net: bridge: vlan: add support for mcast querier global option

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 62938182c35906c0ed4beb7845b93b8ffb937597
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/62938182.failed

Add support to change and retrieve global vlan multicast querier state.
We just need to pass multicast context to br_multicast_set_querier
instead of bridge device and the rest of the logic remains the same.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 62938182c35906c0ed4beb7845b93b8ffb937597)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/if_bridge.h
#	net/bridge/br_multicast.c
#	net/bridge/br_netlink.c
#	net/bridge/br_private.h
#	net/bridge/br_sysfs_br.c
#	net/bridge/br_vlan_options.c
diff --cc include/uapi/linux/if_bridge.h
index d643fa57361d,03fd14a4e377..000000000000
--- a/include/uapi/linux/if_bridge.h
+++ b/include/uapi/linux/if_bridge.h
@@@ -491,6 -548,19 +491,22 @@@ enum 
  	BRIDGE_VLANDB_GOPTS_UNSPEC,
  	BRIDGE_VLANDB_GOPTS_ID,
  	BRIDGE_VLANDB_GOPTS_RANGE,
++<<<<<<< HEAD
++=======
+ 	BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_PAD,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER,
++>>>>>>> 62938182c359 (net: bridge: vlan: add support for mcast querier global option)
  	__BRIDGE_VLANDB_GOPTS_MAX
  };
  #define BRIDGE_VLANDB_GOPTS_MAX (__BRIDGE_VLANDB_GOPTS_MAX - 1)
diff --cc net/bridge/br_multicast.c
index def6f1840985,a780ad8aca37..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -3131,11 -4303,11 +3131,16 @@@ int br_multicast_set_querier(struct net
  
  	val = !!val;
  
++<<<<<<< HEAD
 +	spin_lock_bh(&br->multicast_lock);
 +	if (br_opt_get(br, BROPT_MULTICAST_QUERIER) == val)
++=======
+ 	spin_lock_bh(&brmctx->br->multicast_lock);
+ 	if (brmctx->multicast_querier == val)
++>>>>>>> 62938182c359 (net: bridge: vlan: add support for mcast querier global option)
  		goto unlock;
  
 -	WRITE_ONCE(brmctx->multicast_querier, val);
 +	br_opt_toggle(br, BROPT_MULTICAST_QUERIER, !!val);
  	if (!val)
  		goto unlock;
  
diff --cc net/bridge/br_netlink.c
index 75be8311a010,60616a4380b3..000000000000
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@@ -1536,7 -1576,7 +1537,11 @@@ static int br_fill_info(struct sk_buff 
  	    nla_put_u8(skb, IFLA_BR_MCAST_QUERY_USE_IFADDR,
  		       br_opt_get(br, BROPT_MULTICAST_QUERY_USE_IFADDR)) ||
  	    nla_put_u8(skb, IFLA_BR_MCAST_QUERIER,
++<<<<<<< HEAD
 +		       br_opt_get(br, BROPT_MULTICAST_QUERIER)) ||
++=======
+ 		       br->multicast_ctx.multicast_querier) ||
++>>>>>>> 62938182c359 (net: bridge: vlan: add support for mcast querier global option)
  	    nla_put_u8(skb, IFLA_BR_MCAST_STATS_ENABLED,
  		       br_opt_get(br, BROPT_MULTICAST_STATS_ENABLED)) ||
  	    nla_put_u32(skb, IFLA_BR_MCAST_HASH_ELASTICITY, RHT_ELASTICITY) ||
diff --cc net/bridge/br_private.h
index 30e07225bc94,40477885fb2a..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -729,16 -874,20 +729,22 @@@ void br_multicast_leave_snoopers(struc
  void br_multicast_open(struct net_bridge *br);
  void br_multicast_stop(struct net_bridge *br);
  void br_multicast_dev_del(struct net_bridge *br);
 -void br_multicast_flood(struct net_bridge_mdb_entry *mdst, struct sk_buff *skb,
 -			struct net_bridge_mcast *brmctx,
 -			bool local_rcv, bool local_orig);
 +void br_multicast_flood(struct net_bridge_mdb_entry *mdst,
 +			struct sk_buff *skb, bool local_rcv, bool local_orig);
  int br_multicast_set_router(struct net_bridge *br, unsigned long val);
  int br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val);
++<<<<<<< HEAD
 +int br_multicast_toggle(struct net_bridge *br, unsigned long val);
 +int br_multicast_set_querier(struct net_bridge *br, unsigned long val);
++=======
+ int br_multicast_toggle(struct net_bridge *br, unsigned long val,
+ 			struct netlink_ext_ack *extack);
+ int br_multicast_set_querier(struct net_bridge_mcast *brmctx, unsigned long val);
++>>>>>>> 62938182c359 (net: bridge: vlan: add support for mcast querier global option)
  int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);
 -int br_multicast_set_igmp_version(struct net_bridge_mcast *brmctx,
 -				  unsigned long val);
 +int br_multicast_set_igmp_version(struct net_bridge *br, unsigned long val);
  #if IS_ENABLED(CONFIG_IPV6)
 -int br_multicast_set_mld_version(struct net_bridge_mcast *brmctx,
 -				 unsigned long val);
 +int br_multicast_set_mld_version(struct net_bridge *br, unsigned long val);
  #endif
  struct net_bridge_mdb_entry *
  br_mdb_ip_get(struct net_bridge *br, struct br_ip *dst);
@@@ -787,8 -1028,8 +793,13 @@@ __br_multicast_querier_exists(struct ne
  {
  	bool own_querier_enabled;
  
++<<<<<<< HEAD
 +	if (br_opt_get(br, BROPT_MULTICAST_QUERIER)) {
 +		if (is_ipv6 && !br_opt_get(br, BROPT_HAS_IPV6_ADDR))
++=======
+ 	if (brmctx->multicast_querier) {
+ 		if (is_ipv6 && !br_opt_get(brmctx->br, BROPT_HAS_IPV6_ADDR))
++>>>>>>> 62938182c359 (net: bridge: vlan: add support for mcast querier global option)
  			own_querier_enabled = false;
  		else
  			own_querier_enabled = true;
@@@ -822,21 -1094,124 +833,128 @@@ static inline int br_multicast_igmp_typ
  	return BR_INPUT_SKB_CB(skb)->igmp;
  }
  
 -static inline unsigned long br_multicast_lmqt(const struct net_bridge_mcast *brmctx)
 +static inline unsigned long br_multicast_lmqt(const struct net_bridge *br)
  {
 -	return brmctx->multicast_last_member_interval *
 -	       brmctx->multicast_last_member_count;
 +	return br->multicast_last_member_interval *
 +	       br->multicast_last_member_count;
  }
  
 -static inline unsigned long br_multicast_gmi(const struct net_bridge_mcast *brmctx)
 +static inline unsigned long br_multicast_gmi(const struct net_bridge *br)
  {
  	/* use the RFC default of 2 for QRV */
++<<<<<<< HEAD
 +	return 2 * br->multicast_query_interval +
 +	       br->multicast_query_response_interval;
++=======
+ 	return 2 * brmctx->multicast_query_interval +
+ 	       brmctx->multicast_query_response_interval;
+ }
+ 
+ static inline bool
+ br_multicast_ctx_is_vlan(const struct net_bridge_mcast *brmctx)
+ {
+ 	return !!brmctx->vlan;
+ }
+ 
+ static inline bool
+ br_multicast_port_ctx_is_vlan(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	return !!pmctx->vlan;
+ }
+ 
+ static inline struct net_bridge_mcast *
+ br_multicast_port_ctx_get_global(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	if (!br_multicast_port_ctx_is_vlan(pmctx))
+ 		return &pmctx->port->br->multicast_ctx;
+ 	else
+ 		return &pmctx->vlan->brvlan->br_mcast_ctx;
+ }
+ 
+ static inline bool
+ br_multicast_ctx_vlan_global_disabled(const struct net_bridge_mcast *brmctx)
+ {
+ 	return br_opt_get(brmctx->br, BROPT_MCAST_VLAN_SNOOPING_ENABLED) &&
+ 	       br_multicast_ctx_is_vlan(brmctx) &&
+ 	       !(brmctx->vlan->priv_flags & BR_VLFLAG_GLOBAL_MCAST_ENABLED);
+ }
+ 
+ static inline bool
+ br_multicast_ctx_vlan_disabled(const struct net_bridge_mcast *brmctx)
+ {
+ 	return br_multicast_ctx_is_vlan(brmctx) &&
+ 	       !(brmctx->vlan->priv_flags & BR_VLFLAG_MCAST_ENABLED);
+ }
+ 
+ static inline bool
+ br_multicast_port_ctx_vlan_disabled(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	return br_multicast_port_ctx_is_vlan(pmctx) &&
+ 	       !(pmctx->vlan->priv_flags & BR_VLFLAG_MCAST_ENABLED);
+ }
+ 
+ static inline bool
+ br_multicast_port_ctx_state_disabled(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	return pmctx->port->state == BR_STATE_DISABLED ||
+ 	       (br_multicast_port_ctx_is_vlan(pmctx) &&
+ 		(br_multicast_port_ctx_vlan_disabled(pmctx) ||
+ 		 pmctx->vlan->state == BR_STATE_DISABLED));
+ }
+ 
+ static inline bool
+ br_multicast_port_ctx_state_stopped(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	return br_multicast_port_ctx_state_disabled(pmctx) ||
+ 	       pmctx->port->state == BR_STATE_BLOCKING ||
+ 	       (br_multicast_port_ctx_is_vlan(pmctx) &&
+ 		pmctx->vlan->state == BR_STATE_BLOCKING);
+ }
+ 
+ static inline bool
+ br_multicast_ctx_options_equal(const struct net_bridge_mcast *brmctx1,
+ 			       const struct net_bridge_mcast *brmctx2)
+ {
+ 	return brmctx1->multicast_igmp_version ==
+ 	       brmctx2->multicast_igmp_version &&
+ 	       brmctx1->multicast_last_member_count ==
+ 	       brmctx2->multicast_last_member_count &&
+ 	       brmctx1->multicast_startup_query_count ==
+ 	       brmctx2->multicast_startup_query_count &&
+ 	       brmctx1->multicast_last_member_interval ==
+ 	       brmctx2->multicast_last_member_interval &&
+ 	       brmctx1->multicast_membership_interval ==
+ 	       brmctx2->multicast_membership_interval &&
+ 	       brmctx1->multicast_querier_interval ==
+ 	       brmctx2->multicast_querier_interval &&
+ 	       brmctx1->multicast_query_interval ==
+ 	       brmctx2->multicast_query_interval &&
+ 	       brmctx1->multicast_query_response_interval ==
+ 	       brmctx2->multicast_query_response_interval &&
+ 	       brmctx1->multicast_startup_query_interval ==
+ 	       brmctx2->multicast_startup_query_interval &&
+ 	       brmctx1->multicast_querier == brmctx2->multicast_querier &&
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	       brmctx1->multicast_mld_version ==
+ 	       brmctx2->multicast_mld_version &&
+ #endif
+ 	       true;
+ }
+ 
+ static inline bool
+ br_multicast_ctx_matches_vlan_snooping(const struct net_bridge_mcast *brmctx)
+ {
+ 	bool vlan_snooping_enabled;
+ 
+ 	vlan_snooping_enabled = !!br_opt_get(brmctx->br,
+ 					     BROPT_MCAST_VLAN_SNOOPING_ENABLED);
+ 
+ 	return !!(vlan_snooping_enabled == br_multicast_ctx_is_vlan(brmctx));
++>>>>>>> 62938182c359 (net: bridge: vlan: add support for mcast querier global option)
  }
  #else
 -static inline int br_multicast_rcv(struct net_bridge_mcast **brmctx,
 -				   struct net_bridge_mcast_port **pmctx,
 -				   struct net_bridge_vlan *vlan,
 +static inline int br_multicast_rcv(struct net_bridge *br,
 +				   struct net_bridge_port *port,
  				   struct sk_buff *skb,
  				   u16 vid)
  {
diff --cc net/bridge/br_sysfs_br.c
index 52b9892eb49f,e1234bd8d5a0..000000000000
--- a/net/bridge/br_sysfs_br.c
+++ b/net/bridge/br_sysfs_br.c
@@@ -391,7 -447,13 +391,17 @@@ static ssize_t multicast_querier_show(s
  				      char *buf)
  {
  	struct net_bridge *br = to_bridge(d);
++<<<<<<< HEAD
 +	return sprintf(buf, "%d\n", br_opt_get(br, BROPT_MULTICAST_QUERIER));
++=======
+ 	return sprintf(buf, "%d\n", br->multicast_ctx.multicast_querier);
+ }
+ 
+ static int set_multicast_querier(struct net_bridge *br, unsigned long val,
+ 				 struct netlink_ext_ack *extack)
+ {
+ 	return br_multicast_set_querier(&br->multicast_ctx, val);
++>>>>>>> 62938182c359 (net: bridge: vlan: add support for mcast querier global option)
  }
  
  static ssize_t multicast_querier_store(struct device *d,
diff --cc net/bridge/br_vlan_options.c
index 827bfc319599,0d0db8ddae45..000000000000
--- a/net/bridge/br_vlan_options.c
+++ b/net/bridge/br_vlan_options.c
@@@ -281,6 -286,51 +281,54 @@@ bool br_vlan_global_opts_fill(struct sk
  	    nla_put_u16(skb, BRIDGE_VLANDB_GOPTS_RANGE, vid_range))
  		goto out_err;
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	if (nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING,
+ 		       !!(v_opts->priv_flags & BR_VLFLAG_GLOBAL_MCAST_ENABLED)) ||
+ 	    nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION,
+ 		       v_opts->br_mcast_ctx.multicast_igmp_version) ||
+ 	    nla_put_u32(skb, BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT,
+ 			v_opts->br_mcast_ctx.multicast_last_member_count) ||
+ 	    nla_put_u32(skb, BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT,
+ 			v_opts->br_mcast_ctx.multicast_startup_query_count) ||
+ 	    nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERIER,
+ 		       v_opts->br_mcast_ctx.multicast_querier))
+ 		goto out_err;
+ 
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_last_member_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_membership_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_querier_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_query_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_query_response_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_startup_query_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION,
+ 		       v_opts->br_mcast_ctx.multicast_mld_version))
+ 		goto out_err;
+ #endif
+ #endif
+ 
++>>>>>>> 62938182c359 (net: bridge: vlan: add support for mcast querier global option)
  	nla_nest_end(skb, nest);
  
  	return true;
@@@ -295,6 -345,20 +343,23 @@@ static size_t rtnl_vlan_global_opts_nlm
  	return NLMSG_ALIGN(sizeof(struct br_vlan_msg))
  		+ nla_total_size(0) /* BRIDGE_VLANDB_GLOBAL_OPTIONS */
  		+ nla_total_size(sizeof(u16)) /* BRIDGE_VLANDB_GOPTS_ID */
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION */
+ 		+ nla_total_size(sizeof(u32)) /* BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT */
+ 		+ nla_total_size(sizeof(u32)) /* BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERIER */
+ #endif
++>>>>>>> 62938182c359 (net: bridge: vlan: add support for mcast querier global option)
  		+ nla_total_size(sizeof(u16)); /* BRIDGE_VLANDB_GOPTS_RANGE */
  }
  
@@@ -348,13 -412,122 +413,126 @@@ static int br_vlan_process_global_one_o
  					   bool *changed,
  					   struct netlink_ext_ack *extack)
  {
 -	int err __maybe_unused;
 -
  	*changed = false;
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING]) {
+ 		u8 mc_snooping;
+ 
+ 		mc_snooping = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING]);
+ 		if (br_multicast_toggle_global_vlan(v, !!mc_snooping))
+ 			*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION]) {
+ 		u8 ver;
+ 
+ 		ver = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION]);
+ 		err = br_multicast_set_igmp_version(&v->br_mcast_ctx, ver);
+ 		if (err)
+ 			return err;
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT]) {
+ 		u32 cnt;
+ 
+ 		cnt = nla_get_u32(tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT]);
+ 		v->br_mcast_ctx.multicast_last_member_count = cnt;
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT]) {
+ 		u32 cnt;
+ 
+ 		cnt = nla_get_u32(tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT]);
+ 		v->br_mcast_ctx.multicast_startup_query_count = cnt;
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL]);
+ 		v->br_mcast_ctx.multicast_last_member_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL]);
+ 		v->br_mcast_ctx.multicast_membership_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL]);
+ 		v->br_mcast_ctx.multicast_querier_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL]);
+ 		v->br_mcast_ctx.multicast_query_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL]);
+ 		v->br_mcast_ctx.multicast_query_response_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL]);
+ 		v->br_mcast_ctx.multicast_startup_query_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER]) {
+ 		u8 val;
+ 
+ 		val = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER]);
+ 		err = br_multicast_set_querier(&v->br_mcast_ctx, val);
+ 		if (err)
+ 			return err;
+ 		*changed = true;
+ 	}
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION]) {
+ 		u8 ver;
+ 
+ 		ver = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION]);
+ 		err = br_multicast_set_mld_version(&v->br_mcast_ctx, ver);
+ 		if (err)
+ 			return err;
+ 		*changed = true;
+ 	}
+ #endif
+ #endif
+ 
++>>>>>>> 62938182c359 (net: bridge: vlan: add support for mcast querier global option)
  	return 0;
  }
  
  static const struct nla_policy br_vlan_db_gpol[BRIDGE_VLANDB_GOPTS_MAX + 1] = {
  	[BRIDGE_VLANDB_GOPTS_ID]	= { .type = NLA_U16 },
  	[BRIDGE_VLANDB_GOPTS_RANGE]	= { .type = NLA_U16 },
++<<<<<<< HEAD
++=======
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL]	= { .type = NLA_U64 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT]	= { .type = NLA_U32 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT]	= { .type = NLA_U32 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL]	= { .type = NLA_U64 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL]	= { .type = NLA_U64 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL]	= { .type = NLA_U64 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL]	= { .type = NLA_U64 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL] = { .type = NLA_U64 },
++>>>>>>> 62938182c359 (net: bridge: vlan: add support for mcast querier global option)
  };
  
  int br_vlan_rtm_process_global_options(struct net_device *dev,
* Unmerged path include/uapi/linux/if_bridge.h
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_netlink.c
* Unmerged path net/bridge/br_private.h
* Unmerged path net/bridge/br_sysfs_br.c
* Unmerged path net/bridge/br_vlan_options.c
