rcu: Panic after fixed number of stalls

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author chao <chao@eero.com>
commit dfe564045c653d9e6969ccca57a8a04771d333f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/dfe56404.failed

Some stalls are transient, so that system fully recovers.  This commit
therefore allows users to configure the number of stalls that must happen
in order to trigger kernel panic.

	Signed-off-by: chao <chao@eero.com>
	Signed-off-by: Paul E. McKenney <paulmck@kernel.org>
(cherry picked from commit dfe564045c653d9e6969ccca57a8a04771d333f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sysctl.c
diff --cc kernel/sysctl.c
index 46d04fd7d653,c9fbdd848138..000000000000
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@@ -1261,78 -2072,107 +1261,103 @@@ static struct ctl_table kern_table[] = 
  		.extra1		= SYSCTL_ONE,
  		.extra2		= SYSCTL_ONE,
  	},
 -#endif
 -#ifdef CONFIG_UEVENT_HELPER
  	{
 -		.procname	= "hotplug",
 -		.data		= &uevent_helper,
 -		.maxlen		= UEVENT_HELPER_PATH_LEN,
 +		.procname	= "bpf_stats_enabled",
 +		.data		= &bpf_stats_enabled_key.key,
 +		.maxlen		= sizeof(bpf_stats_enabled_key),
  		.mode		= 0644,
 -		.proc_handler	= proc_dostring,
 -	},
 -#endif
 -#ifdef CONFIG_CHR_DEV_SG
 -	{
 -		.procname	= "sg-big-buff",
 -		.data		= &sg_big_buff,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0444,
 -		.proc_handler	= proc_dointvec,
 +		.proc_handler	= bpf_stats_handler,
  	},
  #endif
 -#ifdef CONFIG_BSD_PROCESS_ACCT
 +#if defined(CONFIG_TREE_RCU)
  	{
 -		.procname	= "acct",
 -		.data		= &acct_parm,
 -		.maxlen		= 3*sizeof(int),
 +		.procname	= "panic_on_rcu_stall",
 +		.data		= &sysctl_panic_on_rcu_stall,
 +		.maxlen		= sizeof(sysctl_panic_on_rcu_stall),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 +		.proc_handler	= proc_dointvec_minmax,
 +		.extra1		= SYSCTL_ZERO,
 +		.extra2		= SYSCTL_ONE,
  	},
  #endif
 -#ifdef CONFIG_MAGIC_SYSRQ
++<<<<<<< HEAD
++=======
++#if defined(CONFIG_TREE_RCU)
+ 	{
 -		.procname	= "sysrq",
 -		.data		= NULL,
 -		.maxlen		= sizeof (int),
++		.procname	= "max_rcu_stall_to_panic",
++		.data		= &sysctl_max_rcu_stall_to_panic,
++		.maxlen		= sizeof(sysctl_max_rcu_stall_to_panic),
+ 		.mode		= 0644,
 -		.proc_handler	= sysrq_sysctl_handler,
++		.proc_handler	= proc_dointvec_minmax,
++		.extra1		= SYSCTL_ONE,
++		.extra2		= SYSCTL_INT_MAX,
+ 	},
+ #endif
 -#ifdef CONFIG_PROC_SYSCTL
++#ifdef CONFIG_STACKLEAK_RUNTIME_DISABLE
+ 	{
 -		.procname	= "cad_pid",
++		.procname	= "stack_erasing",
+ 		.data		= NULL,
 -		.maxlen		= sizeof (int),
++		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
 -		.proc_handler	= proc_do_cad_pid,
++		.proc_handler	= stack_erasing_sysctl,
++		.extra1		= SYSCTL_ZERO,
++		.extra2		= SYSCTL_ONE,
+ 	},
+ #endif
++>>>>>>> dfe564045c65 (rcu: Panic after fixed number of stalls)
 +	{ }
 +};
 +
 +static struct ctl_table vm_table[] = {
  	{
 -		.procname	= "threads-max",
 -		.data		= NULL,
 -		.maxlen		= sizeof(int),
 +		.procname	= "overcommit_memory",
 +		.data		= &sysctl_overcommit_memory,
 +		.maxlen		= sizeof(sysctl_overcommit_memory),
  		.mode		= 0644,
 -		.proc_handler	= sysctl_max_threads,
 -	},
 -	{
 -		.procname	= "random",
 -		.mode		= 0555,
 -		.child		= random_table,
 +		.proc_handler	= proc_dointvec_minmax,
 +		.extra1		= SYSCTL_ZERO,
 +		.extra2		= &two,
  	},
  	{
 -		.procname	= "usermodehelper",
 -		.mode		= 0555,
 -		.child		= usermodehelper_table,
 +		.procname	= "panic_on_oom",
 +		.data		= &sysctl_panic_on_oom,
 +		.maxlen		= sizeof(sysctl_panic_on_oom),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec_minmax,
 +		.extra1		= SYSCTL_ZERO,
 +		.extra2		= &two,
  	},
 -#ifdef CONFIG_FW_LOADER_USER_HELPER
  	{
 -		.procname	= "firmware_config",
 -		.mode		= 0555,
 -		.child		= firmware_config_table,
 +		.procname	= "oom_kill_allocating_task",
 +		.data		= &sysctl_oom_kill_allocating_task,
 +		.maxlen		= sizeof(sysctl_oom_kill_allocating_task),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec,
  	},
 -#endif
  	{
 -		.procname	= "overflowuid",
 -		.data		= &overflowuid,
 -		.maxlen		= sizeof(int),
 +		.procname	= "oom_dump_tasks",
 +		.data		= &sysctl_oom_dump_tasks,
 +		.maxlen		= sizeof(sysctl_oom_dump_tasks),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &minolduid,
 -		.extra2		= &maxolduid,
 +		.proc_handler	= proc_dointvec,
  	},
  	{
 -		.procname	= "overflowgid",
 -		.data		= &overflowgid,
 -		.maxlen		= sizeof(int),
 +		.procname	= "overcommit_ratio",
 +		.data		= &sysctl_overcommit_ratio,
 +		.maxlen		= sizeof(sysctl_overcommit_ratio),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &minolduid,
 -		.extra2		= &maxolduid,
 +		.proc_handler	= overcommit_ratio_handler,
  	},
 -#ifdef CONFIG_S390
  	{
 -		.procname	= "userprocess_debug",
 -		.data		= &show_unhandled_signals,
 -		.maxlen		= sizeof(int),
 +		.procname	= "overcommit_kbytes",
 +		.data		= &sysctl_overcommit_kbytes,
 +		.maxlen		= sizeof(sysctl_overcommit_kbytes),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 +		.proc_handler	= overcommit_kbytes_handler,
  	},
 -#endif
 -#ifdef CONFIG_SMP
  	{
 -		.procname	= "oops_all_cpu_backtrace",
 -		.data		= &sysctl_oops_all_cpu_backtrace,
 +		.procname	= "page-cluster", 
 +		.data		= &page_cluster,
  		.maxlen		= sizeof(int),
  		.mode		= 0644,
  		.proc_handler	= proc_dointvec_minmax,
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 223c86c5b1cb..bc2860a925b9 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -527,6 +527,7 @@ extern int panic_on_warn;
 extern unsigned long panic_on_taint;
 extern bool panic_on_taint_nousertaint;
 extern int sysctl_panic_on_rcu_stall;
+extern int sysctl_max_rcu_stall_to_panic;
 extern int sysctl_panic_on_stackoverflow;
 
 extern bool crash_kexec_post_notifiers;
diff --git a/kernel/rcu/tree_stall.h b/kernel/rcu/tree_stall.h
index 7282ee37edd7..28d5a22a04a6 100644
--- a/kernel/rcu/tree_stall.h
+++ b/kernel/rcu/tree_stall.h
@@ -13,6 +13,7 @@
 
 /* panic() on RCU Stall sysctl. */
 int sysctl_panic_on_rcu_stall __read_mostly;
+int sysctl_max_rcu_stall_to_panic __read_mostly;
 
 #ifdef CONFIG_PROVE_RCU
 #define RCU_STALL_DELAY_DELTA		(5 * HZ)
@@ -106,6 +107,11 @@ early_initcall(check_cpu_stall_init);
 /* If so specified via sysctl, panic, yielding cleaner stall-warning output. */
 static void panic_on_rcu_stall(void)
 {
+	static int cpu_stall;
+
+	if (++cpu_stall < sysctl_max_rcu_stall_to_panic)
+		return;
+
 	if (sysctl_panic_on_rcu_stall)
 		panic("RCU Stall\n");
 }
* Unmerged path kernel/sysctl.c
