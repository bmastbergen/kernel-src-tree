perf/x86: Fix out of bound MSR access

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit f4b4b45652578357031fbbef7f7a1b04f6fa2dc3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/f4b4b456.failed

On Wed, Jul 28, 2021 at 12:49:43PM -0400, Vince Weaver wrote:
> [32694.087403] unchecked MSR access error: WRMSR to 0x318 (tried to write 0x0000000000000000) at rIP: 0xffffffff8106f854 (native_write_msr+0x4/0x20)
> [32694.101374] Call Trace:
> [32694.103974]  perf_clear_dirty_counters+0x86/0x100

The problem being that it doesn't filter out all fake counters, in
specific the above (erroneously) tries to use FIXED_BTS. Limit the
fixed counters indexes to the hardware supplied number.

	Reported-by: Vince Weaver <vincent.weaver@maine.edu>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Tested-by: Vince Weaver <vincent.weaver@maine.edu>
	Tested-by: Like Xu <likexu@tencent.com>
Link: https://lkml.kernel.org/r/YQJxka3dxgdIdebG@hirez.programming.kicks-ass.net
(cherry picked from commit f4b4b45652578357031fbbef7f7a1b04f6fa2dc3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/events/core.c
diff --cc arch/x86/events/core.c
index e5de91e5b10c,3092fbf9dbe4..000000000000
--- a/arch/x86/events/core.c
+++ b/arch/x86/events/core.c
@@@ -2394,9 -2476,31 +2394,35 @@@ static int x86_pmu_event_init(struct pe
  	return err;
  }
  
 -void perf_clear_dirty_counters(void)
 +static void refresh_pce(void *ignored)
  {
++<<<<<<< HEAD
 +	load_mm_cr4(this_cpu_read(cpu_tlbstate.loaded_mm));
++=======
+ 	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
+ 	int i;
+ 
+ 	 /* Don't need to clear the assigned counter. */
+ 	for (i = 0; i < cpuc->n_events; i++)
+ 		__clear_bit(cpuc->assign[i], cpuc->dirty);
+ 
+ 	if (bitmap_empty(cpuc->dirty, X86_PMC_IDX_MAX))
+ 		return;
+ 
+ 	for_each_set_bit(i, cpuc->dirty, X86_PMC_IDX_MAX) {
+ 		if (i >= INTEL_PMC_IDX_FIXED) {
+ 			/* Metrics and fake events don't have corresponding HW counters. */
+ 			if ((i - INTEL_PMC_IDX_FIXED) >= hybrid(cpuc->pmu, num_counters_fixed))
+ 				continue;
+ 
+ 			wrmsrl(MSR_ARCH_PERFMON_FIXED_CTR0 + (i - INTEL_PMC_IDX_FIXED), 0);
+ 		} else {
+ 			wrmsrl(x86_pmu_event_addr(i), 0);
+ 		}
+ 	}
+ 
+ 	bitmap_zero(cpuc->dirty, X86_PMC_IDX_MAX);
++>>>>>>> f4b4b4565257 (perf/x86: Fix out of bound MSR access)
  }
  
  static void x86_pmu_event_mapped(struct perf_event *event, struct mm_struct *mm)
* Unmerged path arch/x86/events/core.c
