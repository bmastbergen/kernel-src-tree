mm: memcontrol: rename lruvec_holds_page_lru_lock to page_matches_lruvec

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Muchun Song <songmuchun@bytedance.com>
commit 7467c39128bda1d58af08aaeb0c7ba54d0ec87ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/7467c391.failed

lruvec_holds_page_lru_lock() doesn't check anything about locking and is
used to check whether the page belongs to the lruvec.  So rename it to
page_matches_lruvec().

Link: https://lkml.kernel.org/r/20210417043538.9793-6-songmuchun@bytedance.com
	Signed-off-by: Muchun Song <songmuchun@bytedance.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
	Reviewed-by: Shakeel Butt <shakeelb@google.com>
	Cc: Roman Gushchin <guro@fb.com>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Cc: Xiongchun Duan <duanxiongchun@bytedance.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 7467c39128bda1d58af08aaeb0c7ba54d0ec87ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/memcontrol.h
#	mm/vmscan.c
diff --cc include/linux/memcontrol.h
index cc3d9b32271f,0ce97eff79e2..000000000000
--- a/include/linux/memcontrol.h
+++ b/include/linux/memcontrol.h
@@@ -1561,6 -1492,13 +1561,16 @@@ static inline void unlock_page_lruvec_i
  	spin_unlock_irqrestore(&lruvec->lru_lock, flags);
  }
  
++<<<<<<< HEAD
++=======
+ /* Test requires a stable page->memcg binding, see page_memcg() */
+ static inline bool page_matches_lruvec(struct page *page, struct lruvec *lruvec)
+ {
+ 	return lruvec_pgdat(lruvec) == page_pgdat(page) &&
+ 	       lruvec_memcg(lruvec) == page_memcg(page);
+ }
+ 
++>>>>>>> 7467c39128bd (mm: memcontrol: rename lruvec_holds_page_lru_lock to page_matches_lruvec)
  /* Don't lock again iff page's lruvec locked */
  static inline struct lruvec *relock_page_lruvec_irq(struct page *page,
  		struct lruvec *locked_lruvec)
diff --cc mm/vmscan.c
index f5da07494c0e,ec93d4fd5a6b..000000000000
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@@ -2066,8 -2063,8 +2066,13 @@@ static unsigned noinline_for_stack move
  		 * All pages were isolated from the same lruvec (and isolation
  		 * inhibits memcg migration).
  		 */
++<<<<<<< HEAD
 +		VM_BUG_ON_PAGE(!lruvec_holds_page_lru_lock(page, lruvec), page);
 +		add_page_to_lru_list(page, lruvec, page_lru(page));
++=======
+ 		VM_BUG_ON_PAGE(!page_matches_lruvec(page, lruvec), page);
+ 		add_page_to_lru_list(page, lruvec);
++>>>>>>> 7467c39128bd (mm: memcontrol: rename lruvec_holds_page_lru_lock to page_matches_lruvec)
  		nr_pages = thp_nr_pages(page);
  		nr_moved += nr_pages;
  		if (PageActive(page))
* Unmerged path include/linux/memcontrol.h
* Unmerged path mm/vmscan.c
