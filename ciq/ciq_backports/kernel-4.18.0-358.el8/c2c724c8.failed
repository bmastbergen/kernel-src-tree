driver core: Add fw_devlink_parse_fwtree()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Saravana Kannan <saravanak@google.com>
commit c2c724c868c42c5166bf7aa644dd0a0c8d30b47a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/c2c724c8.failed

This function is a wrapper around fwnode_operations.add_links().

This function parses each node in a fwnode tree and create fwnode links
for each of those nodes. The information for creating the fwnode links
(the supplier and consumer fwnode) is obtained by parsing the properties
in each of the fwnodes.

This function also ensures that no fwnode is parsed more than once by
marking the fwnodes as parsed.

	Signed-off-by: Saravana Kannan <saravanak@google.com>
Link: https://lore.kernel.org/r/20201121020232.908850-13-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit c2c724c868c42c5166bf7aa644dd0a0c8d30b47a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/fwnode.h
diff --cc include/linux/fwnode.h
index e1e5a96e9010,ffa9129182a6..000000000000
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@@ -21,7 -25,17 +28,21 @@@ struct device
  struct fwnode_handle {
  	struct fwnode_handle *secondary;
  	const struct fwnode_operations *ops;
++<<<<<<< HEAD
 +	RH_KABI_EXTEND(struct device *dev)
++=======
+ 	struct device *dev;
+ 	struct list_head suppliers;
+ 	struct list_head consumers;
+ 	u8 flags;
+ };
+ 
+ struct fwnode_link {
+ 	struct fwnode_handle *supplier;
+ 	struct list_head s_hook;
+ 	struct fwnode_handle *consumer;
+ 	struct list_head c_hook;
++>>>>>>> c2c724c868c4 (driver core: Add fw_devlink_parse_fwtree())
  };
  
  /**
diff --git a/drivers/base/core.c b/drivers/base/core.c
index 8db14fc9c3aa..262e6631cedd 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1439,6 +1439,25 @@ static bool fw_devlink_is_permissive(void)
 	return fw_devlink_flags == DL_FLAG_SYNC_STATE_ONLY;
 }
 
+static void fw_devlink_parse_fwnode(struct fwnode_handle *fwnode)
+{
+	if (fwnode->flags & FWNODE_FLAG_LINKS_ADDED)
+		return;
+
+	fwnode_call_int_op(fwnode, add_links, NULL);
+	fwnode->flags |= FWNODE_FLAG_LINKS_ADDED;
+}
+
+static void fw_devlink_parse_fwtree(struct fwnode_handle *fwnode)
+{
+	struct fwnode_handle *child = NULL;
+
+	fw_devlink_parse_fwnode(fwnode);
+
+	while ((child = fwnode_get_next_available_child_node(fwnode, child)))
+		fw_devlink_parse_fwtree(child);
+}
+
 static void fw_devlink_link_device(struct device *dev)
 {
 	int fw_ret;
* Unmerged path include/linux/fwnode.h
