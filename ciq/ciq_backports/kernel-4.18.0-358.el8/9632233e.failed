net: bridge: multicast: factor out port multicast context

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 9632233e7de8da43711bb7cd3e054af32fedcc38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/9632233e.failed

Factor out the port's multicast context into a separate structure which
will later be shared for per-port,vlan context. No functional changes
intended. We need the structure even if bridge multicast is not defined
to pass down as pointer to forwarding functions.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9632233e7de8da43711bb7cd3e054af32fedcc38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_mdb.c
#	net/bridge/br_multicast.c
#	net/bridge/br_netlink.c
#	net/bridge/br_private.h
diff --cc net/bridge/br_mdb.c
index 5621f5510fd4,64619dc65bc8..000000000000
--- a/net/bridge/br_mdb.c
+++ b/net/bridge/br_mdb.c
@@@ -16,6 -16,35 +16,38 @@@
  
  #include "br_private.h"
  
++<<<<<<< HEAD
++=======
+ static bool br_rports_have_mc_router(struct net_bridge *br)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	return !hlist_empty(&br->ip4_mc_router_list) ||
+ 	       !hlist_empty(&br->ip6_mc_router_list);
+ #else
+ 	return !hlist_empty(&br->ip4_mc_router_list);
+ #endif
+ }
+ 
+ static bool
+ br_ip4_rports_get_timer(struct net_bridge_port *port, unsigned long *timer)
+ {
+ 	*timer = br_timer_value(&port->multicast_ctx.ip4_mc_router_timer);
+ 	return !hlist_unhashed(&port->multicast_ctx.ip4_rlist);
+ }
+ 
+ static bool
+ br_ip6_rports_get_timer(struct net_bridge_port *port, unsigned long *timer)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	*timer = br_timer_value(&port->multicast_ctx.ip6_mc_router_timer);
+ 	return !hlist_unhashed(&port->multicast_ctx.ip6_rlist);
+ #else
+ 	*timer = 0;
+ 	return false;
+ #endif
+ }
+ 
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
  static int br_rports_fill_info(struct sk_buff *skb, struct netlink_callback *cb,
  			       struct net_device *dev)
  {
@@@ -36,11 -73,13 +68,11 @@@
  		port_nest = nla_nest_start_noflag(skb, MDBA_ROUTER_PORT);
  		if (!port_nest)
  			goto fail;
 -
  		if (nla_put_nohdr(skb, sizeof(u32), &p->dev->ifindex) ||
  		    nla_put_u32(skb, MDBA_ROUTER_PATTR_TIMER,
 -				max(ip4_timer, ip6_timer)) ||
 +				br_timer_value(&p->multicast_router_timer)) ||
  		    nla_put_u8(skb, MDBA_ROUTER_PATTR_TYPE,
- 			       p->multicast_router) ||
+ 			       p->multicast_ctx.multicast_router) ||
  		    (have_ip4_mc_rtr &&
  		     nla_put_u32(skb, MDBA_ROUTER_PATTR_INET_TIMER,
  				 ip4_timer)) ||
diff --cc net/bridge/br_multicast.c
index def6f1840985,3abb673ee4ee..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -947,23 -1357,66 +947,85 @@@ static int br_ip6_multicast_add_group(s
  }
  #endif
  
++<<<<<<< HEAD
 +static void br_multicast_router_expired(struct timer_list *t)
 +{
 +	struct net_bridge_port *port =
 +			from_timer(port, t, multicast_router_timer);
 +	struct net_bridge *br = port->br;
 +
 +	spin_lock(&br->multicast_lock);
 +	if (port->multicast_router == MDB_RTR_TYPE_DISABLED ||
 +	    port->multicast_router == MDB_RTR_TYPE_PERM ||
 +	    timer_pending(&port->multicast_router_timer))
 +		goto out;
 +
 +	__del_port_router(port);
++=======
+ static bool br_multicast_rport_del(struct hlist_node *rlist)
+ {
+ 	if (hlist_unhashed(rlist))
+ 		return false;
+ 
+ 	hlist_del_init_rcu(rlist);
+ 	return true;
+ }
+ 
+ static bool br_ip4_multicast_rport_del(struct net_bridge_port *p)
+ {
+ 	return br_multicast_rport_del(&p->multicast_ctx.ip4_rlist);
+ }
+ 
+ static bool br_ip6_multicast_rport_del(struct net_bridge_port *p)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	return br_multicast_rport_del(&p->multicast_ctx.ip6_rlist);
+ #else
+ 	return false;
+ #endif
+ }
+ 
+ static void br_multicast_router_expired(struct net_bridge_mcast_port *pmctx,
+ 					struct timer_list *t,
+ 					struct hlist_node *rlist)
+ {
+ 	struct net_bridge *br = pmctx->port->br;
+ 	bool del;
+ 
+ 	spin_lock(&br->multicast_lock);
+ 	if (pmctx->multicast_router == MDB_RTR_TYPE_DISABLED ||
+ 	    pmctx->multicast_router == MDB_RTR_TYPE_PERM ||
+ 	    timer_pending(t))
+ 		goto out;
+ 
+ 	del = br_multicast_rport_del(rlist);
+ 	br_multicast_rport_del_notify(pmctx->port, del);
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
  out:
  	spin_unlock(&br->multicast_lock);
  }
  
++<<<<<<< HEAD
++=======
+ static void br_ip4_multicast_router_expired(struct timer_list *t)
+ {
+ 	struct net_bridge_mcast_port *pmctx = from_timer(pmctx, t,
+ 							 ip4_mc_router_timer);
+ 
+ 	br_multicast_router_expired(pmctx, t, &pmctx->ip4_rlist);
+ }
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static void br_ip6_multicast_router_expired(struct timer_list *t)
+ {
+ 	struct net_bridge_mcast_port *pmctx = from_timer(pmctx, t,
+ 							 ip6_mc_router_timer);
+ 
+ 	br_multicast_router_expired(pmctx, t, &pmctx->ip6_rlist);
+ }
+ #endif
+ 
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
  static void br_mc_router_state_change(struct net_bridge *p,
  				      bool is_mc_router)
  {
@@@ -1086,9 -1555,9 +1148,9 @@@ static void br_multicast_send_query(str
  	    !br_opt_get(br, BROPT_MULTICAST_QUERIER))
  		return;
  
 -	memset(&br_group.dst, 0, sizeof(br_group.dst));
 +	memset(&br_group.u, 0, sizeof(br_group.u));
  
- 	if (port ? (own_query == &port->ip4_own_query) :
+ 	if (port ? (own_query == &port->multicast_ctx.ip4_own_query) :
  		   (own_query == &br->ip4_own_query)) {
  		other_query = &br->ip4_other_query;
  		br_group.proto = htons(ETH_P_IP);
@@@ -1195,23 -1667,47 +1259,62 @@@ static void br_mc_disabled_update(struc
  		.u.mc_disabled = !value,
  	};
  
 -	return switchdev_port_attr_set(dev, &attr, extack);
 +	switchdev_port_attr_set(dev, &attr);
  }
  
+ static void br_multicast_port_ctx_init(struct net_bridge_port *port,
+ 				       struct net_bridge_mcast_port *pmctx)
+ {
+ 	pmctx->port = port;
+ 	pmctx->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
+ 	timer_setup(&pmctx->ip4_mc_router_timer,
+ 		    br_ip4_multicast_router_expired, 0);
+ 	timer_setup(&pmctx->ip4_own_query.timer,
+ 		    br_ip4_multicast_port_query_expired, 0);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	timer_setup(&pmctx->ip6_mc_router_timer,
+ 		    br_ip6_multicast_router_expired, 0);
+ 	timer_setup(&pmctx->ip6_own_query.timer,
+ 		    br_ip6_multicast_port_query_expired, 0);
+ #endif
+ }
+ 
+ static void br_multicast_port_ctx_deinit(struct net_bridge_mcast_port *pmctx)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	del_timer_sync(&pmctx->ip6_mc_router_timer);
+ #endif
+ 	del_timer_sync(&pmctx->ip4_mc_router_timer);
+ }
+ 
  int br_multicast_add_port(struct net_bridge_port *port)
  {
++<<<<<<< HEAD
 +	port->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
 +
 +	timer_setup(&port->multicast_router_timer,
 +		    br_multicast_router_expired, 0);
 +	timer_setup(&port->ip4_own_query.timer,
 +		    br_ip4_multicast_port_query_expired, 0);
 +#if IS_ENABLED(CONFIG_IPV6)
 +	timer_setup(&port->ip6_own_query.timer,
 +		    br_ip6_multicast_port_query_expired, 0);
 +#endif
 +	br_mc_disabled_update(port->dev,
 +			      br_opt_get(port->br, BROPT_MULTICAST_ENABLED));
++=======
+ 	int err;
+ 
+ 	port->multicast_eht_hosts_limit = BR_MCAST_DEFAULT_EHT_HOSTS_LIMIT;
+ 	br_multicast_port_ctx_init(port, &port->multicast_ctx);
+ 
+ 	err = br_mc_disabled_update(port->dev,
+ 				    br_opt_get(port->br,
+ 					       BROPT_MULTICAST_ENABLED),
+ 				    NULL);
+ 	if (err && err != -EOPNOTSUPP)
+ 		return err;
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
  
  	port->mcast_stats = netdev_alloc_pcpu_stats(struct bridge_mcast_stats);
  	if (!port->mcast_stats)
@@@ -1234,7 -1730,7 +1337,11 @@@ void br_multicast_del_port(struct net_b
  	hlist_move_list(&br->mcast_gc_list, &deleted_head);
  	spin_unlock_bh(&br->multicast_lock);
  	br_multicast_gc(&deleted_head);
++<<<<<<< HEAD
 +	del_timer_sync(&port->multicast_router_timer);
++=======
+ 	br_multicast_port_ctx_deinit(&port->multicast_ctx);
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
  	free_percpu(port->mcast_stats);
  }
  
@@@ -1254,13 -1750,14 +1361,20 @@@ static void __br_multicast_enable_port(
  	if (!br_opt_get(br, BROPT_MULTICAST_ENABLED) || !netif_running(br->dev))
  		return;
  
- 	br_multicast_enable(&port->ip4_own_query);
+ 	br_multicast_enable(&port->multicast_ctx.ip4_own_query);
  #if IS_ENABLED(CONFIG_IPV6)
- 	br_multicast_enable(&port->ip6_own_query);
+ 	br_multicast_enable(&port->multicast_ctx.ip6_own_query);
  #endif
++<<<<<<< HEAD
 +	if (port->multicast_router == MDB_RTR_TYPE_PERM &&
 +	    hlist_unhashed(&port->rlist))
 +		br_multicast_add_router(br, port);
++=======
+ 	if (port->multicast_ctx.multicast_router == MDB_RTR_TYPE_PERM) {
+ 		br_ip4_multicast_add_router(br, port);
+ 		br_ip6_multicast_add_router(br, port);
+ 	}
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
  }
  
  void br_multicast_enable_port(struct net_bridge_port *port)
@@@ -1283,13 -1781,15 +1397,23 @@@ void br_multicast_disable_port(struct n
  		if (!(pg->flags & MDB_PG_FLAGS_PERMANENT))
  			br_multicast_find_del_pg(br, pg);
  
++<<<<<<< HEAD
 +	__del_port_router(port);
 +
 +	del_timer(&port->multicast_router_timer);
 +	del_timer(&port->ip4_own_query.timer);
 +#if IS_ENABLED(CONFIG_IPV6)
 +	del_timer(&port->ip6_own_query.timer);
++=======
+ 	del |= br_ip4_multicast_rport_del(port);
+ 	del_timer(&port->multicast_ctx.ip4_mc_router_timer);
+ 	del_timer(&port->multicast_ctx.ip4_own_query.timer);
+ 	del |= br_ip6_multicast_rport_del(port);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	del_timer(&port->multicast_ctx.ip6_mc_router_timer);
+ 	del_timer(&port->multicast_ctx.ip6_own_query.timer);
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
  #endif
 -	br_multicast_rport_del_notify(port, del);
  	spin_unlock(&br->multicast_lock);
  }
  
@@@ -2140,35 -2721,116 +2264,130 @@@ static void br_port_mc_router_state_cha
  		.u.mrouter = is_mc_router,
  	};
  
 -	switchdev_port_attr_set(p->dev, &attr, NULL);
 +	switchdev_port_attr_set(p->dev, &attr);
  }
  
++<<<<<<< HEAD
 +/*
 + * Add port to router_list
++=======
+ static struct net_bridge_port *
+ br_multicast_rport_from_node(struct net_bridge *br,
+ 			     struct hlist_head *mc_router_list,
+ 			     struct hlist_node *rlist)
+ {
+ 	struct net_bridge_mcast_port *pmctx;
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (mc_router_list == &br->ip6_mc_router_list)
+ 		pmctx = hlist_entry(rlist, struct net_bridge_mcast_port,
+ 				    ip6_rlist);
+ 	else
+ #endif
+ 		pmctx = hlist_entry(rlist, struct net_bridge_mcast_port,
+ 				    ip4_rlist);
+ 
+ 	return pmctx->port;
+ }
+ 
+ static struct hlist_node *
+ br_multicast_get_rport_slot(struct net_bridge *br,
+ 			    struct net_bridge_port *port,
+ 			    struct hlist_head *mc_router_list)
+ 
+ {
+ 	struct hlist_node *slot = NULL;
+ 	struct net_bridge_port *p;
+ 	struct hlist_node *rlist;
+ 
+ 	hlist_for_each(rlist, mc_router_list) {
+ 		p = br_multicast_rport_from_node(br, mc_router_list, rlist);
+ 
+ 		if ((unsigned long)port >= (unsigned long)p)
+ 			break;
+ 
+ 		slot = rlist;
+ 	}
+ 
+ 	return slot;
+ }
+ 
+ static bool br_multicast_no_router_otherpf(struct net_bridge_port *port,
+ 					   struct hlist_node *rnode)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (rnode != &port->multicast_ctx.ip6_rlist)
+ 		return hlist_unhashed(&port->multicast_ctx.ip6_rlist);
+ 	else
+ 		return hlist_unhashed(&port->multicast_ctx.ip4_rlist);
+ #else
+ 	return true;
+ #endif
+ }
+ 
+ /* Add port to router_list
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
   *  list is maintained ordered by pointer value
   *  and locked by br->multicast_lock and RCU
   */
  static void br_multicast_add_router(struct net_bridge *br,
 -				    struct net_bridge_port *port,
 -				    struct hlist_node *rlist,
 -				    struct hlist_head *mc_router_list)
 +				    struct net_bridge_port *port)
  {
 -	struct hlist_node *slot;
 +	struct net_bridge_port *p;
 +	struct hlist_node *slot = NULL;
  
 -	if (!hlist_unhashed(rlist))
 +	if (!hlist_unhashed(&port->rlist))
  		return;
  
 -	slot = br_multicast_get_rport_slot(br, port, mc_router_list);
 +	hlist_for_each_entry(p, &br->router_list, rlist) {
 +		if ((unsigned long) port >= (unsigned long) p)
 +			break;
 +		slot = &p->rlist;
 +	}
  
  	if (slot)
 -		hlist_add_behind_rcu(rlist, slot);
 +		hlist_add_behind_rcu(&port->rlist, slot);
  	else
++<<<<<<< HEAD
 +		hlist_add_head_rcu(&port->rlist, &br->router_list);
 +	br_rtr_notify(br->dev, port, RTM_NEWMDB);
 +	br_port_mc_router_state_change(port, true);
++=======
+ 		hlist_add_head_rcu(rlist, mc_router_list);
+ 
+ 	/* For backwards compatibility for now, only notify if we
+ 	 * switched from no IPv4/IPv6 multicast router to a new
+ 	 * IPv4 or IPv6 multicast router.
+ 	 */
+ 	if (br_multicast_no_router_otherpf(port, rlist)) {
+ 		br_rtr_notify(br->dev, port, RTM_NEWMDB);
+ 		br_port_mc_router_state_change(port, true);
+ 	}
+ }
+ 
+ /* Add port to router_list
+  *  list is maintained ordered by pointer value
+  *  and locked by br->multicast_lock and RCU
+  */
+ static void br_ip4_multicast_add_router(struct net_bridge *br,
+ 					struct net_bridge_port *port)
+ {
+ 	br_multicast_add_router(br, port, &port->multicast_ctx.ip4_rlist,
+ 				&br->ip4_mc_router_list);
+ }
+ 
+ /* Add port to router_list
+  *  list is maintained ordered by pointer value
+  *  and locked by br->multicast_lock and RCU
+  */
+ static void br_ip6_multicast_add_router(struct net_bridge *br,
+ 					struct net_bridge_port *port)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	br_multicast_add_router(br, port, &port->multicast_ctx.ip6_rlist,
+ 				&br->ip6_mc_router_list);
+ #endif
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
  }
  
  static void br_multicast_mark_router(struct net_bridge *br,
@@@ -2186,14 -2851,44 +2405,47 @@@
  		return;
  	}
  
- 	if (port->multicast_router == MDB_RTR_TYPE_DISABLED ||
- 	    port->multicast_router == MDB_RTR_TYPE_PERM)
+ 	if (port->multicast_ctx.multicast_router == MDB_RTR_TYPE_DISABLED ||
+ 	    port->multicast_ctx.multicast_router == MDB_RTR_TYPE_PERM)
  		return;
  
 -	br_multicast_add_router(br, port, rlist, mc_router_list);
 -	mod_timer(timer, now + br->multicast_querier_interval);
 -}
 +	br_multicast_add_router(br, port);
  
++<<<<<<< HEAD
 +	mod_timer(&port->multicast_router_timer,
 +		  now + br->multicast_querier_interval);
++=======
+ static void br_ip4_multicast_mark_router(struct net_bridge *br,
+ 					 struct net_bridge_port *port)
+ {
+ 	struct timer_list *timer = &br->ip4_mc_router_timer;
+ 	struct hlist_node *rlist = NULL;
+ 
+ 	if (port) {
+ 		timer = &port->multicast_ctx.ip4_mc_router_timer;
+ 		rlist = &port->multicast_ctx.ip4_rlist;
+ 	}
+ 
+ 	br_multicast_mark_router(br, port, timer, rlist,
+ 				 &br->ip4_mc_router_list);
+ }
+ 
+ static void br_ip6_multicast_mark_router(struct net_bridge *br,
+ 					 struct net_bridge_port *port)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	struct timer_list *timer = &br->ip6_mc_router_timer;
+ 	struct hlist_node *rlist = NULL;
+ 
+ 	if (port) {
+ 		timer = &port->multicast_ctx.ip6_mc_router_timer;
+ 		rlist = &port->multicast_ctx.ip6_rlist;
+ 	}
+ 
+ 	br_multicast_mark_router(br, port, timer, rlist,
+ 				 &br->ip6_mc_router_list);
+ #endif
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
  }
  
  static void
@@@ -2511,10 -3206,11 +2763,11 @@@ static void br_ip4_multicast_leave_grou
  	if (ipv4_is_local_multicast(group))
  		return;
  
- 	own_query = port ? &port->ip4_own_query : &br->ip4_own_query;
+ 	own_query = port ? &port->multicast_ctx.ip4_own_query :
+ 			   &br->ip4_own_query;
  
  	memset(&br_group, 0, sizeof(br_group));
 -	br_group.dst.ip4 = group;
 +	br_group.u.ip4 = group;
  	br_group.proto = htons(ETH_P_IP);
  	br_group.vid = vid;
  
@@@ -2535,10 -3231,11 +2788,11 @@@ static void br_ip6_multicast_leave_grou
  	if (ipv6_addr_is_ll_all_nodes(group))
  		return;
  
- 	own_query = port ? &port->ip6_own_query : &br->ip6_own_query;
+ 	own_query = port ? &port->multicast_ctx.ip6_own_query :
+ 			   &br->ip6_own_query;
  
  	memset(&br_group, 0, sizeof(br_group));
 -	br_group.dst.ip6 = *group;
 +	br_group.u.ip6 = *group;
  	br_group.proto = htons(ETH_P_IPV6);
  	br_group.vid = vid;
  
@@@ -2975,11 -3684,22 +3229,25 @@@ int br_multicast_set_router(struct net_
  	return err;
  }
  
 -static void
 -br_multicast_rport_del_notify(struct net_bridge_port *p, bool deleted)
 +static void __del_port_router(struct net_bridge_port *p)
  {
 -	if (!deleted)
 +	if (hlist_unhashed(&p->rlist))
  		return;
++<<<<<<< HEAD
 +	hlist_del_init_rcu(&p->rlist);
++=======
+ 
+ 	/* For backwards compatibility for now, only notify if there is
+ 	 * no multicast router anymore for both IPv4 and IPv6.
+ 	 */
+ 	if (!hlist_unhashed(&p->multicast_ctx.ip4_rlist))
+ 		return;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (!hlist_unhashed(&p->multicast_ctx.ip6_rlist))
+ 		return;
+ #endif
+ 
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
  	br_rtr_notify(p->br->dev, p, RTM_DELMDB);
  	br_port_mc_router_state_change(p, false);
  
@@@ -2993,34 -3713,52 +3261,76 @@@ int br_multicast_set_port_router(struc
  	struct net_bridge *br = p->br;
  	unsigned long now = jiffies;
  	int err = -EINVAL;
 -	bool del = false;
  
  	spin_lock(&br->multicast_lock);
- 	if (p->multicast_router == val) {
+ 	if (p->multicast_ctx.multicast_router == val) {
  		/* Refresh the temp router port timer */
++<<<<<<< HEAD
 +		if (p->multicast_router == MDB_RTR_TYPE_TEMP)
 +			mod_timer(&p->multicast_router_timer,
 +				  now + br->multicast_querier_interval);
++=======
+ 		if (p->multicast_ctx.multicast_router == MDB_RTR_TYPE_TEMP) {
+ 			mod_timer(&p->multicast_ctx.ip4_mc_router_timer,
+ 				  now + br->multicast_querier_interval);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 			mod_timer(&p->multicast_ctx.ip6_mc_router_timer,
+ 				  now + br->multicast_querier_interval);
+ #endif
+ 		}
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
  		err = 0;
  		goto unlock;
  	}
  	switch (val) {
  	case MDB_RTR_TYPE_DISABLED:
++<<<<<<< HEAD
 +		p->multicast_router = MDB_RTR_TYPE_DISABLED;
 +		__del_port_router(p);
 +		del_timer(&p->multicast_router_timer);
 +		break;
 +	case MDB_RTR_TYPE_TEMP_QUERY:
 +		p->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
 +		__del_port_router(p);
 +		break;
 +	case MDB_RTR_TYPE_PERM:
 +		p->multicast_router = MDB_RTR_TYPE_PERM;
 +		del_timer(&p->multicast_router_timer);
 +		br_multicast_add_router(br, p);
 +		break;
 +	case MDB_RTR_TYPE_TEMP:
 +		p->multicast_router = MDB_RTR_TYPE_TEMP;
 +		br_multicast_mark_router(br, p);
++=======
+ 		p->multicast_ctx.multicast_router = MDB_RTR_TYPE_DISABLED;
+ 		del |= br_ip4_multicast_rport_del(p);
+ 		del_timer(&p->multicast_ctx.ip4_mc_router_timer);
+ 		del |= br_ip6_multicast_rport_del(p);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		del_timer(&p->multicast_ctx.ip6_mc_router_timer);
+ #endif
+ 		br_multicast_rport_del_notify(p, del);
+ 		break;
+ 	case MDB_RTR_TYPE_TEMP_QUERY:
+ 		p->multicast_ctx.multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
+ 		del |= br_ip4_multicast_rport_del(p);
+ 		del |= br_ip6_multicast_rport_del(p);
+ 		br_multicast_rport_del_notify(p, del);
+ 		break;
+ 	case MDB_RTR_TYPE_PERM:
+ 		p->multicast_ctx.multicast_router = MDB_RTR_TYPE_PERM;
+ 		del_timer(&p->multicast_ctx.ip4_mc_router_timer);
+ 		br_ip4_multicast_add_router(br, p);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		del_timer(&p->multicast_ctx.ip6_mc_router_timer);
+ #endif
+ 		br_ip6_multicast_add_router(br, p);
+ 		break;
+ 	case MDB_RTR_TYPE_TEMP:
+ 		p->multicast_ctx.multicast_router = MDB_RTR_TYPE_TEMP;
+ 		br_ip4_multicast_mark_router(br, p);
+ 		br_ip6_multicast_mark_router(br, p);
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
  		break;
  	default:
  		goto unlock;
diff --cc net/bridge/br_netlink.c
index 75be8311a010,f1cf0ade9412..000000000000
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@@ -288,7 -287,11 +288,15 @@@ static int br_port_fill_attrs(struct sk
  
  #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
  	if (nla_put_u8(skb, IFLA_BRPORT_MULTICAST_ROUTER,
++<<<<<<< HEAD
 +		       p->multicast_router))
++=======
+ 		       p->multicast_ctx.multicast_router) ||
+ 	    nla_put_u32(skb, IFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT,
+ 			p->multicast_eht_hosts_limit) ||
+ 	    nla_put_u32(skb, IFLA_BRPORT_MCAST_EHT_HOSTS_CNT,
+ 			p->multicast_eht_hosts_cnt))
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
  		return -EMSGSIZE;
  #endif
  
diff --cc net/bridge/br_private.h
index e7ccf58bc2f4,6bedc724af96..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -296,16 -322,14 +313,25 @@@ struct net_bridge_port 
  	struct kobject			kobj;
  	struct rcu_head			rcu;
  
+ 	struct net_bridge_mcast_port	multicast_ctx;
+ 
  #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
++<<<<<<< HEAD
 +	struct bridge_mcast_own_query	ip4_own_query;
 +#if IS_ENABLED(CONFIG_IPV6)
 +	struct bridge_mcast_own_query	ip6_own_query;
 +#endif /* IS_ENABLED(CONFIG_IPV6) */
 +	unsigned char			multicast_router;
 +	struct bridge_mcast_stats	__percpu *mcast_stats;
 +	struct timer_list		multicast_router_timer;
++=======
+ 	struct bridge_mcast_stats	__percpu *mcast_stats;
+ 
+ 	u32				multicast_eht_hosts_limit;
+ 	u32				multicast_eht_hosts_cnt;
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
  	struct hlist_head		mglist;
 +	struct hlist_node		rlist;
  #endif
  
  #ifdef CONFIG_SYSFS
@@@ -758,11 -879,68 +784,43 @@@ void br_multicast_host_leave(struct net
  #define mlock_dereference(X, br) \
  	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
  
++<<<<<<< HEAD
 +static inline bool br_multicast_is_router(struct net_bridge *br)
++=======
+ static inline struct hlist_node *
+ br_multicast_get_first_rport_node(struct net_bridge *b, struct sk_buff *skb) {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (skb->protocol == htons(ETH_P_IPV6))
+ 		return rcu_dereference(hlist_first_rcu(&b->ip6_mc_router_list));
+ #endif
+ 	return rcu_dereference(hlist_first_rcu(&b->ip4_mc_router_list));
+ }
+ 
+ static inline struct net_bridge_port *
+ br_multicast_rport_from_node_skb(struct hlist_node *rp, struct sk_buff *skb) {
+ 	struct net_bridge_mcast_port *mctx;
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (skb->protocol == htons(ETH_P_IPV6))
+ 		mctx = hlist_entry_safe(rp, struct net_bridge_mcast_port,
+ 					ip6_rlist);
+ 	else
+ #endif
+ 		mctx = hlist_entry_safe(rp, struct net_bridge_mcast_port,
+ 					ip4_rlist);
+ 
+ 	if (mctx)
+ 		return mctx->port;
+ 	else
+ 		return NULL;
+ }
+ 
+ static inline bool br_ip4_multicast_is_router(struct net_bridge *br)
++>>>>>>> 9632233e7de8 (net: bridge: multicast: factor out port multicast context)
  {
 -	return timer_pending(&br->ip4_mc_router_timer);
 -}
 -
 -static inline bool br_ip6_multicast_is_router(struct net_bridge *br)
 -{
 -#if IS_ENABLED(CONFIG_IPV6)
 -	return timer_pending(&br->ip6_mc_router_timer);
 -#else
 -	return false;
 -#endif
 -}
 -
 -static inline bool
 -br_multicast_is_router(struct net_bridge *br, struct sk_buff *skb)
 -{
 -	switch (br->multicast_router) {
 -	case MDB_RTR_TYPE_PERM:
 -		return true;
 -	case MDB_RTR_TYPE_TEMP_QUERY:
 -		if (skb) {
 -			if (skb->protocol == htons(ETH_P_IP))
 -				return br_ip4_multicast_is_router(br);
 -			else if (skb->protocol == htons(ETH_P_IPV6))
 -				return br_ip6_multicast_is_router(br);
 -		} else {
 -			return br_ip4_multicast_is_router(br) ||
 -			       br_ip6_multicast_is_router(br);
 -		}
 -		fallthrough;
 -	default:
 -		return false;
 -	}
 +	return br->multicast_router == 2 ||
 +	       (br->multicast_router == 1 &&
 +		timer_pending(&br->multicast_router_timer));
  }
  
  static inline bool
* Unmerged path net/bridge/br_mdb.c
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_netlink.c
* Unmerged path net/bridge/br_private.h
diff --git a/net/bridge/br_sysfs_if.c b/net/bridge/br_sysfs_if.c
index 251e38b9cd3e..e9d5ff4fbfb9 100644
--- a/net/bridge/br_sysfs_if.c
+++ b/net/bridge/br_sysfs_if.c
@@ -248,7 +248,7 @@ BRPORT_ATTR_FLAG(isolated, BR_ISOLATED);
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 static ssize_t show_multicast_router(struct net_bridge_port *p, char *buf)
 {
-	return sprintf(buf, "%d\n", p->multicast_router);
+	return sprintf(buf, "%d\n", p->multicast_ctx.multicast_router);
 }
 
 static int store_multicast_router(struct net_bridge_port *p,
