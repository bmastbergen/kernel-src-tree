iommu/vt-d: Add prq_report trace event

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Lu Baolu <baolu.lu@linux.intel.com>
commit e93a67f5a0eef3e9ab5b4649cac5c3b831c6a9db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/e93a67f5.failed

This adds a new trace event to track the page fault request report.
This event will provide almost all information defined in a page
request descriptor.

A sample output:
| prq_report: dmar0/0000:00:0a.0 seq# 1: rid=0x50 addr=0x559ef6f97 r---- pasid=0x2 index=0x1
| prq_report: dmar0/0000:00:0a.0 seq# 2: rid=0x50 addr=0x559ef6f9c rw--l pasid=0x2 index=0x1
| prq_report: dmar0/0000:00:0a.0 seq# 3: rid=0x50 addr=0x559ef6f98 r---- pasid=0x2 index=0x1
| prq_report: dmar0/0000:00:0a.0 seq# 4: rid=0x50 addr=0x559ef6f9d rw--l pasid=0x2 index=0x1
| prq_report: dmar0/0000:00:0a.0 seq# 5: rid=0x50 addr=0x559ef6f99 r---- pasid=0x2 index=0x1
| prq_report: dmar0/0000:00:0a.0 seq# 6: rid=0x50 addr=0x559ef6f9e rw--l pasid=0x2 index=0x1
| prq_report: dmar0/0000:00:0a.0 seq# 7: rid=0x50 addr=0x559ef6f9a r---- pasid=0x2 index=0x1
| prq_report: dmar0/0000:00:0a.0 seq# 8: rid=0x50 addr=0x559ef6f9f rw--l pasid=0x2 index=0x1

This will be helpful for I/O page fault related debugging.

	Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
Link: https://lore.kernel.org/r/20210520031531.712333-1-baolu.lu@linux.intel.com
Link: https://lore.kernel.org/r/20210610020115.1637656-13-baolu.lu@linux.intel.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit e93a67f5a0eef3e9ab5b4649cac5c3b831c6a9db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel/svm.c
diff --cc drivers/iommu/intel/svm.c
index f4c78a5e53a1,d3d028c6a727..000000000000
--- a/drivers/iommu/intel/svm.c
+++ b/drivers/iommu/intel/svm.c
@@@ -912,127 -928,67 +913,138 @@@ static irqreturn_t prq_event_thread(in
  
  	tail = dmar_readq(iommu->reg + DMAR_PQT_REG) & PRQ_RING_MASK;
  	head = dmar_readq(iommu->reg + DMAR_PQH_REG) & PRQ_RING_MASK;
 -	handled = (head != tail);
  	while (head != tail) {
 +		struct vm_area_struct *vma;
 +		struct page_req_dsc *req;
 +		struct qi_desc resp;
 +		int result;
 +		vm_fault_t ret;
 +		u64 address;
 +
 +		handled = 1;
  		req = &iommu->prq[head / sizeof(*req)];
 +		result = QI_RESP_INVALID;
  		address = (u64)req->addr << VTD_PAGE_SHIFT;
 -
 -		if (unlikely(!req->pasid_present)) {
 -			pr_err("IOMMU: %s: Page request without PASID\n",
 -			       iommu->name);
 -bad_req:
 -			svm = NULL;
 -			sdev = NULL;
 -			handle_bad_prq_event(iommu, req, QI_RESP_INVALID);
 -			goto prq_advance;
 -		}
 -
 -		if (unlikely(!is_canonical_address(address))) {
 -			pr_err("IOMMU: %s: Address is not canonical\n",
 -			       iommu->name);
 -			goto bad_req;
 +		if (!req->pasid_present) {
 +			pr_err("%s: Page request without PASID: %08llx %08llx\n",
 +			       iommu->name, ((unsigned long long *)req)[0],
 +			       ((unsigned long long *)req)[1]);
 +			goto no_pasid;
  		}
 -
 -		if (unlikely(req->pm_req && (req->rd_req | req->wr_req))) {
 -			pr_err("IOMMU: %s: Page request in Privilege Mode\n",
 -			       iommu->name);
 -			goto bad_req;
 +		/* We shall not receive page request for supervisor SVM */
 +		if (req->pm_req && (req->rd_req | req->wr_req)) {
 +			pr_err("Unexpected page request in Privilege Mode");
 +			/* No need to find the matching sdev as for bad_req */
 +			goto no_pasid;
  		}
 -
 -		if (unlikely(req->exe_req && req->rd_req)) {
 -			pr_err("IOMMU: %s: Execution request not supported\n",
 -			       iommu->name);
 -			goto bad_req;
 +		/* DMA read with exec requeset is not supported. */
 +		if (req->exe_req && req->rd_req) {
 +			pr_err("Execution request not supported\n");
 +			goto no_pasid;
  		}
 -
  		if (!svm || svm->pasid != req->pasid) {
 -			/*
 -			 * It can't go away, because the driver is not permitted
 -			 * to unbind the mm while any page faults are outstanding.
 -			 */
 +			rcu_read_lock();
  			svm = pasid_private_find(req->pasid);
 -			if (IS_ERR_OR_NULL(svm) || (svm->flags & SVM_FLAG_SUPERVISOR_MODE))
 -				goto bad_req;
 +			/* It *can't* go away, because the driver is not permitted
 +			 * to unbind the mm while any page faults are outstanding.
 +			 * So we only need RCU to protect the internal idr code. */
 +			rcu_read_unlock();
 +			if (IS_ERR_OR_NULL(svm)) {
 +				pr_err("%s: Page request for invalid PASID %d: %08llx %08llx\n",
 +				       iommu->name, req->pasid, ((unsigned long long *)req)[0],
 +				       ((unsigned long long *)req)[1]);
 +				goto no_pasid;
 +			}
  		}
  
 -		if (!sdev || sdev->sid != req->rid) {
 +		if (!sdev || sdev->sid != req->rid)
  			sdev = svm_lookup_device_by_sid(svm, req->rid);
 -			if (!sdev)
 -				goto bad_req;
 -		}
 +
 +		/* Since we're using init_mm.pgd directly, we should never take
 +		 * any faults on kernel addresses. */
 +		if (!svm->mm)
 +			goto bad_req;
 +
 +		/* If address is not canonical, return invalid response */
 +		if (!is_canonical_address(address))
 +			goto bad_req;
  
+ 		sdev->prq_seq_number++;
+ 
  		/*
  		 * If prq is to be handled outside iommu driver via receiver of
  		 * the fault notifiers, we skip the page response here.
  		 */
++<<<<<<< HEAD
 +		if (svm->flags & SVM_FLAG_GUEST_MODE) {
 +			if (sdev && !intel_svm_prq_report(sdev->dev, req))
 +				goto prq_advance;
 +			else
 +				goto bad_req;
 +		}
 +
 +		/* If the mm is already defunct, don't handle faults. */
 +		if (!mmget_not_zero(svm->mm))
 +			goto bad_req;
 +
 +		mmap_read_lock(svm->mm);
 +		vma = find_extend_vma(svm->mm, address);
 +		if (!vma || address < vma->vm_start)
 +			goto invalid;
 +
 +		if (access_error(vma, req))
 +			goto invalid;
 +
 +		flags = FAULT_FLAG_USER | FAULT_FLAG_REMOTE;
 +		if (req->wr_req)
 +			flags |= FAULT_FLAG_WRITE;
 +
 +		ret = handle_mm_fault(vma, address, flags);
 +		if (ret & VM_FAULT_ERROR)
 +			goto invalid;
 +
 +		result = QI_RESP_SUCCESS;
 +invalid:
 +		mmap_read_unlock(svm->mm);
 +		mmput(svm->mm);
 +bad_req:
 +		/* We get here in the error case where the PASID lookup failed,
 +		   and these can be NULL. Do not use them below this point! */
 +		sdev = NULL;
 +		svm = NULL;
 +no_pasid:
 +		if (req->lpig || req->priv_data_present) {
 +			/*
 +			 * Per VT-d spec. v3.0 ch7.7, system software must
 +			 * respond with page group response if private data
 +			 * is present (PDP) or last page in group (LPIG) bit
 +			 * is set. This is an additional VT-d feature beyond
 +			 * PCI ATS spec.
 +			 */
 +			resp.qw0 = QI_PGRP_PASID(req->pasid) |
 +				QI_PGRP_DID(req->rid) |
 +				QI_PGRP_PASID_P(req->pasid_present) |
 +				QI_PGRP_PDP(req->priv_data_present) |
 +				QI_PGRP_RESP_CODE(result) |
 +				QI_PGRP_RESP_TYPE;
 +			resp.qw1 = QI_PGRP_IDX(req->prg_index) |
 +				QI_PGRP_LPIG(req->lpig);
 +			resp.qw2 = 0;
 +			resp.qw3 = 0;
 +
 +			if (req->priv_data_present)
 +				memcpy(&resp.qw2, req->priv_data,
 +				       sizeof(req->priv_data));
 +			qi_submit_sync(iommu, &resp, 1, 0);
 +		}
++=======
+ 		if (intel_svm_prq_report(sdev->dev, req))
+ 			handle_bad_prq_event(iommu, req, QI_RESP_INVALID);
+ 
+ 		trace_prq_report(iommu, sdev->dev, req->qw_0, req->qw_1,
+ 				 req->priv_data[0], req->priv_data[1],
+ 				 sdev->prq_seq_number);
++>>>>>>> e93a67f5a0ee (iommu/vt-d: Add prq_report trace event)
  prq_advance:
  		head = (head + sizeof(*req)) & PRQ_RING_MASK;
  	}
* Unmerged path drivers/iommu/intel/svm.c
diff --git a/include/linux/intel-iommu.h b/include/linux/intel-iommu.h
index 2baad6435f51..9082b808505c 100644
--- a/include/linux/intel-iommu.h
+++ b/include/linux/intel-iommu.h
@@ -783,6 +783,7 @@ struct intel_svm_dev {
 	struct device *dev;
 	struct intel_iommu *iommu;
 	struct iommu_sva sva;
+	unsigned long prq_seq_number;
 	u32 pasid;
 	int users;
 	u16 did;
@@ -833,4 +834,32 @@ static inline int iommu_calculate_max_sagaw(struct intel_iommu *iommu)
 #define intel_iommu_enabled (0)
 #endif
 
+static inline const char *decode_prq_descriptor(char *str, size_t size,
+		u64 dw0, u64 dw1, u64 dw2, u64 dw3)
+{
+	char *buf = str;
+	int bytes;
+
+	bytes = snprintf(buf, size,
+			 "rid=0x%llx addr=0x%llx %c%c%c%c%c pasid=0x%llx index=0x%llx",
+			 FIELD_GET(GENMASK_ULL(31, 16), dw0),
+			 FIELD_GET(GENMASK_ULL(63, 12), dw1),
+			 dw1 & BIT_ULL(0) ? 'r' : '-',
+			 dw1 & BIT_ULL(1) ? 'w' : '-',
+			 dw0 & BIT_ULL(52) ? 'x' : '-',
+			 dw0 & BIT_ULL(53) ? 'p' : '-',
+			 dw1 & BIT_ULL(2) ? 'l' : '-',
+			 FIELD_GET(GENMASK_ULL(51, 32), dw0),
+			 FIELD_GET(GENMASK_ULL(11, 3), dw1));
+
+	/* Private Data */
+	if (dw0 & BIT_ULL(9)) {
+		size -= bytes;
+		buf += bytes;
+		snprintf(buf, size, " private=0x%llx/0x%llx\n", dw2, dw3);
+	}
+
+	return str;
+}
+
 #endif
diff --git a/include/trace/events/intel_iommu.h b/include/trace/events/intel_iommu.h
index d233f2916584..e5c1ca6d16ee 100644
--- a/include/trace/events/intel_iommu.h
+++ b/include/trace/events/intel_iommu.h
@@ -15,6 +15,8 @@
 #include <linux/tracepoint.h>
 #include <linux/intel-iommu.h>
 
+#define MSG_MAX		256
+
 TRACE_EVENT(qi_submit,
 	TP_PROTO(struct intel_iommu *iommu, u64 qw0, u64 qw1, u64 qw2, u64 qw3),
 
@@ -51,6 +53,41 @@ TRACE_EVENT(qi_submit,
 		__entry->qw0, __entry->qw1, __entry->qw2, __entry->qw3
 	)
 );
+
+TRACE_EVENT(prq_report,
+	TP_PROTO(struct intel_iommu *iommu, struct device *dev,
+		 u64 dw0, u64 dw1, u64 dw2, u64 dw3,
+		 unsigned long seq),
+
+	TP_ARGS(iommu, dev, dw0, dw1, dw2, dw3, seq),
+
+	TP_STRUCT__entry(
+		__field(u64, dw0)
+		__field(u64, dw1)
+		__field(u64, dw2)
+		__field(u64, dw3)
+		__field(unsigned long, seq)
+		__string(iommu, iommu->name)
+		__string(dev, dev_name(dev))
+		__dynamic_array(char, buff, MSG_MAX)
+	),
+
+	TP_fast_assign(
+		__entry->dw0 = dw0;
+		__entry->dw1 = dw1;
+		__entry->dw2 = dw2;
+		__entry->dw3 = dw3;
+		__entry->seq = seq;
+		__assign_str(iommu, iommu->name);
+		__assign_str(dev, dev_name(dev));
+	),
+
+	TP_printk("%s/%s seq# %ld: %s",
+		__get_str(iommu), __get_str(dev), __entry->seq,
+		decode_prq_descriptor(__get_str(buff), MSG_MAX, __entry->dw0,
+				      __entry->dw1, __entry->dw2, __entry->dw3)
+	)
+);
 #endif /* _TRACE_INTEL_IOMMU_H */
 
 /* This part must be outside protection */
