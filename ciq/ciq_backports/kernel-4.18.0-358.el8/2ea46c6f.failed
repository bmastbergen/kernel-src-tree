cpumask/hotplug: Fix cpu_dying() state tracking

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit 2ea46c6fc9452ac100ad907b051d797225847e33
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/2ea46c6f.failed

Vincent reported that for states with a NULL startup/teardown function
we do not call cpuhp_invoke_callback() (because there is none) and as
such we'll not update the cpu_dying() state.

The stale cpu_dying() can eventually lead to triggering BUG().

Rectify this by updating cpu_dying() in the exact same places the
hotplug machinery tracks its directional state, namely
cpuhp_set_state() and cpuhp_reset_state().

	Reported-by: Vincent Donnefort <vincent.donnefort@arm.com>
	Suggested-by: Vincent Donnefort <vincent.donnefort@arm.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Vincent Donnefort <vincent.donnefort@arm.com>
	Reviewed-by: Valentin Schneider <valentin.schneider@arm.com>
Link: https://lkml.kernel.org/r/YH7r+AoQEReSvxBI@hirez.programming.kicks-ass.net
(cherry picked from commit 2ea46c6fc9452ac100ad907b051d797225847e33)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/cpu.c
diff --cc kernel/cpu.c
index 4f2a7706340a,e538518556f4..000000000000
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@@ -63,7 -63,7 +63,11 @@@ struct cpuhp_cpu_state 
  	bool			rollback;
  	bool			single;
  	bool			bringup;
++<<<<<<< HEAD
 +	bool			booted_once;
++=======
+ 	int			cpu;
++>>>>>>> 2ea46c6fc945 (cpumask/hotplug: Fix cpu_dying() state tracking)
  	struct hlist_node	*node;
  	struct hlist_node	*last;
  	enum cpuhp_state	cb_state;
@@@ -471,6 -482,17 +478,20 @@@ cpuhp_set_state(struct cpuhp_cpu_state 
  static inline void
  cpuhp_reset_state(struct cpuhp_cpu_state *st, enum cpuhp_state prev_state)
  {
++<<<<<<< HEAD
++=======
+ 	bool bringup = !st->bringup;
+ 
+ 	st->target = prev_state;
+ 
+ 	/*
+ 	 * Already rolling back. No need invert the bringup value or to change
+ 	 * the current state.
+ 	 */
+ 	if (st->rollback)
+ 		return;
+ 
++>>>>>>> 2ea46c6fc945 (cpumask/hotplug: Fix cpu_dying() state tracking)
  	st->rollback = true;
  
  	/*
@@@ -484,8 -506,9 +505,14 @@@
  			st->state++;
  	}
  
++<<<<<<< HEAD
 +	st->target = prev_state;
 +	st->bringup = !st->bringup;
++=======
+ 	st->bringup = bringup;
+ 	if (cpu_dying(st->cpu) != !bringup)
+ 		set_cpu_dying(st->cpu, !bringup);
++>>>>>>> 2ea46c6fc945 (cpumask/hotplug: Fix cpu_dying() state tracking)
  }
  
  /* Regular hotplug invocation of the AP hotplug thread */
* Unmerged path kernel/cpu.c
