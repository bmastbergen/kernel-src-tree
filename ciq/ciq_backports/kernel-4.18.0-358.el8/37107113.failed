x86/fpu: Use pkru_write_default() in copy_init_fpstate_to_fpregs()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 371071131cd1032c1e9172c51234a2a324841cab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/37107113.failed

There is no point in using copy_init_pkru_to_fpregs() which in turn calls
write_pkru(). write_pkru() tries to fiddle with the task's xstate buffer
for nothing because the XRSTOR[S](init_fpstate) just cleared the xfeature
flag in the xstate header which makes get_xsave_addr() fail.

It's a useless exercise anyway because the reinitialization activates the
FPU so before the task's xstate buffer can be used again a XRSTOR[S] must
happen which in turn dumps the PKRU value.

Get rid of the now unused copy_init_pkru_to_fpregs().

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20210623121455.732508792@linutronix.de
(cherry picked from commit 371071131cd1032c1e9172c51234a2a324841cab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/core.c
#	arch/x86/mm/pkeys.c
diff --cc arch/x86/kernel/fpu/core.c
index 1e27c69db876,fedadcb04ba2..000000000000
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@@ -356,8 -311,7 +356,12 @@@ static inline void copy_init_fpstate_to
  	else
  		frstor(&init_fpstate.fsave);
  
++<<<<<<< HEAD
 +	if (boot_cpu_has(X86_FEATURE_OSPKE))
 +		copy_init_pkru_to_fpregs();
++=======
+ 	pkru_write_default();
++>>>>>>> 371071131cd1 (x86/fpu: Use pkru_write_default() in copy_init_fpstate_to_fpregs())
  }
  
  /*
diff --cc arch/x86/mm/pkeys.c
index 4061d7b3ffe8,fb171a5d7f33..000000000000
--- a/arch/x86/mm/pkeys.c
+++ b/arch/x86/mm/pkeys.c
@@@ -133,22 -124,6 +132,25 @@@ u32 init_pkru_value = PKRU_AD_KEY( 1) 
  		      PKRU_AD_KEY(10) | PKRU_AD_KEY(11) | PKRU_AD_KEY(12) |
  		      PKRU_AD_KEY(13) | PKRU_AD_KEY(14) | PKRU_AD_KEY(15);
  
++<<<<<<< HEAD
 +/*
 + * Called from the FPU code when creating a fresh set of FPU
 + * registers.  This is called from a very specific context where
 + * we know the FPU regstiers are safe for use and we can use PKRU
 + * directly.
 + */
 +void copy_init_pkru_to_fpregs(void)
 +{
 +	u32 init_pkru_value_snapshot = READ_ONCE(init_pkru_value);
 +	/*
 +	 * Override the PKRU state that came from 'init_fpstate'
 +	 * with the baseline from the process.
 +	 */
 +	write_pkru(init_pkru_value_snapshot);
 +}
 +
++=======
++>>>>>>> 371071131cd1 (x86/fpu: Use pkru_write_default() in copy_init_fpstate_to_fpregs())
  static ssize_t init_pkru_read_file(struct file *file, char __user *user_buf,
  			     size_t count, loff_t *ppos)
  {
diff --git a/arch/x86/include/asm/pkeys.h b/arch/x86/include/asm/pkeys.h
index 2ff9b98812b7..307507da3eb5 100644
--- a/arch/x86/include/asm/pkeys.h
+++ b/arch/x86/include/asm/pkeys.h
@@ -124,7 +124,6 @@ extern int arch_set_user_pkey_access(struct task_struct *tsk, int pkey,
 		unsigned long init_val);
 extern int __arch_set_user_pkey_access(struct task_struct *tsk, int pkey,
 		unsigned long init_val);
-extern void copy_init_pkru_to_fpregs(void);
 
 static inline int vma_pkey(struct vm_area_struct *vma)
 {
* Unmerged path arch/x86/kernel/fpu/core.c
* Unmerged path arch/x86/mm/pkeys.c
diff --git a/include/linux/pkeys.h b/include/linux/pkeys.h
index 2955ba976048..6beb26b7151d 100644
--- a/include/linux/pkeys.h
+++ b/include/linux/pkeys.h
@@ -44,10 +44,6 @@ static inline bool arch_pkeys_enabled(void)
 	return false;
 }
 
-static inline void copy_init_pkru_to_fpregs(void)
-{
-}
-
 #endif /* ! CONFIG_ARCH_HAS_PKEYS */
 
 #endif /* _LINUX_PKEYS_H */
