ata: move *sata_set_spd*() to libata-sata.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
commit ab4117cf2470618ffd5af16fa7c363b81260d6e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/ab4117cf.failed

* move *sata_set_spd*() to libata-sata.c

* add static inlines for CONFIG_SATA_HOST=n case

Code size savings on m68k arch using (modified) atari_defconfig:

   text    data     bss     dec     hex filename
before:
  32842     572      40   33458    82ae drivers/ata/libata-core.o
after:
  32812     572      40   33428    8290 drivers/ata/libata-core.o

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit ab4117cf2470618ffd5af16fa7c363b81260d6e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ata/libata-core.c
#	drivers/ata/libata-sata.c
#	include/linux/libata.h
diff --cc drivers/ata/libata-core.c
index d6da17431f7f,13214ebd0e5c..000000000000
--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@@ -3108,264 -3050,7 +3108,268 @@@ int sata_down_spd_limit(struct ata_lin
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int __sata_set_spd_needed(struct ata_link *link, u32 *scontrol)
 +{
 +	struct ata_link *host_link = &link->ap->link;
 +	u32 limit, target, spd;
 +
 +	limit = link->sata_spd_limit;
 +
 +	/* Don't configure downstream link faster than upstream link.
 +	 * It doesn't speed up anything and some PMPs choke on such
 +	 * configuration.
 +	 */
 +	if (!ata_is_host_link(link) && host_link->sata_spd)
 +		limit &= (1 << host_link->sata_spd) - 1;
 +
 +	if (limit == UINT_MAX)
 +		target = 0;
 +	else
 +		target = fls(limit);
 +
 +	spd = (*scontrol >> 4) & 0xf;
 +	*scontrol = (*scontrol & ~0xf0) | ((target & 0xf) << 4);
 +
 +	return spd != target;
 +}
 +
 +/**
 + *	sata_set_spd_needed - is SATA spd configuration needed
 + *	@link: Link in question
 + *
 + *	Test whether the spd limit in SControl matches
 + *	@link->sata_spd_limit.  This function is used to determine
 + *	whether hardreset is necessary to apply SATA spd
 + *	configuration.
 + *
 + *	LOCKING:
 + *	Inherited from caller.
 + *
 + *	RETURNS:
 + *	1 if SATA spd configuration is needed, 0 otherwise.
 + */
 +static int sata_set_spd_needed(struct ata_link *link)
 +{
 +	u32 scontrol;
 +
 +	if (sata_scr_read(link, SCR_CONTROL, &scontrol))
 +		return 1;
 +
 +	return __sata_set_spd_needed(link, &scontrol);
 +}
 +
 +/**
 + *	sata_set_spd - set SATA spd according to spd limit
 + *	@link: Link to set SATA spd for
 + *
 + *	Set SATA spd of @link according to sata_spd_limit.
 + *
 + *	LOCKING:
 + *	Inherited from caller.
 + *
 + *	RETURNS:
 + *	0 if spd doesn't need to be changed, 1 if spd has been
 + *	changed.  Negative errno if SCR registers are inaccessible.
 + */
 +int sata_set_spd(struct ata_link *link)
 +{
 +	u32 scontrol;
 +	int rc;
 +
 +	if ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))
 +		return rc;
 +
 +	if (!__sata_set_spd_needed(link, &scontrol))
 +		return 0;
 +
 +	if ((rc = sata_scr_write(link, SCR_CONTROL, scontrol)))
 +		return rc;
 +
 +	return 1;
 +}
 +
 +/*
 + * This mode timing computation functionality is ported over from
 + * drivers/ide/ide-timing.h and was originally written by Vojtech Pavlik
 + */
 +/*
 + * PIO 0-4, MWDMA 0-2 and UDMA 0-6 timings (in nanoseconds).
 + * These were taken from ATA/ATAPI-6 standard, rev 0a, except
 + * for UDMA6, which is currently supported only by Maxtor drives.
 + *
 + * For PIO 5/6 MWDMA 3/4 see the CFA specification 3.0.
 + */
 +
 +static const struct ata_timing ata_timing[] = {
 +/*	{ XFER_PIO_SLOW, 120, 290, 240, 960, 290, 240, 0,  960,   0 }, */
 +	{ XFER_PIO_0,     70, 290, 240, 600, 165, 150, 0,  600,   0 },
 +	{ XFER_PIO_1,     50, 290,  93, 383, 125, 100, 0,  383,   0 },
 +	{ XFER_PIO_2,     30, 290,  40, 330, 100,  90, 0,  240,   0 },
 +	{ XFER_PIO_3,     30,  80,  70, 180,  80,  70, 0,  180,   0 },
 +	{ XFER_PIO_4,     25,  70,  25, 120,  70,  25, 0,  120,   0 },
 +	{ XFER_PIO_5,     15,  65,  25, 100,  65,  25, 0,  100,   0 },
 +	{ XFER_PIO_6,     10,  55,  20,  80,  55,  20, 0,   80,   0 },
 +
 +	{ XFER_SW_DMA_0, 120,   0,   0,   0, 480, 480, 50, 960,   0 },
 +	{ XFER_SW_DMA_1,  90,   0,   0,   0, 240, 240, 30, 480,   0 },
 +	{ XFER_SW_DMA_2,  60,   0,   0,   0, 120, 120, 20, 240,   0 },
 +
 +	{ XFER_MW_DMA_0,  60,   0,   0,   0, 215, 215, 20, 480,   0 },
 +	{ XFER_MW_DMA_1,  45,   0,   0,   0,  80,  50, 5,  150,   0 },
 +	{ XFER_MW_DMA_2,  25,   0,   0,   0,  70,  25, 5,  120,   0 },
 +	{ XFER_MW_DMA_3,  25,   0,   0,   0,  65,  25, 5,  100,   0 },
 +	{ XFER_MW_DMA_4,  25,   0,   0,   0,  55,  20, 5,   80,   0 },
 +
 +/*	{ XFER_UDMA_SLOW,  0,   0,   0,   0,   0,   0, 0,    0, 150 }, */
 +	{ XFER_UDMA_0,     0,   0,   0,   0,   0,   0, 0,    0, 120 },
 +	{ XFER_UDMA_1,     0,   0,   0,   0,   0,   0, 0,    0,  80 },
 +	{ XFER_UDMA_2,     0,   0,   0,   0,   0,   0, 0,    0,  60 },
 +	{ XFER_UDMA_3,     0,   0,   0,   0,   0,   0, 0,    0,  45 },
 +	{ XFER_UDMA_4,     0,   0,   0,   0,   0,   0, 0,    0,  30 },
 +	{ XFER_UDMA_5,     0,   0,   0,   0,   0,   0, 0,    0,  20 },
 +	{ XFER_UDMA_6,     0,   0,   0,   0,   0,   0, 0,    0,  15 },
 +
 +	{ 0xFF }
 +};
 +
 +#define ENOUGH(v, unit)		(((v)-1)/(unit)+1)
 +#define EZ(v, unit)		((v)?ENOUGH(((v) * 1000), unit):0)
 +
 +static void ata_timing_quantize(const struct ata_timing *t,
 +				struct ata_timing *q, int T, int UT)
 +{
 +	q->setup	= EZ(t->setup,       T);
 +	q->act8b	= EZ(t->act8b,       T);
 +	q->rec8b	= EZ(t->rec8b,       T);
 +	q->cyc8b	= EZ(t->cyc8b,       T);
 +	q->active	= EZ(t->active,      T);
 +	q->recover	= EZ(t->recover,     T);
 +	q->dmack_hold	= EZ(t->dmack_hold,  T);
 +	q->cycle	= EZ(t->cycle,       T);
 +	q->udma		= EZ(t->udma,       UT);
 +}
 +
 +void ata_timing_merge(const struct ata_timing *a, const struct ata_timing *b,
 +		      struct ata_timing *m, unsigned int what)
 +{
 +	if (what & ATA_TIMING_SETUP)
 +		m->setup = max(a->setup, b->setup);
 +	if (what & ATA_TIMING_ACT8B)
 +		m->act8b = max(a->act8b, b->act8b);
 +	if (what & ATA_TIMING_REC8B)
 +		m->rec8b = max(a->rec8b, b->rec8b);
 +	if (what & ATA_TIMING_CYC8B)
 +		m->cyc8b = max(a->cyc8b, b->cyc8b);
 +	if (what & ATA_TIMING_ACTIVE)
 +		m->active = max(a->active, b->active);
 +	if (what & ATA_TIMING_RECOVER)
 +		m->recover = max(a->recover, b->recover);
 +	if (what & ATA_TIMING_DMACK_HOLD)
 +		m->dmack_hold = max(a->dmack_hold, b->dmack_hold);
 +	if (what & ATA_TIMING_CYCLE)
 +		m->cycle = max(a->cycle, b->cycle);
 +	if (what & ATA_TIMING_UDMA)
 +		m->udma = max(a->udma, b->udma);
 +}
 +
 +const struct ata_timing *ata_timing_find_mode(u8 xfer_mode)
 +{
 +	const struct ata_timing *t = ata_timing;
 +
 +	while (xfer_mode > t->mode)
 +		t++;
 +
 +	if (xfer_mode == t->mode)
 +		return t;
 +
 +	WARN_ONCE(true, "%s: unable to find timing for xfer_mode 0x%x\n",
 +			__func__, xfer_mode);
 +
 +	return NULL;
 +}
 +
 +int ata_timing_compute(struct ata_device *adev, unsigned short speed,
 +		       struct ata_timing *t, int T, int UT)
 +{
 +	const u16 *id = adev->id;
 +	const struct ata_timing *s;
 +	struct ata_timing p;
 +
 +	/*
 +	 * Find the mode.
 +	 */
 +	s = ata_timing_find_mode(speed);
 +	if (!s)
 +		return -EINVAL;
 +
 +	memcpy(t, s, sizeof(*s));
 +
 +	/*
 +	 * If the drive is an EIDE drive, it can tell us it needs extended
 +	 * PIO/MW_DMA cycle timing.
 +	 */
 +
 +	if (id[ATA_ID_FIELD_VALID] & 2) {	/* EIDE drive */
 +		memset(&p, 0, sizeof(p));
 +
 +		if (speed >= XFER_PIO_0 && speed < XFER_SW_DMA_0) {
 +			if (speed <= XFER_PIO_2)
 +				p.cycle = p.cyc8b = id[ATA_ID_EIDE_PIO];
 +			else if ((speed <= XFER_PIO_4) ||
 +				 (speed == XFER_PIO_5 && !ata_id_is_cfa(id)))
 +				p.cycle = p.cyc8b = id[ATA_ID_EIDE_PIO_IORDY];
 +		} else if (speed >= XFER_MW_DMA_0 && speed <= XFER_MW_DMA_2)
 +			p.cycle = id[ATA_ID_EIDE_DMA_MIN];
 +
 +		ata_timing_merge(&p, t, t, ATA_TIMING_CYCLE | ATA_TIMING_CYC8B);
 +	}
 +
 +	/*
 +	 * Convert the timing to bus clock counts.
 +	 */
 +
 +	ata_timing_quantize(t, t, T, UT);
 +
 +	/*
 +	 * Even in DMA/UDMA modes we still use PIO access for IDENTIFY,
 +	 * S.M.A.R.T * and some other commands. We have to ensure that the
 +	 * DMA cycle timing is slower/equal than the fastest PIO timing.
 +	 */
 +
 +	if (speed > XFER_PIO_6) {
 +		ata_timing_compute(adev, adev->pio_mode, &p, T, UT);
 +		ata_timing_merge(&p, t, t, ATA_TIMING_ALL);
 +	}
 +
 +	/*
 +	 * Lengthen active & recovery time so that cycle time is correct.
 +	 */
 +
 +	if (t->act8b + t->rec8b < t->cyc8b) {
 +		t->act8b += (t->cyc8b - (t->act8b + t->rec8b)) / 2;
 +		t->rec8b = t->cyc8b - t->act8b;
 +	}
 +
 +	if (t->active + t->recover < t->cycle) {
 +		t->active += (t->cycle - (t->active + t->recover)) / 2;
 +		t->recover = t->cycle - t->active;
 +	}
 +
 +	/*
 +	 * In a few cases quantisation may produce enough errors to
 +	 * leave t->cycle too low for the sum of active and recovery
 +	 * if so we must correct this.
 +	 */
 +	if (t->active + t->recover > t->cycle)
 +		t->cycle = t->active + t->recover;
 +
 +	return 0;
 +}
 +
++=======
+ #ifdef CONFIG_ATA_ACPI
++>>>>>>> ab4117cf2470 (ata: move *sata_set_spd*() to libata-sata.c)
  /**
   *	ata_timing_cycle2mode - find xfer mode for the specified cycle duration
   *	@xfer_shift: ATA_SHIFT_* value for transfer type to examine.
diff --cc include/linux/libata.h
index ce0dc53b9adc,f0817a8f1e3f..000000000000
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@@ -1208,6 -1184,38 +1207,41 @@@ extern struct ata_device *ata_dev_pair(
  extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
  extern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);
  extern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap, struct list_head *eh_q);
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * SATA specific code - drivers/ata/libata-sata.c
+  */
+ #ifdef CONFIG_SATA_HOST
+ extern int sata_scr_valid(struct ata_link *link);
+ extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
+ extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
+ extern int sata_scr_write_flush(struct ata_link *link, int reg, u32 val);
+ extern int sata_set_spd(struct ata_link *link);
+ #else
+ static inline int sata_scr_valid(struct ata_link *link) { return 0; }
+ static inline int sata_scr_read(struct ata_link *link, int reg, u32 *val)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int sata_scr_write(struct ata_link *link, int reg, u32 val)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int sata_scr_write_flush(struct ata_link *link, int reg, u32 val)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int sata_set_spd(struct ata_link *link) { return -EOPNOTSUPP; }
+ #endif
+ extern int sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,
+ 			     bool spm_wakeup);
+ extern int ata_slave_link_init(struct ata_port *ap);
+ extern void ata_tf_to_fis(const struct ata_taskfile *tf,
+ 			  u8 pmp, int is_cmd, u8 *fis);
+ extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);
++>>>>>>> ab4117cf2470 (ata: move *sata_set_spd*() to libata-sata.c)
  extern bool sata_lpm_ignore_phy_events(struct ata_link *link);
  
  extern int ata_cable_40wire(struct ata_port *ap);
* Unmerged path drivers/ata/libata-sata.c
* Unmerged path drivers/ata/libata-core.c
* Unmerged path drivers/ata/libata-sata.c
diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index f953cb4bb1ba..295b228d881a 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -103,6 +103,13 @@ extern unsigned int ata_read_log_page(struct ata_device *dev, u8 log,
 
 #define to_ata_port(d) container_of(d, struct ata_port, tdev)
 
+/* libata-sata.c */
+#ifdef CONFIG_SATA_HOST
+int sata_set_spd_needed(struct ata_link *link);
+#else
+static inline int sata_set_spd_needed(struct ata_link *link) { return 1; }
+#endif
+
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
 extern unsigned int ata_acpi_gtf_filter;
* Unmerged path include/linux/libata.h
