KVM: x86: Drop skip MMU sync and TLB flush params from "new PGD" helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Sean Christopherson <seanjc@google.com>
commit b5129100398ac3b6364cfa6dbd55abfd36cf7202
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/b5129100.failed

Drop skip_mmu_sync and skip_tlb_flush from __kvm_mmu_new_pgd() now that
all call sites unconditionally skip both the sync and flush.

No functional change intended.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20210609234235.1244004-8-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit b5129100398ac3b6364cfa6dbd55abfd36cf7202)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/mmu.c
#	arch/x86/kvm/svm/nested.c
diff --cc arch/x86/kvm/mmu/mmu.c
index 3b76d5727c6b,894b9a4a5961..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -4709,7 -4681,7 +4706,11 @@@ void kvm_init_shadow_npt_mmu(struct kvm
  	struct kvm_mmu *context = &vcpu->arch.guest_mmu;
  	union kvm_mmu_role new_role = kvm_calc_shadow_npt_root_page_role(vcpu);
  
++<<<<<<< HEAD
 +	__kvm_mmu_new_pgd(vcpu, nested_cr3, new_role.base, false, false);
++=======
+ 	__kvm_mmu_new_pgd(vcpu, nested_cr3, new_role.base);
++>>>>>>> b5129100398a (KVM: x86: Drop skip MMU sync and TLB flush params from "new PGD" helpers)
  
  	if (new_role.as_u64 != context->mmu_role.as_u64) {
  		shadow_mmu_init_context(vcpu, context, cr0, cr4, efer, new_role);
diff --cc arch/x86/kvm/svm/nested.c
index 776469a3419a,5f45991edcda..000000000000
--- a/arch/x86/kvm/svm/nested.c
+++ b/arch/x86/kvm/svm/nested.c
@@@ -401,12 -413,8 +401,16 @@@ static int nested_svm_load_cr3(struct k
  	    CC(!load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3)))
  		return -EINVAL;
  
 +	/*
 +	 * TODO: optimize unconditional TLB flush/MMU sync here and in
 +	 * kvm_init_shadow_npt_mmu().
 +	 */
  	if (!nested_npt)
++<<<<<<< HEAD
 +		kvm_mmu_new_pgd(vcpu, cr3, false, false);
++=======
+ 		kvm_mmu_new_pgd(vcpu, cr3);
++>>>>>>> b5129100398a (KVM: x86: Drop skip MMU sync and TLB flush params from "new PGD" helpers)
  
  	vcpu->arch.cr3 = cr3;
  	kvm_register_mark_available(vcpu, VCPU_EXREG_CR3);
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 688d90ed3cab..6b4bd70f75d6 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -1700,8 +1700,7 @@ void kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva);
 void kvm_mmu_invalidate_gva(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,
 			    gva_t gva, hpa_t root_hpa);
 void kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid);
-void kvm_mmu_new_pgd(struct kvm_vcpu *vcpu, gpa_t new_pgd, bool skip_tlb_flush,
-		     bool skip_mmu_sync);
+void kvm_mmu_new_pgd(struct kvm_vcpu *vcpu, gpa_t new_pgd);
 
 void kvm_configure_mmu(bool enable_tdp, int tdp_max_root_level,
 		       int tdp_huge_page_level);
* Unmerged path arch/x86/kvm/mmu/mmu.c
* Unmerged path arch/x86/kvm/svm/nested.c
diff --git a/arch/x86/kvm/vmx/nested.c b/arch/x86/kvm/vmx/nested.c
index 0561abd324b4..c3c5d12332ac 100644
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@ -1129,12 +1129,8 @@ static int nested_vmx_load_cr3(struct kvm_vcpu *vcpu, unsigned long cr3,
 		return -EINVAL;
 	}
 
-	/*
-	 * Unconditionally skip the TLB flush on fast CR3 switch, all TLB
-	 * flushes are handled by nested_vmx_transition_tlb_flush().
-	 */
 	if (!nested_ept) {
-		kvm_mmu_new_pgd(vcpu, cr3, true, true);
+		kvm_mmu_new_pgd(vcpu, cr3);
 
 		/*
 		 * A TLB flush on VM-Enter/VM-Exit flushes all linear mappings
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index a1180e6094fb..12c0884e054b 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -1107,7 +1107,7 @@ int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)
 		return 1;
 
 	if (cr3 != kvm_read_cr3(vcpu))
-		kvm_mmu_new_pgd(vcpu, cr3, true, true);
+		kvm_mmu_new_pgd(vcpu, cr3);
 
 	vcpu->arch.cr3 = cr3;
 	kvm_register_mark_available(vcpu, VCPU_EXREG_CR3);
