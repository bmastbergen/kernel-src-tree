net: bridge: mcast: add support for blocked port groups

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 9116ffbf1dd71f953ffda4198d01f82d3ca16df8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/9116ffbf.failed

When excluding S,G entries we need a way to block a particular S,G,port.
The new port group flag is managed based on the source's timer as per
RFCs 3376 and 3810. When a source expires and its port group is in
EXCLUDE mode, it will be blocked.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9116ffbf1dd71f953ffda4198d01f82d3ca16df8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/if_bridge.h
#	net/bridge/br_mdb.c
#	net/bridge/br_multicast.c
#	net/bridge/br_private.h
diff --cc include/uapi/linux/if_bridge.h
index c424bb8708cd,4c687686aa8f..000000000000
--- a/include/uapi/linux/if_bridge.h
+++ b/include/uapi/linux/if_bridge.h
@@@ -459,6 -518,8 +459,11 @@@ struct br_mdb_entry 
  	__u8 state;
  #define MDB_FLAGS_OFFLOAD	(1 << 0)
  #define MDB_FLAGS_FAST_LEAVE	(1 << 1)
++<<<<<<< HEAD
++=======
+ #define MDB_FLAGS_STAR_EXCL	(1 << 2)
+ #define MDB_FLAGS_BLOCKED	(1 << 3)
++>>>>>>> 9116ffbf1dd7 (net: bridge: mcast: add support for blocked port groups)
  	__u8 flags;
  	__u16 vid;
  	struct {
diff --cc net/bridge/br_mdb.c
index 40754c5e5bdc,e15bab19a012..000000000000
--- a/net/bridge/br_mdb.c
+++ b/net/bridge/br_mdb.c
@@@ -62,9 -62,14 +62,16 @@@ static void __mdb_entry_fill_flags(stru
  		e->flags |= MDB_FLAGS_OFFLOAD;
  	if (flags & MDB_PG_FLAGS_FAST_LEAVE)
  		e->flags |= MDB_FLAGS_FAST_LEAVE;
++<<<<<<< HEAD
++=======
+ 	if (flags & MDB_PG_FLAGS_STAR_EXCL)
+ 		e->flags |= MDB_FLAGS_STAR_EXCL;
+ 	if (flags & MDB_PG_FLAGS_BLOCKED)
+ 		e->flags |= MDB_FLAGS_BLOCKED;
++>>>>>>> 9116ffbf1dd7 (net: bridge: mcast: add support for blocked port groups)
  }
  
 -static void __mdb_entry_to_br_ip(struct br_mdb_entry *entry, struct br_ip *ip,
 -				 struct nlattr **mdb_attrs)
 +static void __mdb_entry_to_br_ip(struct br_mdb_entry *entry, struct br_ip *ip)
  {
  	memset(ip, 0, sizeof(struct br_ip));
  	ip->vid = entry->vid;
diff --cc net/bridge/br_multicast.c
index 28b757a17768,11d224c01914..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -65,6 -66,26 +65,29 @@@ static void br_ip6_multicast_leave_grou
  					 const struct in6_addr *group,
  					 __u16 vid, const unsigned char *src);
  #endif
++<<<<<<< HEAD
++=======
+ static struct net_bridge_port_group *
+ __br_multicast_add_group(struct net_bridge *br,
+ 			 struct net_bridge_port *port,
+ 			 struct br_ip *group,
+ 			 const unsigned char *src,
+ 			 u8 filter_mode,
+ 			 bool igmpv2_mldv1,
+ 			 bool blocked);
+ static void br_multicast_find_del_pg(struct net_bridge *br,
+ 				     struct net_bridge_port_group *pg);
+ 
+ static struct net_bridge_port_group *
+ br_sg_port_find(struct net_bridge *br,
+ 		struct net_bridge_port_group_sg_key *sg_p)
+ {
+ 	lockdep_assert_held_once(&br->multicast_lock);
+ 
+ 	return rhashtable_lookup_fast(&br->sg_port_tbl, sg_p,
+ 				      br_sg_port_rht_params);
+ }
++>>>>>>> 9116ffbf1dd7 (net: bridge: mcast: add support for blocked port groups)
  
  static struct net_bridge_mdb_entry *br_mdb_ip_get_rcu(struct net_bridge *br,
  						      struct br_ip *dst)
@@@ -146,6 -185,272 +169,275 @@@ struct net_bridge_mdb_entry *br_mdb_get
  	return br_mdb_ip_get_rcu(br, &ip);
  }
  
++<<<<<<< HEAD
++=======
+ static bool br_port_group_equal(struct net_bridge_port_group *p,
+ 				struct net_bridge_port *port,
+ 				const unsigned char *src)
+ {
+ 	if (p->key.port != port)
+ 		return false;
+ 
+ 	if (!(port->flags & BR_MULTICAST_TO_UNICAST))
+ 		return true;
+ 
+ 	return ether_addr_equal(src, p->eth_addr);
+ }
+ 
+ static void __fwd_add_star_excl(struct net_bridge_port_group *pg,
+ 				struct br_ip *sg_ip)
+ {
+ 	struct net_bridge_port_group_sg_key sg_key;
+ 	struct net_bridge *br = pg->key.port->br;
+ 	struct net_bridge_port_group *src_pg;
+ 
+ 	memset(&sg_key, 0, sizeof(sg_key));
+ 	sg_key.port = pg->key.port;
+ 	sg_key.addr = *sg_ip;
+ 	if (br_sg_port_find(br, &sg_key))
+ 		return;
+ 
+ 	src_pg = __br_multicast_add_group(br, pg->key.port, sg_ip, pg->eth_addr,
+ 					  MCAST_INCLUDE, false, false);
+ 	if (IS_ERR_OR_NULL(src_pg) ||
+ 	    src_pg->rt_protocol != RTPROT_KERNEL)
+ 		return;
+ 
+ 	src_pg->flags |= MDB_PG_FLAGS_STAR_EXCL;
+ }
+ 
+ static void __fwd_del_star_excl(struct net_bridge_port_group *pg,
+ 				struct br_ip *sg_ip)
+ {
+ 	struct net_bridge_port_group_sg_key sg_key;
+ 	struct net_bridge *br = pg->key.port->br;
+ 	struct net_bridge_port_group *src_pg;
+ 
+ 	memset(&sg_key, 0, sizeof(sg_key));
+ 	sg_key.port = pg->key.port;
+ 	sg_key.addr = *sg_ip;
+ 	src_pg = br_sg_port_find(br, &sg_key);
+ 	if (!src_pg || !(src_pg->flags & MDB_PG_FLAGS_STAR_EXCL) ||
+ 	    src_pg->rt_protocol != RTPROT_KERNEL)
+ 		return;
+ 
+ 	br_multicast_find_del_pg(br, src_pg);
+ }
+ 
+ /* When a port group transitions to (or is added as) EXCLUDE we need to add it
+  * to all other ports' S,G entries which are not blocked by the current group
+  * for proper replication, the assumption is that any S,G blocked entries
+  * are already added so the S,G,port lookup should skip them.
+  * When a port group transitions from EXCLUDE -> INCLUDE mode or is being
+  * deleted we need to remove it from all ports' S,G entries where it was
+  * automatically installed before (i.e. where it's MDB_PG_FLAGS_STAR_EXCL).
+  */
+ void br_multicast_star_g_handle_mode(struct net_bridge_port_group *pg,
+ 				     u8 filter_mode)
+ {
+ 	struct net_bridge *br = pg->key.port->br;
+ 	struct net_bridge_port_group *pg_lst;
+ 	struct net_bridge_mdb_entry *mp;
+ 	struct br_ip sg_ip;
+ 
+ 	if (WARN_ON(!br_multicast_is_star_g(&pg->key.addr)))
+ 		return;
+ 
+ 	mp = br_mdb_ip_get(br, &pg->key.addr);
+ 	if (!mp)
+ 		return;
+ 
+ 	memset(&sg_ip, 0, sizeof(sg_ip));
+ 	sg_ip = pg->key.addr;
+ 	for (pg_lst = mlock_dereference(mp->ports, br);
+ 	     pg_lst;
+ 	     pg_lst = mlock_dereference(pg_lst->next, br)) {
+ 		struct net_bridge_group_src *src_ent;
+ 
+ 		if (pg_lst == pg)
+ 			continue;
+ 		hlist_for_each_entry(src_ent, &pg_lst->src_list, node) {
+ 			if (!(src_ent->flags & BR_SGRP_F_INSTALLED))
+ 				continue;
+ 			sg_ip.src = src_ent->addr.src;
+ 			switch (filter_mode) {
+ 			case MCAST_INCLUDE:
+ 				__fwd_del_star_excl(pg, &sg_ip);
+ 				break;
+ 			case MCAST_EXCLUDE:
+ 				__fwd_add_star_excl(pg, &sg_ip);
+ 				break;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ static void br_multicast_sg_del_exclude_ports(struct net_bridge_mdb_entry *sgmp)
+ {
+ 	struct net_bridge_port_group __rcu **pp;
+ 	struct net_bridge_port_group *p;
+ 
+ 	/* *,G exclude ports are only added to S,G entries */
+ 	if (WARN_ON(br_multicast_is_star_g(&sgmp->addr)))
+ 		return;
+ 
+ 	/* we need the STAR_EXCLUDE ports if there are non-STAR_EXCLUDE ports
+ 	 * we should ignore perm entries since they're managed by user-space
+ 	 */
+ 	for (pp = &sgmp->ports;
+ 	     (p = mlock_dereference(*pp, sgmp->br)) != NULL;
+ 	     pp = &p->next)
+ 		if (!(p->flags & (MDB_PG_FLAGS_STAR_EXCL |
+ 				  MDB_PG_FLAGS_PERMANENT)))
+ 			return;
+ 
+ 	for (pp = &sgmp->ports;
+ 	     (p = mlock_dereference(*pp, sgmp->br)) != NULL;) {
+ 		if (!(p->flags & MDB_PG_FLAGS_PERMANENT))
+ 			br_multicast_del_pg(sgmp, p, pp);
+ 		else
+ 			pp = &p->next;
+ 	}
+ }
+ 
+ void br_multicast_sg_add_exclude_ports(struct net_bridge_mdb_entry *star_mp,
+ 				       struct net_bridge_port_group *sg)
+ {
+ 	struct net_bridge_port_group_sg_key sg_key;
+ 	struct net_bridge *br = star_mp->br;
+ 	struct net_bridge_port_group *pg;
+ 
+ 	if (WARN_ON(br_multicast_is_star_g(&sg->key.addr)))
+ 		return;
+ 	if (WARN_ON(!br_multicast_is_star_g(&star_mp->addr)))
+ 		return;
+ 
+ 	memset(&sg_key, 0, sizeof(sg_key));
+ 	sg_key.addr = sg->key.addr;
+ 	/* we need to add all exclude ports to the S,G */
+ 	for (pg = mlock_dereference(star_mp->ports, br);
+ 	     pg;
+ 	     pg = mlock_dereference(pg->next, br)) {
+ 		struct net_bridge_port_group *src_pg;
+ 
+ 		if (pg == sg || pg->filter_mode == MCAST_INCLUDE)
+ 			continue;
+ 
+ 		sg_key.port = pg->key.port;
+ 		if (br_sg_port_find(br, &sg_key))
+ 			continue;
+ 
+ 		src_pg = __br_multicast_add_group(br, pg->key.port,
+ 						  &sg->key.addr,
+ 						  sg->eth_addr,
+ 						  MCAST_INCLUDE, false, false);
+ 		if (IS_ERR_OR_NULL(src_pg) ||
+ 		    src_pg->rt_protocol != RTPROT_KERNEL)
+ 			continue;
+ 		src_pg->flags |= MDB_PG_FLAGS_STAR_EXCL;
+ 	}
+ }
+ 
+ static void br_multicast_fwd_src_add(struct net_bridge_group_src *src)
+ {
+ 	struct net_bridge_mdb_entry *star_mp;
+ 	struct net_bridge_port_group *sg;
+ 	struct br_ip sg_ip;
+ 
+ 	if (src->flags & BR_SGRP_F_INSTALLED)
+ 		return;
+ 
+ 	memset(&sg_ip, 0, sizeof(sg_ip));
+ 	sg_ip = src->pg->key.addr;
+ 	sg_ip.src = src->addr.src;
+ 	sg = __br_multicast_add_group(src->br, src->pg->key.port, &sg_ip,
+ 				      src->pg->eth_addr, MCAST_INCLUDE, false,
+ 				      !timer_pending(&src->timer));
+ 	if (IS_ERR_OR_NULL(sg))
+ 		return;
+ 	src->flags |= BR_SGRP_F_INSTALLED;
+ 	sg->flags &= ~MDB_PG_FLAGS_STAR_EXCL;
+ 
+ 	/* if it was added by user-space as perm we can skip next steps */
+ 	if (sg->rt_protocol != RTPROT_KERNEL &&
+ 	    (sg->flags & MDB_PG_FLAGS_PERMANENT))
+ 		return;
+ 
+ 	/* the kernel is now responsible for removing this S,G */
+ 	del_timer(&sg->timer);
+ 	star_mp = br_mdb_ip_get(src->br, &src->pg->key.addr);
+ 	if (!star_mp)
+ 		return;
+ 
+ 	br_multicast_sg_add_exclude_ports(star_mp, sg);
+ }
+ 
+ static void br_multicast_fwd_src_remove(struct net_bridge_group_src *src)
+ {
+ 	struct net_bridge_port_group *p, *pg = src->pg;
+ 	struct net_bridge_port_group __rcu **pp;
+ 	struct net_bridge_mdb_entry *mp;
+ 	struct br_ip sg_ip;
+ 
+ 	memset(&sg_ip, 0, sizeof(sg_ip));
+ 	sg_ip = pg->key.addr;
+ 	sg_ip.src = src->addr.src;
+ 
+ 	mp = br_mdb_ip_get(src->br, &sg_ip);
+ 	if (!mp)
+ 		return;
+ 
+ 	for (pp = &mp->ports;
+ 	     (p = mlock_dereference(*pp, src->br)) != NULL;
+ 	     pp = &p->next) {
+ 		if (!br_port_group_equal(p, pg->key.port, pg->eth_addr))
+ 			continue;
+ 
+ 		if (p->rt_protocol != RTPROT_KERNEL &&
+ 		    (p->flags & MDB_PG_FLAGS_PERMANENT))
+ 			break;
+ 
+ 		br_multicast_del_pg(mp, p, pp);
+ 		break;
+ 	}
+ 	src->flags &= ~BR_SGRP_F_INSTALLED;
+ }
+ 
+ /* install S,G and based on src's timer enable or disable forwarding */
+ static void br_multicast_fwd_src_handle(struct net_bridge_group_src *src)
+ {
+ 	struct net_bridge_port_group_sg_key sg_key;
+ 	struct net_bridge_port_group *sg;
+ 	u8 old_flags;
+ 
+ 	br_multicast_fwd_src_add(src);
+ 
+ 	memset(&sg_key, 0, sizeof(sg_key));
+ 	sg_key.addr = src->pg->key.addr;
+ 	sg_key.addr.src = src->addr.src;
+ 	sg_key.port = src->pg->key.port;
+ 
+ 	sg = br_sg_port_find(src->br, &sg_key);
+ 	if (!sg || (sg->flags & MDB_PG_FLAGS_PERMANENT))
+ 		return;
+ 
+ 	old_flags = sg->flags;
+ 	if (timer_pending(&src->timer))
+ 		sg->flags &= ~MDB_PG_FLAGS_BLOCKED;
+ 	else
+ 		sg->flags |= MDB_PG_FLAGS_BLOCKED;
+ 
+ 	if (old_flags != sg->flags) {
+ 		struct net_bridge_mdb_entry *sg_mp;
+ 
+ 		sg_mp = br_mdb_ip_get(src->br, &sg_key.addr);
+ 		if (!sg_mp)
+ 			return;
+ 		br_mdb_notify(src->br->dev, sg_mp, sg, RTM_NEWMDB);
+ 	}
+ }
+ 
++>>>>>>> 9116ffbf1dd7 (net: bridge: mcast: add support for blocked port groups)
  static void br_multicast_destroy_mdb_entry(struct net_bridge_mcast_gc *gc)
  {
  	struct net_bridge_mdb_entry *mp;
@@@ -843,20 -1159,20 +1138,31 @@@ void br_multicast_host_leave(struct net
  		br_mdb_notify(mp->br->dev, mp, NULL, RTM_DELMDB);
  }
  
++<<<<<<< HEAD
 +static int br_multicast_add_group(struct net_bridge *br,
 +				  struct net_bridge_port *port,
 +				  struct br_ip *group,
 +				  const unsigned char *src,
 +				  u8 filter_mode,
 +				  bool igmpv2_mldv1)
++=======
+ static struct net_bridge_port_group *
+ __br_multicast_add_group(struct net_bridge *br,
+ 			 struct net_bridge_port *port,
+ 			 struct br_ip *group,
+ 			 const unsigned char *src,
+ 			 u8 filter_mode,
+ 			 bool igmpv2_mldv1,
+ 			 bool blocked)
++>>>>>>> 9116ffbf1dd7 (net: bridge: mcast: add support for blocked port groups)
  {
  	struct net_bridge_port_group __rcu **pp;
 -	struct net_bridge_port_group *p = NULL;
 +	struct net_bridge_port_group *p;
  	struct net_bridge_mdb_entry *mp;
  	unsigned long now = jiffies;
 +	int err;
  
 +	spin_lock(&br->multicast_lock);
  	if (!netif_running(br->dev) ||
  	    (port && port->state == BR_STATE_DISABLED))
  		goto out;
@@@ -880,10 -1195,15 +1186,12 @@@
  			break;
  	}
  
 -	p = br_multicast_new_port_group(port, group, *pp, 0, src, filter_mode,
 -					RTPROT_KERNEL);
 -	if (unlikely(!p)) {
 -		p = ERR_PTR(-ENOMEM);
 -		goto out;
 -	}
 +	p = br_multicast_new_port_group(port, group, *pp, 0, src, filter_mode);
 +	if (unlikely(!p))
 +		goto err;
  	rcu_assign_pointer(*pp, p);
+ 	if (blocked)
+ 		p->flags |= MDB_PG_FLAGS_BLOCKED;
  	br_mdb_notify(br->dev, mp, p, RTM_NEWMDB);
  
  found:
@@@ -891,10 -1211,26 +1199,28 @@@
  		mod_timer(&p->timer, now + br->multicast_membership_interval);
  
  out:
 -	return p;
 -}
 +	err = 0;
  
++<<<<<<< HEAD
 +err:
++=======
+ static int br_multicast_add_group(struct net_bridge *br,
+ 				  struct net_bridge_port *port,
+ 				  struct br_ip *group,
+ 				  const unsigned char *src,
+ 				  u8 filter_mode,
+ 				  bool igmpv2_mldv1)
+ {
+ 	struct net_bridge_port_group *pg;
+ 	int err;
+ 
+ 	spin_lock(&br->multicast_lock);
+ 	pg = __br_multicast_add_group(br, port, group, src, filter_mode,
+ 				      igmpv2_mldv1, false);
+ 	/* NULL is considered valid for host joined groups */
+ 	err = IS_ERR(pg) ? PTR_ERR(pg) : 0;
++>>>>>>> 9116ffbf1dd7 (net: bridge: mcast: add support for blocked port groups)
  	spin_unlock(&br->multicast_lock);
 -
  	return err;
  }
  
diff --cc net/bridge/br_private.h
index 26b3cc8b3453,345118e35c42..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -213,6 -213,8 +213,11 @@@ struct net_bridge_fdb_entry 
  #define MDB_PG_FLAGS_PERMANENT	BIT(0)
  #define MDB_PG_FLAGS_OFFLOAD	BIT(1)
  #define MDB_PG_FLAGS_FAST_LEAVE	BIT(2)
++<<<<<<< HEAD
++=======
+ #define MDB_PG_FLAGS_STAR_EXCL	BIT(3)
+ #define MDB_PG_FLAGS_BLOCKED	BIT(4)
++>>>>>>> 9116ffbf1dd7 (net: bridge: mcast: add support for blocked port groups)
  
  #define PG_SRC_ENT_LIMIT	32
  
* Unmerged path include/uapi/linux/if_bridge.h
* Unmerged path net/bridge/br_mdb.c
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_private.h
