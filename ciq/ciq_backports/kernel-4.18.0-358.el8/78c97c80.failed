ata: move sata_link_hardreset() to libata-sata.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
commit 78c97c80d76b0590fc6ff5e20f4b18f105aa4fae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/78c97c80.failed

* move sata_link_hardreset() to libata-sata.c

* add static inline for CONFIG_SATA_HOST=n case

* make sata_set_spd_needed() static

Code size savings on m68k arch using (modified) atari_defconfig:

   text    data     bss     dec     hex filename
before:
  32724     572      40   33336    8238 drivers/ata/libata-core.o
after:
  32559     572      40   33171    8193 drivers/ata/libata-core.o

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 78c97c80d76b0590fc6ff5e20f4b18f105aa4fae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ata/libata-core.c
#	drivers/ata/libata-sata.c
#	include/linux/libata.h
diff --cc drivers/ata/libata-core.c
index d6da17431f7f,19624d056d92..000000000000
--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@@ -4051,120 -3529,9 +4051,123 @@@ int ata_std_prereset(struct ata_link *l
  
  	return 0;
  }
 -EXPORT_SYMBOL_GPL(ata_std_prereset);
  
  /**
++<<<<<<< HEAD
 + *	sata_link_hardreset - reset link via SATA phy reset
 + *	@link: link to reset
 + *	@timing: timing parameters { interval, duration, timeout } in msec
 + *	@deadline: deadline jiffies for the operation
 + *	@online: optional out parameter indicating link onlineness
 + *	@check_ready: optional callback to check link readiness
 + *
 + *	SATA phy-reset @link using DET bits of SControl register.
 + *	After hardreset, link readiness is waited upon using
 + *	ata_wait_ready() if @check_ready is specified.  LLDs are
 + *	allowed to not specify @check_ready and wait itself after this
 + *	function returns.  Device classification is LLD's
 + *	responsibility.
 + *
 + *	*@online is set to one iff reset succeeded and @link is online
 + *	after reset.
 + *
 + *	LOCKING:
 + *	Kernel thread context (may sleep)
 + *
 + *	RETURNS:
 + *	0 on success, -errno otherwise.
 + */
 +int sata_link_hardreset(struct ata_link *link, const unsigned long *timing,
 +			unsigned long deadline,
 +			bool *online, int (*check_ready)(struct ata_link *))
 +{
 +	u32 scontrol;
 +	int rc;
 +
 +	DPRINTK("ENTER\n");
 +
 +	if (online)
 +		*online = false;
 +
 +	if (sata_set_spd_needed(link)) {
 +		/* SATA spec says nothing about how to reconfigure
 +		 * spd.  To be on the safe side, turn off phy during
 +		 * reconfiguration.  This works for at least ICH7 AHCI
 +		 * and Sil3124.
 +		 */
 +		if ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))
 +			goto out;
 +
 +		scontrol = (scontrol & 0x0f0) | 0x304;
 +
 +		if ((rc = sata_scr_write(link, SCR_CONTROL, scontrol)))
 +			goto out;
 +
 +		sata_set_spd(link);
 +	}
 +
 +	/* issue phy wake/reset */
 +	if ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))
 +		goto out;
 +
 +	scontrol = (scontrol & 0x0f0) | 0x301;
 +
 +	if ((rc = sata_scr_write_flush(link, SCR_CONTROL, scontrol)))
 +		goto out;
 +
 +	/* Couldn't find anything in SATA I/II specs, but AHCI-1.1
 +	 * 10.4.2 says at least 1 ms.
 +	 */
 +	ata_msleep(link->ap, 1);
 +
 +	/* bring link back */
 +	rc = sata_link_resume(link, timing, deadline);
 +	if (rc)
 +		goto out;
 +	/* if link is offline nothing more to do */
 +	if (ata_phys_link_offline(link))
 +		goto out;
 +
 +	/* Link is online.  From this point, -ENODEV too is an error. */
 +	if (online)
 +		*online = true;
 +
 +	if (sata_pmp_supported(link->ap) && ata_is_host_link(link)) {
 +		/* If PMP is supported, we have to do follow-up SRST.
 +		 * Some PMPs don't send D2H Reg FIS after hardreset if
 +		 * the first port is empty.  Wait only for
 +		 * ATA_TMOUT_PMP_SRST_WAIT.
 +		 */
 +		if (check_ready) {
 +			unsigned long pmp_deadline;
 +
 +			pmp_deadline = ata_deadline(jiffies,
 +						    ATA_TMOUT_PMP_SRST_WAIT);
 +			if (time_after(pmp_deadline, deadline))
 +				pmp_deadline = deadline;
 +			ata_wait_ready(link, pmp_deadline, check_ready);
 +		}
 +		rc = -EAGAIN;
 +		goto out;
 +	}
 +
 +	rc = 0;
 +	if (check_ready)
 +		rc = ata_wait_ready(link, deadline, check_ready);
 + out:
 +	if (rc && rc != -EAGAIN) {
 +		/* online is set iff link is online && reset succeeded */
 +		if (online)
 +			*online = false;
 +		ata_link_err(link, "COMRESET failed (errno=%d)\n", rc);
 +	}
 +	DPRINTK("EXIT, rc=%d\n", rc);
 +	return rc;
 +}
 +
 +/**
++=======
++>>>>>>> 78c97c80d76b (ata: move sata_link_hardreset() to libata-sata.c)
   *	sata_std_hardreset - COMRESET w/o waiting or classification
   *	@link: link to reset
   *	@class: resulting class of attached device
diff --cc include/linux/libata.h
index ce0dc53b9adc,981f73c02509..000000000000
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@@ -1097,15 -1077,6 +1097,18 @@@ extern int sata_set_spd(struct ata_lin
  extern int ata_std_prereset(struct ata_link *link, unsigned long deadline);
  extern int ata_wait_after_reset(struct ata_link *link, unsigned long deadline,
  				int (*check_ready)(struct ata_link *link));
++<<<<<<< HEAD
 +extern int sata_link_debounce(struct ata_link *link,
 +			const unsigned long *params, unsigned long deadline);
 +extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
 +			    unsigned long deadline);
 +extern int sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,
 +			     bool spm_wakeup);
 +extern int sata_link_hardreset(struct ata_link *link,
 +			const unsigned long *timing, unsigned long deadline,
 +			bool *online, int (*check_ready)(struct ata_link *));
++=======
++>>>>>>> 78c97c80d76b (ata: move sata_link_hardreset() to libata-sata.c)
  extern int sata_std_hardreset(struct ata_link *link, unsigned int *class,
  			      unsigned long deadline);
  extern void ata_std_postreset(struct ata_link *link, unsigned int *classes);
@@@ -1208,6 -1177,61 +1211,64 @@@ extern struct ata_device *ata_dev_pair(
  extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
  extern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);
  extern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap, struct list_head *eh_q);
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * SATA specific code - drivers/ata/libata-sata.c
+  */
+ #ifdef CONFIG_SATA_HOST
+ extern int sata_scr_valid(struct ata_link *link);
+ extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
+ extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
+ extern int sata_scr_write_flush(struct ata_link *link, int reg, u32 val);
+ extern int sata_set_spd(struct ata_link *link);
+ extern int sata_link_hardreset(struct ata_link *link,
+ 			const unsigned long *timing, unsigned long deadline,
+ 			bool *online, int (*check_ready)(struct ata_link *));
+ extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
+ 			    unsigned long deadline);
+ #else
+ static inline int sata_scr_valid(struct ata_link *link) { return 0; }
+ static inline int sata_scr_read(struct ata_link *link, int reg, u32 *val)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int sata_scr_write(struct ata_link *link, int reg, u32 val)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int sata_scr_write_flush(struct ata_link *link, int reg, u32 val)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int sata_set_spd(struct ata_link *link) { return -EOPNOTSUPP; }
+ static inline int sata_link_hardreset(struct ata_link *link,
+ 				      const unsigned long *timing,
+ 				      unsigned long deadline,
+ 				      bool *online,
+ 				      int (*check_ready)(struct ata_link *))
+ {
+ 	if (online)
+ 		*online = false;
+ 	return -EOPNOTSUPP;
+ }
+ static inline int sata_link_resume(struct ata_link *link,
+ 				   const unsigned long *params,
+ 				   unsigned long deadline)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ #endif
+ extern int sata_link_debounce(struct ata_link *link,
+ 			const unsigned long *params, unsigned long deadline);
+ extern int sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,
+ 			     bool spm_wakeup);
+ extern int ata_slave_link_init(struct ata_port *ap);
+ extern void ata_tf_to_fis(const struct ata_taskfile *tf,
+ 			  u8 pmp, int is_cmd, u8 *fis);
+ extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);
++>>>>>>> 78c97c80d76b (ata: move sata_link_hardreset() to libata-sata.c)
  extern bool sata_lpm_ignore_phy_events(struct ata_link *link);
  
  extern int ata_cable_40wire(struct ata_port *ap);
* Unmerged path drivers/ata/libata-sata.c
* Unmerged path drivers/ata/libata-core.c
* Unmerged path drivers/ata/libata-sata.c
* Unmerged path include/linux/libata.h
