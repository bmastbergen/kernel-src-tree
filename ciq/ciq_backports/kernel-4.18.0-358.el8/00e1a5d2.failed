PCI/VPD: Defer VPD sizing until first access

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Bjorn Helgaas <bhelgaas@google.com>
commit 00e1a5d21b4ff514593554167b28a8caeda1497f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/00e1a5d2.failed

7bac54497c3e ("PCI/VPD: Determine VPD size in pci_vpd_init()") reads VPD at
enumeration-time to find the size.  But this is quite slow, and we don't
need the size until we actually need data from VPD.  Dave reported a boot
slowdown of more than two minutes [1].

Defer the VPD sizing until a driver or the user (via sysfs) requests
information from VPD.

If devices are quirked because VPD is known not to work, don't bother even
looking for the VPD capability.  The VPD will not be accessible at all.

[1] https://lore.kernel.org/r/20210913141818.GA27911@codemonkey.org.uk/
Link: https://lore.kernel.org/r/20210914215543.GA1437800@bjorn-Precision-5520
Fixes: 7bac54497c3e ("PCI/VPD: Determine VPD size in pci_vpd_init()")
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 00e1a5d21b4ff514593554167b28a8caeda1497f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/vpd.c
diff --cc drivers/pci/vpd.c
index 799ce083bd7b,4be24890132e..000000000000
--- a/drivers/pci/vpd.c
+++ b/drivers/pci/vpd.c
@@@ -151,7 -163,7 +169,11 @@@ static ssize_t pci_vpd_read(struct pci_
  	loff_t end = pos + count;
  	u8 *buf = arg;
  
++<<<<<<< HEAD
 +	if (!vpd)
++=======
+ 	if (!pci_vpd_available(dev))
++>>>>>>> 00e1a5d21b4f (PCI/VPD: Defer VPD sizing until first access)
  		return -ENODEV;
  
  	if (pos < 0)
@@@ -218,7 -224,7 +240,11 @@@ static ssize_t pci_vpd_write(struct pci
  	loff_t end = pos + count;
  	int ret = 0;
  
++<<<<<<< HEAD
 +	if (!vpd)
++=======
+ 	if (!pci_vpd_available(dev))
++>>>>>>> 00e1a5d21b4f (PCI/VPD: Defer VPD sizing until first access)
  		return -ENODEV;
  
  	if (pos < 0 || (pos & 3) || (count & 3))
@@@ -260,25 -260,11 +286,33 @@@
  
  void pci_vpd_init(struct pci_dev *dev)
  {
++<<<<<<< HEAD
 +	struct pci_vpd *vpd;
 +	u8 cap;
 +
 +	cap = pci_find_capability(dev, PCI_CAP_ID_VPD);
 +	if (!cap)
 +		return;
 +
 +	vpd = kzalloc(sizeof(*vpd), GFP_ATOMIC);
 +	if (!vpd)
 +		return;
 +
 +	mutex_init(&vpd->lock);
 +	vpd->cap = cap;
 +	dev->vpd = vpd;
 +}
 +
 +void pci_vpd_release(struct pci_dev *dev)
 +{
 +	kfree(dev->vpd);
++=======
+ 	if (dev->vpd.len == PCI_VPD_SZ_INVALID)
+ 		return;
+ 
+ 	dev->vpd.cap = pci_find_capability(dev, PCI_CAP_ID_VPD);
+ 	mutex_init(&dev->vpd.lock);
++>>>>>>> 00e1a5d21b4f (PCI/VPD: Defer VPD sizing until first access)
  }
  
  static ssize_t vpd_read(struct file *filp, struct kobject *kobj,
* Unmerged path drivers/pci/vpd.c
