selftests: xsk: Implement bpf_link test

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Maciej Fijalkowski <maciej.fijalkowski@intel.com>
commit 27e1ca2525de264901b5c2d9d0c4403c3fe8608c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/27e1ca25.failed

Introduce a test that is supposed to verify the persistence of BPF
resources based on underlying bpf_link usage.

Test will:
1) create and bind two sockets on queue ids 0 and 1
2) run a traffic on queue ids 0
3) remove xsk sockets from queue 0 on both veth interfaces
4) run a traffic on queues ids 1

Running traffic successfully on qids 1 means that BPF resources were
not removed on step 3).

In order to make it work, change the command that creates veth pair to
have the 4 queue pairs by default.

Introduce the arrays of xsks and umems to ifobject struct but keep a
pointers to single entities, so rest of the logic around Rx/Tx can be
kept as-is.

For umem handling, double the size of mmapped space and split that
between the two sockets.

Rename also bidi_pass to a variable 'second_step' of a boolean type as
it's now used also for the test that is introduced here and it doesn't
have anything in common with bi-directional testing.

Drop opt_queue command line argument as it wasn't working before anyway.

	Signed-off-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20210329224316.17793-15-maciej.fijalkowski@intel.com
(cherry picked from commit 27e1ca2525de264901b5c2d9d0c4403c3fe8608c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/xdpxceiver.c
#	tools/testing/selftests/bpf/xdpxceiver.h
diff --cc tools/testing/selftests/bpf/xdpxceiver.c
index 9f8d5dabf30a,5c0d6dbd076f..000000000000
--- a/tools/testing/selftests/bpf/xdpxceiver.c
+++ b/tools/testing/selftests/bpf/xdpxceiver.c
@@@ -33,19 -28,25 +33,41 @@@
   *       Configure sockets as bi-directional tx/rx sockets, sets up fill and
   *       completion rings on each socket, tx/rx in both directions. Only nopoll
   *       mode is used
++<<<<<<< HEAD
 + *
 + * 2. AF_XDP DRV/Native mode
 + *    Works on any netdevice with XDP_REDIRECT support, driver dependent. Processes
 + *    packets before SKB allocation. Provides better performance than SKB. Driver
 + *    hook available just after DMA of buffer descriptor.
 + *    a. nopoll
 + *    b. poll
 + *    c. Socket Teardown
 + *    d. Bi-directional sockets
 + *    - Only copy mode is supported because veth does not currently support
 + *      zero-copy mode
 + *
 + * Total tests: 8
++=======
+  *    e. Statistics
+  *       Trigger some error conditions and ensure that the appropriate statistics
+  *       are incremented. Within this test, the following statistics are tested:
+  *       i.   rx dropped
+  *            Increase the UMEM frame headroom to a value which results in
+  *            insufficient space in the rx buffer for both the packet and the headroom.
+  *       ii.  tx invalid
+  *            Set the 'len' field of tx descriptors to an invalid value (umem frame
+  *            size + 1).
+  *       iii. rx ring full
+  *            Reduce the size of the RX ring to a fraction of the fill ring size.
+  *       iv.  fill queue empty
+  *            Do not populate the fill queue and then try to receive pkts.
+  *    f. bpf_link resource persistence
+  *       Configure sockets at indexes 0 and 1, run a traffic on queue ids 0,
+  *       then remove xsk sockets from queue 0 on both veth interfaces and
+  *       finally run a traffic on queues ids 1
+  *
+  * Total tests: 12
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
   *
   * Flow:
   * -----
@@@ -106,24 -119,23 +128,33 @@@ static void __exit_with_error(int error
  #define exit_with_error(error) __exit_with_error(error, __FILE__, __func__, __LINE__)
  
  #define print_ksft_result(void)\
++<<<<<<< HEAD
 +	(ksft_test_result_pass("PASS: %s %s %s%s\n", uut ? "DRV" : "SKB", opt_poll ? "POLL" :\
 +			       "NOPOLL", opt_teardown ? "Socket Teardown" : "",\
 +			       opt_bidi ? "Bi-directional Sockets" : ""))
++=======
+ 	(ksft_test_result_pass("PASS: %s %s %s%s%s%s\n", configured_mode ? "DRV" : "SKB",\
+ 			       test_type == TEST_TYPE_POLL ? "POLL" : "NOPOLL",\
+ 			       test_type == TEST_TYPE_TEARDOWN ? "Socket Teardown" : "",\
+ 			       test_type == TEST_TYPE_BIDI ? "Bi-directional Sockets" : "",\
+ 			       test_type == TEST_TYPE_STATS ? "Stats" : "",\
+ 			       test_type == TEST_TYPE_BPF_RES ? "BPF RES" : ""))
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  
 -static void init_sync_resources(void)
 +static void pthread_init_mutex(void)
  {
  	pthread_mutex_init(&sync_mutex, NULL);
 +	pthread_mutex_init(&sync_mutex_tx, NULL);
  	pthread_cond_init(&signal_rx_condition, NULL);
 +	pthread_cond_init(&signal_tx_condition, NULL);
  }
  
 -static void destroy_sync_resources(void)
 +static void pthread_destroy_mutex(void)
  {
  	pthread_mutex_destroy(&sync_mutex);
 +	pthread_mutex_destroy(&sync_mutex_tx);
  	pthread_cond_destroy(&signal_rx_condition);
 +	pthread_cond_destroy(&signal_tx_condition);
  }
  
  static void *memset32_htonl(void *dest, u32 val, u32 size)
@@@ -251,16 -263,25 +282,33 @@@ static void gen_eth_frame(struct xsk_um
  	memcpy(xsk_umem__get_data(umem->buffer, addr), pkt_data, PKT_SIZE);
  }
  
- static void xsk_configure_umem(struct ifobject *data, void *buffer, u64 size)
+ static void xsk_configure_umem(struct ifobject *data, void *buffer, int idx)
  {
++<<<<<<< HEAD
++=======
+ 	struct xsk_umem_config cfg = {
+ 		.fill_size = XSK_RING_PROD__DEFAULT_NUM_DESCS,
+ 		.comp_size = XSK_RING_CONS__DEFAULT_NUM_DESCS,
+ 		.frame_size = XSK_UMEM__DEFAULT_FRAME_SIZE,
+ 		.frame_headroom = frame_headroom,
+ 		.flags = XSK_UMEM__DEFAULT_FLAGS
+ 	};
+ 	int size = num_frames * XSK_UMEM__DEFAULT_FRAME_SIZE;
+ 	struct xsk_umem_info *umem;
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  	int ret;
  
- 	data->umem = calloc(1, sizeof(struct xsk_umem_info));
- 	if (!data->umem)
+ 	umem = calloc(1, sizeof(struct xsk_umem_info));
+ 	if (!umem)
  		exit_with_error(errno);
  
++<<<<<<< HEAD
 +	ret = xsk_umem__create(&data->umem->umem, buffer, size,
 +			       &data->umem->fq, &data->umem->cq, NULL);
++=======
+ 	ret = xsk_umem__create(&umem->umem, buffer, size,
+ 			       &umem->fq, &umem->cq, &cfg);
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  	if (ret)
  		exit_with_error(ret);
  
@@@ -287,28 -311,27 +338,38 @@@ static int xsk_configure_socket(struct 
  	struct xsk_ring_prod *txr;
  	int ret;
  
- 	ifobject->xsk = calloc(1, sizeof(struct xsk_socket_info));
- 	if (!ifobject->xsk)
+ 	xsk = calloc(1, sizeof(struct xsk_socket_info));
+ 	if (!xsk)
  		exit_with_error(errno);
  
++<<<<<<< HEAD
 +	ifobject->xsk->umem = ifobject->umem;
 +	cfg.rx_size = XSK_RING_CONS__DEFAULT_NUM_DESCS;
++=======
+ 	xsk->umem = ifobject->umem;
+ 	cfg.rx_size = rxqsize;
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  	cfg.tx_size = XSK_RING_PROD__DEFAULT_NUM_DESCS;
  	cfg.libbpf_flags = 0;
 -	cfg.xdp_flags = xdp_flags;
 -	cfg.bind_flags = xdp_bind_flags;
 -
 +	cfg.xdp_flags = opt_xdp_flags;
 +	cfg.bind_flags = opt_xdp_bind_flags;
 +
++<<<<<<< HEAD
 +	if (!opt_bidi) {
 +		rxr = (ifobject->fv.vector == rx) ? &ifobject->xsk->rx : NULL;
 +		txr = (ifobject->fv.vector == tx) ? &ifobject->xsk->tx : NULL;
++=======
+ 	if (test_type != TEST_TYPE_BIDI) {
+ 		rxr = (ifobject->fv.vector == rx) ? &xsk->rx : NULL;
+ 		txr = (ifobject->fv.vector == tx) ? &xsk->tx : NULL;
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  	} else {
- 		rxr = &ifobject->xsk->rx;
- 		txr = &ifobject->xsk->tx;
+ 		rxr = &xsk->rx;
+ 		txr = &xsk->tx;
  	}
  
- 	ret = xsk_socket__create(&ifobject->xsk->xsk, ifobject->ifname,
- 				 opt_queue, ifobject->umem->umem, rxr, txr, &cfg);
- 
+ 	ret = xsk_socket__create(&xsk->xsk, ifobject->ifname, idx,
+ 				 ifobject->umem->umem, rxr, txr, &cfg);
  	if (ret)
  		return 1;
  
@@@ -432,7 -404,7 +495,11 @@@ static void parse_command_line(int argc
  	opterr = 0;
  
  	for (;;) {
++<<<<<<< HEAD
 +		c = getopt_long(argc, argv, "i:q:pSNcTBDC:v", long_options, &option_index);
++=======
+ 		c = getopt_long(argc, argv, "i:DC:v", long_options, &option_index);
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  
  		if (c == -1)
  			break;
@@@ -452,31 -424,6 +519,34 @@@
  				       MAX_INTERFACES_NAMESPACE_CHARS);
  			interface_index++;
  			break;
++<<<<<<< HEAD
 +		case 'q':
 +			opt_queue = atoi(optarg);
 +			break;
 +		case 'p':
 +			opt_poll = 1;
 +			break;
 +		case 'S':
 +			opt_xdp_flags |= XDP_FLAGS_SKB_MODE;
 +			opt_xdp_bind_flags |= XDP_COPY;
 +			uut = ORDER_CONTENT_VALIDATE_XDP_SKB;
 +			break;
 +		case 'N':
 +			opt_xdp_flags |= XDP_FLAGS_DRV_MODE;
 +			opt_xdp_bind_flags |= XDP_COPY;
 +			uut = ORDER_CONTENT_VALIDATE_XDP_DRV;
 +			break;
 +		case 'c':
 +			opt_xdp_bind_flags |= XDP_COPY;
 +			break;
 +		case 'T':
 +			opt_teardown = 1;
 +			break;
 +		case 'B':
 +			opt_bidi = 1;
 +			break;
++=======
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  		case 'D':
  			debug_pkt_dump = 1;
  			break;
@@@ -757,26 -758,35 +827,51 @@@ static void worker_pkt_validate(void
  	}
  }
  
 -static void thread_common_ops(struct ifobject *ifobject, void *bufs)
 +static void thread_common_ops(struct ifobject *ifobject, void *bufs, pthread_mutex_t *mutexptr,
 +			      atomic_int *spinningptr)
  {
+ 	int umem_sz = num_frames * XSK_UMEM__DEFAULT_FRAME_SIZE;
  	int ctr = 0;
  	int ret;
  
++<<<<<<< HEAD
 +	xsk_configure_umem(ifobject, bufs, num_frames * XSK_UMEM__DEFAULT_FRAME_SIZE);
 +	ret = xsk_configure_socket(ifobject);
++=======
+ 	pthread_attr_setstacksize(&attr, THREAD_STACK);
+ 
+ 	ifobject->ns_fd = switch_namespace(ifobject->nsname);
+ 
+ 	if (test_type == TEST_TYPE_BPF_RES)
+ 		umem_sz *= 2;
+ 
+ 	bufs = mmap(NULL, umem_sz,
+ 		    PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+ 	if (bufs == MAP_FAILED)
+ 		exit_with_error(errno);
+ 
+ 	xsk_configure_umem(ifobject, bufs, 0);
+ 	ifobject->umem = ifobject->umem_arr[0];
+ 	ret = xsk_configure_socket(ifobject, 0);
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  
  	/* Retry Create Socket if it fails as xsk_socket__create()
  	 * is asynchronous
 +	 *
 +	 * Essential to lock Mutex here to prevent Tx thread from
 +	 * entering before Rx and causing a deadlock
  	 */
 +	pthread_mutex_lock(mutexptr);
  	while (ret && ctr < SOCK_RECONF_CTR) {
++<<<<<<< HEAD
 +		atomic_store(spinningptr, 1);
 +		xsk_configure_umem(ifobject, bufs, num_frames * XSK_UMEM__DEFAULT_FRAME_SIZE);
 +		ret = xsk_configure_socket(ifobject);
++=======
+ 		xsk_configure_umem(ifobject, bufs, 0);
+ 		ifobject->umem = ifobject->umem_arr[0];
+ 		ret = xsk_configure_socket(ifobject, 0);
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  		usleep(USLEEP_MAX);
  		ctr++;
  	}
@@@ -785,9 -793,36 +880,42 @@@
  
  	if (ctr >= SOCK_RECONF_CTR)
  		exit_with_error(ret);
++<<<<<<< HEAD
 +}
 +
 +static void *worker_testapp_validate(void *arg)
++=======
+ 
+ 	ifobject->umem = ifobject->umem_arr[0];
+ 	ifobject->xsk = ifobject->xsk_arr[0];
+ 
+ 	if (test_type == TEST_TYPE_BPF_RES) {
+ 		xsk_configure_umem(ifobject, (u8 *)bufs + (umem_sz / 2), 1);
+ 		ifobject->umem = ifobject->umem_arr[1];
+ 		ret = xsk_configure_socket(ifobject, 1);
+ 	}
+ 
+ 	ifobject->umem = ifobject->umem_arr[0];
+ 	ifobject->xsk = ifobject->xsk_arr[0];
+ 	print_verbose("Interface [%s] vector [%s]\n",
+ 		      ifobject->ifname, ifobject->fv.vector == tx ? "Tx" : "Rx");
+ }
+ 
+ static bool testapp_is_test_two_stepped(void)
+ {
+ 	return (test_type != TEST_TYPE_BIDI && test_type != TEST_TYPE_BPF_RES) || second_step;
+ }
+ 
+ static void testapp_cleanup_xsk_res(struct ifobject *ifobj)
+ {
+ 	if (testapp_is_test_two_stepped()) {
+ 		xsk_socket__delete(ifobj->xsk->xsk);
+ 		(void)xsk_umem__delete(ifobj->umem->umem);
+ 	}
+ }
+ 
+ static void *worker_testapp_validate_tx(void *arg)
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  {
  	struct udphdr *udp_hdr =
  	    (struct udphdr *)(pkt_data + sizeof(struct ethhdr) + sizeof(struct iphdr));
@@@ -797,100 -832,82 +925,131 @@@
  	struct generic_data data;
  	void *bufs = NULL;
  
++<<<<<<< HEAD
 +	pthread_attr_setstacksize(&attr, THREAD_STACK);
++=======
+ 	if (!second_step)
+ 		thread_common_ops(ifobject, bufs);
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
 +
 +	if (!bidi_pass) {
 +		bufs = mmap(NULL, num_frames * XSK_UMEM__DEFAULT_FRAME_SIZE,
 +			    PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
 +		if (bufs == MAP_FAILED)
 +			exit_with_error(errno);
  
 -	for (int i = 0; i < num_frames; i++) {
 -		/*send EOT frame */
 -		if (i == (num_frames - 1))
 -			data.seqnum = -1;
 -		else
 -			data.seqnum = i;
 -		gen_udp_hdr(&data, ifobject, udp_hdr);
 -		gen_ip_hdr(ifobject, ip_hdr);
 -		gen_udp_csum(udp_hdr, ip_hdr);
 -		gen_eth_hdr(ifobject, eth_hdr);
 -		gen_eth_frame(ifobject->umem, i * XSK_UMEM__DEFAULT_FRAME_SIZE);
 +		if (strcmp(ifobject->nsname, ""))
 +			switch_namespace(ifobject->ifdict_index);
  	}
  
 -	print_verbose("Sending %d packets on interface %s\n",
 -		      (opt_pkt_count - 1), ifobject->ifname);
 -	tx_only_all(ifobject);
 +	if (ifobject->fv.vector == tx) {
 +		int spinningrxctr = 0;
  
++<<<<<<< HEAD
 +		if (!bidi_pass)
 +			thread_common_ops(ifobject, bufs, &sync_mutex_tx, &spinning_tx);
++=======
+ 	testapp_cleanup_xsk_res(ifobject);
+ 	pthread_exit(NULL);
+ }
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  
 -static void *worker_testapp_validate_rx(void *arg)
 -{
 -	struct ifobject *ifobject = (struct ifobject *)arg;
 -	struct pollfd fds[MAX_SOCKS] = { };
 -	void *bufs = NULL;
 +		while (atomic_load(&spinning_rx) && spinningrxctr < SOCK_RECONF_CTR) {
 +			spinningrxctr++;
 +			usleep(USLEEP_MAX);
 +		}
  
++<<<<<<< HEAD
 +		print_verbose("Interface [%s] vector [Tx]\n", ifobject->ifname);
 +		for (int i = 0; i < num_frames; i++) {
 +			/*send EOT frame */
 +			if (i == (num_frames - 1))
 +				data.seqnum = -1;
 +			else
 +				data.seqnum = i;
 +			gen_udp_hdr(&data, ifobject, udp_hdr);
 +			gen_ip_hdr(ifobject, ip_hdr);
 +			gen_udp_csum(udp_hdr, ip_hdr);
 +			gen_eth_hdr(ifobject, eth_hdr);
 +			gen_eth_frame(ifobject->umem, i * XSK_UMEM__DEFAULT_FRAME_SIZE);
 +		}
++=======
+ 	if (!second_step)
+ 		thread_common_ops(ifobject, bufs);
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  
 -	if (stat_test_type != STAT_TEST_RX_FILL_EMPTY)
 +		print_verbose("Sending %d packets on interface %s\n",
 +			       (opt_pkt_count - 1), ifobject->ifname);
 +		tx_only_all(ifobject);
 +	} else if (ifobject->fv.vector == rx) {
 +		struct pollfd fds[MAX_SOCKS] = { };
 +		int ret;
 +
 +		if (!bidi_pass)
 +			thread_common_ops(ifobject, bufs, &sync_mutex_tx, &spinning_rx);
 +
 +		print_verbose("Interface [%s] vector [Rx]\n", ifobject->ifname);
  		xsk_populate_fill_ring(ifobject->umem);
  
 -	TAILQ_INIT(&head);
 -	if (debug_pkt_dump) {
 -		pkt_buf = calloc(num_frames, sizeof(*pkt_buf));
 -		if (!pkt_buf)
 -			exit_with_error(errno);
 -	}
 +		TAILQ_INIT(&head);
 +		if (debug_pkt_dump) {
 +			pkt_buf = calloc(num_frames, sizeof(*pkt_buf));
 +			if (!pkt_buf)
 +				exit_with_error(errno);
 +		}
  
 -	fds[0].fd = xsk_socket__fd(ifobject->xsk->xsk);
 -	fds[0].events = POLLIN;
 +		fds[0].fd = xsk_socket__fd(ifobject->xsk->xsk);
 +		fds[0].events = POLLIN;
  
 -	pthread_mutex_lock(&sync_mutex);
 -	pthread_cond_signal(&signal_rx_condition);
 -	pthread_mutex_unlock(&sync_mutex);
 +		pthread_mutex_lock(&sync_mutex);
 +		pthread_cond_signal(&signal_rx_condition);
 +		pthread_mutex_unlock(&sync_mutex);
  
 -	while (1) {
 -		if (test_type != TEST_TYPE_STATS) {
 +		while (1) {
 +			if (opt_poll) {
 +				ret = poll(fds, 1, POLL_TMOUT);
 +				if (ret <= 0)
 +					continue;
 +			}
  			rx_pkt(ifobject->xsk, fds);
  			worker_pkt_validate();
 -		} else {
 -			worker_stats_validate(ifobject);
 +
 +			if (sigvar)
 +				break;
  		}
 -		if (sigvar)
 -			break;
 +
 +		print_verbose("Received %d packets on interface %s\n",
 +			       pkt_counter, ifobject->ifname);
 +
 +		if (opt_teardown)
 +			print_verbose("Destroying socket\n");
  	}
  
++<<<<<<< HEAD
 +	if (!opt_bidi || bidi_pass) {
 +		xsk_socket__delete(ifobject->xsk->xsk);
 +		(void)xsk_umem__delete(ifobject->umem->umem);
 +	}
++=======
+ 	print_verbose("Received %d packets on interface %s\n",
+ 		      pkt_counter, ifobject->ifname);
+ 
+ 	if (test_type == TEST_TYPE_TEARDOWN)
+ 		print_verbose("Destroying socket\n");
+ 
+ 	testapp_cleanup_xsk_res(ifobject);
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  	pthread_exit(NULL);
  }
  
  static void testapp_validate(void)
  {
  	struct timespec max_wait = { 0, 0 };
++<<<<<<< HEAD
++=======
+ 	bool bidi = test_type == TEST_TYPE_BIDI;
+ 	bool bpf = test_type == TEST_TYPE_BPF_RES;
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  
  	pthread_attr_init(&attr);
  	pthread_attr_setstacksize(&attr, THREAD_STACK);
@@@ -948,7 -941,7 +1107,11 @@@
  		free(pkt_buf);
  	}
  
++<<<<<<< HEAD
 +	if (!opt_teardown && !opt_bidi)
++=======
+ 	if (!(test_type == TEST_TYPE_TEARDOWN) && !bidi && !bpf && !(test_type == TEST_TYPE_STATS))
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  		print_ksft_result();
  }
  
@@@ -966,30 -960,178 +1129,198 @@@ static void testapp_sockets(void
  	print_ksft_result();
  }
  
 -static void swap_vectors(struct ifobject *ifobj1, struct ifobject *ifobj2)
 +static void init_iface_config(struct ifaceconfigobj *ifaceconfig)
  {
 -	void *(*tmp_func_ptr)(void *) = ifobj1->func_ptr;
 -	enum fvector tmp_vector = ifobj1->fv.vector;
 -
 +	/*Init interface0 */
 +	ifdict[0]->fv.vector = tx;
 +	memcpy(ifdict[0]->dst_mac, ifaceconfig->dst_mac, ETH_ALEN);
 +	memcpy(ifdict[0]->src_mac, ifaceconfig->src_mac, ETH_ALEN);
 +	ifdict[0]->dst_ip = ifaceconfig->dst_ip.s_addr;
 +	ifdict[0]->src_ip = ifaceconfig->src_ip.s_addr;
 +	ifdict[0]->dst_port = ifaceconfig->dst_port;
 +	ifdict[0]->src_port = ifaceconfig->src_port;
 +
++<<<<<<< HEAD
 +	/*Init interface1 */
 +	ifdict[1]->fv.vector = rx;
 +	memcpy(ifdict[1]->dst_mac, ifaceconfig->src_mac, ETH_ALEN);
 +	memcpy(ifdict[1]->src_mac, ifaceconfig->dst_mac, ETH_ALEN);
 +	ifdict[1]->dst_ip = ifaceconfig->src_ip.s_addr;
 +	ifdict[1]->src_ip = ifaceconfig->dst_ip.s_addr;
 +	ifdict[1]->dst_port = ifaceconfig->src_port;
 +	ifdict[1]->src_port = ifaceconfig->dst_port;
++=======
+ 	ifobj1->func_ptr = ifobj2->func_ptr;
+ 	ifobj1->fv.vector = ifobj2->fv.vector;
+ 
+ 	ifobj2->func_ptr = tmp_func_ptr;
+ 	ifobj2->fv.vector = tmp_vector;
+ 
+ 	ifdict_tx = ifobj1;
+ 	ifdict_rx = ifobj2;
+ }
+ 
+ static void testapp_bidi(void)
+ {
+ 	for (int i = 0; i < MAX_BIDI_ITER; i++) {
+ 		pkt_counter = 0;
+ 		prev_pkt = -1;
+ 		sigvar = 0;
+ 		print_verbose("Creating socket\n");
+ 		testapp_validate();
+ 		if (!second_step) {
+ 			print_verbose("Switching Tx/Rx vectors\n");
+ 			swap_vectors(ifdict[1], ifdict[0]);
+ 		}
+ 		second_step = true;
+ 	}
+ 
+ 	swap_vectors(ifdict[0], ifdict[1]);
+ 
+ 	print_ksft_result();
+ }
+ 
+ static void swap_xsk_res(void)
+ {
+ 	xsk_socket__delete(ifdict_tx->xsk->xsk);
+ 	xsk_umem__delete(ifdict_tx->umem->umem);
+ 	xsk_socket__delete(ifdict_rx->xsk->xsk);
+ 	xsk_umem__delete(ifdict_rx->umem->umem);
+ 	ifdict_tx->umem = ifdict_tx->umem_arr[1];
+ 	ifdict_tx->xsk = ifdict_tx->xsk_arr[1];
+ 	ifdict_rx->umem = ifdict_rx->umem_arr[1];
+ 	ifdict_rx->xsk = ifdict_rx->xsk_arr[1];
+ }
+ 
+ static void testapp_bpf_res(void)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < MAX_BPF_ITER; i++) {
+ 		pkt_counter = 0;
+ 		prev_pkt = -1;
+ 		sigvar = 0;
+ 		print_verbose("Creating socket\n");
+ 		testapp_validate();
+ 		if (!second_step)
+ 			swap_xsk_res();
+ 		second_step = true;
+ 	}
+ 
+ 	print_ksft_result();
+ }
+ 
+ static void testapp_stats(void)
+ {
+ 	for (int i = 0; i < STAT_TEST_TYPE_MAX; i++) {
+ 		stat_test_type = i;
+ 
+ 		/* reset defaults */
+ 		rxqsize = XSK_RING_CONS__DEFAULT_NUM_DESCS;
+ 		frame_headroom = XSK_UMEM__DEFAULT_FRAME_HEADROOM;
+ 
+ 		switch (stat_test_type) {
+ 		case STAT_TEST_RX_DROPPED:
+ 			frame_headroom = XSK_UMEM__DEFAULT_FRAME_SIZE -
+ 						XDP_PACKET_HEADROOM - 1;
+ 			break;
+ 		case STAT_TEST_RX_FULL:
+ 			rxqsize = RX_FULL_RXQSIZE;
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 		testapp_validate();
+ 	}
+ 
+ 	print_ksft_result();
+ }
+ 
+ static void init_iface(struct ifobject *ifobj, const char *dst_mac,
+ 		       const char *src_mac, const char *dst_ip,
+ 		       const char *src_ip, const u16 dst_port,
+ 		       const u16 src_port, enum fvector vector)
+ {
+ 	struct in_addr ip;
+ 
+ 	memcpy(ifobj->dst_mac, dst_mac, ETH_ALEN);
+ 	memcpy(ifobj->src_mac, src_mac, ETH_ALEN);
+ 
+ 	inet_aton(dst_ip, &ip);
+ 	ifobj->dst_ip = ip.s_addr;
+ 
+ 	inet_aton(src_ip, &ip);
+ 	ifobj->src_ip = ip.s_addr;
+ 
+ 	ifobj->dst_port = dst_port;
+ 	ifobj->src_port = src_port;
+ 
+ 	if (vector == tx) {
+ 		ifobj->fv.vector = tx;
+ 		ifobj->func_ptr = worker_testapp_validate_tx;
+ 		ifdict_tx = ifobj;
+ 	} else {
+ 		ifobj->fv.vector = rx;
+ 		ifobj->func_ptr = worker_testapp_validate_rx;
+ 		ifdict_rx = ifobj;
+ 	}
+ }
+ 
+ static void run_pkt_test(int mode, int type)
+ {
+ 	test_type = type;
+ 
+ 	/* reset defaults after potential previous test */
+ 	xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST;
+ 	pkt_counter = 0;
+ 	second_step = 0;
+ 	prev_pkt = -1;
+ 	sigvar = 0;
+ 	stat_test_type = -1;
+ 	rxqsize = XSK_RING_CONS__DEFAULT_NUM_DESCS;
+ 	frame_headroom = XSK_UMEM__DEFAULT_FRAME_HEADROOM;
+ 
+ 	configured_mode = mode;
+ 
+ 	switch (mode) {
+ 	case (TEST_MODE_SKB):
+ 		xdp_flags |= XDP_FLAGS_SKB_MODE;
+ 		break;
+ 	case (TEST_MODE_DRV):
+ 		xdp_flags |= XDP_FLAGS_DRV_MODE;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	switch (test_type) {
+ 	case TEST_TYPE_STATS:
+ 		testapp_stats();
+ 		break;
+ 	case TEST_TYPE_TEARDOWN:
+ 		testapp_teardown();
+ 		break;
+ 	case TEST_TYPE_BIDI:
+ 		testapp_bidi();
+ 		break;
+ 	case TEST_TYPE_BPF_RES:
+ 		testapp_bpf_res();
+ 		break;
+ 	default:
+ 		testapp_validate();
+ 		break;
+ 	}
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  }
  
  int main(int argc, char **argv)
  {
  	struct rlimit _rlim = { RLIM_INFINITY, RLIM_INFINITY };
++<<<<<<< HEAD
++=======
+ 	bool failure = false;
+ 	int i, j;
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  
  	if (setrlimit(RLIMIT_MEMLOCK, &_rlim))
  		exit_with_error(errno);
@@@ -1023,25 -1160,31 +1364,41 @@@
  
  	num_frames = ++opt_pkt_count;
  
 -	init_iface(ifdict[0], MAC1, MAC2, IP1, IP2, UDP_PORT1, UDP_PORT2, tx);
 -	init_iface(ifdict[1], MAC2, MAC1, IP2, IP1, UDP_PORT2, UDP_PORT1, rx);
 +	init_iface_config(ifaceconfig);
  
 -	ksft_set_plan(TEST_MODE_MAX * TEST_TYPE_MAX);
 +	pthread_init_mutex();
  
 -	init_sync_resources();
 +	ksft_set_plan(1);
  
 -	for (i = 0; i < TEST_MODE_MAX; i++) {
 -		for (j = 0; j < TEST_TYPE_MAX; j++)
 -			run_pkt_test(i, j);
 +	if (!opt_teardown && !opt_bidi) {
 +		testapp_validate();
 +	} else if (opt_teardown && opt_bidi) {
 +		ksft_test_result_fail("ERROR: parameters -T and -B cannot be used together\n");
 +		ksft_exit_xfail();
 +	} else {
 +		testapp_sockets();
  	}
  
++<<<<<<< HEAD
 +	for (int i = 0; i < MAX_INTERFACES; i++)
++=======
+ 	destroy_sync_resources();
+ 
+ cleanup:
+ 	for (int i = 0; i < MAX_INTERFACES; i++) {
+ 		if (ifdict[i]->ns_fd != -1)
+ 			close(ifdict[i]->ns_fd);
+ 		free(ifdict[i]->xsk_arr);
+ 		free(ifdict[i]->umem_arr);
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  		free(ifdict[i]);
 -	}
  
++<<<<<<< HEAD
 +	pthread_destroy_mutex();
++=======
+ 	if (failure)
+ 		exit_with_error(errno);
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  
  	ksft_exit_pass();
  
diff --cc tools/testing/selftests/bpf/xdpxceiver.h
index f66f399dfb2d,e431ecb9bb95..000000000000
--- a/tools/testing/selftests/bpf/xdpxceiver.h
+++ b/tools/testing/selftests/bpf/xdpxceiver.h
@@@ -48,29 -51,49 +49,56 @@@ typedef __u32 u32
  typedef __u16 u16;
  typedef __u8 u8;
  
 -enum TEST_MODES {
 -	TEST_MODE_UNCONFIGURED = -1,
 -	TEST_MODE_SKB,
 -	TEST_MODE_DRV,
 -	TEST_MODE_MAX
 +enum TESTS {
 +	ORDER_CONTENT_VALIDATE_XDP_SKB = 0,
 +	ORDER_CONTENT_VALIDATE_XDP_DRV = 1,
  };
  
++<<<<<<< HEAD
 +static u8 uut;
 +static u8 debug_pkt_dump;
 +static u32 num_frames;
 +static u8 switching_notify;
 +static u8 bidi_pass;
 +
 +static u32 opt_xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST;
 +static int opt_queue;
++=======
+ enum TEST_TYPES {
+ 	TEST_TYPE_NOPOLL,
+ 	TEST_TYPE_POLL,
+ 	TEST_TYPE_TEARDOWN,
+ 	TEST_TYPE_BIDI,
+ 	TEST_TYPE_STATS,
+ 	TEST_TYPE_BPF_RES,
+ 	TEST_TYPE_MAX
+ };
+ 
+ enum STAT_TEST_TYPES {
+ 	STAT_TEST_RX_DROPPED,
+ 	STAT_TEST_TX_INVALID,
+ 	STAT_TEST_RX_FULL,
+ 	STAT_TEST_RX_FILL_EMPTY,
+ 	STAT_TEST_TYPE_MAX
+ };
+ 
+ static int configured_mode = TEST_MODE_UNCONFIGURED;
+ static u8 debug_pkt_dump;
+ static u32 num_frames;
+ static bool second_step;
+ static int test_type;
+ 
++>>>>>>> 27e1ca2525de (selftests: xsk: Implement bpf_link test)
  static int opt_pkt_count;
 +static int opt_poll;
 +static int opt_teardown;
 +static int opt_bidi;
 +static u32 opt_xdp_bind_flags = XDP_USE_NEED_WAKEUP;
  static u8 opt_verbose;
 -
 -static u32 xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST;
 -static u32 xdp_bind_flags = XDP_USE_NEED_WAKEUP | XDP_COPY;
  static u8 pkt_data[XSK_UMEM__DEFAULT_FRAME_SIZE];
  static u32 pkt_counter;
 -static long prev_pkt = -1;
 +static u32 prev_pkt = -1;
  static int sigvar;
 -static int stat_test_type;
 -static u32 rxqsize;
 -static u32 frame_headroom;
  
  struct xsk_umem_info {
  	struct xsk_ring_prod fq;
@@@ -102,25 -125,17 +130,27 @@@ struct generic_data 
  	u32 seqnum;
  };
  
 +struct ifaceconfigobj {
 +	u8 dst_mac[ETH_ALEN];
 +	u8 src_mac[ETH_ALEN];
 +	struct in_addr dst_ip;
 +	struct in_addr src_ip;
 +	u16 src_port;
 +	u16 dst_port;
 +} *ifaceconfig;
 +
  struct ifobject {
 +	int ifindex;
 +	int ifdict_index;
  	char ifname[MAX_INTERFACE_NAME_CHARS];
  	char nsname[MAX_INTERFACES_NAMESPACE_CHARS];
 +	struct flow_vector fv;
  	struct xsk_socket_info *xsk;
+ 	struct xsk_socket_info **xsk_arr;
+ 	struct xsk_umem_info **umem_arr;
  	struct xsk_umem_info *umem;
 -	void *(*func_ptr)(void *arg);
 -	struct flow_vector fv;
 -	int ns_fd;
 -	int ifdict_index;
 +	u8 dst_mac[ETH_ALEN];
 +	u8 src_mac[ETH_ALEN];
  	u32 dst_ip;
  	u32 src_ip;
  	u16 src_port;
diff --git a/tools/testing/selftests/bpf/test_xsk.sh b/tools/testing/selftests/bpf/test_xsk.sh
index dbb129a36606..a098904403c8 100755
--- a/tools/testing/selftests/bpf/test_xsk.sh
+++ b/tools/testing/selftests/bpf/test_xsk.sh
@@ -107,7 +107,7 @@ setup_vethPairs() {
 	        echo "setting up ${VETH0}: namespace: ${NS0}"
 	fi
 	ip netns add ${NS1}
-	ip link add ${VETH0} type veth peer name ${VETH1}
+	ip link add ${VETH0} numtxqueues 4 numrxqueues 4 type veth peer name ${VETH1} numtxqueues 4 numrxqueues 4
 	if [ -f /proc/net/if_inet6 ]; then
 		echo 1 > /proc/sys/net/ipv6/conf/${VETH0}/disable_ipv6
 	fi
@@ -118,6 +118,7 @@ setup_vethPairs() {
 	ip netns exec ${NS1} ip link set ${VETH1} mtu ${MTU}
 	ip link set ${VETH0} mtu ${MTU}
 	ip netns exec ${NS1} ip link set ${VETH1} up
+	ip netns exec ${NS1} ip link set dev lo up
 	ip link set ${VETH0} up
 }
 
* Unmerged path tools/testing/selftests/bpf/xdpxceiver.c
* Unmerged path tools/testing/selftests/bpf/xdpxceiver.h
