KVM: SVM: remove svm_toggle_avic_for_irq_window

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Maxim Levitsky <mlevitsk@redhat.com>
commit 30eed56a7e1cbefe933a33d661827e5c72cd136f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/30eed56a.failed

Now that kvm_request_apicv_update doesn't need to drop the kvm->srcu lock,
we can call kvm_request_apicv_update directly.

	Signed-off-by: Maxim Levitsky <mlevitsk@redhat.com>
	Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
Message-Id: <20210810205251.424103-13-mlevitsk@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 30eed56a7e1cbefe933a33d661827e5c72cd136f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/avic.c
diff --cc arch/x86/kvm/svm/avic.c
index 13dc8ffbc01a,1def54c26259..000000000000
--- a/arch/x86/kvm/svm/avic.c
+++ b/arch/x86/kvm/svm/avic.c
@@@ -586,17 -582,6 +586,20 @@@ void avic_post_state_restore(struct kvm
  	avic_handle_ldr_update(vcpu);
  }
  
++<<<<<<< HEAD
 +void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate)
 +{
 +	if (!avic || !lapic_in_kernel(vcpu))
 +		return;
 +
 +	srcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);
 +	kvm_request_apicv_update(vcpu->kvm, activate,
 +				 APICV_INHIBIT_REASON_IRQWIN);
 +	vcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);
 +}
 +
++=======
++>>>>>>> 30eed56a7e1c (KVM: SVM: remove svm_toggle_avic_for_irq_window)
  void svm_set_virtual_apic_mode(struct kvm_vcpu *vcpu)
  {
  	return;
* Unmerged path arch/x86/kvm/svm/avic.c
diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.c
index 4f061289c253..a6e35b4f3384 100644
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@ -2988,7 +2988,7 @@ static int interrupt_window_interception(struct kvm_vcpu *vcpu)
 	 * In this case AVIC was temporarily disabled for
 	 * requesting the IRQ window and we have to re-enable it.
 	 */
-	svm_toggle_avic_for_irq_window(vcpu, true);
+	kvm_request_apicv_update(vcpu->kvm, true, APICV_INHIBIT_REASON_IRQWIN);
 
 	++vcpu->stat.irq_window_exits;
 	return 1;
@@ -3540,7 +3540,7 @@ static void svm_enable_irq_window(struct kvm_vcpu *vcpu)
 		 * via AVIC. In such case, we need to temporarily disable AVIC,
 		 * and fallback to injecting IRQ via V_IRQ.
 		 */
-		svm_toggle_avic_for_irq_window(vcpu, false);
+		kvm_request_apicv_update(vcpu->kvm, false, APICV_INHIBIT_REASON_IRQWIN);
 		svm_set_vintr(svm);
 	}
 }
diff --git a/arch/x86/kvm/svm/svm.h b/arch/x86/kvm/svm/svm.h
index 5e838a56ab11..0c97fe1cff33 100644
--- a/arch/x86/kvm/svm/svm.h
+++ b/arch/x86/kvm/svm/svm.h
@@ -526,7 +526,6 @@ int avic_ga_log_notifier(u32 ga_tag);
 void avic_vm_destroy(struct kvm *kvm);
 int avic_vm_init(struct kvm *kvm);
 void avic_init_vmcb(struct vcpu_svm *svm);
-void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);
 int avic_incomplete_ipi_interception(struct kvm_vcpu *vcpu);
 int avic_unaccelerated_access_interception(struct kvm_vcpu *vcpu);
 int avic_init_vcpu(struct vcpu_svm *svm);
