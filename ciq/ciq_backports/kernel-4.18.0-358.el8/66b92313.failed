i2c: designware: call i2c_dw_read_clear_intrbits_slave() once

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Michael Wu <michael.wu@vatics.com>
commit 66b92313e2ca9208b5f3ebf5d86e9a818299d8fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/66b92313.failed

If some bits were cleared by i2c_dw_read_clear_intrbits_slave() in
i2c_dw_isr_slave() and not handled immediately, those cleared bits would
not be shown again by later i2c_dw_read_clear_intrbits_slave(). They
therefore were forgotten to be handled.

i2c_dw_read_clear_intrbits_slave() should be called once in an ISR and take
its returned state for all later handlings.

	Signed-off-by: Michael Wu <michael.wu@vatics.com>
	Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
	Signed-off-by: Wolfram Sang <wsa@kernel.org>
(cherry picked from commit 66b92313e2ca9208b5f3ebf5d86e9a818299d8fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/busses/i2c-designware-slave.c
diff --cc drivers/i2c/busses/i2c-designware-slave.c
index f5ecf76c0d02,13de01a0f75f..000000000000
--- a/drivers/i2c/busses/i2c-designware-slave.c
+++ b/drivers/i2c/busses/i2c-designware-slave.c
@@@ -155,14 -156,13 +155,21 @@@ static u32 i2c_dw_read_clear_intrbits_s
  
  static int i2c_dw_irq_handler_slave(struct dw_i2c_dev *dev)
  {
 -	u32 raw_stat, stat, enabled, tmp;
 -	u8 val = 0, slave_activity;
 -
 +	u32 raw_stat, stat, enabled;
 +	u8 val, slave_activity;
 +
++<<<<<<< HEAD
 +	stat = dw_readl(dev, DW_IC_INTR_STAT);
 +	enabled = dw_readl(dev, DW_IC_ENABLE);
 +	raw_stat = dw_readl(dev, DW_IC_RAW_INTR_STAT);
 +	slave_activity = ((dw_readl(dev, DW_IC_STATUS) &
 +		DW_IC_STATUS_SLAVE_ACTIVITY) >> 6);
++=======
+ 	regmap_read(dev->map, DW_IC_ENABLE, &enabled);
+ 	regmap_read(dev->map, DW_IC_RAW_INTR_STAT, &raw_stat);
+ 	regmap_read(dev->map, DW_IC_STATUS, &tmp);
+ 	slave_activity = ((tmp & DW_IC_STATUS_SLAVE_ACTIVITY) >> 6);
++>>>>>>> 66b92313e2ca (i2c: designware: call i2c_dw_read_clear_intrbits_slave() once)
  
  	if (!enabled || !(raw_stat & ~DW_IC_INTR_ACTIVITY) || !dev->slave)
  		return 0;
@@@ -185,12 -187,10 +193,19 @@@
  					dev_vdbg(dev->dev, "Byte %X acked!",
  						 val);
  				}
++<<<<<<< HEAD
 +				dw_readl(dev, DW_IC_CLR_RD_REQ);
 +				stat = i2c_dw_read_clear_intrbits_slave(dev);
 +			} else {
 +				dw_readl(dev, DW_IC_CLR_RD_REQ);
 +				dw_readl(dev, DW_IC_CLR_RX_UNDER);
 +				stat = i2c_dw_read_clear_intrbits_slave(dev);
++=======
+ 				regmap_read(dev->map, DW_IC_CLR_RD_REQ, &tmp);
+ 			} else {
+ 				regmap_read(dev->map, DW_IC_CLR_RD_REQ, &tmp);
+ 				regmap_read(dev->map, DW_IC_CLR_RX_UNDER, &tmp);
++>>>>>>> 66b92313e2ca (i2c: designware: call i2c_dw_read_clear_intrbits_slave() once)
  			}
  			if (!i2c_slave_event(dev->slave,
  					     I2C_SLAVE_READ_REQUESTED,
@@@ -202,10 -202,9 +217,9 @@@
  	if (stat & DW_IC_INTR_RX_DONE) {
  		if (!i2c_slave_event(dev->slave, I2C_SLAVE_READ_PROCESSED,
  				     &val))
 -			regmap_read(dev->map, DW_IC_CLR_RX_DONE, &tmp);
 +			dw_readl(dev, DW_IC_CLR_RX_DONE);
  
  		i2c_slave_event(dev->slave, I2C_SLAVE_STOP, &val);
- 		stat = i2c_dw_read_clear_intrbits_slave(dev);
  		return 1;
  	}
  
* Unmerged path drivers/i2c/busses/i2c-designware-slave.c
