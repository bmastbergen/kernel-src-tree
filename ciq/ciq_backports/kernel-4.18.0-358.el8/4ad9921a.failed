printk: finalize records with trailing newlines

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author John Ogness <john.ogness@linutronix.de>
commit 4ad9921af4f18490980369f7d60f90ade0195812
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/4ad9921a.failed

Any record with a trailing newline (LOG_NEWLINE flag) cannot
be continued because the newline has been stripped and will
not be visible if the message is appended. This was already
handled correctly when committing in log_output() but was
not handled correctly when committing in log_store().

Fixes: f5f022e53b87 ("printk: reimplement log_cont using record extension")
Link: https://lore.kernel.org/r/20201126114836.14750-1-john.ogness@linutronix.de
	Reported-by: Kefeng Wang <wangkefeng.wang@huawei.com>
	Signed-off-by: John Ogness <john.ogness@linutronix.de>
	Tested-by: Kefeng Wang <wangkefeng.wang@huawei.com>
	Reviewed-by: Petr Mladek <pmladek@suse.com>
	Signed-off-by: Petr Mladek <pmladek@suse.com>
(cherry picked from commit 4ad9921af4f18490980369f7d60f90ade0195812)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/printk/printk.c
diff --cc kernel/printk/printk.c
index c1fedccb5ed4,bc1e3b5a97bd..000000000000
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@@ -634,44 -512,29 +634,52 @@@ static int log_store(u32 caller_id, in
  			return 0;
  	}
  
 +	if (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {
 +		/*
 +		 * This message + an additional empty header does not fit
 +		 * at the end of the buffer. Add an empty header with len == 0
 +		 * to signify a wrap around.
 +		 */
 +		memset(log_buf + log_next_idx, 0, sizeof(struct printk_log));
 +		log_next_idx = 0;
 +	}
 +
  	/* fill message */
 -	memcpy(&r.text_buf[0], text, text_len);
 -	if (trunc_msg_len)
 -		memcpy(&r.text_buf[text_len], trunc_msg, trunc_msg_len);
 -	r.info->text_len = text_len + trunc_msg_len;
 -	r.info->facility = facility;
 -	r.info->level = level & 7;
 -	r.info->flags = flags & 0x1f;
 +	msg = (struct printk_log *)(log_buf + log_next_idx);
 +	memcpy(log_text(msg), text, text_len);
 +	msg->text_len = text_len;
 +	if (trunc_msg_len) {
 +		memcpy(log_text(msg) + text_len, trunc_msg, trunc_msg_len);
 +		msg->text_len += trunc_msg_len;
 +	}
 +	memcpy(log_dict(msg), dict, dict_len);
 +	msg->dict_len = dict_len;
 +	msg->facility = facility;
 +	msg->level = level & 7;
 +	msg->flags = flags & 0x1f;
  	if (ts_nsec > 0)
 -		r.info->ts_nsec = ts_nsec;
 +		msg->ts_nsec = ts_nsec;
  	else
 -		r.info->ts_nsec = local_clock();
 -	r.info->caller_id = caller_id;
 -	if (dev_info)
 -		memcpy(&r.info->dev_info, dev_info, sizeof(r.info->dev_info));
 -
 +		msg->ts_nsec = local_clock();
 +#ifdef CONFIG_PRINTK_CALLER
 +	msg->caller_id = caller_id;
 +#endif
 +	memset(log_dict(msg) + dict_len, 0, pad_len);
 +	msg->len = size;
 +
++<<<<<<< HEAD
 +	/* insert message */
 +	log_next_idx += msg->len;
 +	log_next_seq++;
++=======
+ 	/* A message without a trailing newline can be continued. */
+ 	if (!(flags & LOG_NEWLINE))
+ 		prb_commit(&e);
+ 	else
+ 		prb_final_commit(&e);
++>>>>>>> 4ad9921af4f1 (printk: finalize records with trailing newlines)
  
 -	return (text_len + trunc_msg_len);
 +	return msg->text_len;
  }
  
  int dmesg_restrict = IS_ENABLED(CONFIG_SECURITY_DMESG_RESTRICT);
* Unmerged path kernel/printk/printk.c
