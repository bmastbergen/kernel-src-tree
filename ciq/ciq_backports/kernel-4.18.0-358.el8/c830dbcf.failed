ACPI: scan: Call acpi_get_object_info() from acpi_set_pnp_ids()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit c830dbcfccbf70be94f15dbb4781be5ffb210d98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/c830dbcf.failed

Notice that it is not necessary to call acpi_get_object_info() from
acpi_add_single_object() in order to pass the pointer returned by it
to acpi_init_device_object() and from there to acpi_set_pnp_ids().

It is more straightforward to call acpi_get_object_info() from
acpi_set_pnp_ids() and avoid unnecessary pointer passing, so change
the code accordingly.

No intentional functional impact.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Hans de Goede <hdegoede@redhat.com>
(cherry picked from commit c830dbcfccbf70be94f15dbb4781be5ffb210d98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/internal.h
#	drivers/acpi/power.c
#	drivers/acpi/scan.c
diff --cc drivers/acpi/internal.h
index 4ab8878c4f8c,b852cff80287..000000000000
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@@ -114,8 -109,7 +114,12 @@@ struct acpi_device_bus_id 
  int acpi_device_add(struct acpi_device *device,
  		    void (*release)(struct device *));
  void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
++<<<<<<< HEAD
 +			     int type, unsigned long long sta,
 +			     struct acpi_device_info *info);
++=======
+ 			     int type);
++>>>>>>> c830dbcfccbf (ACPI: scan: Call acpi_get_object_info() from acpi_set_pnp_ids())
  int acpi_device_setup_files(struct acpi_device *dev);
  void acpi_device_remove_files(struct acpi_device *dev);
  void acpi_device_add_finalize(struct acpi_device *device);
diff --cc drivers/acpi/power.c
index 44808cce19a2,b68a6e33ac34..000000000000
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@@ -952,8 -925,7 +952,12 @@@ int acpi_add_power_resource(acpi_handl
  		return -ENOMEM;
  
  	device = &resource->device;
++<<<<<<< HEAD
 +	acpi_init_device_object(device, handle, ACPI_BUS_TYPE_POWER,
 +				ACPI_STA_DEFAULT, NULL);
++=======
+ 	acpi_init_device_object(device, handle, ACPI_BUS_TYPE_POWER);
++>>>>>>> c830dbcfccbf (ACPI: scan: Call acpi_get_object_info() from acpi_set_pnp_ids())
  	mutex_init(&resource->resource_lock);
  	INIT_LIST_HEAD(&resource->list_node);
  	INIT_LIST_HEAD(&resource->dependents);
diff --cc drivers/acpi/scan.c
index fc29b67fcda9,053777845475..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -1659,17 -1653,16 +1663,21 @@@ static bool acpi_device_enumeration_by_
  }
  
  void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
++<<<<<<< HEAD
 +			     int type, unsigned long long sta,
 +			     struct acpi_device_info *info)
++=======
+ 			     int type)
++>>>>>>> c830dbcfccbf (ACPI: scan: Call acpi_get_object_info() from acpi_set_pnp_ids())
  {
  	INIT_LIST_HEAD(&device->pnp.ids);
  	device->device_type = type;
  	device->handle = handle;
  	device->parent = acpi_bus_get_parent(handle);
  	fwnode_init(&device->fwnode, &acpi_device_fwnode_ops);
 -	acpi_set_device_status(device, ACPI_STA_DEFAULT);
 +	acpi_set_device_status(device, sta);
  	acpi_device_get_busid(device);
- 	acpi_set_pnp_ids(handle, &device->pnp, type, info);
+ 	acpi_set_pnp_ids(handle, &device->pnp, type);
  	acpi_init_properties(device);
  	acpi_bus_get_flags(device);
  	device->flags.match_driver = false;
@@@ -1690,35 -1683,30 +1698,47 @@@ void acpi_device_add_finalize(struct ac
  	kobject_uevent(&device->dev.kobj, KOBJ_ADD);
  }
  
 -static void acpi_scan_init_status(struct acpi_device *adev)
 -{
 -	if (acpi_bus_get_status(adev))
 -		acpi_set_device_status(adev, 0);
 -}
 -
  static int acpi_add_single_object(struct acpi_device **child,
 -				  acpi_handle handle, int type)
 +				  acpi_handle handle, int type,
 +				  unsigned long long sta)
  {
++<<<<<<< HEAD
++=======
+ 	struct acpi_device *device;
++>>>>>>> c830dbcfccbf (ACPI: scan: Call acpi_get_object_info() from acpi_set_pnp_ids())
  	int result;
 +	struct acpi_device *device;
 +	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 +	struct acpi_device_info *info = NULL;
 +
++<<<<<<< HEAD
 +	if (handle != ACPI_ROOT_OBJECT && type == ACPI_BUS_TYPE_DEVICE)
 +		acpi_get_object_info(handle, &info);
  
 +	device = kzalloc(sizeof(struct acpi_device), GFP_KERNEL);
 +	if (!device) {
 +		printk(KERN_ERR PREFIX "Memory allocation error\n");
 +		kfree(info);
++=======
+ 	device = kzalloc(sizeof(struct acpi_device), GFP_KERNEL);
+ 	if (!device)
++>>>>>>> c830dbcfccbf (ACPI: scan: Call acpi_get_object_info() from acpi_set_pnp_ids())
  		return -ENOMEM;
- 	}
  
++<<<<<<< HEAD
 +	acpi_init_device_object(device, handle, type, sta, info);
 +	kfree(info);
++=======
+ 	acpi_init_device_object(device, handle, type);
++>>>>>>> c830dbcfccbf (ACPI: scan: Call acpi_get_object_info() from acpi_set_pnp_ids())
  	/*
 -	 * Getting the status is delayed till here so that we can call
 -	 * acpi_bus_get_status() and use its quirk handling.  Note that
 -	 * this must be done before the get power-/wakeup_dev-flags calls.
 +	 * For ACPI_BUS_TYPE_DEVICE getting the status is delayed till here so
 +	 * that we can call acpi_bus_get_status() and use its quirk handling.
 +	 * Note this must be done before the get power-/wakeup_dev-flags calls.
  	 */
 -	if (type == ACPI_BUS_TYPE_DEVICE || type == ACPI_BUS_TYPE_PROCESSOR)
 -		acpi_scan_init_status(device);
 +	if (type == ACPI_BUS_TYPE_DEVICE)
 +		if (acpi_bus_get_status(device) < 0)
 +			acpi_set_device_status(device, 0);
  
  	acpi_bus_get_power_flags(device);
  	acpi_bus_get_wakeup_device_flags(device);
* Unmerged path drivers/acpi/internal.h
* Unmerged path drivers/acpi/power.c
* Unmerged path drivers/acpi/scan.c
