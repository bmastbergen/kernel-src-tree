PCI/VPD: Determine VPD size in pci_vpd_init()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit 7bac54497c3e3b2ca37b7043f1fa78586540f10e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/7bac5449.failed

Determine VPD size in pci_vpd_init().

Quirks set dev->vpd.len to a non-zero value, so they cause us to skip the
dynamic size calculation.  Prerequisite is that we move the quirks from
FINAL to HEADER so they are run before pci_vpd_init().

Link: https://lore.kernel.org/r/cc4a6538-557a-294d-4f94-e6d1d3c91589@gmail.com
	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 7bac54497c3e3b2ca37b7043f1fa78586540f10e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/vpd.c
diff --cc drivers/pci/vpd.c
index 9d9cff5f89e2,a62251a3c7a1..000000000000
--- a/drivers/pci/vpd.c
+++ b/drivers/pci/vpd.c
@@@ -238,25 -226,11 +232,33 @@@ static ssize_t pci_vpd_write(struct pci
  
  void pci_vpd_init(struct pci_dev *dev)
  {
++<<<<<<< HEAD
 +	struct pci_vpd *vpd;
 +	u8 cap;
 +
 +	cap = pci_find_capability(dev, PCI_CAP_ID_VPD);
 +	if (!cap)
 +		return;
 +
 +	vpd = kzalloc(sizeof(*vpd), GFP_ATOMIC);
 +	if (!vpd)
 +		return;
 +
 +	mutex_init(&vpd->lock);
 +	vpd->cap = cap;
 +	dev->vpd = vpd;
 +}
 +
 +void pci_vpd_release(struct pci_dev *dev)
 +{
 +	kfree(dev->vpd);
++=======
+ 	dev->vpd.cap = pci_find_capability(dev, PCI_CAP_ID_VPD);
+ 	mutex_init(&dev->vpd.lock);
+ 
+ 	if (!dev->vpd.len)
+ 		dev->vpd.len = pci_vpd_size(dev);
++>>>>>>> 7bac54497c3e (PCI/VPD: Determine VPD size in pci_vpd_init())
  }
  
  static ssize_t vpd_read(struct file *filp, struct kobject *kobj,
@@@ -418,41 -392,28 +420,40 @@@ DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDO
   */
  static void quirk_blacklist_vpd(struct pci_dev *dev)
  {
 -	dev->vpd.len = PCI_VPD_SZ_INVALID;
 -	pci_warn(dev, FW_BUG "disabling VPD access (can't determine size of non-standard VPD format)\n");
 +	if (dev->vpd) {
 +		dev->vpd->len = PCI_VPD_SZ_INVALID;
 +		pci_warn(dev, FW_BUG "disabling VPD access (can't determine size of non-standard VPD format)\n");
 +	}
  }
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LSI_LOGIC, 0x0060, quirk_blacklist_vpd);
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LSI_LOGIC, 0x007c, quirk_blacklist_vpd);
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LSI_LOGIC, 0x0413, quirk_blacklist_vpd);
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LSI_LOGIC, 0x0078, quirk_blacklist_vpd);
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LSI_LOGIC, 0x0079, quirk_blacklist_vpd);
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LSI_LOGIC, 0x0073, quirk_blacklist_vpd);
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LSI_LOGIC, 0x0071, quirk_blacklist_vpd);
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LSI_LOGIC, 0x005b, quirk_blacklist_vpd);
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LSI_LOGIC, 0x002f, quirk_blacklist_vpd);
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LSI_LOGIC, 0x005d, quirk_blacklist_vpd);
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LSI_LOGIC, 0x005f, quirk_blacklist_vpd);
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATTANSIC, PCI_ANY_ID,
- 		quirk_blacklist_vpd);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x0060, quirk_blacklist_vpd);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x007c, quirk_blacklist_vpd);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x0413, quirk_blacklist_vpd);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x0078, quirk_blacklist_vpd);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x0079, quirk_blacklist_vpd);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x0073, quirk_blacklist_vpd);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x0071, quirk_blacklist_vpd);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x005b, quirk_blacklist_vpd);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x002f, quirk_blacklist_vpd);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x005d, quirk_blacklist_vpd);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x005f, quirk_blacklist_vpd);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATTANSIC, PCI_ANY_ID, quirk_blacklist_vpd);
  /*
   * The Amazon Annapurna Labs 0x0031 device id is reused for other non Root Port
   * device types, so the quirk is registered for the PCI_CLASS_BRIDGE_PCI class.
   */
- DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_AMAZON_ANNAPURNA_LABS, 0x0031,
- 			      PCI_CLASS_BRIDGE_PCI, 8, quirk_blacklist_vpd);
+ DECLARE_PCI_FIXUP_CLASS_HEADER(PCI_VENDOR_ID_AMAZON_ANNAPURNA_LABS, 0x0031,
+ 			       PCI_CLASS_BRIDGE_PCI, 8, quirk_blacklist_vpd);
  
 +static void pci_vpd_set_size(struct pci_dev *dev, size_t len)
 +{
 +	struct pci_vpd *vpd = dev->vpd;
 +
 +	if (!vpd || len == 0 || len > PCI_VPD_MAX_SIZE)
 +		return;
 +
 +	vpd->len = len;
 +}
 +
  static void quirk_chelsio_extend_vpd(struct pci_dev *dev)
  {
  	int chip = (dev->device & 0xf000) >> 12;
@@@ -471,12 -432,12 +472,12 @@@
  	 * limits.
  	 */
  	if (chip == 0x0 && prod >= 0x20)
 -		dev->vpd.len = 8192;
 +		pci_vpd_set_size(dev, 8192);
  	else if (chip >= 0x4 && func < 0x8)
 -		dev->vpd.len = 2048;
 +		pci_vpd_set_size(dev, 2048);
  }
  
- DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, PCI_ANY_ID,
- 			quirk_chelsio_extend_vpd);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_CHELSIO, PCI_ANY_ID,
+ 			 quirk_chelsio_extend_vpd);
  
  #endif
* Unmerged path drivers/pci/vpd.c
