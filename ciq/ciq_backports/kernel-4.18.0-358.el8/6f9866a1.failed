x86/fpu/signal: Let xrstor handle the features to init

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 6f9866a166cd1ad3ebb2dcdb3874aa8fee8dea2f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/6f9866a1.failed

There is no reason to do an extra XRSTOR from init_fpstate for feature
bits which have been cleared by user space in the FX magic xfeatures
storage.

Just clear them in the task's XSTATE header and do a full restore which
will put these cleared features into init state.

There is no real difference in performance because the current code
already does a full restore when the xfeatures bits are preserved as the
signal frame setup has stored them, which is the full UABI feature set.

 [ bp: Use the negated mxcsr_feature_mask in the MXCSR check. ]

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20210623121457.804115017@linutronix.de
(cherry picked from commit 6f9866a166cd1ad3ebb2dcdb3874aa8fee8dea2f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/signal.c
diff --cc arch/x86/kernel/fpu/signal.c
index 7e120ce9728a,445c57c9c539..000000000000
--- a/arch/x86/kernel/fpu/signal.c
+++ b/arch/x86/kernel/fpu/signal.c
@@@ -219,33 -220,25 +219,55 @@@ retry
  	return 0;
  }
  
++<<<<<<< HEAD
 +static inline void
 +sanitize_restored_user_xstate(union fpregs_state *state,
 +			      struct user_i387_ia32_struct *ia32_env, u64 mask)
 +{
 +	struct xregs_state *xsave = &state->xsave;
 +	struct xstate_header *header = &xsave->header;
 +
 +	if (use_xsave()) {
 +		/*
 +		 * Clear all feature bits which are not set in mask.
 +		 *
 +		 * Supervisor state has to be preserved. The sigframe
 +		 * restore can only modify user features, i.e. @mask
 +		 * cannot contain them.
 +		 */
 +		header->xfeatures &= mask | xfeatures_mask_supervisor();
 +	}
 +
 +	if (use_fxsr()) {
 +		/*
 +		 * mscsr reserved bits must be masked to zero for security
 +		 * reasons.
 +		 */
 +		xsave->i387.mxcsr &= mxcsr_feature_mask;
 +
 +		if (ia32_env)
 +			convert_to_fxsr(&state->fxsave, ia32_env);
++=======
+ static int __restore_fpregs_from_user(void __user *buf, u64 xrestore,
+ 				      bool fx_only)
+ {
+ 	if (use_xsave()) {
+ 		u64 init_bv = xfeatures_mask_uabi() & ~xrestore;
+ 		int ret;
+ 
+ 		if (likely(!fx_only))
+ 			ret = xrstor_from_user_sigframe(buf, xrestore);
+ 		else
+ 			ret = fxrstor_from_user_sigframe(buf);
+ 
+ 		if (!ret && unlikely(init_bv))
+ 			os_xrstor(&init_fpstate.xsave, init_bv);
+ 		return ret;
+ 	} else if (use_fxsr()) {
+ 		return fxrstor_from_user_sigframe(buf);
+ 	} else {
+ 		return frstor_from_user_sigframe(buf);
++>>>>>>> 6f9866a166cd (x86/fpu/signal: Let xrstor handle the features to init)
  	}
  }
  
@@@ -301,72 -322,29 +323,74 @@@ static int __fpu_restore_sig(void __use
  		fx_only = !fx_sw_user.magic1;
  		state_size = fx_sw_user.xstate_size;
  		user_xfeatures = fx_sw_user.xfeatures;
+ 	} else {
+ 		user_xfeatures = XFEATURE_MASK_FPSSE;
  	}
  
 -	if (likely(!ia32_fxstate)) {
 +	if (!ia32_fxstate) {
  		/*
  		 * Attempt to restore the FPU registers directly from user
 -		 * memory. For that to succeed, the user access cannot cause page
 -		 * faults. If it does, fall back to the slow path below, going
 -		 * through the kernel buffer with the enabled pagefault handler.
 +		 * memory. For that to succeed, the user access cannot cause
 +		 * page faults. If it does, fall back to the slow path below,
 +		 * going through the kernel buffer with the enabled pagefault
 +		 * handler.
  		 */
 -		return restore_fpregs_from_user(buf_fx, user_xfeatures, fx_only,
 -						state_size);
 -	}
 +		fpregs_lock();
 +		pagefault_disable();
 +		ret = copy_user_to_fpregs_zeroing(buf_fx, user_xfeatures, fx_only);
 +		pagefault_enable();
 +		if (!ret) {
 +
 +			/*
 +			 * Restore supervisor states: previous context switch
 +			 * etc has done XSAVES and saved the supervisor states
 +			 * in the kernel buffer from which they can be restored
 +			 * now.
 +			 *
 +			 * We cannot do a single XRSTORS here - which would
 +			 * be nice - because the rest of the FPU registers are
 +			 * being restored from a user buffer directly. The
 +			 * single XRSTORS happens below, when the user buffer
 +			 * has been copied to the kernel one.
 +			 */
 +			if (test_thread_flag(TIF_NEED_FPU_LOAD) &&
 +			    xfeatures_mask_supervisor())
 +				copy_kernel_to_xregs(&fpu->state.xsave,
 +						     xfeatures_mask_supervisor());
 +			fpregs_mark_activate();
 +			fpregs_unlock();
 +			return 0;
 +		}
  
 -	/*
 -	 * Copy the legacy state because the FP portion of the FX frame has
 -	 * to be ignored for histerical raisins. The legacy state is folded
 -	 * in once the larger state has been copied.
 -	 */
 -	ret = __copy_from_user(&env, buf, sizeof(env));
 -	if (ret)
 -		return ret;
 +		/*
 +		 * The above did an FPU restore operation, restricted to
 +		 * the user portion of the registers, and failed, but the
 +		 * microcode might have modified the FPU registers
 +		 * nevertheless.
 +		 *
 +		 * If the FPU registers do not belong to current, then
 +		 * invalidate the FPU register state otherwise the task might
 +		 * preempt current and return to user space with corrupted
 +		 * FPU registers.
 +		 *
 +		 * In case current owns the FPU registers then no further
 +		 * action is required. The fixup below will handle it
 +		 * correctly.
 +		 */
 +		if (test_thread_flag(TIF_NEED_FPU_LOAD))
 +			__cpu_invalidate_fpregs_state();
 +
 +		fpregs_unlock();
 +	} else {
 +		/*
 +		 * For 32-bit frames with fxstate, copy the fxstate so it can
 +		 * be reconstructed later.
 +		 */
 +		ret = __copy_from_user(&env, buf, sizeof(env));
 +		if (ret)
 +			return ret;
 +		envp = &env;
 +	}
  
  	/*
  	 * By setting TIF_NEED_FPU_LOAD it is ensured that our xstate is
@@@ -393,51 -371,48 +418,94 @@@
  	fpregs_unlock();
  
  	if (use_xsave() && !fx_only) {
++<<<<<<< HEAD
 +		u64 init_bv = xfeatures_mask_user() & ~user_xfeatures;
 +
 +		ret = copy_user_to_xstate(&fpu->state.xsave, buf_fx);
 +		if (ret)
 +			return ret;
 +
 +		sanitize_restored_user_xstate(&fpu->state, envp, user_xfeatures);
 +
 +		fpregs_lock();
 +		if (unlikely(init_bv))
 +			copy_kernel_to_xregs(&init_fpstate.xsave, init_bv);
 +
 +		/*
 +		 * Restore previously saved supervisor xstates along with
 +		 * copied-in user xstates.
 +		 */
 +		ret = copy_kernel_to_xregs_err(&fpu->state.xsave,
 +					       user_xfeatures | xfeatures_mask_supervisor());
 +
 +	} else if (use_fxsr()) {
 +		ret = __copy_from_user(&fpu->state.fxsave, buf_fx, state_size);
 +		if (ret)
 +			return -EFAULT;
 +
 +		sanitize_restored_user_xstate(&fpu->state, envp, user_xfeatures);
++=======
+ 		ret = copy_sigframe_from_user_to_xstate(&fpu->state.xsave, buf_fx);
+ 		if (ret)
+ 			return ret;
+ 	} else {
+ 		if (__copy_from_user(&fpu->state.fxsave, buf_fx,
+ 				     sizeof(fpu->state.fxsave)))
+ 			return -EFAULT;
  
- 		fpregs_lock();
- 		if (use_xsave()) {
- 			u64 init_bv;
+ 		/* Reject invalid MXCSR values. */
+ 		if (fpu->state.fxsave.mxcsr & ~mxcsr_feature_mask)
+ 			return -EINVAL;
++>>>>>>> 6f9866a166cd (x86/fpu/signal: Let xrstor handle the features to init)
+ 
+ 		/* Enforce XFEATURE_MASK_FPSSE when XSAVE is enabled */
+ 		if (use_xsave())
+ 			fpu->state.xsave.header.xfeatures |= XFEATURE_MASK_FPSSE;
+ 	}
  
++<<<<<<< HEAD
 +			init_bv = xfeatures_mask_user() & ~XFEATURE_MASK_FPSSE;
 +			copy_kernel_to_xregs(&init_fpstate.xsave, init_bv);
 +		}
 +
 +		ret = copy_kernel_to_fxregs_err(&fpu->state.fxsave);
 +	} else {
 +		ret = __copy_from_user(&fpu->state.fsave, buf_fx, state_size);
 +		if (ret)
 +			return ret;
 +
 +		fpregs_lock();
 +		ret = frstor_safe(&fpu->state.fsave);
 +	}
 +	if (!ret)
 +		fpregs_mark_activate();
++=======
+ 	/* Fold the legacy FP storage */
+ 	convert_to_fxsr(&fpu->state.fxsave, &env);
+ 
+ 	fpregs_lock();
+ 	if (use_xsave()) {
+ 		/*
+ 		 * Remove all UABI feature bits not set in user_xfeatures
+ 		 * from the memory xstate header which makes the full
+ 		 * restore below bring them into init state. This works for
+ 		 * fx_only mode as well because that has only FP and SSE
+ 		 * set in user_xfeatures.
+ 		 *
+ 		 * Preserve supervisor states!
+ 		 */
+ 		u64 mask = user_xfeatures | xfeatures_mask_supervisor();
+ 
+ 		fpu->state.xsave.header.xfeatures &= mask;
+ 		ret = os_xrstor_safe(&fpu->state.xsave, xfeatures_mask_all);
+ 	} else {
+ 		ret = fxrstor_safe(&fpu->state.fxsave);
+ 	}
+ 
+ 	if (likely(!ret))
+ 		fpregs_mark_activate();
+ 
++>>>>>>> 6f9866a166cd (x86/fpu/signal: Let xrstor handle the features to init)
  	fpregs_unlock();
  	return ret;
  }
* Unmerged path arch/x86/kernel/fpu/signal.c
