net: bridge: multicast: add EHT allow/block handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 474ddb37fa3ad0454f8d07bb9fb53ceab190b667
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/474ddb37.failed

Add support for IGMPv3/MLDv2 allow/block EHT handling. Similar to how
the reports are processed we have 2 cases when the group is in include
or exclude mode, these are processed as follows:
 - group include
  - allow: create missing entries
  - block: remove existing matching entries and remove the corresponding
    S,G entries if there are no more set host entries, then possibly
    delete the whole group if there are no more S,G entries

 - group exclude
  - allow
    - host include: create missing entries
    - host exclude: remove existing matching entries and remove the
      corresponding S,G entries if there are no more set host entries
  - block
    - host include: remove existing matching entries and remove the
      corresponding S,G entries if there are no more set host entries,
      then possibly delete the whole group if there are no more S,G entries
    - host exclude: create missing entries

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 474ddb37fa3ad0454f8d07bb9fb53ceab190b667)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
#	net/bridge/br_multicast_eht.c
#	net/bridge/br_private.h
#	net/bridge/br_private_mcast_eht.h
diff --cc net/bridge/br_multicast.c
index 4eaac3b4a6ea,3b8c5d1d0c55..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -199,10 -560,11 +199,10 @@@ static void br_multicast_destroy_group_
  	kfree_rcu(src, rcu);
  }
  
- static void br_multicast_del_group_src(struct net_bridge_group_src *src)
+ void br_multicast_del_group_src(struct net_bridge_group_src *src)
  {
 -	struct net_bridge *br = src->pg->key.port->br;
 +	struct net_bridge *br = src->pg->port->br;
  
 -	br_multicast_fwd_src_remove(src);
  	hlist_del_init_rcu(&src->node);
  	src->pg->src_ents--;
  	hlist_add_head(&src->mcast_gc.gc_node, &br->mcast_gc_list);
@@@ -1393,10 -1803,11 +1393,16 @@@ static void __grp_send_query_and_rexmit
   * INCLUDE (A)    ALLOW (B)     INCLUDE (A+B)            (B)=GMI
   * EXCLUDE (X,Y)  ALLOW (A)     EXCLUDE (X+A,Y-A)        (A)=GMI
   */
++<<<<<<< HEAD
 +static bool br_multicast_isinc_allow(struct net_bridge_port_group *pg,
 +				     void *srcs, u32 nsrcs, size_t src_size)
++=======
+ static bool br_multicast_isinc_allow(struct net_bridge_port_group *pg, void *h_addr,
+ 				     void *srcs, u32 nsrcs, size_t addr_size,
+ 				     int grec_type)
++>>>>>>> 474ddb37fa3a (net: bridge: multicast: add EHT allow/block handling)
  {
 -	struct net_bridge *br = pg->key.port->br;
 +	struct net_bridge *br = pg->port->br;
  	struct net_bridge_group_src *ent;
  	unsigned long now = jiffies;
  	bool changed = false;
@@@ -1415,10 -1826,12 +1421,13 @@@
  		}
  
  		if (ent)
 -			__grp_src_mod_timer(ent, now + br_multicast_gmi(br));
 +			mod_timer(&ent->timer, now + br_multicast_gmi(br));
 +		srcs += src_size;
  	}
  
+ 	if (br_multicast_eht_handle(pg, h_addr, srcs, nsrcs, addr_size, grec_type))
+ 		changed = true;
+ 
  	return changed;
  }
  
@@@ -1730,8 -2143,8 +1739,13 @@@ static bool br_multicast_toex(struct ne
  /* State          Msg type      New state                Actions
   * INCLUDE (A)    BLOCK (B)     INCLUDE (A)              Send Q(G,A*B)
   */
++<<<<<<< HEAD
 +static void __grp_src_block_incl(struct net_bridge_port_group *pg,
 +				 void *srcs, u32 nsrcs, size_t src_size)
++=======
+ static bool __grp_src_block_incl(struct net_bridge_port_group *pg, void *h_addr,
+ 				 void *srcs, u32 nsrcs, size_t addr_size, int grec_type)
++>>>>>>> 474ddb37fa3a (net: bridge: multicast: add EHT allow/block handling)
  {
  	struct net_bridge_group_src *ent;
  	u32 src_idx, to_send = 0;
@@@ -1749,9 -2163,11 +1763,12 @@@
  			ent->flags |= BR_SGRP_F_SEND;
  			to_send++;
  		}
 +		srcs += src_size;
  	}
  
+ 	if (br_multicast_eht_handle(pg, h_addr, srcs, nsrcs, addr_size, grec_type))
+ 		changed = true;
+ 
  	if (to_send)
  		__grp_src_query_marked_and_rexmit(pg);
  
@@@ -1763,8 -2186,8 +1780,13 @@@
   * EXCLUDE (X,Y)  BLOCK (A)     EXCLUDE (X+(A-Y),Y)      (A-X-Y)=Group Timer
   *                                                       Send Q(G,A-Y)
   */
++<<<<<<< HEAD
 +static bool __grp_src_block_excl(struct net_bridge_port_group *pg,
 +				 void *srcs, u32 nsrcs, size_t src_size)
++=======
+ static bool __grp_src_block_excl(struct net_bridge_port_group *pg, void *h_addr,
+ 				 void *srcs, u32 nsrcs, size_t addr_size, int grec_type)
++>>>>>>> 474ddb37fa3a (net: bridge: multicast: add EHT allow/block handling)
  {
  	struct net_bridge_group_src *ent;
  	u32 src_idx, to_send = 0;
@@@ -1790,26 -2213,30 +1812,43 @@@
  			ent->flags |= BR_SGRP_F_SEND;
  			to_send++;
  		}
 +		srcs += src_size;
  	}
  
+ 	if (br_multicast_eht_handle(pg, h_addr, srcs, nsrcs, addr_size, grec_type))
+ 		changed = true;
+ 
  	if (to_send)
  		__grp_src_query_marked_and_rexmit(pg);
  
  	return changed;
  }
  
++<<<<<<< HEAD
 +static bool br_multicast_block(struct net_bridge_port_group *pg,
 +			       void *srcs, u32 nsrcs, size_t src_size)
++=======
+ static bool br_multicast_block(struct net_bridge_port_group *pg, void *h_addr,
+ 			       void *srcs, u32 nsrcs, size_t addr_size, int grec_type)
++>>>>>>> 474ddb37fa3a (net: bridge: multicast: add EHT allow/block handling)
  {
  	bool changed = false;
  
  	switch (pg->filter_mode) {
  	case MCAST_INCLUDE:
++<<<<<<< HEAD
 +		__grp_src_block_incl(pg, srcs, nsrcs, src_size);
 +		break;
 +	case MCAST_EXCLUDE:
 +		changed = __grp_src_block_excl(pg, srcs, nsrcs, src_size);
++=======
+ 		changed = __grp_src_block_incl(pg, h_addr, srcs, nsrcs, addr_size,
+ 					       grec_type);
+ 		break;
+ 	case MCAST_EXCLUDE:
+ 		changed = __grp_src_block_excl(pg, h_addr, srcs, nsrcs, addr_size,
+ 					       grec_type);
++>>>>>>> 474ddb37fa3a (net: bridge: multicast: add EHT allow/block handling)
  		break;
  	}
  
@@@ -1906,32 -2333,33 +1945,46 @@@ static int br_ip4_multicast_igmp3_repor
  		pg = br_multicast_find_port(mdst, port, src);
  		if (!pg || (pg->flags & MDB_PG_FLAGS_PERMANENT))
  			goto unlock_continue;
 -		/* reload grec and host addr */
 +		/* reload grec */
  		grec = (void *)(skb->data + len - sizeof(*grec) - (nsrcs * 4));
 -		h_addr = &ip_hdr(skb)->saddr;
  		switch (type) {
  		case IGMPV3_ALLOW_NEW_SOURCES:
++<<<<<<< HEAD
 +			changed = br_multicast_isinc_allow(pg, grec->grec_src,
 +							   nsrcs, sizeof(__be32));
 +			break;
 +		case IGMPV3_MODE_IS_INCLUDE:
 +			changed = br_multicast_isinc_allow(pg, grec->grec_src, nsrcs,
 +							   sizeof(__be32));
++=======
+ 			changed = br_multicast_isinc_allow(pg, h_addr, grec->grec_src,
+ 							   nsrcs, sizeof(__be32), type);
+ 			break;
+ 		case IGMPV3_MODE_IS_INCLUDE:
+ 			changed = br_multicast_isinc_allow(pg, h_addr, grec->grec_src,
+ 							   nsrcs, sizeof(__be32), type);
++>>>>>>> 474ddb37fa3a (net: bridge: multicast: add EHT allow/block handling)
  			break;
  		case IGMPV3_MODE_IS_EXCLUDE:
 -			changed = br_multicast_isexc(pg, h_addr, grec->grec_src,
 -						     nsrcs, sizeof(__be32));
 +			changed = br_multicast_isexc(pg, grec->grec_src, nsrcs,
 +						     sizeof(__be32));
  			break;
  		case IGMPV3_CHANGE_TO_INCLUDE:
 -			changed = br_multicast_toin(pg, h_addr, grec->grec_src,
 -						    nsrcs, sizeof(__be32));
 +			changed = br_multicast_toin(pg, grec->grec_src, nsrcs,
 +						    sizeof(__be32));
  			break;
  		case IGMPV3_CHANGE_TO_EXCLUDE:
 -			changed = br_multicast_toex(pg, h_addr, grec->grec_src,
 -						    nsrcs, sizeof(__be32));
 +			changed = br_multicast_toex(pg, grec->grec_src, nsrcs,
 +						    sizeof(__be32));
  			break;
  		case IGMPV3_BLOCK_OLD_SOURCES:
++<<<<<<< HEAD
 +			changed = br_multicast_block(pg, grec->grec_src, nsrcs,
 +						     sizeof(__be32));
++=======
+ 			changed = br_multicast_block(pg, h_addr, grec->grec_src,
+ 						     nsrcs, sizeof(__be32), type);
++>>>>>>> 474ddb37fa3a (net: bridge: multicast: add EHT allow/block handling)
  			break;
  		}
  		if (changed)
@@@ -2033,18 -2462,23 +2086,31 @@@ static int br_ip6_multicast_mld2_report
  		pg = br_multicast_find_port(mdst, port, src);
  		if (!pg || (pg->flags & MDB_PG_FLAGS_PERMANENT))
  			goto unlock_continue;
 -		h_addr = &ipv6_hdr(skb)->saddr;
  		switch (grec->grec_type) {
  		case MLD2_ALLOW_NEW_SOURCES:
++<<<<<<< HEAD
 +			changed = br_multicast_isinc_allow(pg, grec->grec_src,
 +							   nsrcs,
 +							   sizeof(struct in6_addr));
 +			break;
 +		case MLD2_MODE_IS_INCLUDE:
 +			changed = br_multicast_isinc_allow(pg, grec->grec_src, nsrcs,
 +							   sizeof(struct in6_addr));
++=======
+ 			changed = br_multicast_isinc_allow(pg, h_addr,
+ 							   grec->grec_src, nsrcs,
+ 							   sizeof(struct in6_addr),
+ 							   grec->grec_type);
+ 			break;
+ 		case MLD2_MODE_IS_INCLUDE:
+ 			changed = br_multicast_isinc_allow(pg, h_addr,
+ 							   grec->grec_src, nsrcs,
+ 							   sizeof(struct in6_addr),
+ 							   grec->grec_type);
++>>>>>>> 474ddb37fa3a (net: bridge: multicast: add EHT allow/block handling)
  			break;
  		case MLD2_MODE_IS_EXCLUDE:
 -			changed = br_multicast_isexc(pg, h_addr,
 -						     grec->grec_src, nsrcs,
 +			changed = br_multicast_isexc(pg, grec->grec_src, nsrcs,
  						     sizeof(struct in6_addr));
  			break;
  		case MLD2_CHANGE_TO_INCLUDE:
@@@ -2056,8 -2492,10 +2122,15 @@@
  						    sizeof(struct in6_addr));
  			break;
  		case MLD2_BLOCK_OLD_SOURCES:
++<<<<<<< HEAD
 +			changed = br_multicast_block(pg, grec->grec_src, nsrcs,
 +						     sizeof(struct in6_addr));
++=======
+ 			changed = br_multicast_block(pg, h_addr,
+ 						     grec->grec_src, nsrcs,
+ 						     sizeof(struct in6_addr),
+ 						     grec->grec_type);
++>>>>>>> 474ddb37fa3a (net: bridge: multicast: add EHT allow/block handling)
  			break;
  		}
  		if (changed)
diff --cc net/bridge/br_private.h
index 032a117dc438,cad967690e9f..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -754,6 -844,18 +754,21 @@@ void br_mdb_init(void)
  void br_mdb_uninit(void);
  void br_multicast_host_join(struct net_bridge_mdb_entry *mp, bool notify);
  void br_multicast_host_leave(struct net_bridge_mdb_entry *mp, bool notify);
++<<<<<<< HEAD
++=======
+ void br_multicast_star_g_handle_mode(struct net_bridge_port_group *pg,
+ 				     u8 filter_mode);
+ void br_multicast_sg_add_exclude_ports(struct net_bridge_mdb_entry *star_mp,
+ 				       struct net_bridge_port_group *sg);
+ struct net_bridge_group_src *
+ br_multicast_find_group_src(struct net_bridge_port_group *pg, struct br_ip *ip);
+ void br_multicast_del_group_src(struct net_bridge_group_src *src);
+ 
+ static inline bool br_group_is_l2(const struct br_ip *group)
+ {
+ 	return group->proto == 0;
+ }
++>>>>>>> 474ddb37fa3a (net: bridge: multicast: add EHT allow/block handling)
  
  #define mlock_dereference(X, br) \
  	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
diff --cc net/bridge/br_private_mcast_eht.h
index 0c9c4267969d,92933822301d..000000000000
--- a/net/bridge/br_private_mcast_eht.h
+++ b/net/bridge/br_private_mcast_eht.h
@@@ -47,4 -47,12 +47,15 @@@ struct net_bridge_group_eht_set 
  	struct net_bridge_mcast_gc	mcast_gc;
  };
  
++<<<<<<< HEAD
++=======
+ void br_multicast_eht_clean_sets(struct net_bridge_port_group *pg);
+ bool br_multicast_eht_handle(struct net_bridge_port_group *pg,
+ 			     void *h_addr,
+ 			     void *srcs,
+ 			     u32 nsrcs,
+ 			     size_t addr_size,
+ 			     int grec_type);
+ 
++>>>>>>> 474ddb37fa3a (net: bridge: multicast: add EHT allow/block handling)
  #endif /* _BR_PRIVATE_MCAST_EHT_H_ */
* Unmerged path net/bridge/br_multicast_eht.c
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_multicast_eht.c
* Unmerged path net/bridge/br_private.h
* Unmerged path net/bridge/br_private_mcast_eht.h
