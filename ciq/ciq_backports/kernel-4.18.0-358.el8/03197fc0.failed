tracing: kdb: Allow ftdump to skip all but the last few entries

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Douglas Anderson <dianders@chromium.org>
commit 03197fc02b356606355d7ede343b18e3e3737771
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/03197fc0.failed

The 'ftdump' command in kdb is currently a bit of a last resort, at
least if you have lots of traces turned on.  It's going to print a
whole boatload of data out your serial port which is probably running
at 115200.  This could easily take many, many minutes.

Usually you're most interested in what's at the _end_ of the ftrace
buffer, AKA what happened most recently.  That means you've got to
wait the full time for the dump.  The 'ftdump' command does attempt to
help you a little bit by allowing you to skip a fixed number of
entries.  Unfortunately it provides no way for you to know how many
entries you should skip.

Let's do similar to python and allow you to use a negative number to
indicate that you want to skip all entries except the last few.  This
allows you to quickly see what you want.

Note that we also change the printout in ftdump to print the
(positive) number of entries actually skipped since that could be
helpful to know when you've specified a negative skip count.

Link: http://lkml.kernel.org/r/20190319171206.97107-3-dianders@chromium.org

	Signed-off-by: Douglas Anderson <dianders@chromium.org>
	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit 03197fc02b356606355d7ede343b18e3e3737771)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace_kdb.c
diff --cc kernel/trace/trace_kdb.c
index 6ffd1d8dd801,6c1ae6b752d1..000000000000
--- a/kernel/trace/trace_kdb.c
+++ b/kernel/trace/trace_kdb.c
@@@ -26,14 -26,8 +26,15 @@@ static void ftrace_dump_buf(int skip_en
  	unsigned int old_userobj;
  	int cnt = 0, cpu;
  
- 	trace_init_global_iter(&iter);
- 	iter.buffer_iter = buffer_iter;
  	tr = iter.tr;
  
++<<<<<<< HEAD
 +	for_each_tracing_cpu(cpu) {
 +		atomic_inc(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);
 +	}
 +
++=======
++>>>>>>> 03197fc02b35 (tracing: kdb: Allow ftdump to skip all but the last few entries)
  	old_userobj = tr->trace_flags;
  
  	/* don't look at user memory in panic mode */
@@@ -88,10 -86,6 +91,13 @@@ out
  	tr->trace_flags = old_userobj;
  
  	for_each_tracing_cpu(cpu) {
++<<<<<<< HEAD
 +		atomic_dec(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);
 +	}
 +
 +	for_each_tracing_cpu(cpu) {
++=======
++>>>>>>> 03197fc02b35 (tracing: kdb: Allow ftdump to skip all but the last few entries)
  		if (iter.buffer_iter[cpu]) {
  			ring_buffer_read_finish(iter.buffer_iter[cpu]);
  			iter.buffer_iter[cpu] = NULL;
* Unmerged path kernel/trace/trace_kdb.c
