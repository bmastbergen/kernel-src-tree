iommu: remove iommu_domain_{get,set}_attr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 7876a83ffe8c23c7049a63c747a7b96cafaf10a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/7876a83f.failed

Remove the now unused iommu attr infrastructure.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Acked-by: Will Deacon <will@kernel.org>
Link: https://lore.kernel.org/r/20210401155256.298656-21-hch@lst.de
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 7876a83ffe8c23c7049a63c747a7b96cafaf10a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iommu.c
#	include/linux/iommu.h
diff --cc drivers/iommu/iommu.c
index 1134fe3f7517,c4ad9c644802..000000000000
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@@ -2746,50 -2665,26 +2746,73 @@@ static int __init iommu_init(void
  }
  core_initcall(iommu_init);
  
++<<<<<<< HEAD
 +int iommu_domain_get_attr(struct iommu_domain *domain,
 +			  enum iommu_attr attr, void *data)
 +{
 +	struct iommu_domain_geometry *geometry;
 +	bool *paging;
 +	int ret = 0;
 +
 +	switch (attr) {
 +	case DOMAIN_ATTR_GEOMETRY:
 +		geometry  = data;
 +		*geometry = domain->geometry;
 +
 +		break;
 +	case DOMAIN_ATTR_PAGING:
 +		paging  = data;
 +		*paging = (domain->pgsize_bitmap != 0UL);
 +		break;
 +	default:
 +		if (!domain->ops->domain_get_attr)
 +			return -EINVAL;
 +
 +		ret = domain->ops->domain_get_attr(domain, attr, data);
 +	}
 +
 +	return ret;
 +}
 +EXPORT_SYMBOL_GPL(iommu_domain_get_attr);
 +
 +int iommu_domain_set_attr(struct iommu_domain *domain,
 +			  enum iommu_attr attr, void *data)
 +{
 +	int ret = 0;
 +
 +	switch (attr) {
 +	default:
 +		if (domain->ops->domain_set_attr == NULL)
 +			return -EINVAL;
 +
 +		ret = domain->ops->domain_set_attr(domain, attr, data);
 +	}
 +
 +	return ret;
 +}
 +EXPORT_SYMBOL_GPL(iommu_domain_set_attr);
++=======
+ int iommu_enable_nesting(struct iommu_domain *domain)
+ {
+ 	if (domain->type != IOMMU_DOMAIN_UNMANAGED)
+ 		return -EINVAL;
+ 	if (!domain->ops->enable_nesting)
+ 		return -EINVAL;
+ 	return domain->ops->enable_nesting(domain);
+ }
+ EXPORT_SYMBOL_GPL(iommu_enable_nesting);
+ 
+ int iommu_set_pgtable_quirks(struct iommu_domain *domain,
+ 		unsigned long quirk)
+ {
+ 	if (domain->type != IOMMU_DOMAIN_UNMANAGED)
+ 		return -EINVAL;
+ 	if (!domain->ops->set_pgtable_quirks)
+ 		return -EINVAL;
+ 	return domain->ops->set_pgtable_quirks(domain, quirk);
+ }
+ EXPORT_SYMBOL_GPL(iommu_set_pgtable_quirks);
++>>>>>>> 7876a83ffe8c (iommu: remove iommu_domain_{get,set}_attr)
  
  void iommu_get_resv_regions(struct device *dev, struct list_head *list)
  {
diff --cc include/linux/iommu.h
index 1d738c608f7d,a5b3af54fbb8..000000000000
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@@ -109,34 -96,6 +109,37 @@@ enum iommu_cap 
  	IOMMU_CAP_NOEXEC,		/* IOMMU_NOEXEC flag */
  };
  
++<<<<<<< HEAD
 +/*
 + * Following constraints are specifc to FSL_PAMUV1:
 + *  -aperture must be power of 2, and naturally aligned
 + *  -number of windows must be power of 2, and address space size
 + *   of each window is determined by aperture size / # of windows
 + *  -the actual size of the mapped region of a window must be power
 + *   of 2 starting with 4KB and physical address must be naturally
 + *   aligned.
 + * DOMAIN_ATTR_FSL_PAMUV1 corresponds to the above mentioned contraints.
 + * The caller can invoke iommu_domain_get_attr to check if the underlying
 + * iommu implementation supports these constraints.
 + */
 +
 +enum iommu_attr {
 +	DOMAIN_ATTR_GEOMETRY,
 +	DOMAIN_ATTR_PAGING,
 +	DOMAIN_ATTR_WINDOWS,
 +	DOMAIN_ATTR_FSL_PAMU_STASH,
 +	DOMAIN_ATTR_FSL_PAMU_ENABLE,
 +	DOMAIN_ATTR_FSL_PAMUV1,
 +	DOMAIN_ATTR_NESTING,	/* two stages of translation */
 +	DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE,
 +#ifndef __GENKSYMS__
 +	DOMAIN_ATTR_IO_PGTABLE_CFG,
 +#endif
 +	DOMAIN_ATTR_MAX,
 +};
 +
++=======
++>>>>>>> 7876a83ffe8c (iommu: remove iommu_domain_{get,set}_attr)
  /* These are the possible reserved region types */
  enum iommu_resv_type {
  	/* Memory regions which must be mapped 1:1 at all times */
@@@ -234,8 -191,8 +237,13 @@@ struct iommu_iotlb_gather 
   * @probe_finalize: Do final setup work after the device is added to an IOMMU
   *                  group and attached to the groups domain
   * @device_group: find iommu group for a particular device
++<<<<<<< HEAD
 + * @domain_get_attr: Query domain attributes
 + * @domain_set_attr: Change domain attributes
++=======
+  * @enable_nesting: Enable nesting
+  * @set_pgtable_quirks: Set io page table quirks (IO_PGTABLE_QUIRK_*)
++>>>>>>> 7876a83ffe8c (iommu: remove iommu_domain_{get,set}_attr)
   * @get_resv_regions: Request list of reserved regions for a device
   * @put_resv_regions: Free list of reserved regions for a device
   * @apply_resv_region: Temporary helper call-back for iova reserved ranges
@@@ -271,29 -227,23 +279,35 @@@ struct iommu_ops 
  
  	int (*attach_dev)(struct iommu_domain *domain, struct device *dev);
  	void (*detach_dev)(struct iommu_domain *domain, struct device *dev);
 -	int (*map)(struct iommu_domain *domain, unsigned long iova,
 -		   phys_addr_t paddr, size_t size, int prot, gfp_t gfp);
 -	size_t (*unmap)(struct iommu_domain *domain, unsigned long iova,
 -		     size_t size, struct iommu_iotlb_gather *iotlb_gather);
 +	RH_KABI_BROKEN_REPLACE(int (*map)(struct iommu_domain *domain, unsigned long iova,\
 +					  phys_addr_t paddr, size_t size, int prot),\
 +			       int (*map)(struct iommu_domain *domain, unsigned long iova,\
 +					  phys_addr_t paddr, size_t size, int prot, gfp_t gfp))
 +	RH_KABI_BROKEN_REPLACE(size_t (*unmap)(struct iommu_domain *domain, unsigned long iova,\
 +					       size_t size),size_t (*unmap)(struct iommu_domain *domain, unsigned long iova, \
 +									    size_t size, struct iommu_iotlb_gather *iotlb_gather))
  	void (*flush_iotlb_all)(struct iommu_domain *domain);
 -	void (*iotlb_sync_map)(struct iommu_domain *domain, unsigned long iova,
 -			       size_t size);
 -	void (*iotlb_sync)(struct iommu_domain *domain,
 -			   struct iommu_iotlb_gather *iotlb_gather);
 +	RH_KABI_BROKEN_REPLACE(void (*iotlb_range_add)(struct iommu_domain *domain,\
 +						       unsigned long iova, size_t size), \
 +			       void (*iotlb_sync_map)(struct iommu_domain *domain, unsigned long iova,\
 +				       size_t size))
 +	RH_KABI_BROKEN_REPLACE(void (*iotlb_sync)(struct iommu_domain *domain),\
 +			       void (*iotlb_sync)(struct iommu_domain *domain, \
 +						  struct iommu_iotlb_gather *iotlb_gather))
  	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain, dma_addr_t iova);
 -	struct iommu_device *(*probe_device)(struct device *dev);
 -	void (*release_device)(struct device *dev);
 -	void (*probe_finalize)(struct device *dev);
 +	RH_KABI_BROKEN_REMOVE(int (*add_device)(struct device *dev))
 +	RH_KABI_BROKEN_REMOVE(void (*remove_device)(struct device *dev))
  	struct iommu_group *(*device_group)(struct device *dev);
++<<<<<<< HEAD
 +	int (*domain_get_attr)(struct iommu_domain *domain,
 +			       enum iommu_attr attr, void *data);
 +	int (*domain_set_attr)(struct iommu_domain *domain,
 +			       enum iommu_attr attr, void *data);
++=======
+ 	int (*enable_nesting)(struct iommu_domain *domain);
+ 	int (*set_pgtable_quirks)(struct iommu_domain *domain,
+ 				  unsigned long quirks);
++>>>>>>> 7876a83ffe8c (iommu: remove iommu_domain_{get,set}_attr)
  
  	/* Request/Free a list of reserved regions for a device */
  	void (*get_resv_regions)(struct device *dev, struct list_head *list);
@@@ -546,15 -489,12 +560,21 @@@ extern int iommu_page_response(struct d
  extern int iommu_group_id(struct iommu_group *group);
  extern struct iommu_domain *iommu_group_default_domain(struct iommu_group *);
  
++<<<<<<< HEAD
 +extern int iommu_domain_get_attr(struct iommu_domain *domain, enum iommu_attr,
 +				 void *data);
 +extern int iommu_domain_set_attr(struct iommu_domain *domain, enum iommu_attr,
 +				 void *data);
++=======
+ int iommu_enable_nesting(struct iommu_domain *domain);
+ int iommu_set_pgtable_quirks(struct iommu_domain *domain,
+ 		unsigned long quirks);
++>>>>>>> 7876a83ffe8c (iommu: remove iommu_domain_{get,set}_attr)
  
 -void iommu_set_dma_strict(bool val);
 -bool iommu_get_dma_strict(struct iommu_domain *domain);
 +/* Window handling function prototypes */
 +extern int iommu_domain_window_enable(struct iommu_domain *domain, u32 wnd_nr,
 +				      phys_addr_t offset, u64 size,
 +				      int prot);
  
  extern int report_iommu_fault(struct iommu_domain *domain, struct device *dev,
  			      unsigned long iova, int flags);
@@@ -927,16 -859,10 +947,23 @@@ static inline int iommu_group_id(struc
  	return -ENODEV;
  }
  
++<<<<<<< HEAD
 +static inline int iommu_domain_get_attr(struct iommu_domain *domain,
 +					enum iommu_attr attr, void *data)
 +{
 +	return -EINVAL;
 +}
 +
 +static inline int iommu_domain_set_attr(struct iommu_domain *domain,
 +					enum iommu_attr attr, void *data)
 +{
 +	return -EINVAL;
++=======
+ static inline int iommu_set_pgtable_quirks(struct iommu_domain *domain,
+ 		unsigned long quirks)
+ {
+ 	return 0;
++>>>>>>> 7876a83ffe8c (iommu: remove iommu_domain_{get,set}_attr)
  }
  
  static inline int  iommu_device_register(struct iommu_device *iommu)
* Unmerged path drivers/iommu/iommu.c
* Unmerged path include/linux/iommu.h
