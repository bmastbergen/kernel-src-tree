signal: don't silently convert SI_USER signals to non-current pidfd

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Jann Horn <jannh@google.com>
commit 556a888a14afe27164191955618990fb3ccc9aad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/556a888a.failed

The current sys_pidfd_send_signal() silently turns signals with explicit
SI_USER context that are sent to non-current tasks into signals with
kernel-generated siginfo.
This is unlike do_rt_sigqueueinfo(), which returns -EPERM in this case.
If a user actually wants to send a signal with kernel-provided siginfo,
they can do that with pidfd_send_signal(pidfd, sig, NULL, 0); so allowing
this case is unnecessary.

Instead of silently replacing the siginfo, just bail out with an error;
this is consistent with other interfaces and avoids special-casing behavior
based on security checks.

Fixes: 3eb39f47934f ("signal: add pidfd_send_signal() syscall")
	Signed-off-by: Jann Horn <jannh@google.com>
	Signed-off-by: Christian Brauner <christian@brauner.io>
(cherry picked from commit 556a888a14afe27164191955618990fb3ccc9aad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/signal.c
diff --cc kernel/signal.c
index 0770041a0f5a,f98448cf2def..000000000000
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@@ -3543,6 -3513,115 +3543,118 @@@ SYSCALL_DEFINE2(kill, pid_t, pid, int, 
  	return kill_something_info(sig, &info, pid);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PROC_FS
+ /*
+  * Verify that the signaler and signalee either are in the same pid namespace
+  * or that the signaler's pid namespace is an ancestor of the signalee's pid
+  * namespace.
+  */
+ static bool access_pidfd_pidns(struct pid *pid)
+ {
+ 	struct pid_namespace *active = task_active_pid_ns(current);
+ 	struct pid_namespace *p = ns_of_pid(pid);
+ 
+ 	for (;;) {
+ 		if (!p)
+ 			return false;
+ 		if (p == active)
+ 			break;
+ 		p = p->parent;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static int copy_siginfo_from_user_any(kernel_siginfo_t *kinfo, siginfo_t *info)
+ {
+ #ifdef CONFIG_COMPAT
+ 	/*
+ 	 * Avoid hooking up compat syscalls and instead handle necessary
+ 	 * conversions here. Note, this is a stop-gap measure and should not be
+ 	 * considered a generic solution.
+ 	 */
+ 	if (in_compat_syscall())
+ 		return copy_siginfo_from_user32(
+ 			kinfo, (struct compat_siginfo __user *)info);
+ #endif
+ 	return copy_siginfo_from_user(kinfo, info);
+ }
+ 
+ /**
+  * sys_pidfd_send_signal - send a signal to a process through a task file
+  *                          descriptor
+  * @pidfd:  the file descriptor of the process
+  * @sig:    signal to be sent
+  * @info:   the signal info
+  * @flags:  future flags to be passed
+  *
+  * The syscall currently only signals via PIDTYPE_PID which covers
+  * kill(<positive-pid>, <signal>. It does not signal threads or process
+  * groups.
+  * In order to extend the syscall to threads and process groups the @flags
+  * argument should be used. In essence, the @flags argument will determine
+  * what is signaled and not the file descriptor itself. Put in other words,
+  * grouping is a property of the flags argument not a property of the file
+  * descriptor.
+  *
+  * Return: 0 on success, negative errno on failure
+  */
+ SYSCALL_DEFINE4(pidfd_send_signal, int, pidfd, int, sig,
+ 		siginfo_t __user *, info, unsigned int, flags)
+ {
+ 	int ret;
+ 	struct fd f;
+ 	struct pid *pid;
+ 	kernel_siginfo_t kinfo;
+ 
+ 	/* Enforce flags be set to 0 until we add an extension. */
+ 	if (flags)
+ 		return -EINVAL;
+ 
+ 	f = fdget_raw(pidfd);
+ 	if (!f.file)
+ 		return -EBADF;
+ 
+ 	/* Is this a pidfd? */
+ 	pid = tgid_pidfd_to_pid(f.file);
+ 	if (IS_ERR(pid)) {
+ 		ret = PTR_ERR(pid);
+ 		goto err;
+ 	}
+ 
+ 	ret = -EINVAL;
+ 	if (!access_pidfd_pidns(pid))
+ 		goto err;
+ 
+ 	if (info) {
+ 		ret = copy_siginfo_from_user_any(&kinfo, info);
+ 		if (unlikely(ret))
+ 			goto err;
+ 
+ 		ret = -EINVAL;
+ 		if (unlikely(sig != kinfo.si_signo))
+ 			goto err;
+ 
+ 		/* Only allow sending arbitrary signals to yourself. */
+ 		ret = -EPERM;
+ 		if ((task_pid(current) != pid) &&
+ 		    (kinfo.si_code >= 0 || kinfo.si_code == SI_TKILL))
+ 			goto err;
+ 	} else {
+ 		prepare_kill_siginfo(sig, &kinfo);
+ 	}
+ 
+ 	ret = kill_pid_info(sig, &kinfo, pid);
+ 
+ err:
+ 	fdput(f);
+ 	return ret;
+ }
+ #endif /* CONFIG_PROC_FS */
+ 
++>>>>>>> 556a888a14af (signal: don't silently convert SI_USER signals to non-current pidfd)
  static int
  do_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)
  {
* Unmerged path kernel/signal.c
