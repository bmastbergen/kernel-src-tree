net: bridge: add a flag to avoid refreshing fdb when changing/adding

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit b5f1d9ec283bd28a452cf61d7e5c2f2b1a9cccda
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/b5f1d9ec.failed

When we modify or create a new fdb entry sometimes we want to avoid
refreshing its activity in order to track it properly. One example is
when a mac is received from EVPN multi-homing peer by FRR, which doesn't
want to change local activity accounting. It makes it static and sets a
flag to track its activity.

	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b5f1d9ec283bd28a452cf61d7e5c2f2b1a9cccda)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/neighbour.h
#	net/bridge/br_fdb.c
diff --cc include/uapi/linux/neighbour.h
index cd144e3099a3,dc8b72201f6c..000000000000
--- a/include/uapi/linux/neighbour.h
+++ b/include/uapi/linux/neighbour.h
@@@ -171,4 -173,27 +171,30 @@@ enum 
  };
  #define NDTA_MAX (__NDTA_MAX - 1)
  
++<<<<<<< HEAD
++=======
+  /* FDB activity notification bits used in NFEA_ACTIVITY_NOTIFY:
+   * - FDB_NOTIFY_BIT - notify on activity/expire for any entry
+   * - FDB_NOTIFY_INACTIVE_BIT - mark as inactive to avoid multiple notifications
+   */
+ enum {
+ 	FDB_NOTIFY_BIT		= (1 << 0),
+ 	FDB_NOTIFY_INACTIVE_BIT	= (1 << 1)
+ };
+ 
+ /* embedded into NDA_FDB_EXT_ATTRS:
+  * [NDA_FDB_EXT_ATTRS] = {
+  *     [NFEA_ACTIVITY_NOTIFY]
+  *     ...
+  * }
+  */
+ enum {
+ 	NFEA_UNSPEC,
+ 	NFEA_ACTIVITY_NOTIFY,
+ 	NFEA_DONT_REFRESH,
+ 	__NFEA_MAX
+ };
+ #define NFEA_MAX (__NFEA_MAX - 1)
+ 
++>>>>>>> b5f1d9ec283b (net: bridge: add a flag to avoid refreshing fdb when changing/adding)
  #endif
diff --cc net/bridge/br_fdb.c
index d2321417063c,9db504baa094..000000000000
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@@ -806,11 -830,37 +806,12 @@@ errout
  	return err;
  }
  
 -/* returns true if the fdb is modified */
 -static bool fdb_handle_notify(struct net_bridge_fdb_entry *fdb, u8 notify)
 -{
 -	bool modified = false;
 -
 -	/* allow to mark an entry as inactive, usually done on creation */
 -	if ((notify & FDB_NOTIFY_INACTIVE_BIT) &&
 -	    !test_and_set_bit(BR_FDB_NOTIFY_INACTIVE, &fdb->flags))
 -		modified = true;
 -
 -	if ((notify & FDB_NOTIFY_BIT) &&
 -	    !test_and_set_bit(BR_FDB_NOTIFY, &fdb->flags)) {
 -		/* enabled activity tracking */
 -		modified = true;
 -	} else if (!(notify & FDB_NOTIFY_BIT) &&
 -		   test_and_clear_bit(BR_FDB_NOTIFY, &fdb->flags)) {
 -		/* disabled activity tracking, clear notify state */
 -		clear_bit(BR_FDB_NOTIFY_INACTIVE, &fdb->flags);
 -		modified = true;
 -	}
 -
 -	return modified;
 -}
 -
  /* Update (create or replace) forwarding database entry */
  static int fdb_add_entry(struct net_bridge *br, struct net_bridge_port *source,
 -			 const u8 *addr, struct ndmsg *ndm, u16 flags, u16 vid,
 -			 struct nlattr *nfea_tb[])
 +			 const u8 *addr, struct ndmsg *ndm, u16 flags, u16 vid)
  {
  	bool is_sticky = !!(ndm->ndm_flags & NTF_STICKY);
+ 	bool refresh = !nfea_tb[NFEA_DONT_REFRESH];
  	struct net_bridge_fdb_entry *fdb;
  	u16 state = ndm->ndm_state;
  	bool modified = false;
@@@ -912,6 -977,11 +914,14 @@@ static int __br_fdb_add(struct ndmsg *n
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static const struct nla_policy br_nda_fdb_pol[NFEA_MAX + 1] = {
+ 	[NFEA_ACTIVITY_NOTIFY]	= { .type = NLA_U8 },
+ 	[NFEA_DONT_REFRESH]	= { .type = NLA_FLAG },
+ };
+ 
++>>>>>>> b5f1d9ec283b (net: bridge: add a flag to avoid refreshing fdb when changing/adding)
  /* Add new permanent fdb entry with RTM_NEWNEIGH */
  int br_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
  	       struct net_device *dev,
* Unmerged path include/uapi/linux/neighbour.h
* Unmerged path net/bridge/br_fdb.c
