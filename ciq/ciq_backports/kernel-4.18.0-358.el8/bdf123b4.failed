net: bridge: constify variables in the replay helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Vladimir Oltean <vladimir.oltean@nxp.com>
commit bdf123b455ce596aec6e410ec36fe3687b6a2140
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/bdf123b4.failed

Some of the arguments and local variables for the newly added switchdev
replay helpers can be const, so let's make them so.

	Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bdf123b455ce596aec6e410ec36fe3687b6a2140)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/if_bridge.h
#	net/bridge/br_fdb.c
#	net/bridge/br_mdb.c
diff --cc include/linux/if_bridge.h
index f87c7c990fb6,6b54da2c65ba..000000000000
--- a/include/linux/if_bridge.h
+++ b/include/linux/if_bridge.h
@@@ -106,6 -104,13 +106,16 @@@ static inline bool br_multicast_router(
  {
  	return false;
  }
++<<<<<<< HEAD
++=======
+ static inline int br_mdb_replay(const struct net_device *br_dev,
+ 				const struct net_device *dev, const void *ctx,
+ 				struct notifier_block *nb,
+ 				struct netlink_ext_ack *extack)
+ {
+ 	return -EOPNOTSUPP;
+ }
++>>>>>>> bdf123b455ce (net: bridge: constify variables in the replay helpers)
  #endif
  
  #if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_VLAN_FILTERING)
@@@ -160,9 -166,9 +170,15 @@@ struct net_device *br_fdb_find_port(con
  void br_fdb_clear_offload(const struct net_device *dev, u16 vid);
  bool br_port_flag_is_set(const struct net_device *dev, unsigned long flag);
  u8 br_port_get_stp_state(const struct net_device *dev);
++<<<<<<< HEAD
 +clock_t br_get_ageing_time(struct net_device *br_dev);
 +int br_fdb_replay(struct net_device *br_dev, struct net_device *dev,
 +		  struct notifier_block *nb);
++=======
+ clock_t br_get_ageing_time(const struct net_device *br_dev);
+ int br_fdb_replay(const struct net_device *br_dev, const struct net_device *dev,
+ 		  const void *ctx, struct notifier_block *nb);
++>>>>>>> bdf123b455ce (net: bridge: constify variables in the replay helpers)
  #else
  static inline struct net_device *
  br_fdb_find_port(const struct net_device *br_dev,
@@@ -192,8 -198,8 +208,13 @@@ static inline clock_t br_get_ageing_tim
  	return 0;
  }
  
++<<<<<<< HEAD
 +static inline int br_fdb_replay(struct net_device *br_dev,
 +				struct net_device *dev,
++=======
+ static inline int br_fdb_replay(const struct net_device *br_dev,
+ 				const struct net_device *dev, const void *ctx,
++>>>>>>> bdf123b455ce (net: bridge: constify variables in the replay helpers)
  				struct notifier_block *nb)
  {
  	return -EOPNOTSUPP;
diff --cc net/bridge/br_fdb.c
index 971a68243dd4,2e777c8b0921..000000000000
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@@ -701,8 -727,8 +701,13 @@@ static inline size_t fdb_nlmsg_size(voi
  }
  
  static int br_fdb_replay_one(struct notifier_block *nb,
++<<<<<<< HEAD
 +			     struct net_bridge_fdb_entry *fdb,
 +			     struct net_device *dev)
++=======
+ 			     const struct net_bridge_fdb_entry *fdb,
+ 			     struct net_device *dev, const void *ctx)
++>>>>>>> bdf123b455ce (net: bridge: constify variables in the replay helpers)
  {
  	struct switchdev_notifier_fdb_info item;
  	int err;
@@@ -718,8 -745,8 +723,13 @@@
  	return notifier_to_errno(err);
  }
  
++<<<<<<< HEAD
 +int br_fdb_replay(struct net_device *br_dev, struct net_device *dev,
 +		  struct notifier_block *nb)
++=======
+ int br_fdb_replay(const struct net_device *br_dev, const struct net_device *dev,
+ 		  const void *ctx, struct notifier_block *nb)
++>>>>>>> bdf123b455ce (net: bridge: constify variables in the replay helpers)
  {
  	struct net_bridge_fdb_entry *fdb;
  	struct net_bridge *br;
diff --cc net/bridge/br_mdb.c
index 5621f5510fd4,cebdbff17b54..000000000000
--- a/net/bridge/br_mdb.c
+++ b/net/bridge/br_mdb.c
@@@ -466,6 -551,136 +466,139 @@@ err
  	kfree(priv);
  }
  
++<<<<<<< HEAD
++=======
+ static void br_switchdev_mdb_populate(struct switchdev_obj_port_mdb *mdb,
+ 				      const struct net_bridge_mdb_entry *mp)
+ {
+ 	if (mp->addr.proto == htons(ETH_P_IP))
+ 		ip_eth_mc_map(mp->addr.dst.ip4, mdb->addr);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	else if (mp->addr.proto == htons(ETH_P_IPV6))
+ 		ipv6_eth_mc_map(&mp->addr.dst.ip6, mdb->addr);
+ #endif
+ 	else
+ 		ether_addr_copy(mdb->addr, mp->addr.dst.mac_addr);
+ 
+ 	mdb->vid = mp->addr.vid;
+ }
+ 
+ static int br_mdb_replay_one(struct notifier_block *nb, struct net_device *dev,
+ 			     const struct switchdev_obj_port_mdb *mdb,
+ 			     const void *ctx, struct netlink_ext_ack *extack)
+ {
+ 	struct switchdev_notifier_port_obj_info obj_info = {
+ 		.info = {
+ 			.dev = dev,
+ 			.extack = extack,
+ 			.ctx = ctx,
+ 		},
+ 		.obj = &mdb->obj,
+ 	};
+ 	int err;
+ 
+ 	err = nb->notifier_call(nb, SWITCHDEV_PORT_OBJ_ADD, &obj_info);
+ 	return notifier_to_errno(err);
+ }
+ 
+ static int br_mdb_queue_one(struct list_head *mdb_list,
+ 			    enum switchdev_obj_id id,
+ 			    const struct net_bridge_mdb_entry *mp,
+ 			    struct net_device *orig_dev)
+ {
+ 	struct switchdev_obj_port_mdb *mdb;
+ 
+ 	mdb = kzalloc(sizeof(*mdb), GFP_ATOMIC);
+ 	if (!mdb)
+ 		return -ENOMEM;
+ 
+ 	mdb->obj.id = id;
+ 	mdb->obj.orig_dev = orig_dev;
+ 	br_switchdev_mdb_populate(mdb, mp);
+ 	list_add_tail(&mdb->obj.list, mdb_list);
+ 
+ 	return 0;
+ }
+ 
+ int br_mdb_replay(struct net_device *br_dev, struct net_device *dev,
+ 		  const void *ctx, struct notifier_block *nb,
+ 		  struct netlink_ext_ack *extack)
+ {
+ 	const struct net_bridge_mdb_entry *mp;
+ 	struct switchdev_obj *obj, *tmp;
+ 	struct net_bridge *br;
+ 	LIST_HEAD(mdb_list);
+ 	int err = 0;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	if (!netif_is_bridge_master(br_dev) || !netif_is_bridge_port(dev))
+ 		return -EINVAL;
+ 
+ 	br = netdev_priv(br_dev);
+ 
+ 	if (!br_opt_get(br, BROPT_MULTICAST_ENABLED))
+ 		return 0;
+ 
+ 	/* We cannot walk over br->mdb_list protected just by the rtnl_mutex,
+ 	 * because the write-side protection is br->multicast_lock. But we
+ 	 * need to emulate the [ blocking ] calling context of a regular
+ 	 * switchdev event, so since both br->multicast_lock and RCU read side
+ 	 * critical sections are atomic, we have no choice but to pick the RCU
+ 	 * read side lock, queue up all our events, leave the critical section
+ 	 * and notify switchdev from blocking context.
+ 	 */
+ 	rcu_read_lock();
+ 
+ 	hlist_for_each_entry_rcu(mp, &br->mdb_list, mdb_node) {
+ 		struct net_bridge_port_group __rcu * const *pp;
+ 		const struct net_bridge_port_group *p;
+ 
+ 		if (mp->host_joined) {
+ 			err = br_mdb_queue_one(&mdb_list,
+ 					       SWITCHDEV_OBJ_ID_HOST_MDB,
+ 					       mp, br_dev);
+ 			if (err) {
+ 				rcu_read_unlock();
+ 				goto out_free_mdb;
+ 			}
+ 		}
+ 
+ 		for (pp = &mp->ports; (p = rcu_dereference(*pp)) != NULL;
+ 		     pp = &p->next) {
+ 			if (p->key.port->dev != dev)
+ 				continue;
+ 
+ 			err = br_mdb_queue_one(&mdb_list,
+ 					       SWITCHDEV_OBJ_ID_PORT_MDB,
+ 					       mp, dev);
+ 			if (err) {
+ 				rcu_read_unlock();
+ 				goto out_free_mdb;
+ 			}
+ 		}
+ 	}
+ 
+ 	rcu_read_unlock();
+ 
+ 	list_for_each_entry(obj, &mdb_list, list) {
+ 		err = br_mdb_replay_one(nb, dev, SWITCHDEV_OBJ_PORT_MDB(obj),
+ 					ctx, extack);
+ 		if (err)
+ 			goto out_free_mdb;
+ 	}
+ 
+ out_free_mdb:
+ 	list_for_each_entry_safe(obj, tmp, &mdb_list, list) {
+ 		list_del(&obj->list);
+ 		kfree(SWITCHDEV_OBJ_PORT_MDB(obj));
+ 	}
+ 
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(br_mdb_replay);
+ 
++>>>>>>> bdf123b455ce (net: bridge: constify variables in the replay helpers)
  static void br_mdb_switchdev_host_port(struct net_device *dev,
  				       struct net_device *lower_dev,
  				       struct net_bridge_mdb_entry *mp,
* Unmerged path include/linux/if_bridge.h
* Unmerged path net/bridge/br_fdb.c
* Unmerged path net/bridge/br_mdb.c
diff --git a/net/bridge/br_stp.c b/net/bridge/br_stp.c
index 9ab768fe3a72..e911aee79aa6 100644
--- a/net/bridge/br_stp.c
+++ b/net/bridge/br_stp.c
@@ -643,9 +643,9 @@ int br_set_ageing_time(struct net_bridge *br, clock_t ageing_time)
 	return 0;
 }
 
-clock_t br_get_ageing_time(struct net_device *br_dev)
+clock_t br_get_ageing_time(const struct net_device *br_dev)
 {
-	struct net_bridge *br;
+	const struct net_bridge *br;
 
 	if (!netif_is_bridge_master(br_dev))
 		return 0;
