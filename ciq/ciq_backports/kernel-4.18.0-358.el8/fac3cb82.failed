net: bridge: mcast: use multicast_membership_interval for IGMPv3

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit fac3cb82a54a4b7c49c932f96ef196cf5774344c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/fac3cb82.failed

When I added IGMPv3 support I decided to follow the RFC for computing
the GMI dynamically:
" 8.4. Group Membership Interval

   The Group Membership Interval is the amount of time that must pass
   before a multicast router decides there are no more members of a
   group or a particular source on a network.

   This value MUST be ((the Robustness Variable) times (the Query
   Interval)) plus (one Query Response Interval)."

But that actually is inconsistent with how the bridge used to compute it
for IGMPv2, where it was user-configurable that has a correct default value
but it is up to user-space to maintain it. This would make it consistent
with the other timer values which are also maintained correct by the user
instead of being dynamically computed. It also changes back to the previous
user-expected GMI behaviour for IGMPv3 queries which were supported before
IGMPv3 was added. Note that to properly compute it dynamically we would
need to add support for "Robustness Variable" which is currently missing.

	Reported-by: Hangbin Liu <liuhangbin@gmail.com>
Fixes: 0436862e417e ("net: bridge: mcast: support for IGMPv3/MLDv2 ALLOW_NEW_SOURCES report")
	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fac3cb82a54a4b7c49c932f96ef196cf5774344c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_private.h
diff --cc net/bridge/br_private.h
index 30e07225bc94,37ca76406f1e..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -822,21 -1117,136 +822,141 @@@ static inline int br_multicast_igmp_typ
  	return BR_INPUT_SKB_CB(skb)->igmp;
  }
  
 -static inline unsigned long br_multicast_lmqt(const struct net_bridge_mcast *brmctx)
 +static inline unsigned long br_multicast_lmqt(const struct net_bridge *br)
  {
 -	return brmctx->multicast_last_member_interval *
 -	       brmctx->multicast_last_member_count;
 +	return br->multicast_last_member_interval *
 +	       br->multicast_last_member_count;
  }
  
 -static inline unsigned long br_multicast_gmi(const struct net_bridge_mcast *brmctx)
 +static inline unsigned long br_multicast_gmi(const struct net_bridge *br)
  {
++<<<<<<< HEAD
 +	/* use the RFC default of 2 for QRV */
 +	return 2 * br->multicast_query_interval +
 +	       br->multicast_query_response_interval;
++=======
+ 	return brmctx->multicast_membership_interval;
+ }
+ 
+ static inline bool
+ br_multicast_ctx_is_vlan(const struct net_bridge_mcast *brmctx)
+ {
+ 	return !!brmctx->vlan;
+ }
+ 
+ static inline bool
+ br_multicast_port_ctx_is_vlan(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	return !!pmctx->vlan;
+ }
+ 
+ static inline struct net_bridge_mcast *
+ br_multicast_port_ctx_get_global(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	if (!br_multicast_port_ctx_is_vlan(pmctx))
+ 		return &pmctx->port->br->multicast_ctx;
+ 	else
+ 		return &pmctx->vlan->brvlan->br_mcast_ctx;
+ }
+ 
+ static inline bool
+ br_multicast_ctx_vlan_global_disabled(const struct net_bridge_mcast *brmctx)
+ {
+ 	return br_opt_get(brmctx->br, BROPT_MCAST_VLAN_SNOOPING_ENABLED) &&
+ 	       br_multicast_ctx_is_vlan(brmctx) &&
+ 	       !(brmctx->vlan->priv_flags & BR_VLFLAG_GLOBAL_MCAST_ENABLED);
+ }
+ 
+ static inline bool
+ br_multicast_ctx_vlan_disabled(const struct net_bridge_mcast *brmctx)
+ {
+ 	return br_multicast_ctx_is_vlan(brmctx) &&
+ 	       !(brmctx->vlan->priv_flags & BR_VLFLAG_MCAST_ENABLED);
+ }
+ 
+ static inline bool
+ br_multicast_port_ctx_vlan_disabled(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	return br_multicast_port_ctx_is_vlan(pmctx) &&
+ 	       !(pmctx->vlan->priv_flags & BR_VLFLAG_MCAST_ENABLED);
+ }
+ 
+ static inline bool
+ br_multicast_port_ctx_state_disabled(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	return pmctx->port->state == BR_STATE_DISABLED ||
+ 	       (br_multicast_port_ctx_is_vlan(pmctx) &&
+ 		(br_multicast_port_ctx_vlan_disabled(pmctx) ||
+ 		 pmctx->vlan->state == BR_STATE_DISABLED));
+ }
+ 
+ static inline bool
+ br_multicast_port_ctx_state_stopped(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	return br_multicast_port_ctx_state_disabled(pmctx) ||
+ 	       pmctx->port->state == BR_STATE_BLOCKING ||
+ 	       (br_multicast_port_ctx_is_vlan(pmctx) &&
+ 		pmctx->vlan->state == BR_STATE_BLOCKING);
+ }
+ 
+ static inline bool
+ br_rports_have_mc_router(const struct net_bridge_mcast *brmctx)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	return !hlist_empty(&brmctx->ip4_mc_router_list) ||
+ 	       !hlist_empty(&brmctx->ip6_mc_router_list);
+ #else
+ 	return !hlist_empty(&brmctx->ip4_mc_router_list);
+ #endif
+ }
+ 
+ static inline bool
+ br_multicast_ctx_options_equal(const struct net_bridge_mcast *brmctx1,
+ 			       const struct net_bridge_mcast *brmctx2)
+ {
+ 	return brmctx1->multicast_igmp_version ==
+ 	       brmctx2->multicast_igmp_version &&
+ 	       brmctx1->multicast_last_member_count ==
+ 	       brmctx2->multicast_last_member_count &&
+ 	       brmctx1->multicast_startup_query_count ==
+ 	       brmctx2->multicast_startup_query_count &&
+ 	       brmctx1->multicast_last_member_interval ==
+ 	       brmctx2->multicast_last_member_interval &&
+ 	       brmctx1->multicast_membership_interval ==
+ 	       brmctx2->multicast_membership_interval &&
+ 	       brmctx1->multicast_querier_interval ==
+ 	       brmctx2->multicast_querier_interval &&
+ 	       brmctx1->multicast_query_interval ==
+ 	       brmctx2->multicast_query_interval &&
+ 	       brmctx1->multicast_query_response_interval ==
+ 	       brmctx2->multicast_query_response_interval &&
+ 	       brmctx1->multicast_startup_query_interval ==
+ 	       brmctx2->multicast_startup_query_interval &&
+ 	       brmctx1->multicast_querier == brmctx2->multicast_querier &&
+ 	       brmctx1->multicast_router == brmctx2->multicast_router &&
+ 	       !br_rports_have_mc_router(brmctx1) &&
+ 	       !br_rports_have_mc_router(brmctx2) &&
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	       brmctx1->multicast_mld_version ==
+ 	       brmctx2->multicast_mld_version &&
+ #endif
+ 	       true;
+ }
+ 
+ static inline bool
+ br_multicast_ctx_matches_vlan_snooping(const struct net_bridge_mcast *brmctx)
+ {
+ 	bool vlan_snooping_enabled;
+ 
+ 	vlan_snooping_enabled = !!br_opt_get(brmctx->br,
+ 					     BROPT_MCAST_VLAN_SNOOPING_ENABLED);
+ 
+ 	return !!(vlan_snooping_enabled == br_multicast_ctx_is_vlan(brmctx));
++>>>>>>> fac3cb82a54a (net: bridge: mcast: use multicast_membership_interval for IGMPv3)
  }
  #else
 -static inline int br_multicast_rcv(struct net_bridge_mcast **brmctx,
 -				   struct net_bridge_mcast_port **pmctx,
 -				   struct net_bridge_vlan *vlan,
 +static inline int br_multicast_rcv(struct net_bridge *br,
 +				   struct net_bridge_port *port,
  				   struct sk_buff *skb,
  				   u16 vid)
  {
* Unmerged path net/bridge/br_private.h
