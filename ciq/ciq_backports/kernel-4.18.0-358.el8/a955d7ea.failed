trace: Add timerlat tracer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Daniel Bristot de Oliveira <bristot@redhat.com>
commit a955d7eac1779b437ceb24fc352026a2cbcec140
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/a955d7ea.failed

The timerlat tracer aims to help the preemptive kernel developers to
found souces of wakeup latencies of real-time threads. Like cyclictest,
the tracer sets a periodic timer that wakes up a thread. The thread then
computes a *wakeup latency* value as the difference between the *current
time* and the *absolute time* that the timer was set to expire. The main
goal of timerlat is tracing in such a way to help kernel developers.

Usage

Write the ASCII text "timerlat" into the current_tracer file of the
tracing system (generally mounted at /sys/kernel/tracing).

For example:

        [root@f32 ~]# cd /sys/kernel/tracing/
        [root@f32 tracing]# echo timerlat > current_tracer

It is possible to follow the trace by reading the trace trace file:

  [root@f32 tracing]# cat trace
  # tracer: timerlat
  #
  #                              _-----=> irqs-off
  #                             / _----=> need-resched
  #                            | / _---=> hardirq/softirq
  #                            || / _--=> preempt-depth
  #                            || /
  #                            ||||             ACTIVATION
  #         TASK-PID      CPU# ||||   TIMESTAMP    ID            CONTEXT                LATENCY
  #            | |         |   ||||      |         |                  |                       |
          <idle>-0       [000] d.h1    54.029328: #1     context    irq timer_latency       932 ns
           <...>-867     [000] ....    54.029339: #1     context thread timer_latency     11700 ns
          <idle>-0       [001] dNh1    54.029346: #1     context    irq timer_latency      2833 ns
           <...>-868     [001] ....    54.029353: #1     context thread timer_latency      9820 ns
          <idle>-0       [000] d.h1    54.030328: #2     context    irq timer_latency       769 ns
           <...>-867     [000] ....    54.030330: #2     context thread timer_latency      3070 ns
          <idle>-0       [001] d.h1    54.030344: #2     context    irq timer_latency       935 ns
           <...>-868     [001] ....    54.030347: #2     context thread timer_latency      4351 ns

The tracer creates a per-cpu kernel thread with real-time priority that
prints two lines at every activation. The first is the *timer latency*
observed at the *hardirq* context before the activation of the thread.
The second is the *timer latency* observed by the thread, which is the
same level that cyclictest reports. The ACTIVATION ID field
serves to relate the *irq* execution to its respective *thread* execution.

The irq/thread splitting is important to clarify at which context
the unexpected high value is coming from. The *irq* context can be
delayed by hardware related actions, such as SMIs, NMIs, IRQs
or by a thread masking interrupts. Once the timer happens, the delay
can also be influenced by blocking caused by threads. For example, by
postponing the scheduler execution via preempt_disable(),  by the
scheduler execution, or by masking interrupts. Threads can
also be delayed by the interference from other threads and IRQs.

The timerlat can also take advantage of the osnoise: traceevents.
For example:

        [root@f32 ~]# cd /sys/kernel/tracing/
        [root@f32 tracing]# echo timerlat > current_tracer
        [root@f32 tracing]# echo osnoise > set_event
        [root@f32 tracing]# echo 25 > osnoise/stop_tracing_total_us
        [root@f32 tracing]# tail -10 trace
             cc1-87882   [005] d..h...   548.771078: #402268 context    irq timer_latency      1585 ns
             cc1-87882   [005] dNLh1..   548.771082: irq_noise: local_timer:236 start 548.771077442 duration 4597 ns
             cc1-87882   [005] dNLh2..   548.771083: irq_noise: reschedule:253 start 548.771083017 duration 56 ns
             cc1-87882   [005] dNLh2..   548.771086: irq_noise: call_function_single:251 start 548.771083811 duration 2048 ns
             cc1-87882   [005] dNLh2..   548.771088: irq_noise: call_function_single:251 start 548.771086814 duration 1495 ns
             cc1-87882   [005] dNLh2..   548.771091: irq_noise: call_function_single:251 start 548.771089194 duration 1558 ns
             cc1-87882   [005] dNLh2..   548.771094: irq_noise: call_function_single:251 start 548.771091719 duration 1932 ns
             cc1-87882   [005] dNLh2..   548.771096: irq_noise: call_function_single:251 start 548.771094696 duration 1050 ns
             cc1-87882   [005] d...3..   548.771101: thread_noise:      cc1:87882 start 548.771078243 duration 10909 ns
      timerlat/5-1035    [005] .......   548.771103: #402268 context thread timer_latency     25960 ns

For further information see: Documentation/trace/timerlat-tracer.rst

Link: https://lkml.kernel.org/r/71f18efc013e1194bcaea1e54db957de2b19ba62.1624372313.git.bristot@redhat.com

	Cc: Phil Auld <pauld@redhat.com>
	Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Cc: Kate Carcia <kcarcia@redhat.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Alexandre Chartre <alexandre.chartre@oracle.com>
	Cc: Clark Willaims <williams@redhat.com>
	Cc: John Kacur <jkacur@redhat.com>
	Cc: Juri Lelli <juri.lelli@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: x86@kernel.org
	Cc: linux-doc@vger.kernel.org
	Cc: linux-kernel@vger.kernel.org
	Signed-off-by: Daniel Bristot de Oliveira <bristot@redhat.com>
	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit a955d7eac1779b437ceb24fc352026a2cbcec140)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/trace/index.rst
#	kernel/trace/Kconfig
#	kernel/trace/trace.h
#	kernel/trace/trace_osnoise.c
#	kernel/trace/trace_output.c
diff --cc Documentation/trace/index.rst
index b58c10b04e27,3769b9b7aed8..000000000000
--- a/Documentation/trace/index.rst
+++ b/Documentation/trace/index.rst
@@@ -18,6 -19,14 +18,11 @@@ Linux Tracing Technologie
     events-nmi
     events-msr
     mmiotrace
 -   histogram
 -   histogram-design
 -   boottime-trace
     hwlat_detector
++<<<<<<< HEAD
++=======
+    osnoise-tracer
+    timerlat-tracer
++>>>>>>> a955d7eac177 (trace: Add timerlat tracer)
     intel_th
 -   ring-buffer-design
     stm
 -   sys-t
 -   coresight/index
diff --cc kernel/trace/Kconfig
index dbed47140bd5,d567b1717c4c..000000000000
--- a/kernel/trace/Kconfig
+++ b/kernel/trace/Kconfig
@@@ -278,6 -356,81 +278,84 @@@ config HWLAT_TRACE
  	 file. Every time a latency is greater than tracing_thresh, it will
  	 be recorded into the ring buffer.
  
++<<<<<<< HEAD
++=======
+ config OSNOISE_TRACER
+ 	bool "OS Noise tracer"
+ 	select GENERIC_TRACER
+ 	help
+ 	  In the context of high-performance computing (HPC), the Operating
+ 	  System Noise (osnoise) refers to the interference experienced by an
+ 	  application due to activities inside the operating system. In the
+ 	  context of Linux, NMIs, IRQs, SoftIRQs, and any other system thread
+ 	  can cause noise to the system. Moreover, hardware-related jobs can
+ 	  also cause noise, for example, via SMIs.
+ 
+ 	  The osnoise tracer leverages the hwlat_detector by running a similar
+ 	  loop with preemption, SoftIRQs and IRQs enabled, thus allowing all
+ 	  the sources of osnoise during its execution. The osnoise tracer takes
+ 	  note of the entry and exit point of any source of interferences,
+ 	  increasing a per-cpu interference counter. It saves an interference
+ 	  counter for each source of interference. The interference counter for
+ 	  NMI, IRQs, SoftIRQs, and threads is increased anytime the tool
+ 	  observes these interferences' entry events. When a noise happens
+ 	  without any interference from the operating system level, the
+ 	  hardware noise counter increases, pointing to a hardware-related
+ 	  noise. In this way, osnoise can account for any source of
+ 	  interference. At the end of the period, the osnoise tracer prints
+ 	  the sum of all noise, the max single noise, the percentage of CPU
+ 	  available for the thread, and the counters for the noise sources.
+ 
+ 	  In addition to the tracer, a set of tracepoints were added to
+ 	  facilitate the identification of the osnoise source.
+ 
+ 	  The output will appear in the trace and trace_pipe files.
+ 
+ 	  To enable this tracer, echo in "osnoise" into the current_tracer
+           file.
+ 
+ config TIMERLAT_TRACER
+ 	bool "Timerlat tracer"
+ 	select OSNOISE_TRACER
+ 	select GENERIC_TRACER
+ 	help
+ 	  The timerlat tracer aims to help the preemptive kernel developers
+ 	  to find sources of wakeup latencies of real-time threads.
+ 
+ 	  The tracer creates a per-cpu kernel thread with real-time priority.
+ 	  The tracer thread sets a periodic timer to wakeup itself, and goes
+ 	  to sleep waiting for the timer to fire. At the wakeup, the thread
+ 	  then computes a wakeup latency value as the difference between
+ 	  the current time and the absolute time that the timer was set
+ 	  to expire.
+ 
+ 	  The tracer prints two lines at every activation. The first is the
+ 	  timer latency observed at the hardirq context before the
+ 	  activation of the thread. The second is the timer latency observed
+ 	  by the thread, which is the same level that cyclictest reports. The
+ 	  ACTIVATION ID field serves to relate the irq execution to its
+ 	  respective thread execution.
+ 
+ 	  The tracer is build on top of osnoise tracer, and the osnoise:
+ 	  events can be used to trace the source of interference from NMI,
+ 	  IRQs and other threads. It also enables the capture of the
+ 	  stacktrace at the IRQ context, which helps to identify the code
+ 	  path that can cause thread delay.
+ 
+ config MMIOTRACE
+ 	bool "Memory mapped IO tracing"
+ 	depends on HAVE_MMIOTRACE_SUPPORT && PCI
+ 	select GENERIC_TRACER
+ 	help
+ 	  Mmiotrace traces Memory Mapped I/O access and is meant for
+ 	  debugging and reverse engineering. It is called from the ioremap
+ 	  implementation and works via page faults. Tracing is disabled by
+ 	  default and can be enabled at run-time.
+ 
+ 	  See Documentation/trace/mmiotrace.rst.
+ 	  If you are not helping to develop drivers, say N.
+ 
++>>>>>>> a955d7eac177 (trace: Add timerlat tracer)
  config ENABLE_DEFAULT_TRACERS
  	bool "Trace process context switches and events"
  	depends on !GENERIC_TRACER
diff --cc kernel/trace/trace.h
index d08237c45b3a,d83bbb6859b4..000000000000
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@@ -41,7 -44,10 +41,12 @@@ enum trace_type 
  	TRACE_BLK,
  	TRACE_BPUTS,
  	TRACE_HWLAT,
++<<<<<<< HEAD
++=======
+ 	TRACE_OSNOISE,
+ 	TRACE_TIMERLAT,
++>>>>>>> a955d7eac177 (trace: Add timerlat tracer)
  	TRACE_RAW_DATA,
 -	TRACE_FUNC_REPEATS,
  
  	__TRACE_LAST_TYPE,
  };
@@@ -348,6 -448,8 +353,11 @@@ extern void __ftrace_bad_type(void)
  		IF_ASSIGN(var, ent, struct bprint_entry, TRACE_BPRINT);	\
  		IF_ASSIGN(var, ent, struct bputs_entry, TRACE_BPUTS);	\
  		IF_ASSIGN(var, ent, struct hwlat_entry, TRACE_HWLAT);	\
++<<<<<<< HEAD
++=======
+ 		IF_ASSIGN(var, ent, struct osnoise_entry, TRACE_OSNOISE);\
+ 		IF_ASSIGN(var, ent, struct timerlat_entry, TRACE_TIMERLAT);\
++>>>>>>> a955d7eac177 (trace: Add timerlat tracer)
  		IF_ASSIGN(var, ent, struct raw_data_entry, TRACE_RAW_DATA);\
  		IF_ASSIGN(var, ent, struct trace_mmiotrace_rw,		\
  			  TRACE_MMIO_RW);				\
diff --cc kernel/trace/trace_output.c
index c35fc4a07d49,a0bf446bb034..000000000000
--- a/kernel/trace/trace_output.c
+++ b/kernel/trace/trace_output.c
@@@ -1233,6 -1231,122 +1233,125 @@@ static struct trace_event trace_hwlat_e
  	.funcs		= &trace_hwlat_funcs,
  };
  
++<<<<<<< HEAD
++=======
+ /* TRACE_OSNOISE */
+ static enum print_line_t
+ trace_osnoise_print(struct trace_iterator *iter, int flags,
+ 		    struct trace_event *event)
+ {
+ 	struct trace_entry *entry = iter->ent;
+ 	struct trace_seq *s = &iter->seq;
+ 	struct osnoise_entry *field;
+ 	u64 ratio, ratio_dec;
+ 	u64 net_runtime;
+ 
+ 	trace_assign_type(field, entry);
+ 
+ 	/*
+ 	 * compute the available % of cpu time.
+ 	 */
+ 	net_runtime = field->runtime - field->noise;
+ 	ratio = net_runtime * 10000000;
+ 	do_div(ratio, field->runtime);
+ 	ratio_dec = do_div(ratio, 100000);
+ 
+ 	trace_seq_printf(s, "%llu %10llu %3llu.%05llu %7llu",
+ 			 field->runtime,
+ 			 field->noise,
+ 			 ratio, ratio_dec,
+ 			 field->max_sample);
+ 
+ 	trace_seq_printf(s, " %6u", field->hw_count);
+ 	trace_seq_printf(s, " %6u", field->nmi_count);
+ 	trace_seq_printf(s, " %6u", field->irq_count);
+ 	trace_seq_printf(s, " %6u", field->softirq_count);
+ 	trace_seq_printf(s, " %6u", field->thread_count);
+ 
+ 	trace_seq_putc(s, '\n');
+ 
+ 	return trace_handle_return(s);
+ }
+ 
+ static enum print_line_t
+ trace_osnoise_raw(struct trace_iterator *iter, int flags,
+ 		  struct trace_event *event)
+ {
+ 	struct osnoise_entry *field;
+ 	struct trace_seq *s = &iter->seq;
+ 
+ 	trace_assign_type(field, iter->ent);
+ 
+ 	trace_seq_printf(s, "%lld %llu %llu %u %u %u %u %u\n",
+ 			 field->runtime,
+ 			 field->noise,
+ 			 field->max_sample,
+ 			 field->hw_count,
+ 			 field->nmi_count,
+ 			 field->irq_count,
+ 			 field->softirq_count,
+ 			 field->thread_count);
+ 
+ 	return trace_handle_return(s);
+ }
+ 
+ static struct trace_event_functions trace_osnoise_funcs = {
+ 	.trace		= trace_osnoise_print,
+ 	.raw		= trace_osnoise_raw,
+ };
+ 
+ static struct trace_event trace_osnoise_event = {
+ 	.type		= TRACE_OSNOISE,
+ 	.funcs		= &trace_osnoise_funcs,
+ };
+ 
+ /* TRACE_TIMERLAT */
+ static enum print_line_t
+ trace_timerlat_print(struct trace_iterator *iter, int flags,
+ 		     struct trace_event *event)
+ {
+ 	struct trace_entry *entry = iter->ent;
+ 	struct trace_seq *s = &iter->seq;
+ 	struct timerlat_entry *field;
+ 
+ 	trace_assign_type(field, entry);
+ 
+ 	trace_seq_printf(s, "#%-5u context %6s timer_latency %9llu ns\n",
+ 			 field->seqnum,
+ 			 field->context ? "thread" : "irq",
+ 			 field->timer_latency);
+ 
+ 	return trace_handle_return(s);
+ }
+ 
+ static enum print_line_t
+ trace_timerlat_raw(struct trace_iterator *iter, int flags,
+ 		   struct trace_event *event)
+ {
+ 	struct timerlat_entry *field;
+ 	struct trace_seq *s = &iter->seq;
+ 
+ 	trace_assign_type(field, iter->ent);
+ 
+ 	trace_seq_printf(s, "%u %d %llu\n",
+ 			 field->seqnum,
+ 			 field->context,
+ 			 field->timer_latency);
+ 
+ 	return trace_handle_return(s);
+ }
+ 
+ static struct trace_event_functions trace_timerlat_funcs = {
+ 	.trace		= trace_timerlat_print,
+ 	.raw		= trace_timerlat_raw,
+ };
+ 
+ static struct trace_event trace_timerlat_event = {
+ 	.type		= TRACE_TIMERLAT,
+ 	.funcs		= &trace_timerlat_funcs,
+ };
+ 
++>>>>>>> a955d7eac177 (trace: Add timerlat tracer)
  /* TRACE_BPUTS */
  static enum print_line_t
  trace_bputs_print(struct trace_iterator *iter, int flags,
@@@ -1398,7 -1557,10 +1517,12 @@@ static struct trace_event *events[] __i
  	&trace_bprint_event,
  	&trace_print_event,
  	&trace_hwlat_event,
++<<<<<<< HEAD
++=======
+ 	&trace_osnoise_event,
+ 	&trace_timerlat_event,
++>>>>>>> a955d7eac177 (trace: Add timerlat tracer)
  	&trace_raw_data_event,
 -	&trace_func_repeats_event,
  	NULL
  };
  
* Unmerged path kernel/trace/trace_osnoise.c
* Unmerged path Documentation/trace/index.rst
diff --git a/Documentation/trace/timerlat-tracer.rst b/Documentation/trace/timerlat-tracer.rst
new file mode 100644
index 000000000000..c7cbb557aee7
--- /dev/null
+++ b/Documentation/trace/timerlat-tracer.rst
@@ -0,0 +1,181 @@
+###############
+Timerlat tracer
+###############
+
+The timerlat tracer aims to help the preemptive kernel developers to
+find souces of wakeup latencies of real-time threads. Like cyclictest,
+the tracer sets a periodic timer that wakes up a thread. The thread then
+computes a *wakeup latency* value as the difference between the *current
+time* and the *absolute time* that the timer was set to expire. The main
+goal of timerlat is tracing in such a way to help kernel developers.
+
+Usage
+-----
+
+Write the ASCII text "timerlat" into the current_tracer file of the
+tracing system (generally mounted at /sys/kernel/tracing).
+
+For example::
+
+        [root@f32 ~]# cd /sys/kernel/tracing/
+        [root@f32 tracing]# echo timerlat > current_tracer
+
+It is possible to follow the trace by reading the trace trace file::
+
+  [root@f32 tracing]# cat trace
+  # tracer: timerlat
+  #
+  #                              _-----=> irqs-off
+  #                             / _----=> need-resched
+  #                            | / _---=> hardirq/softirq
+  #                            || / _--=> preempt-depth
+  #                            || /
+  #                            ||||             ACTIVATION
+  #         TASK-PID      CPU# ||||   TIMESTAMP    ID            CONTEXT                LATENCY
+  #            | |         |   ||||      |         |                  |                       |
+          <idle>-0       [000] d.h1    54.029328: #1     context    irq timer_latency       932 ns
+           <...>-867     [000] ....    54.029339: #1     context thread timer_latency     11700 ns
+          <idle>-0       [001] dNh1    54.029346: #1     context    irq timer_latency      2833 ns
+           <...>-868     [001] ....    54.029353: #1     context thread timer_latency      9820 ns
+          <idle>-0       [000] d.h1    54.030328: #2     context    irq timer_latency       769 ns
+           <...>-867     [000] ....    54.030330: #2     context thread timer_latency      3070 ns
+          <idle>-0       [001] d.h1    54.030344: #2     context    irq timer_latency       935 ns
+           <...>-868     [001] ....    54.030347: #2     context thread timer_latency      4351 ns
+
+
+The tracer creates a per-cpu kernel thread with real-time priority that
+prints two lines at every activation. The first is the *timer latency*
+observed at the *hardirq* context before the activation of the thread.
+The second is the *timer latency* observed by the thread. The ACTIVATION
+ID field serves to relate the *irq* execution to its respective *thread*
+execution.
+
+The *irq*/*thread* splitting is important to clarify at which context
+the unexpected high value is coming from. The *irq* context can be
+delayed by hardware related actions, such as SMIs, NMIs, IRQs
+or by a thread masking interrupts. Once the timer happens, the delay
+can also be influenced by blocking caused by threads. For example, by
+postponing the scheduler execution via preempt_disable(), by the
+scheduler execution, or by masking interrupts. Threads can
+also be delayed by the interference from other threads and IRQs.
+
+Tracer options
+---------------------
+
+The timerlat tracer is built on top of osnoise tracer.
+So its configuration is also done in the osnoise/ config
+directory. The timerlat configs are:
+
+ - cpus: CPUs at which a timerlat thread will execute.
+ - timerlat_period_us: the period of the timerlat thread.
+ - osnoise/stop_tracing_us: stop the system tracing if a
+   timer latency at the *irq* context higher than the configured
+   value happens. Writing 0 disables this option.
+ - stop_tracing_total_us: stop the system tracing if a
+   timer latency at the *thread* context higher than the configured
+   value happens. Writing 0 disables this option.
+ - print_stack: save the stack of the IRQ ocurrence, and print
+   it afte the *thread context* event".
+
+timerlat and osnoise
+----------------------------
+
+The timerlat can also take advantage of the osnoise: traceevents.
+For example::
+
+        [root@f32 ~]# cd /sys/kernel/tracing/
+        [root@f32 tracing]# echo timerlat > current_tracer
+        [root@f32 tracing]# echo 1 > events/osnoise/enable
+        [root@f32 tracing]# echo 25 > osnoise/stop_tracing_total_us
+        [root@f32 tracing]# tail -10 trace
+             cc1-87882   [005] d..h...   548.771078: #402268 context    irq timer_latency     13585 ns
+             cc1-87882   [005] dNLh1..   548.771082: irq_noise: local_timer:236 start 548.771077442 duration 7597 ns
+             cc1-87882   [005] dNLh2..   548.771099: irq_noise: qxl:21 start 548.771085017 duration 7139 ns
+             cc1-87882   [005] d...3..   548.771102: thread_noise:      cc1:87882 start 548.771078243 duration 9909 ns
+      timerlat/5-1035    [005] .......   548.771104: #402268 context thread timer_latency     39960 ns
+
+In this case, the root cause of the timer latency does not point to a
+single cause, but to multiple ones. Firstly, the timer IRQ was delayed
+for 13 us, which may point to a long IRQ disabled section (see IRQ
+stacktrace section). Then the timer interrupt that wakes up the timerlat
+thread took 7597 ns, and the qxl:21 device IRQ took 7139 ns. Finally,
+the cc1 thread noise took 9909 ns of time before the context switch.
+Such pieces of evidence are useful for the developer to use other
+tracing methods to figure out how to debug and optimize the system.
+
+It is worth mentioning that the *duration* values reported
+by the osnoise: events are *net* values. For example, the
+thread_noise does not include the duration of the overhead caused
+by the IRQ execution (which indeed accounted for 12736 ns). But
+the values reported by the timerlat tracer (timerlat_latency)
+are *gross* values.
+
+The art below illustrates a CPU timeline and how the timerlat tracer
+observes it at the top and the osnoise: events at the bottom. Each "-"
+in the timelines means circa 1 us, and the time moves ==>::
+
+      External     timer irq                   thread
+       clock        latency                    latency
+       event        13585 ns                   39960 ns
+         |             ^                         ^
+         v             |                         |
+         |-------------|                         |
+         |-------------+-------------------------|
+                       ^                         ^
+  ========================================================================
+                    [tmr irq]  [dev irq]
+  [another thread...^       v..^       v.......][timerlat/ thread]  <-- CPU timeline
+  =========================================================================
+                    |-------|  |-------|
+                            |--^       v-------|
+                            |          |       |
+                            |          |       + thread_noise: 9909 ns
+                            |          +-> irq_noise: 6139 ns
+                            +-> irq_noise: 7597 ns
+
+IRQ stacktrace
+---------------------------
+
+The osnoise/print_stack option is helpful for the cases in which a thread
+noise causes the major factor for the timer latency, because of preempt or
+irq disabled. For example::
+
+        [root@f32 tracing]# echo 500 > osnoise/stop_tracing_total_us
+        [root@f32 tracing]# echo 500 > osnoise/print_stack
+        [root@f32 tracing]# echo timerlat > current_tracer
+        [root@f32 tracing]# tail -21 per_cpu/cpu7/trace
+          insmod-1026    [007] dN.h1..   200.201948: irq_noise: local_timer:236 start 200.201939376 duration 7872 ns
+          insmod-1026    [007] d..h1..   200.202587: #29800 context    irq timer_latency      1616 ns
+          insmod-1026    [007] dN.h2..   200.202598: irq_noise: local_timer:236 start 200.202586162 duration 11855 ns
+          insmod-1026    [007] dN.h3..   200.202947: irq_noise: local_timer:236 start 200.202939174 duration 7318 ns
+          insmod-1026    [007] d...3..   200.203444: thread_noise:   insmod:1026 start 200.202586933 duration 838681 ns
+      timerlat/7-1001    [007] .......   200.203445: #29800 context thread timer_latency    859978 ns
+      timerlat/7-1001    [007] ....1..   200.203446: <stack trace>
+  => timerlat_irq
+  => __hrtimer_run_queues
+  => hrtimer_interrupt
+  => __sysvec_apic_timer_interrupt
+  => asm_call_irq_on_stack
+  => sysvec_apic_timer_interrupt
+  => asm_sysvec_apic_timer_interrupt
+  => delay_tsc
+  => dummy_load_1ms_pd_init
+  => do_one_initcall
+  => do_init_module
+  => __do_sys_finit_module
+  => do_syscall_64
+  => entry_SYSCALL_64_after_hwframe
+
+In this case, it is possible to see that the thread added the highest
+contribution to the *timer latency* and the stack trace, saved during
+the timerlat IRQ handler, points to a function named
+dummy_load_1ms_pd_init, which had the following code (on purpose)::
+
+	static int __init dummy_load_1ms_pd_init(void)
+	{
+		preempt_disable();
+		mdelay(1);
+		preempt_enable();
+		return 0;
+
+	}
* Unmerged path kernel/trace/Kconfig
* Unmerged path kernel/trace/trace.h
diff --git a/kernel/trace/trace_entries.h b/kernel/trace/trace_entries.h
index 1d67464ed95e..c273c8f45da2 100644
--- a/kernel/trace/trace_entries.h
+++ b/kernel/trace/trace_entries.h
@@ -369,3 +369,19 @@ FTRACE_ENTRY(hwlat, hwlat_entry,
 
 	FILTER_OTHER
 );
+
+FTRACE_ENTRY(timerlat, timerlat_entry,
+
+	TRACE_TIMERLAT,
+
+	F_STRUCT(
+		__field(	unsigned int,		seqnum		)
+		__field(	int,			context		)
+		__field(	u64,			timer_latency	)
+	),
+
+	F_printk("seq:%u\tcontext:%d\ttimer_latency:%llu\n",
+		 __entry->seqnum,
+		 __entry->context,
+		 __entry->timer_latency)
+);
* Unmerged path kernel/trace/trace_osnoise.c
* Unmerged path kernel/trace/trace_output.c
