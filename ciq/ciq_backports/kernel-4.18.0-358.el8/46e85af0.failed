driver core: platform: don't oops in platform_shutdown() on unbound devices

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
commit 46e85af0cc53f35584e00bb5db7db6893d0e16e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/46e85af0.failed

On shutdown the driver core calls the bus' shutdown callback also for
unbound devices. A driver's shutdown callback however is only called for
devices bound to this driver. Commit 9c30921fe799 ("driver core:
platform: use bus_type functions") changed the platform bus from driver
callbacks to bus callbacks, so the shutdown function must be prepared to
be called without a driver. Add the corresponding check in the shutdown
function.

Fixes: 9c30921fe799 ("driver core: platform: use bus_type functions")
	Tested-by: Guenter Roeck <linux@roeck-us.net>
	Reviewed-by: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
	Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
Link: https://lore.kernel.org/r/20201212235533.247537-1-dmitry.baryshkov@linaro.org
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 46e85af0cc53f35584e00bb5db7db6893d0e16e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/platform.c
diff --cc drivers/base/platform.c
index 376d4125a3e4,e9477e0bbca5..000000000000
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@@ -1371,6 -1135,234 +1371,237 @@@ int platform_pm_restore(struct device *
  
  #endif /* CONFIG_HIBERNATE_CALLBACKS */
  
++<<<<<<< HEAD
++=======
+ /* modalias support enables more hands-off userspace setup:
+  * (a) environment variable lets new-style hotplug events work once system is
+  *     fully running:  "modprobe $MODALIAS"
+  * (b) sysfs attribute lets new-style coldplug recover from hotplug events
+  *     mishandled before system is fully running:  "modprobe $(cat modalias)"
+  */
+ static ssize_t modalias_show(struct device *dev,
+ 			     struct device_attribute *attr, char *buf)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+ 	int len;
+ 
+ 	len = of_device_modalias(dev, buf, PAGE_SIZE);
+ 	if (len != -ENODEV)
+ 		return len;
+ 
+ 	len = acpi_device_modalias(dev, buf, PAGE_SIZE - 1);
+ 	if (len != -ENODEV)
+ 		return len;
+ 
+ 	return sysfs_emit(buf, "platform:%s\n", pdev->name);
+ }
+ static DEVICE_ATTR_RO(modalias);
+ 
+ static ssize_t numa_node_show(struct device *dev,
+ 			      struct device_attribute *attr, char *buf)
+ {
+ 	return sysfs_emit(buf, "%d\n", dev_to_node(dev));
+ }
+ static DEVICE_ATTR_RO(numa_node);
+ 
+ static ssize_t driver_override_show(struct device *dev,
+ 				    struct device_attribute *attr, char *buf)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+ 	ssize_t len;
+ 
+ 	device_lock(dev);
+ 	len = sysfs_emit(buf, "%s\n", pdev->driver_override);
+ 	device_unlock(dev);
+ 
+ 	return len;
+ }
+ 
+ static ssize_t driver_override_store(struct device *dev,
+ 				     struct device_attribute *attr,
+ 				     const char *buf, size_t count)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+ 	char *driver_override, *old, *cp;
+ 
+ 	/* We need to keep extra room for a newline */
+ 	if (count >= (PAGE_SIZE - 1))
+ 		return -EINVAL;
+ 
+ 	driver_override = kstrndup(buf, count, GFP_KERNEL);
+ 	if (!driver_override)
+ 		return -ENOMEM;
+ 
+ 	cp = strchr(driver_override, '\n');
+ 	if (cp)
+ 		*cp = '\0';
+ 
+ 	device_lock(dev);
+ 	old = pdev->driver_override;
+ 	if (strlen(driver_override)) {
+ 		pdev->driver_override = driver_override;
+ 	} else {
+ 		kfree(driver_override);
+ 		pdev->driver_override = NULL;
+ 	}
+ 	device_unlock(dev);
+ 
+ 	kfree(old);
+ 
+ 	return count;
+ }
+ static DEVICE_ATTR_RW(driver_override);
+ 
+ static struct attribute *platform_dev_attrs[] = {
+ 	&dev_attr_modalias.attr,
+ 	&dev_attr_numa_node.attr,
+ 	&dev_attr_driver_override.attr,
+ 	NULL,
+ };
+ 
+ static umode_t platform_dev_attrs_visible(struct kobject *kobj, struct attribute *a,
+ 		int n)
+ {
+ 	struct device *dev = container_of(kobj, typeof(*dev), kobj);
+ 
+ 	if (a == &dev_attr_numa_node.attr &&
+ 			dev_to_node(dev) == NUMA_NO_NODE)
+ 		return 0;
+ 
+ 	return a->mode;
+ }
+ 
+ static struct attribute_group platform_dev_group = {
+ 	.attrs = platform_dev_attrs,
+ 	.is_visible = platform_dev_attrs_visible,
+ };
+ __ATTRIBUTE_GROUPS(platform_dev);
+ 
+ 
+ /**
+  * platform_match - bind platform device to platform driver.
+  * @dev: device.
+  * @drv: driver.
+  *
+  * Platform device IDs are assumed to be encoded like this:
+  * "<name><instance>", where <name> is a short description of the type of
+  * device, like "pci" or "floppy", and <instance> is the enumerated
+  * instance of the device, like '0' or '42'.  Driver IDs are simply
+  * "<name>".  So, extract the <name> from the platform_device structure,
+  * and compare it against the name of the driver. Return whether they match
+  * or not.
+  */
+ static int platform_match(struct device *dev, struct device_driver *drv)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+ 	struct platform_driver *pdrv = to_platform_driver(drv);
+ 
+ 	/* When driver_override is set, only bind to the matching driver */
+ 	if (pdev->driver_override)
+ 		return !strcmp(pdev->driver_override, drv->name);
+ 
+ 	/* Attempt an OF style match first */
+ 	if (of_driver_match_device(dev, drv))
+ 		return 1;
+ 
+ 	/* Then try ACPI style match */
+ 	if (acpi_driver_match_device(dev, drv))
+ 		return 1;
+ 
+ 	/* Then try to match against the id table */
+ 	if (pdrv->id_table)
+ 		return platform_match_id(pdrv->id_table, pdev) != NULL;
+ 
+ 	/* fall-back to driver name match */
+ 	return (strcmp(pdev->name, drv->name) == 0);
+ }
+ 
+ static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
+ {
+ 	struct platform_device	*pdev = to_platform_device(dev);
+ 	int rc;
+ 
+ 	/* Some devices have extra OF data and an OF-style MODALIAS */
+ 	rc = of_device_uevent_modalias(dev, env);
+ 	if (rc != -ENODEV)
+ 		return rc;
+ 
+ 	rc = acpi_device_uevent_modalias(dev, env);
+ 	if (rc != -ENODEV)
+ 		return rc;
+ 
+ 	add_uevent_var(env, "MODALIAS=%s%s", PLATFORM_MODULE_PREFIX,
+ 			pdev->name);
+ 	return 0;
+ }
+ 
+ static int platform_probe(struct device *_dev)
+ {
+ 	struct platform_driver *drv = to_platform_driver(_dev->driver);
+ 	struct platform_device *dev = to_platform_device(_dev);
+ 	int ret;
+ 
+ 	/*
+ 	 * A driver registered using platform_driver_probe() cannot be bound
+ 	 * again later because the probe function usually lives in __init code
+ 	 * and so is gone. For these drivers .probe is set to
+ 	 * platform_probe_fail in __platform_driver_probe(). Don't even prepare
+ 	 * clocks and PM domains for these to match the traditional behaviour.
+ 	 */
+ 	if (unlikely(drv->probe == platform_probe_fail))
+ 		return -ENXIO;
+ 
+ 	ret = of_clk_set_defaults(_dev->of_node, false);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ret = dev_pm_domain_attach(_dev, true);
+ 	if (ret)
+ 		goto out;
+ 
+ 	if (drv->probe) {
+ 		ret = drv->probe(dev);
+ 		if (ret)
+ 			dev_pm_domain_detach(_dev, true);
+ 	}
+ 
+ out:
+ 	if (drv->prevent_deferred_probe && ret == -EPROBE_DEFER) {
+ 		dev_warn(_dev, "probe deferral not supported\n");
+ 		ret = -ENXIO;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int platform_remove(struct device *_dev)
+ {
+ 	struct platform_driver *drv = to_platform_driver(_dev->driver);
+ 	struct platform_device *dev = to_platform_device(_dev);
+ 	int ret = 0;
+ 
+ 	if (drv->remove)
+ 		ret = drv->remove(dev);
+ 	dev_pm_domain_detach(_dev, true);
+ 
+ 	return ret;
+ }
+ 
+ static void platform_shutdown(struct device *_dev)
+ {
+ 	struct platform_device *dev = to_platform_device(_dev);
+ 	struct platform_driver *drv;
+ 
+ 	if (!_dev->driver)
+ 		return;
+ 
+ 	drv = to_platform_driver(_dev->driver);
+ 	if (drv->shutdown)
+ 		drv->shutdown(dev);
+ }
+ 
+ 
++>>>>>>> 46e85af0cc53 (driver core: platform: don't oops in platform_shutdown() on unbound devices)
  int platform_dma_configure(struct device *dev)
  {
  	enum dev_dma_attr attr;
* Unmerged path drivers/base/platform.c
