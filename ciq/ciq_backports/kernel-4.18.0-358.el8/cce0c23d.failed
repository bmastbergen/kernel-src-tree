KVM: selftests: Add wrapper to allocate page table page

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Sean Christopherson <seanjc@google.com>
commit cce0c23dd944068d7f07a03938d5b3cbcdaf4148
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/cce0c23d.failed

Add a helper to allocate a page for use in constructing the guest's page
tables.  All architectures have identical address and memslot
requirements (which appear to be arbitrary anyways).

No functional change intended.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20210622200529.3650424-15-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit cce0c23dd944068d7f07a03938d5b3cbcdaf4148)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/lib/aarch64/processor.c
#	tools/testing/selftests/kvm/lib/x86_64/processor.c
diff --cc tools/testing/selftests/kvm/lib/aarch64/processor.c
index 48b55c93f858,ad465ca16237..000000000000
--- a/tools/testing/selftests/kvm/lib/aarch64/processor.c
+++ b/tools/testing/selftests/kvm/lib/aarch64/processor.c
@@@ -12,11 -11,8 +12,10 @@@
  #include "../kvm_util_internal.h"
  #include "processor.h"
  
- #define KVM_GUEST_PAGE_TABLE_MIN_PADDR		0x180000
  #define DEFAULT_ARM64_GUEST_STACK_VADDR_MIN	0xac0000
  
 +static vm_vaddr_t exception_handlers;
 +
  static uint64_t page_align(struct kvm_vm *vm, uint64_t v)
  {
  	return (v + vm->page_size) & ~(vm->page_size - 1);
@@@ -107,25 -103,19 +106,40 @@@ void _virt_pg_map(struct kvm_vm *vm, ui
  		paddr, vm->max_gfn, vm->page_size);
  
  	ptep = addr_gpa2hva(vm, vm->pgd) + pgd_index(vm, vaddr) * 8;
++<<<<<<< HEAD
 +	if (!*ptep) {
 +		*ptep = vm_phy_page_alloc(vm, KVM_GUEST_PAGE_TABLE_MIN_PADDR, pgd_memslot);
 +		*ptep |= 3;
 +	}
++=======
+ 	if (!*ptep)
+ 		*ptep = vm_alloc_page_table(vm) | 3;
++>>>>>>> cce0c23dd944 (KVM: selftests: Add wrapper to allocate page table page)
  
  	switch (vm->pgtable_levels) {
  	case 4:
  		ptep = addr_gpa2hva(vm, pte_addr(vm, *ptep)) + pud_index(vm, vaddr) * 8;
++<<<<<<< HEAD
 +		if (!*ptep) {
 +			*ptep = vm_phy_page_alloc(vm, KVM_GUEST_PAGE_TABLE_MIN_PADDR, pgd_memslot);
 +			*ptep |= 3;
 +		}
 +		/* fall through */
 +	case 3:
 +		ptep = addr_gpa2hva(vm, pte_addr(vm, *ptep)) + pmd_index(vm, vaddr) * 8;
 +		if (!*ptep) {
 +			*ptep = vm_phy_page_alloc(vm, KVM_GUEST_PAGE_TABLE_MIN_PADDR, pgd_memslot);
 +			*ptep |= 3;
 +		}
++=======
+ 		if (!*ptep)
+ 			*ptep = vm_alloc_page_table(vm) | 3;
+ 		/* fall through */
+ 	case 3:
+ 		ptep = addr_gpa2hva(vm, pte_addr(vm, *ptep)) + pmd_index(vm, vaddr) * 8;
+ 		if (!*ptep)
+ 			*ptep = vm_alloc_page_table(vm) | 3;
++>>>>>>> cce0c23dd944 (KVM: selftests: Add wrapper to allocate page table page)
  		/* fall through */
  	case 2:
  		ptep = addr_gpa2hva(vm, pte_addr(vm, *ptep)) + pte_index(vm, vaddr) * 8;
diff --cc tools/testing/selftests/kvm/lib/x86_64/processor.c
index 4e80df28f873,f96a6221e798..000000000000
--- a/tools/testing/selftests/kvm/lib/x86_64/processor.c
+++ b/tools/testing/selftests/kvm/lib/x86_64/processor.c
@@@ -214,9 -211,7 +211,13 @@@ void virt_pgd_alloc(struct kvm_vm *vm, 
  
  	/* If needed, create page map l4 table. */
  	if (!vm->pgd_created) {
++<<<<<<< HEAD
 +		vm_paddr_t paddr = vm_phy_page_alloc(vm,
 +			KVM_GUEST_PAGE_TABLE_MIN_PADDR, pgd_memslot);
 +		vm->pgd = paddr;
++=======
+ 		vm->pgd = vm_alloc_page_table(vm);
++>>>>>>> cce0c23dd944 (KVM: selftests: Add wrapper to allocate page table page)
  		vm->pgd_created = true;
  	}
  }
@@@ -255,9 -249,7 +256,13 @@@ void virt_pg_map(struct kvm_vm *vm, uin
  	/* Allocate page directory pointer table if not present. */
  	pml4e = addr_gpa2hva(vm, vm->pgd);
  	if (!pml4e[index[3]].present) {
++<<<<<<< HEAD
 +		pml4e[index[3]].address = vm_phy_page_alloc(vm,
 +			KVM_GUEST_PAGE_TABLE_MIN_PADDR, pgd_memslot)
 +			>> vm->page_shift;
++=======
+ 		pml4e[index[3]].address = vm_alloc_page_table(vm) >> vm->page_shift;
++>>>>>>> cce0c23dd944 (KVM: selftests: Add wrapper to allocate page table page)
  		pml4e[index[3]].writable = true;
  		pml4e[index[3]].present = true;
  	}
@@@ -266,9 -258,7 +271,13 @@@
  	struct pageDirectoryPointerEntry *pdpe;
  	pdpe = addr_gpa2hva(vm, pml4e[index[3]].address * vm->page_size);
  	if (!pdpe[index[2]].present) {
++<<<<<<< HEAD
 +		pdpe[index[2]].address = vm_phy_page_alloc(vm,
 +			KVM_GUEST_PAGE_TABLE_MIN_PADDR, pgd_memslot)
 +			>> vm->page_shift;
++=======
+ 		pdpe[index[2]].address = vm_alloc_page_table(vm) >> vm->page_shift;
++>>>>>>> cce0c23dd944 (KVM: selftests: Add wrapper to allocate page table page)
  		pdpe[index[2]].writable = true;
  		pdpe[index[2]].present = true;
  	}
@@@ -277,9 -267,7 +286,13 @@@
  	struct pageDirectoryEntry *pde;
  	pde = addr_gpa2hva(vm, pdpe[index[2]].address * vm->page_size);
  	if (!pde[index[1]].present) {
++<<<<<<< HEAD
 +		pde[index[1]].address = vm_phy_page_alloc(vm,
 +			KVM_GUEST_PAGE_TABLE_MIN_PADDR, pgd_memslot)
 +			>> vm->page_shift;
++=======
+ 		pde[index[1]].address = vm_alloc_page_table(vm) >> vm->page_shift;
++>>>>>>> cce0c23dd944 (KVM: selftests: Add wrapper to allocate page table page)
  		pde[index[1]].writable = true;
  		pde[index[1]].present = true;
  	}
diff --git a/tools/testing/selftests/kvm/include/kvm_util.h b/tools/testing/selftests/kvm/include/kvm_util.h
index af80e938320d..acb7fed98ec8 100644
--- a/tools/testing/selftests/kvm/include/kvm_util.h
+++ b/tools/testing/selftests/kvm/include/kvm_util.h
@@ -30,6 +30,7 @@ typedef uint64_t vm_vaddr_t; /* Virtual Machine (Guest) virtual address */
 
 /* Minimum allocated guest virtual and physical addresses */
 #define KVM_UTIL_MIN_VADDR		0x2000
+#define KVM_GUEST_PAGE_TABLE_MIN_PADDR	0x180000
 
 #define DEFAULT_GUEST_PHY_PAGES		512
 #define DEFAULT_GUEST_STACK_VADDR_MIN	0xab6000
@@ -260,6 +261,7 @@ vm_paddr_t vm_phy_page_alloc(struct kvm_vm *vm, vm_paddr_t paddr_min,
 			     uint32_t memslot);
 vm_paddr_t vm_phy_pages_alloc(struct kvm_vm *vm, size_t num,
 			      vm_paddr_t paddr_min, uint32_t memslot);
+vm_paddr_t vm_alloc_page_table(struct kvm_vm *vm);
 
 /*
  * Create a VM with reasonable defaults
* Unmerged path tools/testing/selftests/kvm/lib/aarch64/processor.c
diff --git a/tools/testing/selftests/kvm/lib/kvm_util.c b/tools/testing/selftests/kvm/lib/kvm_util.c
index 6e1f9b382aee..aeecac2ab94a 100644
--- a/tools/testing/selftests/kvm/lib/kvm_util.c
+++ b/tools/testing/selftests/kvm/lib/kvm_util.c
@@ -2134,6 +2134,14 @@ vm_paddr_t vm_phy_page_alloc(struct kvm_vm *vm, vm_paddr_t paddr_min,
 	return vm_phy_pages_alloc(vm, 1, paddr_min, memslot);
 }
 
+/* Arbitrary minimum physical address used for virtual translation tables. */
+#define KVM_GUEST_PAGE_TABLE_MIN_PADDR 0x180000
+
+vm_paddr_t vm_alloc_page_table(struct kvm_vm *vm)
+{
+	return vm_phy_page_alloc(vm, KVM_GUEST_PAGE_TABLE_MIN_PADDR, 0);
+}
+
 /*
  * Address Guest Virtual to Host Virtual
  *
diff --git a/tools/testing/selftests/kvm/lib/s390x/processor.c b/tools/testing/selftests/kvm/lib/s390x/processor.c
index 0152f356c099..3e95556099cd 100644
--- a/tools/testing/selftests/kvm/lib/s390x/processor.c
+++ b/tools/testing/selftests/kvm/lib/s390x/processor.c
@@ -9,8 +9,6 @@
 #include "kvm_util.h"
 #include "../kvm_util_internal.h"
 
-#define KVM_GUEST_PAGE_TABLE_MIN_PADDR		0x180000
-
 #define PAGES_PER_REGION 4
 
 void virt_pgd_alloc(struct kvm_vm *vm, uint32_t memslot)
* Unmerged path tools/testing/selftests/kvm/lib/x86_64/processor.c
diff --git a/tools/testing/selftests/kvm/lib/x86_64/vmx.c b/tools/testing/selftests/kvm/lib/x86_64/vmx.c
index cdf22f6bf127..1ce80b7b53df 100644
--- a/tools/testing/selftests/kvm/lib/x86_64/vmx.c
+++ b/tools/testing/selftests/kvm/lib/x86_64/vmx.c
@@ -428,9 +428,7 @@ void nested_pg_map(struct vmx_pages *vmx, struct kvm_vm *vm,
 	/* Allocate page directory pointer table if not present. */
 	pml4e = vmx->eptp_hva;
 	if (!pml4e[index[3]].readable) {
-		pml4e[index[3]].address = vm_phy_page_alloc(vm,
-			  KVM_EPT_PAGE_TABLE_MIN_PADDR, 0)
-			>> vm->page_shift;
+		pml4e[index[3]].address = vm_alloc_page_table(vm) >> vm->page_shift;
 		pml4e[index[3]].writable = true;
 		pml4e[index[3]].readable = true;
 		pml4e[index[3]].executable = true;
@@ -440,9 +438,7 @@ void nested_pg_map(struct vmx_pages *vmx, struct kvm_vm *vm,
 	struct eptPageTableEntry *pdpe;
 	pdpe = addr_gpa2hva(vm, pml4e[index[3]].address * vm->page_size);
 	if (!pdpe[index[2]].readable) {
-		pdpe[index[2]].address = vm_phy_page_alloc(vm,
-			  KVM_EPT_PAGE_TABLE_MIN_PADDR, 0)
-			>> vm->page_shift;
+		pdpe[index[2]].address = vm_alloc_page_table(vm) >> vm->page_shift;
 		pdpe[index[2]].writable = true;
 		pdpe[index[2]].readable = true;
 		pdpe[index[2]].executable = true;
@@ -452,9 +448,7 @@ void nested_pg_map(struct vmx_pages *vmx, struct kvm_vm *vm,
 	struct eptPageTableEntry *pde;
 	pde = addr_gpa2hva(vm, pdpe[index[2]].address * vm->page_size);
 	if (!pde[index[1]].readable) {
-		pde[index[1]].address = vm_phy_page_alloc(vm,
-			  KVM_EPT_PAGE_TABLE_MIN_PADDR, 0)
-			>> vm->page_shift;
+		pde[index[1]].address = vm_alloc_page_table(vm) >> vm->page_shift;
 		pde[index[1]].writable = true;
 		pde[index[1]].readable = true;
 		pde[index[1]].executable = true;
