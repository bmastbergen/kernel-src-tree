bridge: mrp: Use hlist_head instead of list_head for mrp

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Horatiu Vultur <horatiu.vultur@microchip.com>
commit 0169b8205431589b945c29a576c65f2037a5bc26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/0169b820.failed

Replace list_head with hlist_head for MRP list under the bridge.
There is no need for a circular list when a linear list will work.
This will also decrease the size of 'struct net_bridge'.

	Signed-off-by: Horatiu Vultur <horatiu.vultur@microchip.com>
Link: https://lore.kernel.org/r/20201106215049.1448185-1-horatiu.vultur@microchip.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 0169b8205431589b945c29a576c65f2037a5bc26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_mrp.c
#	net/bridge/br_private.h
#	net/bridge/br_private_mrp.h
diff --cc net/bridge/br_mrp.c
index d673550412b4,bb12fbf9aaf2..000000000000
--- a/net/bridge/br_mrp.c
+++ b/net/bridge/br_mrp.c
@@@ -37,6 -65,22 +37,25 @@@ static struct br_mrp *br_mrp_find_id(st
  	return res;
  }
  
++<<<<<<< HEAD
++=======
+ static struct br_mrp *br_mrp_find_in_id(struct net_bridge *br, u32 in_id)
+ {
+ 	struct br_mrp *res = NULL;
+ 	struct br_mrp *mrp;
+ 
+ 	hlist_for_each_entry_rcu(mrp, &br->mrp_list, list,
+ 				 lockdep_rtnl_is_held()) {
+ 		if (mrp->in_id == in_id) {
+ 			res = mrp;
+ 			break;
+ 		}
+ 	}
+ 
+ 	return res;
+ }
+ 
++>>>>>>> 0169b8205431 (bridge: mrp: Use hlist_head instead of list_head for mrp)
  static bool br_mrp_unique_ifindex(struct net_bridge *br, u32 ifindex)
  {
  	struct br_mrp *mrp;
@@@ -63,10 -111,11 +82,10 @@@ static struct br_mrp *br_mrp_find_port(
  	struct br_mrp *res = NULL;
  	struct br_mrp *mrp;
  
- 	list_for_each_entry_rcu(mrp, &br->mrp_list, list,
- 				lockdep_rtnl_is_held()) {
+ 	hlist_for_each_entry_rcu(mrp, &br->mrp_list, list,
+ 				 lockdep_rtnl_is_held()) {
  		if (rcu_access_pointer(mrp->p_port) == p ||
 -		    rcu_access_pointer(mrp->s_port) == p ||
 -		    rcu_access_pointer(mrp->i_port) == p) {
 +		    rcu_access_pointer(mrp->s_port) == p) {
  			res = mrp;
  			break;
  		}
@@@ -256,8 -438,23 +275,28 @@@ static void br_mrp_del_impl(struct net_
  		rcu_assign_pointer(mrp->s_port, NULL);
  	}
  
++<<<<<<< HEAD
 +	list_del_rcu(&mrp->list);
 +	kfree_rcu(mrp, rcu);
++=======
+ 	p = rtnl_dereference(mrp->i_port);
+ 	if (p) {
+ 		spin_lock_bh(&br->lock);
+ 		state = netif_running(br->dev) ?
+ 				BR_STATE_FORWARDING : BR_STATE_DISABLED;
+ 		p->state = state;
+ 		p->flags &= ~BR_MRP_AWARE;
+ 		spin_unlock_bh(&br->lock);
+ 		br_mrp_port_switchdev_set_state(p, state);
+ 		rcu_assign_pointer(mrp->i_port, NULL);
+ 	}
+ 
+ 	hlist_del_rcu(&mrp->list);
+ 	kfree_rcu(mrp, rcu);
+ 
+ 	if (hlist_empty(&br->mrp_list))
+ 		br_del_frame(br, &mrp_frame_type);
++>>>>>>> 0169b8205431 (bridge: mrp: Use hlist_head instead of list_head for mrp)
  }
  
  /* Adds a new MRP instance.
@@@ -305,8 -503,12 +344,17 @@@ int br_mrp_add(struct net_bridge *br, s
  	spin_unlock_bh(&br->lock);
  	rcu_assign_pointer(mrp->s_port, p);
  
++<<<<<<< HEAD
 +	INIT_DELAYED_WORK(&mrp->test_work, br_mrp_test_work_expired);
 +	list_add_tail_rcu(&mrp->list, &br->mrp_list);
++=======
+ 	if (hlist_empty(&br->mrp_list))
+ 		br_add_frame(br, &mrp_frame_type);
+ 
+ 	INIT_DELAYED_WORK(&mrp->test_work, br_mrp_test_work_expired);
+ 	INIT_DELAYED_WORK(&mrp->in_test_work, br_mrp_in_test_work_expired);
+ 	hlist_add_tail_rcu(&mrp->list, &br->mrp_list);
++>>>>>>> 0169b8205431 (bridge: mrp: Use hlist_head instead of list_head for mrp)
  
  	err = br_mrp_switchdev_add(br, mrp);
  	if (err)
diff --cc net/bridge/br_private.h
index 9a712c7e69b8,6f2818cb2ac0..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -470,7 -482,7 +470,11 @@@ struct net_bridge 
  	struct hlist_head		fdb_list;
  
  #if IS_ENABLED(CONFIG_BRIDGE_MRP)
++<<<<<<< HEAD
 +	struct list_head		__rcu mrp_list;
++=======
+ 	struct hlist_head		mrp_list;
++>>>>>>> 0169b8205431 (bridge: mrp: Use hlist_head instead of list_head for mrp)
  #endif
  #if IS_ENABLED(CONFIG_BRIDGE_CFM)
  	struct hlist_head		mep_list;
diff --cc net/bridge/br_private_mrp.h
index ab744ac18d94,1883118aae55..000000000000
--- a/net/bridge/br_private_mrp.h
+++ b/net/bridge/br_private_mrp.h
@@@ -8,7 -8,7 +8,11 @@@
  
  struct br_mrp {
  	/* list of mrp instances */
++<<<<<<< HEAD
 +	struct list_head		__rcu list;
++=======
+ 	struct hlist_node		list;
++>>>>>>> 0169b8205431 (bridge: mrp: Use hlist_head instead of list_head for mrp)
  
  	struct net_bridge_port __rcu	*p_port;
  	struct net_bridge_port __rcu	*s_port;
diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c
index d13e4408d749..66182e5dbc66 100644
--- a/net/bridge/br_device.c
+++ b/net/bridge/br_device.c
@@ -459,7 +459,7 @@ void br_dev_setup(struct net_device *dev)
 	INIT_LIST_HEAD(&br->port_list);
 	INIT_HLIST_HEAD(&br->fdb_list);
 #if IS_ENABLED(CONFIG_BRIDGE_MRP)
-	INIT_LIST_HEAD(&br->mrp_list);
+	INIT_HLIST_HEAD(&br->mrp_list);
 #endif
 #if IS_ENABLED(CONFIG_BRIDGE_CFM)
 	INIT_HLIST_HEAD(&br->mep_list);
* Unmerged path net/bridge/br_mrp.c
diff --git a/net/bridge/br_mrp_netlink.c b/net/bridge/br_mrp_netlink.c
index ad4ae5b8289b..286e7571dc4a 100644
--- a/net/bridge/br_mrp_netlink.c
+++ b/net/bridge/br_mrp_netlink.c
@@ -442,7 +442,7 @@ int br_mrp_fill_info(struct sk_buff *skb, struct net_bridge *br)
 	if (!mrp_tb)
 		return -EMSGSIZE;
 
-	list_for_each_entry_rcu(mrp, &br->mrp_list, list) {
+	hlist_for_each_entry_rcu(mrp, &br->mrp_list, list) {
 		struct net_bridge_port *p;
 
 		tb = nla_nest_start_noflag(skb, IFLA_BRIDGE_MRP_INFO);
* Unmerged path net/bridge/br_private.h
* Unmerged path net/bridge/br_private_mrp.h
