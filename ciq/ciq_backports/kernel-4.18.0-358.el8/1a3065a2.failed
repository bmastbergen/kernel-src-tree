net: bridge: mcast: prepare is-router function for mcast router split

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Linus Lüssing <linus.luessing@c0d3.blue>
commit 1a3065a26807b4cdd65d3b696ddb18385610f7da
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/1a3065a2.failed

In preparation for the upcoming split of multicast router state into
their IPv4 and IPv6 variants make br_multicast_is_router() protocol
family aware.

Note that for now br_ip6_multicast_is_router() uses the currently still
common ip4_mc_router_timer for now. It will be renamed to
ip6_mc_router_timer later when the split is performed.

While at it also renames the "1" and "2" constants in
br_multicast_is_router() to the MDB_RTR_TYPE_TEMP_QUERY and
MDB_RTR_TYPE_PERM enums.

	Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1a3065a26807b4cdd65d3b696ddb18385610f7da)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
#	net/bridge/br_private.h
diff --cc net/bridge/br_multicast.c
index 2827c70f9d21,048b5b9e9c89..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -984,7 -1391,8 +984,12 @@@ static void br_multicast_local_router_e
  	spin_lock(&br->multicast_lock);
  	if (br->multicast_router == MDB_RTR_TYPE_DISABLED ||
  	    br->multicast_router == MDB_RTR_TYPE_PERM ||
++<<<<<<< HEAD
 +	    timer_pending(&br->multicast_router_timer))
++=======
+ 	    br_ip4_multicast_is_router(br) ||
+ 	    br_ip6_multicast_is_router(br))
++>>>>>>> 1a3065a26807 (net: bridge: mcast: prepare is-router function for mcast router split)
  		goto out;
  
  	br_mc_router_state_change(br, false);
diff --cc net/bridge/br_private.h
index 336f9152b211,f9a381fcff09..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -758,11 -864,50 +758,58 @@@ void br_multicast_host_leave(struct net
  #define mlock_dereference(X, br) \
  	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
  
++<<<<<<< HEAD
 +static inline bool br_multicast_is_router(struct net_bridge *br)
 +{
 +	return br->multicast_router == 2 ||
 +	       (br->multicast_router == 1 &&
 +		timer_pending(&br->multicast_router_timer));
++=======
+ static inline struct hlist_node *
+ br_multicast_get_first_rport_node(struct net_bridge *b, struct sk_buff *skb) {
+ 	return rcu_dereference(hlist_first_rcu(&b->ip4_mc_router_list));
+ }
+ 
+ static inline struct net_bridge_port *
+ br_multicast_rport_from_node_skb(struct hlist_node *rp, struct sk_buff *skb) {
+ 	return hlist_entry_safe(rp, struct net_bridge_port, ip4_rlist);
+ }
+ 
+ static inline bool br_ip4_multicast_is_router(struct net_bridge *br)
+ {
+ 	return timer_pending(&br->ip4_mc_router_timer);
+ }
+ 
+ static inline bool br_ip6_multicast_is_router(struct net_bridge *br)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	return timer_pending(&br->ip4_mc_router_timer);
+ #else
+ 	return false;
+ #endif
+ }
+ 
+ static inline bool
+ br_multicast_is_router(struct net_bridge *br, struct sk_buff *skb)
+ {
+ 	switch (br->multicast_router) {
+ 	case MDB_RTR_TYPE_PERM:
+ 		return true;
+ 	case MDB_RTR_TYPE_TEMP_QUERY:
+ 		if (skb) {
+ 			if (skb->protocol == htons(ETH_P_IP))
+ 				return br_ip4_multicast_is_router(br);
+ 			else if (skb->protocol == htons(ETH_P_IPV6))
+ 				return br_ip6_multicast_is_router(br);
+ 		} else {
+ 			return br_ip4_multicast_is_router(br) ||
+ 			       br_ip6_multicast_is_router(br);
+ 		}
+ 		fallthrough;
+ 	default:
+ 		return false;
+ 	}
++>>>>>>> 1a3065a26807 (net: bridge: mcast: prepare is-router function for mcast router split)
  }
  
  static inline bool
diff --git a/net/bridge/br_input.c b/net/bridge/br_input.c
index ab915be2b05a..bacfcd024607 100644
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@ -140,7 +140,7 @@ int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb
 		if ((mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) &&
 		    br_multicast_querier_exists(br, eth_hdr(skb))) {
 			if ((mdst && mdst->host_joined) ||
-			    br_multicast_is_router(br)) {
+			    br_multicast_is_router(br, skb)) {
 				local_rcv = true;
 				br->dev->stats.multicast++;
 			}
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_private.h
