selftests: xsk: Remove thread attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Björn Töpel <bjorn.topel@intel.com>
commit 7651910257c8fb1ec76b50bef0330fcf739105c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/76519102.failed

There is really no reason to have a non-default thread stack
size. Remove that.

	Signed-off-by: Björn Töpel <bjorn.topel@intel.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20210329224316.17793-16-maciej.fijalkowski@intel.com
(cherry picked from commit 7651910257c8fb1ec76b50bef0330fcf739105c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/xdpxceiver.c
#	tools/testing/selftests/bpf/xdpxceiver.h
diff --cc tools/testing/selftests/bpf/xdpxceiver.c
index 9f8d5dabf30a,ec09b8fe1178..000000000000
--- a/tools/testing/selftests/bpf/xdpxceiver.c
+++ b/tools/testing/selftests/bpf/xdpxceiver.c
@@@ -763,8 -763,20 +763,24 @@@ static void thread_common_ops(struct if
  	int ctr = 0;
  	int ret;
  
++<<<<<<< HEAD
 +	xsk_configure_umem(ifobject, bufs, num_frames * XSK_UMEM__DEFAULT_FRAME_SIZE);
 +	ret = xsk_configure_socket(ifobject);
++=======
+ 	ifobject->ns_fd = switch_namespace(ifobject->nsname);
+ 
+ 	if (test_type == TEST_TYPE_BPF_RES)
+ 		umem_sz *= 2;
+ 
+ 	bufs = mmap(NULL, umem_sz,
+ 		    PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+ 	if (bufs == MAP_FAILED)
+ 		exit_with_error(errno);
+ 
+ 	xsk_configure_umem(ifobject, bufs, 0);
+ 	ifobject->umem = ifobject->umem_arr[0];
+ 	ret = xsk_configure_socket(ifobject, 0);
++>>>>>>> 7651910257c8 (selftests: xsk: Remove thread attribute)
  
  	/* Retry Create Socket if it fails as xsk_socket__create()
  	 * is asynchronous
@@@ -891,30 -904,13 +907,37 @@@ static void *worker_testapp_validate(vo
  static void testapp_validate(void)
  {
  	struct timespec max_wait = { 0, 0 };
 -	bool bidi = test_type == TEST_TYPE_BIDI;
 -	bool bpf = test_type == TEST_TYPE_BPF_RES;
  
++<<<<<<< HEAD
 +	pthread_attr_init(&attr);
 +	pthread_attr_setstacksize(&attr, THREAD_STACK);
 +
 +	if (opt_bidi && bidi_pass) {
 +		pthread_init_mutex();
 +		if (!switching_notify) {
 +			print_verbose("Switching Tx/Rx vectors\n");
 +			switching_notify++;
 +		}
 +	}
 +
 +	pthread_mutex_lock(&sync_mutex);
 +
 +	/*Spawn RX thread */
 +	if (!opt_bidi || !bidi_pass) {
 +		if (pthread_create(&t0, &attr, worker_testapp_validate, ifdict[1]))
 +			exit_with_error(errno);
 +	} else if (opt_bidi && bidi_pass) {
 +		/*switch Tx/Rx vectors */
 +		ifdict[0]->fv.vector = rx;
 +		if (pthread_create(&t0, &attr, worker_testapp_validate, ifdict[0]))
 +			exit_with_error(errno);
 +	}
++=======
+ 	pthread_mutex_lock(&sync_mutex);
+ 
+ 	/*Spawn RX thread */
+ 	pthread_create(&t0, NULL, ifdict_rx->func_ptr, ifdict_rx);
++>>>>>>> 7651910257c8 (selftests: xsk: Remove thread attribute)
  
  	if (clock_gettime(CLOCK_REALTIME, &max_wait))
  		exit_with_error(errno);
@@@ -926,15 -922,7 +949,19 @@@
  	pthread_mutex_unlock(&sync_mutex);
  
  	/*Spawn TX thread */
++<<<<<<< HEAD
 +	if (!opt_bidi || !bidi_pass) {
 +		if (pthread_create(&t1, &attr, worker_testapp_validate, ifdict[0]))
 +			exit_with_error(errno);
 +	} else if (opt_bidi && bidi_pass) {
 +		/*switch Tx/Rx vectors */
 +		ifdict[1]->fv.vector = tx;
 +		if (pthread_create(&t1, &attr, worker_testapp_validate, ifdict[1]))
 +			exit_with_error(errno);
 +	}
++=======
+ 	pthread_create(&t1, NULL, ifdict_tx->func_ptr, ifdict_tx);
++>>>>>>> 7651910257c8 (selftests: xsk: Remove thread attribute)
  
  	pthread_join(t1, NULL);
  	pthread_join(t0, NULL);
diff --cc tools/testing/selftests/bpf/xdpxceiver.h
index f66f399dfb2d,78863820fb81..000000000000
--- a/tools/testing/selftests/bpf/xdpxceiver.h
+++ b/tools/testing/selftests/bpf/xdpxceiver.h
@@@ -128,21 -142,15 +127,25 @@@ struct ifobject 
  };
  
  static struct ifobject *ifdict[MAX_INTERFACES];
 -static struct ifobject *ifdict_rx;
 -static struct ifobject *ifdict_tx;
  
  /*threads*/
 +atomic_int spinning_tx;
 +atomic_int spinning_rx;
  pthread_mutex_t sync_mutex;
 +pthread_mutex_t sync_mutex_tx;
  pthread_cond_t signal_rx_condition;
++<<<<<<< HEAD
 +pthread_cond_t signal_tx_condition;
 +pthread_t t0, t1, ns_thread;
 +pthread_attr_t attr;
++=======
+ pthread_t t0, t1;
++>>>>>>> 7651910257c8 (selftests: xsk: Remove thread attribute)
 +
 +struct targs {
 +	bool retptr;
 +	int idx;
 +};
  
  TAILQ_HEAD(head_s, pkt) head = TAILQ_HEAD_INITIALIZER(head);
  struct head_s *head_p;
* Unmerged path tools/testing/selftests/bpf/xdpxceiver.c
* Unmerged path tools/testing/selftests/bpf/xdpxceiver.h
