RDMA/hfi1: Use attributes for the port sysfs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Jason Gunthorpe <jgg@nvidia.com>
commit 8f1708f19f919135a5d7eddcdccc15b7fd7d524d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/8f1708f1.failed

hfi1 should not be creating a mess of kobjects to attach to the port
kobject - this is all attributes. The proper API is to create an
attribute_group list and create it against the port's kobject.

Link: https://lore.kernel.org/r/cbe0ccb6175dd22274359b6ad803a37435a70e91.1623427137.git.leonro@nvidia.com
	Tested-by: Mike Marciniszyn <mike.marciniszyn@cornelisnetworks.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 8f1708f19f919135a5d7eddcdccc15b7fd7d524d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/sysfs.c
diff --cc drivers/infiniband/hw/hfi1/sysfs.c
index 074ec71772d2,98bb0b3aac09..000000000000
--- a/drivers/infiniband/hw/hfi1/sysfs.c
+++ b/drivers/infiniband/hw/hfi1/sysfs.c
@@@ -136,27 -134,30 +134,34 @@@ static ssize_t cc_setting_bin_read(stru
  
  	return count;
  }
+ static BIN_ATTR_RO(cc_setting_bin, PAGE_SIZE);
  
- static const struct bin_attribute cc_setting_bin_attr = {
- 	.attr = {.name = "cc_settings_bin", .mode = 0444},
- 	.read = read_cc_setting_bin,
- 	.size = PAGE_SIZE,
- };
- 
- struct hfi1_port_attr {
- 	struct attribute attr;
- 	ssize_t	(*show)(struct hfi1_pportdata *, char *);
- 	ssize_t	(*store)(struct hfi1_pportdata *, const char *, size_t);
+ static struct bin_attribute *port_cc_bin_attributes[] = {
+ 	&bin_attr_cc_setting_bin,
+ 	&bin_attr_cc_table_bin,
+ 	NULL
  };
  
- static ssize_t cc_prescan_show(struct hfi1_pportdata *ppd, char *buf)
+ static ssize_t cc_prescan_show(struct ib_device *ibdev, u32 port_num,
+ 			       struct ib_port_attribute *attr, char *buf)
  {
++<<<<<<< HEAD
 +	return sprintf(buf, "%s\n", ppd->cc_prescan ? "on" : "off");
++=======
+ 	struct hfi1_devdata *dd = dd_from_ibdev(ibdev);
+ 	struct hfi1_pportdata *ppd = &dd->pport[port_num - 1];
+ 
+ 	return sysfs_emit(buf, "%s\n", ppd->cc_prescan ? "on" : "off");
++>>>>>>> 8f1708f19f91 (RDMA/hfi1: Use attributes for the port sysfs)
  }
  
- static ssize_t cc_prescan_store(struct hfi1_pportdata *ppd, const char *buf,
+ static ssize_t cc_prescan_store(struct ib_device *ibdev, u32 port_num,
+ 				struct ib_port_attribute *attr, const char *buf,
  				size_t count)
  {
+ 	struct hfi1_devdata *dd = dd_from_ibdev(ibdev);
+ 	struct hfi1_pportdata *ppd = &dd->pport[port_num - 1];
+ 
  	if (!memcmp(buf, "on", 2))
  		ppd->cc_prescan = true;
  	else if (!memcmp(buf, "off", 3))
@@@ -287,28 -269,10 +273,27 @@@ static struct attribute *port_sc2vl_att
  	NULL
  };
  
++<<<<<<< HEAD
 +static ssize_t sc2vl_attr_show(struct kobject *kobj, struct attribute *attr,
 +			       char *buf)
 +{
 +	struct hfi1_sc2vl_attr *sattr =
 +		container_of(attr, struct hfi1_sc2vl_attr, attr);
 +	struct hfi1_pportdata *ppd =
 +		container_of(kobj, struct hfi1_pportdata, sc2vl_kobj);
 +	struct hfi1_devdata *dd = ppd->dd;
 +
 +	return sprintf(buf, "%u\n", *((u8 *)dd->sc2vl + sattr->sc));
 +}
 +
 +static const struct sysfs_ops hfi1_sc2vl_ops = {
 +	.show = sc2vl_attr_show,
++=======
+ static const struct attribute_group port_sc2vl_group = {
+ 	.name = "sc2vl",
+ 	.attrs = port_sc2vl_attributes,
++>>>>>>> 8f1708f19f91 (RDMA/hfi1: Use attributes for the port sysfs)
  };
- 
- static struct kobj_type hfi1_sc2vl_ktype = {
- 	.release = port_release,
- 	.sysfs_ops = &hfi1_sc2vl_ops,
- 	.default_attrs = sc2vl_default_attributes
- };
- 
  /* End sc2vl */
  
  /* Start sl2sc */
@@@ -392,26 -366,9 +387,32 @@@ static struct attribute *port_sl2sc_att
  	NULL
  };
  
++<<<<<<< HEAD
 +static ssize_t sl2sc_attr_show(struct kobject *kobj, struct attribute *attr,
 +			       char *buf)
 +{
 +	struct hfi1_sl2sc_attr *sattr =
 +		container_of(attr, struct hfi1_sl2sc_attr, attr);
 +	struct hfi1_pportdata *ppd =
 +		container_of(kobj, struct hfi1_pportdata, sl2sc_kobj);
 +	struct hfi1_ibport *ibp = &ppd->ibport_data;
 +
 +	return sprintf(buf, "%u\n", ibp->sl_to_sc[sattr->sl]);
 +}
 +
 +static const struct sysfs_ops hfi1_sl2sc_ops = {
 +	.show = sl2sc_attr_show,
 +};
 +
 +static struct kobj_type hfi1_sl2sc_ktype = {
 +	.release = port_release,
 +	.sysfs_ops = &hfi1_sl2sc_ops,
 +	.default_attrs = sl2sc_default_attributes
++=======
+ static const struct attribute_group port_sl2sc_group = {
+ 	.name = "sl2sc",
+ 	.attrs = port_sl2sc_attributes,
++>>>>>>> 8f1708f19f91 (RDMA/hfi1: Use attributes for the port sysfs)
  };
  
  /* End sl2sc */
@@@ -466,26 -433,9 +477,32 @@@ static struct attribute *port_vl2mtu_at
  	NULL
  };
  
++<<<<<<< HEAD
 +static ssize_t vl2mtu_attr_show(struct kobject *kobj, struct attribute *attr,
 +				char *buf)
 +{
 +	struct hfi1_vl2mtu_attr *vlattr =
 +		container_of(attr, struct hfi1_vl2mtu_attr, attr);
 +	struct hfi1_pportdata *ppd =
 +		container_of(kobj, struct hfi1_pportdata, vl2mtu_kobj);
 +	struct hfi1_devdata *dd = ppd->dd;
 +
 +	return sprintf(buf, "%u\n", dd->vld[vlattr->vl].mtu);
 +}
 +
 +static const struct sysfs_ops hfi1_vl2mtu_ops = {
 +	.show = vl2mtu_attr_show,
 +};
 +
 +static struct kobj_type hfi1_vl2mtu_ktype = {
 +	.release = port_release,
 +	.sysfs_ops = &hfi1_vl2mtu_ops,
 +	.default_attrs = vl2mtu_default_attributes
++=======
+ static const struct attribute_group port_vl2mtu_group = {
+ 	.name = "vl2mtu",
+ 	.attrs = port_vl2mtu_attributes,
++>>>>>>> 8f1708f19f91 (RDMA/hfi1: Use attributes for the port sysfs)
  };
  
  /* end of per-port file structures and support code */
@@@ -653,100 -599,18 +670,22 @@@ const struct attribute_group ib_hfi1_at
  	.attrs = hfi1_attributes,
  };
  
++<<<<<<< HEAD
 +int hfi1_create_port_files(struct ib_device *ibdev, u8 port_num,
++=======
+ static const struct attribute_group *hfi1_port_groups[] = {
+ 	&port_cc_group,
+ 	&port_sc2vl_group,
+ 	&port_sl2sc_group,
+ 	&port_vl2mtu_group,
+ 	NULL,
+ };
+ 
+ int hfi1_create_port_files(struct ib_device *ibdev, u32 port_num,
++>>>>>>> 8f1708f19f91 (RDMA/hfi1: Use attributes for the port sysfs)
  			   struct kobject *kobj)
  {
- 	struct hfi1_pportdata *ppd;
- 	struct hfi1_devdata *dd = dd_from_ibdev(ibdev);
- 	int ret;
- 
- 	if (!port_num || port_num > dd->num_pports) {
- 		dd_dev_err(dd,
- 			   "Skipping infiniband class with invalid port %u\n",
- 			   port_num);
- 		return -ENODEV;
- 	}
- 	ppd = &dd->pport[port_num - 1];
- 
- 	ret = kobject_init_and_add(&ppd->sc2vl_kobj, &hfi1_sc2vl_ktype, kobj,
- 				   "sc2vl");
- 	if (ret) {
- 		dd_dev_err(dd,
- 			   "Skipping sc2vl sysfs info, (err %d) port %u\n",
- 			   ret, port_num);
- 		/*
- 		 * Based on the documentation for kobject_init_and_add(), the
- 		 * caller should call kobject_put even if this call fails.
- 		 */
- 		goto bail_sc2vl;
- 	}
- 	kobject_uevent(&ppd->sc2vl_kobj, KOBJ_ADD);
- 
- 	ret = kobject_init_and_add(&ppd->sl2sc_kobj, &hfi1_sl2sc_ktype, kobj,
- 				   "sl2sc");
- 	if (ret) {
- 		dd_dev_err(dd,
- 			   "Skipping sl2sc sysfs info, (err %d) port %u\n",
- 			   ret, port_num);
- 		goto bail_sl2sc;
- 	}
- 	kobject_uevent(&ppd->sl2sc_kobj, KOBJ_ADD);
- 
- 	ret = kobject_init_and_add(&ppd->vl2mtu_kobj, &hfi1_vl2mtu_ktype, kobj,
- 				   "vl2mtu");
- 	if (ret) {
- 		dd_dev_err(dd,
- 			   "Skipping vl2mtu sysfs info, (err %d) port %u\n",
- 			   ret, port_num);
- 		goto bail_vl2mtu;
- 	}
- 	kobject_uevent(&ppd->vl2mtu_kobj, KOBJ_ADD);
- 
- 	ret = kobject_init_and_add(&ppd->pport_cc_kobj, &port_cc_ktype,
- 				   kobj, "CCMgtA");
- 	if (ret) {
- 		dd_dev_err(dd,
- 			   "Skipping Congestion Control sysfs info, (err %d) port %u\n",
- 			   ret, port_num);
- 		goto bail_cc;
- 	}
- 
- 	kobject_uevent(&ppd->pport_cc_kobj, KOBJ_ADD);
- 
- 	ret = sysfs_create_bin_file(&ppd->pport_cc_kobj, &cc_setting_bin_attr);
- 	if (ret) {
- 		dd_dev_err(dd,
- 			   "Skipping Congestion Control setting sysfs info, (err %d) port %u\n",
- 			   ret, port_num);
- 		goto bail_cc;
- 	}
- 
- 	ret = sysfs_create_bin_file(&ppd->pport_cc_kobj, &cc_table_bin_attr);
- 	if (ret) {
- 		dd_dev_err(dd,
- 			   "Skipping Congestion Control table sysfs info, (err %d) port %u\n",
- 			   ret, port_num);
- 		goto bail_cc_entry_bin;
- 	}
- 
- 	dd_dev_info(dd,
- 		    "Congestion Control Agent enabled for port %d\n",
- 		    port_num);
- 
- 	return 0;
- 
- bail_cc_entry_bin:
- 	sysfs_remove_bin_file(&ppd->pport_cc_kobj,
- 			      &cc_setting_bin_attr);
- bail_cc:
- 	kobject_put(&ppd->pport_cc_kobj);
- bail_vl2mtu:
- 	kobject_put(&ppd->vl2mtu_kobj);
- bail_sl2sc:
- 	kobject_put(&ppd->sl2sc_kobj);
- bail_sc2vl:
- 	kobject_put(&ppd->sc2vl_kobj);
- 	return ret;
+ 	return ib_port_sysfs_create_groups(ibdev, port_num, hfi1_port_groups);
  }
  
  struct sde_attribute {
diff --git a/drivers/infiniband/hw/hfi1/hfi.h b/drivers/infiniband/hw/hfi1/hfi.h
index 4aba6416147b..eca27b7ac0e3 100644
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@ -779,10 +779,6 @@ struct hfi1_pportdata {
 	struct hfi1_ibport ibport_data;
 
 	struct hfi1_devdata *dd;
-	struct kobject pport_cc_kobj;
-	struct kobject sc2vl_kobj;
-	struct kobject sl2sc_kobj;
-	struct kobject vl2mtu_kobj;
 
 	/* PHY support */
 	struct qsfp_data qsfp_info;
* Unmerged path drivers/infiniband/hw/hfi1/sysfs.c
