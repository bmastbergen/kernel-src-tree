net: bridge: vlan: convert mcast router global option to per-vlan entry

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 2796d846d74a18cc6563e96eff8bf28c5e06f912
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/2796d846.failed

The per-vlan router option controls the port/vlan and host vlan entries'
mcast router config. The global option controlled only the host vlan
config, but that is unnecessary and incosistent as it's not really a
global vlan option, but rather bridge option to control host router
config, so convert BRIDGE_VLANDB_GOPTS_MCAST_ROUTER to
BRIDGE_VLANDB_ENTRY_MCAST_ROUTER which can be used to control both host
vlan and port vlan mcast router config.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2796d846d74a18cc6563e96eff8bf28c5e06f912)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/if_bridge.h
#	net/bridge/br_multicast.c
#	net/bridge/br_private.h
#	net/bridge/br_vlan_options.c
diff --cc include/uapi/linux/if_bridge.h
index d643fa57361d,2711c3522010..000000000000
--- a/include/uapi/linux/if_bridge.h
+++ b/include/uapi/linux/if_bridge.h
@@@ -491,6 -549,21 +492,24 @@@ enum 
  	BRIDGE_VLANDB_GOPTS_UNSPEC,
  	BRIDGE_VLANDB_GOPTS_ID,
  	BRIDGE_VLANDB_GOPTS_RANGE,
++<<<<<<< HEAD
++=======
+ 	BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_PAD,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_ROUTER_PORTS,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_STATE,
++>>>>>>> 2796d846d74a (net: bridge: vlan: convert mcast router global option to per-vlan entry)
  	__BRIDGE_VLANDB_GOPTS_MAX
  };
  #define BRIDGE_VLANDB_GOPTS_MAX (__BRIDGE_VLANDB_GOPTS_MAX - 1)
diff --cc net/bridge/br_multicast.c
index def6f1840985,2c437d4bf632..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -3032,7 -4310,20 +3032,24 @@@ unlock
  	return err;
  }
  
++<<<<<<< HEAD
 +static void br_multicast_start_querier(struct net_bridge *br,
++=======
+ int br_multicast_set_vlan_router(struct net_bridge_vlan *v, u8 mcast_router)
+ {
+ 	int err;
+ 
+ 	if (br_vlan_is_master(v))
+ 		err = br_multicast_set_router(&v->br_mcast_ctx, mcast_router);
+ 	else
+ 		err = br_multicast_set_port_router(&v->port_mcast_ctx,
+ 						   mcast_router);
+ 
+ 	return err;
+ }
+ 
+ static void br_multicast_start_querier(struct net_bridge_mcast *brmctx,
++>>>>>>> 2796d846d74a (net: bridge: vlan: convert mcast router global option to per-vlan entry)
  				       struct bridge_mcast_own_query *query)
  {
  	struct net_bridge_port *port;
diff --cc net/bridge/br_private.h
index 30e07225bc94,b4cef3a97f12..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -557,6 -624,84 +557,87 @@@ static inline bool br_vlan_should_use(c
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool nbp_state_should_learn(const struct net_bridge_port *p)
+ {
+ 	return p->state == BR_STATE_LEARNING || p->state == BR_STATE_FORWARDING;
+ }
+ 
+ static inline bool br_vlan_valid_id(u16 vid, struct netlink_ext_ack *extack)
+ {
+ 	bool ret = vid > 0 && vid < VLAN_VID_MASK;
+ 
+ 	if (!ret)
+ 		NL_SET_ERR_MSG_MOD(extack, "Vlan id is invalid");
+ 
+ 	return ret;
+ }
+ 
+ static inline bool br_vlan_valid_range(const struct bridge_vlan_info *cur,
+ 				       const struct bridge_vlan_info *last,
+ 				       struct netlink_ext_ack *extack)
+ {
+ 	/* pvid flag is not allowed in ranges */
+ 	if (cur->flags & BRIDGE_VLAN_INFO_PVID) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Pvid isn't allowed in a range");
+ 		return false;
+ 	}
+ 
+ 	/* when cur is the range end, check if:
+ 	 *  - it has range start flag
+ 	 *  - range ids are invalid (end is equal to or before start)
+ 	 */
+ 	if (last) {
+ 		if (cur->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN) {
+ 			NL_SET_ERR_MSG_MOD(extack, "Found a new vlan range start while processing one");
+ 			return false;
+ 		} else if (!(cur->flags & BRIDGE_VLAN_INFO_RANGE_END)) {
+ 			NL_SET_ERR_MSG_MOD(extack, "Vlan range end flag is missing");
+ 			return false;
+ 		} else if (cur->vid <= last->vid) {
+ 			NL_SET_ERR_MSG_MOD(extack, "End vlan id is less than or equal to start vlan id");
+ 			return false;
+ 		}
+ 	}
+ 
+ 	/* check for required range flags */
+ 	if (!(cur->flags & (BRIDGE_VLAN_INFO_RANGE_BEGIN |
+ 			    BRIDGE_VLAN_INFO_RANGE_END))) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Both vlan range flags are missing");
+ 		return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static inline u8 br_vlan_multicast_router(const struct net_bridge_vlan *v)
+ {
+ 	u8 mcast_router = MDB_RTR_TYPE_DISABLED;
+ 
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	if (!br_vlan_is_master(v))
+ 		mcast_router = v->port_mcast_ctx.multicast_router;
+ 	else
+ 		mcast_router = v->br_mcast_ctx.multicast_router;
+ #endif
+ 
+ 	return mcast_router;
+ }
+ 
+ static inline int br_afspec_cmd_to_rtm(int cmd)
+ {
+ 	switch (cmd) {
+ 	case RTM_SETLINK:
+ 		return RTM_NEWVLAN;
+ 	case RTM_DELLINK:
+ 		return RTM_DELVLAN;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 2796d846d74a (net: bridge: vlan: convert mcast router global option to per-vlan entry)
  static inline int br_opt_get(const struct net_bridge *br,
  			     enum net_bridge_opts opt)
  {
@@@ -729,16 -889,22 +810,29 @@@ void br_multicast_leave_snoopers(struc
  void br_multicast_open(struct net_bridge *br);
  void br_multicast_stop(struct net_bridge *br);
  void br_multicast_dev_del(struct net_bridge *br);
++<<<<<<< HEAD
 +void br_multicast_flood(struct net_bridge_mdb_entry *mdst,
 +			struct sk_buff *skb, bool local_rcv, bool local_orig);
 +int br_multicast_set_router(struct net_bridge *br, unsigned long val);
 +int br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val);
 +int br_multicast_toggle(struct net_bridge *br, unsigned long val);
 +int br_multicast_set_querier(struct net_bridge *br, unsigned long val);
++=======
+ void br_multicast_flood(struct net_bridge_mdb_entry *mdst, struct sk_buff *skb,
+ 			struct net_bridge_mcast *brmctx,
+ 			bool local_rcv, bool local_orig);
+ int br_multicast_set_router(struct net_bridge_mcast *brmctx, unsigned long val);
+ int br_multicast_set_port_router(struct net_bridge_mcast_port *pmctx,
+ 				 unsigned long val);
+ int br_multicast_set_vlan_router(struct net_bridge_vlan *v, u8 mcast_router);
+ int br_multicast_toggle(struct net_bridge *br, unsigned long val,
+ 			struct netlink_ext_ack *extack);
+ int br_multicast_set_querier(struct net_bridge_mcast *brmctx, unsigned long val);
++>>>>>>> 2796d846d74a (net: bridge: vlan: convert mcast router global option to per-vlan entry)
  int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);
 -int br_multicast_set_igmp_version(struct net_bridge_mcast *brmctx,
 -				  unsigned long val);
 +int br_multicast_set_igmp_version(struct net_bridge *br, unsigned long val);
  #if IS_ENABLED(CONFIG_IPV6)
 -int br_multicast_set_mld_version(struct net_bridge_mcast *brmctx,
 -				 unsigned long val);
 +int br_multicast_set_mld_version(struct net_bridge *br, unsigned long val);
  #endif
  struct net_bridge_mdb_entry *
  br_mdb_ip_get(struct net_bridge *br, struct br_ip *dst);
diff --cc net/bridge/br_vlan_options.c
index 827bfc319599,8ffd4ed2563c..000000000000
--- a/net/bridge/br_vlan_options.c
+++ b/net/bridge/br_vlan_options.c
@@@ -281,6 -315,70 +309,73 @@@ bool br_vlan_global_opts_fill(struct sk
  	    nla_put_u16(skb, BRIDGE_VLANDB_GOPTS_RANGE, vid_range))
  		goto out_err;
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	if (nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING,
+ 		       !!(v_opts->priv_flags & BR_VLFLAG_GLOBAL_MCAST_ENABLED)) ||
+ 	    nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION,
+ 		       v_opts->br_mcast_ctx.multicast_igmp_version) ||
+ 	    nla_put_u32(skb, BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT,
+ 			v_opts->br_mcast_ctx.multicast_last_member_count) ||
+ 	    nla_put_u32(skb, BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT,
+ 			v_opts->br_mcast_ctx.multicast_startup_query_count) ||
+ 	    nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERIER,
+ 		       v_opts->br_mcast_ctx.multicast_querier) ||
+ 	    br_multicast_dump_querier_state(skb, &v_opts->br_mcast_ctx,
+ 					    BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_STATE))
+ 		goto out_err;
+ 
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_last_member_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_membership_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_querier_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_query_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_query_response_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_startup_query_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 
+ 	if (br_rports_have_mc_router(&v_opts->br_mcast_ctx)) {
+ 		nest2 = nla_nest_start(skb,
+ 				       BRIDGE_VLANDB_GOPTS_MCAST_ROUTER_PORTS);
+ 		if (!nest2)
+ 			goto out_err;
+ 
+ 		rcu_read_lock();
+ 		if (br_rports_fill_info(skb, &v_opts->br_mcast_ctx)) {
+ 			rcu_read_unlock();
+ 			nla_nest_cancel(skb, nest2);
+ 			goto out_err;
+ 		}
+ 		rcu_read_unlock();
+ 
+ 		nla_nest_end(skb, nest2);
+ 	}
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION,
+ 		       v_opts->br_mcast_ctx.multicast_mld_version))
+ 		goto out_err;
+ #endif
+ #endif
+ 
++>>>>>>> 2796d846d74a (net: bridge: vlan: convert mcast router global option to per-vlan entry)
  	nla_nest_end(skb, nest);
  
  	return true;
@@@ -295,6 -393,23 +390,26 @@@ static size_t rtnl_vlan_global_opts_nlm
  	return NLMSG_ALIGN(sizeof(struct br_vlan_msg))
  		+ nla_total_size(0) /* BRIDGE_VLANDB_GLOBAL_OPTIONS */
  		+ nla_total_size(sizeof(u16)) /* BRIDGE_VLANDB_GOPTS_ID */
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION */
+ 		+ nla_total_size(sizeof(u32)) /* BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT */
+ 		+ nla_total_size(sizeof(u32)) /* BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERIER */
+ 		+ br_multicast_querier_state_size() /* BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_STATE */
+ 		+ nla_total_size(0) /* BRIDGE_VLANDB_GOPTS_MCAST_ROUTER_PORTS */
+ 		+ br_rports_size(&v->br_mcast_ctx) /* BRIDGE_VLANDB_GOPTS_MCAST_ROUTER_PORTS */
+ #endif
++>>>>>>> 2796d846d74a (net: bridge: vlan: convert mcast router global option to per-vlan entry)
  		+ nla_total_size(sizeof(u16)); /* BRIDGE_VLANDB_GOPTS_RANGE */
  }
  
@@@ -348,13 -462,122 +463,126 @@@ static int br_vlan_process_global_one_o
  					   bool *changed,
  					   struct netlink_ext_ack *extack)
  {
 -	int err __maybe_unused;
 -
  	*changed = false;
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING]) {
+ 		u8 mc_snooping;
+ 
+ 		mc_snooping = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING]);
+ 		if (br_multicast_toggle_global_vlan(v, !!mc_snooping))
+ 			*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION]) {
+ 		u8 ver;
+ 
+ 		ver = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION]);
+ 		err = br_multicast_set_igmp_version(&v->br_mcast_ctx, ver);
+ 		if (err)
+ 			return err;
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT]) {
+ 		u32 cnt;
+ 
+ 		cnt = nla_get_u32(tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT]);
+ 		v->br_mcast_ctx.multicast_last_member_count = cnt;
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT]) {
+ 		u32 cnt;
+ 
+ 		cnt = nla_get_u32(tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT]);
+ 		v->br_mcast_ctx.multicast_startup_query_count = cnt;
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL]);
+ 		v->br_mcast_ctx.multicast_last_member_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL]);
+ 		v->br_mcast_ctx.multicast_membership_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL]);
+ 		v->br_mcast_ctx.multicast_querier_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL]);
+ 		v->br_mcast_ctx.multicast_query_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL]);
+ 		v->br_mcast_ctx.multicast_query_response_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL]);
+ 		v->br_mcast_ctx.multicast_startup_query_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER]) {
+ 		u8 val;
+ 
+ 		val = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER]);
+ 		err = br_multicast_set_querier(&v->br_mcast_ctx, val);
+ 		if (err)
+ 			return err;
+ 		*changed = true;
+ 	}
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION]) {
+ 		u8 ver;
+ 
+ 		ver = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION]);
+ 		err = br_multicast_set_mld_version(&v->br_mcast_ctx, ver);
+ 		if (err)
+ 			return err;
+ 		*changed = true;
+ 	}
+ #endif
+ #endif
+ 
++>>>>>>> 2796d846d74a (net: bridge: vlan: convert mcast router global option to per-vlan entry)
  	return 0;
  }
  
  static const struct nla_policy br_vlan_db_gpol[BRIDGE_VLANDB_GOPTS_MAX + 1] = {
  	[BRIDGE_VLANDB_GOPTS_ID]	= { .type = NLA_U16 },
  	[BRIDGE_VLANDB_GOPTS_RANGE]	= { .type = NLA_U16 },
++<<<<<<< HEAD
++=======
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL]	= { .type = NLA_U64 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT]	= { .type = NLA_U32 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT]	= { .type = NLA_U32 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL]	= { .type = NLA_U64 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL]	= { .type = NLA_U64 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL]	= { .type = NLA_U64 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL]	= { .type = NLA_U64 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL] = { .type = NLA_U64 },
++>>>>>>> 2796d846d74a (net: bridge: vlan: convert mcast router global option to per-vlan entry)
  };
  
  int br_vlan_rtm_process_global_options(struct net_device *dev,
* Unmerged path include/uapi/linux/if_bridge.h
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_private.h
diff --git a/net/bridge/br_vlan.c b/net/bridge/br_vlan.c
index 2d6db5abfe0e..4c6b1930ceb6 100644
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@ -1969,6 +1969,7 @@ static const struct nla_policy br_vlan_db_policy[BRIDGE_VLANDB_ENTRY_MAX + 1] =
 	[BRIDGE_VLANDB_ENTRY_RANGE]	= { .type = NLA_U16 },
 	[BRIDGE_VLANDB_ENTRY_STATE]	= { .type = NLA_U8 },
 	[BRIDGE_VLANDB_ENTRY_TUNNEL_INFO] = { .type = NLA_NESTED },
+	[BRIDGE_VLANDB_ENTRY_MCAST_ROUTER]	= { .type = NLA_U8 },
 };
 
 static int br_vlan_rtm_process_one(struct net_device *dev,
* Unmerged path net/bridge/br_vlan_options.c
