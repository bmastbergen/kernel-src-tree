net: bridge: mcast: move querier state to the multicast context

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 4d5b4e84c72451face4d7817697684196cbee50d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/4d5b4e84.failed

We need to have the querier state per multicast context in order to have
per-vlan control, so remove the internal option bit and move it to the
multicast context. Also annotate the lockless reads of the new variable.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4d5b4e84c72451face4d7817697684196cbee50d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
#	net/bridge/br_private.h
diff --cc net/bridge/br_multicast.c
index def6f1840985,fe1482efd59c..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -1081,16 -1666,16 +1081,22 @@@ static void br_multicast_send_query(str
  	struct br_ip br_group;
  	unsigned long time;
  
++<<<<<<< HEAD
 +	if (!netif_running(br->dev) ||
 +	    !br_opt_get(br, BROPT_MULTICAST_ENABLED) ||
 +	    !br_opt_get(br, BROPT_MULTICAST_QUERIER))
++=======
+ 	if (!br_multicast_ctx_should_use(brmctx, pmctx) ||
+ 	    !br_opt_get(brmctx->br, BROPT_MULTICAST_ENABLED) ||
+ 	    !brmctx->multicast_querier)
++>>>>>>> 4d5b4e84c724 (net: bridge: mcast: move querier state to the multicast context)
  		return;
  
 -	memset(&br_group.dst, 0, sizeof(br_group.dst));
 +	memset(&br_group.u, 0, sizeof(br_group.u));
  
 -	if (pmctx ? (own_query == &pmctx->ip4_own_query) :
 -		    (own_query == &brmctx->ip4_own_query)) {
 -		other_query = &brmctx->ip4_other_query;
 +	if (port ? (own_query == &port->ip4_own_query) :
 +		   (own_query == &br->ip4_own_query)) {
 +		other_query = &br->ip4_other_query;
  		br_group.proto = htons(ETH_P_IP);
  #if IS_ENABLED(CONFIG_IPV6)
  	} else {
@@@ -1157,15 -1747,21 +1163,26 @@@ static void br_multicast_port_group_rex
  
  	spin_lock(&br->multicast_lock);
  	if (!netif_running(br->dev) || hlist_unhashed(&pg->mglist) ||
- 	    !br_opt_get(br, BROPT_MULTICAST_ENABLED) ||
- 	    !br_opt_get(br, BROPT_MULTICAST_QUERIER))
+ 	    !br_opt_get(br, BROPT_MULTICAST_ENABLED))
  		goto out;
  
++<<<<<<< HEAD
 +	if (pg->addr.proto == htons(ETH_P_IP))
 +		other_query = &br->ip4_other_query;
++=======
+ 	pmctx = br_multicast_pg_to_port_ctx(pg);
+ 	if (!pmctx)
+ 		goto out;
+ 	brmctx = br_multicast_port_ctx_get_global(pmctx);
+ 	if (!brmctx->multicast_querier)
+ 		goto out;
+ 
+ 	if (pg->key.addr.proto == htons(ETH_P_IP))
+ 		other_query = &brmctx->ip4_other_query;
++>>>>>>> 4d5b4e84c724 (net: bridge: mcast: move querier state to the multicast context)
  #if IS_ENABLED(CONFIG_IPV6)
  	else
 -		other_query = &brmctx->ip6_other_query;
 +		other_query = &br->ip6_other_query;
  #endif
  
  	if (!other_query || timer_pending(&other_query->timer))
@@@ -1332,7 -1976,7 +1349,11 @@@ static void __grp_src_query_marked_and_
  		if (ent->flags & BR_SGRP_F_SEND) {
  			ent->flags &= ~BR_SGRP_F_SEND;
  			if (ent->timer.expires > lmqt) {
++<<<<<<< HEAD
 +				if (br_opt_get(br, BROPT_MULTICAST_QUERIER) &&
++=======
+ 				if (brmctx->multicast_querier &&
++>>>>>>> 4d5b4e84c724 (net: bridge: mcast: move querier state to the multicast context)
  				    other_query &&
  				    !timer_pending(&other_query->timer))
  					ent->src_query_rexmit_cnt = lmqc;
@@@ -1341,7 -1985,7 +1362,11 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	if (!br_opt_get(br, BROPT_MULTICAST_QUERIER) ||
++=======
+ 	if (!brmctx->multicast_querier ||
++>>>>>>> 4d5b4e84c724 (net: bridge: mcast: move querier state to the multicast context)
  	    !other_query || timer_pending(&other_query->timer))
  		return;
  
@@@ -1354,29 -1998,30 +1379,33 @@@
  		mod_timer(&pg->rexmit_timer, lmi);
  }
  
 -static void __grp_send_query_and_rexmit(struct net_bridge_mcast *brmctx,
 -					struct net_bridge_mcast_port *pmctx,
 -					struct net_bridge_port_group *pg)
 +static void __grp_send_query_and_rexmit(struct net_bridge_port_group *pg)
  {
  	struct bridge_mcast_other_query *other_query = NULL;
 +	struct net_bridge *br = pg->port->br;
  	unsigned long now = jiffies, lmi;
  
 -	if (!netif_running(brmctx->br->dev) ||
 -	    !br_opt_get(brmctx->br, BROPT_MULTICAST_ENABLED))
 +	if (!netif_running(br->dev) ||
 +	    !br_opt_get(br, BROPT_MULTICAST_ENABLED))
  		return;
  
 -	if (pg->key.addr.proto == htons(ETH_P_IP))
 -		other_query = &brmctx->ip4_other_query;
 +	if (pg->addr.proto == htons(ETH_P_IP))
 +		other_query = &br->ip4_other_query;
  #if IS_ENABLED(CONFIG_IPV6)
  	else
 -		other_query = &brmctx->ip6_other_query;
 +		other_query = &br->ip6_other_query;
  #endif
  
++<<<<<<< HEAD
 +	if (br_opt_get(br, BROPT_MULTICAST_QUERIER) &&
++=======
+ 	if (brmctx->multicast_querier &&
++>>>>>>> 4d5b4e84c724 (net: bridge: mcast: move querier state to the multicast context)
  	    other_query && !timer_pending(&other_query->timer)) {
 -		lmi = now + brmctx->multicast_last_member_interval;
 -		pg->grp_query_rexmit_cnt = brmctx->multicast_last_member_count - 1;
 -		__br_multicast_send_query(brmctx, pmctx, pg, &pg->key.addr,
 -					  &pg->key.addr, false, 0, NULL);
 +		lmi = now + br->multicast_last_member_interval;
 +		pg->grp_query_rexmit_cnt = br->multicast_last_member_count - 1;
 +		__br_multicast_send_query(br, pg->port, pg, &pg->addr,
 +					  &pg->addr, false, 0, NULL);
  		if (!timer_pending(&pg->rexmit_timer) ||
  		    time_after(pg->rexmit_timer.expires, lmi))
  			mod_timer(&pg->rexmit_timer, lmi);
@@@ -2439,12 -3317,12 +2468,17 @@@ br_multicast_leave_group(struct net_bri
  	if (timer_pending(&other_query->timer))
  		goto out;
  
++<<<<<<< HEAD
 +	if (br_opt_get(br, BROPT_MULTICAST_QUERIER)) {
 +		__br_multicast_send_query(br, port, NULL, NULL, &mp->addr,
++=======
+ 	if (brmctx->multicast_querier) {
+ 		__br_multicast_send_query(brmctx, pmctx, NULL, NULL, &mp->addr,
++>>>>>>> 4d5b4e84c724 (net: bridge: mcast: move querier state to the multicast context)
  					  false, 0, NULL);
  
 -		time = jiffies + brmctx->multicast_last_member_count *
 -				 brmctx->multicast_last_member_interval;
 +		time = jiffies + br->multicast_last_member_count *
 +				 br->multicast_last_member_interval;
  
  		mod_timer(&own_query->timer, time);
  
diff --cc net/bridge/br_private.h
index 30e07225bc94,b85203e8eb26..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -93,6 -91,60 +93,63 @@@ struct bridge_mcast_stats 
  };
  #endif
  
++<<<<<<< HEAD
++=======
+ /* net_bridge_mcast_port must be always defined due to forwarding stubs */
+ struct net_bridge_mcast_port {
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	struct net_bridge_port		*port;
+ 	struct net_bridge_vlan		*vlan;
+ 
+ 	struct bridge_mcast_own_query	ip4_own_query;
+ 	struct timer_list		ip4_mc_router_timer;
+ 	struct hlist_node		ip4_rlist;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	struct bridge_mcast_own_query	ip6_own_query;
+ 	struct timer_list		ip6_mc_router_timer;
+ 	struct hlist_node		ip6_rlist;
+ #endif /* IS_ENABLED(CONFIG_IPV6) */
+ 	unsigned char			multicast_router;
+ #endif /* CONFIG_BRIDGE_IGMP_SNOOPING */
+ };
+ 
+ /* net_bridge_mcast must be always defined due to forwarding stubs */
+ struct net_bridge_mcast {
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	struct net_bridge		*br;
+ 	struct net_bridge_vlan		*vlan;
+ 
+ 	u32				multicast_last_member_count;
+ 	u32				multicast_startup_query_count;
+ 
+ 	u8				multicast_querier;
+ 	u8				multicast_igmp_version;
+ 	u8				multicast_router;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	u8				multicast_mld_version;
+ #endif
+ 	unsigned long			multicast_last_member_interval;
+ 	unsigned long			multicast_membership_interval;
+ 	unsigned long			multicast_querier_interval;
+ 	unsigned long			multicast_query_interval;
+ 	unsigned long			multicast_query_response_interval;
+ 	unsigned long			multicast_startup_query_interval;
+ 	struct hlist_head		ip4_mc_router_list;
+ 	struct timer_list		ip4_mc_router_timer;
+ 	struct bridge_mcast_other_query	ip4_other_query;
+ 	struct bridge_mcast_own_query	ip4_own_query;
+ 	struct bridge_mcast_querier	ip4_querier;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	struct hlist_head		ip6_mc_router_list;
+ 	struct timer_list		ip6_mc_router_timer;
+ 	struct bridge_mcast_other_query	ip6_other_query;
+ 	struct bridge_mcast_own_query	ip6_own_query;
+ 	struct bridge_mcast_querier	ip6_querier;
+ #endif /* IS_ENABLED(CONFIG_IPV6) */
+ #endif /* CONFIG_BRIDGE_IGMP_SNOOPING */
+ };
+ 
++>>>>>>> 4d5b4e84c724 (net: bridge: mcast: move querier state to the multicast context)
  struct br_tunnel_info {
  	__be64				tunnel_id;
  	struct metadata_dst __rcu	*tunnel_dst;
@@@ -787,8 -1028,8 +843,13 @@@ __br_multicast_querier_exists(struct ne
  {
  	bool own_querier_enabled;
  
++<<<<<<< HEAD
 +	if (br_opt_get(br, BROPT_MULTICAST_QUERIER)) {
 +		if (is_ipv6 && !br_opt_get(br, BROPT_HAS_IPV6_ADDR))
++=======
+ 	if (READ_ONCE(brmctx->multicast_querier)) {
+ 		if (is_ipv6 && !br_opt_get(brmctx->br, BROPT_HAS_IPV6_ADDR))
++>>>>>>> 4d5b4e84c724 (net: bridge: mcast: move querier state to the multicast context)
  			own_querier_enabled = false;
  		else
  			own_querier_enabled = true;
* Unmerged path net/bridge/br_multicast.c
diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c
index 75be8311a010..d72464161021 100644
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@ -1536,7 +1536,7 @@ static int br_fill_info(struct sk_buff *skb, const struct net_device *brdev)
 	    nla_put_u8(skb, IFLA_BR_MCAST_QUERY_USE_IFADDR,
 		       br_opt_get(br, BROPT_MULTICAST_QUERY_USE_IFADDR)) ||
 	    nla_put_u8(skb, IFLA_BR_MCAST_QUERIER,
-		       br_opt_get(br, BROPT_MULTICAST_QUERIER)) ||
+		       READ_ONCE(br->multicast_ctx.multicast_querier)) ||
 	    nla_put_u8(skb, IFLA_BR_MCAST_STATS_ENABLED,
 		       br_opt_get(br, BROPT_MULTICAST_STATS_ENABLED)) ||
 	    nla_put_u32(skb, IFLA_BR_MCAST_HASH_ELASTICITY, RHT_ELASTICITY) ||
* Unmerged path net/bridge/br_private.h
diff --git a/net/bridge/br_sysfs_br.c b/net/bridge/br_sysfs_br.c
index 52b9892eb49f..3c9a0e6bc7d3 100644
--- a/net/bridge/br_sysfs_br.c
+++ b/net/bridge/br_sysfs_br.c
@@ -391,7 +391,7 @@ static ssize_t multicast_querier_show(struct device *d,
 				      char *buf)
 {
 	struct net_bridge *br = to_bridge(d);
-	return sprintf(buf, "%d\n", br_opt_get(br, BROPT_MULTICAST_QUERIER));
+	return sprintf(buf, "%d\n", READ_ONCE(br->multicast_ctx.multicast_querier));
 }
 
 static ssize_t multicast_querier_store(struct device *d,
