fork: don't check parent_tidptr with CLONE_PIDFD

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Dmitry V. Levin <ldv@altlinux.org>
commit 9014143bab2f3bc0b9e5db3bc8d00e2a43e50fbd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/9014143b.failed

Give userspace a cheap and reliable way to tell whether CLONE_PIDFD is
supported by the kernel or not. The easiest way is to pass an invalid
file descriptor value in parent_tidptr, perform the syscall and verify
that parent_tidptr has been changed to a valid file descriptor value.

CLONE_PIDFD uses parent_tidptr to return pidfds. CLONE_PARENT_SETTID
will use parent_tidptr to return the tid of the parent. The two flags
cannot be used together. Old kernels that only support
CLONE_PARENT_SETTID will not verify the value pointed to by
parent_tidptr. This behavior is unchanged even with the introduction of
CLONE_PIDFD.
However, if CLONE_PIDFD is specified the kernel will currently check the
value pointed to by parent_tidptr before placing the pidfd in the memory
pointed to. EINVAL will be returned if the value in parent_tidptr is not
0.

If CLONE_PIDFD is supported and fd 0 is closed, then the returned pidfd
can and likely will be 0 and parent_tidptr will be unchanged. This means
userspace must either check CLONE_PIDFD support beforehand or check that
fd 0 is not closed when invoking CLONE_PIDFD.

The check for pidfd == 0 was introduced during the v5.2 merge window by
commit b3e583825266 ("clone: add CLONE_PIDFD") to ensure that
CLONE_PIDFD could be potentially extended by passing in flags through
the return argument.

However, that extension would look horrible, and with the upcoming
introduction of the clone3 syscall in v5.3 there is no need to extend
legacy clone syscall this way. (Even if it would need to be extended,
CLONE_DETACHED can be reused with CLONE_PIDFD.)

So remove the pidfd == 0 check. Userspace that needs to be portable to
kernels without CLONE_PIDFD support can then be advised to initialize
pidfd to -1 and check the pidfd value returned by CLONE_PIDFD.

Fixes: b3e583825266 ("clone: add CLONE_PIDFD")
	Signed-off-by: Dmitry V. Levin <ldv@altlinux.org>
	Signed-off-by: Christian Brauner <christian@brauner.io>
(cherry picked from commit 9014143bab2f3bc0b9e5db3bc8d00e2a43e50fbd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/fork.c
diff --cc kernel/fork.c
index 886c2f479b06,39a3adaa4ad1..000000000000
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@@ -1784,12 -1821,16 +1784,25 @@@ static __latent_entropy struct task_str
  			return ERR_PTR(-EINVAL);
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * If the new process will be in a different time namespace
 +	 * do not allow it to share VM or a thread group with the forking task.
 +	 */
 +	if (clone_flags & (CLONE_THREAD | CLONE_VM)) {
 +		if (nsp->time_ns != nsp->time_ns_for_children)
++=======
+ 	if (clone_flags & CLONE_PIDFD) {
+ 		/*
+ 		 * - CLONE_PARENT_SETTID is useless for pidfds and also
+ 		 *   parent_tidptr is used to return pidfds.
+ 		 * - CLONE_DETACHED is blocked so that we can potentially
+ 		 *   reuse it later for CLONE_PIDFD.
+ 		 * - CLONE_THREAD is blocked until someone really needs it.
+ 		 */
+ 		if (clone_flags &
+ 		    (CLONE_DETACHED | CLONE_PARENT_SETTID | CLONE_THREAD))
++>>>>>>> 9014143bab2f (fork: don't check parent_tidptr with CLONE_PIDFD)
  			return ERR_PTR(-EINVAL);
  	}
  
* Unmerged path kernel/fork.c
