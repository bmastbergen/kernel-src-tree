scsi: qla2xxx: edif: Add doorbell notification for app

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Quinn Tran <qutran@marvell.com>
commit 7a09e8d92c6d56121910ccb2e8bc0d1affff66ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/7a09e8d9.failed

Some FC adapters from Marvell offer the ability to encrypt data in flight
(EDIF). This feature requires an application to act as an authenticator.

During runtime, driver and authentication application need to stay in sync
in terms of: Session being down|up, arrival of new authentication
message (AUTH ELS) and SADB update completion.

These events are queued up as doorbell to the authentication
application. Application would read this doorbell on regular basis to stay
up to date. Each SCSI host would have a separate doorbell queue.

The doorbell interface can daisy chain a list of events for each read. Each
event contains an event code + hint to help application steer the next
course of action.

Link: https://lore.kernel.org/r/20210624052606.21613-9-njavali@marvell.com
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>
Co-developed-by: Larry Wisneski <Larry.Wisneski@marvell.com>
	Signed-off-by: Larry Wisneski <Larry.Wisneski@marvell.com>
Co-developed-by: Duane Grigsby <duane.grigsby@marvell.com>
	Signed-off-by: Duane Grigsby <duane.grigsby@marvell.com>
Co-developed-by: Rick Hicksted Jr <rhicksted@marvell.com>
	Signed-off-by: Rick Hicksted Jr <rhicksted@marvell.com>
	Signed-off-by: Quinn Tran <qutran@marvell.com>
	Signed-off-by: Nilesh Javali <njavali@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 7a09e8d92c6d56121910ccb2e8bc0d1affff66ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_attr.c
#	drivers/scsi/qla2xxx/qla_edif.c
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_os.c
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_attr.c
index f781e4a61afe,22191e9a04a0..000000000000
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@@ -2402,6 -2480,8 +2403,11 @@@ struct device_attribute *qla2x00_host_a
  	&dev_attr_port_speed,
  	&dev_attr_port_no,
  	&dev_attr_fw_attr,
++<<<<<<< HEAD
++=======
+ 	&dev_attr_dport_diagnostics,
+ 	&dev_attr_edif_doorbell,
++>>>>>>> 7a09e8d92c6d (scsi: qla2xxx: edif: Add doorbell notification for app)
  	NULL, /* reserve for qlini_mode */
  	NULL, /* reserve for ql2xiniexchg */
  	NULL, /* reserve for ql2xexchoffld */
@@@ -3028,6 -3109,9 +3034,12 @@@ qla24xx_vport_delete(struct fc_vport *f
  	qla2x00_wait_for_sess_deletion(vha);
  
  	qla_nvme_delete(vha);
++<<<<<<< HEAD
++=======
+ 	qla_enode_stop(vha);
+ 	qla_edb_stop(vha);
+ 
++>>>>>>> 7a09e8d92c6d (scsi: qla2xxx: edif: Add doorbell notification for app)
  	vha->flags.delete_progress = 1;
  
  	qlt_remove_target(ha, vha);
diff --cc drivers/scsi/qla2xxx/qla_edif.c
index 8c567362bb60,818d740fdfd1..000000000000
--- a/drivers/scsi/qla2xxx/qla_edif.c
+++ b/drivers/scsi/qla2xxx/qla_edif.c
@@@ -11,6 -11,186 +11,189 @@@
  #include <linux/delay.h>
  #include <scsi/scsi_tcq.h>
  
++<<<<<<< HEAD
++=======
+ static struct edif_sa_index_entry *qla_edif_sadb_find_sa_index_entry(uint16_t nport_handle,
+ 		struct list_head *sa_list);
+ static uint16_t qla_edif_sadb_get_sa_index(fc_port_t *fcport,
+ 		struct qla_sa_update_frame *sa_frame);
+ static int qla_edif_sadb_delete_sa_index(fc_port_t *fcport, uint16_t nport_handle,
+ 		uint16_t sa_index);
+ static int qla_pur_get_pending(scsi_qla_host_t *, fc_port_t *, struct bsg_job *);
+ 
+ struct edb_node {
+ 	struct  list_head	list;
+ 	uint32_t		ntype;
+ 	union {
+ 		port_id_t	plogi_did;
+ 		uint32_t	async;
+ 		port_id_t	els_sid;
+ 		struct edif_sa_update_aen	sa_aen;
+ 	} u;
+ };
+ 
+ static struct els_sub_cmd {
+ 	uint16_t cmd;
+ 	const char *str;
+ } sc_str[] = {
+ 	{SEND_ELS, "send ELS"},
+ 	{SEND_ELS_REPLY, "send ELS Reply"},
+ 	{PULL_ELS, "retrieve ELS"},
+ };
+ 
+ const char *sc_to_str(uint16_t cmd)
+ {
+ 	int i;
+ 	struct els_sub_cmd *e;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(sc_str); i++) {
+ 		e = sc_str + i;
+ 		if (cmd == e->cmd)
+ 			return e->str;
+ 	}
+ 	return "unknown";
+ }
+ 
+ static struct edif_list_entry *qla_edif_list_find_sa_index(fc_port_t *fcport,
+ 		uint16_t handle)
+ {
+ 	struct edif_list_entry *entry;
+ 	struct edif_list_entry *tentry;
+ 	struct list_head *indx_list = &fcport->edif.edif_indx_list;
+ 
+ 	list_for_each_entry_safe(entry, tentry, indx_list, next) {
+ 		if (entry->handle == handle)
+ 			return entry;
+ 	}
+ 	return NULL;
+ }
+ 
+ /* timeout called when no traffic and delayed rx sa_index delete */
+ static void qla2x00_sa_replace_iocb_timeout(struct timer_list *t)
+ {
+ 	struct edif_list_entry *edif_entry = from_timer(edif_entry, t, timer);
+ 	fc_port_t *fcport = edif_entry->fcport;
+ 	struct scsi_qla_host *vha = fcport->vha;
+ 	struct  edif_sa_ctl *sa_ctl;
+ 	uint16_t nport_handle;
+ 	unsigned long flags = 0;
+ 
+ 	ql_dbg(ql_dbg_edif, vha, 0x3069,
+ 	    "%s:  nport_handle 0x%x,  SA REPL Delay Timeout, %8phC portid=%06x\n",
+ 	    __func__, edif_entry->handle, fcport->port_name, fcport->d_id.b24);
+ 
+ 	/*
+ 	 * if delete_sa_index is valid then no one has serviced this
+ 	 * delayed delete
+ 	 */
+ 	spin_lock_irqsave(&fcport->edif.indx_list_lock, flags);
+ 
+ 	/*
+ 	 * delete_sa_index is invalidated when we find the new sa_index in
+ 	 * the incoming data stream.  If it is not invalidated then we are
+ 	 * still looking for the new sa_index because there is no I/O and we
+ 	 * need to just force the rx delete and move on.  Otherwise
+ 	 * we could get another rekey which will result in an error 66.
+ 	 */
+ 	if (edif_entry->delete_sa_index != INVALID_EDIF_SA_INDEX) {
+ 		uint16_t delete_sa_index = edif_entry->delete_sa_index;
+ 
+ 		edif_entry->delete_sa_index = INVALID_EDIF_SA_INDEX;
+ 		nport_handle = edif_entry->handle;
+ 		spin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);
+ 
+ 		sa_ctl = qla_edif_find_sa_ctl_by_index(fcport,
+ 		    delete_sa_index, 0);
+ 
+ 		if (sa_ctl) {
+ 			ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 			    "%s: sa_ctl: %p, delete index %d, update index: %d, lid: 0x%x\n",
+ 			    __func__, sa_ctl, delete_sa_index, edif_entry->update_sa_index,
+ 			    nport_handle);
+ 
+ 			sa_ctl->flags = EDIF_SA_CTL_FLG_DEL;
+ 			set_bit(EDIF_SA_CTL_REPL, &sa_ctl->state);
+ 			qla_post_sa_replace_work(fcport->vha, fcport,
+ 			    nport_handle, sa_ctl);
+ 
+ 		} else {
+ 			ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 			    "%s: sa_ctl not found for delete_sa_index: %d\n",
+ 			    __func__, edif_entry->delete_sa_index);
+ 		}
+ 	} else {
+ 		spin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);
+ 	}
+ }
+ 
+ /*
+  * create a new list entry for this nport handle and
+  * add an sa_update index to the list - called for sa_update
+  */
+ static int qla_edif_list_add_sa_update_index(fc_port_t *fcport,
+ 		uint16_t sa_index, uint16_t handle)
+ {
+ 	struct edif_list_entry *entry;
+ 	unsigned long flags = 0;
+ 
+ 	/* if the entry exists, then just update the sa_index */
+ 	entry = qla_edif_list_find_sa_index(fcport, handle);
+ 	if (entry) {
+ 		entry->update_sa_index = sa_index;
+ 		entry->count = 0;
+ 		return 0;
+ 	}
+ 
+ 	/*
+ 	 * This is the normal path - there should be no existing entry
+ 	 * when update is called.  The exception is at startup
+ 	 * when update is called for the first two sa_indexes
+ 	 * followed by a delete of the first sa_index
+ 	 */
+ 	entry = kzalloc((sizeof(struct edif_list_entry)), GFP_ATOMIC);
+ 	if (!entry)
+ 		return -ENOMEM;
+ 
+ 	INIT_LIST_HEAD(&entry->next);
+ 	entry->handle = handle;
+ 	entry->update_sa_index = sa_index;
+ 	entry->delete_sa_index = INVALID_EDIF_SA_INDEX;
+ 	entry->count = 0;
+ 	entry->flags = 0;
+ 	timer_setup(&entry->timer, qla2x00_sa_replace_iocb_timeout, 0);
+ 	spin_lock_irqsave(&fcport->edif.indx_list_lock, flags);
+ 	list_add_tail(&entry->next, &fcport->edif.edif_indx_list);
+ 	spin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);
+ 	return 0;
+ }
+ 
+ /* remove an entry from the list */
+ static void qla_edif_list_delete_sa_index(fc_port_t *fcport, struct edif_list_entry *entry)
+ {
+ 	unsigned long flags = 0;
+ 
+ 	spin_lock_irqsave(&fcport->edif.indx_list_lock, flags);
+ 	list_del(&entry->next);
+ 	spin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);
+ }
+ 
+ int qla_post_sa_replace_work(struct scsi_qla_host *vha,
+ 	 fc_port_t *fcport, uint16_t nport_handle, struct edif_sa_ctl *sa_ctl)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_SA_REPLACE);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.sa_update.fcport = fcport;
+ 	e->u.sa_update.sa_ctl = sa_ctl;
+ 	e->u.sa_update.nport_handle = nport_handle;
+ 	fcport->flags |= FCF_ASYNC_ACTIVE;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
++>>>>>>> 7a09e8d92c6d (scsi: qla2xxx: edif: Add doorbell notification for app)
  static void
  qla_edif_sa_ctl_init(scsi_qla_host_t *vha, struct fc_port  *fcport)
  {
@@@ -105,6 -347,171 +288,174 @@@ static void qla_edif_reset_auth_wait(st
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ qla_edif_free_sa_ctl(fc_port_t *fcport, struct edif_sa_ctl *sa_ctl,
+ 	int index)
+ {
+ 	unsigned long flags = 0;
+ 
+ 	spin_lock_irqsave(&fcport->edif.sa_list_lock, flags);
+ 	list_del(&sa_ctl->next);
+ 	spin_unlock_irqrestore(&fcport->edif.sa_list_lock, flags);
+ 	if (index >= 512)
+ 		fcport->edif.tx_rekey_cnt--;
+ 	else
+ 		fcport->edif.rx_rekey_cnt--;
+ 	kfree(sa_ctl);
+ }
+ 
+ /* return an index to the freepool */
+ static void qla_edif_add_sa_index_to_freepool(fc_port_t *fcport, int dir,
+ 		uint16_t sa_index)
+ {
+ 	void *sa_id_map;
+ 	struct scsi_qla_host *vha = fcport->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	unsigned long flags = 0;
+ 	u16 lsa_index = sa_index;
+ 
+ 	ql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x3063,
+ 	    "%s: entry\n", __func__);
+ 
+ 	if (dir) {
+ 		sa_id_map = ha->edif_tx_sa_id_map;
+ 		lsa_index -= EDIF_TX_SA_INDEX_BASE;
+ 	} else {
+ 		sa_id_map = ha->edif_rx_sa_id_map;
+ 	}
+ 
+ 	spin_lock_irqsave(&ha->sadb_fp_lock, flags);
+ 	clear_bit(lsa_index, sa_id_map);
+ 	spin_unlock_irqrestore(&ha->sadb_fp_lock, flags);
+ 	ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 	    "%s: index %d added to free pool\n", __func__, sa_index);
+ }
+ 
+ static void __qla2x00_release_all_sadb(struct scsi_qla_host *vha,
+ 	struct fc_port *fcport, struct edif_sa_index_entry *entry,
+ 	int pdir)
+ {
+ 	struct edif_list_entry *edif_entry;
+ 	struct  edif_sa_ctl *sa_ctl;
+ 	int i, dir;
+ 	int key_cnt = 0;
+ 
+ 	for (i = 0; i < 2; i++) {
+ 		if (entry->sa_pair[i].sa_index == INVALID_EDIF_SA_INDEX)
+ 			continue;
+ 
+ 		if (fcport->loop_id != entry->handle) {
+ 			ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 			    "%s: ** WARNING %d** entry handle: 0x%x, lid: 0x%x, sa_index: %d\n",
+ 			    __func__, i, entry->handle, fcport->loop_id,
+ 			    entry->sa_pair[i].sa_index);
+ 		}
+ 
+ 		/* release the sa_ctl */
+ 		sa_ctl = qla_edif_find_sa_ctl_by_index(fcport,
+ 				entry->sa_pair[i].sa_index, pdir);
+ 		if (sa_ctl &&
+ 		    qla_edif_find_sa_ctl_by_index(fcport, sa_ctl->index, pdir)) {
+ 			ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 			    "%s: freeing sa_ctl for index %d\n", __func__, sa_ctl->index);
+ 			qla_edif_free_sa_ctl(fcport, sa_ctl, sa_ctl->index);
+ 		} else {
+ 			ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 			    "%s: sa_ctl NOT freed, sa_ctl: %p\n", __func__, sa_ctl);
+ 		}
+ 
+ 		/* Release the index */
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 			"%s: freeing sa_index %d, nph: 0x%x\n",
+ 			__func__, entry->sa_pair[i].sa_index, entry->handle);
+ 
+ 		dir = (entry->sa_pair[i].sa_index <
+ 			EDIF_TX_SA_INDEX_BASE) ? 0 : 1;
+ 		qla_edif_add_sa_index_to_freepool(fcport, dir,
+ 			entry->sa_pair[i].sa_index);
+ 
+ 		/* Delete timer on RX */
+ 		if (pdir != SAU_FLG_TX) {
+ 			edif_entry =
+ 				qla_edif_list_find_sa_index(fcport, entry->handle);
+ 			if (edif_entry) {
+ 				ql_dbg(ql_dbg_edif, vha, 0x5033,
+ 				    "%s: remove edif_entry %p, update_sa_index: 0x%x, delete_sa_index: 0x%x\n",
+ 				    __func__, edif_entry, edif_entry->update_sa_index,
+ 				    edif_entry->delete_sa_index);
+ 				qla_edif_list_delete_sa_index(fcport, edif_entry);
+ 				/*
+ 				 * valid delete_sa_index indicates there is a rx
+ 				 * delayed delete queued
+ 				 */
+ 				if (edif_entry->delete_sa_index !=
+ 						INVALID_EDIF_SA_INDEX) {
+ 					del_timer(&edif_entry->timer);
+ 
+ 					/* build and send the aen */
+ 					fcport->edif.rx_sa_set = 1;
+ 					fcport->edif.rx_sa_pending = 0;
+ 					qla_edb_eventcreate(vha,
+ 							VND_CMD_AUTH_STATE_SAUPDATE_COMPL,
+ 							QL_VND_SA_STAT_SUCCESS,
+ 							QL_VND_RX_SA_KEY, fcport);
+ 				}
+ 				ql_dbg(ql_dbg_edif, vha, 0x5033,
+ 				    "%s: release edif_entry %p, update_sa_index: 0x%x, delete_sa_index: 0x%x\n",
+ 				    __func__, edif_entry, edif_entry->update_sa_index,
+ 				    edif_entry->delete_sa_index);
+ 
+ 				kfree(edif_entry);
+ 			}
+ 		}
+ 		key_cnt++;
+ 	}
+ 	ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 	    "%s: %d %s keys released\n",
+ 	    __func__, key_cnt, pdir ? "tx" : "rx");
+ }
+ 
+ /* find an release all outstanding sadb sa_indicies */
+ void qla2x00_release_all_sadb(struct scsi_qla_host *vha, struct fc_port *fcport)
+ {
+ 	struct edif_sa_index_entry *entry, *tmp;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	unsigned long flags;
+ 
+ 	ql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x3063,
+ 	    "%s: Starting...\n", __func__);
+ 
+ 	spin_lock_irqsave(&ha->sadb_lock, flags);
+ 
+ 	list_for_each_entry_safe(entry, tmp, &ha->sadb_rx_index_list, next) {
+ 		if (entry->fcport == fcport) {
+ 			list_del(&entry->next);
+ 			spin_unlock_irqrestore(&ha->sadb_lock, flags);
+ 			__qla2x00_release_all_sadb(vha, fcport, entry, 0);
+ 			kfree(entry);
+ 			spin_lock_irqsave(&ha->sadb_lock, flags);
+ 			break;
+ 		}
+ 	}
+ 
+ 	list_for_each_entry_safe(entry, tmp, &ha->sadb_tx_index_list, next) {
+ 		if (entry->fcport == fcport) {
+ 			list_del(&entry->next);
+ 			spin_unlock_irqrestore(&ha->sadb_lock, flags);
+ 
+ 			__qla2x00_release_all_sadb(vha, fcport, entry, SAU_FLG_TX);
+ 
+ 			kfree(entry);
+ 			spin_lock_irqsave(&ha->sadb_lock, flags);
+ 			break;
+ 		}
+ 	}
+ 	spin_unlock_irqrestore(&ha->sadb_lock, flags);
+ }
+ 
++>>>>>>> 7a09e8d92c6d (scsi: qla2xxx: edif: Add doorbell notification for app)
  /**
   * qla_edif_app_start:  application has announce its present
   * @vha: host adapter pointer
@@@ -720,6 -1137,482 +1077,485 @@@ done
  	return rval;
  }
  
++<<<<<<< HEAD
++=======
+ static struct edif_sa_ctl *
+ qla_edif_add_sa_ctl(fc_port_t *fcport, struct qla_sa_update_frame *sa_frame,
+ 	int dir)
+ {
+ 	struct	edif_sa_ctl *sa_ctl;
+ 	struct qla_sa_update_frame *sap;
+ 	int	index = sa_frame->fast_sa_index;
+ 	unsigned long flags = 0;
+ 
+ 	sa_ctl = kzalloc(sizeof(*sa_ctl), GFP_KERNEL);
+ 	if (!sa_ctl) {
+ 		/* couldn't get space */
+ 		ql_dbg(ql_dbg_edif, fcport->vha, 0x9100,
+ 		    "unable to allocate SA CTL\n");
+ 		return NULL;
+ 	}
+ 
+ 	/*
+ 	 * need to allocate sa_index here and save it
+ 	 * in both sa_ctl->index and sa_frame->fast_sa_index;
+ 	 * If alloc fails then delete sa_ctl and return NULL
+ 	 */
+ 	INIT_LIST_HEAD(&sa_ctl->next);
+ 	sap = &sa_ctl->sa_frame;
+ 	*sap = *sa_frame;
+ 	sa_ctl->index = index;
+ 	sa_ctl->fcport = fcport;
+ 	sa_ctl->flags = 0;
+ 	sa_ctl->state = 0L;
+ 	ql_dbg(ql_dbg_edif, fcport->vha, 0x9100,
+ 	    "%s: Added sa_ctl %p, index %d, state 0x%lx\n",
+ 	    __func__, sa_ctl, sa_ctl->index, sa_ctl->state);
+ 	spin_lock_irqsave(&fcport->edif.sa_list_lock, flags);
+ 	if (dir == SAU_FLG_TX)
+ 		list_add_tail(&sa_ctl->next, &fcport->edif.tx_sa_list);
+ 	else
+ 		list_add_tail(&sa_ctl->next, &fcport->edif.rx_sa_list);
+ 	spin_unlock_irqrestore(&fcport->edif.sa_list_lock, flags);
+ 
+ 	return sa_ctl;
+ }
+ 
+ void
+ qla_edif_flush_sa_ctl_lists(fc_port_t *fcport)
+ {
+ 	struct edif_sa_ctl *sa_ctl, *tsa_ctl;
+ 	unsigned long flags = 0;
+ 
+ 	spin_lock_irqsave(&fcport->edif.sa_list_lock, flags);
+ 
+ 	list_for_each_entry_safe(sa_ctl, tsa_ctl, &fcport->edif.tx_sa_list,
+ 	    next) {
+ 		list_del(&sa_ctl->next);
+ 		kfree(sa_ctl);
+ 	}
+ 
+ 	list_for_each_entry_safe(sa_ctl, tsa_ctl, &fcport->edif.rx_sa_list,
+ 	    next) {
+ 		list_del(&sa_ctl->next);
+ 		kfree(sa_ctl);
+ 	}
+ 
+ 	spin_unlock_irqrestore(&fcport->edif.sa_list_lock, flags);
+ }
+ 
+ struct edif_sa_ctl *
+ qla_edif_find_sa_ctl_by_index(fc_port_t *fcport, int index, int dir)
+ {
+ 	struct edif_sa_ctl *sa_ctl, *tsa_ctl;
+ 	struct list_head *sa_list;
+ 
+ 	if (dir == SAU_FLG_TX)
+ 		sa_list = &fcport->edif.tx_sa_list;
+ 	else
+ 		sa_list = &fcport->edif.rx_sa_list;
+ 
+ 	list_for_each_entry_safe(sa_ctl, tsa_ctl, sa_list, next) {
+ 		if (test_bit(EDIF_SA_CTL_USED, &sa_ctl->state) &&
+ 		    sa_ctl->index == index)
+ 			return sa_ctl;
+ 	}
+ 	return NULL;
+ }
+ 
+ /* add the sa to the correct list */
+ static int
+ qla24xx_check_sadb_avail_slot(struct bsg_job *bsg_job, fc_port_t *fcport,
+ 	struct qla_sa_update_frame *sa_frame)
+ {
+ 	struct edif_sa_ctl *sa_ctl = NULL;
+ 	int dir;
+ 	uint16_t sa_index;
+ 
+ 	dir = (sa_frame->flags & SAU_FLG_TX);
+ 
+ 	/* map the spi to an sa_index */
+ 	sa_index = qla_edif_sadb_get_sa_index(fcport, sa_frame);
+ 	if (sa_index == RX_DELETE_NO_EDIF_SA_INDEX) {
+ 		/* process rx delete */
+ 		ql_dbg(ql_dbg_edif, fcport->vha, 0x3063,
+ 		    "%s: rx delete for lid 0x%x, spi 0x%x, no entry found\n",
+ 		    __func__, fcport->loop_id, sa_frame->spi);
+ 
+ 		/* build and send the aen */
+ 		fcport->edif.rx_sa_set = 1;
+ 		fcport->edif.rx_sa_pending = 0;
+ 		qla_edb_eventcreate(fcport->vha,
+ 		    VND_CMD_AUTH_STATE_SAUPDATE_COMPL,
+ 		    QL_VND_SA_STAT_SUCCESS,
+ 		    QL_VND_RX_SA_KEY, fcport);
+ 
+ 		/* force a return of good bsg status; */
+ 		return RX_DELETE_NO_EDIF_SA_INDEX;
+ 	} else if (sa_index == INVALID_EDIF_SA_INDEX) {
+ 		ql_dbg(ql_dbg_edif, fcport->vha, 0x9100,
+ 		    "%s: Failed to get sa_index for spi 0x%x, dir: %d\n",
+ 		    __func__, sa_frame->spi, dir);
+ 		return INVALID_EDIF_SA_INDEX;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_edif, fcport->vha, 0x9100,
+ 	    "%s: index %d allocated to spi 0x%x, dir: %d, nport_handle: 0x%x\n",
+ 	    __func__, sa_index, sa_frame->spi, dir, fcport->loop_id);
+ 
+ 	/* This is a local copy of sa_frame. */
+ 	sa_frame->fast_sa_index = sa_index;
+ 	/* create the sa_ctl */
+ 	sa_ctl = qla_edif_add_sa_ctl(fcport, sa_frame, dir);
+ 	if (!sa_ctl) {
+ 		ql_dbg(ql_dbg_edif, fcport->vha, 0x9100,
+ 		    "%s: Failed to add sa_ctl for spi 0x%x, dir: %d, sa_index: %d\n",
+ 		    __func__, sa_frame->spi, dir, sa_index);
+ 		return -1;
+ 	}
+ 
+ 	set_bit(EDIF_SA_CTL_USED, &sa_ctl->state);
+ 
+ 	if (dir == SAU_FLG_TX)
+ 		fcport->edif.tx_rekey_cnt++;
+ 	else
+ 		fcport->edif.rx_rekey_cnt++;
+ 
+ 	ql_dbg(ql_dbg_edif, fcport->vha, 0x9100,
+ 	    "%s: Found sa_ctl %p, index %d, state 0x%lx, tx_cnt %d, rx_cnt %d, nport_handle: 0x%x\n",
+ 	    __func__, sa_ctl, sa_ctl->index, sa_ctl->state,
+ 	    fcport->edif.tx_rekey_cnt,
+ 	    fcport->edif.rx_rekey_cnt, fcport->loop_id);
+ 
+ 	return 0;
+ }
+ 
+ #define QLA_SA_UPDATE_FLAGS_RX_KEY      0x0
+ #define QLA_SA_UPDATE_FLAGS_TX_KEY      0x2
+ 
+ int
+ qla24xx_sadb_update(struct bsg_job *bsg_job)
+ {
+ 	struct	fc_bsg_reply	*bsg_reply = bsg_job->reply;
+ 	struct Scsi_Host *host = fc_bsg_to_shost(bsg_job);
+ 	scsi_qla_host_t *vha = shost_priv(host);
+ 	fc_port_t		*fcport = NULL;
+ 	srb_t			*sp = NULL;
+ 	struct edif_list_entry *edif_entry = NULL;
+ 	int			found = 0;
+ 	int			rval = 0;
+ 	int result = 0;
+ 	struct qla_sa_update_frame sa_frame;
+ 	struct srb_iocb *iocb_cmd;
+ 
+ 	ql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x911d,
+ 	    "%s entered, vha: 0x%p\n", __func__, vha);
+ 
+ 	sg_copy_to_buffer(bsg_job->request_payload.sg_list,
+ 	    bsg_job->request_payload.sg_cnt, &sa_frame,
+ 	    sizeof(struct qla_sa_update_frame));
+ 
+ 	/* Check if host is online */
+ 	if (!vha->flags.online) {
+ 		ql_log(ql_log_warn, vha, 0x70a1, "Host is not online\n");
+ 		rval = -EIO;
+ 		SET_DID_STATUS(bsg_reply->result, DID_ERROR);
+ 		goto done;
+ 	}
+ 
+ 	if (vha->e_dbell.db_flags != EDB_ACTIVE) {
+ 		ql_log(ql_log_warn, vha, 0x70a1, "App not started\n");
+ 		rval = -EIO;
+ 		SET_DID_STATUS(bsg_reply->result, DID_ERROR);
+ 		goto done;
+ 	}
+ 
+ 	fcport = qla2x00_find_fcport_by_pid(vha, &sa_frame.port_id);
+ 	if (fcport) {
+ 		found = 1;
+ 		if (sa_frame.flags == QLA_SA_UPDATE_FLAGS_TX_KEY)
+ 			fcport->edif.tx_bytes = 0;
+ 		if (sa_frame.flags == QLA_SA_UPDATE_FLAGS_RX_KEY)
+ 			fcport->edif.rx_bytes = 0;
+ 	}
+ 
+ 	if (!found) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x70a3, "Failed to find port= %06x\n",
+ 		    sa_frame.port_id.b24);
+ 		rval = -EINVAL;
+ 		SET_DID_STATUS(bsg_reply->result, DID_TARGET_FAILURE);
+ 		goto done;
+ 	}
+ 
+ 	/* make sure the nport_handle is valid */
+ 	if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x70e1,
+ 		    "%s: %8phN lid=FC_NO_LOOP_ID, spi: 0x%x, DS %d, returning NO_CONNECT\n",
+ 		    __func__, fcport->port_name, sa_frame.spi,
+ 		    fcport->disc_state);
+ 		rval = -EINVAL;
+ 		SET_DID_STATUS(bsg_reply->result, DID_NO_CONNECT);
+ 		goto done;
+ 	}
+ 
+ 	/* allocate and queue an sa_ctl */
+ 	result = qla24xx_check_sadb_avail_slot(bsg_job, fcport, &sa_frame);
+ 
+ 	/* failure of bsg */
+ 	if (result == INVALID_EDIF_SA_INDEX) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x70e1,
+ 		    "%s: %8phN, skipping update.\n",
+ 		    __func__, fcport->port_name);
+ 		rval = -EINVAL;
+ 		SET_DID_STATUS(bsg_reply->result, DID_ERROR);
+ 		goto done;
+ 
+ 	/* rx delete failure */
+ 	} else if (result == RX_DELETE_NO_EDIF_SA_INDEX) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x70e1,
+ 		    "%s: %8phN, skipping rx delete.\n",
+ 		    __func__, fcport->port_name);
+ 		SET_DID_STATUS(bsg_reply->result, DID_OK);
+ 		goto done;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_edif, vha, 0x70e1,
+ 	    "%s: %8phN, sa_index in sa_frame: %d flags %xh\n",
+ 	    __func__, fcport->port_name, sa_frame.fast_sa_index,
+ 	    sa_frame.flags);
+ 
+ 	/* looking for rx index and delete */
+ 	if (((sa_frame.flags & SAU_FLG_TX) == 0) &&
+ 	    (sa_frame.flags & SAU_FLG_INV)) {
+ 		uint16_t nport_handle = fcport->loop_id;
+ 		uint16_t sa_index = sa_frame.fast_sa_index;
+ 
+ 		/*
+ 		 * make sure we have an existing rx key, otherwise just process
+ 		 * this as a straight delete just like TX
+ 		 * This is NOT a normal case, it indicates an error recovery or key cleanup
+ 		 * by the ipsec code above us.
+ 		 */
+ 		edif_entry = qla_edif_list_find_sa_index(fcport, fcport->loop_id);
+ 		if (!edif_entry) {
+ 			ql_dbg(ql_dbg_edif, vha, 0x911d,
+ 			    "%s: WARNING: no active sa_index for nport_handle 0x%x, forcing delete for sa_index 0x%x\n",
+ 			    __func__, fcport->loop_id, sa_index);
+ 			goto force_rx_delete;
+ 		}
+ 
+ 		/*
+ 		 * if we have a forced delete for rx, remove the sa_index from the edif list
+ 		 * and proceed with normal delete.  The rx delay timer should not be running
+ 		 */
+ 		if ((sa_frame.flags & SAU_FLG_FORCE_DELETE) == SAU_FLG_FORCE_DELETE) {
+ 			qla_edif_list_delete_sa_index(fcport, edif_entry);
+ 			ql_dbg(ql_dbg_edif, vha, 0x911d,
+ 			    "%s: FORCE DELETE flag found for nport_handle 0x%x, sa_index 0x%x, forcing DELETE\n",
+ 			    __func__, fcport->loop_id, sa_index);
+ 			kfree(edif_entry);
+ 			goto force_rx_delete;
+ 		}
+ 
+ 		/*
+ 		 * delayed rx delete
+ 		 *
+ 		 * if delete_sa_index is not invalid then there is already
+ 		 * a delayed index in progress, return bsg bad status
+ 		 */
+ 		if (edif_entry->delete_sa_index != INVALID_EDIF_SA_INDEX) {
+ 			struct edif_sa_ctl *sa_ctl;
+ 
+ 			ql_dbg(ql_dbg_edif, vha, 0x911d,
+ 			    "%s: delete for lid 0x%x, delete_sa_index %d is pending\n",
+ 			    __func__, edif_entry->handle, edif_entry->delete_sa_index);
+ 
+ 			/* free up the sa_ctl that was allocated with the sa_index */
+ 			sa_ctl = qla_edif_find_sa_ctl_by_index(fcport, sa_index,
+ 			    (sa_frame.flags & SAU_FLG_TX));
+ 			if (sa_ctl) {
+ 				ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 				    "%s: freeing sa_ctl for index %d\n",
+ 				    __func__, sa_ctl->index);
+ 				qla_edif_free_sa_ctl(fcport, sa_ctl, sa_ctl->index);
+ 			}
+ 
+ 			/* release the sa_index */
+ 			ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 			    "%s: freeing sa_index %d, nph: 0x%x\n",
+ 			    __func__, sa_index, nport_handle);
+ 			qla_edif_sadb_delete_sa_index(fcport, nport_handle, sa_index);
+ 
+ 			rval = -EINVAL;
+ 			SET_DID_STATUS(bsg_reply->result, DID_ERROR);
+ 			goto done;
+ 		}
+ 
+ 		fcport->edif.rekey_cnt++;
+ 
+ 		/* configure and start the rx delay timer */
+ 		edif_entry->fcport = fcport;
+ 		edif_entry->timer.expires = jiffies + RX_DELAY_DELETE_TIMEOUT * HZ;
+ 
+ 		ql_dbg(ql_dbg_edif, vha, 0x911d,
+ 		    "%s: adding timer, entry: %p, delete sa_index %d, lid 0x%x to edif_list\n",
+ 		    __func__, edif_entry, sa_index, nport_handle);
+ 
+ 		/*
+ 		 * Start the timer when we queue the delayed rx delete.
+ 		 * This is an activity timer that goes off if we have not
+ 		 * received packets with the new sa_index
+ 		 */
+ 		add_timer(&edif_entry->timer);
+ 
+ 		/*
+ 		 * sa_delete for rx key with an active rx key including this one
+ 		 * add the delete rx sa index to the hash so we can look for it
+ 		 * in the rsp queue.  Do this after making any changes to the
+ 		 * edif_entry as part of the rx delete.
+ 		 */
+ 
+ 		ql_dbg(ql_dbg_edif, vha, 0x911d,
+ 		    "%s: delete sa_index %d, lid 0x%x to edif_list. bsg done ptr %p\n",
+ 		    __func__, sa_index, nport_handle, bsg_job);
+ 
+ 		edif_entry->delete_sa_index = sa_index;
+ 
+ 		bsg_job->reply_len = sizeof(struct fc_bsg_reply);
+ 		bsg_reply->result = DID_OK << 16;
+ 
+ 		goto done;
+ 
+ 	/*
+ 	 * rx index and update
+ 	 * add the index to the list and continue with normal update
+ 	 */
+ 	} else if (((sa_frame.flags & SAU_FLG_TX) == 0) &&
+ 	    ((sa_frame.flags & SAU_FLG_INV) == 0)) {
+ 		/* sa_update for rx key */
+ 		uint32_t nport_handle = fcport->loop_id;
+ 		uint16_t sa_index = sa_frame.fast_sa_index;
+ 		int result;
+ 
+ 		/*
+ 		 * add the update rx sa index to the hash so we can look for it
+ 		 * in the rsp queue and continue normally
+ 		 */
+ 
+ 		ql_dbg(ql_dbg_edif, vha, 0x911d,
+ 		    "%s:  adding update sa_index %d, lid 0x%x to edif_list\n",
+ 		    __func__, sa_index, nport_handle);
+ 
+ 		result = qla_edif_list_add_sa_update_index(fcport, sa_index,
+ 		    nport_handle);
+ 		if (result) {
+ 			ql_dbg(ql_dbg_edif, vha, 0x911d,
+ 			    "%s: SA_UPDATE failed to add new sa index %d to list for lid 0x%x\n",
+ 			    __func__, sa_index, nport_handle);
+ 		}
+ 	}
+ 	if (sa_frame.flags & SAU_FLG_GMAC_MODE)
+ 		fcport->edif.aes_gmac = 1;
+ 	else
+ 		fcport->edif.aes_gmac = 0;
+ 
+ force_rx_delete:
+ 	/*
+ 	 * sa_update for both rx and tx keys, sa_delete for tx key
+ 	 * immediately process the request
+ 	 */
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp) {
+ 		rval = -ENOMEM;
+ 		SET_DID_STATUS(bsg_reply->result, DID_IMM_RETRY);
+ 		goto done;
+ 	}
+ 
+ 	sp->type = SRB_SA_UPDATE;
+ 	sp->name = "bsg_sa_update";
+ 	sp->u.bsg_job = bsg_job;
+ 	/* sp->free = qla2x00_bsg_sp_free; */
+ 	sp->free = qla2x00_rel_sp;
+ 	sp->done = qla2x00_bsg_job_done;
+ 	iocb_cmd = &sp->u.iocb_cmd;
+ 	iocb_cmd->u.sa_update.sa_frame  = sa_frame;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_log(ql_dbg_edif, vha, 0x70e3,
+ 		    "qla2x00_start_sp failed=%d.\n", rval);
+ 
+ 		qla2x00_rel_sp(sp);
+ 		rval = -EIO;
+ 		SET_DID_STATUS(bsg_reply->result, DID_IMM_RETRY);
+ 		goto done;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_edif, vha, 0x911d,
+ 	    "%s:  %s sent, hdl=%x, portid=%06x.\n",
+ 	    __func__, sp->name, sp->handle, fcport->d_id.b24);
+ 
+ 	fcport->edif.rekey_cnt++;
+ 	bsg_job->reply_len = sizeof(struct fc_bsg_reply);
+ 	SET_DID_STATUS(bsg_reply->result, DID_OK);
+ 
+ 	return 0;
+ 
+ /*
+  * send back error status
+  */
+ done:
+ 	bsg_job->reply_len = sizeof(struct fc_bsg_reply);
+ 	ql_dbg(ql_dbg_edif, vha, 0x911d,
+ 	    "%s:status: FAIL, result: 0x%x, bsg ptr done %p\n",
+ 	    __func__, bsg_reply->result, bsg_job);
+ 	bsg_job_done(bsg_job, bsg_reply->result,
+ 	    bsg_reply->reply_payload_rcv_len);
+ 
+ 	return 0;
+ }
+ 
+ static void
+ qla_enode_free(scsi_qla_host_t *vha, struct enode *node)
+ {
+ 	node->ntype = N_UNDEF;
+ 	kfree(node);
+ }
+ 
+ /**
+  * qla_enode_init - initialize enode structs & lock
+  * @vha: host adapter pointer
+  *
+  * should only be called when driver attaching
+  */
+ void
+ qla_enode_init(scsi_qla_host_t *vha)
+ {
+ 	struct	qla_hw_data *ha = vha->hw;
+ 	char	name[32];
+ 
+ 	if (vha->pur_cinfo.enode_flags == ENODE_ACTIVE) {
+ 		/* list still active - error */
+ 		ql_dbg(ql_dbg_edif, vha, 0x09102, "%s enode still active\n",
+ 		    __func__);
+ 		return;
+ 	}
+ 
+ 	/* initialize lock which protects pur_core & init list */
+ 	spin_lock_init(&vha->pur_cinfo.pur_lock);
+ 	INIT_LIST_HEAD(&vha->pur_cinfo.head);
+ 
+ 	snprintf(name, sizeof(name), "%s_%d_purex", QLA2XXX_DRIVER_NAME,
+ 	    ha->pdev->device);
+ }
+ 
+ /**
+  * qla_enode_stop - stop and clear and enode data
+  * @vha: host adapter pointer
+  *
+  * called when app notified it is exiting
+  */
++>>>>>>> 7a09e8d92c6d (scsi: qla2xxx: edif: Add doorbell notification for app)
  void
  qla_enode_stop(scsi_qla_host_t *vha)
  {
@@@ -729,17 -1625,1529 +1565,1520 @@@
  		    "%s enode not active\n", __func__);
  		return;
  	}
 -
 -	/* grab lock so list doesn't move */
 -	spin_lock_irqsave(&vha->pur_cinfo.pur_lock, flags);
 -
 -	vha->pur_cinfo.enode_flags &= ~ENODE_ACTIVE; /* mark it not active */
 -
 -	/* hopefully this is a null list at this point */
 -	list_for_each_entry_safe(node, q, &vha->pur_cinfo.head, list) {
 -		ql_dbg(ql_dbg_edif, vha, 0x910f,
 -		    "%s freeing enode type=%x, cnt=%x\n", __func__, node->ntype,
 -		    node->dinfo.nodecnt);
 -		list_del_init(&node->list);
 -		qla_enode_free(vha, node);
 -	}
 -	spin_unlock_irqrestore(&vha->pur_cinfo.pur_lock, flags);
  }
  
- /* function called when app is stopping */
++<<<<<<< HEAD
++=======
+ /*
+  *  allocate enode struct and populate buffer
+  *  returns: enode pointer with buffers
+  *           NULL on error
+  */
+ static struct enode *
+ qla_enode_alloc(scsi_qla_host_t *vha, uint32_t ntype)
+ {
+ 	struct enode		*node;
+ 	struct purexevent	*purex;
  
- void
- qla_edb_stop(scsi_qla_host_t *vha)
+ 	node = kzalloc(RX_ELS_SIZE, GFP_ATOMIC);
+ 	if (!node)
+ 		return NULL;
+ 
+ 	purex = &node->u.purexinfo;
+ 	purex->msgp = (u8 *)(node + 1);
+ 	purex->msgp_len = ELS_MAX_PAYLOAD;
+ 
+ 	node->ntype = ntype;
+ 	INIT_LIST_HEAD(&node->list);
+ 	return node;
+ }
+ 
+ static void
+ qla_enode_add(scsi_qla_host_t *vha, struct enode *ptr)
  {
- 	if (vha->e_dbell.db_flags != EDB_ACTIVE) {
- 		/* doorbell list not enabled */
- 		ql_dbg(ql_dbg_edif, vha, 0x09102,
- 		    "%s doorbell not enabled\n", __func__);
- 		return;
+ 	unsigned long flags;
+ 
+ 	ql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x9109,
+ 	    "%s add enode for type=%x, cnt=%x\n",
+ 	    __func__, ptr->ntype, ptr->dinfo.nodecnt);
+ 
+ 	spin_lock_irqsave(&vha->pur_cinfo.pur_lock, flags);
+ 	list_add_tail(&ptr->list, &vha->pur_cinfo.head);
+ 	spin_unlock_irqrestore(&vha->pur_cinfo.pur_lock, flags);
+ 
+ 	return;
+ }
+ 
+ static struct enode *
+ qla_enode_find(scsi_qla_host_t *vha, uint32_t ntype, uint32_t p1, uint32_t p2)
+ {
+ 	struct enode		*node_rtn = NULL;
+ 	struct enode		*list_node = NULL;
+ 	unsigned long		flags;
+ 	struct list_head	*pos, *q;
+ 	uint32_t		sid;
+ 	uint32_t		rw_flag;
+ 	struct purexevent	*purex;
+ 
+ 	/* secure the list from moving under us */
+ 	spin_lock_irqsave(&vha->pur_cinfo.pur_lock, flags);
+ 
+ 	list_for_each_safe(pos, q, &vha->pur_cinfo.head) {
+ 		list_node = list_entry(pos, struct enode, list);
+ 
+ 		/* node type determines what p1 and p2 are */
+ 		purex = &list_node->u.purexinfo;
+ 		sid = p1;
+ 		rw_flag = p2;
+ 
+ 		if (purex->pur_info.pur_sid.b24 == sid) {
+ 			if (purex->pur_info.pur_pend == 1 &&
+ 			    rw_flag == PUR_GET) {
+ 				/*
+ 				 * if the receive is in progress
+ 				 * and its a read/get then can't
+ 				 * transfer yet
+ 				 */
+ 				ql_dbg(ql_dbg_edif, vha, 0x9106,
+ 				    "%s purex xfer in progress for sid=%x\n",
+ 				    __func__, sid);
+ 			} else {
+ 				/* found it and its complete */
+ 				node_rtn = list_node;
+ 				list_del(pos);
+ 				break;
+ 			}
+ 		}
+ 	}
+ 
+ 	spin_unlock_irqrestore(&vha->pur_cinfo.pur_lock, flags);
+ 
+ 	return node_rtn;
+ }
+ 
+ /**
+  * qla_pur_get_pending - read/return authentication message sent
+  *  from remote port
+  * @vha: host adapter pointer
+  * @fcport: session pointer
+  * @bsg_job: user request where the message is copy to.
+  */
+ static int
+ qla_pur_get_pending(scsi_qla_host_t *vha, fc_port_t *fcport,
+ 	struct bsg_job *bsg_job)
+ {
+ 	struct enode		*ptr;
+ 	struct purexevent	*purex;
+ 	struct qla_bsg_auth_els_reply *rpl =
+ 	    (struct qla_bsg_auth_els_reply *)bsg_job->reply;
+ 
+ 	bsg_job->reply_len = sizeof(*rpl);
+ 
+ 	ptr = qla_enode_find(vha, N_PUREX, fcport->d_id.b24, PUR_GET);
+ 	if (!ptr) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x9111,
+ 		    "%s no enode data found for %8phN sid=%06x\n",
+ 		    __func__, fcport->port_name, fcport->d_id.b24);
+ 		SET_DID_STATUS(rpl->r.result, DID_IMM_RETRY);
+ 		return -EIO;
+ 	}
+ 
+ 	/*
+ 	 * enode is now off the linked list and is ours to deal with
+ 	 */
+ 	purex = &ptr->u.purexinfo;
+ 
+ 	/* Copy info back to caller */
+ 	rpl->rx_xchg_address = purex->pur_info.pur_rx_xchg_address;
+ 
+ 	SET_DID_STATUS(rpl->r.result, DID_OK);
+ 	rpl->r.reply_payload_rcv_len =
+ 	    sg_pcopy_from_buffer(bsg_job->reply_payload.sg_list,
+ 		bsg_job->reply_payload.sg_cnt, purex->msgp,
+ 		purex->pur_info.pur_bytes_rcvd, 0);
+ 
+ 	/* data copy / passback completed - destroy enode */
+ 	qla_enode_free(vha, ptr);
+ 
+ 	return 0;
+ }
+ 
+ /* it is assume qpair lock is held */
+ static int
+ qla_els_reject_iocb(scsi_qla_host_t *vha, struct qla_qpair *qp,
+ 	struct qla_els_pt_arg *a)
+ {
+ 	struct els_entry_24xx *els_iocb;
+ 
+ 	els_iocb = __qla2x00_alloc_iocbs(qp, NULL);
+ 	if (!els_iocb) {
+ 		ql_log(ql_log_warn, vha, 0x700c,
+ 		    "qla2x00_alloc_iocbs failed.\n");
+ 		return QLA_FUNCTION_FAILED;
+ 	}
+ 
+ 	qla_els_pt_iocb(vha, els_iocb, a);
+ 
+ 	ql_dbg(ql_dbg_edif, vha, 0x0183,
+ 	    "Sending ELS reject...\n");
+ 	ql_dump_buffer(ql_dbg_edif + ql_dbg_verbose, vha, 0x0185,
+ 	    vha->hw->elsrej.c, sizeof(*vha->hw->elsrej.c));
+ 	/* flush iocb to mem before notifying hw doorbell */
+ 	wmb();
+ 	qla2x00_start_iocbs(vha, qp->req);
+ 	return 0;
+ }
+ 
+ void
+ qla_edb_init(scsi_qla_host_t *vha)
+ {
+ 	if (vha->e_dbell.db_flags == EDB_ACTIVE) {
+ 		/* list already init'd - error */
+ 		ql_dbg(ql_dbg_edif, vha, 0x09102,
+ 		    "edif db already initialized, cannot reinit\n");
+ 		return;
+ 	}
+ 
+ 	/* initialize lock which protects doorbell & init list */
+ 	spin_lock_init(&vha->e_dbell.db_lock);
+ 	INIT_LIST_HEAD(&vha->e_dbell.head);
+ 
+ 	/* create and initialize doorbell */
+ 	init_completion(&vha->e_dbell.dbell);
+ }
+ 
+ static void
+ qla_edb_node_free(scsi_qla_host_t *vha, struct edb_node *node)
+ {
+ 	/*
+ 	 * releases the space held by this edb node entry
+ 	 * this function does _not_ free the edb node itself
+ 	 * NB: the edb node entry passed should not be on any list
+ 	 *
+ 	 * currently for doorbell there's no additional cleanup
+ 	 * needed, but here as a placeholder for furture use.
+ 	 */
+ 
+ 	if (!node) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x09122,
+ 		    "%s error - no valid node passed\n", __func__);
+ 		return;
+ 	}
+ 
+ 	node->ntype = N_UNDEF;
+ }
+ 
++>>>>>>> 7a09e8d92c6d (scsi: qla2xxx: edif: Add doorbell notification for app)
+ /* function called when app is stopping */
+ 
+ void
+ qla_edb_stop(scsi_qla_host_t *vha)
+ {
+ 	unsigned long flags;
+ 	struct edb_node *node, *q;
+ 
+ 	if (vha->e_dbell.db_flags != EDB_ACTIVE) {
+ 		/* doorbell list not enabled */
+ 		ql_dbg(ql_dbg_edif, vha, 0x09102,
+ 		    "%s doorbell not enabled\n", __func__);
+ 		return;
+ 	}
+ 
+ 	/* grab lock so list doesn't move */
+ 	spin_lock_irqsave(&vha->e_dbell.db_lock, flags);
+ 
+ 	vha->e_dbell.db_flags &= ~EDB_ACTIVE; /* mark it not active */
+ 	/* hopefully this is a null list at this point */
+ 	list_for_each_entry_safe(node, q, &vha->e_dbell.head, list) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x910f,
+ 		    "%s freeing edb_node type=%x\n",
+ 		    __func__, node->ntype);
+ 		qla_edb_node_free(vha, node);
+ 		list_del(&node->list);
+ 
+ 		kfree(node);
+ 	}
+ 	spin_unlock_irqrestore(&vha->e_dbell.db_lock, flags);
+ 
+ 	/* wake up doorbell waiters - they'll be dismissed with error code */
+ 	complete_all(&vha->e_dbell.dbell);
+ }
+ 
+ static struct edb_node *
+ qla_edb_node_alloc(scsi_qla_host_t *vha, uint32_t ntype)
+ {
+ 	struct edb_node	*node;
+ 
+ 	node = kzalloc(sizeof(*node), GFP_ATOMIC);
+ 	if (!node) {
+ 		/* couldn't get space */
+ 		ql_dbg(ql_dbg_edif, vha, 0x9100,
+ 		    "edb node unable to be allocated\n");
+ 		return NULL;
+ 	}
+ 
+ 	node->ntype = ntype;
+ 	INIT_LIST_HEAD(&node->list);
+ 	return node;
+ }
+ 
+ /* adds a already alllocated enode to the linked list */
+ static bool
+ qla_edb_node_add(scsi_qla_host_t *vha, struct edb_node *ptr)
+ {
+ 	unsigned long		flags;
+ 
+ 	if (vha->e_dbell.db_flags != EDB_ACTIVE) {
+ 		/* doorbell list not enabled */
+ 		ql_dbg(ql_dbg_edif, vha, 0x09102,
+ 		    "%s doorbell not enabled\n", __func__);
+ 		return false;
+ 	}
+ 
+ 	spin_lock_irqsave(&vha->e_dbell.db_lock, flags);
+ 	list_add_tail(&ptr->list, &vha->e_dbell.head);
+ 	spin_unlock_irqrestore(&vha->e_dbell.db_lock, flags);
+ 
+ 	/* ring doorbell for waiters */
+ 	complete(&vha->e_dbell.dbell);
+ 
+ 	return true;
+ }
+ 
+ /* adds event to doorbell list */
+ void
+ qla_edb_eventcreate(scsi_qla_host_t *vha, uint32_t dbtype,
+ 	uint32_t data, uint32_t data2, fc_port_t	*sfcport)
+ {
+ 	struct edb_node	*edbnode;
+ 	fc_port_t *fcport = sfcport;
+ 	port_id_t id;
+ 
+ 	if (!vha->hw->flags.edif_enabled) {
+ 		/* edif not enabled */
+ 		return;
+ 	}
+ 
+ 	if (vha->e_dbell.db_flags != EDB_ACTIVE) {
+ 		if (fcport)
+ 			fcport->edif.auth_state = dbtype;
+ 		/* doorbell list not enabled */
+ 		ql_dbg(ql_dbg_edif, vha, 0x09102,
+ 		    "%s doorbell not enabled (type=%d\n", __func__, dbtype);
+ 		return;
+ 	}
+ 
+ 	edbnode = qla_edb_node_alloc(vha, dbtype);
+ 	if (!edbnode) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x09102,
+ 		    "%s unable to alloc db node\n", __func__);
+ 		return;
+ 	}
+ 
+ 	if (!fcport) {
+ 		id.b.domain = (data >> 16) & 0xff;
+ 		id.b.area = (data >> 8) & 0xff;
+ 		id.b.al_pa = data & 0xff;
+ 		ql_dbg(ql_dbg_edif, vha, 0x09222,
+ 		    "%s: Arrived s_id: %06x\n", __func__,
+ 		    id.b24);
+ 		fcport = qla2x00_find_fcport_by_pid(vha, &id);
+ 		if (!fcport) {
+ 			ql_dbg(ql_dbg_edif, vha, 0x09102,
+ 			    "%s can't find fcport for sid= 0x%x - ignoring\n",
+ 			__func__, id.b24);
+ 			kfree(edbnode);
+ 			return;
+ 		}
+ 	}
+ 
+ 	/* populate the edb node */
+ 	switch (dbtype) {
+ 	case VND_CMD_AUTH_STATE_NEEDED:
+ 	case VND_CMD_AUTH_STATE_SESSION_SHUTDOWN:
+ 		edbnode->u.plogi_did.b24 = fcport->d_id.b24;
+ 		break;
+ 	case VND_CMD_AUTH_STATE_ELS_RCVD:
+ 		edbnode->u.els_sid.b24 = fcport->d_id.b24;
+ 		break;
+ 	case VND_CMD_AUTH_STATE_SAUPDATE_COMPL:
+ 		edbnode->u.sa_aen.port_id = fcport->d_id;
+ 		edbnode->u.sa_aen.status =  data;
+ 		edbnode->u.sa_aen.key_type =  data2;
+ 		break;
+ 	default:
+ 		ql_dbg(ql_dbg_edif, vha, 0x09102,
+ 			"%s unknown type: %x\n", __func__, dbtype);
+ 		qla_edb_node_free(vha, edbnode);
+ 		kfree(edbnode);
+ 		edbnode = NULL;
+ 		break;
+ 	}
+ 
+ 	if (edbnode && (!qla_edb_node_add(vha, edbnode))) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x09102,
+ 		    "%s unable to add dbnode\n", __func__);
+ 		qla_edb_node_free(vha, edbnode);
+ 		kfree(edbnode);
+ 		return;
+ 	}
+ 	if (edbnode && fcport)
+ 		fcport->edif.auth_state = dbtype;
+ 	ql_dbg(ql_dbg_edif, vha, 0x09102,
+ 	    "%s Doorbell produced : type=%d %p\n", __func__, dbtype, edbnode);
+ }
+ 
+ static struct edb_node *
+ qla_edb_getnext(scsi_qla_host_t *vha)
+ {
+ 	unsigned long	flags;
+ 	struct edb_node	*edbnode = NULL;
+ 
+ 	spin_lock_irqsave(&vha->e_dbell.db_lock, flags);
+ 
+ 	/* db nodes are fifo - no qualifications done */
+ 	if (!list_empty(&vha->e_dbell.head)) {
+ 		edbnode = list_first_entry(&vha->e_dbell.head,
+ 		    struct edb_node, list);
+ 		list_del(&edbnode->list);
+ 	}
+ 
+ 	spin_unlock_irqrestore(&vha->e_dbell.db_lock, flags);
+ 
+ 	return edbnode;
+ }
+ 
+ /*
+  * app uses separate thread to read this. It'll wait until the doorbell
+  * is rung by the driver or the max wait time has expired
+  */
+ ssize_t
+ edif_doorbell_show(struct device *dev, struct device_attribute *attr,
+ 		char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	struct edb_node	*dbnode = NULL;
+ 	struct edif_app_dbell *ap = (struct edif_app_dbell *)buf;
+ 	uint32_t dat_siz, buf_size, sz;
+ 
+ 	/* TODO: app currently hardcoded to 256. Will transition to bsg */
+ 	sz = 256;
+ 
+ 	/* stop new threads from waiting if we're not init'd */
+ 	if (vha->e_dbell.db_flags != EDB_ACTIVE) {
+ 		ql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x09122,
+ 		    "%s error - edif db not enabled\n", __func__);
+ 		return 0;
+ 	}
+ 
+ 	if (!vha->hw->flags.edif_enabled) {
+ 		/* edif not enabled */
+ 		ql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x09122,
+ 		    "%s error - edif not enabled\n", __func__);
+ 		return -1;
+ 	}
+ 
+ 	buf_size = 0;
+ 	while ((sz - buf_size) >= sizeof(struct edb_node)) {
+ 		/* remove the next item from the doorbell list */
+ 		dat_siz = 0;
+ 		dbnode = qla_edb_getnext(vha);
+ 		if (dbnode) {
+ 			ap->event_code = dbnode->ntype;
+ 			switch (dbnode->ntype) {
+ 			case VND_CMD_AUTH_STATE_SESSION_SHUTDOWN:
+ 			case VND_CMD_AUTH_STATE_NEEDED:
+ 				ap->port_id = dbnode->u.plogi_did;
+ 				dat_siz += sizeof(ap->port_id);
+ 				break;
+ 			case VND_CMD_AUTH_STATE_ELS_RCVD:
+ 				ap->port_id = dbnode->u.els_sid;
+ 				dat_siz += sizeof(ap->port_id);
+ 				break;
+ 			case VND_CMD_AUTH_STATE_SAUPDATE_COMPL:
+ 				ap->port_id = dbnode->u.sa_aen.port_id;
+ 				memcpy(ap->event_data, &dbnode->u,
+ 						sizeof(struct edif_sa_update_aen));
+ 				dat_siz += sizeof(struct edif_sa_update_aen);
+ 				break;
+ 			default:
+ 				/* unknown node type, rtn unknown ntype */
+ 				ap->event_code = VND_CMD_AUTH_STATE_UNDEF;
+ 				memcpy(ap->event_data, &dbnode->ntype, 4);
+ 				dat_siz += 4;
+ 				break;
+ 			}
+ 
+ 			ql_dbg(ql_dbg_edif, vha, 0x09102,
+ 				"%s Doorbell consumed : type=%d %p\n",
+ 				__func__, dbnode->ntype, dbnode);
+ 			/* we're done with the db node, so free it up */
+ 			qla_edb_node_free(vha, dbnode);
+ 			kfree(dbnode);
+ 		} else {
+ 			break;
+ 		}
+ 
+ 		ap->event_data_size = dat_siz;
+ 		/* 8bytes = ap->event_code + ap->event_data_size */
+ 		buf_size += dat_siz + 8;
+ 		ap = (struct edif_app_dbell *)(buf + buf_size);
+ 	}
+ 	return buf_size;
+ }
++<<<<<<< HEAD
++=======
+ 
+ static void qla_noop_sp_done(srb_t *sp, int res)
+ {
+ 	sp->free(sp);
+ }
+ 
+ /*
+  * Called from work queue
+  * build and send the sa_update iocb to delete an rx sa_index
+  */
+ int
+ qla24xx_issue_sa_replace_iocb(scsi_qla_host_t *vha, struct qla_work_evt *e)
+ {
+ 	srb_t *sp;
+ 	fc_port_t	*fcport = NULL;
+ 	struct srb_iocb *iocb_cmd = NULL;
+ 	int rval = QLA_SUCCESS;
+ 	struct	edif_sa_ctl *sa_ctl = e->u.sa_update.sa_ctl;
+ 	uint16_t nport_handle = e->u.sa_update.nport_handle;
+ 
+ 	ql_dbg(ql_dbg_edif, vha, 0x70e6,
+ 	    "%s: starting,  sa_ctl: %p\n", __func__, sa_ctl);
+ 
+ 	if (!sa_ctl) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x70e6,
+ 		    "sa_ctl allocation failed\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	fcport = sa_ctl->fcport;
+ 
+ 	/* Alloc SRB structure */
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x70e6,
+ 		 "SRB allocation failed\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	iocb_cmd = &sp->u.iocb_cmd;
+ 	iocb_cmd->u.sa_update.sa_ctl = sa_ctl;
+ 
+ 	ql_dbg(ql_dbg_edif, vha, 0x3073,
+ 	    "Enter: SA REPL portid=%06x, sa_ctl %p, index %x, nport_handle: 0x%x\n",
+ 	    fcport->d_id.b24, sa_ctl, sa_ctl->index, nport_handle);
+ 	/*
+ 	 * if this is a sadb cleanup delete, mark it so the isr can
+ 	 * take the correct action
+ 	 */
+ 	if (sa_ctl->flags & EDIF_SA_CTL_FLG_CLEANUP_DEL) {
+ 		/* mark this srb as a cleanup delete */
+ 		sp->flags |= SRB_EDIF_CLEANUP_DELETE;
+ 		ql_dbg(ql_dbg_edif, vha, 0x70e6,
+ 		    "%s: sp 0x%p flagged as cleanup delete\n", __func__, sp);
+ 	}
+ 
+ 	sp->type = SRB_SA_REPLACE;
+ 	sp->name = "SA_REPLACE";
+ 	sp->fcport = fcport;
+ 	sp->free = qla2x00_rel_sp;
+ 	sp->done = qla_noop_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 
+ 	if (rval != QLA_SUCCESS)
+ 		rval = QLA_FUNCTION_FAILED;
+ 
+ 	return rval;
+ }
+ 
+ void qla24xx_sa_update_iocb(srb_t *sp, struct sa_update_28xx *sa_update_iocb)
+ {
+ 	int	itr = 0;
+ 	struct	scsi_qla_host		*vha = sp->vha;
+ 	struct	qla_sa_update_frame	*sa_frame =
+ 		&sp->u.iocb_cmd.u.sa_update.sa_frame;
+ 	u8 flags = 0;
+ 
+ 	switch (sa_frame->flags & (SAU_FLG_INV | SAU_FLG_TX)) {
+ 	case 0:
+ 		ql_dbg(ql_dbg_edif, vha, 0x911d,
+ 		    "%s: EDIF SA UPDATE RX IOCB  vha: 0x%p  index: %d\n",
+ 		    __func__, vha, sa_frame->fast_sa_index);
+ 		break;
+ 	case 1:
+ 		ql_dbg(ql_dbg_edif, vha, 0x911d,
+ 		    "%s: EDIF SA DELETE RX IOCB  vha: 0x%p  index: %d\n",
+ 		    __func__, vha, sa_frame->fast_sa_index);
+ 		flags |= SA_FLAG_INVALIDATE;
+ 		break;
+ 	case 2:
+ 		ql_dbg(ql_dbg_edif, vha, 0x911d,
+ 		    "%s: EDIF SA UPDATE TX IOCB  vha: 0x%p  index: %d\n",
+ 		    __func__, vha, sa_frame->fast_sa_index);
+ 		flags |= SA_FLAG_TX;
+ 		break;
+ 	case 3:
+ 		ql_dbg(ql_dbg_edif, vha, 0x911d,
+ 		    "%s: EDIF SA DELETE TX IOCB  vha: 0x%p  index: %d\n",
+ 		    __func__, vha, sa_frame->fast_sa_index);
+ 		flags |= SA_FLAG_TX | SA_FLAG_INVALIDATE;
+ 		break;
+ 	}
+ 
+ 	sa_update_iocb->entry_type = SA_UPDATE_IOCB_TYPE;
+ 	sa_update_iocb->entry_count = 1;
+ 	sa_update_iocb->sys_define = 0;
+ 	sa_update_iocb->entry_status = 0;
+ 	sa_update_iocb->handle = sp->handle;
+ 	sa_update_iocb->u.nport_handle = cpu_to_le16(sp->fcport->loop_id);
+ 	sa_update_iocb->vp_index = sp->fcport->vha->vp_idx;
+ 	sa_update_iocb->port_id[0] = sp->fcport->d_id.b.al_pa;
+ 	sa_update_iocb->port_id[1] = sp->fcport->d_id.b.area;
+ 	sa_update_iocb->port_id[2] = sp->fcport->d_id.b.domain;
+ 
+ 	sa_update_iocb->flags = flags;
+ 	sa_update_iocb->salt = cpu_to_le32(sa_frame->salt);
+ 	sa_update_iocb->spi = cpu_to_le32(sa_frame->spi);
+ 	sa_update_iocb->sa_index = cpu_to_le16(sa_frame->fast_sa_index);
+ 
+ 	sa_update_iocb->sa_control |= SA_CNTL_ENC_FCSP;
+ 	if (sp->fcport->edif.aes_gmac)
+ 		sa_update_iocb->sa_control |= SA_CNTL_AES_GMAC;
+ 
+ 	if (sa_frame->flags & SAU_FLG_KEY256) {
+ 		sa_update_iocb->sa_control |= SA_CNTL_KEY256;
+ 		for (itr = 0; itr < 32; itr++)
+ 			sa_update_iocb->sa_key[itr] = sa_frame->sa_key[itr];
+ 
+ 		ql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x921f, "%s 256 sa key=%32phN\n",
+ 		    __func__, sa_update_iocb->sa_key);
+ 	} else {
+ 		sa_update_iocb->sa_control |= SA_CNTL_KEY128;
+ 		for (itr = 0; itr < 16; itr++)
+ 			sa_update_iocb->sa_key[itr] = sa_frame->sa_key[itr];
+ 
+ 		ql_dbg(ql_dbg_edif +  ql_dbg_verbose, vha, 0x921f, "%s 128 sa key=%16phN\n",
+ 		    __func__, sa_update_iocb->sa_key);
+ 	}
+ 
+ 	ql_dbg(ql_dbg_edif, vha, 0x921d,
+ 	    "%s SAU Port ID = %02x%02x%02x, flags=%xh, index=%u, ctl=%xh, SPI 0x%x flags 0x%x hdl=%x gmac %d\n",
+ 	    __func__, sa_update_iocb->port_id[2], sa_update_iocb->port_id[1],
+ 	    sa_update_iocb->port_id[0], sa_update_iocb->flags, sa_update_iocb->sa_index,
+ 	    sa_update_iocb->sa_control, sa_update_iocb->spi, sa_frame->flags, sp->handle,
+ 	    sp->fcport->edif.aes_gmac);
+ 
+ 	if (sa_frame->flags & SAU_FLG_TX)
+ 		sp->fcport->edif.tx_sa_pending = 1;
+ 	else
+ 		sp->fcport->edif.rx_sa_pending = 1;
+ 
+ 	sp->fcport->vha->qla_stats.control_requests++;
+ }
+ 
+ void
+ qla24xx_sa_replace_iocb(srb_t *sp, struct sa_update_28xx *sa_update_iocb)
+ {
+ 	struct	scsi_qla_host		*vha = sp->vha;
+ 	struct srb_iocb *srb_iocb = &sp->u.iocb_cmd;
+ 	struct	edif_sa_ctl		*sa_ctl = srb_iocb->u.sa_update.sa_ctl;
+ 	uint16_t nport_handle = sp->fcport->loop_id;
+ 
+ 	sa_update_iocb->entry_type = SA_UPDATE_IOCB_TYPE;
+ 	sa_update_iocb->entry_count = 1;
+ 	sa_update_iocb->sys_define = 0;
+ 	sa_update_iocb->entry_status = 0;
+ 	sa_update_iocb->handle = sp->handle;
+ 
+ 	sa_update_iocb->u.nport_handle = cpu_to_le16(nport_handle);
+ 
+ 	sa_update_iocb->vp_index = sp->fcport->vha->vp_idx;
+ 	sa_update_iocb->port_id[0] = sp->fcport->d_id.b.al_pa;
+ 	sa_update_iocb->port_id[1] = sp->fcport->d_id.b.area;
+ 	sa_update_iocb->port_id[2] = sp->fcport->d_id.b.domain;
+ 
+ 	/* Invalidate the index. salt, spi, control & key are ignore */
+ 	sa_update_iocb->flags = SA_FLAG_INVALIDATE;
+ 	sa_update_iocb->salt = 0;
+ 	sa_update_iocb->spi = 0;
+ 	sa_update_iocb->sa_index = cpu_to_le16(sa_ctl->index);
+ 	sa_update_iocb->sa_control = 0;
+ 
+ 	ql_dbg(ql_dbg_edif, vha, 0x921d,
+ 	    "%s SAU DELETE RX Port ID = %02x:%02x:%02x, lid %d flags=%xh, index=%u, hdl=%x\n",
+ 	    __func__, sa_update_iocb->port_id[2], sa_update_iocb->port_id[1],
+ 	    sa_update_iocb->port_id[0], nport_handle, sa_update_iocb->flags,
+ 	    sa_update_iocb->sa_index, sp->handle);
+ 
+ 	sp->fcport->vha->qla_stats.control_requests++;
+ }
+ 
+ void qla24xx_auth_els(scsi_qla_host_t *vha, void **pkt, struct rsp_que **rsp)
+ {
+ 	struct purex_entry_24xx *p = *pkt;
+ 	struct enode		*ptr;
+ 	int		sid;
+ 	u16 totlen;
+ 	struct purexevent	*purex;
+ 	struct scsi_qla_host *host = NULL;
+ 	int rc;
+ 	struct fc_port *fcport;
+ 	struct qla_els_pt_arg a;
+ 	be_id_t beid;
+ 
+ 	memset(&a, 0, sizeof(a));
+ 
+ 	a.els_opcode = ELS_AUTH_ELS;
+ 	a.nport_handle = p->nport_handle;
+ 	a.rx_xchg_address = p->rx_xchg_addr;
+ 	a.did.b.domain = p->s_id[2];
+ 	a.did.b.area   = p->s_id[1];
+ 	a.did.b.al_pa  = p->s_id[0];
+ 	a.tx_byte_count = a.tx_len = sizeof(struct fc_els_ls_rjt);
+ 	a.tx_addr = vha->hw->elsrej.cdma;
+ 	a.vp_idx = vha->vp_idx;
+ 	a.control_flags = EPD_ELS_RJT;
+ 
+ 	sid = p->s_id[0] | (p->s_id[1] << 8) | (p->s_id[2] << 16);
+ 
+ 	totlen = (le16_to_cpu(p->frame_size) & 0x0fff) - PURX_ELS_HEADER_SIZE;
+ 	if (le16_to_cpu(p->status_flags) & 0x8000) {
+ 		totlen = le16_to_cpu(p->trunc_frame_size);
+ 		qla_els_reject_iocb(vha, (*rsp)->qpair, &a);
+ 		__qla_consume_iocb(vha, pkt, rsp);
+ 		return;
+ 	}
+ 
+ 	if (totlen > MAX_PAYLOAD) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x0910d,
+ 		    "%s WARNING: verbose ELS frame received (totlen=%x)\n",
+ 		    __func__, totlen);
+ 		qla_els_reject_iocb(vha, (*rsp)->qpair, &a);
+ 		__qla_consume_iocb(vha, pkt, rsp);
+ 		return;
+ 	}
+ 
+ 	if (!vha->hw->flags.edif_enabled) {
+ 		/* edif support not enabled */
+ 		ql_dbg(ql_dbg_edif, vha, 0x910e, "%s edif not enabled\n",
+ 		    __func__);
+ 		qla_els_reject_iocb(vha, (*rsp)->qpair, &a);
+ 		__qla_consume_iocb(vha, pkt, rsp);
+ 		return;
+ 	}
+ 
+ 	ptr = qla_enode_alloc(vha, N_PUREX);
+ 	if (!ptr) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x09109,
+ 		    "WARNING: enode allloc failed for sid=%x\n",
+ 		    sid);
+ 		qla_els_reject_iocb(vha, (*rsp)->qpair, &a);
+ 		__qla_consume_iocb(vha, pkt, rsp);
+ 		return;
+ 	}
+ 
+ 	purex = &ptr->u.purexinfo;
+ 	purex->pur_info.pur_sid = a.did;
+ 	purex->pur_info.pur_pend = 0;
+ 	purex->pur_info.pur_bytes_rcvd = totlen;
+ 	purex->pur_info.pur_rx_xchg_address = le32_to_cpu(p->rx_xchg_addr);
+ 	purex->pur_info.pur_nphdl = le16_to_cpu(p->nport_handle);
+ 	purex->pur_info.pur_did.b.domain =  p->d_id[2];
+ 	purex->pur_info.pur_did.b.area =  p->d_id[1];
+ 	purex->pur_info.pur_did.b.al_pa =  p->d_id[0];
+ 	purex->pur_info.vp_idx = p->vp_idx;
+ 
+ 	rc = __qla_copy_purex_to_buffer(vha, pkt, rsp, purex->msgp,
+ 		purex->msgp_len);
+ 	if (rc) {
+ 		qla_els_reject_iocb(vha, (*rsp)->qpair, &a);
+ 		qla_enode_free(vha, ptr);
+ 		return;
+ 	}
+ 	beid.al_pa = purex->pur_info.pur_did.b.al_pa;
+ 	beid.area   = purex->pur_info.pur_did.b.area;
+ 	beid.domain = purex->pur_info.pur_did.b.domain;
+ 	host = qla_find_host_by_d_id(vha, beid);
+ 	if (!host) {
+ 		ql_log(ql_log_fatal, vha, 0x508b,
+ 		    "%s Drop ELS due to unable to find host %06x\n",
+ 		    __func__, purex->pur_info.pur_did.b24);
+ 
+ 		qla_els_reject_iocb(vha, (*rsp)->qpair, &a);
+ 		qla_enode_free(vha, ptr);
+ 		return;
+ 	}
+ 
+ 	fcport = qla2x00_find_fcport_by_pid(host, &purex->pur_info.pur_sid);
+ 
+ 	if (host->e_dbell.db_flags != EDB_ACTIVE ||
+ 	    (fcport && fcport->loop_id == FC_NO_LOOP_ID)) {
+ 		ql_dbg(ql_dbg_edif, host, 0x0910c, "%s e_dbell.db_flags =%x %06x\n",
+ 		    __func__, host->e_dbell.db_flags,
+ 		    fcport ? fcport->d_id.b24 : 0);
+ 
+ 		qla_els_reject_iocb(host, (*rsp)->qpair, &a);
+ 		qla_enode_free(host, ptr);
+ 		return;
+ 	}
+ 
+ 	/* add the local enode to the list */
+ 	qla_enode_add(host, ptr);
+ 
+ 	ql_dbg(ql_dbg_edif, host, 0x0910c,
+ 	    "%s COMPLETE purex->pur_info.pur_bytes_rcvd =%xh s:%06x -> d:%06x xchg=%xh\n",
+ 	    __func__, purex->pur_info.pur_bytes_rcvd, purex->pur_info.pur_sid.b24,
+ 	    purex->pur_info.pur_did.b24, p->rx_xchg_addr);
+ 
+ 	qla_edb_eventcreate(host, VND_CMD_AUTH_STATE_ELS_RCVD, sid, 0, NULL);
+ }
+ 
+ static uint16_t  qla_edif_get_sa_index_from_freepool(fc_port_t *fcport, int dir)
+ {
+ 	struct scsi_qla_host *vha = fcport->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	void *sa_id_map;
+ 	unsigned long flags = 0;
+ 	u16 sa_index;
+ 
+ 	ql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x3063,
+ 	    "%s: entry\n", __func__);
+ 
+ 	if (dir)
+ 		sa_id_map = ha->edif_tx_sa_id_map;
+ 	else
+ 		sa_id_map = ha->edif_rx_sa_id_map;
+ 
+ 	spin_lock_irqsave(&ha->sadb_fp_lock, flags);
+ 	sa_index = find_first_zero_bit(sa_id_map, EDIF_NUM_SA_INDEX);
+ 	if (sa_index >=  EDIF_NUM_SA_INDEX) {
+ 		spin_unlock_irqrestore(&ha->sadb_fp_lock, flags);
+ 		return INVALID_EDIF_SA_INDEX;
+ 	}
+ 	set_bit(sa_index, sa_id_map);
+ 	spin_unlock_irqrestore(&ha->sadb_fp_lock, flags);
+ 
+ 	if (dir)
+ 		sa_index += EDIF_TX_SA_INDEX_BASE;
+ 
+ 	ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 	    "%s: index retrieved from free pool %d\n", __func__, sa_index);
+ 
+ 	return sa_index;
+ }
+ 
+ /* find an sadb entry for an nport_handle */
+ static struct edif_sa_index_entry *
+ qla_edif_sadb_find_sa_index_entry(uint16_t nport_handle,
+ 		struct list_head *sa_list)
+ {
+ 	struct edif_sa_index_entry *entry;
+ 	struct edif_sa_index_entry *tentry;
+ 	struct list_head *indx_list = sa_list;
+ 
+ 	list_for_each_entry_safe(entry, tentry, indx_list, next) {
+ 		if (entry->handle == nport_handle)
+ 			return entry;
+ 	}
+ 	return NULL;
+ }
+ 
+ /* remove an sa_index from the nport_handle and return it to the free pool */
+ static int qla_edif_sadb_delete_sa_index(fc_port_t *fcport, uint16_t nport_handle,
+ 		uint16_t sa_index)
+ {
+ 	struct edif_sa_index_entry *entry;
+ 	struct list_head *sa_list;
+ 	int dir = (sa_index < EDIF_TX_SA_INDEX_BASE) ? 0 : 1;
+ 	int slot = 0;
+ 	int free_slot_count = 0;
+ 	scsi_qla_host_t *vha = fcport->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	unsigned long flags = 0;
+ 
+ 	ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 	    "%s: entry\n", __func__);
+ 
+ 	if (dir)
+ 		sa_list = &ha->sadb_tx_index_list;
+ 	else
+ 		sa_list = &ha->sadb_rx_index_list;
+ 
+ 	entry = qla_edif_sadb_find_sa_index_entry(nport_handle, sa_list);
+ 	if (!entry) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "%s: no entry found for nport_handle 0x%x\n",
+ 		    __func__, nport_handle);
+ 		return -1;
+ 	}
+ 
+ 	spin_lock_irqsave(&ha->sadb_lock, flags);
+ 	/*
+ 	 * each tx/rx direction has up to 2 sa indexes/slots. 1 slot for in flight traffic
+ 	 * the other is use at re-key time.
+ 	 */
+ 	for (slot = 0; slot < 2; slot++) {
+ 		if (entry->sa_pair[slot].sa_index == sa_index) {
+ 			entry->sa_pair[slot].sa_index = INVALID_EDIF_SA_INDEX;
+ 			entry->sa_pair[slot].spi = 0;
+ 			free_slot_count++;
+ 			qla_edif_add_sa_index_to_freepool(fcport, dir, sa_index);
+ 		} else if (entry->sa_pair[slot].sa_index == INVALID_EDIF_SA_INDEX) {
+ 			free_slot_count++;
+ 		}
+ 	}
+ 
+ 	if (free_slot_count == 2) {
+ 		list_del(&entry->next);
+ 		kfree(entry);
+ 	}
+ 	spin_unlock_irqrestore(&ha->sadb_lock, flags);
+ 
+ 	ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 	    "%s: sa_index %d removed, free_slot_count: %d\n",
+ 	    __func__, sa_index, free_slot_count);
+ 
+ 	return 0;
+ }
+ 
+ void
+ qla28xx_sa_update_iocb_entry(scsi_qla_host_t *v, struct req_que *req,
+ 	struct sa_update_28xx *pkt)
+ {
+ 	const char *func = "SA_UPDATE_RESPONSE_IOCB";
+ 	srb_t *sp;
+ 	struct edif_sa_ctl *sa_ctl;
+ 	int old_sa_deleted = 1;
+ 	uint16_t nport_handle;
+ 	struct scsi_qla_host *vha;
+ 
+ 	sp = qla2x00_get_sp_from_handle(v, func, req, pkt);
+ 
+ 	if (!sp) {
+ 		ql_dbg(ql_dbg_edif, v, 0x3063,
+ 			"%s: no sp found for pkt\n", __func__);
+ 		return;
+ 	}
+ 	/* use sp->vha due to npiv */
+ 	vha = sp->vha;
+ 
+ 	switch (pkt->flags & (SA_FLAG_INVALIDATE | SA_FLAG_TX)) {
+ 	case 0:
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "%s: EDIF SA UPDATE RX IOCB  vha: 0x%p  index: %d\n",
+ 		    __func__, vha, pkt->sa_index);
+ 		break;
+ 	case 1:
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "%s: EDIF SA DELETE RX IOCB  vha: 0x%p  index: %d\n",
+ 		    __func__, vha, pkt->sa_index);
+ 		break;
+ 	case 2:
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "%s: EDIF SA UPDATE TX IOCB  vha: 0x%p  index: %d\n",
+ 		    __func__, vha, pkt->sa_index);
+ 		break;
+ 	case 3:
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "%s: EDIF SA DELETE TX IOCB  vha: 0x%p  index: %d\n",
+ 		    __func__, vha, pkt->sa_index);
+ 		break;
+ 	}
+ 
+ 	/*
+ 	 * dig the nport handle out of the iocb, fcport->loop_id can not be trusted
+ 	 * to be correct during cleanup sa_update iocbs.
+ 	 */
+ 	nport_handle = sp->fcport->loop_id;
+ 
+ 	ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 	    "%s: %8phN comp status=%x old_sa_info=%x new_sa_info=%x lid %d, index=0x%x pkt_flags %xh hdl=%x\n",
+ 	    __func__, sp->fcport->port_name, pkt->u.comp_sts, pkt->old_sa_info, pkt->new_sa_info,
+ 	    nport_handle, pkt->sa_index, pkt->flags, sp->handle);
+ 
+ 	/* if rx delete, remove the timer */
+ 	if ((pkt->flags & (SA_FLAG_INVALIDATE | SA_FLAG_TX)) ==  SA_FLAG_INVALIDATE) {
+ 		struct edif_list_entry *edif_entry;
+ 
+ 		sp->fcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);
+ 
+ 		edif_entry = qla_edif_list_find_sa_index(sp->fcport, nport_handle);
+ 		if (edif_entry) {
+ 			ql_dbg(ql_dbg_edif, vha, 0x5033,
+ 			    "%s: removing edif_entry %p, new sa_index: 0x%x\n",
+ 			    __func__, edif_entry, pkt->sa_index);
+ 			qla_edif_list_delete_sa_index(sp->fcport, edif_entry);
+ 			del_timer(&edif_entry->timer);
+ 
+ 			ql_dbg(ql_dbg_edif, vha, 0x5033,
+ 			    "%s: releasing edif_entry %p, new sa_index: 0x%x\n",
+ 			    __func__, edif_entry, pkt->sa_index);
+ 
+ 			kfree(edif_entry);
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * if this is a delete for either tx or rx, make sure it succeeded.
+ 	 * The new_sa_info field should be 0xffff on success
+ 	 */
+ 	if (pkt->flags & SA_FLAG_INVALIDATE)
+ 		old_sa_deleted = (le16_to_cpu(pkt->new_sa_info) == 0xffff) ? 1 : 0;
+ 
+ 	/* Process update and delete the same way */
+ 
+ 	/* If this is an sadb cleanup delete, bypass sending events to IPSEC */
+ 	if (sp->flags & SRB_EDIF_CLEANUP_DELETE) {
+ 		sp->fcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "%s: nph 0x%x, sa_index %d removed from fw\n",
+ 		    __func__, sp->fcport->loop_id, pkt->sa_index);
+ 
+ 	} else if ((pkt->entry_status == 0) && (pkt->u.comp_sts == 0) &&
+ 	    old_sa_deleted) {
+ 		/*
+ 		 * Note: Wa are only keeping track of latest SA,
+ 		 * so we know when we can start enableing encryption per I/O.
+ 		 * If all SA's get deleted, let FW reject the IOCB.
+ 
+ 		 * TODO: edif: don't set enabled here I think
+ 		 * TODO: edif: prli complete is where it should be set
+ 		 */
+ 		ql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x3063,
+ 			"SA(%x)updated for s_id %02x%02x%02x\n",
+ 			pkt->new_sa_info,
+ 			pkt->port_id[2], pkt->port_id[1], pkt->port_id[0]);
+ 		sp->fcport->edif.enable = 1;
+ 		if (pkt->flags & SA_FLAG_TX) {
+ 			sp->fcport->edif.tx_sa_set = 1;
+ 			sp->fcport->edif.tx_sa_pending = 0;
+ 			qla_edb_eventcreate(vha, VND_CMD_AUTH_STATE_SAUPDATE_COMPL,
+ 				QL_VND_SA_STAT_SUCCESS,
+ 				QL_VND_TX_SA_KEY, sp->fcport);
+ 		} else {
+ 			sp->fcport->edif.rx_sa_set = 1;
+ 			sp->fcport->edif.rx_sa_pending = 0;
+ 			qla_edb_eventcreate(vha, VND_CMD_AUTH_STATE_SAUPDATE_COMPL,
+ 				QL_VND_SA_STAT_SUCCESS,
+ 				QL_VND_RX_SA_KEY, sp->fcport);
+ 		}
+ 	} else {
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "%s: %8phN SA update FAILED: sa_index: %d, new_sa_info %d, %02x%02x%02x\n",
+ 		    __func__, sp->fcport->port_name, pkt->sa_index, pkt->new_sa_info,
+ 		    pkt->port_id[2], pkt->port_id[1], pkt->port_id[0]);
+ 
+ 		if (pkt->flags & SA_FLAG_TX)
+ 			qla_edb_eventcreate(vha, VND_CMD_AUTH_STATE_SAUPDATE_COMPL,
+ 				(le16_to_cpu(pkt->u.comp_sts) << 16) | QL_VND_SA_STAT_FAILED,
+ 				QL_VND_TX_SA_KEY, sp->fcport);
+ 		else
+ 			qla_edb_eventcreate(vha, VND_CMD_AUTH_STATE_SAUPDATE_COMPL,
+ 				(le16_to_cpu(pkt->u.comp_sts) << 16) | QL_VND_SA_STAT_FAILED,
+ 				QL_VND_RX_SA_KEY, sp->fcport);
+ 	}
+ 
+ 	/* for delete, release sa_ctl, sa_index */
+ 	if (pkt->flags & SA_FLAG_INVALIDATE) {
+ 		/* release the sa_ctl */
+ 		sa_ctl = qla_edif_find_sa_ctl_by_index(sp->fcport,
+ 		    le16_to_cpu(pkt->sa_index), (pkt->flags & SA_FLAG_TX));
+ 		if (sa_ctl &&
+ 		    qla_edif_find_sa_ctl_by_index(sp->fcport, sa_ctl->index,
+ 			(pkt->flags & SA_FLAG_TX)) != NULL) {
+ 			ql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x3063,
+ 			    "%s: freeing sa_ctl for index %d\n",
+ 			    __func__, sa_ctl->index);
+ 			qla_edif_free_sa_ctl(sp->fcport, sa_ctl, sa_ctl->index);
+ 		} else {
+ 			ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 			    "%s: sa_ctl NOT freed, sa_ctl: %p\n",
+ 			    __func__, sa_ctl);
+ 		}
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "%s: freeing sa_index %d, nph: 0x%x\n",
+ 		    __func__, le16_to_cpu(pkt->sa_index), nport_handle);
+ 		qla_edif_sadb_delete_sa_index(sp->fcport, nport_handle,
+ 		    le16_to_cpu(pkt->sa_index));
+ 	/*
+ 	 * check for a failed sa_update and remove
+ 	 * the sadb entry.
+ 	 */
+ 	} else if (pkt->u.comp_sts) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "%s: freeing sa_index %d, nph: 0x%x\n",
+ 		    __func__, pkt->sa_index, nport_handle);
+ 		qla_edif_sadb_delete_sa_index(sp->fcport, nport_handle,
+ 		    le16_to_cpu(pkt->sa_index));
+ 	}
+ 
+ 	sp->done(sp, 0);
+ }
+ 
+ /**********************************************
+  * edif update/delete sa_index list functions *
+  **********************************************/
+ 
+ /* clear the edif_indx_list for this port */
+ void qla_edif_list_del(fc_port_t *fcport)
+ {
+ 	struct edif_list_entry *indx_lst;
+ 	struct edif_list_entry *tindx_lst;
+ 	struct list_head *indx_list = &fcport->edif.edif_indx_list;
+ 	unsigned long flags = 0;
+ 
+ 	spin_lock_irqsave(&fcport->edif.indx_list_lock, flags);
+ 	list_for_each_entry_safe(indx_lst, tindx_lst, indx_list, next) {
+ 		list_del(&indx_lst->next);
+ 		kfree(indx_lst);
+ 	}
+ 	spin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);
+ }
+ 
+ /******************
+  * SADB functions *
+  ******************/
+ 
+ /* allocate/retrieve an sa_index for a given spi */
+ static uint16_t qla_edif_sadb_get_sa_index(fc_port_t *fcport,
+ 		struct qla_sa_update_frame *sa_frame)
+ {
+ 	struct edif_sa_index_entry *entry;
+ 	struct list_head *sa_list;
+ 	uint16_t sa_index;
+ 	int dir = sa_frame->flags & SAU_FLG_TX;
+ 	int slot = 0;
+ 	int free_slot = -1;
+ 	scsi_qla_host_t *vha = fcport->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	unsigned long flags = 0;
+ 	uint16_t nport_handle = fcport->loop_id;
+ 
+ 	ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 	    "%s: entry  fc_port: %p, nport_handle: 0x%x\n",
+ 	    __func__, fcport, nport_handle);
+ 
+ 	if (dir)
+ 		sa_list = &ha->sadb_tx_index_list;
+ 	else
+ 		sa_list = &ha->sadb_rx_index_list;
+ 
+ 	entry = qla_edif_sadb_find_sa_index_entry(nport_handle, sa_list);
+ 	if (!entry) {
+ 		if ((sa_frame->flags & (SAU_FLG_TX | SAU_FLG_INV)) == SAU_FLG_INV) {
+ 			ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 			    "%s: rx delete request with no entry\n", __func__);
+ 			return RX_DELETE_NO_EDIF_SA_INDEX;
+ 		}
+ 
+ 		/* if there is no entry for this nport, add one */
+ 		entry = kzalloc((sizeof(struct edif_sa_index_entry)), GFP_ATOMIC);
+ 		if (!entry)
+ 			return INVALID_EDIF_SA_INDEX;
+ 
+ 		sa_index = qla_edif_get_sa_index_from_freepool(fcport, dir);
+ 		if (sa_index == INVALID_EDIF_SA_INDEX) {
+ 			kfree(entry);
+ 			return INVALID_EDIF_SA_INDEX;
+ 		}
+ 
+ 		INIT_LIST_HEAD(&entry->next);
+ 		entry->handle = nport_handle;
+ 		entry->fcport = fcport;
+ 		entry->sa_pair[0].spi = sa_frame->spi;
+ 		entry->sa_pair[0].sa_index = sa_index;
+ 		entry->sa_pair[1].spi = 0;
+ 		entry->sa_pair[1].sa_index = INVALID_EDIF_SA_INDEX;
+ 		spin_lock_irqsave(&ha->sadb_lock, flags);
+ 		list_add_tail(&entry->next, sa_list);
+ 		spin_unlock_irqrestore(&ha->sadb_lock, flags);
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "%s: Created new sadb entry for nport_handle 0x%x, spi 0x%x, returning sa_index %d\n",
+ 		    __func__, nport_handle, sa_frame->spi, sa_index);
+ 
+ 		return sa_index;
+ 	}
+ 
+ 	spin_lock_irqsave(&ha->sadb_lock, flags);
+ 
+ 	/* see if we already have an entry for this spi */
+ 	for (slot = 0; slot < 2; slot++) {
+ 		if (entry->sa_pair[slot].sa_index == INVALID_EDIF_SA_INDEX) {
+ 			free_slot = slot;
+ 		} else {
+ 			if (entry->sa_pair[slot].spi == sa_frame->spi) {
+ 				spin_unlock_irqrestore(&ha->sadb_lock, flags);
+ 				ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 				    "%s: sadb slot %d entry for lid 0x%x, spi 0x%x found, sa_index %d\n",
+ 				    __func__, slot, entry->handle, sa_frame->spi,
+ 				    entry->sa_pair[slot].sa_index);
+ 				return entry->sa_pair[slot].sa_index;
+ 			}
+ 		}
+ 	}
+ 	spin_unlock_irqrestore(&ha->sadb_lock, flags);
+ 
+ 	/* both slots are used */
+ 	if (free_slot == -1) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "%s: WARNING: No free slots in sadb for nport_handle 0x%x, spi: 0x%x\n",
+ 		    __func__, entry->handle, sa_frame->spi);
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "%s: Slot 0  spi: 0x%x  sa_index: %d,  Slot 1  spi: 0x%x  sa_index: %d\n",
+ 		    __func__, entry->sa_pair[0].spi, entry->sa_pair[0].sa_index,
+ 		    entry->sa_pair[1].spi, entry->sa_pair[1].sa_index);
+ 
+ 		return INVALID_EDIF_SA_INDEX;
+ 	}
+ 
+ 	/* there is at least one free slot, use it */
+ 	sa_index = qla_edif_get_sa_index_from_freepool(fcport, dir);
+ 	if (sa_index == INVALID_EDIF_SA_INDEX) {
+ 		ql_dbg(ql_dbg_edif, fcport->vha, 0x3063,
+ 		    "%s: empty freepool!!\n", __func__);
+ 		return INVALID_EDIF_SA_INDEX;
+ 	}
+ 
+ 	spin_lock_irqsave(&ha->sadb_lock, flags);
+ 	entry->sa_pair[free_slot].spi = sa_frame->spi;
+ 	entry->sa_pair[free_slot].sa_index = sa_index;
+ 	spin_unlock_irqrestore(&ha->sadb_lock, flags);
+ 	ql_dbg(ql_dbg_edif, fcport->vha, 0x3063,
+ 	    "%s: sadb slot %d entry for nport_handle 0x%x, spi 0x%x added, returning sa_index %d\n",
+ 	    __func__, free_slot, entry->handle, sa_frame->spi, sa_index);
+ 
+ 	return sa_index;
+ }
+ 
+ /* release any sadb entries -- only done at teardown */
+ void qla_edif_sadb_release(struct qla_hw_data *ha)
+ {
+ 	struct list_head *pos;
+ 	struct list_head *tmp;
+ 	struct edif_sa_index_entry *entry;
+ 
+ 	list_for_each_safe(pos, tmp, &ha->sadb_rx_index_list) {
+ 		entry = list_entry(pos, struct edif_sa_index_entry, next);
+ 		list_del(&entry->next);
+ 		kfree(entry);
+ 	}
+ 
+ 	list_for_each_safe(pos, tmp, &ha->sadb_tx_index_list) {
+ 		entry = list_entry(pos, struct edif_sa_index_entry, next);
+ 		list_del(&entry->next);
+ 		kfree(entry);
+ 	}
+ }
+ 
+ /**************************
+  * sadb freepool functions
+  **************************/
+ 
+ /* build the rx and tx sa_index free pools -- only done at fcport init */
+ int qla_edif_sadb_build_free_pool(struct qla_hw_data *ha)
+ {
+ 	ha->edif_tx_sa_id_map =
+ 	    kcalloc(BITS_TO_LONGS(EDIF_NUM_SA_INDEX), sizeof(long), GFP_KERNEL);
+ 
+ 	if (!ha->edif_tx_sa_id_map) {
+ 		ql_log_pci(ql_log_fatal, ha->pdev, 0x0009,
+ 		    "Unable to allocate memory for sadb tx.\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	ha->edif_rx_sa_id_map =
+ 	    kcalloc(BITS_TO_LONGS(EDIF_NUM_SA_INDEX), sizeof(long), GFP_KERNEL);
+ 	if (!ha->edif_rx_sa_id_map) {
+ 		kfree(ha->edif_tx_sa_id_map);
+ 		ha->edif_tx_sa_id_map = NULL;
+ 		ql_log_pci(ql_log_fatal, ha->pdev, 0x0009,
+ 		    "Unable to allocate memory for sadb rx.\n");
+ 		return -ENOMEM;
+ 	}
+ 	return 0;
+ }
+ 
+ /* release the free pool - only done during fcport teardown */
+ void qla_edif_sadb_release_free_pool(struct qla_hw_data *ha)
+ {
+ 	kfree(ha->edif_tx_sa_id_map);
+ 	ha->edif_tx_sa_id_map = NULL;
+ 	kfree(ha->edif_rx_sa_id_map);
+ 	ha->edif_rx_sa_id_map = NULL;
+ }
+ 
+ static void __chk_edif_rx_sa_delete_pending(scsi_qla_host_t *vha,
+ 		fc_port_t *fcport, uint32_t handle, uint16_t sa_index)
+ {
+ 	struct edif_list_entry *edif_entry;
+ 	struct edif_sa_ctl *sa_ctl;
+ 	uint16_t delete_sa_index = INVALID_EDIF_SA_INDEX;
+ 	unsigned long flags = 0;
+ 	uint16_t nport_handle = fcport->loop_id;
+ 	uint16_t cached_nport_handle;
+ 
+ 	spin_lock_irqsave(&fcport->edif.indx_list_lock, flags);
+ 	edif_entry = qla_edif_list_find_sa_index(fcport, nport_handle);
+ 	if (!edif_entry) {
+ 		spin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);
+ 		return;		/* no pending delete for this handle */
+ 	}
+ 
+ 	/*
+ 	 * check for no pending delete for this index or iocb does not
+ 	 * match rx sa_index
+ 	 */
+ 	if (edif_entry->delete_sa_index == INVALID_EDIF_SA_INDEX ||
+ 	    edif_entry->update_sa_index != sa_index) {
+ 		spin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * wait until we have seen at least EDIF_DELAY_COUNT transfers before
+ 	 * queueing RX delete
+ 	 */
+ 	if (edif_entry->count++ < EDIF_RX_DELETE_FILTER_COUNT) {
+ 		spin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);
+ 		return;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_edif, vha, 0x5033,
+ 	    "%s: invalidating delete_sa_index,  update_sa_index: 0x%x sa_index: 0x%x, delete_sa_index: 0x%x\n",
+ 	    __func__, edif_entry->update_sa_index, sa_index, edif_entry->delete_sa_index);
+ 
+ 	delete_sa_index = edif_entry->delete_sa_index;
+ 	edif_entry->delete_sa_index = INVALID_EDIF_SA_INDEX;
+ 	cached_nport_handle = edif_entry->handle;
+ 	spin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);
+ 
+ 	/* sanity check on the nport handle */
+ 	if (nport_handle != cached_nport_handle) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "%s: POST SA DELETE nport_handle mismatch: lid: 0x%x, edif_entry nph: 0x%x\n",
+ 		    __func__, nport_handle, cached_nport_handle);
+ 	}
+ 
+ 	/* find the sa_ctl for the delete and schedule the delete */
+ 	sa_ctl = qla_edif_find_sa_ctl_by_index(fcport, delete_sa_index, 0);
+ 	if (sa_ctl) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "%s: POST SA DELETE sa_ctl: %p, index recvd %d\n",
+ 		    __func__, sa_ctl, sa_index);
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "delete index %d, update index: %d, nport handle: 0x%x, handle: 0x%x\n",
+ 		    delete_sa_index,
+ 		    edif_entry->update_sa_index, nport_handle, handle);
+ 
+ 		sa_ctl->flags = EDIF_SA_CTL_FLG_DEL;
+ 		set_bit(EDIF_SA_CTL_REPL, &sa_ctl->state);
+ 		qla_post_sa_replace_work(fcport->vha, fcport,
+ 		    nport_handle, sa_ctl);
+ 	} else {
+ 		ql_dbg(ql_dbg_edif, vha, 0x3063,
+ 		    "%s: POST SA DELETE sa_ctl not found for delete_sa_index: %d\n",
+ 		    __func__, delete_sa_index);
+ 	}
+ }
+ 
+ void qla_chk_edif_rx_sa_delete_pending(scsi_qla_host_t *vha,
+ 		srb_t *sp, struct sts_entry_24xx *sts24)
+ {
+ 	fc_port_t *fcport = sp->fcport;
+ 	/* sa_index used by this iocb */
+ 	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
+ 	uint32_t handle;
+ 
+ 	handle = (uint32_t)LSW(sts24->handle);
+ 
+ 	/* find out if this status iosb is for a scsi read */
+ 	if (cmd->sc_data_direction != DMA_FROM_DEVICE)
+ 		return;
+ 
+ 	return __chk_edif_rx_sa_delete_pending(vha, fcport, handle,
+ 	   le16_to_cpu(sts24->edif_sa_index));
+ }
+ 
+ void qlt_chk_edif_rx_sa_delete_pending(scsi_qla_host_t *vha, fc_port_t *fcport,
+ 		struct ctio7_from_24xx *pkt)
+ {
+ 	__chk_edif_rx_sa_delete_pending(vha, fcport,
+ 	    pkt->handle, le16_to_cpu(pkt->edif_sa_index));
+ }
+ 
+ static void qla_parse_auth_els_ctl(struct srb *sp)
+ {
+ 	struct qla_els_pt_arg *a = &sp->u.bsg_cmd.u.els_arg;
+ 	struct bsg_job *bsg_job = sp->u.bsg_cmd.bsg_job;
+ 	struct fc_bsg_request *request = bsg_job->request;
+ 	struct qla_bsg_auth_els_request *p =
+ 	    (struct qla_bsg_auth_els_request *)bsg_job->request;
+ 
+ 	a->tx_len = a->tx_byte_count = sp->remap.req.len;
+ 	a->tx_addr = sp->remap.req.dma;
+ 	a->rx_len = a->rx_byte_count = sp->remap.rsp.len;
+ 	a->rx_addr = sp->remap.rsp.dma;
+ 
+ 	if (p->e.sub_cmd == SEND_ELS_REPLY) {
+ 		a->control_flags = p->e.extra_control_flags << 13;
+ 		a->rx_xchg_address = cpu_to_le32(p->e.extra_rx_xchg_address);
+ 		if (p->e.extra_control_flags == BSG_CTL_FLAG_LS_ACC)
+ 			a->els_opcode = ELS_LS_ACC;
+ 		else if (p->e.extra_control_flags == BSG_CTL_FLAG_LS_RJT)
+ 			a->els_opcode = ELS_LS_RJT;
+ 	}
+ 	a->did = sp->fcport->d_id;
+ 	a->els_opcode =  request->rqst_data.h_els.command_code;
+ 	a->nport_handle = cpu_to_le16(sp->fcport->loop_id);
+ 	a->vp_idx = sp->vha->vp_idx;
+ }
+ 
+ int qla_edif_process_els(scsi_qla_host_t *vha, struct bsg_job *bsg_job)
+ {
+ 	struct fc_bsg_request *bsg_request = bsg_job->request;
+ 	struct fc_bsg_reply *bsg_reply = bsg_job->reply;
+ 	fc_port_t *fcport = NULL;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	srb_t *sp;
+ 	int rval =  (DID_ERROR << 16);
+ 	port_id_t d_id;
+ 	struct qla_bsg_auth_els_request *p =
+ 	    (struct qla_bsg_auth_els_request *)bsg_job->request;
+ 
+ 	d_id.b.al_pa = bsg_request->rqst_data.h_els.port_id[2];
+ 	d_id.b.area = bsg_request->rqst_data.h_els.port_id[1];
+ 	d_id.b.domain = bsg_request->rqst_data.h_els.port_id[0];
+ 
+ 	/* find matching d_id in fcport list */
+ 	fcport = qla2x00_find_fcport_by_pid(vha, &d_id);
+ 	if (!fcport) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x911a,
+ 		    "%s fcport not find online portid=%06x.\n",
+ 		    __func__, d_id.b24);
+ 		SET_DID_STATUS(bsg_reply->result, DID_ERROR);
+ 		return -EIO;
+ 	}
+ 
+ 	if (qla_bsg_check(vha, bsg_job, fcport))
+ 		return 0;
+ 
+ 	if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 		ql_dbg(ql_dbg_edif, vha, 0x910d,
+ 		    "%s ELS code %x, no loop id.\n", __func__,
+ 		    bsg_request->rqst_data.r_els.els_code);
+ 		SET_DID_STATUS(bsg_reply->result, DID_BAD_TARGET);
+ 		return -ENXIO;
+ 	}
+ 
+ 	if (!vha->flags.online) {
+ 		ql_log(ql_log_warn, vha, 0x7005, "Host not online.\n");
+ 		SET_DID_STATUS(bsg_reply->result, DID_BAD_TARGET);
+ 		rval = -EIO;
+ 		goto done;
+ 	}
+ 
+ 	/* pass through is supported only for ISP 4Gb or higher */
+ 	if (!IS_FWI2_CAPABLE(ha)) {
+ 		ql_dbg(ql_dbg_user, vha, 0x7001,
+ 		    "ELS passthru not supported for ISP23xx based adapters.\n");
+ 		SET_DID_STATUS(bsg_reply->result, DID_BAD_TARGET);
+ 		rval = -EPERM;
+ 		goto done;
+ 	}
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp) {
+ 		ql_dbg(ql_dbg_user, vha, 0x7004,
+ 		    "Failed get sp pid=%06x\n", fcport->d_id.b24);
+ 		rval = -ENOMEM;
+ 		SET_DID_STATUS(bsg_reply->result, DID_IMM_RETRY);
+ 		goto done;
+ 	}
+ 
+ 	sp->remap.req.len = bsg_job->request_payload.payload_len;
+ 	sp->remap.req.buf = dma_pool_alloc(ha->purex_dma_pool,
+ 	    GFP_KERNEL, &sp->remap.req.dma);
+ 	if (!sp->remap.req.buf) {
+ 		ql_dbg(ql_dbg_user, vha, 0x7005,
+ 		    "Failed allocate request dma len=%x\n",
+ 		    bsg_job->request_payload.payload_len);
+ 		rval = -ENOMEM;
+ 		SET_DID_STATUS(bsg_reply->result, DID_IMM_RETRY);
+ 		goto done_free_sp;
+ 	}
+ 
+ 	sp->remap.rsp.len = bsg_job->reply_payload.payload_len;
+ 	sp->remap.rsp.buf = dma_pool_alloc(ha->purex_dma_pool,
+ 	    GFP_KERNEL, &sp->remap.rsp.dma);
+ 	if (!sp->remap.rsp.buf) {
+ 		ql_dbg(ql_dbg_user, vha, 0x7006,
+ 		    "Failed allocate response dma len=%x\n",
+ 		    bsg_job->reply_payload.payload_len);
+ 		rval = -ENOMEM;
+ 		SET_DID_STATUS(bsg_reply->result, DID_IMM_RETRY);
+ 		goto done_free_remap_req;
+ 	}
+ 	sg_copy_to_buffer(bsg_job->request_payload.sg_list,
+ 	    bsg_job->request_payload.sg_cnt, sp->remap.req.buf,
+ 	    sp->remap.req.len);
+ 	sp->remap.remapped = true;
+ 
+ 	sp->type = SRB_ELS_CMD_HST_NOLOGIN;
+ 	sp->name = "SPCN_BSG_HST_NOLOGIN";
+ 	sp->u.bsg_cmd.bsg_job = bsg_job;
+ 	qla_parse_auth_els_ctl(sp);
+ 
+ 	sp->free = qla2x00_bsg_sp_free;
+ 	sp->done = qla2x00_bsg_job_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 
+ 	ql_dbg(ql_dbg_edif, vha, 0x700a,
+ 	    "%s %s %8phN xchg %x ctlflag %x hdl %x reqlen %xh bsg ptr %p\n",
+ 	    __func__, sc_to_str(p->e.sub_cmd), fcport->port_name,
+ 	    p->e.extra_rx_xchg_address, p->e.extra_control_flags,
+ 	    sp->handle, sp->remap.req.len, bsg_job);
+ 
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_log(ql_log_warn, vha, 0x700e,
+ 		    "qla2x00_start_sp failed = %d\n", rval);
+ 		SET_DID_STATUS(bsg_reply->result, DID_IMM_RETRY);
+ 		rval = -EIO;
+ 		goto done_free_remap_rsp;
+ 	}
+ 	return rval;
+ 
+ done_free_remap_rsp:
+ 	dma_pool_free(ha->purex_dma_pool, sp->remap.rsp.buf,
+ 	    sp->remap.rsp.dma);
+ done_free_remap_req:
+ 	dma_pool_free(ha->purex_dma_pool, sp->remap.req.buf,
+ 	    sp->remap.req.dma);
+ done_free_sp:
+ 	qla2x00_rel_sp(sp);
+ 
+ done:
+ 	return rval;
+ }
+ 
+ void qla_edif_sess_down(struct scsi_qla_host *vha, struct fc_port *sess)
+ {
+ 	if (sess->edif.app_sess_online && vha->e_dbell.db_flags & EDB_ACTIVE) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xf09c,
+ 			"%s: sess %8phN send port_offline event\n",
+ 			__func__, sess->port_name);
+ 		sess->edif.app_sess_online = 0;
+ 		qla_edb_eventcreate(vha, VND_CMD_AUTH_STATE_SESSION_SHUTDOWN,
+ 		    sess->d_id.b24, 0, sess);
+ 		qla2x00_post_aen_work(vha, FCH_EVT_PORT_OFFLINE, sess->d_id.b24);
  	}
  }
++>>>>>>> 7a09e8d92c6d (scsi: qla2xxx: edif: Add doorbell notification for app)
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index 50ae84979282,4fc20491898d..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -950,10 -975,23 +950,29 @@@ extern void qla_nvme_abort_process_comp
  
  /* nvme.c */
  void qla_nvme_unregister_remote_port(struct fc_port *fcport);
++<<<<<<< HEAD
++=======
+ 
+ /* qla_edif.c */
+ fc_port_t *qla2x00_find_fcport_by_pid(scsi_qla_host_t *vha, port_id_t *id);
+ void qla_edb_eventcreate(scsi_qla_host_t *vha, uint32_t dbtype, uint32_t data, uint32_t data2,
+ 		fc_port_t *fcport);
++>>>>>>> 7a09e8d92c6d (scsi: qla2xxx: edif: Add doorbell notification for app)
  void qla_edb_stop(scsi_qla_host_t *vha);
+ ssize_t edif_doorbell_show(struct device *dev, struct device_attribute *attr, char *buf);
  int32_t qla_edif_app_mgmt(struct bsg_job *bsg_job);
  void qla_enode_init(scsi_qla_host_t *vha);
  void qla_enode_stop(scsi_qla_host_t *vha);
++<<<<<<< HEAD
++=======
+ void qla_edif_flush_sa_ctl_lists(fc_port_t *fcport);
+ void qla_edb_init(scsi_qla_host_t *vha);
+ void qla24xx_sa_update_iocb(srb_t *sp, struct sa_update_28xx *sa_update_iocb);
+ void qla24xx_sa_replace_iocb(srb_t *sp, struct sa_update_28xx *sa_update_iocb);
+ void qla24xx_auth_els(scsi_qla_host_t *vha, void **pkt, struct rsp_que **rsp);
+ void qla28xx_sa_update_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,
+ 		struct sa_update_28xx *pkt);
++>>>>>>> 7a09e8d92c6d (scsi: qla2xxx: edif: Add doorbell notification for app)
  void qla_handle_els_plogi_done(scsi_qla_host_t *vha, struct event_arg *ea);
  
  #define QLA2XX_HW_ERROR			BIT_0
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 2a2edf816619,46dddc1dba9b..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -1418,6 -1436,60 +1418,63 @@@ void __qla24xx_handle_gpdb_event(scsi_q
  	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
  }
  
++<<<<<<< HEAD
++=======
+ static int	qla_chk_secure_login(scsi_qla_host_t	*vha, fc_port_t *fcport,
+ 	struct port_database_24xx *pd)
+ {
+ 	int rc = 0;
+ 
+ 	if (pd->secure_login) {
+ 		ql_dbg(ql_dbg_disc, vha, 0x104d,
+ 		    "Secure Login established on %8phC\n",
+ 		    fcport->port_name);
+ 		fcport->edif.secured_login = 1;
+ 		fcport->edif.non_secured_login = 0;
+ 		fcport->flags |= FCF_FCSP_DEVICE;
+ 	} else {
+ 		ql_dbg(ql_dbg_disc, vha, 0x104d,
+ 		    "non-Secure Login %8phC",
+ 		    fcport->port_name);
+ 		fcport->edif.secured_login = 0;
+ 		fcport->edif.non_secured_login = 1;
+ 	}
+ 	if (vha->hw->flags.edif_enabled) {
+ 		if (fcport->flags & FCF_FCSP_DEVICE) {
+ 			qla2x00_set_fcport_disc_state(fcport, DSC_LOGIN_AUTH_PEND);
+ 			/* Start edif prli timer & ring doorbell for app */
+ 			fcport->edif.rx_sa_set = 0;
+ 			fcport->edif.tx_sa_set = 0;
+ 			fcport->edif.rx_sa_pending = 0;
+ 			fcport->edif.tx_sa_pending = 0;
+ 
+ 			qla2x00_post_aen_work(vha, FCH_EVT_PORT_ONLINE,
+ 			    fcport->d_id.b24);
+ 
+ 			if (vha->e_dbell.db_flags ==  EDB_ACTIVE) {
+ 				ql_dbg(ql_dbg_disc, vha, 0x20ef,
+ 				    "%s %d %8phC EDIF: post DB_AUTH: AUTH needed\n",
+ 				    __func__, __LINE__, fcport->port_name);
+ 				fcport->edif.app_started = 1;
+ 				fcport->edif.app_sess_online = 1;
+ 
+ 				qla_edb_eventcreate(vha, VND_CMD_AUTH_STATE_NEEDED,
+ 				    fcport->d_id.b24, 0, fcport);
+ 			}
+ 
+ 			rc = 1;
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0x2117,
+ 			    "%s %d %8phC post prli\n",
+ 			    __func__, __LINE__, fcport->port_name);
+ 			qla24xx_post_prli_work(vha, fcport);
+ 			rc = 1;
+ 		}
+ 	}
+ 	return rc;
+ }
+ 
++>>>>>>> 7a09e8d92c6d (scsi: qla2xxx: edif: Add doorbell notification for app)
  static
  void qla24xx_handle_gpdb_event(scsi_qla_host_t *vha, struct event_arg *ea)
  {
diff --cc drivers/scsi/qla2xxx/qla_os.c
index fbb549c49362,0234cd90bb01..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -3356,6 -3487,8 +3356,11 @@@ skip_dpc
  	return 0;
  
  probe_failed:
++<<<<<<< HEAD
++=======
+ 	qla_enode_stop(base_vha);
+ 	qla_edb_stop(base_vha);
++>>>>>>> 7a09e8d92c6d (scsi: qla2xxx: edif: Add doorbell notification for app)
  	if (base_vha->gnl.l) {
  		dma_free_coherent(&ha->pdev->dev, base_vha->gnl.size,
  				base_vha->gnl.l, base_vha->gnl.ldma);
@@@ -3654,6 -3791,8 +3659,11 @@@ qla2x00_remove_one(struct pci_dev *pdev
  		base_vha->gnl.size, base_vha->gnl.l, base_vha->gnl.ldma);
  
  	base_vha->gnl.l = NULL;
++<<<<<<< HEAD
++=======
+ 	qla_enode_stop(base_vha);
+ 	qla_edb_stop(base_vha);
++>>>>>>> 7a09e8d92c6d (scsi: qla2xxx: edif: Add doorbell notification for app)
  
  	vfree(base_vha->scan.l);
  
@@@ -4731,6 -4918,9 +4741,12 @@@ struct scsi_qla_host *qla2x00_create_ho
  	spin_lock_init(&vha->cmd_list_lock);
  	init_waitqueue_head(&vha->fcport_waitQ);
  	init_waitqueue_head(&vha->vref_waitq);
++<<<<<<< HEAD
++=======
+ 	qla_enode_init(vha);
+ 	qla_edb_init(vha);
+ 
++>>>>>>> 7a09e8d92c6d (scsi: qla2xxx: edif: Add doorbell notification for app)
  
  	vha->gnl.size = sizeof(struct get_name_list_extended) *
  			(ha->max_loop_id + 1);
diff --cc drivers/scsi/qla2xxx/qla_target.c
index cc3934c87715,77b54e9ac0a1..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -588,6 -576,18 +588,21 @@@ static void qla2x00_async_nack_sp_done(
  		sp->fcport->logout_on_delete = 1;
  		sp->fcport->plogi_nack_done_deadline = jiffies + HZ;
  		sp->fcport->send_els_logo = 0;
++<<<<<<< HEAD
++=======
+ 
+ 		if (sp->fcport->flags & FCF_FCSP_DEVICE) {
+ 			ql_dbg(ql_dbg_edif, vha, 0x20ef,
+ 			    "%s %8phC edif: PLOGI- AUTH WAIT\n", __func__,
+ 			    sp->fcport->port_name);
+ 			qla2x00_set_fcport_disc_state(sp->fcport,
+ 			    DSC_LOGIN_AUTH_PEND);
+ 			qla2x00_post_aen_work(vha, FCH_EVT_PORT_ONLINE,
+ 			    sp->fcport->d_id.b24);
+ 			qla_edb_eventcreate(vha, VND_CMD_AUTH_STATE_NEEDED, sp->fcport->d_id.b24,
+ 			    0, sp->fcport);
+ 		}
++>>>>>>> 7a09e8d92c6d (scsi: qla2xxx: edif: Add doorbell notification for app)
  		break;
  
  	case SRB_NACK_PRLI:
* Unmerged path drivers/scsi/qla2xxx/qla_attr.c
diff --git a/drivers/scsi/qla2xxx/qla_bsg.c b/drivers/scsi/qla2xxx/qla_bsg.c
index 921f5a78b4d1..481d7de231d6 100644
--- a/drivers/scsi/qla2xxx/qla_bsg.c
+++ b/drivers/scsi/qla2xxx/qla_bsg.c
@@ -2769,10 +2769,13 @@ qla2x00_manage_host_port(struct bsg_job *bsg_job)
 }
 
 static int
-qla2x00_process_vendor_specific(struct bsg_job *bsg_job)
+qla2x00_process_vendor_specific(struct scsi_qla_host *vha, struct bsg_job *bsg_job)
 {
 	struct fc_bsg_request *bsg_request = bsg_job->request;
 
+	ql_dbg(ql_dbg_edif, vha, 0x911b, "%s FC_BSG_HST_VENDOR cmd[0]=0x%x\n",
+	    __func__, bsg_request->rqst_data.h_vendor.vendor_cmd[0]);
+
 	switch (bsg_request->rqst_data.h_vendor.vendor_cmd[0]) {
 	case QL_VND_LOOPBACK:
 		return qla2x00_process_loopback(bsg_job);
@@ -2901,12 +2904,19 @@ qla24xx_bsg_request(struct bsg_job *bsg_job)
 		ql_dbg(ql_dbg_user, vha, 0x709f,
 		    "BSG: ISP abort active/needed -- cmd=%d.\n",
 		    bsg_request->msgcode);
+		SET_DID_STATUS(bsg_reply->result, DID_ERROR);
 		return -EBUSY;
 	}
 
+	if (test_bit(PFLG_DRIVER_REMOVING, &vha->pci_flags)) {
+		SET_DID_STATUS(bsg_reply->result, DID_ERROR);
+		return -EIO;
+	}
+
 skip_chip_chk:
-	ql_dbg(ql_dbg_user, vha, 0x7000,
-	    "Entered %s msgcode=0x%x.\n", __func__, bsg_request->msgcode);
+	ql_dbg(ql_dbg_user + ql_dbg_verbose, vha, 0x7000,
+	    "Entered %s msgcode=0x%x. bsg ptr %px\n",
+	    __func__, bsg_request->msgcode, bsg_job);
 
 	switch (bsg_request->msgcode) {
 	case FC_BSG_RPT_ELS:
@@ -2917,7 +2927,7 @@ qla24xx_bsg_request(struct bsg_job *bsg_job)
 		ret = qla2x00_process_ct(bsg_job);
 		break;
 	case FC_BSG_HST_VENDOR:
-		ret = qla2x00_process_vendor_specific(bsg_job);
+		ret = qla2x00_process_vendor_specific(vha, bsg_job);
 		break;
 	case FC_BSG_HST_ADD_RPORT:
 	case FC_BSG_HST_DEL_RPORT:
@@ -2926,6 +2936,10 @@ qla24xx_bsg_request(struct bsg_job *bsg_job)
 		ql_log(ql_log_warn, vha, 0x705a, "Unsupported BSG request.\n");
 		break;
 	}
+
+	ql_dbg(ql_dbg_user + ql_dbg_verbose, vha, 0x7000,
+	    "%s done with return %x\n", __func__, ret);
+
 	return ret;
 }
 
@@ -2940,6 +2954,8 @@ qla24xx_bsg_timeout(struct bsg_job *bsg_job)
 	unsigned long flags;
 	struct req_que *req;
 
+	ql_log(ql_log_info, vha, 0x708b, "%s CMD timeout. bsg ptr %p.\n",
+	    __func__, bsg_job);
 	/* find the bsg job from the active list of commands */
 	spin_lock_irqsave(&ha->hardware_lock, flags);
 	for (que = 0; que < ha->max_req_queues; que++) {
* Unmerged path drivers/scsi/qla2xxx/qla_edif.c
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
