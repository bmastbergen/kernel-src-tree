i2c: busses: Use fallthrough pseudo-keyword

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Gustavo A. R. Silva <gustavoars@kernel.org>
commit 4db7e1786db505eee86e6301cd42967f4da43be8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/4db7e178.failed

Replace the existing /* fall through */ comments and its variants with
the new pseudo-keyword macro fallthrough[1].

[1] https://www.kernel.org/doc/html/v5.7/process/deprecated.html?highlight=fallthrough#implicit-switch-case-fall-through

	Acked-by: Baruch Siach <baruch@tkos.co.il>
	Reviewed-by: Jean Delvare <jdelvare@suse.de>
	Reviewed-by: Brendan Higgins <brendanhiggins@google.com>
	Reviewed-by: Gregory CLEMENT <gregory.clement@bootlin.com>
	Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
	Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
	Signed-off-by: Wolfram Sang <wsa@kernel.org>
(cherry picked from commit 4db7e1786db505eee86e6301cd42967f4da43be8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/busses/i2c-amd8111.c
#	drivers/i2c/busses/i2c-aspeed.c
#	drivers/i2c/busses/i2c-synquacer.c
diff --cc drivers/i2c/busses/i2c-amd8111.c
index 95a80a8f81b5,34862ad3423e..000000000000
--- a/drivers/i2c/busses/i2c-amd8111.c
+++ b/drivers/i2c/busses/i2c-amd8111.c
@@@ -384,6 -381,7 +384,10 @@@ static s32 amd8111_access(struct i2c_ad
  			if (status)
  				return status;
  			len = min_t(u8, len, I2C_SMBUS_BLOCK_MAX);
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> 4db7e1786db5 (i2c: busses: Use fallthrough pseudo-keyword)
  		case I2C_SMBUS_I2C_BLOCK_DATA:
  			for (i = 0; i < len; i++) {
  				status = amd_ec_read(smbus, AMD_SMB_DATA + i,
diff --cc drivers/i2c/busses/i2c-aspeed.c
index 60e4d0e939a3,31268074c422..000000000000
--- a/drivers/i2c/busses/i2c-aspeed.c
+++ b/drivers/i2c/busses/i2c-aspeed.c
@@@ -451,15 -496,15 +451,20 @@@ static bool aspeed_i2c_master_irq(struc
  	switch (bus->master_state) {
  	case ASPEED_I2C_MASTER_TX:
  		if (unlikely(irq_status & ASPEED_I2CD_INTR_TX_NAK)) {
 -			dev_dbg(bus->dev, "slave NACKed TX\n");
 -			irq_handled |= ASPEED_I2CD_INTR_TX_NAK;
 +			dev_dbg(bus->dev, "slave NACKed TX");
 +			status_ack |= ASPEED_I2CD_INTR_TX_NAK;
  			goto error_and_stop;
  		} else if (unlikely(!(irq_status & ASPEED_I2CD_INTR_TX_ACK))) {
 -			dev_err(bus->dev, "slave failed to ACK TX\n");
 +			dev_err(bus->dev, "slave failed to ACK TX");
  			goto error_and_stop;
  		}
++<<<<<<< HEAD
 +		status_ack |= ASPEED_I2CD_INTR_TX_ACK;
 +		/* fallthrough intended */
++=======
+ 		irq_handled |= ASPEED_I2CD_INTR_TX_ACK;
+ 		fallthrough;
++>>>>>>> 4db7e1786db5 (i2c: busses: Use fallthrough pseudo-keyword)
  	case ASPEED_I2C_MASTER_TX_FIRST:
  		if (bus->buf_index < msg->len) {
  			bus->master_state = ASPEED_I2C_MASTER_TX;
@@@ -475,13 -520,13 +480,17 @@@
  		/* RX may not have completed yet (only address cycle) */
  		if (!(irq_status & ASPEED_I2CD_INTR_RX_DONE))
  			goto out_no_complete;
++<<<<<<< HEAD
 +		/* fallthrough intended */
++=======
+ 		fallthrough;
++>>>>>>> 4db7e1786db5 (i2c: busses: Use fallthrough pseudo-keyword)
  	case ASPEED_I2C_MASTER_RX:
  		if (unlikely(!(irq_status & ASPEED_I2CD_INTR_RX_DONE))) {
 -			dev_err(bus->dev, "master failed to RX\n");
 +			dev_err(bus->dev, "master failed to RX");
  			goto error_and_stop;
  		}
 -		irq_handled |= ASPEED_I2CD_INTR_RX_DONE;
 +		status_ack |= ASPEED_I2CD_INTR_RX_DONE;
  
  		recv_byte = readl(bus->base + ASPEED_I2C_BYTE_BUF_REG) >> 8;
  		msg->buf[bus->buf_index++] = recv_byte;
diff --cc drivers/i2c/busses/i2c-synquacer.c
index 915f5edbab33,31be1811d5e6..000000000000
--- a/drivers/i2c/busses/i2c-synquacer.c
+++ b/drivers/i2c/busses/i2c-synquacer.c
@@@ -403,8 -398,7 +403,12 @@@ static irqreturn_t synquacer_i2c_isr(in
  
  		if (i2c->state == STATE_READ)
  			goto prepare_read;
++<<<<<<< HEAD
 +
 +		/* fallthru */
++=======
+ 		fallthrough;
++>>>>>>> 4db7e1786db5 (i2c: busses: Use fallthrough pseudo-keyword)
  
  	case STATE_WRITE:
  		if (bsr & SYNQUACER_I2C_BSR_LRB) {
* Unmerged path drivers/i2c/busses/i2c-amd8111.c
* Unmerged path drivers/i2c/busses/i2c-aspeed.c
diff --git a/drivers/i2c/busses/i2c-designware-pcidrv.c b/drivers/i2c/busses/i2c-designware-pcidrv.c
index 3664d76bb976..363e8d9b2c91 100644
--- a/drivers/i2c/busses/i2c-designware-pcidrv.c
+++ b/drivers/i2c/busses/i2c-designware-pcidrv.c
@@ -92,7 +92,7 @@ static int mfld_setup(struct pci_dev *pdev, struct dw_pci_controller *c)
 	switch (pdev->device) {
 	case 0x0817:
 		dev->timings.bus_freq_hz = I2C_MAX_STANDARD_MODE_FREQ;
-		/* fall through */
+		fallthrough;
 	case 0x0818:
 	case 0x0819:
 		c->bus_num = pdev->device - 0x817 + 3;
diff --git a/drivers/i2c/busses/i2c-digicolor.c b/drivers/i2c/busses/i2c-digicolor.c
index 50813a24c541..594f1eb779b9 100644
--- a/drivers/i2c/busses/i2c-digicolor.c
+++ b/drivers/i2c/busses/i2c-digicolor.c
@@ -191,7 +191,7 @@ static irqreturn_t dc_i2c_irq(int irq, void *dev_id)
 			break;
 		}
 		i2c->state = STATE_WRITE;
-		/* fall through */
+		fallthrough;
 	case STATE_WRITE:
 		if (i2c->msgbuf_ptr < i2c->msg->len)
 			dc_i2c_write_buf(i2c);
diff --git a/drivers/i2c/busses/i2c-i801.c b/drivers/i2c/busses/i2c-i801.c
index b22f50c9e492..634644286e5b 100644
--- a/drivers/i2c/busses/i2c-i801.c
+++ b/drivers/i2c/busses/i2c-i801.c
@@ -1613,18 +1613,18 @@ static int i801_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	case PCI_DEVICE_ID_INTEL_WELLSBURG_SMBUS_MS1:
 	case PCI_DEVICE_ID_INTEL_WELLSBURG_SMBUS_MS2:
 		priv->features |= FEATURE_IDF;
-		/* fall through */
+		fallthrough;
 	default:
 		priv->features |= FEATURE_I2C_BLOCK_READ;
 		priv->features |= FEATURE_IRQ;
-		/* fall through */
+		fallthrough;
 	case PCI_DEVICE_ID_INTEL_82801DB_3:
 		priv->features |= FEATURE_SMBUS_PEC;
 		priv->features |= FEATURE_BLOCK_BUFFER;
-		/* fall through */
+		fallthrough;
 	case PCI_DEVICE_ID_INTEL_82801CA_3:
 		priv->features |= FEATURE_HOST_NOTIFY;
-		/* fall through */
+		fallthrough;
 	case PCI_DEVICE_ID_INTEL_82801BA_2:
 	case PCI_DEVICE_ID_INTEL_82801AB_3:
 	case PCI_DEVICE_ID_INTEL_82801AA_3:
diff --git a/drivers/i2c/busses/i2c-mv64xxx.c b/drivers/i2c/busses/i2c-mv64xxx.c
index febb7c7ea72b..68e3ab5d5582 100644
--- a/drivers/i2c/busses/i2c-mv64xxx.c
+++ b/drivers/i2c/busses/i2c-mv64xxx.c
@@ -251,7 +251,7 @@ mv64xxx_i2c_fsm(struct mv64xxx_i2c_data *drv_data, u32 status)
 				MV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK;
 			break;
 		}
-		/* FALLTHRU */
+		fallthrough;
 	case MV64XXX_I2C_STATUS_MAST_WR_ADDR_2_ACK: /* 0xd0 */
 	case MV64XXX_I2C_STATUS_MAST_WR_ACK: /* 0x28 */
 		if ((drv_data->bytes_left == 0)
@@ -282,14 +282,14 @@ mv64xxx_i2c_fsm(struct mv64xxx_i2c_data *drv_data, u32 status)
 				MV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK;
 			break;
 		}
-		/* FALLTHRU */
+		fallthrough;
 	case MV64XXX_I2C_STATUS_MAST_RD_ADDR_2_ACK: /* 0xe0 */
 		if (drv_data->bytes_left == 0) {
 			drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
 			drv_data->state = MV64XXX_I2C_STATE_IDLE;
 			break;
 		}
-		/* FALLTHRU */
+		fallthrough;
 	case MV64XXX_I2C_STATUS_MAST_RD_DATA_ACK: /* 0x50 */
 		if (status != MV64XXX_I2C_STATUS_MAST_RD_DATA_ACK)
 			drv_data->action = MV64XXX_I2C_ACTION_CONTINUE;
@@ -417,8 +417,7 @@ mv64xxx_i2c_do_action(struct mv64xxx_i2c_data *drv_data)
 			"mv64xxx_i2c_do_action: Invalid action: %d\n",
 			drv_data->action);
 		drv_data->rc = -EIO;
-
-		/* FALLTHRU */
+		fallthrough;
 	case MV64XXX_I2C_ACTION_SEND_STOP:
 		drv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;
 		writel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_STOP,
* Unmerged path drivers/i2c/busses/i2c-synquacer.c
diff --git a/drivers/i2c/busses/i2c-viapro.c b/drivers/i2c/busses/i2c-viapro.c
index 0dc45e12bb1d..61654ae49db2 100644
--- a/drivers/i2c/busses/i2c-viapro.c
+++ b/drivers/i2c/busses/i2c-viapro.c
@@ -236,7 +236,7 @@ static s32 vt596_access(struct i2c_adapter *adap, u16 addr,
 			goto exit_unsupported;
 		if (read_write == I2C_SMBUS_READ)
 			outb_p(data->block[0], SMBHSTDAT0);
-		/* Fall through */
+		fallthrough;
 	case I2C_SMBUS_BLOCK_DATA:
 		outb_p(command, SMBHSTCMD);
 		if (read_write == I2C_SMBUS_WRITE) {
diff --git a/drivers/i2c/busses/scx200_acb.c b/drivers/i2c/busses/scx200_acb.c
index e0923bee8d1f..b5aa67dcac51 100644
--- a/drivers/i2c/busses/scx200_acb.c
+++ b/drivers/i2c/busses/scx200_acb.c
@@ -159,7 +159,7 @@ static void scx200_acb_machine(struct scx200_acb_iface *iface, u8 status)
 
 	case state_repeat_start:
 		outb(inb(ACBCTL1) | ACBCTL1_START, ACBCTL1);
-		/* fallthrough */
+		fallthrough;
 
 	case state_quick:
 		if (iface->address_byte & 1) {
diff --git a/drivers/i2c/i2c-slave-eeprom.c b/drivers/i2c/i2c-slave-eeprom.c
index db9763cb4dae..8e5e15063c24 100644
--- a/drivers/i2c/i2c-slave-eeprom.c
+++ b/drivers/i2c/i2c-slave-eeprom.c
@@ -66,7 +66,7 @@ static int i2c_slave_eeprom_slave_cb(struct i2c_client *client,
 	case I2C_SLAVE_READ_PROCESSED:
 		/* The previous byte made it to the bus, get next one */
 		eeprom->buffer_idx++;
-		/* fallthrough */
+		fallthrough;
 	case I2C_SLAVE_READ_REQUESTED:
 		spin_lock(&eeprom->buffer_lock);
 		*val = eeprom->buffer[eeprom->buffer_idx & eeprom->address_mask];
