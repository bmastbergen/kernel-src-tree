mm/mmu_notifiers: check if mmu notifier callbacks are allowed to fail

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Daniel Vetter <daniel.vetter@ffwll.ch>
commit 8402ce61bec28a1b73ec467b4c146f1e3f587044
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/8402ce61.failed

Just a bit of paranoia, since if we start pushing this deep into
callchains it's hard to spot all places where an mmu notifier
implementation might fail when it's not allowed to.

Inspired by some confusion we had discussing i915 mmu notifiers and
whether we could use the newly-introduced return value to handle some
corner cases. Until we realized that these are only for when a task has
been killed by the oom reaper.

An alternative approach would be to split the callback into two versions,
one with the int return value, and the other with void return value like
in older kernels. But that's a lot more churn for fairly little gain I
think.

Summary from the m-l discussion on why we want something at warning level:
This allows automated tooling in CI to catch bugs without humans having to
look at everything. If we just upgrade the existing pr_info to a pr_warn,
then we'll have false positives. And as-is, no one will ever spot the
problem since it's lost in the massive amounts of overall dmesg noise.

Link: https://lore.kernel.org/r/20190814202027.18735-2-daniel.vetter@ffwll.ch
	Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
	Reviewed-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 8402ce61bec28a1b73ec467b4c146f1e3f587044)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/mmu_notifier.c
diff --cc mm/mmu_notifier.c
index 4361d699fa34,d76ea27e2bbb..000000000000
--- a/mm/mmu_notifier.c
+++ b/mm/mmu_notifier.c
@@@ -452,9 -171,18 +452,21 @@@ static void mn_hlist_invalidate_range_s
  	int id;
  
  	id = srcu_read_lock(&srcu);
 -	hlist_for_each_entry_rcu(mn, &range->mm->mmu_notifier_mm->list, hlist) {
 +	hlist_for_each_entry_rcu(mn, &mmn_mm->list, hlist) {
  		if (mn->ops->invalidate_range_start) {
++<<<<<<< HEAD
 +			mn->ops->invalidate_range_start(mn, range->mm, range->start, range->end);
++=======
+ 			int _ret = mn->ops->invalidate_range_start(mn, range);
+ 			if (_ret) {
+ 				pr_info("%pS callback failed with %d in %sblockable context.\n",
+ 					mn->ops->invalidate_range_start, _ret,
+ 					!mmu_notifier_range_blockable(range) ? "non-" : "");
+ 				WARN_ON(mmu_notifier_range_blockable(range) ||
+ 					ret != -EAGAIN);
+ 				ret = _ret;
+ 			}
++>>>>>>> 8402ce61bec2 (mm/mmu_notifiers: check if mmu notifier callbacks are allowed to fail)
  		}
  	}
  	srcu_read_unlock(&srcu, id);
* Unmerged path mm/mmu_notifier.c
