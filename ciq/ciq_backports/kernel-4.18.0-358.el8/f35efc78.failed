printk: remove dict ring

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author John Ogness <john.ogness@linutronix.de>
commit f35efc78add6439a9fbe611f2dd517641e82d067
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/f35efc78.failed

Since there is no code that will ever store anything into the dict
ring, remove it. If any future dictionary properties are to be
added, these should be added to the struct printk_info.

	Signed-off-by: John Ogness <john.ogness@linutronix.de>
	Reviewed-by: Petr Mladek <pmladek@suse.com>
	Signed-off-by: Petr Mladek <pmladek@suse.com>
Link: https://lore.kernel.org/r/20200918223421.21621-4-john.ogness@linutronix.de
(cherry picked from commit f35efc78add6439a9fbe611f2dd517641e82d067)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/printk/printk.c
#	kernel/printk/printk_ringbuffer.c
#	kernel/printk/printk_ringbuffer.h
diff --cc kernel/printk/printk.c
index c1fedccb5ed4,1fe3d0cb2fe0..000000000000
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@@ -461,6 -424,23 +461,26 @@@ static char *log_buf = __log_buf
  static u32 log_buf_len = __LOG_BUF_LEN;
  
  /*
++<<<<<<< HEAD
++=======
+  * Define the average message size. This only affects the number of
+  * descriptors that will be available. Underestimating is better than
+  * overestimating (too many available descriptors is better than not enough).
+  */
+ #define PRB_AVGBITS 5	/* 32 character average length */
+ 
+ #if CONFIG_LOG_BUF_SHIFT <= PRB_AVGBITS
+ #error CONFIG_LOG_BUF_SHIFT value too small.
+ #endif
+ _DEFINE_PRINTKRB(printk_rb_static, CONFIG_LOG_BUF_SHIFT - PRB_AVGBITS,
+ 		 PRB_AVGBITS, &__log_buf[0]);
+ 
+ static struct printk_ringbuffer printk_rb_dynamic;
+ 
+ static struct printk_ringbuffer *prb = &printk_rb_static;
+ 
+ /*
++>>>>>>> f35efc78add6 (printk: remove dict ring)
   * We cannot access per-CPU data (e.g. per-CPU flush irq_work) before
   * per_cpu_areas are initialised. This variable is set to true when
   * it's safe to access per-CPU data.
@@@ -615,22 -494,21 +635,31 @@@ static u32 truncate_msg(u16 *text_len, 
  /* insert record into the buffer, discard old ones, update heads */
  static int log_store(u32 caller_id, int facility, int level,
  		     enum log_flags flags, u64 ts_nsec,
 -		     const struct dev_printk_info *dev_info,
 +		     const char *dict, u16 dict_len,
  		     const char *text, u16 text_len)
  {
 -	struct prb_reserved_entry e;
 -	struct printk_record r;
 +	struct printk_log *msg;
 +	u32 size, pad_len;
  	u16 trunc_msg_len = 0;
  
++<<<<<<< HEAD
 +	/* number of '\0' padding bytes to next message */
 +	size = msg_used_size(text_len, dict_len, &pad_len);
++=======
+ 	prb_rec_init_wr(&r, text_len);
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  
 -	if (!prb_reserve(&e, prb, &r)) {
 +	if (log_make_free_space(size)) {
  		/* truncate the message if it is too long for empty buffer */
++<<<<<<< HEAD
 +		size = truncate_msg(&text_len, &trunc_msg_len,
 +				    &dict_len, &pad_len);
++=======
+ 		truncate_msg(&text_len, &trunc_msg_len);
+ 		prb_rec_init_wr(&r, text_len + trunc_msg_len);
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  		/* survive when the log buffer is too small for trunc_msg */
 -		if (!prb_reserve(&e, prb, &r))
 +		if (log_make_free_space(size))
  			return 0;
  	}
  
@@@ -1029,9 -896,11 +1058,15 @@@ static int devkmsg_open(struct inode *i
  
  	mutex_init(&user->lock);
  
++<<<<<<< HEAD
++=======
+ 	prb_rec_init_rd(&user->record, &user->info,
+ 			&user->text_buf[0], sizeof(user->text_buf));
+ 
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  	logbuf_lock_irq();
 -	user->seq = prb_first_valid_seq(prb);
 +	user->idx = log_first_idx;
 +	user->seq = log_first_seq;
  	logbuf_unlock_irq();
  
  	file->private_data = user;
@@@ -1072,23 -941,58 +1107,68 @@@ const struct file_operations kmsg_fops 
   */
  void log_buf_vmcoreinfo_setup(void)
  {
 -	struct dev_printk_info *dev_info = NULL;
 -
 -	VMCOREINFO_SYMBOL(prb);
 -	VMCOREINFO_SYMBOL(printk_rb_static);
 -	VMCOREINFO_SYMBOL(clear_seq);
 -
 +	VMCOREINFO_SYMBOL(log_buf);
 +	VMCOREINFO_SYMBOL(log_buf_len);
 +	VMCOREINFO_SYMBOL(log_first_idx);
 +	VMCOREINFO_SYMBOL(clear_idx);
 +	VMCOREINFO_SYMBOL(log_next_idx);
  	/*
 -	 * Export struct size and field offsets. User space tools can
 +	 * Export struct printk_log size and field offsets. User space tools can
  	 * parse it and detect any changes to structure down the line.
  	 */
++<<<<<<< HEAD
 +	VMCOREINFO_STRUCT_SIZE(printk_log);
 +	VMCOREINFO_OFFSET(printk_log, ts_nsec);
 +	VMCOREINFO_OFFSET(printk_log, len);
 +	VMCOREINFO_OFFSET(printk_log, text_len);
 +	VMCOREINFO_OFFSET(printk_log, dict_len);
 +#ifdef CONFIG_PRINTK_CALLER
 +	VMCOREINFO_OFFSET(printk_log, caller_id);
 +#endif
++=======
+ 
+ 	VMCOREINFO_STRUCT_SIZE(printk_ringbuffer);
+ 	VMCOREINFO_OFFSET(printk_ringbuffer, desc_ring);
+ 	VMCOREINFO_OFFSET(printk_ringbuffer, text_data_ring);
+ 	VMCOREINFO_OFFSET(printk_ringbuffer, fail);
+ 
+ 	VMCOREINFO_STRUCT_SIZE(prb_desc_ring);
+ 	VMCOREINFO_OFFSET(prb_desc_ring, count_bits);
+ 	VMCOREINFO_OFFSET(prb_desc_ring, descs);
+ 	VMCOREINFO_OFFSET(prb_desc_ring, infos);
+ 	VMCOREINFO_OFFSET(prb_desc_ring, head_id);
+ 	VMCOREINFO_OFFSET(prb_desc_ring, tail_id);
+ 
+ 	VMCOREINFO_STRUCT_SIZE(prb_desc);
+ 	VMCOREINFO_OFFSET(prb_desc, state_var);
+ 	VMCOREINFO_OFFSET(prb_desc, text_blk_lpos);
+ 
+ 	VMCOREINFO_STRUCT_SIZE(prb_data_blk_lpos);
+ 	VMCOREINFO_OFFSET(prb_data_blk_lpos, begin);
+ 	VMCOREINFO_OFFSET(prb_data_blk_lpos, next);
+ 
+ 	VMCOREINFO_STRUCT_SIZE(printk_info);
+ 	VMCOREINFO_OFFSET(printk_info, seq);
+ 	VMCOREINFO_OFFSET(printk_info, ts_nsec);
+ 	VMCOREINFO_OFFSET(printk_info, text_len);
+ 	VMCOREINFO_OFFSET(printk_info, caller_id);
+ 	VMCOREINFO_OFFSET(printk_info, dev_info);
+ 
+ 	VMCOREINFO_STRUCT_SIZE(dev_printk_info);
+ 	VMCOREINFO_OFFSET(dev_printk_info, subsystem);
+ 	VMCOREINFO_LENGTH(printk_info_subsystem, sizeof(dev_info->subsystem));
+ 	VMCOREINFO_OFFSET(dev_printk_info, device);
+ 	VMCOREINFO_LENGTH(printk_info_device, sizeof(dev_info->device));
+ 
+ 	VMCOREINFO_STRUCT_SIZE(prb_data_ring);
+ 	VMCOREINFO_OFFSET(prb_data_ring, size_bits);
+ 	VMCOREINFO_OFFSET(prb_data_ring, data);
+ 	VMCOREINFO_OFFSET(prb_data_ring, head_lpos);
+ 	VMCOREINFO_OFFSET(prb_data_ring, tail_lpos);
+ 
+ 	VMCOREINFO_SIZE(atomic_long_t);
+ 	VMCOREINFO_TYPE_OFFSET(atomic_long_t, counter);
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  }
  #endif
  
@@@ -1166,8 -1070,42 +1246,38 @@@ static void __init set_percpu_data_read
  	__printk_percpu_data_ready = true;
  }
  
++<<<<<<< HEAD
++=======
+ static unsigned int __init add_to_rb(struct printk_ringbuffer *rb,
+ 				     struct printk_record *r)
+ {
+ 	struct prb_reserved_entry e;
+ 	struct printk_record dest_r;
+ 
+ 	prb_rec_init_wr(&dest_r, r->info->text_len);
+ 
+ 	if (!prb_reserve(&e, rb, &dest_r))
+ 		return 0;
+ 
+ 	memcpy(&dest_r.text_buf[0], &r->text_buf[0], r->info->text_len);
+ 	dest_r.info->text_len = r->info->text_len;
+ 	dest_r.info->facility = r->info->facility;
+ 	dest_r.info->level = r->info->level;
+ 	dest_r.info->flags = r->info->flags;
+ 	dest_r.info->ts_nsec = r->info->ts_nsec;
+ 	dest_r.info->caller_id = r->info->caller_id;
+ 	memcpy(&dest_r.info->dev_info, &r->info->dev_info, sizeof(dest_r.info->dev_info));
+ 
+ 	prb_final_commit(&e);
+ 
+ 	return prb_record_text_space(&e);
+ }
+ 
+ static char setup_text_buf[CONSOLE_EXT_LOG_MAX] __initdata;
+ 
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  void __init setup_log_buf(int early)
  {
 -	struct printk_info *new_infos;
 -	unsigned int new_descs_count;
 -	struct prb_desc *new_descs;
 -	struct printk_info info;
 -	struct printk_record r;
 -	size_t new_descs_size;
 -	size_t new_infos_size;
  	unsigned long flags;
  	char *new_log_buf;
  	unsigned int free;
@@@ -1203,7 -1141,31 +1313,33 @@@
  		return;
  	}
  
++<<<<<<< HEAD
++=======
+ 	new_descs_size = new_descs_count * sizeof(struct prb_desc);
+ 	new_descs = memblock_alloc(new_descs_size, LOG_ALIGN);
+ 	if (unlikely(!new_descs)) {
+ 		pr_err("log_buf_len: %zu desc bytes not available\n",
+ 		       new_descs_size);
+ 		goto err_free_log_buf;
+ 	}
+ 
+ 	new_infos_size = new_descs_count * sizeof(struct printk_info);
+ 	new_infos = memblock_alloc(new_infos_size, LOG_ALIGN);
+ 	if (unlikely(!new_infos)) {
+ 		pr_err("log_buf_len: %zu info bytes not available\n",
+ 		       new_infos_size);
+ 		goto err_free_descs;
+ 	}
+ 
+ 	prb_rec_init_rd(&r, &info, &setup_text_buf[0], sizeof(setup_text_buf));
+ 
+ 	prb_init(&printk_rb_dynamic,
+ 		 new_log_buf, ilog2(new_log_buf_len),
+ 		 new_descs, ilog2(new_descs_count),
+ 		 new_infos);
+ 
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  	logbuf_lock_irqsave(flags);
 -
  	log_buf_len = new_log_buf_len;
  	log_buf = new_log_buf;
  	new_log_buf_len = 0;
@@@ -1214,6 -1186,17 +1350,15 @@@
  	pr_info("log_buf_len: %u bytes\n", log_buf_len);
  	pr_info("early log buf free: %u(%u%%)\n",
  		free, (free * 100) / __LOG_BUF_LEN);
++<<<<<<< HEAD
++=======
+ 	return;
+ 
+ err_free_descs:
+ 	memblock_free(__pa(new_descs), new_descs_size);
+ err_free_log_buf:
+ 	memblock_free(__pa(new_log_buf), new_log_buf_len);
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  }
  
  static bool __read_mostly ignore_loglevel;
@@@ -1392,6 -1445,8 +1537,11 @@@ static int syslog_print(char __user *bu
  	if (!text)
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	prb_rec_init_rd(&r, &info, text, LOG_LINE_MAX + PREFIX_MAX);
+ 
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  	while (size > 0) {
  		size_t n;
  		size_t skip;
@@@ -1470,38 -1522,28 +1620,42 @@@ static int syslog_print_all(char __use
  	 * Find first record that fits, including all following records,
  	 * into the user-provided buffer for this dump.
  	 */
 -	prb_for_each_info(clear_seq, prb, seq, &info, &line_count)
 -		len += get_record_print_text_size(&info, line_count, true, time);
 +	seq = clear_seq;
 +	idx = clear_idx;
 +	while (seq < log_next_seq) {
 +		struct printk_log *msg = log_from_idx(idx);
 +
 +		len += msg_print_text(msg, true, time, NULL, 0);
 +		idx = log_next(idx);
 +		seq++;
 +	}
  
++<<<<<<< HEAD
  	/* move first record forward until length fits into the buffer */
 -	prb_for_each_info(clear_seq, prb, seq, &info, &line_count) {
 -		if (len <= size)
 -			break;
 -		len -= get_record_print_text_size(&info, line_count, true, time);
 +	seq = clear_seq;
 +	idx = clear_idx;
 +	while (len > size && seq < log_next_seq) {
 +		struct printk_log *msg = log_from_idx(idx);
 +
 +		len -= msg_print_text(msg, true, time, NULL, 0);
 +		idx = log_next(idx);
 +		seq++;
  	}
  
 +	/* last message fitting into this dump */
 +	next_seq = log_next_seq;
++=======
+ 	prb_rec_init_rd(&r, &info, text, LOG_LINE_MAX + PREFIX_MAX);
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  
  	len = 0;
 -	prb_for_each_record(seq, prb, seq, &r) {
 -		int textlen;
 -
 -		textlen = record_print_text(&r, true, time);
 +	while (len >= 0 && seq < next_seq) {
 +		struct printk_log *msg = log_from_idx(idx);
 +		int textlen = msg_print_text(msg, true, time, text,
 +					     LOG_LINE_MAX + PREFIX_MAX);
  
 -		if (len + textlen > size) {
 -			seq--;
 -			break;
 -		}
 +		idx = log_next(idx);
 +		seq++;
  
  		logbuf_unlock_irq();
  		if (copy_to_user(buf + len, text, textlen))
@@@ -1907,27 -1898,22 +2061,45 @@@ static size_t log_output(int facility, 
  {
  	const u32 caller_id = printk_caller_id();
  
++<<<<<<< HEAD
 +	/*
 +	 * If an earlier line was buffered, and we're a continuation
 +	 * write from the same context, try to add it to the buffer.
 +	 */
 +	if (cont.len) {
 +		if (cont.caller_id == caller_id && (lflags & LOG_CONT)) {
 +			if (cont_add(caller_id, facility, level, lflags, text, text_len))
 +				return text_len;
++=======
+ 	if (lflags & LOG_CONT) {
+ 		struct prb_reserved_entry e;
+ 		struct printk_record r;
+ 
+ 		prb_rec_init_wr(&r, text_len);
+ 		if (prb_reserve_in_last(&e, prb, &r, caller_id)) {
+ 			memcpy(&r.text_buf[r.info->text_len], text, text_len);
+ 			r.info->text_len += text_len;
+ 			if (lflags & LOG_NEWLINE) {
+ 				r.info->flags |= LOG_NEWLINE;
+ 				prb_final_commit(&e);
+ 			} else {
+ 				prb_commit(&e);
+ 			}
+ 			return text_len;
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  		}
 +		/* Otherwise, make sure it's flushed */
 +		cont_flush();
 +	}
 +
 +	/* Skip empty continuation lines that couldn't be added - they just flush */
 +	if (!text_len && (lflags & LOG_CONT))
 +		return 0;
 +
 +	/* If it doesn't end in a newline, try to buffer the current line */
 +	if (!(lflags & LOG_NEWLINE)) {
 +		if (cont_add(caller_id, facility, level, lflags, text, text_len))
 +			return text_len;
  	}
  
  	/* Store it in the record log */
@@@ -2402,6 -2390,8 +2574,11 @@@ void console_unlock(void
  		return;
  	}
  
++<<<<<<< HEAD
++=======
+ 	prb_rec_init_rd(&r, &info, text, sizeof(text));
+ 
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  	/*
  	 * Console drivers are called with interrupts disabled, so
  	 * @console_may_schedule should be cleared before; however, we may
@@@ -3229,6 -3248,8 +3406,11 @@@ bool kmsg_dump_get_line_nolock(struct k
  	size_t l = 0;
  	bool ret = false;
  
++<<<<<<< HEAD
++=======
+ 	prb_rec_init_rd(&r, &info, line, size);
+ 
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  	if (!dumper->active)
  		goto out;
  
@@@ -3316,7 -3339,9 +3498,13 @@@ bool kmsg_dump_get_buffer(struct kmsg_d
  	bool ret = false;
  	bool time = printk_time;
  
++<<<<<<< HEAD
 +	if (!dumper->active)
++=======
+ 	prb_rec_init_rd(&r, &info, buf, size);
+ 
+ 	if (!dumper->active || !buf || !size)
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  		goto out;
  
  	logbuf_lock_irqsave(flags);
@@@ -3356,15 -3377,19 +3544,24 @@@
  
  	/* last message in next interation */
  	next_seq = seq;
 +	next_idx = idx;
  
 -	/* actually read text into the buffer now */
  	l = 0;
 -	while (prb_read_valid(prb, seq, &r)) {
 -		if (r.info->seq >= dumper->next_seq)
 -			break;
 -
 +	while (seq < dumper->next_seq) {
 +		struct printk_log *msg = log_from_idx(idx);
 +
++<<<<<<< HEAD
 +		l += msg_print_text(msg, syslog, time, buf + l, size - l);
 +		idx = log_next(idx);
 +		seq++;
++=======
+ 		l += record_print_text(&r, syslog, time);
+ 
+ 		/* adjust record to store to remaining buffer space */
+ 		prb_rec_init_rd(&r, &info, buf + l, size - l);
+ 
+ 		seq = r.info->seq + 1;
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  	}
  
  	dumper->next_seq = next_seq;
diff --cc kernel/printk/printk_ringbuffer.c
index 25548d2880ae,13b94b92342e..000000000000
--- a/kernel/printk/printk_ringbuffer.c
+++ b/kernel/printk/printk_ringbuffer.c
@@@ -15,10 -15,10 +15,17 @@@
   * The printk_ringbuffer is made up of 3 internal ringbuffers:
   *
   *   desc_ring
++<<<<<<< HEAD
 + *     A ring of descriptors. A descriptor contains all record meta data
 + *     (sequence number, timestamp, loglevel, etc.) as well as internal state
 + *     information about the record and logical positions specifying where in
 + *     the other ringbuffers the text and dictionary strings are located.
++=======
+  *     A ring of descriptors and their meta data (such as sequence number,
+  *     timestamp, loglevel, etc.) as well as internal state information about
+  *     the record and logical positions specifying where in the other
+  *     ringbuffer the text strings are located.
++>>>>>>> f35efc78add6 (printk: remove dict ring)
   *
   *   text_data_ring
   *     A ring of data blocks. A data block consists of an unsigned long
@@@ -38,13 -33,14 +40,24 @@@
   *
   * Descriptor Ring
   * ~~~~~~~~~~~~~~~
++<<<<<<< HEAD
 + * The descriptor ring is an array of descriptors. A descriptor contains all
 + * the meta data of a printk record as well as blk_lpos structs pointing to
 + * associated text and dictionary data blocks (see "Data Rings" below). Each
 + * descriptor is assigned an ID that maps directly to index values of the
 + * descriptor array and has a state. The ID and the state are bitwise combined
 + * into a single descriptor field named @state_var, allowing ID and state to
 + * be synchronously and atomically updated.
++=======
+  * The descriptor ring is an array of descriptors. A descriptor contains
+  * essential meta data to track the data of a printk record using
+  * blk_lpos structs pointing to associated text data blocks (see
+  * "Data Rings" below). Each descriptor is assigned an ID that maps
+  * directly to index values of the descriptor array and has a state. The ID
+  * and the state are bitwise combined into a single descriptor field named
+  * @state_var, allowing ID and state to be synchronously and atomically
+  * updated.
++>>>>>>> f35efc78add6 (printk: remove dict ring)
   *
   * Descriptors have four states:
   *
@@@ -175,12 -173,11 +182,18 @@@
   *	if (prb_reserve(&e, &test_rb, &r)) {
   *		snprintf(r.text_buf, r.text_buf_size, "%s", textstr);
   *
++<<<<<<< HEAD
 + *		// dictionary allocation may have failed
 + *		if (r.dict_buf)
 + *			snprintf(r.dict_buf, r.dict_buf_size, "%s", dictstr);
 + *
++=======
+  *		r.info->text_len = strlen(textstr);
++>>>>>>> f35efc78add6 (printk: remove dict ring)
   *		r.info->ts_nsec = local_clock();
+  *		r.info->caller_id = printk_caller_id();
   *
+  *		// commit and finalize the record
   *		prb_final_commit(&e);
   *	}
   *
@@@ -466,11 -473,12 +474,19 @@@ static enum desc_state desc_read(struc
  	 * state has been re-checked. A memcpy() for all of @desc
  	 * cannot be used because of the atomic_t @state_var field.
  	 */
 +	memcpy(&desc_out->info, &desc->info, sizeof(desc_out->info)); /* LMM(desc_read:C) */
  	memcpy(&desc_out->text_blk_lpos, &desc->text_blk_lpos,
++<<<<<<< HEAD
 +	       sizeof(desc_out->text_blk_lpos)); /* also part of desc_read:C */
 +	memcpy(&desc_out->dict_blk_lpos, &desc->dict_blk_lpos,
 +	       sizeof(desc_out->dict_blk_lpos)); /* also part of desc_read:C */
++=======
+ 	       sizeof(desc_out->text_blk_lpos)); /* LMM(desc_read:C) */
+ 	if (seq_out)
+ 		*seq_out = info->seq; /* also part of desc_read:C */
+ 	if (caller_id_out)
+ 		*caller_id_out = info->caller_id; /* also part of desc_read:C */
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  
  	/*
  	 * 1. Guarantee the descriptor content is loaded before re-checking
@@@ -1417,11 -1416,7 +1417,15 @@@ bool prb_reserve_in_last(struct prb_res
  	if (r->text_buf_size && !r->text_buf)
  		goto fail;
  
++<<<<<<< HEAD
 +	/* Although dictionary data may be in use, it cannot be extended. */
 +	r->dict_buf = NULL;
 +	r->dict_buf_size = 0;
 +
 +	r->info = &d->info;
++=======
+ 	r->info = info;
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  
  	e->text_space = space_used(&rb->text_data_ring, &d->text_blk_lpos);
  
@@@ -1470,14 -1464,9 +1473,20 @@@ static void desc_make_final(struct prb_
   * on success, prb_record_text_space() can be used on @e to query the actual
   * space used for the text data block.
   *
++<<<<<<< HEAD
 + * If the function fails to reserve dictionary space (but all else succeeded),
 + * it will still report success. In that case @dict_buf is set to NULL and
 + * @dict_buf_size is set to 0. Writers must check this before writing to
 + * dictionary space.
 + *
 + * @info->text_len and @info->dict_len will already be set to @text_buf_size
 + * and @dict_buf_size, respectively. If dictionary space reservation fails,
 + * @info->dict_len is set to 0.
++=======
+  * Important: @info->text_len needs to be set correctly by the writer in
+  *            order for data to be readable and/or extended. Its value
+  *            is initialized to 0.
++>>>>>>> f35efc78add6 (printk: remove dict ring)
   */
  bool prb_reserve(struct prb_reserved_entry *e, struct printk_ringbuffer *rb,
  		 struct printk_record *r)
@@@ -1552,20 -1547,7 +1558,24 @@@
  		goto fail;
  	}
  
++<<<<<<< HEAD
 +	r->dict_buf = data_alloc(rb, &rb->dict_data_ring, r->dict_buf_size,
 +				 &d->dict_blk_lpos, id);
 +	/*
 +	 * If dict data allocation fails, the caller can still commit
 +	 * text. But dictionary information will not be available.
 +	 */
 +	if (r->dict_buf_size && !r->dict_buf)
 +		r->dict_buf_size = 0;
 +
 +	r->info = &d->info;
 +
 +	/* Set default values for the sizes. */
 +	d->info.text_len = r->text_buf_size;
 +	d->info.dict_len = r->dict_buf_size;
++=======
+ 	r->info = info;
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  
  	/* Record full text space used by record. */
  	e->text_space = space_used(&rb->text_data_ring, &d->text_blk_lpos);
@@@ -1825,17 -1809,6 +1835,20 @@@ static int prb_read(struct printk_ringb
  		return -ENOENT;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * Copy dict data. Although this should not fail, dict data is not
 +	 * important. So if it fails, modify the copied meta data to report
 +	 * that there is no dict data, thus silently dropping the dict data.
 +	 */
 +	if (!copy_data(&rb->dict_data_ring, &desc.dict_blk_lpos, desc.info.dict_len,
 +		       r->dict_buf, r->dict_buf_size, NULL)) {
 +		if (r->info)
 +			r->info->dict_len = 0;
 +	}
 +
++=======
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  	/* Ensure the record is still finalized and has the same @seq. */
  	return desc_read_finalized_seq(desc_ring, id, seq, &desc);
  }
@@@ -2039,10 -2013,9 +2052,8 @@@ u64 prb_next_seq(struct printk_ringbuff
   * @rb:       The ringbuffer to initialize.
   * @text_buf: The data buffer for text data.
   * @textbits: The size of @text_buf as a power-of-2 value.
-  * @dict_buf: The data buffer for dictionary data.
-  * @dictbits: The size of @dict_buf as a power-of-2 value.
   * @descs:    The descriptor buffer for ringbuffer records.
   * @descbits: The count of @descs items as a power-of-2 value.
 - * @infos:    The printk_info buffer for ringbuffer records.
   *
   * This is the public function available to writers to setup a ringbuffer
   * during runtime using provided buffers.
@@@ -2053,10 -2026,11 +2064,15 @@@
   */
  void prb_init(struct printk_ringbuffer *rb,
  	      char *text_buf, unsigned int textbits,
++<<<<<<< HEAD
 +	      char *dict_buf, unsigned int dictbits,
 +	      struct prb_desc *descs, unsigned int descbits)
++=======
+ 	      struct prb_desc *descs, unsigned int descbits,
+ 	      struct printk_info *infos)
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  {
  	memset(descs, 0, _DESCS_COUNT(descbits) * sizeof(descs[0]));
 -	memset(infos, 0, _DESCS_COUNT(descbits) * sizeof(infos[0]));
  
  	rb->desc_ring.count_bits = descbits;
  	rb->desc_ring.descs = descs;
@@@ -2068,21 -2043,14 +2084,22 @@@
  	atomic_long_set(&rb->text_data_ring.head_lpos, BLK0_LPOS(textbits));
  	atomic_long_set(&rb->text_data_ring.tail_lpos, BLK0_LPOS(textbits));
  
- 	rb->dict_data_ring.size_bits = dictbits;
- 	rb->dict_data_ring.data = dict_buf;
- 	atomic_long_set(&rb->dict_data_ring.head_lpos, BLK0_LPOS(dictbits));
- 	atomic_long_set(&rb->dict_data_ring.tail_lpos, BLK0_LPOS(dictbits));
- 
  	atomic_long_set(&rb->fail, 0);
  
 +	descs[0].info.seq = -(u64)_DESCS_COUNT(descbits);
 +
 +	descs[_DESCS_COUNT(descbits) - 1].info.seq = 0;
  	atomic_long_set(&(descs[_DESCS_COUNT(descbits) - 1].state_var), DESC0_SV(descbits));
  	descs[_DESCS_COUNT(descbits) - 1].text_blk_lpos.begin = FAILED_LPOS;
  	descs[_DESCS_COUNT(descbits) - 1].text_blk_lpos.next = FAILED_LPOS;
++<<<<<<< HEAD
 +	descs[_DESCS_COUNT(descbits) - 1].dict_blk_lpos.begin = FAILED_LPOS;
 +	descs[_DESCS_COUNT(descbits) - 1].dict_blk_lpos.next = FAILED_LPOS;
++=======
+ 
+ 	infos[0].seq = -(u64)_DESCS_COUNT(descbits);
+ 	infos[_DESCS_COUNT(descbits) - 1].seq = 0;
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  }
  
  /**
diff --cc kernel/printk/printk_ringbuffer.h
index 853ea62dc5f2,0adaa685d1ca..000000000000
--- a/kernel/printk/printk_ringbuffer.h
+++ b/kernel/printk/printk_ringbuffer.h
@@@ -58,10 -56,8 +53,9 @@@ struct prb_data_blk_lpos 
   * @state_var: A bitwise combination of descriptor ID and descriptor state.
   */
  struct prb_desc {
 +	struct printk_info		info;
  	atomic_long_t			state_var;
  	struct prb_data_blk_lpos	text_blk_lpos;
- 	struct prb_data_blk_lpos	dict_blk_lpos;
  };
  
  /* A ringbuffer of "ID + data" elements. */
@@@ -233,30 -229,28 +226,27 @@@ enum desc_state 
   * Note: The specified external buffer must be of the size:
   *       2 ^ (descbits + avgtextbits)
   */
- #define _DEFINE_PRINTKRB(name, descbits, avgtextbits, avgdictbits, text_buf)			\
- static char _##name##_dict[1U << ((avgdictbits) + (descbits))]					\
- 			__aligned(__alignof__(unsigned long));					\
+ #define _DEFINE_PRINTKRB(name, descbits, avgtextbits, text_buf)			\
  static struct prb_desc _##name##_descs[_DESCS_COUNT(descbits)] = {				\
 +	/* this will be the first record reserved by a writer */				\
 +	[0] = {											\
 +		.info = {									\
 +			/* will be incremented to 0 on the first reservation */			\
 +			.seq = -(u64)_DESCS_COUNT(descbits),					\
 +		},										\
 +	},											\
  	/* the initial head and tail */								\
  	[_DESCS_COUNT(descbits) - 1] = {							\
 +		.info = {									\
 +			/* reports the first seq value during the bootstrap phase */		\
 +			.seq = 0,								\
 +		},										\
  		/* reusable */									\
  		.state_var	= ATOMIC_INIT(DESC0_SV(descbits)),				\
  		/* no associated data block */							\
  		.text_blk_lpos	= FAILED_BLK_LPOS,						\
- 		.dict_blk_lpos	= FAILED_BLK_LPOS,						\
  	},											\
  };												\
 -static struct printk_info _##name##_infos[_DESCS_COUNT(descbits)] = {				\
 -	/* this will be the first record reserved by a writer */				\
 -	[0] = {											\
 -		/* will be incremented to 0 on the first reservation */				\
 -		.seq = -(u64)_DESCS_COUNT(descbits),						\
 -	},											\
 -	/* the initial head and tail */								\
 -	[_DESCS_COUNT(descbits) - 1] = {							\
 -		/* reports the first seq value during the bootstrap phase */			\
 -		.seq = 0,									\
 -	},											\
 -};												\
  static struct printk_ringbuffer name = {							\
  	.desc_ring = {										\
  		.count_bits	= descbits,							\
@@@ -335,8 -309,8 +304,13 @@@ void prb_final_commit(struct prb_reserv
  
  void prb_init(struct printk_ringbuffer *rb,
  	      char *text_buf, unsigned int text_buf_size,
++<<<<<<< HEAD
 +	      char *dict_buf, unsigned int dict_buf_size,
 +	      struct prb_desc *descs, unsigned int descs_count_bits);
++=======
+ 	      struct prb_desc *descs, unsigned int descs_count_bits,
+ 	      struct printk_info *infos);
++>>>>>>> f35efc78add6 (printk: remove dict ring)
  unsigned int prb_record_text_space(struct prb_reserved_entry *e);
  
  /* Reader Interface */
* Unmerged path kernel/printk/printk.c
* Unmerged path kernel/printk/printk_ringbuffer.c
* Unmerged path kernel/printk/printk_ringbuffer.h
