net: bridge: mcast: fix vlan port router deadlock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit ddd0d5293810c1882e2a96f8cce1678823b1dd38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/ddd0d529.failed

Before vlan/port mcast router support was added
br_multicast_set_port_router was used only with bh already disabled due
to the bridge port lock, but that is no longer the case and when it is
called to configure a vlan/port mcast router we can deadlock with the
timer, so always disable bh to make sure it can be called from contexts
with both enabled and disabled bh.

Fixes: 2796d846d74a ("net: bridge: vlan: convert mcast router global option to per-vlan entry")
	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ddd0d5293810c1882e2a96f8cce1678823b1dd38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
diff --cc net/bridge/br_multicast.c
index def6f1840985,3523c8c7068f..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -2975,31 -4222,50 +2975,37 @@@ int br_multicast_set_router(struct net_
  	return err;
  }
  
 -static void
 -br_multicast_rport_del_notify(struct net_bridge_mcast_port *pmctx, bool deleted)
 +static void __del_port_router(struct net_bridge_port *p)
  {
 -	if (!deleted)
 -		return;
 -
 -	/* For backwards compatibility for now, only notify if there is
 -	 * no multicast router anymore for both IPv4 and IPv6.
 -	 */
 -	if (!hlist_unhashed(&pmctx->ip4_rlist))
 -		return;
 -#if IS_ENABLED(CONFIG_IPV6)
 -	if (!hlist_unhashed(&pmctx->ip6_rlist))
 +	if (hlist_unhashed(&p->rlist))
  		return;
 -#endif
 -
 -	br_rtr_notify(pmctx->port->br->dev, pmctx, RTM_DELMDB);
 -	br_port_mc_router_state_change(pmctx->port, false);
 +	hlist_del_init_rcu(&p->rlist);
 +	br_rtr_notify(p->br->dev, p, RTM_DELMDB);
 +	br_port_mc_router_state_change(p, false);
  
  	/* don't allow timer refresh */
 -	if (pmctx->multicast_router == MDB_RTR_TYPE_TEMP)
 -		pmctx->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
 +	if (p->multicast_router == MDB_RTR_TYPE_TEMP)
 +		p->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
  }
  
 -int br_multicast_set_port_router(struct net_bridge_mcast_port *pmctx,
 -				 unsigned long val)
 +int br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val)
  {
 -	struct net_bridge_mcast *brmctx;
 +	struct net_bridge *br = p->br;
  	unsigned long now = jiffies;
  	int err = -EINVAL;
 -	bool del = false;
  
++<<<<<<< HEAD
 +	spin_lock(&br->multicast_lock);
 +	if (p->multicast_router == val) {
++=======
+ 	brmctx = br_multicast_port_ctx_get_global(pmctx);
+ 	spin_lock_bh(&brmctx->br->multicast_lock);
+ 	if (pmctx->multicast_router == val) {
++>>>>>>> ddd0d5293810 (net: bridge: mcast: fix vlan port router deadlock)
  		/* Refresh the temp router port timer */
 -		if (pmctx->multicast_router == MDB_RTR_TYPE_TEMP) {
 -			mod_timer(&pmctx->ip4_mc_router_timer,
 -				  now + brmctx->multicast_querier_interval);
 -#if IS_ENABLED(CONFIG_IPV6)
 -			mod_timer(&pmctx->ip6_mc_router_timer,
 -				  now + brmctx->multicast_querier_interval);
 -#endif
 -		}
 +		if (p->multicast_router == MDB_RTR_TYPE_TEMP)
 +			mod_timer(&p->multicast_router_timer,
 +				  now + br->multicast_querier_interval);
  		err = 0;
  		goto unlock;
  	}
@@@ -3027,7 -4305,7 +3033,11 @@@
  	}
  	err = 0;
  unlock:
++<<<<<<< HEAD
 +	spin_unlock(&br->multicast_lock);
++=======
+ 	spin_unlock_bh(&brmctx->br->multicast_lock);
++>>>>>>> ddd0d5293810 (net: bridge: mcast: fix vlan port router deadlock)
  
  	return err;
  }
* Unmerged path net/bridge/br_multicast.c
