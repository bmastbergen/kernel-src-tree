driver core: platform: reorder functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
commit e21d740a3fe5ad2db7b5f5c2331fe2b713b1edba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/e21d740a.failed

This way all callbacks and structures used to initialize
platform_bus_type are defined just before platform_bus_type and in the
same order. Also move platform_drv_probe_fail just before it's only
user.

	Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Link: https://lore.kernel.org/r/20201119124611.2573057-1-u.kleine-koenig@pengutronix.de
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit e21d740a3fe5ad2db7b5f5c2331fe2b713b1edba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/platform.c
diff --cc drivers/base/platform.c
index 12b5b6af6e01,b36ab5831cb6..000000000000
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@@ -931,129 -1017,6 +931,132 @@@ void platform_unregister_drivers(struc
  }
  EXPORT_SYMBOL_GPL(platform_unregister_drivers);
  
++<<<<<<< HEAD
 +/* modalias support enables more hands-off userspace setup:
 + * (a) environment variable lets new-style hotplug events work once system is
 + *     fully running:  "modprobe $MODALIAS"
 + * (b) sysfs attribute lets new-style coldplug recover from hotplug events
 + *     mishandled before system is fully running:  "modprobe $(cat modalias)"
 + */
 +static ssize_t modalias_show(struct device *dev,
 +			     struct device_attribute *attr, char *buf)
 +{
 +	struct platform_device *pdev = to_platform_device(dev);
 +	int len;
 +
 +	len = of_device_modalias(dev, buf, PAGE_SIZE);
 +	if (len != -ENODEV)
 +		return len;
 +
 +	len = acpi_device_modalias(dev, buf, PAGE_SIZE -1);
 +	if (len != -ENODEV)
 +		return len;
 +
 +	return sysfs_emit(buf, "platform:%s\n", pdev->name);
 +}
 +static DEVICE_ATTR_RO(modalias);
 +
 +static ssize_t driver_override_store(struct device *dev,
 +				     struct device_attribute *attr,
 +				     const char *buf, size_t count)
 +{
 +	struct platform_device *pdev = to_platform_device(dev);
 +	char *driver_override, *old, *cp;
 +
 +	/* We need to keep extra room for a newline */
 +	if (count >= (PAGE_SIZE - 1))
 +		return -EINVAL;
 +
 +	driver_override = kstrndup(buf, count, GFP_KERNEL);
 +	if (!driver_override)
 +		return -ENOMEM;
 +
 +	cp = strchr(driver_override, '\n');
 +	if (cp)
 +		*cp = '\0';
 +
 +	device_lock(dev);
 +	old = pdev->driver_override;
 +	if (strlen(driver_override)) {
 +		pdev->driver_override = driver_override;
 +	} else {
 +		kfree(driver_override);
 +		pdev->driver_override = NULL;
 +	}
 +	device_unlock(dev);
 +
 +	kfree(old);
 +
 +	return count;
 +}
 +
 +static ssize_t driver_override_show(struct device *dev,
 +				    struct device_attribute *attr, char *buf)
 +{
 +	struct platform_device *pdev = to_platform_device(dev);
 +	ssize_t len;
 +
 +	device_lock(dev);
 +	len = sysfs_emit(buf, "%s\n", pdev->driver_override);
 +	device_unlock(dev);
 +
 +	return len;
 +}
 +static DEVICE_ATTR_RW(driver_override);
 +
 +static ssize_t numa_node_show(struct device *dev,
 +			      struct device_attribute *attr, char *buf)
 +{
 +	return sysfs_emit(buf, "%d\n", dev_to_node(dev));
 +}
 +static DEVICE_ATTR_RO(numa_node);
 +
 +static umode_t platform_dev_attrs_visible(struct kobject *kobj, struct attribute *a,
 +		int n)
 +{
 +	struct device *dev = container_of(kobj, typeof(*dev), kobj);
 +
 +	if (a == &dev_attr_numa_node.attr &&
 +			dev_to_node(dev) == NUMA_NO_NODE)
 +		return 0;
 +
 +	return a->mode;
 +}
 +
 +static struct attribute *platform_dev_attrs[] = {
 +	&dev_attr_modalias.attr,
 +	&dev_attr_numa_node.attr,
 +	&dev_attr_driver_override.attr,
 +	NULL,
 +};
 +
 +static struct attribute_group platform_dev_group = {
 +	.attrs = platform_dev_attrs,
 +	.is_visible = platform_dev_attrs_visible,
 +};
 +__ATTRIBUTE_GROUPS(platform_dev);
 +
 +static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
 +{
 +	struct platform_device	*pdev = to_platform_device(dev);
 +	int rc;
 +
 +	/* Some devices have extra OF data and an OF-style MODALIAS */
 +	rc = of_device_uevent_modalias(dev, env);
 +	if (rc != -ENODEV)
 +		return rc;
 +
 +	rc = acpi_device_uevent_modalias(dev, env);
 +	if (rc != -ENODEV)
 +		return rc;
 +
 +	add_uevent_var(env, "MODALIAS=%s%s", PLATFORM_MODULE_PREFIX,
 +			pdev->name);
 +	return 0;
 +}
 +
++=======
++>>>>>>> e21d740a3fe5 (driver core: platform: reorder functions)
  static const struct platform_device_id *platform_match_id(
  			const struct platform_device_id *id,
  			struct platform_device *pdev)
* Unmerged path drivers/base/platform.c
