Bluetooth: use inclusive language in SMP

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Archie Pusaka <apusaka@chromium.org>
commit fad646e16d3cafd67d3cfff8e66f77401190957e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/fad646e1.failed

This patch replaces some non-inclusive terms based on the appropriate
language mapping table compiled by the Bluetooth SIG:
https://specificationrefs.bluetooth.com/language-mapping/Appropriate_Language_Mapping_Table.pdf

Specifically, these terms are replaced:
master -> initiator
slave  -> responder

	Signed-off-by: Archie Pusaka <apusaka@chromium.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit fad646e16d3cafd67d3cfff8e66f77401190957e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/smp.c
diff --cc net/bluetooth/smp.c
index ca58e3a1f266,6197f8ae53ab..000000000000
--- a/net/bluetooth/smp.c
+++ b/net/bluetooth/smp.c
@@@ -769,10 -753,9 +769,10 @@@ static void smp_chan_destroy(struct l2c
  	mgmt_smp_complete(hcon, complete);
  
  	kfree_sensitive(smp->csrk);
- 	kfree_sensitive(smp->slave_csrk);
+ 	kfree_sensitive(smp->responder_csrk);
  	kfree_sensitive(smp->link_key);
  
 +	crypto_free_cipher(smp->tfm_aes);
  	crypto_free_shash(smp->tfm_cmac);
  	crypto_free_kpp(smp->tfm_ecdh);
  
@@@ -994,12 -978,10 +994,17 @@@ static u8 smp_random(struct smp_chan *s
  	u8 confirm[16];
  	int ret;
  
++<<<<<<< HEAD
 +	if (IS_ERR_OR_NULL(smp->tfm_aes))
 +		return SMP_UNSPECIFIED;
++=======
+ 	bt_dev_dbg(conn->hcon->hdev, "conn %p %s", conn,
+ 		   conn->hcon->out ? "initiator" : "responder");
++>>>>>>> fad646e16d3c (Bluetooth: use inclusive language in SMP)
  
 -	ret = smp_c1(smp->tk, smp->rrnd, smp->preq, smp->prsp,
 +	BT_DBG("conn %p %s", conn, conn->hcon->out ? "master" : "slave");
 +
 +	ret = smp_c1(smp->tfm_aes, smp->tk, smp->rrnd, smp->preq, smp->prsp,
  		     hcon->init_addr_type, &hcon->init_addr,
  		     hcon->resp_addr_type, &hcon->resp_addr, confirm);
  	if (ret)
@@@ -2106,8 -2082,11 +2112,13 @@@ static u8 smp_cmd_pairing_confirm(struc
  {
  	struct l2cap_chan *chan = conn->smp;
  	struct smp_chan *smp = chan->data;
 -	struct hci_conn *hcon = conn->hcon;
 -	struct hci_dev *hdev = hcon->hdev;
  
++<<<<<<< HEAD
 +	BT_DBG("conn %p %s", conn, conn->hcon->out ? "master" : "slave");
++=======
+ 	bt_dev_dbg(hdev, "conn %p %s", conn,
+ 		   hcon->out ? "initiator" : "responder");
++>>>>>>> fad646e16d3c (Bluetooth: use inclusive language in SMP)
  
  	if (skb->len < sizeof(smp->pcnf))
  		return SMP_INVALID_PARAMS;
diff --git a/include/net/bluetooth/mgmt.h b/include/net/bluetooth/mgmt.h
index 3ea02dba9d3d..409ebaf50d14 100644
--- a/include/net/bluetooth/mgmt.h
+++ b/include/net/bluetooth/mgmt.h
@@ -196,7 +196,7 @@ struct mgmt_cp_load_link_keys {
 struct mgmt_ltk_info {
 	struct mgmt_addr_info addr;
 	__u8	type;
-	__u8	master;
+	__u8	initiator;
 	__u8	enc_size;
 	__le16	ediv;
 	__le64	rand;
diff --git a/net/bluetooth/mgmt.c b/net/bluetooth/mgmt.c
index 3cc29210fdd6..c1f68eb91379 100644
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@ -5271,7 +5271,7 @@ static int load_irks(struct sock *sk, struct hci_dev *hdev, void *cp_data,
 
 static bool ltk_is_valid(struct mgmt_ltk_info *key)
 {
-	if (key->master != 0x00 && key->master != 0x01)
+	if (key->initiator != 0x00 && key->initiator != 0x01)
 		return false;
 
 	switch (key->addr.type) {
@@ -5349,11 +5349,11 @@ static int load_long_term_keys(struct sock *sk, struct hci_dev *hdev,
 		switch (key->type) {
 		case MGMT_LTK_UNAUTHENTICATED:
 			authenticated = 0x00;
-			type = key->master ? SMP_LTK : SMP_LTK_SLAVE;
+			type = key->initiator ? SMP_LTK : SMP_LTK_RESPONDER;
 			break;
 		case MGMT_LTK_AUTHENTICATED:
 			authenticated = 0x01;
-			type = key->master ? SMP_LTK : SMP_LTK_SLAVE;
+			type = key->initiator ? SMP_LTK : SMP_LTK_RESPONDER;
 			break;
 		case MGMT_LTK_P256_UNAUTH:
 			authenticated = 0x00;
@@ -7335,7 +7335,7 @@ static u8 mgmt_ltk_type(struct smp_ltk *ltk)
 {
 	switch (ltk->type) {
 	case SMP_LTK:
-	case SMP_LTK_SLAVE:
+	case SMP_LTK_RESPONDER:
 		if (ltk->authenticated)
 			return MGMT_LTK_AUTHENTICATED;
 		return MGMT_LTK_UNAUTHENTICATED;
@@ -7381,7 +7381,7 @@ void mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, bool persistent)
 	ev.key.rand = key->rand;
 
 	if (key->type == SMP_LTK)
-		ev.key.master = 1;
+		ev.key.initiator = 1;
 
 	/* Make sure we copy only the significant bytes based on the
 	 * encryption key size, and set the rest of the value to zeroes.
* Unmerged path net/bluetooth/smp.c
diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index fc35a8bf358e..87a59ec2c9f0 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -79,8 +79,8 @@ struct smp_cmd_encrypt_info {
 	__u8	ltk[16];
 } __packed;
 
-#define SMP_CMD_MASTER_IDENT	0x07
-struct smp_cmd_master_ident {
+#define SMP_CMD_INITIATOR_IDENT	0x07
+struct smp_cmd_initiator_ident {
 	__le16	ediv;
 	__le64	rand;
 } __packed;
@@ -146,7 +146,7 @@ struct smp_cmd_keypress_notify {
 enum {
 	SMP_STK,
 	SMP_LTK,
-	SMP_LTK_SLAVE,
+	SMP_LTK_RESPONDER,
 	SMP_LTK_P256,
 	SMP_LTK_P256_DEBUG,
 };
