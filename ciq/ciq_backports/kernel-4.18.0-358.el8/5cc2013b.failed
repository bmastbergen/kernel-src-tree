regmap-irq: use fwnode instead of device node in add_irq_chip()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Michael Walle <michael@walle.cc>
commit 5cc2013bfeee756a1ee6da9bfbe42e52b4695035
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/5cc2013b.failed

Convert the argument to the newer fwnode_handle instead a device tree
node. Fortunately, there are no users for now. So this is an easy
change.

	Signed-off-by: Michael Walle <michael@walle.cc>
Link: https://lore.kernel.org/r/20200706175353.16404-2-michael@walle.cc
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 5cc2013bfeee756a1ee6da9bfbe42e52b4695035)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/regmap/regmap-irq.c
#	include/linux/regmap.h
diff --cc drivers/base/regmap/regmap-irq.c
index 6bc16d7834a3,369a57e6f89d..000000000000
--- a/drivers/base/regmap/regmap-irq.c
+++ b/drivers/base/regmap/regmap-irq.c
@@@ -429,8 -541,9 +429,14 @@@ static const struct irq_domain_ops regm
  };
  
  /**
++<<<<<<< HEAD
 + * regmap_add_irq_chip() - Use standard regmap IRQ controller handling
 + *
++=======
+  * regmap_add_irq_chip_fwnode() - Use standard regmap IRQ controller handling
+  *
+  * @fwnode: The firmware node where the IRQ domain should be added to.
++>>>>>>> 5cc2013bfeee (regmap-irq: use fwnode instead of device node in add_irq_chip())
   * @map: The regmap for the device.
   * @irq: The IRQ the device uses to signal interrupts.
   * @irq_flags: The IRQF_ flags to use for the primary interrupt.
@@@ -444,9 -557,11 +450,17 @@@
   * register cache.  The chip driver is responsible for restoring the
   * register values used by the IRQ controller over suspend and resume.
   */
++<<<<<<< HEAD
 +int regmap_add_irq_chip(struct regmap *map, int irq, int irq_flags,
 +			int irq_base, const struct regmap_irq_chip *chip,
 +			struct regmap_irq_chip_data **data)
++=======
+ int regmap_add_irq_chip_fwnode(struct fwnode_handle *fwnode,
+ 			       struct regmap *map, int irq,
+ 			       int irq_flags, int irq_base,
+ 			       const struct regmap_irq_chip *chip,
+ 			       struct regmap_irq_chip_data **data)
++>>>>>>> 5cc2013bfeee (regmap-irq: use fwnode instead of device node in add_irq_chip())
  {
  	struct regmap_irq_chip_data *d;
  	int i;
@@@ -659,11 -772,11 +673,19 @@@
  	}
  
  	if (irq_base)
++<<<<<<< HEAD
 +		d->domain = irq_domain_add_legacy(map->dev->of_node,
 +						  chip->num_irqs, irq_base, 0,
 +						  &regmap_domain_ops, d);
 +	else
 +		d->domain = irq_domain_add_linear(map->dev->of_node,
++=======
+ 		d->domain = irq_domain_add_legacy(to_of_node(fwnode),
+ 						  chip->num_irqs, irq_base,
+ 						  0, &regmap_domain_ops, d);
+ 	else
+ 		d->domain = irq_domain_add_linear(to_of_node(fwnode),
++>>>>>>> 5cc2013bfeee (regmap-irq: use fwnode instead of device node in add_irq_chip())
  						  chip->num_irqs,
  						  &regmap_domain_ops, d);
  	if (!d->domain) {
@@@ -698,6 -811,30 +720,33 @@@ err_alloc
  	kfree(d);
  	return ret;
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL_GPL(regmap_add_irq_chip_fwnode);
+ 
+ /**
+  * regmap_add_irq_chip() - Use standard regmap IRQ controller handling
+  *
+  * @map: The regmap for the device.
+  * @irq: The IRQ the device uses to signal interrupts.
+  * @irq_flags: The IRQF_ flags to use for the primary interrupt.
+  * @irq_base: Allocate at specific IRQ number if irq_base > 0.
+  * @chip: Configuration for the interrupt controller.
+  * @data: Runtime data structure for the controller, allocated on success.
+  *
+  * Returns 0 on success or an errno on failure.
+  *
+  * This is the same as regmap_add_irq_chip_fwnode, except that the firmware
+  * node of the regmap is used.
+  */
+ int regmap_add_irq_chip(struct regmap *map, int irq, int irq_flags,
+ 			int irq_base, const struct regmap_irq_chip *chip,
+ 			struct regmap_irq_chip_data **data)
+ {
+ 	return regmap_add_irq_chip_fwnode(dev_fwnode(map->dev), map, irq,
+ 					  irq_flags, irq_base, chip, data);
+ }
++>>>>>>> 5cc2013bfeee (regmap-irq: use fwnode instead of device node in add_irq_chip())
  EXPORT_SYMBOL_GPL(regmap_add_irq_chip);
  
  /**
@@@ -765,6 -902,52 +814,55 @@@ static int devm_regmap_irq_chip_match(s
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * devm_regmap_add_irq_chip_fwnode() - Resource managed regmap_add_irq_chip_fwnode()
+  *
+  * @dev: The device pointer on which irq_chip belongs to.
+  * @fwnode: The firmware node where the IRQ domain should be added to.
+  * @map: The regmap for the device.
+  * @irq: The IRQ the device uses to signal interrupts
+  * @irq_flags: The IRQF_ flags to use for the primary interrupt.
+  * @irq_base: Allocate at specific IRQ number if irq_base > 0.
+  * @chip: Configuration for the interrupt controller.
+  * @data: Runtime data structure for the controller, allocated on success
+  *
+  * Returns 0 on success or an errno on failure.
+  *
+  * The &regmap_irq_chip_data will be automatically released when the device is
+  * unbound.
+  */
+ int devm_regmap_add_irq_chip_fwnode(struct device *dev,
+ 				    struct fwnode_handle *fwnode,
+ 				    struct regmap *map, int irq,
+ 				    int irq_flags, int irq_base,
+ 				    const struct regmap_irq_chip *chip,
+ 				    struct regmap_irq_chip_data **data)
+ {
+ 	struct regmap_irq_chip_data **ptr, *d;
+ 	int ret;
+ 
+ 	ptr = devres_alloc(devm_regmap_irq_chip_release, sizeof(*ptr),
+ 			   GFP_KERNEL);
+ 	if (!ptr)
+ 		return -ENOMEM;
+ 
+ 	ret = regmap_add_irq_chip_fwnode(fwnode, map, irq, irq_flags, irq_base,
+ 					 chip, &d);
+ 	if (ret < 0) {
+ 		devres_free(ptr);
+ 		return ret;
+ 	}
+ 
+ 	*ptr = d;
+ 	devres_add(dev, ptr);
+ 	*data = d;
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(devm_regmap_add_irq_chip_fwnode);
+ 
+ /**
++>>>>>>> 5cc2013bfeee (regmap-irq: use fwnode instead of device node in add_irq_chip())
   * devm_regmap_add_irq_chip() - Resource manager regmap_add_irq_chip()
   *
   * @dev: The device pointer on which irq_chip belongs to.
@@@ -785,25 -968,9 +883,31 @@@ int devm_regmap_add_irq_chip(struct dev
  			     const struct regmap_irq_chip *chip,
  			     struct regmap_irq_chip_data **data)
  {
++<<<<<<< HEAD
 +	struct regmap_irq_chip_data **ptr, *d;
 +	int ret;
 +
 +	ptr = devres_alloc(devm_regmap_irq_chip_release, sizeof(*ptr),
 +			   GFP_KERNEL);
 +	if (!ptr)
 +		return -ENOMEM;
 +
 +	ret = regmap_add_irq_chip(map, irq, irq_flags, irq_base,
 +				  chip, &d);
 +	if (ret < 0) {
 +		devres_free(ptr);
 +		return ret;
 +	}
 +
 +	*ptr = d;
 +	devres_add(dev, ptr);
 +	*data = d;
 +	return 0;
++=======
+ 	return devm_regmap_add_irq_chip_fwnode(dev, dev_fwnode(map->dev), map,
+ 					       irq, irq_flags, irq_base, chip,
+ 					       data);
++>>>>>>> 5cc2013bfeee (regmap-irq: use fwnode instead of device node in add_irq_chip())
  }
  EXPORT_SYMBOL_GPL(devm_regmap_add_irq_chip);
  
diff --cc include/linux/regmap.h
index 03ac7d5bdb07,e2c22c0f3b9a..000000000000
--- a/include/linux/regmap.h
+++ b/include/linux/regmap.h
@@@ -20,6 -17,8 +20,11 @@@
  #include <linux/err.h>
  #include <linux/bug.h>
  #include <linux/lockdep.h>
++<<<<<<< HEAD
++=======
+ #include <linux/iopoll.h>
+ #include <linux/fwnode.h>
++>>>>>>> 5cc2013bfeee (regmap-irq: use fwnode instead of device node in add_irq_chip())
  
  struct module;
  struct clk;
@@@ -1171,12 -1312,23 +1176,29 @@@ struct regmap_irq_chip_data
  int regmap_add_irq_chip(struct regmap *map, int irq, int irq_flags,
  			int irq_base, const struct regmap_irq_chip *chip,
  			struct regmap_irq_chip_data **data);
++<<<<<<< HEAD
++=======
+ int regmap_add_irq_chip_fwnode(struct fwnode_handle *fwnode,
+ 			       struct regmap *map, int irq,
+ 			       int irq_flags, int irq_base,
+ 			       const struct regmap_irq_chip *chip,
+ 			       struct regmap_irq_chip_data **data);
++>>>>>>> 5cc2013bfeee (regmap-irq: use fwnode instead of device node in add_irq_chip())
  void regmap_del_irq_chip(int irq, struct regmap_irq_chip_data *data);
  
  int devm_regmap_add_irq_chip(struct device *dev, struct regmap *map, int irq,
  			     int irq_flags, int irq_base,
  			     const struct regmap_irq_chip *chip,
  			     struct regmap_irq_chip_data **data);
++<<<<<<< HEAD
++=======
+ int devm_regmap_add_irq_chip_fwnode(struct device *dev,
+ 				    struct fwnode_handle *fwnode,
+ 				    struct regmap *map, int irq,
+ 				    int irq_flags, int irq_base,
+ 				    const struct regmap_irq_chip *chip,
+ 				    struct regmap_irq_chip_data **data);
++>>>>>>> 5cc2013bfeee (regmap-irq: use fwnode instead of device node in add_irq_chip())
  void devm_regmap_del_irq_chip(struct device *dev, int irq,
  			      struct regmap_irq_chip_data *data);
  
* Unmerged path drivers/base/regmap/regmap-irq.c
* Unmerged path include/linux/regmap.h
