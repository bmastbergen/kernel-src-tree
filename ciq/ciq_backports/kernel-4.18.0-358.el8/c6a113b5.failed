PM: domains: enable domain idle state accounting

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Lina Iyer <ilina@codeaurora.org>
commit c6a113b52302adcfadda63af81dc05f7a669fbc8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/c6a113b5.failed

To enable better debug of PM domains, keep a track of successful
and failing attempts to enter each domain idle state.

This statistics are exported in debugfs when reading the
idle_states node associated with each PM domain.

	Signed-off-by: Lina Iyer <ilina@codeaurora.org>
[ rjw: Subject and changelog edits ]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit c6a113b52302adcfadda63af81dc05f7a669fbc8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/power/domain.c
diff --cc drivers/base/power/domain.c
index 56b0f3e7b6fc,859cdb207010..000000000000
--- a/drivers/base/power/domain.c
+++ b/drivers/base/power/domain.c
@@@ -587,33 -586,25 +587,41 @@@ static int genpd_power_off(struct gener
  	if (!genpd->gov)
  		genpd->state_idx = 0;
  
 -	/* Don't power off, if a child domain is waiting to power on. */
 -	if (atomic_read(&genpd->sd_count) > 0)
 -		return -EBUSY;
 +	if (genpd->power_off) {
 +		int ret;
  
++<<<<<<< HEAD
 +		if (atomic_read(&genpd->sd_count) > 0)
 +			return -EBUSY;
 +
 +		/*
 +		 * If sd_count > 0 at this point, one of the subdomains hasn't
 +		 * managed to call genpd_power_on() for the master yet after
 +		 * incrementing it.  In that case genpd_power_on() will wait
 +		 * for us to drop the lock, so we can call .power_off() and let
 +		 * the genpd_power_on() restore power for us (this shouldn't
 +		 * happen very often).
 +		 */
 +		ret = _genpd_power_off(genpd, true);
 +		if (ret)
 +			return ret;
++=======
+ 	ret = _genpd_power_off(genpd, true);
+ 	if (ret) {
+ 		genpd->states[genpd->state_idx].rejected++;
+ 		return ret;
++>>>>>>> c6a113b52302 (PM: domains: enable domain idle state accounting)
  	}
  
  	genpd->status = GENPD_STATE_OFF;
  	genpd_update_accounting(genpd);
+ 	genpd->states[genpd->state_idx].usage++;
  
 -	list_for_each_entry(link, &genpd->child_links, child_node) {
 -		genpd_sd_counter_dec(link->parent);
 -		genpd_lock_nested(link->parent, depth + 1);
 -		genpd_power_off(link->parent, false, depth + 1);
 -		genpd_unlock(link->parent);
 +	list_for_each_entry(link, &genpd->slave_links, slave_node) {
 +		genpd_sd_counter_dec(link->master);
 +		genpd_lock_nested(link->master, depth + 1);
 +		genpd_power_off(link->master, false, depth + 1);
 +		genpd_unlock(link->master);
  	}
  
  	return 0;
* Unmerged path drivers/base/power/domain.c
diff --git a/include/linux/pm_domain.h b/include/linux/pm_domain.h
index 2efcd4bfb87a..a14df356fa2b 100644
--- a/include/linux/pm_domain.h
+++ b/include/linux/pm_domain.h
@@ -90,6 +90,8 @@ struct genpd_power_state {
 	s64 power_off_latency_ns;
 	s64 power_on_latency_ns;
 	s64 residency_ns;
+	u64 usage;
+	u64 rejected;
 	struct fwnode_handle *fwnode;
 	ktime_t idle_time;
 	void *data;
