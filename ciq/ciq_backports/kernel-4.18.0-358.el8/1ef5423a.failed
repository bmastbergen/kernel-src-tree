x86/fpu: Handle FPU-related and clearcpuid command line arguments earlier

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Mike Hommey <mh@glandium.org>
commit 1ef5423a55c2ac6f1361811efe75b6e46d1023ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/1ef5423a.failed

FPU initialization handles them currently. However, in the case
of clearcpuid=, some other early initialization code may check for
features before the FPU initialization code is called. Handling the
argument earlier allows the command line to influence those early
initializations.

	Signed-off-by: Mike Hommey <mh@glandium.org>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20200921215638.37980-1-mh@glandium.org
(cherry picked from commit 1ef5423a55c2ac6f1361811efe75b6e46d1023ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/init.c
diff --cc arch/x86/kernel/fpu/init.c
index c88aa034efa4,701f196d7c68..000000000000
--- a/arch/x86/kernel/fpu/init.c
+++ b/arch/x86/kernel/fpu/init.c
@@@ -243,56 -237,6 +242,59 @@@ static void __init fpu__init_system_ctx
  }
  
  /*
++<<<<<<< HEAD
 + * We parse fpu parameters early because fpu__init_system() is executed
 + * before parse_early_param().
 + */
 +static void __init fpu__init_parse_early_param(void)
 +{
 +	char arg[128];
 +	char *argptr = arg;
 +	int arglen, res, bit;
 +
 +	if (cmdline_find_option_bool(boot_command_line, "no387"))
 +		setup_clear_cpu_cap(X86_FEATURE_FPU);
 +
 +	if (cmdline_find_option_bool(boot_command_line, "nofxsr")) {
 +		setup_clear_cpu_cap(X86_FEATURE_FXSR);
 +		setup_clear_cpu_cap(X86_FEATURE_FXSR_OPT);
 +		setup_clear_cpu_cap(X86_FEATURE_XMM);
 +	}
 +
 +	if (cmdline_find_option_bool(boot_command_line, "noxsave"))
 +		setup_clear_cpu_cap(X86_FEATURE_XSAVE);
 +
 +	if (cmdline_find_option_bool(boot_command_line, "noxsaveopt"))
 +		setup_clear_cpu_cap(X86_FEATURE_XSAVEOPT);
 +
 +	if (cmdline_find_option_bool(boot_command_line, "noxsaves"))
 +		setup_clear_cpu_cap(X86_FEATURE_XSAVES);
 +
 +	arglen = cmdline_find_option(boot_command_line, "clearcpuid", arg, sizeof(arg));
 +	if (arglen <= 0)
 +		return;
 +
 +	pr_info("Clearing CPUID bits:");
 +	do {
 +		res = get_option(&argptr, &bit);
 +		if (res == 0 || res == 3)
 +			break;
 +
 +		/* If the argument was too long, the last bit may be cut off */
 +		if (res == 1 && arglen >= sizeof(arg))
 +			break;
 +
 +		if (bit >= 0 && bit < NCAPINTS * 32) {
 +			pr_cont(" " X86_CAP_FMT, x86_cap_flag(bit));
 +			setup_clear_cpu_cap(bit);
 +		}
 +	} while (res == 2);
 +	pr_cont("\n");
 +}
 +
 +/*
++=======
++>>>>>>> 1ef5423a55c2 (x86/fpu: Handle FPU-related and clearcpuid command line arguments earlier)
   * Called on the boot CPU once per system bootup, to set up the initial
   * FPU state that is later cloned into all processes:
   */
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index 2f830e0242fd..1269f4dfedab 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -20,6 +20,7 @@
 #include <linux/io.h>
 #include <linux/syscore_ops.h>
 
+#include <asm/cmdline.h>
 #include <asm/stackprotector.h>
 #include <asm/perf_event.h>
 #include <asm/mmu_context.h>
@@ -1134,6 +1135,59 @@ static void detect_nopl(struct cpuinfo_x86 *c)
 #endif
 }
 
+/*
+ * We parse cpu parameters early because fpu__init_system() is executed
+ * before parse_early_param().
+ */
+static void __init cpu_parse_early_param(void)
+{
+	char arg[128];
+	char *argptr = arg;
+	int arglen, res, bit;
+
+#ifdef CONFIG_X86_32
+	if (cmdline_find_option_bool(boot_command_line, "no387"))
+#ifdef CONFIG_MATH_EMULATION
+		setup_clear_cpu_cap(X86_FEATURE_FPU);
+#else
+		pr_err("Option 'no387' required CONFIG_MATH_EMULATION enabled.\n");
+#endif
+
+	if (cmdline_find_option_bool(boot_command_line, "nofxsr"))
+		setup_clear_cpu_cap(X86_FEATURE_FXSR);
+#endif
+
+	if (cmdline_find_option_bool(boot_command_line, "noxsave"))
+		setup_clear_cpu_cap(X86_FEATURE_XSAVE);
+
+	if (cmdline_find_option_bool(boot_command_line, "noxsaveopt"))
+		setup_clear_cpu_cap(X86_FEATURE_XSAVEOPT);
+
+	if (cmdline_find_option_bool(boot_command_line, "noxsaves"))
+		setup_clear_cpu_cap(X86_FEATURE_XSAVES);
+
+	arglen = cmdline_find_option(boot_command_line, "clearcpuid", arg, sizeof(arg));
+	if (arglen <= 0)
+		return;
+
+	pr_info("Clearing CPUID bits:");
+	do {
+		res = get_option(&argptr, &bit);
+		if (res == 0 || res == 3)
+			break;
+
+		/* If the argument was too long, the last bit may be cut off */
+		if (res == 1 && arglen >= sizeof(arg))
+			break;
+
+		if (bit >= 0 && bit < NCAPINTS * 32) {
+			pr_cont(" " X86_CAP_FMT, x86_cap_flag(bit));
+			setup_clear_cpu_cap(bit);
+		}
+	} while (res == 2);
+	pr_cont("\n");
+}
+
 /*
  * Do minimum CPU detection early.
  * Fields really needed: vendor, cpuid_level, family, model, mask,
@@ -1167,6 +1221,7 @@ static void __init early_identify_cpu(struct cpuinfo_x86 *c)
 		get_model_name(c); /* RHEL8: get model name for unsupported check */
 		get_cpu_address_sizes(c);
 		setup_force_cpu_cap(X86_FEATURE_CPUID);
+		cpu_parse_early_param();
 
 		if (this_cpu->c_early_init)
 			this_cpu->c_early_init(c);
* Unmerged path arch/x86/kernel/fpu/init.c
