net: bridge: multicast: check if should use vlan mcast ctx

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 4cdd0d10f31da9fab65eb6411441ffb71a653997
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/4cdd0d10.failed

Add helpers which check if the current bridge/port multicast context
should be used (i.e. they're not disabled) and use them for Rx IGMP/MLD
processing, timers and new group addition. It is important for vlans to
disable processing of timer/packet after the multicast_lock is obtained
if the vlan context doesn't have BR_VLFLAG_MCAST_ENABLED. There are two
cases when that flag is missing:
 - if the vlan is getting destroyed it will be removed and timers will
   be stopped
 - if the vlan mcast snooping is being disabled

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4cdd0d10f31da9fab65eb6411441ffb71a653997)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
diff --cc net/bridge/br_multicast.c
index def6f1840985,4620946ec7d7..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -116,12 -141,14 +116,13 @@@ static struct net_bridge_mdb_entry *br_
  }
  #endif
  
 -struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge_mcast *brmctx,
 +struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
  					struct sk_buff *skb, u16 vid)
  {
 -	struct net_bridge *br = brmctx->br;
  	struct br_ip ip;
  
- 	if (!br_opt_get(br, BROPT_MULTICAST_ENABLED))
+ 	if (!br_opt_get(br, BROPT_MULTICAST_ENABLED) ||
+ 	    br_multicast_ctx_vlan_global_disabled(brmctx))
  		return NULL;
  
  	if (BR_INPUT_SKB_CB(skb)->igmp)
@@@ -147,6 -193,407 +148,410 @@@
  	return br_mdb_ip_get_rcu(br, &ip);
  }
  
++<<<<<<< HEAD
++=======
+ /* IMPORTANT: this function must be used only when the contexts cannot be
+  * passed down (e.g. timer) and must be used for read-only purposes because
+  * the vlan snooping option can change, so it can return any context
+  * (non-vlan or vlan). Its initial intended purpose is to read timer values
+  * from the *current* context based on the option. At worst that could lead
+  * to inconsistent timers when the contexts are changed, i.e. src timer
+  * which needs to re-arm with a specific delay taken from the old context
+  */
+ static struct net_bridge_mcast_port *
+ br_multicast_pg_to_port_ctx(const struct net_bridge_port_group *pg)
+ {
+ 	struct net_bridge_mcast_port *pmctx = &pg->key.port->multicast_ctx;
+ 	struct net_bridge_vlan *vlan;
+ 
+ 	lockdep_assert_held_once(&pg->key.port->br->multicast_lock);
+ 
+ 	/* if vlan snooping is disabled use the port's multicast context */
+ 	if (!pg->key.addr.vid ||
+ 	    !br_opt_get(pg->key.port->br, BROPT_MCAST_VLAN_SNOOPING_ENABLED))
+ 		goto out;
+ 
+ 	/* locking is tricky here, due to different rules for multicast and
+ 	 * vlans we need to take rcu to find the vlan and make sure it has
+ 	 * the BR_VLFLAG_MCAST_ENABLED flag set, it can only change under
+ 	 * multicast_lock which must be already held here, so the vlan's pmctx
+ 	 * can safely be used on return
+ 	 */
+ 	rcu_read_lock();
+ 	vlan = br_vlan_find(nbp_vlan_group(pg->key.port), pg->key.addr.vid);
+ 	if (vlan && !br_multicast_port_ctx_vlan_disabled(&vlan->port_mcast_ctx))
+ 		pmctx = &vlan->port_mcast_ctx;
+ 	else
+ 		pmctx = NULL;
+ 	rcu_read_unlock();
+ out:
+ 	return pmctx;
+ }
+ 
+ /* when snooping we need to check if the contexts should be used
+  * in the following order:
+  * - if pmctx is non-NULL (port), check if it should be used
+  * - if pmctx is NULL (bridge), check if brmctx should be used
+  */
+ static bool
+ br_multicast_ctx_should_use(const struct net_bridge_mcast *brmctx,
+ 			    const struct net_bridge_mcast_port *pmctx)
+ {
+ 	if (!netif_running(brmctx->br->dev))
+ 		return false;
+ 
+ 	if (pmctx)
+ 		return !br_multicast_port_ctx_state_disabled(pmctx);
+ 	else
+ 		return !br_multicast_ctx_vlan_disabled(brmctx);
+ }
+ 
+ static bool br_port_group_equal(struct net_bridge_port_group *p,
+ 				struct net_bridge_port *port,
+ 				const unsigned char *src)
+ {
+ 	if (p->key.port != port)
+ 		return false;
+ 
+ 	if (!(port->flags & BR_MULTICAST_TO_UNICAST))
+ 		return true;
+ 
+ 	return ether_addr_equal(src, p->eth_addr);
+ }
+ 
+ static void __fwd_add_star_excl(struct net_bridge_mcast_port *pmctx,
+ 				struct net_bridge_port_group *pg,
+ 				struct br_ip *sg_ip)
+ {
+ 	struct net_bridge_port_group_sg_key sg_key;
+ 	struct net_bridge_port_group *src_pg;
+ 	struct net_bridge_mcast *brmctx;
+ 
+ 	memset(&sg_key, 0, sizeof(sg_key));
+ 	brmctx = br_multicast_port_ctx_get_global(pmctx);
+ 	sg_key.port = pg->key.port;
+ 	sg_key.addr = *sg_ip;
+ 	if (br_sg_port_find(brmctx->br, &sg_key))
+ 		return;
+ 
+ 	src_pg = __br_multicast_add_group(brmctx, pmctx,
+ 					  sg_ip, pg->eth_addr,
+ 					  MCAST_INCLUDE, false, false);
+ 	if (IS_ERR_OR_NULL(src_pg) ||
+ 	    src_pg->rt_protocol != RTPROT_KERNEL)
+ 		return;
+ 
+ 	src_pg->flags |= MDB_PG_FLAGS_STAR_EXCL;
+ }
+ 
+ static void __fwd_del_star_excl(struct net_bridge_port_group *pg,
+ 				struct br_ip *sg_ip)
+ {
+ 	struct net_bridge_port_group_sg_key sg_key;
+ 	struct net_bridge *br = pg->key.port->br;
+ 	struct net_bridge_port_group *src_pg;
+ 
+ 	memset(&sg_key, 0, sizeof(sg_key));
+ 	sg_key.port = pg->key.port;
+ 	sg_key.addr = *sg_ip;
+ 	src_pg = br_sg_port_find(br, &sg_key);
+ 	if (!src_pg || !(src_pg->flags & MDB_PG_FLAGS_STAR_EXCL) ||
+ 	    src_pg->rt_protocol != RTPROT_KERNEL)
+ 		return;
+ 
+ 	br_multicast_find_del_pg(br, src_pg);
+ }
+ 
+ /* When a port group transitions to (or is added as) EXCLUDE we need to add it
+  * to all other ports' S,G entries which are not blocked by the current group
+  * for proper replication, the assumption is that any S,G blocked entries
+  * are already added so the S,G,port lookup should skip them.
+  * When a port group transitions from EXCLUDE -> INCLUDE mode or is being
+  * deleted we need to remove it from all ports' S,G entries where it was
+  * automatically installed before (i.e. where it's MDB_PG_FLAGS_STAR_EXCL).
+  */
+ void br_multicast_star_g_handle_mode(struct net_bridge_port_group *pg,
+ 				     u8 filter_mode)
+ {
+ 	struct net_bridge *br = pg->key.port->br;
+ 	struct net_bridge_port_group *pg_lst;
+ 	struct net_bridge_mcast_port *pmctx;
+ 	struct net_bridge_mdb_entry *mp;
+ 	struct br_ip sg_ip;
+ 
+ 	if (WARN_ON(!br_multicast_is_star_g(&pg->key.addr)))
+ 		return;
+ 
+ 	mp = br_mdb_ip_get(br, &pg->key.addr);
+ 	if (!mp)
+ 		return;
+ 	pmctx = br_multicast_pg_to_port_ctx(pg);
+ 	if (!pmctx)
+ 		return;
+ 
+ 	memset(&sg_ip, 0, sizeof(sg_ip));
+ 	sg_ip = pg->key.addr;
+ 
+ 	for (pg_lst = mlock_dereference(mp->ports, br);
+ 	     pg_lst;
+ 	     pg_lst = mlock_dereference(pg_lst->next, br)) {
+ 		struct net_bridge_group_src *src_ent;
+ 
+ 		if (pg_lst == pg)
+ 			continue;
+ 		hlist_for_each_entry(src_ent, &pg_lst->src_list, node) {
+ 			if (!(src_ent->flags & BR_SGRP_F_INSTALLED))
+ 				continue;
+ 			sg_ip.src = src_ent->addr.src;
+ 			switch (filter_mode) {
+ 			case MCAST_INCLUDE:
+ 				__fwd_del_star_excl(pg, &sg_ip);
+ 				break;
+ 			case MCAST_EXCLUDE:
+ 				__fwd_add_star_excl(pmctx, pg, &sg_ip);
+ 				break;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ /* called when adding a new S,G with host_joined == false by default */
+ static void br_multicast_sg_host_state(struct net_bridge_mdb_entry *star_mp,
+ 				       struct net_bridge_port_group *sg)
+ {
+ 	struct net_bridge_mdb_entry *sg_mp;
+ 
+ 	if (WARN_ON(!br_multicast_is_star_g(&star_mp->addr)))
+ 		return;
+ 	if (!star_mp->host_joined)
+ 		return;
+ 
+ 	sg_mp = br_mdb_ip_get(star_mp->br, &sg->key.addr);
+ 	if (!sg_mp)
+ 		return;
+ 	sg_mp->host_joined = true;
+ }
+ 
+ /* set the host_joined state of all of *,G's S,G entries */
+ static void br_multicast_star_g_host_state(struct net_bridge_mdb_entry *star_mp)
+ {
+ 	struct net_bridge *br = star_mp->br;
+ 	struct net_bridge_mdb_entry *sg_mp;
+ 	struct net_bridge_port_group *pg;
+ 	struct br_ip sg_ip;
+ 
+ 	if (WARN_ON(!br_multicast_is_star_g(&star_mp->addr)))
+ 		return;
+ 
+ 	memset(&sg_ip, 0, sizeof(sg_ip));
+ 	sg_ip = star_mp->addr;
+ 	for (pg = mlock_dereference(star_mp->ports, br);
+ 	     pg;
+ 	     pg = mlock_dereference(pg->next, br)) {
+ 		struct net_bridge_group_src *src_ent;
+ 
+ 		hlist_for_each_entry(src_ent, &pg->src_list, node) {
+ 			if (!(src_ent->flags & BR_SGRP_F_INSTALLED))
+ 				continue;
+ 			sg_ip.src = src_ent->addr.src;
+ 			sg_mp = br_mdb_ip_get(br, &sg_ip);
+ 			if (!sg_mp)
+ 				continue;
+ 			sg_mp->host_joined = star_mp->host_joined;
+ 		}
+ 	}
+ }
+ 
+ static void br_multicast_sg_del_exclude_ports(struct net_bridge_mdb_entry *sgmp)
+ {
+ 	struct net_bridge_port_group __rcu **pp;
+ 	struct net_bridge_port_group *p;
+ 
+ 	/* *,G exclude ports are only added to S,G entries */
+ 	if (WARN_ON(br_multicast_is_star_g(&sgmp->addr)))
+ 		return;
+ 
+ 	/* we need the STAR_EXCLUDE ports if there are non-STAR_EXCLUDE ports
+ 	 * we should ignore perm entries since they're managed by user-space
+ 	 */
+ 	for (pp = &sgmp->ports;
+ 	     (p = mlock_dereference(*pp, sgmp->br)) != NULL;
+ 	     pp = &p->next)
+ 		if (!(p->flags & (MDB_PG_FLAGS_STAR_EXCL |
+ 				  MDB_PG_FLAGS_PERMANENT)))
+ 			return;
+ 
+ 	/* currently the host can only have joined the *,G which means
+ 	 * we treat it as EXCLUDE {}, so for an S,G it's considered a
+ 	 * STAR_EXCLUDE entry and we can safely leave it
+ 	 */
+ 	sgmp->host_joined = false;
+ 
+ 	for (pp = &sgmp->ports;
+ 	     (p = mlock_dereference(*pp, sgmp->br)) != NULL;) {
+ 		if (!(p->flags & MDB_PG_FLAGS_PERMANENT))
+ 			br_multicast_del_pg(sgmp, p, pp);
+ 		else
+ 			pp = &p->next;
+ 	}
+ }
+ 
+ void br_multicast_sg_add_exclude_ports(struct net_bridge_mdb_entry *star_mp,
+ 				       struct net_bridge_port_group *sg)
+ {
+ 	struct net_bridge_port_group_sg_key sg_key;
+ 	struct net_bridge *br = star_mp->br;
+ 	struct net_bridge_mcast_port *pmctx;
+ 	struct net_bridge_port_group *pg;
+ 	struct net_bridge_mcast *brmctx;
+ 
+ 	if (WARN_ON(br_multicast_is_star_g(&sg->key.addr)))
+ 		return;
+ 	if (WARN_ON(!br_multicast_is_star_g(&star_mp->addr)))
+ 		return;
+ 
+ 	br_multicast_sg_host_state(star_mp, sg);
+ 	memset(&sg_key, 0, sizeof(sg_key));
+ 	sg_key.addr = sg->key.addr;
+ 	/* we need to add all exclude ports to the S,G */
+ 	for (pg = mlock_dereference(star_mp->ports, br);
+ 	     pg;
+ 	     pg = mlock_dereference(pg->next, br)) {
+ 		struct net_bridge_port_group *src_pg;
+ 
+ 		if (pg == sg || pg->filter_mode == MCAST_INCLUDE)
+ 			continue;
+ 
+ 		sg_key.port = pg->key.port;
+ 		if (br_sg_port_find(br, &sg_key))
+ 			continue;
+ 
+ 		pmctx = br_multicast_pg_to_port_ctx(pg);
+ 		if (!pmctx)
+ 			continue;
+ 		brmctx = br_multicast_port_ctx_get_global(pmctx);
+ 
+ 		src_pg = __br_multicast_add_group(brmctx, pmctx,
+ 						  &sg->key.addr,
+ 						  sg->eth_addr,
+ 						  MCAST_INCLUDE, false, false);
+ 		if (IS_ERR_OR_NULL(src_pg) ||
+ 		    src_pg->rt_protocol != RTPROT_KERNEL)
+ 			continue;
+ 		src_pg->flags |= MDB_PG_FLAGS_STAR_EXCL;
+ 	}
+ }
+ 
+ static void br_multicast_fwd_src_add(struct net_bridge_group_src *src)
+ {
+ 	struct net_bridge_mdb_entry *star_mp;
+ 	struct net_bridge_mcast_port *pmctx;
+ 	struct net_bridge_port_group *sg;
+ 	struct net_bridge_mcast *brmctx;
+ 	struct br_ip sg_ip;
+ 
+ 	if (src->flags & BR_SGRP_F_INSTALLED)
+ 		return;
+ 
+ 	memset(&sg_ip, 0, sizeof(sg_ip));
+ 	pmctx = br_multicast_pg_to_port_ctx(src->pg);
+ 	if (!pmctx)
+ 		return;
+ 	brmctx = br_multicast_port_ctx_get_global(pmctx);
+ 	sg_ip = src->pg->key.addr;
+ 	sg_ip.src = src->addr.src;
+ 
+ 	sg = __br_multicast_add_group(brmctx, pmctx, &sg_ip,
+ 				      src->pg->eth_addr, MCAST_INCLUDE, false,
+ 				      !timer_pending(&src->timer));
+ 	if (IS_ERR_OR_NULL(sg))
+ 		return;
+ 	src->flags |= BR_SGRP_F_INSTALLED;
+ 	sg->flags &= ~MDB_PG_FLAGS_STAR_EXCL;
+ 
+ 	/* if it was added by user-space as perm we can skip next steps */
+ 	if (sg->rt_protocol != RTPROT_KERNEL &&
+ 	    (sg->flags & MDB_PG_FLAGS_PERMANENT))
+ 		return;
+ 
+ 	/* the kernel is now responsible for removing this S,G */
+ 	del_timer(&sg->timer);
+ 	star_mp = br_mdb_ip_get(src->br, &src->pg->key.addr);
+ 	if (!star_mp)
+ 		return;
+ 
+ 	br_multicast_sg_add_exclude_ports(star_mp, sg);
+ }
+ 
+ static void br_multicast_fwd_src_remove(struct net_bridge_group_src *src,
+ 					bool fastleave)
+ {
+ 	struct net_bridge_port_group *p, *pg = src->pg;
+ 	struct net_bridge_port_group __rcu **pp;
+ 	struct net_bridge_mdb_entry *mp;
+ 	struct br_ip sg_ip;
+ 
+ 	memset(&sg_ip, 0, sizeof(sg_ip));
+ 	sg_ip = pg->key.addr;
+ 	sg_ip.src = src->addr.src;
+ 
+ 	mp = br_mdb_ip_get(src->br, &sg_ip);
+ 	if (!mp)
+ 		return;
+ 
+ 	for (pp = &mp->ports;
+ 	     (p = mlock_dereference(*pp, src->br)) != NULL;
+ 	     pp = &p->next) {
+ 		if (!br_port_group_equal(p, pg->key.port, pg->eth_addr))
+ 			continue;
+ 
+ 		if (p->rt_protocol != RTPROT_KERNEL &&
+ 		    (p->flags & MDB_PG_FLAGS_PERMANENT))
+ 			break;
+ 
+ 		if (fastleave)
+ 			p->flags |= MDB_PG_FLAGS_FAST_LEAVE;
+ 		br_multicast_del_pg(mp, p, pp);
+ 		break;
+ 	}
+ 	src->flags &= ~BR_SGRP_F_INSTALLED;
+ }
+ 
+ /* install S,G and based on src's timer enable or disable forwarding */
+ static void br_multicast_fwd_src_handle(struct net_bridge_group_src *src)
+ {
+ 	struct net_bridge_port_group_sg_key sg_key;
+ 	struct net_bridge_port_group *sg;
+ 	u8 old_flags;
+ 
+ 	br_multicast_fwd_src_add(src);
+ 
+ 	memset(&sg_key, 0, sizeof(sg_key));
+ 	sg_key.addr = src->pg->key.addr;
+ 	sg_key.addr.src = src->addr.src;
+ 	sg_key.port = src->pg->key.port;
+ 
+ 	sg = br_sg_port_find(src->br, &sg_key);
+ 	if (!sg || (sg->flags & MDB_PG_FLAGS_PERMANENT))
+ 		return;
+ 
+ 	old_flags = sg->flags;
+ 	if (timer_pending(&src->timer))
+ 		sg->flags &= ~MDB_PG_FLAGS_BLOCKED;
+ 	else
+ 		sg->flags |= MDB_PG_FLAGS_BLOCKED;
+ 
+ 	if (old_flags != sg->flags) {
+ 		struct net_bridge_mdb_entry *sg_mp;
+ 
+ 		sg_mp = br_mdb_ip_get(src->br, &sg_key.addr);
+ 		if (!sg_mp)
+ 			return;
+ 		br_mdb_notify(src->br->dev, sg_mp, sg, RTM_NEWMDB);
+ 	}
+ }
+ 
++>>>>>>> 4cdd0d10f31d (net: bridge: multicast: check if should use vlan mcast ctx)
  static void br_multicast_destroy_mdb_entry(struct net_bridge_mcast_gc *gc)
  {
  	struct net_bridge_mdb_entry *mp;
@@@ -844,8 -1316,63 +1249,68 @@@ void br_multicast_host_leave(struct net
  		br_mdb_notify(mp->br->dev, mp, NULL, RTM_DELMDB);
  }
  
++<<<<<<< HEAD
 +static int br_multicast_add_group(struct net_bridge *br,
 +				  struct net_bridge_port *port,
++=======
+ static struct net_bridge_port_group *
+ __br_multicast_add_group(struct net_bridge_mcast *brmctx,
+ 			 struct net_bridge_mcast_port *pmctx,
+ 			 struct br_ip *group,
+ 			 const unsigned char *src,
+ 			 u8 filter_mode,
+ 			 bool igmpv2_mldv1,
+ 			 bool blocked)
+ {
+ 	struct net_bridge_port_group __rcu **pp;
+ 	struct net_bridge_port_group *p = NULL;
+ 	struct net_bridge_mdb_entry *mp;
+ 	unsigned long now = jiffies;
+ 
+ 	if (!br_multicast_ctx_should_use(brmctx, pmctx))
+ 		goto out;
+ 
+ 	mp = br_multicast_new_group(brmctx->br, group);
+ 	if (IS_ERR(mp))
+ 		return ERR_CAST(mp);
+ 
+ 	if (!pmctx) {
+ 		br_multicast_host_join(mp, true);
+ 		goto out;
+ 	}
+ 
+ 	for (pp = &mp->ports;
+ 	     (p = mlock_dereference(*pp, brmctx->br)) != NULL;
+ 	     pp = &p->next) {
+ 		if (br_port_group_equal(p, pmctx->port, src))
+ 			goto found;
+ 		if ((unsigned long)p->key.port < (unsigned long)pmctx->port)
+ 			break;
+ 	}
+ 
+ 	p = br_multicast_new_port_group(pmctx->port, group, *pp, 0, src,
+ 					filter_mode, RTPROT_KERNEL);
+ 	if (unlikely(!p)) {
+ 		p = ERR_PTR(-ENOMEM);
+ 		goto out;
+ 	}
+ 	rcu_assign_pointer(*pp, p);
+ 	if (blocked)
+ 		p->flags |= MDB_PG_FLAGS_BLOCKED;
+ 	br_mdb_notify(brmctx->br->dev, mp, p, RTM_NEWMDB);
+ 
+ found:
+ 	if (igmpv2_mldv1)
+ 		mod_timer(&p->timer,
+ 			  now + brmctx->multicast_membership_interval);
+ 
+ out:
+ 	return p;
+ }
+ 
+ static int br_multicast_add_group(struct net_bridge_mcast *brmctx,
+ 				  struct net_bridge_mcast_port *pmctx,
++>>>>>>> 4cdd0d10f31d (net: bridge: multicast: check if should use vlan mcast ctx)
  				  struct br_ip *group,
  				  const unsigned char *src,
  				  u8 filter_mode,
@@@ -974,35 -1509,55 +1439,42 @@@ static void br_mc_router_state_change(s
  		.u.mrouter = is_mc_router,
  	};
  
 -	switchdev_port_attr_set(p->dev, &attr, NULL);
 +	switchdev_port_attr_set(p->dev, &attr);
  }
  
 -static void br_multicast_local_router_expired(struct net_bridge_mcast *brmctx,
 -					      struct timer_list *timer)
 +static void br_multicast_local_router_expired(struct timer_list *t)
  {
 -	spin_lock(&brmctx->br->multicast_lock);
 -	if (brmctx->multicast_router == MDB_RTR_TYPE_DISABLED ||
 -	    brmctx->multicast_router == MDB_RTR_TYPE_PERM ||
 -	    br_ip4_multicast_is_router(brmctx) ||
 -	    br_ip6_multicast_is_router(brmctx))
 +	struct net_bridge *br = from_timer(br, t, multicast_router_timer);
 +
 +	spin_lock(&br->multicast_lock);
 +	if (br->multicast_router == MDB_RTR_TYPE_DISABLED ||
 +	    br->multicast_router == MDB_RTR_TYPE_PERM ||
 +	    timer_pending(&br->multicast_router_timer))
  		goto out;
  
 -	br_mc_router_state_change(brmctx->br, false);
 +	br_mc_router_state_change(br, false);
  out:
 -	spin_unlock(&brmctx->br->multicast_lock);
 -}
 -
 -static void br_ip4_multicast_local_router_expired(struct timer_list *t)
 -{
 -	struct net_bridge_mcast *brmctx = from_timer(brmctx, t,
 -						     ip4_mc_router_timer);
 -
 -	br_multicast_local_router_expired(brmctx, t);
 -}
 -
 -#if IS_ENABLED(CONFIG_IPV6)
 -static void br_ip6_multicast_local_router_expired(struct timer_list *t)
 -{
 -	struct net_bridge_mcast *brmctx = from_timer(brmctx, t,
 -						     ip6_mc_router_timer);
 -
 -	br_multicast_local_router_expired(brmctx, t);
 +	spin_unlock(&br->multicast_lock);
  }
 -#endif
  
 -static void br_multicast_querier_expired(struct net_bridge_mcast *brmctx,
 +static void br_multicast_querier_expired(struct net_bridge *br,
  					 struct bridge_mcast_own_query *query)
  {
++<<<<<<< HEAD
 +	spin_lock(&br->multicast_lock);
 +	if (!netif_running(br->dev) || !br_opt_get(br, BROPT_MULTICAST_ENABLED))
++=======
+ 	spin_lock(&brmctx->br->multicast_lock);
+ 	if (!netif_running(brmctx->br->dev) ||
+ 	    br_multicast_ctx_vlan_global_disabled(brmctx) ||
+ 	    !br_opt_get(brmctx->br, BROPT_MULTICAST_ENABLED))
++>>>>>>> 4cdd0d10f31d (net: bridge: multicast: check if should use vlan mcast ctx)
  		goto out;
  
 -	br_multicast_start_querier(brmctx, query);
 +	br_multicast_start_querier(br, query);
  
  out:
 -	spin_unlock(&brmctx->br->multicast_lock);
 +	spin_unlock(&br->multicast_lock);
  }
  
  static void br_ip4_multicast_querier_expired(struct timer_list *t)
@@@ -1081,16 -1638,16 +1553,22 @@@ static void br_multicast_send_query(str
  	struct br_ip br_group;
  	unsigned long time;
  
++<<<<<<< HEAD
 +	if (!netif_running(br->dev) ||
 +	    !br_opt_get(br, BROPT_MULTICAST_ENABLED) ||
 +	    !br_opt_get(br, BROPT_MULTICAST_QUERIER))
++=======
+ 	if (!br_multicast_ctx_should_use(brmctx, pmctx) ||
+ 	    !br_opt_get(brmctx->br, BROPT_MULTICAST_ENABLED) ||
+ 	    !br_opt_get(brmctx->br, BROPT_MULTICAST_QUERIER))
++>>>>>>> 4cdd0d10f31d (net: bridge: multicast: check if should use vlan mcast ctx)
  		return;
  
 -	memset(&br_group.dst, 0, sizeof(br_group.dst));
 +	memset(&br_group.u, 0, sizeof(br_group.u));
  
 -	if (pmctx ? (own_query == &pmctx->ip4_own_query) :
 -		    (own_query == &brmctx->ip4_own_query)) {
 -		other_query = &brmctx->ip4_other_query;
 +	if (port ? (own_query == &port->ip4_own_query) :
 +		   (own_query == &br->ip4_own_query)) {
 +		other_query = &br->ip4_other_query;
  		br_group.proto = htons(ETH_P_IP);
  #if IS_ENABLED(CONFIG_IPV6)
  	} else {
@@@ -1113,20 -1670,20 +1591,34 @@@
  }
  
  static void
 -br_multicast_port_query_expired(struct net_bridge_mcast_port *pmctx,
 +br_multicast_port_query_expired(struct net_bridge_port *port,
  				struct bridge_mcast_own_query *query)
  {
++<<<<<<< HEAD
 +	struct net_bridge *br = port->br;
 +
 +	spin_lock(&br->multicast_lock);
 +	if (port->state == BR_STATE_DISABLED ||
 +	    port->state == BR_STATE_BLOCKING)
 +		goto out;
 +
 +	if (query->startup_sent < br->multicast_startup_query_count)
 +		query->startup_sent++;
 +
 +	br_multicast_send_query(port->br, port, query);
++=======
+ 	struct net_bridge *br = pmctx->port->br;
+ 	struct net_bridge_mcast *brmctx;
+ 
+ 	spin_lock(&br->multicast_lock);
+ 	if (br_multicast_port_ctx_state_stopped(pmctx))
+ 		goto out;
+ 	brmctx = br_multicast_port_ctx_get_global(pmctx);
+ 	if (query->startup_sent < brmctx->multicast_startup_query_count)
+ 		query->startup_sent++;
+ 
+ 	br_multicast_send_query(brmctx, pmctx, query);
++>>>>>>> 4cdd0d10f31d (net: bridge: multicast: check if should use vlan mcast ctx)
  
  out:
  	spin_unlock(&br->multicast_lock);
@@@ -1896,42 -2597,52 +2388,50 @@@ static int br_ip4_multicast_igmp3_repor
  				break;
  		}
  
 -		if (!pmctx || igmpv2)
 +		if (!port || igmpv2)
  			continue;
  
++<<<<<<< HEAD
 +		spin_lock_bh(&br->multicast_lock);
 +		mdst = br_mdb_ip4_get(br, group, vid);
++=======
+ 		spin_lock_bh(&brmctx->br->multicast_lock);
+ 		if (!br_multicast_ctx_should_use(brmctx, pmctx))
+ 			goto unlock_continue;
+ 
+ 		mdst = br_mdb_ip4_get(brmctx->br, group, vid);
++>>>>>>> 4cdd0d10f31d (net: bridge: multicast: check if should use vlan mcast ctx)
  		if (!mdst)
  			goto unlock_continue;
 -		pg = br_multicast_find_port(mdst, pmctx->port, src);
 +		pg = br_multicast_find_port(mdst, port, src);
  		if (!pg || (pg->flags & MDB_PG_FLAGS_PERMANENT))
  			goto unlock_continue;
 -		/* reload grec and host addr */
 +		/* reload grec */
  		grec = (void *)(skb->data + len - sizeof(*grec) - (nsrcs * 4));
 -		h_addr = &ip_hdr(skb)->saddr;
  		switch (type) {
  		case IGMPV3_ALLOW_NEW_SOURCES:
 -			changed = br_multicast_isinc_allow(brmctx, pg, h_addr,
 -							   grec->grec_src,
 -							   nsrcs, sizeof(__be32), type);
 +			changed = br_multicast_isinc_allow(pg, grec->grec_src,
 +							   nsrcs, sizeof(__be32));
  			break;
  		case IGMPV3_MODE_IS_INCLUDE:
 -			changed = br_multicast_isinc_allow(brmctx, pg, h_addr,
 -							   grec->grec_src,
 -							   nsrcs, sizeof(__be32), type);
 +			changed = br_multicast_isinc_allow(pg, grec->grec_src, nsrcs,
 +							   sizeof(__be32));
  			break;
  		case IGMPV3_MODE_IS_EXCLUDE:
 -			changed = br_multicast_isexc(brmctx, pg, h_addr,
 -						     grec->grec_src,
 -						     nsrcs, sizeof(__be32), type);
 +			changed = br_multicast_isexc(pg, grec->grec_src, nsrcs,
 +						     sizeof(__be32));
  			break;
  		case IGMPV3_CHANGE_TO_INCLUDE:
 -			changed = br_multicast_toin(brmctx, pmctx, pg, h_addr,
 -						    grec->grec_src,
 -						    nsrcs, sizeof(__be32), type);
 +			changed = br_multicast_toin(pg, grec->grec_src, nsrcs,
 +						    sizeof(__be32));
  			break;
  		case IGMPV3_CHANGE_TO_EXCLUDE:
 -			changed = br_multicast_toex(brmctx, pmctx, pg, h_addr,
 -						    grec->grec_src,
 -						    nsrcs, sizeof(__be32), type);
 +			changed = br_multicast_toex(pg, grec->grec_src, nsrcs,
 +						    sizeof(__be32));
  			break;
  		case IGMPV3_BLOCK_OLD_SOURCES:
 -			changed = br_multicast_block(brmctx, pmctx, pg, h_addr,
 -						     grec->grec_src,
 -						     nsrcs, sizeof(__be32), type);
 +			changed = br_multicast_block(pg, grec->grec_src, nsrcs,
 +						     sizeof(__be32));
  			break;
  		}
  		if (changed)
@@@ -2023,41 -2735,56 +2523,49 @@@ static int br_ip6_multicast_mld2_report
  				break;
  		}
  
 -		if (!pmctx || mldv1)
 +		if (!port || mldv1)
  			continue;
  
++<<<<<<< HEAD
 +		spin_lock_bh(&br->multicast_lock);
 +		mdst = br_mdb_ip6_get(br, &grec->grec_mca, vid);
++=======
+ 		spin_lock_bh(&brmctx->br->multicast_lock);
+ 		if (!br_multicast_ctx_should_use(brmctx, pmctx))
+ 			goto unlock_continue;
+ 
+ 		mdst = br_mdb_ip6_get(brmctx->br, &grec->grec_mca, vid);
++>>>>>>> 4cdd0d10f31d (net: bridge: multicast: check if should use vlan mcast ctx)
  		if (!mdst)
  			goto unlock_continue;
 -		pg = br_multicast_find_port(mdst, pmctx->port, src);
 +		pg = br_multicast_find_port(mdst, port, src);
  		if (!pg || (pg->flags & MDB_PG_FLAGS_PERMANENT))
  			goto unlock_continue;
 -		h_addr = &ipv6_hdr(skb)->saddr;
  		switch (grec->grec_type) {
  		case MLD2_ALLOW_NEW_SOURCES:
 -			changed = br_multicast_isinc_allow(brmctx, pg, h_addr,
 -							   grec->grec_src, nsrcs,
 -							   sizeof(struct in6_addr),
 -							   grec->grec_type);
 +			changed = br_multicast_isinc_allow(pg, grec->grec_src,
 +							   nsrcs,
 +							   sizeof(struct in6_addr));
  			break;
  		case MLD2_MODE_IS_INCLUDE:
 -			changed = br_multicast_isinc_allow(brmctx, pg, h_addr,
 -							   grec->grec_src, nsrcs,
 -							   sizeof(struct in6_addr),
 -							   grec->grec_type);
 +			changed = br_multicast_isinc_allow(pg, grec->grec_src, nsrcs,
 +							   sizeof(struct in6_addr));
  			break;
  		case MLD2_MODE_IS_EXCLUDE:
 -			changed = br_multicast_isexc(brmctx, pg, h_addr,
 -						     grec->grec_src, nsrcs,
 -						     sizeof(struct in6_addr),
 -						     grec->grec_type);
 +			changed = br_multicast_isexc(pg, grec->grec_src, nsrcs,
 +						     sizeof(struct in6_addr));
  			break;
  		case MLD2_CHANGE_TO_INCLUDE:
 -			changed = br_multicast_toin(brmctx, pmctx, pg, h_addr,
 -						    grec->grec_src, nsrcs,
 -						    sizeof(struct in6_addr),
 -						    grec->grec_type);
 +			changed = br_multicast_toin(pg, grec->grec_src, nsrcs,
 +						    sizeof(struct in6_addr));
  			break;
  		case MLD2_CHANGE_TO_EXCLUDE:
 -			changed = br_multicast_toex(brmctx, pmctx, pg, h_addr,
 -						    grec->grec_src, nsrcs,
 -						    sizeof(struct in6_addr),
 -						    grec->grec_type);
 +			changed = br_multicast_toex(pg, grec->grec_src, nsrcs,
 +						    sizeof(struct in6_addr));
  			break;
  		case MLD2_BLOCK_OLD_SOURCES:
 -			changed = br_multicast_block(brmctx, pmctx, pg, h_addr,
 -						     grec->grec_src, nsrcs,
 -						     sizeof(struct in6_addr),
 -						     grec->grec_type);
 +			changed = br_multicast_block(pg, grec->grec_src, nsrcs,
 +						     sizeof(struct in6_addr));
  			break;
  		}
  		if (changed)
@@@ -2176,12 -2987,15 +2684,24 @@@ static void br_multicast_mark_router(st
  {
  	unsigned long now = jiffies;
  
++<<<<<<< HEAD
 +	if (!port) {
 +		if (br->multicast_router == MDB_RTR_TYPE_TEMP_QUERY) {
 +			if (!timer_pending(&br->multicast_router_timer))
 +				br_mc_router_state_change(br, true);
 +			mod_timer(&br->multicast_router_timer,
 +				  now + br->multicast_querier_interval);
++=======
+ 	if (!br_multicast_ctx_should_use(brmctx, pmctx))
+ 		return;
+ 
+ 	if (!pmctx) {
+ 		if (brmctx->multicast_router == MDB_RTR_TYPE_TEMP_QUERY) {
+ 			if (!br_ip4_multicast_is_router(brmctx) &&
+ 			    !br_ip6_multicast_is_router(brmctx))
+ 				br_mc_router_state_change(brmctx->br, true);
+ 			mod_timer(timer, now + brmctx->multicast_querier_interval);
++>>>>>>> 4cdd0d10f31d (net: bridge: multicast: check if should use vlan mcast ctx)
  		}
  		return;
  	}
@@@ -2243,9 -3087,8 +2763,14 @@@ static void br_ip4_multicast_query(stru
  	unsigned long now = jiffies;
  	__be32 group;
  
++<<<<<<< HEAD
 +	spin_lock(&br->multicast_lock);
 +	if (!netif_running(br->dev) ||
 +	    (port && port->state == BR_STATE_DISABLED))
++=======
+ 	spin_lock(&brmctx->br->multicast_lock);
+ 	if (!br_multicast_ctx_should_use(brmctx, pmctx))
++>>>>>>> 4cdd0d10f31d (net: bridge: multicast: check if should use vlan mcast ctx)
  		goto out;
  
  	group = ih->group;
@@@ -2325,9 -3170,8 +2850,14 @@@ static int br_ip6_multicast_query(struc
  	bool is_general_query;
  	int err = 0;
  
++<<<<<<< HEAD
 +	spin_lock(&br->multicast_lock);
 +	if (!netif_running(br->dev) ||
 +	    (port && port->state == BR_STATE_DISABLED))
++=======
+ 	spin_lock(&brmctx->br->multicast_lock);
+ 	if (!br_multicast_ctx_should_use(brmctx, pmctx))
++>>>>>>> 4cdd0d10f31d (net: bridge: multicast: check if should use vlan mcast ctx)
  		goto out;
  
  	if (transport_len == sizeof(*mld)) {
@@@ -2409,12 -3254,11 +2939,17 @@@ br_multicast_leave_group(struct net_bri
  	unsigned long now;
  	unsigned long time;
  
++<<<<<<< HEAD
 +	spin_lock(&br->multicast_lock);
 +	if (!netif_running(br->dev) ||
 +	    (port && port->state == BR_STATE_DISABLED))
++=======
+ 	spin_lock(&brmctx->br->multicast_lock);
+ 	if (!br_multicast_ctx_should_use(brmctx, pmctx))
++>>>>>>> 4cdd0d10f31d (net: bridge: multicast: check if should use vlan mcast ctx)
  		goto out;
  
 -	mp = br_mdb_ip_get(brmctx->br, group);
 +	mp = br_mdb_ip_get(br, group);
  	if (!mp)
  		goto out;
  
@@@ -2756,13 -3633,17 +3291,27 @@@ static void br_multicast_query_expired(
  				       struct bridge_mcast_own_query *query,
  				       struct bridge_mcast_querier *querier)
  {
++<<<<<<< HEAD
 +	spin_lock(&br->multicast_lock);
 +	if (query->startup_sent < br->multicast_startup_query_count)
 +		query->startup_sent++;
 +
 +	RCU_INIT_POINTER(querier->port, NULL);
 +	br_multicast_send_query(br, NULL, query);
 +	spin_unlock(&br->multicast_lock);
++=======
+ 	spin_lock(&brmctx->br->multicast_lock);
+ 	if (br_multicast_ctx_vlan_disabled(brmctx))
+ 		goto out;
+ 
+ 	if (query->startup_sent < brmctx->multicast_startup_query_count)
+ 		query->startup_sent++;
+ 
+ 	RCU_INIT_POINTER(querier->port, NULL);
+ 	br_multicast_send_query(brmctx, NULL, query);
+ out:
+ 	spin_unlock(&brmctx->br->multicast_lock);
++>>>>>>> 4cdd0d10f31d (net: bridge: multicast: check if should use vlan mcast ctx)
  }
  
  static void br_ip4_multicast_query_expired(struct timer_list *t)
* Unmerged path net/bridge/br_multicast.c
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e7ccf58bc2f4..93771f577805 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -819,6 +819,24 @@ static inline unsigned long br_multicast_gmi(const struct net_bridge *br)
 	return 2 * br->multicast_query_interval +
 	       br->multicast_query_response_interval;
 }
+
+static inline bool
+br_multicast_port_ctx_state_disabled(const struct net_bridge_mcast_port *pmctx)
+{
+	return pmctx->port->state == BR_STATE_DISABLED ||
+	       (br_multicast_port_ctx_is_vlan(pmctx) &&
+		(br_multicast_port_ctx_vlan_disabled(pmctx) ||
+		 pmctx->vlan->state == BR_STATE_DISABLED));
+}
+
+static inline bool
+br_multicast_port_ctx_state_stopped(const struct net_bridge_mcast_port *pmctx)
+{
+	return br_multicast_port_ctx_state_disabled(pmctx) ||
+	       pmctx->port->state == BR_STATE_BLOCKING ||
+	       (br_multicast_port_ctx_is_vlan(pmctx) &&
+		pmctx->vlan->state == BR_STATE_BLOCKING);
+}
 #else
 static inline int br_multicast_rcv(struct net_bridge *br,
 				   struct net_bridge_port *port,
