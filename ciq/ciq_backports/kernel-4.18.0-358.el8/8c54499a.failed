zram: don't fail to remove zram during unloading module

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Ming Lei <ming.lei@redhat.com>
commit 8c54499a59b026a3dc2afccf6e1b36d5700d2fef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/8c54499a.failed

When the zram module is being unloaded, no one should be using the
zram disks. However even while being unloaded the zram module's
sysfs attributes might be poked at to re-configure zram devices.
This is expected, and kernfs ensures that these operations complete
before device_del() completes.

But reset_store() may set ->claim which will fail zram_remove(), when
this happens, zram_reset_device() is bypassed, and zram->comp can't
be destroyed, so the warning of 'Error: Removing state 63 which has
instances left.' is triggered during unloading module, together with
memory leak and sort of thing.

Fixes the issue by not failing zram_remove() if ->claim is set, and
we actually need to do nothing in case that zram_reset() is running
since del_gendisk() will wait until zram_reset() is done.

	Reported-by: Luis Chamberlain <mcgrof@kernel.org>
	Reviewed-by: Luis Chamberlain <mcgrof@kernel.org>
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Acked-by: Minchan Kim <minchan@kernel.org>
Link: https://lore.kernel.org/r/20211025025426.2815424-3-ming.lei@redhat.com
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 8c54499a59b026a3dc2afccf6e1b36d5700d2fef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/zram/zram_drv.c
diff --cc drivers/block/zram/zram_drv.c
index 55c88306734b,13b65ebbab8d..000000000000
--- a/drivers/block/zram/zram_drv.c
+++ b/drivers/block/zram/zram_drv.c
@@@ -1726,34 -1971,42 +1726,72 @@@ out_free_dev
  
  static int zram_remove(struct zram *zram)
  {
++<<<<<<< HEAD
 +	struct block_device *bdev;
 +
 +	bdev = bdget_disk(zram->disk, 0);
 +	if (!bdev)
 +		return -ENOMEM;
 +
 +	mutex_lock(&bdev->bd_mutex);
 +	if (bdev->bd_openers || zram->claim) {
 +		mutex_unlock(&bdev->bd_mutex);
 +		bdput(bdev);
 +		return -EBUSY;
 +	}
 +
 +	zram->claim = true;
 +	mutex_unlock(&bdev->bd_mutex);
 +
 +	zram_debugfs_unregister(zram);
 +
 +	/* Make sure all the pending I/O are finished */
 +	fsync_bdev(bdev);
 +	zram_reset_device(zram);
 +	bdput(bdev);
++=======
+ 	struct block_device *bdev = zram->disk->part0;
+ 	bool claimed;
+ 
+ 	mutex_lock(&bdev->bd_disk->open_mutex);
+ 	if (bdev->bd_openers) {
+ 		mutex_unlock(&bdev->bd_disk->open_mutex);
+ 		return -EBUSY;
+ 	}
+ 
+ 	claimed = zram->claim;
+ 	if (!claimed)
+ 		zram->claim = true;
+ 	mutex_unlock(&bdev->bd_disk->open_mutex);
+ 
+ 	zram_debugfs_unregister(zram);
+ 
+ 	if (claimed) {
+ 		/*
+ 		 * If we were claimed by reset_store(), del_gendisk() will
+ 		 * wait until reset_store() is done, so nothing need to do.
+ 		 */
+ 		;
+ 	} else {
+ 		/* Make sure all the pending I/O are finished */
+ 		fsync_bdev(bdev);
+ 		zram_reset_device(zram);
+ 	}
++>>>>>>> 8c54499a59b0 (zram: don't fail to remove zram during unloading module)
  
  	pr_info("Removed device: %s\n", zram->disk->disk_name);
  
  	del_gendisk(zram->disk);
++<<<<<<< HEAD
 +	blk_cleanup_queue(zram->disk->queue);
 +	put_disk(zram->disk);
++=======
+ 
+ 	/* del_gendisk drains pending reset_store */
+ 	WARN_ON_ONCE(claimed && zram->claim);
+ 
+ 	blk_cleanup_disk(zram->disk);
++>>>>>>> 8c54499a59b0 (zram: don't fail to remove zram during unloading module)
  	kfree(zram);
  	return 0;
  }
* Unmerged path drivers/block/zram/zram_drv.c
