tty: 8250_of: Use software emulated RS485 direction control

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Heiko Schocher <hs@denx.de>
commit 0c11b88883db1a83980633fc88091d3cdd79bd48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/0c11b888.failed

Use software emulated RS485 direction control to provide RS485 API

Currently it is not possible to use rs485 as pointer to
rs485_config struct in struct uart_port is NULL in case we
configure the port through device tree.

	Signed-off-by: Heiko Schocher <hs@denx.de>

Link: https://lore.kernel.org/r/20190913050105.1132080-1-hs@denx.de
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 0c11b88883db1a83980633fc88091d3cdd79bd48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/serial/8250/8250_of.c
diff --cc drivers/tty/serial/8250/8250_of.c
index f7e76c160d0a,92fbf46ce3bd..000000000000
--- a/drivers/tty/serial/8250/8250_of.c
+++ b/drivers/tty/serial/8250/8250_of.c
@@@ -25,6 -26,58 +25,61 @@@ struct of_serial_info 
  	int line;
  };
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARCH_TEGRA
+ static void tegra_serial_handle_break(struct uart_port *p)
+ {
+ 	unsigned int status, tmout = 10000;
+ 
+ 	do {
+ 		status = p->serial_in(p, UART_LSR);
+ 		if (status & (UART_LSR_FIFOE | UART_LSR_BRK_ERROR_BITS))
+ 			status = p->serial_in(p, UART_RX);
+ 		else
+ 			break;
+ 		if (--tmout == 0)
+ 			break;
+ 		udelay(1);
+ 	} while (1);
+ }
+ #else
+ static inline void tegra_serial_handle_break(struct uart_port *port)
+ {
+ }
+ #endif
+ 
+ static int of_8250_rs485_config(struct uart_port *port,
+ 				  struct serial_rs485 *rs485)
+ {
+ 	struct uart_8250_port *up = up_to_u8250p(port);
+ 
+ 	/* Clamp the delays to [0, 100ms] */
+ 	rs485->delay_rts_before_send = min(rs485->delay_rts_before_send, 100U);
+ 	rs485->delay_rts_after_send  = min(rs485->delay_rts_after_send, 100U);
+ 
+ 	port->rs485 = *rs485;
+ 
+ 	/*
+ 	 * Both serial8250_em485_init and serial8250_em485_destroy
+ 	 * are idempotent
+ 	 */
+ 	if (rs485->flags & SER_RS485_ENABLED) {
+ 		int ret = serial8250_em485_init(up);
+ 
+ 		if (ret) {
+ 			rs485->flags &= ~SER_RS485_ENABLED;
+ 			port->rs485.flags &= ~SER_RS485_ENABLED;
+ 		}
+ 		return ret;
+ 	}
+ 
+ 	serial8250_em485_destroy(up);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 0c11b88883db (tty: 8250_of: Use software emulated RS485 direction control)
  /*
   * Fill a struct uart_port for a given device node
   */
@@@ -150,8 -208,13 +205,9 @@@ static int of_platform_serial_setup(str
  		port->flags |= UPF_SKIP_TEST;
  
  	port->dev = &ofdev->dev;
+ 	port->rs485_config = of_8250_rs485_config;
  
  	switch (type) {
 -	case PORT_TEGRA:
 -		port->handle_break = tegra_serial_handle_break;
 -		break;
 -
  	case PORT_RT2880:
  		port->iotype = UPIO_AU;
  		break;
* Unmerged path drivers/tty/serial/8250/8250_of.c
