mm, slub: restore irqs around calling new_slab()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Vlastimil Babka <vbabka@suse.cz>
commit 6c1dbb674c5cf76d23381160577d34bead60b76b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/6c1dbb67.failed

allocate_slab() currently re-enables irqs before calling to the page allocator.
It depends on gfpflags_allow_blocking() to determine if it's safe to do so.
Now we can instead simply restore irq before calling it through new_slab().
The other caller early_kmem_cache_node_alloc() is unaffected by this.

	Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
(cherry picked from commit 6c1dbb674c5cf76d23381160577d34bead60b76b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/slub.c
diff --cc mm/slub.c
index 18ea2f53cb90,7798ba1c614f..000000000000
--- a/mm/slub.c
+++ b/mm/slub.c
@@@ -2696,14 -2807,17 +2691,23 @@@ new_slab
  		goto check_new_page;
  	}
  
++<<<<<<< HEAD
++=======
+ 	local_irq_restore(flags);
+ 	put_cpu_ptr(s->cpu_slab);
++>>>>>>> 6c1dbb674c5c (mm, slub: restore irqs around calling new_slab())
  	page = new_slab(s, gfpflags, node);
 -	c = get_cpu_ptr(s->cpu_slab);
  
  	if (unlikely(!page)) {
  		slab_out_of_memory(s, gfpflags, node);
  		return NULL;
  	}
  
++<<<<<<< HEAD
 +	c = raw_cpu_ptr(s->cpu_slab);
++=======
+ 	local_irq_save(flags);
++>>>>>>> 6c1dbb674c5c (mm, slub: restore irqs around calling new_slab())
  	if (c->page)
  		flush_slab(s, c);
  
* Unmerged path mm/slub.c
