net: bridge: mcast: install S,G entries automatically based on reports

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit b08123684bd55fa6d6ee4b52d4ae3040fadb5aa2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/b0812368.failed

This patch adds support for automatic install of S,G mdb entries based
on the port group's source list and the source entry's timer.
Once installed the S,G will be used when forwarding packets if the
approprate multicast/mld versions are set. A new source flag called
BR_SGRP_F_INSTALLED denotes if the source has a forwarding mdb entry
installed.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b08123684bd55fa6d6ee4b52d4ae3040fadb5aa2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
diff --cc net/bridge/br_multicast.c
index 28b757a17768,ece8ac805e98..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -65,7 -66,24 +65,14 @@@ static void br_ip6_multicast_leave_grou
  					 const struct in6_addr *group,
  					 __u16 vid, const unsigned char *src);
  #endif
+ static struct net_bridge_port_group *
+ __br_multicast_add_group(struct net_bridge *br,
+ 			 struct net_bridge_port *port,
+ 			 struct br_ip *group,
+ 			 const unsigned char *src,
+ 			 u8 filter_mode,
+ 			 bool igmpv2_mldv1);
  
 -static struct net_bridge_port_group *
 -br_sg_port_find(struct net_bridge *br,
 -		struct net_bridge_port_group_sg_key *sg_p)
 -{
 -	lockdep_assert_held_once(&br->multicast_lock);
 -
 -	return rhashtable_lookup_fast(&br->sg_port_tbl, sg_p,
 -				      br_sg_port_rht_params);
 -}
 -
  static struct net_bridge_mdb_entry *br_mdb_ip_get_rcu(struct net_bridge *br,
  						      struct br_ip *dst)
  {
@@@ -200,8 -312,9 +283,9 @@@ static void br_multicast_destroy_group_
  
  static void br_multicast_del_group_src(struct net_bridge_group_src *src)
  {
 -	struct net_bridge *br = src->pg->key.port->br;
 +	struct net_bridge *br = src->pg->port->br;
  
+ 	br_multicast_fwd_src_remove(src);
  	hlist_del_init_rcu(&src->node);
  	src->pg->src_ents--;
  	hlist_add_head(&src->mcast_gc.gc_node, &br->mcast_gc_list);
@@@ -810,19 -935,6 +894,22 @@@ struct net_bridge_port_group *br_multic
  	return p;
  }
  
++<<<<<<< HEAD
 +static bool br_port_group_equal(struct net_bridge_port_group *p,
 +				struct net_bridge_port *port,
 +				const unsigned char *src)
 +{
 +	if (p->port != port)
 +		return false;
 +
 +	if (!(port->flags & BR_MULTICAST_TO_UNICAST))
 +		return true;
 +
 +	return ether_addr_equal(src, p->eth_addr);
 +}
 +
++=======
++>>>>>>> b08123684bd5 (net: bridge: mcast: install S,G entries automatically based on reports)
  void br_multicast_host_join(struct net_bridge_mdb_entry *mp, bool notify)
  {
  	if (!mp->host_joined) {
@@@ -880,9 -990,12 +965,18 @@@ __br_multicast_add_group(struct net_bri
  			break;
  	}
  
++<<<<<<< HEAD
 +	p = br_multicast_new_port_group(port, group, *pp, 0, src, filter_mode);
 +	if (unlikely(!p))
 +		goto err;
++=======
+ 	p = br_multicast_new_port_group(port, group, *pp, 0, src, filter_mode,
+ 					RTPROT_KERNEL);
+ 	if (unlikely(!p)) {
+ 		p = ERR_PTR(-ENOMEM);
+ 		goto out;
+ 	}
++>>>>>>> b08123684bd5 (net: bridge: mcast: install S,G entries automatically based on reports)
  	rcu_assign_pointer(*pp, p);
  	br_mdb_notify(br->dev, mp, p, RTM_NEWMDB);
  
* Unmerged path net/bridge/br_multicast.c
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 26b3cc8b3453..fdfa7b683d41 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -218,6 +218,7 @@ struct net_bridge_fdb_entry {
 
 #define BR_SGRP_F_DELETE	BIT(0)
 #define BR_SGRP_F_SEND		BIT(1)
+#define BR_SGRP_F_INSTALLED	BIT(2)
 
 struct net_bridge_mcast_gc {
 	struct hlist_node		gc_node;
