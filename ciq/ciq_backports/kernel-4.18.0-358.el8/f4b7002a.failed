net: bridge: add vlan mcast snooping knob

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit f4b7002a7076f025dce59647a77c8251175d2b34
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/f4b7002a.failed

Add a global knob that controls if vlan multicast snooping is enabled.
The proper contexts (vlan or bridge-wide) will be chosen based on the knob
when processing packets and changing bridge device state. Note that
vlans have their individual mcast snooping enabled by default, but this
knob is needed to turn on bridge vlan snooping. It is disabled by
default. To enable the knob vlan filtering must also be enabled, it
doesn't make sense to have vlan mcast snooping without vlan filtering
since that would lead to inconsistencies. Disabling vlan filtering will
also automatically disable vlan mcast snooping.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f4b7002a7076f025dce59647a77c8251175d2b34)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/if_bridge.h
#	net/bridge/br.c
#	net/bridge/br_device.c
#	net/bridge/br_input.c
#	net/bridge/br_multicast.c
#	net/bridge/br_private.h
diff --cc include/uapi/linux/if_bridge.h
index d042dfe91586,7927ad80ee86..000000000000
--- a/include/uapi/linux/if_bridge.h
+++ b/include/uapi/linux/if_bridge.h
@@@ -656,10 -719,15 +656,21 @@@ struct br_mcast_stats 
  };
  
  /* bridge boolean options
++<<<<<<< HEAD
++=======
+  * BR_BOOLOPT_NO_LL_LEARN - disable learning from link-local packets
+  * BR_BOOLOPT_MCAST_VLAN_SNOOPING - control vlan multicast snooping
+  *
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
   * IMPORTANT: if adding a new option do not forget to handle
   *            it in br_boolopt_toggle/get and bridge sysfs
   */
  enum br_boolopt_id {
++<<<<<<< HEAD
++=======
+ 	BR_BOOLOPT_NO_LL_LEARN,
+ 	BR_BOOLOPT_MCAST_VLAN_SNOOPING,
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  	BR_BOOLOPT_MAX
  };
  
diff --cc net/bridge/br.c
index 77c8f6ec5329,51f2e25c4cd6..000000000000
--- a/net/bridge/br.c
+++ b/net/bridge/br.c
@@@ -218,7 -214,15 +218,18 @@@ static struct notifier_block br_switchd
  int br_boolopt_toggle(struct net_bridge *br, enum br_boolopt_id opt, bool on,
  		      struct netlink_ext_ack *extack)
  {
+ 	int err = 0;
+ 
  	switch (opt) {
++<<<<<<< HEAD
++=======
+ 	case BR_BOOLOPT_NO_LL_LEARN:
+ 		br_opt_toggle(br, BROPT_NO_LL_LEARN, on);
+ 		break;
+ 	case BR_BOOLOPT_MCAST_VLAN_SNOOPING:
+ 		err = br_multicast_toggle_vlan_snooping(br, on, extack);
+ 		break;
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  	default:
  		/* shouldn't be called with unsupported options */
  		WARN_ON(1);
@@@ -231,6 -235,10 +242,13 @@@
  int br_boolopt_get(const struct net_bridge *br, enum br_boolopt_id opt)
  {
  	switch (opt) {
++<<<<<<< HEAD
++=======
+ 	case BR_BOOLOPT_NO_LL_LEARN:
+ 		return br_opt_get(br, BROPT_NO_LL_LEARN);
+ 	case BR_BOOLOPT_MCAST_VLAN_SNOOPING:
+ 		return br_opt_get(br, BROPT_MCAST_VLAN_SNOOPING_ENABLED);
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  	default:
  		/* shouldn't be called with unsupported options */
  		WARN_ON(1);
diff --cc net/bridge/br_device.c
index b4100a4583af,00daf35f54d5..000000000000
--- a/net/bridge/br_device.c
+++ b/net/bridge/br_device.c
@@@ -31,7 -27,9 +31,8 @@@ EXPORT_SYMBOL_GPL(nf_br_ops)
  /* net device transmit always called with BH disabled */
  netdev_tx_t br_dev_xmit(struct sk_buff *skb, struct net_device *dev)
  {
+ 	struct net_bridge_mcast_port *pmctx_null = NULL;
  	struct net_bridge *br = netdev_priv(dev);
 -	struct net_bridge_mcast *brmctx = &br->multicast_ctx;
  	struct net_bridge_fdb_entry *dst;
  	struct net_bridge_mdb_entry *mdst;
  	const struct nf_br_ops *nf_ops;
@@@ -85,7 -86,7 +88,11 @@@
  			br_flood(br, skb, BR_PKT_MULTICAST, false, true);
  			goto out;
  		}
++<<<<<<< HEAD
 +		if (br_multicast_rcv(br, NULL, skb, vid)) {
++=======
+ 		if (br_multicast_rcv(&brmctx, &pmctx_null, vlan, skb, vid)) {
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  			kfree_skb(skb);
  			goto out;
  		}
diff --cc net/bridge/br_input.c
index ab915be2b05a,8a0c0cc55cb4..000000000000
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@@ -77,8 -69,11 +77,13 @@@ int br_handle_frame_finish(struct net *
  	struct net_bridge_port *p = br_port_get_rcu(skb->dev);
  	enum br_pkt_type pkt_type = BR_PKT_UNICAST;
  	struct net_bridge_fdb_entry *dst = NULL;
 -	struct net_bridge_mcast_port *pmctx;
  	struct net_bridge_mdb_entry *mdst;
  	bool local_rcv, mcast_hit = false;
++<<<<<<< HEAD
++=======
+ 	struct net_bridge_mcast *brmctx;
+ 	struct net_bridge_vlan *vlan;
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  	struct net_bridge *br;
  	u16 vid = 0;
  	u8 state;
@@@ -86,9 -81,11 +91,9 @@@
  	if (!p || p->state == BR_STATE_DISABLED)
  		goto drop;
  
 -	brmctx = &p->br->multicast_ctx;
 -	pmctx = &p->multicast_ctx;
  	state = p->state;
  	if (!br_allowed_ingress(p->br, nbp_vlan_group_rcu(p), skb, &vid,
- 				&state))
+ 				&state, &vlan))
  		goto out;
  
  	nbp_switchdev_frame_mark(p, skb);
@@@ -106,7 -103,7 +111,11 @@@
  			local_rcv = true;
  		} else {
  			pkt_type = BR_PKT_MULTICAST;
++<<<<<<< HEAD
 +			if (br_multicast_rcv(br, p, skb, vid))
++=======
+ 			if (br_multicast_rcv(&brmctx, &pmctx, vlan, skb, vid))
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  				goto drop;
  		}
  	}
diff --cc net/bridge/br_multicast.c
index def6f1840985,b71772828b23..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -1267,30 -1797,39 +1267,42 @@@ void br_multicast_enable_port(struct ne
  {
  	struct net_bridge *br = port->br;
  
++<<<<<<< HEAD
 +	spin_lock(&br->multicast_lock);
 +	__br_multicast_enable_port(port);
 +	spin_unlock(&br->multicast_lock);
++=======
+ 	spin_lock_bh(&br->multicast_lock);
+ 	__br_multicast_enable_port_ctx(&port->multicast_ctx);
+ 	spin_unlock_bh(&br->multicast_lock);
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  }
  
 -static void __br_multicast_disable_port_ctx(struct net_bridge_mcast_port *pmctx)
 +void br_multicast_disable_port(struct net_bridge_port *port)
  {
++<<<<<<< HEAD
 +	struct net_bridge *br = port->br;
  	struct net_bridge_port_group *pg;
  	struct hlist_node *n;
 -	bool del = false;
 -
 -	hlist_for_each_entry_safe(pg, n, &pmctx->port->mglist, mglist)
 -		if (!(pg->flags & MDB_PG_FLAGS_PERMANENT) &&
 -		    (!br_multicast_port_ctx_is_vlan(pmctx) ||
 -		     pg->key.addr.vid == pmctx->vlan->vid))
 -			br_multicast_find_del_pg(pmctx->port->br, pg);
 -
 -	del |= br_ip4_multicast_rport_del(pmctx);
 -	del_timer(&pmctx->ip4_mc_router_timer);
 -	del_timer(&pmctx->ip4_own_query.timer);
 -	del |= br_ip6_multicast_rport_del(pmctx);
 +
 +	spin_lock(&br->multicast_lock);
 +	hlist_for_each_entry_safe(pg, n, &port->mglist, mglist)
 +		if (!(pg->flags & MDB_PG_FLAGS_PERMANENT))
 +			br_multicast_find_del_pg(br, pg);
 +
 +	__del_port_router(port);
 +
 +	del_timer(&port->multicast_router_timer);
 +	del_timer(&port->ip4_own_query.timer);
  #if IS_ENABLED(CONFIG_IPV6)
 -	del_timer(&pmctx->ip6_mc_router_timer);
 -	del_timer(&pmctx->ip6_own_query.timer);
 +	del_timer(&port->ip6_own_query.timer);
  #endif
 -	br_multicast_rport_del_notify(pmctx, del);
 -}
 -
 -void br_multicast_disable_port(struct net_bridge_port *port)
 -{
 +	spin_unlock(&br->multicast_lock);
++=======
+ 	spin_lock_bh(&port->br->multicast_lock);
+ 	__br_multicast_disable_port_ctx(&port->multicast_ctx);
+ 	spin_unlock_bh(&port->br->multicast_lock);
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  }
  
  static int __grp_src_delete_marked(struct net_bridge_port_group *pg)
@@@ -2727,7 -3510,9 +2739,13 @@@ static int br_multicast_ipv6_rcv(struc
  }
  #endif
  
++<<<<<<< HEAD
 +int br_multicast_rcv(struct net_bridge *br, struct net_bridge_port *port,
++=======
+ int br_multicast_rcv(struct net_bridge_mcast **brmctx,
+ 		     struct net_bridge_mcast_port **pmctx,
+ 		     struct net_bridge_vlan *vlan,
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  		     struct sk_buff *skb, u16 vid)
  {
  	int ret = 0;
@@@ -2735,16 -3520,36 +2753,48 @@@
  	BR_INPUT_SKB_CB(skb)->igmp = 0;
  	BR_INPUT_SKB_CB(skb)->mrouters_only = 0;
  
++<<<<<<< HEAD
 +	if (!br_opt_get(br, BROPT_MULTICAST_ENABLED))
++=======
+ 	if (!br_opt_get((*brmctx)->br, BROPT_MULTICAST_ENABLED))
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  		return 0;
  
+ 	if (br_opt_get((*brmctx)->br, BROPT_MCAST_VLAN_SNOOPING_ENABLED) && vlan) {
+ 		const struct net_bridge_vlan *masterv;
+ 
+ 		/* the vlan has the master flag set only when transmitting
+ 		 * through the bridge device
+ 		 */
+ 		if (br_vlan_is_master(vlan)) {
+ 			masterv = vlan;
+ 			*brmctx = &vlan->br_mcast_ctx;
+ 			*pmctx = NULL;
+ 		} else {
+ 			masterv = vlan->brvlan;
+ 			*brmctx = &vlan->brvlan->br_mcast_ctx;
+ 			*pmctx = &vlan->port_mcast_ctx;
+ 		}
+ 
+ 		if (!(masterv->priv_flags & BR_VLFLAG_GLOBAL_MCAST_ENABLED))
+ 			return 0;
+ 	}
+ 
  	switch (skb->protocol) {
  	case htons(ETH_P_IP):
++<<<<<<< HEAD
 +		ret = br_multicast_ipv4_rcv(br, port, skb, vid);
 +		break;
 +#if IS_ENABLED(CONFIG_IPV6)
 +	case htons(ETH_P_IPV6):
 +		ret = br_multicast_ipv6_rcv(br, port, skb, vid);
++=======
+ 		ret = br_multicast_ipv4_rcv(*brmctx, *pmctx, skb, vid);
+ 		break;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	case htons(ETH_P_IPV6):
+ 		ret = br_multicast_ipv6_rcv(*brmctx, *pmctx, skb, vid);
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  		break;
  #endif
  	}
@@@ -2911,23 -3738,173 +2961,179 @@@ static void __br_multicast_open(struct 
  	mod_timer(&query->timer, jiffies);
  }
  
 -static void __br_multicast_open(struct net_bridge_mcast *brmctx)
 -{
 -	__br_multicast_open_query(brmctx->br, &brmctx->ip4_own_query);
 -#if IS_ENABLED(CONFIG_IPV6)
 -	__br_multicast_open_query(brmctx->br, &brmctx->ip6_own_query);
 -#endif
 -}
 -
  void br_multicast_open(struct net_bridge *br)
  {
++<<<<<<< HEAD
 +	__br_multicast_open(br, &br->ip4_own_query);
++=======
+ 	ASSERT_RTNL();
+ 
+ 	if (br_opt_get(br, BROPT_MCAST_VLAN_SNOOPING_ENABLED)) {
+ 		struct net_bridge_vlan_group *vg;
+ 		struct net_bridge_vlan *vlan;
+ 
+ 		vg = br_vlan_group(br);
+ 		if (vg) {
+ 			list_for_each_entry(vlan, &vg->vlan_list, vlist) {
+ 				struct net_bridge_mcast *brmctx;
+ 
+ 				brmctx = &vlan->br_mcast_ctx;
+ 				if (br_vlan_is_brentry(vlan) &&
+ 				    !br_multicast_ctx_vlan_disabled(brmctx))
+ 					__br_multicast_open(&vlan->br_mcast_ctx);
+ 			}
+ 		}
+ 	}
+ 
+ 	__br_multicast_open(&br->multicast_ctx);
+ }
+ 
+ static void __br_multicast_stop(struct net_bridge_mcast *brmctx)
+ {
+ 	del_timer_sync(&brmctx->ip4_mc_router_timer);
+ 	del_timer_sync(&brmctx->ip4_other_query.timer);
+ 	del_timer_sync(&brmctx->ip4_own_query.timer);
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  #if IS_ENABLED(CONFIG_IPV6)
 -	del_timer_sync(&brmctx->ip6_mc_router_timer);
 -	del_timer_sync(&brmctx->ip6_other_query.timer);
 -	del_timer_sync(&brmctx->ip6_own_query.timer);
 +	__br_multicast_open(br, &br->ip6_own_query);
  #endif
  }
  
++<<<<<<< HEAD
 +void br_multicast_stop(struct net_bridge *br)
 +{
 +	del_timer_sync(&br->multicast_router_timer);
 +	del_timer_sync(&br->ip4_other_query.timer);
 +	del_timer_sync(&br->ip4_own_query.timer);
 +#if IS_ENABLED(CONFIG_IPV6)
 +	del_timer_sync(&br->ip6_other_query.timer);
 +	del_timer_sync(&br->ip6_own_query.timer);
 +#endif
++=======
+ void br_multicast_toggle_one_vlan(struct net_bridge_vlan *vlan, bool on)
+ {
+ 	struct net_bridge *br;
+ 
+ 	/* it's okay to check for the flag without the multicast lock because it
+ 	 * can only change under RTNL -> multicast_lock, we need the latter to
+ 	 * sync with timers and packets
+ 	 */
+ 	if (on == !!(vlan->priv_flags & BR_VLFLAG_MCAST_ENABLED))
+ 		return;
+ 
+ 	if (br_vlan_is_master(vlan)) {
+ 		br = vlan->br;
+ 
+ 		if (!br_vlan_is_brentry(vlan) ||
+ 		    (on &&
+ 		     br_multicast_ctx_vlan_global_disabled(&vlan->br_mcast_ctx)))
+ 			return;
+ 
+ 		spin_lock_bh(&br->multicast_lock);
+ 		vlan->priv_flags ^= BR_VLFLAG_MCAST_ENABLED;
+ 		spin_unlock_bh(&br->multicast_lock);
+ 
+ 		if (on)
+ 			__br_multicast_open(&vlan->br_mcast_ctx);
+ 		else
+ 			__br_multicast_stop(&vlan->br_mcast_ctx);
+ 	} else {
+ 		struct net_bridge_mcast *brmctx;
+ 
+ 		brmctx = br_multicast_port_ctx_get_global(&vlan->port_mcast_ctx);
+ 		if (on && br_multicast_ctx_vlan_global_disabled(brmctx))
+ 			return;
+ 
+ 		br = vlan->port->br;
+ 		spin_lock_bh(&br->multicast_lock);
+ 		vlan->priv_flags ^= BR_VLFLAG_MCAST_ENABLED;
+ 		if (on)
+ 			__br_multicast_enable_port_ctx(&vlan->port_mcast_ctx);
+ 		else
+ 			__br_multicast_disable_port_ctx(&vlan->port_mcast_ctx);
+ 		spin_unlock_bh(&br->multicast_lock);
+ 	}
+ }
+ 
+ void br_multicast_toggle_vlan(struct net_bridge_vlan *vlan, bool on)
+ {
+ 	struct net_bridge_port *p;
+ 
+ 	if (WARN_ON_ONCE(!br_vlan_is_master(vlan)))
+ 		return;
+ 
+ 	list_for_each_entry(p, &vlan->br->port_list, list) {
+ 		struct net_bridge_vlan *vport;
+ 
+ 		vport = br_vlan_find(nbp_vlan_group(p), vlan->vid);
+ 		if (!vport)
+ 			continue;
+ 		br_multicast_toggle_one_vlan(vport, on);
+ 	}
+ }
+ 
+ int br_multicast_toggle_vlan_snooping(struct net_bridge *br, bool on,
+ 				      struct netlink_ext_ack *extack)
+ {
+ 	struct net_bridge_vlan_group *vg;
+ 	struct net_bridge_vlan *vlan;
+ 	struct net_bridge_port *p;
+ 
+ 	if (br_opt_get(br, BROPT_MCAST_VLAN_SNOOPING_ENABLED) == on)
+ 		return 0;
+ 
+ 	if (on && !br_opt_get(br, BROPT_VLAN_ENABLED)) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Cannot enable multicast vlan snooping with vlan filtering disabled");
+ 		return -EINVAL;
+ 	}
+ 
+ 	vg = br_vlan_group(br);
+ 	if (!vg)
+ 		return 0;
+ 
+ 	br_opt_toggle(br, BROPT_MCAST_VLAN_SNOOPING_ENABLED, on);
+ 
+ 	/* disable/enable non-vlan mcast contexts based on vlan snooping */
+ 	if (on)
+ 		__br_multicast_stop(&br->multicast_ctx);
+ 	else
+ 		__br_multicast_open(&br->multicast_ctx);
+ 	list_for_each_entry(p, &br->port_list, list) {
+ 		if (on)
+ 			br_multicast_disable_port(p);
+ 		else
+ 			br_multicast_enable_port(p);
+ 	}
+ 
+ 	list_for_each_entry(vlan, &vg->vlan_list, vlist)
+ 		br_multicast_toggle_vlan(vlan, on);
+ 
+ 	return 0;
+ }
+ 
+ void br_multicast_stop(struct net_bridge *br)
+ {
+ 	ASSERT_RTNL();
+ 
+ 	if (br_opt_get(br, BROPT_MCAST_VLAN_SNOOPING_ENABLED)) {
+ 		struct net_bridge_vlan_group *vg;
+ 		struct net_bridge_vlan *vlan;
+ 
+ 		vg = br_vlan_group(br);
+ 		if (vg) {
+ 			list_for_each_entry(vlan, &vg->vlan_list, vlist) {
+ 				struct net_bridge_mcast *brmctx;
+ 
+ 				brmctx = &vlan->br_mcast_ctx;
+ 				if (br_vlan_is_brentry(vlan) &&
+ 				    !br_multicast_ctx_vlan_disabled(brmctx))
+ 					__br_multicast_stop(&vlan->br_mcast_ctx);
+ 			}
+ 		}
+ 	}
+ 
+ 	__br_multicast_stop(&br->multicast_ctx);
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  }
  
  void br_multicast_dev_del(struct net_bridge *br)
diff --cc net/bridge/br_private.h
index e7ccf58bc2f4,c3c2f19d3b71..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -361,7 -431,9 +361,8 @@@ enum net_bridge_opts 
  	BROPT_NEIGH_SUPPRESS_ENABLED,
  	BROPT_MTU_SET_BY_USER,
  	BROPT_VLAN_STATS_PER_PORT,
 -	BROPT_NO_LL_LEARN,
  	BROPT_VLAN_BRIDGE_BINDING,
+ 	BROPT_MCAST_VLAN_SNOOPING_ENABLED,
  };
  
  struct net_bridge {
@@@ -700,9 -830,11 +701,15 @@@ int br_ioctl_deviceless_stub(struct ne
  
  /* br_multicast.c */
  #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
++<<<<<<< HEAD
 +int br_multicast_rcv(struct net_bridge *br, struct net_bridge_port *port,
++=======
+ int br_multicast_rcv(struct net_bridge_mcast **brmctx,
+ 		     struct net_bridge_mcast_port **pmctx,
+ 		     struct net_bridge_vlan *vlan,
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  		     struct sk_buff *skb, u16 vid);
 -struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge_mcast *brmctx,
 +struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
  					struct sk_buff *skb, u16 vid);
  int br_multicast_add_port(struct net_bridge_port *port);
  void br_multicast_del_port(struct net_bridge_port *port);
@@@ -754,6 -889,31 +761,34 @@@ void br_mdb_init(void)
  void br_mdb_uninit(void);
  void br_multicast_host_join(struct net_bridge_mdb_entry *mp, bool notify);
  void br_multicast_host_leave(struct net_bridge_mdb_entry *mp, bool notify);
++<<<<<<< HEAD
++=======
+ void br_multicast_star_g_handle_mode(struct net_bridge_port_group *pg,
+ 				     u8 filter_mode);
+ void br_multicast_sg_add_exclude_ports(struct net_bridge_mdb_entry *star_mp,
+ 				       struct net_bridge_port_group *sg);
+ struct net_bridge_group_src *
+ br_multicast_find_group_src(struct net_bridge_port_group *pg, struct br_ip *ip);
+ void br_multicast_del_group_src(struct net_bridge_group_src *src,
+ 				bool fastleave);
+ void br_multicast_ctx_init(struct net_bridge *br,
+ 			   struct net_bridge_vlan *vlan,
+ 			   struct net_bridge_mcast *brmctx);
+ void br_multicast_ctx_deinit(struct net_bridge_mcast *brmctx);
+ void br_multicast_port_ctx_init(struct net_bridge_port *port,
+ 				struct net_bridge_vlan *vlan,
+ 				struct net_bridge_mcast_port *pmctx);
+ void br_multicast_port_ctx_deinit(struct net_bridge_mcast_port *pmctx);
+ void br_multicast_toggle_one_vlan(struct net_bridge_vlan *vlan, bool on);
+ void br_multicast_toggle_vlan(struct net_bridge_vlan *vlan, bool on);
+ int br_multicast_toggle_vlan_snooping(struct net_bridge *br, bool on,
+ 				      struct netlink_ext_ack *extack);
+ 
+ static inline bool br_group_is_l2(const struct br_ip *group)
+ {
+ 	return group->proto == 0;
+ }
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  
  #define mlock_dereference(X, br) \
  	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
@@@ -807,21 -1058,65 +842,74 @@@ static inline int br_multicast_igmp_typ
  	return BR_INPUT_SKB_CB(skb)->igmp;
  }
  
 -static inline unsigned long br_multicast_lmqt(const struct net_bridge_mcast *brmctx)
 +static inline unsigned long br_multicast_lmqt(const struct net_bridge *br)
  {
 -	return brmctx->multicast_last_member_interval *
 -	       brmctx->multicast_last_member_count;
 +	return br->multicast_last_member_interval *
 +	       br->multicast_last_member_count;
  }
  
 -static inline unsigned long br_multicast_gmi(const struct net_bridge_mcast *brmctx)
 +static inline unsigned long br_multicast_gmi(const struct net_bridge *br)
  {
  	/* use the RFC default of 2 for QRV */
++<<<<<<< HEAD
 +	return 2 * br->multicast_query_interval +
 +	       br->multicast_query_response_interval;
 +}
 +#else
 +static inline int br_multicast_rcv(struct net_bridge *br,
 +				   struct net_bridge_port *port,
++=======
+ 	return 2 * brmctx->multicast_query_interval +
+ 	       brmctx->multicast_query_response_interval;
+ }
+ 
+ static inline bool
+ br_multicast_ctx_is_vlan(const struct net_bridge_mcast *brmctx)
+ {
+ 	return !!brmctx->vlan;
+ }
+ 
+ static inline bool
+ br_multicast_port_ctx_is_vlan(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	return !!pmctx->vlan;
+ }
+ 
+ static inline struct net_bridge_mcast *
+ br_multicast_port_ctx_get_global(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	if (!br_multicast_port_ctx_is_vlan(pmctx))
+ 		return &pmctx->port->br->multicast_ctx;
+ 	else
+ 		return &pmctx->vlan->brvlan->br_mcast_ctx;
+ }
+ 
+ static inline bool
+ br_multicast_ctx_vlan_global_disabled(const struct net_bridge_mcast *brmctx)
+ {
+ 	return br_opt_get(brmctx->br, BROPT_MCAST_VLAN_SNOOPING_ENABLED) &&
+ 	       br_multicast_ctx_is_vlan(brmctx) &&
+ 	       !(brmctx->vlan->priv_flags & BR_VLFLAG_GLOBAL_MCAST_ENABLED);
+ }
+ 
+ static inline bool
+ br_multicast_ctx_vlan_disabled(const struct net_bridge_mcast *brmctx)
+ {
+ 	return br_multicast_ctx_is_vlan(brmctx) &&
+ 	       !(brmctx->vlan->priv_flags & BR_VLFLAG_MCAST_ENABLED);
+ }
+ 
+ static inline bool
+ br_multicast_port_ctx_vlan_disabled(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	return br_multicast_port_ctx_is_vlan(pmctx) &&
+ 	       !(pmctx->vlan->priv_flags & BR_VLFLAG_MCAST_ENABLED);
+ }
+ #else
+ static inline int br_multicast_rcv(struct net_bridge_mcast **brmctx,
+ 				   struct net_bridge_mcast_port **pmctx,
+ 				   struct net_bridge_vlan *vlan,
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  				   struct sk_buff *skb,
  				   u16 vid)
  {
@@@ -931,6 -1227,43 +1019,46 @@@ static inline int br_multicast_igmp_typ
  {
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline void br_multicast_ctx_init(struct net_bridge *br,
+ 					 struct net_bridge_vlan *vlan,
+ 					 struct net_bridge_mcast *brmctx)
+ {
+ }
+ 
+ static inline void br_multicast_ctx_deinit(struct net_bridge_mcast *brmctx)
+ {
+ }
+ 
+ static inline void br_multicast_port_ctx_init(struct net_bridge_port *port,
+ 					      struct net_bridge_vlan *vlan,
+ 					      struct net_bridge_mcast_port *pmctx)
+ {
+ }
+ 
+ static inline void br_multicast_port_ctx_deinit(struct net_bridge_mcast_port *pmctx)
+ {
+ }
+ 
+ static inline void br_multicast_toggle_one_vlan(struct net_bridge_vlan *vlan,
+ 						bool on)
+ {
+ }
+ 
+ static inline void br_multicast_toggle_vlan(struct net_bridge_vlan *vlan,
+ 					    bool on)
+ {
+ }
+ 
+ static inline int br_multicast_toggle_vlan_snooping(struct net_bridge *br,
+ 						    bool on,
+ 						    struct netlink_ext_ack *extack)
+ {
+ 	return -EOPNOTSUPP;
+ }
++>>>>>>> f4b7002a7076 (net: bridge: add vlan mcast snooping knob)
  #endif
  
  /* br_vlan.c */
* Unmerged path include/uapi/linux/if_bridge.h
* Unmerged path net/bridge/br.c
* Unmerged path net/bridge/br_device.c
* Unmerged path net/bridge/br_input.c
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_private.h
diff --git a/net/bridge/br_vlan.c b/net/bridge/br_vlan.c
index ec7de6e6d9e9..3468b36eb724 100644
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@ -451,7 +451,8 @@ struct sk_buff *br_handle_vlan(struct net_bridge *br,
 static bool __allowed_ingress(const struct net_bridge *br,
 			      struct net_bridge_vlan_group *vg,
 			      struct sk_buff *skb, u16 *vid,
-			      u8 *state)
+			      u8 *state,
+			      struct net_bridge_vlan **vlan)
 {
 	struct pcpu_sw_netstats *stats;
 	struct net_bridge_vlan *v;
@@ -516,8 +517,9 @@ static bool __allowed_ingress(const struct net_bridge *br,
 			 */
 			skb->vlan_tci |= pvid;
 
-		/* if stats are disabled we can avoid the lookup */
-		if (!br_opt_get(br, BROPT_VLAN_STATS_ENABLED)) {
+		/* if snooping and stats are disabled we can avoid the lookup */
+		if (!br_opt_get(br, BROPT_MCAST_VLAN_SNOOPING_ENABLED) &&
+		    !br_opt_get(br, BROPT_VLAN_STATS_ENABLED)) {
 			if (*state == BR_STATE_FORWARDING) {
 				*state = br_vlan_get_pvid_state(vg);
 				return br_vlan_state_allowed(*state, true);
@@ -544,6 +546,8 @@ static bool __allowed_ingress(const struct net_bridge *br,
 		u64_stats_update_end(&stats->syncp);
 	}
 
+	*vlan = v;
+
 	return true;
 
 drop:
@@ -553,17 +557,19 @@ static bool __allowed_ingress(const struct net_bridge *br,
 
 bool br_allowed_ingress(const struct net_bridge *br,
 			struct net_bridge_vlan_group *vg, struct sk_buff *skb,
-			u16 *vid, u8 *state)
+			u16 *vid, u8 *state,
+			struct net_bridge_vlan **vlan)
 {
 	/* If VLAN filtering is disabled on the bridge, all packets are
 	 * permitted.
 	 */
+	*vlan = NULL;
 	if (!br_opt_get(br, BROPT_VLAN_ENABLED)) {
 		BR_INPUT_SKB_CB(skb)->vlan_filtered = false;
 		return true;
 	}
 
-	return __allowed_ingress(br, vg, skb, vid, state);
+	return __allowed_ingress(br, vg, skb, vid, state, vlan);
 }
 
 /* Called under RCU. */
@@ -803,6 +809,10 @@ int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val)
 	br_manage_promisc(br);
 	recalculate_group_addr(br);
 	br_recalculate_fwd_mask(br);
+	if (!val && br_opt_get(br, BROPT_MCAST_VLAN_SNOOPING_ENABLED)) {
+		br_info(br, "vlan filtering disabled, automatically disabling multicast vlan snooping\n");
+		br_multicast_toggle_vlan_snooping(br, false, NULL);
+	}
 
 	return 0;
 }
