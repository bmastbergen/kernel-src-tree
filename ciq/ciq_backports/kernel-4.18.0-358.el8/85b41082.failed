net: bridge: mcast: dump ipv6 querier state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 85b4108211742c5dd4f9f56c1d0704b4e0d4c98e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/85b41082.failed

Add support for dumping global IPv6 querier state, we dump the state
only if our own querier is enabled or there has been another external
querier which has won the election. For the bridge global state we use
a new attribute IFLA_BR_MCAST_QUERIER_STATE and embed the state inside.
The structure is:
  [IFLA_BR_MCAST_QUERIER_STATE]
   `[BRIDGE_QUERIER_IPV6_ADDRESS] - ip address of the querier
   `[BRIDGE_QUERIER_IPV6_PORT]    - bridge port ifindex where the querier
                                    was seen (set only if external querier)
   `[BRIDGE_QUERIER_IPV6_OTHER_TIMER]   -  other querier timeout

IPv4 and IPv6 attributes are embedded at the same level of
IFLA_BR_MCAST_QUERIER_STATE. If we didn't dump anything we cancel the nest
and return.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 85b4108211742c5dd4f9f56c1d0704b4e0d4c98e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/if_bridge.h
#	net/bridge/br_multicast.c
diff --cc include/uapi/linux/if_bridge.h
index d643fa57361d,eceaad200bf6..000000000000
--- a/include/uapi/linux/if_bridge.h
+++ b/include/uapi/linux/if_bridge.h
@@@ -686,4 -770,17 +686,20 @@@ struct br_boolopt_multi 
  	__u32 optval;
  	__u32 optmask;
  };
++<<<<<<< HEAD
++=======
+ 
+ enum {
+ 	BRIDGE_QUERIER_UNSPEC,
+ 	BRIDGE_QUERIER_IP_ADDRESS,
+ 	BRIDGE_QUERIER_IP_PORT,
+ 	BRIDGE_QUERIER_IP_OTHER_TIMER,
+ 	BRIDGE_QUERIER_PAD,
+ 	BRIDGE_QUERIER_IPV6_ADDRESS,
+ 	BRIDGE_QUERIER_IPV6_PORT,
+ 	BRIDGE_QUERIER_IPV6_OTHER_TIMER,
+ 	__BRIDGE_QUERIER_MAX
+ };
+ #define BRIDGE_QUERIER_MAX (__BRIDGE_QUERIER_MAX - 1)
++>>>>>>> 85b410821174 (net: bridge: mcast: dump ipv6 querier state)
  #endif /* _UAPI_LINUX_IF_BRIDGE_H */
diff --cc net/bridge/br_multicast.c
index def6f1840985,0e5d6ba03457..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -2095,32 -2905,109 +2095,116 @@@ update
  	return true;
  }
  
 -static struct net_bridge_port *
 -__br_multicast_get_querier_port(struct net_bridge *br,
 -				const struct bridge_mcast_querier *querier)
 +#if IS_ENABLED(CONFIG_IPV6)
 +static bool br_ip6_multicast_select_querier(struct net_bridge *br,
 +					    struct net_bridge_port *port,
 +					    struct in6_addr *saddr)
  {
 -	int port_ifidx = READ_ONCE(querier->port_ifidx);
 -	struct net_bridge_port *p;
 -	struct net_device *dev;
 +	if (!timer_pending(&br->ip6_own_query.timer) &&
 +	    !timer_pending(&br->ip6_other_query.timer))
 +		goto update;
  
 -	if (port_ifidx == 0)
 -		return NULL;
 +	if (ipv6_addr_cmp(saddr, &br->ip6_querier.addr.src.ip6) <= 0)
 +		goto update;
  
 -	dev = dev_get_by_index_rcu(dev_net(br->dev), port_ifidx);
 -	if (!dev)
 -		return NULL;
 -	p = br_port_get_rtnl_rcu(dev);
 -	if (!p || p->br != br)
 -		return NULL;
 +	return false;
 +
++<<<<<<< HEAD
 +update:
 +	br->ip6_querier.addr.src.ip6 = *saddr;
 +
 +	/* update protected by general multicast_lock by caller */
 +	rcu_assign_pointer(br->ip6_querier.port, port);
  
 +	return true;
++=======
+ 	return p;
+ }
+ 
+ size_t br_multicast_querier_state_size(void)
+ {
+ 	return nla_total_size(sizeof(0)) +      /* nest attribute */
+ 	       nla_total_size(sizeof(__be32)) + /* BRIDGE_QUERIER_IP_ADDRESS */
+ 	       nla_total_size(sizeof(int)) +    /* BRIDGE_QUERIER_IP_PORT */
+ 	       nla_total_size_64bit(sizeof(u64)); /* BRIDGE_QUERIER_IP_OTHER_TIMER */
+ }
+ 
+ /* protected by rtnl or rcu */
+ int br_multicast_dump_querier_state(struct sk_buff *skb,
+ 				    const struct net_bridge_mcast *brmctx,
+ 				    int nest_attr)
+ {
+ 	struct bridge_mcast_querier querier = {};
+ 	struct net_bridge_port *p;
+ 	struct nlattr *nest;
+ 
+ 	nest = nla_nest_start(skb, nest_attr);
+ 	if (!nest)
+ 		return -EMSGSIZE;
+ 
+ 	rcu_read_lock();
+ 	if (!brmctx->multicast_querier &&
+ 	    !timer_pending(&brmctx->ip4_other_query.timer))
+ 		goto out_v6;
+ 
+ 	br_multicast_read_querier(&brmctx->ip4_querier, &querier);
+ 	if (nla_put_in_addr(skb, BRIDGE_QUERIER_IP_ADDRESS,
+ 			    querier.addr.src.ip4)) {
+ 		rcu_read_unlock();
+ 		goto out_err;
+ 	}
+ 
+ 	p = __br_multicast_get_querier_port(brmctx->br, &querier);
+ 	if (timer_pending(&brmctx->ip4_other_query.timer) &&
+ 	    (nla_put_u64_64bit(skb, BRIDGE_QUERIER_IP_OTHER_TIMER,
+ 			       br_timer_value(&brmctx->ip4_other_query.timer),
+ 			       BRIDGE_QUERIER_PAD) ||
+ 	     (p && nla_put_u32(skb, BRIDGE_QUERIER_IP_PORT, p->dev->ifindex)))) {
+ 		rcu_read_unlock();
+ 		goto out_err;
+ 	}
+ 
+ out_v6:
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (!brmctx->multicast_querier &&
+ 	    !timer_pending(&brmctx->ip6_other_query.timer))
+ 		goto out;
+ 
+ 	br_multicast_read_querier(&brmctx->ip6_querier, &querier);
+ 	if (nla_put_in6_addr(skb, BRIDGE_QUERIER_IPV6_ADDRESS,
+ 			     &querier.addr.src.ip6)) {
+ 		rcu_read_unlock();
+ 		goto out_err;
+ 	}
+ 
+ 	p = __br_multicast_get_querier_port(brmctx->br, &querier);
+ 	if (timer_pending(&brmctx->ip6_other_query.timer) &&
+ 	    (nla_put_u64_64bit(skb, BRIDGE_QUERIER_IPV6_OTHER_TIMER,
+ 			       br_timer_value(&brmctx->ip6_other_query.timer),
+ 			       BRIDGE_QUERIER_PAD) ||
+ 	     (p && nla_put_u32(skb, BRIDGE_QUERIER_IPV6_PORT,
+ 			       p->dev->ifindex)))) {
+ 		rcu_read_unlock();
+ 		goto out_err;
+ 	}
+ out:
+ #endif
+ 	rcu_read_unlock();
+ 	nla_nest_end(skb, nest);
+ 	if (!nla_len(nest))
+ 		nla_nest_cancel(skb, nest);
+ 
+ 	return 0;
+ 
+ out_err:
+ 	nla_nest_cancel(skb, nest);
+ 	return -EMSGSIZE;
++>>>>>>> 85b410821174 (net: bridge: mcast: dump ipv6 querier state)
  }
 +#endif
  
  static void
 -br_multicast_update_query_timer(struct net_bridge_mcast *brmctx,
 +br_multicast_update_query_timer(struct net_bridge *br,
  				struct bridge_mcast_other_query *query,
  				unsigned long max_delay)
  {
* Unmerged path include/uapi/linux/if_bridge.h
* Unmerged path net/bridge/br_multicast.c
