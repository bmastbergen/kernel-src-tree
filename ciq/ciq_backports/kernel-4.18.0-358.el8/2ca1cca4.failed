RDMA/core: Simplify how the port sysfs is created

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Jason Gunthorpe <jgg@nvidia.com>
commit 2ca1cca4352ed50a363159aa9b8eeb6182446580
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/2ca1cca4.failed

Use the same technique as gid_attrs now uses to manage the port
sysfs. Bundle everything into three allocations and use a single
sysfs_create_groups() to build everything in one shot.

All the memory is always freed in the kobj release function, removing most
of the error unwinding.

The gid_attr technique and the hw_counters are very similar, merge the two
together and combine the sysfs_create_group() call for hw_counters with
the single sysfs group setup.

Link: https://lore.kernel.org/r/b688f3340694c59f7b44b1bde40e25559ef43cf3.1623427137.git.leonro@nvidia.com
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 2ca1cca4352ed50a363159aa9b8eeb6182446580)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/sysfs.c
diff --cc drivers/infiniband/core/sysfs.c
index 1ae9eecb09be,2631c179e004..000000000000
--- a/drivers/infiniband/core/sysfs.c
+++ b/drivers/infiniband/core/sysfs.c
@@@ -85,16 -67,54 +85,67 @@@ struct port_table_attribute 
  	__be16			attr_id;
  };
  
++<<<<<<< HEAD
 +struct hw_stats_attribute {
 +	struct attribute	attr;
 +	ssize_t			(*show)(struct kobject *kobj,
 +					struct attribute *attr, char *buf);
 +	ssize_t			(*store)(struct kobject *kobj,
 +					 struct attribute *attr,
 +					 const char *buf,
 +					 size_t count);
 +	int			index;
 +	u8			port_num;
++=======
+ struct gid_attr_group {
+ 	struct ib_port *port;
+ 	struct kobject kobj;
+ 	struct attribute_group groups[2];
+ 	const struct attribute_group *groups_list[3];
+ 	struct port_table_attribute attrs_list[];
+ };
+ 
+ struct ib_port {
+ 	struct kobject kobj;
+ 	struct ib_device *ibdev;
+ 	struct gid_attr_group *gid_attr_group;
+ 	struct hw_stats_port_data *hw_stats_data;
+ 
+ 	struct attribute_group groups[3];
+ 	const struct attribute_group *groups_list[5];
+ 	u32 port_num;
+ 	struct port_table_attribute attrs_list[];
+ };
+ 
+ struct hw_stats_device_attribute {
+ 	struct device_attribute attr;
+ 	ssize_t (*show)(struct ib_device *ibdev, struct rdma_hw_stats *stats,
+ 			unsigned int index, unsigned int port_num, char *buf);
+ 	ssize_t (*store)(struct ib_device *ibdev, struct rdma_hw_stats *stats,
+ 			 unsigned int index, unsigned int port_num,
+ 			 const char *buf, size_t count);
+ };
+ 
+ struct hw_stats_port_attribute {
+ 	struct port_attribute attr;
+ 	ssize_t (*show)(struct ib_device *ibdev, struct rdma_hw_stats *stats,
+ 			unsigned int index, unsigned int port_num, char *buf);
+ 	ssize_t (*store)(struct ib_device *ibdev, struct rdma_hw_stats *stats,
+ 			 unsigned int index, unsigned int port_num,
+ 			 const char *buf, size_t count);
+ };
+ 
+ struct hw_stats_device_data {
+ 	struct attribute_group group;
+ 	const struct attribute_group *groups[2];
+ 	struct rdma_hw_stats *stats;
+ 	struct hw_stats_device_attribute attrs[];
+ };
+ 
+ struct hw_stats_port_data {
+ 	struct rdma_hw_stats *stats;
+ 	struct hw_stats_port_attribute attrs[];
++>>>>>>> 2ca1cca4352e (RDMA/core: Simplify how the port sysfs is created)
  };
  
  static ssize_t port_attr_show(struct kobject *kobj,
@@@ -985,254 -903,395 +978,467 @@@ static void setup_hw_stats(struct ib_de
  	 * Two extra attribue elements here, one for the lifespan entry and
  	 * one to NULL terminate the list for the sysfs core code
  	 */
 -	data = kzalloc(struct_size(data, attrs, stats->num_counters + 1),
 +	hsag = kzalloc(sizeof(*hsag) +
 +		       sizeof(void *) * (stats->num_counters + 2),
  		       GFP_KERNEL);
 -	if (!data)
 +	if (!hsag)
  		goto err_free_stats;
 -	data->group.attrs = kcalloc(stats->num_counters + 2,
 -				    sizeof(*data->group.attrs), GFP_KERNEL);
 -	if (!data->group.attrs)
 -		goto err_free_data;
 +
 +	ret = device->ops.get_hw_stats(device, stats, port_num,
 +				       stats->num_counters);
 +	if (ret != stats->num_counters)
 +		goto err_free_hsag;
 +
 +	stats->timestamp = jiffies;
 +
 +	hsag->name = "hw_counters";
 +	hsag->attrs = (void *)hsag + sizeof(*hsag);
 +
 +	for (i = 0; i < stats->num_counters; i++) {
 +		hsag->attrs[i] = alloc_hsa(i, port_num, stats->names[i]);
 +		if (!hsag->attrs[i])
 +			goto err;
 +		sysfs_attr_init(hsag->attrs[i]);
 +	}
  
  	mutex_init(&stats->lock);
 -	data->group.name = "hw_counters";
 -	data->stats = stats;
 -	data->groups[0] = &data->group;
 -	return data;
 +	/* treat an error here as non-fatal */
 +	hsag->attrs[i] = alloc_hsa_lifespan("lifespan", port_num);
 +	if (hsag->attrs[i])
 +		sysfs_attr_init(hsag->attrs[i]);
 +
 +	if (port) {
 +		struct kobject *kobj = &port->kobj;
 +		ret = sysfs_create_group(kobj, hsag);
 +		if (ret)
 +			goto err;
 +		port->hw_stats_ag = hsag;
 +		port->hw_stats = stats;
 +	} else {
 +		struct kobject *kobj = &device->dev.kobj;
 +		ret = sysfs_create_group(kobj, hsag);
 +		if (ret)
 +			goto err;
 +		device->hw_stats_ag = hsag;
 +		device->hw_stats = stats;
 +	}
  
 -err_free_data:
 -	kfree(data);
 +	return;
 +
 +err:
 +	for (; i >= 0; i--)
 +		kfree(hsag->attrs[i]);
 +err_free_hsag:
 +	kfree(hsag);
  err_free_stats:
  	kfree(stats);
++<<<<<<< HEAD
++=======
+ 	return ERR_PTR(-ENOMEM);
+ }
+ 
+ static void free_hw_stats_device(struct hw_stats_device_data *data)
+ {
+ 	kfree(data->group.attrs);
+ 	kfree(data->stats);
+ 	kfree(data);
+ }
+ 
+ static int setup_hw_device_stats(struct ib_device *ibdev)
+ {
+ 	struct hw_stats_device_attribute *attr;
+ 	struct hw_stats_device_data *data;
+ 	int i, ret;
+ 
+ 	data = alloc_hw_stats_device(ibdev);
+ 	if (IS_ERR(data))
+ 		return PTR_ERR(data);
+ 
+ 	ret = ibdev->ops.get_hw_stats(ibdev, data->stats, 0,
+ 				      data->stats->num_counters);
+ 	if (ret != data->stats->num_counters) {
+ 		if (WARN_ON(ret >= 0))
+ 			ret = -EINVAL;
+ 		goto err_free;
+ 	}
+ 
+ 	data->stats->timestamp = jiffies;
+ 
+ 	for (i = 0; i < data->stats->num_counters; i++) {
+ 		attr = &data->attrs[i];
+ 		sysfs_attr_init(&attr->attr.attr);
+ 		attr->attr.attr.name = data->stats->names[i];
+ 		attr->attr.attr.mode = 0444;
+ 		attr->attr.show = hw_stat_device_show;
+ 		attr->show = show_hw_stats;
+ 		data->group.attrs[i] = &attr->attr.attr;
+ 	}
+ 
+ 	attr = &data->attrs[i];
+ 	sysfs_attr_init(&attr->attr.attr);
+ 	attr->attr.attr.name = "lifespan";
+ 	attr->attr.attr.mode = 0644;
+ 	attr->attr.show = hw_stat_device_show;
+ 	attr->show = show_stats_lifespan;
+ 	attr->attr.store = hw_stat_device_store;
+ 	attr->store = set_stats_lifespan;
+ 	data->group.attrs[i] = &attr->attr.attr;
+ 
+ 	ibdev->hw_stats_data = data;
+ 	ret = device_add_groups(&ibdev->dev, data->groups);
+ 	if (ret)
+ 		goto err_free;
+ 	return 0;
+ 
+ err_free:
+ 	free_hw_stats_device(data);
+ 	ibdev->hw_stats_data = NULL;
+ 	return ret;
+ }
+ 
+ static void destroy_hw_device_stats(struct ib_device *ibdev)
+ {
+ 	if (!ibdev->hw_stats_data)
+ 		return;
+ 	device_remove_groups(&ibdev->dev, ibdev->hw_stats_data->groups);
+ 	free_hw_stats_device(ibdev->hw_stats_data);
+ 	ibdev->hw_stats_data = NULL;
+ }
+ 
+ static struct hw_stats_port_data *
+ alloc_hw_stats_port(struct ib_port *port, struct attribute_group *group)
+ {
+ 	struct ib_device *ibdev = port->ibdev;
+ 	struct hw_stats_port_data *data;
+ 	struct rdma_hw_stats *stats;
+ 
+ 	if (!ibdev->ops.alloc_hw_port_stats)
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 	stats = ibdev->ops.alloc_hw_port_stats(port->ibdev, port->port_num);
+ 	if (!stats)
+ 		return ERR_PTR(-ENOMEM);
+ 	if (!stats->names || stats->num_counters <= 0)
+ 		goto err_free_stats;
+ 
+ 	/*
+ 	 * Two extra attribue elements here, one for the lifespan entry and
+ 	 * one to NULL terminate the list for the sysfs core code
+ 	 */
+ 	data = kzalloc(struct_size(data, attrs, stats->num_counters + 1),
+ 		       GFP_KERNEL);
+ 	if (!data)
+ 		goto err_free_stats;
+ 	group->attrs = kcalloc(stats->num_counters + 2,
+ 				    sizeof(*group->attrs), GFP_KERNEL);
+ 	if (!group->attrs)
+ 		goto err_free_data;
+ 
+ 	mutex_init(&stats->lock);
+ 	group->name = "hw_counters";
+ 	data->stats = stats;
+ 	return data;
+ 
+ err_free_data:
+ 	kfree(data);
+ err_free_stats:
+ 	kfree(stats);
+ 	return ERR_PTR(-ENOMEM);
+ }
+ 
+ static int setup_hw_port_stats(struct ib_port *port,
+ 			       struct attribute_group *group)
+ {
+ 	struct hw_stats_port_attribute *attr;
+ 	struct hw_stats_port_data *data;
+ 	int i, ret;
+ 
+ 	data = alloc_hw_stats_port(port, group);
+ 	if (IS_ERR(data))
+ 		return PTR_ERR(data);
+ 
+ 	ret = port->ibdev->ops.get_hw_stats(port->ibdev, data->stats,
+ 					    port->port_num,
+ 					    data->stats->num_counters);
+ 	if (ret != data->stats->num_counters) {
+ 		if (WARN_ON(ret >= 0))
+ 			return -EINVAL;
+ 		return ret;
+ 	}
+ 
+ 	data->stats->timestamp = jiffies;
+ 
+ 	for (i = 0; i < data->stats->num_counters; i++) {
+ 		attr = &data->attrs[i];
+ 		sysfs_attr_init(&attr->attr.attr);
+ 		attr->attr.attr.name = data->stats->names[i];
+ 		attr->attr.attr.mode = 0444;
+ 		attr->attr.show = hw_stat_port_show;
+ 		attr->show = show_hw_stats;
+ 		group->attrs[i] = &attr->attr.attr;
+ 	}
+ 
+ 	attr = &data->attrs[i];
+ 	sysfs_attr_init(&attr->attr.attr);
+ 	attr->attr.attr.name = "lifespan";
+ 	attr->attr.attr.mode = 0644;
+ 	attr->attr.show = hw_stat_port_show;
+ 	attr->show = show_stats_lifespan;
+ 	attr->attr.store = hw_stat_port_store;
+ 	attr->store = set_stats_lifespan;
+ 	group->attrs[i] = &attr->attr.attr;
+ 
+ 	port->hw_stats_data = data;
+ 	return 0;
++>>>>>>> 2ca1cca4352e (RDMA/core: Simplify how the port sysfs is created)
  }
  
  struct rdma_hw_stats *ib_get_hw_stats_port(struct ib_device *ibdev,
  					   u32 port_num)
  {
 -	if (!ibdev->port_data || !rdma_is_port_valid(ibdev, port_num) ||
 -	    !ibdev->port_data[port_num].sysfs->hw_stats_data)
 +	if (!ibdev->port_data || !rdma_is_port_valid(ibdev, port_num))
  		return NULL;
 -	return ibdev->port_data[port_num].sysfs->hw_stats_data->stats;
 -}
 -
 -static int alloc_port_table_group(
 -	const char *name, struct attribute_group *group,
 -	struct port_table_attribute *attrs, size_t num,
 -	ssize_t (*show)(struct ib_port *, struct port_attribute *, char *buf))
 -{
 -	struct attribute **attr_list;
 -	int i;
 -
 -	attr_list = kcalloc(num + 1, sizeof(*attr_list), GFP_KERNEL);
 -	if (!attr_list)
 -		return -ENOMEM;
 -
 -	for (i = 0; i < num; i++) {
 -		struct port_table_attribute *element = &attrs[i];
 -
 -		if (snprintf(element->name, sizeof(element->name), "%d", i) >=
 -		    sizeof(element->name))
 -			goto err;
 -
 -		sysfs_attr_init(&element->attr.attr);
 -		element->attr.attr.name = element->name;
 -		element->attr.attr.mode = 0444;
 -		element->attr.show = show;
 -		element->index = i;
 -
 -		attr_list[i] = &element->attr.attr;
 -	}
 -	group->name = name;
 -	group->attrs = attr_list;
 -	return 0;
 -err:
 -	kfree(attr_list);
 -	return -EINVAL;
 -}
 -
 -/*
 - * Create the sysfs:
 - *  ibp0s9/ports/XX/gid_attrs/{ndevs,types}/YYY
 - * YYY is the gid table index in decimal
 - */
 -static int setup_gid_attrs(struct ib_port *port,
 -			   const struct ib_port_attr *attr)
 -{
 -	struct gid_attr_group *gid_attr_group;
 -	int ret;
 -
 -	gid_attr_group = kzalloc(struct_size(gid_attr_group, attrs_list,
 -					     attr->gid_tbl_len * 2),
 -				 GFP_KERNEL);
 -	if (!gid_attr_group)
 -		return -ENOMEM;
 -	gid_attr_group->port = port;
 -	kobject_init(&gid_attr_group->kobj, &gid_attr_type);
 -
 -	ret = alloc_port_table_group("ndevs", &gid_attr_group->groups[0],
 -				     gid_attr_group->attrs_list,
 -				     attr->gid_tbl_len,
 -				     show_port_gid_attr_ndev);
 -	if (ret)
 -		goto err_put;
 -	gid_attr_group->groups_list[0] = &gid_attr_group->groups[0];
 -
 -	ret = alloc_port_table_group(
 -		"types", &gid_attr_group->groups[1],
 -		gid_attr_group->attrs_list + attr->gid_tbl_len,
 -		attr->gid_tbl_len, show_port_gid_attr_gid_type);
 -	if (ret)
 -		goto err_put;
 -	gid_attr_group->groups_list[1] = &gid_attr_group->groups[1];
 -
 -	ret = kobject_add(&gid_attr_group->kobj, &port->kobj, "gid_attrs");
 -	if (ret)
 -		goto err_put;
 -	ret = sysfs_create_groups(&gid_attr_group->kobj,
 -				  gid_attr_group->groups_list);
 -	if (ret)
 -		goto err_del;
 -	port->gid_attr_group = gid_attr_group;
 -	return 0;
 -
 -err_del:
 -	kobject_del(&gid_attr_group->kobj);
 -err_put:
 -	kobject_put(&gid_attr_group->kobj);
 -	return ret;
 -}
 -
 -static void destroy_gid_attrs(struct ib_port *port)
 -{
 -	struct gid_attr_group *gid_attr_group = port->gid_attr_group;
 -
 -	if (!gid_attr_group)
 -		return;
 -	sysfs_remove_groups(&gid_attr_group->kobj, gid_attr_group->groups_list);
 -	kobject_del(&gid_attr_group->kobj);
 -	kobject_put(&gid_attr_group->kobj);
 +	return ibdev->port_data[port_num].sysfs->hw_stats;
  }
  
- static int add_port(struct ib_core_device *coredev, int port_num)
+ /*
+  * Create the sysfs:
+  *  ibp0s9/ports/XX/{gids,pkeys,counters}/YYY
+  */
+ static struct ib_port *setup_port(struct ib_core_device *coredev, int port_num,
+ 				  const struct ib_port_attr *attr)
  {
  	struct ib_device *device = rdma_device_to_ibdev(&coredev->dev);
  	bool is_full_dev = &device->coredev == coredev;
+ 	const struct attribute_group **cur_group;
  	struct ib_port *p;
- 	struct ib_port_attr attr;
- 	int i;
  	int ret;
  
- 	ret = ib_query_port(device, port_num, &attr);
- 	if (ret)
- 		return ret;
- 
- 	p = kzalloc(sizeof *p, GFP_KERNEL);
+ 	p = kzalloc(struct_size(p, attrs_list,
+ 				attr->gid_tbl_len + attr->pkey_tbl_len),
+ 		    GFP_KERNEL);
  	if (!p)
- 		return -ENOMEM;
- 
- 	p->ibdev      = device;
- 	p->port_num   = port_num;
- 
- 	ret = kobject_init_and_add(&p->kobj, &port_type,
- 				   coredev->ports_kobj,
- 				   "%d", port_num);
+ 		return ERR_PTR(-ENOMEM);
+ 	p->ibdev = device;
+ 	p->port_num = port_num;
+ 	kobject_init(&p->kobj, &port_type);
+ 
+ 	cur_group = p->groups_list;
+ 	ret = alloc_port_table_group("gids", &p->groups[0], p->attrs_list,
+ 				     attr->gid_tbl_len, show_port_gid);
  	if (ret)
  		goto err_put;
+ 	*cur_group++ = &p->groups[0];
  
++<<<<<<< HEAD
 +	p->gid_attr_group = kzalloc(sizeof(*p->gid_attr_group), GFP_KERNEL);
 +	if (!p->gid_attr_group) {
 +		ret = -ENOMEM;
 +		goto err_put;
 +	}
 +
 +	p->gid_attr_group->port = p;
 +	ret = kobject_init_and_add(&p->gid_attr_group->kobj, &gid_attr_type,
 +				   &p->kobj, "gid_attrs");
 +	if (ret)
 +		goto err_put_gid_attrs;
 +
 +	if (device->ops.process_mad && is_full_dev) {
 +		p->pma_table = get_counter_table(device, port_num);
 +		ret = sysfs_create_group(&p->kobj, p->pma_table);
 +		if (ret)
 +			goto err_put_gid_attrs;
 +	}
 +
 +	p->gid_group.name  = "gids";
 +	p->gid_group.attrs = alloc_group_attrs(show_port_gid, attr.gid_tbl_len);
 +	if (!p->gid_group.attrs) {
 +		ret = -ENOMEM;
 +		goto err_remove_pma;
 +	}
 +
 +	ret = sysfs_create_group(&p->kobj, &p->gid_group);
 +	if (ret)
 +		goto err_free_gid;
 +
 +	p->gid_attr_group->ndev.name = "ndevs";
 +	p->gid_attr_group->ndev.attrs = alloc_group_attrs(show_port_gid_attr_ndev,
 +							  attr.gid_tbl_len);
 +	if (!p->gid_attr_group->ndev.attrs) {
 +		ret = -ENOMEM;
 +		goto err_remove_gid;
 +	}
 +
 +	ret = sysfs_create_group(&p->gid_attr_group->kobj,
 +				 &p->gid_attr_group->ndev);
 +	if (ret)
 +		goto err_free_gid_ndev;
 +
 +	p->gid_attr_group->type.name = "types";
 +	p->gid_attr_group->type.attrs = alloc_group_attrs(show_port_gid_attr_gid_type,
 +							  attr.gid_tbl_len);
 +	if (!p->gid_attr_group->type.attrs) {
 +		ret = -ENOMEM;
 +		goto err_remove_gid_ndev;
 +	}
 +
 +	ret = sysfs_create_group(&p->gid_attr_group->kobj,
 +				 &p->gid_attr_group->type);
 +	if (ret)
 +		goto err_free_gid_type;
 +
 +	if (attr.pkey_tbl_len) {
 +		p->pkey_group = kzalloc(sizeof(*p->pkey_group), GFP_KERNEL);
 +		if (!p->pkey_group) {
 +			ret = -ENOMEM;
 +			goto err_remove_gid_type;
 +		}
 +
 +		p->pkey_group->name  = "pkeys";
 +		p->pkey_group->attrs = alloc_group_attrs(show_port_pkey,
 +							 attr.pkey_tbl_len);
 +		if (!p->pkey_group->attrs) {
 +			ret = -ENOMEM;
 +			goto err_free_pkey_group;
 +		}
 +
 +		ret = sysfs_create_group(&p->kobj, p->pkey_group);
 +		if (ret)
 +			goto err_free_pkey;
 +	}
 +
 +
 +	if (device->ops.init_port && is_full_dev) {
 +		ret = device->ops.init_port(device, port_num, &p->kobj);
 +		if (ret)
 +			goto err_remove_pkey;
 +	}
++=======
+ 	if (attr->pkey_tbl_len) {
+ 		ret = alloc_port_table_group("pkeys", &p->groups[1],
+ 					     p->attrs_list + attr->gid_tbl_len,
+ 					     attr->pkey_tbl_len, show_port_pkey);
+ 		if (ret)
+ 			goto err_put;
+ 		*cur_group++ = &p->groups[1];
+ 	}
+ 
+ 	/*
+ 	 * If port == 0, it means hw_counters are per device and not per
+ 	 * port, so holder should be device. Therefore skip per port
+ 	 * counter initialization.
+ 	 */
+ 	if (port_num && is_full_dev) {
+ 		ret = setup_hw_port_stats(p, &p->groups[2]);
+ 		if (ret && ret != -EOPNOTSUPP)
+ 			goto err_put;
+ 		if (!ret)
+ 			*cur_group++ = &p->groups[2];
+ 	}
+ 
+ 	if (device->ops.process_mad && is_full_dev)
+ 		*cur_group++ = get_counter_table(device, port_num);
+ 
+ 	ret = kobject_add(&p->kobj, coredev->ports_kobj, "%d", port_num);
+ 	if (ret)
+ 		goto err_put;
+ 	ret = sysfs_create_groups(&p->kobj, p->groups_list);
+ 	if (ret)
+ 		goto err_del;
++>>>>>>> 2ca1cca4352e (RDMA/core: Simplify how the port sysfs is created)
 +
 +	/*
 +	 * If port == 0, it means hw_counters are per device and not per
 +	 * port, so holder should be device. Therefore skip per port conunter
 +	 * initialization.
 +	 */
 +	if (device->ops.alloc_hw_stats && port_num && is_full_dev)
 +		setup_hw_stats(device, p, port_num);
  
  	list_add_tail(&p->kobj.entry, &coredev->port_list);
  	if (device->port_data && is_full_dev)
  		device->port_data[port_num].sysfs = p;
  
++<<<<<<< HEAD
 +	kobject_uevent(&p->kobj, KOBJ_ADD);
 +	return 0;
 +
 +err_remove_pkey:
 +	if (p->pkey_group)
 +		sysfs_remove_group(&p->kobj, p->pkey_group);
 +
 +err_free_pkey:
 +	if (p->pkey_group) {
 +		for (i = 0; i < attr.pkey_tbl_len; ++i)
 +			kfree(p->pkey_group->attrs[i]);
 +
 +		kfree(p->pkey_group->attrs);
 +		p->pkey_group->attrs = NULL;
 +	}
 +
 +err_free_pkey_group:
 +	kfree(p->pkey_group);
 +
 +err_remove_gid_type:
 +	sysfs_remove_group(&p->gid_attr_group->kobj,
 +			   &p->gid_attr_group->type);
 +
 +err_free_gid_type:
 +	for (i = 0; i < attr.gid_tbl_len; ++i)
 +		kfree(p->gid_attr_group->type.attrs[i]);
 +
 +	kfree(p->gid_attr_group->type.attrs);
 +	p->gid_attr_group->type.attrs = NULL;
 +
 +err_remove_gid_ndev:
 +	sysfs_remove_group(&p->gid_attr_group->kobj,
 +			   &p->gid_attr_group->ndev);
 +
 +err_free_gid_ndev:
 +	for (i = 0; i < attr.gid_tbl_len; ++i)
 +		kfree(p->gid_attr_group->ndev.attrs[i]);
 +
 +	kfree(p->gid_attr_group->ndev.attrs);
 +	p->gid_attr_group->ndev.attrs = NULL;
 +
 +err_remove_gid:
 +	sysfs_remove_group(&p->kobj, &p->gid_group);
 +
 +err_free_gid:
 +	for (i = 0; i < attr.gid_tbl_len; ++i)
 +		kfree(p->gid_group.attrs[i]);
 +
 +	kfree(p->gid_group.attrs);
 +	p->gid_group.attrs = NULL;
 +
 +err_remove_pma:
 +	if (p->pma_table)
 +		sysfs_remove_group(&p->kobj, p->pma_table);
 +
 +err_put_gid_attrs:
 +	kobject_put(&p->gid_attr_group->kobj);
 +
++=======
+ 	return p;
+ 
+ err_del:
+ 	kobject_del(&p->kobj);
++>>>>>>> 2ca1cca4352e (RDMA/core: Simplify how the port sysfs is created)
  err_put:
  	kobject_put(&p->kobj);
- 	return ret;
+ 	return ERR_PTR(ret);
+ }
+ 
+ static void destroy_port(struct ib_port *port)
+ {
+ 	if (port->ibdev->port_data &&
+ 	    port->ibdev->port_data[port->port_num].sysfs == port)
+ 		port->ibdev->port_data[port->port_num].sysfs = NULL;
+ 	list_del(&port->kobj.entry);
+ 	sysfs_remove_groups(&port->kobj, port->groups_list);
+ 	kobject_del(&port->kobj);
+ 	kobject_put(&port->kobj);
  }
  
 -static const char *node_type_string(int node_type)
 -{
 -	switch (node_type) {
 -	case RDMA_NODE_IB_CA:
 -		return "CA";
 -	case RDMA_NODE_IB_SWITCH:
 -		return "switch";
 -	case RDMA_NODE_IB_ROUTER:
 -		return "router";
 -	case RDMA_NODE_RNIC:
 -		return "RNIC";
 -	case RDMA_NODE_USNIC:
 -		return "usNIC";
 -	case RDMA_NODE_USNIC_UDP:
 -		return "usNIC UDP";
 -	case RDMA_NODE_UNSPECIFIED:
 -		return "unspecified";
 -	}
 -	return "<unknown>";
 -}
 -
  static ssize_t node_type_show(struct device *device,
  			      struct device_attribute *attr, char *buf)
  {
@@@ -1338,24 -1390,8 +1542,29 @@@ void ib_free_port_attrs(struct ib_core_
  	list_for_each_entry_safe(p, t, &coredev->port_list, entry) {
  		struct ib_port *port = container_of(p, struct ib_port, kobj);
  
++<<<<<<< HEAD
 +		list_del(&p->entry);
 +		if (port->hw_stats_ag)
 +			free_hsag(&port->kobj, port->hw_stats_ag);
 +		kfree(port->hw_stats);
 +		if (device->port_data && is_full_dev)
 +			device->port_data[port->port_num].sysfs = NULL;
 +
 +		if (port->pma_table)
 +			sysfs_remove_group(p, port->pma_table);
 +		if (port->pkey_group)
 +			sysfs_remove_group(p, port->pkey_group);
 +		sysfs_remove_group(p, &port->gid_group);
 +		sysfs_remove_group(&port->gid_attr_group->kobj,
 +				   &port->gid_attr_group->ndev);
 +		sysfs_remove_group(&port->gid_attr_group->kobj,
 +				   &port->gid_attr_group->type);
 +		kobject_put(&port->gid_attr_group->kobj);
 +		kobject_put(p);
++=======
+ 		destroy_gid_attrs(port);
+ 		destroy_port(port);
++>>>>>>> 2ca1cca4352e (RDMA/core: Simplify how the port sysfs is created)
  	}
  
  	kobject_put(coredev->ports_kobj);
@@@ -1364,7 -1400,8 +1573,12 @@@
  int ib_setup_port_attrs(struct ib_core_device *coredev)
  {
  	struct ib_device *device = rdma_device_to_ibdev(&coredev->dev);
++<<<<<<< HEAD
 +	unsigned int port;
++=======
+ 	bool is_full_dev = &device->coredev == coredev;
+ 	u32 port_num;
++>>>>>>> 2ca1cca4352e (RDMA/core: Simplify how the port sysfs is created)
  	int ret;
  
  	coredev->ports_kobj = kobject_create_and_add("ports",
* Unmerged path drivers/infiniband/core/sysfs.c
