nvme: move the ioctl code to a separate file

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 2405252a680e2151046f4f256d706c3ca92fedef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/2405252a.failed

Split out the ioctl code from core.c into a new file.  Also update
copyrights while we're at it.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Keith Busch <kbusch@kernel.org>
	Reviewed-by: Javier Gonz√°lez <javier.gonz@samsung.com>
	Reviewed-by: Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
(cherry picked from commit 2405252a680e2151046f4f256d706c3ca92fedef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index bf3ac9d14052,b20ffa25f0f0..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -119,11 -109,10 +119,11 @@@ static void nvme_set_queue_dying(struc
  	blk_set_queue_dying(ns->queue);
  	blk_mq_unquiesce_queue(ns->queue);
  
 -	set_capacity_and_notify(ns->disk, 0);
 +	set_capacity(ns->disk, 0);
 +	nvme_update_bdev_size(ns->disk);
  }
  
- static void nvme_queue_scan(struct nvme_ctrl *ctrl)
+ void nvme_queue_scan(struct nvme_ctrl *ctrl)
  {
  	/*
  	 * Only new queue scan work when admin and IO queues are both alive
@@@ -1180,70 -1098,12 +1146,73 @@@ void nvme_execute_passthru_rq(struct re
  	u32 effects;
  
  	effects = nvme_passthru_start(ctrl, ns, cmd->common.opcode);
 -	blk_execute_rq(disk, rq, 0);
 -	if (effects) /* nothing to be done for zero cmd effects */
 -		nvme_passthru_end(ctrl, effects);
 +	blk_execute_rq(rq->q, disk, rq, 0);
 +	nvme_passthru_end(ctrl, effects);
 +}
 +EXPORT_SYMBOL_GPL(nvme_execute_passthru_rq);
 +
++<<<<<<< HEAD
 +static int nvme_submit_user_cmd(struct request_queue *q,
 +		struct nvme_command *cmd, void __user *ubuffer,
 +		unsigned bufflen, void __user *meta_buffer, unsigned meta_len,
 +		u32 meta_seed, u64 *result, unsigned timeout)
 +{
 +	bool write = nvme_is_write(cmd);
 +	struct nvme_ns *ns = q->queuedata;
 +	struct gendisk *disk = ns ? ns->disk : NULL;
 +	struct request *req;
 +	struct bio *bio = NULL;
 +	void *meta = NULL;
 +	int ret;
 +
 +	req = nvme_alloc_request(q, cmd, 0);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
 +
 +	if (timeout)
 +		req->timeout = timeout;
 +	nvme_req(req)->flags |= NVME_REQ_USERCMD;
 +
 +	if (ubuffer && bufflen) {
 +		ret = blk_rq_map_user(q, req, NULL, ubuffer, bufflen,
 +				GFP_KERNEL);
 +		if (ret)
 +			goto out;
 +		bio = req->bio;
 +		bio->bi_disk = disk;
 +		if (disk && meta_buffer && meta_len) {
 +			meta = nvme_add_user_metadata(bio, meta_buffer, meta_len,
 +					meta_seed, write);
 +			if (IS_ERR(meta)) {
 +				ret = PTR_ERR(meta);
 +				goto out_unmap;
 +			}
 +			req->cmd_flags |= REQ_INTEGRITY;
 +		}
 +	}
 +
 +	nvme_execute_passthru_rq(req);
 +	if (nvme_req(req)->flags & NVME_REQ_CANCELLED)
 +		ret = -EINTR;
 +	else
 +		ret = nvme_req(req)->status;
 +	if (result)
 +		*result = le64_to_cpu(nvme_req(req)->result.u64);
 +	if (meta && !ret && !write) {
 +		if (copy_to_user(meta_buffer, meta, meta_len))
 +			ret = -EFAULT;
 +	}
 +	kfree(meta);
 + out_unmap:
 +	if (bio)
 +		blk_rq_unmap_user(bio);
 + out:
 +	blk_mq_free_request(req);
 +	return ret;
  }
 -EXPORT_SYMBOL_NS_GPL(nvme_execute_passthru_rq, NVME_TARGET_PASSTHRU);
  
++=======
++>>>>>>> 2405252a680e (nvme: move the ioctl code to a separate file)
  static void nvme_keep_alive_end_io(struct request *rq, blk_status_t status)
  {
  	struct nvme_ctrl *ctrl = rq->end_io_data;
@@@ -1794,127 -1478,6 +1587,130 @@@ void nvme_put_ns_from_disk(struct nvme_
  		srcu_read_unlock(&head->srcu, idx);
  }
  
++<<<<<<< HEAD
 +static bool is_ctrl_ioctl(unsigned int cmd)
 +{
 +	if (cmd == NVME_IOCTL_ADMIN_CMD || cmd == NVME_IOCTL_ADMIN64_CMD)
 +		return true;
 +	if (is_sed_ioctl(cmd))
 +		return true;
 +	return false;
 +}
 +
 +static int nvme_handle_ctrl_ioctl(struct nvme_ns *ns, unsigned int cmd,
 +				  void __user *argp,
 +				  struct nvme_ns_head *head,
 +				  int srcu_idx)
 +{
 +	struct nvme_ctrl *ctrl = ns->ctrl;
 +	int ret;
 +
 +	nvme_get_ctrl(ns->ctrl);
 +	nvme_put_ns_from_disk(head, srcu_idx);
 +
 +	switch (cmd) {
 +	case NVME_IOCTL_ADMIN_CMD:
 +		ret = nvme_user_cmd(ctrl, NULL, argp);
 +		break;
 +	case NVME_IOCTL_ADMIN64_CMD:
 +		ret = nvme_user_cmd64(ctrl, NULL, argp);
 +		break;
 +	default:
 +		ret = sed_ioctl(ctrl->opal_dev, cmd, argp);
 +		break;
 +	}
 +	nvme_put_ctrl(ctrl);
 +	return ret;
 +}
 +
 +static int nvme_ioctl(struct block_device *bdev, fmode_t mode,
 +		unsigned int cmd, unsigned long arg)
 +{
 +	struct nvme_ns_head *head = NULL;
 +	void __user *argp = (void __user *)arg;
 +	struct nvme_ns *ns;
 +	int srcu_idx, ret;
 +
 +	ns = nvme_get_ns_from_disk(bdev->bd_disk, &head, &srcu_idx);
 +	if (unlikely(!ns))
 +		return -EWOULDBLOCK;
 +
 +	/*
 +	 * Handle ioctls that apply to the controller instead of the namespace
 +	 * seperately and drop the ns SRCU reference early.  This avoids a
 +	 * deadlock when deleting namespaces using the passthrough interface.
 +	 */
 +	if (is_ctrl_ioctl(cmd))
 +		return nvme_handle_ctrl_ioctl(ns, cmd, argp, head, srcu_idx);
 +
 +	switch (cmd) {
 +	case NVME_IOCTL_ID:
 +		force_successful_syscall_return();
 +		ret = ns->head->ns_id;
 +		break;
 +	case NVME_IOCTL_IO_CMD:
 +		ret = nvme_user_cmd(ns->ctrl, ns, argp);
 +		break;
 +	case NVME_IOCTL_SUBMIT_IO:
 +		ret = nvme_submit_io(ns, argp);
 +		break;
 +	case NVME_IOCTL_IO64_CMD:
 +		ret = nvme_user_cmd64(ns->ctrl, ns, argp);
 +		break;
 +	default:
 +		if (ns->ndev)
 +			ret = nvme_nvm_ioctl(ns, cmd, argp);
 +		else
 +			ret = -ENOTTY;
 +	}
 +
 +	nvme_put_ns_from_disk(head, srcu_idx);
 +	return ret;
 +}
 +
 +#ifdef CONFIG_COMPAT
 +struct nvme_user_io32 {
 +	__u8	opcode;
 +	__u8	flags;
 +	__u16	control;
 +	__u16	nblocks;
 +	__u16	rsvd;
 +	__u64	metadata;
 +	__u64	addr;
 +	__u64	slba;
 +	__u32	dsmgmt;
 +	__u32	reftag;
 +	__u16	apptag;
 +	__u16	appmask;
 +} __attribute__((__packed__));
 +
 +#define NVME_IOCTL_SUBMIT_IO32	_IOW('N', 0x42, struct nvme_user_io32)
 +
 +static int nvme_compat_ioctl(struct block_device *bdev, fmode_t mode,
 +		unsigned int cmd, unsigned long arg)
 +{
 +	/*
 +	 * Corresponds to the difference of NVME_IOCTL_SUBMIT_IO
 +	 * between 32 bit programs and 64 bit kernel.
 +	 * The cause is that the results of sizeof(struct nvme_user_io),
 +	 * which is used to define NVME_IOCTL_SUBMIT_IO,
 +	 * are not same between 32 bit compiler and 64 bit compiler.
 +	 * NVME_IOCTL_SUBMIT_IO32 is for 64 bit kernel handling
 +	 * NVME_IOCTL_SUBMIT_IO issued from 32 bit programs.
 +	 * Other IOCTL numbers are same between 32 bit and 64 bit.
 +	 * So there is nothing to do regarding to other IOCTL numbers.
 +	 */
 +	if (cmd == NVME_IOCTL_SUBMIT_IO32)
 +		return nvme_ioctl(bdev, mode, NVME_IOCTL_SUBMIT_IO, arg);
 +
 +	return nvme_ioctl(bdev, mode, cmd, arg);
 +}
 +#else
 +#define nvme_compat_ioctl	NULL
 +#endif /* CONFIG_COMPAT */
 +
++=======
++>>>>>>> 2405252a680e (nvme: move the ioctl code to a separate file)
  static int nvme_open(struct block_device *bdev, fmode_t mode)
  {
  	struct nvme_ns *ns = bdev->bd_disk->private_data;
@@@ -2449,12 -1987,32 +2245,35 @@@ static void nvme_ns_head_release(struc
  	nvme_put_ns_head(disk->private_data);
  }
  
++<<<<<<< HEAD
++=======
+ struct nvme_ctrl *nvme_find_get_live_ctrl(struct nvme_subsystem *subsys)
+ {
+ 	struct nvme_ctrl *ctrl;
+ 	int ret;
+ 
+ 	ret = mutex_lock_killable(&nvme_subsystems_lock);
+ 	if (ret)
+ 		return ERR_PTR(ret);
+ 	list_for_each_entry(ctrl, &subsys->ctrls, subsys_entry) {
+ 		if (ctrl->state == NVME_CTRL_LIVE)
+ 			goto found;
+ 	}
+ 	mutex_unlock(&nvme_subsystems_lock);
+ 	return ERR_PTR(-EWOULDBLOCK);
+ found:
+ 	nvme_get_ctrl(ctrl);
+ 	mutex_unlock(&nvme_subsystems_lock);
+ 	return ctrl;
+ }
+ 
++>>>>>>> 2405252a680e (nvme: move the ioctl code to a separate file)
  const struct block_device_operations nvme_ns_head_ops = {
  	.owner		= THIS_MODULE,
 -	.submit_bio	= nvme_ns_head_submit_bio,
  	.open		= nvme_ns_head_open,
  	.release	= nvme_ns_head_release,
 -	.ioctl		= nvme_ns_head_ioctl,
 +	.ioctl		= nvme_ioctl,
 +	.compat_ioctl	= nvme_compat_ioctl,
  	.getgeo		= nvme_getgeo,
  	.report_zones	= nvme_report_zones,
  	.pr_ops		= &nvme_pr_ops,
diff --git a/drivers/nvme/host/Makefile b/drivers/nvme/host/Makefile
index d7f6a87687b8..cbc509784b2e 100644
--- a/drivers/nvme/host/Makefile
+++ b/drivers/nvme/host/Makefile
@@ -9,7 +9,7 @@ obj-$(CONFIG_NVME_RDMA)			+= nvme-rdma.o
 obj-$(CONFIG_NVME_FC)			+= nvme-fc.o
 obj-$(CONFIG_NVME_TCP)			+= nvme-tcp.o
 
-nvme-core-y				:= core.o
+nvme-core-y				:= core.o ioctl.o
 nvme-core-$(CONFIG_TRACING)		+= trace.o
 nvme-core-$(CONFIG_NVME_MULTIPATH)	+= multipath.o
 nvme-core-$(CONFIG_NVM)			+= lightnvm.o
* Unmerged path drivers/nvme/host/core.c
diff --git a/drivers/nvme/host/ioctl.c b/drivers/nvme/host/ioctl.c
new file mode 100644
index 000000000000..8e05d65c9e93
--- /dev/null
+++ b/drivers/nvme/host/ioctl.c
@@ -0,0 +1,455 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2011-2014, Intel Corporation.
+ * Copyright (c) 2017-2021 Christoph Hellwig.
+ */
+#include <linux/ptrace.h>	/* for force_successful_syscall_return */
+#include <linux/nvme_ioctl.h>
+#include "nvme.h"
+
+/*
+ * Convert integer values from ioctl structures to user pointers, silently
+ * ignoring the upper bits in the compat case to match behaviour of 32-bit
+ * kernels.
+ */
+static void __user *nvme_to_user_ptr(uintptr_t ptrval)
+{
+	if (in_compat_syscall())
+		ptrval = (compat_uptr_t)ptrval;
+	return (void __user *)ptrval;
+}
+
+static void *nvme_add_user_metadata(struct bio *bio, void __user *ubuf,
+		unsigned len, u32 seed, bool write)
+{
+	struct bio_integrity_payload *bip;
+	int ret = -ENOMEM;
+	void *buf;
+
+	buf = kmalloc(len, GFP_KERNEL);
+	if (!buf)
+		goto out;
+
+	ret = -EFAULT;
+	if (write && copy_from_user(buf, ubuf, len))
+		goto out_free_meta;
+
+	bip = bio_integrity_alloc(bio, GFP_KERNEL, 1);
+	if (IS_ERR(bip)) {
+		ret = PTR_ERR(bip);
+		goto out_free_meta;
+	}
+
+	bip->bip_iter.bi_size = len;
+	bip->bip_iter.bi_sector = seed;
+	ret = bio_integrity_add_page(bio, virt_to_page(buf), len,
+			offset_in_page(buf));
+	if (ret == len)
+		return buf;
+	ret = -ENOMEM;
+out_free_meta:
+	kfree(buf);
+out:
+	return ERR_PTR(ret);
+}
+
+static int nvme_submit_user_cmd(struct request_queue *q,
+		struct nvme_command *cmd, void __user *ubuffer,
+		unsigned bufflen, void __user *meta_buffer, unsigned meta_len,
+		u32 meta_seed, u64 *result, unsigned timeout)
+{
+	bool write = nvme_is_write(cmd);
+	struct nvme_ns *ns = q->queuedata;
+	struct block_device *bdev = ns ? ns->disk->part0 : NULL;
+	struct request *req;
+	struct bio *bio = NULL;
+	void *meta = NULL;
+	int ret;
+
+	req = nvme_alloc_request(q, cmd, 0);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	if (timeout)
+		req->timeout = timeout;
+	nvme_req(req)->flags |= NVME_REQ_USERCMD;
+
+	if (ubuffer && bufflen) {
+		ret = blk_rq_map_user(q, req, NULL, ubuffer, bufflen,
+				GFP_KERNEL);
+		if (ret)
+			goto out;
+		bio = req->bio;
+		if (bdev)
+			bio_set_dev(bio, bdev);
+		if (bdev && meta_buffer && meta_len) {
+			meta = nvme_add_user_metadata(bio, meta_buffer, meta_len,
+					meta_seed, write);
+			if (IS_ERR(meta)) {
+				ret = PTR_ERR(meta);
+				goto out_unmap;
+			}
+			req->cmd_flags |= REQ_INTEGRITY;
+		}
+	}
+
+	nvme_execute_passthru_rq(req);
+	if (nvme_req(req)->flags & NVME_REQ_CANCELLED)
+		ret = -EINTR;
+	else
+		ret = nvme_req(req)->status;
+	if (result)
+		*result = le64_to_cpu(nvme_req(req)->result.u64);
+	if (meta && !ret && !write) {
+		if (copy_to_user(meta_buffer, meta, meta_len))
+			ret = -EFAULT;
+	}
+	kfree(meta);
+ out_unmap:
+	if (bio)
+		blk_rq_unmap_user(bio);
+ out:
+	blk_mq_free_request(req);
+	return ret;
+}
+
+
+static int nvme_submit_io(struct nvme_ns *ns, struct nvme_user_io __user *uio)
+{
+	struct nvme_user_io io;
+	struct nvme_command c;
+	unsigned length, meta_len;
+	void __user *metadata;
+
+	if (copy_from_user(&io, uio, sizeof(io)))
+		return -EFAULT;
+	if (io.flags)
+		return -EINVAL;
+
+	switch (io.opcode) {
+	case nvme_cmd_write:
+	case nvme_cmd_read:
+	case nvme_cmd_compare:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	length = (io.nblocks + 1) << ns->lba_shift;
+
+	if ((io.control & NVME_RW_PRINFO_PRACT) &&
+	    ns->ms == sizeof(struct t10_pi_tuple)) {
+		/*
+		 * Protection information is stripped/inserted by the
+		 * controller.
+		 */
+		if (nvme_to_user_ptr(io.metadata))
+			return -EINVAL;
+		meta_len = 0;
+		metadata = NULL;
+	} else {
+		meta_len = (io.nblocks + 1) * ns->ms;
+		metadata = nvme_to_user_ptr(io.metadata);
+	}
+
+	if (ns->features & NVME_NS_EXT_LBAS) {
+		length += meta_len;
+		meta_len = 0;
+	} else if (meta_len) {
+		if ((io.metadata & 3) || !io.metadata)
+			return -EINVAL;
+	}
+
+	memset(&c, 0, sizeof(c));
+	c.rw.opcode = io.opcode;
+	c.rw.flags = io.flags;
+	c.rw.nsid = cpu_to_le32(ns->head->ns_id);
+	c.rw.slba = cpu_to_le64(io.slba);
+	c.rw.length = cpu_to_le16(io.nblocks);
+	c.rw.control = cpu_to_le16(io.control);
+	c.rw.dsmgmt = cpu_to_le32(io.dsmgmt);
+	c.rw.reftag = cpu_to_le32(io.reftag);
+	c.rw.apptag = cpu_to_le16(io.apptag);
+	c.rw.appmask = cpu_to_le16(io.appmask);
+
+	return nvme_submit_user_cmd(ns->queue, &c,
+			nvme_to_user_ptr(io.addr), length,
+			metadata, meta_len, lower_32_bits(io.slba), NULL, 0);
+}
+
+static int nvme_user_cmd(struct nvme_ctrl *ctrl, struct nvme_ns *ns,
+			struct nvme_passthru_cmd __user *ucmd)
+{
+	struct nvme_passthru_cmd cmd;
+	struct nvme_command c;
+	unsigned timeout = 0;
+	u64 result;
+	int status;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+	if (copy_from_user(&cmd, ucmd, sizeof(cmd)))
+		return -EFAULT;
+	if (cmd.flags)
+		return -EINVAL;
+	if (ns && cmd.nsid != ns->head->ns_id) {
+		dev_err(ctrl->device,
+			"%s: nsid (%u) in cmd does not match nsid (%u) of namespace\n",
+			current->comm, cmd.nsid, ns->head->ns_id);
+		return -EINVAL;
+	}
+
+	memset(&c, 0, sizeof(c));
+	c.common.opcode = cmd.opcode;
+	c.common.flags = cmd.flags;
+	c.common.nsid = cpu_to_le32(cmd.nsid);
+	c.common.cdw2[0] = cpu_to_le32(cmd.cdw2);
+	c.common.cdw2[1] = cpu_to_le32(cmd.cdw3);
+	c.common.cdw10 = cpu_to_le32(cmd.cdw10);
+	c.common.cdw11 = cpu_to_le32(cmd.cdw11);
+	c.common.cdw12 = cpu_to_le32(cmd.cdw12);
+	c.common.cdw13 = cpu_to_le32(cmd.cdw13);
+	c.common.cdw14 = cpu_to_le32(cmd.cdw14);
+	c.common.cdw15 = cpu_to_le32(cmd.cdw15);
+
+	if (cmd.timeout_ms)
+		timeout = msecs_to_jiffies(cmd.timeout_ms);
+
+	status = nvme_submit_user_cmd(ns ? ns->queue : ctrl->admin_q, &c,
+			nvme_to_user_ptr(cmd.addr), cmd.data_len,
+			nvme_to_user_ptr(cmd.metadata), cmd.metadata_len,
+			0, &result, timeout);
+
+	if (status >= 0) {
+		if (put_user(result, &ucmd->result))
+			return -EFAULT;
+	}
+
+	return status;
+}
+
+static int nvme_user_cmd64(struct nvme_ctrl *ctrl, struct nvme_ns *ns,
+			struct nvme_passthru_cmd64 __user *ucmd)
+{
+	struct nvme_passthru_cmd64 cmd;
+	struct nvme_command c;
+	unsigned timeout = 0;
+	int status;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+	if (copy_from_user(&cmd, ucmd, sizeof(cmd)))
+		return -EFAULT;
+	if (cmd.flags)
+		return -EINVAL;
+	if (ns && cmd.nsid != ns->head->ns_id) {
+		dev_err(ctrl->device,
+			"%s: nsid (%u) in cmd does not match nsid (%u) of namespace\n",
+			current->comm, cmd.nsid, ns->head->ns_id);
+		return -EINVAL;
+	}
+
+	memset(&c, 0, sizeof(c));
+	c.common.opcode = cmd.opcode;
+	c.common.flags = cmd.flags;
+	c.common.nsid = cpu_to_le32(cmd.nsid);
+	c.common.cdw2[0] = cpu_to_le32(cmd.cdw2);
+	c.common.cdw2[1] = cpu_to_le32(cmd.cdw3);
+	c.common.cdw10 = cpu_to_le32(cmd.cdw10);
+	c.common.cdw11 = cpu_to_le32(cmd.cdw11);
+	c.common.cdw12 = cpu_to_le32(cmd.cdw12);
+	c.common.cdw13 = cpu_to_le32(cmd.cdw13);
+	c.common.cdw14 = cpu_to_le32(cmd.cdw14);
+	c.common.cdw15 = cpu_to_le32(cmd.cdw15);
+
+	if (cmd.timeout_ms)
+		timeout = msecs_to_jiffies(cmd.timeout_ms);
+
+	status = nvme_submit_user_cmd(ns ? ns->queue : ctrl->admin_q, &c,
+			nvme_to_user_ptr(cmd.addr), cmd.data_len,
+			nvme_to_user_ptr(cmd.metadata), cmd.metadata_len,
+			0, &cmd.result, timeout);
+
+	if (status >= 0) {
+		if (put_user(cmd.result, &ucmd->result))
+			return -EFAULT;
+	}
+
+	return status;
+}
+
+static bool is_ctrl_ioctl(unsigned int cmd)
+{
+	if (cmd == NVME_IOCTL_ADMIN_CMD || cmd == NVME_IOCTL_ADMIN64_CMD)
+		return true;
+	if (is_sed_ioctl(cmd))
+		return true;
+	return false;
+}
+
+static int nvme_ctrl_ioctl(struct nvme_ctrl *ctrl, unsigned int cmd,
+		void __user *argp)
+{
+	switch (cmd) {
+	case NVME_IOCTL_ADMIN_CMD:
+		return nvme_user_cmd(ctrl, NULL, argp);
+	case NVME_IOCTL_ADMIN64_CMD:
+		return nvme_user_cmd64(ctrl, NULL, argp);
+	default:
+		return sed_ioctl(ctrl->opal_dev, cmd, argp);
+	}
+}
+
+#ifdef COMPAT_FOR_U64_ALIGNMENT
+struct nvme_user_io32 {
+	__u8	opcode;
+	__u8	flags;
+	__u16	control;
+	__u16	nblocks;
+	__u16	rsvd;
+	__u64	metadata;
+	__u64	addr;
+	__u64	slba;
+	__u32	dsmgmt;
+	__u32	reftag;
+	__u16	apptag;
+	__u16	appmask;
+} __attribute__((__packed__));
+#define NVME_IOCTL_SUBMIT_IO32	_IOW('N', 0x42, struct nvme_user_io32)
+#endif /* COMPAT_FOR_U64_ALIGNMENT */
+
+static int nvme_ns_ioctl(struct nvme_ns *ns, unsigned int cmd,
+		void __user *argp)
+{
+	switch (cmd) {
+	case NVME_IOCTL_ID:
+		force_successful_syscall_return();
+		return ns->head->ns_id;
+	case NVME_IOCTL_IO_CMD:
+		return nvme_user_cmd(ns->ctrl, ns, argp);
+	/*
+	 * struct nvme_user_io can have different padding on some 32-bit ABIs.
+	 * Just accept the compat version as all fields that are used are the
+	 * same size and at the same offset.
+	 */
+#ifdef COMPAT_FOR_U64_ALIGNMENT
+	case NVME_IOCTL_SUBMIT_IO32:
+#endif
+	case NVME_IOCTL_SUBMIT_IO:
+		return nvme_submit_io(ns, argp);
+	case NVME_IOCTL_IO64_CMD:
+		return nvme_user_cmd64(ns->ctrl, ns, argp);
+	default:
+		if (!ns->ndev)
+			return -ENOTTY;
+		return nvme_nvm_ioctl(ns, cmd, argp);
+	}
+}
+
+int nvme_ioctl(struct block_device *bdev, fmode_t mode,
+		unsigned int cmd, unsigned long arg)
+{
+	struct nvme_ns *ns = bdev->bd_disk->private_data;
+	void __user *argp = (void __user *)arg;
+
+	if (is_ctrl_ioctl(cmd))
+		return nvme_ctrl_ioctl(ns->ctrl, cmd, argp);
+	return nvme_ns_ioctl(ns, cmd, argp);
+}
+
+#ifdef CONFIG_NVME_MULTIPATH
+static int nvme_ns_head_ctrl_ioctl(struct nvme_ns_head *head,
+		unsigned int cmd, void __user *argp)
+{
+	struct nvme_ctrl *ctrl = nvme_find_get_live_ctrl(head->subsys);
+	int ret;
+
+	if (IS_ERR(ctrl))
+		return PTR_ERR(ctrl);
+	ret = nvme_ctrl_ioctl(ctrl, cmd, argp);
+	nvme_put_ctrl(ctrl);
+	return ret;
+}
+
+static int nvme_ns_head_ns_ioctl(struct nvme_ns_head *head,
+		unsigned int cmd, void __user *argp)
+{
+	int srcu_idx = srcu_read_lock(&head->srcu);
+	struct nvme_ns *ns = nvme_find_path(head);
+	int ret = -EWOULDBLOCK;
+
+	if (ns)
+		ret = nvme_ns_ioctl(ns, cmd, argp);
+	srcu_read_unlock(&head->srcu, srcu_idx);
+	return ret;
+}
+
+int nvme_ns_head_ioctl(struct block_device *bdev, fmode_t mode,
+		unsigned int cmd, unsigned long arg)
+{
+	struct nvme_ns_head *head = bdev->bd_disk->private_data;
+
+	if (is_ctrl_ioctl(cmd))
+		return nvme_ns_head_ctrl_ioctl(head, cmd, (void __user *)arg);
+	return nvme_ns_head_ns_ioctl(head, cmd, (void __user *)arg);
+}
+#endif /* CONFIG_NVME_MULTIPATH */
+
+static int nvme_dev_user_cmd(struct nvme_ctrl *ctrl, void __user *argp)
+{
+	struct nvme_ns *ns;
+	int ret;
+
+	down_read(&ctrl->namespaces_rwsem);
+	if (list_empty(&ctrl->namespaces)) {
+		ret = -ENOTTY;
+		goto out_unlock;
+	}
+
+	ns = list_first_entry(&ctrl->namespaces, struct nvme_ns, list);
+	if (ns != list_last_entry(&ctrl->namespaces, struct nvme_ns, list)) {
+		dev_warn(ctrl->device,
+			"NVME_IOCTL_IO_CMD not supported when multiple namespaces present!\n");
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+
+	dev_warn(ctrl->device,
+		"using deprecated NVME_IOCTL_IO_CMD ioctl on the char device!\n");
+	kref_get(&ns->kref);
+	up_read(&ctrl->namespaces_rwsem);
+
+	ret = nvme_user_cmd(ctrl, ns, argp);
+	nvme_put_ns(ns);
+	return ret;
+
+out_unlock:
+	up_read(&ctrl->namespaces_rwsem);
+	return ret;
+}
+
+long nvme_dev_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	struct nvme_ctrl *ctrl = file->private_data;
+	void __user *argp = (void __user *)arg;
+
+	switch (cmd) {
+	case NVME_IOCTL_ADMIN_CMD:
+		return nvme_user_cmd(ctrl, NULL, argp);
+	case NVME_IOCTL_ADMIN64_CMD:
+		return nvme_user_cmd64(ctrl, NULL, argp);
+	case NVME_IOCTL_IO_CMD:
+		return nvme_dev_user_cmd(ctrl, argp);
+	case NVME_IOCTL_RESET:
+		dev_warn(ctrl->device, "resetting controller\n");
+		return nvme_reset_ctrl_sync(ctrl);
+	case NVME_IOCTL_SUBSYS_RESET:
+		return nvme_reset_subsystem(ctrl);
+	case NVME_IOCTL_RESCAN:
+		nvme_queue_scan(ctrl);
+		return 0;
+	default:
+		return -ENOTTY;
+	}
+}
diff --git a/drivers/nvme/host/nvme.h b/drivers/nvme/host/nvme.h
index d12eb5696033..a4457832205c 100644
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@ -642,14 +642,22 @@ int nvme_get_features(struct nvme_ctrl *dev, unsigned int fid,
 int nvme_set_queue_count(struct nvme_ctrl *ctrl, int *count);
 void nvme_stop_keep_alive(struct nvme_ctrl *ctrl);
 int nvme_reset_ctrl(struct nvme_ctrl *ctrl);
+int nvme_reset_ctrl_sync(struct nvme_ctrl *ctrl);
 int nvme_try_sched_reset(struct nvme_ctrl *ctrl);
 int nvme_delete_ctrl(struct nvme_ctrl *ctrl);
-
+void nvme_queue_scan(struct nvme_ctrl *ctrl);
 int nvme_get_log(struct nvme_ctrl *ctrl, u32 nsid, u8 log_page, u8 lsp, u8 csi,
 		void *log, size_t size, u64 offset);
 struct nvme_ns *nvme_get_ns_from_disk(struct gendisk *disk,
 		struct nvme_ns_head **head, int *srcu_idx);
 void nvme_put_ns_from_disk(struct nvme_ns_head *head, int idx);
+struct nvme_ctrl *nvme_find_get_live_ctrl(struct nvme_subsystem *subsys);
+int nvme_ioctl(struct block_device *bdev, fmode_t mode,
+		unsigned int cmd, unsigned long arg);
+int nvme_ns_head_ioctl(struct block_device *bdev, fmode_t mode,
+		unsigned int cmd, unsigned long arg);
+long nvme_dev_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg);
 
 extern const struct attribute_group *nvme_ns_id_attr_groups[];
 extern const struct block_device_operations nvme_ns_head_ops;
