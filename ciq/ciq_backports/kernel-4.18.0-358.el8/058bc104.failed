serial: 8250: Generalize rs485 software emulation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Lukas Wunner <lukas@wunner.de>
commit 058bc104f7ca5c83d81695ee96f03dbd93bae518
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/058bc104.failed

Commit e490c9144cfa ("tty: Add software emulated RS485 support for 8250")
introduced support to use RTS as an rs485 Transmit Enable signal.
So far the only drivers taking advantage of it are 8250_omap.c and
8250_of.c.

We're about to make use of the feature in 8250_bcm2835aux.c as well.
The bcm2835aux differs from omap chips by inverting the meaning of RTS
in the MCR register.  Moreover, omap achieves half-duplex mode by
disabling the RX interrupt and clearing the RX FIFO when TX stops.
The bcm2835aux requires disabling the receiver instead.

Support these behavioral differences by generalizing the rs485 emulation:
Introduce ->rs485_start_tx() and ->rs485_stop_tx() callbacks in struct
uart_8250_port, provide generic implementations containing the existing
code and use them as callbacks in 8250_omap.c and 8250_of.c.

start_tx_rs485() is idempotent in that it recognizes whether RTS is
already asserted.  Achieve the same by introducing a tx_stopped flag in
struct uart_8250_em485.  This may even perform a little better on arches
where memory access is faster than mmio access.

	Signed-off-by: Lukas Wunner <lukas@wunner.de>
	Cc: Matwey V. Kornilov <matwey@sai.msu.ru>
Link: https://lore.kernel.org/r/5ac0464ae4414708e723a1e0d52b0c1b2bd41b9b.1582895077.git.lukas@wunner.de
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 058bc104f7ca5c83d81695ee96f03dbd93bae518)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/serial/8250/8250.h
#	drivers/tty/serial/8250/8250_of.c
#	drivers/tty/serial/8250/8250_omap.c
#	include/linux/serial_8250.h
diff --cc drivers/tty/serial/8250/8250.h
index d58d44a7ebb6,52bb21205bb6..000000000000
--- a/drivers/tty/serial/8250/8250.h
+++ b/drivers/tty/serial/8250/8250.h
@@@ -136,7 -156,9 +136,13 @@@ void serial8250_rpm_put(struct uart_825
  void serial8250_rpm_get_tx(struct uart_8250_port *p);
  void serial8250_rpm_put_tx(struct uart_8250_port *p);
  
++<<<<<<< HEAD
 +int serial8250_em485_init(struct uart_8250_port *p);
++=======
+ int serial8250_em485_config(struct uart_port *port, struct serial_rs485 *rs485);
+ void serial8250_em485_start_tx(struct uart_8250_port *p);
+ void serial8250_em485_stop_tx(struct uart_8250_port *p);
++>>>>>>> 058bc104f7ca (serial: 8250: Generalize rs485 software emulation)
  void serial8250_em485_destroy(struct uart_8250_port *p);
  
  /* MCR <-> TIOCM conversion */
diff --cc drivers/tty/serial/8250/8250_of.c
index f7e76c160d0a,65e9045dafe6..000000000000
--- a/drivers/tty/serial/8250/8250_of.c
+++ b/drivers/tty/serial/8250/8250_of.c
@@@ -150,6 -155,9 +151,12 @@@ static int of_platform_serial_setup(str
  		port->flags |= UPF_SKIP_TEST;
  
  	port->dev = &ofdev->dev;
++<<<<<<< HEAD
++=======
+ 	port->rs485_config = serial8250_em485_config;
+ 	up->rs485_start_tx = serial8250_em485_start_tx;
+ 	up->rs485_stop_tx = serial8250_em485_stop_tx;
++>>>>>>> 058bc104f7ca (serial: 8250: Generalize rs485 software emulation)
  
  	switch (type) {
  	case PORT_RT2880:
diff --cc drivers/tty/serial/8250/8250_omap.c
index 23156d57d732,dd69226ce918..000000000000
--- a/drivers/tty/serial/8250/8250_omap.c
+++ b/drivers/tty/serial/8250/8250_omap.c
@@@ -1191,25 -1157,14 +1191,32 @@@ static int omap8250_probe(struct platfo
  	up.port.shutdown = omap_8250_shutdown;
  	up.port.throttle = omap_8250_throttle;
  	up.port.unthrottle = omap_8250_unthrottle;
++<<<<<<< HEAD
 +	up.port.rs485_config = omap_8250_rs485_config;
++=======
+ 	up.port.rs485_config = serial8250_em485_config;
+ 	up.rs485_start_tx = serial8250_em485_start_tx;
+ 	up.rs485_stop_tx = serial8250_em485_stop_tx;
+ 	up.port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_8250_CONSOLE);
++>>>>>>> 058bc104f7ca (serial: 8250: Generalize rs485 software emulation)
 +
 +	if (pdev->dev.of_node) {
 +		const struct of_device_id *id;
  
 -	ret = of_alias_get_id(np, "serial");
 +		ret = of_alias_get_id(pdev->dev.of_node, "serial");
 +
 +		of_property_read_u32(pdev->dev.of_node, "clock-frequency",
 +				     &up.port.uartclk);
 +		priv->wakeirq = irq_of_parse_and_map(pdev->dev.of_node, 1);
 +
 +		id = of_match_device(of_match_ptr(omap8250_dt_ids), &pdev->dev);
 +		if (id && id->data)
 +			priv->habit |= *(u8 *)id->data;
 +	} else {
 +		ret = pdev->id;
 +	}
  	if (ret < 0) {
 -		dev_err(&pdev->dev, "failed to get alias\n");
 +		dev_err(&pdev->dev, "failed to get alias/pdev id\n");
  		return ret;
  	}
  	up.port.line = ret;
diff --cc include/linux/serial_8250.h
index 0db168009439,0901c2aa366c..000000000000
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@@ -134,6 -133,12 +135,15 @@@ struct uart_8250_port 
  	void			(*dl_write)(struct uart_8250_port *, int);
  
  	struct uart_8250_em485 *em485;
++<<<<<<< HEAD
++=======
+ 	void			(*rs485_start_tx)(struct uart_8250_port *);
+ 	void			(*rs485_stop_tx)(struct uart_8250_port *);
+ 
+ 	/* Serial port overrun backoff */
+ 	struct delayed_work overrun_backoff;
+ 	u32 overrun_backoff_time_ms;
++>>>>>>> 058bc104f7ca (serial: 8250: Generalize rs485 software emulation)
  };
  
  static inline struct uart_8250_port *up_to_u8250p(struct uart_port *up)
* Unmerged path drivers/tty/serial/8250/8250.h
diff --git a/drivers/tty/serial/8250/8250_core.c b/drivers/tty/serial/8250/8250_core.c
index 998736e25bc4..0d3c0a1062b2 100644
--- a/drivers/tty/serial/8250/8250_core.c
+++ b/drivers/tty/serial/8250/8250_core.c
@@ -998,6 +998,8 @@ int serial8250_register_8250_port(struct uart_8250_port *up)
 		uart->port.unthrottle	= up->port.unthrottle;
 		uart->port.rs485_config	= up->port.rs485_config;
 		uart->port.rs485	= up->port.rs485;
+		uart->rs485_start_tx	= up->rs485_start_tx;
+		uart->rs485_stop_tx	= up->rs485_stop_tx;
 		uart->dma		= up->dma;
 
 		/* Take tx_loadsz from fifosize if it wasn't set separately */
* Unmerged path drivers/tty/serial/8250/8250_of.c
* Unmerged path drivers/tty/serial/8250/8250_omap.c
diff --git a/drivers/tty/serial/8250/8250_port.c b/drivers/tty/serial/8250/8250_port.c
index d58f7359f288..04c9d581bdc5 100644
--- a/drivers/tty/serial/8250/8250_port.c
+++ b/drivers/tty/serial/8250/8250_port.c
@@ -569,17 +569,6 @@ static void serial8250_clear_fifos(struct uart_8250_port *p)
 	}
 }
 
-static inline void serial8250_em485_rts_after_send(struct uart_8250_port *p)
-{
-	unsigned char mcr = serial8250_in_MCR(p);
-
-	if (p->port.rs485.flags & SER_RS485_RTS_AFTER_SEND)
-		mcr |= UART_MCR_RTS;
-	else
-		mcr &= ~UART_MCR_RTS;
-	serial8250_out_MCR(p, mcr);
-}
-
 static enum hrtimer_restart serial8250_em485_handle_start_tx(struct hrtimer *t);
 static enum hrtimer_restart serial8250_em485_handle_stop_tx(struct hrtimer *t);
 
@@ -644,7 +633,9 @@ int serial8250_em485_init(struct uart_8250_port *p)
 	p->em485->start_tx_timer.function = &serial8250_em485_handle_start_tx;
 	p->em485->port = p;
 	p->em485->active_timer = NULL;
-	serial8250_em485_rts_after_send(p);
+	p->em485->tx_stopped = true;
+
+	p->rs485_stop_tx(p);
 
 	return 0;
 }
@@ -1448,9 +1439,21 @@ static void serial8250_stop_rx(struct uart_port *port)
 	serial8250_rpm_put(up);
 }
 
-static void __do_stop_tx_rs485(struct uart_8250_port *p)
+/**
+ * serial8250_em485_stop_tx() - generic ->rs485_stop_tx() callback
+ * @up: uart 8250 port
+ *
+ * Generic callback usable by 8250 uart drivers to stop rs485 transmission.
+ */
+void serial8250_em485_stop_tx(struct uart_8250_port *p)
 {
-	serial8250_em485_rts_after_send(p);
+	unsigned char mcr = serial8250_in_MCR(p);
+
+	if (p->port.rs485.flags & SER_RS485_RTS_AFTER_SEND)
+		mcr |= UART_MCR_RTS;
+	else
+		mcr &= ~UART_MCR_RTS;
+	serial8250_out_MCR(p, mcr);
 
 	/*
 	 * Empty the RX FIFO, we are not interested in anything
@@ -1464,6 +1467,8 @@ static void __do_stop_tx_rs485(struct uart_8250_port *p)
 		serial_port_out(&p->port, UART_IER, p->ier);
 	}
 }
+EXPORT_SYMBOL_GPL(serial8250_em485_stop_tx);
+
 static enum hrtimer_restart serial8250_em485_handle_stop_tx(struct hrtimer *t)
 {
 	struct uart_8250_em485 *em485;
@@ -1476,8 +1481,9 @@ static enum hrtimer_restart serial8250_em485_handle_stop_tx(struct hrtimer *t)
 	serial8250_rpm_get(p);
 	spin_lock_irqsave(&p->port.lock, flags);
 	if (em485->active_timer == &em485->stop_tx_timer) {
-		__do_stop_tx_rs485(p);
+		p->rs485_stop_tx(p);
 		em485->active_timer = NULL;
+		em485->tx_stopped = true;
 	}
 	spin_unlock_irqrestore(&p->port.lock, flags);
 	serial8250_rpm_put(p);
@@ -1498,7 +1504,7 @@ static void __stop_tx_rs485(struct uart_8250_port *p)
 	struct uart_8250_em485 *em485 = p->em485;
 
 	/*
-	 * __do_stop_tx_rs485 is going to set RTS according to config
+	 * rs485_stop_tx() is going to set RTS according to config
 	 * AND flush RX FIFO if required.
 	 */
 	if (p->port.rs485.delay_rts_after_send > 0) {
@@ -1506,8 +1512,9 @@ static void __stop_tx_rs485(struct uart_8250_port *p)
 		start_hrtimer_ms(&em485->stop_tx_timer,
 				   p->port.rs485.delay_rts_after_send);
 	} else {
-		__do_stop_tx_rs485(p);
+		p->rs485_stop_tx(p);
 		em485->active_timer = NULL;
+		em485->tx_stopped = true;
 	}
 }
 
@@ -1587,25 +1594,42 @@ static inline void __start_tx(struct uart_port *port)
 	}
 }
 
-static inline void start_tx_rs485(struct uart_port *port)
+/**
+ * serial8250_em485_start_tx() - generic ->rs485_start_tx() callback
+ * @up: uart 8250 port
+ *
+ * Generic callback usable by 8250 uart drivers to start rs485 transmission.
+ * Assumes that setting the RTS bit in the MCR register means RTS is high.
+ * (Some chips use inverse semantics.)  Further assumes that reception is
+ * stoppable by disabling the UART_IER_RDI interrupt.  (Some chips set the
+ * UART_LSR_DR bit even when UART_IER_RDI is disabled, foiling this approach.)
+ */
+void serial8250_em485_start_tx(struct uart_8250_port *up)
 {
-	struct uart_8250_port *up = up_to_u8250p(port);
-	struct uart_8250_em485 *em485 = up->em485;
-	unsigned char mcr;
+	unsigned char mcr = serial8250_in_MCR(up);
 
 	if (!(up->port.rs485.flags & SER_RS485_RX_DURING_TX))
 		serial8250_stop_rx(&up->port);
 
+	if (up->port.rs485.flags & SER_RS485_RTS_ON_SEND)
+		mcr |= UART_MCR_RTS;
+	else
+		mcr &= ~UART_MCR_RTS;
+	serial8250_out_MCR(up, mcr);
+}
+EXPORT_SYMBOL_GPL(serial8250_em485_start_tx);
+
+static inline void start_tx_rs485(struct uart_port *port)
+{
+	struct uart_8250_port *up = up_to_u8250p(port);
+	struct uart_8250_em485 *em485 = up->em485;
+
 	em485->active_timer = NULL;
 
-	mcr = serial8250_in_MCR(up);
-	if (!!(up->port.rs485.flags & SER_RS485_RTS_ON_SEND) !=
-	    !!(mcr & UART_MCR_RTS)) {
-		if (up->port.rs485.flags & SER_RS485_RTS_ON_SEND)
-			mcr |= UART_MCR_RTS;
-		else
-			mcr &= ~UART_MCR_RTS;
-		serial8250_out_MCR(up, mcr);
+	if (em485->tx_stopped) {
+		em485->tx_stopped = false;
+
+		up->rs485_start_tx(up);
 
 		if (up->port.rs485.delay_rts_before_send > 0) {
 			em485->active_timer = &em485->start_tx_timer;
* Unmerged path include/linux/serial_8250.h
