nvme: fix controller ioctl through ns_head

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Minwoo Im <minwoo.im.dev@gmail.com>
commit 48145b62563a9ae1ad631d6b576c6b9a798fcbec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/48145b62.failed

In multipath case, we should consider namespace attachment with
controllers in a subsystem when we find out the live controller for the
namespace.  This patch manually reverted the commit 3557a4409701
("nvme: don't bother to look up a namespace for controller ioctls") with
few more updates to nvme_ns_head_chr_ioctl which has been newly updated.

Fixes: 3557a4409701 ("nvme: don't bother to look up a namespace for
controller ioctls")
	Cc: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Minwoo Im <minwoo.im.dev@gmail.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 48145b62563a9ae1ad631d6b576c6b9a798fcbec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
#	drivers/nvme/host/ioctl.c
#	drivers/nvme/host/nvme.h
diff --cc drivers/nvme/host/core.c
index 0e1b405e0026,c1c196459d79..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -2459,31 -1999,6 +2459,34 @@@ static const struct block_device_operat
  	.pr_ops		= &nvme_pr_ops,
  };
  
++<<<<<<< HEAD
 +#ifdef CONFIG_NVME_MULTIPATH
 +static int nvme_ns_head_open(struct block_device *bdev, fmode_t mode)
 +{
 +	if (!nvme_tryget_ns_head(bdev->bd_disk->private_data))
 +		return -ENXIO;
 +	return 0;
 +}
 +
 +static void nvme_ns_head_release(struct gendisk *disk, fmode_t mode)
 +{
 +	nvme_put_ns_head(disk->private_data);
 +}
 +
 +const struct block_device_operations nvme_ns_head_ops = {
 +	.owner		= THIS_MODULE,
 +	.open		= nvme_ns_head_open,
 +	.release	= nvme_ns_head_release,
 +	.ioctl		= nvme_ioctl,
 +	.compat_ioctl	= nvme_compat_ioctl,
 +	.getgeo		= nvme_getgeo,
 +	.report_zones	= nvme_report_zones,
 +	.pr_ops		= &nvme_pr_ops,
 +};
 +#endif /* CONFIG_NVME_MULTIPATH */
 +
++=======
++>>>>>>> 48145b62563a (nvme: fix controller ioctl through ns_head)
  static int nvme_wait_ready(struct nvme_ctrl *ctrl, u64 cap, bool enabled)
  {
  	unsigned long timeout =
diff --cc drivers/nvme/host/nvme.h
index 7d87bfacb56d,c1e086a0bc3f..000000000000
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@@ -649,8 -662,24 +649,26 @@@ int nvme_get_log(struct nvme_ctrl *ctrl
  struct nvme_ns *nvme_get_ns_from_disk(struct gendisk *disk,
  		struct nvme_ns_head **head, int *srcu_idx);
  void nvme_put_ns_from_disk(struct nvme_ns_head *head, int idx);
++<<<<<<< HEAD
++=======
+ bool nvme_tryget_ns_head(struct nvme_ns_head *head);
+ void nvme_put_ns_head(struct nvme_ns_head *head);
+ int nvme_cdev_add(struct cdev *cdev, struct device *cdev_device,
+ 		const struct file_operations *fops, struct module *owner);
+ void nvme_cdev_del(struct cdev *cdev, struct device *cdev_device);
+ int nvme_ioctl(struct block_device *bdev, fmode_t mode,
+ 		unsigned int cmd, unsigned long arg);
+ long nvme_ns_chr_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+ int nvme_ns_head_ioctl(struct block_device *bdev, fmode_t mode,
+ 		unsigned int cmd, unsigned long arg);
+ long nvme_ns_head_chr_ioctl(struct file *file, unsigned int cmd,
+ 		unsigned long arg);
+ long nvme_dev_ioctl(struct file *file, unsigned int cmd,
+ 		unsigned long arg);
+ int nvme_getgeo(struct block_device *bdev, struct hd_geometry *geo);
++>>>>>>> 48145b62563a (nvme: fix controller ioctl through ns_head)
  
  extern const struct attribute_group *nvme_ns_id_attr_groups[];
 -extern const struct pr_ops nvme_pr_ops;
  extern const struct block_device_operations nvme_ns_head_ops;
  
  #ifdef CONFIG_NVME_MULTIPATH
* Unmerged path drivers/nvme/host/ioctl.c
* Unmerged path drivers/nvme/host/core.c
* Unmerged path drivers/nvme/host/ioctl.c
* Unmerged path drivers/nvme/host/nvme.h
