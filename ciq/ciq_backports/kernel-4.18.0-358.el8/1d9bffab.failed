x86/fpu: Move FXSAVE_LEAK quirk info __copy_kernel_to_fpregs()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 1d9bffab116fadfe1594f5fea2b50ab280d81d30
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/1d9bffab.failed

copy_kernel_to_fpregs() restores all xfeatures but it is also the place
where the AMD FXSAVE_LEAK bug is handled.

That prevents fpregs_restore_userregs() to limit the restored features,
which is required to untangle PKRU and XSTATE handling and also for the
upcoming supervisor state management.

Move the FXSAVE_LEAK quirk into __copy_kernel_to_fpregs() and deinline that
function which has become rather fat.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20210623121456.114271278@linutronix.de
(cherry picked from commit 1d9bffab116fadfe1594f5fea2b50ab280d81d30)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/fpu/internal.h
diff --cc arch/x86/include/asm/fpu/internal.h
index 5a42546d89cb,63d979656437..000000000000
--- a/arch/x86/include/asm/fpu/internal.h
+++ b/arch/x86/include/asm/fpu/internal.h
@@@ -377,36 -379,11 +377,44 @@@ static inline int copy_kernel_to_xregs_
  	return err;
  }
  
++<<<<<<< HEAD
 +extern int save_fpregs_to_fpstate(struct fpu *fpu);
 +
 +static inline void __copy_kernel_to_fpregs(union fpregs_state *fpstate, u64 mask)
 +{
 +	if (use_xsave()) {
 +		copy_kernel_to_xregs(&fpstate->xsave, mask);
 +	} else {
 +		if (use_fxsr())
 +			copy_kernel_to_fxregs(&fpstate->fxsave);
 +		else
 +			frstor(&fpstate->fsave);
 +	}
 +}
++=======
+ extern void __restore_fpregs_from_fpstate(union fpregs_state *fpstate, u64 mask);
++>>>>>>> 1d9bffab116f (x86/fpu: Move FXSAVE_LEAK quirk info __copy_kernel_to_fpregs())
  
 -static inline void restore_fpregs_from_fpstate(union fpregs_state *fpstate)
 +static inline void copy_kernel_to_fpregs(union fpregs_state *fpstate)
  {
++<<<<<<< HEAD
 +	/*
 +	 * AMD K7/K8 CPUs don't save/restore FDP/FIP/FOP unless an exception is
 +	 * pending. Clear the x87 state here by setting it to fixed values.
 +	 * "m" is a random variable that should be in L1.
 +	 */
 +	if (unlikely(static_cpu_has_bug(X86_BUG_FXSAVE_LEAK))) {
 +		asm volatile(
 +			"fnclex\n\t"
 +			"emms\n\t"
 +			"fildl %P[addr]"	/* set F?P to defined value */
 +			: : [addr] "m" (fpstate));
 +	}
 +
 +	__copy_kernel_to_fpregs(fpstate, -1);
++=======
+ 	__restore_fpregs_from_fpstate(fpstate, -1);
++>>>>>>> 1d9bffab116f (x86/fpu: Move FXSAVE_LEAK quirk info __copy_kernel_to_fpregs())
  }
  
  extern int copy_fpstate_to_sigframe(void __user *buf, void __user *fp, int size);
* Unmerged path arch/x86/include/asm/fpu/internal.h
diff --git a/arch/x86/kernel/fpu/core.c b/arch/x86/kernel/fpu/core.c
index d86fb6c58479..8963dd5114d4 100644
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@ -113,6 +113,33 @@ int save_fpregs_to_fpstate(struct fpu *fpu)
 }
 EXPORT_SYMBOL(save_fpregs_to_fpstate);
 
+void __restore_fpregs_from_fpstate(union fpregs_state *fpstate, u64 mask)
+{
+	/*
+	 * AMD K7/K8 and later CPUs up to Zen don't save/restore
+	 * FDP/FIP/FOP unless an exception is pending. Clear the x87 state
+	 * here by setting it to fixed values.  "m" is a random variable
+	 * that should be in L1.
+	 */
+	if (unlikely(static_cpu_has_bug(X86_BUG_FXSAVE_LEAK))) {
+		asm volatile(
+			"fnclex\n\t"
+			"emms\n\t"
+			"fildl %P[addr]"	/* set F?P to defined value */
+			: : [addr] "m" (fpstate));
+	}
+
+	if (use_xsave()) {
+		os_xrstor(&fpstate->xsave, mask);
+	} else {
+		if (use_fxsr())
+			fxrstor(&fpstate->fxsave);
+		else
+			frstor(&fpstate->fsave);
+	}
+}
+EXPORT_SYMBOL_GPL(__restore_fpregs_from_fpstate);
+
 void kernel_fpu_begin_mask(unsigned int kfpu_mask)
 {
 	preempt_disable();
