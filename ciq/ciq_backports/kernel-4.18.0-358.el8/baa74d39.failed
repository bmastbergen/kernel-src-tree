net: bridge: multicast: add EHT source set handling functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit baa74d39ca39f2b22eeac5c3b069b58491ecd418
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/baa74d39.failed

Add EHT source set and set-entry create, delete and lookup functions.
These allow to manipulate source sets which contain their own host sets
with entries which joined that S,G. We're limiting the maximum number of
tracked S,G entries per host to PG_SRC_ENT_LIMIT (currently 32) which is
the current maximum of S,G entries for a group. There's a per-set timer
which will be used to destroy the whole set later.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit baa74d39ca39f2b22eeac5c3b069b58491ecd418)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
#	net/bridge/br_multicast_eht.c
diff --cc net/bridge/br_multicast.c
index 4eaac3b4a6ea,ac363b104239..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -792,12 -1169,23 +793,18 @@@ struct net_bridge_port_group *br_multic
  	if (unlikely(!p))
  		return NULL;
  
 -	p->key.addr = *group;
 -	p->key.port = port;
 +	p->addr = *group;
 +	p->port = port;
  	p->flags = flags;
  	p->filter_mode = filter_mode;
++<<<<<<< HEAD
++=======
+ 	p->rt_protocol = rt_protocol;
+ 	p->eht_host_tree = RB_ROOT;
+ 	p->eht_set_tree = RB_ROOT;
++>>>>>>> baa74d39ca39 (net: bridge: multicast: add EHT source set handling functions)
  	p->mcast_gc.destroy = br_multicast_destroy_port_group;
  	INIT_HLIST_HEAD(&p->src_list);
 -
 -	if (!br_multicast_is_star_g(group) &&
 -	    rhashtable_lookup_insert_fast(&port->br->sg_port_tbl, &p->rhnode,
 -					  br_sg_port_rht_params)) {
 -		kfree(p);
 -		return NULL;
 -	}
 -
  	rcu_assign_pointer(p->next, next);
  	timer_setup(&p->timer, br_multicast_port_group_expired, 0);
  	timer_setup(&p->rexmit_timer, br_multicast_port_group_rexmit, 0);
* Unmerged path net/bridge/br_multicast_eht.c
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_multicast_eht.c
diff --git a/net/bridge/br_private_mcast_eht.h b/net/bridge/br_private_mcast_eht.h
index 0c9c4267969d..bba507c9acb0 100644
--- a/net/bridge/br_private_mcast_eht.h
+++ b/net/bridge/br_private_mcast_eht.h
@@ -47,4 +47,6 @@ struct net_bridge_group_eht_set {
 	struct net_bridge_mcast_gc	mcast_gc;
 };
 
+void br_multicast_eht_clean_sets(struct net_bridge_port_group *pg);
+
 #endif /* _BR_PRIVATE_MCAST_EHT_H_ */
