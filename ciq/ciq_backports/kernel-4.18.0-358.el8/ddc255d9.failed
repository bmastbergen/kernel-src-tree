net: bridge: multicast: add EHT include and exclude handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit ddc255d993d83bc13c2c8b239fd69cb87d12d03e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/ddc255d9.failed

Add support for IGMPv3/MLDv2 include and exclude EHT handling. Similar to
how the reports are processed we have 2 cases when the group is in include
or exclude mode, these are processed as follows:
 - group include
  - is_include: create missing entries
  - to_include: flush existing entries and create a new set from the
    report, obviously if the src set is empty then we delete the group

 - group exclude
  - is_exclude: create missing entries
  - to_exclude: flush existing entries and create a new set from the
    report, any empty source set entries are removed

If the group is in a different mode then we just flush all entries reported
by the host and we create a new set with the new mode entries created from
the report. If the report is include type, the source list is empty and
the group has empty sources' set then we remove it. Any source set entries
which are empty are removed as well. If the group is in exclude mode it
can exist without any S,G entries (allowing for all traffic to pass).

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit ddc255d993d83bc13c2c8b239fd69cb87d12d03e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
#	net/bridge/br_multicast_eht.c
#	net/bridge/br_private_mcast_eht.h
diff --cc net/bridge/br_multicast.c
index 4eaac3b4a6ea,9cfc004312ab..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -1427,8 -1840,9 +1427,14 @@@ static bool br_multicast_isinc_allow(st
   *                                                       Delete (A-B)
   *                                                       Group Timer=GMI
   */
++<<<<<<< HEAD
 +static void __grp_src_isexc_incl(struct net_bridge_port_group *pg,
 +				 void *srcs, u32 nsrcs, size_t src_size)
++=======
+ static void __grp_src_isexc_incl(struct net_bridge_port_group *pg, void *h_addr,
+ 				 void *srcs, u32 nsrcs, size_t addr_size,
+ 				 int grec_type)
++>>>>>>> ddc255d993d8 (net: bridge: multicast: add EHT include and exclude handling)
  {
  	struct net_bridge_group_src *ent;
  	struct br_ip src_ip;
@@@ -1445,10 -1859,13 +1451,12 @@@
  		if (ent)
  			ent->flags &= ~BR_SGRP_F_DELETE;
  		else
 -			ent = br_multicast_new_group_src(pg, &src_ip);
 -		if (ent)
 -			br_multicast_fwd_src_handle(ent);
 +			br_multicast_new_group_src(pg, &src_ip);
 +		srcs += src_size;
  	}
  
+ 	br_multicast_eht_handle(pg, h_addr, srcs, nsrcs, addr_size, grec_type);
+ 
  	__grp_src_delete_marked(pg);
  }
  
@@@ -1458,10 -1875,11 +1466,16 @@@
   *                                                       Delete (Y-A)
   *                                                       Group Timer=GMI
   */
++<<<<<<< HEAD
 +static bool __grp_src_isexc_excl(struct net_bridge_port_group *pg,
 +				 void *srcs, u32 nsrcs, size_t src_size)
++=======
+ static bool __grp_src_isexc_excl(struct net_bridge_port_group *pg, void *h_addr,
+ 				 void *srcs, u32 nsrcs, size_t addr_size,
+ 				 int grec_type)
++>>>>>>> ddc255d993d8 (net: bridge: multicast: add EHT include and exclude handling)
  {
 -	struct net_bridge *br = pg->key.port->br;
 +	struct net_bridge *br = pg->port->br;
  	struct net_bridge_group_src *ent;
  	unsigned long now = jiffies;
  	bool changed = false;
@@@ -1486,28 -1904,34 +1500,48 @@@
  				changed = true;
  			}
  		}
 +		srcs += src_size;
  	}
  
+ 	if (br_multicast_eht_handle(pg, h_addr, srcs, nsrcs, addr_size, grec_type))
+ 		changed = true;
+ 
  	if (__grp_src_delete_marked(pg))
  		changed = true;
  
  	return changed;
  }
  
++<<<<<<< HEAD
 +static bool br_multicast_isexc(struct net_bridge_port_group *pg,
 +			       void *srcs, u32 nsrcs, size_t src_size)
++=======
+ static bool br_multicast_isexc(struct net_bridge_port_group *pg, void *h_addr,
+ 			       void *srcs, u32 nsrcs, size_t addr_size,
+ 			       int grec_type)
++>>>>>>> ddc255d993d8 (net: bridge: multicast: add EHT include and exclude handling)
  {
 -	struct net_bridge *br = pg->key.port->br;
 +	struct net_bridge *br = pg->port->br;
  	bool changed = false;
  
  	switch (pg->filter_mode) {
  	case MCAST_INCLUDE:
++<<<<<<< HEAD
 +		__grp_src_isexc_incl(pg, srcs, nsrcs, src_size);
 +		changed = true;
 +		break;
 +	case MCAST_EXCLUDE:
 +		changed = __grp_src_isexc_excl(pg, srcs, nsrcs, src_size);
++=======
+ 		__grp_src_isexc_incl(pg, h_addr, srcs, nsrcs, addr_size,
+ 				     grec_type);
+ 		br_multicast_star_g_handle_mode(pg, MCAST_EXCLUDE);
+ 		changed = true;
+ 		break;
+ 	case MCAST_EXCLUDE:
+ 		changed = __grp_src_isexc_excl(pg, h_addr, srcs, nsrcs, addr_size,
+ 					       grec_type);
++>>>>>>> ddc255d993d8 (net: bridge: multicast: add EHT include and exclude handling)
  		break;
  	}
  
@@@ -1521,10 -1945,11 +1555,16 @@@
   * INCLUDE (A)    TO_IN (B)     INCLUDE (A+B)            (B)=GMI
   *                                                       Send Q(G,A-B)
   */
++<<<<<<< HEAD
 +static bool __grp_src_toin_incl(struct net_bridge_port_group *pg,
 +				void *srcs, u32 nsrcs, size_t src_size)
++=======
+ static bool __grp_src_toin_incl(struct net_bridge_port_group *pg, void *h_addr,
+ 				void *srcs, u32 nsrcs, size_t addr_size,
+ 				int grec_type)
++>>>>>>> ddc255d993d8 (net: bridge: multicast: add EHT include and exclude handling)
  {
 -	struct net_bridge *br = pg->key.port->br;
 +	struct net_bridge *br = pg->port->br;
  	u32 src_idx, to_send = pg->src_ents;
  	struct net_bridge_group_src *ent;
  	unsigned long now = jiffies;
@@@ -1548,10 -1973,12 +1588,13 @@@
  				changed = true;
  		}
  		if (ent)
 -			__grp_src_mod_timer(ent, now + br_multicast_gmi(br));
 +			mod_timer(&ent->timer, now + br_multicast_gmi(br));
 +		srcs += src_size;
  	}
  
+ 	if (br_multicast_eht_handle(pg, h_addr, srcs, nsrcs, addr_size, grec_type))
+ 		changed = true;
+ 
  	if (to_send)
  		__grp_src_query_marked_and_rexmit(pg);
  
@@@ -1563,10 -1990,11 +1606,16 @@@
   *                                                       Send Q(G,X-A)
   *                                                       Send Q(G)
   */
++<<<<<<< HEAD
 +static bool __grp_src_toin_excl(struct net_bridge_port_group *pg,
 +				void *srcs, u32 nsrcs, size_t src_size)
++=======
+ static bool __grp_src_toin_excl(struct net_bridge_port_group *pg, void *h_addr,
+ 				void *srcs, u32 nsrcs, size_t addr_size,
+ 				int grec_type)
++>>>>>>> ddc255d993d8 (net: bridge: multicast: add EHT include and exclude handling)
  {
 -	struct net_bridge *br = pg->key.port->br;
 +	struct net_bridge *br = pg->port->br;
  	u32 src_idx, to_send = pg->src_ents;
  	struct net_bridge_group_src *ent;
  	unsigned long now = jiffies;
@@@ -1593,10 -2021,12 +1642,13 @@@
  				changed = true;
  		}
  		if (ent)
 -			__grp_src_mod_timer(ent, now + br_multicast_gmi(br));
 +			mod_timer(&ent->timer, now + br_multicast_gmi(br));
 +		srcs += src_size;
  	}
  
+ 	if (br_multicast_eht_handle(pg, h_addr, srcs, nsrcs, addr_size, grec_type))
+ 		changed = true;
+ 
  	if (to_send)
  		__grp_src_query_marked_and_rexmit(pg);
  
@@@ -1605,18 -2035,29 +1657,41 @@@
  	return changed;
  }
  
++<<<<<<< HEAD
 +static bool br_multicast_toin(struct net_bridge_port_group *pg,
 +			      void *srcs, u32 nsrcs, size_t src_size)
++=======
+ static bool br_multicast_toin(struct net_bridge_port_group *pg, void *h_addr,
+ 			      void *srcs, u32 nsrcs, size_t addr_size,
+ 			      int grec_type)
++>>>>>>> ddc255d993d8 (net: bridge: multicast: add EHT include and exclude handling)
  {
  	bool changed = false;
  
  	switch (pg->filter_mode) {
  	case MCAST_INCLUDE:
++<<<<<<< HEAD
 +		changed = __grp_src_toin_incl(pg, srcs, nsrcs, src_size);
 +		break;
 +	case MCAST_EXCLUDE:
 +		changed = __grp_src_toin_excl(pg, srcs, nsrcs, src_size);
++=======
+ 		changed = __grp_src_toin_incl(pg, h_addr, srcs, nsrcs, addr_size,
+ 					      grec_type);
  		break;
+ 	case MCAST_EXCLUDE:
+ 		changed = __grp_src_toin_excl(pg, h_addr, srcs, nsrcs, addr_size,
+ 					      grec_type);
++>>>>>>> ddc255d993d8 (net: bridge: multicast: add EHT include and exclude handling)
+ 		break;
+ 	}
+ 
+ 	if (br_multicast_eht_should_del_pg(pg)) {
+ 		br_multicast_find_del_pg(pg->key.port->br, pg);
+ 		/* a notification has already been sent and we shouldn't
+ 		 * access pg after the delete so we have to return false
+ 		 */
+ 		changed = false;
  	}
  
  	return changed;
@@@ -1628,8 -2069,9 +1703,14 @@@
   *                                                       Send Q(G,A*B)
   *                                                       Group Timer=GMI
   */
++<<<<<<< HEAD
 +static void __grp_src_toex_incl(struct net_bridge_port_group *pg,
 +				void *srcs, u32 nsrcs, size_t src_size)
++=======
+ static void __grp_src_toex_incl(struct net_bridge_port_group *pg, void *h_addr,
+ 				void *srcs, u32 nsrcs, size_t addr_size,
+ 				int grec_type)
++>>>>>>> ddc255d993d8 (net: bridge: multicast: add EHT include and exclude handling)
  {
  	struct net_bridge_group_src *ent;
  	u32 src_idx, to_send = 0;
@@@ -1648,11 -2090,14 +1729,13 @@@
  				     BR_SGRP_F_SEND;
  			to_send++;
  		} else {
 -			ent = br_multicast_new_group_src(pg, &src_ip);
 +			br_multicast_new_group_src(pg, &src_ip);
  		}
 -		if (ent)
 -			br_multicast_fwd_src_handle(ent);
 +		srcs += src_size;
  	}
  
+ 	br_multicast_eht_handle(pg, h_addr, srcs, nsrcs, addr_size, grec_type);
+ 
  	__grp_src_delete_marked(pg);
  	if (to_send)
  		__grp_src_query_marked_and_rexmit(pg);
@@@ -1665,8 -2110,9 +1748,14 @@@
   *                                                       Send Q(G,A-Y)
   *                                                       Group Timer=GMI
   */
++<<<<<<< HEAD
 +static bool __grp_src_toex_excl(struct net_bridge_port_group *pg,
 +				void *srcs, u32 nsrcs, size_t src_size)
++=======
+ static bool __grp_src_toex_excl(struct net_bridge_port_group *pg, void *h_addr,
+ 				void *srcs, u32 nsrcs, size_t addr_size,
+ 				int grec_type)
++>>>>>>> ddc255d993d8 (net: bridge: multicast: add EHT include and exclude handling)
  {
  	struct net_bridge_group_src *ent;
  	u32 src_idx, to_send = 0;
@@@ -1694,9 -2140,11 +1783,12 @@@
  			ent->flags |= BR_SGRP_F_SEND;
  			to_send++;
  		}
 +		srcs += src_size;
  	}
  
+ 	if (br_multicast_eht_handle(pg, h_addr, srcs, nsrcs, addr_size, grec_type))
+ 		changed = true;
+ 
  	if (__grp_src_delete_marked(pg))
  		changed = true;
  	if (to_send)
@@@ -1705,19 -2153,23 +1797,36 @@@
  	return changed;
  }
  
++<<<<<<< HEAD
 +static bool br_multicast_toex(struct net_bridge_port_group *pg,
 +			      void *srcs, u32 nsrcs, size_t src_size)
++=======
+ static bool br_multicast_toex(struct net_bridge_port_group *pg, void *h_addr,
+ 			      void *srcs, u32 nsrcs, size_t addr_size,
+ 			      int grec_type)
++>>>>>>> ddc255d993d8 (net: bridge: multicast: add EHT include and exclude handling)
  {
 -	struct net_bridge *br = pg->key.port->br;
 +	struct net_bridge *br = pg->port->br;
  	bool changed = false;
  
  	switch (pg->filter_mode) {
  	case MCAST_INCLUDE:
++<<<<<<< HEAD
 +		__grp_src_toex_incl(pg, srcs, nsrcs, src_size);
 +		changed = true;
 +		break;
 +	case MCAST_EXCLUDE:
 +		changed = __grp_src_toex_excl(pg, srcs, nsrcs, src_size);
++=======
+ 		__grp_src_toex_incl(pg, h_addr, srcs, nsrcs, addr_size,
+ 				    grec_type);
+ 		br_multicast_star_g_handle_mode(pg, MCAST_EXCLUDE);
+ 		changed = true;
+ 		break;
+ 	case MCAST_EXCLUDE:
+ 		changed = __grp_src_toex_excl(pg, h_addr, srcs, nsrcs, addr_size,
+ 					      grec_type);
++>>>>>>> ddc255d993d8 (net: bridge: multicast: add EHT include and exclude handling)
  		break;
  	}
  
@@@ -1906,32 -2372,33 +2015,45 @@@ static int br_ip4_multicast_igmp3_repor
  		pg = br_multicast_find_port(mdst, port, src);
  		if (!pg || (pg->flags & MDB_PG_FLAGS_PERMANENT))
  			goto unlock_continue;
 -		/* reload grec and host addr */
 +		/* reload grec */
  		grec = (void *)(skb->data + len - sizeof(*grec) - (nsrcs * 4));
 -		h_addr = &ip_hdr(skb)->saddr;
  		switch (type) {
  		case IGMPV3_ALLOW_NEW_SOURCES:
 -			changed = br_multicast_isinc_allow(pg, h_addr, grec->grec_src,
 -							   nsrcs, sizeof(__be32), type);
 +			changed = br_multicast_isinc_allow(pg, grec->grec_src,
 +							   nsrcs, sizeof(__be32));
  			break;
  		case IGMPV3_MODE_IS_INCLUDE:
 -			changed = br_multicast_isinc_allow(pg, h_addr, grec->grec_src,
 -							   nsrcs, sizeof(__be32), type);
 +			changed = br_multicast_isinc_allow(pg, grec->grec_src, nsrcs,
 +							   sizeof(__be32));
  			break;
  		case IGMPV3_MODE_IS_EXCLUDE:
++<<<<<<< HEAD
 +			changed = br_multicast_isexc(pg, grec->grec_src, nsrcs,
 +						     sizeof(__be32));
 +			break;
 +		case IGMPV3_CHANGE_TO_INCLUDE:
 +			changed = br_multicast_toin(pg, grec->grec_src, nsrcs,
 +						    sizeof(__be32));
 +			break;
 +		case IGMPV3_CHANGE_TO_EXCLUDE:
 +			changed = br_multicast_toex(pg, grec->grec_src, nsrcs,
 +						    sizeof(__be32));
++=======
+ 			changed = br_multicast_isexc(pg, h_addr, grec->grec_src,
+ 						     nsrcs, sizeof(__be32), type);
+ 			break;
+ 		case IGMPV3_CHANGE_TO_INCLUDE:
+ 			changed = br_multicast_toin(pg, h_addr, grec->grec_src,
+ 						    nsrcs, sizeof(__be32), type);
+ 			break;
+ 		case IGMPV3_CHANGE_TO_EXCLUDE:
+ 			changed = br_multicast_toex(pg, h_addr, grec->grec_src,
+ 						    nsrcs, sizeof(__be32), type);
++>>>>>>> ddc255d993d8 (net: bridge: multicast: add EHT include and exclude handling)
  			break;
  		case IGMPV3_BLOCK_OLD_SOURCES:
 -			changed = br_multicast_block(pg, h_addr, grec->grec_src,
 -						     nsrcs, sizeof(__be32), type);
 +			changed = br_multicast_block(pg, grec->grec_src, nsrcs,
 +						     sizeof(__be32));
  			break;
  		}
  		if (changed)
@@@ -2033,31 -2501,43 +2155,50 @@@ static int br_ip6_multicast_mld2_report
  		pg = br_multicast_find_port(mdst, port, src);
  		if (!pg || (pg->flags & MDB_PG_FLAGS_PERMANENT))
  			goto unlock_continue;
 -		h_addr = &ipv6_hdr(skb)->saddr;
  		switch (grec->grec_type) {
  		case MLD2_ALLOW_NEW_SOURCES:
 -			changed = br_multicast_isinc_allow(pg, h_addr,
 -							   grec->grec_src, nsrcs,
 -							   sizeof(struct in6_addr),
 -							   grec->grec_type);
 +			changed = br_multicast_isinc_allow(pg, grec->grec_src,
 +							   nsrcs,
 +							   sizeof(struct in6_addr));
  			break;
  		case MLD2_MODE_IS_INCLUDE:
 -			changed = br_multicast_isinc_allow(pg, h_addr,
 -							   grec->grec_src, nsrcs,
 -							   sizeof(struct in6_addr),
 -							   grec->grec_type);
 +			changed = br_multicast_isinc_allow(pg, grec->grec_src, nsrcs,
 +							   sizeof(struct in6_addr));
  			break;
  		case MLD2_MODE_IS_EXCLUDE:
++<<<<<<< HEAD
 +			changed = br_multicast_isexc(pg, grec->grec_src, nsrcs,
 +						     sizeof(struct in6_addr));
 +			break;
 +		case MLD2_CHANGE_TO_INCLUDE:
 +			changed = br_multicast_toin(pg, grec->grec_src, nsrcs,
 +						    sizeof(struct in6_addr));
 +			break;
 +		case MLD2_CHANGE_TO_EXCLUDE:
 +			changed = br_multicast_toex(pg, grec->grec_src, nsrcs,
 +						    sizeof(struct in6_addr));
++=======
+ 			changed = br_multicast_isexc(pg, h_addr,
+ 						     grec->grec_src, nsrcs,
+ 						     sizeof(struct in6_addr),
+ 						     grec->grec_type);
+ 			break;
+ 		case MLD2_CHANGE_TO_INCLUDE:
+ 			changed = br_multicast_toin(pg, h_addr,
+ 						    grec->grec_src, nsrcs,
+ 						    sizeof(struct in6_addr),
+ 						    grec->grec_type);
+ 			break;
+ 		case MLD2_CHANGE_TO_EXCLUDE:
+ 			changed = br_multicast_toex(pg, h_addr,
+ 						    grec->grec_src, nsrcs,
+ 						    sizeof(struct in6_addr),
+ 						    grec->grec_type);
++>>>>>>> ddc255d993d8 (net: bridge: multicast: add EHT include and exclude handling)
  			break;
  		case MLD2_BLOCK_OLD_SOURCES:
 -			changed = br_multicast_block(pg, h_addr,
 -						     grec->grec_src, nsrcs,
 -						     sizeof(struct in6_addr),
 -						     grec->grec_type);
 +			changed = br_multicast_block(pg, grec->grec_src, nsrcs,
 +						     sizeof(struct in6_addr));
  			break;
  		}
  		if (changed)
diff --cc net/bridge/br_private_mcast_eht.h
index 0c9c4267969d,9daffa3ad8d5..000000000000
--- a/net/bridge/br_private_mcast_eht.h
+++ b/net/bridge/br_private_mcast_eht.h
@@@ -47,4 -47,19 +47,22 @@@ struct net_bridge_group_eht_set 
  	struct net_bridge_mcast_gc	mcast_gc;
  };
  
++<<<<<<< HEAD
++=======
+ void br_multicast_eht_clean_sets(struct net_bridge_port_group *pg);
+ bool br_multicast_eht_handle(struct net_bridge_port_group *pg,
+ 			     void *h_addr,
+ 			     void *srcs,
+ 			     u32 nsrcs,
+ 			     size_t addr_size,
+ 			     int grec_type);
+ 
+ static inline bool
+ br_multicast_eht_should_del_pg(const struct net_bridge_port_group *pg)
+ {
+ 	return !!((pg->key.port->flags & BR_MULTICAST_FAST_LEAVE) &&
+ 		  RB_EMPTY_ROOT(&pg->eht_host_tree));
+ }
+ 
++>>>>>>> ddc255d993d8 (net: bridge: multicast: add EHT include and exclude handling)
  #endif /* _BR_PRIVATE_MCAST_EHT_H_ */
* Unmerged path net/bridge/br_multicast_eht.c
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_multicast_eht.c
* Unmerged path net/bridge/br_private_mcast_eht.h
