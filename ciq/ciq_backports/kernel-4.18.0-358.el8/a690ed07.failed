time/sched_clock: Use seqcount_latch_t

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Ahmed S. Darwish <a.darwish@linutronix.de>
commit a690ed07353ec45f056b0a6f87c23a12a59c030d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/a690ed07.failed

Latch sequence counters have unique read and write APIs, and thus
seqcount_latch_t was recently introduced at seqlock.h.

Use that new data type instead of plain seqcount_t. This adds the
necessary type-safety and ensures only latching-safe seqcount APIs are
to be used.

	Signed-off-by: Ahmed S. Darwish <a.darwish@linutronix.de>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20200827114044.11173-5-a.darwish@linutronix.de
(cherry picked from commit a690ed07353ec45f056b0a6f87c23a12a59c030d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/sched_clock.c
diff --cc kernel/time/sched_clock.c
index d1dcfcebc1c4,0642013dace4..000000000000
--- a/kernel/time/sched_clock.c
+++ b/kernel/time/sched_clock.c
@@@ -96,6 -68,17 +96,20 @@@ static inline u64 notrace cyc_to_ns(u6
  	return (cyc * mult) >> shift;
  }
  
++<<<<<<< HEAD
++=======
+ struct clock_read_data *sched_clock_read_begin(unsigned int *seq)
+ {
+ 	*seq = raw_read_seqcount_latch(&cd.seq);
+ 	return cd.read_data + (*seq & 1);
+ }
+ 
+ int sched_clock_read_retry(unsigned int seq)
+ {
+ 	return read_seqcount_latch_retry(&cd.seq, seq);
+ }
+ 
++>>>>>>> a690ed07353e (time/sched_clock: Use seqcount_latch_t)
  unsigned long long notrace sched_clock(void)
  {
  	u64 cyc, res;
* Unmerged path kernel/time/sched_clock.c
