Bluetooth: Add handler of MGMT_OP_ADD_ADV_PATTERNS_MONITOR

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Miao-chen Chou <mcchou@chromium.org>
commit b139553db5cd940d66095fb97de1727e9a19369f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/b139553d.failed

This adds the request handler of MGMT_OP_ADD_ADV_PATTERNS_MONITOR command.
Note that the controller-based monitoring is not yet in place. This tracks
the content of the monitor without sending HCI traffic, so the request
returns immediately.

The following manual test was performed.
- Issue btmgmt advmon-add with valid and invalid inputs.
- Issue btmgmt advmon-add more the allowed number of monitors.

	Signed-off-by: Miao-chen Chou <mcchou@chromium.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
	Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
(cherry picked from commit b139553db5cd940d66095fb97de1727e9a19369f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/bluetooth/hci_core.h
#	net/bluetooth/hci_core.c
#	net/bluetooth/mgmt.c
diff --cc include/net/bluetooth/hci_core.h
index 7a4a7a86d423,13fad419ae7d..000000000000
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@@ -1261,6 -1280,10 +1261,13 @@@ int hci_add_adv_instance(struct hci_de
  int hci_remove_adv_instance(struct hci_dev *hdev, u8 instance);
  void hci_adv_instances_set_rpa_expired(struct hci_dev *hdev, bool rpa_expired);
  
++<<<<<<< HEAD
++=======
+ void hci_adv_monitors_clear(struct hci_dev *hdev);
+ void hci_free_adv_monitor(struct adv_monitor *monitor);
+ int hci_add_adv_monitor(struct hci_dev *hdev, struct adv_monitor *monitor);
+ 
++>>>>>>> b139553db5cd (Bluetooth: Add handler of MGMT_OP_ADD_ADV_PATTERNS_MONITOR)
  void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
  
  void hci_init_sysfs(struct hci_dev *hdev);
diff --cc net/bluetooth/hci_core.c
index 666cd966baa4,ce481fab349d..000000000000
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@@ -2995,6 -2995,52 +2995,55 @@@ int hci_add_adv_instance(struct hci_de
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* This function requires the caller holds hdev->lock */
+ void hci_adv_monitors_clear(struct hci_dev *hdev)
+ {
+ 	struct adv_monitor *monitor;
+ 	int handle;
+ 
+ 	idr_for_each_entry(&hdev->adv_monitors_idr, monitor, handle)
+ 		hci_free_adv_monitor(monitor);
+ 
+ 	idr_destroy(&hdev->adv_monitors_idr);
+ }
+ 
+ void hci_free_adv_monitor(struct adv_monitor *monitor)
+ {
+ 	struct adv_pattern *pattern;
+ 	struct adv_pattern *tmp;
+ 
+ 	if (!monitor)
+ 		return;
+ 
+ 	list_for_each_entry_safe(pattern, tmp, &monitor->patterns, list)
+ 		kfree(pattern);
+ 
+ 	kfree(monitor);
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ int hci_add_adv_monitor(struct hci_dev *hdev, struct adv_monitor *monitor)
+ {
+ 	int min, max, handle;
+ 
+ 	if (!monitor)
+ 		return -EINVAL;
+ 
+ 	min = HCI_MIN_ADV_MONITOR_HANDLE;
+ 	max = HCI_MIN_ADV_MONITOR_HANDLE + HCI_MAX_ADV_MONITOR_NUM_HANDLES;
+ 	handle = idr_alloc(&hdev->adv_monitors_idr, monitor, min, max,
+ 			   GFP_KERNEL);
+ 	if (handle < 0)
+ 		return handle;
+ 
+ 	hdev->adv_monitors_cnt++;
+ 	monitor->handle = handle;
+ 	return 0;
+ }
+ 
++>>>>>>> b139553db5cd (Bluetooth: Add handler of MGMT_OP_ADD_ADV_PATTERNS_MONITOR)
  struct bdaddr_list *hci_bdaddr_list_lookup(struct list_head *bdaddr_list,
  					 bdaddr_t *bdaddr, u8 type)
  {
diff --cc net/bluetooth/mgmt.c
index 46a1d1b65411,1eca36e51706..000000000000
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@@ -108,6 -110,17 +108,20 @@@ static const u16 mgmt_commands[] = 
  	MGMT_OP_SET_APPEARANCE,
  	MGMT_OP_SET_BLOCKED_KEYS,
  	MGMT_OP_SET_WIDEBAND_SPEECH,
++<<<<<<< HEAD
++=======
+ 	MGMT_OP_READ_SECURITY_INFO,
+ 	MGMT_OP_READ_EXP_FEATURES_INFO,
+ 	MGMT_OP_SET_EXP_FEATURE,
+ 	MGMT_OP_READ_DEF_SYSTEM_CONFIG,
+ 	MGMT_OP_SET_DEF_SYSTEM_CONFIG,
+ 	MGMT_OP_READ_DEF_RUNTIME_CONFIG,
+ 	MGMT_OP_SET_DEF_RUNTIME_CONFIG,
+ 	MGMT_OP_GET_DEVICE_FLAGS,
+ 	MGMT_OP_SET_DEVICE_FLAGS,
+ 	MGMT_OP_READ_ADV_MONITOR_FEATURES,
+ 	MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
++>>>>>>> b139553db5cd (Bluetooth: Add handler of MGMT_OP_ADD_ADV_PATTERNS_MONITOR)
  };
  
  static const u16 mgmt_events[] = {
@@@ -3611,55 -3679,445 +3625,152 @@@ unlock
  	return err;
  }
  
 -static int read_security_info(struct sock *sk, struct hci_dev *hdev,
 -			      void *data, u16 data_len)
 -{
 -	char buf[16];
 -	struct mgmt_rp_read_security_info *rp = (void *)buf;
 -	u16 sec_len = 0;
 -	u8 flags = 0;
 -
 -	bt_dev_dbg(hdev, "sock %p", sk);
 -
 -	memset(&buf, 0, sizeof(buf));
 -
 -	hci_dev_lock(hdev);
 -
 -	/* When the Read Simple Pairing Options command is supported, then
 -	 * the remote public key validation is supported.
 -	 */
 -	if (hdev->commands[41] & 0x08)
 -		flags |= 0x01;	/* Remote public key validation (BR/EDR) */
 -
 -	flags |= 0x02;		/* Remote public key validation (LE) */
 -
 -	/* When the Read Encryption Key Size command is supported, then the
 -	 * encryption key size is enforced.
 -	 */
 -	if (hdev->commands[20] & 0x10)
 -		flags |= 0x04;	/* Encryption key size enforcement (BR/EDR) */
 -
 -	flags |= 0x08;		/* Encryption key size enforcement (LE) */
 -
 -	sec_len = eir_append_data(rp->sec, sec_len, 0x01, &flags, 1);
 -
 -	/* When the Read Simple Pairing Options command is supported, then
 -	 * also max encryption key size information is provided.
 -	 */
 -	if (hdev->commands[41] & 0x08)
 -		sec_len = eir_append_le16(rp->sec, sec_len, 0x02,
 -					  hdev->max_enc_key_size);
 -
 -	sec_len = eir_append_le16(rp->sec, sec_len, 0x03, SMP_MAX_ENC_KEY_SIZE);
 -
 -	rp->sec_len = cpu_to_le16(sec_len);
 -
 -	hci_dev_unlock(hdev);
 -
 -	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_SECURITY_INFO, 0,
 -				 rp, sizeof(*rp) + sec_len);
 -}
 -
 -#ifdef CONFIG_BT_FEATURE_DEBUG
 -/* d4992530-b9ec-469f-ab01-6c481c47da1c */
 -static const u8 debug_uuid[16] = {
 -	0x1c, 0xda, 0x47, 0x1c, 0x48, 0x6c, 0x01, 0xab,
 -	0x9f, 0x46, 0xec, 0xb9, 0x30, 0x25, 0x99, 0xd4,
 -};
 -#endif
 -
 -static int read_exp_features_info(struct sock *sk, struct hci_dev *hdev,
 -				  void *data, u16 data_len)
 -{
 -	char buf[42];
 -	struct mgmt_rp_read_exp_features_info *rp = (void *)buf;
 -	u16 idx = 0;
 -
 -	bt_dev_dbg(hdev, "sock %p", sk);
 -
 -	memset(&buf, 0, sizeof(buf));
 -
 -#ifdef CONFIG_BT_FEATURE_DEBUG
 -	if (!hdev) {
 -		u32 flags = bt_dbg_get() ? BIT(0) : 0;
 -
 -		memcpy(rp->features[idx].uuid, debug_uuid, 16);
 -		rp->features[idx].flags = cpu_to_le32(flags);
 -		idx++;
 -	}
 -#endif
 -
 -	rp->feature_count = cpu_to_le16(idx);
 -
 -	/* After reading the experimental features information, enable
 -	 * the events to update client on any future change.
 -	 */
 -	hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
 -
 -	return mgmt_cmd_complete(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
 -				 MGMT_OP_READ_EXP_FEATURES_INFO,
 -				 0, rp, sizeof(*rp) + (20 * idx));
 -}
 -
 -#ifdef CONFIG_BT_FEATURE_DEBUG
 -static int exp_debug_feature_changed(bool enabled, struct sock *skip)
 -{
 -	struct mgmt_ev_exp_feature_changed ev;
 -
 -	memset(&ev, 0, sizeof(ev));
 -	memcpy(ev.uuid, debug_uuid, 16);
 -	ev.flags = cpu_to_le32(enabled ? BIT(0) : 0);
 -
 -	return mgmt_limited_event(MGMT_EV_EXP_FEATURE_CHANGED, NULL,
 -				  &ev, sizeof(ev),
 -				  HCI_MGMT_EXP_FEATURE_EVENTS, skip);
 -}
 -#endif
 -
 -static int set_exp_feature(struct sock *sk, struct hci_dev *hdev,
 -			   void *data, u16 data_len)
 -{
 -	struct mgmt_cp_set_exp_feature *cp = data;
 -	struct mgmt_rp_set_exp_feature rp;
 -
 -	bt_dev_dbg(hdev, "sock %p", sk);
 -
 -	if (!memcmp(cp->uuid, ZERO_KEY, 16)) {
 -		memset(rp.uuid, 0, 16);
 -		rp.flags = cpu_to_le32(0);
 -
 -#ifdef CONFIG_BT_FEATURE_DEBUG
 -		if (!hdev) {
 -			bool changed = bt_dbg_get();
 -
 -			bt_dbg_set(false);
 -
 -			if (changed)
 -				exp_debug_feature_changed(false, sk);
 -		}
 -#endif
 -
 -		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
 -
 -		return mgmt_cmd_complete(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
 -					 MGMT_OP_SET_EXP_FEATURE, 0,
 -					 &rp, sizeof(rp));
 -	}
 -
 -#ifdef CONFIG_BT_FEATURE_DEBUG
 -	if (!memcmp(cp->uuid, debug_uuid, 16)) {
 -		bool val, changed;
 -		int err;
 -
 -		/* Command requires to use the non-controller index */
 -		if (hdev)
 -			return mgmt_cmd_status(sk, hdev->id,
 -					       MGMT_OP_SET_EXP_FEATURE,
 -					       MGMT_STATUS_INVALID_INDEX);
 -
 -		/* Parameters are limited to a single octet */
 -		if (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)
 -			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
 -					       MGMT_OP_SET_EXP_FEATURE,
 -					       MGMT_STATUS_INVALID_PARAMS);
 -
 -		/* Only boolean on/off is supported */
 -		if (cp->param[0] != 0x00 && cp->param[0] != 0x01)
 -			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
 -					       MGMT_OP_SET_EXP_FEATURE,
 -					       MGMT_STATUS_INVALID_PARAMS);
 -
 -		val = !!cp->param[0];
 -		changed = val ? !bt_dbg_get() : bt_dbg_get();
 -		bt_dbg_set(val);
 -
 -		memcpy(rp.uuid, debug_uuid, 16);
 -		rp.flags = cpu_to_le32(val ? BIT(0) : 0);
 -
 -		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
 -
 -		err = mgmt_cmd_complete(sk, MGMT_INDEX_NONE,
 -					MGMT_OP_SET_EXP_FEATURE, 0,
 -					&rp, sizeof(rp));
 -
 -		if (changed)
 -			exp_debug_feature_changed(val, sk);
 -
 -		return err;
 -	}
 -#endif
 -
 -	return mgmt_cmd_status(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
 -			       MGMT_OP_SET_EXP_FEATURE,
 -			       MGMT_STATUS_NOT_SUPPORTED);
 -}
 -
 -#define SUPPORTED_DEVICE_FLAGS() ((1U << HCI_CONN_FLAG_MAX) - 1)
 -
 -static int get_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,
 -			    u16 data_len)
 -{
 -	struct mgmt_cp_get_device_flags *cp = data;
 -	struct mgmt_rp_get_device_flags rp;
 -	struct bdaddr_list_with_flags *br_params;
 -	struct hci_conn_params *params;
 -	u32 supported_flags = SUPPORTED_DEVICE_FLAGS();
 -	u32 current_flags = 0;
 -	u8 status = MGMT_STATUS_INVALID_PARAMS;
 -
 -	bt_dev_dbg(hdev, "Get device flags %pMR (type 0x%x)\n",
 -		   &cp->addr.bdaddr, cp->addr.type);
 -
 -	if (cp->addr.type == BDADDR_BREDR) {
 -		br_params = hci_bdaddr_list_lookup_with_flags(&hdev->whitelist,
 -							      &cp->addr.bdaddr,
 -							      cp->addr.type);
 -		if (!br_params)
 -			goto done;
 -
 -		current_flags = br_params->current_flags;
 -	} else {
 -		params = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,
 -						le_addr_type(cp->addr.type));
 -
 -		if (!params)
 -			goto done;
 -
 -		current_flags = params->current_flags;
 -	}
 -
 -	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
 -	rp.addr.type = cp->addr.type;
 -	rp.supported_flags = cpu_to_le32(supported_flags);
 -	rp.current_flags = cpu_to_le32(current_flags);
 -
 -	status = MGMT_STATUS_SUCCESS;
 -
 -done:
 -	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_DEVICE_FLAGS, status,
 -				&rp, sizeof(rp));
 -}
 -
 -static void device_flags_changed(struct sock *sk, struct hci_dev *hdev,
 -				 bdaddr_t *bdaddr, u8 bdaddr_type,
 -				 u32 supported_flags, u32 current_flags)
 -{
 -	struct mgmt_ev_device_flags_changed ev;
 -
 -	bacpy(&ev.addr.bdaddr, bdaddr);
 -	ev.addr.type = bdaddr_type;
 -	ev.supported_flags = cpu_to_le32(supported_flags);
 -	ev.current_flags = cpu_to_le32(current_flags);
 -
 -	mgmt_event(MGMT_EV_DEVICE_FLAGS_CHANGED, hdev, &ev, sizeof(ev), sk);
 -}
 -
 -static int set_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,
 +static int set_blocked_keys(struct sock *sk, struct hci_dev *hdev, void *data,
  			    u16 len)
  {
 -	struct mgmt_cp_set_device_flags *cp = data;
 -	struct bdaddr_list_with_flags *br_params;
 -	struct hci_conn_params *params;
 -	u8 status = MGMT_STATUS_INVALID_PARAMS;
 -	u32 supported_flags = SUPPORTED_DEVICE_FLAGS();
 -	u32 current_flags = __le32_to_cpu(cp->current_flags);
 +	int err = MGMT_STATUS_SUCCESS;
 +	struct mgmt_cp_set_blocked_keys *keys = data;
 +	const u16 max_key_count = ((U16_MAX - sizeof(*keys)) /
 +				   sizeof(struct mgmt_blocked_key_info));
 +	u16 key_count, expected_len;
 +	int i;
  
 -	bt_dev_dbg(hdev, "Set device flags %pMR (type 0x%x) = 0x%x",
 -		   &cp->addr.bdaddr, cp->addr.type,
 -		   __le32_to_cpu(current_flags));
 +	BT_DBG("request for %s", hdev->name);
  
 -	if ((supported_flags | current_flags) != supported_flags) {
 -		bt_dev_warn(hdev, "Bad flag given (0x%x) vs supported (0x%0x)",
 -			    current_flags, supported_flags);
 -		goto done;
 +	key_count = __le16_to_cpu(keys->key_count);
 +	if (key_count > max_key_count) {
 +		bt_dev_err(hdev, "too big key_count value %u", key_count);
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				       MGMT_STATUS_INVALID_PARAMS);
  	}
  
 -	if (cp->addr.type == BDADDR_BREDR) {
 -		br_params = hci_bdaddr_list_lookup_with_flags(&hdev->whitelist,
 -							      &cp->addr.bdaddr,
 -							      cp->addr.type);
 -
 -		if (br_params) {
 -			br_params->current_flags = current_flags;
 -			status = MGMT_STATUS_SUCCESS;
 -		} else {
 -			bt_dev_warn(hdev, "No such BR/EDR device %pMR (0x%x)",
 -				    &cp->addr.bdaddr, cp->addr.type);
 -		}
 -	} else {
 -		params = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,
 -						le_addr_type(cp->addr.type));
 -		if (params) {
 -			params->current_flags = current_flags;
 -			status = MGMT_STATUS_SUCCESS;
 -		} else {
 -			bt_dev_warn(hdev, "No such LE device %pMR (0x%x)",
 -				    &cp->addr.bdaddr,
 -				    le_addr_type(cp->addr.type));
 -		}
 +	expected_len = struct_size(keys, keys, key_count);
 +	if (expected_len != len) {
 +		bt_dev_err(hdev, "expected %u bytes, got %u bytes",
 +			   expected_len, len);
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				       MGMT_STATUS_INVALID_PARAMS);
  	}
  
 -done:
 -	if (status == MGMT_STATUS_SUCCESS)
 -		device_flags_changed(sk, hdev, &cp->addr.bdaddr, cp->addr.type,
 -				     supported_flags, current_flags);
 -
 -	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_DEVICE_FLAGS, status,
 -				 &cp->addr, sizeof(cp->addr));
 -}
 -
 -static int read_adv_mon_features(struct sock *sk, struct hci_dev *hdev,
 -				 void *data, u16 len)
 -{
 -	struct adv_monitor *monitor = NULL;
 -	struct mgmt_rp_read_adv_monitor_features *rp = NULL;
 -	int handle;
 -	size_t rp_size = 0;
 -	__u32 supported = 0;
 -	__u16 num_handles = 0;
 -	__u16 handles[HCI_MAX_ADV_MONITOR_NUM_HANDLES];
 +	hci_dev_lock(hdev);
  
 -	BT_DBG("request for %s", hdev->name);
 +	hci_blocked_keys_clear(hdev);
  
 -	hci_dev_lock(hdev);
 +	for (i = 0; i < keys->key_count; ++i) {
 +		struct blocked_key *b = kzalloc(sizeof(*b), GFP_KERNEL);
  
 -	if (msft_get_features(hdev) & MSFT_FEATURE_MASK_LE_ADV_MONITOR)
 -		supported |= MGMT_ADV_MONITOR_FEATURE_MASK_OR_PATTERNS;
 +		if (!b) {
 +			err = MGMT_STATUS_NO_RESOURCES;
 +			break;
 +		}
  
 -	idr_for_each_entry(&hdev->adv_monitors_idr, monitor, handle) {
 -		handles[num_handles++] = monitor->handle;
 +		b->type = keys->keys[i].type;
 +		memcpy(b->val, keys->keys[i].val, sizeof(b->val));
 +		list_add_rcu(&b->list, &hdev->blocked_keys);
  	}
 -
  	hci_dev_unlock(hdev);
  
 -	rp_size = sizeof(*rp) + (num_handles * sizeof(u16));
 -	rp = kmalloc(rp_size, GFP_KERNEL);
 -	if (!rp)
 -		return -ENOMEM;
 -
 -	/* Once controller-based monitoring is in place, the enabled_features
 -	 * should reflect the use.
 -	 */
 -	rp->supported_features = cpu_to_le32(supported);
 -	rp->enabled_features = 0;
 -	rp->max_num_handles = cpu_to_le16(HCI_MAX_ADV_MONITOR_NUM_HANDLES);
 -	rp->max_num_patterns = HCI_MAX_ADV_MONITOR_NUM_PATTERNS;
 -	rp->num_handles = cpu_to_le16(num_handles);
 -	if (num_handles)
 -		memcpy(&rp->handles, &handles, (num_handles * sizeof(u16)));
 -
 -	return mgmt_cmd_complete(sk, hdev->id,
 -				 MGMT_OP_READ_ADV_MONITOR_FEATURES,
 -				 MGMT_STATUS_SUCCESS, rp, rp_size);
 +	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				err, NULL, 0);
  }
  
+ static int add_adv_patterns_monitor(struct sock *sk, struct hci_dev *hdev,
+ 				    void *data, u16 len)
+ {
+ 	struct mgmt_cp_add_adv_patterns_monitor *cp = data;
+ 	struct mgmt_rp_add_adv_patterns_monitor rp;
+ 	struct adv_monitor *m = NULL;
+ 	struct adv_pattern *p = NULL;
+ 	__u8 cp_ofst = 0, cp_len = 0;
+ 	unsigned int mp_cnt = 0;
+ 	int err, i;
+ 
+ 	BT_DBG("request for %s", hdev->name);
+ 
+ 	if (len <= sizeof(*cp) || cp->pattern_count == 0) {
+ 		err = mgmt_cmd_status(sk, hdev->id,
+ 				      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
+ 				      MGMT_STATUS_INVALID_PARAMS);
+ 		goto failed;
+ 	}
+ 
+ 	m = kmalloc(sizeof(*m), GFP_KERNEL);
+ 	if (!m) {
+ 		err = -ENOMEM;
+ 		goto failed;
+ 	}
+ 
+ 	INIT_LIST_HEAD(&m->patterns);
+ 	m->active = false;
+ 
+ 	for (i = 0; i < cp->pattern_count; i++) {
+ 		if (++mp_cnt > HCI_MAX_ADV_MONITOR_NUM_PATTERNS) {
+ 			err = mgmt_cmd_status(sk, hdev->id,
+ 					      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
+ 					      MGMT_STATUS_INVALID_PARAMS);
+ 			goto failed;
+ 		}
+ 
+ 		cp_ofst = cp->patterns[i].offset;
+ 		cp_len = cp->patterns[i].length;
+ 		if (cp_ofst >= HCI_MAX_AD_LENGTH ||
+ 		    cp_len > HCI_MAX_AD_LENGTH ||
+ 		    (cp_ofst + cp_len) > HCI_MAX_AD_LENGTH) {
+ 			err = mgmt_cmd_status(sk, hdev->id,
+ 					      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
+ 					      MGMT_STATUS_INVALID_PARAMS);
+ 			goto failed;
+ 		}
+ 
+ 		p = kmalloc(sizeof(*p), GFP_KERNEL);
+ 		if (!p) {
+ 			err = -ENOMEM;
+ 			goto failed;
+ 		}
+ 
+ 		p->ad_type = cp->patterns[i].ad_type;
+ 		p->offset = cp->patterns[i].offset;
+ 		p->length = cp->patterns[i].length;
+ 		memcpy(p->value, cp->patterns[i].value, p->length);
+ 
+ 		INIT_LIST_HEAD(&p->list);
+ 		list_add(&p->list, &m->patterns);
+ 	}
+ 
+ 	if (mp_cnt != cp->pattern_count) {
+ 		err = mgmt_cmd_status(sk, hdev->id,
+ 				      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
+ 				      MGMT_STATUS_INVALID_PARAMS);
+ 		goto failed;
+ 	}
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	err = hci_add_adv_monitor(hdev, m);
+ 	if (err) {
+ 		if (err == -ENOSPC) {
+ 			mgmt_cmd_status(sk, hdev->id,
+ 					MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
+ 					MGMT_STATUS_NO_RESOURCES);
+ 		}
+ 		goto unlock;
+ 	}
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	rp.monitor_handle = cpu_to_le16(m->handle);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
+ 				 MGMT_STATUS_SUCCESS, &rp, sizeof(rp));
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ 
+ failed:
+ 	hci_free_adv_monitor(m);
+ 	return err;
+ }
+ 
  static void read_local_oob_data_complete(struct hci_dev *hdev, u8 status,
  				         u16 opcode, struct sk_buff *skb)
  {
@@@ -7101,6 -7568,27 +7212,30 @@@ static const struct hci_mgmt_handler mg
  	{ set_blocked_keys,	   MGMT_OP_SET_BLOCKED_KEYS_SIZE,
  						HCI_MGMT_VAR_LEN },
  	{ set_wideband_speech,	   MGMT_SETTING_SIZE },
++<<<<<<< HEAD
++=======
+ 	{ read_security_info,      MGMT_READ_SECURITY_INFO_SIZE,
+ 						HCI_MGMT_UNTRUSTED },
+ 	{ read_exp_features_info,  MGMT_READ_EXP_FEATURES_INFO_SIZE,
+ 						HCI_MGMT_UNTRUSTED |
+ 						HCI_MGMT_HDEV_OPTIONAL },
+ 	{ set_exp_feature,         MGMT_SET_EXP_FEATURE_SIZE,
+ 						HCI_MGMT_VAR_LEN |
+ 						HCI_MGMT_HDEV_OPTIONAL },
+ 	{ read_def_system_config,  MGMT_READ_DEF_SYSTEM_CONFIG_SIZE,
+ 						HCI_MGMT_UNTRUSTED },
+ 	{ set_def_system_config,   MGMT_SET_DEF_SYSTEM_CONFIG_SIZE,
+ 						HCI_MGMT_VAR_LEN },
+ 	{ read_def_runtime_config, MGMT_READ_DEF_RUNTIME_CONFIG_SIZE,
+ 						HCI_MGMT_UNTRUSTED },
+ 	{ set_def_runtime_config,  MGMT_SET_DEF_RUNTIME_CONFIG_SIZE,
+ 						HCI_MGMT_VAR_LEN },
+ 	{ get_device_flags,        MGMT_GET_DEVICE_FLAGS_SIZE },
+ 	{ set_device_flags,        MGMT_SET_DEVICE_FLAGS_SIZE },
+ 	{ read_adv_mon_features,   MGMT_READ_ADV_MONITOR_FEATURES_SIZE },
+ 	{ add_adv_patterns_monitor,MGMT_ADD_ADV_PATTERNS_MONITOR_SIZE,
+ 						HCI_MGMT_VAR_LEN },
++>>>>>>> b139553db5cd (Bluetooth: Add handler of MGMT_OP_ADD_ADV_PATTERNS_MONITOR)
  };
  
  void mgmt_index_added(struct hci_dev *hdev)
* Unmerged path include/net/bluetooth/hci_core.h
* Unmerged path net/bluetooth/hci_core.c
* Unmerged path net/bluetooth/mgmt.c
