trace/hwlat: Protect kdata->kthread with get/put_online_cpus

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Daniel Bristot de Oliveira <bristot@redhat.com>
commit 039a602db393c00665e7a3b968b15fb6fd7042b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/039a602d.failed

In preparation to the hotplug support, protect kdata->kthread
with get/put_online_cpus() to avoid concurrency with hotplug
operations.

Link: https://lore.kernel.org/linux-doc/20210621134636.5b332226@oasis.local.home/
Link: https://lkml.kernel.org/r/8bdb2a56f46abfd301d6fffbf43448380c09a6f5.1624372313.git.bristot@redhat.com

	Cc: Phil Auld <pauld@redhat.com>
	Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Cc: Kate Carcia <kcarcia@redhat.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Alexandre Chartre <alexandre.chartre@oracle.com>
	Cc: Clark Willaims <williams@redhat.com>
	Cc: John Kacur <jkacur@redhat.com>
	Cc: Juri Lelli <juri.lelli@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: x86@kernel.org
	Cc: linux-doc@vger.kernel.org
	Cc: linux-kernel@vger.kernel.org
	Suggested-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
	Signed-off-by: Daniel Bristot de Oliveira <bristot@redhat.com>
	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit 039a602db393c00665e7a3b968b15fb6fd7042b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace_hwlat.c
diff --cc kernel/trace/trace_hwlat.c
index 86a0e47cf098,20e31f79ebd9..000000000000
--- a/kernel/trace/trace_hwlat.c
+++ b/kernel/trace/trace_hwlat.c
@@@ -341,8 -387,33 +341,38 @@@ static int kthread_fn(void *data
  	return 0;
  }
  
++<<<<<<< HEAD
 +/**
 + * start_kthread - Kick off the hardware latency sampling/detector kthread
++=======
+ /*
+  * stop_stop_kthread - Inform the hardware latency sampling/detector kthread to stop
+  *
+  * This kicks the running hardware latency sampling/detector kernel thread and
+  * tells it to stop sampling now. Use this on unload and at system shutdown.
+  */
+ static void stop_single_kthread(void)
+ {
+ 	struct hwlat_kthread_data *kdata = get_cpu_data();
+ 	struct task_struct *kthread;
+ 
+ 	get_online_cpus();
+ 	kthread = kdata->kthread;
+ 
+ 	if (!kthread)
+ 		goto out_put_cpus;
+ 
+ 	kthread_stop(kthread);
+ 	kdata->kthread = NULL;
+ 
+ out_put_cpus:
+ 	put_online_cpus();
+ }
+ 
+ 
+ /*
+  * start_single_kthread - Kick off the hardware latency sampling/detector kthread
++>>>>>>> 039a602db393 (trace/hwlat: Protect kdata->kthread with get/put_online_cpus)
   *
   * This starts the kernel thread that will sit and sample the CPU timestamp
   * counter (TSC or similar) and look for potential hardware latencies.
@@@ -353,14 -425,9 +383,20 @@@ static int start_kthread(struct trace_a
  	struct task_struct *kthread;
  	int next_cpu;
  
++<<<<<<< HEAD
 +	if (WARN_ON(hwlat_kthread))
 +		return 0;
++=======
+ 	get_online_cpus();
+ 	if (kdata->kthread)
+ 		goto out_put_cpus;
++>>>>>>> 039a602db393 (trace/hwlat: Protect kdata->kthread with get/put_online_cpus)
 +
 +	/* Just pick the first CPU on first iteration */
 +	get_online_cpus();
 +	cpumask_and(current_mask, cpu_online_mask, tr->tracing_cpumask);
 +	put_online_cpus();
 +	next_cpu = cpumask_first(current_mask);
  
  	kthread = kthread_create(kthread_fn, NULL, "hwlatd");
  	if (IS_ERR(kthread)) {
@@@ -368,13 -436,23 +405,28 @@@
  		return -ENOMEM;
  	}
  
++<<<<<<< HEAD
 +	cpumask_clear(current_mask);
 +	cpumask_set_cpu(next_cpu, current_mask);
++=======
+ 	/* Just pick the first CPU on first iteration */
+ 	cpumask_and(current_mask, cpu_online_mask, tr->tracing_cpumask);
+ 
+ 	if (hwlat_data.thread_mode == MODE_ROUND_ROBIN) {
+ 		next_cpu = cpumask_first(current_mask);
+ 		cpumask_clear(current_mask);
+ 		cpumask_set_cpu(next_cpu, current_mask);
+ 
+ 	}
+ 
++>>>>>>> 039a602db393 (trace/hwlat: Protect kdata->kthread with get/put_online_cpus)
  	sched_setaffinity(kthread->pid, current_mask);
  
 -	kdata->kthread = kthread;
 +	hwlat_kthread = kthread;
  	wake_up_process(kthread);
  
+ out_put_cpus:
+ 	put_online_cpus();
  	return 0;
  }
  
* Unmerged path kernel/trace/trace_hwlat.c
