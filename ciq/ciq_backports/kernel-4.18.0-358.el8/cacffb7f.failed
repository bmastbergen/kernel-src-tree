iommu: Add an unmap_pages() op for IOMMU drivers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Isaac J. Manjarres <isaacm@codeaurora.org>
commit cacffb7f7b45ba7649eedea4c196c6e9f1863bf3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/cacffb7f.failed

Add a callback for IOMMU drivers to provide a path for the
IOMMU framework to call into an IOMMU driver, which can call
into the io-pgtable code, to unmap a virtually contiguous
range of pages of the same size.

For IOMMU drivers that do not specify an unmap_pages() callback,
the existing logic of unmapping memory one page block at a time
will be used.

	Signed-off-by: Isaac J. Manjarres <isaacm@codeaurora.org>
	Suggested-by: Will Deacon <will@kernel.org>
	Signed-off-by: Will Deacon <will@kernel.org>
	Acked-by: Lu Baolu <baolu.lu@linux.intel.com>
	Signed-off-by: Georgi Djakov <quic_c_gdjako@quicinc.com>
Link: https://lore.kernel.org/r/1623850736-389584-3-git-send-email-quic_c_gdjako@quicinc.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit cacffb7f7b45ba7649eedea4c196c6e9f1863bf3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/iommu.h
diff --cc include/linux/iommu.h
index 486407c90575,25a844121be5..000000000000
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@@ -274,29 -228,26 +275,39 @@@ struct iommu_ops 
  
  	int (*attach_dev)(struct iommu_domain *domain, struct device *dev);
  	void (*detach_dev)(struct iommu_domain *domain, struct device *dev);
++<<<<<<< HEAD
 +	RH_KABI_BROKEN_REPLACE(int (*map)(struct iommu_domain *domain, unsigned long iova,\
 +					  phys_addr_t paddr, size_t size, int prot),\
 +			       int (*map)(struct iommu_domain *domain, unsigned long iova,\
 +					  phys_addr_t paddr, size_t size, int prot, gfp_t gfp))
 +	RH_KABI_BROKEN_REPLACE(size_t (*unmap)(struct iommu_domain *domain, unsigned long iova,\
 +					       size_t size),size_t (*unmap)(struct iommu_domain *domain, unsigned long iova, \
 +									    size_t size, struct iommu_iotlb_gather *iotlb_gather))
++=======
+ 	int (*map)(struct iommu_domain *domain, unsigned long iova,
+ 		   phys_addr_t paddr, size_t size, int prot, gfp_t gfp);
+ 	size_t (*unmap)(struct iommu_domain *domain, unsigned long iova,
+ 		     size_t size, struct iommu_iotlb_gather *iotlb_gather);
+ 	size_t (*unmap_pages)(struct iommu_domain *domain, unsigned long iova,
+ 			      size_t pgsize, size_t pgcount,
+ 			      struct iommu_iotlb_gather *iotlb_gather);
++>>>>>>> cacffb7f7b45 (iommu: Add an unmap_pages() op for IOMMU drivers)
  	void (*flush_iotlb_all)(struct iommu_domain *domain);
 -	void (*iotlb_sync_map)(struct iommu_domain *domain, unsigned long iova,
 -			       size_t size);
 -	void (*iotlb_sync)(struct iommu_domain *domain,
 -			   struct iommu_iotlb_gather *iotlb_gather);
 +	RH_KABI_BROKEN_REPLACE(void (*iotlb_range_add)(struct iommu_domain *domain,\
 +						       unsigned long iova, size_t size), \
 +			       void (*iotlb_sync_map)(struct iommu_domain *domain, unsigned long iova,\
 +				       size_t size))
 +	RH_KABI_BROKEN_REPLACE(void (*iotlb_sync)(struct iommu_domain *domain),\
 +			       void (*iotlb_sync)(struct iommu_domain *domain, \
 +						  struct iommu_iotlb_gather *iotlb_gather))
  	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain, dma_addr_t iova);
 -	struct iommu_device *(*probe_device)(struct device *dev);
 -	void (*release_device)(struct device *dev);
 -	void (*probe_finalize)(struct device *dev);
 +	RH_KABI_BROKEN_REMOVE(int (*add_device)(struct device *dev))
 +	RH_KABI_BROKEN_REMOVE(void (*remove_device)(struct device *dev))
  	struct iommu_group *(*device_group)(struct device *dev);
 -	int (*enable_nesting)(struct iommu_domain *domain);
 -	int (*set_pgtable_quirks)(struct iommu_domain *domain,
 -				  unsigned long quirks);
 +	int (*domain_get_attr)(struct iommu_domain *domain,
 +			       enum iommu_attr attr, void *data);
 +	int (*domain_set_attr)(struct iommu_domain *domain,
 +			       enum iommu_attr attr, void *data);
  
  	/* Request/Free a list of reserved regions for a device */
  	void (*get_resv_regions)(struct device *dev, struct list_head *list);
* Unmerged path include/linux/iommu.h
