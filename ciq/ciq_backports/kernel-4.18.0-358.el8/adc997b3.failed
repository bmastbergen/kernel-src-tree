x86/fpu: Use copy_xstate_to_uabi_buf() in xfpregs_get()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit adc997b3d66d1cfa8c15a7dbafdaef239a51b5db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/adc997b3.failed

Use the new functionality of copy_xstate_to_uabi_buf() to retrieve the
FX state when XSAVE* is in use. This avoids overwriting the FPU state
buffer with fpstate_sanitize_xstate() which is error prone and duplicated
code.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20210623121452.901736860@linutronix.de
(cherry picked from commit adc997b3d66d1cfa8c15a7dbafdaef239a51b5db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/regset.c
diff --cc arch/x86/kernel/fpu/regset.c
index 7bcf779c46cb,ccbe25f6627d..000000000000
--- a/arch/x86/kernel/fpu/regset.c
+++ b/arch/x86/kernel/fpu/regset.c
@@@ -38,10 -37,14 +38,19 @@@ int xfpregs_get(struct task_struct *tar
  		return -ENODEV;
  
  	fpu__prepare_read(fpu);
- 	fpstate_sanitize_xstate(fpu);
  
++<<<<<<< HEAD
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				   &fpu->state.fxsave, 0, -1);
++=======
+ 	if (!use_xsave()) {
+ 		return membuf_write(&to, &fpu->state.fxsave,
+ 				    sizeof(fpu->state.fxsave));
+ 	}
+ 
+ 	copy_xstate_to_uabi_buf(to, &fpu->state.xsave, XSTATE_COPY_FX);
+ 	return 0;
++>>>>>>> adc997b3d66d (x86/fpu: Use copy_xstate_to_uabi_buf() in xfpregs_get())
  }
  
  int xfpregs_set(struct task_struct *target, const struct user_regset *regset,
* Unmerged path arch/x86/kernel/fpu/regset.c
