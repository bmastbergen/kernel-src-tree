iommu: remove DOMAIN_ATTR_GEOMETRY

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Christoph Hellwig <hch@lst.de>
commit bc9a05eef113e75cfa792fdf24dae011bc3d5294
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/bc9a05ee.failed

The geometry information can be trivially queried from the iommu_domain
struture.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Acked-by: Will Deacon <will@kernel.org>
	Acked-by: Li Yang <leoyang.li@nxp.com>
Link: https://lore.kernel.org/r/20210401155256.298656-16-hch@lst.de
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit bc9a05eef113e75cfa792fdf24dae011bc3d5294)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iommu.c
#	include/linux/iommu.h
diff --cc drivers/iommu/iommu.c
index 3393cee7f54d,703e67d8cb04..000000000000
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@@ -2678,28 -2667,9 +2678,34 @@@ core_initcall(iommu_init)
  int iommu_domain_get_attr(struct iommu_domain *domain,
  			  enum iommu_attr attr, void *data)
  {
++<<<<<<< HEAD
 +	struct iommu_domain_geometry *geometry;
 +	bool *paging;
 +	int ret = 0;
 +
 +	switch (attr) {
 +	case DOMAIN_ATTR_GEOMETRY:
 +		geometry  = data;
 +		*geometry = domain->geometry;
 +
 +		break;
 +	case DOMAIN_ATTR_PAGING:
 +		paging  = data;
 +		*paging = (domain->pgsize_bitmap != 0UL);
 +		break;
 +	default:
 +		if (!domain->ops->domain_get_attr)
 +			return -EINVAL;
 +
 +		ret = domain->ops->domain_get_attr(domain, attr, data);
 +	}
 +
 +	return ret;
++=======
+ 	if (!domain->ops->domain_get_attr)
+ 		return -EINVAL;
+ 	return domain->ops->domain_get_attr(domain, attr, data);
++>>>>>>> bc9a05eef113 (iommu: remove DOMAIN_ATTR_GEOMETRY)
  }
  EXPORT_SYMBOL_GPL(iommu_domain_get_attr);
  
diff --cc include/linux/iommu.h
index 486407c90575,207446cc6d3f..000000000000
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@@ -123,17 -107,9 +123,20 @@@ enum iommu_cap 
   */
  
  enum iommu_attr {
++<<<<<<< HEAD
 +	DOMAIN_ATTR_GEOMETRY,
 +	DOMAIN_ATTR_PAGING,
 +	DOMAIN_ATTR_WINDOWS,
 +	DOMAIN_ATTR_FSL_PAMU_STASH,
 +	DOMAIN_ATTR_FSL_PAMU_ENABLE,
 +	DOMAIN_ATTR_FSL_PAMUV1,
++=======
++>>>>>>> bc9a05eef113 (iommu: remove DOMAIN_ATTR_GEOMETRY)
  	DOMAIN_ATTR_NESTING,	/* two stages of translation */
  	DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE,
 +#ifndef __GENKSYMS__
  	DOMAIN_ATTR_IO_PGTABLE_CFG,
 +#endif
  	DOMAIN_ATTR_MAX,
  };
  
* Unmerged path drivers/iommu/iommu.c
diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c
index 5e6947aee901..0af2b74e93ff 100644
--- a/drivers/vfio/vfio_iommu_type1.c
+++ b/drivers/vfio/vfio_iommu_type1.c
@@ -2007,7 +2007,7 @@ static int vfio_iommu_type1_attach_group(void *iommu_data,
 	int ret;
 	bool resv_msi, msi_remap;
 	phys_addr_t resv_msi_base = 0;
-	struct iommu_domain_geometry geo;
+	struct iommu_domain_geometry *geo;
 	LIST_HEAD(iova_copy);
 	LIST_HEAD(group_resv_regions);
 
@@ -2098,10 +2098,9 @@ static int vfio_iommu_type1_attach_group(void *iommu_data,
 		goto out_domain;
 
 	/* Get aperture info */
-	iommu_domain_get_attr(domain->domain, DOMAIN_ATTR_GEOMETRY, &geo);
-
-	if (vfio_iommu_aper_conflict(iommu, geo.aperture_start,
-				     geo.aperture_end)) {
+	geo = &domain->domain->geometry;
+	if (vfio_iommu_aper_conflict(iommu, geo->aperture_start,
+				     geo->aperture_end)) {
 		ret = -EINVAL;
 		goto out_detach;
 	}
@@ -2124,8 +2123,8 @@ static int vfio_iommu_type1_attach_group(void *iommu_data,
 	if (ret)
 		goto out_detach;
 
-	ret = vfio_iommu_aper_resize(&iova_copy, geo.aperture_start,
-				     geo.aperture_end);
+	ret = vfio_iommu_aper_resize(&iova_copy, geo->aperture_start,
+				     geo->aperture_end);
 	if (ret)
 		goto out_detach;
 
@@ -2275,7 +2274,6 @@ static void vfio_iommu_aper_expand(struct vfio_iommu *iommu,
 				   struct list_head *iova_copy)
 {
 	struct vfio_domain *domain;
-	struct iommu_domain_geometry geo;
 	struct vfio_iova *node;
 	dma_addr_t start = 0;
 	dma_addr_t end = (dma_addr_t)~0;
@@ -2284,12 +2282,12 @@ static void vfio_iommu_aper_expand(struct vfio_iommu *iommu,
 		return;
 
 	list_for_each_entry(domain, &iommu->domain_list, next) {
-		iommu_domain_get_attr(domain->domain, DOMAIN_ATTR_GEOMETRY,
-				      &geo);
-		if (geo.aperture_start > start)
-			start = geo.aperture_start;
-		if (geo.aperture_end < end)
-			end = geo.aperture_end;
+		struct iommu_domain_geometry *geo = &domain->domain->geometry;
+
+		if (geo->aperture_start > start)
+			start = geo->aperture_start;
+		if (geo->aperture_end < end)
+			end = geo->aperture_end;
 	}
 
 	/* Modify aperture limits. The new aper is either same or bigger */
diff --git a/drivers/vhost/vdpa.c b/drivers/vhost/vdpa.c
index 1f712ea6cc94..3479fa2143b4 100644
--- a/drivers/vhost/vdpa.c
+++ b/drivers/vhost/vdpa.c
@@ -834,18 +834,14 @@ static void vhost_vdpa_free_domain(struct vhost_vdpa *v)
 static void vhost_vdpa_set_iova_range(struct vhost_vdpa *v)
 {
 	struct vdpa_iova_range *range = &v->range;
-	struct iommu_domain_geometry geo;
 	struct vdpa_device *vdpa = v->vdpa;
 	const struct vdpa_config_ops *ops = vdpa->config;
 
 	if (ops->get_iova_range) {
 		*range = ops->get_iova_range(vdpa);
-	} else if (v->domain &&
-		   !iommu_domain_get_attr(v->domain,
-		   DOMAIN_ATTR_GEOMETRY, &geo) &&
-		   geo.force_aperture) {
-		range->first = geo.aperture_start;
-		range->last = geo.aperture_end;
+	} else if (v->domain && v->domain->geometry.force_aperture) {
+		range->first = v->domain->geometry.aperture_start;
+		range->last = v->domain->geometry.aperture_end;
 	} else {
 		range->first = 0;
 		range->last = ULLONG_MAX;
* Unmerged path include/linux/iommu.h
