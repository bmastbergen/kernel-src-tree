Bluetooth: Query LE tx power on startup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Daniel Winkler <danielwinkler@google.com>
commit 7c395ea521e6c8d77f643be61bf2f0f3a1f5b3e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/7c395ea5.failed

Queries tx power via HCI_LE_Read_Transmit_Power command when the hci
device is initialized, and stores resulting min/max LE power in hdev
struct. If command isn't available (< BT5 support), min/max values
both default to HCI_TX_POWER_INVALID.

This patch is manually verified by ensuring BT5 devices correctly query
and receive controller tx power range.

	Reviewed-by: Sonny Sasaka <sonnysasaka@chromium.org>
	Signed-off-by: Daniel Winkler <danielwinkler@google.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
	Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
(cherry picked from commit 7c395ea521e6c8d77f643be61bf2f0f3a1f5b3e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/bluetooth/hci_core.h
#	net/bluetooth/hci_core.c
diff --cc include/net/bluetooth/hci_core.h
index 87a79e4f1ac5,677a8c50b2ad..000000000000
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@@ -360,6 -383,9 +360,12 @@@ struct hci_dev 
  	__u16		def_br_lsto;
  	__u16		def_page_timeout;
  	__u16		def_multi_adv_rotation_duration;
++<<<<<<< HEAD
++=======
+ 	__u16		def_le_autoconnect_timeout;
+ 	__s8		min_le_tx_power;
+ 	__s8		max_le_tx_power;
++>>>>>>> 7c395ea521e6 (Bluetooth: Query LE tx power on startup)
  
  	__u16		pkt_type;
  	__u16		esco_type;
diff --cc net/bluetooth/hci_core.c
index 0693dacbf6e3,9d2c9a1c552f..000000000000
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@@ -3498,6 -3665,9 +3504,12 @@@ struct hci_dev *hci_alloc_dev(void
  	hdev->le_rx_def_phys = HCI_LE_SET_PHY_1M;
  	hdev->le_num_of_adv_sets = HCI_MAX_ADV_INSTANCES;
  	hdev->def_multi_adv_rotation_duration = HCI_DEFAULT_ADV_DURATION;
++<<<<<<< HEAD
++=======
+ 	hdev->def_le_autoconnect_timeout = HCI_LE_AUTOCONN_TIMEOUT;
+ 	hdev->min_le_tx_power = HCI_TX_POWER_INVALID;
+ 	hdev->max_le_tx_power = HCI_TX_POWER_INVALID;
++>>>>>>> 7c395ea521e6 (Bluetooth: Query LE tx power on startup)
  
  	hdev->rpa_timeout = HCI_DEFAULT_RPA_TIMEOUT;
  	hdev->discov_interleaved_timeout = DISCOV_INTERLEAVED_TIMEOUT;
diff --git a/include/net/bluetooth/hci.h b/include/net/bluetooth/hci.h
index 22de35264e4b..d4bd53aa6069 100644
--- a/include/net/bluetooth/hci.h
+++ b/include/net/bluetooth/hci.h
@@ -1793,6 +1793,13 @@ struct hci_cp_le_set_adv_set_rand_addr {
 	bdaddr_t  bdaddr;
 } __packed;
 
+#define HCI_OP_LE_READ_TRANSMIT_POWER	0x204b
+struct hci_rp_le_read_transmit_power {
+	__u8  status;
+	__s8  min_le_tx_power;
+	__s8  max_le_tx_power;
+} __packed;
+
 #define HCI_OP_LE_READ_BUFFER_SIZE_V2	0x2060
 struct hci_rp_le_read_buffer_size_v2 {
 	__u8    status;
* Unmerged path include/net/bluetooth/hci_core.h
* Unmerged path net/bluetooth/hci_core.c
diff --git a/net/bluetooth/hci_event.c b/net/bluetooth/hci_event.c
index 4c50fa2de0a1..66144cef0c82 100644
--- a/net/bluetooth/hci_event.c
+++ b/net/bluetooth/hci_event.c
@@ -1202,6 +1202,20 @@ static void hci_cc_le_set_adv_set_random_addr(struct hci_dev *hdev,
 	hci_dev_unlock(hdev);
 }
 
+static void hci_cc_le_read_transmit_power(struct hci_dev *hdev,
+					  struct sk_buff *skb)
+{
+	struct hci_rp_le_read_transmit_power *rp = (void *)skb->data;
+
+	BT_DBG("%s status 0x%2.2x", hdev->name, rp->status);
+
+	if (rp->status)
+		return;
+
+	hdev->min_le_tx_power = rp->min_le_tx_power;
+	hdev->max_le_tx_power = rp->max_le_tx_power;
+}
+
 static void hci_cc_le_set_adv_enable(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	__u8 *sent, status = *((__u8 *) skb->data);
@@ -3585,6 +3599,10 @@ static void hci_cmd_complete_evt(struct hci_dev *hdev, struct sk_buff *skb,
 		hci_cc_le_set_adv_set_random_addr(hdev, skb);
 		break;
 
+	case HCI_OP_LE_READ_TRANSMIT_POWER:
+		hci_cc_le_read_transmit_power(hdev, skb);
+		break;
+
 	default:
 		BT_DBG("%s opcode 0x%4.4x", hdev->name, *opcode);
 		break;
