x86/fpu: Use copy_xstate_to_uabi_buf() in fpregs_get()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 3f7f75634ccefefcc929696f346db7a748e78f79
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/3f7f7563.failed

Use the new functionality of copy_xstate_to_uabi_buf() to retrieve the
FX state when XSAVE* is in use. This avoids to overwrite the FPU state
buffer with fpstate_sanitize_xstate() which is error prone and duplicated
code.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20210623121453.014441775@linutronix.de
(cherry picked from commit 3f7f75634ccefefcc929696f346db7a748e78f79)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/regset.c
diff --cc arch/x86/kernel/fpu/regset.c
index 7bcf779c46cb,4b799e42ebc7..000000000000
--- a/arch/x86/kernel/fpu/regset.c
+++ b/arch/x86/kernel/fpu/regset.c
@@@ -303,24 -289,26 +310,47 @@@ int fpregs_get(struct task_struct *targ
  
  	fpu__prepare_read(fpu);
  
++<<<<<<< HEAD
 +	if (!boot_cpu_has(X86_FEATURE_FPU))
 +		return fpregs_soft_get(target, regset, pos, count, kbuf, ubuf);
 +
 +	if (!boot_cpu_has(X86_FEATURE_FXSR))
 +		return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +					   &fpu->state.fsave, 0,
 +					   -1);
++=======
+ 	if (!cpu_feature_enabled(X86_FEATURE_FPU))
+ 		return fpregs_soft_get(target, regset, to);
  
- 	fpstate_sanitize_xstate(fpu);
+ 	if (!cpu_feature_enabled(X86_FEATURE_FXSR)) {
+ 		return membuf_write(&to, &fpu->state.fsave,
+ 				    sizeof(struct fregs_state));
+ 	}
++>>>>>>> 3f7f75634cce (x86/fpu: Use copy_xstate_to_uabi_buf() in fpregs_get())
+ 
+ 	if (use_xsave()) {
+ 		struct membuf mb = { .p = &fxsave, .left = sizeof(fxsave) };
  
++<<<<<<< HEAD
 +	if (kbuf && pos == 0 && count == sizeof(env)) {
 +		convert_from_fxsr(kbuf, target);
 +		return 0;
 +	}
 +
 +	convert_from_fxsr(&env, target);
 +
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf, &env, 0, -1);
++=======
+ 		/* Handle init state optimized xstate correctly */
+ 		copy_xstate_to_uabi_buf(mb, &fpu->state.xsave, XSTATE_COPY_FP);
+ 		fx = &fxsave;
+ 	} else {
+ 		fx = &fpu->state.fxsave;
+ 	}
+ 
+ 	__convert_from_fxsr(&env, target, fx);
+ 	return membuf_write(&to, &env, sizeof(env));
++>>>>>>> 3f7f75634cce (x86/fpu: Use copy_xstate_to_uabi_buf() in fpregs_get())
  }
  
  int fpregs_set(struct task_struct *target, const struct user_regset *regset,
* Unmerged path arch/x86/kernel/fpu/regset.c
