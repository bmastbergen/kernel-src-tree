x86/fpu: Rename copy_kernel_to_fpregs() to restore_fpregs_from_fpstate()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 1c61fada304c125c3f8a2b8eb1896406e4098a05
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/1c61fada.failed

This is not a copy functionality. It restores the register state from the
supplied kernel buffer.

No functional changes.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20210623121454.716058365@linutronix.de
(cherry picked from commit 1c61fada304c125c3f8a2b8eb1896406e4098a05)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/fpu/internal.h
diff --cc arch/x86/include/asm/fpu/internal.h
index 5a42546d89cb,3558cd05c62f..000000000000
--- a/arch/x86/include/asm/fpu/internal.h
+++ b/arch/x86/include/asm/fpu/internal.h
@@@ -377,15 -376,13 +377,19 @@@ static inline int copy_kernel_to_xregs_
  	return err;
  }
  
++<<<<<<< HEAD
 +extern int save_fpregs_to_fpstate(struct fpu *fpu);
 +
 +static inline void __copy_kernel_to_fpregs(union fpregs_state *fpstate, u64 mask)
++=======
+ static inline void __restore_fpregs_from_fpstate(union fpregs_state *fpstate, u64 mask)
++>>>>>>> 1c61fada304c (x86/fpu: Rename copy_kernel_to_fpregs() to restore_fpregs_from_fpstate())
  {
  	if (use_xsave()) {
 -		os_xrstor(&fpstate->xsave, mask);
 +		copy_kernel_to_xregs(&fpstate->xsave, mask);
  	} else {
  		if (use_fxsr())
 -			fxrstor(&fpstate->fxsave);
 +			copy_kernel_to_fxregs(&fpstate->fxsave);
  		else
  			frstor(&fpstate->fsave);
  	}
* Unmerged path arch/x86/include/asm/fpu/internal.h
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index f11d38cc6d91..ace7615dd7df 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -9604,7 +9604,7 @@ static void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)
 	 */
 	if (vcpu->arch.guest_fpu)
 		/* PKRU is separately restored in kvm_x86_ops.run. */
-		__copy_kernel_to_fpregs(&vcpu->arch.guest_fpu->state,
+		__restore_fpregs_from_fpstate(&vcpu->arch.guest_fpu->state,
 					~XFEATURE_MASK_PKRU);
 
 	fpregs_mark_activate();
@@ -9625,7 +9625,7 @@ static void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)
 	if (vcpu->arch.guest_fpu)
 		kvm_save_current_fpu(vcpu->arch.guest_fpu);
 
-	copy_kernel_to_fpregs(&vcpu->arch.user_fpu->state);
+	restore_fpregs_from_fpstate(&vcpu->arch.user_fpu->state);
 
 	fpregs_mark_activate();
 	fpregs_unlock();
diff --git a/arch/x86/mm/extable.c b/arch/x86/mm/extable.c
index 034f9e2c889e..2804268d3398 100644
--- a/arch/x86/mm/extable.c
+++ b/arch/x86/mm/extable.c
@@ -104,7 +104,7 @@ __visible bool ex_handler_fprestore(const struct exception_table_entry *fixup,
 	WARN_ONCE(1, "Bad FPU state detected at %pB, reinitializing FPU registers.",
 		  (void *)instruction_pointer(regs));
 
-	__copy_kernel_to_fpregs(&init_fpstate, -1);
+	__restore_fpregs_from_fpstate(&init_fpstate, -1);
 	return true;
 }
 EXPORT_SYMBOL_GPL(ex_handler_fprestore);
