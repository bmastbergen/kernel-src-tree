mm: VM_BUG_ON lru page flags

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Yu Zhao <yuzhao@google.com>
commit bc7112719e1e80e4208eef3fc9bd8d2b6c263e7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/bc711271.failed

Move scattered VM_BUG_ONs to two essential places that cover all
lru list additions and deletions.

Link: https://lore.kernel.org/linux-mm/20201207220949.830352-8-yuzhao@google.com/
Link: https://lkml.kernel.org/r/20210122220600.906146-8-yuzhao@google.com
	Signed-off-by: Yu Zhao <yuzhao@google.com>
	Cc: Alex Shi <alex.shi@linux.alibaba.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Roman Gushchin <guro@fb.com>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit bc7112719e1e80e4208eef3fc9bd8d2b6c263e7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mm_inline.h
#	mm/swap.c
#	mm/vmscan.c
diff --cc include/linux/mm_inline.h
index b714bf7a0dfe,6d907a4dd6ad..000000000000
--- a/include/linux/mm_inline.h
+++ b/include/linux/mm_inline.h
@@@ -82,27 -61,21 +82,33 @@@ static inline enum lru_list page_lru_ba
  }
  
  /**
 - * __clear_page_lru_flags - clear page lru flags before releasing a page
 - * @page: the page that was on lru and now has a zero reference
 + * page_off_lru - which LRU list was page on? clearing its lru flags.
 + * @page: the page to test
 + *
 + * Returns the LRU list a page was on, as an index into the array of LRU
 + * lists; and clears its Unevictable or Active flags, ready for freeing.
   */
 -static __always_inline void __clear_page_lru_flags(struct page *page)
 +static __always_inline enum lru_list page_off_lru(struct page *page)
  {
++<<<<<<< HEAD
 +	enum lru_list lru;
++=======
+ 	VM_BUG_ON_PAGE(!PageLRU(page), page);
+ 
+ 	__ClearPageLRU(page);
++>>>>>>> bc7112719e1e (mm: VM_BUG_ON lru page flags)
  
 -	/* this shouldn't happen, so leave the flags to bad_page() */
 -	if (PageActive(page) && PageUnevictable(page))
 -		return;
 -
 -	__ClearPageActive(page);
 -	__ClearPageUnevictable(page);
 +	if (PageUnevictable(page)) {
 +		__ClearPageUnevictable(page);
 +		lru = LRU_UNEVICTABLE;
 +	} else {
 +		lru = page_lru_base_type(page);
 +		if (PageActive(page)) {
 +			__ClearPageActive(page);
 +			lru += LRU_ACTIVE;
 +		}
 +	}
 +	return lru;
  }
  
  /**
diff --cc mm/swap.c
index 78fee54efe0c,ab3258afcbeb..000000000000
--- a/mm/swap.c
+++ b/mm/swap.c
@@@ -82,9 -83,8 +82,14 @@@ static void __page_cache_release(struc
  		unsigned long flags;
  
  		lruvec = lock_page_lruvec_irqsave(page, &flags);
++<<<<<<< HEAD
 +		VM_BUG_ON_PAGE(!PageLRU(page), page);
 +		__ClearPageLRU(page);
 +		del_page_from_lru_list(page, lruvec, page_off_lru(page));
++=======
+ 		del_page_from_lru_list(page, lruvec);
+ 		__clear_page_lru_flags(page);
++>>>>>>> bc7112719e1e (mm: VM_BUG_ON lru page flags)
  		unlock_page_lruvec_irqrestore(lruvec, flags);
  	}
  	__ClearPageWaiters(page);
@@@ -855,9 -908,8 +860,14 @@@ void release_pages(struct page **pages
  			if (prev_lruvec != lruvec)
  				lock_batch = 0;
  
++<<<<<<< HEAD
 +			VM_BUG_ON_PAGE(!PageLRU(page), page);
 +			__ClearPageLRU(page);
 +			del_page_from_lru_list(page, lruvec, page_off_lru(page));
++=======
+ 			del_page_from_lru_list(page, lruvec);
+ 			__clear_page_lru_flags(page);
++>>>>>>> bc7112719e1e (mm: VM_BUG_ON lru page flags)
  		}
  
  		__ClearPageWaiters(page);
diff --cc mm/vmscan.c
index 622f69d66ebc,348a90096550..000000000000
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@@ -4294,12 -4281,9 +4294,16 @@@ void check_move_unevictable_pages(struc
  
  		lruvec = relock_page_lruvec_irq(page, lruvec);
  		if (page_evictable(page) && PageUnevictable(page)) {
++<<<<<<< HEAD
 +			enum lru_list lru = page_lru_base_type(page);
 +
 +			VM_BUG_ON_PAGE(PageActive(page), page);
++=======
+ 			del_page_from_lru_list(page, lruvec);
++>>>>>>> bc7112719e1e (mm: VM_BUG_ON lru page flags)
  			ClearPageUnevictable(page);
 -			add_page_to_lru_list(page, lruvec);
 +			del_page_from_lru_list(page, lruvec, LRU_UNEVICTABLE);
 +			add_page_to_lru_list(page, lruvec, lru);
  			pgrescued += nr_pages;
  		}
  		SetPageLRU(page);
* Unmerged path include/linux/mm_inline.h
* Unmerged path mm/swap.c
* Unmerged path mm/vmscan.c
