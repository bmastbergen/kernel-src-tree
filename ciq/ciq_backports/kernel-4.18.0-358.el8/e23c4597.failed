arch/kunmap: remove duplicate kunmap implementations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Ira Weiny <ira.weiny@intel.com>
commit e23c45976f82ac789469c37e4d5a72ea2ce30bba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/e23c4597.failed

All architectures do exactly the same thing for kunmap(); remove all the
duplicate definitions and lift the call to the core.

This also has the benefit of changing kmap_unmap() on a number of
architectures to be an inline call rather than an actual function.

[akpm@linux-foundation.org: fix CONFIG_HIGHMEM=n build on various architectures]
	Signed-off-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Christian KÃ¶nig <christian.koenig@amd.com>
	Cc: Chris Zankel <chris@zankel.net>
	Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Helge Deller <deller@gmx.de>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: "James E.J. Bottomley" <James.Bottomley@HansenPartnership.com>
	Cc: Max Filippov <jcmvbkbc@gmail.com>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/20200507150004.1423069-5-ira.weiny@intel.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e23c45976f82ac789469c37e4d5a72ea2ce30bba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arc/include/asm/highmem.h
#	arch/arm/include/asm/highmem.h
#	arch/arm/mm/highmem.c
#	arch/csky/include/asm/highmem.h
#	arch/csky/mm/highmem.c
#	arch/microblaze/include/asm/highmem.h
#	arch/mips/include/asm/highmem.h
#	arch/mips/mm/highmem.c
#	arch/nds32/include/asm/highmem.h
#	arch/nds32/mm/highmem.c
#	arch/powerpc/include/asm/highmem.h
#	arch/sparc/include/asm/highmem.h
#	arch/x86/include/asm/highmem.h
#	arch/x86/mm/highmem_32.c
#	arch/xtensa/include/asm/highmem.h
#	include/linux/highmem.h
diff --cc arch/arc/include/asm/highmem.h
index b1585c96324a,8387a5596a91..000000000000
--- a/arch/arc/include/asm/highmem.h
+++ b/arch/arc/include/asm/highmem.h
@@@ -34,11 -30,8 +34,10 @@@
  
  #include <asm/cacheflush.h>
  
 +extern void *kmap(struct page *page);
 +extern void *kmap_high(struct page *page);
  extern void *kmap_atomic(struct page *page);
  extern void __kunmap_atomic(void *kvaddr);
- extern void kunmap_high(struct page *page);
  
  extern void kmap_init(void);
  
@@@ -47,15 -40,6 +46,18 @@@ static inline void flush_cache_kmaps(vo
  	flush_cache_all();
  }
  
++<<<<<<< HEAD
 +static inline void kunmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +
 +
++=======
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  #endif
  
  #endif
diff --cc arch/arm/include/asm/highmem.h
index eb4e4207cd3c,736f65283e7b..000000000000
--- a/arch/arm/include/asm/highmem.h
+++ b/arch/arm/include/asm/highmem.h
@@@ -20,9 -20,6 +20,12 @@@
  
  extern pte_t *pkmap_page_table;
  
++<<<<<<< HEAD
 +extern void *kmap_high(struct page *page);
 +extern void kunmap_high(struct page *page);
 +
++=======
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  /*
   * The reason for kmap_high_get() is to ensure that the currently kmap'd
   * page usage count does not decrease to zero while we're using its
@@@ -63,8 -60,6 +66,11 @@@ static inline void *kmap_high_get(struc
   * when CONFIG_HIGHMEM is not set.
   */
  #ifdef CONFIG_HIGHMEM
++<<<<<<< HEAD
 +extern void *kmap(struct page *page);
 +extern void kunmap(struct page *page);
++=======
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  extern void *kmap_atomic(struct page *page);
  extern void __kunmap_atomic(void *kvaddr);
  extern void *kmap_atomic_pfn(unsigned long pfn);
diff --cc arch/arm/mm/highmem.c
index d02f8187b1cc,c700b32350ee..000000000000
--- a/arch/arm/mm/highmem.c
+++ b/arch/arm/mm/highmem.c
@@@ -34,24 -31,6 +34,27 @@@ static inline pte_t get_fixmap_pte(unsi
  	return *ptep;
  }
  
++<<<<<<< HEAD
 +void *kmap(struct page *page)
 +{
 +	might_sleep();
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	return kmap_high(page);
 +}
 +EXPORT_SYMBOL(kmap);
 +
 +void kunmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +EXPORT_SYMBOL(kunmap);
 +
++=======
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  void *kmap_atomic(struct page *page)
  {
  	unsigned int idx;
diff --cc arch/microblaze/include/asm/highmem.h
index 332c78e15198,0c94046f2d58..000000000000
--- a/arch/microblaze/include/asm/highmem.h
+++ b/arch/microblaze/include/asm/highmem.h
@@@ -51,27 -51,9 +51,33 @@@ extern pte_t *pkmap_page_table
  #define PKMAP_NR(virt)  ((virt - PKMAP_BASE) >> PAGE_SHIFT)
  #define PKMAP_ADDR(nr)  (PKMAP_BASE + ((nr) << PAGE_SHIFT))
  
++<<<<<<< HEAD
 +extern void *kmap_high(struct page *page);
 +extern void kunmap_high(struct page *page);
  extern void *kmap_atomic_prot(struct page *page, pgprot_t prot);
  extern void __kunmap_atomic(void *kvaddr);
  
 +static inline void *kmap(struct page *page)
 +{
 +	might_sleep();
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	return kmap_high(page);
 +}
 +
 +static inline void kunmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +
++=======
++extern void *kmap_atomic_prot(struct page *page, pgprot_t prot);
++extern void __kunmap_atomic(void *kvaddr);
++
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  static inline void *kmap_atomic(struct page *page)
  {
  	return kmap_atomic_prot(page, kmap_prot);
diff --cc arch/mips/include/asm/highmem.h
index 9d84aafc33d0,24e7e7e5cc7b..000000000000
--- a/arch/mips/include/asm/highmem.h
+++ b/arch/mips/include/asm/highmem.h
@@@ -46,11 -46,8 +46,16 @@@ extern pte_t *pkmap_page_table
  #define PKMAP_NR(virt)	((virt-PKMAP_BASE) >> PAGE_SHIFT)
  #define PKMAP_ADDR(nr)	(PKMAP_BASE + ((nr) << PAGE_SHIFT))
  
++<<<<<<< HEAD
 +extern void * kmap_high(struct page *page);
 +extern void kunmap_high(struct page *page);
 +
 +extern void *kmap(struct page *page);
 +extern void kunmap(struct page *page);
++=======
+ #define ARCH_HAS_KMAP_FLUSH_TLB
+ extern void kmap_flush_tlb(unsigned long addr);
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  extern void *kmap_atomic(struct page *page);
  extern void __kunmap_atomic(void *kvaddr);
  extern void *kmap_atomic_pfn(unsigned long pfn);
diff --cc arch/mips/mm/highmem.c
index d08e6d7d533b,eb8ec8493f2f..000000000000
--- a/arch/mips/mm/highmem.c
+++ b/arch/mips/mm/highmem.c
@@@ -12,29 -12,12 +12,32 @@@ static pte_t *kmap_pte
  
  unsigned long highstart_pfn, highend_pfn;
  
 -void kmap_flush_tlb(unsigned long addr)
 +void *kmap(struct page *page)
  {
 -	flush_tlb_one(addr);
 +	void *addr;
 +
 +	might_sleep();
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	addr = kmap_high(page);
 +	flush_tlb_one((unsigned long)addr);
 +
 +	return addr;
 +}
 +EXPORT_SYMBOL(kmap);
 +
++<<<<<<< HEAD
 +void kunmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
  }
 -EXPORT_SYMBOL(kmap_flush_tlb);
 +EXPORT_SYMBOL(kunmap);
  
++=======
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  /*
   * kmap_atomic/kunmap_atomic is significantly faster than kmap/kunmap because
   * no global lock is needed and because the kmap code must perform a global TLB
diff --cc arch/nds32/include/asm/highmem.h
index 425d546cb059,c93c7368bb3f..000000000000
--- a/arch/nds32/include/asm/highmem.h
+++ b/arch/nds32/include/asm/highmem.h
@@@ -44,9 -44,6 +44,12 @@@ extern unsigned long highstart_pfn, hig
  
  extern pte_t *pkmap_page_table;
  
++<<<<<<< HEAD
 +extern void *kmap_high(struct page *page);
 +extern void kunmap_high(struct page *page);
 +
++=======
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  extern void kmap_init(void);
  
  /*
@@@ -54,8 -51,6 +57,11 @@@
   * when CONFIG_HIGHMEM is not set.
   */
  #ifdef CONFIG_HIGHMEM
++<<<<<<< HEAD
 +extern void *kmap(struct page *page);
 +extern void kunmap(struct page *page);
++=======
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  extern void *kmap_atomic(struct page *page);
  extern void __kunmap_atomic(void *kvaddr);
  extern void *kmap_atomic_pfn(unsigned long pfn);
diff --cc arch/nds32/mm/highmem.c
index 022779af6148,f9348bec0ecb..000000000000
--- a/arch/nds32/mm/highmem.c
+++ b/arch/nds32/mm/highmem.c
@@@ -10,28 -10,6 +10,31 @@@
  #include <asm/fixmap.h>
  #include <asm/tlbflush.h>
  
++<<<<<<< HEAD
 +void *kmap(struct page *page)
 +{
 +	unsigned long vaddr;
 +	might_sleep();
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	vaddr = (unsigned long)kmap_high(page);
 +	return (void *)vaddr;
 +}
 +
 +EXPORT_SYMBOL(kmap);
 +
 +void kunmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +
 +EXPORT_SYMBOL(kunmap);
 +
++=======
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  void *kmap_atomic(struct page *page)
  {
  	unsigned int idx;
diff --cc arch/powerpc/include/asm/highmem.h
index cec820f961da,ba3371977d49..000000000000
--- a/arch/powerpc/include/asm/highmem.h
+++ b/arch/powerpc/include/asm/highmem.h
@@@ -59,27 -59,9 +59,33 @@@ extern pte_t *pkmap_page_table
  #define PKMAP_NR(virt)  ((virt-PKMAP_BASE) >> PAGE_SHIFT)
  #define PKMAP_ADDR(nr)  (PKMAP_BASE + ((nr) << PAGE_SHIFT))
  
++<<<<<<< HEAD
 +extern void *kmap_high(struct page *page);
 +extern void kunmap_high(struct page *page);
  extern void *kmap_atomic_prot(struct page *page, pgprot_t prot);
  extern void __kunmap_atomic(void *kvaddr);
  
 +static inline void *kmap(struct page *page)
 +{
 +	might_sleep();
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	return kmap_high(page);
 +}
 +
 +static inline void kunmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +
++=======
++extern void *kmap_atomic_prot(struct page *page, pgprot_t prot);
++extern void __kunmap_atomic(void *kvaddr);
++
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  static inline void *kmap_atomic(struct page *page)
  {
  	return kmap_atomic_prot(page, kmap_prot);
diff --cc arch/sparc/include/asm/highmem.h
index 18d776925c45,4bdb79fed02c..000000000000
--- a/arch/sparc/include/asm/highmem.h
+++ b/arch/sparc/include/asm/highmem.h
@@@ -50,25 -50,6 +50,28 @@@ void kmap_init(void) __init
  
  #define PKMAP_END (PKMAP_ADDR(LAST_PKMAP))
  
++<<<<<<< HEAD
 +void *kmap_high(struct page *page);
 +void kunmap_high(struct page *page);
 +
 +static inline void *kmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	return kmap_high(page);
 +}
 +
 +static inline void kunmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +
++=======
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  void *kmap_atomic(struct page *page);
  void __kunmap_atomic(void *kvaddr);
  
diff --cc arch/x86/include/asm/highmem.h
index a8059930056d,90b96594d6c5..000000000000
--- a/arch/x86/include/asm/highmem.h
+++ b/arch/x86/include/asm/highmem.h
@@@ -58,12 -58,6 +58,15 @@@ extern unsigned long highstart_pfn, hig
  #define PKMAP_NR(virt)  ((virt-PKMAP_BASE) >> PAGE_SHIFT)
  #define PKMAP_ADDR(nr)  (PKMAP_BASE + ((nr) << PAGE_SHIFT))
  
++<<<<<<< HEAD
 +extern void *kmap_high(struct page *page);
 +extern void kunmap_high(struct page *page);
 +
 +void *kmap(struct page *page);
 +void kunmap(struct page *page);
 +
++=======
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  void *kmap_atomic_prot(struct page *page, pgprot_t prot);
  void *kmap_atomic(struct page *page);
  void __kunmap_atomic(void *kvaddr);
diff --cc arch/x86/mm/highmem_32.c
index 0d4bdcb84da5,c4ebfd0ae401..000000000000
--- a/arch/x86/mm/highmem_32.c
+++ b/arch/x86/mm/highmem_32.c
@@@ -3,25 -4,6 +3,28 @@@
  #include <linux/swap.h> /* for totalram_pages */
  #include <linux/memblock.h>
  
++<<<<<<< HEAD
 +void *kmap(struct page *page)
 +{
 +	might_sleep();
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	return kmap_high(page);
 +}
 +EXPORT_SYMBOL(kmap);
 +
 +void kunmap(struct page *page)
 +{
 +	if (in_interrupt())
 +		BUG();
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +EXPORT_SYMBOL(kunmap);
 +
++=======
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  /*
   * kmap_atomic/kunmap_atomic is significantly faster than kmap/kunmap because
   * no global lock is needed and because the kmap code must perform a global TLB
diff --cc arch/xtensa/include/asm/highmem.h
index 04e9340eac4b,5a481f7def0b..000000000000
--- a/arch/xtensa/include/asm/highmem.h
+++ b/arch/xtensa/include/asm/highmem.h
@@@ -63,30 -63,6 +63,33 @@@ static inline wait_queue_head_t *get_pk
  
  extern pte_t *pkmap_page_table;
  
++<<<<<<< HEAD
 +void *kmap_high(struct page *page);
 +void kunmap_high(struct page *page);
 +
 +static inline void *kmap(struct page *page)
 +{
 +	/* Check if this memory layout is broken because PKMAP overlaps
 +	 * page table.
 +	 */
 +	BUILD_BUG_ON(PKMAP_BASE <
 +		     TLBTEMP_BASE_1 + TLBTEMP_SIZE);
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	return kmap_high(page);
 +}
 +
 +static inline void kunmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +
++=======
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  static inline void flush_cache_kmaps(void)
  {
  	flush_cache_all();
diff --cc include/linux/highmem.h
index ea5cdbd8c2c3,216a647ed7db..000000000000
--- a/include/linux/highmem.h
+++ b/include/linux/highmem.h
@@@ -34,6 -34,34 +34,37 @@@ static inline void invalidate_kernel_vm
  #ifdef CONFIG_HIGHMEM
  #include <asm/highmem.h>
  
++<<<<<<< HEAD
++=======
+ #ifndef ARCH_HAS_KMAP_FLUSH_TLB
+ static inline void kmap_flush_tlb(unsigned long addr) { }
+ #endif
+ 
+ void *kmap_high(struct page *page);
+ static inline void *kmap(struct page *page)
+ {
+ 	void *addr;
+ 
+ 	might_sleep();
+ 	if (!PageHighMem(page))
+ 		addr = page_address(page);
+ 	else
+ 		addr = kmap_high(page);
+ 	kmap_flush_tlb((unsigned long)addr);
+ 	return addr;
+ }
+ 
+ void kunmap_high(struct page *page);
+ 
+ static inline void kunmap(struct page *page)
+ {
+ 	might_sleep();
+ 	if (!PageHighMem(page))
+ 		return;
+ 	kunmap_high(page);
+ }
+ 
++>>>>>>> e23c45976f82 (arch/kunmap: remove duplicate kunmap implementations)
  /* declarations for linux/mm/highmem.c */
  unsigned int nr_free_highpages(void);
  extern atomic_long_t _totalhigh_pages;
* Unmerged path arch/csky/include/asm/highmem.h
* Unmerged path arch/csky/mm/highmem.c
* Unmerged path arch/arc/include/asm/highmem.h
* Unmerged path arch/arm/include/asm/highmem.h
* Unmerged path arch/arm/mm/highmem.c
* Unmerged path arch/csky/include/asm/highmem.h
* Unmerged path arch/csky/mm/highmem.c
* Unmerged path arch/microblaze/include/asm/highmem.h
* Unmerged path arch/mips/include/asm/highmem.h
* Unmerged path arch/mips/mm/highmem.c
* Unmerged path arch/nds32/include/asm/highmem.h
* Unmerged path arch/nds32/mm/highmem.c
* Unmerged path arch/powerpc/include/asm/highmem.h
* Unmerged path arch/sparc/include/asm/highmem.h
* Unmerged path arch/x86/include/asm/highmem.h
* Unmerged path arch/x86/mm/highmem_32.c
* Unmerged path arch/xtensa/include/asm/highmem.h
* Unmerged path include/linux/highmem.h
