net: switchdev: pass flags and mask to both {PRE_,}BRIDGE_FLAGS attributes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Vladimir Oltean <vladimir.oltean@nxp.com>
commit e18f4c18ab5b0dd47caaf8377c2e36d66f632a8c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/e18f4c18.failed

This switchdev attribute offers a counterproductive API for a driver
writer, because although br_switchdev_set_port_flag gets passed a
"flags" and a "mask", those are passed piecemeal to the driver, so while
the PRE_BRIDGE_FLAGS listener knows what changed because it has the
"mask", the BRIDGE_FLAGS listener doesn't, because it only has the final
value. But certain drivers can offload only certain combinations of
settings, like for example they cannot change unicast flooding
independently of multicast flooding - they must be both on or both off.
The way the information is passed to switchdev makes drivers not
expressive enough, and unable to reject this request ahead of time, in
the PRE_BRIDGE_FLAGS notifier, so they are forced to reject it during
the deferred BRIDGE_FLAGS attribute, where the rejection is currently
ignored.

This patch also changes drivers to make use of the "mask" field for edge
detection when possible.

	Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
	Reviewed-by: Grygorii Strashko <grygorii.strashko@ti.com>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e18f4c18ab5b0dd47caaf8377c2e36d66f632a8c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/marvell/prestera/prestera_switchdev.c
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
#	drivers/net/ethernet/rocker/rocker_main.c
#	drivers/net/ethernet/ti/am65-cpsw-switchdev.c
#	drivers/net/ethernet/ti/cpsw_switchdev.c
#	drivers/staging/fsl-dpaa2/ethsw/ethsw.c
#	include/net/switchdev.h
#	net/dsa/dsa_priv.h
#	net/dsa/port.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
index 14ce372c3f85,23b7e8d6386b..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
@@@ -661,21 -653,19 +661,27 @@@ err_port_bridge_vlan_learning_set
  	return err;
  }
  
++<<<<<<< HEAD
 +static int mlxsw_sp_port_attr_br_pre_flags_set(struct mlxsw_sp_port
 +					       *mlxsw_sp_port,
 +					       struct switchdev_trans *trans,
 +					       unsigned long brport_flags)
++=======
+ static int
+ mlxsw_sp_port_attr_br_pre_flags_set(struct mlxsw_sp_port *mlxsw_sp_port,
+ 				    struct switchdev_brport_flags flags)
++>>>>>>> e18f4c18ab5b (net: switchdev: pass flags and mask to both {PRE_,}BRIDGE_FLAGS attributes)
  {
- 	if (brport_flags & ~(BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD))
+ 	if (flags.mask & ~(BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD))
  		return -EINVAL;
  
  	return 0;
  }
  
  static int mlxsw_sp_port_attr_br_flags_set(struct mlxsw_sp_port *mlxsw_sp_port,
 +					   struct switchdev_trans *trans,
  					   struct net_device *orig_dev,
- 					   unsigned long brport_flags)
+ 					   struct switchdev_brport_flags flags)
  {
  	struct mlxsw_sp_bridge_port *bridge_port;
  	int err;
diff --cc drivers/net/ethernet/rocker/rocker_main.c
index 6bf36ef15dab,3473d296b2e2..000000000000
--- a/drivers/net/ethernet/rocker/rocker_main.c
+++ b/drivers/net/ethernet/rocker/rocker_main.c
@@@ -1581,8 -1576,7 +1581,12 @@@ rocker_world_port_attr_bridge_flags_sup
  
  static int
  rocker_world_port_attr_pre_bridge_flags_set(struct rocker_port *rocker_port,
++<<<<<<< HEAD
 +					    unsigned long brport_flags,
 +					    struct switchdev_trans *trans)
++=======
+ 					    struct switchdev_brport_flags flags)
++>>>>>>> e18f4c18ab5b (net: switchdev: pass flags and mask to both {PRE_,}BRIDGE_FLAGS attributes)
  {
  	struct rocker_world_ops *wops = rocker_port->rocker->wops;
  	unsigned long brport_flags_s;
@@@ -1604,19 -1598,14 +1608,27 @@@
  
  static int
  rocker_world_port_attr_bridge_flags_set(struct rocker_port *rocker_port,
++<<<<<<< HEAD
 +					unsigned long brport_flags,
 +					struct switchdev_trans *trans)
++=======
+ 					struct switchdev_brport_flags flags)
++>>>>>>> e18f4c18ab5b (net: switchdev: pass flags and mask to both {PRE_,}BRIDGE_FLAGS attributes)
  {
  	struct rocker_world_ops *wops = rocker_port->rocker->wops;
  
  	if (!wops->port_attr_bridge_flags_set)
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	if (switchdev_trans_ph_prepare(trans))
 +		return 0;
 +
 +	return wops->port_attr_bridge_flags_set(rocker_port, brport_flags,
 +						trans);
++=======
+ 	return wops->port_attr_bridge_flags_set(rocker_port, flags.val);
++>>>>>>> e18f4c18ab5b (net: switchdev: pass flags and mask to both {PRE_,}BRIDGE_FLAGS attributes)
  }
  
  static int
@@@ -2081,8 -2058,7 +2093,12 @@@ static int rocker_port_attr_set(struct 
  		break;
  	case SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS:
  		err = rocker_world_port_attr_pre_bridge_flags_set(rocker_port,
++<<<<<<< HEAD
 +							      attr->u.brport_flags,
 +							      trans);
++=======
+ 								  attr->u.brport_flags);
++>>>>>>> e18f4c18ab5b (net: switchdev: pass flags and mask to both {PRE_,}BRIDGE_FLAGS attributes)
  		break;
  	case SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:
  		err = rocker_world_port_attr_bridge_flags_set(rocker_port,
diff --cc drivers/staging/fsl-dpaa2/ethsw/ethsw.c
index 1f9a4c8ef2da,703055e063ff..000000000000
--- a/drivers/staging/fsl-dpaa2/ethsw/ethsw.c
+++ b/drivers/staging/fsl-dpaa2/ethsw/ethsw.c
@@@ -645,58 -905,46 +645,92 @@@ static int swdev_port_attr_get(struct n
  {
  	struct ethsw_port_priv *port_priv = netdev_priv(netdev);
  
++<<<<<<< HEAD
 +	switch (attr->id) {
 +	case SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:
 +		attr->u.brport_flags =
 +			(port_priv->ethsw_data->learning ? BR_LEARNING : 0) |
 +			(port_priv->flood ? BR_FLOOD : 0);
 +		break;
 +	case SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS_SUPPORT:
 +		attr->u.brport_flags_support = BR_LEARNING | BR_FLOOD;
 +		break;
 +	default:
 +		return -EOPNOTSUPP;
 +	}
++=======
+ 	return dpaa2_switch_port_set_stp_state(port_priv, state);
+ }
+ 
+ static int
+ dpaa2_switch_port_attr_br_flags_pre_set(struct net_device *netdev,
+ 					struct switchdev_brport_flags flags)
+ {
+ 	if (flags.mask & ~(BR_LEARNING | BR_FLOOD))
+ 		return -EINVAL;
++>>>>>>> e18f4c18ab5b (net: switchdev: pass flags and mask to both {PRE_,}BRIDGE_FLAGS attributes)
  
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int port_attr_stp_state_set(struct net_device *netdev,
 +				   struct switchdev_trans *trans,
 +				   u8 state)
 +{
 +	struct ethsw_port_priv *port_priv = netdev_priv(netdev);
 +
 +	if (switchdev_trans_ph_prepare(trans))
 +		return 0;
 +
 +	return ethsw_port_set_stp_state(port_priv, state);
 +}
 +
 +static int port_attr_br_flags_set(struct net_device *netdev,
 +				  struct switchdev_trans *trans,
 +				  unsigned long flags)
++=======
+ static int
+ dpaa2_switch_port_attr_br_flags_set(struct net_device *netdev,
+ 				    struct switchdev_brport_flags flags)
++>>>>>>> e18f4c18ab5b (net: switchdev: pass flags and mask to both {PRE_,}BRIDGE_FLAGS attributes)
  {
  	struct ethsw_port_priv *port_priv = netdev_priv(netdev);
  	int err = 0;
  
++<<<<<<< HEAD
 +	if (switchdev_trans_ph_prepare(trans))
 +		return 0;
 +
 +	/* Learning is enabled per switch */
 +	err = ethsw_set_learning(port_priv->ethsw_data, flags & BR_LEARNING);
 +	if (err)
 +		goto exit;
 +
 +	err = ethsw_port_set_flood(port_priv, flags & BR_FLOOD);
++=======
+ 	if (flags.mask & BR_LEARNING) {
+ 		/* Learning is enabled per switch */
+ 		err = dpaa2_switch_set_learning(port_priv->ethsw_data,
+ 						!!(flags.val & BR_LEARNING));
+ 		if (err)
+ 			return err;
+ 	}
  
- exit:
- 	return err;
+ 	if (flags.mask & BR_FLOOD) {
+ 		err = dpaa2_switch_port_set_flood(port_priv,
+ 						  !!(flags.val & BR_FLOOD));
+ 		if (err)
+ 			return err;
+ 	}
++>>>>>>> e18f4c18ab5b (net: switchdev: pass flags and mask to both {PRE_,}BRIDGE_FLAGS attributes)
+ 
+ 	return 0;
  }
  
 -static int dpaa2_switch_port_attr_set(struct net_device *netdev,
 -				      const struct switchdev_attr *attr)
 +static int swdev_port_attr_set(struct net_device *netdev,
 +			       const struct switchdev_attr *attr,
 +			       struct switchdev_trans *trans)
  {
  	int err = 0;
  
diff --cc include/net/switchdev.h
index 2ce151de5c5a,25d9e4570934..000000000000
--- a/include/net/switchdev.h
+++ b/include/net/switchdev.h
@@@ -48,10 -44,8 +53,14 @@@ struct switchdev_attr 
  	void *complete_priv;
  	void (*complete)(struct net_device *dev, int err, void *priv);
  	union {
 +		RH_KABI_DEPRECATE(struct netdev_phys_item_id, ppid)
  		u8 stp_state;				/* PORT_STP_STATE */
++<<<<<<< HEAD
 +		unsigned long brport_flags;		/* PORT_{PRE}_BRIDGE_FLAGS */
 +		RH_KABI_DEPRECATE(unsigned long, brport_flags_support)
++=======
+ 		struct switchdev_brport_flags brport_flags; /* PORT_BRIDGE_FLAGS */
++>>>>>>> e18f4c18ab5b (net: switchdev: pass flags and mask to both {PRE_,}BRIDGE_FLAGS attributes)
  		bool mrouter;				/* PORT_MROUTER */
  		clock_t ageing_time;			/* BRIDGE_AGEING_TIME */
  		bool vlan_filtering;			/* BRIDGE_VLAN_FILTERING */
diff --cc net/dsa/dsa_priv.h
index 4aeecfbc0008,bc835f3de2be..000000000000
--- a/net/dsa/dsa_priv.h
+++ b/net/dsa/dsa_priv.h
@@@ -155,13 -180,16 +155,21 @@@ int dsa_port_fdb_del(struct dsa_port *d
  		     u16 vid);
  int dsa_port_fdb_dump(struct dsa_port *dp, dsa_fdb_dump_cb_t *cb, void *data);
  int dsa_port_mdb_add(const struct dsa_port *dp,
 -		     const struct switchdev_obj_port_mdb *mdb);
 +		     const struct switchdev_obj_port_mdb *mdb,
 +		     struct switchdev_trans *trans);
  int dsa_port_mdb_del(const struct dsa_port *dp,
  		     const struct switchdev_obj_port_mdb *mdb);
++<<<<<<< HEAD
++=======
+ int dsa_port_pre_bridge_flags(const struct dsa_port *dp,
+ 			      struct switchdev_brport_flags flags);
+ int dsa_port_bridge_flags(const struct dsa_port *dp,
+ 			  struct switchdev_brport_flags flags);
+ int dsa_port_mrouter(struct dsa_port *dp, bool mrouter);
++>>>>>>> e18f4c18ab5b (net: switchdev: pass flags and mask to both {PRE_,}BRIDGE_FLAGS attributes)
  int dsa_port_vlan_add(struct dsa_port *dp,
 -		      const struct switchdev_obj_port_vlan *vlan);
 +		      const struct switchdev_obj_port_vlan *vlan,
 +		      struct switchdev_trans *trans);
  int dsa_port_vlan_del(struct dsa_port *dp,
  		      const struct switchdev_obj_port_vlan *vlan);
  int dsa_port_link_register_of(struct dsa_port *dp);
diff --cc net/dsa/port.c
index 2d7e01b23572,368064dfd93e..000000000000
--- a/net/dsa/port.c
+++ b/net/dsa/port.c
@@@ -90,10 -105,43 +90,43 @@@ void dsa_port_disable(struct dsa_port *
  	struct dsa_switch *ds = dp->ds;
  	int port = dp->index;
  
 -	if (dp->pl)
 -		phylink_stop(dp->pl);
 -
 -	if (!dp->bridge_dev)
 -		dsa_port_set_state_now(dp, BR_STATE_DISABLED);
 +	dsa_port_set_state_now(dp, BR_STATE_DISABLED);
  
  	if (ds->ops->port_disable)
++<<<<<<< HEAD
 +		ds->ops->port_disable(ds, port, phy);
++=======
+ 		ds->ops->port_disable(ds, port);
+ }
+ 
+ void dsa_port_disable(struct dsa_port *dp)
+ {
+ 	rtnl_lock();
+ 	dsa_port_disable_rt(dp);
+ 	rtnl_unlock();
+ }
+ 
+ static void dsa_port_change_brport_flags(struct dsa_port *dp,
+ 					 bool bridge_offload)
+ {
+ 	struct switchdev_brport_flags flags;
+ 	int flag;
+ 
+ 	flags.mask = BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD;
+ 	if (bridge_offload)
+ 		flags.val = flags.mask;
+ 	else
+ 		flags.val = flags.mask & ~BR_LEARNING;
+ 
+ 	for_each_set_bit(flag, &flags.mask, 32) {
+ 		struct switchdev_brport_flags tmp;
+ 
+ 		tmp.val = flags.val & BIT(flag);
+ 		tmp.mask = BIT(flag);
+ 
+ 		dsa_port_bridge_flags(dp, tmp);
+ 	}
++>>>>>>> e18f4c18ab5b (net: switchdev: pass flags and mask to both {PRE_,}BRIDGE_FLAGS attributes)
  }
  
  int dsa_port_bridge_join(struct dsa_port *dp, struct net_device *br)
@@@ -174,7 -421,58 +207,62 @@@ int dsa_port_ageing_time(struct dsa_por
  
  	dp->ageing_time = ageing_time;
  
++<<<<<<< HEAD
 +	return dsa_port_notify(dp, DSA_NOTIFIER_AGEING_TIME, &info);
++=======
+ 	return 0;
+ }
+ 
+ int dsa_port_pre_bridge_flags(const struct dsa_port *dp,
+ 			      struct switchdev_brport_flags flags)
+ {
+ 	struct dsa_switch *ds = dp->ds;
+ 
+ 	if (!ds->ops->port_egress_floods ||
+ 	    (flags.mask & ~(BR_FLOOD | BR_MCAST_FLOOD)))
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ int dsa_port_bridge_flags(const struct dsa_port *dp,
+ 			  struct switchdev_brport_flags flags)
+ {
+ 	struct dsa_switch *ds = dp->ds;
+ 	int port = dp->index;
+ 	int err = 0;
+ 
+ 	if (ds->ops->port_egress_floods)
+ 		err = ds->ops->port_egress_floods(ds, port,
+ 						  flags.val & BR_FLOOD,
+ 						  flags.val & BR_MCAST_FLOOD);
+ 
+ 	return err;
+ }
+ 
+ int dsa_port_mrouter(struct dsa_port *dp, bool mrouter)
+ {
+ 	struct dsa_switch *ds = dp->ds;
+ 	int port = dp->index;
+ 
+ 	if (!ds->ops->port_egress_floods)
+ 		return -EOPNOTSUPP;
+ 
+ 	return ds->ops->port_egress_floods(ds, port, true, mrouter);
+ }
+ 
+ int dsa_port_mtu_change(struct dsa_port *dp, int new_mtu,
+ 			bool propagate_upstream)
+ {
+ 	struct dsa_notifier_mtu_info info = {
+ 		.sw_index = dp->ds->index,
+ 		.propagate_upstream = propagate_upstream,
+ 		.port = dp->index,
+ 		.mtu = new_mtu,
+ 	};
+ 
+ 	return dsa_port_notify(dp, DSA_NOTIFIER_MTU, &info);
++>>>>>>> e18f4c18ab5b (net: switchdev: pass flags and mask to both {PRE_,}BRIDGE_FLAGS attributes)
  }
  
  int dsa_port_fdb_add(struct dsa_port *dp, const unsigned char *addr,
* Unmerged path drivers/net/ethernet/marvell/prestera/prestera_switchdev.c
* Unmerged path drivers/net/ethernet/ti/am65-cpsw-switchdev.c
* Unmerged path drivers/net/ethernet/ti/cpsw_switchdev.c
* Unmerged path drivers/net/ethernet/marvell/prestera/prestera_switchdev.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
* Unmerged path drivers/net/ethernet/rocker/rocker_main.c
* Unmerged path drivers/net/ethernet/ti/am65-cpsw-switchdev.c
* Unmerged path drivers/net/ethernet/ti/cpsw_switchdev.c
* Unmerged path drivers/staging/fsl-dpaa2/ethsw/ethsw.c
* Unmerged path include/net/switchdev.h
diff --git a/net/bridge/br_switchdev.c b/net/bridge/br_switchdev.c
index cef6330b1cc4..d459f5ec74e6 100644
--- a/net/bridge/br_switchdev.c
+++ b/net/bridge/br_switchdev.c
@@ -65,7 +65,6 @@ int br_switchdev_set_port_flag(struct net_bridge_port *p,
 {
 	struct switchdev_attr attr = {
 		.orig_dev = p->dev,
-		.id = SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS,
 	};
 	struct switchdev_notifier_port_attr_info info = {
 		.attr = &attr,
@@ -76,7 +75,9 @@ int br_switchdev_set_port_flag(struct net_bridge_port *p,
 	if (!mask)
 		return 0;
 
-	attr.u.brport_flags = mask;
+	attr.id = SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS;
+	attr.u.brport_flags.val = flags;
+	attr.u.brport_flags.mask = mask;
 
 	/* We run from atomic context here */
 	err = call_switchdev_notifiers(SWITCHDEV_PORT_ATTR_SET, p->dev,
@@ -94,7 +95,6 @@ int br_switchdev_set_port_flag(struct net_bridge_port *p,
 
 	attr.id = SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS;
 	attr.flags = SWITCHDEV_F_DEFER;
-	attr.u.brport_flags = flags;
 
 	err = switchdev_port_attr_set(p->dev, &attr);
 	if (err) {
* Unmerged path net/dsa/dsa_priv.h
* Unmerged path net/dsa/port.c
