bpf: Notify user if we ever hit a bpf_snprintf verifier bug

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Florent Revest <revest@chromium.org>
commit 8e8ee109b02c0e90021d63cd20dd0157c021f7a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/8e8ee109.failed

In check_bpf_snprintf_call(), a map_direct_value_addr() of the fmt map
should never fail because it has already been checked by
ARG_PTR_TO_CONST_STR. But if it ever fails, it's better to error out
with an explicit debug message rather than silently fail.

	Reported-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Florent Revest <revest@chromium.org>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20210422235543.4007694-2-revest@chromium.org
(cherry picked from commit 8e8ee109b02c0e90021d63cd20dd0157c021f7a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index 3c2ee850da6c,59799a9b014a..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -5563,7 -5919,45 +5563,49 @@@ static int check_reference_leak(struct 
  	return state->acquired_refs ? -EINVAL : 0;
  }
  
++<<<<<<< HEAD
 +static int check_helper_call(struct bpf_verifier_env *env, int func_id, int insn_idx)
++=======
+ static int check_bpf_snprintf_call(struct bpf_verifier_env *env,
+ 				   struct bpf_reg_state *regs)
+ {
+ 	struct bpf_reg_state *fmt_reg = &regs[BPF_REG_3];
+ 	struct bpf_reg_state *data_len_reg = &regs[BPF_REG_5];
+ 	struct bpf_map *fmt_map = fmt_reg->map_ptr;
+ 	int err, fmt_map_off, num_args;
+ 	u64 fmt_addr;
+ 	char *fmt;
+ 
+ 	/* data must be an array of u64 */
+ 	if (data_len_reg->var_off.value % 8)
+ 		return -EINVAL;
+ 	num_args = data_len_reg->var_off.value / 8;
+ 
+ 	/* fmt being ARG_PTR_TO_CONST_STR guarantees that var_off is const
+ 	 * and map_direct_value_addr is set.
+ 	 */
+ 	fmt_map_off = fmt_reg->off + fmt_reg->var_off.value;
+ 	err = fmt_map->ops->map_direct_value_addr(fmt_map, &fmt_addr,
+ 						  fmt_map_off);
+ 	if (err) {
+ 		verbose(env, "verifier bug\n");
+ 		return -EFAULT;
+ 	}
+ 	fmt = (char *)(long)fmt_addr + fmt_map_off;
+ 
+ 	/* We are also guaranteed that fmt+fmt_map_off is NULL terminated, we
+ 	 * can focus on validating the format specifiers.
+ 	 */
+ 	err = bpf_printf_prepare(fmt, UINT_MAX, NULL, NULL, NULL, num_args);
+ 	if (err < 0)
+ 		verbose(env, "Invalid format string\n");
+ 
+ 	return err;
+ }
+ 
+ static int check_helper_call(struct bpf_verifier_env *env, struct bpf_insn *insn,
+ 			     int *insn_idx_p)
++>>>>>>> 8e8ee109b02c (bpf: Notify user if we ever hit a bpf_snprintf verifier bug)
  {
  	const struct bpf_func_proto *fn = NULL;
  	struct bpf_reg_state *regs;
* Unmerged path kernel/bpf/verifier.c
