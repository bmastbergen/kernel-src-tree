KVM: x86/mmu: Remove redundant root_hpa checks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author David Matlack <dmatlack@google.com>
commit 0485cf8dbe964b6cc485178da6ee8ae7b2d0d15c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/0485cf8d.failed

The root_hpa checks below the top-level check in kvm_mmu_page_fault are
theoretically redundant since there is no longer a way for the root_hpa
to be reset during a page fault. The details of why are described in
commit ddce6208217c ("KVM: x86/mmu: Move root_hpa validity checks to top
of page fault handler")

__direct_map, kvm_tdp_mmu_map, and get_mmio_spte are all only reachable
through kvm_mmu_page_fault, therefore their root_hpa checks are
redundant.

	Suggested-by: Sean Christopherson <seanjc@google.com>
	Signed-off-by: David Matlack <dmatlack@google.com>
Message-Id: <20210617231948.2591431-5-dmatlack@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 0485cf8dbe964b6cc485178da6ee8ae7b2d0d15c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/mmu.c
diff --cc arch/x86/kvm/mmu/mmu.c
index 3ea1a3f588dc,84d48a33e38b..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -3620,12 -3600,7 +3617,16 @@@ static bool get_mmio_spte(struct kvm_vc
  	int root, leaf, level;
  	bool reserved = false;
  
++<<<<<<< HEAD
 +	if (!VALID_PAGE(vcpu->arch.mmu->root_hpa)) {
 +		*sptep = 0ull;
 +		return reserved;
 +	}
 +
 +	if (is_tdp_mmu_root(vcpu->arch.mmu->root_hpa))
++=======
+ 	if (is_tdp_mmu(vcpu->arch.mmu))
++>>>>>>> 0485cf8dbe96 (KVM: x86/mmu: Remove redundant root_hpa checks)
  		leaf = kvm_tdp_mmu_get_walk(vcpu, addr, sptes, &root);
  	else
  		leaf = get_walk(vcpu, addr, sptes, &root);
* Unmerged path arch/x86/kvm/mmu/mmu.c
diff --git a/arch/x86/kvm/mmu/tdp_mmu.c b/arch/x86/kvm/mmu/tdp_mmu.c
index 66e1adaafe79..cc4645939760 100644
--- a/arch/x86/kvm/mmu/tdp_mmu.c
+++ b/arch/x86/kvm/mmu/tdp_mmu.c
@@ -825,9 +825,6 @@ int kvm_tdp_mmu_map(struct kvm_vcpu *vcpu, gpa_t gpa, u32 error_code,
 	int level;
 	int req_level;
 
-	if (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))
-		return RET_PF_RETRY;
-
 	level = kvm_mmu_hugepage_adjust(vcpu, gfn, max_level, &pfn,
 					huge_page_disallowed, &req_level);
 
