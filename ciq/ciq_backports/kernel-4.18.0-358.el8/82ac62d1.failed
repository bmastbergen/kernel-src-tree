psci: Replace psci_function_id array with a struct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author David Brazdil <dbrazdil@google.com>
commit 82ac62d1658b42392282550078a189ccd3f50214
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/82ac62d1.failed

Small refactor that replaces array of v0.1 function IDs indexed by an
enum of function-name constants with a struct of function IDs "indexed"
by field names. This is done in preparation for exposing the IDs to
other parts of the kernel. Exposing a struct avoids the need for
bounds checking.

	Signed-off-by: David Brazdil <dbrazdil@google.com>
	Signed-off-by: Marc Zyngier <maz@kernel.org>
	Acked-by: Mark Rutland <mark.rutland@arm.com>
Link: https://lore.kernel.org/r/20201202184122.26046-6-dbrazdil@google.com
(cherry picked from commit 82ac62d1658b42392282550078a189ccd3f50214)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/psci/psci.c
diff --cc drivers/firmware/psci/psci.c
index 1606915bfeff,593fdd0e09a2..000000000000
--- a/drivers/firmware/psci/psci.c
+++ b/drivers/firmware/psci/psci.c
@@@ -184,36 -175,72 +183,93 @@@ static int psci_cpu_suspend(u32 state, 
  	return psci_to_linux_errno(err);
  }
  
++<<<<<<< HEAD
 +static int psci_cpu_off(u32 state)
++=======
+ static int psci_0_1_cpu_suspend(u32 state, unsigned long entry_point)
+ {
+ 	return __psci_cpu_suspend(psci_0_1_function_ids.cpu_suspend,
+ 				  state, entry_point);
+ }
+ 
+ static int psci_0_2_cpu_suspend(u32 state, unsigned long entry_point)
+ {
+ 	return __psci_cpu_suspend(PSCI_FN_NATIVE(0_2, CPU_SUSPEND),
+ 				  state, entry_point);
+ }
+ 
+ static int __psci_cpu_off(u32 fn, u32 state)
++>>>>>>> 82ac62d1658b (psci: Replace psci_function_id array with a struct)
  {
  	int err;
 +	u32 fn;
  
 +	fn = psci_function_id[PSCI_FN_CPU_OFF];
  	err = invoke_psci_fn(fn, state, 0, 0);
  	return psci_to_linux_errno(err);
  }
  
++<<<<<<< HEAD
 +static int psci_cpu_on(unsigned long cpuid, unsigned long entry_point)
++=======
+ static int psci_0_1_cpu_off(u32 state)
+ {
+ 	return __psci_cpu_off(psci_0_1_function_ids.cpu_off, state);
+ }
+ 
+ static int psci_0_2_cpu_off(u32 state)
+ {
+ 	return __psci_cpu_off(PSCI_0_2_FN_CPU_OFF, state);
+ }
+ 
+ static int __psci_cpu_on(u32 fn, unsigned long cpuid, unsigned long entry_point)
++>>>>>>> 82ac62d1658b (psci: Replace psci_function_id array with a struct)
  {
  	int err;
 +	u32 fn;
  
 +	fn = psci_function_id[PSCI_FN_CPU_ON];
  	err = invoke_psci_fn(fn, cpuid, entry_point, 0);
  	return psci_to_linux_errno(err);
  }
  
++<<<<<<< HEAD
 +static int psci_migrate(unsigned long cpuid)
++=======
+ static int psci_0_1_cpu_on(unsigned long cpuid, unsigned long entry_point)
+ {
+ 	return __psci_cpu_on(psci_0_1_function_ids.cpu_on, cpuid, entry_point);
+ }
+ 
+ static int psci_0_2_cpu_on(unsigned long cpuid, unsigned long entry_point)
+ {
+ 	return __psci_cpu_on(PSCI_FN_NATIVE(0_2, CPU_ON), cpuid, entry_point);
+ }
+ 
+ static int __psci_migrate(u32 fn, unsigned long cpuid)
++>>>>>>> 82ac62d1658b (psci: Replace psci_function_id array with a struct)
  {
  	int err;
 +	u32 fn;
  
 +	fn = psci_function_id[PSCI_FN_MIGRATE];
  	err = invoke_psci_fn(fn, cpuid, 0, 0);
  	return psci_to_linux_errno(err);
  }
  
++<<<<<<< HEAD
++=======
+ static int psci_0_1_migrate(unsigned long cpuid)
+ {
+ 	return __psci_migrate(psci_0_1_function_ids.migrate, cpuid);
+ }
+ 
+ static int psci_0_2_migrate(unsigned long cpuid)
+ {
+ 	return __psci_migrate(PSCI_FN_NATIVE(0_2, MIGRATE), cpuid);
+ }
+ 
++>>>>>>> 82ac62d1658b (psci: Replace psci_function_id array with a struct)
  static int psci_affinity_info(unsigned long target_affinity,
  		unsigned long lowest_affinity_level)
  {
@@@ -679,23 -547,23 +735,43 @@@ static int __init psci_0_1_init(struct 
  	psci_ops.get_version = psci_0_1_get_version;
  
  	if (!of_property_read_u32(np, "cpu_suspend", &id)) {
++<<<<<<< HEAD
 +		psci_function_id[PSCI_FN_CPU_SUSPEND] = id;
 +		psci_ops.cpu_suspend = psci_cpu_suspend;
 +	}
 +
 +	if (!of_property_read_u32(np, "cpu_off", &id)) {
 +		psci_function_id[PSCI_FN_CPU_OFF] = id;
 +		psci_ops.cpu_off = psci_cpu_off;
 +	}
 +
 +	if (!of_property_read_u32(np, "cpu_on", &id)) {
 +		psci_function_id[PSCI_FN_CPU_ON] = id;
 +		psci_ops.cpu_on = psci_cpu_on;
 +	}
 +
 +	if (!of_property_read_u32(np, "migrate", &id)) {
 +		psci_function_id[PSCI_FN_MIGRATE] = id;
 +		psci_ops.migrate = psci_migrate;
++=======
+ 		psci_0_1_function_ids.cpu_suspend = id;
+ 		psci_ops.cpu_suspend = psci_0_1_cpu_suspend;
+ 	}
+ 
+ 	if (!of_property_read_u32(np, "cpu_off", &id)) {
+ 		psci_0_1_function_ids.cpu_off = id;
+ 		psci_ops.cpu_off = psci_0_1_cpu_off;
+ 	}
+ 
+ 	if (!of_property_read_u32(np, "cpu_on", &id)) {
+ 		psci_0_1_function_ids.cpu_on = id;
+ 		psci_ops.cpu_on = psci_0_1_cpu_on;
+ 	}
+ 
+ 	if (!of_property_read_u32(np, "migrate", &id)) {
+ 		psci_0_1_function_ids.migrate = id;
+ 		psci_ops.migrate = psci_0_1_migrate;
++>>>>>>> 82ac62d1658b (psci: Replace psci_function_id array with a struct)
  	}
  
  	return 0;
* Unmerged path drivers/firmware/psci/psci.c
