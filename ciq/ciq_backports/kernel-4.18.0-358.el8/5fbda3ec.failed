sched: highmem: Store local kmaps in task struct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 5fbda3ecd14a5343644979c98d6eb65b7e7de9d8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/5fbda3ec.failed

Instead of storing the map per CPU provide and use per task storage. That
prepares for local kmaps which are preemptible.

The context switch code is preparatory and not yet in use because
kmap_atomic() runs with preemption disabled. Will be made usable in the
next step.

The context switch logic is safe even when an interrupt happens after
clearing or before restoring the kmaps. The kmap index in task struct is
not modified so any nesting kmap in an interrupt will use unused indices
and on return the counter is the same as before.

Also add an assert into the return to user space code. Going back to user
space with an active kmap local is a nono.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lore.kernel.org/r/20201118204007.372935758@linutronix.de

(cherry picked from commit 5fbda3ecd14a5343644979c98d6eb65b7e7de9d8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/highmem-internal.h
#	include/linux/sched.h
#	kernel/entry/common.c
#	mm/highmem.c
diff --cc include/linux/sched.h
index 187fbf3248da,8946911cee9f..000000000000
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@@ -34,7 -34,7 +34,11 @@@
  #include <linux/rseq.h>
  #include <linux/seqlock.h>
  #include <linux/kcsan.h>
++<<<<<<< HEAD
 +#include <linux/rh_kabi.h>
++=======
+ #include <asm/kmap_size.h>
++>>>>>>> 5fbda3ecd14a (sched: highmem: Store local kmaps in task struct)
  
  /* task_struct member predeclarations (sorted alphabetically): */
  struct audit_context;
@@@ -583,30 -630,11 +587,38 @@@ struct wake_q_node 
  	struct wake_q_node *next;
  };
  
++<<<<<<< HEAD
 +struct task_struct;
 +
 +struct task_struct_rh {
 +	/* Empty if CONFIG_POSIX_CPUTIMERS=n */
 +	struct posix_cputimers posix_cputimers;
 +	/* struct vtime->cpu */
 +	unsigned int vtime_cpu;
 +	u64				parent_exec_id;
 +	u64				self_exec_id;
 +#ifdef CONFIG_COMPACTION
 +	struct capture_control          *capture_control;
 +#endif
 +#ifdef CONFIG_X86_MCE
 +	__u64				mce_ripv : 1,
 +					mce_whole_page : 1,
 +					__mce_reserved : 62;
 +#endif
 +	/* pointer back to the main task_struct */
 +	struct task_struct		*task_struct;
 +	int				trc_reader_nesting;
 +	int				trc_ipi_to_cpu;
 +	union rcu_special		trc_reader_special;
 +	bool				trc_reader_checked;
 +	struct list_head		trc_holdout_list;
++=======
+ struct kmap_ctrl {
+ #ifdef CONFIG_KMAP_LOCAL
+ 	int				idx;
+ 	pte_t				pteval[KM_MAX_IDX];
+ #endif
++>>>>>>> 5fbda3ecd14a (sched: highmem: Store local kmaps in task struct)
  };
  
  struct task_struct {
diff --cc mm/highmem.c
index 51171d0f44c2,d1ef06aa6de6..000000000000
--- a/mm/highmem.c
+++ b/mm/highmem.c
@@@ -365,8 -358,253 +365,257 @@@ void kunmap_high(struct page *page
  	if (need_wakeup)
  		wake_up(pkmap_map_wait);
  }
 +
  EXPORT_SYMBOL(kunmap_high);
++<<<<<<< HEAD
++=======
+ #endif /* CONFIG_HIGHMEM */
+ 
+ #ifdef CONFIG_KMAP_LOCAL
+ 
+ #include <asm/kmap_size.h>
+ 
+ /*
+  * With DEBUG_KMAP_LOCAL the stack depth is doubled and every second
+  * slot is unused which acts as a guard page
+  */
+ #ifdef CONFIG_DEBUG_KMAP_LOCAL
+ # define KM_INCR	2
+ #else
+ # define KM_INCR	1
+ #endif
+ 
+ static inline int kmap_local_idx_push(void)
+ {
+ 	WARN_ON_ONCE(in_irq() && !irqs_disabled());
+ 	current->kmap_ctrl.idx += KM_INCR;
+ 	BUG_ON(current->kmap_ctrl.idx >= KM_MAX_IDX);
+ 	return current->kmap_ctrl.idx - 1;
+ }
+ 
+ static inline int kmap_local_idx(void)
+ {
+ 	return current->kmap_ctrl.idx - 1;
+ }
+ 
+ static inline void kmap_local_idx_pop(void)
+ {
+ 	current->kmap_ctrl.idx -= KM_INCR;
+ 	BUG_ON(current->kmap_ctrl.idx < 0);
+ }
+ 
+ #ifndef arch_kmap_local_post_map
+ # define arch_kmap_local_post_map(vaddr, pteval)	do { } while (0)
+ #endif
+ 
+ #ifndef arch_kmap_local_pre_unmap
+ # define arch_kmap_local_pre_unmap(vaddr)		do { } while (0)
+ #endif
+ 
+ #ifndef arch_kmap_local_post_unmap
+ # define arch_kmap_local_post_unmap(vaddr)		do { } while (0)
+ #endif
+ 
+ #ifndef arch_kmap_local_map_idx
+ #define arch_kmap_local_map_idx(idx, pfn)	kmap_local_calc_idx(idx)
+ #endif
+ 
+ #ifndef arch_kmap_local_unmap_idx
+ #define arch_kmap_local_unmap_idx(idx, vaddr)	kmap_local_calc_idx(idx)
+ #endif
+ 
+ #ifndef arch_kmap_local_high_get
+ static inline void *arch_kmap_local_high_get(struct page *page)
+ {
+ 	return NULL;
+ }
+ #endif
+ 
+ /* Unmap a local mapping which was obtained by kmap_high_get() */
+ static inline bool kmap_high_unmap_local(unsigned long vaddr)
+ {
+ #ifdef ARCH_NEEDS_KMAP_HIGH_GET
+ 	if (vaddr >= PKMAP_ADDR(0) && vaddr < PKMAP_ADDR(LAST_PKMAP)) {
+ 		kunmap_high(pte_page(pkmap_page_table[PKMAP_NR(vaddr)]));
+ 		return true;
+ 	}
+ #endif
+ 	return false;
+ }
+ 
+ static inline int kmap_local_calc_idx(int idx)
+ {
+ 	return idx + KM_MAX_IDX * smp_processor_id();
+ }
+ 
+ static pte_t *__kmap_pte;
+ 
+ static pte_t *kmap_get_pte(void)
+ {
+ 	if (!__kmap_pte)
+ 		__kmap_pte = virt_to_kpte(__fix_to_virt(FIX_KMAP_BEGIN));
+ 	return __kmap_pte;
+ }
+ 
+ void *__kmap_local_pfn_prot(unsigned long pfn, pgprot_t prot)
+ {
+ 	pte_t pteval, *kmap_pte = kmap_get_pte();
+ 	unsigned long vaddr;
+ 	int idx;
+ 
+ 	preempt_disable();
+ 	idx = arch_kmap_local_map_idx(kmap_local_idx_push(), pfn);
+ 	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
+ 	BUG_ON(!pte_none(*(kmap_pte - idx)));
+ 	pteval = pfn_pte(pfn, prot);
+ 	set_pte_at(&init_mm, vaddr, kmap_pte - idx, pteval);
+ 	arch_kmap_local_post_map(vaddr, pteval);
+ 	current->kmap_ctrl.pteval[kmap_local_idx()] = pteval;
+ 	preempt_enable();
+ 
+ 	return (void *)vaddr;
+ }
+ EXPORT_SYMBOL_GPL(__kmap_local_pfn_prot);
+ 
+ void *__kmap_local_page_prot(struct page *page, pgprot_t prot)
+ {
+ 	void *kmap;
+ 
+ 	/*
+ 	 * To broaden the usage of the actual kmap_local() machinery always map
+ 	 * pages when debugging is enabled and the architecture has no problems
+ 	 * with alias mappings.
+ 	 */
+ 	if (!IS_ENABLED(CONFIG_DEBUG_KMAP_LOCAL_FORCE_MAP) && !PageHighMem(page))
+ 		return page_address(page);
+ 
+ 	/* Try kmap_high_get() if architecture has it enabled */
+ 	kmap = arch_kmap_local_high_get(page);
+ 	if (kmap)
+ 		return kmap;
+ 
+ 	return __kmap_local_pfn_prot(page_to_pfn(page), prot);
+ }
+ EXPORT_SYMBOL(__kmap_local_page_prot);
+ 
+ void kunmap_local_indexed(void *vaddr)
+ {
+ 	unsigned long addr = (unsigned long) vaddr & PAGE_MASK;
+ 	pte_t *kmap_pte = kmap_get_pte();
+ 	int idx;
+ 
+ 	if (addr < __fix_to_virt(FIX_KMAP_END) ||
+ 	    addr > __fix_to_virt(FIX_KMAP_BEGIN)) {
+ 		if (IS_ENABLED(CONFIG_DEBUG_KMAP_LOCAL_FORCE_MAP)) {
+ 			/* This _should_ never happen! See above. */
+ 			WARN_ON_ONCE(1);
+ 			return;
+ 		}
+ 		/*
+ 		 * Handle mappings which were obtained by kmap_high_get()
+ 		 * first as the virtual address of such mappings is below
+ 		 * PAGE_OFFSET. Warn for all other addresses which are in
+ 		 * the user space part of the virtual address space.
+ 		 */
+ 		if (!kmap_high_unmap_local(addr))
+ 			WARN_ON_ONCE(addr < PAGE_OFFSET);
+ 		return;
+ 	}
+ 
+ 	preempt_disable();
+ 	idx = arch_kmap_local_unmap_idx(kmap_local_idx(), addr);
+ 	WARN_ON_ONCE(addr != __fix_to_virt(FIX_KMAP_BEGIN + idx));
+ 
+ 	arch_kmap_local_pre_unmap(addr);
+ 	pte_clear(&init_mm, addr, kmap_pte - idx);
+ 	arch_kmap_local_post_unmap(addr);
+ 	current->kmap_ctrl.pteval[kmap_local_idx()] = __pte(0);
+ 	kmap_local_idx_pop();
+ 	preempt_enable();
+ }
+ EXPORT_SYMBOL(kunmap_local_indexed);
+ 
+ /*
+  * Invoked before switch_to(). This is safe even when during or after
+  * clearing the maps an interrupt which needs a kmap_local happens because
+  * the task::kmap_ctrl.idx is not modified by the unmapping code so a
+  * nested kmap_local will use the next unused index and restore the index
+  * on unmap. The already cleared kmaps of the outgoing task are irrelevant
+  * because the interrupt context does not know about them. The same applies
+  * when scheduling back in for an interrupt which happens before the
+  * restore is complete.
+  */
+ void __kmap_local_sched_out(void)
+ {
+ 	struct task_struct *tsk = current;
+ 	pte_t *kmap_pte = kmap_get_pte();
+ 	int i;
+ 
+ 	/* Clear kmaps */
+ 	for (i = 0; i < tsk->kmap_ctrl.idx; i++) {
+ 		pte_t pteval = tsk->kmap_ctrl.pteval[i];
+ 		unsigned long addr;
+ 		int idx;
+ 
+ 		/* With debug all even slots are unmapped and act as guard */
+ 		if (IS_ENABLED(CONFIG_DEBUG_HIGHMEM) && !(i & 0x01)) {
+ 			WARN_ON_ONCE(!pte_none(pteval));
+ 			continue;
+ 		}
+ 		if (WARN_ON_ONCE(pte_none(pteval)))
+ 			continue;
+ 
+ 		/*
+ 		 * This is a horrible hack for XTENSA to calculate the
+ 		 * coloured PTE index. Uses the PFN encoded into the pteval
+ 		 * and the map index calculation because the actual mapped
+ 		 * virtual address is not stored in task::kmap_ctrl.
+ 		 * For any sane architecture this is optimized out.
+ 		 */
+ 		idx = arch_kmap_local_map_idx(i, pte_pfn(pteval));
+ 
+ 		addr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
+ 		arch_kmap_local_pre_unmap(addr);
+ 		pte_clear(&init_mm, addr, kmap_pte - idx);
+ 		arch_kmap_local_post_unmap(addr);
+ 	}
+ }
+ 
+ void __kmap_local_sched_in(void)
+ {
+ 	struct task_struct *tsk = current;
+ 	pte_t *kmap_pte = kmap_get_pte();
+ 	int i;
+ 
+ 	/* Restore kmaps */
+ 	for (i = 0; i < tsk->kmap_ctrl.idx; i++) {
+ 		pte_t pteval = tsk->kmap_ctrl.pteval[i];
+ 		unsigned long addr;
+ 		int idx;
+ 
+ 		/* With debug all even slots are unmapped and act as guard */
+ 		if (IS_ENABLED(CONFIG_DEBUG_HIGHMEM) && !(i & 0x01)) {
+ 			WARN_ON_ONCE(!pte_none(pteval));
+ 			continue;
+ 		}
+ 		if (WARN_ON_ONCE(pte_none(pteval)))
+ 			continue;
+ 
+ 		/* See comment in __kmap_local_sched_out() */
+ 		idx = arch_kmap_local_map_idx(i, pte_pfn(pteval));
+ 		addr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
+ 		set_pte_at(&init_mm, addr, kmap_pte - idx, pteval);
+ 		arch_kmap_local_post_map(addr, pteval);
+ 	}
+ }
+ 
+ void kmap_local_fork(struct task_struct *tsk)
+ {
+ 	if (WARN_ON_ONCE(tsk->kmap_ctrl.idx))
+ 		memset(&tsk->kmap_ctrl, 0, sizeof(tsk->kmap_ctrl));
+ }
+ 
++>>>>>>> 5fbda3ecd14a (sched: highmem: Store local kmaps in task struct)
  #endif
  
  #if defined(HASHED_PAGE_VIRTUAL)
* Unmerged path include/linux/highmem-internal.h
* Unmerged path kernel/entry/common.c
* Unmerged path include/linux/highmem-internal.h
* Unmerged path include/linux/sched.h
* Unmerged path kernel/entry/common.c
diff --git a/kernel/fork.c b/kernel/fork.c
index c0080fb30ce4..8b781d8a07f1 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -934,6 +934,7 @@ static struct task_struct *dup_task_struct(struct task_struct *orig, int node)
 	account_kernel_stack(tsk, 1);
 
 	kcov_task_init(tsk);
+	kmap_local_fork(tsk);
 
 #ifdef CONFIG_FAULT_INJECTION
 	tsk->fail_nth = 0;
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 3cc7d5465aa5..dd38c46f832c 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -2877,6 +2877,22 @@ static inline void finish_lock_switch(struct rq *rq)
 # define finish_arch_post_lock_switch()	do { } while (0)
 #endif
 
+static inline void kmap_local_sched_out(void)
+{
+#ifdef CONFIG_KMAP_LOCAL
+	if (unlikely(current->kmap_ctrl.idx))
+		__kmap_local_sched_out();
+#endif
+}
+
+static inline void kmap_local_sched_in(void)
+{
+#ifdef CONFIG_KMAP_LOCAL
+	if (unlikely(current->kmap_ctrl.idx))
+		__kmap_local_sched_in();
+#endif
+}
+
 /**
  * prepare_task_switch - prepare to switch tasks
  * @rq: the runqueue preparing to switch
@@ -2899,6 +2915,7 @@ prepare_task_switch(struct rq *rq, struct task_struct *prev,
 	perf_event_task_sched_out(prev, next);
 	rseq_preempt(prev);
 	fire_sched_out_preempt_notifiers(prev, next);
+	kmap_local_sched_out();
 	prepare_task(next);
 	prepare_arch_switch(next);
 }
@@ -2965,6 +2982,14 @@ static struct rq *finish_task_switch(struct task_struct *prev)
 	finish_lock_switch(rq);
 	finish_arch_post_lock_switch();
 	kcov_finish_switch(current);
+	/*
+	 * kmap_local_sched_out() is invoked with rq::lock held and
+	 * interrupts disabled. There is no requirement for that, but the
+	 * sched out code does not have an interrupt enabled section.
+	 * Restoring the maps on sched in does not require interrupts being
+	 * disabled either.
+	 */
+	kmap_local_sched_in();
 
 	fire_sched_in_preempt_notifiers(current);
 	/*
* Unmerged path mm/highmem.c
