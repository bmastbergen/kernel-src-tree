Bluetooth: btintel: Move operational checks after version check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
commit 9b16bfbf411664697817385096ce59df453e1fb6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/9b16bfbf.failed

In order to allow new firmware to load, it first needs to check if the
firmware version on file matches the one loaded if it doesn't, then it
needs to revert to bootloader mode in order to load the new firmware.

	Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
	Tested-by: Tedd Ho-Jeong An <tedd.an@intel.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 9b16bfbf411664697817385096ce59df453e1fb6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btintel.c
#	drivers/bluetooth/btusb.c
diff --cc drivers/bluetooth/btintel.c
index 7b72e62d6766,13bc93a986c7..000000000000
--- a/drivers/bluetooth/btintel.c
+++ b/drivers/bluetooth/btintel.c
@@@ -918,6 -937,38 +918,41 @@@ int btintel_download_firmware(struct hc
  {
  	int err;
  
++<<<<<<< HEAD
++=======
+ 	/* SfP and WsP don't seem to update the firmware version on file
+ 	 * so version checking is currently not possible.
+ 	 */
+ 	switch (ver->hw_variant) {
+ 	case 0x0b:	/* SfP */
+ 	case 0x0c:	/* WsP */
+ 		/* Skip version checking */
+ 		break;
+ 	default:
+ 		/* Skip download if firmware has the same version */
+ 		if (btintel_firmware_version(hdev, ver->fw_build_num,
+ 					     ver->fw_build_ww, ver->fw_build_yy,
+ 					     fw, boot_param)) {
+ 			bt_dev_info(hdev, "Firmware already loaded");
+ 			/* Return -EALREADY to indicate that the firmware has
+ 			 * already been loaded.
+ 			 */
+ 			return -EALREADY;
+ 		}
+ 	}
+ 
+ 	/* The firmware variant determines if the device is in bootloader
+ 	 * mode or is running operational firmware. The value 0x06 identifies
+ 	 * the bootloader and the value 0x23 identifies the operational
+ 	 * firmware.
+ 	 *
+ 	 * If the firmware version has changed that means it needs to be reset
+ 	 * to bootloader when operational so the new firmware can be loaded.
+ 	 */
+ 	if (ver->fw_variant == 0x23)
+ 		return -EINVAL;
+ 
++>>>>>>> 9b16bfbf4116 (Bluetooth: btintel: Move operational checks after version check)
  	err = btintel_sfi_rsa_header_secure_send(hdev, fw);
  	if (err)
  		return err;
@@@ -934,6 -985,28 +969,31 @@@ int btintel_download_firmware_newgen(st
  	int err;
  	u32 css_header_ver;
  
++<<<<<<< HEAD
++=======
+ 	/* Skip download if firmware has the same version */
+ 	if (btintel_firmware_version(hdev, ver->min_fw_build_nn,
+ 				     ver->min_fw_build_cw, ver->min_fw_build_yy,
+ 				     fw, boot_param)) {
+ 		bt_dev_info(hdev, "Firmware already loaded");
+ 		/* Return -EALREADY to indicate that firmware has already been
+ 		 * loaded.
+ 		 */
+ 		return -EALREADY;
+ 	}
+ 
+ 	/* The firmware variant determines if the device is in bootloader
+ 	 * mode or is running operational firmware. The value 0x01 identifies
+ 	 * the bootloader and the value 0x03 identifies the operational
+ 	 * firmware.
+ 	 *
+ 	 * If the firmware version has changed that means it needs to be reset
+ 	 * to bootloader when operational so the new firmware can be loaded.
+ 	 */
+ 	if (ver->img_type == 0x03)
+ 		return -EINVAL;
+ 
++>>>>>>> 9b16bfbf4116 (Bluetooth: btintel: Move operational checks after version check)
  	/* iBT hardware variants 0x0b, 0x0c, 0x11, 0x12, 0x13, 0x14 support
  	 * only RSA secure boot engine. Hence, the corresponding sfi file will
  	 * have RSA header of 644 bytes followed by Command Buffer.
diff --cc drivers/bluetooth/btusb.c
index 853b361339c6,a30f7ea9be36..000000000000
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@@ -2441,15 -2432,30 +2447,32 @@@ static int btusb_setup_intel_new_get_fw
  			suffix);
  		break;
  	default:
- 		return false;
+ 		return -EINVAL;
  	}
- 	return true;
+ 
+ 	return 0;
  }
  
- static int btusb_intel_download_firmware(struct hci_dev *hdev,
- 					 struct intel_version *ver,
- 					 struct intel_boot_params *params,
- 					 u32 *boot_param)
++<<<<<<< HEAD
++=======
+ static void btusb_setup_intel_newgen_get_fw_name(const struct intel_version_tlv *ver_tlv,
+ 						 char *fw_name, size_t len,
+ 						 const char *suffix)
+ {
+ 	/* The firmware file name for new generation controllers will be
+ 	 * ibt-<cnvi_top type+cnvi_top step>-<cnvr_top type+cnvr_top step>
+ 	 */
+ 	snprintf(fw_name, len, "intel/ibt-%04x-%04x.%s",
+ 		 INTEL_CNVX_TOP_PACK_SWAB(INTEL_CNVX_TOP_TYPE(ver_tlv->cnvi_top),
+ 					  INTEL_CNVX_TOP_STEP(ver_tlv->cnvi_top)),
+ 		 INTEL_CNVX_TOP_PACK_SWAB(INTEL_CNVX_TOP_TYPE(ver_tlv->cnvr_top),
+ 					  INTEL_CNVX_TOP_STEP(ver_tlv->cnvr_top)),
+ 		 suffix);
+ }
+ 
+ static int btusb_intel_download_firmware_newgen(struct hci_dev *hdev,
+ 						struct intel_version_tlv *ver,
+ 						u32 *boot_param)
  {
  	const struct firmware *fw;
  	char fwname[64];
@@@ -2488,6 -2528,112 +2545,113 @@@
  		return -EINVAL;
  	}
  
+ 	/* Secure boot engine type should be either 1 (ECDSA) or 0 (RSA) */
+ 	if (ver->sbe_type > 0x01) {
+ 		bt_dev_err(hdev, "Unsupported Intel secure boot engine type (0x%x)",
+ 			   ver->sbe_type);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* If the OTP has no valid Bluetooth device address, then there will
+ 	 * also be no valid address for the operational firmware.
+ 	 */
+ 	if (!bacmp(&ver->otp_bd_addr, BDADDR_ANY)) {
+ 		bt_dev_info(hdev, "No device address configured");
+ 		set_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks);
+ 	}
+ 
+ 	btusb_setup_intel_newgen_get_fw_name(ver, fwname, sizeof(fwname), "sfi");
+ 	err = request_firmware(&fw, fwname, &hdev->dev);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to load Intel firmware file %s (%d)",
+ 			   fwname, err);
+ 		return err;
+ 	}
+ 
+ 	bt_dev_info(hdev, "Found device firmware: %s", fwname);
+ 
+ 	if (fw->size < 644) {
+ 		bt_dev_err(hdev, "Invalid size of firmware file (%zu)",
+ 			   fw->size);
+ 		err = -EBADF;
+ 		goto done;
+ 	}
+ 
+ 	set_bit(BTUSB_DOWNLOADING, &data->flags);
+ 
+ 	/* Start firmware downloading and get boot parameter */
+ 	err = btintel_download_firmware_newgen(hdev, ver, fw, boot_param,
+ 					       INTEL_HW_VARIANT(ver->cnvi_bt),
+ 					       ver->sbe_type);
+ 	if (err < 0) {
+ 		if (err == -EALREADY) {
+ 			/* Firmware has already been loaded */
+ 			set_bit(BTUSB_FIRMWARE_LOADED, &data->flags);
+ 			err = 0;
+ 			goto done;
+ 		}
+ 
+ 		/* When FW download fails, send Intel Reset to retry
+ 		 * FW download.
+ 		 */
+ 		btintel_reset_to_bootloader(hdev);
+ 		goto done;
+ 	}
+ 	set_bit(BTUSB_FIRMWARE_LOADED, &data->flags);
+ 
+ 	bt_dev_info(hdev, "Waiting for firmware download to complete");
+ 
+ 	/* Before switching the device into operational mode and with that
+ 	 * booting the loaded firmware, wait for the bootloader notification
+ 	 * that all fragments have been successfully received.
+ 	 *
+ 	 * When the event processing receives the notification, then the
+ 	 * BTUSB_DOWNLOADING flag will be cleared.
+ 	 *
+ 	 * The firmware loading should not take longer than 5 seconds
+ 	 * and thus just timeout if that happens and fail the setup
+ 	 * of this device.
+ 	 */
+ 	err = wait_on_bit_timeout(&data->flags, BTUSB_DOWNLOADING,
+ 				  TASK_INTERRUPTIBLE,
+ 				  msecs_to_jiffies(5000));
+ 	if (err == -EINTR) {
+ 		bt_dev_err(hdev, "Firmware loading interrupted");
+ 		goto done;
+ 	}
+ 
+ 	if (err) {
+ 		bt_dev_err(hdev, "Firmware loading timeout");
+ 		err = -ETIMEDOUT;
+ 		btintel_reset_to_bootloader(hdev);
+ 		goto done;
+ 	}
+ 
+ 	if (test_bit(BTUSB_FIRMWARE_FAILED, &data->flags)) {
+ 		bt_dev_err(hdev, "Firmware loading failed");
+ 		err = -ENOEXEC;
+ 		goto done;
+ 	}
+ 
+ done:
+ 	release_firmware(fw);
+ 	return err;
+ }
+ 
++>>>>>>> 9b16bfbf4116 (Bluetooth: btintel: Move operational checks after version check)
+ static int btusb_intel_download_firmware(struct hci_dev *hdev,
+ 					 struct intel_version *ver,
+ 					 struct intel_boot_params *params,
+ 					 u32 *boot_param)
+ {
+ 	const struct firmware *fw;
+ 	char fwname[64];
+ 	int err;
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 
+ 	if (!ver || !params)
+ 		return -EINVAL;
+ 
  	btintel_version_info(hdev, ver);
  
  	/* The firmware variant determines if the device is in bootloader
* Unmerged path drivers/bluetooth/btintel.c
* Unmerged path drivers/bluetooth/btusb.c
