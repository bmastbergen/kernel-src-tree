selftests: xsk: Remove sync_mutex_tx and atomic var

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Maciej Fijalkowski <maciej.fijalkowski@intel.com>
commit 0464b1ed07677f869005bde3fade1580b48de67e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/0464b1ed.failed

Although thread_common_ops() are called in both Tx and Rx threads,
testapp_validate() will not spawn Tx thread until Rx thread signals that
it has finished its initialization via condition variable.

Therefore, locking in thread_common_ops is not needed and furthermore Tx
thread does not have to spin on atomic variable.

Note that this simplification wouldn't be possible if there would still
be a common worker thread.

	Signed-off-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20210329224316.17793-13-maciej.fijalkowski@intel.com
(cherry picked from commit 0464b1ed07677f869005bde3fade1580b48de67e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/xdpxceiver.c
#	tools/testing/selftests/bpf/xdpxceiver.h
diff --cc tools/testing/selftests/bpf/xdpxceiver.c
index 9f8d5dabf30a,35e14ad8097e..000000000000
--- a/tools/testing/selftests/bpf/xdpxceiver.c
+++ b/tools/testing/selftests/bpf/xdpxceiver.c
@@@ -106,24 -115,22 +106,22 @@@ static void __exit_with_error(int error
  #define exit_with_error(error) __exit_with_error(error, __FILE__, __func__, __LINE__)
  
  #define print_ksft_result(void)\
 -	(ksft_test_result_pass("PASS: %s %s %s%s%s\n", configured_mode ? "DRV" : "SKB",\
 -			       test_type == TEST_TYPE_POLL ? "POLL" : "NOPOLL",\
 -			       test_type == TEST_TYPE_TEARDOWN ? "Socket Teardown" : "",\
 -			       test_type == TEST_TYPE_BIDI ? "Bi-directional Sockets" : "",\
 -			       test_type == TEST_TYPE_STATS ? "Stats" : ""))
 +	(ksft_test_result_pass("PASS: %s %s %s%s\n", uut ? "DRV" : "SKB", opt_poll ? "POLL" :\
 +			       "NOPOLL", opt_teardown ? "Socket Teardown" : "",\
 +			       opt_bidi ? "Bi-directional Sockets" : ""))
  
- static void pthread_init_mutex(void)
+ static void init_sync_resources(void)
  {
  	pthread_mutex_init(&sync_mutex, NULL);
- 	pthread_mutex_init(&sync_mutex_tx, NULL);
  	pthread_cond_init(&signal_rx_condition, NULL);
 +	pthread_cond_init(&signal_tx_condition, NULL);
  }
  
- static void pthread_destroy_mutex(void)
+ static void destroy_sync_resources(void)
  {
  	pthread_mutex_destroy(&sync_mutex);
- 	pthread_mutex_destroy(&sync_mutex_tx);
  	pthread_cond_destroy(&signal_rx_condition);
 +	pthread_cond_destroy(&signal_tx_condition);
  }
  
  static void *memset32_htonl(void *dest, u32 val, u32 size)
@@@ -757,8 -750,7 +755,12 @@@ static void worker_pkt_validate(void
  	}
  }
  
++<<<<<<< HEAD
 +static void thread_common_ops(struct ifobject *ifobject, void *bufs, pthread_mutex_t *mutexptr,
 +			      atomic_int *spinningptr)
++=======
+ static void thread_common_ops(struct ifobject *ifobject, void *bufs)
++>>>>>>> 0464b1ed0767 (selftests: xsk: Remove sync_mutex_tx and atomic var)
  {
  	int ctr = 0;
  	int ret;
@@@ -768,20 -769,13 +770,22 @@@
  
  	/* Retry Create Socket if it fails as xsk_socket__create()
  	 * is asynchronous
- 	 *
- 	 * Essential to lock Mutex here to prevent Tx thread from
- 	 * entering before Rx and causing a deadlock
  	 */
- 	pthread_mutex_lock(mutexptr);
  	while (ret && ctr < SOCK_RECONF_CTR) {
++<<<<<<< HEAD
 +		atomic_store(spinningptr, 1);
++=======
++>>>>>>> 0464b1ed0767 (selftests: xsk: Remove sync_mutex_tx and atomic var)
  		xsk_configure_umem(ifobject, bufs, num_frames * XSK_UMEM__DEFAULT_FRAME_SIZE);
  		ret = xsk_configure_socket(ifobject);
  		usleep(USLEEP_MAX);
  		ctr++;
  	}
++<<<<<<< HEAD
 +	atomic_store(spinningptr, 0);
 +	pthread_mutex_unlock(mutexptr);
++=======
++>>>>>>> 0464b1ed0767 (selftests: xsk: Remove sync_mutex_tx and atomic var)
  
  	if (ctr >= SOCK_RECONF_CTR)
  		exit_with_error(ret);
@@@ -797,91 -794,77 +801,101 @@@ static void *worker_testapp_validate(vo
  	struct generic_data data;
  	void *bufs = NULL;
  
++<<<<<<< HEAD
 +	pthread_attr_setstacksize(&attr, THREAD_STACK);
 +
 +	if (!bidi_pass) {
 +		bufs = mmap(NULL, num_frames * XSK_UMEM__DEFAULT_FRAME_SIZE,
 +			    PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
 +		if (bufs == MAP_FAILED)
 +			exit_with_error(errno);
 +
 +		if (strcmp(ifobject->nsname, ""))
 +			switch_namespace(ifobject->ifdict_index);
 +	}
++=======
+ 	if (!bidi_pass)
+ 		thread_common_ops(ifobject, bufs);
++>>>>>>> 0464b1ed0767 (selftests: xsk: Remove sync_mutex_tx and atomic var)
  
 -	for (int i = 0; i < num_frames; i++) {
 -		/*send EOT frame */
 -		if (i == (num_frames - 1))
 -			data.seqnum = -1;
 -		else
 -			data.seqnum = i;
 -		gen_udp_hdr(&data, ifobject, udp_hdr);
 -		gen_ip_hdr(ifobject, ip_hdr);
 -		gen_udp_csum(udp_hdr, ip_hdr);
 -		gen_eth_hdr(ifobject, eth_hdr);
 -		gen_eth_frame(ifobject->umem, i * XSK_UMEM__DEFAULT_FRAME_SIZE);
 -	}
 +	if (ifobject->fv.vector == tx) {
 +		int spinningrxctr = 0;
  
 -	print_verbose("Sending %d packets on interface %s\n",
 -		      (opt_pkt_count - 1), ifobject->ifname);
 -	tx_only_all(ifobject);
 +		if (!bidi_pass)
 +			thread_common_ops(ifobject, bufs, &sync_mutex_tx, &spinning_tx);
  
 -	if (test_type != TEST_TYPE_BIDI || bidi_pass) {
 -		xsk_socket__delete(ifobject->xsk->xsk);
 -		(void)xsk_umem__delete(ifobject->umem->umem);
 -	}
 -	pthread_exit(NULL);
 -}
 +		while (atomic_load(&spinning_rx) && spinningrxctr < SOCK_RECONF_CTR) {
 +			spinningrxctr++;
 +			usleep(USLEEP_MAX);
 +		}
  
 -static void *worker_testapp_validate_rx(void *arg)
 -{
 -	struct ifobject *ifobject = (struct ifobject *)arg;
 -	struct pollfd fds[MAX_SOCKS] = { };
 -	void *bufs = NULL;
 +		print_verbose("Interface [%s] vector [Tx]\n", ifobject->ifname);
 +		for (int i = 0; i < num_frames; i++) {
 +			/*send EOT frame */
 +			if (i == (num_frames - 1))
 +				data.seqnum = -1;
 +			else
 +				data.seqnum = i;
 +			gen_udp_hdr(&data, ifobject, udp_hdr);
 +			gen_ip_hdr(ifobject, ip_hdr);
 +			gen_udp_csum(udp_hdr, ip_hdr);
 +			gen_eth_hdr(ifobject, eth_hdr);
 +			gen_eth_frame(ifobject->umem, i * XSK_UMEM__DEFAULT_FRAME_SIZE);
 +		}
  
++<<<<<<< HEAD
 +		print_verbose("Sending %d packets on interface %s\n",
 +			       (opt_pkt_count - 1), ifobject->ifname);
 +		tx_only_all(ifobject);
 +	} else if (ifobject->fv.vector == rx) {
 +		struct pollfd fds[MAX_SOCKS] = { };
 +		int ret;
++=======
+ 	if (!bidi_pass)
+ 		thread_common_ops(ifobject, bufs);
++>>>>>>> 0464b1ed0767 (selftests: xsk: Remove sync_mutex_tx and atomic var)
 +
 +		if (!bidi_pass)
 +			thread_common_ops(ifobject, bufs, &sync_mutex_tx, &spinning_rx);
  
 -	if (stat_test_type != STAT_TEST_RX_FILL_EMPTY)
 +		print_verbose("Interface [%s] vector [Rx]\n", ifobject->ifname);
  		xsk_populate_fill_ring(ifobject->umem);
  
 -	TAILQ_INIT(&head);
 -	if (debug_pkt_dump) {
 -		pkt_buf = calloc(num_frames, sizeof(*pkt_buf));
 -		if (!pkt_buf)
 -			exit_with_error(errno);
 -	}
 +		TAILQ_INIT(&head);
 +		if (debug_pkt_dump) {
 +			pkt_buf = calloc(num_frames, sizeof(*pkt_buf));
 +			if (!pkt_buf)
 +				exit_with_error(errno);
 +		}
  
 -	fds[0].fd = xsk_socket__fd(ifobject->xsk->xsk);
 -	fds[0].events = POLLIN;
 +		fds[0].fd = xsk_socket__fd(ifobject->xsk->xsk);
 +		fds[0].events = POLLIN;
  
 -	pthread_mutex_lock(&sync_mutex);
 -	pthread_cond_signal(&signal_rx_condition);
 -	pthread_mutex_unlock(&sync_mutex);
 +		pthread_mutex_lock(&sync_mutex);
 +		pthread_cond_signal(&signal_rx_condition);
 +		pthread_mutex_unlock(&sync_mutex);
  
 -	while (1) {
 -		if (test_type != TEST_TYPE_STATS) {
 +		while (1) {
 +			if (opt_poll) {
 +				ret = poll(fds, 1, POLL_TMOUT);
 +				if (ret <= 0)
 +					continue;
 +			}
  			rx_pkt(ifobject->xsk, fds);
  			worker_pkt_validate();
 -		} else {
 -			worker_stats_validate(ifobject);
 +
 +			if (sigvar)
 +				break;
  		}
 -		if (sigvar)
 -			break;
 -	}
  
 -	print_verbose("Received %d packets on interface %s\n",
 -		      pkt_counter, ifobject->ifname);
 +		print_verbose("Received %d packets on interface %s\n",
 +			       pkt_counter, ifobject->ifname);
  
 -	if (test_type == TEST_TYPE_TEARDOWN)
 -		print_verbose("Destroying socket\n");
 +		if (opt_teardown)
 +			print_verbose("Destroying socket\n");
 +	}
  
 -	if ((test_type != TEST_TYPE_BIDI) || bidi_pass) {
 +	if (!opt_bidi || bidi_pass) {
  		xsk_socket__delete(ifobject->xsk->xsk);
  		(void)xsk_umem__delete(ifobject->umem->umem);
  	}
@@@ -1023,25 -1081,25 +1037,25 @@@ int main(int argc, char **argv
  
  	num_frames = ++opt_pkt_count;
  
 -	init_iface(ifdict[0], MAC1, MAC2, IP1, IP2, UDP_PORT1, UDP_PORT2, tx);
 -	init_iface(ifdict[1], MAC2, MAC1, IP2, IP1, UDP_PORT2, UDP_PORT1, rx);
 -
 -	ksft_set_plan(TEST_MODE_MAX * TEST_TYPE_MAX);
 +	init_iface_config(ifaceconfig);
  
- 	pthread_init_mutex();
+ 	init_sync_resources();
  
 -	for (i = 0; i < TEST_MODE_MAX; i++) {
 -		for (j = 0; j < TEST_TYPE_MAX; j++)
 -			run_pkt_test(i, j);
 +	ksft_set_plan(1);
 +
 +	if (!opt_teardown && !opt_bidi) {
 +		testapp_validate();
 +	} else if (opt_teardown && opt_bidi) {
 +		ksft_test_result_fail("ERROR: parameters -T and -B cannot be used together\n");
 +		ksft_exit_xfail();
 +	} else {
 +		testapp_sockets();
  	}
  
 -	for (int i = 0; i < MAX_INTERFACES; i++) {
 -		if (ifdict[i]->ns_fd != -1)
 -			close(ifdict[i]->ns_fd);
 +	for (int i = 0; i < MAX_INTERFACES; i++)
  		free(ifdict[i]);
 -	}
  
- 	pthread_destroy_mutex();
+ 	destroy_sync_resources();
  
  	ksft_exit_pass();
  
diff --cc tools/testing/selftests/bpf/xdpxceiver.h
index f66f399dfb2d,e304229d8a4c..000000000000
--- a/tools/testing/selftests/bpf/xdpxceiver.h
+++ b/tools/testing/selftests/bpf/xdpxceiver.h
@@@ -128,22 -140,17 +128,24 @@@ struct ifobject 
  };
  
  static struct ifobject *ifdict[MAX_INTERFACES];
 -static struct ifobject *ifdict_rx;
 -static struct ifobject *ifdict_tx;
  
  /*threads*/
++<<<<<<< HEAD
 +atomic_int spinning_tx;
 +atomic_int spinning_rx;
++=======
++>>>>>>> 0464b1ed0767 (selftests: xsk: Remove sync_mutex_tx and atomic var)
  pthread_mutex_t sync_mutex;
- pthread_mutex_t sync_mutex_tx;
  pthread_cond_t signal_rx_condition;
 -pthread_t t0, t1;
 +pthread_cond_t signal_tx_condition;
 +pthread_t t0, t1, ns_thread;
  pthread_attr_t attr;
  
 +struct targs {
 +	bool retptr;
 +	int idx;
 +};
 +
  TAILQ_HEAD(head_s, pkt) head = TAILQ_HEAD_INITIALIZER(head);
  struct head_s *head_p;
  struct pkt {
* Unmerged path tools/testing/selftests/bpf/xdpxceiver.c
* Unmerged path tools/testing/selftests/bpf/xdpxceiver.h
