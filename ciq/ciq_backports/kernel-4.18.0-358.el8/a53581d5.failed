net: bridge: mcast: br_multicast_set_port_router takes multicast context as argument

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit a53581d5559eaacaac1b4aed8e2f22c40efa5acc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/a53581d5.failed

Change br_multicast_set_port_router to take port multicast context as
its first argument so we can later use it to control port/vlan mcast
router option.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a53581d5559eaacaac1b4aed8e2f22c40efa5acc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
#	net/bridge/br_private.h
diff --cc net/bridge/br_multicast.c
index def6f1840985,be9d1376e249..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -2975,31 -4222,50 +2975,42 @@@ int br_multicast_set_router(struct net_
  	return err;
  }
  
 -static void
 -br_multicast_rport_del_notify(struct net_bridge_mcast_port *pmctx, bool deleted)
 +static void __del_port_router(struct net_bridge_port *p)
  {
 -	if (!deleted)
 -		return;
 -
 -	/* For backwards compatibility for now, only notify if there is
 -	 * no multicast router anymore for both IPv4 and IPv6.
 -	 */
 -	if (!hlist_unhashed(&pmctx->ip4_rlist))
 -		return;
 -#if IS_ENABLED(CONFIG_IPV6)
 -	if (!hlist_unhashed(&pmctx->ip6_rlist))
 +	if (hlist_unhashed(&p->rlist))
  		return;
 -#endif
 -
 -	br_rtr_notify(pmctx->port->br->dev, pmctx, RTM_DELMDB);
 -	br_port_mc_router_state_change(pmctx->port, false);
 +	hlist_del_init_rcu(&p->rlist);
 +	br_rtr_notify(p->br->dev, p, RTM_DELMDB);
 +	br_port_mc_router_state_change(p, false);
  
  	/* don't allow timer refresh */
 -	if (pmctx->multicast_router == MDB_RTR_TYPE_TEMP)
 -		pmctx->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
 +	if (p->multicast_router == MDB_RTR_TYPE_TEMP)
 +		p->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
  }
  
- int br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val)
+ int br_multicast_set_port_router(struct net_bridge_mcast_port *pmctx,
+ 				 unsigned long val)
  {
++<<<<<<< HEAD
 +	struct net_bridge *br = p->br;
++=======
+ 	struct net_bridge_mcast *brmctx;
++>>>>>>> a53581d5559e (net: bridge: mcast: br_multicast_set_port_router takes multicast context as argument)
  	unsigned long now = jiffies;
  	int err = -EINVAL;
 -	bool del = false;
  
++<<<<<<< HEAD
 +	spin_lock(&br->multicast_lock);
 +	if (p->multicast_router == val) {
++=======
+ 	brmctx = br_multicast_port_ctx_get_global(pmctx);
+ 	spin_lock(&brmctx->br->multicast_lock);
+ 	if (pmctx->multicast_router == val) {
++>>>>>>> a53581d5559e (net: bridge: mcast: br_multicast_set_port_router takes multicast context as argument)
  		/* Refresh the temp router port timer */
 -		if (pmctx->multicast_router == MDB_RTR_TYPE_TEMP) {
 -			mod_timer(&pmctx->ip4_mc_router_timer,
 -				  now + brmctx->multicast_querier_interval);
 -#if IS_ENABLED(CONFIG_IPV6)
 -			mod_timer(&pmctx->ip6_mc_router_timer,
 -				  now + brmctx->multicast_querier_interval);
 -#endif
 -		}
 +		if (p->multicast_router == MDB_RTR_TYPE_TEMP)
 +			mod_timer(&p->multicast_router_timer,
 +				  now + br->multicast_querier_interval);
  		err = 0;
  		goto unlock;
  	}
@@@ -3027,7 -4305,7 +3038,11 @@@
  	}
  	err = 0;
  unlock:
++<<<<<<< HEAD
 +	spin_unlock(&br->multicast_lock);
++=======
+ 	spin_unlock(&brmctx->br->multicast_lock);
++>>>>>>> a53581d5559e (net: bridge: mcast: br_multicast_set_port_router takes multicast context as argument)
  
  	return err;
  }
diff --cc net/bridge/br_private.h
index 30e07225bc94,fcc0fcf44a95..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -729,16 -875,21 +729,28 @@@ void br_multicast_leave_snoopers(struc
  void br_multicast_open(struct net_bridge *br);
  void br_multicast_stop(struct net_bridge *br);
  void br_multicast_dev_del(struct net_bridge *br);
++<<<<<<< HEAD
 +void br_multicast_flood(struct net_bridge_mdb_entry *mdst,
 +			struct sk_buff *skb, bool local_rcv, bool local_orig);
 +int br_multicast_set_router(struct net_bridge *br, unsigned long val);
 +int br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val);
 +int br_multicast_toggle(struct net_bridge *br, unsigned long val);
 +int br_multicast_set_querier(struct net_bridge *br, unsigned long val);
++=======
+ void br_multicast_flood(struct net_bridge_mdb_entry *mdst, struct sk_buff *skb,
+ 			struct net_bridge_mcast *brmctx,
+ 			bool local_rcv, bool local_orig);
+ int br_multicast_set_router(struct net_bridge_mcast *brmctx, unsigned long val);
+ int br_multicast_set_port_router(struct net_bridge_mcast_port *pmctx,
+ 				 unsigned long val);
+ int br_multicast_toggle(struct net_bridge *br, unsigned long val,
+ 			struct netlink_ext_ack *extack);
+ int br_multicast_set_querier(struct net_bridge_mcast *brmctx, unsigned long val);
++>>>>>>> a53581d5559e (net: bridge: mcast: br_multicast_set_port_router takes multicast context as argument)
  int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);
 -int br_multicast_set_igmp_version(struct net_bridge_mcast *brmctx,
 -				  unsigned long val);
 +int br_multicast_set_igmp_version(struct net_bridge *br, unsigned long val);
  #if IS_ENABLED(CONFIG_IPV6)
 -int br_multicast_set_mld_version(struct net_bridge_mcast *brmctx,
 -				 unsigned long val);
 +int br_multicast_set_mld_version(struct net_bridge *br, unsigned long val);
  #endif
  struct net_bridge_mdb_entry *
  br_mdb_ip_get(struct net_bridge *br, struct br_ip *dst);
* Unmerged path net/bridge/br_multicast.c
diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c
index 75be8311a010..81f6bb250faa 100644
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@ -907,7 +907,8 @@ static int br_setport(struct net_bridge_port *p, struct nlattr *tb[],
 	if (tb[IFLA_BRPORT_MULTICAST_ROUTER]) {
 		u8 mcast_router = nla_get_u8(tb[IFLA_BRPORT_MULTICAST_ROUTER]);
 
-		err = br_multicast_set_port_router(p, mcast_router);
+		err = br_multicast_set_port_router(&p->multicast_ctx,
+						   mcast_router);
 		if (err)
 			return err;
 	}
* Unmerged path net/bridge/br_private.h
diff --git a/net/bridge/br_sysfs_if.c b/net/bridge/br_sysfs_if.c
index 251e38b9cd3e..97c6112dabb0 100644
--- a/net/bridge/br_sysfs_if.c
+++ b/net/bridge/br_sysfs_if.c
@@ -254,7 +254,7 @@ static ssize_t show_multicast_router(struct net_bridge_port *p, char *buf)
 static int store_multicast_router(struct net_bridge_port *p,
 				      unsigned long v)
 {
-	return br_multicast_set_port_router(p, v);
+	return br_multicast_set_port_router(&p->multicast_ctx, v);
 }
 static BRPORT_ATTR(multicast_router, 0644, show_multicast_router,
 		   store_multicast_router);
