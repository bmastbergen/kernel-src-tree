net: bridge: switchdev: replay the entire FDB for each port

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Vladimir Oltean <vladimir.oltean@nxp.com>
commit b4454bc6a0fbf2f9edcddd08862175085b990856
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/b4454bc6.failed

Currently when a switchdev port joins a bridge, we replay all FDB
entries pointing towards that port or towards the bridge.

However, this is insufficient in certain situations:

(a) DSA, through its assisted_learning_on_cpu_port logic, snoops
    dynamically learned FDB entries on foreign interfaces.
    These are FDB entries that are pointing neither towards the newly
    joined switchdev port, nor towards the bridge. So these addresses
    would be missed when joining a bridge where a foreign interface has
    already learned some addresses, and they would also linger on if the
    DSA port leaves the bridge before the foreign interface forgets them.
    None of this happens if we replay the entire FDB when the port joins.

(b) There is a desire to treat local FDB entries on a port (i.e. the
    port's termination MAC address) identically to FDB entries pointing
    towards the bridge itself. More details on the reason behind this in
    the next patch. The point is that this cannot be done given the
    current structure of br_fdb_replay() in this situation:
      ip link set swp0 master br0  # br0 inherits its MAC address from swp0
      ip link set swp1 master br0
    What is desirable is that when swp1 joins the bridge, br_fdb_replay()
    also notifies swp1 of br0's MAC address, but this won't in fact
    happen because the MAC address of br0 does not have fdb->dst == NULL
    (it doesn't point towards the bridge), but it has fdb->dst == swp0.
    So our current logic makes it impossible for that address to be
    replayed. But if we dump the entire FDB instead of just the entries
    with fdb->dst == swp1 and fdb->dst == NULL, then the inherited MAC
    address of br0 will be replayed too, which is what we need.

A natural question arises: say there is an FDB entry to be replayed,
like a MAC address dynamically learned on a foreign interface that
belongs to a bridge where no switchdev port has joined yet. If 10
switchdev ports belonging to the same driver join this bridge, one by
one, won't every port get notified 10 times of the foreign FDB entry,
amounting to a total of 100 notifications for this FDB entry in the
switchdev driver?

Well, yes, but this is where the "void *ctx" argument for br_fdb_replay
is useful: every port of the switchdev driver is notified whenever any
other port requests an FDB replay, but because the replay was initiated
by a different port, its context is different from the initiating port's
context, so it ignores those replays.

So the foreign FDB entry will be installed only 10 times, once per port.
This is done so that the following 4 code paths are always well balanced:
(a) addition of foreign FDB entry is replayed when port joins bridge
(b) deletion of foreign FDB entry is replayed when port leaves bridge
(c) addition of foreign FDB entry is notified to all ports currently in bridge
(c) deletion of foreign FDB entry is notified to all ports currently in bridge

	Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b4454bc6a0fbf2f9edcddd08862175085b990856)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_fdb.c
#	net/bridge/br_private.h
#	net/bridge/br_switchdev.c
diff --cc net/bridge/br_fdb.c
index 727e4c29f2d6,be75889ceeba..000000000000
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@@ -703,13 -727,17 +703,21 @@@ static inline size_t fdb_nlmsg_size(voi
  		+ nla_total_size(ETH_ALEN) /* NDA_LLADDR */
  		+ nla_total_size(sizeof(u32)) /* NDA_MASTER */
  		+ nla_total_size(sizeof(u16)) /* NDA_VLAN */
 -		+ nla_total_size(sizeof(struct nda_cacheinfo))
 -		+ nla_total_size(0) /* NDA_FDB_EXT_ATTRS */
 -		+ nla_total_size(sizeof(u8)); /* NFEA_ACTIVITY_NOTIFY */
 +		+ nla_total_size(sizeof(struct nda_cacheinfo));
  }
  
++<<<<<<< HEAD
 +static int br_fdb_replay_one(struct notifier_block *nb,
 +			     struct net_bridge_fdb_entry *fdb,
 +			     struct net_device *dev)
- {
++=======
+ static int br_fdb_replay_one(struct net_bridge *br, struct notifier_block *nb,
+ 			     const struct net_bridge_fdb_entry *fdb,
+ 			     unsigned long action, const void *ctx)
++>>>>>>> b4454bc6a0fb (net: bridge: switchdev: replay the entire FDB for each port)
+ {
+ 	const struct net_bridge_port *p = READ_ONCE(fdb->dst);
+ 	struct net_device *dev = p ? p->dev : br->dev;
  	struct switchdev_notifier_fdb_info item;
  	int err;
  
@@@ -724,7 -753,7 +732,11 @@@
  	return notifier_to_errno(err);
  }
  
++<<<<<<< HEAD
 +int br_fdb_replay(struct net_device *br_dev, struct net_device *dev,
++=======
+ int br_fdb_replay(const struct net_device *br_dev, const void *ctx, bool adding,
++>>>>>>> b4454bc6a0fb (net: bridge: switchdev: replay the entire FDB for each port)
  		  struct notifier_block *nb)
  {
  	struct net_bridge_fdb_entry *fdb;
@@@ -734,22 -764,20 +746,23 @@@
  	if (!netif_is_bridge_master(br_dev))
  		return -EINVAL;
  
- 	if (!netif_is_bridge_port(dev) && !netif_is_bridge_master(dev))
- 		return -EINVAL;
- 
  	br = netdev_priv(br_dev);
  
 -	if (adding)
 -		action = SWITCHDEV_FDB_ADD_TO_DEVICE;
 -	else
 -		action = SWITCHDEV_FDB_DEL_TO_DEVICE;
 -
  	rcu_read_lock();
  
  	hlist_for_each_entry_rcu(fdb, &br->fdb_list, fdb_node) {
++<<<<<<< HEAD
 +		struct net_bridge_port *dst = READ_ONCE(fdb->dst);
 +		struct net_device *dst_dev;
 +
 +		dst_dev = dst ? dst->dev : br->dev;
 +		if (dst_dev && dst_dev != dev)
 +			continue;
 +
 +		err = br_fdb_replay_one(nb, fdb, dst_dev);
++=======
+ 		err = br_fdb_replay_one(br, nb, fdb, action, ctx);
++>>>>>>> b4454bc6a0fb (net: bridge: switchdev: replay the entire FDB for each port)
  		if (err)
  			break;
  	}
diff --cc net/bridge/br_private.h
index 30e07225bc94,c939631428b9..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -647,6 -777,8 +647,11 @@@ int br_fdb_external_learn_del(struct ne
  			      bool swdev_notify);
  void br_fdb_offloaded_set(struct net_bridge *br, struct net_bridge_port *p,
  			  const unsigned char *addr, u16 vid, bool offloaded);
++<<<<<<< HEAD
++=======
+ int br_fdb_replay(const struct net_device *br_dev, const void *ctx, bool adding,
+ 		  struct notifier_block *nb);
++>>>>>>> b4454bc6a0fb (net: bridge: switchdev: replay the entire FDB for each port)
  
  /* br_forward.c */
  enum br_pkt_type {
diff --cc net/bridge/br_switchdev.c
index be7535fa5f0e,8bc3c7fc415f..000000000000
--- a/net/bridge/br_switchdev.c
+++ b/net/bridge/br_switchdev.c
@@@ -185,4 -263,108 +185,106 @@@ void nbp_switchdev_del(struct net_bridg
  
  	if (p->hwdom)
  		nbp_switchdev_hwdom_put(p);
 -
 -	if (p->flags & BR_TX_FWD_OFFLOAD) {
 -		p->flags &= ~BR_TX_FWD_OFFLOAD;
 -		static_branch_dec(&br_switchdev_tx_fwd_offload);
 -	}
  }
++<<<<<<< HEAD
++=======
+ 
+ static int nbp_switchdev_sync_objs(struct net_bridge_port *p, const void *ctx,
+ 				   struct notifier_block *atomic_nb,
+ 				   struct notifier_block *blocking_nb,
+ 				   struct netlink_ext_ack *extack)
+ {
+ 	struct net_device *br_dev = p->br->dev;
+ 	struct net_device *dev = p->dev;
+ 	int err;
+ 
+ 	err = br_vlan_replay(br_dev, dev, ctx, true, blocking_nb, extack);
+ 	if (err && err != -EOPNOTSUPP)
+ 		return err;
+ 
+ 	err = br_mdb_replay(br_dev, dev, ctx, true, blocking_nb, extack);
+ 	if (err && err != -EOPNOTSUPP)
+ 		return err;
+ 
+ 	err = br_fdb_replay(br_dev, ctx, true, atomic_nb);
+ 	if (err && err != -EOPNOTSUPP)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
+ static void nbp_switchdev_unsync_objs(struct net_bridge_port *p,
+ 				      const void *ctx,
+ 				      struct notifier_block *atomic_nb,
+ 				      struct notifier_block *blocking_nb)
+ {
+ 	struct net_device *br_dev = p->br->dev;
+ 	struct net_device *dev = p->dev;
+ 
+ 	br_vlan_replay(br_dev, dev, ctx, false, blocking_nb, NULL);
+ 
+ 	br_mdb_replay(br_dev, dev, ctx, false, blocking_nb, NULL);
+ 
+ 	br_fdb_replay(br_dev, ctx, false, atomic_nb);
+ }
+ 
+ /* Let the bridge know that this port is offloaded, so that it can assign a
+  * switchdev hardware domain to it.
+  */
+ int switchdev_bridge_port_offload(struct net_device *brport_dev,
+ 				  struct net_device *dev, const void *ctx,
+ 				  struct notifier_block *atomic_nb,
+ 				  struct notifier_block *blocking_nb,
+ 				  bool tx_fwd_offload,
+ 				  struct netlink_ext_ack *extack)
+ {
+ 	struct netdev_phys_item_id ppid;
+ 	struct net_bridge_port *p;
+ 	int err;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	p = br_port_get_rtnl(brport_dev);
+ 	if (!p)
+ 		return -ENODEV;
+ 
+ 	err = dev_get_port_parent_id(dev, &ppid, false);
+ 	if (err)
+ 		return err;
+ 
+ 	err = nbp_switchdev_add(p, ppid, tx_fwd_offload, extack);
+ 	if (err)
+ 		return err;
+ 
+ 	err = nbp_switchdev_sync_objs(p, ctx, atomic_nb, blocking_nb, extack);
+ 	if (err)
+ 		goto out_switchdev_del;
+ 
+ 	return 0;
+ 
+ out_switchdev_del:
+ 	nbp_switchdev_del(p);
+ 
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(switchdev_bridge_port_offload);
+ 
+ void switchdev_bridge_port_unoffload(struct net_device *brport_dev,
+ 				     const void *ctx,
+ 				     struct notifier_block *atomic_nb,
+ 				     struct notifier_block *blocking_nb)
+ {
+ 	struct net_bridge_port *p;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	p = br_port_get_rtnl(brport_dev);
+ 	if (!p)
+ 		return;
+ 
+ 	nbp_switchdev_unsync_objs(p, ctx, atomic_nb, blocking_nb);
+ 
+ 	nbp_switchdev_del(p);
+ }
+ EXPORT_SYMBOL_GPL(switchdev_bridge_port_unoffload);
++>>>>>>> b4454bc6a0fb (net: bridge: switchdev: replay the entire FDB for each port)
* Unmerged path net/bridge/br_fdb.c
* Unmerged path net/bridge/br_private.h
* Unmerged path net/bridge/br_switchdev.c
