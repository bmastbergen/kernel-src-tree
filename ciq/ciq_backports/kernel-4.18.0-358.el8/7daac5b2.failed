lib/vsprintf: Print time64_t in human readable format

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 7daac5b2fdf88e3c3e84cf0d577f524beb0244ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/7daac5b2.failed

There are users which print time and date represented by content of
time64_t type in human readable format.

Instead of open coding that each time introduce %ptT[dt][r] specifier.

Few test cases for %ptT specifier has been added as well.

Link: https://lore.kernel.org/r/20200415170046.33374-2-andriy.shevchenko@linux.intel.com
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Reviewed-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
	Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Rewieved-by: Petr Mladek <pmladek@suse.com>
	Signed-off-by: Petr Mladek <pmladek@suse.com>
(cherry picked from commit 7daac5b2fdf88e3c3e84cf0d577f524beb0244ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/core-api/printk-formats.rst
diff --cc Documentation/core-api/printk-formats.rst
index 197a9b73d060,a407cdd09083..000000000000
--- a/Documentation/core-api/printk-formats.rst
+++ b/Documentation/core-api/printk-formats.rst
@@@ -458,8 -444,32 +458,37 @@@ Examples:
  
  Passed by reference.
  
++<<<<<<< HEAD
 +Time and date (struct rtc_time)
 +-------------------------------
++=======
+ Fwnode handles
+ --------------
+ 
+ ::
+ 
+ 	%pfw[fP]
+ 
+ For printing information on fwnode handles. The default is to print the full
+ node name, including the path. The modifiers are functionally equivalent to
+ %pOF above.
+ 
+ 	- f - full name of the node, including the path
+ 	- P - the name of the node including an address (if there is one)
+ 
+ Examples (ACPI)::
+ 
+ 	%pfwf	\_SB.PCI0.CIO2.port@1.endpoint@0	- Full node name
+ 	%pfwP	endpoint@0				- Node name
+ 
+ Examples (OF)::
+ 
+ 	%pfwf	/ocp@68000000/i2c@48072000/camera@10/port/endpoint - Full name
+ 	%pfwP	endpoint				- Node name
+ 
+ Time and date
+ -------------
++>>>>>>> 7daac5b2fdf8 (lib/vsprintf: Print time64_t in human readable format)
  
  ::
  
* Unmerged path Documentation/core-api/printk-formats.rst
diff --git a/lib/test_printf.c b/lib/test_printf.c
index 0fbb55842fc3..9d6a84934389 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -478,7 +478,7 @@ struct_va_format(void)
 }
 
 static void __init
-struct_rtc_time(void)
+time_and_date(void)
 {
 	/* 1543210543 */
 	const struct rtc_time tm = {
@@ -489,14 +489,21 @@ struct_rtc_time(void)
 		.tm_mon = 10,
 		.tm_year = 118,
 	};
+	/* 2019-01-04T15:32:23 */
+	time64_t t = 1546615943;
 
-	test("(%ptR?)", "%pt", &tm);
+	test("(%pt?)", "%pt", &tm);
 	test("2018-11-26T05:35:43", "%ptR", &tm);
 	test("0118-10-26T05:35:43", "%ptRr", &tm);
 	test("05:35:43|2018-11-26", "%ptRt|%ptRd", &tm, &tm);
 	test("05:35:43|0118-10-26", "%ptRtr|%ptRdr", &tm, &tm);
 	test("05:35:43|2018-11-26", "%ptRttr|%ptRdtr", &tm, &tm);
 	test("05:35:43 tr|2018-11-26 tr", "%ptRt tr|%ptRd tr", &tm, &tm);
+
+	test("2019-01-04T15:32:23", "%ptT", &t);
+	test("0119-00-04T15:32:23", "%ptTr", &t);
+	test("15:32:23|2019-01-04", "%ptTt|%ptTd", &t, &t);
+	test("15:32:23|0119-00-04", "%ptTtr|%ptTdr", &t, &t);
 }
 
 static void __init
@@ -663,7 +670,7 @@ test_pointer(void)
 	uuid();
 	dentry();
 	struct_va_format();
-	struct_rtc_time();
+	time_and_date();
 	struct_clk();
 	bitmap();
 	netdev_features();
diff --git a/lib/vsprintf.c b/lib/vsprintf.c
index d162198745e9..c33406bbc787 100644
--- a/lib/vsprintf.c
+++ b/lib/vsprintf.c
@@ -33,6 +33,7 @@
 #include <linux/dcache.h>
 #include <linux/cred.h>
 #include <linux/rtc.h>
+#include <linux/time.h>
 #include <linux/uuid.h>
 #include <linux/of.h>
 #include <net/addrconf.h>
@@ -1800,6 +1801,29 @@ char *rtc_str(char *buf, char *end, const struct rtc_time *tm,
 	return buf;
 }
 
+static noinline_for_stack
+char *time64_str(char *buf, char *end, const time64_t time,
+		 struct printf_spec spec, const char *fmt)
+{
+	struct rtc_time rtc_time;
+	struct tm tm;
+
+	time64_to_tm(time, 0, &tm);
+
+	rtc_time.tm_sec = tm.tm_sec;
+	rtc_time.tm_min = tm.tm_min;
+	rtc_time.tm_hour = tm.tm_hour;
+	rtc_time.tm_mday = tm.tm_mday;
+	rtc_time.tm_mon = tm.tm_mon;
+	rtc_time.tm_year = tm.tm_year;
+	rtc_time.tm_wday = tm.tm_wday;
+	rtc_time.tm_yday = tm.tm_yday;
+
+	rtc_time.tm_isdst = 0;
+
+	return rtc_str(buf, end, &rtc_time, spec, fmt);
+}
+
 static noinline_for_stack
 char *time_and_date(char *buf, char *end, void *ptr, struct printf_spec spec,
 		    const char *fmt)
@@ -1807,8 +1831,10 @@ char *time_and_date(char *buf, char *end, void *ptr, struct printf_spec spec,
 	switch (fmt[1]) {
 	case 'R':
 		return rtc_str(buf, end, (const struct rtc_time *)ptr, spec, fmt);
+	case 'T':
+		return time64_str(buf, end, *(const time64_t *)ptr, spec, fmt);
 	default:
-		return error_string(buf, end, "(%ptR?)", spec);
+		return error_string(buf, end, "(%pt?)", spec);
 	}
 }
 
@@ -2100,8 +2126,9 @@ static char *kobject_string(char *buf, char *end, void *ptr,
  * - 'd[234]' For a dentry name (optionally 2-4 last components)
  * - 'D[234]' Same as 'd' but for a struct file
  * - 'g' For block_device name (gendisk + partition number)
- * - 't[R][dt][r]' For time and date as represented:
+ * - 't[RT][dt][r]' For time and date as represented by:
  *      R    struct rtc_time
+ *      T    time64_t
  * - 'C' For a clock, it prints the name (Common Clock Framework) or address
  *       (legacy clock framework) of the clock
  * - 'Cn' For a clock, it prints the name (Common Clock Framework) or address
