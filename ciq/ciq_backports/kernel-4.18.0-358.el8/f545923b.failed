net: bridge: vlan: notify on vlan add/delete/change flags

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit f545923b4a6bd7abedac50ea3fce76c713be1b74
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/f545923b.failed

Now that we can notify, send a notification on add/del or change of flags.
Notifications are also compressed when possible to reduce their number
and relieve user-space of extra processing, due to that we have to
manually notify after each add/del in order to avoid double
notifications. We try hard to notify only about the vlans which actually
changed, thus a single command can result in multiple notifications
about disjoint ranges if there were vlans which didn't change inside.

	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f545923b4a6bd7abedac50ea3fce76c713be1b74)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_netlink.c
#	net/bridge/br_private.h
diff --cc net/bridge/br_netlink.c
index 46fba65754f0,43dab4066f91..000000000000
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@@ -572,28 -568,26 +572,37 @@@ int br_process_vlan_info(struct net_bri
  			 bool *changed,
  			 struct netlink_ext_ack *extack)
  {
++<<<<<<< HEAD
 +	if (!vinfo_curr->vid || vinfo_curr->vid >= VLAN_VID_MASK)
++=======
+ 	int err, rtm_cmd;
+ 
+ 	if (!br_vlan_valid_id(vinfo_curr->vid, extack))
++>>>>>>> f545923b4a6b (net: bridge: vlan: notify on vlan add/delete/change flags)
  		return -EINVAL;
  
+ 	/* needed for vlan-only NEWVLAN/DELVLAN notifications */
+ 	rtm_cmd = br_afspec_cmd_to_rtm(cmd);
+ 
  	if (vinfo_curr->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN) {
 -		if (!br_vlan_valid_range(vinfo_curr, *vinfo_last, extack))
 +		/* check if we are already processing a range */
 +		if (*vinfo_last)
  			return -EINVAL;
  		*vinfo_last = vinfo_curr;
 +		/* don't allow range of pvids */
 +		if ((*vinfo_last)->flags & BRIDGE_VLAN_INFO_PVID)
 +			return -EINVAL;
  		return 0;
  	}
  
  	if (*vinfo_last) {
  		struct bridge_vlan_info tmp_vinfo;
- 		int v, err;
+ 		int v, v_change_start = 0;
  
 -		if (!br_vlan_valid_range(vinfo_curr, *vinfo_last, extack))
 +		if (!(vinfo_curr->flags & BRIDGE_VLAN_INFO_RANGE_END))
 +			return -EINVAL;
 +
 +		if (vinfo_curr->vid <= (*vinfo_last)->vid)
  			return -EINVAL;
  
  		memcpy(&tmp_vinfo, *vinfo_last,
@@@ -604,8 -600,24 +615,28 @@@
  					   extack);
  			if (err)
  				break;
++<<<<<<< HEAD
 +			cond_resched();
++=======
+ 			if (curr_change) {
+ 				*changed = curr_change;
+ 				if (!v_change_start)
+ 					v_change_start = v;
+ 			} else {
+ 				/* nothing to notify yet */
+ 				if (!v_change_start)
+ 					continue;
+ 				br_vlan_notify(br, p, v_change_start,
+ 					       v - 1, rtm_cmd);
+ 				v_change_start = 0;
+ 			}
++>>>>>>> f545923b4a6b (net: bridge: vlan: notify on vlan add/delete/change flags)
  		}
+ 		/* v_change_start is set only if the last/whole range changed */
+ 		if (v_change_start)
+ 			br_vlan_notify(br, p, v_change_start,
+ 				       v - 1, rtm_cmd);
+ 
  		*vinfo_last = NULL;
  
  		return err;
diff --cc net/bridge/br_private.h
index 1dfdba61458a,a6226ff2f0cc..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -501,6 -502,70 +501,73 @@@ static inline bool br_vlan_should_use(c
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool nbp_state_should_learn(const struct net_bridge_port *p)
+ {
+ 	return p->state == BR_STATE_LEARNING || p->state == BR_STATE_FORWARDING;
+ }
+ 
+ static inline bool br_vlan_valid_id(u16 vid, struct netlink_ext_ack *extack)
+ {
+ 	bool ret = vid > 0 && vid < VLAN_VID_MASK;
+ 
+ 	if (!ret)
+ 		NL_SET_ERR_MSG_MOD(extack, "Vlan id is invalid");
+ 
+ 	return ret;
+ }
+ 
+ static inline bool br_vlan_valid_range(const struct bridge_vlan_info *cur,
+ 				       const struct bridge_vlan_info *last,
+ 				       struct netlink_ext_ack *extack)
+ {
+ 	/* pvid flag is not allowed in ranges */
+ 	if (cur->flags & BRIDGE_VLAN_INFO_PVID) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Pvid isn't allowed in a range");
+ 		return false;
+ 	}
+ 
+ 	/* when cur is the range end, check if:
+ 	 *  - it has range start flag
+ 	 *  - range ids are invalid (end is equal to or before start)
+ 	 */
+ 	if (last) {
+ 		if (cur->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN) {
+ 			NL_SET_ERR_MSG_MOD(extack, "Found a new vlan range start while processing one");
+ 			return false;
+ 		} else if (!(cur->flags & BRIDGE_VLAN_INFO_RANGE_END)) {
+ 			NL_SET_ERR_MSG_MOD(extack, "Vlan range end flag is missing");
+ 			return false;
+ 		} else if (cur->vid <= last->vid) {
+ 			NL_SET_ERR_MSG_MOD(extack, "End vlan id is less than or equal to start vlan id");
+ 			return false;
+ 		}
+ 	}
+ 
+ 	/* check for required range flags */
+ 	if (!(cur->flags & (BRIDGE_VLAN_INFO_RANGE_BEGIN |
+ 			    BRIDGE_VLAN_INFO_RANGE_END))) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Both vlan range flags are missing");
+ 		return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static inline int br_afspec_cmd_to_rtm(int cmd)
+ {
+ 	switch (cmd) {
+ 	case RTM_SETLINK:
+ 		return RTM_NEWVLAN;
+ 	case RTM_DELLINK:
+ 		return RTM_DELVLAN;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> f545923b4a6b (net: bridge: vlan: notify on vlan add/delete/change flags)
  static inline int br_opt_get(const struct net_bridge *br,
  			     enum net_bridge_opts opt)
  {
* Unmerged path net/bridge/br_netlink.c
* Unmerged path net/bridge/br_private.h
diff --git a/net/bridge/br_vlan.c b/net/bridge/br_vlan.c
index 16e20345f720..468b317febc2 100644
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@ -257,6 +257,10 @@ static int __vlan_add(struct net_bridge_vlan *v, u16 flags,
 					  &changed, extack);
 			if (err)
 				goto out_filt;
+
+			if (changed)
+				br_vlan_notify(br, NULL, v->vid, 0,
+					       RTM_NEWVLAN);
 		}
 
 		masterv = br_vlan_get_master(br, v->vid, extack);
@@ -382,13 +386,31 @@ static void __vlan_group_free(struct net_bridge_vlan_group *vg)
 	kfree(vg);
 }
 
-static void __vlan_flush(struct net_bridge_vlan_group *vg)
+static void __vlan_flush(const struct net_bridge *br,
+			 const struct net_bridge_port *p,
+			 struct net_bridge_vlan_group *vg)
 {
 	struct net_bridge_vlan *vlan, *tmp;
+	u16 v_start = 0, v_end = 0;
 
 	__vlan_delete_pvid(vg, vg->pvid);
-	list_for_each_entry_safe(vlan, tmp, &vg->vlan_list, vlist)
+	list_for_each_entry_safe(vlan, tmp, &vg->vlan_list, vlist) {
+		/* take care of disjoint ranges */
+		if (!v_start) {
+			v_start = vlan->vid;
+		} else if (vlan->vid - v_end != 1) {
+			/* found range end, notify and start next one */
+			br_vlan_notify(br, p, v_start, v_end, RTM_DELVLAN);
+			v_start = vlan->vid;
+		}
+		v_end = vlan->vid;
+
 		__vlan_del(vlan);
+	}
+
+	/* notify about the last/whole vlan range */
+	if (v_start)
+		br_vlan_notify(br, p, v_start, v_end, RTM_DELVLAN);
 }
 
 struct sk_buff *br_handle_vlan(struct net_bridge *br,
@@ -718,7 +740,7 @@ void br_vlan_flush(struct net_bridge *br)
 	ASSERT_RTNL();
 
 	vg = br_vlan_group(br);
-	__vlan_flush(vg);
+	__vlan_flush(br, NULL, vg);
 	RCU_INIT_POINTER(br->vlgrp, NULL);
 	synchronize_rcu();
 	__vlan_group_free(vg);
@@ -939,12 +961,15 @@ static void br_vlan_disable_default_pvid(struct net_bridge *br)
 	/* Disable default_pvid on all ports where it is still
 	 * configured.
 	 */
-	if (vlan_default_pvid(br_vlan_group(br), pvid))
-		br_vlan_delete(br, pvid);
+	if (vlan_default_pvid(br_vlan_group(br), pvid)) {
+		if (!br_vlan_delete(br, pvid))
+			br_vlan_notify(br, NULL, pvid, 0, RTM_DELVLAN);
+	}
 
 	list_for_each_entry(p, &br->port_list, list) {
-		if (vlan_default_pvid(nbp_vlan_group(p), pvid))
-			nbp_vlan_delete(p, pvid);
+		if (vlan_default_pvid(nbp_vlan_group(p), pvid) &&
+		    !nbp_vlan_delete(p, pvid))
+			br_vlan_notify(br, p, pvid, 0, RTM_DELVLAN);
 	}
 
 	br->default_pvid = 0;
@@ -986,7 +1011,10 @@ int __br_vlan_set_default_pvid(struct net_bridge *br, u16 pvid,
 				  &vlchange, extack);
 		if (err)
 			goto out;
-		br_vlan_delete(br, old_pvid);
+
+		if (br_vlan_delete(br, old_pvid))
+			br_vlan_notify(br, NULL, old_pvid, 0, RTM_DELVLAN);
+		br_vlan_notify(br, NULL, pvid, 0, RTM_NEWVLAN);
 		set_bit(0, changed);
 	}
 
@@ -1006,7 +1034,9 @@ int __br_vlan_set_default_pvid(struct net_bridge *br, u16 pvid,
 				   &vlchange, extack);
 		if (err)
 			goto err_port;
-		nbp_vlan_delete(p, old_pvid);
+		if (nbp_vlan_delete(p, old_pvid))
+			br_vlan_notify(br, p, old_pvid, 0, RTM_DELVLAN);
+		br_vlan_notify(p->br, p, pvid, 0, RTM_NEWVLAN);
 		set_bit(p->port_no, changed);
 	}
 
@@ -1021,22 +1051,28 @@ int __br_vlan_set_default_pvid(struct net_bridge *br, u16 pvid,
 		if (!test_bit(p->port_no, changed))
 			continue;
 
-		if (old_pvid)
+		if (old_pvid) {
 			nbp_vlan_add(p, old_pvid,
 				     BRIDGE_VLAN_INFO_PVID |
 				     BRIDGE_VLAN_INFO_UNTAGGED,
 				     &vlchange, NULL);
+			br_vlan_notify(p->br, p, old_pvid, 0, RTM_NEWVLAN);
+		}
 		nbp_vlan_delete(p, pvid);
+		br_vlan_notify(br, p, pvid, 0, RTM_DELVLAN);
 	}
 
 	if (test_bit(0, changed)) {
-		if (old_pvid)
+		if (old_pvid) {
 			br_vlan_add(br, old_pvid,
 				    BRIDGE_VLAN_INFO_PVID |
 				    BRIDGE_VLAN_INFO_UNTAGGED |
 				    BRIDGE_VLAN_INFO_BRENTRY,
 				    &vlchange, NULL);
+			br_vlan_notify(br, NULL, old_pvid, 0, RTM_NEWVLAN);
+		}
 		br_vlan_delete(br, pvid);
+		br_vlan_notify(br, NULL, pvid, 0, RTM_DELVLAN);
 	}
 	goto out;
 }
@@ -1129,6 +1165,7 @@ int nbp_vlan_init(struct net_bridge_port *p, struct netlink_ext_ack *extack)
 				   &changed, extack);
 		if (ret)
 			goto err_vlan_add;
+		br_vlan_notify(p->br, p, p->br->default_pvid, 0, RTM_NEWVLAN);
 	}
 out:
 	return ret;
@@ -1210,7 +1247,7 @@ void nbp_vlan_flush(struct net_bridge_port *port)
 	ASSERT_RTNL();
 
 	vg = nbp_vlan_group(port);
-	__vlan_flush(vg);
+	__vlan_flush(port->br, port, vg);
 	RCU_INIT_POINTER(port->vlgrp, NULL);
 	synchronize_rcu();
 	__vlan_group_free(vg);
@@ -1489,8 +1526,8 @@ int br_vlan_bridge_event(struct net_device *dev, unsigned long event, void *ptr)
 {
 	struct netdev_notifier_changeupper_info *info;
 	struct net_bridge *br = netdev_priv(dev);
-	bool changed;
-	int ret = 0;
+	int vlcmd = 0, ret = 0;
+	bool changed = false;
 
 	switch (event) {
 	case NETDEV_REGISTER:
@@ -1498,9 +1535,11 @@ int br_vlan_bridge_event(struct net_device *dev, unsigned long event, void *ptr)
 				  BRIDGE_VLAN_INFO_PVID |
 				  BRIDGE_VLAN_INFO_UNTAGGED |
 				  BRIDGE_VLAN_INFO_BRENTRY, &changed, NULL);
+		vlcmd = RTM_NEWVLAN;
 		break;
 	case NETDEV_UNREGISTER:
-		br_vlan_delete(br, br->default_pvid);
+		changed = !br_vlan_delete(br, br->default_pvid);
+		vlcmd = RTM_DELVLAN;
 		break;
 	case NETDEV_CHANGEUPPER:
 		info = ptr;
@@ -1514,6 +1553,8 @@ int br_vlan_bridge_event(struct net_device *dev, unsigned long event, void *ptr)
 		br_vlan_link_state_change(dev, br);
 		break;
 	}
+	if (changed)
+		br_vlan_notify(br, NULL, br->default_pvid, 0, vlcmd);
 
 	return ret;
 }
