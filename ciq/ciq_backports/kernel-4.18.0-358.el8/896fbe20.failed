printk: use the lockless ringbuffer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author John Ogness <john.ogness@linutronix.de>
commit 896fbe20b4e2333fb55cc9b9b783ebcc49eee7c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/896fbe20.failed

Replace the existing ringbuffer usage and implementation with
lockless ringbuffer usage. Even though the new ringbuffer does not
require locking, all existing locking is left in place. Therefore,
this change is purely replacing the underlining ringbuffer.

Changes that exist due to the ringbuffer replacement:

- The VMCOREINFO has been updated for the new structures.

- Dictionary data is now stored in a separate data buffer from the
  human-readable messages. The dictionary data buffer is set to the
  same size as the message buffer. Therefore, the total required
  memory for both dictionary and message data is
  2 * (2 ^ CONFIG_LOG_BUF_SHIFT) for the initial static buffers and
  2 * log_buf_len (the kernel parameter) for the dynamic buffers.

- Record meta-data is now stored in a separate array of descriptors.
  This is an additional 72 * (2 ^ (CONFIG_LOG_BUF_SHIFT - 5)) bytes
  for the static array and 72 * (log_buf_len >> 5) bytes for the
  dynamic array.

	Signed-off-by: John Ogness <john.ogness@linutronix.de>
	Reviewed-by: Petr Mladek <pmladek@suse.com>
	Signed-off-by: Petr Mladek <pmladek@suse.com>
Link: https://lore.kernel.org/r/20200709132344.760-5-john.ogness@linutronix.de
(cherry picked from commit 896fbe20b4e2333fb55cc9b9b783ebcc49eee7c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/printk/printk.c
diff --cc kernel/printk/printk.c
index c1fedccb5ed4,fec71229169e..000000000000
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@@ -1189,17 -1118,9 +1118,23 @@@ void __init setup_log_buf(int early
  	if (!new_log_buf_len)
  		return;
  
++<<<<<<< HEAD
 +	if (early) {
 +		new_log_buf =
 +			memblock_alloc(new_log_buf_len, LOG_ALIGN);
 +	} else {
 +		new_log_buf = memblock_alloc_nopanic(new_log_buf_len,
 +							  LOG_ALIGN);
 +	}
 +
 +	if (unlikely(!new_log_buf)) {
 +		pr_err("log_buf_len: %lu bytes not available\n",
 +			new_log_buf_len);
++=======
+ 	new_descs_count = new_log_buf_len >> PRB_AVGBITS;
+ 	if (new_descs_count == 0) {
+ 		pr_err("new_log_buf_len: %lu too small\n", new_log_buf_len);
++>>>>>>> 896fbe20b4e2 (printk: use the lockless ringbuffer)
  		return;
  	}
  
@@@ -1810,6 -1833,13 +1847,16 @@@ static void call_console_drivers(const 
  	if (!console_drivers)
  		return;
  
++<<<<<<< HEAD
++=======
+ 	if (console_dropped) {
+ 		dropped_len = snprintf(dropped_text, sizeof(dropped_text),
+ 				       "** %lu printk messages dropped **\n",
+ 				       console_dropped);
+ 		console_dropped = 0;
+ 	}
+ 
++>>>>>>> 896fbe20b4e2 (printk: use the lockless ringbuffer)
  	for_each_console(con) {
  		if (exclusive_console && con != exclusive_console)
  			continue;
* Unmerged path kernel/printk/printk.c
