crypto: drop mask=CRYPTO_ALG_ASYNC from 'shash' tfm allocations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Eric Biggers <ebiggers@google.com>
commit 3d234b3313cd12157946522fe35f5a4574f31169
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/3d234b33.failed

'shash' algorithms are always synchronous, so passing CRYPTO_ALG_ASYNC
in the mask to crypto_alloc_shash() has no effect.  Many users therefore
already don't pass it, but some still do.  This inconsistency can cause
confusion, especially since the way the 'mask' argument works is
somewhat counterintuitive.

Thus, just remove the unneeded CRYPTO_ALG_ASYNC flags.

This patch shouldn't change any actual behavior.

	Signed-off-by: Eric Biggers <ebiggers@google.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 3d234b3313cd12157946522fe35f5a4574f31169)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/drbd/drbd_receiver.c
#	drivers/md/dm-integrity.c
#	fs/ubifs/auth.c
#	security/integrity/evm/evm_crypto.c
diff --cc drivers/block/drbd/drbd_receiver.c
index 10d307d8d54d,ccfcf00f2798..000000000000
--- a/drivers/block/drbd/drbd_receiver.c
+++ b/drivers/block/drbd/drbd_receiver.c
@@@ -3623,7 -3623,7 +3623,11 @@@ static int receive_protocol(struct drbd
  		 * change.
  		 */
  
++<<<<<<< HEAD
 +		peer_integrity_tfm = crypto_alloc_ahash(integrity_alg, 0, CRYPTO_ALG_ASYNC);
++=======
+ 		peer_integrity_tfm = crypto_alloc_shash(integrity_alg, 0, 0);
++>>>>>>> 3d234b3313cd (crypto: drop mask=CRYPTO_ALG_ASYNC from 'shash' tfm allocations)
  		if (IS_ERR(peer_integrity_tfm)) {
  			peer_integrity_tfm = NULL;
  			drbd_err(connection, "peer data-integrity-alg %s not supported\n",
diff --cc drivers/md/dm-integrity.c
index 20414a8dab3e,d4ad0bfee251..000000000000
--- a/drivers/md/dm-integrity.c
+++ b/drivers/md/dm-integrity.c
@@@ -3628,7 -2804,7 +3628,11 @@@ static int get_mac(struct crypto_shash 
  	int r;
  
  	if (a->alg_string) {
++<<<<<<< HEAD
 +		*hash = crypto_alloc_shash(a->alg_string, 0, CRYPTO_ALG_ALLOCATES_MEMORY);
++=======
+ 		*hash = crypto_alloc_shash(a->alg_string, 0, 0);
++>>>>>>> 3d234b3313cd (crypto: drop mask=CRYPTO_ALG_ASYNC from 'shash' tfm allocations)
  		if (IS_ERR(*hash)) {
  			*error = error_alg;
  			r = PTR_ERR(*hash);
diff --cc security/integrity/evm/evm_crypto.c
index 4c8318e7dfeb,1820099dc74b..000000000000
--- a/security/integrity/evm/evm_crypto.c
+++ b/security/integrity/evm/evm_crypto.c
@@@ -100,7 -97,7 +100,11 @@@ static struct shash_desc *init_desc(cha
  		mutex_lock(&mutex);
  		if (*tfm)
  			goto out;
++<<<<<<< HEAD
 +		*tfm = crypto_alloc_shash(algo, 0, CRYPTO_ALG_ASYNC);
++=======
+ 		*tfm = crypto_alloc_shash(algo, 0, CRYPTO_NOLOAD);
++>>>>>>> 3d234b3313cd (crypto: drop mask=CRYPTO_ALG_ASYNC from 'shash' tfm allocations)
  		if (IS_ERR(*tfm)) {
  			rc = PTR_ERR(*tfm);
  			pr_err("Can not allocate %s (reason: %ld)\n", algo, rc);
* Unmerged path fs/ubifs/auth.c
* Unmerged path drivers/block/drbd/drbd_receiver.c
* Unmerged path drivers/md/dm-integrity.c
* Unmerged path fs/ubifs/auth.c
* Unmerged path security/integrity/evm/evm_crypto.c
