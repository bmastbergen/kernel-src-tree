loop: don't allow deleting an unspecified loop device

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Christoph Hellwig <hch@lst.de>
commit e5d66a10324f2a0c31153fd6210d99a9d00ef047
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/e5d66a10.failed

Passing a negative index to loop_lookup while return any unbound device.
Doing that for a delete does not make much sense, so add check to
explicitly reject that case.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
Link: https://lore.kernel.org/r/20210623145908.92973-8-hch@lst.de
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit e5d66a10324f2a0c31153fd6210d99a9d00ef047)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/loop.c
diff --cc drivers/block/loop.c
index c2f478450eaa,b217065a6d67..000000000000
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@@ -2245,15 -2397,47 +2245,51 @@@ static void loop_probe(dev_t dev
  
  	if (max_loop && idx >= max_loop)
  		return;
 -	loop_add(idx);
 -}
  
++<<<<<<< HEAD
 +	mutex_lock(&loop_ctl_mutex);
 +	if (loop_lookup(&lo, idx) < 0)
 +		loop_add(&lo, idx);
++=======
+ static int loop_control_remove(int idx)
+ {
+ 	struct loop_device *lo;
+ 	int ret;
+ 
+ 	if (idx < 0) {
+ 		pr_warn("deleting an unspecified loop device is not supported.\n");
+ 		return -EINVAL;
+ 	}
+ 		
+ 	ret = mutex_lock_killable(&loop_ctl_mutex);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = loop_lookup(&lo, idx);
+ 	if (ret < 0)
+ 		goto out_unlock_ctrl;
+ 
+ 	ret = mutex_lock_killable(&lo->lo_mutex);
+ 	if (ret)
+ 		goto out_unlock_ctrl;
+ 	if (lo->lo_state != Lo_unbound ||
+ 	    atomic_read(&lo->lo_refcnt) > 0) {
+ 		mutex_unlock(&lo->lo_mutex);
+ 		ret = -EBUSY;
+ 		goto out_unlock_ctrl;
+ 	}
+ 	lo->lo_state = Lo_deleting;
+ 	mutex_unlock(&lo->lo_mutex);
+ 
+ 	idr_remove(&loop_index_idr, lo->lo_number);
+ 	loop_remove(lo);
+ out_unlock_ctrl:
++>>>>>>> e5d66a10324f (loop: don't allow deleting an unspecified loop device)
  	mutex_unlock(&loop_ctl_mutex);
 -	return ret;
  }
  
 -static int loop_control_get_free(int idx)
 +static long loop_control_ioctl(struct file *file, unsigned int cmd,
 +			       unsigned long parm)
  {
  	struct loop_device *lo;
  	int ret;
* Unmerged path drivers/block/loop.c
