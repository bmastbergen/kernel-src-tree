ice: Correctly deal with PFs that do not support RDMA

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Dave Ertman <david.m.ertman@intel.com>
commit bfe84435090a6c85271b02a42b1d83fef9ff7cc7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/bfe84435.failed

There are two cases where the current PF does not support RDMA
functionality.  The first is if the NVM loaded on the device is set
to not support RDMA (common_caps.rdma is false).  The second is if
the kernel bonding driver has included the current PF in an active
link aggregate.

When the driver has determined that this PF does not support RDMA, then
auxiliary devices should not be created on the auxiliary bus.  Without
a device on the auxiliary bus, even if the irdma driver is present, there
will be no RDMA activity attempted on this PF.

Currently, in the reset flow, an attempt to create auxiliary devices is
performed without regard to the ability of the PF.  There needs to be a
check in ice_aux_plug_dev (as the central point that creates auxiliary
devices) to see if the PF is in a state to support the functionality.

When disabling and re-enabling RDMA due to the inclusion/removal of the PF
in a link aggregate, we also need to set/clear the bit which controls
auxiliary device creation so that a reset recovery in a link aggregate
situation doesn't try to create auxiliary devices when it shouldn't.

Fixes: f9f5301e7e2d ("ice: Register auxiliary device to provide RDMA")
	Reported-by: Yongxin Liu <yongxin.liu@windriver.com>
	Signed-off-by: Dave Ertman <david.m.ertman@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bfe84435090a6c85271b02a42b1d83fef9ff7cc7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice.h
#	drivers/net/ethernet/intel/ice/ice_idc.c
diff --cc drivers/net/ethernet/intel/ice/ice.h
index 1dbcc6c036b0,3c4f08d20414..000000000000
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@@ -646,4 -687,27 +646,30 @@@ int ice_open_internal(struct net_devic
  int ice_stop(struct net_device *netdev);
  void ice_service_task_schedule(struct ice_pf *pf);
  
++<<<<<<< HEAD
++=======
+ /**
+  * ice_set_rdma_cap - enable RDMA support
+  * @pf: PF struct
+  */
+ static inline void ice_set_rdma_cap(struct ice_pf *pf)
+ {
+ 	if (pf->hw.func_caps.common_cap.rdma && pf->num_rdma_msix) {
+ 		set_bit(ICE_FLAG_RDMA_ENA, pf->flags);
+ 		set_bit(ICE_FLAG_AUX_ENA, pf->flags);
+ 		ice_plug_aux_dev(pf);
+ 	}
+ }
+ 
+ /**
+  * ice_clear_rdma_cap - disable RDMA support
+  * @pf: PF struct
+  */
+ static inline void ice_clear_rdma_cap(struct ice_pf *pf)
+ {
+ 	ice_unplug_aux_dev(pf);
+ 	clear_bit(ICE_FLAG_RDMA_ENA, pf->flags);
+ 	clear_bit(ICE_FLAG_AUX_ENA, pf->flags);
+ }
++>>>>>>> bfe84435090a (ice: Correctly deal with PFs that do not support RDMA)
  #endif /* _ICE_H_ */
* Unmerged path drivers/net/ethernet/intel/ice/ice_idc.c
* Unmerged path drivers/net/ethernet/intel/ice/ice.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_idc.c
