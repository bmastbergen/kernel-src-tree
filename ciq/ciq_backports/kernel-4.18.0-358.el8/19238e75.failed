kvm: x86: Allow userspace to handle emulation errors

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Aaron Lewis <aaronlewis@google.com>
commit 19238e75bd8ed8ffe784bf5b37586e77b2093742
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/19238e75.failed

Add a fallback mechanism to the in-kernel instruction emulator that
allows userspace the opportunity to process an instruction the emulator
was unable to.  When the in-kernel instruction emulator fails to process
an instruction it will either inject a #UD into the guest or exit to
userspace with exit reason KVM_INTERNAL_ERROR.  This is because it does
not know how to proceed in an appropriate manner.  This feature lets
userspace get involved to see if it can figure out a better path
forward.

	Signed-off-by: Aaron Lewis <aaronlewis@google.com>
	Reviewed-by: David Edmondson <david.edmondson@oracle.com>
Message-Id: <20210510144834.658457-2-aaronlewis@google.com>
	Reviewed-by: Jim Mattson <jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 19238e75bd8ed8ffe784bf5b37586e77b2093742)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virt/kvm/api.rst
#	arch/x86/kvm/x86.c
#	include/uapi/linux/kvm.h
diff --cc Documentation/virt/kvm/api.rst
index b9046872a3cf,3b6e3b1628b4..000000000000
--- a/Documentation/virt/kvm/api.rst
+++ b/Documentation/virt/kvm/api.rst
@@@ -6239,6 -6536,17 +6239,20 @@@ the bus lock vm exit can be preempted b
  notifications to userspace can be KVM_EXIT_BUS_LOCK or other reasons.
  KVM_RUN_BUS_LOCK flag is used to distinguish between them.
  
++<<<<<<< HEAD
++=======
+ 7.23 KVM_CAP_PPC_DAWR1
+ ----------------------
+ 
+ :Architectures: ppc
+ :Parameters: none
+ :Returns: 0 on success, -EINVAL when CPU doesn't support 2nd DAWR
+ 
+ This capability can be used to check / enable 2nd DAWR feature provided
+ by POWER10 processor.
+ 
+ 
++>>>>>>> 19238e75bd8e (kvm: x86: Allow userspace to handle emulation errors)
  7.24 KVM_CAP_VM_COPY_ENC_CONTEXT_FROM
  -------------------------------------
  
@@@ -6276,8 -6584,45 +6290,27 @@@ system fingerprint.  To prevent userspa
  by running an enclave in a VM, KVM prevents access to privileged attributes by
  default.
  
 -See Documentation/x86/sgx/2.Kernel-internals.rst for more details.
 -
 -7.26 KVM_CAP_PPC_RPT_INVALIDATE
 --------------------------------
 -
 -:Capability: KVM_CAP_PPC_RPT_INVALIDATE
 -:Architectures: ppc
 -:Type: vm
 -
 -This capability indicates that the kernel is capable of handling
 -H_RPT_INVALIDATE hcall.
 -
 -In order to enable the use of H_RPT_INVALIDATE in the guest,
 -user space might have to advertise it for the guest. For example,
 -IBM pSeries (sPAPR) guest starts using it if "hcall-rpt-invalidate" is
 -present in the "ibm,hypertas-functions" device-tree property.
 -
 -This capability is enabled for hypervisors on platforms like POWER9
 -that support radix MMU.
 +See Documentation/x86/sgx.rst for more details.
  
+ 7.27 KVM_CAP_EXIT_ON_EMULATION_FAILURE
+ --------------------------------------
+ 
+ :Architectures: x86
+ :Parameters: args[0] whether the feature should be enabled or not
+ 
+ When this capability is enabled, an emulation failure will result in an exit
+ to userspace with KVM_INTERNAL_ERROR (except when the emulator was invoked
+ to handle a VMware backdoor instruction). Furthermore, KVM will now provide up
+ to 15 instruction bytes for any exit to userspace resulting from an emulation
+ failure.  When these exits to userspace occur use the emulation_failure struct
+ instead of the internal struct.  They both have the same layout, but the
+ emulation_failure struct matches the content better.  It also explicitly
+ defines the 'flags' field which is used to describe the fields in the struct
+ that are valid (ie: if KVM_INTERNAL_ERROR_EMULATION_FLAG_INSTRUCTION_BYTES is
+ set in the 'flags' field then both 'insn_size' and 'insn_bytes' have valid data
+ in them.)
+ 
+ 
  8. Other capabilities.
  ======================
  
diff --cc arch/x86/kvm/x86.c
index 274678e70ff8,17468d983fbd..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -3985,8 -4009,13 +3985,13 @@@ int kvm_vm_ioctl_check_extension(struc
  	case KVM_CAP_SGX_ATTRIBUTE:
  #endif
  	case KVM_CAP_VM_COPY_ENC_CONTEXT_FROM:
++<<<<<<< HEAD
++=======
+ 	case KVM_CAP_SREGS2:
+ 	case KVM_CAP_EXIT_ON_EMULATION_FAILURE:
++>>>>>>> 19238e75bd8e (kvm: x86: Allow userspace to handle emulation errors)
  		r = 1;
  		break;
 -	case KVM_CAP_EXIT_HYPERCALL:
 -		r = KVM_EXIT_HYPERCALL_VALID_MASK;
 -		break;
  	case KVM_CAP_SET_GUEST_DEBUG2:
  		return KVM_GUESTDBG_VALID_MASK;
  #ifdef CONFIG_KVM_XEN
@@@ -5590,6 -5642,21 +5595,24 @@@ split_irqchip_unlock
  		if (kvm_x86_ops.vm_copy_enc_context_from)
  			r = kvm_x86_ops.vm_copy_enc_context_from(kvm, cap->args[0]);
  		return r;
++<<<<<<< HEAD
++=======
+ 	case KVM_CAP_EXIT_HYPERCALL:
+ 		if (cap->args[0] & ~KVM_EXIT_HYPERCALL_VALID_MASK) {
+ 			r = -EINVAL;
+ 			break;
+ 		}
+ 		kvm->arch.hypercall_exit_enabled = cap->args[0];
+ 		r = 0;
+ 		break;
+ 	case KVM_CAP_EXIT_ON_EMULATION_FAILURE:
+ 		r = -EINVAL;
+ 		if (cap->args[0] & ~1)
+ 			break;
+ 		kvm->arch.exit_on_emulation_error = cap->args[0];
+ 		r = 0;
+ 		break;
++>>>>>>> 19238e75bd8e (kvm: x86: Allow userspace to handle emulation errors)
  	default:
  		r = -EINVAL;
  		break;
diff --cc include/uapi/linux/kvm.h
index 1e90d5a48059,68c9e6d8bbda..000000000000
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@@ -1079,6 -1103,14 +1101,16 @@@ struct kvm_ppc_resize_hpt 
  #define KVM_CAP_SET_GUEST_DEBUG2 195
  #define KVM_CAP_SGX_ATTRIBUTE 196
  #define KVM_CAP_VM_COPY_ENC_CONTEXT_FROM 197
++<<<<<<< HEAD
++=======
+ #define KVM_CAP_PTP_KVM 198
+ #define KVM_CAP_HYPERV_ENFORCE_CPUID 199
+ #define KVM_CAP_SREGS2 200
+ #define KVM_CAP_EXIT_HYPERCALL 201
+ #define KVM_CAP_PPC_RPT_INVALIDATE 202
+ #define KVM_CAP_BINARY_STATS_FD 203
+ #define KVM_CAP_EXIT_ON_EMULATION_FAILURE 204
++>>>>>>> 19238e75bd8e (kvm: x86: Allow userspace to handle emulation errors)
  
  #ifdef KVM_CAP_IRQ_ROUTING
  
* Unmerged path Documentation/virt/kvm/api.rst
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 239117a06e1f..d4c15caa9230 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -1103,6 +1103,12 @@ struct kvm_arch {
 	bool exception_payload_enabled;
 
 	bool bus_lock_detection_enabled;
+	/*
+	 * If exit_on_emulation_error is set, and the in-kernel instruction
+	 * emulator fails to emulate an instruction, allow userspace
+	 * the opportunity to look at it.
+	 */
+	bool exit_on_emulation_error;
 
 	/* Guest can access the SGX PROVISIONKEY. */
 	bool sgx_provisioning_allowed;
* Unmerged path arch/x86/kvm/x86.c
* Unmerged path include/uapi/linux/kvm.h
