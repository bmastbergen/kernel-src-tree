KVM: stats: Add halt_wait_ns stats for all architectures

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Jing Zhang <jingzhangos@google.com>
commit 87bcc5fa092f82a9890f9e73e4f4c7016ef64049
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/87bcc5fa.failed

Add simple stats halt_wait_ns to record the time a VCPU has spent on
waiting for all architectures (not just powerpc).

	Signed-off-by: Jing Zhang <jingzhangos@google.com>
Message-Id: <20210802165633.1866976-5-jingzhangos@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 87bcc5fa092f82a9890f9e73e4f4c7016ef64049)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/kvm_host.h
#	arch/powerpc/kvm/book3s.c
#	arch/powerpc/kvm/booke.c
#	include/linux/kvm_host.h
#	include/linux/kvm_types.h
diff --cc arch/powerpc/include/asm/kvm_host.h
index 68394cde4bf7,4931d03e5799..000000000000
--- a/arch/powerpc/include/asm/kvm_host.h
+++ b/arch/powerpc/include/asm/kvm_host.h
@@@ -113,14 -103,7 +113,17 @@@ struct kvm_vcpu_stat 
  	u64 emulated_inst_exits;
  	u64 dec_exits;
  	u64 ext_intr_exits;
++<<<<<<< HEAD
 +	u64 halt_poll_success_ns;
 +	u64 halt_poll_fail_ns;
 +	u64 halt_wait_ns;
 +	u64 halt_successful_poll;
 +	u64 halt_attempted_poll;
++=======
++>>>>>>> 87bcc5fa092f (KVM: stats: Add halt_wait_ns stats for all architectures)
  	u64 halt_successful_wait;
 +	u64 halt_poll_invalid;
 +	u64 halt_wakeup;
  	u64 dbell_exits;
  	u64 gdbell_exits;
  	u64 ld;
diff --cc arch/powerpc/kvm/book3s.c
index 5063a9817c96,b785f6772391..000000000000
--- a/arch/powerpc/kvm/book3s.c
+++ b/arch/powerpc/kvm/book3s.c
@@@ -42,37 -38,61 +42,95 @@@
  
  /* #define EXIT_DEBUG */
  
++<<<<<<< HEAD
 +struct kvm_stats_debugfs_item debugfs_entries[] = {
 +	VCPU_STAT("exits", sum_exits),
 +	VCPU_STAT("mmio", mmio_exits),
 +	VCPU_STAT("sig", signal_exits),
 +	VCPU_STAT("sysc", syscall_exits),
 +	VCPU_STAT("inst_emu", emulated_inst_exits),
 +	VCPU_STAT("dec", dec_exits),
 +	VCPU_STAT("ext_intr", ext_intr_exits),
 +	VCPU_STAT("queue_intr", queue_intr),
 +	VCPU_STAT("halt_poll_success_ns", halt_poll_success_ns),
 +	VCPU_STAT("halt_poll_fail_ns", halt_poll_fail_ns),
 +	VCPU_STAT("halt_wait_ns", halt_wait_ns),
 +	VCPU_STAT("halt_successful_poll", halt_successful_poll),
 +	VCPU_STAT("halt_attempted_poll", halt_attempted_poll),
 +	VCPU_STAT("halt_successful_wait", halt_successful_wait),
 +	VCPU_STAT("halt_poll_invalid", halt_poll_invalid),
 +	VCPU_STAT("halt_wakeup", halt_wakeup),
 +	VCPU_STAT("pf_storage", pf_storage),
 +	VCPU_STAT("sp_storage", sp_storage),
 +	VCPU_STAT("pf_instruc", pf_instruc),
 +	VCPU_STAT("sp_instruc", sp_instruc),
 +	VCPU_STAT("ld", ld),
 +	VCPU_STAT("ld_slow", ld_slow),
 +	VCPU_STAT("st", st),
 +	VCPU_STAT("st_slow", st_slow),
 +	VCPU_STAT("pthru_all", pthru_all),
 +	VCPU_STAT("pthru_host", pthru_host),
 +	VCPU_STAT("pthru_bad_aff", pthru_bad_aff),
 +	VM_STAT("largepages_2M", num_2M_pages, .mode = 0444),
 +	VM_STAT("largepages_1G", num_1G_pages, .mode = 0444),
 +	{ NULL }
++=======
+ const struct _kvm_stats_desc kvm_vm_stats_desc[] = {
+ 	KVM_GENERIC_VM_STATS(),
+ 	STATS_DESC_ICOUNTER(VM, num_2M_pages),
+ 	STATS_DESC_ICOUNTER(VM, num_1G_pages)
+ };
+ 
+ const struct kvm_stats_header kvm_vm_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vm_stats_desc),
+ 	.id_offset = sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vm_stats_desc),
+ };
+ 
+ const struct _kvm_stats_desc kvm_vcpu_stats_desc[] = {
+ 	KVM_GENERIC_VCPU_STATS(),
+ 	STATS_DESC_COUNTER(VCPU, sum_exits),
+ 	STATS_DESC_COUNTER(VCPU, mmio_exits),
+ 	STATS_DESC_COUNTER(VCPU, signal_exits),
+ 	STATS_DESC_COUNTER(VCPU, light_exits),
+ 	STATS_DESC_COUNTER(VCPU, itlb_real_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, itlb_virt_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, dtlb_real_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, dtlb_virt_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, syscall_exits),
+ 	STATS_DESC_COUNTER(VCPU, isi_exits),
+ 	STATS_DESC_COUNTER(VCPU, dsi_exits),
+ 	STATS_DESC_COUNTER(VCPU, emulated_inst_exits),
+ 	STATS_DESC_COUNTER(VCPU, dec_exits),
+ 	STATS_DESC_COUNTER(VCPU, ext_intr_exits),
+ 	STATS_DESC_COUNTER(VCPU, halt_successful_wait),
+ 	STATS_DESC_COUNTER(VCPU, dbell_exits),
+ 	STATS_DESC_COUNTER(VCPU, gdbell_exits),
+ 	STATS_DESC_COUNTER(VCPU, ld),
+ 	STATS_DESC_COUNTER(VCPU, st),
+ 	STATS_DESC_COUNTER(VCPU, pf_storage),
+ 	STATS_DESC_COUNTER(VCPU, pf_instruc),
+ 	STATS_DESC_COUNTER(VCPU, sp_storage),
+ 	STATS_DESC_COUNTER(VCPU, sp_instruc),
+ 	STATS_DESC_COUNTER(VCPU, queue_intr),
+ 	STATS_DESC_COUNTER(VCPU, ld_slow),
+ 	STATS_DESC_COUNTER(VCPU, st_slow),
+ 	STATS_DESC_COUNTER(VCPU, pthru_all),
+ 	STATS_DESC_COUNTER(VCPU, pthru_host),
+ 	STATS_DESC_COUNTER(VCPU, pthru_bad_aff)
+ };
+ 
+ const struct kvm_stats_header kvm_vcpu_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vcpu_stats_desc),
+ 	.id_offset = sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vcpu_stats_desc),
++>>>>>>> 87bcc5fa092f (KVM: stats: Add halt_wait_ns stats for all architectures)
  };
  
  static inline void kvmppc_update_int_pending(struct kvm_vcpu *vcpu,
diff --cc arch/powerpc/kvm/booke.c
index f7ec42fd14d5,977801c83aff..000000000000
--- a/arch/powerpc/kvm/booke.c
+++ b/arch/powerpc/kvm/booke.c
@@@ -46,29 -36,54 +46,80 @@@
  
  unsigned long kvmppc_booke_handlers;
  
++<<<<<<< HEAD
 +struct kvm_stats_debugfs_item debugfs_entries[] = {
 +	VCPU_STAT("mmio", mmio_exits),
 +	VCPU_STAT("sig", signal_exits),
 +	VCPU_STAT("itlb_r", itlb_real_miss_exits),
 +	VCPU_STAT("itlb_v", itlb_virt_miss_exits),
 +	VCPU_STAT("dtlb_r", dtlb_real_miss_exits),
 +	VCPU_STAT("dtlb_v", dtlb_virt_miss_exits),
 +	VCPU_STAT("sysc", syscall_exits),
 +	VCPU_STAT("isi", isi_exits),
 +	VCPU_STAT("dsi", dsi_exits),
 +	VCPU_STAT("inst_emu", emulated_inst_exits),
 +	VCPU_STAT("dec", dec_exits),
 +	VCPU_STAT("ext_intr", ext_intr_exits),
 +	VCPU_STAT("halt_successful_poll", halt_successful_poll),
 +	VCPU_STAT("halt_attempted_poll", halt_attempted_poll),
 +	VCPU_STAT("halt_poll_invalid", halt_poll_invalid),
 +	VCPU_STAT("halt_wakeup", halt_wakeup),
 +	VCPU_STAT("doorbell", dbell_exits),
 +	VCPU_STAT("guest doorbell", gdbell_exits),
 +	VCPU_STAT("halt_poll_success_ns", halt_poll_success_ns),
 +	VCPU_STAT("halt_poll_fail_ns", halt_poll_fail_ns),
 +	VM_STAT("remote_tlb_flush", remote_tlb_flush),
 +	{ NULL }
++=======
+ const struct _kvm_stats_desc kvm_vm_stats_desc[] = {
+ 	KVM_GENERIC_VM_STATS(),
+ 	STATS_DESC_ICOUNTER(VM, num_2M_pages),
+ 	STATS_DESC_ICOUNTER(VM, num_1G_pages)
+ };
+ 
+ const struct kvm_stats_header kvm_vm_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vm_stats_desc),
+ 	.id_offset = sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vm_stats_desc),
+ };
+ 
+ const struct _kvm_stats_desc kvm_vcpu_stats_desc[] = {
+ 	KVM_GENERIC_VCPU_STATS(),
+ 	STATS_DESC_COUNTER(VCPU, sum_exits),
+ 	STATS_DESC_COUNTER(VCPU, mmio_exits),
+ 	STATS_DESC_COUNTER(VCPU, signal_exits),
+ 	STATS_DESC_COUNTER(VCPU, light_exits),
+ 	STATS_DESC_COUNTER(VCPU, itlb_real_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, itlb_virt_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, dtlb_real_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, dtlb_virt_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, syscall_exits),
+ 	STATS_DESC_COUNTER(VCPU, isi_exits),
+ 	STATS_DESC_COUNTER(VCPU, dsi_exits),
+ 	STATS_DESC_COUNTER(VCPU, emulated_inst_exits),
+ 	STATS_DESC_COUNTER(VCPU, dec_exits),
+ 	STATS_DESC_COUNTER(VCPU, ext_intr_exits),
+ 	STATS_DESC_COUNTER(VCPU, halt_successful_wait),
+ 	STATS_DESC_COUNTER(VCPU, dbell_exits),
+ 	STATS_DESC_COUNTER(VCPU, gdbell_exits),
+ 	STATS_DESC_COUNTER(VCPU, ld),
+ 	STATS_DESC_COUNTER(VCPU, st),
+ 	STATS_DESC_COUNTER(VCPU, pthru_all),
+ 	STATS_DESC_COUNTER(VCPU, pthru_host),
+ 	STATS_DESC_COUNTER(VCPU, pthru_bad_aff)
+ };
+ 
+ const struct kvm_stats_header kvm_vcpu_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vcpu_stats_desc),
+ 	.id_offset = sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vcpu_stats_desc),
++>>>>>>> 87bcc5fa092f (KVM: stats: Add halt_wait_ns stats for all architectures)
  };
  
  /* TODO: use vcpu_printf() */
diff --cc include/linux/kvm_host.h
index 53ea2b6e9d9d,58a8ffee265e..000000000000
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@@ -1250,27 -1347,166 +1250,128 @@@ enum kvm_stat_kind 
  
  struct kvm_stat_data {
  	struct kvm *kvm;
 -	const struct _kvm_stats_desc *desc;
 -	enum kvm_stat_kind kind;
 +	struct kvm_stats_debugfs_item *dbgfs_item;
  };
  
 -struct _kvm_stats_desc {
 -	struct kvm_stats_desc desc;
 -	char name[KVM_STATS_NAME_SIZE];
 +struct kvm_stats_debugfs_item {
 +	const char *name;
 +	int offset;
 +	enum kvm_stat_kind kind;
 +	int mode;
  };
  
 +#define KVM_DBGFS_GET_MODE(dbgfs_item)                                         \
 +	((dbgfs_item)->mode ? (dbgfs_item)->mode : 0644)
 +
++<<<<<<< HEAD
 +#define VM_STAT(n, x, ...) 							\
 +	{ n, offsetof(struct kvm, stat.x), KVM_STAT_VM, ## __VA_ARGS__ }
 +#define VCPU_STAT(n, x, ...)							\
 +	{ n, offsetof(struct kvm_vcpu, stat.x), KVM_STAT_VCPU, ## __VA_ARGS__ }
++=======
+ #define STATS_DESC_COMMON(type, unit, base, exp, sz, bsz)		       \
+ 	.flags = type | unit | base |					       \
+ 		 BUILD_BUG_ON_ZERO(type & ~KVM_STATS_TYPE_MASK) |	       \
+ 		 BUILD_BUG_ON_ZERO(unit & ~KVM_STATS_UNIT_MASK) |	       \
+ 		 BUILD_BUG_ON_ZERO(base & ~KVM_STATS_BASE_MASK),	       \
+ 	.exponent = exp,						       \
+ 	.size = sz,							       \
+ 	.bucket_size = bsz
+ 
+ #define VM_GENERIC_STATS_DESC(stat, type, unit, base, exp, sz, bsz)	       \
+ 	{								       \
+ 		{							       \
+ 			STATS_DESC_COMMON(type, unit, base, exp, sz, bsz),     \
+ 			.offset = offsetof(struct kvm_vm_stat, generic.stat)   \
+ 		},							       \
+ 		.name = #stat,						       \
+ 	}
+ #define VCPU_GENERIC_STATS_DESC(stat, type, unit, base, exp, sz, bsz)	       \
+ 	{								       \
+ 		{							       \
+ 			STATS_DESC_COMMON(type, unit, base, exp, sz, bsz),     \
+ 			.offset = offsetof(struct kvm_vcpu_stat, generic.stat) \
+ 		},							       \
+ 		.name = #stat,						       \
+ 	}
+ #define VM_STATS_DESC(stat, type, unit, base, exp, sz, bsz)		       \
+ 	{								       \
+ 		{							       \
+ 			STATS_DESC_COMMON(type, unit, base, exp, sz, bsz),     \
+ 			.offset = offsetof(struct kvm_vm_stat, stat)	       \
+ 		},							       \
+ 		.name = #stat,						       \
+ 	}
+ #define VCPU_STATS_DESC(stat, type, unit, base, exp, sz, bsz)		       \
+ 	{								       \
+ 		{							       \
+ 			STATS_DESC_COMMON(type, unit, base, exp, sz, bsz),     \
+ 			.offset = offsetof(struct kvm_vcpu_stat, stat)	       \
+ 		},							       \
+ 		.name = #stat,						       \
+ 	}
+ /* SCOPE: VM, VM_GENERIC, VCPU, VCPU_GENERIC */
+ #define STATS_DESC(SCOPE, stat, type, unit, base, exp, sz, bsz)		       \
+ 	SCOPE##_STATS_DESC(stat, type, unit, base, exp, sz, bsz)
+ 
+ #define STATS_DESC_CUMULATIVE(SCOPE, name, unit, base, exponent)	       \
+ 	STATS_DESC(SCOPE, name, KVM_STATS_TYPE_CUMULATIVE,		       \
+ 		unit, base, exponent, 1, 0)
+ #define STATS_DESC_INSTANT(SCOPE, name, unit, base, exponent)		       \
+ 	STATS_DESC(SCOPE, name, KVM_STATS_TYPE_INSTANT,			       \
+ 		unit, base, exponent, 1, 0)
+ #define STATS_DESC_PEAK(SCOPE, name, unit, base, exponent)		       \
+ 	STATS_DESC(SCOPE, name, KVM_STATS_TYPE_PEAK,			       \
+ 		unit, base, exponent, 1, 0)
+ #define STATS_DESC_LINEAR_HIST(SCOPE, name, unit, base, exponent, sz, bsz)     \
+ 	STATS_DESC(SCOPE, name, KVM_STATS_TYPE_LINEAR_HIST,		       \
+ 		unit, base, exponent, sz, bsz)
+ #define STATS_DESC_LOG_HIST(SCOPE, name, unit, base, exponent, sz)	       \
+ 	STATS_DESC(SCOPE, name, KVM_STATS_TYPE_LOG_HIST,		       \
+ 		unit, base, exponent, sz, 0)
+ 
+ /* Cumulative counter, read/write */
+ #define STATS_DESC_COUNTER(SCOPE, name)					       \
+ 	STATS_DESC_CUMULATIVE(SCOPE, name, KVM_STATS_UNIT_NONE,		       \
+ 		KVM_STATS_BASE_POW10, 0)
+ /* Instantaneous counter, read only */
+ #define STATS_DESC_ICOUNTER(SCOPE, name)				       \
+ 	STATS_DESC_INSTANT(SCOPE, name, KVM_STATS_UNIT_NONE,		       \
+ 		KVM_STATS_BASE_POW10, 0)
+ /* Peak counter, read/write */
+ #define STATS_DESC_PCOUNTER(SCOPE, name)				       \
+ 	STATS_DESC_PEAK(SCOPE, name, KVM_STATS_UNIT_NONE,		       \
+ 		KVM_STATS_BASE_POW10, 0)
+ 
+ /* Cumulative time in nanosecond */
+ #define STATS_DESC_TIME_NSEC(SCOPE, name)				       \
+ 	STATS_DESC_CUMULATIVE(SCOPE, name, KVM_STATS_UNIT_SECONDS,	       \
+ 		KVM_STATS_BASE_POW10, -9)
+ /* Linear histogram for time in nanosecond */
+ #define STATS_DESC_LINHIST_TIME_NSEC(SCOPE, name, sz, bsz)		       \
+ 	STATS_DESC_LINEAR_HIST(SCOPE, name, KVM_STATS_UNIT_SECONDS,	       \
+ 		KVM_STATS_BASE_POW10, -9, sz, bsz)
+ /* Logarithmic histogram for time in nanosecond */
+ #define STATS_DESC_LOGHIST_TIME_NSEC(SCOPE, name, sz)			       \
+ 	STATS_DESC_LOG_HIST(SCOPE, name, KVM_STATS_UNIT_SECONDS,	       \
+ 		KVM_STATS_BASE_POW10, -9, sz)
+ 
+ #define KVM_GENERIC_VM_STATS()						       \
+ 	STATS_DESC_COUNTER(VM_GENERIC, remote_tlb_flush)
+ 
+ #define KVM_GENERIC_VCPU_STATS()					       \
+ 	STATS_DESC_COUNTER(VCPU_GENERIC, halt_successful_poll),		       \
+ 	STATS_DESC_COUNTER(VCPU_GENERIC, halt_attempted_poll),		       \
+ 	STATS_DESC_COUNTER(VCPU_GENERIC, halt_poll_invalid),		       \
+ 	STATS_DESC_COUNTER(VCPU_GENERIC, halt_wakeup),			       \
+ 	STATS_DESC_TIME_NSEC(VCPU_GENERIC, halt_poll_success_ns),	       \
+ 	STATS_DESC_TIME_NSEC(VCPU_GENERIC, halt_poll_fail_ns),		       \
+ 	STATS_DESC_TIME_NSEC(VCPU_GENERIC, halt_wait_ns)
++>>>>>>> 87bcc5fa092f (KVM: stats: Add halt_wait_ns stats for all architectures)
  
 +extern struct kvm_stats_debugfs_item debugfs_entries[];
  extern struct dentry *kvm_debugfs_dir;
  
 -ssize_t kvm_stats_read(char *id, const struct kvm_stats_header *header,
 -		       const struct _kvm_stats_desc *desc,
 -		       void *stats, size_t size_stats,
 -		       char __user *user_buffer, size_t size, loff_t *offset);
 -
 -/**
 - * kvm_stats_linear_hist_update() - Update bucket value for linear histogram
 - * statistics data.
 - *
 - * @data: start address of the stats data
 - * @size: the number of bucket of the stats data
 - * @value: the new value used to update the linear histogram's bucket
 - * @bucket_size: the size (width) of a bucket
 - */
 -static inline void kvm_stats_linear_hist_update(u64 *data, size_t size,
 -						u64 value, size_t bucket_size)
 -{
 -	size_t index = div64_u64(value, bucket_size);
 -
 -	index = min(index, size - 1);
 -	++data[index];
 -}
 -
 -/**
 - * kvm_stats_log_hist_update() - Update bucket value for logarithmic histogram
 - * statistics data.
 - *
 - * @data: start address of the stats data
 - * @size: the number of bucket of the stats data
 - * @value: the new value used to update the logarithmic histogram's bucket
 - */
 -static inline void kvm_stats_log_hist_update(u64 *data, size_t size, u64 value)
 -{
 -	size_t index = fls64(value);
 -
 -	index = min(index, size - 1);
 -	++data[index];
 -}
 -
 -#define KVM_STATS_LINEAR_HIST_UPDATE(array, value, bsize)		       \
 -	kvm_stats_linear_hist_update(array, ARRAY_SIZE(array), value, bsize)
 -#define KVM_STATS_LOG_HIST_UPDATE(array, value)				       \
 -	kvm_stats_log_hist_update(array, ARRAY_SIZE(array), value)
 -
 -
 -extern const struct kvm_stats_header kvm_vm_stats_header;
 -extern const struct _kvm_stats_desc kvm_vm_stats_desc[];
 -extern const struct kvm_stats_header kvm_vcpu_stats_header;
 -extern const struct _kvm_stats_desc kvm_vcpu_stats_desc[];
 -
  #if defined(CONFIG_MMU_NOTIFIER) && defined(KVM_ARCH_WANT_MMU_NOTIFIER)
  static inline int mmu_notifier_retry(struct kvm *kvm, unsigned long mmu_seq)
  {
diff --cc include/linux/kvm_types.h
index 8446b08abe44,291ef55125b2..000000000000
--- a/include/linux/kvm_types.h
+++ b/include/linux/kvm_types.h
@@@ -90,5 -76,20 +90,23 @@@ struct kvm_mmu_memory_cache 
  };
  #endif
  
++<<<<<<< HEAD
++=======
+ struct kvm_vm_stat_generic {
+ 	u64 remote_tlb_flush;
+ };
+ 
+ struct kvm_vcpu_stat_generic {
+ 	u64 halt_successful_poll;
+ 	u64 halt_attempted_poll;
+ 	u64 halt_poll_invalid;
+ 	u64 halt_wakeup;
+ 	u64 halt_poll_success_ns;
+ 	u64 halt_poll_fail_ns;
+ 	u64 halt_wait_ns;
+ };
+ 
+ #define KVM_STATS_NAME_SIZE	48
++>>>>>>> 87bcc5fa092f (KVM: stats: Add halt_wait_ns stats for all architectures)
  
  #endif /* __KVM_TYPES_H__ */
* Unmerged path arch/powerpc/include/asm/kvm_host.h
* Unmerged path arch/powerpc/kvm/book3s.c
diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c
index e49c21bec9bd..554a41e20515 100644
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@ -3951,7 +3951,7 @@ static void kvmppc_vcore_blocked(struct kvmppc_vcore *vc)
 
 	/* Attribute wait time */
 	if (do_sleep) {
-		vc->runner->stat.halt_wait_ns +=
+		vc->runner->stat.generic.halt_wait_ns +=
 			ktime_to_ns(cur) - ktime_to_ns(start_wait);
 		/* Attribute failed poll time */
 		if (vc->halt_poll_ns)
* Unmerged path arch/powerpc/kvm/booke.c
* Unmerged path include/linux/kvm_host.h
* Unmerged path include/linux/kvm_types.h
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 04fef38446f1..ecec1746bf93 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -2968,6 +2968,10 @@ void kvm_vcpu_block(struct kvm_vcpu *vcpu)
 	}
 	finish_rcuwait(&vcpu->wait);
 	cur = ktime_get();
+	if (waited) {
+		vcpu->stat.generic.halt_wait_ns +=
+			ktime_to_ns(cur) - ktime_to_ns(poll_end);
+	}
 out:
 	kvm_arch_vcpu_unblocking(vcpu);
 	block_ns = ktime_to_ns(cur) - ktime_to_ns(start);
