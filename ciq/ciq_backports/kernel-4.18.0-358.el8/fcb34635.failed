net: bridge: mrp: Update ring transitions.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Horatiu Vultur <horatiu.vultur@microchip.com>
commit fcb34635854a5a5814227628867ea914a9805384
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/fcb34635.failed

According to the standard IEC 62439-2, the number of transitions needs
to be counted for each transition 'between' ring state open and ring
state closed and not from open state to closed state.

Therefore fix this for both ring and interconnect ring.

	Signed-off-by: Horatiu Vultur <horatiu.vultur@microchip.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fcb34635854a5a5814227628867ea914a9805384)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_mrp.c
diff --cc net/bridge/br_mrp.c
index abe4029a84d1,f7012b7d7ce4..000000000000
--- a/net/bridge/br_mrp.c
+++ b/net/bridge/br_mrp.c
@@@ -493,6 -704,186 +492,189 @@@ int br_mrp_start_test(struct net_bridg
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* Set in state, int state can be only Open or Closed
+  * note: already called with rtnl_lock
+  */
+ int br_mrp_set_in_state(struct net_bridge *br, struct br_mrp_in_state *state)
+ {
+ 	struct br_mrp *mrp = br_mrp_find_in_id(br, state->in_id);
+ 
+ 	if (!mrp)
+ 		return -EINVAL;
+ 
+ 	if (mrp->in_state != state->in_state)
+ 		mrp->in_transitions++;
+ 
+ 	mrp->in_state = state->in_state;
+ 
+ 	br_mrp_switchdev_set_in_state(br, mrp, state->in_state);
+ 
+ 	return 0;
+ }
+ 
+ /* Set in role, in role can be only MIM(Media Interconnection Manager) or
+  * MIC(Media Interconnection Client).
+  * note: already called with rtnl_lock
+  */
+ int br_mrp_set_in_role(struct net_bridge *br, struct br_mrp_in_role *role)
+ {
+ 	struct br_mrp *mrp = br_mrp_find_id(br, role->ring_id);
+ 	enum br_mrp_hw_support support;
+ 	struct net_bridge_port *p;
+ 
+ 	if (!mrp)
+ 		return -EINVAL;
+ 
+ 	if (!br_mrp_get_port(br, role->i_ifindex))
+ 		return -EINVAL;
+ 
+ 	if (role->in_role == BR_MRP_IN_ROLE_DISABLED) {
+ 		u8 state;
+ 
+ 		/* It is not allowed to disable a port that doesn't exist */
+ 		p = rtnl_dereference(mrp->i_port);
+ 		if (!p)
+ 			return -EINVAL;
+ 
+ 		/* Stop the generating MRP_InTest frames */
+ 		cancel_delayed_work_sync(&mrp->in_test_work);
+ 		br_mrp_switchdev_send_in_test(br, mrp, 0, 0, 0);
+ 
+ 		/* Remove the port */
+ 		spin_lock_bh(&br->lock);
+ 		state = netif_running(br->dev) ?
+ 				BR_STATE_FORWARDING : BR_STATE_DISABLED;
+ 		p->state = state;
+ 		p->flags &= ~BR_MRP_AWARE;
+ 		spin_unlock_bh(&br->lock);
+ 		br_mrp_port_switchdev_set_state(p, state);
+ 		rcu_assign_pointer(mrp->i_port, NULL);
+ 
+ 		mrp->in_role = role->in_role;
+ 		mrp->in_id = 0;
+ 
+ 		return 0;
+ 	}
+ 
+ 	/* It is not possible to have the same port part of multiple rings */
+ 	if (!br_mrp_unique_ifindex(br, role->i_ifindex))
+ 		return -EINVAL;
+ 
+ 	/* It is not allowed to set a different interconnect port if the mrp
+ 	 * instance has already one. First it needs to be disabled and after
+ 	 * that set the new port
+ 	 */
+ 	if (rcu_access_pointer(mrp->i_port))
+ 		return -EINVAL;
+ 
+ 	p = br_mrp_get_port(br, role->i_ifindex);
+ 	spin_lock_bh(&br->lock);
+ 	p->state = BR_STATE_FORWARDING;
+ 	p->flags |= BR_MRP_AWARE;
+ 	spin_unlock_bh(&br->lock);
+ 	rcu_assign_pointer(mrp->i_port, p);
+ 
+ 	mrp->in_role = role->in_role;
+ 	mrp->in_id = role->in_id;
+ 
+ 	/* If there is an error just bailed out */
+ 	support = br_mrp_switchdev_set_in_role(br, mrp, role->in_id,
+ 					       role->ring_id, role->in_role);
+ 	if (support == BR_MRP_NONE)
+ 		return -EOPNOTSUPP;
+ 
+ 	/* Now detect if the HW actually applied the role or not. If the HW
+ 	 * applied the role it means that the SW will not to do those operations
+ 	 * anymore. For example if the role is MIM then the HW will notify the
+ 	 * SW when interconnect ring is open, but if the is not pushed to the HW
+ 	 * the SW will need to detect when the interconnect ring is open.
+ 	 */
+ 	mrp->in_role_offloaded = support == BR_MRP_SW ? 0 : 1;
+ 
+ 	return 0;
+ }
+ 
+ /* Start to generate MRP_InTest frames, the frames are generated by
+  * HW and if it fails, they are generated by the SW.
+  * note: already called with rtnl_lock
+  */
+ int br_mrp_start_in_test(struct net_bridge *br,
+ 			 struct br_mrp_start_in_test *in_test)
+ {
+ 	struct br_mrp *mrp = br_mrp_find_in_id(br, in_test->in_id);
+ 	enum br_mrp_hw_support support;
+ 
+ 	if (!mrp)
+ 		return -EINVAL;
+ 
+ 	if (mrp->in_role != BR_MRP_IN_ROLE_MIM)
+ 		return -EINVAL;
+ 
+ 	/* Try to push it to the HW and if it fails then continue with SW
+ 	 * implementation and if that also fails then return error.
+ 	 */
+ 	support =  br_mrp_switchdev_send_in_test(br, mrp, in_test->interval,
+ 						 in_test->max_miss,
+ 						 in_test->period);
+ 	if (support == BR_MRP_NONE)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (support == BR_MRP_HW)
+ 		return 0;
+ 
+ 	mrp->in_test_interval = in_test->interval;
+ 	mrp->in_test_end = jiffies + usecs_to_jiffies(in_test->period);
+ 	mrp->in_test_max_miss = in_test->max_miss;
+ 	mrp->in_test_count_miss = 0;
+ 	queue_delayed_work(system_wq, &mrp->in_test_work,
+ 			   usecs_to_jiffies(in_test->interval));
+ 
+ 	return 0;
+ }
+ 
+ /* Determine if the frame type is a ring frame */
+ static bool br_mrp_ring_frame(struct sk_buff *skb)
+ {
+ 	const struct br_mrp_tlv_hdr *hdr;
+ 	struct br_mrp_tlv_hdr _hdr;
+ 
+ 	hdr = skb_header_pointer(skb, sizeof(uint16_t), sizeof(_hdr), &_hdr);
+ 	if (!hdr)
+ 		return false;
+ 
+ 	if (hdr->type == BR_MRP_TLV_HEADER_RING_TEST ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_RING_TOPO ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_RING_LINK_DOWN ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_RING_LINK_UP ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_OPTION)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ /* Determine if the frame type is an interconnect frame */
+ static bool br_mrp_in_frame(struct sk_buff *skb)
+ {
+ 	const struct br_mrp_tlv_hdr *hdr;
+ 	struct br_mrp_tlv_hdr _hdr;
+ 
+ 	hdr = skb_header_pointer(skb, sizeof(uint16_t), sizeof(_hdr), &_hdr);
+ 	if (!hdr)
+ 		return false;
+ 
+ 	if (hdr->type == BR_MRP_TLV_HEADER_IN_TEST ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_IN_TOPO ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_IN_LINK_DOWN ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_IN_LINK_UP ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_IN_LINK_STATUS)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
++>>>>>>> fcb34635854a (net: bridge: mrp: Update ring transitions.)
  /* Process only MRP Test frame. All the other MRP frames are processed by
   * userspace application
   * note: already called with rcu_read_lock
* Unmerged path net/bridge/br_mrp.c
