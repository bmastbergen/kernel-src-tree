sctp: send pmtu probe only if packet loss in Search Complete state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Xin Long <lucien.xin@gmail.com>
commit eacf078cf4c7aa23e9591738511f142cc39b5186
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/eacf078c.failed

This patch is to introduce last_rtx_chunks into sctp_transport to detect
if there's any packet retransmission/loss happened by checking against
asoc's rtx_data_chunks in sctp_transport_pl_send().

If there is, namely, transport->last_rtx_chunks != asoc->rtx_data_chunks,
the pmtu probe will be sent out. Otherwise, increment the pl.raise_count
and return when it's in Search Complete state.

With this patch, if in Search Complete state, which is a long period, it
doesn't need to keep probing the current pmtu unless there's data packet
loss. This will save quite some traffic.

v1->v2:
  - add the missing Fixes tag.

Fixes: 0dac127c0557 ("sctp: do black hole detection in search complete state")
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit eacf078cf4c7aa23e9591738511f142cc39b5186)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/transport.c
diff --cc net/sctp/transport.c
index 510029130fa7,a3d3ca6dd63d..000000000000
--- a/net/sctp/transport.c
+++ b/net/sctp/transport.c
@@@ -273,16 -258,13 +273,21 @@@ void sctp_transport_pmtu(struct sctp_tr
  	sctp_transport_pl_update(transport);
  }
  
 -bool sctp_transport_pl_send(struct sctp_transport *t)
 +void sctp_transport_pl_send(struct sctp_transport *t)
  {
 -	if (t->pl.probe_count < SCTP_MAX_PROBES)
 -		goto out;
 +	pr_debug("%s: PLPMTUD: transport: %p, state: %d, pmtu: %d, size: %d, high: %d\n",
 +		 __func__, t, t->pl.state, t->pl.pmtu, t->pl.probe_size, t->pl.probe_high);
 +
 +	if (t->pl.probe_count < SCTP_MAX_PROBES) {
 +		t->pl.probe_count++;
 +		return;
 +	}
  
++<<<<<<< HEAD
++=======
+ 	t->pl.last_rtx_chunks = t->asoc->rtx_data_chunks;
+ 	t->pl.probe_count = 0;
++>>>>>>> eacf078cf4c7 (sctp: send pmtu probe only if packet loss in Search Complete state)
  	if (t->pl.state == SCTP_PL_BASE) {
  		if (t->pl.probe_size == SCTP_BASE_PLPMTU) { /* BASE_PLPMTU Confirmation Failed */
  			t->pl.state = SCTP_PL_ERROR; /* Base -> Error */
@@@ -314,10 -296,22 +319,26 @@@
  			sctp_assoc_sync_pmtu(t->asoc);
  		}
  	}
++<<<<<<< HEAD
 +	t->pl.probe_count = 1;
++=======
+ 
+ out:
+ 	if (t->pl.state == SCTP_PL_COMPLETE && t->pl.raise_count < 30 &&
+ 	    !t->pl.probe_count && t->pl.last_rtx_chunks == t->asoc->rtx_data_chunks) {
+ 		t->pl.raise_count++;
+ 		return false;
+ 	}
+ 
+ 	pr_debug("%s: PLPMTUD: transport: %p, state: %d, pmtu: %d, size: %d, high: %d\n",
+ 		 __func__, t, t->pl.state, t->pl.pmtu, t->pl.probe_size, t->pl.probe_high);
+ 
+ 	t->pl.probe_count++;
+ 	return true;
++>>>>>>> eacf078cf4c7 (sctp: send pmtu probe only if packet loss in Search Complete state)
  }
  
 -bool sctp_transport_pl_recv(struct sctp_transport *t)
 +void sctp_transport_pl_recv(struct sctp_transport *t)
  {
  	pr_debug("%s: PLPMTUD: transport: %p, state: %d, pmtu: %d, size: %d, high: %d\n",
  		 __func__, t, t->pl.state, t->pl.pmtu, t->pl.probe_size, t->pl.probe_high);
diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 1ca0aea93619..c4701deb2c36 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1006,6 +1006,7 @@ struct sctp_transport {
 	} cacc;
 
 	struct {
+		__u32 last_rtx_chunks;
 		__u16 pmtu;
 		__u16 probe_size;
 		__u16 probe_high;
* Unmerged path net/sctp/transport.c
