block: remove the 1 and 4 vec bvec_slabs entries

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Christoph Hellwig <hch@lst.de>
commit de76fd893074ab2cea132c28ac9efd9d0434215e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/de76fd89.failed

All bios with up to 4 bvecs use the inline bvecs in the bio itself, so
don't bother to define bvec_slabs entries for them.  Also decruftify
the bvec_slabs definition and initialization while we're at it.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit de76fd893074ab2cea132c28ac9efd9d0434215e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/bio.c
diff --cc block/bio.c
index 3992af35a0a5,ae241252ea14..000000000000
--- a/block/bio.c
+++ b/block/bio.c
@@@ -2232,57 -1602,21 +2221,73 @@@ int bioset_init_from_src(struct bio_se
  }
  EXPORT_SYMBOL(bioset_init_from_src);
  
++<<<<<<< HEAD
 +#ifdef CONFIG_BLK_CGROUP
 +/**
 + * bio_associate_blkg - associate a bio with a blkg
 + * @bio: target bio
 + *
 + * Associate @bio with the blkg found from the bio's css and request_queue.
 + * If one is not found, bio_lookup_blkg() creates the blkg.  If a blkg is
 + * already associated, the css is reused and association redone as the
 + * request_queue may have changed.
 + */
 +void bio_associate_blkg(struct bio *bio)
 +{
 +	struct cgroup_subsys_state *css;
 +
 +	rcu_read_lock();
 +
 +	if (bio->bi_blkg)
 +		css = &bio_blkcg(bio)->css;
 +	else
 +		css = blkcg_css();
 +
 +	bio_associate_blkg_from_css(bio, css);
 +
 +	rcu_read_unlock();
 +}
 +EXPORT_SYMBOL_GPL(bio_associate_blkg);
 +#endif /* CONFIG_BLK_CGROUP */
 +
 +static void __init biovec_init_slabs(void)
 +{
 +	int i;
 +
 +	for (i = 0; i < BVEC_POOL_NR; i++) {
 +		int size;
 +		struct biovec_slab *bvs = bvec_slabs + i;
 +
 +		if (bvs->nr_vecs <= BIO_INLINE_VECS) {
 +			bvs->slab = NULL;
 +			continue;
 +		}
 +
 +		size = bvs->nr_vecs * sizeof(struct bio_vec);
 +		bvs->slab = kmem_cache_create(bvs->name, size, 0,
 +                                SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
 +	}
 +}
 +
 +static int __init init_bio(void)
 +{
++=======
+ static int __init init_bio(void)
+ {
+ 	int i;
+ 
+ 	BUILD_BUG_ON(BIO_FLAG_LAST > BVEC_POOL_OFFSET);
+ 
++>>>>>>> de76fd893074 (block: remove the 1 and 4 vec bvec_slabs entries)
  	bio_integrity_init();
- 	biovec_init_slabs();
+ 
+ 	for (i = 0; i < ARRAY_SIZE(bvec_slabs); i++) {
+ 		struct biovec_slab *bvs = bvec_slabs + i;
+ 
+ 		bvs->slab = kmem_cache_create(bvs->name,
+ 				bvs->nr_vecs * sizeof(struct bio_vec), 0,
+ 				SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);
+ 	}
  
  	if (bioset_init(&fs_bio_set, BIO_POOL_SIZE, 0, BIOSET_NEED_BVECS))
  		panic("bio: can't allocate bios\n");
* Unmerged path block/bio.c
