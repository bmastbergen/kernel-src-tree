nfsd: ensure new clients break delegations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author J. Bruce Fields <bfields@redhat.com>
commit 217fd6f625af591e2866bebb8cda778cf85bea2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/217fd6f6.failed

If nfsd already has an open file that it plans to use for IO from
another, it may not need to do another vfs open, but it still may need
to break any delegations in case the existing opens are for another
client.

Symptoms are that we may incorrectly fail to break a delegation on a
write open from a different client, when the delegation-holding client
already has a write open.

Fixes: 28df3d1539de ("nfsd: clients don't need to break their own delegations")
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 217fd6f625af591e2866bebb8cda778cf85bea2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4state.c
diff --cc fs/nfsd/nfs4state.c
index d04e8e6be7db,403c69efdbea..000000000000
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@@ -4815,9 -4877,14 +4815,14 @@@ static __be32 nfs4_get_vfs_file(struct 
  		}
  	}
  	spin_unlock(&fp->fi_lock);
 -	if (nf)
 -		nfsd_file_put(nf);
 +	if (filp)
 +		fput(filp);
  
+ 	status = nfserrno(nfsd_open_break_lease(cur_fh->fh_dentry->d_inode,
+ 								access));
+ 	if (status)
+ 		goto out_put_access;
+ 
  	status = nfsd4_truncate(rqstp, cur_fh, open);
  	if (status)
  		goto out_put_access;
@@@ -6690,12 -6860,21 +6695,30 @@@ out
   */
  static __be32 nfsd_test_lock(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file_lock *lock)
  {
++<<<<<<< HEAD
 +	struct file *file;
 +	__be32 err = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_READ, &file);
 +	if (!err) {
 +		err = nfserrno(vfs_test_lock(file, lock));
 +		fput(file);
 +	}
++=======
+ 	struct nfsd_file *nf;
+ 	__be32 err;
+ 
+ 	err = nfsd_file_acquire(rqstp, fhp, NFSD_MAY_READ, &nf);
+ 	if (err)
+ 		return err;
+ 	fh_lock(fhp); /* to block new leases till after test_lock: */
+ 	err = nfserrno(nfsd_open_break_lease(fhp->fh_dentry->d_inode,
+ 							NFSD_MAY_READ));
+ 	if (err)
+ 		goto out;
+ 	err = nfserrno(vfs_test_lock(nf->nf_file, lock));
+ out:
+ 	fh_unlock(fhp);
+ 	nfsd_file_put(nf);
++>>>>>>> 217fd6f625af (nfsd: ensure new clients break delegations)
  	return err;
  }
  
* Unmerged path fs/nfsd/nfs4state.c
