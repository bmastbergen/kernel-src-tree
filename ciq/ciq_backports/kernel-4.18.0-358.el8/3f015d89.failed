NFSv42: Fix pagecache invalidation after COPY/CLONE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Benjamin Coddington <bcodding@redhat.com>
commit 3f015d89a47cd8855cd92f71fff770095bd885a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/3f015d89.failed

The mechanism in use to allow the client to see the results of COPY/CLONE
is to drop those pages from the pagecache.  This forces the client to read
those pages once more from the server.  However, truncate_pagecache_range()
zeros out partial pages instead of dropping them.  Let us instead use
invalidate_inode_pages2_range() with full-page offsets to ensure the client
properly sees the results of COPY/CLONE operations.

	Cc: <stable@vger.kernel.org> # v4.7+
Fixes: 2e72448b07dc ("NFS: Add COPY nfs operation")
	Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 3f015d89a47cd8855cd92f71fff770095bd885a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs42proc.c
diff --cc fs/nfs/nfs42proc.c
index b00536e115fe,8b21ff1be717..000000000000
--- a/fs/nfs/nfs42proc.c
+++ b/fs/nfs/nfs42proc.c
@@@ -229,6 -273,35 +229,38 @@@ out
  	return status;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * nfs42_copy_dest_done - perform inode cache updates after clone/copy offload
+  * @inode: pointer to destination inode
+  * @pos: destination offset
+  * @len: copy length
+  *
+  * Punch a hole in the inode page cache, so that the NFS client will
+  * know to retrieve new data.
+  * Update the file size if necessary, and then mark the inode as having
+  * invalid cached values for change attribute, ctime, mtime and space used.
+  */
+ static void nfs42_copy_dest_done(struct inode *inode, loff_t pos, loff_t len)
+ {
+ 	loff_t newsize = pos + len;
+ 	loff_t end = newsize - 1;
+ 
+ 	WARN_ON_ONCE(invalidate_inode_pages2_range(inode->i_mapping,
+ 				pos >> PAGE_SHIFT, end >> PAGE_SHIFT));
+ 
+ 	spin_lock(&inode->i_lock);
+ 	if (newsize > i_size_read(inode))
+ 		i_size_write(inode, newsize);
+ 	nfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE |
+ 					     NFS_INO_INVALID_CTIME |
+ 					     NFS_INO_INVALID_MTIME |
+ 					     NFS_INO_INVALID_BLOCKS);
+ 	spin_unlock(&inode->i_lock);
+ }
+ 
++>>>>>>> 3f015d89a47c (NFSv42: Fix pagecache invalidation after COPY/CLONE)
  static ssize_t _nfs42_proc_copy(struct file *src,
  				struct nfs_lock_context *src_lock,
  				struct file *dst,
* Unmerged path fs/nfs/nfs42proc.c
