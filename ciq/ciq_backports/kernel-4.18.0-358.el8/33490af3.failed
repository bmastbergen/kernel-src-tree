mm, mmu_notifier: be explicit about range invalition non-blocking mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Michal Hocko <mhocko@suse.com>
commit 33490af3f5c15757448b6c454ca93b48a333aa1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/33490af3.failed

If invalidate_range_start() is called for !blocking mode then all
callbacks have to guarantee they will no block/sleep.  The same obviously
applies to invalidate_range_end because this operation pairs with the
former and they are called from the same context.  Make sure this is
appropriately documented.

Link: http://lkml.kernel.org/r/20180827112623.8992-3-mhocko@kernel.org
	Signed-off-by: Michal Hocko <mhocko@suse.com>
	Reviewed-by: Jerome Glisse <jglisse@redhat.com>
	Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Juergen Gross <jgross@suse.com>
	Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 33490af3f5c15757448b6c454ca93b48a333aa1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mmu_notifier.h
diff --cc include/linux/mmu_notifier.h
index d924803cea7c,698e371aafe3..000000000000
--- a/include/linux/mmu_notifier.h
+++ b/include/linux/mmu_notifier.h
@@@ -199,13 -151,17 +199,22 @@@ struct mmu_notifier_ops 
  	 * address space but may still be referenced by sptes until
  	 * the last refcount is dropped.
  	 *
++<<<<<<< HEAD
 +	 * If both of these callbacks cannot block, and invalidate_range
 +	 * cannot block, mmu_notifier_ops.flags should have
 +	 * MMU_INVALIDATE_DOES_NOT_BLOCK set.
++=======
+ 	 * If blockable argument is set to false then the callback cannot
+ 	 * sleep and has to return with -EAGAIN. 0 should be returned
+ 	 * otherwise. Please note that if invalidate_range_start approves
+ 	 * a non-blocking behavior then the same applies to
+ 	 * invalidate_range_end.
+ 	 *
++>>>>>>> 33490af3f5c1 (mm, mmu_notifier: be explicit about range invalition non-blocking mode)
  	 */
 -	int (*invalidate_range_start)(struct mmu_notifier *mn,
 +	void (*invalidate_range_start)(struct mmu_notifier *mn,
  				       struct mm_struct *mm,
 -				       unsigned long start, unsigned long end,
 -				       bool blockable);
 +				       unsigned long start, unsigned long end);
  	void (*invalidate_range_end)(struct mmu_notifier *mn,
  				     struct mm_struct *mm,
  				     unsigned long start, unsigned long end);
* Unmerged path include/linux/mmu_notifier.h
