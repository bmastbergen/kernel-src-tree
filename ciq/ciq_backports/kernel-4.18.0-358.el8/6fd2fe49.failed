copy_process(): don't use ksys_close() on cleanups

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 6fd2fe494b17bf2dec37b610d23a43a72b16923a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/6fd2fe49.failed

anon_inode_getfd() should be used *ONLY* in situations when we are
guaranteed to be past the last failure point (including copying the
descriptor number to userland, at that).  And ksys_close() should
not be used for cleanups at all.

anon_inode_getfile() is there for all nontrivial cases like that.
Just use that...

Fixes: b3e583825266 ("clone: add CLONE_PIDFD")
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
	Reviewed-by: Jann Horn <jannh@google.com>
	Signed-off-by: Christian Brauner <christian@brauner.io>
(cherry picked from commit 6fd2fe494b17bf2dec37b610d23a43a72b16923a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/fork.c
diff --cc kernel/fork.c
index 886c2f479b06,399aca51ff75..000000000000
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@@ -1675,13 -1683,35 +1675,45 @@@ static inline void rcu_copy_process(str
  	INIT_LIST_HEAD(&p->rcu_tasks_holdout_list);
  	p->rcu_tasks_idle_cpu = -1;
  #endif /* #ifdef CONFIG_TASKS_RCU */
++<<<<<<< HEAD
 +#ifdef CONFIG_TASKS_TRACE_RCU
 +	p->task_struct_rh->trc_reader_nesting = 0;
 +	p->task_struct_rh->trc_reader_special.s = 0;
 +	INIT_LIST_HEAD(&p->task_struct_rh->trc_holdout_list);
 +#endif /* #ifdef CONFIG_TASKS_TRACE_RCU */
 +}
 +
++=======
+ }
+ 
+ static int pidfd_release(struct inode *inode, struct file *file)
+ {
+ 	struct pid *pid = file->private_data;
+ 
+ 	file->private_data = NULL;
+ 	put_pid(pid);
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_PROC_FS
+ static void pidfd_show_fdinfo(struct seq_file *m, struct file *f)
+ {
+ 	struct pid_namespace *ns = proc_pid_ns(file_inode(m->file));
+ 	struct pid *pid = f->private_data;
+ 
+ 	seq_put_decimal_ull(m, "Pid:\t", pid_nr_ns(pid, ns));
+ 	seq_putc(m, '\n');
+ }
+ #endif
+ 
+ const struct file_operations pidfd_fops = {
+ 	.release = pidfd_release,
+ #ifdef CONFIG_PROC_FS
+ 	.show_fdinfo = pidfd_show_fdinfo,
+ #endif
+ };
+ 
++>>>>>>> 6fd2fe494b17 (copy_process(): don't use ksys_close() on cleanups)
  static void __delayed_free_task(struct rcu_head *rhp)
  {
  	struct task_struct *tsk = container_of(rhp, struct task_struct, rcu);
@@@ -1734,10 -1746,10 +1766,14 @@@ static __latent_entropy struct task_str
  					unsigned long tls,
  					int node)
  {
 -	int pidfd = -1, retval;
 +	int retval;
  	struct task_struct *p;
  	struct multiprocess_signals delayed;
++<<<<<<< HEAD
 +	struct nsproxy *nsp = current->nsproxy;
++=======
+ 	struct file *pidfile = NULL;
++>>>>>>> 6fd2fe494b17 (copy_process(): don't use ksys_close() on cleanups)
  
  	/*
  	 * Don't allow sharing the root directory with processes in a different
@@@ -1986,6 -2016,31 +2022,34 @@@
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * This has to happen after we've potentially unshared the file
+ 	 * descriptor table (so that the pidfd doesn't leak into the child
+ 	 * if the fd table isn't shared).
+ 	 */
+ 	if (clone_flags & CLONE_PIDFD) {
+ 		retval = get_unused_fd_flags(O_RDWR | O_CLOEXEC);
+ 		if (retval < 0)
+ 			goto bad_fork_free_pid;
+ 
+ 		pidfd = retval;
+ 
+ 		pidfile = anon_inode_getfile("[pidfd]", &pidfd_fops, pid,
+ 					      O_RDWR | O_CLOEXEC);
+ 		if (IS_ERR(pidfile)) {
+ 			put_unused_fd(pidfd);
+ 			goto bad_fork_free_pid;
+ 		}
+ 		get_pid(pid);	/* held by pidfile now */
+ 
+ 		retval = put_user(pidfd, parent_tidptr);
+ 		if (retval)
+ 			goto bad_fork_put_pidfd;
+ 	}
+ 
++>>>>>>> 6fd2fe494b17 (copy_process(): don't use ksys_close() on cleanups)
  #ifdef CONFIG_BLOCK
  	p->plug = NULL;
  #endif
@@@ -2157,6 -2219,13 +2224,16 @@@ bad_fork_cancel_cgroup
  	spin_unlock(&current->sighand->siglock);
  	write_unlock_irq(&tasklist_lock);
  	cgroup_cancel_fork(p);
++<<<<<<< HEAD
++=======
+ bad_fork_cgroup_threadgroup_change_end:
+ 	cgroup_threadgroup_change_end(current);
+ bad_fork_put_pidfd:
+ 	if (clone_flags & CLONE_PIDFD) {
+ 		fput(pidfile);
+ 		put_unused_fd(pidfd);
+ 	}
++>>>>>>> 6fd2fe494b17 (copy_process(): don't use ksys_close() on cleanups)
  bad_fork_free_pid:
  	if (pid != &init_struct_pid)
  		free_pid(pid);
* Unmerged path kernel/fork.c
