locking/rtmutex: Provide rt_mutex_slowlock_locked()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit ebbdc41e90ffce8b6bb3cbba1801ede2dd07a89b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/ebbdc41e.failed

Split the inner workings of rt_mutex_slowlock() out into a separate
function, which can be reused by the upcoming RT lock substitutions,
e.g. for rw_semaphores.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
Link: https://lore.kernel.org/r/20210815211302.841971086@linutronix.de
(cherry picked from commit ebbdc41e90ffce8b6bb3cbba1801ede2dd07a89b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/locking/rtmutex.c
diff --cc kernel/locking/rtmutex.c
index dc54c0c2b3d8,3d0b29cb5e63..000000000000
--- a/kernel/locking/rtmutex.c
+++ b/kernel/locking/rtmutex.c
@@@ -1114,9 -1115,10 +1114,16 @@@ static void __sched remove_waiter(struc
   *
   * Must be called with lock->wait_lock held and interrupts disabled
   */
++<<<<<<< HEAD
 +static int __sched __rt_mutex_slowlock(struct rt_mutex *lock, int state,
 +				       struct hrtimer_sleeper *timeout,
 +				       struct rt_mutex_waiter *waiter)
++=======
+ static int __sched rt_mutex_slowlock_block(struct rt_mutex_base *lock,
+ 					   unsigned int state,
+ 					   struct hrtimer_sleeper *timeout,
+ 					   struct rt_mutex_waiter *waiter)
++>>>>>>> ebbdc41e90ff (locking/rtmutex: Provide rt_mutex_slowlock_locked())
  {
  	int ret = 0;
  
@@@ -1166,34 -1168,25 +1173,30 @@@ static void __sched rt_mutex_handle_dea
  	}
  }
  
- /*
-  * Slow path lock function:
+ /**
+  * __rt_mutex_slowlock - Locking slowpath invoked with lock::wait_lock held
+  * @lock:	The rtmutex to block lock
+  * @state:	The task state for sleeping
+  * @chwalk:	Indicator whether full or partial chainwalk is requested
+  * @waiter:	Initializer waiter for blocking
   */
++<<<<<<< HEAD
 +static int __sched rt_mutex_slowlock(struct rt_mutex *lock, int state,
 +				     struct hrtimer_sleeper *timeout,
 +				     enum rtmutex_chainwalk chwalk)
++=======
+ static int __sched __rt_mutex_slowlock(struct rt_mutex_base *lock,
+ 				       unsigned int state,
+ 				       enum rtmutex_chainwalk chwalk,
+ 				       struct rt_mutex_waiter *waiter)
  {
- 	struct rt_mutex_waiter waiter;
- 	unsigned long flags;
- 	int ret = 0;
- 
- 	rt_mutex_init_waiter(&waiter);
+ 	int ret;
  
- 	/*
- 	 * Technically we could use raw_spin_[un]lock_irq() here, but this can
- 	 * be called in early boot if the cmpxchg() fast path is disabled
- 	 * (debug, no architecture support). In this case we will acquire the
- 	 * rtmutex with lock->wait_lock held. But we cannot unconditionally
- 	 * enable interrupts in that early boot case. So we need to use the
- 	 * irqsave/restore variants.
- 	 */
- 	raw_spin_lock_irqsave(&lock->wait_lock, flags);
+ 	lockdep_assert_held(&lock->wait_lock);
  
  	/* Try to acquire the lock again: */
- 	if (try_to_take_rt_mutex(lock, current, NULL)) {
- 		raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
+ 	if (try_to_take_rt_mutex(lock, current, NULL))
  		return 0;
- 	}
  
  	set_current_state(state);
  
@@@ -1218,14 -1206,45 +1216,46 @@@
  	 * unconditionally. We might have to fix that up.
  	 */
  	fixup_rt_mutex_waiters(lock);
+ 	return ret;
+ }
  
- 	raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
+ static inline int __rt_mutex_slowlock_locked(struct rt_mutex_base *lock,
+ 					     unsigned int state)
++>>>>>>> ebbdc41e90ff (locking/rtmutex: Provide rt_mutex_slowlock_locked())
+ {
+ 	struct rt_mutex_waiter waiter;
+ 	int ret;
  
- 	/* Remove pending timer: */
- 	if (unlikely(timeout))
- 		hrtimer_cancel(&timeout->timer);
+ 	rt_mutex_init_waiter(&waiter);
+ 
+ 	ret = __rt_mutex_slowlock(lock, state, RT_MUTEX_MIN_CHAINWALK, &waiter);
  
  	debug_rt_mutex_free_waiter(&waiter);
+ 	return ret;
+ }
+ 
+ /*
+  * rt_mutex_slowlock - Locking slowpath invoked when fast path fails
+  * @lock:	The rtmutex to block lock
+  * @state:	The task state for sleeping
+  */
+ static int __sched rt_mutex_slowlock(struct rt_mutex_base *lock,
+ 				     unsigned int state)
+ {
+ 	unsigned long flags;
+ 	int ret;
+ 
+ 	/*
+ 	 * Technically we could use raw_spin_[un]lock_irq() here, but this can
+ 	 * be called in early boot if the cmpxchg() fast path is disabled
+ 	 * (debug, no architecture support). In this case we will acquire the
+ 	 * rtmutex with lock->wait_lock held. But we cannot unconditionally
+ 	 * enable interrupts in that early boot case. So we need to use the
+ 	 * irqsave/restore variants.
+ 	 */
+ 	raw_spin_lock_irqsave(&lock->wait_lock, flags);
+ 	ret = __rt_mutex_slowlock_locked(lock, state);
+ 	raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
  
  	return ret;
  }
@@@ -1236,10 -1255,10 +1266,10 @@@ static __always_inline int __rt_mutex_l
  	if (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))
  		return 0;
  
- 	return rt_mutex_slowlock(lock, state, NULL, RT_MUTEX_MIN_CHAINWALK);
+ 	return rt_mutex_slowlock(lock, state);
  }
  
 -static int __sched __rt_mutex_slowtrylock(struct rt_mutex_base *lock)
 +static int __sched __rt_mutex_slowtrylock(struct rt_mutex *lock)
  {
  	int ret = try_to_take_rt_mutex(lock, current, NULL);
  
* Unmerged path kernel/locking/rtmutex.c
diff --git a/kernel/locking/rtmutex_api.c b/kernel/locking/rtmutex_api.c
index fc1322f5b219..32998821a48a 100644
--- a/kernel/locking/rtmutex_api.c
+++ b/kernel/locking/rtmutex_api.c
@@ -337,7 +337,7 @@ int __sched rt_mutex_wait_proxy_lock(struct rt_mutex *lock,
 	raw_spin_lock_irq(&lock->wait_lock);
 	/* sleep on the mutex */
 	set_current_state(TASK_INTERRUPTIBLE);
-	ret = __rt_mutex_slowlock(lock, TASK_INTERRUPTIBLE, to, waiter);
+	ret = rt_mutex_slowlock_block(lock, TASK_INTERRUPTIBLE, to, waiter);
 	/*
 	 * try_to_take_rt_mutex() sets the waiter bit unconditionally. We might
 	 * have to fix that up.
