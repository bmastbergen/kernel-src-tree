mm, slub: move reset of c->page and freelist out of deactivate_slab()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Vlastimil Babka <vbabka@suse.cz>
commit a019d20162586ae5b14bf26c94f1943b1d24a832
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/a019d201.failed

deactivate_slab() removes the cpu slab by merging the cpu freelist with slab's
freelist and putting the slab on the proper node's list. It also sets the
respective kmem_cache_cpu pointers to NULL.

By extracting the kmem_cache_cpu operations from the function, we can make it
not dependent on disabled irqs.

Also if we return a single free pointer from ___slab_alloc, we no longer have
to assign kmem_cache_cpu.page before deactivation or care if somebody preempted
us and assigned a different page to our kmem_cache_cpu in the process.

	Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
(cherry picked from commit a019d20162586ae5b14bf26c94f1943b1d24a832)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/slub.c
diff --cc mm/slub.c
index 18ea2f53cb90,cea7a2ad9e3e..000000000000
--- a/mm/slub.c
+++ b/mm/slub.c
@@@ -2679,8 -2765,22 +2685,24 @@@ load_freelist
  	VM_BUG_ON(!c->page->frozen);
  	c->freelist = get_freepointer(s, freelist);
  	c->tid = next_tid(c->tid);
 -	local_irq_restore(flags);
  	return freelist;
  
++<<<<<<< HEAD
++=======
+ deactivate_slab:
+ 
+ 	local_irq_save(flags);
+ 	if (page != c->page) {
+ 		local_irq_restore(flags);
+ 		goto reread_page;
+ 	}
+ 	freelist = c->freelist;
+ 	c->page = NULL;
+ 	c->freelist = NULL;
+ 	deactivate_slab(s, page, freelist);
+ 	local_irq_restore(flags);
+ 
++>>>>>>> a019d2016258 (mm, slub: move reset of c->page and freelist out of deactivate_slab())
  new_slab:
  
  	if (slub_percpu_partial(c)) {
@@@ -2742,7 -2856,9 +2764,13 @@@ check_new_page
  
  return_single:
  
++<<<<<<< HEAD
 +	deactivate_slab(s, page, get_freepointer(s, freelist), c);
++=======
+ 	local_irq_save(flags);
+ 	deactivate_slab(s, page, get_freepointer(s, freelist));
+ 	local_irq_restore(flags);
++>>>>>>> a019d2016258 (mm, slub: move reset of c->page and freelist out of deactivate_slab())
  	return freelist;
  }
  
* Unmerged path mm/slub.c
