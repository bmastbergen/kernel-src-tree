x86/cpufeatures: Force disable X86_FEATURE_ENQCMD and remove update_pasid()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 9bfecd05833918526cc7357d55e393393440c5fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/9bfecd05.failed

While digesting the XSAVE-related horrors which got introduced with
the supervisor/user split, the recent addition of ENQCMD-related
functionality got on the radar and turned out to be similarly broken.

update_pasid(), which is only required when X86_FEATURE_ENQCMD is
available, is invoked from two places:

 1) From switch_to() for the incoming task

 2) Via a SMP function call from the IOMMU/SMV code

#1 is half-ways correct as it hacks around the brokenness of get_xsave_addr()
   by enforcing the state to be 'present', but all the conditionals in that
   code are completely pointless for that.

   Also the invocation is just useless overhead because at that point
   it's guaranteed that TIF_NEED_FPU_LOAD is set on the incoming task
   and all of this can be handled at return to user space.

#2 is broken beyond repair. The comment in the code claims that it is safe
   to invoke this in an IPI, but that's just wishful thinking.

   FPU state of a running task is protected by fregs_lock() which is
   nothing else than a local_bh_disable(). As BH-disabled regions run
   usually with interrupts enabled the IPI can hit a code section which
   modifies FPU state and there is absolutely no guarantee that any of the
   assumptions which are made for the IPI case is true.

   Also the IPI is sent to all CPUs in mm_cpumask(mm), but the IPI is
   invoked with a NULL pointer argument, so it can hit a completely
   unrelated task and unconditionally force an update for nothing.
   Worse, it can hit a kernel thread which operates on a user space
   address space and set a random PASID for it.

The offending commit does not cleanly revert, but it's sufficient to
force disable X86_FEATURE_ENQCMD and to remove the broken update_pasid()
code to make this dysfunctional all over the place. Anything more
complex would require more surgery and none of the related functions
outside of the x86 core code are blatantly wrong, so removing those
would be overkill.

As nothing enables the PASID bit in the IA32_XSS MSR yet, which is
required to make this actually work, this cannot result in a regression
except for related out of tree train-wrecks, but they are broken already
today.

Fixes: 20f0afd1fb3d ("x86/mmu: Allocate/free a PASID")
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Acked-by: Andy Lutomirski <luto@kernel.org>
	Cc: stable@vger.kernel.org
Link: https://lkml.kernel.org/r/87mtsd6gr9.ffs@nanos.tec.linutronix.de
(cherry picked from commit 9bfecd05833918526cc7357d55e393393440c5fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/xstate.c
diff --cc arch/x86/kernel/fpu/xstate.c
index 6e16c4196ac9,d0eef963aad1..000000000000
--- a/arch/x86/kernel/fpu/xstate.c
+++ b/arch/x86/kernel/fpu/xstate.c
@@@ -1471,59 -1358,47 +1471,106 @@@ void copy_kernel_to_dynamic_supervisor(
  	WARN_ON_FPU(err);
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_IOMMU_SUPPORT
 +void update_pasid(void)
 +{
 +	u64 pasid_state;
 +	u32 pasid;
 +
 +	if (!cpu_feature_enabled(X86_FEATURE_ENQCMD))
 +		return;
 +
 +	if (!current->mm)
 +		return;
 +
 +	pasid = READ_ONCE(current->mm->pasid);
 +	/* Set the valid bit in the PASID MSR/state only for valid pasid. */
 +	pasid_state = pasid == PASID_DISABLED ?
 +		      pasid : pasid | MSR_IA32_PASID_VALID;
 +
 +	/*
 +	 * No need to hold fregs_lock() since the task's fpstate won't
 +	 * be changed by others (e.g. ptrace) while the task is being
 +	 * switched to or is in IPI.
 +	 */
 +	if (!test_thread_flag(TIF_NEED_FPU_LOAD)) {
 +		/* The MSR is active and can be directly updated. */
 +		wrmsrl(MSR_IA32_PASID, pasid_state);
 +	} else {
 +		struct fpu *fpu = &current->thread.fpu;
 +		struct ia32_pasid_state *ppasid_state;
 +		struct xregs_state *xsave;
 +
 +		/*
 +		 * The CPU's xstate registers are not currently active. Just
 +		 * update the PASID state in the memory buffer here. The
 +		 * PASID MSR will be loaded when returning to user mode.
 +		 */
 +		xsave = &fpu->state.xsave;
 +		xsave->header.xfeatures |= XFEATURE_MASK_PASID;
 +		ppasid_state = get_xsave_addr(xsave, XFEATURE_PASID);
 +		/*
 +		 * Since XFEATURE_MASK_PASID is set in xfeatures, ppasid_state
 +		 * won't be NULL and no need to check its value.
 +		 *
 +		 * Only update the task's PASID state when it's different
 +		 * from the mm's pasid.
 +		 */
 +		if (ppasid_state->pasid != pasid_state) {
 +			/*
 +			 * Invalid fpregs so that state restoring will pick up
 +			 * the PASID state.
 +			 */
 +			__fpu_invalidate_fpregs_state(fpu);
 +			ppasid_state->pasid = pasid_state;
 +		}
 +	}
 +}
 +#endif /* CONFIG_IOMMU_SUPPORT */
++=======
+ #ifdef CONFIG_PROC_PID_ARCH_STATUS
+ /*
+  * Report the amount of time elapsed in millisecond since last AVX512
+  * use in the task.
+  */
+ static void avx512_status(struct seq_file *m, struct task_struct *task)
+ {
+ 	unsigned long timestamp = READ_ONCE(task->thread.fpu.avx512_timestamp);
+ 	long delta;
+ 
+ 	if (!timestamp) {
+ 		/*
+ 		 * Report -1 if no AVX512 usage
+ 		 */
+ 		delta = -1;
+ 	} else {
+ 		delta = (long)(jiffies - timestamp);
+ 		/*
+ 		 * Cap to LONG_MAX if time difference > LONG_MAX
+ 		 */
+ 		if (delta < 0)
+ 			delta = LONG_MAX;
+ 		delta = jiffies_to_msecs(delta);
+ 	}
+ 
+ 	seq_put_decimal_ll(m, "AVX512_elapsed_ms:\t", delta);
+ 	seq_putc(m, '\n');
+ }
+ 
+ /*
+  * Report architecture specific information
+  */
+ int proc_pid_arch_status(struct seq_file *m, struct pid_namespace *ns,
+ 			struct pid *pid, struct task_struct *task)
+ {
+ 	/*
+ 	 * Report AVX512 state if the processor and build option supported.
+ 	 */
+ 	if (cpu_feature_enabled(X86_FEATURE_AVX512F))
+ 		avx512_status(m, task);
+ 
+ 	return 0;
+ }
+ #endif /* CONFIG_PROC_PID_ARCH_STATUS */
++>>>>>>> 9bfecd058339 (x86/cpufeatures: Force disable X86_FEATURE_ENQCMD and remove update_pasid())
diff --git a/arch/x86/include/asm/disabled-features.h b/arch/x86/include/asm/disabled-features.h
index db1e1fa617c4..8ca9a5833aa4 100644
--- a/arch/x86/include/asm/disabled-features.h
+++ b/arch/x86/include/asm/disabled-features.h
@@ -56,11 +56,8 @@
 # define DISABLE_PTI		(1 << (X86_FEATURE_PTI & 31))
 #endif
 
-#ifdef CONFIG_IOMMU_SUPPORT
-# define DISABLE_ENQCMD	0
-#else
-# define DISABLE_ENQCMD (1 << (X86_FEATURE_ENQCMD & 31))
-#endif
+/* Force disable because it's broken beyond repair */
+#define DISABLE_ENQCMD		(1 << (X86_FEATURE_ENQCMD & 31))
 
 #ifdef CONFIG_X86_SGX
 # define DISABLE_SGX	0
diff --git a/arch/x86/include/asm/fpu/api.h b/arch/x86/include/asm/fpu/api.h
index 435bc59d539b..6143693b28d0 100644
--- a/arch/x86/include/asm/fpu/api.h
+++ b/arch/x86/include/asm/fpu/api.h
@@ -91,10 +91,6 @@ extern int cpu_has_xfeatures(u64 xfeatures_mask, const char **feature_name);
  */
 #define PASID_DISABLED	0
 
-#ifdef CONFIG_IOMMU_SUPPORT
-/* Update current's PASID MSR/state by mm's PASID. */
-void update_pasid(void);
-#else
 static inline void update_pasid(void) { }
-#endif
+
 #endif /* _ASM_X86_FPU_API_H */
diff --git a/arch/x86/include/asm/fpu/internal.h b/arch/x86/include/asm/fpu/internal.h
index 117fa5e8f0aa..c8bcd327b8f8 100644
--- a/arch/x86/include/asm/fpu/internal.h
+++ b/arch/x86/include/asm/fpu/internal.h
@@ -627,13 +627,6 @@ static inline void switch_fpu_finish(struct fpu *new_fpu)
 		pkru_val = pk ? pk->pkru : 0;
 	}
 	__write_pkru(pkru_val);
-
-	/*
-	 * Expensive PASID MSR write will be avoided in update_pasid() because
-	 * TIF_NEED_FPU_LOAD was set. And the PASID state won't be updated
-	 * unless it's different from mm->pasid to reduce overhead.
-	 */
-	update_pasid();
 }
 
 #endif /* _ASM_X86_FPU_INTERNAL_H */
* Unmerged path arch/x86/kernel/fpu/xstate.c
