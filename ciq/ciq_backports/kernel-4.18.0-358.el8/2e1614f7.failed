Bluetooth: SMP: Convert BT_ERR/BT_DBG to bt_dev_err/bt_dev_dbg

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
commit 2e1614f7d61e407f1a8e7935a2903a6fa3cb0b11
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/2e1614f7.failed

This converts instances of BT_ERR and BT_DBG to bt_dev_err and
bt_dev_dbg which can be enabled at runtime when BT_FEATURE_DEBUG is
enabled.

Note: Not all instances could be converted as some are exercised by
selftest.

	Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 2e1614f7d61e407f1a8e7935a2903a6fa3cb0b11)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/smp.c
diff --cc net/bluetooth/smp.c
index 38407d06b44c,efc19f98b959..000000000000
--- a/net/bluetooth/smp.c
+++ b/net/bluetooth/smp.c
@@@ -966,9 -950,9 +967,9 @@@ static u8 smp_confirm(struct smp_chan *
  	struct smp_cmd_pairing_confirm cp;
  	int ret;
  
- 	BT_DBG("conn %p", conn);
+ 	bt_dev_dbg(conn->hcon->hdev, "conn %p", conn);
  
 -	ret = smp_c1(smp->tk, smp->prnd, smp->preq, smp->prsp,
 +	ret = smp_c1(smp->tfm_aes, smp->tk, smp->prnd, smp->preq, smp->prsp,
  		     conn->hcon->init_addr_type, &conn->hcon->init_addr,
  		     conn->hcon->resp_addr_type, &conn->hcon->resp_addr,
  		     cp.confirm_val);
@@@ -994,12 -978,10 +995,17 @@@ static u8 smp_random(struct smp_chan *s
  	u8 confirm[16];
  	int ret;
  
++<<<<<<< HEAD
 +	if (IS_ERR_OR_NULL(smp->tfm_aes))
 +		return SMP_UNSPECIFIED;
 +
 +	BT_DBG("conn %p %s", conn, conn->hcon->out ? "master" : "slave");
++=======
+ 	bt_dev_dbg(conn->hcon->hdev, "conn %p %s", conn,
+ 		   conn->hcon->out ? "master" : "slave");
++>>>>>>> 2e1614f7d61e (Bluetooth: SMP: Convert BT_ERR/BT_DBG to bt_dev_err/bt_dev_dbg)
  
 -	ret = smp_c1(smp->tk, smp->rrnd, smp->preq, smp->prsp,
 +	ret = smp_c1(smp->tfm_aes, smp->tk, smp->rrnd, smp->preq, smp->prsp,
  		     hcon->init_addr_type, &hcon->init_addr,
  		     hcon->resp_addr_type, &hcon->resp_addr, confirm);
  	if (ret)
@@@ -1400,16 -1383,10 +1407,21 @@@ static struct smp_chan *smp_chan_create
  	if (!smp)
  		return NULL;
  
 +	smp->tfm_aes = crypto_alloc_cipher("aes", 0, 0);
 +	if (IS_ERR(smp->tfm_aes)) {
 +		BT_ERR("Unable to create AES crypto context");
 +		goto zfree_smp;
 +	}
 +
  	smp->tfm_cmac = crypto_alloc_shash("cmac(aes)", 0, 0);
  	if (IS_ERR(smp->tfm_cmac)) {
++<<<<<<< HEAD
 +		BT_ERR("Unable to create CMAC crypto context");
 +		goto free_cipher;
++=======
+ 		bt_dev_err(hcon->hdev, "Unable to create CMAC crypto context");
+ 		goto zfree_smp;
++>>>>>>> 2e1614f7d61e (Bluetooth: SMP: Convert BT_ERR/BT_DBG to bt_dev_err/bt_dev_dbg)
  	}
  
  	smp->tfm_ecdh = crypto_alloc_kpp("ecdh", 0, 0);
@@@ -3312,27 -3289,18 +3327,32 @@@ static struct l2cap_chan *smp_add_cid(s
  	if (!smp)
  		return ERR_PTR(-ENOMEM);
  
 +	tfm_aes = crypto_alloc_cipher("aes", 0, 0);
 +	if (IS_ERR(tfm_aes)) {
 +		BT_ERR("Unable to create AES crypto context");
 +		kzfree(smp);
 +		return ERR_CAST(tfm_aes);
 +	}
 +
  	tfm_cmac = crypto_alloc_shash("cmac(aes)", 0, 0);
  	if (IS_ERR(tfm_cmac)) {
++<<<<<<< HEAD
 +		BT_ERR("Unable to create CMAC crypto context");
 +		crypto_free_cipher(tfm_aes);
 +		kzfree(smp);
++=======
+ 		bt_dev_err(hdev, "Unable to create CMAC crypto context");
+ 		kfree_sensitive(smp);
++>>>>>>> 2e1614f7d61e (Bluetooth: SMP: Convert BT_ERR/BT_DBG to bt_dev_err/bt_dev_dbg)
  		return ERR_CAST(tfm_cmac);
  	}
  
  	tfm_ecdh = crypto_alloc_kpp("ecdh", 0, 0);
  	if (IS_ERR(tfm_ecdh)) {
- 		BT_ERR("Unable to create ECDH crypto context");
+ 		bt_dev_err(hdev, "Unable to create ECDH crypto context");
  		crypto_free_shash(tfm_cmac);
 -		kfree_sensitive(smp);
 +		crypto_free_cipher(tfm_aes);
 +		kzfree(smp);
  		return ERR_CAST(tfm_ecdh);
  	}
  
* Unmerged path net/bluetooth/smp.c
