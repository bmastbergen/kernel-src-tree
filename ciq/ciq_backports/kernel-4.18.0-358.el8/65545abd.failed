ACPI: battery: fix some coding style issues

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Xiaofei Tan <tanxiaofei@huawei.com>
commit 65545abd8aa3a98c44472525bb459aacffa052c1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/65545abd.failed

Fix some coding style issues reported by checkpatch.pl, including the
following types:

WARNING: Block comments use * on subsequent lines
WARNING: Block comments use a trailing */ on a separate line
ERROR: code indent should use tabs where possible
WARNING: Missing a blank line after declarations
ERROR: spaces required around that '?' (ctx:WxV)
WARNING: Block comments should align the * on each line

	Signed-off-by: Xiaofei Tan <tanxiaofei@huawei.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 65545abd8aa3a98c44472525bb459aacffa052c1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/battery.c
diff --cc drivers/acpi/battery.c
index 612a1872450d,dae91f906cea..000000000000
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@@ -559,8 -533,10 +562,15 @@@ static int acpi_battery_get_info(struc
  		mutex_unlock(&battery->lock);
  
  		if (ACPI_FAILURE(status)) {
++<<<<<<< HEAD
 +			ACPI_EXCEPTION((AE_INFO, status, "Evaluating %s",
 +					use_bix ? "_BIX":"_BIF"));
++=======
+ 			acpi_handle_info(battery->device->handle,
+ 					 "%s evaluation failed: %s\n",
+ 					 use_bix ? "_BIX":"_BIF",
+ 					 acpi_format_exception(status));
++>>>>>>> 65545abd8aa3 (ACPI: battery: fix some coding style issues)
  		} else {
  			result = extract_battery_info(use_bix,
  						      battery,
@@@ -1036,231 -1021,7 +1051,235 @@@ static void acpi_battery_refresh(struc
  	sysfs_add_battery(battery);
  }
  
++<<<<<<< HEAD
 +/* --------------------------------------------------------------------------
 +                              FS Interface (/proc)
 +   -------------------------------------------------------------------------- */
 +
 +#ifdef CONFIG_ACPI_PROCFS_POWER
 +static struct proc_dir_entry *acpi_battery_dir;
 +
 +static const char *acpi_battery_units(const struct acpi_battery *battery)
 +{
 +	return (battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA) ?
 +		"mA" : "mW";
 +}
 +
 +static int acpi_battery_info_proc_show(struct seq_file *seq, void *offset)
 +{
 +	struct acpi_battery *battery = seq->private;
 +	int result = acpi_battery_update(battery, false);
 +
 +	if (result)
 +		goto end;
 +
 +	seq_printf(seq, "present:                 %s\n",
 +		   acpi_battery_present(battery) ? "yes" : "no");
 +	if (!acpi_battery_present(battery))
 +		goto end;
 +	if (battery->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
 +		seq_printf(seq, "design capacity:         unknown\n");
 +	else
 +		seq_printf(seq, "design capacity:         %d %sh\n",
 +			   battery->design_capacity,
 +			   acpi_battery_units(battery));
 +
 +	if (battery->full_charge_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
 +		seq_printf(seq, "last full capacity:      unknown\n");
 +	else
 +		seq_printf(seq, "last full capacity:      %d %sh\n",
 +			   battery->full_charge_capacity,
 +			   acpi_battery_units(battery));
 +
 +	seq_printf(seq, "battery technology:      %srechargeable\n",
 +		   battery->technology ? "" : "non-");
 +
 +	if (battery->design_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
 +		seq_printf(seq, "design voltage:          unknown\n");
 +	else
 +		seq_printf(seq, "design voltage:          %d mV\n",
 +			   battery->design_voltage);
 +	seq_printf(seq, "design capacity warning: %d %sh\n",
 +		   battery->design_capacity_warning,
 +		   acpi_battery_units(battery));
 +	seq_printf(seq, "design capacity low:     %d %sh\n",
 +		   battery->design_capacity_low,
 +		   acpi_battery_units(battery));
 +	seq_printf(seq, "cycle count:		  %i\n", battery->cycle_count);
 +	seq_printf(seq, "capacity granularity 1:  %d %sh\n",
 +		   battery->capacity_granularity_1,
 +		   acpi_battery_units(battery));
 +	seq_printf(seq, "capacity granularity 2:  %d %sh\n",
 +		   battery->capacity_granularity_2,
 +		   acpi_battery_units(battery));
 +	seq_printf(seq, "model number:            %s\n", battery->model_number);
 +	seq_printf(seq, "serial number:           %s\n", battery->serial_number);
 +	seq_printf(seq, "battery type:            %s\n", battery->type);
 +	seq_printf(seq, "OEM info:                %s\n", battery->oem_info);
 +      end:
 +	if (result)
 +		seq_printf(seq, "ERROR: Unable to read battery info\n");
 +	return result;
 +}
 +
 +static int acpi_battery_state_proc_show(struct seq_file *seq, void *offset)
 +{
 +	struct acpi_battery *battery = seq->private;
 +	int result = acpi_battery_update(battery, false);
 +
 +	if (result)
 +		goto end;
 +
 +	seq_printf(seq, "present:                 %s\n",
 +		   acpi_battery_present(battery) ? "yes" : "no");
 +	if (!acpi_battery_present(battery))
 +		goto end;
 +
 +	seq_printf(seq, "capacity state:          %s\n",
 +			(battery->state & 0x04) ? "critical" : "ok");
 +	if ((battery->state & 0x01) && (battery->state & 0x02))
 +		seq_printf(seq,
 +			   "charging state:          charging/discharging\n");
 +	else if (battery->state & 0x01)
 +		seq_printf(seq, "charging state:          discharging\n");
 +	else if (battery->state & 0x02)
 +		seq_printf(seq, "charging state:          charging\n");
 +	else
 +		seq_printf(seq, "charging state:          charged\n");
 +
 +	if (battery->rate_now == ACPI_BATTERY_VALUE_UNKNOWN)
 +		seq_printf(seq, "present rate:            unknown\n");
 +	else
 +		seq_printf(seq, "present rate:            %d %s\n",
 +			   battery->rate_now, acpi_battery_units(battery));
 +
 +	if (battery->capacity_now == ACPI_BATTERY_VALUE_UNKNOWN)
 +		seq_printf(seq, "remaining capacity:      unknown\n");
 +	else
 +		seq_printf(seq, "remaining capacity:      %d %sh\n",
 +			   battery->capacity_now, acpi_battery_units(battery));
 +	if (battery->voltage_now == ACPI_BATTERY_VALUE_UNKNOWN)
 +		seq_printf(seq, "present voltage:         unknown\n");
 +	else
 +		seq_printf(seq, "present voltage:         %d mV\n",
 +			   battery->voltage_now);
 +      end:
 +	if (result)
 +		seq_printf(seq, "ERROR: Unable to read battery state\n");
 +
 +	return result;
 +}
 +
 +static int acpi_battery_alarm_proc_show(struct seq_file *seq, void *offset)
 +{
 +	struct acpi_battery *battery = seq->private;
 +	int result = acpi_battery_update(battery, false);
 +
 +	if (result)
 +		goto end;
 +
 +	if (!acpi_battery_present(battery)) {
 +		seq_printf(seq, "present:                 no\n");
 +		goto end;
 +	}
 +	seq_printf(seq, "alarm:                   ");
 +	if (battery->alarm) {
 +		seq_printf(seq, "%u %sh\n", battery->alarm,
 +				acpi_battery_units(battery));
 +	} else {
 +		seq_printf(seq, "unsupported\n");
 +	}
 +      end:
 +	if (result)
 +		seq_printf(seq, "ERROR: Unable to read battery alarm\n");
 +	return result;
 +}
 +
 +static ssize_t acpi_battery_write_alarm(struct file *file,
 +					const char __user * buffer,
 +					size_t count, loff_t * ppos)
 +{
 +	int result = 0;
 +	char alarm_string[12] = { '\0' };
 +	struct seq_file *m = file->private_data;
 +	struct acpi_battery *battery = m->private;
 +
 +	if (!battery || (count > sizeof(alarm_string) - 1))
 +		return -EINVAL;
 +	if (!acpi_battery_present(battery)) {
 +		result = -ENODEV;
 +		goto end;
 +	}
 +	if (copy_from_user(alarm_string, buffer, count)) {
 +		result = -EFAULT;
 +		goto end;
 +	}
 +	alarm_string[count] = '\0';
 +	if (kstrtoint(alarm_string, 0, &battery->alarm)) {
 +		result = -EINVAL;
 +		goto end;
 +	}
 +	result = acpi_battery_set_alarm(battery);
 +      end:
 +	if (result)
 +		return result;
 +	return count;
 +}
 +
 +static int acpi_battery_alarm_proc_open(struct inode *inode, struct file *file)
 +{
 +	return single_open(file, acpi_battery_alarm_proc_show, PDE_DATA(inode));
 +}
 +
 +static const struct file_operations acpi_battery_alarm_fops = {
 +	.owner		= THIS_MODULE,
 +	.open		= acpi_battery_alarm_proc_open,
 +	.read		= seq_read,
 +	.write		= acpi_battery_write_alarm,
 +	.llseek		= seq_lseek,
 +	.release	= single_release,
 +};
 +
 +static int acpi_battery_add_fs(struct acpi_device *device)
 +{
 +	pr_warn(PREFIX "Deprecated procfs I/F for battery is loaded, please retry with CONFIG_ACPI_PROCFS_POWER cleared\n");
 +	if (!acpi_device_dir(device)) {
 +		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
 +						     acpi_battery_dir);
 +		if (!acpi_device_dir(device))
 +			return -ENODEV;
 +	}
 +
 +	if (!proc_create_single_data("info", S_IRUGO, acpi_device_dir(device),
 +			acpi_battery_info_proc_show, acpi_driver_data(device)))
 +		return -ENODEV;
 +	if (!proc_create_single_data("state", S_IRUGO, acpi_device_dir(device),
 +			acpi_battery_state_proc_show, acpi_driver_data(device)))
 +		return -ENODEV;
 +	if (!proc_create_data("alarm", S_IFREG | S_IRUGO | S_IWUSR,
 +			acpi_device_dir(device), &acpi_battery_alarm_fops,
 +			acpi_driver_data(device)))
 +		return -ENODEV;
 +	return 0;
 +}
 +
 +static void acpi_battery_remove_fs(struct acpi_device *device)
 +{
 +	if (!acpi_device_dir(device))
 +		return;
 +	remove_proc_subtree(acpi_device_bid(device), acpi_battery_dir);
 +	acpi_device_dir(device) = NULL;
 +}
 +
 +#endif
 +
 +/* --------------------------------------------------------------------------
 +                                 Driver Interface
 +   -------------------------------------------------------------------------- */
 +
++=======
+ /* Driver Interface */
++>>>>>>> 65545abd8aa3 (ACPI: battery: fix some coding style issues)
  static void acpi_battery_notify(struct acpi_device *device, u32 event)
  {
  	struct acpi_battery *battery = acpi_driver_data(device);
* Unmerged path drivers/acpi/battery.c
