ice: Reduce scope of variables

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Tony Nguyen <anthony.l.nguyen@intel.com>
commit bd557d97978ea3e22653117a39184b5db70c7093
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/bd557d97.failed

There are some places where the scope of a variable can
be reduced, so do that.

	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
	Tested-by: Gurucharan G <gurucharanx.g@intel.com> (A Contingent worker at Intel)
(cherry picked from commit bd557d97978ea3e22653117a39184b5db70c7093)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_flex_pipe.c
diff --cc drivers/net/ethernet/intel/ice/ice_flex_pipe.c
index a3e1704ca779,5ce413965930..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_flex_pipe.c
+++ b/drivers/net/ethernet/intel/ice/ice_flex_pipe.c
@@@ -1718,8 -321,118 +1718,120 @@@ ice_get_open_tunnel_port(struct ice_hw 
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * ice_upd_dvm_boost_entry
+  * @hw: pointer to the HW structure
+  * @entry: pointer to double vlan boost entry info
+  */
+ static int
+ ice_upd_dvm_boost_entry(struct ice_hw *hw, struct ice_dvm_entry *entry)
+ {
+ 	struct ice_boost_tcam_section *sect_rx, *sect_tx;
+ 	int status = -ENOSPC;
+ 	struct ice_buf_build *bld;
+ 	u8 val, dc, nm;
+ 
+ 	bld = ice_pkg_buf_alloc(hw);
+ 	if (!bld)
+ 		return -ENOMEM;
+ 
+ 	/* allocate 2 sections, one for Rx parser, one for Tx parser */
+ 	if (ice_pkg_buf_reserve_section(bld, 2))
+ 		goto ice_upd_dvm_boost_entry_err;
+ 
+ 	sect_rx = ice_pkg_buf_alloc_section(bld, ICE_SID_RXPARSER_BOOST_TCAM,
+ 					    struct_size(sect_rx, tcam, 1));
+ 	if (!sect_rx)
+ 		goto ice_upd_dvm_boost_entry_err;
+ 	sect_rx->count = cpu_to_le16(1);
+ 
+ 	sect_tx = ice_pkg_buf_alloc_section(bld, ICE_SID_TXPARSER_BOOST_TCAM,
+ 					    struct_size(sect_tx, tcam, 1));
+ 	if (!sect_tx)
+ 		goto ice_upd_dvm_boost_entry_err;
+ 	sect_tx->count = cpu_to_le16(1);
+ 
+ 	/* copy original boost entry to update package buffer */
+ 	memcpy(sect_rx->tcam, entry->boost_entry, sizeof(*sect_rx->tcam));
+ 
+ 	/* re-write the don't care and never match bits accordingly */
+ 	if (entry->enable) {
+ 		/* all bits are don't care */
+ 		val = 0x00;
+ 		dc = 0xFF;
+ 		nm = 0x00;
+ 	} else {
+ 		/* disable, one never match bit, the rest are don't care */
+ 		val = 0x00;
+ 		dc = 0xF7;
+ 		nm = 0x08;
+ 	}
+ 
+ 	ice_set_key((u8 *)&sect_rx->tcam[0].key, sizeof(sect_rx->tcam[0].key),
+ 		    &val, NULL, &dc, &nm, 0, sizeof(u8));
+ 
+ 	/* exact copy of entry to Tx section entry */
+ 	memcpy(sect_tx->tcam, sect_rx->tcam, sizeof(*sect_tx->tcam));
+ 
+ 	status = ice_update_pkg_no_lock(hw, ice_pkg_buf(bld), 1);
+ 
+ ice_upd_dvm_boost_entry_err:
+ 	ice_pkg_buf_free(hw, bld);
+ 
+ 	return status;
+ }
+ 
+ /**
+  * ice_set_dvm_boost_entries
+  * @hw: pointer to the HW structure
+  *
+  * Enable double vlan by updating the appropriate boost tcam entries.
+  */
+ int ice_set_dvm_boost_entries(struct ice_hw *hw)
+ {
+ 	u16 i;
+ 
+ 	for (i = 0; i < hw->dvm_upd.count; i++) {
+ 		int status;
+ 
+ 		status = ice_upd_dvm_boost_entry(hw, &hw->dvm_upd.tbl[i]);
+ 		if (status)
+ 			return status;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_tunnel_idx_to_entry - convert linear index to the sparse one
+  * @hw: pointer to the HW structure
+  * @type: type of tunnel
+  * @idx: linear index
+  *
+  * Stack assumes we have 2 linear tables with indexes [0, count_valid),
+  * but really the port table may be sprase, and types are mixed, so convert
+  * the stack index into the device index.
+  */
+ static u16 ice_tunnel_idx_to_entry(struct ice_hw *hw, enum ice_tunnel_type type,
+ 				   u16 idx)
+ {
+ 	u16 i;
+ 
+ 	for (i = 0; i < hw->tnl.count && i < ICE_TUNNEL_MAX_ENTRIES; i++)
+ 		if (hw->tnl.tbl[i].valid &&
+ 		    hw->tnl.tbl[i].type == type &&
+ 		    idx-- == 0)
+ 			return i;
+ 
+ 	WARN_ON_ONCE(1);
+ 	return 0;
+ }
+ 
+ /**
++>>>>>>> bd557d97978e (ice: Reduce scope of variables)
   * ice_create_tunnel
   * @hw: pointer to the HW structure
 - * @index: device table entry
   * @type: type of tunnel
   * @port: port of tunnel to create
   *
@@@ -4455,7 -3196,6 +4567,10 @@@ ice_rem_vsig(struct ice_hw *hw, enum ic
  	u16 idx = vsig & ICE_VSIG_IDX_M;
  	struct ice_vsig_vsi *vsi_cur;
  	struct ice_vsig_prof *d, *t;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> bd557d97978e (ice: Reduce scope of variables)
  
  	/* remove TCAM entries */
  	list_for_each_entry_safe(d, t,
@@@ -4511,7 -3253,6 +4628,10 @@@ ice_rem_prof_id_vsig(struct ice_hw *hw
  {
  	u16 idx = vsig & ICE_VSIG_IDX_M;
  	struct ice_vsig_prof *p, *t;
++<<<<<<< HEAD
 +	enum ice_status status;
++=======
++>>>>>>> bd557d97978e (ice: Reduce scope of variables)
  
  	list_for_each_entry_safe(p, t,
  				 &hw->blk[blk].xlt2.vsig_tbl[idx].prop_lst,
* Unmerged path drivers/net/ethernet/intel/ice/ice_flex_pipe.c
diff --git a/drivers/net/ethernet/intel/ice/ice_sched.c b/drivers/net/ethernet/intel/ice/ice_sched.c
index 2f097637e405..a8864d336dfd 100644
--- a/drivers/net/ethernet/intel/ice/ice_sched.c
+++ b/drivers/net/ethernet/intel/ice/ice_sched.c
@@ -1586,6 +1586,8 @@ ice_sched_add_vsi_child_nodes(struct ice_port_info *pi, u16 vsi_handle,
 	vsil = ice_sched_get_vsi_layer(hw);
 	parent = ice_sched_get_vsi_node(pi, tc_node, vsi_handle);
 	for (i = vsil + 1; i <= qgl; i++) {
+		int status;
+
 		if (!parent)
 			return ICE_ERR_CFG;
 
@@ -1688,6 +1690,8 @@ ice_sched_add_vsi_support_nodes(struct ice_port_info *pi, u16 vsi_handle,
 
 	vsil = ice_sched_get_vsi_layer(pi->hw);
 	for (i = pi->hw->sw_entry_point_layer; i <= vsil; i++) {
+		int status;
+
 		status = ice_sched_add_nodes_to_layer(pi, tc_node, parent,
 						      i, num_nodes[i],
 						      &first_node_teid,
