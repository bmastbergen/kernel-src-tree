mptcp: re-arm retransmit timer if data is pending

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Florian Westphal <fw@strlen.de>
commit 3241a9c029344ca4aa0ef1fa9f0f010d5bbc2a85
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/3241a9c0.failed

The retransmit head will be NULL in case there is no in-flight data
(meaning all data injected into network has been acked).

In that case the retransmit timer is stopped.

This is only correct if there is no more pending, not-yet-sent data.

If there is, the retransmit timer needs to set the PENDING bit again so
that mptcp tries to send the remaining (new) data once a subflow can accept
more data.

Also, mptcp_subflow_get_retrans() has to be called unconditionally.

This function checks for subflows that have become unresponsive and marks
them as stale, so in the case where the rtx queue is empty, subflows
will never be marked stale which prevents available backup subflows from
becoming eligible for transmit.

Closes: https://github.com/multipath-tcp/mptcp_net-next/issues/226
	Acked-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3241a9c029344ca4aa0ef1fa9f0f010d5bbc2a85)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
diff --cc net/mptcp/protocol.c
index 3c6947aa65c4,8029bbbe1c9e..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -1092,7 -1105,8 +1092,12 @@@ out
  	if (cleaned && tcp_under_memory_pressure(sk))
  		__mptcp_mem_reclaim_partial(sk);
  
++<<<<<<< HEAD
 +	if (snd_una == READ_ONCE(msk->snd_nxt)) {
++=======
+ 	if (snd_una == READ_ONCE(msk->snd_nxt) &&
+ 	    snd_una == READ_ONCE(msk->write_seq)) {
++>>>>>>> 3241a9c02934 (mptcp: re-arm retransmit timer if data is pending)
  		if (mptcp_timer_pending(sk) && !mptcp_data_fin_enabled(msk))
  			mptcp_stop_timer(sk);
  	} else {
@@@ -1454,7 -1523,39 +1459,43 @@@ static void mptcp_push_release(struct s
  	release_sock(ssk);
  }
  
++<<<<<<< HEAD
 +static void __mptcp_push_pending(struct sock *sk, unsigned int flags)
++=======
+ static void mptcp_update_post_push(struct mptcp_sock *msk,
+ 				   struct mptcp_data_frag *dfrag,
+ 				   u32 sent)
+ {
+ 	u64 snd_nxt_new = dfrag->data_seq;
+ 
+ 	dfrag->already_sent += sent;
+ 
+ 	msk->snd_burst -= sent;
+ 
+ 	snd_nxt_new += dfrag->already_sent;
+ 
+ 	/* snd_nxt_new can be smaller than snd_nxt in case mptcp
+ 	 * is recovering after a failover. In that event, this re-sends
+ 	 * old segments.
+ 	 *
+ 	 * Thus compute snd_nxt_new candidate based on
+ 	 * the dfrag->data_seq that was sent and the data
+ 	 * that has been handed to the subflow for transmission
+ 	 * and skip update in case it was old dfrag.
+ 	 */
+ 	if (likely(after64(snd_nxt_new, msk->snd_nxt)))
+ 		msk->snd_nxt = snd_nxt_new;
+ }
+ 
+ static void mptcp_check_and_set_pending(struct sock *sk)
+ {
+ 	if (mptcp_send_head(sk) &&
+ 	    !test_bit(MPTCP_PUSH_PENDING, &mptcp_sk(sk)->flags))
+ 		set_bit(MPTCP_PUSH_PENDING, &mptcp_sk(sk)->flags);
+ }
+ 
+ void __mptcp_push_pending(struct sock *sk, unsigned int flags)
++>>>>>>> 3241a9c02934 (mptcp: re-arm retransmit timer if data is pending)
  {
  	struct sock *prev_ssk = NULL, *ssk = NULL;
  	struct mptcp_sock *msk = mptcp_sk(sk);
* Unmerged path net/mptcp/protocol.c
