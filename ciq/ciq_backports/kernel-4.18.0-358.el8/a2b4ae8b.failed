mm, slub: make slab_lock() disable irqs with PREEMPT_RT

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Vlastimil Babka <vbabka@suse.cz>
commit a2b4ae8bfd9c10e3c1c1966bd3c8d8b7c9026aaf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/a2b4ae8b.failed

We need to disable irqs around slab_lock() (a bit spinlock) to make it
irq-safe. Most calls to slab_lock() are nested under spin_lock_irqsave() which
doesn't disable irqs on PREEMPT_RT, so add explicit disabling with PREEMPT_RT.
The exception is cmpxchg_double_slab() which already disables irqs, so use a
__slab_[un]lock() variant without irq disable there.

slab_[un]lock() thus needs a flags pointer parameter, which is unused on !RT.
free_debug_processing() now has two flags variables, which looks odd, but only
one is actually used - the one used in spin_lock_irqsave() on !RT and the one
used in slab_lock() on RT.

As a result, __cmpxchg_double_slab() and cmpxchg_double_slab() become
effectively identical on RT, as both will disable irqs, which is necessary on
RT as most callers of this function also rely on irqsaving lock operations.
Thus, assert that irqs are already disabled in __cmpxchg_double_slab() only on
!RT and also change the VM_BUG_ON assertion to the more standard lockdep_assert
one.

	Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
(cherry picked from commit a2b4ae8bfd9c10e3c1c1966bd3c8d8b7c9026aaf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/slub.c
diff --cc mm/slub.c
index f80099cd9447,a04c36e173c0..000000000000
--- a/mm/slub.c
+++ b/mm/slub.c
@@@ -1220,7 -1291,7 +1242,11 @@@ static noinline int free_debug_processi
  	struct kmem_cache_node *n = get_node(s, page_to_nid(page));
  	void *object = head;
  	int cnt = 0;
++<<<<<<< HEAD
 +	unsigned long uninitialized_var(flags);
++=======
+ 	unsigned long flags, flags2;
++>>>>>>> a2b4ae8bfd9c (mm, slub: make slab_lock() disable irqs with PREEMPT_RT)
  	int ret = 0;
  
  	spin_lock_irqsave(&n->list_lock, flags);
* Unmerged path mm/slub.c
