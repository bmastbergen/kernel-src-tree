i2c: designware: Move ACPI parts into common module

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit f9288fcc5c6154959de4dd83be1b91abcf5e0c17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/f9288fcc.failed

For possible code reuse in the future, move ACPI parts into common module.

	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
	Signed-off-by: Wolfram Sang <wsa@kernel.org>
(cherry picked from commit f9288fcc5c6154959de4dd83be1b91abcf5e0c17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/busses/i2c-designware-common.c
#	drivers/i2c/busses/i2c-designware-core.h
#	drivers/i2c/busses/i2c-designware-platdrv.c
diff --cc drivers/i2c/busses/i2c-designware-common.c
index 37ca1ea69f2b,e1697ed8b54a..000000000000
--- a/drivers/i2c/busses/i2c-designware-common.c
+++ b/drivers/i2c/busses/i2c-designware-common.c
@@@ -116,6 -120,151 +120,154 @@@ int i2c_dw_set_reg_access(struct dw_i2c
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static const u32 supported_speeds[] = {
+ 	I2C_MAX_HIGH_SPEED_MODE_FREQ,
+ 	I2C_MAX_FAST_MODE_PLUS_FREQ,
+ 	I2C_MAX_FAST_MODE_FREQ,
+ 	I2C_MAX_STANDARD_MODE_FREQ,
+ };
+ 
+ int i2c_dw_validate_speed(struct dw_i2c_dev *dev)
+ {
+ 	struct i2c_timings *t = &dev->timings;
+ 	unsigned int i;
+ 
+ 	/*
+ 	 * Only standard mode at 100kHz, fast mode at 400kHz,
+ 	 * fast mode plus at 1MHz and high speed mode at 3.4MHz are supported.
+ 	 */
+ 	for (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {
+ 		if (t->bus_freq_hz == supported_speeds[i])
+ 			return 0;
+ 	}
+ 
+ 	dev_err(dev->dev,
+ 		"%d Hz is unsupported, only 100kHz, 400kHz, 1MHz and 3.4MHz are supported\n",
+ 		t->bus_freq_hz);
+ 
+ 	return -EINVAL;
+ }
+ EXPORT_SYMBOL_GPL(i2c_dw_validate_speed);
+ 
+ #ifdef CONFIG_ACPI
+ 
+ #include <linux/dmi.h>
+ 
+ /*
+  * The HCNT/LCNT information coming from ACPI should be the most accurate
+  * for given platform. However, some systems get it wrong. On such systems
+  * we get better results by calculating those based on the input clock.
+  */
+ static const struct dmi_system_id i2c_dw_no_acpi_params[] = {
+ 	{
+ 		.ident = "Dell Inspiron 7348",
+ 		.matches = {
+ 			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+ 			DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 7348"),
+ 		},
+ 	},
+ 	{}
+ };
+ 
+ static void i2c_dw_acpi_params(struct device *device, char method[],
+ 			       u16 *hcnt, u16 *lcnt, u32 *sda_hold)
+ {
+ 	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
+ 	acpi_handle handle = ACPI_HANDLE(device);
+ 	union acpi_object *obj;
+ 
+ 	if (dmi_check_system(i2c_dw_no_acpi_params))
+ 		return;
+ 
+ 	if (ACPI_FAILURE(acpi_evaluate_object(handle, method, NULL, &buf)))
+ 		return;
+ 
+ 	obj = (union acpi_object *)buf.pointer;
+ 	if (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 3) {
+ 		const union acpi_object *objs = obj->package.elements;
+ 
+ 		*hcnt = (u16)objs[0].integer.value;
+ 		*lcnt = (u16)objs[1].integer.value;
+ 		*sda_hold = (u32)objs[2].integer.value;
+ 	}
+ 
+ 	kfree(buf.pointer);
+ }
+ 
+ int i2c_dw_acpi_configure(struct device *device)
+ {
+ 	struct dw_i2c_dev *dev = dev_get_drvdata(device);
+ 	struct i2c_timings *t = &dev->timings;
+ 	u32 ss_ht = 0, fp_ht = 0, hs_ht = 0, fs_ht = 0;
+ 
+ 	dev->tx_fifo_depth = 32;
+ 	dev->rx_fifo_depth = 32;
+ 
+ 	/*
+ 	 * Try to get SDA hold time and *CNT values from an ACPI method for
+ 	 * selected speed modes.
+ 	 */
+ 	i2c_dw_acpi_params(device, "SSCN", &dev->ss_hcnt, &dev->ss_lcnt, &ss_ht);
+ 	i2c_dw_acpi_params(device, "FPCN", &dev->fp_hcnt, &dev->fp_lcnt, &fp_ht);
+ 	i2c_dw_acpi_params(device, "HSCN", &dev->hs_hcnt, &dev->hs_lcnt, &hs_ht);
+ 	i2c_dw_acpi_params(device, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt, &fs_ht);
+ 
+ 	switch (t->bus_freq_hz) {
+ 	case I2C_MAX_STANDARD_MODE_FREQ:
+ 		dev->sda_hold_time = ss_ht;
+ 		break;
+ 	case I2C_MAX_FAST_MODE_PLUS_FREQ:
+ 		dev->sda_hold_time = fp_ht;
+ 		break;
+ 	case I2C_MAX_HIGH_SPEED_MODE_FREQ:
+ 		dev->sda_hold_time = hs_ht;
+ 		break;
+ 	case I2C_MAX_FAST_MODE_FREQ:
+ 	default:
+ 		dev->sda_hold_time = fs_ht;
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(i2c_dw_acpi_configure);
+ 
+ void i2c_dw_acpi_adjust_bus_speed(struct device *device)
+ {
+ 	struct dw_i2c_dev *dev = dev_get_drvdata(device);
+ 	struct i2c_timings *t = &dev->timings;
+ 	u32 acpi_speed;
+ 	int i;
+ 
+ 	acpi_speed = i2c_acpi_find_bus_speed(device);
+ 	/*
+ 	 * Some DSTDs use a non standard speed, round down to the lowest
+ 	 * standard speed.
+ 	 */
+ 	for (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {
+ 		if (acpi_speed >= supported_speeds[i])
+ 			break;
+ 	}
+ 	acpi_speed = i < ARRAY_SIZE(supported_speeds) ? supported_speeds[i] : 0;
+ 
+ 	/*
+ 	 * Find bus speed from the "clock-frequency" device property, ACPI
+ 	 * or by using fast mode if neither is set.
+ 	 */
+ 	if (acpi_speed && t->bus_freq_hz)
+ 		t->bus_freq_hz = min(t->bus_freq_hz, acpi_speed);
+ 	else if (acpi_speed || t->bus_freq_hz)
+ 		t->bus_freq_hz = max(t->bus_freq_hz, acpi_speed);
+ 	else
+ 		t->bus_freq_hz = I2C_MAX_FAST_MODE_FREQ;
+ }
+ EXPORT_SYMBOL_GPL(i2c_dw_acpi_adjust_bus_speed);
+ 
+ #endif	/* CONFIG_ACPI */
+ 
++>>>>>>> f9288fcc5c61 (i2c: designware: Move ACPI parts into common module)
  u32 i2c_dw_scl_hcnt(u32 ic_clk, u32 tSYMBOL, u32 tf, int cond, int offset)
  {
  	/*
diff --cc drivers/i2c/busses/i2c-designware-core.h
index a5f6db491e44,150de5e5c31b..000000000000
--- a/drivers/i2c/busses/i2c-designware-core.h
+++ b/drivers/i2c/busses/i2c-designware-core.h
@@@ -323,10 -332,40 +323,23 @@@ extern int i2c_dw_probe_slave(struct dw
  static inline int i2c_dw_probe_slave(struct dw_i2c_dev *dev) { return -EINVAL; }
  #endif
  
 -static inline int i2c_dw_probe(struct dw_i2c_dev *dev)
 -{
 -	switch (dev->mode) {
 -	case DW_IC_SLAVE:
 -		return i2c_dw_probe_slave(dev);
 -	case DW_IC_MASTER:
 -		return i2c_dw_probe_master(dev);
 -	default:
 -		dev_err(dev->dev, "Wrong operation mode: %d\n", dev->mode);
 -		return -EINVAL;
 -	}
 -}
 -
 -static inline void i2c_dw_configure(struct dw_i2c_dev *dev)
 -{
 -	if (i2c_detect_slave_mode(dev->dev))
 -		i2c_dw_configure_slave(dev);
 -	else
 -		i2c_dw_configure_master(dev);
 -}
 -
  #if IS_ENABLED(CONFIG_I2C_DESIGNWARE_BAYTRAIL)
  extern int i2c_dw_probe_lock_support(struct dw_i2c_dev *dev);
 +extern void i2c_dw_remove_lock_support(struct dw_i2c_dev *dev);
  #else
  static inline int i2c_dw_probe_lock_support(struct dw_i2c_dev *dev) { return 0; }
 +static inline void i2c_dw_remove_lock_support(struct dw_i2c_dev *dev) {}
  #endif
++<<<<<<< HEAD
++=======
+ 
+ int i2c_dw_validate_speed(struct dw_i2c_dev *dev);
+ 
+ #if IS_ENABLED(CONFIG_ACPI)
+ int i2c_dw_acpi_configure(struct device *device);
+ void i2c_dw_acpi_adjust_bus_speed(struct device *device);
+ #else
+ static inline int i2c_dw_acpi_configure(struct device *device) { return -ENODEV; }
+ static inline void i2c_dw_acpi_adjust_bus_speed(struct device *device) {}
+ #endif
++>>>>>>> f9288fcc5c61 (i2c: designware: Move ACPI parts into common module)
diff --cc drivers/i2c/busses/i2c-designware-platdrv.c
index 3d5c410d94af,f6d2c96e35ce..000000000000
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@@ -39,84 -38,6 +38,87 @@@ static u32 i2c_dw_get_clk_rate_khz(stru
  }
  
  #ifdef CONFIG_ACPI
++<<<<<<< HEAD
 +/*
 + * The HCNT/LCNT information coming from ACPI should be the most accurate
 + * for given platform. However, some systems get it wrong. On such systems
 + * we get better results by calculating those based on the input clock.
 + */
 +static const struct dmi_system_id dw_i2c_no_acpi_params[] = {
 +	{
 +		.ident = "Dell Inspiron 7348",
 +		.matches = {
 +			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 7348"),
 +		},
 +	},
 +	{ }
 +};
 +
 +static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
 +			       u16 *hcnt, u16 *lcnt, u32 *sda_hold)
 +{
 +	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
 +	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
 +	union acpi_object *obj;
 +
 +	if (dmi_check_system(dw_i2c_no_acpi_params))
 +		return;
 +
 +	if (ACPI_FAILURE(acpi_evaluate_object(handle, method, NULL, &buf)))
 +		return;
 +
 +	obj = (union acpi_object *)buf.pointer;
 +	if (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 3) {
 +		const union acpi_object *objs = obj->package.elements;
 +
 +		*hcnt = (u16)objs[0].integer.value;
 +		*lcnt = (u16)objs[1].integer.value;
 +		*sda_hold = (u32)objs[2].integer.value;
 +	}
 +
 +	kfree(buf.pointer);
 +}
 +
 +static int dw_i2c_acpi_configure(struct platform_device *pdev)
 +{
 +	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
 +	struct i2c_timings *t = &dev->timings;
 +	u32 ss_ht = 0, fp_ht = 0, hs_ht = 0, fs_ht = 0;
 +
 +	dev->tx_fifo_depth = 32;
 +	dev->rx_fifo_depth = 32;
 +
 +	/*
 +	 * Try to get SDA hold time and *CNT values from an ACPI method for
 +	 * selected speed modes.
 +	 */
 +	dw_i2c_acpi_params(pdev, "SSCN", &dev->ss_hcnt, &dev->ss_lcnt, &ss_ht);
 +	dw_i2c_acpi_params(pdev, "FPCN", &dev->fp_hcnt, &dev->fp_lcnt, &fp_ht);
 +	dw_i2c_acpi_params(pdev, "HSCN", &dev->hs_hcnt, &dev->hs_lcnt, &hs_ht);
 +	dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt, &fs_ht);
 +
 +	switch (t->bus_freq_hz) {
 +	case 100000:
 +		dev->sda_hold_time = ss_ht;
 +		break;
 +	case 1000000:
 +		dev->sda_hold_time = fp_ht;
 +		break;
 +	case 3400000:
 +		dev->sda_hold_time = hs_ht;
 +		break;
 +	case 400000:
 +	default:
 +		dev->sda_hold_time = fs_ht;
 +		break;
 +	}
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> f9288fcc5c61 (i2c: designware: Move ACPI parts into common module)
  static const struct acpi_device_id dw_i2c_acpi_match[] = {
  	{ "INT33C2", 0 },
  	{ "INT33C3", 0 },
@@@ -231,11 -114,7 +228,15 @@@ static int dw_i2c_plat_probe(struct pla
  	struct i2c_adapter *adap;
  	struct dw_i2c_dev *dev;
  	struct i2c_timings *t;
++<<<<<<< HEAD
 +	u32 acpi_speed;
 +	int i, irq, ret;
 +	static const int supported_speeds[] = {
 +		0, 100000, 400000, 1000000, 3400000
 +	};
++=======
+ 	int irq, ret;
++>>>>>>> f9288fcc5c61 (i2c: designware: Move ACPI parts into common module)
  
  	irq = platform_get_irq(pdev, 0);
  	if (irq < 0)
@@@ -265,27 -144,7 +266,31 @@@
  	else
  		i2c_parse_fw_timings(&pdev->dev, t, false);
  
++<<<<<<< HEAD
 +	acpi_speed = i2c_acpi_find_bus_speed(&pdev->dev);
 +	/*
 +	 * Some DSTDs use a non standard speed, round down to the lowest
 +	 * standard speed.
 +	 */
 +	for (i = 1; i < ARRAY_SIZE(supported_speeds); i++) {
 +		if (acpi_speed < supported_speeds[i])
 +			break;
 +	}
 +	acpi_speed = supported_speeds[i - 1];
 +
 +	/*
 +	 * Find bus speed from the "clock-frequency" device property, ACPI
 +	 * or by using fast mode if neither is set.
 +	 */
 +	if (acpi_speed && t->bus_freq_hz)
 +		t->bus_freq_hz = min(t->bus_freq_hz, acpi_speed);
 +	else if (acpi_speed || t->bus_freq_hz)
 +		t->bus_freq_hz = max(t->bus_freq_hz, acpi_speed);
 +	else
 +		t->bus_freq_hz = 400000;
++=======
+ 	i2c_dw_acpi_adjust_bus_speed(&pdev->dev);
++>>>>>>> f9288fcc5c61 (i2c: designware: Move ACPI parts into common module)
  
  	dev->flags |= (uintptr_t)device_get_match_data(&pdev->dev);
  
@@@ -293,20 -152,11 +298,20 @@@
  		dw_i2c_of_configure(pdev);
  
  	if (has_acpi_companion(&pdev->dev))
- 		dw_i2c_acpi_configure(pdev);
+ 		i2c_dw_acpi_configure(&pdev->dev);
  
 -	ret = i2c_dw_validate_speed(dev);
 -	if (ret)
 +	/*
 +	 * Only standard mode at 100kHz, fast mode at 400kHz,
 +	 * fast mode plus at 1MHz and high speed mode at 3.4MHz are supported.
 +	 */
 +	if (t->bus_freq_hz != 100000 && t->bus_freq_hz != 400000 &&
 +	    t->bus_freq_hz != 1000000 && t->bus_freq_hz != 3400000) {
 +		dev_err(&pdev->dev,
 +			"%d Hz is unsupported, only 100kHz, 400kHz, 1MHz and 3.4MHz are supported\n",
 +			t->bus_freq_hz);
 +		ret = -EINVAL;
  		goto exit_reset;
 +	}
  
  	ret = i2c_dw_probe_lock_support(dev);
  	if (ret)
* Unmerged path drivers/i2c/busses/i2c-designware-common.c
* Unmerged path drivers/i2c/busses/i2c-designware-core.h
* Unmerged path drivers/i2c/busses/i2c-designware-platdrv.c
