PCI: vmd: Update type of the __iomem pointers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Krzysztof Wilczyński <kw@linux.com>
commit ce0602990fb762d53dd06167faedcd58d177199b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/ce060299.failed

Use "void __iomem" instead "char __iomem" pointer type when working with
the accessor functions (with names like readb() or writel(), etc.) to
better match a given accessor function signature where commonly the address
pointing to an I/O memory region would be a "void __iomem" pointer.

Related: https://lwn.net/Articles/102232/

	Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
Link: https://lore.kernel.org/r/20201129230743.3006978-5-kw@linux.com
	Signed-off-by: Krzysztof Wilczyński <kw@linux.com>
	Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Jon Derrick <jonathan.derrick@intel.com>
(cherry picked from commit ce0602990fb762d53dd06167faedcd58d177199b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/controller/vmd.c
diff --cc drivers/pci/controller/vmd.c
index 7ad9c77f39f5,59fa9a94860f..000000000000
--- a/drivers/pci/controller/vmd.c
+++ b/drivers/pci/controller/vmd.c
@@@ -292,18 -299,43 +292,49 @@@ static struct msi_domain_info vmd_msi_d
  	.chip		= &vmd_msi_controller,
  };
  
++<<<<<<< HEAD
 +static char __iomem *vmd_cfg_addr(struct vmd_dev *vmd, struct pci_bus *bus,
++=======
+ static int vmd_create_irq_domain(struct vmd_dev *vmd)
+ {
+ 	struct fwnode_handle *fn;
+ 
+ 	fn = irq_domain_alloc_named_id_fwnode("VMD-MSI", vmd->sysdata.domain);
+ 	if (!fn)
+ 		return -ENODEV;
+ 
+ 	vmd->irq_domain = pci_msi_create_irq_domain(fn, &vmd_msi_domain_info, NULL);
+ 	if (!vmd->irq_domain) {
+ 		irq_domain_free_fwnode(fn);
+ 		return -ENODEV;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void vmd_remove_irq_domain(struct vmd_dev *vmd)
+ {
+ 	if (vmd->irq_domain) {
+ 		struct fwnode_handle *fn = vmd->irq_domain->fwnode;
+ 
+ 		irq_domain_remove(vmd->irq_domain);
+ 		irq_domain_free_fwnode(fn);
+ 	}
+ }
+ 
+ static void __iomem *vmd_cfg_addr(struct vmd_dev *vmd, struct pci_bus *bus,
++>>>>>>> ce0602990fb7 (PCI: vmd: Update type of the __iomem pointers)
  				  unsigned int devfn, int reg, int len)
  {
 -	unsigned int busnr_ecam = bus->number - vmd->busn_start;
 -	u32 offset = PCIE_ECAM_OFFSET(busnr_ecam, devfn, reg);
 +	char __iomem *addr = vmd->cfgbar +
 +			     ((bus->number - vmd->busn_start) << 20) +
 +			     (devfn << 12) + reg;
  
 -	if (offset + len >= resource_size(&vmd->dev->resource[VMD_CFGBAR]))
 +	if ((addr - vmd->cfgbar) + len >=
 +	    resource_size(&vmd->dev->resource[VMD_CFGBAR]))
  		return NULL;
  
 -	return vmd->cfgbar + offset;
 +	return addr;
  }
  
  /*
* Unmerged path drivers/pci/controller/vmd.c
