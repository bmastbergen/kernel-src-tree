PM: domains: Allow to abort power off when no ->power_off() callback

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Ulf Hansson <ulf.hansson@linaro.org>
commit f63816e43d90442684cd2fd74f602cf3c5fae69c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/f63816e4.failed

In genpd_power_off() we may decide to abort the power off of the PM domain,
even beyond the point when the governor would accept it. The abort is done
if it turns out that a child domain has been requested to be powered on,
which means it's waiting for the lock of the parent to be released.

However, the abort is currently only considered if the genpd in question
has a ->power_off() callback assigned. This is unnecessary limiting,
especially if the genpd would have a parent of its own. Let's remove the
limitation and make the behaviour consistent.

	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
[ rjw: Subject edit ]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit f63816e43d90442684cd2fd74f602cf3c5fae69c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/power/domain.c
diff --cc drivers/base/power/domain.c
index 60ee8886b692,0198af358503..000000000000
--- a/drivers/base/power/domain.c
+++ b/drivers/base/power/domain.c
@@@ -551,24 -545,13 +552,31 @@@ static int genpd_power_off(struct gener
  	if (!genpd->gov)
  		genpd->state_idx = 0;
  
- 	if (genpd->power_off) {
- 		int ret;
+ 	/* Don't power off, if a child domain is waiting to power on. */
+ 	if (atomic_read(&genpd->sd_count) > 0)
+ 		return -EBUSY;
  
++<<<<<<< HEAD
 +		if (atomic_read(&genpd->sd_count) > 0)
 +			return -EBUSY;
 +
 +		/*
 +		 * If sd_count > 0 at this point, one of the subdomains hasn't
 +		 * managed to call genpd_power_on() for the master yet after
 +		 * incrementing it.  In that case genpd_power_on() will wait
 +		 * for us to drop the lock, so we can call .power_off() and let
 +		 * the genpd_power_on() restore power for us (this shouldn't
 +		 * happen very often).
 +		 */
 +		ret = _genpd_power_off(genpd, true);
 +		if (ret)
 +			return ret;
 +	}
++=======
+ 	ret = _genpd_power_off(genpd, true);
+ 	if (ret)
+ 		return ret;
++>>>>>>> f63816e43d90 (PM: domains: Allow to abort power off when no ->power_off() callback)
  
  	genpd->status = GENPD_STATE_OFF;
  	genpd_update_accounting(genpd);
* Unmerged path drivers/base/power/domain.c
