exec: In setup_new_exec cache current in the local variable me

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 7d503feba0c88586b4c9f1212e9cc582c9370fa7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/7d503feb.failed

At least gcc 8.3 when generating code for x86_64 has a hard time
consolidating multiple calls to current aka get_current(), and winds
up unnecessarily rereading %gs:current_task several times in
setup_new_exec.

Caching the value of current in the local variable of me generates
slightly better and shorter assembly.

	Reviewed-by: Kees Cook <keescook@chromium.org>
	Reviewed-by: Greg Ungerer <gerg@linux-m68k.org>
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit 7d503feba0c88586b4c9f1212e9cc582c9370fa7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/exec.c
diff --cc fs/exec.c
index 671dee5c3348,8c3abafb9bb1..000000000000
--- a/fs/exec.c
+++ b/fs/exec.c
@@@ -1405,9 -1442,33 +1406,39 @@@ void setup_new_exec(struct linux_binpr
  
  	/* An exec changes our domain. We are no longer part of the thread
  	   group */
++<<<<<<< HEAD
 +	WRITE_ONCE(current->task_struct_rh->self_exec_id,
 +		current->task_struct_rh->self_exec_id + 1);
 +	flush_signal_handlers(current, 0);
++=======
+ 	WRITE_ONCE(me->self_exec_id, me->self_exec_id + 1);
+ 	flush_signal_handlers(me, 0);
+ 
+ 	/*
+ 	 * install the new credentials for this executable
+ 	 */
+ 	security_bprm_committing_creds(bprm);
+ 
+ 	commit_creds(bprm->cred);
+ 	bprm->cred = NULL;
+ 
+ 	/*
+ 	 * Disable monitoring for regular users
+ 	 * when executing setuid binaries. Must
+ 	 * wait until new credentials are committed
+ 	 * by commit_creds() above
+ 	 */
+ 	if (get_dumpable(me->mm) != SUID_DUMP_USER)
+ 		perf_event_exit_task(me);
+ 	/*
+ 	 * cred_guard_mutex must be held at least to this point to prevent
+ 	 * ptrace_attach() from altering our determination of the task's
+ 	 * credentials; any time after this it may be unlocked.
+ 	 */
+ 	security_bprm_committed_creds(bprm);
+ 	mutex_unlock(&me->signal->exec_update_mutex);
+ 	mutex_unlock(&me->signal->cred_guard_mutex);
++>>>>>>> 7d503feba0c8 (exec: In setup_new_exec cache current in the local variable me)
  }
  EXPORT_SYMBOL(setup_new_exec);
  
* Unmerged path fs/exec.c
