KVM: stats: Add VM stat for remote tlb flush requests

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Jing Zhang <jingzhangos@google.com>
commit 3cc4e148b96263313e3dce926eae569c942bb74e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/3cc4e148.failed

Add a new stat that counts the number of times a remote TLB flush is
requested, regardless of whether it kicks vCPUs out of guest mode. This
allows us to look at how often flushes are initiated.

Unlike remote_tlb_flush, this one applies to ARM's instruction-set-based
TLB flush implementation, so apply it there too.

Original-by: David Matlack <dmatlack@google.com>
	Signed-off-by: Jing Zhang <jingzhangos@google.com>
Message-Id: <20210817002639.3856694-1-jingzhangos@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 3cc4e148b96263313e3dce926eae569c942bb74e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kvm/mmu.c
#	include/linux/kvm_host.h
#	include/linux/kvm_types.h
diff --cc arch/arm64/kvm/mmu.c
index 14b8c6fb282f,f5bb235bbb59..000000000000
--- a/arch/arm64/kvm/mmu.c
+++ b/arch/arm64/kvm/mmu.c
@@@ -67,32 -80,8 +67,37 @@@ static bool memslot_is_logging(struct k
   */
  void kvm_flush_remote_tlbs(struct kvm *kvm)
  {
++<<<<<<< HEAD
 +	kvm_call_hyp(__kvm_tlb_flush_vmid, kvm);
 +}
 +
 +static void kvm_tlb_flush_vmid_ipa(struct kvm *kvm, phys_addr_t ipa)
 +{
 +	kvm_call_hyp(__kvm_tlb_flush_vmid_ipa, kvm, ipa);
 +}
 +
 +/*
 + * D-Cache management functions. They take the page table entries by
 + * value, as they are flushing the cache using the kernel mapping (or
 + * kmap on 32bit).
 + */
 +static void kvm_flush_dcache_pte(pte_t pte)
 +{
 +	__kvm_flush_dcache_pte(pte);
 +}
 +
 +static void kvm_flush_dcache_pmd(pmd_t pmd)
 +{
 +	__kvm_flush_dcache_pmd(pmd);
 +}
 +
 +static void kvm_flush_dcache_pud(pud_t pud)
 +{
 +	__kvm_flush_dcache_pud(pud);
++=======
+ 	++kvm->stat.generic.remote_tlb_flush_requests;
+ 	kvm_call_hyp(__kvm_tlb_flush_vmid, &kvm->arch.mmu);
++>>>>>>> 3cc4e148b962 (KVM: stats: Add VM stat for remote tlb flush requests)
  }
  
  static bool kvm_is_device_pfn(unsigned long pfn)
diff --cc include/linux/kvm_host.h
index 53ea2b6e9d9d,c177789a8542..000000000000
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@@ -1250,27 -1347,173 +1250,135 @@@ enum kvm_stat_kind 
  
  struct kvm_stat_data {
  	struct kvm *kvm;
 -	const struct _kvm_stats_desc *desc;
 -	enum kvm_stat_kind kind;
 +	struct kvm_stats_debugfs_item *dbgfs_item;
  };
  
 -struct _kvm_stats_desc {
 -	struct kvm_stats_desc desc;
 -	char name[KVM_STATS_NAME_SIZE];
 +struct kvm_stats_debugfs_item {
 +	const char *name;
 +	int offset;
 +	enum kvm_stat_kind kind;
 +	int mode;
  };
  
 +#define KVM_DBGFS_GET_MODE(dbgfs_item)                                         \
 +	((dbgfs_item)->mode ? (dbgfs_item)->mode : 0644)
 +
++<<<<<<< HEAD
 +#define VM_STAT(n, x, ...) 							\
 +	{ n, offsetof(struct kvm, stat.x), KVM_STAT_VM, ## __VA_ARGS__ }
 +#define VCPU_STAT(n, x, ...)							\
 +	{ n, offsetof(struct kvm_vcpu, stat.x), KVM_STAT_VCPU, ## __VA_ARGS__ }
++=======
+ #define STATS_DESC_COMMON(type, unit, base, exp, sz, bsz)		       \
+ 	.flags = type | unit | base |					       \
+ 		 BUILD_BUG_ON_ZERO(type & ~KVM_STATS_TYPE_MASK) |	       \
+ 		 BUILD_BUG_ON_ZERO(unit & ~KVM_STATS_UNIT_MASK) |	       \
+ 		 BUILD_BUG_ON_ZERO(base & ~KVM_STATS_BASE_MASK),	       \
+ 	.exponent = exp,						       \
+ 	.size = sz,							       \
+ 	.bucket_size = bsz
+ 
+ #define VM_GENERIC_STATS_DESC(stat, type, unit, base, exp, sz, bsz)	       \
+ 	{								       \
+ 		{							       \
+ 			STATS_DESC_COMMON(type, unit, base, exp, sz, bsz),     \
+ 			.offset = offsetof(struct kvm_vm_stat, generic.stat)   \
+ 		},							       \
+ 		.name = #stat,						       \
+ 	}
+ #define VCPU_GENERIC_STATS_DESC(stat, type, unit, base, exp, sz, bsz)	       \
+ 	{								       \
+ 		{							       \
+ 			STATS_DESC_COMMON(type, unit, base, exp, sz, bsz),     \
+ 			.offset = offsetof(struct kvm_vcpu_stat, generic.stat) \
+ 		},							       \
+ 		.name = #stat,						       \
+ 	}
+ #define VM_STATS_DESC(stat, type, unit, base, exp, sz, bsz)		       \
+ 	{								       \
+ 		{							       \
+ 			STATS_DESC_COMMON(type, unit, base, exp, sz, bsz),     \
+ 			.offset = offsetof(struct kvm_vm_stat, stat)	       \
+ 		},							       \
+ 		.name = #stat,						       \
+ 	}
+ #define VCPU_STATS_DESC(stat, type, unit, base, exp, sz, bsz)		       \
+ 	{								       \
+ 		{							       \
+ 			STATS_DESC_COMMON(type, unit, base, exp, sz, bsz),     \
+ 			.offset = offsetof(struct kvm_vcpu_stat, stat)	       \
+ 		},							       \
+ 		.name = #stat,						       \
+ 	}
+ /* SCOPE: VM, VM_GENERIC, VCPU, VCPU_GENERIC */
+ #define STATS_DESC(SCOPE, stat, type, unit, base, exp, sz, bsz)		       \
+ 	SCOPE##_STATS_DESC(stat, type, unit, base, exp, sz, bsz)
+ 
+ #define STATS_DESC_CUMULATIVE(SCOPE, name, unit, base, exponent)	       \
+ 	STATS_DESC(SCOPE, name, KVM_STATS_TYPE_CUMULATIVE,		       \
+ 		unit, base, exponent, 1, 0)
+ #define STATS_DESC_INSTANT(SCOPE, name, unit, base, exponent)		       \
+ 	STATS_DESC(SCOPE, name, KVM_STATS_TYPE_INSTANT,			       \
+ 		unit, base, exponent, 1, 0)
+ #define STATS_DESC_PEAK(SCOPE, name, unit, base, exponent)		       \
+ 	STATS_DESC(SCOPE, name, KVM_STATS_TYPE_PEAK,			       \
+ 		unit, base, exponent, 1, 0)
+ #define STATS_DESC_LINEAR_HIST(SCOPE, name, unit, base, exponent, sz, bsz)     \
+ 	STATS_DESC(SCOPE, name, KVM_STATS_TYPE_LINEAR_HIST,		       \
+ 		unit, base, exponent, sz, bsz)
+ #define STATS_DESC_LOG_HIST(SCOPE, name, unit, base, exponent, sz)	       \
+ 	STATS_DESC(SCOPE, name, KVM_STATS_TYPE_LOG_HIST,		       \
+ 		unit, base, exponent, sz, 0)
+ 
+ /* Cumulative counter, read/write */
+ #define STATS_DESC_COUNTER(SCOPE, name)					       \
+ 	STATS_DESC_CUMULATIVE(SCOPE, name, KVM_STATS_UNIT_NONE,		       \
+ 		KVM_STATS_BASE_POW10, 0)
+ /* Instantaneous counter, read only */
+ #define STATS_DESC_ICOUNTER(SCOPE, name)				       \
+ 	STATS_DESC_INSTANT(SCOPE, name, KVM_STATS_UNIT_NONE,		       \
+ 		KVM_STATS_BASE_POW10, 0)
+ /* Peak counter, read/write */
+ #define STATS_DESC_PCOUNTER(SCOPE, name)				       \
+ 	STATS_DESC_PEAK(SCOPE, name, KVM_STATS_UNIT_NONE,		       \
+ 		KVM_STATS_BASE_POW10, 0)
+ 
+ /* Cumulative time in nanosecond */
+ #define STATS_DESC_TIME_NSEC(SCOPE, name)				       \
+ 	STATS_DESC_CUMULATIVE(SCOPE, name, KVM_STATS_UNIT_SECONDS,	       \
+ 		KVM_STATS_BASE_POW10, -9)
+ /* Linear histogram for time in nanosecond */
+ #define STATS_DESC_LINHIST_TIME_NSEC(SCOPE, name, sz, bsz)		       \
+ 	STATS_DESC_LINEAR_HIST(SCOPE, name, KVM_STATS_UNIT_SECONDS,	       \
+ 		KVM_STATS_BASE_POW10, -9, sz, bsz)
+ /* Logarithmic histogram for time in nanosecond */
+ #define STATS_DESC_LOGHIST_TIME_NSEC(SCOPE, name, sz)			       \
+ 	STATS_DESC_LOG_HIST(SCOPE, name, KVM_STATS_UNIT_SECONDS,	       \
+ 		KVM_STATS_BASE_POW10, -9, sz)
+ 
+ #define KVM_GENERIC_VM_STATS()						       \
+ 	STATS_DESC_COUNTER(VM_GENERIC, remote_tlb_flush),		       \
+ 	STATS_DESC_COUNTER(VM_GENERIC, remote_tlb_flush_requests)
+ 
+ #define KVM_GENERIC_VCPU_STATS()					       \
+ 	STATS_DESC_COUNTER(VCPU_GENERIC, halt_successful_poll),		       \
+ 	STATS_DESC_COUNTER(VCPU_GENERIC, halt_attempted_poll),		       \
+ 	STATS_DESC_COUNTER(VCPU_GENERIC, halt_poll_invalid),		       \
+ 	STATS_DESC_COUNTER(VCPU_GENERIC, halt_wakeup),			       \
+ 	STATS_DESC_TIME_NSEC(VCPU_GENERIC, halt_poll_success_ns),	       \
+ 	STATS_DESC_TIME_NSEC(VCPU_GENERIC, halt_poll_fail_ns),		       \
+ 	STATS_DESC_TIME_NSEC(VCPU_GENERIC, halt_wait_ns),		       \
+ 	STATS_DESC_LOGHIST_TIME_NSEC(VCPU_GENERIC, halt_poll_success_hist,     \
+ 			HALT_POLL_HIST_COUNT),				       \
+ 	STATS_DESC_LOGHIST_TIME_NSEC(VCPU_GENERIC, halt_poll_fail_hist,	       \
+ 			HALT_POLL_HIST_COUNT),				       \
+ 	STATS_DESC_LOGHIST_TIME_NSEC(VCPU_GENERIC, halt_wait_hist,	       \
+ 			HALT_POLL_HIST_COUNT)
++>>>>>>> 3cc4e148b962 (KVM: stats: Add VM stat for remote tlb flush requests)
  
 +extern struct kvm_stats_debugfs_item debugfs_entries[];
  extern struct dentry *kvm_debugfs_dir;
  
 -ssize_t kvm_stats_read(char *id, const struct kvm_stats_header *header,
 -		       const struct _kvm_stats_desc *desc,
 -		       void *stats, size_t size_stats,
 -		       char __user *user_buffer, size_t size, loff_t *offset);
 -
 -/**
 - * kvm_stats_linear_hist_update() - Update bucket value for linear histogram
 - * statistics data.
 - *
 - * @data: start address of the stats data
 - * @size: the number of bucket of the stats data
 - * @value: the new value used to update the linear histogram's bucket
 - * @bucket_size: the size (width) of a bucket
 - */
 -static inline void kvm_stats_linear_hist_update(u64 *data, size_t size,
 -						u64 value, size_t bucket_size)
 -{
 -	size_t index = div64_u64(value, bucket_size);
 -
 -	index = min(index, size - 1);
 -	++data[index];
 -}
 -
 -/**
 - * kvm_stats_log_hist_update() - Update bucket value for logarithmic histogram
 - * statistics data.
 - *
 - * @data: start address of the stats data
 - * @size: the number of bucket of the stats data
 - * @value: the new value used to update the logarithmic histogram's bucket
 - */
 -static inline void kvm_stats_log_hist_update(u64 *data, size_t size, u64 value)
 -{
 -	size_t index = fls64(value);
 -
 -	index = min(index, size - 1);
 -	++data[index];
 -}
 -
 -#define KVM_STATS_LINEAR_HIST_UPDATE(array, value, bsize)		       \
 -	kvm_stats_linear_hist_update(array, ARRAY_SIZE(array), value, bsize)
 -#define KVM_STATS_LOG_HIST_UPDATE(array, value)				       \
 -	kvm_stats_log_hist_update(array, ARRAY_SIZE(array), value)
 -
 -
 -extern const struct kvm_stats_header kvm_vm_stats_header;
 -extern const struct _kvm_stats_desc kvm_vm_stats_desc[];
 -extern const struct kvm_stats_header kvm_vcpu_stats_header;
 -extern const struct _kvm_stats_desc kvm_vcpu_stats_desc[];
 -
  #if defined(CONFIG_MMU_NOTIFIER) && defined(KVM_ARCH_WANT_MMU_NOTIFIER)
  static inline int mmu_notifier_retry(struct kvm *kvm, unsigned long mmu_seq)
  {
diff --cc include/linux/kvm_types.h
index 8446b08abe44,2237abb93ccd..000000000000
--- a/include/linux/kvm_types.h
+++ b/include/linux/kvm_types.h
@@@ -90,5 -76,26 +90,29 @@@ struct kvm_mmu_memory_cache 
  };
  #endif
  
++<<<<<<< HEAD
++=======
+ #define HALT_POLL_HIST_COUNT			32
+ 
+ struct kvm_vm_stat_generic {
+ 	u64 remote_tlb_flush;
+ 	u64 remote_tlb_flush_requests;
+ };
+ 
+ struct kvm_vcpu_stat_generic {
+ 	u64 halt_successful_poll;
+ 	u64 halt_attempted_poll;
+ 	u64 halt_poll_invalid;
+ 	u64 halt_wakeup;
+ 	u64 halt_poll_success_ns;
+ 	u64 halt_poll_fail_ns;
+ 	u64 halt_wait_ns;
+ 	u64 halt_poll_success_hist[HALT_POLL_HIST_COUNT];
+ 	u64 halt_poll_fail_hist[HALT_POLL_HIST_COUNT];
+ 	u64 halt_wait_hist[HALT_POLL_HIST_COUNT];
+ };
+ 
+ #define KVM_STATS_NAME_SIZE	48
++>>>>>>> 3cc4e148b962 (KVM: stats: Add VM stat for remote tlb flush requests)
  
  #endif /* __KVM_TYPES_H__ */
* Unmerged path arch/arm64/kvm/mmu.c
* Unmerged path include/linux/kvm_host.h
* Unmerged path include/linux/kvm_types.h
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 04fef38446f1..7edfcd7b8af5 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -322,6 +322,7 @@ void kvm_flush_remote_tlbs(struct kvm *kvm)
 	 */
 	long dirty_count = smp_load_acquire(&kvm->tlbs_dirty);
 
+	++kvm->stat.generic.remote_tlb_flush_requests;
 	/*
 	 * We want to publish modifications to the page tables before reading
 	 * mode. Pairs with a memory barrier in arch-specific code.
