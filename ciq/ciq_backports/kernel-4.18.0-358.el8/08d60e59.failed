printk: fix string termination for record_print_text()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author John Ogness <john.ogness@linutronix.de>
commit 08d60e5999540110576e7c1346d486220751b7f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/08d60e59.failed

Commit f0e386ee0c0b ("printk: fix buffer overflow potential for
print_text()") added string termination in record_print_text().
However it used the wrong base pointer for adding the terminator.
This led to a 0-byte being written somewhere beyond the buffer.

Use the correct base pointer when adding the terminator.

Fixes: f0e386ee0c0b ("printk: fix buffer overflow potential for print_text()")
	Reported-by: Sven Schnelle <svens@linux.ibm.com>
	Signed-off-by: John Ogness <john.ogness@linutronix.de>
	Signed-off-by: Petr Mladek <pmladek@suse.com>
Link: https://lore.kernel.org/r/20210124202728.4718-1-john.ogness@linutronix.de
(cherry picked from commit 08d60e5999540110576e7c1346d486220751b7f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/printk/printk.c
diff --cc kernel/printk/printk.c
index 9c33249065a6,c55cd1820689..000000000000
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@@ -1340,43 -1286,120 +1340,91 @@@ static size_t print_prefix(const struc
  	return len;
  }
  
 -/*
 - * Prepare the record for printing. The text is shifted within the given
 - * buffer to avoid a need for another one. The following operations are
 - * done:
 - *
 - *   - Add prefix for each line.
 - *   - Drop truncated lines that no longer fit into the buffer.
 - *   - Add the trailing newline that has been removed in vprintk_store().
 - *   - Add a string terminator.
 - *
 - * Since the produced string is always terminated, the maximum possible
 - * return value is @r->text_buf_size - 1;
 - *
 - * Return: The length of the updated/prepared text, including the added
 - * prefixes and the newline. The terminator is not counted. The dropped
 - * line(s) are not counted.
 - */
 -static size_t record_print_text(struct printk_record *r, bool syslog,
 -				bool time)
 +static size_t msg_print_text(const struct printk_log *msg, bool syslog,
 +			     bool time, char *buf, size_t size)
  {
 -	size_t text_len = r->info->text_len;
 -	size_t buf_size = r->text_buf_size;
 -	char *text = r->text_buf;
 -	char prefix[PREFIX_MAX];
 -	bool truncated = false;
 -	size_t prefix_len;
 -	size_t line_len;
 +	const char *text = log_text(msg);
 +	size_t text_size = msg->text_len;
  	size_t len = 0;
 -	char *next;
 -
 -	/*
 -	 * If the message was truncated because the buffer was not large
 -	 * enough, treat the available text as if it were the full text.
 -	 */
 -	if (text_len > buf_size)
 -		text_len = buf_size;
 +	char prefix[PREFIX_MAX];
 +	const size_t prefix_len = print_prefix(msg, syslog, time, prefix);
  
 -	prefix_len = info_print_prefix(r->info, syslog, time, prefix);
 +	do {
 +		const char *next = memchr(text, '\n', text_size);
 +		size_t text_len;
  
 -	/*
 -	 * @text_len: bytes of unprocessed text
 -	 * @line_len: bytes of current line _without_ newline
 -	 * @text:     pointer to beginning of current line
 -	 * @len:      number of bytes prepared in r->text_buf
 -	 */
 -	for (;;) {
 -		next = memchr(text, '\n', text_len);
  		if (next) {
 -			line_len = next - text;
 +			text_len = next - text;
 +			next++;
 +			text_size -= next - text;
  		} else {
 -			/* Drop truncated line(s). */
 -			if (truncated)
 -				break;
 -			line_len = text_len;
 +			text_len = text_size;
  		}
  
 -		/*
 -		 * Truncate the text if there is not enough space to add the
 -		 * prefix and a trailing newline and a terminator.
 -		 */
 -		if (len + prefix_len + text_len + 1 + 1 > buf_size) {
 -			/* Drop even the current line if no space. */
 -			if (len + prefix_len + line_len + 1 + 1 > buf_size)
 +		if (buf) {
 +			if (prefix_len + text_len + 1 >= size - len)
  				break;
  
 -			text_len = buf_size - len - prefix_len - 1 - 1;
 -			truncated = true;
 +			memcpy(buf + len, prefix, prefix_len);
 +			len += prefix_len;
 +			memcpy(buf + len, text, text_len);
 +			len += text_len;
 +			buf[len++] = '\n';
 +		} else {
 +			/* SYSLOG_ACTION_* buffer size only calculation */
 +			len += prefix_len + text_len + 1;
  		}
  
++<<<<<<< HEAD
 +		text = next;
 +	} while (text);
++=======
+ 		memmove(text + prefix_len, text, text_len);
+ 		memcpy(text, prefix, prefix_len);
+ 
+ 		/*
+ 		 * Increment the prepared length to include the text and
+ 		 * prefix that were just moved+copied. Also increment for the
+ 		 * newline at the end of this line. If this is the last line,
+ 		 * there is no newline, but it will be added immediately below.
+ 		 */
+ 		len += prefix_len + line_len + 1;
+ 		if (text_len == line_len) {
+ 			/*
+ 			 * This is the last line. Add the trailing newline
+ 			 * removed in vprintk_store().
+ 			 */
+ 			text[prefix_len + line_len] = '\n';
+ 			break;
+ 		}
+ 
+ 		/*
+ 		 * Advance beyond the added prefix and the related line with
+ 		 * its newline.
+ 		 */
+ 		text += prefix_len + line_len + 1;
+ 
+ 		/*
+ 		 * The remaining text has only decreased by the line with its
+ 		 * newline.
+ 		 *
+ 		 * Note that @text_len can become zero. It happens when @text
+ 		 * ended with a newline (either due to truncation or the
+ 		 * original string ending with "\n\n"). The loop is correctly
+ 		 * repeated and (if not truncated) an empty line with a prefix
+ 		 * will be prepared.
+ 		 */
+ 		text_len -= line_len + 1;
+ 	}
+ 
+ 	/*
+ 	 * If a buffer was provided, it will be terminated. Space for the
+ 	 * string terminator is guaranteed to be available. The terminator is
+ 	 * not counted in the return value.
+ 	 */
+ 	if (buf_size > 0)
+ 		r->text_buf[len] = 0;
++>>>>>>> 08d60e599954 (printk: fix string termination for record_print_text())
  
  	return len;
  }
* Unmerged path kernel/printk/printk.c
