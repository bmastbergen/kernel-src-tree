nfsd: helper for laundromat expiry calculations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author J. Bruce Fields <bfields@redhat.com>
commit 7f7e7a4006f74b031718055a0751c70c2e3d5e7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/7f7e7a40.failed

We do this same logic repeatedly, and it's easy to get the sense of the
comparison wrong.

	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 7f7e7a4006f74b031718055a0751c70c2e3d5e7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4state.c
diff --cc fs/nfsd/nfs4state.c
index 97f82a43a97b,1aa7d4ee7c15..000000000000
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@@ -5296,15 -5363,30 +5312,38 @@@ nfs4_laundromat(struct nfsd_net *nn
  	struct nfs4_ol_stateid *stp;
  	struct nfsd4_blocked_lock *nbl;
  	struct list_head *pos, *next, reaplist;
++<<<<<<< HEAD
 +	time64_t cutoff = ktime_get_boottime_seconds() - nn->nfsd4_lease;
 +	time64_t t, new_timeo = nn->nfsd4_lease;
++=======
+ 	struct laundry_time lt = {
+ 		.cutoff = ktime_get_boottime_seconds() - nn->nfsd4_lease,
+ 		.new_timeo = nn->nfsd4_lease
+ 	};
+ 	struct nfs4_cpntf_state *cps;
+ 	copy_stateid_t *cps_t;
+ 	int i;
++>>>>>>> 7f7e7a4006f7 (nfsd: helper for laundromat expiry calculations)
  
  	if (clients_still_reclaiming(nn)) {
- 		new_timeo = 0;
+ 		lt.new_timeo = 0;
  		goto out;
  	}
  	nfsd4_end_grace(nn);
  	INIT_LIST_HEAD(&reaplist);
++<<<<<<< HEAD
++=======
+ 
+ 	spin_lock(&nn->s2s_cp_lock);
+ 	idr_for_each_entry(&nn->s2s_cp_stateids, cps_t, i) {
+ 		cps = container_of(cps_t, struct nfs4_cpntf_state, cp_stateid);
+ 		if (cps->cp_stateid.sc_type == NFS4_COPYNOTIFY_STID &&
+ 				state_expired(&lt, cps->cpntf_time))
+ 			_free_cpntf_state_locked(nn, cps);
+ 	}
+ 	spin_unlock(&nn->s2s_cp_lock);
+ 
++>>>>>>> 7f7e7a4006f7 (nfsd: helper for laundromat expiry calculations)
  	spin_lock(&nn->client_lock);
  	list_for_each_safe(pos, next, &nn->client_lru) {
  		clp = list_entry(pos, struct nfs4_client, cl_lru);
* Unmerged path fs/nfsd/nfs4state.c
