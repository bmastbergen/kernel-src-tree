locking/rtmutex: Dequeue waiter on ww_mutex deadlock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 37e8abff2bebbf9947d6b784f5c75ed48a717089
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/37e8abff.failed

The rt_mutex based ww_mutex variant queues the new waiter first in the
lock's rbtree before evaluating the ww_mutex specific conditions which
might decide that the waiter should back out. This check and conditional
exit happens before the waiter is enqueued into the PI chain.

The failure handling at the call site assumes that the waiter, if it is the
top most waiter on the lock, is queued in the PI chain and then proceeds to
adjust the unmodified PI chain, which results in RB tree corruption.

Dequeue the waiter from the lock waiter list in the ww_mutex error exit
path to prevent this.

Fixes: add461325ec5 ("locking/rtmutex: Extend the rtmutex core to support ww_mutex")
	Reported-by: Sebastian Siewior <bigeasy@linutronix.de>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20210825102454.042280541@linutronix.de
(cherry picked from commit 37e8abff2bebbf9947d6b784f5c75ed48a717089)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/locking/rtmutex.c
diff --cc kernel/locking/rtmutex.c
index ebfe41ea03fb,c8fe74ef8db9..000000000000
--- a/kernel/locking/rtmutex.c
+++ b/kernel/locking/rtmutex.c
@@@ -1013,6 -1076,21 +1013,24 @@@ static int __sched task_blocks_on_rt_mu
  
  	raw_spin_unlock(&task->pi_lock);
  
++<<<<<<< HEAD
++=======
+ 	if (build_ww_mutex() && ww_ctx) {
+ 		struct rt_mutex *rtm;
+ 
+ 		/* Check whether the waiter should back out immediately */
+ 		rtm = container_of(lock, struct rt_mutex, rtmutex);
+ 		res = __ww_mutex_add_waiter(waiter, rtm, ww_ctx);
+ 		if (res) {
+ 			raw_spin_lock(&task->pi_lock);
+ 			rt_mutex_dequeue(lock, waiter);
+ 			task->pi_blocked_on = NULL;
+ 			raw_spin_unlock(&task->pi_lock);
+ 			return res;
+ 		}
+ 	}
+ 
++>>>>>>> 37e8abff2beb (locking/rtmutex: Dequeue waiter on ww_mutex deadlock)
  	if (!owner)
  		return 0;
  
* Unmerged path kernel/locking/rtmutex.c
