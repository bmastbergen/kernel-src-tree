Bluetooth: Fix kernel oops triggered by hci_adv_monitors_clear()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Miao-chen Chou <mcchou@chromium.org>
commit b83764f9220a4a14525657466f299850bbc98de9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/b83764f9.failed

This fixes the kernel oops by removing unnecessary background scan
update from hci_adv_monitors_clear() which shouldn't invoke any work
queue.

The following test was performed.
- Run "rmmod btusb" and verify that no kernel oops is triggered.

	Signed-off-by: Miao-chen Chou <mcchou@chromium.org>
	Reviewed-by: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
	Reviewed-by: Alain Michaud <alainm@chromium.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit b83764f9220a4a14525657466f299850bbc98de9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/hci_core.c
diff --cc net/bluetooth/hci_core.c
index 666cd966baa4,6509f785dd14..000000000000
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@@ -2995,6 -2995,94 +2995,97 @@@ int hci_add_adv_instance(struct hci_de
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* This function requires the caller holds hdev->lock */
+ void hci_adv_monitors_clear(struct hci_dev *hdev)
+ {
+ 	struct adv_monitor *monitor;
+ 	int handle;
+ 
+ 	idr_for_each_entry(&hdev->adv_monitors_idr, monitor, handle)
+ 		hci_free_adv_monitor(monitor);
+ 
+ 	idr_destroy(&hdev->adv_monitors_idr);
+ }
+ 
+ void hci_free_adv_monitor(struct adv_monitor *monitor)
+ {
+ 	struct adv_pattern *pattern;
+ 	struct adv_pattern *tmp;
+ 
+ 	if (!monitor)
+ 		return;
+ 
+ 	list_for_each_entry_safe(pattern, tmp, &monitor->patterns, list)
+ 		kfree(pattern);
+ 
+ 	kfree(monitor);
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ int hci_add_adv_monitor(struct hci_dev *hdev, struct adv_monitor *monitor)
+ {
+ 	int min, max, handle;
+ 
+ 	if (!monitor)
+ 		return -EINVAL;
+ 
+ 	min = HCI_MIN_ADV_MONITOR_HANDLE;
+ 	max = HCI_MIN_ADV_MONITOR_HANDLE + HCI_MAX_ADV_MONITOR_NUM_HANDLES;
+ 	handle = idr_alloc(&hdev->adv_monitors_idr, monitor, min, max,
+ 			   GFP_KERNEL);
+ 	if (handle < 0)
+ 		return handle;
+ 
+ 	hdev->adv_monitors_cnt++;
+ 	monitor->handle = handle;
+ 
+ 	hci_update_background_scan(hdev);
+ 
+ 	return 0;
+ }
+ 
+ static int free_adv_monitor(int id, void *ptr, void *data)
+ {
+ 	struct hci_dev *hdev = data;
+ 	struct adv_monitor *monitor = ptr;
+ 
+ 	idr_remove(&hdev->adv_monitors_idr, monitor->handle);
+ 	hci_free_adv_monitor(monitor);
+ 
+ 	return 0;
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ int hci_remove_adv_monitor(struct hci_dev *hdev, u16 handle)
+ {
+ 	struct adv_monitor *monitor;
+ 
+ 	if (handle) {
+ 		monitor = idr_find(&hdev->adv_monitors_idr, handle);
+ 		if (!monitor)
+ 			return -ENOENT;
+ 
+ 		idr_remove(&hdev->adv_monitors_idr, monitor->handle);
+ 		hci_free_adv_monitor(monitor);
+ 	} else {
+ 		/* Remove all monitors if handle is 0. */
+ 		idr_for_each(&hdev->adv_monitors_idr, &free_adv_monitor, hdev);
+ 	}
+ 
+ 	hci_update_background_scan(hdev);
+ 
+ 	return 0;
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ bool hci_is_adv_monitoring(struct hci_dev *hdev)
+ {
+ 	return !idr_is_empty(&hdev->adv_monitors_idr);
+ }
+ 
++>>>>>>> b83764f9220a (Bluetooth: Fix kernel oops triggered by hci_adv_monitors_clear())
  struct bdaddr_list *hci_bdaddr_list_lookup(struct list_head *bdaddr_list,
  					 bdaddr_t *bdaddr, u8 type)
  {
* Unmerged path net/bluetooth/hci_core.c
