x86/mm: Report which part of kernel image is freed

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Kees Cook <keescook@chromium.org>
commit 5494c3a6a0b965906ffdcb620d94079ea4cb69ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/5494c3a6.failed

The memory freeing report wasn't very useful for figuring out which
parts of the kernel image were being freed. Add the details for clearer
reporting in dmesg.

Before:

  Freeing unused kernel image memory: 1348K
  Write protecting the kernel read-only data: 20480k
  Freeing unused kernel image memory: 2040K
  Freeing unused kernel image memory: 172K

After:

  Freeing unused kernel image (initmem) memory: 1348K
  Write protecting the kernel read-only data: 20480k
  Freeing unused kernel image (text/rodata gap) memory: 2040K
  Freeing unused kernel image (rodata/data gap) memory: 172K

	Signed-off-by: Kees Cook <keescook@chromium.org>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: linux-alpha@vger.kernel.org
	Cc: linux-arch@vger.kernel.org
	Cc: linux-arm-kernel@lists.infradead.org
	Cc: linux-c6x-dev@linux-c6x.org
	Cc: linux-ia64@vger.kernel.org
	Cc: linuxppc-dev@lists.ozlabs.org
	Cc: linux-s390@vger.kernel.org
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Michal Simek <monstr@monstr.eu>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rick Edgecombe <rick.p.edgecombe@intel.com>
	Cc: Segher Boessenkool <segher@kernel.crashing.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Will Deacon <will@kernel.org>
	Cc: x86-ml <x86@kernel.org>
	Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
Link: https://lkml.kernel.org/r/20191029211351.13243-28-keescook@chromium.org
(cherry picked from commit 5494c3a6a0b965906ffdcb620d94079ea4cb69ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/processor.h
#	arch/x86/mm/init.c
#	arch/x86/mm/init_64.c
diff --cc arch/x86/include/asm/processor.h
index f9976803eb50,790f250d39a8..000000000000
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@@ -910,7 -957,8 +910,12 @@@ static inline uint32_t hypervisor_cpuid
  }
  
  extern unsigned long arch_align_stack(unsigned long sp);
++<<<<<<< HEAD
 +extern void free_init_pages(char *what, unsigned long begin, unsigned long end);
++=======
+ void free_init_pages(const char *what, unsigned long begin, unsigned long end);
+ extern void free_kernel_image_pages(const char *what, void *begin, void *end);
++>>>>>>> 5494c3a6a0b9 (x86/mm: Report which part of kernel image is freed)
  
  void default_idle(void);
  #ifdef	CONFIG_XEN
diff --cc arch/x86/mm/init.c
index d56c62c50b99,e7bb483557c9..000000000000
--- a/arch/x86/mm/init.c
+++ b/arch/x86/mm/init.c
@@@ -818,6 -824,38 +818,41 @@@ void free_init_pages(char *what, unsign
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * begin/end can be in the direct map or the "high kernel mapping"
+  * used for the kernel image only.  free_init_pages() will do the
+  * right thing for either kind of address.
+  */
+ void free_kernel_image_pages(const char *what, void *begin, void *end)
+ {
+ 	unsigned long begin_ul = (unsigned long)begin;
+ 	unsigned long end_ul = (unsigned long)end;
+ 	unsigned long len_pages = (end_ul - begin_ul) >> PAGE_SHIFT;
+ 
+ 	free_init_pages(what, begin_ul, end_ul);
+ 
+ 	/*
+ 	 * PTI maps some of the kernel into userspace.  For performance,
+ 	 * this includes some kernel areas that do not contain secrets.
+ 	 * Those areas might be adjacent to the parts of the kernel image
+ 	 * being freed, which may contain secrets.  Remove the "high kernel
+ 	 * image mapping" for these freed areas, ensuring they are not even
+ 	 * potentially vulnerable to Meltdown regardless of the specific
+ 	 * optimizations PTI is currently using.
+ 	 *
+ 	 * The "noalias" prevents unmapping the direct map alias which is
+ 	 * needed to access the freed pages.
+ 	 *
+ 	 * This is only valid for 64bit kernels. 32bit has only one mapping
+ 	 * which can't be treated in this way for obvious reasons.
+ 	 */
+ 	if (IS_ENABLED(CONFIG_X86_64) && cpu_feature_enabled(X86_FEATURE_PTI))
+ 		set_memory_np_noalias(begin_ul, len_pages);
+ }
+ 
++>>>>>>> 5494c3a6a0b9 (x86/mm: Report which part of kernel image is freed)
  void __weak mem_encrypt_free_decrypted_mem(void) { }
  
  void __ref free_initmem(void)
@@@ -826,9 -864,8 +861,14 @@@
  
  	mem_encrypt_free_decrypted_mem();
  
++<<<<<<< HEAD
 +	free_init_pages("unused kernel",
 +			(unsigned long)(&__init_begin),
 +			(unsigned long)(&__init_end));
++=======
+ 	free_kernel_image_pages("unused kernel image (initmem)",
+ 				&__init_begin, &__init_end);
++>>>>>>> 5494c3a6a0b9 (x86/mm: Report which part of kernel image is freed)
  }
  
  #ifdef CONFIG_BLK_DEV_INITRD
diff --cc arch/x86/mm/init_64.c
index 614d6126b132,dcb9bc961b39..000000000000
--- a/arch/x86/mm/init_64.c
+++ b/arch/x86/mm/init_64.c
@@@ -1347,16 -1334,12 +1347,23 @@@ void mark_rodata_ro(void
  	set_memory_ro(start, (end-start) >> PAGE_SHIFT);
  #endif
  
++<<<<<<< HEAD
 +	free_init_pages("unused kernel", text_end, rodata_start);
 +	free_init_pages("unused kernel", rodata_end, _sdata);
++=======
+ 	free_kernel_image_pages("unused kernel image (text/rodata gap)",
+ 				(void *)text_end, (void *)rodata_start);
+ 	free_kernel_image_pages("unused kernel image (rodata/data gap)",
+ 				(void *)rodata_end, (void *)_sdata);
++>>>>>>> 5494c3a6a0b9 (x86/mm: Report which part of kernel image is freed)
  
  	debug_checkwx();
 +
 +	/*
 +	 * Do this after all of the manipulation of the
 +	 * kernel text page tables are complete.
 +	 */
 +	pti_clone_kernel_text();
  }
  
  int kern_addr_valid(unsigned long addr)
* Unmerged path arch/x86/include/asm/processor.h
* Unmerged path arch/x86/mm/init.c
* Unmerged path arch/x86/mm/init_64.c
