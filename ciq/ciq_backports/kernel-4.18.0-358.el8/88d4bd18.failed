net: bridge: mdb: add support for add/del/dump of entries with source

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 88d4bd180419a7cde3947f191dc4e26fbb19f80b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/88d4bd18.failed

Add new mdb attributes (MDBE_ATTR_SOURCE for setting,
MDBA_MDB_EATTR_SOURCE for dumping) to allow add/del and dump of mdb
entries with a source address (S,G). New S,G entries are created with
filter mode of MCAST_INCLUDE. The same attributes are used for IPv4 and
IPv6, they're validated and parsed based on their protocol.
S,G host joined entries which are added by user are not allowed yet.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 88d4bd180419a7cde3947f191dc4e26fbb19f80b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_mdb.c
diff --cc net/bridge/br_mdb.c
index 40754c5e5bdc,7f9ca5c20120..000000000000
--- a/net/bridge/br_mdb.c
+++ b/net/bridge/br_mdb.c
@@@ -69,12 -70,21 +70,29 @@@ static void __mdb_entry_to_br_ip(struc
  	memset(ip, 0, sizeof(struct br_ip));
  	ip->vid = entry->vid;
  	ip->proto = entry->addr.proto;
++<<<<<<< HEAD
 +	if (ip->proto == htons(ETH_P_IP))
 +		ip->u.ip4 = entry->addr.u.ip4;
 +#if IS_ENABLED(CONFIG_IPV6)
 +	else
 +		ip->u.ip6 = entry->addr.u.ip6;
++=======
+ 	switch (ip->proto) {
+ 	case htons(ETH_P_IP):
+ 		ip->dst.ip4 = entry->addr.u.ip4;
+ 		if (mdb_attrs && mdb_attrs[MDBE_ATTR_SOURCE])
+ 			ip->src.ip4 = nla_get_in_addr(mdb_attrs[MDBE_ATTR_SOURCE]);
+ 		break;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	case htons(ETH_P_IPV6):
+ 		ip->dst.ip6 = entry->addr.u.ip6;
+ 		if (mdb_attrs && mdb_attrs[MDBE_ATTR_SOURCE])
+ 			ip->src.ip6 = nla_get_in6_addr(mdb_attrs[MDBE_ATTR_SOURCE]);
+ 		break;
++>>>>>>> 88d4bd180419 (net: bridge: mdb: add support for add/del/dump of entries with source)
  #endif
+ 	}
+ 
  }
  
  static int __mdb_fill_srcs(struct sk_buff *skb,
diff --git a/include/uapi/linux/if_bridge.h b/include/uapi/linux/if_bridge.h
index c424bb8708cd..eadab3b835e4 100644
--- a/include/uapi/linux/if_bridge.h
+++ b/include/uapi/linux/if_bridge.h
@@ -400,6 +400,7 @@ enum {
 	MDBA_MDB_EATTR_TIMER,
 	MDBA_MDB_EATTR_SRC_LIST,
 	MDBA_MDB_EATTR_GROUP_MODE,
+	MDBA_MDB_EATTR_SOURCE,
 	__MDBA_MDB_EATTR_MAX
 };
 #define MDBA_MDB_EATTR_MAX (__MDBA_MDB_EATTR_MAX - 1)
@@ -485,6 +486,7 @@ enum {
  */
 enum {
 	MDBE_ATTR_UNSPEC,
+	MDBE_ATTR_SOURCE,
 	__MDBE_ATTR_MAX,
 };
 #define MDBE_ATTR_MAX (__MDBE_ATTR_MAX - 1)
* Unmerged path net/bridge/br_mdb.c
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 26b3cc8b3453..43ba931624e3 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -804,6 +804,20 @@ static inline bool br_multicast_querier_exists(struct net_bridge *br,
 	}
 }
 
+static inline bool br_multicast_is_star_g(const struct br_ip *ip)
+{
+	switch (ip->proto) {
+	case htons(ETH_P_IP):
+		return ipv4_is_zeronet(ip->src.ip4);
+#if IS_ENABLED(CONFIG_IPV6)
+	case htons(ETH_P_IPV6):
+		return ipv6_addr_any(&ip->src.ip6);
+#endif
+	default:
+		return false;
+	}
+}
+
 static inline int br_multicast_igmp_type(const struct sk_buff *skb)
 {
 	return BR_INPUT_SKB_CB(skb)->igmp;
