RDMA: Manual changes for sysfs_emit and neatening

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Joe Perches <joe@perches.com>
commit 45808361d4491217de11cdf0661d657081f8f422
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/45808361.failed

Make changes to use sysfs_emit in the RDMA code as cocci scripts can not
be written to handle _all_ the possible variants of various sprintf family
uses in sysfs show functions.

While there, make the code more legible and update its style to be more
like the typical kernel styles.

Miscellanea:

o Use intermediate pointers for dereferences
o Add and use string lookup functions
o return early when any intermediate call fails so normal return is
  at the bottom of the function
o mlx4/mcg.c:sysfs_show_group: use scnprintf to format intermediate strings

Link: https://lore.kernel.org/r/f5c9e4c9d8dafca1b7b70bd597ee7f8f219c31c8.1602122880.git.joe@perches.com
	Signed-off-by: Joe Perches <joe@perches.com>
	Acked-by: Jack Wang <jinpu.wang@cloud.ionos.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 45808361d4491217de11cdf0661d657081f8f422)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/sysfs.c
#	drivers/infiniband/hw/hfi1/sysfs.c
#	drivers/infiniband/hw/mlx4/main.c
#	drivers/infiniband/hw/mlx4/sysfs.c
#	drivers/infiniband/hw/mthca/mthca_provider.c
#	drivers/infiniband/hw/qib/qib_sysfs.c
#	drivers/infiniband/hw/usnic/usnic_ib_sysfs.c
#	drivers/infiniband/ulp/srp/ib_srp.c
diff --cc drivers/infiniband/core/sysfs.c
index 2f032e79f36f,4dd803f23aaa..000000000000
--- a/drivers/infiniband/core/sysfs.c
+++ b/drivers/infiniband/core/sysfs.c
@@@ -1233,16 -1250,8 +1254,21 @@@ static ssize_t node_type_show(struct de
  {
  	struct ib_device *dev = rdma_device_to_ibdev(device);
  
++<<<<<<< HEAD
 +	switch (dev->node_type) {
 +	case RDMA_NODE_IB_CA:	  return sprintf(buf, "%d: CA\n", dev->node_type);
 +	case RDMA_NODE_RNIC:	  return sprintf(buf, "%d: RNIC\n", dev->node_type);
 +	case RDMA_NODE_USNIC:	  return sprintf(buf, "%d: usNIC\n", dev->node_type);
 +	case RDMA_NODE_USNIC_UDP: return sprintf(buf, "%d: usNIC UDP\n", dev->node_type);
 +	case RDMA_NODE_UNSPECIFIED: return sprintf(buf, "%d: unspecified\n", dev->node_type);
 +	case RDMA_NODE_IB_SWITCH: return sprintf(buf, "%d: switch\n", dev->node_type);
 +	case RDMA_NODE_IB_ROUTER: return sprintf(buf, "%d: router\n", dev->node_type);
 +	default:		  return sprintf(buf, "%d: <unknown>\n", dev->node_type);
 +	}
++=======
+ 	return sysfs_emit(buf, "%d: %s\n", dev->node_type,
+ 			  node_type_string(dev->node_type));
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  static DEVICE_ATTR_RO(node_type);
  
@@@ -1250,12 -1259,13 +1276,21 @@@ static ssize_t sys_image_guid_show(stru
  				   struct device_attribute *dev_attr, char *buf)
  {
  	struct ib_device *dev = rdma_device_to_ibdev(device);
+ 	__be16 *guid = (__be16 *)&dev->attrs.sys_image_guid;
  
++<<<<<<< HEAD
 +	return sprintf(buf, "%04x:%04x:%04x:%04x\n",
 +		       be16_to_cpu(((__be16 *) &dev->attrs.sys_image_guid)[0]),
 +		       be16_to_cpu(((__be16 *) &dev->attrs.sys_image_guid)[1]),
 +		       be16_to_cpu(((__be16 *) &dev->attrs.sys_image_guid)[2]),
 +		       be16_to_cpu(((__be16 *) &dev->attrs.sys_image_guid)[3]));
++=======
+ 	return sysfs_emit(buf, "%04x:%04x:%04x:%04x\n",
+ 			  be16_to_cpu(guid[0]),
+ 			  be16_to_cpu(guid[1]),
+ 			  be16_to_cpu(guid[2]),
+ 			  be16_to_cpu(guid[3]));
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  static DEVICE_ATTR_RO(sys_image_guid);
  
@@@ -1263,12 -1273,13 +1298,21 @@@ static ssize_t node_guid_show(struct de
  			      struct device_attribute *attr, char *buf)
  {
  	struct ib_device *dev = rdma_device_to_ibdev(device);
+ 	__be16 *node_guid = (__be16 *)&dev->node_guid;
  
++<<<<<<< HEAD
 +	return sprintf(buf, "%04x:%04x:%04x:%04x\n",
 +		       be16_to_cpu(((__be16 *) &dev->node_guid)[0]),
 +		       be16_to_cpu(((__be16 *) &dev->node_guid)[1]),
 +		       be16_to_cpu(((__be16 *) &dev->node_guid)[2]),
 +		       be16_to_cpu(((__be16 *) &dev->node_guid)[3]));
++=======
+ 	return sysfs_emit(buf, "%04x:%04x:%04x:%04x\n",
+ 			  be16_to_cpu(node_guid[0]),
+ 			  be16_to_cpu(node_guid[1]),
+ 			  be16_to_cpu(node_guid[2]),
+ 			  be16_to_cpu(node_guid[3]));
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  static DEVICE_ATTR_RO(node_guid);
  
diff --cc drivers/infiniband/hw/hfi1/sysfs.c
index 074ec71772d2,9a695e1571c0..000000000000
--- a/drivers/infiniband/hw/hfi1/sysfs.c
+++ b/drivers/infiniband/hw/hfi1/sysfs.c
@@@ -510,13 -510,11 +510,18 @@@ static ssize_t board_id_show(struct dev
  	struct hfi1_ibdev *dev =
  		rdma_device_to_drv_device(device, struct hfi1_ibdev, rdi.ibdev);
  	struct hfi1_devdata *dd = dd_from_dev(dev);
- 	int ret;
  
  	if (!dd->boardname)
++<<<<<<< HEAD
 +		ret = -EINVAL;
 +	else
 +		ret = scnprintf(buf, PAGE_SIZE, "%s\n", dd->boardname);
 +	return ret;
++=======
+ 		return -EINVAL;
+ 
+ 	return sysfs_emit(buf, "%s\n", dd->boardname);
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  static DEVICE_ATTR_RO(board_id);
  
@@@ -570,7 -568,8 +575,12 @@@ static ssize_t serial_show(struct devic
  		rdma_device_to_drv_device(device, struct hfi1_ibdev, rdi.ibdev);
  	struct hfi1_devdata *dd = dd_from_dev(dev);
  
++<<<<<<< HEAD
 +	return scnprintf(buf, PAGE_SIZE, "%s", dd->serial);
++=======
+ 	/* dd->serial is already newline terminated in chip.c */
+ 	return sysfs_emit(buf, "%s", dd->serial);
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  static DEVICE_ATTR_RO(serial);
  
diff --cc drivers/infiniband/hw/mlx4/main.c
index c5f44a179962,f0864f40ea1a..000000000000
--- a/drivers/infiniband/hw/mlx4/main.c
+++ b/drivers/infiniband/hw/mlx4/main.c
@@@ -2021,7 -2024,8 +2021,12 @@@ static ssize_t hca_type_show(struct dev
  {
  	struct mlx4_ib_dev *dev =
  		rdma_device_to_drv_device(device, struct mlx4_ib_dev, ib_dev);
++<<<<<<< HEAD
 +	return sprintf(buf, "MT%d\n", dev->dev->persist->pdev->device);
++=======
+ 
+ 	return sysfs_emit(buf, "MT%d\n", dev->dev->persist->pdev->device);
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  static DEVICE_ATTR_RO(hca_type);
  
@@@ -2030,7 -2034,8 +2035,12 @@@ static ssize_t hw_rev_show(struct devic
  {
  	struct mlx4_ib_dev *dev =
  		rdma_device_to_drv_device(device, struct mlx4_ib_dev, ib_dev);
++<<<<<<< HEAD
 +	return sprintf(buf, "%x\n", dev->dev->rev_id);
++=======
+ 
+ 	return sysfs_emit(buf, "%x\n", dev->dev->rev_id);
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  static DEVICE_ATTR_RO(hw_rev);
  
diff --cc drivers/infiniband/hw/mlx4/sysfs.c
index 5138f2f6b3d1,0279b780c446..000000000000
--- a/drivers/infiniband/hw/mlx4/sysfs.c
+++ b/drivers/infiniband/hw/mlx4/sysfs.c
@@@ -123,16 -124,17 +124,30 @@@ static ssize_t show_port_gid(struct dev
  				  mlx4_ib_iov_dentry->entry_num, &gid, 1);
  	if (ret)
  		return ret;
++<<<<<<< HEAD
 +	ret = sprintf(buf, "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\n",
 +		      be16_to_cpu(((__be16 *) gid.raw)[0]),
 +		      be16_to_cpu(((__be16 *) gid.raw)[1]),
 +		      be16_to_cpu(((__be16 *) gid.raw)[2]),
 +		      be16_to_cpu(((__be16 *) gid.raw)[3]),
 +		      be16_to_cpu(((__be16 *) gid.raw)[4]),
 +		      be16_to_cpu(((__be16 *) gid.raw)[5]),
 +		      be16_to_cpu(((__be16 *) gid.raw)[6]),
 +		      be16_to_cpu(((__be16 *) gid.raw)[7]));
 +	return ret;
++=======
+ 
+ 	raw = (__be16 *)gid.raw;
+ 	return sysfs_emit(buf, "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\n",
+ 			  be16_to_cpu(raw[0]),
+ 			  be16_to_cpu(raw[1]),
+ 			  be16_to_cpu(raw[2]),
+ 			  be16_to_cpu(raw[3]),
+ 			  be16_to_cpu(raw[4]),
+ 			  be16_to_cpu(raw[5]),
+ 			  be16_to_cpu(raw[6]),
+ 			  be16_to_cpu(raw[7]));
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  
  static ssize_t show_phys_port_pkey(struct device *dev,
@@@ -542,14 -544,10 +557,19 @@@ static ssize_t sysfs_show_smi_enabled(s
  {
  	struct mlx4_port *p =
  		container_of(attr, struct mlx4_port, smi_enabled);
- 	ssize_t len = 0;
  
++<<<<<<< HEAD
 +	if (mlx4_vf_smi_enabled(p->dev->dev, p->slave, p->port_num))
 +		len = sprintf(buf, "%d\n", 1);
 +	else
 +		len = sprintf(buf, "%d\n", 0);
 +
 +	return len;
++=======
+ 	return sysfs_emit(buf, "%d\n",
+ 			  !!mlx4_vf_smi_enabled(p->dev->dev, p->slave,
+ 						p->port_num));
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  
  static ssize_t sysfs_show_enable_smi_admin(struct device *dev,
@@@ -558,14 -556,10 +578,19 @@@
  {
  	struct mlx4_port *p =
  		container_of(attr, struct mlx4_port, enable_smi_admin);
- 	ssize_t len = 0;
  
++<<<<<<< HEAD
 +	if (mlx4_vf_get_enable_smi_admin(p->dev->dev, p->slave, p->port_num))
 +		len = sprintf(buf, "%d\n", 1);
 +	else
 +		len = sprintf(buf, "%d\n", 0);
 +
 +	return len;
++=======
+ 	return sysfs_emit(buf, "%d\n",
+ 			  !!mlx4_vf_get_enable_smi_admin(p->dev->dev, p->slave,
+ 							 p->port_num));
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  
  static ssize_t sysfs_store_enable_smi_admin(struct device *dev,
diff --cc drivers/infiniband/hw/mthca/mthca_provider.c
index 61eedaa0a6a3,1a3dd07f993b..000000000000
--- a/drivers/infiniband/hw/mthca/mthca_provider.c
+++ b/drivers/infiniband/hw/mthca/mthca_provider.c
@@@ -964,19 -988,7 +981,23 @@@ static ssize_t hca_type_show(struct dev
  	struct mthca_dev *dev =
  		rdma_device_to_drv_device(device, struct mthca_dev, ib_dev);
  
++<<<<<<< HEAD
 +	switch (dev->pdev->device) {
 +	case PCI_DEVICE_ID_MELLANOX_TAVOR:
 +		return sprintf(buf, "MT23108\n");
 +	case PCI_DEVICE_ID_MELLANOX_ARBEL_COMPAT:
 +		return sprintf(buf, "MT25208 (MT23108 compat mode)\n");
 +	case PCI_DEVICE_ID_MELLANOX_ARBEL:
 +		return sprintf(buf, "MT25208\n");
 +	case PCI_DEVICE_ID_MELLANOX_SINAI:
 +	case PCI_DEVICE_ID_MELLANOX_SINAI_OLD:
 +		return sprintf(buf, "MT25204\n");
 +	default:
 +		return sprintf(buf, "unknown\n");
 +	}
++=======
+ 	return sysfs_emit(buf, "%s\n", hca_type_string(dev->pdev->device));
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  static DEVICE_ATTR_RO(hca_type);
  
diff --cc drivers/infiniband/hw/qib/qib_sysfs.c
index 3926be78036e,3761f21cef97..000000000000
--- a/drivers/infiniband/hw/qib/qib_sysfs.c
+++ b/drivers/infiniband/hw/qib/qib_sysfs.c
@@@ -569,13 -575,10 +569,17 @@@ static ssize_t hca_type_show(struct dev
  	struct qib_ibdev *dev =
  		rdma_device_to_drv_device(device, struct qib_ibdev, rdi.ibdev);
  	struct qib_devdata *dd = dd_from_dev(dev);
- 	int ret;
  
  	if (!dd->boardname)
++<<<<<<< HEAD
 +		ret = -EINVAL;
 +	else
 +		ret = scnprintf(buf, PAGE_SIZE, "%s\n", dd->boardname);
 +	return ret;
++=======
+ 		return -EINVAL;
+ 	return sysfs_emit(buf, "%s\n", dd->boardname);
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  static DEVICE_ATTR_RO(hca_type);
  static DEVICE_ATTR(board_id, 0444, hca_type_show, NULL);
@@@ -683,27 -686,26 +686,37 @@@ static ssize_t tempsense_show(struct de
  	struct qib_ibdev *dev =
  		rdma_device_to_drv_device(device, struct qib_ibdev, rdi.ibdev);
  	struct qib_devdata *dd = dd_from_dev(dev);
- 	int ret;
- 	int idx;
+ 	int i;
  	u8 regvals[8];
  
- 	ret = -ENXIO;
- 	for (idx = 0; idx < 8; ++idx) {
- 		if (idx == 6)
+ 	for (i = 0; i < 8; i++) {
+ 		int ret;
+ 
+ 		if (i == 6)
  			continue;
- 		ret = dd->f_tempsense_rd(dd, idx);
+ 		ret = dd->f_tempsense_rd(dd, i);
  		if (ret < 0)
- 			break;
- 		regvals[idx] = ret;
+ 			return ret;	/* return error on bad read */
+ 		regvals[i] = ret;
  	}
++<<<<<<< HEAD
 +	if (idx == 8)
 +		ret = scnprintf(buf, PAGE_SIZE, "%d %d %02X %02X %d %d\n",
 +				*(signed char *)(regvals),
 +				*(signed char *)(regvals + 1),
 +				regvals[2], regvals[3],
 +				*(signed char *)(regvals + 5),
 +				*(signed char *)(regvals + 7));
 +	return ret;
++=======
+ 	return sysfs_emit(buf, "%d %d %02X %02X %d %d\n",
+ 			  (signed char)regvals[0],
+ 			  (signed char)regvals[1],
+ 			  regvals[2],
+ 			  regvals[3],
+ 			  (signed char)regvals[5],
+ 			  (signed char)regvals[7]);
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  static DEVICE_ATTR_RO(tempsense);
  
diff --cc drivers/infiniband/hw/usnic/usnic_ib_sysfs.c
index c85d48ae7442,250948c382f9..000000000000
--- a/drivers/infiniband/hw/usnic/usnic_ib_sysfs.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_sysfs.c
@@@ -57,7 -57,7 +57,11 @@@ static ssize_t board_id_show(struct dev
  	subsystem_device_id = us_ibdev->pdev->subsystem_device;
  	mutex_unlock(&us_ibdev->usdev_lock);
  
++<<<<<<< HEAD
 +	return scnprintf(buf, PAGE_SIZE, "%hu\n", subsystem_device_id);
++=======
+ 	return sysfs_emit(buf, "%u\n", subsystem_device_id);
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  static DEVICE_ATTR_RO(board_id);
  
diff --cc drivers/infiniband/ulp/srp/ib_srp.c
index b77539da3a55,ee22ea44a40a..000000000000
--- a/drivers/infiniband/ulp/srp/ib_srp.c
+++ b/drivers/infiniband/ulp/srp/ib_srp.c
@@@ -2939,7 -2925,8 +2939,12 @@@ static ssize_t show_pkey(struct device 
  
  	if (target->using_rdma_cm)
  		return -ENOENT;
++<<<<<<< HEAD
 +	return sprintf(buf, "0x%04x\n", be16_to_cpu(target->ib_cm.pkey));
++=======
+ 
+ 	return sysfs_emit(buf, "0x%04x\n", be16_to_cpu(target->ib_cm.pkey));
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  
  static ssize_t show_sgid(struct device *dev, struct device_attribute *attr,
@@@ -2958,7 -2945,8 +2963,12 @@@ static ssize_t show_dgid(struct device 
  
  	if (target->using_rdma_cm)
  		return -ENOENT;
++<<<<<<< HEAD
 +	return sprintf(buf, "%pI6\n", ch->ib_cm.path.dgid.raw);
++=======
+ 
+ 	return sysfs_emit(buf, "%pI6\n", ch->ib_cm.path.dgid.raw);
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  
  static ssize_t show_orig_dgid(struct device *dev,
@@@ -2968,7 -2956,8 +2978,12 @@@
  
  	if (target->using_rdma_cm)
  		return -ENOENT;
++<<<<<<< HEAD
 +	return sprintf(buf, "%pI6\n", target->ib_cm.orig_dgid.raw);
++=======
+ 
+ 	return sysfs_emit(buf, "%pI6\n", target->ib_cm.orig_dgid.raw);
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  
  static ssize_t show_req_lim(struct device *dev,
@@@ -2982,7 -2971,8 +2997,12 @@@
  		ch = &target->ch[i];
  		req_lim = min(req_lim, ch->req_lim);
  	}
++<<<<<<< HEAD
 +	return sprintf(buf, "%d\n", req_lim);
++=======
+ 
+ 	return sysfs_emit(buf, "%d\n", req_lim);
++>>>>>>> 45808361d449 (RDMA: Manual changes for sysfs_emit and neatening)
  }
  
  static ssize_t show_zero_req_lim(struct device *dev,
* Unmerged path drivers/infiniband/core/sysfs.c
* Unmerged path drivers/infiniband/hw/hfi1/sysfs.c
* Unmerged path drivers/infiniband/hw/mlx4/main.c
diff --git a/drivers/infiniband/hw/mlx4/mcg.c b/drivers/infiniband/hw/mlx4/mcg.c
index 5e4ec9786081..33f525b744f2 100644
--- a/drivers/infiniband/hw/mlx4/mcg.c
+++ b/drivers/infiniband/hw/mlx4/mcg.c
@@ -988,53 +988,63 @@ int mlx4_ib_mcg_multiplex_handler(struct ib_device *ibdev, int port,
 }
 
 static ssize_t sysfs_show_group(struct device *dev,
-		struct device_attribute *attr, char *buf)
+				struct device_attribute *attr, char *buf)
 {
 	struct mcast_group *group =
 		container_of(attr, struct mcast_group, dentry);
 	struct mcast_req *req = NULL;
-	char pending_str[40];
 	char state_str[40];
-	ssize_t len = 0;
-	int f;
+	char pending_str[40];
+	int len;
+	int i;
+	u32 hoplimit;
 
 	if (group->state == MCAST_IDLE)
-		sprintf(state_str, "%s", get_state_string(group->state));
+		scnprintf(state_str, sizeof(state_str), "%s",
+			  get_state_string(group->state));
 	else
-		sprintf(state_str, "%s(TID=0x%llx)",
-				get_state_string(group->state),
-				be64_to_cpu(group->last_req_tid));
+		scnprintf(state_str, sizeof(state_str), "%s(TID=0x%llx)",
+			  get_state_string(group->state),
+			  be64_to_cpu(group->last_req_tid));
+
 	if (list_empty(&group->pending_list)) {
-		sprintf(pending_str, "No");
+		scnprintf(pending_str, sizeof(pending_str), "No");
 	} else {
-		req = list_first_entry(&group->pending_list, struct mcast_req, group_list);
-		sprintf(pending_str, "Yes(TID=0x%llx)",
-				be64_to_cpu(req->sa_mad.mad_hdr.tid));
+		req = list_first_entry(&group->pending_list, struct mcast_req,
+				       group_list);
+		scnprintf(pending_str, sizeof(pending_str), "Yes(TID=0x%llx)",
+			  be64_to_cpu(req->sa_mad.mad_hdr.tid));
 	}
-	len += sprintf(buf + len, "%1d [%02d,%02d,%02d] %4d %4s %5s     ",
-			group->rec.scope_join_state & 0xf,
-			group->members[2], group->members[1], group->members[0],
-			atomic_read(&group->refcount),
-			pending_str,
-			state_str);
-	for (f = 0; f < MAX_VFS; ++f)
-		if (group->func[f].state == MCAST_MEMBER)
-			len += sprintf(buf + len, "%d[%1x] ",
-					f, group->func[f].join_state);
-
-	len += sprintf(buf + len, "\t\t(%4hx %4x %2x %2x %2x %2x %2x "
-		"%4x %4x %2x %2x)\n",
-		be16_to_cpu(group->rec.pkey),
-		be32_to_cpu(group->rec.qkey),
-		(group->rec.mtusel_mtu & 0xc0) >> 6,
-		group->rec.mtusel_mtu & 0x3f,
-		group->rec.tclass,
-		(group->rec.ratesel_rate & 0xc0) >> 6,
-		group->rec.ratesel_rate & 0x3f,
-		(be32_to_cpu(group->rec.sl_flowlabel_hoplimit) & 0xf0000000) >> 28,
-		(be32_to_cpu(group->rec.sl_flowlabel_hoplimit) & 0x0fffff00) >> 8,
-		be32_to_cpu(group->rec.sl_flowlabel_hoplimit) & 0x000000ff,
-		group->rec.proxy_join);
+
+	len = sysfs_emit(buf, "%1d [%02d,%02d,%02d] %4d %4s %5s     ",
+			 group->rec.scope_join_state & 0xf,
+			 group->members[2],
+			 group->members[1],
+			 group->members[0],
+			 atomic_read(&group->refcount),
+			 pending_str,
+			 state_str);
+
+	for (i = 0; i < MAX_VFS; i++) {
+		if (group->func[i].state == MCAST_MEMBER)
+			len += sysfs_emit_at(buf, len, "%d[%1x] ", i,
+					     group->func[i].join_state);
+	}
+
+	hoplimit = be32_to_cpu(group->rec.sl_flowlabel_hoplimit);
+	len += sysfs_emit_at(buf, len,
+			     "\t\t(%4hx %4x %2x %2x %2x %2x %2x %4x %4x %2x %2x)\n",
+			     be16_to_cpu(group->rec.pkey),
+			     be32_to_cpu(group->rec.qkey),
+			     (group->rec.mtusel_mtu & 0xc0) >> 6,
+			     (group->rec.mtusel_mtu & 0x3f),
+			     group->rec.tclass,
+			     (group->rec.ratesel_rate & 0xc0) >> 6,
+			     (group->rec.ratesel_rate & 0x3f),
+			     (hoplimit & 0xf0000000) >> 28,
+			     (hoplimit & 0x0fffff00) >> 8,
+			     (hoplimit & 0x000000ff),
+			     group->rec.proxy_join);
 
 	return len;
 }
* Unmerged path drivers/infiniband/hw/mlx4/sysfs.c
* Unmerged path drivers/infiniband/hw/mthca/mthca_provider.c
* Unmerged path drivers/infiniband/hw/qib/qib_sysfs.c
* Unmerged path drivers/infiniband/hw/usnic/usnic_ib_sysfs.c
* Unmerged path drivers/infiniband/ulp/srp/ib_srp.c
