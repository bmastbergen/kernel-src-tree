nvme: avoid race in shutdown namespace removal

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Daniel Wagner <dwagner@suse.de>
commit 9edceaf43050f5ba1dd7d0011bcf68a736a17743
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/9edceaf4.failed

When we remove the siblings entry, we update ns->head->list, hence we
can't separate the removal and test for being empty. They have to be
in the same critical section to avoid a race.

To avoid breaking the refcounting imbalance again, add a list empty
check to nvme_find_ns_head.

Fixes: 5396fdac56d8 ("nvme: fix refcounting imbalance when all paths are down")
	Signed-off-by: Daniel Wagner <dwagner@suse.de>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Tested-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 9edceaf43050f5ba1dd7d0011bcf68a736a17743)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index e310c0f15679,97f8211cf92c..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -4197,26 -3845,32 +4199,38 @@@ static void nvme_ns_remove(struct nvme_
  
  	mutex_lock(&ns->ctrl->subsys->lock);
  	list_del_rcu(&ns->siblings);
++<<<<<<< HEAD
 +	if (list_empty(&ns->head->list))
 +		list_del_init(&ns->head->entry);
++=======
+ 	if (list_empty(&ns->head->list)) {
+ 		list_del_init(&ns->head->entry);
+ 		last_path = true;
+ 	}
++>>>>>>> 9edceaf43050 (nvme: avoid race in shutdown namespace removal)
  	mutex_unlock(&ns->ctrl->subsys->lock);
  
 -	/* guarantee not available in head->list */
 -	synchronize_rcu();
 +	synchronize_rcu(); /* guarantee not available in head->list */
 +	nvme_mpath_clear_current_path(ns);
 +	synchronize_srcu(&ns->head->srcu); /* wait for concurrent submissions */
  
 -	/* wait for concurrent submissions */
 -	if (nvme_mpath_clear_current_path(ns))
 -		synchronize_srcu(&ns->head->srcu);
 -
 -	if (!nvme_ns_head_multipath(ns->head))
 -		nvme_cdev_del(&ns->cdev, &ns->cdev_device);
 -	del_gendisk(ns->disk);
 -	blk_cleanup_queue(ns->queue);
 -	if (blk_get_integrity(ns->disk))
 -		blk_integrity_unregister(ns->disk);
 +	if (ns->disk->flags & GENHD_FL_UP) {
 +		del_gendisk(ns->disk);
 +		blk_cleanup_queue(ns->queue);
 +		if (blk_get_integrity(ns->disk))
 +			blk_integrity_unregister(ns->disk);
 +	}
  
  	down_write(&ns->ctrl->namespaces_rwsem);
  	list_del_init(&ns->list);
  	up_write(&ns->ctrl->namespaces_rwsem);
  
++<<<<<<< HEAD
 +	nvme_mpath_check_last_path(ns);
++=======
+ 	if (last_path)
+ 		nvme_mpath_shutdown_disk(ns->head);
++>>>>>>> 9edceaf43050 (nvme: avoid race in shutdown namespace removal)
  	nvme_put_ns(ns);
  }
  
* Unmerged path drivers/nvme/host/core.c
