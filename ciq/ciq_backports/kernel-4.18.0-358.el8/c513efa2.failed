switchdev: mrp: Extend ring_role_mrp and in_role_mrp

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Horatiu Vultur <horatiu.vultur@microchip.com>
commit c513efa20c5254ef74c4157a03d515abdc46c503
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/c513efa2.failed

Add the member sw_backup to the structures switchdev_obj_ring_role_mrp
and switchdev_obj_in_role_mrp. In this way the SW can call the driver in
2 ways, once when sw_backup is set to false, meaning that the driver
should implement this completely in HW. And if that is not supported the
SW will call again but with sw_backup set to true, meaning that the
HW should help or allow the SW to run the protocol.

For example when role is MRM, if the HW can't detect when it stops
receiving MRP Test frames but it can trap these frames to CPU, then it
needs to return -EOPNOTSUPP when sw_backup is false and return 0 when
sw_backup is true.

	Signed-off-by: Horatiu Vultur <horatiu.vultur@microchip.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c513efa20c5254ef74c4157a03d515abdc46c503)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/switchdev.h
diff --cc include/net/switchdev.h
index 4b6737027b82,b7fc7d0f54e2..000000000000
--- a/include/net/switchdev.h
+++ b/include/net/switchdev.h
@@@ -101,38 -95,90 +101,123 @@@ struct switchdev_obj_port_mdb 
  #define SWITCHDEV_OBJ_PORT_MDB(OBJ) \
  	container_of((OBJ), struct switchdev_obj_port_mdb, obj)
  
++<<<<<<< HEAD
++=======
+ 
+ /* SWITCHDEV_OBJ_ID_MRP */
+ struct switchdev_obj_mrp {
+ 	struct switchdev_obj obj;
+ 	struct net_device *p_port;
+ 	struct net_device *s_port;
+ 	u32 ring_id;
+ 	u16 prio;
+ };
+ 
+ #define SWITCHDEV_OBJ_MRP(OBJ) \
+ 	container_of((OBJ), struct switchdev_obj_mrp, obj)
+ 
+ /* SWITCHDEV_OBJ_ID_RING_TEST_MRP */
+ struct switchdev_obj_ring_test_mrp {
+ 	struct switchdev_obj obj;
+ 	/* The value is in us and a value of 0 represents to stop */
+ 	u32 interval;
+ 	u8 max_miss;
+ 	u32 ring_id;
+ 	u32 period;
+ 	bool monitor;
+ };
+ 
+ #define SWITCHDEV_OBJ_RING_TEST_MRP(OBJ) \
+ 	container_of((OBJ), struct switchdev_obj_ring_test_mrp, obj)
+ 
+ /* SWICHDEV_OBJ_ID_RING_ROLE_MRP */
+ struct switchdev_obj_ring_role_mrp {
+ 	struct switchdev_obj obj;
+ 	u8 ring_role;
+ 	u32 ring_id;
+ 	u8 sw_backup;
+ };
+ 
+ #define SWITCHDEV_OBJ_RING_ROLE_MRP(OBJ) \
+ 	container_of((OBJ), struct switchdev_obj_ring_role_mrp, obj)
+ 
+ struct switchdev_obj_ring_state_mrp {
+ 	struct switchdev_obj obj;
+ 	u8 ring_state;
+ 	u32 ring_id;
+ };
+ 
+ #define SWITCHDEV_OBJ_RING_STATE_MRP(OBJ) \
+ 	container_of((OBJ), struct switchdev_obj_ring_state_mrp, obj)
+ 
+ /* SWITCHDEV_OBJ_ID_IN_TEST_MRP */
+ struct switchdev_obj_in_test_mrp {
+ 	struct switchdev_obj obj;
+ 	/* The value is in us and a value of 0 represents to stop */
+ 	u32 interval;
+ 	u32 in_id;
+ 	u32 period;
+ 	u8 max_miss;
+ };
+ 
+ #define SWITCHDEV_OBJ_IN_TEST_MRP(OBJ) \
+ 	container_of((OBJ), struct switchdev_obj_in_test_mrp, obj)
+ 
+ /* SWICHDEV_OBJ_ID_IN_ROLE_MRP */
+ struct switchdev_obj_in_role_mrp {
+ 	struct switchdev_obj obj;
+ 	struct net_device *i_port;
+ 	u32 ring_id;
+ 	u16 in_id;
+ 	u8 in_role;
+ 	u8 sw_backup;
+ };
+ 
+ #define SWITCHDEV_OBJ_IN_ROLE_MRP(OBJ) \
+ 	container_of((OBJ), struct switchdev_obj_in_role_mrp, obj)
+ 
+ struct switchdev_obj_in_state_mrp {
+ 	struct switchdev_obj obj;
+ 	u32 in_id;
+ 	u8 in_state;
+ };
+ 
+ #define SWITCHDEV_OBJ_IN_STATE_MRP(OBJ) \
+ 	container_of((OBJ), struct switchdev_obj_in_state_mrp, obj)
+ 
++>>>>>>> c513efa20c52 (switchdev: mrp: Extend ring_role_mrp and in_role_mrp)
  typedef int switchdev_obj_dump_cb_t(struct switchdev_obj *obj);
  
 +struct switchdev_ops_extended_rh {
 +};
 +
 +/**
 + * struct switchdev_ops - switchdev operations
 + *
 + * @switchdev_port_attr_set: Set a port attribute (see switchdev_attr).
 + */
 +struct RH_KABI_RENAME(switchdev_ops, rh_deprecated_switchdev_ops) {
 +	RH_KABI_DEPRECATE_FN(int, switchdev_port_attr_get, struct net_device *dev,
 +					   struct switchdev_attr *attr)
 +	RH_KABI_DEPRECATE_FN(int, switchdev_port_attr_set, struct net_device *dev,
 +					   const struct switchdev_attr *attr,
 +					   struct switchdev_trans *trans)
 +	RH_KABI_DEPRECATE_FN(int, switchdev_port_obj_add, struct net_device *dev,
 +					  const struct switchdev_obj *obj,
 +					  struct switchdev_trans *trans)
 +	RH_KABI_DEPRECATE_FN(int, switchdev_port_obj_del, struct net_device *dev,
 +					  const struct switchdev_obj *obj)
 +
 +	RH_KABI_RESERVE(1)
 +	RH_KABI_RESERVE(2)
 +	RH_KABI_RESERVE(3)
 +	RH_KABI_RESERVE(4)
 +	RH_KABI_RESERVE(5)
 +	RH_KABI_RESERVE(6)
 +	RH_KABI_RESERVE(7)
 +	RH_KABI_AUX_EMBED(switchdev_ops_extended)
 +};
 +
  enum switchdev_notifier_type {
  	SWITCHDEV_FDB_ADD_TO_BRIDGE = 1,
  	SWITCHDEV_FDB_DEL_TO_BRIDGE,
* Unmerged path include/net/switchdev.h
