mm/oom_kill.c: clean up oom_reap_task_mm()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Michal Hocko <mhocko@kernel.org>
commit 431f42fdfdb36f06f43c711fc59be9b814d8fb22
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/431f42fd.failed

Andrew has noticed some inconsistencies in oom_reap_task_mm.  Notably

 - Undocumented return value.

 - comment "failed to reap part..." is misleading - sounds like it's
   referring to something which happened in the past, is in fact
   referring to something which might happen in the future.

 - fails to call trace_finish_task_reaping() in one case

 - code duplication.

 - Increases mmap_sem hold time a little by moving
   trace_finish_task_reaping() inside the locked region.  So sue me ;)

 - Sharing the finish: path means that the trace event won't
   distinguish between the two sources of finishing.

Add a short explanation for the return value and fix the rest by
reorganizing the function a bit to have unified function exit paths.

Link: http://lkml.kernel.org/r/20180724141747.GP28386@dhcp22.suse.cz
	Suggested-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Michal Hocko <mhocko@suse.com>
	Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
	Cc: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
	Cc: David Rientjes <rientjes@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 431f42fdfdb36f06f43c711fc59be9b814d8fb22)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/oom_kill.c
diff --cc mm/oom_kill.c
index db8561edec1a,20600779f5db..000000000000
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@@ -528,24 -516,35 +528,36 @@@ void __oom_reap_task_mm(struct mm_struc
  		 * count elevated without a good reason.
  		 */
  		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
 -			const unsigned long start = vma->vm_start;
 -			const unsigned long end = vma->vm_end;
 +			struct mmu_notifier_range range;
  			struct mmu_gather tlb;
  
 -			tlb_gather_mmu(&tlb, mm, start, end);
 -			if (mmu_notifier_invalidate_range_start_nonblock(mm, start, end)) {
 -				ret = false;
 -				continue;
 -			}
 -			unmap_page_range(&tlb, vma, start, end, NULL);
 -			mmu_notifier_invalidate_range_end(mm, start, end);
 -			tlb_finish_mmu(&tlb, start, end);
 +			mmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0,
 +						vma, mm, vma->vm_start,
 +						vma->vm_end);
 +			tlb_gather_mmu(&tlb, mm, range.start, range.end);
 +			mmu_notifier_invalidate_range_start(&range);
 +			unmap_page_range(&tlb, vma, range.start, range.end, NULL);
 +			mmu_notifier_invalidate_range_end(&range);
 +			tlb_finish_mmu(&tlb, range.start, range.end);
  		}
  	}
 -
 -	return ret;
  }
  
+ /*
+  * Reaps the address space of the give task.
+  *
+  * Returns true on success and false if none or part of the address space
+  * has been reclaimed and the caller should retry later.
+  */
  static bool oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
  {
++<<<<<<< HEAD
 +	if (!mmap_read_trylock(mm)) {
++=======
+ 	bool ret = true;
+ 
+ 	if (!down_read_trylock(&mm->mmap_sem)) {
++>>>>>>> 431f42fdfdb3 (mm/oom_kill.c: clean up oom_reap_task_mm())
  		trace_skip_task_reaping(tsk->pid);
  		return false;
  	}
@@@ -565,28 -552,32 +577,44 @@@
  	/*
  	 * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't
  	 * work on the mm anymore. The check for MMF_OOM_SKIP must run
 -	 * under mmap_sem for reading because it serializes against the
 -	 * down_write();up_write() cycle in exit_mmap().
 +	 * under mmap_lock for reading because it serializes against the
 +	 * mmap_write_lock();mmap_write_unlock() cycle in exit_mmap().
  	 */
  	if (test_bit(MMF_OOM_SKIP, &mm->flags)) {
++<<<<<<< HEAD
 +		mmap_read_unlock(mm);
++=======
++>>>>>>> 431f42fdfdb3 (mm/oom_kill.c: clean up oom_reap_task_mm())
  		trace_skip_task_reaping(tsk->pid);
- 		return true;
+ 		goto out_unlock;
  	}
  
  	trace_start_task_reaping(tsk->pid);
  
++<<<<<<< HEAD
 +	__oom_reap_task_mm(mm);
++=======
+ 	/* failed to reap part of the address space. Try again later */
+ 	ret = __oom_reap_task_mm(mm);
+ 	if (!ret)
+ 		goto out_finish;
++>>>>>>> 431f42fdfdb3 (mm/oom_kill.c: clean up oom_reap_task_mm())
  
  	pr_info("oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n",
  			task_pid_nr(tsk), tsk->comm,
  			K(get_mm_counter(mm, MM_ANONPAGES)),
  			K(get_mm_counter(mm, MM_FILEPAGES)),
  			K(get_mm_counter(mm, MM_SHMEMPAGES)));
++<<<<<<< HEAD
 +	mmap_read_unlock(mm);
- 
++=======
+ out_finish:
  	trace_finish_task_reaping(tsk->pid);
- 	return true;
+ out_unlock:
+ 	up_read(&mm->mmap_sem);
++>>>>>>> 431f42fdfdb3 (mm/oom_kill.c: clean up oom_reap_task_mm())
+ 
+ 	return ret;
  }
  
  #define MAX_OOM_REAP_RETRIES 10
* Unmerged path mm/oom_kill.c
