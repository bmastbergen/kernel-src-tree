mm/mmu_notifier: pass down vma and reasons why mmu notifier is happening

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Jérôme Glisse <jglisse@redhat.com>
commit bf198b2b34bfd4bc9bd6abb33bf650b74329a2ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/bf198b2b.failed

CPU page table update can happens for many reasons, not only as a result
of a syscall (munmap(), mprotect(), mremap(), madvise(), ...) but also as
a result of kernel activities (memory compression, reclaim, migration,
...).

Users of mmu notifier API track changes to the CPU page table and take
specific action for them.  While current API only provide range of virtual
address affected by the change, not why the changes is happening

This patch is just passing down the new informations by adding it to the
mmu_notifier_range structure.

Link: http://lkml.kernel.org/r/20190326164747.24405-8-jglisse@redhat.com
	Signed-off-by: Jérôme Glisse <jglisse@redhat.com>
	Reviewed-by: Ralph Campbell <rcampbell@nvidia.com>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Cc: Christian König <christian.koenig@amd.com>
	Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
	Cc: Jani Nikula <jani.nikula@linux.intel.com>
	Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
	Cc: Jan Kara <jack@suse.cz>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Peter Xu <peterx@redhat.com>
	Cc: Felix Kuehling <Felix.Kuehling@amd.com>
	Cc: Jason Gunthorpe <jgg@mellanox.com>
	Cc: Ross Zwisler <zwisler@kernel.org>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Radim Krcmar <rkrcmar@redhat.com>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Christian Koenig <christian.koenig@amd.com>
	Cc: John Hubbard <jhubbard@nvidia.com>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit bf198b2b34bfd4bc9bd6abb33bf650b74329a2ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mmu_notifier.h
diff --cc include/linux/mmu_notifier.h
index d924803cea7c,0379956fff23..000000000000
--- a/include/linux/mmu_notifier.h
+++ b/include/linux/mmu_notifier.h
@@@ -77,16 -57,16 +77,28 @@@ struct mmu_interval_notifier
  
  #define MMU_NOTIFIER_RANGE_BLOCKABLE (1 << 0)
  
++<<<<<<< HEAD
++=======
+ struct mmu_notifier_range {
+ 	struct vm_area_struct *vma;
+ 	struct mm_struct *mm;
+ 	unsigned long start;
+ 	unsigned long end;
+ 	unsigned flags;
+ 	enum mmu_notifier_event event;
+ };
+ 
++>>>>>>> bf198b2b34bf (mm/mmu_notifier: pass down vma and reasons why mmu notifier is happening)
  struct mmu_notifier_ops {
 +	/*
 +	 * Flags to specify behavior of callbacks for this MMU notifier.
 +	 * Used to determine which context an operation may be called.
 +	 *
 +	 * MMU_INVALIDATE_DOES_NOT_BLOCK: invalidate_range_* callbacks do not
 +	 *	block
 +	 */
 +	int flags;
 +
  	/*
  	 * Called either by mmu_notifier_unregister or when the mm is
  	 * being destroyed by exit_mmap, always before all pages are
@@@ -522,10 -365,12 +534,19 @@@ static inline void mmu_notifier_range_i
  					   unsigned long start,
  					   unsigned long end)
  {
++<<<<<<< HEAD
 +	memset(range, 0, sizeof(*range));
 +	range->mm = mm;
 +	range->start = start;
 +	range->end = end;
++=======
+ 	range->vma = vma;
+ 	range->event = event;
+ 	range->mm = mm;
+ 	range->start = start;
+ 	range->end = end;
+ 	range->flags = flags;
++>>>>>>> bf198b2b34bf (mm/mmu_notifier: pass down vma and reasons why mmu notifier is happening)
  }
  
  #define ptep_clear_flush_young_notify(__vma, __address, __ptep)		\
* Unmerged path include/linux/mmu_notifier.h
