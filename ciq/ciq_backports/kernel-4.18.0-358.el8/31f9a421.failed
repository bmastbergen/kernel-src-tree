pinctrl: Introduce MODE group in enum pin_config_param

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 31f9a421a1d01538776db37ec9c5419a3a49d650
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/31f9a421.failed

Better to have a MODE group of settings to keep them together
when ordered alphabetically. Hence, rename PIN_CONFIG_LOW_POWER_MODE
to PIN_CONFIG_MODE_LOW_POWER.

	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Link: https://lore.kernel.org/r/20210412140741.39946-2-andriy.shevchenko@linux.intel.com
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 31f9a421a1d01538776db37ec9c5419a3a49d650)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/soc/tegra/pmc.c
diff --cc drivers/soc/tegra/pmc.c
index 2d6f3fcf3211,46bcdbef1675..000000000000
--- a/drivers/soc/tegra/pmc.c
+++ b/drivers/soc/tegra/pmc.c
@@@ -1353,6 -1680,769 +1353,772 @@@ out
  	of_node_put(np);
  }
  
++<<<<<<< HEAD
++=======
+ static int tegra_io_pad_pinctrl_get_groups_count(struct pinctrl_dev *pctl_dev)
+ {
+ 	struct tegra_pmc *pmc = pinctrl_dev_get_drvdata(pctl_dev);
+ 
+ 	return pmc->soc->num_io_pads;
+ }
+ 
+ static const char *tegra_io_pad_pinctrl_get_group_name(struct pinctrl_dev *pctl,
+ 						       unsigned int group)
+ {
+ 	struct tegra_pmc *pmc = pinctrl_dev_get_drvdata(pctl);
+ 
+ 	return pmc->soc->io_pads[group].name;
+ }
+ 
+ static int tegra_io_pad_pinctrl_get_group_pins(struct pinctrl_dev *pctl_dev,
+ 					       unsigned int group,
+ 					       const unsigned int **pins,
+ 					       unsigned int *num_pins)
+ {
+ 	struct tegra_pmc *pmc = pinctrl_dev_get_drvdata(pctl_dev);
+ 
+ 	*pins = &pmc->soc->io_pads[group].id;
+ 	*num_pins = 1;
+ 
+ 	return 0;
+ }
+ 
+ static const struct pinctrl_ops tegra_io_pad_pinctrl_ops = {
+ 	.get_groups_count = tegra_io_pad_pinctrl_get_groups_count,
+ 	.get_group_name = tegra_io_pad_pinctrl_get_group_name,
+ 	.get_group_pins = tegra_io_pad_pinctrl_get_group_pins,
+ 	.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,
+ 	.dt_free_map = pinconf_generic_dt_free_map,
+ };
+ 
+ static int tegra_io_pad_pinconf_get(struct pinctrl_dev *pctl_dev,
+ 				    unsigned int pin, unsigned long *config)
+ {
+ 	enum pin_config_param param = pinconf_to_config_param(*config);
+ 	struct tegra_pmc *pmc = pinctrl_dev_get_drvdata(pctl_dev);
+ 	const struct tegra_io_pad_soc *pad;
+ 	int ret;
+ 	u32 arg;
+ 
+ 	pad = tegra_io_pad_find(pmc, pin);
+ 	if (!pad)
+ 		return -EINVAL;
+ 
+ 	switch (param) {
+ 	case PIN_CONFIG_POWER_SOURCE:
+ 		ret = tegra_io_pad_get_voltage(pmc, pad->id);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		arg = ret;
+ 		break;
+ 
+ 	case PIN_CONFIG_MODE_LOW_POWER:
+ 		ret = tegra_io_pad_is_powered(pmc, pad->id);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		arg = !ret;
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	*config = pinconf_to_config_packed(param, arg);
+ 
+ 	return 0;
+ }
+ 
+ static int tegra_io_pad_pinconf_set(struct pinctrl_dev *pctl_dev,
+ 				    unsigned int pin, unsigned long *configs,
+ 				    unsigned int num_configs)
+ {
+ 	struct tegra_pmc *pmc = pinctrl_dev_get_drvdata(pctl_dev);
+ 	const struct tegra_io_pad_soc *pad;
+ 	enum pin_config_param param;
+ 	unsigned int i;
+ 	int err;
+ 	u32 arg;
+ 
+ 	pad = tegra_io_pad_find(pmc, pin);
+ 	if (!pad)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < num_configs; ++i) {
+ 		param = pinconf_to_config_param(configs[i]);
+ 		arg = pinconf_to_config_argument(configs[i]);
+ 
+ 		switch (param) {
+ 		case PIN_CONFIG_MODE_LOW_POWER:
+ 			if (arg)
+ 				err = tegra_io_pad_power_disable(pad->id);
+ 			else
+ 				err = tegra_io_pad_power_enable(pad->id);
+ 			if (err)
+ 				return err;
+ 			break;
+ 		case PIN_CONFIG_POWER_SOURCE:
+ 			if (arg != TEGRA_IO_PAD_VOLTAGE_1V8 &&
+ 			    arg != TEGRA_IO_PAD_VOLTAGE_3V3)
+ 				return -EINVAL;
+ 			err = tegra_io_pad_set_voltage(pmc, pad->id, arg);
+ 			if (err)
+ 				return err;
+ 			break;
+ 		default:
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static const struct pinconf_ops tegra_io_pad_pinconf_ops = {
+ 	.pin_config_get = tegra_io_pad_pinconf_get,
+ 	.pin_config_set = tegra_io_pad_pinconf_set,
+ 	.is_generic = true,
+ };
+ 
+ static struct pinctrl_desc tegra_pmc_pctl_desc = {
+ 	.pctlops = &tegra_io_pad_pinctrl_ops,
+ 	.confops = &tegra_io_pad_pinconf_ops,
+ };
+ 
+ static int tegra_pmc_pinctrl_init(struct tegra_pmc *pmc)
+ {
+ 	int err;
+ 
+ 	if (!pmc->soc->num_pin_descs)
+ 		return 0;
+ 
+ 	tegra_pmc_pctl_desc.name = dev_name(pmc->dev);
+ 	tegra_pmc_pctl_desc.pins = pmc->soc->pin_descs;
+ 	tegra_pmc_pctl_desc.npins = pmc->soc->num_pin_descs;
+ 
+ 	pmc->pctl_dev = devm_pinctrl_register(pmc->dev, &tegra_pmc_pctl_desc,
+ 					      pmc);
+ 	if (IS_ERR(pmc->pctl_dev)) {
+ 		err = PTR_ERR(pmc->pctl_dev);
+ 		dev_err(pmc->dev, "failed to register pin controller: %d\n",
+ 			err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static ssize_t reset_reason_show(struct device *dev,
+ 				 struct device_attribute *attr, char *buf)
+ {
+ 	u32 value;
+ 
+ 	value = tegra_pmc_readl(pmc, pmc->soc->regs->rst_status);
+ 	value &= pmc->soc->regs->rst_source_mask;
+ 	value >>= pmc->soc->regs->rst_source_shift;
+ 
+ 	if (WARN_ON(value >= pmc->soc->num_reset_sources))
+ 		return sprintf(buf, "%s\n", "UNKNOWN");
+ 
+ 	return sprintf(buf, "%s\n", pmc->soc->reset_sources[value]);
+ }
+ 
+ static DEVICE_ATTR_RO(reset_reason);
+ 
+ static ssize_t reset_level_show(struct device *dev,
+ 				struct device_attribute *attr, char *buf)
+ {
+ 	u32 value;
+ 
+ 	value = tegra_pmc_readl(pmc, pmc->soc->regs->rst_status);
+ 	value &= pmc->soc->regs->rst_level_mask;
+ 	value >>= pmc->soc->regs->rst_level_shift;
+ 
+ 	if (WARN_ON(value >= pmc->soc->num_reset_levels))
+ 		return sprintf(buf, "%s\n", "UNKNOWN");
+ 
+ 	return sprintf(buf, "%s\n", pmc->soc->reset_levels[value]);
+ }
+ 
+ static DEVICE_ATTR_RO(reset_level);
+ 
+ static void tegra_pmc_reset_sysfs_init(struct tegra_pmc *pmc)
+ {
+ 	struct device *dev = pmc->dev;
+ 	int err = 0;
+ 
+ 	if (pmc->soc->reset_sources) {
+ 		err = device_create_file(dev, &dev_attr_reset_reason);
+ 		if (err < 0)
+ 			dev_warn(dev,
+ 				 "failed to create attr \"reset_reason\": %d\n",
+ 				 err);
+ 	}
+ 
+ 	if (pmc->soc->reset_levels) {
+ 		err = device_create_file(dev, &dev_attr_reset_level);
+ 		if (err < 0)
+ 			dev_warn(dev,
+ 				 "failed to create attr \"reset_level\": %d\n",
+ 				 err);
+ 	}
+ }
+ 
+ static int tegra_pmc_irq_translate(struct irq_domain *domain,
+ 				   struct irq_fwspec *fwspec,
+ 				   unsigned long *hwirq,
+ 				   unsigned int *type)
+ {
+ 	if (WARN_ON(fwspec->param_count < 2))
+ 		return -EINVAL;
+ 
+ 	*hwirq = fwspec->param[0];
+ 	*type = fwspec->param[1];
+ 
+ 	return 0;
+ }
+ 
+ static int tegra_pmc_irq_alloc(struct irq_domain *domain, unsigned int virq,
+ 			       unsigned int num_irqs, void *data)
+ {
+ 	struct tegra_pmc *pmc = domain->host_data;
+ 	const struct tegra_pmc_soc *soc = pmc->soc;
+ 	struct irq_fwspec *fwspec = data;
+ 	unsigned int i;
+ 	int err = 0;
+ 
+ 	if (WARN_ON(num_irqs > 1))
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < soc->num_wake_events; i++) {
+ 		const struct tegra_wake_event *event = &soc->wake_events[i];
+ 
+ 		if (fwspec->param_count == 2) {
+ 			struct irq_fwspec spec;
+ 
+ 			if (event->id != fwspec->param[0])
+ 				continue;
+ 
+ 			err = irq_domain_set_hwirq_and_chip(domain, virq,
+ 							    event->id,
+ 							    &pmc->irq, pmc);
+ 			if (err < 0)
+ 				break;
+ 
+ 			spec.fwnode = &pmc->dev->of_node->fwnode;
+ 			spec.param_count = 3;
+ 			spec.param[0] = GIC_SPI;
+ 			spec.param[1] = event->irq;
+ 			spec.param[2] = fwspec->param[1];
+ 
+ 			err = irq_domain_alloc_irqs_parent(domain, virq,
+ 							   num_irqs, &spec);
+ 
+ 			break;
+ 		}
+ 
+ 		if (fwspec->param_count == 3) {
+ 			if (event->gpio.instance != fwspec->param[0] ||
+ 			    event->gpio.pin != fwspec->param[1])
+ 				continue;
+ 
+ 			err = irq_domain_set_hwirq_and_chip(domain, virq,
+ 							    event->id,
+ 							    &pmc->irq, pmc);
+ 
+ 			/* GPIO hierarchies stop at the PMC level */
+ 			if (!err && domain->parent)
+  				err = irq_domain_disconnect_hierarchy(domain->parent,
+ 								      virq);
+ 			break;
+ 		}
+ 	}
+ 
+ 	/* If there is no wake-up event, there is no PMC mapping */
+ 	if (i == soc->num_wake_events)
+ 		err = irq_domain_disconnect_hierarchy(domain, virq);
+ 
+ 	return err;
+ }
+ 
+ static const struct irq_domain_ops tegra_pmc_irq_domain_ops = {
+ 	.translate = tegra_pmc_irq_translate,
+ 	.alloc = tegra_pmc_irq_alloc,
+ };
+ 
+ static int tegra210_pmc_irq_set_wake(struct irq_data *data, unsigned int on)
+ {
+ 	struct tegra_pmc *pmc = irq_data_get_irq_chip_data(data);
+ 	unsigned int offset, bit;
+ 	u32 value;
+ 
+ 	offset = data->hwirq / 32;
+ 	bit = data->hwirq % 32;
+ 
+ 	/* clear wake status */
+ 	tegra_pmc_writel(pmc, 0, PMC_SW_WAKE_STATUS);
+ 	tegra_pmc_writel(pmc, 0, PMC_SW_WAKE2_STATUS);
+ 
+ 	tegra_pmc_writel(pmc, 0, PMC_WAKE_STATUS);
+ 	tegra_pmc_writel(pmc, 0, PMC_WAKE2_STATUS);
+ 
+ 	/* enable PMC wake */
+ 	if (data->hwirq >= 32)
+ 		offset = PMC_WAKE2_MASK;
+ 	else
+ 		offset = PMC_WAKE_MASK;
+ 
+ 	value = tegra_pmc_readl(pmc, offset);
+ 
+ 	if (on)
+ 		value |= BIT(bit);
+ 	else
+ 		value &= ~BIT(bit);
+ 
+ 	tegra_pmc_writel(pmc, value, offset);
+ 
+ 	return 0;
+ }
+ 
+ static int tegra210_pmc_irq_set_type(struct irq_data *data, unsigned int type)
+ {
+ 	struct tegra_pmc *pmc = irq_data_get_irq_chip_data(data);
+ 	unsigned int offset, bit;
+ 	u32 value;
+ 
+ 	offset = data->hwirq / 32;
+ 	bit = data->hwirq % 32;
+ 
+ 	if (data->hwirq >= 32)
+ 		offset = PMC_WAKE2_LEVEL;
+ 	else
+ 		offset = PMC_WAKE_LEVEL;
+ 
+ 	value = tegra_pmc_readl(pmc, offset);
+ 
+ 	switch (type) {
+ 	case IRQ_TYPE_EDGE_RISING:
+ 	case IRQ_TYPE_LEVEL_HIGH:
+ 		value |= BIT(bit);
+ 		break;
+ 
+ 	case IRQ_TYPE_EDGE_FALLING:
+ 	case IRQ_TYPE_LEVEL_LOW:
+ 		value &= ~BIT(bit);
+ 		break;
+ 
+ 	case IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING:
+ 		value ^= BIT(bit);
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	tegra_pmc_writel(pmc, value, offset);
+ 
+ 	return 0;
+ }
+ 
+ static int tegra186_pmc_irq_set_wake(struct irq_data *data, unsigned int on)
+ {
+ 	struct tegra_pmc *pmc = irq_data_get_irq_chip_data(data);
+ 	unsigned int offset, bit;
+ 	u32 value;
+ 
+ 	offset = data->hwirq / 32;
+ 	bit = data->hwirq % 32;
+ 
+ 	/* clear wake status */
+ 	writel(0x1, pmc->wake + WAKE_AOWAKE_STATUS_W(data->hwirq));
+ 
+ 	/* route wake to tier 2 */
+ 	value = readl(pmc->wake + WAKE_AOWAKE_TIER2_ROUTING(offset));
+ 
+ 	if (!on)
+ 		value &= ~(1 << bit);
+ 	else
+ 		value |= 1 << bit;
+ 
+ 	writel(value, pmc->wake + WAKE_AOWAKE_TIER2_ROUTING(offset));
+ 
+ 	/* enable wakeup event */
+ 	writel(!!on, pmc->wake + WAKE_AOWAKE_MASK_W(data->hwirq));
+ 
+ 	return 0;
+ }
+ 
+ static int tegra186_pmc_irq_set_type(struct irq_data *data, unsigned int type)
+ {
+ 	struct tegra_pmc *pmc = irq_data_get_irq_chip_data(data);
+ 	u32 value;
+ 
+ 	value = readl(pmc->wake + WAKE_AOWAKE_CNTRL(data->hwirq));
+ 
+ 	switch (type) {
+ 	case IRQ_TYPE_EDGE_RISING:
+ 	case IRQ_TYPE_LEVEL_HIGH:
+ 		value |= WAKE_AOWAKE_CNTRL_LEVEL;
+ 		break;
+ 
+ 	case IRQ_TYPE_EDGE_FALLING:
+ 	case IRQ_TYPE_LEVEL_LOW:
+ 		value &= ~WAKE_AOWAKE_CNTRL_LEVEL;
+ 		break;
+ 
+ 	case IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING:
+ 		value ^= WAKE_AOWAKE_CNTRL_LEVEL;
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	writel(value, pmc->wake + WAKE_AOWAKE_CNTRL(data->hwirq));
+ 
+ 	return 0;
+ }
+ 
+ static void tegra_irq_mask_parent(struct irq_data *data)
+ {
+ 	if (data->parent_data)
+ 		irq_chip_mask_parent(data);
+ }
+ 
+ static void tegra_irq_unmask_parent(struct irq_data *data)
+ {
+ 	if (data->parent_data)
+ 		irq_chip_unmask_parent(data);
+ }
+ 
+ static void tegra_irq_eoi_parent(struct irq_data *data)
+ {
+ 	if (data->parent_data)
+ 		irq_chip_eoi_parent(data);
+ }
+ 
+ static int tegra_irq_set_affinity_parent(struct irq_data *data,
+ 					 const struct cpumask *dest,
+ 					 bool force)
+ {
+ 	if (data->parent_data)
+ 		return irq_chip_set_affinity_parent(data, dest, force);
+ 
+ 	return -EINVAL;
+ }
+ 
+ static int tegra_pmc_irq_init(struct tegra_pmc *pmc)
+ {
+ 	struct irq_domain *parent = NULL;
+ 	struct device_node *np;
+ 
+ 	np = of_irq_find_parent(pmc->dev->of_node);
+ 	if (np) {
+ 		parent = irq_find_host(np);
+ 		of_node_put(np);
+ 	}
+ 
+ 	if (!parent)
+ 		return 0;
+ 
+ 	pmc->irq.name = dev_name(pmc->dev);
+ 	pmc->irq.irq_mask = tegra_irq_mask_parent;
+ 	pmc->irq.irq_unmask = tegra_irq_unmask_parent;
+ 	pmc->irq.irq_eoi = tegra_irq_eoi_parent;
+ 	pmc->irq.irq_set_affinity = tegra_irq_set_affinity_parent;
+ 	pmc->irq.irq_set_type = pmc->soc->irq_set_type;
+ 	pmc->irq.irq_set_wake = pmc->soc->irq_set_wake;
+ 
+ 	pmc->domain = irq_domain_add_hierarchy(parent, 0, 96, pmc->dev->of_node,
+ 					       &tegra_pmc_irq_domain_ops, pmc);
+ 	if (!pmc->domain) {
+ 		dev_err(pmc->dev, "failed to allocate domain\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int tegra_pmc_clk_notify_cb(struct notifier_block *nb,
+ 				   unsigned long action, void *ptr)
+ {
+ 	struct tegra_pmc *pmc = container_of(nb, struct tegra_pmc, clk_nb);
+ 	struct clk_notifier_data *data = ptr;
+ 
+ 	switch (action) {
+ 	case PRE_RATE_CHANGE:
+ 		mutex_lock(&pmc->powergates_lock);
+ 		break;
+ 
+ 	case POST_RATE_CHANGE:
+ 		pmc->rate = data->new_rate;
+ 		fallthrough;
+ 
+ 	case ABORT_RATE_CHANGE:
+ 		mutex_unlock(&pmc->powergates_lock);
+ 		break;
+ 
+ 	default:
+ 		WARN_ON_ONCE(1);
+ 		return notifier_from_errno(-EINVAL);
+ 	}
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ static void pmc_clk_fence_udelay(u32 offset)
+ {
+ 	tegra_pmc_readl(pmc, offset);
+ 	/* pmc clk propagation delay 2 us */
+ 	udelay(2);
+ }
+ 
+ static u8 pmc_clk_mux_get_parent(struct clk_hw *hw)
+ {
+ 	struct pmc_clk *clk = to_pmc_clk(hw);
+ 	u32 val;
+ 
+ 	val = tegra_pmc_readl(pmc, clk->offs) >> clk->mux_shift;
+ 	val &= PMC_CLK_OUT_MUX_MASK;
+ 
+ 	return val;
+ }
+ 
+ static int pmc_clk_mux_set_parent(struct clk_hw *hw, u8 index)
+ {
+ 	struct pmc_clk *clk = to_pmc_clk(hw);
+ 	u32 val;
+ 
+ 	val = tegra_pmc_readl(pmc, clk->offs);
+ 	val &= ~(PMC_CLK_OUT_MUX_MASK << clk->mux_shift);
+ 	val |= index << clk->mux_shift;
+ 	tegra_pmc_writel(pmc, val, clk->offs);
+ 	pmc_clk_fence_udelay(clk->offs);
+ 
+ 	return 0;
+ }
+ 
+ static int pmc_clk_is_enabled(struct clk_hw *hw)
+ {
+ 	struct pmc_clk *clk = to_pmc_clk(hw);
+ 	u32 val;
+ 
+ 	val = tegra_pmc_readl(pmc, clk->offs) & BIT(clk->force_en_shift);
+ 
+ 	return val ? 1 : 0;
+ }
+ 
+ static void pmc_clk_set_state(unsigned long offs, u32 shift, int state)
+ {
+ 	u32 val;
+ 
+ 	val = tegra_pmc_readl(pmc, offs);
+ 	val = state ? (val | BIT(shift)) : (val & ~BIT(shift));
+ 	tegra_pmc_writel(pmc, val, offs);
+ 	pmc_clk_fence_udelay(offs);
+ }
+ 
+ static int pmc_clk_enable(struct clk_hw *hw)
+ {
+ 	struct pmc_clk *clk = to_pmc_clk(hw);
+ 
+ 	pmc_clk_set_state(clk->offs, clk->force_en_shift, 1);
+ 
+ 	return 0;
+ }
+ 
+ static void pmc_clk_disable(struct clk_hw *hw)
+ {
+ 	struct pmc_clk *clk = to_pmc_clk(hw);
+ 
+ 	pmc_clk_set_state(clk->offs, clk->force_en_shift, 0);
+ }
+ 
+ static const struct clk_ops pmc_clk_ops = {
+ 	.get_parent = pmc_clk_mux_get_parent,
+ 	.set_parent = pmc_clk_mux_set_parent,
+ 	.determine_rate = __clk_mux_determine_rate,
+ 	.is_enabled = pmc_clk_is_enabled,
+ 	.enable = pmc_clk_enable,
+ 	.disable = pmc_clk_disable,
+ };
+ 
+ static struct clk *
+ tegra_pmc_clk_out_register(struct tegra_pmc *pmc,
+ 			   const struct pmc_clk_init_data *data,
+ 			   unsigned long offset)
+ {
+ 	struct clk_init_data init;
+ 	struct pmc_clk *pmc_clk;
+ 
+ 	pmc_clk = devm_kzalloc(pmc->dev, sizeof(*pmc_clk), GFP_KERNEL);
+ 	if (!pmc_clk)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	init.name = data->name;
+ 	init.ops = &pmc_clk_ops;
+ 	init.parent_names = data->parents;
+ 	init.num_parents = data->num_parents;
+ 	init.flags = CLK_SET_RATE_NO_REPARENT | CLK_SET_RATE_PARENT |
+ 		     CLK_SET_PARENT_GATE;
+ 
+ 	pmc_clk->hw.init = &init;
+ 	pmc_clk->offs = offset;
+ 	pmc_clk->mux_shift = data->mux_shift;
+ 	pmc_clk->force_en_shift = data->force_en_shift;
+ 
+ 	return clk_register(NULL, &pmc_clk->hw);
+ }
+ 
+ static int pmc_clk_gate_is_enabled(struct clk_hw *hw)
+ {
+ 	struct pmc_clk_gate *gate = to_pmc_clk_gate(hw);
+ 
+ 	return tegra_pmc_readl(pmc, gate->offs) & BIT(gate->shift) ? 1 : 0;
+ }
+ 
+ static int pmc_clk_gate_enable(struct clk_hw *hw)
+ {
+ 	struct pmc_clk_gate *gate = to_pmc_clk_gate(hw);
+ 
+ 	pmc_clk_set_state(gate->offs, gate->shift, 1);
+ 
+ 	return 0;
+ }
+ 
+ static void pmc_clk_gate_disable(struct clk_hw *hw)
+ {
+ 	struct pmc_clk_gate *gate = to_pmc_clk_gate(hw);
+ 
+ 	pmc_clk_set_state(gate->offs, gate->shift, 0);
+ }
+ 
+ static const struct clk_ops pmc_clk_gate_ops = {
+ 	.is_enabled = pmc_clk_gate_is_enabled,
+ 	.enable = pmc_clk_gate_enable,
+ 	.disable = pmc_clk_gate_disable,
+ };
+ 
+ static struct clk *
+ tegra_pmc_clk_gate_register(struct tegra_pmc *pmc, const char *name,
+ 			    const char *parent_name, unsigned long offset,
+ 			    u32 shift)
+ {
+ 	struct clk_init_data init;
+ 	struct pmc_clk_gate *gate;
+ 
+ 	gate = devm_kzalloc(pmc->dev, sizeof(*gate), GFP_KERNEL);
+ 	if (!gate)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	init.name = name;
+ 	init.ops = &pmc_clk_gate_ops;
+ 	init.parent_names = &parent_name;
+ 	init.num_parents = 1;
+ 	init.flags = 0;
+ 
+ 	gate->hw.init = &init;
+ 	gate->offs = offset;
+ 	gate->shift = shift;
+ 
+ 	return clk_register(NULL, &gate->hw);
+ }
+ 
+ static void tegra_pmc_clock_register(struct tegra_pmc *pmc,
+ 				     struct device_node *np)
+ {
+ 	struct clk *clk;
+ 	struct clk_onecell_data *clk_data;
+ 	unsigned int num_clks;
+ 	int i, err;
+ 
+ 	num_clks = pmc->soc->num_pmc_clks;
+ 	if (pmc->soc->has_blink_output)
+ 		num_clks += 1;
+ 
+ 	if (!num_clks)
+ 		return;
+ 
+ 	clk_data = devm_kmalloc(pmc->dev, sizeof(*clk_data), GFP_KERNEL);
+ 	if (!clk_data)
+ 		return;
+ 
+ 	clk_data->clks = devm_kcalloc(pmc->dev, TEGRA_PMC_CLK_MAX,
+ 				      sizeof(*clk_data->clks), GFP_KERNEL);
+ 	if (!clk_data->clks)
+ 		return;
+ 
+ 	clk_data->clk_num = TEGRA_PMC_CLK_MAX;
+ 
+ 	for (i = 0; i < TEGRA_PMC_CLK_MAX; i++)
+ 		clk_data->clks[i] = ERR_PTR(-ENOENT);
+ 
+ 	for (i = 0; i < pmc->soc->num_pmc_clks; i++) {
+ 		const struct pmc_clk_init_data *data;
+ 
+ 		data = pmc->soc->pmc_clks_data + i;
+ 
+ 		clk = tegra_pmc_clk_out_register(pmc, data, PMC_CLK_OUT_CNTRL);
+ 		if (IS_ERR(clk)) {
+ 			dev_warn(pmc->dev, "unable to register clock %s: %d\n",
+ 				 data->name, PTR_ERR_OR_ZERO(clk));
+ 			return;
+ 		}
+ 
+ 		err = clk_register_clkdev(clk, data->name, NULL);
+ 		if (err) {
+ 			dev_warn(pmc->dev,
+ 				 "unable to register %s clock lookup: %d\n",
+ 				 data->name, err);
+ 			return;
+ 		}
+ 
+ 		clk_data->clks[data->clk_id] = clk;
+ 	}
+ 
+ 	if (pmc->soc->has_blink_output) {
+ 		tegra_pmc_writel(pmc, 0x0, PMC_BLINK_TIMER);
+ 		clk = tegra_pmc_clk_gate_register(pmc,
+ 						  "pmc_blink_override",
+ 						  "clk_32k",
+ 						  PMC_DPD_PADS_ORIDE,
+ 						  PMC_DPD_PADS_ORIDE_BLINK);
+ 		if (IS_ERR(clk)) {
+ 			dev_warn(pmc->dev,
+ 				 "unable to register pmc_blink_override: %d\n",
+ 				 PTR_ERR_OR_ZERO(clk));
+ 			return;
+ 		}
+ 
+ 		clk = tegra_pmc_clk_gate_register(pmc, "pmc_blink",
+ 						  "pmc_blink_override",
+ 						  PMC_CNTRL,
+ 						  PMC_CNTRL_BLINK_EN);
+ 		if (IS_ERR(clk)) {
+ 			dev_warn(pmc->dev,
+ 				 "unable to register pmc_blink: %d\n",
+ 				 PTR_ERR_OR_ZERO(clk));
+ 			return;
+ 		}
+ 
+ 		err = clk_register_clkdev(clk, "pmc_blink", NULL);
+ 		if (err) {
+ 			dev_warn(pmc->dev,
+ 				 "unable to register pmc_blink lookup: %d\n",
+ 				 err);
+ 			return;
+ 		}
+ 
+ 		clk_data->clks[TEGRA_PMC_CLK_BLINK] = clk;
+ 	}
+ 
+ 	err = of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
+ 	if (err)
+ 		dev_warn(pmc->dev, "failed to add pmc clock provider: %d\n",
+ 			 err);
+ }
+ 
++>>>>>>> 31f9a421a1d0 (pinctrl: Introduce MODE group in enum pin_config_param)
  static int tegra_pmc_probe(struct platform_device *pdev)
  {
  	void __iomem *base;
diff --git a/drivers/pinctrl/pinconf-generic.c b/drivers/pinctrl/pinconf-generic.c
index dfef471201f6..18c19de3a224 100644
--- a/drivers/pinctrl/pinconf-generic.c
+++ b/drivers/pinctrl/pinconf-generic.c
@@ -43,7 +43,7 @@ static const struct pin_config_item conf_items[] = {
 	PCONFDUMP(PIN_CONFIG_INPUT_ENABLE, "input enabled", NULL, false),
 	PCONFDUMP(PIN_CONFIG_INPUT_SCHMITT, "input schmitt trigger", NULL, false),
 	PCONFDUMP(PIN_CONFIG_INPUT_SCHMITT_ENABLE, "input schmitt enabled", NULL, false),
-	PCONFDUMP(PIN_CONFIG_LOW_POWER_MODE, "pin low power", "mode", true),
+	PCONFDUMP(PIN_CONFIG_MODE_LOW_POWER, "pin low power", "mode", true),
 	PCONFDUMP(PIN_CONFIG_OUTPUT_ENABLE, "output enabled", NULL, false),
 	PCONFDUMP(PIN_CONFIG_OUTPUT, "pin output", "level", true),
 	PCONFDUMP(PIN_CONFIG_POWER_SOURCE, "pin power source", "selector", true),
@@ -174,8 +174,8 @@ static const struct pinconf_generic_params dt_params[] = {
 	{ "input-schmitt", PIN_CONFIG_INPUT_SCHMITT, 0 },
 	{ "input-schmitt-disable", PIN_CONFIG_INPUT_SCHMITT_ENABLE, 0 },
 	{ "input-schmitt-enable", PIN_CONFIG_INPUT_SCHMITT_ENABLE, 1 },
-	{ "low-power-disable", PIN_CONFIG_LOW_POWER_MODE, 0 },
-	{ "low-power-enable", PIN_CONFIG_LOW_POWER_MODE, 1 },
+	{ "low-power-disable", PIN_CONFIG_MODE_LOW_POWER, 0 },
+	{ "low-power-enable", PIN_CONFIG_MODE_LOW_POWER, 1 },
 	{ "output-disable", PIN_CONFIG_OUTPUT_ENABLE, 0 },
 	{ "output-enable", PIN_CONFIG_OUTPUT_ENABLE, 1 },
 	{ "output-high", PIN_CONFIG_OUTPUT, 1, },
diff --git a/drivers/pinctrl/pinctrl-lpc18xx.c b/drivers/pinctrl/pinctrl-lpc18xx.c
index 190f17e4bbda..497f5833d37e 100644
--- a/drivers/pinctrl/pinctrl-lpc18xx.c
+++ b/drivers/pinctrl/pinctrl-lpc18xx.c
@@ -652,7 +652,7 @@ static const struct pin_config_item lpc18xx_conf_items[ARRAY_SIZE(lpc18xx_params
 static int lpc18xx_pconf_get_usb1(enum pin_config_param param, int *arg, u32 reg)
 {
 	switch (param) {
-	case PIN_CONFIG_LOW_POWER_MODE:
+	case PIN_CONFIG_MODE_LOW_POWER:
 		if (reg & LPC18XX_SCU_USB1_EPWR)
 			*arg = 0;
 		else
@@ -907,7 +907,7 @@ static int lpc18xx_pconf_set_usb1(struct pinctrl_dev *pctldev,
 				  u32 param_val, u32 *reg)
 {
 	switch (param) {
-	case PIN_CONFIG_LOW_POWER_MODE:
+	case PIN_CONFIG_MODE_LOW_POWER:
 		if (param_val)
 			*reg &= ~LPC18XX_SCU_USB1_EPWR;
 		else
diff --git a/drivers/pinctrl/pinctrl-single.c b/drivers/pinctrl/pinctrl-single.c
index e5647dac0818..dec6ac8a9877 100644
--- a/drivers/pinctrl/pinctrl-single.c
+++ b/drivers/pinctrl/pinctrl-single.c
@@ -509,7 +509,7 @@ static int pcs_pinconf_get(struct pinctrl_dev *pctldev,
 			break;
 		case PIN_CONFIG_DRIVE_STRENGTH:
 		case PIN_CONFIG_SLEW_RATE:
-		case PIN_CONFIG_LOW_POWER_MODE:
+		case PIN_CONFIG_MODE_LOW_POWER:
 		default:
 			*config = data;
 			break;
@@ -547,7 +547,7 @@ static int pcs_pinconf_set(struct pinctrl_dev *pctldev,
 			case PIN_CONFIG_INPUT_SCHMITT:
 			case PIN_CONFIG_DRIVE_STRENGTH:
 			case PIN_CONFIG_SLEW_RATE:
-			case PIN_CONFIG_LOW_POWER_MODE:
+			case PIN_CONFIG_MODE_LOW_POWER:
 				shift = ffs(func->conf[i].mask) - 1;
 				data &= ~func->conf[i].mask;
 				data |= (arg << shift) & func->conf[i].mask;
@@ -899,7 +899,7 @@ static int pcs_parse_pinconf(struct pcs_device *pcs, struct device_node *np,
 		{ "pinctrl-single,drive-strength", PIN_CONFIG_DRIVE_STRENGTH, },
 		{ "pinctrl-single,slew-rate", PIN_CONFIG_SLEW_RATE, },
 		{ "pinctrl-single,input-schmitt", PIN_CONFIG_INPUT_SCHMITT, },
-		{ "pinctrl-single,low-power-mode", PIN_CONFIG_LOW_POWER_MODE, },
+		{ "pinctrl-single,low-power-mode", PIN_CONFIG_MODE_LOW_POWER, },
 	};
 	static const struct pcs_conf_type prop4[] = {
 		{ "pinctrl-single,bias-pullup", PIN_CONFIG_BIAS_PULL_UP, },
diff --git a/drivers/pinctrl/pinctrl-zynq.c b/drivers/pinctrl/pinctrl-zynq.c
index a0daf27042bd..aa571d476013 100644
--- a/drivers/pinctrl/pinctrl-zynq.c
+++ b/drivers/pinctrl/pinctrl-zynq.c
@@ -1031,7 +1031,7 @@ static int zynq_pinconf_cfg_get(struct pinctrl_dev *pctldev,
 	case PIN_CONFIG_SLEW_RATE:
 		arg = !!(reg & ZYNQ_PINCONF_SPEED);
 		break;
-	case PIN_CONFIG_LOW_POWER_MODE:
+	case PIN_CONFIG_MODE_LOW_POWER:
 	{
 		enum zynq_io_standards iostd = zynq_pinconf_iostd_get(reg);
 
@@ -1102,7 +1102,7 @@ static int zynq_pinconf_cfg_set(struct pinctrl_dev *pctldev,
 			reg &= ~ZYNQ_PINCONF_IOTYPE_MASK;
 			reg |= arg << ZYNQ_PINCONF_IOTYPE_SHIFT;
 			break;
-		case PIN_CONFIG_LOW_POWER_MODE:
+		case PIN_CONFIG_MODE_LOW_POWER:
 			if (arg)
 				reg |= ZYNQ_PINCONF_DISABLE_RECVR;
 			else
diff --git a/drivers/pinctrl/pxa/pinctrl-pxa2xx.c b/drivers/pinctrl/pxa/pinctrl-pxa2xx.c
index 6cf0006d4c8d..2c429a49cade 100644
--- a/drivers/pinctrl/pxa/pinctrl-pxa2xx.c
+++ b/drivers/pinctrl/pxa/pinctrl-pxa2xx.c
@@ -197,7 +197,7 @@ static int pxa2xx_pconf_group_get(struct pinctrl_dev *pctldev,
 
 	spin_lock_irqsave(&pctl->lock, flags);
 	val = readl_relaxed(pgsr) & BIT(pin % 32);
-	*config = val ? PIN_CONFIG_LOW_POWER_MODE : 0;
+	*config = val ? PIN_CONFIG_MODE_LOW_POWER : 0;
 	spin_unlock_irqrestore(&pctl->lock, flags);
 
 	dev_dbg(pctl->dev, "get sleep gpio state(pin=%d) %d\n",
@@ -220,7 +220,7 @@ static int pxa2xx_pconf_group_set(struct pinctrl_dev *pctldev,
 
 	for (i = 0; i < num_configs; i++) {
 		switch (pinconf_to_config_param(configs[i])) {
-		case PIN_CONFIG_LOW_POWER_MODE:
+		case PIN_CONFIG_MODE_LOW_POWER:
 			is_set = pinconf_to_config_argument(configs[i]);
 			break;
 		default:
* Unmerged path drivers/soc/tegra/pmc.c
diff --git a/include/linux/pinctrl/pinconf-generic.h b/include/linux/pinctrl/pinconf-generic.h
index 81f1abde5728..544e4e47d45c 100644
--- a/include/linux/pinctrl/pinconf-generic.h
+++ b/include/linux/pinctrl/pinconf-generic.h
@@ -77,7 +77,7 @@ struct pinctrl_map;
  * @PIN_CONFIG_INPUT_SCHMITT_ENABLE: control schmitt-trigger mode on the pin.
  *      If the argument != 0, schmitt-trigger mode is enabled. If it's 0,
  *      schmitt-trigger mode is disabled.
- * @PIN_CONFIG_LOW_POWER_MODE: this will configure the pin for low power
+ * @PIN_CONFIG_MODE_LOW_POWER: this will configure the pin for low power
  *	operation, if several modes of operation are supported these can be
  *	passed in the argument on a custom form, else just use argument 1
  *	to indicate low power mode, argument 0 turns low power mode off.
@@ -125,7 +125,7 @@ enum pin_config_param {
 	PIN_CONFIG_INPUT_ENABLE,
 	PIN_CONFIG_INPUT_SCHMITT,
 	PIN_CONFIG_INPUT_SCHMITT_ENABLE,
-	PIN_CONFIG_LOW_POWER_MODE,
+	PIN_CONFIG_MODE_LOW_POWER,
 	PIN_CONFIG_OUTPUT_ENABLE,
 	PIN_CONFIG_OUTPUT,
 	PIN_CONFIG_PERSIST_STATE,
