mm/migrate: fix migrate_pgmap_owner w/o CONFIG_MMU_NOTIFIER

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Ralph Campbell <rcampbell@nvidia.com>
commit c1a06df6ebf6ca98fb7a672fe447c7469d6c1968
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/c1a06df6.failed

On x86_64, when CONFIG_MMU_NOTIFIER is not set/enabled, there is a
compiler error:

   mm/migrate.c: In function 'migrate_vma_collect':
   mm/migrate.c:2481:7: error: 'struct mmu_notifier_range' has no member named 'migrate_pgmap_owner'
     range.migrate_pgmap_owner = migrate->pgmap_owner;
          ^

Fixes: 998427b3ad2c ("mm/notifier: add migration invalidation type")
	Reported-by: Randy Dunlap <rdunlap@infradead.org>
	Signed-off-by: Ralph Campbell <rcampbell@nvidia.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Tested-by: Randy Dunlap <rdunlap@infradead.org>
	Acked-by: Randy Dunlap <rdunlap@infradead.org>
	Cc: Jerome Glisse <jglisse@redhat.com>
	Cc: John Hubbard <jhubbard@nvidia.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: "Jason Gunthorpe" <jgg@mellanox.com>
Link: http://lkml.kernel.org/r/20200806193353.7124-1-rcampbell@nvidia.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit c1a06df6ebf6ca98fb7a672fe447c7469d6c1968)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/migrate.c
diff --cc mm/migrate.c
index 6e0b070f8524,d179657f8685..000000000000
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@@ -2448,9 -2381,14 +2448,20 @@@ static void migrate_vma_collect(struct 
  {
  	struct mmu_notifier_range range;
  
++<<<<<<< HEAD
 +	mmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, NULL,
 +				migrate->vma->vm_mm, migrate->start,
 +				migrate->end);
++=======
+ 	/*
+ 	 * Note that the pgmap_owner is passed to the mmu notifier callback so
+ 	 * that the registered device driver can skip invalidating device
+ 	 * private page mappings that won't be migrated.
+ 	 */
+ 	mmu_notifier_range_init_migrate(&range, 0, migrate->vma,
+ 		migrate->vma->vm_mm, migrate->start, migrate->end,
+ 		migrate->pgmap_owner);
++>>>>>>> c1a06df6ebf6 (mm/migrate: fix migrate_pgmap_owner w/o CONFIG_MMU_NOTIFIER)
  	mmu_notifier_invalidate_range_start(&range);
  
  	walk_page_range(migrate->vma->vm_mm, migrate->start, migrate->end,
diff --git a/include/linux/mmu_notifier.h b/include/linux/mmu_notifier.h
index d924803cea7c..e92c3cfe7a6e 100644
--- a/include/linux/mmu_notifier.h
+++ b/include/linux/mmu_notifier.h
@@ -528,6 +528,16 @@ static inline void mmu_notifier_range_init(struct mmu_notifier_range *range,
 	range->end = end;
 }
 
+static inline void mmu_notifier_range_init_migrate(
+			struct mmu_notifier_range *range, unsigned int flags,
+			struct vm_area_struct *vma, struct mm_struct *mm,
+			unsigned long start, unsigned long end, void *pgmap)
+{
+	mmu_notifier_range_init(range, MMU_NOTIFY_MIGRATE, flags, vma, mm,
+				start, end);
+	range->migrate_pgmap_owner = pgmap;
+}
+
 #define ptep_clear_flush_young_notify(__vma, __address, __ptep)		\
 ({									\
 	int __young;							\
@@ -655,6 +665,9 @@ static inline void _mmu_notifier_range_init(struct mmu_notifier_range *range,
 
 #define mmu_notifier_range_init(range,event,flags,vma,mm,start,end)  \
 	_mmu_notifier_range_init(range, start, end)
+#define mmu_notifier_range_init_migrate(range, flags, vma, mm, start, end, \
+					pgmap) \
+	_mmu_notifier_range_init(range, start, end)
 
 static inline bool
 mmu_notifier_range_blockable(const struct mmu_notifier_range *range)
* Unmerged path mm/migrate.c
