x86/fpu: Rename xstate copy functions which are related to UABI

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 1cc34413ff3f18c30e5df89fefd95cc0f3b3292e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/1cc34413.failed

Rename them to reflect that these functions deal with user space format
XSAVE buffers.

      copy_kernel_to_xstate() -> copy_uabi_from_kernel_to_xstate()
      copy_user_to_xstate()   -> copy_sigframe_from_user_to_xstate()

Again a clear statement that these functions deal with user space ABI.

	Suggested-by: Andy Lutomirski <luto@kernel.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20210623121454.318485015@linutronix.de
(cherry picked from commit 1cc34413ff3f18c30e5df89fefd95cc0f3b3292e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/fpu/xstate.h
#	arch/x86/kernel/fpu/regset.c
diff --cc arch/x86/include/asm/fpu/xstate.h
index 3c3a675cc056,00e1a2ac5239..000000000000
--- a/arch/x86/include/asm/fpu/xstate.h
+++ b/arch/x86/include/asm/fpu/xstate.h
@@@ -101,13 -101,9 +101,18 @@@ extern void __init update_regset_xstate
  					     u64 xstate_mask);
  
  void *get_xsave_addr(struct xregs_state *xsave, int xfeature_nr);
 +const void *get_xsave_field_ptr(int xfeature_nr);
 +int using_compacted_format(void);
  int xfeature_size(int xfeature_nr);
++<<<<<<< HEAD
 +int copy_xstate_to_kernel(void *kbuf, struct xregs_state *xsave, unsigned int offset, unsigned int size);
 +int copy_xstate_to_user(void __user *ubuf, struct xregs_state *xsave, unsigned int offset, unsigned int size);
 +int copy_kernel_to_xstate(struct xregs_state *xsave, const void *kbuf);
 +int copy_user_to_xstate(struct xregs_state *xsave, const void __user *ubuf);
++=======
+ int copy_uabi_from_kernel_to_xstate(struct xregs_state *xsave, const void *kbuf);
+ int copy_sigframe_from_user_to_xstate(struct xregs_state *xsave, const void __user *ubuf);
++>>>>>>> 1cc34413ff3f (x86/fpu: Rename xstate copy functions which are related to UABI)
  void copy_dynamic_supervisor_to_kernel(struct xregs_state *xstate, u64 mask);
  void copy_kernel_to_dynamic_supervisor(struct xregs_state *xstate, u64 mask);
  
diff --cc arch/x86/kernel/fpu/regset.c
index 7bcf779c46cb,892aec1dd822..000000000000
--- a/arch/x86/kernel/fpu/regset.c
+++ b/arch/x86/kernel/fpu/regset.c
@@@ -150,8 -165,8 +150,13 @@@ int xstateregs_set(struct task_struct *
  		}
  	}
  
++<<<<<<< HEAD
 +	fpu__prepare_write(fpu);
 +	ret = copy_kernel_to_xstate(&fpu->state.xsave, kbuf ?: tmpbuf);
++=======
+ 	fpu_force_restore(fpu);
+ 	ret = copy_uabi_from_kernel_to_xstate(&fpu->state.xsave, kbuf ?: tmpbuf);
++>>>>>>> 1cc34413ff3f (x86/fpu: Rename xstate copy functions which are related to UABI)
  
  out:
  	vfree(tmpbuf);
* Unmerged path arch/x86/include/asm/fpu/xstate.h
* Unmerged path arch/x86/kernel/fpu/regset.c
diff --git a/arch/x86/kernel/fpu/signal.c b/arch/x86/kernel/fpu/signal.c
index 5f4bd04da0b6..933b484d994e 100644
--- a/arch/x86/kernel/fpu/signal.c
+++ b/arch/x86/kernel/fpu/signal.c
@@ -420,7 +420,7 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
 	if (use_xsave() && !fx_only) {
 		u64 init_bv = xfeatures_mask_user() & ~user_xfeatures;
 
-		ret = copy_user_to_xstate(&fpu->state.xsave, buf_fx);
+		ret = copy_sigframe_from_user_to_xstate(&fpu->state.xsave, buf_fx);
 		if (ret)
 			goto out;
 
diff --git a/arch/x86/kernel/fpu/xstate.c b/arch/x86/kernel/fpu/xstate.c
index 4641d3145e59..6234f721109e 100644
--- a/arch/x86/kernel/fpu/xstate.c
+++ b/arch/x86/kernel/fpu/xstate.c
@@ -1213,7 +1213,7 @@ static inline bool mxcsr_valid(struct xstate_header *hdr, const u32 *mxcsr)
  * Convert from a ptrace standard-format kernel buffer to kernel XSAVE[S] format
  * and copy to the target thread. This is called from xstateregs_set().
  */
-int copy_kernel_to_xstate(struct xregs_state *xsave, const void *kbuf)
+int copy_uabi_from_kernel_to_xstate(struct xregs_state *xsave, const void *kbuf)
 {
 	unsigned int offset, size;
 	int i;
@@ -1268,7 +1268,8 @@ int copy_kernel_to_xstate(struct xregs_state *xsave, const void *kbuf)
  * XSAVE[S] format and copy to the target thread. This is called from the
  * sigreturn() and rt_sigreturn() system calls.
  */
-int copy_user_to_xstate(struct xregs_state *xsave, const void __user *ubuf)
+int copy_sigframe_from_user_to_xstate(struct xregs_state *xsave,
+				      const void __user *ubuf)
 {
 	unsigned int offset, size;
 	int i;
