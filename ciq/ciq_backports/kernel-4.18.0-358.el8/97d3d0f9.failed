mm/huge_memory.c: thp: fix conflict of above-47bit hint address and PMD alignment

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Kirill A. Shutemov <kirill@shutemov.name>
commit 97d3d0f9a1cf132c63c0b8b8bd497b8a56283dd9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/97d3d0f9.failed

Patch series "Fix two above-47bit hint address vs.  THP bugs".

The two get_unmapped_area() implementations have to be fixed to provide
THP-friendly mappings if above-47bit hint address is specified.

This patch (of 2):

Filesystems use thp_get_unmapped_area() to provide THP-friendly
mappings.  For DAX in particular.

Normally, the kernel doesn't create userspace mappings above 47-bit,
even if the machine allows this (such as with 5-level paging on x86-64).
Not all user space is ready to handle wide addresses.  It's known that
at least some JIT compilers use higher bits in pointers to encode their
information.

Userspace can ask for allocation from full address space by specifying
hint address (with or without MAP_FIXED) above 47-bits.  If the
application doesn't need a particular address, but wants to allocate
from whole address space it can specify -1 as a hint address.

Unfortunately, this trick breaks thp_get_unmapped_area(): the function
would not try to allocate PMD-aligned area if *any* hint address
specified.

Modify the routine to handle it correctly:

 - Try to allocate the space at the specified hint address with length
   padding required for PMD alignment.
 - If failed, retry without length padding (but with the same hint
   address);
 - If the returned address matches the hint address return it.
 - Otherwise, align the address as required for THP and return.

The user specified hint address is passed down to get_unmapped_area() so
above-47bit hint address will be taken into account without breaking
alignment requirements.

Link: http://lkml.kernel.org/r/20191220142548.7118-2-kirill.shutemov@linux.intel.com
Fixes: b569bab78d8d ("x86/mm: Prepare to expose larger address space to userspace")
	Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Reported-by: Thomas Willhalm <thomas.willhalm@intel.com>
	Tested-by: Dan Williams <dan.j.williams@intel.com>
	Cc: "Aneesh Kumar K . V" <aneesh.kumar@linux.vnet.ibm.com>
	Cc: "Bruggeman, Otto G" <otto.g.bruggeman@intel.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 97d3d0f9a1cf132c63c0b8b8bd497b8a56283dd9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/huge_memory.c
diff --cc mm/huge_memory.c
index 7d91dae821ed,a88093213674..000000000000
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@@ -521,24 -527,13 +521,28 @@@ void prep_transhuge_page(struct page *p
  	set_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);
  }
  
++<<<<<<< HEAD
 +bool is_transparent_hugepage(struct page *page)
 +{
 +	if (!PageCompound(page))
 +		return 0;
 +
 +	page = compound_head(page);
 +	return is_huge_zero_page(page) ||
 +	       page[1].compound_dtor == TRANSHUGE_PAGE_DTOR;
 +}
 +EXPORT_SYMBOL_GPL(is_transparent_hugepage);
 +
 +unsigned long __thp_get_unmapped_area(struct file *filp, unsigned long len,
++=======
+ static unsigned long __thp_get_unmapped_area(struct file *filp,
+ 		unsigned long addr, unsigned long len,
++>>>>>>> 97d3d0f9a1cf (mm/huge_memory.c: thp: fix conflict of above-47bit hint address and PMD alignment)
  		loff_t off, unsigned long flags, unsigned long size)
  {
- 	unsigned long addr;
  	loff_t off_end = off + len;
  	loff_t off_align = round_up(off, size);
- 	unsigned long len_pad;
+ 	unsigned long len_pad, ret;
  
  	if (off_end <= off_align || (off_end - off_align) < size)
  		return 0;
* Unmerged path mm/huge_memory.c
