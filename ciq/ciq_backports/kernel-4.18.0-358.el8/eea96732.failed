exec: Add exec_update_mutex to replace cred_guard_mutex

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit eea9673250db4e854e9998ef9da6d4584857f0ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/eea96732.failed

The cred_guard_mutex is problematic as it is held over possibly
indefinite waits for userspace.  The possible indefinite waits for
userspace that I have identified are: The cred_guard_mutex is held in
PTRACE_EVENT_EXIT waiting for the tracer.  The cred_guard_mutex is
held over "put_user(0, tsk->clear_child_tid)" in exit_mm().  The
cred_guard_mutex is held over "get_user(futex_offset, ...")  in
exit_robust_list.  The cred_guard_mutex held over copy_strings.

The functions get_user and put_user can trigger a page fault which can
potentially wait indefinitely in the case of userfaultfd or if
userspace implements part of the page fault path.

In any of those cases the userspace process that the kernel is waiting
for might make a different system call that winds up taking the
cred_guard_mutex and result in deadlock.

Holding a mutex over any of those possibly indefinite waits for
userspace does not appear necessary.  Add exec_update_mutex that will
just cover updating the process during exec where the permissions and
the objects pointed to by the task struct may be out of sync.

The plan is to switch the users of cred_guard_mutex to
exec_update_mutex one by one.  This lets us move forward while still
being careful and not introducing any regressions.

Link: https://lore.kernel.org/lkml/20160921152946.GA24210@dhcp22.suse.cz/
Link: https://lore.kernel.org/lkml/AM6PR03MB5170B06F3A2B75EFB98D071AE4E60@AM6PR03MB5170.eurprd03.prod.outlook.com/
Link: https://lore.kernel.org/linux-fsdevel/20161102181806.GB1112@redhat.com/
Link: https://lore.kernel.org/lkml/20160923095031.GA14923@redhat.com/
Link: https://lore.kernel.org/lkml/20170213141452.GA30203@redhat.com/
Ref: 45c1a159b85b ("Add PTRACE_O_TRACEVFORKDONE and PTRACE_O_TRACEEXIT facilities.")
Ref: 456f17cd1a28 ("[PATCH] user-vm-unlock-2.5.31-A2")
	Reviewed-by: Kirill Tkhai <ktkhai@virtuozzo.com>
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
	Signed-off-by: Bernd Edlinger <bernd.edlinger@hotmail.de>
	Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
(cherry picked from commit eea9673250db4e854e9998ef9da6d4584857f0ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/exec.c
#	include/linux/sched/signal.h
diff --cc fs/exec.c
index 671dee5c3348,0e46ec57fe0a..000000000000
--- a/fs/exec.c
+++ b/fs/exec.c
@@@ -1018,34 -1035,23 +1028,40 @@@ static int exec_mmap(struct mm_struct *
  		/*
  		 * Make sure that if there is a core dump in progress
  		 * for the old mm, we get out and die instead of going
 -		 * through with the exec.  We must hold mmap_sem around
 +		 * through with the exec.  We must hold mmap_lock around
  		 * checking core_state and changing tsk->mm.
  		 */
 -		down_read(&old_mm->mmap_sem);
 +		mmap_read_lock(old_mm);
  		if (unlikely(old_mm->core_state)) {
++<<<<<<< HEAD
 +			mmap_read_unlock(old_mm);
++=======
+ 			up_read(&old_mm->mmap_sem);
+ 			mutex_unlock(&tsk->signal->exec_update_mutex);
++>>>>>>> eea9673250db (exec: Add exec_update_mutex to replace cred_guard_mutex)
  			return -EINTR;
  		}
  	}
+ 
  	task_lock(tsk);
 -	active_mm = tsk->active_mm;
  	membarrier_exec_mmap(mm);
 -	tsk->mm = mm;
 +
 +	local_irq_disable();
 +	active_mm = tsk->active_mm;
  	tsk->active_mm = mm;
 +	tsk->mm = mm;
 +	/*
 +	 * This prevents preemption while active_mm is being loaded and
 +	 * it and mm are being updated, which could cause problems for
 +	 * lazy tlb mm refcounting when these are updated by context
 +	 * switches. Not all architectures can handle irqs off over
 +	 * activate_mm yet.
 +	 */
 +	if (!IS_ENABLED(CONFIG_ARCH_WANT_IRQS_OFF_ACTIVATE_MM))
 +		local_irq_enable();
  	activate_mm(active_mm, mm);
 +	if (IS_ENABLED(CONFIG_ARCH_WANT_IRQS_OFF_ACTIVATE_MM))
 +		local_irq_enable();
  	tsk->mm->vmacache_seqnum = 0;
  	vmacache_flush(tsk);
  	task_unlock(tsk);
@@@ -1684,10 -1694,10 +1704,10 @@@ int search_binary_handler(struct linux_
  
  		read_lock(&binfmt_lock);
  		put_binfmt(fmt);
- 		if (retval < 0 && !bprm->mm) {
+ 		if (retval < 0 && bprm->called_exec_mmap) {
  			/* we got to flush_old_exec() and failed after it */
  			read_unlock(&binfmt_lock);
 -			force_sigsegv(SIGSEGV);
 +			force_sigsegv(SIGSEGV, current);
  			return retval;
  		}
  		if (retval != -ENOEXEC || !bprm->file) {
diff --cc include/linux/sched/signal.h
index b260e8feef0c,a29df79540ce..000000000000
--- a/include/linux/sched/signal.h
+++ b/include/linux/sched/signal.h
@@@ -228,23 -224,14 +228,34 @@@ struct signal_struct 
  
  	struct mutex cred_guard_mutex;	/* guard against foreign influences on
  					 * credential calculations
++<<<<<<< HEAD
 +					 * (notably. ptrace) */
 +
 +	/*
 +	 * RHEL8: signal_struct is always dynamically allocated at process
 +	 * creation time and not embedded directly into other structure.
 +	 * So it is safe to extend the size of the structure.
 +	 */
 +	/* PID/PID hash table linkage. */
 +	RH_KABI_EXTEND(struct pid *pids[PIDTYPE_MAX])
 +
 +	/* For collecting multiprocess signals during fork */
 +	RH_KABI_USE(1, struct hlist_head multiprocess)
 +
 +	RH_KABI_RESERVE(2)
 +	RH_KABI_RESERVE(3)
 +	RH_KABI_RESERVE(4)
 +	RH_KABI_EXTEND(struct posix_cputimers posix_cputimers)
++=======
+ 					 * (notably. ptrace)
+ 					 * Deprecated do not use in new code.
+ 					 * Use exec_update_mutex instead.
+ 					 */
+ 	struct mutex exec_update_mutex;	/* Held while task_struct is being
+ 					 * updated during exec, and may have
+ 					 * inconsistent permissions.
+ 					 */
++>>>>>>> eea9673250db (exec: Add exec_update_mutex to replace cred_guard_mutex)
  } __randomize_layout;
  
  /*
* Unmerged path fs/exec.c
diff --git a/include/linux/binfmts.h b/include/linux/binfmts.h
index 8c12228326b0..5f7290f26bbc 100644
--- a/include/linux/binfmts.h
+++ b/include/linux/binfmts.h
@@ -44,7 +44,13 @@ struct linux_binprm {
 		 * exec has happened. Used to sanitize execution environment
 		 * and to set AT_SECURE auxv for glibc.
 		 */
-		secureexec:1;
+		secureexec:1,
+		/*
+		 * Set by flush_old_exec, when exec_mmap has been called.
+		 * This is past the point of no return, when the
+		 * exec_update_mutex has been taken.
+		 */
+		called_exec_mmap:1;
 #ifdef __alpha__
 	unsigned int taso:1;
 #endif
* Unmerged path include/linux/sched/signal.h
diff --git a/init/init_task.c b/init/init_task.c
index a267e8049159..d154824c2dc3 100644
--- a/init/init_task.c
+++ b/init/init_task.c
@@ -27,6 +27,7 @@ static struct signal_struct init_signals = {
 	.multiprocess	= HLIST_HEAD_INIT,
 	.rlim		= INIT_RLIMITS,
 	.cred_guard_mutex = __MUTEX_INITIALIZER(init_signals.cred_guard_mutex),
+	.exec_update_mutex = __MUTEX_INITIALIZER(init_signals.exec_update_mutex),
 #ifdef CONFIG_POSIX_TIMERS
 	.posix_timers = LIST_HEAD_INIT(init_signals.posix_timers),
 	.cputimer	= {
diff --git a/kernel/fork.c b/kernel/fork.c
index 886c2f479b06..518750fe4168 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1590,6 +1590,7 @@ static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)
 	sig->oom_score_adj_min = current->signal->oom_score_adj_min;
 
 	mutex_init(&sig->cred_guard_mutex);
+	mutex_init(&sig->exec_update_mutex);
 
 	return 0;
 }
