vrf: Fix fast path output packet handling with async Netfilter rules

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Martin Willi <martin@strongswan.org>
commit 9e2b7fa2df4365e99934901da4fb4af52d81e820
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/9e2b7fa2.failed

VRF devices use an optimized direct path on output if a default qdisc
is involved, calling Netfilter hooks directly. This path, however, does
not consider Netfilter rules completing asynchronously, such as with
NFQUEUE. The Netfilter okfn() is called for asynchronously accepted
packets, but the VRF never passes that packet down the stack to send
it out over the slave device. Using the slower redirect path for this
seems not feasible, as we do not know beforehand if a Netfilter hook
has asynchronously completing rules.

Fix the use of asynchronously completing Netfilter rules in OUTPUT and
POSTROUTING by using a special completion function that additionally
calls dst_output() to pass the packet down the stack. Also, slightly
adjust the use of nf_reset_ct() so that is called in the asynchronous
case, too.

Fixes: dcdd43c41e60 ("net: vrf: performance improvements for IPv4")
Fixes: a9ec54d1b0cd ("net: vrf: performance improvements for IPv6")
	Signed-off-by: Martin Willi <martin@strongswan.org>
Link: https://lore.kernel.org/r/20201106073030.3974927-1-martin@strongswan.org
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 9e2b7fa2df4365e99934901da4fb4af52d81e820)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vrf.c
diff --cc drivers/net/vrf.c
index b513e17e6c86,f2793ffde191..000000000000
--- a/drivers/net/vrf.c
+++ b/drivers/net/vrf.c
@@@ -459,13 -759,10 +485,16 @@@ static struct sk_buff *vrf_ip6_out_dire
  	if (likely(err == 1))
  		err = vrf_output6_direct(net, sk, skb);
  
- 	/* reset skb device */
  	if (likely(err == 1))
++<<<<<<< HEAD
 +		nf_reset(skb);
 +	else
 +		skb = NULL;
++=======
+ 		return skb;
++>>>>>>> 9e2b7fa2df43 (vrf: Fix fast path output packet handling with async Netfilter rules)
  
- 	return skb;
+ 	return NULL;
  }
  
  static struct sk_buff *vrf_ip6_out(struct net_device *vrf_dev,
@@@ -673,13 -994,10 +728,16 @@@ static struct sk_buff *vrf_ip_out_direc
  	if (likely(err == 1))
  		err = vrf_output_direct(net, sk, skb);
  
- 	/* reset skb device */
  	if (likely(err == 1))
++<<<<<<< HEAD
 +		nf_reset(skb);
 +	else
 +		skb = NULL;
++=======
+ 		return skb;
++>>>>>>> 9e2b7fa2df43 (vrf: Fix fast path output packet handling with async Netfilter rules)
  
- 	return skb;
+ 	return NULL;
  }
  
  static struct sk_buff *vrf_ip_out(struct net_device *vrf_dev,
* Unmerged path drivers/net/vrf.c
