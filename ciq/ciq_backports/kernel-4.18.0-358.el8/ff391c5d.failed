net: bridge: mcast: prepare mdb netlink for mcast router split

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Linus Lüssing <linus.luessing@c0d3.blue>
commit ff391c5d9871894c620f1e6ae2b18d7db572e49d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/ff391c5d.failed

In preparation for the upcoming split of multicast router state into
their IPv4 and IPv6 variants and to avoid IPv6 #ifdef clutter later add
some inline functions for the protocol specific parts in the mdb router
netlink code. Also the we need iterate over the port instead of router
list to be able put one router port entry with both the IPv4 and IPv6
multicast router info later.

	Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ff391c5d9871894c620f1e6ae2b18d7db572e49d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_mdb.c
diff --cc net/bridge/br_mdb.c
index 40754c5e5bdc,482edb9aadc7..000000000000
--- a/net/bridge/br_mdb.c
+++ b/net/bridge/br_mdb.c
@@@ -20,25 -39,35 +39,48 @@@ static int br_rports_fill_info(struct s
  			       struct net_device *dev)
  {
  	struct net_bridge *br = netdev_priv(dev);
- 	struct net_bridge_port *p;
+ 	bool have_ip4_mc_rtr, have_ip6_mc_rtr;
+ 	unsigned long ip4_timer, ip6_timer;
  	struct nlattr *nest, *port_nest;
+ 	struct net_bridge_port *p;
  
++<<<<<<< HEAD
 +	if (!br->multicast_router || hlist_empty(&br->router_list))
++=======
+ 	if (!br->multicast_router)
+ 		return 0;
+ 
+ 	if (!br_rports_have_mc_router(br))
++>>>>>>> ff391c5d9871 (net: bridge: mcast: prepare mdb netlink for mcast router split)
  		return 0;
  
  	nest = nla_nest_start_noflag(skb, MDBA_ROUTER);
  	if (nest == NULL)
  		return -EMSGSIZE;
  
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(p, &br->router_list, rlist) {
 +		if (!p)
++=======
+ 	list_for_each_entry_rcu(p, &br->port_list, list) {
+ 		have_ip4_mc_rtr = br_ip4_rports_get_timer(p, &ip4_timer);
+ 		have_ip6_mc_rtr = br_ip6_rports_get_timer(p, &ip6_timer);
+ 
+ 		if (!have_ip4_mc_rtr && !have_ip6_mc_rtr)
++>>>>>>> ff391c5d9871 (net: bridge: mcast: prepare mdb netlink for mcast router split)
  			continue;
+ 
  		port_nest = nla_nest_start_noflag(skb, MDBA_ROUTER_PORT);
  		if (!port_nest)
  			goto fail;
+ 
  		if (nla_put_nohdr(skb, sizeof(u32), &p->dev->ifindex) ||
  		    nla_put_u32(skb, MDBA_ROUTER_PATTR_TIMER,
++<<<<<<< HEAD
 +				br_timer_value(&p->multicast_router_timer)) ||
++=======
+ 				max(ip4_timer, ip6_timer)) ||
++>>>>>>> ff391c5d9871 (net: bridge: mcast: prepare mdb netlink for mcast router split)
  		    nla_put_u8(skb, MDBA_ROUTER_PATTR_TYPE,
  			       p->multicast_router)) {
  			nla_nest_cancel(skb, port_nest);
* Unmerged path net/bridge/br_mdb.c
