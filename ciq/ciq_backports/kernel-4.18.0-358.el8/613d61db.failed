net: bridge: vlan: add global and per-port multicast context

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 613d61dbef8eb87aea0be71efc9289beea1a6106
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/613d61db.failed

Add global and per-port vlan multicast context, only initialized but
still not used. No functional changes intended.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 613d61dbef8eb87aea0be71efc9289beea1a6106)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
#	net/bridge/br_private.h
diff --cc net/bridge/br_multicast.c
index def6f1840985,6f803f789217..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -66,6 -70,27 +66,30 @@@ static void br_ip6_multicast_leave_grou
  					 const struct in6_addr *group,
  					 __u16 vid, const unsigned char *src);
  #endif
++<<<<<<< HEAD
++=======
+ static struct net_bridge_port_group *
+ __br_multicast_add_group(struct net_bridge_mcast *brmctx,
+ 			 struct net_bridge_mcast_port *pmctx,
+ 			 struct br_ip *group,
+ 			 const unsigned char *src,
+ 			 u8 filter_mode,
+ 			 bool igmpv2_mldv1,
+ 			 bool blocked);
+ static void br_multicast_find_del_pg(struct net_bridge *br,
+ 				     struct net_bridge_port_group *pg);
+ static void __br_multicast_stop(struct net_bridge_mcast *brmctx);
+ 
+ static struct net_bridge_port_group *
+ br_sg_port_find(struct net_bridge *br,
+ 		struct net_bridge_port_group_sg_key *sg_p)
+ {
+ 	lockdep_assert_held_once(&br->multicast_lock);
+ 
+ 	return rhashtable_lookup_fast(&br->sg_port_tbl, sg_p,
+ 				      br_sg_port_rht_params);
+ }
++>>>>>>> 613d61dbef8e (net: bridge: vlan: add global and per-port multicast context)
  
  static struct net_bridge_mdb_entry *br_mdb_ip_get_rcu(struct net_bridge *br,
  						      struct br_ip *dst)
@@@ -1195,23 -1694,49 +1219,66 @@@ static void br_mc_disabled_update(struc
  		.u.mc_disabled = !value,
  	};
  
++<<<<<<< HEAD
 +	switchdev_port_attr_set(dev, &attr);
++=======
+ 	return switchdev_port_attr_set(dev, &attr, extack);
+ }
+ 
+ void br_multicast_port_ctx_init(struct net_bridge_port *port,
+ 				struct net_bridge_vlan *vlan,
+ 				struct net_bridge_mcast_port *pmctx)
+ {
+ 	pmctx->port = port;
+ 	pmctx->vlan = vlan;
+ 	pmctx->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
+ 	timer_setup(&pmctx->ip4_mc_router_timer,
+ 		    br_ip4_multicast_router_expired, 0);
+ 	timer_setup(&pmctx->ip4_own_query.timer,
+ 		    br_ip4_multicast_port_query_expired, 0);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	timer_setup(&pmctx->ip6_mc_router_timer,
+ 		    br_ip6_multicast_router_expired, 0);
+ 	timer_setup(&pmctx->ip6_own_query.timer,
+ 		    br_ip6_multicast_port_query_expired, 0);
+ #endif
+ }
+ 
+ void br_multicast_port_ctx_deinit(struct net_bridge_mcast_port *pmctx)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	del_timer_sync(&pmctx->ip6_mc_router_timer);
+ #endif
+ 	del_timer_sync(&pmctx->ip4_mc_router_timer);
++>>>>>>> 613d61dbef8e (net: bridge: vlan: add global and per-port multicast context)
  }
  
  int br_multicast_add_port(struct net_bridge_port *port)
  {
 -	int err;
 +	port->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
  
++<<<<<<< HEAD
 +	timer_setup(&port->multicast_router_timer,
 +		    br_multicast_router_expired, 0);
 +	timer_setup(&port->ip4_own_query.timer,
 +		    br_ip4_multicast_port_query_expired, 0);
 +#if IS_ENABLED(CONFIG_IPV6)
 +	timer_setup(&port->ip6_own_query.timer,
 +		    br_ip6_multicast_port_query_expired, 0);
 +#endif
 +	br_mc_disabled_update(port->dev,
 +			      br_opt_get(port->br, BROPT_MULTICAST_ENABLED));
++=======
+ 	port->multicast_eht_hosts_limit = BR_MCAST_DEFAULT_EHT_HOSTS_LIMIT;
+ 	br_multicast_port_ctx_init(port, NULL, &port->multicast_ctx);
+ 
+ 	err = br_mc_disabled_update(port->dev,
+ 				    br_opt_get(port->br,
+ 					       BROPT_MULTICAST_ENABLED),
+ 				    NULL);
+ 	if (err && err != -EOPNOTSUPP)
+ 		return err;
++>>>>>>> 613d61dbef8e (net: bridge: vlan: add global and per-port multicast context)
  
  	port->mcast_stats = netdev_alloc_pcpu_stats(struct bridge_mcast_stats);
  	if (!port->mcast_stats)
@@@ -2798,41 -3625,12 +2912,49 @@@ void br_multicast_init(struct net_bridg
  {
  	br->hash_max = BR_MULTICAST_DEFAULT_HASH_MAX;
  
++<<<<<<< HEAD
 +	br->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
 +	br->multicast_last_member_count = 2;
 +	br->multicast_startup_query_count = 2;
 +
 +	br->multicast_last_member_interval = HZ;
 +	br->multicast_query_response_interval = 10 * HZ;
 +	br->multicast_startup_query_interval = 125 * HZ / 4;
 +	br->multicast_query_interval = 125 * HZ;
 +	br->multicast_querier_interval = 255 * HZ;
 +	br->multicast_membership_interval = 260 * HZ;
 +
 +	br->ip4_other_query.delay_time = 0;
 +	br->ip4_querier.port = NULL;
 +	br->multicast_igmp_version = 2;
 +#if IS_ENABLED(CONFIG_IPV6)
 +	br->multicast_mld_version = 1;
 +	br->ip6_other_query.delay_time = 0;
 +	br->ip6_querier.port = NULL;
 +#endif
++=======
+ 	br_multicast_ctx_init(br, NULL, &br->multicast_ctx);
+ 
++>>>>>>> 613d61dbef8e (net: bridge: vlan: add global and per-port multicast context)
  	br_opt_toggle(br, BROPT_MULTICAST_ENABLED, true);
  	br_opt_toggle(br, BROPT_HAS_IPV6_ADDR, true);
  
  	spin_lock_init(&br->multicast_lock);
++<<<<<<< HEAD
 +	timer_setup(&br->multicast_router_timer,
 +		    br_multicast_local_router_expired, 0);
 +	timer_setup(&br->ip4_other_query.timer,
 +		    br_ip4_multicast_querier_expired, 0);
 +	timer_setup(&br->ip4_own_query.timer,
 +		    br_ip4_multicast_query_expired, 0);
 +#if IS_ENABLED(CONFIG_IPV6)
 +	timer_setup(&br->ip6_other_query.timer,
 +		    br_ip6_multicast_querier_expired, 0);
 +	timer_setup(&br->ip6_own_query.timer,
 +		    br_ip6_multicast_query_expired, 0);
 +#endif
++=======
++>>>>>>> 613d61dbef8e (net: bridge: vlan: add global and per-port multicast context)
  	INIT_HLIST_HEAD(&br->mdb_list);
  	INIT_HLIST_HEAD(&br->mcast_gc_list);
  	INIT_WORK(&br->mcast_gc_work, br_multicast_gc_work);
@@@ -2919,15 -3717,21 +3041,31 @@@ void br_multicast_open(struct net_bridg
  #endif
  }
  
+ static void __br_multicast_stop(struct net_bridge_mcast *brmctx)
+ {
+ 	del_timer_sync(&brmctx->ip4_mc_router_timer);
+ 	del_timer_sync(&brmctx->ip4_other_query.timer);
+ 	del_timer_sync(&brmctx->ip4_own_query.timer);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	del_timer_sync(&brmctx->ip6_mc_router_timer);
+ 	del_timer_sync(&brmctx->ip6_other_query.timer);
+ 	del_timer_sync(&brmctx->ip6_own_query.timer);
+ #endif
+ }
+ 
  void br_multicast_stop(struct net_bridge *br)
  {
++<<<<<<< HEAD
 +	del_timer_sync(&br->multicast_router_timer);
 +	del_timer_sync(&br->ip4_other_query.timer);
 +	del_timer_sync(&br->ip4_own_query.timer);
 +#if IS_ENABLED(CONFIG_IPV6)
 +	del_timer_sync(&br->ip6_other_query.timer);
 +	del_timer_sync(&br->ip6_own_query.timer);
 +#endif
++=======
+ 	__br_multicast_stop(&br->multicast_ctx);
++>>>>>>> 613d61dbef8e (net: bridge: vlan: add global and per-port multicast context)
  }
  
  void br_multicast_dev_del(struct net_bridge *br)
diff --cc net/bridge/br_private.h
index e7ccf58bc2f4,5762e5e86d6c..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -91,6 -89,59 +91,62 @@@ struct bridge_mcast_stats 
  };
  #endif
  
++<<<<<<< HEAD
++=======
+ /* net_bridge_mcast_port must be always defined due to forwarding stubs */
+ struct net_bridge_mcast_port {
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	struct net_bridge_port		*port;
+ 	struct net_bridge_vlan		*vlan;
+ 
+ 	struct bridge_mcast_own_query	ip4_own_query;
+ 	struct timer_list		ip4_mc_router_timer;
+ 	struct hlist_node		ip4_rlist;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	struct bridge_mcast_own_query	ip6_own_query;
+ 	struct timer_list		ip6_mc_router_timer;
+ 	struct hlist_node		ip6_rlist;
+ #endif /* IS_ENABLED(CONFIG_IPV6) */
+ 	unsigned char			multicast_router;
+ #endif /* CONFIG_BRIDGE_IGMP_SNOOPING */
+ };
+ 
+ /* net_bridge_mcast must be always defined due to forwarding stubs */
+ struct net_bridge_mcast {
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	struct net_bridge		*br;
+ 	struct net_bridge_vlan		*vlan;
+ 
+ 	u32				multicast_last_member_count;
+ 	u32				multicast_startup_query_count;
+ 
+ 	u8				multicast_igmp_version;
+ 	u8				multicast_router;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	u8				multicast_mld_version;
+ #endif
+ 	unsigned long			multicast_last_member_interval;
+ 	unsigned long			multicast_membership_interval;
+ 	unsigned long			multicast_querier_interval;
+ 	unsigned long			multicast_query_interval;
+ 	unsigned long			multicast_query_response_interval;
+ 	unsigned long			multicast_startup_query_interval;
+ 	struct hlist_head		ip4_mc_router_list;
+ 	struct timer_list		ip4_mc_router_timer;
+ 	struct bridge_mcast_other_query	ip4_other_query;
+ 	struct bridge_mcast_own_query	ip4_own_query;
+ 	struct bridge_mcast_querier	ip4_querier;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	struct hlist_head		ip6_mc_router_list;
+ 	struct timer_list		ip6_mc_router_timer;
+ 	struct bridge_mcast_other_query	ip6_other_query;
+ 	struct bridge_mcast_own_query	ip6_own_query;
+ 	struct bridge_mcast_querier	ip6_querier;
+ #endif /* IS_ENABLED(CONFIG_IPV6) */
+ #endif /* CONFIG_BRIDGE_IGMP_SNOOPING */
+ };
+ 
++>>>>>>> 613d61dbef8e (net: bridge: vlan: add global and per-port multicast context)
  struct br_tunnel_info {
  	__be64				tunnel_id;
  	struct metadata_dst __rcu	*tunnel_dst;
@@@ -754,6 -885,27 +818,30 @@@ void br_mdb_init(void)
  void br_mdb_uninit(void);
  void br_multicast_host_join(struct net_bridge_mdb_entry *mp, bool notify);
  void br_multicast_host_leave(struct net_bridge_mdb_entry *mp, bool notify);
++<<<<<<< HEAD
++=======
+ void br_multicast_star_g_handle_mode(struct net_bridge_port_group *pg,
+ 				     u8 filter_mode);
+ void br_multicast_sg_add_exclude_ports(struct net_bridge_mdb_entry *star_mp,
+ 				       struct net_bridge_port_group *sg);
+ struct net_bridge_group_src *
+ br_multicast_find_group_src(struct net_bridge_port_group *pg, struct br_ip *ip);
+ void br_multicast_del_group_src(struct net_bridge_group_src *src,
+ 				bool fastleave);
+ void br_multicast_ctx_init(struct net_bridge *br,
+ 			   struct net_bridge_vlan *vlan,
+ 			   struct net_bridge_mcast *brmctx);
+ void br_multicast_ctx_deinit(struct net_bridge_mcast *brmctx);
+ void br_multicast_port_ctx_init(struct net_bridge_port *port,
+ 				struct net_bridge_vlan *vlan,
+ 				struct net_bridge_mcast_port *pmctx);
+ void br_multicast_port_ctx_deinit(struct net_bridge_mcast_port *pmctx);
+ 
+ static inline bool br_group_is_l2(const struct br_ip *group)
+ {
+ 	return group->proto == 0;
+ }
++>>>>>>> 613d61dbef8e (net: bridge: vlan: add global and per-port multicast context)
  
  #define mlock_dereference(X, br) \
  	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_private.h
diff --git a/net/bridge/br_vlan.c b/net/bridge/br_vlan.c
index ec7de6e6d9e9..5f01ff0fef65 100644
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@ -190,6 +190,7 @@ static void br_vlan_put_master(struct net_bridge_vlan *masterv)
 		rhashtable_remove_fast(&vg->vlan_hash,
 				       &masterv->vnode, br_vlan_rht_params);
 		__vlan_del_list(masterv);
+		br_multicast_ctx_deinit(&masterv->br_mcast_ctx);
 		call_rcu(&masterv->rcu, br_master_vlan_rcu_free);
 	}
 }
@@ -276,10 +277,12 @@ static int __vlan_add(struct net_bridge_vlan *v, u16 flags,
 		} else {
 			v->stats = masterv->stats;
 		}
+		br_multicast_port_ctx_init(p, v, &v->port_mcast_ctx);
 	} else {
 		err = br_switchdev_port_vlan_add(dev, v->vid, flags, extack);
 		if (err && err != -EOPNOTSUPP)
 			goto out;
+		br_multicast_ctx_init(br, v, &v->br_mcast_ctx);
 	}
 
 	/* Add the dev mac and count the vlan only if it's usable */
@@ -370,6 +373,7 @@ static int __vlan_del(struct net_bridge_vlan *v)
 				       br_vlan_rht_params);
 		__vlan_del_list(v);
 		nbp_vlan_set_vlan_dev_state(p, v->vid);
+		br_multicast_port_ctx_deinit(&v->port_mcast_ctx);
 		call_rcu(&v->rcu, nbp_vlan_rcu_free);
 	}
 
