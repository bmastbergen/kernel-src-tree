arch/kmap_atomic: consolidate duplicate code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Ira Weiny <ira.weiny@intel.com>
commit 78b6d91ec7bbfc5bcc2dd05bb2cf13c9de1dc7cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/78b6d91e.failed

Every arch has the same code to ensure atomic operations and a check for
!HIGHMEM page.

Remove the duplicate code by defining a core kmap_atomic() which only
calls the arch specific kmap_atomic_high() when the page is high memory.

[akpm@linux-foundation.org: coding style fixes]
	Signed-off-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Christian KÃ¶nig <christian.koenig@amd.com>
	Cc: Chris Zankel <chris@zankel.net>
	Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Helge Deller <deller@gmx.de>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: "James E.J. Bottomley" <James.Bottomley@HansenPartnership.com>
	Cc: Max Filippov <jcmvbkbc@gmail.com>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/20200507150004.1423069-7-ira.weiny@intel.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 78b6d91ec7bbfc5bcc2dd05bb2cf13c9de1dc7cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arc/include/asm/highmem.h
#	arch/arc/mm/highmem.c
#	arch/arm/include/asm/highmem.h
#	arch/arm/mm/highmem.c
#	arch/csky/include/asm/highmem.h
#	arch/csky/mm/highmem.c
#	arch/mips/include/asm/highmem.h
#	arch/nds32/include/asm/highmem.h
#	arch/nds32/mm/highmem.c
#	arch/powerpc/mm/highmem.c
#	arch/sparc/include/asm/highmem.h
#	arch/x86/include/asm/highmem.h
#	arch/x86/mm/highmem_32.c
#	include/linux/highmem.h
diff --cc arch/arc/include/asm/highmem.h
index b1585c96324a,db425cd38545..000000000000
--- a/arch/arc/include/asm/highmem.h
+++ b/arch/arc/include/asm/highmem.h
@@@ -34,11 -30,7 +34,14 @@@
  
  #include <asm/cacheflush.h>
  
++<<<<<<< HEAD
 +extern void *kmap(struct page *page);
 +extern void *kmap_high(struct page *page);
 +extern void *kmap_atomic(struct page *page);
++=======
++>>>>>>> 78b6d91ec7bb (arch/kmap_atomic: consolidate duplicate code)
  extern void __kunmap_atomic(void *kvaddr);
 +extern void kunmap_high(struct page *page);
  
  extern void kmap_init(void);
  
diff --cc arch/arc/mm/highmem.c
index 48e700151810,0964b011c29f..000000000000
--- a/arch/arc/mm/highmem.c
+++ b/arch/arc/mm/highmem.c
@@@ -53,17 -49,7 +53,21 @@@
  extern pte_t * pkmap_page_table;
  static pte_t * fixmap_page_table;
  
++<<<<<<< HEAD
 +void *kmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +
 +	return kmap_high(page);
 +}
 +EXPORT_SYMBOL(kmap);
 +
 +void *kmap_atomic(struct page *page)
++=======
+ void *kmap_atomic_high(struct page *page)
++>>>>>>> 78b6d91ec7bb (arch/kmap_atomic: consolidate duplicate code)
  {
  	int idx, cpu_idx;
  	unsigned long vaddr;
diff --cc arch/arm/include/asm/highmem.h
index eb4e4207cd3c,8c80bfe18a34..000000000000
--- a/arch/arm/include/asm/highmem.h
+++ b/arch/arm/include/asm/highmem.h
@@@ -63,9 -60,6 +63,12 @@@ static inline void *kmap_high_get(struc
   * when CONFIG_HIGHMEM is not set.
   */
  #ifdef CONFIG_HIGHMEM
++<<<<<<< HEAD
 +extern void *kmap(struct page *page);
 +extern void kunmap(struct page *page);
 +extern void *kmap_atomic(struct page *page);
++=======
++>>>>>>> 78b6d91ec7bb (arch/kmap_atomic: consolidate duplicate code)
  extern void __kunmap_atomic(void *kvaddr);
  extern void *kmap_atomic_pfn(unsigned long pfn);
  #endif
diff --cc arch/arm/mm/highmem.c
index d02f8187b1cc,075fdc235091..000000000000
--- a/arch/arm/mm/highmem.c
+++ b/arch/arm/mm/highmem.c
@@@ -34,25 -31,7 +34,29 @@@ static inline pte_t get_fixmap_pte(unsi
  	return *ptep;
  }
  
++<<<<<<< HEAD
 +void *kmap(struct page *page)
 +{
 +	might_sleep();
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	return kmap_high(page);
 +}
 +EXPORT_SYMBOL(kmap);
 +
 +void kunmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +EXPORT_SYMBOL(kunmap);
 +
 +void *kmap_atomic(struct page *page)
++=======
+ void *kmap_atomic_high(struct page *page)
++>>>>>>> 78b6d91ec7bb (arch/kmap_atomic: consolidate duplicate code)
  {
  	unsigned int idx;
  	unsigned long vaddr;
diff --cc arch/mips/include/asm/highmem.h
index 9d84aafc33d0,8bdbbfc322ad..000000000000
--- a/arch/mips/include/asm/highmem.h
+++ b/arch/mips/include/asm/highmem.h
@@@ -46,12 -46,8 +46,17 @@@ extern pte_t *pkmap_page_table
  #define PKMAP_NR(virt)	((virt-PKMAP_BASE) >> PAGE_SHIFT)
  #define PKMAP_ADDR(nr)	(PKMAP_BASE + ((nr) << PAGE_SHIFT))
  
++<<<<<<< HEAD
 +extern void * kmap_high(struct page *page);
 +extern void kunmap_high(struct page *page);
 +
 +extern void *kmap(struct page *page);
 +extern void kunmap(struct page *page);
 +extern void *kmap_atomic(struct page *page);
++=======
+ #define ARCH_HAS_KMAP_FLUSH_TLB
+ extern void kmap_flush_tlb(unsigned long addr);
++>>>>>>> 78b6d91ec7bb (arch/kmap_atomic: consolidate duplicate code)
  extern void __kunmap_atomic(void *kvaddr);
  extern void *kmap_atomic_pfn(unsigned long pfn);
  
diff --cc arch/nds32/include/asm/highmem.h
index 425d546cb059,a3970e566ede..000000000000
--- a/arch/nds32/include/asm/highmem.h
+++ b/arch/nds32/include/asm/highmem.h
@@@ -54,9 -51,6 +54,12 @@@ extern void kmap_init(void)
   * when CONFIG_HIGHMEM is not set.
   */
  #ifdef CONFIG_HIGHMEM
++<<<<<<< HEAD
 +extern void *kmap(struct page *page);
 +extern void kunmap(struct page *page);
 +extern void *kmap_atomic(struct page *page);
++=======
++>>>>>>> 78b6d91ec7bb (arch/kmap_atomic: consolidate duplicate code)
  extern void __kunmap_atomic(void *kvaddr);
  extern void *kmap_atomic_pfn(unsigned long pfn);
  extern struct page *kmap_atomic_to_page(void *ptr);
diff --cc arch/nds32/mm/highmem.c
index 022779af6148,d4387d835870..000000000000
--- a/arch/nds32/mm/highmem.c
+++ b/arch/nds32/mm/highmem.c
@@@ -10,29 -10,7 +10,33 @@@
  #include <asm/fixmap.h>
  #include <asm/tlbflush.h>
  
++<<<<<<< HEAD
 +void *kmap(struct page *page)
 +{
 +	unsigned long vaddr;
 +	might_sleep();
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	vaddr = (unsigned long)kmap_high(page);
 +	return (void *)vaddr;
 +}
 +
 +EXPORT_SYMBOL(kmap);
 +
 +void kunmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +
 +EXPORT_SYMBOL(kunmap);
 +
 +void *kmap_atomic(struct page *page)
++=======
+ void *kmap_atomic_high(struct page *page)
++>>>>>>> 78b6d91ec7bb (arch/kmap_atomic: consolidate duplicate code)
  {
  	unsigned int idx;
  	unsigned long vaddr, pte;
diff --cc arch/powerpc/mm/highmem.c
index 668e87d03f9e,67aaa5217f7f..000000000000
--- a/arch/powerpc/mm/highmem.c
+++ b/arch/powerpc/mm/highmem.c
@@@ -24,13 -24,7 +24,17 @@@
  #include <linux/highmem.h>
  #include <linux/module.h>
  
++<<<<<<< HEAD
 +/*
 + * The use of kmap_atomic/kunmap_atomic is discouraged - kmap/kunmap
 + * gives a more generic (and caching) interface. But kmap_atomic can
 + * be used in IRQ contexts, so in some (very limited) cases we need
 + * it.
 + */
 +void *kmap_atomic_prot(struct page *page, pgprot_t prot)
++=======
+ void *kmap_atomic_high_prot(struct page *page, pgprot_t prot)
++>>>>>>> 78b6d91ec7bb (arch/kmap_atomic: consolidate duplicate code)
  {
  	unsigned long vaddr;
  	int idx, type;
diff --cc arch/sparc/include/asm/highmem.h
index 18d776925c45,458210c5bc38..000000000000
--- a/arch/sparc/include/asm/highmem.h
+++ b/arch/sparc/include/asm/highmem.h
@@@ -50,26 -50,6 +50,29 @@@ void kmap_init(void) __init
  
  #define PKMAP_END (PKMAP_ADDR(LAST_PKMAP))
  
++<<<<<<< HEAD
 +void *kmap_high(struct page *page);
 +void kunmap_high(struct page *page);
 +
 +static inline void *kmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	return kmap_high(page);
 +}
 +
 +static inline void kunmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +
 +void *kmap_atomic(struct page *page);
++=======
++>>>>>>> 78b6d91ec7bb (arch/kmap_atomic: consolidate duplicate code)
  void __kunmap_atomic(void *kvaddr);
  
  #define flush_cache_kmaps()	flush_cache_all()
diff --cc arch/x86/include/asm/highmem.h
index a8059930056d,9393d55a2adb..000000000000
--- a/arch/x86/include/asm/highmem.h
+++ b/arch/x86/include/asm/highmem.h
@@@ -58,14 -58,20 +58,23 @@@ extern unsigned long highstart_pfn, hig
  #define PKMAP_NR(virt)  ((virt-PKMAP_BASE) >> PAGE_SHIFT)
  #define PKMAP_ADDR(nr)  (PKMAP_BASE + ((nr) << PAGE_SHIFT))
  
 -extern void *kmap_atomic_high_prot(struct page *page, pgprot_t prot);
 -static inline void *kmap_atomic_prot(struct page *page, pgprot_t prot)
 -{
 -	preempt_disable();
 -	pagefault_disable();
 -	if (!PageHighMem(page))
 -		return page_address(page);
 +extern void *kmap_high(struct page *page);
 +extern void kunmap_high(struct page *page);
 +
++<<<<<<< HEAD
 +void *kmap(struct page *page);
 +void kunmap(struct page *page);
  
 +void *kmap_atomic_prot(struct page *page, pgprot_t prot);
 +void *kmap_atomic(struct page *page);
++=======
+ 	return kmap_atomic_high_prot(page, prot);
+ }
+ static inline void *kmap_atomic_high(struct page *page)
+ {
+ 	return kmap_atomic_high_prot(page, kmap_prot);
+ }
++>>>>>>> 78b6d91ec7bb (arch/kmap_atomic: consolidate duplicate code)
  void __kunmap_atomic(void *kvaddr);
  void *kmap_atomic_pfn(unsigned long pfn);
  void *kmap_atomic_prot_pfn(unsigned long pfn, pgprot_t prot);
diff --cc arch/x86/mm/highmem_32.c
index 0d4bdcb84da5,c3e272a759e0..000000000000
--- a/arch/x86/mm/highmem_32.c
+++ b/arch/x86/mm/highmem_32.c
@@@ -3,34 -4,7 +3,38 @@@
  #include <linux/swap.h> /* for totalram_pages */
  #include <linux/memblock.h>
  
++<<<<<<< HEAD
 +void *kmap(struct page *page)
 +{
 +	might_sleep();
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	return kmap_high(page);
 +}
 +EXPORT_SYMBOL(kmap);
 +
 +void kunmap(struct page *page)
 +{
 +	if (in_interrupt())
 +		BUG();
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +EXPORT_SYMBOL(kunmap);
 +
 +/*
 + * kmap_atomic/kunmap_atomic is significantly faster than kmap/kunmap because
 + * no global lock is needed and because the kmap code must perform a global TLB
 + * invalidation when the kmap pool wraps.
 + *
 + * However when holding an atomic kmap it is not legal to sleep, so atomic
 + * kmaps are appropriate for short, tight code paths only.
 + */
 +void *kmap_atomic_prot(struct page *page, pgprot_t prot)
++=======
+ void *kmap_atomic_high_prot(struct page *page, pgprot_t prot)
++>>>>>>> 78b6d91ec7bb (arch/kmap_atomic: consolidate duplicate code)
  {
  	unsigned long vaddr;
  	int idx, type;
@@@ -50,14 -18,8 +54,8 @@@
  
  	return (void *)vaddr;
  }
 -EXPORT_SYMBOL(kmap_atomic_high_prot);
 +EXPORT_SYMBOL(kmap_atomic_prot);
  
- void *kmap_atomic(struct page *page)
- {
- 	return kmap_atomic_prot(page, kmap_prot);
- }
- EXPORT_SYMBOL(kmap_atomic);
- 
  /*
   * This is the same as kmap_atomic() but can map memory that doesn't
   * have a struct page associated with it.
diff --cc include/linux/highmem.h
index ea5cdbd8c2c3,d2209ae8be99..000000000000
--- a/include/linux/highmem.h
+++ b/include/linux/highmem.h
@@@ -32,8 -32,59 +32,62 @@@ static inline void invalidate_kernel_vm
  #include <asm/kmap_types.h>
  
  #ifdef CONFIG_HIGHMEM
+ extern void *kmap_atomic_high(struct page *page);
  #include <asm/highmem.h>
  
++<<<<<<< HEAD
++=======
+ #ifndef ARCH_HAS_KMAP_FLUSH_TLB
+ static inline void kmap_flush_tlb(unsigned long addr) { }
+ #endif
+ 
+ void *kmap_high(struct page *page);
+ static inline void *kmap(struct page *page)
+ {
+ 	void *addr;
+ 
+ 	might_sleep();
+ 	if (!PageHighMem(page))
+ 		addr = page_address(page);
+ 	else
+ 		addr = kmap_high(page);
+ 	kmap_flush_tlb((unsigned long)addr);
+ 	return addr;
+ }
+ 
+ void kunmap_high(struct page *page);
+ 
+ static inline void kunmap(struct page *page)
+ {
+ 	might_sleep();
+ 	if (!PageHighMem(page))
+ 		return;
+ 	kunmap_high(page);
+ }
+ 
+ /*
+  * kmap_atomic/kunmap_atomic is significantly faster than kmap/kunmap because
+  * no global lock is needed and because the kmap code must perform a global TLB
+  * invalidation when the kmap pool wraps.
+  *
+  * However when holding an atomic kmap is is not legal to sleep, so atomic
+  * kmaps are appropriate for short, tight code paths only.
+  *
+  * The use of kmap_atomic/kunmap_atomic is discouraged - kmap/kunmap
+  * gives a more generic (and caching) interface. But kmap_atomic can
+  * be used in IRQ contexts, so in some (very limited) cases we need
+  * it.
+  */
+ static inline void *kmap_atomic(struct page *page)
+ {
+ 	preempt_disable();
+ 	pagefault_disable();
+ 	if (!PageHighMem(page))
+ 		return page_address(page);
+ 	return kmap_atomic_high(page);
+ }
+ 
++>>>>>>> 78b6d91ec7bb (arch/kmap_atomic: consolidate duplicate code)
  /* declarations for linux/mm/highmem.c */
  unsigned int nr_free_highpages(void);
  extern atomic_long_t _totalhigh_pages;
* Unmerged path arch/csky/include/asm/highmem.h
* Unmerged path arch/csky/mm/highmem.c
* Unmerged path arch/arc/include/asm/highmem.h
* Unmerged path arch/arc/mm/highmem.c
* Unmerged path arch/arm/include/asm/highmem.h
* Unmerged path arch/arm/mm/highmem.c
* Unmerged path arch/csky/include/asm/highmem.h
* Unmerged path arch/csky/mm/highmem.c
diff --git a/arch/microblaze/include/asm/highmem.h b/arch/microblaze/include/asm/highmem.h
index 332c78e15198..11f988c0b286 100644
--- a/arch/microblaze/include/asm/highmem.h
+++ b/arch/microblaze/include/asm/highmem.h
@@ -72,9 +72,9 @@ static inline void kunmap(struct page *page)
 	kunmap_high(page);
 }
 
-static inline void *kmap_atomic(struct page *page)
+static inline void *kmap_atomic_high(struct page *page)
 {
-	return kmap_atomic_prot(page, kmap_prot);
+	return kmap_atomic_high_prot(page, kmap_prot);
 }
 
 #define flush_cache_kmaps()	{ flush_icache(); flush_dcache(); }
* Unmerged path arch/mips/include/asm/highmem.h
diff --git a/arch/mips/mm/cache.c b/arch/mips/mm/cache.c
index 84d6847a403b..a7c2e26f0286 100644
--- a/arch/mips/mm/cache.c
+++ b/arch/mips/mm/cache.c
@@ -14,9 +14,9 @@
 #include <linux/sched.h>
 #include <linux/syscalls.h>
 #include <linux/mm.h>
+#include <linux/highmem.h>
 
 #include <asm/cacheflush.h>
-#include <asm/highmem.h>
 #include <asm/processor.h>
 #include <asm/cpu.h>
 #include <asm/cpu-features.h>
diff --git a/arch/mips/mm/highmem.c b/arch/mips/mm/highmem.c
index d08e6d7d533b..afa5a0960f2c 100644
--- a/arch/mips/mm/highmem.c
+++ b/arch/mips/mm/highmem.c
@@ -35,25 +35,11 @@ void kunmap(struct page *page)
 }
 EXPORT_SYMBOL(kunmap);
 
-/*
- * kmap_atomic/kunmap_atomic is significantly faster than kmap/kunmap because
- * no global lock is needed and because the kmap code must perform a global TLB
- * invalidation when the kmap pool wraps.
- *
- * However when holding an atomic kmap is is not legal to sleep, so atomic
- * kmaps are appropriate for short, tight code paths only.
- */
-
-void *kmap_atomic(struct page *page)
+void *kmap_atomic_high(struct page *page)
 {
 	unsigned long vaddr;
 	int idx, type;
 
-	preempt_disable();
-	pagefault_disable();
-	if (!PageHighMem(page))
-		return page_address(page);
-
 	type = kmap_atomic_idx_push();
 	idx = type + KM_TYPE_NR*smp_processor_id();
 	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
@@ -65,7 +51,7 @@ void *kmap_atomic(struct page *page)
 
 	return (void*) vaddr;
 }
-EXPORT_SYMBOL(kmap_atomic);
+EXPORT_SYMBOL(kmap_atomic_high);
 
 void __kunmap_atomic(void *kvaddr)
 {
* Unmerged path arch/nds32/include/asm/highmem.h
* Unmerged path arch/nds32/mm/highmem.c
diff --git a/arch/powerpc/include/asm/highmem.h b/arch/powerpc/include/asm/highmem.h
index cec820f961da..b0c81ed7f833 100644
--- a/arch/powerpc/include/asm/highmem.h
+++ b/arch/powerpc/include/asm/highmem.h
@@ -80,9 +80,9 @@ static inline void kunmap(struct page *page)
 	kunmap_high(page);
 }
 
-static inline void *kmap_atomic(struct page *page)
+static inline void *kmap_atomic_high(struct page *page)
 {
-	return kmap_atomic_prot(page, kmap_prot);
+	return kmap_atomic_high_prot(page, kmap_prot);
 }
 
 
* Unmerged path arch/powerpc/mm/highmem.c
* Unmerged path arch/sparc/include/asm/highmem.h
diff --git a/arch/sparc/mm/highmem.c b/arch/sparc/mm/highmem.c
index 86bc2a58d26c..71830e6b1a2e 100644
--- a/arch/sparc/mm/highmem.c
+++ b/arch/sparc/mm/highmem.c
@@ -49,16 +49,11 @@ void __init kmap_init(void)
         kmap_prot = __pgprot(SRMMU_ET_PTE | SRMMU_PRIV | SRMMU_CACHE);
 }
 
-void *kmap_atomic(struct page *page)
+void *kmap_atomic_high(struct page *page)
 {
 	unsigned long vaddr;
 	long idx, type;
 
-	preempt_disable();
-	pagefault_disable();
-	if (!PageHighMem(page))
-		return page_address(page);
-
 	type = kmap_atomic_idx_push();
 	idx = type + KM_TYPE_NR*smp_processor_id();
 	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
@@ -83,7 +78,7 @@ void *kmap_atomic(struct page *page)
 
 	return (void*) vaddr;
 }
-EXPORT_SYMBOL(kmap_atomic);
+EXPORT_SYMBOL(kmap_atomic_high);
 
 void __kunmap_atomic(void *kvaddr)
 {
* Unmerged path arch/x86/include/asm/highmem.h
* Unmerged path arch/x86/mm/highmem_32.c
diff --git a/arch/xtensa/include/asm/highmem.h b/arch/xtensa/include/asm/highmem.h
index 04e9340eac4b..227706783457 100644
--- a/arch/xtensa/include/asm/highmem.h
+++ b/arch/xtensa/include/asm/highmem.h
@@ -92,7 +92,6 @@ static inline void flush_cache_kmaps(void)
 	flush_cache_all();
 }
 
-void *kmap_atomic(struct page *page);
 void __kunmap_atomic(void *kvaddr);
 
 void kmap_init(void);
diff --git a/arch/xtensa/mm/highmem.c b/arch/xtensa/mm/highmem.c
index 184ceadccc1a..f13a64ef09dd 100644
--- a/arch/xtensa/mm/highmem.c
+++ b/arch/xtensa/mm/highmem.c
@@ -37,16 +37,11 @@ static inline enum fixed_addresses kmap_idx(int type, unsigned long color)
 		color;
 }
 
-void *kmap_atomic(struct page *page)
+void *kmap_atomic_high(struct page *page)
 {
 	enum fixed_addresses idx;
 	unsigned long vaddr;
 
-	preempt_disable();
-	pagefault_disable();
-	if (!PageHighMem(page))
-		return page_address(page);
-
 	idx = kmap_idx(kmap_atomic_idx_push(),
 		       DCACHE_ALIAS(page_to_phys(page)));
 	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
@@ -57,7 +52,7 @@ void *kmap_atomic(struct page *page)
 
 	return (void *)vaddr;
 }
-EXPORT_SYMBOL(kmap_atomic);
+EXPORT_SYMBOL(kmap_atomic_high);
 
 void __kunmap_atomic(void *kvaddr)
 {
* Unmerged path include/linux/highmem.h
