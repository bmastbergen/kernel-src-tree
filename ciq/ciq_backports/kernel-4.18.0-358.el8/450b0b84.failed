selftests: net: lib: add support for IPv6 mcast packet test

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 450b0b84c6609e7ec1fb0276c8a7e4efa9e78a4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/450b0b84.failed

In order to test an IPv6 multicast packet we need to pass different tc
and mausezahn protocols only, so add a simple check for the destination
address which decides if we should generate an IPv4 or IPv6 mcast
packet.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 450b0b84c6609e7ec1fb0276c8a7e4efa9e78a4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/net/forwarding/lib.sh
diff --cc tools/testing/selftests/net/forwarding/lib.sh
index 3c2f1a1e2d6c,0a427b8a039d..000000000000
--- a/tools/testing/selftests/net/forwarding/lib.sh
+++ b/tools/testing/selftests/net/forwarding/lib.sh
@@@ -1305,3 -1227,86 +1305,89 @@@ stop_traffic(
  	# Suppress noise from killing mausezahn.
  	{ kill %% && wait %%; } 2>/dev/null
  }
++<<<<<<< HEAD
++=======
+ 
+ tcpdump_start()
+ {
+ 	local if_name=$1; shift
+ 	local ns=$1; shift
+ 
+ 	capfile=$(mktemp)
+ 	capout=$(mktemp)
+ 
+ 	if [ -z $ns ]; then
+ 		ns_cmd=""
+ 	else
+ 		ns_cmd="ip netns exec ${ns}"
+ 	fi
+ 
+ 	if [ -z $SUDO_USER ] ; then
+ 		capuser=""
+ 	else
+ 		capuser="-Z $SUDO_USER"
+ 	fi
+ 
+ 	$ns_cmd tcpdump -e -n -Q in -i $if_name \
+ 		-s 65535 -B 32768 $capuser -w $capfile > "$capout" 2>&1 &
+ 	cappid=$!
+ 
+ 	sleep 1
+ }
+ 
+ tcpdump_stop()
+ {
+ 	$ns_cmd kill $cappid
+ 	sleep 1
+ }
+ 
+ tcpdump_cleanup()
+ {
+ 	rm $capfile $capout
+ }
+ 
+ tcpdump_show()
+ {
+ 	tcpdump -e -n -r $capfile 2>&1
+ }
+ 
+ # return 0 if the packet wasn't seen on host2_if or 1 if it was
+ mcast_packet_test()
+ {
+ 	local mac=$1
+ 	local src_ip=$2
+ 	local ip=$3
+ 	local host1_if=$4
+ 	local host2_if=$5
+ 	local seen=0
+ 	local tc_proto="ip"
+ 	local mz_v6arg=""
+ 
+ 	# basic check to see if we were passed an IPv4 address, if not assume IPv6
+ 	if [[ ! $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
+ 		tc_proto="ipv6"
+ 		mz_v6arg="-6"
+ 	fi
+ 
+ 	# Add an ACL on `host2_if` which will tell us whether the packet
+ 	# was received by it or not.
+ 	tc qdisc add dev $host2_if ingress
+ 	tc filter add dev $host2_if ingress protocol $tc_proto pref 1 handle 101 \
+ 		flower ip_proto udp dst_mac $mac action drop
+ 
+ 	$MZ $host1_if $mz_v6arg -c 1 -p 64 -b $mac -A $src_ip -B $ip -t udp "dp=4096,sp=2048" -q
+ 	sleep 1
+ 
+ 	tc -j -s filter show dev $host2_if ingress \
+ 		| jq -e ".[] | select(.options.handle == 101) \
+ 		| select(.options.actions[0].stats.packets == 1)" &> /dev/null
+ 	if [[ $? -eq 0 ]]; then
+ 		seen=1
+ 	fi
+ 
+ 	tc filter del dev $host2_if ingress protocol $tc_proto pref 1 handle 101 flower
+ 	tc qdisc del dev $host2_if ingress
+ 
+ 	return $seen
+ }
++>>>>>>> 450b0b84c660 (selftests: net: lib: add support for IPv6 mcast packet test)
* Unmerged path tools/testing/selftests/net/forwarding/lib.sh
