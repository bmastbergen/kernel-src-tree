of: property: Update implementation of add_links() to create fwnode links

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Saravana Kannan <saravanak@google.com>
commit 8a06d1ea061739dd2e60aff3d64a58892e4031cf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/8a06d1ea.failed

The semantics of add_links() has changed from creating device link
between devices to creating fwnode links between fwnodes. So, update the
implementation of add_links() to match the new semantics.

	Acked-by: Rob Herring <robh@kernel.org>
	Signed-off-by: Saravana Kannan <saravanak@google.com>
Link: https://lore.kernel.org/r/20201121020232.908850-15-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 8a06d1ea061739dd2e60aff3d64a58892e4031cf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/of/property.c
diff --cc drivers/of/property.c
index 0d910c5d3517,620d29fdace8..000000000000
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@@ -1038,9 -1038,9 +1038,15 @@@ static bool of_is_ancestor_of(struct de
  }
  
  /**
++<<<<<<< HEAD
 + * of_link_to_phandle - Add device link to supplier from supplier phandle
 + * @dev: consumer device
 + * @sup_np: phandle to supplier device tree node
++=======
+  * of_link_to_phandle - Add fwnode link to supplier from supplier phandle
+  * @con_np: consumer device tree node
+  * @sup_np: supplier device tree node
++>>>>>>> 8a06d1ea0617 (of: property: Update implementation of add_links() to create fwnode links)
   *
   * Given a phandle to a supplier device tree node (@sup_np), this function
   * finds the device that owns the supplier device tree node and creates a
@@@ -1050,16 -1050,14 +1056,22 @@@
   * cases, it returns an error.
   *
   * Returns:
-  * - 0 if link successfully created to supplier
-  * - -EAGAIN if linking to the supplier should be reattempted
+  * - 0 if fwnode link successfully created to supplier
   * - -EINVAL if the supplier link is invalid and should not be created
-  * - -ENODEV if there is no device that corresponds to the supplier phandle
+  * - -ENODEV if struct device will never be create for supplier
   */
++<<<<<<< HEAD
 +static int of_link_to_phandle(struct device *dev, struct device_node *sup_np)
 +{
 +	struct device *sup_dev;
 +	u32 dl_flags = DL_FLAG_AUTOPROBE_CONSUMER;
 +	int ret = 0;
++=======
+ static int of_link_to_phandle(struct device_node *con_np,
+ 			      struct device_node *sup_np)
+ {
+ 	struct device *sup_dev;
++>>>>>>> 8a06d1ea0617 (of: property: Update implementation of add_links() to create fwnode links)
  	struct device_node *tmp_np = sup_np;
  
  	of_node_get(sup_np);
@@@ -1096,14 -1096,24 +1110,32 @@@
  		of_node_put(sup_np);
  		return -EINVAL;
  	}
+ 
+ 	/*
+ 	 * Don't create links to "early devices" that won't have struct devices
+ 	 * created for them.
+ 	 */
  	sup_dev = get_dev_from_fwnode(&sup_np->fwnode);
++<<<<<<< HEAD
 +	of_node_put(sup_np);
 +	if (!sup_dev)
 +		return -EAGAIN;
 +	if (!device_link_add(dev, sup_dev, dl_flags))
 +		ret = -EAGAIN;
++=======
+ 	if (!sup_dev && of_node_check_flag(sup_np, OF_POPULATED)) {
+ 		pr_debug("Not linking %pOFP to %pOFP - No struct device\n",
+ 			 con_np, sup_np);
+ 		of_node_put(sup_np);
+ 		return -ENODEV;
+ 	}
++>>>>>>> 8a06d1ea0617 (of: property: Update implementation of add_links() to create fwnode links)
  	put_device(sup_dev);
- 	return ret;
+ 
+ 	fwnode_link_add(of_fwnode_handle(con_np), of_fwnode_handle(sup_np));
+ 	of_node_put(sup_np);
+ 
+ 	return 0;
  }
  
  /**
@@@ -1325,8 -1335,7 +1357,12 @@@ static int of_link_property(struct devi
  		while ((phandle = s->parse_prop(con_np, prop_name, i))) {
  			matched = true;
  			i++;
++<<<<<<< HEAD
 +			if (of_link_to_phandle(dev, phandle) == -EAGAIN)
 +				ret = -EAGAIN;
++=======
+ 			of_link_to_phandle(con_np, phandle);
++>>>>>>> 8a06d1ea0617 (of: property: Update implementation of add_links() to create fwnode links)
  			of_node_put(phandle);
  		}
  		s++;
@@@ -1334,31 -1343,19 +1370,41 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int of_link_to_suppliers(struct device *dev,
 +				  struct device_node *con_np)
 +{
 +	struct device_node *child;
 +	struct property *p;
 +	int ret = 0;
 +
 +	for_each_property_of_node(con_np, p)
 +		if (of_link_property(dev, con_np, p->name))
 +			ret = -EAGAIN;
 +
 +	for_each_available_child_of_node(con_np, child)
 +		if (of_link_to_suppliers(dev, child))
 +			ret = -EAGAIN;
 +
 +	return ret;
 +}
 +
 +static int of_fwnode_add_links(const struct fwnode_handle *fwnode,
++=======
+ static int of_fwnode_add_links(struct fwnode_handle *fwnode,
++>>>>>>> 8a06d1ea0617 (of: property: Update implementation of add_links() to create fwnode links)
  			       struct device *dev)
  {
- 	if (unlikely(!is_of_node(fwnode)))
- 		return 0;
+ 	struct property *p;
+ 	struct device_node *con_np = to_of_node(fwnode);
  
- 	return of_link_to_suppliers(dev, to_of_node(fwnode));
+ 	if (!con_np)
+ 		return -EINVAL;
+ 
+ 	for_each_property_of_node(con_np, p)
+ 		of_link_property(con_np, p->name);
+ 
+ 	return 0;
  }
  
  const struct fwnode_operations of_fwnode_ops = {
* Unmerged path drivers/of/property.c
