bpf: Lock bpf_trace_printk's tmp buf before it is written to

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Florent Revest <revest@chromium.org>
commit 38d26d89b31d0766d431471572cc9b007ca19c98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/38d26d89.failed

bpf_trace_printk uses a shared static buffer to hold strings before they
are printed. A recent refactoring moved the locking of that buffer after
it gets filled by mistake.

Fixes: d9c9e4db186a ("bpf: Factorize bpf_trace_printk and bpf_seq_printf")
	Reported-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
	Signed-off-by: Florent Revest <revest@chromium.org>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20210427112958.773132-1-revest@chromium.org
(cherry picked from commit 38d26d89b31d0766d431471572cc9b007ca19c98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/bpf_trace.c
diff --cc kernel/trace/bpf_trace.c
index 235070f4b98b,0e67d12a8f40..000000000000
--- a/kernel/trace/bpf_trace.c
+++ b/kernel/trace/bpf_trace.c
@@@ -362,49 -372,32 +362,64 @@@ static const struct bpf_func_proto *bpf
  	return &bpf_probe_write_user_proto;
  }
  
 +static void bpf_trace_copy_string(char *buf, void *unsafe_ptr, char fmt_ptype,
 +		size_t bufsz)
 +{
 +	void __user *user_ptr = (__force void __user *)unsafe_ptr;
 +
 +	buf[0] = 0;
 +
 +	switch (fmt_ptype) {
 +	case 's':
 +#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE
 +		if ((unsigned long)unsafe_ptr < TASK_SIZE) {
 +			strncpy_from_unsafe_user(buf, user_ptr, bufsz);
 +			break;
 +		}
 +		/* fallthrough */
 +#endif
 +	case 'k':
 +		strncpy_from_unsafe_strict(buf, unsafe_ptr, bufsz);
 +		break;
 +	case 'u':
 +		strncpy_from_unsafe_user(buf, user_ptr, bufsz);
 +		break;
 +	}
 +}
 +
  static DEFINE_RAW_SPINLOCK(trace_printk_lock);
  
 -#define MAX_TRACE_PRINTK_VARARGS	3
 -#define BPF_TRACE_PRINTK_SIZE		1024
 +#define BPF_TRACE_PRINTK_SIZE   1024
  
 -BPF_CALL_5(bpf_trace_printk, char *, fmt, u32, fmt_size, u64, arg1,
 -	   u64, arg2, u64, arg3)
 +static __printf(1, 0) int bpf_do_trace_printk(const char *fmt, ...)
  {
 -	u64 args[MAX_TRACE_PRINTK_VARARGS] = { arg1, arg2, arg3 };
 -	enum bpf_printf_mod_type mod[MAX_TRACE_PRINTK_VARARGS];
  	static char buf[BPF_TRACE_PRINTK_SIZE];
  	unsigned long flags;
 +	va_list ap;
  	int ret;
  
++<<<<<<< HEAD
 +	raw_spin_lock_irqsave(&trace_printk_lock, flags);
 +	va_start(ap, fmt);
 +	ret = vsnprintf(buf, sizeof(buf), fmt, ap);
 +	va_end(ap);
 +	/* vsnprintf() will not append null for zero-length strings */
 +	if (ret == 0)
 +		buf[0] = '\0';
++=======
+ 	ret = bpf_printf_prepare(fmt, fmt_size, args, args, mod,
+ 				 MAX_TRACE_PRINTK_VARARGS);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	raw_spin_lock_irqsave(&trace_printk_lock, flags);
+ 	ret = snprintf(buf, sizeof(buf), fmt, BPF_CAST_FMT_ARG(0, args, mod),
+ 		BPF_CAST_FMT_ARG(1, args, mod), BPF_CAST_FMT_ARG(2, args, mod));
+ 	/* snprintf() will not append null for zero-length strings */
+ 	if (ret == 0)
+ 		buf[0] = '\0';
+ 
++>>>>>>> 38d26d89b31d (bpf: Lock bpf_trace_printk's tmp buf before it is written to)
  	trace_bpf_trace_printk(buf);
  	raw_spin_unlock_irqrestore(&trace_printk_lock, flags);
  
* Unmerged path kernel/trace/bpf_trace.c
