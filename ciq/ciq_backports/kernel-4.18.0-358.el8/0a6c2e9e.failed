x86/fpu/signal: Split out the direct restore code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 0a6c2e9ec91c96bde1e8ce063180ac6e05e680f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/0a6c2e9e.failed

Prepare for smarter failure handling of the direct restore.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20210623121457.493455414@linutronix.de
(cherry picked from commit 0a6c2e9ec91c96bde1e8ce063180ac6e05e680f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/signal.c
diff --cc arch/x86/kernel/fpu/signal.c
index 7e120ce9728a,aa268d9cf228..000000000000
--- a/arch/x86/kernel/fpu/signal.c
+++ b/arch/x86/kernel/fpu/signal.c
@@@ -249,36 -250,79 +249,92 @@@ sanitize_restored_user_xstate(union fpr
  	}
  }
  
++<<<<<<< HEAD
 +/*
 + * Restore the extended state if present. Otherwise, restore the FP/SSE state.
 + */
 +static int copy_user_to_fpregs_zeroing(void __user *buf, u64 xbv, int fx_only)
++=======
+ static int __restore_fpregs_from_user(void __user *buf, u64 xrestore,
+ 				      bool fx_only)
++>>>>>>> 0a6c2e9ec91c (x86/fpu/signal: Split out the direct restore code)
  {
 -	if (use_xsave()) {
 -		u64 init_bv = xfeatures_mask_uabi() & ~xrestore;
 -		int ret;
 +	u64 init_bv;
 +	int r;
  
 -		if (likely(!fx_only))
 -			ret = xrstor_from_user_sigframe(buf, xrestore);
 -		else
 -			ret = fxrstor_from_user_sigframe(buf);
 -
 -		if (!ret && unlikely(init_bv))
 -			os_xrstor(&init_fpstate.xsave, init_bv);
 -		return ret;
 +	if (use_xsave()) {
 +		if (fx_only) {
 +			init_bv = xfeatures_mask_user() & ~XFEATURE_MASK_FPSSE;
 +
 +			r = copy_user_to_fxregs(buf);
 +			if (!r)
 +				copy_kernel_to_xregs(&init_fpstate.xsave, init_bv);
 +			return r;
 +		} else {
 +			init_bv = xfeatures_mask_user() & ~xbv;
 +
 +			r = xrstor_from_user_sigframe(buf, xbv);
 +			if (!r && unlikely(init_bv))
 +				copy_kernel_to_xregs(&init_fpstate.xsave, init_bv);
 +			return r;
 +		}
  	} else if (use_fxsr()) {
 -		return fxrstor_from_user_sigframe(buf);
 -	} else {
 +		return copy_user_to_fxregs(buf);
 +	} else
  		return frstor_from_user_sigframe(buf);
 -	}
  }
  
+ static int restore_fpregs_from_user(void __user *buf, u64 xrestore, bool fx_only)
+ {
+ 	struct fpu *fpu = &current->thread.fpu;
+ 	int ret;
+ 
+ 	fpregs_lock();
+ 	pagefault_disable();
+ 	ret = __restore_fpregs_from_user(buf, xrestore, fx_only);
+ 	pagefault_enable();
+ 
+ 	if (unlikely(ret)) {
+ 		/*
+ 		 * The above did an FPU restore operation, restricted to
+ 		 * the user portion of the registers, and failed, but the
+ 		 * microcode might have modified the FPU registers
+ 		 * nevertheless.
+ 		 *
+ 		 * If the FPU registers do not belong to current, then
+ 		 * invalidate the FPU register state otherwise the task
+ 		 * might preempt current and return to user space with
+ 		 * corrupted FPU registers.
+ 		 *
+ 		 * In case current owns the FPU registers then no further
+ 		 * action is required. The fixup in the slow path will
+ 		 * handle it correctly.
+ 		 */
+ 		if (test_thread_flag(TIF_NEED_FPU_LOAD))
+ 			__cpu_invalidate_fpregs_state();
+ 		fpregs_unlock();
+ 		return ret;
+ 	}
+ 
+ 	/*
+ 	 * Restore supervisor states: previous context switch etc has done
+ 	 * XSAVES and saved the supervisor states in the kernel buffer from
+ 	 * which they can be restored now.
+ 	 *
+ 	 * It would be optimal to handle this with a single XRSTORS, but
+ 	 * this does not work because the rest of the FPU registers have
+ 	 * been restored from a user buffer directly. The single XRSTORS
+ 	 * happens below, when the user buffer has been copied to the
+ 	 * kernel one.
+ 	 */
+ 	if (test_thread_flag(TIF_NEED_FPU_LOAD) && xfeatures_mask_supervisor())
+ 		os_xrstor(&fpu->state.xsave, xfeatures_mask_supervisor());
+ 
+ 	fpregs_mark_activate();
+ 	fpregs_unlock();
+ 	return 0;
+ }
+ 
  static int __fpu_restore_sig(void __user *buf, void __user *buf_fx,
  			     bool ia32_fxstate)
  {
@@@ -303,60 -347,16 +359,43 @@@
  		user_xfeatures = fx_sw_user.xfeatures;
  	}
  
- 	if (!ia32_fxstate) {
+ 	if (likely(!ia32_fxstate)) {
  		/*
  		 * Attempt to restore the FPU registers directly from user
- 		 * memory. For that to succeed, the user access cannot cause
- 		 * page faults. If it does, fall back to the slow path below,
- 		 * going through the kernel buffer with the enabled pagefault
- 		 * handler.
+ 		 * memory. For that to succeed, the user access cannot cause page
+ 		 * faults. If it does, fall back to the slow path below, going
+ 		 * through the kernel buffer with the enabled pagefault handler.
  		 */
++<<<<<<< HEAD
 +		fpregs_lock();
 +		pagefault_disable();
 +		ret = copy_user_to_fpregs_zeroing(buf_fx, user_xfeatures, fx_only);
 +		pagefault_enable();
 +		if (!ret) {
 +
 +			/*
 +			 * Restore supervisor states: previous context switch
 +			 * etc has done XSAVES and saved the supervisor states
 +			 * in the kernel buffer from which they can be restored
 +			 * now.
 +			 *
 +			 * We cannot do a single XRSTORS here - which would
 +			 * be nice - because the rest of the FPU registers are
 +			 * being restored from a user buffer directly. The
 +			 * single XRSTORS happens below, when the user buffer
 +			 * has been copied to the kernel one.
 +			 */
 +			if (test_thread_flag(TIF_NEED_FPU_LOAD) &&
 +			    xfeatures_mask_supervisor())
 +				copy_kernel_to_xregs(&fpu->state.xsave,
 +						     xfeatures_mask_supervisor());
 +			fpregs_mark_activate();
 +			fpregs_unlock();
++=======
+ 		ret = restore_fpregs_from_user(buf_fx, user_xfeatures, fx_only);
+ 		if (likely(!ret))
++>>>>>>> 0a6c2e9ec91c (x86/fpu/signal: Split out the direct restore code)
  			return 0;
- 		}
- 
- 		/*
- 		 * The above did an FPU restore operation, restricted to
- 		 * the user portion of the registers, and failed, but the
- 		 * microcode might have modified the FPU registers
- 		 * nevertheless.
- 		 *
- 		 * If the FPU registers do not belong to current, then
- 		 * invalidate the FPU register state otherwise the task might
- 		 * preempt current and return to user space with corrupted
- 		 * FPU registers.
- 		 *
- 		 * In case current owns the FPU registers then no further
- 		 * action is required. The fixup below will handle it
- 		 * correctly.
- 		 */
- 		if (test_thread_flag(TIF_NEED_FPU_LOAD))
- 			__cpu_invalidate_fpregs_state();
- 
- 		fpregs_unlock();
  	} else {
  		/*
  		 * For 32-bit frames with fxstate, copy the fxstate so it can
* Unmerged path arch/x86/kernel/fpu/signal.c
