x86/fpu: Move fpu__write_begin() to regset

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit dbb60ac764581e62f2116c5a6b8926ba3a872dd4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/dbb60ac7.failed

The only usecase for fpu__write_begin is the set() callback of regset, so
the function is pointlessly global.

Move it to the regset code and rename it to fpu_force_restore() which is
exactly decribing what the function does.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20210623121453.328652975@linutronix.de
(cherry picked from commit dbb60ac764581e62f2116c5a6b8926ba3a872dd4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/fpu/internal.h
#	arch/x86/kernel/fpu/core.c
#	arch/x86/kernel/fpu/regset.c
diff --cc arch/x86/include/asm/fpu/internal.h
index 1bc560a23553,854bfb03645e..000000000000
--- a/arch/x86/include/asm/fpu/internal.h
+++ b/arch/x86/include/asm/fpu/internal.h
@@@ -26,8 -26,6 +26,11 @@@
  /*
   * High level FPU state handling functions:
   */
++<<<<<<< HEAD
 +extern void fpu__prepare_read(struct fpu *fpu);
 +extern void fpu__prepare_write(struct fpu *fpu);
++=======
++>>>>>>> dbb60ac76458 (x86/fpu: Move fpu__write_begin() to regset)
  extern void fpu__save(struct fpu *fpu);
  extern int  fpu__restore_sig(void __user *buf, int ia32_frame);
  extern void fpu__drop(struct fpu *fpu);
diff --cc arch/x86/kernel/fpu/core.c
index 780a11e1b5d6,22437011f4f0..000000000000
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@@ -274,50 -282,6 +274,53 @@@ static void fpu__initialize(struct fpu 
  }
  
  /*
++<<<<<<< HEAD
 + * This function must be called before we read a task's fpstate.
 + *
 + * There's two cases where this gets called:
 + *
 + * - for the current task (when coredumping), in which case we have
 + *   to save the latest FPU registers into the fpstate,
 + *
 + * - or it's called for stopped tasks (ptrace), in which case the
 + *   registers were already saved by the context-switch code when
 + *   the task scheduled out.
 + *
 + * If the task has used the FPU before then save it.
 + */
 +void fpu__prepare_read(struct fpu *fpu)
 +{
 +	if (fpu == &current->thread.fpu)
 +		fpu__save(fpu);
 +}
 +
 +/*
 + * This function must be called before we write a task's fpstate.
 + *
 + * Invalidate any cached FPU registers.
 + *
 + * After this function call, after registers in the fpstate are
 + * modified and the child task has woken up, the child task will
 + * restore the modified FPU state from the modified context. If we
 + * didn't clear its cached status here then the cached in-registers
 + * state pending on its former CPU could be restored, corrupting
 + * the modifications.
 + */
 +void fpu__prepare_write(struct fpu *fpu)
 +{
 +	/*
 +	 * Only stopped child tasks can be used to modify the FPU
 +	 * state in the fpstate buffer:
 +	 */
 +	WARN_ON_FPU(fpu == &current->thread.fpu);
 +
 +	/* Invalidate any cached state: */
 +	__fpu_invalidate_fpregs_state(fpu);
 +}
 +
 +/*
++=======
++>>>>>>> dbb60ac76458 (x86/fpu: Move fpu__write_begin() to regset)
   * Drops current FPU state: deactivates the fpregs and
   * the fpstate. NOTE: it still leaves previous contents
   * in the fpregs in the eager-FPU case.
diff --cc arch/x86/kernel/fpu/regset.c
index 7bcf779c46cb,ddc290d9bf8e..000000000000
--- a/arch/x86/kernel/fpu/regset.c
+++ b/arch/x86/kernel/fpu/regset.c
@@@ -28,9 -28,43 +28,47 @@@ int regset_xregset_fpregs_active(struc
  		return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * The regset get() functions are invoked from:
+  *
+  *   - coredump to dump the current task's fpstate. If the current task
+  *     owns the FPU then the memory state has to be synchronized and the
+  *     FPU register state preserved. Otherwise fpstate is already in sync.
+  *
+  *   - ptrace to dump fpstate of a stopped task, in which case the registers
+  *     have already been saved to fpstate on context switch.
+  */
+ static void sync_fpstate(struct fpu *fpu)
+ {
+ 	if (fpu == &current->thread.fpu)
+ 		fpu__save(fpu);
+ }
+ 
+ /*
+  * Invalidate cached FPU registers before modifying the stopped target
+  * task's fpstate.
+  *
+  * This forces the target task on resume to restore the FPU registers from
+  * modified fpstate. Otherwise the task might skip the restore and operate
+  * with the cached FPU registers which discards the modifications.
+  */
+ static void fpu_force_restore(struct fpu *fpu)
+ {
+ 	/*
+ 	 * Only stopped child tasks can be used to modify the FPU
+ 	 * state in the fpstate buffer:
+ 	 */
+ 	WARN_ON_FPU(fpu == &current->thread.fpu);
+ 
+ 	__fpu_invalidate_fpregs_state(fpu);
+ }
+ 
++>>>>>>> dbb60ac76458 (x86/fpu: Move fpu__write_begin() to regset)
  int xfpregs_get(struct task_struct *target, const struct user_regset *regset,
 -		struct membuf to)
 +		unsigned int pos, unsigned int count,
 +		void *kbuf, void __user *ubuf)
  {
  	struct fpu *fpu = &target->thread.fpu;
  
* Unmerged path arch/x86/include/asm/fpu/internal.h
* Unmerged path arch/x86/kernel/fpu/core.c
* Unmerged path arch/x86/kernel/fpu/regset.c
