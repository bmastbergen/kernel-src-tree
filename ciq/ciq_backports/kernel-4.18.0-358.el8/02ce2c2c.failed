Bluetooth: mgmt: Fix the command returns garbage parameter value

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Tedd Ho-Jeong An <tedd.an@intel.com>
commit 02ce2c2c24024aade65a8d91d6a596651eaf2d0a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/02ce2c2c.failed

When the Get Device Flags command fails, it returns the error status
with the parameters filled with the garbage values. Although the
parameters are not used, it is better to fill with zero than the random
values.

	Signed-off-by: Tedd Ho-Jeong An <tedd.an@intel.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 02ce2c2c24024aade65a8d91d6a596651eaf2d0a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/mgmt.c
diff --cc net/bluetooth/mgmt.c
index 09f02c38d4a7,5616e8afb22e..000000000000
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@@ -3635,122 -3716,542 +3635,519 @@@ unlock
  	return err;
  }
  
++<<<<<<< HEAD
 +static int set_blocked_keys(struct sock *sk, struct hci_dev *hdev, void *data,
++=======
+ static int read_controller_cap(struct sock *sk, struct hci_dev *hdev,
+ 			       void *data, u16 data_len)
+ {
+ 	char buf[20];
+ 	struct mgmt_rp_read_controller_cap *rp = (void *)buf;
+ 	u16 cap_len = 0;
+ 	u8 flags = 0;
+ 	u8 tx_power_range[2];
+ 
+ 	bt_dev_dbg(hdev, "sock %p", sk);
+ 
+ 	memset(&buf, 0, sizeof(buf));
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	/* When the Read Simple Pairing Options command is supported, then
+ 	 * the remote public key validation is supported.
+ 	 *
+ 	 * Alternatively, when Microsoft extensions are available, they can
+ 	 * indicate support for public key validation as well.
+ 	 */
+ 	if ((hdev->commands[41] & 0x08) || msft_curve_validity(hdev))
+ 		flags |= 0x01;	/* Remote public key validation (BR/EDR) */
+ 
+ 	flags |= 0x02;		/* Remote public key validation (LE) */
+ 
+ 	/* When the Read Encryption Key Size command is supported, then the
+ 	 * encryption key size is enforced.
+ 	 */
+ 	if (hdev->commands[20] & 0x10)
+ 		flags |= 0x04;	/* Encryption key size enforcement (BR/EDR) */
+ 
+ 	flags |= 0x08;		/* Encryption key size enforcement (LE) */
+ 
+ 	cap_len = eir_append_data(rp->cap, cap_len, MGMT_CAP_SEC_FLAGS,
+ 				  &flags, 1);
+ 
+ 	/* When the Read Simple Pairing Options command is supported, then
+ 	 * also max encryption key size information is provided.
+ 	 */
+ 	if (hdev->commands[41] & 0x08)
+ 		cap_len = eir_append_le16(rp->cap, cap_len,
+ 					  MGMT_CAP_MAX_ENC_KEY_SIZE,
+ 					  hdev->max_enc_key_size);
+ 
+ 	cap_len = eir_append_le16(rp->cap, cap_len,
+ 				  MGMT_CAP_SMP_MAX_ENC_KEY_SIZE,
+ 				  SMP_MAX_ENC_KEY_SIZE);
+ 
+ 	/* Append the min/max LE tx power parameters if we were able to fetch
+ 	 * it from the controller
+ 	 */
+ 	if (hdev->commands[38] & 0x80) {
+ 		memcpy(&tx_power_range[0], &hdev->min_le_tx_power, 1);
+ 		memcpy(&tx_power_range[1], &hdev->max_le_tx_power, 1);
+ 		cap_len = eir_append_data(rp->cap, cap_len, MGMT_CAP_LE_TX_PWR,
+ 					  tx_power_range, 2);
+ 	}
+ 
+ 	rp->cap_len = cpu_to_le16(cap_len);
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_CONTROLLER_CAP, 0,
+ 				 rp, sizeof(*rp) + cap_len);
+ }
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ /* d4992530-b9ec-469f-ab01-6c481c47da1c */
+ static const u8 debug_uuid[16] = {
+ 	0x1c, 0xda, 0x47, 0x1c, 0x48, 0x6c, 0x01, 0xab,
+ 	0x9f, 0x46, 0xec, 0xb9, 0x30, 0x25, 0x99, 0xd4,
+ };
+ #endif
+ 
+ /* 671b10b5-42c0-4696-9227-eb28d1b049d6 */
+ static const u8 simult_central_periph_uuid[16] = {
+ 	0xd6, 0x49, 0xb0, 0xd1, 0x28, 0xeb, 0x27, 0x92,
+ 	0x96, 0x46, 0xc0, 0x42, 0xb5, 0x10, 0x1b, 0x67,
+ };
+ 
+ /* 15c0a148-c273-11ea-b3de-0242ac130004 */
+ static const u8 rpa_resolution_uuid[16] = {
+ 	0x04, 0x00, 0x13, 0xac, 0x42, 0x02, 0xde, 0xb3,
+ 	0xea, 0x11, 0x73, 0xc2, 0x48, 0xa1, 0xc0, 0x15,
+ };
+ 
+ static int read_exp_features_info(struct sock *sk, struct hci_dev *hdev,
+ 				  void *data, u16 data_len)
+ {
+ 	char buf[62];	/* Enough space for 3 features */
+ 	struct mgmt_rp_read_exp_features_info *rp = (void *)buf;
+ 	u16 idx = 0;
+ 	u32 flags;
+ 
+ 	bt_dev_dbg(hdev, "sock %p", sk);
+ 
+ 	memset(&buf, 0, sizeof(buf));
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ 	if (!hdev) {
+ 		flags = bt_dbg_get() ? BIT(0) : 0;
+ 
+ 		memcpy(rp->features[idx].uuid, debug_uuid, 16);
+ 		rp->features[idx].flags = cpu_to_le32(flags);
+ 		idx++;
+ 	}
+ #endif
+ 
+ 	if (hdev) {
+ 		if (test_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks) &&
+ 		    (hdev->le_states[4] & 0x08) &&	/* Central */
+ 		    (hdev->le_states[4] & 0x40) &&	/* Peripheral */
+ 		    (hdev->le_states[3] & 0x10))	/* Simultaneous */
+ 			flags = BIT(0);
+ 		else
+ 			flags = 0;
+ 
+ 		memcpy(rp->features[idx].uuid, simult_central_periph_uuid, 16);
+ 		rp->features[idx].flags = cpu_to_le32(flags);
+ 		idx++;
+ 	}
+ 
+ 	if (hdev && use_ll_privacy(hdev)) {
+ 		if (hci_dev_test_flag(hdev, HCI_ENABLE_LL_PRIVACY))
+ 			flags = BIT(0) | BIT(1);
+ 		else
+ 			flags = BIT(1);
+ 
+ 		memcpy(rp->features[idx].uuid, rpa_resolution_uuid, 16);
+ 		rp->features[idx].flags = cpu_to_le32(flags);
+ 		idx++;
+ 	}
+ 
+ 	rp->feature_count = cpu_to_le16(idx);
+ 
+ 	/* After reading the experimental features information, enable
+ 	 * the events to update client on any future change.
+ 	 */
+ 	hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 	return mgmt_cmd_complete(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
+ 				 MGMT_OP_READ_EXP_FEATURES_INFO,
+ 				 0, rp, sizeof(*rp) + (20 * idx));
+ }
+ 
+ static int exp_ll_privacy_feature_changed(bool enabled, struct hci_dev *hdev,
+ 					  struct sock *skip)
+ {
+ 	struct mgmt_ev_exp_feature_changed ev;
+ 
+ 	memset(&ev, 0, sizeof(ev));
+ 	memcpy(ev.uuid, rpa_resolution_uuid, 16);
+ 	ev.flags = cpu_to_le32((enabled ? BIT(0) : 0) | BIT(1));
+ 
+ 	return mgmt_limited_event(MGMT_EV_EXP_FEATURE_CHANGED, hdev,
+ 				  &ev, sizeof(ev),
+ 				  HCI_MGMT_EXP_FEATURE_EVENTS, skip);
+ 
+ }
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ static int exp_debug_feature_changed(bool enabled, struct sock *skip)
+ {
+ 	struct mgmt_ev_exp_feature_changed ev;
+ 
+ 	memset(&ev, 0, sizeof(ev));
+ 	memcpy(ev.uuid, debug_uuid, 16);
+ 	ev.flags = cpu_to_le32(enabled ? BIT(0) : 0);
+ 
+ 	return mgmt_limited_event(MGMT_EV_EXP_FEATURE_CHANGED, NULL,
+ 				  &ev, sizeof(ev),
+ 				  HCI_MGMT_EXP_FEATURE_EVENTS, skip);
+ }
+ #endif
+ 
+ static int set_exp_feature(struct sock *sk, struct hci_dev *hdev,
+ 			   void *data, u16 data_len)
+ {
+ 	struct mgmt_cp_set_exp_feature *cp = data;
+ 	struct mgmt_rp_set_exp_feature rp;
+ 
+ 	bt_dev_dbg(hdev, "sock %p", sk);
+ 
+ 	if (!memcmp(cp->uuid, ZERO_KEY, 16)) {
+ 		memset(rp.uuid, 0, 16);
+ 		rp.flags = cpu_to_le32(0);
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ 		if (!hdev) {
+ 			bool changed = bt_dbg_get();
+ 
+ 			bt_dbg_set(false);
+ 
+ 			if (changed)
+ 				exp_debug_feature_changed(false, sk);
+ 		}
+ #endif
+ 
+ 		if (hdev && use_ll_privacy(hdev) && !hdev_is_powered(hdev)) {
+ 			bool changed = hci_dev_test_flag(hdev,
+ 							 HCI_ENABLE_LL_PRIVACY);
+ 
+ 			hci_dev_clear_flag(hdev, HCI_ENABLE_LL_PRIVACY);
+ 
+ 			if (changed)
+ 				exp_ll_privacy_feature_changed(false, hdev, sk);
+ 		}
+ 
+ 		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 		return mgmt_cmd_complete(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
+ 					 MGMT_OP_SET_EXP_FEATURE, 0,
+ 					 &rp, sizeof(rp));
+ 	}
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ 	if (!memcmp(cp->uuid, debug_uuid, 16)) {
+ 		bool val, changed;
+ 		int err;
+ 
+ 		/* Command requires to use the non-controller index */
+ 		if (hdev)
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_INDEX);
+ 
+ 		/* Parameters are limited to a single octet */
+ 		if (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)
+ 			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		/* Only boolean on/off is supported */
+ 		if (cp->param[0] != 0x00 && cp->param[0] != 0x01)
+ 			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		val = !!cp->param[0];
+ 		changed = val ? !bt_dbg_get() : bt_dbg_get();
+ 		bt_dbg_set(val);
+ 
+ 		memcpy(rp.uuid, debug_uuid, 16);
+ 		rp.flags = cpu_to_le32(val ? BIT(0) : 0);
+ 
+ 		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 		err = mgmt_cmd_complete(sk, MGMT_INDEX_NONE,
+ 					MGMT_OP_SET_EXP_FEATURE, 0,
+ 					&rp, sizeof(rp));
+ 
+ 		if (changed)
+ 			exp_debug_feature_changed(val, sk);
+ 
+ 		return err;
+ 	}
+ #endif
+ 
+ 	if (!memcmp(cp->uuid, rpa_resolution_uuid, 16)) {
+ 		bool val, changed;
+ 		int err;
+ 		u32 flags;
+ 
+ 		/* Command requires to use the controller index */
+ 		if (!hdev)
+ 			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_INDEX);
+ 
+ 		/* Changes can only be made when controller is powered down */
+ 		if (hdev_is_powered(hdev))
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_REJECTED);
+ 
+ 		/* Parameters are limited to a single octet */
+ 		if (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		/* Only boolean on/off is supported */
+ 		if (cp->param[0] != 0x00 && cp->param[0] != 0x01)
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		val = !!cp->param[0];
+ 
+ 		if (val) {
+ 			changed = !hci_dev_test_flag(hdev,
+ 						     HCI_ENABLE_LL_PRIVACY);
+ 			hci_dev_set_flag(hdev, HCI_ENABLE_LL_PRIVACY);
+ 			hci_dev_clear_flag(hdev, HCI_ADVERTISING);
+ 
+ 			/* Enable LL privacy + supported settings changed */
+ 			flags = BIT(0) | BIT(1);
+ 		} else {
+ 			changed = hci_dev_test_flag(hdev,
+ 						    HCI_ENABLE_LL_PRIVACY);
+ 			hci_dev_clear_flag(hdev, HCI_ENABLE_LL_PRIVACY);
+ 
+ 			/* Disable LL privacy + supported settings changed */
+ 			flags = BIT(1);
+ 		}
+ 
+ 		memcpy(rp.uuid, rpa_resolution_uuid, 16);
+ 		rp.flags = cpu_to_le32(flags);
+ 
+ 		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 		err = mgmt_cmd_complete(sk, hdev->id,
+ 					MGMT_OP_SET_EXP_FEATURE, 0,
+ 					&rp, sizeof(rp));
+ 
+ 		if (changed)
+ 			exp_ll_privacy_feature_changed(val, hdev, sk);
+ 
+ 		return err;
+ 	}
+ 
+ 	return mgmt_cmd_status(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
+ 			       MGMT_OP_SET_EXP_FEATURE,
+ 			       MGMT_STATUS_NOT_SUPPORTED);
+ }
+ 
+ #define SUPPORTED_DEVICE_FLAGS() ((1U << HCI_CONN_FLAG_MAX) - 1)
+ 
+ static int get_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,
+ 			    u16 data_len)
+ {
+ 	struct mgmt_cp_get_device_flags *cp = data;
+ 	struct mgmt_rp_get_device_flags rp;
+ 	struct bdaddr_list_with_flags *br_params;
+ 	struct hci_conn_params *params;
+ 	u32 supported_flags = SUPPORTED_DEVICE_FLAGS();
+ 	u32 current_flags = 0;
+ 	u8 status = MGMT_STATUS_INVALID_PARAMS;
+ 
+ 	bt_dev_dbg(hdev, "Get device flags %pMR (type 0x%x)\n",
+ 		   &cp->addr.bdaddr, cp->addr.type);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	memset(&rp, 0, sizeof(rp));
+ 
+ 	if (cp->addr.type == BDADDR_BREDR) {
+ 		br_params = hci_bdaddr_list_lookup_with_flags(&hdev->whitelist,
+ 							      &cp->addr.bdaddr,
+ 							      cp->addr.type);
+ 		if (!br_params)
+ 			goto done;
+ 
+ 		current_flags = br_params->current_flags;
+ 	} else {
+ 		params = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,
+ 						le_addr_type(cp->addr.type));
+ 
+ 		if (!params)
+ 			goto done;
+ 
+ 		current_flags = params->current_flags;
+ 	}
+ 
+ 	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
+ 	rp.addr.type = cp->addr.type;
+ 	rp.supported_flags = cpu_to_le32(supported_flags);
+ 	rp.current_flags = cpu_to_le32(current_flags);
+ 
+ 	status = MGMT_STATUS_SUCCESS;
+ 
+ done:
+ 	hci_dev_unlock(hdev);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_DEVICE_FLAGS, status,
+ 				&rp, sizeof(rp));
+ }
+ 
+ static void device_flags_changed(struct sock *sk, struct hci_dev *hdev,
+ 				 bdaddr_t *bdaddr, u8 bdaddr_type,
+ 				 u32 supported_flags, u32 current_flags)
+ {
+ 	struct mgmt_ev_device_flags_changed ev;
+ 
+ 	bacpy(&ev.addr.bdaddr, bdaddr);
+ 	ev.addr.type = bdaddr_type;
+ 	ev.supported_flags = cpu_to_le32(supported_flags);
+ 	ev.current_flags = cpu_to_le32(current_flags);
+ 
+ 	mgmt_event(MGMT_EV_DEVICE_FLAGS_CHANGED, hdev, &ev, sizeof(ev), sk);
+ }
+ 
+ static int set_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,
++>>>>>>> 02ce2c2c2402 (Bluetooth: mgmt: Fix the command returns garbage parameter value)
  			    u16 len)
  {
 -	struct mgmt_cp_set_device_flags *cp = data;
 -	struct bdaddr_list_with_flags *br_params;
 -	struct hci_conn_params *params;
 -	u8 status = MGMT_STATUS_INVALID_PARAMS;
 -	u32 supported_flags = SUPPORTED_DEVICE_FLAGS();
 -	u32 current_flags = __le32_to_cpu(cp->current_flags);
 +	int err = MGMT_STATUS_SUCCESS;
 +	struct mgmt_cp_set_blocked_keys *keys = data;
 +	const u16 max_key_count = ((U16_MAX - sizeof(*keys)) /
 +				   sizeof(struct mgmt_blocked_key_info));
 +	u16 key_count, expected_len;
 +	int i;
  
 -	bt_dev_dbg(hdev, "Set device flags %pMR (type 0x%x) = 0x%x",
 -		   &cp->addr.bdaddr, cp->addr.type,
 -		   __le32_to_cpu(current_flags));
 +	BT_DBG("request for %s", hdev->name);
  
 -	if ((supported_flags | current_flags) != supported_flags) {
 -		bt_dev_warn(hdev, "Bad flag given (0x%x) vs supported (0x%0x)",
 -			    current_flags, supported_flags);
 -		goto done;
 +	key_count = __le16_to_cpu(keys->key_count);
 +	if (key_count > max_key_count) {
 +		bt_dev_err(hdev, "too big key_count value %u", key_count);
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				       MGMT_STATUS_INVALID_PARAMS);
  	}
  
 -	hci_dev_lock(hdev);
 -
 -	if (cp->addr.type == BDADDR_BREDR) {
 -		br_params = hci_bdaddr_list_lookup_with_flags(&hdev->whitelist,
 -							      &cp->addr.bdaddr,
 -							      cp->addr.type);
 -
 -		if (br_params) {
 -			br_params->current_flags = current_flags;
 -			status = MGMT_STATUS_SUCCESS;
 -		} else {
 -			bt_dev_warn(hdev, "No such BR/EDR device %pMR (0x%x)",
 -				    &cp->addr.bdaddr, cp->addr.type);
 -		}
 -	} else {
 -		params = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,
 -						le_addr_type(cp->addr.type));
 -		if (params) {
 -			params->current_flags = current_flags;
 -			status = MGMT_STATUS_SUCCESS;
 -		} else {
 -			bt_dev_warn(hdev, "No such LE device %pMR (0x%x)",
 -				    &cp->addr.bdaddr,
 -				    le_addr_type(cp->addr.type));
 -		}
 +	expected_len = struct_size(keys, keys, key_count);
 +	if (expected_len != len) {
 +		bt_dev_err(hdev, "expected %u bytes, got %u bytes",
 +			   expected_len, len);
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				       MGMT_STATUS_INVALID_PARAMS);
  	}
  
 -done:
 -	hci_dev_unlock(hdev);
 +	hci_dev_lock(hdev);
  
 -	if (status == MGMT_STATUS_SUCCESS)
 -		device_flags_changed(sk, hdev, &cp->addr.bdaddr, cp->addr.type,
 -				     supported_flags, current_flags);
 +	hci_blocked_keys_clear(hdev);
  
 -	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_DEVICE_FLAGS, status,
 -				 &cp->addr, sizeof(cp->addr));
 -}
 +	for (i = 0; i < keys->key_count; ++i) {
 +		struct blocked_key *b = kzalloc(sizeof(*b), GFP_KERNEL);
  
 -static void mgmt_adv_monitor_added(struct sock *sk, struct hci_dev *hdev,
 -				   u16 handle)
 -{
 -	struct mgmt_ev_adv_monitor_added ev;
 +		if (!b) {
 +			err = MGMT_STATUS_NO_RESOURCES;
 +			break;
 +		}
  
 -	ev.monitor_handle = cpu_to_le16(handle);
 +		b->type = keys->keys[i].type;
 +		memcpy(b->val, keys->keys[i].val, sizeof(b->val));
 +		list_add_rcu(&b->list, &hdev->blocked_keys);
 +	}
 +	hci_dev_unlock(hdev);
  
 -	mgmt_event(MGMT_EV_ADV_MONITOR_ADDED, hdev, &ev, sizeof(ev), sk);
 +	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				err, NULL, 0);
  }
  
 -void mgmt_adv_monitor_removed(struct hci_dev *hdev, u16 handle)
 +static void read_local_oob_data_complete(struct hci_dev *hdev, u8 status,
 +				         u16 opcode, struct sk_buff *skb)
  {
 -	struct mgmt_ev_adv_monitor_removed ev;
 +	struct mgmt_rp_read_local_oob_data mgmt_rp;
 +	size_t rp_size = sizeof(mgmt_rp);
  	struct mgmt_pending_cmd *cmd;
 -	struct sock *sk_skip = NULL;
 -	struct mgmt_cp_remove_adv_monitor *cp;
 -
 -	cmd = pending_find(MGMT_OP_REMOVE_ADV_MONITOR, hdev);
 -	if (cmd) {
 -		cp = cmd->param;
 -
 -		if (cp->monitor_handle)
 -			sk_skip = cmd->sk;
 -	}
  
 -	ev.monitor_handle = cpu_to_le16(handle);
 +	BT_DBG("%s status %u", hdev->name, status);
  
 -	mgmt_event(MGMT_EV_ADV_MONITOR_REMOVED, hdev, &ev, sizeof(ev), sk_skip);
 -}
 -
 -static int read_adv_mon_features(struct sock *sk, struct hci_dev *hdev,
 -				 void *data, u16 len)
 -{
 -	struct adv_monitor *monitor = NULL;
 -	struct mgmt_rp_read_adv_monitor_features *rp = NULL;
 -	int handle, err;
 -	size_t rp_size = 0;
 -	__u32 supported = 0;
 -	__u32 enabled = 0;
 -	__u16 num_handles = 0;
 -	__u16 handles[HCI_MAX_ADV_MONITOR_NUM_HANDLES];
 +	cmd = pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev);
 +	if (!cmd)
 +		return;
  
 -	BT_DBG("request for %s", hdev->name);
 +	if (status || !skb) {
 +		mgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
 +				status ? mgmt_status(status) : MGMT_STATUS_FAILED);
 +		goto remove;
 +	}
  
 -	hci_dev_lock(hdev);
 +	memset(&mgmt_rp, 0, sizeof(mgmt_rp));
  
 -	if (msft_monitor_supported(hdev))
 -		supported |= MGMT_ADV_MONITOR_FEATURE_MASK_OR_PATTERNS;
 +	if (opcode == HCI_OP_READ_LOCAL_OOB_DATA) {
 +		struct hci_rp_read_local_oob_data *rp = (void *) skb->data;
  
 -	idr_for_each_entry(&hdev->adv_monitors_idr, monitor, handle)
 -		handles[num_handles++] = monitor->handle;
 +		if (skb->len < sizeof(*rp)) {
 +			mgmt_cmd_status(cmd->sk, hdev->id,
 +					MGMT_OP_READ_LOCAL_OOB_DATA,
 +					MGMT_STATUS_FAILED);
 +			goto remove;
 +		}
  
 -	hci_dev_unlock(hdev);
 +		memcpy(mgmt_rp.hash192, rp->hash, sizeof(rp->hash));
 +		memcpy(mgmt_rp.rand192, rp->rand, sizeof(rp->rand));
  
 -	rp_size = sizeof(*rp) + (num_handles * sizeof(u16));
 -	rp = kmalloc(rp_size, GFP_KERNEL);
 -	if (!rp)
 -		return -ENOMEM;
 +		rp_size -= sizeof(mgmt_rp.hash256) + sizeof(mgmt_rp.rand256);
 +	} else {
 +		struct hci_rp_read_local_oob_ext_data *rp = (void *) skb->data;
  
 -	/* All supported features are currently enabled */
 -	enabled = supported;
 +		if (skb->len < sizeof(*rp)) {
 +			mgmt_cmd_status(cmd->sk, hdev->id,
 +					MGMT_OP_READ_LOCAL_OOB_DATA,
 +					MGMT_STATUS_FAILED);
 +			goto remove;
 +		}
  
 -	rp->supported_features = cpu_to_le32(supported);
 -	rp->enabled_features = cpu_to_le32(enabled);
 -	rp->max_num_handles = cpu_to_le16(HCI_MAX_ADV_MONITOR_NUM_HANDLES);
 -	rp->max_num_patterns = HCI_MAX_ADV_MONITOR_NUM_PATTERNS;
 -	rp->num_handles = cpu_to_le16(num_handles);
 -	if (num_handles)
 -		memcpy(&rp->handles, &handles, (num_handles * sizeof(u16)));
 +		memcpy(mgmt_rp.hash192, rp->hash192, sizeof(rp->hash192));
 +		memcpy(mgmt_rp.rand192, rp->rand192, sizeof(rp->rand192));
  
 -	err = mgmt_cmd_complete(sk, hdev->id,
 -				MGMT_OP_READ_ADV_MONITOR_FEATURES,
 -				MGMT_STATUS_SUCCESS, rp, rp_size);
 +		memcpy(mgmt_rp.hash256, rp->hash256, sizeof(rp->hash256));
 +		memcpy(mgmt_rp.rand256, rp->rand256, sizeof(rp->rand256));
 +	}
  
 -	kfree(rp);
 +	mgmt_cmd_complete(cmd->sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
 +			  MGMT_STATUS_SUCCESS, &mgmt_rp, rp_size);
  
 -	return err;
 +remove:
 +	mgmt_pending_remove(cmd);
  }
  
 -int mgmt_add_adv_patterns_monitor_complete(struct hci_dev *hdev, u8 status)
 +static int read_local_oob_data(struct sock *sk, struct hci_dev *hdev,
 +			       void *data, u16 data_len)
  {
 -	struct mgmt_rp_add_adv_patterns_monitor rp;
  	struct mgmt_pending_cmd *cmd;
 -	struct adv_monitor *monitor;
 -	int err = 0;
 +	struct hci_request req;
 +	int err;
 +
 +	BT_DBG("%s", hdev->name);
  
  	hci_dev_lock(hdev);
  
* Unmerged path net/bluetooth/mgmt.c
