ethtool: add a new command for reading standard stats

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Jakub Kicinski <kuba@kernel.org>
commit f09ea6fb12723d6726293d68de00b6307368bd76
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/f09ea6fb.failed

Add an interface for reading standard stats, including
stats which don't have a corresponding control interface.

Start with IEEE 802.3 PHY stats. There seems to be only
one stat to expose there.

Define API to not require user space changes when new
stats or groups are added. Groups are based on bitset,
stats have a string set associated.

v1: wrap stats in a nest

	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f09ea6fb12723d6726293d68de00b6307368bd76)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/ethtool.h
#	include/uapi/linux/ethtool_netlink.h
#	net/ethtool/Makefile
#	net/ethtool/netlink.c
#	net/ethtool/netlink.h
diff --cc include/linux/ethtool.h
index 98bda0684804,2d5455eedbf4..000000000000
--- a/include/linux/ethtool.h
+++ b/include/linux/ethtool.h
@@@ -455,6 -491,10 +462,13 @@@ struct ethtool_ops_extended_rh 
   *	cannot use the standard PHY library helpers.
   * @get_phy_tunable: Read the value of a PHY tunable.
   * @set_phy_tunable: Set the value of a PHY tunable.
++<<<<<<< HEAD
++=======
+  * @get_module_eeprom_by_page: Get a region of plug-in module EEPROM data from
+  *	specified page. Returns a negative error code or the amount of bytes
+  *	read.
+  * @get_eth_phy_stats: Query some of the IEEE 802.3 PHY statistics.
++>>>>>>> f09ea6fb1272 (ethtool: add a new command for reading standard stats)
   *
   * All operations are optional (i.e. the function pointer may be set
   * to %NULL) and callers must take this into account.  Callers must
@@@ -558,47 -598,18 +572,60 @@@ struct ethtool_ops 
  				      struct ethtool_fecparam *);
  	void	(*get_ethtool_phy_stats)(struct net_device *,
  					 struct ethtool_stats *, u64 *);
++<<<<<<< HEAD
++=======
+ 	int	(*get_phy_tunable)(struct net_device *,
+ 				   const struct ethtool_tunable *, void *);
+ 	int	(*set_phy_tunable)(struct net_device *,
+ 				   const struct ethtool_tunable *, const void *);
+ 	int	(*get_module_eeprom_by_page)(struct net_device *dev,
+ 					     const struct ethtool_module_eeprom *page,
+ 					     struct netlink_ext_ack *extack);
+ 	void	(*get_eth_phy_stats)(struct net_device *dev,
+ 				     struct ethtool_eth_phy_stats *phy_stats);
+ };
 -
 -int ethtool_check_ops(const struct ethtool_ops *ops);
++>>>>>>> f09ea6fb1272 (ethtool: add a new command for reading standard stats)
 +
 +	RH_KABI_USE(1, int	(*get_link_ksettings)(struct net_device *,
 +				      struct ethtool_link_ksettings *))
 +	RH_KABI_USE(2, int	(*set_link_ksettings)(struct net_device *,
 +				      const struct ethtool_link_ksettings *))
 +	RH_KABI_USE_SPLIT(3,	u32	supported_coalesce_params,
 +				u32     cap_link_lanes_supported:1)
 +	RH_KABI_USE(4, int	(*get_link_ext_state)(struct net_device *,
 +				      struct ethtool_link_ext_state_info *))
 +	RH_KABI_USE(5, void	(*get_pause_stats)(struct net_device *dev,
 +				   struct ethtool_pause_stats *pause_stats))
 +	RH_KABI_USE(6, int	(*get_phy_tunable)(struct net_device *,
 +				   const struct ethtool_tunable *, void *))
 +	RH_KABI_USE(7, int	(*set_phy_tunable)(struct net_device *,
 +				   const struct ethtool_tunable *, const void *))
 +	RH_KABI_RESERVE(8)
 +	RH_KABI_RESERVE(9)
 +	RH_KABI_RESERVE(10)
 +	RH_KABI_RESERVE(11)
 +	RH_KABI_RESERVE(12)
 +	RH_KABI_RESERVE(13)
 +	RH_KABI_RESERVE(14)
 +	RH_KABI_RESERVE(15)
 +	RH_KABI_RESERVE(16)
 +	RH_KABI_RESERVE(17)
 +	RH_KABI_RESERVE(18)
 +	RH_KABI_RESERVE(19)
 +	RH_KABI_RESERVE(20)
 +	RH_KABI_RESERVE(21)
 +	RH_KABI_RESERVE(22)
 +	RH_KABI_RESERVE(23)
 +	RH_KABI_RESERVE(24)
 +	RH_KABI_RESERVE(25)
 +	RH_KABI_RESERVE(26)
 +	RH_KABI_RESERVE(27)
 +	RH_KABI_RESERVE(28)
 +	RH_KABI_RESERVE(29)
 +	RH_KABI_RESERVE(30)
 +	RH_KABI_RESERVE(31)
 +	RH_KABI_AUX_EMBED(ethtool_ops_extended)
 +};
  
  struct ethtool_rx_flow_rule {
  	struct flow_rule	*rule;
diff --cc include/uapi/linux/ethtool_netlink.h
index df13d637e99a,a54cfe625f34..000000000000
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@@ -44,6 -44,8 +44,11 @@@ enum 
  	ETHTOOL_MSG_TUNNEL_INFO_GET,
  	ETHTOOL_MSG_FEC_GET,
  	ETHTOOL_MSG_FEC_SET,
++<<<<<<< HEAD
++=======
+ 	ETHTOOL_MSG_MODULE_EEPROM_GET,
+ 	ETHTOOL_MSG_STATS_GET,
++>>>>>>> f09ea6fb1272 (ethtool: add a new command for reading standard stats)
  
  	/* add new constants above here */
  	__ETHTOOL_MSG_USER_CNT,
@@@ -84,6 -86,8 +89,11 @@@ enum 
  	ETHTOOL_MSG_TUNNEL_INFO_GET_REPLY,
  	ETHTOOL_MSG_FEC_GET_REPLY,
  	ETHTOOL_MSG_FEC_NTF,
++<<<<<<< HEAD
++=======
+ 	ETHTOOL_MSG_MODULE_EEPROM_GET_REPLY,
+ 	ETHTOOL_MSG_STATS_GET_REPLY,
++>>>>>>> f09ea6fb1272 (ethtool: add a new command for reading standard stats)
  
  	/* add new constants above here */
  	__ETHTOOL_MSG_KERNEL_CNT,
@@@ -648,6 -651,81 +658,84 @@@ enum 
  	ETHTOOL_A_FEC_MAX = (__ETHTOOL_A_FEC_CNT - 1)
  };
  
++<<<<<<< HEAD
++=======
+ enum {
+ 	ETHTOOL_A_FEC_STAT_UNSPEC,
+ 	ETHTOOL_A_FEC_STAT_PAD,
+ 
+ 	ETHTOOL_A_FEC_STAT_CORRECTED,			/* array, u64 */
+ 	ETHTOOL_A_FEC_STAT_UNCORR,			/* array, u64 */
+ 	ETHTOOL_A_FEC_STAT_CORR_BITS,			/* array, u64 */
+ 
+ 	/* add new constants above here */
+ 	__ETHTOOL_A_FEC_STAT_CNT,
+ 	ETHTOOL_A_FEC_STAT_MAX = (__ETHTOOL_A_FEC_STAT_CNT - 1)
+ };
+ 
+ /* MODULE EEPROM */
+ 
+ enum {
+ 	ETHTOOL_A_MODULE_EEPROM_UNSPEC,
+ 	ETHTOOL_A_MODULE_EEPROM_HEADER,			/* nest - _A_HEADER_* */
+ 
+ 	ETHTOOL_A_MODULE_EEPROM_OFFSET,			/* u32 */
+ 	ETHTOOL_A_MODULE_EEPROM_LENGTH,			/* u32 */
+ 	ETHTOOL_A_MODULE_EEPROM_PAGE,			/* u8 */
+ 	ETHTOOL_A_MODULE_EEPROM_BANK,			/* u8 */
+ 	ETHTOOL_A_MODULE_EEPROM_I2C_ADDRESS,		/* u8 */
+ 	ETHTOOL_A_MODULE_EEPROM_DATA,			/* nested */
+ 
+ 	__ETHTOOL_A_MODULE_EEPROM_CNT,
+ 	ETHTOOL_A_MODULE_EEPROM_MAX = (__ETHTOOL_A_MODULE_EEPROM_CNT - 1)
+ };
+ 
+ /* STATS */
+ 
+ enum {
+ 	ETHTOOL_A_STATS_UNSPEC,
+ 	ETHTOOL_A_STATS_PAD,
+ 	ETHTOOL_A_STATS_HEADER,			/* nest - _A_HEADER_* */
+ 	ETHTOOL_A_STATS_GROUPS,			/* bitset */
+ 
+ 	ETHTOOL_A_STATS_GRP,			/* nest - _A_STATS_GRP_* */
+ 
+ 	/* add new constants above here */
+ 	__ETHTOOL_A_STATS_CNT,
+ 	ETHTOOL_A_STATS_MAX = (__ETHTOOL_A_STATS_CNT - 1)
+ };
+ 
+ enum {
+ 	ETHTOOL_STATS_ETH_PHY,
+ 
+ 	/* add new constants above here */
+ 	__ETHTOOL_STATS_CNT
+ };
+ 
+ enum {
+ 	ETHTOOL_A_STATS_GRP_UNSPEC,
+ 	ETHTOOL_A_STATS_GRP_PAD,
+ 
+ 	ETHTOOL_A_STATS_GRP_ID,			/* u32 */
+ 	ETHTOOL_A_STATS_GRP_SS_ID,		/* u32 */
+ 
+ 	ETHTOOL_A_STATS_GRP_STAT,		/* nest */
+ 
+ 	/* add new constants above here */
+ 	__ETHTOOL_A_STATS_GRP_CNT,
+ 	ETHTOOL_A_STATS_GRP_MAX = (__ETHTOOL_A_STATS_CNT - 1)
+ };
+ 
+ enum {
+ 	/* 30.3.2.1.5 aSymbolErrorDuringCarrier */
+ 	ETHTOOL_A_STATS_ETH_PHY_5_SYM_ERR,
+ 
+ 	/* add new constants above here */
+ 	__ETHTOOL_A_STATS_ETH_PHY_CNT,
+ 	ETHTOOL_A_STATS_ETH_PHY_MAX = (__ETHTOOL_A_STATS_ETH_PHY_CNT - 1)
+ };
+ 
++>>>>>>> f09ea6fb1272 (ethtool: add a new command for reading standard stats)
  /* generic netlink info */
  #define ETHTOOL_GENL_NAME "ethtool"
  #define ETHTOOL_GENL_VERSION 1
diff --cc net/ethtool/Makefile
index c2dc9033a8f7,723c9a8a8cdf..000000000000
--- a/net/ethtool/Makefile
+++ b/net/ethtool/Makefile
@@@ -7,4 -7,4 +7,8 @@@ obj-$(CONFIG_ETHTOOL_NETLINK)	+= ethtoo
  ethtool_nl-y	:= netlink.o bitset.o strset.o linkinfo.o linkmodes.o \
  		   linkstate.o debug.o wol.o features.o privflags.o rings.o \
  		   channels.o coalesce.o pause.o eee.o tsinfo.o cabletest.o \
++<<<<<<< HEAD
 +		   tunnels.o fec.o
++=======
+ 		   tunnels.o fec.o eeprom.o stats.o
++>>>>>>> f09ea6fb1272 (ethtool: add a new command for reading standard stats)
diff --cc net/ethtool/netlink.c
index 3e06c0c2f7e9,290012d0d11d..000000000000
--- a/net/ethtool/netlink.c
+++ b/net/ethtool/netlink.c
@@@ -246,6 -246,8 +246,11 @@@ ethnl_default_requests[__ETHTOOL_MSG_US
  	[ETHTOOL_MSG_EEE_GET]		= &ethnl_eee_request_ops,
  	[ETHTOOL_MSG_FEC_GET]		= &ethnl_fec_request_ops,
  	[ETHTOOL_MSG_TSINFO_GET]	= &ethnl_tsinfo_request_ops,
++<<<<<<< HEAD
++=======
+ 	[ETHTOOL_MSG_MODULE_EEPROM_GET]	= &ethnl_module_eeprom_request_ops,
+ 	[ETHTOOL_MSG_STATS_GET]		= &ethnl_stats_request_ops,
++>>>>>>> f09ea6fb1272 (ethtool: add a new command for reading standard stats)
  };
  
  static struct ethnl_dump_ctx *ethnl_dump_context(struct netlink_callback *cb)
@@@ -932,6 -933,25 +937,28 @@@ static const struct genl_ops ethtool_ge
  		.policy = ethnl_fec_set_policy,
  		.maxattr = ARRAY_SIZE(ethnl_fec_set_policy) - 1,
  	},
++<<<<<<< HEAD
++=======
+ 	{
+ 		.cmd	= ETHTOOL_MSG_MODULE_EEPROM_GET,
+ 		.flags  = GENL_UNS_ADMIN_PERM,
+ 		.doit	= ethnl_default_doit,
+ 		.start	= ethnl_default_start,
+ 		.dumpit	= ethnl_default_dumpit,
+ 		.done	= ethnl_default_done,
+ 		.policy = ethnl_module_eeprom_get_policy,
+ 		.maxattr = ARRAY_SIZE(ethnl_module_eeprom_get_policy) - 1,
+ 	},
+ 	{
+ 		.cmd	= ETHTOOL_MSG_STATS_GET,
+ 		.doit	= ethnl_default_doit,
+ 		.start	= ethnl_default_start,
+ 		.dumpit	= ethnl_default_dumpit,
+ 		.done	= ethnl_default_done,
+ 		.policy = ethnl_stats_get_policy,
+ 		.maxattr = ARRAY_SIZE(ethnl_stats_get_policy) - 1,
+ 	},
++>>>>>>> f09ea6fb1272 (ethtool: add a new command for reading standard stats)
  };
  
  static const struct genl_multicast_group ethtool_nl_mcgrps[] = {
diff --cc net/ethtool/netlink.h
index adf85e250953,9d88983b6597..000000000000
--- a/net/ethtool/netlink.h
+++ b/net/ethtool/netlink.h
@@@ -345,6 -345,8 +345,11 @@@ extern const struct ethnl_request_ops e
  extern const struct ethnl_request_ops ethnl_eee_request_ops;
  extern const struct ethnl_request_ops ethnl_tsinfo_request_ops;
  extern const struct ethnl_request_ops ethnl_fec_request_ops;
++<<<<<<< HEAD
++=======
+ extern const struct ethnl_request_ops ethnl_module_eeprom_request_ops;
+ extern const struct ethnl_request_ops ethnl_stats_request_ops;
++>>>>>>> f09ea6fb1272 (ethtool: add a new command for reading standard stats)
  
  extern const struct nla_policy ethnl_header_policy[ETHTOOL_A_HEADER_FLAGS + 1];
  extern const struct nla_policy ethnl_header_policy_stats[ETHTOOL_A_HEADER_FLAGS + 1];
@@@ -378,6 -380,8 +383,11 @@@ extern const struct nla_policy ethnl_ca
  extern const struct nla_policy ethnl_tunnel_info_get_policy[ETHTOOL_A_TUNNEL_INFO_HEADER + 1];
  extern const struct nla_policy ethnl_fec_get_policy[ETHTOOL_A_FEC_HEADER + 1];
  extern const struct nla_policy ethnl_fec_set_policy[ETHTOOL_A_FEC_AUTO + 1];
++<<<<<<< HEAD
++=======
+ extern const struct nla_policy ethnl_module_eeprom_get_policy[ETHTOOL_A_MODULE_EEPROM_DATA + 1];
+ extern const struct nla_policy ethnl_stats_get_policy[ETHTOOL_A_STATS_GROUPS + 1];
++>>>>>>> f09ea6fb1272 (ethtool: add a new command for reading standard stats)
  
  int ethnl_set_linkinfo(struct sk_buff *skb, struct genl_info *info);
  int ethnl_set_linkmodes(struct sk_buff *skb, struct genl_info *info);
* Unmerged path include/linux/ethtool.h
diff --git a/include/uapi/linux/ethtool.h b/include/uapi/linux/ethtool.h
index a60adc2dff9f..4ec9724837e5 100644
--- a/include/uapi/linux/ethtool.h
+++ b/include/uapi/linux/ethtool.h
@@ -673,6 +673,8 @@ enum ethtool_link_ext_substate_cable_issue {
  * @ETH_SS_TS_TX_TYPES: timestamping Tx types
  * @ETH_SS_TS_RX_FILTERS: timestamping Rx filters
  * @ETH_SS_UDP_TUNNEL_TYPES: UDP tunnel types
+ * @ETH_SS_STATS_STD: standardized stats
+ * @ETH_SS_STATS_ETH_PHY: names of IEEE 802.3 PHY statistics
  *
  * @ETH_SS_COUNT: number of defined string sets
  */
@@ -693,6 +695,8 @@ enum ethtool_stringset {
 	ETH_SS_TS_TX_TYPES,
 	ETH_SS_TS_RX_FILTERS,
 	ETH_SS_UDP_TUNNEL_TYPES,
+	ETH_SS_STATS_STD,
+	ETH_SS_STATS_ETH_PHY,
 
 	/* add new constants above here */
 	ETH_SS_COUNT
* Unmerged path include/uapi/linux/ethtool_netlink.h
* Unmerged path net/ethtool/Makefile
* Unmerged path net/ethtool/netlink.c
* Unmerged path net/ethtool/netlink.h
diff --git a/net/ethtool/stats.c b/net/ethtool/stats.c
new file mode 100644
index 000000000000..fd8f47178c06
--- /dev/null
+++ b/net/ethtool/stats.c
@@ -0,0 +1,200 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include "netlink.h"
+#include "common.h"
+#include "bitset.h"
+
+struct stats_req_info {
+	struct ethnl_req_info		base;
+	DECLARE_BITMAP(stat_mask, __ETHTOOL_STATS_CNT);
+};
+
+#define STATS_REQINFO(__req_base) \
+	container_of(__req_base, struct stats_req_info, base)
+
+struct stats_reply_data {
+	struct ethnl_reply_data		base;
+	struct ethtool_eth_phy_stats	phy_stats;
+};
+
+#define STATS_REPDATA(__reply_base) \
+	container_of(__reply_base, struct stats_reply_data, base)
+
+const char stats_std_names[__ETHTOOL_STATS_CNT][ETH_GSTRING_LEN] = {
+	[ETHTOOL_STATS_ETH_PHY]			= "eth-phy",
+};
+
+const char stats_eth_phy_names[__ETHTOOL_A_STATS_ETH_PHY_CNT][ETH_GSTRING_LEN] = {
+	[ETHTOOL_A_STATS_ETH_PHY_5_SYM_ERR]	= "SymbolErrorDuringCarrier",
+};
+
+const struct nla_policy ethnl_stats_get_policy[ETHTOOL_A_STATS_GROUPS + 1] = {
+	[ETHTOOL_A_STATS_HEADER]	=
+		NLA_POLICY_NESTED(ethnl_header_policy),
+	[ETHTOOL_A_STATS_GROUPS]	= { .type = NLA_NESTED },
+};
+
+static int stats_parse_request(struct ethnl_req_info *req_base,
+			       struct nlattr **tb,
+			       struct netlink_ext_ack *extack)
+{
+	struct stats_req_info *req_info = STATS_REQINFO(req_base);
+	bool mod = false;
+	int err;
+
+	err = ethnl_update_bitset(req_info->stat_mask, __ETHTOOL_STATS_CNT,
+				  tb[ETHTOOL_A_STATS_GROUPS], stats_std_names,
+				  extack, &mod);
+	if (err)
+		return err;
+
+	if (!mod) {
+		NL_SET_ERR_MSG(extack, "no stats requested");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int stats_prepare_data(const struct ethnl_req_info *req_base,
+			      struct ethnl_reply_data *reply_base,
+			      struct genl_info *info)
+{
+	const struct stats_req_info *req_info = STATS_REQINFO(req_base);
+	struct stats_reply_data *data = STATS_REPDATA(reply_base);
+	struct net_device *dev = reply_base->dev;
+	int ret;
+
+	ret = ethnl_ops_begin(dev);
+	if (ret < 0)
+		return ret;
+
+	memset(&data->phy_stats, 0xff, sizeof(data->phy_stats));
+
+	if (test_bit(ETHTOOL_STATS_ETH_PHY, req_info->stat_mask) &&
+	    dev->ethtool_ops->get_eth_phy_stats)
+		dev->ethtool_ops->get_eth_phy_stats(dev, &data->phy_stats);
+
+	ethnl_ops_complete(dev);
+	return 0;
+}
+
+static int stats_reply_size(const struct ethnl_req_info *req_base,
+			    const struct ethnl_reply_data *reply_base)
+{
+	const struct stats_req_info *req_info = STATS_REQINFO(req_base);
+	unsigned int n_grps = 0, n_stats = 0;
+	int len = 0;
+
+	if (test_bit(ETHTOOL_STATS_ETH_PHY, req_info->stat_mask)) {
+		n_stats += sizeof(struct ethtool_eth_phy_stats) / sizeof(u64);
+		n_grps++;
+	}
+
+	len += n_grps * (nla_total_size(0) + /* _A_STATS_GRP */
+			 nla_total_size(4) + /* _A_STATS_GRP_ID */
+			 nla_total_size(4)); /* _A_STATS_GRP_SS_ID */
+	len += n_stats * (nla_total_size(0) + /* _A_STATS_GRP_STAT */
+			  nla_total_size_64bit(sizeof(u64)));
+
+	return len;
+}
+
+static int stat_put(struct sk_buff *skb, u16 attrtype, u64 val)
+{
+	struct nlattr *nest;
+	int ret;
+
+	if (val == ETHTOOL_STAT_NOT_SET)
+		return 0;
+
+	/* We want to start stats attr types from 0, so we don't have a type
+	 * for pad inside ETHTOOL_A_STATS_GRP_STAT. Pad things on the outside
+	 * of ETHTOOL_A_STATS_GRP_STAT. Since we're one nest away from the
+	 * actual attr we're 4B off - nla_need_padding_for_64bit() & co.
+	 * can't be used.
+	 */
+#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
+	if (!IS_ALIGNED((unsigned long)skb_tail_pointer(skb), 8))
+		if (!nla_reserve(skb, ETHTOOL_A_STATS_GRP_PAD, 0))
+			return -EMSGSIZE;
+#endif
+
+	nest = nla_nest_start(skb, ETHTOOL_A_STATS_GRP_STAT);
+	if (!nest)
+		return -EMSGSIZE;
+
+	ret = nla_put_u64_64bit(skb, attrtype, val, -1 /* not used */);
+	if (ret) {
+		nla_nest_cancel(skb, nest);
+		return ret;
+	}
+
+	nla_nest_end(skb, nest);
+	return 0;
+}
+
+static int stats_put_phy_stats(struct sk_buff *skb,
+			       const struct stats_reply_data *data)
+{
+	if (stat_put(skb, ETHTOOL_A_STATS_ETH_PHY_5_SYM_ERR,
+		     data->phy_stats.SymbolErrorDuringCarrier))
+		return -EMSGSIZE;
+	return 0;
+}
+
+static int stats_put_stats(struct sk_buff *skb,
+			   const struct stats_reply_data *data,
+			   u32 id, u32 ss_id,
+			   int (*cb)(struct sk_buff *skb,
+				     const struct stats_reply_data *data))
+{
+	struct nlattr *nest;
+
+	nest = nla_nest_start(skb, ETHTOOL_A_STATS_GRP);
+	if (!nest)
+		return -EMSGSIZE;
+
+	if (nla_put_u32(skb, ETHTOOL_A_STATS_GRP_ID, id) ||
+	    nla_put_u32(skb, ETHTOOL_A_STATS_GRP_SS_ID, ss_id))
+		goto err_cancel;
+
+	if (cb(skb, data))
+		goto err_cancel;
+
+	nla_nest_end(skb, nest);
+	return 0;
+
+err_cancel:
+	nla_nest_cancel(skb, nest);
+	return -EMSGSIZE;
+}
+
+static int stats_fill_reply(struct sk_buff *skb,
+			    const struct ethnl_req_info *req_base,
+			    const struct ethnl_reply_data *reply_base)
+{
+	const struct stats_req_info *req_info = STATS_REQINFO(req_base);
+	const struct stats_reply_data *data = STATS_REPDATA(reply_base);
+	int ret = 0;
+
+	if (!ret && test_bit(ETHTOOL_STATS_ETH_PHY, req_info->stat_mask))
+		ret = stats_put_stats(skb, data, ETHTOOL_STATS_ETH_PHY,
+				      ETH_SS_STATS_ETH_PHY,
+				      stats_put_phy_stats);
+
+	return ret;
+}
+
+const struct ethnl_request_ops ethnl_stats_request_ops = {
+	.request_cmd		= ETHTOOL_MSG_STATS_GET,
+	.reply_cmd		= ETHTOOL_MSG_STATS_GET_REPLY,
+	.hdr_attr		= ETHTOOL_A_STATS_HEADER,
+	.req_info_size		= sizeof(struct stats_req_info),
+	.reply_data_size	= sizeof(struct stats_reply_data),
+
+	.parse_request		= stats_parse_request,
+	.prepare_data		= stats_prepare_data,
+	.reply_size		= stats_reply_size,
+	.fill_reply		= stats_fill_reply,
+};
diff --git a/net/ethtool/strset.c b/net/ethtool/strset.c
index 9908b922cce8..0eb70e8cc024 100644
--- a/net/ethtool/strset.c
+++ b/net/ethtool/strset.c
@@ -80,6 +80,16 @@ static const struct strset_info info_template[] = {
 		.count		= __ETHTOOL_UDP_TUNNEL_TYPE_CNT,
 		.strings	= udp_tunnel_type_names,
 	},
+	[ETH_SS_STATS_STD] = {
+		.per_dev	= false,
+		.count		= __ETHTOOL_STATS_CNT,
+		.strings	= stats_std_names,
+	},
+	[ETH_SS_STATS_ETH_PHY] = {
+		.per_dev	= false,
+		.count		= __ETHTOOL_A_STATS_ETH_PHY_CNT,
+		.strings	= stats_eth_phy_names,
+	},
 };
 
 struct strset_req_info {
