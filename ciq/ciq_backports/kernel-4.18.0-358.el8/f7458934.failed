net: bridge: mrp: Update the Test frames for MRA

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Horatiu Vultur <horatiu.vultur@microchip.com>
commit f7458934b0791c39a001e4d902fc3bf697b439b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/f7458934.failed

According to the standard IEC 62439-2, in case the node behaves as MRA
and needs to send Test frames on ring ports, then these Test frames need
to have an Option TLV and a Sub-Option TLV which has the type AUTO_MGR.

	Signed-off-by: Horatiu Vultur <horatiu.vultur@microchip.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f7458934b0791c39a001e4d902fc3bf697b439b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_private_mrp.h
diff --cc net/bridge/br_private_mrp.h
index c01588ee2685,bda8e1896712..000000000000
--- a/net/bridge/br_private_mrp.h
+++ b/net/bridge/br_private_mrp.h
@@@ -6,9 -6,11 +6,11 @@@
  #include "br_private.h"
  #include <uapi/linux/mrp_bridge.h>
  
+ #define MRP_OPT_PADDING		0x2
+ 
  struct br_mrp {
  	/* list of mrp instances */
 -	struct hlist_node		list;
 +	struct list_head		__rcu list;
  
  	struct net_bridge_port __rcu	*p_port;
  	struct net_bridge_port __rcu	*s_port;
@@@ -82,4 -107,42 +84,45 @@@ int br_mrp_switchdev_send_in_test(struc
  int br_mrp_ring_port_open(struct net_device *dev, u8 loc);
  int br_mrp_in_port_open(struct net_device *dev, u8 loc);
  
++<<<<<<< HEAD
++=======
+ /* MRP protocol data units */
+ struct br_mrp_tlv_hdr {
+ 	__u8 type;
+ 	__u8 length;
+ };
+ 
+ struct br_mrp_common_hdr {
+ 	__be16 seq_id;
+ 	__u8 domain[MRP_DOMAIN_UUID_LENGTH];
+ };
+ 
+ struct br_mrp_ring_test_hdr {
+ 	__be16 prio;
+ 	__u8 sa[ETH_ALEN];
+ 	__be16 port_role;
+ 	__be16 state;
+ 	__be16 transitions;
+ 	__be32 timestamp;
+ } __attribute__((__packed__));
+ 
+ struct br_mrp_in_test_hdr {
+ 	__be16 id;
+ 	__u8 sa[ETH_ALEN];
+ 	__be16 port_role;
+ 	__be16 state;
+ 	__be16 transitions;
+ 	__be32 timestamp;
+ } __attribute__((__packed__));
+ 
+ struct br_mrp_oui_hdr {
+ 	__u8 oui[MRP_OUI_LENGTH];
+ };
+ 
+ struct br_mrp_sub_option1_hdr {
+ 	__u8 type;
+ 	__u8 data[MRP_MANUFACTURE_DATA_LENGTH];
+ };
+ 
++>>>>>>> f7458934b079 (net: bridge: mrp: Update the Test frames for MRA)
  #endif /* _BR_PRIVATE_MRP_H */
diff --git a/net/bridge/br_mrp.c b/net/bridge/br_mrp.c
index abe4029a84d1..1945dc83c50c 100644
--- a/net/bridge/br_mrp.c
+++ b/net/bridge/br_mrp.c
@@ -155,6 +155,33 @@ static struct sk_buff *br_mrp_alloc_test_skb(struct br_mrp *mrp,
 	hdr->timestamp = cpu_to_be32(jiffies_to_msecs(jiffies));
 
 	br_mrp_skb_common(skb, mrp);
+
+	/* In case the node behaves as MRA then the Test frame needs to have
+	 * an Option TLV which includes eventually a sub-option TLV that has
+	 * the type AUTO_MGR
+	 */
+	if (mrp->ring_role == BR_MRP_RING_ROLE_MRA) {
+		struct br_mrp_sub_option1_hdr *sub_opt = NULL;
+		struct br_mrp_tlv_hdr *sub_tlv = NULL;
+		struct br_mrp_oui_hdr *oui = NULL;
+		u8 length;
+
+		length = sizeof(*sub_opt) + sizeof(*sub_tlv) + sizeof(oui) +
+			MRP_OPT_PADDING;
+		br_mrp_skb_tlv(skb, BR_MRP_TLV_HEADER_OPTION, length);
+
+		oui = skb_put(skb, sizeof(*oui));
+		memset(oui, 0x0, sizeof(*oui));
+		sub_opt = skb_put(skb, sizeof(*sub_opt));
+		memset(sub_opt, 0x0, sizeof(*sub_opt));
+
+		sub_tlv = skb_put(skb, sizeof(*sub_tlv));
+		sub_tlv->type = BR_MRP_SUB_TLV_HEADER_TEST_AUTO_MGR;
+
+		/* 32 bit alligment shall be ensured therefore add 2 bytes */
+		skb_put(skb, MRP_OPT_PADDING);
+	}
+
 	br_mrp_skb_tlv(skb, BR_MRP_TLV_HEADER_END, 0x0);
 
 	return skb;
* Unmerged path net/bridge/br_private_mrp.h
