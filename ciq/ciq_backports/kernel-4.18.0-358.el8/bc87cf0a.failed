trace: Add a generic function to read/write u64 values from tracefs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Daniel Bristot de Oliveira <bristot@redhat.com>
commit bc87cf0a08d437ea192b15f0918cb581a8698f15
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/bc87cf0a.failed

The hwlat detector and (in preparation for) the osnoise/timerlat tracers
have a set of u64 parameters that the user can read/write via tracefs.
For instance, we have hwlat_detector's window and width.

To reduce the code duplication, hwlat's window and width share the same
read function. However, they do not share the write functions because
they do different parameter checks. For instance, the width needs to
be smaller than the window, while the window needs to be larger
than the window. The same pattern repeats on osnoise/timerlat, and
a large portion of the code was devoted to the write function.

Despite having different checks, the write functions have the same
structure:

   read a user-space buffer
   take the lock that protects the value
   check for minimum and maximum acceptable values
      save the value
   release the lock
   return success or error

To reduce the code duplication also in the write functions, this patch
provides a generic read and write implementation for u64 values that
need to be within some minimum and/or maximum parameters, while
(potentially) being protected by a lock.

To use this interface, the structure trace_min_max_param needs to be
filled:

 struct trace_min_max_param {
         struct mutex    *lock;
         u64             *val;
         u64             *min;
         u64             *max;
 };

The desired value is stored on the variable pointed by *val. If *min
points to a minimum acceptable value, it will be checked during the
write operation. Likewise, if *max points to a maximum allowable value,
it will be checked during the write operation. Finally, if *lock points
to a mutex, it will be taken at the beginning of the operation and
released at the end.

The definition of a trace_min_max_param needs to passed as the
(private) *data for tracefs_create_file(), and the trace_min_max_fops
(added by this patch) as the *fops file_operations.

Link: https://lkml.kernel.org/r/3e35760a7c8b5c55f16ae5ad5fc54a0e71cbe647.1624372313.git.bristot@redhat.com

	Cc: Phil Auld <pauld@redhat.com>
	Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Cc: Kate Carcia <kcarcia@redhat.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Alexandre Chartre <alexandre.chartre@oracle.com>
	Cc: Clark Willaims <williams@redhat.com>
	Cc: John Kacur <jkacur@redhat.com>
	Cc: Juri Lelli <juri.lelli@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: x86@kernel.org
	Cc: linux-doc@vger.kernel.org
	Cc: linux-kernel@vger.kernel.org
	Signed-off-by: Daniel Bristot de Oliveira <bristot@redhat.com>
	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit bc87cf0a08d437ea192b15f0918cb581a8698f15)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace.c
#	kernel/trace/trace.h
diff --cc kernel/trace/trace.c
index 3efee662ba03,27bf203ef05a..000000000000
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@@ -6657,6 -7583,336 +6657,339 @@@ static const struct file_operations sna
  
  #endif /* CONFIG_TRACER_SNAPSHOT */
  
++<<<<<<< HEAD
++=======
+ /*
+  * trace_min_max_write - Write a u64 value to a trace_min_max_param struct
+  * @filp: The active open file structure
+  * @ubuf: The userspace provided buffer to read value into
+  * @cnt: The maximum number of bytes to read
+  * @ppos: The current "file" position
+  *
+  * This function implements the write interface for a struct trace_min_max_param.
+  * The filp->private_data must point to a trace_min_max_param structure that
+  * defines where to write the value, the min and the max acceptable values,
+  * and a lock to protect the write.
+  */
+ static ssize_t
+ trace_min_max_write(struct file *filp, const char __user *ubuf, size_t cnt, loff_t *ppos)
+ {
+ 	struct trace_min_max_param *param = filp->private_data;
+ 	u64 val;
+ 	int err;
+ 
+ 	if (!param)
+ 		return -EFAULT;
+ 
+ 	err = kstrtoull_from_user(ubuf, cnt, 10, &val);
+ 	if (err)
+ 		return err;
+ 
+ 	if (param->lock)
+ 		mutex_lock(param->lock);
+ 
+ 	if (param->min && val < *param->min)
+ 		err = -EINVAL;
+ 
+ 	if (param->max && val > *param->max)
+ 		err = -EINVAL;
+ 
+ 	if (!err)
+ 		*param->val = val;
+ 
+ 	if (param->lock)
+ 		mutex_unlock(param->lock);
+ 
+ 	if (err)
+ 		return err;
+ 
+ 	return cnt;
+ }
+ 
+ /*
+  * trace_min_max_read - Read a u64 value from a trace_min_max_param struct
+  * @filp: The active open file structure
+  * @ubuf: The userspace provided buffer to read value into
+  * @cnt: The maximum number of bytes to read
+  * @ppos: The current "file" position
+  *
+  * This function implements the read interface for a struct trace_min_max_param.
+  * The filp->private_data must point to a trace_min_max_param struct with valid
+  * data.
+  */
+ static ssize_t
+ trace_min_max_read(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppos)
+ {
+ 	struct trace_min_max_param *param = filp->private_data;
+ 	char buf[U64_STR_SIZE];
+ 	int len;
+ 	u64 val;
+ 
+ 	if (!param)
+ 		return -EFAULT;
+ 
+ 	val = *param->val;
+ 
+ 	if (cnt > sizeof(buf))
+ 		cnt = sizeof(buf);
+ 
+ 	len = snprintf(buf, sizeof(buf), "%llu\n", val);
+ 
+ 	return simple_read_from_buffer(ubuf, cnt, ppos, buf, len);
+ }
+ 
+ const struct file_operations trace_min_max_fops = {
+ 	.open		= tracing_open_generic,
+ 	.read		= trace_min_max_read,
+ 	.write		= trace_min_max_write,
+ };
+ 
+ #define TRACING_LOG_ERRS_MAX	8
+ #define TRACING_LOG_LOC_MAX	128
+ 
+ #define CMD_PREFIX "  Command: "
+ 
+ struct err_info {
+ 	const char	**errs;	/* ptr to loc-specific array of err strings */
+ 	u8		type;	/* index into errs -> specific err string */
+ 	u8		pos;	/* MAX_FILTER_STR_VAL = 256 */
+ 	u64		ts;
+ };
+ 
+ struct tracing_log_err {
+ 	struct list_head	list;
+ 	struct err_info		info;
+ 	char			loc[TRACING_LOG_LOC_MAX]; /* err location */
+ 	char			cmd[MAX_FILTER_STR_VAL]; /* what caused err */
+ };
+ 
+ static DEFINE_MUTEX(tracing_err_log_lock);
+ 
+ static struct tracing_log_err *get_tracing_log_err(struct trace_array *tr)
+ {
+ 	struct tracing_log_err *err;
+ 
+ 	if (tr->n_err_log_entries < TRACING_LOG_ERRS_MAX) {
+ 		err = kzalloc(sizeof(*err), GFP_KERNEL);
+ 		if (!err)
+ 			err = ERR_PTR(-ENOMEM);
+ 		tr->n_err_log_entries++;
+ 
+ 		return err;
+ 	}
+ 
+ 	err = list_first_entry(&tr->err_log, struct tracing_log_err, list);
+ 	list_del(&err->list);
+ 
+ 	return err;
+ }
+ 
+ /**
+  * err_pos - find the position of a string within a command for error careting
+  * @cmd: The tracing command that caused the error
+  * @str: The string to position the caret at within @cmd
+  *
+  * Finds the position of the first occurrence of @str within @cmd.  The
+  * return value can be passed to tracing_log_err() for caret placement
+  * within @cmd.
+  *
+  * Returns the index within @cmd of the first occurrence of @str or 0
+  * if @str was not found.
+  */
+ unsigned int err_pos(char *cmd, const char *str)
+ {
+ 	char *found;
+ 
+ 	if (WARN_ON(!strlen(cmd)))
+ 		return 0;
+ 
+ 	found = strstr(cmd, str);
+ 	if (found)
+ 		return found - cmd;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * tracing_log_err - write an error to the tracing error log
+  * @tr: The associated trace array for the error (NULL for top level array)
+  * @loc: A string describing where the error occurred
+  * @cmd: The tracing command that caused the error
+  * @errs: The array of loc-specific static error strings
+  * @type: The index into errs[], which produces the specific static err string
+  * @pos: The position the caret should be placed in the cmd
+  *
+  * Writes an error into tracing/error_log of the form:
+  *
+  * <loc>: error: <text>
+  *   Command: <cmd>
+  *              ^
+  *
+  * tracing/error_log is a small log file containing the last
+  * TRACING_LOG_ERRS_MAX errors (8).  Memory for errors isn't allocated
+  * unless there has been a tracing error, and the error log can be
+  * cleared and have its memory freed by writing the empty string in
+  * truncation mode to it i.e. echo > tracing/error_log.
+  *
+  * NOTE: the @errs array along with the @type param are used to
+  * produce a static error string - this string is not copied and saved
+  * when the error is logged - only a pointer to it is saved.  See
+  * existing callers for examples of how static strings are typically
+  * defined for use with tracing_log_err().
+  */
+ void tracing_log_err(struct trace_array *tr,
+ 		     const char *loc, const char *cmd,
+ 		     const char **errs, u8 type, u8 pos)
+ {
+ 	struct tracing_log_err *err;
+ 
+ 	if (!tr)
+ 		tr = &global_trace;
+ 
+ 	mutex_lock(&tracing_err_log_lock);
+ 	err = get_tracing_log_err(tr);
+ 	if (PTR_ERR(err) == -ENOMEM) {
+ 		mutex_unlock(&tracing_err_log_lock);
+ 		return;
+ 	}
+ 
+ 	snprintf(err->loc, TRACING_LOG_LOC_MAX, "%s: error: ", loc);
+ 	snprintf(err->cmd, MAX_FILTER_STR_VAL,"\n" CMD_PREFIX "%s\n", cmd);
+ 
+ 	err->info.errs = errs;
+ 	err->info.type = type;
+ 	err->info.pos = pos;
+ 	err->info.ts = local_clock();
+ 
+ 	list_add_tail(&err->list, &tr->err_log);
+ 	mutex_unlock(&tracing_err_log_lock);
+ }
+ 
+ static void clear_tracing_err_log(struct trace_array *tr)
+ {
+ 	struct tracing_log_err *err, *next;
+ 
+ 	mutex_lock(&tracing_err_log_lock);
+ 	list_for_each_entry_safe(err, next, &tr->err_log, list) {
+ 		list_del(&err->list);
+ 		kfree(err);
+ 	}
+ 
+ 	tr->n_err_log_entries = 0;
+ 	mutex_unlock(&tracing_err_log_lock);
+ }
+ 
+ static void *tracing_err_log_seq_start(struct seq_file *m, loff_t *pos)
+ {
+ 	struct trace_array *tr = m->private;
+ 
+ 	mutex_lock(&tracing_err_log_lock);
+ 
+ 	return seq_list_start(&tr->err_log, *pos);
+ }
+ 
+ static void *tracing_err_log_seq_next(struct seq_file *m, void *v, loff_t *pos)
+ {
+ 	struct trace_array *tr = m->private;
+ 
+ 	return seq_list_next(v, &tr->err_log, pos);
+ }
+ 
+ static void tracing_err_log_seq_stop(struct seq_file *m, void *v)
+ {
+ 	mutex_unlock(&tracing_err_log_lock);
+ }
+ 
+ static void tracing_err_log_show_pos(struct seq_file *m, u8 pos)
+ {
+ 	u8 i;
+ 
+ 	for (i = 0; i < sizeof(CMD_PREFIX) - 1; i++)
+ 		seq_putc(m, ' ');
+ 	for (i = 0; i < pos; i++)
+ 		seq_putc(m, ' ');
+ 	seq_puts(m, "^\n");
+ }
+ 
+ static int tracing_err_log_seq_show(struct seq_file *m, void *v)
+ {
+ 	struct tracing_log_err *err = v;
+ 
+ 	if (err) {
+ 		const char *err_text = err->info.errs[err->info.type];
+ 		u64 sec = err->info.ts;
+ 		u32 nsec;
+ 
+ 		nsec = do_div(sec, NSEC_PER_SEC);
+ 		seq_printf(m, "[%5llu.%06u] %s%s", sec, nsec / 1000,
+ 			   err->loc, err_text);
+ 		seq_printf(m, "%s", err->cmd);
+ 		tracing_err_log_show_pos(m, err->info.pos);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static const struct seq_operations tracing_err_log_seq_ops = {
+ 	.start  = tracing_err_log_seq_start,
+ 	.next   = tracing_err_log_seq_next,
+ 	.stop   = tracing_err_log_seq_stop,
+ 	.show   = tracing_err_log_seq_show
+ };
+ 
+ static int tracing_err_log_open(struct inode *inode, struct file *file)
+ {
+ 	struct trace_array *tr = inode->i_private;
+ 	int ret = 0;
+ 
+ 	ret = tracing_check_open_get_tr(tr);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* If this file was opened for write, then erase contents */
+ 	if ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC))
+ 		clear_tracing_err_log(tr);
+ 
+ 	if (file->f_mode & FMODE_READ) {
+ 		ret = seq_open(file, &tracing_err_log_seq_ops);
+ 		if (!ret) {
+ 			struct seq_file *m = file->private_data;
+ 			m->private = tr;
+ 		} else {
+ 			trace_array_put(tr);
+ 		}
+ 	}
+ 	return ret;
+ }
+ 
+ static ssize_t tracing_err_log_write(struct file *file,
+ 				     const char __user *buffer,
+ 				     size_t count, loff_t *ppos)
+ {
+ 	return count;
+ }
+ 
+ static int tracing_err_log_release(struct inode *inode, struct file *file)
+ {
+ 	struct trace_array *tr = inode->i_private;
+ 
+ 	trace_array_put(tr);
+ 
+ 	if (file->f_mode & FMODE_READ)
+ 		seq_release(inode, file);
+ 
+ 	return 0;
+ }
+ 
+ static const struct file_operations tracing_err_log_fops = {
+ 	.open           = tracing_err_log_open,
+ 	.write		= tracing_err_log_write,
+ 	.read           = seq_read,
+ 	.llseek         = seq_lseek,
+ 	.release        = tracing_err_log_release,
+ };
+ 
++>>>>>>> bc87cf0a08d4 (trace: Add a generic function to read/write u64 values from tracefs)
  static int tracing_buffers_open(struct inode *inode, struct file *filp)
  {
  	struct trace_array *tr = inode->i_private;
diff --cc kernel/trace/trace.h
index d08237c45b3a,22f8c652ef8b..000000000000
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@@ -1912,4 -1922,52 +1912,55 @@@ static inline void tracer_hardirqs_off(
  
  extern struct trace_iterator *tracepoint_print_iter;
  
++<<<<<<< HEAD
++=======
+ /*
+  * Reset the state of the trace_iterator so that it can read consumed data.
+  * Normally, the trace_iterator is used for reading the data when it is not
+  * consumed, and must retain state.
+  */
+ static __always_inline void trace_iterator_reset(struct trace_iterator *iter)
+ {
+ 	const size_t offset = offsetof(struct trace_iterator, seq);
+ 
+ 	/*
+ 	 * Keep gcc from complaining about overwriting more than just one
+ 	 * member in the structure.
+ 	 */
+ 	memset((char *)iter + offset, 0, sizeof(struct trace_iterator) - offset);
+ 
+ 	iter->pos = -1;
+ }
+ 
+ /* Check the name is good for event/group/fields */
+ static inline bool is_good_name(const char *name)
+ {
+ 	if (!isalpha(*name) && *name != '_')
+ 		return false;
+ 	while (*++name != '\0') {
+ 		if (!isalpha(*name) && !isdigit(*name) && *name != '_')
+ 			return false;
+ 	}
+ 	return true;
+ }
+ 
+ /*
+  * This is a generic way to read and write a u64 value from a file in tracefs.
+  *
+  * The value is stored on the variable pointed by *val. The value needs
+  * to be at least *min and at most *max. The write is protected by an
+  * existing *lock.
+  */
+ struct trace_min_max_param {
+ 	struct mutex	*lock;
+ 	u64		*val;
+ 	u64		*min;
+ 	u64		*max;
+ };
+ 
+ #define U64_STR_SIZE		24	/* 20 digits max */
+ 
+ extern const struct file_operations trace_min_max_fops;
+ 
++>>>>>>> bc87cf0a08d4 (trace: Add a generic function to read/write u64 values from tracefs)
  #endif /* _LINUX_KERNEL_TRACE_H */
* Unmerged path kernel/trace/trace.c
* Unmerged path kernel/trace/trace.h
