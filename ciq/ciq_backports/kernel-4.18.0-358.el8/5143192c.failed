mm/migrate: add a flags parameter to migrate_vma

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Ralph Campbell <rcampbell@nvidia.com>
commit 5143192cd410c4fc83be09a2e73423765aee072b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/5143192c.failed

The src_owner field in struct migrate_vma is being used for two purposes,
it acts as a selection filter for which types of pages are to be migrated
and it identifies device private pages owned by the caller.

Split this into separate parameters so the src_owner field can be used
just to identify device private pages owned by the caller of
migrate_vma_setup().

Rename the src_owner field to pgmap_owner to reflect it is now used only
to identify which device private pages to migrate.

Link: https://lore.kernel.org/r/20200723223004.9586-3-rcampbell@nvidia.com
	Signed-off-by: Ralph Campbell <rcampbell@nvidia.com>
	Reviewed-by: Bharata B Rao <bharata@linux.ibm.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 5143192cd410c4fc83be09a2e73423765aee072b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_hv_uvmem.c
#	drivers/gpu/drm/nouveau/nouveau_dmem.c
#	lib/test_hmm.c
diff --cc arch/powerpc/kvm/book3s_hv_uvmem.c
index c4c1823f928e,6850bd04bcb9..000000000000
--- a/arch/powerpc/kvm/book3s_hv_uvmem.c
+++ b/arch/powerpc/kvm/book3s_hv_uvmem.c
@@@ -744,7 -400,20 +744,8 @@@ static int kvmppc_svm_page_in(struct vm
  	mig.end = end;
  	mig.src = &src_pfn;
  	mig.dst = &dst_pfn;
+ 	mig.flags = MIGRATE_VMA_SELECT_SYSTEM;
  
 -	/*
 -	 * We come here with mmap_lock write lock held just for
 -	 * ksm_madvise(), otherwise we only need read mmap_lock.
 -	 * Hence downgrade to read lock once ksm_madvise() is done.
 -	 */
 -	ret = ksm_madvise(vma, vma->vm_start, vma->vm_end,
 -			  MADV_UNMERGEABLE, &vma->vm_flags);
 -	mmap_write_downgrade(kvm->mm);
 -	*downgrade = true;
 -	if (ret)
 -		return ret;
 -
  	ret = migrate_vma_setup(&mig);
  	if (ret)
  		return ret;
@@@ -974,6 -556,83 +975,86 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Provision a new page on HV side and copy over the contents
+  * from secure memory using UV_PAGE_OUT uvcall.
+  */
+ static int
+ kvmppc_svm_page_out(struct vm_area_struct *vma, unsigned long start,
+ 		    unsigned long end, unsigned long page_shift,
+ 		    struct kvm *kvm, unsigned long gpa)
+ {
+ 	unsigned long src_pfn, dst_pfn = 0;
+ 	struct migrate_vma mig;
+ 	struct page *dpage, *spage;
+ 	struct kvmppc_uvmem_page_pvt *pvt;
+ 	unsigned long pfn;
+ 	int ret = U_SUCCESS;
+ 
+ 	memset(&mig, 0, sizeof(mig));
+ 	mig.vma = vma;
+ 	mig.start = start;
+ 	mig.end = end;
+ 	mig.src = &src_pfn;
+ 	mig.dst = &dst_pfn;
+ 	mig.pgmap_owner = &kvmppc_uvmem_pgmap;
+ 	mig.flags = MIGRATE_VMA_SELECT_DEVICE_PRIVATE;
+ 
+ 	mutex_lock(&kvm->arch.uvmem_lock);
+ 	/* The requested page is already paged-out, nothing to do */
+ 	if (!kvmppc_gfn_is_uvmem_pfn(gpa >> page_shift, kvm, NULL))
+ 		goto out;
+ 
+ 	ret = migrate_vma_setup(&mig);
+ 	if (ret)
+ 		goto out;
+ 
+ 	spage = migrate_pfn_to_page(*mig.src);
+ 	if (!spage || !(*mig.src & MIGRATE_PFN_MIGRATE))
+ 		goto out_finalize;
+ 
+ 	if (!is_zone_device_page(spage))
+ 		goto out_finalize;
+ 
+ 	dpage = alloc_page_vma(GFP_HIGHUSER, vma, start);
+ 	if (!dpage) {
+ 		ret = -1;
+ 		goto out_finalize;
+ 	}
+ 
+ 	lock_page(dpage);
+ 	pvt = spage->zone_device_data;
+ 	pfn = page_to_pfn(dpage);
+ 
+ 	/*
+ 	 * This function is used in two cases:
+ 	 * - When HV touches a secure page, for which we do UV_PAGE_OUT
+ 	 * - When a secure page is converted to shared page, we *get*
+ 	 *   the page to essentially unmap the device page. In this
+ 	 *   case we skip page-out.
+ 	 */
+ 	if (!pvt->skip_page_out)
+ 		ret = uv_page_out(kvm->arch.lpid, pfn << page_shift,
+ 				  gpa, 0, page_shift);
+ 
+ 	if (ret == U_SUCCESS)
+ 		*mig.dst = migrate_pfn(pfn) | MIGRATE_PFN_LOCKED;
+ 	else {
+ 		unlock_page(dpage);
+ 		__free_page(dpage);
+ 		goto out_finalize;
+ 	}
+ 
+ 	migrate_vma_pages(&mig);
+ out_finalize:
+ 	migrate_vma_finalize(&mig);
+ out:
+ 	mutex_unlock(&kvm->arch.uvmem_lock);
+ 	return ret;
+ }
++>>>>>>> 5143192cd410 (mm/migrate: add a flags parameter to migrate_vma)
  
  /*
   * Fault handler callback that gets called when HV touches any page that
diff --cc drivers/gpu/drm/nouveau/nouveau_dmem.c
index 92987daa5e17,78b9e3c2a5b3..000000000000
--- a/drivers/gpu/drm/nouveau/nouveau_dmem.c
+++ b/drivers/gpu/drm/nouveau/nouveau_dmem.c
@@@ -653,7 -616,6 +653,10 @@@ nouveau_dmem_migrate_vma(struct nouveau
  	struct migrate_vma args = {
  		.vma		= vma,
  		.start		= start,
++<<<<<<< HEAD
 +		.pgmap_owner	= drm->dev,
++=======
++>>>>>>> 5143192cd410 (mm/migrate: add a flags parameter to migrate_vma)
  		.flags		= MIGRATE_VMA_SELECT_SYSTEM,
  	};
  	unsigned long i;
* Unmerged path lib/test_hmm.c
* Unmerged path arch/powerpc/kvm/book3s_hv_uvmem.c
* Unmerged path drivers/gpu/drm/nouveau/nouveau_dmem.c
diff --git a/include/linux/migrate.h b/include/linux/migrate.h
index 5d26156a9fa6..65434c04decd 100644
--- a/include/linux/migrate.h
+++ b/include/linux/migrate.h
@@ -159,6 +159,11 @@ static inline unsigned long migrate_pfn(unsigned long pfn)
 	return (pfn << MIGRATE_PFN_SHIFT) | MIGRATE_PFN_VALID;
 }
 
+enum migrate_vma_direction {
+	MIGRATE_VMA_SELECT_SYSTEM = 1 << 0,
+	MIGRATE_VMA_SELECT_DEVICE_PRIVATE = 1 << 1,
+};
+
 struct migrate_vma {
 	struct vm_area_struct	*vma;
 	/*
@@ -178,11 +183,11 @@ struct migrate_vma {
 
 	/*
 	 * Set to the owner value also stored in page->pgmap->owner for
-	 * migrating out of device private memory.  If set only device
-	 * private pages with this owner are migrated.  If not set
-	 * device private pages are not migrated at all.
+	 * migrating out of device private memory. The flags also need to
+	 * be set to MIGRATE_VMA_SELECT_DEVICE_PRIVATE.
 	 */
-	void			*src_owner;
+	void			*pgmap_owner;
+	unsigned long		flags;
 };
 
 int migrate_vma_setup(struct migrate_vma *args);
* Unmerged path lib/test_hmm.c
diff --git a/mm/migrate.c b/mm/migrate.c
index 6e0b070f8524..8b52f00dd4b4 100644
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@ -2338,7 +2338,9 @@ static int migrate_vma_collect_pmd(pmd_t *pmdp,
 				goto next;
 
 			page = device_private_entry_to_page(entry);
-			if (page->pgmap->owner != migrate->src_owner)
+			if (!(migrate->flags &
+				MIGRATE_VMA_SELECT_DEVICE_PRIVATE) ||
+			    page->pgmap->owner != migrate->pgmap_owner)
 				goto next;
 
 			mpfn = migrate_pfn(page_to_pfn(page)) |
@@ -2346,7 +2348,7 @@ static int migrate_vma_collect_pmd(pmd_t *pmdp,
 			if (is_write_device_private_entry(entry))
 				mpfn |= MIGRATE_PFN_WRITE;
 		} else {
-			if (migrate->src_owner)
+			if (!(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))
 				goto next;
 			pfn = pte_pfn(pte);
 			if (is_zero_pfn(pfn)) {
