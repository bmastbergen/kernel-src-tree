mm: memcontrol: bail out early when !mm in get_mem_cgroup_from_mm

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Muchun Song <songmuchun@bytedance.com>
commit 2884b6b7eed4fc14c0630fb16e56a4c66c786d33
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/2884b6b7.failed

When mm is NULL, we do not need to hold rcu lock and call css_tryget for
the root memcg.  And we also do not need to check !mm in every loop of
while.  So bail out early when !mm.

Link: https://lkml.kernel.org/r/20210417043538.9793-3-songmuchun@bytedance.com
	Signed-off-by: Muchun Song <songmuchun@bytedance.com>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
	Reviewed-by: Shakeel Butt <shakeelb@google.com>
	Acked-by: Roman Gushchin <guro@fb.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Cc: Xiongchun Duan <duanxiongchun@bytedance.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 2884b6b7eed4fc14c0630fb16e56a4c66c786d33)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index 4af0e7f1ab3a,babbaf49ee36..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -964,20 -919,23 +964,32 @@@ struct mem_cgroup *get_mem_cgroup_from_
  	if (mem_cgroup_disabled())
  		return NULL;
  
+ 	/*
+ 	 * Page cache insertions can happen without an
+ 	 * actual mm context, e.g. during disk probing
+ 	 * on boot, loopback IO, acct() writes etc.
+ 	 *
+ 	 * No need to css_get on root memcg as the reference
+ 	 * counting is disabled on the root level in the
+ 	 * cgroup core. See CSS_NO_REF.
+ 	 */
+ 	if (unlikely(!mm))
+ 		return root_mem_cgroup;
+ 
  	rcu_read_lock();
  	do {
++<<<<<<< HEAD
 +		/*
 +		 * Page cache insertions can happen withou an
 +		 * actual mm context, e.g. during disk probing
 +		 * on boot, loopback IO, acct() writes etc.
 +		 */
 +		if (unlikely(!mm))
++=======
+ 		memcg = mem_cgroup_from_task(rcu_dereference(mm->owner));
+ 		if (unlikely(!memcg))
++>>>>>>> 2884b6b7eed4 (mm: memcontrol: bail out early when !mm in get_mem_cgroup_from_mm)
  			memcg = root_mem_cgroup;
- 		else {
- 			memcg = mem_cgroup_from_task(rcu_dereference(mm->owner));
- 			if (unlikely(!memcg))
- 				memcg = root_mem_cgroup;
- 		}
  	} while (!css_tryget(&memcg->css));
  	rcu_read_unlock();
  	return memcg;
* Unmerged path mm/memcontrol.c
