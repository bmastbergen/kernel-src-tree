net: bridge: mcast: prepare expiry functions for mcast router split

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Linus Lüssing <linus.luessing@c0d3.blue>
commit ee5fb2223ee581676fe7e4e5a87481c419569454
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/ee5fb222.failed

In preparation for the upcoming split of multicast router state into
their IPv4 and IPv6 variants move the protocol specific timer access to
an ip4 wrapper function.

	Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ee5fb2223ee581676fe7e4e5a87481c419569454)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
diff --cc net/bridge/br_multicast.c
index 2827c70f9d21,781599155d8a..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -947,16 -1354,16 +947,25 @@@ static int br_ip6_multicast_add_group(s
  }
  #endif
  
- static void br_multicast_router_expired(struct timer_list *t)
+ static void br_multicast_router_expired(struct net_bridge_port *port,
+ 					struct timer_list *t,
+ 					struct hlist_node *rlist)
  {
++<<<<<<< HEAD
 +	struct net_bridge_port *port =
 +			from_timer(port, t, multicast_router_timer);
++=======
++>>>>>>> ee5fb2223ee5 (net: bridge: mcast: prepare expiry functions for mcast router split)
  	struct net_bridge *br = port->br;
  
  	spin_lock(&br->multicast_lock);
  	if (port->multicast_router == MDB_RTR_TYPE_DISABLED ||
  	    port->multicast_router == MDB_RTR_TYPE_PERM ||
++<<<<<<< HEAD
 +	    timer_pending(&port->multicast_router_timer))
++=======
+ 	    timer_pending(t))
++>>>>>>> ee5fb2223ee5 (net: bridge: mcast: prepare expiry functions for mcast router split)
  		goto out;
  
  	__del_port_router(port);
@@@ -974,13 -1388,12 +990,17 @@@ static void br_mc_router_state_change(s
  		.u.mrouter = is_mc_router,
  	};
  
 -	switchdev_port_attr_set(p->dev, &attr, NULL);
 +	switchdev_port_attr_set(p->dev, &attr);
  }
  
- static void br_multicast_local_router_expired(struct timer_list *t)
+ static void br_multicast_local_router_expired(struct net_bridge *br,
+ 					      struct timer_list *timer)
  {
++<<<<<<< HEAD
 +	struct net_bridge *br = from_timer(br, t, multicast_router_timer);
 +
++=======
++>>>>>>> ee5fb2223ee5 (net: bridge: mcast: prepare expiry functions for mcast router split)
  	spin_lock(&br->multicast_lock);
  	if (br->multicast_router == MDB_RTR_TYPE_DISABLED ||
  	    br->multicast_router == MDB_RTR_TYPE_PERM ||
@@@ -1200,10 -1622,13 +1227,15 @@@ static void br_mc_disabled_update(struc
  
  int br_multicast_add_port(struct net_bridge_port *port)
  {
 -	int err;
 -
  	port->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
 -	port->multicast_eht_hosts_limit = BR_MCAST_DEFAULT_EHT_HOSTS_LIMIT;
  
++<<<<<<< HEAD
 +	timer_setup(&port->multicast_router_timer,
 +		    br_multicast_router_expired, 0);
++=======
+ 	timer_setup(&port->ip4_mc_router_timer,
+ 		    br_ip4_multicast_router_expired, 0);
++>>>>>>> ee5fb2223ee5 (net: bridge: mcast: prepare expiry functions for mcast router split)
  	timer_setup(&port->ip4_own_query.timer,
  		    br_ip4_multicast_port_query_expired, 0);
  #if IS_ENABLED(CONFIG_IPV6)
@@@ -2821,8 -3331,8 +2853,13 @@@ void br_multicast_init(struct net_bridg
  	br_opt_toggle(br, BROPT_HAS_IPV6_ADDR, true);
  
  	spin_lock_init(&br->multicast_lock);
++<<<<<<< HEAD
 +	timer_setup(&br->multicast_router_timer,
 +		    br_multicast_local_router_expired, 0);
++=======
+ 	timer_setup(&br->ip4_mc_router_timer,
+ 		    br_ip4_multicast_local_router_expired, 0);
++>>>>>>> ee5fb2223ee5 (net: bridge: mcast: prepare expiry functions for mcast router split)
  	timer_setup(&br->ip4_other_query.timer,
  		    br_ip4_multicast_querier_expired, 0);
  	timer_setup(&br->ip4_own_query.timer,
* Unmerged path net/bridge/br_multicast.c
