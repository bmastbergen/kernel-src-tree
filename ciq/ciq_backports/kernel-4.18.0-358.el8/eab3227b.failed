net: bridge: mcast: rename br_ip's u member to dst

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit eab3227b1240bdcc06c0a01a3fc5bfd2bc12f406
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/eab3227b.failed

Since now we have src in br_ip, u no longer makes sense so rename
it to dst. No functional changes.

v2: fix build with CONFIG_BATMAN_ADV_MCAST

CC: Marek Lindner <mareklindner@neomailbox.ch>
CC: Simon Wunderlich <sw@simonwunderlich.de>
CC: Antonio Quartulli <a@unstable.cc>
CC: Sven Eckelmann <sven@narfation.org>
CC: b.a.t.m.a.n@lists.open-mesh.org
	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit eab3227b1240bdcc06c0a01a3fc5bfd2bc12f406)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/batman-adv/multicast.c
diff --cc net/batman-adv/multicast.c
index 3df51c7f8004,9af99c39b9fd..000000000000
--- a/net/batman-adv/multicast.c
+++ b/net/batman-adv/multicast.c
@@@ -123,73 -121,215 +123,125 @@@ static bool batadv_mcast_addr_is_ipv4(c
  }
  
  /**
 - * batadv_mcast_mla_rtr_flags_softif_get_ipv6() - get mcast router flags from
 - *  node for IPv6
 - * @dev: the interface to check
 + * batadv_mcast_addr_is_ipv6() - check if multicast MAC is IPv6
 + * @addr: the MAC address to check
   *
 - * Checks the presence of an IPv6 multicast router on this node.
 - *
 - * Caller needs to hold rcu read lock.
 - *
 - * Return: BATADV_NO_FLAGS if present, BATADV_MCAST_WANT_NO_RTR6 otherwise.
 + * Return: True, if MAC address is one reserved for IPv6 multicast, false
 + * otherwise.
   */
 -#if IS_ENABLED(CONFIG_IPV6_MROUTE)
 -static u8 batadv_mcast_mla_rtr_flags_softif_get_ipv6(struct net_device *dev)
 +static bool batadv_mcast_addr_is_ipv6(const u8 *addr)
  {
 -	struct inet6_dev *in6_dev = __in6_dev_get(dev);
 +	static const u8 prefix[] = {0x33, 0x33};
  
 -	if (in6_dev && in6_dev->cnf.mc_forwarding)
 -		return BATADV_NO_FLAGS;
 -	else
 -		return BATADV_MCAST_WANT_NO_RTR6;
 -}
 -#else
 -static inline u8
 -batadv_mcast_mla_rtr_flags_softif_get_ipv6(struct net_device *dev)
 -{
 -	return BATADV_MCAST_WANT_NO_RTR6;
 +	return memcmp(prefix, addr, sizeof(prefix)) == 0;
  }
 -#endif
  
  /**
 - * batadv_mcast_mla_rtr_flags_softif_get() - get mcast router flags from node
 + * batadv_mcast_mla_softif_get() - get softif multicast listeners
   * @bat_priv: the bat priv with all the soft interface information
 - * @bridge: bridge interface on top of the soft_iface if present,
 - *  otherwise pass NULL
 + * @dev: the device to collect multicast addresses from
 + * @mcast_list: a list to put found addresses into
   *
 - * Checks the presence of IPv4 and IPv6 multicast routers on this
 - * node.
 + * Collects multicast addresses of multicast listeners residing
 + * on this kernel on the given soft interface, dev, in
 + * the given mcast_list. In general, multicast listeners provided by
 + * your multicast receiving applications run directly on this node.
   *
 - * Return:
 - *	BATADV_NO_FLAGS: Both an IPv4 and IPv6 multicast router is present
 - *	BATADV_MCAST_WANT_NO_RTR4: No IPv4 multicast router is present
 - *	BATADV_MCAST_WANT_NO_RTR6: No IPv6 multicast router is present
 - *	The former two OR'd: no multicast router is present
 + * If there is a bridge interface on top of dev, collects from that one
 + * instead. Just like with IP addresses and routes, multicast listeners
 + * will(/should) register to the bridge interface instead of an
 + * enslaved bat0.
 + *
 + * Return: -ENOMEM on memory allocation error or the number of
 + * items added to the mcast_list otherwise.
   */
 -static u8 batadv_mcast_mla_rtr_flags_softif_get(struct batadv_priv *bat_priv,
 -						struct net_device *bridge)
 +static int batadv_mcast_mla_softif_get(struct batadv_priv *bat_priv,
 +				       struct net_device *dev,
 +				       struct hlist_head *mcast_list)
  {
 -	struct net_device *dev = bridge ? bridge : bat_priv->soft_iface;
 -	u8 flags = BATADV_NO_FLAGS;
 +	bool all_ipv4 = bat_priv->mcast.flags & BATADV_MCAST_WANT_ALL_IPV4;
 +	bool all_ipv6 = bat_priv->mcast.flags & BATADV_MCAST_WANT_ALL_IPV6;
 +	struct net_device *bridge = batadv_mcast_get_bridge(dev);
 +	struct netdev_hw_addr *mc_list_entry;
 +	struct batadv_hw_addr *new;
 +	int ret = 0;
  
 -	rcu_read_lock();
 +	netif_addr_lock_bh(bridge ? bridge : dev);
 +	netdev_for_each_mc_addr(mc_list_entry, bridge ? bridge : dev) {
 +		if (all_ipv4 && batadv_mcast_addr_is_ipv4(mc_list_entry->addr))
 +			continue;
  
 -	flags |= batadv_mcast_mla_rtr_flags_softif_get_ipv4(dev);
 -	flags |= batadv_mcast_mla_rtr_flags_softif_get_ipv6(dev);
 +		if (all_ipv6 && batadv_mcast_addr_is_ipv6(mc_list_entry->addr))
 +			continue;
  
 -	rcu_read_unlock();
 +		new = kmalloc(sizeof(*new), GFP_ATOMIC);
 +		if (!new) {
 +			ret = -ENOMEM;
 +			break;
 +		}
  
++<<<<<<< HEAD
 +		ether_addr_copy(new->addr, mc_list_entry->addr);
 +		hlist_add_head(&new->list, mcast_list);
 +		ret++;
++=======
+ 	return flags;
+ }
+ 
+ /**
+  * batadv_mcast_mla_rtr_flags_bridge_get() - get mcast router flags from bridge
+  * @bat_priv: the bat priv with all the soft interface information
+  * @bridge: bridge interface on top of the soft_iface if present,
+  *  otherwise pass NULL
+  *
+  * Checks the presence of IPv4 and IPv6 multicast routers behind a bridge.
+  *
+  * Return:
+  *	BATADV_NO_FLAGS: Both an IPv4 and IPv6 multicast router is present
+  *	BATADV_MCAST_WANT_NO_RTR4: No IPv4 multicast router is present
+  *	BATADV_MCAST_WANT_NO_RTR6: No IPv6 multicast router is present
+  *	The former two OR'd: no multicast router is present
+  */
+ #if IS_ENABLED(CONFIG_IPV6)
+ static u8 batadv_mcast_mla_rtr_flags_bridge_get(struct batadv_priv *bat_priv,
+ 						struct net_device *bridge)
+ {
+ 	struct list_head bridge_mcast_list = LIST_HEAD_INIT(bridge_mcast_list);
+ 	struct net_device *dev = bat_priv->soft_iface;
+ 	struct br_ip_list *br_ip_entry, *tmp;
+ 	u8 flags = BATADV_MCAST_WANT_NO_RTR6;
+ 	int ret;
+ 
+ 	if (!bridge)
+ 		return BATADV_MCAST_WANT_NO_RTR4 | BATADV_MCAST_WANT_NO_RTR6;
+ 
+ 	/* TODO: ask the bridge if a multicast router is present (the bridge
+ 	 * is capable of performing proper RFC4286 multicast router
+ 	 * discovery) instead of searching for a ff02::2 listener here
+ 	 */
+ 	ret = br_multicast_list_adjacent(dev, &bridge_mcast_list);
+ 	if (ret < 0)
+ 		return BATADV_NO_FLAGS;
+ 
+ 	list_for_each_entry_safe(br_ip_entry, tmp, &bridge_mcast_list, list) {
+ 		/* the bridge snooping does not maintain IPv4 link-local
+ 		 * addresses - therefore we won't find any IPv4 multicast router
+ 		 * address here, only IPv6 ones
+ 		 */
+ 		if (br_ip_entry->addr.proto == htons(ETH_P_IPV6) &&
+ 		    ipv6_addr_is_ll_all_routers(&br_ip_entry->addr.dst.ip6))
+ 			flags &= ~BATADV_MCAST_WANT_NO_RTR6;
+ 
+ 		list_del(&br_ip_entry->list);
+ 		kfree(br_ip_entry);
++>>>>>>> eab3227b1240 (net: bridge: mcast: rename br_ip's u member to dst)
  	}
 +	netif_addr_unlock_bh(bridge ? bridge : dev);
  
 -	return flags;
 -}
 -#else
 -static inline u8
 -batadv_mcast_mla_rtr_flags_bridge_get(struct batadv_priv *bat_priv,
 -				      struct net_device *bridge)
 -{
  	if (bridge)
 -		return BATADV_NO_FLAGS;
 -	else
 -		return BATADV_MCAST_WANT_NO_RTR4 | BATADV_MCAST_WANT_NO_RTR6;
 -}
 -#endif
 -
 -/**
 - * batadv_mcast_mla_rtr_flags_get() - get multicast router flags
 - * @bat_priv: the bat priv with all the soft interface information
 - * @bridge: bridge interface on top of the soft_iface if present,
 - *  otherwise pass NULL
 - *
 - * Checks the presence of IPv4 and IPv6 multicast routers on this
 - * node or behind its bridge.
 - *
 - * Return:
 - *	BATADV_NO_FLAGS: Both an IPv4 and IPv6 multicast router is present
 - *	BATADV_MCAST_WANT_NO_RTR4: No IPv4 multicast router is present
 - *	BATADV_MCAST_WANT_NO_RTR6: No IPv6 multicast router is present
 - *	The former two OR'd: no multicast router is present
 - */
 -static u8 batadv_mcast_mla_rtr_flags_get(struct batadv_priv *bat_priv,
 -					 struct net_device *bridge)
 -{
 -	u8 flags = BATADV_MCAST_WANT_NO_RTR4 | BATADV_MCAST_WANT_NO_RTR6;
 -
 -	flags &= batadv_mcast_mla_rtr_flags_softif_get(bat_priv, bridge);
 -	flags &= batadv_mcast_mla_rtr_flags_bridge_get(bat_priv, bridge);
 -
 -	return flags;
 -}
 -
 -/**
 - * batadv_mcast_mla_flags_get() - get the new multicast flags
 - * @bat_priv: the bat priv with all the soft interface information
 - *
 - * Return: A set of flags for the current/next TVLV, querier and
 - * bridge state.
 - */
 -static struct batadv_mcast_mla_flags
 -batadv_mcast_mla_flags_get(struct batadv_priv *bat_priv)
 -{
 -	struct net_device *dev = bat_priv->soft_iface;
 -	struct batadv_mcast_querier_state *qr4, *qr6;
 -	struct batadv_mcast_mla_flags mla_flags;
 -	struct net_device *bridge;
 -
 -	bridge = batadv_mcast_get_bridge(dev);
 -
 -	memset(&mla_flags, 0, sizeof(mla_flags));
 -	mla_flags.enabled = 1;
 -	mla_flags.tvlv_flags |= batadv_mcast_mla_rtr_flags_get(bat_priv,
 -							       bridge);
 -
 -	if (!bridge)
 -		return mla_flags;
 -
 -	dev_put(bridge);
 -
 -	mla_flags.bridged = 1;
 -	qr4 = &mla_flags.querier_ipv4;
 -	qr6 = &mla_flags.querier_ipv6;
 -
 -	if (!IS_ENABLED(CONFIG_BRIDGE_IGMP_SNOOPING))
 -		pr_warn_once("No bridge IGMP snooping compiled - multicast optimizations disabled\n");
 -
 -	qr4->exists = br_multicast_has_querier_anywhere(dev, ETH_P_IP);
 -	qr4->shadowing = br_multicast_has_querier_adjacent(dev, ETH_P_IP);
 -
 -	qr6->exists = br_multicast_has_querier_anywhere(dev, ETH_P_IPV6);
 -	qr6->shadowing = br_multicast_has_querier_adjacent(dev, ETH_P_IPV6);
 -
 -	mla_flags.tvlv_flags |= BATADV_MCAST_WANT_ALL_UNSNOOPABLES;
 -
 -	/* 1) If no querier exists at all, then multicast listeners on
 -	 *    our local TT clients behind the bridge will keep silent.
 -	 * 2) If the selected querier is on one of our local TT clients,
 -	 *    behind the bridge, then this querier might shadow multicast
 -	 *    listeners on our local TT clients, behind this bridge.
 -	 *
 -	 * In both cases, we will signalize other batman nodes that
 -	 * we need all multicast traffic of the according protocol.
 -	 */
 -	if (!qr4->exists || qr4->shadowing) {
 -		mla_flags.tvlv_flags |= BATADV_MCAST_WANT_ALL_IPV4;
 -		mla_flags.tvlv_flags &= ~BATADV_MCAST_WANT_NO_RTR4;
 -	}
 -
 -	if (!qr6->exists || qr6->shadowing) {
 -		mla_flags.tvlv_flags |= BATADV_MCAST_WANT_ALL_IPV6;
 -		mla_flags.tvlv_flags &= ~BATADV_MCAST_WANT_NO_RTR6;
 -	}
 +		dev_put(bridge);
  
 -	return mla_flags;
 +	return ret;
  }
  
  /**
@@@ -270,11 -604,34 +322,38 @@@ static int batadv_mcast_mla_bridge_get(
  		goto out;
  
  	list_for_each_entry(br_ip_entry, &bridge_mcast_list, list) {
 -		if (br_ip_entry->addr.proto == htons(ETH_P_IP)) {
 -			if (tvlv_flags & BATADV_MCAST_WANT_ALL_IPV4)
 -				continue;
 +		if (all_ipv4 && br_ip_entry->addr.proto == htons(ETH_P_IP))
 +			continue;
  
++<<<<<<< HEAD
 +		if (all_ipv6 && br_ip_entry->addr.proto == htons(ETH_P_IPV6))
 +			continue;
++=======
+ 			if (tvlv_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES &&
+ 			    ipv4_is_local_multicast(br_ip_entry->addr.dst.ip4))
+ 				continue;
+ 
+ 			if (!(tvlv_flags & BATADV_MCAST_WANT_NO_RTR4) &&
+ 			    !ipv4_is_local_multicast(br_ip_entry->addr.dst.ip4))
+ 				continue;
+ 		}
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		if (br_ip_entry->addr.proto == htons(ETH_P_IPV6)) {
+ 			if (tvlv_flags & BATADV_MCAST_WANT_ALL_IPV6)
+ 				continue;
+ 
+ 			if (tvlv_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES &&
+ 			    ipv6_addr_is_ll_all_nodes(&br_ip_entry->addr.dst.ip6))
+ 				continue;
+ 
+ 			if (!(tvlv_flags & BATADV_MCAST_WANT_NO_RTR6) &&
+ 			    IPV6_ADDR_MC_SCOPE(&br_ip_entry->addr.dst.ip6) >
+ 			    IPV6_ADDR_SCOPE_LINKLOCAL)
+ 				continue;
+ 		}
+ #endif
++>>>>>>> eab3227b1240 (net: bridge: mcast: rename br_ip's u member to dst)
  
  		batadv_mcast_mla_br_addr_cpy(mcast_addr, &br_ip_entry->addr);
  		if (batadv_mcast_mla_is_duplicate(mcast_addr, mcast_list))
diff --git a/include/linux/if_bridge.h b/include/linux/if_bridge.h
index 61ec732c0c22..0416efe976c0 100644
--- a/include/linux/if_bridge.h
+++ b/include/linux/if_bridge.h
@@ -29,7 +29,7 @@ struct br_ip {
 #if IS_ENABLED(CONFIG_IPV6)
 		struct in6_addr ip6;
 #endif
-	} u;
+	} dst;
 	__be16		proto;
 	__u16           vid;
 };
* Unmerged path net/batman-adv/multicast.c
diff --git a/net/bridge/br_mdb.c b/net/bridge/br_mdb.c
index 269ffd2e549b..a1ff0a372185 100644
--- a/net/bridge/br_mdb.c
+++ b/net/bridge/br_mdb.c
@@ -70,10 +70,10 @@ static void __mdb_entry_to_br_ip(struct br_mdb_entry *entry, struct br_ip *ip)
 	ip->vid = entry->vid;
 	ip->proto = entry->addr.proto;
 	if (ip->proto == htons(ETH_P_IP))
-		ip->u.ip4 = entry->addr.u.ip4;
+		ip->dst.ip4 = entry->addr.u.ip4;
 #if IS_ENABLED(CONFIG_IPV6)
 	else
-		ip->u.ip6 = entry->addr.u.ip6;
+		ip->dst.ip6 = entry->addr.u.ip6;
 #endif
 }
 
@@ -158,10 +158,10 @@ static int __mdb_fill_info(struct sk_buff *skb,
 	e.ifindex = ifindex;
 	e.vid = mp->addr.vid;
 	if (mp->addr.proto == htons(ETH_P_IP))
-		e.addr.u.ip4 = mp->addr.u.ip4;
+		e.addr.u.ip4 = mp->addr.dst.ip4;
 #if IS_ENABLED(CONFIG_IPV6)
 	if (mp->addr.proto == htons(ETH_P_IPV6))
-		e.addr.u.ip6 = mp->addr.u.ip6;
+		e.addr.u.ip6 = mp->addr.dst.ip6;
 #endif
 	e.addr.proto = mp->addr.proto;
 	nest_ent = nla_nest_start_noflag(skb,
@@ -474,10 +474,10 @@ static void br_mdb_switchdev_host_port(struct net_device *dev,
 	};
 
 	if (mp->addr.proto == htons(ETH_P_IP))
-		ip_eth_mc_map(mp->addr.u.ip4, mdb.addr);
+		ip_eth_mc_map(mp->addr.dst.ip4, mdb.addr);
 #if IS_ENABLED(CONFIG_IPV6)
 	else
-		ipv6_eth_mc_map(&mp->addr.u.ip6, mdb.addr);
+		ipv6_eth_mc_map(&mp->addr.dst.ip6, mdb.addr);
 #endif
 
 	mdb.obj.orig_dev = dev;
@@ -520,10 +520,10 @@ void br_mdb_notify(struct net_device *dev,
 
 	if (pg) {
 		if (mp->addr.proto == htons(ETH_P_IP))
-			ip_eth_mc_map(mp->addr.u.ip4, mdb.addr);
+			ip_eth_mc_map(mp->addr.dst.ip4, mdb.addr);
 #if IS_ENABLED(CONFIG_IPV6)
 		else
-			ipv6_eth_mc_map(&mp->addr.u.ip6, mdb.addr);
+			ipv6_eth_mc_map(&mp->addr.dst.ip6, mdb.addr);
 #endif
 		mdb.obj.orig_dev = pg->port->dev;
 		switch (type) {
diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c
index 28b757a17768..7e07284707df 100644
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@ -92,7 +92,7 @@ static struct net_bridge_mdb_entry *br_mdb_ip4_get(struct net_bridge *br,
 	struct br_ip br_dst;
 
 	memset(&br_dst, 0, sizeof(br_dst));
-	br_dst.u.ip4 = dst;
+	br_dst.dst.ip4 = dst;
 	br_dst.proto = htons(ETH_P_IP);
 	br_dst.vid = vid;
 
@@ -107,7 +107,7 @@ static struct net_bridge_mdb_entry *br_mdb_ip6_get(struct net_bridge *br,
 	struct br_ip br_dst;
 
 	memset(&br_dst, 0, sizeof(br_dst));
-	br_dst.u.ip6 = *dst;
+	br_dst.dst.ip6 = *dst;
 	br_dst.proto = htons(ETH_P_IPV6);
 	br_dst.vid = vid;
 
@@ -132,11 +132,11 @@ struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
 
 	switch (skb->protocol) {
 	case htons(ETH_P_IP):
-		ip.u.ip4 = ip_hdr(skb)->daddr;
+		ip.dst.ip4 = ip_hdr(skb)->daddr;
 		break;
 #if IS_ENABLED(CONFIG_IPV6)
 	case htons(ETH_P_IPV6):
-		ip.u.ip6 = ipv6_hdr(skb)->daddr;
+		ip.dst.ip6 = ipv6_hdr(skb)->daddr;
 		break;
 #endif
 	default:
@@ -631,9 +631,9 @@ static struct sk_buff *br_multicast_alloc_query(struct net_bridge *br,
 
 	switch (group->proto) {
 	case htons(ETH_P_IP):
-		ip4_dst = ip_dst ? ip_dst->u.ip4 : htonl(INADDR_ALLHOSTS_GROUP);
+		ip4_dst = ip_dst ? ip_dst->dst.ip4 : htonl(INADDR_ALLHOSTS_GROUP);
 		return br_ip4_multicast_alloc_query(br, pg,
-						    ip4_dst, group->u.ip4,
+						    ip4_dst, group->dst.ip4,
 						    with_srcs, over_lmqt,
 						    sflag, igmp_type,
 						    need_rexmit);
@@ -642,13 +642,13 @@ static struct sk_buff *br_multicast_alloc_query(struct net_bridge *br,
 		struct in6_addr ip6_dst;
 
 		if (ip_dst)
-			ip6_dst = ip_dst->u.ip6;
+			ip6_dst = ip_dst->dst.ip6;
 		else
 			ipv6_addr_set(&ip6_dst, htonl(0xff020000), 0, 0,
 				      htonl(1));
 
 		return br_ip6_multicast_alloc_query(br, pg,
-						    &ip6_dst, &group->u.ip6,
+						    &ip6_dst, &group->dst.ip6,
 						    with_srcs, over_lmqt,
 						    sflag, igmp_type,
 						    need_rexmit);
@@ -912,7 +912,7 @@ static int br_ip4_multicast_add_group(struct net_bridge *br,
 		return 0;
 
 	memset(&br_group, 0, sizeof(br_group));
-	br_group.u.ip4 = group;
+	br_group.dst.ip4 = group;
 	br_group.proto = htons(ETH_P_IP);
 	br_group.vid = vid;
 	filter_mode = igmpv2 ? MCAST_EXCLUDE : MCAST_INCLUDE;
@@ -936,7 +936,7 @@ static int br_ip6_multicast_add_group(struct net_bridge *br,
 		return 0;
 
 	memset(&br_group, 0, sizeof(br_group));
-	br_group.u.ip6 = *group;
+	br_group.dst.ip6 = *group;
 	br_group.proto = htons(ETH_P_IPV6);
 	br_group.vid = vid;
 	filter_mode = mldv1 ? MCAST_EXCLUDE : MCAST_INCLUDE;
@@ -1085,7 +1085,7 @@ static void br_multicast_send_query(struct net_bridge *br,
 	    !br_opt_get(br, BROPT_MULTICAST_QUERIER))
 		return;
 
-	memset(&br_group.u, 0, sizeof(br_group.u));
+	memset(&br_group.dst, 0, sizeof(br_group.dst));
 
 	if (port ? (own_query == &port->ip4_own_query) :
 		   (own_query == &br->ip4_own_query)) {
@@ -2512,7 +2512,7 @@ static void br_ip4_multicast_leave_group(struct net_bridge *br,
 	own_query = port ? &port->ip4_own_query : &br->ip4_own_query;
 
 	memset(&br_group, 0, sizeof(br_group));
-	br_group.u.ip4 = group;
+	br_group.dst.ip4 = group;
 	br_group.proto = htons(ETH_P_IP);
 	br_group.vid = vid;
 
@@ -2536,7 +2536,7 @@ static void br_ip6_multicast_leave_group(struct net_bridge *br,
 	own_query = port ? &port->ip6_own_query : &br->ip6_own_query;
 
 	memset(&br_group, 0, sizeof(br_group));
-	br_group.u.ip6 = *group;
+	br_group.dst.ip6 = *group;
 	br_group.proto = htons(ETH_P_IPV6);
 	br_group.vid = vid;
 
