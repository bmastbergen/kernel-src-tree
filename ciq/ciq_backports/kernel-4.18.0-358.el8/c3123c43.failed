locking/rtmutex: Dont dereference waiter lockless

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit c3123c431447da99db160264506de9897c003513
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/c3123c43.failed

The new rt_mutex_spin_on_onwer() loop checks whether the spinning waiter is
still the top waiter on the lock by utilizing rt_mutex_top_waiter(), which
is broken because that function contains a sanity check which dereferences
the top waiter pointer to check whether the waiter belongs to the
lock. That's wrong in the lockless spinwait case:

 CPU 0							CPU 1
 rt_mutex_lock(lock)					rt_mutex_lock(lock);
   queue(waiter0)
   waiter0 == rt_mutex_top_waiter(lock)
   rt_mutex_spin_on_onwer(lock, waiter0) {		queue(waiter1)
   					 		waiter1 == rt_mutex_top_waiter(lock)
   							...
     top_waiter = rt_mutex_top_waiter(lock)
       leftmost = rb_first_cached(&lock->waiters);
							-> signal
							dequeue(waiter1)
							destroy(waiter1)
       w = rb_entry(leftmost, ....)
       BUG_ON(w->lock != lock)	 <- UAF

The BUG_ON() is correct for the case where the caller holds lock->wait_lock
which guarantees that the leftmost waiter entry cannot vanish. For the
lockless spinwait case it's broken.

Create a new helper function which avoids the pointer dereference and just
compares the leftmost entry pointer with current's waiter pointer to
validate that currrent is still elegible for spinning.

Fixes: 992caf7f1724 ("locking/rtmutex: Add adaptive spinwait mechanism")
	Reported-by: Sebastian Siewior <bigeasy@linutronix.de>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20210825102453.981720644@linutronix.de
(cherry picked from commit c3123c431447da99db160264506de9897c003513)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/locking/rtmutex.c
#	kernel/locking/rtmutex_common.h
diff --cc kernel/locking/rtmutex.c
index ebfe41ea03fb,b3c09611ef6a..000000000000
--- a/kernel/locking/rtmutex.c
+++ b/kernel/locking/rtmutex.c
@@@ -1422,3 -1301,374 +1422,377 @@@ static __always_inline void __rt_mutex_
  
  	rt_mutex_slowunlock(lock);
  }
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_SMP
+ static bool rtmutex_spin_on_owner(struct rt_mutex_base *lock,
+ 				  struct rt_mutex_waiter *waiter,
+ 				  struct task_struct *owner)
+ {
+ 	bool res = true;
+ 
+ 	rcu_read_lock();
+ 	for (;;) {
+ 		/* If owner changed, trylock again. */
+ 		if (owner != rt_mutex_owner(lock))
+ 			break;
+ 		/*
+ 		 * Ensure that @owner is dereferenced after checking that
+ 		 * the lock owner still matches @owner. If that fails,
+ 		 * @owner might point to freed memory. If it still matches,
+ 		 * the rcu_read_lock() ensures the memory stays valid.
+ 		 */
+ 		barrier();
+ 		/*
+ 		 * Stop spinning when:
+ 		 *  - the lock owner has been scheduled out
+ 		 *  - current is not longer the top waiter
+ 		 *  - current is requested to reschedule (redundant
+ 		 *    for CONFIG_PREEMPT_RCU=y)
+ 		 *  - the VCPU on which owner runs is preempted
+ 		 */
+ 		if (!owner->on_cpu || need_resched() ||
+ 		    rt_mutex_waiter_is_top_waiter(lock, waiter) ||
+ 		    vcpu_is_preempted(task_cpu(owner))) {
+ 			res = false;
+ 			break;
+ 		}
+ 		cpu_relax();
+ 	}
+ 	rcu_read_unlock();
+ 	return res;
+ }
+ #else
+ static bool rtmutex_spin_on_owner(struct rt_mutex_base *lock,
+ 				  struct rt_mutex_waiter *waiter,
+ 				  struct task_struct *owner)
+ {
+ 	return false;
+ }
+ #endif
+ 
+ #ifdef RT_MUTEX_BUILD_MUTEX
+ /*
+  * Functions required for:
+  *	- rtmutex, futex on all kernels
+  *	- mutex and rwsem substitutions on RT kernels
+  */
+ 
+ /*
+  * Remove a waiter from a lock and give up
+  *
+  * Must be called with lock->wait_lock held and interrupts disabled. It must
+  * have just failed to try_to_take_rt_mutex().
+  */
+ static void __sched remove_waiter(struct rt_mutex_base *lock,
+ 				  struct rt_mutex_waiter *waiter)
+ {
+ 	bool is_top_waiter = (waiter == rt_mutex_top_waiter(lock));
+ 	struct task_struct *owner = rt_mutex_owner(lock);
+ 	struct rt_mutex_base *next_lock;
+ 
+ 	lockdep_assert_held(&lock->wait_lock);
+ 
+ 	raw_spin_lock(&current->pi_lock);
+ 	rt_mutex_dequeue(lock, waiter);
+ 	current->pi_blocked_on = NULL;
+ 	raw_spin_unlock(&current->pi_lock);
+ 
+ 	/*
+ 	 * Only update priority if the waiter was the highest priority
+ 	 * waiter of the lock and there is an owner to update.
+ 	 */
+ 	if (!owner || !is_top_waiter)
+ 		return;
+ 
+ 	raw_spin_lock(&owner->pi_lock);
+ 
+ 	rt_mutex_dequeue_pi(owner, waiter);
+ 
+ 	if (rt_mutex_has_waiters(lock))
+ 		rt_mutex_enqueue_pi(owner, rt_mutex_top_waiter(lock));
+ 
+ 	rt_mutex_adjust_prio(owner);
+ 
+ 	/* Store the lock on which owner is blocked or NULL */
+ 	next_lock = task_blocked_on_lock(owner);
+ 
+ 	raw_spin_unlock(&owner->pi_lock);
+ 
+ 	/*
+ 	 * Don't walk the chain, if the owner task is not blocked
+ 	 * itself.
+ 	 */
+ 	if (!next_lock)
+ 		return;
+ 
+ 	/* gets dropped in rt_mutex_adjust_prio_chain()! */
+ 	get_task_struct(owner);
+ 
+ 	raw_spin_unlock_irq(&lock->wait_lock);
+ 
+ 	rt_mutex_adjust_prio_chain(owner, RT_MUTEX_MIN_CHAINWALK, lock,
+ 				   next_lock, NULL, current);
+ 
+ 	raw_spin_lock_irq(&lock->wait_lock);
+ }
+ 
+ /**
+  * rt_mutex_slowlock_block() - Perform the wait-wake-try-to-take loop
+  * @lock:		 the rt_mutex to take
+  * @ww_ctx:		 WW mutex context pointer
+  * @state:		 the state the task should block in (TASK_INTERRUPTIBLE
+  *			 or TASK_UNINTERRUPTIBLE)
+  * @timeout:		 the pre-initialized and started timer, or NULL for none
+  * @waiter:		 the pre-initialized rt_mutex_waiter
+  *
+  * Must be called with lock->wait_lock held and interrupts disabled
+  */
+ static int __sched rt_mutex_slowlock_block(struct rt_mutex_base *lock,
+ 					   struct ww_acquire_ctx *ww_ctx,
+ 					   unsigned int state,
+ 					   struct hrtimer_sleeper *timeout,
+ 					   struct rt_mutex_waiter *waiter)
+ {
+ 	struct rt_mutex *rtm = container_of(lock, struct rt_mutex, rtmutex);
+ 	struct task_struct *owner;
+ 	int ret = 0;
+ 
+ 	for (;;) {
+ 		/* Try to acquire the lock: */
+ 		if (try_to_take_rt_mutex(lock, current, waiter))
+ 			break;
+ 
+ 		if (timeout && !timeout->task) {
+ 			ret = -ETIMEDOUT;
+ 			break;
+ 		}
+ 		if (signal_pending_state(state, current)) {
+ 			ret = -EINTR;
+ 			break;
+ 		}
+ 
+ 		if (build_ww_mutex() && ww_ctx) {
+ 			ret = __ww_mutex_check_kill(rtm, waiter, ww_ctx);
+ 			if (ret)
+ 				break;
+ 		}
+ 
+ 		if (waiter == rt_mutex_top_waiter(lock))
+ 			owner = rt_mutex_owner(lock);
+ 		else
+ 			owner = NULL;
+ 		raw_spin_unlock_irq(&lock->wait_lock);
+ 
+ 		if (!owner || !rtmutex_spin_on_owner(lock, waiter, owner))
+ 			schedule();
+ 
+ 		raw_spin_lock_irq(&lock->wait_lock);
+ 		set_current_state(state);
+ 	}
+ 
+ 	__set_current_state(TASK_RUNNING);
+ 	return ret;
+ }
+ 
+ static void __sched rt_mutex_handle_deadlock(int res, int detect_deadlock,
+ 					     struct rt_mutex_waiter *w)
+ {
+ 	/*
+ 	 * If the result is not -EDEADLOCK or the caller requested
+ 	 * deadlock detection, nothing to do here.
+ 	 */
+ 	if (res != -EDEADLOCK || detect_deadlock)
+ 		return;
+ 
+ 	if (build_ww_mutex() && w->ww_ctx)
+ 		return;
+ 
+ 	/*
+ 	 * Yell loudly and stop the task right here.
+ 	 */
+ 	WARN(1, "rtmutex deadlock detected\n");
+ 	while (1) {
+ 		set_current_state(TASK_INTERRUPTIBLE);
+ 		schedule();
+ 	}
+ }
+ 
+ /**
+  * __rt_mutex_slowlock - Locking slowpath invoked with lock::wait_lock held
+  * @lock:	The rtmutex to block lock
+  * @ww_ctx:	WW mutex context pointer
+  * @state:	The task state for sleeping
+  * @chwalk:	Indicator whether full or partial chainwalk is requested
+  * @waiter:	Initializer waiter for blocking
+  */
+ static int __sched __rt_mutex_slowlock(struct rt_mutex_base *lock,
+ 				       struct ww_acquire_ctx *ww_ctx,
+ 				       unsigned int state,
+ 				       enum rtmutex_chainwalk chwalk,
+ 				       struct rt_mutex_waiter *waiter)
+ {
+ 	struct rt_mutex *rtm = container_of(lock, struct rt_mutex, rtmutex);
+ 	struct ww_mutex *ww = ww_container_of(rtm);
+ 	int ret;
+ 
+ 	lockdep_assert_held(&lock->wait_lock);
+ 
+ 	/* Try to acquire the lock again: */
+ 	if (try_to_take_rt_mutex(lock, current, NULL)) {
+ 		if (build_ww_mutex() && ww_ctx) {
+ 			__ww_mutex_check_waiters(rtm, ww_ctx);
+ 			ww_mutex_lock_acquired(ww, ww_ctx);
+ 		}
+ 		return 0;
+ 	}
+ 
+ 	set_current_state(state);
+ 
+ 	ret = task_blocks_on_rt_mutex(lock, waiter, current, ww_ctx, chwalk);
+ 	if (likely(!ret))
+ 		ret = rt_mutex_slowlock_block(lock, ww_ctx, state, NULL, waiter);
+ 
+ 	if (likely(!ret)) {
+ 		/* acquired the lock */
+ 		if (build_ww_mutex() && ww_ctx) {
+ 			if (!ww_ctx->is_wait_die)
+ 				__ww_mutex_check_waiters(rtm, ww_ctx);
+ 			ww_mutex_lock_acquired(ww, ww_ctx);
+ 		}
+ 	} else {
+ 		__set_current_state(TASK_RUNNING);
+ 		remove_waiter(lock, waiter);
+ 		rt_mutex_handle_deadlock(ret, chwalk, waiter);
+ 	}
+ 
+ 	/*
+ 	 * try_to_take_rt_mutex() sets the waiter bit
+ 	 * unconditionally. We might have to fix that up.
+ 	 */
+ 	fixup_rt_mutex_waiters(lock);
+ 	return ret;
+ }
+ 
+ static inline int __rt_mutex_slowlock_locked(struct rt_mutex_base *lock,
+ 					     struct ww_acquire_ctx *ww_ctx,
+ 					     unsigned int state)
+ {
+ 	struct rt_mutex_waiter waiter;
+ 	int ret;
+ 
+ 	rt_mutex_init_waiter(&waiter);
+ 	waiter.ww_ctx = ww_ctx;
+ 
+ 	ret = __rt_mutex_slowlock(lock, ww_ctx, state, RT_MUTEX_MIN_CHAINWALK,
+ 				  &waiter);
+ 
+ 	debug_rt_mutex_free_waiter(&waiter);
+ 	return ret;
+ }
+ 
+ /*
+  * rt_mutex_slowlock - Locking slowpath invoked when fast path fails
+  * @lock:	The rtmutex to block lock
+  * @ww_ctx:	WW mutex context pointer
+  * @state:	The task state for sleeping
+  */
+ static int __sched rt_mutex_slowlock(struct rt_mutex_base *lock,
+ 				     struct ww_acquire_ctx *ww_ctx,
+ 				     unsigned int state)
+ {
+ 	unsigned long flags;
+ 	int ret;
+ 
+ 	/*
+ 	 * Technically we could use raw_spin_[un]lock_irq() here, but this can
+ 	 * be called in early boot if the cmpxchg() fast path is disabled
+ 	 * (debug, no architecture support). In this case we will acquire the
+ 	 * rtmutex with lock->wait_lock held. But we cannot unconditionally
+ 	 * enable interrupts in that early boot case. So we need to use the
+ 	 * irqsave/restore variants.
+ 	 */
+ 	raw_spin_lock_irqsave(&lock->wait_lock, flags);
+ 	ret = __rt_mutex_slowlock_locked(lock, ww_ctx, state);
+ 	raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
+ 
+ 	return ret;
+ }
+ 
+ static __always_inline int __rt_mutex_lock(struct rt_mutex_base *lock,
+ 					   unsigned int state)
+ {
+ 	if (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))
+ 		return 0;
+ 
+ 	return rt_mutex_slowlock(lock, NULL, state);
+ }
+ #endif /* RT_MUTEX_BUILD_MUTEX */
+ 
+ #ifdef RT_MUTEX_BUILD_SPINLOCKS
+ /*
+  * Functions required for spin/rw_lock substitution on RT kernels
+  */
+ 
+ /**
+  * rtlock_slowlock_locked - Slow path lock acquisition for RT locks
+  * @lock:	The underlying RT mutex
+  */
+ static void __sched rtlock_slowlock_locked(struct rt_mutex_base *lock)
+ {
+ 	struct rt_mutex_waiter waiter;
+ 	struct task_struct *owner;
+ 
+ 	lockdep_assert_held(&lock->wait_lock);
+ 
+ 	if (try_to_take_rt_mutex(lock, current, NULL))
+ 		return;
+ 
+ 	rt_mutex_init_rtlock_waiter(&waiter);
+ 
+ 	/* Save current state and set state to TASK_RTLOCK_WAIT */
+ 	current_save_and_set_rtlock_wait_state();
+ 
+ 	task_blocks_on_rt_mutex(lock, &waiter, current, NULL, RT_MUTEX_MIN_CHAINWALK);
+ 
+ 	for (;;) {
+ 		/* Try to acquire the lock again */
+ 		if (try_to_take_rt_mutex(lock, current, &waiter))
+ 			break;
+ 
+ 		if (&waiter == rt_mutex_top_waiter(lock))
+ 			owner = rt_mutex_owner(lock);
+ 		else
+ 			owner = NULL;
+ 		raw_spin_unlock_irq(&lock->wait_lock);
+ 
+ 		if (!owner || !rtmutex_spin_on_owner(lock, &waiter, owner))
+ 			schedule_rtlock();
+ 
+ 		raw_spin_lock_irq(&lock->wait_lock);
+ 		set_current_state(TASK_RTLOCK_WAIT);
+ 	}
+ 
+ 	/* Restore the task state */
+ 	current_restore_rtlock_saved_state();
+ 
+ 	/*
+ 	 * try_to_take_rt_mutex() sets the waiter bit unconditionally.
+ 	 * We might have to fix that up:
+ 	 */
+ 	fixup_rt_mutex_waiters(lock);
+ 	debug_rt_mutex_free_waiter(&waiter);
+ }
+ 
+ static __always_inline void __sched rtlock_slowlock(struct rt_mutex_base *lock)
+ {
+ 	unsigned long flags;
+ 
+ 	raw_spin_lock_irqsave(&lock->wait_lock, flags);
+ 	rtlock_slowlock_locked(lock);
+ 	raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
+ }
+ 
+ #endif /* RT_MUTEX_BUILD_SPINLOCKS */
++>>>>>>> c3123c431447 (locking/rtmutex: Dont dereference waiter lockless)
diff --cc kernel/locking/rtmutex_common.h
index 60b371b6d83f,c47e8361bfb5..000000000000
--- a/kernel/locking/rtmutex_common.h
+++ b/kernel/locking/rtmutex_common.h
@@@ -91,7 -95,20 +91,24 @@@ static inline int rt_mutex_has_waiters(
  	return !RB_EMPTY_ROOT(&lock->waiters.rb_root);
  }
  
++<<<<<<< HEAD
 +static inline struct rt_mutex_waiter *rt_mutex_top_waiter(struct rt_mutex *lock)
++=======
+ /*
+  * Lockless speculative check whether @waiter is still the top waiter on
+  * @lock. This is solely comparing pointers and not derefencing the
+  * leftmost entry which might be about to vanish.
+  */
+ static inline bool rt_mutex_waiter_is_top_waiter(struct rt_mutex_base *lock,
+ 						 struct rt_mutex_waiter *waiter)
+ {
+ 	struct rb_node *leftmost = rb_first_cached(&lock->waiters);
+ 
+ 	return rb_entry(leftmost, struct rt_mutex_waiter, tree_entry) == waiter;
+ }
+ 
+ static inline struct rt_mutex_waiter *rt_mutex_top_waiter(struct rt_mutex_base *lock)
++>>>>>>> c3123c431447 (locking/rtmutex: Dont dereference waiter lockless)
  {
  	struct rb_node *leftmost = rb_first_cached(&lock->waiters);
  	struct rt_mutex_waiter *w = NULL;
* Unmerged path kernel/locking/rtmutex.c
* Unmerged path kernel/locking/rtmutex_common.h
