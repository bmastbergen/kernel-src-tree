Revert "driver core: Rename dev_links_info.defer_sync to defer_hook"

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Saravana Kannan <saravanak@google.com>
commit 3b052a3e30f2eb92dcae9fd89af48d5a13045737
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/3b052a3e.failed

This reverts commit ec7bd78498f29680f536451fbdf9464e851273ed.

This field rename was done to reuse defer_syc list head for multiple
lists. That's not needed anymore and this list head will only be used
for defer sync. So revert this patch to avoid conflicts with the other
reverts coming after this.

	Signed-off-by: Saravana Kannan <saravanak@google.com>
Link: https://lore.kernel.org/r/20201121020232.908850-3-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 3b052a3e30f2eb92dcae9fd89af48d5a13045737)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
#	include/linux/device.h
diff --cc drivers/base/core.c
index c73bf3cdd933,fc4b0bc59935..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -949,11 -959,11 +949,19 @@@ static void __device_links_queue_sync_s
  	 */
  	dev->state_synced = true;
  
++<<<<<<< HEAD
 +	if (WARN_ON(!list_empty(&dev->links_defer_hook)))
 +		return;
 +
 +	get_device(dev);
 +	list_add_tail(&dev->links_defer_hook, list);
++=======
+ 	if (WARN_ON(!list_empty(&dev->links.defer_sync)))
+ 		return;
+ 
+ 	get_device(dev);
+ 	list_add_tail(&dev->links.defer_sync, list);
++>>>>>>> 3b052a3e30f2 (Revert "driver core: Rename dev_links_info.defer_sync to defer_hook")
  }
  
  /**
@@@ -971,8 -981,8 +979,13 @@@ static void device_links_flush_sync_lis
  {
  	struct device *dev, *tmp;
  
++<<<<<<< HEAD
 +	list_for_each_entry_safe(dev, tmp, list, links_defer_hook) {
 +		list_del_init(&dev->links_defer_hook);
++=======
+ 	list_for_each_entry_safe(dev, tmp, list, links.defer_sync) {
+ 		list_del_init(&dev->links.defer_sync);
++>>>>>>> 3b052a3e30f2 (Revert "driver core: Rename dev_links_info.defer_sync to defer_hook")
  
  		if (dev != dont_lock_dev)
  			device_lock(dev);
@@@ -1010,12 -1020,12 +1023,20 @@@ void device_links_supplier_sync_state_r
  	if (defer_sync_state_count)
  		goto out;
  
++<<<<<<< HEAD
 +	list_for_each_entry_safe(dev, tmp, &deferred_sync, links_defer_hook) {
++=======
+ 	list_for_each_entry_safe(dev, tmp, &deferred_sync, links.defer_sync) {
++>>>>>>> 3b052a3e30f2 (Revert "driver core: Rename dev_links_info.defer_sync to defer_hook")
  		/*
  		 * Delete from deferred_sync list before queuing it to
  		 * sync_list because defer_sync is used for both lists.
  		 */
++<<<<<<< HEAD
 +		list_del_init(&dev->links_defer_hook);
++=======
+ 		list_del_init(&dev->links.defer_sync);
++>>>>>>> 3b052a3e30f2 (Revert "driver core: Rename dev_links_info.defer_sync to defer_hook")
  		__device_links_queue_sync_state(dev, &sync_list);
  	}
  out:
@@@ -1033,8 -1043,8 +1054,13 @@@ late_initcall(sync_state_resume_initcal
  
  static void __device_links_supplier_defer_sync(struct device *sup)
  {
++<<<<<<< HEAD
 +	if (list_empty(&sup->links_defer_hook) && dev_has_sync_state(sup))
 +		list_add_tail(&sup->links_defer_hook, &deferred_sync);
++=======
+ 	if (list_empty(&sup->links.defer_sync) && dev_has_sync_state(sup))
+ 		list_add_tail(&sup->links.defer_sync, &deferred_sync);
++>>>>>>> 3b052a3e30f2 (Revert "driver core: Rename dev_links_info.defer_sync to defer_hook")
  }
  
  static void device_link_drop_managed(struct device_link *link)
@@@ -1264,7 -1272,7 +1290,11 @@@ void device_links_driver_cleanup(struc
  		WRITE_ONCE(link->status, DL_STATE_DORMANT);
  	}
  
++<<<<<<< HEAD
 +	list_del_init(&dev->links_defer_hook);
++=======
+ 	list_del_init(&dev->links.defer_sync);
++>>>>>>> 3b052a3e30f2 (Revert "driver core: Rename dev_links_info.defer_sync to defer_hook")
  	__device_links_no_driver(dev);
  
  	device_links_write_unlock();
@@@ -2396,8 -2404,8 +2426,13 @@@ void device_initialize(struct device *d
  #endif
  	INIT_LIST_HEAD(&dev->links.consumers);
  	INIT_LIST_HEAD(&dev->links.suppliers);
++<<<<<<< HEAD
 +	INIT_LIST_HEAD(&dev->links_needs_suppliers);
 +	INIT_LIST_HEAD(&dev->links_defer_hook);
++=======
+ 	INIT_LIST_HEAD(&dev->links.needs_suppliers);
+ 	INIT_LIST_HEAD(&dev->links.defer_sync);
++>>>>>>> 3b052a3e30f2 (Revert "driver core: Rename dev_links_info.defer_sync to defer_hook")
  	dev->links.status = DL_DEV_NO_DRIVER;
  }
  EXPORT_SYMBOL_GPL(device_initialize);
diff --cc include/linux/device.h
index d191907ceea8,1e771ea4dca6..000000000000
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@@ -1079,13 -352,17 +1079,25 @@@ enum dl_dev_state 
   * @suppliers: List of links to supplier devices.
   * @consumers: List of links to consumer devices.
   * @needs_suppliers: Hook to global list of devices waiting for suppliers.
++<<<<<<< HEAD
 + * @defer_hook: Hook to global list of devices that have deferred sync_state or
 + *             deferred fw_devlink.
++=======
+  * @defer_sync: Hook to global list of devices that have deferred sync_state.
+  * @need_for_probe: If needs_suppliers is on a list, this indicates if the
+  *		    suppliers are needed for probe or not.
++>>>>>>> 3b052a3e30f2 (Revert "driver core: Rename dev_links_info.defer_sync to defer_hook")
   * @status: Driver status information.
   */
  struct dev_links_info {
  	struct list_head suppliers;
  	struct list_head consumers;
++<<<<<<< HEAD
++=======
+ 	struct list_head needs_suppliers;
+ 	struct list_head defer_sync;
+ 	bool need_for_probe;
++>>>>>>> 3b052a3e30f2 (Revert "driver core: Rename dev_links_info.defer_sync to defer_hook")
  	enum dl_dev_state status;
  };
  
* Unmerged path drivers/base/core.c
* Unmerged path include/linux/device.h
