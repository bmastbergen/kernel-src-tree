ice: Drop leading underscores in enum ice_pf_state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
commit 7e408e07b42dceba4bc6630ff9ce9a55fcb043e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/7e408e07.failed

Remove the leading underscores in enum ice_pf_state. This is not really
communicating anything and is unnecessary. No functional change.

	Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
	Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 7e408e07b42dceba4bc6630ff9ce9a55fcb043e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice.h
#	drivers/net/ethernet/intel/ice/ice_main.c
#	drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/ice/ice.h
index 3b22620c8ce7,2cb09af3148c..000000000000
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@@ -198,47 -197,45 +198,68 @@@ struct ice_sw 
  };
  
  enum ice_pf_state {
- 	__ICE_TESTING,
- 	__ICE_DOWN,
- 	__ICE_NEEDS_RESTART,
- 	__ICE_PREPARED_FOR_RESET,	/* set by driver when prepared */
- 	__ICE_RESET_OICR_RECV,		/* set by driver after rcv reset OICR */
- 	__ICE_PFR_REQ,			/* set by driver and peers */
- 	__ICE_CORER_REQ,		/* set by driver and peers */
- 	__ICE_GLOBR_REQ,		/* set by driver and peers */
- 	__ICE_CORER_RECV,		/* set by OICR handler */
- 	__ICE_GLOBR_RECV,		/* set by OICR handler */
- 	__ICE_EMPR_RECV,		/* set by OICR handler */
- 	__ICE_SUSPENDED,		/* set on module remove path */
- 	__ICE_RESET_FAILED,		/* set by reset/rebuild */
+ 	ICE_TESTING,
+ 	ICE_DOWN,
+ 	ICE_NEEDS_RESTART,
+ 	ICE_PREPARED_FOR_RESET,	/* set by driver when prepared */
+ 	ICE_RESET_OICR_RECV,		/* set by driver after rcv reset OICR */
+ 	ICE_PFR_REQ,			/* set by driver and peers */
+ 	ICE_CORER_REQ,		/* set by driver and peers */
+ 	ICE_GLOBR_REQ,		/* set by driver and peers */
+ 	ICE_CORER_RECV,		/* set by OICR handler */
+ 	ICE_GLOBR_RECV,		/* set by OICR handler */
+ 	ICE_EMPR_RECV,		/* set by OICR handler */
+ 	ICE_SUSPENDED,		/* set on module remove path */
+ 	ICE_RESET_FAILED,		/* set by reset/rebuild */
  	/* When checking for the PF to be in a nominal operating state, the
  	 * bits that are grouped at the beginning of the list need to be
- 	 * checked. Bits occurring before __ICE_STATE_NOMINAL_CHECK_BITS will
+ 	 * checked. Bits occurring before ICE_STATE_NOMINAL_CHECK_BITS will
  	 * be checked. If you need to add a bit into consideration for nominal
  	 * operating state, it must be added before
- 	 * __ICE_STATE_NOMINAL_CHECK_BITS. Do not move this entry's position
+ 	 * ICE_STATE_NOMINAL_CHECK_BITS. Do not move this entry's position
  	 * without appropriate consideration.
  	 */
++<<<<<<< HEAD
 +	__ICE_STATE_NOMINAL_CHECK_BITS,
 +	__ICE_ADMINQ_EVENT_PENDING,
 +	__ICE_MAILBOXQ_EVENT_PENDING,
 +	ICE_SIDEBANDQ_EVENT_PENDING,
 +	__ICE_MDD_EVENT_PENDING,
 +	__ICE_VFLR_EVENT_PENDING,
 +	__ICE_FLTR_OVERFLOW_PROMISC,
 +	__ICE_VF_DIS,
 +	ICE_VF_DEINIT_IN_PROGRESS,
 +	__ICE_CFG_BUSY,
 +	__ICE_SERVICE_SCHED,
 +	__ICE_SERVICE_DIS,
 +	__ICE_FD_FLUSH_REQ,
 +	__ICE_OICR_INTR_DIS,		/* Global OICR interrupt disabled */
 +	__ICE_MDD_VF_PRINT_PENDING,	/* set when MDD event handle */
 +	__ICE_VF_RESETS_DISABLED,	/* disable resets during ice_remove */
 +	__ICE_LINK_DEFAULT_OVERRIDE_PENDING,
 +	__ICE_PHY_INIT_COMPLETE,
 +	__ICE_FD_VF_FLUSH_CTX,		/* set at FD Rx IRQ or timeout */
 +	__ICE_STATE_NBITS		/* must be last */
++=======
+ 	ICE_STATE_NOMINAL_CHECK_BITS,
+ 	ICE_ADMINQ_EVENT_PENDING,
+ 	ICE_MAILBOXQ_EVENT_PENDING,
+ 	ICE_MDD_EVENT_PENDING,
+ 	ICE_VFLR_EVENT_PENDING,
+ 	ICE_FLTR_OVERFLOW_PROMISC,
+ 	ICE_VF_DIS,
+ 	ICE_CFG_BUSY,
+ 	ICE_SERVICE_SCHED,
+ 	ICE_SERVICE_DIS,
+ 	ICE_FD_FLUSH_REQ,
+ 	ICE_OICR_INTR_DIS,		/* Global OICR interrupt disabled */
+ 	ICE_MDD_VF_PRINT_PENDING,	/* set when MDD event handle */
+ 	ICE_VF_RESETS_DISABLED,	/* disable resets during ice_remove */
+ 	ICE_LINK_DEFAULT_OVERRIDE_PENDING,
+ 	ICE_PHY_INIT_COMPLETE,
+ 	ICE_FD_VF_FLUSH_CTX,		/* set at FD Rx IRQ or timeout */
+ 	ICE_STATE_NBITS		/* must be last */
++>>>>>>> 7e408e07b42d (ice: Drop leading underscores in enum ice_pf_state)
  };
  
  enum ice_vsi_state {
@@@ -427,8 -421,7 +448,12 @@@ struct ice_pf 
  	u16 num_msix_per_vf;
  	/* used to ratelimit the MDD event logging */
  	unsigned long last_printed_mdd_jiffies;
++<<<<<<< HEAD
 +	DECLARE_BITMAP(malvfs, ICE_MAX_VF_COUNT);
 +	DECLARE_BITMAP(state, __ICE_STATE_NBITS);
++=======
+ 	DECLARE_BITMAP(state, ICE_STATE_NBITS);
++>>>>>>> 7e408e07b42d (ice: Drop leading underscores in enum ice_pf_state)
  	DECLARE_BITMAP(flags, ICE_PF_FLAGS_NBITS);
  	unsigned long *avail_txqs;	/* bitmap to track PF Tx queue usage */
  	unsigned long *avail_rxqs;	/* bitmap to track PF Rx queue usage */
diff --cc drivers/net/ethernet/intel/ice/ice_main.c
index c321e8a93a56,032101680e09..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@@ -2109,10 -2058,10 +2109,11 @@@ static void ice_service_task(struct wor
  
  	ice_process_vflr_event(pf);
  	ice_clean_mailboxq_subtask(pf);
 +	ice_clean_sbq_subtask(pf);
  	ice_sync_arfs_fltrs(pf);
  	ice_flush_fdir_ctx(pf);
- 	/* Clear __ICE_SERVICE_SCHED flag to allow scheduling next event */
+ 
+ 	/* Clear ICE_SERVICE_SCHED flag to allow scheduling next event */
  	ice_service_task_complete(pf);
  
  	/* If the tasks have taken longer than one service timer period
@@@ -2120,12 -2069,11 +2121,20 @@@
  	 * schedule the service task now.
  	 */
  	if (time_after(jiffies, (start_time + pf->serv_tmr_period)) ||
++<<<<<<< HEAD
 +	    test_bit(__ICE_MDD_EVENT_PENDING, pf->state) ||
 +	    test_bit(__ICE_VFLR_EVENT_PENDING, pf->state) ||
 +	    test_bit(__ICE_MAILBOXQ_EVENT_PENDING, pf->state) ||
 +	    test_bit(__ICE_FD_VF_FLUSH_CTX, pf->state) ||
 +	    test_bit(ICE_SIDEBANDQ_EVENT_PENDING, pf->state) ||
 +	    test_bit(__ICE_ADMINQ_EVENT_PENDING, pf->state))
++=======
+ 	    test_bit(ICE_MDD_EVENT_PENDING, pf->state) ||
+ 	    test_bit(ICE_VFLR_EVENT_PENDING, pf->state) ||
+ 	    test_bit(ICE_MAILBOXQ_EVENT_PENDING, pf->state) ||
+ 	    test_bit(ICE_FD_VF_FLUSH_CTX, pf->state) ||
+ 	    test_bit(ICE_ADMINQ_EVENT_PENDING, pf->state))
++>>>>>>> 7e408e07b42d (ice: Drop leading underscores in enum ice_pf_state)
  		mod_timer(&pf->serv_tmr, jiffies);
  }
  
@@@ -2682,9 -2626,8 +2691,14 @@@ static irqreturn_t ice_misc_intr(int __
  	u32 oicr, ena_mask;
  
  	dev = ice_pf_to_dev(pf);
++<<<<<<< HEAD
 +	set_bit(__ICE_ADMINQ_EVENT_PENDING, pf->state);
 +	set_bit(__ICE_MAILBOXQ_EVENT_PENDING, pf->state);
 +	set_bit(ICE_SIDEBANDQ_EVENT_PENDING, pf->state);
++=======
+ 	set_bit(ICE_ADMINQ_EVENT_PENDING, pf->state);
+ 	set_bit(ICE_MAILBOXQ_EVENT_PENDING, pf->state);
++>>>>>>> 7e408e07b42d (ice: Drop leading underscores in enum ice_pf_state)
  
  	oicr = rd32(hw, PFINT_OICR);
  	ena_mask = rd32(hw, PFINT_OICR_ENA);
diff --cc drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
index 92dfadc080b2,a3d8d06b1e3f..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
@@@ -673,16 -424,7 +673,20 @@@ void ice_free_vfs(struct ice_pf *pf
  			wr32(hw, GLGEN_VFLRSTAT(reg_idx), BIT(bit_idx));
  		}
  	}
++<<<<<<< HEAD
 +
 +	/* clear malicious info if the VFs are getting released */
 +	for (i = 0; i < tmp; i++)
 +		if (ice_mbx_clear_malvf(&hw->mbx_snapshot, pf->malvfs,
 +					ICE_MAX_VF_COUNT, i))
 +			dev_dbg(dev, "failed to clear malicious VF state for VF %u\n",
 +				i);
 +
 +	clear_bit(__ICE_VF_DIS, pf->state);
 +	clear_bit(ICE_VF_DEINIT_IN_PROGRESS, pf->state);
++=======
+ 	clear_bit(ICE_VF_DIS, pf->state);
++>>>>>>> 7e408e07b42d (ice: Drop leading underscores in enum ice_pf_state)
  	clear_bit(ICE_FLAG_SRIOV_ENA, pf->flags);
  }
  
@@@ -1515,13 -1257,8 +1519,13 @@@ bool ice_reset_all_vfs(struct ice_pf *p
  	if (!pf->num_alloc_vfs)
  		return false;
  
 +	/* clear all malicious info if the VFs are getting reset */
 +	ice_for_each_vf(pf, i)
 +		if (ice_mbx_clear_malvf(&hw->mbx_snapshot, pf->malvfs, ICE_MAX_VF_COUNT, i))
 +			dev_dbg(dev, "failed to clear malicious VF state for VF %u\n", i);
 +
  	/* If VFs have been disabled, there is no need to reset */
- 	if (test_and_set_bit(__ICE_VF_DIS, pf->state))
+ 	if (test_and_set_bit(ICE_VF_DIS, pf->state))
  		return false;
  
  	/* Begin reset on all VFs at once */
* Unmerged path drivers/net/ethernet/intel/ice/ice.h
diff --git a/drivers/net/ethernet/intel/ice/ice_ethtool.c b/drivers/net/ethernet/intel/ice/ice_ethtool.c
index 4835c55bf1eb..1d935fe39468 100644
--- a/drivers/net/ethernet/intel/ice/ice_ethtool.c
+++ b/drivers/net/ethernet/intel/ice/ice_ethtool.c
@@ -806,7 +806,7 @@ ice_self_test(struct net_device *netdev, struct ethtool_test *eth_test,
 	if (eth_test->flags == ETH_TEST_FL_OFFLINE) {
 		netdev_info(netdev, "offline testing starting\n");
 
-		set_bit(__ICE_TESTING, pf->state);
+		set_bit(ICE_TESTING, pf->state);
 
 		if (ice_active_vfs(pf)) {
 			dev_warn(dev, "Please take active VFs and Netqueues offline and restart the adapter before running NIC diagnostics\n");
@@ -816,7 +816,7 @@ ice_self_test(struct net_device *netdev, struct ethtool_test *eth_test,
 			data[ICE_ETH_TEST_LOOP] = 1;
 			data[ICE_ETH_TEST_LINK] = 1;
 			eth_test->flags |= ETH_TEST_FL_FAILED;
-			clear_bit(__ICE_TESTING, pf->state);
+			clear_bit(ICE_TESTING, pf->state);
 			goto skip_ol_tests;
 		}
 		/* If the device is online then take it offline */
@@ -837,7 +837,7 @@ ice_self_test(struct net_device *netdev, struct ethtool_test *eth_test,
 		    data[ICE_ETH_TEST_REG])
 			eth_test->flags |= ETH_TEST_FL_FAILED;
 
-		clear_bit(__ICE_TESTING, pf->state);
+		clear_bit(ICE_TESTING, pf->state);
 
 		if (if_running) {
 			int status = ice_open(netdev);
@@ -1118,7 +1118,7 @@ static int ice_nway_reset(struct net_device *netdev)
 	int err;
 
 	/* If VSI state is up, then restart autoneg with link up */
-	if (!test_bit(__ICE_DOWN, vsi->back->state))
+	if (!test_bit(ICE_DOWN, vsi->back->state))
 		err = ice_set_link(vsi, true);
 	else
 		err = ice_set_link(vsi, false);
@@ -2264,7 +2264,7 @@ ice_set_link_ksettings(struct net_device *netdev,
 		goto done;
 	}
 
-	while (test_and_set_bit(__ICE_CFG_BUSY, pf->state)) {
+	while (test_and_set_bit(ICE_CFG_BUSY, pf->state)) {
 		timeout--;
 		if (!timeout) {
 			err = -EBUSY;
@@ -2374,7 +2374,7 @@ ice_set_link_ksettings(struct net_device *netdev,
 	pi->phy.curr_user_speed_req = adv_link_speed;
 done:
 	kfree(phy_caps);
-	clear_bit(__ICE_CFG_BUSY, pf->state);
+	clear_bit(ICE_CFG_BUSY, pf->state);
 
 	return err;
 }
@@ -2730,7 +2730,7 @@ ice_set_ringparam(struct net_device *netdev, struct ethtool_ringparam *ring)
 	if (ice_xsk_any_rx_ring_ena(vsi))
 		return -EBUSY;
 
-	while (test_and_set_bit(__ICE_CFG_BUSY, pf->state)) {
+	while (test_and_set_bit(ICE_CFG_BUSY, pf->state)) {
 		timeout--;
 		if (!timeout)
 			return -EBUSY;
@@ -2909,7 +2909,7 @@ ice_set_ringparam(struct net_device *netdev, struct ethtool_ringparam *ring)
 	}
 
 done:
-	clear_bit(__ICE_CFG_BUSY, pf->state);
+	clear_bit(ICE_CFG_BUSY, pf->state);
 	return err;
 }
 
@@ -3028,7 +3028,7 @@ ice_set_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
 	}
 
 	/* If we have link and don't have autoneg */
-	if (!test_bit(__ICE_DOWN, pf->state) &&
+	if (!test_bit(ICE_DOWN, pf->state) &&
 	    !(hw_link_info->an_info & ICE_AQ_AN_COMPLETED)) {
 		/* Send message that it might not necessarily work*/
 		netdev_info(netdev, "Autoneg did not complete so changing settings may not result in an actual change.\n");
diff --git a/drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c b/drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
index 440964defa4a..16de603b280c 100644
--- a/drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
+++ b/drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
@@ -1452,7 +1452,7 @@ int ice_del_fdir_ethtool(struct ice_vsi *vsi, struct ethtool_rxnfc *cmd)
 		return -EBUSY;
 	}
 
-	if (test_bit(__ICE_FD_FLUSH_REQ, pf->state))
+	if (test_bit(ICE_FD_FLUSH_REQ, pf->state))
 		return -EBUSY;
 
 	mutex_lock(&hw->fdir_fltr_lock);
diff --git a/drivers/net/ethernet/intel/ice/ice_lib.c b/drivers/net/ethernet/intel/ice/ice_lib.c
index 2e328aad1449..7868b4c7bd94 100644
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@ -1515,13 +1515,13 @@ static void ice_vsi_set_rss_flow_fld(struct ice_vsi *vsi)
  */
 bool ice_pf_state_is_nominal(struct ice_pf *pf)
 {
-	DECLARE_BITMAP(check_bits, __ICE_STATE_NBITS) = { 0 };
+	DECLARE_BITMAP(check_bits, ICE_STATE_NBITS) = { 0 };
 
 	if (!pf)
 		return false;
 
-	bitmap_set(check_bits, 0, __ICE_STATE_NOMINAL_CHECK_BITS);
-	if (bitmap_intersects(pf->state, check_bits, __ICE_STATE_NBITS))
+	bitmap_set(check_bits, 0, ICE_STATE_NOMINAL_CHECK_BITS);
+	if (bitmap_intersects(pf->state, check_bits, ICE_STATE_NBITS))
 		return false;
 
 	return true;
@@ -2828,7 +2828,7 @@ int ice_vsi_release(struct ice_vsi *vsi)
 	ice_vsi_delete(vsi);
 	ice_vsi_free_q_vectors(vsi);
 
-	/* make sure unregister_netdev() was called by checking __ICE_DOWN */
+	/* make sure unregister_netdev() was called by checking ICE_DOWN */
 	if (vsi->netdev && test_bit(ICE_VSI_DOWN, vsi->state)) {
 		free_netdev(vsi->netdev);
 		vsi->netdev = NULL;
@@ -3157,7 +3157,7 @@ int ice_vsi_rebuild(struct ice_vsi *vsi, bool init_vsi)
 	}
 err_vsi:
 	ice_vsi_clear(vsi);
-	set_bit(__ICE_RESET_FAILED, pf->state);
+	set_bit(ICE_RESET_FAILED, pf->state);
 	kfree(coalesce);
 	return ret;
 }
@@ -3168,10 +3168,10 @@ int ice_vsi_rebuild(struct ice_vsi *vsi, bool init_vsi)
  */
 bool ice_is_reset_in_progress(unsigned long *state)
 {
-	return test_bit(__ICE_RESET_OICR_RECV, state) ||
-	       test_bit(__ICE_PFR_REQ, state) ||
-	       test_bit(__ICE_CORER_REQ, state) ||
-	       test_bit(__ICE_GLOBR_REQ, state);
+	return test_bit(ICE_RESET_OICR_RECV, state) ||
+	       test_bit(ICE_PFR_REQ, state) ||
+	       test_bit(ICE_CORER_REQ, state) ||
+	       test_bit(ICE_GLOBR_REQ, state);
 }
 
 #ifdef CONFIG_DCB
* Unmerged path drivers/net/ethernet/intel/ice/ice_main.c
diff --git a/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c b/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
index 1f4ba38b1599..eee180d8c024 100644
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_fdir.c
@@ -1548,7 +1548,7 @@ static void ice_vf_fdir_timer(struct timer_list *t)
 	ctx_done->v_opcode = ctx_irq->v_opcode;
 	spin_unlock_irqrestore(&fdir->ctx_lock, flags);
 
-	set_bit(__ICE_FD_VF_FLUSH_CTX, pf->state);
+	set_bit(ICE_FD_VF_FLUSH_CTX, pf->state);
 	ice_service_task_schedule(pf);
 }
 
@@ -1596,7 +1596,7 @@ ice_vc_fdir_irq_handler(struct ice_vsi *ctrl_vsi,
 	if (!ret)
 		dev_err(dev, "VF %d: Unexpected inactive timer!\n", vf->vf_id);
 
-	set_bit(__ICE_FD_VF_FLUSH_CTX, pf->state);
+	set_bit(ICE_FD_VF_FLUSH_CTX, pf->state);
 	ice_service_task_schedule(pf);
 }
 
@@ -1847,7 +1847,7 @@ void ice_flush_fdir_ctx(struct ice_pf *pf)
 {
 	int i;
 
-	if (!test_and_clear_bit(__ICE_FD_VF_FLUSH_CTX, pf->state))
+	if (!test_and_clear_bit(ICE_FD_VF_FLUSH_CTX, pf->state))
 		return;
 
 	ice_for_each_vf(pf, i) {
* Unmerged path drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
diff --git a/drivers/net/ethernet/intel/ice/ice_xsk.c b/drivers/net/ethernet/intel/ice/ice_xsk.c
index f1d4240e57df..e452e7d336e3 100644
--- a/drivers/net/ethernet/intel/ice/ice_xsk.c
+++ b/drivers/net/ethernet/intel/ice/ice_xsk.c
@@ -159,7 +159,7 @@ static int ice_qp_dis(struct ice_vsi *vsi, u16 q_idx)
 	rx_ring = vsi->rx_rings[q_idx];
 	q_vector = rx_ring->q_vector;
 
-	while (test_and_set_bit(__ICE_CFG_BUSY, vsi->state)) {
+	while (test_and_set_bit(ICE_CFG_BUSY, vsi->state)) {
 		timeout--;
 		if (!timeout)
 			return -EBUSY;
@@ -249,7 +249,7 @@ static int ice_qp_ena(struct ice_vsi *vsi, u16 q_idx)
 	if (err)
 		goto free_buf;
 
-	clear_bit(__ICE_CFG_BUSY, vsi->state);
+	clear_bit(ICE_CFG_BUSY, vsi->state);
 	ice_qvec_toggle_napi(vsi, q_vector, true);
 	ice_qvec_ena_irq(vsi, q_vector);
 
@@ -765,7 +765,7 @@ ice_xsk_wakeup(struct net_device *netdev, u32 queue_id,
 	struct ice_vsi *vsi = np->vsi;
 	struct ice_ring *ring;
 
-	if (test_bit(__ICE_DOWN, vsi->state))
+	if (test_bit(ICE_DOWN, vsi->state))
 		return -ENETDOWN;
 
 	if (!ice_is_xdp_ena_vsi(vsi))
