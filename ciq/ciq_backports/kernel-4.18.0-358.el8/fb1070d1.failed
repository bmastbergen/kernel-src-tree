KVM: X86: Use _BITUL() macro in UAPI headers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Joe Richey <joerichey@google.com>
commit fb1070d18edb37daf3979662975bc54625a19953
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/fb1070d1.failed

Replace BIT() in KVM's UPAI header with _BITUL(). BIT() is not defined
in the UAPI headers and its usage may cause userspace build errors.

Fixes: fb04a1eddb1a ("KVM: X86: Implement ring-based dirty memory tracking")
	Signed-off-by: Joe Richey <joerichey@google.com>
Message-Id: <20210521085849.37676-3-joerichey94@gmail.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit fb1070d18edb37daf3979662975bc54625a19953)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/include/uapi/linux/kvm.h
diff --cc tools/include/uapi/linux/kvm.h
index dab31a4a50a9,26e6d94d64ed..000000000000
--- a/tools/include/uapi/linux/kvm.h
+++ b/tools/include/uapi/linux/kvm.h
@@@ -1623,4 -1803,55 +1624,58 @@@ struct kvm_hyperv_eventfd 
  #define KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE    (1 << 0)
  #define KVM_DIRTY_LOG_INITIALLY_SET            (1 << 1)
  
++<<<<<<< HEAD
++=======
+ /*
+  * Arch needs to define the macro after implementing the dirty ring
+  * feature.  KVM_DIRTY_LOG_PAGE_OFFSET should be defined as the
+  * starting page offset of the dirty ring structures.
+  */
+ #ifndef KVM_DIRTY_LOG_PAGE_OFFSET
+ #define KVM_DIRTY_LOG_PAGE_OFFSET 0
+ #endif
+ 
+ /*
+  * KVM dirty GFN flags, defined as:
+  *
+  * |---------------+---------------+--------------|
+  * | bit 1 (reset) | bit 0 (dirty) | Status       |
+  * |---------------+---------------+--------------|
+  * |             0 |             0 | Invalid GFN  |
+  * |             0 |             1 | Dirty GFN    |
+  * |             1 |             X | GFN to reset |
+  * |---------------+---------------+--------------|
+  *
+  * Lifecycle of a dirty GFN goes like:
+  *
+  *      dirtied         harvested        reset
+  * 00 -----------> 01 -------------> 1X -------+
+  *  ^                                          |
+  *  |                                          |
+  *  +------------------------------------------+
+  *
+  * The userspace program is only responsible for the 01->1X state
+  * conversion after harvesting an entry.  Also, it must not skip any
+  * dirty bits, so that dirty bits are always harvested in sequence.
+  */
+ #define KVM_DIRTY_GFN_F_DIRTY           _BITUL(0)
+ #define KVM_DIRTY_GFN_F_RESET           _BITUL(1)
+ #define KVM_DIRTY_GFN_F_MASK            0x3
+ 
+ /*
+  * KVM dirty rings should be mapped at KVM_DIRTY_LOG_PAGE_OFFSET of
+  * per-vcpu mmaped regions as an array of struct kvm_dirty_gfn.  The
+  * size of the gfn buffer is decided by the first argument when
+  * enabling KVM_CAP_DIRTY_LOG_RING.
+  */
+ struct kvm_dirty_gfn {
+ 	__u32 flags;
+ 	__u32 slot;
+ 	__u64 offset;
+ };
+ 
+ #define KVM_BUS_LOCK_DETECTION_OFF             (1 << 0)
+ #define KVM_BUS_LOCK_DETECTION_EXIT            (1 << 1)
+ 
++>>>>>>> fb1070d18edb (KVM: X86: Use _BITUL() macro in UAPI headers)
  #endif /* __LINUX_KVM_H */
diff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h
index 1e90d5a48059..baea8f46af61 100644
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@ -8,6 +8,7 @@
  * Note: you must update KVM_API_VERSION if you change this interface.
  */
 
+#include <linux/const.h>
 #include <linux/types.h>
 #include <linux/compiler.h>
 #include <linux/ioctl.h>
@@ -1875,8 +1876,8 @@ struct kvm_hyperv_eventfd {
  * conversion after harvesting an entry.  Also, it must not skip any
  * dirty bits, so that dirty bits are always harvested in sequence.
  */
-#define KVM_DIRTY_GFN_F_DIRTY           BIT(0)
-#define KVM_DIRTY_GFN_F_RESET           BIT(1)
+#define KVM_DIRTY_GFN_F_DIRTY           _BITUL(0)
+#define KVM_DIRTY_GFN_F_RESET           _BITUL(1)
 #define KVM_DIRTY_GFN_F_MASK            0x3
 
 /*
* Unmerged path tools/include/uapi/linux/kvm.h
