ipc: remove memcg accounting for sops objects in do_semtimedop()

jira LE-1907
cve CVE-2021-3759
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Vasily Averin <vvs@virtuozzo.com>
commit 6a4746ba06191e23d30230738e94334b26590a8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/6a4746ba.failed

Linus proposes to revert an accounting for sops objects in
do_semtimedop() because it's really just a temporary buffer
for a single semtimedop() system call.

This object can consume up to 2 pages, syscall is sleeping
one, size and duration can be controlled by user, and this
allocation can be repeated by many thread at the same time.

However Shakeel Butt pointed that there are much more popular
objects with the same life time and similar memory
consumption, the accounting of which was decided to be
rejected for performance reasons.

Considering at least 2 pages for task_struct and 2 pages for
the kernel stack, a back of the envelope calculation gives a
footprint amplification of <1.5 so this temporal buffer can be
safely ignored.

The factor would IMO be interesting if it was >> 2 (from the
PoV of excessive (ab)use, fine-grained accounting seems to be
currently unfeasible due to performance impact).

Link: https://lore.kernel.org/lkml/90e254df-0dfe-f080-011e-b7c53ee7fd20@virtuozzo.com/
Fixes: 18319498fdd4 ("memcg: enable accounting of ipc resources")
	Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Reviewed-by: Michal Koutn√Ω <mkoutny@suse.com>
	Acked-by: Shakeel Butt <shakeelb@google.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 6a4746ba06191e23d30230738e94334b26590a8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	ipc/sem.c
diff --cc ipc/sem.c
index dbef09723735,6693daf4fe11..000000000000
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@@ -2182,9 -2216,40 +2182,43 @@@ static long do_semtimedop(int semid, st
  
  	unlink_queue(sma, &queue);
  
 -out_unlock:
 +out_unlock_free:
  	sem_unlock(sma, locknum);
  	rcu_read_unlock();
++<<<<<<< HEAD
++=======
+ out:
+ 	return error;
+ }
+ 
+ static long do_semtimedop(int semid, struct sembuf __user *tsops,
+ 		unsigned nsops, const struct timespec64 *timeout)
+ {
+ 	struct sembuf fast_sops[SEMOPM_FAST];
+ 	struct sembuf *sops = fast_sops;
+ 	struct ipc_namespace *ns;
+ 	int ret;
+ 
+ 	ns = current->nsproxy->ipc_ns;
+ 	if (nsops > ns->sc_semopm)
+ 		return -E2BIG;
+ 	if (nsops < 1)
+ 		return -EINVAL;
+ 
+ 	if (nsops > SEMOPM_FAST) {
+ 		sops = kvmalloc_array(nsops, sizeof(*sops), GFP_KERNEL);
+ 		if (sops == NULL)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	if (copy_from_user(sops, tsops, nsops * sizeof(*tsops))) {
+ 		ret =  -EFAULT;
+ 		goto out_free;
+ 	}
+ 
+ 	ret = __do_semtimedop(semid, sops, nsops, timeout, ns);
+ 
++>>>>>>> 6a4746ba0619 (ipc: remove memcg accounting for sops objects in do_semtimedop())
  out_free:
  	if (sops != fast_sops)
  		kvfree(sops);
* Unmerged path ipc/sem.c
