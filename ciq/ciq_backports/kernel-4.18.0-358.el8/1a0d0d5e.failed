powerpc/vas: Add platform specific user window operations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Haren Myneni <haren@linux.ibm.com>
commit 1a0d0d5ed5e3cd9e3fc1ad4459f1db2f3618fce0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/1a0d0d5e.failed

PowerNV uses registers to open/close VAS windows, and getting the
paste address. Whereas the hypervisor calls are used on PowerVM.

This patch adds the platform specific user space window operations
and register with the common VAS user space interface.

	Signed-off-by: Haren Myneni <haren@linux.ibm.com>
	Reviewed-by: Nicholas Piggin <npiggin@gmail.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/f85091f4ace67f951ac04d60394d67b21e2f5d3c.camel@linux.ibm.com

(cherry picked from commit 1a0d0d5ed5e3cd9e3fc1ad4459f1db2f3618fce0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/vas.h
#	arch/powerpc/platforms/powernv/vas-window.c
#	arch/powerpc/platforms/powernv/vas.h
diff --cc arch/powerpc/include/asm/vas.h
index 6c441ad0e6ea,163a8bb85d02..000000000000
--- a/arch/powerpc/include/asm/vas.h
+++ b/arch/powerpc/include/asm/vas.h
@@@ -166,6 -173,10 +177,13 @@@ int vas_copy_crb(void *crb, int offset)
   */
  int vas_paste_crb(struct vas_window *win, int offset, bool re);
  
++<<<<<<< HEAD
++=======
+ int vas_register_api_powernv(struct module *mod, enum vas_cop_type cop_type,
+ 			     const char *name);
+ void vas_unregister_api_powernv(void);
+ 
++>>>>>>> 1a0d0d5ed5e3 (powerpc/vas: Add platform specific user window operations)
  /*
   * Register / unregister coprocessor type to VAS API which will be exported
   * to user space. Applications can use this API to open / close window
diff --cc arch/powerpc/platforms/powernv/vas-window.c
index 5516ad56ba07,26440da4fc6a..000000000000
--- a/arch/powerpc/platforms/powernv/vas-window.c
+++ b/arch/powerpc/platforms/powernv/vas-window.c
@@@ -1449,3 -1443,63 +1450,66 @@@ struct vas_window *vas_pswid_to_window(
  
  	return window;
  }
++<<<<<<< HEAD
++=======
+ 
+ static struct vas_window *vas_user_win_open(int vas_id, u64 flags,
+ 				enum vas_cop_type cop_type)
+ {
+ 	struct vas_tx_win_attr txattr = {};
+ 
+ 	vas_init_tx_win_attr(&txattr, cop_type);
+ 
+ 	txattr.lpid = mfspr(SPRN_LPID);
+ 	txattr.pidr = mfspr(SPRN_PID);
+ 	txattr.user_win = true;
+ 	txattr.rsvd_txbuf_count = false;
+ 	txattr.pswid = false;
+ 
+ 	pr_devel("Pid %d: Opening txwin, PIDR %ld\n", txattr.pidr,
+ 				mfspr(SPRN_PID));
+ 
+ 	return vas_tx_win_open(vas_id, cop_type, &txattr);
+ }
+ 
+ static u64 vas_user_win_paste_addr(struct vas_window *win)
+ {
+ 	u64 paste_addr;
+ 
+ 	vas_win_paste_addr(win, &paste_addr, NULL);
+ 
+ 	return paste_addr;
+ }
+ 
+ static int vas_user_win_close(struct vas_window *txwin)
+ {
+ 
+ 	vas_win_close(txwin);
+ 
+ 	return 0;
+ }
+ 
+ static const struct vas_user_win_ops vops =  {
+ 	.open_win	=	vas_user_win_open,
+ 	.paste_addr	=	vas_user_win_paste_addr,
+ 	.close_win	=	vas_user_win_close,
+ };
+ 
+ /*
+  * Supporting only nx-gzip coprocessor type now, but this API code
+  * extended to other coprocessor types later.
+  */
+ int vas_register_api_powernv(struct module *mod, enum vas_cop_type cop_type,
+ 			     const char *name)
+ {
+ 
+ 	return vas_register_coproc_api(mod, cop_type, name, &vops);
+ }
+ EXPORT_SYMBOL_GPL(vas_register_api_powernv);
+ 
+ void vas_unregister_api_powernv(void)
+ {
+ 	vas_unregister_coproc_api();
+ }
+ EXPORT_SYMBOL_GPL(vas_unregister_api_powernv);
++>>>>>>> 1a0d0d5ed5e3 (powerpc/vas: Add platform specific user window operations)
diff --cc arch/powerpc/platforms/powernv/vas.h
index 27337783457b,c2b1e12efca5..000000000000
--- a/arch/powerpc/platforms/powernv/vas.h
+++ b/arch/powerpc/platforms/powernv/vas.h
@@@ -441,7 -439,7 +441,11 @@@ extern void vas_return_credit(struct va
  extern struct vas_window *vas_pswid_to_window(struct vas_instance *vinst,
  						uint32_t pswid);
  extern void vas_win_paste_addr(struct vas_window *window, u64 *addr,
++<<<<<<< HEAD
 +					int *len);
++=======
+ 				int *len);
++>>>>>>> 1a0d0d5ed5e3 (powerpc/vas: Add platform specific user window operations)
  
  static inline int vas_window_pid(struct vas_window *window)
  {
* Unmerged path arch/powerpc/include/asm/vas.h
diff --git a/arch/powerpc/platforms/powernv/vas-api.c b/arch/powerpc/platforms/powernv/vas-api.c
index 4312140f6776..9ea013e6104a 100644
--- a/arch/powerpc/platforms/powernv/vas-api.c
+++ b/arch/powerpc/platforms/powernv/vas-api.c
@@ -43,6 +43,7 @@ static struct coproc_dev {
 	dev_t devt;
 	struct class *class;
 	enum vas_cop_type cop_type;
+	const struct vas_user_win_ops *vops;
 } coproc_device;
 
 struct coproc_instance {
@@ -73,11 +74,10 @@ static int coproc_open(struct inode *inode, struct file *fp)
 static int coproc_ioc_tx_win_open(struct file *fp, unsigned long arg)
 {
 	void __user *uptr = (void __user *)arg;
-	struct vas_tx_win_attr txattr = {};
 	struct vas_tx_win_open_attr uattr;
 	struct coproc_instance *cp_inst;
 	struct vas_window *txwin;
-	int rc, vasid;
+	int rc;
 
 	cp_inst = fp->private_data;
 
@@ -94,27 +94,20 @@ static int coproc_ioc_tx_win_open(struct file *fp, unsigned long arg)
 	}
 
 	if (uattr.version != 1) {
-		pr_err("Invalid version\n");
+		pr_err("Invalid window open API version\n");
 		return -EINVAL;
 	}
 
-	vasid = uattr.vas_id;
-
-	vas_init_tx_win_attr(&txattr, cp_inst->coproc->cop_type);
-
-	txattr.lpid = mfspr(SPRN_LPID);
-	txattr.pidr = mfspr(SPRN_PID);
-	txattr.user_win = true;
-	txattr.rsvd_txbuf_count = false;
-	txattr.pswid = false;
-
-	pr_devel("Pid %d: Opening txwin, PIDR %ld\n", txattr.pidr,
-				mfspr(SPRN_PID));
+	if (!cp_inst->coproc->vops && !cp_inst->coproc->vops->open_win) {
+		pr_err("VAS API is not registered\n");
+		return -EACCES;
+	}
 
-	txwin = vas_tx_win_open(vasid, cp_inst->coproc->cop_type, &txattr);
+	txwin = cp_inst->coproc->vops->open_win(uattr.vas_id, uattr.flags,
+						cp_inst->coproc->cop_type);
 	if (IS_ERR(txwin)) {
-		pr_err("%s() vas_tx_win_open() failed, %ld\n", __func__,
-					PTR_ERR(txwin));
+		pr_err("%s() VAS window open failed, %ld\n", __func__,
+				PTR_ERR(txwin));
 		return PTR_ERR(txwin);
 	}
 
@@ -126,9 +119,15 @@ static int coproc_ioc_tx_win_open(struct file *fp, unsigned long arg)
 static int coproc_release(struct inode *inode, struct file *fp)
 {
 	struct coproc_instance *cp_inst = fp->private_data;
+	int rc;
 
 	if (cp_inst->txwin) {
-		vas_win_close(cp_inst->txwin);
+		if (cp_inst->coproc->vops &&
+			cp_inst->coproc->vops->close_win) {
+			rc = cp_inst->coproc->vops->close_win(cp_inst->txwin);
+			if (rc)
+				return rc;
+		}
 		cp_inst->txwin = NULL;
 	}
 
@@ -169,7 +168,17 @@ static int coproc_mmap(struct file *fp, struct vm_area_struct *vma)
 		return -EINVAL;
 	}
 
-	vas_win_paste_addr(txwin, &paste_addr, NULL);
+	if (!cp_inst->coproc->vops && !cp_inst->coproc->vops->paste_addr) {
+		pr_err("%s(): VAS API is not registered\n", __func__);
+		return -EACCES;
+	}
+
+	paste_addr = cp_inst->coproc->vops->paste_addr(txwin);
+	if (!paste_addr) {
+		pr_err("%s(): Window paste address failed\n", __func__);
+		return -EINVAL;
+	}
+
 	pfn = paste_addr >> PAGE_SHIFT;
 
 	/* flags, page_prot from cxl_mmap(), except we want cachable */
@@ -209,7 +218,8 @@ static struct file_operations coproc_fops = {
  * extended to other coprocessor types later.
  */
 int vas_register_coproc_api(struct module *mod, enum vas_cop_type cop_type,
-				const char *name)
+			    const char *name,
+			    const struct vas_user_win_ops *vops)
 {
 	int rc = -EINVAL;
 	dev_t devno;
@@ -231,6 +241,7 @@ int vas_register_coproc_api(struct module *mod, enum vas_cop_type cop_type,
 	}
 	coproc_device.class->devnode = coproc_devnode;
 	coproc_device.cop_type = cop_type;
+	coproc_device.vops = vops;
 
 	coproc_fops.owner = mod;
 	cdev_init(&coproc_device.cdev, &coproc_fops);
* Unmerged path arch/powerpc/platforms/powernv/vas-window.c
* Unmerged path arch/powerpc/platforms/powernv/vas.h
