ice: Register auxiliary device to provide RDMA

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Dave Ertman <david.m.ertman@intel.com>
commit f9f5301e7e2d4fa2445aab3ec889dac6b34ea63e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/f9f5301e.failed

Register ice client auxiliary RDMA device on the auxiliary bus per
PCIe device function for the auxiliary driver (irdma) to attach to.
It allows to realize a single RDMA driver (irdma) capable of working with
multiple netdev drivers over multi-generation Intel HW supporting RDMA.
There is no load ordering dependencies between ice and irdma.

	Signed-off-by: Dave Ertman <david.m.ertman@intel.com>
	Signed-off-by: Shiraz Saleem <shiraz.saleem@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit f9f5301e7e2d4fa2445aab3ec889dac6b34ea63e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice.h
#	drivers/net/ethernet/intel/ice/ice_idc.c
#	drivers/net/ethernet/intel/ice/ice_main.c
diff --cc drivers/net/ethernet/intel/ice/ice.h
index 5e29f3ac887e,228055e8f33b..000000000000
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@@ -621,6 -648,9 +622,12 @@@ int ice_get_rss_key(struct ice_vsi *vsi
  void ice_fill_rss_lut(u8 *lut, u16 rss_table_size, u16 rss_size);
  int ice_schedule_reset(struct ice_pf *pf, enum ice_reset_req reset);
  void ice_print_link_msg(struct ice_vsi *vsi, bool isup);
++<<<<<<< HEAD
++=======
+ int ice_plug_aux_dev(struct ice_pf *pf);
+ void ice_unplug_aux_dev(struct ice_pf *pf);
+ int ice_init_rdma(struct ice_pf *pf);
++>>>>>>> f9f5301e7e2d (ice: Register auxiliary device to provide RDMA)
  const char *ice_stat_str(enum ice_status stat_err);
  const char *ice_aq_str(enum ice_aq_err aq_err);
  bool ice_is_wol_supported(struct ice_hw *hw);
@@@ -645,4 -675,25 +652,28 @@@ int ice_open_internal(struct net_devic
  int ice_stop(struct net_device *netdev);
  void ice_service_task_schedule(struct ice_pf *pf);
  
++<<<<<<< HEAD
++=======
+ /**
+  * ice_set_rdma_cap - enable RDMA support
+  * @pf: PF struct
+  */
+ static inline void ice_set_rdma_cap(struct ice_pf *pf)
+ {
+ 	if (pf->hw.func_caps.common_cap.rdma && pf->num_rdma_msix) {
+ 		set_bit(ICE_FLAG_RDMA_ENA, pf->flags);
+ 		ice_plug_aux_dev(pf);
+ 	}
+ }
+ 
+ /**
+  * ice_clear_rdma_cap - disable RDMA support
+  * @pf: PF struct
+  */
+ static inline void ice_clear_rdma_cap(struct ice_pf *pf)
+ {
+ 	ice_unplug_aux_dev(pf);
+ 	clear_bit(ICE_FLAG_RDMA_ENA, pf->flags);
+ }
++>>>>>>> f9f5301e7e2d (ice: Register auxiliary device to provide RDMA)
  #endif /* _ICE_H_ */
diff --cc drivers/net/ethernet/intel/ice/ice_main.c
index 4d9dc76890e0,254cfc14d6b4..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@@ -462,9 -453,11 +462,11 @@@ ice_prepare_for_reset(struct ice_pf *pf
  	unsigned int i;
  
  	/* already prepared for reset */
 -	if (test_bit(ICE_PREPARED_FOR_RESET, pf->state))
 +	if (test_bit(__ICE_PREPARED_FOR_RESET, pf->state))
  		return;
  
+ 	ice_unplug_aux_dev(pf);
+ 
  	/* Notify VFs of impending reset */
  	if (ice_check_sq_alive(hw, &hw->mailboxq))
  		ice_vc_notify_reset(pf);
@@@ -2169,15 -2122,17 +2171,17 @@@ int ice_schedule_reset(struct ice_pf *p
  		return -EBUSY;
  	}
  
+ 	ice_unplug_aux_dev(pf);
+ 
  	switch (reset) {
  	case ICE_RESET_PFR:
 -		set_bit(ICE_PFR_REQ, pf->state);
 +		set_bit(__ICE_PFR_REQ, pf->state);
  		break;
  	case ICE_RESET_CORER:
 -		set_bit(ICE_CORER_REQ, pf->state);
 +		set_bit(__ICE_CORER_REQ, pf->state);
  		break;
  	case ICE_RESET_GLOBR:
 -		set_bit(ICE_GLOBR_REQ, pf->state);
 +		set_bit(__ICE_GLOBR_REQ, pf->state);
  		break;
  	default:
  		return -EINVAL;
@@@ -4434,14 -4460,15 +4438,23 @@@ static void ice_remove(struct pci_dev *
  		ice_free_vfs(pf);
  	}
  
++<<<<<<< HEAD
 +	set_bit(__ICE_DOWN, pf->state);
 +	ice_service_task_stop(pf);
 +
 +	ice_aq_cancel_waiting_tasks(pf);
++=======
+ 	ice_service_task_stop(pf);
+ 
+ 	ice_aq_cancel_waiting_tasks(pf);
+ 	ice_unplug_aux_dev(pf);
+ 	ida_free(&ice_aux_ida, pf->aux_idx);
+ 	set_bit(ICE_DOWN, pf->state);
++>>>>>>> f9f5301e7e2d (ice: Register auxiliary device to provide RDMA)
  
  	mutex_destroy(&(&pf->hw)->fdir_fltr_lock);
 -	ice_deinit_lag(pf);
 +	if (test_bit(ICE_FLAG_PTP_SUPPORTED, pf->flags))
 +		ice_ptp_release(pf);
  	if (!ice_is_safe_mode(pf))
  		ice_remove_arfs(pf);
  	ice_setup_mc_magic_wake(pf);
@@@ -4594,8 -4621,10 +4607,10 @@@ static int __maybe_unused ice_suspend(s
  	 */
  	disabled = ice_service_task_stop(pf);
  
+ 	ice_unplug_aux_dev(pf);
+ 
  	/* Already suspended?, then there is nothing to do */
 -	if (test_and_set_bit(ICE_SUSPENDED, pf->state)) {
 +	if (test_and_set_bit(__ICE_SUSPENDED, pf->state)) {
  		if (!disabled)
  			ice_service_task_restart(pf);
  		return 0;
@@@ -6274,7 -6292,9 +6289,13 @@@ static void ice_rebuild(struct ice_pf *
  	ice_replay_post(hw);
  
  	/* if we get here, reset flow is successful */
++<<<<<<< HEAD
 +	clear_bit(__ICE_RESET_FAILED, pf->state);
++=======
+ 	clear_bit(ICE_RESET_FAILED, pf->state);
+ 
+ 	ice_plug_aux_dev(pf);
++>>>>>>> f9f5301e7e2d (ice: Register auxiliary device to provide RDMA)
  	return;
  
  err_vsi_rebuild:
* Unmerged path drivers/net/ethernet/intel/ice/ice_idc.c
diff --git a/drivers/net/ethernet/intel/Kconfig b/drivers/net/ethernet/intel/Kconfig
index 8991d3550753..42939e71733d 100644
--- a/drivers/net/ethernet/intel/Kconfig
+++ b/drivers/net/ethernet/intel/Kconfig
@@ -281,6 +281,7 @@ config ICE
 	tristate "Intel(R) Ethernet Connection E800 Series Support"
 	default n
 	depends on PCI_MSI
+	select AUXILIARY_BUS
 	select DIMLIB
 	select NET_DEVLINK
 	select PLDMFW
* Unmerged path drivers/net/ethernet/intel/ice/ice.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_idc.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_main.c
