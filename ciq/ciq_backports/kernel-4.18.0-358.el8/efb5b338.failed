net: bridge: fix misspellings using codespell tool

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Menglong Dong <dong.menglong@zte.com.cn>
commit efb5b338da6a0d474cdab3bfc11edef32ed0c173
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/efb5b338.failed

Some typos are found out by codespell tool:

$ codespell ./net/bridge/
./net/bridge/br_stp.c:604: permanant  ==> permanent
./net/bridge/br_stp.c:605: persistance  ==> persistence
./net/bridge/br.c:125: underlaying  ==> underlying
./net/bridge/br_input.c:43: modue  ==> mode
./net/bridge/br_mrp.c:828: Determin  ==> Determine
./net/bridge/br_mrp.c:848: Determin  ==> Determine
./net/bridge/br_mrp.c:897: Determin  ==> Determine

Fix typos found by codespell.

	Signed-off-by: Menglong Dong <dong.menglong@zte.com.cn>
	Acked-by: Randy Dunlap <rdunlap@infradead.org>
Link: https://lore.kernel.org/r/20210108025332.52480-1-dong.menglong@zte.com.cn
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit efb5b338da6a0d474cdab3bfc11edef32ed0c173)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_mrp.c
diff --cc net/bridge/br_mrp.c
index d673550412b4,fc0a98874bfc..000000000000
--- a/net/bridge/br_mrp.c
+++ b/net/bridge/br_mrp.c
@@@ -486,6 -690,181 +486,184 @@@ int br_mrp_start_test(struct net_bridg
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* Set in state, int state can be only Open or Closed
+  * note: already called with rtnl_lock
+  */
+ int br_mrp_set_in_state(struct net_bridge *br, struct br_mrp_in_state *state)
+ {
+ 	struct br_mrp *mrp = br_mrp_find_in_id(br, state->in_id);
+ 
+ 	if (!mrp)
+ 		return -EINVAL;
+ 
+ 	if (mrp->in_state == BR_MRP_IN_STATE_CLOSED &&
+ 	    state->in_state != BR_MRP_IN_STATE_CLOSED)
+ 		mrp->in_transitions++;
+ 
+ 	mrp->in_state = state->in_state;
+ 
+ 	br_mrp_switchdev_set_in_state(br, mrp, state->in_state);
+ 
+ 	return 0;
+ }
+ 
+ /* Set in role, in role can be only MIM(Media Interconnection Manager) or
+  * MIC(Media Interconnection Client).
+  * note: already called with rtnl_lock
+  */
+ int br_mrp_set_in_role(struct net_bridge *br, struct br_mrp_in_role *role)
+ {
+ 	struct br_mrp *mrp = br_mrp_find_id(br, role->ring_id);
+ 	struct net_bridge_port *p;
+ 	int err;
+ 
+ 	if (!mrp)
+ 		return -EINVAL;
+ 
+ 	if (!br_mrp_get_port(br, role->i_ifindex))
+ 		return -EINVAL;
+ 
+ 	if (role->in_role == BR_MRP_IN_ROLE_DISABLED) {
+ 		u8 state;
+ 
+ 		/* It is not allowed to disable a port that doesn't exist */
+ 		p = rtnl_dereference(mrp->i_port);
+ 		if (!p)
+ 			return -EINVAL;
+ 
+ 		/* Stop the generating MRP_InTest frames */
+ 		cancel_delayed_work_sync(&mrp->in_test_work);
+ 		br_mrp_switchdev_send_in_test(br, mrp, 0, 0, 0);
+ 
+ 		/* Remove the port */
+ 		spin_lock_bh(&br->lock);
+ 		state = netif_running(br->dev) ?
+ 				BR_STATE_FORWARDING : BR_STATE_DISABLED;
+ 		p->state = state;
+ 		p->flags &= ~BR_MRP_AWARE;
+ 		spin_unlock_bh(&br->lock);
+ 		br_mrp_port_switchdev_set_state(p, state);
+ 		rcu_assign_pointer(mrp->i_port, NULL);
+ 
+ 		mrp->in_role = role->in_role;
+ 		mrp->in_id = 0;
+ 
+ 		return 0;
+ 	}
+ 
+ 	/* It is not possible to have the same port part of multiple rings */
+ 	if (!br_mrp_unique_ifindex(br, role->i_ifindex))
+ 		return -EINVAL;
+ 
+ 	/* It is not allowed to set a different interconnect port if the mrp
+ 	 * instance has already one. First it needs to be disabled and after
+ 	 * that set the new port
+ 	 */
+ 	if (rcu_access_pointer(mrp->i_port))
+ 		return -EINVAL;
+ 
+ 	p = br_mrp_get_port(br, role->i_ifindex);
+ 	spin_lock_bh(&br->lock);
+ 	p->state = BR_STATE_FORWARDING;
+ 	p->flags |= BR_MRP_AWARE;
+ 	spin_unlock_bh(&br->lock);
+ 	rcu_assign_pointer(mrp->i_port, p);
+ 
+ 	mrp->in_role = role->in_role;
+ 	mrp->in_id = role->in_id;
+ 
+ 	/* If there is an error just bailed out */
+ 	err = br_mrp_switchdev_set_in_role(br, mrp, role->in_id,
+ 					   role->ring_id, role->in_role);
+ 	if (err && err != -EOPNOTSUPP)
+ 		return err;
+ 
+ 	/* Now detect if the HW actually applied the role or not. If the HW
+ 	 * applied the role it means that the SW will not to do those operations
+ 	 * anymore. For example if the role is MIM then the HW will notify the
+ 	 * SW when interconnect ring is open, but if the is not pushed to the HW
+ 	 * the SW will need to detect when the interconnect ring is open.
+ 	 */
+ 	mrp->in_role_offloaded = err == -EOPNOTSUPP ? 0 : 1;
+ 
+ 	return 0;
+ }
+ 
+ /* Start to generate MRP_InTest frames, the frames are generated by
+  * HW and if it fails, they are generated by the SW.
+  * note: already called with rtnl_lock
+  */
+ int br_mrp_start_in_test(struct net_bridge *br,
+ 			 struct br_mrp_start_in_test *in_test)
+ {
+ 	struct br_mrp *mrp = br_mrp_find_in_id(br, in_test->in_id);
+ 
+ 	if (!mrp)
+ 		return -EINVAL;
+ 
+ 	if (mrp->in_role != BR_MRP_IN_ROLE_MIM)
+ 		return -EINVAL;
+ 
+ 	/* Try to push it to the HW and if it fails then continue with SW
+ 	 * implementation and if that also fails then return error.
+ 	 */
+ 	if (!br_mrp_switchdev_send_in_test(br, mrp, in_test->interval,
+ 					   in_test->max_miss, in_test->period))
+ 		return 0;
+ 
+ 	mrp->in_test_interval = in_test->interval;
+ 	mrp->in_test_end = jiffies + usecs_to_jiffies(in_test->period);
+ 	mrp->in_test_max_miss = in_test->max_miss;
+ 	mrp->in_test_count_miss = 0;
+ 	queue_delayed_work(system_wq, &mrp->in_test_work,
+ 			   usecs_to_jiffies(in_test->interval));
+ 
+ 	return 0;
+ }
+ 
+ /* Determine if the frame type is a ring frame */
+ static bool br_mrp_ring_frame(struct sk_buff *skb)
+ {
+ 	const struct br_mrp_tlv_hdr *hdr;
+ 	struct br_mrp_tlv_hdr _hdr;
+ 
+ 	hdr = skb_header_pointer(skb, sizeof(uint16_t), sizeof(_hdr), &_hdr);
+ 	if (!hdr)
+ 		return false;
+ 
+ 	if (hdr->type == BR_MRP_TLV_HEADER_RING_TEST ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_RING_TOPO ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_RING_LINK_DOWN ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_RING_LINK_UP ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_OPTION)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ /* Determine if the frame type is an interconnect frame */
+ static bool br_mrp_in_frame(struct sk_buff *skb)
+ {
+ 	const struct br_mrp_tlv_hdr *hdr;
+ 	struct br_mrp_tlv_hdr _hdr;
+ 
+ 	hdr = skb_header_pointer(skb, sizeof(uint16_t), sizeof(_hdr), &_hdr);
+ 	if (!hdr)
+ 		return false;
+ 
+ 	if (hdr->type == BR_MRP_TLV_HEADER_IN_TEST ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_IN_TOPO ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_IN_LINK_DOWN ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_IN_LINK_UP ||
+ 	    hdr->type == BR_MRP_TLV_HEADER_IN_LINK_STATUS)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
++>>>>>>> efb5b338da6a (net: bridge: fix misspellings using codespell tool)
  /* Process only MRP Test frame. All the other MRP frames are processed by
   * userspace application
   * note: already called with rcu_read_lock
@@@ -515,8 -894,135 +693,140 @@@ static void br_mrp_mrm_process(struct b
  		br_mrp_ring_port_open(port->dev, false);
  }
  
++<<<<<<< HEAD
 +/* This will just forward the frame to the other mrp ring port(MRC role) or will
 + * not do anything.
++=======
+ /* Determine if the test hdr has a better priority than the node */
+ static bool br_mrp_test_better_than_own(struct br_mrp *mrp,
+ 					struct net_bridge *br,
+ 					const struct br_mrp_ring_test_hdr *hdr)
+ {
+ 	u16 prio = be16_to_cpu(hdr->prio);
+ 
+ 	if (prio < mrp->prio ||
+ 	    (prio == mrp->prio &&
+ 	    ether_addr_to_u64(hdr->sa) < ether_addr_to_u64(br->dev->dev_addr)))
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ /* Process only MRP Test frame. All the other MRP frames are processed by
+  * userspace application
+  * note: already called with rcu_read_lock
+  */
+ static void br_mrp_mra_process(struct br_mrp *mrp, struct net_bridge *br,
+ 			       struct net_bridge_port *port,
+ 			       struct sk_buff *skb)
+ {
+ 	const struct br_mrp_ring_test_hdr *test_hdr;
+ 	struct br_mrp_ring_test_hdr _test_hdr;
+ 	const struct br_mrp_tlv_hdr *hdr;
+ 	struct br_mrp_tlv_hdr _hdr;
+ 
+ 	/* Each MRP header starts with a version field which is 16 bits.
+ 	 * Therefore skip the version and get directly the TLV header.
+ 	 */
+ 	hdr = skb_header_pointer(skb, sizeof(uint16_t), sizeof(_hdr), &_hdr);
+ 	if (!hdr)
+ 		return;
+ 
+ 	if (hdr->type != BR_MRP_TLV_HEADER_RING_TEST)
+ 		return;
+ 
+ 	test_hdr = skb_header_pointer(skb, sizeof(uint16_t) + sizeof(_hdr),
+ 				      sizeof(_test_hdr), &_test_hdr);
+ 	if (!test_hdr)
+ 		return;
+ 
+ 	/* Only frames that have a better priority than the node will
+ 	 * clear the miss counter because otherwise the node will need to behave
+ 	 * as MRM.
+ 	 */
+ 	if (br_mrp_test_better_than_own(mrp, br, test_hdr))
+ 		mrp->test_count_miss = 0;
+ }
+ 
+ /* Process only MRP InTest frame. All the other MRP frames are processed by
+  * userspace application
+  * note: already called with rcu_read_lock
+  */
+ static bool br_mrp_mim_process(struct br_mrp *mrp, struct net_bridge_port *port,
+ 			       struct sk_buff *skb)
+ {
+ 	const struct br_mrp_in_test_hdr *in_hdr;
+ 	struct br_mrp_in_test_hdr _in_hdr;
+ 	const struct br_mrp_tlv_hdr *hdr;
+ 	struct br_mrp_tlv_hdr _hdr;
+ 
+ 	/* Each MRP header starts with a version field which is 16 bits.
+ 	 * Therefore skip the version and get directly the TLV header.
+ 	 */
+ 	hdr = skb_header_pointer(skb, sizeof(uint16_t), sizeof(_hdr), &_hdr);
+ 	if (!hdr)
+ 		return false;
+ 
+ 	/* The check for InTest frame type was already done */
+ 	in_hdr = skb_header_pointer(skb, sizeof(uint16_t) + sizeof(_hdr),
+ 				    sizeof(_in_hdr), &_in_hdr);
+ 	if (!in_hdr)
+ 		return false;
+ 
+ 	/* It needs to process only it's own InTest frames. */
+ 	if (mrp->in_id != ntohs(in_hdr->id))
+ 		return false;
+ 
+ 	mrp->in_test_count_miss = 0;
+ 
+ 	/* Notify the userspace that the ring is closed only when the ring is
+ 	 * not closed
+ 	 */
+ 	if (mrp->in_state != BR_MRP_IN_STATE_CLOSED)
+ 		br_mrp_in_port_open(port->dev, false);
+ 
+ 	return true;
+ }
+ 
+ /* Get the MRP frame type
+  * note: already called with rcu_read_lock
+  */
+ static u8 br_mrp_get_frame_type(struct sk_buff *skb)
+ {
+ 	const struct br_mrp_tlv_hdr *hdr;
+ 	struct br_mrp_tlv_hdr _hdr;
+ 
+ 	/* Each MRP header starts with a version field which is 16 bits.
+ 	 * Therefore skip the version and get directly the TLV header.
+ 	 */
+ 	hdr = skb_header_pointer(skb, sizeof(uint16_t), sizeof(_hdr), &_hdr);
+ 	if (!hdr)
+ 		return 0xff;
+ 
+ 	return hdr->type;
+ }
+ 
+ static bool br_mrp_mrm_behaviour(struct br_mrp *mrp)
+ {
+ 	if (mrp->ring_role == BR_MRP_RING_ROLE_MRM ||
+ 	    (mrp->ring_role == BR_MRP_RING_ROLE_MRA && !mrp->test_monitor))
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static bool br_mrp_mrc_behaviour(struct br_mrp *mrp)
+ {
+ 	if (mrp->ring_role == BR_MRP_RING_ROLE_MRC ||
+ 	    (mrp->ring_role == BR_MRP_RING_ROLE_MRA && mrp->test_monitor))
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ /* This will just forward the frame to the other mrp ring ports, depending on
+  * the frame type, ring role and interconnect role
++>>>>>>> efb5b338da6a (net: bridge: fix misspellings using codespell tool)
   * note: already called with rcu_read_lock
   */
  static int br_mrp_rcv(struct net_bridge_port *p,
diff --git a/net/bridge/br.c b/net/bridge/br.c
index 77c8f6ec5329..550a228a640b 100644
--- a/net/bridge/br.c
+++ b/net/bridge/br.c
@@ -126,7 +126,7 @@ static int br_device_event(struct notifier_block *unused, unsigned long event, v
 		break;
 
 	case NETDEV_PRE_TYPE_CHANGE:
-		/* Forbid underlaying device to change its type. */
+		/* Forbid underlying device to change its type. */
 		return NOTIFY_BAD;
 
 	case NETDEV_RESEND_IGMP:
diff --git a/net/bridge/br_input.c b/net/bridge/br_input.c
index 3b32225025b1..9aa8389ca425 100644
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@ -48,7 +48,7 @@ static int br_pass_frame_up(struct sk_buff *skb)
 
 	vg = br_vlan_group_rcu(br);
 	/* Bridge is just like any other port.  Make sure the
-	 * packet is allowed except in promisc modue when someone
+	 * packet is allowed except in promisc mode when someone
 	 * may be running packet capture.
 	 */
 	if (!(brdev->flags & IFF_PROMISC) &&
* Unmerged path net/bridge/br_mrp.c
diff --git a/net/bridge/br_stp.c b/net/bridge/br_stp.c
index 4715353eba7c..2d9d979e6a50 100644
--- a/net/bridge/br_stp.c
+++ b/net/bridge/br_stp.c
@@ -605,8 +605,8 @@ int __set_ageing_time(struct net_device *dev, unsigned long t)
 /* Set time interval that dynamic forwarding entries live
  * For pure software bridge, allow values outside the 802.1
  * standard specification for special cases:
- *  0 - entry never ages (all permanant)
- *  1 - entry disappears (no persistance)
+ *  0 - entry never ages (all permanent)
+ *  1 - entry disappears (no persistence)
  *
  * Offloaded switch entries maybe more restrictive
  */
