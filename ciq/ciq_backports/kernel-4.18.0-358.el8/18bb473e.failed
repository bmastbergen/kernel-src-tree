mm: vmscan: shrink deferred objects proportional to priority

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Yang Shi <shy828301@gmail.com>
commit 18bb473e5031213ebfa9a622c0b0f8cdcb8a5371
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/18bb473e.failed

The number of deferred objects might get windup to an absurd number, and
it results in clamp of slab objects.  It is undesirable for sustaining
workingset.

So shrink deferred objects proportional to priority and cap nr_deferred
to twice of cache items.

The idea is borrowed from Dave Chinner's patch:
  https://lore.kernel.org/linux-xfs/20191031234618.15403-13-david@fromorbit.com/

Tested with kernel build and vfs metadata heavy workload in our
production environment, no regression is spotted so far.

Link: https://lkml.kernel.org/r/20210311190845.9708-14-shy828301@gmail.com
	Signed-off-by: Yang Shi <shy828301@gmail.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Kirill Tkhai <ktkhai@virtuozzo.com>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Roman Gushchin <guro@fb.com>
	Cc: Shakeel Butt <shakeelb@google.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 18bb473e5031213ebfa9a622c0b0f8cdcb8a5371)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/vmscan.c
diff --cc mm/vmscan.c
index f5da07494c0e,44c49acf10c4..000000000000
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@@ -653,37 -677,9 +652,42 @@@ static unsigned long do_shrink_slab(str
  		delta = freeable / 2;
  	}
  
+ 	total_scan = nr >> priority;
  	total_scan += delta;
++<<<<<<< HEAD
 +	if (total_scan < 0) {
 +		pr_err("shrink_slab: %pF negative objects to delete nr=%ld\n",
 +		       shrinker->scan_objects, total_scan);
 +		total_scan = freeable;
 +		next_deferred = nr;
 +	} else
 +		next_deferred = total_scan;
 +
 +	/*
 +	 * We need to avoid excessive windup on filesystem shrinkers
 +	 * due to large numbers of GFP_NOFS allocations causing the
 +	 * shrinkers to return -1 all the time. This results in a large
 +	 * nr being built up so when a shrink that can do some work
 +	 * comes along it empties the entire cache due to nr >>>
 +	 * freeable. This is bad for sustaining a working set in
 +	 * memory.
 +	 *
 +	 * Hence only allow the shrinker to scan the entire cache when
 +	 * a large delta change is calculated directly.
 +	 */
 +	if (delta < freeable / 4)
 +		total_scan = min(total_scan, freeable / 2);
 +
 +	/*
 +	 * Avoid risking looping forever due to too large nr value:
 +	 * never try to free more than twice the estimate number of
 +	 * freeable entries.
 +	 */
 +	if (total_scan > freeable * 2)
 +		total_scan = freeable * 2;
++=======
+ 	total_scan = min(total_scan, (2 * freeable));
++>>>>>>> 18bb473e5031 (mm: vmscan: shrink deferred objects proportional to priority)
  
  	trace_mm_shrink_slab_start(shrinker, shrinkctl, nr,
  				   freeable, delta, total_scan, priority);
* Unmerged path mm/vmscan.c
