PCI: Unify ECAM constants in native PCI Express drivers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Krzysztof Wilczyński <kw@linux.com>
commit e7708f5b10e205d6291bb495e645a03553b9768b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/e7708f5b.failed

Add ECAM-related constants to provide a set of standard constants
defining memory address shift values to the byte-level address that can
be used to access the PCI Express Configuration Space, and then move
native PCI Express controller drivers to use the newly introduced
definitions retiring driver-specific ones.

Refactor pci_ecam_map_bus() function to use newly added constants so
that limits to the bus, device function and offset (now limited to 4K as
per the specification) are in place to prevent the defective or
malicious caller from supplying incorrect configuration offset and thus
targeting the wrong device when accessing extended configuration space.

This refactor also allows for the ".bus_shift" initialisers to be
dropped when the user is not using a custom value as a default value
will be used as per the PCI Express Specification.

Thanks to Qian Cai <qcai@redhat.com>, Michael Walle <michael@walle.cc>,
and Vladimir Oltean <olteanv@gmail.com> for reporting a pci_ecam_create()
issue with .bus_shift and to Vladimir for proposing the fix.

[bhelgaas: incorporate Vladimir's fix, update commit log]
	Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
Link: https://lore.kernel.org/r/20201129230743.3006978-2-kw@linux.com
	Tested-by: Michael Walle <michael@walle.cc>
	Signed-off-by: Krzysztof Wilczyński <kw@linux.com>
	Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Jon Derrick <jonathan.derrick@intel.com>
	Reviewed-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit e7708f5b10e205d6291bb495e645a03553b9768b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/controller/dwc/pcie-al.c
#	drivers/pci/controller/dwc/pcie-hisi.c
#	drivers/pci/controller/pci-aardvark.c
#	drivers/pci/controller/pcie-brcmstb.c
diff --cc drivers/pci/controller/dwc/pcie-al.c
index fb12736f95c6,af9e51ab1af8..000000000000
--- a/drivers/pci/controller/dwc/pcie-al.c
+++ b/drivers/pci/controller/dwc/pcie-al.c
@@@ -91,3 -85,323 +90,326 @@@ const struct pci_ecam_ops al_pcie_ops 
  };
  
  #endif /* defined(CONFIG_ACPI) && defined(CONFIG_PCI_QUIRKS) */
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_PCIE_AL
+ 
+ #include <linux/of_pci.h>
+ #include "pcie-designware.h"
+ 
+ #define AL_PCIE_REV_ID_2	2
+ #define AL_PCIE_REV_ID_3	3
+ #define AL_PCIE_REV_ID_4	4
+ 
+ #define AXI_BASE_OFFSET		0x0
+ 
+ #define DEVICE_ID_OFFSET	0x16c
+ 
+ #define DEVICE_REV_ID			0x0
+ #define DEVICE_REV_ID_DEV_ID_MASK	GENMASK(31, 16)
+ 
+ #define DEVICE_REV_ID_DEV_ID_X4		0
+ #define DEVICE_REV_ID_DEV_ID_X8		2
+ #define DEVICE_REV_ID_DEV_ID_X16	4
+ 
+ #define OB_CTRL_REV1_2_OFFSET	0x0040
+ #define OB_CTRL_REV3_5_OFFSET	0x0030
+ 
+ #define CFG_TARGET_BUS			0x0
+ #define CFG_TARGET_BUS_MASK_MASK	GENMASK(7, 0)
+ #define CFG_TARGET_BUS_BUSNUM_MASK	GENMASK(15, 8)
+ 
+ #define CFG_CONTROL			0x4
+ #define CFG_CONTROL_SUBBUS_MASK		GENMASK(15, 8)
+ #define CFG_CONTROL_SEC_BUS_MASK	GENMASK(23, 16)
+ 
+ struct al_pcie_reg_offsets {
+ 	unsigned int ob_ctrl;
+ };
+ 
+ struct al_pcie_target_bus_cfg {
+ 	u8 reg_val;
+ 	u8 reg_mask;
+ 	u8 ecam_mask;
+ };
+ 
+ struct al_pcie {
+ 	struct dw_pcie *pci;
+ 	void __iomem *controller_base; /* base of PCIe unit (not DW core) */
+ 	struct device *dev;
+ 	resource_size_t ecam_size;
+ 	unsigned int controller_rev_id;
+ 	struct al_pcie_reg_offsets reg_offsets;
+ 	struct al_pcie_target_bus_cfg target_bus_cfg;
+ };
+ 
+ #define to_al_pcie(x)		dev_get_drvdata((x)->dev)
+ 
+ static inline u32 al_pcie_controller_readl(struct al_pcie *pcie, u32 offset)
+ {
+ 	return readl_relaxed(pcie->controller_base + offset);
+ }
+ 
+ static inline void al_pcie_controller_writel(struct al_pcie *pcie, u32 offset,
+ 					     u32 val)
+ {
+ 	writel_relaxed(val, pcie->controller_base + offset);
+ }
+ 
+ static int al_pcie_rev_id_get(struct al_pcie *pcie, unsigned int *rev_id)
+ {
+ 	u32 dev_rev_id_val;
+ 	u32 dev_id_val;
+ 
+ 	dev_rev_id_val = al_pcie_controller_readl(pcie, AXI_BASE_OFFSET +
+ 						  DEVICE_ID_OFFSET +
+ 						  DEVICE_REV_ID);
+ 	dev_id_val = FIELD_GET(DEVICE_REV_ID_DEV_ID_MASK, dev_rev_id_val);
+ 
+ 	switch (dev_id_val) {
+ 	case DEVICE_REV_ID_DEV_ID_X4:
+ 		*rev_id = AL_PCIE_REV_ID_2;
+ 		break;
+ 	case DEVICE_REV_ID_DEV_ID_X8:
+ 		*rev_id = AL_PCIE_REV_ID_3;
+ 		break;
+ 	case DEVICE_REV_ID_DEV_ID_X16:
+ 		*rev_id = AL_PCIE_REV_ID_4;
+ 		break;
+ 	default:
+ 		dev_err(pcie->dev, "Unsupported dev_id_val (0x%x)\n",
+ 			dev_id_val);
+ 		return -EINVAL;
+ 	}
+ 
+ 	dev_dbg(pcie->dev, "dev_id_val: 0x%x\n", dev_id_val);
+ 
+ 	return 0;
+ }
+ 
+ static int al_pcie_reg_offsets_set(struct al_pcie *pcie)
+ {
+ 	switch (pcie->controller_rev_id) {
+ 	case AL_PCIE_REV_ID_2:
+ 		pcie->reg_offsets.ob_ctrl = OB_CTRL_REV1_2_OFFSET;
+ 		break;
+ 	case AL_PCIE_REV_ID_3:
+ 	case AL_PCIE_REV_ID_4:
+ 		pcie->reg_offsets.ob_ctrl = OB_CTRL_REV3_5_OFFSET;
+ 		break;
+ 	default:
+ 		dev_err(pcie->dev, "Unsupported controller rev_id: 0x%x\n",
+ 			pcie->controller_rev_id);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static inline void al_pcie_target_bus_set(struct al_pcie *pcie,
+ 					  u8 target_bus,
+ 					  u8 mask_target_bus)
+ {
+ 	u32 reg;
+ 
+ 	reg = FIELD_PREP(CFG_TARGET_BUS_MASK_MASK, mask_target_bus) |
+ 	      FIELD_PREP(CFG_TARGET_BUS_BUSNUM_MASK, target_bus);
+ 
+ 	al_pcie_controller_writel(pcie, AXI_BASE_OFFSET +
+ 				  pcie->reg_offsets.ob_ctrl + CFG_TARGET_BUS,
+ 				  reg);
+ }
+ 
+ static void __iomem *al_pcie_conf_addr_map_bus(struct pci_bus *bus,
+ 					       unsigned int devfn, int where)
+ {
+ 	struct pcie_port *pp = bus->sysdata;
+ 	struct al_pcie *pcie = to_al_pcie(to_dw_pcie_from_pp(pp));
+ 	unsigned int busnr = bus->number;
+ 	struct al_pcie_target_bus_cfg *target_bus_cfg = &pcie->target_bus_cfg;
+ 	unsigned int busnr_ecam = busnr & target_bus_cfg->ecam_mask;
+ 	unsigned int busnr_reg = busnr & target_bus_cfg->reg_mask;
+ 
+ 	if (busnr_reg != target_bus_cfg->reg_val) {
+ 		dev_dbg(pcie->pci->dev, "Changing target bus busnum val from 0x%x to 0x%x\n",
+ 			target_bus_cfg->reg_val, busnr_reg);
+ 		target_bus_cfg->reg_val = busnr_reg;
+ 		al_pcie_target_bus_set(pcie,
+ 				       target_bus_cfg->reg_val,
+ 				       target_bus_cfg->reg_mask);
+ 	}
+ 
+ 	return pp->va_cfg0_base + PCIE_ECAM_OFFSET(busnr_ecam, devfn, where);
+ }
+ 
+ static struct pci_ops al_child_pci_ops = {
+ 	.map_bus = al_pcie_conf_addr_map_bus,
+ 	.read = pci_generic_config_read,
+ 	.write = pci_generic_config_write,
+ };
+ 
+ static void al_pcie_config_prepare(struct al_pcie *pcie)
+ {
+ 	struct al_pcie_target_bus_cfg *target_bus_cfg;
+ 	struct pcie_port *pp = &pcie->pci->pp;
+ 	unsigned int ecam_bus_mask;
+ 	u32 cfg_control_offset;
+ 	u8 subordinate_bus;
+ 	u8 secondary_bus;
+ 	u32 cfg_control;
+ 	u32 reg;
+ 	struct resource *bus = resource_list_first_type(&pp->bridge->windows, IORESOURCE_BUS)->res;
+ 
+ 	target_bus_cfg = &pcie->target_bus_cfg;
+ 
+ 	ecam_bus_mask = (pcie->ecam_size >> PCIE_ECAM_BUS_SHIFT) - 1;
+ 	if (ecam_bus_mask > 255) {
+ 		dev_warn(pcie->dev, "ECAM window size is larger than 256MB. Cutting off at 256\n");
+ 		ecam_bus_mask = 255;
+ 	}
+ 
+ 	/* This portion is taken from the transaction address */
+ 	target_bus_cfg->ecam_mask = ecam_bus_mask;
+ 	/* This portion is taken from the cfg_target_bus reg */
+ 	target_bus_cfg->reg_mask = ~target_bus_cfg->ecam_mask;
+ 	target_bus_cfg->reg_val = bus->start & target_bus_cfg->reg_mask;
+ 
+ 	al_pcie_target_bus_set(pcie, target_bus_cfg->reg_val,
+ 			       target_bus_cfg->reg_mask);
+ 
+ 	secondary_bus = bus->start + 1;
+ 	subordinate_bus = bus->end;
+ 
+ 	/* Set the valid values of secondary and subordinate buses */
+ 	cfg_control_offset = AXI_BASE_OFFSET + pcie->reg_offsets.ob_ctrl +
+ 			     CFG_CONTROL;
+ 
+ 	cfg_control = al_pcie_controller_readl(pcie, cfg_control_offset);
+ 
+ 	reg = cfg_control &
+ 	      ~(CFG_CONTROL_SEC_BUS_MASK | CFG_CONTROL_SUBBUS_MASK);
+ 
+ 	reg |= FIELD_PREP(CFG_CONTROL_SUBBUS_MASK, subordinate_bus) |
+ 	       FIELD_PREP(CFG_CONTROL_SEC_BUS_MASK, secondary_bus);
+ 
+ 	al_pcie_controller_writel(pcie, cfg_control_offset, reg);
+ }
+ 
+ static int al_pcie_host_init(struct pcie_port *pp)
+ {
+ 	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+ 	struct al_pcie *pcie = to_al_pcie(pci);
+ 	int rc;
+ 
+ 	pp->bridge->child_ops = &al_child_pci_ops;
+ 
+ 	rc = al_pcie_rev_id_get(pcie, &pcie->controller_rev_id);
+ 	if (rc)
+ 		return rc;
+ 
+ 	rc = al_pcie_reg_offsets_set(pcie);
+ 	if (rc)
+ 		return rc;
+ 
+ 	al_pcie_config_prepare(pcie);
+ 
+ 	return 0;
+ }
+ 
+ static const struct dw_pcie_host_ops al_pcie_host_ops = {
+ 	.host_init = al_pcie_host_init,
+ };
+ 
+ static int al_add_pcie_port(struct pcie_port *pp,
+ 			    struct platform_device *pdev)
+ {
+ 	struct device *dev = &pdev->dev;
+ 	int ret;
+ 
+ 	pp->ops = &al_pcie_host_ops;
+ 
+ 	ret = dw_pcie_host_init(pp);
+ 	if (ret) {
+ 		dev_err(dev, "failed to initialize host\n");
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static const struct dw_pcie_ops dw_pcie_ops = {
+ };
+ 
+ static int al_pcie_probe(struct platform_device *pdev)
+ {
+ 	struct device *dev = &pdev->dev;
+ 	struct resource *controller_res;
+ 	struct resource *ecam_res;
+ 	struct resource *dbi_res;
+ 	struct al_pcie *al_pcie;
+ 	struct dw_pcie *pci;
+ 
+ 	al_pcie = devm_kzalloc(dev, sizeof(*al_pcie), GFP_KERNEL);
+ 	if (!al_pcie)
+ 		return -ENOMEM;
+ 
+ 	pci = devm_kzalloc(dev, sizeof(*pci), GFP_KERNEL);
+ 	if (!pci)
+ 		return -ENOMEM;
+ 
+ 	pci->dev = dev;
+ 	pci->ops = &dw_pcie_ops;
+ 
+ 	al_pcie->pci = pci;
+ 	al_pcie->dev = dev;
+ 
+ 	dbi_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dbi");
+ 	pci->dbi_base = devm_pci_remap_cfg_resource(dev, dbi_res);
+ 	if (IS_ERR(pci->dbi_base))
+ 		return PTR_ERR(pci->dbi_base);
+ 
+ 	ecam_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "config");
+ 	if (!ecam_res) {
+ 		dev_err(dev, "couldn't find 'config' reg in DT\n");
+ 		return -ENOENT;
+ 	}
+ 	al_pcie->ecam_size = resource_size(ecam_res);
+ 
+ 	controller_res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+ 						      "controller");
+ 	al_pcie->controller_base = devm_ioremap_resource(dev, controller_res);
+ 	if (IS_ERR(al_pcie->controller_base)) {
+ 		dev_err(dev, "couldn't remap controller base %pR\n",
+ 			controller_res);
+ 		return PTR_ERR(al_pcie->controller_base);
+ 	}
+ 
+ 	dev_dbg(dev, "From DT: dbi_base: %pR, controller_base: %pR\n",
+ 		dbi_res, controller_res);
+ 
+ 	platform_set_drvdata(pdev, al_pcie);
+ 
+ 	return al_add_pcie_port(&pci->pp, pdev);
+ }
+ 
+ static const struct of_device_id al_pcie_of_match[] = {
+ 	{ .compatible = "amazon,al-alpine-v2-pcie",
+ 	},
+ 	{ .compatible = "amazon,al-alpine-v3-pcie",
+ 	},
+ 	{},
+ };
+ 
+ static struct platform_driver al_pcie_driver = {
+ 	.driver = {
+ 		.name	= "al-pcie",
+ 		.of_match_table = al_pcie_of_match,
+ 		.suppress_bind_attrs = true,
+ 	},
+ 	.probe = al_pcie_probe,
+ };
+ builtin_platform_driver(al_pcie_driver);
+ 
+ #endif /* CONFIG_PCIE_AL*/
++>>>>>>> e7708f5b10e2 (PCI: Unify ECAM constants in native PCI Express drivers)
diff --cc drivers/pci/controller/dwc/pcie-hisi.c
index 90017045334d,8fc5960faf28..000000000000
--- a/drivers/pci/controller/dwc/pcie-hisi.c
+++ b/drivers/pci/controller/dwc/pcie-hisi.c
@@@ -362,8 -133,7 +361,12 @@@ static int hisi_pcie_platform_init(stru
  	return 0;
  }
  
++<<<<<<< HEAD
 +const struct pci_ecam_ops hisi_pcie_platform_ops = {
 +	.bus_shift    = 20,
++=======
+ static const struct pci_ecam_ops hisi_pcie_platform_ops = {
++>>>>>>> e7708f5b10e2 (PCI: Unify ECAM constants in native PCI Express drivers)
  	.init         =  hisi_pcie_platform_init,
  	.pci_ops      = {
  		.map_bus    = hisi_pcie_map_bus,
diff --cc drivers/pci/controller/pci-aardvark.c
index 4cbdb0017913,1043e54c73bd..000000000000
--- a/drivers/pci/controller/pci-aardvark.c
+++ b/drivers/pci/controller/pci-aardvark.c
@@@ -13,8 -14,11 +13,9 @@@
  #include <linux/irq.h>
  #include <linux/irqdomain.h>
  #include <linux/kernel.h>
 -#include <linux/module.h>
  #include <linux/pci.h>
+ #include <linux/pci-ecam.h>
  #include <linux/init.h>
 -#include <linux/phy/phy.h>
  #include <linux/platform_device.h>
  #include <linux/msi.h>
  #include <linux/of_address.h>
@@@ -159,15 -165,8 +160,20 @@@
  #define PCIE_CONFIG_WR_TYPE0			0xa
  #define PCIE_CONFIG_WR_TYPE1			0xb
  
++<<<<<<< HEAD
 +#define PCIE_CONF_BUS(bus)			(((bus) & 0xff) << 20)
 +#define PCIE_CONF_DEV(dev)			(((dev) & 0x1f) << 15)
 +#define PCIE_CONF_FUNC(fun)			(((fun) & 0x7)	<< 12)
 +#define PCIE_CONF_REG(reg)			((reg) & 0xffc)
 +#define PCIE_CONF_ADDR(bus, devfn, where)	\
 +	(PCIE_CONF_BUS(bus) | PCIE_CONF_DEV(PCI_SLOT(devfn))	| \
 +	 PCIE_CONF_FUNC(PCI_FUNC(devfn)) | PCIE_CONF_REG(where))
 +
 +#define PIO_TIMEOUT_MS			1
++=======
+ #define PIO_RETRY_CNT			500
+ #define PIO_RETRY_DELAY			2 /* 2 us*/
++>>>>>>> e7708f5b10e2 (PCI: Unify ECAM constants in native PCI Express drivers)
  
  #define LINK_WAIT_MAX_RETRIES		10
  #define LINK_WAIT_USLEEP_MIN		90000
* Unmerged path drivers/pci/controller/pcie-brcmstb.c
* Unmerged path drivers/pci/controller/dwc/pcie-al.c
* Unmerged path drivers/pci/controller/dwc/pcie-hisi.c
* Unmerged path drivers/pci/controller/pci-aardvark.c
diff --git a/drivers/pci/controller/pci-host-generic.c b/drivers/pci/controller/pci-host-generic.c
index fd8cff61de14..d158cbe55743 100644
--- a/drivers/pci/controller/pci-host-generic.c
+++ b/drivers/pci/controller/pci-host-generic.c
@@ -51,7 +51,6 @@ static void __iomem *pci_dw_ecam_map_bus(struct pci_bus *bus,
 }
 
 static const struct pci_ecam_ops pci_dw_ecam_bus_ops = {
-	.bus_shift	= 20,
 	.pci_ops	= {
 		.map_bus	= pci_dw_ecam_map_bus,
 		.read		= pci_generic_config_read,
diff --git a/drivers/pci/controller/pci-thunder-ecam.c b/drivers/pci/controller/pci-thunder-ecam.c
index c3fdd3e6b21c..4394e223de8a 100644
--- a/drivers/pci/controller/pci-thunder-ecam.c
+++ b/drivers/pci/controller/pci-thunder-ecam.c
@@ -346,7 +346,6 @@ static int thunder_ecam_config_write(struct pci_bus *bus, unsigned int devfn,
 }
 
 const struct pci_ecam_ops pci_thunder_ecam_ops = {
-	.bus_shift	= 20,
 	.pci_ops	= {
 		.map_bus        = pci_ecam_map_bus,
 		.read           = thunder_ecam_config_read,
* Unmerged path drivers/pci/controller/pcie-brcmstb.c
diff --git a/drivers/pci/controller/pcie-rockchip-host.c b/drivers/pci/controller/pcie-rockchip-host.c
index 1372d270764f..30ce5a5db27d 100644
--- a/drivers/pci/controller/pcie-rockchip-host.c
+++ b/drivers/pci/controller/pcie-rockchip-host.c
@@ -160,12 +160,11 @@ static int rockchip_pcie_rd_other_conf(struct rockchip_pcie *rockchip,
 				       struct pci_bus *bus, u32 devfn,
 				       int where, int size, u32 *val)
 {
-	u32 busdev;
+	void __iomem *addr;
 
-	busdev = PCIE_ECAM_ADDR(bus->number, PCI_SLOT(devfn),
-				PCI_FUNC(devfn), where);
+	addr = rockchip->reg_base + PCIE_ECAM_OFFSET(bus->number, devfn, where);
 
-	if (!IS_ALIGNED(busdev, size)) {
+	if (!IS_ALIGNED((uintptr_t)addr, size)) {
 		*val = 0;
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 	}
@@ -178,11 +177,11 @@ static int rockchip_pcie_rd_other_conf(struct rockchip_pcie *rockchip,
 						AXI_WRAPPER_TYPE1_CFG);
 
 	if (size == 4) {
-		*val = readl(rockchip->reg_base + busdev);
+		*val = readl(addr);
 	} else if (size == 2) {
-		*val = readw(rockchip->reg_base + busdev);
+		*val = readw(addr);
 	} else if (size == 1) {
-		*val = readb(rockchip->reg_base + busdev);
+		*val = readb(addr);
 	} else {
 		*val = 0;
 		return PCIBIOS_BAD_REGISTER_NUMBER;
@@ -194,11 +193,11 @@ static int rockchip_pcie_wr_other_conf(struct rockchip_pcie *rockchip,
 				       struct pci_bus *bus, u32 devfn,
 				       int where, int size, u32 val)
 {
-	u32 busdev;
+	void __iomem *addr;
 
-	busdev = PCIE_ECAM_ADDR(bus->number, PCI_SLOT(devfn),
-				PCI_FUNC(devfn), where);
-	if (!IS_ALIGNED(busdev, size))
+	addr = rockchip->reg_base + PCIE_ECAM_OFFSET(bus->number, devfn, where);
+
+	if (!IS_ALIGNED((uintptr_t)addr, size))
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
 	if (bus->parent->number == rockchip->root_bus_nr)
@@ -209,11 +208,11 @@ static int rockchip_pcie_wr_other_conf(struct rockchip_pcie *rockchip,
 						AXI_WRAPPER_TYPE1_CFG);
 
 	if (size == 4)
-		writel(val, rockchip->reg_base + busdev);
+		writel(val, addr);
 	else if (size == 2)
-		writew(val, rockchip->reg_base + busdev);
+		writew(val, addr);
 	else if (size == 1)
-		writeb(val, rockchip->reg_base + busdev);
+		writeb(val, addr);
 	else
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
diff --git a/drivers/pci/controller/pcie-rockchip.h b/drivers/pci/controller/pcie-rockchip.h
index 53e4f9e59624..b555957b8fb5 100644
--- a/drivers/pci/controller/pcie-rockchip.h
+++ b/drivers/pci/controller/pcie-rockchip.h
@@ -13,6 +13,7 @@
 
 #include <linux/kernel.h>
 #include <linux/pci.h>
+#include <linux/pci-ecam.h>
 
 /*
  * The upper 16 bits of PCIE_CLIENT_CONFIG are a write mask for the lower 16
@@ -178,13 +179,6 @@
 #define MIN_AXI_ADDR_BITS_PASSED		8
 #define PCIE_RC_SEND_PME_OFF			0x11960
 #define ROCKCHIP_VENDOR_ID			0x1d87
-#define PCIE_ECAM_BUS(x)			(((x) & 0xff) << 20)
-#define PCIE_ECAM_DEV(x)			(((x) & 0x1f) << 15)
-#define PCIE_ECAM_FUNC(x)			(((x) & 0x7) << 12)
-#define PCIE_ECAM_REG(x)			(((x) & 0xfff) << 0)
-#define PCIE_ECAM_ADDR(bus, dev, func, reg) \
-	  (PCIE_ECAM_BUS(bus) | PCIE_ECAM_DEV(dev) | \
-	   PCIE_ECAM_FUNC(func) | PCIE_ECAM_REG(reg))
 #define PCIE_LINK_IS_L2(x) \
 	(((x) & PCIE_CLIENT_DEBUG_LTSSM_MASK) == PCIE_CLIENT_DEBUG_LTSSM_L2)
 #define PCIE_LINK_UP(x) \
diff --git a/drivers/pci/controller/pcie-tango.c b/drivers/pci/controller/pcie-tango.c
index 3b2b10906fdd..c54a87e6b77f 100644
--- a/drivers/pci/controller/pcie-tango.c
+++ b/drivers/pci/controller/pcie-tango.c
@@ -208,7 +208,6 @@ static int smp8759_config_write(struct pci_bus *bus, unsigned int devfn,
 }
 
 static const struct pci_ecam_ops smp8759_ecam_ops = {
-	.bus_shift	= 20,
 	.pci_ops	= {
 		.map_bus	= pci_ecam_map_bus,
 		.read		= smp8759_config_read,
diff --git a/drivers/pci/controller/pcie-xilinx-nwl.c b/drivers/pci/controller/pcie-xilinx-nwl.c
index f77dd0e911bb..0b2deb53fa53 100644
--- a/drivers/pci/controller/pcie-xilinx-nwl.c
+++ b/drivers/pci/controller/pcie-xilinx-nwl.c
@@ -18,6 +18,7 @@
 #include <linux/of_platform.h>
 #include <linux/of_irq.h>
 #include <linux/pci.h>
+#include <linux/pci-ecam.h>
 #include <linux/platform_device.h>
 #include <linux/irqchip/chained_irq.h>
 
@@ -124,8 +125,6 @@
 #define E_ECAM_CR_ENABLE		BIT(0)
 #define E_ECAM_SIZE_LOC			GENMASK(20, 16)
 #define E_ECAM_SIZE_SHIFT		16
-#define ECAM_BUS_LOC_SHIFT		20
-#define ECAM_DEV_LOC_SHIFT		12
 #define NWL_ECAM_VALUE_DEFAULT		12
 
 #define CFG_DMA_REG_BAR			GENMASK(2, 0)
@@ -243,15 +242,11 @@ static void __iomem *nwl_pcie_map_bus(struct pci_bus *bus, unsigned int devfn,
 				      int where)
 {
 	struct nwl_pcie *pcie = bus->sysdata;
-	int relbus;
 
 	if (!nwl_pcie_valid_device(bus, devfn))
 		return NULL;
 
-	relbus = (bus->number << ECAM_BUS_LOC_SHIFT) |
-			(devfn << ECAM_DEV_LOC_SHIFT);
-
-	return pcie->ecam_base + relbus + where;
+	return pcie->ecam_base + PCIE_ECAM_OFFSET(bus->number, devfn, where);
 }
 
 /* PCIe operations */
diff --git a/drivers/pci/controller/pcie-xilinx.c b/drivers/pci/controller/pcie-xilinx.c
index 7b1389d8e2a5..577e296a4c0c 100644
--- a/drivers/pci/controller/pcie-xilinx.c
+++ b/drivers/pci/controller/pcie-xilinx.c
@@ -21,6 +21,7 @@
 #include <linux/of_platform.h>
 #include <linux/of_irq.h>
 #include <linux/pci.h>
+#include <linux/pci-ecam.h>
 #include <linux/platform_device.h>
 
 #include "../pci.h"
@@ -86,10 +87,6 @@
 /* Phy Status/Control Register definitions */
 #define XILINX_PCIE_REG_PSCR_LNKUP	BIT(11)
 
-/* ECAM definitions */
-#define ECAM_BUS_NUM_SHIFT		20
-#define ECAM_DEV_NUM_SHIFT		12
-
 /* Number of MSI IRQs */
 #define XILINX_NUM_MSI_IRQS		128
 
@@ -186,15 +183,11 @@ static void __iomem *xilinx_pcie_map_bus(struct pci_bus *bus,
 					 unsigned int devfn, int where)
 {
 	struct xilinx_pcie_port *port = bus->sysdata;
-	int relbus;
 
 	if (!xilinx_pcie_valid_device(bus, devfn))
 		return NULL;
 
-	relbus = (bus->number << ECAM_BUS_NUM_SHIFT) |
-		 (devfn << ECAM_DEV_NUM_SHIFT);
-
-	return port->reg_base + relbus + where;
+	return port->reg_base + PCIE_ECAM_OFFSET(bus->number, devfn, where);
 }
 
 /* PCIe operations */
diff --git a/drivers/pci/controller/vmd.c b/drivers/pci/controller/vmd.c
index 7ad9c77f39f5..a3900e828e15 100644
--- a/drivers/pci/controller/vmd.c
+++ b/drivers/pci/controller/vmd.c
@@ -11,6 +11,7 @@
 #include <linux/module.h>
 #include <linux/msi.h>
 #include <linux/pci.h>
+#include <linux/pci-ecam.h>
 #include <linux/srcu.h>
 #include <linux/rculist.h>
 #include <linux/rcupdate.h>
@@ -295,15 +296,13 @@ static struct msi_domain_info vmd_msi_domain_info = {
 static char __iomem *vmd_cfg_addr(struct vmd_dev *vmd, struct pci_bus *bus,
 				  unsigned int devfn, int reg, int len)
 {
-	char __iomem *addr = vmd->cfgbar +
-			     ((bus->number - vmd->busn_start) << 20) +
-			     (devfn << 12) + reg;
+	unsigned int busnr_ecam = bus->number - vmd->busn_start;
+	u32 offset = PCIE_ECAM_OFFSET(busnr_ecam, devfn, reg);
 
-	if ((addr - vmd->cfgbar) + len >=
-	    resource_size(&vmd->dev->resource[VMD_CFGBAR]))
+	if (offset + len >= resource_size(&vmd->dev->resource[VMD_CFGBAR]))
 		return NULL;
 
-	return addr;
+	return vmd->cfgbar + offset;
 }
 
 /*
diff --git a/drivers/pci/ecam.c b/drivers/pci/ecam.c
index b54d32a31669..d2a1920bb055 100644
--- a/drivers/pci/ecam.c
+++ b/drivers/pci/ecam.c
@@ -28,6 +28,7 @@ struct pci_config_window *pci_ecam_create(struct device *dev,
 		struct resource *cfgres, struct resource *busr,
 		const struct pci_ecam_ops *ops)
 {
+	unsigned int bus_shift = ops->bus_shift;
 	struct pci_config_window *cfg;
 	unsigned int bus_range, bus_range_max, bsz;
 	struct resource *conflict;
@@ -40,20 +41,24 @@ struct pci_config_window *pci_ecam_create(struct device *dev,
 	if (!cfg)
 		return ERR_PTR(-ENOMEM);
 
+	/* ECAM-compliant platforms need not supply ops->bus_shift */
+	if (!bus_shift)
+		bus_shift = PCIE_ECAM_BUS_SHIFT;
+
 	cfg->parent = dev;
 	cfg->ops = ops;
 	cfg->busr.start = busr->start;
 	cfg->busr.end = busr->end;
 	cfg->busr.flags = IORESOURCE_BUS;
 	bus_range = resource_size(&cfg->busr);
-	bus_range_max = resource_size(cfgres) >> ops->bus_shift;
+	bus_range_max = resource_size(cfgres) >> bus_shift;
 	if (bus_range > bus_range_max) {
 		bus_range = bus_range_max;
 		cfg->busr.end = busr->start + bus_range - 1;
 		dev_warn(dev, "ECAM area %pR can only accommodate %pR (reduced from %pR desired)\n",
 			 cfgres, &cfg->busr, busr);
 	}
-	bsz = 1 << ops->bus_shift;
+	bsz = 1 << bus_shift;
 
 	cfg->res.start = cfgres->start;
 	cfg->res.end = cfgres->end;
@@ -131,25 +136,36 @@ void __iomem *pci_ecam_map_bus(struct pci_bus *bus, unsigned int devfn,
 			       int where)
 {
 	struct pci_config_window *cfg = bus->sysdata;
+	unsigned int bus_shift = cfg->ops->bus_shift;
 	unsigned int devfn_shift = cfg->ops->bus_shift - 8;
 	unsigned int busn = bus->number;
 	void __iomem *base;
+	u32 bus_offset, devfn_offset;
 
 	if (busn < cfg->busr.start || busn > cfg->busr.end)
 		return NULL;
 
 	busn -= cfg->busr.start;
-	if (per_bus_mapping)
+	if (per_bus_mapping) {
 		base = cfg->winp[busn];
-	else
-		base = cfg->win + (busn << cfg->ops->bus_shift);
-	return base + (devfn << devfn_shift) + where;
+		busn = 0;
+	} else
+		base = cfg->win;
+
+	if (cfg->ops->bus_shift) {
+		bus_offset = (busn & PCIE_ECAM_BUS_MASK) << bus_shift;
+		devfn_offset = (devfn & PCIE_ECAM_DEVFN_MASK) << devfn_shift;
+		where &= PCIE_ECAM_REG_MASK;
+
+		return base + (bus_offset | devfn_offset | where);
+	}
+
+	return base + PCIE_ECAM_OFFSET(busn, devfn, where);
 }
 EXPORT_SYMBOL_GPL(pci_ecam_map_bus);
 
 /* ECAM ops */
 const struct pci_ecam_ops pci_generic_ecam_ops = {
-	.bus_shift	= 20,
 	.pci_ops	= {
 		.map_bus	= pci_ecam_map_bus,
 		.read		= pci_generic_config_read,
@@ -161,7 +177,6 @@ EXPORT_SYMBOL_GPL(pci_generic_ecam_ops);
 #if defined(CONFIG_ACPI) && defined(CONFIG_PCI_QUIRKS)
 /* ECAM ops for 32-bit access only (non-compliant) */
 const struct pci_ecam_ops pci_32b_ops = {
-	.bus_shift	= 20,
 	.pci_ops	= {
 		.map_bus	= pci_ecam_map_bus,
 		.read		= pci_generic_config_read32,
@@ -171,7 +186,6 @@ const struct pci_ecam_ops pci_32b_ops = {
 
 /* ECAM ops for 32-bit read only (non-compliant) */
 const struct pci_ecam_ops pci_32b_read_ops = {
-	.bus_shift	= 20,
 	.pci_ops	= {
 		.map_bus	= pci_ecam_map_bus,
 		.read		= pci_generic_config_read32,
diff --git a/include/linux/pci-ecam.h b/include/linux/pci-ecam.h
index 4855e22bf582..7f93b9267b40 100644
--- a/include/linux/pci-ecam.h
+++ b/include/linux/pci-ecam.h
@@ -9,6 +9,33 @@
 #include <linux/kernel.h>
 #include <linux/platform_device.h>
 
+/*
+ * Memory address shift values for the byte-level address that
+ * can be used when accessing the PCI Express Configuration Space.
+ */
+
+/*
+ * Enhanced Configuration Access Mechanism (ECAM)
+ *
+ * See PCI Express Base Specification, Revision 5.0, Version 1.0,
+ * Section 7.2.2, Table 7-1, p. 677.
+ */
+#define PCIE_ECAM_BUS_SHIFT	20 /* Bus number */
+#define PCIE_ECAM_DEVFN_SHIFT	12 /* Device and Function number */
+
+#define PCIE_ECAM_BUS_MASK	0xff
+#define PCIE_ECAM_DEVFN_MASK	0xff
+#define PCIE_ECAM_REG_MASK	0xfff /* Limit offset to a maximum of 4K */
+
+#define PCIE_ECAM_BUS(x)	(((x) & PCIE_ECAM_BUS_MASK) << PCIE_ECAM_BUS_SHIFT)
+#define PCIE_ECAM_DEVFN(x)	(((x) & PCIE_ECAM_DEVFN_MASK) << PCIE_ECAM_DEVFN_SHIFT)
+#define PCIE_ECAM_REG(x)	((x) & PCIE_ECAM_REG_MASK)
+
+#define PCIE_ECAM_OFFSET(bus, devfn, where) \
+	(PCIE_ECAM_BUS(bus) | \
+	 PCIE_ECAM_DEVFN(devfn) | \
+	 PCIE_ECAM_REG(where))
+
 /*
  * struct to hold pci ops and bus shift of the config window
  * for a PCI controller.
