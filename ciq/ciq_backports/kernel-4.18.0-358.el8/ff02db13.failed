Bluetooth: Allow scannable adv with extended MGMT APIs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Daniel Winkler <danielwinkler@google.com>
commit ff02db13e9bfa01e0d66c5fa53da29bd1f1b208a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/ff02db13.failed

An issue was found, where if a bluetooth client requests a broadcast
advertisement with scan response data, it will not be properly
registered with the controller. This is because at the time that the
hci_cp_le_set_scan_param structure is created, the scan response will
not yet have been received since it comes in a second MGMT call. With
empty scan response, the request defaults to a non-scannable PDU type.
On some controllers, the subsequent scan response request will fail due
to incorrect PDU type, and others will succeed and not use the scan
response.

This fix allows the advertising parameters MGMT call to include a flag
to let the kernel know whether a scan response will be coming, so that
the correct PDU type is used in the first place. A bluetoothd change is
also incoming to take advantage of it.

To test this, I created a broadcast advertisement with scan response
data and registered it on the hatch chromebook. Without this change, the
request fails, and with it will succeed.

	Reviewed-by: Alain Michaud <alainm@chromium.org>
	Reviewed-by: Sonny Sasaka <sonnysasaka@chromium.org>
	Reviewed-by: Miao-chen Chou <mcchou@chromium.org>
	Signed-off-by: Daniel Winkler <danielwinkler@google.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit ff02db13e9bfa01e0d66c5fa53da29bd1f1b208a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/bluetooth/mgmt.h
#	net/bluetooth/mgmt.c
diff --cc include/net/bluetooth/mgmt.h
index 5b34e2732311,a7cffb069565..000000000000
--- a/include/net/bluetooth/mgmt.h
+++ b/include/net/bluetooth/mgmt.h
@@@ -568,6 -574,11 +568,14 @@@ struct mgmt_rp_add_advertising 
  #define MGMT_ADV_FLAG_SEC_CODED 	BIT(9)
  #define MGMT_ADV_FLAG_CAN_SET_TX_POWER	BIT(10)
  #define MGMT_ADV_FLAG_HW_OFFLOAD	BIT(11)
++<<<<<<< HEAD
++=======
+ #define MGMT_ADV_PARAM_DURATION		BIT(12)
+ #define MGMT_ADV_PARAM_TIMEOUT		BIT(13)
+ #define MGMT_ADV_PARAM_INTERVALS	BIT(14)
+ #define MGMT_ADV_PARAM_TX_POWER		BIT(15)
+ #define MGMT_ADV_PARAM_SCAN_RSP		BIT(16)
++>>>>>>> ff02db13e9bf (Bluetooth: Allow scannable adv with extended MGMT APIs)
  
  #define MGMT_ADV_FLAG_SEC_MASK	(MGMT_ADV_FLAG_SEC_1M | MGMT_ADV_FLAG_SEC_2M | \
  				 MGMT_ADV_FLAG_SEC_CODED)
diff --cc net/bluetooth/mgmt.c
index dae1b1cdab60,90334ac4a135..000000000000
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@@ -6526,6 -7428,11 +6526,14 @@@ static u32 get_supported_adv_flags(stru
  	flags |= MGMT_ADV_FLAG_MANAGED_FLAGS;
  	flags |= MGMT_ADV_FLAG_APPEARANCE;
  	flags |= MGMT_ADV_FLAG_LOCAL_NAME;
++<<<<<<< HEAD
++=======
+ 	flags |= MGMT_ADV_PARAM_DURATION;
+ 	flags |= MGMT_ADV_PARAM_TIMEOUT;
+ 	flags |= MGMT_ADV_PARAM_INTERVALS;
+ 	flags |= MGMT_ADV_PARAM_TX_POWER;
+ 	flags |= MGMT_ADV_PARAM_SCAN_RSP;
++>>>>>>> ff02db13e9bf (Bluetooth: Allow scannable adv with extended MGMT APIs)
  
  	/* In extended adv TX_POWER returned from Set Adv Param
  	 * will be always valid.
* Unmerged path include/net/bluetooth/mgmt.h
diff --git a/net/bluetooth/hci_request.c b/net/bluetooth/hci_request.c
index f57b8ee4ec12..9011f4251085 100644
--- a/net/bluetooth/hci_request.c
+++ b/net/bluetooth/hci_request.c
@@ -2004,7 +2004,8 @@ int __hci_req_setup_ext_adv_instance(struct hci_request *req, u8 instance)
 			cp.evt_properties = cpu_to_le16(LE_EXT_ADV_CONN_IND);
 		else
 			cp.evt_properties = cpu_to_le16(LE_LEGACY_ADV_IND);
-	} else if (adv_instance_is_scannable(hdev, instance)) {
+	} else if (adv_instance_is_scannable(hdev, instance) ||
+		   (flags & MGMT_ADV_PARAM_SCAN_RSP)) {
 		if (secondary_adv)
 			cp.evt_properties = cpu_to_le16(LE_EXT_ADV_SCAN_IND);
 		else
* Unmerged path net/bluetooth/mgmt.c
