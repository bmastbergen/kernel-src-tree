ice: Add new VSI states to track netdev alloc/registration

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
commit a476d72abe6cdd2cccc3dbf5a844286cfe9684ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/a476d72a.failed

Add two new VSI states, one to track if a netdev for the VSI has been
allocated and the other to track if the netdev has been registered.
Call unregister_netdev/free_netdev only when the corresponding state
bits are set.

	Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
	Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit a476d72abe6cdd2cccc3dbf5a844286cfe9684ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_lib.c
diff --cc drivers/net/ethernet/intel/ice/ice_lib.c
index 2e328aad1449,40a9b034d73b..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@@ -2828,10 -2814,16 +2831,23 @@@ int ice_vsi_release(struct ice_vsi *vsi
  	ice_vsi_delete(vsi);
  	ice_vsi_free_q_vectors(vsi);
  
++<<<<<<< HEAD
 +	/* make sure unregister_netdev() was called by checking __ICE_DOWN */
 +	if (vsi->netdev && test_bit(ICE_VSI_DOWN, vsi->state)) {
 +		free_netdev(vsi->netdev);
 +		vsi->netdev = NULL;
++=======
+ 	if (vsi->netdev) {
+ 		if (test_bit(ICE_VSI_NETDEV_REGISTERED, vsi->state)) {
+ 			unregister_netdev(vsi->netdev);
+ 			clear_bit(ICE_VSI_NETDEV_REGISTERED, vsi->state);
+ 		}
+ 		if (test_bit(ICE_VSI_NETDEV_ALLOCD, vsi->state)) {
+ 			free_netdev(vsi->netdev);
+ 			vsi->netdev = NULL;
+ 			clear_bit(ICE_VSI_NETDEV_ALLOCD, vsi->state);
+ 		}
++>>>>>>> a476d72abe6c (ice: Add new VSI states to track netdev alloc/registration)
  	}
  
  	if (vsi->type == ICE_VSI_VF &&
diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 3b22620c8ce7..fa85a1090aa5 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -244,6 +244,8 @@ enum ice_pf_state {
 enum ice_vsi_state {
 	ICE_VSI_DOWN,
 	ICE_VSI_NEEDS_RESTART,
+	ICE_VSI_NETDEV_ALLOCD,
+	ICE_VSI_NETDEV_REGISTERED,
 	ICE_VSI_UMAC_FLTR_CHANGED,
 	ICE_VSI_MMAC_FLTR_CHANGED,
 	ICE_VSI_VLAN_FLTR_CHANGED,
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.c
diff --git a/drivers/net/ethernet/intel/ice/ice_main.c b/drivers/net/ethernet/intel/ice/ice_main.c
index c321e8a93a56..0f14f84efe26 100644
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@ -3058,6 +3058,7 @@ static int ice_cfg_netdev(struct ice_vsi *vsi)
 	if (!netdev)
 		return -ENOMEM;
 
+	set_bit(ICE_VSI_NETDEV_ALLOCD, vsi->state);
 	vsi->netdev = netdev;
 	np = netdev_priv(netdev);
 	np->vsi = vsi;
@@ -3270,6 +3271,7 @@ static int ice_setup_pf_sw(struct ice_pf *pf)
 	if (vsi) {
 		ice_napi_del(vsi);
 		if (vsi->netdev) {
+			clear_bit(ICE_VSI_NETDEV_ALLOCD, vsi->state);
 			free_netdev(vsi->netdev);
 			vsi->netdev = NULL;
 		}
@@ -4046,6 +4048,7 @@ static int ice_register_netdev(struct ice_pf *pf)
 	if (err)
 		goto err_register_netdev;
 
+	set_bit(ICE_VSI_NETDEV_REGISTERED, vsi->state);
 	netif_carrier_off(vsi->netdev);
 	netif_tx_stop_all_queues(vsi->netdev);
 	err = ice_devlink_create_port(vsi);
@@ -4057,9 +4060,11 @@ static int ice_register_netdev(struct ice_pf *pf)
 	return 0;
 err_devlink_create:
 	unregister_netdev(vsi->netdev);
+	clear_bit(ICE_VSI_NETDEV_REGISTERED, vsi->state);
 err_register_netdev:
 	free_netdev(vsi->netdev);
 	vsi->netdev = NULL;
+	clear_bit(ICE_VSI_NETDEV_ALLOCD, vsi->state);
 	return err;
 }
 
