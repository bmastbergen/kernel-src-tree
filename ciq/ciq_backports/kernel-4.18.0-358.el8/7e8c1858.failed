net: bridge: allow the switchdev replay functions to be called for deletion

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Vladimir Oltean <vladimir.oltean@nxp.com>
commit 7e8c18586daf7c1653c4b43a8119bc9662ed8fa6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/7e8c1858.failed

When a switchdev port leaves a LAG that is a bridge port, the switchdev
objects and port attributes offloaded to that port are not removed:

ip link add br0 type bridge
ip link add bond0 type bond mode 802.3ad
ip link set swp0 master bond0
ip link set bond0 master br0
bridge vlan add dev bond0 vid 100
ip link set swp0 nomaster

VLAN 100 will remain installed on swp0 despite it going into standalone
mode, because as far as the bridge is concerned, nothing ever happened
to its bridge port.

Let's extend the bridge vlan, fdb and mdb replay functions to take a
'bool adding' argument, and make DSA and ocelot call the replay
functions with 'adding' as false from the switchdev unsync path, for the
switch port that leaves the bridge.

Note that this patch in itself does not salvage anything, because in the
current pull mode of operation, DSA still needs to call the replay
helpers with adding=false. This will be done in another patch.

	Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7e8c18586daf7c1653c4b43a8119bc9662ed8fa6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mscc/ocelot_net.c
#	include/linux/if_bridge.h
#	net/bridge/br_fdb.c
#	net/bridge/br_mdb.c
#	net/bridge/br_vlan.c
#	net/dsa/port.c
diff --cc include/linux/if_bridge.h
index f87c7c990fb6,b651c5e32a28..000000000000
--- a/include/linux/if_bridge.h
+++ b/include/linux/if_bridge.h
@@@ -75,6 -70,9 +75,12 @@@ bool br_multicast_has_querier_adjacent(
  bool br_multicast_has_router_adjacent(struct net_device *dev, int proto);
  bool br_multicast_enabled(const struct net_device *dev);
  bool br_multicast_router(const struct net_device *dev);
++<<<<<<< HEAD
++=======
+ int br_mdb_replay(struct net_device *br_dev, struct net_device *dev,
+ 		  const void *ctx, bool adding, struct notifier_block *nb,
+ 		  struct netlink_ext_ack *extack);
++>>>>>>> 7e8c18586daf (net: bridge: allow the switchdev replay functions to be called for deletion)
  #else
  static inline int br_multicast_list_adjacent(struct net_device *dev,
  					     struct list_head *br_ip_list)
@@@ -106,6 -104,13 +112,16 @@@ static inline bool br_multicast_router(
  {
  	return false;
  }
++<<<<<<< HEAD
++=======
+ static inline int br_mdb_replay(const struct net_device *br_dev,
+ 				const struct net_device *dev, const void *ctx,
+ 				bool adding, struct notifier_block *nb,
+ 				struct netlink_ext_ack *extack)
+ {
+ 	return -EOPNOTSUPP;
+ }
++>>>>>>> 7e8c18586daf (net: bridge: allow the switchdev replay functions to be called for deletion)
  #endif
  
  #if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_VLAN_FILTERING)
@@@ -116,7 -121,8 +132,12 @@@ int br_vlan_get_proto(const struct net_
  int br_vlan_get_info(const struct net_device *dev, u16 vid,
  		     struct bridge_vlan_info *p_vinfo);
  int br_vlan_replay(struct net_device *br_dev, struct net_device *dev,
++<<<<<<< HEAD
 +		   struct notifier_block *nb, struct netlink_ext_ack *extack);
++=======
+ 		   const void *ctx, bool adding, struct notifier_block *nb,
+ 		   struct netlink_ext_ack *extack);
++>>>>>>> 7e8c18586daf (net: bridge: allow the switchdev replay functions to be called for deletion)
  #else
  static inline bool br_vlan_enabled(const struct net_device *dev)
  {
@@@ -145,8 -151,8 +166,13 @@@ static inline int br_vlan_get_info(cons
  }
  
  static inline int br_vlan_replay(struct net_device *br_dev,
++<<<<<<< HEAD
 +				 struct net_device *dev,
 +				 struct notifier_block *nb,
++=======
+ 				 struct net_device *dev, const void *ctx,
+ 				 bool adding, struct notifier_block *nb,
++>>>>>>> 7e8c18586daf (net: bridge: allow the switchdev replay functions to be called for deletion)
  				 struct netlink_ext_ack *extack)
  {
  	return -EOPNOTSUPP;
@@@ -160,9 -166,9 +186,15 @@@ struct net_device *br_fdb_find_port(con
  void br_fdb_clear_offload(const struct net_device *dev, u16 vid);
  bool br_port_flag_is_set(const struct net_device *dev, unsigned long flag);
  u8 br_port_get_stp_state(const struct net_device *dev);
++<<<<<<< HEAD
 +clock_t br_get_ageing_time(struct net_device *br_dev);
 +int br_fdb_replay(struct net_device *br_dev, struct net_device *dev,
 +		  struct notifier_block *nb);
++=======
+ clock_t br_get_ageing_time(const struct net_device *br_dev);
+ int br_fdb_replay(const struct net_device *br_dev, const struct net_device *dev,
+ 		  const void *ctx, bool adding, struct notifier_block *nb);
++>>>>>>> 7e8c18586daf (net: bridge: allow the switchdev replay functions to be called for deletion)
  #else
  static inline struct net_device *
  br_fdb_find_port(const struct net_device *br_dev,
@@@ -192,9 -198,9 +224,15 @@@ static inline clock_t br_get_ageing_tim
  	return 0;
  }
  
++<<<<<<< HEAD
 +static inline int br_fdb_replay(struct net_device *br_dev,
 +				struct net_device *dev,
 +				struct notifier_block *nb)
++=======
+ static inline int br_fdb_replay(const struct net_device *br_dev,
+ 				const struct net_device *dev, const void *ctx,
+ 				bool adding, struct notifier_block *nb)
++>>>>>>> 7e8c18586daf (net: bridge: allow the switchdev replay functions to be called for deletion)
  {
  	return -EOPNOTSUPP;
  }
diff --cc net/bridge/br_fdb.c
index 971a68243dd4,16f9434fdb5d..000000000000
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@@ -701,8 -727,9 +701,14 @@@ static inline size_t fdb_nlmsg_size(voi
  }
  
  static int br_fdb_replay_one(struct notifier_block *nb,
++<<<<<<< HEAD
 +			     struct net_bridge_fdb_entry *fdb,
 +			     struct net_device *dev)
++=======
+ 			     const struct net_bridge_fdb_entry *fdb,
+ 			     struct net_device *dev, unsigned long action,
+ 			     const void *ctx)
++>>>>>>> 7e8c18586daf (net: bridge: allow the switchdev replay functions to be called for deletion)
  {
  	struct switchdev_notifier_fdb_info item;
  	int err;
@@@ -713,13 -740,14 +719,18 @@@
  	item.offloaded = test_bit(BR_FDB_OFFLOADED, &fdb->flags);
  	item.is_local = test_bit(BR_FDB_LOCAL, &fdb->flags);
  	item.info.dev = dev;
 -	item.info.ctx = ctx;
  
- 	err = nb->notifier_call(nb, SWITCHDEV_FDB_ADD_TO_DEVICE, &item);
+ 	err = nb->notifier_call(nb, action, &item);
  	return notifier_to_errno(err);
  }
  
++<<<<<<< HEAD
 +int br_fdb_replay(struct net_device *br_dev, struct net_device *dev,
 +		  struct notifier_block *nb)
++=======
+ int br_fdb_replay(const struct net_device *br_dev, const struct net_device *dev,
+ 		  const void *ctx, bool adding, struct notifier_block *nb)
++>>>>>>> 7e8c18586daf (net: bridge: allow the switchdev replay functions to be called for deletion)
  {
  	struct net_bridge_fdb_entry *fdb;
  	struct net_bridge *br;
@@@ -740,7 -774,7 +757,11 @@@
  		if (dst_dev != br_dev && dst_dev != dev)
  			continue;
  
++<<<<<<< HEAD
 +		err = br_fdb_replay_one(nb, fdb, dst_dev);
++=======
+ 		err = br_fdb_replay_one(nb, fdb, dst_dev, action, ctx);
++>>>>>>> 7e8c18586daf (net: bridge: allow the switchdev replay functions to be called for deletion)
  		if (err)
  			break;
  	}
diff --cc net/bridge/br_mdb.c
index 5621f5510fd4,17a720b4473f..000000000000
--- a/net/bridge/br_mdb.c
+++ b/net/bridge/br_mdb.c
@@@ -466,6 -551,143 +466,146 @@@ err
  	kfree(priv);
  }
  
++<<<<<<< HEAD
++=======
+ static void br_switchdev_mdb_populate(struct switchdev_obj_port_mdb *mdb,
+ 				      const struct net_bridge_mdb_entry *mp)
+ {
+ 	if (mp->addr.proto == htons(ETH_P_IP))
+ 		ip_eth_mc_map(mp->addr.dst.ip4, mdb->addr);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	else if (mp->addr.proto == htons(ETH_P_IPV6))
+ 		ipv6_eth_mc_map(&mp->addr.dst.ip6, mdb->addr);
+ #endif
+ 	else
+ 		ether_addr_copy(mdb->addr, mp->addr.dst.mac_addr);
+ 
+ 	mdb->vid = mp->addr.vid;
+ }
+ 
+ static int br_mdb_replay_one(struct notifier_block *nb, struct net_device *dev,
+ 			     const struct switchdev_obj_port_mdb *mdb,
+ 			     unsigned long action, const void *ctx,
+ 			     struct netlink_ext_ack *extack)
+ {
+ 	struct switchdev_notifier_port_obj_info obj_info = {
+ 		.info = {
+ 			.dev = dev,
+ 			.extack = extack,
+ 			.ctx = ctx,
+ 		},
+ 		.obj = &mdb->obj,
+ 	};
+ 	int err;
+ 
+ 	err = nb->notifier_call(nb, action, &obj_info);
+ 	return notifier_to_errno(err);
+ }
+ 
+ static int br_mdb_queue_one(struct list_head *mdb_list,
+ 			    enum switchdev_obj_id id,
+ 			    const struct net_bridge_mdb_entry *mp,
+ 			    struct net_device *orig_dev)
+ {
+ 	struct switchdev_obj_port_mdb *mdb;
+ 
+ 	mdb = kzalloc(sizeof(*mdb), GFP_ATOMIC);
+ 	if (!mdb)
+ 		return -ENOMEM;
+ 
+ 	mdb->obj.id = id;
+ 	mdb->obj.orig_dev = orig_dev;
+ 	br_switchdev_mdb_populate(mdb, mp);
+ 	list_add_tail(&mdb->obj.list, mdb_list);
+ 
+ 	return 0;
+ }
+ 
+ int br_mdb_replay(struct net_device *br_dev, struct net_device *dev,
+ 		  const void *ctx, bool adding, struct notifier_block *nb,
+ 		  struct netlink_ext_ack *extack)
+ {
+ 	const struct net_bridge_mdb_entry *mp;
+ 	struct switchdev_obj *obj, *tmp;
+ 	struct net_bridge *br;
+ 	unsigned long action;
+ 	LIST_HEAD(mdb_list);
+ 	int err = 0;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	if (!netif_is_bridge_master(br_dev) || !netif_is_bridge_port(dev))
+ 		return -EINVAL;
+ 
+ 	br = netdev_priv(br_dev);
+ 
+ 	if (!br_opt_get(br, BROPT_MULTICAST_ENABLED))
+ 		return 0;
+ 
+ 	/* We cannot walk over br->mdb_list protected just by the rtnl_mutex,
+ 	 * because the write-side protection is br->multicast_lock. But we
+ 	 * need to emulate the [ blocking ] calling context of a regular
+ 	 * switchdev event, so since both br->multicast_lock and RCU read side
+ 	 * critical sections are atomic, we have no choice but to pick the RCU
+ 	 * read side lock, queue up all our events, leave the critical section
+ 	 * and notify switchdev from blocking context.
+ 	 */
+ 	rcu_read_lock();
+ 
+ 	hlist_for_each_entry_rcu(mp, &br->mdb_list, mdb_node) {
+ 		struct net_bridge_port_group __rcu * const *pp;
+ 		const struct net_bridge_port_group *p;
+ 
+ 		if (mp->host_joined) {
+ 			err = br_mdb_queue_one(&mdb_list,
+ 					       SWITCHDEV_OBJ_ID_HOST_MDB,
+ 					       mp, br_dev);
+ 			if (err) {
+ 				rcu_read_unlock();
+ 				goto out_free_mdb;
+ 			}
+ 		}
+ 
+ 		for (pp = &mp->ports; (p = rcu_dereference(*pp)) != NULL;
+ 		     pp = &p->next) {
+ 			if (p->key.port->dev != dev)
+ 				continue;
+ 
+ 			err = br_mdb_queue_one(&mdb_list,
+ 					       SWITCHDEV_OBJ_ID_PORT_MDB,
+ 					       mp, dev);
+ 			if (err) {
+ 				rcu_read_unlock();
+ 				goto out_free_mdb;
+ 			}
+ 		}
+ 	}
+ 
+ 	rcu_read_unlock();
+ 
+ 	if (adding)
+ 		action = SWITCHDEV_PORT_OBJ_ADD;
+ 	else
+ 		action = SWITCHDEV_PORT_OBJ_DEL;
+ 
+ 	list_for_each_entry(obj, &mdb_list, list) {
+ 		err = br_mdb_replay_one(nb, dev, SWITCHDEV_OBJ_PORT_MDB(obj),
+ 					action, ctx, extack);
+ 		if (err)
+ 			goto out_free_mdb;
+ 	}
+ 
+ out_free_mdb:
+ 	list_for_each_entry_safe(obj, tmp, &mdb_list, list) {
+ 		list_del(&obj->list);
+ 		kfree(SWITCHDEV_OBJ_PORT_MDB(obj));
+ 	}
+ 
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(br_mdb_replay);
+ 
++>>>>>>> 7e8c18586daf (net: bridge: allow the switchdev replay functions to be called for deletion)
  static void br_mdb_switchdev_host_port(struct net_device *dev,
  				       struct net_device *lower_dev,
  				       struct net_bridge_mdb_entry *mp,
diff --cc net/bridge/br_vlan.c
index ec7de6e6d9e9,a08e9f193009..000000000000
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@@ -1707,6 -1807,7 +1707,10 @@@ out_kfree
  static int br_vlan_replay_one(struct notifier_block *nb,
  			      struct net_device *dev,
  			      struct switchdev_obj_port_vlan *vlan,
++<<<<<<< HEAD
++=======
+ 			      const void *ctx, unsigned long action,
++>>>>>>> 7e8c18586daf (net: bridge: allow the switchdev replay functions to be called for deletion)
  			      struct netlink_ext_ack *extack)
  {
  	struct switchdev_notifier_port_obj_info obj_info = {
@@@ -1723,7 -1825,8 +1727,12 @@@
  }
  
  int br_vlan_replay(struct net_device *br_dev, struct net_device *dev,
++<<<<<<< HEAD
 +		   struct notifier_block *nb, struct netlink_ext_ack *extack)
++=======
+ 		   const void *ctx, bool adding, struct notifier_block *nb,
+ 		   struct netlink_ext_ack *extack)
++>>>>>>> 7e8c18586daf (net: bridge: allow the switchdev replay functions to be called for deletion)
  {
  	struct net_bridge_vlan_group *vg;
  	struct net_bridge_vlan *v;
@@@ -1768,7 -1877,7 +1783,11 @@@
  		if (!br_vlan_should_use(v))
  			continue;
  
++<<<<<<< HEAD
 +		err = br_vlan_replay_one(nb, dev, &vlan, extack);
++=======
+ 		err = br_vlan_replay_one(nb, dev, &vlan, ctx, action, extack);
++>>>>>>> 7e8c18586daf (net: bridge: allow the switchdev replay functions to be called for deletion)
  		if (err)
  			return err;
  	}
diff --cc net/dsa/port.c
index 2d7e01b23572,4e58d07ececd..000000000000
--- a/net/dsa/port.c
+++ b/net/dsa/port.c
@@@ -90,15 -105,151 +90,150 @@@ void dsa_port_disable(struct dsa_port *
  	struct dsa_switch *ds = dp->ds;
  	int port = dp->index;
  
 -	if (dp->pl)
 -		phylink_stop(dp->pl);
 -
 -	if (!dp->bridge_dev)
 -		dsa_port_set_state_now(dp, BR_STATE_DISABLED);
 +	dsa_port_set_state_now(dp, BR_STATE_DISABLED);
  
  	if (ds->ops->port_disable)
 -		ds->ops->port_disable(ds, port);
 +		ds->ops->port_disable(ds, port, phy);
  }
  
++<<<<<<< HEAD
 +int dsa_port_bridge_join(struct dsa_port *dp, struct net_device *br)
++=======
+ void dsa_port_disable(struct dsa_port *dp)
+ {
+ 	rtnl_lock();
+ 	dsa_port_disable_rt(dp);
+ 	rtnl_unlock();
+ }
+ 
+ static int dsa_port_inherit_brport_flags(struct dsa_port *dp,
+ 					 struct netlink_ext_ack *extack)
+ {
+ 	const unsigned long mask = BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD |
+ 				   BR_BCAST_FLOOD;
+ 	struct net_device *brport_dev = dsa_port_to_bridge_port(dp);
+ 	int flag, err;
+ 
+ 	for_each_set_bit(flag, &mask, 32) {
+ 		struct switchdev_brport_flags flags = {0};
+ 
+ 		flags.mask = BIT(flag);
+ 
+ 		if (br_port_flag_is_set(brport_dev, BIT(flag)))
+ 			flags.val = BIT(flag);
+ 
+ 		err = dsa_port_bridge_flags(dp, flags, extack);
+ 		if (err && err != -EOPNOTSUPP)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void dsa_port_clear_brport_flags(struct dsa_port *dp)
+ {
+ 	const unsigned long val = BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD;
+ 	const unsigned long mask = BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD |
+ 				   BR_BCAST_FLOOD;
+ 	int flag, err;
+ 
+ 	for_each_set_bit(flag, &mask, 32) {
+ 		struct switchdev_brport_flags flags = {0};
+ 
+ 		flags.mask = BIT(flag);
+ 		flags.val = val & BIT(flag);
+ 
+ 		err = dsa_port_bridge_flags(dp, flags, NULL);
+ 		if (err && err != -EOPNOTSUPP)
+ 			dev_err(dp->ds->dev,
+ 				"failed to clear bridge port flag %lu: %pe\n",
+ 				flags.val, ERR_PTR(err));
+ 	}
+ }
+ 
+ static int dsa_port_switchdev_sync(struct dsa_port *dp,
+ 				   struct netlink_ext_ack *extack)
+ {
+ 	struct net_device *brport_dev = dsa_port_to_bridge_port(dp);
+ 	struct net_device *br = dp->bridge_dev;
+ 	int err;
+ 
+ 	err = dsa_port_inherit_brport_flags(dp, extack);
+ 	if (err)
+ 		return err;
+ 
+ 	err = dsa_port_set_state(dp, br_port_get_stp_state(brport_dev));
+ 	if (err && err != -EOPNOTSUPP)
+ 		return err;
+ 
+ 	err = dsa_port_vlan_filtering(dp, br_vlan_enabled(br), extack);
+ 	if (err && err != -EOPNOTSUPP)
+ 		return err;
+ 
+ 	err = dsa_port_mrouter(dp->cpu_dp, br_multicast_router(br), extack);
+ 	if (err && err != -EOPNOTSUPP)
+ 		return err;
+ 
+ 	err = dsa_port_ageing_time(dp, br_get_ageing_time(br));
+ 	if (err && err != -EOPNOTSUPP)
+ 		return err;
+ 
+ 	err = br_mdb_replay(br, brport_dev, dp, true,
+ 			    &dsa_slave_switchdev_blocking_notifier, extack);
+ 	if (err && err != -EOPNOTSUPP)
+ 		return err;
+ 
+ 	err = br_fdb_replay(br, brport_dev, dp, true,
+ 			    &dsa_slave_switchdev_notifier);
+ 	if (err && err != -EOPNOTSUPP)
+ 		return err;
+ 
+ 	err = br_vlan_replay(br, brport_dev, dp, true,
+ 			     &dsa_slave_switchdev_blocking_notifier, extack);
+ 	if (err && err != -EOPNOTSUPP)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
+ static void dsa_port_switchdev_unsync(struct dsa_port *dp)
+ {
+ 	/* Configure the port for standalone mode (no address learning,
+ 	 * flood everything).
+ 	 * The bridge only emits SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS events
+ 	 * when the user requests it through netlink or sysfs, but not
+ 	 * automatically at port join or leave, so we need to handle resetting
+ 	 * the brport flags ourselves. But we even prefer it that way, because
+ 	 * otherwise, some setups might never get the notification they need,
+ 	 * for example, when a port leaves a LAG that offloads the bridge,
+ 	 * it becomes standalone, but as far as the bridge is concerned, no
+ 	 * port ever left.
+ 	 */
+ 	dsa_port_clear_brport_flags(dp);
+ 
+ 	/* Port left the bridge, put in BR_STATE_DISABLED by the bridge layer,
+ 	 * so allow it to be in BR_STATE_FORWARDING to be kept functional
+ 	 */
+ 	dsa_port_set_state_now(dp, BR_STATE_FORWARDING);
+ 
+ 	/* VLAN filtering is handled by dsa_switch_bridge_leave */
+ 
+ 	/* Some drivers treat the notification for having a local multicast
+ 	 * router by allowing multicast to be flooded to the CPU, so we should
+ 	 * allow this in standalone mode too.
+ 	 */
+ 	dsa_port_mrouter(dp->cpu_dp, true, NULL);
+ 
+ 	/* Ageing time may be global to the switch chip, so don't change it
+ 	 * here because we have no good reason (or value) to change it to.
+ 	 */
+ }
+ 
+ int dsa_port_bridge_join(struct dsa_port *dp, struct net_device *br,
+ 			 struct netlink_ext_ack *extack)
++>>>>>>> 7e8c18586daf (net: bridge: allow the switchdev replay functions to be called for deletion)
  {
  	struct dsa_notifier_bridge_info info = {
 -		.tree_index = dp->ds->dst->index,
  		.sw_index = dp->ds->index,
  		.port = dp->index,
  		.br = br,
* Unmerged path drivers/net/ethernet/mscc/ocelot_net.c
* Unmerged path drivers/net/ethernet/mscc/ocelot_net.c
* Unmerged path include/linux/if_bridge.h
* Unmerged path net/bridge/br_fdb.c
* Unmerged path net/bridge/br_mdb.c
* Unmerged path net/bridge/br_vlan.c
* Unmerged path net/dsa/port.c
