sched/wakeup: Split out the wakeup ->__state check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 43295d73adc8d3780e9f34206663e336678aaff8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/43295d73.failed

RT kernels have a slightly more complicated handling of wakeups due to
'sleeping' spin/rwlocks. If a task is blocked on such a lock then the
original state of the task is preserved over the blocking period, and
any regular (non lock related) wakeup has to be targeted at the
saved state to ensure that these wakeups are not lost.

Once the task acquires the lock it restores the task state from the saved state.

To avoid cluttering try_to_wake_up() with that logic, split the wakeup
state check out into an inline helper and use it at both places where
task::__state is checked against the state argument of try_to_wake_up().

No functional change.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
Link: https://lore.kernel.org/r/20210815211302.088945085@linutronix.de
(cherry picked from commit 43295d73adc8d3780e9f34206663e336678aaff8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/core.c
diff --cc kernel/sched/core.c
index 9945a9321de5,961991e06337..000000000000
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@@ -2212,12 -3716,11 +2228,15 @@@ try_to_wake_up(struct task_struct *p, u
  		 *  - we're serialized against set_special_state() by virtue of
  		 *    it disabling IRQs (this allows not taking ->pi_lock).
  		 */
++<<<<<<< HEAD
 +		if (!(p->state & state))
++=======
+ 		if (!ttwu_state_match(p, state, &success))
++>>>>>>> 43295d73adc8 (sched/wakeup: Split out the wakeup ->__state check)
  			goto out;
  
- 		success = 1;
  		trace_sched_waking(p);
 -		WRITE_ONCE(p->__state, TASK_RUNNING);
 +		p->state = TASK_RUNNING;
  		trace_sched_wakeup(p);
  		goto out;
  	}
@@@ -2230,7 -3733,7 +2249,11 @@@
  	 */
  	raw_spin_lock_irqsave(&p->pi_lock, flags);
  	smp_mb__after_spinlock();
++<<<<<<< HEAD
 +	if (!(p->state & state))
++=======
+ 	if (!ttwu_state_match(p, state, &success))
++>>>>>>> 43295d73adc8 (sched/wakeup: Split out the wakeup ->__state check)
  		goto unlock;
  
  	trace_sched_waking(p);
* Unmerged path kernel/sched/core.c
