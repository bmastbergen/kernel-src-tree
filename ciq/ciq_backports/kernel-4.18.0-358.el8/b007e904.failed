KVM: selftests: Genericize upper level page table entry struct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Sean Christopherson <seanjc@google.com>
commit b007e904b36a945d01a9080d754702ca5f9c68b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/b007e904.failed

In preparation for adding hugepage support, replace "pageMapL4Entry",
"pageDirectoryPointerEntry", and "pageDirectoryEntry" with a common
"pageUpperEntry", and add a helper to create an upper level entry. All
upper level entries have the same layout, using unique structs provides
minimal value and requires a non-trivial amount of code duplication.

No functional change intended.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20210622200529.3650424-18-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit b007e904b36a945d01a9080d754702ca5f9c68b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/lib/x86_64/processor.c
diff --cc tools/testing/selftests/kvm/lib/x86_64/processor.c
index 4e80df28f873,fc33acf819ef..000000000000
--- a/tools/testing/selftests/kvm/lib/x86_64/processor.c
+++ b/tools/testing/selftests/kvm/lib/x86_64/processor.c
@@@ -23,37 -20,7 +23,41 @@@
  vm_vaddr_t exception_handlers;
  
  /* Virtual translation table structure declarations */
++<<<<<<< HEAD
 +struct pageMapL4Entry {
 +	uint64_t present:1;
 +	uint64_t writable:1;
 +	uint64_t user:1;
 +	uint64_t write_through:1;
 +	uint64_t cache_disable:1;
 +	uint64_t accessed:1;
 +	uint64_t ignored_06:1;
 +	uint64_t page_size:1;
 +	uint64_t ignored_11_08:4;
 +	uint64_t address:40;
 +	uint64_t ignored_62_52:11;
 +	uint64_t execute_disable:1;
 +};
 +
 +struct pageDirectoryPointerEntry {
 +	uint64_t present:1;
 +	uint64_t writable:1;
 +	uint64_t user:1;
 +	uint64_t write_through:1;
 +	uint64_t cache_disable:1;
 +	uint64_t accessed:1;
 +	uint64_t ignored_06:1;
 +	uint64_t page_size:1;
 +	uint64_t ignored_11_08:4;
 +	uint64_t address:40;
 +	uint64_t ignored_62_52:11;
 +	uint64_t execute_disable:1;
 +};
 +
 +struct pageDirectoryEntry {
++=======
+ struct pageUpperEntry {
++>>>>>>> b007e904b36a (KVM: selftests: Genericize upper level page table entry struct)
  	uint64_t present:1;
  	uint64_t writable:1;
  	uint64_t user:1;
@@@ -221,11 -186,34 +225,42 @@@ void virt_pgd_alloc(struct kvm_vm *vm, 
  	}
  }
  
++<<<<<<< HEAD
 +void virt_pg_map(struct kvm_vm *vm, uint64_t vaddr, uint64_t paddr,
 +	uint32_t pgd_memslot)
 +{
 +	uint16_t index[4];
 +	struct pageMapL4Entry *pml4e;
++=======
+ static void *virt_get_pte(struct kvm_vm *vm, uint64_t pt_pfn, uint64_t vaddr,
+ 			  int level)
+ {
+ 	uint64_t *page_table = addr_gpa2hva(vm, pt_pfn << vm->page_shift);
+ 	int index = vaddr >> (vm->page_shift + level * 9) & 0x1ffu;
+ 
+ 	return &page_table[index];
+ }
+ 
+ static struct pageUpperEntry *virt_create_upper_pte(struct kvm_vm *vm,
+ 						    uint64_t pt_pfn,
+ 						    uint64_t vaddr,
+ 						    int level)
+ {
+ 	struct pageUpperEntry *pte = virt_get_pte(vm, pt_pfn, vaddr, level);
+ 
+ 	if (!pte->present) {
+ 		pte->pfn = vm_alloc_page_table(vm) >> vm->page_shift;
+ 		pte->writable = true;
+ 		pte->present = true;
+ 	}
+ 	return pte;
+ }
+ 
+ void virt_pg_map(struct kvm_vm *vm, uint64_t vaddr, uint64_t paddr)
+ {
+ 	struct pageUpperEntry *pml4e, *pdpe, *pde;
+ 	struct pageTableEntry *pte;
++>>>>>>> b007e904b36a (KVM: selftests: Genericize upper level page table entry struct)
  
  	TEST_ASSERT(vm->mode == VM_MODE_PXXV48_4K, "Attempt to use "
  		"unknown or unsupported guest mode, mode: 0x%x", vm->mode);
@@@ -247,49 -235,16 +282,56 @@@
  		"  paddr: 0x%lx vm->max_gfn: 0x%lx vm->page_size: 0x%x",
  		paddr, vm->max_gfn, vm->page_size);
  
++<<<<<<< HEAD
 +	index[0] = (vaddr >> 12) & 0x1ffu;
 +	index[1] = (vaddr >> 21) & 0x1ffu;
 +	index[2] = (vaddr >> 30) & 0x1ffu;
 +	index[3] = (vaddr >> 39) & 0x1ffu;
 +
 +	/* Allocate page directory pointer table if not present. */
 +	pml4e = addr_gpa2hva(vm, vm->pgd);
 +	if (!pml4e[index[3]].present) {
 +		pml4e[index[3]].address = vm_phy_page_alloc(vm,
 +			KVM_GUEST_PAGE_TABLE_MIN_PADDR, pgd_memslot)
 +			>> vm->page_shift;
 +		pml4e[index[3]].writable = true;
 +		pml4e[index[3]].present = true;
 +	}
 +
 +	/* Allocate page directory table if not present. */
 +	struct pageDirectoryPointerEntry *pdpe;
 +	pdpe = addr_gpa2hva(vm, pml4e[index[3]].address * vm->page_size);
 +	if (!pdpe[index[2]].present) {
 +		pdpe[index[2]].address = vm_phy_page_alloc(vm,
 +			KVM_GUEST_PAGE_TABLE_MIN_PADDR, pgd_memslot)
 +			>> vm->page_shift;
 +		pdpe[index[2]].writable = true;
 +		pdpe[index[2]].present = true;
 +	}
 +
 +	/* Allocate page table if not present. */
 +	struct pageDirectoryEntry *pde;
 +	pde = addr_gpa2hva(vm, pdpe[index[2]].address * vm->page_size);
 +	if (!pde[index[1]].present) {
 +		pde[index[1]].address = vm_phy_page_alloc(vm,
 +			KVM_GUEST_PAGE_TABLE_MIN_PADDR, pgd_memslot)
 +			>> vm->page_shift;
 +		pde[index[1]].writable = true;
 +		pde[index[1]].present = true;
 +	}
++=======
+ 	/* Allocate upper level page tables, if not already present. */
+ 	pml4e = virt_create_upper_pte(vm, vm->pgd >> vm->page_shift, vaddr, 3);
+ 	pdpe = virt_create_upper_pte(vm, pml4e->pfn, vaddr, 2);
+ 	pde = virt_create_upper_pte(vm, pdpe->pfn, vaddr, 1);
++>>>>>>> b007e904b36a (KVM: selftests: Genericize upper level page table entry struct)
  
  	/* Fill in page table entry. */
 -	pte = virt_get_pte(vm, pde->pfn, vaddr, 0);
 -	pte->pfn = paddr >> vm->page_shift;
 -	pte->writable = true;
 -	pte->present = 1;
 +	struct pageTableEntry *pte;
 +	pte = addr_gpa2hva(vm, pde[index[1]].address * vm->page_size);
 +	pte[index[0]].address = paddr >> vm->page_shift;
 +	pte[index[0]].writable = true;
 +	pte[index[0]].present = 1;
  }
  
  void virt_dump(FILE *stream, struct kvm_vm *vm, uint8_t indent)
* Unmerged path tools/testing/selftests/kvm/lib/x86_64/processor.c
