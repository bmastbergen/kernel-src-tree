bridge: uapi: mrp: Extend MRP attributes for MRP interconnect

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Horatiu Vultur <horatiu.vultur@microchip.com>
commit 2801758391ba6b0c20e253b956355e1b15ad85a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/28017583.failed

Extend the existing MRP netlink attributes to allow to configure MRP
Interconnect:

IFLA_BRIDGE_MRP_IN_ROLE - the parameter type is br_mrp_in_role which
  contains the interconnect id, the ring id, the interconnect role(MIM
  or MIC) and the port ifindex that represents the interconnect port.

IFLA_BRIDGE_MRP_IN_STATE - the parameter type is br_mrp_in_state which
  contains the interconnect id and the interconnect state.

IFLA_BRIDGE_MRP_IN_TEST - the parameter type is br_mrp_start_in_test
  which contains the interconnect id, the interval at which to send
  MRP_InTest frames, how many test frames can be missed before declaring
  the interconnect ring open and the period which represents for how long
  to send MRP_InTest frames.

	Signed-off-by: Horatiu Vultur <horatiu.vultur@microchip.com>
	Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2801758391ba6b0c20e253b956355e1b15ad85a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/mrp_bridge.h
diff --cc include/uapi/linux/mrp_bridge.h
index 694a68dcbe43,6aeb13ef0b1e..000000000000
--- a/include/uapi/linux/mrp_bridge.h
+++ b/include/uapi/linux/mrp_bridge.h
@@@ -16,8 -18,15 +16,14 @@@ enum br_mrp_ring_role_type 
  	BR_MRP_RING_ROLE_DISABLED,
  	BR_MRP_RING_ROLE_MRC,
  	BR_MRP_RING_ROLE_MRM,
 -	BR_MRP_RING_ROLE_MRA,
  };
  
+ enum br_mrp_in_role_type {
+ 	BR_MRP_IN_ROLE_DISABLED,
+ 	BR_MRP_IN_ROLE_MIC,
+ 	BR_MRP_IN_ROLE_MIM,
+ };
+ 
  enum br_mrp_ring_state_type {
  	BR_MRP_RING_STATE_OPEN,
  	BR_MRP_RING_STATE_CLOSED,
@@@ -42,6 -57,17 +54,20 @@@ enum br_mrp_tlv_header_type 
  	BR_MRP_TLV_HEADER_RING_TOPO = 0x3,
  	BR_MRP_TLV_HEADER_RING_LINK_DOWN = 0x4,
  	BR_MRP_TLV_HEADER_RING_LINK_UP = 0x5,
++<<<<<<< HEAD
++=======
+ 	BR_MRP_TLV_HEADER_IN_TEST = 0x6,
+ 	BR_MRP_TLV_HEADER_IN_TOPO = 0x7,
+ 	BR_MRP_TLV_HEADER_IN_LINK_DOWN = 0x8,
+ 	BR_MRP_TLV_HEADER_IN_LINK_UP = 0x9,
+ 	BR_MRP_TLV_HEADER_OPTION = 0x7f,
+ };
+ 
+ enum br_mrp_sub_tlv_header_type {
+ 	BR_MRP_SUB_TLV_HEADER_TEST_MGR_NACK = 0x1,
+ 	BR_MRP_SUB_TLV_HEADER_TEST_PROPAGATE = 0x2,
+ 	BR_MRP_SUB_TLV_HEADER_TEST_AUTO_MGR = 0x3,
++>>>>>>> 2801758391ba (bridge: uapi: mrp: Extend MRP attributes for MRP interconnect)
  };
  
  struct br_mrp_tlv_hdr {
@@@ -80,4 -111,49 +106,52 @@@ struct br_mrp_ring_link_hdr 
  	__be16 blocked;
  };
  
++<<<<<<< HEAD
++=======
+ struct br_mrp_sub_opt_hdr {
+ 	__u8 type;
+ 	__u8 manufacture_data[MRP_MANUFACTURE_DATA_LENGTH];
+ };
+ 
+ struct br_mrp_test_mgr_nack_hdr {
+ 	__be16 prio;
+ 	__u8 sa[ETH_ALEN];
+ 	__be16 other_prio;
+ 	__u8 other_sa[ETH_ALEN];
+ };
+ 
+ struct br_mrp_test_prop_hdr {
+ 	__be16 prio;
+ 	__u8 sa[ETH_ALEN];
+ 	__be16 other_prio;
+ 	__u8 other_sa[ETH_ALEN];
+ };
+ 
+ struct br_mrp_oui_hdr {
+ 	__u8 oui[MRP_OUI_LENGTH];
+ };
+ 
+ struct br_mrp_in_test_hdr {
+ 	__be16 id;
+ 	__u8 sa[ETH_ALEN];
+ 	__be16 port_role;
+ 	__be16 state;
+ 	__be16 transitions;
+ 	__be32 timestamp;
+ };
+ 
+ struct br_mrp_in_topo_hdr {
+ 	__u8 sa[ETH_ALEN];
+ 	__be16 id;
+ 	__be16 interval;
+ };
+ 
+ struct br_mrp_in_link_hdr {
+ 	__u8 sa[ETH_ALEN];
+ 	__be16 port_role;
+ 	__be16 id;
+ 	__be16 interval;
+ };
+ 
++>>>>>>> 2801758391ba (bridge: uapi: mrp: Extend MRP attributes for MRP interconnect)
  #endif
diff --git a/include/uapi/linux/if_bridge.h b/include/uapi/linux/if_bridge.h
index 5b49595db6cf..5f2fde4eddf7 100644
--- a/include/uapi/linux/if_bridge.h
+++ b/include/uapi/linux/if_bridge.h
@@ -167,6 +167,9 @@ enum {
 	IFLA_BRIDGE_MRP_RING_ROLE,
 	IFLA_BRIDGE_MRP_START_TEST,
 	IFLA_BRIDGE_MRP_INFO,
+	IFLA_BRIDGE_MRP_IN_ROLE,
+	IFLA_BRIDGE_MRP_IN_STATE,
+	IFLA_BRIDGE_MRP_START_IN_TEST,
 	__IFLA_BRIDGE_MRP_MAX,
 };
 
@@ -243,6 +246,37 @@ enum {
 
 #define IFLA_BRIDGE_MRP_INFO_MAX (__IFLA_BRIDGE_MRP_INFO_MAX - 1)
 
+enum {
+	IFLA_BRIDGE_MRP_IN_STATE_UNSPEC,
+	IFLA_BRIDGE_MRP_IN_STATE_IN_ID,
+	IFLA_BRIDGE_MRP_IN_STATE_STATE,
+	__IFLA_BRIDGE_MRP_IN_STATE_MAX,
+};
+
+#define IFLA_BRIDGE_MRP_IN_STATE_MAX (__IFLA_BRIDGE_MRP_IN_STATE_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_MRP_IN_ROLE_UNSPEC,
+	IFLA_BRIDGE_MRP_IN_ROLE_RING_ID,
+	IFLA_BRIDGE_MRP_IN_ROLE_IN_ID,
+	IFLA_BRIDGE_MRP_IN_ROLE_ROLE,
+	IFLA_BRIDGE_MRP_IN_ROLE_I_IFINDEX,
+	__IFLA_BRIDGE_MRP_IN_ROLE_MAX,
+};
+
+#define IFLA_BRIDGE_MRP_IN_ROLE_MAX (__IFLA_BRIDGE_MRP_IN_ROLE_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_MRP_START_IN_TEST_UNSPEC,
+	IFLA_BRIDGE_MRP_START_IN_TEST_IN_ID,
+	IFLA_BRIDGE_MRP_START_IN_TEST_INTERVAL,
+	IFLA_BRIDGE_MRP_START_IN_TEST_MAX_MISS,
+	IFLA_BRIDGE_MRP_START_IN_TEST_PERIOD,
+	__IFLA_BRIDGE_MRP_START_IN_TEST_MAX,
+};
+
+#define IFLA_BRIDGE_MRP_START_IN_TEST_MAX (__IFLA_BRIDGE_MRP_START_IN_TEST_MAX - 1)
+
 struct br_mrp_instance {
 	__u32 ring_id;
 	__u32 p_ifindex;
@@ -266,6 +300,25 @@ struct br_mrp_start_test {
 	__u32 period;
 };
 
+struct br_mrp_in_state {
+	__u32 in_state;
+	__u16 in_id;
+};
+
+struct br_mrp_in_role {
+	__u32 ring_id;
+	__u32 in_role;
+	__u32 i_ifindex;
+	__u16 in_id;
+};
+
+struct br_mrp_start_in_test {
+	__u32 interval;
+	__u32 max_miss;
+	__u32 period;
+	__u16 in_id;
+};
+
 struct bridge_stp_xstats {
 	__u64 transition_blk;
 	__u64 transition_fwd;
* Unmerged path include/uapi/linux/mrp_bridge.h
