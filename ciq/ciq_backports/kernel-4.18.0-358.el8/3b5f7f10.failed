i2c: designware: slave should do WRITE_REQUESTED before WRITE_RECEIVED

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Michael Wu <michael.wu@vatics.com>
commit 3b5f7f10ff6e6b66f553e12cc50d9bb751ce60ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/3b5f7f10.failed

Sometimes we would get the following flow when doing an i2cset:

0x1 STATUS SLAVE_ACTIVITY=0x1 : RAW_INTR_STAT=0x514 : INTR_STAT=0x4
I2C_SLAVE_WRITE_RECEIVED
0x1 STATUS SLAVE_ACTIVITY=0x0 : RAW_INTR_STAT=0x714 : INTR_STAT=0x204
I2C_SLAVE_WRITE_REQUESTED
I2C_SLAVE_WRITE_RECEIVED

Documentation/i2c/slave-interface.rst says that I2C_SLAVE_WRITE_REQUESTED,
which is mandatory, should be sent while the data did not arrive yet. It
means in a write-request I2C_SLAVE_WRITE_REQUESTED should be reported
before any I2C_SLAVE_WRITE_RECEIVED.

By the way, I2C_SLAVE_STOP didn't be reported in the above case because
DW_IC_INTR_STAT was not 0x200.

dev->status can be used to record the current state, especially Designware
I2C controller has no interrupts to identify a write-request. This patch
makes not only I2C_SLAVE_WRITE_REQUESTED been reported first when
IC_INTR_RX_FULL is rising and dev->status isn't STATUS_WRITE_IN_PROGRESS
but also I2C_SLAVE_STOP been reported when a STOP condition is received.

	Signed-off-by: Michael Wu <michael.wu@vatics.com>
	Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
	Signed-off-by: Wolfram Sang <wsa@kernel.org>
(cherry picked from commit 3b5f7f10ff6e6b66f553e12cc50d9bb751ce60ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/busses/i2c-designware-slave.c
diff --cc drivers/i2c/busses/i2c-designware-slave.c
index f5ecf76c0d02,0d15f4c1e9f7..000000000000
--- a/drivers/i2c/busses/i2c-designware-slave.c
+++ b/drivers/i2c/busses/i2c-designware-slave.c
@@@ -176,22 -188,9 +187,28 @@@ static int i2c_dw_irq_handler_slave(str
  
  	if (stat & DW_IC_INTR_RD_REQ) {
  		if (slave_activity) {
++<<<<<<< HEAD
 +			if (stat & DW_IC_INTR_RX_FULL) {
 +				val = dw_readl(dev, DW_IC_DATA_CMD);
 +
 +				if (!i2c_slave_event(dev->slave,
 +						     I2C_SLAVE_WRITE_RECEIVED,
 +						     &val)) {
 +					dev_vdbg(dev->dev, "Byte %X acked!",
 +						 val);
 +				}
 +				dw_readl(dev, DW_IC_CLR_RD_REQ);
 +				stat = i2c_dw_read_clear_intrbits_slave(dev);
 +			} else {
 +				dw_readl(dev, DW_IC_CLR_RD_REQ);
 +				dw_readl(dev, DW_IC_CLR_RX_UNDER);
 +				stat = i2c_dw_read_clear_intrbits_slave(dev);
 +			}
++=======
+ 			regmap_read(dev->map, DW_IC_CLR_RD_REQ, &tmp);
+ 
+ 			dev->status = STATUS_READ_IN_PROGRESS;
++>>>>>>> 3b5f7f10ff6e (i2c: designware: slave should do WRITE_REQUESTED before WRITE_RECEIVED)
  			if (!i2c_slave_event(dev->slave,
  					     I2C_SLAVE_READ_REQUESTED,
  					     &val))
@@@ -202,21 -201,12 +219,29 @@@
  	if (stat & DW_IC_INTR_RX_DONE) {
  		if (!i2c_slave_event(dev->slave, I2C_SLAVE_READ_PROCESSED,
  				     &val))
++<<<<<<< HEAD
 +			dw_readl(dev, DW_IC_CLR_RX_DONE);
 +
 +		i2c_slave_event(dev->slave, I2C_SLAVE_STOP, &val);
 +		stat = i2c_dw_read_clear_intrbits_slave(dev);
 +		return 1;
 +	}
 +
 +	if (stat & DW_IC_INTR_RX_FULL) {
 +		val = dw_readl(dev, DW_IC_DATA_CMD);
 +		if (!i2c_slave_event(dev->slave, I2C_SLAVE_WRITE_RECEIVED,
 +				     &val))
 +			dev_vdbg(dev->dev, "Byte %X acked!", val);
 +	} else {
++=======
+ 			regmap_read(dev->map, DW_IC_CLR_RX_DONE, &tmp);
+ 	}
+ 
+ 	if (stat & DW_IC_INTR_STOP_DET) {
+ 		dev->status = STATUS_IDLE;
++>>>>>>> 3b5f7f10ff6e (i2c: designware: slave should do WRITE_REQUESTED before WRITE_RECEIVED)
  		i2c_slave_event(dev->slave, I2C_SLAVE_STOP, &val);
 +		stat = i2c_dw_read_clear_intrbits_slave(dev);
  	}
  
  	return 1;
* Unmerged path drivers/i2c/busses/i2c-designware-slave.c
