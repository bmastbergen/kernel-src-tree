KVM: x86: remove dead initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit ffbe17cadaf564b5da0e4eabdcff1b719e184a76
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/ffbe17ca.failed

hv_vcpu is initialized again a dozen lines below, and at this
point vcpu->arch.hyperv is not valid.  Remove the initializer.

	Reported-by: kernel test robot <lkp@intel.com>
	Reviewed-by: Sean Christopherson <seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit ffbe17cadaf564b5da0e4eabdcff1b719e184a76)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/hyperv.c
diff --cc arch/x86/kvm/hyperv.c
index 47f95831accd,41d2a53c5dea..000000000000
--- a/arch/x86/kvm/hyperv.c
+++ b/arch/x86/kvm/hyperv.c
@@@ -1938,12 -1933,67 +1938,16 @@@ ret_success
  void kvm_hv_set_cpuid(struct kvm_vcpu *vcpu)
  {
  	struct kvm_cpuid_entry2 *entry;
++<<<<<<< HEAD
++=======
+ 	struct kvm_vcpu_hv *hv_vcpu;
++>>>>>>> ffbe17cadaf5 (KVM: x86: remove dead initialization)
  
  	entry = kvm_find_cpuid_entry(vcpu, HYPERV_CPUID_INTERFACE, 0);
 -	if (entry && entry->eax == HYPERV_CPUID_SIGNATURE_EAX) {
 +	if (entry && entry->eax == HYPERV_CPUID_SIGNATURE_EAX)
  		vcpu->arch.hyperv_enabled = true;
 -	} else {
 -		vcpu->arch.hyperv_enabled = false;
 -		return;
 -	}
 -
 -	if (!to_hv_vcpu(vcpu) && kvm_hv_vcpu_init(vcpu))
 -		return;
 -
 -	hv_vcpu = to_hv_vcpu(vcpu);
 -
 -	entry = kvm_find_cpuid_entry(vcpu, HYPERV_CPUID_FEATURES, 0);
 -	if (entry) {
 -		hv_vcpu->cpuid_cache.features_eax = entry->eax;
 -		hv_vcpu->cpuid_cache.features_ebx = entry->ebx;
 -		hv_vcpu->cpuid_cache.features_edx = entry->edx;
 -	} else {
 -		hv_vcpu->cpuid_cache.features_eax = 0;
 -		hv_vcpu->cpuid_cache.features_ebx = 0;
 -		hv_vcpu->cpuid_cache.features_edx = 0;
 -	}
 -
 -	entry = kvm_find_cpuid_entry(vcpu, HYPERV_CPUID_ENLIGHTMENT_INFO, 0);
 -	if (entry) {
 -		hv_vcpu->cpuid_cache.enlightenments_eax = entry->eax;
 -		hv_vcpu->cpuid_cache.enlightenments_ebx = entry->ebx;
 -	} else {
 -		hv_vcpu->cpuid_cache.enlightenments_eax = 0;
 -		hv_vcpu->cpuid_cache.enlightenments_ebx = 0;
 -	}
 -
 -	entry = kvm_find_cpuid_entry(vcpu, HYPERV_CPUID_SYNDBG_PLATFORM_CAPABILITIES, 0);
 -	if (entry)
 -		hv_vcpu->cpuid_cache.syndbg_cap_eax = entry->eax;
  	else
 -		hv_vcpu->cpuid_cache.syndbg_cap_eax = 0;
 -}
 -
 -int kvm_hv_set_enforce_cpuid(struct kvm_vcpu *vcpu, bool enforce)
 -{
 -	struct kvm_vcpu_hv *hv_vcpu;
 -	int ret = 0;
 -
 -	if (!to_hv_vcpu(vcpu)) {
 -		if (enforce) {
 -			ret = kvm_hv_vcpu_init(vcpu);
 -			if (ret)
 -				return ret;
 -		} else {
 -			return 0;
 -		}
 -	}
 -
 -	hv_vcpu = to_hv_vcpu(vcpu);
 -	hv_vcpu->enforce_cpuid = enforce;
 -
 -	return ret;
 +		vcpu->arch.hyperv_enabled = false;
  }
  
  bool kvm_hv_hypercall_enabled(struct kvm_vcpu *vcpu)
* Unmerged path arch/x86/kvm/hyperv.c
