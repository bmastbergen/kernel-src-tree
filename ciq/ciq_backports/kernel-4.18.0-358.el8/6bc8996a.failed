locking/rtmutex: Provide rt_mutex_base_is_locked()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 6bc8996add9f82d0153b0be44efe282bd45dc702
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/6bc8996a.failed

Provide rt_mutex_base_is_locked(), which will be used for various wrapped
locking primitives for RT.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
Link: https://lore.kernel.org/r/20210815211302.899572818@linutronix.de
(cherry picked from commit 6bc8996add9f82d0153b0be44efe282bd45dc702)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/rtmutex.h
diff --cc include/linux/rtmutex.h
index cb0f441fecb9,174419ee58e9..000000000000
--- a/include/linux/rtmutex.h
+++ b/include/linux/rtmutex.h
@@@ -19,6 -20,32 +20,35 @@@
  
  extern int max_lock_depth; /* for sysctl */
  
++<<<<<<< HEAD
++=======
+ struct rt_mutex_base {
+ 	raw_spinlock_t		wait_lock;
+ 	struct rb_root_cached   waiters;
+ 	struct task_struct	*owner;
+ };
+ 
+ #define __RT_MUTEX_BASE_INITIALIZER(rtbasename)				\
+ {									\
+ 	.wait_lock = __RAW_SPIN_LOCK_UNLOCKED(rtbasename.wait_lock),	\
+ 	.waiters = RB_ROOT_CACHED,					\
+ 	.owner = NULL							\
+ }
+ 
+ /**
+  * rt_mutex_base_is_locked - is the rtmutex locked
+  * @lock: the mutex to be queried
+  *
+  * Returns true if the mutex is locked, false if unlocked.
+  */
+ static inline bool rt_mutex_base_is_locked(struct rt_mutex_base *lock)
+ {
+ 	return READ_ONCE(lock->owner) != NULL;
+ }
+ 
+ extern void rt_mutex_base_init(struct rt_mutex_base *rtb);
+ 
++>>>>>>> 6bc8996add9f (locking/rtmutex: Provide rt_mutex_base_is_locked())
  /**
   * The rt_mutex structure
   *
* Unmerged path include/linux/rtmutex.h
