switchdev: mrp: Extend switchdev API for MRP Interconnect

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Horatiu Vultur <horatiu.vultur@microchip.com>
commit cf7c52748f64606f5f9111e7cbdb2ffb281a60af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/cf7c5274.failed

Extend switchdev API to add support for MRP interconnect. The HW is
notified in the following cases:

SWITCHDEV_OBJ_ID_IN_ROLE_MRP: This is used when the interconnect role
  of the node changes. The supported roles are MIM and MIC.

SWITCHDEV_OBJ_ID_IN_STATE_MRP: This is used when the interconnect ring
  changes it states to open or closed.

SWITCHDEV_OBJ_ID_IN_TEST_MRP: This is used to start/stop sending
  MRP_InTest frames on all MRP ports. This is called only on nodes that
  have the interconnect role MIM.

	Signed-off-by: Horatiu Vultur <horatiu.vultur@microchip.com>
	Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cf7c52748f64606f5f9111e7cbdb2ffb281a60af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/switchdev.h
diff --cc include/net/switchdev.h
index 4c14c5b37237,ff2246914301..000000000000
--- a/include/net/switchdev.h
+++ b/include/net/switchdev.h
@@@ -79,6 -71,16 +79,19 @@@ enum switchdev_obj_id 
  	SWITCHDEV_OBJ_ID_PORT_VLAN,
  	SWITCHDEV_OBJ_ID_PORT_MDB,
  	SWITCHDEV_OBJ_ID_HOST_MDB,
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_BRIDGE_MRP)
+ 	SWITCHDEV_OBJ_ID_MRP,
+ 	SWITCHDEV_OBJ_ID_RING_TEST_MRP,
+ 	SWITCHDEV_OBJ_ID_RING_ROLE_MRP,
+ 	SWITCHDEV_OBJ_ID_RING_STATE_MRP,
+ 	SWITCHDEV_OBJ_ID_IN_TEST_MRP,
+ 	SWITCHDEV_OBJ_ID_IN_ROLE_MRP,
+ 	SWITCHDEV_OBJ_ID_IN_STATE_MRP,
+ 
+ #endif
++>>>>>>> cf7c52748f64 (switchdev: mrp: Extend switchdev API for MRP Interconnect)
  };
  
  struct switchdev_obj {
@@@ -115,38 -112,91 +128,124 @@@ struct switchdev_obj_port_mdb 
  #define SWITCHDEV_OBJ_PORT_MDB(OBJ) \
  	container_of((OBJ), struct switchdev_obj_port_mdb, obj)
  
++<<<<<<< HEAD
++=======
+ 
+ #if IS_ENABLED(CONFIG_BRIDGE_MRP)
+ /* SWITCHDEV_OBJ_ID_MRP */
+ struct switchdev_obj_mrp {
+ 	struct switchdev_obj obj;
+ 	struct net_device *p_port;
+ 	struct net_device *s_port;
+ 	u32 ring_id;
+ 	u16 prio;
+ };
+ 
+ #define SWITCHDEV_OBJ_MRP(OBJ) \
+ 	container_of((OBJ), struct switchdev_obj_mrp, obj)
+ 
+ /* SWITCHDEV_OBJ_ID_RING_TEST_MRP */
+ struct switchdev_obj_ring_test_mrp {
+ 	struct switchdev_obj obj;
+ 	/* The value is in us and a value of 0 represents to stop */
+ 	u32 interval;
+ 	u8 max_miss;
+ 	u32 ring_id;
+ 	u32 period;
+ 	bool monitor;
+ };
+ 
+ #define SWITCHDEV_OBJ_RING_TEST_MRP(OBJ) \
+ 	container_of((OBJ), struct switchdev_obj_ring_test_mrp, obj)
+ 
+ /* SWICHDEV_OBJ_ID_RING_ROLE_MRP */
+ struct switchdev_obj_ring_role_mrp {
+ 	struct switchdev_obj obj;
+ 	u8 ring_role;
+ 	u32 ring_id;
+ };
+ 
+ #define SWITCHDEV_OBJ_RING_ROLE_MRP(OBJ) \
+ 	container_of((OBJ), struct switchdev_obj_ring_role_mrp, obj)
+ 
+ struct switchdev_obj_ring_state_mrp {
+ 	struct switchdev_obj obj;
+ 	u8 ring_state;
+ 	u32 ring_id;
+ };
+ 
+ #define SWITCHDEV_OBJ_RING_STATE_MRP(OBJ) \
+ 	container_of((OBJ), struct switchdev_obj_ring_state_mrp, obj)
+ 
+ /* SWITCHDEV_OBJ_ID_IN_TEST_MRP */
+ struct switchdev_obj_in_test_mrp {
+ 	struct switchdev_obj obj;
+ 	/* The value is in us and a value of 0 represents to stop */
+ 	u32 interval;
+ 	u32 in_id;
+ 	u32 period;
+ 	u8 max_miss;
+ };
+ 
+ #define SWITCHDEV_OBJ_IN_TEST_MRP(OBJ) \
+ 	container_of((OBJ), struct switchdev_obj_in_test_mrp, obj)
+ 
+ /* SWICHDEV_OBJ_ID_IN_ROLE_MRP */
+ struct switchdev_obj_in_role_mrp {
+ 	struct switchdev_obj obj;
+ 	struct net_device *i_port;
+ 	u32 ring_id;
+ 	u16 in_id;
+ 	u8 in_role;
+ };
+ 
+ #define SWITCHDEV_OBJ_IN_ROLE_MRP(OBJ) \
+ 	container_of((OBJ), struct switchdev_obj_in_role_mrp, obj)
+ 
+ struct switchdev_obj_in_state_mrp {
+ 	struct switchdev_obj obj;
+ 	u32 in_id;
+ 	u8 in_state;
+ };
+ 
+ #define SWITCHDEV_OBJ_IN_STATE_MRP(OBJ) \
+ 	container_of((OBJ), struct switchdev_obj_in_state_mrp, obj)
+ 
+ #endif
+ 
++>>>>>>> cf7c52748f64 (switchdev: mrp: Extend switchdev API for MRP Interconnect)
  typedef int switchdev_obj_dump_cb_t(struct switchdev_obj *obj);
  
 +struct switchdev_ops_extended_rh {
 +};
 +
 +/**
 + * struct switchdev_ops - switchdev operations
 + *
 + * @switchdev_port_attr_set: Set a port attribute (see switchdev_attr).
 + */
 +struct RH_KABI_RENAME(switchdev_ops, rh_deprecated_switchdev_ops) {
 +	RH_KABI_DEPRECATE_FN(int, switchdev_port_attr_get, struct net_device *dev,
 +					   struct switchdev_attr *attr)
 +	RH_KABI_DEPRECATE_FN(int, switchdev_port_attr_set, struct net_device *dev,
 +					   const struct switchdev_attr *attr,
 +					   struct switchdev_trans *trans)
 +	RH_KABI_DEPRECATE_FN(int, switchdev_port_obj_add, struct net_device *dev,
 +					  const struct switchdev_obj *obj,
 +					  struct switchdev_trans *trans)
 +	RH_KABI_DEPRECATE_FN(int, switchdev_port_obj_del, struct net_device *dev,
 +					  const struct switchdev_obj *obj)
 +
 +	RH_KABI_RESERVE(1)
 +	RH_KABI_RESERVE(2)
 +	RH_KABI_RESERVE(3)
 +	RH_KABI_RESERVE(4)
 +	RH_KABI_RESERVE(5)
 +	RH_KABI_RESERVE(6)
 +	RH_KABI_RESERVE(7)
 +	RH_KABI_AUX_EMBED(switchdev_ops_extended)
 +};
 +
  enum switchdev_notifier_type {
  	SWITCHDEV_FDB_ADD_TO_BRIDGE = 1,
  	SWITCHDEV_FDB_DEL_TO_BRIDGE,
* Unmerged path include/net/switchdev.h
