Bluetooth: Use intervals and tx power from mgmt cmds

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Daniel Winkler <danielwinkler@google.com>
commit 9bf9f4b6301ffbd51674e1168f8eeed214d2cf99
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/9bf9f4b6.failed

This patch takes the min/max intervals and tx power optionally provided
in mgmt interface, stores them in the advertisement struct, and uses
them when configuring the hci requests. While tx power is not used if
extended advertising is unavailable, software rotation will use the min
and max advertising intervals specified by the client.

This change is validated manually by ensuring the min/max intervals are
propagated to the controller on both hatch (extended advertising) and
kukui (no extended advertising) chromebooks, and that tx power is
propagated correctly on hatch. These tests are performed with multiple
advertisements simultaneously.

	Reviewed-by: Sonny Sasaka <sonnysasaka@chromium.org>
	Signed-off-by: Daniel Winkler <danielwinkler@google.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
	Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
(cherry picked from commit 9bf9f4b6301ffbd51674e1168f8eeed214d2cf99)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/bluetooth/hci_core.h
#	net/bluetooth/mgmt.c
diff --cc include/net/bluetooth/hci_core.h
index 87a79e4f1ac5,88988d4fd347..000000000000
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@@ -1267,7 -1305,11 +1269,15 @@@ struct adv_info *hci_get_next_instance(
  int hci_add_adv_instance(struct hci_dev *hdev, u8 instance, u32 flags,
  			 u16 adv_data_len, u8 *adv_data,
  			 u16 scan_rsp_len, u8 *scan_rsp_data,
++<<<<<<< HEAD
 +			 u16 timeout, u16 duration);
++=======
+ 			 u16 timeout, u16 duration, s8 tx_power,
+ 			 u32 min_interval, u32 max_interval);
+ int hci_set_adv_instance_data(struct hci_dev *hdev, u8 instance,
+ 			 u16 adv_data_len, u8 *adv_data,
+ 			 u16 scan_rsp_len, u8 *scan_rsp_data);
++>>>>>>> 9bf9f4b6301f (Bluetooth: Use intervals and tx power from mgmt cmds)
  int hci_remove_adv_instance(struct hci_dev *hdev, u8 instance);
  void hci_adv_instances_set_rpa_expired(struct hci_dev *hdev, bool rpa_expired);
  
diff --cc net/bluetooth/mgmt.c
index bd9aa408640d,668a62c8181e..000000000000
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@@ -6883,6 -7609,338 +6886,341 @@@ unlock
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static void add_ext_adv_params_complete(struct hci_dev *hdev, u8 status,
+ 					u16 opcode)
+ {
+ 	struct mgmt_pending_cmd *cmd;
+ 	struct mgmt_cp_add_ext_adv_params *cp;
+ 	struct mgmt_rp_add_ext_adv_params rp;
+ 	struct adv_info *adv_instance;
+ 	u32 flags;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	cmd = pending_find(MGMT_OP_ADD_EXT_ADV_PARAMS, hdev);
+ 	if (!cmd)
+ 		goto unlock;
+ 
+ 	cp = cmd->param;
+ 	adv_instance = hci_find_adv_instance(hdev, cp->instance);
+ 	if (!adv_instance)
+ 		goto unlock;
+ 
+ 	rp.instance = cp->instance;
+ 	rp.tx_power = adv_instance->tx_power;
+ 
+ 	/* While we're at it, inform userspace of the available space for this
+ 	 * advertisement, given the flags that will be used.
+ 	 */
+ 	flags = __le32_to_cpu(cp->flags);
+ 	rp.max_adv_data_len = tlv_data_max_len(hdev, flags, true);
+ 	rp.max_scan_rsp_len = tlv_data_max_len(hdev, flags, false);
+ 
+ 	if (status) {
+ 		/* If this advertisement was previously advertising and we
+ 		 * failed to update it, we signal that it has been removed and
+ 		 * delete its structure
+ 		 */
+ 		if (!adv_instance->pending)
+ 			mgmt_advertising_removed(cmd->sk, hdev, cp->instance);
+ 
+ 		hci_remove_adv_instance(hdev, cp->instance);
+ 
+ 		mgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode,
+ 				mgmt_status(status));
+ 
+ 	} else {
+ 		mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,
+ 				  mgmt_status(status), &rp, sizeof(rp));
+ 	}
+ 
+ unlock:
+ 	if (cmd)
+ 		mgmt_pending_remove(cmd);
+ 
+ 	hci_dev_unlock(hdev);
+ }
+ 
+ static int add_ext_adv_params(struct sock *sk, struct hci_dev *hdev,
+ 			      void *data, u16 data_len)
+ {
+ 	struct mgmt_cp_add_ext_adv_params *cp = data;
+ 	struct mgmt_rp_add_ext_adv_params rp;
+ 	struct mgmt_pending_cmd *cmd = NULL;
+ 	struct adv_info *adv_instance;
+ 	struct hci_request req;
+ 	u32 flags, min_interval, max_interval;
+ 	u16 timeout, duration;
+ 	u8 status;
+ 	s8 tx_power;
+ 	int err;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	status = mgmt_le_support(hdev);
+ 	if (status)
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,
+ 				       status);
+ 
+ 	if (cp->instance < 1 || cp->instance > hdev->le_num_of_adv_sets)
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 	/* The purpose of breaking add_advertising into two separate MGMT calls
+ 	 * for params and data is to allow more parameters to be added to this
+ 	 * structure in the future. For this reason, we verify that we have the
+ 	 * bare minimum structure we know of when the interface was defined. Any
+ 	 * extra parameters we don't know about will be ignored in this request.
+ 	 */
+ 	if (data_len < MGMT_ADD_EXT_ADV_PARAMS_MIN_SIZE)
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 	flags = __le32_to_cpu(cp->flags);
+ 
+ 	if (!requested_adv_flags_are_valid(hdev, flags))
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	/* In new interface, we require that we are powered to register */
+ 	if (!hdev_is_powered(hdev)) {
+ 		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,
+ 				      MGMT_STATUS_REJECTED);
+ 		goto unlock;
+ 	}
+ 
+ 	if (adv_busy(hdev)) {
+ 		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,
+ 				      MGMT_STATUS_BUSY);
+ 		goto unlock;
+ 	}
+ 
+ 	/* Parse defined parameters from request, use defaults otherwise */
+ 	timeout = (flags & MGMT_ADV_PARAM_TIMEOUT) ?
+ 		  __le16_to_cpu(cp->timeout) : 0;
+ 
+ 	duration = (flags & MGMT_ADV_PARAM_DURATION) ?
+ 		   __le16_to_cpu(cp->duration) :
+ 		   hdev->def_multi_adv_rotation_duration;
+ 
+ 	min_interval = (flags & MGMT_ADV_PARAM_INTERVALS) ?
+ 		       __le32_to_cpu(cp->min_interval) :
+ 		       hdev->le_adv_min_interval;
+ 
+ 	max_interval = (flags & MGMT_ADV_PARAM_INTERVALS) ?
+ 		       __le32_to_cpu(cp->max_interval) :
+ 		       hdev->le_adv_max_interval;
+ 
+ 	tx_power = (flags & MGMT_ADV_PARAM_TX_POWER) ?
+ 		   cp->tx_power :
+ 		   HCI_ADV_TX_POWER_NO_PREFERENCE;
+ 
+ 	/* Create advertising instance with no advertising or response data */
+ 	err = hci_add_adv_instance(hdev, cp->instance, flags,
+ 				   0, NULL, 0, NULL, timeout, duration,
+ 				   tx_power, min_interval, max_interval);
+ 
+ 	if (err < 0) {
+ 		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,
+ 				      MGMT_STATUS_FAILED);
+ 		goto unlock;
+ 	}
+ 
+ 	hdev->cur_adv_instance = cp->instance;
+ 	/* Submit request for advertising params if ext adv available */
+ 	if (ext_adv_capable(hdev)) {
+ 		hci_req_init(&req, hdev);
+ 		adv_instance = hci_find_adv_instance(hdev, cp->instance);
+ 
+ 		/* Updating parameters of an active instance will return a
+ 		 * Command Disallowed error, so we must first disable the
+ 		 * instance if it is active.
+ 		 */
+ 		if (!adv_instance->pending)
+ 			__hci_req_disable_ext_adv_instance(&req, cp->instance);
+ 
+ 		__hci_req_setup_ext_adv_instance(&req, cp->instance);
+ 
+ 		err = hci_req_run(&req, add_ext_adv_params_complete);
+ 
+ 		if (!err)
+ 			cmd = mgmt_pending_add(sk, MGMT_OP_ADD_EXT_ADV_PARAMS,
+ 					       hdev, data, data_len);
+ 		if (!cmd) {
+ 			err = -ENOMEM;
+ 			hci_remove_adv_instance(hdev, cp->instance);
+ 			goto unlock;
+ 		}
+ 
+ 	} else {
+ 		rp.instance = cp->instance;
+ 		rp.tx_power = HCI_ADV_TX_POWER_NO_PREFERENCE;
+ 		rp.max_adv_data_len = tlv_data_max_len(hdev, flags, true);
+ 		rp.max_scan_rsp_len = tlv_data_max_len(hdev, flags, false);
+ 		err = mgmt_cmd_complete(sk, hdev->id,
+ 					MGMT_OP_ADD_EXT_ADV_PARAMS,
+ 					MGMT_STATUS_SUCCESS, &rp, sizeof(rp));
+ 	}
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ 
+ 	return err;
+ }
+ 
+ static int add_ext_adv_data(struct sock *sk, struct hci_dev *hdev, void *data,
+ 			    u16 data_len)
+ {
+ 	struct mgmt_cp_add_ext_adv_data *cp = data;
+ 	struct mgmt_rp_add_ext_adv_data rp;
+ 	u8 schedule_instance = 0;
+ 	struct adv_info *next_instance;
+ 	struct adv_info *adv_instance;
+ 	int err = 0;
+ 	struct mgmt_pending_cmd *cmd;
+ 	struct hci_request req;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	adv_instance = hci_find_adv_instance(hdev, cp->instance);
+ 
+ 	if (!adv_instance) {
+ 		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_DATA,
+ 				      MGMT_STATUS_INVALID_PARAMS);
+ 		goto unlock;
+ 	}
+ 
+ 	/* In new interface, we require that we are powered to register */
+ 	if (!hdev_is_powered(hdev)) {
+ 		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_DATA,
+ 				      MGMT_STATUS_REJECTED);
+ 		goto clear_new_instance;
+ 	}
+ 
+ 	if (adv_busy(hdev)) {
+ 		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_DATA,
+ 				      MGMT_STATUS_BUSY);
+ 		goto clear_new_instance;
+ 	}
+ 
+ 	/* Validate new data */
+ 	if (!tlv_data_is_valid(hdev, adv_instance->flags, cp->data,
+ 			       cp->adv_data_len, true) ||
+ 	    !tlv_data_is_valid(hdev, adv_instance->flags, cp->data +
+ 			       cp->adv_data_len, cp->scan_rsp_len, false)) {
+ 		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_DATA,
+ 				      MGMT_STATUS_INVALID_PARAMS);
+ 		goto clear_new_instance;
+ 	}
+ 
+ 	/* Set the data in the advertising instance */
+ 	hci_set_adv_instance_data(hdev, cp->instance, cp->adv_data_len,
+ 				  cp->data, cp->scan_rsp_len,
+ 				  cp->data + cp->adv_data_len);
+ 
+ 	/* We're good to go, update advertising data, parameters, and start
+ 	 * advertising.
+ 	 */
+ 
+ 	hci_req_init(&req, hdev);
+ 
+ 	hci_req_add(&req, HCI_OP_READ_LOCAL_NAME, 0, NULL);
+ 
+ 	if (ext_adv_capable(hdev)) {
+ 		__hci_req_update_adv_data(&req, cp->instance);
+ 		__hci_req_update_scan_rsp_data(&req, cp->instance);
+ 		__hci_req_enable_ext_advertising(&req, cp->instance);
+ 
+ 	} else {
+ 		/* If using software rotation, determine next instance to use */
+ 
+ 		if (hdev->cur_adv_instance == cp->instance) {
+ 			/* If the currently advertised instance is being changed
+ 			 * then cancel the current advertising and schedule the
+ 			 * next instance. If there is only one instance then the
+ 			 * overridden advertising data will be visible right
+ 			 * away
+ 			 */
+ 			cancel_adv_timeout(hdev);
+ 
+ 			next_instance = hci_get_next_instance(hdev,
+ 							      cp->instance);
+ 			if (next_instance)
+ 				schedule_instance = next_instance->instance;
+ 		} else if (!hdev->adv_instance_timeout) {
+ 			/* Immediately advertise the new instance if no other
+ 			 * instance is currently being advertised.
+ 			 */
+ 			schedule_instance = cp->instance;
+ 		}
+ 
+ 		/* If the HCI_ADVERTISING flag is set or there is no instance to
+ 		 * be advertised then we have no HCI communication to make.
+ 		 * Simply return.
+ 		 */
+ 		if (hci_dev_test_flag(hdev, HCI_ADVERTISING) ||
+ 		    !schedule_instance) {
+ 			if (adv_instance->pending) {
+ 				mgmt_advertising_added(sk, hdev, cp->instance);
+ 				adv_instance->pending = false;
+ 			}
+ 			rp.instance = cp->instance;
+ 			err = mgmt_cmd_complete(sk, hdev->id,
+ 						MGMT_OP_ADD_EXT_ADV_DATA,
+ 						MGMT_STATUS_SUCCESS, &rp,
+ 						sizeof(rp));
+ 			goto unlock;
+ 		}
+ 
+ 		err = __hci_req_schedule_adv_instance(&req, schedule_instance,
+ 						      true);
+ 	}
+ 
+ 	cmd = mgmt_pending_add(sk, MGMT_OP_ADD_EXT_ADV_DATA, hdev, data,
+ 			       data_len);
+ 	if (!cmd) {
+ 		err = -ENOMEM;
+ 		goto clear_new_instance;
+ 	}
+ 
+ 	if (!err)
+ 		err = hci_req_run(&req, add_advertising_complete);
+ 
+ 	if (err < 0) {
+ 		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_DATA,
+ 				      MGMT_STATUS_FAILED);
+ 		mgmt_pending_remove(cmd);
+ 		goto clear_new_instance;
+ 	}
+ 
+ 	/* We were successful in updating data, so trigger advertising_added
+ 	 * event if this is an instance that wasn't previously advertising. If
+ 	 * a failure occurs in the requests we initiated, we will remove the
+ 	 * instance again in add_advertising_complete
+ 	 */
+ 	if (adv_instance->pending)
+ 		mgmt_advertising_added(sk, hdev, cp->instance);
+ 
+ 	goto unlock;
+ 
+ clear_new_instance:
+ 	hci_remove_adv_instance(hdev, cp->instance);
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 9bf9f4b6301f (Bluetooth: Use intervals and tx power from mgmt cmds)
  static void remove_advertising_complete(struct hci_dev *hdev, u8 status,
  					u16 opcode)
  {
* Unmerged path include/net/bluetooth/hci_core.h
diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index 0693dacbf6e3..c83865b46338 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -2941,7 +2941,8 @@ static void adv_instance_rpa_expired(struct work_struct *work)
 int hci_add_adv_instance(struct hci_dev *hdev, u8 instance, u32 flags,
 			 u16 adv_data_len, u8 *adv_data,
 			 u16 scan_rsp_len, u8 *scan_rsp_data,
-			 u16 timeout, u16 duration)
+			 u16 timeout, u16 duration, s8 tx_power,
+			 u32 min_interval, u32 max_interval)
 {
 	struct adv_info *adv_instance;
 
@@ -2969,6 +2970,9 @@ int hci_add_adv_instance(struct hci_dev *hdev, u8 instance, u32 flags,
 	adv_instance->flags = flags;
 	adv_instance->adv_data_len = adv_data_len;
 	adv_instance->scan_rsp_len = scan_rsp_len;
+	adv_instance->min_interval = min_interval;
+	adv_instance->max_interval = max_interval;
+	adv_instance->tx_power = tx_power;
 
 	if (adv_data_len)
 		memcpy(adv_instance->adv_data, adv_data, adv_data_len);
@@ -2985,8 +2989,6 @@ int hci_add_adv_instance(struct hci_dev *hdev, u8 instance, u32 flags,
 	else
 		adv_instance->duration = duration;
 
-	adv_instance->tx_power = HCI_TX_POWER_INVALID;
-
 	INIT_DELAYED_WORK(&adv_instance->rpa_expired_cb,
 			  adv_instance_rpa_expired);
 
diff --git a/net/bluetooth/hci_request.c b/net/bluetooth/hci_request.c
index 533127737517..23f39b9d1ef6 100644
--- a/net/bluetooth/hci_request.c
+++ b/net/bluetooth/hci_request.c
@@ -1419,6 +1419,7 @@ static bool is_advertising_allowed(struct hci_dev *hdev, bool connectable)
 void __hci_req_enable_advertising(struct hci_request *req)
 {
 	struct hci_dev *hdev = req->hdev;
+	struct adv_info *adv_instance;
 	struct hci_cp_le_set_adv_param cp;
 	u8 own_addr_type, enable = 0x01;
 	bool connectable;
@@ -1426,6 +1427,7 @@ void __hci_req_enable_advertising(struct hci_request *req)
 	u32 flags;
 
 	flags = get_adv_instance_flags(hdev, hdev->cur_adv_instance);
+	adv_instance = hci_find_adv_instance(hdev, hdev->cur_adv_instance);
 
 	/* If the "connectable" instance flag was not set, then choose between
 	 * ADV_IND and ADV_NONCONN_IND based on the global connectable setting.
@@ -1457,11 +1459,16 @@ void __hci_req_enable_advertising(struct hci_request *req)
 
 	memset(&cp, 0, sizeof(cp));
 
-	if (connectable) {
-		cp.type = LE_ADV_IND;
-
+	if (adv_instance) {
+		adv_min_interval = adv_instance->min_interval;
+		adv_max_interval = adv_instance->max_interval;
+	} else {
 		adv_min_interval = hdev->le_adv_min_interval;
 		adv_max_interval = hdev->le_adv_max_interval;
+	}
+
+	if (connectable) {
+		cp.type = LE_ADV_IND;
 	} else {
 		if (adv_cur_instance_is_scannable(hdev))
 			cp.type = LE_ADV_SCAN_IND;
@@ -1472,9 +1479,6 @@ void __hci_req_enable_advertising(struct hci_request *req)
 		    hci_dev_test_flag(hdev, HCI_LIMITED_DISCOVERABLE)) {
 			adv_min_interval = DISCOV_LE_FAST_ADV_INT_MIN;
 			adv_max_interval = DISCOV_LE_FAST_ADV_INT_MAX;
-		} else {
-			adv_min_interval = hdev->le_adv_min_interval;
-			adv_max_interval = hdev->le_adv_max_interval;
 		}
 	}
 
@@ -1994,9 +1998,15 @@ int __hci_req_setup_ext_adv_instance(struct hci_request *req, u8 instance)
 
 	memset(&cp, 0, sizeof(cp));
 
-	/* In ext adv set param interval is 3 octets */
-	hci_cpu_to_le24(hdev->le_adv_min_interval, cp.min_interval);
-	hci_cpu_to_le24(hdev->le_adv_max_interval, cp.max_interval);
+	if (adv_instance) {
+		hci_cpu_to_le24(adv_instance->min_interval, cp.min_interval);
+		hci_cpu_to_le24(adv_instance->max_interval, cp.max_interval);
+		cp.tx_power = adv_instance->tx_power;
+	} else {
+		hci_cpu_to_le24(hdev->le_adv_min_interval, cp.min_interval);
+		hci_cpu_to_le24(hdev->le_adv_max_interval, cp.max_interval);
+		cp.tx_power = HCI_ADV_TX_POWER_NO_PREFERENCE;
+	}
 
 	secondary_adv = (flags & MGMT_ADV_FLAG_SEC_MASK);
 
@@ -2019,7 +2029,6 @@ int __hci_req_setup_ext_adv_instance(struct hci_request *req, u8 instance)
 
 	cp.own_addr_type = own_addr_type;
 	cp.channel_map = hdev->le_adv_channel_map;
-	cp.tx_power = 127;
 	cp.handle = instance;
 
 	if (flags & MGMT_ADV_FLAG_SEC_2M) {
* Unmerged path net/bluetooth/mgmt.c
