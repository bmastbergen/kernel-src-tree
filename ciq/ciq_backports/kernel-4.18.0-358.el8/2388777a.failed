exec: Rename flush_old_exec begin_new_exec

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 2388777a0a5957a10b3d78677216530a9b3bd09f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/2388777a.failed

There is and has been for a very long time been a lot more going on in
flush_old_exec than just flushing the old state.  After the movement
of code from setup_new_exec there is a whole lot more going on than
just flushing the old executables state.

Rename flush_old_exec to begin_new_exec to more accurately reflect
what this function does.

	Reviewed-by: Kees Cook <keescook@chromium.org>
	Reviewed-by: Greg Ungerer <gerg@linux-m68k.org>
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit 2388777a0a5957a10b3d78677216530a9b3bd09f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/trace/ftrace.rst
diff --cc Documentation/trace/ftrace.rst
index af5b7e9b05a0,430a16283103..000000000000
--- a/Documentation/trace/ftrace.rst
+++ b/Documentation/trace/ftrace.rst
@@@ -1396,6 -1479,58 +1396,61 @@@ enabling function tracing, we incur an 
  overhead may extend the latency times. But nevertheless, this
  trace has provided some very helpful debugging information.
  
++<<<<<<< HEAD
++=======
+ If we prefer function graph output instead of function, we can set
+ display-graph option::
+ 
+  with echo 1 > options/display-graph
+ 
+   # tracer: irqsoff
+   #
+   # irqsoff latency trace v1.1.5 on 4.20.0-rc6+
+   # --------------------------------------------------------------------
+   # latency: 3751 us, #274/274, CPU#0 | (M:desktop VP:0, KP:0, SP:0 HP:0 #P:4)
+   #    -----------------
+   #    | task: bash-1507 (uid:0 nice:0 policy:0 rt_prio:0)
+   #    -----------------
+   #  => started at: free_debug_processing
+   #  => ended at:   return_to_handler
+   #
+   #
+   #                                       _-----=> irqs-off
+   #                                      / _----=> need-resched
+   #                                     | / _---=> hardirq/softirq
+   #                                     || / _--=> preempt-depth
+   #                                     ||| /
+   #   REL TIME      CPU  TASK/PID       ||||     DURATION                  FUNCTION CALLS
+   #      |          |     |    |        ||||      |   |                     |   |   |   |
+           0 us |   0)   bash-1507    |  d... |   0.000 us    |  _raw_spin_lock_irqsave();
+           0 us |   0)   bash-1507    |  d..1 |   0.378 us    |    do_raw_spin_trylock();
+           1 us |   0)   bash-1507    |  d..2 |               |    set_track() {
+           2 us |   0)   bash-1507    |  d..2 |               |      save_stack_trace() {
+           2 us |   0)   bash-1507    |  d..2 |               |        __save_stack_trace() {
+           3 us |   0)   bash-1507    |  d..2 |               |          __unwind_start() {
+           3 us |   0)   bash-1507    |  d..2 |               |            get_stack_info() {
+           3 us |   0)   bash-1507    |  d..2 |   0.351 us    |              in_task_stack();
+           4 us |   0)   bash-1507    |  d..2 |   1.107 us    |            }
+   [...]
+        3750 us |   0)   bash-1507    |  d..1 |   0.516 us    |      do_raw_spin_unlock();
+        3750 us |   0)   bash-1507    |  d..1 |   0.000 us    |  _raw_spin_unlock_irqrestore();
+        3764 us |   0)   bash-1507    |  d..1 |   0.000 us    |  tracer_hardirqs_on();
+       bash-1507    0d..1 3792us : <stack trace>
+    => free_debug_processing
+    => __slab_free
+    => kmem_cache_free
+    => vm_area_free
+    => remove_vma
+    => exit_mmap
+    => mmput
+    => begin_new_exec
+    => load_elf_binary
+    => search_binary_handler
+    => __do_execve_file.isra.32
+    => __x64_sys_execve
+    => do_syscall_64
+    => entry_SYSCALL_64_after_hwframe
++>>>>>>> 2388777a0a59 (exec: Rename flush_old_exec begin_new_exec)
  
  preemptoff
  ----------
* Unmerged path Documentation/trace/ftrace.rst
diff --git a/arch/x86/ia32/ia32_aout.c b/arch/x86/ia32/ia32_aout.c
index 3a18b3d03784..af739f025dd6 100644
--- a/arch/x86/ia32/ia32_aout.c
+++ b/arch/x86/ia32/ia32_aout.c
@@ -287,7 +287,7 @@ static int load_aout_binary(struct linux_binprm *bprm)
 		return -ENOMEM;
 
 	/* Flush all traces of the currently running executable */
-	retval = flush_old_exec(bprm);
+	retval = begin_new_exec(bprm);
 	if (retval)
 		return retval;
 
diff --git a/fs/binfmt_aout.c b/fs/binfmt_aout.c
index af09b55d5ac5..da775c259865 100644
--- a/fs/binfmt_aout.c
+++ b/fs/binfmt_aout.c
@@ -233,7 +233,7 @@ static int load_aout_binary(struct linux_binprm * bprm)
 		return -ENOMEM;
 
 	/* Flush all traces of the currently running executable */
-	retval = flush_old_exec(bprm);
+	retval = begin_new_exec(bprm);
 	if (retval)
 		return retval;
 
diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index c9fdad31fb37..ee3ec48dbcdb 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -866,7 +866,7 @@ static int load_elf_binary(struct linux_binprm *bprm)
 		goto out_free_dentry;
 
 	/* Flush all traces of the currently running executable */
-	retval = flush_old_exec(bprm);
+	retval = begin_new_exec(bprm);
 	if (retval)
 		goto out_free_dentry;
 
diff --git a/fs/binfmt_elf_fdpic.c b/fs/binfmt_elf_fdpic.c
index 60896c16f103..88abdc1429dd 100644
--- a/fs/binfmt_elf_fdpic.c
+++ b/fs/binfmt_elf_fdpic.c
@@ -342,7 +342,7 @@ static int load_elf_fdpic_binary(struct linux_binprm *bprm)
 		interp_params.flags |= ELF_FDPIC_FLAG_CONSTDISP;
 
 	/* flush all traces of the currently running executable */
-	retval = flush_old_exec(bprm);
+	retval = begin_new_exec(bprm);
 	if (retval)
 		goto error;
 
diff --git a/fs/binfmt_flat.c b/fs/binfmt_flat.c
index 16954cc1b2d2..97cd8ddc971f 100644
--- a/fs/binfmt_flat.c
+++ b/fs/binfmt_flat.c
@@ -510,7 +510,7 @@ static int load_flat_file(struct linux_binprm *bprm,
 
 	/* Flush all traces of the currently running executable */
 	if (id == 0) {
-		ret = flush_old_exec(bprm);
+		ret = begin_new_exec(bprm);
 		if (ret)
 			goto err;
 
diff --git a/fs/exec.c b/fs/exec.c
index 671dee5c3348..5758e3653620 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1264,7 +1264,7 @@ void __set_task_comm(struct task_struct *tsk, const char *buf, bool exec)
  * signal (via de_thread() or coredump), or will have SEGV raised
  * (after exec_mmap()) by search_binary_handlers (see below).
  */
-int flush_old_exec(struct linux_binprm * bprm)
+int begin_new_exec(struct linux_binprm * bprm)
 {
 	struct task_struct *me = current;
 	int retval;
@@ -1330,7 +1330,7 @@ int flush_old_exec(struct linux_binprm * bprm)
 out:
 	return retval;
 }
-EXPORT_SYMBOL(flush_old_exec);
+EXPORT_SYMBOL(begin_new_exec);
 
 void would_dump(struct linux_binprm *bprm, struct file *file)
 {
diff --git a/include/linux/binfmts.h b/include/linux/binfmts.h
index 8c12228326b0..840a80fd98cc 100644
--- a/include/linux/binfmts.h
+++ b/include/linux/binfmts.h
@@ -119,7 +119,7 @@ extern void unregister_binfmt(struct linux_binfmt *);
 extern int prepare_binprm(struct linux_binprm *);
 extern int __must_check remove_arg_zero(struct linux_binprm *);
 extern int search_binary_handler(struct linux_binprm *);
-extern int flush_old_exec(struct linux_binprm * bprm);
+extern int begin_new_exec(struct linux_binprm * bprm);
 extern void setup_new_exec(struct linux_binprm * bprm);
 extern void finalize_exec(struct linux_binprm *bprm);
 extern void would_dump(struct linux_binprm *, struct file *);
