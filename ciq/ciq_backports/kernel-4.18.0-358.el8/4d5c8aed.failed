mm, memcg: introduce mem_cgroup_kmem_disabled()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Roman Gushchin <guro@fb.com>
commit 4d5c8aedc8aa6a1f5d1b06eb4f5517dc60dd9440
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/4d5c8aed.failed

Introduce a new mem_cgroup_kmem_disabled() helper, similar to
mem_cgroup_disabled(), to check whether the kernel memory accounting
is off. A user could disable it using a boot option to eliminate
some associated costs.

The helper can be used outside of memcontrol.c to dynamically disable
the kmem-related code. The returned value is stable after the kernel
initialization is finished.

	Signed-off-by: Roman Gushchin <guro@fb.com>
	Signed-off-by: Dennis Zhou <dennis@kernel.org>
(cherry picked from commit 4d5c8aedc8aa6a1f5d1b06eb4f5517dc60dd9440)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index a59fd41a5b6a,1fa9b00ec71d..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -263,8 -255,15 +263,20 @@@ struct cgroup_subsys_state *vmpressure_
  #ifdef CONFIG_MEMCG_KMEM
  extern spinlock_t css_set_lock;
  
++<<<<<<< HEAD
 +static void obj_cgroup_uncharge_pages(struct obj_cgroup *objcg,
 +				      unsigned int nr_pages);
++=======
+ bool mem_cgroup_kmem_disabled(void)
+ {
+ 	return cgroup_memory_nokmem;
+ }
+ 
+ static int __memcg_kmem_charge(struct mem_cgroup *memcg, gfp_t gfp,
+ 			       unsigned int nr_pages);
+ static void __memcg_kmem_uncharge(struct mem_cgroup *memcg,
+ 				  unsigned int nr_pages);
++>>>>>>> 4d5c8aedc8aa (mm, memcg: introduce mem_cgroup_kmem_disabled())
  
  static void obj_cgroup_release(struct percpu_ref *ref)
  {
diff --git a/include/linux/memcontrol.h b/include/linux/memcontrol.h
index f3b4c2738734..da025ebc7052 100644
--- a/include/linux/memcontrol.h
+++ b/include/linux/memcontrol.h
@@ -1676,6 +1676,7 @@ static inline void set_shrinker_bit(struct mem_cgroup *memcg,
 #endif
 
 #ifdef CONFIG_MEMCG_KMEM
+bool mem_cgroup_kmem_disabled(void);
 int __memcg_kmem_charge_page(struct page *page, gfp_t gfp, int order);
 void __memcg_kmem_uncharge_page(struct page *page, int order);
 
@@ -1729,6 +1730,10 @@ static inline int memcg_cache_id(struct mem_cgroup *memcg)
 struct mem_cgroup *mem_cgroup_from_obj(void *p);
 
 #else
+static inline bool mem_cgroup_kmem_disabled(void)
+{
+	return true;
+}
 
 static inline int memcg_kmem_charge_page(struct page *page, gfp_t gfp,
 					 int order)
* Unmerged path mm/memcontrol.c
