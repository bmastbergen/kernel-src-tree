lib/scatterlist: Fix wrong update of orig_nents

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Maor Gottlieb <maorg@nvidia.com>
commit 3e302dbc6774a27edaea39a1d5107f0c12e35cf2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/3e302dbc.failed

orig_nents should represent the number of entries with pages,
but __sg_alloc_table_from_pages sets orig_nents as the number of
total entries in the table. This is wrong when the API is used for
dynamic allocation where not all the table entries are mapped with
pages. It wasn't observed until now, since RDMA umem who uses this
API in the dynamic form doesn't use orig_nents implicit or explicit
by the scatterlist APIs.

Fix it by changing the append API to track the SG append table
state and have an API to free the append table according to the
total number of entries in the table.
Now all APIs set orig_nents as number of enries with pages.

Fixes: 07da1223ec93 ("lib/scatterlist: Add support in dynamic allocation of SG table from pages")
Link: https://lore.kernel.org/r/20210824142531.3877007-3-maorg@nvidia.com
	Signed-off-by: Maor Gottlieb <maorg@nvidia.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 3e302dbc6774a27edaea39a1d5107f0c12e35cf2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/umem.c
#	include/linux/scatterlist.h
#	lib/scatterlist.c
#	tools/testing/scatterlist/main.c
diff --cc drivers/infiniband/core/umem.c
index e642fd4f1880,42481e7a72e8..000000000000
--- a/drivers/infiniband/core/umem.c
+++ b/drivers/infiniband/core/umem.c
@@@ -53,12 -55,11 +53,12 @@@ static void __ib_umem_release(struct ib
  		ib_dma_unmap_sg(dev, umem->sg_head.sgl, umem->sg_nents,
  				DMA_BIDIRECTIONAL);
  
 -	for_each_sg(umem->sg_head.sgl, sg, umem->sg_nents, i)
 -		unpin_user_page_range_dirty_lock(sg_page(sg),
 -			DIV_ROUND_UP(sg->length, PAGE_SIZE), make_dirty);
 +	for_each_sg_page(umem->sg_head.sgl, &sg_iter, umem->sg_nents, 0) {
 +		page = sg_page_iter_page(&sg_iter);
 +		unpin_user_pages_dirty_lock(&page, 1, umem->writable && dirty);
 +	}
  
- 	sg_free_table(&umem->sg_head);
+ 	sg_free_append_table(&umem->sgt_append);
  }
  
  /**
@@@ -159,18 -155,9 +159,17 @@@ struct ib_umem *ib_umem_get(struct ib_u
  	unsigned long dma_attr = 0;
  	struct mm_struct *mm;
  	unsigned long npages;
- 	int ret;
- 	struct scatterlist *sg = NULL;
+ 	int pinned, ret;
  	unsigned int gup_flags = FOLL_WRITE;
  
 +	if (!udata)
 +		return ERR_PTR(-EIO);
 +
 +	context = container_of(udata, struct uverbs_attr_bundle, driver_udata)
 +			  ->context;
 +	if (!context)
 +		return ERR_PTR(-EIO);
 +
  	/*
  	 * If the combination of the addr and size requested for this memory
  	 * region causes an integer overflow, return error.
@@@ -233,19 -220,22 +232,35 @@@
  						PAGE_SIZE /
  						sizeof(struct page *)),
  					  gup_flags | FOLL_LONGTERM, page_list);
- 		if (ret < 0)
+ 		if (pinned < 0) {
+ 			ret = pinned;
  			goto umem_release;
+ 		}
  
++<<<<<<< HEAD
 +		cur_base += ret * PAGE_SIZE;
 +		npages -= ret;
 +		sg = __sg_alloc_table_from_pages(&umem->sg_head, page_list, ret,
 +				0, ret << PAGE_SHIFT,
 +				ib_dma_max_seg_size(context->device), sg, npages,
 +				GFP_KERNEL);
 +		umem->sg_nents = umem->sg_head.nents;
 +		if (IS_ERR(sg)) {
 +			unpin_user_pages_dirty_lock(page_list, ret, 0);
 +			ret = PTR_ERR(sg);
++=======
+ 		cur_base += pinned * PAGE_SIZE;
+ 		npages -= pinned;
+ 		ret = sg_alloc_append_table_from_pages(
+ 			&umem->sgt_append, page_list, pinned, 0,
+ 			pinned << PAGE_SHIFT, ib_dma_max_seg_size(device),
+ 			npages, GFP_KERNEL);
+ 		umem->sg_nents = umem->sgt_append.sgt.nents;
+ 		if (ret) {
+ 			memcpy(&umem->sg_head.sgl, &umem->sgt_append.sgt,
+ 			       sizeof(umem->sgt_append.sgt));
+ 			unpin_user_pages_dirty_lock(page_list, pinned, 0);
++>>>>>>> 3e302dbc6774 (lib/scatterlist: Fix wrong update of orig_nents)
  			goto umem_release;
  		}
  	}
diff --cc include/linux/scatterlist.h
index cd9011a4b9b1,266754a55327..000000000000
--- a/include/linux/scatterlist.h
+++ b/include/linux/scatterlist.h
@@@ -291,14 -292,45 +298,56 @@@ void sg_free_append_table(struct sg_app
  int __sg_alloc_table(struct sg_table *, unsigned int, unsigned int,
  		     struct scatterlist *, unsigned int, gfp_t, sg_alloc_fn *);
  int sg_alloc_table(struct sg_table *, unsigned int, gfp_t);
++<<<<<<< HEAD
 +struct scatterlist *__sg_alloc_table_from_pages(struct sg_table *sgt,
 +		struct page **pages, unsigned int n_pages, unsigned int offset,
 +		unsigned long size, unsigned int max_segment,
 +		struct scatterlist *prv, unsigned int left_pages,
 +		gfp_t gfp_mask);
 +int sg_alloc_table_from_pages(struct sg_table *sgt, struct page **pages,
 +			      unsigned int n_pages, unsigned int offset,
 +			      unsigned long size, gfp_t gfp_mask);
++=======
+ int sg_alloc_append_table_from_pages(struct sg_append_table *sgt,
+ 				     struct page **pages, unsigned int n_pages,
+ 				     unsigned int offset, unsigned long size,
+ 				     unsigned int max_segment,
+ 				     unsigned int left_pages, gfp_t gfp_mask);
+ int sg_alloc_table_from_pages_segment(struct sg_table *sgt, struct page **pages,
+ 				      unsigned int n_pages, unsigned int offset,
+ 				      unsigned long size,
+ 				      unsigned int max_segment, gfp_t gfp_mask);
+ 
+ /**
+  * sg_alloc_table_from_pages - Allocate and initialize an sg table from
+  *			       an array of pages
+  * @sgt:	 The sg table header to use
+  * @pages:	 Pointer to an array of page pointers
+  * @n_pages:	 Number of pages in the pages array
+  * @offset:      Offset from start of the first page to the start of a buffer
+  * @size:        Number of valid bytes in the buffer (after offset)
+  * @gfp_mask:	 GFP allocation mask
+  *
+  *  Description:
+  *    Allocate and initialize an sg table from a list of pages. Contiguous
+  *    ranges of the pages are squashed into a single scatterlist node. A user
+  *    may provide an offset at a start and a size of valid data in a buffer
+  *    specified by the page array. The returned sg table is released by
+  *    sg_free_table.
+  *
+  * Returns:
+  *   0 on success, negative error on failure
+  */
+ static inline int sg_alloc_table_from_pages(struct sg_table *sgt,
+ 					    struct page **pages,
+ 					    unsigned int n_pages,
+ 					    unsigned int offset,
+ 					    unsigned long size, gfp_t gfp_mask)
+ {
+ 	return sg_alloc_table_from_pages_segment(sgt, pages, n_pages, offset,
+ 						 size, UINT_MAX, gfp_mask);
+ }
++>>>>>>> 3e302dbc6774 (lib/scatterlist: Fix wrong update of orig_nents)
  
  #ifdef CONFIG_SGL_ALLOC
  struct scatterlist *sgl_alloc_order(unsigned long long length,
diff --cc lib/scatterlist.c
index 484374d86451,f4b1ff78ab2d..000000000000
--- a/lib/scatterlist.c
+++ b/lib/scatterlist.c
@@@ -399,11 -411,11 +413,19 @@@ static struct scatterlist *get_next_sg(
  }
  
  /**
++<<<<<<< HEAD
 + * __sg_alloc_table_from_pages - Allocate and initialize an sg table from
 + *			         an array of pages
 + * @sgt:	 The sg table header to use
 + * @pages:	 Pointer to an array of page pointers
 + * @n_pages:	 Number of pages in the pages array
++=======
+  * sg_alloc_append_table_from_pages - Allocate and initialize an append sg
+  *                                    table from an array of pages
+  * @sgt_append:  The sg append table to use
+  * @pages:       Pointer to an array of page pointers
+  * @n_pages:     Number of pages in the pages array
++>>>>>>> 3e302dbc6774 (lib/scatterlist: Fix wrong update of orig_nents)
   * @offset:      Offset from start of the first page to the start of a buffer
   * @size:        Number of valid bytes in the buffer (after offset)
   * @max_segment: Maximum size of a scatterlist element in bytes
@@@ -425,13 -435,14 +445,18 @@@
   *
   * Notes:
   *   If this function returns non-0 (eg failure), the caller must call
-  *   sg_free_table() to cleanup any leftover allocations.
+  *   sg_free_append_table() to cleanup any leftover allocations.
+  *
+  *   In the fist call, sgt_append must by initialized.
   */
++<<<<<<< HEAD
 +struct scatterlist *__sg_alloc_table_from_pages(struct sg_table *sgt,
++=======
+ int sg_alloc_append_table_from_pages(struct sg_append_table *sgt_append,
++>>>>>>> 3e302dbc6774 (lib/scatterlist: Fix wrong update of orig_nents)
  		struct page **pages, unsigned int n_pages, unsigned int offset,
  		unsigned long size, unsigned int max_segment,
- 		struct scatterlist *prv, unsigned int left_pages,
- 		gfp_t gfp_mask)
+ 		unsigned int left_pages, gfp_t gfp_mask)
  {
  	unsigned int chunks, cur_page, seg_len, i, prv_len = 0;
  	unsigned int added_nents = 0;
@@@ -520,13 -535,14 +549,13 @@@
  out:
  	if (!left_pages)
  		sg_mark_end(s);
- 	return s;
+ 	return 0;
  }
 -EXPORT_SYMBOL(sg_alloc_append_table_from_pages);
 +EXPORT_SYMBOL(__sg_alloc_table_from_pages);
  
  /**
 - * sg_alloc_table_from_pages_segment - Allocate and initialize an sg table from
 - *                                     an array of pages and given maximum
 - *                                     segment.
 + * sg_alloc_table_from_pages - Allocate and initialize an sg table from
 + *			       an array of pages
   * @sgt:	 The sg table header to use
   * @pages:	 Pointer to an array of page pointers
   * @n_pages:	 Number of pages in the pages array
@@@ -536,22 -553,34 +565,37 @@@
   *
   *  Description:
   *    Allocate and initialize an sg table from a list of pages. Contiguous
 - *    ranges of the pages are squashed into a single scatterlist node up to the
 - *    maximum size specified in @max_segment. A user may provide an offset at a
 - *    start and a size of valid data in a buffer specified by the page array.
 + *    ranges of the pages are squashed into a single scatterlist node. A user
 + *    may provide an offset at a start and a size of valid data in a buffer
 + *    specified by the page array. The returned sg table is released by
 + *    sg_free_table.
   *
 - *    The returned sg table is released by sg_free_table.
 - *
 - *  Returns:
 + * Returns:
   *   0 on success, negative error on failure
   */
 -int sg_alloc_table_from_pages_segment(struct sg_table *sgt, struct page **pages,
 -				unsigned int n_pages, unsigned int offset,
 -				unsigned long size, unsigned int max_segment,
 -				gfp_t gfp_mask)
 -{
 +int sg_alloc_table_from_pages(struct sg_table *sgt, struct page **pages,
 +			      unsigned int n_pages, unsigned int offset,
 +			      unsigned long size, gfp_t gfp_mask)
 +{
++<<<<<<< HEAD
 +	return PTR_ERR_OR_ZERO(__sg_alloc_table_from_pages(sgt, pages, n_pages,
 +			offset, size, UINT_MAX, NULL, 0, gfp_mask));
++=======
+ 	struct sg_append_table append = {};
+ 	int err;
+ 
+ 	err = sg_alloc_append_table_from_pages(&append, pages, n_pages, offset,
+ 					       size, max_segment, 0, gfp_mask);
+ 	if (err) {
+ 		sg_free_append_table(&append);
+ 		return err;
+ 	}
+ 	memcpy(sgt, &append.sgt, sizeof(*sgt));
+ 	WARN_ON(append.total_nents != sgt->orig_nents);
+ 	return 0;
++>>>>>>> 3e302dbc6774 (lib/scatterlist: Fix wrong update of orig_nents)
  }
 -EXPORT_SYMBOL(sg_alloc_table_from_pages_segment);
 +EXPORT_SYMBOL(sg_alloc_table_from_pages);
  
  #ifdef CONFIG_SGL_ALLOC
  
diff --cc tools/testing/scatterlist/main.c
index 2d27e47bbf2f,08465a701cd5..000000000000
--- a/tools/testing/scatterlist/main.c
+++ b/tools/testing/scatterlist/main.c
@@@ -86,32 -85,46 +86,66 @@@ int main(void
  
  	for (i = 0, test = tests; test->expected_segments; test++, i++) {
  		int left_pages = test->pfn_app ? test->num_pages : 0;
+ 		struct sg_append_table append = {};
  		struct page *pages[MAX_PAGES];
++<<<<<<< HEAD
 +		struct sg_table st;
 +		struct scatterlist *sg;
 +
 +		set_pages(pages, test->pfn, test->num_pages);
 +
 +		sg = __sg_alloc_table_from_pages(&st, pages, test->num_pages, 0,
 +				test->size, test->max_seg, NULL, left_pages, GFP_KERNEL);
 +		assert(PTR_ERR_OR_ZERO(sg) == test->alloc_ret);
++=======
+ 		int ret;
+ 
+ 		set_pages(pages, test->pfn, test->num_pages);
+ 
+ 		if (test->pfn_app)
+ 			ret = sg_alloc_append_table_from_pages(
+ 				&append, pages, test->num_pages, 0, test->size,
+ 				test->max_seg, left_pages, GFP_KERNEL);
+ 		else
+ 			ret = sg_alloc_table_from_pages_segment(
+ 				&append.sgt, pages, test->num_pages, 0,
+ 				test->size, test->max_seg, GFP_KERNEL);
+ 
+ 		assert(ret == test->alloc_ret);
++>>>>>>> 3e302dbc6774 (lib/scatterlist: Fix wrong update of orig_nents)
  
  		if (test->alloc_ret)
  			continue;
  
  		if (test->pfn_app) {
  			set_pages(pages, test->pfn_app, test->num_pages);
++<<<<<<< HEAD
 +			sg = __sg_alloc_table_from_pages(&st, pages, test->num_pages, 0,
 +					test->size, test->max_seg, sg, 0, GFP_KERNEL);
++=======
+ 			ret = sg_alloc_append_table_from_pages(
+ 				&append, pages, test->num_pages, 0, test->size,
+ 				test->max_seg, 0, GFP_KERNEL);
++>>>>>>> 3e302dbc6774 (lib/scatterlist: Fix wrong update of orig_nents)
  
- 			assert(PTR_ERR_OR_ZERO(sg) == test->alloc_ret);
+ 			assert(ret == test->alloc_ret);
  		}
  
- 		VALIDATE(st.nents == test->expected_segments, &st, test);
+ 		VALIDATE(append.sgt.nents == test->expected_segments,
+ 			 &append.sgt, test);
  		if (!test->pfn_app)
++<<<<<<< HEAD
 +			VALIDATE(st.orig_nents == test->expected_segments, &st, test);
- 
- 		sg_free_table(&st);
++=======
+ 			VALIDATE(append.sgt.orig_nents ==
+ 					 test->expected_segments,
+ 				 &append.sgt, test);
++>>>>>>> 3e302dbc6774 (lib/scatterlist: Fix wrong update of orig_nents)
+ 
+ 		if (test->pfn_app)
+ 			sg_free_append_table(&append);
+ 		else
+ 			sg_free_table(&append.sgt);
  	}
  
  	assert(i == (sizeof(tests) / sizeof(tests[0])) - 1);
* Unmerged path drivers/infiniband/core/umem.c
* Unmerged path include/linux/scatterlist.h
diff --git a/include/rdma/ib_umem.h b/include/rdma/ib_umem.h
index c6e799d5112d..c91dab15b984 100644
--- a/include/rdma/ib_umem.h
+++ b/include/rdma/ib_umem.h
@@ -23,6 +23,7 @@ struct ib_umem {
 	u32 writable : 1;
 	u32 is_odp : 1;
 	struct work_struct	work;
+	struct sg_append_table  sgt_append;
 	struct sg_table sg_head;
 	int             nmap;
 	unsigned int    sg_nents;
* Unmerged path lib/scatterlist.c
diff --git a/lib/sg_pool.c b/lib/sg_pool.c
index 5938b30c49f4..43c7bf47388f 100644
--- a/lib/sg_pool.c
+++ b/lib/sg_pool.c
@@ -89,7 +89,8 @@ void sg_free_table_chained(struct sg_table *table,
 	if (nents_first_chunk == 1)
 		nents_first_chunk = 0;
 
-	__sg_free_table(table, SG_CHUNK_SIZE, nents_first_chunk, sg_pool_free);
+	__sg_free_table(table, SG_CHUNK_SIZE, nents_first_chunk, sg_pool_free,
+			table->orig_nents);
 }
 EXPORT_SYMBOL_GPL(sg_free_table_chained);
 
* Unmerged path tools/testing/scatterlist/main.c
