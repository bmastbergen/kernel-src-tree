net: Remove redundant if statements

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Yajun Deng <yajun.deng@linux.dev>
commit 1160dfa178eb848327e9dec39960a735f4dc1685
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/1160dfa1.failed

The 'if (dev)' statement already move into dev_{put , hold}, so remove
redundant if statements.

	Signed-off-by: Yajun Deng <yajun.deng@linux.dev>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1160dfa178eb848327e9dec39960a735f4dc1685)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/batman-adv/multicast.c
#	net/ipv4/fib_semantics.c
#	net/ipv4/icmp.c
#	net/ipv6/route.c
#	net/netfilter/nf_flow_table_offload.c
#	net/packet/af_packet.c
diff --cc net/batman-adv/multicast.c
index 3df51c7f8004,0158f267c403..000000000000
--- a/net/batman-adv/multicast.c
+++ b/net/batman-adv/multicast.c
@@@ -213,6 -320,200 +212,203 @@@ static bool batadv_mcast_mla_is_duplica
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * batadv_mcast_mla_softif_get_ipv4() - get softif IPv4 multicast listeners
+  * @dev: the device to collect multicast addresses from
+  * @mcast_list: a list to put found addresses into
+  * @flags: flags indicating the new multicast state
+  *
+  * Collects multicast addresses of IPv4 multicast listeners residing
+  * on this kernel on the given soft interface, dev, in
+  * the given mcast_list. In general, multicast listeners provided by
+  * your multicast receiving applications run directly on this node.
+  *
+  * Return: -ENOMEM on memory allocation error or the number of
+  * items added to the mcast_list otherwise.
+  */
+ static int
+ batadv_mcast_mla_softif_get_ipv4(struct net_device *dev,
+ 				 struct hlist_head *mcast_list,
+ 				 struct batadv_mcast_mla_flags *flags)
+ {
+ 	struct batadv_hw_addr *new;
+ 	struct in_device *in_dev;
+ 	u8 mcast_addr[ETH_ALEN];
+ 	struct ip_mc_list *pmc;
+ 	int ret = 0;
+ 
+ 	if (flags->tvlv_flags & BATADV_MCAST_WANT_ALL_IPV4)
+ 		return 0;
+ 
+ 	rcu_read_lock();
+ 
+ 	in_dev = __in_dev_get_rcu(dev);
+ 	if (!in_dev) {
+ 		rcu_read_unlock();
+ 		return 0;
+ 	}
+ 
+ 	for (pmc = rcu_dereference(in_dev->mc_list); pmc;
+ 	     pmc = rcu_dereference(pmc->next_rcu)) {
+ 		if (flags->tvlv_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES &&
+ 		    ipv4_is_local_multicast(pmc->multiaddr))
+ 			continue;
+ 
+ 		if (!(flags->tvlv_flags & BATADV_MCAST_WANT_NO_RTR4) &&
+ 		    !ipv4_is_local_multicast(pmc->multiaddr))
+ 			continue;
+ 
+ 		ip_eth_mc_map(pmc->multiaddr, mcast_addr);
+ 
+ 		if (batadv_mcast_mla_is_duplicate(mcast_addr, mcast_list))
+ 			continue;
+ 
+ 		new = kmalloc(sizeof(*new), GFP_ATOMIC);
+ 		if (!new) {
+ 			ret = -ENOMEM;
+ 			break;
+ 		}
+ 
+ 		ether_addr_copy(new->addr, mcast_addr);
+ 		hlist_add_head(&new->list, mcast_list);
+ 		ret++;
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * batadv_mcast_mla_softif_get_ipv6() - get softif IPv6 multicast listeners
+  * @dev: the device to collect multicast addresses from
+  * @mcast_list: a list to put found addresses into
+  * @flags: flags indicating the new multicast state
+  *
+  * Collects multicast addresses of IPv6 multicast listeners residing
+  * on this kernel on the given soft interface, dev, in
+  * the given mcast_list. In general, multicast listeners provided by
+  * your multicast receiving applications run directly on this node.
+  *
+  * Return: -ENOMEM on memory allocation error or the number of
+  * items added to the mcast_list otherwise.
+  */
+ #if IS_ENABLED(CONFIG_IPV6)
+ static int
+ batadv_mcast_mla_softif_get_ipv6(struct net_device *dev,
+ 				 struct hlist_head *mcast_list,
+ 				 struct batadv_mcast_mla_flags *flags)
+ {
+ 	struct batadv_hw_addr *new;
+ 	struct inet6_dev *in6_dev;
+ 	u8 mcast_addr[ETH_ALEN];
+ 	struct ifmcaddr6 *pmc6;
+ 	int ret = 0;
+ 
+ 	if (flags->tvlv_flags & BATADV_MCAST_WANT_ALL_IPV6)
+ 		return 0;
+ 
+ 	rcu_read_lock();
+ 
+ 	in6_dev = __in6_dev_get(dev);
+ 	if (!in6_dev) {
+ 		rcu_read_unlock();
+ 		return 0;
+ 	}
+ 
+ 	for (pmc6 = rcu_dereference(in6_dev->mc_list);
+ 	     pmc6;
+ 	     pmc6 = rcu_dereference(pmc6->next)) {
+ 		if (IPV6_ADDR_MC_SCOPE(&pmc6->mca_addr) <
+ 		    IPV6_ADDR_SCOPE_LINKLOCAL)
+ 			continue;
+ 
+ 		if (flags->tvlv_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES &&
+ 		    ipv6_addr_is_ll_all_nodes(&pmc6->mca_addr))
+ 			continue;
+ 
+ 		if (!(flags->tvlv_flags & BATADV_MCAST_WANT_NO_RTR6) &&
+ 		    IPV6_ADDR_MC_SCOPE(&pmc6->mca_addr) >
+ 		    IPV6_ADDR_SCOPE_LINKLOCAL)
+ 			continue;
+ 
+ 		ipv6_eth_mc_map(&pmc6->mca_addr, mcast_addr);
+ 
+ 		if (batadv_mcast_mla_is_duplicate(mcast_addr, mcast_list))
+ 			continue;
+ 
+ 		new = kmalloc(sizeof(*new), GFP_ATOMIC);
+ 		if (!new) {
+ 			ret = -ENOMEM;
+ 			break;
+ 		}
+ 
+ 		ether_addr_copy(new->addr, mcast_addr);
+ 		hlist_add_head(&new->list, mcast_list);
+ 		ret++;
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	return ret;
+ }
+ #else
+ static inline int
+ batadv_mcast_mla_softif_get_ipv6(struct net_device *dev,
+ 				 struct hlist_head *mcast_list,
+ 				 struct batadv_mcast_mla_flags *flags)
+ {
+ 	return 0;
+ }
+ #endif
+ 
+ /**
+  * batadv_mcast_mla_softif_get() - get softif multicast listeners
+  * @dev: the device to collect multicast addresses from
+  * @mcast_list: a list to put found addresses into
+  * @flags: flags indicating the new multicast state
+  *
+  * Collects multicast addresses of multicast listeners residing
+  * on this kernel on the given soft interface, dev, in
+  * the given mcast_list. In general, multicast listeners provided by
+  * your multicast receiving applications run directly on this node.
+  *
+  * If there is a bridge interface on top of dev, collect from that one
+  * instead. Just like with IP addresses and routes, multicast listeners
+  * will(/should) register to the bridge interface instead of an
+  * enslaved bat0.
+  *
+  * Return: -ENOMEM on memory allocation error or the number of
+  * items added to the mcast_list otherwise.
+  */
+ static int
+ batadv_mcast_mla_softif_get(struct net_device *dev,
+ 			    struct hlist_head *mcast_list,
+ 			    struct batadv_mcast_mla_flags *flags)
+ {
+ 	struct net_device *bridge = batadv_mcast_get_bridge(dev);
+ 	int ret4, ret6 = 0;
+ 
+ 	if (bridge)
+ 		dev = bridge;
+ 
+ 	ret4 = batadv_mcast_mla_softif_get_ipv4(dev, mcast_list, flags);
+ 	if (ret4 < 0)
+ 		goto out;
+ 
+ 	ret6 = batadv_mcast_mla_softif_get_ipv6(dev, mcast_list, flags);
+ 	if (ret6 < 0) {
+ 		ret4 = 0;
+ 		goto out;
+ 	}
+ 
+ out:
+ 	dev_put(bridge);
+ 
+ 	return ret4 + ret6;
+ }
+ 
+ /**
++>>>>>>> 1160dfa178eb (net: Remove redundant if statements)
   * batadv_mcast_mla_br_addr_cpy() - copy a bridge multicast address
   * @dst: destination to write to - a multicast MAC address
   * @src: source to read from - a multicast IP address
diff --cc net/ipv4/fib_semantics.c
index 1dfb3bf9b3c6,b42c429cebbe..000000000000
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@@ -204,6 -206,25 +204,28 @@@ static void rt_fibinfo_free_cpus(struc
  	free_percpu(rtp);
  }
  
++<<<<<<< HEAD
++=======
+ void fib_nh_common_release(struct fib_nh_common *nhc)
+ {
+ 	dev_put(nhc->nhc_dev);
+ 	lwtstate_put(nhc->nhc_lwtstate);
+ 	rt_fibinfo_free_cpus(nhc->nhc_pcpu_rth_output);
+ 	rt_fibinfo_free(&nhc->nhc_rth_input);
+ 	free_nh_exceptions(nhc);
+ }
+ EXPORT_SYMBOL_GPL(fib_nh_common_release);
+ 
+ void fib_nh_release(struct net *net, struct fib_nh *fib_nh)
+ {
+ #ifdef CONFIG_IP_ROUTE_CLASSID
+ 	if (fib_nh->nh_tclassid)
+ 		net->ipv4.fib_num_tclassid_users--;
+ #endif
+ 	fib_nh_common_release(&fib_nh->nh_common);
+ }
+ 
++>>>>>>> 1160dfa178eb (net: Remove redundant if statements)
  /* Release a nexthop info record */
  static void free_fib_info_rcu(struct rcu_head *head)
  {
diff --cc net/ipv4/icmp.c
index cafe71040b9c,8b30cadff708..000000000000
--- a/net/ipv4/icmp.c
+++ b/net/ipv4/icmp.c
@@@ -967,6 -1016,115 +967,118 @@@ static bool icmp_echo(struct sk_buff *s
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ /*	Helper for icmp_echo and icmpv6_echo_reply.
+  *	Searches for net_device that matches PROBE interface identifier
+  *		and builds PROBE reply message in icmphdr.
+  *
+  *	Returns false if PROBE responses are disabled via sysctl
+  */
+ 
+ bool icmp_build_probe(struct sk_buff *skb, struct icmphdr *icmphdr)
+ {
+ 	struct icmp_ext_hdr *ext_hdr, _ext_hdr;
+ 	struct icmp_ext_echo_iio *iio, _iio;
+ 	struct net *net = dev_net(skb->dev);
+ 	struct net_device *dev;
+ 	char buff[IFNAMSIZ];
+ 	u16 ident_len;
+ 	u8 status;
+ 
+ 	if (!net->ipv4.sysctl_icmp_echo_enable_probe)
+ 		return false;
+ 
+ 	/* We currently only support probing interfaces on the proxy node
+ 	 * Check to ensure L-bit is set
+ 	 */
+ 	if (!(ntohs(icmphdr->un.echo.sequence) & 1))
+ 		return false;
+ 	/* Clear status bits in reply message */
+ 	icmphdr->un.echo.sequence &= htons(0xFF00);
+ 	if (icmphdr->type == ICMP_EXT_ECHO)
+ 		icmphdr->type = ICMP_EXT_ECHOREPLY;
+ 	else
+ 		icmphdr->type = ICMPV6_EXT_ECHO_REPLY;
+ 	ext_hdr = skb_header_pointer(skb, 0, sizeof(_ext_hdr), &_ext_hdr);
+ 	/* Size of iio is class_type dependent.
+ 	 * Only check header here and assign length based on ctype in the switch statement
+ 	 */
+ 	iio = skb_header_pointer(skb, sizeof(_ext_hdr), sizeof(iio->extobj_hdr), &_iio);
+ 	if (!ext_hdr || !iio)
+ 		goto send_mal_query;
+ 	if (ntohs(iio->extobj_hdr.length) <= sizeof(iio->extobj_hdr))
+ 		goto send_mal_query;
+ 	ident_len = ntohs(iio->extobj_hdr.length) - sizeof(iio->extobj_hdr);
+ 	status = 0;
+ 	dev = NULL;
+ 	switch (iio->extobj_hdr.class_type) {
+ 	case ICMP_EXT_ECHO_CTYPE_NAME:
+ 		iio = skb_header_pointer(skb, sizeof(_ext_hdr), sizeof(_iio), &_iio);
+ 		if (ident_len >= IFNAMSIZ)
+ 			goto send_mal_query;
+ 		memset(buff, 0, sizeof(buff));
+ 		memcpy(buff, &iio->ident.name, ident_len);
+ 		dev = dev_get_by_name(net, buff);
+ 		break;
+ 	case ICMP_EXT_ECHO_CTYPE_INDEX:
+ 		iio = skb_header_pointer(skb, sizeof(_ext_hdr), sizeof(iio->extobj_hdr) +
+ 					 sizeof(iio->ident.ifindex), &_iio);
+ 		if (ident_len != sizeof(iio->ident.ifindex))
+ 			goto send_mal_query;
+ 		dev = dev_get_by_index(net, ntohl(iio->ident.ifindex));
+ 		break;
+ 	case ICMP_EXT_ECHO_CTYPE_ADDR:
+ 		if (ident_len != sizeof(iio->ident.addr.ctype3_hdr) +
+ 				 iio->ident.addr.ctype3_hdr.addrlen)
+ 			goto send_mal_query;
+ 		switch (ntohs(iio->ident.addr.ctype3_hdr.afi)) {
+ 		case ICMP_AFI_IP:
+ 			iio = skb_header_pointer(skb, sizeof(_ext_hdr), sizeof(iio->extobj_hdr) +
+ 						 sizeof(struct in_addr), &_iio);
+ 			if (ident_len != sizeof(iio->ident.addr.ctype3_hdr) +
+ 					 sizeof(struct in_addr))
+ 				goto send_mal_query;
+ 			dev = ip_dev_find(net, iio->ident.addr.ip_addr.ipv4_addr);
+ 			break;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		case ICMP_AFI_IP6:
+ 			iio = skb_header_pointer(skb, sizeof(_ext_hdr), sizeof(_iio), &_iio);
+ 			if (ident_len != sizeof(iio->ident.addr.ctype3_hdr) +
+ 					 sizeof(struct in6_addr))
+ 				goto send_mal_query;
+ 			dev = ipv6_stub->ipv6_dev_find(net, &iio->ident.addr.ip_addr.ipv6_addr, dev);
+ 			dev_hold(dev);
+ 			break;
+ #endif
+ 		default:
+ 			goto send_mal_query;
+ 		}
+ 		break;
+ 	default:
+ 		goto send_mal_query;
+ 	}
+ 	if (!dev) {
+ 		icmphdr->code = ICMP_EXT_CODE_NO_IF;
+ 		return true;
+ 	}
+ 	/* Fill bits in reply message */
+ 	if (dev->flags & IFF_UP)
+ 		status |= ICMP_EXT_ECHOREPLY_ACTIVE;
+ 	if (__in_dev_get_rcu(dev) && __in_dev_get_rcu(dev)->ifa_list)
+ 		status |= ICMP_EXT_ECHOREPLY_IPV4;
+ 	if (!list_empty(&rcu_dereference(dev->ip6_ptr)->addr_list))
+ 		status |= ICMP_EXT_ECHOREPLY_IPV6;
+ 	dev_put(dev);
+ 	icmphdr->un.echo.sequence |= htons(status);
+ 	return true;
+ send_mal_query:
+ 	icmphdr->code = ICMP_EXT_CODE_MAL_QUERY;
+ 	return true;
+ }
+ EXPORT_SYMBOL_GPL(icmp_build_probe);
+ 
++>>>>>>> 1160dfa178eb (net: Remove redundant if statements)
  /*
   *	Handle ICMP Timestamp requests.
   *	RFC 1122: 3.2.2.8 MAY implement ICMP timestamp requests.
diff --cc net/ipv6/route.c
index d59f5fd3e25e,6cf4bb89ca69..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -2965,6 -3495,180 +2965,183 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static bool fib6_is_reject(u32 flags, struct net_device *dev, int addr_type)
+ {
+ 	if ((flags & RTF_REJECT) ||
+ 	    (dev && (dev->flags & IFF_LOOPBACK) &&
+ 	     !(addr_type & IPV6_ADDR_LOOPBACK) &&
+ 	     !(flags & (RTF_ANYCAST | RTF_LOCAL))))
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ int fib6_nh_init(struct net *net, struct fib6_nh *fib6_nh,
+ 		 struct fib6_config *cfg, gfp_t gfp_flags,
+ 		 struct netlink_ext_ack *extack)
+ {
+ 	struct net_device *dev = NULL;
+ 	struct inet6_dev *idev = NULL;
+ 	int addr_type;
+ 	int err;
+ 
+ 	fib6_nh->fib_nh_family = AF_INET6;
+ #ifdef CONFIG_IPV6_ROUTER_PREF
+ 	fib6_nh->last_probe = jiffies;
+ #endif
+ 	if (cfg->fc_is_fdb) {
+ 		fib6_nh->fib_nh_gw6 = cfg->fc_gateway;
+ 		fib6_nh->fib_nh_gw_family = AF_INET6;
+ 		return 0;
+ 	}
+ 
+ 	err = -ENODEV;
+ 	if (cfg->fc_ifindex) {
+ 		dev = dev_get_by_index(net, cfg->fc_ifindex);
+ 		if (!dev)
+ 			goto out;
+ 		idev = in6_dev_get(dev);
+ 		if (!idev)
+ 			goto out;
+ 	}
+ 
+ 	if (cfg->fc_flags & RTNH_F_ONLINK) {
+ 		if (!dev) {
+ 			NL_SET_ERR_MSG(extack,
+ 				       "Nexthop device required for onlink");
+ 			goto out;
+ 		}
+ 
+ 		if (!(dev->flags & IFF_UP)) {
+ 			NL_SET_ERR_MSG(extack, "Nexthop device is not up");
+ 			err = -ENETDOWN;
+ 			goto out;
+ 		}
+ 
+ 		fib6_nh->fib_nh_flags |= RTNH_F_ONLINK;
+ 	}
+ 
+ 	fib6_nh->fib_nh_weight = 1;
+ 
+ 	/* We cannot add true routes via loopback here,
+ 	 * they would result in kernel looping; promote them to reject routes
+ 	 */
+ 	addr_type = ipv6_addr_type(&cfg->fc_dst);
+ 	if (fib6_is_reject(cfg->fc_flags, dev, addr_type)) {
+ 		/* hold loopback dev/idev if we haven't done so. */
+ 		if (dev != net->loopback_dev) {
+ 			if (dev) {
+ 				dev_put(dev);
+ 				in6_dev_put(idev);
+ 			}
+ 			dev = net->loopback_dev;
+ 			dev_hold(dev);
+ 			idev = in6_dev_get(dev);
+ 			if (!idev) {
+ 				err = -ENODEV;
+ 				goto out;
+ 			}
+ 		}
+ 		goto pcpu_alloc;
+ 	}
+ 
+ 	if (cfg->fc_flags & RTF_GATEWAY) {
+ 		err = ip6_validate_gw(net, cfg, &dev, &idev, extack);
+ 		if (err)
+ 			goto out;
+ 
+ 		fib6_nh->fib_nh_gw6 = cfg->fc_gateway;
+ 		fib6_nh->fib_nh_gw_family = AF_INET6;
+ 	}
+ 
+ 	err = -ENODEV;
+ 	if (!dev)
+ 		goto out;
+ 
+ 	if (idev->cnf.disable_ipv6) {
+ 		NL_SET_ERR_MSG(extack, "IPv6 is disabled on nexthop device");
+ 		err = -EACCES;
+ 		goto out;
+ 	}
+ 
+ 	if (!(dev->flags & IFF_UP) && !cfg->fc_ignore_dev_down) {
+ 		NL_SET_ERR_MSG(extack, "Nexthop device is not up");
+ 		err = -ENETDOWN;
+ 		goto out;
+ 	}
+ 
+ 	if (!(cfg->fc_flags & (RTF_LOCAL | RTF_ANYCAST)) &&
+ 	    !netif_carrier_ok(dev))
+ 		fib6_nh->fib_nh_flags |= RTNH_F_LINKDOWN;
+ 
+ 	err = fib_nh_common_init(net, &fib6_nh->nh_common, cfg->fc_encap,
+ 				 cfg->fc_encap_type, cfg, gfp_flags, extack);
+ 	if (err)
+ 		goto out;
+ 
+ pcpu_alloc:
+ 	fib6_nh->rt6i_pcpu = alloc_percpu_gfp(struct rt6_info *, gfp_flags);
+ 	if (!fib6_nh->rt6i_pcpu) {
+ 		err = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	fib6_nh->fib_nh_dev = dev;
+ 	fib6_nh->fib_nh_oif = dev->ifindex;
+ 	err = 0;
+ out:
+ 	if (idev)
+ 		in6_dev_put(idev);
+ 
+ 	if (err) {
+ 		lwtstate_put(fib6_nh->fib_nh_lws);
+ 		fib6_nh->fib_nh_lws = NULL;
+ 		dev_put(dev);
+ 	}
+ 
+ 	return err;
+ }
+ 
+ void fib6_nh_release(struct fib6_nh *fib6_nh)
+ {
+ 	struct rt6_exception_bucket *bucket;
+ 
+ 	rcu_read_lock();
+ 
+ 	fib6_nh_flush_exceptions(fib6_nh, NULL);
+ 	bucket = fib6_nh_get_excptn_bucket(fib6_nh, NULL);
+ 	if (bucket) {
+ 		rcu_assign_pointer(fib6_nh->rt6i_exception_bucket, NULL);
+ 		kfree(bucket);
+ 	}
+ 
+ 	rcu_read_unlock();
+ 
+ 	if (fib6_nh->rt6i_pcpu) {
+ 		int cpu;
+ 
+ 		for_each_possible_cpu(cpu) {
+ 			struct rt6_info **ppcpu_rt;
+ 			struct rt6_info *pcpu_rt;
+ 
+ 			ppcpu_rt = per_cpu_ptr(fib6_nh->rt6i_pcpu, cpu);
+ 			pcpu_rt = *ppcpu_rt;
+ 			if (pcpu_rt) {
+ 				dst_dev_put(&pcpu_rt->dst);
+ 				dst_release(&pcpu_rt->dst);
+ 				*ppcpu_rt = NULL;
+ 			}
+ 		}
+ 
+ 		free_percpu(fib6_nh->rt6i_pcpu);
+ 	}
+ 
+ 	fib_nh_common_release(&fib6_nh->nh_common);
+ }
+ 
++>>>>>>> 1160dfa178eb (net: Remove redundant if statements)
  static struct fib6_info *ip6_route_info_create(struct fib6_config *cfg,
  					      gfp_t gfp_flags,
  					      struct netlink_ext_ack *extack)
diff --cc net/netfilter/nf_flow_table_offload.c
index 8303bca658b3,2bfd9f1b8f11..000000000000
--- a/net/netfilter/nf_flow_table_offload.c
+++ b/net/netfilter/nf_flow_table_offload.c
@@@ -193,9 -247,10 +193,13 @@@ static int flow_offload_eth_src(struct 
  			    &val, &mask);
  
  	mask = ~0xffffffff;
 -	memcpy(&val, addr + 2, 4);
 +	memcpy(&val, dev->dev_addr + 2, 4);
  	flow_offload_mangle(entry1, FLOW_ACT_MANGLE_HDR_TYPE_ETH, 8,
  			    &val, &mask);
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> 1160dfa178eb (net: Remove redundant if statements)
  	dev_put(dev);
  
  	return 0;
diff --cc net/packet/af_packet.c
index a2b99f1a75c2,543365f58e97..000000000000
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@@ -4032,9 -4104,8 +4028,14 @@@ static int packet_notifier(struct notif
  				}
  				if (msg == NETDEV_UNREGISTER) {
  					packet_cached_dev_reset(po);
++<<<<<<< HEAD
 +					po->ifindex = -1;
 +					if (po->prot_hook.dev)
 +						dev_put(po->prot_hook.dev);
++=======
+ 					WRITE_ONCE(po->ifindex, -1);
+ 					dev_put(po->prot_hook.dev);
++>>>>>>> 1160dfa178eb (net: Remove redundant if statements)
  					po->prot_hook.dev = NULL;
  				}
  				spin_unlock(&po->bind_lock);
diff --git a/net/batman-adv/bridge_loop_avoidance.c b/net/batman-adv/bridge_loop_avoidance.c
index a2de5a44bd41..f2ca8b15e273 100644
--- a/net/batman-adv/bridge_loop_avoidance.c
+++ b/net/batman-adv/bridge_loop_avoidance.c
@@ -2242,8 +2242,7 @@ int batadv_bla_claim_dump(struct sk_buff *msg, struct netlink_callback *cb)
 	if (primary_if)
 		batadv_hardif_put(primary_if);
 
-	if (soft_iface)
-		dev_put(soft_iface);
+	dev_put(soft_iface);
 
 	return ret;
 }
@@ -2475,8 +2474,7 @@ int batadv_bla_backbone_dump(struct sk_buff *msg, struct netlink_callback *cb)
 	if (primary_if)
 		batadv_hardif_put(primary_if);
 
-	if (soft_iface)
-		dev_put(soft_iface);
+	dev_put(soft_iface);
 
 	return ret;
 }
diff --git a/net/batman-adv/distributed-arp-table.c b/net/batman-adv/distributed-arp-table.c
index a60bacf7120b..27cf016c0516 100644
--- a/net/batman-adv/distributed-arp-table.c
+++ b/net/batman-adv/distributed-arp-table.c
@@ -997,8 +997,7 @@ int batadv_dat_cache_dump(struct sk_buff *msg, struct netlink_callback *cb)
 	if (primary_if)
 		batadv_hardif_put(primary_if);
 
-	if (soft_iface)
-		dev_put(soft_iface);
+	dev_put(soft_iface);
 
 	return ret;
 }
diff --git a/net/batman-adv/gateway_client.c b/net/batman-adv/gateway_client.c
index 8b198ee798c9..d5b84415ecfb 100644
--- a/net/batman-adv/gateway_client.c
+++ b/net/batman-adv/gateway_client.c
@@ -600,8 +600,7 @@ int batadv_gw_dump(struct sk_buff *msg, struct netlink_callback *cb)
 out:
 	if (primary_if)
 		batadv_hardif_put(primary_if);
-	if (soft_iface)
-		dev_put(soft_iface);
+	dev_put(soft_iface);
 
 	return ret;
 }
* Unmerged path net/batman-adv/multicast.c
diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c
index 716e5b43acfa..5b7577e988ce 100644
--- a/net/batman-adv/originator.c
+++ b/net/batman-adv/originator.c
@@ -847,12 +847,10 @@ int batadv_hardif_neigh_dump(struct sk_buff *msg, struct netlink_callback *cb)
  out:
 	if (hardif)
 		batadv_hardif_put(hardif);
-	if (hard_iface)
-		dev_put(hard_iface);
+	dev_put(hard_iface);
 	if (primary_if)
 		batadv_hardif_put(primary_if);
-	if (soft_iface)
-		dev_put(soft_iface);
+	dev_put(soft_iface);
 
 	return ret;
 }
@@ -1551,12 +1549,10 @@ int batadv_orig_dump(struct sk_buff *msg, struct netlink_callback *cb)
  out:
 	if (hardif)
 		batadv_hardif_put(hardif);
-	if (hard_iface)
-		dev_put(hard_iface);
+	dev_put(hard_iface);
 	if (primary_if)
 		batadv_hardif_put(primary_if);
-	if (soft_iface)
-		dev_put(soft_iface);
+	dev_put(soft_iface);
 
 	return ret;
 }
diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c
index 12a2b7d21376..2ce23e31b5ce 100644
--- a/net/batman-adv/translation-table.c
+++ b/net/batman-adv/translation-table.c
@@ -822,8 +822,7 @@ bool batadv_tt_local_add(struct net_device *soft_iface, const u8 *addr,
 out:
 	if (in_hardif)
 		batadv_hardif_put(in_hardif);
-	if (in_dev)
-		dev_put(in_dev);
+	dev_put(in_dev);
 	if (tt_local)
 		batadv_tt_local_entry_put(tt_local);
 	if (tt_global)
@@ -1290,8 +1289,7 @@ int batadv_tt_local_dump(struct sk_buff *msg, struct netlink_callback *cb)
  out:
 	if (primary_if)
 		batadv_hardif_put(primary_if);
-	if (soft_iface)
-		dev_put(soft_iface);
+	dev_put(soft_iface);
 
 	cb->args[0] = bucket;
 	cb->args[1] = idx;
@@ -2205,8 +2203,7 @@ int batadv_tt_global_dump(struct sk_buff *msg, struct netlink_callback *cb)
  out:
 	if (primary_if)
 		batadv_hardif_put(primary_if);
-	if (soft_iface)
-		dev_put(soft_iface);
+	dev_put(soft_iface);
 
 	cb->args[0] = bucket;
 	cb->args[1] = idx;
diff --git a/net/can/raw.c b/net/can/raw.c
index 1051eee82581..4587425112c4 100644
--- a/net/can/raw.c
+++ b/net/can/raw.c
@@ -560,9 +560,7 @@ static int raw_setsockopt(struct socket *sock, int level, int optname,
 		ro->count  = count;
 
  out_fil:
-		if (dev)
-			dev_put(dev);
-
+		dev_put(dev);
 		release_sock(sk);
 
 		break;
@@ -599,9 +597,7 @@ static int raw_setsockopt(struct socket *sock, int level, int optname,
 		ro->err_mask = err_mask;
 
  out_err:
-		if (dev)
-			dev_put(dev);
-
+		dev_put(dev);
 		release_sock(sk);
 
 		break;
diff --git a/net/core/dev.c b/net/core/dev.c
index 4f8544eeede0..cab388c608fb 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -912,8 +912,7 @@ struct net_device *dev_get_by_name(struct net *net, const char *name)
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
-	if (dev)
-		dev_hold(dev);
+	dev_hold(dev);
 	rcu_read_unlock();
 	return dev;
 }
@@ -986,8 +985,7 @@ struct net_device *dev_get_by_index(struct net *net, int ifindex)
 
 	rcu_read_lock();
 	dev = dev_get_by_index_rcu(net, ifindex);
-	if (dev)
-		dev_hold(dev);
+	dev_hold(dev);
 	rcu_read_unlock();
 	return dev;
 }
diff --git a/net/core/drop_monitor.c b/net/core/drop_monitor.c
index 06d6536a8efc..56a0d780dc45 100644
--- a/net/core/drop_monitor.c
+++ b/net/core/drop_monitor.c
@@ -846,8 +846,7 @@ net_dm_hw_metadata_copy(const struct devlink_trap_metadata *metadata)
 	}
 
 	hw_metadata->input_dev = metadata->input_dev;
-	if (hw_metadata->input_dev)
-		dev_hold(hw_metadata->input_dev);
+	dev_hold(hw_metadata->input_dev);
 
 	return hw_metadata;
 
@@ -863,8 +862,7 @@ net_dm_hw_metadata_copy(const struct devlink_trap_metadata *metadata)
 static void
 net_dm_hw_metadata_free(const struct devlink_trap_metadata *hw_metadata)
 {
-	if (hw_metadata->input_dev)
-		dev_put(hw_metadata->input_dev);
+	dev_put(hw_metadata->input_dev);
 	kfree(hw_metadata->fa_cookie);
 	kfree(hw_metadata->trap_name);
 	kfree(hw_metadata->trap_group_name);
diff --git a/net/core/dst.c b/net/core/dst.c
index 2d9b37f8944a..f759e8dc8a42 100644
--- a/net/core/dst.c
+++ b/net/core/dst.c
@@ -65,8 +65,7 @@ void dst_init(struct dst_entry *dst, struct dst_ops *ops,
 	      unsigned short flags)
 {
 	dst->dev = dev;
-	if (dev)
-		dev_hold(dev);
+	dev_hold(dev);
 	dst->ops = ops;
 	dst_init_metrics(dst, dst_default_metrics.metrics, true);
 	dst->expires = 0UL;
@@ -130,8 +129,7 @@ struct dst_entry *dst_destroy(struct dst_entry * dst)
 
 	if (dst->ops->destroy)
 		dst->ops->destroy(dst);
-	if (dst->dev)
-		dev_put(dst->dev);
+	dev_put(dst->dev);
 
 	lwtstate_put(dst->lwtstate);
 
diff --git a/net/core/neighbour.c b/net/core/neighbour.c
index e1dd99e65298..0183aea40a13 100644
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@ -657,12 +657,10 @@ struct pneigh_entry * pneigh_lookup(struct neigh_table *tbl,
 	write_pnet(&n->net, net);
 	memcpy(n->key, pkey, key_len);
 	n->dev = dev;
-	if (dev)
-		dev_hold(dev);
+	dev_hold(dev);
 
 	if (tbl->pconstructor && tbl->pconstructor(n)) {
-		if (dev)
-			dev_put(dev);
+		dev_put(dev);
 		kfree(n);
 		n = NULL;
 		goto out;
@@ -694,8 +692,7 @@ int pneigh_delete(struct neigh_table *tbl, struct net *net, const void *pkey,
 			write_unlock_bh(&tbl->lock);
 			if (tbl->pdestructor)
 				tbl->pdestructor(n);
-			if (n->dev)
-				dev_put(n->dev);
+			dev_put(n->dev);
 			kfree(n);
 			return 0;
 		}
@@ -728,8 +725,7 @@ static int pneigh_ifdown_and_unlock(struct neigh_table *tbl,
 		n->next = NULL;
 		if (tbl->pdestructor)
 			tbl->pdestructor(n);
-		if (n->dev)
-			dev_put(n->dev);
+		dev_put(n->dev);
 		kfree(n);
 	}
 	return -ENOENT;
@@ -1575,8 +1571,7 @@ void neigh_parms_release(struct neigh_table *tbl, struct neigh_parms *parms)
 	list_del(&parms->list);
 	parms->dead = 1;
 	write_unlock_bh(&tbl->lock);
-	if (parms->dev)
-		dev_put(parms->dev);
+	dev_put(parms->dev);
 	call_rcu(&parms->rcu_head, neigh_rcu_free_parms);
 }
 EXPORT_SYMBOL(neigh_parms_release);
diff --git a/net/decnet/dn_dev.c b/net/decnet/dn_dev.c
index 2d143682ca26..f4773316cbd5 100644
--- a/net/decnet/dn_dev.c
+++ b/net/decnet/dn_dev.c
@@ -524,8 +524,7 @@ int dn_dev_set_default(struct net_device *dev, int force)
 	}
 	spin_unlock(&dndev_lock);
 
-	if (old)
-		dev_put(old);
+	dev_put(old);
 	return rv;
 }
 
@@ -539,8 +538,7 @@ static void dn_dev_check_default(struct net_device *dev)
 	}
 	spin_unlock(&dndev_lock);
 
-	if (dev)
-		dev_put(dev);
+	dev_put(dev);
 }
 
 /*
diff --git a/net/decnet/dn_fib.c b/net/decnet/dn_fib.c
index 31c0f926b297..ed32580946ff 100644
--- a/net/decnet/dn_fib.c
+++ b/net/decnet/dn_fib.c
@@ -92,8 +92,7 @@ void dn_fib_free_info(struct dn_fib_info *fi)
 	}
 
 	change_nexthops(fi) {
-		if (nh->nh_dev)
-			dev_put(nh->nh_dev);
+		dev_put(nh->nh_dev);
 		nh->nh_dev = NULL;
 	} endfor_nexthops(fi);
 	kfree(fi);
diff --git a/net/decnet/dn_route.c b/net/decnet/dn_route.c
index 8d1bb00e5bbb..6336b417c362 100644
--- a/net/decnet/dn_route.c
+++ b/net/decnet/dn_route.c
@@ -1028,8 +1028,7 @@ static int dn_route_output_slow(struct dst_entry **pprt, const struct flowidn *o
 	if (!fld.daddr) {
 		fld.daddr = fld.saddr;
 
-		if (dev_out)
-			dev_put(dev_out);
+		dev_put(dev_out);
 		err = -EINVAL;
 		dev_out = init_net.loopback_dev;
 		if (!dev_out->dn_ptr)
@@ -1086,8 +1085,7 @@ static int dn_route_output_slow(struct dst_entry **pprt, const struct flowidn *o
 					neigh_release(neigh);
 					neigh = NULL;
 				} else {
-					if (dev_out)
-						dev_put(dev_out);
+					dev_put(dev_out);
 					if (dn_dev_islocal(neigh->dev, fld.daddr)) {
 						dev_out = init_net.loopback_dev;
 						res.type = RTN_LOCAL;
@@ -1146,8 +1144,7 @@ static int dn_route_output_slow(struct dst_entry **pprt, const struct flowidn *o
 	if (res.type == RTN_LOCAL) {
 		if (!fld.saddr)
 			fld.saddr = fld.daddr;
-		if (dev_out)
-			dev_put(dev_out);
+		dev_put(dev_out);
 		dev_out = init_net.loopback_dev;
 		dev_hold(dev_out);
 		if (!dev_out->dn_ptr)
@@ -1170,8 +1167,7 @@ static int dn_route_output_slow(struct dst_entry **pprt, const struct flowidn *o
 	if (!fld.saddr)
 		fld.saddr = DN_FIB_RES_PREFSRC(res);
 
-	if (dev_out)
-		dev_put(dev_out);
+	dev_put(dev_out);
 	dev_out = DN_FIB_RES_DEV(res);
 	dev_hold(dev_out);
 	fld.flowidn_oif = dev_out->ifindex;
@@ -1224,8 +1220,7 @@ static int dn_route_output_slow(struct dst_entry **pprt, const struct flowidn *o
 		neigh_release(neigh);
 	if (free_res)
 		dn_fib_res_put(&res);
-	if (dev_out)
-		dev_put(dev_out);
+	dev_put(dev_out);
 out:
 	return err;
 
@@ -1504,8 +1499,7 @@ static int dn_route_input_slow(struct sk_buff *skb)
 	if (free_res)
 		dn_fib_res_put(&res);
 	dev_put(in_dev);
-	if (out_dev)
-		dev_put(out_dev);
+	dev_put(out_dev);
 out:
 	return err;
 
diff --git a/net/ethtool/netlink.c b/net/ethtool/netlink.c
index 25a55086d2b6..fc969d120636 100644
--- a/net/ethtool/netlink.c
+++ b/net/ethtool/netlink.c
@@ -356,8 +356,7 @@ static int ethnl_default_doit(struct sk_buff *skb, struct genl_info *info)
 		ops->cleanup_data(reply_data);
 
 	genlmsg_end(rskb, reply_payload);
-	if (req_info->dev)
-		dev_put(req_info->dev);
+	dev_put(req_info->dev);
 	kfree(reply_data);
 	kfree(req_info);
 	return genlmsg_reply(rskb, info);
@@ -369,8 +368,7 @@ static int ethnl_default_doit(struct sk_buff *skb, struct genl_info *info)
 	if (ops->cleanup_data)
 		ops->cleanup_data(reply_data);
 err_dev:
-	if (req_info->dev)
-		dev_put(req_info->dev);
+	dev_put(req_info->dev);
 	kfree(reply_data);
 	kfree(req_info);
 	return ret;
diff --git a/net/ieee802154/nl-phy.c b/net/ieee802154/nl-phy.c
index 0c25c0bcc4da..c1bf83281b62 100644
--- a/net/ieee802154/nl-phy.c
+++ b/net/ieee802154/nl-phy.c
@@ -346,8 +346,7 @@ int ieee802154_del_iface(struct sk_buff *skb, struct genl_info *info)
 out_dev:
 	wpan_phy_put(phy);
 out:
-	if (dev)
-		dev_put(dev);
+	dev_put(dev);
 
 	return rc;
 }
diff --git a/net/ieee802154/nl802154.c b/net/ieee802154/nl802154.c
index cd3826c30ad9..bd0e214ff811 100644
--- a/net/ieee802154/nl802154.c
+++ b/net/ieee802154/nl802154.c
@@ -2179,8 +2179,7 @@ static void nl802154_post_doit(const struct genl_ops *ops, struct sk_buff *skb,
 		if (ops->internal_flags & NL802154_FLAG_NEED_WPAN_DEV) {
 			struct wpan_dev *wpan_dev = info->user_ptr[1];
 
-			if (wpan_dev->netdev)
-				dev_put(wpan_dev->netdev);
+			dev_put(wpan_dev->netdev);
 		} else {
 			dev_put(info->user_ptr[1]);
 		}
diff --git a/net/ieee802154/socket.c b/net/ieee802154/socket.c
index e95004b507d3..128ab8bc0c81 100644
--- a/net/ieee802154/socket.c
+++ b/net/ieee802154/socket.c
@@ -48,8 +48,7 @@ ieee802154_get_dev(struct net *net, const struct ieee802154_addr *addr)
 		ieee802154_devaddr_to_raw(hwaddr, addr->extended_addr);
 		rcu_read_lock();
 		dev = dev_getbyhwaddr_rcu(net, ARPHRD_IEEE802154, hwaddr);
-		if (dev)
-			dev_hold(dev);
+		dev_hold(dev);
 		rcu_read_unlock();
 		break;
 	case IEEE802154_ADDR_SHORT:
* Unmerged path net/ipv4/fib_semantics.c
* Unmerged path net/ipv4/icmp.c
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index 736b1318bfd7..a0baa0d7e331 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -2610,8 +2610,7 @@ struct dst_entry *ipv4_blackhole_route(struct net *net, struct dst_entry *dst_or
 		new->output = dst_discard_out;
 
 		new->dev = net->loopback_dev;
-		if (new->dev)
-			dev_hold(new->dev);
+		dev_hold(new->dev);
 
 		rt->rt_is_input = ort->rt_is_input;
 		rt->rt_iif = ort->rt_iif;
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index ffd256100974..db7cf2f7c555 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -695,8 +695,7 @@ static int inet6_netconf_get_devconf(struct sk_buff *in_skb,
 errout:
 	if (in6_dev)
 		in6_dev_put(in6_dev);
-	if (dev)
-		dev_put(dev);
+	dev_put(dev);
 	return err;
 }
 
@@ -5390,8 +5389,7 @@ static int inet6_rtm_getaddr(struct sk_buff *in_skb, struct nlmsghdr *nlh,
 errout_ifa:
 	in6_ifa_put(ifa);
 errout:
-	if (dev)
-		dev_put(dev);
+	dev_put(dev);
 	if (fillargs.netnsid >= 0)
 		put_net(tgt_net);
 
diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c
index ae7de79e6bd0..7a7db6094ad4 100644
--- a/net/ipv6/ip6mr.c
+++ b/net/ipv6/ip6mr.c
@@ -564,8 +564,7 @@ static int pim6_rcv(struct sk_buff *skb)
 	read_lock(&mrt_lock);
 	if (reg_vif_num >= 0)
 		reg_dev = mrt->vif_table[reg_vif_num].dev;
-	if (reg_dev)
-		dev_hold(reg_dev);
+	dev_hold(reg_dev);
 	read_unlock(&mrt_lock);
 
 	if (!reg_dev)
* Unmerged path net/ipv6/route.c
diff --git a/net/llc/af_llc.c b/net/llc/af_llc.c
index c7426ddd91e8..c1e0c7ef0280 100644
--- a/net/llc/af_llc.c
+++ b/net/llc/af_llc.c
@@ -216,8 +216,7 @@ static int llc_ui_release(struct socket *sock)
 	} else {
 		release_sock(sk);
 	}
-	if (llc->dev)
-		dev_put(llc->dev);
+	dev_put(llc->dev);
 	sock_put(sk);
 	llc_sk_free(sk);
 out:
@@ -352,8 +351,7 @@ static int llc_ui_bind(struct socket *sock, struct sockaddr *uaddr, int addrlen)
 	} else
 		llc->dev = dev_getbyhwaddr_rcu(&init_net, addr->sllc_arphrd,
 					   addr->sllc_mac);
-	if (llc->dev)
-		dev_hold(llc->dev);
+	dev_hold(llc->dev);
 	rcu_read_unlock();
 	if (!llc->dev)
 		goto out;
* Unmerged path net/netfilter/nf_flow_table_offload.c
diff --git a/net/netfilter/nf_queue.c b/net/netfilter/nf_queue.c
index e54627bcc2be..684cb725bbfb 100644
--- a/net/netfilter/nf_queue.c
+++ b/net/netfilter/nf_queue.c
@@ -51,18 +51,14 @@ static void nf_queue_entry_release_refs(struct nf_queue_entry *entry)
 	struct nf_hook_state *state = &entry->state;
 
 	/* Release those devices we held, or Alexey will kill me. */
-	if (state->in)
-		dev_put(state->in);
-	if (state->out)
-		dev_put(state->out);
+	dev_put(state->in);
+	dev_put(state->out);
 	if (state->sk)
 		sock_put(state->sk);
 
 #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
-	if (entry->physin)
-		dev_put(entry->physin);
-	if (entry->physout)
-		dev_put(entry->physout);
+	dev_put(entry->physin);
+	dev_put(entry->physout);
 #endif
 }
 
@@ -95,18 +91,14 @@ void nf_queue_entry_get_refs(struct nf_queue_entry *entry)
 {
 	struct nf_hook_state *state = &entry->state;
 
-	if (state->in)
-		dev_hold(state->in);
-	if (state->out)
-		dev_hold(state->out);
+	dev_hold(state->in);
+	dev_hold(state->out);
 	if (state->sk)
 		sock_hold(state->sk);
 
 #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
-	if (entry->physin)
-		dev_hold(entry->physin);
-	if (entry->physout)
-		dev_hold(entry->physout);
+	dev_hold(entry->physin);
+	dev_hold(entry->physout);
 #endif
 }
 EXPORT_SYMBOL_GPL(nf_queue_entry_get_refs);
diff --git a/net/netlabel/netlabel_unlabeled.c b/net/netlabel/netlabel_unlabeled.c
index 4b462ddc15fa..6f6c7aada9cb 100644
--- a/net/netlabel/netlabel_unlabeled.c
+++ b/net/netlabel/netlabel_unlabeled.c
@@ -505,8 +505,7 @@ static int netlbl_unlhsh_remove_addr4(struct net *net,
 		netlbl_af4list_audit_addr(audit_buf, 1,
 					  (dev != NULL ? dev->name : NULL),
 					  addr->s_addr, mask->s_addr);
-		if (dev != NULL)
-			dev_put(dev);
+		dev_put(dev);
 		if (entry != NULL &&
 		    security_secid_to_secctx(entry->secid,
 					     &secctx, &secctx_len) == 0) {
@@ -566,8 +565,7 @@ static int netlbl_unlhsh_remove_addr6(struct net *net,
 		netlbl_af6list_audit_addr(audit_buf, 1,
 					  (dev != NULL ? dev->name : NULL),
 					  addr, mask);
-		if (dev != NULL)
-			dev_put(dev);
+		dev_put(dev);
 		if (entry != NULL &&
 		    security_secid_to_secctx(entry->secid,
 					     &secctx, &secctx_len) == 0) {
diff --git a/net/netrom/nr_loopback.c b/net/netrom/nr_loopback.c
index 215ad22a9647..e4bf1c90e9e8 100644
--- a/net/netrom/nr_loopback.c
+++ b/net/netrom/nr_loopback.c
@@ -62,8 +62,7 @@ static void nr_loopback_timer(struct timer_list *unused)
 		if (dev == NULL || nr_rx_frame(skb, dev) == 0)
 			kfree_skb(skb);
 
-		if (dev != NULL)
-			dev_put(dev);
+		dev_put(dev);
 
 		if (!skb_queue_empty(&loopback_queue) && !nr_loopback_running())
 			mod_timer(&loopback_timer, jiffies + 10);
diff --git a/net/netrom/nr_route.c b/net/netrom/nr_route.c
index 6485f593e2f0..fb815c4bcbec 100644
--- a/net/netrom/nr_route.c
+++ b/net/netrom/nr_route.c
@@ -580,8 +580,7 @@ struct net_device *nr_dev_first(void)
 			if (first == NULL || strncmp(dev->name, first->name, 3) < 0)
 				first = dev;
 	}
-	if (first)
-		dev_hold(first);
+	dev_hold(first);
 	rcu_read_unlock();
 
 	return first;
* Unmerged path net/packet/af_packet.c
diff --git a/net/phonet/af_phonet.c b/net/phonet/af_phonet.c
index 3b0ef691f5b1..88c109031d32 100644
--- a/net/phonet/af_phonet.c
+++ b/net/phonet/af_phonet.c
@@ -288,8 +288,7 @@ int pn_skb_send(struct sock *sk, struct sk_buff *skb,
 
 drop:
 	kfree_skb(skb);
-	if (dev)
-		dev_put(dev);
+	dev_put(dev);
 	return err;
 }
 EXPORT_SYMBOL(pn_skb_send);
diff --git a/net/phonet/pn_dev.c b/net/phonet/pn_dev.c
index 6cb4f602ab71..550b776aadce 100644
--- a/net/phonet/pn_dev.c
+++ b/net/phonet/pn_dev.c
@@ -137,8 +137,7 @@ struct net_device *phonet_device_get(struct net *net)
 			break;
 		dev = NULL;
 	}
-	if (dev)
-		dev_hold(dev);
+	dev_hold(dev);
 	rcu_read_unlock();
 	return dev;
 }
@@ -426,8 +425,7 @@ struct net_device *phonet_route_output(struct net *net, u8 daddr)
 	daddr >>= 2;
 	rcu_read_lock();
 	dev = rcu_dereference(routes->table[daddr]);
-	if (dev)
-		dev_hold(dev);
+	dev_hold(dev);
 	rcu_read_unlock();
 
 	if (!dev)
diff --git a/net/phonet/socket.c b/net/phonet/socket.c
index 1bdf844c867c..0348b10e67db 100644
--- a/net/phonet/socket.c
+++ b/net/phonet/socket.c
@@ -392,8 +392,7 @@ static int pn_socket_ioctl(struct socket *sock, unsigned int cmd,
 			saddr = PN_NO_ADDR;
 		release_sock(sk);
 
-		if (dev)
-			dev_put(dev);
+		dev_put(dev);
 		if (saddr == PN_NO_ADDR)
 			return -EHOSTUNREACH;
 
diff --git a/net/sched/act_mirred.c b/net/sched/act_mirred.c
index d9c5d44d4f4a..62b4abfd72b7 100644
--- a/net/sched/act_mirred.c
+++ b/net/sched/act_mirred.c
@@ -83,8 +83,7 @@ static void tcf_mirred_release(struct tc_action *a)
 
 	/* last reference to action, no need to lock */
 	dev = rcu_dereference_protected(m->tcfm_dev, 1);
-	if (dev)
-		dev_put(dev);
+	dev_put(dev);
 }
 
 static const struct nla_policy mirred_policy[TCA_MIRRED_MAX + 1] = {
@@ -185,8 +184,7 @@ static int tcf_mirred_init(struct net *net, struct nlattr *nla,
 		mac_header_xmit = dev_is_mac_header_xmit(dev);
 		dev = rcu_replace_pointer(m->tcfm_dev, dev,
 					  lockdep_is_held(&m->tcf_lock));
-		if (dev)
-			dev_put(dev);
+		dev_put(dev);
 		m->tcfm_mac_header_xmit = mac_header_xmit;
 	}
 	goto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);
diff --git a/net/smc/smc_ib.c b/net/smc/smc_ib.c
index 64dba8f6490b..4b491b95bc06 100644
--- a/net/smc/smc_ib.c
+++ b/net/smc/smc_ib.c
@@ -753,8 +753,7 @@ void smc_ib_ndev_change(struct net_device *ndev, unsigned long event)
 			if (!libdev->ops.get_netdev)
 				continue;
 			lndev = libdev->ops.get_netdev(libdev, i + 1);
-			if (lndev)
-				dev_put(lndev);
+			dev_put(lndev);
 			if (lndev != ndev)
 				continue;
 			if (event == NETDEV_REGISTER)
diff --git a/net/smc/smc_pnet.c b/net/smc/smc_pnet.c
index 2b855831e2ce..3e76efd3e560 100644
--- a/net/smc/smc_pnet.c
+++ b/net/smc/smc_pnet.c
@@ -394,8 +394,7 @@ static int smc_pnet_add_eth(struct smc_pnettable *pnettable, struct net *net,
 	return 0;
 
 out_put:
-	if (ndev)
-		dev_put(ndev);
+	dev_put(ndev);
 	return rc;
 }
 
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 3437117f29da..a0555bb57ff3 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -6520,8 +6520,7 @@ static int nl80211_set_station(struct sk_buff *skb, struct genl_info *info)
 	err = rdev_change_station(rdev, dev, mac_addr, &params);
 
  out_put_vlan:
-	if (params.vlan)
-		dev_put(params.vlan);
+	dev_put(params.vlan);
 
 	return err;
 }
@@ -6756,8 +6755,7 @@ static int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)
 
 	err = rdev_add_station(rdev, dev, mac_addr, &params);
 
-	if (params.vlan)
-		dev_put(params.vlan);
+	dev_put(params.vlan);
 	return err;
 }
 
@@ -8483,8 +8481,7 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 		goto out_free;
 
 	nl80211_send_scan_start(rdev, wdev);
-	if (wdev->netdev)
-		dev_hold(wdev->netdev);
+	dev_hold(wdev->netdev);
 
 	return 0;
 
@@ -14854,9 +14851,7 @@ static int nl80211_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,
 			return -ENETDOWN;
 		}
 
-		if (dev)
-			dev_hold(dev);
-
+		dev_hold(dev);
 		info->user_ptr[0] = rdev;
 	}
 
@@ -14878,8 +14873,7 @@ static void nl80211_post_doit(const struct genl_ops *ops, struct sk_buff *skb,
 		if (ops->internal_flags & NL80211_FLAG_NEED_WDEV) {
 			struct wireless_dev *wdev = info->user_ptr[1];
 
-			if (wdev->netdev)
-				dev_put(wdev->netdev);
+			dev_put(wdev->netdev);
 		} else {
 			dev_put(info->user_ptr[1]);
 		}
diff --git a/net/wireless/scan.c b/net/wireless/scan.c
index 4f06c1825029..d348bc2a0d19 100644
--- a/net/wireless/scan.c
+++ b/net/wireless/scan.c
@@ -965,8 +965,7 @@ void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev,
 	}
 #endif
 
-	if (wdev->netdev)
-		dev_put(wdev->netdev);
+	dev_put(wdev->netdev);
 
 	kfree(rdev->int_scan_req);
 	rdev->int_scan_req = NULL;
