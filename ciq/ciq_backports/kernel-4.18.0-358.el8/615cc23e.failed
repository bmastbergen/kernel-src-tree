net: bridge: multicast: add vlan querier and query support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 615cc23e6283e143933ecf2bf3645fe0cea5ae6a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/615cc23e.failed

Add basic vlan context querier support, if the contexts passed to
multicast_alloc_query are vlan then the query will be tagged. Also
handle querier start/stop of vlan contexts.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 615cc23e6283e143933ecf2bf3645fe0cea5ae6a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
diff --cc net/bridge/br_multicast.c
index def6f1840985,9d4a18a711e4..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -312,7 -773,28 +312,32 @@@ static void br_multicast_gc(struct hlis
  	}
  }
  
++<<<<<<< HEAD
 +static struct sk_buff *br_ip4_multicast_alloc_query(struct net_bridge *br,
++=======
+ static void __br_multicast_query_handle_vlan(struct net_bridge_mcast *brmctx,
+ 					     struct net_bridge_mcast_port *pmctx,
+ 					     struct sk_buff *skb)
+ {
+ 	struct net_bridge_vlan *vlan = NULL;
+ 
+ 	if (pmctx && br_multicast_port_ctx_is_vlan(pmctx))
+ 		vlan = pmctx->vlan;
+ 	else if (br_multicast_ctx_is_vlan(brmctx))
+ 		vlan = brmctx->vlan;
+ 
+ 	if (vlan && !(vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED)) {
+ 		u16 vlan_proto;
+ 
+ 		if (br_vlan_get_proto(brmctx->br->dev, &vlan_proto) != 0)
+ 			return;
+ 		__vlan_hwaccel_put_tag(skb, htons(vlan_proto), vlan->vid);
+ 	}
+ }
+ 
+ static struct sk_buff *br_ip4_multicast_alloc_query(struct net_bridge_mcast *brmctx,
+ 						    struct net_bridge_mcast_port *pmctx,
++>>>>>>> 615cc23e6283 (net: bridge: multicast: add vlan querier and query support)
  						    struct net_bridge_port_group *pg,
  						    __be32 ip_dst, __be32 group,
  						    bool with_srcs, bool over_lmqt,
@@@ -457,7 -940,8 +483,12 @@@ out
  }
  
  #if IS_ENABLED(CONFIG_IPV6)
++<<<<<<< HEAD
 +static struct sk_buff *br_ip6_multicast_alloc_query(struct net_bridge *br,
++=======
+ static struct sk_buff *br_ip6_multicast_alloc_query(struct net_bridge_mcast *brmctx,
+ 						    struct net_bridge_mcast_port *pmctx,
++>>>>>>> 615cc23e6283 (net: bridge: multicast: add vlan querier and query support)
  						    struct net_bridge_port_group *pg,
  						    const struct in6_addr *ip6_dst,
  						    const struct in6_addr *group,
@@@ -620,7 -1105,8 +652,12 @@@ out
  }
  #endif
  
++<<<<<<< HEAD
 +static struct sk_buff *br_multicast_alloc_query(struct net_bridge *br,
++=======
+ static struct sk_buff *br_multicast_alloc_query(struct net_bridge_mcast *brmctx,
+ 						struct net_bridge_mcast_port *pmctx,
++>>>>>>> 615cc23e6283 (net: bridge: multicast: add vlan querier and query support)
  						struct net_bridge_port_group *pg,
  						struct br_ip *ip_dst,
  						struct br_ip *group,
@@@ -632,9 -1118,9 +669,15 @@@
  
  	switch (group->proto) {
  	case htons(ETH_P_IP):
++<<<<<<< HEAD
 +		ip4_dst = ip_dst ? ip_dst->u.ip4 : htonl(INADDR_ALLHOSTS_GROUP);
 +		return br_ip4_multicast_alloc_query(br, pg,
 +						    ip4_dst, group->u.ip4,
++=======
+ 		ip4_dst = ip_dst ? ip_dst->dst.ip4 : htonl(INADDR_ALLHOSTS_GROUP);
+ 		return br_ip4_multicast_alloc_query(brmctx, pmctx, pg,
+ 						    ip4_dst, group->dst.ip4,
++>>>>>>> 615cc23e6283 (net: bridge: multicast: add vlan querier and query support)
  						    with_srcs, over_lmqt,
  						    sflag, igmp_type,
  						    need_rexmit);
@@@ -648,8 -1134,8 +691,13 @@@
  			ipv6_addr_set(&ip6_dst, htonl(0xff020000), 0, 0,
  				      htonl(1));
  
++<<<<<<< HEAD
 +		return br_ip6_multicast_alloc_query(br, pg,
 +						    &ip6_dst, &group->u.ip6,
++=======
+ 		return br_ip6_multicast_alloc_query(brmctx, pmctx, pg,
+ 						    &ip6_dst, &group->dst.ip6,
++>>>>>>> 615cc23e6283 (net: bridge: multicast: add vlan querier and query support)
  						    with_srcs, over_lmqt,
  						    sflag, igmp_type,
  						    need_rexmit);
@@@ -1046,9 -1628,12 +1094,17 @@@ static void __br_multicast_send_query(s
  	struct sk_buff *skb;
  	u8 igmp_type;
  
+ 	if (!br_multicast_ctx_should_use(brmctx, pmctx))
+ 		return;
+ 
  again_under_lmqt:
++<<<<<<< HEAD
 +	skb = br_multicast_alloc_query(br, pg, ip_dst, group, with_srcs,
 +				       over_lmqt, sflag, &igmp_type,
++=======
+ 	skb = br_multicast_alloc_query(brmctx, pmctx, pg, ip_dst, group,
+ 				       with_srcs, over_lmqt, sflag, &igmp_type,
++>>>>>>> 615cc23e6283 (net: bridge: multicast: add vlan querier and query support)
  				       need_rexmit);
  	if (!skb)
  		return;
@@@ -1113,20 -1698,21 +1169,25 @@@ static void br_multicast_send_query(str
  }
  
  static void
 -br_multicast_port_query_expired(struct net_bridge_mcast_port *pmctx,
 +br_multicast_port_query_expired(struct net_bridge_port *port,
  				struct bridge_mcast_own_query *query)
  {
 -	struct net_bridge *br = pmctx->port->br;
 -	struct net_bridge_mcast *brmctx;
 +	struct net_bridge *br = port->br;
  
  	spin_lock(&br->multicast_lock);
 -	if (br_multicast_port_ctx_state_stopped(pmctx))
 +	if (port->state == BR_STATE_DISABLED ||
 +	    port->state == BR_STATE_BLOCKING)
  		goto out;
  
++<<<<<<< HEAD
 +	if (query->startup_sent < br->multicast_startup_query_count)
++=======
+ 	brmctx = br_multicast_port_ctx_get_global(pmctx);
+ 	if (query->startup_sent < brmctx->multicast_startup_query_count)
++>>>>>>> 615cc23e6283 (net: bridge: multicast: add vlan querier and query support)
  		query->startup_sent++;
  
 -	br_multicast_send_query(brmctx, pmctx, query);
 +	br_multicast_send_query(port->br, port, query);
  
  out:
  	spin_unlock(&br->multicast_lock);
@@@ -3037,19 -4154,42 +3098,55 @@@ static void br_multicast_start_querier(
  {
  	struct net_bridge_port *port;
  
 -	__br_multicast_open_query(brmctx->br, query);
 +	__br_multicast_open(br, query);
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	list_for_each_entry_rcu(port, &br->port_list, list) {
 +		if (port->state == BR_STATE_DISABLED ||
 +		    port->state == BR_STATE_BLOCKING)
 +			continue;
 +
 +		if (query == &br->ip4_own_query)
 +			br_multicast_enable(&port->ip4_own_query);
 +#if IS_ENABLED(CONFIG_IPV6)
 +		else
 +			br_multicast_enable(&port->ip6_own_query);
++=======
+ 	list_for_each_entry_rcu(port, &brmctx->br->port_list, list) {
+ 		struct bridge_mcast_own_query *ip4_own_query;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		struct bridge_mcast_own_query *ip6_own_query;
+ #endif
+ 
+ 		if (br_multicast_port_ctx_state_stopped(&port->multicast_ctx))
+ 			continue;
+ 
+ 		if (br_multicast_ctx_is_vlan(brmctx)) {
+ 			struct net_bridge_vlan *vlan;
+ 
+ 			vlan = br_vlan_find(nbp_vlan_group(port), brmctx->vlan->vid);
+ 			if (!vlan ||
+ 			    br_multicast_port_ctx_state_stopped(&vlan->port_mcast_ctx))
+ 				continue;
+ 
+ 			ip4_own_query = &vlan->port_mcast_ctx.ip4_own_query;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 			ip6_own_query = &vlan->port_mcast_ctx.ip6_own_query;
+ #endif
+ 		} else {
+ 			ip4_own_query = &port->multicast_ctx.ip4_own_query;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 			ip6_own_query = &port->multicast_ctx.ip6_own_query;
+ #endif
+ 		}
+ 
+ 		if (query == &brmctx->ip4_own_query)
+ 			br_multicast_enable(ip4_own_query);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		else
+ 			br_multicast_enable(ip6_own_query);
++>>>>>>> 615cc23e6283 (net: bridge: multicast: add vlan querier and query support)
  #endif
  	}
  	rcu_read_unlock();
* Unmerged path net/bridge/br_multicast.c
