ata: move sata_link_{debounce,resume}() to libata-sata.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
commit 9d3158f5cb11142d85c351fa0e0087ef95ac9cb8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/9d3158f5.failed

* move sata_link_{debounce,resume}() to libata-sata.c

* add static inline for CONFIG_SATA_HOST=n case (only one,
  for sata_link_resume() is needed)

Code size savings on m68k arch using (modified) atari_defconfig:

   text    data     bss     dec     hex filename
before:
  32816     572      40   33428    8294 drivers/ata/libata-core.o
after:
  32724     572      40   33336    8238 drivers/ata/libata-core.o

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 9d3158f5cb11142d85c351fa0e0087ef95ac9cb8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ata/libata-core.c
#	drivers/ata/libata-sata.c
#	include/linux/libata.h
diff --cc drivers/ata/libata-core.c
index d6da17431f7f,4ca81ef7c8bd..000000000000
--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@@ -3796,218 -3483,9 +3796,221 @@@ int ata_wait_after_reset(struct ata_lin
  
  	return ata_wait_ready(link, deadline, check_ready);
  }
 -EXPORT_SYMBOL_GPL(ata_wait_after_reset);
  
  /**
++<<<<<<< HEAD
 + *	sata_link_debounce - debounce SATA phy status
 + *	@link: ATA link to debounce SATA phy status for
 + *	@params: timing parameters { interval, duration, timeout } in msec
 + *	@deadline: deadline jiffies for the operation
 + *
 + *	Make sure SStatus of @link reaches stable state, determined by
 + *	holding the same value where DET is not 1 for @duration polled
 + *	every @interval, before @timeout.  Timeout constraints the
 + *	beginning of the stable state.  Because DET gets stuck at 1 on
 + *	some controllers after hot unplugging, this functions waits
 + *	until timeout then returns 0 if DET is stable at 1.
 + *
 + *	@timeout is further limited by @deadline.  The sooner of the
 + *	two is used.
 + *
 + *	LOCKING:
 + *	Kernel thread context (may sleep)
 + *
 + *	RETURNS:
 + *	0 on success, -errno on failure.
 + */
 +int sata_link_debounce(struct ata_link *link, const unsigned long *params,
 +		       unsigned long deadline)
 +{
 +	unsigned long interval = params[0];
 +	unsigned long duration = params[1];
 +	unsigned long last_jiffies, t;
 +	u32 last, cur;
 +	int rc;
 +
 +	t = ata_deadline(jiffies, params[2]);
 +	if (time_before(t, deadline))
 +		deadline = t;
 +
 +	if ((rc = sata_scr_read(link, SCR_STATUS, &cur)))
 +		return rc;
 +	cur &= 0xf;
 +
 +	last = cur;
 +	last_jiffies = jiffies;
 +
 +	while (1) {
 +		ata_msleep(link->ap, interval);
 +		if ((rc = sata_scr_read(link, SCR_STATUS, &cur)))
 +			return rc;
 +		cur &= 0xf;
 +
 +		/* DET stable? */
 +		if (cur == last) {
 +			if (cur == 1 && time_before(jiffies, deadline))
 +				continue;
 +			if (time_after(jiffies,
 +				       ata_deadline(last_jiffies, duration)))
 +				return 0;
 +			continue;
 +		}
 +
 +		/* unstable, start over */
 +		last = cur;
 +		last_jiffies = jiffies;
 +
 +		/* Check deadline.  If debouncing failed, return
 +		 * -EPIPE to tell upper layer to lower link speed.
 +		 */
 +		if (time_after(jiffies, deadline))
 +			return -EPIPE;
 +	}
 +}
 +
 +/**
 + *	sata_link_resume - resume SATA link
 + *	@link: ATA link to resume SATA
 + *	@params: timing parameters { interval, duration, timeout } in msec
 + *	@deadline: deadline jiffies for the operation
 + *
 + *	Resume SATA phy @link and debounce it.
 + *
 + *	LOCKING:
 + *	Kernel thread context (may sleep)
 + *
 + *	RETURNS:
 + *	0 on success, -errno on failure.
 + */
 +int sata_link_resume(struct ata_link *link, const unsigned long *params,
 +		     unsigned long deadline)
 +{
 +	int tries = ATA_LINK_RESUME_TRIES;
 +	u32 scontrol, serror;
 +	int rc;
 +
 +	if ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))
 +		return rc;
 +
 +	/*
 +	 * Writes to SControl sometimes get ignored under certain
 +	 * controllers (ata_piix SIDPR).  Make sure DET actually is
 +	 * cleared.
 +	 */
 +	do {
 +		scontrol = (scontrol & 0x0f0) | 0x300;
 +		if ((rc = sata_scr_write(link, SCR_CONTROL, scontrol)))
 +			return rc;
 +		/*
 +		 * Some PHYs react badly if SStatus is pounded
 +		 * immediately after resuming.  Delay 200ms before
 +		 * debouncing.
 +		 */
 +		if (!(link->flags & ATA_LFLAG_NO_DB_DELAY))
 +			ata_msleep(link->ap, 200);
 +
 +		/* is SControl restored correctly? */
 +		if ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))
 +			return rc;
 +	} while ((scontrol & 0xf0f) != 0x300 && --tries);
 +
 +	if ((scontrol & 0xf0f) != 0x300) {
 +		ata_link_warn(link, "failed to resume link (SControl %X)\n",
 +			     scontrol);
 +		return 0;
 +	}
 +
 +	if (tries < ATA_LINK_RESUME_TRIES)
 +		ata_link_warn(link, "link resume succeeded after %d retries\n",
 +			      ATA_LINK_RESUME_TRIES - tries);
 +
 +	if ((rc = sata_link_debounce(link, params, deadline)))
 +		return rc;
 +
 +	/* clear SError, some PHYs require this even for SRST to work */
 +	if (!(rc = sata_scr_read(link, SCR_ERROR, &serror)))
 +		rc = sata_scr_write(link, SCR_ERROR, serror);
 +
 +	return rc != -EINVAL ? rc : 0;
 +}
 +
 +/**
 + *	sata_link_scr_lpm - manipulate SControl IPM and SPM fields
 + *	@link: ATA link to manipulate SControl for
 + *	@policy: LPM policy to configure
 + *	@spm_wakeup: initiate LPM transition to active state
 + *
 + *	Manipulate the IPM field of the SControl register of @link
 + *	according to @policy.  If @policy is ATA_LPM_MAX_POWER and
 + *	@spm_wakeup is %true, the SPM field is manipulated to wake up
 + *	the link.  This function also clears PHYRDY_CHG before
 + *	returning.
 + *
 + *	LOCKING:
 + *	EH context.
 + *
 + *	RETURNS:
 + *	0 on success, -errno otherwise.
 + */
 +int sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,
 +		      bool spm_wakeup)
 +{
 +	struct ata_eh_context *ehc = &link->eh_context;
 +	bool woken_up = false;
 +	u32 scontrol;
 +	int rc;
 +
 +	rc = sata_scr_read(link, SCR_CONTROL, &scontrol);
 +	if (rc)
 +		return rc;
 +
 +	switch (policy) {
 +	case ATA_LPM_MAX_POWER:
 +		/* disable all LPM transitions */
 +		scontrol |= (0x7 << 8);
 +		/* initiate transition to active state */
 +		if (spm_wakeup) {
 +			scontrol |= (0x4 << 12);
 +			woken_up = true;
 +		}
 +		break;
 +	case ATA_LPM_MED_POWER:
 +		/* allow LPM to PARTIAL */
 +		scontrol &= ~(0x1 << 8);
 +		scontrol |= (0x6 << 8);
 +		break;
 +	case ATA_LPM_MED_POWER_WITH_DIPM:
 +	case ATA_LPM_MIN_POWER_WITH_PARTIAL:
 +	case ATA_LPM_MIN_POWER:
 +		if (ata_link_nr_enabled(link) > 0)
 +			/* no restrictions on LPM transitions */
 +			scontrol &= ~(0x7 << 8);
 +		else {
 +			/* empty port, power off */
 +			scontrol &= ~0xf;
 +			scontrol |= (0x1 << 2);
 +		}
 +		break;
 +	default:
 +		WARN_ON(1);
 +	}
 +
 +	rc = sata_scr_write(link, SCR_CONTROL, scontrol);
 +	if (rc)
 +		return rc;
 +
 +	/* give the link time to transit out of LPM state */
 +	if (woken_up)
 +		msleep(10);
 +
 +	/* clear PHYRDY_CHG from SError */
 +	ehc->i.serror &= ~SERR_PHYRDY_CHG;
 +	return sata_scr_write(link, SCR_ERROR, SERR_PHYRDY_CHG);
 +}
 +
 +/**
++=======
++>>>>>>> 9d3158f5cb11 (ata: move sata_link_{debounce,resume}() to libata-sata.c)
   *	ata_std_prereset - prepare for reset
   *	@link: ATA link to be reset
   *	@deadline: deadline jiffies for the operation
diff --cc include/linux/libata.h
index ce0dc53b9adc,b05538d06919..000000000000
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@@ -1097,12 -1077,6 +1097,15 @@@ extern int sata_set_spd(struct ata_lin
  extern int ata_std_prereset(struct ata_link *link, unsigned long deadline);
  extern int ata_wait_after_reset(struct ata_link *link, unsigned long deadline,
  				int (*check_ready)(struct ata_link *link));
++<<<<<<< HEAD
 +extern int sata_link_debounce(struct ata_link *link,
 +			const unsigned long *params, unsigned long deadline);
 +extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
 +			    unsigned long deadline);
 +extern int sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,
 +			     bool spm_wakeup);
++=======
++>>>>>>> 9d3158f5cb11 (ata: move sata_link_{debounce,resume}() to libata-sata.c)
  extern int sata_link_hardreset(struct ata_link *link,
  			const unsigned long *timing, unsigned long deadline,
  			bool *online, int (*check_ready)(struct ata_link *));
@@@ -1208,6 -1180,48 +1211,51 @@@ extern struct ata_device *ata_dev_pair(
  extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
  extern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);
  extern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap, struct list_head *eh_q);
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * SATA specific code - drivers/ata/libata-sata.c
+  */
+ #ifdef CONFIG_SATA_HOST
+ extern int sata_scr_valid(struct ata_link *link);
+ extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
+ extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
+ extern int sata_scr_write_flush(struct ata_link *link, int reg, u32 val);
+ extern int sata_set_spd(struct ata_link *link);
+ extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
+ 			    unsigned long deadline);
+ #else
+ static inline int sata_scr_valid(struct ata_link *link) { return 0; }
+ static inline int sata_scr_read(struct ata_link *link, int reg, u32 *val)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int sata_scr_write(struct ata_link *link, int reg, u32 val)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int sata_scr_write_flush(struct ata_link *link, int reg, u32 val)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int sata_set_spd(struct ata_link *link) { return -EOPNOTSUPP; }
+ static inline int sata_link_resume(struct ata_link *link,
+ 				   const unsigned long *params,
+ 				   unsigned long deadline)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ #endif
+ extern int sata_link_debounce(struct ata_link *link,
+ 			const unsigned long *params, unsigned long deadline);
+ extern int sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,
+ 			     bool spm_wakeup);
+ extern int ata_slave_link_init(struct ata_port *ap);
+ extern void ata_tf_to_fis(const struct ata_taskfile *tf,
+ 			  u8 pmp, int is_cmd, u8 *fis);
+ extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);
++>>>>>>> 9d3158f5cb11 (ata: move sata_link_{debounce,resume}() to libata-sata.c)
  extern bool sata_lpm_ignore_phy_events(struct ata_link *link);
  
  extern int ata_cable_40wire(struct ata_port *ap);
* Unmerged path drivers/ata/libata-sata.c
* Unmerged path drivers/ata/libata-core.c
* Unmerged path drivers/ata/libata-sata.c
* Unmerged path include/linux/libata.h
