ata: move ata_qc_complete_multiple() to libata-sata.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
commit 61a11986d33d01dbef745d49c0536961eb06d2f1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/61a11986.failed

* move ata_qc_complete_multiple() to libata-sata.c

Code size savings on m68k arch using (modified) atari_defconfig:

   text    data     bss     dec     hex filename
before:
  32559     572      40   33171    8193 drivers/ata/libata-core.o
after:
  32162     572      40   32774    8006 drivers/ata/libata-core.o

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 61a11986d33d01dbef745d49c0536961eb06d2f1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ata/libata-core.c
#	drivers/ata/libata-sata.c
#	include/linux/libata.h
diff --cc drivers/ata/libata-core.c
index d6da17431f7f,2ef0960b2154..000000000000
--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@@ -5377,64 -4750,6 +5377,67 @@@ u64 ata_qc_get_active(struct ata_port *
  EXPORT_SYMBOL_GPL(ata_qc_get_active);
  
  /**
++<<<<<<< HEAD
 + *	ata_qc_complete_multiple - Complete multiple qcs successfully
 + *	@ap: port in question
 + *	@qc_active: new qc_active mask
 + *
 + *	Complete in-flight commands.  This functions is meant to be
 + *	called from low-level driver's interrupt routine to complete
 + *	requests normally.  ap->qc_active and @qc_active is compared
 + *	and commands are completed accordingly.
 + *
 + *	Always use this function when completing multiple NCQ commands
 + *	from IRQ handlers instead of calling ata_qc_complete()
 + *	multiple times to keep IRQ expect status properly in sync.
 + *
 + *	LOCKING:
 + *	spin_lock_irqsave(host lock)
 + *
 + *	RETURNS:
 + *	Number of completed commands on success, -errno otherwise.
 + */
 +int ata_qc_complete_multiple(struct ata_port *ap, u64 qc_active)
 +{
 +	u64 done_mask, ap_qc_active = ap->qc_active;
 +	int nr_done = 0;
 +
 +	/*
 +	 * If the internal tag is set on ap->qc_active, then we care about
 +	 * bit0 on the passed in qc_active mask. Move that bit up to match
 +	 * the internal tag.
 +	 */
 +	if (ap_qc_active & (1ULL << ATA_TAG_INTERNAL)) {
 +		qc_active |= (qc_active & 0x01) << ATA_TAG_INTERNAL;
 +		qc_active ^= qc_active & 0x01;
 +	}
 +
 +	done_mask = ap_qc_active ^ qc_active;
 +
 +	if (unlikely(done_mask & qc_active)) {
 +		ata_port_err(ap, "illegal qc_active transition (%08llx->%08llx)\n",
 +			     ap->qc_active, qc_active);
 +		return -EINVAL;
 +	}
 +
 +	while (done_mask) {
 +		struct ata_queued_cmd *qc;
 +		unsigned int tag = __ffs64(done_mask);
 +
 +		qc = ata_qc_from_tag(ap, tag);
 +		if (qc) {
 +			ata_qc_complete(qc);
 +			nr_done++;
 +		}
 +		done_mask &= ~(1ULL << tag);
 +	}
 +
 +	return nr_done;
 +}
 +
 +/**
++=======
++>>>>>>> 61a11986d33d (ata: move ata_qc_complete_multiple() to libata-sata.c)
   *	ata_qc_issue - issue taskfile to device
   *	@qc: command to issue to device
   *
diff --cc include/linux/libata.h
index ce0dc53b9adc,08fec96a6a1e..000000000000
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@@ -1208,6 -1176,62 +1207,65 @@@ extern struct ata_device *ata_dev_pair(
  extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
  extern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);
  extern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap, struct list_head *eh_q);
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * SATA specific code - drivers/ata/libata-sata.c
+  */
+ #ifdef CONFIG_SATA_HOST
+ extern int sata_scr_valid(struct ata_link *link);
+ extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
+ extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
+ extern int sata_scr_write_flush(struct ata_link *link, int reg, u32 val);
+ extern int sata_set_spd(struct ata_link *link);
+ extern int sata_link_hardreset(struct ata_link *link,
+ 			const unsigned long *timing, unsigned long deadline,
+ 			bool *online, int (*check_ready)(struct ata_link *));
+ extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
+ 			    unsigned long deadline);
+ #else
+ static inline int sata_scr_valid(struct ata_link *link) { return 0; }
+ static inline int sata_scr_read(struct ata_link *link, int reg, u32 *val)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int sata_scr_write(struct ata_link *link, int reg, u32 val)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int sata_scr_write_flush(struct ata_link *link, int reg, u32 val)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int sata_set_spd(struct ata_link *link) { return -EOPNOTSUPP; }
+ static inline int sata_link_hardreset(struct ata_link *link,
+ 				      const unsigned long *timing,
+ 				      unsigned long deadline,
+ 				      bool *online,
+ 				      int (*check_ready)(struct ata_link *))
+ {
+ 	if (online)
+ 		*online = false;
+ 	return -EOPNOTSUPP;
+ }
+ static inline int sata_link_resume(struct ata_link *link,
+ 				   const unsigned long *params,
+ 				   unsigned long deadline)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ #endif
+ extern int sata_link_debounce(struct ata_link *link,
+ 			const unsigned long *params, unsigned long deadline);
+ extern int sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,
+ 			     bool spm_wakeup);
+ extern int ata_slave_link_init(struct ata_port *ap);
+ extern void ata_tf_to_fis(const struct ata_taskfile *tf,
+ 			  u8 pmp, int is_cmd, u8 *fis);
+ extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);
+ extern int ata_qc_complete_multiple(struct ata_port *ap, u64 qc_active);
++>>>>>>> 61a11986d33d (ata: move ata_qc_complete_multiple() to libata-sata.c)
  extern bool sata_lpm_ignore_phy_events(struct ata_link *link);
  
  extern int ata_cable_40wire(struct ata_port *ap);
* Unmerged path drivers/ata/libata-sata.c
* Unmerged path drivers/ata/libata-core.c
* Unmerged path drivers/ata/libata-sata.c
* Unmerged path include/linux/libata.h
