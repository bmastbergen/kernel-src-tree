nfsd: remove unused set_client argument

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author J. Bruce Fields <bfields@redhat.com>
commit f71475ba8c2a77fff8051903cf4b7d826c3d1693
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/f71475ba.failed

Every caller is setting this argument to false, so we don't need it.

Also cut this comment a bit and remove an unnecessary warning.

	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit f71475ba8c2a77fff8051903cf4b7d826c3d1693)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4state.c
diff --cc fs/nfsd/nfs4state.c
index 1988369d20ec,677586d9169a..000000000000
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@@ -4586,33 -4638,32 +4586,52 @@@ static __be32 lookup_clientid(clientid_
  {
  	struct nfs4_client *found;
  
++<<<<<<< HEAD
++=======
+ 	spin_lock(&nn->client_lock);
+ 	found = find_confirmed_client(clid, sessions, nn);
+ 	if (found)
+ 		atomic_inc(&found->cl_rpc_users);
+ 	spin_unlock(&nn->client_lock);
+ 	return found;
+ }
+ 
+ static __be32 set_client(clientid_t *clid,
+ 		struct nfsd4_compound_state *cstate,
+ 		struct nfsd_net *nn)
+ {
++>>>>>>> f71475ba8c2a (nfsd: remove unused set_client argument)
  	if (cstate->clp) {
 -		if (!same_clid(&cstate->clp->cl_clientid, clid))
 +		found = cstate->clp;
 +		if (!same_clid(&found->cl_clientid, clid))
  			return nfserr_stale_clientid;
  		return nfs_ok;
  	}
 +
  	if (STALE_CLIENTID(clid, nn))
  		return nfserr_stale_clientid;
 +
  	/*
- 	 * For v4.1+ we get the client in the SEQUENCE op. If we don't have one
- 	 * cached already then we know this is for is for v4.0 and "sessions"
- 	 * will be false.
+ 	 * We're in the 4.0 case (otherwise the SEQUENCE op would have
+ 	 * set cstate->clp), so session = false:
  	 */
++<<<<<<< HEAD
 +	WARN_ON_ONCE(cstate->session);
 +	spin_lock(&nn->client_lock);
 +	found = find_confirmed_client(clid, false, nn);
 +	if (!found) {
 +		spin_unlock(&nn->client_lock);
++=======
+ 	cstate->clp = lookup_clientid(clid, false, nn);
+ 	if (!cstate->clp)
++>>>>>>> f71475ba8c2a (nfsd: remove unused set_client argument)
  		return nfserr_expired;
 +	}
 +	atomic_inc(&found->cl_rpc_users);
 +	spin_unlock(&nn->client_lock);
 +
 +	/* Cache the nfs4_client in cstate! */
 +	cstate->clp = found;
  	return nfs_ok;
  }
  
@@@ -4634,7 -4685,7 +4653,11 @@@ nfsd4_process_open1(struct nfsd4_compou
  	if (open->op_file == NULL)
  		return nfserr_jukebox;
  
++<<<<<<< HEAD
 +	status = lookup_clientid(clientid, cstate, nn);
++=======
+ 	status = set_client(clientid, cstate, nn);
++>>>>>>> f71475ba8c2a (nfsd: remove unused set_client argument)
  	if (status)
  		return status;
  	clp = cstate->clp;
@@@ -5219,7 -5295,7 +5242,11 @@@ nfsd4_renew(struct svc_rqst *rqstp, str
  	struct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);
  
  	trace_nfsd_clid_renew(clid);
++<<<<<<< HEAD
 +	status = lookup_clientid(clid, cstate, nn);
++=======
+ 	status = set_client(clid, cstate, nn);
++>>>>>>> f71475ba8c2a (nfsd: remove unused set_client argument)
  	if (status)
  		return status;
  	clp = cstate->clp;
@@@ -5590,7 -5678,7 +5617,11 @@@ nfsd4_lookup_stateid(struct nfsd4_compo
  	if (ZERO_STATEID(stateid) || ONE_STATEID(stateid) ||
  		CLOSE_STATEID(stateid))
  		return nfserr_bad_stateid;
++<<<<<<< HEAD
 +	status = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);
++=======
+ 	status = set_client(&stateid->si_opaque.so_clid, cstate, nn);
++>>>>>>> f71475ba8c2a (nfsd: remove unused set_client argument)
  	if (status == nfserr_stale_clientid) {
  		if (cstate->session)
  			return nfserr_bad_stateid;
@@@ -6728,7 -6902,7 +6759,11 @@@ nfsd4_lockt(struct svc_rqst *rqstp, str
  		 return nfserr_inval;
  
  	if (!nfsd4_has_session(cstate)) {
++<<<<<<< HEAD
 +		status = lookup_clientid(&lockt->lt_clientid, cstate, nn);
++=======
+ 		status = set_client(&lockt->lt_clientid, cstate, nn);
++>>>>>>> f71475ba8c2a (nfsd: remove unused set_client argument)
  		if (status)
  			goto out;
  	}
@@@ -6912,7 -7086,7 +6947,11 @@@ nfsd4_release_lockowner(struct svc_rqs
  	dprintk("nfsd4_release_lockowner clientid: (%08x/%08x):\n",
  		clid->cl_boot, clid->cl_id);
  
++<<<<<<< HEAD
 +	status = lookup_clientid(clid, cstate, nn);
++=======
+ 	status = set_client(clid, cstate, nn);
++>>>>>>> f71475ba8c2a (nfsd: remove unused set_client argument)
  	if (status)
  		return status;
  
@@@ -7059,7 -7233,7 +7098,11 @@@ nfs4_check_open_reclaim(clientid_t *cli
  	__be32 status;
  
  	/* find clientid in conf_id_hashtbl */
++<<<<<<< HEAD
 +	status = lookup_clientid(clid, cstate, nn);
++=======
+ 	status = set_client(clid, cstate, nn);
++>>>>>>> f71475ba8c2a (nfsd: remove unused set_client argument)
  	if (status)
  		return nfserr_reclaim_bad;
  
* Unmerged path fs/nfsd/nfs4state.c
