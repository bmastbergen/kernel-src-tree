PCI/VPD: Add pci_read/write_vpd_any()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit bf2928c7a284e31f9f91a004b5dca09c522157c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/bf2928c7.failed

In certain cases we need a variant of pci_read_vpd()/pci_write_vpd() that
does not check against dev->vpd.len. Such cases are:

  - Reading VPD if dev->vpd.len isn't set yet (in pci_vpd_size())

  - Devices that map non-VPD information to arbitrary places in VPD address
    space (example: Chelsio T3 EEPROM write-protect flag)

Therefore add pci_read_vpd_any() and pci_write_vpd_any() that check against
PCI_VPD_MAX_SIZE only.

Link: https://lore.kernel.org/r/93ecce28-a158-f02a-d134-8afcaced8efe@gmail.com
	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Acked-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit bf2928c7a284e31f9f91a004b5dca09c522157c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/vpd.c
diff --cc drivers/pci/vpd.c
index 799ce083bd7b,0a804715d98e..000000000000
--- a/drivers/pci/vpd.c
+++ b/drivers/pci/vpd.c
@@@ -144,9 -156,10 +144,14 @@@ static int pci_vpd_wait(struct pci_dev 
  }
  
  static ssize_t pci_vpd_read(struct pci_dev *dev, loff_t pos, size_t count,
- 			    void *arg)
+ 			    void *arg, bool check_size)
  {
++<<<<<<< HEAD
 +	struct pci_vpd *vpd = dev->vpd;
++=======
+ 	struct pci_vpd *vpd = &dev->vpd;
+ 	unsigned int max_len = check_size ? vpd->len : PCI_VPD_MAX_SIZE;
++>>>>>>> bf2928c7a284 (PCI/VPD: Add pci_read/write_vpd_any())
  	int ret = 0;
  	loff_t end = pos + count;
  	u8 *buf = arg;
@@@ -157,17 -170,11 +162,21 @@@
  	if (pos < 0)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (!vpd->len)
 +		vpd->len = pci_vpd_size(dev);
 +
 +	if (vpd->len == PCI_VPD_SZ_INVALID)
 +		return -EIO;
 +
 +	if (pos > vpd->len)
++=======
+ 	if (pos >= max_len)
++>>>>>>> bf2928c7a284 (PCI/VPD: Add pci_read/write_vpd_any())
  		return 0;
  
- 	if (end > vpd->len) {
- 		end = vpd->len;
+ 	if (end > max_len) {
+ 		end = max_len;
  		count = end - pos;
  	}
  
@@@ -211,9 -218,10 +220,14 @@@
  }
  
  static ssize_t pci_vpd_write(struct pci_dev *dev, loff_t pos, size_t count,
- 			     const void *arg)
+ 			     const void *arg, bool check_size)
  {
++<<<<<<< HEAD
 +	struct pci_vpd *vpd = dev->vpd;
++=======
+ 	struct pci_vpd *vpd = &dev->vpd;
+ 	unsigned int max_len = check_size ? vpd->len : PCI_VPD_MAX_SIZE;
++>>>>>>> bf2928c7a284 (PCI/VPD: Add pci_read/write_vpd_any())
  	const u8 *buf = arg;
  	loff_t end = pos + count;
  	int ret = 0;
@@@ -224,13 -232,7 +238,17 @@@
  	if (pos < 0 || (pos & 3) || (count & 3))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (!vpd->len)
 +		vpd->len = pci_vpd_size(dev);
 +
 +	if (vpd->len == PCI_VPD_SZ_INVALID)
 +		return -EIO;
 +
 +	if (end > vpd->len)
++=======
+ 	if (end > max_len)
++>>>>>>> bf2928c7a284 (PCI/VPD: Add pci_read/write_vpd_any())
  		return -EINVAL;
  
  	if (mutex_lock_killable(&vpd->lock))
* Unmerged path drivers/pci/vpd.c
diff --git a/include/linux/pci.h b/include/linux/pci.h
index 137e69e7b9c4..100486aec260 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -1365,6 +1365,8 @@ void pci_unlock_rescan_remove(void);
 /* Vital Product Data routines */
 ssize_t pci_read_vpd(struct pci_dev *dev, loff_t pos, size_t count, void *buf);
 ssize_t pci_write_vpd(struct pci_dev *dev, loff_t pos, size_t count, const void *buf);
+ssize_t pci_read_vpd_any(struct pci_dev *dev, loff_t pos, size_t count, void *buf);
+ssize_t pci_write_vpd_any(struct pci_dev *dev, loff_t pos, size_t count, const void *buf);
 
 /* Helper functions for low-level code (drivers/pci/setup-[bus,res].c) */
 resource_size_t pcibios_retrieve_fw_addr(struct pci_dev *dev, int idx);
