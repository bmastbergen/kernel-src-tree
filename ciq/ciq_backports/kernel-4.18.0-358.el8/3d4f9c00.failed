Bluetooth: use inclusive language when filtering devices

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Archie Pusaka <apusaka@chromium.org>
commit 3d4f9c00492b4e21641e5140a5e78cb50b58d60b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/3d4f9c00.failed

This patch replaces some non-inclusive terms based on the appropriate
language mapping table compiled by the Bluetooth SIG:
https://specificationrefs.bluetooth.com/language-mapping/Appropriate_Language_Mapping_Table.pdf

Specifically, these terms are replaced:
blacklist -> reject list
whitelist -> accept list

	Signed-off-by: Archie Pusaka <apusaka@chromium.org>
	Reviewed-by: Miao-chen Chou <mcchou@chromium.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 3d4f9c00492b4e21641e5140a5e78cb50b58d60b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/hci_core.c
#	net/bluetooth/hci_request.c
#	net/bluetooth/mgmt.c
diff --cc net/bluetooth/hci_core.c
index 62051240c083,2560ed2f144d..000000000000
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@@ -735,17 -742,29 +735,17 @@@ static int hci_init3_req(struct hci_req
  			hci_req_add(req, HCI_OP_LE_READ_ADV_TX_POWER, 0, NULL);
  		}
  
 -		if (hdev->commands[38] & 0x80) {
 -			/* Read LE Min/Max Tx Power*/
 -			hci_req_add(req, HCI_OP_LE_READ_TRANSMIT_POWER,
 -				    0, NULL);
 -		}
 -
  		if (hdev->commands[26] & 0x40) {
- 			/* Read LE White List Size */
- 			hci_req_add(req, HCI_OP_LE_READ_WHITE_LIST_SIZE,
+ 			/* Read LE Accept List Size */
+ 			hci_req_add(req, HCI_OP_LE_READ_ACCEPT_LIST_SIZE,
  				    0, NULL);
  		}
  
  		if (hdev->commands[26] & 0x80) {
- 			/* Clear LE White List */
- 			hci_req_add(req, HCI_OP_LE_CLEAR_WHITE_LIST, 0, NULL);
+ 			/* Clear LE Accept List */
+ 			hci_req_add(req, HCI_OP_LE_CLEAR_ACCEPT_LIST, 0, NULL);
  		}
  
 -		if (hdev->commands[34] & 0x40) {
 -			/* Read LE Resolving List Size */
 -			hci_req_add(req, HCI_OP_LE_READ_RESOLV_LIST_SIZE,
 -				    0, NULL);
 -		}
 -
  		if (hdev->commands[34] & 0x20) {
  			/* Clear LE Resolving List */
  			hci_req_add(req, HCI_OP_LE_CLEAR_RESOLV_LIST, 0, NULL);
@@@ -3447,18 -3713,30 +3447,18 @@@ static int hci_suspend_notifier(struct 
  		/* Suspend consists of two actions:
  		 *  - First, disconnect everything and make the controller not
  		 *    connectable (disabling scanning)
- 		 *  - Second, program event filter/whitelist and enable scan
+ 		 *  - Second, program event filter/accept list and enable scan
  		 */
  		ret = hci_change_suspend_state(hdev, BT_SUSPEND_DISCONNECT);
 -		if (!ret)
 -			state = BT_SUSPEND_DISCONNECT;
  
- 		/* Only configure whitelist if disconnect succeeded and wake
+ 		/* Only configure accept list if disconnect succeeded and wake
  		 * isn't being prevented.
  		 */
 -		if (!ret && !(hdev->prevent_wake && hdev->prevent_wake(hdev))) {
 +		if (!ret && !(hdev->prevent_wake && hdev->prevent_wake(hdev)))
  			ret = hci_change_suspend_state(hdev,
  						BT_SUSPEND_CONFIGURE_WAKE);
 -			if (!ret)
 -				state = BT_SUSPEND_CONFIGURE_WAKE;
 -		}
 -
 -		hci_clear_wake_reason(hdev);
 -		mgmt_suspending(hdev, state);
 -
  	} else if (action == PM_POST_SUSPEND) {
  		ret = hci_change_suspend_state(hdev, BT_RUNNING);
 -
 -		mgmt_resuming(hdev, hdev->wake_reason, &hdev->wake_addr,
 -			      hdev->wake_addr_type);
  	}
  
  done:
@@@ -3768,7 -4055,8 +3768,12 @@@ void hci_unregister_dev(struct hci_dev 
  	hci_smp_irks_clear(hdev);
  	hci_remote_oob_data_clear(hdev);
  	hci_adv_instances_clear(hdev);
++<<<<<<< HEAD
 +	hci_bdaddr_list_clear(&hdev->le_white_list);
++=======
+ 	hci_adv_monitors_clear(hdev);
+ 	hci_bdaddr_list_clear(&hdev->le_accept_list);
++>>>>>>> 3d4f9c00492b (Bluetooth: use inclusive language when filtering devices)
  	hci_bdaddr_list_clear(&hdev->le_resolv_list);
  	hci_conn_params_clear_all(hdev);
  	hci_discovery_filter_clear(hdev);
diff --cc net/bluetooth/hci_request.c
index 9956180871f8,f7a9d97f3e84..000000000000
--- a/net/bluetooth/hci_request.c
+++ b/net/bluetooth/hci_request.c
@@@ -853,7 -911,17 +853,21 @@@ static u8 update_accept_list(struct hci
  			return 0x00;
  	}
  
++<<<<<<< HEAD
 +	/* Select filter policy to use white list */
++=======
+ 	/* Use the allowlist unless the following conditions are all true:
+ 	 * - We are not currently suspending
+ 	 * - There are 1 or more ADV monitors registered and it's not offloaded
+ 	 * - Interleaved scanning is not currently using the allowlist
+ 	 */
+ 	if (!idr_is_empty(&hdev->adv_monitors_idr) && !hdev->suspended &&
+ 	    hci_get_adv_monitor_offload_ext(hdev) == HCI_ADV_MONITOR_EXT_NONE &&
+ 	    hdev->interleave_scan_state != INTERLEAVE_SCAN_ALLOWLIST)
+ 		return 0x00;
+ 
+ 	/* Select filter policy to use accept list */
++>>>>>>> 3d4f9c00492b (Bluetooth: use inclusive language when filtering devices)
  	return 0x01;
  }
  
@@@ -1002,11 -1073,16 +1016,20 @@@ void hci_req_add_le_passive_scan(struc
  				      &own_addr_type))
  		return;
  
++<<<<<<< HEAD
 +	/* Adding or removing entries from the white list must
++=======
+ 	if (hdev->enable_advmon_interleave_scan &&
+ 	    __hci_update_interleaved_scan(hdev))
+ 		return;
+ 
+ 	bt_dev_dbg(hdev, "interleave state %d", hdev->interleave_scan_state);
+ 	/* Adding or removing entries from the accept list must
++>>>>>>> 3d4f9c00492b (Bluetooth: use inclusive language when filtering devices)
  	 * happen before enabling scanning. The controller does
- 	 * not allow white list modification while scanning.
+ 	 * not allow accept list modification while scanning.
  	 */
- 	filter_policy = update_white_list(req);
+ 	filter_policy = update_accept_list(req);
  
  	/* When the controller is using random resolvable addresses and
  	 * with that having LE privacy enabled, then controllers with
diff --cc net/bluetooth/mgmt.c
index 6f87f1f65f22,d1bf5a55ff85..000000000000
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@@ -3635,53 -3716,863 +3635,719 @@@ unlock
  	return err;
  }
  
++<<<<<<< HEAD
 +static int set_blocked_keys(struct sock *sk, struct hci_dev *hdev, void *data,
 +			    u16 len)
 +{
 +	int err = MGMT_STATUS_SUCCESS;
 +	struct mgmt_cp_set_blocked_keys *keys = data;
 +	const u16 max_key_count = ((U16_MAX - sizeof(*keys)) /
 +				   sizeof(struct mgmt_blocked_key_info));
 +	u16 key_count, expected_len;
++=======
+ static int read_controller_cap(struct sock *sk, struct hci_dev *hdev,
+ 			       void *data, u16 data_len)
+ {
+ 	char buf[20];
+ 	struct mgmt_rp_read_controller_cap *rp = (void *)buf;
+ 	u16 cap_len = 0;
+ 	u8 flags = 0;
+ 	u8 tx_power_range[2];
+ 
+ 	bt_dev_dbg(hdev, "sock %p", sk);
+ 
+ 	memset(&buf, 0, sizeof(buf));
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	/* When the Read Simple Pairing Options command is supported, then
+ 	 * the remote public key validation is supported.
+ 	 *
+ 	 * Alternatively, when Microsoft extensions are available, they can
+ 	 * indicate support for public key validation as well.
+ 	 */
+ 	if ((hdev->commands[41] & 0x08) || msft_curve_validity(hdev))
+ 		flags |= 0x01;	/* Remote public key validation (BR/EDR) */
+ 
+ 	flags |= 0x02;		/* Remote public key validation (LE) */
+ 
+ 	/* When the Read Encryption Key Size command is supported, then the
+ 	 * encryption key size is enforced.
+ 	 */
+ 	if (hdev->commands[20] & 0x10)
+ 		flags |= 0x04;	/* Encryption key size enforcement (BR/EDR) */
+ 
+ 	flags |= 0x08;		/* Encryption key size enforcement (LE) */
+ 
+ 	cap_len = eir_append_data(rp->cap, cap_len, MGMT_CAP_SEC_FLAGS,
+ 				  &flags, 1);
+ 
+ 	/* When the Read Simple Pairing Options command is supported, then
+ 	 * also max encryption key size information is provided.
+ 	 */
+ 	if (hdev->commands[41] & 0x08)
+ 		cap_len = eir_append_le16(rp->cap, cap_len,
+ 					  MGMT_CAP_MAX_ENC_KEY_SIZE,
+ 					  hdev->max_enc_key_size);
+ 
+ 	cap_len = eir_append_le16(rp->cap, cap_len,
+ 				  MGMT_CAP_SMP_MAX_ENC_KEY_SIZE,
+ 				  SMP_MAX_ENC_KEY_SIZE);
+ 
+ 	/* Append the min/max LE tx power parameters if we were able to fetch
+ 	 * it from the controller
+ 	 */
+ 	if (hdev->commands[38] & 0x80) {
+ 		memcpy(&tx_power_range[0], &hdev->min_le_tx_power, 1);
+ 		memcpy(&tx_power_range[1], &hdev->max_le_tx_power, 1);
+ 		cap_len = eir_append_data(rp->cap, cap_len, MGMT_CAP_LE_TX_PWR,
+ 					  tx_power_range, 2);
+ 	}
+ 
+ 	rp->cap_len = cpu_to_le16(cap_len);
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_CONTROLLER_CAP, 0,
+ 				 rp, sizeof(*rp) + cap_len);
+ }
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ /* d4992530-b9ec-469f-ab01-6c481c47da1c */
+ static const u8 debug_uuid[16] = {
+ 	0x1c, 0xda, 0x47, 0x1c, 0x48, 0x6c, 0x01, 0xab,
+ 	0x9f, 0x46, 0xec, 0xb9, 0x30, 0x25, 0x99, 0xd4,
+ };
+ #endif
+ 
+ /* 671b10b5-42c0-4696-9227-eb28d1b049d6 */
+ static const u8 simult_central_periph_uuid[16] = {
+ 	0xd6, 0x49, 0xb0, 0xd1, 0x28, 0xeb, 0x27, 0x92,
+ 	0x96, 0x46, 0xc0, 0x42, 0xb5, 0x10, 0x1b, 0x67,
+ };
+ 
+ /* 15c0a148-c273-11ea-b3de-0242ac130004 */
+ static const u8 rpa_resolution_uuid[16] = {
+ 	0x04, 0x00, 0x13, 0xac, 0x42, 0x02, 0xde, 0xb3,
+ 	0xea, 0x11, 0x73, 0xc2, 0x48, 0xa1, 0xc0, 0x15,
+ };
+ 
+ static int read_exp_features_info(struct sock *sk, struct hci_dev *hdev,
+ 				  void *data, u16 data_len)
+ {
+ 	char buf[62];	/* Enough space for 3 features */
+ 	struct mgmt_rp_read_exp_features_info *rp = (void *)buf;
+ 	u16 idx = 0;
+ 	u32 flags;
+ 
+ 	bt_dev_dbg(hdev, "sock %p", sk);
+ 
+ 	memset(&buf, 0, sizeof(buf));
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ 	if (!hdev) {
+ 		flags = bt_dbg_get() ? BIT(0) : 0;
+ 
+ 		memcpy(rp->features[idx].uuid, debug_uuid, 16);
+ 		rp->features[idx].flags = cpu_to_le32(flags);
+ 		idx++;
+ 	}
+ #endif
+ 
+ 	if (hdev) {
+ 		if (test_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks) &&
+ 		    (hdev->le_states[4] & 0x08) &&	/* Central */
+ 		    (hdev->le_states[4] & 0x40) &&	/* Peripheral */
+ 		    (hdev->le_states[3] & 0x10))	/* Simultaneous */
+ 			flags = BIT(0);
+ 		else
+ 			flags = 0;
+ 
+ 		memcpy(rp->features[idx].uuid, simult_central_periph_uuid, 16);
+ 		rp->features[idx].flags = cpu_to_le32(flags);
+ 		idx++;
+ 	}
+ 
+ 	if (hdev && use_ll_privacy(hdev)) {
+ 		if (hci_dev_test_flag(hdev, HCI_ENABLE_LL_PRIVACY))
+ 			flags = BIT(0) | BIT(1);
+ 		else
+ 			flags = BIT(1);
+ 
+ 		memcpy(rp->features[idx].uuid, rpa_resolution_uuid, 16);
+ 		rp->features[idx].flags = cpu_to_le32(flags);
+ 		idx++;
+ 	}
+ 
+ 	rp->feature_count = cpu_to_le16(idx);
+ 
+ 	/* After reading the experimental features information, enable
+ 	 * the events to update client on any future change.
+ 	 */
+ 	hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 	return mgmt_cmd_complete(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
+ 				 MGMT_OP_READ_EXP_FEATURES_INFO,
+ 				 0, rp, sizeof(*rp) + (20 * idx));
+ }
+ 
+ static int exp_ll_privacy_feature_changed(bool enabled, struct hci_dev *hdev,
+ 					  struct sock *skip)
+ {
+ 	struct mgmt_ev_exp_feature_changed ev;
+ 
+ 	memset(&ev, 0, sizeof(ev));
+ 	memcpy(ev.uuid, rpa_resolution_uuid, 16);
+ 	ev.flags = cpu_to_le32((enabled ? BIT(0) : 0) | BIT(1));
+ 
+ 	return mgmt_limited_event(MGMT_EV_EXP_FEATURE_CHANGED, hdev,
+ 				  &ev, sizeof(ev),
+ 				  HCI_MGMT_EXP_FEATURE_EVENTS, skip);
+ 
+ }
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ static int exp_debug_feature_changed(bool enabled, struct sock *skip)
+ {
+ 	struct mgmt_ev_exp_feature_changed ev;
+ 
+ 	memset(&ev, 0, sizeof(ev));
+ 	memcpy(ev.uuid, debug_uuid, 16);
+ 	ev.flags = cpu_to_le32(enabled ? BIT(0) : 0);
+ 
+ 	return mgmt_limited_event(MGMT_EV_EXP_FEATURE_CHANGED, NULL,
+ 				  &ev, sizeof(ev),
+ 				  HCI_MGMT_EXP_FEATURE_EVENTS, skip);
+ }
+ #endif
+ 
+ static int set_exp_feature(struct sock *sk, struct hci_dev *hdev,
+ 			   void *data, u16 data_len)
+ {
+ 	struct mgmt_cp_set_exp_feature *cp = data;
+ 	struct mgmt_rp_set_exp_feature rp;
+ 
+ 	bt_dev_dbg(hdev, "sock %p", sk);
+ 
+ 	if (!memcmp(cp->uuid, ZERO_KEY, 16)) {
+ 		memset(rp.uuid, 0, 16);
+ 		rp.flags = cpu_to_le32(0);
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ 		if (!hdev) {
+ 			bool changed = bt_dbg_get();
+ 
+ 			bt_dbg_set(false);
+ 
+ 			if (changed)
+ 				exp_debug_feature_changed(false, sk);
+ 		}
+ #endif
+ 
+ 		if (hdev && use_ll_privacy(hdev) && !hdev_is_powered(hdev)) {
+ 			bool changed = hci_dev_test_flag(hdev,
+ 							 HCI_ENABLE_LL_PRIVACY);
+ 
+ 			hci_dev_clear_flag(hdev, HCI_ENABLE_LL_PRIVACY);
+ 
+ 			if (changed)
+ 				exp_ll_privacy_feature_changed(false, hdev, sk);
+ 		}
+ 
+ 		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 		return mgmt_cmd_complete(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
+ 					 MGMT_OP_SET_EXP_FEATURE, 0,
+ 					 &rp, sizeof(rp));
+ 	}
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ 	if (!memcmp(cp->uuid, debug_uuid, 16)) {
+ 		bool val, changed;
+ 		int err;
+ 
+ 		/* Command requires to use the non-controller index */
+ 		if (hdev)
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_INDEX);
+ 
+ 		/* Parameters are limited to a single octet */
+ 		if (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)
+ 			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		/* Only boolean on/off is supported */
+ 		if (cp->param[0] != 0x00 && cp->param[0] != 0x01)
+ 			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		val = !!cp->param[0];
+ 		changed = val ? !bt_dbg_get() : bt_dbg_get();
+ 		bt_dbg_set(val);
+ 
+ 		memcpy(rp.uuid, debug_uuid, 16);
+ 		rp.flags = cpu_to_le32(val ? BIT(0) : 0);
+ 
+ 		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 		err = mgmt_cmd_complete(sk, MGMT_INDEX_NONE,
+ 					MGMT_OP_SET_EXP_FEATURE, 0,
+ 					&rp, sizeof(rp));
+ 
+ 		if (changed)
+ 			exp_debug_feature_changed(val, sk);
+ 
+ 		return err;
+ 	}
+ #endif
+ 
+ 	if (!memcmp(cp->uuid, rpa_resolution_uuid, 16)) {
+ 		bool val, changed;
+ 		int err;
+ 		u32 flags;
+ 
+ 		/* Command requires to use the controller index */
+ 		if (!hdev)
+ 			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_INDEX);
+ 
+ 		/* Changes can only be made when controller is powered down */
+ 		if (hdev_is_powered(hdev))
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_REJECTED);
+ 
+ 		/* Parameters are limited to a single octet */
+ 		if (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		/* Only boolean on/off is supported */
+ 		if (cp->param[0] != 0x00 && cp->param[0] != 0x01)
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		val = !!cp->param[0];
+ 
+ 		if (val) {
+ 			changed = !hci_dev_test_flag(hdev,
+ 						     HCI_ENABLE_LL_PRIVACY);
+ 			hci_dev_set_flag(hdev, HCI_ENABLE_LL_PRIVACY);
+ 			hci_dev_clear_flag(hdev, HCI_ADVERTISING);
+ 
+ 			/* Enable LL privacy + supported settings changed */
+ 			flags = BIT(0) | BIT(1);
+ 		} else {
+ 			changed = hci_dev_test_flag(hdev,
+ 						    HCI_ENABLE_LL_PRIVACY);
+ 			hci_dev_clear_flag(hdev, HCI_ENABLE_LL_PRIVACY);
+ 
+ 			/* Disable LL privacy + supported settings changed */
+ 			flags = BIT(1);
+ 		}
+ 
+ 		memcpy(rp.uuid, rpa_resolution_uuid, 16);
+ 		rp.flags = cpu_to_le32(flags);
+ 
+ 		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 		err = mgmt_cmd_complete(sk, hdev->id,
+ 					MGMT_OP_SET_EXP_FEATURE, 0,
+ 					&rp, sizeof(rp));
+ 
+ 		if (changed)
+ 			exp_ll_privacy_feature_changed(val, hdev, sk);
+ 
+ 		return err;
+ 	}
+ 
+ 	return mgmt_cmd_status(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
+ 			       MGMT_OP_SET_EXP_FEATURE,
+ 			       MGMT_STATUS_NOT_SUPPORTED);
+ }
+ 
+ #define SUPPORTED_DEVICE_FLAGS() ((1U << HCI_CONN_FLAG_MAX) - 1)
+ 
+ static int get_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,
+ 			    u16 data_len)
+ {
+ 	struct mgmt_cp_get_device_flags *cp = data;
+ 	struct mgmt_rp_get_device_flags rp;
+ 	struct bdaddr_list_with_flags *br_params;
+ 	struct hci_conn_params *params;
+ 	u32 supported_flags = SUPPORTED_DEVICE_FLAGS();
+ 	u32 current_flags = 0;
+ 	u8 status = MGMT_STATUS_INVALID_PARAMS;
+ 
+ 	bt_dev_dbg(hdev, "Get device flags %pMR (type 0x%x)\n",
+ 		   &cp->addr.bdaddr, cp->addr.type);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	memset(&rp, 0, sizeof(rp));
+ 
+ 	if (cp->addr.type == BDADDR_BREDR) {
+ 		br_params = hci_bdaddr_list_lookup_with_flags(&hdev->accept_list,
+ 							      &cp->addr.bdaddr,
+ 							      cp->addr.type);
+ 		if (!br_params)
+ 			goto done;
+ 
+ 		current_flags = br_params->current_flags;
+ 	} else {
+ 		params = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,
+ 						le_addr_type(cp->addr.type));
+ 
+ 		if (!params)
+ 			goto done;
+ 
+ 		current_flags = params->current_flags;
+ 	}
+ 
+ 	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
+ 	rp.addr.type = cp->addr.type;
+ 	rp.supported_flags = cpu_to_le32(supported_flags);
+ 	rp.current_flags = cpu_to_le32(current_flags);
+ 
+ 	status = MGMT_STATUS_SUCCESS;
+ 
+ done:
+ 	hci_dev_unlock(hdev);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_DEVICE_FLAGS, status,
+ 				&rp, sizeof(rp));
+ }
+ 
+ static void device_flags_changed(struct sock *sk, struct hci_dev *hdev,
+ 				 bdaddr_t *bdaddr, u8 bdaddr_type,
+ 				 u32 supported_flags, u32 current_flags)
+ {
+ 	struct mgmt_ev_device_flags_changed ev;
+ 
+ 	bacpy(&ev.addr.bdaddr, bdaddr);
+ 	ev.addr.type = bdaddr_type;
+ 	ev.supported_flags = cpu_to_le32(supported_flags);
+ 	ev.current_flags = cpu_to_le32(current_flags);
+ 
+ 	mgmt_event(MGMT_EV_DEVICE_FLAGS_CHANGED, hdev, &ev, sizeof(ev), sk);
+ }
+ 
+ static int set_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,
+ 			    u16 len)
+ {
+ 	struct mgmt_cp_set_device_flags *cp = data;
+ 	struct bdaddr_list_with_flags *br_params;
+ 	struct hci_conn_params *params;
+ 	u8 status = MGMT_STATUS_INVALID_PARAMS;
+ 	u32 supported_flags = SUPPORTED_DEVICE_FLAGS();
+ 	u32 current_flags = __le32_to_cpu(cp->current_flags);
+ 
+ 	bt_dev_dbg(hdev, "Set device flags %pMR (type 0x%x) = 0x%x",
+ 		   &cp->addr.bdaddr, cp->addr.type,
+ 		   __le32_to_cpu(current_flags));
+ 
+ 	if ((supported_flags | current_flags) != supported_flags) {
+ 		bt_dev_warn(hdev, "Bad flag given (0x%x) vs supported (0x%0x)",
+ 			    current_flags, supported_flags);
+ 		goto done;
+ 	}
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	if (cp->addr.type == BDADDR_BREDR) {
+ 		br_params = hci_bdaddr_list_lookup_with_flags(&hdev->accept_list,
+ 							      &cp->addr.bdaddr,
+ 							      cp->addr.type);
+ 
+ 		if (br_params) {
+ 			br_params->current_flags = current_flags;
+ 			status = MGMT_STATUS_SUCCESS;
+ 		} else {
+ 			bt_dev_warn(hdev, "No such BR/EDR device %pMR (0x%x)",
+ 				    &cp->addr.bdaddr, cp->addr.type);
+ 		}
+ 	} else {
+ 		params = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,
+ 						le_addr_type(cp->addr.type));
+ 		if (params) {
+ 			params->current_flags = current_flags;
+ 			status = MGMT_STATUS_SUCCESS;
+ 		} else {
+ 			bt_dev_warn(hdev, "No such LE device %pMR (0x%x)",
+ 				    &cp->addr.bdaddr,
+ 				    le_addr_type(cp->addr.type));
+ 		}
+ 	}
+ 
+ done:
+ 	hci_dev_unlock(hdev);
+ 
+ 	if (status == MGMT_STATUS_SUCCESS)
+ 		device_flags_changed(sk, hdev, &cp->addr.bdaddr, cp->addr.type,
+ 				     supported_flags, current_flags);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_DEVICE_FLAGS, status,
+ 				 &cp->addr, sizeof(cp->addr));
+ }
+ 
+ static void mgmt_adv_monitor_added(struct sock *sk, struct hci_dev *hdev,
+ 				   u16 handle)
+ {
+ 	struct mgmt_ev_adv_monitor_added ev;
+ 
+ 	ev.monitor_handle = cpu_to_le16(handle);
+ 
+ 	mgmt_event(MGMT_EV_ADV_MONITOR_ADDED, hdev, &ev, sizeof(ev), sk);
+ }
+ 
+ void mgmt_adv_monitor_removed(struct hci_dev *hdev, u16 handle)
+ {
+ 	struct mgmt_ev_adv_monitor_removed ev;
+ 	struct mgmt_pending_cmd *cmd;
+ 	struct sock *sk_skip = NULL;
+ 	struct mgmt_cp_remove_adv_monitor *cp;
+ 
+ 	cmd = pending_find(MGMT_OP_REMOVE_ADV_MONITOR, hdev);
+ 	if (cmd) {
+ 		cp = cmd->param;
+ 
+ 		if (cp->monitor_handle)
+ 			sk_skip = cmd->sk;
+ 	}
+ 
+ 	ev.monitor_handle = cpu_to_le16(handle);
+ 
+ 	mgmt_event(MGMT_EV_ADV_MONITOR_REMOVED, hdev, &ev, sizeof(ev), sk_skip);
+ }
+ 
+ static int read_adv_mon_features(struct sock *sk, struct hci_dev *hdev,
+ 				 void *data, u16 len)
+ {
+ 	struct adv_monitor *monitor = NULL;
+ 	struct mgmt_rp_read_adv_monitor_features *rp = NULL;
+ 	int handle, err;
+ 	size_t rp_size = 0;
+ 	__u32 supported = 0;
+ 	__u32 enabled = 0;
+ 	__u16 num_handles = 0;
+ 	__u16 handles[HCI_MAX_ADV_MONITOR_NUM_HANDLES];
+ 
+ 	BT_DBG("request for %s", hdev->name);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	if (msft_monitor_supported(hdev))
+ 		supported |= MGMT_ADV_MONITOR_FEATURE_MASK_OR_PATTERNS;
+ 
+ 	idr_for_each_entry(&hdev->adv_monitors_idr, monitor, handle)
+ 		handles[num_handles++] = monitor->handle;
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	rp_size = sizeof(*rp) + (num_handles * sizeof(u16));
+ 	rp = kmalloc(rp_size, GFP_KERNEL);
+ 	if (!rp)
+ 		return -ENOMEM;
+ 
+ 	/* All supported features are currently enabled */
+ 	enabled = supported;
+ 
+ 	rp->supported_features = cpu_to_le32(supported);
+ 	rp->enabled_features = cpu_to_le32(enabled);
+ 	rp->max_num_handles = cpu_to_le16(HCI_MAX_ADV_MONITOR_NUM_HANDLES);
+ 	rp->max_num_patterns = HCI_MAX_ADV_MONITOR_NUM_PATTERNS;
+ 	rp->num_handles = cpu_to_le16(num_handles);
+ 	if (num_handles)
+ 		memcpy(&rp->handles, &handles, (num_handles * sizeof(u16)));
+ 
+ 	err = mgmt_cmd_complete(sk, hdev->id,
+ 				MGMT_OP_READ_ADV_MONITOR_FEATURES,
+ 				MGMT_STATUS_SUCCESS, rp, rp_size);
+ 
+ 	kfree(rp);
+ 
+ 	return err;
+ }
+ 
+ int mgmt_add_adv_patterns_monitor_complete(struct hci_dev *hdev, u8 status)
+ {
+ 	struct mgmt_rp_add_adv_patterns_monitor rp;
+ 	struct mgmt_pending_cmd *cmd;
+ 	struct adv_monitor *monitor;
+ 	int err = 0;
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	cmd = pending_find(MGMT_OP_ADD_ADV_PATTERNS_MONITOR_RSSI, hdev);
+ 	if (!cmd) {
+ 		cmd = pending_find(MGMT_OP_ADD_ADV_PATTERNS_MONITOR, hdev);
+ 		if (!cmd)
+ 			goto done;
+ 	}
+ 
+ 	monitor = cmd->user_data;
+ 	rp.monitor_handle = cpu_to_le16(monitor->handle);
+ 
+ 	if (!status) {
+ 		mgmt_adv_monitor_added(cmd->sk, hdev, monitor->handle);
+ 		hdev->adv_monitors_cnt++;
+ 		if (monitor->state == ADV_MONITOR_STATE_NOT_REGISTERED)
+ 			monitor->state = ADV_MONITOR_STATE_REGISTERED;
+ 		hci_update_background_scan(hdev);
+ 	}
+ 
+ 	err = mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,
+ 				mgmt_status(status), &rp, sizeof(rp));
+ 	mgmt_pending_remove(cmd);
+ 
+ done:
+ 	hci_dev_unlock(hdev);
+ 	bt_dev_dbg(hdev, "add monitor %d complete, status %u",
+ 		   rp.monitor_handle, status);
+ 
+ 	return err;
+ }
+ 
+ static int __add_adv_patterns_monitor(struct sock *sk, struct hci_dev *hdev,
+ 				      struct adv_monitor *m, u8 status,
+ 				      void *data, u16 len, u16 op)
+ {
+ 	struct mgmt_rp_add_adv_patterns_monitor rp;
+ 	struct mgmt_pending_cmd *cmd;
+ 	int err;
+ 	bool pending;
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	if (status)
+ 		goto unlock;
+ 
+ 	if (pending_find(MGMT_OP_SET_LE, hdev) ||
+ 	    pending_find(MGMT_OP_ADD_ADV_PATTERNS_MONITOR, hdev) ||
+ 	    pending_find(MGMT_OP_ADD_ADV_PATTERNS_MONITOR_RSSI, hdev) ||
+ 	    pending_find(MGMT_OP_REMOVE_ADV_MONITOR, hdev)) {
+ 		status = MGMT_STATUS_BUSY;
+ 		goto unlock;
+ 	}
+ 
+ 	cmd = mgmt_pending_add(sk, op, hdev, data, len);
+ 	if (!cmd) {
+ 		status = MGMT_STATUS_NO_RESOURCES;
+ 		goto unlock;
+ 	}
+ 
+ 	cmd->user_data = m;
+ 	pending = hci_add_adv_monitor(hdev, m, &err);
+ 	if (err) {
+ 		if (err == -ENOSPC || err == -ENOMEM)
+ 			status = MGMT_STATUS_NO_RESOURCES;
+ 		else if (err == -EINVAL)
+ 			status = MGMT_STATUS_INVALID_PARAMS;
+ 		else
+ 			status = MGMT_STATUS_FAILED;
+ 
+ 		mgmt_pending_remove(cmd);
+ 		goto unlock;
+ 	}
+ 
+ 	if (!pending) {
+ 		mgmt_pending_remove(cmd);
+ 		rp.monitor_handle = cpu_to_le16(m->handle);
+ 		mgmt_adv_monitor_added(sk, hdev, m->handle);
+ 		m->state = ADV_MONITOR_STATE_REGISTERED;
+ 		hdev->adv_monitors_cnt++;
+ 
+ 		hci_dev_unlock(hdev);
+ 		return mgmt_cmd_complete(sk, hdev->id, op, MGMT_STATUS_SUCCESS,
+ 					 &rp, sizeof(rp));
+ 	}
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	return 0;
+ 
+ unlock:
+ 	hci_free_adv_monitor(hdev, m);
+ 	hci_dev_unlock(hdev);
+ 	return mgmt_cmd_status(sk, hdev->id, op, status);
+ }
+ 
+ static void parse_adv_monitor_rssi(struct adv_monitor *m,
+ 				   struct mgmt_adv_rssi_thresholds *rssi)
+ {
+ 	if (rssi) {
+ 		m->rssi.low_threshold = rssi->low_threshold;
+ 		m->rssi.low_threshold_timeout =
+ 		    __le16_to_cpu(rssi->low_threshold_timeout);
+ 		m->rssi.high_threshold = rssi->high_threshold;
+ 		m->rssi.high_threshold_timeout =
+ 		    __le16_to_cpu(rssi->high_threshold_timeout);
+ 		m->rssi.sampling_period = rssi->sampling_period;
+ 	} else {
+ 		/* Default values. These numbers are the least constricting
+ 		 * parameters for MSFT API to work, so it behaves as if there
+ 		 * are no rssi parameter to consider. May need to be changed
+ 		 * if other API are to be supported.
+ 		 */
+ 		m->rssi.low_threshold = -127;
+ 		m->rssi.low_threshold_timeout = 60;
+ 		m->rssi.high_threshold = -127;
+ 		m->rssi.high_threshold_timeout = 0;
+ 		m->rssi.sampling_period = 0;
+ 	}
+ }
+ 
+ static u8 parse_adv_monitor_pattern(struct adv_monitor *m, u8 pattern_count,
+ 				    struct mgmt_adv_pattern *patterns)
+ {
+ 	u8 offset = 0, length = 0;
+ 	struct adv_pattern *p = NULL;
++>>>>>>> 3d4f9c00492b (Bluetooth: use inclusive language when filtering devices)
  	int i;
  
 -	for (i = 0; i < pattern_count; i++) {
 -		offset = patterns[i].offset;
 -		length = patterns[i].length;
 -		if (offset >= HCI_MAX_AD_LENGTH ||
 -		    length > HCI_MAX_AD_LENGTH ||
 -		    (offset + length) > HCI_MAX_AD_LENGTH)
 -			return MGMT_STATUS_INVALID_PARAMS;
 -
 -		p = kmalloc(sizeof(*p), GFP_KERNEL);
 -		if (!p)
 -			return MGMT_STATUS_NO_RESOURCES;
 -
 -		p->ad_type = patterns[i].ad_type;
 -		p->offset = patterns[i].offset;
 -		p->length = patterns[i].length;
 -		memcpy(p->value, patterns[i].value, p->length);
 -
 -		INIT_LIST_HEAD(&p->list);
 -		list_add(&p->list, &m->patterns);
 -	}
 -
 -	return MGMT_STATUS_SUCCESS;
 -}
 -
 -static int add_adv_patterns_monitor(struct sock *sk, struct hci_dev *hdev,
 -				    void *data, u16 len)
 -{
 -	struct mgmt_cp_add_adv_patterns_monitor *cp = data;
 -	struct adv_monitor *m = NULL;
 -	u8 status = MGMT_STATUS_SUCCESS;
 -	size_t expected_size = sizeof(*cp);
 -
 -	BT_DBG("request for %s", hdev->name);
 -
 -	if (len <= sizeof(*cp)) {
 -		status = MGMT_STATUS_INVALID_PARAMS;
 -		goto done;
 -	}
 -
 -	expected_size += cp->pattern_count * sizeof(struct mgmt_adv_pattern);
 -	if (len != expected_size) {
 -		status = MGMT_STATUS_INVALID_PARAMS;
 -		goto done;
 -	}
 -
 -	m = kzalloc(sizeof(*m), GFP_KERNEL);
 -	if (!m) {
 -		status = MGMT_STATUS_NO_RESOURCES;
 -		goto done;
 -	}
 -
 -	INIT_LIST_HEAD(&m->patterns);
 -
 -	parse_adv_monitor_rssi(m, NULL);
 -	status = parse_adv_monitor_pattern(m, cp->pattern_count, cp->patterns);
 -
 -done:
 -	return __add_adv_patterns_monitor(sk, hdev, m, status, data, len,
 -					  MGMT_OP_ADD_ADV_PATTERNS_MONITOR);
 -}
 -
 -static int add_adv_patterns_monitor_rssi(struct sock *sk, struct hci_dev *hdev,
 -					 void *data, u16 len)
 -{
 -	struct mgmt_cp_add_adv_patterns_monitor_rssi *cp = data;
 -	struct adv_monitor *m = NULL;
 -	u8 status = MGMT_STATUS_SUCCESS;
 -	size_t expected_size = sizeof(*cp);
 -
  	BT_DBG("request for %s", hdev->name);
  
 -	if (len <= sizeof(*cp)) {
 -		status = MGMT_STATUS_INVALID_PARAMS;
 -		goto done;
 -	}
 -
 -	expected_size += cp->pattern_count * sizeof(struct mgmt_adv_pattern);
 -	if (len != expected_size) {
 -		status = MGMT_STATUS_INVALID_PARAMS;
 -		goto done;
 +	key_count = __le16_to_cpu(keys->key_count);
 +	if (key_count > max_key_count) {
 +		bt_dev_err(hdev, "too big key_count value %u", key_count);
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				       MGMT_STATUS_INVALID_PARAMS);
  	}
  
 -	m = kzalloc(sizeof(*m), GFP_KERNEL);
 -	if (!m) {
 -		status = MGMT_STATUS_NO_RESOURCES;
 -		goto done;
 +	expected_len = struct_size(keys, keys, key_count);
 +	if (expected_len != len) {
 +		bt_dev_err(hdev, "expected %u bytes, got %u bytes",
 +			   expected_len, len);
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				       MGMT_STATUS_INVALID_PARAMS);
  	}
  
 -	INIT_LIST_HEAD(&m->patterns);
 -
 -	parse_adv_monitor_rssi(m, &cp->rssi);
 -	status = parse_adv_monitor_pattern(m, cp->pattern_count, cp->patterns);
 -
 -done:
 -	return __add_adv_patterns_monitor(sk, hdev, m, status, data, len,
 -					 MGMT_OP_ADD_ADV_PATTERNS_MONITOR_RSSI);
 -}
 -
 -int mgmt_remove_adv_monitor_complete(struct hci_dev *hdev, u8 status)
 -{
 -	struct mgmt_rp_remove_adv_monitor rp;
 -	struct mgmt_cp_remove_adv_monitor *cp;
 -	struct mgmt_pending_cmd *cmd;
 -	int err = 0;
 -
 -	hci_dev_lock(hdev);
 -
 -	cmd = pending_find(MGMT_OP_REMOVE_ADV_MONITOR, hdev);
 -	if (!cmd)
 -		goto done;
 -
 -	cp = cmd->param;
 -	rp.monitor_handle = cp->monitor_handle;
 -
 -	if (!status)
 -		hci_update_background_scan(hdev);
 -
 -	err = mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,
 -				mgmt_status(status), &rp, sizeof(rp));
 -	mgmt_pending_remove(cmd);
 -
 -done:
 -	hci_dev_unlock(hdev);
 -	bt_dev_dbg(hdev, "remove monitor %d complete, status %u",
 -		   rp.monitor_handle, status);
 -
 -	return err;
 -}
 -
 -static int remove_adv_monitor(struct sock *sk, struct hci_dev *hdev,
 -			      void *data, u16 len)
 -{
 -	struct mgmt_cp_remove_adv_monitor *cp = data;
 -	struct mgmt_rp_remove_adv_monitor rp;
 -	struct mgmt_pending_cmd *cmd;
 -	u16 handle = __le16_to_cpu(cp->monitor_handle);
 -	int err, status;
 -	bool pending;
 -
 -	BT_DBG("request for %s", hdev->name);
 -	rp.monitor_handle = cp->monitor_handle;
 -
  	hci_dev_lock(hdev);
  
 -	if (pending_find(MGMT_OP_SET_LE, hdev) ||
 -	    pending_find(MGMT_OP_REMOVE_ADV_MONITOR, hdev) ||
 -	    pending_find(MGMT_OP_ADD_ADV_PATTERNS_MONITOR, hdev) ||
 -	    pending_find(MGMT_OP_ADD_ADV_PATTERNS_MONITOR_RSSI, hdev)) {
 -		status = MGMT_STATUS_BUSY;
 -		goto unlock;
 -	}
 -
 -	cmd = mgmt_pending_add(sk, MGMT_OP_REMOVE_ADV_MONITOR, hdev, data, len);
 -	if (!cmd) {
 -		status = MGMT_STATUS_NO_RESOURCES;
 -		goto unlock;
 -	}
 -
 -	if (handle)
 -		pending = hci_remove_single_adv_monitor(hdev, handle, &err);
 -	else
 -		pending = hci_remove_all_adv_monitor(hdev, &err);
 -
 -	if (err) {
 -		mgmt_pending_remove(cmd);
 -
 -		if (err == -ENOENT)
 -			status = MGMT_STATUS_INVALID_INDEX;
 -		else
 -			status = MGMT_STATUS_FAILED;
 +	hci_blocked_keys_clear(hdev);
  
 -		goto unlock;
 -	}
 +	for (i = 0; i < keys->key_count; ++i) {
 +		struct blocked_key *b = kzalloc(sizeof(*b), GFP_KERNEL);
  
 -	/* monitor can be removed without forwarding request to controller */
 -	if (!pending) {
 -		mgmt_pending_remove(cmd);
 -		hci_dev_unlock(hdev);
 +		if (!b) {
 +			err = MGMT_STATUS_NO_RESOURCES;
 +			break;
 +		}
  
 -		return mgmt_cmd_complete(sk, hdev->id,
 -					 MGMT_OP_REMOVE_ADV_MONITOR,
 -					 MGMT_STATUS_SUCCESS,
 -					 &rp, sizeof(rp));
 +		b->type = keys->keys[i].type;
 +		memcpy(b->val, keys->keys[i].val, sizeof(b->val));
 +		list_add_rcu(&b->list, &hdev->blocked_keys);
  	}
 -
  	hci_dev_unlock(hdev);
 -	return 0;
  
 -unlock:
 -	hci_dev_unlock(hdev);
 -	return mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_ADV_MONITOR,
 -			       status);
 +	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				err, NULL, 0);
  }
  
  static void read_local_oob_data_complete(struct hci_dev *hdev, u8 status,
diff --git a/include/net/bluetooth/hci.h b/include/net/bluetooth/hci.h
index f920fd31923e..77cf2334b7e2 100644
--- a/include/net/bluetooth/hci.h
+++ b/include/net/bluetooth/hci.h
@@ -1502,7 +1502,7 @@ struct hci_cp_le_set_scan_enable {
 } __packed;
 
 #define HCI_LE_USE_PEER_ADDR		0x00
-#define HCI_LE_USE_WHITELIST		0x01
+#define HCI_LE_USE_ACCEPT_LIST		0x01
 
 #define HCI_OP_LE_CREATE_CONN		0x200d
 struct hci_cp_le_create_conn {
@@ -1522,22 +1522,22 @@ struct hci_cp_le_create_conn {
 
 #define HCI_OP_LE_CREATE_CONN_CANCEL	0x200e
 
-#define HCI_OP_LE_READ_WHITE_LIST_SIZE	0x200f
-struct hci_rp_le_read_white_list_size {
+#define HCI_OP_LE_READ_ACCEPT_LIST_SIZE	0x200f
+struct hci_rp_le_read_accept_list_size {
 	__u8	status;
 	__u8	size;
 } __packed;
 
-#define HCI_OP_LE_CLEAR_WHITE_LIST	0x2010
+#define HCI_OP_LE_CLEAR_ACCEPT_LIST	0x2010
 
-#define HCI_OP_LE_ADD_TO_WHITE_LIST	0x2011
-struct hci_cp_le_add_to_white_list {
+#define HCI_OP_LE_ADD_TO_ACCEPT_LIST	0x2011
+struct hci_cp_le_add_to_accept_list {
 	__u8     bdaddr_type;
 	bdaddr_t bdaddr;
 } __packed;
 
-#define HCI_OP_LE_DEL_FROM_WHITE_LIST	0x2012
-struct hci_cp_le_del_from_white_list {
+#define HCI_OP_LE_DEL_FROM_ACCEPT_LIST	0x2012
+struct hci_cp_le_del_from_accept_list {
 	__u8     bdaddr_type;
 	bdaddr_t bdaddr;
 } __packed;
diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9461b0b6884e..38c27eadc27c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -289,7 +289,7 @@ struct hci_dev {
 	__u8		max_page;
 	__u8		features[HCI_MAX_PAGES][8];
 	__u8		le_features[8];
-	__u8		le_white_list_size;
+	__u8		le_accept_list_size;
 	__u8		le_resolv_list_size;
 	__u8		le_num_of_adv_sets;
 	__u8		le_states[8];
@@ -475,14 +475,14 @@ struct hci_dev {
 	struct hci_conn_hash	conn_hash;
 
 	struct list_head	mgmt_pending;
-	struct list_head	blacklist;
-	struct list_head	whitelist;
+	struct list_head	reject_list;
+	struct list_head	accept_list;
 	struct list_head	uuids;
 	struct list_head	link_keys;
 	struct list_head	long_term_keys;
 	struct list_head	identity_resolving_keys;
 	struct list_head	remote_oob_data;
-	struct list_head	le_white_list;
+	struct list_head	le_accept_list;
 	struct list_head	le_resolv_list;
 	struct list_head	le_conn_params;
 	struct list_head	pend_le_conns;
* Unmerged path net/bluetooth/hci_core.c
diff --git a/net/bluetooth/hci_debugfs.c b/net/bluetooth/hci_debugfs.c
index 47f4f21fbc1a..841393389f7b 100644
--- a/net/bluetooth/hci_debugfs.c
+++ b/net/bluetooth/hci_debugfs.c
@@ -125,7 +125,7 @@ static int device_list_show(struct seq_file *f, void *ptr)
 	struct bdaddr_list *b;
 
 	hci_dev_lock(hdev);
-	list_for_each_entry(b, &hdev->whitelist, list)
+	list_for_each_entry(b, &hdev->accept_list, list)
 		seq_printf(f, "%pMR (type %u)\n", &b->bdaddr, b->bdaddr_type);
 	list_for_each_entry(p, &hdev->le_conn_params, list) {
 		seq_printf(f, "%pMR (type %u) %u\n", &p->addr, p->addr_type,
@@ -144,7 +144,7 @@ static int blacklist_show(struct seq_file *f, void *p)
 	struct bdaddr_list *b;
 
 	hci_dev_lock(hdev);
-	list_for_each_entry(b, &hdev->blacklist, list)
+	list_for_each_entry(b, &hdev->reject_list, list)
 		seq_printf(f, "%pMR (type %u)\n", &b->bdaddr, b->bdaddr_type);
 	hci_dev_unlock(hdev);
 
@@ -784,7 +784,7 @@ static int white_list_show(struct seq_file *f, void *ptr)
 	struct bdaddr_list *b;
 
 	hci_dev_lock(hdev);
-	list_for_each_entry(b, &hdev->le_white_list, list)
+	list_for_each_entry(b, &hdev->le_accept_list, list)
 		seq_printf(f, "%pMR (type %u)\n", &b->bdaddr, b->bdaddr_type);
 	hci_dev_unlock(hdev);
 
@@ -1195,7 +1195,7 @@ void hci_debugfs_create_le(struct hci_dev *hdev)
 				    &force_static_address_fops);
 
 	debugfs_create_u8("white_list_size", 0444, hdev->debugfs,
-			  &hdev->le_white_list_size);
+			  &hdev->le_accept_list_size);
 	debugfs_create_file("white_list", 0444, hdev->debugfs, hdev,
 			    &white_list_fops);
 	debugfs_create_u8("resolv_list_size", 0444, hdev->debugfs,
diff --git a/net/bluetooth/hci_event.c b/net/bluetooth/hci_event.c
index 09b7db533ada..1757a469e8d9 100644
--- a/net/bluetooth/hci_event.c
+++ b/net/bluetooth/hci_event.c
@@ -236,7 +236,7 @@ static void hci_cc_reset(struct hci_dev *hdev, struct sk_buff *skb)
 
 	hdev->ssp_debug_mode = 0;
 
-	hci_bdaddr_list_clear(&hdev->le_white_list);
+	hci_bdaddr_list_clear(&hdev->le_accept_list);
 	hci_bdaddr_list_clear(&hdev->le_resolv_list);
 }
 
@@ -1456,21 +1456,21 @@ static void hci_cc_le_read_num_adv_sets(struct hci_dev *hdev,
 	hdev->le_num_of_adv_sets = rp->num_of_sets;
 }
 
-static void hci_cc_le_read_white_list_size(struct hci_dev *hdev,
-					   struct sk_buff *skb)
+static void hci_cc_le_read_accept_list_size(struct hci_dev *hdev,
+					    struct sk_buff *skb)
 {
-	struct hci_rp_le_read_white_list_size *rp = (void *) skb->data;
+	struct hci_rp_le_read_accept_list_size *rp = (void *)skb->data;
 
 	BT_DBG("%s status 0x%2.2x size %u", hdev->name, rp->status, rp->size);
 
 	if (rp->status)
 		return;
 
-	hdev->le_white_list_size = rp->size;
+	hdev->le_accept_list_size = rp->size;
 }
 
-static void hci_cc_le_clear_white_list(struct hci_dev *hdev,
-				       struct sk_buff *skb)
+static void hci_cc_le_clear_accept_list(struct hci_dev *hdev,
+					struct sk_buff *skb)
 {
 	__u8 status = *((__u8 *) skb->data);
 
@@ -1479,13 +1479,13 @@ static void hci_cc_le_clear_white_list(struct hci_dev *hdev,
 	if (status)
 		return;
 
-	hci_bdaddr_list_clear(&hdev->le_white_list);
+	hci_bdaddr_list_clear(&hdev->le_accept_list);
 }
 
-static void hci_cc_le_add_to_white_list(struct hci_dev *hdev,
-					struct sk_buff *skb)
+static void hci_cc_le_add_to_accept_list(struct hci_dev *hdev,
+					 struct sk_buff *skb)
 {
-	struct hci_cp_le_add_to_white_list *sent;
+	struct hci_cp_le_add_to_accept_list *sent;
 	__u8 status = *((__u8 *) skb->data);
 
 	BT_DBG("%s status 0x%2.2x", hdev->name, status);
@@ -1493,18 +1493,18 @@ static void hci_cc_le_add_to_white_list(struct hci_dev *hdev,
 	if (status)
 		return;
 
-	sent = hci_sent_cmd_data(hdev, HCI_OP_LE_ADD_TO_WHITE_LIST);
+	sent = hci_sent_cmd_data(hdev, HCI_OP_LE_ADD_TO_ACCEPT_LIST);
 	if (!sent)
 		return;
 
-	hci_bdaddr_list_add(&hdev->le_white_list, &sent->bdaddr,
-			   sent->bdaddr_type);
+	hci_bdaddr_list_add(&hdev->le_accept_list, &sent->bdaddr,
+			    sent->bdaddr_type);
 }
 
-static void hci_cc_le_del_from_white_list(struct hci_dev *hdev,
-					  struct sk_buff *skb)
+static void hci_cc_le_del_from_accept_list(struct hci_dev *hdev,
+					   struct sk_buff *skb)
 {
-	struct hci_cp_le_del_from_white_list *sent;
+	struct hci_cp_le_del_from_accept_list *sent;
 	__u8 status = *((__u8 *) skb->data);
 
 	BT_DBG("%s status 0x%2.2x", hdev->name, status);
@@ -1512,11 +1512,11 @@ static void hci_cc_le_del_from_white_list(struct hci_dev *hdev,
 	if (status)
 		return;
 
-	sent = hci_sent_cmd_data(hdev, HCI_OP_LE_DEL_FROM_WHITE_LIST);
+	sent = hci_sent_cmd_data(hdev, HCI_OP_LE_DEL_FROM_ACCEPT_LIST);
 	if (!sent)
 		return;
 
-	hci_bdaddr_list_del(&hdev->le_white_list, &sent->bdaddr,
+	hci_bdaddr_list_del(&hdev->le_accept_list, &sent->bdaddr,
 			    sent->bdaddr_type);
 }
 
@@ -2331,7 +2331,7 @@ static void cs_le_create_conn(struct hci_dev *hdev, bdaddr_t *peer_addr,
 	/* We don't want the connection attempt to stick around
 	 * indefinitely since LE doesn't have a page timeout concept
 	 * like BR/EDR. Set a timer for any connection that doesn't use
-	 * the white list for connecting.
+	 * the accept list for connecting.
 	 */
 	if (filter_policy == HCI_LE_USE_PEER_ADDR)
 		queue_delayed_work(conn->hdev->workqueue,
@@ -2587,7 +2587,7 @@ static void hci_conn_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)
 		 * only used during suspend.
 		 */
 		if (ev->link_type == ACL_LINK &&
-		    hci_bdaddr_list_lookup_with_flags(&hdev->whitelist,
+		    hci_bdaddr_list_lookup_with_flags(&hdev->accept_list,
 						      &ev->bdaddr,
 						      BDADDR_BREDR)) {
 			conn = hci_conn_add(hdev, ev->link_type, &ev->bdaddr,
@@ -2709,19 +2709,19 @@ static void hci_conn_request_evt(struct hci_dev *hdev, struct sk_buff *skb)
 		return;
 	}
 
-	if (hci_bdaddr_list_lookup(&hdev->blacklist, &ev->bdaddr,
+	if (hci_bdaddr_list_lookup(&hdev->reject_list, &ev->bdaddr,
 				   BDADDR_BREDR)) {
 		hci_reject_conn(hdev, &ev->bdaddr);
 		return;
 	}
 
-	/* Require HCI_CONNECTABLE or a whitelist entry to accept the
+	/* Require HCI_CONNECTABLE or an accept list entry to accept the
 	 * connection. These features are only touched through mgmt so
 	 * only do the checks if HCI_MGMT is set.
 	 */
 	if (hci_dev_test_flag(hdev, HCI_MGMT) &&
 	    !hci_dev_test_flag(hdev, HCI_CONNECTABLE) &&
-	    !hci_bdaddr_list_lookup_with_flags(&hdev->whitelist, &ev->bdaddr,
+	    !hci_bdaddr_list_lookup_with_flags(&hdev->accept_list, &ev->bdaddr,
 					       BDADDR_BREDR)) {
 		hci_reject_conn(hdev, &ev->bdaddr);
 		return;
@@ -3502,20 +3502,20 @@ static void hci_cmd_complete_evt(struct hci_dev *hdev, struct sk_buff *skb,
 		hci_cc_le_set_scan_enable(hdev, skb);
 		break;
 
-	case HCI_OP_LE_READ_WHITE_LIST_SIZE:
-		hci_cc_le_read_white_list_size(hdev, skb);
+	case HCI_OP_LE_READ_ACCEPT_LIST_SIZE:
+		hci_cc_le_read_accept_list_size(hdev, skb);
 		break;
 
-	case HCI_OP_LE_CLEAR_WHITE_LIST:
-		hci_cc_le_clear_white_list(hdev, skb);
+	case HCI_OP_LE_CLEAR_ACCEPT_LIST:
+		hci_cc_le_clear_accept_list(hdev, skb);
 		break;
 
-	case HCI_OP_LE_ADD_TO_WHITE_LIST:
-		hci_cc_le_add_to_white_list(hdev, skb);
+	case HCI_OP_LE_ADD_TO_ACCEPT_LIST:
+		hci_cc_le_add_to_accept_list(hdev, skb);
 		break;
 
-	case HCI_OP_LE_DEL_FROM_WHITE_LIST:
-		hci_cc_le_del_from_white_list(hdev, skb);
+	case HCI_OP_LE_DEL_FROM_ACCEPT_LIST:
+		hci_cc_le_del_from_accept_list(hdev, skb);
 		break;
 
 	case HCI_OP_LE_READ_SUPPORTED_STATES:
@@ -5092,7 +5092,7 @@ static void le_conn_complete_evt(struct hci_dev *hdev, u8 status,
 
 		/* If we didn't have a hci_conn object previously
 		 * but we're in central role this must be something
-		 * initiated using a white list. Since white list based
+		 * initiated using an accept list. Since accept list based
 		 * connections are not "first class citizens" we don't
 		 * have full tracking of them. Therefore, we go ahead
 		 * with a "best effort" approach of determining the
@@ -5184,7 +5184,7 @@ static void le_conn_complete_evt(struct hci_dev *hdev, u8 status,
 		addr_type = BDADDR_LE_RANDOM;
 
 	/* Drop the connection if the device is blocked */
-	if (hci_bdaddr_list_lookup(&hdev->blacklist, &conn->dst, addr_type)) {
+	if (hci_bdaddr_list_lookup(&hdev->reject_list, &conn->dst, addr_type)) {
 		hci_conn_drop(conn);
 		goto unlock;
 	}
@@ -5339,7 +5339,7 @@ static struct hci_conn *check_pending_le_conn(struct hci_dev *hdev,
 		return NULL;
 
 	/* Ignore if the device is blocked */
-	if (hci_bdaddr_list_lookup(&hdev->blacklist, addr, addr_type))
+	if (hci_bdaddr_list_lookup(&hdev->reject_list, addr, addr_type))
 		return NULL;
 
 	/* Most controller will fail if we try to create new connections
* Unmerged path net/bluetooth/hci_request.c
diff --git a/net/bluetooth/hci_sock.c b/net/bluetooth/hci_sock.c
index 6b8f3fc352fa..fa1b95edfe43 100644
--- a/net/bluetooth/hci_sock.c
+++ b/net/bluetooth/hci_sock.c
@@ -892,7 +892,7 @@ static int hci_sock_release(struct socket *sock)
 	return 0;
 }
 
-static int hci_sock_blacklist_add(struct hci_dev *hdev, void __user *arg)
+static int hci_sock_reject_list_add(struct hci_dev *hdev, void __user *arg)
 {
 	bdaddr_t bdaddr;
 	int err;
@@ -902,14 +902,14 @@ static int hci_sock_blacklist_add(struct hci_dev *hdev, void __user *arg)
 
 	hci_dev_lock(hdev);
 
-	err = hci_bdaddr_list_add(&hdev->blacklist, &bdaddr, BDADDR_BREDR);
+	err = hci_bdaddr_list_add(&hdev->reject_list, &bdaddr, BDADDR_BREDR);
 
 	hci_dev_unlock(hdev);
 
 	return err;
 }
 
-static int hci_sock_blacklist_del(struct hci_dev *hdev, void __user *arg)
+static int hci_sock_reject_list_del(struct hci_dev *hdev, void __user *arg)
 {
 	bdaddr_t bdaddr;
 	int err;
@@ -919,7 +919,7 @@ static int hci_sock_blacklist_del(struct hci_dev *hdev, void __user *arg)
 
 	hci_dev_lock(hdev);
 
-	err = hci_bdaddr_list_del(&hdev->blacklist, &bdaddr, BDADDR_BREDR);
+	err = hci_bdaddr_list_del(&hdev->reject_list, &bdaddr, BDADDR_BREDR);
 
 	hci_dev_unlock(hdev);
 
@@ -959,12 +959,12 @@ static int hci_sock_bound_ioctl(struct sock *sk, unsigned int cmd,
 	case HCIBLOCKADDR:
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
-		return hci_sock_blacklist_add(hdev, (void __user *)arg);
+		return hci_sock_reject_list_add(hdev, (void __user *)arg);
 
 	case HCIUNBLOCKADDR:
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
-		return hci_sock_blacklist_del(hdev, (void __user *)arg);
+		return hci_sock_reject_list_del(hdev, (void __user *)arg);
 	}
 
 	return -ENOIOCTLCMD;
diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c
index b76c5d00b082..77ba68209dbd 100644
--- a/net/bluetooth/l2cap_core.c
+++ b/net/bluetooth/l2cap_core.c
@@ -7662,7 +7662,7 @@ static void l2cap_recv_frame(struct l2cap_conn *conn, struct sk_buff *skb)
 	 * at least ensure that we ignore incoming data from them.
 	 */
 	if (hcon->type == LE_LINK &&
-	    hci_bdaddr_list_lookup(&hcon->hdev->blacklist, &hcon->dst,
+	    hci_bdaddr_list_lookup(&hcon->hdev->reject_list, &hcon->dst,
 				   bdaddr_dst_type(hcon))) {
 		kfree_skb(skb);
 		return;
@@ -8119,7 +8119,7 @@ static void l2cap_connect_cfm(struct hci_conn *hcon, u8 status)
 	dst_type = bdaddr_dst_type(hcon);
 
 	/* If device is blocked, do not create channels for it */
-	if (hci_bdaddr_list_lookup(&hdev->blacklist, &hcon->dst, dst_type))
+	if (hci_bdaddr_list_lookup(&hdev->reject_list, &hcon->dst, dst_type))
 		return;
 
 	/* Find fixed channels and notify them of the new connection. We
* Unmerged path net/bluetooth/mgmt.c
