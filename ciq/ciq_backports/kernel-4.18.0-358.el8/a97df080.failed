net: bridge: vlan: add support for mcast router global option

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit a97df080b6a86c105f98052ca3a9d66149b461b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/a97df080.failed

Add support to change and retrieve global vlan multicast router state
which is used for the bridge itself. We just need to pass multicast context
to br_multicast_set_router instead of bridge device and the rest of the
logic remains the same.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a97df080b6a86c105f98052ca3a9d66149b461b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/if_bridge.h
#	net/bridge/br_multicast.c
#	net/bridge/br_private.h
#	net/bridge/br_sysfs_br.c
#	net/bridge/br_vlan_options.c
diff --cc include/uapi/linux/if_bridge.h
index d643fa57361d,2104dd3557b4..000000000000
--- a/include/uapi/linux/if_bridge.h
+++ b/include/uapi/linux/if_bridge.h
@@@ -491,6 -548,20 +491,23 @@@ enum 
  	BRIDGE_VLANDB_GOPTS_UNSPEC,
  	BRIDGE_VLANDB_GOPTS_ID,
  	BRIDGE_VLANDB_GOPTS_RANGE,
++<<<<<<< HEAD
++=======
+ 	BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_PAD,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_ROUTER,
++>>>>>>> a97df080b6a8 (net: bridge: vlan: add support for mcast router global option)
  	__BRIDGE_VLANDB_GOPTS_MAX
  };
  #define BRIDGE_VLANDB_GOPTS_MAX (__BRIDGE_VLANDB_GOPTS_MAX - 1)
diff --cc net/bridge/br_multicast.c
index def6f1840985,df6bf6a237aa..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -2957,15 -4062,18 +2957,30 @@@ int br_multicast_set_router(struct net_
  	switch (val) {
  	case MDB_RTR_TYPE_DISABLED:
  	case MDB_RTR_TYPE_PERM:
++<<<<<<< HEAD
 +		br_mc_router_state_change(br, val == MDB_RTR_TYPE_PERM);
 +		del_timer(&br->multicast_router_timer);
 +		br->multicast_router = val;
 +		err = 0;
 +		break;
 +	case MDB_RTR_TYPE_TEMP_QUERY:
 +		if (br->multicast_router != MDB_RTR_TYPE_TEMP_QUERY)
 +			br_mc_router_state_change(br, false);
 +		br->multicast_router = val;
++=======
+ 		br_mc_router_state_change(brmctx->br, val == MDB_RTR_TYPE_PERM);
+ 		del_timer(&brmctx->ip4_mc_router_timer);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		del_timer(&brmctx->ip6_mc_router_timer);
+ #endif
+ 		brmctx->multicast_router = val;
+ 		err = 0;
+ 		break;
+ 	case MDB_RTR_TYPE_TEMP_QUERY:
+ 		if (brmctx->multicast_router != MDB_RTR_TYPE_TEMP_QUERY)
+ 			br_mc_router_state_change(brmctx->br, false);
+ 		brmctx->multicast_router = val;
++>>>>>>> a97df080b6a8 (net: bridge: vlan: add support for mcast router global option)
  		err = 0;
  		break;
  	}
diff --cc net/bridge/br_private.h
index 30e07225bc94,6d5681ca8d2f..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -729,16 -874,20 +729,23 @@@ void br_multicast_leave_snoopers(struc
  void br_multicast_open(struct net_bridge *br);
  void br_multicast_stop(struct net_bridge *br);
  void br_multicast_dev_del(struct net_bridge *br);
++<<<<<<< HEAD
 +void br_multicast_flood(struct net_bridge_mdb_entry *mdst,
 +			struct sk_buff *skb, bool local_rcv, bool local_orig);
 +int br_multicast_set_router(struct net_bridge *br, unsigned long val);
++=======
+ void br_multicast_flood(struct net_bridge_mdb_entry *mdst, struct sk_buff *skb,
+ 			struct net_bridge_mcast *brmctx,
+ 			bool local_rcv, bool local_orig);
+ int br_multicast_set_router(struct net_bridge_mcast *brmctx, unsigned long val);
++>>>>>>> a97df080b6a8 (net: bridge: vlan: add support for mcast router global option)
  int br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val);
 -int br_multicast_toggle(struct net_bridge *br, unsigned long val,
 -			struct netlink_ext_ack *extack);
 -int br_multicast_set_querier(struct net_bridge_mcast *brmctx, unsigned long val);
 +int br_multicast_toggle(struct net_bridge *br, unsigned long val);
 +int br_multicast_set_querier(struct net_bridge *br, unsigned long val);
  int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);
 -int br_multicast_set_igmp_version(struct net_bridge_mcast *brmctx,
 -				  unsigned long val);
 +int br_multicast_set_igmp_version(struct net_bridge *br, unsigned long val);
  #if IS_ENABLED(CONFIG_IPV6)
 -int br_multicast_set_mld_version(struct net_bridge_mcast *brmctx,
 -				 unsigned long val);
 +int br_multicast_set_mld_version(struct net_bridge *br, unsigned long val);
  #endif
  struct net_bridge_mdb_entry *
  br_mdb_ip_get(struct net_bridge *br, struct br_ip *dst);
@@@ -822,21 -1094,125 +829,129 @@@ static inline int br_multicast_igmp_typ
  	return BR_INPUT_SKB_CB(skb)->igmp;
  }
  
 -static inline unsigned long br_multicast_lmqt(const struct net_bridge_mcast *brmctx)
 +static inline unsigned long br_multicast_lmqt(const struct net_bridge *br)
  {
 -	return brmctx->multicast_last_member_interval *
 -	       brmctx->multicast_last_member_count;
 +	return br->multicast_last_member_interval *
 +	       br->multicast_last_member_count;
  }
  
 -static inline unsigned long br_multicast_gmi(const struct net_bridge_mcast *brmctx)
 +static inline unsigned long br_multicast_gmi(const struct net_bridge *br)
  {
  	/* use the RFC default of 2 for QRV */
++<<<<<<< HEAD
 +	return 2 * br->multicast_query_interval +
 +	       br->multicast_query_response_interval;
++=======
+ 	return 2 * brmctx->multicast_query_interval +
+ 	       brmctx->multicast_query_response_interval;
+ }
+ 
+ static inline bool
+ br_multicast_ctx_is_vlan(const struct net_bridge_mcast *brmctx)
+ {
+ 	return !!brmctx->vlan;
+ }
+ 
+ static inline bool
+ br_multicast_port_ctx_is_vlan(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	return !!pmctx->vlan;
+ }
+ 
+ static inline struct net_bridge_mcast *
+ br_multicast_port_ctx_get_global(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	if (!br_multicast_port_ctx_is_vlan(pmctx))
+ 		return &pmctx->port->br->multicast_ctx;
+ 	else
+ 		return &pmctx->vlan->brvlan->br_mcast_ctx;
+ }
+ 
+ static inline bool
+ br_multicast_ctx_vlan_global_disabled(const struct net_bridge_mcast *brmctx)
+ {
+ 	return br_opt_get(brmctx->br, BROPT_MCAST_VLAN_SNOOPING_ENABLED) &&
+ 	       br_multicast_ctx_is_vlan(brmctx) &&
+ 	       !(brmctx->vlan->priv_flags & BR_VLFLAG_GLOBAL_MCAST_ENABLED);
+ }
+ 
+ static inline bool
+ br_multicast_ctx_vlan_disabled(const struct net_bridge_mcast *brmctx)
+ {
+ 	return br_multicast_ctx_is_vlan(brmctx) &&
+ 	       !(brmctx->vlan->priv_flags & BR_VLFLAG_MCAST_ENABLED);
+ }
+ 
+ static inline bool
+ br_multicast_port_ctx_vlan_disabled(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	return br_multicast_port_ctx_is_vlan(pmctx) &&
+ 	       !(pmctx->vlan->priv_flags & BR_VLFLAG_MCAST_ENABLED);
+ }
+ 
+ static inline bool
+ br_multicast_port_ctx_state_disabled(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	return pmctx->port->state == BR_STATE_DISABLED ||
+ 	       (br_multicast_port_ctx_is_vlan(pmctx) &&
+ 		(br_multicast_port_ctx_vlan_disabled(pmctx) ||
+ 		 pmctx->vlan->state == BR_STATE_DISABLED));
+ }
+ 
+ static inline bool
+ br_multicast_port_ctx_state_stopped(const struct net_bridge_mcast_port *pmctx)
+ {
+ 	return br_multicast_port_ctx_state_disabled(pmctx) ||
+ 	       pmctx->port->state == BR_STATE_BLOCKING ||
+ 	       (br_multicast_port_ctx_is_vlan(pmctx) &&
+ 		pmctx->vlan->state == BR_STATE_BLOCKING);
+ }
+ 
+ static inline bool
+ br_multicast_ctx_options_equal(const struct net_bridge_mcast *brmctx1,
+ 			       const struct net_bridge_mcast *brmctx2)
+ {
+ 	return brmctx1->multicast_igmp_version ==
+ 	       brmctx2->multicast_igmp_version &&
+ 	       brmctx1->multicast_last_member_count ==
+ 	       brmctx2->multicast_last_member_count &&
+ 	       brmctx1->multicast_startup_query_count ==
+ 	       brmctx2->multicast_startup_query_count &&
+ 	       brmctx1->multicast_last_member_interval ==
+ 	       brmctx2->multicast_last_member_interval &&
+ 	       brmctx1->multicast_membership_interval ==
+ 	       brmctx2->multicast_membership_interval &&
+ 	       brmctx1->multicast_querier_interval ==
+ 	       brmctx2->multicast_querier_interval &&
+ 	       brmctx1->multicast_query_interval ==
+ 	       brmctx2->multicast_query_interval &&
+ 	       brmctx1->multicast_query_response_interval ==
+ 	       brmctx2->multicast_query_response_interval &&
+ 	       brmctx1->multicast_startup_query_interval ==
+ 	       brmctx2->multicast_startup_query_interval &&
+ 	       brmctx1->multicast_querier == brmctx2->multicast_querier &&
+ 	       brmctx1->multicast_router == brmctx2->multicast_router &&
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	       brmctx1->multicast_mld_version ==
+ 	       brmctx2->multicast_mld_version &&
+ #endif
+ 	       true;
+ }
+ 
+ static inline bool
+ br_multicast_ctx_matches_vlan_snooping(const struct net_bridge_mcast *brmctx)
+ {
+ 	bool vlan_snooping_enabled;
+ 
+ 	vlan_snooping_enabled = !!br_opt_get(brmctx->br,
+ 					     BROPT_MCAST_VLAN_SNOOPING_ENABLED);
+ 
+ 	return !!(vlan_snooping_enabled == br_multicast_ctx_is_vlan(brmctx));
++>>>>>>> a97df080b6a8 (net: bridge: vlan: add support for mcast router global option)
  }
  #else
 -static inline int br_multicast_rcv(struct net_bridge_mcast **brmctx,
 -				   struct net_bridge_mcast_port **pmctx,
 -				   struct net_bridge_vlan *vlan,
 +static inline int br_multicast_rcv(struct net_bridge *br,
 +				   struct net_bridge_port *port,
  				   struct sk_buff *skb,
  				   u16 vid)
  {
diff --cc net/bridge/br_sysfs_br.c
index 52b9892eb49f,d9a89ddd0331..000000000000
--- a/net/bridge/br_sysfs_br.c
+++ b/net/bridge/br_sysfs_br.c
@@@ -335,7 -384,13 +335,17 @@@ static ssize_t multicast_router_show(st
  				     struct device_attribute *attr, char *buf)
  {
  	struct net_bridge *br = to_bridge(d);
++<<<<<<< HEAD
 +	return sprintf(buf, "%d\n", br->multicast_router);
++=======
+ 	return sprintf(buf, "%d\n", br->multicast_ctx.multicast_router);
+ }
+ 
+ static int set_multicast_router(struct net_bridge *br, unsigned long val,
+ 				struct netlink_ext_ack *extack)
+ {
+ 	return br_multicast_set_router(&br->multicast_ctx, val);
++>>>>>>> a97df080b6a8 (net: bridge: vlan: add support for mcast router global option)
  }
  
  static ssize_t multicast_router_store(struct device *d,
diff --cc net/bridge/br_vlan_options.c
index 827bfc319599,6ba45b73931f..000000000000
--- a/net/bridge/br_vlan_options.c
+++ b/net/bridge/br_vlan_options.c
@@@ -281,6 -286,53 +281,56 @@@ bool br_vlan_global_opts_fill(struct sk
  	    nla_put_u16(skb, BRIDGE_VLANDB_GOPTS_RANGE, vid_range))
  		goto out_err;
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	if (nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING,
+ 		       !!(v_opts->priv_flags & BR_VLFLAG_GLOBAL_MCAST_ENABLED)) ||
+ 	    nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION,
+ 		       v_opts->br_mcast_ctx.multicast_igmp_version) ||
+ 	    nla_put_u32(skb, BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT,
+ 			v_opts->br_mcast_ctx.multicast_last_member_count) ||
+ 	    nla_put_u32(skb, BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT,
+ 			v_opts->br_mcast_ctx.multicast_startup_query_count) ||
+ 	    nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERIER,
+ 		       v_opts->br_mcast_ctx.multicast_querier) ||
+ 	    nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_ROUTER,
+ 		       v_opts->br_mcast_ctx.multicast_router))
+ 		goto out_err;
+ 
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_last_member_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_membership_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_querier_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_query_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_query_response_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 	clockval = jiffies_to_clock_t(v_opts->br_mcast_ctx.multicast_startup_query_interval);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL,
+ 			      clockval, BRIDGE_VLANDB_GOPTS_PAD))
+ 		goto out_err;
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION,
+ 		       v_opts->br_mcast_ctx.multicast_mld_version))
+ 		goto out_err;
+ #endif
+ #endif
+ 
++>>>>>>> a97df080b6a8 (net: bridge: vlan: add support for mcast router global option)
  	nla_nest_end(skb, nest);
  
  	return true;
@@@ -295,6 -347,21 +345,24 @@@ static size_t rtnl_vlan_global_opts_nlm
  	return NLMSG_ALIGN(sizeof(struct br_vlan_msg))
  		+ nla_total_size(0) /* BRIDGE_VLANDB_GLOBAL_OPTIONS */
  		+ nla_total_size(sizeof(u16)) /* BRIDGE_VLANDB_GOPTS_ID */
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION */
+ 		+ nla_total_size(sizeof(u32)) /* BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT */
+ 		+ nla_total_size(sizeof(u32)) /* BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERIER */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_ROUTER */
+ #endif
++>>>>>>> a97df080b6a8 (net: bridge: vlan: add support for mcast router global option)
  		+ nla_total_size(sizeof(u16)); /* BRIDGE_VLANDB_GOPTS_RANGE */
  }
  
@@@ -348,13 -415,132 +416,136 @@@ static int br_vlan_process_global_one_o
  					   bool *changed,
  					   struct netlink_ext_ack *extack)
  {
 -	int err __maybe_unused;
 -
  	*changed = false;
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING]) {
+ 		u8 mc_snooping;
+ 
+ 		mc_snooping = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING]);
+ 		if (br_multicast_toggle_global_vlan(v, !!mc_snooping))
+ 			*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION]) {
+ 		u8 ver;
+ 
+ 		ver = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION]);
+ 		err = br_multicast_set_igmp_version(&v->br_mcast_ctx, ver);
+ 		if (err)
+ 			return err;
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT]) {
+ 		u32 cnt;
+ 
+ 		cnt = nla_get_u32(tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT]);
+ 		v->br_mcast_ctx.multicast_last_member_count = cnt;
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT]) {
+ 		u32 cnt;
+ 
+ 		cnt = nla_get_u32(tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT]);
+ 		v->br_mcast_ctx.multicast_startup_query_count = cnt;
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL]);
+ 		v->br_mcast_ctx.multicast_last_member_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL]);
+ 		v->br_mcast_ctx.multicast_membership_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL]);
+ 		v->br_mcast_ctx.multicast_querier_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL]);
+ 		v->br_mcast_ctx.multicast_query_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL]);
+ 		v->br_mcast_ctx.multicast_query_response_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL]) {
+ 		u64 val;
+ 
+ 		val = nla_get_u64(tb[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL]);
+ 		v->br_mcast_ctx.multicast_startup_query_interval = clock_t_to_jiffies(val);
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER]) {
+ 		u8 val;
+ 
+ 		val = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER]);
+ 		err = br_multicast_set_querier(&v->br_mcast_ctx, val);
+ 		if (err)
+ 			return err;
+ 		*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_ROUTER]) {
+ 		u8 val;
+ 
+ 		val = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_ROUTER]);
+ 		err = br_multicast_set_router(&v->br_mcast_ctx, val);
+ 		if (err)
+ 			return err;
+ 		*changed = true;
+ 	}
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION]) {
+ 		u8 ver;
+ 
+ 		ver = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION]);
+ 		err = br_multicast_set_mld_version(&v->br_mcast_ctx, ver);
+ 		if (err)
+ 			return err;
+ 		*changed = true;
+ 	}
+ #endif
+ #endif
+ 
++>>>>>>> a97df080b6a8 (net: bridge: vlan: add support for mcast router global option)
  	return 0;
  }
  
  static const struct nla_policy br_vlan_db_gpol[BRIDGE_VLANDB_GOPTS_MAX + 1] = {
  	[BRIDGE_VLANDB_GOPTS_ID]	= { .type = NLA_U16 },
  	[BRIDGE_VLANDB_GOPTS_RANGE]	= { .type = NLA_U16 },
++<<<<<<< HEAD
++=======
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL]	= { .type = NLA_U64 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_ROUTER]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT]	= { .type = NLA_U32 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT]	= { .type = NLA_U32 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL]	= { .type = NLA_U64 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL]	= { .type = NLA_U64 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL]	= { .type = NLA_U64 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL]	= { .type = NLA_U64 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL] = { .type = NLA_U64 },
++>>>>>>> a97df080b6a8 (net: bridge: vlan: add support for mcast router global option)
  };
  
  int br_vlan_rtm_process_global_options(struct net_device *dev,
* Unmerged path include/uapi/linux/if_bridge.h
* Unmerged path net/bridge/br_multicast.c
diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c
index 75be8311a010..eb947183ca2d 100644
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@ -1252,7 +1252,8 @@ static int br_changelink(struct net_device *brdev, struct nlattr *tb[],
 	if (data[IFLA_BR_MCAST_ROUTER]) {
 		u8 multicast_router = nla_get_u8(data[IFLA_BR_MCAST_ROUTER]);
 
-		err = br_multicast_set_router(br, multicast_router);
+		err = br_multicast_set_router(&br->multicast_ctx,
+					      multicast_router);
 		if (err)
 			return err;
 	}
* Unmerged path net/bridge/br_private.h
* Unmerged path net/bridge/br_sysfs_br.c
* Unmerged path net/bridge/br_vlan_options.c
