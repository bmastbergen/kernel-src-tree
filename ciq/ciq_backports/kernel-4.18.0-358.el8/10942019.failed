firmware: psci: Extend psci_set_osi_mode() to allow reset to PC mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Ulf Hansson <ulf.hansson@linaro.org>
commit 10942019040c5557556ec22aae0f771b2a1a1a6d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/10942019.failed

The current user (cpuidle-psci) of psci_set_osi_mode() only needs to enable
the PSCI OSI mode. Although, as subsequent changes shows, there is a need
to be able to reset back into the PSCI PC mode.

Therefore, let's extend psci_set_osi_mode() to take a bool as in-parameter,
to let the user indicate whether to enable OSI or to switch back to PC
mode.

	Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 10942019040c5557556ec22aae0f771b2a1a1a6d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpuidle/cpuidle-psci-domain.c
#	drivers/firmware/psci/psci.c
#	include/linux/psci.h
diff --cc drivers/firmware/psci/psci.c
index bb1d53965413,00af99b6f97c..000000000000
--- a/drivers/firmware/psci/psci.c
+++ b/drivers/firmware/psci/psci.c
@@@ -169,6 -151,18 +169,21 @@@ static u32 psci_get_version(void
  	return invoke_psci_fn(PSCI_0_2_FN_PSCI_VERSION, 0, 0, 0);
  }
  
++<<<<<<< HEAD
++=======
+ int psci_set_osi_mode(bool enable)
+ {
+ 	unsigned long suspend_mode;
+ 	int err;
+ 
+ 	suspend_mode = enable ? PSCI_1_0_SUSPEND_MODE_OSI :
+ 			PSCI_1_0_SUSPEND_MODE_PC;
+ 
+ 	err = invoke_psci_fn(PSCI_1_0_FN_SET_SUSPEND_MODE, suspend_mode, 0, 0);
+ 	return psci_to_linux_errno(err);
+ }
+ 
++>>>>>>> 10942019040c (firmware: psci: Extend psci_set_osi_mode() to allow reset to PC mode)
  static int psci_cpu_suspend(u32 state, unsigned long entry_point)
  {
  	int err;
@@@ -702,9 -545,13 +717,16 @@@ static int __init psci_1_0_init(struct 
  	if (err)
  		return err;
  
 -	if (psci_has_osi_support()) {
 +	if (psci_has_osi_support())
  		pr_info("OSI mode supported.\n");
  
++<<<<<<< HEAD
++=======
+ 		/* Default to PC mode. */
+ 		psci_set_osi_mode(false);
+ 	}
+ 
++>>>>>>> 10942019040c (firmware: psci: Extend psci_set_osi_mode() to allow reset to PC mode)
  	return 0;
  }
  
diff --cc include/linux/psci.h
index fb6e507b57c5,2a1bfb890e58..000000000000
--- a/include/linux/psci.h
+++ b/include/linux/psci.h
@@@ -23,8 -16,10 +23,15 @@@
  
  bool psci_tos_resident_on(int cpu);
  
++<<<<<<< HEAD
 +int psci_cpu_init_idle(unsigned int cpu);
 +int psci_cpu_suspend_enter(unsigned long index);
++=======
+ int psci_cpu_suspend_enter(u32 state);
+ bool psci_power_state_is_valid(u32 state);
+ int psci_set_osi_mode(bool enable);
+ bool psci_has_osi_support(void);
++>>>>>>> 10942019040c (firmware: psci: Extend psci_set_osi_mode() to allow reset to PC mode)
  
  struct psci_operations {
  	u32 (*get_version)(void);
* Unmerged path drivers/cpuidle/cpuidle-psci-domain.c
* Unmerged path drivers/cpuidle/cpuidle-psci-domain.c
* Unmerged path drivers/firmware/psci/psci.c
* Unmerged path include/linux/psci.h
