ceph: add a new metric to keep track of remote object copies

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Luís Henriques <lhenriques@suse.de>
commit c02cb7bdc4501debc3e71a4d2daf7286c48e1d38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/c02cb7bd.failed

This patch adds latency and size metrics for remote object copies
operations ("copyfrom").  For now, these metrics will be available on the
client only, they won't be sent to the MDS.

	Signed-off-by: Luís Henriques <lhenriques@suse.de>
	Reviewed-by: Jeff Layton <jlayton@kernel.org>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit c02cb7bdc4501debc3e71a4d2daf7286c48e1d38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/debugfs.c
#	fs/ceph/metric.h
diff --cc fs/ceph/debugfs.c
index 08a330a116d4,3cf7c9c1085b..000000000000
--- a/fs/ceph/debugfs.c
+++ b/fs/ceph/debugfs.c
@@@ -146,26 -146,38 +146,53 @@@ static int mdsc_show(struct seq_file *s
  		   name, total, avg, _min, max, sum);			\
  }
  
 -static int metrics_file_show(struct seq_file *s, void *p)
 +static int metric_show(struct seq_file *s, void *p)
  {
  	struct ceph_fs_client *fsc = s->private;
 -	struct ceph_client_metric *m = &fsc->mdsc->metric;
 +	struct ceph_mds_client *mdsc = fsc->mdsc;
 +	struct ceph_client_metric *m = &mdsc->metric;
 +	int nr_caps = 0;
 +	s64 total, sum, avg, min, max, sq;
 +	u64 sum_sz, avg_sz, min_sz, max_sz;
  
 +	sum = percpu_counter_sum(&m->total_inodes);
  	seq_printf(s, "item                               total\n");
  	seq_printf(s, "------------------------------------------\n");
++<<<<<<< HEAD
 +	seq_printf(s, "%-35s%lld / %lld\n", "opened files  / total inodes",
 +		   (long long)atomic64_read(&m->opened_files), sum);
 +	seq_printf(s, "%-35s%lld / %lld\n", "pinned i_caps / total inodes",
 +		   (long long)atomic64_read(&m->total_caps), sum);
 +	seq_printf(s, "%-35s%lld / %lld\n", "opened inodes / total inodes",
 +		   percpu_counter_sum(&m->opened_inodes), sum);
++=======
+ 	seq_printf(s, "%-35s%lld\n", "total inodes",
+ 		   percpu_counter_sum(&m->total_inodes));
+ 	seq_printf(s, "%-35s%lld\n", "opened files",
+ 		   atomic64_read(&m->opened_files));
+ 	seq_printf(s, "%-35s%lld\n", "pinned i_caps",
+ 		   atomic64_read(&m->total_caps));
+ 	seq_printf(s, "%-35s%lld\n", "opened inodes",
+ 		   percpu_counter_sum(&m->opened_inodes));
+ 	return 0;
+ }
+ 
+ static const char * const metric_str[] = {
+ 	"read",
+ 	"write",
+ 	"metadata",
+ 	"copyfrom"
+ };
+ static int metrics_latency_show(struct seq_file *s, void *p)
+ {
+ 	struct ceph_fs_client *fsc = s->private;
+ 	struct ceph_client_metric *cm = &fsc->mdsc->metric;
+ 	struct ceph_metric *m;
+ 	s64 total, sum, avg, min, max, sq;
+ 	int i;
++>>>>>>> c02cb7bdc450 (ceph: add a new metric to keep track of remote object copies)
  
 +	seq_printf(s, "\n");
  	seq_printf(s, "item          total       avg_lat(us)     min_lat(us)     max_lat(us)     stdev(us)\n");
  	seq_printf(s, "-----------------------------------------------------------------------------------\n");
  
diff --cc fs/ceph/metric.h
index 0133955a3c6a,bb45608181e7..000000000000
--- a/fs/ceph/metric.h
+++ b/fs/ceph/metric.h
@@@ -125,6 -125,26 +125,29 @@@ struct ceph_metric_head 
  	__le32 num;	/* the number of metrics that will be sent */
  } __packed;
  
++<<<<<<< HEAD
++=======
+ enum metric_type {
+ 	METRIC_READ,
+ 	METRIC_WRITE,
+ 	METRIC_METADATA,
+ 	METRIC_COPYFROM,
+ 	METRIC_MAX
+ };
+ 
+ struct ceph_metric {
+ 	spinlock_t lock;
+ 	u64 total;
+ 	u64 size_sum;
+ 	u64 size_min;
+ 	u64 size_max;
+ 	ktime_t latency_sum;
+ 	ktime_t latency_sq_sum;
+ 	ktime_t latency_min;
+ 	ktime_t latency_max;
+ };
+ 
++>>>>>>> c02cb7bdc450 (ceph: add a new metric to keep track of remote object copies)
  /* This is the global metrics */
  struct ceph_client_metric {
  	atomic64_t            total_dentries;
@@@ -195,13 -190,36 +218,48 @@@ static inline void ceph_update_cap_mis(
  	percpu_counter_inc(&m->i_caps_mis);
  }
  
++<<<<<<< HEAD
 +extern void ceph_update_read_metrics(struct ceph_client_metric *m,
 +				     ktime_t r_start, ktime_t r_end,
 +				     unsigned int size, int rc);
 +extern void ceph_update_write_metrics(struct ceph_client_metric *m,
 +				      ktime_t r_start, ktime_t r_end,
 +				      unsigned int size, int rc);
 +extern void ceph_update_metadata_metrics(struct ceph_client_metric *m,
 +				         ktime_t r_start, ktime_t r_end,
 +					 int rc);
++=======
+ extern void ceph_update_metrics(struct ceph_metric *m,
+ 				ktime_t r_start, ktime_t r_end,
+ 				unsigned int size, int rc);
+ 
+ static inline void ceph_update_read_metrics(struct ceph_client_metric *m,
+ 					    ktime_t r_start, ktime_t r_end,
+ 					    unsigned int size, int rc)
+ {
+ 	ceph_update_metrics(&m->metric[METRIC_READ],
+ 			    r_start, r_end, size, rc);
+ }
+ static inline void ceph_update_write_metrics(struct ceph_client_metric *m,
+ 					     ktime_t r_start, ktime_t r_end,
+ 					     unsigned int size, int rc)
+ {
+ 	ceph_update_metrics(&m->metric[METRIC_WRITE],
+ 			    r_start, r_end, size, rc);
+ }
+ static inline void ceph_update_metadata_metrics(struct ceph_client_metric *m,
+ 						ktime_t r_start, ktime_t r_end,
+ 						int rc)
+ {
+ 	ceph_update_metrics(&m->metric[METRIC_METADATA],
+ 			    r_start, r_end, 0, rc);
+ }
+ static inline void ceph_update_copyfrom_metrics(struct ceph_client_metric *m,
+ 						ktime_t r_start, ktime_t r_end,
+ 						unsigned int size, int rc)
+ {
+ 	ceph_update_metrics(&m->metric[METRIC_COPYFROM],
+ 			    r_start, r_end, size, rc);
+ }
++>>>>>>> c02cb7bdc450 (ceph: add a new metric to keep track of remote object copies)
  #endif /* _FS_CEPH_MDS_METRIC_H */
* Unmerged path fs/ceph/debugfs.c
diff --git a/fs/ceph/file.c b/fs/ceph/file.c
index 2e8e326b39d1..5154145f8084 100644
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@ -2296,6 +2296,10 @@ static ssize_t ceph_do_objects_copy(struct ceph_inode_info *src_ci, u64 *src_off
 		else {
 			ceph_osdc_start_request(osdc, req, false);
 			ret = ceph_osdc_wait_request(osdc, req);
+			ceph_update_copyfrom_metrics(&fsc->mdsc->metric,
+						     req->r_start_latency,
+						     req->r_end_latency,
+						     object_size, ret);
 			ceph_osdc_put_request(req);
 		}
 		if (ret) {
* Unmerged path fs/ceph/metric.h
