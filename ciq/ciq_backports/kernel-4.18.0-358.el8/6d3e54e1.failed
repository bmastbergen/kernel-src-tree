serial: 8250: Sanitize rs485 config harder

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Lukas Wunner <lukas@wunner.de>
commit 6d3e54e1955ed1cd2da9a90c944290e91772cbcb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/6d3e54e1.failed

Amend the generic ->rs485_config() callback to sanitize RTS polarity and
zero-fill the padding (in addition to the existing sanitization of the
RTS delays).

	Signed-off-by: Lukas Wunner <lukas@wunner.de>
	Cc: Matwey V. Kornilov <matwey@sai.msu.ru>
Link: https://lore.kernel.org/r/ff833721bc372d38678f289eb2a44dbf016d5203.1582895077.git.lukas@wunner.de
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 6d3e54e1955ed1cd2da9a90c944290e91772cbcb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/serial/8250/8250_port.c
diff --cc drivers/tty/serial/8250/8250_port.c
index df6900256379,d281aea061d6..000000000000
--- a/drivers/tty/serial/8250/8250_port.c
+++ b/drivers/tty/serial/8250/8250_port.c
@@@ -676,6 -663,52 +676,55 @@@ void serial8250_em485_destroy(struct ua
  }
  EXPORT_SYMBOL_GPL(serial8250_em485_destroy);
  
++<<<<<<< HEAD
++=======
+ /**
+  * serial8250_em485_config() - generic ->rs485_config() callback
+  * @port: uart port
+  * @rs485: rs485 settings
+  *
+  * Generic callback usable by 8250 uart drivers to activate rs485 settings
+  * if the uart is incapable of driving RTS as a Transmit Enable signal in
+  * hardware, relying on software emulation instead.
+  */
+ int serial8250_em485_config(struct uart_port *port, struct serial_rs485 *rs485)
+ {
+ 	struct uart_8250_port *up = up_to_u8250p(port);
+ 
+ 	/* pick sane settings if the user hasn't */
+ 	if (!!(rs485->flags & SER_RS485_RTS_ON_SEND) ==
+ 	    !!(rs485->flags & SER_RS485_RTS_AFTER_SEND)) {
+ 		rs485->flags |= SER_RS485_RTS_ON_SEND;
+ 		rs485->flags &= ~SER_RS485_RTS_AFTER_SEND;
+ 	}
+ 
+ 	/* clamp the delays to [0, 100ms] */
+ 	rs485->delay_rts_before_send = min(rs485->delay_rts_before_send, 100U);
+ 	rs485->delay_rts_after_send  = min(rs485->delay_rts_after_send, 100U);
+ 
+ 	memset(rs485->padding, 0, sizeof(rs485->padding));
+ 	port->rs485 = *rs485;
+ 
+ 	/*
+ 	 * Both serial8250_em485_init() and serial8250_em485_destroy()
+ 	 * are idempotent.
+ 	 */
+ 	if (rs485->flags & SER_RS485_ENABLED) {
+ 		int ret = serial8250_em485_init(up);
+ 
+ 		if (ret) {
+ 			rs485->flags &= ~SER_RS485_ENABLED;
+ 			port->rs485.flags &= ~SER_RS485_ENABLED;
+ 		}
+ 		return ret;
+ 	}
+ 
+ 	serial8250_em485_destroy(up);
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(serial8250_em485_config);
+ 
++>>>>>>> 6d3e54e1955e (serial: 8250: Sanitize rs485 config harder)
  /*
   * These two wrappers ensure that enable_runtime_pm_tx() can be called more than
   * once and disable_runtime_pm_tx() will still disable RPM because the fifo is
* Unmerged path drivers/tty/serial/8250/8250_port.c
