powerpc/smp: Use existing L2 cache_map cpumask to find L3 cache siblings

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Parth Shah <parth@linux.ibm.com>
commit e9ef81e1079b0c4c374fba0f9affa7129c7c913b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/e9ef81e1.failed

On POWER10 systems, the "ibm,thread-groups" property "2" indicates the cpus
in thread-group share both L2 and L3 caches. Hence, use cache_property = 2
itself to find both the L2 and L3 cache siblings.
Hence, create a new thread_group_l3_cache_map to keep list of L3 siblings,
but fill the mask using same property "2" array.

	Signed-off-by: Parth Shah <parth@linux.ibm.com>
	Reviewed-by: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20210728175607.591679-4-parth@linux.ibm.com

(cherry picked from commit e9ef81e1079b0c4c374fba0f9affa7129c7c913b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/smp.h
#	arch/powerpc/kernel/cacheinfo.c
diff --cc arch/powerpc/include/asm/smp.h
index 99568f469c8e,7ef1cd8168a0..000000000000
--- a/arch/powerpc/include/asm/smp.h
+++ b/arch/powerpc/include/asm/smp.h
@@@ -38,6 -33,10 +38,13 @@@ extern void cpu_die(void)
  extern int cpu_to_chip_id(int cpu);
  extern int *chip_id_lookup_table;
  
++<<<<<<< HEAD
++=======
+ DECLARE_PER_CPU(cpumask_var_t, thread_group_l1_cache_map);
+ DECLARE_PER_CPU(cpumask_var_t, thread_group_l2_cache_map);
+ DECLARE_PER_CPU(cpumask_var_t, thread_group_l3_cache_map);
+ 
++>>>>>>> e9ef81e1079b (powerpc/smp: Use existing L2 cache_map cpumask to find L3 cache siblings)
  #ifdef CONFIG_SMP
  
  struct smp_ops_t {
diff --cc arch/powerpc/kernel/cacheinfo.c
index e56d591f03f8,cf1be75b7833..000000000000
--- a/arch/powerpc/kernel/cacheinfo.c
+++ b/arch/powerpc/kernel/cacheinfo.c
@@@ -427,11 -442,40 +427,38 @@@ static void link_cache_lists(struct cac
  
  static void do_subsidiary_caches_debugcheck(struct cache *cache)
  {
 -	WARN_ONCE(cache->level != 1,
 -		  "instantiating cache chain from L%d %s cache for "
 -		  "%pOFP instead of an L1\n", cache->level,
 -		  cache_type_string(cache), cache->ofnode);
 -	WARN_ONCE(!of_node_is_type(cache->ofnode, "cpu"),
 -		  "instantiating cache chain from node %pOFP of type '%s' "
 -		  "instead of a cpu node\n", cache->ofnode,
 -		  of_node_get_device_type(cache->ofnode));
 +	WARN_ON_ONCE(cache->level != 1);
 +	WARN_ON_ONCE(strcmp(cache->ofnode->type, "cpu"));
  }
  
++<<<<<<< HEAD
 +static void do_subsidiary_caches(struct cache *cache)
++=======
+ /*
+  * If sub-groups of threads in a core containing @cpu_id share the
+  * L@level-cache (information obtained via "ibm,thread-groups"
+  * device-tree property), then we identify the group by the first
+  * thread-sibling in the group. We define this to be the group-id.
+  *
+  * In the absence of any thread-group information for L@level-cache,
+  * this function returns -1.
+  */
+ static int get_group_id(unsigned int cpu_id, int level)
+ {
+ 	if (has_big_cores && level == 1)
+ 		return cpumask_first(per_cpu(thread_group_l1_cache_map,
+ 					     cpu_id));
+ 	else if (thread_group_shares_l2 && level == 2)
+ 		return cpumask_first(per_cpu(thread_group_l2_cache_map,
+ 					     cpu_id));
+ 	else if (thread_group_shares_l3 && level == 3)
+ 		return cpumask_first(per_cpu(thread_group_l3_cache_map,
+ 					     cpu_id));
+ 	return -1;
+ }
+ 
+ static void do_subsidiary_caches(struct cache *cache, unsigned int cpu_id)
++>>>>>>> e9ef81e1079b (powerpc/smp: Use existing L2 cache_map cpumask to find L3 cache siblings)
  {
  	struct device_node *subcache_node;
  	int level = cache->level;
* Unmerged path arch/powerpc/include/asm/smp.h
* Unmerged path arch/powerpc/kernel/cacheinfo.c
diff --git a/arch/powerpc/kernel/smp.c b/arch/powerpc/kernel/smp.c
index 8c7f550269c7..fb0d59cc26b3 100644
--- a/arch/powerpc/kernel/smp.c
+++ b/arch/powerpc/kernel/smp.c
@@ -79,6 +79,7 @@ struct thread_info *secondary_ti;
 bool has_big_cores;
 bool coregroup_enabled;
 bool thread_group_shares_l2;
+bool thread_group_shares_l3;
 
 DEFINE_PER_CPU(cpumask_var_t, cpu_sibling_map);
 DEFINE_PER_CPU(cpumask_var_t, cpu_smallcore_map);
@@ -102,7 +103,7 @@ enum {
 
 #define MAX_THREAD_LIST_SIZE	8
 #define THREAD_GROUP_SHARE_L1   1
-#define THREAD_GROUP_SHARE_L2   2
+#define THREAD_GROUP_SHARE_L2_L3 2
 struct thread_groups {
 	unsigned int property;
 	unsigned int nr_groups;
@@ -132,6 +133,12 @@ DEFINE_PER_CPU(cpumask_var_t, thread_group_l1_cache_map);
  */
 DEFINE_PER_CPU(cpumask_var_t, thread_group_l2_cache_map);
 
+/*
+ * On P10, thread_group_l3_cache_map for each CPU is equal to the
+ * thread_group_l2_cache_map
+ */
+DEFINE_PER_CPU(cpumask_var_t, thread_group_l3_cache_map);
+
 /* SMP operations for this machine */
 struct smp_ops_t *smp_ops;
 
@@ -878,19 +885,41 @@ static struct thread_groups *__init get_thread_groups(int cpu,
 	return tg;
 }
 
+static int update_mask_from_threadgroup(cpumask_var_t *mask, struct thread_groups *tg, int cpu, int cpu_group_start)
+{
+	int first_thread = cpu_first_thread_sibling(cpu);
+	int i;
+
+	zalloc_cpumask_var_node(mask, GFP_KERNEL, cpu_to_node(cpu));
+
+	for (i = first_thread; i < first_thread + threads_per_core; i++) {
+		int i_group_start = get_cpu_thread_group_start(i, tg);
+
+		if (unlikely(i_group_start == -1)) {
+			WARN_ON_ONCE(1);
+			return -ENODATA;
+		}
+
+		if (i_group_start == cpu_group_start)
+			cpumask_set_cpu(i, *mask);
+	}
+
+	return 0;
+}
+
 static int __init init_thread_group_cache_map(int cpu, int cache_property)
 
 {
-	int first_thread = cpu_first_thread_sibling(cpu);
-	int i, cpu_group_start = -1, err = 0;
+	int cpu_group_start = -1, err = 0;
 	struct thread_groups *tg = NULL;
 	cpumask_var_t *mask = NULL;
 
 	if (cache_property != THREAD_GROUP_SHARE_L1 &&
-	    cache_property != THREAD_GROUP_SHARE_L2)
+	    cache_property != THREAD_GROUP_SHARE_L2_L3)
 		return -EINVAL;
 
 	tg = get_thread_groups(cpu, cache_property, &err);
+
 	if (!tg)
 		return err;
 
@@ -901,25 +930,18 @@ static int __init init_thread_group_cache_map(int cpu, int cache_property)
 		return -ENODATA;
 	}
 
-	if (cache_property == THREAD_GROUP_SHARE_L1)
+	if (cache_property == THREAD_GROUP_SHARE_L1) {
 		mask = &per_cpu(thread_group_l1_cache_map, cpu);
-	else if (cache_property == THREAD_GROUP_SHARE_L2)
+		update_mask_from_threadgroup(mask, tg, cpu, cpu_group_start);
+	}
+	else if (cache_property == THREAD_GROUP_SHARE_L2_L3) {
 		mask = &per_cpu(thread_group_l2_cache_map, cpu);
-
-	zalloc_cpumask_var_node(mask, GFP_KERNEL, cpu_to_node(cpu));
-
-	for (i = first_thread; i < first_thread + threads_per_core; i++) {
-		int i_group_start = get_cpu_thread_group_start(i, tg);
-
-		if (unlikely(i_group_start == -1)) {
-			WARN_ON_ONCE(1);
-			return -ENODATA;
-		}
-
-		if (i_group_start == cpu_group_start)
-			cpumask_set_cpu(i, *mask);
+		update_mask_from_threadgroup(mask, tg, cpu, cpu_group_start);
+		mask = &per_cpu(thread_group_l3_cache_map, cpu);
+		update_mask_from_threadgroup(mask, tg, cpu, cpu_group_start);
 	}
 
+
 	return 0;
 }
 
@@ -1009,14 +1031,16 @@ static int init_big_cores(void)
 	has_big_cores = true;
 
 	for_each_possible_cpu(cpu) {
-		int err = init_thread_group_cache_map(cpu, THREAD_GROUP_SHARE_L2);
+		int err = init_thread_group_cache_map(cpu, THREAD_GROUP_SHARE_L2_L3);
 
 		if (err)
 			return err;
 	}
 
 	thread_group_shares_l2 = true;
-	pr_debug("L2 cache only shared by the threads in the small core\n");
+	thread_group_shares_l3 = true;
+	pr_debug("L2/L3 cache only shared by the threads in the small core\n");
+
 	return 0;
 }
 
