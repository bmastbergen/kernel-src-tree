x86/fpu: Don't store PKRU in xstate in fpu_reset_fpstate()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 0e8c54f6b2c8b1037cef9276e451522ee90ed969
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/0e8c54f6.failed

PKRU for a task is stored in task->thread.pkru when the task is scheduled
out. For 'current' the authoritative source of PKRU is the hardware.

fpu_reset_fpstate() has two callers:

  1) fpu__clear_user_states() for !FPU systems. For those PKRU is irrelevant

  2) fpu_flush_thread() which is invoked from flush_thread(). flush_thread()
     resets the hardware to the kernel restrictive default value.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20210623121456.802850233@linutronix.de
(cherry picked from commit 0e8c54f6b2c8b1037cef9276e451522ee90ed969)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/core.c
diff --cc arch/x86/kernel/fpu/core.c
index d86fb6c58479,5295cbafc92e..000000000000
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@@ -356,17 -325,51 +356,63 @@@ static inline void copy_init_fpstate_to
  	else
  		frstor(&init_fpstate.fsave);
  
++<<<<<<< HEAD
 +	if (boot_cpu_has(X86_FEATURE_OSPKE))
 +		copy_init_pkru_to_fpregs();
++=======
+ 	pkru_write_default();
+ }
+ 
+ static inline unsigned int init_fpstate_copy_size(void)
+ {
+ 	if (!use_xsave())
+ 		return fpu_kernel_xstate_size;
+ 
+ 	/* XSAVE(S) just needs the legacy and the xstate header part */
+ 	return sizeof(init_fpstate.xsave);
++>>>>>>> 0e8c54f6b2c8 (x86/fpu: Don't store PKRU in xstate in fpu_reset_fpstate())
  }
  
  /*
 - * Reset current->fpu memory state to the init values.
 + * Clear the FPU state back to init state.
 + *
 + * Called by sys_execve(), by the signal handler code and by various
 + * error paths.
   */
++<<<<<<< HEAD
 +static void fpu__clear(struct fpu *fpu, bool user_only)
++=======
+ static void fpu_reset_fpstate(void)
+ {
+ 	struct fpu *fpu = &current->thread.fpu;
+ 
+ 	fpregs_lock();
+ 	fpu__drop(fpu);
+ 	/*
+ 	 * This does not change the actual hardware registers. It just
+ 	 * resets the memory image and sets TIF_NEED_FPU_LOAD so a
+ 	 * subsequent return to usermode will reload the registers from the
+ 	 * task's memory image.
+ 	 *
+ 	 * Do not use fpstate_init() here. Just copy init_fpstate which has
+ 	 * the correct content already except for PKRU.
+ 	 *
+ 	 * PKRU handling does not rely on the xstate when restoring for
+ 	 * user space as PKRU is eagerly written in switch_to() and
+ 	 * flush_thread().
+ 	 */
+ 	memcpy(&fpu->state, &init_fpstate, init_fpstate_copy_size());
+ 	set_thread_flag(TIF_NEED_FPU_LOAD);
+ 	fpregs_unlock();
+ }
+ 
+ /*
+  * Reset current's user FPU states to the init states.  current's
+  * supervisor states, if any, are not modified by this function.  The
+  * caller guarantees that the XSTATE header in memory is intact.
+  */
+ void fpu__clear_user_states(struct fpu *fpu)
++>>>>>>> 0e8c54f6b2c8 (x86/fpu: Don't store PKRU in xstate in fpu_reset_fpstate())
  {
  	WARN_ON_FPU(fpu != &current->thread.fpu);
  
* Unmerged path arch/x86/kernel/fpu/core.c
