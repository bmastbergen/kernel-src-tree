locking/rtmutex: Add adaptive spinwait mechanism

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Steven Rostedt <rostedt@goodmis.org>
commit 992caf7f17243d736fc996770bac6566103778f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/992caf7f.failed

Going to sleep when locks are contended can be quite inefficient when the
contention time is short and the lock owner is running on a different CPU.

The MCS mechanism cannot be used because MCS is strictly FIFO ordered while
for rtmutex based locks the waiter ordering is priority based.

Provide a simple adaptive spinwait mechanism which currently restricts the
spinning to the top priority waiter.

[ tglx: Provide a contemporary changelog, extended it to all rtmutex based
  	locks and updated it to match the other spin on owner implementations ]

Originally-by: Gregory Haskins <ghaskins@novell.com>
	Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
Link: https://lore.kernel.org/r/20210815211305.912050691@linutronix.de
(cherry picked from commit 992caf7f17243d736fc996770bac6566103778f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/locking/rtmutex.c
diff --cc kernel/locking/rtmutex.c
index ebfe41ea03fb,8aaa352d0c17..000000000000
--- a/kernel/locking/rtmutex.c
+++ b/kernel/locking/rtmutex.c
@@@ -1422,3 -1301,373 +1427,376 @@@ static __always_inline void __rt_mutex_
  
  	rt_mutex_slowunlock(lock);
  }
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_SMP
+ static bool rtmutex_spin_on_owner(struct rt_mutex_base *lock,
+ 				  struct rt_mutex_waiter *waiter,
+ 				  struct task_struct *owner)
+ {
+ 	bool res = true;
+ 
+ 	rcu_read_lock();
+ 	for (;;) {
+ 		/* If owner changed, trylock again. */
+ 		if (owner != rt_mutex_owner(lock))
+ 			break;
+ 		/*
+ 		 * Ensure that @owner is dereferenced after checking that
+ 		 * the lock owner still matches @owner. If that fails,
+ 		 * @owner might point to freed memory. If it still matches,
+ 		 * the rcu_read_lock() ensures the memory stays valid.
+ 		 */
+ 		barrier();
+ 		/*
+ 		 * Stop spinning when:
+ 		 *  - the lock owner has been scheduled out
+ 		 *  - current is not longer the top waiter
+ 		 *  - current is requested to reschedule (redundant
+ 		 *    for CONFIG_PREEMPT_RCU=y)
+ 		 *  - the VCPU on which owner runs is preempted
+ 		 */
+ 		if (!owner->on_cpu || waiter != rt_mutex_top_waiter(lock) ||
+ 		    need_resched() || vcpu_is_preempted(task_cpu(owner))) {
+ 			res = false;
+ 			break;
+ 		}
+ 		cpu_relax();
+ 	}
+ 	rcu_read_unlock();
+ 	return res;
+ }
+ #else
+ static bool rtmutex_spin_on_owner(struct rt_mutex_base *lock,
+ 				  struct rt_mutex_waiter *waiter,
+ 				  struct task_struct *owner)
+ {
+ 	return false;
+ }
+ #endif
+ 
+ #ifdef RT_MUTEX_BUILD_MUTEX
+ /*
+  * Functions required for:
+  *	- rtmutex, futex on all kernels
+  *	- mutex and rwsem substitutions on RT kernels
+  */
+ 
+ /*
+  * Remove a waiter from a lock and give up
+  *
+  * Must be called with lock->wait_lock held and interrupts disabled. It must
+  * have just failed to try_to_take_rt_mutex().
+  */
+ static void __sched remove_waiter(struct rt_mutex_base *lock,
+ 				  struct rt_mutex_waiter *waiter)
+ {
+ 	bool is_top_waiter = (waiter == rt_mutex_top_waiter(lock));
+ 	struct task_struct *owner = rt_mutex_owner(lock);
+ 	struct rt_mutex_base *next_lock;
+ 
+ 	lockdep_assert_held(&lock->wait_lock);
+ 
+ 	raw_spin_lock(&current->pi_lock);
+ 	rt_mutex_dequeue(lock, waiter);
+ 	current->pi_blocked_on = NULL;
+ 	raw_spin_unlock(&current->pi_lock);
+ 
+ 	/*
+ 	 * Only update priority if the waiter was the highest priority
+ 	 * waiter of the lock and there is an owner to update.
+ 	 */
+ 	if (!owner || !is_top_waiter)
+ 		return;
+ 
+ 	raw_spin_lock(&owner->pi_lock);
+ 
+ 	rt_mutex_dequeue_pi(owner, waiter);
+ 
+ 	if (rt_mutex_has_waiters(lock))
+ 		rt_mutex_enqueue_pi(owner, rt_mutex_top_waiter(lock));
+ 
+ 	rt_mutex_adjust_prio(owner);
+ 
+ 	/* Store the lock on which owner is blocked or NULL */
+ 	next_lock = task_blocked_on_lock(owner);
+ 
+ 	raw_spin_unlock(&owner->pi_lock);
+ 
+ 	/*
+ 	 * Don't walk the chain, if the owner task is not blocked
+ 	 * itself.
+ 	 */
+ 	if (!next_lock)
+ 		return;
+ 
+ 	/* gets dropped in rt_mutex_adjust_prio_chain()! */
+ 	get_task_struct(owner);
+ 
+ 	raw_spin_unlock_irq(&lock->wait_lock);
+ 
+ 	rt_mutex_adjust_prio_chain(owner, RT_MUTEX_MIN_CHAINWALK, lock,
+ 				   next_lock, NULL, current);
+ 
+ 	raw_spin_lock_irq(&lock->wait_lock);
+ }
+ 
+ /**
+  * rt_mutex_slowlock_block() - Perform the wait-wake-try-to-take loop
+  * @lock:		 the rt_mutex to take
+  * @ww_ctx:		 WW mutex context pointer
+  * @state:		 the state the task should block in (TASK_INTERRUPTIBLE
+  *			 or TASK_UNINTERRUPTIBLE)
+  * @timeout:		 the pre-initialized and started timer, or NULL for none
+  * @waiter:		 the pre-initialized rt_mutex_waiter
+  *
+  * Must be called with lock->wait_lock held and interrupts disabled
+  */
+ static int __sched rt_mutex_slowlock_block(struct rt_mutex_base *lock,
+ 					   struct ww_acquire_ctx *ww_ctx,
+ 					   unsigned int state,
+ 					   struct hrtimer_sleeper *timeout,
+ 					   struct rt_mutex_waiter *waiter)
+ {
+ 	struct rt_mutex *rtm = container_of(lock, struct rt_mutex, rtmutex);
+ 	struct task_struct *owner;
+ 	int ret = 0;
+ 
+ 	for (;;) {
+ 		/* Try to acquire the lock: */
+ 		if (try_to_take_rt_mutex(lock, current, waiter))
+ 			break;
+ 
+ 		if (timeout && !timeout->task) {
+ 			ret = -ETIMEDOUT;
+ 			break;
+ 		}
+ 		if (signal_pending_state(state, current)) {
+ 			ret = -EINTR;
+ 			break;
+ 		}
+ 
+ 		if (build_ww_mutex() && ww_ctx) {
+ 			ret = __ww_mutex_check_kill(rtm, waiter, ww_ctx);
+ 			if (ret)
+ 				break;
+ 		}
+ 
+ 		if (waiter == rt_mutex_top_waiter(lock))
+ 			owner = rt_mutex_owner(lock);
+ 		else
+ 			owner = NULL;
+ 		raw_spin_unlock_irq(&lock->wait_lock);
+ 
+ 		if (!owner || !rtmutex_spin_on_owner(lock, waiter, owner))
+ 			schedule();
+ 
+ 		raw_spin_lock_irq(&lock->wait_lock);
+ 		set_current_state(state);
+ 	}
+ 
+ 	__set_current_state(TASK_RUNNING);
+ 	return ret;
+ }
+ 
+ static void __sched rt_mutex_handle_deadlock(int res, int detect_deadlock,
+ 					     struct rt_mutex_waiter *w)
+ {
+ 	/*
+ 	 * If the result is not -EDEADLOCK or the caller requested
+ 	 * deadlock detection, nothing to do here.
+ 	 */
+ 	if (res != -EDEADLOCK || detect_deadlock)
+ 		return;
+ 
+ 	if (build_ww_mutex() && w->ww_ctx)
+ 		return;
+ 
+ 	/*
+ 	 * Yell loudly and stop the task right here.
+ 	 */
+ 	WARN(1, "rtmutex deadlock detected\n");
+ 	while (1) {
+ 		set_current_state(TASK_INTERRUPTIBLE);
+ 		schedule();
+ 	}
+ }
+ 
+ /**
+  * __rt_mutex_slowlock - Locking slowpath invoked with lock::wait_lock held
+  * @lock:	The rtmutex to block lock
+  * @ww_ctx:	WW mutex context pointer
+  * @state:	The task state for sleeping
+  * @chwalk:	Indicator whether full or partial chainwalk is requested
+  * @waiter:	Initializer waiter for blocking
+  */
+ static int __sched __rt_mutex_slowlock(struct rt_mutex_base *lock,
+ 				       struct ww_acquire_ctx *ww_ctx,
+ 				       unsigned int state,
+ 				       enum rtmutex_chainwalk chwalk,
+ 				       struct rt_mutex_waiter *waiter)
+ {
+ 	struct rt_mutex *rtm = container_of(lock, struct rt_mutex, rtmutex);
+ 	struct ww_mutex *ww = ww_container_of(rtm);
+ 	int ret;
+ 
+ 	lockdep_assert_held(&lock->wait_lock);
+ 
+ 	/* Try to acquire the lock again: */
+ 	if (try_to_take_rt_mutex(lock, current, NULL)) {
+ 		if (build_ww_mutex() && ww_ctx) {
+ 			__ww_mutex_check_waiters(rtm, ww_ctx);
+ 			ww_mutex_lock_acquired(ww, ww_ctx);
+ 		}
+ 		return 0;
+ 	}
+ 
+ 	set_current_state(state);
+ 
+ 	ret = task_blocks_on_rt_mutex(lock, waiter, current, ww_ctx, chwalk);
+ 	if (likely(!ret))
+ 		ret = rt_mutex_slowlock_block(lock, ww_ctx, state, NULL, waiter);
+ 
+ 	if (likely(!ret)) {
+ 		/* acquired the lock */
+ 		if (build_ww_mutex() && ww_ctx) {
+ 			if (!ww_ctx->is_wait_die)
+ 				__ww_mutex_check_waiters(rtm, ww_ctx);
+ 			ww_mutex_lock_acquired(ww, ww_ctx);
+ 		}
+ 	} else {
+ 		__set_current_state(TASK_RUNNING);
+ 		remove_waiter(lock, waiter);
+ 		rt_mutex_handle_deadlock(ret, chwalk, waiter);
+ 	}
+ 
+ 	/*
+ 	 * try_to_take_rt_mutex() sets the waiter bit
+ 	 * unconditionally. We might have to fix that up.
+ 	 */
+ 	fixup_rt_mutex_waiters(lock);
+ 	return ret;
+ }
+ 
+ static inline int __rt_mutex_slowlock_locked(struct rt_mutex_base *lock,
+ 					     struct ww_acquire_ctx *ww_ctx,
+ 					     unsigned int state)
+ {
+ 	struct rt_mutex_waiter waiter;
+ 	int ret;
+ 
+ 	rt_mutex_init_waiter(&waiter);
+ 	waiter.ww_ctx = ww_ctx;
+ 
+ 	ret = __rt_mutex_slowlock(lock, ww_ctx, state, RT_MUTEX_MIN_CHAINWALK,
+ 				  &waiter);
+ 
+ 	debug_rt_mutex_free_waiter(&waiter);
+ 	return ret;
+ }
+ 
+ /*
+  * rt_mutex_slowlock - Locking slowpath invoked when fast path fails
+  * @lock:	The rtmutex to block lock
+  * @ww_ctx:	WW mutex context pointer
+  * @state:	The task state for sleeping
+  */
+ static int __sched rt_mutex_slowlock(struct rt_mutex_base *lock,
+ 				     struct ww_acquire_ctx *ww_ctx,
+ 				     unsigned int state)
+ {
+ 	unsigned long flags;
+ 	int ret;
+ 
+ 	/*
+ 	 * Technically we could use raw_spin_[un]lock_irq() here, but this can
+ 	 * be called in early boot if the cmpxchg() fast path is disabled
+ 	 * (debug, no architecture support). In this case we will acquire the
+ 	 * rtmutex with lock->wait_lock held. But we cannot unconditionally
+ 	 * enable interrupts in that early boot case. So we need to use the
+ 	 * irqsave/restore variants.
+ 	 */
+ 	raw_spin_lock_irqsave(&lock->wait_lock, flags);
+ 	ret = __rt_mutex_slowlock_locked(lock, ww_ctx, state);
+ 	raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
+ 
+ 	return ret;
+ }
+ 
+ static __always_inline int __rt_mutex_lock(struct rt_mutex_base *lock,
+ 					   unsigned int state)
+ {
+ 	if (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))
+ 		return 0;
+ 
+ 	return rt_mutex_slowlock(lock, NULL, state);
+ }
+ #endif /* RT_MUTEX_BUILD_MUTEX */
+ 
+ #ifdef RT_MUTEX_BUILD_SPINLOCKS
+ /*
+  * Functions required for spin/rw_lock substitution on RT kernels
+  */
+ 
+ /**
+  * rtlock_slowlock_locked - Slow path lock acquisition for RT locks
+  * @lock:	The underlying RT mutex
+  */
+ static void __sched rtlock_slowlock_locked(struct rt_mutex_base *lock)
+ {
+ 	struct rt_mutex_waiter waiter;
+ 	struct task_struct *owner;
+ 
+ 	lockdep_assert_held(&lock->wait_lock);
+ 
+ 	if (try_to_take_rt_mutex(lock, current, NULL))
+ 		return;
+ 
+ 	rt_mutex_init_rtlock_waiter(&waiter);
+ 
+ 	/* Save current state and set state to TASK_RTLOCK_WAIT */
+ 	current_save_and_set_rtlock_wait_state();
+ 
+ 	task_blocks_on_rt_mutex(lock, &waiter, current, NULL, RT_MUTEX_MIN_CHAINWALK);
+ 
+ 	for (;;) {
+ 		/* Try to acquire the lock again */
+ 		if (try_to_take_rt_mutex(lock, current, &waiter))
+ 			break;
+ 
+ 		if (&waiter == rt_mutex_top_waiter(lock))
+ 			owner = rt_mutex_owner(lock);
+ 		else
+ 			owner = NULL;
+ 		raw_spin_unlock_irq(&lock->wait_lock);
+ 
+ 		if (!owner || !rtmutex_spin_on_owner(lock, &waiter, owner))
+ 			schedule_rtlock();
+ 
+ 		raw_spin_lock_irq(&lock->wait_lock);
+ 		set_current_state(TASK_RTLOCK_WAIT);
+ 	}
+ 
+ 	/* Restore the task state */
+ 	current_restore_rtlock_saved_state();
+ 
+ 	/*
+ 	 * try_to_take_rt_mutex() sets the waiter bit unconditionally.
+ 	 * We might have to fix that up:
+ 	 */
+ 	fixup_rt_mutex_waiters(lock);
+ 	debug_rt_mutex_free_waiter(&waiter);
+ }
+ 
+ static __always_inline void __sched rtlock_slowlock(struct rt_mutex_base *lock)
+ {
+ 	unsigned long flags;
+ 
+ 	raw_spin_lock_irqsave(&lock->wait_lock, flags);
+ 	rtlock_slowlock_locked(lock);
+ 	raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
+ }
+ 
+ #endif /* RT_MUTEX_BUILD_SPINLOCKS */
++>>>>>>> 992caf7f1724 (locking/rtmutex: Add adaptive spinwait mechanism)
* Unmerged path kernel/locking/rtmutex.c
