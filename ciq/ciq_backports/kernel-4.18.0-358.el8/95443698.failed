x86/fpu: Remove PKRU handling from switch_fpu_finish()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 954436989cc550dd91aab98363240c9c0a4b7e23
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/95443698.failed

PKRU is already updated and the xstate is not longer the proper source
of information.

 [ bp: Use cpu_feature_enabled() ]

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20210623121456.708180184@linutronix.de
(cherry picked from commit 954436989cc550dd91aab98363240c9c0a4b7e23)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/fpu/internal.h
diff --cc arch/x86/include/asm/fpu/internal.h
index 5a42546d89cb,528a86826f95..000000000000
--- a/arch/x86/include/asm/fpu/internal.h
+++ b/arch/x86/include/asm/fpu/internal.h
@@@ -527,41 -528,8 +527,46 @@@ static inline void switch_fpu_prepare(s
   */
  static inline void switch_fpu_finish(struct fpu *new_fpu)
  {
++<<<<<<< HEAD
 +	u32 pkru_val = init_pkru_value;
 +	struct pkru_state *pk;
 +
 +	if (!static_cpu_has(X86_FEATURE_FPU))
 +		return;
 +
 +	set_thread_flag(TIF_NEED_FPU_LOAD);
 +
 +	if (!cpu_feature_enabled(X86_FEATURE_OSPKE))
 +		return;
 +
 +	/*
 +	 * PKRU state is switched eagerly because it needs to be valid before we
 +	 * return to userland e.g. for a copy_to_user() operation.
 +	 */
 +	if (!(current->flags & PF_KTHREAD)) {
 +		/*
 +		 * If the PKRU bit in xsave.header.xfeatures is not set,
 +		 * then the PKRU component was in init state, which means
 +		 * XRSTOR will set PKRU to 0. If the bit is not set then
 +		 * get_xsave_addr() will return NULL because the PKRU value
 +		 * in memory is not valid. This means pkru_val has to be
 +		 * set to 0 and not to init_pkru_value.
 +		 */
 +		pk = get_xsave_addr(&new_fpu->state.xsave, XFEATURE_PKRU);
 +		pkru_val = pk ? pk->pkru : 0;
 +	}
 +	__write_pkru(pkru_val);
 +
 +	/*
 +	 * Expensive PASID MSR write will be avoided in update_pasid() because
 +	 * TIF_NEED_FPU_LOAD was set. And the PASID state won't be updated
 +	 * unless it's different from mm->pasid to reduce overhead.
 +	 */
 +	update_pasid();
++=======
+ 	if (cpu_feature_enabled(X86_FEATURE_FPU))
+ 		set_thread_flag(TIF_NEED_FPU_LOAD);
++>>>>>>> 954436989cc5 (x86/fpu: Remove PKRU handling from switch_fpu_finish())
  }
  
  #endif /* _ASM_X86_FPU_INTERNAL_H */
* Unmerged path arch/x86/include/asm/fpu/internal.h
