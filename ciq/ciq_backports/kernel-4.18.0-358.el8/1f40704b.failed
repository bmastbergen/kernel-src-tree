PCI: Move pci_match_device() ahead of new_id_store()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Zhenzhong Duan <zhenzhong.duan@gmail.com>
commit 1f40704bb01b9fba9925006662a37373d514f26b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/1f40704b.failed

Move pci_match_device() and its dependencies (pci_match_id() and
pci_device_id_any) ahead of new_id_store().

This is preparation work for calling pci_match_device() in new_id_store().
No functional changes.

[bhelgaas: update function comments]
Link: https://lore.kernel.org/r/20201117054409.3428-2-zhenzhong.duan@gmail.com
	Signed-off-by: Zhenzhong Duan <zhenzhong.duan@gmail.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 1f40704bb01b9fba9925006662a37373d514f26b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci-driver.c
diff --cc drivers/pci/pci-driver.c
index 5e196e4b29a2,965b3d772cdf..000000000000
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@@ -208,126 -281,6 +281,129 @@@ static struct attribute *pci_drv_attrs[
  };
  ATTRIBUTE_GROUPS(pci_drv);
  
++<<<<<<< HEAD
 +/**
 + * pci_match_id - See if a pci device matches a given pci_id table
 + * @ids: array of PCI device id structures to search in
 + * @dev: the PCI device structure to match against.
 + *
 + * Used by a driver to check whether a PCI device present in the
 + * system is in its list of supported devices.  Returns the matching
 + * pci_device_id structure or %NULL if there is no match.
 + *
 + * Deprecated, don't use this as it will not catch any dynamic ids
 + * that a driver might want to check for.
 + */
 +const struct pci_device_id *pci_match_id(const struct pci_device_id *ids,
 +					 struct pci_dev *dev)
 +{
 +	if (ids) {
 +		while (ids->vendor || ids->subvendor || ids->class_mask) {
 +			if (pci_match_one_device(ids, dev))
 +				return ids;
 +			ids++;
 +		}
 +	}
 +	return NULL;
 +}
 +EXPORT_SYMBOL(pci_match_id);
 +
 +static const struct pci_device_id pci_device_id_any = {
 +	.vendor = PCI_ANY_ID,
 +	.device = PCI_ANY_ID,
 +	.subvendor = PCI_ANY_ID,
 +	.subdevice = PCI_ANY_ID,
 +};
 +
 +/**
 + * pci_match_device - Tell if a PCI device structure has a matching PCI device id structure
 + * @drv: the PCI driver to match against
 + * @dev: the PCI device structure to match against
 + *
 + * Used by a driver to check whether a PCI device present in the
 + * system is in its list of supported devices.  Returns the matching
 + * pci_device_id structure or %NULL if there is no match.
 + */
 +static const struct pci_device_id *pci_match_device(struct pci_driver *drv,
 +						    struct pci_dev *dev)
 +{
 +	struct pci_dynid *dynid;
 +	const struct pci_device_id *found_id = NULL;
 +
 +	/* When driver_override is set, only bind to the matching driver */
 +	if (dev->driver_override && strcmp(dev->driver_override, drv->name))
 +		return NULL;
 +
 +	/* Look at the dynamic ids first, before the static ones */
 +	spin_lock(&drv->dynids.lock);
 +	list_for_each_entry(dynid, &drv->dynids.list, node) {
 +		if (pci_match_one_device(&dynid->id, dev)) {
 +			found_id = &dynid->id;
 +			break;
 +		}
 +	}
 +	spin_unlock(&drv->dynids.lock);
 +
 +	if (!found_id)
 +		found_id = pci_match_id(drv->id_table, dev);
 +
 +	/* driver_override will always match, send a dummy id */
 +	if (!found_id && dev->driver_override)
 +		found_id = &pci_device_id_any;
 +
 +	return found_id;
 +}
 +
 +/**
 + * pci_hw_vendor_status - Tell if a PCI device is supported by the HW vendor
 + * @ids: array of PCI device id structures to search in
 + * @dev: the PCI device structure to match against
 + *
 + * Used by a driver to check whether this device is in its list of unsupported
 + * devices.  Returns the matching pci_device_id structure or %NULL if there is
 + * no match.
 + *
 + * Reserved for Internal Red Hat use only.
 + */
 +const struct pci_device_id *pci_hw_vendor_status(
 +						const struct pci_device_id *ids,
 +						struct pci_dev *dev)
 +{
 +	char devinfo[64];
 +	const struct pci_device_id *ret = pci_match_id(ids, dev);
 +
 +	if (ret) {
 +		snprintf(devinfo, sizeof(devinfo), "%s %s",
 +			 dev_driver_string(&dev->dev), dev_name(&dev->dev));
 +		mark_hardware_deprecated(devinfo);
 +	}
 +
 +	return ret;
 +}
 +EXPORT_SYMBOL(pci_hw_vendor_status);
 +
 +/*
 + * check_pci_unsupported_hardware() tests if certain pci-id is
 + * unsupported and if needed calls mark_hardware_unsupported
 + */
 +void check_unsupported_pci_hardware(const struct pci_device_id *removed_ids,
 +                                    struct pci_dev *dev)
 +{
 +	char devinfo[64];
 +	const struct pci_device_id *ret = pci_match_id(removed_ids, dev);
 +
 +	if (!ret)
 +		return;
 +
 +	snprintf(devinfo, sizeof(devinfo), "%s %s [%04x:%04x]",
 +		dev_driver_string(&dev->dev), dev_name(&dev->dev),
 +		dev->vendor, dev->device);
 +	mark_hardware_unsupported(devinfo);
 +}
 +EXPORT_SYMBOL(check_unsupported_pci_hardware);
 +
++=======
++>>>>>>> 1f40704bb01b (PCI: Move pci_match_device() ahead of new_id_store())
  struct drv_dev_and_id {
  	struct pci_driver *drv;
  	struct pci_dev *dev;
* Unmerged path drivers/pci/pci-driver.c
