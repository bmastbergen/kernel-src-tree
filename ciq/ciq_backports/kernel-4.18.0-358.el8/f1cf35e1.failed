nvme: remove nvme_{get,put}_ns_from_disk

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Christoph Hellwig <hch@lst.de>
commit f1cf35e17ec308c0e76f55c6bccf84fff1a2d71a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/f1cf35e1.failed

Now that only one caller is left remove the helpers by restructuring
nvme_pr_command so that it has two helpers for sending a command of to a
given nsid using either the ns_head for multipath, or the namespace
stored in the gendisk.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Keith Busch <kbusch@kernel.org>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
(cherry picked from commit f1cf35e17ec308c0e76f55c6bccf84fff1a2d71a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
#	drivers/nvme/host/nvme.h
diff --cc drivers/nvme/host/core.c
index 228052b88c83,177cae44b612..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -1631,336 -1542,8 +1631,340 @@@ static void nvme_enable_aen(struct nvme
  	queue_work(nvme_wq, &ctrl->async_event_work);
  }
  
++<<<<<<< HEAD
 +/*
 + * Convert integer values from ioctl structures to user pointers, silently
 + * ignoring the upper bits in the compat case to match behaviour of 32-bit
 + * kernels.
 + */
 +static void __user *nvme_to_user_ptr(uintptr_t ptrval)
 +{
 +	if (in_compat_syscall())
 +		ptrval = (compat_uptr_t)ptrval;
 +	return (void __user *)ptrval;
 +}
 +
 +static int nvme_submit_io(struct nvme_ns *ns, struct nvme_user_io __user *uio)
 +{
 +	struct nvme_user_io io;
 +	struct nvme_command c;
 +	unsigned length, meta_len;
 +	void __user *metadata;
 +
 +	if (copy_from_user(&io, uio, sizeof(io)))
 +		return -EFAULT;
 +	if (io.flags)
 +		return -EINVAL;
 +
 +	switch (io.opcode) {
 +	case nvme_cmd_write:
 +	case nvme_cmd_read:
 +	case nvme_cmd_compare:
 +		break;
 +	default:
 +		return -EINVAL;
 +	}
 +
 +	length = (io.nblocks + 1) << ns->lba_shift;
 +
 +	if ((io.control & NVME_RW_PRINFO_PRACT) &&
 +	    ns->ms == sizeof(struct t10_pi_tuple)) {
 +		/*
 +		 * Protection information is stripped/inserted by the
 +		 * controller.
 +		 */
 +		if (nvme_to_user_ptr(io.metadata))
 +			return -EINVAL;
 +		meta_len = 0;
 +		metadata = NULL;
 +	} else {
 +		meta_len = (io.nblocks + 1) * ns->ms;
 +		metadata = nvme_to_user_ptr(io.metadata);
 +	}
 +
 +	if (ns->features & NVME_NS_EXT_LBAS) {
 +		length += meta_len;
 +		meta_len = 0;
 +	} else if (meta_len) {
 +		if ((io.metadata & 3) || !io.metadata)
 +			return -EINVAL;
 +	}
 +
 +	memset(&c, 0, sizeof(c));
 +	c.rw.opcode = io.opcode;
 +	c.rw.flags = io.flags;
 +	c.rw.nsid = cpu_to_le32(ns->head->ns_id);
 +	c.rw.slba = cpu_to_le64(io.slba);
 +	c.rw.length = cpu_to_le16(io.nblocks);
 +	c.rw.control = cpu_to_le16(io.control);
 +	c.rw.dsmgmt = cpu_to_le32(io.dsmgmt);
 +	c.rw.reftag = cpu_to_le32(io.reftag);
 +	c.rw.apptag = cpu_to_le16(io.apptag);
 +	c.rw.appmask = cpu_to_le16(io.appmask);
 +
 +	return nvme_submit_user_cmd(ns->queue, &c,
 +			nvme_to_user_ptr(io.addr), length,
 +			metadata, meta_len, lower_32_bits(io.slba), NULL, 0);
 +}
 +
 +static int nvme_user_cmd(struct nvme_ctrl *ctrl, struct nvme_ns *ns,
 +			struct nvme_passthru_cmd __user *ucmd)
 +{
 +	struct nvme_passthru_cmd cmd;
 +	struct nvme_command c;
 +	unsigned timeout = 0;
 +	u64 result;
 +	int status;
 +
 +	if (!capable(CAP_SYS_ADMIN))
 +		return -EACCES;
 +	if (copy_from_user(&cmd, ucmd, sizeof(cmd)))
 +		return -EFAULT;
 +	if (cmd.flags)
 +		return -EINVAL;
 +	if (ns && cmd.nsid != ns->head->ns_id) {
 +		dev_err(ctrl->device,
 +			"%s: nsid (%u) in cmd does not match nsid (%u) of namespace\n",
 +			current->comm, cmd.nsid, ns->head->ns_id);
 +		return -EINVAL;
 +	}
 +
 +	memset(&c, 0, sizeof(c));
 +	c.common.opcode = cmd.opcode;
 +	c.common.flags = cmd.flags;
 +	c.common.nsid = cpu_to_le32(cmd.nsid);
 +	c.common.cdw2[0] = cpu_to_le32(cmd.cdw2);
 +	c.common.cdw2[1] = cpu_to_le32(cmd.cdw3);
 +	c.common.cdw10 = cpu_to_le32(cmd.cdw10);
 +	c.common.cdw11 = cpu_to_le32(cmd.cdw11);
 +	c.common.cdw12 = cpu_to_le32(cmd.cdw12);
 +	c.common.cdw13 = cpu_to_le32(cmd.cdw13);
 +	c.common.cdw14 = cpu_to_le32(cmd.cdw14);
 +	c.common.cdw15 = cpu_to_le32(cmd.cdw15);
 +
 +	if (cmd.timeout_ms)
 +		timeout = msecs_to_jiffies(cmd.timeout_ms);
 +
 +	status = nvme_submit_user_cmd(ns ? ns->queue : ctrl->admin_q, &c,
 +			nvme_to_user_ptr(cmd.addr), cmd.data_len,
 +			nvme_to_user_ptr(cmd.metadata), cmd.metadata_len,
 +			0, &result, timeout);
 +
 +	if (status >= 0) {
 +		if (put_user(result, &ucmd->result))
 +			return -EFAULT;
 +	}
 +
 +	return status;
 +}
 +
 +static int nvme_user_cmd64(struct nvme_ctrl *ctrl, struct nvme_ns *ns,
 +			struct nvme_passthru_cmd64 __user *ucmd)
 +{
 +	struct nvme_passthru_cmd64 cmd;
 +	struct nvme_command c;
 +	unsigned timeout = 0;
 +	int status;
 +
 +	if (!capable(CAP_SYS_ADMIN))
 +		return -EACCES;
 +	if (copy_from_user(&cmd, ucmd, sizeof(cmd)))
 +		return -EFAULT;
 +	if (cmd.flags)
 +		return -EINVAL;
 +	if (ns && cmd.nsid != ns->head->ns_id) {
 +		dev_err(ctrl->device,
 +			"%s: nsid (%u) in cmd does not match nsid (%u) of namespace\n",
 +			current->comm, cmd.nsid, ns->head->ns_id);
 +		return -EINVAL;
 +	}
 +
 +	memset(&c, 0, sizeof(c));
 +	c.common.opcode = cmd.opcode;
 +	c.common.flags = cmd.flags;
 +	c.common.nsid = cpu_to_le32(cmd.nsid);
 +	c.common.cdw2[0] = cpu_to_le32(cmd.cdw2);
 +	c.common.cdw2[1] = cpu_to_le32(cmd.cdw3);
 +	c.common.cdw10 = cpu_to_le32(cmd.cdw10);
 +	c.common.cdw11 = cpu_to_le32(cmd.cdw11);
 +	c.common.cdw12 = cpu_to_le32(cmd.cdw12);
 +	c.common.cdw13 = cpu_to_le32(cmd.cdw13);
 +	c.common.cdw14 = cpu_to_le32(cmd.cdw14);
 +	c.common.cdw15 = cpu_to_le32(cmd.cdw15);
 +
 +	if (cmd.timeout_ms)
 +		timeout = msecs_to_jiffies(cmd.timeout_ms);
 +
 +	status = nvme_submit_user_cmd(ns ? ns->queue : ctrl->admin_q, &c,
 +			nvme_to_user_ptr(cmd.addr), cmd.data_len,
 +			nvme_to_user_ptr(cmd.metadata), cmd.metadata_len,
 +			0, &cmd.result, timeout);
 +
 +	if (status >= 0) {
 +		if (put_user(cmd.result, &ucmd->result))
 +			return -EFAULT;
 +	}
 +
 +	return status;
 +}
 +
 +/*
 + * Issue ioctl requests on the first available path.  Note that unlike normal
 + * block layer requests we will not retry failed request on another controller.
 + */
 +struct nvme_ns *nvme_get_ns_from_disk(struct gendisk *disk,
 +		struct nvme_ns_head **head, int *srcu_idx)
 +{
 +#ifdef CONFIG_NVME_MULTIPATH
 +	if (disk->fops == &nvme_ns_head_ops) {
 +		struct nvme_ns *ns;
 +
 +		*head = disk->private_data;
 +		*srcu_idx = srcu_read_lock(&(*head)->srcu);
 +		ns = nvme_find_path(*head);
 +		if (!ns)
 +			srcu_read_unlock(&(*head)->srcu, *srcu_idx);
 +		return ns;
 +	}
 +#endif
 +	*head = NULL;
 +	*srcu_idx = -1;
 +	return disk->private_data;
 +}
 +
 +void nvme_put_ns_from_disk(struct nvme_ns_head *head, int idx)
 +{
 +	if (head)
 +		srcu_read_unlock(&head->srcu, idx);
 +}
 +
 +static bool is_ctrl_ioctl(unsigned int cmd)
++=======
+ static int nvme_ns_open(struct nvme_ns *ns)
++>>>>>>> f1cf35e17ec3 (nvme: remove nvme_{get,put}_ns_from_disk)
 +{
 +	if (cmd == NVME_IOCTL_ADMIN_CMD || cmd == NVME_IOCTL_ADMIN64_CMD)
 +		return true;
 +	if (is_sed_ioctl(cmd))
 +		return true;
 +	return false;
 +}
 +
 +static int nvme_handle_ctrl_ioctl(struct nvme_ns *ns, unsigned int cmd,
 +				  void __user *argp,
 +				  struct nvme_ns_head *head,
 +				  int srcu_idx)
 +{
 +	struct nvme_ctrl *ctrl = ns->ctrl;
 +	int ret;
 +
 +	nvme_get_ctrl(ns->ctrl);
 +	nvme_put_ns_from_disk(head, srcu_idx);
 +
 +	switch (cmd) {
 +	case NVME_IOCTL_ADMIN_CMD:
 +		ret = nvme_user_cmd(ctrl, NULL, argp);
 +		break;
 +	case NVME_IOCTL_ADMIN64_CMD:
 +		ret = nvme_user_cmd64(ctrl, NULL, argp);
 +		break;
 +	default:
 +		ret = sed_ioctl(ctrl->opal_dev, cmd, argp);
 +		break;
 +	}
 +	nvme_put_ctrl(ctrl);
 +	return ret;
 +}
 +
 +static int nvme_ioctl(struct block_device *bdev, fmode_t mode,
 +		unsigned int cmd, unsigned long arg)
 +{
 +	struct nvme_ns_head *head = NULL;
 +	void __user *argp = (void __user *)arg;
 +	struct nvme_ns *ns;
 +	int srcu_idx, ret;
 +
 +	ns = nvme_get_ns_from_disk(bdev->bd_disk, &head, &srcu_idx);
 +	if (unlikely(!ns))
 +		return -EWOULDBLOCK;
 +
 +	/*
 +	 * Handle ioctls that apply to the controller instead of the namespace
 +	 * seperately and drop the ns SRCU reference early.  This avoids a
 +	 * deadlock when deleting namespaces using the passthrough interface.
 +	 */
 +	if (is_ctrl_ioctl(cmd))
 +		return nvme_handle_ctrl_ioctl(ns, cmd, argp, head, srcu_idx);
 +
 +	switch (cmd) {
 +	case NVME_IOCTL_ID:
 +		force_successful_syscall_return();
 +		ret = ns->head->ns_id;
 +		break;
 +	case NVME_IOCTL_IO_CMD:
 +		ret = nvme_user_cmd(ns->ctrl, ns, argp);
 +		break;
 +	case NVME_IOCTL_SUBMIT_IO:
 +		ret = nvme_submit_io(ns, argp);
 +		break;
 +	case NVME_IOCTL_IO64_CMD:
 +		ret = nvme_user_cmd64(ns->ctrl, ns, argp);
 +		break;
 +	default:
 +		if (ns->ndev)
 +			ret = nvme_nvm_ioctl(ns, cmd, argp);
 +		else
 +			ret = -ENOTTY;
 +	}
 +
 +	nvme_put_ns_from_disk(head, srcu_idx);
 +	return ret;
 +}
 +
 +#ifdef CONFIG_COMPAT
 +struct nvme_user_io32 {
 +	__u8	opcode;
 +	__u8	flags;
 +	__u16	control;
 +	__u16	nblocks;
 +	__u16	rsvd;
 +	__u64	metadata;
 +	__u64	addr;
 +	__u64	slba;
 +	__u32	dsmgmt;
 +	__u32	reftag;
 +	__u16	apptag;
 +	__u16	appmask;
 +} __attribute__((__packed__));
 +
 +#define NVME_IOCTL_SUBMIT_IO32	_IOW('N', 0x42, struct nvme_user_io32)
 +
 +static int nvme_compat_ioctl(struct block_device *bdev, fmode_t mode,
 +		unsigned int cmd, unsigned long arg)
 +{
 +	/*
 +	 * Corresponds to the difference of NVME_IOCTL_SUBMIT_IO
 +	 * between 32 bit programs and 64 bit kernel.
 +	 * The cause is that the results of sizeof(struct nvme_user_io),
 +	 * which is used to define NVME_IOCTL_SUBMIT_IO,
 +	 * are not same between 32 bit compiler and 64 bit compiler.
 +	 * NVME_IOCTL_SUBMIT_IO32 is for 64 bit kernel handling
 +	 * NVME_IOCTL_SUBMIT_IO issued from 32 bit programs.
 +	 * Other IOCTL numbers are same between 32 bit and 64 bit.
 +	 * So there is nothing to do regarding to other IOCTL numbers.
 +	 */
 +	if (cmd == NVME_IOCTL_SUBMIT_IO32)
 +		return nvme_ioctl(bdev, mode, NVME_IOCTL_SUBMIT_IO, arg);
 +
 +	return nvme_ioctl(bdev, mode, cmd, arg);
 +}
 +#else
 +#define nvme_compat_ioctl	NULL
 +#endif /* CONFIG_COMPAT */
 +
 +static int nvme_open(struct block_device *bdev, fmode_t mode)
  {
 +	struct nvme_ns *ns = bdev->bd_disk->private_data;
  
  	/* should never be called due to GENHD_FL_HIDDEN */
  	if (WARN_ON_ONCE(nvme_ns_head_multipath(ns->head)))
diff --cc drivers/nvme/host/nvme.h
index 7d87bfacb56d,1f397ecba16c..000000000000
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@@ -641,18 -668,33 +641,37 @@@ int nvme_get_features(struct nvme_ctrl 
  int nvme_set_queue_count(struct nvme_ctrl *ctrl, int *count);
  void nvme_stop_keep_alive(struct nvme_ctrl *ctrl);
  int nvme_reset_ctrl(struct nvme_ctrl *ctrl);
 -int nvme_reset_ctrl_sync(struct nvme_ctrl *ctrl);
  int nvme_try_sched_reset(struct nvme_ctrl *ctrl);
  int nvme_delete_ctrl(struct nvme_ctrl *ctrl);
 -void nvme_queue_scan(struct nvme_ctrl *ctrl);
 +
  int nvme_get_log(struct nvme_ctrl *ctrl, u32 nsid, u8 log_page, u8 lsp, u8 csi,
  		void *log, size_t size, u64 offset);
++<<<<<<< HEAD
 +struct nvme_ns *nvme_get_ns_from_disk(struct gendisk *disk,
 +		struct nvme_ns_head **head, int *srcu_idx);
 +void nvme_put_ns_from_disk(struct nvme_ns_head *head, int idx);
++=======
+ bool nvme_tryget_ns_head(struct nvme_ns_head *head);
+ void nvme_put_ns_head(struct nvme_ns_head *head);
+ int nvme_cdev_add(struct cdev *cdev, struct device *cdev_device,
+ 		const struct file_operations *fops, struct module *owner);
+ void nvme_cdev_del(struct cdev *cdev, struct device *cdev_device);
+ int nvme_ioctl(struct block_device *bdev, fmode_t mode,
+ 		unsigned int cmd, unsigned long arg);
+ long nvme_ns_chr_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+ int nvme_ns_head_ioctl(struct block_device *bdev, fmode_t mode,
+ 		unsigned int cmd, unsigned long arg);
+ long nvme_ns_head_chr_ioctl(struct file *file, unsigned int cmd,
+ 		unsigned long arg);
+ long nvme_dev_ioctl(struct file *file, unsigned int cmd,
+ 		unsigned long arg);
+ int nvme_getgeo(struct block_device *bdev, struct hd_geometry *geo);
++>>>>>>> f1cf35e17ec3 (nvme: remove nvme_{get,put}_ns_from_disk)
  
  extern const struct attribute_group *nvme_ns_id_attr_groups[];
 -extern const struct pr_ops nvme_pr_ops;
  extern const struct block_device_operations nvme_ns_head_ops;
  
+ struct nvme_ns *nvme_find_path(struct nvme_ns_head *head);
  #ifdef CONFIG_NVME_MULTIPATH
  static inline bool nvme_ctrl_use_ana(struct nvme_ctrl *ctrl)
  {
* Unmerged path drivers/nvme/host/core.c
* Unmerged path drivers/nvme/host/nvme.h
