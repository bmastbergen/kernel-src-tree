net: bridge: vlan: account for router port lists when notifying

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 05d6f38ec0a5108596941f8b25d92c45aa08fc40
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/05d6f38e.failed

When sending a global vlan notification we should account for the number
of router ports when allocating the skb, otherwise we might end up
losing notifications.

Fixes: dc002875c22b ("net: bridge: vlan: use br_rports_fill_info() to export mcast router ports")
	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 05d6f38ec0a5108596941f8b25d92c45aa08fc40)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_mdb.c
#	net/bridge/br_private.h
#	net/bridge/br_vlan_options.c
diff --cc net/bridge/br_mdb.c
index 5621f5510fd4,0281453f7766..000000000000
--- a/net/bridge/br_mdb.c
+++ b/net/bridge/br_mdb.c
@@@ -16,14 -16,67 +16,71 @@@
  
  #include "br_private.h"
  
 -static bool
 -br_ip4_rports_get_timer(struct net_bridge_mcast_port *pmctx,
 -			unsigned long *timer)
 +static int br_rports_fill_info(struct sk_buff *skb, struct netlink_callback *cb,
 +			       struct net_device *dev)
  {
++<<<<<<< HEAD
 +	struct net_bridge *br = netdev_priv(dev);
++=======
+ 	*timer = br_timer_value(&pmctx->ip4_mc_router_timer);
+ 	return !hlist_unhashed(&pmctx->ip4_rlist);
+ }
+ 
+ static bool
+ br_ip6_rports_get_timer(struct net_bridge_mcast_port *pmctx,
+ 			unsigned long *timer)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	*timer = br_timer_value(&pmctx->ip6_mc_router_timer);
+ 	return !hlist_unhashed(&pmctx->ip6_rlist);
+ #else
+ 	*timer = 0;
+ 	return false;
+ #endif
+ }
+ 
+ static size_t __br_rports_one_size(void)
+ {
+ 	return nla_total_size(sizeof(u32)) + /* MDBA_ROUTER_PORT */
+ 	       nla_total_size(sizeof(u32)) + /* MDBA_ROUTER_PATTR_TIMER */
+ 	       nla_total_size(sizeof(u8)) +  /* MDBA_ROUTER_PATTR_TYPE */
+ 	       nla_total_size(sizeof(u32)) + /* MDBA_ROUTER_PATTR_INET_TIMER */
+ 	       nla_total_size(sizeof(u32)) + /* MDBA_ROUTER_PATTR_INET6_TIMER */
+ 	       nla_total_size(sizeof(u32));  /* MDBA_ROUTER_PATTR_VID */
+ }
+ 
+ size_t br_rports_size(const struct net_bridge_mcast *brmctx)
+ {
+ 	struct net_bridge_mcast_port *pmctx;
+ 	size_t size = nla_total_size(0); /* MDBA_ROUTER */
+ 
+ 	rcu_read_lock();
+ 	hlist_for_each_entry_rcu(pmctx, &brmctx->ip4_mc_router_list,
+ 				 ip4_rlist)
+ 		size += __br_rports_one_size();
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	hlist_for_each_entry_rcu(pmctx, &brmctx->ip6_mc_router_list,
+ 				 ip6_rlist)
+ 		size += __br_rports_one_size();
+ #endif
+ 	rcu_read_unlock();
+ 
+ 	return size;
+ }
+ 
+ int br_rports_fill_info(struct sk_buff *skb,
+ 			const struct net_bridge_mcast *brmctx)
+ {
+ 	u16 vid = brmctx->vlan ? brmctx->vlan->vid : 0;
+ 	bool have_ip4_mc_rtr, have_ip6_mc_rtr;
+ 	unsigned long ip4_timer, ip6_timer;
+ 	struct nlattr *nest, *port_nest;
++>>>>>>> 05d6f38ec0a5 (net: bridge: vlan: account for router port lists when notifying)
  	struct net_bridge_port *p;
 +	struct nlattr *nest, *port_nest;
  
 -	if (!brmctx->multicast_router || !br_rports_have_mc_router(brmctx))
 +	if (!br->multicast_router || hlist_empty(&br->router_list))
  		return 0;
  
  	nest = nla_nest_start_noflag(skb, MDBA_ROUTER);
diff --cc net/bridge/br_private.h
index 30e07225bc94,df0fa246c80c..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -767,8 -918,46 +767,48 @@@ void br_multicast_get_stats(const struc
  			    struct br_mcast_stats *dest);
  void br_mdb_init(void);
  void br_mdb_uninit(void);
 -void br_multicast_host_join(const struct net_bridge_mcast *brmctx,
 -			    struct net_bridge_mdb_entry *mp, bool notify);
 +void br_multicast_host_join(struct net_bridge_mdb_entry *mp, bool notify);
  void br_multicast_host_leave(struct net_bridge_mdb_entry *mp, bool notify);
++<<<<<<< HEAD
++=======
+ void br_multicast_star_g_handle_mode(struct net_bridge_port_group *pg,
+ 				     u8 filter_mode);
+ void br_multicast_sg_add_exclude_ports(struct net_bridge_mdb_entry *star_mp,
+ 				       struct net_bridge_port_group *sg);
+ struct net_bridge_group_src *
+ br_multicast_find_group_src(struct net_bridge_port_group *pg, struct br_ip *ip);
+ void br_multicast_del_group_src(struct net_bridge_group_src *src,
+ 				bool fastleave);
+ void br_multicast_ctx_init(struct net_bridge *br,
+ 			   struct net_bridge_vlan *vlan,
+ 			   struct net_bridge_mcast *brmctx);
+ void br_multicast_ctx_deinit(struct net_bridge_mcast *brmctx);
+ void br_multicast_port_ctx_init(struct net_bridge_port *port,
+ 				struct net_bridge_vlan *vlan,
+ 				struct net_bridge_mcast_port *pmctx);
+ void br_multicast_port_ctx_deinit(struct net_bridge_mcast_port *pmctx);
+ void br_multicast_toggle_one_vlan(struct net_bridge_vlan *vlan, bool on);
+ void br_multicast_toggle_vlan(struct net_bridge_vlan *vlan, bool on);
+ int br_multicast_toggle_vlan_snooping(struct net_bridge *br, bool on,
+ 				      struct netlink_ext_ack *extack);
+ bool br_multicast_toggle_global_vlan(struct net_bridge_vlan *vlan, bool on);
+ 
+ int br_mdb_replay(struct net_device *br_dev, struct net_device *dev,
+ 		  const void *ctx, bool adding, struct notifier_block *nb,
+ 		  struct netlink_ext_ack *extack);
+ int br_rports_fill_info(struct sk_buff *skb,
+ 			const struct net_bridge_mcast *brmctx);
+ int br_multicast_dump_querier_state(struct sk_buff *skb,
+ 				    const struct net_bridge_mcast *brmctx,
+ 				    int nest_attr);
+ size_t br_multicast_querier_state_size(void);
+ size_t br_rports_size(const struct net_bridge_mcast *brmctx);
+ 
+ static inline bool br_group_is_l2(const struct br_ip *group)
+ {
+ 	return group->proto == 0;
+ }
++>>>>>>> 05d6f38ec0a5 (net: bridge: vlan: account for router port lists when notifying)
  
  #define mlock_dereference(X, br) \
  	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
diff --cc net/bridge/br_vlan_options.c
index 827bfc319599,a3b8a086284b..000000000000
--- a/net/bridge/br_vlan_options.c
+++ b/net/bridge/br_vlan_options.c
@@@ -295,6 -367,24 +295,27 @@@ static size_t rtnl_vlan_global_opts_nlm
  	return NLMSG_ALIGN(sizeof(struct br_vlan_msg))
  		+ nla_total_size(0) /* BRIDGE_VLANDB_GLOBAL_OPTIONS */
  		+ nla_total_size(sizeof(u16)) /* BRIDGE_VLANDB_GOPTS_ID */
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION */
+ 		+ nla_total_size(sizeof(u32)) /* BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT */
+ 		+ nla_total_size(sizeof(u32)) /* BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL */
+ 		+ nla_total_size(sizeof(u64)) /* BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_QUERIER */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_ROUTER */
+ 		+ br_multicast_querier_state_size() /* BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_STATE */
+ 		+ nla_total_size(0) /* BRIDGE_VLANDB_GOPTS_MCAST_ROUTER_PORTS */
+ 		+ br_rports_size(&v->br_mcast_ctx) /* BRIDGE_VLANDB_GOPTS_MCAST_ROUTER_PORTS */
+ #endif
++>>>>>>> 05d6f38ec0a5 (net: bridge: vlan: account for router port lists when notifying)
  		+ nla_total_size(sizeof(u16)); /* BRIDGE_VLANDB_GOPTS_RANGE */
  }
  
* Unmerged path net/bridge/br_mdb.c
* Unmerged path net/bridge/br_private.h
* Unmerged path net/bridge/br_vlan_options.c
