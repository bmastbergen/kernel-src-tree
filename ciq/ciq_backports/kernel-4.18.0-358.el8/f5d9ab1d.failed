ACPI: scan: Drop sta argument from acpi_init_device_object()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit f5d9ab1d803456f5215f853e9286659933b59afe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/f5d9ab1d.failed

Use the observation that the initial status check for
ACPI_BUS_TYPE_PROCESSOR objects can be carried out in the same way
as for ACPI_BUS_TYPE_DEVICE objects and it is not necessary to fail
acpi_add_single_object() if acpi_bus_get_status_handle() returns an
error for a processor (its status can be set to 0 instead) to
simplify acpi_add_single_object().

Accordingly, drop the "sta" argument from acpi_init_device_object()
as it can always set the initial status to ACPI_STA_DEFAULT and let
its caller correct that later on.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Hans de Goede <hdegoede@redhat.com>
(cherry picked from commit f5d9ab1d803456f5215f853e9286659933b59afe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
diff --cc drivers/acpi/scan.c
index fc29b67fcda9,902cecb218d3..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -1690,16 -1679,20 +1689,27 @@@ void acpi_device_add_finalize(struct ac
  	kobject_uevent(&device->dev.kobj, KOBJ_ADD);
  }
  
+ static void acpi_scan_init_status(struct acpi_device *adev)
+ {
+ 	if (acpi_bus_get_status(adev))
+ 		acpi_set_device_status(adev, 0);
+ }
+ 
  static int acpi_add_single_object(struct acpi_device **child,
 -				  acpi_handle handle, int type)
 +				  acpi_handle handle, int type,
 +				  unsigned long long sta)
  {
++<<<<<<< HEAD
++=======
+ 	struct acpi_device_info *info = NULL;
+ 	struct acpi_device *device;
++>>>>>>> f5d9ab1d8034 (ACPI: scan: Drop sta argument from acpi_init_device_object())
  	int result;
 +	struct acpi_device *device;
 +	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 +	struct acpi_device_info *info = NULL;
  
 -	if (type == ACPI_BUS_TYPE_DEVICE && handle != ACPI_ROOT_OBJECT)
 +	if (handle != ACPI_ROOT_OBJECT && type == ACPI_BUS_TYPE_DEVICE)
  		acpi_get_object_info(handle, &info);
  
  	device = kzalloc(sizeof(struct acpi_device), GFP_KERNEL);
diff --git a/drivers/acpi/internal.h b/drivers/acpi/internal.h
index 4ab8878c4f8c..aac45857d9e0 100644
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@ -114,8 +114,7 @@ struct acpi_device_bus_id {
 int acpi_device_add(struct acpi_device *device,
 		    void (*release)(struct device *));
 void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
-			     int type, unsigned long long sta,
-			     struct acpi_device_info *info);
+			     int type, struct acpi_device_info *info);
 int acpi_device_setup_files(struct acpi_device *dev);
 void acpi_device_remove_files(struct acpi_device *dev);
 void acpi_device_add_finalize(struct acpi_device *device);
diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 44808cce19a2..3d4ee061fb83 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -952,8 +952,7 @@ int acpi_add_power_resource(acpi_handle handle)
 		return -ENOMEM;
 
 	device = &resource->device;
-	acpi_init_device_object(device, handle, ACPI_BUS_TYPE_POWER,
-				ACPI_STA_DEFAULT, NULL);
+	acpi_init_device_object(device, handle, ACPI_BUS_TYPE_POWER, NULL);
 	mutex_init(&resource->resource_lock);
 	INIT_LIST_HEAD(&resource->list_node);
 	INIT_LIST_HEAD(&resource->dependents);
* Unmerged path drivers/acpi/scan.c
