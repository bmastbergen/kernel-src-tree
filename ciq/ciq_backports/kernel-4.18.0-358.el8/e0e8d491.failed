sched/isolation: Prefer housekeeping CPU in local node

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Wanpeng Li <wanpengli@tencent.com>
commit e0e8d4911ed2695b12c3a01c15634000ede9bc73
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/e0e8d491.failed

In real product setup, there will be houseeking CPUs in each nodes, it
is prefer to do housekeeping from local node, fallback to global online
cpumask if failed to find houseeking CPU from local node.

	Signed-off-by: Wanpeng Li <wanpengli@tencent.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Frederic Weisbecker <frederic@kernel.org>
	Reviewed-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: https://lkml.kernel.org/r/1561711901-4755-2-git-send-email-wanpengli@tencent.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit e0e8d4911ed2695b12c3a01c15634000ede9bc73)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/isolation.c
diff --cc kernel/sched/isolation.c
index e02a43386575,9fcb2a695a41..000000000000
--- a/kernel/sched/isolation.c
+++ b/kernel/sched/isolation.c
@@@ -21,9 -22,17 +21,22 @@@ EXPORT_SYMBOL_GPL(housekeeping_enabled)
  
  int housekeeping_any_cpu(enum hk_flags flags)
  {
++<<<<<<< HEAD
 +	if (static_branch_unlikely(&housekeeping_overriden))
 +		if (housekeeping_flags & flags)
++=======
+ 	int cpu;
+ 
+ 	if (static_branch_unlikely(&housekeeping_overridden)) {
+ 		if (housekeeping_flags & flags) {
+ 			cpu = sched_numa_find_closest(housekeeping_mask, smp_processor_id());
+ 			if (cpu < nr_cpu_ids)
+ 				return cpu;
+ 
++>>>>>>> e0e8d4911ed2 (sched/isolation: Prefer housekeeping CPU in local node)
  			return cpumask_any_and(housekeeping_mask, cpu_online_mask);
+ 		}
+ 	}
  	return smp_processor_id();
  }
  EXPORT_SYMBOL_GPL(housekeeping_any_cpu);
* Unmerged path kernel/sched/isolation.c
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index 73dbfecd533e..f732d47c7986 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -1313,16 +1313,18 @@ enum numa_topology_type {
 extern enum numa_topology_type sched_numa_topology_type;
 extern int sched_max_numa_distance;
 extern bool find_numa_distance(int distance);
-#endif
-
-#ifdef CONFIG_NUMA
 extern void sched_init_numa(void);
 extern void sched_domains_numa_masks_set(unsigned int cpu);
 extern void sched_domains_numa_masks_clear(unsigned int cpu);
+extern int sched_numa_find_closest(const struct cpumask *cpus, int cpu);
 #else
 static inline void sched_init_numa(void) { }
 static inline void sched_domains_numa_masks_set(unsigned int cpu) { }
 static inline void sched_domains_numa_masks_clear(unsigned int cpu) { }
+static inline int sched_numa_find_closest(const struct cpumask *cpus, int cpu)
+{
+	return nr_cpu_ids;
+}
 #endif
 
 #ifdef CONFIG_NUMA_BALANCING
diff --git a/kernel/sched/topology.c b/kernel/sched/topology.c
index 93be4d899820..36111f445a60 100644
--- a/kernel/sched/topology.c
+++ b/kernel/sched/topology.c
@@ -1738,6 +1738,26 @@ void sched_domains_numa_masks_clear(unsigned int cpu)
 	}
 }
 
+/*
+ * sched_numa_find_closest() - given the NUMA topology, find the cpu
+ *                             closest to @cpu from @cpumask.
+ * cpumask: cpumask to find a cpu from
+ * cpu: cpu to be close to
+ *
+ * returns: cpu, or nr_cpu_ids when nothing found.
+ */
+int sched_numa_find_closest(const struct cpumask *cpus, int cpu)
+{
+	int i, j = cpu_to_node(cpu);
+
+	for (i = 0; i < sched_domains_numa_levels; i++) {
+		cpu = cpumask_any_and(cpus, sched_domains_numa_masks[i][j]);
+		if (cpu < nr_cpu_ids)
+			return cpu;
+	}
+	return nr_cpu_ids;
+}
+
 #endif /* CONFIG_NUMA */
 
 static int __sdt_alloc(const struct cpumask *cpu_map)
