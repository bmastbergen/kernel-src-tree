Revert "driver core: Avoid deferred probe due to fw_devlink_pause/resume()"

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Saravana Kannan <saravanak@google.com>
commit c95d64012ad7de2747923b0caf80e195e940606c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/c95d6401.failed

This reverts commit 2451e746478a6a6e981cfa66b62b791ca93b90c8.

fw_devlink_pause/resume() was an incomplete attempt at boot time
optimization. That's going to get replaced by a much better optimization
at the end of the series. Since fw_devlink_pause/resume() is going away,
changes made for that can also go away.

	Signed-off-by: Saravana Kannan <saravanak@google.com>
Link: https://lore.kernel.org/r/20201121020232.908850-2-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit c95d64012ad7de2747923b0caf80e195e940606c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
#	include/linux/device.h
diff --cc drivers/base/core.c
index c73bf3cdd933,58c7d17820a7..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -1459,12 -1467,6 +1458,15 @@@ static void fw_devlink_link_device(stru
  			fw_ret = -EAGAIN;
  	} else {
  		fw_ret = -ENODEV;
++<<<<<<< HEAD
 +		/*
 +		 * defer_hook is not used to add device to deferred_sync list
 +		 * until device is bound. Since deferred fw devlink also blocks
 +		 * probing, same list hook can be used for deferred_fw_devlink.
 +		 */
 +		list_add_tail(&dev->links_defer_hook, &deferred_fw_devlink);
++=======
++>>>>>>> c95d64012ad7 (Revert "driver core: Avoid deferred probe due to fw_devlink_pause/resume()")
  	}
  
  	if (fw_ret == -ENODEV)
@@@ -1547,19 -1546,8 +1546,21 @@@ void fw_devlink_resume(void
  		goto out;
  
  	device_link_add_missing_supplier_links();
- 	list_splice_tail_init(&deferred_fw_devlink, &probe_list);
  out:
  	mutex_unlock(&defer_fw_devlink_lock);
++<<<<<<< HEAD
 +
 +	/*
 +	 * bus_probe_device() can cause new devices to get added and they'll
 +	 * try to grab defer_fw_devlink_lock. So, this needs to be done outside
 +	 * the defer_fw_devlink_lock.
 +	 */
 +	list_for_each_entry_safe(dev, tmp, &probe_list, links_defer_hook) {
 +		list_del_init(&dev->links_defer_hook);
 +		bus_probe_device(dev);
 +	}
++=======
++>>>>>>> c95d64012ad7 (Revert "driver core: Avoid deferred probe due to fw_devlink_pause/resume()")
  }
  /* Device links support end. */
  
diff --cc include/linux/device.h
index d191907ceea8,da00f8e449bb..000000000000
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@@ -1079,8 -352,9 +1079,14 @@@ enum dl_dev_state 
   * @suppliers: List of links to supplier devices.
   * @consumers: List of links to consumer devices.
   * @needs_suppliers: Hook to global list of devices waiting for suppliers.
++<<<<<<< HEAD
 + * @defer_hook: Hook to global list of devices that have deferred sync_state or
 + *             deferred fw_devlink.
++=======
+  * @defer_hook: Hook to global list of devices that have deferred sync_state.
+  * @need_for_probe: If needs_suppliers is on a list, this indicates if the
+  *		    suppliers are needed for probe or not.
++>>>>>>> c95d64012ad7 (Revert "driver core: Avoid deferred probe due to fw_devlink_pause/resume()")
   * @status: Driver status information.
   */
  struct dev_links_info {
* Unmerged path drivers/base/core.c
* Unmerged path include/linux/device.h
