KVM: x86: Zero the IOAPIC scan request dest vCPUs bitmap

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Nitesh Narayan Lal <nitesh@redhat.com>
commit 9a2ae9f6b6bbd3ef05d5e5977ace854e9b8f04b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/9a2ae9f6.failed

Not zeroing the bitmap used for identifying the destination vCPUs for an
IOAPIC scan request in fixed delivery mode could lead to waking up unwanted
vCPUs. This patch zeroes the vCPU bitmap before passing it to
kvm_bitmap_or_dest_vcpus(), which is responsible for setting the bitmap
with the bits corresponding to the destination vCPUs.

Fixes: 7ee30bc132c6("KVM: x86: deliver KVM IOAPIC scan request to target vCPUs")
	Signed-off-by: Nitesh Narayan Lal <nitesh@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 9a2ae9f6b6bbd3ef05d5e5977ace854e9b8f04b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/ioapic.c
diff --cc arch/x86/kvm/ioapic.c
index 48c3d0dcf67b,9fd2dd89a1c5..000000000000
--- a/arch/x86/kvm/ioapic.c
+++ b/arch/x86/kvm/ioapic.c
@@@ -329,7 -324,34 +329,38 @@@ static void ioapic_write_indirect(struc
  		if (e->fields.trig_mode == IOAPIC_LEVEL_TRIG
  		    && ioapic->irr & (1 << index))
  			ioapic_service(ioapic, index, false);
++<<<<<<< HEAD
 +		kvm_vcpu_request_scan_ioapic(ioapic->kvm);
++=======
+ 		if (e->fields.delivery_mode == APIC_DM_FIXED) {
+ 			struct kvm_lapic_irq irq;
+ 
+ 			irq.shorthand = 0;
+ 			irq.vector = e->fields.vector;
+ 			irq.delivery_mode = e->fields.delivery_mode << 8;
+ 			irq.dest_id = e->fields.dest_id;
+ 			irq.dest_mode = e->fields.dest_mode;
+ 			bitmap_zero(&vcpu_bitmap, 16);
+ 			kvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,
+ 						 &vcpu_bitmap);
+ 			if (old_dest_mode != e->fields.dest_mode ||
+ 			    old_dest_id != e->fields.dest_id) {
+ 				/*
+ 				 * Update vcpu_bitmap with vcpus specified in
+ 				 * the previous request as well. This is done to
+ 				 * keep ioapic_handled_vectors synchronized.
+ 				 */
+ 				irq.dest_id = old_dest_id;
+ 				irq.dest_mode = old_dest_mode;
+ 				kvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,
+ 							 &vcpu_bitmap);
+ 			}
+ 			kvm_make_scan_ioapic_request_mask(ioapic->kvm,
+ 							  &vcpu_bitmap);
+ 		} else {
+ 			kvm_make_scan_ioapic_request(ioapic->kvm);
+ 		}
++>>>>>>> 9a2ae9f6b6bb (KVM: x86: Zero the IOAPIC scan request dest vCPUs bitmap)
  		break;
  	}
  }
* Unmerged path arch/x86/kvm/ioapic.c
