ext4: fix buffer leak in ext4_xattr_move_to_block() on error path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Vasily Averin <vvs@virtuozzo.com>
commit 6bdc9977fcdedf47118d2caf7270a19f4b6d8a8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/6bdc9977.failed

Fixes: 3f2571c1f91f ("ext4: factor out xattr moving")
Fixes: 6dd4ee7cab7e ("ext4: Expand extra_inodes space per ...")
	Reviewed-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: stable@kernel.org # 2.6.23
(cherry picked from commit 6bdc9977fcdedf47118d2caf7270a19f4b6d8a8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/xattr.c
diff --cc fs/ext4/xattr.c
index 33713ac4f705,5c9bc0d85cc0..000000000000
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@@ -1260,6 -2541,156 +1260,159 @@@ static void ext4_xattr_shift_entries(st
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Move xattr pointed to by 'entry' from inode into external xattr block
+  */
+ static int ext4_xattr_move_to_block(handle_t *handle, struct inode *inode,
+ 				    struct ext4_inode *raw_inode,
+ 				    struct ext4_xattr_entry *entry)
+ {
+ 	struct ext4_xattr_ibody_find *is = NULL;
+ 	struct ext4_xattr_block_find *bs = NULL;
+ 	char *buffer = NULL, *b_entry_name = NULL;
+ 	size_t value_size = le32_to_cpu(entry->e_value_size);
+ 	struct ext4_xattr_info i = {
+ 		.value = NULL,
+ 		.value_len = 0,
+ 		.name_index = entry->e_name_index,
+ 		.in_inode = !!entry->e_value_inum,
+ 	};
+ 	struct ext4_xattr_ibody_header *header = IHDR(inode, raw_inode);
+ 	int error;
+ 
+ 	is = kzalloc(sizeof(struct ext4_xattr_ibody_find), GFP_NOFS);
+ 	bs = kzalloc(sizeof(struct ext4_xattr_block_find), GFP_NOFS);
+ 	buffer = kmalloc(value_size, GFP_NOFS);
+ 	b_entry_name = kmalloc(entry->e_name_len + 1, GFP_NOFS);
+ 	if (!is || !bs || !buffer || !b_entry_name) {
+ 		error = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	is->s.not_found = -ENODATA;
+ 	bs->s.not_found = -ENODATA;
+ 	is->iloc.bh = NULL;
+ 	bs->bh = NULL;
+ 
+ 	/* Save the entry name and the entry value */
+ 	if (entry->e_value_inum) {
+ 		error = ext4_xattr_inode_get(inode, entry, buffer, value_size);
+ 		if (error)
+ 			goto out;
+ 	} else {
+ 		size_t value_offs = le16_to_cpu(entry->e_value_offs);
+ 		memcpy(buffer, (void *)IFIRST(header) + value_offs, value_size);
+ 	}
+ 
+ 	memcpy(b_entry_name, entry->e_name, entry->e_name_len);
+ 	b_entry_name[entry->e_name_len] = '\0';
+ 	i.name = b_entry_name;
+ 
+ 	error = ext4_get_inode_loc(inode, &is->iloc);
+ 	if (error)
+ 		goto out;
+ 
+ 	error = ext4_xattr_ibody_find(inode, &i, is);
+ 	if (error)
+ 		goto out;
+ 
+ 	/* Remove the chosen entry from the inode */
+ 	error = ext4_xattr_ibody_set(handle, inode, &i, is);
+ 	if (error)
+ 		goto out;
+ 
+ 	i.value = buffer;
+ 	i.value_len = value_size;
+ 	error = ext4_xattr_block_find(inode, &i, bs);
+ 	if (error)
+ 		goto out;
+ 
+ 	/* Add entry which was removed from the inode into the block */
+ 	error = ext4_xattr_block_set(handle, inode, &i, bs);
+ 	if (error)
+ 		goto out;
+ 	error = 0;
+ out:
+ 	kfree(b_entry_name);
+ 	kfree(buffer);
+ 	if (is)
+ 		brelse(is->iloc.bh);
+ 	if (bs)
+ 		brelse(bs->bh);
+ 	kfree(is);
+ 	kfree(bs);
+ 
+ 	return error;
+ }
+ 
+ static int ext4_xattr_make_inode_space(handle_t *handle, struct inode *inode,
+ 				       struct ext4_inode *raw_inode,
+ 				       int isize_diff, size_t ifree,
+ 				       size_t bfree, int *total_ino)
+ {
+ 	struct ext4_xattr_ibody_header *header = IHDR(inode, raw_inode);
+ 	struct ext4_xattr_entry *small_entry;
+ 	struct ext4_xattr_entry *entry;
+ 	struct ext4_xattr_entry *last;
+ 	unsigned int entry_size;	/* EA entry size */
+ 	unsigned int total_size;	/* EA entry size + value size */
+ 	unsigned int min_total_size;
+ 	int error;
+ 
+ 	while (isize_diff > ifree) {
+ 		entry = NULL;
+ 		small_entry = NULL;
+ 		min_total_size = ~0U;
+ 		last = IFIRST(header);
+ 		/* Find the entry best suited to be pushed into EA block */
+ 		for (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {
+ 			/* never move system.data out of the inode */
+ 			if ((last->e_name_len == 4) &&
+ 			    (last->e_name_index == EXT4_XATTR_INDEX_SYSTEM) &&
+ 			    !memcmp(last->e_name, "data", 4))
+ 				continue;
+ 			total_size = EXT4_XATTR_LEN(last->e_name_len);
+ 			if (!last->e_value_inum)
+ 				total_size += EXT4_XATTR_SIZE(
+ 					       le32_to_cpu(last->e_value_size));
+ 			if (total_size <= bfree &&
+ 			    total_size < min_total_size) {
+ 				if (total_size + ifree < isize_diff) {
+ 					small_entry = last;
+ 				} else {
+ 					entry = last;
+ 					min_total_size = total_size;
+ 				}
+ 			}
+ 		}
+ 
+ 		if (entry == NULL) {
+ 			if (small_entry == NULL)
+ 				return -ENOSPC;
+ 			entry = small_entry;
+ 		}
+ 
+ 		entry_size = EXT4_XATTR_LEN(entry->e_name_len);
+ 		total_size = entry_size;
+ 		if (!entry->e_value_inum)
+ 			total_size += EXT4_XATTR_SIZE(
+ 					      le32_to_cpu(entry->e_value_size));
+ 		error = ext4_xattr_move_to_block(handle, inode, raw_inode,
+ 						 entry);
+ 		if (error)
+ 			return error;
+ 
+ 		*total_ino -= entry_size;
+ 		ifree += total_size;
+ 		bfree -= total_size;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
++>>>>>>> 6bdc9977fcde (ext4: fix buffer leak in ext4_xattr_move_to_block() on error path)
   * Expand an inode by new_extra_isize bytes when EAs are present.
   * Returns 0 on success or negative error number on failure.
   */
* Unmerged path fs/ext4/xattr.c
