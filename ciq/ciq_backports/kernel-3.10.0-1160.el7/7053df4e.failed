KVM: introduce kvm_make_vcpus_request_mask() API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 7053df4edb3ae3ae15c316fe49122c0b3936e9dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/7053df4e.failed

Hyper-V style PV TLB flush hypercalls inmplementation will use this API.
To avoid memory allocation in CONFIG_CPUMASK_OFFSTACK case add
cpumask_var_t argument.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit 7053df4edb3ae3ae15c316fe49122c0b3936e9dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kvm_host.h
#	virt/kvm/kvm_main.c
diff --cc include/linux/kvm_host.h
index ea0c4ef8a854,14e710d639c7..000000000000
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@@ -703,8 -730,9 +703,14 @@@ void kvm_put_guest_fpu(struct kvm_vcpu 
  
  void kvm_flush_remote_tlbs(struct kvm *kvm);
  void kvm_reload_remote_mmus(struct kvm *kvm);
++<<<<<<< HEAD
 +void kvm_make_mclock_inprogress_request(struct kvm *kvm);
 +void kvm_make_scan_ioapic_request(struct kvm *kvm);
++=======
+ 
+ bool kvm_make_vcpus_request_mask(struct kvm *kvm, unsigned int req,
+ 				 unsigned long *vcpu_bitmap, cpumask_var_t tmp);
++>>>>>>> 7053df4edb3a (KVM: introduce kvm_make_vcpus_request_mask() API)
  bool kvm_make_all_cpus_request(struct kvm *kvm, unsigned int req);
  
  long kvm_arch_dev_ioctl(struct file *filp,
diff --cc virt/kvm/kvm_main.c
index bbbc7b9a8d29,b125d94307d2..000000000000
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@@ -174,34 -191,59 +174,80 @@@ static void ack_flush(void *_completed
  {
  }
  
++<<<<<<< HEAD
 +bool kvm_make_all_cpus_request(struct kvm *kvm, unsigned int req)
 +{
 +	int i, cpu, me;
 +	cpumask_var_t cpus;
 +	bool called = true;
- 	struct kvm_vcpu *vcpu;
++=======
+ static inline bool kvm_kick_many_cpus(const struct cpumask *cpus, bool wait)
+ {
+ 	if (unlikely(!cpus))
+ 		cpus = cpu_online_mask;
  
- 	zalloc_cpumask_var(&cpus, GFP_ATOMIC);
+ 	if (cpumask_empty(cpus))
+ 		return false;
+ 
+ 	smp_call_function_many(cpus, ack_flush, NULL, wait);
+ 	return true;
+ }
+ 
+ bool kvm_make_vcpus_request_mask(struct kvm *kvm, unsigned int req,
+ 				 unsigned long *vcpu_bitmap, cpumask_var_t tmp)
+ {
+ 	int i, cpu, me;
++>>>>>>> 7053df4edb3a (KVM: introduce kvm_make_vcpus_request_mask() API)
+ 	struct kvm_vcpu *vcpu;
+ 	bool called;
  
  	me = get_cpu();
+ 
  	kvm_for_each_vcpu(i, vcpu, kvm) {
+ 		if (!test_bit(i, vcpu_bitmap))
+ 			continue;
+ 
  		kvm_make_request(req, vcpu);
  		cpu = vcpu->cpu;
  
 -		if (!(req & KVM_REQUEST_NO_WAKEUP) && kvm_vcpu_wake_up(vcpu))
 -			continue;
 +		/* Set ->requests bit before we read ->mode */
 +		smp_mb();
  
++<<<<<<< HEAD
 +		if (cpus != NULL && cpu != -1 && cpu != me &&
 +		      kvm_vcpu_exiting_guest_mode(vcpu) != OUTSIDE_GUEST_MODE)
 +			cpumask_set_cpu(cpu, cpus);
 +	}
 +	if (unlikely(cpus == NULL))
 +		smp_call_function_many(cpu_online_mask, ack_flush, NULL, 1);
 +	else if (!cpumask_empty(cpus))
 +		smp_call_function_many(cpus, ack_flush, NULL, 1);
 +	else
 +		called = false;
++=======
+ 		if (tmp != NULL && cpu != -1 && cpu != me &&
+ 		    kvm_request_needs_ipi(vcpu, req))
+ 			__cpumask_set_cpu(cpu, tmp);
+ 	}
+ 
+ 	called = kvm_kick_many_cpus(tmp, !!(req & KVM_REQUEST_WAIT));
++>>>>>>> 7053df4edb3a (KVM: introduce kvm_make_vcpus_request_mask() API)
  	put_cpu();
+ 
+ 	return called;
+ }
+ 
+ bool kvm_make_all_cpus_request(struct kvm *kvm, unsigned int req)
+ {
+ 	cpumask_var_t cpus;
+ 	bool called;
+ 	static unsigned long vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)]
+ 		= {[0 ... BITS_TO_LONGS(KVM_MAX_VCPUS)-1] = ULONG_MAX};
+ 
+ 	zalloc_cpumask_var(&cpus, GFP_ATOMIC);
+ 
+ 	called = kvm_make_vcpus_request_mask(kvm, req, vcpu_bitmap, cpus);
+ 
  	free_cpumask_var(cpus);
  	return called;
  }
* Unmerged path include/linux/kvm_host.h
* Unmerged path virt/kvm/kvm_main.c
