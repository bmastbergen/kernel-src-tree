mm/swap_slots.c: fix race conditions in swap_slots cache init

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Tim Chen <tim.c.chen@linux.intel.com>
commit a2e16731728a285bcfcece0feaaa8cf478d24022
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/a2e16731.failed

Memory allocations can happen before the swap_slots cache initialization
is completed during cpu bring up.  If we are low on memory, we could
call get_swap_page() and access swap_slots_cache before it is fully
initialized.

Add a check in get_swap_page() for initialized swap_slots_cache to
prevent this condition.  Similar check already exists in free_swap_slot.
Also annotate the checks to indicate the likely condition.

We also added a memory barrier to make sure that the locks
initialization are done before the assignment of cache->slots and
cache->slots_ret pointers.  This ensures the assumption that it is safe
to acquire the slots cache locks and use the slots cache when the
corresponding cache->slots or cache->slots_ret pointers are non null.

[akpm@linux-foundation.org: tidy up comment]
[akpm@linux-foundation.org: fix spello in comment]
Link: http://lkml.kernel.org/r/65a9d0f133f63e66bba37b53b2fd0464b7cae771.1500677066.git.tim.c.chen@linux.intel.com
	Signed-off-by: Tim Chen <tim.c.chen@linux.intel.com>
	Reported-by: Wenwei Tao <wenwei.tww@alibaba-inc.com>
	Acked-by: Ying Huang <ying.huang@intel.com>
	Cc: Minchan Kim <minchan@kernel.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Hillf Danton <hdanton@sina.com>
	Cc: Hugh Dickins <hughd@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit a2e16731728a285bcfcece0feaaa8cf478d24022)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/swap_slots.c
diff --cc mm/swap_slots.c
index e7db58f118cc,bebc19292018..000000000000
--- a/mm/swap_slots.c
+++ b/mm/swap_slots.c
@@@ -296,11 -281,11 +303,16 @@@ int free_swap_slot(swp_entry_t entry
  {
  	struct swap_slots_cache *cache;
  
++<<<<<<< HEAD
 +	cache = &get_cpu_var(swp_slots);
 +	if (use_swap_slot_cache && cache->slots_ret) {
++=======
+ 	cache = raw_cpu_ptr(&swp_slots);
+ 	if (likely(use_swap_slot_cache && cache->slots_ret)) {
++>>>>>>> a2e16731728a (mm/swap_slots.c: fix race conditions in swap_slots cache init)
  		spin_lock_irq(&cache->free_lock);
  		/* Swap slots cache may be deactivated before acquiring lock */
 -		if (!use_swap_slot_cache || !cache->slots_ret) {
 +		if (!use_swap_slot_cache) {
  			spin_unlock_irq(&cache->free_lock);
  			goto direct_free;
  		}
@@@ -339,10 -331,9 +351,14 @@@ swp_entry_t get_swap_page(void
  	 * The alloc path here does not touch cache->slots_ret
  	 * so cache->free_lock is not taken.
  	 */
 -	cache = raw_cpu_ptr(&swp_slots);
 +	cache = __this_cpu_ptr(&swp_slots);
  
++<<<<<<< HEAD
 +	entry.val = 0;
 +	if (check_cache_active()) {
++=======
+ 	if (likely(check_cache_active() && cache->slots)) {
++>>>>>>> a2e16731728a (mm/swap_slots.c: fix race conditions in swap_slots cache init)
  		mutex_lock(&cache->alloc_lock);
  		if (cache->slots) {
  repeat:
* Unmerged path mm/swap_slots.c
