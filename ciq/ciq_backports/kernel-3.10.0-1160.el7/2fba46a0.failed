gfs2: Change inode qa_data to allow multiple users

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit 2fba46a04c383f91e7fe837d43bf1ab33ce32b6a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/2fba46a0.failed

Before this patch, multiple users called gfs2_qa_alloc which allocated
a qadata structure to the inode, if quotas are turned on. Later, in
file close or evict, the structure was deleted with gfs2_qa_delete.
But there can be several competing processes who need access to the
structure. There were races between file close (release) and the others.
Thus, a release could delete the structure out from under a process
that relied upon its existence. For example, chown.

This patch changes the management of the qadata structures to be
a get/put scheme. Function gfs2_qa_alloc has been changed to gfs2_qa_get
and if the structure is allocated, the count essentially starts out at
1. Function gfs2_qa_delete has been renamed to gfs2_qa_put, and the
last guy to decrement the count to 0 frees the memory.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 2fba46a04c383f91e7fe837d43bf1ab33ce32b6a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/acl.c
#	fs/gfs2/bmap.c
#	fs/gfs2/file.c
#	fs/gfs2/inode.c
#	fs/gfs2/quota.c
#	fs/gfs2/xattr.c
diff --cc fs/gfs2/acl.c
index ad3b45fd2910,2e939f5fe751..000000000000
--- a/fs/gfs2/acl.c
+++ b/fs/gfs2/acl.c
@@@ -109,198 -106,45 +109,225 @@@ out
  	return error;
  }
  
 -int gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 +int gfs2_acl_create(struct gfs2_inode *dip, struct inode *inode)
  {
 -	struct gfs2_inode *ip = GFS2_I(inode);
 -	struct gfs2_holder gh;
 -	bool need_unlock = false;
 -	int ret;
 -	umode_t mode;
 +	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 +	struct posix_acl *acl;
 +	umode_t mode = inode->i_mode;
 +	int error = 0;
  
 -	if (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))
 -		return -E2BIG;
 +	if (!sdp->sd_args.ar_posix_acl)
 +		return 0;
 +	if (S_ISLNK(inode->i_mode))
 +		return 0;
  
++<<<<<<< HEAD
 +	acl = gfs2_get_acl(&dip->i_inode, ACL_TYPE_DEFAULT);
 +	if (IS_ERR(acl))
 +		return PTR_ERR(acl);
 +	if (!acl) {
 +		mode &= ~current_umask();
 +		return gfs2_set_mode(inode, mode);
++=======
+ 	ret = gfs2_qa_get(ip);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (!gfs2_glock_is_locked_by_me(ip->i_gl)) {
+ 		ret = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);
+ 		if (ret)
+ 			goto out;
+ 		need_unlock = true;
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	}
  
 -	mode = inode->i_mode;
 -	if (type == ACL_TYPE_ACCESS && acl) {
 -		ret = posix_acl_update_mode(inode, &mode, &acl);
 -		if (ret)
 -			goto unlock;
 +	if (S_ISDIR(inode->i_mode)) {
 +		error = gfs2_acl_set(inode, ACL_TYPE_DEFAULT, acl);
 +		if (error)
 +			goto out;
  	}
  
++<<<<<<< HEAD
 +	error = posix_acl_create(&acl, GFP_NOFS, &mode);
 +	if (error < 0)
 +		return error;
 +
 +	if (error == 0)
 +		goto munge;
 +
 +	error = gfs2_acl_set(inode, ACL_TYPE_ACCESS, acl);
 +	if (error)
 +		goto out;
 +munge:
 +	error = gfs2_set_mode(inode, mode);
 +out:
 +	posix_acl_release(acl);
 +	return error;
++=======
+ 	ret = __gfs2_set_acl(inode, acl, type);
+ 	if (!ret && mode != inode->i_mode) {
+ 		inode->i_ctime = current_time(inode);
+ 		inode->i_mode = mode;
+ 		mark_inode_dirty(inode);
+ 	}
+ unlock:
+ 	if (need_unlock)
+ 		gfs2_glock_dq_uninit(&gh);
+ out:
+ 	gfs2_qa_put(ip);
+ 	return ret;
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
 +}
 +
 +int gfs2_acl_chmod(struct gfs2_inode *ip, struct iattr *attr)
 +{
 +	struct inode *inode = &ip->i_inode;
 +	struct posix_acl *acl;
 +	char *data;
 +	unsigned int len;
 +	int error;
 +
 +	acl = gfs2_get_acl(&ip->i_inode, ACL_TYPE_ACCESS);
 +	if (IS_ERR(acl))
 +		return PTR_ERR(acl);
 +	if (!acl)
 +		return gfs2_setattr_simple(inode, attr);
 +
 +	error = posix_acl_chmod(&acl, GFP_NOFS, attr->ia_mode);
 +	if (error)
 +		return error;
 +
 +	len = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);
 +	data = kmalloc(len, GFP_NOFS);
 +	error = -ENOMEM;
 +	if (data == NULL)
 +		goto out;
 +	posix_acl_to_xattr(&init_user_ns, acl, data, len);
 +	error = gfs2_xattr_acl_chmod(ip, attr, data);
 +	kfree(data);
 +	set_cached_acl(&ip->i_inode, ACL_TYPE_ACCESS, acl);
 +
 +out:
 +	posix_acl_release(acl);
 +	return error;
 +}
 +
 +static int gfs2_acl_type(const char *name)
 +{
 +	if (strcmp(name, GFS2_POSIX_ACL_ACCESS) == 0)
 +		return ACL_TYPE_ACCESS;
 +	if (strcmp(name, GFS2_POSIX_ACL_DEFAULT) == 0)
 +		return ACL_TYPE_DEFAULT;
 +	return -EINVAL;
  }
 +
 +static int gfs2_xattr_system_get(struct dentry *dentry, const char *name,
 +				 void *buffer, size_t size, int xtype)
 +{
 +	struct inode *inode = dentry->d_inode;
 +	struct gfs2_sbd *sdp = GFS2_SB(inode);
 +	struct posix_acl *acl;
 +	int type;
 +	int error;
 +
 +	if (!sdp->sd_args.ar_posix_acl)
 +		return -EOPNOTSUPP;
 +
 +	type = gfs2_acl_type(name);
 +	if (type < 0)
 +		return type;
 +
 +	acl = gfs2_get_acl(inode, type);
 +	if (IS_ERR(acl))
 +		return PTR_ERR(acl);
 +	if (acl == NULL)
 +		return -ENODATA;
 +
 +	error = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);
 +	posix_acl_release(acl);
 +
 +	return error;
 +}
 +
 +static int gfs2_xattr_system_set(struct dentry *dentry, const char *name,
 +				 const void *value, size_t size, int flags,
 +				 int xtype)
 +{
 +	struct inode *inode = dentry->d_inode;
 +	struct gfs2_sbd *sdp = GFS2_SB(inode);
 +	struct posix_acl *acl = NULL, *real_acl = NULL;
 +	int error = 0, type;
 +
 +	if (!sdp->sd_args.ar_posix_acl)
 +		return -EOPNOTSUPP;
 +
 +	type = gfs2_acl_type(name);
 +	if (type < 0)
 +		return type;
 +	if (flags & XATTR_CREATE)
 +		return -EINVAL;
 +	if (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))
 +		return value ? -EACCES : 0;
 +	if (!uid_eq(current_fsuid(), inode->i_uid) && !capable(CAP_FOWNER))
 +		return -EPERM;
 +	if (S_ISLNK(inode->i_mode))
 +		return -EOPNOTSUPP;
 +
 +	if (!value)
 +		goto set_acl;
 +
 +	acl = posix_acl_from_xattr(&init_user_ns, value, size);
 +	if (!acl) {
 +		/*
 +		 * acl_set_file(3) may request that we set default ACLs with
 +		 * zero length -- defend (gracefully) against that here.
 +		 */
 +		goto out;
 +	}
 +	if (IS_ERR(acl)) {
 +		error = PTR_ERR(acl);
 +		goto out;
 +	}
 +
 +	error = posix_acl_valid(inode->i_sb->s_user_ns, acl);
 +	if (error)
 +		goto out_release;
 +
 +	error = -EINVAL;
 +	if (acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))
 +		goto out_release;
 +
 +	real_acl = acl;
 +	if (type == ACL_TYPE_ACCESS) {
 +		umode_t mode;
 +
 +		error = posix_acl_update_mode(inode, &mode, &real_acl);
 +		if (error)
 +			goto out_release;
 +
 +		error = gfs2_set_mode(inode, mode);
 +		if (error)
 +			goto out_release;
 +	}
 +
 +set_acl:
 +	error = __gfs2_xattr_set(inode, name, value, size, 0, GFS2_EATYPE_SYS);
 +	if (!error) {
 +		if (real_acl)
 +			set_cached_acl(inode, type, real_acl);
 +		else
 +			forget_cached_acl(inode, type);
 +	}
 +out_release:
 +	posix_acl_release(acl);
 +out:
 +	return error;
 +}
 +
 +const struct xattr_handler gfs2_xattr_system_handler = {
 +	.prefix = XATTR_SYSTEM_PREFIX,
 +	.flags  = GFS2_EATYPE_SYS,
 +	.get    = gfs2_xattr_system_get,
 +	.set    = gfs2_xattr_system_set,
 +};
 +
diff --cc fs/gfs2/bmap.c
index 1879d6dd89c5,d510a453dfa8..000000000000
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@@ -2186,7 -2183,7 +2186,11 @@@ int gfs2_setattr_size(struct inode *ino
  
  	inode_dio_wait(inode);
  
++<<<<<<< HEAD
 +	ret = gfs2_rsqa_alloc(ip);
++=======
+ 	ret = gfs2_qa_get(ip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	if (ret)
  		goto out;
  
diff --cc fs/gfs2/file.c
index 1c0c0f8e680b,f18876cdfb0f..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -411,7 -458,7 +411,11 @@@ static int gfs2_page_mkwrite(struct vm_
  
  	sb_start_pagefault(inode->i_sb);
  
++<<<<<<< HEAD
 +	ret = gfs2_rsqa_alloc(ip);
++=======
+ 	ret = gfs2_qa_get(ip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	if (ret)
  		goto out;
  
@@@ -706,17 -851,14 +719,21 @@@ static int gfs2_fsync(struct file *file
   *
   */
  
 -static ssize_t gfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
 +static ssize_t gfs2_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 +				   unsigned long nr_segs, loff_t pos)
  {
  	struct file *file = iocb->ki_filp;
 -	struct inode *inode = file_inode(file);
 +	struct address_space *mapping = file->f_mapping;
 +	struct inode *inode = mapping->host;
  	struct gfs2_inode *ip = GFS2_I(inode);
 +	size_t ocount, count;
  	ssize_t ret;
  
++<<<<<<< HEAD
 +	ret = gfs2_rsqa_alloc(ip);
++=======
+ 	ret = gfs2_qa_get(ip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	if (ret)
  		return ret;
  
@@@ -731,52 -873,62 +748,57 @@@
  		gfs2_glock_dq_uninit(&gh);
  	}
  
 -	inode_lock(inode);
 -	ret = generic_write_checks(iocb, from);
 -	if (ret <= 0)
 -		goto out_unlock;
 +	if (io_is_direct(file))
 +		return generic_file_aio_write(iocb, iov, nr_segs, pos);
  
 -	ret = file_remove_privs(file);
 +	ocount = 0;
 +	ret = generic_segment_checks(iov, &nr_segs, &ocount, VERIFY_READ);
  	if (ret)
 -		goto out_unlock;
 +		return ret;
  
 -	ret = file_update_time(file);
 +	count = ocount;
 +
 +	BUG_ON(iocb->ki_pos != pos);
 +
 +	inode_lock(inode);
 +	ret = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));
  	if (ret)
 -		goto out_unlock;
 +		goto out;
  
 -	if (iocb->ki_flags & IOCB_DIRECT) {
 -		struct address_space *mapping = file->f_mapping;
 -		ssize_t buffered, ret2;
 +	if (count == 0)
 +		goto out;
  
 -		ret = gfs2_file_direct_write(iocb, from);
 -		if (ret < 0 || !iov_iter_count(from))
 -			goto out_unlock;
 +	/* We can write back this queue in page reclaim */
 +	current->backing_dev_info = mapping->backing_dev_info;
  
 -		iocb->ki_flags |= IOCB_DSYNC;
 -		current->backing_dev_info = inode_to_bdi(inode);
 -		buffered = iomap_file_buffered_write(iocb, from, &gfs2_iomap_ops);
 -		current->backing_dev_info = NULL;
 -		if (unlikely(buffered <= 0))
 -			goto out_unlock;
 +	ret = file_remove_privs(file);
 +	if (ret)
 +		goto out2;
  
 -		/*
 -		 * We need to ensure that the page cache pages are written to
 -		 * disk and invalidated to preserve the expected O_DIRECT
 -		 * semantics.  If the writeback or invalidate fails, only report
 -		 * the direct I/O range as we don't know if the buffered pages
 -		 * made it to disk.
 -		 */
 -		iocb->ki_pos += buffered;
 -		ret2 = generic_write_sync(iocb, buffered);
 -		invalidate_mapping_pages(mapping,
 -				(iocb->ki_pos - buffered) >> PAGE_SHIFT,
 -				(iocb->ki_pos - 1) >> PAGE_SHIFT);
 -		if (!ret || ret2 > 0)
 -			ret += ret2;
 -	} else {
 -		current->backing_dev_info = inode_to_bdi(inode);
 -		ret = iomap_file_buffered_write(iocb, from, &gfs2_iomap_ops);
 -		current->backing_dev_info = NULL;
 -		if (likely(ret > 0)) {
 -			iocb->ki_pos += ret;
 -			ret = generic_write_sync(iocb, ret);
 -		}
 -	}
 +	ret = file_update_time(file);
 +	if (ret)
 +		goto out2;
  
 -out_unlock:
 +	ret = iomap_file_buffered_write(iocb, iov, nr_segs, pos, &iocb->ki_pos,
 +					count, &gfs2_iomap_ops);
 +
 +out2:
 +	current->backing_dev_info = NULL;
 +out:
  	inode_unlock(inode);
++<<<<<<< HEAD
 +	if (likely(ret > 0)) {
 +		ssize_t err;
 +
 +		/* Handle various SYNC-type writes */
 +		err = generic_write_sync(file, pos, ret);
 +		if (err < 0 && ret > 0)
 +			ret = err;
 +	}
++=======
+ out:
+ 	gfs2_qa_put(ip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	return ret;
  }
  
@@@ -1004,7 -1160,7 +1026,11 @@@ static long gfs2_fallocate(struct file 
  	if (mode & FALLOC_FL_PUNCH_HOLE) {
  		ret = __gfs2_punch_hole(file, offset, len);
  	} else {
++<<<<<<< HEAD
 +		ret = gfs2_rsqa_alloc(ip);
++=======
+ 		ret = gfs2_qa_get(ip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  		if (ret)
  			goto out_putw;
  
@@@ -1053,14 -1187,17 +1080,25 @@@ static ssize_t gfs2_file_splice_write(s
  {
  	int error;
  	struct gfs2_inode *ip = GFS2_I(out->f_mapping->host);
+ 	ssize_t ret;
  
++<<<<<<< HEAD
 +	error = gfs2_rsqa_alloc(ip);
++=======
+ 	error = gfs2_qa_get(ip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	if (error)
  		return (ssize_t)error;
  
  	gfs2_size_hint(out, *ppos, len);
  
++<<<<<<< HEAD
 +	return generic_file_splice_write(pipe, out, ppos, len, flags);
++=======
+ 	ret = iter_file_splice_write(pipe, out, ppos, len, flags);
+ 	gfs2_qa_put(ip);
+ 	return ret;
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  }
  
  #ifdef CONFIG_GFS2_FS_LOCKING_DLM
diff --cc fs/gfs2/inode.c
index a7cb675316c4,d1a24753c55f..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -561,7 -588,7 +561,11 @@@ static int gfs2_create_inode(struct ino
  	if (!name->len || name->len > GFS2_FNAMESIZE)
  		return -ENAMETOOLONG;
  
++<<<<<<< HEAD
 +	error = gfs2_rsqa_alloc(dip);
++=======
+ 	error = gfs2_qa_get(dip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	if (error)
  		return error;
  
@@@ -609,10 -636,14 +613,14 @@@
  	if (!inode)
  		goto fail_gunlock;
  
 -	error = posix_acl_create(dir, &mode, &default_acl, &acl);
 -	if (error)
 -		goto fail_gunlock;
 -
  	ip = GFS2_I(inode);
++<<<<<<< HEAD
 +	error = gfs2_rsqa_alloc(ip);
++=======
+ 	error = gfs2_qa_get(ip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	if (error)
 -		goto fail_free_acls;
 +		goto fail_free_inode;
  
  	inode->i_mode = mode;
  	set_nlink(inode, S_ISDIR(mode) ? 2 : 1);
@@@ -719,11 -772,11 +727,12 @@@
  fail_gunlock3:
  	glock_clear_object(io_gl, ip);
  	gfs2_glock_dq_uninit(&ip->i_iopen_gh);
 -fail_gunlock2:
 -	clear_bit(GLF_INODE_CREATING, &io_gl->gl_flags);
  	gfs2_glock_put(io_gl);
 +fail_gunlock2:
 +	if (io_gl)
 +		clear_bit(GLF_INODE_CREATING, &io_gl->gl_flags);
  fail_free_inode:
+ 	gfs2_qa_put(ip);
  	if (ip->i_gl) {
  		glock_clear_object(ip->i_gl, ip);
  		gfs2_glock_put(ip->i_gl);
@@@ -847,7 -901,7 +857,11 @@@ static int gfs2_link(struct dentry *old
  	if (S_ISDIR(inode->i_mode))
  		return -EPERM;
  
++<<<<<<< HEAD
 +	error = gfs2_rsqa_alloc(dip);
++=======
+ 	error = gfs2_qa_get(dip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	if (error)
  		return error;
  
@@@ -1322,7 -1365,7 +1337,11 @@@ static int gfs2_rename(struct inode *od
  	if (error)
  		return error;
  
++<<<<<<< HEAD
 +	error = gfs2_rsqa_alloc(ndip);
++=======
+ 	error = gfs2_qa_get(ndip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	if (error)
  		return error;
  
@@@ -1828,10 -1877,9 +1848,14 @@@ static int setattr_chown(struct inode *
  		ouid = nuid = NO_UID_QUOTA_CHANGE;
  	if (!(attr->ia_valid & ATTR_GID) || gid_eq(ogid, ngid))
  		ogid = ngid = NO_GID_QUOTA_CHANGE;
++<<<<<<< HEAD
 +
 +	error = gfs2_rsqa_alloc(ip);
++=======
+ 	error = gfs2_qa_get(ip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	if (error)
- 		goto out;
+ 		return error;
  
  	error = gfs2_rindex_update(sdp);
  	if (error)
@@@ -1890,7 -1939,7 +1915,11 @@@ static int gfs2_setattr(struct dentry *
  	struct gfs2_holder i_gh;
  	int error;
  
++<<<<<<< HEAD
 +	error = gfs2_rsqa_alloc(ip);
++=======
+ 	error = gfs2_qa_get(ip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	if (error)
  		return error;
  
@@@ -1900,22 -1949,23 +1929,22 @@@
  
  	error = -EPERM;
  	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
- 		goto out;
+ 		goto error;
  
 -	error = setattr_prepare(dentry, attr);
 +	error = inode_change_ok(inode, attr);
  	if (error)
- 		goto out;
+ 		goto error;
  
  	if (attr->ia_valid & ATTR_SIZE)
  		error = gfs2_setattr_size(inode, attr->ia_size);
  	else if (attr->ia_valid & (ATTR_UID | ATTR_GID))
  		error = setattr_chown(inode, attr);
 -	else {
 +	else if ((attr->ia_valid & ATTR_MODE) && IS_POSIXACL(inode))
 +		error = gfs2_acl_chmod(ip, attr);
 +	else
  		error = gfs2_setattr_simple(inode, attr);
 -		if (!error && attr->ia_valid & ATTR_MODE)
 -			error = posix_acl_chmod(inode, inode->i_mode);
 -	}
  
- out:
+ error:
  	if (!error)
  		mark_inode_dirty(inode);
  	gfs2_glock_dq_uninit(&i_gh);
diff --cc fs/gfs2/quota.c
index 59f8789aa118,cc0c4b5800be..000000000000
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@@ -557,11 -570,9 +561,17 @@@ int gfs2_quota_hold(struct gfs2_inode *
  	if (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)
  		return 0;
  
++<<<<<<< HEAD
 +	if (ip->i_qadata == NULL) {
 +		error = gfs2_rsqa_alloc(ip);
 +		if (error)
 +			return error;
 +	}
++=======
+ 	error = gfs2_qa_get(ip);
+ 	if (error)
+ 		return error;
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  
  	qd = ip->i_qadata->qa_qd;
  
@@@ -870,19 -883,21 +885,31 @@@ static int do_sync(unsigned int num_qd
  	unsigned int nalloc = 0, blocks;
  	int error;
  
++<<<<<<< HEAD
 +	error = gfs2_rsqa_alloc(ip);
++=======
+ 	error = gfs2_qa_get(ip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	if (error)
  		return error;
  
  	gfs2_write_calc_reserv(ip, sizeof(struct gfs2_quota),
  			      &data_blocks, &ind_blocks);
  
++<<<<<<< HEAD
 +	ghs = kmalloc(num_qd * sizeof(struct gfs2_holder), GFP_NOFS);
 +	if (!ghs)
 +		return -ENOMEM;
++=======
+ 	ghs = kmalloc_array(num_qd, sizeof(struct gfs2_holder), GFP_NOFS);
+ 	if (!ghs) {
+ 		error = -ENOMEM;
+ 		goto out;
+ 	}
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  
  	sort(qda, num_qd, sizeof(struct gfs2_quota_data *), sort_qd, NULL);
 -	inode_lock(&ip->i_inode);
 +	mutex_lock(&ip->i_inode.i_mutex);
  	for (qx = 0; qx < num_qd; qx++) {
  		error = gfs2_glock_nq_init(qda[qx]->qd_gl, LM_ST_EXCLUSIVE,
  					   GL_NOCACHE, &ghs[qx]);
@@@ -944,12 -959,15 +971,19 @@@ out_ipres
  	gfs2_inplace_release(ip);
  out_alloc:
  	gfs2_glock_dq_uninit(&i_gh);
- out:
+ out_dq:
  	while (qx--)
  		gfs2_glock_dq_uninit(&ghs[qx]);
 -	inode_unlock(&ip->i_inode);
 +	mutex_unlock(&ip->i_inode.i_mutex);
  	kfree(ghs);
++<<<<<<< HEAD
 +	gfs2_log_flush(ip->i_gl->gl_name.ln_sbd, ip->i_gl);
++=======
+ 	gfs2_log_flush(ip->i_gl->gl_name.ln_sbd, ip->i_gl,
+ 		       GFS2_LOG_HEAD_FLUSH_NORMAL | GFS2_LFC_DO_SYNC);
+ out:
+ 	gfs2_qa_put(ip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	return error;
  }
  
@@@ -1678,7 -1689,7 +1713,11 @@@ static int gfs2_set_dqblk(struct super_
  	if (error)
  		return error;
  
++<<<<<<< HEAD
 +	error = gfs2_rsqa_alloc(ip);
++=======
+ 	error = gfs2_qa_get(ip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	if (error)
  		goto out_put;
  
@@@ -1747,7 -1758,8 +1786,12 @@@ out_i
  out_q:
  	gfs2_glock_dq_uninit(&q_gh);
  out_unlockput:
++<<<<<<< HEAD
 +	mutex_unlock(&ip->i_inode.i_mutex);
++=======
+ 	gfs2_qa_put(ip);
+ 	inode_unlock(&ip->i_inode);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  out_put:
  	qd_put(qd);
  	return error;
diff --cc fs/gfs2/xattr.c
index 3d8d490c8606,9d7667bc4292..000000000000
--- a/fs/gfs2/xattr.c
+++ b/fs/gfs2/xattr.c
@@@ -1202,29 -1213,37 +1202,52 @@@ int __gfs2_xattr_set(struct inode *inod
  	return error;
  }
  
 -static int gfs2_xattr_set(const struct xattr_handler *handler,
 -			  struct dentry *unused, struct inode *inode,
 -			  const char *name, const void *value,
 -			  size_t size, int flags)
 +static int gfs2_xattr_set(struct dentry *dentry, const char *name,
 +		const void *value, size_t size, int flags, int type)
  {
 -	struct gfs2_inode *ip = GFS2_I(inode);
 -	struct gfs2_holder gh;
 +	return __gfs2_xattr_set(dentry->d_inode, name, value,
 +				size, flags, type);
 +}
 +
 +
 +static int ea_acl_chmod_unstuffed(struct gfs2_inode *ip,
 +				  struct gfs2_ea_header *ea, char *data)
 +{
 +	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
 +	unsigned int amount = GFS2_EA_DATA_LEN(ea);
 +	unsigned int nptrs = DIV_ROUND_UP(amount, sdp->sd_jbsize);
  	int ret;
  
++<<<<<<< HEAD
 +	ret = gfs2_trans_begin(sdp, nptrs + RES_DINODE, 0);
++=======
+ 	ret = gfs2_qa_get(ip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	if (ret)
  		return ret;
  
 -	/* May be called from gfs_setattr with the glock locked. */
 +	ret = gfs2_iter_unstuffed(ip, ea, data, NULL);
 +	gfs2_trans_end(sdp);
  
++<<<<<<< HEAD
++=======
+ 	if (!gfs2_glock_is_locked_by_me(ip->i_gl)) {
+ 		ret = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);
+ 		if (ret)
+ 			goto out;
+ 	} else {
+ 		if (WARN_ON_ONCE(ip->i_gl->gl_state != LM_ST_EXCLUSIVE)) {
+ 			ret = -EIO;
+ 			goto out;
+ 		}
+ 		gfs2_holder_mark_uninitialized(&gh);
+ 	}
+ 	ret = __gfs2_xattr_set(inode, name, value, size, flags, handler->flags);
+ 	if (gfs2_holder_initialized(&gh))
+ 		gfs2_glock_dq_uninit(&gh);
+ out:
+ 	gfs2_qa_put(ip);
++>>>>>>> 2fba46a04c38 (gfs2: Change inode qa_data to allow multiple users)
  	return ret;
  }
  
* Unmerged path fs/gfs2/acl.c
* Unmerged path fs/gfs2/bmap.c
* Unmerged path fs/gfs2/file.c
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 7bc931735e6f..1f6f222b6802 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -264,6 +264,7 @@ struct gfs2_qadata { /* quota allocation data */
 	struct gfs2_quota_data *qa_qd[2 * GFS2_MAXQUOTAS];
 	struct gfs2_holder qa_qd_ghs[2 * GFS2_MAXQUOTAS];
 	unsigned int qa_qd_num;
+	int qa_ref;
 };
 
 /* Resource group multi-block reservation, in order of appearance:
* Unmerged path fs/gfs2/inode.c
* Unmerged path fs/gfs2/quota.c
diff --git a/fs/gfs2/quota.h b/fs/gfs2/quota.h
index 836f29480be6..deadec556896 100644
--- a/fs/gfs2/quota.h
+++ b/fs/gfs2/quota.h
@@ -18,8 +18,8 @@ struct gfs2_sbd;
 #define NO_UID_QUOTA_CHANGE INVALID_UID
 #define NO_GID_QUOTA_CHANGE INVALID_GID
 
-extern int gfs2_qa_alloc(struct gfs2_inode *ip);
-extern void gfs2_qa_delete(struct gfs2_inode *ip, atomic_t *wcount);
+extern int gfs2_qa_get(struct gfs2_inode *ip);
+extern void gfs2_qa_put(struct gfs2_inode *ip);
 extern int gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid);
 extern void gfs2_quota_unhold(struct gfs2_inode *ip);
 
diff --git a/fs/gfs2/rgrp.c b/fs/gfs2/rgrp.c
index 61ede4feb7e3..65a9a75972ec 100644
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@ -648,7 +648,7 @@ void gfs2_rsqa_delete(struct gfs2_inode *ip, atomic_t *wcount)
 	if ((wcount == NULL) || (atomic_read(wcount) <= 1))
 		gfs2_rs_deltree(&ip->i_res);
 	up_write(&ip->i_rw_mutex);
-	gfs2_qa_delete(ip, wcount);
+	gfs2_qa_put(ip);
 }
 
 /**
diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c
index 6327156ef20f..d01ff4b52b57 100644
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@ -1648,6 +1648,8 @@ out_unlock:
 out:
 	/* Case 3 starts here */
 	truncate_inode_pages_final(&inode->i_data);
+	if (ip->i_qadata)
+		gfs2_assert_warn(sdp, ip->i_qadata->qa_ref == 0);
 	gfs2_rsqa_delete(ip, NULL);
 	gfs2_ordered_del_inode(ip);
 	clear_inode(inode);
* Unmerged path fs/gfs2/xattr.c
