signal: Don't send signals to tasks that don't exist

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 84fe4cc09abc1a5ef3a282db3ed10f4d3f1e6a0b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/84fe4cc0.failed

Recently syzbot reported crashes in send_sigio_to_task and
send_sigurg_to_task in linux-next.  Despite finding a reproducer
syzbot apparently did not bisected this or otherwise track down the
offending commit in linux-next.

I happened to see this report and examined the code because I had
recently changed these functions as part of making PIDTYPE_TGID a real
pid type so that fork would does not need to restart when receiving a
signal.  By examination I see that I spotted a bug in the code
that could explain the reported crashes.

When I took Oleg's suggestion and optimized send_sigurg and send_sigio
to only send to a single task when type is PIDTYPE_PID or PIDTYPE_TGID
I failed to handle pids that no longer point to tasks.  The macro
do_each_pid_task simply iterates for zero iterations.  With pid_task
an explicit NULL test is needed.

Update the code to include the missing NULL test.

Fixes: 019191342fec ("signal: Use PIDTYPE_TGID to clearly store where file signals will be sent")
	Reported-by: syzkaller-bugs@googlegroups.com
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit 84fe4cc09abc1a5ef3a282db3ed10f4d3f1e6a0b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fcntl.c
diff --cc fs/fcntl.c
index 5c030954e9f9,4137d96534a6..000000000000
--- a/fs/fcntl.c
+++ b/fs/fcntl.c
@@@ -530,12 -787,20 +530,29 @@@ void send_sigio(struct fown_struct *fow
  	pid = fown->pid;
  	if (!pid)
  		goto out_unlock_fown;
++<<<<<<< HEAD
 +	
 +	qread_lock(&tasklist_lock);
 +	do_each_pid_task(pid, type, p) {
 +		send_sigio_to_task(p, fown, fd, band, group);
 +	} while_each_pid_task(pid, type, p);
 +	qread_unlock(&tasklist_lock);
++=======
+ 
+ 	if (type <= PIDTYPE_TGID) {
+ 		rcu_read_lock();
+ 		p = pid_task(pid, PIDTYPE_PID);
+ 		if (p)
+ 			send_sigio_to_task(p, fown, fd, band, type);
+ 		rcu_read_unlock();
+ 	} else {
+ 		read_lock(&tasklist_lock);
+ 		do_each_pid_task(pid, type, p) {
+ 			send_sigio_to_task(p, fown, fd, band, type);
+ 		} while_each_pid_task(pid, type, p);
+ 		read_unlock(&tasklist_lock);
+ 	}
++>>>>>>> 84fe4cc09abc (signal: Don't send signals to tasks that don't exist)
   out_unlock_fown:
  	read_unlock(&fown->lock);
  }
@@@ -568,12 -827,20 +585,29 @@@ int send_sigurg(struct fown_struct *fow
  		goto out_unlock_fown;
  
  	ret = 1;
++<<<<<<< HEAD
 +	
 +	qread_lock(&tasklist_lock);
 +	do_each_pid_task(pid, type, p) {
 +		send_sigurg_to_task(p, fown, group);
 +	} while_each_pid_task(pid, type, p);
 +	qread_unlock(&tasklist_lock);
++=======
+ 
+ 	if (type <= PIDTYPE_TGID) {
+ 		rcu_read_lock();
+ 		p = pid_task(pid, PIDTYPE_PID);
+ 		if (p)
+ 			send_sigurg_to_task(p, fown, type);
+ 		rcu_read_unlock();
+ 	} else {
+ 		read_lock(&tasklist_lock);
+ 		do_each_pid_task(pid, type, p) {
+ 			send_sigurg_to_task(p, fown, type);
+ 		} while_each_pid_task(pid, type, p);
+ 		read_unlock(&tasklist_lock);
+ 	}
++>>>>>>> 84fe4cc09abc (signal: Don't send signals to tasks that don't exist)
   out_unlock_fown:
  	read_unlock(&fown->lock);
  	return ret;
* Unmerged path fs/fcntl.c
