x86/Hyper-V: Report crash data in die() when panic_on_oops is set

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
Rebuild_CHGLOG: - [x86] hyper-v: Report crash data in die() when panic_on_oops is set (Mohammed Gamal) [1828450]
Rebuild_FUZZ: 96.83%
commit-author Tianyu Lan <Tianyu.Lan@microsoft.com>
commit f3a99e761efa616028b255b4de58e9b5b87c5545
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/f3a99e76.failed

When oops happens with panic_on_oops unset, the oops
thread is killed by die() and system continues to run.
In such case, guest should not report crash register
data to host since system still runs. Check panic_on_oops
and return directly in hyperv_report_panic() when the function
is called in the die() and panic_on_oops is unset. Fix it.

Fixes: 7ed4325a44ea ("Drivers: hv: vmbus: Make panic reporting to be more useful")
	Signed-off-by: Tianyu Lan <Tianyu.Lan@microsoft.com>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
Link: https://lore.kernel.org/r/20200406155331.2105-7-Tianyu.Lan@microsoft.com
	Signed-off-by: Wei Liu <wei.liu@kernel.org>
(cherry picked from commit f3a99e761efa616028b255b4de58e9b5b87c5545)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/hv_init.c
#	drivers/hv/vmbus_drv.c
#	include/asm-generic/mshyperv.h
diff --cc arch/x86/hyperv/hv_init.c
index 2c8a003f032c,624f5d9b0f79..000000000000
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@@ -26,103 -18,223 +26,110 @@@
  #include <linux/version.h>
  #include <linux/vmalloc.h>
  #include <linux/mm.h>
 +#include <linux/clockchips.h>
  #include <linux/hyperv.h>
  #include <linux/slab.h>
 -#include <linux/kernel.h>
 -#include <linux/cpuhotplug.h>
 -#include <linux/syscore_ops.h>
 -#include <clocksource/hyperv_timer.h>
++<<<<<<< HEAD
 +#include <linux/cpu.h>
 +#include <linux/kaiser.h>
  
 -void *hv_hypercall_pg;
 -EXPORT_SYMBOL_GPL(hv_hypercall_pg);
 +#ifdef CONFIG_HYPERV_TSCPAGE
  
 -/* Storage to save the hypercall page temporarily for hibernation */
 -static void *hv_hypercall_pg_saved;
 +static struct ms_hyperv_tsc_page *tsc_pg;
  
 -u32 *hv_vp_index;
 -EXPORT_SYMBOL_GPL(hv_vp_index);
 -
 -struct hv_vp_assist_page **hv_vp_assist_page;
 -EXPORT_SYMBOL_GPL(hv_vp_assist_page);
 -
 -void  __percpu **hyperv_pcpu_input_arg;
 -EXPORT_SYMBOL_GPL(hyperv_pcpu_input_arg);
 -
 -u32 hv_max_vp_index;
 -EXPORT_SYMBOL_GPL(hv_max_vp_index);
 -
 -void *hv_alloc_hyperv_page(void)
 +struct ms_hyperv_tsc_page *hv_get_tsc_page(void)
  {
 -	BUILD_BUG_ON(PAGE_SIZE != HV_HYP_PAGE_SIZE);
 -
 -	return (void *)__get_free_page(GFP_KERNEL);
 +	return tsc_pg;
  }
 -EXPORT_SYMBOL_GPL(hv_alloc_hyperv_page);
  
 -void *hv_alloc_hyperv_zeroed_page(void)
 +static u64 read_hv_clock_tsc(struct clocksource *arg)
  {
 -        BUILD_BUG_ON(PAGE_SIZE != HV_HYP_PAGE_SIZE);
 +	u64 current_tick = hv_read_tsc_page(tsc_pg);
  
 -        return (void *)__get_free_page(GFP_KERNEL | __GFP_ZERO);
 -}
 -EXPORT_SYMBOL_GPL(hv_alloc_hyperv_zeroed_page);
 +	if (current_tick == U64_MAX)
 +		rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
  
 -void hv_free_hyperv_page(unsigned long addr)
 -{
 -	free_page(addr);
 +	return current_tick;
  }
 -EXPORT_SYMBOL_GPL(hv_free_hyperv_page);
 -
 -static int hv_cpu_init(unsigned int cpu)
 -{
 -	u64 msr_vp_index;
 -	struct hv_vp_assist_page **hvp = &hv_vp_assist_page[smp_processor_id()];
 -	void **input_arg;
 -	struct page *pg;
 -
 -	input_arg = (void **)this_cpu_ptr(hyperv_pcpu_input_arg);
 -	pg = alloc_page(GFP_KERNEL);
 -	if (unlikely(!pg))
 -		return -ENOMEM;
 -	*input_arg = page_address(pg);
 -
 -	hv_get_vp_index(msr_vp_index);
 -
 -	hv_vp_index[smp_processor_id()] = msr_vp_index;
 -
 -	if (msr_vp_index > hv_max_vp_index)
 -		hv_max_vp_index = msr_vp_index;
 -
 -	if (!hv_vp_assist_page)
 -		return 0;
 -
 -	/*
 -	 * The VP ASSIST PAGE is an "overlay" page (see Hyper-V TLFS's Section
 -	 * 5.2.1 "GPA Overlay Pages"). Here it must be zeroed out to make sure
 -	 * we always write the EOI MSR in hv_apic_eoi_write() *after* the
 -	 * EOI optimization is disabled in hv_cpu_die(), otherwise a CPU may
 -	 * not be stopped in the case of CPU offlining and the VM will hang.
 -	 */
 -	if (!*hvp) {
 -		*hvp = __vmalloc(PAGE_SIZE, GFP_KERNEL | __GFP_ZERO,
 -				 PAGE_KERNEL);
 -	}
 -
 -	if (*hvp) {
 -		u64 val;
  
 -		val = vmalloc_to_pfn(*hvp);
 -		val = (val << HV_X64_MSR_VP_ASSIST_PAGE_ADDRESS_SHIFT) |
 -			HV_X64_MSR_VP_ASSIST_PAGE_ENABLE;
 -
 -		wrmsrl(HV_X64_MSR_VP_ASSIST_PAGE, val);
 -	}
 -
 -	return 0;
 -}
 -
 -static void (*hv_reenlightenment_cb)(void);
 -
 -static void hv_reenlightenment_notify(struct work_struct *dummy)
 -{
 -	struct hv_tsc_emulation_status emu_status;
 -
 -	rdmsrl(HV_X64_MSR_TSC_EMULATION_STATUS, *(u64 *)&emu_status);
 -
 -	/* Don't issue the callback if TSC accesses are not emulated */
 -	if (hv_reenlightenment_cb && emu_status.inprogress)
 -		hv_reenlightenment_cb();
 -}
 -static DECLARE_DELAYED_WORK(hv_reenlightenment_work, hv_reenlightenment_notify);
 -
 -void hyperv_stop_tsc_emulation(void)
 -{
 -	u64 freq;
 -	struct hv_tsc_emulation_status emu_status;
 -
 -	rdmsrl(HV_X64_MSR_TSC_EMULATION_STATUS, *(u64 *)&emu_status);
 -	emu_status.inprogress = 0;
 -	wrmsrl(HV_X64_MSR_TSC_EMULATION_STATUS, *(u64 *)&emu_status);
 -
 -	rdmsrl(HV_X64_MSR_TSC_FREQUENCY, freq);
 -	tsc_khz = div64_u64(freq, 1000);
 -}
 -EXPORT_SYMBOL_GPL(hyperv_stop_tsc_emulation);
 +static struct clocksource hyperv_cs_tsc = {
 +		.name		= "hyperv_clocksource_tsc_page",
 +		.rating		= 400,
 +		.read		= read_hv_clock_tsc,
 +		.mask		= CLOCKSOURCE_MASK(64),
 +		.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 +};
 +#endif
  
 -static inline bool hv_reenlightenment_available(void)
 +static u64 read_hv_clock_msr(struct clocksource *arg)
  {
 +	u64 current_tick;
  	/*
 -	 * Check for required features and priviliges to make TSC frequency
 -	 * change notifications work.
 +	 * Read the partition counter to get the current tick count. This count
 +	 * is set to 0 when the partition is created and is incremented in
 +	 * 100 nanosecond units.
  	 */
 -	return ms_hyperv.features & HV_X64_ACCESS_FREQUENCY_MSRS &&
 -		ms_hyperv.misc_features & HV_FEATURE_FREQUENCY_MSRS_AVAILABLE &&
 -		ms_hyperv.features & HV_X64_ACCESS_REENLIGHTENMENT;
 +	rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
 +	return current_tick;
  }
  
 -__visible void __irq_entry hyperv_reenlightenment_intr(struct pt_regs *regs)
 -{
 -	entering_ack_irq();
 -
 -	inc_irq_stat(irq_hv_reenlightenment_count);
 -
 -	schedule_delayed_work(&hv_reenlightenment_work, HZ/10);
 -
 -	exiting_irq();
 -}
 -
 -void set_hv_tscchange_cb(void (*cb)(void))
 -{
 -	struct hv_reenlightenment_control re_ctrl = {
 -		.vector = HYPERV_REENLIGHTENMENT_VECTOR,
 -		.enabled = 1,
 -		.target_vp = hv_vp_index[smp_processor_id()]
 -	};
 -	struct hv_tsc_emulation_control emu_ctrl = {.enabled = 1};
 -
 -	if (!hv_reenlightenment_available()) {
 -		pr_warn("Hyper-V: reenlightenment support is unavailable\n");
 -		return;
 -	}
 +static struct clocksource hyperv_cs_msr = {
 +	.name		= "hyperv_clocksource_msr",
 +	.rating		= 400,
 +	.read		= read_hv_clock_msr,
 +	.mask		= CLOCKSOURCE_MASK(64),
 +	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 +};
++=======
++#include <linux/kernel.h>
++#include <linux/cpuhotplug.h>
++#include <linux/syscore_ops.h>
++#include <clocksource/hyperv_timer.h>
++>>>>>>> f3a99e761efa (x86/Hyper-V: Report crash data in die() when panic_on_oops is set)
  
 -	hv_reenlightenment_cb = cb;
 +void *hv_hypercall_pg;
 +EXPORT_SYMBOL_GPL(hv_hypercall_pg);
 +struct clocksource *hyperv_cs;
 +EXPORT_SYMBOL_GPL(hyperv_cs);
  
 -	/* Make sure callback is registered before we write to MSRs */
 -	wmb();
 +u32 *hv_vp_index;
 +EXPORT_SYMBOL_GPL(hv_vp_index);
  
 -	wrmsrl(HV_X64_MSR_REENLIGHTENMENT_CONTROL, *((u64 *)&re_ctrl));
 -	wrmsrl(HV_X64_MSR_TSC_EMULATION_CONTROL, *((u64 *)&emu_ctrl));
 -}
 -EXPORT_SYMBOL_GPL(set_hv_tscchange_cb);
 +u32 hv_max_vp_index;
 +EXPORT_SYMBOL_GPL(hv_max_vp_index);
  
 -void clear_hv_tscchange_cb(void)
 +static void hv_cpu_init(void *arg)
  {
 -	struct hv_reenlightenment_control re_ctrl;
 +	u64 msr_vp_index;
  
 -	if (!hv_reenlightenment_available())
 -		return;
 +	hv_get_vp_index(msr_vp_index);
  
 -	rdmsrl(HV_X64_MSR_REENLIGHTENMENT_CONTROL, *(u64 *)&re_ctrl);
 -	re_ctrl.enabled = 0;
 -	wrmsrl(HV_X64_MSR_REENLIGHTENMENT_CONTROL, *(u64 *)&re_ctrl);
 +	hv_vp_index[smp_processor_id()] = msr_vp_index;
  
 -	hv_reenlightenment_cb = NULL;
 +	if (msr_vp_index > hv_max_vp_index)
 +		hv_max_vp_index = msr_vp_index;
  }
 -EXPORT_SYMBOL_GPL(clear_hv_tscchange_cb);
  
 -static int hv_cpu_die(unsigned int cpu)
 +/* RHEL-only: old CPUHP infrastructure */
 +static int hv_newcpu_cb(struct notifier_block *nfb,
 +			unsigned long action, void *hcpu)
  {
 -	struct hv_reenlightenment_control re_ctrl;
 -	unsigned int new_cpu;
 -	unsigned long flags;
 -	void **input_arg;
 -	void *input_pg = NULL;
 -
 -	local_irq_save(flags);
 -	input_arg = (void **)this_cpu_ptr(hyperv_pcpu_input_arg);
 -	input_pg = *input_arg;
 -	*input_arg = NULL;
 -	local_irq_restore(flags);
 -	free_page((unsigned long)input_pg);
 -
 -	if (hv_vp_assist_page && hv_vp_assist_page[cpu])
 -		wrmsrl(HV_X64_MSR_VP_ASSIST_PAGE, 0);
 -
 -	if (hv_reenlightenment_cb == NULL)
 -		return 0;
 -
 -	rdmsrl(HV_X64_MSR_REENLIGHTENMENT_CONTROL, *((u64 *)&re_ctrl));
 -	if (re_ctrl.target_vp == hv_vp_index[cpu]) {
 -		/* Reassign to some other online CPU */
 -		new_cpu = cpumask_any_but(cpu_online_mask, cpu);
 -
 -		re_ctrl.target_vp = hv_vp_index[new_cpu];
 -		wrmsrl(HV_X64_MSR_REENLIGHTENMENT_CONTROL, *((u64 *)&re_ctrl));
 +	switch (action & ~CPU_TASKS_FROZEN) {
 +	case CPU_STARTING:
 +		hv_cpu_init(hcpu);
 +		break;
 +	default:
 +		break;
  	}
  
 -	return 0;
 +	return NOTIFY_OK;
  }
  
 +static struct notifier_block hv_newcpu_notifier __refdata = {
 +       .notifier_call = hv_newcpu_cb,
 +       .priority = INT_MAX,
 +};
 +
  static int __init hv_pci_init(void)
  {
  	int gen2vm = efi_enabled(EFI_BOOT);
diff --cc drivers/hv/vmbus_drv.c
index 52302e715e84,a68bce4d0ddb..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -43,6 -31,9 +43,12 @@@
  #include <linux/kdebug.h>
  #include <linux/efi.h>
  #include <linux/random.h>
++<<<<<<< HEAD
++=======
+ #include <linux/kernel.h>
+ #include <linux/syscore_ops.h>
+ #include <clocksource/hyperv_timer.h>
++>>>>>>> f3a99e761efa (x86/Hyper-V: Report crash data in die() when panic_on_oops is set)
  #include "hyperv_vmbus.h"
  
  struct vmbus_dynid {
@@@ -60,9 -66,18 +66,22 @@@ static int hyperv_panic_event(struct no
  {
  	struct pt_regs *regs;
  
 -	vmbus_initiate_unload(true);
 +	regs = current_pt_regs();
  
++<<<<<<< HEAD
 +	hyperv_report_panic(regs, val);
++=======
+ 	/*
+ 	 * Hyper-V should be notified only once about a panic.  If we will be
+ 	 * doing hyperv_report_panic_msg() later with kmsg data, don't do
+ 	 * the notification here.
+ 	 */
+ 	if (ms_hyperv.misc_features & HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE
+ 	    && hyperv_report_reg()) {
+ 		regs = current_pt_regs();
+ 		hyperv_report_panic(regs, val, false);
+ 	}
++>>>>>>> f3a99e761efa (x86/Hyper-V: Report crash data in die() when panic_on_oops is set)
  	return NOTIFY_DONE;
  }
  
@@@ -72,7 -87,13 +91,17 @@@ static int hyperv_die_event(struct noti
  	struct die_args *die = (struct die_args *)args;
  	struct pt_regs *regs = die->regs;
  
++<<<<<<< HEAD
 +	hyperv_report_panic(regs, val);
++=======
+ 	/*
+ 	 * Hyper-V should be notified only once about a panic.  If we will be
+ 	 * doing hyperv_report_panic_msg() later with kmsg data, don't do
+ 	 * the notification here.
+ 	 */
+ 	if (hyperv_report_reg())
+ 		hyperv_report_panic(regs, val, true);
++>>>>>>> f3a99e761efa (x86/Hyper-V: Report crash data in die() when panic_on_oops is set)
  	return NOTIFY_DONE;
  }
  
* Unmerged path include/asm-generic/mshyperv.h
* Unmerged path arch/x86/hyperv/hv_init.c
* Unmerged path drivers/hv/vmbus_drv.c
* Unmerged path include/asm-generic/mshyperv.h
