nfs: remove nfs4_file_fsync

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 4ff79bc7098fab71e5957d48d31d2036c234e506
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/4ff79bc7.failed

The only difference to nfs_file_fsync is the call to pnfs_sync_inode.  But
pnfs_sync_inode is just an inline that calls a pNFS layout driver method
if CONFIG_PNFS is designed, and thus can be called just fine from the core
NFS module.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 4ff79bc7098fab71e5957d48d31d2036c234e506)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/file.c
#	fs/nfs/nfs4file.c
diff --cc fs/nfs/file.c
index 23d911115367,cdf862188618..000000000000
--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@@ -280,9 -277,11 +279,15 @@@ nfs_file_fsync(struct file *file, loff_
  		ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
  		if (ret != 0)
  			break;
 -		inode_lock(inode);
 +		mutex_lock(&inode->i_mutex);
  		ret = nfs_file_fsync_commit(file, start, end, datasync);
++<<<<<<< HEAD
 +		mutex_unlock(&inode->i_mutex);
++=======
+ 		if (!ret)
+ 			ret = pnfs_sync_inode(inode, !!datasync);
+ 		inode_unlock(inode);
++>>>>>>> 4ff79bc7098f (nfs: remove nfs4_file_fsync)
  		/*
  		 * If nfs_file_fsync_commit detected a server reboot, then
  		 * resend all dirty pages that might have been covered by
diff --cc fs/nfs/nfs4file.c
index 0b9f20bc0c2a,22c35abbee9d..000000000000
--- a/fs/nfs/nfs4file.c
+++ b/fs/nfs/nfs4file.c
@@@ -128,48 -128,7 +128,51 @@@ nfs4_file_flush(struct file *file, fl_o
  	return vfs_fsync(file, 0);
  }
  
++<<<<<<< HEAD
 +static int
 +nfs4_file_fsync(struct file *file, loff_t start, loff_t end, int datasync)
 +{
 +	int ret;
 +	struct inode *inode = file_inode(file);
 +
 +	trace_nfs_fsync_enter(inode);
 +
 +	nfs_inode_dio_wait(inode);
 +	do {
 +		ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
 +		if (ret != 0)
 +			break;
 +		mutex_lock(&inode->i_mutex);
 +		ret = nfs_file_fsync_commit(file, start, end, datasync);
 +		if (!ret)
 +			ret = pnfs_sync_inode(inode, !!datasync);
 +		mutex_unlock(&inode->i_mutex);
 +		/*
 +		 * If nfs_file_fsync_commit detected a server reboot, then
 +		 * resend all dirty pages that might have been covered by
 +		 * the NFS_CONTEXT_RESEND_WRITES flag
 +		 */
 +		start = 0;
 +		end = LLONG_MAX;
 +	} while (ret == -EAGAIN);
 +
 +	trace_nfs_fsync_exit(inode, ret);
 +	return ret;
 +}
 +
++=======
++>>>>>>> 4ff79bc7098f (nfs: remove nfs4_file_fsync)
  #ifdef CONFIG_NFS_V4_2
 +static ssize_t nfs4_copy_file_range(struct file *file_in, loff_t pos_in,
 +				    struct file *file_out, loff_t pos_out,
 +				    size_t count, unsigned int flags)
 +{
 +	if (file_inode(file_in) == file_inode(file_out))
 +		return -EINVAL;
 +
 +	return nfs42_proc_copy(file_in, pos_in, file_out, pos_out, count);
 +}
 +
  static loff_t nfs4_file_llseek(struct file *filep, loff_t offset, int whence)
  {
  	loff_t ret;
@@@ -269,30 -228,25 +272,47 @@@ out
  }
  #endif /* CONFIG_NFS_V4_2 */
  
++<<<<<<< HEAD
 +const struct file_operations_extend nfs4_file_operations = {
 +	.kabi_fops = {
 +		.read		= do_sync_read,
 +		.write		= do_sync_write,
 +		.aio_read	= nfs_file_read,
 +		.aio_write	= nfs_file_write,
 +		.mmap		= nfs_file_mmap,
 +		.open		= nfs4_file_open,
 +		.flush		= nfs4_file_flush,
 +		.release	= nfs_file_release,
 +		.fsync		= nfs4_file_fsync,
 +		.lock		= nfs_lock,
 +		.flock		= nfs_flock,
 +		.splice_read	= nfs_file_splice_read,
 +		.splice_write	= nfs_file_splice_write,
 +		.check_flags	= nfs_check_flags,
 +		.setlease	= nfs_setlease,
++=======
+ const struct file_operations nfs4_file_operations = {
+ 	.read_iter	= nfs_file_read,
+ 	.write_iter	= nfs_file_write,
+ 	.mmap		= nfs_file_mmap,
+ 	.open		= nfs4_file_open,
+ 	.flush		= nfs4_file_flush,
+ 	.release	= nfs_file_release,
+ 	.fsync		= nfs_file_fsync,
+ 	.lock		= nfs_lock,
+ 	.flock		= nfs_flock,
+ 	.splice_read	= nfs_file_splice_read,
+ 	.splice_write	= iter_file_splice_write,
+ 	.check_flags	= nfs_check_flags,
+ 	.setlease	= simple_nosetlease,
++>>>>>>> 4ff79bc7098f (nfs: remove nfs4_file_fsync)
  #ifdef CONFIG_NFS_V4_2
 -	.llseek		= nfs4_file_llseek,
 -	.fallocate	= nfs42_fallocate,
 -	.clone_file_range = nfs42_clone_file_range,
 +		.llseek		= nfs4_file_llseek,
 +		.fallocate	= nfs42_fallocate,
  #else
 -	.llseek		= nfs_file_llseek,
 +		.llseek		= nfs_file_llseek,
  #endif
 +	},
 +	.copy_file_range = nfs4_copy_file_range,
 +	.clone_file_range = nfs42_clone_file_range,
  };
* Unmerged path fs/nfs/file.c
diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 6b008712d54e..7a861f3b2013 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -362,7 +362,7 @@ int nfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);
 int nfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
 
 /* file.c */
-int nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);
+int nfs_file_fsync(struct file *file, loff_t start, loff_t end, int datasync);
 loff_t nfs_file_llseek(struct file *, loff_t, int);
 ssize_t nfs_file_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 ssize_t nfs_file_splice_read(struct file *, loff_t *, struct pipe_inode_info *,
* Unmerged path fs/nfs/nfs4file.c
