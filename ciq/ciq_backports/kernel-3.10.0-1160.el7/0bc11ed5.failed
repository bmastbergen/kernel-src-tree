kprobes: Allow kprobes coexist with livepatch

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Masami Hiramatsu <mhiramat@kernel.org>
commit 0bc11ed5ab60c135aa764a62c02cd5ea68289de4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/0bc11ed5.failed

Allow kprobes which do not modify regs->ip, coexist with livepatch
by dropping FTRACE_OPS_FL_IPMODIFY from ftrace_ops.

User who wants to modify regs->ip (e.g. function fault injection)
must set a dummy post_handler to its kprobes when registering.
However, if such regs->ip modifying kprobes is set on a function,
that function can not be livepatched.

Link: http://lkml.kernel.org/r/156403587671.30117.5233558741694155985.stgit@devnote2

	Acked-by: Joe Lawrence <joe.lawrence@redhat.com>
	Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit 0bc11ed5ab60c135aa764a62c02cd5ea68289de4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/kprobes.c
diff --cc kernel/kprobes.c
index 7f971d04c732,f57deec96ba1..000000000000
--- a/kernel/kprobes.c
+++ b/kernel/kprobes.c
@@@ -941,14 -983,15 +948,18 @@@ static int __kprobes prepare_kprobe(str
  }
  
  /* Caller must lock kprobe_mutex */
++<<<<<<< HEAD
 +static int __kprobes arm_kprobe_ftrace(struct kprobe *p)
++=======
+ static int __arm_kprobe_ftrace(struct kprobe *p, struct ftrace_ops *ops,
+ 			       int *cnt)
++>>>>>>> 0bc11ed5ab60 (kprobes: Allow kprobes coexist with livepatch)
  {
  	int ret = 0;
  
- 	ret = ftrace_set_filter_ip(&kprobe_ftrace_ops,
- 				   (unsigned long)p->addr, 0, 0);
+ 	ret = ftrace_set_filter_ip(ops, (unsigned long)p->addr, 0, 0);
  	if (ret) {
 -		pr_debug("Failed to arm kprobe-ftrace at %pS (%d)\n",
 -			 p->addr, ret);
 +		pr_debug("Failed to arm kprobe-ftrace at %p (%d)\n", p->addr, ret);
  		return ret;
  	}
  
@@@ -973,8 -1015,18 +983,22 @@@ err_ftrace
  	return ret;
  }
  
+ static int arm_kprobe_ftrace(struct kprobe *p)
+ {
+ 	bool ipmodify = (p->post_handler != NULL);
+ 
+ 	return __arm_kprobe_ftrace(p,
+ 		ipmodify ? &kprobe_ipmodify_ops : &kprobe_ftrace_ops,
+ 		ipmodify ? &kprobe_ipmodify_enabled : &kprobe_ftrace_enabled);
+ }
+ 
  /* Caller must lock kprobe_mutex */
++<<<<<<< HEAD
 +static int __kprobes disarm_kprobe_ftrace(struct kprobe *p)
++=======
+ static int __disarm_kprobe_ftrace(struct kprobe *p, struct ftrace_ops *ops,
+ 				  int *cnt)
++>>>>>>> 0bc11ed5ab60 (kprobes: Allow kprobes coexist with livepatch)
  {
  	int ret = 0;
  
@@@ -984,13 -1036,22 +1008,28 @@@
  			return ret;
  	}
  
- 	kprobe_ftrace_enabled--;
+ 	(*cnt)--;
  
++<<<<<<< HEAD
 +	ret = ftrace_set_filter_ip(&kprobe_ftrace_ops,
 +			   (unsigned long)p->addr, 1, 0);
 +	WARN(ret < 0, "Failed to disarm kprobe-ftrace at %p (%d)\n", p->addr, ret);
++=======
+ 	ret = ftrace_set_filter_ip(ops, (unsigned long)p->addr, 1, 0);
+ 	WARN_ONCE(ret < 0, "Failed to disarm kprobe-ftrace at %pS (%d)\n",
+ 		  p->addr, ret);
++>>>>>>> 0bc11ed5ab60 (kprobes: Allow kprobes coexist with livepatch)
  	return ret;
  }
+ 
+ static int disarm_kprobe_ftrace(struct kprobe *p)
+ {
+ 	bool ipmodify = (p->post_handler != NULL);
+ 
+ 	return __disarm_kprobe_ftrace(p,
+ 		ipmodify ? &kprobe_ipmodify_ops : &kprobe_ftrace_ops,
+ 		ipmodify ? &kprobe_ipmodify_enabled : &kprobe_ftrace_enabled);
+ }
  #else	/* !CONFIG_KPROBES_ON_FTRACE */
  #define prepare_kprobe(p)	arch_prepare_kprobe(p)
  #define arm_kprobe_ftrace(p)	(-ENODEV)
* Unmerged path kernel/kprobes.c
