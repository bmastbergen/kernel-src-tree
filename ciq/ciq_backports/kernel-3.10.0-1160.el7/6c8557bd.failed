smp, cpumask: Use non-atomic cpumask_{set,clear}_cpu()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
Rebuild_CHGLOG: - [kernel] smp, cpumask: Use non-atomic cpumask_{set, clear}_cpu() (Nitesh Narayan Lal) [1772082]
Rebuild_FUZZ: 99.08%
commit-author Peter Zijlstra <peterz@infradead.org>
commit 6c8557bdb28df3ae97476c5e2aed6373cd235aab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/6c8557bd.failed

The cpumasks in smp_call_function_many() are private and not subject
to concurrency, atomic bitops are pointless and expensive.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-kernel@vger.kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 6c8557bdb28df3ae97476c5e2aed6373cd235aab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/smp.c
diff --cc kernel/smp.c
index 3150b5af3117,3061483cb3ad..000000000000
--- a/kernel/smp.c
+++ b/kernel/smp.c
@@@ -420,10 -433,10 +420,10 @@@ void smp_call_function_many(const struc
  		return;
  	}
  
 -	cfd = this_cpu_ptr(&cfd_data);
 +	cfd = &__get_cpu_var(cfd_data);
  
  	cpumask_and(cfd->cpumask, mask, cpu_online_mask);
- 	cpumask_clear_cpu(this_cpu, cfd->cpumask);
+ 	__cpumask_clear_cpu(this_cpu, cfd->cpumask);
  
  	/* Some callers race with other cpus changing the passed mask */
  	if (unlikely(!cpumask_weight(cfd->cpumask)))
@@@ -433,9 -447,12 +433,14 @@@
  		struct call_single_data *csd = per_cpu_ptr(cfd->csd, cpu);
  
  		csd_lock(csd);
 -		if (wait)
 -			csd->flags |= CSD_FLAG_SYNCHRONOUS;
  		csd->func = func;
  		csd->info = info;
++<<<<<<< HEAD
 +		llist_add(&csd->llist, &per_cpu(call_single_queue, cpu));
++=======
+ 		if (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu)))
+ 			__cpumask_set_cpu(cpu, cfd->cpumask_ipi);
++>>>>>>> 6c8557bdb28d (smp, cpumask: Use non-atomic cpumask_{set,clear}_cpu())
  	}
  
  	/* Send a message to all CPUs in the map */
diff --git a/include/linux/cpumask.h b/include/linux/cpumask.h
index b6b72ce417d6..f5a5a3060292 100644
--- a/include/linux/cpumask.h
+++ b/include/linux/cpumask.h
@@ -288,6 +288,12 @@ static inline void cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)
 	set_bit(cpumask_check(cpu), cpumask_bits(dstp));
 }
 
+static inline void __cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)
+{
+	__set_bit(cpumask_check(cpu), cpumask_bits(dstp));
+}
+
+
 /**
  * cpumask_clear_cpu - clear a cpu in a cpumask
  * @cpu: cpu number (< nr_cpu_ids)
@@ -298,6 +304,11 @@ static inline void cpumask_clear_cpu(int cpu, struct cpumask *dstp)
 	clear_bit(cpumask_check(cpu), cpumask_bits(dstp));
 }
 
+static inline void __cpumask_clear_cpu(int cpu, struct cpumask *dstp)
+{
+	__clear_bit(cpumask_check(cpu), cpumask_bits(dstp));
+}
+
 /**
  * cpumask_test_cpu - test for a cpu in a cpumask
  * @cpu: cpu number (< nr_cpu_ids)
* Unmerged path kernel/smp.c
