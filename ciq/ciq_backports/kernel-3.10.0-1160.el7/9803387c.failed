ext4: validate the debug_want_extra_isize mount option at parse time

jira LE-1907
cve CVE-2019-19767
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit 9803387c55f7d2ce69aa64340c5fdc6b3027dbc8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/9803387c.failed

Instead of setting s_want_extra_size and then making sure that it is a
valid value afterwards, validate the field before we set it.  This
avoids races and other problems when remounting the file system.

Link: https://lore.kernel.org/r/20191215063020.GA11512@mit.edu
	Cc: stable@kernel.org
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Reported-and-tested-by: syzbot+4a39a025912b265cacef@syzkaller.appspotmail.com
(cherry picked from commit 9803387c55f7d2ce69aa64340c5fdc6b3027dbc8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/super.c
diff --cc fs/ext4/super.c
index 417c0071ce41,46b6d5b150ac..000000000000
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@@ -1561,7 -1877,23 +1561,19 @@@ static int handle_mount_opt(struct supe
  	} else if (token == Opt_commit) {
  		if (arg == 0)
  			arg = JBD2_DEFAULT_MAX_COMMIT_AGE;
 -		else if (arg > INT_MAX / HZ) {
 -			ext4_msg(sb, KERN_ERR,
 -				 "Invalid commit interval %d, "
 -				 "must be smaller than %d",
 -				 arg, INT_MAX / HZ);
 -			return -1;
 -		}
  		sbi->s_commit_interval = HZ * arg;
++<<<<<<< HEAD
++=======
+ 	} else if (token == Opt_debug_want_extra_isize) {
+ 		if ((arg & 1) ||
+ 		    (arg < 4) ||
+ 		    (arg > (sbi->s_inode_size - EXT4_GOOD_OLD_INODE_SIZE))) {
+ 			ext4_msg(sb, KERN_ERR,
+ 				 "Invalid want_extra_isize %d", arg);
+ 			return -1;
+ 		}
+ 		sbi->s_want_extra_isize = arg;
++>>>>>>> 9803387c55f7 (ext4: validate the debug_want_extra_isize mount option at parse time)
  	} else if (token == Opt_max_batch_time) {
  		sbi->s_max_batch_time = arg;
  	} else if (token == Opt_min_batch_time) {
@@@ -3517,10 -3547,10 +3529,14 @@@ int ext4_calculate_overhead(struct supe
  	return 0;
  }
  
++<<<<<<< HEAD
 +
 +static ext4_fsblk_t ext4_calculate_resv_clusters(struct super_block *sb)
++=======
+ static void ext4_set_resv_clusters(struct super_block *sb)
++>>>>>>> 9803387c55f7 (ext4: validate the debug_want_extra_isize mount option at parse time)
  {
  	ext4_fsblk_t resv_clusters;
 -	struct ext4_sb_info *sbi = EXT4_SB(sb);
  
  	/*
  	 * There's no need to reserve anything when we aren't using extents.
@@@ -3915,31 -4054,8 +3993,34 @@@ static int ext4_fill_super(struct super
  						      has_huge_files);
  	sb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);
  
++<<<<<<< HEAD
 +	if (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {
 +		sbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;
 +		sbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;
 +	} else {
 +		sbi->s_inode_size = le16_to_cpu(es->s_inode_size);
 +		sbi->s_first_ino = le32_to_cpu(es->s_first_ino);
 +		if (sbi->s_first_ino < EXT4_GOOD_OLD_FIRST_INO) {
 +			ext4_msg(sb, KERN_ERR, "invalid first ino: %u",
 +				 sbi->s_first_ino);
 +			goto failed_mount;
 +		}
 +		if ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||
 +		    (!is_power_of_2(sbi->s_inode_size)) ||
 +		    (sbi->s_inode_size > blocksize)) {
 +			ext4_msg(sb, KERN_ERR,
 +			       "unsupported inode size: %d",
 +			       sbi->s_inode_size);
 +			goto failed_mount;
 +		}
 +		if (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)
 +			sb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);
 +	}
 +
++=======
++>>>>>>> 9803387c55f7 (ext4: validate the debug_want_extra_isize mount option at parse time)
  	sbi->s_desc_size = le16_to_cpu(es->s_desc_size);
 -	if (ext4_has_feature_64bit(sb)) {
 +	if (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT)) {
  		if (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||
  		    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||
  		    !is_power_of_2(sbi->s_desc_size)) {
@@@ -4321,40 -4495,14 +4402,45 @@@ no_journal
  		goto failed_mount4;
  	}
  
 -	ret = ext4_setup_super(sb, es, sb_rdonly(sb));
 -	if (ret == -EROFS) {
 -		sb->s_flags |= SB_RDONLY;
 -		ret = 0;
 -	} else if (ret)
 +	if (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))
 +		sb->s_flags |= MS_RDONLY;
 +
 +	/* determine the minimum size of new large inodes, if present */
 +	if (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {
 +		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
 +						     EXT4_GOOD_OLD_INODE_SIZE;
 +		if (EXT4_HAS_RO_COMPAT_FEATURE(sb,
 +				       EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE)) {
 +			if (sbi->s_want_extra_isize <
 +			    le16_to_cpu(es->s_want_extra_isize))
 +				sbi->s_want_extra_isize =
 +					le16_to_cpu(es->s_want_extra_isize);
 +			if (sbi->s_want_extra_isize <
 +			    le16_to_cpu(es->s_min_extra_isize))
 +				sbi->s_want_extra_isize =
 +					le16_to_cpu(es->s_min_extra_isize);
 +		}
 +	}
 +	/* Check if enough inode space is available */
 +	if (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >
 +							sbi->s_inode_size) {
 +		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
 +						       EXT4_GOOD_OLD_INODE_SIZE;
 +		ext4_msg(sb, KERN_INFO, "required extra inode space not"
 +			 "available");
 +	}
 +
 +	err = ext4_reserve_clusters(sbi, ext4_calculate_resv_clusters(sb));
 +	if (err) {
 +		ext4_msg(sb, KERN_ERR, "failed to reserve %llu clusters for "
 +			 "reserved pool", ext4_calculate_resv_clusters(sb));
  		goto failed_mount4a;
++<<<<<<< HEAD
 +	}
++=======
+ 
+ 	ext4_set_resv_clusters(sb);
++>>>>>>> 9803387c55f7 (ext4: validate the debug_want_extra_isize mount option at parse time)
  
  	err = ext4_setup_system_zone(sb);
  	if (err) {
* Unmerged path fs/ext4/super.c
