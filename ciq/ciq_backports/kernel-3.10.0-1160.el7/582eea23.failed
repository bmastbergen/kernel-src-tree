sctp: fix possibly using a bad saddr with a given dst

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
commit 582eea230536a6f104097dd46205822005d5fe3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/582eea23.failed

Under certain circumstances, depending on the order of addresses on the
interfaces, it could be that sctp_v[46]_get_dst() would return a dst
with a mismatched struct flowi.

For example, if when walking through the bind addresses and the first
one is not a match, it saves the dst as a fallback (added in
410f03831c07), but not the flowi. Then if the next one is also not a
match, the previous dst will be returned but with the flowi information
for the 2nd address, which is wrong.

The fix is to use a locally stored flowi that can be used for such
attempts, and copy it to the parameter only in case it is a possible
match, together with the corresponding dst entry.

The patch updates IPv6 code mostly just to be in sync. Even though the issue
is also present there, it fallback is not expected to work with IPv6.

Fixes: 410f03831c07 ("sctp: add routing output fallback")
	Reported-by: Jin Meng <meng.a.jin@nokia-sbell.com>
	Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Tested-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 582eea230536a6f104097dd46205822005d5fe3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/ipv6.c
#	net/sctp/protocol.c
diff --cc net/sctp/ipv6.c
index 994f6f415246,c87af430107a..000000000000
--- a/net/sctp/ipv6.c
+++ b/net/sctp/ipv6.c
@@@ -249,10 -236,10 +250,10 @@@ static void sctp_v6_get_dst(struct sctp
  	union sctp_addr *daddr = &t->ipaddr;
  	union sctp_addr dst_saddr;
  	struct in6_addr *final_p, final;
 -	enum sctp_scope scope;
  	__u8 matchlen = 0;
 +	sctp_scope_t scope;
  
- 	memset(fl6, 0, sizeof(struct flowi6));
+ 	memset(&_fl, 0, sizeof(_fl));
  	fl6->daddr = daddr->v6.sin6_addr;
  	fl6->fl6_dport = daddr->v6.sin6_port;
  	fl6->flowi6_proto = IPPROTO_SCTP;
@@@ -277,9 -276,12 +278,17 @@@
  	final_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);
  	rcu_read_unlock();
  
++<<<<<<< HEAD
 +	dst = ip6_dst_lookup_flow(sk, fl6, final_p);
 +	if (!asoc || saddr)
++=======
+ 	dst = ip6_dst_lookup_flow(sock_net(sk), sk, fl6, final_p);
+ 	if (!asoc || saddr) {
+ 		t->dst = dst;
+ 		memcpy(fl, &_fl, sizeof(_fl));
++>>>>>>> 582eea230536 (sctp: fix possibly using a bad saddr with a given dst)
  		goto out;
+ 	}
  
  	bp = &asoc->base.bind_addr;
  	scope = sctp_scope(daddr);
diff --cc net/sctp/protocol.c
index c3742e6354eb,092d1afdee0d..000000000000
--- a/net/sctp/protocol.c
+++ b/net/sctp/protocol.c
@@@ -448,8 -416,11 +449,14 @@@ static void sctp_v4_get_dst(struct sctp
  	struct dst_entry *dst = NULL;
  	union sctp_addr *daddr = &t->ipaddr;
  	union sctp_addr dst_saddr;
 -	__u8 tos = inet_sk(sk)->tos;
  
++<<<<<<< HEAD
 +	memset(fl4, 0x0, sizeof(struct flowi4));
++=======
+ 	if (t->dscp & SCTP_DSCP_SET_MASK)
+ 		tos = t->dscp & SCTP_DSCP_VAL_MASK;
+ 	memset(&_fl, 0x0, sizeof(_fl));
++>>>>>>> 582eea230536 (sctp: fix possibly using a bad saddr with a given dst)
  	fl4->daddr  = daddr->v4.sin_addr.s_addr;
  	fl4->fl4_dport = daddr->v4.sin_port;
  	fl4->flowi4_proto = IPPROTO_SCTP;
* Unmerged path net/sctp/ipv6.c
* Unmerged path net/sctp/protocol.c
