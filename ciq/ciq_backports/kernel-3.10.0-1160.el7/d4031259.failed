gfs2: Minor gfs2_alloc_inode cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit d40312598d534c17c17f41c2bb7ce9541a5f786e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/d4031259.failed

In gfs2_alloc_inode, when kmem_cache_alloc cannot allocate a new object, return
NULL immediately.  The code currently relies on the fact that i_inode is the
first member in struct gfs2_inode and so ip and &ip->i_inode evaluate to the
same address, but that isn't immediately obvious.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Reviewed-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit d40312598d534c17c17f41c2bb7ce9541a5f786e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/super.c
diff --cc fs/gfs2/super.c
index 6327156ef20f,644c70ae09f7..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1673,14 -1722,13 +1673,24 @@@ static struct inode *gfs2_alloc_inode(s
  	struct gfs2_inode *ip;
  
  	ip = kmem_cache_alloc(gfs2_inode_cachep, GFP_KERNEL);
++<<<<<<< HEAD
 +	if (ip) {
 +		ip->i_flags = 0;
 +		ip->i_gl = NULL;
 +		ip->i_rgd = NULL;
 +		memset(&ip->i_res, 0, sizeof(ip->i_res));
 +		RB_CLEAR_NODE(&ip->i_res.rs_node);
 +		ip->i_rahead = 0;
 +	}
++=======
+ 	if (!ip)
+ 		return NULL;
+ 	ip->i_flags = 0;
+ 	ip->i_gl = NULL;
+ 	memset(&ip->i_res, 0, sizeof(ip->i_res));
+ 	RB_CLEAR_NODE(&ip->i_res.rs_node);
+ 	ip->i_rahead = 0;
++>>>>>>> d40312598d53 (gfs2: Minor gfs2_alloc_inode cleanup)
  	return &ip->i_inode;
  }
  
* Unmerged path fs/gfs2/super.c
