powerpc64/ftrace: Delay enabling ftrace on secondary cpus

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
commit d103978636c27fce216bbc8bb289981047b71bd4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/d1039786.failed

On the boot cpu, though we enable paca->ftrace_enabled in early_setup()
(via cpu_ready_for_interrupts()), we don't start tracing until much
later since ftrace is not initialized yet and since we only support
DYNAMIC_FTRACE on powerpc. However, it is possible that ftrace has been
initialized by the time some of the secondary cpus start up. In this
case, we will try to trace some of the early boot code which can cause
problems.

To address this, move setting paca->ftrace_enabled from
cpu_ready_for_interrupts() to early_setup() for the boot cpu, and towards
the end of start_secondary() for secondary cpus.

	Signed-off-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit d103978636c27fce216bbc8bb289981047b71bd4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/setup_64.c
#	arch/powerpc/kernel/smp.c
diff --cc arch/powerpc/kernel/setup_64.c
index 77d750687707,7a7ce8ad455e..000000000000
--- a/arch/powerpc/kernel/setup_64.c
+++ b/arch/powerpc/kernel/setup_64.c
@@@ -177,6 -240,26 +177,29 @@@ static void cpu_ready_for_interrupts(vo
  		unsigned long lpcr = mfspr(SPRN_LPCR);
  		mtspr(SPRN_LPCR, lpcr | LPCR_AIL_3);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * Fixup HFSCR:TM based on CPU features. The bit is set by our
+ 	 * early asm init because at that point we haven't updated our
+ 	 * CPU features from firmware and device-tree. Here we have,
+ 	 * so let's do it.
+ 	 */
+ 	if (cpu_has_feature(CPU_FTR_HVMODE) && !cpu_has_feature(CPU_FTR_TM_COMP))
+ 		mtspr(SPRN_HFSCR, mfspr(SPRN_HFSCR) & ~HFSCR_TM);
+ 
+ 	/* Set IR and DR in PACA MSR */
+ 	get_paca()->kernel_msr = MSR_KERNEL;
+ }
+ 
+ unsigned long spr_default_dscr = 0;
+ 
+ void __init record_spr_defaults(void)
+ {
+ 	if (early_cpu_has_feature(CPU_FTR_DSCR))
+ 		spr_default_dscr = mfspr(SPRN_DSCR);
++>>>>>>> d103978636c2 (powerpc64/ftrace: Delay enabling ftrace on secondary cpus)
  }
  
  /*
@@@ -250,17 -346,26 +273,28 @@@ void __init early_setup(unsigned long d
  	 */
  	cpu_ready_for_interrupts();
  
++<<<<<<< HEAD
 +	/* Reserve large chunks of memory for use by CMA for KVM */
 +	kvm_cma_reserve();
++=======
+ 	/*
+ 	 * We enable ftrace here, but since we only support DYNAMIC_FTRACE, it
+ 	 * will only actually get enabled on the boot cpu much later once
+ 	 * ftrace itself has been initialized.
+ 	 */
+ 	this_cpu_enable_ftrace();
+ 
+ 	DBG(" <- early_setup()\n");
++>>>>>>> d103978636c2 (powerpc64/ftrace: Delay enabling ftrace on secondary cpus)
  
 -#ifdef CONFIG_PPC_EARLY_DEBUG_BOOTX
  	/*
 -	 * This needs to be done *last* (after the above DBG() even)
 -	 *
 -	 * Right after we return from this function, we turn on the MMU
 -	 * which means the real-mode access trick that btext does will
 -	 * no longer work, it needs to switch to using a real MMU
 -	 * mapping. This call will ensure that it does
 +	 * Reserve any gigantic pages requested on the command line.
 +	 * memblock needs to have been initialized by the time this is
 +	 * called since this will reserve memory.
  	 */
 -	btext_map();
 -#endif /* CONFIG_PPC_EARLY_DEBUG_BOOTX */
 +	reserve_hugetlb_gpages();
 +
 +	DBG(" <- early_setup()\n");
  }
  
  #ifdef CONFIG_SMP
diff --cc arch/powerpc/kernel/smp.c
index f6ba171311af,9e711cdbe384..000000000000
--- a/arch/powerpc/kernel/smp.c
+++ b/arch/powerpc/kernel/smp.c
@@@ -54,6 -58,8 +54,11 @@@
  #include <asm/debug.h>
  #include <asm/kexec.h>
  #include <asm/asm-prototypes.h>
++<<<<<<< HEAD
++=======
+ #include <asm/cpu_has_feature.h>
+ #include <asm/ftrace.h>
++>>>>>>> d103978636c2 (powerpc64/ftrace: Delay enabling ftrace on secondary cpus)
  
  #ifdef DEBUG
  #include <asm/udbg.h>
@@@ -761,7 -1067,10 +766,14 @@@ void start_secondary(void *unused
  
  	local_irq_enable();
  
++<<<<<<< HEAD
 +	cpu_startup_entry(CPUHP_ONLINE);
++=======
+ 	/* We can enable ftrace for secondary cpus now */
+ 	this_cpu_enable_ftrace();
+ 
+ 	cpu_startup_entry(CPUHP_AP_ONLINE_IDLE);
++>>>>>>> d103978636c2 (powerpc64/ftrace: Delay enabling ftrace on secondary cpus)
  
  	BUG();
  }
* Unmerged path arch/powerpc/kernel/setup_64.c
* Unmerged path arch/powerpc/kernel/smp.c
