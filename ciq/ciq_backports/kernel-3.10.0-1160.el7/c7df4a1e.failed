ext4: work around deleting a file with i_nlink == 0 safely

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit c7df4a1ecb8579838ec8c56b2bb6a6716e974f37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/c7df4a1e.failed

If the file system is corrupted such that a file's i_links_count is
too small, then it's possible that when unlinking that file, i_nlink
will already be zero.  Previously we were working around this kind of
corruption by forcing i_nlink to one; but we were doing this before
trying to delete the directory entry --- and if the file system is
corrupted enough that ext4_delete_entry() fails, then we exit with
i_nlink elevated, and this causes the orphan inode list handling to be
FUBAR'ed, such that when we unmount the file system, the orphan inode
list can get corrupted.

A better way to fix this is to simply skip trying to call drop_nlink()
if i_nlink is already zero, thus moving the check to the place where
it makes the most sense.

https://bugzilla.kernel.org/show_bug.cgi?id=205433

Link: https://lore.kernel.org/r/20191112032903.8828-1-tytso@mit.edu
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: stable@kernel.org
	Reviewed-by: Andreas Dilger <adilger@dilger.ca>
(cherry picked from commit c7df4a1ecb8579838ec8c56b2bb6a6716e974f37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/namei.c
diff --cc fs/ext4/namei.c
index 573b87e45f75,a856997d87b5..000000000000
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@@ -2830,24 -3196,33 +2830,31 @@@ static int ext4_unlink(struct inode *di
  	if (IS_DIRSYNC(dir))
  		ext4_handle_sync(handle);
  
++<<<<<<< HEAD
 +	if (!inode->i_nlink) {
 +		ext4_warning(inode->i_sb,
 +			     "Deleting nonexistent file (%lu), %d",
 +			     inode->i_ino, inode->i_nlink);
 +		set_nlink(inode, 1);
 +	}
++=======
++>>>>>>> c7df4a1ecb85 (ext4: work around deleting a file with i_nlink == 0 safely)
  	retval = ext4_delete_entry(handle, dir, de, bh);
  	if (retval)
  		goto end_unlink;
 -	dir->i_ctime = dir->i_mtime = current_time(dir);
 +	dir->i_ctime = dir->i_mtime = ext4_current_time(dir);
  	ext4_update_dx_flag(dir);
  	ext4_mark_inode_dirty(handle, dir);
- 	drop_nlink(inode);
+ 	if (inode->i_nlink == 0)
+ 		ext4_warning_inode(inode, "Deleting file '%.*s' with no links",
+ 				   dentry->d_name.len, dentry->d_name.name);
+ 	else
+ 		drop_nlink(inode);
  	if (!inode->i_nlink)
  		ext4_orphan_add(handle, inode);
 -	inode->i_ctime = current_time(inode);
 +	inode->i_ctime = ext4_current_time(inode);
  	ext4_mark_inode_dirty(handle, inode);
  
 -#ifdef CONFIG_UNICODE
 -	/* VFS negative dentries are incompatible with Encoding and
 -	 * Case-insensitiveness. Eventually we'll want avoid
 -	 * invalidating the dentries here, alongside with returning the
 -	 * negative dentries at ext4_lookup(), when it is  better
 -	 * supported by the VFS for the CI case.
 -	 */
 -	if (IS_CASEFOLDED(dir))
 -		d_invalidate(dentry);
 -#endif
 -
  end_unlink:
  	brelse(bh);
  	if (handle)
* Unmerged path fs/ext4/namei.c
