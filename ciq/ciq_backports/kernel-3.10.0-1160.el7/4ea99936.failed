ext4: add more paranoia checking in ext4_expand_extra_isize handling

jira LE-1907
cve CVE-2019-19767
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit 4ea99936a1630f51fc3a2d61a58ec4a1c4b7d55a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/4ea99936.failed

It's possible to specify a non-zero s_want_extra_isize via debugging
option, and this can cause bad things(tm) to happen when using a file
system with an inode size of 128 bytes.

Add better checking when the file system is mounted, as well as when
we are actually doing the trying to do the inode expansion.

Link: https://lore.kernel.org/r/20191110121510.GH23325@mit.edu
	Reported-by: syzbot+f8d6f8386ceacdbfff57@syzkaller.appspotmail.com
	Reported-by: syzbot+33d7ea72e47de3bdf4e1@syzkaller.appspotmail.com
	Reported-by: syzbot+44b6763edfc17144296f@syzkaller.appspotmail.com
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: stable@kernel.org
(cherry picked from commit 4ea99936a1630f51fc3a2d61a58ec4a1c4b7d55a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/inode.c
#	fs/ext4/super.c
diff --cc fs/ext4/inode.c
index 8274eb8296d4,c6e3fe287b50..000000000000
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@@ -5264,11 -5569,24 +5264,32 @@@ static int ext4_expand_extra_isize(stru
  {
  	struct ext4_inode *raw_inode;
  	struct ext4_xattr_ibody_header *header;
++<<<<<<< HEAD
 +
 +	if (EXT4_I(inode)->i_extra_isize >= new_extra_isize)
 +		return 0;
 +
 +	raw_inode = ext4_raw_inode(&iloc);
++=======
+ 	unsigned int inode_size = EXT4_INODE_SIZE(inode->i_sb);
+ 	struct ext4_inode_info *ei = EXT4_I(inode);
+ 	int error;
+ 
+ 	/* this was checked at iget time, but double check for good measure */
+ 	if ((EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize > inode_size) ||
+ 	    (ei->i_extra_isize & 3)) {
+ 		EXT4_ERROR_INODE(inode, "bad extra_isize %u (inode size %u)",
+ 				 ei->i_extra_isize,
+ 				 EXT4_INODE_SIZE(inode->i_sb));
+ 		return -EFSCORRUPTED;
+ 	}
+ 	if ((new_extra_isize < ei->i_extra_isize) ||
+ 	    (new_extra_isize < 4) ||
+ 	    (new_extra_isize > inode_size - EXT4_GOOD_OLD_INODE_SIZE))
+ 		return -EINVAL;	/* Should never happen */
+ 
+ 	raw_inode = ext4_raw_inode(iloc);
++>>>>>>> 4ea99936a163 (ext4: add more paranoia checking in ext4_expand_extra_isize handling)
  
  	header = IHDR(inode, raw_inode);
  
diff --cc fs/ext4/super.c
index 417c0071ce41,71af8780d4ee..000000000000
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@@ -3517,10 -3541,44 +3517,48 @@@ int ext4_calculate_overhead(struct supe
  	return 0;
  }
  
++<<<<<<< HEAD
 +
 +static ext4_fsblk_t ext4_calculate_resv_clusters(struct super_block *sb)
++=======
+ static void ext4_clamp_want_extra_isize(struct super_block *sb)
+ {
+ 	struct ext4_sb_info *sbi = EXT4_SB(sb);
+ 	struct ext4_super_block *es = sbi->s_es;
+ 	unsigned def_extra_isize = sizeof(struct ext4_inode) -
+ 						EXT4_GOOD_OLD_INODE_SIZE;
+ 
+ 	if (sbi->s_inode_size == EXT4_GOOD_OLD_INODE_SIZE) {
+ 		sbi->s_want_extra_isize = 0;
+ 		return;
+ 	}
+ 	if (sbi->s_want_extra_isize < 4) {
+ 		sbi->s_want_extra_isize = def_extra_isize;
+ 		if (ext4_has_feature_extra_isize(sb)) {
+ 			if (sbi->s_want_extra_isize <
+ 			    le16_to_cpu(es->s_want_extra_isize))
+ 				sbi->s_want_extra_isize =
+ 					le16_to_cpu(es->s_want_extra_isize);
+ 			if (sbi->s_want_extra_isize <
+ 			    le16_to_cpu(es->s_min_extra_isize))
+ 				sbi->s_want_extra_isize =
+ 					le16_to_cpu(es->s_min_extra_isize);
+ 		}
+ 	}
+ 	/* Check if enough inode space is available */
+ 	if ((sbi->s_want_extra_isize > sbi->s_inode_size) ||
+ 	    (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >
+ 							sbi->s_inode_size)) {
+ 		sbi->s_want_extra_isize = def_extra_isize;
+ 		ext4_msg(sb, KERN_INFO,
+ 			 "required extra inode space not available");
+ 	}
+ }
+ 
+ static void ext4_set_resv_clusters(struct super_block *sb)
++>>>>>>> 4ea99936a163 (ext4: add more paranoia checking in ext4_expand_extra_isize handling)
  {
  	ext4_fsblk_t resv_clusters;
 -	struct ext4_sb_info *sbi = EXT4_SB(sb);
  
  	/*
  	 * There's no need to reserve anything when we aren't using extents.
* Unmerged path fs/ext4/inode.c
* Unmerged path fs/ext4/super.c
