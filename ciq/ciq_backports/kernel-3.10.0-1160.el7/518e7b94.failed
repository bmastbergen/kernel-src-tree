KVM: X86: Allow userspace to define the microcode version

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Wanpeng Li <wanpengli@tencent.com>
commit 518e7b94817abed94becfe6a44f1ece0d4745afe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/518e7b94.failed

Linux (among the others) has checks to make sure that certain features
aren't enabled on a certain family/model/stepping if the microcode version
isn't greater than or equal to a known good version.

By exposing the real microcode version, we're preventing buggy guests that
don't check that they are running virtualized (i.e., they should trust the
hypervisor) from disabling features that are effectively not buggy.

	Suggested-by: Filippo Sironi <sironi@amazon.de>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Cc: Liran Alon <liran.alon@oracle.com>
	Cc: Nadav Amit <nadav.amit@gmail.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: Wanpeng Li <wanpengli@tencent.com>
	Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit 518e7b94817abed94becfe6a44f1ece0d4745afe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/svm.c
#	arch/x86/kvm/vmx.c
#	arch/x86/kvm/x86.c
diff --cc arch/x86/include/asm/kvm_host.h
index b6317f3d615e,b605a5b6a30c..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -526,8 -504,10 +526,13 @@@ struct kvm_vcpu_arch 
  	int mp_state;
  	u64 ia32_misc_enable_msr;
  	u64 smbase;
 -	u64 smi_count;
  	bool tpr_access_reporting;
++<<<<<<< HEAD
 +	u64 arch_capabilities;
++=======
+ 	u64 ia32_xss;
+ 	u64 microcode_version;
++>>>>>>> 518e7b94817a (KVM: X86: Allow userspace to define the microcode version)
  
  	/*
  	 * Paging state of the vcpu
diff --cc arch/x86/kvm/svm.c
index abee2f094107,312f33f4ed36..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -1727,7 -1907,9 +1727,13 @@@ static void svm_vcpu_reset(struct kvm_v
  	u32 dummy;
  	u32 eax = 1;
  
++<<<<<<< HEAD
 +	svm->virt_spec_ctrl = 0;
++=======
+ 	vcpu->arch.microcode_version = 0x01000065;
+ 	svm->spec_ctrl = 0;
+ 
++>>>>>>> 518e7b94817a (KVM: X86: Allow userspace to define the microcode version)
  	if (!init_event) {
  		svm->vcpu.arch.apic_base = APIC_DEFAULT_PHYS_BASE |
  					   MSR_IA32_APICBASE_ENABLE;
@@@ -3780,17 -3957,31 +3786,39 @@@ static int svm_get_msr(struct kvm_vcpu 
  		msr_info->data = svm->nested.vm_cr_msr;
  		break;
  	case MSR_IA32_SPEC_CTRL:
 +		msr_info->data = svm->spec_ctrl;
 +		break;
 +	case MSR_AMD64_VIRT_SPEC_CTRL:
  		if (!msr_info->host_initiated &&
 -		    !guest_cpuid_has(vcpu, X86_FEATURE_IBRS))
 +		    !guest_cpuid_has(vcpu, X86_FEATURE_VIRT_SSBD))
  			return 1;
  
 -		msr_info->data = svm->spec_ctrl;
 +		msr_info->data = svm->virt_spec_ctrl;
  		break;
++<<<<<<< HEAD
 +	case MSR_IA32_UCODE_REV:
 +		msr_info->data = 0x01000065;
++=======
+ 	case MSR_F15H_IC_CFG: {
+ 
+ 		int family, model;
+ 
+ 		family = guest_cpuid_family(vcpu);
+ 		model  = guest_cpuid_model(vcpu);
+ 
+ 		if (family < 0 || model < 0)
+ 			return kvm_get_msr_common(vcpu, msr_info);
+ 
+ 		msr_info->data = 0;
+ 
+ 		if (family == 0x15 &&
+ 		    (model >= 0x2 && model < 0x20))
+ 			msr_info->data = 0x1E;
+ 		}
+ 		break;
+ 	case MSR_F10H_DECFG:
+ 		msr_info->data = svm->msr_decfg;
++>>>>>>> 518e7b94817a (KVM: X86: Allow userspace to define the microcode version)
  		break;
  	default:
  		return kvm_get_msr_common(vcpu, msr_info);
diff --cc arch/x86/kvm/vmx.c
index f0c4334a97d9,591214843046..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -5619,8 -5771,7 +5619,12 @@@ static void vmx_vcpu_reset(struct kvm_v
  	vmx->rmode.vm86_active = 0;
  	vmx->spec_ctrl = 0;
  
++<<<<<<< HEAD
 +	vmx->soft_vnmi_blocked = 0;
 +
++=======
+ 	vcpu->arch.microcode_version = 0x100000000ULL;
++>>>>>>> 518e7b94817a (KVM: X86: Allow userspace to define the microcode version)
  	vmx->vcpu.arch.regs[VCPU_REGS_RDX] = get_rdx_init_val();
  	kvm_set_cr8(vcpu, 0);
  
diff --cc arch/x86/kvm/x86.c
index 8137675c477b,11649d290b93..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -1048,7 -1054,8 +1048,12 @@@ static unsigned num_emulated_msrs
   * can be used by a hypervisor to validate requested CPU features.
   */
  static u32 msr_based_features[] = {
++<<<<<<< HEAD
 +	MSR_IA32_ARCH_CAPABILITIES,
++=======
+ 	MSR_F10H_DECFG,
+ 	MSR_IA32_UCODE_REV,
++>>>>>>> 518e7b94817a (KVM: X86: Allow userspace to define the microcode version)
  };
  
  static unsigned int num_msr_based_features;
@@@ -1097,8 -1063,8 +1102,13 @@@ EXPORT_SYMBOL_GPL(kvm_get_arch_capabili
  static int kvm_get_msr_feature(struct kvm_msr_entry *msr)
  {
  	switch (msr->index) {
++<<<<<<< HEAD
 +	case MSR_IA32_ARCH_CAPABILITIES:
 +		msr->data = kvm_get_arch_capabilities();
++=======
+ 	case MSR_IA32_UCODE_REV:
+ 		rdmsrl(msr->index, msr->data);
++>>>>>>> 518e7b94817a (KVM: X86: Allow userspace to define the microcode version)
  		break;
  	default:
  		if (kvm_x86_ops->get_msr_feature(msr))
@@@ -2244,13 -2266,11 +2253,19 @@@ int kvm_set_msr_common(struct kvm_vcpu 
  	case MSR_AMD64_PATCH_LOADER:
  	case MSR_AMD64_BU_CFG2:
  	case MSR_AMD64_DC_CFG:
 +	case MSR_F15H_EX_CFG:
  		break;
  
++<<<<<<< HEAD
 +	case MSR_IA32_ARCH_CAPABILITIES:
 +		if (!msr_info->host_initiated)
 +			return 1;
 +		vcpu->arch.arch_capabilities = data;
++=======
+ 	case MSR_IA32_UCODE_REV:
+ 		if (msr_info->host_initiated)
+ 			vcpu->arch.microcode_version = data;
++>>>>>>> 518e7b94817a (KVM: X86: Allow userspace to define the microcode version)
  		break;
  	case MSR_EFER:
  		return set_efer(vcpu, data);
@@@ -2539,17 -2567,8 +2554,17 @@@ int kvm_get_msr_common(struct kvm_vcpu 
  		msr_info->data = 0;
  		break;
  	case MSR_IA32_UCODE_REV:
- 		msr_info->data = 0x100000000ULL;
+ 		msr_info->data = vcpu->arch.microcode_version;
  		break;
 +	case MSR_IA32_ARCH_CAPABILITIES:
 +		if (!msr_info->host_initiated &&
 +		    !guest_cpuid_has(vcpu, X86_FEATURE_ARCH_CAPABILITIES))
 +			return 1;
 +		msr_info->data = vcpu->arch.arch_capabilities;
 +		break;
 +	case MSR_IA32_TSC:
 +		msr_info->data = kvm_scale_tsc(vcpu, rdtsc()) + vcpu->arch.tsc_offset;
 +		break;
  	case MSR_MTRRcap:
  	case 0x200 ... 0x2ff:
  		return kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/svm.c
* Unmerged path arch/x86/kvm/vmx.c
* Unmerged path arch/x86/kvm/x86.c
