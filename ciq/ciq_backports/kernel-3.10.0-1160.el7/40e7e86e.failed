gfs2: Clean up inode initialization and teardown

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 40e7e86ef16550c7371939c7025041b7740f252e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/40e7e86e.failed

When allocating a new inode, mark the iopen glock holder as uninitialized to
make sure gfs2_evict_inode won't fail after an incomplete create or lookup.  In
gfs2_evict_inode, allow the inode glock to be NULL and remove the duplicate
iopen glock teardown code.  In gfs2_inode_lookup, don't tear down things that
gfs2_evict_inode will already tear down.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 40e7e86ef16550c7371939c7025041b7740f252e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/inode.c
#	fs/gfs2/super.c
diff --cc fs/gfs2/inode.c
index a7cb675316c4,b5d04f3a247e..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -164,18 -161,16 +164,23 @@@ struct inode *gfs2_inode_lookup(struct 
  				error = gfs2_check_blk_type(sdp, no_addr,
  							    blktype);
  				if (error)
- 					goto fail_put;
+ 					goto fail;
  			}
  		}
 -
 +		flush_delayed_work(&ip->i_gl->gl_work);
  		glock_set_object(ip->i_gl, ip);
 +
  		set_bit(GIF_INVALID, &ip->i_flags);
  		error = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);
  		if (unlikely(error))
++<<<<<<< HEAD
 +			goto fail_put;
 +
 +		glock_set_object(io_gl, ip);
++=======
+ 			goto fail;
+ 		glock_set_object(ip->i_iopen_gh.gh_gl, ip);
++>>>>>>> 40e7e86ef165 (gfs2: Clean up inode initialization and teardown)
  		gfs2_glock_put(io_gl);
  		io_gl = NULL;
  
@@@ -183,8 -182,9 +188,8 @@@
  			/* Inode glock must be locked already */
  			error = gfs2_inode_refresh(GFS2_I(inode));
  			if (error)
- 				goto fail_refresh;
+ 				goto fail;
  		} else {
 -			ip->i_no_formal_ino = no_formal_ino;
  			inode->i_mode = DT2IF(type);
  		}
  
diff --cc fs/gfs2/super.c
index 6327156ef20f,d664b0175946..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1633,16 -1393,10 +1633,21 @@@ out_unlock
  	if (gfs2_rs_active(&ip->i_res))
  		gfs2_rs_deltree(&ip->i_res);
  
++<<<<<<< HEAD
 +	if (gfs2_holder_initialized(&ip->i_iopen_gh)) {
 +		glock_clear_object(ip->i_iopen_gh.gh_gl, ip);
 +		if (test_bit(HIF_HOLDER, &ip->i_iopen_gh.gh_iflags)) {
 +			ip->i_iopen_gh.gh_flags |= GL_NOCACHE;
 +			gfs2_glock_dq(&ip->i_iopen_gh);
 +		}
 +		gfs2_holder_uninit(&ip->i_iopen_gh);
 +	}
 +	if (gfs2_holder_initialized(&gh))
++=======
+ 	if (gfs2_holder_initialized(&gh)) {
+ 		glock_clear_object(ip->i_gl, ip);
++>>>>>>> 40e7e86ef165 (gfs2: Clean up inode initialization and teardown)
  		gfs2_glock_dq_uninit(&gh);
 -	}
  	if (error && error != GLR_TRYFAILED && error != -EROFS)
  		fs_warn(sdp, "gfs2_evict_inode: %d\n", error);
  out:
@@@ -1673,14 -1431,14 +1683,25 @@@ static struct inode *gfs2_alloc_inode(s
  	struct gfs2_inode *ip;
  
  	ip = kmem_cache_alloc(gfs2_inode_cachep, GFP_KERNEL);
++<<<<<<< HEAD
 +	if (ip) {
 +		ip->i_flags = 0;
 +		ip->i_gl = NULL;
 +		ip->i_rgd = NULL;
 +		memset(&ip->i_res, 0, sizeof(ip->i_res));
 +		RB_CLEAR_NODE(&ip->i_res.rs_node);
 +		ip->i_rahead = 0;
 +	}
++=======
+ 	if (!ip)
+ 		return NULL;
+ 	ip->i_flags = 0;
+ 	ip->i_gl = NULL;
+ 	gfs2_holder_mark_uninitialized(&ip->i_iopen_gh);
+ 	memset(&ip->i_res, 0, sizeof(ip->i_res));
+ 	RB_CLEAR_NODE(&ip->i_res.rs_node);
+ 	ip->i_rahead = 0;
++>>>>>>> 40e7e86ef165 (gfs2: Clean up inode initialization and teardown)
  	return &ip->i_inode;
  }
  
* Unmerged path fs/gfs2/inode.c
* Unmerged path fs/gfs2/super.c
