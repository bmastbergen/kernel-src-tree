scsi: core: avoid repetitive logging of device offline messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
Rebuild_CHGLOG: - [scsi] scsi: avoid repetitive logging of device offline messages (Nilesh Javali) [1798042]
Rebuild_FUZZ: 95.00%
commit-author Ewan D. Milne <emilne@redhat.com>
commit b0962c53bde9a485c8ebc401fa1dbe821a76bc3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/b0962c53.failed

Large queues of I/O to offline devices that are eventually submitted when
devices are unblocked result in a many repeated "rejecting I/O to offline
device" messages.  These messages can fill up the dmesg buffer in crash
dumps so no useful prior messages remain.  In addition, if a serial console
is used, the flood of messages can cause a hard lockup in the console code.

Introduce a flag indicating the message has already been logged for the
device, and reset the flag when scsi_device_set_state() changes the device
state.

Link: https://lore.kernel.org/r/20200311143930.20674-1-emilne@redhat.com
	Reviewed-by: Bart van Assche <bvanassche@acm.org>
	Signed-off-by: Ewan D. Milne <emilne@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit b0962c53bde9a485c8ebc401fa1dbe821a76bc3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_lib.c
#	include/scsi/scsi_device.h
diff --cc drivers/scsi/scsi_lib.c
index eedd4db07442,47835c4b4ee0..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -1258,127 -1198,57 +1258,171 @@@ static int scsi_setup_cmnd(struct scsi_
  	else
  		cmd->sc_data_direction = DMA_FROM_DEVICE;
  
 -	if (blk_rq_is_scsi(req))
 -		return scsi_setup_scsi_cmnd(sdev, req);
 -	else
 +	switch (req->cmd_type) {
 +	case REQ_TYPE_FS:
  		return scsi_setup_fs_cmnd(sdev, req);
 +	case REQ_TYPE_BLOCK_PC:
 +		return scsi_setup_blk_pc_cmnd(sdev, req);
 +	default:
 +		return BLKPREP_KILL;
 +	}
  }
  
 -static blk_status_t
 +static int
  scsi_prep_state_check(struct scsi_device *sdev, struct request *req)
  {
++<<<<<<< HEAD
 +	int ret = BLKPREP_OK;
 +
 +	/*
 +	 * If the device is not in running state we will reject some
 +	 * or all commands.
 +	 */
 +	if (unlikely(sdev->sdev_state != SDEV_RUNNING)) {
 +		switch (sdev->sdev_state) {
 +		case SDEV_OFFLINE:
 +		case SDEV_TRANSPORT_OFFLINE:
 +			/*
 +			 * If the device is offline we refuse to process any
 +			 * commands.  The device must be brought online
 +			 * before trying any recovery commands.
 +			 */
 +			sdev_printk(KERN_ERR, sdev,
 +				    "rejecting I/O to offline device\n");
 +			ret = BLKPREP_KILL;
 +			break;
 +		case SDEV_DEL:
 +			/*
 +			 * If the device is fully deleted, we refuse to
 +			 * process any commands as well.
 +			 */
 +			sdev_printk(KERN_ERR, sdev,
 +				    "rejecting I/O to dead device\n");
 +			ret = BLKPREP_KILL;
 +			break;
 +		case SDEV_QUIESCE:
 +		case SDEV_BLOCK:
 +		case SDEV_CREATED_BLOCK:
 +			/*
 +			 * If the devices is blocked we defer normal commands.
 +			 */
 +			if (req && !(req->cmd_flags & REQ_PREEMPT))
 +				ret = BLKPREP_DEFER;
 +			break;
 +		default:
 +			/*
 +			 * For any other not fully online state we only allow
 +			 * special commands.  In particular any user initiated
 +			 * command is not allowed.
 +			 */
 +			if (req && !(req->cmd_flags & REQ_PREEMPT))
 +				ret = BLKPREP_KILL;
 +			break;
 +		}
++=======
+ 	switch (sdev->sdev_state) {
+ 	case SDEV_OFFLINE:
+ 	case SDEV_TRANSPORT_OFFLINE:
+ 		/*
+ 		 * If the device is offline we refuse to process any
+ 		 * commands.  The device must be brought online
+ 		 * before trying any recovery commands.
+ 		 */
+ 		if (!sdev->offline_already) {
+ 			sdev->offline_already = true;
+ 			sdev_printk(KERN_ERR, sdev,
+ 				    "rejecting I/O to offline device\n");
+ 		}
+ 		return BLK_STS_IOERR;
+ 	case SDEV_DEL:
+ 		/*
+ 		 * If the device is fully deleted, we refuse to
+ 		 * process any commands as well.
+ 		 */
+ 		sdev_printk(KERN_ERR, sdev,
+ 			    "rejecting I/O to dead device\n");
+ 		return BLK_STS_IOERR;
+ 	case SDEV_BLOCK:
+ 	case SDEV_CREATED_BLOCK:
+ 		return BLK_STS_RESOURCE;
+ 	case SDEV_QUIESCE:
+ 		/*
+ 		 * If the devices is blocked we defer normal commands.
+ 		 */
+ 		if (req && !(req->rq_flags & RQF_PREEMPT))
+ 			return BLK_STS_RESOURCE;
+ 		return BLK_STS_OK;
+ 	default:
+ 		/*
+ 		 * For any other not fully online state we only allow
+ 		 * special commands.  In particular any user initiated
+ 		 * command is not allowed.
+ 		 */
+ 		if (req && !(req->rq_flags & RQF_PREEMPT))
+ 			return BLK_STS_IOERR;
+ 		return BLK_STS_OK;
++>>>>>>> b0962c53bde9 (scsi: core: avoid repetitive logging of device offline messages)
 +	}
 +	return ret;
 +}
 +
 +static int
 +scsi_prep_return(struct request_queue *q, struct request *req, int ret)
 +{
 +	struct scsi_device *sdev = q->queuedata;
 +
 +	switch (ret) {
 +	case BLKPREP_KILL:
 +		req->errors = DID_NO_CONNECT << 16;
 +		/* release the command and kill it */
 +		if (req->special) {
 +			struct scsi_cmnd *cmd = req->special;
 +			scsi_release_buffers(cmd);
 +			scsi_put_command(cmd);
 +			put_device(&sdev->sdev_gendev);
 +			req->special = NULL;
 +		}
 +		break;
 +	case BLKPREP_DEFER:
 +		/*
 +		 * If we defer, the blk_peek_request() returns NULL, but the
 +		 * queue must be restarted, so we schedule a callback to happen
 +		 * shortly.
 +		 */
 +		if (atomic_read(&sdev->device_busy) == 0)
 +			blk_delay_queue(q, SCSI_QUEUE_DELAY);
 +		break;
 +	default:
 +		req->cmd_flags |= REQ_DONTPREP;
  	}
 +
 +	return ret;
 +}
 +
 +static int scsi_prep_fn(struct request_queue *q, struct request *req)
 +{
 +	struct scsi_device *sdev = q->queuedata;
 +	struct scsi_cmnd *cmd;
 +	int ret;
 +
 +	ret = scsi_prep_state_check(sdev, req);
 +	if (ret != BLKPREP_OK)
 +		goto out;
 +
 +	cmd = scsi_get_cmd_from_req(sdev, req);
 +	if (unlikely(!cmd)) {
 +		ret = BLKPREP_DEFER;
 +		goto out;
 +	}
 +
 +	ret = scsi_setup_cmnd(sdev, req);
 +out:
 +	return scsi_prep_return(q, req, ret);
 +}
 +
 +static void scsi_unprep_fn(struct request_queue *q, struct request *req)
 +{
 +	scsi_uninit_cmd(req->special);
  }
  
  /*
diff --cc include/scsi/scsi_device.h
index bd3cae55e067,c3cba2aaf934..000000000000
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@@ -180,17 -199,12 +180,26 @@@ struct scsi_device 
  	unsigned wce_default_on:1;	/* Cache is ON by default */
  	unsigned no_dif:1;	/* T10 PI (DIF) should be disabled */
  	unsigned broken_fua:1;		/* Don't set FUA bit */
++<<<<<<< HEAD
 +
 +	/* FOR RH USE ONLY
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserving ABI.
 +	 */
 +	unsigned vpd_reserved:1;
 +	unsigned xcopy_reserved:1;
 +	RH_KABI_FILL_HOLE(unsigned lun_in_cdb:1) /* Store LUN bits in CDB[1] */
 +	RH_KABI_FILL_HOLE(unsigned try_vpd_pages:1)	/* attempt to read VPD pages */
 +	RH_KABI_FILL_HOLE(unsigned unmap_limit_for_ws:1)	/* Use the UNMAP limit for WRITE SAME */
++=======
+ 	unsigned lun_in_cdb:1;		/* Store LUN bits in CDB[1] */
+ 	unsigned unmap_limit_for_ws:1;	/* Use the UNMAP limit for WRITE SAME */
+ 	unsigned rpm_autosuspend:1;	/* Enable runtime autosuspend at device
+ 					 * creation time */
+ 
+ 	bool offline_already;		/* Device offline message logged */
++>>>>>>> b0962c53bde9 (scsi: core: avoid repetitive logging of device offline messages)
  
  	atomic_t disk_events_disable_depth; /* disable depth for disk events */
  
* Unmerged path drivers/scsi/scsi_lib.c
* Unmerged path include/scsi/scsi_device.h
