md/raid1: release pending accounting for an I/O only after write-behind is also finished

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author David Jeffery <djeffery@redhat.com>
commit c91114c2b89d5bea132d34b40568053f8bfa963d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/c91114c2.failed

When using RAID1 and write-behind, md can deadlock when errors occur. With
write-behind, r1bio structs can be accounted by raid1 as queued but not
counted as pending. The pending count is dropped when the original bio is
returned complete but write-behind for the r1bio may still be active.

This breaks the accounting used in some conditions to know when the raid1
md device has reached an idle state. It can result in calls to
freeze_array deadlocking. freeze_array will never complete from a negative
"unqueued" value being calculated due to a queued count larger than the
pending count.

To properly account for write-behind, move the call to allow_barrier from
call_bio_endio to raid_end_bio_io. When using write-behind, md can call
call_bio_endio before all write-behind I/O is complete. Using
raid_end_bio_io for the point to call allow_barrier will release the
pending count at a point where all I/O for an r1bio, even write-behind, is
done.

	Signed-off-by: David Jeffery <djeffery@redhat.com>
	Signed-off-by: Song Liu <songliubraving@fb.com>
(cherry picked from commit c91114c2b89d5bea132d34b40568053f8bfa963d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid1.c
diff --cc drivers/md/raid1.c
index 8338144e1d03,dcd27f3da84e..000000000000
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@@ -269,17 -296,11 +269,20 @@@ static void reschedule_retry(struct r1b
  static void call_bio_endio(struct r1bio *r1_bio)
  {
  	struct bio *bio = r1_bio->master_bio;
- 	struct r1conf *conf = r1_bio->mddev->private;
  
  	if (!test_bit(R1BIO_Uptodate, &r1_bio->state))
 -		bio->bi_status = BLK_STS_IOERR;
 +		clear_bit(BIO_UPTODATE, &bio->bi_flags);
  
++<<<<<<< HEAD
 +	bio_endio(bio, 0);
 +	/*
 +	 * Wake up any possible resync thread that waits for the device
 +	 * to go idle.
 +	 */
 +	allow_barrier(conf, r1_bio->sector);
++=======
+ 	bio_endio(bio);
++>>>>>>> c91114c2b89d (md/raid1: release pending accounting for an I/O only after write-behind is also finished)
  }
  
  static void raid_end_bio_io(struct r1bio *r1_bio)
* Unmerged path drivers/md/raid1.c
