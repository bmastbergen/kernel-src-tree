x86/devicetable: Move x86 specific macro out of generic code

jira LE-1907
cve CVE-2020-0543
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit ba5bade4cc0d2013cdf5634dae554693c968a090
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/ba5bade4.failed

There is no reason that this gunk is in a generic header file. The wildcard
defines need to stay as they are required by file2alias.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Link: https://lkml.kernel.org/r/20200320131508.736205164@linutronix.de
(cherry picked from commit ba5bade4cc0d2013cdf5634dae554693c968a090)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm.c
#	arch/x86/kvm/vmx/vmx.c
#	include/linux/mod_devicetable.h
diff --cc arch/x86/kvm/svm.c
index b452f8e650be,5753fc3bcfc1..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -43,7 -47,8 +43,12 @@@
  #include <asm/debugreg.h>
  #include <asm/kvm_para.h>
  #include <asm/irq_remapping.h>
++<<<<<<< HEAD
 +#include <asm/nospec-branch.h>
++=======
+ #include <asm/spec-ctrl.h>
+ #include <asm/cpu_device_id.h>
++>>>>>>> ba5bade4cc0d (x86/devicetable: Move x86 specific macro out of generic code)
  
  #include <asm/virtext.h>
  #include "trace.h"
diff --cc include/linux/mod_devicetable.h
index 49d0b197b2e2,f8b66d43acf6..000000000000
--- a/include/linux/mod_devicetable.h
+++ b/include/linux/mod_devicetable.h
@@@ -208,6 -230,529 +208,532 @@@ struct pnp_card_device_id 
  	} devs[PNP_MAX_DEVICES];
  };
  
++<<<<<<< HEAD
++=======
+ 
+ #define SERIO_ANY	0xff
+ 
+ struct serio_device_id {
+ 	__u8 type;
+ 	__u8 extra;
+ 	__u8 id;
+ 	__u8 proto;
+ };
+ 
+ struct hda_device_id {
+ 	__u32 vendor_id;
+ 	__u32 rev_id;
+ 	__u8 api_version;
+ 	const char *name;
+ 	unsigned long driver_data;
+ };
+ 
+ struct sdw_device_id {
+ 	__u16 mfg_id;
+ 	__u16 part_id;
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ /*
+  * Struct used for matching a device
+  */
+ struct of_device_id {
+ 	char	name[32];
+ 	char	type[32];
+ 	char	compatible[128];
+ 	const void *data;
+ };
+ 
+ /* VIO */
+ struct vio_device_id {
+ 	char type[32];
+ 	char compat[32];
+ };
+ 
+ /* PCMCIA */
+ 
+ struct pcmcia_device_id {
+ 	__u16		match_flags;
+ 
+ 	__u16		manf_id;
+ 	__u16		card_id;
+ 
+ 	__u8		func_id;
+ 
+ 	/* for real multi-function devices */
+ 	__u8		function;
+ 
+ 	/* for pseudo multi-function devices */
+ 	__u8		device_no;
+ 
+ 	__u32		prod_id_hash[4];
+ 
+ 	/* not matched against in kernelspace */
+ 	const char *	prod_id[4];
+ 
+ 	/* not matched against */
+ 	kernel_ulong_t	driver_info;
+ 	char *		cisfile;
+ };
+ 
+ #define PCMCIA_DEV_ID_MATCH_MANF_ID	0x0001
+ #define PCMCIA_DEV_ID_MATCH_CARD_ID	0x0002
+ #define PCMCIA_DEV_ID_MATCH_FUNC_ID	0x0004
+ #define PCMCIA_DEV_ID_MATCH_FUNCTION	0x0008
+ #define PCMCIA_DEV_ID_MATCH_PROD_ID1	0x0010
+ #define PCMCIA_DEV_ID_MATCH_PROD_ID2	0x0020
+ #define PCMCIA_DEV_ID_MATCH_PROD_ID3	0x0040
+ #define PCMCIA_DEV_ID_MATCH_PROD_ID4	0x0080
+ #define PCMCIA_DEV_ID_MATCH_DEVICE_NO	0x0100
+ #define PCMCIA_DEV_ID_MATCH_FAKE_CIS	0x0200
+ #define PCMCIA_DEV_ID_MATCH_ANONYMOUS	0x0400
+ 
+ /* Input */
+ #define INPUT_DEVICE_ID_EV_MAX		0x1f
+ #define INPUT_DEVICE_ID_KEY_MIN_INTERESTING	0x71
+ #define INPUT_DEVICE_ID_KEY_MAX		0x2ff
+ #define INPUT_DEVICE_ID_REL_MAX		0x0f
+ #define INPUT_DEVICE_ID_ABS_MAX		0x3f
+ #define INPUT_DEVICE_ID_MSC_MAX		0x07
+ #define INPUT_DEVICE_ID_LED_MAX		0x0f
+ #define INPUT_DEVICE_ID_SND_MAX		0x07
+ #define INPUT_DEVICE_ID_FF_MAX		0x7f
+ #define INPUT_DEVICE_ID_SW_MAX		0x0f
+ #define INPUT_DEVICE_ID_PROP_MAX	0x1f
+ 
+ #define INPUT_DEVICE_ID_MATCH_BUS	1
+ #define INPUT_DEVICE_ID_MATCH_VENDOR	2
+ #define INPUT_DEVICE_ID_MATCH_PRODUCT	4
+ #define INPUT_DEVICE_ID_MATCH_VERSION	8
+ 
+ #define INPUT_DEVICE_ID_MATCH_EVBIT	0x0010
+ #define INPUT_DEVICE_ID_MATCH_KEYBIT	0x0020
+ #define INPUT_DEVICE_ID_MATCH_RELBIT	0x0040
+ #define INPUT_DEVICE_ID_MATCH_ABSBIT	0x0080
+ #define INPUT_DEVICE_ID_MATCH_MSCIT	0x0100
+ #define INPUT_DEVICE_ID_MATCH_LEDBIT	0x0200
+ #define INPUT_DEVICE_ID_MATCH_SNDBIT	0x0400
+ #define INPUT_DEVICE_ID_MATCH_FFBIT	0x0800
+ #define INPUT_DEVICE_ID_MATCH_SWBIT	0x1000
+ #define INPUT_DEVICE_ID_MATCH_PROPBIT	0x2000
+ 
+ struct input_device_id {
+ 
+ 	kernel_ulong_t flags;
+ 
+ 	__u16 bustype;
+ 	__u16 vendor;
+ 	__u16 product;
+ 	__u16 version;
+ 
+ 	kernel_ulong_t evbit[INPUT_DEVICE_ID_EV_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t keybit[INPUT_DEVICE_ID_KEY_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t relbit[INPUT_DEVICE_ID_REL_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t absbit[INPUT_DEVICE_ID_ABS_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t mscbit[INPUT_DEVICE_ID_MSC_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t ledbit[INPUT_DEVICE_ID_LED_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t sndbit[INPUT_DEVICE_ID_SND_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t ffbit[INPUT_DEVICE_ID_FF_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t swbit[INPUT_DEVICE_ID_SW_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t propbit[INPUT_DEVICE_ID_PROP_MAX / BITS_PER_LONG + 1];
+ 
+ 	kernel_ulong_t driver_info;
+ };
+ 
+ /* EISA */
+ 
+ #define EISA_SIG_LEN   8
+ 
+ /* The EISA signature, in ASCII form, null terminated */
+ struct eisa_device_id {
+ 	char          sig[EISA_SIG_LEN];
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ #define EISA_DEVICE_MODALIAS_FMT "eisa:s%s"
+ 
+ struct parisc_device_id {
+ 	__u8	hw_type;	/* 5 bits used */
+ 	__u8	hversion_rev;	/* 4 bits */
+ 	__u16	hversion;	/* 12 bits */
+ 	__u32	sversion;	/* 20 bits */
+ };
+ 
+ #define PA_HWTYPE_ANY_ID	0xff
+ #define PA_HVERSION_REV_ANY_ID	0xff
+ #define PA_HVERSION_ANY_ID	0xffff
+ #define PA_SVERSION_ANY_ID	0xffffffff
+ 
+ /* SDIO */
+ 
+ #define SDIO_ANY_ID (~0)
+ 
+ struct sdio_device_id {
+ 	__u8	class;			/* Standard interface or SDIO_ANY_ID */
+ 	__u16	vendor;			/* Vendor or SDIO_ANY_ID */
+ 	__u16	device;			/* Device ID or SDIO_ANY_ID */
+ 	kernel_ulong_t driver_data;	/* Data private to the driver */
+ };
+ 
+ /* SSB core, see drivers/ssb/ */
+ struct ssb_device_id {
+ 	__u16	vendor;
+ 	__u16	coreid;
+ 	__u8	revision;
+ 	__u8	__pad;
+ } __attribute__((packed, aligned(2)));
+ #define SSB_DEVICE(_vendor, _coreid, _revision)  \
+ 	{ .vendor = _vendor, .coreid = _coreid, .revision = _revision, }
+ 
+ #define SSB_ANY_VENDOR		0xFFFF
+ #define SSB_ANY_ID		0xFFFF
+ #define SSB_ANY_REV		0xFF
+ 
+ /* Broadcom's specific AMBA core, see drivers/bcma/ */
+ struct bcma_device_id {
+ 	__u16	manuf;
+ 	__u16	id;
+ 	__u8	rev;
+ 	__u8	class;
+ } __attribute__((packed,aligned(2)));
+ #define BCMA_CORE(_manuf, _id, _rev, _class)  \
+ 	{ .manuf = _manuf, .id = _id, .rev = _rev, .class = _class, }
+ 
+ #define BCMA_ANY_MANUF		0xFFFF
+ #define BCMA_ANY_ID		0xFFFF
+ #define BCMA_ANY_REV		0xFF
+ #define BCMA_ANY_CLASS		0xFF
+ 
+ struct virtio_device_id {
+ 	__u32 device;
+ 	__u32 vendor;
+ };
+ #define VIRTIO_DEV_ANY_ID	0xffffffff
+ 
+ /*
+  * For Hyper-V devices we use the device guid as the id.
+  */
+ struct hv_vmbus_device_id {
+ 	uuid_le guid;
+ 	kernel_ulong_t driver_data;	/* Data private to the driver */
+ };
+ 
+ /* rpmsg */
+ 
+ #define RPMSG_NAME_SIZE			32
+ #define RPMSG_DEVICE_MODALIAS_FMT	"rpmsg:%s"
+ 
+ struct rpmsg_device_id {
+ 	char name[RPMSG_NAME_SIZE];
+ };
+ 
+ /* i2c */
+ 
+ #define I2C_NAME_SIZE	20
+ #define I2C_MODULE_PREFIX "i2c:"
+ 
+ struct i2c_device_id {
+ 	char name[I2C_NAME_SIZE];
+ 	kernel_ulong_t driver_data;	/* Data private to the driver */
+ };
+ 
+ /* pci_epf */
+ 
+ #define PCI_EPF_NAME_SIZE	20
+ #define PCI_EPF_MODULE_PREFIX	"pci_epf:"
+ 
+ struct pci_epf_device_id {
+ 	char name[PCI_EPF_NAME_SIZE];
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ /* i3c */
+ 
+ #define I3C_MATCH_DCR			0x1
+ #define I3C_MATCH_MANUF			0x2
+ #define I3C_MATCH_PART			0x4
+ #define I3C_MATCH_EXTRA_INFO		0x8
+ 
+ struct i3c_device_id {
+ 	__u8 match_flags;
+ 	__u8 dcr;
+ 	__u16 manuf_id;
+ 	__u16 part_id;
+ 	__u16 extra_info;
+ 
+ 	const void *data;
+ };
+ 
+ /* spi */
+ 
+ #define SPI_NAME_SIZE	32
+ #define SPI_MODULE_PREFIX "spi:"
+ 
+ struct spi_device_id {
+ 	char name[SPI_NAME_SIZE];
+ 	kernel_ulong_t driver_data;	/* Data private to the driver */
+ };
+ 
+ /* SLIMbus */
+ 
+ #define SLIMBUS_NAME_SIZE	32
+ #define SLIMBUS_MODULE_PREFIX	"slim:"
+ 
+ struct slim_device_id {
+ 	__u16 manf_id, prod_code;
+ 	__u16 dev_index, instance;
+ 
+ 	/* Data private to the driver */
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ #define APR_NAME_SIZE	32
+ #define APR_MODULE_PREFIX "apr:"
+ 
+ struct apr_device_id {
+ 	char name[APR_NAME_SIZE];
+ 	__u32 domain_id;
+ 	__u32 svc_id;
+ 	__u32 svc_version;
+ 	kernel_ulong_t driver_data;	/* Data private to the driver */
+ };
+ 
+ #define SPMI_NAME_SIZE	32
+ #define SPMI_MODULE_PREFIX "spmi:"
+ 
+ struct spmi_device_id {
+ 	char name[SPMI_NAME_SIZE];
+ 	kernel_ulong_t driver_data;	/* Data private to the driver */
+ };
+ 
+ /* dmi */
+ enum dmi_field {
+ 	DMI_NONE,
+ 	DMI_BIOS_VENDOR,
+ 	DMI_BIOS_VERSION,
+ 	DMI_BIOS_DATE,
+ 	DMI_SYS_VENDOR,
+ 	DMI_PRODUCT_NAME,
+ 	DMI_PRODUCT_VERSION,
+ 	DMI_PRODUCT_SERIAL,
+ 	DMI_PRODUCT_UUID,
+ 	DMI_PRODUCT_SKU,
+ 	DMI_PRODUCT_FAMILY,
+ 	DMI_BOARD_VENDOR,
+ 	DMI_BOARD_NAME,
+ 	DMI_BOARD_VERSION,
+ 	DMI_BOARD_SERIAL,
+ 	DMI_BOARD_ASSET_TAG,
+ 	DMI_CHASSIS_VENDOR,
+ 	DMI_CHASSIS_TYPE,
+ 	DMI_CHASSIS_VERSION,
+ 	DMI_CHASSIS_SERIAL,
+ 	DMI_CHASSIS_ASSET_TAG,
+ 	DMI_STRING_MAX,
+ 	DMI_OEM_STRING,	/* special case - will not be in dmi_ident */
+ };
+ 
+ struct dmi_strmatch {
+ 	unsigned char slot:7;
+ 	unsigned char exact_match:1;
+ 	char substr[79];
+ };
+ 
+ struct dmi_system_id {
+ 	int (*callback)(const struct dmi_system_id *);
+ 	const char *ident;
+ 	struct dmi_strmatch matches[4];
+ 	void *driver_data;
+ };
+ /*
+  * struct dmi_device_id appears during expansion of
+  * "MODULE_DEVICE_TABLE(dmi, x)". Compiler doesn't look inside it
+  * but this is enough for gcc 3.4.6 to error out:
+  *	error: storage size of '__mod_dmi_device_table' isn't known
+  */
+ #define dmi_device_id dmi_system_id
+ 
+ #define DMI_MATCH(a, b)	{ .slot = a, .substr = b }
+ #define DMI_EXACT_MATCH(a, b)	{ .slot = a, .substr = b, .exact_match = 1 }
+ 
+ #define PLATFORM_NAME_SIZE	20
+ #define PLATFORM_MODULE_PREFIX	"platform:"
+ 
+ struct platform_device_id {
+ 	char name[PLATFORM_NAME_SIZE];
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ #define MDIO_NAME_SIZE		32
+ #define MDIO_MODULE_PREFIX	"mdio:"
+ 
+ #define MDIO_ID_FMT "%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u"
+ #define MDIO_ID_ARGS(_id) \
+ 	((_id)>>31) & 1, ((_id)>>30) & 1, ((_id)>>29) & 1, ((_id)>>28) & 1, \
+ 	((_id)>>27) & 1, ((_id)>>26) & 1, ((_id)>>25) & 1, ((_id)>>24) & 1, \
+ 	((_id)>>23) & 1, ((_id)>>22) & 1, ((_id)>>21) & 1, ((_id)>>20) & 1, \
+ 	((_id)>>19) & 1, ((_id)>>18) & 1, ((_id)>>17) & 1, ((_id)>>16) & 1, \
+ 	((_id)>>15) & 1, ((_id)>>14) & 1, ((_id)>>13) & 1, ((_id)>>12) & 1, \
+ 	((_id)>>11) & 1, ((_id)>>10) & 1, ((_id)>>9) & 1, ((_id)>>8) & 1, \
+ 	((_id)>>7) & 1, ((_id)>>6) & 1, ((_id)>>5) & 1, ((_id)>>4) & 1, \
+ 	((_id)>>3) & 1, ((_id)>>2) & 1, ((_id)>>1) & 1, (_id) & 1
+ 
+ /**
+  * struct mdio_device_id - identifies PHY devices on an MDIO/MII bus
+  * @phy_id: The result of
+  *     (mdio_read(&MII_PHYSID1) << 16 | mdio_read(&MII_PHYSID2)) & @phy_id_mask
+  *     for this PHY type
+  * @phy_id_mask: Defines the significant bits of @phy_id.  A value of 0
+  *     is used to terminate an array of struct mdio_device_id.
+  */
+ struct mdio_device_id {
+ 	__u32 phy_id;
+ 	__u32 phy_id_mask;
+ };
+ 
+ struct zorro_device_id {
+ 	__u32 id;			/* Device ID or ZORRO_WILDCARD */
+ 	kernel_ulong_t driver_data;	/* Data private to the driver */
+ };
+ 
+ #define ZORRO_WILDCARD			(0xffffffff)	/* not official */
+ 
+ #define ZORRO_DEVICE_MODALIAS_FMT	"zorro:i%08X"
+ 
+ #define ISAPNP_ANY_ID		0xffff
+ struct isapnp_device_id {
+ 	unsigned short card_vendor, card_device;
+ 	unsigned short vendor, function;
+ 	kernel_ulong_t driver_data;	/* data private to the driver */
+ };
+ 
+ /**
+  * struct amba_id - identifies a device on an AMBA bus
+  * @id: The significant bits if the hardware device ID
+  * @mask: Bitmask specifying which bits of the id field are significant when
+  *	matching.  A driver binds to a device when ((hardware device ID) & mask)
+  *	== id.
+  * @data: Private data used by the driver.
+  */
+ struct amba_id {
+ 	unsigned int		id;
+ 	unsigned int		mask;
+ 	void			*data;
+ };
+ 
+ /**
+  * struct mips_cdmm_device_id - identifies devices in MIPS CDMM bus
+  * @type:	Device type identifier.
+  */
+ struct mips_cdmm_device_id {
+ 	__u8	type;
+ };
+ 
+ /*
+  * Match x86 CPUs for CPU specific drivers.
+  * See documentation of "x86_match_cpu" for details.
+  */
+ 
+ /*
+  * MODULE_DEVICE_TABLE expects this struct to be called x86cpu_device_id.
+  * Although gcc seems to ignore this error, clang fails without this define.
+  */
+ #define x86cpu_device_id x86_cpu_id
+ struct x86_cpu_id {
+ 	__u16 vendor;
+ 	__u16 family;
+ 	__u16 model;
+ 	__u16 feature;	/* bit index */
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ /* Wild cards for x86_cpu_id::vendor, family, model and feature */
+ #define X86_VENDOR_ANY 0xffff
+ #define X86_FAMILY_ANY 0
+ #define X86_MODEL_ANY  0
+ #define X86_FEATURE_ANY 0	/* Same as FPU, you can't test for that */
+ 
+ /*
+  * Generic table type for matching CPU features.
+  * @feature:	the bit number of the feature (0 - 65535)
+  */
+ 
+ struct cpu_feature {
+ 	__u16	feature;
+ };
+ 
+ #define IPACK_ANY_FORMAT 0xff
+ #define IPACK_ANY_ID (~0)
+ struct ipack_device_id {
+ 	__u8  format;			/* Format version or IPACK_ANY_ID */
+ 	__u32 vendor;			/* Vendor ID or IPACK_ANY_ID */
+ 	__u32 device;			/* Device ID or IPACK_ANY_ID */
+ };
+ 
+ #define MEI_CL_MODULE_PREFIX "mei:"
+ #define MEI_CL_NAME_SIZE 32
+ #define MEI_CL_VERSION_ANY 0xff
+ 
+ /**
+  * struct mei_cl_device_id - MEI client device identifier
+  * @name: helper name
+  * @uuid: client uuid
+  * @version: client protocol version
+  * @driver_info: information used by the driver.
+  *
+  * identifies mei client device by uuid and name
+  */
+ struct mei_cl_device_id {
+ 	char name[MEI_CL_NAME_SIZE];
+ 	uuid_le uuid;
+ 	__u8    version;
+ 	kernel_ulong_t driver_info;
+ };
+ 
+ /* RapidIO */
+ 
+ #define RIO_ANY_ID	0xffff
+ 
+ /**
+  * struct rio_device_id - RIO device identifier
+  * @did: RapidIO device ID
+  * @vid: RapidIO vendor ID
+  * @asm_did: RapidIO assembly device ID
+  * @asm_vid: RapidIO assembly vendor ID
+  *
+  * Identifies a RapidIO device based on both the device/vendor IDs and
+  * the assembly device/vendor IDs.
+  */
+ struct rio_device_id {
+ 	__u16 did, vid;
+ 	__u16 asm_did, asm_vid;
+ };
+ 
+ struct mcb_device_id {
+ 	__u16 device;
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ struct ulpi_device_id {
+ 	__u16 vendor;
+ 	__u16 product;
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ /**
+  * struct fsl_mc_device_id - MC object device identifier
+  * @vendor: vendor ID
+  * @obj_type: MC object type
+  *
+  * Type of entries in the "device Id" table for MC object devices supported by
+  * a MC object device driver. The last entry of the table has vendor set to 0x0
+  */
+ struct fsl_mc_device_id {
+ 	__u16 vendor;
+ 	const char obj_type[16];
+ };
+ 
++>>>>>>> ba5bade4cc0d (x86/devicetable: Move x86 specific macro out of generic code)
  /**
   * struct tb_service_id - Thunderbolt service identifiers
   * @match_flags: Flags used to match the structure
* Unmerged path arch/x86/kvm/vmx/vmx.c
diff --git a/arch/x86/include/asm/cpu_device_id.h b/arch/x86/include/asm/cpu_device_id.h
index 0d72cb7c4c6e..dc984169a895 100644
--- a/arch/x86/include/asm/cpu_device_id.h
+++ b/arch/x86/include/asm/cpu_device_id.h
@@ -5,11 +5,22 @@
  * Declare drivers belonging to specific x86 CPUs
  * Similar in spirit to pci_device_id and related PCI functions
  */
-
 #include <linux/mod_devicetable.h>
 
 extern const struct x86_cpu_id *x86_match_cpu(const struct x86_cpu_id *match);
 
+/*
+ * The wildcard initializers are in mod_devicetable.h because
+ * file2alias needs them. Sigh.
+ */
+
+#define X86_FEATURE_MATCH(x) {			\
+	.vendor		= X86_VENDOR_ANY,	\
+	.family		= X86_FAMILY_ANY,	\
+	.model		= X86_MODEL_ANY,	\
+	.feature	= x,			\
+}
+
 /*
  * Match specific microcode revisions.
  *
* Unmerged path arch/x86/kvm/svm.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
diff --git a/drivers/cpufreq/acpi-cpufreq.c b/drivers/cpufreq/acpi-cpufreq.c
index b38f5d963599..45d190556501 100644
--- a/drivers/cpufreq/acpi-cpufreq.c
+++ b/drivers/cpufreq/acpi-cpufreq.c
@@ -45,6 +45,7 @@
 #include <asm/msr.h>
 #include <asm/processor.h>
 #include <asm/cpufeature.h>
+#include <asm/cpu_device_id.h>
 
 MODULE_AUTHOR("Paul Diefenbaugh, Dominik Brodowski");
 MODULE_DESCRIPTION("ACPI Processor P-States Driver");
diff --git a/drivers/cpufreq/amd_freq_sensitivity.c b/drivers/cpufreq/amd_freq_sensitivity.c
index 2c9f9c568274..1aaeca6eebe9 100644
--- a/drivers/cpufreq/amd_freq_sensitivity.c
+++ b/drivers/cpufreq/amd_freq_sensitivity.c
@@ -20,6 +20,7 @@
 
 #include <asm/msr.h>
 #include <asm/cpufeature.h>
+#include <asm/cpu_device_id.h>
 
 #include "cpufreq_governor.h"
 
* Unmerged path include/linux/mod_devicetable.h
