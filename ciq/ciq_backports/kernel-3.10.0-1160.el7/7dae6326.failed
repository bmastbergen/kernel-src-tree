ACPI / sysfs: Extend ACPI sysfs to provide access to boot error region

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Tony Luck <tony.luck@intel.com>
commit 7dae6326ed76431653793df0388b3a404de1217e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/7dae6326.failed

The ACPI sysfs interface provides a way to read each ACPI table from
userspace via entries in /sys/firmware/acpi/tables/

The BERT table simply provides the size and address of the error
record in BIOS reserved memory and users may want access to this
record.

In an earlier age we might have used /dev/mem to retrieve this error
record, but many systems disable /dev/mem for security reasons.

Extend this driver to provide read-only access to the data via a
file in a new directory /sys/firmware/acpi/tables/data/BERT

	Acked-by: Punit Agrawal <punit.agrawal@arm.com>
	Signed-off-by: Tony Luck <tony.luck@intel.com>

v4: fix typo reported by Punit
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 7dae6326ed76431653793df0388b3a404de1217e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/sysfs.c
diff --cc drivers/acpi/sysfs.c
index a4c4db16b7d3,faa1aa3ed0e1..000000000000
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@@ -364,32 -511,37 +439,42 @@@ static int acpi_tables_sysfs_init(void
  	if (!dynamic_tables_kobj)
  		goto err_dynamic_tables;
  
 -	for (table_index = 0;; table_index++) {
 -		status = acpi_get_table_by_index(table_index, &table_header);
 -
 -		if (status == AE_BAD_PARAMETER)
 -			break;
 -
 -		if (ACPI_FAILURE(status))
 -			continue;
 -
 -		table_attr = kzalloc(sizeof(*table_attr), GFP_KERNEL);
 -		if (!table_attr)
 -			return -ENOMEM;
 +	do {
 +		result = acpi_get_table_by_index(table_index, &table_header);
 +		if (!result) {
 +			table_index++;
 +			table_attr = NULL;
 +			table_attr =
 +			    kzalloc(sizeof(struct acpi_table_attr), GFP_KERNEL);
 +			if (!table_attr)
 +				return -ENOMEM;
  
 -		ret = acpi_table_attr_init(tables_kobj,
 -					   table_attr, table_header);
 -		if (ret) {
 -			kfree(table_attr);
 -			return ret;
 +			acpi_table_attr_init(table_attr, table_header);
 +			result =
 +			    sysfs_create_bin_file(tables_kobj,
 +						  &table_attr->attr);
 +			if (result) {
 +				kfree(table_attr);
 +				return result;
 +			} else
 +				list_add_tail(&table_attr->node,
 +					      &acpi_table_attr_list);
  		}
++<<<<<<< HEAD
 +	} while (!result);
++=======
+ 		list_add_tail(&table_attr->node, &acpi_table_attr_list);
+ 		acpi_table_data_init(table_header);
+ 	}
+ 
++>>>>>>> 7dae6326ed76 (ACPI / sysfs: Extend ACPI sysfs to provide access to boot error region)
  	kobject_uevent(tables_kobj, KOBJ_ADD);
+ 	kobject_uevent(tables_data_kobj, KOBJ_ADD);
  	kobject_uevent(dynamic_tables_kobj, KOBJ_ADD);
 -
  	return 0;
  err_dynamic_tables:
+ 	kobject_put(tables_data_kobj);
+ err_tables_data:
  	kobject_put(tables_kobj);
  err:
  	return -ENOMEM;
* Unmerged path drivers/acpi/sysfs.c
