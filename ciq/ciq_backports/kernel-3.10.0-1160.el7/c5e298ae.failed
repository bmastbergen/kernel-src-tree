ext4: prevent ext4_quota_write() from failing due to ENOSPC

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit c5e298ae53dc2eb69f2f7153be03454c8a33c658
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/c5e298ae.failed

In order to prevent quota block tracking to be inaccurate when
ext4_quota_write() fails with ENOSPC, we make two changes.  The quota
file can now use the reserved block (since the quota file is arguably
file system metadata), and ext4_quota_write() now uses
ext4_should_retry_alloc() to retry the block allocation after a commit
has completed and released some blocks for allocation.

This fixes failures of xfstests generic/270:

Quota error (device vdc): write_blk: dquota write failed
Quota error (device vdc): qtree_write_dquot: Error -28 occurred while creating quota

	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit c5e298ae53dc2eb69f2f7153be03454c8a33c658)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/inode.c
#	fs/ext4/namei.c
#	fs/ext4/super.c
diff --cc fs/ext4/inode.c
index 8274eb8296d4,e8a67b8ba90c..000000000000
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@@ -806,34 -731,27 +806,42 @@@ int ext4_get_block(struct inode *inode
   * `handle' can be NULL if create is zero
   */
  struct buffer_head *ext4_getblk(handle_t *handle, struct inode *inode,
++<<<<<<< HEAD
 +				ext4_lblk_t block, int create, int *errp)
 +{
 +	struct ext4_map_blocks map;
 +	struct buffer_head *bh;
 +	int fatal = 0, err;
++=======
+ 				ext4_lblk_t block, int map_flags)
+ {
+ 	struct ext4_map_blocks map;
+ 	struct buffer_head *bh;
+ 	int create = map_flags & EXT4_GET_BLOCKS_CREATE;
+ 	int err;
++>>>>>>> c5e298ae53dc (ext4: prevent ext4_quota_write() from failing due to ENOSPC)
  
  	J_ASSERT(handle != NULL || create == 0);
  
  	map.m_lblk = block;
  	map.m_len = 1;
- 	err = ext4_map_blocks(handle, inode, &map,
- 			      create ? EXT4_GET_BLOCKS_CREATE : 0);
+ 	err = ext4_map_blocks(handle, inode, &map, map_flags);
  
 -	if (err == 0)
 -		return create ? ERR_PTR(-ENOSPC) : NULL;
 +	/* ensure we send some value back into *errp */
 +	*errp = 0;
 +
 +	if (create && err == 0)
 +		err = -ENOSPC;	/* should never happen */
  	if (err < 0)
 -		return ERR_PTR(err);
 +		*errp = err;
 +	if (err <= 0)
 +		return NULL;
  
  	bh = sb_getblk(inode->i_sb, map.m_pblk);
 -	if (unlikely(!bh))
 -		return ERR_PTR(-ENOMEM);
 +	if (unlikely(!bh)) {
 +		*errp = -ENOMEM;
 +		return NULL;
 +	}
  	if (map.m_flags & EXT4_MAP_NEW) {
  		J_ASSERT(create != 0);
  		J_ASSERT(handle != NULL);
@@@ -869,14 -785,17 +877,23 @@@
  }
  
  struct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,
++<<<<<<< HEAD
 +			       ext4_lblk_t block, int create, int *err)
 +{
 +	struct buffer_head *bh;
 +
 +	bh = ext4_getblk(handle, inode, block, create, err);
 +	if (!bh)
++=======
+ 			       ext4_lblk_t block, int map_flags)
+ {
+ 	struct buffer_head *bh;
+ 
+ 	bh = ext4_getblk(handle, inode, block, map_flags);
+ 	if (IS_ERR(bh))
++>>>>>>> c5e298ae53dc (ext4: prevent ext4_quota_write() from failing due to ENOSPC)
  		return bh;
 -	if (!bh || buffer_uptodate(bh))
 +	if (buffer_uptodate(bh))
  		return bh;
  	ll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);
  	wait_on_buffer(bh);
diff --cc fs/ext4/namei.c
index 573b87e45f75,e230b31251f7..000000000000
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@@ -62,9 -61,9 +62,15 @@@ static struct buffer_head *ext4_append(
  
  	*block = inode->i_size >> inode->i_sb->s_blocksize_bits;
  
++<<<<<<< HEAD
 +	bh = ext4_bread(handle, inode, *block, 1, &err);
 +	if (!bh)
 +		return ERR_PTR(err);
++=======
+ 	bh = ext4_bread(handle, inode, *block, EXT4_GET_BLOCKS_CREATE);
+ 	if (IS_ERR(bh))
+ 		return bh;
++>>>>>>> c5e298ae53dc (ext4: prevent ext4_quota_write() from failing due to ENOSPC)
  	inode->i_size += inode->i_sb->s_blocksize;
  	EXT4_I(inode)->i_disksize = inode->i_size;
  	BUFFER_TRACE(bh, "get_write_access");
diff --cc fs/ext4/super.c
index 417c0071ce41,bd4df9d379b2..000000000000
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@@ -5706,8 -5437,8 +5706,13 @@@ static ssize_t ext4_quota_write(struct 
  {
  	struct inode *inode = sb_dqopt(sb)->files[type];
  	ext4_lblk_t blk = off >> EXT4_BLOCK_SIZE_BITS(sb);
++<<<<<<< HEAD
 +	int err = 0;
 +	int offset = off & (sb->s_blocksize - 1);
++=======
+ 	int err, offset = off & (sb->s_blocksize - 1);
+ 	int retries = 0;
++>>>>>>> c5e298ae53dc (ext4: prevent ext4_quota_write() from failing due to ENOSPC)
  	struct buffer_head *bh;
  	handle_t *handle = journal_current_handle();
  
@@@ -5728,7 -5459,14 +5733,18 @@@
  		return -EIO;
  	}
  
++<<<<<<< HEAD
 +	bh = ext4_bread(handle, inode, blk, 1, &err);
++=======
+ 	do {
+ 		bh = ext4_bread(handle, inode, blk,
+ 				EXT4_GET_BLOCKS_CREATE |
+ 				EXT4_GET_BLOCKS_METADATA_NOFAIL);
+ 	} while (IS_ERR(bh) && (PTR_ERR(bh) == -ENOSPC) &&
+ 		 ext4_should_retry_alloc(inode->i_sb, &retries));
+ 	if (IS_ERR(bh))
+ 		return PTR_ERR(bh);
++>>>>>>> c5e298ae53dc (ext4: prevent ext4_quota_write() from failing due to ENOSPC)
  	if (!bh)
  		goto out;
  	BUFFER_TRACE(bh, "get write access");
diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 72233774feed..b8042631f754 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -4500,6 +4500,8 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 		ar.flags |= EXT4_MB_HINT_NOPREALLOC;
 	if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)
 		ar.flags |= EXT4_MB_DELALLOC_RESERVED;
+	if (flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)
+		ar.flags |= EXT4_MB_USE_RESERVED;
 	newblock = ext4_mb_new_blocks(handle, &ar, &err);
 	if (!newblock)
 		goto out2;
diff --git a/fs/ext4/indirect.c b/fs/ext4/indirect.c
index d34dc4de4bd2..d94e7fc2ada5 100644
--- a/fs/ext4/indirect.c
+++ b/fs/ext4/indirect.c
@@ -598,6 +598,8 @@ int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,
 		ar.flags = EXT4_MB_HINT_DATA;
 	if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)
 		ar.flags |= EXT4_MB_DELALLOC_RESERVED;
+	if (flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)
+		ar.flags |= EXT4_MB_USE_RESERVED;
 
 	ar.goal = ext4_find_goal(inode, map->m_lblk, partial);
 
* Unmerged path fs/ext4/inode.c
* Unmerged path fs/ext4/namei.c
* Unmerged path fs/ext4/super.c
