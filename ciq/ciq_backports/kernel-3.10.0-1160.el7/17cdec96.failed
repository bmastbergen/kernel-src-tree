s390/pci: Recover handle in clp_set_pci_fn()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit 17cdec960cf776b20b1fb08c622221babe591d51
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/17cdec96.failed

When we try to recover a PCI function using

    echo 1 > /sys/bus/pci/devices/<id>/recover

or manually with

    echo 1 > /sys/bus/pci/devices/<id>/remove
    echo 0 > /sys/bus/pci/slots/<slot>/power
    echo 1 > /sys/bus/pci/slots/<slot>/power

clp_disable_fn() / clp_enable_fn() call clp_set_pci_fn() to first
disable and then reenable the function.

When the function is already in the requested state we may be left with
an invalid function handle.

To get a new valid handle we do a clp_list_pci() call. For this we need
both the function ID and function handle in clp_set_pci_fn() so pass the
zdev and get both.

To simplify things also pull setting the refreshed function handle into
clp_set_pci_fn()

	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Reviewed-by: Peter Oberparleiter <oberpar@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit 17cdec960cf776b20b1fb08c622221babe591d51)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci_clp.c
diff --cc arch/s390/pci/pci_clp.c
index ccc21b6297fe,0d3d8f170ea4..000000000000
--- a/arch/s390/pci/pci_clp.c
+++ b/arch/s390/pci/pci_clp.c
@@@ -239,15 -289,21 +246,30 @@@ static int clp_set_pci_fn(struct zpci_d
  
  int clp_enable_fh(struct zpci_dev *zdev, u8 nr_dma_as)
  {
- 	u32 fh = zdev->fh;
  	int rc;
  
++<<<<<<< HEAD
 +	rc = clp_set_pci_fn(&fh, nr_dma_as, CLP_SET_ENABLE_PCI_FN);
 +	if (!rc)
 +		/* Success -> store enabled handle in zdev */
 +		zdev->fh = fh;
 +
 +	zpci_dbg(3, "ena fid:%x, fh:%x, rc:%d\n", zdev->fid, zdev->fh, rc);
++=======
+ 	rc = clp_set_pci_fn(zdev, nr_dma_as, CLP_SET_ENABLE_PCI_FN);
+ 	zpci_dbg(3, "ena fid:%x, fh:%x, rc:%d\n", zdev->fid, zdev->fh, rc);
+ 	if (rc)
+ 		goto out;
+ 
+ 	if (zpci_use_mio(zdev)) {
+ 		rc = clp_set_pci_fn(zdev, nr_dma_as, CLP_SET_ENABLE_MIO);
+ 		zpci_dbg(3, "ena mio fid:%x, fh:%x, rc:%d\n",
+ 				zdev->fid, zdev->fh, rc);
+ 		if (rc)
+ 			clp_disable_fh(zdev);
+ 	}
+ out:
++>>>>>>> 17cdec960cf7 (s390/pci: Recover handle in clp_set_pci_fn())
  	return rc;
  }
  
@@@ -259,12 -315,8 +281,17 @@@ int clp_disable_fh(struct zpci_dev *zde
  	if (!zdev_enabled(zdev))
  		return 0;
  
++<<<<<<< HEAD
 +	rc = clp_set_pci_fn(&fh, 0, CLP_SET_DISABLE_PCI_FN);
 +	if (!rc)
 +		/* Success -> store disabled handle in zdev */
 +		zdev->fh = fh;
 +
 +	zpci_dbg(3, "dis fid:%x, fh:%x, rc:%d\n", zdev->fid, zdev->fh, rc);
++=======
+ 	rc = clp_set_pci_fn(zdev, 0, CLP_SET_DISABLE_PCI_FN);
+ 	zpci_dbg(3, "dis fid:%x, fh:%x, rc:%d\n", zdev->fid, fh, rc);
++>>>>>>> 17cdec960cf7 (s390/pci: Recover handle in clp_set_pci_fn())
  	return rc;
  }
  
diff --git a/arch/s390/include/asm/pci.h b/arch/s390/include/asm/pci.h
index 77fa151cbb75..1da0480a6412 100644
--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@ -172,7 +172,7 @@ void zpci_remove_reserved_devices(void);
 /* CLP */
 int clp_scan_pci_devices(void);
 int clp_rescan_pci_devices(void);
-int clp_rescan_pci_devices_simple(void);
+int clp_rescan_pci_devices_simple(u32 *fid);
 int clp_add_pci_device(u32, u32, int);
 int clp_enable_fh(struct zpci_dev *, u8);
 int clp_disable_fh(struct zpci_dev *);
diff --git a/arch/s390/pci/pci.c b/arch/s390/pci/pci.c
index e6162ff78f3a..e3d424e9f820 100644
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@ -1145,5 +1145,5 @@ subsys_initcall_sync(pci_base_init);
 void zpci_rescan(void)
 {
 	if (zpci_is_enabled())
-		clp_rescan_pci_devices_simple();
+		clp_rescan_pci_devices_simple(NULL);
 }
* Unmerged path arch/s390/pci/pci_clp.c
