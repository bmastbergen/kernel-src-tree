gfs2: Fix problems regarding gfs2_qa_get and _put

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit 2297ab6144c2e85c418d0fd47b2f24e294b55dca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/2297ab61.failed

This patch fixes a couple of places in which gfs2_qa_get and gfs2_qa_put are
not balanced: we now keep references around whenever a file is open for writing
(see gfs2_open_common and gfs2_release), so we need to put all references we
grab in function gfs2_create_inode.  This was broken in the successful case and
on one error path.

This also means that we don't have a reference to put in gfs2_evict_inode.

In addition, gfs2_qa_put was called for the wrong inode in gfs2_link.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 2297ab6144c2e85c418d0fd47b2f24e294b55dca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/inode.c
#	fs/gfs2/super.c
diff --cc fs/gfs2/inode.c
index a7cb675316c4,5acd3ce30759..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -707,13 -757,18 +707,19 @@@ static int gfs2_create_inode(struct ino
  
  	mark_inode_dirty(inode);
  	d_instantiate(dentry, inode);
 -	/* After instantiate, errors should result in evict which will destroy
 -	 * both inode and iopen glocks properly. */
  	if (file) {
 -		file->f_mode |= FMODE_CREATED;
 -		error = finish_open(file, dentry, gfs2_open_common);
 +		*opened |= FILE_CREATED;
 +		error = finish_open(file, dentry, gfs2_open_common, opened);
  	}
  	gfs2_glock_dq_uninit(ghs);
+ 	gfs2_qa_put(ip);
  	gfs2_glock_dq_uninit(ghs + 1);
  	clear_bit(GLF_INODE_CREATING, &io_gl->gl_flags);
++<<<<<<< HEAD
++=======
+ 	gfs2_glock_put(io_gl);
+ 	gfs2_qa_put(dip);
++>>>>>>> 2297ab6144c2 (gfs2: Fix problems regarding gfs2_qa_get and _put)
  	return error;
  
  fail_gunlock3:
@@@ -953,6 -1006,7 +959,10 @@@ out_gunlock
  out_child:
  	gfs2_glock_dq(ghs);
  out_parent:
++<<<<<<< HEAD
++=======
+ 	gfs2_qa_put(dip);
++>>>>>>> 2297ab6144c2 (gfs2: Fix problems regarding gfs2_qa_get and _put)
  	gfs2_holder_uninit(ghs);
  	gfs2_holder_uninit(ghs + 1);
  	return error;
diff --cc fs/gfs2/super.c
index 6327156ef20f,956fced0a8ec..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1633,8 -1393,31 +1633,32 @@@ out_unlock
  	if (gfs2_rs_active(&ip->i_res))
  		gfs2_rs_deltree(&ip->i_res);
  
++<<<<<<< HEAD
++=======
+ 	if (gfs2_holder_initialized(&gh)) {
+ 		glock_clear_object(ip->i_gl, ip);
+ 		gfs2_glock_dq_uninit(&gh);
+ 	}
+ 	if (error && error != GLR_TRYFAILED && error != -EROFS)
+ 		fs_warn(sdp, "gfs2_evict_inode: %d\n", error);
+ out:
+ 	truncate_inode_pages_final(&inode->i_data);
+ 	if (ip->i_qadata)
+ 		gfs2_assert_warn(sdp, ip->i_qadata->qa_ref == 0);
+ 	gfs2_rs_delete(ip, NULL);
+ 	gfs2_ordered_del_inode(ip);
+ 	clear_inode(inode);
+ 	gfs2_dir_hash_inval(ip);
+ 	if (ip->i_gl) {
+ 		glock_clear_object(ip->i_gl, ip);
+ 		wait_on_bit_io(&ip->i_flags, GIF_GLOP_PENDING, TASK_UNINTERRUPTIBLE);
+ 		gfs2_glock_add_to_lru(ip->i_gl);
+ 		gfs2_glock_put_eventually(ip->i_gl);
+ 		ip->i_gl = NULL;
+ 	}
++>>>>>>> 2297ab6144c2 (gfs2: Fix problems regarding gfs2_qa_get and _put)
  	if (gfs2_holder_initialized(&ip->i_iopen_gh)) {
 -		struct gfs2_glock *gl = ip->i_iopen_gh.gh_gl;
 -
 -		glock_clear_object(gl, ip);
 +		glock_clear_object(ip->i_iopen_gh.gh_gl, ip);
  		if (test_bit(HIF_HOLDER, &ip->i_iopen_gh.gh_iflags)) {
  			ip->i_iopen_gh.gh_flags |= GL_NOCACHE;
  			gfs2_glock_dq(&ip->i_iopen_gh);
* Unmerged path fs/gfs2/inode.c
* Unmerged path fs/gfs2/super.c
