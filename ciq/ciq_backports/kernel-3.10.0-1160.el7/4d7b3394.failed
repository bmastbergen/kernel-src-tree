mm/oom_kill: fix the wrong task->mm == mm checks in oom_kill_process()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
Rebuild_CHGLOG: - [mm] mm: oom: fix the wrong task->mm == mm checks in oom_kill_process() (Rafael Aquini) [1261799]
Rebuild_FUZZ: 94.12%
commit-author Oleg Nesterov <oleg@redhat.com>
commit 4d7b3394f76ed72cfdec23ca5571dbab6ec41793
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/4d7b3394.failed

Both "child->mm == mm" and "p->mm != mm" checks in oom_kill_process() are
wrong.  task->mm can be NULL if the task is the exited group leader.  This
means in particular that "kill sharing same memory" loop can miss a
process with a zombie leader which uses the same ->mm.

Note: the process_has_mm(child, p->mm) check is still not 100% correct,
p->mm can be NULL too.  This is minor, but probably deserves a fix or a
comment anyway.

[akpm@linux-foundation.org: document process_shares_mm() a bit]
	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Acked-by: David Rientjes <rientjes@google.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Cc: Kyle Walker <kwalker@redhat.com>
	Cc: Stanislav Kozina <skozina@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 4d7b3394f76ed72cfdec23ca5571dbab6ec41793)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/oom_kill.c
diff --cc mm/oom_kill.c
index cb09e6224089,e4778285d8d1..000000000000
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@@ -398,22 -392,106 +398,40 @@@ static void dump_header(struct task_str
  }
  
  /*
 - * Number of OOM victims in flight
 + * Number of OOM killer invocations (including memcg OOM killer).
 + * Primarily used by PM freezer to check for potential races with
 + * OOM killed frozen task.
   */
 -static atomic_t oom_victims = ATOMIC_INIT(0);
 -static DECLARE_WAIT_QUEUE_HEAD(oom_victims_wait);
 -
 -bool oom_killer_disabled __read_mostly;
 +static atomic_t oom_kills = ATOMIC_INIT(0);
  
 -/**
 - * mark_oom_victim - mark the given task as OOM victim
 - * @tsk: task to mark
 - *
 - * Has to be called with oom_lock held and never after
 - * oom has been disabled already.
 - */
 -void mark_oom_victim(struct task_struct *tsk)
 +int oom_kills_count(void)
  {
 -	WARN_ON(oom_killer_disabled);
 -	/* OOM killer might race with memcg OOM */
 -	if (test_and_set_tsk_thread_flag(tsk, TIF_MEMDIE))
 -		return;
 -	/*
 -	 * Make sure that the task is woken up from uninterruptible sleep
 -	 * if it is frozen because OOM killer wouldn't be able to free
 -	 * any memory and livelock. freezing_slow_path will tell the freezer
 -	 * that TIF_MEMDIE tasks should be ignored.
 -	 */
 -	__thaw_task(tsk);
 -	atomic_inc(&oom_victims);
 +	return atomic_read(&oom_kills);
  }
  
 -/**
 - * exit_oom_victim - note the exit of an OOM victim
 - */
 -void exit_oom_victim(void)
 +void note_oom_kill(void)
  {
 -	clear_thread_flag(TIF_MEMDIE);
 -
 -	if (!atomic_dec_return(&oom_victims))
 -		wake_up_all(&oom_victims_wait);
 -}
 -
 -/**
 - * oom_killer_disable - disable OOM killer
 - *
 - * Forces all page allocations to fail rather than trigger OOM killer.
 - * Will block and wait until all OOM victims are killed.
 - *
 - * The function cannot be called when there are runnable user tasks because
 - * the userspace would see unexpected allocation failures as a result. Any
 - * new usage of this function should be consulted with MM people.
 - *
 - * Returns true if successful and false if the OOM killer cannot be
 - * disabled.
 - */
 -bool oom_killer_disable(void)
 -{
 -	/*
 -	 * Make sure to not race with an ongoing OOM killer
 -	 * and that the current is not the victim.
 -	 */
 -	mutex_lock(&oom_lock);
 -	if (test_thread_flag(TIF_MEMDIE)) {
 -		mutex_unlock(&oom_lock);
 -		return false;
 -	}
 -
 -	oom_killer_disabled = true;
 -	mutex_unlock(&oom_lock);
 -
 -	wait_event(oom_victims_wait, !atomic_read(&oom_victims));
 -
 -	return true;
 -}
 -
 -/**
 - * oom_killer_enable - enable OOM killer
 - */
 -void oom_killer_enable(void)
 -{
 -	oom_killer_disabled = false;
 +	atomic_inc(&oom_kills);
  }
  
+ /*
+  * task->mm can be NULL if the task is the exited group leader.  So to
+  * determine whether the task is using a particular mm, we examine all the
+  * task's threads: if one of those is using this mm then this task was also
+  * using it.
+  */
+ static bool process_shares_mm(struct task_struct *p, struct mm_struct *mm)
+ {
+ 	struct task_struct *t;
+ 
+ 	for_each_thread(p, t) {
+ 		struct mm_struct *t_mm = READ_ONCE(t->mm);
+ 		if (t_mm)
+ 			return t_mm == mm;
+ 	}
+ 	return false;
+ }
+ 
  #define K(x) ((x) << (PAGE_SHIFT-10))
  /*
   * Must be called while holding a reference to p, which will be released upon
@@@ -516,22 -592,21 +534,34 @@@ void oom_kill_process(struct task_struc
  	 * pending fatal signal.
  	 */
  	rcu_read_lock();
++<<<<<<< HEAD
 +	for_each_process(p)
 +		if (p->mm == mm && !same_thread_group(p, victim) &&
 +		    !(p->flags & PF_KTHREAD)) {
 +			if (p->signal->oom_score_adj == OOM_SCORE_ADJ_MIN)
 +				continue;
++=======
+ 	for_each_process(p) {
+ 		if (!process_shares_mm(p, mm))
+ 			continue;
+ 		if (same_thread_group(p, victim))
+ 			continue;
+ 		if (unlikely(p->flags & PF_KTHREAD))
+ 			continue;
+ 		if (p->signal->oom_score_adj == OOM_SCORE_ADJ_MIN)
+ 			continue;
++>>>>>>> 4d7b3394f76e (mm/oom_kill: fix the wrong task->mm == mm checks in oom_kill_process())
  
 -		do_send_sig_info(SIGKILL, SEND_SIG_FORCED, p, true);
 -	}
 +			task_lock(p);	/* Protect ->comm from prctl() */
 +			pr_err("Kill process %d (%s) sharing same memory\n",
 +				task_pid_nr(p), p->comm);
 +			task_unlock(p);
 +			do_send_sig_info(SIGKILL, SEND_SIG_FORCED, p, true);
 +		}
  	rcu_read_unlock();
  
 -	mmdrop(mm);
 +	set_tsk_thread_flag(victim, TIF_MEMDIE);
 +	do_send_sig_info(SIGKILL, SEND_SIG_FORCED, victim, true);
  	put_task_struct(victim);
  }
  #undef K
* Unmerged path mm/oom_kill.c
