s390/diag: add tracepoint for diagnose calls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Martin Schwidefsky <schwidefsky@de.ibm.com>
commit b5a6b71b1901b9ca495f669c9ad86f2181960aba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/b5a6b71b.failed

To be able to analyse problems in regard to hypervisor overhead
add a tracepoing for diagnose calls. It reports the number of
the diagnose issued, e.g.

            sshd-1385  [002] ....    42.701431: diagnose: nr=0x9c
          <idle>-0     [001] ..s.    43.587528: diagnose: nr=0x9c

	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit b5a6b71b1901b9ca495f669c9ad86f2181960aba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/diag.h
#	arch/s390/kernel/diag.c
#	arch/s390/kernel/smp.c
diff --cc arch/s390/include/asm/diag.h
index 1aa8265588bf,5fac921c1c42..000000000000
--- a/arch/s390/include/asm/diag.h
+++ b/arch/s390/include/asm/diag.h
@@@ -8,7 -8,33 +8,37 @@@
  #ifndef _ASM_S390_DIAG_H
  #define _ASM_S390_DIAG_H
  
++<<<<<<< HEAD
 +#include <linux/if_ether.h>
++=======
+ #include <linux/percpu.h>
+ 
+ enum diag_stat_enum {
+ 	DIAG_STAT_X008,
+ 	DIAG_STAT_X00C,
+ 	DIAG_STAT_X010,
+ 	DIAG_STAT_X014,
+ 	DIAG_STAT_X044,
+ 	DIAG_STAT_X064,
+ 	DIAG_STAT_X09C,
+ 	DIAG_STAT_X0DC,
+ 	DIAG_STAT_X204,
+ 	DIAG_STAT_X210,
+ 	DIAG_STAT_X224,
+ 	DIAG_STAT_X250,
+ 	DIAG_STAT_X258,
+ 	DIAG_STAT_X288,
+ 	DIAG_STAT_X2C4,
+ 	DIAG_STAT_X2FC,
+ 	DIAG_STAT_X304,
+ 	DIAG_STAT_X308,
+ 	DIAG_STAT_X500,
+ 	NR_DIAG_STAT
+ };
+ 
+ void diag_stat_inc(enum diag_stat_enum nr);
+ void diag_stat_inc_norecursion(enum diag_stat_enum nr);
++>>>>>>> b5a6b71b1901 (s390/diag: add tracepoint for diagnose calls)
  
  /*
   * Diagnose 10: Release page range
diff --cc arch/s390/kernel/diag.c
index 55dee28dda39,f98766ede4e1..000000000000
--- a/arch/s390/kernel/diag.c
+++ b/arch/s390/kernel/diag.c
@@@ -6,8 -6,132 +6,132 @@@
   */
  
  #include <linux/module.h>
 -#include <linux/cpu.h>
 -#include <linux/seq_file.h>
 -#include <linux/debugfs.h>
  #include <asm/diag.h>
+ #include <asm/trace/diag.h>
  
++<<<<<<< HEAD
++=======
+ struct diag_stat {
+ 	unsigned int counter[NR_DIAG_STAT];
+ };
+ 
+ static DEFINE_PER_CPU(struct diag_stat, diag_stat);
+ 
+ struct diag_desc {
+ 	int code;
+ 	char *name;
+ };
+ 
+ static const struct diag_desc diag_map[NR_DIAG_STAT] = {
+ 	[DIAG_STAT_X008] = { .code = 0x008, .name = "Console Function" },
+ 	[DIAG_STAT_X00C] = { .code = 0x00c, .name = "Pseudo Timer" },
+ 	[DIAG_STAT_X010] = { .code = 0x010, .name = "Release Pages" },
+ 	[DIAG_STAT_X014] = { .code = 0x014, .name = "Spool File Services" },
+ 	[DIAG_STAT_X044] = { .code = 0x044, .name = "Voluntary Timeslice End" },
+ 	[DIAG_STAT_X064] = { .code = 0x064, .name = "NSS Manipulation" },
+ 	[DIAG_STAT_X09C] = { .code = 0x09c, .name = "Relinquish Timeslice" },
+ 	[DIAG_STAT_X0DC] = { .code = 0x0dc, .name = "Appldata Control" },
+ 	[DIAG_STAT_X204] = { .code = 0x204, .name = "Logical-CPU Utilization" },
+ 	[DIAG_STAT_X210] = { .code = 0x210, .name = "Device Information" },
+ 	[DIAG_STAT_X224] = { .code = 0x224, .name = "EBCDIC-Name Table" },
+ 	[DIAG_STAT_X250] = { .code = 0x250, .name = "Block I/O" },
+ 	[DIAG_STAT_X258] = { .code = 0x258, .name = "Page-Reference Services" },
+ 	[DIAG_STAT_X288] = { .code = 0x288, .name = "Time Bomb" },
+ 	[DIAG_STAT_X2C4] = { .code = 0x2c4, .name = "FTP Services" },
+ 	[DIAG_STAT_X2FC] = { .code = 0x2fc, .name = "Guest Performance Data" },
+ 	[DIAG_STAT_X304] = { .code = 0x304, .name = "Partition-Resource Service" },
+ 	[DIAG_STAT_X308] = { .code = 0x308, .name = "List-Directed IPL" },
+ 	[DIAG_STAT_X500] = { .code = 0x500, .name = "Virtio Service" },
+ };
+ 
+ static int show_diag_stat(struct seq_file *m, void *v)
+ {
+ 	struct diag_stat *stat;
+ 	unsigned long n = (unsigned long) v - 1;
+ 	int cpu, prec, tmp;
+ 
+ 	get_online_cpus();
+ 	if (n == 0) {
+ 		seq_puts(m, "         ");
+ 
+ 		for_each_online_cpu(cpu) {
+ 			prec = 10;
+ 			for (tmp = 10; cpu >= tmp; tmp *= 10)
+ 				prec--;
+ 			seq_printf(m, "%*s%d", prec, "CPU", cpu);
+ 		}
+ 		seq_putc(m, '\n');
+ 	} else if (n <= NR_DIAG_STAT) {
+ 		seq_printf(m, "diag %03x:", diag_map[n-1].code);
+ 		for_each_online_cpu(cpu) {
+ 			stat = &per_cpu(diag_stat, cpu);
+ 			seq_printf(m, " %10u", stat->counter[n-1]);
+ 		}
+ 		seq_printf(m, "    %s\n", diag_map[n-1].name);
+ 	}
+ 	put_online_cpus();
+ 	return 0;
+ }
+ 
+ static void *show_diag_stat_start(struct seq_file *m, loff_t *pos)
+ {
+ 	return *pos <= nr_cpu_ids ? (void *)((unsigned long) *pos + 1) : NULL;
+ }
+ 
+ static void *show_diag_stat_next(struct seq_file *m, void *v, loff_t *pos)
+ {
+ 	++*pos;
+ 	return show_diag_stat_start(m, pos);
+ }
+ 
+ static void show_diag_stat_stop(struct seq_file *m, void *v)
+ {
+ }
+ 
+ static const struct seq_operations show_diag_stat_sops = {
+ 	.start	= show_diag_stat_start,
+ 	.next	= show_diag_stat_next,
+ 	.stop	= show_diag_stat_stop,
+ 	.show	= show_diag_stat,
+ };
+ 
+ static int show_diag_stat_open(struct inode *inode, struct file *file)
+ {
+ 	return seq_open(file, &show_diag_stat_sops);
+ }
+ 
+ static const struct file_operations show_diag_stat_fops = {
+ 	.open		= show_diag_stat_open,
+ 	.read		= seq_read,
+ 	.llseek		= seq_lseek,
+ 	.release	= seq_release,
+ };
+ 
+ 
+ static int __init show_diag_stat_init(void)
+ {
+ 	debugfs_create_file("diag_stat", 0400, NULL, NULL,
+ 			    &show_diag_stat_fops);
+ 	return 0;
+ }
+ 
+ device_initcall(show_diag_stat_init);
+ 
+ void diag_stat_inc(enum diag_stat_enum nr)
+ {
+ 	this_cpu_inc(diag_stat.counter[nr]);
+ 	trace_diagnose(diag_map[nr].code);
+ }
+ EXPORT_SYMBOL(diag_stat_inc);
+ 
+ void diag_stat_inc_norecursion(enum diag_stat_enum nr)
+ {
+ 	this_cpu_inc(diag_stat.counter[nr]);
+ 	trace_diagnose_norecursion(diag_map[nr].code);
+ }
+ EXPORT_SYMBOL(diag_stat_inc_norecursion);
+ 
++>>>>>>> b5a6b71b1901 (s390/diag: add tracepoint for diagnose calls)
  /*
   * Diagnose 14: Input spool file manipulation
   */
diff --cc arch/s390/kernel/smp.c
index 059e25724051,dbd40d448294..000000000000
--- a/arch/s390/kernel/smp.c
+++ b/arch/s390/kernel/smp.c
@@@ -428,19 -374,16 +428,28 @@@ int smp_vcpu_scheduled(int cpu
  	return pcpu_running(pcpu_devices + cpu);
  }
  
 +void smp_yield(void)
 +{
 +	if (!smp_cpu_mtid && MACHINE_HAS_DIAG44)
 +		asm volatile("diag 0,0,0x44");
 +}
 +
  void smp_yield_cpu(int cpu)
  {
++<<<<<<< HEAD
 +	if (MACHINE_HAS_DIAG9C)
 +		asm volatile("diag %0,0,0x9c"
 +			     : : "d" (pcpu_devices[cpu].address));
 +	else if (MACHINE_HAS_DIAG44)
++=======
+ 	if (MACHINE_HAS_DIAG9C) {
+ 		diag_stat_inc_norecursion(DIAG_STAT_X09C);
+ 		asm volatile("diag %0,0,0x9c"
+ 			     : : "d" (pcpu_devices[cpu].address));
+ 	} else if (MACHINE_HAS_DIAG44) {
+ 		diag_stat_inc_norecursion(DIAG_STAT_X044);
++>>>>>>> b5a6b71b1901 (s390/diag: add tracepoint for diagnose calls)
  		asm volatile("diag 0,0,0x44");
 -	}
  }
  
  /*
* Unmerged path arch/s390/include/asm/diag.h
diff --git a/arch/s390/include/asm/trace/diag.h b/arch/s390/include/asm/trace/diag.h
new file mode 100644
index 000000000000..776f307960cc
--- /dev/null
+++ b/arch/s390/include/asm/trace/diag.h
@@ -0,0 +1,43 @@
+/*
+ * Tracepoint header for s390 diagnose calls
+ *
+ * Copyright IBM Corp. 2015
+ * Author(s): Martin Schwidefsky <schwidefsky@de.ibm.com>
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM s390
+
+#if !defined(_TRACE_S390_DIAG_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_S390_DIAG_H
+
+#include <linux/tracepoint.h>
+
+#undef TRACE_INCLUDE_PATH
+#undef TRACE_INCLUDE_FILE
+
+#define TRACE_INCLUDE_PATH asm/trace
+#define TRACE_INCLUDE_FILE diag
+
+TRACE_EVENT(diagnose,
+	TP_PROTO(unsigned short nr),
+	TP_ARGS(nr),
+	TP_STRUCT__entry(
+		__field(unsigned short, nr)
+	),
+	TP_fast_assign(
+		__entry->nr = nr;
+	),
+	TP_printk("nr=0x%x", __entry->nr)
+);
+
+#ifdef CONFIG_TRACEPOINTS
+void trace_diagnose_norecursion(int diag_nr);
+#else
+static inline void trace_diagnose_norecursion(int diag_nr) { }
+#endif
+
+#endif /* _TRACE_S390_DIAG_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/arch/s390/kernel/Makefile b/arch/s390/kernel/Makefile
index 0fcf5012a320..25efd9148cd1 100644
--- a/arch/s390/kernel/Makefile
+++ b/arch/s390/kernel/Makefile
@@ -69,6 +69,8 @@ obj-y				+= runtime_instr.o cache.o
 endif
 obj-$(CONFIG_PROTECTED_VIRTUALIZATION_GUEST)	+= uv.o
 
+obj-$(CONFIG_TRACEPOINTS)	+= trace.o
+
 # vdso
 obj-$(CONFIG_64BIT)		+= vdso64/
 obj-$(CONFIG_32BIT)		+= vdso32/
* Unmerged path arch/s390/kernel/diag.c
* Unmerged path arch/s390/kernel/smp.c
diff --git a/arch/s390/kernel/trace.c b/arch/s390/kernel/trace.c
new file mode 100644
index 000000000000..73239bb576c4
--- /dev/null
+++ b/arch/s390/kernel/trace.c
@@ -0,0 +1,29 @@
+/*
+ * Tracepoint definitions for s390
+ *
+ * Copyright IBM Corp. 2015
+ * Author(s): Martin Schwidefsky <schwidefsky@de.ibm.com>
+ */
+
+#include <linux/percpu.h>
+#define CREATE_TRACE_POINTS
+#include <asm/trace/diag.h>
+
+EXPORT_TRACEPOINT_SYMBOL(diagnose);
+
+static DEFINE_PER_CPU(unsigned int, diagnose_trace_depth);
+
+void trace_diagnose_norecursion(int diag_nr)
+{
+	unsigned long flags;
+	unsigned int *depth;
+
+	local_irq_save(flags);
+	depth = this_cpu_ptr(&diagnose_trace_depth);
+	if (*depth == 0) {
+		(*depth)++;
+		trace_diagnose(diag_nr);
+		(*depth)--;
+	}
+	local_irq_restore(flags);
+}
