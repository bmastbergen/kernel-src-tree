net_sched: let qdisc_put() accept NULL pointer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Cong Wang <xiyou.wangcong@gmail.com>
commit 6efb971ba8edfbd80b666f29de12882852f095ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/6efb971b.failed

When tcf_block_get() fails in sfb_init(), q->qdisc is still a NULL
pointer which leads to a crash in sfb_destroy(). Similar for
sch_dsmark.

Instead of fixing each separately, Linus suggested to just accept
NULL pointer in qdisc_put(), which would make callers easier.

(For sch_dsmark, the bug probably exists long before commit
6529eaba33f0.)

Fixes: 6529eaba33f0 ("net: sched: introduce tcf block infractructure")
	Reported-by: syzbot+d5870a903591faaca4ae@syzkaller.appspotmail.com
	Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Cc: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6efb971ba8edfbd80b666f29de12882852f095ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_generic.c
diff --cc net/sched/sch_generic.c
index 7972f293cc6a,17bd8f539bc7..000000000000
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@@ -776,11 -970,47 +776,43 @@@ void qdisc_destroy(struct Qdisc *qdisc
  	module_put(ops->owner);
  	dev_put(qdisc_dev(qdisc));
  
 -	skb_queue_walk_safe(&qdisc->gso_skb, skb, tmp) {
 -		__skb_unlink(skb, &qdisc->gso_skb);
 -		kfree_skb_list(skb);
 -	}
 -
 -	skb_queue_walk_safe(&qdisc->skb_bad_txq, skb, tmp) {
 -		__skb_unlink(skb, &qdisc->skb_bad_txq);
 -		kfree_skb_list(skb);
 -	}
 -
 -	call_rcu(&qdisc->rcu, qdisc_free_cb);
 +	kfree_skb_list(qdisc->gso_skb);
 +	kfree_skb(qdisc->skb_bad_txq);
 +	qdisc_free(qdisc);
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(qdisc_destroy);
++=======
+ 
+ void qdisc_put(struct Qdisc *qdisc)
+ {
+ 	if (!qdisc)
+ 		return;
+ 
+ 	if (qdisc->flags & TCQ_F_BUILTIN ||
+ 	    !refcount_dec_and_test(&qdisc->refcnt))
+ 		return;
+ 
+ 	qdisc_destroy(qdisc);
+ }
+ EXPORT_SYMBOL(qdisc_put);
+ 
+ /* Version of qdisc_put() that is called with rtnl mutex unlocked.
+  * Intended to be used as optimization, this function only takes rtnl lock if
+  * qdisc reference counter reached zero.
+  */
+ 
+ void qdisc_put_unlocked(struct Qdisc *qdisc)
+ {
+ 	if (qdisc->flags & TCQ_F_BUILTIN ||
+ 	    !refcount_dec_and_rtnl_lock(&qdisc->refcnt))
+ 		return;
+ 
+ 	qdisc_destroy(qdisc);
+ 	rtnl_unlock();
+ }
+ EXPORT_SYMBOL(qdisc_put_unlocked);
++>>>>>>> 6efb971ba8ed (net_sched: let qdisc_put() accept NULL pointer)
  
  /* Attach toplevel qdisc to device queue. */
  struct Qdisc *dev_graft_qdisc(struct netdev_queue *dev_queue,
* Unmerged path net/sched/sch_generic.c
