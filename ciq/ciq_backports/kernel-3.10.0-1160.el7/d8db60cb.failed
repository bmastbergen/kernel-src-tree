selinux: ensure we cleanup the internal AVC counters on error in avc_insert()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Paul Moore <paul@paul-moore.com>
commit d8db60cb23e49a92cf8cada3297395c7fa50fdf8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/d8db60cb.failed

Fix avc_insert() to call avc_node_kill() if we've already allocated
an AVC node and the code fails to insert the node in the cache.

Fixes: fa1aa143ac4a ("selinux: extended permissions for ioctls")
	Reported-by: rsiddoji@codeaurora.org
	Suggested-by: Stephen Smalley <sds@tycho.nsa.gov>
	Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit d8db60cb23e49a92cf8cada3297395c7fa50fdf8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/avc.c
diff --cc security/selinux/avc.c
index ebd563b83eac,6646300f7ccb..000000000000
--- a/security/selinux/avc.c
+++ b/security/selinux/avc.c
@@@ -662,40 -617,37 +662,71 @@@ static struct avc_node *avc_insert(u32 
  	struct avc_node *pos, *node = NULL;
  	int hvalue;
  	unsigned long flag;
+ 	spinlock_t *lock;
+ 	struct hlist_head *head;
  
++<<<<<<< HEAD
 +	if (avc_latest_notif_update(avd->seqno, 1))
 +		goto out;
 +
 +	node = avc_alloc_node();
 +	if (node) {
 +		struct hlist_head *head;
 +		spinlock_t *lock;
 +		int rc = 0;
 +
 +		hvalue = avc_hash(ssid, tsid, tclass);
 +		avc_node_populate(node, ssid, tsid, tclass, avd);
 +		rc = avc_xperms_populate(node, xp_node);
 +		if (rc) {
 +			kmem_cache_free(avc_node_cachep, node);
 +			return NULL;
 +		}
 +		head = &avc_cache.slots[hvalue];
 +		lock = &avc_cache.slots_lock[hvalue];
 +
 +		spin_lock_irqsave(lock, flag);
 +		hlist_for_each_entry(pos, head, list) {
 +			if (pos->ae.ssid == ssid &&
 +			    pos->ae.tsid == tsid &&
 +			    pos->ae.tclass == tclass) {
 +				avc_node_replace(node, pos);
 +				goto found;
 +			}
 +		}
 +		hlist_add_head_rcu(&node->list, head);
 +found:
 +		spin_unlock_irqrestore(lock, flag);
++=======
+ 	if (avc_latest_notif_update(avc, avd->seqno, 1))
+ 		return NULL;
+ 
+ 	node = avc_alloc_node(avc);
+ 	if (!node)
+ 		return NULL;
+ 
+ 	avc_node_populate(node, ssid, tsid, tclass, avd);
+ 	if (avc_xperms_populate(node, xp_node)) {
+ 		avc_node_kill(avc, node);
+ 		return NULL;
++>>>>>>> d8db60cb23e4 (selinux: ensure we cleanup the internal AVC counters on error in avc_insert())
  	}
- out:
+ 
+ 	hvalue = avc_hash(ssid, tsid, tclass);
+ 	head = &avc->avc_cache.slots[hvalue];
+ 	lock = &avc->avc_cache.slots_lock[hvalue];
+ 	spin_lock_irqsave(lock, flag);
+ 	hlist_for_each_entry(pos, head, list) {
+ 		if (pos->ae.ssid == ssid &&
+ 			pos->ae.tsid == tsid &&
+ 			pos->ae.tclass == tclass) {
+ 			avc_node_replace(avc, node, pos);
+ 			goto found;
+ 		}
+ 	}
+ 	hlist_add_head_rcu(&node->list, head);
+ found:
+ 	spin_unlock_irqrestore(lock, flag);
  	return node;
  }
  
* Unmerged path security/selinux/avc.c
