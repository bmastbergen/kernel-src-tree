scsi: target: iscsi: tie the challenge length to the hash digest size

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Maurizio Lombardi <mlombard@redhat.com>
commit 19f5f88ed779180f16e236949e18389a0dca4aae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/19f5f88e.failed

Link: https://lore.kernel.org/r/20191017131037.9903-3-mlombard@redhat.com
	Signed-off-by: Maurizio Lombardi <mlombard@redhat.com>
	Tested-by: Chris Leech <cleech@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 19f5f88ed779180f16e236949e18389a0dca4aae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/iscsi/iscsi_target_auth.c
#	drivers/target/iscsi/iscsi_target_auth.h
diff --cc drivers/target/iscsi/iscsi_target_auth.c
index cc9294c1362f,f3973ab19da2..000000000000
--- a/drivers/target/iscsi/iscsi_target_auth.c
+++ b/drivers/target/iscsi/iscsi_target_auth.c
@@@ -32,14 -40,22 +32,30 @@@ static void chap_gen_challenge
  	char *c_str,
  	unsigned int *c_len)
  {
++<<<<<<< HEAD
 +	unsigned char challenge_asciihex[CHAP_CHALLENGE_LENGTH * 2 + 1];
++=======
+ 	int ret;
+ 	unsigned char *challenge_asciihex;
++>>>>>>> 19f5f88ed779 (scsi: target: iscsi: tie the challenge length to the hash digest size)
  	struct iscsi_chap *chap = conn->auth_protocol;
  
- 	memset(challenge_asciihex, 0, CHAP_CHALLENGE_LENGTH * 2 + 1);
+ 	challenge_asciihex = kzalloc(chap->challenge_len * 2 + 1, GFP_KERNEL);
+ 	if (!challenge_asciihex)
+ 		return -ENOMEM;
  
++<<<<<<< HEAD
 +	get_random_bytes(chap->challenge, CHAP_CHALLENGE_LENGTH);
++=======
+ 	memset(chap->challenge, 0, MAX_CHAP_CHALLENGE_LEN);
+ 
+ 	ret = get_random_bytes_wait(chap->challenge, chap->challenge_len);
+ 	if (unlikely(ret))
+ 		goto out;
+ 
++>>>>>>> 19f5f88ed779 (scsi: target: iscsi: tie the challenge length to the hash digest size)
  	bin2hex(challenge_asciihex, chap->challenge,
- 				CHAP_CHALLENGE_LENGTH);
+ 				chap->challenge_len);
  	/*
  	 * Set CHAP_C, and copy the generated challenge into c_str.
  	 */
@@@ -48,6 -64,22 +64,25 @@@
  
  	pr_debug("[%s] Sending CHAP_C=0x%s\n\n", (caller) ? "server" : "client",
  			challenge_asciihex);
++<<<<<<< HEAD
++=======
+ 
+ out:
+ 	kfree(challenge_asciihex);
+ 	return ret;
+ }
+ 
+ static int chap_test_algorithm(const char *name)
+ {
+ 	struct crypto_shash *tfm;
+ 
+ 	tfm = crypto_alloc_shash(name, 0, 0);
+ 	if (IS_ERR(tfm))
+ 		return -1;
+ 
+ 	crypto_free_shash(tfm);
+ 	return 0;
++>>>>>>> 19f5f88ed779 (scsi: target: iscsi: tie the challenge length to the hash digest size)
  }
  
  static int chap_check_algorithm(const char *a_str)
@@@ -132,6 -177,16 +167,19 @@@ static struct iscsi_chap *chap_server_o
  		return NULL;
  	}
  
++<<<<<<< HEAD
++=======
+ 	chap->digest_name = chap_get_digest_name(digest_type);
+ 
+ 	/* Tie the challenge length to the digest size */
+ 	chap->challenge_len = chap->digest_size;
+ 
+ 	pr_debug("[server] Got CHAP_A=%d\n", digest_type);
+ 	*aic_len = sprintf(aic_str, "CHAP_A=%d", digest_type);
+ 	*aic_len += 1;
+ 	pr_debug("[server] Sending CHAP_A=%d\n", digest_type);
+ 
++>>>>>>> 19f5f88ed779 (scsi: target: iscsi: tie the challenge length to the hash digest size)
  	/*
  	 * Set Identifier.
  	 */
@@@ -273,15 -351,17 +321,29 @@@ static int chap_server_compute_md5
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	bin2hex(response, server_digest, MD5_SIGNATURE_SIZE);
 +	pr_debug("[server] MD5 Server Digest: %s\n", response);
 +
 +	if (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {
 +		pr_debug("[server] MD5 Digests do not match!\n\n");
 +		goto out;
 +	} else
 +		pr_debug("[server] MD5 Digests match, CHAP connetication"
 +				" successful.\n\n");
++=======
+ 	bin2hex(response, server_digest, chap->digest_size);
+ 	pr_debug("[server] %s Server Digest: %s\n",
+ 		chap->digest_name, response);
+ 
+ 	if (memcmp(server_digest, client_digest, chap->digest_size) != 0) {
+ 		pr_debug("[server] %s Digests do not match!\n\n",
+ 			chap->digest_name);
+ 		goto out;
+ 	} else
+ 		pr_debug("[server] %s Digests match, CHAP connection"
+ 				" successful.\n\n", chap->digest_name);
++>>>>>>> 19f5f88ed779 (scsi: target: iscsi: tie the challenge length to the hash digest size)
  	/*
  	 * One way authentication has succeeded, return now if mutual
  	 * authentication is not enabled.
diff --cc drivers/target/iscsi/iscsi_target_auth.h
index d22f7b96a06c,fc75c1c20e23..000000000000
--- a/drivers/target/iscsi/iscsi_target_auth.h
+++ b/drivers/target/iscsi/iscsi_target_auth.h
@@@ -1,13 -1,18 +1,13 @@@
  #ifndef _ISCSI_CHAP_H_
  #define _ISCSI_CHAP_H_
  
 -#include <linux/types.h>
 -
  #define CHAP_DIGEST_UNKNOWN	0
  #define CHAP_DIGEST_MD5		5
 -#define CHAP_DIGEST_SHA1	6
 -#define CHAP_DIGEST_SHA256	7
 -#define CHAP_DIGEST_SHA3_256	8
 +#define CHAP_DIGEST_SHA		6
  
- #define CHAP_CHALLENGE_LENGTH	16
+ #define MAX_CHAP_CHALLENGE_LEN	32
  #define CHAP_CHALLENGE_STR_LEN	4096
 -#define MAX_RESPONSE_LENGTH	128	/* sufficient for SHA3 256 */
 +#define MAX_RESPONSE_LENGTH	64	/* sufficient for MD5 */
  #define	MAX_CHAP_N_SIZE		512
  
  #define MD5_SIGNATURE_SIZE	16	/* 16 bytes in a MD5 message digest */
@@@ -22,9 -33,11 +22,16 @@@ extern u32 chap_main_loop(struct iscsi_
  				int *, int *);
  
  struct iscsi_chap {
 +	unsigned char	digest_type;
  	unsigned char	id;
++<<<<<<< HEAD
 +	unsigned char	challenge[CHAP_CHALLENGE_LENGTH];
++=======
+ 	unsigned char	challenge[MAX_CHAP_CHALLENGE_LEN];
+ 	unsigned int	challenge_len;
+ 	unsigned char	*digest_name;
+ 	unsigned int	digest_size;
++>>>>>>> 19f5f88ed779 (scsi: target: iscsi: tie the challenge length to the hash digest size)
  	unsigned int	authenticate_target;
  	unsigned int	chap_state;
  } ____cacheline_aligned;
* Unmerged path drivers/target/iscsi/iscsi_target_auth.c
* Unmerged path drivers/target/iscsi/iscsi_target_auth.h
