macvlan: return correct error value

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Matteo Croce <mcroce@redhat.com>
commit 59f997b088d26a774958cb7b17b0763cd82de7ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/59f997b0.failed

A MAC address must be unique among all the macvlan devices with the same
lower device. The only exception is the passthru [sic] mode,
which shares the lower device address.

When duplicate addresses are detected, EBUSY is returned when bringing
the interface up:

    # ip link add macvlan0 link eth0 type macvlan
    # read addr </sys/class/net/eth0/address
    # ip link set macvlan0 address $addr
    # ip link set macvlan0 up
    RTNETLINK answers: Device or resource busy

Use correct error code which is EADDRINUSE, and do the check also
earlier, on address change:

    # ip link set macvlan0 address $addr
    RTNETLINK answers: Address already in use

	Signed-off-by: Matteo Croce <mcroce@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 59f997b088d26a774958cb7b17b0763cd82de7ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/macvlan.c
diff --cc drivers/net/macvlan.c
index 4405cc3b198c,0da3d36b283b..000000000000
--- a/drivers/net/macvlan.c
+++ b/drivers/net/macvlan.c
@@@ -423,20 -608,7 +423,24 @@@ static int macvlan_open(struct net_devi
  		goto hash_add;
  	}
  
++<<<<<<< HEAD
 +	if (lowerdev->features & NETIF_F_HW_L2FW_DOFFLOAD) {
 +		vlan->fwd_priv =
 +		      get_ndo_ext(lowerdev->netdev_ops, ndo_dfwd_add_station)(lowerdev, dev);
 +
 +		/* If we get a NULL pointer back, or if we get an error
 +		 * then we should just fall through to the non accelerated path
 +		 */
 +		if (IS_ERR_OR_NULL(vlan->fwd_priv)) {
 +			vlan->fwd_priv = NULL;
 +		} else
 +			return 0;
 +	}
 +
 +	err = -EBUSY;
++=======
+ 	err = -EADDRINUSE;
++>>>>>>> 59f997b088d2 (macvlan: return correct error value)
  	if (macvlan_addr_busy(vlan->port, dev->dev_addr))
  		goto out;
  
@@@ -495,6 -693,43 +499,46 @@@ hash_del
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int macvlan_sync_address(struct net_device *dev, unsigned char *addr)
+ {
+ 	struct macvlan_dev *vlan = netdev_priv(dev);
+ 	struct net_device *lowerdev = vlan->lowerdev;
+ 	struct macvlan_port *port = vlan->port;
+ 	int err;
+ 
+ 	if (!(dev->flags & IFF_UP)) {
+ 		/* Just copy in the new address */
+ 		ether_addr_copy(dev->dev_addr, addr);
+ 	} else {
+ 		/* Rehash and update the device filters */
+ 		if (macvlan_addr_busy(vlan->port, addr))
+ 			return -EADDRINUSE;
+ 
+ 		if (!macvlan_passthru(port)) {
+ 			err = dev_uc_add(lowerdev, addr);
+ 			if (err)
+ 				return err;
+ 
+ 			dev_uc_del(lowerdev, dev->dev_addr);
+ 		}
+ 
+ 		macvlan_hash_change_addr(vlan, addr);
+ 	}
+ 	if (macvlan_passthru(port) && !macvlan_addr_change(port)) {
+ 		/* Since addr_change isn't set, we are here due to lower
+ 		 * device change.  Save the lower-dev address so we can
+ 		 * restore it later.
+ 		 */
+ 		ether_addr_copy(vlan->port->perm_addr,
+ 				lowerdev->dev_addr);
+ 	}
+ 	macvlan_clear_addr_change(port);
+ 	return 0;
+ }
+ 
++>>>>>>> 59f997b088d2 (macvlan: return correct error value)
  static int macvlan_set_mac_address(struct net_device *dev, void *p)
  {
  	struct macvlan_dev *vlan = netdev_priv(dev);
@@@ -505,23 -738,19 +549,31 @@@
  	if (!is_valid_ether_addr(addr->sa_data))
  		return -EADDRNOTAVAIL;
  
 -	/* If the addresses are the same, this is a no-op */
 -	if (ether_addr_equal(dev->dev_addr, addr->sa_data))
 -		return 0;
 +	if (!(dev->flags & IFF_UP)) {
 +		/* Just copy in the new address */
 +		memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
 +	} else {
 +		/* Rehash and update the device filters */
 +		if (macvlan_addr_busy(vlan->port, addr->sa_data))
 +			return -EBUSY;
  
 -	if (vlan->mode == MACVLAN_MODE_PASSTHRU) {
 -		macvlan_set_addr_change(vlan->port);
 -		return dev_set_mac_address(vlan->lowerdev, addr);
 +		err = dev_uc_add(lowerdev, addr->sa_data);
 +		if (err)
 +			return err;
 +
 +		dev_uc_del(lowerdev, dev->dev_addr);
 +
 +		macvlan_hash_change_addr(vlan, addr->sa_data);
  	}
++<<<<<<< HEAD
 +	return 0;
++=======
+ 
+ 	if (macvlan_addr_busy(vlan->port, addr->sa_data))
+ 		return -EADDRINUSE;
+ 
+ 	return macvlan_sync_address(dev, addr->sa_data);
++>>>>>>> 59f997b088d2 (macvlan: return correct error value)
  }
  
  static void macvlan_change_rx_flags(struct net_device *dev, int change)
* Unmerged path drivers/net/macvlan.c
