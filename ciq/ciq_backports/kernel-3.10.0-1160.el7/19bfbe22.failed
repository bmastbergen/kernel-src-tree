mm, hugetlb, soft_offline: save compound page order before page migration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Alexandru Moise <00moses.alexander00@gmail.com>
commit 19bfbe22f59a207417b2679e7e83c180419c9ec5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/19bfbe22.failed

This fixes a bug in madvise() where if you'd try to soft offline a
hugepage via madvise(), while walking the address range you'd end up,
using the wrong page offset due to attempting to get the compound order
of a former but presently not compound page, due to dissolving the huge
page (since commit c3114a84f7f9: "mm: hugetlb: soft-offline: dissolve
source hugepage after successful migration").

As a result I ended up with all my free pages except one being offlined.

Link: http://lkml.kernel.org/r/20170912204306.GA12053@gmail.com
Fixes: c3114a84f7f9 ("mm: hugetlb: soft-offline: dissolve source hugepage after successful migration")
	Signed-off-by: Alexandru Moise <00moses.alexander00@gmail.com>
	Cc: Anshuman Khandual <khandual@linux.vnet.ibm.com>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Minchan Kim <minchan@kernel.org>
	Cc: Hillf Danton <hdanton@sina.com>
	Cc: Shaohua Li <shli@fb.com>
	Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
	Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 19bfbe22f59a207417b2679e7e83c180419c9ec5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/madvise.c
diff --cc mm/madvise.c
index e91a6fd14d07,25bade36e9ca..000000000000
--- a/mm/madvise.c
+++ b/mm/madvise.c
@@@ -615,44 -620,49 +615,71 @@@ static long madvise_remove(struct vm_ar
  /*
   * Error injection support for memory error handling.
   */
 -static int madvise_inject_error(int behavior,
 -		unsigned long start, unsigned long end)
 +static int madvise_hwpoison(int bhv, unsigned long start, unsigned long end)
  {
++<<<<<<< HEAD
 +	struct page *p;
 +	int ret = 0;
 +
 +	if (!capable(CAP_SYS_ADMIN))
 +		return -EPERM;
 +	for (; start < end; start += PAGE_SIZE <<
 +				compound_order(compound_head(p))) {
 +		unsigned long pfn;
 +		int ret = get_user_pages_fast(start, 1, 0, &p);
 +		if (ret != 1)
 +			return ret;
 +		if (PageHWPoison(p)) {
 +			put_page(p);
++=======
+ 	struct page *page;
+ 	struct zone *zone;
+ 	unsigned int order;
+ 
+ 	if (!capable(CAP_SYS_ADMIN))
+ 		return -EPERM;
+ 
+ 
+ 	for (; start < end; start += PAGE_SIZE << order) {
+ 		int ret;
+ 
+ 		ret = get_user_pages_fast(start, 1, 0, &page);
+ 		if (ret != 1)
+ 			return ret;
+ 
+ 		/*
+ 		 * When soft offlining hugepages, after migrating the page
+ 		 * we dissolve it, therefore in the second loop "page" will
+ 		 * no longer be a compound page, and order will be 0.
+ 		 */
+ 		order = compound_order(compound_head(page));
+ 
+ 		if (PageHWPoison(page)) {
+ 			put_page(page);
++>>>>>>> 19bfbe22f59a (mm, hugetlb, soft_offline: save compound page order before page migration)
  			continue;
  		}
 -
 -		if (behavior == MADV_SOFT_OFFLINE) {
 -			pr_info("Soft offlining pfn %#lx at process virtual address %#lx\n",
 -						page_to_pfn(page), start);
 -
 -			ret = soft_offline_page(page, MF_COUNT_INCREASED);
 +		pfn = page_to_pfn(p);
 +		if (bhv == MADV_SOFT_OFFLINE) {
 +			printk(KERN_INFO "Soft offlining page %lx at %lx\n",
 +				pfn, start);
 +			ret = soft_offline_page(p, MF_COUNT_INCREASED);
  			if (ret)
 -				return ret;
 +				break;
  			continue;
  		}
 -		pr_info("Injecting memory failure for pfn %#lx at process virtual address %#lx\n",
 -						page_to_pfn(page), start);
  
 -		ret = memory_failure(page_to_pfn(page), 0, MF_COUNT_INCREASED);
 +		printk(KERN_INFO "Injecting memory failure for page %lx at %lx\n",
 +		       pfn, start);
 +
 +		/*
 +		 * Drop the page reference taken by get_user_pages_fast(). In
 +		 * the absence of MF_COUNT_INCREASED the memory_failure()
 +		 * routine is responsible for pinning the page to prevent it
 +		 * from being released back to the page allocator.
 +		 */
 +		put_page(p);
 +		ret = memory_failure(pfn, 0, 0);
  		if (ret)
  			return ret;
  	}
* Unmerged path mm/madvise.c
