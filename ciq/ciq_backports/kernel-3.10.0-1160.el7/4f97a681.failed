ext4: fix support for inode sizes > 1024 bytes

jira LE-1907
cve CVE-2019-19767
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit 4f97a68192bd33b9963b400759cef0ca5963af00
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/4f97a681.failed

A recent commit, 9803387c55f7 ("ext4: validate the
debug_want_extra_isize mount option at parse time"), moved mount-time
checks around.  One of those changes moved the inode size check before
the blocksize variable was set to the blocksize of the file system.
After 9803387c55f7 was set to the minimum allowable blocksize, which
in practice on most systems would be 1024 bytes.  This cuased file
systems with inode sizes larger than 1024 bytes to be rejected with a
message:

EXT4-fs (sdXX): unsupported inode size: 4096

Fixes: 9803387c55f7 ("ext4: validate the debug_want_extra_isize mount option at parse time")
Link: https://lore.kernel.org/r/20200206225252.GA3673@mit.edu
	Reported-by: Herbert Poetzl <herbert@13thfloor.at>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: stable@kernel.org
(cherry picked from commit 4f97a68192bd33b9963b400759cef0ca5963af00)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/super.c
diff --cc fs/ext4/super.c
index 417c0071ce41,b0b9150c9773..000000000000
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@@ -3740,6 -3814,78 +3740,81 @@@ static int ext4_fill_super(struct super
  	 */
  	sbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;
  
++<<<<<<< HEAD
++=======
+ 	blocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);
+ 	if (blocksize < EXT4_MIN_BLOCK_SIZE ||
+ 	    blocksize > EXT4_MAX_BLOCK_SIZE) {
+ 		ext4_msg(sb, KERN_ERR,
+ 		       "Unsupported filesystem blocksize %d (%d log_block_size)",
+ 			 blocksize, le32_to_cpu(es->s_log_block_size));
+ 		goto failed_mount;
+ 	}
+ 
+ 	if (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {
+ 		sbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;
+ 		sbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;
+ 	} else {
+ 		sbi->s_inode_size = le16_to_cpu(es->s_inode_size);
+ 		sbi->s_first_ino = le32_to_cpu(es->s_first_ino);
+ 		if (sbi->s_first_ino < EXT4_GOOD_OLD_FIRST_INO) {
+ 			ext4_msg(sb, KERN_ERR, "invalid first ino: %u",
+ 				 sbi->s_first_ino);
+ 			goto failed_mount;
+ 		}
+ 		if ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||
+ 		    (!is_power_of_2(sbi->s_inode_size)) ||
+ 		    (sbi->s_inode_size > blocksize)) {
+ 			ext4_msg(sb, KERN_ERR,
+ 			       "unsupported inode size: %d",
+ 			       sbi->s_inode_size);
+ 			ext4_msg(sb, KERN_ERR, "blocksize: %d", blocksize);
+ 			goto failed_mount;
+ 		}
+ 		/*
+ 		 * i_atime_extra is the last extra field available for
+ 		 * [acm]times in struct ext4_inode. Checking for that
+ 		 * field should suffice to ensure we have extra space
+ 		 * for all three.
+ 		 */
+ 		if (sbi->s_inode_size >= offsetof(struct ext4_inode, i_atime_extra) +
+ 			sizeof(((struct ext4_inode *)0)->i_atime_extra)) {
+ 			sb->s_time_gran = 1;
+ 			sb->s_time_max = EXT4_EXTRA_TIMESTAMP_MAX;
+ 		} else {
+ 			sb->s_time_gran = NSEC_PER_SEC;
+ 			sb->s_time_max = EXT4_NON_EXTRA_TIMESTAMP_MAX;
+ 		}
+ 		sb->s_time_min = EXT4_TIMESTAMP_MIN;
+ 	}
+ 	if (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {
+ 		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
+ 			EXT4_GOOD_OLD_INODE_SIZE;
+ 		if (ext4_has_feature_extra_isize(sb)) {
+ 			unsigned v, max = (sbi->s_inode_size -
+ 					   EXT4_GOOD_OLD_INODE_SIZE);
+ 
+ 			v = le16_to_cpu(es->s_want_extra_isize);
+ 			if (v > max) {
+ 				ext4_msg(sb, KERN_ERR,
+ 					 "bad s_want_extra_isize: %d", v);
+ 				goto failed_mount;
+ 			}
+ 			if (sbi->s_want_extra_isize < v)
+ 				sbi->s_want_extra_isize = v;
+ 
+ 			v = le16_to_cpu(es->s_min_extra_isize);
+ 			if (v > max) {
+ 				ext4_msg(sb, KERN_ERR,
+ 					 "bad s_min_extra_isize: %d", v);
+ 				goto failed_mount;
+ 			}
+ 			if (sbi->s_want_extra_isize < v)
+ 				sbi->s_want_extra_isize = v;
+ 		}
+ 	}
+ 
++>>>>>>> 4f97a68192bd (ext4: fix support for inode sizes > 1024 bytes)
  	if (sbi->s_es->s_mount_opts[0]) {
  		char *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,
  					      sizeof(sbi->s_es->s_mount_opts),
@@@ -3830,17 -4040,9 +3905,9 @@@
  	 * previously didn't change the revision level when setting the flags,
  	 * so there is a chance incompat flags are set on a rev 0 filesystem.
  	 */
 -	if (!ext4_feature_set_ok(sb, (sb_rdonly(sb))))
 +	if (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))
  		goto failed_mount;
  
- 	blocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);
- 	if (blocksize < EXT4_MIN_BLOCK_SIZE ||
- 	    blocksize > EXT4_MAX_BLOCK_SIZE) {
- 		ext4_msg(sb, KERN_ERR,
- 		       "Unsupported filesystem blocksize %d (%d log_block_size)",
- 			 blocksize, le32_to_cpu(es->s_log_block_size));
- 		goto failed_mount;
- 	}
  	if (le32_to_cpu(es->s_log_block_size) >
  	    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {
  		ext4_msg(sb, KERN_ERR,
* Unmerged path fs/ext4/super.c
