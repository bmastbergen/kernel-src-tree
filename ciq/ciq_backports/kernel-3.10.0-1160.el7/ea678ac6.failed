powerpc64/ftrace: Add a field in paca to disable ftrace in unsafe code paths

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
commit ea678ac627e01daf5b4f1da24bf1d0c500e10898
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/ea678ac6.failed

We have some C code that we call into from real mode where we cannot
take any exceptions. Though the C functions themselves are mostly safe,
if these functions are traced, there is a possibility that we may take
an exception. For instance, in certain conditions, the ftrace code uses
WARN(), which uses a 'trap' to do its job.

For such scenarios, introduce a new field in paca 'ftrace_enabled',
which is checked on ftrace entry before continuing. This field can then
be set to zero to disable/pause ftrace, and set to a non-zero value to
resume ftrace.

	Signed-off-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit ea678ac627e01daf5b4f1da24bf1d0c500e10898)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/asm-offsets.c
#	arch/powerpc/kernel/setup_64.c
#	arch/powerpc/kernel/trace/ftrace_64_mprofile.S
#	arch/powerpc/kernel/trace/ftrace_64_pg.S
diff --cc arch/powerpc/kernel/asm-offsets.c
index 59a813689833,262c44a90ea1..000000000000
--- a/arch/powerpc/kernel/asm-offsets.c
+++ b/arch/powerpc/kernel/asm-offsets.c
@@@ -161,104 -153,118 +161,122 @@@ int main(void
  	       sizeof(struct pt_regs) + 16);
  #endif /* CONFIG_PPC_TRANSACTIONAL_MEM */
  
 -	OFFSET(TI_FLAGS, thread_info, flags);
 -	OFFSET(TI_LOCAL_FLAGS, thread_info, local_flags);
 -	OFFSET(TI_PREEMPT, thread_info, preempt_count);
 -	OFFSET(TI_TASK, thread_info, task);
 -	OFFSET(TI_CPU, thread_info, cpu);
 +	DEFINE(TI_FLAGS, offsetof(struct thread_info, flags));
 +	DEFINE(TI_LOCAL_FLAGS, offsetof(struct thread_info, local_flags));
 +	DEFINE(TI_PREEMPT, offsetof(struct thread_info, preempt_count));
 +	DEFINE(TI_TASK, offsetof(struct thread_info, task));
 +	DEFINE(TI_CPU, offsetof(struct thread_info, cpu));
  
  #ifdef CONFIG_PPC64
 -	OFFSET(DCACHEL1BLOCKSIZE, ppc64_caches, l1d.block_size);
 -	OFFSET(DCACHEL1LOGBLOCKSIZE, ppc64_caches, l1d.log_block_size);
 -	OFFSET(DCACHEL1BLOCKSPERPAGE, ppc64_caches, l1d.blocks_per_page);
 -	OFFSET(ICACHEL1BLOCKSIZE, ppc64_caches, l1i.block_size);
 -	OFFSET(ICACHEL1LOGBLOCKSIZE, ppc64_caches, l1i.log_block_size);
 -	OFFSET(ICACHEL1BLOCKSPERPAGE, ppc64_caches, l1i.blocks_per_page);
 +	DEFINE(DCACHEL1LINESIZE, offsetof(struct ppc64_caches, dline_size));
 +	DEFINE(DCACHEL1LOGLINESIZE, offsetof(struct ppc64_caches, log_dline_size));
 +	DEFINE(DCACHEL1LINESPERPAGE, offsetof(struct ppc64_caches, dlines_per_page));
 +	DEFINE(ICACHEL1LINESIZE, offsetof(struct ppc64_caches, iline_size));
 +	DEFINE(ICACHEL1LOGLINESIZE, offsetof(struct ppc64_caches, log_iline_size));
 +	DEFINE(ICACHEL1LINESPERPAGE, offsetof(struct ppc64_caches, ilines_per_page));
  	/* paca */
  	DEFINE(PACA_SIZE, sizeof(struct paca_struct));
++<<<<<<< HEAD
 +	DEFINE(PACA_LOCK_TOKEN, offsetof(struct paca_struct, lock_token));
 +	DEFINE(PACAPACAINDEX, offsetof(struct paca_struct, paca_index));
 +	DEFINE(PACAPROCSTART, offsetof(struct paca_struct, cpu_start));
 +	DEFINE(PACAKSAVE, offsetof(struct paca_struct, kstack));
 +	DEFINE(PACACURRENT, offsetof(struct paca_struct, __current));
 +	DEFINE(PACASAVEDMSR, offsetof(struct paca_struct, saved_msr));
 +	DEFINE(PACASTABRR, offsetof(struct paca_struct, stab_rr));
 +	DEFINE(PACAR1, offsetof(struct paca_struct, saved_r1));
 +	DEFINE(PACATOC, offsetof(struct paca_struct, kernel_toc));
 +	DEFINE(PACAKBASE, offsetof(struct paca_struct, kernelbase));
 +	DEFINE(PACAKMSR, offsetof(struct paca_struct, kernel_msr));
 +	DEFINE(PACASOFTIRQEN, offsetof(struct paca_struct, soft_enabled));
 +	DEFINE(PACAIRQHAPPENED, offsetof(struct paca_struct, irq_happened));
 +	DEFINE(PACACONTEXTID, offsetof(struct paca_struct, context.id));
++=======
+ 	OFFSET(PACAPACAINDEX, paca_struct, paca_index);
+ 	OFFSET(PACAPROCSTART, paca_struct, cpu_start);
+ 	OFFSET(PACAKSAVE, paca_struct, kstack);
+ 	OFFSET(PACACURRENT, paca_struct, __current);
+ 	OFFSET(PACASAVEDMSR, paca_struct, saved_msr);
+ 	OFFSET(PACASTABRR, paca_struct, stab_rr);
+ 	OFFSET(PACAR1, paca_struct, saved_r1);
+ 	OFFSET(PACATOC, paca_struct, kernel_toc);
+ 	OFFSET(PACAKBASE, paca_struct, kernelbase);
+ 	OFFSET(PACAKMSR, paca_struct, kernel_msr);
+ 	OFFSET(PACAIRQSOFTMASK, paca_struct, irq_soft_mask);
+ 	OFFSET(PACAIRQHAPPENED, paca_struct, irq_happened);
+ 	OFFSET(PACA_FTRACE_ENABLED, paca_struct, ftrace_enabled);
+ #ifdef CONFIG_PPC_BOOK3S
+ 	OFFSET(PACACONTEXTID, paca_struct, mm_ctx_id);
++>>>>>>> ea678ac627e0 (powerpc64/ftrace: Add a field in paca to disable ftrace in unsafe code paths)
  #ifdef CONFIG_PPC_MM_SLICES
 -	OFFSET(PACALOWSLICESPSIZE, paca_struct, mm_ctx_low_slices_psize);
 -	OFFSET(PACAHIGHSLICEPSIZE, paca_struct, mm_ctx_high_slices_psize);
 -	OFFSET(PACA_SLB_ADDR_LIMIT, paca_struct, mm_ctx_slb_addr_limit);
 +	DEFINE(PACALOWSLICESPSIZE, offsetof(struct paca_struct,
 +					    context.low_slices_psize));
 +	DEFINE(PACAHIGHSLICEPSIZE, offsetof(struct paca_struct,
 +					    context.high_slices_psize));
  	DEFINE(MMUPSIZEDEFSIZE, sizeof(struct mmu_psize_def));
  #endif /* CONFIG_PPC_MM_SLICES */
 -#endif
  
  #ifdef CONFIG_PPC_BOOK3E
 -	OFFSET(PACAPGD, paca_struct, pgd);
 -	OFFSET(PACA_KERNELPGD, paca_struct, kernel_pgd);
 -	OFFSET(PACA_EXGEN, paca_struct, exgen);
 -	OFFSET(PACA_EXTLB, paca_struct, extlb);
 -	OFFSET(PACA_EXMC, paca_struct, exmc);
 -	OFFSET(PACA_EXCRIT, paca_struct, excrit);
 -	OFFSET(PACA_EXDBG, paca_struct, exdbg);
 -	OFFSET(PACA_MC_STACK, paca_struct, mc_kstack);
 -	OFFSET(PACA_CRIT_STACK, paca_struct, crit_kstack);
 -	OFFSET(PACA_DBG_STACK, paca_struct, dbg_kstack);
 -	OFFSET(PACA_TCD_PTR, paca_struct, tcd_ptr);
 -
 -	OFFSET(TCD_ESEL_NEXT, tlb_core_data, esel_next);
 -	OFFSET(TCD_ESEL_MAX, tlb_core_data, esel_max);
 -	OFFSET(TCD_ESEL_FIRST, tlb_core_data, esel_first);
 +	DEFINE(PACAPGD, offsetof(struct paca_struct, pgd));
 +	DEFINE(PACA_KERNELPGD, offsetof(struct paca_struct, kernel_pgd));
 +	DEFINE(PACA_EXGEN, offsetof(struct paca_struct, exgen));
 +	DEFINE(PACA_EXTLB, offsetof(struct paca_struct, extlb));
 +	DEFINE(PACA_EXMC, offsetof(struct paca_struct, exmc));
 +	DEFINE(PACA_EXCRIT, offsetof(struct paca_struct, excrit));
 +	DEFINE(PACA_EXDBG, offsetof(struct paca_struct, exdbg));
 +	DEFINE(PACA_MC_STACK, offsetof(struct paca_struct, mc_kstack));
 +	DEFINE(PACA_CRIT_STACK, offsetof(struct paca_struct, crit_kstack));
 +	DEFINE(PACA_DBG_STACK, offsetof(struct paca_struct, dbg_kstack));
  #endif /* CONFIG_PPC_BOOK3E */
  
 -#ifdef CONFIG_PPC_BOOK3S_64
 -	OFFSET(PACASLBCACHE, paca_struct, slb_cache);
 -	OFFSET(PACASLBCACHEPTR, paca_struct, slb_cache_ptr);
 -	OFFSET(PACAVMALLOCSLLP, paca_struct, vmalloc_sllp);
 +#ifdef CONFIG_PPC_STD_MMU_64
 +	DEFINE(PACASTABREAL, offsetof(struct paca_struct, stab_real));
 +	DEFINE(PACASTABVIRT, offsetof(struct paca_struct, stab_addr));
 +	DEFINE(PACASLBCACHE, offsetof(struct paca_struct, slb_cache));
 +	DEFINE(PACASLBCACHEPTR, offsetof(struct paca_struct, slb_cache_ptr));
 +	DEFINE(PACAVMALLOCSLLP, offsetof(struct paca_struct, vmalloc_sllp));
  #ifdef CONFIG_PPC_MM_SLICES
 -	OFFSET(MMUPSIZESLLP, mmu_psize_def, sllp);
 +	DEFINE(MMUPSIZESLLP, offsetof(struct mmu_psize_def, sllp));
  #else
 -	OFFSET(PACACONTEXTSLLP, paca_struct, mm_ctx_sllp);
 +	DEFINE(PACACONTEXTSLLP, offsetof(struct paca_struct, context.sllp));
  #endif /* CONFIG_PPC_MM_SLICES */
 -	OFFSET(PACA_EXGEN, paca_struct, exgen);
 -	OFFSET(PACA_EXMC, paca_struct, exmc);
 -	OFFSET(PACA_EXSLB, paca_struct, exslb);
 -	OFFSET(PACA_EXNMI, paca_struct, exnmi);
 -#ifdef CONFIG_PPC_PSERIES
 -	OFFSET(PACALPPACAPTR, paca_struct, lppaca_ptr);
 -#endif
 -	OFFSET(PACA_SLBSHADOWPTR, paca_struct, slb_shadow_ptr);
 -	OFFSET(SLBSHADOW_STACKVSID, slb_shadow, save_area[SLB_NUM_BOLTED - 1].vsid);
 -	OFFSET(SLBSHADOW_STACKESID, slb_shadow, save_area[SLB_NUM_BOLTED - 1].esid);
 -	OFFSET(SLBSHADOW_SAVEAREA, slb_shadow, save_area);
 -	OFFSET(LPPACA_PMCINUSE, lppaca, pmcregs_in_use);
 -#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
 -	OFFSET(PACA_PMCINUSE, paca_struct, pmcregs_in_use);
 -#endif
 -	OFFSET(LPPACA_DTLIDX, lppaca, dtl_idx);
 -	OFFSET(LPPACA_YIELDCOUNT, lppaca, yield_count);
 -	OFFSET(PACA_DTL_RIDX, paca_struct, dtl_ridx);
 -#endif /* CONFIG_PPC_BOOK3S_64 */
 -	OFFSET(PACAEMERGSP, paca_struct, emergency_sp);
 +	DEFINE(PACA_EXGEN, offsetof(struct paca_struct, exgen));
 +	DEFINE(PACA_EXMC, offsetof(struct paca_struct, exmc));
 +	DEFINE(PACA_EXSLB, offsetof(struct paca_struct, exslb));
  #ifdef CONFIG_PPC_BOOK3S_64
 -	OFFSET(PACAMCEMERGSP, paca_struct, mc_emergency_sp);
 -	OFFSET(PACA_NMI_EMERG_SP, paca_struct, nmi_emergency_sp);
 -	OFFSET(PACA_IN_MCE, paca_struct, in_mce);
 -	OFFSET(PACA_IN_NMI, paca_struct, in_nmi);
 -	OFFSET(PACA_RFI_FLUSH_FALLBACK_AREA, paca_struct, rfi_flush_fallback_area);
 -	OFFSET(PACA_EXRFI, paca_struct, exrfi);
 -	OFFSET(PACA_L1D_FLUSH_SIZE, paca_struct, l1d_flush_size);
 -
 -#endif
 -	OFFSET(PACAHWCPUID, paca_struct, hw_cpu_id);
 -	OFFSET(PACAKEXECSTATE, paca_struct, kexec_state);
 -	OFFSET(PACA_DSCR_DEFAULT, paca_struct, dscr_default);
 -	OFFSET(ACCOUNT_STARTTIME, paca_struct, accounting.starttime);
 -	OFFSET(ACCOUNT_STARTTIME_USER, paca_struct, accounting.starttime_user);
 -	OFFSET(ACCOUNT_USER_TIME, paca_struct, accounting.utime);
 -	OFFSET(ACCOUNT_SYSTEM_TIME, paca_struct, accounting.stime);
 -	OFFSET(PACA_TRAP_SAVE, paca_struct, trap_save);
 -	OFFSET(PACA_NAPSTATELOST, paca_struct, nap_state_lost);
 -	OFFSET(PACA_SPRG_VDSO, paca_struct, sprg_vdso);
 -#else /* CONFIG_PPC64 */
 -#ifdef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE
 -	OFFSET(ACCOUNT_STARTTIME, thread_info, accounting.starttime);
 -	OFFSET(ACCOUNT_STARTTIME_USER, thread_info, accounting.starttime_user);
 -	OFFSET(ACCOUNT_USER_TIME, thread_info, accounting.utime);
 -	OFFSET(ACCOUNT_SYSTEM_TIME, thread_info, accounting.stime);
 -#endif
 +	/* paca_aux_struct stuff: */
 +	DEFINE(PACA_AUX_PTR, offsetof(struct paca_struct, exslb[EX_DAR/8]));
 +	OFFSET(PACA_AUX_RFI_FLUSH_FALLBACK_AREA, paca_aux_struct, rfi_flush_fallback_area);
 +	OFFSET(PACA_AUX_EXRFI, paca_aux_struct, exrfi);
 +	OFFSET(PACA_AUX_L1D_FLUSH_SIZE, paca_aux_struct, l1d_flush_size);
 +#endif
 +	DEFINE(PACALPPACAPTR, offsetof(struct paca_struct, lppaca_ptr));
 +	DEFINE(PACA_SLBSHADOWPTR, offsetof(struct paca_struct, slb_shadow_ptr));
 +	DEFINE(SLBSHADOW_STACKVSID,
 +	       offsetof(struct slb_shadow, save_area[SLB_NUM_BOLTED - 1].vsid));
 +	DEFINE(SLBSHADOW_STACKESID,
 +	       offsetof(struct slb_shadow, save_area[SLB_NUM_BOLTED - 1].esid));
 +	DEFINE(SLBSHADOW_SAVEAREA, offsetof(struct slb_shadow, save_area));
 +	DEFINE(LPPACA_PMCINUSE, offsetof(struct lppaca, pmcregs_in_use));
 +	DEFINE(LPPACA_DTLIDX, offsetof(struct lppaca, dtl_idx));
 +	DEFINE(LPPACA_YIELDCOUNT, offsetof(struct lppaca, yield_count));
 +	DEFINE(PACA_DTL_RIDX, offsetof(struct paca_struct, dtl_ridx));
 +#endif /* CONFIG_PPC_STD_MMU_64 */
 +	DEFINE(PACAEMERGSP, offsetof(struct paca_struct, emergency_sp));
 +#ifdef CONFIG_PPC_BOOK3S_64
 +	DEFINE(PACAMCEMERGSP, offsetof(struct paca_struct, mc_emergency_sp));
 +	DEFINE(PACA_IN_MCE, offsetof(struct paca_struct, in_mce));
 +#endif
 +	DEFINE(PACAHWCPUID, offsetof(struct paca_struct, hw_cpu_id));
 +	DEFINE(PACAKEXECSTATE, offsetof(struct paca_struct, kexec_state));
 +	DEFINE(PACA_DSCR_DEFAULT, offsetof(struct paca_struct, dscr_default));
 +	DEFINE(PACA_STARTTIME, offsetof(struct paca_struct, starttime));
 +	DEFINE(PACA_STARTTIME_USER, offsetof(struct paca_struct, starttime_user));
 +	DEFINE(PACA_USER_TIME, offsetof(struct paca_struct, user_time));
 +	DEFINE(PACA_SYSTEM_TIME, offsetof(struct paca_struct, system_time));
 +	DEFINE(PACA_TRAP_SAVE, offsetof(struct paca_struct, trap_save));
 +	DEFINE(PACA_NAPSTATELOST, offsetof(struct paca_struct, nap_state_lost));
 +	DEFINE(PACA_SPRG3, offsetof(struct paca_struct, sprg3));
  #endif /* CONFIG_PPC64 */
  
  	/* RTAS */
diff --cc arch/powerpc/kernel/setup_64.c
index 77d750687707,313136006d1c..000000000000
--- a/arch/powerpc/kernel/setup_64.c
+++ b/arch/powerpc/kernel/setup_64.c
@@@ -177,6 -240,29 +177,32 @@@ static void cpu_ready_for_interrupts(vo
  		unsigned long lpcr = mfspr(SPRN_LPCR);
  		mtspr(SPRN_LPCR, lpcr | LPCR_AIL_3);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * Fixup HFSCR:TM based on CPU features. The bit is set by our
+ 	 * early asm init because at that point we haven't updated our
+ 	 * CPU features from firmware and device-tree. Here we have,
+ 	 * so let's do it.
+ 	 */
+ 	if (cpu_has_feature(CPU_FTR_HVMODE) && !cpu_has_feature(CPU_FTR_TM_COMP))
+ 		mtspr(SPRN_HFSCR, mfspr(SPRN_HFSCR) & ~HFSCR_TM);
+ 
+ 	/* Set IR and DR in PACA MSR */
+ 	get_paca()->kernel_msr = MSR_KERNEL;
+ 
+ 	/* We are now ok to enable ftrace */
+ 	get_paca()->ftrace_enabled = 1;
+ }
+ 
+ unsigned long spr_default_dscr = 0;
+ 
+ void __init record_spr_defaults(void)
+ {
+ 	if (early_cpu_has_feature(CPU_FTR_DSCR))
+ 		spr_default_dscr = mfspr(SPRN_DSCR);
++>>>>>>> ea678ac627e0 (powerpc64/ftrace: Add a field in paca to disable ftrace in unsafe code paths)
  }
  
  /*
* Unmerged path arch/powerpc/kernel/trace/ftrace_64_mprofile.S
* Unmerged path arch/powerpc/kernel/trace/ftrace_64_pg.S
diff --git a/arch/powerpc/include/asm/paca.h b/arch/powerpc/include/asm/paca.h
index f76a11041ee7..8b43a4af514b 100644
--- a/arch/powerpc/include/asm/paca.h
+++ b/arch/powerpc/include/asm/paca.h
@@ -187,6 +187,7 @@ struct paca_struct {
 	 */
 	struct sibling_subcore_state *sibling_subcore_state;
 #endif
+	u8 ftrace_enabled;		/* Hard disable ftrace */
 
 	/* Stuff for accurate time accounting */
 	u64 user_time;			/* accumulated usermode TB ticks */
* Unmerged path arch/powerpc/kernel/asm-offsets.c
* Unmerged path arch/powerpc/kernel/setup_64.c
* Unmerged path arch/powerpc/kernel/trace/ftrace_64_mprofile.S
* Unmerged path arch/powerpc/kernel/trace/ftrace_64_pg.S
