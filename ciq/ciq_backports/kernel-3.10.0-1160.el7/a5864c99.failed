NFS: Do not serialise O_DIRECT reads and writes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit a5864c999de6703f7ce908f72337568520c6cad3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/a5864c99.failed

Allow dio requests to be scheduled in parallel, but ensuring that they
do not conflict with buffered I/O.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit a5864c999de6703f7ce908f72337568520c6cad3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/direct.c
#	fs/nfs/file.c
diff --cc fs/nfs/direct.c
index 245296715330,6d0e88096440..000000000000
--- a/fs/nfs/direct.c
+++ b/fs/nfs/direct.c
@@@ -652,21 -578,16 +652,24 @@@ ssize_t nfs_file_direct_read(struct kio
  	if (!count)
  		goto out;
  
++<<<<<<< HEAD
 +	mutex_lock(&inode->i_mutex);
 +	result = nfs_sync_mapping(mapping);
 +	if (result)
 +		goto out_unlock;
 +
++=======
++>>>>>>> a5864c999de6 (NFS: Do not serialise O_DIRECT reads and writes)
  	task_io_account_read(count);
  
  	result = -ENOMEM;
  	dreq = nfs_direct_req_alloc();
  	if (dreq == NULL)
- 		goto out_unlock;
+ 		goto out;
  
  	dreq->inode = inode;
 -	dreq->bytes_left = dreq->max_count = count;
 -	dreq->io_start = iocb->ki_pos;
 +	dreq->bytes_left = iov_length(iov, nr_segs);
 +	dreq->io_start = pos;
  	dreq->ctx = get_nfs_open_context(nfs_file_open_context(iocb->ki_filp));
  	l_ctx = nfs_get_lock_context(dreq->ctx);
  	if (IS_ERR(l_ctx)) {
@@@ -677,24 -598,21 +680,33 @@@
  	if (!is_sync_kiocb(iocb))
  		dreq->iocb = iocb;
  
++<<<<<<< HEAD
 +	NFS_I(inode)->read_io += iov_length(iov, nr_segs);
 +	result = nfs_direct_read_schedule_iovec(dreq, iov, nr_segs, pos, uio);
 +
 +	mutex_unlock(&inode->i_mutex);
++=======
+ 	nfs_start_io_direct(inode);
+ 
+ 	NFS_I(inode)->read_io += count;
+ 	result = nfs_direct_read_schedule_iovec(dreq, iter, iocb->ki_pos);
+ 
+ 	nfs_end_io_direct(inode);
++>>>>>>> a5864c999de6 (NFS: Do not serialise O_DIRECT reads and writes)
  
  	if (!result) {
  		result = nfs_direct_wait(dreq);
  		if (result > 0)
 -			iocb->ki_pos += result;
 +			iocb->ki_pos = pos + result;
  	}
  
- 	nfs_direct_req_release(dreq);
- 	return result;
- 
  out_release:
  	nfs_direct_req_release(dreq);
++<<<<<<< HEAD
 +out_unlock:
 +	mutex_unlock(&inode->i_mutex);
++=======
++>>>>>>> a5864c999de6 (NFS: Do not serialise O_DIRECT reads and writes)
  out:
  	return result;
  }
@@@ -1121,50 -986,29 +1133,53 @@@ ssize_t nfs_file_direct_write(struct ki
  	struct inode *inode = mapping->host;
  	struct nfs_direct_req *dreq;
  	struct nfs_lock_context *l_ctx;
 -	loff_t pos, end;
 +	loff_t end;
 +	size_t count;
  
 -	dfprintk(FILE, "NFS: direct write(%pD2, %zd@%Ld)\n",
 -		file, iov_iter_count(iter), (long long) iocb->ki_pos);
 +	count = iov_length(iov, nr_segs);
 +	end = (pos + count - 1) >> PAGE_CACHE_SHIFT;
  
 -	result = generic_write_checks(iocb, iter);
 -	if (result <= 0)
 -		return result;
 -	count = result;
  	nfs_add_stats(mapping->host, NFSIOS_DIRECTWRITTENBYTES, count);
  
 -	pos = iocb->ki_pos;
 -	end = (pos + iov_iter_count(iter) - 1) >> PAGE_SHIFT;
 +	dfprintk(FILE, "NFS: direct write(%pD2, %zd@%Ld)\n",
 +		file, count, (long long) pos);
 +
++<<<<<<< HEAD
 +	result = generic_write_checks(file, &pos, &count, 0);
 +	if (result)
 +		goto out;
 +
 +	result = -EINVAL;
 +	if ((ssize_t) count < 0)
 +		goto out;
 +	result = 0;
 +	if (!count)
 +		goto out;
 +
 +	mutex_lock(&inode->i_mutex);
  
 +	result = nfs_sync_mapping(mapping);
 +	if (result)
 +		goto out_unlock;
 +
 +	if (mapping->nrpages) {
 +		result = invalidate_inode_pages2_range(mapping,
 +					pos >> PAGE_CACHE_SHIFT, end);
 +		if (result)
 +			goto out_unlock;
 +	}
 +
++=======
++>>>>>>> a5864c999de6 (NFS: Do not serialise O_DIRECT reads and writes)
  	task_io_account_write(count);
  
  	result = -ENOMEM;
  	dreq = nfs_direct_req_alloc();
  	if (!dreq)
- 		goto out_unlock;
+ 		goto out;
  
  	dreq->inode = inode;
 -	dreq->bytes_left = dreq->max_count = count;
 +	dreq->bytes_left = count;
  	dreq->io_start = pos;
  	dreq->ctx = get_nfs_open_context(nfs_file_open_context(iocb->ki_filp));
  	l_ctx = nfs_get_lock_context(dreq->ctx);
@@@ -1176,35 -1020,27 +1191,45 @@@
  	if (!is_sync_kiocb(iocb))
  		dreq->iocb = iocb;
  
++<<<<<<< HEAD
 +	result = nfs_direct_write_schedule_iovec(dreq, iov, nr_segs, pos, uio);
++=======
+ 	nfs_start_io_direct(inode);
+ 
+ 	result = nfs_direct_write_schedule_iovec(dreq, iter, pos);
++>>>>>>> a5864c999de6 (NFS: Do not serialise O_DIRECT reads and writes)
  
  	if (mapping->nrpages) {
  		invalidate_inode_pages2_range(mapping,
 -					      pos >> PAGE_SHIFT, end);
 +					      pos >> PAGE_CACHE_SHIFT, end);
  	}
  
++<<<<<<< HEAD
 +	mutex_unlock(&inode->i_mutex);
++=======
+ 	nfs_end_io_direct(inode);
++>>>>>>> a5864c999de6 (NFS: Do not serialise O_DIRECT reads and writes)
  
  	if (!result) {
  		result = nfs_direct_wait(dreq);
  		if (result > 0) {
 +			struct inode *inode = mapping->host;
 +
  			iocb->ki_pos = pos + result;
 -			/* XXX: should check the generic_write_sync retval */
 -			generic_write_sync(iocb, result);
 +			spin_lock(&inode->i_lock);
 +			if (i_size_read(inode) < iocb->ki_pos)
 +				i_size_write(inode, iocb->ki_pos);
 +			spin_unlock(&inode->i_lock);
 +			generic_write_sync(file, pos, result);
  		}
  	}
- 	nfs_direct_req_release(dreq);
- 	return result;
- 
  out_release:
  	nfs_direct_req_release(dreq);
++<<<<<<< HEAD
 +out_unlock:
 +	mutex_unlock(&inode->i_mutex);
++=======
++>>>>>>> a5864c999de6 (NFS: Do not serialise O_DIRECT reads and writes)
  out:
  	return result;
  }
diff --cc fs/nfs/file.c
index 5b55f801cd6b,9f8da9e1b23f..000000000000
--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@@ -165,16 -163,17 +165,17 @@@ nfs_file_read(struct kiocb *iocb, cons
  	struct inode *inode = file_inode(iocb->ki_filp);
  	ssize_t result;
  
 -	if (iocb->ki_flags & IOCB_DIRECT)
 -		return nfs_file_direct_read(iocb, to);
 +	if (iocb->ki_filp->f_flags & O_DIRECT)
 +		return nfs_file_direct_read(iocb, iov, nr_segs, pos, true);
  
 -	dprintk("NFS: read(%pD2, %zu@%lu)\n",
 +	dprintk("NFS: read(%pD2, %lu@%lu)\n",
  		iocb->ki_filp,
 -		iov_iter_count(to), (unsigned long) iocb->ki_pos);
 +		(unsigned long) iov_length(iov, nr_segs), (unsigned long) pos);
  
- 	result = nfs_revalidate_mapping_protected(inode, iocb->ki_filp->f_mapping);
+ 	nfs_start_io_read(inode);
+ 	result = nfs_revalidate_mapping(inode, iocb->ki_filp->f_mapping);
  	if (!result) {
 -		result = generic_file_read_iter(iocb, to);
 +		result = generic_file_aio_read(iocb, iov, nr_segs, pos);
  		if (result > 0)
  			nfs_add_stats(inode, NFSIOS_NORMALREADBYTES, result);
  	}
@@@ -693,16 -649,22 +697,28 @@@ ssize_t nfs_file_write(struct kiocb *io
  			goto out;
  	}
  
++<<<<<<< HEAD
 +	result = count;
 +	if (!count)
++=======
+ 	nfs_start_io_write(inode);
+ 	result = generic_write_checks(iocb, from);
+ 	if (result > 0) {
+ 		current->backing_dev_info = inode_to_bdi(inode);
+ 		result = generic_perform_write(file, from, iocb->ki_pos);
+ 		current->backing_dev_info = NULL;
+ 	}
+ 	nfs_end_io_write(inode);
+ 	if (result <= 0)
++>>>>>>> a5864c999de6 (NFS: Do not serialise O_DIRECT reads and writes)
  		goto out;
  
 -	written = generic_write_sync(iocb, result);
 -	iocb->ki_pos += written;
 +	result = generic_file_aio_write(iocb, iov, nr_segs, pos);
 +	if (result > 0)
 +		written = result;
  
  	/* Return error values */
 -	if (nfs_need_check_write(file, inode)) {
 +	if (result >= 0 && nfs_need_check_write(file, inode)) {
  		int err = vfs_fsync(file, 0);
  		if (err < 0)
  			result = err;
diff --git a/fs/nfs/Makefile b/fs/nfs/Makefile
index 8664417955a2..6abdda209642 100644
--- a/fs/nfs/Makefile
+++ b/fs/nfs/Makefile
@@ -6,7 +6,7 @@ obj-$(CONFIG_NFS_FS) += nfs.o
 
 CFLAGS_nfstrace.o += -I$(src)
 nfs-y 			:= client.o dir.o file.o getroot.o inode.o super.o \
-			   direct.o pagelist.o read.o symlink.o unlink.o \
+			   io.o direct.o pagelist.o read.o symlink.o unlink.o \
 			   write.o namespace.o mount_clnt.o nfstrace.o
 nfs-$(CONFIG_ROOT_NFS)	+= nfsroot.o
 nfs-$(CONFIG_SYSCTL)	+= sysctl.o
* Unmerged path fs/nfs/direct.c
* Unmerged path fs/nfs/file.c
diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index eebeef04ff7a..abaac735743a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -418,6 +418,14 @@ extern void __exit unregister_nfs_fs(void);
 extern bool nfs_sb_active(struct super_block *sb);
 extern void nfs_sb_deactive(struct super_block *sb);
 
+/* io.c */
+extern void nfs_start_io_read(struct inode *inode);
+extern void nfs_end_io_read(struct inode *inode);
+extern void nfs_start_io_write(struct inode *inode);
+extern void nfs_end_io_write(struct inode *inode);
+extern void nfs_start_io_direct(struct inode *inode);
+extern void nfs_end_io_direct(struct inode *inode);
+
 /* namespace.c */
 #define NFS_PATH_CANONICAL 1
 extern char *nfs_path(char **p, struct dentry *dentry,
diff --git a/fs/nfs/io.c b/fs/nfs/io.c
new file mode 100644
index 000000000000..1fc5d1ce327e
--- /dev/null
+++ b/fs/nfs/io.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright (c) 2016 Trond Myklebust
+ *
+ * I/O and data path helper functionality.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/bitops.h>
+#include <linux/rwsem.h>
+#include <linux/fs.h>
+#include <linux/nfs_fs.h>
+
+#include "internal.h"
+
+/* Call with exclusively locked inode->i_rwsem */
+static void nfs_block_o_direct(struct nfs_inode *nfsi, struct inode *inode)
+{
+	if (test_bit(NFS_INO_ODIRECT, &nfsi->flags)) {
+		clear_bit(NFS_INO_ODIRECT, &nfsi->flags);
+		inode_dio_wait(inode);
+	}
+}
+
+/**
+ * nfs_start_io_read - declare the file is being used for buffered reads
+ * @inode - file inode
+ *
+ * Declare that a buffered read operation is about to start, and ensure
+ * that we block all direct I/O.
+ * On exit, the function ensures that the NFS_INO_ODIRECT flag is unset,
+ * and holds a shared lock on inode->i_rwsem to ensure that the flag
+ * cannot be changed.
+ * In practice, this means that buffered read operations are allowed to
+ * execute in parallel, thanks to the shared lock, whereas direct I/O
+ * operations need to wait to grab an exclusive lock in order to set
+ * NFS_INO_ODIRECT.
+ * Note that buffered writes and truncates both take a write lock on
+ * inode->i_rwsem, meaning that those are serialised w.r.t. the reads.
+ */
+void
+nfs_start_io_read(struct inode *inode)
+{
+	struct nfs_inode *nfsi = NFS_I(inode);
+	/* Be an optimist! */
+	down_read(&inode->i_rwsem);
+	if (test_bit(NFS_INO_ODIRECT, &nfsi->flags) == 0)
+		return;
+	up_read(&inode->i_rwsem);
+	/* Slow path.... */
+	down_write(&inode->i_rwsem);
+	nfs_block_o_direct(nfsi, inode);
+	downgrade_write(&inode->i_rwsem);
+}
+
+/**
+ * nfs_end_io_read - declare that the buffered read operation is done
+ * @inode - file inode
+ *
+ * Declare that a buffered read operation is done, and release the shared
+ * lock on inode->i_rwsem.
+ */
+void
+nfs_end_io_read(struct inode *inode)
+{
+	up_read(&inode->i_rwsem);
+}
+
+/**
+ * nfs_start_io_write - declare the file is being used for buffered writes
+ * @inode - file inode
+ *
+ * Declare that a buffered read operation is about to start, and ensure
+ * that we block all direct I/O.
+ */
+void
+nfs_start_io_write(struct inode *inode)
+{
+	down_write(&inode->i_rwsem);
+	nfs_block_o_direct(NFS_I(inode), inode);
+}
+
+/**
+ * nfs_end_io_write - declare that the buffered write operation is done
+ * @inode - file inode
+ *
+ * Declare that a buffered write operation is done, and release the
+ * lock on inode->i_rwsem.
+ */
+void
+nfs_end_io_write(struct inode *inode)
+{
+	up_write(&inode->i_rwsem);
+}
+
+/* Call with exclusively locked inode->i_rwsem */
+static void nfs_block_buffered(struct nfs_inode *nfsi, struct inode *inode)
+{
+	if (!test_bit(NFS_INO_ODIRECT, &nfsi->flags)) {
+		set_bit(NFS_INO_ODIRECT, &nfsi->flags);
+		nfs_wb_all(inode);
+	}
+}
+
+/**
+ * nfs_end_io_direct - declare the file is being used for direct i/o
+ * @inode - file inode
+ *
+ * Declare that a direct I/O operation is about to start, and ensure
+ * that we block all buffered I/O.
+ * On exit, the function ensures that the NFS_INO_ODIRECT flag is set,
+ * and holds a shared lock on inode->i_rwsem to ensure that the flag
+ * cannot be changed.
+ * In practice, this means that direct I/O operations are allowed to
+ * execute in parallel, thanks to the shared lock, whereas buffered I/O
+ * operations need to wait to grab an exclusive lock in order to clear
+ * NFS_INO_ODIRECT.
+ * Note that buffered writes and truncates both take a write lock on
+ * inode->i_rwsem, meaning that those are serialised w.r.t. O_DIRECT.
+ */
+void
+nfs_start_io_direct(struct inode *inode)
+{
+	struct nfs_inode *nfsi = NFS_I(inode);
+	/* Be an optimist! */
+	down_read(&inode->i_rwsem);
+	if (test_bit(NFS_INO_ODIRECT, &nfsi->flags) != 0)
+		return;
+	up_read(&inode->i_rwsem);
+	/* Slow path.... */
+	down_write(&inode->i_rwsem);
+	nfs_block_buffered(nfsi, inode);
+	downgrade_write(&inode->i_rwsem);
+}
+
+/**
+ * nfs_end_io_direct - declare that the direct i/o operation is done
+ * @inode - file inode
+ *
+ * Declare that a direct I/O operation is done, and release the shared
+ * lock on inode->i_rwsem.
+ */
+void
+nfs_end_io_direct(struct inode *inode)
+{
+	up_read(&inode->i_rwsem);
+}
diff --git a/include/linux/nfs_fs.h b/include/linux/nfs_fs.h
index a84b39cb0dba..f4c1911ffeeb 100644
--- a/include/linux/nfs_fs.h
+++ b/include/linux/nfs_fs.h
@@ -214,6 +214,7 @@ struct nfs_inode {
 #define NFS_INO_LAYOUTCOMMIT	(9)		/* layoutcommit required */
 #define NFS_INO_LAYOUTCOMMITTING (10)		/* layoutcommit inflight */
 #define NFS_INO_LAYOUTSTATS	(11)		/* layoutstats inflight */
+#define NFS_INO_ODIRECT		(12)		/* I/O setting is O_DIRECT */
 
 static inline struct nfs_inode *NFS_I(const struct inode *inode)
 {
