gfs2: Even more gfs2_find_jhead fixes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 20be493b787cd581c9fffad7fcd6bfbe6af1050c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/20be493b.failed

Fix several issues in the previous gfs2_find_jhead fix:
* When updating @blocks_submitted, @block refers to the first block block not
  submitted yet, not the last block submitted, so fix an off-by-one error.
* We want to ensure that @blocks_submitted is far enough ahead of @blocks_read
  to guarantee that there is in-flight I/O.  Otherwise, we'll eventually end up
  waiting for pages that haven't been submitted, yet.
* It's much easier to compare the number of blocks added with the number of
  blocks submitted to limit the maximum bio size.
* Even with bio chaining, we can keep adding blocks until we reach the maximum
  bio size, as long as we stop at a page boundary.  This simplifies the logic.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Reviewed-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 20be493b787cd581c9fffad7fcd6bfbe6af1050c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/lops.c
diff --cc fs/gfs2/lops.c
index 13eb06ebcf6c,cb2a11b458c6..000000000000
--- a/fs/gfs2/lops.c
+++ b/fs/gfs2/lops.c
@@@ -495,15 -506,16 +495,23 @@@ int gfs2_find_jhead(struct gfs2_jdesc *
  	struct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);
  	struct address_space *mapping = jd->jd_inode->i_mapping;
  	unsigned int block = 0, blocks_submitted = 0, blocks_read = 0;
 -	unsigned int bsize = sdp->sd_sb.sb_bsize, off;
 +	unsigned int bsize = sdp->sd_sb.sb_bsize;
  	unsigned int bsize_shift = sdp->sd_sb.sb_bsize_shift;
  	unsigned int shift = PAGE_SHIFT - bsize_shift;
++<<<<<<< HEAD
 +	unsigned int readhead_blocks = BIO_MAX_PAGES << shift;
++=======
+ 	unsigned int max_blocks = 2 * 1024 * 1024 >> bsize_shift;
++>>>>>>> 20be493b787c (gfs2: Even more gfs2_find_jhead fixes)
  	struct gfs2_journal_extent *je;
  	int sz, ret = 0;
  	struct bio *bio = NULL;
  	struct page *page = NULL;
  	bool done = false;
++<<<<<<< HEAD
++=======
+ 	errseq_t since;
++>>>>>>> 20be493b787c (gfs2: Even more gfs2_find_jhead fixes)
  
  	memset(head, 0, sizeof(*head));
  	if (list_empty(&jd->extent_list))
@@@ -521,34 -534,41 +529,72 @@@
  					done = true;
  					goto out;
  				}
++<<<<<<< HEAD
 +			}
 +
 +			if (bio) {
 +				unsigned int off;
 +
 +				off = (block << bsize_shift) & ~PAGE_MASK;
 +				sz = bio_add_page(bio, page, bsize, off);
 +				if (sz == bsize) { /* block added */
 +					if (off + bsize == PAGE_SIZE) {
 +						page = NULL;
 +						goto page_added;
 +					}
 +					continue;
 +				}
 +				blocks_submitted = block + 1;
 +				submit_bio(READ, bio);
 +				bio = NULL;
++=======
+ 				off = 0;
+ 			}
+ 
+ 			if (bio && (off || block < blocks_submitted + max_blocks)) {
+ 				sector_t sector = dblock << sdp->sd_fsb2bb_shift;
+ 
+ 				if (bio_end_sector(bio) == sector) {
+ 					sz = bio_add_page(bio, page, bsize, off);
+ 					if (sz == bsize)
+ 						goto block_added;
+ 				}
+ 				if (off) {
+ 					unsigned int blocks =
+ 						(PAGE_SIZE - off) >> bsize_shift;
+ 
+ 					bio = gfs2_chain_bio(bio, blocks);
+ 					goto add_block_to_new_bio;
+ 				}
+ 			}
+ 
+ 			if (bio) {
+ 				blocks_submitted = block;
+ 				submit_bio(bio);
++>>>>>>> 20be493b787c (gfs2: Even more gfs2_find_jhead fixes)
  			}
  
 +			dblock = je->dblock + (block - je->lblock);
  			bio = gfs2_log_alloc_bio(sdp, dblock, gfs2_end_log_read);
++<<<<<<< HEAD
 +			sz = bio_add_page(bio, page, bsize, 0);
 +			gfs2_assert_warn(sdp, sz == bsize);
 +			if (bsize == PAGE_SIZE)
 +				page = NULL;
 +
 +page_added:
 +			if (blocks_submitted < blocks_read + readhead_blocks) {
++=======
+ 			bio->bi_opf = REQ_OP_READ;
+ add_block_to_new_bio:
+ 			sz = bio_add_page(bio, page, bsize, off);
+ 			BUG_ON(sz != bsize);
+ block_added:
+ 			off += bsize;
+ 			if (off == PAGE_SIZE)
+ 				page = NULL;
+ 			if (blocks_submitted <= blocks_read + max_blocks) {
++>>>>>>> 20be493b787c (gfs2: Even more gfs2_find_jhead fixes)
  				/* Keep at least one bio in flight */
  				continue;
  			}
* Unmerged path fs/gfs2/lops.c
