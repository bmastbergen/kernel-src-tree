mm: hwpoison: dissolve in-use hugepage in unrecoverable memory error

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
commit 78bb920344b8a6f04b79a7c254041723b931c94f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/78bb9203.failed

Currently me_huge_page() relies on dequeue_hwpoisoned_huge_page() to
keep the error hugepage away from the system, which is OK but not good
enough because the hugepage still has a refcount and unpoison doesn't
work on the error hugepage (PageHWPoison flags are cleared but pages are
still leaked.) And there's "wasting health subpages" issue too.  This
patch reworks on me_huge_page() to solve these issues.

For hugetlb file, recently we have truncating code so let's use it in
hugetlbfs specific ->error_remove_page().

For anonymous hugepage, it's helpful to dissolve the error page after
freeing it into free hugepage list.  Migration entry and PageHWPoison in
the head page prevent the access to it.

TODO: dissolve_free_huge_page() can fail but we don't considered it yet.
It's not critical (and at least no worse that now) because in such case
the error hugepage just stays in free hugepage list without being
dissolved.  By virtue of PageHWPoison in head page, it's never allocated
to processes.

[akpm@linux-foundation.org: fix unused var warnings]
Fixes: 23a003bfd23ea9ea0b7756b920e51f64b284b468 ("mm/madvise: pass return code of memory_failure() to userspace")
Link: http://lkml.kernel.org/r/20170417055948.GM31394@yexl-desktop
Link: http://lkml.kernel.org/r/1496305019-5493-8-git-send-email-n-horiguchi@ah.jp.nec.com
	Signed-off-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Reported-by: kernel test robot <lkp@intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 78bb920344b8a6f04b79a7c254041723b931c94f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory-failure.c
diff --cc mm/memory-failure.c
index 989a662e69f7,6f8f69f4a986..000000000000
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@@ -620,8 -611,6 +653,11 @@@ static int me_unknown(struct page *p, u
   */
  static int me_pagecache_clean(struct page *p, unsigned long pfn)
  {
++<<<<<<< HEAD
 +	int err;
 +	int ret = FAILED;
++=======
++>>>>>>> 78bb920344b8 (mm: hwpoison: dissolve in-use hugepage in unrecoverable memory error)
  	struct address_space *mapping;
  
  	delete_from_lru_cache(p);
@@@ -653,29 -642,7 +689,33 @@@
  	 *
  	 * Open: to take i_mutex or not for this? Right now we don't.
  	 */
++<<<<<<< HEAD
 +	if (mapping->a_ops->error_remove_page) {
 +		err = mapping->a_ops->error_remove_page(mapping, p);
 +		if (err != 0) {
 +			printk(KERN_INFO "MCE %#lx: Failed to punch page: %d\n",
 +					pfn, err);
 +		} else if (page_has_private(p) &&
 +				!try_to_release_page(p, GFP_NOIO)) {
 +			pr_info("MCE %#lx: failed to release buffers\n", pfn);
 +		} else {
 +			ret = RECOVERED;
 +		}
 +	} else {
 +		/*
 +		 * If the file system doesn't support it just invalidate
 +		 * This fails on dirty or anything with private pages
 +		 */
 +		if (invalidate_inode_page(p))
 +			ret = RECOVERED;
 +		else
 +			printk(KERN_INFO "MCE %#lx: Failed to invalidate\n",
 +				pfn);
 +	}
 +	return ret;
++=======
+ 	return truncate_error_page(p, pfn, mapping);
++>>>>>>> 78bb920344b8 (mm: hwpoison: dissolve in-use hugepage in unrecoverable memory error)
  }
  
  /*
@@@ -781,24 -748,29 +821,46 @@@ static int me_huge_page(struct page *p
  {
  	int res = 0;
  	struct page *hpage = compound_head(p);
+ 	struct address_space *mapping;
  
  	if (!PageHuge(hpage))
 -		return MF_DELAYED;
 +		return DELAYED;
  
++<<<<<<< HEAD
 +	/*
 +	 * We can safely recover from error on free or reserved (i.e.
 +	 * not in-use) hugepage by dequeuing it from freelist.
 +	 * To check whether a hugepage is in-use or not, we can't use
 +	 * page->lru because it can be used in other hugepage operations,
 +	 * such as __unmap_hugepage_range() and gather_surplus_pages().
 +	 * So instead we use page_mapping() and PageAnon().
 +	 */
 +	if (!(page_mapping(hpage) || PageAnon(hpage))) {
 +		res = dequeue_hwpoisoned_huge_page(hpage);
 +		if (!res)
 +			return RECOVERED;
 +	}
 +	return DELAYED;
++=======
+ 	mapping = page_mapping(hpage);
+ 	if (mapping) {
+ 		res = truncate_error_page(hpage, pfn, mapping);
+ 	} else {
+ 		unlock_page(hpage);
+ 		/*
+ 		 * migration entry prevents later access on error anonymous
+ 		 * hugepage, so we can free and dissolve it into buddy to
+ 		 * save healthy subpages.
+ 		 */
+ 		if (PageAnon(hpage))
+ 			put_page(hpage);
+ 		dissolve_free_huge_page(p);
+ 		res = MF_RECOVERED;
+ 		lock_page(hpage);
+ 	}
+ 
+ 	return res;
++>>>>>>> 78bb920344b8 (mm: hwpoison: dissolve in-use hugepage in unrecoverable memory error)
  }
  
  /*
@@@ -903,15 -867,14 +965,22 @@@ static int page_action(struct page_stat
  	result = ps->action(p, pfn);
  
  	count = page_count(p) - 1;
 -	if (ps->action == me_swapcache_dirty && result == MF_DELAYED)
 +	if (ps->action == me_swapcache_dirty && result == DELAYED)
  		count--;
++<<<<<<< HEAD
 +	if (count != 0) {
 +		printk(KERN_ERR
 +		       "MCE %#lx: %s page still referenced by %d users\n",
 +		       pfn, ps->msg, count);
 +		result = FAILED;
++=======
+ 	if (count > 0) {
+ 		pr_err("Memory failure: %#lx: %s still referenced by %d users\n",
+ 		       pfn, action_page_types[ps->type], count);
+ 		result = MF_FAILED;
++>>>>>>> 78bb920344b8 (mm: hwpoison: dissolve in-use hugepage in unrecoverable memory error)
  	}
 -	action_result(pfn, ps->type, result);
 +	action_result(pfn, ps->msg, result);
  
  	/* Could do more checks here if page looks ok */
  	/*
diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c
index bdd5c7827391..0c1b6ec67e4c 100644
--- a/fs/hugetlbfs/inode.c
+++ b/fs/hugetlbfs/inode.c
@@ -904,6 +904,16 @@ static int hugetlbfs_migrate_page(struct address_space *mapping,
 	return MIGRATEPAGE_SUCCESS;
 }
 
+static int hugetlbfs_error_remove_page(struct address_space *mapping,
+				struct page *page)
+{
+	struct inode *inode = mapping->host;
+
+	remove_huge_page(page);
+	hugetlb_fix_reserve_counts(inode);
+	return 0;
+}
+
 static int hugetlbfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(dentry->d_sb);
@@ -1019,6 +1029,7 @@ static const struct address_space_operations hugetlbfs_aops = {
 	.write_end	= hugetlbfs_write_end,
 	.set_page_dirty	= hugetlbfs_set_page_dirty,
 	.migratepage    = hugetlbfs_migrate_page,
+	.error_remove_page	= hugetlbfs_error_remove_page,
 };
 
 
* Unmerged path mm/memory-failure.c
