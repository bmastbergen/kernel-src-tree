nfsd: Fix races between nfsd4_cb_release() and nfsd4_shutdown_callback()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Trond Myklebust <trondmy@gmail.com>
commit 2bbfed98a4d82ac4e7abfcd4eba40bddfc670b1d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/2bbfed98.failed

When we're destroying the client lease, and we call
nfsd4_shutdown_callback(), we must ensure that we do not return
before all outstanding callbacks have terminated and have
released their payloads.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 2bbfed98a4d82ac4e7abfcd4eba40bddfc670b1d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4callback.c
#	fs/nfsd/state.h
diff --cc fs/nfsd/nfs4callback.c
index d692b9756e84,67d24a536082..000000000000
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@@ -744,29 -826,48 +744,58 @@@ static int max_cb_time(struct net *net
  	return max(nn->nfsd4_lease/10, (time_t)1) * HZ;
  }
  
++<<<<<<< HEAD
 +static struct rpc_cred *callback_cred;
 +
 +int set_callback_cred(void)
 +{
 +	if (callback_cred)
 +		return 0;
 +	callback_cred = rpc_lookup_machine_cred("nfs");
 +	if (!callback_cred)
 +		return -ENOMEM;
 +	return 0;
 +}
 +
 +static struct rpc_cred *get_backchannel_cred(struct nfs4_client *clp, struct rpc_clnt *client, struct nfsd4_session *ses)
++=======
+ static struct workqueue_struct *callback_wq;
+ 
+ static bool nfsd4_queue_cb(struct nfsd4_callback *cb)
+ {
+ 	return queue_work(callback_wq, &cb->cb_work);
+ }
+ 
+ static void nfsd41_cb_inflight_begin(struct nfs4_client *clp)
+ {
+ 	atomic_inc(&clp->cl_cb_inflight);
+ }
+ 
+ static void nfsd41_cb_inflight_end(struct nfs4_client *clp)
+ {
+ 
+ 	if (atomic_dec_and_test(&clp->cl_cb_inflight))
+ 		wake_up_var(&clp->cl_cb_inflight);
+ }
+ 
+ static void nfsd41_cb_inflight_wait_complete(struct nfs4_client *clp)
+ {
+ 	wait_var_event(&clp->cl_cb_inflight,
+ 			!atomic_read(&clp->cl_cb_inflight));
+ }
+ 
+ static const struct cred *get_backchannel_cred(struct nfs4_client *clp, struct rpc_clnt *client, struct nfsd4_session *ses)
++>>>>>>> 2bbfed98a4d8 (nfsd: Fix races between nfsd4_cb_release() and nfsd4_shutdown_callback())
  {
  	if (clp->cl_minorversion == 0) {
 -		client->cl_principal = clp->cl_cred.cr_targ_princ ?
 -			clp->cl_cred.cr_targ_princ : "nfs";
 -
 -		return get_cred(rpc_machine_cred());
 +		return get_rpccred(callback_cred);
  	} else {
 -		struct cred *kcred;
 +		struct rpc_auth *auth = client->cl_auth;
 +		struct auth_cred acred = {};
  
 -		kcred = prepare_kernel_cred(NULL);
 -		if (!kcred)
 -			return NULL;
 -
 -		kcred->uid = ses->se_cb_sec.uid;
 -		kcred->gid = ses->se_cb_sec.gid;
 -		return kcred;
 +		acred.uid = ses->se_cb_sec.uid;
 +		acred.gid = ses->se_cb_sec.gid;
 +		return auth->au_ops->lookup_cred(client->cl_auth, &acred, 0);
  	}
  }
  
diff --cc fs/nfsd/state.h
index d8bac46b3573,d61b83b9654c..000000000000
--- a/fs/nfsd/state.h
+++ b/fs/nfsd/state.h
@@@ -350,6 -365,9 +350,12 @@@ struct nfs4_client 
  	struct rpc_wait_queue	cl_cb_waitq;	/* backchannel callers may */
  						/* wait here for slots */
  	struct net		*net;
++<<<<<<< HEAD
++=======
+ 	struct list_head	async_copies;	/* list of async copies */
+ 	spinlock_t		async_lock;	/* lock for async copies */
+ 	atomic_t		cl_cb_inflight;	/* Outstanding callbacks */
++>>>>>>> 2bbfed98a4d8 (nfsd: Fix races between nfsd4_cb_release() and nfsd4_shutdown_callback())
  };
  
  /* struct nfs4_client_reset
* Unmerged path fs/nfsd/nfs4callback.c
* Unmerged path fs/nfsd/state.h
