kernel/sysctl.c: ignore out-of-range taint bits introduced via kernel.tainted

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Rafael Aquini <aquini@redhat.com>
commit e77132e75845470065768e2205727e6be52cb7f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/e77132e7.failed

Users with SYS_ADMIN capability can add arbitrary taint flags to the
running kernel by writing to /proc/sys/kernel/tainted or issuing the
command 'sysctl -w kernel.tainted=...'.  This interface, however, is
open for any integer value and this might cause an invalid set of flags
being committed to the tainted_mask bitset.

This patch introduces a simple way for proc_taint() to ignore any
eventual invalid bit coming from the user input before committing those
bits to the kernel tainted_mask.

	Signed-off-by: Rafael Aquini <aquini@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Luis Chamberlain <mcgrof@kernel.org>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: Iurii Zaikin <yzaikin@google.com>
	Cc: "Theodore Ts'o" <tytso@mit.edu>
Link: http://lkml.kernel.org/r/20200512223946.888020-1-aquini@redhat.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e77132e75845470065768e2205727e6be52cb7f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sysctl.c
diff --cc kernel/sysctl.c
index 10b17c319970,db1ce7af2563..000000000000
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@@ -1707,1569 -2176,1199 +1707,1573 @@@ static struct ctl_table fs_table[] = 
  		.mode		= 0644,
  		.proc_handler	= proc_dointvec,
  	},
 +#endif
 +#ifdef CONFIG_AIO
  	{
 -		.procname	= "panic_print",
 -		.data		= &panic_print,
 -		.maxlen		= sizeof(unsigned long),
 -		.mode		= 0644,
 +		.procname	= "aio-nr",
 +		.data		= &aio_nr,
 +		.maxlen		= sizeof(aio_nr),
 +		.mode		= 0444,
  		.proc_handler	= proc_doulongvec_minmax,
  	},
 -#if defined CONFIG_PRINTK
  	{
 -		.procname	= "printk",
 -		.data		= &console_loglevel,
 -		.maxlen		= 4*sizeof(int),
 +		.procname	= "aio-max-nr",
 +		.data		= &aio_max_nr,
 +		.maxlen		= sizeof(aio_max_nr),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 +		.proc_handler	= proc_doulongvec_minmax,
  	},
 +#endif /* CONFIG_AIO */
 +#ifdef CONFIG_INOTIFY_USER
  	{
 -		.procname	= "printk_ratelimit",
 -		.data		= &printk_ratelimit_state.interval,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_jiffies,
 +		.procname	= "inotify",
 +		.mode		= 0555,
 +		.child		= inotify_table,
  	},
 +#endif	
 +#ifdef CONFIG_EPOLL
  	{
 -		.procname	= "printk_ratelimit_burst",
 -		.data		= &printk_ratelimit_state.burst,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 +		.procname	= "epoll",
 +		.mode		= 0555,
 +		.child		= epoll_table,
  	},
 +#endif
 +#endif
  	{
 -		.procname	= "printk_delay",
 -		.data		= &printk_delay_msec,
 +		.procname	= "protected_symlinks",
 +		.data		= &sysctl_protected_symlinks,
  		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 +		.mode		= 0600,
  		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= &ten_thousand,
 -	},
 -	{
 -		.procname	= "printk_devkmsg",
 -		.data		= devkmsg_log_str,
 -		.maxlen		= DEVKMSG_STR_MAX_SIZE,
 -		.mode		= 0644,
 -		.proc_handler	= devkmsg_sysctl_set_loglvl,
 +		.extra1		= &zero,
 +		.extra2		= &one,
  	},
  	{
 -		.procname	= "dmesg_restrict",
 -		.data		= &dmesg_restrict,
 +		.procname	= "protected_hardlinks",
 +		.data		= &sysctl_protected_hardlinks,
  		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax_sysadmin,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 +		.mode		= 0600,
 +		.proc_handler	= proc_dointvec_minmax,
 +		.extra1		= &zero,
 +		.extra2		= &one,
  	},
  	{
 -		.procname	= "kptr_restrict",
 -		.data		= &kptr_restrict,
 +		.procname	= "suid_dumpable",
 +		.data		= &suid_dumpable,
  		.maxlen		= sizeof(int),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax_sysadmin,
 -		.extra1		= SYSCTL_ZERO,
 +		.proc_handler	= proc_dointvec_minmax_coredump,
 +		.extra1		= &zero,
  		.extra2		= &two,
  	},
 -#endif
 -	{
 -		.procname	= "ngroups_max",
 -		.data		= &ngroups_max,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0444,
 -		.proc_handler	= proc_dointvec,
 -	},
 +#if defined(CONFIG_BINFMT_MISC) || defined(CONFIG_BINFMT_MISC_MODULE)
  	{
 -		.procname	= "cap_last_cap",
 -		.data		= (void *)&cap_last_cap,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0444,
 -		.proc_handler	= proc_dointvec,
 +		.procname	= "binfmt_misc",
 +		.mode		= 0555,
 +		.child		= sysctl_mount_point,
  	},
 -#if defined(CONFIG_LOCKUP_DETECTOR)
 +#endif
  	{
 -		.procname       = "watchdog",
 -		.data		= &watchdog_user_enabled,
 -		.maxlen		= sizeof(int),
 +		.procname	= "pipe-max-size",
 +		.data		= &pipe_max_size,
 +		.maxlen		= sizeof(pipe_max_size),
  		.mode		= 0644,
 -		.proc_handler   = proc_watchdog,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 +		.proc_handler	= &pipe_proc_fn,
 +		.extra1		= &pipe_min_size,
  	},
  	{
 -		.procname	= "watchdog_thresh",
 -		.data		= &watchdog_thresh,
 -		.maxlen		= sizeof(int),
 +		.procname	= "pipe-user-pages-hard",
 +		.data		= &pipe_user_pages_hard,
 +		.maxlen		= sizeof(pipe_user_pages_hard),
  		.mode		= 0644,
 -		.proc_handler	= proc_watchdog_thresh,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= &sixty,
 -	},
 -	{
 -		.procname       = "nmi_watchdog",
 -		.data		= &nmi_watchdog_user_enabled,
 -		.maxlen		= sizeof(int),
 -		.mode		= NMI_WATCHDOG_SYSCTL_PERM,
 -		.proc_handler   = proc_nmi_watchdog,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 +		.proc_handler	= proc_doulongvec_minmax,
  	},
  	{
 -		.procname	= "watchdog_cpumask",
 -		.data		= &watchdog_cpumask_bits,
 -		.maxlen		= NR_CPUS,
 +		.procname	= "pipe-user-pages-soft",
 +		.data		= &pipe_user_pages_soft,
 +		.maxlen		= sizeof(pipe_user_pages_soft),
  		.mode		= 0644,
 -		.proc_handler	= proc_watchdog_cpumask,
 +		.proc_handler	= proc_doulongvec_minmax,
  	},
 -#ifdef CONFIG_SOFTLOCKUP_DETECTOR
  	{
 -		.procname       = "soft_watchdog",
 -		.data		= &soft_watchdog_user_enabled,
 -		.maxlen		= sizeof(int),
 +		.procname	= "mount-max",
 +		.data		= &sysctl_mount_max,
 +		.maxlen		= sizeof(unsigned int),
  		.mode		= 0644,
 -		.proc_handler   = proc_soft_watchdog,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 +		.proc_handler	= proc_dointvec_minmax,
 +		.extra1		= &one,
  	},
  	{
 -		.procname	= "softlockup_panic",
 -		.data		= &softlockup_panic,
 -		.maxlen		= sizeof(int),
 +		.procname	= "negative-dentry-limit",
 +		.data		= &dcache_negative_dentry_limit_sysctl,
 +		.maxlen		= sizeof(dcache_negative_dentry_limit_sysctl),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 +		.proc_handler	= proc_dcache_negative_dentry_limit,
 +		.extra1		= &zero,
 +		.extra2		= &one_hundred,
  	},
 -#ifdef CONFIG_SMP
 +	{ }
 +};
 +
 +static struct ctl_table debug_table[] = {
 +#ifdef CONFIG_SYSCTL_EXCEPTION_TRACE
  	{
 -		.procname	= "softlockup_all_cpu_backtrace",
 -		.data		= &sysctl_softlockup_all_cpu_backtrace,
 +		.procname	= "exception-trace",
 +		.data		= &show_unhandled_signals,
  		.maxlen		= sizeof(int),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 +		.proc_handler	= proc_dointvec
  	},
 -#endif /* CONFIG_SMP */
  #endif
 -#ifdef CONFIG_HARDLOCKUP_DETECTOR
 +#if defined(CONFIG_OPTPROBES)
  	{
 -		.procname	= "hardlockup_panic",
 -		.data		= &hardlockup_panic,
 +		.procname	= "kprobes-optimization",
 +		.data		= &sysctl_kprobes_optimization,
  		.maxlen		= sizeof(int),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 +		.proc_handler	= proc_kprobes_optimization_handler,
 +		.extra1		= &zero,
 +		.extra2		= &one,
  	},
 -#ifdef CONFIG_SMP
 +#endif
 +#if defined(CONFIG_TREE_RCU) || defined(CONFIG_PREEMPT_RCU)
  	{
 -		.procname	= "hardlockup_all_cpu_backtrace",
 -		.data		= &sysctl_hardlockup_all_cpu_backtrace,
 -		.maxlen		= sizeof(int),
 +		.procname	= "panic_on_rcu_stall",
 +		.data		= &sysctl_panic_on_rcu_stall,
 +		.maxlen		= sizeof(sysctl_panic_on_rcu_stall),
  		.mode		= 0644,
  		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 +		.extra1		= &zero,
 +		.extra2		= &one,
  	},
 -#endif /* CONFIG_SMP */
 -#endif
  #endif
 +	{ }
 +};
 +
 +static struct ctl_table dev_table[] = {
 +	{ }
 +};
 +
 +int __init sysctl_init(void)
 +{
 +	struct ctl_table_header *hdr;
 +
 +	hdr = register_sysctl_table(sysctl_base_table);
 +	kmemleak_not_leak(hdr);
 +	return 0;
 +}
 +
 +#endif /* CONFIG_SYSCTL */
 +
 +/*
 + * /proc/sys support
 + */
 +
 +#ifdef CONFIG_PROC_SYSCTL
 +
 +static int _proc_do_string(char *data, int maxlen, int write,
 +			   char __user *buffer,
 +			   size_t *lenp, loff_t *ppos)
 +{
 +	size_t len;
 +	char __user *p;
 +	char c;
 +
 +	if (!data || !maxlen || !*lenp) {
 +		*lenp = 0;
 +		return 0;
 +	}
 +
 +	if (write) {
 +		if (sysctl_writes_strict == SYSCTL_WRITES_STRICT) {
 +			/* Only continue writes not past the end of buffer. */
 +			len = strlen(data);
 +			if (len > maxlen - 1)
 +				len = maxlen - 1;
 +
 +			if (*ppos > len)
 +				return 0;
 +			len = *ppos;
 +		} else {
 +			/* Start writing from beginning of buffer. */
 +			len = 0;
 +		}
 +
 +		*ppos += *lenp;
 +		p = buffer;
 +		while ((p - buffer) < *lenp && len < maxlen - 1) {
 +			if (get_user(c, p++))
 +				return -EFAULT;
 +			if (c == 0 || c == '\n')
 +				break;
 +			data[len++] = c;
 +		}
 +		data[len] = 0;
 +	} else {
 +		len = strlen(data);
 +		if (len > maxlen)
 +			len = maxlen;
 +
 +		if (*ppos > len) {
 +			*lenp = 0;
 +			return 0;
 +		}
 +
 +		data += *ppos;
 +		len  -= *ppos;
 +
 +		if (len > *lenp)
 +			len = *lenp;
 +		if (len)
 +			if (copy_to_user(buffer, data, len))
 +				return -EFAULT;
 +		if (len < *lenp) {
 +			if (put_user('\n', buffer + len))
 +				return -EFAULT;
 +			len++;
 +		}
 +		*lenp = len;
 +		*ppos += len;
 +	}
 +	return 0;
 +}
  
 -#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_X86)
 -	{
 -		.procname       = "unknown_nmi_panic",
 -		.data           = &unknown_nmi_panic,
 -		.maxlen         = sizeof (int),
 -		.mode           = 0644,
 -		.proc_handler   = proc_dointvec,
 -	},
 -#endif
 +static void warn_sysctl_write(struct ctl_table *table)
 +{
 +	pr_warn_once("%s wrote to %s when file position was not 0!\n"
 +		"This will not be supported in the future. To silence this\n"
 +		"warning, set kernel.sysctl_writes_strict = -1\n",
 +		current->comm, table->procname);
 +}
 +
 +/**
 + * proc_first_pos_non_zero_ignore - check if firs position is allowed
 + * @ppos: file position
 + * @table: the sysctl table
 + *
 + * Returns true if the first position is non-zero and the sysctl_writes_strict
 + * mode indicates this is not allowed for numeric input types. String proc
 + * hadlers can ignore the return value.
 + */
 +static bool proc_first_pos_non_zero_ignore(loff_t *ppos,
 +					   struct ctl_table *table)
 +{
 +	if (!*ppos)
 +		return false;
 +
 +	switch (sysctl_writes_strict) {
 +	case SYSCTL_WRITES_STRICT:
 +		return true;
 +	case SYSCTL_WRITES_WARN:
 +		warn_sysctl_write(table);
 +		return false;
 +	default:
 +		return false;
 +	}
 +}
 +
 +/**
 + * proc_dostring - read a string sysctl
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes a string from/to the user buffer. If the kernel
 + * buffer provided is not large enough to hold the string, the
 + * string is truncated. The copied string is %NULL-terminated.
 + * If the string is being read by the user process, it is copied
 + * and a newline '\n' is added. It is truncated if the buffer is
 + * not large enough.
 + *
 + * Returns 0 on success.
 + */
 +int proc_dostring(struct ctl_table *table, int write,
 +		  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	if (write)
 +		proc_first_pos_non_zero_ignore(ppos, table);
 +
 +	return _proc_do_string((char *)(table->data), table->maxlen, write,
 +			       (char __user *)buffer, lenp, ppos);
 +}
 +
 +static size_t proc_skip_spaces(char **buf)
 +{
 +	size_t ret;
 +	char *tmp = skip_spaces(*buf);
 +	ret = tmp - *buf;
 +	*buf = tmp;
 +	return ret;
 +}
 +
 +static void proc_skip_char(char **buf, size_t *size, const char v)
 +{
 +	while (*size) {
 +		if (**buf != v)
 +			break;
 +		(*size)--;
 +		(*buf)++;
 +	}
 +}
 +
 +/**
 + * strtoul_lenient - parse an ASCII formatted integer from a buffer and only
 + *                   fail on overflow
 + *
 + * @cp: kernel buffer containing the string to parse
 + * @endp: pointer to store the trailing characters
 + * @base: the base to use
 + * @res: where the parsed integer will be stored
 + *
 + * In case of success 0 is returned and @res will contain the parsed integer,
 + * @endp will hold any trailing characters.
 + * This function will fail the parse on overflow. If there wasn't an overflow
 + * the function will defer the decision what characters count as invalid to the
 + * caller.
 + */
 +static int strtoul_lenient(const char *cp, char **endp, unsigned int base,
 +			   unsigned long *res)
 +{
 +	unsigned long long result;
 +	unsigned int rv;
 +
 +	cp = _parse_integer_fixup_radix(cp, &base);
 +	rv = _parse_integer(cp, base, &result);
 +	if ((rv & KSTRTOX_OVERFLOW) || (result != (unsigned long)result))
 +		return -ERANGE;
 +
 +	cp += rv;
 +
 +	if (endp)
 +		*endp = (char *)cp;
 +
 +	*res = (unsigned long)result;
 +	return 0;
 +}
 +
 +#define TMPBUFLEN 22
 +/**
 + * proc_get_long - reads an ASCII formatted integer from a user buffer
 + *
 + * @buf: a kernel buffer
 + * @size: size of the kernel buffer
 + * @val: this is where the number will be stored
 + * @neg: set to %TRUE if number is negative
 + * @perm_tr: a vector which contains the allowed trailers
 + * @perm_tr_len: size of the perm_tr vector
 + * @tr: pointer to store the trailer character
 + *
 + * In case of success %0 is returned and @buf and @size are updated with
 + * the amount of bytes read. If @tr is non-NULL and a trailing
 + * character exists (size is non-zero after returning from this
 + * function), @tr is updated with the trailing character.
 + */
 +static int proc_get_long(char **buf, size_t *size,
 +			  unsigned long *val, bool *neg,
 +			  const char *perm_tr, unsigned perm_tr_len, char *tr)
 +{
 +	int len;
 +	char *p, tmp[TMPBUFLEN];
 +
 +	if (!*size)
 +		return -EINVAL;
 +
 +	len = *size;
 +	if (len > TMPBUFLEN - 1)
 +		len = TMPBUFLEN - 1;
 +
 +	memcpy(tmp, *buf, len);
 +
 +	tmp[len] = 0;
 +	p = tmp;
 +	if (*p == '-' && *size > 1) {
 +		*neg = true;
 +		p++;
 +	} else
 +		*neg = false;
 +	if (!isdigit(*p))
 +		return -EINVAL;
 +
 +	if (strtoul_lenient(p, &p, 0, val))
 +		return -EINVAL;
 +
 +	len = p - tmp;
 +
 +	/* We don't know if the next char is whitespace thus we may accept
 +	 * invalid integers (e.g. 1234...a) or two integers instead of one
 +	 * (e.g. 123...1). So lets not allow such large numbers. */
 +	if (len == TMPBUFLEN - 1)
 +		return -EINVAL;
 +
 +	if (len < *size && perm_tr_len && !memchr(perm_tr, *p, perm_tr_len))
 +		return -EINVAL;
 +
 +	if (tr && (len < *size))
 +		*tr = *p;
 +
 +	*buf += len;
 +	*size -= len;
 +
 +	return 0;
 +}
 +
 +/**
 + * proc_put_long - converts an integer to a decimal ASCII formatted string
 + *
 + * @buf: the user buffer
 + * @size: the size of the user buffer
 + * @val: the integer to be converted
 + * @neg: sign of the number, %TRUE for negative
 + *
 + * In case of success %0 is returned and @buf and @size are updated with
 + * the amount of bytes written.
 + */
 +static int proc_put_long(void __user **buf, size_t *size, unsigned long val,
 +			  bool neg)
 +{
 +	int len;
 +	char tmp[TMPBUFLEN], *p = tmp;
 +
 +	sprintf(p, "%s%lu", neg ? "-" : "", val);
 +	len = strlen(tmp);
 +	if (len > *size)
 +		len = *size;
 +	if (copy_to_user(*buf, tmp, len))
 +		return -EFAULT;
 +	*size -= len;
 +	*buf += len;
 +	return 0;
 +}
 +#undef TMPBUFLEN
 +
 +static int proc_put_char(void __user **buf, size_t *size, char c)
 +{
 +	if (*size) {
 +		char __user **buffer = (char __user **)buf;
 +		if (put_user(c, *buffer))
 +			return -EFAULT;
 +		(*size)--, (*buffer)++;
 +		*buf = *buffer;
 +	}
 +	return 0;
 +}
 +
 +static int do_proc_dointvec_conv(bool *negp, unsigned long *lvalp,
 +				 int *valp,
 +				 int write, void *data)
 +{
 +	if (write) {
 +		if (*negp) {
 +			if (*lvalp > (unsigned long) INT_MAX + 1)
 +				return -EINVAL;
 +			*valp = -*lvalp;
 +		} else {
 +			if (*lvalp > (unsigned long) INT_MAX)
 +				return -EINVAL;
 +			*valp = *lvalp;
 +		}
 +	} else {
 +		int val = *valp;
 +		if (val < 0) {
 +			*negp = true;
 +			*lvalp = (unsigned long)-val;
 +		} else {
 +			*negp = false;
 +			*lvalp = (unsigned long)val;
 +		}
 +	}
 +	return 0;
 +}
 +
 +static int do_proc_douintvec_conv(unsigned long *lvalp,
 +				  unsigned int *valp,
 +				  int write, void *data)
 +{
 +	if (write) {
 +		if (*lvalp > UINT_MAX)
 +			return -EINVAL;
 +		*valp = *lvalp;
 +	} else {
 +		unsigned int val = *valp;
 +		*lvalp = (unsigned long)val;
 +	}
 +	return 0;
 +}
  
 -#if (defined(CONFIG_X86_32) || defined(CONFIG_PARISC)) && \
 -	defined(CONFIG_DEBUG_STACKOVERFLOW)
 -	{
 -		.procname	= "panic_on_stackoverflow",
 -		.data		= &sysctl_panic_on_stackoverflow,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#if defined(CONFIG_X86)
 -	{
 -		.procname	= "panic_on_unrecovered_nmi",
 -		.data		= &panic_on_unrecovered_nmi,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "panic_on_io_nmi",
 -		.data		= &panic_on_io_nmi,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "bootloader_type",
 -		.data		= &bootloader_type,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0444,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "bootloader_version",
 -		.data		= &bootloader_version,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0444,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "io_delay_type",
 -		.data		= &io_delay_type,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#if defined(CONFIG_MMU)
 -	{
 -		.procname	= "randomize_va_space",
 -		.data		= &randomize_va_space,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#if defined(CONFIG_S390) && defined(CONFIG_SMP)
 -	{
 -		.procname	= "spin_retry",
 -		.data		= &spin_retry,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#if	defined(CONFIG_ACPI_SLEEP) && defined(CONFIG_X86)
 -	{
 -		.procname	= "acpi_video_flags",
 -		.data		= &acpi_realmode_flags,
 -		.maxlen		= sizeof (unsigned long),
 -		.mode		= 0644,
 -		.proc_handler	= proc_doulongvec_minmax,
 -	},
 -#endif
 -#ifdef CONFIG_SYSCTL_ARCH_UNALIGN_NO_WARN
 -	{
 -		.procname	= "ignore-unaligned-usertrap",
 -		.data		= &no_unaligned_warning,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#ifdef CONFIG_IA64
 -	{
 -		.procname	= "unaligned-dump-stack",
 -		.data		= &unaligned_dump_stack,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#ifdef CONFIG_DETECT_HUNG_TASK
 -#ifdef CONFIG_SMP
 -	{
 -		.procname	= "hung_task_all_cpu_backtrace",
 -		.data		= &sysctl_hung_task_all_cpu_backtrace,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -#endif /* CONFIG_SMP */
 -	{
 -		.procname	= "hung_task_panic",
 -		.data		= &sysctl_hung_task_panic,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -	{
 -		.procname	= "hung_task_check_count",
 -		.data		= &sysctl_hung_task_check_count,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -	{
 -		.procname	= "hung_task_timeout_secs",
 -		.data		= &sysctl_hung_task_timeout_secs,
 -		.maxlen		= sizeof(unsigned long),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dohung_task_timeout_secs,
 -		.extra2		= &hung_task_timeout_max,
 -	},
 -	{
 -		.procname	= "hung_task_check_interval_secs",
 -		.data		= &sysctl_hung_task_check_interval_secs,
 -		.maxlen		= sizeof(unsigned long),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dohung_task_timeout_secs,
 -		.extra2		= &hung_task_timeout_max,
 -	},
 -	{
 -		.procname	= "hung_task_warnings",
 -		.data		= &sysctl_hung_task_warnings,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &neg_one,
 -	},
 -#endif
 -#ifdef CONFIG_RT_MUTEXES
 -	{
 -		.procname	= "max_lock_depth",
 -		.data		= &max_lock_depth,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -	{
 -		.procname	= "poweroff_cmd",
 -		.data		= &poweroff_cmd,
 -		.maxlen		= POWEROFF_CMD_PATH_LEN,
 -		.mode		= 0644,
 -		.proc_handler	= proc_dostring,
 -	},
 -#ifdef CONFIG_KEYS
 -	{
 -		.procname	= "keys",
 -		.mode		= 0555,
 -		.child		= key_sysctls,
 -	},
 -#endif
 -#ifdef CONFIG_PERF_EVENTS
 -	/*
 -	 * User-space scripts rely on the existence of this file
 -	 * as a feature check for perf_events being enabled.
 -	 *
 -	 * So it's an ABI, do not remove!
 -	 */
 -	{
 -		.procname	= "perf_event_paranoid",
 -		.data		= &sysctl_perf_event_paranoid,
 -		.maxlen		= sizeof(sysctl_perf_event_paranoid),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "perf_event_mlock_kb",
 -		.data		= &sysctl_perf_event_mlock,
 -		.maxlen		= sizeof(sysctl_perf_event_mlock),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "perf_event_max_sample_rate",
 -		.data		= &sysctl_perf_event_sample_rate,
 -		.maxlen		= sizeof(sysctl_perf_event_sample_rate),
 -		.mode		= 0644,
 -		.proc_handler	= perf_proc_update_handler,
 -		.extra1		= SYSCTL_ONE,
 -	},
 -	{
 -		.procname	= "perf_cpu_time_max_percent",
 -		.data		= &sysctl_perf_cpu_time_max_percent,
 -		.maxlen		= sizeof(sysctl_perf_cpu_time_max_percent),
 -		.mode		= 0644,
 -		.proc_handler	= perf_cpu_time_max_percent_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= &one_hundred,
 -	},
 -	{
 -		.procname	= "perf_event_max_stack",
 -		.data		= &sysctl_perf_event_max_stack,
 -		.maxlen		= sizeof(sysctl_perf_event_max_stack),
 -		.mode		= 0644,
 -		.proc_handler	= perf_event_max_stack_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= &six_hundred_forty_kb,
 -	},
 -	{
 -		.procname	= "perf_event_max_contexts_per_stack",
 -		.data		= &sysctl_perf_event_max_contexts_per_stack,
 -		.maxlen		= sizeof(sysctl_perf_event_max_contexts_per_stack),
 -		.mode		= 0644,
 -		.proc_handler	= perf_event_max_stack_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= &one_thousand,
 -	},
 -#endif
 -	{
 -		.procname	= "panic_on_warn",
 -		.data		= &panic_on_warn,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -#if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)
 -	{
 -		.procname	= "timer_migration",
 -		.data		= &sysctl_timer_migration,
 -		.maxlen		= sizeof(unsigned int),
 -		.mode		= 0644,
 -		.proc_handler	= timer_migration_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -#endif
 -#ifdef CONFIG_BPF_SYSCALL
 -	{
 -		.procname	= "unprivileged_bpf_disabled",
 -		.data		= &sysctl_unprivileged_bpf_disabled,
 -		.maxlen		= sizeof(sysctl_unprivileged_bpf_disabled),
 -		.mode		= 0644,
 -		/* only handle a transition from default "0" to "1" */
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ONE,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -	{
 -		.procname	= "bpf_stats_enabled",
 -		.data		= &bpf_stats_enabled_key.key,
 -		.maxlen		= sizeof(bpf_stats_enabled_key),
 -		.mode		= 0644,
 -		.proc_handler	= bpf_stats_handler,
 -	},
 -#endif
 -#if defined(CONFIG_TREE_RCU)
 -	{
 -		.procname	= "panic_on_rcu_stall",
 -		.data		= &sysctl_panic_on_rcu_stall,
 -		.maxlen		= sizeof(sysctl_panic_on_rcu_stall),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -#endif
 -#ifdef CONFIG_STACKLEAK_RUNTIME_DISABLE
 -	{
 -		.procname	= "stack_erasing",
 -		.data		= NULL,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0600,
 -		.proc_handler	= stack_erasing_sysctl,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -#endif
 -	{ }
 -};
 +static const char proc_wspace_sep[] = { ' ', '\t', '\n' };
 +
 +static int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,
 +		  int write, void __user *buffer,
 +		  size_t *lenp, loff_t *ppos,
 +		  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,
 +			      int write, void *data),
 +		  void *data)
 +{
 +	int *i, vleft, first = 1, err = 0;
 +	unsigned long page = 0;
 +	size_t left;
 +	char *kbuf;
 +	
 +	if (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {
 +		*lenp = 0;
 +		return 0;
 +	}
 +	
 +	i = (int *) tbl_data;
 +	vleft = table->maxlen / sizeof(*i);
 +	left = *lenp;
  
 -static struct ctl_table vm_table[] = {
 -	{
 -		.procname	= "overcommit_memory",
 -		.data		= &sysctl_overcommit_memory,
 -		.maxlen		= sizeof(sysctl_overcommit_memory),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= &two,
 -	},
 -	{
 -		.procname	= "panic_on_oom",
 -		.data		= &sysctl_panic_on_oom,
 -		.maxlen		= sizeof(sysctl_panic_on_oom),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= &two,
 -	},
 -	{
 -		.procname	= "oom_kill_allocating_task",
 -		.data		= &sysctl_oom_kill_allocating_task,
 -		.maxlen		= sizeof(sysctl_oom_kill_allocating_task),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "oom_dump_tasks",
 -		.data		= &sysctl_oom_dump_tasks,
 -		.maxlen		= sizeof(sysctl_oom_dump_tasks),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "overcommit_ratio",
 -		.data		= &sysctl_overcommit_ratio,
 -		.maxlen		= sizeof(sysctl_overcommit_ratio),
 -		.mode		= 0644,
 -		.proc_handler	= overcommit_ratio_handler,
 -	},
 -	{
 -		.procname	= "overcommit_kbytes",
 -		.data		= &sysctl_overcommit_kbytes,
 -		.maxlen		= sizeof(sysctl_overcommit_kbytes),
 -		.mode		= 0644,
 -		.proc_handler	= overcommit_kbytes_handler,
 -	},
 -	{
 -		.procname	= "page-cluster",
 -		.data		= &page_cluster,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -	{
 -		.procname	= "dirty_background_ratio",
 -		.data		= &dirty_background_ratio,
 -		.maxlen		= sizeof(dirty_background_ratio),
 -		.mode		= 0644,
 -		.proc_handler	= dirty_background_ratio_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= &one_hundred,
 -	},
 -	{
 -		.procname	= "dirty_background_bytes",
 -		.data		= &dirty_background_bytes,
 -		.maxlen		= sizeof(dirty_background_bytes),
 -		.mode		= 0644,
 -		.proc_handler	= dirty_background_bytes_handler,
 -		.extra1		= &one_ul,
 -	},
 -	{
 -		.procname	= "dirty_ratio",
 -		.data		= &vm_dirty_ratio,
 -		.maxlen		= sizeof(vm_dirty_ratio),
 -		.mode		= 0644,
 -		.proc_handler	= dirty_ratio_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= &one_hundred,
 -	},
 -	{
 -		.procname	= "dirty_bytes",
 -		.data		= &vm_dirty_bytes,
 -		.maxlen		= sizeof(vm_dirty_bytes),
 -		.mode		= 0644,
 -		.proc_handler	= dirty_bytes_handler,
 -		.extra1		= &dirty_bytes_min,
 -	},
 -	{
 -		.procname	= "dirty_writeback_centisecs",
 -		.data		= &dirty_writeback_interval,
 -		.maxlen		= sizeof(dirty_writeback_interval),
 -		.mode		= 0644,
 -		.proc_handler	= dirty_writeback_centisecs_handler,
 -	},
 -	{
 -		.procname	= "dirty_expire_centisecs",
 -		.data		= &dirty_expire_interval,
 -		.maxlen		= sizeof(dirty_expire_interval),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -	{
 -		.procname	= "dirtytime_expire_seconds",
 -		.data		= &dirtytime_expire_interval,
 -		.maxlen		= sizeof(dirtytime_expire_interval),
 -		.mode		= 0644,
 -		.proc_handler	= dirtytime_interval_handler,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -	{
 -		.procname	= "swappiness",
 -		.data		= &vm_swappiness,
 -		.maxlen		= sizeof(vm_swappiness),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= &two_hundred,
 -	},
 -#ifdef CONFIG_HUGETLB_PAGE
 -	{
 -		.procname	= "nr_hugepages",
 -		.data		= NULL,
 -		.maxlen		= sizeof(unsigned long),
 -		.mode		= 0644,
 -		.proc_handler	= hugetlb_sysctl_handler,
 -	},
 -#ifdef CONFIG_NUMA
 -	{
 -		.procname       = "nr_hugepages_mempolicy",
 -		.data           = NULL,
 -		.maxlen         = sizeof(unsigned long),
 -		.mode           = 0644,
 -		.proc_handler   = &hugetlb_mempolicy_sysctl_handler,
 -	},
 -	{
 -		.procname		= "numa_stat",
 -		.data			= &sysctl_vm_numa_stat,
 -		.maxlen			= sizeof(int),
 -		.mode			= 0644,
 -		.proc_handler	= sysctl_vm_numa_stat_handler,
 -		.extra1			= SYSCTL_ZERO,
 -		.extra2			= SYSCTL_ONE,
 -	},
 -#endif
 -	 {
 -		.procname	= "hugetlb_shm_group",
 -		.data		= &sysctl_hugetlb_shm_group,
 -		.maxlen		= sizeof(gid_t),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	 },
 -	{
 -		.procname	= "nr_overcommit_hugepages",
 -		.data		= NULL,
 -		.maxlen		= sizeof(unsigned long),
 -		.mode		= 0644,
 -		.proc_handler	= hugetlb_overcommit_handler,
 -	},
 -#endif
 -	{
 -		.procname	= "lowmem_reserve_ratio",
 -		.data		= &sysctl_lowmem_reserve_ratio,
 -		.maxlen		= sizeof(sysctl_lowmem_reserve_ratio),
 -		.mode		= 0644,
 -		.proc_handler	= lowmem_reserve_ratio_sysctl_handler,
 -	},
 -	{
 -		.procname	= "drop_caches",
 -		.data		= &sysctl_drop_caches,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0200,
 -		.proc_handler	= drop_caches_sysctl_handler,
 -		.extra1		= SYSCTL_ONE,
 -		.extra2		= &four,
 -	},
 -#ifdef CONFIG_COMPACTION
 -	{
 -		.procname	= "compact_memory",
 -		.data		= &sysctl_compact_memory,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0200,
 -		.proc_handler	= sysctl_compaction_handler,
 -	},
 -	{
 -		.procname	= "extfrag_threshold",
 -		.data		= &sysctl_extfrag_threshold,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &min_extfrag_threshold,
 -		.extra2		= &max_extfrag_threshold,
 -	},
 -	{
 -		.procname	= "compact_unevictable_allowed",
 -		.data		= &sysctl_compact_unevictable_allowed,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax_warn_RT_change,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 +	if (!conv)
 +		conv = do_proc_dointvec_conv;
 +
 +	if (write) {
 +		if (proc_first_pos_non_zero_ignore(ppos, table))
 +			goto out;
 +
 +		if (left > PAGE_SIZE - 1)
 +			left = PAGE_SIZE - 1;
 +		page = __get_free_page(GFP_TEMPORARY);
 +		kbuf = (char *) page;
 +		if (!kbuf)
 +			return -ENOMEM;
 +		if (copy_from_user(kbuf, buffer, left)) {
 +			err = -EFAULT;
 +			goto free;
 +		}
 +		kbuf[left] = 0;
 +	}
 +
 +	for (; left && vleft--; i++, first=0) {
 +		unsigned long lval;
 +		bool neg;
 +
 +		if (write) {
 +			left -= proc_skip_spaces(&kbuf);
 +
 +			if (!left)
 +				break;
 +			err = proc_get_long(&kbuf, &left, &lval, &neg,
 +					     proc_wspace_sep,
 +					     sizeof(proc_wspace_sep), NULL);
 +			if (err)
 +				break;
 +			if (conv(&neg, &lval, i, 1, data)) {
 +				err = -EINVAL;
 +				break;
 +			}
 +		} else {
 +			if (conv(&neg, &lval, i, 0, data)) {
 +				err = -EINVAL;
 +				break;
 +			}
 +			if (!first)
 +				err = proc_put_char(&buffer, &left, '\t');
 +			if (err)
 +				break;
 +			err = proc_put_long(&buffer, &left, lval, neg);
 +			if (err)
 +				break;
 +		}
 +	}
 +
 +	if (!write && !first && left && !err)
 +		err = proc_put_char(&buffer, &left, '\n');
 +	if (write && !err && left)
 +		left -= proc_skip_spaces(&kbuf);
 +free:
 +	if (write) {
 +		free_page(page);
 +		if (first)
 +			return err ? : -EINVAL;
 +	}
 +	*lenp -= left;
 +out:
 +	*ppos += *lenp;
 +	return err;
 +}
 +
 +static int do_proc_dointvec(struct ctl_table *table, int write,
 +		  void __user *buffer, size_t *lenp, loff_t *ppos,
 +		  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,
 +			      int write, void *data),
 +		  void *data)
 +{
 +	return __do_proc_dointvec(table->data, table, write,
 +			buffer, lenp, ppos, conv, data);
 +}
 +
 +static int do_proc_douintvec_w(unsigned int *tbl_data,
 +			       struct ctl_table *table,
 +			       void __user *buffer,
 +			       size_t *lenp, loff_t *ppos,
 +			       int (*conv)(unsigned long *lvalp,
 +					   unsigned int *valp,
 +					   int write, void *data),
 +			       void *data)
 +{
 +	unsigned long lval;
 +	int err = 0;
 +	size_t left;
 +	bool neg;
 +	char *kbuf = NULL, *p;
  
 -#endif /* CONFIG_COMPACTION */
 -	{
 -		.procname	= "min_free_kbytes",
 -		.data		= &min_free_kbytes,
 -		.maxlen		= sizeof(min_free_kbytes),
 -		.mode		= 0644,
 -		.proc_handler	= min_free_kbytes_sysctl_handler,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -	{
 -		.procname	= "watermark_boost_factor",
 -		.data		= &watermark_boost_factor,
 -		.maxlen		= sizeof(watermark_boost_factor),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -	{
 -		.procname	= "watermark_scale_factor",
 -		.data		= &watermark_scale_factor,
 -		.maxlen		= sizeof(watermark_scale_factor),
 -		.mode		= 0644,
 -		.proc_handler	= watermark_scale_factor_sysctl_handler,
 -		.extra1		= SYSCTL_ONE,
 -		.extra2		= &one_thousand,
 -	},
 -	{
 -		.procname	= "percpu_pagelist_fraction",
 -		.data		= &percpu_pagelist_fraction,
 -		.maxlen		= sizeof(percpu_pagelist_fraction),
 -		.mode		= 0644,
 -		.proc_handler	= percpu_pagelist_fraction_sysctl_handler,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -#ifdef CONFIG_MMU
 -	{
 -		.procname	= "max_map_count",
 -		.data		= &sysctl_max_map_count,
 -		.maxlen		= sizeof(sysctl_max_map_count),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -#else
 -	{
 -		.procname	= "nr_trim_pages",
 -		.data		= &sysctl_nr_trim_pages,
 -		.maxlen		= sizeof(sysctl_nr_trim_pages),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -#endif
 -	{
 -		.procname	= "laptop_mode",
 -		.data		= &laptop_mode,
 -		.maxlen		= sizeof(laptop_mode),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_jiffies,
 -	},
 -	{
 -		.procname	= "block_dump",
 -		.data		= &block_dump,
 -		.maxlen		= sizeof(block_dump),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -	{
 -		.procname	= "vfs_cache_pressure",
 -		.data		= &sysctl_vfs_cache_pressure,
 -		.maxlen		= sizeof(sysctl_vfs_cache_pressure),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -#if defined(HAVE_ARCH_PICK_MMAP_LAYOUT) || \
 -    defined(CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT)
 -	{
 -		.procname	= "legacy_va_layout",
 -		.data		= &sysctl_legacy_va_layout,
 -		.maxlen		= sizeof(sysctl_legacy_va_layout),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -#endif
 -#ifdef CONFIG_NUMA
 -	{
 -		.procname	= "zone_reclaim_mode",
 -		.data		= &node_reclaim_mode,
 -		.maxlen		= sizeof(node_reclaim_mode),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -	{
 -		.procname	= "min_unmapped_ratio",
 -		.data		= &sysctl_min_unmapped_ratio,
 -		.maxlen		= sizeof(sysctl_min_unmapped_ratio),
 -		.mode		= 0644,
 -		.proc_handler	= sysctl_min_unmapped_ratio_sysctl_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= &one_hundred,
 -	},
 -	{
 -		.procname	= "min_slab_ratio",
 -		.data		= &sysctl_min_slab_ratio,
 -		.maxlen		= sizeof(sysctl_min_slab_ratio),
 -		.mode		= 0644,
 -		.proc_handler	= sysctl_min_slab_ratio_sysctl_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= &one_hundred,
 -	},
 -#endif
 -#ifdef CONFIG_SMP
 -	{
 -		.procname	= "stat_interval",
 -		.data		= &sysctl_stat_interval,
 -		.maxlen		= sizeof(sysctl_stat_interval),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_jiffies,
 -	},
 -	{
 -		.procname	= "stat_refresh",
 -		.data		= NULL,
 -		.maxlen		= 0,
 -		.mode		= 0600,
 -		.proc_handler	= vmstat_refresh,
 -	},
 -#endif
 -#ifdef CONFIG_MMU
 -	{
 -		.procname	= "mmap_min_addr",
 -		.data		= &dac_mmap_min_addr,
 -		.maxlen		= sizeof(unsigned long),
 -		.mode		= 0644,
 -		.proc_handler	= mmap_min_addr_handler,
 -	},
 -#endif
 -#ifdef CONFIG_NUMA
 -	{
 -		.procname	= "numa_zonelist_order",
 -		.data		= &numa_zonelist_order,
 -		.maxlen		= NUMA_ZONELIST_ORDER_LEN,
 -		.mode		= 0644,
 -		.proc_handler	= numa_zonelist_order_handler,
 -	},
 -#endif
 -#if (defined(CONFIG_X86_32) && !defined(CONFIG_UML))|| \
 -   (defined(CONFIG_SUPERH) && defined(CONFIG_VSYSCALL))
 -	{
 -		.procname	= "vdso_enabled",
 -#ifdef CONFIG_X86_32
 -		.data		= &vdso32_enabled,
 -		.maxlen		= sizeof(vdso32_enabled),
 -#else
 -		.data		= &vdso_enabled,
 -		.maxlen		= sizeof(vdso_enabled),
 -#endif
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -#endif
 -#ifdef CONFIG_HIGHMEM
 -	{
 -		.procname	= "highmem_is_dirtyable",
 -		.data		= &vm_highmem_is_dirtyable,
 -		.maxlen		= sizeof(vm_highmem_is_dirtyable),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -#endif
 -#ifdef CONFIG_MEMORY_FAILURE
 -	{
 -		.procname	= "memory_failure_early_kill",
 -		.data		= &sysctl_memory_failure_early_kill,
 -		.maxlen		= sizeof(sysctl_memory_failure_early_kill),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -	{
 -		.procname	= "memory_failure_recovery",
 -		.data		= &sysctl_memory_failure_recovery,
 -		.maxlen		= sizeof(sysctl_memory_failure_recovery),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -#endif
 -	{
 -		.procname	= "user_reserve_kbytes",
 -		.data		= &sysctl_user_reserve_kbytes,
 -		.maxlen		= sizeof(sysctl_user_reserve_kbytes),
 -		.mode		= 0644,
 -		.proc_handler	= proc_doulongvec_minmax,
 -	},
 -	{
 -		.procname	= "admin_reserve_kbytes",
 -		.data		= &sysctl_admin_reserve_kbytes,
 -		.maxlen		= sizeof(sysctl_admin_reserve_kbytes),
 -		.mode		= 0644,
 -		.proc_handler	= proc_doulongvec_minmax,
 -	},
 -#ifdef CONFIG_HAVE_ARCH_MMAP_RND_BITS
 -	{
 -		.procname	= "mmap_rnd_bits",
 -		.data		= &mmap_rnd_bits,
 -		.maxlen		= sizeof(mmap_rnd_bits),
 -		.mode		= 0600,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= (void *)&mmap_rnd_bits_min,
 -		.extra2		= (void *)&mmap_rnd_bits_max,
 -	},
 +	left = *lenp;
 +
 +	if (proc_first_pos_non_zero_ignore(ppos, table))
 +		goto bail_early;
 +
 +	if (left > PAGE_SIZE - 1)
 +		left = PAGE_SIZE - 1;
 +
 +	p = kbuf = memdup_user_nul(buffer, left);
 +	if (IS_ERR(kbuf))
 +		return -EINVAL;
 +
 +	left -= proc_skip_spaces(&p);
 +	if (!left) {
 +		err = -EINVAL;
 +		goto out_free;
 +	}
 +
 +	err = proc_get_long(&p, &left, &lval, &neg,
 +			     proc_wspace_sep,
 +			     sizeof(proc_wspace_sep), NULL);
 +	if (err || neg) {
 +		err = -EINVAL;
 +		goto out_free;
 +	}
 +
 +	if (conv(&lval, tbl_data, 1, data)) {
 +		err = -EINVAL;
 +		goto out_free;
 +	}
 +
 +	if (!err && left)
 +		left -= proc_skip_spaces(&p);
 +
 +out_free:
 +	kfree(kbuf);
 +	if (err)
 +		return -EINVAL;
 +
 +	return 0;
 +
 +	/* This is in keeping with old __do_proc_dointvec() */
 +bail_early:
 +	*ppos += *lenp;
 +	return err;
 +}
 +
 +static int do_proc_douintvec_r(unsigned int *tbl_data, void __user *buffer,
 +			       size_t *lenp, loff_t *ppos,
 +			       int (*conv)(unsigned long *lvalp,
 +					   unsigned int *valp,
 +					   int write, void *data),
 +			       void *data)
 +{
 +	unsigned long lval;
 +	int err = 0;
 +	size_t left;
 +
 +	left = *lenp;
 +
 +	if (conv(&lval, tbl_data, 0, data)) {
 +		err = -EINVAL;
 +		goto out;
 +	}
 +
 +	err = proc_put_long(&buffer, &left, lval, false);
 +	if (err || !left)
 +		goto out;
 +
 +	err = proc_put_char(&buffer, &left, '\n');
 +
 +out:
 +	*lenp -= left;
 +	*ppos += *lenp;
 +
 +	return err;
 +}
 +
 +static int __do_proc_douintvec(void *tbl_data, struct ctl_table *table,
 +			       int write, void __user *buffer,
 +			       size_t *lenp, loff_t *ppos,
 +			       int (*conv)(unsigned long *lvalp,
 +					   unsigned int *valp,
 +					   int write, void *data),
 +			       void *data)
 +{
 +	unsigned int *i, vleft;
 +
 +	if (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {
 +		*lenp = 0;
 +		return 0;
 +	}
 +
 +	i = (unsigned int *) tbl_data;
 +	vleft = table->maxlen / sizeof(*i);
 +
 +	/*
 +	 * Arrays are not supported, keep this simple. *Do not* add
 +	 * support for them.
 +	 */
 +	if (vleft != 1) {
 +		*lenp = 0;
 +		return -EINVAL;
 +	}
 +
 +	if (!conv)
 +		conv = do_proc_douintvec_conv;
 +
 +	if (write)
 +		return do_proc_douintvec_w(i, table, buffer, lenp, ppos,
 +					   conv, data);
 +	return do_proc_douintvec_r(i, buffer, lenp, ppos, conv, data);
 +}
 +
 +static int do_proc_douintvec(struct ctl_table *table, int write,
 +			     void __user *buffer, size_t *lenp, loff_t *ppos,
 +			     int (*conv)(unsigned long *lvalp,
 +					 unsigned int *valp,
 +					 int write, void *data),
 +			     void *data)
 +{
 +	return __do_proc_douintvec(table->data, table, write,
 +				   buffer, lenp, ppos, conv, data);
 +}
 +
 +/**
 + * proc_dointvec - read a vector of integers
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
 + * values from/to the user buffer, treated as an ASCII string. 
 + *
 + * Returns 0 on success.
 + */
 +int proc_dointvec(struct ctl_table *table, int write,
 +		     void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return do_proc_dointvec(table, write, buffer, lenp, ppos, NULL, NULL);
 +}
 +
 +/**
 + * proc_douintvec - read a vector of unsigned integers
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned int) unsigned integer
 + * values from/to the user buffer, treated as an ASCII string.
 + *
 + * Returns 0 on success.
 + */
 +int proc_douintvec(struct ctl_table *table, int write,
 +		     void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return do_proc_douintvec(table, write, buffer, lenp, ppos,
 +				 do_proc_douintvec_conv, NULL);
 +}
 +
 +/*
 + * Taint values can only be increased
 + * This means we can safely use a temporary.
 + */
 +static int proc_taint(struct ctl_table *table, int write,
 +			       void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	struct ctl_table t;
 +	unsigned long tmptaint = get_taint();
 +	int err;
 +
 +	if (write && !capable(CAP_SYS_ADMIN))
 +		return -EPERM;
 +
 +	t = *table;
 +	t.data = &tmptaint;
 +	err = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);
 +	if (err < 0)
 +		return err;
 +
 +	if (write) {
 +		/*
 +		 * Poor man's atomic or. Not worth adding a primitive
 +		 * to everyone's atomic.h for this
 +		 */
++<<<<<<< HEAD
 +		int i;
 +		for (i = 0; i < BITS_PER_LONG && tmptaint >> i; i++) {
 +			if ((tmptaint >> i) & 1)
++=======
++		for (i = 0; i < TAINT_FLAGS_COUNT; i++)
++			if ((1UL << i) & tmptaint)
++>>>>>>> e77132e75845 (kernel/sysctl.c: ignore out-of-range taint bits introduced via kernel.tainted)
 +				add_taint(i, LOCKDEP_STILL_OK);
- 		}
 +	}
 +
 +	return err;
 +}
 +
 +#ifdef CONFIG_PRINTK
 +static int proc_dointvec_minmax_sysadmin(struct ctl_table *table, int write,
 +				void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	if (write && !capable(CAP_SYS_ADMIN))
 +		return -EPERM;
 +
 +	return proc_dointvec_minmax(table, write, buffer, lenp, ppos);
 +}
  #endif
 -#ifdef CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS
 -	{
 -		.procname	= "mmap_rnd_compat_bits",
 -		.data		= &mmap_rnd_compat_bits,
 -		.maxlen		= sizeof(mmap_rnd_compat_bits),
 -		.mode		= 0600,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= (void *)&mmap_rnd_compat_bits_min,
 -		.extra2		= (void *)&mmap_rnd_compat_bits_max,
 -	},
 +
 +struct do_proc_dointvec_minmax_conv_param {
 +	int *min;
 +	int *max;
 +};
 +
 +static int do_proc_dointvec_minmax_conv(bool *negp, unsigned long *lvalp,
 +					int *valp,
 +					int write, void *data)
 +{
 +	int tmp, ret;
 +	struct do_proc_dointvec_minmax_conv_param *param = data;
 +	/*
 +	 * If writing, first do so via a temporary local int so we can
 +	 * bounds-check it before touching *valp.
 +	 */
 +	int *ip = write ? &tmp : valp;
 +
 +	ret = do_proc_dointvec_conv(negp, lvalp, ip, write, data);
 +	if (ret)
 +		return ret;
 +
 +	if (write) {
 +		if ((param->min && *param->min > tmp) ||
 +		    (param->max && *param->max < tmp))
 +			return -EINVAL;
 +		*valp = tmp;
 +	}
 +
 +	return 0;
 +}
 +
 +/**
 + * proc_dointvec_minmax - read a vector of integers with min/max values
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
 + * values from/to the user buffer, treated as an ASCII string.
 + *
 + * This routine will ensure the values are within the range specified by
 + * table->extra1 (min) and table->extra2 (max).
 + *
 + * Returns 0 on success.
 + */
 +int proc_dointvec_minmax(struct ctl_table *table, int write,
 +		  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	struct do_proc_dointvec_minmax_conv_param param = {
 +		.min = (int *) table->extra1,
 +		.max = (int *) table->extra2,
 +	};
 +	return do_proc_dointvec(table, write, buffer, lenp, ppos,
 +				do_proc_dointvec_minmax_conv, &param);
 +}
 +
 +struct do_proc_douintvec_minmax_conv_param {
 +	unsigned int *min;
 +	unsigned int *max;
 +};
 +
 +static int do_proc_douintvec_minmax_conv(unsigned long *lvalp,
 +					 unsigned int *valp,
 +					 int write, void *data)
 +{
 +	int ret;
 +	unsigned int tmp;
 +	struct do_proc_douintvec_minmax_conv_param *param = data;
 +	/* write via temporary local uint for bounds-checking */
 +	unsigned int *up = write ? &tmp : valp;
 +
 +	ret = do_proc_douintvec_conv(lvalp, up, write, data);
 +	if (ret)
 +		return ret;
 +
 +	if (write) {
 +		if ((param->min && *param->min > tmp) ||
 +		    (param->max && *param->max < tmp))
 +			return -ERANGE;
 +
 +		*valp = tmp;
 +	}
 +
 +	return 0;
 +}
 +
 +/**
 + * proc_douintvec_minmax - read a vector of unsigned ints with min/max values
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned int) unsigned integer
 + * values from/to the user buffer, treated as an ASCII string. Negative
 + * strings are not allowed.
 + *
 + * This routine will ensure the values are within the range specified by
 + * table->extra1 (min) and table->extra2 (max). There is a final sanity
 + * check for UINT_MAX to avoid having to support wrap around uses from
 + * userspace.
 + *
 + * Returns 0 on success.
 + */
 +int proc_douintvec_minmax(struct ctl_table *table, int write,
 +			  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	struct do_proc_douintvec_minmax_conv_param param = {
 +		.min = (unsigned int *) table->extra1,
 +		.max = (unsigned int *) table->extra2,
 +	};
 +	return do_proc_douintvec(table, write, buffer, lenp, ppos,
 +				 do_proc_douintvec_minmax_conv, &param);
 +}
 +
 +struct do_proc_dopipe_max_size_conv_param {
 +	unsigned int *min;
 +};
 +
 +static int do_proc_dopipe_max_size_conv(unsigned long *lvalp,
 +					unsigned int *valp,
 +					int write, void *data)
 +{
 +	struct do_proc_dopipe_max_size_conv_param *param = data;
 +
 +	if (write) {
 +		unsigned int val;
 +
 +		if (*lvalp > UINT_MAX)
 +			return -EINVAL;
 +
 +		val = round_pipe_size(*lvalp);
 +		if (val == 0)
 +			return -EINVAL;
 +
 +		if (param->min && *param->min > val)
 +			return -ERANGE;
 +
 +		*valp = val;
 +	} else {
 +		unsigned int val = *valp;
 +		*lvalp = (unsigned long) val;
 +	}
 +
 +	return 0;
 +}
 +
 +int proc_dopipe_max_size(struct ctl_table *table, int write,
 +			 void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	struct do_proc_dopipe_max_size_conv_param param = {
 +		.min = (unsigned int *) table->extra1,
 +	};
 +	return do_proc_douintvec(table, write, buffer, lenp, ppos,
 +				 do_proc_dopipe_max_size_conv, &param);
 +}
 +
 +static void validate_coredump_safety(void)
 +{
 +#ifdef CONFIG_COREDUMP
 +	if (suid_dumpable == SUID_DUMP_ROOT &&
 +	    core_pattern[0] != '/' && core_pattern[0] != '|') {
 +		printk(KERN_WARNING "Unsafe core_pattern used with "\
 +			"suid_dumpable=2. Pipe handler or fully qualified "\
 +			"core dump path required.\n");
 +	}
  #endif
 -#ifdef CONFIG_USERFAULTFD
 -	{
 -		.procname	= "unprivileged_userfaultfd",
 -		.data		= &sysctl_unprivileged_userfaultfd,
 -		.maxlen		= sizeof(sysctl_unprivileged_userfaultfd),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 +}
 +
 +static int proc_dointvec_minmax_coredump(struct ctl_table *table, int write,
 +		void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	int error = proc_dointvec_minmax(table, write, buffer, lenp, ppos);
 +	if (!error)
 +		validate_coredump_safety();
 +	return error;
 +}
 +
 +#ifdef CONFIG_COREDUMP
 +static int proc_dostring_coredump(struct ctl_table *table, int write,
 +		  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	int error = proc_dostring(table, write, buffer, lenp, ppos);
 +	if (!error)
 +		validate_coredump_safety();
 +	return error;
 +}
  #endif
 -	{ }
 -};
  
 -static struct ctl_table fs_table[] = {
 -	{
 -		.procname	= "inode-nr",
 -		.data		= &inodes_stat,
 -		.maxlen		= 2*sizeof(long),
 -		.mode		= 0444,
 -		.proc_handler	= proc_nr_inodes,
 -	},
 -	{
 -		.procname	= "inode-state",
 -		.data		= &inodes_stat,
 -		.maxlen		= 7*sizeof(long),
 -		.mode		= 0444,
 -		.proc_handler	= proc_nr_inodes,
 -	},
 -	{
 -		.procname	= "file-nr",
 -		.data		= &files_stat,
 -		.maxlen		= sizeof(files_stat),
 -		.mode		= 0444,
 -		.proc_handler	= proc_nr_files,
 -	},
 -	{
 -		.procname	= "file-max",
 -		.data		= &files_stat.max_files,
 -		.maxlen		= sizeof(files_stat.max_files),
 -		.mode		= 0644,
 -		.proc_handler	= proc_doulongvec_minmax,
 -		.extra1		= &zero_ul,
 -		.extra2		= &long_max,
 -	},
 -	{
 -		.procname	= "nr_open",
 -		.data		= &sysctl_nr_open,
 -		.maxlen		= sizeof(unsigned int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &sysctl_nr_open_min,
 -		.extra2		= &sysctl_nr_open_max,
 -	},
 -	{
 -		.procname	= "dentry-state",
 -		.data		= &dentry_stat,
 -		.maxlen		= 6*sizeof(long),
 -		.mode		= 0444,
 -		.proc_handler	= proc_nr_dentry,
 -	},
 -	{
 -		.procname	= "overflowuid",
 -		.data		= &fs_overflowuid,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &minolduid,
 -		.extra2		= &maxolduid,
 -	},
 -	{
 -		.procname	= "overflowgid",
 -		.data		= &fs_overflowgid,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &minolduid,
 -		.extra2		= &maxolduid,
 -	},
 -#ifdef CONFIG_FILE_LOCKING
 -	{
 -		.procname	= "leases-enable",
 -		.data		= &leases_enable,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#ifdef CONFIG_DNOTIFY
 -	{
 -		.procname	= "dir-notify-enable",
 -		.data		= &dir_notify_enable,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#ifdef CONFIG_MMU
 -#ifdef CONFIG_FILE_LOCKING
 -	{
 -		.procname	= "lease-break-time",
 -		.data		= &lease_break_time,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#ifdef CONFIG_AIO
 -	{
 -		.procname	= "aio-nr",
 -		.data		= &aio_nr,
 -		.maxlen		= sizeof(aio_nr),
 -		.mode		= 0444,
 -		.proc_handler	= proc_doulongvec_minmax,
 -	},
 -	{
 -		.procname	= "aio-max-nr",
 -		.data		= &aio_max_nr,
 -		.maxlen		= sizeof(aio_max_nr),
 -		.mode		= 0644,
 -		.proc_handler	= proc_doulongvec_minmax,
 -	},
 -#endif /* CONFIG_AIO */
 -#ifdef CONFIG_INOTIFY_USER
 -	{
 -		.procname	= "inotify",
 -		.mode		= 0555,
 -		.child		= inotify_table,
 -	},
 -#endif	
 -#ifdef CONFIG_EPOLL
 -	{
 -		.procname	= "epoll",
 -		.mode		= 0555,
 -		.child		= epoll_table,
 -	},
 -#endif
 -#endif
 -	{
 -		.procname	= "protected_symlinks",
 -		.data		= &sysctl_protected_symlinks,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0600,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -	{
 -		.procname	= "protected_hardlinks",
 -		.data		= &sysctl_protected_hardlinks,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0600,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -	{
 -		.procname	= "protected_fifos",
 -		.data		= &sysctl_protected_fifos,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0600,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= &two,
 -	},
 -	{
 -		.procname	= "protected_regular",
 -		.data		= &sysctl_protected_regular,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0600,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= &two,
 -	},
 -	{
 -		.procname	= "suid_dumpable",
 -		.data		= &suid_dumpable,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax_coredump,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= &two,
 -	},
 -#if defined(CONFIG_BINFMT_MISC) || defined(CONFIG_BINFMT_MISC_MODULE)
 -	{
 -		.procname	= "binfmt_misc",
 -		.mode		= 0555,
 -		.child		= sysctl_mount_point,
 -	},
 -#endif
 -	{
 -		.procname	= "pipe-max-size",
 -		.data		= &pipe_max_size,
 -		.maxlen		= sizeof(pipe_max_size),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dopipe_max_size,
 -	},
 -	{
 -		.procname	= "pipe-user-pages-hard",
 -		.data		= &pipe_user_pages_hard,
 -		.maxlen		= sizeof(pipe_user_pages_hard),
 -		.mode		= 0644,
 -		.proc_handler	= proc_doulongvec_minmax,
 -	},
 -	{
 -		.procname	= "pipe-user-pages-soft",
 -		.data		= &pipe_user_pages_soft,
 -		.maxlen		= sizeof(pipe_user_pages_soft),
 -		.mode		= 0644,
 -		.proc_handler	= proc_doulongvec_minmax,
 -	},
 -	{
 -		.procname	= "mount-max",
 -		.data		= &sysctl_mount_max,
 -		.maxlen		= sizeof(unsigned int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ONE,
 -	},
 -	{ }
 -};
 +static int __do_proc_doulongvec_minmax(void *data, struct ctl_table *table, int write,
 +				     void __user *buffer,
 +				     size_t *lenp, loff_t *ppos,
 +				     unsigned long convmul,
 +				     unsigned long convdiv)
 +{
 +	unsigned long *i, *min, *max;
 +	int vleft, first = 1, err = 0;
 +	unsigned long page = 0;
 +	size_t left;
 +	char *kbuf;
 +
 +	if (!data || !table->maxlen || !*lenp || (*ppos && !write)) {
 +		*lenp = 0;
 +		return 0;
 +	}
 +
 +	i = (unsigned long *) data;
 +	min = (unsigned long *) table->extra1;
 +	max = (unsigned long *) table->extra2;
 +	vleft = table->maxlen / sizeof(unsigned long);
 +	left = *lenp;
 +
 +	if (write) {
 +		if (proc_first_pos_non_zero_ignore(ppos, table))
 +			goto out;
 +
 +		if (left > PAGE_SIZE - 1)
 +			left = PAGE_SIZE - 1;
 +		page = __get_free_page(GFP_TEMPORARY);
 +		kbuf = (char *) page;
 +		if (!kbuf)
 +			return -ENOMEM;
 +		if (copy_from_user(kbuf, buffer, left)) {
 +			err = -EFAULT;
 +			goto free;
 +		}
 +		kbuf[left] = 0;
 +	}
 +
 +	for (; left && vleft--; i++, first = 0) {
 +		unsigned long val;
 +
 +		if (write) {
 +			bool neg;
 +
 +			left -= proc_skip_spaces(&kbuf);
 +
 +			err = proc_get_long(&kbuf, &left, &val, &neg,
 +					     proc_wspace_sep,
 +					     sizeof(proc_wspace_sep), NULL);
 +			if (err)
 +				break;
 +			if (neg)
 +				continue;
 +			if ((min && val < *min) || (max && val > *max))
 +				continue;
 +			*i = val;
 +		} else {
 +			val = convdiv * (*i) / convmul;
 +			if (!first)
 +				err = proc_put_char(&buffer, &left, '\t');
 +			err = proc_put_long(&buffer, &left, val, false);
 +			if (err)
 +				break;
 +		}
 +	}
 +
 +	if (!write && !first && left && !err)
 +		err = proc_put_char(&buffer, &left, '\n');
 +	if (write && !err)
 +		left -= proc_skip_spaces(&kbuf);
 +free:
 +	if (write) {
 +		free_page(page);
 +		if (first)
 +			return err ? : -EINVAL;
 +	}
 +	*lenp -= left;
 +out:
 +	*ppos += *lenp;
 +	return err;
 +}
 +
 +static int do_proc_doulongvec_minmax(struct ctl_table *table, int write,
 +				     void __user *buffer,
 +				     size_t *lenp, loff_t *ppos,
 +				     unsigned long convmul,
 +				     unsigned long convdiv)
 +{
 +	return __do_proc_doulongvec_minmax(table->data, table, write,
 +			buffer, lenp, ppos, convmul, convdiv);
 +}
 +
 +/**
 + * proc_doulongvec_minmax - read a vector of long integers with min/max values
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned long) unsigned long
 + * values from/to the user buffer, treated as an ASCII string.
 + *
 + * This routine will ensure the values are within the range specified by
 + * table->extra1 (min) and table->extra2 (max).
 + *
 + * Returns 0 on success.
 + */
 +int proc_doulongvec_minmax(struct ctl_table *table, int write,
 +			   void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +    return do_proc_doulongvec_minmax(table, write, buffer, lenp, ppos, 1l, 1l);
 +}
 +
 +/**
 + * proc_doulongvec_ms_jiffies_minmax - read a vector of millisecond values with min/max values
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned long) unsigned long
 + * values from/to the user buffer, treated as an ASCII string. The values
 + * are treated as milliseconds, and converted to jiffies when they are stored.
 + *
 + * This routine will ensure the values are within the range specified by
 + * table->extra1 (min) and table->extra2 (max).
 + *
 + * Returns 0 on success.
 + */
 +int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,
 +				      void __user *buffer,
 +				      size_t *lenp, loff_t *ppos)
 +{
 +    return do_proc_doulongvec_minmax(table, write, buffer,
 +				     lenp, ppos, HZ, 1000l);
 +}
 +
 +
 +static int do_proc_dointvec_jiffies_conv(bool *negp, unsigned long *lvalp,
 +					 int *valp,
 +					 int write, void *data)
 +{
 +	if (write) {
 +		if (*lvalp > LONG_MAX / HZ)
 +			return 1;
 +		*valp = *negp ? -(*lvalp*HZ) : (*lvalp*HZ);
 +	} else {
 +		int val = *valp;
 +		unsigned long lval;
 +		if (val < 0) {
 +			*negp = true;
 +			lval = (unsigned long)-val;
 +		} else {
 +			*negp = false;
 +			lval = (unsigned long)val;
 +		}
 +		*lvalp = lval / HZ;
 +	}
 +	return 0;
 +}
 +
 +static int do_proc_dointvec_userhz_jiffies_conv(bool *negp, unsigned long *lvalp,
 +						int *valp,
 +						int write, void *data)
 +{
 +	if (write) {
 +		if (USER_HZ < HZ && *lvalp > (LONG_MAX / HZ) * USER_HZ)
 +			return 1;
 +		*valp = clock_t_to_jiffies(*negp ? -*lvalp : *lvalp);
 +	} else {
 +		int val = *valp;
 +		unsigned long lval;
 +		if (val < 0) {
 +			*negp = true;
 +			lval = (unsigned long)-val;
 +		} else {
 +			*negp = false;
 +			lval = (unsigned long)val;
 +		}
 +		*lvalp = jiffies_to_clock_t(lval);
 +	}
 +	return 0;
 +}
 +
 +static int do_proc_dointvec_ms_jiffies_conv(bool *negp, unsigned long *lvalp,
 +					    int *valp,
 +					    int write, void *data)
 +{
 +	if (write) {
 +		unsigned long jif = msecs_to_jiffies(*negp ? -*lvalp : *lvalp);
 +
 +		if (jif > INT_MAX)
 +			return 1;
 +		*valp = (int)jif;
 +	} else {
 +		int val = *valp;
 +		unsigned long lval;
 +		if (val < 0) {
 +			*negp = true;
 +			lval = (unsigned long)-val;
 +		} else {
 +			*negp = false;
 +			lval = (unsigned long)val;
 +		}
 +		*lvalp = jiffies_to_msecs(lval);
 +	}
 +	return 0;
 +}
 +
 +/**
 + * proc_dointvec_jiffies - read a vector of integers as seconds
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
 + * values from/to the user buffer, treated as an ASCII string. 
 + * The values read are assumed to be in seconds, and are converted into
 + * jiffies.
 + *
 + * Returns 0 on success.
 + */
 +int proc_dointvec_jiffies(struct ctl_table *table, int write,
 +			  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +    return do_proc_dointvec(table,write,buffer,lenp,ppos,
 +		    	    do_proc_dointvec_jiffies_conv,NULL);
 +}
 +
 +/**
 + * proc_dointvec_userhz_jiffies - read a vector of integers as 1/USER_HZ seconds
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: pointer to the file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
 + * values from/to the user buffer, treated as an ASCII string. 
 + * The values read are assumed to be in 1/USER_HZ seconds, and 
 + * are converted into jiffies.
 + *
 + * Returns 0 on success.
 + */
 +int proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,
 +				 void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +    return do_proc_dointvec(table,write,buffer,lenp,ppos,
 +		    	    do_proc_dointvec_userhz_jiffies_conv,NULL);
 +}
 +
 +/**
 + * proc_dointvec_ms_jiffies - read a vector of integers as 1 milliseconds
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + * @ppos: the current position in the file
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
 + * values from/to the user buffer, treated as an ASCII string. 
 + * The values read are assumed to be in 1/1000 seconds, and 
 + * are converted into jiffies.
 + *
 + * Returns 0 on success.
 + */
 +int proc_dointvec_ms_jiffies(struct ctl_table *table, int write,
 +			     void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return do_proc_dointvec(table, write, buffer, lenp, ppos,
 +				do_proc_dointvec_ms_jiffies_conv, NULL);
 +}
 +
 +static int proc_do_cad_pid(struct ctl_table *table, int write,
 +			   void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	struct pid *new_pid;
 +	pid_t tmp;
 +	int r;
 +
 +	tmp = pid_vnr(cad_pid);
 +
 +	r = __do_proc_dointvec(&tmp, table, write, buffer,
 +			       lenp, ppos, NULL, NULL);
 +	if (r || !write)
 +		return r;
 +
 +	new_pid = find_get_pid(tmp);
 +	if (!new_pid)
 +		return -ESRCH;
  
 -static struct ctl_table debug_table[] = {
 -#ifdef CONFIG_SYSCTL_EXCEPTION_TRACE
 -	{
 -		.procname	= "exception-trace",
 -		.data		= &show_unhandled_signals,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec
 -	},
 -#endif
 -#if defined(CONFIG_OPTPROBES)
 -	{
 -		.procname	= "kprobes-optimization",
 -		.data		= &sysctl_kprobes_optimization,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_kprobes_optimization_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -#endif
 -	{ }
 -};
 +	put_pid(xchg(&cad_pid, new_pid));
 +	return 0;
 +}
  
 -static struct ctl_table dev_table[] = {
 -	{ }
 -};
 +/**
 + * proc_do_large_bitmap - read/write from/to a large bitmap
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * The bitmap is stored at table->data and the bitmap length (in bits)
 + * in table->maxlen.
 + *
 + * We use a range comma separated format (e.g. 1,3-4,10-10) so that
 + * large bitmaps may be represented in a compact manner. Writing into
 + * the file will clear the bitmap then update it with the given input.
 + *
 + * Returns 0 on success.
 + */
 +int proc_do_large_bitmap(struct ctl_table *table, int write,
 +			 void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	int err = 0;
 +	bool first = 1;
 +	size_t left = *lenp;
 +	unsigned long bitmap_len = table->maxlen;
 +	unsigned long *bitmap = (unsigned long *) table->data;
 +	unsigned long *tmp_bitmap = NULL;
 +	char tr_a[] = { '-', ',', '\n' }, tr_b[] = { ',', '\n', 0 }, c;
  
 -static struct ctl_table sysctl_base_table[] = {
 -	{
 -		.procname	= "kernel",
 -		.mode		= 0555,
 -		.child		= kern_table,
 -	},
 -	{
 -		.procname	= "vm",
 -		.mode		= 0555,
 -		.child		= vm_table,
 -	},
 -	{
 -		.procname	= "fs",
 -		.mode		= 0555,
 -		.child		= fs_table,
 -	},
 -	{
 -		.procname	= "debug",
 -		.mode		= 0555,
 -		.child		= debug_table,
 -	},
 -	{
 -		.procname	= "dev",
 -		.mode		= 0555,
 -		.child		= dev_table,
 -	},
 -	{ }
 -};
 +	if (!bitmap_len || !left || (*ppos && !write)) {
 +		*lenp = 0;
 +		return 0;
 +	}
  
 -int __init sysctl_init(void)
 +	if (write) {
 +		unsigned long page = 0;
 +		char *kbuf;
 +		size_t skipped = 0;
 +
 +		if (left > PAGE_SIZE - 1) {
 +			left = PAGE_SIZE - 1;
 +			/* How much of the buffer we'll skip this pass */
 +			skipped = *lenp - left;
 +		}
 +
 +		page = __get_free_page(GFP_TEMPORARY);
 +		kbuf = (char *) page;
 +		if (!kbuf)
 +			return -ENOMEM;
 +		if (copy_from_user(kbuf, buffer, left)) {
 +			free_page(page);
 +			return -EFAULT;
 +                }
 +		kbuf[left] = 0;
 +
 +		tmp_bitmap = kzalloc(BITS_TO_LONGS(bitmap_len) * sizeof(unsigned long),
 +				     GFP_KERNEL);
 +		if (!tmp_bitmap) {
 +			free_page(page);
 +			return -ENOMEM;
 +		}
 +		proc_skip_char(&kbuf, &left, '\n');
 +		while (!err && left) {
 +			unsigned long val_a, val_b;
 +			bool neg;
 +			size_t saved_left;
 +
 +			/* In case we stop parsing mid-number, we can reset */
 +			saved_left = left;
 +			err = proc_get_long(&kbuf, &left, &val_a, &neg, tr_a,
 +					     sizeof(tr_a), &c);
 +			/*
 +			 * If we consumed the entirety of a truncated buffer or
 +			 * only one char is left (may be a "-"), then stop here,
 +			 * reset, & come back for more.
 +			 */
 +			if ((left <= 1) && skipped) {
 +				left = saved_left;
 +				break;
 +			}
 +
 +			if (err)
 +				break;
 +			if (val_a >= bitmap_len || neg) {
 +				err = -EINVAL;
 +				break;
 +			}
 +
 +			val_b = val_a;
 +			if (left) {
 +				kbuf++;
 +				left--;
 +			}
 +
 +			if (c == '-') {
 +				err = proc_get_long(&kbuf, &left, &val_b,
 +						     &neg, tr_b, sizeof(tr_b),
 +						     &c);
 +				/*
 +				 * If we consumed all of a truncated buffer or
 +				 * then stop here, reset, & come back for more.
 +				 */
 +				if (!left && skipped) {
 +					left = saved_left;
 +					break;
 +				}
 +
 +				if (err)
 +					break;
 +				if (val_b >= bitmap_len || neg ||
 +				    val_a > val_b) {
 +					err = -EINVAL;
 +					break;
 +				}
 +				if (left) {
 +					kbuf++;
 +					left--;
 +				}
 +			}
 +
 +			bitmap_set(tmp_bitmap, val_a, val_b - val_a + 1);
 +			first = 0;
 +			proc_skip_char(&kbuf, &left, '\n');
 +		}
 +		free_page(page);
 +		left += skipped;
 +	} else {
 +		unsigned long bit_a, bit_b = 0;
 +
 +		while (left) {
 +			bit_a = find_next_bit(bitmap, bitmap_len, bit_b);
 +			if (bit_a >= bitmap_len)
 +				break;
 +			bit_b = find_next_zero_bit(bitmap, bitmap_len,
 +						   bit_a + 1) - 1;
 +
 +			if (!first) {
 +				err = proc_put_char(&buffer, &left, ',');
 +				if (err)
 +					break;
 +			}
 +			err = proc_put_long(&buffer, &left, bit_a, false);
 +			if (err)
 +				break;
 +			if (bit_a != bit_b) {
 +				err = proc_put_char(&buffer, &left, '-');
 +				if (err)
 +					break;
 +				err = proc_put_long(&buffer, &left, bit_b, false);
 +				if (err)
 +					break;
 +			}
 +
 +			first = 0; bit_b++;
 +		}
 +		if (!err)
 +			err = proc_put_char(&buffer, &left, '\n');
 +	}
 +
 +	if (!err) {
 +		if (write) {
 +			if (*ppos)
 +				bitmap_or(bitmap, bitmap, tmp_bitmap, bitmap_len);
 +			else
 +				bitmap_copy(bitmap, tmp_bitmap, bitmap_len);
 +		}
 +		kfree(tmp_bitmap);
 +		*lenp -= left;
 +		*ppos += *lenp;
 +		return 0;
 +	} else {
 +		kfree(tmp_bitmap);
 +		return err;
 +	}
 +}
 +
 +#else /* CONFIG_PROC_SYSCTL */
 +
 +int proc_dostring(struct ctl_table *table, int write,
 +		  void __user *buffer, size_t *lenp, loff_t *ppos)
  {
 -	struct ctl_table_header *hdr;
 +	return -ENOSYS;
 +}
  
 -	hdr = register_sysctl_table(sysctl_base_table);
 -	kmemleak_not_leak(hdr);
 -	return 0;
 +int proc_dointvec(struct ctl_table *table, int write,
 +		  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
  }
 -#endif /* CONFIG_SYSCTL */
 +
 +int proc_douintvec(struct ctl_table *table, int write,
 +		  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
 +
 +int proc_dointvec_minmax(struct ctl_table *table, int write,
 +		    void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
 +
 +int proc_douintvec_minmax(struct ctl_table *table, int write,
 +			  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
 +
 +int proc_dopipe_max_size(struct ctl_table *table, int write,
 +			 void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
 +
 +int proc_dointvec_jiffies(struct ctl_table *table, int write,
 +		    void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
 +
 +int proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,
 +		    void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
 +
 +int proc_dointvec_ms_jiffies(struct ctl_table *table, int write,
 +			     void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
 +
 +int proc_doulongvec_minmax(struct ctl_table *table, int write,
 +		    void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
 +
 +int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,
 +				      void __user *buffer,
 +				      size_t *lenp, loff_t *ppos)
 +{
 +    return -ENOSYS;
 +}
 +
 +
 +#endif /* CONFIG_PROC_SYSCTL */
 +
  /*
   * No sense putting this after each symbol definition, twice,
   * exception granted :-)
* Unmerged path kernel/sysctl.c
