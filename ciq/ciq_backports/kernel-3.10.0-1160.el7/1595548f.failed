gfs2: Split gfs2_rsqa_delete into gfs2_rs_delete and gfs2_qa_put

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 1595548fe72ca834abe75fb3df47e300a087d563
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/1595548f.failed

Keeping reservations and quotas separate helps reviewing the code.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 1595548fe72ca834abe75fb3df47e300a087d563)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/file.c
#	fs/gfs2/inode.c
#	fs/gfs2/rgrp.c
#	fs/gfs2/rgrp.h
#	fs/gfs2/super.c
diff --cc fs/gfs2/file.c
index 1c0c0f8e680b,99a75e779ac0..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -631,10 -701,10 +631,17 @@@ static int gfs2_release(struct inode *i
  	kfree(file->private_data);
  	file->private_data = NULL;
  
++<<<<<<< HEAD
 +	if (!(file->f_mode & FMODE_WRITE))
 +		return 0;
 +
 +	gfs2_rsqa_delete(ip, &inode->i_writecount);
++=======
+ 	if (file->f_mode & FMODE_WRITE) {
+ 		gfs2_rs_delete(ip, &inode->i_writecount);
+ 		gfs2_qa_put(ip);
+ 	}
++>>>>>>> 1595548fe72c (gfs2: Split gfs2_rsqa_delete into gfs2_rs_delete and gfs2_qa_put)
  	return 0;
  }
  
diff --cc fs/gfs2/inode.c
index a7cb675316c4,980a6feb0e22..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -728,10 -781,15 +728,18 @@@ fail_free_inode
  		glock_clear_object(ip->i_gl, ip);
  		gfs2_glock_put(ip->i_gl);
  	}
++<<<<<<< HEAD
 +	gfs2_rsqa_delete(ip, NULL);
++=======
+ 	gfs2_rs_delete(ip, NULL);
+ 	gfs2_qa_put(ip);
+ fail_free_acls:
+ 	posix_acl_release(default_acl);
+ 	posix_acl_release(acl);
++>>>>>>> 1595548fe72c (gfs2: Split gfs2_rsqa_delete into gfs2_rs_delete and gfs2_qa_put)
  fail_gunlock:
 -	gfs2_dir_no_add(&da);
  	gfs2_glock_dq_uninit(ghs);
 -	if (!IS_ERR_OR_NULL(inode)) {
 +	if (inode && !IS_ERR(inode)) {
  		clear_nlink(inode);
  		if (!free_vfs_inode)
  			mark_inode_dirty(inode);
diff --cc fs/gfs2/rgrp.c
index 61ede4feb7e3,692dc11d0f13..000000000000
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@@ -648,7 -673,6 +648,10 @@@ void gfs2_rs_delete(struct gfs2_inode *
  	if ((wcount == NULL) || (atomic_read(wcount) <= 1))
  		gfs2_rs_deltree(&ip->i_res);
  	up_write(&ip->i_rw_mutex);
++<<<<<<< HEAD
 +	gfs2_qa_delete(ip, wcount);
++=======
++>>>>>>> 1595548fe72c (gfs2: Split gfs2_rsqa_delete into gfs2_rs_delete and gfs2_qa_put)
  }
  
  /**
diff --cc fs/gfs2/rgrp.h
index 5b363f86df1a,a1d7e14fc55b..000000000000
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@@ -49,11 -44,12 +49,19 @@@ extern void gfs2_inplace_release(struc
  extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
  			     bool dinode, u64 *generation);
  
 +extern int gfs2_rsqa_alloc(struct gfs2_inode *ip);
  extern void gfs2_rs_deltree(struct gfs2_blkreserv *rs);
++<<<<<<< HEAD
 +extern void gfs2_rsqa_delete(struct gfs2_inode *ip, atomic_t *wcount);
 +extern void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta);
 +extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
++=======
+ extern void gfs2_rs_delete(struct gfs2_inode *ip, atomic_t *wcount);
+ extern void __gfs2_free_blocks(struct gfs2_inode *ip, struct gfs2_rgrpd *rgd,
+ 			       u64 bstart, u32 blen, int meta);
+ extern void gfs2_free_meta(struct gfs2_inode *ip, struct gfs2_rgrpd *rgd,
+ 			   u64 bstart, u32 blen);
++>>>>>>> 1595548fe72c (gfs2: Split gfs2_rsqa_delete into gfs2_rs_delete and gfs2_qa_put)
  extern void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);
  extern void gfs2_unlink_di(struct inode *inode);
  extern int gfs2_check_blk_type(struct gfs2_sbd *sdp, u64 no_addr,
diff --cc fs/gfs2/super.c
index 6327156ef20f,37fc41632aa2..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1633,8 -1393,32 +1633,33 @@@ out_unlock
  	if (gfs2_rs_active(&ip->i_res))
  		gfs2_rs_deltree(&ip->i_res);
  
++<<<<<<< HEAD
++=======
+ 	if (gfs2_holder_initialized(&gh)) {
+ 		glock_clear_object(ip->i_gl, ip);
+ 		gfs2_glock_dq_uninit(&gh);
+ 	}
+ 	if (error && error != GLR_TRYFAILED && error != -EROFS)
+ 		fs_warn(sdp, "gfs2_evict_inode: %d\n", error);
+ out:
+ 	truncate_inode_pages_final(&inode->i_data);
+ 	if (ip->i_qadata)
+ 		gfs2_assert_warn(sdp, ip->i_qadata->qa_ref == 0);
+ 	gfs2_rs_delete(ip, NULL);
+ 	gfs2_qa_put(ip);
+ 	gfs2_ordered_del_inode(ip);
+ 	clear_inode(inode);
+ 	gfs2_dir_hash_inval(ip);
+ 	if (ip->i_gl) {
+ 		glock_clear_object(ip->i_gl, ip);
+ 		wait_on_bit_io(&ip->i_flags, GIF_GLOP_PENDING, TASK_UNINTERRUPTIBLE);
+ 		gfs2_glock_add_to_lru(ip->i_gl);
+ 		gfs2_glock_put_eventually(ip->i_gl);
+ 		ip->i_gl = NULL;
+ 	}
++>>>>>>> 1595548fe72c (gfs2: Split gfs2_rsqa_delete into gfs2_rs_delete and gfs2_qa_put)
  	if (gfs2_holder_initialized(&ip->i_iopen_gh)) {
 -		struct gfs2_glock *gl = ip->i_iopen_gh.gh_gl;
 -
 -		glock_clear_object(gl, ip);
 +		glock_clear_object(ip->i_iopen_gh.gh_gl, ip);
  		if (test_bit(HIF_HOLDER, &ip->i_iopen_gh.gh_iflags)) {
  			ip->i_iopen_gh.gh_flags |= GL_NOCACHE;
  			gfs2_glock_dq(&ip->i_iopen_gh);
diff --git a/fs/gfs2/bmap.c b/fs/gfs2/bmap.c
index 1879d6dd89c5..1bf7615b7965 100644
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@ -2197,7 +2197,8 @@ int gfs2_setattr_size(struct inode *inode, u64 newsize)
 
 	ret = do_shrink(inode, newsize);
 out:
-	gfs2_rsqa_delete(ip, NULL);
+	gfs2_rs_delete(ip, NULL);
+	gfs2_qa_put(ip);
 	return ret;
 }
 
* Unmerged path fs/gfs2/file.c
* Unmerged path fs/gfs2/inode.c
* Unmerged path fs/gfs2/rgrp.c
* Unmerged path fs/gfs2/rgrp.h
* Unmerged path fs/gfs2/super.c
