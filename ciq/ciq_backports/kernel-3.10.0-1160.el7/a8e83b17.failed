slcan: Port write_wakeup deadlock fix from slip

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Tyler Hall <tylerwhall@gmail.com>
commit a8e83b17536aad603fbeae4c460f2da0ee9fe6ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/a8e83b17.failed

The commit "slip: Fix deadlock in write_wakeup" fixes a deadlock caused
by a change made in both slcan and slip. This is a direct port of that
fix.

	Signed-off-by: Tyler Hall <tylerwhall@gmail.com>
	Cc: Oliver Hartkopp <socketcan@hartkopp.net>
	Cc: Andre Naujoks <nautsch2@gmail.com>
	Cc: David S. Miller <davem@davemloft.net>
	Cc: linux-kernel@vger.kernel.org
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a8e83b17536aad603fbeae4c460f2da0ee9fe6ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/can/slcan.c
diff --cc drivers/net/can/slcan.c
index 92bc87cbf3e3,ea4d4f1a6411..000000000000
--- a/drivers/net/can/slcan.c
+++ b/drivers/net/can/slcan.c
@@@ -274,36 -311,46 +276,55 @@@ static void slc_encaps(struct slcan *sl
  	sl->dev->stats.tx_bytes += cf->can_dlc;
  }
  
- /*
-  * Called by the driver when there's room for more data.  If we have
-  * more packets to send, we send them here.
-  */
- static void slcan_write_wakeup(struct tty_struct *tty)
+ /* Write out any remaining transmit buffer. Scheduled when tty is writable */
+ static void slcan_transmit(struct work_struct *work)
  {
+ 	struct slcan *sl = container_of(work, struct slcan, tx_work);
  	int actual;
- 	struct slcan *sl = (struct slcan *) tty->disc_data;
  
++<<<<<<< HEAD
++	spin_lock(&sl->lock);
++=======
+ 	spin_lock_bh(&sl->lock);
  	/* First make sure we're connected. */
- 	if (!sl || sl->magic != SLCAN_MAGIC || !netif_running(sl->dev))
+ 	if (!sl->tty || sl->magic != SLCAN_MAGIC || !netif_running(sl->dev)) {
+ 		spin_unlock_bh(&sl->lock);
  		return;
+ 	}
  
- 	spin_lock(&sl->lock);
++>>>>>>> a8e83b17536a (slcan: Port write_wakeup deadlock fix from slip)
  	if (sl->xleft <= 0)  {
  		/* Now serial buffer is almost free & we can start
  		 * transmission of another packet */
  		sl->dev->stats.tx_packets++;
++<<<<<<< HEAD
 +		clear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);
 +		spin_unlock(&sl->lock);
++=======
+ 		clear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);
+ 		spin_unlock_bh(&sl->lock);
++>>>>>>> a8e83b17536a (slcan: Port write_wakeup deadlock fix from slip)
  		netif_wake_queue(sl->dev);
  		return;
  	}
  
- 	actual = tty->ops->write(tty, sl->xhead, sl->xleft);
+ 	actual = sl->tty->ops->write(sl->tty, sl->xhead, sl->xleft);
  	sl->xleft -= actual;
  	sl->xhead += actual;
 -	spin_unlock_bh(&sl->lock);
 +	spin_unlock(&sl->lock);
  }
  
+ /*
+  * Called by the driver when there's room for more data.
+  * Schedule the transmit.
+  */
+ static void slcan_write_wakeup(struct tty_struct *tty)
+ {
+ 	struct slcan *sl = tty->disc_data;
+ 
+ 	schedule_work(&sl->tx_work);
+ }
+ 
  /* Send a can_frame to a TTY queue. */
  static netdev_tx_t slc_xmit(struct sk_buff *skb, struct net_device *dev)
  {
* Unmerged path drivers/net/can/slcan.c
