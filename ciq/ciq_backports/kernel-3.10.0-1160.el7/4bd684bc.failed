gfs2: Remove unnecessary gfs2_qa_{get,put} pairs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
Rebuild_CHGLOG: - [fs] gfs2: Remove unnecessary gfs2_qa_{get, put} pairs (Robert S Peterson) [1798713]
Rebuild_FUZZ: 98.97%
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 4bd684bc0143b46eea6dcf4dd3a73dfd6dc7247c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/4bd684bc.failed

We now get the quota data structure when opening a file writable and put it
when closing that writable file descriptor, so there no longer is a need for
gfs2_qa_{get,put} while we're holding a writable file descriptor.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 4bd684bc0143b46eea6dcf4dd3a73dfd6dc7247c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/file.c
diff --cc fs/gfs2/file.c
index 1c0c0f8e680b,fe305e4bfd37..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -411,12 -458,6 +411,15 @@@ static int gfs2_page_mkwrite(struct vm_
  
  	sb_start_pagefault(inode->i_sb);
  
++<<<<<<< HEAD
 +	ret = gfs2_rsqa_alloc(ip);
 +	if (ret)
 +		goto out;
 +
 +	gfs2_size_hint(vma->vm_file, pos, PAGE_CACHE_SIZE);
 +
++=======
++>>>>>>> 4bd684bc0143 (gfs2: Remove unnecessary gfs2_qa_{get,put} pairs)
  	gfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);
  	ret = gfs2_glock_nq(&gh);
  	if (ret)
@@@ -706,23 -847,16 +708,27 @@@ static int gfs2_fsync(struct file *file
   *
   */
  
 -static ssize_t gfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
 +static ssize_t gfs2_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 +				   unsigned long nr_segs, loff_t pos)
  {
  	struct file *file = iocb->ki_filp;
 -	struct inode *inode = file_inode(file);
 +	struct address_space *mapping = file->f_mapping;
 +	struct inode *inode = mapping->host;
  	struct gfs2_inode *ip = GFS2_I(inode);
 +	size_t ocount, count;
  	ssize_t ret;
  
++<<<<<<< HEAD
 +	ret = gfs2_rsqa_alloc(ip);
 +	if (ret)
 +		return ret;
 +
 +	gfs2_size_hint(file, pos, iov_length(iov, nr_segs));
++=======
+ 	gfs2_size_hint(file, iocb->ki_pos, iov_iter_count(from));
++>>>>>>> 4bd684bc0143 (gfs2: Remove unnecessary gfs2_qa_{get,put} pairs)
  
 -	if (iocb->ki_flags & IOCB_APPEND) {
 +	if (file->f_flags & O_APPEND) {
  		struct gfs2_holder gh;
  
  		ret = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &gh);
@@@ -760,23 -876,49 +766,63 @@@
  
  	ret = file_update_time(file);
  	if (ret)
 -		goto out_unlock;
 +		goto out2;
 +
 +	ret = iomap_file_buffered_write(iocb, iov, nr_segs, pos, &iocb->ki_pos,
 +					count, &gfs2_iomap_ops);
  
 -	if (iocb->ki_flags & IOCB_DIRECT) {
 -		struct address_space *mapping = file->f_mapping;
 -		ssize_t buffered, ret2;
++<<<<<<< HEAD
 +out2:
 +	current->backing_dev_info = NULL;
 +out:
 +	inode_unlock(inode);
 +	if (likely(ret > 0)) {
 +		ssize_t err;
  
 +		/* Handle various SYNC-type writes */
 +		err = generic_write_sync(file, pos, ret);
 +		if (err < 0 && ret > 0)
 +			ret = err;
 +	}
++=======
+ 		ret = gfs2_file_direct_write(iocb, from);
+ 		if (ret < 0 || !iov_iter_count(from))
+ 			goto out_unlock;
+ 
+ 		iocb->ki_flags |= IOCB_DSYNC;
+ 		current->backing_dev_info = inode_to_bdi(inode);
+ 		buffered = iomap_file_buffered_write(iocb, from, &gfs2_iomap_ops);
+ 		current->backing_dev_info = NULL;
+ 		if (unlikely(buffered <= 0))
+ 			goto out_unlock;
+ 
+ 		/*
+ 		 * We need to ensure that the page cache pages are written to
+ 		 * disk and invalidated to preserve the expected O_DIRECT
+ 		 * semantics.  If the writeback or invalidate fails, only report
+ 		 * the direct I/O range as we don't know if the buffered pages
+ 		 * made it to disk.
+ 		 */
+ 		iocb->ki_pos += buffered;
+ 		ret2 = generic_write_sync(iocb, buffered);
+ 		invalidate_mapping_pages(mapping,
+ 				(iocb->ki_pos - buffered) >> PAGE_SHIFT,
+ 				(iocb->ki_pos - 1) >> PAGE_SHIFT);
+ 		if (!ret || ret2 > 0)
+ 			ret += ret2;
+ 	} else {
+ 		current->backing_dev_info = inode_to_bdi(inode);
+ 		ret = iomap_file_buffered_write(iocb, from, &gfs2_iomap_ops);
+ 		current->backing_dev_info = NULL;
+ 		if (likely(ret > 0)) {
+ 			iocb->ki_pos += ret;
+ 			ret = generic_write_sync(iocb, ret);
+ 		}
+ 	}
+ 
+ out_unlock:
+ 	inode_unlock(inode);
++>>>>>>> 4bd684bc0143 (gfs2: Remove unnecessary gfs2_qa_{get,put} pairs)
  	return ret;
  }
  
@@@ -1004,12 -1150,7 +1050,14 @@@ static long gfs2_fallocate(struct file 
  	if (mode & FALLOC_FL_PUNCH_HOLE) {
  		ret = __gfs2_punch_hole(file, offset, len);
  	} else {
++<<<<<<< HEAD
 +		ret = gfs2_rsqa_alloc(ip);
 +		if (ret)
 +			goto out_putw;
 +
++=======
++>>>>>>> 4bd684bc0143 (gfs2: Remove unnecessary gfs2_qa_{get,put} pairs)
  		ret = __gfs2_fallocate(file, mode, offset, len);
- 
  		if (ret)
  			gfs2_rs_deltree(&ip->i_res);
  	}
@@@ -1051,16 -1168,12 +1098,25 @@@ static ssize_t gfs2_file_splice_write(s
  				      struct file *out, loff_t *ppos,
  				      size_t len, unsigned int flags)
  {
++<<<<<<< HEAD
 +	int error;
 +	struct gfs2_inode *ip = GFS2_I(out->f_mapping->host);
 +
 +	error = gfs2_rsqa_alloc(ip);
 +	if (error)
 +		return (ssize_t)error;
 +
 +	gfs2_size_hint(out, *ppos, len);
 +
 +	return generic_file_splice_write(pipe, out, ppos, len, flags);
++=======
+ 	ssize_t ret;
+ 
+ 	gfs2_size_hint(out, *ppos, len);
+ 
+ 	ret = iter_file_splice_write(pipe, out, ppos, len, flags);
+ 	return ret;
++>>>>>>> 4bd684bc0143 (gfs2: Remove unnecessary gfs2_qa_{get,put} pairs)
  }
  
  #ifdef CONFIG_GFS2_FS_LOCKING_DLM
* Unmerged path fs/gfs2/file.c
