ceph: hold i_ceph_lock when removing caps for freeing inode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Yan, Zheng <zyan@redhat.com>
commit d6e47819721ae2d9d090058ad5570a66f3c42e39
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/d6e47819.failed

ceph_d_revalidate(, LOOKUP_RCU) may call __ceph_caps_issued_mask()
on a freeing inode.

	Signed-off-by: "Yan, Zheng" <zyan@redhat.com>
	Reviewed-by: Jeff Layton <jlayton@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit d6e47819721ae2d9d090058ad5570a66f3c42e39)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/caps.c
#	fs/ceph/inode.c
#	fs/ceph/super.h
diff --cc fs/ceph/caps.c
index a38f24d18974,7754d7679122..000000000000
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@@ -1244,14 -1263,15 +1244,19 @@@ static int send_cap_msg(struct cap_msg_
  }
  
  /*
-  * Queue cap releases when an inode is dropped from our cache.  Since
-  * inode is about to be destroyed, there is no need for i_ceph_lock.
+  * Queue cap releases when an inode is dropped from our cache.
   */
++<<<<<<< HEAD
 +void ceph_queue_caps_release(struct inode *inode)
++=======
+ void __ceph_remove_caps(struct ceph_inode_info *ci)
++>>>>>>> d6e47819721a (ceph: hold i_ceph_lock when removing caps for freeing inode)
  {
- 	struct ceph_inode_info *ci = ceph_inode(inode);
  	struct rb_node *p;
  
+ 	/* lock i_ceph_lock, because ceph_d_revalidate(..., LOOKUP_RCU)
+ 	 * may call __ceph_caps_issued_mask() on a freeing inode. */
+ 	spin_lock(&ci->i_ceph_lock);
  	p = rb_first(&ci->i_caps);
  	while (p) {
  		struct ceph_cap *cap = rb_entry(p, struct ceph_cap, ci_node);
diff --cc fs/ceph/inode.c
index 9881f548a6fd,18869ba08db7..000000000000
--- a/fs/ceph/inode.c
+++ b/fs/ceph/inode.c
@@@ -532,7 -531,9 +532,13 @@@ void ceph_destroy_inode(struct inode *i
  
  	dout("destroy_inode %p ino %llx.%llx\n", inode, ceph_vinop(inode));
  
++<<<<<<< HEAD
 +	ceph_queue_caps_release(inode);
++=======
+ 	ceph_fscache_unregister_inode_cookie(ci);
+ 
+ 	__ceph_remove_caps(ci);
++>>>>>>> d6e47819721a (ceph: hold i_ceph_lock when removing caps for freeing inode)
  
  	if (__ceph_has_any_quota(ci))
  		ceph_adjust_quota_realms_count(inode, false);
diff --cc fs/ceph/super.h
index 30d1ebe3bba4,0176b3c97e1a..000000000000
--- a/fs/ceph/super.h
+++ b/fs/ceph/super.h
@@@ -963,6 -1004,7 +963,10 @@@ extern void ceph_add_cap(struct inode *
  			 unsigned cap, unsigned seq, u64 realmino, int flags,
  			 struct ceph_cap **new_cap);
  extern void __ceph_remove_cap(struct ceph_cap *cap, bool queue_release);
++<<<<<<< HEAD
++=======
+ extern void __ceph_remove_caps(struct ceph_inode_info *ci);
++>>>>>>> d6e47819721a (ceph: hold i_ceph_lock when removing caps for freeing inode)
  extern void ceph_put_cap(struct ceph_mds_client *mdsc,
  			 struct ceph_cap *cap);
  extern int ceph_is_any_caps(struct inode *inode);
* Unmerged path fs/ceph/caps.c
* Unmerged path fs/ceph/inode.c
* Unmerged path fs/ceph/super.h
