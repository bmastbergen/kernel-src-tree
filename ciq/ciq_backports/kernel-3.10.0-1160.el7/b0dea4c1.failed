ext4: move handling of list of shrinkable inodes into extent status code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Jan Kara <jack@suse.cz>
commit b0dea4c1651f3cdb6d17604fa473e72cb74cdc6b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/b0dea4c1.failed

Currently callers adding extents to extent status tree were responsible
for adding the inode to the list of inodes with freeable extents. This
is error prone and puts list handling in unnecessarily many places.

Just add inode to the list automatically when the first non-delay extent
is added to the tree and remove inode from the list when the last
non-delay extent is removed.

	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit b0dea4c1651f3cdb6d17604fa473e72cb74cdc6b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/extents.c
#	fs/ext4/extents_status.c
#	fs/ext4/extents_status.h
#	fs/ext4/inode.c
#	fs/ext4/ioctl.c
#	fs/ext4/super.c
diff --cc fs/ext4/extents.c
index 72233774feed,e2424bafd6fe..000000000000
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@@ -4663,7 -4632,6 +4663,10 @@@ out2
  
  	trace_ext4_ext_map_blocks_exit(inode, flags, map,
  				       err ? err : allocated);
++<<<<<<< HEAD
 +	ext4_es_lru_add(inode);
++=======
++>>>>>>> b0dea4c1651f (ext4: move handling of list of shrinkable inodes into extent status code)
  	return err ? err : allocated;
  }
  
@@@ -5234,7 -5190,6 +5237,10 @@@ int ext4_fiemap(struct inode *inode, st
  		error = ext4_fill_fiemap_extents(inode, start_blk,
  						 len_blks, fieinfo);
  	}
++<<<<<<< HEAD
 +	ext4_es_lru_add(inode);
++=======
++>>>>>>> b0dea4c1651f (ext4: move handling of list of shrinkable inodes into extent status code)
  	return error;
  }
  
diff --cc fs/ext4/extents_status.c
index 3ef7f932e809,de2d9d8bf22f..000000000000
--- a/fs/ext4/extents_status.c
+++ b/fs/ext4/extents_status.c
@@@ -296,6 -298,36 +296,39 @@@ out
  	trace_ext4_es_find_delayed_extent_range_exit(inode, es);
  }
  
++<<<<<<< HEAD
++=======
+ static void ext4_es_list_add(struct inode *inode)
+ {
+ 	struct ext4_inode_info *ei = EXT4_I(inode);
+ 	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
+ 
+ 	if (!list_empty(&ei->i_es_list))
+ 		return;
+ 
+ 	spin_lock(&sbi->s_es_lock);
+ 	if (list_empty(&ei->i_es_list)) {
+ 		list_add_tail(&ei->i_es_list, &sbi->s_es_list);
+ 		sbi->s_es_nr_inode++;
+ 	}
+ 	spin_unlock(&sbi->s_es_lock);
+ }
+ 
+ static void ext4_es_list_del(struct inode *inode)
+ {
+ 	struct ext4_inode_info *ei = EXT4_I(inode);
+ 	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
+ 
+ 	spin_lock(&sbi->s_es_lock);
+ 	if (!list_empty(&ei->i_es_list)) {
+ 		list_del_init(&ei->i_es_list);
+ 		sbi->s_es_nr_inode--;
+ 		WARN_ON_ONCE(sbi->s_es_nr_inode < 0);
+ 	}
+ 	spin_unlock(&sbi->s_es_lock);
+ }
+ 
++>>>>>>> b0dea4c1651f (ext4: move handling of list of shrinkable inodes into extent status code)
  static struct extent_status *
  ext4_es_alloc_extent(struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len,
  		     ext4_fsblk_t pblk)
@@@ -312,20 -344,30 +345,35 @@@
  	 * We don't count delayed extent because we never try to reclaim them
  	 */
  	if (!ext4_es_is_delayed(es)) {
++<<<<<<< HEAD
 +		EXT4_I(inode)->i_es_lru_nr++;
 +		percpu_counter_inc(&EXT4_SB(inode->i_sb)->s_extent_cache_cnt);
++=======
+ 		if (!EXT4_I(inode)->i_es_shk_nr++)
+ 			ext4_es_list_add(inode);
+ 		percpu_counter_inc(&EXT4_SB(inode->i_sb)->
+ 					s_es_stats.es_stats_shk_cnt);
++>>>>>>> b0dea4c1651f (ext4: move handling of list of shrinkable inodes into extent status code)
  	}
  
 -	EXT4_I(inode)->i_es_all_nr++;
 -	percpu_counter_inc(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);
 -
  	return es;
  }
  
  static void ext4_es_free_extent(struct inode *inode, struct extent_status *es)
  {
 -	EXT4_I(inode)->i_es_all_nr--;
 -	percpu_counter_dec(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);
 -
 -	/* Decrease the shrink counter when this es is not delayed */
 +	/* Decrease the lru counter when this es is not delayed */
  	if (!ext4_es_is_delayed(es)) {
++<<<<<<< HEAD
 +		BUG_ON(EXT4_I(inode)->i_es_lru_nr == 0);
 +		EXT4_I(inode)->i_es_lru_nr--;
 +		percpu_counter_dec(&EXT4_SB(inode->i_sb)->s_extent_cache_cnt);
++=======
+ 		BUG_ON(EXT4_I(inode)->i_es_shk_nr == 0);
+ 		if (!--EXT4_I(inode)->i_es_shk_nr)
+ 			ext4_es_list_del(inode);
+ 		percpu_counter_dec(&EXT4_SB(inode->i_sb)->
+ 					s_es_stats.es_stats_shk_cnt);
++>>>>>>> b0dea4c1651f (ext4: move handling of list of shrinkable inodes into extent status code)
  	}
  
  	kmem_cache_free(ext4_es_cachep, es);
diff --cc fs/ext4/extents_status.h
index f1b62a419920,b0b78b95f481..000000000000
--- a/fs/ext4/extents_status.h
+++ b/fs/ext4/extents_status.h
@@@ -138,9 -148,7 +138,12 @@@ static inline void ext4_es_store_pblock
  		       (pb & ~ES_MASK));
  }
  
 -extern int ext4_es_register_shrinker(struct ext4_sb_info *sbi);
 +extern void ext4_es_register_shrinker(struct ext4_sb_info *sbi);
  extern void ext4_es_unregister_shrinker(struct ext4_sb_info *sbi);
++<<<<<<< HEAD
 +extern void ext4_es_lru_add(struct inode *inode);
 +extern void ext4_es_lru_del(struct inode *inode);
++=======
++>>>>>>> b0dea4c1651f (ext4: move handling of list of shrinkable inodes into extent status code)
  
  #endif /* _EXT4_EXTENTS_STATUS_H */
diff --cc fs/ext4/inode.c
index 8274eb8296d4,b416b461fa50..000000000000
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@@ -494,7 -486,6 +494,10 @@@ int ext4_map_blocks(handle_t *handle, s
  
  	/* Lookup extent status tree firstly */
  	if (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {
++<<<<<<< HEAD
 +		ext4_es_lru_add(inode);
++=======
++>>>>>>> b0dea4c1651f (ext4: move handling of list of shrinkable inodes into extent status code)
  		if (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {
  			map->m_pblk = ext4_es_pblock(&es) +
  					map->m_lblk - es.es_lblk;
@@@ -1487,7 -1387,6 +1490,10 @@@ static int ext4_da_map_blocks(struct in
  
  	/* Lookup extent status tree firstly */
  	if (ext4_es_lookup_extent(inode, iblock, &es)) {
++<<<<<<< HEAD
 +		ext4_es_lru_add(inode);
++=======
++>>>>>>> b0dea4c1651f (ext4: move handling of list of shrinkable inodes into extent status code)
  		if (ext4_es_is_hole(&es)) {
  			retval = 0;
  			down_read(&EXT4_I(inode)->i_data_sem);
diff --cc fs/ext4/ioctl.c
index fe421e8dcaba,f58a0d106726..000000000000
--- a/fs/ext4/ioctl.c
+++ b/fs/ext4/ioctl.c
@@@ -79,8 -78,6 +79,11 @@@ static void swap_inode_data(struct inod
  	memswap(&ei1->i_disksize, &ei2->i_disksize, sizeof(ei1->i_disksize));
  	ext4_es_remove_extent(inode1, 0, EXT_MAX_BLOCKS);
  	ext4_es_remove_extent(inode2, 0, EXT_MAX_BLOCKS);
++<<<<<<< HEAD
 +	ext4_es_lru_del(inode1);
 +	ext4_es_lru_del(inode2);
++=======
++>>>>>>> b0dea4c1651f (ext4: move handling of list of shrinkable inodes into extent status code)
  
  	isize = i_size_read(inode1);
  	i_size_write(inode1, i_size_read(inode2));
diff --cc fs/ext4/super.c
index 417c0071ce41,e2a17f8b7adc..000000000000
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@@ -1009,7 -962,6 +1009,10 @@@ void ext4_clear_inode(struct inode *ino
  	dquot_drop(inode);
  	ext4_discard_preallocations(inode);
  	ext4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);
++<<<<<<< HEAD
 +	ext4_es_lru_del(inode);
++=======
++>>>>>>> b0dea4c1651f (ext4: move handling of list of shrinkable inodes into extent status code)
  	if (EXT4_I(inode)->jinode) {
  		jbd2_journal_release_jbd_inode(EXT4_JOURNAL(inode),
  					       EXT4_I(inode)->jinode);
* Unmerged path fs/ext4/extents.c
* Unmerged path fs/ext4/extents_status.c
* Unmerged path fs/ext4/extents_status.h
* Unmerged path fs/ext4/inode.c
* Unmerged path fs/ext4/ioctl.c
* Unmerged path fs/ext4/super.c
