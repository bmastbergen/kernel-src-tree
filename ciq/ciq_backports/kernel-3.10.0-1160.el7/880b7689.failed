mm/oom_kill.c: fix potentially killing unrelated process

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
Rebuild_CHGLOG: - [mm] mm: oom: fix potentially killing unrelated process (Rafael Aquini) [1261799]
Rebuild_FUZZ: 90.57%
commit-author Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
commit 880b768937e90c433c0c8254a22b1eb63df005a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/880b7689.failed

At the for_each_process() loop in oom_kill_process(), we are comparing
address of OOM victim's mm without holding a reference to that mm.  If
there are a lot of processes to compare or a lot of "Kill process %d (%s)
sharing same memory" messages to print, for_each_process() loop could take
very long time.

It is possible that meanwhile the OOM victim exits and releases its mm,
and then mm is allocated with the same address and assigned to some
unrelated process.  When we hit such race, the unrelated process will be
killed by error.  To make sure that the OOM victim's mm does not go away
until for_each_process() loop finishes, get a reference on the OOM
victim's mm before calling task_unlock(victim).

[oleg@redhat.com: several fixes]
	Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: David Rientjes <rientjes@google.com>
	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 880b768937e90c433c0c8254a22b1eb63df005a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/oom_kill.c
diff --cc mm/oom_kill.c
index cb09e6224089,5ba743aaba87..000000000000
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@@ -496,14 -552,20 +496,27 @@@ void oom_kill_process(struct task_struc
  		victim = p;
  	}
  
- 	/* mm cannot safely be dereferenced after task_unlock(victim) */
+ 	/* Get a reference to safely compare mm after task_unlock(victim) */
  	mm = victim->mm;
++<<<<<<< HEAD
 +	pr_err("Killed process %d (%s), UID %d, total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n",
 +		task_pid_nr(victim), victim->comm,
 +		task_uid(victim).val, K(victim->mm->total_vm),
++=======
+ 	atomic_inc(&mm->mm_count);
+ 	/*
+ 	 * We should send SIGKILL before setting TIF_MEMDIE in order to prevent
+ 	 * the OOM victim from depleting the memory reserves from the user
+ 	 * space under its control.
+ 	 */
+ 	do_send_sig_info(SIGKILL, SEND_SIG_FORCED, victim, true);
+ 	mark_oom_victim(victim);
+ 	pr_err("Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB\n",
+ 		task_pid_nr(victim), victim->comm, K(victim->mm->total_vm),
++>>>>>>> 880b768937e9 (mm/oom_kill.c: fix potentially killing unrelated process)
  		K(get_mm_counter(victim->mm, MM_ANONPAGES)),
 -		K(get_mm_counter(victim->mm, MM_FILEPAGES)));
 +		K(get_mm_counter(victim->mm, MM_FILEPAGES)),
 +		K(get_mm_counter(victim->mm, MM_SHMEMPAGES)));
  	task_unlock(victim);
  
  	/*
@@@ -530,8 -592,7 +543,12 @@@
  		}
  	rcu_read_unlock();
  
++<<<<<<< HEAD
 +	set_tsk_thread_flag(victim, TIF_MEMDIE);
 +	do_send_sig_info(SIGKILL, SEND_SIG_FORCED, victim, true);
++=======
+ 	mmdrop(mm);
++>>>>>>> 880b768937e9 (mm/oom_kill.c: fix potentially killing unrelated process)
  	put_task_struct(victim);
  }
  #undef K
* Unmerged path mm/oom_kill.c
