mm/oom_kill: cleanup the "kill sharing same memory" loop

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
Rebuild_CHGLOG: - [mm] mm: oom: cleanup the "kill sharing same memory" loop (Rafael Aquini) [1261799]
Rebuild_FUZZ: 92.59%
commit-author Oleg Nesterov <oleg@redhat.com>
commit c319025a6c79e532d862e3a0b9506ba316a4d13a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/c319025a.failed

Purely cosmetic, but the complex "if" condition looks annoying to me.
Especially because it is not consistent with OOM_SCORE_ADJ_MIN check
which adds another if/continue.

	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Acked-by: David Rientjes <rientjes@google.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Hillf Danton <hillf.zj@alibaba-inc.com>
	Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Cc: Kyle Walker <kwalker@redhat.com>
	Cc: Stanislav Kozina <skozina@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit c319025a6c79e532d862e3a0b9506ba316a4d13a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/oom_kill.c
diff --cc mm/oom_kill.c
index cb09e6224089,2b6e8809d7a8..000000000000
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@@ -516,22 -574,21 +516,31 @@@ void oom_kill_process(struct task_struc
  	 * pending fatal signal.
  	 */
  	rcu_read_lock();
- 	for_each_process(p)
- 		if (p->mm == mm && !same_thread_group(p, victim) &&
- 		    !(p->flags & PF_KTHREAD)) {
- 			if (p->signal->oom_score_adj == OOM_SCORE_ADJ_MIN)
- 				continue;
+ 	for_each_process(p) {
+ 		if (p->mm != mm)
+ 			continue;
+ 		if (same_thread_group(p, victim))
+ 			continue;
+ 		if (unlikely(p->flags & PF_KTHREAD))
+ 			continue;
+ 		if (p->signal->oom_score_adj == OOM_SCORE_ADJ_MIN)
+ 			continue;
  
++<<<<<<< HEAD
 +			task_lock(p);	/* Protect ->comm from prctl() */
 +			pr_err("Kill process %d (%s) sharing same memory\n",
 +				task_pid_nr(p), p->comm);
 +			task_unlock(p);
 +			do_send_sig_info(SIGKILL, SEND_SIG_FORCED, p, true);
 +		}
++=======
+ 		do_send_sig_info(SIGKILL, SEND_SIG_FORCED, p, true);
+ 	}
++>>>>>>> c319025a6c79 (mm/oom_kill: cleanup the "kill sharing same memory" loop)
  	rcu_read_unlock();
  
 -	mmdrop(mm);
 +	set_tsk_thread_flag(victim, TIF_MEMDIE);
 +	do_send_sig_info(SIGKILL, SEND_SIG_FORCED, victim, true);
  	put_task_struct(victim);
  }
  #undef K
* Unmerged path mm/oom_kill.c
