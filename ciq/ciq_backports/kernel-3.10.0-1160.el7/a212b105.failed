bdi: make inode_to_bdi() inline

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Tejun Heo <tj@kernel.org>
commit a212b105b07d75b48b1a166378282e8a77fbf53d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/a212b105.failed

Now that bdi definitions are moved to backing-dev-defs.h,
backing-dev.h can include blkdev.h and inline inode_to_bdi() without
worrying about introducing circular include dependency.  The function
gets called from hot paths and fairly trivial.

This patch makes inode_to_bdi() and sb_is_blkdev_sb() that the
function calls inline.  blockdev_superblock and noop_backing_dev_info
are EXPORT_GPL'd to allow the inline functions to be used from
modules.

While at it, make sb_is_blkdev_sb() return bool instead of int.

v2: Fixed typo in description as suggested by Jan.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Reviewed-by: Jens Axboe <axboe@kernel.dk>
	Cc: Christoph Hellwig <hch@infradead.org>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit a212b105b07d75b48b1a166378282e8a77fbf53d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/backing-dev.h
diff --cc include/linux/backing-dev.h
index df1d4b3c6d9d,785782034e86..000000000000
--- a/include/linux/backing-dev.h
+++ b/include/linux/backing-dev.h
@@@ -14,102 -11,11 +14,110 @@@
  #include <linux/kernel.h>
  #include <linux/fs.h>
  #include <linux/sched.h>
++<<<<<<< HEAD
 +#include <linux/timer.h>
++=======
+ #include <linux/blkdev.h>
++>>>>>>> a212b105b07d (bdi: make inode_to_bdi() inline)
  #include <linux/writeback.h>
 -#include <linux/backing-dev-defs.h>
 +#include <linux/atomic.h>
 +#include <linux/sysctl.h>
 +#include <linux/workqueue.h>
  
++<<<<<<< HEAD
 +struct page;
 +struct device;
 +struct dentry;
 +
 +/*
 + * Bits in backing_dev_info.state
 + */
 +enum bdi_state {
 +	BDI_wb_alloc,		/* Default embedded wb allocated */
 +	BDI_async_congested,	/* The async (write) queue is getting full */
 +	BDI_sync_congested,	/* The sync queue is getting full */
 +	BDI_registered,		/* bdi_register() was done */
 +	BDI_writeback_running,	/* Writeback is in progress */
 +	BDI_unused,		/* Available bits start here */
 +};
 +
 +typedef int (congested_fn)(void *, int);
 +
 +enum bdi_stat_item {
 +	BDI_RECLAIMABLE,
 +	BDI_WRITEBACK,
 +	BDI_DIRTIED,
 +	BDI_WRITTEN,
 +	NR_BDI_STAT_ITEMS
 +};
 +
 +#define BDI_STAT_BATCH (8*(1+ilog2(nr_cpu_ids)))
 +
 +struct bdi_writeback {
 +	struct backing_dev_info *bdi;	/* our parent bdi */
 +	unsigned int nr;
 +
 +	unsigned long last_old_flush;	/* last old data flush */
 +
 +	struct delayed_work dwork;	/* work item used for writeback */
 +	struct list_head b_dirty;	/* dirty inodes */
 +	struct list_head b_io;		/* parked for writeback */
 +	struct list_head b_more_io;	/* parked for more writeback */
 +	spinlock_t list_lock;		/* protects the b_* lists */
 +};
 +
 +struct backing_dev_info {
 +	struct list_head bdi_list;
 +	unsigned long ra_pages;	/* max readahead in PAGE_CACHE_SIZE units */
 +	unsigned long state;	/* Always use atomic bitops on this */
 +	unsigned int capabilities; /* Device capabilities */
 +	congested_fn *congested_fn; /* Function pointer if device is md/dm */
 +	void *congested_data;	/* Pointer to aux data for congested func */
 +
 +	char *name;
 +
 +	struct percpu_counter bdi_stat[NR_BDI_STAT_ITEMS];
 +
 +	unsigned long bw_time_stamp;	/* last time write bw is updated */
 +	unsigned long dirtied_stamp;
 +	unsigned long written_stamp;	/* pages written at bw_time_stamp */
 +	unsigned long write_bandwidth;	/* the estimated write bandwidth */
 +	unsigned long avg_write_bandwidth; /* further smoothed write bw */
 +
 +	/*
 +	 * The base dirty throttle rate, re-calculated on every 200ms.
 +	 * All the bdi tasks' dirty rate will be curbed under it.
 +	 * @dirty_ratelimit tracks the estimated @balanced_dirty_ratelimit
 +	 * in small steps and is much more smooth/stable than the latter.
 +	 */
 +	unsigned long dirty_ratelimit;
 +	unsigned long balanced_dirty_ratelimit;
 +
 +	struct fprop_local_percpu completions;
 +	int dirty_exceeded;
 +
 +	unsigned int min_ratio;
 +	unsigned int max_ratio, max_prop_frac;
 +
 +	struct bdi_writeback wb;  /* default writeback info for this bdi */
 +	spinlock_t wb_lock;	  /* protects work_list & wb.dwork scheduling */
 +
 +	struct list_head work_list;
 +
 +	struct device *dev;
 +
 +	struct timer_list laptop_mode_wb_timer;
 +
 +#ifdef CONFIG_DEBUG_FS
 +	struct dentry *debug_dir;
 +	struct dentry *debug_stats;
 +#endif
 +};
 +
 +int bdi_init(struct backing_dev_info *bdi);
++=======
+ int __must_check bdi_init(struct backing_dev_info *bdi);
++>>>>>>> a212b105b07d (bdi: make inode_to_bdi() inline)
  void bdi_destroy(struct backing_dev_info *bdi);
  
  __printf(3, 4)
@@@ -277,11 -150,16 +285,24 @@@ int writeback_in_progress(struct backin
  
  static inline struct backing_dev_info *inode_to_bdi(struct inode *inode)
  {
++<<<<<<< HEAD
 +	struct super_block *sb = inode->i_sb;
 +
 +	if (sb_is_blkdev_sb(sb))
 +		return inode->i_mapping->backing_dev_info;
 +
++=======
+ 	struct super_block *sb;
+ 
+ 	if (!inode)
+ 		return &noop_backing_dev_info;
+ 
+ 	sb = inode->i_sb;
+ #ifdef CONFIG_BLOCK
+ 	if (sb_is_blkdev_sb(sb))
+ 		return blk_get_backing_dev_info(I_BDEV(inode));
+ #endif
++>>>>>>> a212b105b07d (bdi: make inode_to_bdi() inline)
  	return sb->s_bdi;
  }
  
diff --git a/fs/block_dev.c b/fs/block_dev.c
index 030d96819fe6..88cbeb11e7e2 100644
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@ -584,7 +584,8 @@ static struct file_system_type bd_type = {
 	.kill_sb	= kill_anon_super,
 };
 
-static struct super_block *blockdev_superblock __read_mostly;
+struct super_block *blockdev_superblock __read_mostly;
+EXPORT_SYMBOL_GPL(blockdev_superblock);
 
 void __init bdev_cache_init(void)
 {
@@ -726,11 +727,6 @@ static struct block_device *bd_acquire(struct inode *inode)
 	return bdev;
 }
 
-int sb_is_blkdev_sb(struct super_block *sb)
-{
-	return sb == blockdev_superblock;
-}
-
 /* Call when you free inode */
 
 void bd_forget(struct inode *inode)
* Unmerged path include/linux/backing-dev.h
diff --git a/include/linux/fs.h b/include/linux/fs.h
index c0793d4ccaf8..c84206da65e9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2559,7 +2559,13 @@ extern void emergency_thaw_all(void);
 extern void emergency_thaw_bdev(struct super_block *sb);
 extern int thaw_bdev(struct block_device *bdev, struct super_block *sb);
 extern int fsync_bdev(struct block_device *);
-extern int sb_is_blkdev_sb(struct super_block *sb);
+
+extern struct super_block *blockdev_superblock;
+
+static inline bool sb_is_blkdev_sb(struct super_block *sb)
+{
+	return sb == blockdev_superblock;
+}
 #else
 static inline void bd_forget(struct inode *inode) {}
 static inline int sync_blockdev(struct block_device *bdev) { return 0; }
