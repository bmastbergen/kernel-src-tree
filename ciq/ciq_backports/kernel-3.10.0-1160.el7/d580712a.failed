gfs2: eliminate gfs2_rsqa_alloc in favor of gfs2_qa_alloc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit d580712a37272182cb63002878f3bb7bcebbb8bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/d580712a.failed

Before this patch, multiple callers called gfs2_rsqa_alloc to force
the existence of a reservations structure and a quota data structure
if needed. However, now the reservations are handled separately, so
the quota data is only the quota data. So we eliminate the one in
favor of just calling gfs2_qa_alloc directly.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit d580712a37272182cb63002878f3bb7bcebbb8bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/acl.c
#	fs/gfs2/rgrp.c
#	fs/gfs2/xattr.c
diff --cc fs/gfs2/acl.c
index ad3b45fd2910,cb09b85c5b10..000000000000
--- a/fs/gfs2/acl.c
+++ b/fs/gfs2/acl.c
@@@ -24,6 -21,8 +24,11 @@@
  #include "glock.h"
  #include "inode.h"
  #include "meta_io.h"
++<<<<<<< HEAD
++=======
+ #include "quota.h"
+ #include "rgrp.h"
++>>>>>>> d580712a3727 (gfs2: eliminate gfs2_rsqa_alloc in favor of gfs2_qa_alloc)
  #include "trans.h"
  #include "util.h"
  
@@@ -109,198 -106,43 +114,210 @@@ out
  	return error;
  }
  
 -int gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 +int gfs2_acl_create(struct gfs2_inode *dip, struct inode *inode)
  {
 -	struct gfs2_inode *ip = GFS2_I(inode);
 -	struct gfs2_holder gh;
 -	bool need_unlock = false;
 -	int ret;
 -	umode_t mode;
 +	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 +	struct posix_acl *acl;
 +	umode_t mode = inode->i_mode;
 +	int error = 0;
  
 -	if (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))
 -		return -E2BIG;
 +	if (!sdp->sd_args.ar_posix_acl)
 +		return 0;
 +	if (S_ISLNK(inode->i_mode))
 +		return 0;
  
++<<<<<<< HEAD
 +	acl = gfs2_get_acl(&dip->i_inode, ACL_TYPE_DEFAULT);
 +	if (IS_ERR(acl))
 +		return PTR_ERR(acl);
 +	if (!acl) {
 +		mode &= ~current_umask();
 +		return gfs2_set_mode(inode, mode);
++=======
+ 	ret = gfs2_qa_alloc(ip);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (!gfs2_glock_is_locked_by_me(ip->i_gl)) {
+ 		ret = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);
+ 		if (ret)
+ 			return ret;
+ 		need_unlock = true;
++>>>>>>> d580712a3727 (gfs2: eliminate gfs2_rsqa_alloc in favor of gfs2_qa_alloc)
  	}
  
 -	mode = inode->i_mode;
 -	if (type == ACL_TYPE_ACCESS && acl) {
 -		ret = posix_acl_update_mode(inode, &mode, &acl);
 -		if (ret)
 -			goto unlock;
 +	if (S_ISDIR(inode->i_mode)) {
 +		error = gfs2_acl_set(inode, ACL_TYPE_DEFAULT, acl);
 +		if (error)
 +			goto out;
  	}
  
 -	ret = __gfs2_set_acl(inode, acl, type);
 -	if (!ret && mode != inode->i_mode) {
 -		inode->i_ctime = current_time(inode);
 -		inode->i_mode = mode;
 -		mark_inode_dirty(inode);
 +	error = posix_acl_create(&acl, GFP_NOFS, &mode);
 +	if (error < 0)
 +		return error;
 +
 +	if (error == 0)
 +		goto munge;
 +
 +	error = gfs2_acl_set(inode, ACL_TYPE_ACCESS, acl);
 +	if (error)
 +		goto out;
 +munge:
 +	error = gfs2_set_mode(inode, mode);
 +out:
 +	posix_acl_release(acl);
 +	return error;
 +}
 +
 +int gfs2_acl_chmod(struct gfs2_inode *ip, struct iattr *attr)
 +{
 +	struct inode *inode = &ip->i_inode;
 +	struct posix_acl *acl;
 +	char *data;
 +	unsigned int len;
 +	int error;
 +
 +	acl = gfs2_get_acl(&ip->i_inode, ACL_TYPE_ACCESS);
 +	if (IS_ERR(acl))
 +		return PTR_ERR(acl);
 +	if (!acl)
 +		return gfs2_setattr_simple(inode, attr);
 +
 +	error = posix_acl_chmod(&acl, GFP_NOFS, attr->ia_mode);
 +	if (error)
 +		return error;
 +
 +	len = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);
 +	data = kmalloc(len, GFP_NOFS);
 +	error = -ENOMEM;
 +	if (data == NULL)
 +		goto out;
 +	posix_acl_to_xattr(&init_user_ns, acl, data, len);
 +	error = gfs2_xattr_acl_chmod(ip, attr, data);
 +	kfree(data);
 +	set_cached_acl(&ip->i_inode, ACL_TYPE_ACCESS, acl);
 +
 +out:
 +	posix_acl_release(acl);
 +	return error;
 +}
 +
 +static int gfs2_acl_type(const char *name)
 +{
 +	if (strcmp(name, GFS2_POSIX_ACL_ACCESS) == 0)
 +		return ACL_TYPE_ACCESS;
 +	if (strcmp(name, GFS2_POSIX_ACL_DEFAULT) == 0)
 +		return ACL_TYPE_DEFAULT;
 +	return -EINVAL;
 +}
 +
 +static int gfs2_xattr_system_get(struct dentry *dentry, const char *name,
 +				 void *buffer, size_t size, int xtype)
 +{
 +	struct inode *inode = dentry->d_inode;
 +	struct gfs2_sbd *sdp = GFS2_SB(inode);
 +	struct posix_acl *acl;
 +	int type;
 +	int error;
 +
 +	if (!sdp->sd_args.ar_posix_acl)
 +		return -EOPNOTSUPP;
 +
 +	type = gfs2_acl_type(name);
 +	if (type < 0)
 +		return type;
 +
 +	acl = gfs2_get_acl(inode, type);
 +	if (IS_ERR(acl))
 +		return PTR_ERR(acl);
 +	if (acl == NULL)
 +		return -ENODATA;
 +
 +	error = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);
 +	posix_acl_release(acl);
 +
 +	return error;
 +}
 +
 +static int gfs2_xattr_system_set(struct dentry *dentry, const char *name,
 +				 const void *value, size_t size, int flags,
 +				 int xtype)
 +{
 +	struct inode *inode = dentry->d_inode;
 +	struct gfs2_sbd *sdp = GFS2_SB(inode);
 +	struct posix_acl *acl = NULL, *real_acl = NULL;
 +	int error = 0, type;
 +
 +	if (!sdp->sd_args.ar_posix_acl)
 +		return -EOPNOTSUPP;
 +
 +	type = gfs2_acl_type(name);
 +	if (type < 0)
 +		return type;
 +	if (flags & XATTR_CREATE)
 +		return -EINVAL;
 +	if (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))
 +		return value ? -EACCES : 0;
 +	if (!uid_eq(current_fsuid(), inode->i_uid) && !capable(CAP_FOWNER))
 +		return -EPERM;
 +	if (S_ISLNK(inode->i_mode))
 +		return -EOPNOTSUPP;
 +
 +	if (!value)
 +		goto set_acl;
 +
 +	acl = posix_acl_from_xattr(&init_user_ns, value, size);
 +	if (!acl) {
 +		/*
 +		 * acl_set_file(3) may request that we set default ACLs with
 +		 * zero length -- defend (gracefully) against that here.
 +		 */
 +		goto out;
 +	}
 +	if (IS_ERR(acl)) {
 +		error = PTR_ERR(acl);
 +		goto out;
 +	}
 +
 +	error = posix_acl_valid(inode->i_sb->s_user_ns, acl);
 +	if (error)
 +		goto out_release;
 +
 +	error = -EINVAL;
 +	if (acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))
 +		goto out_release;
 +
 +	real_acl = acl;
 +	if (type == ACL_TYPE_ACCESS) {
 +		umode_t mode;
 +
 +		error = posix_acl_update_mode(inode, &mode, &real_acl);
 +		if (error)
 +			goto out_release;
 +
 +		error = gfs2_set_mode(inode, mode);
 +		if (error)
 +			goto out_release;
  	}
 -unlock:
 -	if (need_unlock)
 -		gfs2_glock_dq_uninit(&gh);
 -	return ret;
 +
 +set_acl:
 +	error = __gfs2_xattr_set(inode, name, value, size, 0, GFS2_EATYPE_SYS);
 +	if (!error) {
 +		if (real_acl)
 +			set_cached_acl(inode, type, real_acl);
 +		else
 +			forget_cached_acl(inode, type);
 +	}
 +out_release:
 +	posix_acl_release(acl);
 +out:
 +	return error;
  }
 +
 +const struct xattr_handler gfs2_xattr_system_handler = {
 +	.prefix = XATTR_SYSTEM_PREFIX,
 +	.flags  = GFS2_EATYPE_SYS,
 +	.get    = gfs2_xattr_system_get,
 +	.set    = gfs2_xattr_system_set,
 +};
 +
diff --cc fs/gfs2/rgrp.c
index 61ede4feb7e3,3e3696da5bcb..000000000000
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@@ -568,20 -590,13 +568,25 @@@ void gfs2_free_clones(struct gfs2_rgrp
  	}
  }
  
++<<<<<<< HEAD
 +/**
 + * gfs2_rsqa_alloc - make sure we have a reservation assigned to the inode
 + *                 plus a quota allocations data structure, if necessary
 + * @ip: the inode for this reservation
 + */
 +int gfs2_rsqa_alloc(struct gfs2_inode *ip)
 +{
 +	return gfs2_qa_alloc(ip);
 +}
 +
 +static void dump_rs(struct seq_file *seq, const struct gfs2_blkreserv *rs)
++=======
+ static void dump_rs(struct seq_file *seq, const struct gfs2_blkreserv *rs,
+ 		    const char *fs_id_buf)
++>>>>>>> d580712a3727 (gfs2: eliminate gfs2_rsqa_alloc in favor of gfs2_qa_alloc)
  {
 -	struct gfs2_inode *ip = container_of(rs, struct gfs2_inode, i_res);
 -
 -	gfs2_print_dbg(seq, "%s  B: n:%llu s:%llu b:%u f:%u\n", fs_id_buf,
 -		       (unsigned long long)ip->i_no_addr,
 +	gfs2_print_dbg(seq, "  B: n:%llu s:%llu b:%u f:%u\n",
 +		       (unsigned long long)rs->rs_inum,
  		       (unsigned long long)gfs2_rbm_to_block(&rs->rs_rbm),
  		       rs->rs_rbm.offset, rs->rs_free);
  }
diff --cc fs/gfs2/xattr.c
index 3d8d490c8606,c4fbb96e001f..000000000000
--- a/fs/gfs2/xattr.c
+++ b/fs/gfs2/xattr.c
@@@ -1202,23 -1213,16 +1202,27 @@@ int __gfs2_xattr_set(struct inode *inod
  	return error;
  }
  
 -static int gfs2_xattr_set(const struct xattr_handler *handler,
 -			  struct dentry *unused, struct inode *inode,
 -			  const char *name, const void *value,
 -			  size_t size, int flags)
 +static int gfs2_xattr_set(struct dentry *dentry, const char *name,
 +		const void *value, size_t size, int flags, int type)
  {
 -	struct gfs2_inode *ip = GFS2_I(inode);
 -	struct gfs2_holder gh;
 +	return __gfs2_xattr_set(dentry->d_inode, name, value,
 +				size, flags, type);
 +}
 +
 +
 +static int ea_acl_chmod_unstuffed(struct gfs2_inode *ip,
 +				  struct gfs2_ea_header *ea, char *data)
 +{
 +	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
 +	unsigned int amount = GFS2_EA_DATA_LEN(ea);
 +	unsigned int nptrs = DIV_ROUND_UP(amount, sdp->sd_jbsize);
  	int ret;
  
++<<<<<<< HEAD
 +	ret = gfs2_trans_begin(sdp, nptrs + RES_DINODE, 0);
++=======
+ 	ret = gfs2_qa_alloc(ip);
++>>>>>>> d580712a3727 (gfs2: eliminate gfs2_rsqa_alloc in favor of gfs2_qa_alloc)
  	if (ret)
  		return ret;
  
* Unmerged path fs/gfs2/acl.c
diff --git a/fs/gfs2/bmap.c b/fs/gfs2/bmap.c
index 1879d6dd89c5..3318de8bf774 100644
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@ -2186,7 +2186,7 @@ int gfs2_setattr_size(struct inode *inode, u64 newsize)
 
 	inode_dio_wait(inode);
 
-	ret = gfs2_rsqa_alloc(ip);
+	ret = gfs2_qa_alloc(ip);
 	if (ret)
 		goto out;
 
diff --git a/fs/gfs2/file.c b/fs/gfs2/file.c
index 1c0c0f8e680b..4d15f5076403 100644
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@ -411,7 +411,7 @@ static int gfs2_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
 
 	sb_start_pagefault(inode->i_sb);
 
-	ret = gfs2_rsqa_alloc(ip);
+	ret = gfs2_qa_alloc(ip);
 	if (ret)
 		goto out;
 
@@ -716,7 +716,7 @@ static ssize_t gfs2_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 	size_t ocount, count;
 	ssize_t ret;
 
-	ret = gfs2_rsqa_alloc(ip);
+	ret = gfs2_qa_alloc(ip);
 	if (ret)
 		return ret;
 
@@ -1004,7 +1004,7 @@ static long gfs2_fallocate(struct file *file, int mode, loff_t offset, loff_t le
 	if (mode & FALLOC_FL_PUNCH_HOLE) {
 		ret = __gfs2_punch_hole(file, offset, len);
 	} else {
-		ret = gfs2_rsqa_alloc(ip);
+		ret = gfs2_qa_alloc(ip);
 		if (ret)
 			goto out_putw;
 
@@ -1054,7 +1054,7 @@ static ssize_t gfs2_file_splice_write(struct pipe_inode_info *pipe,
 	int error;
 	struct gfs2_inode *ip = GFS2_I(out->f_mapping->host);
 
-	error = gfs2_rsqa_alloc(ip);
+	error = gfs2_qa_alloc(ip);
 	if (error)
 		return (ssize_t)error;
 
diff --git a/fs/gfs2/inode.c b/fs/gfs2/inode.c
index a7cb675316c4..dd5ad5f21ce2 100644
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@ -561,7 +561,7 @@ static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,
 	if (!name->len || name->len > GFS2_FNAMESIZE)
 		return -ENAMETOOLONG;
 
-	error = gfs2_rsqa_alloc(dip);
+	error = gfs2_qa_alloc(dip);
 	if (error)
 		return error;
 
@@ -610,7 +610,7 @@ static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,
 		goto fail_gunlock;
 
 	ip = GFS2_I(inode);
-	error = gfs2_rsqa_alloc(ip);
+	error = gfs2_qa_alloc(ip);
 	if (error)
 		goto fail_free_inode;
 
@@ -847,7 +847,7 @@ static int gfs2_link(struct dentry *old_dentry, struct inode *dir,
 	if (S_ISDIR(inode->i_mode))
 		return -EPERM;
 
-	error = gfs2_rsqa_alloc(dip);
+	error = gfs2_qa_alloc(dip);
 	if (error)
 		return error;
 
@@ -1322,7 +1322,7 @@ static int gfs2_rename(struct inode *odir, struct dentry *odentry,
 	if (error)
 		return error;
 
-	error = gfs2_rsqa_alloc(ndip);
+	error = gfs2_qa_alloc(ndip);
 	if (error)
 		return error;
 
@@ -1829,7 +1829,7 @@ static int setattr_chown(struct inode *inode, struct iattr *attr)
 	if (!(attr->ia_valid & ATTR_GID) || gid_eq(ogid, ngid))
 		ogid = ngid = NO_GID_QUOTA_CHANGE;
 
-	error = gfs2_rsqa_alloc(ip);
+	error = gfs2_qa_alloc(ip);
 	if (error)
 		goto out;
 
@@ -1890,7 +1890,7 @@ static int gfs2_setattr(struct dentry *dentry, struct iattr *attr)
 	struct gfs2_holder i_gh;
 	int error;
 
-	error = gfs2_rsqa_alloc(ip);
+	error = gfs2_qa_alloc(ip);
 	if (error)
 		return error;
 
diff --git a/fs/gfs2/quota.c b/fs/gfs2/quota.c
index 59f8789aa118..254fa282156c 100644
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@ -558,7 +558,7 @@ int gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)
 		return 0;
 
 	if (ip->i_qadata == NULL) {
-		error = gfs2_rsqa_alloc(ip);
+		error = gfs2_qa_alloc(ip);
 		if (error)
 			return error;
 	}
@@ -870,7 +870,7 @@ static int do_sync(unsigned int num_qd, struct gfs2_quota_data **qda)
 	unsigned int nalloc = 0, blocks;
 	int error;
 
-	error = gfs2_rsqa_alloc(ip);
+	error = gfs2_qa_alloc(ip);
 	if (error)
 		return error;
 
@@ -1678,7 +1678,7 @@ static int gfs2_set_dqblk(struct super_block *sb, struct kqid qid,
 	if (error)
 		return error;
 
-	error = gfs2_rsqa_alloc(ip);
+	error = gfs2_qa_alloc(ip);
 	if (error)
 		goto out_put;
 
* Unmerged path fs/gfs2/rgrp.c
diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 5b363f86df1a..8b3c659cef24 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -49,7 +49,6 @@ extern void gfs2_inplace_release(struct gfs2_inode *ip);
 extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
 			     bool dinode, u64 *generation);
 
-extern int gfs2_rsqa_alloc(struct gfs2_inode *ip);
 extern void gfs2_rs_deltree(struct gfs2_blkreserv *rs);
 extern void gfs2_rsqa_delete(struct gfs2_inode *ip, atomic_t *wcount);
 extern void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta);
* Unmerged path fs/gfs2/xattr.c
