ras: acpi/apei: cper: add support for generic data v3 structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Tyler Baicar <tbaicar@codeaurora.org>
commit bbcc2e7b642ed241651fee50ac6ed59643cb1736
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/bbcc2e7b.failed

The ACPI 6.1 spec adds a new revision of the generic error data
entry structure. Add support to handle the new structure as well
as properly verify and iterate through the generic data entries.

	Signed-off-by: Tyler Baicar <tbaicar@codeaurora.org>
CC: Jonathan (Zhixiong) Zhang <zjzhang@codeaurora.org>
	Signed-off-by: Will Deacon <will.deacon@arm.com>
(cherry picked from commit bbcc2e7b642ed241651fee50ac6ed59643cb1736)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/apei/ghes.c
#	drivers/firmware/efi/cper.c
diff --cc drivers/acpi/apei/ghes.c
index 7f3555a98b9d,81e06e3cb08f..000000000000
--- a/drivers/acpi/apei/ghes.c
+++ b/drivers/acpi/apei/ghes.c
@@@ -412,27 -426,30 +412,26 @@@ static void ghes_handle_memory_failure(
  {
  #ifdef CONFIG_ACPI_APEI_MEMORY_FAILURE
  	unsigned long pfn;
 -	int flags = -1;
  	int sec_sev = ghes_severity(gdata->error_severity);
- 	struct cper_sec_mem_err *mem_err;
- 	mem_err = (struct cper_sec_mem_err *)(gdata + 1);
+ 	struct cper_sec_mem_err *mem_err = acpi_hest_get_payload(gdata);
  
 -	if (!(mem_err->validation_bits & CPER_MEM_VALID_PA))
 -		return;
 -
 -	pfn = mem_err->physical_addr >> PAGE_SHIFT;
 -	if (!pfn_valid(pfn)) {
 -		pr_warn_ratelimited(FW_WARN GHES_PFX
 -		"Invalid address in generic error data: %#llx\n",
 -		mem_err->physical_addr);
 -		return;
 -	}
 -
 -	/* iff following two events can be handled properly by now */
  	if (sec_sev == GHES_SEV_CORRECTED &&
 -	    (gdata->flags & CPER_SEC_ERROR_THRESHOLD_EXCEEDED))
 -		flags = MF_SOFT_OFFLINE;
 -	if (sev == GHES_SEV_RECOVERABLE && sec_sev == GHES_SEV_RECOVERABLE)
 -		flags = 0;
 -
 -	if (flags != -1)
 -		memory_failure_queue(pfn, 0, flags);
 +	    (gdata->flags & CPER_SEC_ERROR_THRESHOLD_EXCEEDED) &&
 +	    (mem_err->validation_bits & CPER_MEM_VALID_PA)) {
 +		pfn = mem_err->physical_addr >> PAGE_SHIFT;
 +		if (pfn_valid(pfn))
 +			memory_failure_queue(pfn, 0, MF_SOFT_OFFLINE);
 +		else if (printk_ratelimit())
 +			pr_warn(FW_WARN GHES_PFX
 +			"Invalid address in generic error data: %#llx\n",
 +			mem_err->physical_addr);
 +	}
 +	if (sev == GHES_SEV_RECOVERABLE &&
 +	    sec_sev == GHES_SEV_RECOVERABLE &&
 +	    mem_err->validation_bits & CPER_MEM_VALID_PA) {
 +		pfn = mem_err->physical_addr >> PAGE_SHIFT;
 +		memory_failure_queue(pfn, 0, 0);
 +	}
  #endif
  }
  
@@@ -444,23 -462,20 +443,35 @@@ static void ghes_do_proc(struct ghes *g
  
  	sev = ghes_severity(estatus->error_severity);
  	apei_estatus_for_each_section(estatus, gdata) {
 -		sec_type = (guid_t *)gdata->section_type;
  		sec_sev = ghes_severity(gdata->error_severity);
++<<<<<<< HEAD
 +		if (!uuid_le_cmp(*(uuid_le *)gdata->section_type,
 +				 CPER_SEC_PLATFORM_MEM)) {
 +			struct cper_sec_mem_err *mem_err;
 +			mem_err = (struct cper_sec_mem_err *)(gdata+1);
++=======
+ 		if (guid_equal(sec_type, &CPER_SEC_PLATFORM_MEM)) {
+ 			struct cper_sec_mem_err *mem_err = acpi_hest_get_payload(gdata);
+ 
++>>>>>>> bbcc2e7b642e (ras: acpi/apei: cper: add support for generic data v3 structure)
  			ghes_edac_report_mem_error(ghes, sev, mem_err);
  
 -			arch_apei_report_mem_error(sev, mem_err);
 +#ifdef CONFIG_X86_MCE
 +			apei_mce_report_mem_error(sev, mem_err);
 +#endif
  			ghes_handle_memory_failure(gdata, sev);
  		}
  #ifdef CONFIG_ACPI_APEI_PCIEAER
++<<<<<<< HEAD
 +		else if (!uuid_le_cmp(*(uuid_le *)gdata->section_type,
 +				      CPER_SEC_PCIE)) {
 +			struct cper_sec_pcie *pcie_err;
 +			pcie_err = (struct cper_sec_pcie *)(gdata+1);
++=======
+ 		else if (guid_equal(sec_type, &CPER_SEC_PCIE)) {
+ 			struct cper_sec_pcie *pcie_err = acpi_hest_get_payload(gdata);
+ 
++>>>>>>> bbcc2e7b642e (ras: acpi/apei: cper: add support for generic data v3 structure)
  			if (sev == GHES_SEV_RECOVERABLE &&
  			    sec_sev == GHES_SEV_RECOVERABLE &&
  			    pcie_err->validation_bits & CPER_PCIE_VALID_DEVICE_ID &&
diff --cc drivers/firmware/efi/cper.c
index cd9d6da63e1f,902475704311..000000000000
--- a/drivers/firmware/efi/cper.c
+++ b/drivers/firmware/efi/cper.c
@@@ -377,25 -385,11 +378,31 @@@ static void cper_print_pcie(const char 
  		printk(
  	"%s""bridge: secondary_status: 0x%04x, control: 0x%04x\n",
  	pfx, pcie->bridge.secondary_status, pcie->bridge.control);
 +
 +	/* Fatal errors call __ghes_panic() before AER handler prints this */
 +	if ((pcie->validation_bits & CPER_PCIE_VALID_AER_INFO) &&
 +	    (gdata->error_severity & CPER_SEV_FATAL)) {
 +		struct aer_capability_regs *aer;
 +
 +		aer = (struct aer_capability_regs *)pcie->aer_info;
 +		printk("%saer_uncor_status: 0x%08x, aer_uncor_mask: 0x%08x\n",
 +		       pfx, aer->uncor_status, aer->uncor_mask);
 +		printk("%saer_uncor_severity: 0x%08x\n",
 +		       pfx, aer->uncor_severity);
 +		printk("%sTLP Header: %08x %08x %08x %08x\n", pfx,
 +		       aer->header_log.dw0, aer->header_log.dw1,
 +		       aer->header_log.dw2, aer->header_log.dw3);
 +	}
  }
  
++<<<<<<< HEAD
 +static void cper_estatus_print_section(
 +	const char *pfx, const struct acpi_generic_data *gdata, int sec_no)
++=======
+ static void
+ cper_estatus_print_section(const char *pfx, struct acpi_hest_generic_data *gdata,
+ 			   int sec_no)
++>>>>>>> bbcc2e7b642e (ras: acpi/apei: cper: add support for generic data v3 structure)
  {
  	uuid_le *sec_type = (uuid_le *)gdata->section_type;
  	__u16 severity;
@@@ -418,10 -413,13 +426,11 @@@
  		else
  			goto err_section_too_small;
  	} else if (!uuid_le_cmp(*sec_type, CPER_SEC_PLATFORM_MEM)) {
- 		struct cper_sec_mem_err *mem_err = (void *)(gdata + 1);
+ 		struct cper_sec_mem_err *mem_err = acpi_hest_get_payload(gdata);
+ 
  		printk("%s""section_type: memory error\n", newpfx);
 -		if (gdata->error_data_length >=
 -		    sizeof(struct cper_sec_mem_err_old))
 -			cper_print_mem(newpfx, mem_err,
 -				       gdata->error_data_length);
 +		if (gdata->error_data_length >= sizeof(*mem_err))
 +			cper_print_mem(newpfx, mem_err);
  		else
  			goto err_section_too_small;
  	} else if (!uuid_le_cmp(*sec_type, CPER_SEC_PCIE)) {
@@@ -441,10 -440,10 +451,15 @@@ err_section_too_small
  }
  
  void cper_estatus_print(const char *pfx,
 -			const struct acpi_hest_generic_status *estatus)
 +			const struct acpi_generic_status *estatus)
  {
++<<<<<<< HEAD
 +	struct acpi_generic_data *gdata;
 +	unsigned int data_len, gedata_len;
++=======
+ 	struct acpi_hest_generic_data *gdata;
+ 	unsigned int data_len;
++>>>>>>> bbcc2e7b642e (ras: acpi/apei: cper: add support for generic data v3 structure)
  	int sec_no = 0;
  	char newpfx[64];
  	__u16 severity;
@@@ -456,13 -455,13 +471,13 @@@
  		       "and requires no further action");
  	printk("%s""event severity: %s\n", pfx, cper_severity_str(severity));
  	data_len = estatus->data_length;
 -	gdata = (struct acpi_hest_generic_data *)(estatus + 1);
 +	gdata = (struct acpi_generic_data *)(estatus + 1);
  	snprintf(newpfx, sizeof(newpfx), "%s%s", pfx, INDENT_SP);
- 	while (data_len >= sizeof(*gdata)) {
- 		gedata_len = gdata->error_data_length;
+ 
+ 	while (data_len >= acpi_hest_get_size(gdata)) {
  		cper_estatus_print_section(newpfx, gdata, sec_no);
- 		data_len -= gedata_len + sizeof(*gdata);
- 		gdata = (void *)(gdata + 1) + gedata_len;
+ 		data_len -= acpi_hest_get_record_size(gdata);
+ 		gdata = acpi_hest_get_next(gdata);
  		sec_no++;
  	}
  }
@@@ -491,13 -490,15 +506,22 @@@ int cper_estatus_check(const struct acp
  	if (rc)
  		return rc;
  	data_len = estatus->data_length;
++<<<<<<< HEAD
 +	gdata = (struct acpi_generic_data *)(estatus + 1);
 +	while (data_len >= sizeof(*gdata)) {
 +		gedata_len = gdata->error_data_length;
 +		if (gedata_len > data_len - sizeof(*gdata))
++=======
+ 	gdata = (struct acpi_hest_generic_data *)(estatus + 1);
+ 
+ 	while (data_len >= acpi_hest_get_size(gdata)) {
+ 		gedata_len = acpi_hest_get_error_length(gdata);
+ 		if (gedata_len > data_len - acpi_hest_get_size(gdata))
++>>>>>>> bbcc2e7b642e (ras: acpi/apei: cper: add support for generic data v3 structure)
  			return -EINVAL;
- 		data_len -= gedata_len + sizeof(*gdata);
- 		gdata = (void *)(gdata + 1) + gedata_len;
+ 
+ 		data_len -= acpi_hest_get_record_size(gdata);
+ 		gdata = acpi_hest_get_next(gdata);
  	}
  	if (data_len)
  		return -EINVAL;
* Unmerged path drivers/acpi/apei/ghes.c
* Unmerged path drivers/firmware/efi/cper.c
diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index dfd60d0bfd27..0a38c8428337 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -70,3 +70,39 @@ static inline void ghes_edac_unregister(struct ghes *ghes)
 {
 }
 #endif
+
+static inline int acpi_hest_get_version(struct acpi_hest_generic_data *gdata)
+{
+	return gdata->revision >> 8;
+}
+
+static inline void *acpi_hest_get_payload(struct acpi_hest_generic_data *gdata)
+{
+	if (acpi_hest_get_version(gdata) >= 3)
+		return (void *)(((struct acpi_hest_generic_data_v300 *)(gdata)) + 1);
+
+	return gdata + 1;
+}
+
+static inline int acpi_hest_get_error_length(struct acpi_hest_generic_data *gdata)
+{
+	return ((struct acpi_hest_generic_data *)(gdata))->error_data_length;
+}
+
+static inline int acpi_hest_get_size(struct acpi_hest_generic_data *gdata)
+{
+	if (acpi_hest_get_version(gdata) >= 3)
+		return sizeof(struct acpi_hest_generic_data_v300);
+
+	return sizeof(struct acpi_hest_generic_data);
+}
+
+static inline int acpi_hest_get_record_size(struct acpi_hest_generic_data *gdata)
+{
+	return (acpi_hest_get_size(gdata) + acpi_hest_get_error_length(gdata));
+}
+
+static inline void *acpi_hest_get_next(struct acpi_hest_generic_data *gdata)
+{
+	return (void *)(gdata) + acpi_hest_get_record_size(gdata);
+}
