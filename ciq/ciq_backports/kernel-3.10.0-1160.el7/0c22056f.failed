KVM: x86: Initializing all kvm_lapic_irq fields in ioapic_write_indirect

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Nitesh Narayan Lal <nitesh@redhat.com>
commit 0c22056f8c43265da21a3dfe7b7e1379e5ff7c72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/0c22056f.failed

Previously all fields of structure kvm_lapic_irq were not initialized
before it was passed to kvm_bitmap_or_dest_vcpus(). Which will cause
an issue when any of those fields are used for processing a request.
For example not initializing the msi_redir_hint field before passing
to the kvm_bitmap_or_dest_vcpus(), may lead to a misbehavior of
kvm_apic_map_get_dest_lapic(). This will specifically happen when the
kvm_lowest_prio_delivery() returns TRUE due to a non-zero garbage
value of msi_redir_hint, which should not happen as the request belongs
to APIC fixed delivery mode and we do not want to deliver the
interrupt only to the lowest priority candidate.

This patch initializes all the fields of kvm_lapic_irq based on the
values of ioapic redirect_entry object before passing it on to
kvm_bitmap_or_dest_vcpus().

Fixes: 7ee30bc132c6 ("KVM: x86: deliver KVM IOAPIC scan request to target vCPUs")
	Signed-off-by: Nitesh Narayan Lal <nitesh@redhat.com>
	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
[Set level to false since the value doesn't really matter. Suggested
 by Vitaly Kuznetsov. - Paolo]
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 0c22056f8c43265da21a3dfe7b7e1379e5ff7c72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/ioapic.c
diff --cc arch/x86/kvm/ioapic.c
index 48c3d0dcf67b,750ff0b29404..000000000000
--- a/arch/x86/kvm/ioapic.c
+++ b/arch/x86/kvm/ioapic.c
@@@ -329,7 -375,40 +329,44 @@@ static void ioapic_write_indirect(struc
  		if (e->fields.trig_mode == IOAPIC_LEVEL_TRIG
  		    && ioapic->irr & (1 << index))
  			ioapic_service(ioapic, index, false);
++<<<<<<< HEAD
 +		kvm_vcpu_request_scan_ioapic(ioapic->kvm);
++=======
+ 		if (e->fields.delivery_mode == APIC_DM_FIXED) {
+ 			struct kvm_lapic_irq irq;
+ 
+ 			irq.vector = e->fields.vector;
+ 			irq.delivery_mode = e->fields.delivery_mode << 8;
+ 			irq.dest_mode =
+ 			    kvm_lapic_irq_dest_mode(!!e->fields.dest_mode);
+ 			irq.level = false;
+ 			irq.trig_mode = e->fields.trig_mode;
+ 			irq.shorthand = APIC_DEST_NOSHORT;
+ 			irq.dest_id = e->fields.dest_id;
+ 			irq.msi_redir_hint = false;
+ 			bitmap_zero(&vcpu_bitmap, 16);
+ 			kvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,
+ 						 &vcpu_bitmap);
+ 			if (old_dest_mode != e->fields.dest_mode ||
+ 			    old_dest_id != e->fields.dest_id) {
+ 				/*
+ 				 * Update vcpu_bitmap with vcpus specified in
+ 				 * the previous request as well. This is done to
+ 				 * keep ioapic_handled_vectors synchronized.
+ 				 */
+ 				irq.dest_id = old_dest_id;
+ 				irq.dest_mode =
+ 				    kvm_lapic_irq_dest_mode(
+ 					!!e->fields.dest_mode);
+ 				kvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,
+ 							 &vcpu_bitmap);
+ 			}
+ 			kvm_make_scan_ioapic_request_mask(ioapic->kvm,
+ 							  &vcpu_bitmap);
+ 		} else {
+ 			kvm_make_scan_ioapic_request(ioapic->kvm);
+ 		}
++>>>>>>> 0c22056f8c43 (KVM: x86: Initializing all kvm_lapic_irq fields in ioapic_write_indirect)
  		break;
  	}
  }
* Unmerged path arch/x86/kvm/ioapic.c
