ext4: introduce aging to extent status tree

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Jan Kara <jack@suse.cz>
commit 2be12de98a1cc21c4de4e2d6fb2bf5aa0a279947
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/2be12de9.failed

Introduce a simple aging to extent status tree. Each extent has a
REFERENCED bit which gets set when the extent is used. Shrinker then
skips entries with referenced bit set and clears the bit. Thus
frequently used extents have higher chances of staying in memory.

	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit 2be12de98a1cc21c4de4e2d6fb2bf5aa0a279947)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/extents_status.c
#	fs/ext4/extents_status.h
diff --cc fs/ext4/extents_status.c
index 3ef7f932e809,e04d45733976..000000000000
--- a/fs/ext4/extents_status.c
+++ b/fs/ext4/extents_status.c
@@@ -780,6 -817,11 +784,14 @@@ out
  		es->es_lblk = es1->es_lblk;
  		es->es_len = es1->es_len;
  		es->es_pblk = es1->es_pblk;
++<<<<<<< HEAD
++=======
+ 		if (!ext4_es_is_referenced(es))
+ 			ext4_es_set_referenced(es);
+ 		stats->es_stats_cache_hits++;
+ 	} else {
+ 		stats->es_stats_cache_misses++;
++>>>>>>> 2be12de98a1c (ext4: introduce aging to extent status tree)
  	}
  
  	read_unlock(&EXT4_I(inode)->i_es_lock);
@@@ -1107,14 -1258,47 +1119,31 @@@ static int __es_try_to_reclaim_extents(
  		 * We can't reclaim delayed extent from status tree because
  		 * fiemap, bigallic, and seek_data/hole need to use it.
  		 */
++<<<<<<< HEAD
 +		if (!ext4_es_is_delayed(es)) {
 +			rb_erase(&es->rb_node, &tree->root);
 +			ext4_es_free_extent(inode, es);
 +			nr_shrunk++;
 +			if (--nr_to_scan == 0)
 +				break;
 +		}
++=======
+ 		if (ext4_es_is_delayed(es))
+ 			goto next;
+ 		if (ext4_es_is_referenced(es)) {
+ 			ext4_es_clear_referenced(es);
+ 			goto next;
+ 		}
+ 
+ 		rb_erase(&es->rb_node, &tree->root);
+ 		ext4_es_free_extent(inode, es);
+ 		(*nr_shrunk)++;
+ next:
+ 		if (!node)
+ 			goto out_wrap;
+ 		es = rb_entry(node, struct extent_status, rb_node);
++>>>>>>> 2be12de98a1c (ext4: introduce aging to extent status tree)
  	}
 -	ei->i_es_shrink_lblk = es->es_lblk;
 -	return 1;
 -out_wrap:
 -	ei->i_es_shrink_lblk = 0;
 -	return 0;
 -}
 -
 -static int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan)
 -{
 -	struct inode *inode = &ei->vfs_inode;
 -	int nr_shrunk = 0;
 -	ext4_lblk_t start = ei->i_es_shrink_lblk;
 -	static DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,
 -				      DEFAULT_RATELIMIT_BURST);
 -
 -	if (ei->i_es_shk_nr == 0)
 -		return 0;
 -
 -	if (ext4_test_inode_state(inode, EXT4_STATE_EXT_PRECACHED) &&
 -	    __ratelimit(&_rs))
 -		ext4_warning(inode->i_sb, "forced shrink of precached extents");
 -
 -	if (!es_do_reclaim_extents(ei, EXT_MAX_BLOCKS, nr_to_scan, &nr_shrunk) &&
 -	    start != 0)
 -		es_do_reclaim_extents(ei, start - 1, nr_to_scan, &nr_shrunk);
 -
 -	ei->i_es_tree.cache_es = NULL;
 +	tree->cache_es = NULL;
  	return nr_shrunk;
  }
diff --cc fs/ext4/extents_status.h
index f1b62a419920,691b52613ce4..000000000000
--- a/fs/ext4/extents_status.h
+++ b/fs/ext4/extents_status.h
@@@ -29,25 -29,28 +29,49 @@@
  /*
   * These flags live in the high bits of extent_status.es_pblk
   */
++<<<<<<< HEAD
 +#define ES_SHIFT	60
++=======
+ enum {
+ 	ES_WRITTEN_B,
+ 	ES_UNWRITTEN_B,
+ 	ES_DELAYED_B,
+ 	ES_HOLE_B,
+ 	ES_REFERENCED_B,
+ 	ES_FLAGS
+ };
 -
 -#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)
 -#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)
 -
++>>>>>>> 2be12de98a1c (ext4: introduce aging to extent status tree)
 +
 +#define EXTENT_STATUS_WRITTEN	(1 << 3)
 +#define EXTENT_STATUS_UNWRITTEN (1 << 2)
 +#define EXTENT_STATUS_DELAYED	(1 << 1)
 +#define EXTENT_STATUS_HOLE	(1 << 0)
 +
++<<<<<<< HEAD
 +#define EXTENT_STATUS_FLAGS	(EXTENT_STATUS_WRITTEN | \
 +				 EXTENT_STATUS_UNWRITTEN | \
 +				 EXTENT_STATUS_DELAYED | \
 +				 EXTENT_STATUS_HOLE)
 +
 +#define ES_WRITTEN		(1ULL << 63)
 +#define ES_UNWRITTEN		(1ULL << 62)
 +#define ES_DELAYED		(1ULL << 61)
 +#define ES_HOLE			(1ULL << 60)
 +
 +#define ES_MASK			(ES_WRITTEN | ES_UNWRITTEN | \
 +				 ES_DELAYED | ES_HOLE)
++=======
+ #define EXTENT_STATUS_WRITTEN	(1 << ES_WRITTEN_B)
+ #define EXTENT_STATUS_UNWRITTEN (1 << ES_UNWRITTEN_B)
+ #define EXTENT_STATUS_DELAYED	(1 << ES_DELAYED_B)
+ #define EXTENT_STATUS_HOLE	(1 << ES_HOLE_B)
+ #define EXTENT_STATUS_REFERENCED	(1 << ES_REFERENCED_B)
+ 
+ #define ES_TYPE_MASK	((ext4_fsblk_t)(EXTENT_STATUS_WRITTEN | \
+ 			  EXTENT_STATUS_UNWRITTEN | \
+ 			  EXTENT_STATUS_DELAYED | \
+ 			  EXTENT_STATUS_HOLE) << ES_SHIFT)
++>>>>>>> 2be12de98a1c (ext4: introduce aging to extent status tree)
  
  struct ext4_sb_info;
  struct ext4_extent;
@@@ -82,29 -95,49 +106,72 @@@ extern void ext4_es_find_delayed_extent
  extern int ext4_es_lookup_extent(struct inode *inode, ext4_lblk_t lblk,
  				 struct extent_status *es);
  
++<<<<<<< HEAD
 +static inline int ext4_es_is_written(struct extent_status *es)
 +{
 +	return (es->es_pblk & ES_WRITTEN) != 0;
++=======
+ static inline unsigned int ext4_es_status(struct extent_status *es)
+ {
+ 	return es->es_pblk >> ES_SHIFT;
+ }
+ 
+ static inline unsigned int ext4_es_type(struct extent_status *es)
+ {
+ 	return (es->es_pblk & ES_TYPE_MASK) >> ES_SHIFT;
+ }
+ 
+ static inline int ext4_es_is_written(struct extent_status *es)
+ {
+ 	return (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;
++>>>>>>> 2be12de98a1c (ext4: introduce aging to extent status tree)
  }
  
  static inline int ext4_es_is_unwritten(struct extent_status *es)
  {
++<<<<<<< HEAD
 +	return (es->es_pblk & ES_UNWRITTEN) != 0;
++=======
+ 	return (ext4_es_type(es) & EXTENT_STATUS_UNWRITTEN) != 0;
++>>>>>>> 2be12de98a1c (ext4: introduce aging to extent status tree)
  }
  
  static inline int ext4_es_is_delayed(struct extent_status *es)
  {
++<<<<<<< HEAD
 +	return (es->es_pblk & ES_DELAYED) != 0;
++=======
+ 	return (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;
++>>>>>>> 2be12de98a1c (ext4: introduce aging to extent status tree)
  }
  
  static inline int ext4_es_is_hole(struct extent_status *es)
  {
++<<<<<<< HEAD
 +	return (es->es_pblk & ES_HOLE) != 0;
 +}
 +
 +static inline unsigned int ext4_es_status(struct extent_status *es)
 +{
 +	return es->es_pblk >> ES_SHIFT;
++=======
+ 	return (ext4_es_type(es) & EXTENT_STATUS_HOLE) != 0;
+ }
+ 
+ static inline void ext4_es_set_referenced(struct extent_status *es)
+ {
+ 	es->es_pblk |= ((ext4_fsblk_t)EXTENT_STATUS_REFERENCED) << ES_SHIFT;
+ }
+ 
+ static inline void ext4_es_clear_referenced(struct extent_status *es)
+ {
+ 	es->es_pblk &= ~(((ext4_fsblk_t)EXTENT_STATUS_REFERENCED) << ES_SHIFT);
+ }
+ 
+ static inline int ext4_es_is_referenced(struct extent_status *es)
+ {
+ 	return (ext4_es_status(es) & EXTENT_STATUS_REFERENCED) != 0;
++>>>>>>> 2be12de98a1c (ext4: introduce aging to extent status tree)
  }
  
  static inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)
* Unmerged path fs/ext4/extents_status.c
* Unmerged path fs/ext4/extents_status.h
