x86/platform/uv: Check EFI Boot to set reboot type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Mike Travis <mike.travis@hpe.com>
commit df55029f7ea65d8c653a79dd728918dfe25b1356
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/df55029f.failed

Change to checking for EFI Boot type from previous check on if this
is a KDUMP kernel.  This allows for KDUMP kernels that can handle
EFI reboots.

	Signed-off-by: Mike Travis <mike.travis@hpe.com>
	Reviewed-by: Steve Wahl <steve.wahl@hpe.com>
	Reviewed-by: Dimitri Sivanich <dimitri.sivanich@hpe.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Christoph Hellwig <hch@infradead.org>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Hedi Berriche <hedi.berriche@hpe.com>
	Cc: Justin Ernst <justin.ernst@hpe.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Russ Anderson <russ.anderson@hpe.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: https://lkml.kernel.org/r/20190910145840.215091717@stormcage.eag.rdlabs.hpecorp.net
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit df55029f7ea65d8c653a79dd728918dfe25b1356)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/apic/x2apic_uv_x.c
diff --cc arch/x86/kernel/apic/x2apic_uv_x.c
index c5191dfb8f26,d5b51a740524..000000000000
--- a/arch/x86/kernel/apic/x2apic_uv_x.c
+++ b/arch/x86/kernel/apic/x2apic_uv_x.c
@@@ -7,30 -7,19 +7,35 @@@
   *
   * Copyright (C) 2007-2014 Silicon Graphics, Inc. All rights reserved.
   */
 -#include <linux/crash_dump.h>
 -#include <linux/cpuhotplug.h>
  #include <linux/cpumask.h>
 +#include <linux/hardirq.h>
  #include <linux/proc_fs.h>
 -#include <linux/memory.h>
 -#include <linux/export.h>
 +#include <linux/threads.h>
 +#include <linux/kernel.h>
 +#include <linux/module.h>
 +#include <linux/string.h>
 +#include <linux/ctype.h>
 +#include <linux/sched.h>
 +#include <linux/timer.h>
 +#include <linux/slab.h>
 +#include <linux/cpu.h>
 +#include <linux/init.h>
 +#include <linux/io.h>
  #include <linux/pci.h>
++<<<<<<< HEAD
 +#include <linux/kdebug.h>
 +#include <linux/delay.h>
 +#include <linux/crash_dump.h>
 +#include <linux/memory.h>
++=======
+ #include <linux/acpi.h>
+ #include <linux/efi.h>
++>>>>>>> df55029f7ea6 (x86/platform/uv: Check EFI Boot to set reboot type)
  
 -#include <asm/e820/api.h>
  #include <asm/uv/uv_mmrs.h>
  #include <asm/uv/uv_hub.h>
 +#include <asm/current.h>
 +#include <asm/pgtable.h>
  #include <asm/uv/bios.h>
  #include <asm/uv/uv.h>
  #include <asm/apic.h>
@@@ -1514,6 -1484,76 +1519,79 @@@ static void __init build_socket_tables(
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /* Check which reboot to use */
+ static void check_efi_reboot(void)
+ {
+ 	/* If EFI reboot not available, use ACPI reboot */
+ 	if (!efi_enabled(EFI_BOOT))
+ 		reboot_type = BOOT_ACPI;
+ }
+ 
+ /* Setup user proc fs files */
+ static int proc_hubbed_show(struct seq_file *file, void *data)
+ {
+ 	seq_printf(file, "0x%x\n", uv_hubbed_system);
+ 	return 0;
+ }
+ 
+ static int proc_hubless_show(struct seq_file *file, void *data)
+ {
+ 	seq_printf(file, "0x%x\n", uv_hubless_system);
+ 	return 0;
+ }
+ 
+ static int proc_oemid_show(struct seq_file *file, void *data)
+ {
+ 	seq_printf(file, "%s/%s\n", oem_id, oem_table_id);
+ 	return 0;
+ }
+ 
+ static int proc_hubbed_open(struct inode *inode, struct file *file)
+ {
+ 	return single_open(file, proc_hubbed_show, (void *)NULL);
+ }
+ 
+ static int proc_hubless_open(struct inode *inode, struct file *file)
+ {
+ 	return single_open(file, proc_hubless_show, (void *)NULL);
+ }
+ 
+ static int proc_oemid_open(struct inode *inode, struct file *file)
+ {
+ 	return single_open(file, proc_oemid_show, (void *)NULL);
+ }
+ 
+ /* (struct is "non-const" as open function is set at runtime) */
+ static struct file_operations proc_version_fops = {
+ 	.read		= seq_read,
+ 	.llseek		= seq_lseek,
+ 	.release	= single_release,
+ };
+ 
+ static const struct file_operations proc_oemid_fops = {
+ 	.open		= proc_oemid_open,
+ 	.read		= seq_read,
+ 	.llseek		= seq_lseek,
+ 	.release	= single_release,
+ };
+ 
+ static __init void uv_setup_proc_files(int hubless)
+ {
+ 	struct proc_dir_entry *pde;
+ 	char *name = hubless ? "hubless" : "hubbed";
+ 
+ 	pde = proc_mkdir(UV_PROC_NODE, NULL);
+ 	proc_create("oemid", 0, pde, &proc_oemid_fops);
+ 	proc_create(name, 0, pde, &proc_version_fops);
+ 	if (hubless)
+ 		proc_version_fops.open = proc_hubless_open;
+ 	else
+ 		proc_version_fops.open = proc_hubbed_open;
+ }
+ 
++>>>>>>> df55029f7ea6 (x86/platform/uv: Check EFI Boot to set reboot type)
  /* Initialize UV hubless systems */
  static __init int uv_system_init_hubless(void)
  {
@@@ -1524,7 -1564,20 +1602,9 @@@
  
  	/* Init kernel/BIOS interface */
  	rc = uv_bios_init();
 -	if (rc < 0)
 -		return rc;
 -
 -	/* Process UVsystab */
 -	rc = decode_uv_systab();
 -	if (rc < 0)
 -		return rc;
 -
 -	/* Create user access node */
 -	if (rc >= 0)
 -		uv_setup_proc_files(1);
  
+ 	check_efi_reboot();
+ 
  	return rc;
  }
  
@@@ -1653,17 -1706,12 +1733,21 @@@ static void __init uv_system_init_hub(v
  	uv_nmi_setup();
  	uv_cpu_init();
  	uv_scir_register_cpu_notifier();
 -	uv_setup_proc_files(0);
 +	proc_mkdir("sgi_uv", NULL);
  
 -	/* Register Legacy VGA I/O redirection handler: */
 +	/* register Legacy VGA I/O redirection handler */
  	pci_register_set_vga_state(uv_set_vga_state);
  
++<<<<<<< HEAD
 +	/*
 +	 * For a kdump kernel the reset must be BOOT_ACPI, not BOOT_EFI, as
 +	 * EFI is not enabled in the kdump kernel.
 +	 */
 +	if (is_kdump_kernel())
 +		reboot_type = BOOT_ACPI;
++=======
+ 	check_efi_reboot();
++>>>>>>> df55029f7ea6 (x86/platform/uv: Check EFI Boot to set reboot type)
  }
  
  /*
* Unmerged path arch/x86/kernel/apic/x2apic_uv_x.c
