mm/page_owner: set correct gfp_mask on page_owner

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Joonsoo Kim <js1304@gmail.com>
commit e2cfc91120fa01e3458167054af993fb83d7d0ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/e2cfc911.failed

Currently, we set wrong gfp_mask to page_owner info in case of isolated
freepage by compaction and split page.  It causes incorrect mixed
pageblock report that we can get from '/proc/pagetypeinfo'.  This metric
is really useful to measure fragmentation effect so should be accurate.
This patch fixes it by setting correct information.

Without this patch, after kernel build workload is finished, number of
mixed pageblock is 112 among roughly 210 movable pageblocks.

But, with this fix, output shows that mixed pageblock is just 57.

	Signed-off-by: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e2cfc91120fa01e3458167054af993fb83d7d0ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/page_owner.h
#	mm/page_alloc.c
#	mm/page_owner.c
diff --cc mm/page_alloc.c
index 789e5ec3768f,ef19f22b2b7d..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -2129,8 -1962,12 +2130,17 @@@ void split_page(struct page *page, unsi
  		split_page(virt_to_page(page[0].shadow), order);
  #endif
  
++<<<<<<< HEAD
 +	for (i = 1; i < (1 << order); i++)
 +		set_page_refcounted(page + i);
++=======
+ 	gfp_mask = get_page_owner_gfp(page);
+ 	set_page_owner(page, 0, gfp_mask);
+ 	for (i = 1; i < (1 << order); i++) {
+ 		set_page_refcounted(page + i);
+ 		set_page_owner(page + i, 0, gfp_mask);
+ 	}
++>>>>>>> e2cfc91120fa (mm/page_owner: set correct gfp_mask on page_owner)
  }
  EXPORT_SYMBOL_GPL(split_page);
  
@@@ -2159,6 -1996,8 +2169,11 @@@ static int __isolate_free_page(struct p
  	zone->free_area[order].nr_free--;
  	rmv_page_order(page);
  
++<<<<<<< HEAD
++=======
+ 	set_page_owner(page, order, __GFP_MOVABLE);
+ 
++>>>>>>> e2cfc91120fa (mm/page_owner: set correct gfp_mask on page_owner)
  	/* Set the pageblock if the isolated page is at least a pageblock */
  	if (order >= pageblock_order - 1) {
  		struct page *endpage = page + (1 << order) - 1;
* Unmerged path include/linux/page_owner.h
* Unmerged path mm/page_owner.c
* Unmerged path include/linux/page_owner.h
* Unmerged path mm/page_alloc.c
* Unmerged path mm/page_owner.c
