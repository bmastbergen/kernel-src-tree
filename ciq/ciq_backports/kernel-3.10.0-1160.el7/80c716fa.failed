scsi: scsi_dh_alua: skip RTPG for devices only supporting active/optimized

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Hannes Reinecke <hare@suse.com>
commit 80c716fad82550b6c4ee4b7c6d48bff3fd7dab56
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/80c716fa.failed

For hardware only supporting active/optimized there's no point in ever
re-issuing RTPG as the only new state we can possibly read is
active/optimized.  This avoid spurious errors during path failover on
such arrays.

	Signed-off-by: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 80c716fad82550b6c4ee4b7c6d48bff3fd7dab56)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/device_handler/scsi_dh_alua.c
diff --cc drivers/scsi/device_handler/scsi_dh_alua.c
index 6acc0b4172b9,022e421c2185..000000000000
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@@ -256,7 -244,8 +258,12 @@@ static struct alua_port_group *alua_all
  	}
  	pg->group_id = group_id;
  	pg->tpgs = tpgs;
++<<<<<<< HEAD
 +	pg->state = TPGS_STATE_OPTIMIZED;
++=======
+ 	pg->state = SCSI_ACCESS_STATE_OPTIMAL;
+ 	pg->valid_states = TPGS_SUPPORT_ALL;
++>>>>>>> 80c716fad825 (scsi: scsi_dh_alua: skip RTPG for devices only supporting active/optimized)
  	if (optimize_stpg)
  		pg->flags |= ALUA_OPTIMIZE_STPG;
  	kref_init(&pg->kref);
@@@ -637,11 -657,21 +660,11 @@@ static int alua_rtpg(struct scsi_devic
  			if (spin_trylock_irqsave(&tmp_pg->lock, flags)) {
  				if ((tmp_pg == pg) ||
  				    !(tmp_pg->flags & ALUA_PG_RUNNING)) {
 -					struct alua_dh_data *h;
 -
  					tmp_pg->state = desc[0] & 0x0f;
  					tmp_pg->pref = desc[0] >> 7;
 -					rcu_read_lock();
 -					list_for_each_entry_rcu(h,
 -						&tmp_pg->dh_list, node) {
 -						/* h->sdev should always be valid */
 -						BUG_ON(!h->sdev);
 -						h->sdev->access_state = desc[0];
 -					}
 -					rcu_read_unlock();
  				}
  				if (tmp_pg == pg)
- 					valid_states = desc[1];
+ 					tmp_pg->valid_states = desc[1];
  				spin_unlock_irqrestore(&tmp_pg->lock, flags);
  			}
  			kref_put(&tmp_pg->kref, release_port_group);
@@@ -654,28 -684,40 +677,28 @@@
  		    "%s: port group %02x state %c %s supports %c%c%c%c%c%c%c\n",
  		    ALUA_DH_NAME, pg->group_id, print_alua_state(pg->state),
  		    pg->pref ? "preferred" : "non-preferred",
- 		    valid_states&TPGS_SUPPORT_TRANSITION?'T':'t',
- 		    valid_states&TPGS_SUPPORT_OFFLINE?'O':'o',
- 		    valid_states&TPGS_SUPPORT_LBA_DEPENDENT?'L':'l',
- 		    valid_states&TPGS_SUPPORT_UNAVAILABLE?'U':'u',
- 		    valid_states&TPGS_SUPPORT_STANDBY?'S':'s',
- 		    valid_states&TPGS_SUPPORT_NONOPTIMIZED?'N':'n',
- 		    valid_states&TPGS_SUPPORT_OPTIMIZED?'A':'a');
+ 		    pg->valid_states&TPGS_SUPPORT_TRANSITION?'T':'t',
+ 		    pg->valid_states&TPGS_SUPPORT_OFFLINE?'O':'o',
+ 		    pg->valid_states&TPGS_SUPPORT_LBA_DEPENDENT?'L':'l',
+ 		    pg->valid_states&TPGS_SUPPORT_UNAVAILABLE?'U':'u',
+ 		    pg->valid_states&TPGS_SUPPORT_STANDBY?'S':'s',
+ 		    pg->valid_states&TPGS_SUPPORT_NONOPTIMIZED?'N':'n',
+ 		    pg->valid_states&TPGS_SUPPORT_OPTIMIZED?'A':'a');
  
  	switch (pg->state) {
 -	case SCSI_ACCESS_STATE_TRANSITIONING:
 +	case TPGS_STATE_TRANSITIONING:
  		if (time_before(jiffies, pg->expiry)) {
  			/* State transition, retry */
 -			pg->interval = 2;
 +			pg->interval = ALUA_RTPG_RETRY_DELAY;
  			err = SCSI_DH_RETRY;
  		} else {
 -			struct alua_dh_data *h;
 -
  			/* Transitioning time exceeded, set port to standby */
  			err = SCSI_DH_IO;
 -			pg->state = SCSI_ACCESS_STATE_STANDBY;
 +			pg->state = TPGS_STATE_STANDBY;
  			pg->expiry = 0;
 -			rcu_read_lock();
 -			list_for_each_entry_rcu(h, &pg->dh_list, node) {
 -				BUG_ON(!h->sdev);
 -				h->sdev->access_state =
 -					(pg->state & SCSI_ACCESS_STATE_MASK);
 -				if (pg->pref)
 -					h->sdev->access_state |=
 -						SCSI_ACCESS_STATE_PREFERRED;
 -			}
 -			rcu_read_unlock();
  		}
  		break;
 -	case SCSI_ACCESS_STATE_OFFLINE:
 +	case TPGS_STATE_OFFLINE:
  		/* Path unusable */
  		err = SCSI_DH_DEV_OFFLINED;
  		pg->expiry = 0;
* Unmerged path drivers/scsi/device_handler/scsi_dh_alua.c
