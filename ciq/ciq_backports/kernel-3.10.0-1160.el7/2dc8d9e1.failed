ext4: forbid i_extra_isize not divisible by 4

jira LE-1907
cve CVE-2019-19767
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Eric Biggers <ebiggers@google.com>
commit 2dc8d9e19b0d891b0d3675b5ac82be9be3875e36
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/2dc8d9e1.failed

i_extra_isize not divisible by 4 is problematic for several reasons:

- It causes the in-inode xattr space to be misaligned, but the xattr
  header and entries are not declared __packed to express this
  possibility.  This may cause poor performance or incorrect code
  generation on some platforms.
- When validating the xattr entries we can read past the end of the
  inode if the size available for xattrs is not a multiple of 4.
- It allows the nonsensical i_extra_isize=1, which doesn't even leave
  enough room for i_extra_isize itself.

Therefore, update ext4_iget() to consider i_extra_isize not divisible by
4 to be an error, like the case where i_extra_isize is too large.

This also matches the rule recently added to e2fsck for determining
whether an inode has valid i_extra_isize.

This patch shouldn't have any noticeable effect on
non-corrupted/non-malicious filesystems, since the size of ext4_inode
has always been a multiple of 4.

	Signed-off-by: Eric Biggers <ebiggers@google.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Reviewed-by: Andreas Dilger <adilger@dilger.ca>
(cherry picked from commit 2dc8d9e19b0d891b0d3675b5ac82be9be3875e36)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/inode.c
diff --cc fs/ext4/inode.c
index 8274eb8296d4,e3e197898c66..000000000000
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@@ -4392,11 -4572,13 +4392,21 @@@ struct inode *ext4_iget(struct super_bl
  	if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {
  		ei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);
  		if (EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >
++<<<<<<< HEAD
 +		    EXT4_INODE_SIZE(inode->i_sb)) {
 +			EXT4_ERROR_INODE(inode, "bad extra_isize (%u != %u)",
 +				EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize,
 +				EXT4_INODE_SIZE(inode->i_sb));
 +			ret = -EIO;
++=======
+ 			EXT4_INODE_SIZE(inode->i_sb) ||
+ 		    (ei->i_extra_isize & 3)) {
+ 			EXT4_ERROR_INODE(inode,
+ 					 "bad extra_isize %u (inode size %u)",
+ 					 ei->i_extra_isize,
+ 					 EXT4_INODE_SIZE(inode->i_sb));
+ 			ret = -EFSCORRUPTED;
++>>>>>>> 2dc8d9e19b0d (ext4: forbid i_extra_isize not divisible by 4)
  			goto bad_inode;
  		}
  	} else
* Unmerged path fs/ext4/inode.c
