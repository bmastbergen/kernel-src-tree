s390/diag: add a statistic for diagnose calls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Martin Schwidefsky <schwidefsky@de.ibm.com>
commit 1ec2772e0c3ca3159035c03165355e355efc326b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/1ec2772e.failed

Introduce /sys/debug/kernel/diag_stat with a statistic how many diagnose
calls have been done by each CPU in the system.

	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 1ec2772e0c3ca3159035c03165355e355efc326b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/hypfs/hypfs_diag.c
#	arch/s390/hypfs/hypfs_sprp.c
#	arch/s390/include/asm/diag.h
#	arch/s390/kernel/cpcmd.c
#	arch/s390/kernel/diag.c
diff --cc arch/s390/hypfs/hypfs_diag.c
index c9aee42e32e6,045035796ca7..000000000000
--- a/arch/s390/hypfs/hypfs_diag.c
+++ b/arch/s390/hypfs/hypfs_diag.c
@@@ -210,6 -336,28 +210,31 @@@ static inline __u64 phys_cpu__ctidx(enu
  }
  
  /* Diagnose 204 functions */
++<<<<<<< HEAD
++=======
+ 
+ static inline int __diag204(unsigned long subcode, unsigned long size, void *addr)
+ {
+ 	register unsigned long _subcode asm("0") = subcode;
+ 	register unsigned long _size asm("1") = size;
+ 
+ 	asm volatile(
+ 		"	diag	%2,%0,0x204\n"
+ 		"0:\n"
+ 		EX_TABLE(0b,0b)
+ 		: "+d" (_subcode), "+d" (_size) : "d" (addr) : "memory");
+ 	if (_subcode)
+ 		return -1;
+ 	return _size;
+ }
+ 
+ static int diag204(unsigned long subcode, unsigned long size, void *addr)
+ {
+ 	diag_stat_inc(DIAG_STAT_X204);
+ 	return __diag204(subcode, size, addr);
+ }
+ 
++>>>>>>> 1ec2772e0c3c (s390/diag: add a statistic for diagnose calls)
  /*
   * For the old diag subcode 4 with simple data format we have to use real
   * memory. If we use subcode 6 or 7 with extended data format, we can (and
@@@ -360,6 -508,20 +385,23 @@@ out
  
  /* Diagnose 224 functions */
  
++<<<<<<< HEAD
++=======
+ static int diag224(void *ptr)
+ {
+ 	int rc = -EOPNOTSUPP;
+ 
+ 	diag_stat_inc(DIAG_STAT_X224);
+ 	asm volatile(
+ 		"	diag	%1,%2,0x224\n"
+ 		"0:	lhi	%0,0x0\n"
+ 		"1:\n"
+ 		EX_TABLE(0b,1b)
+ 		: "+d" (rc) :"d" (0), "d" (ptr) : "memory");
+ 	return rc;
+ }
+ 
++>>>>>>> 1ec2772e0c3c (s390/diag: add a statistic for diagnose calls)
  static int diag224_get_name_table(void)
  {
  	/* memory must be below 2GB */
diff --cc arch/s390/include/asm/diag.h
index 1aa8265588bf,e423cfcaf77d..000000000000
--- a/arch/s390/include/asm/diag.h
+++ b/arch/s390/include/asm/diag.h
@@@ -8,7 -8,41 +8,45 @@@
  #ifndef _ASM_S390_DIAG_H
  #define _ASM_S390_DIAG_H
  
++<<<<<<< HEAD
 +#include <linux/if_ether.h>
++=======
+ #include <linux/percpu.h>
+ 
+ enum diag_stat_enum {
+ 	DIAG_STAT_X008,
+ 	DIAG_STAT_X00C,
+ 	DIAG_STAT_X010,
+ 	DIAG_STAT_X014,
+ 	DIAG_STAT_X044,
+ 	DIAG_STAT_X064,
+ 	DIAG_STAT_X09C,
+ 	DIAG_STAT_X0DC,
+ 	DIAG_STAT_X204,
+ 	DIAG_STAT_X210,
+ 	DIAG_STAT_X224,
+ 	DIAG_STAT_X250,
+ 	DIAG_STAT_X258,
+ 	DIAG_STAT_X288,
+ 	DIAG_STAT_X2C4,
+ 	DIAG_STAT_X2FC,
+ 	DIAG_STAT_X304,
+ 	DIAG_STAT_X308,
+ 	DIAG_STAT_X500,
+ 	NR_DIAG_STAT
+ };
+ 
+ struct diag_stat {
+ 	unsigned int counter[NR_DIAG_STAT];
+ };
+ 
+ DECLARE_PER_CPU(struct diag_stat, diag_stat);
+ 
+ static inline void diag_stat_inc(enum diag_stat_enum nr)
+ {
+ 	this_cpu_inc(diag_stat.counter[nr]);
+ }
++>>>>>>> 1ec2772e0c3c (s390/diag: add a statistic for diagnose calls)
  
  /*
   * Diagnose 10: Release page range
diff --cc arch/s390/kernel/cpcmd.c
index 825079d65898,7f768914fb4f..000000000000
--- a/arch/s390/kernel/cpcmd.c
+++ b/arch/s390/kernel/cpcmd.c
@@@ -14,7 -14,7 +14,11 @@@
  #include <linux/spinlock.h>
  #include <linux/stddef.h>
  #include <linux/string.h>
++<<<<<<< HEAD
 +#include <linux/mm.h>
++=======
+ #include <asm/diag.h>
++>>>>>>> 1ec2772e0c3c (s390/diag: add a statistic for diagnose calls)
  #include <asm/ebcdic.h>
  #include <asm/cpcmd.h>
  #include <asm/io.h>
diff --cc arch/s390/kernel/diag.c
index 55dee28dda39,4ddb5200ddf0..000000000000
--- a/arch/s390/kernel/diag.c
+++ b/arch/s390/kernel/diag.c
@@@ -33,29 -136,14 +140,35 @@@ static inline int __diag14(unsigned lon
  
  	return rc;
  }
+ 
+ int diag14(unsigned long rx, unsigned long ry1, unsigned long subcode)
+ {
+ 	diag_stat_inc(DIAG_STAT_X014);
+ 	return __diag14(rx, ry1, subcode);
+ }
  EXPORT_SYMBOL(diag14);
  
 +static inline int __diag204(unsigned long subcode, unsigned long size, void *addr)
 +{
 +	register unsigned long _subcode asm("0") = subcode;
 +	register unsigned long _size asm("1") = size;
 +
 +	asm volatile(
 +		"	diag	%2,%0,0x204\n"
 +		"0:\n"
 +		EX_TABLE(0b,0b)
 +		: "+d" (_subcode), "+d" (_size) : "d" (addr) : "memory");
 +	if (_subcode)
 +		return -1;
 +	return _size;
 +}
 +
 +int diag204(unsigned long subcode, unsigned long size, void *addr)
 +{
 +	return __diag204(subcode, size, addr);
 +}
 +EXPORT_SYMBOL(diag204);
 +
  /*
   * Diagnose 210: Get information about a virtual device
   */
@@@ -73,7 -161,7 +186,11 @@@ int diag210(struct diag210 *addr
  	spin_lock_irqsave(&diag210_lock, flags);
  	diag210_tmp = *addr;
  
++<<<<<<< HEAD
 +#ifdef CONFIG_64BIT
++=======
+ 	diag_stat_inc(DIAG_STAT_X210);
++>>>>>>> 1ec2772e0c3c (s390/diag: add a statistic for diagnose calls)
  	asm volatile(
  		"	lhi	%0,-1\n"
  		"	sam31\n"
* Unmerged path arch/s390/hypfs/hypfs_sprp.c
* Unmerged path arch/s390/hypfs/hypfs_diag.c
diff --git a/arch/s390/hypfs/hypfs_diag0c.c b/arch/s390/hypfs/hypfs_diag0c.c
index d4c0d3717543..6f76dbb2b24e 100644
--- a/arch/s390/hypfs/hypfs_diag0c.c
+++ b/arch/s390/hypfs/hypfs_diag0c.c
@@ -8,6 +8,7 @@
 
 #include <linux/slab.h>
 #include <linux/cpu.h>
+#include <asm/diag.h>
 #include <asm/hypfs.h>
 #include "hypfs.h"
 
@@ -18,6 +19,7 @@
  */
 static void diag0c(struct hypfs_diag0c_entry *entry)
 {
+	diag_stat_inc(DIAG_STAT_X00C);
 	asm volatile (
 #ifdef CONFIG_64BIT
 		"	sam31\n"
* Unmerged path arch/s390/hypfs/hypfs_sprp.c
diff --git a/arch/s390/hypfs/hypfs_vm.c b/arch/s390/hypfs/hypfs_vm.c
index cb20914a8eb2..717445017daa 100644
--- a/arch/s390/hypfs/hypfs_vm.c
+++ b/arch/s390/hypfs/hypfs_vm.c
@@ -9,6 +9,7 @@
 #include <linux/errno.h>
 #include <linux/string.h>
 #include <linux/vmalloc.h>
+#include <asm/diag.h>
 #include <asm/ebcdic.h>
 #include <asm/timex.h>
 #include "hypfs.h"
@@ -66,6 +67,7 @@ static int diag2fc(int size, char* query, void *addr)
 	memset(parm_list.aci_grp, 0x40, NAME_LEN);
 	rc = -1;
 
+	diag_stat_inc(DIAG_STAT_X2FC);
 	asm volatile(
 		"	diag    %0,%1,0x2fc\n"
 		"0:\n"
diff --git a/arch/s390/include/asm/appldata.h b/arch/s390/include/asm/appldata.h
index 32a705987156..0195fd16d1fd 100644
--- a/arch/s390/include/asm/appldata.h
+++ b/arch/s390/include/asm/appldata.h
@@ -7,6 +7,7 @@
 #ifndef _ASM_S390_APPLDATA_H
 #define _ASM_S390_APPLDATA_H
 
+#include <asm/diag.h>
 #include <asm/io.h>
 
 #ifndef CONFIG_64BIT
@@ -77,6 +78,7 @@ static inline int appldata_asm(struct appldata_product_id *id,
 	parm_list.buffer_length = length;
 	parm_list.product_id_addr = (unsigned long) id;
 	parm_list.buffer_addr = virt_to_phys(buffer);
+	diag_stat_inc(DIAG_STAT_X0DC);
 	asm volatile(
 		"	diag	%1,%0,0xdc"
 		: "=d" (ry)
* Unmerged path arch/s390/include/asm/diag.h
diff --git a/arch/s390/include/asm/kvm_para.h b/arch/s390/include/asm/kvm_para.h
index e0f842308a68..41393052ac57 100644
--- a/arch/s390/include/asm/kvm_para.h
+++ b/arch/s390/include/asm/kvm_para.h
@@ -27,10 +27,9 @@
 #define __S390_KVM_PARA_H
 
 #include <uapi/asm/kvm_para.h>
+#include <asm/diag.h>
 
-
-
-static inline long kvm_hypercall0(unsigned long nr)
+static inline long __kvm_hypercall0(unsigned long nr)
 {
 	register unsigned long __nr asm("1") = nr;
 	register long __rc asm("2");
@@ -40,7 +39,13 @@ static inline long kvm_hypercall0(unsigned long nr)
 	return __rc;
 }
 
-static inline long kvm_hypercall1(unsigned long nr, unsigned long p1)
+static inline long kvm_hypercall0(unsigned long nr)
+{
+	diag_stat_inc(DIAG_STAT_X500);
+	return __kvm_hypercall0(nr);
+}
+
+static inline long __kvm_hypercall1(unsigned long nr, unsigned long p1)
 {
 	register unsigned long __nr asm("1") = nr;
 	register unsigned long __p1 asm("2") = p1;
@@ -51,7 +56,13 @@ static inline long kvm_hypercall1(unsigned long nr, unsigned long p1)
 	return __rc;
 }
 
-static inline long kvm_hypercall2(unsigned long nr, unsigned long p1,
+static inline long kvm_hypercall1(unsigned long nr, unsigned long p1)
+{
+	diag_stat_inc(DIAG_STAT_X500);
+	return __kvm_hypercall1(nr, p1);
+}
+
+static inline long __kvm_hypercall2(unsigned long nr, unsigned long p1,
 			       unsigned long p2)
 {
 	register unsigned long __nr asm("1") = nr;
@@ -65,7 +76,14 @@ static inline long kvm_hypercall2(unsigned long nr, unsigned long p1,
 	return __rc;
 }
 
-static inline long kvm_hypercall3(unsigned long nr, unsigned long p1,
+static inline long kvm_hypercall2(unsigned long nr, unsigned long p1,
+			       unsigned long p2)
+{
+	diag_stat_inc(DIAG_STAT_X500);
+	return __kvm_hypercall2(nr, p1, p2);
+}
+
+static inline long __kvm_hypercall3(unsigned long nr, unsigned long p1,
 			       unsigned long p2, unsigned long p3)
 {
 	register unsigned long __nr asm("1") = nr;
@@ -80,8 +98,14 @@ static inline long kvm_hypercall3(unsigned long nr, unsigned long p1,
 	return __rc;
 }
 
+static inline long kvm_hypercall3(unsigned long nr, unsigned long p1,
+			       unsigned long p2, unsigned long p3)
+{
+	diag_stat_inc(DIAG_STAT_X500);
+	return __kvm_hypercall3(nr, p1, p2, p3);
+}
 
-static inline long kvm_hypercall4(unsigned long nr, unsigned long p1,
+static inline long __kvm_hypercall4(unsigned long nr, unsigned long p1,
 			       unsigned long p2, unsigned long p3,
 			       unsigned long p4)
 {
@@ -98,7 +122,15 @@ static inline long kvm_hypercall4(unsigned long nr, unsigned long p1,
 	return __rc;
 }
 
-static inline long kvm_hypercall5(unsigned long nr, unsigned long p1,
+static inline long kvm_hypercall4(unsigned long nr, unsigned long p1,
+			       unsigned long p2, unsigned long p3,
+			       unsigned long p4)
+{
+	diag_stat_inc(DIAG_STAT_X500);
+	return __kvm_hypercall4(nr, p1, p2, p3, p4);
+}
+
+static inline long __kvm_hypercall5(unsigned long nr, unsigned long p1,
 			       unsigned long p2, unsigned long p3,
 			       unsigned long p4, unsigned long p5)
 {
@@ -116,7 +148,15 @@ static inline long kvm_hypercall5(unsigned long nr, unsigned long p1,
 	return __rc;
 }
 
-static inline long kvm_hypercall6(unsigned long nr, unsigned long p1,
+static inline long kvm_hypercall5(unsigned long nr, unsigned long p1,
+			       unsigned long p2, unsigned long p3,
+			       unsigned long p4, unsigned long p5)
+{
+	diag_stat_inc(DIAG_STAT_X500);
+	return __kvm_hypercall5(nr, p1, p2, p3, p4, p5);
+}
+
+static inline long __kvm_hypercall6(unsigned long nr, unsigned long p1,
 			       unsigned long p2, unsigned long p3,
 			       unsigned long p4, unsigned long p5,
 			       unsigned long p6)
@@ -137,6 +177,15 @@ static inline long kvm_hypercall6(unsigned long nr, unsigned long p1,
 	return __rc;
 }
 
+static inline long kvm_hypercall6(unsigned long nr, unsigned long p1,
+			       unsigned long p2, unsigned long p3,
+			       unsigned long p4, unsigned long p5,
+			       unsigned long p6)
+{
+	diag_stat_inc(DIAG_STAT_X500);
+	return __kvm_hypercall6(nr, p1, p2, p3, p4, p5, p6);
+}
+
 /* kvm on s390 is always paravirtualization enabled */
 static inline int kvm_para_available(void)
 {
* Unmerged path arch/s390/kernel/cpcmd.c
* Unmerged path arch/s390/kernel/diag.c
diff --git a/arch/s390/kernel/early.c b/arch/s390/kernel/early.c
index 9b38ca1c222f..b0cf95464ecb 100644
--- a/arch/s390/kernel/early.c
+++ b/arch/s390/kernel/early.c
@@ -18,6 +18,7 @@
 #include <linux/pfn.h>
 #include <linux/uaccess.h>
 #include <linux/kernel.h>
+#include <asm/diag.h>
 #include <asm/ebcdic.h>
 #include <asm/ipl.h>
 #include <asm/lowcore.h>
@@ -349,6 +350,7 @@ static __init void detect_diag9c(void)
 	int rc;
 
 	cpu_address = stap();
+	diag_stat_inc(DIAG_STAT_X09C);
 	asm volatile(
 		"	diag	%2,0,0x9c\n"
 		"0:	la	%0,0\n"
@@ -364,6 +366,7 @@ static __init void detect_diag44(void)
 #ifdef CONFIG_64BIT
 	int rc;
 
+	diag_stat_inc(DIAG_STAT_X044);
 	asm volatile(
 		"	diag	0,0,0x44\n"
 		"0:	la	%0,0\n"
diff --git a/arch/s390/kernel/ipl.c b/arch/s390/kernel/ipl.c
index 579fadf9e63f..bf4b7a079ff5 100644
--- a/arch/s390/kernel/ipl.c
+++ b/arch/s390/kernel/ipl.c
@@ -17,6 +17,7 @@
 #include <linux/gfp.h>
 #include <linux/crash_dump.h>
 #include <linux/debug_locks.h>
+#include <asm/diag.h>
 #include <asm/ipl.h>
 #include <asm/smp.h>
 #include <asm/setup.h>
@@ -166,7 +167,7 @@ static struct ipl_parameter_block *dump_block_ccw;
 
 static struct sclp_ipl_info sclp_ipl_info;
 
-int diag308(unsigned long subcode, void *addr)
+static inline int __diag308(unsigned long subcode, void *addr)
 {
 	register unsigned long _addr asm("0") = (unsigned long) addr;
 	register unsigned long _rc asm("1") = 0;
@@ -179,6 +180,12 @@ int diag308(unsigned long subcode, void *addr)
 		: "d" (subcode) : "cc", "memory");
 	return _rc;
 }
+
+int diag308(unsigned long subcode, void *addr)
+{
+	diag_stat_inc(DIAG_STAT_X308);
+	return __diag308(subcode, addr);
+}
 EXPORT_SYMBOL_GPL(diag308);
 
 /* SYSFS */
diff --git a/arch/s390/kernel/processor.c b/arch/s390/kernel/processor.c
index 9df46defd330..f0587f024c2f 100644
--- a/arch/s390/kernel/processor.c
+++ b/arch/s390/kernel/processor.c
@@ -12,6 +12,7 @@
 #include <linux/seq_file.h>
 #include <linux/delay.h>
 #include <linux/cpu.h>
+#include <asm/diag.h>
 #include <asm/elf.h>
 #include <asm/facility.h>
 #include <asm/lowcore.h>
@@ -22,8 +23,10 @@ static DEFINE_PER_CPU(struct cpuid, cpu_id);
 
 void notrace cpu_relax(void)
 {
-	if (!smp_cpu_mtid && MACHINE_HAS_DIAG44)
+	if (!smp_cpu_mtid && MACHINE_HAS_DIAG44) {
+		diag_stat_inc(DIAG_STAT_X044);
 		asm volatile("diag 0,0,0x44");
+	}
 	barrier();
 }
 EXPORT_SYMBOL(cpu_relax);
diff --git a/arch/s390/kernel/smp.c b/arch/s390/kernel/smp.c
index 059e25724051..dec309947652 100644
--- a/arch/s390/kernel/smp.c
+++ b/arch/s390/kernel/smp.c
@@ -32,6 +32,7 @@
 #include <linux/slab.h>
 #include <linux/crash_dump.h>
 #include <asm/asm-offsets.h>
+#include <asm/diag.h>
 #include <asm/switch_to.h>
 #include <asm/facility.h>
 #include <asm/ipl.h>
@@ -436,11 +437,14 @@ void smp_yield(void)
 
 void smp_yield_cpu(int cpu)
 {
-	if (MACHINE_HAS_DIAG9C)
+	if (MACHINE_HAS_DIAG9C) {
+		diag_stat_inc(DIAG_STAT_X09C);
 		asm volatile("diag %0,0,0x9c"
 			     : : "d" (pcpu_devices[cpu].address));
-	else if (MACHINE_HAS_DIAG44)
+	} else if (MACHINE_HAS_DIAG44) {
+		diag_stat_inc(DIAG_STAT_X044);
 		asm volatile("diag 0,0,0x44");
+	}
 }
 
 /*
diff --git a/arch/s390/mm/extmem.c b/arch/s390/mm/extmem.c
index 519bba716cc3..7f994dd08166 100644
--- a/arch/s390/mm/extmem.c
+++ b/arch/s390/mm/extmem.c
@@ -18,6 +18,7 @@
 #include <linux/bootmem.h>
 #include <linux/ctype.h>
 #include <linux/ioport.h>
+#include <asm/diag.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/ebcdic.h>
@@ -115,6 +116,7 @@ dcss_set_subcodes(void)
 	ry = DCSS_FINDSEGX;
 
 	strcpy(name, "dummy");
+	diag_stat_inc(DIAG_STAT_X064);
 	asm volatile(
 		"	diag	%0,%1,0x64\n"
 		"0:	ipm	%2\n"
@@ -210,6 +212,7 @@ dcss_diag(int *func, void *parameter,
 
 #ifdef CONFIG_64BIT
 	/* 64-bit Diag x'64' new subcode, keep in 64-bit addressing mode */
+	diag_stat_inc(DIAG_STAT_X064);
 	if (*func > DCSS_SEGEXT)
 		asm volatile(
 			"	diag	%0,%1,0x64\n"
diff --git a/arch/s390/mm/fault.c b/arch/s390/mm/fault.c
index a9965a0518b2..4178f69a29dd 100644
--- a/arch/s390/mm/fault.c
+++ b/arch/s390/mm/fault.c
@@ -30,6 +30,7 @@
 #include <linux/uaccess.h>
 #include <linux/hugetlb.h>
 #include <asm/asm-offsets.h>
+#include <asm/diag.h>
 #include <asm/pgtable.h>
 #include <asm/irq.h>
 #include <asm/mmu_context.h>
@@ -506,6 +507,7 @@ int pfault_init(void)
 
 	if (pfault_disable)
 		return -1;
+	diag_stat_inc(DIAG_STAT_X258);
 	asm volatile(
 		"	diag	%1,%0,0x258\n"
 		"0:	j	2f\n"
@@ -527,6 +529,7 @@ void pfault_fini(void)
 
 	if (pfault_disable)
 		return;
+	diag_stat_inc(DIAG_STAT_X258);
 	asm volatile(
 		"	diag	%0,0,0x258\n"
 		"0:\n"
diff --git a/drivers/s390/block/dasd_diag.c b/drivers/s390/block/dasd_diag.c
index 62f8ed2793b5..c1e695c2983b 100644
--- a/drivers/s390/block/dasd_diag.c
+++ b/drivers/s390/block/dasd_diag.c
@@ -21,6 +21,7 @@
 
 #include <asm/dasd.h>
 #include <asm/debug.h>
+#include <asm/diag.h>
 #include <asm/ebcdic.h>
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -76,6 +77,7 @@ static inline int dia250(void *iob, int cmd)
 	int rc;
 
 	rc = 3;
+	diag_stat_inc(DIAG_STAT_X250);
 	asm volatile(
 		"	diag	2,%2,0x250\n"
 		"0:	ipm	%0\n"
diff --git a/drivers/s390/char/diag_ftp.c b/drivers/s390/char/diag_ftp.c
index 12db8db04cdd..a5ccbf6f0d36 100644
--- a/drivers/s390/char/diag_ftp.c
+++ b/drivers/s390/char/diag_ftp.c
@@ -15,6 +15,7 @@
 #include <linux/wait.h>
 #include <linux/string.h>
 #include <asm/ctl_reg.h>
+#include <asm/diag.h>
 
 #include "hmcdrv_ftp.h"
 #include "diag_ftp.h"
@@ -102,6 +103,7 @@ static int diag_ftp_2c4(struct diag_ftp_ldfpl *fpl,
 {
 	int rc;
 
+	diag_stat_inc(DIAG_STAT_X2C4);
 	asm volatile(
 		"	diag	%[addr],%[cmd],0x2c4\n"
 		"0:	j	2f\n"
diff --git a/drivers/s390/virtio/virtio_ccw.c b/drivers/s390/virtio/virtio_ccw.c
index bc68e3e7e73b..f4a9cd74c155 100644
--- a/drivers/s390/virtio/virtio_ccw.c
+++ b/drivers/s390/virtio/virtio_ccw.c
@@ -28,6 +28,7 @@
 #include <linux/io.h>
 #include <linux/kvm_para.h>
 #include <linux/notifier.h>
+#include <asm/diag.h>
 #include <asm/setup.h>
 #include <asm/irq.h>
 #include <asm/cio.h>
@@ -386,9 +387,9 @@ static void virtio_ccw_drop_indicator(struct virtio_ccw_device *vcdev,
 	ccw_device_dma_free(vcdev->cdev, thinint_area, sizeof(*thinint_area));
 }
 
-static inline long do_kvm_notify(struct subchannel_id schid,
-				 unsigned long queue_index,
-				 long cookie)
+static inline long __do_kvm_notify(struct subchannel_id schid,
+				   unsigned long queue_index,
+				   long cookie)
 {
 	register unsigned long __nr asm("1") = KVM_S390_VIRTIO_CCW_NOTIFY;
 	register struct subchannel_id __schid asm("2") = schid;
@@ -403,6 +404,14 @@ static inline long do_kvm_notify(struct subchannel_id schid,
 	return __rc;
 }
 
+static inline long do_kvm_notify(struct subchannel_id schid,
+				 unsigned long queue_index,
+				 long cookie)
+{
+	diag_stat_inc(DIAG_STAT_X500);
+	return __do_kvm_notify(schid, queue_index, cookie);
+}
+
 static bool virtio_ccw_kvm_notify(struct virtqueue *vq)
 {
 	struct virtio_ccw_vq_info *info = vq->priv;
diff --git a/drivers/watchdog/diag288_wdt.c b/drivers/watchdog/diag288_wdt.c
index 8fa16aa41775..861d3d3133f8 100644
--- a/drivers/watchdog/diag288_wdt.c
+++ b/drivers/watchdog/diag288_wdt.c
@@ -29,6 +29,7 @@
 #include <linux/watchdog.h>
 #include <linux/suspend.h>
 #include <asm/ebcdic.h>
+#include <asm/diag.h>
 #include <linux/io.h>
 #include <linux/uaccess.h>
 
@@ -94,12 +95,14 @@ static int __diag288(unsigned int func, unsigned int timeout,
 static int __diag288_vm(unsigned int  func, unsigned int timeout,
 			char *cmd, size_t len)
 {
+	diag_stat_inc(DIAG_STAT_X288);
 	return __diag288(func, timeout, virt_to_phys(cmd), len);
 }
 
 static int __diag288_lpar(unsigned int func, unsigned int timeout,
 			  unsigned long action)
 {
+	diag_stat_inc(DIAG_STAT_X288);
 	return __diag288(func, timeout, action, 0);
 }
 
@@ -151,6 +154,7 @@ static int wdt_stop(struct watchdog_device *dev)
 {
 	int ret;
 
+	diag_stat_inc(DIAG_STAT_X288);
 	ret = __diag288(WDT_FUNC_CANCEL, 0, 0, 0);
 
 	clear_bit(DIAG_WDOG_BUSY, &wdt_status);
