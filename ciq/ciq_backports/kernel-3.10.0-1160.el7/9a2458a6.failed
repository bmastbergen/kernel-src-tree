mm: mremap: validate input before taking lock

jira LE-1907
cve CVE-2020-10757
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Rasmus Villemoes <linux@rasmusvillemoes.dk>
commit 9a2458a633d4b3c9e0eae506da40cf44dc075314
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/9a2458a6.failed

This patch is very similar to commit 84d96d897671 ("mm: madvise:
complete input validation before taking lock"): perform some basic
validation of the input to mremap() before taking the
&current->mm->mmap_sem lock.

This also makes the MREMAP_FIXED => MREMAP_MAYMOVE dependency slightly
more explicit.

	Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
	Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
	Cc: David Rientjes <rientjes@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9a2458a633d4b3c9e0eae506da40cf44dc075314)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/mremap.c
diff --cc mm/mremap.c
index 793a0391c137,457d34ef3bf2..000000000000
--- a/mm/mremap.c
+++ b/mm/mremap.c
@@@ -519,17 -455,15 +519,18 @@@ SYSCALL_DEFINE5(mremap, unsigned long, 
  	unsigned long ret = -EINVAL;
  	unsigned long charged = 0;
  	bool locked = false;
 +	struct vm_userfaultfd_ctx uf = NULL_VM_UFFD_CTX;
 +	LIST_HEAD(uf_unmap_early);
 +	LIST_HEAD(uf_unmap);
  
- 	down_write(&current->mm->mmap_sem);
- 
  	if (flags & ~(MREMAP_FIXED | MREMAP_MAYMOVE))
- 		goto out;
+ 		return ret;
+ 
+ 	if (flags & MREMAP_FIXED && !(flags & MREMAP_MAYMOVE))
+ 		return ret;
  
  	if (addr & ~PAGE_MASK)
- 		goto out;
+ 		return ret;
  
  	old_len = PAGE_ALIGN(old_len);
  	new_len = PAGE_ALIGN(new_len);
@@@ -540,12 -474,13 +541,19 @@@
  	 * a zero new-len is nonsensical.
  	 */
  	if (!new_len)
- 		goto out;
+ 		return ret;
+ 
+ 	down_write(&current->mm->mmap_sem);
  
  	if (flags & MREMAP_FIXED) {
++<<<<<<< HEAD
 +		if (flags & MREMAP_MAYMOVE)
 +			ret = mremap_to(addr, old_len, new_addr, new_len,
 +					&locked, &uf, &uf_unmap_early, &uf_unmap);
++=======
+ 		ret = mremap_to(addr, old_len, new_addr, new_len,
+ 				&locked);
++>>>>>>> 9a2458a633d4 (mm: mremap: validate input before taking lock)
  		goto out;
  	}
  
* Unmerged path mm/mremap.c
