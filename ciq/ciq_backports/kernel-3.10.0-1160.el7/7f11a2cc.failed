x86/Hyper-V: Free hv_panic_page when fail to register kmsg dump

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Tianyu Lan <Tianyu.Lan@microsoft.com>
commit 7f11a2cc10a4ae3a70e2c73361f4a9a33503539b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/7f11a2cc.failed

If kmsg_dump_register() fails, hv_panic_page will not be used
anywhere.  So free and reset it.

Fixes: 81b18bce48af ("Drivers: HV: Send one page worth of kmsg dump over Hyper-V during panic")
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
	Signed-off-by: Tianyu Lan <Tianyu.Lan@microsoft.com>
Link: https://lore.kernel.org/r/20200406155331.2105-3-Tianyu.Lan@microsoft.com
	Signed-off-by: Wei Liu <wei.liu@kernel.org>
(cherry picked from commit 7f11a2cc10a4ae3a70e2c73361f4a9a33503539b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/vmbus_drv.c
diff --cc drivers/hv/vmbus_drv.c
index 52302e715e84,00a511f15926..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -1238,11 -1367,47 +1238,44 @@@ static int vmbus_bus_init(void
  	 * Only register if the crash MSRs are available
  	 */
  	if (ms_hyperv.misc_features & HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE) {
++<<<<<<< HEAD
++=======
+ 		u64 hyperv_crash_ctl;
+ 		/*
+ 		 * Sysctl registration is not fatal, since by default
+ 		 * reporting is enabled.
+ 		 */
+ 		hv_ctl_table_hdr = register_sysctl_table(hv_root_table);
+ 		if (!hv_ctl_table_hdr)
+ 			pr_err("Hyper-V: sysctl table register error");
+ 
+ 		/*
+ 		 * Register for panic kmsg callback only if the right
+ 		 * capability is supported by the hypervisor.
+ 		 */
+ 		hv_get_crash_ctl(hyperv_crash_ctl);
+ 		if (hyperv_crash_ctl & HV_CRASH_CTL_CRASH_NOTIFY_MSG) {
+ 			hv_panic_page = (void *)hv_alloc_hyperv_zeroed_page();
+ 			if (hv_panic_page) {
+ 				ret = kmsg_dump_register(&hv_kmsg_dumper);
+ 				if (ret) {
+ 					pr_err("Hyper-V: kmsg dump register "
+ 						"error 0x%x\n", ret);
+ 					hv_free_hyperv_page(
+ 					    (unsigned long)hv_panic_page);
+ 					hv_panic_page = NULL;
+ 				}
+ 			} else
+ 				pr_err("Hyper-V: panic message page memory "
+ 					"allocation failed");
+ 		}
+ 
++>>>>>>> 7f11a2cc10a4 (x86/Hyper-V: Free hv_panic_page when fail to register kmsg dump)
  		register_die_notifier(&hyperv_die_block);
 +		atomic_notifier_chain_register(&panic_notifier_list,
 +					       &hyperv_panic_block);
  	}
  
 -	/*
 -	 * Always register the panic notifier because we need to unload
 -	 * the VMbus channel connection to prevent any VMbus
 -	 * activity after the VM panics.
 -	 */
 -	atomic_notifier_chain_register(&panic_notifier_list,
 -			       &hyperv_panic_block);
 -
  	vmbus_request_offers();
  
  	return 0;
@@@ -1260,7 -1420,8 +1293,12 @@@ err_alloc
  	hv_remove_vmbus_irq();
  
  	bus_unregister(&hv_bus);
++<<<<<<< HEAD
 +
++=======
+ 	unregister_sysctl_table(hv_ctl_table_hdr);
+ 	hv_ctl_table_hdr = NULL;
++>>>>>>> 7f11a2cc10a4 (x86/Hyper-V: Free hv_panic_page when fail to register kmsg dump)
  	return ret;
  }
  
* Unmerged path drivers/hv/vmbus_drv.c
