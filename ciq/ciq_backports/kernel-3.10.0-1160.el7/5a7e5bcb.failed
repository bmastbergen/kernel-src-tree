net/mlx5e: Extend tc flow struct with reference counter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Vlad Buslov <vladbu@mellanox.com>
commit 5a7e5bcb663d46d9cfe7d86d5a8ede91338275cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/5a7e5bcb.failed

With new classifier type that doesn't require rtnl lock, following
invariant holds:
 - Filter with specified cookie created only once.
 - Filter with specified cookie deleted only once.
 - Stats updates can be performed in parallel to each other.

Extend tc flow with rcu and reference counter. To protect from concurrent
delete, get reference to tc flow when:
 - Reading flow stats.
 - Accessing flow in neigh update handler.
 - Accessing flow in neigh update used value handler.

Only free flow when reference counter reached zero. Modify flow cleanup to
account for flows that could be not fully initialized by checking if flow
is actually in the list of corresponding mod_hdr, hairpin and encap
entries. Don't cleanup flow directly in case of error to allow concurrent
neigh update (neigh update will be modified to always take reference to
flow when using it).

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 5a7e5bcb663d46d9cfe7d86d5a8ede91338275cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 326a1792e131,e2b87f723819..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -38,7 -38,7 +38,11 @@@
  #include <linux/mlx5/fs.h>
  #include <linux/mlx5/device.h>
  #include <linux/rhashtable.h>
++<<<<<<< HEAD
 +#include <net/switchdev.h>
++=======
+ #include <linux/refcount.h>
++>>>>>>> 5a7e5bcb663d (net/mlx5e: Extend tc flow struct with reference counter)
  #include <net/tc_act/tc_mirred.h>
  #include <net/tc_act/tc_vlan.h>
  #include <net/tc_act/tc_tunnel_key.h>
@@@ -117,6 -120,8 +121,11 @@@ struct mlx5e_tc_flow 
  	struct list_head	mod_hdr; /* flows sharing the same mod hdr ID */
  	struct list_head	hairpin; /* flows sharing the same hairpin */
  	struct list_head	peer;    /* flows with peer flow */
++<<<<<<< HEAD
++=======
+ 	struct list_head	unready; /* flows not ready to be offloaded (e.g due to missing route) */
+ 	refcount_t		refcnt;
++>>>>>>> 5a7e5bcb663d (net/mlx5e: Extend tc flow struct with reference counter)
  	union {
  		struct mlx5_esw_flow_attr esw_attr[0];
  		struct mlx5_nic_flow_attr nic_attr[0];
@@@ -718,19 -752,20 +754,18 @@@ mlx5e_tc_add_nic_flow(struct mlx5e_pri
  	struct mlx5_flow_destination dest[2] = {};
  	struct mlx5_flow_act flow_act = {
  		.action = attr->action,
 +		.flow_tag = attr->flow_tag,
  		.reformat_id = 0,
 -		.flags    = FLOW_ACT_NO_APPEND,
 +		.flags    = FLOW_ACT_HAS_TAG | FLOW_ACT_NO_APPEND,
  	};
  	struct mlx5_fc *counter = NULL;
- 	bool table_created = false;
  	int err, dest_ix = 0;
  
 -	flow_context->flags |= FLOW_CONTEXT_HAS_TAG;
 -	flow_context->flow_tag = attr->flow_tag;
 -
  	if (flow->flags & MLX5E_TC_FLOW_HAIRPIN) {
  		err = mlx5e_hairpin_flow_add(priv, flow, parse_attr, extack);
- 		if (err) {
- 			goto err_add_hairpin_flow;
- 		}
+ 		if (err)
+ 			return err;
+ 
  		if (flow->flags & MLX5E_TC_FLOW_HAIRPIN_RSS) {
  			dest[dest_ix].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
  			dest[dest_ix].ft = attr->hairpin_ft;
@@@ -832,10 -845,11 +845,11 @@@ static void mlx5e_tc_del_nic_flow(struc
  	struct mlx5_fc *counter = NULL;
  
  	counter = attr->counter;
- 	mlx5_del_flow_rules(flow->rule[0]);
+ 	if (!IS_ERR_OR_NULL(flow->rule[0]))
+ 		mlx5_del_flow_rules(flow->rule[0]);
  	mlx5_fc_destroy(priv->mdev, counter);
  
 -	if (!mlx5e_tc_num_filters(priv, MLX5E_TC_NIC_OFFLOAD)  && priv->fs.tc.t) {
 +	if (!mlx5e_tc_num_filters(priv) && priv->fs.tc.t) {
  		mlx5_destroy_flow_table(priv->fs.tc.t);
  		priv->fs.tc.t = NULL;
  	}
@@@ -1017,29 -1047,25 +1027,12 @@@ mlx5e_tc_add_fdb_flow(struct mlx5e_pri
  		flow->rule[0] = mlx5e_tc_offload_fdb_rules(esw, flow, &parse_attr->spec, attr);
  	}
  
- 	if (IS_ERR(flow->rule[0])) {
- 		err = PTR_ERR(flow->rule[0]);
- 		goto err_add_rule;
- 	}
+ 	if (IS_ERR(flow->rule[0]))
+ 		return PTR_ERR(flow->rule[0]);
  
  	return 0;
- 
- err_add_rule:
- 	mlx5_fc_destroy(attr->counter_dev, counter);
- err_create_counter:
- 	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
- 		mlx5e_detach_mod_hdr(priv, flow);
- err_mod_hdr:
- 	mlx5_eswitch_del_vlan_action(esw, attr);
- err_add_vlan:
- 	for (out_index = 0; out_index < MLX5_MAX_FLOW_FWD_VPORTS; out_index++)
- 		if (attr->dests[out_index].flags & MLX5_ESW_DEST_ENCAP)
- 			mlx5e_detach_encap(priv, flow, out_index);
- err_attach_encap:
- err_max_prio_chain:
- 	return err;
  }
  
 -static bool mlx5_flow_has_geneve_opt(struct mlx5e_tc_flow *flow)
 -{
 -	struct mlx5_flow_spec *spec = &flow->esw_attr->parse_attr->spec;
 -	void *headers_v = MLX5_ADDR_OF(fte_match_param,
 -				       spec->match_value,
 -				       misc_parameters_3);
 -	u32 geneve_tlv_opt_0_data = MLX5_GET(fte_match_set_misc3,
 -					     headers_v,
 -					     geneve_tlv_option_0_data);
 -
 -	return !!geneve_tlv_opt_0_data;
 -}
 -
  static void mlx5e_tc_del_fdb_flow(struct mlx5e_priv *priv,
  				  struct mlx5e_tc_flow *flow)
  {
@@@ -1199,16 -1246,20 +1204,20 @@@ void mlx5e_tc_update_neigh_used_value(s
  		return;
  
  	list_for_each_entry(e, &nhe->encap_list, encap_list) {
- 		struct encap_flow_item *efi;
+ 		struct encap_flow_item *efi, *tmp;
  		if (!(e->flags & MLX5_ENCAP_ENTRY_VALID))
  			continue;
- 		list_for_each_entry(efi, &e->flows, list) {
+ 		list_for_each_entry_safe(efi, tmp, &e->flows, list) {
  			flow = container_of(efi, struct mlx5e_tc_flow,
  					    encaps[efi->index]);
+ 			if (IS_ERR(mlx5e_flow_get(flow)))
+ 				continue;
+ 
  			if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
  				counter = mlx5e_tc_get_counter(flow);
 -				mlx5_fc_query_cached(counter, &bytes, &packets, &lastuse);
 +				lastuse = mlx5_fc_query_lastuse(counter);
  				if (time_after((unsigned long)lastuse, nhe->reported_lastuse)) {
+ 					mlx5e_flow_put(netdev_priv(e->out_dev), flow);
  					neigh_used = true;
  					break;
  				}
@@@ -3089,32 -3218,25 +3109,31 @@@ __mlx5e_add_fdb_flow(struct mlx5e_priv 
  	if (err)
  		goto err_free;
  
 -	err = mlx5e_tc_add_fdb_flow(priv, flow, extack);
 -	if (err) {
 -		if (!(err == -ENETUNREACH && mlx5_lag_is_multipath(in_mdev)))
 -			goto err_free;
 +	flow->esw_attr->in_rep = in_rep;
 +	flow->esw_attr->in_mdev = in_mdev;
  
 -		add_unready_flow(flow);
 -	}
 +	if (MLX5_CAP_ESW(esw->dev, counter_eswitch_affinity) ==
 +	    MLX5_COUNTER_SOURCE_ESWITCH)
 +		flow->esw_attr->counter_dev = in_mdev;
 +	else
 +		flow->esw_attr->counter_dev = priv->mdev;
  
 -	return flow;
 +	err = mlx5e_tc_add_fdb_flow(priv, parse_attr, flow, extack);
 +	if (err)
 +		goto err_free;
 +
 +	*__flow = flow;
 +
 +	return 0;
  
  err_free:
- 	kfree(flow);
- 	kvfree(parse_attr);
+ 	mlx5e_flow_put(priv, flow);
  out:
 -	return ERR_PTR(err);
 +	return err;
  }
  
 -static int mlx5e_tc_add_fdb_peer_flow(struct flow_cls_offload *f,
 -				      struct mlx5e_tc_flow *flow,
 -				      u16 flow_flags)
 +static int mlx5e_tc_add_fdb_peer_flow(struct tc_cls_flower_offload *f,
 +				      struct mlx5e_tc_flow *flow)
  {
  	struct mlx5e_priv *priv = flow->priv, *peer_priv;
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch, *peer_esw;
@@@ -3343,23 -3466,32 +3359,43 @@@ int mlx5e_stats_flower(struct net_devic
  	struct mlx5_eswitch *peer_esw;
  	struct mlx5e_tc_flow *flow;
  	struct mlx5_fc *counter;
++<<<<<<< HEAD
 +	u64 bytes;
 +	u64 packets;
 +	u64 lastuse;
++=======
+ 	u64 lastuse = 0;
+ 	u64 packets = 0;
+ 	u64 bytes = 0;
+ 	int err = 0;
++>>>>>>> 5a7e5bcb663d (net/mlx5e: Extend tc flow struct with reference counter)
  
- 	flow = rhashtable_lookup_fast(tc_ht, &f->cookie, tc_ht_params);
- 	if (!flow || !same_flow_direction(flow, flags))
- 		return -EINVAL;
+ 	flow = mlx5e_flow_get(rhashtable_lookup_fast(tc_ht, &f->cookie,
+ 						     tc_ht_params));
+ 	if (IS_ERR(flow))
+ 		return PTR_ERR(flow);
  
+ 	if (!same_flow_direction(flow, flags)) {
+ 		err = -EINVAL;
+ 		goto errout;
+ 	}
+ 
++<<<<<<< HEAD
 +	if (!(flow->flags & MLX5E_TC_FLOW_OFFLOADED))
 +		return 0;
++=======
+ 	if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
+ 		counter = mlx5e_tc_get_counter(flow);
+ 		if (!counter)
+ 			goto errout;
++>>>>>>> 5a7e5bcb663d (net/mlx5e: Extend tc flow struct with reference counter)
  
 -		mlx5_fc_query_cached(counter, &bytes, &packets, &lastuse);
 -	}
 +	counter = mlx5e_tc_get_counter(flow);
 +	if (!counter)
 +		return 0;
 +
 +	mlx5_fc_query_cached(counter, &bytes, &packets, &lastuse);
  
 -	/* Under multipath it's possible for one rule to be currently
 -	 * un-offloaded while the other rule is offloaded.
 -	 */
  	peer_esw = mlx5_devcom_get_peer_data(devcom, MLX5_DEVCOM_ESW_OFFLOADS);
  	if (!peer_esw)
  		goto out;
@@@ -3378,12 -3512,13 +3414,19 @@@
  		lastuse = max_t(u64, lastuse, lastuse2);
  	}
  
 -no_peer_counter:
  	mlx5_devcom_release_peer_data(devcom, MLX5_DEVCOM_ESW_OFFLOADS);
 +
  out:
++<<<<<<< HEAD
 +	tcf_exts_stats_update(f->exts, bytes, packets, lastuse);
 +
 +	return 0;
++=======
+ 	flow_stats_update(&f->stats, bytes, packets, lastuse);
+ errout:
+ 	mlx5e_flow_put(priv, flow);
+ 	return err;
++>>>>>>> 5a7e5bcb663d (net/mlx5e: Extend tc flow struct with reference counter)
  }
  
  static void mlx5e_tc_hairpin_update_dead_peer(struct mlx5e_priv *priv,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
