vfio-pci: Fault mmaps to enable vma tracking

jira LE-1907
cve CVE-2020-12888
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Alex Williamson <alex.williamson@redhat.com>
commit 11c4cd07ba111a09f49625f9e4c851d83daf0a22
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/11c4cd07.failed

Rather than calling remap_pfn_range() when a region is mmap'd, setup
a vm_ops handler to support dynamic faulting of the range on access.
This allows us to manage a list of vmas actively mapping the area that
we can later use to invalidate those mappings.  The open callback
invalidates the vma range so that all tracking is inserted in the
fault handler and removed in the close handler.

	Reviewed-by: Peter Xu <peterx@redhat.com>
	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
(cherry picked from commit 11c4cd07ba111a09f49625f9e4c851d83daf0a22)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vfio/pci/vfio_pci.c
#	drivers/vfio/pci/vfio_pci_private.h
diff --cc drivers/vfio/pci/vfio_pci.c
index 2b338a10c308,66a545a01f8f..000000000000
--- a/drivers/vfio/pci/vfio_pci.c
+++ b/drivers/vfio/pci/vfio_pci.c
@@@ -1222,12 -1676,33 +1292,19 @@@ static int vfio_pci_probe(struct pci_de
  	vdev->irq_type = VFIO_PCI_NUM_IRQS;
  	mutex_init(&vdev->igate);
  	spin_lock_init(&vdev->irqlock);
++<<<<<<< HEAD
++=======
+ 	mutex_init(&vdev->ioeventfds_lock);
+ 	INIT_LIST_HEAD(&vdev->ioeventfds_list);
+ 	mutex_init(&vdev->vma_lock);
+ 	INIT_LIST_HEAD(&vdev->vma_list);
++>>>>>>> 11c4cd07ba11 (vfio-pci: Fault mmaps to enable vma tracking)
  
  	ret = vfio_add_group_dev(&pdev->dev, &vfio_pci_ops, vdev);
 -	if (ret)
 -		goto out_free;
 -
 -	ret = vfio_pci_reflck_attach(vdev);
 -	if (ret)
 -		goto out_del_group_dev;
 -
 -	if (pdev->is_physfn) {
 -		vdev->vf_token = kzalloc(sizeof(*vdev->vf_token), GFP_KERNEL);
 -		if (!vdev->vf_token) {
 -			ret = -ENOMEM;
 -			goto out_reflck;
 -		}
 -
 -		mutex_init(&vdev->vf_token->lock);
 -		uuid_gen(&vdev->vf_token->uuid);
 -
 -		vdev->nb.notifier_call = vfio_pci_bus_notifier;
 -		ret = bus_register_notifier(&pci_bus_type, &vdev->nb);
 -		if (ret)
 -			goto out_vf_token;
 +	if (ret) {
 +		vfio_iommu_group_put(group, &pdev->dev);
 +		kfree(vdev);
 +		return ret;
  	}
  
  	if (vfio_pci_is_vga(pdev)) {
diff --cc drivers/vfio/pci/vfio_pci_private.h
index 24980778532d,9b25f9f6ce1d..000000000000
--- a/drivers/vfio/pci/vfio_pci_private.h
+++ b/drivers/vfio/pci/vfio_pci_private.h
@@@ -63,10 -81,26 +63,29 @@@ struct vfio_pci_dummy_resource 
  	struct list_head	res_next;
  };
  
++<<<<<<< HEAD
++=======
+ struct vfio_pci_reflck {
+ 	struct kref		kref;
+ 	struct mutex		lock;
+ };
+ 
+ struct vfio_pci_vf_token {
+ 	struct mutex		lock;
+ 	uuid_t			uuid;
+ 	int			users;
+ };
+ 
+ struct vfio_pci_mmap_vma {
+ 	struct vm_area_struct	*vma;
+ 	struct list_head	vma_next;
+ };
+ 
++>>>>>>> 11c4cd07ba11 (vfio-pci: Fault mmaps to enable vma tracking)
  struct vfio_pci_device {
  	struct pci_dev		*pdev;
 -	void __iomem		*barmap[PCI_STD_NUM_BARS];
 -	bool			bar_mmap_supported[PCI_STD_NUM_BARS];
 +	void __iomem		*barmap[PCI_STD_RESOURCE_END + 1];
 +	bool			bar_mmap_supported[PCI_STD_RESOURCE_END + 1];
  	u8			*pci_config_map;
  	u8			*vconfig;
  	struct perm_bits	*msi_perm;
@@@ -96,6 -132,13 +115,15 @@@
  	struct eventfd_ctx	*err_trigger;
  	struct eventfd_ctx	*req_trigger;
  	struct list_head	dummy_resources_list;
++<<<<<<< HEAD
++=======
+ 	struct mutex		ioeventfds_lock;
+ 	struct list_head	ioeventfds_list;
+ 	struct vfio_pci_vf_token	*vf_token;
+ 	struct notifier_block	nb;
+ 	struct mutex		vma_lock;
+ 	struct list_head	vma_list;
++>>>>>>> 11c4cd07ba11 (vfio-pci: Fault mmaps to enable vma tracking)
  };
  
  #define is_intx(vdev) (vdev->irq_type == VFIO_PCI_INTX_IRQ_INDEX)
* Unmerged path drivers/vfio/pci/vfio_pci.c
* Unmerged path drivers/vfio/pci/vfio_pci_private.h
