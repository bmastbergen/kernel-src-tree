mm: soft-offline: dissolve free hugepage if soft-offlined

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
commit d4a3a60b37bf4609f9b17961a0db2f6e7ec746cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/d4a3a60b.failed

Now we have code to rescue most of healthy pages from a hwpoisoned
hugepage.  So let's apply it to soft_offline_free_page too.

Link: http://lkml.kernel.org/r/1496305019-5493-6-git-send-email-n-horiguchi@ah.jp.nec.com
	Signed-off-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit d4a3a60b37bf4609f9b17961a0db2f6e7ec746cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory-failure.c
diff --cc mm/memory-failure.c
index 989a662e69f7,8a7b39486b9d..000000000000
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@@ -1739,7 -1661,45 +1739,49 @@@ static int soft_offline_huge_page(struc
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int __soft_offline_page(struct page *page, int flags);
++=======
+ static int soft_offline_in_use_page(struct page *page, int flags)
+ {
+ 	int ret;
+ 	struct page *hpage = compound_head(page);
+ 
+ 	if (!PageHuge(page) && PageTransHuge(hpage)) {
+ 		lock_page(hpage);
+ 		if (!PageAnon(hpage) || unlikely(split_huge_page(hpage))) {
+ 			unlock_page(hpage);
+ 			if (!PageAnon(hpage))
+ 				pr_info("soft offline: %#lx: non anonymous thp\n", page_to_pfn(page));
+ 			else
+ 				pr_info("soft offline: %#lx: thp split failed\n", page_to_pfn(page));
+ 			put_hwpoison_page(hpage);
+ 			return -EBUSY;
+ 		}
+ 		unlock_page(hpage);
+ 		get_hwpoison_page(page);
+ 		put_hwpoison_page(hpage);
+ 	}
+ 
+ 	if (PageHuge(page))
+ 		ret = soft_offline_huge_page(page, flags);
+ 	else
+ 		ret = __soft_offline_page(page, flags);
+ 
+ 	return ret;
+ }
+ 
+ static void soft_offline_free_page(struct page *page)
+ {
+ 	struct page *head = compound_head(page);
+ 
+ 	if (!TestSetPageHWPoison(head)) {
+ 		num_poisoned_pages_inc();
+ 		if (PageHuge(head))
+ 			dissolve_free_huge_page(page);
+ 	}
+ }
++>>>>>>> d4a3a60b37bf (mm: soft-offline: dissolve free hugepage if soft-offlined)
  
  /**
   * soft_offline_page - Soft offline a page.
* Unmerged path mm/memory-failure.c
