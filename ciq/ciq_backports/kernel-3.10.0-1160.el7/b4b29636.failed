KVM: X86: Fix kvm_bitmap_or_dest_vcpus() to use irq shorthand

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Peter Xu <peterx@redhat.com>
commit b4b2963616bbd91ebb33148522552e1135de56ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/b4b29636.failed

The 3rd parameter of kvm_apic_match_dest() is the irq shorthand,
rather than the irq delivery mode.

Fixes: 7ee30bc132c6 ("KVM: x86: deliver KVM IOAPIC scan request to target vCPUs")
	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Peter Xu <peterx@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit b4b2963616bbd91ebb33148522552e1135de56ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/lapic.c
diff --cc arch/x86/kvm/lapic.c
index 27da7d39f701,1eabe58bb6d5..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -1061,6 -1117,50 +1061,53 @@@ static int __apic_accept_irq(struct kvm
  	return result;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * This routine identifies the destination vcpus mask meant to receive the
+  * IOAPIC interrupts. It either uses kvm_apic_map_get_dest_lapic() to find
+  * out the destination vcpus array and set the bitmap or it traverses to
+  * each available vcpu to identify the same.
+  */
+ void kvm_bitmap_or_dest_vcpus(struct kvm *kvm, struct kvm_lapic_irq *irq,
+ 			      unsigned long *vcpu_bitmap)
+ {
+ 	struct kvm_lapic **dest_vcpu = NULL;
+ 	struct kvm_lapic *src = NULL;
+ 	struct kvm_apic_map *map;
+ 	struct kvm_vcpu *vcpu;
+ 	unsigned long bitmap;
+ 	int i, vcpu_idx;
+ 	bool ret;
+ 
+ 	rcu_read_lock();
+ 	map = rcu_dereference(kvm->arch.apic_map);
+ 
+ 	ret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dest_vcpu,
+ 					  &bitmap);
+ 	if (ret) {
+ 		for_each_set_bit(i, &bitmap, 16) {
+ 			if (!dest_vcpu[i])
+ 				continue;
+ 			vcpu_idx = dest_vcpu[i]->vcpu->vcpu_idx;
+ 			__set_bit(vcpu_idx, vcpu_bitmap);
+ 		}
+ 	} else {
+ 		kvm_for_each_vcpu(i, vcpu, kvm) {
+ 			if (!kvm_apic_present(vcpu))
+ 				continue;
+ 			if (!kvm_apic_match_dest(vcpu, NULL,
+ 						 irq->shorthand,
+ 						 irq->dest_id,
+ 						 irq->dest_mode))
+ 				continue;
+ 			__set_bit(i, vcpu_bitmap);
+ 		}
+ 	}
+ 	rcu_read_unlock();
+ }
+ 
++>>>>>>> b4b2963616bb (KVM: X86: Fix kvm_bitmap_or_dest_vcpus() to use irq shorthand)
  int kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)
  {
  	return vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;
* Unmerged path arch/x86/kvm/lapic.c
