x86/cpu: Add a steppings field to struct x86_cpu_id

jira LE-1907
cve CVE-2020-0543
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
commit-author Mark Gross <mgross@linux.intel.com>
commit e9d7144597b10ff13ff2264c059f7d4a7fbc89ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/e9d71445.failed

Intel uses the same family/model for several CPUs. Sometimes the
stepping must be checked to tell them apart.

On x86 there can be at most 16 steppings. Add a steppings bitmask to
x86_cpu_id and a X86_MATCH_VENDOR_FAMILY_MODEL_STEPPING_FEATURE macro
and support for matching against family/model/stepping.

 [ bp: Massage. ]

	Signed-off-by: Mark Gross <mgross@linux.intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Tony Luck <tony.luck@intel.com>
	Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
(cherry picked from commit e9d7144597b10ff13ff2264c059f7d4a7fbc89ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/cpu_device_id.h
#	include/linux/mod_devicetable.h
diff --cc arch/x86/include/asm/cpu_device_id.h
index 0d72cb7c4c6e,10426cd56dca..000000000000
--- a/arch/x86/include/asm/cpu_device_id.h
+++ b/arch/x86/include/asm/cpu_device_id.h
@@@ -4,11 -5,160 +4,158 @@@
  /*
   * Declare drivers belonging to specific x86 CPUs
   * Similar in spirit to pci_device_id and related PCI functions
 - *
 - * The wildcard initializers are in mod_devicetable.h because
 - * file2alias needs them. Sigh.
   */
 +
  #include <linux/mod_devicetable.h>
 -/* Get the INTEL_FAM* model defines */
 -#include <asm/intel-family.h>
 -/* And the X86_VENDOR_* ones */
 -#include <asm/processor.h>
  
++<<<<<<< HEAD
 +extern const struct x86_cpu_id *x86_match_cpu(const struct x86_cpu_id *match);
++=======
+ /* Centaur FAM6 models */
+ #define X86_CENTAUR_FAM6_C7_A		0xa
+ #define X86_CENTAUR_FAM6_C7_D		0xd
+ #define X86_CENTAUR_FAM6_NANO		0xf
+ 
+ #define X86_STEPPINGS(mins, maxs)    GENMASK(maxs, mins)
+ /**
+  * X86_MATCH_VENDOR_FAM_MODEL_STEPPINGS_FEATURE - Base macro for CPU matching
+  * @_vendor:	The vendor name, e.g. INTEL, AMD, HYGON, ..., ANY
+  *		The name is expanded to X86_VENDOR_@_vendor
+  * @_family:	The family number or X86_FAMILY_ANY
+  * @_model:	The model number, model constant or X86_MODEL_ANY
+  * @_steppings:	Bitmask for steppings, stepping constant or X86_STEPPING_ANY
+  * @_feature:	A X86_FEATURE bit or X86_FEATURE_ANY
+  * @_data:	Driver specific data or NULL. The internal storage
+  *		format is unsigned long. The supplied value, pointer
+  *		etc. is casted to unsigned long internally.
+  *
+  * Use only if you need all selectors. Otherwise use one of the shorter
+  * macros of the X86_MATCH_* family. If there is no matching shorthand
+  * macro, consider to add one. If you really need to wrap one of the macros
+  * into another macro at the usage site for good reasons, then please
+  * start this local macro with X86_MATCH to allow easy grepping.
+  */
+ #define X86_MATCH_VENDOR_FAM_MODEL_STEPPINGS_FEATURE(_vendor, _family, _model, \
+ 						    _steppings, _feature, _data) { \
+ 	.vendor		= X86_VENDOR_##_vendor,				\
+ 	.family		= _family,					\
+ 	.model		= _model,					\
+ 	.steppings	= _steppings,					\
+ 	.feature	= _feature,					\
+ 	.driver_data	= (unsigned long) _data				\
+ }
+ 
+ /**
+  * X86_MATCH_VENDOR_FAM_MODEL_FEATURE - Macro for CPU matching
+  * @_vendor:	The vendor name, e.g. INTEL, AMD, HYGON, ..., ANY
+  *		The name is expanded to X86_VENDOR_@_vendor
+  * @_family:	The family number or X86_FAMILY_ANY
+  * @_model:	The model number, model constant or X86_MODEL_ANY
+  * @_feature:	A X86_FEATURE bit or X86_FEATURE_ANY
+  * @_data:	Driver specific data or NULL. The internal storage
+  *		format is unsigned long. The supplied value, pointer
+  *		etc. is casted to unsigned long internally.
+  *
+  * The steppings arguments of X86_MATCH_VENDOR_FAM_MODEL_STEPPINGS_FEATURE() is
+  * set to wildcards.
+  */
+ #define X86_MATCH_VENDOR_FAM_MODEL_FEATURE(vendor, family, model, feature, data) \
+ 	X86_MATCH_VENDOR_FAM_MODEL_STEPPINGS_FEATURE(vendor, family, model, \
+ 						X86_STEPPING_ANY, feature, data)
+ 
+ /**
+  * X86_MATCH_VENDOR_FAM_FEATURE - Macro for matching vendor, family and CPU feature
+  * @vendor:	The vendor name, e.g. INTEL, AMD, HYGON, ..., ANY
+  *		The name is expanded to X86_VENDOR_@vendor
+  * @family:	The family number or X86_FAMILY_ANY
+  * @feature:	A X86_FEATURE bit
+  * @data:	Driver specific data or NULL. The internal storage
+  *		format is unsigned long. The supplied value, pointer
+  *		etc. is casted to unsigned long internally.
+  *
+  * All other missing arguments of X86_MATCH_VENDOR_FAM_MODEL_FEATURE() are
+  * set to wildcards.
+  */
+ #define X86_MATCH_VENDOR_FAM_FEATURE(vendor, family, feature, data)	\
+ 	X86_MATCH_VENDOR_FAM_MODEL_FEATURE(vendor, family,		\
+ 					   X86_MODEL_ANY, feature, data)
+ 
+ /**
+  * X86_MATCH_VENDOR_FEATURE - Macro for matching vendor and CPU feature
+  * @vendor:	The vendor name, e.g. INTEL, AMD, HYGON, ..., ANY
+  *		The name is expanded to X86_VENDOR_@vendor
+  * @feature:	A X86_FEATURE bit
+  * @data:	Driver specific data or NULL. The internal storage
+  *		format is unsigned long. The supplied value, pointer
+  *		etc. is casted to unsigned long internally.
+  *
+  * All other missing arguments of X86_MATCH_VENDOR_FAM_MODEL_FEATURE() are
+  * set to wildcards.
+  */
+ #define X86_MATCH_VENDOR_FEATURE(vendor, feature, data)			\
+ 	X86_MATCH_VENDOR_FAM_FEATURE(vendor, X86_FAMILY_ANY, feature, data)
+ 
+ /**
+  * X86_MATCH_FEATURE - Macro for matching a CPU feature
+  * @feature:	A X86_FEATURE bit
+  * @data:	Driver specific data or NULL. The internal storage
+  *		format is unsigned long. The supplied value, pointer
+  *		etc. is casted to unsigned long internally.
+  *
+  * All other missing arguments of X86_MATCH_VENDOR_FAM_MODEL_FEATURE() are
+  * set to wildcards.
+  */
+ #define X86_MATCH_FEATURE(feature, data)				\
+ 	X86_MATCH_VENDOR_FEATURE(ANY, feature, data)
+ 
+ /**
+  * X86_MATCH_VENDOR_FAM_MODEL - Match vendor, family and model
+  * @vendor:	The vendor name, e.g. INTEL, AMD, HYGON, ..., ANY
+  *		The name is expanded to X86_VENDOR_@vendor
+  * @family:	The family number or X86_FAMILY_ANY
+  * @model:	The model number, model constant or X86_MODEL_ANY
+  * @data:	Driver specific data or NULL. The internal storage
+  *		format is unsigned long. The supplied value, pointer
+  *		etc. is casted to unsigned long internally.
+  *
+  * All other missing arguments of X86_MATCH_VENDOR_FAM_MODEL_FEATURE() are
+  * set to wildcards.
+  */
+ #define X86_MATCH_VENDOR_FAM_MODEL(vendor, family, model, data)		\
+ 	X86_MATCH_VENDOR_FAM_MODEL_FEATURE(vendor, family, model,	\
+ 					   X86_FEATURE_ANY, data)
+ 
+ /**
+  * X86_MATCH_VENDOR_FAM - Match vendor and family
+  * @vendor:	The vendor name, e.g. INTEL, AMD, HYGON, ..., ANY
+  *		The name is expanded to X86_VENDOR_@vendor
+  * @family:	The family number or X86_FAMILY_ANY
+  * @data:	Driver specific data or NULL. The internal storage
+  *		format is unsigned long. The supplied value, pointer
+  *		etc. is casted to unsigned long internally.
+  *
+  * All other missing arguments to X86_MATCH_VENDOR_FAM_MODEL_FEATURE() are
+  * set of wildcards.
+  */
+ #define X86_MATCH_VENDOR_FAM(vendor, family, data)			\
+ 	X86_MATCH_VENDOR_FAM_MODEL(vendor, family, X86_MODEL_ANY, data)
+ 
+ /**
+  * X86_MATCH_INTEL_FAM6_MODEL - Match vendor INTEL, family 6 and model
+  * @model:	The model name without the INTEL_FAM6_ prefix or ANY
+  *		The model name is expanded to INTEL_FAM6_@model internally
+  * @data:	Driver specific data or NULL. The internal storage
+  *		format is unsigned long. The supplied value, pointer
+  *		etc. is casted to unsigned long internally.
+  *
+  * The vendor is set to INTEL, the family to 6 and all other missing
+  * arguments of X86_MATCH_VENDOR_FAM_MODEL_FEATURE() are set to wildcards.
+  *
+  * See X86_MATCH_VENDOR_FAM_MODEL_FEATURE() for further information.
+  */
+ #define X86_MATCH_INTEL_FAM6_MODEL(model, data)				\
+ 	X86_MATCH_VENDOR_FAM_MODEL(INTEL, 6, INTEL_FAM6_##model, data)
++>>>>>>> e9d7144597b1 (x86/cpu: Add a steppings field to struct x86_cpu_id)
  
  /*
   * Match specific microcode revisions.
diff --cc include/linux/mod_devicetable.h
index 49d0b197b2e2,0754b8d71262..000000000000
--- a/include/linux/mod_devicetable.h
+++ b/include/linux/mod_devicetable.h
@@@ -208,6 -230,531 +208,534 @@@ struct pnp_card_device_id 
  	} devs[PNP_MAX_DEVICES];
  };
  
++<<<<<<< HEAD
++=======
+ 
+ #define SERIO_ANY	0xff
+ 
+ struct serio_device_id {
+ 	__u8 type;
+ 	__u8 extra;
+ 	__u8 id;
+ 	__u8 proto;
+ };
+ 
+ struct hda_device_id {
+ 	__u32 vendor_id;
+ 	__u32 rev_id;
+ 	__u8 api_version;
+ 	const char *name;
+ 	unsigned long driver_data;
+ };
+ 
+ struct sdw_device_id {
+ 	__u16 mfg_id;
+ 	__u16 part_id;
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ /*
+  * Struct used for matching a device
+  */
+ struct of_device_id {
+ 	char	name[32];
+ 	char	type[32];
+ 	char	compatible[128];
+ 	const void *data;
+ };
+ 
+ /* VIO */
+ struct vio_device_id {
+ 	char type[32];
+ 	char compat[32];
+ };
+ 
+ /* PCMCIA */
+ 
+ struct pcmcia_device_id {
+ 	__u16		match_flags;
+ 
+ 	__u16		manf_id;
+ 	__u16		card_id;
+ 
+ 	__u8		func_id;
+ 
+ 	/* for real multi-function devices */
+ 	__u8		function;
+ 
+ 	/* for pseudo multi-function devices */
+ 	__u8		device_no;
+ 
+ 	__u32		prod_id_hash[4];
+ 
+ 	/* not matched against in kernelspace */
+ 	const char *	prod_id[4];
+ 
+ 	/* not matched against */
+ 	kernel_ulong_t	driver_info;
+ 	char *		cisfile;
+ };
+ 
+ #define PCMCIA_DEV_ID_MATCH_MANF_ID	0x0001
+ #define PCMCIA_DEV_ID_MATCH_CARD_ID	0x0002
+ #define PCMCIA_DEV_ID_MATCH_FUNC_ID	0x0004
+ #define PCMCIA_DEV_ID_MATCH_FUNCTION	0x0008
+ #define PCMCIA_DEV_ID_MATCH_PROD_ID1	0x0010
+ #define PCMCIA_DEV_ID_MATCH_PROD_ID2	0x0020
+ #define PCMCIA_DEV_ID_MATCH_PROD_ID3	0x0040
+ #define PCMCIA_DEV_ID_MATCH_PROD_ID4	0x0080
+ #define PCMCIA_DEV_ID_MATCH_DEVICE_NO	0x0100
+ #define PCMCIA_DEV_ID_MATCH_FAKE_CIS	0x0200
+ #define PCMCIA_DEV_ID_MATCH_ANONYMOUS	0x0400
+ 
+ /* Input */
+ #define INPUT_DEVICE_ID_EV_MAX		0x1f
+ #define INPUT_DEVICE_ID_KEY_MIN_INTERESTING	0x71
+ #define INPUT_DEVICE_ID_KEY_MAX		0x2ff
+ #define INPUT_DEVICE_ID_REL_MAX		0x0f
+ #define INPUT_DEVICE_ID_ABS_MAX		0x3f
+ #define INPUT_DEVICE_ID_MSC_MAX		0x07
+ #define INPUT_DEVICE_ID_LED_MAX		0x0f
+ #define INPUT_DEVICE_ID_SND_MAX		0x07
+ #define INPUT_DEVICE_ID_FF_MAX		0x7f
+ #define INPUT_DEVICE_ID_SW_MAX		0x0f
+ #define INPUT_DEVICE_ID_PROP_MAX	0x1f
+ 
+ #define INPUT_DEVICE_ID_MATCH_BUS	1
+ #define INPUT_DEVICE_ID_MATCH_VENDOR	2
+ #define INPUT_DEVICE_ID_MATCH_PRODUCT	4
+ #define INPUT_DEVICE_ID_MATCH_VERSION	8
+ 
+ #define INPUT_DEVICE_ID_MATCH_EVBIT	0x0010
+ #define INPUT_DEVICE_ID_MATCH_KEYBIT	0x0020
+ #define INPUT_DEVICE_ID_MATCH_RELBIT	0x0040
+ #define INPUT_DEVICE_ID_MATCH_ABSBIT	0x0080
+ #define INPUT_DEVICE_ID_MATCH_MSCIT	0x0100
+ #define INPUT_DEVICE_ID_MATCH_LEDBIT	0x0200
+ #define INPUT_DEVICE_ID_MATCH_SNDBIT	0x0400
+ #define INPUT_DEVICE_ID_MATCH_FFBIT	0x0800
+ #define INPUT_DEVICE_ID_MATCH_SWBIT	0x1000
+ #define INPUT_DEVICE_ID_MATCH_PROPBIT	0x2000
+ 
+ struct input_device_id {
+ 
+ 	kernel_ulong_t flags;
+ 
+ 	__u16 bustype;
+ 	__u16 vendor;
+ 	__u16 product;
+ 	__u16 version;
+ 
+ 	kernel_ulong_t evbit[INPUT_DEVICE_ID_EV_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t keybit[INPUT_DEVICE_ID_KEY_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t relbit[INPUT_DEVICE_ID_REL_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t absbit[INPUT_DEVICE_ID_ABS_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t mscbit[INPUT_DEVICE_ID_MSC_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t ledbit[INPUT_DEVICE_ID_LED_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t sndbit[INPUT_DEVICE_ID_SND_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t ffbit[INPUT_DEVICE_ID_FF_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t swbit[INPUT_DEVICE_ID_SW_MAX / BITS_PER_LONG + 1];
+ 	kernel_ulong_t propbit[INPUT_DEVICE_ID_PROP_MAX / BITS_PER_LONG + 1];
+ 
+ 	kernel_ulong_t driver_info;
+ };
+ 
+ /* EISA */
+ 
+ #define EISA_SIG_LEN   8
+ 
+ /* The EISA signature, in ASCII form, null terminated */
+ struct eisa_device_id {
+ 	char          sig[EISA_SIG_LEN];
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ #define EISA_DEVICE_MODALIAS_FMT "eisa:s%s"
+ 
+ struct parisc_device_id {
+ 	__u8	hw_type;	/* 5 bits used */
+ 	__u8	hversion_rev;	/* 4 bits */
+ 	__u16	hversion;	/* 12 bits */
+ 	__u32	sversion;	/* 20 bits */
+ };
+ 
+ #define PA_HWTYPE_ANY_ID	0xff
+ #define PA_HVERSION_REV_ANY_ID	0xff
+ #define PA_HVERSION_ANY_ID	0xffff
+ #define PA_SVERSION_ANY_ID	0xffffffff
+ 
+ /* SDIO */
+ 
+ #define SDIO_ANY_ID (~0)
+ 
+ struct sdio_device_id {
+ 	__u8	class;			/* Standard interface or SDIO_ANY_ID */
+ 	__u16	vendor;			/* Vendor or SDIO_ANY_ID */
+ 	__u16	device;			/* Device ID or SDIO_ANY_ID */
+ 	kernel_ulong_t driver_data;	/* Data private to the driver */
+ };
+ 
+ /* SSB core, see drivers/ssb/ */
+ struct ssb_device_id {
+ 	__u16	vendor;
+ 	__u16	coreid;
+ 	__u8	revision;
+ 	__u8	__pad;
+ } __attribute__((packed, aligned(2)));
+ #define SSB_DEVICE(_vendor, _coreid, _revision)  \
+ 	{ .vendor = _vendor, .coreid = _coreid, .revision = _revision, }
+ 
+ #define SSB_ANY_VENDOR		0xFFFF
+ #define SSB_ANY_ID		0xFFFF
+ #define SSB_ANY_REV		0xFF
+ 
+ /* Broadcom's specific AMBA core, see drivers/bcma/ */
+ struct bcma_device_id {
+ 	__u16	manuf;
+ 	__u16	id;
+ 	__u8	rev;
+ 	__u8	class;
+ } __attribute__((packed,aligned(2)));
+ #define BCMA_CORE(_manuf, _id, _rev, _class)  \
+ 	{ .manuf = _manuf, .id = _id, .rev = _rev, .class = _class, }
+ 
+ #define BCMA_ANY_MANUF		0xFFFF
+ #define BCMA_ANY_ID		0xFFFF
+ #define BCMA_ANY_REV		0xFF
+ #define BCMA_ANY_CLASS		0xFF
+ 
+ struct virtio_device_id {
+ 	__u32 device;
+ 	__u32 vendor;
+ };
+ #define VIRTIO_DEV_ANY_ID	0xffffffff
+ 
+ /*
+  * For Hyper-V devices we use the device guid as the id.
+  */
+ struct hv_vmbus_device_id {
+ 	uuid_le guid;
+ 	kernel_ulong_t driver_data;	/* Data private to the driver */
+ };
+ 
+ /* rpmsg */
+ 
+ #define RPMSG_NAME_SIZE			32
+ #define RPMSG_DEVICE_MODALIAS_FMT	"rpmsg:%s"
+ 
+ struct rpmsg_device_id {
+ 	char name[RPMSG_NAME_SIZE];
+ };
+ 
+ /* i2c */
+ 
+ #define I2C_NAME_SIZE	20
+ #define I2C_MODULE_PREFIX "i2c:"
+ 
+ struct i2c_device_id {
+ 	char name[I2C_NAME_SIZE];
+ 	kernel_ulong_t driver_data;	/* Data private to the driver */
+ };
+ 
+ /* pci_epf */
+ 
+ #define PCI_EPF_NAME_SIZE	20
+ #define PCI_EPF_MODULE_PREFIX	"pci_epf:"
+ 
+ struct pci_epf_device_id {
+ 	char name[PCI_EPF_NAME_SIZE];
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ /* i3c */
+ 
+ #define I3C_MATCH_DCR			0x1
+ #define I3C_MATCH_MANUF			0x2
+ #define I3C_MATCH_PART			0x4
+ #define I3C_MATCH_EXTRA_INFO		0x8
+ 
+ struct i3c_device_id {
+ 	__u8 match_flags;
+ 	__u8 dcr;
+ 	__u16 manuf_id;
+ 	__u16 part_id;
+ 	__u16 extra_info;
+ 
+ 	const void *data;
+ };
+ 
+ /* spi */
+ 
+ #define SPI_NAME_SIZE	32
+ #define SPI_MODULE_PREFIX "spi:"
+ 
+ struct spi_device_id {
+ 	char name[SPI_NAME_SIZE];
+ 	kernel_ulong_t driver_data;	/* Data private to the driver */
+ };
+ 
+ /* SLIMbus */
+ 
+ #define SLIMBUS_NAME_SIZE	32
+ #define SLIMBUS_MODULE_PREFIX	"slim:"
+ 
+ struct slim_device_id {
+ 	__u16 manf_id, prod_code;
+ 	__u16 dev_index, instance;
+ 
+ 	/* Data private to the driver */
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ #define APR_NAME_SIZE	32
+ #define APR_MODULE_PREFIX "apr:"
+ 
+ struct apr_device_id {
+ 	char name[APR_NAME_SIZE];
+ 	__u32 domain_id;
+ 	__u32 svc_id;
+ 	__u32 svc_version;
+ 	kernel_ulong_t driver_data;	/* Data private to the driver */
+ };
+ 
+ #define SPMI_NAME_SIZE	32
+ #define SPMI_MODULE_PREFIX "spmi:"
+ 
+ struct spmi_device_id {
+ 	char name[SPMI_NAME_SIZE];
+ 	kernel_ulong_t driver_data;	/* Data private to the driver */
+ };
+ 
+ /* dmi */
+ enum dmi_field {
+ 	DMI_NONE,
+ 	DMI_BIOS_VENDOR,
+ 	DMI_BIOS_VERSION,
+ 	DMI_BIOS_DATE,
+ 	DMI_SYS_VENDOR,
+ 	DMI_PRODUCT_NAME,
+ 	DMI_PRODUCT_VERSION,
+ 	DMI_PRODUCT_SERIAL,
+ 	DMI_PRODUCT_UUID,
+ 	DMI_PRODUCT_SKU,
+ 	DMI_PRODUCT_FAMILY,
+ 	DMI_BOARD_VENDOR,
+ 	DMI_BOARD_NAME,
+ 	DMI_BOARD_VERSION,
+ 	DMI_BOARD_SERIAL,
+ 	DMI_BOARD_ASSET_TAG,
+ 	DMI_CHASSIS_VENDOR,
+ 	DMI_CHASSIS_TYPE,
+ 	DMI_CHASSIS_VERSION,
+ 	DMI_CHASSIS_SERIAL,
+ 	DMI_CHASSIS_ASSET_TAG,
+ 	DMI_STRING_MAX,
+ 	DMI_OEM_STRING,	/* special case - will not be in dmi_ident */
+ };
+ 
+ struct dmi_strmatch {
+ 	unsigned char slot:7;
+ 	unsigned char exact_match:1;
+ 	char substr[79];
+ };
+ 
+ struct dmi_system_id {
+ 	int (*callback)(const struct dmi_system_id *);
+ 	const char *ident;
+ 	struct dmi_strmatch matches[4];
+ 	void *driver_data;
+ };
+ /*
+  * struct dmi_device_id appears during expansion of
+  * "MODULE_DEVICE_TABLE(dmi, x)". Compiler doesn't look inside it
+  * but this is enough for gcc 3.4.6 to error out:
+  *	error: storage size of '__mod_dmi_device_table' isn't known
+  */
+ #define dmi_device_id dmi_system_id
+ 
+ #define DMI_MATCH(a, b)	{ .slot = a, .substr = b }
+ #define DMI_EXACT_MATCH(a, b)	{ .slot = a, .substr = b, .exact_match = 1 }
+ 
+ #define PLATFORM_NAME_SIZE	20
+ #define PLATFORM_MODULE_PREFIX	"platform:"
+ 
+ struct platform_device_id {
+ 	char name[PLATFORM_NAME_SIZE];
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ #define MDIO_NAME_SIZE		32
+ #define MDIO_MODULE_PREFIX	"mdio:"
+ 
+ #define MDIO_ID_FMT "%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u"
+ #define MDIO_ID_ARGS(_id) \
+ 	((_id)>>31) & 1, ((_id)>>30) & 1, ((_id)>>29) & 1, ((_id)>>28) & 1, \
+ 	((_id)>>27) & 1, ((_id)>>26) & 1, ((_id)>>25) & 1, ((_id)>>24) & 1, \
+ 	((_id)>>23) & 1, ((_id)>>22) & 1, ((_id)>>21) & 1, ((_id)>>20) & 1, \
+ 	((_id)>>19) & 1, ((_id)>>18) & 1, ((_id)>>17) & 1, ((_id)>>16) & 1, \
+ 	((_id)>>15) & 1, ((_id)>>14) & 1, ((_id)>>13) & 1, ((_id)>>12) & 1, \
+ 	((_id)>>11) & 1, ((_id)>>10) & 1, ((_id)>>9) & 1, ((_id)>>8) & 1, \
+ 	((_id)>>7) & 1, ((_id)>>6) & 1, ((_id)>>5) & 1, ((_id)>>4) & 1, \
+ 	((_id)>>3) & 1, ((_id)>>2) & 1, ((_id)>>1) & 1, (_id) & 1
+ 
+ /**
+  * struct mdio_device_id - identifies PHY devices on an MDIO/MII bus
+  * @phy_id: The result of
+  *     (mdio_read(&MII_PHYSID1) << 16 | mdio_read(&MII_PHYSID2)) & @phy_id_mask
+  *     for this PHY type
+  * @phy_id_mask: Defines the significant bits of @phy_id.  A value of 0
+  *     is used to terminate an array of struct mdio_device_id.
+  */
+ struct mdio_device_id {
+ 	__u32 phy_id;
+ 	__u32 phy_id_mask;
+ };
+ 
+ struct zorro_device_id {
+ 	__u32 id;			/* Device ID or ZORRO_WILDCARD */
+ 	kernel_ulong_t driver_data;	/* Data private to the driver */
+ };
+ 
+ #define ZORRO_WILDCARD			(0xffffffff)	/* not official */
+ 
+ #define ZORRO_DEVICE_MODALIAS_FMT	"zorro:i%08X"
+ 
+ #define ISAPNP_ANY_ID		0xffff
+ struct isapnp_device_id {
+ 	unsigned short card_vendor, card_device;
+ 	unsigned short vendor, function;
+ 	kernel_ulong_t driver_data;	/* data private to the driver */
+ };
+ 
+ /**
+  * struct amba_id - identifies a device on an AMBA bus
+  * @id: The significant bits if the hardware device ID
+  * @mask: Bitmask specifying which bits of the id field are significant when
+  *	matching.  A driver binds to a device when ((hardware device ID) & mask)
+  *	== id.
+  * @data: Private data used by the driver.
+  */
+ struct amba_id {
+ 	unsigned int		id;
+ 	unsigned int		mask;
+ 	void			*data;
+ };
+ 
+ /**
+  * struct mips_cdmm_device_id - identifies devices in MIPS CDMM bus
+  * @type:	Device type identifier.
+  */
+ struct mips_cdmm_device_id {
+ 	__u8	type;
+ };
+ 
+ /*
+  * Match x86 CPUs for CPU specific drivers.
+  * See documentation of "x86_match_cpu" for details.
+  */
+ 
+ /*
+  * MODULE_DEVICE_TABLE expects this struct to be called x86cpu_device_id.
+  * Although gcc seems to ignore this error, clang fails without this define.
+  */
+ #define x86cpu_device_id x86_cpu_id
+ struct x86_cpu_id {
+ 	__u16 vendor;
+ 	__u16 family;
+ 	__u16 model;
+ 	__u16 steppings;
+ 	__u16 feature;	/* bit index */
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ /* Wild cards for x86_cpu_id::vendor, family, model and feature */
+ #define X86_VENDOR_ANY 0xffff
+ #define X86_FAMILY_ANY 0
+ #define X86_MODEL_ANY  0
+ #define X86_STEPPING_ANY 0
+ #define X86_FEATURE_ANY 0	/* Same as FPU, you can't test for that */
+ 
+ /*
+  * Generic table type for matching CPU features.
+  * @feature:	the bit number of the feature (0 - 65535)
+  */
+ 
+ struct cpu_feature {
+ 	__u16	feature;
+ };
+ 
+ #define IPACK_ANY_FORMAT 0xff
+ #define IPACK_ANY_ID (~0)
+ struct ipack_device_id {
+ 	__u8  format;			/* Format version or IPACK_ANY_ID */
+ 	__u32 vendor;			/* Vendor ID or IPACK_ANY_ID */
+ 	__u32 device;			/* Device ID or IPACK_ANY_ID */
+ };
+ 
+ #define MEI_CL_MODULE_PREFIX "mei:"
+ #define MEI_CL_NAME_SIZE 32
+ #define MEI_CL_VERSION_ANY 0xff
+ 
+ /**
+  * struct mei_cl_device_id - MEI client device identifier
+  * @name: helper name
+  * @uuid: client uuid
+  * @version: client protocol version
+  * @driver_info: information used by the driver.
+  *
+  * identifies mei client device by uuid and name
+  */
+ struct mei_cl_device_id {
+ 	char name[MEI_CL_NAME_SIZE];
+ 	uuid_le uuid;
+ 	__u8    version;
+ 	kernel_ulong_t driver_info;
+ };
+ 
+ /* RapidIO */
+ 
+ #define RIO_ANY_ID	0xffff
+ 
+ /**
+  * struct rio_device_id - RIO device identifier
+  * @did: RapidIO device ID
+  * @vid: RapidIO vendor ID
+  * @asm_did: RapidIO assembly device ID
+  * @asm_vid: RapidIO assembly vendor ID
+  *
+  * Identifies a RapidIO device based on both the device/vendor IDs and
+  * the assembly device/vendor IDs.
+  */
+ struct rio_device_id {
+ 	__u16 did, vid;
+ 	__u16 asm_did, asm_vid;
+ };
+ 
+ struct mcb_device_id {
+ 	__u16 device;
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ struct ulpi_device_id {
+ 	__u16 vendor;
+ 	__u16 product;
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ /**
+  * struct fsl_mc_device_id - MC object device identifier
+  * @vendor: vendor ID
+  * @obj_type: MC object type
+  *
+  * Type of entries in the "device Id" table for MC object devices supported by
+  * a MC object device driver. The last entry of the table has vendor set to 0x0
+  */
+ struct fsl_mc_device_id {
+ 	__u16 vendor;
+ 	const char obj_type[16];
+ };
+ 
++>>>>>>> e9d7144597b1 (x86/cpu: Add a steppings field to struct x86_cpu_id)
  /**
   * struct tb_service_id - Thunderbolt service identifiers
   * @match_flags: Flags used to match the structure
* Unmerged path arch/x86/include/asm/cpu_device_id.h
diff --git a/arch/x86/kernel/cpu/match.c b/arch/x86/kernel/cpu/match.c
index 6fe9e3600e48..787679c95495 100644
--- a/arch/x86/kernel/cpu/match.c
+++ b/arch/x86/kernel/cpu/match.c
@@ -33,13 +33,18 @@ const struct x86_cpu_id *x86_match_cpu(const struct x86_cpu_id *match)
 	const struct x86_cpu_id *m;
 	struct cpuinfo_x86 *c = &boot_cpu_data;
 
-	for (m = match; m->vendor | m->family | m->model | m->feature; m++) {
+	for (m = match;
+	     m->vendor | m->family | m->model | m->steppings | m->feature;
+	     m++) {
 		if (m->vendor != X86_VENDOR_ANY && c->x86_vendor != m->vendor)
 			continue;
 		if (m->family != X86_FAMILY_ANY && c->x86 != m->family)
 			continue;
 		if (m->model != X86_MODEL_ANY && c->x86_model != m->model)
 			continue;
+		if (m->steppings != X86_STEPPING_ANY &&
+		    !(BIT(c->x86_stepping) & m->steppings))
+			continue;
 		if (m->feature != X86_FEATURE_ANY && !cpu_has(c, m->feature))
 			continue;
 		return m;
* Unmerged path include/linux/mod_devicetable.h
