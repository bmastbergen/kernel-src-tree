x86: respect memory size limiting via mem= parameter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.el7
Rebuild_CHGLOG: - [x86] Revert "x86: respect memory size limiting via mem= parameter" (Joel Savitz) [1851576]
Rebuild_FUZZ: 92.04%
commit-author Juergen Gross <jgross@suse.com>
commit 357b4da50a62e2fd70eacee21cdbd22d4c7a7b60
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.el7/357b4da5.failed

When limiting memory size via kernel parameter "mem=" this should be
respected even in case of memory made accessible via a PCI card.

Today this kind of memory won't be made usable in initial memory
setup as the memory won't be visible in E820 map, but it might be
added when adding PCI devices due to corresponding ACPI table entries.

Not respecting "mem=" can be corrected by adding a global max_mem_size
variable set by parse_memopt() which will result in rejecting adding
memory areas resulting in a memory size above the allowed limit.

	Signed-off-by: Juergen Gross <jgross@suse.com>
	Acked-by: Ingo Molnar <mingo@kernel.org>
	Reviewed-by: William Kucharski <william.kucharski@oracle.com>
	Signed-off-by: Juergen Gross <jgross@suse.com>
(cherry picked from commit 357b4da50a62e2fd70eacee21cdbd22d4c7a7b60)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/memory_hotplug.h
#	mm/memory_hotplug.c
diff --cc include/linux/memory_hotplug.h
index 6432c4633cc6,cfd12078172a..000000000000
--- a/include/linux/memory_hotplug.h
+++ b/include/linux/memory_hotplug.h
@@@ -97,10 -100,19 +97,23 @@@ extern void __online_page_free(struct p
  
  extern int try_online_node(int nid);
  
++<<<<<<< HEAD
++=======
+ extern u64 max_mem_size;
+ 
+ extern bool memhp_auto_online;
+ /* If movable_node boot option specified */
+ extern bool movable_node_enabled;
+ static inline bool movable_node_is_enabled(void)
+ {
+ 	return movable_node_enabled;
+ }
+ 
++>>>>>>> 357b4da50a62 (x86: respect memory size limiting via mem= parameter)
  #ifdef CONFIG_MEMORY_HOTREMOVE
 -extern int arch_remove_memory(int nid, u64 start, u64 size,
 -				struct vmem_altmap *altmap);
 +extern bool is_pageblock_removable_nolock(struct page *page);
 +extern int arch_remove_memory(u64 start, u64 size,
 +		struct vmem_altmap *altmap);
  extern int __remove_pages(struct zone *zone, unsigned long start_pfn,
  	unsigned long nr_pages, struct vmem_altmap *altmap);
  #endif /* CONFIG_MEMORY_HOTREMOVE */
diff --cc mm/memory_hotplug.c
index 0352de66ba23,519f9db063ff..000000000000
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@@ -128,18 -92,23 +128,28 @@@ void mem_hotplug_begin(void
  
  void mem_hotplug_done(void)
  {
 -	percpu_up_write(&mem_hotplug_lock);
 -	cpus_read_unlock();
 +	mem_hotplug.active_writer = NULL;
 +	mutex_unlock(&mem_hotplug.lock);
 +	memhp_lock_release();
 +	mutex_unlock(&memory_add_remove_lock);
  }
  
+ u64 max_mem_size = U64_MAX;
+ 
  /* add this memory to iomem resource */
  static struct resource *register_memory_resource(u64 start, u64 size)
  {
++<<<<<<< HEAD
 +	struct resource *res;
++=======
+ 	struct resource *res, *conflict;
+ 
+ 	if (start + size > max_mem_size)
+ 		return ERR_PTR(-E2BIG);
+ 
++>>>>>>> 357b4da50a62 (x86: respect memory size limiting via mem= parameter)
  	res = kzalloc(sizeof(struct resource), GFP_KERNEL);
 -	if (!res)
 -		return ERR_PTR(-ENOMEM);
 +	BUG_ON(!res);
  
  	res->name = "System RAM";
  	res->start = start;
diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 76f02cd6bd57..65494e854603 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -20,6 +20,7 @@
 #include <linux/firmware-map.h>
 #include <linux/memblock.h>
 #include <linux/sort.h>
+#include <linux/memory_hotplug.h>
 
 #include <asm/e820.h>
 #include <asm/proto.h>
@@ -860,6 +861,10 @@ static int __init parse_memopt(char *p)
 		return -EINVAL;
 	e820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
 
+#ifdef CONFIG_MEMORY_HOTPLUG
+	max_mem_size = mem_size;
+#endif
+
 	return 0;
 }
 early_param("mem", parse_memopt);
* Unmerged path include/linux/memory_hotplug.h
* Unmerged path mm/memory_hotplug.c
