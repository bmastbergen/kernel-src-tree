net/sched: cls_u32: Fix reference counter leak leading to overflow

jira LE-1907
cve CVE-2023-3609
Rebuild_History Non-Buildable kernel-3.10.0-1160.102.1.el7
commit-author Lee Jones <lee@kernel.org>
commit 04c55383fa5689357bcdd2c8036725a55ed632bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.102.1.el7/04c55383.failed

In the event of a failure in tcf_change_indev(), u32_set_parms() will
immediately return without decrementing the recently incremented
reference counter.  If this happens enough times, the counter will
rollover and the reference freed, leading to a double free which can be
used to do 'bad things'.

In order to prevent this, move the point of possible failure above the
point where the reference counter is incremented.  Also save any
meaningful return values to be applied to the return data at the
appropriate point in time.

This issue was caught with KASAN.

Fixes: 705c7091262d ("net: sched: cls_u32: no need to call tcf_exts_change for newly allocated struct")
	Suggested-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Lee Jones <lee@kernel.org>
	Reviewed-by: Eric Dumazet <edumazet@google.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 04c55383fa5689357bcdd2c8036725a55ed632bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_u32.c
diff --cc net/sched/cls_u32.c
index 269dcb08fed5,d15d50de7980..000000000000
--- a/net/sched/cls_u32.c
+++ b/net/sched/cls_u32.c
@@@ -763,13 -713,15 +763,13 @@@ static const struct nla_policy u32_poli
  };
  
  static int u32_set_parms(struct net *net, struct tcf_proto *tp,
 -			 unsigned long base,
 +			 unsigned long base, struct tc_u_hnode *ht,
  			 struct tc_u_knode *n, struct nlattr **tb,
 -			 struct nlattr *est, u32 flags, u32 fl_flags,
 -			 struct netlink_ext_ack *extack)
 +			 struct nlattr *est, bool ovr)
  {
- 	int err;
+ 	int err, ifindex = -1;
  
 -	err = tcf_exts_validate_ex(net, tp, tb, est, &n->exts, flags,
 -				   fl_flags, extack);
 +	err = tcf_exts_validate(net, tp, tb, est, &n->exts, ovr);
  	if (err < 0)
  		return err;
  
@@@ -799,15 -765,9 +805,21 @@@
  		tcf_bind_filter(tp, &n->res, base);
  	}
  
++<<<<<<< HEAD
 +#ifdef CONFIG_NET_CLS_IND
 +	if (tb[TCA_U32_INDEV]) {
 +		int ret;
 +		ret = tcf_change_indev(net, tb[TCA_U32_INDEV]);
 +		if (ret < 0)
 +			return -EINVAL;
 +		n->ifindex = ret;
 +	}
 +#endif
++=======
+ 	if (ifindex >= 0)
+ 		n->ifindex = ifindex;
+ 
++>>>>>>> 04c55383fa56 (net/sched: cls_u32: Fix reference counter leak leading to overflow)
  	return 0;
  }
  
* Unmerged path net/sched/cls_u32.c
