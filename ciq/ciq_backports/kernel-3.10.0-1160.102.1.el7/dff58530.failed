NFSv4.1: fix handling of backchannel binding in BIND_CONN_TO_SESSION

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.102.1.el7
commit-author Olga Kornievskaia <olga.kornievskaia@gmail.com>
commit dff58530c4ca8ce7ee5a74db431c6e35362cf682
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.102.1.el7/dff58530.failed

Currently, if the client sends BIND_CONN_TO_SESSION with
NFS4_CDFC4_FORE_OR_BOTH but only gets NFS4_CDFS4_FORE back it ignores
that it wasn't able to enable a backchannel.

To make sure, the client sends BIND_CONN_TO_SESSION as the first
operation on the connections (ie., no other session compounds haven't
been sent before), and if the client's request to bind the backchannel
is not satisfied, then reset the connection and retry.

	Cc: stable@vger.kernel.org
	Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit dff58530c4ca8ce7ee5a74db431c6e35362cf682)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4proc.c
#	include/linux/sunrpc/clnt.h
diff --cc fs/nfs/nfs4proc.c
index 03308d480f96,a0c1e653a935..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -7378,6 -7890,22 +7378,25 @@@ nfs41_same_server_scope(struct nfs41_se
  static void
  nfs4_bind_one_conn_to_session_done(struct rpc_task *task, void *calldata)
  {
++<<<<<<< HEAD
++=======
+ 	struct nfs41_bind_conn_to_session_args *args = task->tk_msg.rpc_argp;
+ 	struct nfs41_bind_conn_to_session_res *res = task->tk_msg.rpc_resp;
+ 	struct nfs_client *clp = args->client;
+ 
+ 	switch (task->tk_status) {
+ 	case -NFS4ERR_BADSESSION:
+ 	case -NFS4ERR_DEADSESSION:
+ 		nfs4_schedule_session_recovery(clp->cl_session,
+ 				task->tk_status);
+ 	}
+ 	if (args->dir == NFS4_CDFC4_FORE_OR_BOTH &&
+ 			res->dir != NFS4_CDFS4_BOTH) {
+ 		rpc_task_close_connection(task);
+ 		if (args->retries++ < MAX_BIND_CONN_TO_SESSION_RETRIES)
+ 			rpc_restart_call(task);
+ 	}
++>>>>>>> dff58530c4ca (NFSv4.1: fix handling of backchannel binding in BIND_CONN_TO_SESSION)
  }
  
  static const struct rpc_call_ops nfs4_bind_one_conn_to_session_ops = {
diff --cc include/linux/sunrpc/clnt.h
index 509bed2dd955,02e7a5863d28..000000000000
--- a/include/linux/sunrpc/clnt.h
+++ b/include/linux/sunrpc/clnt.h
@@@ -225,5 -242,9 +225,13 @@@ static inline int rpc_reply_expected(st
  		(task->tk_msg.rpc_proc->p_decode != NULL);
  }
  
++<<<<<<< HEAD
 +#endif /* __KERNEL__ */
++=======
+ static inline void rpc_task_close_connection(struct rpc_task *task)
+ {
+ 	if (task->tk_xprt)
+ 		xprt_force_disconnect(task->tk_xprt);
+ }
++>>>>>>> dff58530c4ca (NFSv4.1: fix handling of backchannel binding in BIND_CONN_TO_SESSION)
  #endif /* _LINUX_SUNRPC_CLNT_H */
* Unmerged path fs/nfs/nfs4proc.c
diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 1bf4b087e135..e9eedb3dd02f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1255,11 +1255,13 @@ struct nfs41_impl_id {
 	struct nfstime4			date;
 };
 
+#define MAX_BIND_CONN_TO_SESSION_RETRIES 3
 struct nfs41_bind_conn_to_session_args {
 	struct nfs_client		*client;
 	struct nfs4_sessionid		sessionid;
 	u32				dir;
 	bool				use_conn_in_rdma_mode;
+	int				retries;
 };
 
 struct nfs41_bind_conn_to_session_res {
* Unmerged path include/linux/sunrpc/clnt.h
