netfilter: nf_tables: do not allow SET_ID to refer to another table

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.102.1.el7
commit-author Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
commit 470ee20e069a6d05ae549f7d0ef2bdbcee6a81b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.102.1.el7/470ee20e.failed

When doing lookups for sets on the same batch by using its ID, a set from a
different table can be used.

Then, when the table is removed, a reference to the set may be kept after
the set is freed, leading to a potential use-after-free.

When looking for sets by ID, use the table that was used for the lookup by
name, and only return sets belonging to that same table.

This fixes CVE-2022-2586, also reported as ZDI-CAN-17470.

	Reported-by: Team Orca of Sea Security (@seasecresponse)
Fixes: 958bee14d071 ("netfilter: nf_tables: use new transaction infrastructure to handle sets")
	Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 470ee20e069a6d05ae549f7d0ef2bdbcee6a81b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index e5c639ae2e76,41c529b0001c..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -2437,20 -3841,46 +2437,60 @@@ struct nft_set *nf_tables_set_lookup(co
  	return ERR_PTR(-ENOENT);
  }
  
++<<<<<<< HEAD
 +struct nft_set *nf_tables_set_lookup_byid(const struct net *net,
 +					  const struct nlattr *nla)
++=======
+ static struct nft_set *nft_set_lookup_byid(const struct net *net,
+ 					   const struct nft_table *table,
+ 					   const struct nlattr *nla, u8 genmask)
++>>>>>>> 470ee20e069a (netfilter: nf_tables: do not allow SET_ID to refer to another table)
  {
 -	struct nftables_pernet *nft_net = nft_pernet(net);
 -	u32 id = ntohl(nla_get_be32(nla));
  	struct nft_trans *trans;
 +	u32 id = ntohl(nla_get_be32(nla));
  
++<<<<<<< HEAD
 +	list_for_each_entry(trans, &net->nft.commit_list, list) {
 +		if (trans->msg_type == NFT_MSG_NEWSET &&
 +		    id == nft_trans_set_id(trans))
 +			return nft_trans_set(trans);
++=======
+ 	list_for_each_entry(trans, &nft_net->commit_list, list) {
+ 		if (trans->msg_type == NFT_MSG_NEWSET) {
+ 			struct nft_set *set = nft_trans_set(trans);
+ 
+ 			if (id == nft_trans_set_id(trans) &&
+ 			    set->table == table &&
+ 			    nft_active_genmask(set, genmask))
+ 				return set;
+ 		}
++>>>>>>> 470ee20e069a (netfilter: nf_tables: do not allow SET_ID to refer to another table)
  	}
  	return ERR_PTR(-ENOENT);
  }
  
++<<<<<<< HEAD
++=======
+ struct nft_set *nft_set_lookup_global(const struct net *net,
+ 				      const struct nft_table *table,
+ 				      const struct nlattr *nla_set_name,
+ 				      const struct nlattr *nla_set_id,
+ 				      u8 genmask)
+ {
+ 	struct nft_set *set;
+ 
+ 	set = nft_set_lookup(table, nla_set_name, genmask);
+ 	if (IS_ERR(set)) {
+ 		if (!nla_set_id)
+ 			return set;
+ 
+ 		set = nft_set_lookup_byid(net, table, nla_set_id, genmask);
+ 	}
+ 	return set;
+ }
+ EXPORT_SYMBOL_GPL(nft_set_lookup_global);
+ 
++>>>>>>> 470ee20e069a (netfilter: nf_tables: do not allow SET_ID to refer to another table)
  static int nf_tables_set_alloc_name(struct nft_ctx *ctx, struct nft_set *set,
  				    const char *name)
  {
* Unmerged path net/netfilter/nf_tables_api.c
