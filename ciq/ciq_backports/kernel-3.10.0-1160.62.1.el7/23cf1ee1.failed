svcrdma: Fix leak of svc_rdma_recv_ctxt objects

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.62.1.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 23cf1ee1f1869966b75518c59b5cbda4c6c92450
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.62.1.el7/23cf1ee1.failed

Utilize the xpo_release_rqst transport method to ensure that each
rqstp's svc_rdma_recv_ctxt object is released even when the server
cannot return a Reply for that rqstp.

Without this fix, each RPC whose Reply cannot be sent leaks one
svc_rdma_recv_ctxt. This is a 2.5KB structure, a 4KB DMA-mapped
Receive buffer, and any pages that might be part of the Reply
message.

The leak is infrequent unless the network fabric is unreliable or
Kerberos is in use, as GSS sequence window overruns, which result
in connection loss, are more common on fast transports.

Fixes: 3a88092ee319 ("svcrdma: Preserve Receive buffer until svc_rdma_sendto")
	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 23cf1ee1f1869966b75518c59b5cbda4c6c92450)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/svcsock.c
diff --cc net/sunrpc/svcsock.c
index 451508cec780,023514e392b3..000000000000
--- a/net/sunrpc/svcsock.c
+++ b/net/sunrpc/svcsock.c
@@@ -637,17 -502,45 +637,27 @@@ out_free
  	return 0;
  }
  
 -/**
 - * svc_udp_sendto - Send out a reply on a UDP socket
 - * @rqstp: completed svc_rqst
 - *
 - * Returns the number of bytes sent, or a negative errno.
 - */
 -static int svc_udp_sendto(struct svc_rqst *rqstp)
 +static int
 +svc_udp_sendto(struct svc_rqst *rqstp)
  {
 -	struct svc_xprt *xprt = rqstp->rq_xprt;
 -	struct svc_sock	*svsk = container_of(xprt, struct svc_sock, sk_xprt);
 -	struct xdr_buf *xdr = &rqstp->rq_res;
 -	union {
 -		struct cmsghdr	hdr;
 -		long		all[SVC_PKTINFO_SPACE / sizeof(long)];
 -	} buffer;
 -	struct cmsghdr *cmh = &buffer.hdr;
 -	struct msghdr msg = {
 -		.msg_name	= &rqstp->rq_addr,
 -		.msg_namelen	= rqstp->rq_addrlen,
 -		.msg_control	= cmh,
 -		.msg_controllen	= sizeof(buffer),
 -	};
 -	unsigned int uninitialized_var(sent);
 -	int err;
 +	int		error;
  
++<<<<<<< HEAD
 +	error = svc_sendto(rqstp, &rqstp->rq_res);
 +	if (error == -ECONNREFUSED)
++=======
+ 	svc_release_udp_skb(rqstp);
+ 
+ 	svc_set_cmsg_data(rqstp, cmh);
+ 
+ 	err = xprt_sock_sendmsg(svsk->sk_sock, &msg, xdr, 0, 0, &sent);
+ 	xdr_free_bvec(xdr);
+ 	if (err == -ECONNREFUSED) {
++>>>>>>> 23cf1ee1f186 (svcrdma: Fix leak of svc_rdma_recv_ctxt objects)
  		/* ICMP error on earlier request. */
 -		err = xprt_sock_sendmsg(svsk->sk_sock, &msg, xdr, 0, 0, &sent);
 -		xdr_free_bvec(xdr);
 -	}
 -	if (err < 0)
 -		return err;
 -	return sent;
 +		error = svc_sendto(rqstp, &rqstp->rq_res);
 +
 +	return error;
  }
  
  static int svc_udp_has_wspace(struct svc_xprt *xprt)
@@@ -1170,30 -1067,33 +1180,39 @@@ err_noclose
   */
  static int svc_tcp_sendto(struct svc_rqst *rqstp)
  {
 -	struct svc_xprt *xprt = rqstp->rq_xprt;
 -	struct svc_sock	*svsk = container_of(xprt, struct svc_sock, sk_xprt);
 -	struct xdr_buf *xdr = &rqstp->rq_res;
 -	rpc_fraghdr marker = cpu_to_be32(RPC_LAST_STREAM_FRAGMENT |
 -					 (u32)xdr->len);
 -	struct msghdr msg = {
 -		.msg_flags	= 0,
 -	};
 -	unsigned int uninitialized_var(sent);
 -	int err;
 -
 +	struct xdr_buf	*xbufp = &rqstp->rq_res;
 +	int sent;
 +	__be32 reclen;
 +
++<<<<<<< HEAD
 +	/* Set up the first element of the reply kvec.
 +	 * Any other kvecs that may be in use have been taken
 +	 * care of by the server implementation itself.
 +	 */
 +	reclen = htonl(0x80000000|((xbufp->len ) - 4));
 +	memcpy(xbufp->head[0].iov_base, &reclen, 4);
 +
 +	sent = svc_sendto(rqstp, &rqstp->rq_res);
 +	if (sent != xbufp->len) {
 +		printk(KERN_NOTICE
 +		       "rpc-srv/tcp: %s: %s %d when sending %d bytes "
 +		       "- shutting down socket\n",
 +		       rqstp->rq_xprt->xpt_server->sv_name,
 +		       (sent<0)?"got error":"sent only",
 +		       sent, xbufp->len);
 +		set_bit(XPT_CLOSE, &rqstp->rq_xprt->xpt_flags);
 +		svc_xprt_enqueue(rqstp->rq_xprt);
 +		sent = -EAGAIN;
 +	}
++=======
+ 	svc_release_skb(rqstp);
+ 
+ 	err = xprt_sock_sendmsg(svsk->sk_sock, &msg, xdr, 0, marker, &sent);
+ 	xdr_free_bvec(xdr);
+ 	if (err < 0 || sent != (xdr->len + sizeof(marker)))
+ 		goto out_close;
++>>>>>>> 23cf1ee1f186 (svcrdma: Fix leak of svc_rdma_recv_ctxt objects)
  	return sent;
 -
 -out_close:
 -	pr_notice("rpc-srv/tcp: %s: %s %d when sending %d bytes - shutting down socket\n",
 -		  xprt->xpt_server->sv_name,
 -		  (err < 0) ? "got error" : "sent",
 -		  (err < 0) ? err : sent, xdr->len);
 -	set_bit(XPT_CLOSE, &xprt->xpt_flags);
 -	svc_xprt_enqueue(xprt);
 -	return -EAGAIN;
  }
  
  static struct svc_xprt *svc_tcp_create(struct svc_serv *serv,
diff --git a/include/linux/sunrpc/svc_rdma.h b/include/linux/sunrpc/svc_rdma.h
index 1133f448d1db..62b9d8db25c6 100644
--- a/include/linux/sunrpc/svc_rdma.h
+++ b/include/linux/sunrpc/svc_rdma.h
@@ -180,6 +180,7 @@ extern bool svc_rdma_post_recvs(struct svcxprt_rdma *rdma);
 extern void svc_rdma_recv_ctxt_put(struct svcxprt_rdma *rdma,
 				   struct svc_rdma_recv_ctxt *ctxt);
 extern void svc_rdma_flush_recv_queues(struct svcxprt_rdma *rdma);
+extern void svc_rdma_release_rqst(struct svc_rqst *rqstp);
 extern int svc_rdma_recvfrom(struct svc_rqst *);
 
 /* svc_rdma_rw.c */
diff --git a/net/sunrpc/svc_xprt.c b/net/sunrpc/svc_xprt.c
index 617a0ac34e94..bbaf288778f6 100644
--- a/net/sunrpc/svc_xprt.c
+++ b/net/sunrpc/svc_xprt.c
@@ -882,9 +882,6 @@ int svc_send(struct svc_rqst *rqstp)
 	if (!xprt)
 		goto out;
 
-	/* release the receive skb before sending the reply */
-	xprt->xpt_ops->xpo_release_rqst(rqstp);
-
 	/* calculate over-all length */
 	xb = &rqstp->rq_res;
 	xb->len = xb->head[0].iov_len +
* Unmerged path net/sunrpc/svcsock.c
diff --git a/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c b/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c
index b24d5b8f2fee..16c8174658fd 100644
--- a/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c
+++ b/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c
@@ -226,6 +226,26 @@ void svc_rdma_recv_ctxt_put(struct svcxprt_rdma *rdma,
 		svc_rdma_recv_ctxt_destroy(rdma, ctxt);
 }
 
+/**
+ * svc_rdma_release_rqst - Release transport-specific per-rqst resources
+ * @rqstp: svc_rqst being released
+ *
+ * Ensure that the recv_ctxt is released whether or not a Reply
+ * was sent. For example, the client could close the connection,
+ * or svc_process could drop an RPC, before the Reply is sent.
+ */
+void svc_rdma_release_rqst(struct svc_rqst *rqstp)
+{
+	struct svc_rdma_recv_ctxt *ctxt = rqstp->rq_xprt_ctxt;
+	struct svc_xprt *xprt = rqstp->rq_xprt;
+	struct svcxprt_rdma *rdma =
+		container_of(xprt, struct svcxprt_rdma, sc_xprt);
+
+	rqstp->rq_xprt_ctxt = NULL;
+	if (ctxt)
+		svc_rdma_recv_ctxt_put(rdma, ctxt);
+}
+
 static int __svc_rdma_post_recv(struct svcxprt_rdma *rdma,
 				struct svc_rdma_recv_ctxt *ctxt)
 {
@@ -704,6 +724,8 @@ int svc_rdma_recvfrom(struct svc_rqst *rqstp)
 	__be32 *p;
 	int ret;
 
+	rqstp->rq_xprt_ctxt = NULL;
+
 	spin_lock(&rdma_xprt->sc_rq_dto_lock);
 	ctxt = svc_rdma_next_recv_ctxt(&rdma_xprt->sc_read_complete_q);
 	if (ctxt) {
diff --git a/net/sunrpc/xprtrdma/svc_rdma_sendto.c b/net/sunrpc/xprtrdma/svc_rdma_sendto.c
index df8e45fe316e..3b27e5e04601 100644
--- a/net/sunrpc/xprtrdma/svc_rdma_sendto.c
+++ b/net/sunrpc/xprtrdma/svc_rdma_sendto.c
@@ -902,12 +902,7 @@ int svc_rdma_sendto(struct svc_rqst *rqstp)
 				      wr_lst, rp_ch);
 	if (ret < 0)
 		goto err1;
-	ret = 0;
-
-out:
-	rqstp->rq_xprt_ctxt = NULL;
-	svc_rdma_recv_ctxt_put(rdma, rctxt);
-	return ret;
+	return 0;
 
  err2:
 	if (ret != -E2BIG && ret != -EINVAL)
@@ -916,14 +911,12 @@ out:
 	ret = svc_rdma_send_error_msg(rdma, sctxt, rqstp);
 	if (ret < 0)
 		goto err1;
-	ret = 0;
-	goto out;
+	return 0;
 
  err1:
 	svc_rdma_send_ctxt_put(rdma, sctxt);
  err0:
 	trace_svcrdma_send_failed(rqstp, ret);
 	set_bit(XPT_CLOSE, &xprt->xpt_flags);
-	ret = -ENOTCONN;
-	goto out;
+	return -ENOTCONN;
 }
diff --git a/net/sunrpc/xprtrdma/svc_rdma_transport.c b/net/sunrpc/xprtrdma/svc_rdma_transport.c
index 721b611f0b1c..d77816d2451c 100644
--- a/net/sunrpc/xprtrdma/svc_rdma_transport.c
+++ b/net/sunrpc/xprtrdma/svc_rdma_transport.c
@@ -71,7 +71,6 @@ static struct svc_xprt *svc_rdma_create(struct svc_serv *serv,
 					struct sockaddr *sa, int salen,
 					int flags);
 static struct svc_xprt *svc_rdma_accept(struct svc_xprt *xprt);
-static void svc_rdma_release_rqst(struct svc_rqst *);
 static void svc_rdma_detach(struct svc_xprt *xprt);
 static void svc_rdma_free(struct svc_xprt *xprt);
 static int svc_rdma_has_wspace(struct svc_xprt *xprt);
@@ -614,10 +613,6 @@ static struct svc_xprt *svc_rdma_accept(struct svc_xprt *xprt)
 	return NULL;
 }
 
-static void svc_rdma_release_rqst(struct svc_rqst *rqstp)
-{
-}
-
 /*
  * When connected, an svc_xprt has at least two references:
  *
