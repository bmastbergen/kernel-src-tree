get rid of fget_light()

jira LE-1907
cve CVE-2021-4083
Rebuild_History Non-Buildable kernel-3.10.0-1160.62.1.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit bd2a31d522344b3ac2fb680bd2366e77a9bd8209
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.62.1.el7/bd2a31d5.failed

instead of returning the flags by reference, we can just have the
low-level primitive return those in lower bits of unsigned long,
with struct file * derived from the rest.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit bd2a31d522344b3ac2fb680bd2366e77a9bd8209)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/file.c
diff --cc fs/file.c
index 44bd634b636a,60a45e9f5323..000000000000
--- a/fs/file.c
+++ b/fs/file.c
@@@ -772,58 -683,65 +772,114 @@@ EXPORT_SYMBOL(fget_raw)
   * The fput_needed flag returned by fget_light should be passed to the
   * corresponding fput_light.
   */
++<<<<<<< HEAD
 +struct file *fget_light(unsigned int fd, int *fput_needed)
++=======
+ static unsigned long __fget_light(unsigned int fd, fmode_t mask)
++>>>>>>> bd2a31d52234 (get rid of fget_light())
  {
 -	struct files_struct *files = current->files;
  	struct file *file;
 +	struct files_struct *files = current->files;
  
- 	*fput_needed = 0;
  	if (atomic_read(&files->count) == 1) {
++<<<<<<< HEAD
 +		file = fcheck_files(files, fd);
 +		if (file && (file->f_mode & FMODE_PATH))
 +			file = NULL;
 +	} else {
 +		rcu_read_lock();
 +		file = fcheck_files(files, fd);
 +		if (file) {
 +			if (!(file->f_mode & FMODE_PATH) &&
 +			    atomic_long_inc_not_zero(&file->f_count))
 +				*fput_needed = 1;
 +			else
 +				/* Didn't get the reference, someone's freed */
 +				file = NULL;
 +		}
 +		rcu_read_unlock();
++=======
+ 		file = __fcheck_files(files, fd);
+ 		if (!file || unlikely(file->f_mode & mask))
+ 			return 0;
+ 		return (unsigned long)file;
+ 	} else {
+ 		file = __fget(fd, mask);
+ 		if (!file)
+ 			return 0;
+ 		return FDPUT_FPUT | (unsigned long)file;
++>>>>>>> bd2a31d52234 (get rid of fget_light())
  	}
- 
- 	return file;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(fget_light);
++=======
+ unsigned long __fdget(unsigned int fd)
+ {
+ 	return __fget_light(fd, FMODE_PATH);
+ }
+ EXPORT_SYMBOL(__fdget);
++>>>>>>> bd2a31d52234 (get rid of fget_light())
  
- struct file *fget_raw_light(unsigned int fd, int *fput_needed)
+ unsigned long __fdget_raw(unsigned int fd)
  {
++<<<<<<< HEAD
 +	struct file *file;
 +	struct files_struct *files = current->files;
 +
 +	*fput_needed = 0;
 +	if (atomic_read(&files->count) == 1) {
 +		file = fcheck_files(files, fd);
 +	} else {
 +		rcu_read_lock();
 +		file = fcheck_files(files, fd);
 +		if (file) {
 +			if (atomic_long_inc_not_zero(&file->f_count))
 +				*fput_needed = 1;
 +			else
 +				/* Didn't get the reference, someone's freed */
 +				file = NULL;
 +		}
 +		rcu_read_unlock();
 +	}
 +
 +	return file;
++=======
+ 	return __fget_light(fd, 0);
++>>>>>>> bd2a31d52234 (get rid of fget_light())
+ }
+ 
+ unsigned long __fdget_pos(unsigned int fd)
+ {
+ 	struct files_struct *files = current->files;
+ 	struct file *file;
+ 	unsigned long v;
+ 
+ 	if (atomic_read(&files->count) == 1) {
+ 		file = __fcheck_files(files, fd);
+ 		v = 0;
+ 	} else {
+ 		file = __fget(fd, 0);
+ 		v = FDPUT_FPUT;
+ 	}
+ 	if (!file)
+ 		return 0;
+ 
+ 	if (file->f_mode & FMODE_ATOMIC_POS) {
+ 		if (file_count(file) > 1) {
+ 			v |= FDPUT_POS_UNLOCK;
+ 			mutex_lock(&file->f_pos_lock);
+ 		}
+ 	}
+ 	return v | (unsigned long)file;
  }
  
+ /*
+  * We only lock f_pos if we have threads or if the file might be
+  * shared with another process. In both cases we'll have an elevated
+  * file count (done either by fdget() or by fork()).
+  */
+ 
  void set_close_on_exec(unsigned int fd, int flag)
  {
  	struct files_struct *files = current->files;
* Unmerged path fs/file.c
diff --git a/fs/read_write.c b/fs/read_write.c
index bab2902e3a50..9e084bccaa27 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -307,23 +307,9 @@ loff_t vfs_llseek(struct file *file, loff_t offset, int whence)
 }
 EXPORT_SYMBOL(vfs_llseek);
 
-/*
- * We only lock f_pos if we have threads or if the file might be
- * shared with another process. In both cases we'll have an elevated
- * file count (done either by fdget() or by fork()).
- */
 static inline struct fd fdget_pos(int fd)
 {
-	struct fd f = fdget(fd);
-	struct file *file = f.file;
-
-	if (file && (file->f_mode & FMODE_ATOMIC_POS)) {
-		if (file_count(file) > 1) {
-			f.flags |= FDPUT_POS_UNLOCK;
-			mutex_lock(&file->f_pos_lock);
-		}
-	}
-	return f;
+	return __to_fd(__fdget_pos(fd));
 }
 
 static inline void fdput_pos(struct fd f)
diff --git a/include/linux/file.h b/include/linux/file.h
index f2517fa2d610..4d69123377a2 100644
--- a/include/linux/file.h
+++ b/include/linux/file.h
@@ -40,23 +40,24 @@ static inline void fdput(struct fd fd)
 }
 
 extern struct file *fget(unsigned int fd);
-extern struct file *fget_light(unsigned int fd, int *fput_needed);
+extern struct file *fget_raw(unsigned int fd);
+extern unsigned long __fdget(unsigned int fd);
+extern unsigned long __fdget_raw(unsigned int fd);
+extern unsigned long __fdget_pos(unsigned int fd);
 
-static inline struct fd fdget(unsigned int fd)
+static inline struct fd __to_fd(unsigned long v)
 {
-	int b;
-	struct file *f = fget_light(fd, &b);
-	return (struct fd){f,b};
+	return (struct fd){(struct file *)(v & ~3),v & 3};
 }
 
-extern struct file *fget_raw(unsigned int fd);
-extern struct file *fget_raw_light(unsigned int fd, int *fput_needed);
+static inline struct fd fdget(unsigned int fd)
+{
+	return __to_fd(__fdget(fd));
+}
 
 static inline struct fd fdget_raw(unsigned int fd)
 {
-	int b;
-	struct file *f = fget_raw_light(fd, &b);
-	return (struct fd){f,b};
+	return __to_fd(__fdget_raw(fd));
 }
 
 extern int f_dupfd(unsigned int from, struct file *file, unsigned flags);
diff --git a/include/linux/fs.h b/include/linux/fs.h
index d951f79a0cdb..2bc06e2dc543 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -898,7 +898,7 @@ struct file {
 #ifndef __GENKSYMS__
 	struct mutex		f_pos_lock;
 #endif
-};
+} __attribute__((aligned(4)));	/* lest something weird decides that 2 is OK */
 
 struct file_handle {
 	__u32 handle_bytes;
