fs: add fget_many() and fput_many()

jira LE-1907
cve CVE-2021-4083
Rebuild_History Non-Buildable kernel-3.10.0-1160.62.1.el7
commit-author Jens Axboe <axboe@kernel.dk>
commit 091141a42e15fe47ada737f3996b317072afcefb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.62.1.el7/091141a4.failed

Some uses cases repeatedly get and put references to the same file, but
the only exposed interface is doing these one at the time. As each of
these entail an atomic inc or dec on a shared structure, that cost can
add up.

Add fget_many(), which works just like fget(), except it takes an
argument for how many references to get on the file. Ditto fput_many(),
which can drop an arbitrary number of references to a file.

	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 091141a42e15fe47ada737f3996b317072afcefb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/file.c
#	include/linux/file.h
diff --cc fs/file.c
index 44bd634b636a,97df385d6ab0..000000000000
--- a/fs/file.c
+++ b/fs/file.c
@@@ -718,42 -705,44 +718,67 @@@ void do_close_on_exec(struct files_stru
  	spin_unlock(&files->file_lock);
  }
  
++<<<<<<< HEAD
 +struct file *fget(unsigned int fd)
++=======
+ static struct file *__fget(unsigned int fd, fmode_t mask, unsigned int refs)
++>>>>>>> 091141a42e15 (fs: add fget_many() and fput_many())
  {
 -	struct files_struct *files = current->files;
  	struct file *file;
 +	struct files_struct *files = current->files;
  
  	rcu_read_lock();
 -loop:
  	file = fcheck_files(files, fd);
  	if (file) {
 -		/* File object ref couldn't be taken.
 -		 * dup2() atomicity guarantee is the reason
 -		 * we loop to catch the new file (or NULL pointer)
 -		 */
 -		if (file->f_mode & mask)
 +		/* File object ref couldn't be taken */
 +		if (file->f_mode & FMODE_PATH || !get_file_rcu(file))
  			file = NULL;
++<<<<<<< HEAD
++=======
+ 		else if (!get_file_rcu_many(file, refs))
+ 			goto loop;
++>>>>>>> 091141a42e15 (fs: add fget_many() and fput_many())
  	}
  	rcu_read_unlock();
  
  	return file;
  }
  
++<<<<<<< HEAD
++=======
+ struct file *fget_many(unsigned int fd, unsigned int refs)
+ {
+ 	return __fget(fd, FMODE_PATH, refs);
+ }
+ 
+ struct file *fget(unsigned int fd)
+ {
+ 	return __fget(fd, FMODE_PATH, 1);
+ }
++>>>>>>> 091141a42e15 (fs: add fget_many() and fput_many())
  EXPORT_SYMBOL(fget);
  
  struct file *fget_raw(unsigned int fd)
  {
++<<<<<<< HEAD
 +	struct file *file;
 +	struct files_struct *files = current->files;
 +
 +	rcu_read_lock();
 +	file = fcheck_files(files, fd);
 +	if (file) {
 +		/* File object ref couldn't be taken */
 +		if (!atomic_long_inc_not_zero(&file->f_count))
 +			file = NULL;
 +	}
 +	rcu_read_unlock();
 +
 +	return file;
++=======
+ 	return __fget(fd, 0, 1);
++>>>>>>> 091141a42e15 (fs: add fget_many() and fput_many())
  }
 +
  EXPORT_SYMBOL(fget_raw);
  
  /*
@@@ -772,57 -761,58 +797,86 @@@
   * The fput_needed flag returned by fget_light should be passed to the
   * corresponding fput_light.
   */
 -static unsigned long __fget_light(unsigned int fd, fmode_t mask)
 +struct file *fget_light(unsigned int fd, int *fput_needed)
  {
 -	struct files_struct *files = current->files;
  	struct file *file;
 +	struct files_struct *files = current->files;
  
 +	*fput_needed = 0;
  	if (atomic_read(&files->count) == 1) {
 -		file = __fcheck_files(files, fd);
 -		if (!file || unlikely(file->f_mode & mask))
 -			return 0;
 -		return (unsigned long)file;
 +		file = fcheck_files(files, fd);
 +		if (file && (file->f_mode & FMODE_PATH))
 +			file = NULL;
  	} else {
++<<<<<<< HEAD
 +		rcu_read_lock();
 +		file = fcheck_files(files, fd);
 +		if (file) {
 +			if (!(file->f_mode & FMODE_PATH) &&
 +			    atomic_long_inc_not_zero(&file->f_count))
 +				*fput_needed = 1;
 +			else
 +				/* Didn't get the reference, someone's freed */
 +				file = NULL;
++=======
+ 		file = __fget(fd, mask, 1);
+ 		if (!file)
+ 			return 0;
+ 		return FDPUT_FPUT | (unsigned long)file;
+ 	}
+ }
+ unsigned long __fdget(unsigned int fd)
+ {
+ 	return __fget_light(fd, FMODE_PATH);
+ }
+ EXPORT_SYMBOL(__fdget);
+ 
+ unsigned long __fdget_raw(unsigned int fd)
+ {
+ 	return __fget_light(fd, 0);
+ }
+ 
+ unsigned long __fdget_pos(unsigned int fd)
+ {
+ 	unsigned long v = __fdget(fd);
+ 	struct file *file = (struct file *)(v & ~3);
+ 
+ 	if (file && (file->f_mode & FMODE_ATOMIC_POS)) {
+ 		if (file_count(file) > 1) {
+ 			v |= FDPUT_POS_UNLOCK;
+ 			mutex_lock(&file->f_pos_lock);
++>>>>>>> 091141a42e15 (fs: add fget_many() and fput_many())
  		}
 +		rcu_read_unlock();
  	}
 -	return v;
 +
 +	return file;
  }
 +EXPORT_SYMBOL(fget_light);
  
 -void __f_unlock_pos(struct file *f)
 +struct file *fget_raw_light(unsigned int fd, int *fput_needed)
  {
 -	mutex_unlock(&f->f_pos_lock);
 -}
 +	struct file *file;
 +	struct files_struct *files = current->files;
  
 -/*
 - * We only lock f_pos if we have threads or if the file might be
 - * shared with another process. In both cases we'll have an elevated
 - * file count (done either by fdget() or by fork()).
 - */
 +	*fput_needed = 0;
 +	if (atomic_read(&files->count) == 1) {
 +		file = fcheck_files(files, fd);
 +	} else {
 +		rcu_read_lock();
 +		file = fcheck_files(files, fd);
 +		if (file) {
 +			if (atomic_long_inc_not_zero(&file->f_count))
 +				*fput_needed = 1;
 +			else
 +				/* Didn't get the reference, someone's freed */
 +				file = NULL;
 +		}
 +		rcu_read_unlock();
 +	}
 +
 +	return file;
 +}
  
  void set_close_on_exec(unsigned int fd, int flag)
  {
diff --cc include/linux/file.h
index f2517fa2d610,3fcddff56bc4..000000000000
--- a/include/linux/file.h
+++ b/include/linux/file.h
@@@ -40,7 -45,17 +41,21 @@@ static inline void fdput(struct fd fd
  }
  
  extern struct file *fget(unsigned int fd);
++<<<<<<< HEAD
 +extern struct file *fget_light(unsigned int fd, int *fput_needed);
++=======
+ extern struct file *fget_many(unsigned int fd, unsigned int refs);
+ extern struct file *fget_raw(unsigned int fd);
+ extern unsigned long __fdget(unsigned int fd);
+ extern unsigned long __fdget_raw(unsigned int fd);
+ extern unsigned long __fdget_pos(unsigned int fd);
+ extern void __f_unlock_pos(struct file *);
+ 
+ static inline struct fd __to_fd(unsigned long v)
+ {
+ 	return (struct fd){(struct file *)(v & ~3),v & 3};
+ }
++>>>>>>> 091141a42e15 (fs: add fget_many() and fput_many())
  
  static inline struct fd fdget(unsigned int fd)
  {
* Unmerged path fs/file.c
diff --git a/fs/file_table.c b/fs/file_table.c
index 21a69cb934e1..1e7b564ca0a3 100644
--- a/fs/file_table.c
+++ b/fs/file_table.c
@@ -268,9 +268,9 @@ void flush_delayed_fput(void)
 
 static DECLARE_WORK(delayed_fput_work, delayed_fput);
 
-void fput(struct file *file)
+void fput_many(struct file *file, unsigned int refs)
 {
-	if (atomic_long_dec_and_test(&file->f_count)) {
+	if (atomic_long_sub_and_test(refs, &file->f_count)) {
 		struct task_struct *task = current;
 		unsigned long flags;
 
@@ -286,6 +286,11 @@ void fput(struct file *file)
 	}
 }
 
+void fput(struct file *file)
+{
+	fput_many(file, 1);
+}
+
 /*
  * synchronous analog of fput(); for kernel threads that might be needed
  * in some umount() (and thus can't use flush_delayed_fput() without
* Unmerged path include/linux/file.h
diff --git a/include/linux/fs.h b/include/linux/fs.h
index d951f79a0cdb..b1fcd3623e52 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -912,7 +912,9 @@ static inline struct file *get_file(struct file *f)
 	atomic_long_inc(&f->f_count);
 	return f;
 }
-#define get_file_rcu(x) atomic_long_inc_not_zero(&(x)->f_count)
+#define get_file_rcu_many(x, cnt)	\
+	atomic_long_add_unless(&(x)->f_count, (cnt), 0)
+#define get_file_rcu(x) get_file_rcu_many((x), 1)
 #define fput_atomic(x)	atomic_long_add_unless(&(x)->f_count, -1, 1)
 #define file_count(x)	atomic_long_read(&(x)->f_count)
 
