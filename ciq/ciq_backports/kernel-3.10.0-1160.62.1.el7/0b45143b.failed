x86/platform/uv: Add more to secondary CPU kdump info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.62.1.el7
commit-author Georges Aureau <georges.aureau@hpe.com>
commit 0b45143b4b9440579e7fa889708cfc4bc7fdb9a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.62.1.el7/0b45143b.failed

Add call to run_crash_ipi_callback() to gather more info of what the
secondary CPUs were doing to help with failure analysis.

Excerpt from Georges:

'It is only changing where crash secondaries will be stalling after
having taken care of properly laying down "crash note regs". Please
note that "crash note regs" are a key piece of data used by crash dump
debuggers to provide a reliable backtrace of running processors.'

Secondary change pursuant to

  a5f526ecb075 ("CodingStyle: Inclusive Terminology"):

change master/slave to main/secondary.

 [ bp: Massage commit message. ]

	Signed-off-by: Georges Aureau <georges.aureau@hpe.com>
	Signed-off-by: Mike Travis <mike.travis@hpe.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Steve Wahl <steve.wahl@hpe.com>
Link: https://lkml.kernel.org/r/20210311151028.82678-1-mike.travis@hpe.com
(cherry picked from commit 0b45143b4b9440579e7fa889708cfc4bc7fdb9a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/platform/uv/uv_nmi.c
diff --cc arch/x86/platform/uv/uv_nmi.c
index dec365aaf2da,f83810f7bcc2..000000000000
--- a/arch/x86/platform/uv/uv_nmi.c
+++ b/arch/x86/platform/uv/uv_nmi.c
@@@ -814,36 -837,42 +815,64 @@@ static void uv_nmi_touch_watchdogs(void
  
  #if defined(CONFIG_KEXEC_CORE)
  static atomic_t uv_nmi_kexec_failed;
++<<<<<<< HEAD
 +static void uv_nmi_kdump(int cpu, int master, struct pt_regs *regs)
- {
++=======
+ static void uv_nmi_kdump(int cpu, int main, struct pt_regs *regs)
++>>>>>>> 0b45143b4b94 (x86/platform/uv: Add more to secondary CPU kdump info)
+ {
+ 	/* Check if kdump kernel loaded for both main and secondary CPUs */
+ 	if (!kexec_crash_image) {
+ 		if (main)
+ 			pr_err("UV: NMI error: kdump kernel not loaded\n");
+ 		return;
+ 	}
+ 
  	/* Call crash to dump system state */
- 	if (master) {
+ 	if (main) {
  		pr_emerg("UV: NMI executing crash_kexec on CPU%d\n", cpu);
  		crash_kexec(regs);
  
++<<<<<<< HEAD
 +		pr_emerg("UV: crash_kexec unexpectedly returned, ");
 +		if (!kexec_crash_image) {
 +			pr_cont("crash kernel not loaded\n");
 +			atomic_set(&uv_nmi_kexec_failed, 1);
 +			uv_nmi_sync_exit(1);
 +			return;
 +		}
 +		pr_cont("kexec busy, stalling cpus while waiting\n");
 +	}
 +
 +	/* If crash exec fails the slaves should return, otherwise stall */
 +	while (atomic_read(&uv_nmi_kexec_failed) == 0)
 +		mdelay(10);
 +
 +	/* Crash kernel most likely not loaded, return in an orderly fashion */
 +	uv_nmi_sync_exit(0);
++=======
+ 		pr_emerg("UV: crash_kexec unexpectedly returned\n");
+ 		atomic_set(&uv_nmi_kexec_failed, 1);
+ 
+ 	} else { /* secondary */
+ 
+ 		/* If kdump kernel fails, secondaries will exit this loop */
+ 		while (atomic_read(&uv_nmi_kexec_failed) == 0) {
+ 
+ 			/* Once shootdown cpus starts, they do not return */
+ 			run_crash_ipi_callback(regs);
+ 
+ 			mdelay(10);
+ 		}
+ 	}
++>>>>>>> 0b45143b4b94 (x86/platform/uv: Add more to secondary CPU kdump info)
  }
  
  #else /* !CONFIG_KEXEC_CORE */
- static inline void uv_nmi_kdump(int cpu, int master, struct pt_regs *regs)
+ static inline void uv_nmi_kdump(int cpu, int main, struct pt_regs *regs)
  {
- 	if (master)
+ 	if (main)
  		pr_err("UV: NMI kdump: KEXEC not supported in this kernel\n");
 -	atomic_set(&uv_nmi_kexec_failed, 1);
  }
  #endif /* !CONFIG_KEXEC_CORE */
  
* Unmerged path arch/x86/platform/uv/uv_nmi.c
