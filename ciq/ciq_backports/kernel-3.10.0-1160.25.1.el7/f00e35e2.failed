virtio_net: fix virtnet_open and virtnet_probe competing for try_fill_recv

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.25.1.el7
commit-author wangyunjian <wangyunjian@huawei.com>
commit f00e35e259948b995aa1f3ee7fddb05f34a50157
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.25.1.el7/f00e35e2.failed

In function virtnet_open() and virtnet_probe(), func try_fill_recv() may
be executed at the same time. VQ in virtqueue_add() has not been protected
well and BUG_ON will be triggered when virito_net.ko being removed.

	Signed-off-by: Yunjian Wang <wangyunjian@huawei.com>
	Acked-by: Jason Wang <jasowang@redhat.com>
	Acked-by: Michael S. Tsirkin <mst@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f00e35e259948b995aa1f3ee7fddb05f34a50157)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/virtio_net.c
diff --cc drivers/net/virtio_net.c
index d5335774c60a,e0638e556fe7..000000000000
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@@ -1674,33 -1925,17 +1674,36 @@@ static int virtnet_probe(struct virtio_
  
  	virtio_device_ready(vdev);
  
++<<<<<<< HEAD
 +	/* Last of all, set up some receive buffers. */
 +	for (i = 0; i < vi->curr_queue_pairs; i++) {
 +		try_fill_recv(vi, &vi->rq[i], GFP_KERNEL);
 +
 +		/* If we didn't even get one input buffer, we're useless. */
 +		if (vi->rq[i].num == 0) {
 +			free_unused_bufs(vi);
 +			err = -ENOMEM;
 +			goto free_recv_bufs;
 +		}
 +	}
 +
++=======
++>>>>>>> f00e35e25994 (virtio_net: fix virtnet_open and virtnet_probe competing for try_fill_recv)
  	vi->nb.notifier_call = &virtnet_cpu_callback;
  	err = register_hotcpu_notifier(&vi->nb);
  	if (err) {
  		pr_debug("virtio_net: registering cpu notifier failed\n");
- 		goto free_recv_bufs;
+ 		goto free_unregister_netdev;
  	}
  
 +	rtnl_lock();
 +	virtnet_set_queues(vi, vi->curr_queue_pairs);
 +	rtnl_unlock();
 +
  	/* Assume link up if device can't report link status,
  	   otherwise get link status from config. */
 +	netif_carrier_off(dev);
  	if (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS)) {
 -		netif_carrier_off(dev);
  		schedule_work(&vi->config_work);
  	} else {
  		vi->status = VIRTIO_NET_S_LINK_UP;
@@@ -1712,15 -1947,13 +1715,14 @@@
  
  	return 0;
  
- free_recv_bufs:
+ free_unregister_netdev:
  	vi->vdev->config->reset(vdev);
  
- 	free_receive_bufs(vi);
  	unregister_netdev(dev);
 +free_failover:
 +	net_failover_destroy(vi->failover);
  free_vqs:
  	cancel_delayed_work_sync(&vi->refill);
 -	free_receive_page_frags(vi);
  	virtnet_del_vqs(vi);
  free_stats:
  	free_percpu(vi->stats);
* Unmerged path drivers/net/virtio_net.c
