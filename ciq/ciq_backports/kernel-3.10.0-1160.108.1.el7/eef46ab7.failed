gfs2: Introduce new quota=quiet mount option

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.108.1.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit eef46ab713f78591fe2cb20f5e90d9a8fdbddd59
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.108.1.el7/eef46ab7.failed

This patch adds a new mount option quota=quiet which is the same as
quota=on but it suppresses gfs2 quota error messages.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit eef46ab713f78591fe2cb20f5e90d9a8fdbddd59)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/ops_fstype.c
#	fs/gfs2/quota.c
diff --cc fs/gfs2/ops_fstype.c
index 9f53ceffe027,33ca04733e93..000000000000
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@@ -1156,124 -1333,347 +1156,317 @@@ fail_debug
  	return error;
  }
  
 +static int set_gfs2_super(struct super_block *s, void *data)
 +{
 +	s->s_bdev = data;
 +	s->s_dev = s->s_bdev->bd_dev;
 +
 +	/*
 +	 * We set the bdi here to the queue backing, file systems can
 +	 * overwrite this in ->fill_super()
 +	 */
 +	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
 +	return 0;
 +}
 +
 +static int test_gfs2_super(struct super_block *s, void *ptr)
 +{
 +	struct block_device *bdev = ptr;
 +	return (bdev == s->s_bdev);
 +}
 +
  /**
 - * gfs2_get_tree - Get the GFS2 superblock and root directory
 - * @fc: The filesystem context
 + * gfs2_mount - Get the GFS2 superblock
 + * @fs_type: The GFS2 filesystem type
 + * @flags: Mount flags
 + * @dev_name: The name of the device
 + * @data: The mount arguments
 + *
 + * Q. Why not use get_sb_bdev() ?
 + * A. We need to select one of two root directories to mount, independent
 + *    of whether this is the initial, or subsequent, mount of this sb
   *
 - * Returns: 0 or -errno on error
 + * Returns: 0 or -ve on error
   */
 -static int gfs2_get_tree(struct fs_context *fc)
 +
 +static struct dentry *gfs2_mount(struct file_system_type *fs_type, int flags,
 +		       const char *dev_name, void *data)
  {
 -	struct gfs2_args *args = fc->fs_private;
 -	struct gfs2_sbd *sdp;
 +	struct block_device *bdev;
 +	struct super_block *s;
 +	fmode_t mode = FMODE_READ | FMODE_EXCL;
  	int error;
 +	struct gfs2_args args;
 +	struct gfs2_sbd *sdp;
  
 -	error = get_tree_bdev(fc, gfs2_fill_super);
 -	if (error)
 -		return error;
 -
 -	sdp = fc->root->d_sb->s_fs_info;
 -	dput(fc->root);
 -	if (args->ar_meta)
 -		fc->root = dget(sdp->sd_master_dir);
 -	else
 -		fc->root = dget(sdp->sd_root_dir);
 -	return 0;
 -}
 +	if (!(flags & MS_RDONLY))
 +		mode |= FMODE_WRITE;
  
 -static void gfs2_fc_free(struct fs_context *fc)
 -{
 -	struct gfs2_args *args = fc->fs_private;
 +	bdev = blkdev_get_by_path(dev_name, mode, fs_type);
 +	if (IS_ERR(bdev))
 +		return ERR_CAST(bdev);
  
 +	/*
 +	 * once the super is inserted into the list by sget, s_umount
 +	 * will protect the lockfs code from trying to start a snapshot
 +	 * while we are mounting
 +	 */
 +	mutex_lock(&bdev->bd_fsfreeze_mutex);
 +	if (bdev->bd_fsfreeze_count > 0) {
 +		mutex_unlock(&bdev->bd_fsfreeze_mutex);
 +		error = -EBUSY;
 +		goto error_bdev;
 +	}
 +	s = sget(fs_type, test_gfs2_super, set_gfs2_super, flags, bdev);
 +	mutex_unlock(&bdev->bd_fsfreeze_mutex);
 +	error = PTR_ERR(s);
 +	if (IS_ERR(s))
 +		goto error_bdev;
 +
 +	if (s->s_root)
 +		blkdev_put(bdev, mode);
 +	else
 +		/* s_mode must be set before deactivate_locked_super calls */
 +		s->s_mode = mode;
 +
 +	memset(&args, 0, sizeof(args));
 +	args.ar_quota = GFS2_QUOTA_DEFAULT;
 +	args.ar_data = GFS2_DATA_DEFAULT;
 +	args.ar_commit = 30;
 +	args.ar_statfs_quantum = 30;
 +	args.ar_quota_quantum = 60;
 +	args.ar_errors = GFS2_ERRORS_DEFAULT;
 +
++<<<<<<< HEAD
 +	error = gfs2_mount_args(&args, data);
 +	if (error) {
 +		pr_warn("can't parse mount arguments\n");
 +		goto error_super;
++=======
+ 	kfree(args);
+ }
+ 
+ enum gfs2_param {
+ 	Opt_lockproto,
+ 	Opt_locktable,
+ 	Opt_hostdata,
+ 	Opt_spectator,
+ 	Opt_ignore_local_fs,
+ 	Opt_localflocks,
+ 	Opt_localcaching,
+ 	Opt_debug,
+ 	Opt_upgrade,
+ 	Opt_acl,
+ 	Opt_quota,
+ 	Opt_quota_flag,
+ 	Opt_suiddir,
+ 	Opt_data,
+ 	Opt_meta,
+ 	Opt_discard,
+ 	Opt_commit,
+ 	Opt_errors,
+ 	Opt_statfs_quantum,
+ 	Opt_statfs_percent,
+ 	Opt_quota_quantum,
+ 	Opt_barrier,
+ 	Opt_rgrplvb,
+ 	Opt_loccookie,
+ };
+ 
+ static const struct constant_table gfs2_param_quota[] = {
+ 	{"off",        GFS2_QUOTA_OFF},
+ 	{"account",    GFS2_QUOTA_ACCOUNT},
+ 	{"on",         GFS2_QUOTA_ON},
+ 	{"quiet",      GFS2_QUOTA_QUIET},
+ 	{}
+ };
+ 
+ enum opt_data {
+ 	Opt_data_writeback = GFS2_DATA_WRITEBACK,
+ 	Opt_data_ordered   = GFS2_DATA_ORDERED,
+ };
+ 
+ static const struct constant_table gfs2_param_data[] = {
+ 	{"writeback",  Opt_data_writeback },
+ 	{"ordered",    Opt_data_ordered },
+ 	{}
+ };
+ 
+ enum opt_errors {
+ 	Opt_errors_withdraw = GFS2_ERRORS_WITHDRAW,
+ 	Opt_errors_panic    = GFS2_ERRORS_PANIC,
+ };
+ 
+ static const struct constant_table gfs2_param_errors[] = {
+ 	{"withdraw",   Opt_errors_withdraw },
+ 	{"panic",      Opt_errors_panic },
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec gfs2_fs_parameters[] = {
+ 	fsparam_string ("lockproto",          Opt_lockproto),
+ 	fsparam_string ("locktable",          Opt_locktable),
+ 	fsparam_string ("hostdata",           Opt_hostdata),
+ 	fsparam_flag   ("spectator",          Opt_spectator),
+ 	fsparam_flag   ("norecovery",         Opt_spectator),
+ 	fsparam_flag   ("ignore_local_fs",    Opt_ignore_local_fs),
+ 	fsparam_flag   ("localflocks",        Opt_localflocks),
+ 	fsparam_flag   ("localcaching",       Opt_localcaching),
+ 	fsparam_flag_no("debug",              Opt_debug),
+ 	fsparam_flag   ("upgrade",            Opt_upgrade),
+ 	fsparam_flag_no("acl",                Opt_acl),
+ 	fsparam_flag_no("suiddir",            Opt_suiddir),
+ 	fsparam_enum   ("data",               Opt_data, gfs2_param_data),
+ 	fsparam_flag   ("meta",               Opt_meta),
+ 	fsparam_flag_no("discard",            Opt_discard),
+ 	fsparam_s32    ("commit",             Opt_commit),
+ 	fsparam_enum   ("errors",             Opt_errors, gfs2_param_errors),
+ 	fsparam_s32    ("statfs_quantum",     Opt_statfs_quantum),
+ 	fsparam_s32    ("statfs_percent",     Opt_statfs_percent),
+ 	fsparam_s32    ("quota_quantum",      Opt_quota_quantum),
+ 	fsparam_flag_no("barrier",            Opt_barrier),
+ 	fsparam_flag_no("rgrplvb",            Opt_rgrplvb),
+ 	fsparam_flag_no("loccookie",          Opt_loccookie),
+ 	/* quota can be a flag or an enum so it gets special treatment */
+ 	fsparam_flag_no("quota",	      Opt_quota_flag),
+ 	fsparam_enum("quota",		      Opt_quota, gfs2_param_quota),
+ 	{}
+ };
+ 
+ /* Parse a single mount parameter */
+ static int gfs2_parse_param(struct fs_context *fc, struct fs_parameter *param)
+ {
+ 	struct gfs2_args *args = fc->fs_private;
+ 	struct fs_parse_result result;
+ 	int o;
+ 
+ 	o = fs_parse(fc, gfs2_fs_parameters, param, &result);
+ 	if (o < 0)
+ 		return o;
+ 
+ 	switch (o) {
+ 	case Opt_lockproto:
+ 		strscpy(args->ar_lockproto, param->string, GFS2_LOCKNAME_LEN);
+ 		break;
+ 	case Opt_locktable:
+ 		strscpy(args->ar_locktable, param->string, GFS2_LOCKNAME_LEN);
+ 		break;
+ 	case Opt_hostdata:
+ 		strscpy(args->ar_hostdata, param->string, GFS2_LOCKNAME_LEN);
+ 		break;
+ 	case Opt_spectator:
+ 		args->ar_spectator = 1;
+ 		break;
+ 	case Opt_ignore_local_fs:
+ 		/* Retained for backwards compat only */
+ 		break;
+ 	case Opt_localflocks:
+ 		args->ar_localflocks = 1;
+ 		break;
+ 	case Opt_localcaching:
+ 		/* Retained for backwards compat only */
+ 		break;
+ 	case Opt_debug:
+ 		if (result.boolean && args->ar_errors == GFS2_ERRORS_PANIC)
+ 			return invalfc(fc, "-o debug and -o errors=panic are mutually exclusive");
+ 		args->ar_debug = result.boolean;
+ 		break;
+ 	case Opt_upgrade:
+ 		/* Retained for backwards compat only */
+ 		break;
+ 	case Opt_acl:
+ 		args->ar_posix_acl = result.boolean;
+ 		break;
+ 	case Opt_quota_flag:
+ 		args->ar_quota = result.negated ? GFS2_QUOTA_OFF : GFS2_QUOTA_ON;
+ 		break;
+ 	case Opt_quota:
+ 		args->ar_quota = result.int_32;
+ 		break;
+ 	case Opt_suiddir:
+ 		args->ar_suiddir = result.boolean;
+ 		break;
+ 	case Opt_data:
+ 		/* The uint_32 result maps directly to GFS2_DATA_* */
+ 		args->ar_data = result.uint_32;
+ 		break;
+ 	case Opt_meta:
+ 		args->ar_meta = 1;
+ 		break;
+ 	case Opt_discard:
+ 		args->ar_discard = result.boolean;
+ 		break;
+ 	case Opt_commit:
+ 		if (result.int_32 <= 0)
+ 			return invalfc(fc, "commit mount option requires a positive numeric argument");
+ 		args->ar_commit = result.int_32;
+ 		break;
+ 	case Opt_statfs_quantum:
+ 		if (result.int_32 < 0)
+ 			return invalfc(fc, "statfs_quantum mount option requires a non-negative numeric argument");
+ 		args->ar_statfs_quantum = result.int_32;
+ 		break;
+ 	case Opt_quota_quantum:
+ 		if (result.int_32 <= 0)
+ 			return invalfc(fc, "quota_quantum mount option requires a positive numeric argument");
+ 		args->ar_quota_quantum = result.int_32;
+ 		break;
+ 	case Opt_statfs_percent:
+ 		if (result.int_32 < 0 || result.int_32 > 100)
+ 			return invalfc(fc, "statfs_percent mount option requires a numeric argument between 0 and 100");
+ 		args->ar_statfs_percent = result.int_32;
+ 		break;
+ 	case Opt_errors:
+ 		if (args->ar_debug && result.uint_32 == GFS2_ERRORS_PANIC)
+ 			return invalfc(fc, "-o debug and -o errors=panic are mutually exclusive");
+ 		args->ar_errors = result.uint_32;
+ 		break;
+ 	case Opt_barrier:
+ 		args->ar_nobarrier = result.boolean;
+ 		break;
+ 	case Opt_rgrplvb:
+ 		args->ar_rgrplvb = result.boolean;
+ 		args->ar_got_rgrplvb = 1;
+ 		break;
+ 	case Opt_loccookie:
+ 		args->ar_loccookie = result.boolean;
+ 		break;
+ 	default:
+ 		return invalfc(fc, "invalid mount option: %s", param->key);
++>>>>>>> eef46ab713f7 (gfs2: Introduce new quota=quiet mount option)
  	}
 -	return 0;
 -}
 -
 -static int gfs2_reconfigure(struct fs_context *fc)
 -{
 -	struct super_block *sb = fc->root->d_sb;
 -	struct gfs2_sbd *sdp = sb->s_fs_info;
 -	struct gfs2_args *oldargs = &sdp->sd_args;
 -	struct gfs2_args *newargs = fc->fs_private;
 -	struct gfs2_tune *gt = &sdp->sd_tune;
 -	int error = 0;
 -
 -	sync_filesystem(sb);
  
 -	spin_lock(&gt->gt_spin);
 -	oldargs->ar_commit = gt->gt_logd_secs;
 -	oldargs->ar_quota_quantum = gt->gt_quota_quantum;
 -	if (gt->gt_statfs_slow)
 -		oldargs->ar_statfs_quantum = 0;
 -	else
 -		oldargs->ar_statfs_quantum = gt->gt_statfs_quantum;
 -	spin_unlock(&gt->gt_spin);
 +	if (s->s_root) {
 +		error = -EBUSY;
 +		if ((flags ^ s->s_flags) & MS_RDONLY)
 +			goto error_super;
 +	} else {
 +		char b[BDEVNAME_SIZE];
  
 -	if (strcmp(newargs->ar_lockproto, oldargs->ar_lockproto)) {
 -		errorfc(fc, "reconfiguration of locking protocol not allowed");
 -		return -EINVAL;
 -	}
 -	if (strcmp(newargs->ar_locktable, oldargs->ar_locktable)) {
 -		errorfc(fc, "reconfiguration of lock table not allowed");
 -		return -EINVAL;
 -	}
 -	if (strcmp(newargs->ar_hostdata, oldargs->ar_hostdata)) {
 -		errorfc(fc, "reconfiguration of host data not allowed");
 -		return -EINVAL;
 -	}
 -	if (newargs->ar_spectator != oldargs->ar_spectator) {
 -		errorfc(fc, "reconfiguration of spectator mode not allowed");
 -		return -EINVAL;
 -	}
 -	if (newargs->ar_localflocks != oldargs->ar_localflocks) {
 -		errorfc(fc, "reconfiguration of localflocks not allowed");
 -		return -EINVAL;
 -	}
 -	if (newargs->ar_meta != oldargs->ar_meta) {
 -		errorfc(fc, "switching between gfs2 and gfs2meta not allowed");
 -		return -EINVAL;
 -	}
 -	if (oldargs->ar_spectator)
 -		fc->sb_flags |= SB_RDONLY;
 -
 -	if ((sb->s_flags ^ fc->sb_flags) & SB_RDONLY) {
 -		if (fc->sb_flags & SB_RDONLY) {
 -			gfs2_make_fs_ro(sdp);
 -		} else {
 -			error = gfs2_make_fs_rw(sdp);
 -			if (error)
 -				errorfc(fc, "unable to remount read-write");
 -		}
 +		strlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));
 +		sb_set_blocksize(s, block_size(bdev));
 +		error = fill_super(s, &args, flags & MS_SILENT ? 1 : 0);
 +		if (error)
 +			goto error_super;
 +		s->s_flags |= MS_ACTIVE;
 +		bdev->bd_super = s;
  	}
 -	sdp->sd_args = *newargs;
  
 -	if (sdp->sd_args.ar_posix_acl)
 -		sb->s_flags |= SB_POSIXACL;
 -	else
 -		sb->s_flags &= ~SB_POSIXACL;
 -	if (sdp->sd_args.ar_nobarrier)
 -		set_bit(SDF_NOBARRIERS, &sdp->sd_flags);
 +	sdp = s->s_fs_info;
 +	if (args.ar_meta)
 +		return dget(sdp->sd_master_dir);
  	else
 -		clear_bit(SDF_NOBARRIERS, &sdp->sd_flags);
 -	spin_lock(&gt->gt_spin);
 -	gt->gt_logd_secs = newargs->ar_commit;
 -	gt->gt_quota_quantum = newargs->ar_quota_quantum;
 -	if (newargs->ar_statfs_quantum) {
 -		gt->gt_statfs_slow = 0;
 -		gt->gt_statfs_quantum = newargs->ar_statfs_quantum;
 -	}
 -	else {
 -		gt->gt_statfs_slow = 1;
 -		gt->gt_statfs_quantum = 30;
 -	}
 -	spin_unlock(&gt->gt_spin);
 -
 -	gfs2_online_uevent(sdp);
 -	return error;
 +		return dget(sdp->sd_root_dir);
 +
 +error_super:
 +	deactivate_locked_super(s);
 +	return ERR_PTR(error);
 +error_bdev:
 +	blkdev_put(bdev, mode);
 +	return ERR_PTR(error);
  }
  
 -static const struct fs_context_operations gfs2_context_ops = {
 -	.free        = gfs2_fc_free,
 -	.parse_param = gfs2_parse_param,
 -	.get_tree    = gfs2_get_tree,
 -	.reconfigure = gfs2_reconfigure,
 -};
 -
 -/* Set up the filesystem mount context */
 -static int gfs2_init_fs_context(struct fs_context *fc)
 -{
 -	struct gfs2_args *args;
 -
 -	args = kmalloc(sizeof(*args), GFP_KERNEL);
 -	if (args == NULL)
 -		return -ENOMEM;
 -
 -	if (fc->purpose == FS_CONTEXT_FOR_RECONFIGURE) {
 -		struct gfs2_sbd *sdp = fc->root->d_sb->s_fs_info;
 -
 -		*args = sdp->sd_args;
 -	} else {
 -		memset(args, 0, sizeof(*args));
 -		args->ar_quota = GFS2_QUOTA_DEFAULT;
 -		args->ar_data = GFS2_DATA_DEFAULT;
 -		args->ar_commit = 30;
 -		args->ar_statfs_quantum = 30;
 -		args->ar_quota_quantum = 60;
 -		args->ar_errors = GFS2_ERRORS_DEFAULT;
 -	}
 -	fc->fs_private = args;
 -	fc->ops = &gfs2_context_ops;
 -	return 0;
 -}
 -
 -static int set_meta_super(struct super_block *s, struct fs_context *fc)
 +static int set_meta_super(struct super_block *s, void *ptr)
  {
  	return -EINVAL;
  }
diff --cc fs/gfs2/quota.c
index ffbdb85ffe96,0cc585064eae..000000000000
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@@ -1163,12 -1201,13 +1164,20 @@@ void gfs2_quota_unlock(struct gfs2_inod
  
  static int print_message(struct gfs2_quota_data *qd, char *type)
  {
 -	struct gfs2_sbd *sdp = qd->qd_sbd;
 -
 +	struct gfs2_sbd *sdp = qd->qd_gl->gl_name.ln_sbd;
 +
++<<<<<<< HEAD
 +	pr_info("fsid=%s: quota %s for %s %u\n",
 +		sdp->sd_fsname, type,
 +		(qd->qd_id.type == USRQUOTA) ? "user" : "group",
 +		from_kqid(&init_user_ns, qd->qd_id));
++=======
+ 	if (sdp->sd_args.ar_quota != GFS2_QUOTA_QUIET)
+ 		fs_info(sdp, "quota %s for %s %u\n",
+ 			type,
+ 			(qd->qd_id.type == USRQUOTA) ? "user" : "group",
+ 			from_kqid(&init_user_ns, qd->qd_id));
++>>>>>>> eef46ab713f7 (gfs2: Introduce new quota=quiet mount option)
  
  	return 0;
  }
@@@ -1595,15 -1601,20 +1605,17 @@@ static int gfs2_quota_get_xstate(struc
  {
  	struct gfs2_sbd *sdp = sb->s_fs_info;
  
 -	memset(state, 0, sizeof(*state));
 +	memset(fqs, 0, sizeof(struct fs_quota_stat));
 +	fqs->qs_version = FS_QSTAT_VERSION;
  
  	switch (sdp->sd_args.ar_quota) {
+ 	case GFS2_QUOTA_QUIET:
+ 		fallthrough;
  	case GFS2_QUOTA_ON:
 -		state->s_state[USRQUOTA].flags |= QCI_LIMITS_ENFORCED;
 -		state->s_state[GRPQUOTA].flags |= QCI_LIMITS_ENFORCED;
 -		fallthrough;
 +		fqs->qs_flags |= (FS_QUOTA_UDQ_ENFD | FS_QUOTA_GDQ_ENFD);
 +		/*FALLTHRU*/
  	case GFS2_QUOTA_ACCOUNT:
 -		state->s_state[USRQUOTA].flags |= QCI_ACCT_ENABLED |
 -						  QCI_SYSFILE;
 -		state->s_state[GRPQUOTA].flags |= QCI_ACCT_ENABLED |
 -						  QCI_SYSFILE;
 +		fqs->qs_flags |= (FS_QUOTA_UDQ_ACCT | FS_QUOTA_GDQ_ACCT);
  		break;
  	case GFS2_QUOTA_OFF:
  		break;
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 5c3c5f98d07d..2b6e505dfbca 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -551,6 +551,7 @@ struct gfs2_statfs_change_host {
 #define GFS2_QUOTA_OFF		0
 #define GFS2_QUOTA_ACCOUNT	1
 #define GFS2_QUOTA_ON		2
+#define GFS2_QUOTA_QUIET	3 /* on but not complaining */
 
 #define GFS2_DATA_DEFAULT	GFS2_DATA_ORDERED
 #define GFS2_DATA_WRITEBACK	1
* Unmerged path fs/gfs2/ops_fstype.c
* Unmerged path fs/gfs2/quota.c
diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c
index 6429e3ef1e6d..0a8dfcb82904 100644
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@ -1365,6 +1365,9 @@ static int gfs2_show_options(struct seq_file *s, struct dentry *root)
 		case GFS2_QUOTA_ON:
 			state = "on";
 			break;
+		case GFS2_QUOTA_QUIET:
+			state = "quiet";
+			break;
 		default:
 			state = "unknown";
 			break;
