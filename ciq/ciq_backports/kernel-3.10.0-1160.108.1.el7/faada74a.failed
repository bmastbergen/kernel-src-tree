gfs2: Factor out duplicate quota data disposal code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.108.1.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit faada74a90563183cb57af3e4604ed183d71a81c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.108.1.el7/faada74a.failed

Rename gfs2_qd_dispose() to gfs2_qd_dispose_list().  Move some code
duplicated in gfs2_qd_dispose_list() and gfs2_quota_cleanup() into a
new gfs2_qd_dispose() function.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit faada74a90563183cb57af3e4604ed183d71a81c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/quota.c
diff --cc fs/gfs2/quota.c
index 60badd875cf9,01fae6b030e9..000000000000
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@@ -118,29 -138,10 +138,15 @@@ static void gfs2_qd_list_dispose(struc
  
  	while (!list_empty(list)) {
  		qd = list_first_entry(list, struct gfs2_quota_data, qd_lru);
++<<<<<<< HEAD
 +		sdp = qd->qd_gl->gl_name.ln_sbd;
 +
++=======
++>>>>>>> faada74a9056 (gfs2: Factor out duplicate quota data disposal code)
  		list_del(&qd->qd_lru);
  
- 		/* Free from the filesystem-specific list */
- 		spin_lock(&qd_lock);
- 		list_del(&qd->qd_list);
- 		spin_unlock(&qd_lock);
- 
- 		spin_lock_bucket(qd->qd_hash);
- 		hlist_bl_del_rcu(&qd->qd_hlist);
- 		spin_unlock_bucket(qd->qd_hash);
- 
- 		gfs2_assert_warn(sdp, !qd->qd_change);
- 		gfs2_assert_warn(sdp, !qd->qd_slot_count);
- 		gfs2_assert_warn(sdp, !qd->qd_bh_count);
- 
- 		gfs2_glock_put(qd->qd_gl);
+ 		gfs2_qd_dispose(qd);
  		atomic_dec(&sdp->sd_quota_count);
- 
- 		/* Delete it from the common reclaim list */
- 		call_rcu(&qd->qd_rcu, gfs2_qd_dealloc);
  	}
  }
  
@@@ -158,26 -165,30 +164,26 @@@ static enum lru_status gfs2_qd_isolate(
  	}
  
  	spin_unlock(&qd->qd_lockref.lock);
 -	return status;
 +	return LRU_REMOVED;
  }
  
 -static unsigned long gfs2_qd_shrink_scan(struct shrinker *shrink,
 -					 struct shrink_control *sc)
 +static int gfs2_shrink_qd_memory(struct shrinker *shrink,
 +				 struct shrink_control *sc)
  {
  	LIST_HEAD(dispose);
 -	unsigned long freed;
 +
 +	if (sc->nr_to_scan == 0)
 +		goto out;
  
  	if (!(sc->gfp_mask & __GFP_FS))
 -		return SHRINK_STOP;
 +		return -1;
  
 -	freed = list_lru_shrink_walk(&gfs2_qd_lru, sc,
 -				     gfs2_qd_isolate, &dispose);
 +	list_lru_walk(&gfs2_qd_lru, gfs2_qd_isolate, &dispose, sc->nr_to_scan);
  
- 	gfs2_qd_dispose(&dispose);
+ 	gfs2_qd_list_dispose(&dispose);
  
 -	return freed;
 -}
 -
 -static unsigned long gfs2_qd_shrink_count(struct shrinker *shrink,
 -					  struct shrink_control *sc)
 -{
 -	return vfs_pressure_ratio(list_lru_shrink_count(&gfs2_qd_lru, sc));
 +out:
 +	return (list_lru_count(&gfs2_qd_lru) * sysctl_vfs_cache_pressure) / 100;
  }
  
  struct shrinker gfs2_qd_shrinker = {
* Unmerged path fs/gfs2/quota.c
