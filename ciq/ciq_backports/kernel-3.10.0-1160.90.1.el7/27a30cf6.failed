NFSv4.1: Fix open stateid recovery

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.90.1.el7
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 27a30cf64a5cbe2105e4ff9613246b32d584766a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.90.1.el7/27a30cf6.failed

The logic for checking in nfs41_check_open_stateid() whether the state
is supported by a delegation is inverted. In addition, it makes more
sense to perform that check before we check for expired locks.

Fixes: 8a64c4ef106d1 ("NFSv4.1: Even if the stateid is OK,...")
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 27a30cf64a5cbe2105e4ff9613246b32d584766a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/nfs4proc.c
index 61605f2d90f2,c9e14ce0b7b2..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -2625,8 -2749,8 +2630,13 @@@ static int nfs41_check_delegation_state
  	struct nfs_server *server = NFS_SERVER(state->inode);
  	nfs4_stateid stateid;
  	struct nfs_delegation *delegation;
++<<<<<<< HEAD
 +	struct rpc_cred *cred;
 +	int status;
++=======
+ 	const struct cred *cred = NULL;
+ 	int status, ret = NFS_OK;
++>>>>>>> 27a30cf64a5c (NFSv4.1: Fix open stateid recovery)
  
  	/* Get the delegation credential for use by test/free_stateid */
  	rcu_read_lock();
@@@ -2647,17 -2766,34 +2652,37 @@@
  	if (!test_and_clear_bit(NFS_DELEGATION_TEST_EXPIRED,
  				&delegation->flags)) {
  		rcu_read_unlock();
- 		return;
+ 		return NFS_OK;
  	}
  
 -	if (delegation->cred)
 -		cred = get_cred(delegation->cred);
 +	cred = get_rpccred(delegation->cred);
  	rcu_read_unlock();
  	status = nfs41_test_and_free_expired_stateid(server, &stateid, cred);
  	trace_nfs4_test_delegation_stateid(state, NULL, status);
  	if (status == -NFS4ERR_EXPIRED || status == -NFS4ERR_BAD_STATEID)
  		nfs_finish_clear_delegation_stateid(state, &stateid);
+ 	else
+ 		ret = status;
  
++<<<<<<< HEAD
 +	put_rpccred(cred);
++=======
+ 	put_cred(cred);
+ 	return ret;
+ }
+ 
+ static void nfs41_delegation_recover_stateid(struct nfs4_state *state)
+ {
+ 	nfs4_stateid tmp;
+ 
+ 	if (test_bit(NFS_DELEGATED_STATE, &state->flags) &&
+ 	    nfs4_copy_delegation_stateid(state->inode, state->state,
+ 				&tmp, NULL) &&
+ 	    nfs4_stateid_match_other(&state->stateid, &tmp))
+ 		nfs_state_set_delegation(state, &tmp, state->state);
+ 	else
+ 		nfs_state_clear_delegation(state);
++>>>>>>> 27a30cf64a5c (NFSv4.1: Fix open stateid recovery)
  }
  
  /**
@@@ -2724,28 -2860,18 +2749,19 @@@ static int nfs41_check_open_stateid(str
  {
  	struct nfs_server *server = NFS_SERVER(state->inode);
  	nfs4_stateid *stateid = &state->open_stateid;
 -	const struct cred *cred = state->owner->so_cred;
 +	struct rpc_cred *cred = state->owner->so_cred;
  	int status;
  
- 	if (test_bit(NFS_OPEN_STATE, &state->flags) == 0) {
- 		if (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)  {
- 			if (nfs4_have_delegation(state->inode, state->state))
- 				return NFS_OK;
- 			return -NFS4ERR_OPENMODE;
- 		}
+ 	if (test_bit(NFS_OPEN_STATE, &state->flags) == 0)
  		return -NFS4ERR_BAD_STATEID;
- 	}
  	status = nfs41_test_and_free_expired_stateid(server, stateid, cred);
  	trace_nfs4_test_open_stateid(state, NULL, status);
  	if (status == -NFS4ERR_EXPIRED || status == -NFS4ERR_BAD_STATEID) {
- 		clear_bit(NFS_O_RDONLY_STATE, &state->flags);
- 		clear_bit(NFS_O_WRONLY_STATE, &state->flags);
- 		clear_bit(NFS_O_RDWR_STATE, &state->flags);
- 		clear_bit(NFS_OPEN_STATE, &state->flags);
+ 		nfs_state_clear_open_state_flags(state);
  		stateid->type = NFS4_INVALID_STATEID_TYPE;
 -		return status;
  	}
 +	if (status != NFS_OK)
 +		return status;
  	if (nfs_open_stateid_recover_openmode(state))
  		return -NFS4ERR_OPENMODE;
  	return NFS_OK;
* Unmerged path fs/nfs/nfs4proc.c
