x86,objtool: Create .return_sites

jira LE-1907
cve CVE-2022-29901
cve CVE-2022-29900
cve CVE-2022-23825
cve CVE-2022-23816
Rebuild_History Non-Buildable kernel-3.10.0-1160.80.1.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit d9e9d2300681d68a775c28de6aa6e5290ae17796
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.80.1.el7/d9e9d230.failed

Find all the return-thunk sites and record them in a .return_sites
section such that the kernel can undo this.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Josh Poimboeuf <jpoimboe@kernel.org>
	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit d9e9d2300681d68a775c28de6aa6e5290ae17796)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/objtool/arch/x86/decode.c
#	tools/objtool/check.c
#	tools/objtool/include/objtool/arch.h
#	tools/objtool/include/objtool/elf.h
#	tools/objtool/include/objtool/objtool.h
#	tools/objtool/objtool.c
diff --cc tools/objtool/arch/x86/decode.c
index c0c0b265e88e,c260006106be..000000000000
--- a/tools/objtool/arch/x86/decode.c
+++ b/tools/objtool/arch/x86/decode.c
@@@ -170,3 -692,103 +170,106 @@@ int arch_decode_instruction(struct elf 
  
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ void arch_initial_func_cfi_state(struct cfi_init_state *state)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < CFI_NUM_REGS; i++) {
+ 		state->regs[i].base = CFI_UNDEFINED;
+ 		state->regs[i].offset = 0;
+ 	}
+ 
+ 	/* initial CFA (call frame address) */
+ 	state->cfa.base = CFI_SP;
+ 	state->cfa.offset = 8;
+ 
+ 	/* initial RA (return address) */
+ 	state->regs[CFI_RA].base = CFI_CFA;
+ 	state->regs[CFI_RA].offset = -8;
+ }
+ 
+ const char *arch_nop_insn(int len)
+ {
+ 	static const char nops[5][5] = {
+ 		{ BYTES_NOP1 },
+ 		{ BYTES_NOP2 },
+ 		{ BYTES_NOP3 },
+ 		{ BYTES_NOP4 },
+ 		{ BYTES_NOP5 },
+ 	};
+ 
+ 	if (len < 1 || len > 5) {
+ 		WARN("invalid NOP size: %d\n", len);
+ 		return NULL;
+ 	}
+ 
+ 	return nops[len-1];
+ }
+ 
+ #define BYTE_RET	0xC3
+ 
+ const char *arch_ret_insn(int len)
+ {
+ 	static const char ret[5][5] = {
+ 		{ BYTE_RET },
+ 		{ BYTE_RET, 0xcc },
+ 		{ BYTE_RET, 0xcc, BYTES_NOP1 },
+ 		{ BYTE_RET, 0xcc, BYTES_NOP2 },
+ 		{ BYTE_RET, 0xcc, BYTES_NOP3 },
+ 	};
+ 
+ 	if (len < 1 || len > 5) {
+ 		WARN("invalid RET size: %d\n", len);
+ 		return NULL;
+ 	}
+ 
+ 	return ret[len-1];
+ }
+ 
+ int arch_decode_hint_reg(u8 sp_reg, int *base)
+ {
+ 	switch (sp_reg) {
+ 	case ORC_REG_UNDEFINED:
+ 		*base = CFI_UNDEFINED;
+ 		break;
+ 	case ORC_REG_SP:
+ 		*base = CFI_SP;
+ 		break;
+ 	case ORC_REG_BP:
+ 		*base = CFI_BP;
+ 		break;
+ 	case ORC_REG_SP_INDIRECT:
+ 		*base = CFI_SP_INDIRECT;
+ 		break;
+ 	case ORC_REG_R10:
+ 		*base = CFI_R10;
+ 		break;
+ 	case ORC_REG_R13:
+ 		*base = CFI_R13;
+ 		break;
+ 	case ORC_REG_DI:
+ 		*base = CFI_DI;
+ 		break;
+ 	case ORC_REG_DX:
+ 		*base = CFI_DX;
+ 		break;
+ 	default:
+ 		return -1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ bool arch_is_retpoline(struct symbol *sym)
+ {
+ 	return !strncmp(sym->name, "__x86_indirect_", 15);
+ }
+ 
+ bool arch_is_rethunk(struct symbol *sym)
+ {
+ 	return !strcmp(sym->name, "__x86_return_thunk");
+ }
++>>>>>>> d9e9d2300681 (x86,objtool: Create .return_sites)
diff --cc tools/objtool/objtool.c
index ecc5b1b5d15d,a7ecc32e3512..000000000000
--- a/tools/objtool/objtool.c
+++ b/tools/objtool/objtool.c
@@@ -33,85 -12,130 +33,110 @@@
  #include <subcmd/pager.h>
  #include <linux/kernel.h>
  
 -#include <objtool/builtin.h>
 -#include <objtool/objtool.h>
 -#include <objtool/warn.h>
 -
 -bool help;
 -
 -const char *objname;
 -static struct objtool_file file;
 +#include "builtin.h"
  
 -static bool objtool_create_backup(const char *_objname)
 -{
 -	int len = strlen(_objname);
 -	char *buf, *base, *name = malloc(len+6);
 -	int s, d, l, t;
 +struct cmd_struct {
 +	const char *name;
 +	int (*fn)(int, const char **);
 +	const char *help;
 +};
  
 -	if (!name) {
 -		perror("failed backup name malloc");
 -		return false;
 -	}
 +static const char objtool_usage_string[] =
 +	"objtool [OPTIONS] COMMAND [ARGS]";
  
 -	strcpy(name, _objname);
 -	strcpy(name + len, ".orig");
 +static struct cmd_struct objtool_cmds[] = {
 +	{"check",	cmd_check,	"Perform stack metadata validation on an object file" },
 +};
  
 -	d = open(name, O_CREAT|O_WRONLY|O_TRUNC, 0644);
 -	if (d < 0) {
 -		perror("failed to create backup file");
 -		return false;
 -	}
 +bool help;
  
 -	s = open(_objname, O_RDONLY);
 -	if (s < 0) {
 -		perror("failed to open orig file");
 -		return false;
 -	}
 +static void cmd_usage(void)
 +{
 +	unsigned int i, longest = 0;
  
 -	buf = malloc(4096);
 -	if (!buf) {
 -		perror("failed backup data malloc");
 -		return false;
 -	}
 +	printf("\n usage: %s\n\n", objtool_usage_string);
  
 -	while ((l = read(s, buf, 4096)) > 0) {
 -		base = buf;
 -		do {
 -			t = write(d, base, l);
 -			if (t < 0) {
 -				perror("failed backup write");
 -				return false;
 -			}
 -			base += t;
 -			l -= t;
 -		} while (l);
 +	for (i = 0; i < ARRAY_SIZE(objtool_cmds); i++) {
 +		if (longest < strlen(objtool_cmds[i].name))
 +			longest = strlen(objtool_cmds[i].name);
  	}
  
 -	if (l < 0) {
 -		perror("failed backup read");
 -		return false;
 +	puts(" Commands:");
 +	for (i = 0; i < ARRAY_SIZE(objtool_cmds); i++) {
 +		printf("   %-*s   ", longest, objtool_cmds[i].name);
 +		puts(objtool_cmds[i].help);
  	}
  
 -	free(name);
 -	free(buf);
 -	close(d);
 -	close(s);
 +	printf("\n");
  
 -	return true;
 +	exit(1);
  }
  
 -struct objtool_file *objtool_open_read(const char *_objname)
 +static void handle_options(int *argc, const char ***argv)
  {
 -	if (objname) {
 -		if (strcmp(objname, _objname)) {
 -			WARN("won't handle more than one file at a time");
 -			return NULL;
 +	while (*argc > 0) {
 +		const char *cmd = (*argv)[0];
 +
 +		if (cmd[0] != '-')
 +			break;
 +
 +		if (!strcmp(cmd, "--help") || !strcmp(cmd, "-h")) {
 +			help = true;
 +			break;
 +		} else {
 +			fprintf(stderr, "Unknown option: %s\n", cmd);
 +			fprintf(stderr, "\n Usage: %s\n",
 +				objtool_usage_string);
 +			exit(1);
  		}
 -		return &file;
 +
 +		(*argv)++;
 +		(*argc)--;
  	}
++<<<<<<< HEAD
++=======
+ 	objname = _objname;
+ 
+ 	file.elf = elf_open_read(objname, O_RDWR);
+ 	if (!file.elf)
+ 		return NULL;
+ 
+ 	if (opts.backup && !objtool_create_backup(objname)) {
+ 		WARN("can't create backup file");
+ 		return NULL;
+ 	}
+ 
+ 	INIT_LIST_HEAD(&file.insn_list);
+ 	hash_init(file.insn_hash);
+ 	INIT_LIST_HEAD(&file.retpoline_call_list);
+ 	INIT_LIST_HEAD(&file.return_thunk_list);
+ 	INIT_LIST_HEAD(&file.static_call_list);
+ 	INIT_LIST_HEAD(&file.mcount_loc_list);
+ 	INIT_LIST_HEAD(&file.endbr_list);
+ 	file.ignore_unreachables = opts.no_unreachable;
+ 	file.hints = false;
+ 
+ 	return &file;
++>>>>>>> d9e9d2300681 (x86,objtool: Create .return_sites)
  }
  
 -void objtool_pv_add(struct objtool_file *f, int idx, struct symbol *func)
 +static void handle_internal_command(int argc, const char **argv)
  {
 -	if (!opts.noinstr)
 -		return;
 +	const char *cmd = argv[0];
 +	unsigned int i, ret;
  
 -	if (!f->pv_ops) {
 -		WARN("paravirt confusion");
 -		return;
 -	}
 +	for (i = 0; i < ARRAY_SIZE(objtool_cmds); i++) {
 +		struct cmd_struct *p = objtool_cmds+i;
  
 -	/*
 -	 * These functions will be patched into native code,
 -	 * see paravirt_patch().
 -	 */
 -	if (!strcmp(func->name, "_paravirt_nop") ||
 -	    !strcmp(func->name, "_paravirt_ident_64"))
 -		return;
 +		if (strcmp(p->name, cmd))
 +			continue;
  
 -	/* already added this function */
 -	if (!list_empty(&func->pv_target))
 -		return;
 +		ret = p->fn(argc, argv);
  
 -	list_add(&func->pv_target, &f->pv_ops[idx].targets);
 -	f->pv_ops[idx].clean = false;
 +		exit(ret);
 +	}
 +
 +	cmd_usage();
  }
  
  int main(int argc, const char **argv)
* Unmerged path tools/objtool/check.c
* Unmerged path tools/objtool/include/objtool/arch.h
* Unmerged path tools/objtool/include/objtool/elf.h
* Unmerged path tools/objtool/include/objtool/objtool.h
* Unmerged path tools/objtool/arch/x86/decode.c
* Unmerged path tools/objtool/check.c
* Unmerged path tools/objtool/include/objtool/arch.h
* Unmerged path tools/objtool/include/objtool/elf.h
* Unmerged path tools/objtool/include/objtool/objtool.h
* Unmerged path tools/objtool/objtool.c
