x86/cpufeatures: Carve out CQM features retrieval

jira LE-1907
cve CVE-2022-29901
cve CVE-2022-29900
cve CVE-2022-23825
cve CVE-2022-23816
Rebuild_History Non-Buildable kernel-3.10.0-1160.80.1.el7
commit-author Borislav Petkov <bp@suse.de>
commit 45fc56e629caa451467e7664fbd4c797c434a6c4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.80.1.el7/45fc56e6.failed

... into a separate function for better readability. Split out from a
patch from Fenghua Yu <fenghua.yu@intel.com> to keep the mechanical,
sole code movement separate for easy review.

No functional changes.

	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: Fenghua Yu <fenghua.yu@intel.com>
	Cc: x86@kernel.org
(cherry picked from commit 45fc56e629caa451467e7664fbd4c797c434a6c4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/common.c
diff --cc arch/x86/kernel/cpu/common.c
index 2e803501e8c0,fe6ed9696467..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -775,13 -801,35 +775,45 @@@ static void init_speculation_control(st
  	}
  }
  
++<<<<<<< HEAD
 +static void apply_forced_caps(struct cpuinfo_x86 *c)
 +{
 +	int i;
 +
 +	for (i = 0; i < NCAPINTS + NBUGINTS; i++) {
 +		c->x86_capability[i] &= ~cpu_caps_cleared[i];
 +		c->x86_capability[i] |= cpu_caps_set[i];
++=======
+ static void init_cqm(struct cpuinfo_x86 *c)
+ {
+ 	u32 eax, ebx, ecx, edx;
+ 
+ 	/* Additional Intel-defined flags: level 0x0000000F */
+ 	if (c->cpuid_level >= 0x0000000F) {
+ 
+ 		/* QoS sub-leaf, EAX=0Fh, ECX=0 */
+ 		cpuid_count(0x0000000F, 0, &eax, &ebx, &ecx, &edx);
+ 		c->x86_capability[CPUID_F_0_EDX] = edx;
+ 
+ 		if (cpu_has(c, X86_FEATURE_CQM_LLC)) {
+ 			/* will be overridden if occupancy monitoring exists */
+ 			c->x86_cache_max_rmid = ebx;
+ 
+ 			/* QoS sub-leaf, EAX=0Fh, ECX=1 */
+ 			cpuid_count(0x0000000F, 1, &eax, &ebx, &ecx, &edx);
+ 			c->x86_capability[CPUID_F_1_EDX] = edx;
+ 
+ 			if ((cpu_has(c, X86_FEATURE_CQM_OCCUP_LLC)) ||
+ 			      ((cpu_has(c, X86_FEATURE_CQM_MBM_TOTAL)) ||
+ 			       (cpu_has(c, X86_FEATURE_CQM_MBM_LOCAL)))) {
+ 				c->x86_cache_max_rmid = ecx;
+ 				c->x86_cache_occ_scale = ebx;
+ 			}
+ 		} else {
+ 			c->x86_cache_max_rmid = -1;
+ 			c->x86_cache_occ_scale = -1;
+ 		}
++>>>>>>> 45fc56e629ca (x86/cpufeatures: Carve out CQM features retrieval)
  	}
  }
  
@@@ -816,36 -864,6 +848,39 @@@ void get_cpu_cap(struct cpuinfo_x86 *c
  		c->x86_capability[CPUID_D_1_EAX] = eax;
  	}
  
++<<<<<<< HEAD
 +	/* Additional Intel-defined flags: level 0x0000000F */
 +	if (c->cpuid_level >= 0x0000000F) {
 +		struct rh_cpuinfo_x86 *rh_c =
 +			(c == &boot_cpu_data) ? &rh_boot_cpu_data
 +			: &rh_cpu_data(c->cpu_index);
 +
 +		/* QoS sub-leaf, EAX=0Fh, ECX=0 */
 +		cpuid_count(0x0000000F, 0, &eax, &ebx, &ecx, &edx);
 +		c->x86_capability[CPUID_F_0_EDX] = edx;
 +
 +		if (cpu_has(c, X86_FEATURE_CQM_LLC)) {
 +			/* will be overridden if occupancy monitoring exists */
 +			rh_c->x86_cache_max_rmid = ebx;
 +
 +			/* QoS sub-leaf, EAX=0Fh, ECX=1 */
 +			cpuid_count(0x0000000F, 1, &eax, &ebx, &ecx, &edx);
 +			c->x86_capability[CPUID_F_1_EDX] = edx;
 +
 +			if ((cpu_has(c, X86_FEATURE_CQM_OCCUP_LLC)) ||
 +			      ((cpu_has(c, X86_FEATURE_CQM_MBM_TOTAL)) ||
 +			       (cpu_has(c, X86_FEATURE_CQM_MBM_LOCAL)))) {
 +				rh_c->x86_cache_max_rmid = ecx;
 +				rh_c->x86_cache_occ_scale = ebx;
 +			}
 +		} else {
 +			rh_c->x86_cache_max_rmid = -1;
 +			rh_c->x86_cache_occ_scale = -1;
 +		}
 +	}
 +
++=======
++>>>>>>> 45fc56e629ca (x86/cpufeatures: Carve out CQM features retrieval)
  	/* AMD-defined flags: level 0x80000001 */
  	eax = cpuid_eax(0x80000000);
  	c->extended_cpuid_level = eax;
* Unmerged path arch/x86/kernel/cpu/common.c
