GFS2: don't set rgrp gl_object until it's inserted into rgrp tree

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit 36e4ad0316c017d5b271378ed9a1c9a4b77fab5f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/36e4ad03.failed

Before this patch, function read_rindex_entry would set a rgrp
glock's gl_object pointer to itself before inserting the rgrp into
the rgrp rbtree. The problem is: if another process was also reading
the rgrp in, and had already inserted its newly created rgrp, then
the second call to read_rindex_entry would overwrite that value,
then return a bad return code to the caller. Later, other functions
would reference the now-freed rgrp memory by way of gl_object.
In some cases, that could result in gfs2_rgrp_brelse being called
twice for the same rgrp: once for the failed attempt and once for
the "real" rgrp release. Eventually the kernel would panic.
There are also a number of other things that could go wrong when
a kernel module is accessing freed storage. For example, this could
result in rgrp corruption because the fake rgrp would point to a
fake bitmap in memory too, causing gfs2_inplace_reserve to search
some random memory for free blocks, and find some, since we were
never setting rgd->rd_bits to NULL before freeing it.

This patch fixes the problem by not setting gl_object until we
have successfully inserted the rgrp into the rbtree. Also, it sets
rd_bits to NULL as it frees them, which will ensure any accidental
access to the wrong rgrp will result in a kernel panic rather than
file system corruption, which is preferred.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 36e4ad0316c017d5b271378ed9a1c9a4b77fab5f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/rgrp.c
diff --cc fs/gfs2/rgrp.c
index 28da34fba03d,960aaf43d665..000000000000
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@@ -900,7 -917,6 +901,10 @@@ static int read_rindex_entry(struct gfs
  	if (error)
  		goto fail;
  
++<<<<<<< HEAD
 +	rgd->rd_gl->gl_object = rgd;
++=======
++>>>>>>> 36e4ad0316c0 (GFS2: don't set rgrp gl_object until it's inserted into rgrp tree)
  	rgd->rd_rgl = (struct gfs2_rgrp_lvb *)rgd->rd_gl->gl_lksb.sb_lvbptr;
  	rgd->rd_flags &= ~(GFS2_RDF_UPTODATE | GFS2_RDF_PREFERRED);
  	if (rgd->rd_data > sdp->sd_max_rg_data)
* Unmerged path fs/gfs2/rgrp.c
