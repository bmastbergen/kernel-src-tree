sctp: Don't lookup dst if transport dst is still valid

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author fan.du <fan.du@windriver.com>
commit d27fc78208b53ccdfd6a57d4ac44a459ca66806f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d27fc782.failed

When sctp sits on IPv6, sctp_transport_dst_check pass cookie as ZERO,
as a result ip6_dst_check always fail out. This behaviour makes
transport->dst useless, because every sctp_packet_transmit must look
for valid dst.

Add a dst_cookie into sctp_transport, and set the cookie whenever we
get new dst for sctp_transport. So dst validness could be checked
against it.

Since I have split genid for IPv4 and IPv6, also delete/add IPv6 address
will also bump IPv6 genid. So issues we discussed in:
http://marc.info/?l=linux-netdev&m=137404469219410&w=4
have all been sloved for this patch.

	Signed-off-by: Fan Du <fan.du@windriver.com>
	Acked-by: Vlad Yasevich <vyasevich@gmail.com>
	Acked-by: Neil Horman <nhorman@tuxdriver.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d27fc78208b53ccdfd6a57d4ac44a459ca66806f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/ipv6.c
diff --cc net/sctp/ipv6.c
index 09aaba531950,5a9402e3c0cf..000000000000
--- a/net/sctp/ipv6.c
+++ b/net/sctp/ipv6.c
@@@ -339,13 -348,16 +339,19 @@@ static void sctp_v6_get_dst(struct sctp
  out:
  	if (!IS_ERR_OR_NULL(dst)) {
  		struct rt6_info *rt;
 -
  		rt = (struct rt6_info *)dst;
  		t->dst = dst;
++<<<<<<< HEAD
 +		SCTP_DEBUG_PRINTK("rt6_dst:%pI6 rt6_src:%pI6\n",
 +			&rt->rt6i_dst.addr, &fl6->saddr);
++=======
+ 		t->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;
+ 		pr_debug("rt6_dst:%pI6 rt6_src:%pI6\n", &rt->rt6i_dst.addr,
+ 			 &fl6->saddr);
++>>>>>>> d27fc78208b5 (sctp: Don't lookup dst if transport dst is still valid)
  	} else {
  		t->dst = NULL;
 -
 -		pr_debug("no route\n");
 +		SCTP_DEBUG_PRINTK("NO ROUTE\n");
  	}
  }
  
diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.h
index 4b35a0af7318..21f9863b025d 100644
--- a/include/net/sctp/sctp.h
+++ b/include/net/sctp/sctp.h
@@ -735,7 +735,7 @@ static inline void sctp_v4_map_v6(union sctp_addr *addr)
  */
 static inline struct dst_entry *sctp_transport_dst_check(struct sctp_transport *t)
 {
-	if (t->dst && !dst_check(t->dst, 0)) {
+	if (t->dst && !dst_check(t->dst, t->dst_cookie)) {
 		dst_release(t->dst);
 		t->dst = NULL;
 	}
diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7a7c7cb8b173..400c2b271945 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -953,6 +953,7 @@ struct sctp_transport {
 	__u64 hb_nonce;
 
 	struct rcu_head rcu;
+	u32 dst_cookie;
 };
 
 struct sctp_transport *sctp_transport_new(struct net *, const union sctp_addr *,
* Unmerged path net/sctp/ipv6.c
