mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sreekanth Reddy <sreekanth.reddy@avagotech.com>
commit c84b06a48c4d8ac8270624453132f3fa1a4a0f9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c84b06a4.failed

Modified the mpt3sas driver to have a single driver module which
supports both SAS 2.0 & SAS 3.0 HBA devices.

* Added SAS 2.0 HBA device IDs to the mpt3sas_pci_table pci table.

* Created two separate SCSI host templates for SAS2 and SAS3 HBAs so
  that, during the driver load time driver can use corresponding host
  template(based the pci device ID) while registering a scsi host
  adapter instance for that pci device.

* Registered two IOCTL devices, mpt2ctl is for SAS2 HBAs & mpt3ctl for
  SAS3 HBAs. Also updated the code to make sure that mpt2ctl device
  processes only those ioctl cmds issued for the SAS2 HBAs and mpt3ctl
  device processes only those ioctl cmds issued for the SAS3 HBAs.

* Added separate indexing for SAS2 and SAS3 HBAs.

* Replaced compile time check 'MPT2SAS_SCSI' to run time check
  'hba_mpi_version_belonged' whereever needed.

* Aliased this merged driver to mpt2sas using MODULE_ALIAS.

* Moved global varaible 'driver_name' to per adapter instance variable.

* Created two raid function template and used corresponding raid
  function templates based on the run time check
  'hba_mpi_version_belonged'.

* Moved mpt2sas_warpdrive.c file from mpt2sas to mpt3sas folder and
  renamed it as mpt3sas_warpdrive.c.

* Also renamed the functions in mpt3sas_warpdrive.c file to follow
  current driver function name convention.

* Updated the Makefile to build mpt3sas_warpdrive.o file for these
  WarpDrive-specific functions.

* Also in function mpt3sas_setup_direct_io(), used sector_div() API
  instead of division operator (which gives compilation errors on 32 bit
  machines).

* Removed mpt2sas files, mpt2sas directory & mpt3sas_module.c file.

* Added module parameter 'hbas_to_enumerate' which permits using this
  merged driver as a legacy mpt2sas driver or as a legacy mpt3sas
  driver.

  Here are the available options for this module parameter:

   0 - Merged driver which enumerates both SAS 2.0 & SAS 3.0 HBAs
   1 - Acts as legacy mpt2sas driver, which enumerates only SAS 2.0 HBAs
   2 - Acts as legacy mpt3sas driver, which enumerates only SAS 3.0 HBAs

* Removed mpt2sas entries from SCSI's Kconfig and Makefile files.

	Signed-off-by: Sreekanth Reddy <Sreekanth.Reddy@avagotech.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit c84b06a48c4d8ac8270624453132f3fa1a4a0f9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpt2sas/mpt2sas_module.c
#	drivers/scsi/mpt3sas/Makefile
#	drivers/scsi/mpt3sas/mpt2sas_base.c
#	drivers/scsi/mpt3sas/mpt2sas_base.h
#	drivers/scsi/mpt3sas/mpt2sas_config.c
#	drivers/scsi/mpt3sas/mpt2sas_ctl.c
#	drivers/scsi/mpt3sas/mpt2sas_ctl.h
#	drivers/scsi/mpt3sas/mpt2sas_debug.h
#	drivers/scsi/mpt3sas/mpt2sas_scsih.c
#	drivers/scsi/mpt3sas/mpt2sas_transport.c
#	drivers/scsi/mpt3sas/mpt3sas_base.c
#	drivers/scsi/mpt3sas/mpt3sas_base.h
#	drivers/scsi/mpt3sas/mpt3sas_ctl.c
#	drivers/scsi/mpt3sas/mpt3sas_scsih.c
#	drivers/scsi/mpt3sas/mpt3sas_warpdrive.c
diff --cc drivers/scsi/mpt3sas/Makefile
index efb0c4c2e310,b7643f596c1e..000000000000
--- a/drivers/scsi/mpt3sas/Makefile
+++ b/drivers/scsi/mpt3sas/Makefile
@@@ -5,4 -5,5 +5,9 @@@ mpt3sas-y +=  mpt3sas_base.o     
  		mpt3sas_scsih.o      \
  		mpt3sas_transport.o     \
  		mpt3sas_ctl.o	\
++<<<<<<< HEAD
 +		mpt3sas_trigger_diag.o
++=======
+ 		mpt3sas_trigger_diag.o \
+ 		mpt3sas_warpdrive.o
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
diff --cc drivers/scsi/mpt3sas/mpt3sas_base.c
index 5c7d5b89e89c,11393ebf1a68..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_base.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c
@@@ -1800,10 -1836,10 +1801,17 @@@ _base_request_irq(struct MPT3SAS_ADAPTE
  	atomic_set(&reply_q->busy, 0);
  	if (ioc->msix_enable)
  		snprintf(reply_q->name, MPT_NAME_LENGTH, "%s%d-msix%d",
++<<<<<<< HEAD
 +		    MPT3SAS_DRIVER_NAME, ioc->id, index);
 +	else
 +		snprintf(reply_q->name, MPT_NAME_LENGTH, "%s%d",
 +		    MPT3SAS_DRIVER_NAME, ioc->id);
++=======
+ 		    ioc->driver_name, ioc->id, index);
+ 	else
+ 		snprintf(reply_q->name, MPT_NAME_LENGTH, "%s%d",
+ 		    ioc->driver_name, ioc->id);
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  	r = request_irq(vector, _base_interrupt, IRQF_SHARED, reply_q->name,
  	    reply_q);
  	if (r) {
@@@ -2029,7 -2065,7 +2037,11 @@@ mpt3sas_base_map_resources(struct MPT3S
  
  
  	if (pci_request_selected_regions(pdev, ioc->bars,
++<<<<<<< HEAD
 +	    MPT3SAS_DRIVER_NAME)) {
++=======
+ 	    ioc->driver_name)) {
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  		pr_warn(MPT3SAS_FMT "pci_request_selected_regions: failed\n",
  			ioc->name);
  		ioc->bars = 0;
diff --cc drivers/scsi/mpt3sas/mpt3sas_base.h
index e4afe8ed3bc7,25c141c9ec9d..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_base.h
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.h
@@@ -1169,10 -1264,14 +1170,15 @@@ struct _sas_node *mpt3sas_scsih_expande
  	struct MPT3SAS_ADAPTER *ioc, u16 handle);
  struct _sas_node *mpt3sas_scsih_expander_find_by_sas_address(
  	struct MPT3SAS_ADAPTER *ioc, u64 sas_address);
 -struct _sas_device *mpt3sas_get_sdev_by_addr(
 -	 struct MPT3SAS_ADAPTER *ioc, u64 sas_address);
 -struct _sas_device *__mpt3sas_get_sdev_by_addr(
 -	 struct MPT3SAS_ADAPTER *ioc, u64 sas_address);
 +struct _sas_device *mpt3sas_scsih_sas_device_find_by_sas_address(
 +	struct MPT3SAS_ADAPTER *ioc, u64 sas_address);
  
  void mpt3sas_port_enable_complete(struct MPT3SAS_ADAPTER *ioc);
++<<<<<<< HEAD
++=======
+ struct _raid_device *
+ mpt3sas_raid_device_find_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle);
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  
  /* config shared API */
  u8 mpt3sas_config_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
@@@ -1260,8 -1357,8 +1264,13 @@@ int mpt3sas_config_get_volume_wwid(stru
  /* ctl shared API */
  extern struct device_attribute *mpt3sas_host_attrs[];
  extern struct device_attribute *mpt3sas_dev_attrs[];
++<<<<<<< HEAD
 +void mpt3sas_ctl_init(void);
 +void mpt3sas_ctl_exit(void);
++=======
+ void mpt3sas_ctl_init(ushort hbas_to_enumerate);
+ void mpt3sas_ctl_exit(ushort hbas_to_enumerate);
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  u8 mpt3sas_ctl_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
  	u32 reply);
  void mpt3sas_ctl_reset_handler(struct MPT3SAS_ADAPTER *ioc, int reset_phase);
diff --cc drivers/scsi/mpt3sas/mpt3sas_ctl.c
index 028766e49f64,d8366b056b70..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_ctl.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_ctl.c
@@@ -413,13 -415,21 +415,23 @@@ mpt3sas_ctl_event_callback(struct MPT3S
   * Return (-1) means error, else ioc_number.
   */
  static int
- _ctl_verify_adapter(int ioc_number, struct MPT3SAS_ADAPTER **iocpp)
+ _ctl_verify_adapter(int ioc_number, struct MPT3SAS_ADAPTER **iocpp,
+ 							int mpi_version)
  {
  	struct MPT3SAS_ADAPTER *ioc;
 -	/* global ioc lock to protect controller on list operations */
 -	spin_lock(&gioc_lock);
 +
  	list_for_each_entry(ioc, &mpt3sas_ioc_list, list) {
  		if (ioc->id != ioc_number)
  			continue;
++<<<<<<< HEAD
++=======
+ 		/* Check whether this ioctl command is from right
+ 		 * ioctl device or not, if not continue the search.
+ 		 */
+ 		if (ioc->hba_mpi_version_belonged != mpi_version)
+ 			continue;
+ 		spin_unlock(&gioc_lock);
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  		*iocpp = ioc;
  		return ioc_number;
  	}
@@@ -492,7 -503,7 +504,11 @@@ mpt3sas_ctl_reset_handler(struct MPT3SA
   *
   * Called when application request fasyn callback handler.
   */
++<<<<<<< HEAD
 +static int
++=======
+ int
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  _ctl_fasync(int fd, struct file *filep, int mode)
  {
  	return fasync_helper(fd, filep, mode, &async_queue);
@@@ -504,7 -515,7 +520,11 @@@
   * @wait -
   *
   */
++<<<<<<< HEAD
 +static unsigned int
++=======
+ unsigned int
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  _ctl_poll(struct file *filep, poll_table *wait)
  {
  	struct MPT3SAS_ADAPTER *ioc;
@@@ -1027,9 -1042,21 +1047,27 @@@ _ctl_getiocinfo(struct MPT3SAS_ADAPTER 
  	karg.pci_information.u.bits.function = PCI_FUNC(ioc->pdev->devfn);
  	karg.pci_information.segment_id = pci_domain_nr(ioc->pdev->bus);
  	karg.firmware_version = ioc->facts.FWVersion.Word;
++<<<<<<< HEAD
 +	strcpy(karg.driver_version, MPT3SAS_DRIVER_NAME);
 +	strcat(karg.driver_version, "-");
 +	strcat(karg.driver_version, MPT3SAS_DRIVER_VERSION);
++=======
+ 	strcpy(karg.driver_version, ioc->driver_name);
+ 	strcat(karg.driver_version, "-");
+ 	switch  (ioc->hba_mpi_version_belonged) {
+ 	case MPI2_VERSION:
+ 		if (ioc->is_warpdrive)
+ 			karg.adapter_type = MPT2_IOCTL_INTERFACE_SAS2_SSS6200;
+ 		else
+ 			karg.adapter_type = MPT2_IOCTL_INTERFACE_SAS2;
+ 		strcat(karg.driver_version, MPT2SAS_DRIVER_VERSION);
+ 		break;
+ 	case MPI25_VERSION:
+ 		karg.adapter_type = MPT3_IOCTL_INTERFACE_SAS3;
+ 		strcat(karg.driver_version, MPT3SAS_DRIVER_VERSION);
+ 		break;
+ 	}
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  	karg.bios_version = le32_to_cpu(ioc->bios_pg3.BiosVersion);
  
  	if (copy_to_user(arg, &karg, sizeof(karg))) {
@@@ -2193,12 -2222,18 +2233,13 @@@ _ctl_ioctl_main(struct file *file, unsi
  		return -EFAULT;
  	}
  
- 	if (_ctl_verify_adapter(ioctl_header.ioc_number, &ioc) == -1 || !ioc)
+ 	if (_ctl_verify_adapter(ioctl_header.ioc_number,
+ 				&ioc, mpi_version) == -1 || !ioc)
  		return -ENODEV;
  
 -	/* pci_access_mutex lock acquired by ioctl path */
 -	mutex_lock(&ioc->pci_access_mutex);
 -
  	if (ioc->shost_recovery || ioc->pci_error_recovery ||
 -	    ioc->is_driver_loading || ioc->remove_host) {
 -		ret = -EAGAIN;
 -		goto out_unlock_pciaccess;
 -	}
 +	    ioc->is_driver_loading)
 +		return -EAGAIN;
  
  	state = (file->f_flags & O_NONBLOCK) ? NON_BLOCKING : BLOCKING;
  	if (state == NON_BLOCKING) {
@@@ -2290,12 -2331,12 +2331,20 @@@
  }
  
  /**
++<<<<<<< HEAD
 + * _ctl_ioctl - main ioctl entry point (unlocked)
++=======
+  * _ctl_ioctl - mpt3ctl main ioctl entry point (unlocked)
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
   * @file - (struct file)
   * @cmd - ioctl opcode
   * @arg -
   */
++<<<<<<< HEAD
 +static long
++=======
+ long
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  _ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
  {
  	long ret;
@@@ -2304,16 -2348,33 +2356,41 @@@
  	return ret;
  }
  
+ /**
+  * _ctl_mpt2_ioctl - mpt2ctl main ioctl entry point (unlocked)
+  * @file - (struct file)
+  * @cmd - ioctl opcode
+  * @arg -
+  */
+ long
+ _ctl_mpt2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+ {
+ 	long ret;
+ 
+ 	/* pass MPI2_VERSION value, to indicate that this ioctl cmd
+ 	 * came from mpt2ctl ioctl device.
+ 	 */
+ 	ret = _ctl_ioctl_main(file, cmd, (void __user *)arg, 0, MPI2_VERSION);
+ 	return ret;
+ }
  #ifdef CONFIG_COMPAT
  /**
++<<<<<<< HEAD
 + * _ctl_ioctl_compat - main ioctl entry point (compat)
++=======
+  *_ ctl_ioctl_compat - main ioctl entry point (compat)
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
   * @file -
   * @cmd -
   * @arg -
   *
   * This routine handles 32 bit applications in 64bit os.
   */
++<<<<<<< HEAD
 +static long
++=======
+ long
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  _ctl_ioctl_compat(struct file *file, unsigned cmd, unsigned long arg)
  {
  	long ret;
@@@ -3284,6 -3365,7 +3374,10 @@@ struct device_attribute *mpt3sas_dev_at
  	NULL,
  };
  
++<<<<<<< HEAD
++=======
+ /* file operations table for mpt3ctl device */
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  static const struct file_operations ctl_fops = {
  	.owner = THIS_MODULE,
  	.unlocked_ioctl = _ctl_ioctl,
@@@ -3294,23 -3376,53 +3388,68 @@@
  #endif
  };
  
++<<<<<<< HEAD
++=======
+ /* file operations table for mpt2ctl device */
+ static const struct file_operations ctl_gen2_fops = {
+ 	.owner = THIS_MODULE,
+ 	.unlocked_ioctl = _ctl_mpt2_ioctl,
+ 	.poll = _ctl_poll,
+ 	.fasync = _ctl_fasync,
+ #ifdef CONFIG_COMPAT
+ 	.compat_ioctl = _ctl_mpt2_ioctl_compat,
+ #endif
+ };
+ 
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  static struct miscdevice ctl_dev = {
  	.minor  = MPT3SAS_MINOR,
  	.name   = MPT3SAS_DEV_NAME,
  	.fops   = &ctl_fops,
  };
  
++<<<<<<< HEAD
++=======
+ static struct miscdevice gen2_ctl_dev = {
+ 	.minor  = MPT2SAS_MINOR,
+ 	.name   = MPT2SAS_DEV_NAME,
+ 	.fops   = &ctl_gen2_fops,
+ };
+ 
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  /**
   * mpt3sas_ctl_init - main entry point for ctl.
   *
   */
  void
++<<<<<<< HEAD
 +mpt3sas_ctl_init(void)
 +{
 +	async_queue = NULL;
 +	if (misc_register(&ctl_dev) < 0)
 +		pr_err("%s can't register misc device [minor=%d]\n",
 +		    MPT3SAS_DRIVER_NAME, MPT3SAS_MINOR);
++=======
+ mpt3sas_ctl_init(ushort hbas_to_enumerate)
+ {
+ 	async_queue = NULL;
+ 
+ 	/* Don't register mpt3ctl ioctl device if
+ 	 * hbas_to_enumarate is one.
+ 	 */
+ 	if (hbas_to_enumerate != 1)
+ 		if (misc_register(&ctl_dev) < 0)
+ 			pr_err("%s can't register misc device [minor=%d]\n",
+ 			    MPT3SAS_DRIVER_NAME, MPT3SAS_MINOR);
+ 
+ 	/* Don't register mpt3ctl ioctl device if
+ 	 * hbas_to_enumarate is two.
+ 	 */
+ 	if (hbas_to_enumerate != 2)
+ 		if (misc_register(&gen2_ctl_dev) < 0)
+ 			pr_err("%s can't register misc device [minor=%d]\n",
+ 			    MPT2SAS_DRIVER_NAME, MPT2SAS_MINOR);
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  
  	init_waitqueue_head(&ctl_poll_wait);
  }
@@@ -3320,7 -3432,7 +3459,11 @@@
   *
   */
  void
++<<<<<<< HEAD
 +mpt3sas_ctl_exit(void)
++=======
+ mpt3sas_ctl_exit(ushort hbas_to_enumerate)
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  {
  	struct MPT3SAS_ADAPTER *ioc;
  	int i;
@@@ -3345,5 -3457,8 +3488,12 @@@
  
  		kfree(ioc->event_log);
  	}
++<<<<<<< HEAD
 +	misc_deregister(&ctl_dev);
++=======
+ 	if (hbas_to_enumerate != 1)
+ 		misc_deregister(&ctl_dev);
+ 	if (hbas_to_enumerate != 2)
+ 		misc_deregister(&gen2_ctl_dev);
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  }
diff --cc drivers/scsi/mpt3sas/mpt3sas_scsih.c
index dab4affe7dc9,d95206b7e116..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
@@@ -75,11 -71,16 +75,24 @@@ static int _scsih_add_device(struct MPT
  
  static u8 _scsih_check_for_pending_tm(struct MPT3SAS_ADAPTER *ioc, u16 smid);
  
++<<<<<<< HEAD
 +static void _scsih_scan_start(struct Scsi_Host *shost);
 +static int _scsih_scan_finished(struct Scsi_Host *shost, unsigned long time);
 +
 +/* global parameters */
 +LIST_HEAD(mpt3sas_ioc_list);
++=======
+ /* global parameters */
+ LIST_HEAD(mpt3sas_ioc_list);
+ /* global ioc lock for list operations */
+ DEFINE_SPINLOCK(gioc_lock);
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
+ 
+ MODULE_AUTHOR(MPT3SAS_AUTHOR);
+ MODULE_DESCRIPTION(MPT3SAS_DESCRIPTION);
+ MODULE_LICENSE("GPL");
+ MODULE_VERSION(MPT3SAS_DRIVER_VERSION);
+ MODULE_ALIAS("mpt2sas");
  
  /* local parameters */
  static u8 scsi_io_cb_idx = -1;
@@@ -113,12 -115,16 +127,16 @@@ MODULE_PARM_DESC(missing_delay, " devic
  
  /* scsi-mid layer global parmeter is max_report_luns, which is 511 */
  #define MPT3SAS_MAX_LUN (16895)
 -static u64 max_lun = MPT3SAS_MAX_LUN;
 -module_param(max_lun, ullong, 0);
 +static int max_lun = MPT3SAS_MAX_LUN;
 +module_param(max_lun, int, 0);
  MODULE_PARM_DESC(max_lun, " max lun, default=16895 ");
  
- 
- 
+ static ushort hbas_to_enumerate;
+ module_param(hbas_to_enumerate, ushort, 0);
+ MODULE_PARM_DESC(hbas_to_enumerate,
+ 		" 0 - enumerates both SAS 2.0 & SAS 3.0 generation HBAs\n \
+ 		  1 - enumerates only SAS 2.0 generation HBAs\n \
+ 		  2 - enumerates only SAS 3.0 generation HBAs (default=0)");
  
  /* diag_buffer_enable is bitwise
   * bit 0 set = TRACE
@@@ -143,8 -149,8 +161,13 @@@ MODULE_PARM_DESC(prot_mask, " host prot
  
  
  /* raid transport support */
++<<<<<<< HEAD
 +
 +static struct raid_template *mpt3sas_raid_template;
++=======
+ struct raid_template *mpt3sas_raid_template;
+ struct raid_template *mpt2sas_raid_template;
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  
  
  /**
@@@ -1750,6 -1835,10 +1783,13 @@@ _scsih_slave_configure(struct scsi_devi
  			return 1;
  		}
  
++<<<<<<< HEAD
++=======
+ 		/*
+ 		 * WARPDRIVE: Initialize the required data for Direct IO
+ 		 */
+ 		mpt3sas_init_warpdrive_properties(ioc, raid_device);
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  
  		/* RAID Queue Depth Support
  		 * IS volume = underlying qdepth of drive type, either
@@@ -1798,17 -1887,19 +1838,23 @@@
  			break;
  		}
  
 -		if (!ioc->hide_ir_msg)
 -			sdev_printk(KERN_INFO, sdev,
 -			   "%s: handle(0x%04x), wwid(0x%016llx),"
 -			    " pd_count(%d), type(%s)\n",
 -			    r_level, raid_device->handle,
 -			    (unsigned long long)raid_device->wwid,
 -			    raid_device->num_pds, ds);
 +		sdev_printk(KERN_INFO, sdev,
 +			"%s: handle(0x%04x), wwid(0x%016llx), pd_count(%d), type(%s)\n",
 +			 r_level, raid_device->handle,
 +			 (unsigned long long)raid_device->wwid,
 +			 raid_device->num_pds, ds);
  
 -		scsih_change_queue_depth(sdev, qdepth);
  
++<<<<<<< HEAD
 +		_scsih_change_queue_depth(sdev, qdepth, SCSI_QDEPTH_DEFAULT);
 +
 +/* raid transport support */
 +		_scsih_set_level(sdev, raid_device->volume_type);
++=======
+ 		/* raid transport support */
+ 		if (!ioc->is_warpdrive)
+ 			_scsih_set_level(ioc, sdev, raid_device->volume_type);
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  		return 0;
  	}
  
@@@ -3705,6 -3844,7 +3751,10 @@@ _scsih_qcmd(struct Scsi_Host *shost, st
  	struct MPT3SAS_ADAPTER *ioc = shost_priv(shost);
  	struct MPT3SAS_DEVICE *sas_device_priv_data;
  	struct MPT3SAS_TARGET *sas_target_priv_data;
++<<<<<<< HEAD
++=======
+ 	struct _raid_device *raid_device;
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  	Mpi2SCSIIORequest_t *mpi_request;
  	u32 mpi_control;
  	u16 smid;
@@@ -3813,15 -3948,19 +3863,27 @@@
  	} else
  		ioc->build_zero_len_sge(ioc, &mpi_request->SGL);
  
++<<<<<<< HEAD
++=======
+ 	raid_device = sas_target_priv_data->raid_device;
+ 	if (raid_device && raid_device->direct_io_enabled)
+ 		mpt3sas_setup_direct_io(ioc, scmd, raid_device, mpi_request,
+ 		    smid);
+ 
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  	if (likely(mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST)) {
- #ifndef SCSI_MPT2SAS
  		if (sas_target_priv_data->flags & MPT_TARGET_FASTPATH_IO) {
  			mpi_request->IoFlags = cpu_to_le16(scmd->cmd_len |
  			    MPI25_SCSIIO_IOFLAGS_FAST_PATH);
  			mpt3sas_base_put_smid_fast_path(ioc, smid, handle);
  		} else
++<<<<<<< HEAD
 +#endif
 +			mpt3sas_base_put_smid_scsi_io(ioc, smid, handle);
++=======
+ 			mpt3sas_base_put_smid_scsi_io(ioc, smid,
+ 			    le16_to_cpu(mpi_request->DevHandle));
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  	} else
  		mpt3sas_base_put_smid_default(ioc, smid);
  	return 0;
@@@ -4268,6 -4419,7 +4330,10 @@@ _scsih_io_done(struct MPT3SAS_ADAPTER *
  	u32 log_info;
  	struct MPT3SAS_DEVICE *sas_device_priv_data;
  	u32 response_code = 0;
++<<<<<<< HEAD
++=======
+ 	unsigned long flags;
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  
  	mpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);
  	scmd = _scsih_scsi_lookup_get_clear(ioc, smid);
@@@ -4289,6 -4441,24 +4355,27 @@@
  	}
  	ioc_status = le16_to_cpu(mpi_reply->IOCStatus);
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * WARPDRIVE: If direct_io is set then it is directIO,
+ 	 * the failed direct I/O should be redirected to volume
+ 	 */
+ 	if (mpt3sas_scsi_direct_io_get(ioc, smid) &&
+ 	     ((ioc_status & MPI2_IOCSTATUS_MASK)
+ 	      != MPI2_IOCSTATUS_SCSI_TASK_TERMINATED)) {
+ 		spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
+ 		ioc->scsi_lookup[smid - 1].scmd = scmd;
+ 		spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
+ 		mpt3sas_scsi_direct_io_set(ioc, smid, 0);
+ 		memcpy(mpi_request->CDB.CDB32, scmd->cmnd, scmd->cmd_len);
+ 		mpi_request->DevHandle =
+ 		    cpu_to_le16(sas_device_priv_data->sas_target->handle);
+ 		mpt3sas_base_put_smid_scsi_io(ioc, smid,
+ 		    sas_device_priv_data->sas_target->handle);
+ 		return 0;
+ 	}
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  	/* turning off TLR */
  	scsi_state = mpi_reply->SCSIState;
  	if (scsi_state & MPI2_SCSI_STATE_RESPONSE_INFO_VALID)
@@@ -4296,10 -4466,13 +4383,20 @@@
  		    le32_to_cpu(mpi_reply->ResponseInfo) & 0xFF;
  	if (!sas_device_priv_data->tlr_snoop_check) {
  		sas_device_priv_data->tlr_snoop_check++;
++<<<<<<< HEAD
 +		if ((sas_device_priv_data->flags & MPT_DEVICE_TLR_ON) &&
 +		    response_code == MPI2_SCSITASKMGMT_RSP_INVALID_FRAME)
 +			sas_device_priv_data->flags &=
 +			    ~MPT_DEVICE_TLR_ON;
++=======
+ 		if (!ioc->is_warpdrive &&
+ 		    !scsih_is_raid(&scmd->device->sdev_gendev) &&
+ 		    sas_is_tlr_enabled(scmd->device) &&
+ 		    response_code == MPI2_SCSITASKMGMT_RSP_INVALID_FRAME) {
+ 			sas_disable_tlr(scmd->device);
+ 			sdev_printk(KERN_INFO, scmd->device, "TLR disabled\n");
+ 		}
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  	}
  
  	xfer_cnt = le32_to_cpu(mpi_reply->TransferCount);
@@@ -6118,12 -6296,13 +6213,11 @@@ _scsih_sas_pd_hide(struct MPT3SAS_ADAPT
  	if (!sas_device)
  		return;
  
- #ifndef SCSI_MPT2SAS
  	/* hiding raid component */
  	_scsih_ir_fastpath(ioc, handle, element->PhysDiskNum);
- #endif
+ 
  	if (starget)
  		starget_for_each_device(starget, (void *)1, _scsih_reprobe_lun);
 -
 -	sas_device_put(sas_device);
  }
  
  /**
@@@ -6166,13 -6344,10 +6260,16 @@@ _scsih_sas_pd_add(struct MPT3SAS_ADAPTE
  
  	set_bit(handle, ioc->pd_handles);
  
 -	sas_device = mpt3sas_get_sdev_by_handle(ioc, handle);
 +	spin_lock_irqsave(&ioc->sas_device_lock, flags);
 +	sas_device = _scsih_sas_device_find_by_handle(ioc, handle);
 +	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
  	if (sas_device) {
- #ifndef SCSI_MPT2SAS
  		_scsih_ir_fastpath(ioc, handle, element->PhysDiskNum);
++<<<<<<< HEAD
 +#endif
++=======
+ 		sas_device_put(sas_device);
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  		return;
  	}
  
@@@ -6316,9 -6490,9 +6411,8 @@@ _scsih_sas_ir_config_change_event(struc
  					le16_to_cpu(element->PhysDiskDevHandle),
  					element->PhysDiskNum);
  		}
- #endif
  		return;
  	}
 -
  	for (i = 0; i < event_data->NumElements; i++, element++) {
  
  		switch (element->ReasonCode) {
@@@ -6767,6 -6949,13 +6861,16 @@@ _scsih_mark_responding_raid_device(stru
  			starget_printk(KERN_INFO, raid_device->starget,
  			    "handle(0x%04x), wwid(0x%016llx)\n", handle,
  			    (unsigned long long)raid_device->wwid);
++<<<<<<< HEAD
++=======
+ 
+ 			/*
+ 			 * WARPDRIVE: The handles of the PDs might have changed
+ 			 * across the host reset so re-initialize the
+ 			 * required data for Direct IO
+ 			 */
+ 			mpt3sas_init_warpdrive_properties(ioc, raid_device);
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  			spin_lock_irqsave(&ioc->raid_device_lock, flags);
  			if (raid_device->handle == handle) {
  				spin_unlock_irqrestore(&ioc->raid_device_lock,
@@@ -8032,6 -8310,124 +8136,127 @@@ _scsih_scan_finished(struct Scsi_Host *
  	return 1;
  }
  
++<<<<<<< HEAD
++=======
+ /* shost template for SAS 2.0 HBA devices */
+ static struct scsi_host_template mpt2sas_driver_template = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "Fusion MPT SAS Host",
+ 	.proc_name			= MPT2SAS_DRIVER_NAME,
+ 	.queuecommand			= scsih_qcmd,
+ 	.target_alloc			= scsih_target_alloc,
+ 	.slave_alloc			= scsih_slave_alloc,
+ 	.slave_configure		= scsih_slave_configure,
+ 	.target_destroy			= scsih_target_destroy,
+ 	.slave_destroy			= scsih_slave_destroy,
+ 	.scan_finished			= scsih_scan_finished,
+ 	.scan_start			= scsih_scan_start,
+ 	.change_queue_depth		= scsih_change_queue_depth,
+ 	.eh_abort_handler		= scsih_abort,
+ 	.eh_device_reset_handler	= scsih_dev_reset,
+ 	.eh_target_reset_handler	= scsih_target_reset,
+ 	.eh_host_reset_handler		= scsih_host_reset,
+ 	.bios_param			= scsih_bios_param,
+ 	.can_queue			= 1,
+ 	.this_id			= -1,
+ 	.sg_tablesize			= MPT2SAS_SG_DEPTH,
+ 	.max_sectors			= 32767,
+ 	.cmd_per_lun			= 7,
+ 	.use_clustering			= ENABLE_CLUSTERING,
+ 	.shost_attrs			= mpt3sas_host_attrs,
+ 	.sdev_attrs			= mpt3sas_dev_attrs,
+ 	.track_queue_depth		= 1,
+ };
+ 
+ /* raid transport support for SAS 2.0 HBA devices */
+ static struct raid_function_template mpt2sas_raid_functions = {
+ 	.cookie		= &mpt2sas_driver_template,
+ 	.is_raid	= scsih_is_raid,
+ 	.get_resync	= scsih_get_resync,
+ 	.get_state	= scsih_get_state,
+ };
+ 
+ /* shost template for SAS 3.0 HBA devices */
+ static struct scsi_host_template mpt3sas_driver_template = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "Fusion MPT SAS Host",
+ 	.proc_name			= MPT3SAS_DRIVER_NAME,
+ 	.queuecommand			= scsih_qcmd,
+ 	.target_alloc			= scsih_target_alloc,
+ 	.slave_alloc			= scsih_slave_alloc,
+ 	.slave_configure		= scsih_slave_configure,
+ 	.target_destroy			= scsih_target_destroy,
+ 	.slave_destroy			= scsih_slave_destroy,
+ 	.scan_finished			= scsih_scan_finished,
+ 	.scan_start			= scsih_scan_start,
+ 	.change_queue_depth		= scsih_change_queue_depth,
+ 	.eh_abort_handler		= scsih_abort,
+ 	.eh_device_reset_handler	= scsih_dev_reset,
+ 	.eh_target_reset_handler	= scsih_target_reset,
+ 	.eh_host_reset_handler		= scsih_host_reset,
+ 	.bios_param			= scsih_bios_param,
+ 	.can_queue			= 1,
+ 	.this_id			= -1,
+ 	.sg_tablesize			= MPT3SAS_SG_DEPTH,
+ 	.max_sectors			= 32767,
+ 	.cmd_per_lun			= 7,
+ 	.use_clustering			= ENABLE_CLUSTERING,
+ 	.shost_attrs			= mpt3sas_host_attrs,
+ 	.sdev_attrs			= mpt3sas_dev_attrs,
+ 	.track_queue_depth		= 1,
+ };
+ 
+ /* raid transport support for SAS 3.0 HBA devices */
+ static struct raid_function_template mpt3sas_raid_functions = {
+ 	.cookie		= &mpt3sas_driver_template,
+ 	.is_raid	= scsih_is_raid,
+ 	.get_resync	= scsih_get_resync,
+ 	.get_state	= scsih_get_state,
+ };
+ 
+ /**
+  * _scsih_determine_hba_mpi_version - determine in which MPI version class
+  *					this device belongs to.
+  * @pdev: PCI device struct
+  *
+  * return MPI2_VERSION for SAS 2.0 HBA devices,
+  *	MPI25_VERSION for SAS 3.0 HBA devices.
+  */
+ u16
+ _scsih_determine_hba_mpi_version(struct pci_dev *pdev)
+ {
+ 
+ 	switch (pdev->device) {
+ 	case MPI2_MFGPAGE_DEVID_SSS6200:
+ 	case MPI2_MFGPAGE_DEVID_SAS2004:
+ 	case MPI2_MFGPAGE_DEVID_SAS2008:
+ 	case MPI2_MFGPAGE_DEVID_SAS2108_1:
+ 	case MPI2_MFGPAGE_DEVID_SAS2108_2:
+ 	case MPI2_MFGPAGE_DEVID_SAS2108_3:
+ 	case MPI2_MFGPAGE_DEVID_SAS2116_1:
+ 	case MPI2_MFGPAGE_DEVID_SAS2116_2:
+ 	case MPI2_MFGPAGE_DEVID_SAS2208_1:
+ 	case MPI2_MFGPAGE_DEVID_SAS2208_2:
+ 	case MPI2_MFGPAGE_DEVID_SAS2208_3:
+ 	case MPI2_MFGPAGE_DEVID_SAS2208_4:
+ 	case MPI2_MFGPAGE_DEVID_SAS2208_5:
+ 	case MPI2_MFGPAGE_DEVID_SAS2208_6:
+ 	case MPI2_MFGPAGE_DEVID_SAS2308_1:
+ 	case MPI2_MFGPAGE_DEVID_SAS2308_2:
+ 	case MPI2_MFGPAGE_DEVID_SAS2308_3:
+ 		return MPI2_VERSION;
+ 	case MPI25_MFGPAGE_DEVID_SAS3004:
+ 	case MPI25_MFGPAGE_DEVID_SAS3008:
+ 	case MPI25_MFGPAGE_DEVID_SAS3108_1:
+ 	case MPI25_MFGPAGE_DEVID_SAS3108_2:
+ 	case MPI25_MFGPAGE_DEVID_SAS3108_5:
+ 	case MPI25_MFGPAGE_DEVID_SAS3108_6:
+ 		return MPI25_VERSION;
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  /**
   * _scsih_probe - attach and add scsi host
   * @pdev: PCI device struct
@@@ -8039,26 -8435,72 +8264,94 @@@
   *
   * Returns 0 success, anything else error.
   */
++<<<<<<< HEAD
 +static int
 +_scsih_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 +{
 +	struct MPT3SAS_ADAPTER *ioc;
 +	struct Scsi_Host *shost;
++=======
+ int
+ _scsih_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+ {
+ 	struct MPT3SAS_ADAPTER *ioc;
+ 	struct Scsi_Host *shost = NULL;
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  	int rv;
+ 	u16 hba_mpi_version;
  
+ 	/* Determine in which MPI version class this pci device belongs */
+ 	hba_mpi_version = _scsih_determine_hba_mpi_version(pdev);
+ 	if (hba_mpi_version == 0)
+ 		return -ENODEV;
+ 
+ 	/* Enumerate only SAS 2.0 HBA's if hbas_to_enumerate is one,
+ 	 * for other generation HBA's return with -ENODEV
+ 	 */
+ 	if ((hbas_to_enumerate == 1) && (hba_mpi_version !=  MPI2_VERSION))
+ 		return -ENODEV;
+ 
+ 	/* Enumerate only SAS 3.0 HBA's if hbas_to_enumerate is two,
+ 	 * for other generation HBA's return with -ENODEV
+ 	 */
+ 	if ((hbas_to_enumerate == 2) && (hba_mpi_version !=  MPI25_VERSION))
+ 		return -ENODEV;
+ 
+ 	switch (hba_mpi_version) {
+ 	case MPI2_VERSION:
+ 		/* Use mpt2sas driver host template for SAS 2.0 HBA's */
+ 		shost = scsi_host_alloc(&mpt2sas_driver_template,
+ 		  sizeof(struct MPT3SAS_ADAPTER));
+ 		if (!shost)
+ 			return -ENODEV;
+ 		ioc = shost_priv(shost);
+ 		memset(ioc, 0, sizeof(struct MPT3SAS_ADAPTER));
+ 		ioc->hba_mpi_version_belonged = hba_mpi_version;
+ 		ioc->id = mpt2_ids++;
+ 		sprintf(ioc->driver_name, "%s", MPT2SAS_DRIVER_NAME);
+ 		if (pdev->device == MPI2_MFGPAGE_DEVID_SSS6200) {
+ 			ioc->is_warpdrive = 1;
+ 			ioc->hide_ir_msg = 1;
+ 		} else
+ 			ioc->mfg_pg10_hide_flag = MFG_PAGE10_EXPOSE_ALL_DISKS;
+ 		break;
+ 	case MPI25_VERSION:
+ 		/* Use mpt3sas driver host template for SAS 3.0 HBA's */
+ 		shost = scsi_host_alloc(&mpt3sas_driver_template,
+ 		  sizeof(struct MPT3SAS_ADAPTER));
+ 		if (!shost)
+ 			return -ENODEV;
+ 		ioc = shost_priv(shost);
+ 		memset(ioc, 0, sizeof(struct MPT3SAS_ADAPTER));
+ 		ioc->hba_mpi_version_belonged = hba_mpi_version;
+ 		ioc->id = mpt3_ids++;
+ 		sprintf(ioc->driver_name, "%s", MPT3SAS_DRIVER_NAME);
+ 		if (pdev->revision >= SAS3_PCI_DEVICE_C0_REVISION)
+ 			ioc->msix96_vector = 1;
+ 		break;
+ 	default:
+ 		return -ENODEV;
+ 	}
+ 
++<<<<<<< HEAD
 +	shost = scsi_host_alloc(&scsih_driver_template,
 +	    sizeof(struct MPT3SAS_ADAPTER));
 +	if (!shost)
 +		return -ENODEV;
 +
 +	/* init local params */
 +	ioc = shost_priv(shost);
 +	memset(ioc, 0, sizeof(struct MPT3SAS_ADAPTER));
++=======
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  	INIT_LIST_HEAD(&ioc->list);
 -	spin_lock(&gioc_lock);
  	list_add_tail(&ioc->list, &mpt3sas_ioc_list);
 -	spin_unlock(&gioc_lock);
  	ioc->shost = shost;
++<<<<<<< HEAD
 +	ioc->id = mpt_ids++;
 +	sprintf(ioc->name, "%s%d", MPT3SAS_DRIVER_NAME, ioc->id);
++=======
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  	ioc->pdev = pdev;
  	ioc->scsi_io_cb_idx = scsi_io_cb_idx;
  	ioc->tm_cb_idx = tm_cb_idx;
@@@ -8093,6 -8537,8 +8386,11 @@@
  	INIT_LIST_HEAD(&ioc->delayed_tr_volume_list);
  	INIT_LIST_HEAD(&ioc->reply_queue_list);
  
++<<<<<<< HEAD
++=======
+ 	sprintf(ioc->name, "%s_cm%d", ioc->driver_name, ioc->id);
+ 
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  	/* init shost parameters */
  	shost->max_cmd_len = 32;
  	shost->max_lun = max_lun;
@@@ -8148,6 -8594,21 +8446,24 @@@
  		rv = -ENODEV;
  		goto out_attach_fail;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (ioc->is_warpdrive) {
+ 		if (ioc->mfg_pg10_hide_flag ==  MFG_PAGE10_EXPOSE_ALL_DISKS)
+ 			ioc->hide_drives = 0;
+ 		else if (ioc->mfg_pg10_hide_flag ==  MFG_PAGE10_HIDE_ALL_DISKS)
+ 			ioc->hide_drives = 1;
+ 		else {
+ 			if (mpt3sas_get_num_volumes(ioc))
+ 				ioc->hide_drives = 1;
+ 			else
+ 				ioc->hide_drives = 0;
+ 		}
+ 	} else
+ 		ioc->hide_drives = 0;
+ 
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  	rv = scsi_add_host(shost, &pdev->dev);
  	if (rv) {
  		pr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",
@@@ -8345,61 -8808,99 +8661,152 @@@ _scsih_pci_mmio_enabled(struct pci_dev 
  	return PCI_ERS_RESULT_NEED_RESET;
  }
  
++<<<<<<< HEAD
 +/* raid transport support */
 +static struct raid_function_template mpt3sas_raid_functions = {
 +	.cookie		= &scsih_driver_template,
 +	.is_raid	= _scsih_is_raid,
 +	.get_resync	= _scsih_get_resync,
 +	.get_state	= _scsih_get_state,
 +};
 +
 +static struct pci_error_handlers _scsih_err_handler = {
 +	.error_detected = _scsih_pci_error_detected,
 +	.mmio_enabled = _scsih_pci_mmio_enabled,
 +	.slot_reset =	_scsih_pci_slot_reset,
 +	.resume =	_scsih_pci_resume,
 +};
 +
 +static struct pci_driver scsih_driver = {
 +	.name		= MPT3SAS_DRIVER_NAME,
 +	.id_table	= scsih_pci_table,
 +	.probe		= _scsih_probe,
 +	.remove		= _scsih_remove,
 +	.shutdown	= _scsih_shutdown,
 +	.err_handler	= &_scsih_err_handler,
 +#ifdef CONFIG_PM
 +	.suspend	= _scsih_suspend,
 +	.resume		= _scsih_resume,
 +#endif
 +};
 +
 +
++=======
+ /*
+  * The pci device ids are defined in mpi/mpi2_cnfg.h.
+  */
+ static const struct pci_device_id mpt3sas_pci_table[] = {
+ 	/* Spitfire ~ 2004 */
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2004,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	/* Falcon ~ 2008 */
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2008,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	/* Liberator ~ 2108 */
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2108_1,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2108_2,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2108_3,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	/* Meteor ~ 2116 */
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2116_1,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2116_2,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	/* Thunderbolt ~ 2208 */
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_1,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_2,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_3,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_4,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_5,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_6,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	/* Mustang ~ 2308 */
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2308_1,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2308_2,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2308_3,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	/* SSS6200 */
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SSS6200,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	/* Fury ~ 3004 and 3008 */
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3004,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3008,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	/* Invader ~ 3108 */
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_1,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_2,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_5,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_6,
+ 		PCI_ANY_ID, PCI_ANY_ID },
+ 	{0}     /* Terminating entry */
+ };
+ MODULE_DEVICE_TABLE(pci, mpt3sas_pci_table);
+ 
+ static struct pci_error_handlers _mpt3sas_err_handler = {
+ 	.error_detected	= scsih_pci_error_detected,
+ 	.mmio_enabled	= scsih_pci_mmio_enabled,
+ 	.slot_reset	= scsih_pci_slot_reset,
+ 	.resume		= scsih_pci_resume,
+ };
+ 
+ static struct pci_driver mpt3sas_driver = {
+ 	.name		= MPT3SAS_DRIVER_NAME,
+ 	.id_table	= mpt3sas_pci_table,
+ 	.probe		= _scsih_probe,
+ 	.remove		= scsih_remove,
+ 	.shutdown	= scsih_shutdown,
+ 	.err_handler	= &_mpt3sas_err_handler,
+ #ifdef CONFIG_PM
+ 	.suspend	= scsih_suspend,
+ 	.resume		= scsih_resume,
+ #endif
+ };
+ 
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
  /**
 - * scsih_init - main entry point for this driver.
 + * _scsih_init - main entry point for this driver.
   *
   * Returns 0 success, anything else error.
   */
 -int
 -scsih_init(void)
 +static int __init
 +_scsih_init(void)
  {
++<<<<<<< HEAD
 +	int error;
 +
 +	mpt_ids = 0;
++=======
+ 	mpt2_ids = 0;
+ 	mpt3_ids = 0;
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
 +
 +	pr_info("%s version %s loaded\n", MPT3SAS_DRIVER_NAME,
 +	    MPT3SAS_DRIVER_VERSION);
 +
 +	mpt3sas_transport_template =
 +	    sas_attach_transport(&mpt3sas_transport_functions);
 +	if (!mpt3sas_transport_template)
 +		return -ENODEV;
 +
 +/* raid transport support */
 +	mpt3sas_raid_template = raid_class_attach(&mpt3sas_raid_functions);
 +	if (!mpt3sas_raid_template) {
 +		sas_release_transport(mpt3sas_transport_template);
 +		return -ENODEV;
 +	}
  
  	mpt3sas_base_initialize_callback_handler();
  
@@@ -8483,5 -8971,79 +8893,84 @@@ _scsih_exit(void
  	sas_release_transport(mpt3sas_transport_template);
  }
  
++<<<<<<< HEAD
 +module_init(_scsih_init);
 +module_exit(_scsih_exit);
++=======
+ /**
+  * _mpt3sas_init - main entry point for this driver.
+  *
+  * Returns 0 success, anything else error.
+  */
+ static int __init
+ _mpt3sas_init(void)
+ {
+ 	int error;
+ 
+ 	pr_info("%s version %s loaded\n", MPT3SAS_DRIVER_NAME,
+ 					MPT3SAS_DRIVER_VERSION);
+ 
+ 	mpt3sas_transport_template =
+ 	    sas_attach_transport(&mpt3sas_transport_functions);
+ 	if (!mpt3sas_transport_template)
+ 		return -ENODEV;
+ 
+ 	/* No need attach mpt3sas raid functions template
+ 	 * if hbas_to_enumarate value is one.
+ 	 */
+ 	if (hbas_to_enumerate != 1) {
+ 		mpt3sas_raid_template =
+ 				raid_class_attach(&mpt3sas_raid_functions);
+ 		if (!mpt3sas_raid_template) {
+ 			sas_release_transport(mpt3sas_transport_template);
+ 			return -ENODEV;
+ 		}
+ 	}
+ 
+ 	/* No need to attach mpt2sas raid functions template
+ 	 * if hbas_to_enumarate value is two
+ 	 */
+ 	if (hbas_to_enumerate != 2) {
+ 		mpt2sas_raid_template =
+ 				raid_class_attach(&mpt2sas_raid_functions);
+ 		if (!mpt2sas_raid_template) {
+ 			sas_release_transport(mpt3sas_transport_template);
+ 			return -ENODEV;
+ 		}
+ 	}
+ 
+ 	error = scsih_init();
+ 	if (error) {
+ 		scsih_exit();
+ 		return error;
+ 	}
+ 
+ 	mpt3sas_ctl_init(hbas_to_enumerate);
+ 
+ 	error = pci_register_driver(&mpt3sas_driver);
+ 	if (error)
+ 		scsih_exit();
+ 
+ 	return error;
+ }
+ 
+ /**
+  * _mpt3sas_exit - exit point for this driver (when it is a module).
+  *
+  */
+ static void __exit
+ _mpt3sas_exit(void)
+ {
+ 	pr_info("mpt3sas version %s unloading\n",
+ 				MPT3SAS_DRIVER_VERSION);
+ 
+ 	pci_unregister_driver(&mpt3sas_driver);
+ 
+ 	mpt3sas_ctl_exit(hbas_to_enumerate);
+ 
+ 	scsih_exit();
+ }
+ 
+ module_init(_mpt3sas_init);
+ module_exit(_mpt3sas_exit);
++>>>>>>> c84b06a48c4d (mpt3sas: Single driver module which supports both SAS 2.0 & SAS 3.0 HBAs)
* Unmerged path drivers/scsi/mpt2sas/mpt2sas_module.c
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_base.c
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_base.h
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_config.c
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_ctl.c
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_ctl.h
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_debug.h
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_scsih.c
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_transport.c
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_warpdrive.c
diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
index 193144c694a5..d27a09e76e63 100644
--- a/drivers/scsi/Kconfig
+++ b/drivers/scsi/Kconfig
@@ -603,7 +603,6 @@ config SCSI_ARCMSR
 	  module will be called arcmsr (modprobe arcmsr).
 
 source "drivers/scsi/megaraid/Kconfig.megaraid"
-source "drivers/scsi/mpt2sas/Kconfig"
 source "drivers/scsi/mpt3sas/Kconfig"
 source "drivers/scsi/ufs/Kconfig"
 
diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
index b919227f3f7f..85fa830f75a1 100644
--- a/drivers/scsi/Makefile
+++ b/drivers/scsi/Makefile
@@ -106,7 +106,6 @@ obj-$(CONFIG_SCSI_DC390T)	+= tmscsim.o
 obj-$(CONFIG_MEGARAID_LEGACY)	+= megaraid.o
 obj-$(CONFIG_MEGARAID_NEWGEN)	+= megaraid/
 obj-$(CONFIG_MEGARAID_SAS)	+= megaraid/
-obj-$(CONFIG_SCSI_MPT2SAS)	+= mpt2sas/
 obj-$(CONFIG_SCSI_MPT3SAS)	+= mpt3sas/
 obj-$(CONFIG_SCSI_UFSHCD)	+= ufs/
 obj-$(CONFIG_SCSI_ACARD)	+= atp870u.o
diff --git a/drivers/scsi/mpt2sas/Kconfig b/drivers/scsi/mpt2sas/Kconfig
deleted file mode 100644
index 1356a0aa5d14..000000000000
--- a/drivers/scsi/mpt2sas/Kconfig
+++ /dev/null
@@ -1,61 +0,0 @@
-#
-# Kernel configuration file for the MPT2SAS
-#
-# This code is based on drivers/scsi/mpt2sas/Kconfig
-# Copyright (C) 2007-2014  LSI Corporation
-#  (mailto:DL-MPTFusionLinux@lsi.com)
-
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License
-# as published by the Free Software Foundation; either version 2
-# of the License, or (at your option) any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# NO WARRANTY
-# THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
-# CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
-# LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
-# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
-# solely responsible for determining the appropriateness of using and
-# distributing the Program and assumes all risks associated with its
-# exercise of rights under this Agreement, including but not limited to
-# the risks and costs of program errors, damage to or loss of data,
-# programs or equipment, and unavailability or interruption of operations.
-
-# DISCLAIMER OF LIABILITY
-# NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
-# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-# DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
-# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
-# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
-# USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
-# HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
-# USA.
-
-config SCSI_MPT2SAS
-	tristate "LSI MPT Fusion SAS 2.0 Device Driver"
-	depends on PCI && SCSI
-	select SCSI_SAS_ATTRS
-	select RAID_ATTRS
-	---help---
-	This driver supports PCI-Express SAS 6Gb/s Host Adapters.
-
-config SCSI_MPT2SAS_MAX_SGE
-	int "LSI MPT Fusion Max number of SG Entries (16 - 128)"
-	depends on PCI && SCSI && SCSI_MPT2SAS
-	default "128"
-	range 16 128
-	---help---
-	This option allows you to specify the maximum number of scatter-
-	gather entries per I/O. The driver default is 128, which matches
-	SAFE_PHYS_SEGMENTS.  However, it may decreased down to 16.
-	Decreasing this parameter will reduce memory requirements
-	on a per controller instance.
diff --git a/drivers/scsi/mpt2sas/Makefile b/drivers/scsi/mpt2sas/Makefile
deleted file mode 100644
index 37716169b91a..000000000000
--- a/drivers/scsi/mpt2sas/Makefile
+++ /dev/null
@@ -1,15 +0,0 @@
-# mpt2sas makefile
-
-# share the official mpi headers from the mpt3sas driver
-ccflags-y += -I$(src)/../mpt3sas
-ccflags-y += -DSCSI_MPT2SAS
-
-# use the common object files from mpt3sas driver
-obj-$(CONFIG_SCSI_MPT2SAS) += mpt2sas.o
-mpt2sas-y +=  ../mpt3sas/mpt3sas_base.o        \
-		../mpt3sas/mpt3sas_config.o    \
-		../mpt3sas/mpt3sas_scsih.o     \
-		../mpt3sas/mpt3sas_transport.o \
-		../mpt3sas/mpt3sas_ctl.o       \
-		../mpt3sas/mpt3sas_trigger_diag.o  \
-		mpt2sas_module.o
diff --git a/drivers/scsi/mpt2sas/mpt2sas_base.c b/drivers/scsi/mpt2sas/mpt2sas_base.c
deleted file mode 100644
index c167911221e9..000000000000
--- a/drivers/scsi/mpt2sas/mpt2sas_base.c
+++ /dev/null
@@ -1,4899 +0,0 @@
-/*
- * This is the Fusion MPT base driver providing common API layer interface
- * for access to MPT (Message Passing Technology) firmware.
- *
- * This code is based on drivers/scsi/mpt2sas/mpt2_base.c
- * Copyright (C) 2007-2014  LSI Corporation
- * Copyright (C) 20013-2014 Avago Technologies
- *  (mailto: MPT-FusionLinux.pdl@avagotech.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * NO WARRANTY
- * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
- * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
- * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
- * solely responsible for determining the appropriateness of using and
- * distributing the Program and assumes all risks associated with its
- * exercise of rights under this Agreement, including but not limited to
- * the risks and costs of program errors, damage to or loss of data,
- * programs or equipment, and unavailability or interruption of operations.
-
- * DISCLAIMER OF LIABILITY
- * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
- * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
-
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
- * USA.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/types.h>
-#include <linux/pci.h>
-#include <linux/kdev_t.h>
-#include <linux/blkdev.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/dma-mapping.h>
-#include <linux/sort.h>
-#include <linux/io.h>
-#include <linux/time.h>
-#include <linux/kthread.h>
-#include <linux/aer.h>
-
-#include "mpt2sas_base.h"
-
-static MPT_CALLBACK	mpt_callbacks[MPT_MAX_CALLBACKS];
-
-#define FAULT_POLLING_INTERVAL 1000 /* in milliseconds */
-
-#define MAX_HBA_QUEUE_DEPTH	30000
-#define MAX_CHAIN_DEPTH		100000
-static int max_queue_depth = -1;
-module_param(max_queue_depth, int, 0);
-MODULE_PARM_DESC(max_queue_depth, " max controller queue depth ");
-
-static int max_sgl_entries = -1;
-module_param(max_sgl_entries, int, 0);
-MODULE_PARM_DESC(max_sgl_entries, " max sg entries ");
-
-static int msix_disable = -1;
-module_param(msix_disable, int, 0);
-MODULE_PARM_DESC(msix_disable, " disable msix routed interrupts (default=0)");
-
-static int max_msix_vectors = -1;
-module_param(max_msix_vectors, int, 0);
-MODULE_PARM_DESC(max_msix_vectors, " max msix vectors ");
-
-static int mpt2sas_fwfault_debug;
-MODULE_PARM_DESC(mpt2sas_fwfault_debug, " enable detection of firmware fault "
-	"and halt firmware - (default=0)");
-
-static int disable_discovery = -1;
-module_param(disable_discovery, int, 0);
-MODULE_PARM_DESC(disable_discovery, " disable discovery ");
-
-static int
-_base_get_ioc_facts(struct MPT2SAS_ADAPTER *ioc, int sleep_flag);
-
-static int
-_base_diag_reset(struct MPT2SAS_ADAPTER *ioc, int sleep_flag);
-
-/**
- * _scsih_set_fwfault_debug - global setting of ioc->fwfault_debug.
- *
- */
-static int
-_scsih_set_fwfault_debug(const char *val, struct kernel_param *kp)
-{
-	int ret = param_set_int(val, kp);
-	struct MPT2SAS_ADAPTER *ioc;
-
-	if (ret)
-		return ret;
-
-	/* global ioc spinlock to protect controller list on list operations */
-	printk(KERN_INFO "setting fwfault_debug(%d)\n", mpt2sas_fwfault_debug);
-	spin_lock(&gioc_lock);
-	list_for_each_entry(ioc, &mpt2sas_ioc_list, list)
-		ioc->fwfault_debug = mpt2sas_fwfault_debug;
-	spin_unlock(&gioc_lock);
-	return 0;
-}
-
-module_param_call(mpt2sas_fwfault_debug, _scsih_set_fwfault_debug,
-    param_get_int, &mpt2sas_fwfault_debug, 0644);
-
-/**
- *  mpt2sas_remove_dead_ioc_func - kthread context to remove dead ioc
- * @arg: input argument, used to derive ioc
- *
- * Return 0 if controller is removed from pci subsystem.
- * Return -1 for other case.
- */
-static int mpt2sas_remove_dead_ioc_func(void *arg)
-{
-		struct MPT2SAS_ADAPTER *ioc = (struct MPT2SAS_ADAPTER *)arg;
-		struct pci_dev *pdev;
-
-		if ((ioc == NULL))
-			return -1;
-
-		pdev = ioc->pdev;
-		if ((pdev == NULL))
-			return -1;
-		pci_stop_and_remove_bus_device_locked(pdev);
-		return 0;
-}
-
-
-/**
- * _base_fault_reset_work - workq handling ioc fault conditions
- * @work: input argument, used to derive ioc
- * Context: sleep.
- *
- * Return nothing.
- */
-static void
-_base_fault_reset_work(struct work_struct *work)
-{
-	struct MPT2SAS_ADAPTER *ioc =
-	    container_of(work, struct MPT2SAS_ADAPTER, fault_reset_work.work);
-	unsigned long	 flags;
-	u32 doorbell;
-	int rc;
-	struct task_struct *p;
-
-	spin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);
-	if (ioc->shost_recovery || ioc->pci_error_recovery)
-		goto rearm_timer;
-	spin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);
-
-	doorbell = mpt2sas_base_get_iocstate(ioc, 0);
-	if ((doorbell & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_MASK) {
-		printk(MPT2SAS_INFO_FMT "%s : SAS host is non-operational !!!!\n",
-			ioc->name, __func__);
-
-		/* It may be possible that EEH recovery can resolve some of
-		 * pci bus failure issues rather removing the dead ioc function
-		 * by considering controller is in a non-operational state. So
-		 * here priority is given to the EEH recovery. If it doesn't
-		 * not resolve this issue, mpt2sas driver will consider this
-		 * controller to non-operational state and remove the dead ioc
-		 * function.
-		 */
-		if (ioc->non_operational_loop++ < 5) {
-			spin_lock_irqsave(&ioc->ioc_reset_in_progress_lock,
-							 flags);
-			goto rearm_timer;
-		}
-
-		/*
-		 * Call _scsih_flush_pending_cmds callback so that we flush all
-		 * pending commands back to OS. This call is required to aovid
-		 * deadlock at block layer. Dead IOC will fail to do diag reset,
-		 * and this call is safe since dead ioc will never return any
-		 * command back from HW.
-		 */
-		ioc->schedule_dead_ioc_flush_running_cmds(ioc);
-		/*
-		 * Set remove_host flag early since kernel thread will
-		 * take some time to execute.
-		 */
-		ioc->remove_host = 1;
-		/*Remove the Dead Host */
-		p = kthread_run(mpt2sas_remove_dead_ioc_func, ioc,
-		    "mpt2sas_dead_ioc_%d", ioc->id);
-		if (IS_ERR(p)) {
-			printk(MPT2SAS_ERR_FMT
-			"%s: Running mpt2sas_dead_ioc thread failed !!!!\n",
-			ioc->name, __func__);
-		} else {
-		    printk(MPT2SAS_ERR_FMT
-			"%s: Running mpt2sas_dead_ioc thread success !!!!\n",
-			ioc->name, __func__);
-		}
-
-		return; /* don't rearm timer */
-	}
-
-	ioc->non_operational_loop = 0;
-
-	if ((doorbell & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {
-		rc = mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-		    FORCE_BIG_HAMMER);
-		printk(MPT2SAS_WARN_FMT "%s: hard reset: %s\n", ioc->name,
-		    __func__, (rc == 0) ? "success" : "failed");
-		doorbell = mpt2sas_base_get_iocstate(ioc, 0);
-		if ((doorbell & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT)
-			mpt2sas_base_fault_info(ioc, doorbell &
-			    MPI2_DOORBELL_DATA_MASK);
-	}
-
-	spin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);
- rearm_timer:
-	if (ioc->fault_reset_work_q)
-		queue_delayed_work(ioc->fault_reset_work_q,
-		    &ioc->fault_reset_work,
-		    msecs_to_jiffies(FAULT_POLLING_INTERVAL));
-	spin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);
-}
-
-/**
- * mpt2sas_base_start_watchdog - start the fault_reset_work_q
- * @ioc: per adapter object
- * Context: sleep.
- *
- * Return nothing.
- */
-void
-mpt2sas_base_start_watchdog(struct MPT2SAS_ADAPTER *ioc)
-{
-	unsigned long	 flags;
-
-	if (ioc->fault_reset_work_q)
-		return;
-
-	/* initialize fault polling */
-	INIT_DELAYED_WORK(&ioc->fault_reset_work, _base_fault_reset_work);
-	snprintf(ioc->fault_reset_work_q_name,
-	    sizeof(ioc->fault_reset_work_q_name), "poll_%d_status", ioc->id);
-	ioc->fault_reset_work_q =
-		create_singlethread_workqueue(ioc->fault_reset_work_q_name);
-	if (!ioc->fault_reset_work_q) {
-		printk(MPT2SAS_ERR_FMT "%s: failed (line=%d)\n",
-		    ioc->name, __func__, __LINE__);
-			return;
-	}
-	spin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);
-	if (ioc->fault_reset_work_q)
-		queue_delayed_work(ioc->fault_reset_work_q,
-		    &ioc->fault_reset_work,
-		    msecs_to_jiffies(FAULT_POLLING_INTERVAL));
-	spin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);
-}
-
-/**
- * mpt2sas_base_stop_watchdog - stop the fault_reset_work_q
- * @ioc: per adapter object
- * Context: sleep.
- *
- * Return nothing.
- */
-void
-mpt2sas_base_stop_watchdog(struct MPT2SAS_ADAPTER *ioc)
-{
-	unsigned long	 flags;
-	struct workqueue_struct *wq;
-
-	spin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);
-	wq = ioc->fault_reset_work_q;
-	ioc->fault_reset_work_q = NULL;
-	spin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);
-	if (wq) {
-		if (!cancel_delayed_work_sync(&ioc->fault_reset_work))
-			flush_workqueue(wq);
-		destroy_workqueue(wq);
-	}
-}
-
-/**
- * mpt2sas_base_fault_info - verbose translation of firmware FAULT code
- * @ioc: per adapter object
- * @fault_code: fault code
- *
- * Return nothing.
- */
-void
-mpt2sas_base_fault_info(struct MPT2SAS_ADAPTER *ioc , u16 fault_code)
-{
-	printk(MPT2SAS_ERR_FMT "fault_state(0x%04x)!\n",
-	    ioc->name, fault_code);
-}
-
-/**
- * mpt2sas_halt_firmware - halt's mpt controller firmware
- * @ioc: per adapter object
- *
- * For debugging timeout related issues.  Writing 0xCOFFEE00
- * to the doorbell register will halt controller firmware. With
- * the purpose to stop both driver and firmware, the enduser can
- * obtain a ring buffer from controller UART.
- */
-void
-mpt2sas_halt_firmware(struct MPT2SAS_ADAPTER *ioc)
-{
-	u32 doorbell;
-
-	if (!ioc->fwfault_debug)
-		return;
-
-	dump_stack();
-
-	doorbell = readl(&ioc->chip->Doorbell);
-	if ((doorbell & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT)
-		mpt2sas_base_fault_info(ioc , doorbell);
-	else {
-		writel(0xC0FFEE00, &ioc->chip->Doorbell);
-		printk(MPT2SAS_ERR_FMT "Firmware is halted due to command "
-		    "timeout\n", ioc->name);
-	}
-
-	panic("panic in %s\n", __func__);
-}
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-/**
- * _base_sas_ioc_info - verbose translation of the ioc status
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @request_hdr: request mf
- *
- * Return nothing.
- */
-static void
-_base_sas_ioc_info(struct MPT2SAS_ADAPTER *ioc, MPI2DefaultReply_t *mpi_reply,
-     MPI2RequestHeader_t *request_hdr)
-{
-	u16 ioc_status = le16_to_cpu(mpi_reply->IOCStatus) &
-	    MPI2_IOCSTATUS_MASK;
-	char *desc = NULL;
-	u16 frame_sz;
-	char *func_str = NULL;
-
-	/* SCSI_IO, RAID_PASS are handled from _scsih_scsi_ioc_info */
-	if (request_hdr->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||
-	    request_hdr->Function == MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH ||
-	    request_hdr->Function == MPI2_FUNCTION_EVENT_NOTIFICATION)
-		return;
-
-	if (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)
-		return;
-
-	switch (ioc_status) {
-
-/****************************************************************************
-*  Common IOCStatus values for all replies
-****************************************************************************/
-
-	case MPI2_IOCSTATUS_INVALID_FUNCTION:
-		desc = "invalid function";
-		break;
-	case MPI2_IOCSTATUS_BUSY:
-		desc = "busy";
-		break;
-	case MPI2_IOCSTATUS_INVALID_SGL:
-		desc = "invalid sgl";
-		break;
-	case MPI2_IOCSTATUS_INTERNAL_ERROR:
-		desc = "internal error";
-		break;
-	case MPI2_IOCSTATUS_INVALID_VPID:
-		desc = "invalid vpid";
-		break;
-	case MPI2_IOCSTATUS_INSUFFICIENT_RESOURCES:
-		desc = "insufficient resources";
-		break;
-	case MPI2_IOCSTATUS_INVALID_FIELD:
-		desc = "invalid field";
-		break;
-	case MPI2_IOCSTATUS_INVALID_STATE:
-		desc = "invalid state";
-		break;
-	case MPI2_IOCSTATUS_OP_STATE_NOT_SUPPORTED:
-		desc = "op state not supported";
-		break;
-
-/****************************************************************************
-*  Config IOCStatus values
-****************************************************************************/
-
-	case MPI2_IOCSTATUS_CONFIG_INVALID_ACTION:
-		desc = "config invalid action";
-		break;
-	case MPI2_IOCSTATUS_CONFIG_INVALID_TYPE:
-		desc = "config invalid type";
-		break;
-	case MPI2_IOCSTATUS_CONFIG_INVALID_PAGE:
-		desc = "config invalid page";
-		break;
-	case MPI2_IOCSTATUS_CONFIG_INVALID_DATA:
-		desc = "config invalid data";
-		break;
-	case MPI2_IOCSTATUS_CONFIG_NO_DEFAULTS:
-		desc = "config no defaults";
-		break;
-	case MPI2_IOCSTATUS_CONFIG_CANT_COMMIT:
-		desc = "config cant commit";
-		break;
-
-/****************************************************************************
-*  SCSI IO Reply
-****************************************************************************/
-
-	case MPI2_IOCSTATUS_SCSI_RECOVERED_ERROR:
-	case MPI2_IOCSTATUS_SCSI_INVALID_DEVHANDLE:
-	case MPI2_IOCSTATUS_SCSI_DEVICE_NOT_THERE:
-	case MPI2_IOCSTATUS_SCSI_DATA_OVERRUN:
-	case MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN:
-	case MPI2_IOCSTATUS_SCSI_IO_DATA_ERROR:
-	case MPI2_IOCSTATUS_SCSI_PROTOCOL_ERROR:
-	case MPI2_IOCSTATUS_SCSI_TASK_TERMINATED:
-	case MPI2_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:
-	case MPI2_IOCSTATUS_SCSI_TASK_MGMT_FAILED:
-	case MPI2_IOCSTATUS_SCSI_IOC_TERMINATED:
-	case MPI2_IOCSTATUS_SCSI_EXT_TERMINATED:
-		break;
-
-/****************************************************************************
-*  For use by SCSI Initiator and SCSI Target end-to-end data protection
-****************************************************************************/
-
-	case MPI2_IOCSTATUS_EEDP_GUARD_ERROR:
-		desc = "eedp guard error";
-		break;
-	case MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:
-		desc = "eedp ref tag error";
-		break;
-	case MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:
-		desc = "eedp app tag error";
-		break;
-
-/****************************************************************************
-*  SCSI Target values
-****************************************************************************/
-
-	case MPI2_IOCSTATUS_TARGET_INVALID_IO_INDEX:
-		desc = "target invalid io index";
-		break;
-	case MPI2_IOCSTATUS_TARGET_ABORTED:
-		desc = "target aborted";
-		break;
-	case MPI2_IOCSTATUS_TARGET_NO_CONN_RETRYABLE:
-		desc = "target no conn retryable";
-		break;
-	case MPI2_IOCSTATUS_TARGET_NO_CONNECTION:
-		desc = "target no connection";
-		break;
-	case MPI2_IOCSTATUS_TARGET_XFER_COUNT_MISMATCH:
-		desc = "target xfer count mismatch";
-		break;
-	case MPI2_IOCSTATUS_TARGET_DATA_OFFSET_ERROR:
-		desc = "target data offset error";
-		break;
-	case MPI2_IOCSTATUS_TARGET_TOO_MUCH_WRITE_DATA:
-		desc = "target too much write data";
-		break;
-	case MPI2_IOCSTATUS_TARGET_IU_TOO_SHORT:
-		desc = "target iu too short";
-		break;
-	case MPI2_IOCSTATUS_TARGET_ACK_NAK_TIMEOUT:
-		desc = "target ack nak timeout";
-		break;
-	case MPI2_IOCSTATUS_TARGET_NAK_RECEIVED:
-		desc = "target nak received";
-		break;
-
-/****************************************************************************
-*  Serial Attached SCSI values
-****************************************************************************/
-
-	case MPI2_IOCSTATUS_SAS_SMP_REQUEST_FAILED:
-		desc = "smp request failed";
-		break;
-	case MPI2_IOCSTATUS_SAS_SMP_DATA_OVERRUN:
-		desc = "smp data overrun";
-		break;
-
-/****************************************************************************
-*  Diagnostic Buffer Post / Diagnostic Release values
-****************************************************************************/
-
-	case MPI2_IOCSTATUS_DIAGNOSTIC_RELEASED:
-		desc = "diagnostic released";
-		break;
-	default:
-		break;
-	}
-
-	if (!desc)
-		return;
-
-	switch (request_hdr->Function) {
-	case MPI2_FUNCTION_CONFIG:
-		frame_sz = sizeof(Mpi2ConfigRequest_t) + ioc->sge_size;
-		func_str = "config_page";
-		break;
-	case MPI2_FUNCTION_SCSI_TASK_MGMT:
-		frame_sz = sizeof(Mpi2SCSITaskManagementRequest_t);
-		func_str = "task_mgmt";
-		break;
-	case MPI2_FUNCTION_SAS_IO_UNIT_CONTROL:
-		frame_sz = sizeof(Mpi2SasIoUnitControlRequest_t);
-		func_str = "sas_iounit_ctl";
-		break;
-	case MPI2_FUNCTION_SCSI_ENCLOSURE_PROCESSOR:
-		frame_sz = sizeof(Mpi2SepRequest_t);
-		func_str = "enclosure";
-		break;
-	case MPI2_FUNCTION_IOC_INIT:
-		frame_sz = sizeof(Mpi2IOCInitRequest_t);
-		func_str = "ioc_init";
-		break;
-	case MPI2_FUNCTION_PORT_ENABLE:
-		frame_sz = sizeof(Mpi2PortEnableRequest_t);
-		func_str = "port_enable";
-		break;
-	case MPI2_FUNCTION_SMP_PASSTHROUGH:
-		frame_sz = sizeof(Mpi2SmpPassthroughRequest_t) + ioc->sge_size;
-		func_str = "smp_passthru";
-		break;
-	default:
-		frame_sz = 32;
-		func_str = "unknown";
-		break;
-	}
-
-	printk(MPT2SAS_WARN_FMT "ioc_status: %s(0x%04x), request(0x%p),"
-	    " (%s)\n", ioc->name, desc, ioc_status, request_hdr, func_str);
-
-	_debug_dump_mf(request_hdr, frame_sz/4);
-}
-
-/**
- * _base_display_event_data - verbose translation of firmware asyn events
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- *
- * Return nothing.
- */
-static void
-_base_display_event_data(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventNotificationReply_t *mpi_reply)
-{
-	char *desc = NULL;
-	u16 event;
-
-	if (!(ioc->logging_level & MPT_DEBUG_EVENTS))
-		return;
-
-	event = le16_to_cpu(mpi_reply->Event);
-
-	switch (event) {
-	case MPI2_EVENT_LOG_DATA:
-		desc = "Log Data";
-		break;
-	case MPI2_EVENT_STATE_CHANGE:
-		desc = "Status Change";
-		break;
-	case MPI2_EVENT_HARD_RESET_RECEIVED:
-		desc = "Hard Reset Received";
-		break;
-	case MPI2_EVENT_EVENT_CHANGE:
-		desc = "Event Change";
-		break;
-	case MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE:
-		desc = "Device Status Change";
-		break;
-	case MPI2_EVENT_IR_OPERATION_STATUS:
-		if (!ioc->hide_ir_msg)
-			desc = "IR Operation Status";
-		break;
-	case MPI2_EVENT_SAS_DISCOVERY:
-	{
-		Mpi2EventDataSasDiscovery_t *event_data =
-		    (Mpi2EventDataSasDiscovery_t *)mpi_reply->EventData;
-		printk(MPT2SAS_INFO_FMT "Discovery: (%s)", ioc->name,
-		    (event_data->ReasonCode == MPI2_EVENT_SAS_DISC_RC_STARTED) ?
-		    "start" : "stop");
-		if (event_data->DiscoveryStatus)
-			printk("discovery_status(0x%08x)",
-			    le32_to_cpu(event_data->DiscoveryStatus));
-		printk("\n");
-		return;
-	}
-	case MPI2_EVENT_SAS_BROADCAST_PRIMITIVE:
-		desc = "SAS Broadcast Primitive";
-		break;
-	case MPI2_EVENT_SAS_INIT_DEVICE_STATUS_CHANGE:
-		desc = "SAS Init Device Status Change";
-		break;
-	case MPI2_EVENT_SAS_INIT_TABLE_OVERFLOW:
-		desc = "SAS Init Table Overflow";
-		break;
-	case MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST:
-		desc = "SAS Topology Change List";
-		break;
-	case MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE:
-		desc = "SAS Enclosure Device Status Change";
-		break;
-	case MPI2_EVENT_IR_VOLUME:
-		if (!ioc->hide_ir_msg)
-			desc = "IR Volume";
-		break;
-	case MPI2_EVENT_IR_PHYSICAL_DISK:
-		if (!ioc->hide_ir_msg)
-			desc = "IR Physical Disk";
-		break;
-	case MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST:
-		if (!ioc->hide_ir_msg)
-			desc = "IR Configuration Change List";
-		break;
-	case MPI2_EVENT_LOG_ENTRY_ADDED:
-		if (!ioc->hide_ir_msg)
-			desc = "Log Entry Added";
-		break;
-	case MPI2_EVENT_TEMP_THRESHOLD:
-		desc = "Temperature Threshold";
-		break;
-	}
-
-	if (!desc)
-		return;
-
-	printk(MPT2SAS_INFO_FMT "%s\n", ioc->name, desc);
-}
-#endif
-
-/**
- * _base_sas_log_info - verbose translation of firmware log info
- * @ioc: per adapter object
- * @log_info: log info
- *
- * Return nothing.
- */
-static void
-_base_sas_log_info(struct MPT2SAS_ADAPTER *ioc , u32 log_info)
-{
-	union loginfo_type {
-		u32	loginfo;
-		struct {
-			u32	subcode:16;
-			u32	code:8;
-			u32	originator:4;
-			u32	bus_type:4;
-		} dw;
-	};
-	union loginfo_type sas_loginfo;
-	char *originator_str = NULL;
-
-	sas_loginfo.loginfo = log_info;
-	if (sas_loginfo.dw.bus_type != 3 /*SAS*/)
-		return;
-
-	/* each nexus loss loginfo */
-	if (log_info == 0x31170000)
-		return;
-
-	/* eat the loginfos associated with task aborts */
-	if (ioc->ignore_loginfos && (log_info == 0x30050000 || log_info ==
-	    0x31140000 || log_info == 0x31130000))
-		return;
-
-	switch (sas_loginfo.dw.originator) {
-	case 0:
-		originator_str = "IOP";
-		break;
-	case 1:
-		originator_str = "PL";
-		break;
-	case 2:
-		if (!ioc->hide_ir_msg)
-			originator_str = "IR";
-		else
-			originator_str = "WarpDrive";
-		break;
-	}
-
-	printk(MPT2SAS_WARN_FMT "log_info(0x%08x): originator(%s), "
-	    "code(0x%02x), sub_code(0x%04x)\n", ioc->name, log_info,
-	     originator_str, sas_loginfo.dw.code,
-	     sas_loginfo.dw.subcode);
-}
-
-/**
- * _base_display_reply_info -
- * @ioc: per adapter object
- * @smid: system request message index
- * @msix_index: MSIX table index supplied by the OS
- * @reply: reply message frame(lower 32bit addr)
- *
- * Return nothing.
- */
-static void
-_base_display_reply_info(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
-    u32 reply)
-{
-	MPI2DefaultReply_t *mpi_reply;
-	u16 ioc_status;
-
-	mpi_reply = mpt2sas_base_get_reply_virt_addr(ioc, reply);
-	if (unlikely(!mpi_reply)) {
-		printk(MPT2SAS_ERR_FMT "mpi_reply not valid at %s:%d/%s()!\n",
-			ioc->name, __FILE__, __LINE__, __func__);
-		return;
-	}
-	ioc_status = le16_to_cpu(mpi_reply->IOCStatus);
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-	if ((ioc_status & MPI2_IOCSTATUS_MASK) &&
-	    (ioc->logging_level & MPT_DEBUG_REPLY)) {
-		_base_sas_ioc_info(ioc , mpi_reply,
-		   mpt2sas_base_get_msg_frame(ioc, smid));
-	}
-#endif
-	if (ioc_status & MPI2_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE)
-		_base_sas_log_info(ioc, le32_to_cpu(mpi_reply->IOCLogInfo));
-}
-
-/**
- * mpt2sas_base_done - base internal command completion routine
- * @ioc: per adapter object
- * @smid: system request message index
- * @msix_index: MSIX table index supplied by the OS
- * @reply: reply message frame(lower 32bit addr)
- *
- * Return 1 meaning mf should be freed from _base_interrupt
- *        0 means the mf is freed from this function.
- */
-u8
-mpt2sas_base_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
-    u32 reply)
-{
-	MPI2DefaultReply_t *mpi_reply;
-
-	mpi_reply = mpt2sas_base_get_reply_virt_addr(ioc, reply);
-	if (mpi_reply && mpi_reply->Function == MPI2_FUNCTION_EVENT_ACK)
-		return 1;
-
-	if (ioc->base_cmds.status == MPT2_CMD_NOT_USED)
-		return 1;
-
-	ioc->base_cmds.status |= MPT2_CMD_COMPLETE;
-	if (mpi_reply) {
-		ioc->base_cmds.status |= MPT2_CMD_REPLY_VALID;
-		memcpy(ioc->base_cmds.reply, mpi_reply, mpi_reply->MsgLength*4);
-	}
-	ioc->base_cmds.status &= ~MPT2_CMD_PENDING;
-
-	complete(&ioc->base_cmds.done);
-	return 1;
-}
-
-/**
- * _base_async_event - main callback handler for firmware asyn events
- * @ioc: per adapter object
- * @msix_index: MSIX table index supplied by the OS
- * @reply: reply message frame(lower 32bit addr)
- *
- * Returns void.
- */
-static void
-_base_async_event(struct MPT2SAS_ADAPTER *ioc, u8 msix_index, u32 reply)
-{
-	Mpi2EventNotificationReply_t *mpi_reply;
-	Mpi2EventAckRequest_t *ack_request;
-	u16 smid;
-
-	mpi_reply = mpt2sas_base_get_reply_virt_addr(ioc, reply);
-	if (!mpi_reply)
-		return;
-	if (mpi_reply->Function != MPI2_FUNCTION_EVENT_NOTIFICATION)
-		return;
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-	_base_display_event_data(ioc, mpi_reply);
-#endif
-	if (!(mpi_reply->AckRequired & MPI2_EVENT_NOTIFICATION_ACK_REQUIRED))
-		goto out;
-	smid = mpt2sas_base_get_smid(ioc, ioc->base_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		goto out;
-	}
-
-	ack_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	memset(ack_request, 0, sizeof(Mpi2EventAckRequest_t));
-	ack_request->Function = MPI2_FUNCTION_EVENT_ACK;
-	ack_request->Event = mpi_reply->Event;
-	ack_request->EventContext = mpi_reply->EventContext;
-	ack_request->VF_ID = 0;  /* TODO */
-	ack_request->VP_ID = 0;
-	mpt2sas_base_put_smid_default(ioc, smid);
-
- out:
-
-	/* scsih callback handler */
-	mpt2sas_scsih_event_callback(ioc, msix_index, reply);
-
-	/* ctl callback handler */
-	mpt2sas_ctl_event_callback(ioc, msix_index, reply);
-
-	return;
-}
-
-/**
- * _base_get_cb_idx - obtain the callback index
- * @ioc: per adapter object
- * @smid: system request message index
- *
- * Return callback index.
- */
-static u8
-_base_get_cb_idx(struct MPT2SAS_ADAPTER *ioc, u16 smid)
-{
-	int i;
-	u8 cb_idx;
-
-	if (smid < ioc->hi_priority_smid) {
-		i = smid - 1;
-		cb_idx = ioc->scsi_lookup[i].cb_idx;
-	} else if (smid < ioc->internal_smid) {
-		i = smid - ioc->hi_priority_smid;
-		cb_idx = ioc->hpr_lookup[i].cb_idx;
-	} else if (smid <= ioc->hba_queue_depth) {
-		i = smid - ioc->internal_smid;
-		cb_idx = ioc->internal_lookup[i].cb_idx;
-	} else
-		cb_idx = 0xFF;
-	return cb_idx;
-}
-
-/**
- * _base_mask_interrupts - disable interrupts
- * @ioc: per adapter object
- *
- * Disabling ResetIRQ, Reply and Doorbell Interrupts
- *
- * Return nothing.
- */
-static void
-_base_mask_interrupts(struct MPT2SAS_ADAPTER *ioc)
-{
-	u32 him_register;
-
-	ioc->mask_interrupts = 1;
-	him_register = readl(&ioc->chip->HostInterruptMask);
-	him_register |= MPI2_HIM_DIM + MPI2_HIM_RIM + MPI2_HIM_RESET_IRQ_MASK;
-	writel(him_register, &ioc->chip->HostInterruptMask);
-	readl(&ioc->chip->HostInterruptMask);
-}
-
-/**
- * _base_unmask_interrupts - enable interrupts
- * @ioc: per adapter object
- *
- * Enabling only Reply Interrupts
- *
- * Return nothing.
- */
-static void
-_base_unmask_interrupts(struct MPT2SAS_ADAPTER *ioc)
-{
-	u32 him_register;
-
-	him_register = readl(&ioc->chip->HostInterruptMask);
-	him_register &= ~MPI2_HIM_RIM;
-	writel(him_register, &ioc->chip->HostInterruptMask);
-	ioc->mask_interrupts = 0;
-}
-
-union reply_descriptor {
-	u64 word;
-	struct {
-		u32 low;
-		u32 high;
-	} u;
-};
-
-/**
- * _base_interrupt - MPT adapter (IOC) specific interrupt handler.
- * @irq: irq number (not used)
- * @bus_id: bus identifier cookie == pointer to MPT_ADAPTER structure
- * @r: pt_regs pointer (not used)
- *
- * Return IRQ_HANDLE if processed, else IRQ_NONE.
- */
-static irqreturn_t
-_base_interrupt(int irq, void *bus_id)
-{
-	struct adapter_reply_queue *reply_q = bus_id;
-	union reply_descriptor rd;
-	u32 completed_cmds;
-	u8 request_desript_type;
-	u16 smid;
-	u8 cb_idx;
-	u32 reply;
-	u8 msix_index = reply_q->msix_index;
-	struct MPT2SAS_ADAPTER *ioc = reply_q->ioc;
-	Mpi2ReplyDescriptorsUnion_t *rpf;
-	u8 rc;
-
-	if (ioc->mask_interrupts)
-		return IRQ_NONE;
-
-	if (!atomic_add_unless(&reply_q->busy, 1, 1))
-		return IRQ_NONE;
-
-	rpf = &reply_q->reply_post_free[reply_q->reply_post_host_index];
-	request_desript_type = rpf->Default.ReplyFlags
-	     & MPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK;
-	if (request_desript_type == MPI2_RPY_DESCRIPT_FLAGS_UNUSED) {
-		atomic_dec(&reply_q->busy);
-		return IRQ_NONE;
-	}
-
-	completed_cmds = 0;
-	cb_idx = 0xFF;
-	do {
-		rd.word = le64_to_cpu(rpf->Words);
-		if (rd.u.low == UINT_MAX || rd.u.high == UINT_MAX)
-			goto out;
-		reply = 0;
-		smid = le16_to_cpu(rpf->Default.DescriptorTypeDependent1);
-		if (request_desript_type ==
-		    MPI2_RPY_DESCRIPT_FLAGS_ADDRESS_REPLY) {
-			reply = le32_to_cpu
-				(rpf->AddressReply.ReplyFrameAddress);
-			if (reply > ioc->reply_dma_max_address ||
-			    reply < ioc->reply_dma_min_address)
-				reply = 0;
-		} else if (request_desript_type ==
-		    MPI2_RPY_DESCRIPT_FLAGS_TARGET_COMMAND_BUFFER)
-			goto next;
-		else if (request_desript_type ==
-		    MPI2_RPY_DESCRIPT_FLAGS_TARGETASSIST_SUCCESS)
-			goto next;
-		if (smid) {
-			cb_idx = _base_get_cb_idx(ioc, smid);
-		if ((likely(cb_idx < MPT_MAX_CALLBACKS))
-			    && (likely(mpt_callbacks[cb_idx] != NULL))) {
-				rc = mpt_callbacks[cb_idx](ioc, smid,
-				    msix_index, reply);
-			if (reply)
-				_base_display_reply_info(ioc, smid,
-				    msix_index, reply);
-			if (rc)
-				mpt2sas_base_free_smid(ioc, smid);
-			}
-		}
-		if (!smid)
-			_base_async_event(ioc, msix_index, reply);
-
-		/* reply free queue handling */
-		if (reply) {
-			ioc->reply_free_host_index =
-			    (ioc->reply_free_host_index ==
-			    (ioc->reply_free_queue_depth - 1)) ?
-			    0 : ioc->reply_free_host_index + 1;
-			ioc->reply_free[ioc->reply_free_host_index] =
-			    cpu_to_le32(reply);
-			wmb();
-			writel(ioc->reply_free_host_index,
-			    &ioc->chip->ReplyFreeHostIndex);
-		}
-
- next:
-
-		rpf->Words = cpu_to_le64(ULLONG_MAX);
-		reply_q->reply_post_host_index =
-		    (reply_q->reply_post_host_index ==
-		    (ioc->reply_post_queue_depth - 1)) ? 0 :
-		    reply_q->reply_post_host_index + 1;
-		request_desript_type =
-		    reply_q->reply_post_free[reply_q->reply_post_host_index].
-		    Default.ReplyFlags & MPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK;
-		completed_cmds++;
-		if (request_desript_type == MPI2_RPY_DESCRIPT_FLAGS_UNUSED)
-			goto out;
-		if (!reply_q->reply_post_host_index)
-			rpf = reply_q->reply_post_free;
-		else
-			rpf++;
-	} while (1);
-
- out:
-
-	if (!completed_cmds) {
-		atomic_dec(&reply_q->busy);
-		return IRQ_NONE;
-	}
-	wmb();
-	if (ioc->is_warpdrive) {
-		writel(reply_q->reply_post_host_index,
-		ioc->reply_post_host_index[msix_index]);
-		atomic_dec(&reply_q->busy);
-		return IRQ_HANDLED;
-	}
-	writel(reply_q->reply_post_host_index | (msix_index <<
-	    MPI2_RPHI_MSIX_INDEX_SHIFT), &ioc->chip->ReplyPostHostIndex);
-	atomic_dec(&reply_q->busy);
-	return IRQ_HANDLED;
-}
-
-/**
- * _base_is_controller_msix_enabled - is controller support muli-reply queues
- * @ioc: per adapter object
- *
- */
-static inline int
-_base_is_controller_msix_enabled(struct MPT2SAS_ADAPTER *ioc)
-{
-	return (ioc->facts.IOCCapabilities &
-	    MPI2_IOCFACTS_CAPABILITY_MSI_X_INDEX) && ioc->msix_enable;
-}
-
-/**
- * mpt2sas_base_flush_reply_queues - flushing the MSIX reply queues
- * @ioc: per adapter object
- * Context: ISR conext
- *
- * Called when a Task Management request has completed. We want
- * to flush the other reply queues so all the outstanding IO has been
- * completed back to OS before we process the TM completetion.
- *
- * Return nothing.
- */
-void
-mpt2sas_base_flush_reply_queues(struct MPT2SAS_ADAPTER *ioc)
-{
-	struct adapter_reply_queue *reply_q;
-
-	/* If MSIX capability is turned off
-	 * then multi-queues are not enabled
-	 */
-	if (!_base_is_controller_msix_enabled(ioc))
-		return;
-
-	list_for_each_entry(reply_q, &ioc->reply_queue_list, list) {
-		if (ioc->shost_recovery)
-			return;
-		/* TMs are on msix_index == 0 */
-		if (reply_q->msix_index == 0)
-			continue;
-		_base_interrupt(reply_q->vector, (void *)reply_q);
-	}
-}
-
-/**
- * mpt2sas_base_release_callback_handler - clear interrupt callback handler
- * @cb_idx: callback index
- *
- * Return nothing.
- */
-void
-mpt2sas_base_release_callback_handler(u8 cb_idx)
-{
-	mpt_callbacks[cb_idx] = NULL;
-}
-
-/**
- * mpt2sas_base_register_callback_handler - obtain index for the interrupt callback handler
- * @cb_func: callback function
- *
- * Returns cb_func.
- */
-u8
-mpt2sas_base_register_callback_handler(MPT_CALLBACK cb_func)
-{
-	u8 cb_idx;
-
-	for (cb_idx = MPT_MAX_CALLBACKS-1; cb_idx; cb_idx--)
-		if (mpt_callbacks[cb_idx] == NULL)
-			break;
-
-	mpt_callbacks[cb_idx] = cb_func;
-	return cb_idx;
-}
-
-/**
- * mpt2sas_base_initialize_callback_handler - initialize the interrupt callback handler
- *
- * Return nothing.
- */
-void
-mpt2sas_base_initialize_callback_handler(void)
-{
-	u8 cb_idx;
-
-	for (cb_idx = 0; cb_idx < MPT_MAX_CALLBACKS; cb_idx++)
-		mpt2sas_base_release_callback_handler(cb_idx);
-}
-
-/**
- * mpt2sas_base_build_zero_len_sge - build zero length sg entry
- * @ioc: per adapter object
- * @paddr: virtual address for SGE
- *
- * Create a zero length scatter gather entry to insure the IOCs hardware has
- * something to use if the target device goes brain dead and tries
- * to send data even when none is asked for.
- *
- * Return nothing.
- */
-void
-mpt2sas_base_build_zero_len_sge(struct MPT2SAS_ADAPTER *ioc, void *paddr)
-{
-	u32 flags_length = (u32)((MPI2_SGE_FLAGS_LAST_ELEMENT |
-	    MPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_END_OF_LIST |
-	    MPI2_SGE_FLAGS_SIMPLE_ELEMENT) <<
-	    MPI2_SGE_FLAGS_SHIFT);
-	ioc->base_add_sg_single(paddr, flags_length, -1);
-}
-
-/**
- * _base_add_sg_single_32 - Place a simple 32 bit SGE at address pAddr.
- * @paddr: virtual address for SGE
- * @flags_length: SGE flags and data transfer length
- * @dma_addr: Physical address
- *
- * Return nothing.
- */
-static void
-_base_add_sg_single_32(void *paddr, u32 flags_length, dma_addr_t dma_addr)
-{
-	Mpi2SGESimple32_t *sgel = paddr;
-
-	flags_length |= (MPI2_SGE_FLAGS_32_BIT_ADDRESSING |
-	    MPI2_SGE_FLAGS_SYSTEM_ADDRESS) << MPI2_SGE_FLAGS_SHIFT;
-	sgel->FlagsLength = cpu_to_le32(flags_length);
-	sgel->Address = cpu_to_le32(dma_addr);
-}
-
-
-/**
- * _base_add_sg_single_64 - Place a simple 64 bit SGE at address pAddr.
- * @paddr: virtual address for SGE
- * @flags_length: SGE flags and data transfer length
- * @dma_addr: Physical address
- *
- * Return nothing.
- */
-static void
-_base_add_sg_single_64(void *paddr, u32 flags_length, dma_addr_t dma_addr)
-{
-	Mpi2SGESimple64_t *sgel = paddr;
-
-	flags_length |= (MPI2_SGE_FLAGS_64_BIT_ADDRESSING |
-	    MPI2_SGE_FLAGS_SYSTEM_ADDRESS) << MPI2_SGE_FLAGS_SHIFT;
-	sgel->FlagsLength = cpu_to_le32(flags_length);
-	sgel->Address = cpu_to_le64(dma_addr);
-}
-
-#define convert_to_kb(x) ((x) << (PAGE_SHIFT - 10))
-
-/**
- * _base_config_dma_addressing - set dma addressing
- * @ioc: per adapter object
- * @pdev: PCI device struct
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_base_config_dma_addressing(struct MPT2SAS_ADAPTER *ioc, struct pci_dev *pdev)
-{
-	struct sysinfo s;
-	u64 consistent_dma_mask;
-
-	if (ioc->dma_mask)
-		consistent_dma_mask = DMA_BIT_MASK(64);
-	else
-		consistent_dma_mask = DMA_BIT_MASK(32);
-
-	if (sizeof(dma_addr_t) > 4) {
-		const uint64_t required_mask =
-		    dma_get_required_mask(&pdev->dev);
-		if ((required_mask > DMA_BIT_MASK(32)) &&
-		    !pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) &&
-		    !pci_set_consistent_dma_mask(pdev, consistent_dma_mask)) {
-			ioc->base_add_sg_single = &_base_add_sg_single_64;
-			ioc->sge_size = sizeof(Mpi2SGESimple64_t);
-			ioc->dma_mask = 64;
-			goto out;
-		}
-	}
-
-	if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))
-	    && !pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {
-		ioc->base_add_sg_single = &_base_add_sg_single_32;
-		ioc->sge_size = sizeof(Mpi2SGESimple32_t);
-		ioc->dma_mask = 32;
-	} else
-		return -ENODEV;
-
- out:
-	si_meminfo(&s);
-	printk(MPT2SAS_INFO_FMT
-	    "%d BIT PCI BUS DMA ADDRESSING SUPPORTED, total mem (%ld kB)\n",
-	    ioc->name, ioc->dma_mask, convert_to_kb(s.totalram));
-
-	return 0;
-}
-
-static int
-_base_change_consistent_dma_mask(struct MPT2SAS_ADAPTER *ioc,
-				  struct pci_dev *pdev)
-{
-	if (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64))) {
-		if (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32)))
-			return -ENODEV;
-	}
-	return 0;
-}
-/**
- * _base_check_enable_msix - checks MSIX capabable.
- * @ioc: per adapter object
- *
- * Check to see if card is capable of MSIX, and set number
- * of available msix vectors
- */
-static int
-_base_check_enable_msix(struct MPT2SAS_ADAPTER *ioc)
-{
-	int base;
-	u16 message_control;
-
-
-	/* Check whether controller SAS2008 B0 controller,
-	   if it is SAS2008 B0 controller use IO-APIC instead of MSIX */
-	if (ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2008 &&
-	    ioc->pdev->revision == 0x01) {
-		return -EINVAL;
-	}
-
-	base = pci_find_capability(ioc->pdev, PCI_CAP_ID_MSIX);
-	if (!base) {
-		dfailprintk(ioc, printk(MPT2SAS_INFO_FMT "msix not "
-		    "supported\n", ioc->name));
-		return -EINVAL;
-	}
-
-	/* get msix vector count */
-	/* NUMA_IO not supported for older controllers */
-	if (ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2004 ||
-	    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2008 ||
-	    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2108_1 ||
-	    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2108_2 ||
-	    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2108_3 ||
-	    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2116_1 ||
-	    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2116_2)
-		ioc->msix_vector_count = 1;
-	else {
-		pci_read_config_word(ioc->pdev, base + 2, &message_control);
-		ioc->msix_vector_count = (message_control & 0x3FF) + 1;
-	}
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "msix is supported, "
-	    "vector_count(%d)\n", ioc->name, ioc->msix_vector_count));
-
-	return 0;
-}
-
-/**
- * _base_free_irq - free irq
- * @ioc: per adapter object
- *
- * Freeing respective reply_queue from the list.
- */
-static void
-_base_free_irq(struct MPT2SAS_ADAPTER *ioc)
-{
-	struct adapter_reply_queue *reply_q, *next;
-
-	if (list_empty(&ioc->reply_queue_list))
-		return;
-
-	list_for_each_entry_safe(reply_q, next, &ioc->reply_queue_list, list) {
-		list_del(&reply_q->list);
-		irq_set_affinity_hint(reply_q->vector, NULL);
-		free_cpumask_var(reply_q->affinity_hint);
-		synchronize_irq(reply_q->vector);
-		free_irq(reply_q->vector, reply_q);
-		kfree(reply_q);
-	}
-}
-
-/**
- * _base_request_irq - request irq
- * @ioc: per adapter object
- * @index: msix index into vector table
- * @vector: irq vector
- *
- * Inserting respective reply_queue into the list.
- */
-static int
-_base_request_irq(struct MPT2SAS_ADAPTER *ioc, u8 index, u32 vector)
-{
-	struct adapter_reply_queue *reply_q;
-	int r;
-
-	reply_q =  kzalloc(sizeof(struct adapter_reply_queue), GFP_KERNEL);
-	if (!reply_q) {
-		printk(MPT2SAS_ERR_FMT "unable to allocate memory %d!\n",
-		    ioc->name, (int)sizeof(struct adapter_reply_queue));
-		return -ENOMEM;
-	}
-	reply_q->ioc = ioc;
-	reply_q->msix_index = index;
-	reply_q->vector = vector;
-
-	if (!alloc_cpumask_var(&reply_q->affinity_hint, GFP_KERNEL))
-		return -ENOMEM;
-	cpumask_clear(reply_q->affinity_hint);
-
-	atomic_set(&reply_q->busy, 0);
-	if (ioc->msix_enable)
-		snprintf(reply_q->name, MPT_NAME_LENGTH, "%s%d-msix%d",
-		    MPT2SAS_DRIVER_NAME, ioc->id, index);
-	else
-		snprintf(reply_q->name, MPT_NAME_LENGTH, "%s%d",
-		    MPT2SAS_DRIVER_NAME, ioc->id);
-	r = request_irq(vector, _base_interrupt, IRQF_SHARED, reply_q->name,
-	    reply_q);
-	if (r) {
-		printk(MPT2SAS_ERR_FMT "unable to allocate interrupt %d!\n",
-		    reply_q->name, vector);
-		kfree(reply_q);
-		return -EBUSY;
-	}
-
-	INIT_LIST_HEAD(&reply_q->list);
-	list_add_tail(&reply_q->list, &ioc->reply_queue_list);
-	return 0;
-}
-
-/**
- * _base_assign_reply_queues - assigning msix index for each cpu
- * @ioc: per adapter object
- *
- * The enduser would need to set the affinity via /proc/irq/#/smp_affinity
- *
- * It would nice if we could call irq_set_affinity, however it is not
- * an exported symbol
- */
-static void
-_base_assign_reply_queues(struct MPT2SAS_ADAPTER *ioc)
-{
-	unsigned int cpu, nr_cpus, nr_msix, index = 0;
-	struct adapter_reply_queue *reply_q;
-
-	if (!_base_is_controller_msix_enabled(ioc))
-		return;
-
-	memset(ioc->cpu_msix_table, 0, ioc->cpu_msix_table_sz);
-
-	nr_cpus = num_online_cpus();
-	nr_msix = ioc->reply_queue_count = min(ioc->reply_queue_count,
-					       ioc->facts.MaxMSIxVectors);
-	if (!nr_msix)
-		return;
-
-	cpu = cpumask_first(cpu_online_mask);
-
-	list_for_each_entry(reply_q, &ioc->reply_queue_list, list) {
-
-		unsigned int i, group = nr_cpus / nr_msix;
-
-		if (cpu >= nr_cpus)
-			break;
-
-		if (index < nr_cpus % nr_msix)
-			group++;
-
-		for (i = 0 ; i < group ; i++) {
-			ioc->cpu_msix_table[cpu] = index;
-			cpumask_or(reply_q->affinity_hint,
-				   reply_q->affinity_hint, get_cpu_mask(cpu));
-			cpu = cpumask_next(cpu, cpu_online_mask);
-		}
-
-		if (irq_set_affinity_hint(reply_q->vector,
-					   reply_q->affinity_hint))
-			dinitprintk(ioc, pr_info(MPT2SAS_FMT
-			    "error setting affinity hint for irq vector %d\n",
-			    ioc->name, reply_q->vector));
-		index++;
-	}
-}
-
-/**
- * _base_disable_msix - disables msix
- * @ioc: per adapter object
- *
- */
-static void
-_base_disable_msix(struct MPT2SAS_ADAPTER *ioc)
-{
-	if (ioc->msix_enable) {
-		pci_disable_msix(ioc->pdev);
-		ioc->msix_enable = 0;
-	}
-}
-
-/**
- * _base_enable_msix - enables msix, failback to io_apic
- * @ioc: per adapter object
- *
- */
-static int
-_base_enable_msix(struct MPT2SAS_ADAPTER *ioc)
-{
-	struct msix_entry *entries, *a;
-	int r;
-	int i;
-	u8 try_msix = 0;
-
-	if (msix_disable == -1 || msix_disable == 0)
-		try_msix = 1;
-
-	if (!try_msix)
-		goto try_ioapic;
-
-	if (_base_check_enable_msix(ioc) != 0)
-		goto try_ioapic;
-
-	ioc->reply_queue_count = min_t(int, ioc->cpu_count,
-	    ioc->msix_vector_count);
-
-	if (!ioc->rdpq_array_enable && max_msix_vectors == -1)
-		max_msix_vectors = 8;
-
-	if (max_msix_vectors > 0) {
-		ioc->reply_queue_count = min_t(int, max_msix_vectors,
-		    ioc->reply_queue_count);
-		ioc->msix_vector_count = ioc->reply_queue_count;
-	} else if (max_msix_vectors == 0)
-		goto try_ioapic;
-
-	printk(MPT2SAS_INFO_FMT
-	"MSI-X vectors supported: %d, no of cores: %d, max_msix_vectors: %d\n",
-	 ioc->name, ioc->msix_vector_count, ioc->cpu_count, max_msix_vectors);
-
-	entries = kcalloc(ioc->reply_queue_count, sizeof(struct msix_entry),
-	    GFP_KERNEL);
-	if (!entries) {
-		dfailprintk(ioc, printk(MPT2SAS_INFO_FMT "kcalloc "
-		    "failed @ at %s:%d/%s() !!!\n", ioc->name, __FILE__,
-		    __LINE__, __func__));
-		goto try_ioapic;
-	}
-
-	for (i = 0, a = entries; i < ioc->reply_queue_count; i++, a++)
-		a->entry = i;
-
-	r = pci_enable_msix_exact(ioc->pdev, entries, ioc->reply_queue_count);
-	if (r) {
-		dfailprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "pci_enable_msix_exact failed (r=%d) !!!\n", ioc->name, r));
-		kfree(entries);
-		goto try_ioapic;
-	}
-
-	ioc->msix_enable = 1;
-	for (i = 0, a = entries; i < ioc->reply_queue_count; i++, a++) {
-		r = _base_request_irq(ioc, i, a->vector);
-		if (r) {
-			_base_free_irq(ioc);
-			_base_disable_msix(ioc);
-			kfree(entries);
-			goto try_ioapic;
-		}
-	}
-
-	kfree(entries);
-	return 0;
-
-/* failback to io_apic interrupt routing */
- try_ioapic:
-
-	ioc->reply_queue_count = 1;
-	r = _base_request_irq(ioc, 0, ioc->pdev->irq);
-
-	return r;
-}
-
-/**
- * mpt2sas_base_map_resources - map in controller resources (io/irq/memap)
- * @ioc: per adapter object
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_base_map_resources(struct MPT2SAS_ADAPTER *ioc)
-{
-	struct pci_dev *pdev = ioc->pdev;
-	u32 memap_sz;
-	u32 pio_sz;
-	int i, r = 0;
-	u64 pio_chip = 0;
-	u64 chip_phys = 0;
-	struct adapter_reply_queue *reply_q;
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n",
-	    ioc->name, __func__));
-
-	ioc->bars = pci_select_bars(pdev, IORESOURCE_MEM);
-	if (pci_enable_device_mem(pdev)) {
-		printk(MPT2SAS_WARN_FMT "pci_enable_device_mem: "
-		    "failed\n", ioc->name);
-		ioc->bars = 0;
-		return -ENODEV;
-	}
-
-
-	if (pci_request_selected_regions(pdev, ioc->bars,
-	    MPT2SAS_DRIVER_NAME)) {
-		printk(MPT2SAS_WARN_FMT "pci_request_selected_regions: "
-		    "failed\n", ioc->name);
-		ioc->bars = 0;
-		r = -ENODEV;
-		goto out_fail;
-	}
-
-	/* AER (Advanced Error Reporting) hooks */
-	pci_enable_pcie_error_reporting(pdev);
-
-	pci_set_master(pdev);
-
-	if (_base_config_dma_addressing(ioc, pdev) != 0) {
-		printk(MPT2SAS_WARN_FMT "no suitable DMA mask for %s\n",
-		    ioc->name, pci_name(pdev));
-		r = -ENODEV;
-		goto out_fail;
-	}
-
-	for (i = 0, memap_sz = 0, pio_sz = 0; (i < DEVICE_COUNT_RESOURCE) &&
-	     (!memap_sz || !pio_sz); i++) {
-		if (pci_resource_flags(pdev, i) & IORESOURCE_IO) {
-			if (pio_sz)
-				continue;
-			pio_chip = (u64)pci_resource_start(pdev, i);
-			pio_sz = pci_resource_len(pdev, i);
-		} else {
-			if (memap_sz)
-				continue;
-			/* verify memory resource is valid before using */
-			if (pci_resource_flags(pdev, i) & IORESOURCE_MEM) {
-				ioc->chip_phys = pci_resource_start(pdev, i);
-				chip_phys = (u64)ioc->chip_phys;
-				memap_sz = pci_resource_len(pdev, i);
-				ioc->chip = ioremap(ioc->chip_phys, memap_sz);
-			}
-		}
-	}
-
-	if (ioc->chip == NULL) {
-		printk(MPT2SAS_ERR_FMT "unable to map adapter memory! "
-		       "or resource not found\n", ioc->name);
-		r = -EINVAL;
-		goto out_fail;
-	}
-
-	_base_mask_interrupts(ioc);
-
-	r = _base_get_ioc_facts(ioc, CAN_SLEEP);
-	if (r)
-		goto out_fail;
-
-	if (!ioc->rdpq_array_enable_assigned) {
-		ioc->rdpq_array_enable = ioc->rdpq_array_capable;
-		ioc->rdpq_array_enable_assigned = 1;
-	}
-
-	r = _base_enable_msix(ioc);
-	if (r)
-		goto out_fail;
-
-	list_for_each_entry(reply_q, &ioc->reply_queue_list, list)
-		printk(MPT2SAS_INFO_FMT "%s: IRQ %d\n",
-		    reply_q->name,  ((ioc->msix_enable) ? "PCI-MSI-X enabled" :
-		    "IO-APIC enabled"), reply_q->vector);
-
-	printk(MPT2SAS_INFO_FMT "iomem(0x%016llx), mapped(0x%p), size(%d)\n",
-	    ioc->name, (unsigned long long)chip_phys, ioc->chip, memap_sz);
-	printk(MPT2SAS_INFO_FMT "ioport(0x%016llx), size(%d)\n",
-	    ioc->name, (unsigned long long)pio_chip, pio_sz);
-
-	/* Save PCI configuration state for recovery from PCI AER/EEH errors */
-	pci_save_state(pdev);
-
-	return 0;
-
- out_fail:
-	if (ioc->chip_phys)
-		iounmap(ioc->chip);
-	ioc->chip_phys = 0;
-	pci_release_selected_regions(ioc->pdev, ioc->bars);
-	pci_disable_pcie_error_reporting(pdev);
-	pci_disable_device(pdev);
-	return r;
-}
-
-/**
- * mpt2sas_base_get_msg_frame - obtain request mf pointer
- * @ioc: per adapter object
- * @smid: system request message index(smid zero is invalid)
- *
- * Returns virt pointer to message frame.
- */
-void *
-mpt2sas_base_get_msg_frame(struct MPT2SAS_ADAPTER *ioc, u16 smid)
-{
-	return (void *)(ioc->request + (smid * ioc->request_sz));
-}
-
-/**
- * mpt2sas_base_get_sense_buffer - obtain a sense buffer assigned to a mf request
- * @ioc: per adapter object
- * @smid: system request message index
- *
- * Returns virt pointer to sense buffer.
- */
-void *
-mpt2sas_base_get_sense_buffer(struct MPT2SAS_ADAPTER *ioc, u16 smid)
-{
-	return (void *)(ioc->sense + ((smid - 1) * SCSI_SENSE_BUFFERSIZE));
-}
-
-/**
- * mpt2sas_base_get_sense_buffer_dma - obtain a sense buffer assigned to a mf request
- * @ioc: per adapter object
- * @smid: system request message index
- *
- * Returns phys pointer to the low 32bit address of the sense buffer.
- */
-__le32
-mpt2sas_base_get_sense_buffer_dma(struct MPT2SAS_ADAPTER *ioc, u16 smid)
-{
-	return cpu_to_le32(ioc->sense_dma +
-			((smid - 1) * SCSI_SENSE_BUFFERSIZE));
-}
-
-/**
- * mpt2sas_base_get_reply_virt_addr - obtain reply frames virt address
- * @ioc: per adapter object
- * @phys_addr: lower 32 physical addr of the reply
- *
- * Converts 32bit lower physical addr into a virt address.
- */
-void *
-mpt2sas_base_get_reply_virt_addr(struct MPT2SAS_ADAPTER *ioc, u32 phys_addr)
-{
-	if (!phys_addr)
-		return NULL;
-	return ioc->reply + (phys_addr - (u32)ioc->reply_dma);
-}
-
-/**
- * mpt2sas_base_get_smid - obtain a free smid from internal queue
- * @ioc: per adapter object
- * @cb_idx: callback index
- *
- * Returns smid (zero is invalid)
- */
-u16
-mpt2sas_base_get_smid(struct MPT2SAS_ADAPTER *ioc, u8 cb_idx)
-{
-	unsigned long flags;
-	struct request_tracker *request;
-	u16 smid;
-
-	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-	if (list_empty(&ioc->internal_free_list)) {
-		spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-		printk(MPT2SAS_ERR_FMT "%s: smid not available\n",
-		    ioc->name, __func__);
-		return 0;
-	}
-
-	request = list_entry(ioc->internal_free_list.next,
-	    struct request_tracker, tracker_list);
-	request->cb_idx = cb_idx;
-	smid = request->smid;
-	list_del(&request->tracker_list);
-	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-	return smid;
-}
-
-/**
- * mpt2sas_base_get_smid_scsiio - obtain a free smid from scsiio queue
- * @ioc: per adapter object
- * @cb_idx: callback index
- * @scmd: pointer to scsi command object
- *
- * Returns smid (zero is invalid)
- */
-u16
-mpt2sas_base_get_smid_scsiio(struct MPT2SAS_ADAPTER *ioc, u8 cb_idx,
-    struct scsi_cmnd *scmd)
-{
-	unsigned long flags;
-	struct scsiio_tracker *request;
-	u16 smid;
-
-	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-	if (list_empty(&ioc->free_list)) {
-		spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-		printk(MPT2SAS_ERR_FMT "%s: smid not available\n",
-		    ioc->name, __func__);
-		return 0;
-	}
-
-	request = list_entry(ioc->free_list.next,
-	    struct scsiio_tracker, tracker_list);
-	request->scmd = scmd;
-	request->cb_idx = cb_idx;
-	smid = request->smid;
-	list_del(&request->tracker_list);
-	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-	return smid;
-}
-
-/**
- * mpt2sas_base_get_smid_hpr - obtain a free smid from hi-priority queue
- * @ioc: per adapter object
- * @cb_idx: callback index
- *
- * Returns smid (zero is invalid)
- */
-u16
-mpt2sas_base_get_smid_hpr(struct MPT2SAS_ADAPTER *ioc, u8 cb_idx)
-{
-	unsigned long flags;
-	struct request_tracker *request;
-	u16 smid;
-
-	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-	if (list_empty(&ioc->hpr_free_list)) {
-		spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-		return 0;
-	}
-
-	request = list_entry(ioc->hpr_free_list.next,
-	    struct request_tracker, tracker_list);
-	request->cb_idx = cb_idx;
-	smid = request->smid;
-	list_del(&request->tracker_list);
-	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-	return smid;
-}
-
-
-/**
- * mpt2sas_base_free_smid - put smid back on free_list
- * @ioc: per adapter object
- * @smid: system request message index
- *
- * Return nothing.
- */
-void
-mpt2sas_base_free_smid(struct MPT2SAS_ADAPTER *ioc, u16 smid)
-{
-	unsigned long flags;
-	int i;
-	struct chain_tracker *chain_req, *next;
-
-	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-	if (smid < ioc->hi_priority_smid) {
-		/* scsiio queue */
-		i = smid - 1;
-		if (!list_empty(&ioc->scsi_lookup[i].chain_list)) {
-			list_for_each_entry_safe(chain_req, next,
-			    &ioc->scsi_lookup[i].chain_list, tracker_list) {
-				list_del_init(&chain_req->tracker_list);
-				list_add(&chain_req->tracker_list,
-				    &ioc->free_chain_list);
-			}
-		}
-		ioc->scsi_lookup[i].cb_idx = 0xFF;
-		ioc->scsi_lookup[i].scmd = NULL;
-		ioc->scsi_lookup[i].direct_io = 0;
-		list_add(&ioc->scsi_lookup[i].tracker_list,
-		    &ioc->free_list);
-		spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-
-		/*
-		 * See _wait_for_commands_to_complete() call with regards
-		 * to this code.
-		 */
-		if (ioc->shost_recovery && ioc->pending_io_count) {
-			if (ioc->pending_io_count == 1)
-				wake_up(&ioc->reset_wq);
-			ioc->pending_io_count--;
-		}
-		return;
-	} else if (smid < ioc->internal_smid) {
-		/* hi-priority */
-		i = smid - ioc->hi_priority_smid;
-		ioc->hpr_lookup[i].cb_idx = 0xFF;
-		list_add(&ioc->hpr_lookup[i].tracker_list,
-		    &ioc->hpr_free_list);
-	} else if (smid <= ioc->hba_queue_depth) {
-		/* internal queue */
-		i = smid - ioc->internal_smid;
-		ioc->internal_lookup[i].cb_idx = 0xFF;
-		list_add(&ioc->internal_lookup[i].tracker_list,
-		    &ioc->internal_free_list);
-	}
-	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-}
-
-/**
- * _base_writeq - 64 bit write to MMIO
- * @ioc: per adapter object
- * @b: data payload
- * @addr: address in MMIO space
- * @writeq_lock: spin lock
- *
- * Glue for handling an atomic 64 bit word to MMIO. This special handling takes
- * care of 32 bit environment where its not quarenteed to send the entire word
- * in one transfer.
- */
-#ifndef writeq
-static inline void _base_writeq(__u64 b, volatile void __iomem *addr,
-    spinlock_t *writeq_lock)
-{
-	unsigned long flags;
-	__u64 data_out = cpu_to_le64(b);
-
-	spin_lock_irqsave(writeq_lock, flags);
-	writel((u32)(data_out), addr);
-	writel((u32)(data_out >> 32), (addr + 4));
-	spin_unlock_irqrestore(writeq_lock, flags);
-}
-#else
-static inline void _base_writeq(__u64 b, volatile void __iomem *addr,
-    spinlock_t *writeq_lock)
-{
-	writeq(cpu_to_le64(b), addr);
-}
-#endif
-
-static inline u8
-_base_get_msix_index(struct MPT2SAS_ADAPTER *ioc)
-{
-	return ioc->cpu_msix_table[raw_smp_processor_id()];
-}
-
-/**
- * mpt2sas_base_put_smid_scsi_io - send SCSI_IO request to firmware
- * @ioc: per adapter object
- * @smid: system request message index
- * @handle: device handle
- *
- * Return nothing.
- */
-void
-mpt2sas_base_put_smid_scsi_io(struct MPT2SAS_ADAPTER *ioc, u16 smid, u16 handle)
-{
-	Mpi2RequestDescriptorUnion_t descriptor;
-	u64 *request = (u64 *)&descriptor;
-
-
-	descriptor.SCSIIO.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO;
-	descriptor.SCSIIO.MSIxIndex =  _base_get_msix_index(ioc);
-	descriptor.SCSIIO.SMID = cpu_to_le16(smid);
-	descriptor.SCSIIO.DevHandle = cpu_to_le16(handle);
-	descriptor.SCSIIO.LMID = 0;
-	_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
-	    &ioc->scsi_lookup_lock);
-}
-
-
-/**
- * mpt2sas_base_put_smid_hi_priority - send Task Management request to firmware
- * @ioc: per adapter object
- * @smid: system request message index
- *
- * Return nothing.
- */
-void
-mpt2sas_base_put_smid_hi_priority(struct MPT2SAS_ADAPTER *ioc, u16 smid)
-{
-	Mpi2RequestDescriptorUnion_t descriptor;
-	u64 *request = (u64 *)&descriptor;
-
-	descriptor.HighPriority.RequestFlags =
-	    MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY;
-	descriptor.HighPriority.MSIxIndex =  0;
-	descriptor.HighPriority.SMID = cpu_to_le16(smid);
-	descriptor.HighPriority.LMID = 0;
-	descriptor.HighPriority.Reserved1 = 0;
-	_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
-	    &ioc->scsi_lookup_lock);
-}
-
-/**
- * mpt2sas_base_put_smid_default - Default, primarily used for config pages
- * @ioc: per adapter object
- * @smid: system request message index
- *
- * Return nothing.
- */
-void
-mpt2sas_base_put_smid_default(struct MPT2SAS_ADAPTER *ioc, u16 smid)
-{
-	Mpi2RequestDescriptorUnion_t descriptor;
-	u64 *request = (u64 *)&descriptor;
-
-	descriptor.Default.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE;
-	descriptor.Default.MSIxIndex =  _base_get_msix_index(ioc);
-	descriptor.Default.SMID = cpu_to_le16(smid);
-	descriptor.Default.LMID = 0;
-	descriptor.Default.DescriptorTypeDependent = 0;
-	_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
-	    &ioc->scsi_lookup_lock);
-}
-
-/**
- * mpt2sas_base_put_smid_target_assist - send Target Assist/Status to firmware
- * @ioc: per adapter object
- * @smid: system request message index
- * @io_index: value used to track the IO
- *
- * Return nothing.
- */
-void
-mpt2sas_base_put_smid_target_assist(struct MPT2SAS_ADAPTER *ioc, u16 smid,
-    u16 io_index)
-{
-	Mpi2RequestDescriptorUnion_t descriptor;
-	u64 *request = (u64 *)&descriptor;
-
-	descriptor.SCSITarget.RequestFlags =
-	    MPI2_REQ_DESCRIPT_FLAGS_SCSI_TARGET;
-	descriptor.SCSITarget.MSIxIndex =  _base_get_msix_index(ioc);
-	descriptor.SCSITarget.SMID = cpu_to_le16(smid);
-	descriptor.SCSITarget.LMID = 0;
-	descriptor.SCSITarget.IoIndex = cpu_to_le16(io_index);
-	_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
-	    &ioc->scsi_lookup_lock);
-}
-
-/**
- * _base_display_dell_branding - Disply branding string
- * @ioc: per adapter object
- *
- * Return nothing.
- */
-static void
-_base_display_dell_branding(struct MPT2SAS_ADAPTER *ioc)
-{
-	char dell_branding[MPT2SAS_DELL_BRANDING_SIZE];
-
-	if (ioc->pdev->subsystem_vendor != PCI_VENDOR_ID_DELL)
-		return;
-
-	memset(dell_branding, 0, MPT2SAS_DELL_BRANDING_SIZE);
-	switch (ioc->pdev->subsystem_device) {
-	case MPT2SAS_DELL_6GBPS_SAS_HBA_SSDID:
-		strncpy(dell_branding, MPT2SAS_DELL_6GBPS_SAS_HBA_BRANDING,
-		    MPT2SAS_DELL_BRANDING_SIZE - 1);
-		break;
-	case MPT2SAS_DELL_PERC_H200_ADAPTER_SSDID:
-		strncpy(dell_branding, MPT2SAS_DELL_PERC_H200_ADAPTER_BRANDING,
-		    MPT2SAS_DELL_BRANDING_SIZE - 1);
-		break;
-	case MPT2SAS_DELL_PERC_H200_INTEGRATED_SSDID:
-		strncpy(dell_branding,
-		    MPT2SAS_DELL_PERC_H200_INTEGRATED_BRANDING,
-		    MPT2SAS_DELL_BRANDING_SIZE - 1);
-		break;
-	case MPT2SAS_DELL_PERC_H200_MODULAR_SSDID:
-		strncpy(dell_branding,
-		    MPT2SAS_DELL_PERC_H200_MODULAR_BRANDING,
-		    MPT2SAS_DELL_BRANDING_SIZE - 1);
-		break;
-	case MPT2SAS_DELL_PERC_H200_EMBEDDED_SSDID:
-		strncpy(dell_branding,
-		    MPT2SAS_DELL_PERC_H200_EMBEDDED_BRANDING,
-		    MPT2SAS_DELL_BRANDING_SIZE - 1);
-		break;
-	case MPT2SAS_DELL_PERC_H200_SSDID:
-		strncpy(dell_branding, MPT2SAS_DELL_PERC_H200_BRANDING,
-		    MPT2SAS_DELL_BRANDING_SIZE - 1);
-		break;
-	case MPT2SAS_DELL_6GBPS_SAS_SSDID:
-		strncpy(dell_branding, MPT2SAS_DELL_6GBPS_SAS_BRANDING,
-		    MPT2SAS_DELL_BRANDING_SIZE - 1);
-		break;
-	default:
-		sprintf(dell_branding, "0x%4X", ioc->pdev->subsystem_device);
-		break;
-	}
-
-	printk(MPT2SAS_INFO_FMT "%s: Vendor(0x%04X), Device(0x%04X),"
-	    " SSVID(0x%04X), SSDID(0x%04X)\n", ioc->name, dell_branding,
-	    ioc->pdev->vendor, ioc->pdev->device, ioc->pdev->subsystem_vendor,
-	    ioc->pdev->subsystem_device);
-}
-
-/**
- * _base_display_intel_branding - Display branding string
- * @ioc: per adapter object
- *
- * Return nothing.
- */
-static void
-_base_display_intel_branding(struct MPT2SAS_ADAPTER *ioc)
-{
-	if (ioc->pdev->subsystem_vendor != PCI_VENDOR_ID_INTEL)
-		return;
-
-	switch (ioc->pdev->device) {
-	case MPI2_MFGPAGE_DEVID_SAS2008:
-		switch (ioc->pdev->subsystem_device) {
-		case MPT2SAS_INTEL_RMS2LL080_SSDID:
-			printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-			    MPT2SAS_INTEL_RMS2LL080_BRANDING);
-			break;
-		case MPT2SAS_INTEL_RMS2LL040_SSDID:
-			printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-			    MPT2SAS_INTEL_RMS2LL040_BRANDING);
-			break;
-		case MPT2SAS_INTEL_SSD910_SSDID:
-			printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-			    MPT2SAS_INTEL_SSD910_BRANDING);
-			break;
-		default:
-			break;
-		}
-	case MPI2_MFGPAGE_DEVID_SAS2308_2:
-		switch (ioc->pdev->subsystem_device) {
-		case MPT2SAS_INTEL_RS25GB008_SSDID:
-			printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-			    MPT2SAS_INTEL_RS25GB008_BRANDING);
-			break;
-		case MPT2SAS_INTEL_RMS25JB080_SSDID:
-			printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-			    MPT2SAS_INTEL_RMS25JB080_BRANDING);
-			break;
-		case MPT2SAS_INTEL_RMS25JB040_SSDID:
-			printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-			    MPT2SAS_INTEL_RMS25JB040_BRANDING);
-			break;
-		case MPT2SAS_INTEL_RMS25KB080_SSDID:
-			printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-			    MPT2SAS_INTEL_RMS25KB080_BRANDING);
-			break;
-		case MPT2SAS_INTEL_RMS25KB040_SSDID:
-			printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-			    MPT2SAS_INTEL_RMS25KB040_BRANDING);
-			break;
-		case MPT2SAS_INTEL_RMS25LB040_SSDID:
-			printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-			    MPT2SAS_INTEL_RMS25LB040_BRANDING);
-			break;
-		case MPT2SAS_INTEL_RMS25LB080_SSDID:
-			printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-			    MPT2SAS_INTEL_RMS25LB080_BRANDING);
-			break;
-		default:
-			break;
-		}
-	default:
-		break;
-	}
-}
-
-/**
- * _base_display_hp_branding - Display branding string
- * @ioc: per adapter object
- *
- * Return nothing.
- */
-static void
-_base_display_hp_branding(struct MPT2SAS_ADAPTER *ioc)
-{
-	if (ioc->pdev->subsystem_vendor != MPT2SAS_HP_3PAR_SSVID)
-		return;
-
-	switch (ioc->pdev->device) {
-	case MPI2_MFGPAGE_DEVID_SAS2004:
-		switch (ioc->pdev->subsystem_device) {
-		case MPT2SAS_HP_DAUGHTER_2_4_INTERNAL_SSDID:
-			printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-			    MPT2SAS_HP_DAUGHTER_2_4_INTERNAL_BRANDING);
-			break;
-		default:
-			break;
-		}
-	case MPI2_MFGPAGE_DEVID_SAS2308_2:
-		switch (ioc->pdev->subsystem_device) {
-		case MPT2SAS_HP_2_4_INTERNAL_SSDID:
-			printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-			    MPT2SAS_HP_2_4_INTERNAL_BRANDING);
-			break;
-		case MPT2SAS_HP_2_4_EXTERNAL_SSDID:
-			printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-			    MPT2SAS_HP_2_4_EXTERNAL_BRANDING);
-			break;
-		case MPT2SAS_HP_1_4_INTERNAL_1_4_EXTERNAL_SSDID:
-			printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-			    MPT2SAS_HP_1_4_INTERNAL_1_4_EXTERNAL_BRANDING);
-			break;
-		case MPT2SAS_HP_EMBEDDED_2_4_INTERNAL_SSDID:
-			printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-			    MPT2SAS_HP_EMBEDDED_2_4_INTERNAL_BRANDING);
-			break;
-		default:
-			break;
-		}
-	default:
-		break;
-	}
-}
-
-/**
- * _base_display_ioc_capabilities - Disply IOC's capabilities.
- * @ioc: per adapter object
- *
- * Return nothing.
- */
-static void
-_base_display_ioc_capabilities(struct MPT2SAS_ADAPTER *ioc)
-{
-	int i = 0;
-	char desc[16];
-	u32 iounit_pg1_flags;
-	u32 bios_version;
-
-	bios_version = le32_to_cpu(ioc->bios_pg3.BiosVersion);
-	strncpy(desc, ioc->manu_pg0.ChipName, 16);
-	printk(MPT2SAS_INFO_FMT "%s: FWVersion(%02d.%02d.%02d.%02d), "
-	   "ChipRevision(0x%02x), BiosVersion(%02d.%02d.%02d.%02d)\n",
-	    ioc->name, desc,
-	   (ioc->facts.FWVersion.Word & 0xFF000000) >> 24,
-	   (ioc->facts.FWVersion.Word & 0x00FF0000) >> 16,
-	   (ioc->facts.FWVersion.Word & 0x0000FF00) >> 8,
-	   ioc->facts.FWVersion.Word & 0x000000FF,
-	   ioc->pdev->revision,
-	   (bios_version & 0xFF000000) >> 24,
-	   (bios_version & 0x00FF0000) >> 16,
-	   (bios_version & 0x0000FF00) >> 8,
-	    bios_version & 0x000000FF);
-
-	_base_display_dell_branding(ioc);
-	_base_display_intel_branding(ioc);
-	_base_display_hp_branding(ioc);
-
-	printk(MPT2SAS_INFO_FMT "Protocol=(", ioc->name);
-
-	if (ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_SCSI_INITIATOR) {
-		printk("Initiator");
-		i++;
-	}
-
-	if (ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_SCSI_TARGET) {
-		printk("%sTarget", i ? "," : "");
-		i++;
-	}
-
-	i = 0;
-	printk("), ");
-	printk("Capabilities=(");
-
-	if (!ioc->hide_ir_msg) {
-		if (ioc->facts.IOCCapabilities &
-		    MPI2_IOCFACTS_CAPABILITY_INTEGRATED_RAID) {
-			printk("Raid");
-			i++;
-		}
-	}
-
-	if (ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_TLR) {
-		printk("%sTLR", i ? "," : "");
-		i++;
-	}
-
-	if (ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_MULTICAST) {
-		printk("%sMulticast", i ? "," : "");
-		i++;
-	}
-
-	if (ioc->facts.IOCCapabilities &
-	    MPI2_IOCFACTS_CAPABILITY_BIDIRECTIONAL_TARGET) {
-		printk("%sBIDI Target", i ? "," : "");
-		i++;
-	}
-
-	if (ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_EEDP) {
-		printk("%sEEDP", i ? "," : "");
-		i++;
-	}
-
-	if (ioc->facts.IOCCapabilities &
-	    MPI2_IOCFACTS_CAPABILITY_SNAPSHOT_BUFFER) {
-		printk("%sSnapshot Buffer", i ? "," : "");
-		i++;
-	}
-
-	if (ioc->facts.IOCCapabilities &
-	    MPI2_IOCFACTS_CAPABILITY_DIAG_TRACE_BUFFER) {
-		printk("%sDiag Trace Buffer", i ? "," : "");
-		i++;
-	}
-
-	if (ioc->facts.IOCCapabilities &
-	    MPI2_IOCFACTS_CAPABILITY_EXTENDED_BUFFER) {
-		printk(KERN_INFO "%sDiag Extended Buffer", i ? "," : "");
-		i++;
-	}
-
-	if (ioc->facts.IOCCapabilities &
-	    MPI2_IOCFACTS_CAPABILITY_TASK_SET_FULL_HANDLING) {
-		printk("%sTask Set Full", i ? "," : "");
-		i++;
-	}
-
-	iounit_pg1_flags = le32_to_cpu(ioc->iounit_pg1.Flags);
-	if (!(iounit_pg1_flags & MPI2_IOUNITPAGE1_NATIVE_COMMAND_Q_DISABLE)) {
-		printk("%sNCQ", i ? "," : "");
-		i++;
-	}
-
-	printk(")\n");
-}
-
-/**
- * mpt2sas_base_update_missing_delay - change the missing delay timers
- * @ioc: per adapter object
- * @device_missing_delay: amount of time till device is reported missing
- * @io_missing_delay: interval IO is returned when there is a missing device
- *
- * Return nothing.
- *
- * Passed on the command line, this function will modify the device missing
- * delay, as well as the io missing delay. This should be called at driver
- * load time.
- */
-void
-mpt2sas_base_update_missing_delay(struct MPT2SAS_ADAPTER *ioc,
-	u16 device_missing_delay, u8 io_missing_delay)
-{
-	u16 dmd, dmd_new, dmd_orignal;
-	u8 io_missing_delay_original;
-	u16 sz;
-	Mpi2SasIOUnitPage1_t *sas_iounit_pg1 = NULL;
-	Mpi2ConfigReply_t mpi_reply;
-	u8 num_phys = 0;
-	u16 ioc_status;
-
-	mpt2sas_config_get_number_hba_phys(ioc, &num_phys);
-	if (!num_phys)
-		return;
-
-	sz = offsetof(Mpi2SasIOUnitPage1_t, PhyData) + (num_phys *
-	    sizeof(Mpi2SasIOUnit1PhyData_t));
-	sas_iounit_pg1 = kzalloc(sz, GFP_KERNEL);
-	if (!sas_iounit_pg1) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out;
-	}
-	if ((mpt2sas_config_get_sas_iounit_pg1(ioc, &mpi_reply,
-	    sas_iounit_pg1, sz))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out;
-	}
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-	    MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out;
-	}
-
-	/* device missing delay */
-	dmd = sas_iounit_pg1->ReportDeviceMissingDelay;
-	if (dmd & MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16)
-		dmd = (dmd & MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK) * 16;
-	else
-		dmd = dmd & MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK;
-	dmd_orignal = dmd;
-	if (device_missing_delay > 0x7F) {
-		dmd = (device_missing_delay > 0x7F0) ? 0x7F0 :
-		    device_missing_delay;
-		dmd = dmd / 16;
-		dmd |= MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16;
-	} else
-		dmd = device_missing_delay;
-	sas_iounit_pg1->ReportDeviceMissingDelay = dmd;
-
-	/* io missing delay */
-	io_missing_delay_original = sas_iounit_pg1->IODeviceMissingDelay;
-	sas_iounit_pg1->IODeviceMissingDelay = io_missing_delay;
-
-	if (!mpt2sas_config_set_sas_iounit_pg1(ioc, &mpi_reply, sas_iounit_pg1,
-	    sz)) {
-		if (dmd & MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16)
-			dmd_new = (dmd &
-			    MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK) * 16;
-		else
-			dmd_new =
-		    dmd & MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK;
-		printk(MPT2SAS_INFO_FMT "device_missing_delay: old(%d), "
-		    "new(%d)\n", ioc->name, dmd_orignal, dmd_new);
-		printk(MPT2SAS_INFO_FMT "ioc_missing_delay: old(%d), "
-		    "new(%d)\n", ioc->name, io_missing_delay_original,
-		    io_missing_delay);
-		ioc->device_missing_delay = dmd_new;
-		ioc->io_missing_delay = io_missing_delay;
-	}
-
-out:
-	kfree(sas_iounit_pg1);
-}
-
-/**
- * _base_static_config_pages - static start of day config pages
- * @ioc: per adapter object
- *
- * Return nothing.
- */
-static void
-_base_static_config_pages(struct MPT2SAS_ADAPTER *ioc)
-{
-	Mpi2ConfigReply_t mpi_reply;
-	u32 iounit_pg1_flags;
-
-	mpt2sas_config_get_manufacturing_pg0(ioc, &mpi_reply, &ioc->manu_pg0);
-	if (ioc->ir_firmware)
-		mpt2sas_config_get_manufacturing_pg10(ioc, &mpi_reply,
-		    &ioc->manu_pg10);
-	mpt2sas_config_get_bios_pg2(ioc, &mpi_reply, &ioc->bios_pg2);
-	mpt2sas_config_get_bios_pg3(ioc, &mpi_reply, &ioc->bios_pg3);
-	mpt2sas_config_get_ioc_pg8(ioc, &mpi_reply, &ioc->ioc_pg8);
-	mpt2sas_config_get_iounit_pg0(ioc, &mpi_reply, &ioc->iounit_pg0);
-	mpt2sas_config_get_iounit_pg1(ioc, &mpi_reply, &ioc->iounit_pg1);
-	mpt2sas_config_get_iounit_pg8(ioc, &mpi_reply, &ioc->iounit_pg8);
-	_base_display_ioc_capabilities(ioc);
-
-	/*
-	 * Enable task_set_full handling in iounit_pg1 when the
-	 * facts capabilities indicate that its supported.
-	 */
-	iounit_pg1_flags = le32_to_cpu(ioc->iounit_pg1.Flags);
-	if ((ioc->facts.IOCCapabilities &
-	    MPI2_IOCFACTS_CAPABILITY_TASK_SET_FULL_HANDLING))
-		iounit_pg1_flags &=
-		    ~MPI2_IOUNITPAGE1_DISABLE_TASK_SET_FULL_HANDLING;
-	else
-		iounit_pg1_flags |=
-		    MPI2_IOUNITPAGE1_DISABLE_TASK_SET_FULL_HANDLING;
-	ioc->iounit_pg1.Flags = cpu_to_le32(iounit_pg1_flags);
-	mpt2sas_config_set_iounit_pg1(ioc, &mpi_reply, &ioc->iounit_pg1);
-
-	if (ioc->iounit_pg8.NumSensors)
-		ioc->temp_sensors_count = ioc->iounit_pg8.NumSensors;
-}
-
-/**
- * _base_release_memory_pools - release memory
- * @ioc: per adapter object
- *
- * Free memory allocated from _base_allocate_memory_pools.
- *
- * Return nothing.
- */
-static void
-_base_release_memory_pools(struct MPT2SAS_ADAPTER *ioc)
-{
-	int i = 0;
-	struct reply_post_struct *rps;
-
-	dexitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	if (ioc->request) {
-		pci_free_consistent(ioc->pdev, ioc->request_dma_sz,
-		    ioc->request,  ioc->request_dma);
-		dexitprintk(ioc, printk(MPT2SAS_INFO_FMT "request_pool(0x%p)"
-		    ": free\n", ioc->name, ioc->request));
-		ioc->request = NULL;
-	}
-
-	if (ioc->sense) {
-		pci_pool_free(ioc->sense_dma_pool, ioc->sense, ioc->sense_dma);
-		if (ioc->sense_dma_pool)
-			pci_pool_destroy(ioc->sense_dma_pool);
-		dexitprintk(ioc, printk(MPT2SAS_INFO_FMT "sense_pool(0x%p)"
-		    ": free\n", ioc->name, ioc->sense));
-		ioc->sense = NULL;
-	}
-
-	if (ioc->reply) {
-		pci_pool_free(ioc->reply_dma_pool, ioc->reply, ioc->reply_dma);
-		if (ioc->reply_dma_pool)
-			pci_pool_destroy(ioc->reply_dma_pool);
-		dexitprintk(ioc, printk(MPT2SAS_INFO_FMT "reply_pool(0x%p)"
-		     ": free\n", ioc->name, ioc->reply));
-		ioc->reply = NULL;
-	}
-
-	if (ioc->reply_free) {
-		pci_pool_free(ioc->reply_free_dma_pool, ioc->reply_free,
-		    ioc->reply_free_dma);
-		if (ioc->reply_free_dma_pool)
-			pci_pool_destroy(ioc->reply_free_dma_pool);
-		dexitprintk(ioc, printk(MPT2SAS_INFO_FMT "reply_free_pool"
-		    "(0x%p): free\n", ioc->name, ioc->reply_free));
-		ioc->reply_free = NULL;
-	}
-
-	if (ioc->reply_post) {
-		do {
-			rps = &ioc->reply_post[i];
-			if (rps->reply_post_free) {
-				pci_pool_free(
-				    ioc->reply_post_free_dma_pool,
-				    rps->reply_post_free,
-				    rps->reply_post_free_dma);
-				dexitprintk(ioc, printk(MPT2SAS_INFO_FMT
-				    "reply_post_free_pool(0x%p): free\n",
-				    ioc->name, rps->reply_post_free));
-				rps->reply_post_free = NULL;
-			}
-		} while (ioc->rdpq_array_enable &&
-			   (++i < ioc->reply_queue_count));
-
-		if (ioc->reply_post_free_dma_pool)
-			pci_pool_destroy(ioc->reply_post_free_dma_pool);
-		kfree(ioc->reply_post);
-	}
-
-	if (ioc->config_page) {
-		dexitprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "config_page(0x%p): free\n", ioc->name,
-		    ioc->config_page));
-		pci_free_consistent(ioc->pdev, ioc->config_page_sz,
-		    ioc->config_page, ioc->config_page_dma);
-	}
-
-	if (ioc->scsi_lookup) {
-		free_pages((ulong)ioc->scsi_lookup, ioc->scsi_lookup_pages);
-		ioc->scsi_lookup = NULL;
-	}
-	kfree(ioc->hpr_lookup);
-	kfree(ioc->internal_lookup);
-	if (ioc->chain_lookup) {
-		for (i = 0; i < ioc->chain_depth; i++) {
-			if (ioc->chain_lookup[i].chain_buffer)
-				pci_pool_free(ioc->chain_dma_pool,
-				    ioc->chain_lookup[i].chain_buffer,
-				    ioc->chain_lookup[i].chain_buffer_dma);
-		}
-		if (ioc->chain_dma_pool)
-			pci_pool_destroy(ioc->chain_dma_pool);
-		free_pages((ulong)ioc->chain_lookup, ioc->chain_pages);
-		ioc->chain_lookup = NULL;
-	}
-}
-
-
-/**
- * _base_allocate_memory_pools - allocate start of day memory pools
- * @ioc: per adapter object
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * Returns 0 success, anything else error
- */
-static int
-_base_allocate_memory_pools(struct MPT2SAS_ADAPTER *ioc,  int sleep_flag)
-{
-	struct mpt2sas_facts *facts;
-	u16 max_sge_elements;
-	u16 chains_needed_per_io;
-	u32 sz, total_sz, reply_post_free_sz;
-	u32 retry_sz;
-	u16 max_request_credit;
-	int i;
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	retry_sz = 0;
-	facts = &ioc->facts;
-
-	/* command line tunables  for max sgl entries */
-	if (max_sgl_entries != -1) {
-		ioc->shost->sg_tablesize =  min_t(unsigned short,
-			     max_sgl_entries, SCSI_MAX_SG_CHAIN_SEGMENTS);
-		if (ioc->shost->sg_tablesize > MPT2SAS_SG_DEPTH)
-			printk(MPT2SAS_WARN_FMT
-			 "sg_tablesize(%u) is bigger than kernel defined"
-			 " SCSI_MAX_SG_SEGMENTS(%u)\n", ioc->name,
-			  ioc->shost->sg_tablesize, MPT2SAS_SG_DEPTH);
-	} else {
-		ioc->shost->sg_tablesize = MPT2SAS_SG_DEPTH;
-	}
-
-	/* command line tunables  for max controller queue depth */
-	if (max_queue_depth != -1 && max_queue_depth != 0) {
-		max_request_credit = min_t(u16, max_queue_depth +
-			ioc->hi_priority_depth + ioc->internal_depth,
-			facts->RequestCredit);
-		if (max_request_credit > MAX_HBA_QUEUE_DEPTH)
-			max_request_credit =  MAX_HBA_QUEUE_DEPTH;
-	} else
-		max_request_credit = min_t(u16, facts->RequestCredit,
-		    MAX_HBA_QUEUE_DEPTH);
-
-	ioc->hba_queue_depth = max_request_credit;
-	ioc->hi_priority_depth = facts->HighPriorityCredit;
-	ioc->internal_depth = ioc->hi_priority_depth + 5;
-
-	/* request frame size */
-	ioc->request_sz = facts->IOCRequestFrameSize * 4;
-
-	/* reply frame size */
-	ioc->reply_sz = facts->ReplyFrameSize * 4;
-
- retry_allocation:
-	total_sz = 0;
-	/* calculate number of sg elements left over in the 1st frame */
-	max_sge_elements = ioc->request_sz - ((sizeof(Mpi2SCSIIORequest_t) -
-	    sizeof(Mpi2SGEIOUnion_t)) + ioc->sge_size);
-	ioc->max_sges_in_main_message = max_sge_elements/ioc->sge_size;
-
-	/* now do the same for a chain buffer */
-	max_sge_elements = ioc->request_sz - ioc->sge_size;
-	ioc->max_sges_in_chain_message = max_sge_elements/ioc->sge_size;
-
-	ioc->chain_offset_value_for_main_message =
-	    ((sizeof(Mpi2SCSIIORequest_t) - sizeof(Mpi2SGEIOUnion_t)) +
-	     (ioc->max_sges_in_chain_message * ioc->sge_size)) / 4;
-
-	/*
-	 *  MPT2SAS_SG_DEPTH = CONFIG_FUSION_MAX_SGE
-	 */
-	chains_needed_per_io = ((ioc->shost->sg_tablesize -
-	   ioc->max_sges_in_main_message)/ioc->max_sges_in_chain_message)
-	    + 1;
-	if (chains_needed_per_io > facts->MaxChainDepth) {
-		chains_needed_per_io = facts->MaxChainDepth;
-		ioc->shost->sg_tablesize = min_t(u16,
-		ioc->max_sges_in_main_message + (ioc->max_sges_in_chain_message
-		* chains_needed_per_io), ioc->shost->sg_tablesize);
-	}
-	ioc->chains_needed_per_io = chains_needed_per_io;
-
-	/* reply free queue sizing - taking into account for 64 FW events */
-	ioc->reply_free_queue_depth = ioc->hba_queue_depth + 64;
-
-	/* calculate reply descriptor post queue depth */
-	ioc->reply_post_queue_depth = ioc->hba_queue_depth +
-					ioc->reply_free_queue_depth +  1;
-	/* align the reply post queue on the next 16 count boundary */
-	if (ioc->reply_post_queue_depth % 16)
-		ioc->reply_post_queue_depth += 16 -
-			(ioc->reply_post_queue_depth % 16);
-
-
-	if (ioc->reply_post_queue_depth >
-	    facts->MaxReplyDescriptorPostQueueDepth) {
-		ioc->reply_post_queue_depth =
-			facts->MaxReplyDescriptorPostQueueDepth -
-		    (facts->MaxReplyDescriptorPostQueueDepth % 16);
-		ioc->hba_queue_depth =
-			((ioc->reply_post_queue_depth - 64) / 2) - 1;
-		ioc->reply_free_queue_depth = ioc->hba_queue_depth + 64;
-	}
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "scatter gather: "
-	    "sge_in_main_msg(%d), sge_per_chain(%d), sge_per_io(%d), "
-	    "chains_per_io(%d)\n", ioc->name, ioc->max_sges_in_main_message,
-	    ioc->max_sges_in_chain_message, ioc->shost->sg_tablesize,
-	    ioc->chains_needed_per_io));
-
-	/* reply post queue, 16 byte align */
-	reply_post_free_sz = ioc->reply_post_queue_depth *
-	    sizeof(Mpi2DefaultReplyDescriptor_t);
-
-	sz = reply_post_free_sz;
-	if (_base_is_controller_msix_enabled(ioc) && !ioc->rdpq_array_enable)
-		sz *= ioc->reply_queue_count;
-
-	ioc->reply_post = kcalloc((ioc->rdpq_array_enable) ?
-	    (ioc->reply_queue_count):1,
-	    sizeof(struct reply_post_struct), GFP_KERNEL);
-
-	if (!ioc->reply_post) {
-		printk(MPT2SAS_ERR_FMT "reply_post_free pool: kcalloc failed\n",
-			ioc->name);
-		goto out;
-	}
-	ioc->reply_post_free_dma_pool = pci_pool_create("reply_post_free pool",
-	    ioc->pdev, sz, 16, 0);
-	if (!ioc->reply_post_free_dma_pool) {
-		printk(MPT2SAS_ERR_FMT
-		 "reply_post_free pool: pci_pool_create failed\n",
-		 ioc->name);
-		goto out;
-	}
-	i = 0;
-	do {
-		ioc->reply_post[i].reply_post_free =
-		    pci_pool_alloc(ioc->reply_post_free_dma_pool,
-		    GFP_KERNEL,
-		    &ioc->reply_post[i].reply_post_free_dma);
-		if (!ioc->reply_post[i].reply_post_free) {
-			printk(MPT2SAS_ERR_FMT
-			"reply_post_free pool: pci_pool_alloc failed\n",
-			ioc->name);
-			goto out;
-		}
-		memset(ioc->reply_post[i].reply_post_free, 0, sz);
-		dinitprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "reply post free pool (0x%p): depth(%d),"
-		    "element_size(%d), pool_size(%d kB)\n", ioc->name,
-		    ioc->reply_post[i].reply_post_free,
-		    ioc->reply_post_queue_depth, 8, sz/1024));
-		dinitprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "reply_post_free_dma = (0x%llx)\n", ioc->name,
-		    (unsigned long long)
-		    ioc->reply_post[i].reply_post_free_dma));
-		total_sz += sz;
-	} while (ioc->rdpq_array_enable && (++i < ioc->reply_queue_count));
-
-	if (ioc->dma_mask == 64) {
-		if (_base_change_consistent_dma_mask(ioc, ioc->pdev) != 0) {
-			printk(MPT2SAS_WARN_FMT
-			    "no suitable consistent DMA mask for %s\n",
-			    ioc->name, pci_name(ioc->pdev));
-			goto out;
-		}
-	}
-
-	ioc->scsiio_depth = ioc->hba_queue_depth -
-	    ioc->hi_priority_depth - ioc->internal_depth;
-
-	/* set the scsi host can_queue depth
-	 * with some internal commands that could be outstanding
-	 */
-	ioc->shost->can_queue = ioc->scsiio_depth;
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "scsi host: "
-	    "can_queue depth (%d)\n", ioc->name, ioc->shost->can_queue));
-
-	/* contiguous pool for request and chains, 16 byte align, one extra "
-	 * "frame for smid=0
-	 */
-	ioc->chain_depth = ioc->chains_needed_per_io * ioc->scsiio_depth;
-	sz = ((ioc->scsiio_depth + 1) * ioc->request_sz);
-
-	/* hi-priority queue */
-	sz += (ioc->hi_priority_depth * ioc->request_sz);
-
-	/* internal queue */
-	sz += (ioc->internal_depth * ioc->request_sz);
-
-	ioc->request_dma_sz = sz;
-	ioc->request = pci_alloc_consistent(ioc->pdev, sz, &ioc->request_dma);
-	if (!ioc->request) {
-		printk(MPT2SAS_ERR_FMT "request pool: pci_alloc_consistent "
-		    "failed: hba_depth(%d), chains_per_io(%d), frame_sz(%d), "
-		    "total(%d kB)\n", ioc->name, ioc->hba_queue_depth,
-		    ioc->chains_needed_per_io, ioc->request_sz, sz/1024);
-		if (ioc->scsiio_depth < MPT2SAS_SAS_QUEUE_DEPTH)
-			goto out;
-		retry_sz += 64;
-		ioc->hba_queue_depth = max_request_credit - retry_sz;
-		goto retry_allocation;
-	}
-
-	if (retry_sz)
-		printk(MPT2SAS_ERR_FMT "request pool: pci_alloc_consistent "
-		    "succeed: hba_depth(%d), chains_per_io(%d), frame_sz(%d), "
-		    "total(%d kb)\n", ioc->name, ioc->hba_queue_depth,
-		    ioc->chains_needed_per_io, ioc->request_sz, sz/1024);
-
-
-	/* hi-priority queue */
-	ioc->hi_priority = ioc->request + ((ioc->scsiio_depth + 1) *
-	    ioc->request_sz);
-	ioc->hi_priority_dma = ioc->request_dma + ((ioc->scsiio_depth + 1) *
-	    ioc->request_sz);
-
-	/* internal queue */
-	ioc->internal = ioc->hi_priority + (ioc->hi_priority_depth *
-	    ioc->request_sz);
-	ioc->internal_dma = ioc->hi_priority_dma + (ioc->hi_priority_depth *
-	    ioc->request_sz);
-
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "request pool(0x%p): "
-	    "depth(%d), frame_size(%d), pool_size(%d kB)\n", ioc->name,
-	    ioc->request, ioc->hba_queue_depth, ioc->request_sz,
-	    (ioc->hba_queue_depth * ioc->request_sz)/1024));
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "request pool: dma(0x%llx)\n",
-	    ioc->name, (unsigned long long) ioc->request_dma));
-	total_sz += sz;
-
-	sz = ioc->scsiio_depth * sizeof(struct scsiio_tracker);
-	ioc->scsi_lookup_pages = get_order(sz);
-	ioc->scsi_lookup = (struct scsiio_tracker *)__get_free_pages(
-	    GFP_KERNEL, ioc->scsi_lookup_pages);
-	if (!ioc->scsi_lookup) {
-		printk(MPT2SAS_ERR_FMT "scsi_lookup: get_free_pages failed, "
-		    "sz(%d)\n", ioc->name, (int)sz);
-		goto out;
-	}
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "scsiio(0x%p): "
-	    "depth(%d)\n", ioc->name, ioc->request,
-	    ioc->scsiio_depth));
-
-	ioc->chain_depth = min_t(u32, ioc->chain_depth, MAX_CHAIN_DEPTH);
-	sz = ioc->chain_depth * sizeof(struct chain_tracker);
-	ioc->chain_pages = get_order(sz);
-
-	ioc->chain_lookup = (struct chain_tracker *)__get_free_pages(
-	    GFP_KERNEL, ioc->chain_pages);
-	if (!ioc->chain_lookup) {
-		printk(MPT2SAS_ERR_FMT "chain_lookup: get_free_pages failed, "
-		    "sz(%d)\n", ioc->name, (int)sz);
-		goto out;
-	}
-	ioc->chain_dma_pool = pci_pool_create("chain pool", ioc->pdev,
-	    ioc->request_sz, 16, 0);
-	if (!ioc->chain_dma_pool) {
-		printk(MPT2SAS_ERR_FMT "chain_dma_pool: pci_pool_create "
-		    "failed\n", ioc->name);
-		goto out;
-	}
-	for (i = 0; i < ioc->chain_depth; i++) {
-		ioc->chain_lookup[i].chain_buffer = pci_pool_alloc(
-		    ioc->chain_dma_pool , GFP_KERNEL,
-		    &ioc->chain_lookup[i].chain_buffer_dma);
-		if (!ioc->chain_lookup[i].chain_buffer) {
-			ioc->chain_depth = i;
-			goto chain_done;
-		}
-		total_sz += ioc->request_sz;
-	}
-chain_done:
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "chain pool depth"
-	    "(%d), frame_size(%d), pool_size(%d kB)\n", ioc->name,
-	    ioc->chain_depth, ioc->request_sz, ((ioc->chain_depth *
-	    ioc->request_sz))/1024));
-
-	/* initialize hi-priority queue smid's */
-	ioc->hpr_lookup = kcalloc(ioc->hi_priority_depth,
-	    sizeof(struct request_tracker), GFP_KERNEL);
-	if (!ioc->hpr_lookup) {
-		printk(MPT2SAS_ERR_FMT "hpr_lookup: kcalloc failed\n",
-		    ioc->name);
-		goto out;
-	}
-	ioc->hi_priority_smid = ioc->scsiio_depth + 1;
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "hi_priority(0x%p): "
-	    "depth(%d), start smid(%d)\n", ioc->name, ioc->hi_priority,
-	    ioc->hi_priority_depth, ioc->hi_priority_smid));
-
-	/* initialize internal queue smid's */
-	ioc->internal_lookup = kcalloc(ioc->internal_depth,
-	    sizeof(struct request_tracker), GFP_KERNEL);
-	if (!ioc->internal_lookup) {
-		printk(MPT2SAS_ERR_FMT "internal_lookup: kcalloc failed\n",
-		    ioc->name);
-		goto out;
-	}
-	ioc->internal_smid = ioc->hi_priority_smid + ioc->hi_priority_depth;
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "internal(0x%p): "
-	    "depth(%d), start smid(%d)\n", ioc->name, ioc->internal,
-	     ioc->internal_depth, ioc->internal_smid));
-
-	/* sense buffers, 4 byte align */
-	sz = ioc->scsiio_depth * SCSI_SENSE_BUFFERSIZE;
-	ioc->sense_dma_pool = pci_pool_create("sense pool", ioc->pdev, sz, 4,
-	    0);
-	if (!ioc->sense_dma_pool) {
-		printk(MPT2SAS_ERR_FMT "sense pool: pci_pool_create failed\n",
-		    ioc->name);
-		goto out;
-	}
-	ioc->sense = pci_pool_alloc(ioc->sense_dma_pool , GFP_KERNEL,
-	    &ioc->sense_dma);
-	if (!ioc->sense) {
-		printk(MPT2SAS_ERR_FMT "sense pool: pci_pool_alloc failed\n",
-		    ioc->name);
-		goto out;
-	}
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT
-	    "sense pool(0x%p): depth(%d), element_size(%d), pool_size"
-	    "(%d kB)\n", ioc->name, ioc->sense, ioc->scsiio_depth,
-	    SCSI_SENSE_BUFFERSIZE, sz/1024));
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "sense_dma(0x%llx)\n",
-	    ioc->name, (unsigned long long)ioc->sense_dma));
-	total_sz += sz;
-
-	/* reply pool, 4 byte align */
-	sz = ioc->reply_free_queue_depth * ioc->reply_sz;
-	ioc->reply_dma_pool = pci_pool_create("reply pool", ioc->pdev, sz, 4,
-	    0);
-	if (!ioc->reply_dma_pool) {
-		printk(MPT2SAS_ERR_FMT "reply pool: pci_pool_create failed\n",
-		    ioc->name);
-		goto out;
-	}
-	ioc->reply = pci_pool_alloc(ioc->reply_dma_pool , GFP_KERNEL,
-	    &ioc->reply_dma);
-	if (!ioc->reply) {
-		printk(MPT2SAS_ERR_FMT "reply pool: pci_pool_alloc failed\n",
-		    ioc->name);
-		goto out;
-	}
-	ioc->reply_dma_min_address = (u32)(ioc->reply_dma);
-	ioc->reply_dma_max_address = (u32)(ioc->reply_dma) + sz;
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "reply pool(0x%p): depth"
-	    "(%d), frame_size(%d), pool_size(%d kB)\n", ioc->name, ioc->reply,
-	    ioc->reply_free_queue_depth, ioc->reply_sz, sz/1024));
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "reply_dma(0x%llx)\n",
-	    ioc->name, (unsigned long long)ioc->reply_dma));
-	total_sz += sz;
-
-	/* reply free queue, 16 byte align */
-	sz = ioc->reply_free_queue_depth * 4;
-	ioc->reply_free_dma_pool = pci_pool_create("reply_free pool",
-	    ioc->pdev, sz, 16, 0);
-	if (!ioc->reply_free_dma_pool) {
-		printk(MPT2SAS_ERR_FMT "reply_free pool: pci_pool_create "
-		    "failed\n", ioc->name);
-		goto out;
-	}
-	ioc->reply_free = pci_pool_alloc(ioc->reply_free_dma_pool , GFP_KERNEL,
-	    &ioc->reply_free_dma);
-	if (!ioc->reply_free) {
-		printk(MPT2SAS_ERR_FMT "reply_free pool: pci_pool_alloc "
-		    "failed\n", ioc->name);
-		goto out;
-	}
-	memset(ioc->reply_free, 0, sz);
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "reply_free pool(0x%p): "
-	    "depth(%d), element_size(%d), pool_size(%d kB)\n", ioc->name,
-	    ioc->reply_free, ioc->reply_free_queue_depth, 4, sz/1024));
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "reply_free_dma"
-	    "(0x%llx)\n", ioc->name, (unsigned long long)ioc->reply_free_dma));
-	total_sz += sz;
-
-	ioc->config_page_sz = 512;
-	ioc->config_page = pci_alloc_consistent(ioc->pdev,
-	    ioc->config_page_sz, &ioc->config_page_dma);
-	if (!ioc->config_page) {
-		printk(MPT2SAS_ERR_FMT "config page: pci_pool_alloc "
-		    "failed\n", ioc->name);
-		goto out;
-	}
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "config page(0x%p): size"
-	    "(%d)\n", ioc->name, ioc->config_page, ioc->config_page_sz));
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "config_page_dma"
-	    "(0x%llx)\n", ioc->name, (unsigned long long)ioc->config_page_dma));
-	total_sz += ioc->config_page_sz;
-
-	printk(MPT2SAS_INFO_FMT "Allocated physical memory: size(%d kB)\n",
-	    ioc->name, total_sz/1024);
-	printk(MPT2SAS_INFO_FMT "Current Controller Queue Depth(%d), "
-	    "Max Controller Queue Depth(%d)\n",
-	    ioc->name, ioc->shost->can_queue, facts->RequestCredit);
-	printk(MPT2SAS_INFO_FMT "Scatter Gather Elements per IO(%d)\n",
-	    ioc->name, ioc->shost->sg_tablesize);
-	return 0;
-
- out:
-	return -ENOMEM;
-}
-
-
-/**
- * mpt2sas_base_get_iocstate - Get the current state of a MPT adapter.
- * @ioc: Pointer to MPT_ADAPTER structure
- * @cooked: Request raw or cooked IOC state
- *
- * Returns all IOC Doorbell register bits if cooked==0, else just the
- * Doorbell bits in MPI_IOC_STATE_MASK.
- */
-u32
-mpt2sas_base_get_iocstate(struct MPT2SAS_ADAPTER *ioc, int cooked)
-{
-	u32 s, sc;
-
-	s = readl(&ioc->chip->Doorbell);
-	sc = s & MPI2_IOC_STATE_MASK;
-	return cooked ? sc : s;
-}
-
-/**
- * _base_wait_on_iocstate - waiting on a particular ioc state
- * @ioc_state: controller state { READY, OPERATIONAL, or RESET }
- * @timeout: timeout in second
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_base_wait_on_iocstate(struct MPT2SAS_ADAPTER *ioc, u32 ioc_state, int timeout,
-    int sleep_flag)
-{
-	u32 count, cntdn;
-	u32 current_state;
-
-	count = 0;
-	cntdn = (sleep_flag == CAN_SLEEP) ? 1000*timeout : 2000*timeout;
-	do {
-		current_state = mpt2sas_base_get_iocstate(ioc, 1);
-		if (current_state == ioc_state)
-			return 0;
-		if (count && current_state == MPI2_IOC_STATE_FAULT)
-			break;
-		if (sleep_flag == CAN_SLEEP)
-			msleep(1);
-		else
-			udelay(500);
-		count++;
-	} while (--cntdn);
-
-	return current_state;
-}
-
-/**
- * _base_wait_for_doorbell_int - waiting for controller interrupt(generated by
- * a write to the doorbell)
- * @ioc: per adapter object
- * @timeout: timeout in second
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * Returns 0 for success, non-zero for failure.
- *
- * Notes: MPI2_HIS_IOC2SYS_DB_STATUS - set to one when IOC writes to doorbell.
- */
-static int
-_base_wait_for_doorbell_int(struct MPT2SAS_ADAPTER *ioc, int timeout,
-    int sleep_flag)
-{
-	u32 cntdn, count;
-	u32 int_status;
-
-	count = 0;
-	cntdn = (sleep_flag == CAN_SLEEP) ? 1000*timeout : 2000*timeout;
-	do {
-		int_status = readl(&ioc->chip->HostInterruptStatus);
-		if (int_status & MPI2_HIS_IOC2SYS_DB_STATUS) {
-			dhsprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-			    "successful count(%d), timeout(%d)\n", ioc->name,
-			    __func__, count, timeout));
-			return 0;
-		}
-		if (sleep_flag == CAN_SLEEP)
-			msleep(1);
-		else
-			udelay(500);
-		count++;
-	} while (--cntdn);
-
-	printk(MPT2SAS_ERR_FMT "%s: failed due to timeout count(%d), "
-	    "int_status(%x)!\n", ioc->name, __func__, count, int_status);
-	return -EFAULT;
-}
-
-/**
- * _base_wait_for_doorbell_ack - waiting for controller to read the doorbell.
- * @ioc: per adapter object
- * @timeout: timeout in second
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * Returns 0 for success, non-zero for failure.
- *
- * Notes: MPI2_HIS_SYS2IOC_DB_STATUS - set to one when host writes to
- * doorbell.
- */
-static int
-_base_wait_for_doorbell_ack(struct MPT2SAS_ADAPTER *ioc, int timeout,
-    int sleep_flag)
-{
-	u32 cntdn, count;
-	u32 int_status;
-	u32 doorbell;
-
-	count = 0;
-	cntdn = (sleep_flag == CAN_SLEEP) ? 1000*timeout : 2000*timeout;
-	do {
-		int_status = readl(&ioc->chip->HostInterruptStatus);
-		if (!(int_status & MPI2_HIS_SYS2IOC_DB_STATUS)) {
-			dhsprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-			    "successful count(%d), timeout(%d)\n", ioc->name,
-			    __func__, count, timeout));
-			return 0;
-		} else if (int_status & MPI2_HIS_IOC2SYS_DB_STATUS) {
-			doorbell = readl(&ioc->chip->Doorbell);
-			if ((doorbell & MPI2_IOC_STATE_MASK) ==
-			    MPI2_IOC_STATE_FAULT) {
-				mpt2sas_base_fault_info(ioc , doorbell);
-				return -EFAULT;
-			}
-		} else if (int_status == 0xFFFFFFFF)
-			goto out;
-
-		if (sleep_flag == CAN_SLEEP)
-			msleep(1);
-		else
-			udelay(500);
-		count++;
-	} while (--cntdn);
-
- out:
-	printk(MPT2SAS_ERR_FMT "%s: failed due to timeout count(%d), "
-	    "int_status(%x)!\n", ioc->name, __func__, count, int_status);
-	return -EFAULT;
-}
-
-/**
- * _base_wait_for_doorbell_not_used - waiting for doorbell to not be in use
- * @ioc: per adapter object
- * @timeout: timeout in second
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * Returns 0 for success, non-zero for failure.
- *
- */
-static int
-_base_wait_for_doorbell_not_used(struct MPT2SAS_ADAPTER *ioc, int timeout,
-    int sleep_flag)
-{
-	u32 cntdn, count;
-	u32 doorbell_reg;
-
-	count = 0;
-	cntdn = (sleep_flag == CAN_SLEEP) ? 1000*timeout : 2000*timeout;
-	do {
-		doorbell_reg = readl(&ioc->chip->Doorbell);
-		if (!(doorbell_reg & MPI2_DOORBELL_USED)) {
-			dhsprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-			    "successful count(%d), timeout(%d)\n", ioc->name,
-			    __func__, count, timeout));
-			return 0;
-		}
-		if (sleep_flag == CAN_SLEEP)
-			msleep(1);
-		else
-			udelay(500);
-		count++;
-	} while (--cntdn);
-
-	printk(MPT2SAS_ERR_FMT "%s: failed due to timeout count(%d), "
-	    "doorbell_reg(%x)!\n", ioc->name, __func__, count, doorbell_reg);
-	return -EFAULT;
-}
-
-/**
- * _base_send_ioc_reset - send doorbell reset
- * @ioc: per adapter object
- * @reset_type: currently only supports: MPI2_FUNCTION_IOC_MESSAGE_UNIT_RESET
- * @timeout: timeout in second
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_base_send_ioc_reset(struct MPT2SAS_ADAPTER *ioc, u8 reset_type, int timeout,
-    int sleep_flag)
-{
-	u32 ioc_state;
-	int r = 0;
-
-	if (reset_type != MPI2_FUNCTION_IOC_MESSAGE_UNIT_RESET) {
-		printk(MPT2SAS_ERR_FMT "%s: unknown reset_type\n",
-		    ioc->name, __func__);
-		return -EFAULT;
-	}
-
-	if (!(ioc->facts.IOCCapabilities &
-	   MPI2_IOCFACTS_CAPABILITY_EVENT_REPLAY))
-		return -EFAULT;
-
-	printk(MPT2SAS_INFO_FMT "sending message unit reset !!\n", ioc->name);
-
-	writel(reset_type << MPI2_DOORBELL_FUNCTION_SHIFT,
-	    &ioc->chip->Doorbell);
-	if ((_base_wait_for_doorbell_ack(ioc, 15, sleep_flag))) {
-		r = -EFAULT;
-		goto out;
-	}
-	ioc_state = _base_wait_on_iocstate(ioc, MPI2_IOC_STATE_READY,
-	    timeout, sleep_flag);
-	if (ioc_state) {
-		printk(MPT2SAS_ERR_FMT "%s: failed going to ready state "
-		    " (ioc_state=0x%x)\n", ioc->name, __func__, ioc_state);
-		r = -EFAULT;
-		goto out;
-	}
- out:
-	printk(MPT2SAS_INFO_FMT "message unit reset: %s\n",
-	    ioc->name, ((r == 0) ? "SUCCESS" : "FAILED"));
-	return r;
-}
-
-/**
- * _base_handshake_req_reply_wait - send request thru doorbell interface
- * @ioc: per adapter object
- * @request_bytes: request length
- * @request: pointer having request payload
- * @reply_bytes: reply length
- * @reply: pointer to reply payload
- * @timeout: timeout in second
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_base_handshake_req_reply_wait(struct MPT2SAS_ADAPTER *ioc, int request_bytes,
-    u32 *request, int reply_bytes, u16 *reply, int timeout, int sleep_flag)
-{
-	MPI2DefaultReply_t *default_reply = (MPI2DefaultReply_t *)reply;
-	int i;
-	u8 failed;
-	u16 dummy;
-	__le32 *mfp;
-
-	/* make sure doorbell is not in use */
-	if ((readl(&ioc->chip->Doorbell) & MPI2_DOORBELL_USED)) {
-		printk(MPT2SAS_ERR_FMT "doorbell is in use "
-		    " (line=%d)\n", ioc->name, __LINE__);
-		return -EFAULT;
-	}
-
-	/* clear pending doorbell interrupts from previous state changes */
-	if (readl(&ioc->chip->HostInterruptStatus) &
-	    MPI2_HIS_IOC2SYS_DB_STATUS)
-		writel(0, &ioc->chip->HostInterruptStatus);
-
-	/* send message to ioc */
-	writel(((MPI2_FUNCTION_HANDSHAKE<<MPI2_DOORBELL_FUNCTION_SHIFT) |
-	    ((request_bytes/4)<<MPI2_DOORBELL_ADD_DWORDS_SHIFT)),
-	    &ioc->chip->Doorbell);
-
-	if ((_base_wait_for_doorbell_int(ioc, 5, NO_SLEEP))) {
-		printk(MPT2SAS_ERR_FMT "doorbell handshake "
-		   "int failed (line=%d)\n", ioc->name, __LINE__);
-		return -EFAULT;
-	}
-	writel(0, &ioc->chip->HostInterruptStatus);
-
-	if ((_base_wait_for_doorbell_ack(ioc, 5, sleep_flag))) {
-		printk(MPT2SAS_ERR_FMT "doorbell handshake "
-		    "ack failed (line=%d)\n", ioc->name, __LINE__);
-		return -EFAULT;
-	}
-
-	/* send message 32-bits at a time */
-	for (i = 0, failed = 0; i < request_bytes/4 && !failed; i++) {
-		writel(cpu_to_le32(request[i]), &ioc->chip->Doorbell);
-		if ((_base_wait_for_doorbell_ack(ioc, 5, sleep_flag)))
-			failed = 1;
-	}
-
-	if (failed) {
-		printk(MPT2SAS_ERR_FMT "doorbell handshake "
-		    "sending request failed (line=%d)\n", ioc->name, __LINE__);
-		return -EFAULT;
-	}
-
-	/* now wait for the reply */
-	if ((_base_wait_for_doorbell_int(ioc, timeout, sleep_flag))) {
-		printk(MPT2SAS_ERR_FMT "doorbell handshake "
-		   "int failed (line=%d)\n", ioc->name, __LINE__);
-		return -EFAULT;
-	}
-
-	/* read the first two 16-bits, it gives the total length of the reply */
-	reply[0] = le16_to_cpu(readl(&ioc->chip->Doorbell)
-	    & MPI2_DOORBELL_DATA_MASK);
-	writel(0, &ioc->chip->HostInterruptStatus);
-	if ((_base_wait_for_doorbell_int(ioc, 5, sleep_flag))) {
-		printk(MPT2SAS_ERR_FMT "doorbell handshake "
-		   "int failed (line=%d)\n", ioc->name, __LINE__);
-		return -EFAULT;
-	}
-	reply[1] = le16_to_cpu(readl(&ioc->chip->Doorbell)
-	    & MPI2_DOORBELL_DATA_MASK);
-	writel(0, &ioc->chip->HostInterruptStatus);
-
-	for (i = 2; i < default_reply->MsgLength * 2; i++)  {
-		if ((_base_wait_for_doorbell_int(ioc, 5, sleep_flag))) {
-			printk(MPT2SAS_ERR_FMT "doorbell "
-			    "handshake int failed (line=%d)\n", ioc->name,
-			    __LINE__);
-			return -EFAULT;
-		}
-		if (i >=  reply_bytes/2) /* overflow case */
-			dummy = readl(&ioc->chip->Doorbell);
-		else
-			reply[i] = le16_to_cpu(readl(&ioc->chip->Doorbell)
-			    & MPI2_DOORBELL_DATA_MASK);
-		writel(0, &ioc->chip->HostInterruptStatus);
-	}
-
-	_base_wait_for_doorbell_int(ioc, 5, sleep_flag);
-	if (_base_wait_for_doorbell_not_used(ioc, 5, sleep_flag) != 0) {
-		dhsprintk(ioc, printk(MPT2SAS_INFO_FMT "doorbell is in use "
-		    " (line=%d)\n", ioc->name, __LINE__));
-	}
-	writel(0, &ioc->chip->HostInterruptStatus);
-
-	if (ioc->logging_level & MPT_DEBUG_INIT) {
-		mfp = (__le32 *)reply;
-		printk(KERN_INFO "\toffset:data\n");
-		for (i = 0; i < reply_bytes/4; i++)
-			printk(KERN_INFO "\t[0x%02x]:%08x\n", i*4,
-			    le32_to_cpu(mfp[i]));
-	}
-	return 0;
-}
-
-/**
- * mpt2sas_base_sas_iounit_control - send sas iounit control to FW
- * @ioc: per adapter object
- * @mpi_reply: the reply payload from FW
- * @mpi_request: the request payload sent to FW
- *
- * The SAS IO Unit Control Request message allows the host to perform low-level
- * operations, such as resets on the PHYs of the IO Unit, also allows the host
- * to obtain the IOC assigned device handles for a device if it has other
- * identifying information about the device, in addition allows the host to
- * remove IOC resources associated with the device.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_base_sas_iounit_control(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2SasIoUnitControlReply_t *mpi_reply,
-    Mpi2SasIoUnitControlRequest_t *mpi_request)
-{
-	u16 smid;
-	u32 ioc_state;
-	unsigned long timeleft;
-	bool issue_reset = false;
-	int rc;
-	void *request;
-	u16 wait_state_count;
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	mutex_lock(&ioc->base_cmds.mutex);
-
-	if (ioc->base_cmds.status != MPT2_CMD_NOT_USED) {
-		printk(MPT2SAS_ERR_FMT "%s: base_cmd in use\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-
-	wait_state_count = 0;
-	ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
-		if (wait_state_count++ == 10) {
-			printk(MPT2SAS_ERR_FMT
-			    "%s: failed due to ioc not operational\n",
-			    ioc->name, __func__);
-			rc = -EFAULT;
-			goto out;
-		}
-		ssleep(1);
-		ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-		printk(MPT2SAS_INFO_FMT "%s: waiting for "
-		    "operational state(count=%d)\n", ioc->name,
-		    __func__, wait_state_count);
-	}
-
-	smid = mpt2sas_base_get_smid(ioc, ioc->base_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-
-	rc = 0;
-	ioc->base_cmds.status = MPT2_CMD_PENDING;
-	request = mpt2sas_base_get_msg_frame(ioc, smid);
-	ioc->base_cmds.smid = smid;
-	memcpy(request, mpi_request, sizeof(Mpi2SasIoUnitControlRequest_t));
-	if (mpi_request->Operation == MPI2_SAS_OP_PHY_HARD_RESET ||
-	    mpi_request->Operation == MPI2_SAS_OP_PHY_LINK_RESET)
-		ioc->ioc_link_reset_in_progress = 1;
-	init_completion(&ioc->base_cmds.done);
-	mpt2sas_base_put_smid_default(ioc, smid);
-	timeleft = wait_for_completion_timeout(&ioc->base_cmds.done,
-	    msecs_to_jiffies(10000));
-	if ((mpi_request->Operation == MPI2_SAS_OP_PHY_HARD_RESET ||
-	    mpi_request->Operation == MPI2_SAS_OP_PHY_LINK_RESET) &&
-	    ioc->ioc_link_reset_in_progress)
-		ioc->ioc_link_reset_in_progress = 0;
-	if (!(ioc->base_cmds.status & MPT2_CMD_COMPLETE)) {
-		printk(MPT2SAS_ERR_FMT "%s: timeout\n",
-		    ioc->name, __func__);
-		_debug_dump_mf(mpi_request,
-		    sizeof(Mpi2SasIoUnitControlRequest_t)/4);
-		if (!(ioc->base_cmds.status & MPT2_CMD_RESET))
-			issue_reset = true;
-		goto issue_host_reset;
-	}
-	if (ioc->base_cmds.status & MPT2_CMD_REPLY_VALID)
-		memcpy(mpi_reply, ioc->base_cmds.reply,
-		    sizeof(Mpi2SasIoUnitControlReply_t));
-	else
-		memset(mpi_reply, 0, sizeof(Mpi2SasIoUnitControlReply_t));
-	ioc->base_cmds.status = MPT2_CMD_NOT_USED;
-	goto out;
-
- issue_host_reset:
-	if (issue_reset)
-		mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-		    FORCE_BIG_HAMMER);
-	ioc->base_cmds.status = MPT2_CMD_NOT_USED;
-	rc = -EFAULT;
- out:
-	mutex_unlock(&ioc->base_cmds.mutex);
-	return rc;
-}
-
-
-/**
- * mpt2sas_base_scsi_enclosure_processor - sending request to sep device
- * @ioc: per adapter object
- * @mpi_reply: the reply payload from FW
- * @mpi_request: the request payload sent to FW
- *
- * The SCSI Enclosure Processor request message causes the IOC to
- * communicate with SES devices to control LED status signals.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_base_scsi_enclosure_processor(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2SepReply_t *mpi_reply, Mpi2SepRequest_t *mpi_request)
-{
-	u16 smid;
-	u32 ioc_state;
-	unsigned long timeleft;
-	bool issue_reset = false;
-	int rc;
-	void *request;
-	u16 wait_state_count;
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	mutex_lock(&ioc->base_cmds.mutex);
-
-	if (ioc->base_cmds.status != MPT2_CMD_NOT_USED) {
-		printk(MPT2SAS_ERR_FMT "%s: base_cmd in use\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-
-	wait_state_count = 0;
-	ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
-		if (wait_state_count++ == 10) {
-			printk(MPT2SAS_ERR_FMT
-			    "%s: failed due to ioc not operational\n",
-			    ioc->name, __func__);
-			rc = -EFAULT;
-			goto out;
-		}
-		ssleep(1);
-		ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-		printk(MPT2SAS_INFO_FMT "%s: waiting for "
-		    "operational state(count=%d)\n", ioc->name,
-		    __func__, wait_state_count);
-	}
-
-	smid = mpt2sas_base_get_smid(ioc, ioc->base_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-
-	rc = 0;
-	ioc->base_cmds.status = MPT2_CMD_PENDING;
-	request = mpt2sas_base_get_msg_frame(ioc, smid);
-	ioc->base_cmds.smid = smid;
-	memcpy(request, mpi_request, sizeof(Mpi2SepReply_t));
-	init_completion(&ioc->base_cmds.done);
-	mpt2sas_base_put_smid_default(ioc, smid);
-	timeleft = wait_for_completion_timeout(&ioc->base_cmds.done,
-	    msecs_to_jiffies(10000));
-	if (!(ioc->base_cmds.status & MPT2_CMD_COMPLETE)) {
-		printk(MPT2SAS_ERR_FMT "%s: timeout\n",
-		    ioc->name, __func__);
-		_debug_dump_mf(mpi_request,
-		    sizeof(Mpi2SepRequest_t)/4);
-		if (!(ioc->base_cmds.status & MPT2_CMD_RESET))
-			issue_reset = true;
-		goto issue_host_reset;
-	}
-	if (ioc->base_cmds.status & MPT2_CMD_REPLY_VALID)
-		memcpy(mpi_reply, ioc->base_cmds.reply,
-		    sizeof(Mpi2SepReply_t));
-	else
-		memset(mpi_reply, 0, sizeof(Mpi2SepReply_t));
-	ioc->base_cmds.status = MPT2_CMD_NOT_USED;
-	goto out;
-
- issue_host_reset:
-	if (issue_reset)
-		mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-		    FORCE_BIG_HAMMER);
-	ioc->base_cmds.status = MPT2_CMD_NOT_USED;
-	rc = -EFAULT;
- out:
-	mutex_unlock(&ioc->base_cmds.mutex);
-	return rc;
-}
-
-/**
- * _base_get_port_facts - obtain port facts reply and save in ioc
- * @ioc: per adapter object
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_base_get_port_facts(struct MPT2SAS_ADAPTER *ioc, int port, int sleep_flag)
-{
-	Mpi2PortFactsRequest_t mpi_request;
-	Mpi2PortFactsReply_t mpi_reply;
-	struct mpt2sas_port_facts *pfacts;
-	int mpi_reply_sz, mpi_request_sz, r;
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	mpi_reply_sz = sizeof(Mpi2PortFactsReply_t);
-	mpi_request_sz = sizeof(Mpi2PortFactsRequest_t);
-	memset(&mpi_request, 0, mpi_request_sz);
-	mpi_request.Function = MPI2_FUNCTION_PORT_FACTS;
-	mpi_request.PortNumber = port;
-	r = _base_handshake_req_reply_wait(ioc, mpi_request_sz,
-	    (u32 *)&mpi_request, mpi_reply_sz, (u16 *)&mpi_reply, 5, CAN_SLEEP);
-
-	if (r != 0) {
-		printk(MPT2SAS_ERR_FMT "%s: handshake failed (r=%d)\n",
-		    ioc->name, __func__, r);
-		return r;
-	}
-
-	pfacts = &ioc->pfacts[port];
-	memset(pfacts, 0, sizeof(struct mpt2sas_port_facts));
-	pfacts->PortNumber = mpi_reply.PortNumber;
-	pfacts->VP_ID = mpi_reply.VP_ID;
-	pfacts->VF_ID = mpi_reply.VF_ID;
-	pfacts->MaxPostedCmdBuffers =
-	    le16_to_cpu(mpi_reply.MaxPostedCmdBuffers);
-
-	return 0;
-}
-
-/**
- * _base_wait_for_iocstate - Wait until the card is in READY or OPERATIONAL
- * @ioc: per adapter object
- * @timeout:
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_base_wait_for_iocstate(struct MPT2SAS_ADAPTER *ioc, int timeout,
-	int sleep_flag)
-{
-	u32 ioc_state, doorbell;
-	int rc;
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	if (ioc->pci_error_recovery)
-		return 0;
-
-	doorbell = mpt2sas_base_get_iocstate(ioc, 0);
-	ioc_state = doorbell & MPI2_IOC_STATE_MASK;
-	dhsprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: ioc_state(0x%08x)\n",
-	    ioc->name, __func__, ioc_state));
-
-	switch (ioc_state) {
-	case MPI2_IOC_STATE_READY:
-	case MPI2_IOC_STATE_OPERATIONAL:
-		return 0;
-	}
-
-	if (doorbell & MPI2_DOORBELL_USED) {
-		dhsprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "unexpected doorbell activ!e\n", ioc->name));
-		goto issue_diag_reset;
-	}
-
-	if (ioc_state == MPI2_IOC_STATE_FAULT) {
-		mpt2sas_base_fault_info(ioc, doorbell &
-		    MPI2_DOORBELL_DATA_MASK);
-		goto issue_diag_reset;
-	}
-
-	ioc_state = _base_wait_on_iocstate(ioc, MPI2_IOC_STATE_READY,
-	    timeout, sleep_flag);
-	if (ioc_state) {
-		printk(MPT2SAS_ERR_FMT
-		    "%s: failed going to ready state (ioc_state=0x%x)\n",
-		    ioc->name, __func__, ioc_state);
-		return -EFAULT;
-	}
-
- issue_diag_reset:
-	rc = _base_diag_reset(ioc, sleep_flag);
-	return rc;
-}
-
-/**
- * _base_get_ioc_facts - obtain ioc facts reply and save in ioc
- * @ioc: per adapter object
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_base_get_ioc_facts(struct MPT2SAS_ADAPTER *ioc, int sleep_flag)
-{
-	Mpi2IOCFactsRequest_t mpi_request;
-	Mpi2IOCFactsReply_t mpi_reply;
-	struct mpt2sas_facts *facts;
-	int mpi_reply_sz, mpi_request_sz, r;
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	r = _base_wait_for_iocstate(ioc, 10, sleep_flag);
-	if (r) {
-		printk(MPT2SAS_ERR_FMT "%s: failed getting to correct state\n",
-			ioc->name, __func__);
-		return r;
-	}
-
-	mpi_reply_sz = sizeof(Mpi2IOCFactsReply_t);
-	mpi_request_sz = sizeof(Mpi2IOCFactsRequest_t);
-	memset(&mpi_request, 0, mpi_request_sz);
-	mpi_request.Function = MPI2_FUNCTION_IOC_FACTS;
-	r = _base_handshake_req_reply_wait(ioc, mpi_request_sz,
-	    (u32 *)&mpi_request, mpi_reply_sz, (u16 *)&mpi_reply, 5, CAN_SLEEP);
-
-	if (r != 0) {
-		printk(MPT2SAS_ERR_FMT "%s: handshake failed (r=%d)\n",
-		    ioc->name, __func__, r);
-		return r;
-	}
-
-	facts = &ioc->facts;
-	memset(facts, 0, sizeof(struct mpt2sas_facts));
-	facts->MsgVersion = le16_to_cpu(mpi_reply.MsgVersion);
-	facts->HeaderVersion = le16_to_cpu(mpi_reply.HeaderVersion);
-	facts->VP_ID = mpi_reply.VP_ID;
-	facts->VF_ID = mpi_reply.VF_ID;
-	facts->IOCExceptions = le16_to_cpu(mpi_reply.IOCExceptions);
-	facts->MaxChainDepth = mpi_reply.MaxChainDepth;
-	facts->WhoInit = mpi_reply.WhoInit;
-	facts->NumberOfPorts = mpi_reply.NumberOfPorts;
-	facts->MaxMSIxVectors = mpi_reply.MaxMSIxVectors;
-	facts->RequestCredit = le16_to_cpu(mpi_reply.RequestCredit);
-	facts->MaxReplyDescriptorPostQueueDepth =
-	    le16_to_cpu(mpi_reply.MaxReplyDescriptorPostQueueDepth);
-	facts->ProductID = le16_to_cpu(mpi_reply.ProductID);
-	facts->IOCCapabilities = le32_to_cpu(mpi_reply.IOCCapabilities);
-	if ((facts->IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_INTEGRATED_RAID))
-		ioc->ir_firmware = 1;
-	if ((facts->IOCCapabilities &
-	      MPI2_IOCFACTS_CAPABILITY_RDPQ_ARRAY_CAPABLE))
-		ioc->rdpq_array_capable = 1;
-	facts->FWVersion.Word = le32_to_cpu(mpi_reply.FWVersion.Word);
-	facts->IOCRequestFrameSize =
-	    le16_to_cpu(mpi_reply.IOCRequestFrameSize);
-	facts->MaxInitiators = le16_to_cpu(mpi_reply.MaxInitiators);
-	facts->MaxTargets = le16_to_cpu(mpi_reply.MaxTargets);
-	ioc->shost->max_id = -1;
-	facts->MaxSasExpanders = le16_to_cpu(mpi_reply.MaxSasExpanders);
-	facts->MaxEnclosures = le16_to_cpu(mpi_reply.MaxEnclosures);
-	facts->ProtocolFlags = le16_to_cpu(mpi_reply.ProtocolFlags);
-	facts->HighPriorityCredit =
-	    le16_to_cpu(mpi_reply.HighPriorityCredit);
-	facts->ReplyFrameSize = mpi_reply.ReplyFrameSize;
-	facts->MaxDevHandle = le16_to_cpu(mpi_reply.MaxDevHandle);
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "hba queue depth(%d), "
-	    "max chains per io(%d)\n", ioc->name, facts->RequestCredit,
-	    facts->MaxChainDepth));
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "request frame size(%d), "
-	    "reply frame size(%d)\n", ioc->name,
-	    facts->IOCRequestFrameSize * 4, facts->ReplyFrameSize * 4));
-	return 0;
-}
-
-/**
- * _base_send_ioc_init - send ioc_init to firmware
- * @ioc: per adapter object
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_base_send_ioc_init(struct MPT2SAS_ADAPTER *ioc, int sleep_flag)
-{
-	Mpi2IOCInitRequest_t mpi_request;
-	Mpi2IOCInitReply_t mpi_reply;
-	int i, r = 0;
-	struct timeval current_time;
-	u16 ioc_status;
-	u32 reply_post_free_array_sz = 0;
-	Mpi2IOCInitRDPQArrayEntry *reply_post_free_array = NULL;
-	dma_addr_t reply_post_free_array_dma;
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	memset(&mpi_request, 0, sizeof(Mpi2IOCInitRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_IOC_INIT;
-	mpi_request.WhoInit = MPI2_WHOINIT_HOST_DRIVER;
-	mpi_request.VF_ID = 0; /* TODO */
-	mpi_request.VP_ID = 0;
-	mpi_request.MsgVersion = cpu_to_le16(MPI2_VERSION);
-	mpi_request.HeaderVersion = cpu_to_le16(MPI2_HEADER_VERSION);
-
-	if (_base_is_controller_msix_enabled(ioc))
-		mpi_request.HostMSIxVectors = ioc->reply_queue_count;
-	mpi_request.SystemRequestFrameSize = cpu_to_le16(ioc->request_sz/4);
-	mpi_request.ReplyDescriptorPostQueueDepth =
-	    cpu_to_le16(ioc->reply_post_queue_depth);
-	mpi_request.ReplyFreeQueueDepth =
-	    cpu_to_le16(ioc->reply_free_queue_depth);
-
-	mpi_request.SenseBufferAddressHigh =
-	    cpu_to_le32((u64)ioc->sense_dma >> 32);
-	mpi_request.SystemReplyAddressHigh =
-	    cpu_to_le32((u64)ioc->reply_dma >> 32);
-	mpi_request.SystemRequestFrameBaseAddress =
-	    cpu_to_le64((u64)ioc->request_dma);
-	mpi_request.ReplyFreeQueueAddress =
-	    cpu_to_le64((u64)ioc->reply_free_dma);
-
-	if (ioc->rdpq_array_enable) {
-		reply_post_free_array_sz = ioc->reply_queue_count *
-		    sizeof(Mpi2IOCInitRDPQArrayEntry);
-		reply_post_free_array = pci_alloc_consistent(ioc->pdev,
-			reply_post_free_array_sz, &reply_post_free_array_dma);
-		if (!reply_post_free_array) {
-			printk(MPT2SAS_ERR_FMT
-			"reply_post_free_array: pci_alloc_consistent failed\n",
-			ioc->name);
-			r = -ENOMEM;
-			goto out;
-		}
-		memset(reply_post_free_array, 0, reply_post_free_array_sz);
-		for (i = 0; i < ioc->reply_queue_count; i++)
-			reply_post_free_array[i].RDPQBaseAddress =
-			    cpu_to_le64(
-				(u64)ioc->reply_post[i].reply_post_free_dma);
-		mpi_request.MsgFlags = MPI2_IOCINIT_MSGFLAG_RDPQ_ARRAY_MODE;
-		mpi_request.ReplyDescriptorPostQueueAddress =
-		    cpu_to_le64((u64)reply_post_free_array_dma);
-	} else {
-		mpi_request.ReplyDescriptorPostQueueAddress =
-		    cpu_to_le64((u64)ioc->reply_post[0].reply_post_free_dma);
-	}
-
-	/* This time stamp specifies number of milliseconds
-	 * since epoch ~ midnight January 1, 1970.
-	 */
-	do_gettimeofday(&current_time);
-	mpi_request.TimeStamp = cpu_to_le64((u64)current_time.tv_sec * 1000 +
-	    (current_time.tv_usec / 1000));
-
-	if (ioc->logging_level & MPT_DEBUG_INIT) {
-		__le32 *mfp;
-		int i;
-
-		mfp = (__le32 *)&mpi_request;
-		printk(KERN_INFO "\toffset:data\n");
-		for (i = 0; i < sizeof(Mpi2IOCInitRequest_t)/4; i++)
-			printk(KERN_INFO "\t[0x%02x]:%08x\n", i*4,
-			    le32_to_cpu(mfp[i]));
-	}
-
-	r = _base_handshake_req_reply_wait(ioc,
-	    sizeof(Mpi2IOCInitRequest_t), (u32 *)&mpi_request,
-	    sizeof(Mpi2IOCInitReply_t), (u16 *)&mpi_reply, 10,
-	    sleep_flag);
-
-	if (r != 0) {
-		printk(MPT2SAS_ERR_FMT "%s: handshake failed (r=%d)\n",
-		    ioc->name, __func__, r);
-		goto out;
-	}
-
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS ||
-	    mpi_reply.IOCLogInfo) {
-		printk(MPT2SAS_ERR_FMT "%s: failed\n", ioc->name, __func__);
-		r = -EIO;
-	}
-
-out:
-	if (reply_post_free_array)
-		pci_free_consistent(ioc->pdev, reply_post_free_array_sz,
-				    reply_post_free_array,
-				    reply_post_free_array_dma);
-	return r;
-}
-
-/**
- * mpt2sas_port_enable_done - command completion routine for port enable
- * @ioc: per adapter object
- * @smid: system request message index
- * @msix_index: MSIX table index supplied by the OS
- * @reply: reply message frame(lower 32bit addr)
- *
- * Return 1 meaning mf should be freed from _base_interrupt
- *        0 means the mf is freed from this function.
- */
-u8
-mpt2sas_port_enable_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
-	u32 reply)
-{
-	MPI2DefaultReply_t *mpi_reply;
-	u16 ioc_status;
-
-	mpi_reply = mpt2sas_base_get_reply_virt_addr(ioc, reply);
-	if (mpi_reply && mpi_reply->Function == MPI2_FUNCTION_EVENT_ACK)
-		return 1;
-
-	if (ioc->port_enable_cmds.status == MPT2_CMD_NOT_USED)
-		return 1;
-
-	ioc->port_enable_cmds.status |= MPT2_CMD_COMPLETE;
-	if (mpi_reply) {
-		ioc->port_enable_cmds.status |= MPT2_CMD_REPLY_VALID;
-		memcpy(ioc->port_enable_cmds.reply, mpi_reply,
-		    mpi_reply->MsgLength*4);
-	}
-	ioc->port_enable_cmds.status &= ~MPT2_CMD_PENDING;
-
-	ioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;
-
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS)
-		ioc->port_enable_failed = 1;
-
-	if (ioc->is_driver_loading) {
-		if (ioc_status == MPI2_IOCSTATUS_SUCCESS) {
-			mpt2sas_port_enable_complete(ioc);
-			return 1;
-		} else {
-			ioc->start_scan_failed = ioc_status;
-			ioc->start_scan = 0;
-			return 1;
-		}
-	}
-	complete(&ioc->port_enable_cmds.done);
-	return 1;
-}
-
-
-/**
- * _base_send_port_enable - send port_enable(discovery stuff) to firmware
- * @ioc: per adapter object
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_base_send_port_enable(struct MPT2SAS_ADAPTER *ioc, int sleep_flag)
-{
-	Mpi2PortEnableRequest_t *mpi_request;
-	Mpi2PortEnableReply_t *mpi_reply;
-	unsigned long timeleft;
-	int r = 0;
-	u16 smid;
-	u16 ioc_status;
-
-	printk(MPT2SAS_INFO_FMT "sending port enable !!\n", ioc->name);
-
-	if (ioc->port_enable_cmds.status & MPT2_CMD_PENDING) {
-		printk(MPT2SAS_ERR_FMT "%s: internal command already in use\n",
-		    ioc->name, __func__);
-		return -EAGAIN;
-	}
-
-	smid = mpt2sas_base_get_smid(ioc, ioc->port_enable_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		return -EAGAIN;
-	}
-
-	ioc->port_enable_cmds.status = MPT2_CMD_PENDING;
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	ioc->port_enable_cmds.smid = smid;
-	memset(mpi_request, 0, sizeof(Mpi2PortEnableRequest_t));
-	mpi_request->Function = MPI2_FUNCTION_PORT_ENABLE;
-
-	init_completion(&ioc->port_enable_cmds.done);
-	mpt2sas_base_put_smid_default(ioc, smid);
-	timeleft = wait_for_completion_timeout(&ioc->port_enable_cmds.done,
-	    300*HZ);
-	if (!(ioc->port_enable_cmds.status & MPT2_CMD_COMPLETE)) {
-		printk(MPT2SAS_ERR_FMT "%s: timeout\n",
-		    ioc->name, __func__);
-		_debug_dump_mf(mpi_request,
-		    sizeof(Mpi2PortEnableRequest_t)/4);
-		if (ioc->port_enable_cmds.status & MPT2_CMD_RESET)
-			r = -EFAULT;
-		else
-			r = -ETIME;
-		goto out;
-	}
-	mpi_reply = ioc->port_enable_cmds.reply;
-
-	ioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-		printk(MPT2SAS_ERR_FMT "%s: failed with (ioc_status=0x%08x)\n",
-		    ioc->name, __func__, ioc_status);
-		r = -EFAULT;
-		goto out;
-	}
- out:
-	ioc->port_enable_cmds.status = MPT2_CMD_NOT_USED;
-	printk(MPT2SAS_INFO_FMT "port enable: %s\n", ioc->name, ((r == 0) ?
-	    "SUCCESS" : "FAILED"));
-	return r;
-}
-
-/**
- * mpt2sas_port_enable - initiate firmware discovery (don't wait for reply)
- * @ioc: per adapter object
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_port_enable(struct MPT2SAS_ADAPTER *ioc)
-{
-	Mpi2PortEnableRequest_t *mpi_request;
-	u16 smid;
-
-	printk(MPT2SAS_INFO_FMT "sending port enable !!\n", ioc->name);
-
-	if (ioc->port_enable_cmds.status & MPT2_CMD_PENDING) {
-		printk(MPT2SAS_ERR_FMT "%s: internal command already in use\n",
-		    ioc->name, __func__);
-		return -EAGAIN;
-	}
-
-	smid = mpt2sas_base_get_smid(ioc, ioc->port_enable_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		return -EAGAIN;
-	}
-
-	ioc->port_enable_cmds.status = MPT2_CMD_PENDING;
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	ioc->port_enable_cmds.smid = smid;
-	memset(mpi_request, 0, sizeof(Mpi2PortEnableRequest_t));
-	mpi_request->Function = MPI2_FUNCTION_PORT_ENABLE;
-
-	mpt2sas_base_put_smid_default(ioc, smid);
-	return 0;
-}
-
-/**
- * _base_determine_wait_on_discovery - desposition
- * @ioc: per adapter object
- *
- * Decide whether to wait on discovery to complete. Used to either
- * locate boot device, or report volumes ahead of physical devices.
- *
- * Returns 1 for wait, 0 for don't wait
- */
-static int
-_base_determine_wait_on_discovery(struct MPT2SAS_ADAPTER *ioc)
-{
-	/* We wait for discovery to complete if IR firmware is loaded.
-	 * The sas topology events arrive before PD events, so we need time to
-	 * turn on the bit in ioc->pd_handles to indicate PD
-	 * Also, it maybe required to report Volumes ahead of physical
-	 * devices when MPI2_IOCPAGE8_IRFLAGS_LOW_VOLUME_MAPPING is set.
-	 */
-	if (ioc->ir_firmware)
-		return 1;
-
-	/* if no Bios, then we don't need to wait */
-	if (!ioc->bios_pg3.BiosVersion)
-		return 0;
-
-	/* Bios is present, then we drop down here.
-	 *
-	 * If there any entries in the Bios Page 2, then we wait
-	 * for discovery to complete.
-	 */
-
-	/* Current Boot Device */
-	if ((ioc->bios_pg2.CurrentBootDeviceForm &
-	    MPI2_BIOSPAGE2_FORM_MASK) ==
-	    MPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED &&
-	/* Request Boot Device */
-	   (ioc->bios_pg2.ReqBootDeviceForm &
-	    MPI2_BIOSPAGE2_FORM_MASK) ==
-	    MPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED &&
-	/* Alternate Request Boot Device */
-	   (ioc->bios_pg2.ReqAltBootDeviceForm &
-	    MPI2_BIOSPAGE2_FORM_MASK) ==
-	    MPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED)
-		return 0;
-
-	return 1;
-}
-
-
-/**
- * _base_unmask_events - turn on notification for this event
- * @ioc: per adapter object
- * @event: firmware event
- *
- * The mask is stored in ioc->event_masks.
- */
-static void
-_base_unmask_events(struct MPT2SAS_ADAPTER *ioc, u16 event)
-{
-	u32 desired_event;
-
-	if (event >= 128)
-		return;
-
-	desired_event = (1 << (event % 32));
-
-	if (event < 32)
-		ioc->event_masks[0] &= ~desired_event;
-	else if (event < 64)
-		ioc->event_masks[1] &= ~desired_event;
-	else if (event < 96)
-		ioc->event_masks[2] &= ~desired_event;
-	else if (event < 128)
-		ioc->event_masks[3] &= ~desired_event;
-}
-
-/**
- * _base_event_notification - send event notification
- * @ioc: per adapter object
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_base_event_notification(struct MPT2SAS_ADAPTER *ioc, int sleep_flag)
-{
-	Mpi2EventNotificationRequest_t *mpi_request;
-	unsigned long timeleft;
-	u16 smid;
-	int r = 0;
-	int i;
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	if (ioc->base_cmds.status & MPT2_CMD_PENDING) {
-		printk(MPT2SAS_ERR_FMT "%s: internal command already in use\n",
-		    ioc->name, __func__);
-		return -EAGAIN;
-	}
-
-	smid = mpt2sas_base_get_smid(ioc, ioc->base_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		return -EAGAIN;
-	}
-	ioc->base_cmds.status = MPT2_CMD_PENDING;
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	ioc->base_cmds.smid = smid;
-	memset(mpi_request, 0, sizeof(Mpi2EventNotificationRequest_t));
-	mpi_request->Function = MPI2_FUNCTION_EVENT_NOTIFICATION;
-	mpi_request->VF_ID = 0; /* TODO */
-	mpi_request->VP_ID = 0;
-	for (i = 0; i < MPI2_EVENT_NOTIFY_EVENTMASK_WORDS; i++)
-		mpi_request->EventMasks[i] =
-		    cpu_to_le32(ioc->event_masks[i]);
-	init_completion(&ioc->base_cmds.done);
-	mpt2sas_base_put_smid_default(ioc, smid);
-	timeleft = wait_for_completion_timeout(&ioc->base_cmds.done, 30*HZ);
-	if (!(ioc->base_cmds.status & MPT2_CMD_COMPLETE)) {
-		printk(MPT2SAS_ERR_FMT "%s: timeout\n",
-		    ioc->name, __func__);
-		_debug_dump_mf(mpi_request,
-		    sizeof(Mpi2EventNotificationRequest_t)/4);
-		if (ioc->base_cmds.status & MPT2_CMD_RESET)
-			r = -EFAULT;
-		else
-			r = -ETIME;
-	} else
-		dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: complete\n",
-		    ioc->name, __func__));
-	ioc->base_cmds.status = MPT2_CMD_NOT_USED;
-	return r;
-}
-
-/**
- * mpt2sas_base_validate_event_type - validating event types
- * @ioc: per adapter object
- * @event: firmware event
- *
- * This will turn on firmware event notification when application
- * ask for that event. We don't mask events that are already enabled.
- */
-void
-mpt2sas_base_validate_event_type(struct MPT2SAS_ADAPTER *ioc, u32 *event_type)
-{
-	int i, j;
-	u32 event_mask, desired_event;
-	u8 send_update_to_fw;
-
-	for (i = 0, send_update_to_fw = 0; i <
-	    MPI2_EVENT_NOTIFY_EVENTMASK_WORDS; i++) {
-		event_mask = ~event_type[i];
-		desired_event = 1;
-		for (j = 0; j < 32; j++) {
-			if (!(event_mask & desired_event) &&
-			    (ioc->event_masks[i] & desired_event)) {
-				ioc->event_masks[i] &= ~desired_event;
-				send_update_to_fw = 1;
-			}
-			desired_event = (desired_event << 1);
-		}
-	}
-
-	if (!send_update_to_fw)
-		return;
-
-	mutex_lock(&ioc->base_cmds.mutex);
-	_base_event_notification(ioc, CAN_SLEEP);
-	mutex_unlock(&ioc->base_cmds.mutex);
-}
-
-/**
- * _base_diag_reset - the "big hammer" start of day reset
- * @ioc: per adapter object
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_base_diag_reset(struct MPT2SAS_ADAPTER *ioc, int sleep_flag)
-{
-	u32 host_diagnostic;
-	u32 ioc_state;
-	u32 count;
-	u32 hcb_size;
-
-	printk(MPT2SAS_INFO_FMT "sending diag reset !!\n", ioc->name);
-	drsprintk(ioc, printk(MPT2SAS_INFO_FMT "clear interrupts\n",
-	    ioc->name));
-
-	count = 0;
-	do {
-		/* Write magic sequence to WriteSequence register
-		 * Loop until in diagnostic mode
-		 */
-		drsprintk(ioc, printk(MPT2SAS_INFO_FMT "write magic "
-		    "sequence\n", ioc->name));
-		writel(MPI2_WRSEQ_FLUSH_KEY_VALUE, &ioc->chip->WriteSequence);
-		writel(MPI2_WRSEQ_1ST_KEY_VALUE, &ioc->chip->WriteSequence);
-		writel(MPI2_WRSEQ_2ND_KEY_VALUE, &ioc->chip->WriteSequence);
-		writel(MPI2_WRSEQ_3RD_KEY_VALUE, &ioc->chip->WriteSequence);
-		writel(MPI2_WRSEQ_4TH_KEY_VALUE, &ioc->chip->WriteSequence);
-		writel(MPI2_WRSEQ_5TH_KEY_VALUE, &ioc->chip->WriteSequence);
-		writel(MPI2_WRSEQ_6TH_KEY_VALUE, &ioc->chip->WriteSequence);
-
-		/* wait 100 msec */
-		if (sleep_flag == CAN_SLEEP)
-			msleep(100);
-		else
-			mdelay(100);
-
-		if (count++ > 20)
-			goto out;
-
-		host_diagnostic = readl(&ioc->chip->HostDiagnostic);
-		drsprintk(ioc, printk(MPT2SAS_INFO_FMT "wrote magic "
-		    "sequence: count(%d), host_diagnostic(0x%08x)\n",
-		    ioc->name, count, host_diagnostic));
-
-	} while ((host_diagnostic & MPI2_DIAG_DIAG_WRITE_ENABLE) == 0);
-
-	hcb_size = readl(&ioc->chip->HCBSize);
-
-	drsprintk(ioc, printk(MPT2SAS_INFO_FMT "diag reset: issued\n",
-	    ioc->name));
-	writel(host_diagnostic | MPI2_DIAG_RESET_ADAPTER,
-	     &ioc->chip->HostDiagnostic);
-
-	/* This delay allows the chip PCIe hardware time to finish reset tasks*/
-	if (sleep_flag == CAN_SLEEP)
-		msleep(MPI2_HARD_RESET_PCIE_FIRST_READ_DELAY_MICRO_SEC/1000);
-	else
-		mdelay(MPI2_HARD_RESET_PCIE_FIRST_READ_DELAY_MICRO_SEC/1000);
-
-	/* Approximately 300 second max wait */
-	for (count = 0; count < (300000000 /
-	    MPI2_HARD_RESET_PCIE_SECOND_READ_DELAY_MICRO_SEC); count++) {
-
-		host_diagnostic = readl(&ioc->chip->HostDiagnostic);
-
-		if (host_diagnostic == 0xFFFFFFFF)
-			goto out;
-		if (!(host_diagnostic & MPI2_DIAG_RESET_ADAPTER))
-			break;
-
-		/* Wait to pass the second read delay window */
-		if (sleep_flag == CAN_SLEEP)
-			msleep(MPI2_HARD_RESET_PCIE_SECOND_READ_DELAY_MICRO_SEC
-			       /1000);
-		else
-			mdelay(MPI2_HARD_RESET_PCIE_SECOND_READ_DELAY_MICRO_SEC
-			       /1000);
-	}
-
-	if (host_diagnostic & MPI2_DIAG_HCB_MODE) {
-
-		drsprintk(ioc, printk(MPT2SAS_INFO_FMT "restart the adapter "
-		    "assuming the HCB Address points to good F/W\n",
-		    ioc->name));
-		host_diagnostic &= ~MPI2_DIAG_BOOT_DEVICE_SELECT_MASK;
-		host_diagnostic |= MPI2_DIAG_BOOT_DEVICE_SELECT_HCDW;
-		writel(host_diagnostic, &ioc->chip->HostDiagnostic);
-
-		drsprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "re-enable the HCDW\n", ioc->name));
-		writel(hcb_size | MPI2_HCB_SIZE_HCB_ENABLE,
-		    &ioc->chip->HCBSize);
-	}
-
-	drsprintk(ioc, printk(MPT2SAS_INFO_FMT "restart the adapter\n",
-	    ioc->name));
-	writel(host_diagnostic & ~MPI2_DIAG_HOLD_IOC_RESET,
-	    &ioc->chip->HostDiagnostic);
-
-	drsprintk(ioc, printk(MPT2SAS_INFO_FMT "disable writes to the "
-	    "diagnostic register\n", ioc->name));
-	writel(MPI2_WRSEQ_FLUSH_KEY_VALUE, &ioc->chip->WriteSequence);
-
-	drsprintk(ioc, printk(MPT2SAS_INFO_FMT "Wait for FW to go to the "
-	    "READY state\n", ioc->name));
-	ioc_state = _base_wait_on_iocstate(ioc, MPI2_IOC_STATE_READY, 20,
-	    sleep_flag);
-	if (ioc_state) {
-		printk(MPT2SAS_ERR_FMT "%s: failed going to ready state "
-		    " (ioc_state=0x%x)\n", ioc->name, __func__, ioc_state);
-		goto out;
-	}
-
-	printk(MPT2SAS_INFO_FMT "diag reset: SUCCESS\n", ioc->name);
-	return 0;
-
- out:
-	printk(MPT2SAS_ERR_FMT "diag reset: FAILED\n", ioc->name);
-	return -EFAULT;
-}
-
-/**
- * _base_make_ioc_ready - put controller in READY state
- * @ioc: per adapter object
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- * @type: FORCE_BIG_HAMMER or SOFT_RESET
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_base_make_ioc_ready(struct MPT2SAS_ADAPTER *ioc, int sleep_flag,
-    enum reset_type type)
-{
-	u32 ioc_state;
-	int rc;
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	if (ioc->pci_error_recovery)
-		return 0;
-
-	ioc_state = mpt2sas_base_get_iocstate(ioc, 0);
-	dhsprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: ioc_state(0x%08x)\n",
-	    ioc->name, __func__, ioc_state));
-
-	if ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_READY)
-		return 0;
-
-	if (ioc_state & MPI2_DOORBELL_USED) {
-		dhsprintk(ioc, printk(MPT2SAS_INFO_FMT "unexpected doorbell "
-		    "active!\n", ioc->name));
-		goto issue_diag_reset;
-	}
-
-	if ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {
-		mpt2sas_base_fault_info(ioc, ioc_state &
-		    MPI2_DOORBELL_DATA_MASK);
-		goto issue_diag_reset;
-	}
-
-	if (type == FORCE_BIG_HAMMER)
-		goto issue_diag_reset;
-
-	if ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_OPERATIONAL)
-		if (!(_base_send_ioc_reset(ioc,
-		    MPI2_FUNCTION_IOC_MESSAGE_UNIT_RESET, 15, CAN_SLEEP))) {
-			ioc->ioc_reset_count++;
-			return 0;
-	}
-
- issue_diag_reset:
-	rc = _base_diag_reset(ioc, CAN_SLEEP);
-	ioc->ioc_reset_count++;
-	return rc;
-}
-
-/**
- * _base_make_ioc_operational - put controller in OPERATIONAL state
- * @ioc: per adapter object
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_base_make_ioc_operational(struct MPT2SAS_ADAPTER *ioc, int sleep_flag)
-{
-	int r, i;
-	unsigned long	flags;
-	u32 reply_address;
-	u16 smid;
-	struct _tr_list *delayed_tr, *delayed_tr_next;
-	u8 hide_flag;
-	struct adapter_reply_queue *reply_q;
-	long reply_post_free;
-	u32 reply_post_free_sz, index = 0;
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	/* clean the delayed target reset list */
-	list_for_each_entry_safe(delayed_tr, delayed_tr_next,
-	    &ioc->delayed_tr_list, list) {
-		list_del(&delayed_tr->list);
-		kfree(delayed_tr);
-	}
-
-	list_for_each_entry_safe(delayed_tr, delayed_tr_next,
-	    &ioc->delayed_tr_volume_list, list) {
-		list_del(&delayed_tr->list);
-		kfree(delayed_tr);
-	}
-
-	/* initialize the scsi lookup free list */
-	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-	INIT_LIST_HEAD(&ioc->free_list);
-	smid = 1;
-	for (i = 0; i < ioc->scsiio_depth; i++, smid++) {
-		INIT_LIST_HEAD(&ioc->scsi_lookup[i].chain_list);
-		ioc->scsi_lookup[i].cb_idx = 0xFF;
-		ioc->scsi_lookup[i].smid = smid;
-		ioc->scsi_lookup[i].scmd = NULL;
-		ioc->scsi_lookup[i].direct_io = 0;
-		list_add_tail(&ioc->scsi_lookup[i].tracker_list,
-		    &ioc->free_list);
-	}
-
-	/* hi-priority queue */
-	INIT_LIST_HEAD(&ioc->hpr_free_list);
-	smid = ioc->hi_priority_smid;
-	for (i = 0; i < ioc->hi_priority_depth; i++, smid++) {
-		ioc->hpr_lookup[i].cb_idx = 0xFF;
-		ioc->hpr_lookup[i].smid = smid;
-		list_add_tail(&ioc->hpr_lookup[i].tracker_list,
-		    &ioc->hpr_free_list);
-	}
-
-	/* internal queue */
-	INIT_LIST_HEAD(&ioc->internal_free_list);
-	smid = ioc->internal_smid;
-	for (i = 0; i < ioc->internal_depth; i++, smid++) {
-		ioc->internal_lookup[i].cb_idx = 0xFF;
-		ioc->internal_lookup[i].smid = smid;
-		list_add_tail(&ioc->internal_lookup[i].tracker_list,
-		    &ioc->internal_free_list);
-	}
-
-	/* chain pool */
-	INIT_LIST_HEAD(&ioc->free_chain_list);
-	for (i = 0; i < ioc->chain_depth; i++)
-		list_add_tail(&ioc->chain_lookup[i].tracker_list,
-		    &ioc->free_chain_list);
-
-	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-
-	/* initialize Reply Free Queue */
-	for (i = 0, reply_address = (u32)ioc->reply_dma ;
-	    i < ioc->reply_free_queue_depth ; i++, reply_address +=
-	    ioc->reply_sz)
-		ioc->reply_free[i] = cpu_to_le32(reply_address);
-
-	/* initialize reply queues */
-	if (ioc->is_driver_loading)
-		_base_assign_reply_queues(ioc);
-
-	/* initialize Reply Post Free Queue */
-	reply_post_free_sz = ioc->reply_post_queue_depth *
-	    sizeof(Mpi2DefaultReplyDescriptor_t);
-	reply_post_free = (long)ioc->reply_post[index].reply_post_free;
-	list_for_each_entry(reply_q, &ioc->reply_queue_list, list) {
-		reply_q->reply_post_host_index = 0;
-		reply_q->reply_post_free = (Mpi2ReplyDescriptorsUnion_t *)
-		    reply_post_free;
-		for (i = 0; i < ioc->reply_post_queue_depth; i++)
-			reply_q->reply_post_free[i].Words =
-						     cpu_to_le64(ULLONG_MAX);
-		if (!_base_is_controller_msix_enabled(ioc))
-			goto skip_init_reply_post_free_queue;
-		/*
-		 * If RDPQ is enabled, switch to the next allocation.
-		 * Otherwise advance within the contiguous region.
-		 */
-		if (ioc->rdpq_array_enable)
-			reply_post_free = (long)
-			    ioc->reply_post[++index].reply_post_free;
-		else
-			reply_post_free += reply_post_free_sz;
-	}
- skip_init_reply_post_free_queue:
-
-	r = _base_send_ioc_init(ioc, sleep_flag);
-	if (r)
-		return r;
-
-	/* initialize reply free host index */
-	ioc->reply_free_host_index = ioc->reply_free_queue_depth - 1;
-	writel(ioc->reply_free_host_index, &ioc->chip->ReplyFreeHostIndex);
-
-	/* initialize reply post host index */
-	list_for_each_entry(reply_q, &ioc->reply_queue_list, list) {
-		writel(reply_q->msix_index << MPI2_RPHI_MSIX_INDEX_SHIFT,
-		    &ioc->chip->ReplyPostHostIndex);
-		if (!_base_is_controller_msix_enabled(ioc))
-			goto skip_init_reply_post_host_index;
-	}
-
- skip_init_reply_post_host_index:
-
-	_base_unmask_interrupts(ioc);
-
-	r = _base_event_notification(ioc, sleep_flag);
-	if (r)
-		return r;
-
-	if (sleep_flag == CAN_SLEEP)
-		_base_static_config_pages(ioc);
-
-
-	if (ioc->is_driver_loading) {
-		if (ioc->is_warpdrive && ioc->manu_pg10.OEMIdentifier
-		    == 0x80) {
-			hide_flag = (u8) (
-			    le32_to_cpu(ioc->manu_pg10.OEMSpecificFlags0) &
-			    MFG_PAGE10_HIDE_SSDS_MASK);
-			if (hide_flag != MFG_PAGE10_HIDE_SSDS_MASK)
-				ioc->mfg_pg10_hide_flag = hide_flag;
-		}
-		ioc->wait_for_discovery_to_complete =
-		    _base_determine_wait_on_discovery(ioc);
-		return r; /* scan_start and scan_finished support */
-	}
-	r = _base_send_port_enable(ioc, sleep_flag);
-	if (r)
-		return r;
-
-	return r;
-}
-
-/**
- * mpt2sas_base_free_resources - free resources controller resources (io/irq/memap)
- * @ioc: per adapter object
- *
- * Return nothing.
- */
-void
-mpt2sas_base_free_resources(struct MPT2SAS_ADAPTER *ioc)
-{
-	struct pci_dev *pdev = ioc->pdev;
-
-	dexitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	/* synchronizing freeing resource with pci_access_mutex lock */
-	mutex_lock(&ioc->pci_access_mutex);
-	if (ioc->chip_phys && ioc->chip) {
-		_base_mask_interrupts(ioc);
-		ioc->shost_recovery = 1;
-		_base_make_ioc_ready(ioc, CAN_SLEEP, SOFT_RESET);
-		ioc->shost_recovery = 0;
-	}
-
-	_base_free_irq(ioc);
-	_base_disable_msix(ioc);
-
-	if (ioc->chip_phys && ioc->chip)
-		iounmap(ioc->chip);
-	ioc->chip_phys = 0;
-
-	if (pci_is_enabled(pdev)) {
-		pci_release_selected_regions(ioc->pdev, ioc->bars);
-		pci_disable_pcie_error_reporting(pdev);
-		pci_disable_device(pdev);
-	}
-	mutex_unlock(&ioc->pci_access_mutex);
-	return;
-}
-
-/**
- * mpt2sas_base_attach - attach controller instance
- * @ioc: per adapter object
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_base_attach(struct MPT2SAS_ADAPTER *ioc)
-{
-	int r, i;
-	int cpu_id, last_cpu_id = 0;
-
-	dinitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	/* setup cpu_msix_table */
-	ioc->cpu_count = num_online_cpus();
-	for_each_online_cpu(cpu_id)
-		last_cpu_id = cpu_id;
-	ioc->cpu_msix_table_sz = last_cpu_id + 1;
-	ioc->cpu_msix_table = kzalloc(ioc->cpu_msix_table_sz, GFP_KERNEL);
-	ioc->reply_queue_count = 1;
-	if (!ioc->cpu_msix_table) {
-		dfailprintk(ioc, printk(MPT2SAS_INFO_FMT "allocation for "
-		    "cpu_msix_table failed!!!\n", ioc->name));
-		r = -ENOMEM;
-		goto out_free_resources;
-	}
-
-	if (ioc->is_warpdrive) {
-		ioc->reply_post_host_index = kcalloc(ioc->cpu_msix_table_sz,
-		    sizeof(resource_size_t *), GFP_KERNEL);
-		if (!ioc->reply_post_host_index) {
-			dfailprintk(ioc, printk(MPT2SAS_INFO_FMT "allocation "
-				"for cpu_msix_table failed!!!\n", ioc->name));
-			r = -ENOMEM;
-			goto out_free_resources;
-		}
-	}
-
-	ioc->rdpq_array_enable_assigned = 0;
-	ioc->dma_mask = 0;
-	r = mpt2sas_base_map_resources(ioc);
-	if (r)
-		goto out_free_resources;
-
-	if (ioc->is_warpdrive) {
-		ioc->reply_post_host_index[0] = (resource_size_t __iomem *)
-		    &ioc->chip->ReplyPostHostIndex;
-
-		for (i = 1; i < ioc->cpu_msix_table_sz; i++)
-			ioc->reply_post_host_index[i] =
-			(resource_size_t __iomem *)
-			((u8 __iomem *)&ioc->chip->Doorbell + (0x4000 + ((i - 1)
-			* 4)));
-	}
-
-	pci_set_drvdata(ioc->pdev, ioc->shost);
-	r = _base_get_ioc_facts(ioc, CAN_SLEEP);
-	if (r)
-		goto out_free_resources;
-
-	r = _base_make_ioc_ready(ioc, CAN_SLEEP, SOFT_RESET);
-	if (r)
-		goto out_free_resources;
-
-	ioc->pfacts = kcalloc(ioc->facts.NumberOfPorts,
-	    sizeof(struct mpt2sas_port_facts), GFP_KERNEL);
-	if (!ioc->pfacts) {
-		r = -ENOMEM;
-		goto out_free_resources;
-	}
-
-	for (i = 0 ; i < ioc->facts.NumberOfPorts; i++) {
-		r = _base_get_port_facts(ioc, i, CAN_SLEEP);
-		if (r)
-			goto out_free_resources;
-	}
-
-	r = _base_allocate_memory_pools(ioc, CAN_SLEEP);
-	if (r)
-		goto out_free_resources;
-
-	init_waitqueue_head(&ioc->reset_wq);
-	/* allocate memory pd handle bitmask list */
-	ioc->pd_handles_sz = (ioc->facts.MaxDevHandle / 8);
-	if (ioc->facts.MaxDevHandle % 8)
-		ioc->pd_handles_sz++;
-	ioc->pd_handles = kzalloc(ioc->pd_handles_sz,
-	    GFP_KERNEL);
-	if (!ioc->pd_handles) {
-		r = -ENOMEM;
-		goto out_free_resources;
-	}
-	ioc->blocking_handles = kzalloc(ioc->pd_handles_sz,
-	    GFP_KERNEL);
-	if (!ioc->blocking_handles) {
-		r = -ENOMEM;
-		goto out_free_resources;
-	}
-	ioc->fwfault_debug = mpt2sas_fwfault_debug;
-
-	/* base internal command bits */
-	mutex_init(&ioc->base_cmds.mutex);
-	ioc->base_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);
-	ioc->base_cmds.status = MPT2_CMD_NOT_USED;
-
-	/* port_enable command bits */
-	ioc->port_enable_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);
-	ioc->port_enable_cmds.status = MPT2_CMD_NOT_USED;
-
-	/* transport internal command bits */
-	ioc->transport_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);
-	ioc->transport_cmds.status = MPT2_CMD_NOT_USED;
-	mutex_init(&ioc->transport_cmds.mutex);
-
-	/* scsih internal command bits */
-	ioc->scsih_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);
-	ioc->scsih_cmds.status = MPT2_CMD_NOT_USED;
-	mutex_init(&ioc->scsih_cmds.mutex);
-
-	/* task management internal command bits */
-	ioc->tm_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);
-	ioc->tm_cmds.status = MPT2_CMD_NOT_USED;
-	mutex_init(&ioc->tm_cmds.mutex);
-
-	/* config page internal command bits */
-	ioc->config_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);
-	ioc->config_cmds.status = MPT2_CMD_NOT_USED;
-	mutex_init(&ioc->config_cmds.mutex);
-
-	/* ctl module internal command bits */
-	ioc->ctl_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);
-	ioc->ctl_cmds.sense = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_KERNEL);
-	ioc->ctl_cmds.status = MPT2_CMD_NOT_USED;
-	mutex_init(&ioc->ctl_cmds.mutex);
-
-	if (!ioc->base_cmds.reply || !ioc->transport_cmds.reply ||
-	    !ioc->scsih_cmds.reply || !ioc->tm_cmds.reply ||
-	    !ioc->config_cmds.reply || !ioc->ctl_cmds.reply ||
-	    !ioc->ctl_cmds.sense) {
-		r = -ENOMEM;
-		goto out_free_resources;
-	}
-
-	if (!ioc->base_cmds.reply || !ioc->transport_cmds.reply ||
-	    !ioc->scsih_cmds.reply || !ioc->tm_cmds.reply ||
-	    !ioc->config_cmds.reply || !ioc->ctl_cmds.reply) {
-		r = -ENOMEM;
-		goto out_free_resources;
-	}
-
-	for (i = 0; i < MPI2_EVENT_NOTIFY_EVENTMASK_WORDS; i++)
-		ioc->event_masks[i] = -1;
-
-	/* here we enable the events we care about */
-	_base_unmask_events(ioc, MPI2_EVENT_SAS_DISCOVERY);
-	_base_unmask_events(ioc, MPI2_EVENT_SAS_BROADCAST_PRIMITIVE);
-	_base_unmask_events(ioc, MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST);
-	_base_unmask_events(ioc, MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE);
-	_base_unmask_events(ioc, MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE);
-	_base_unmask_events(ioc, MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST);
-	_base_unmask_events(ioc, MPI2_EVENT_IR_VOLUME);
-	_base_unmask_events(ioc, MPI2_EVENT_IR_PHYSICAL_DISK);
-	_base_unmask_events(ioc, MPI2_EVENT_IR_OPERATION_STATUS);
-	_base_unmask_events(ioc, MPI2_EVENT_LOG_ENTRY_ADDED);
-	_base_unmask_events(ioc, MPI2_EVENT_TEMP_THRESHOLD);
-	r = _base_make_ioc_operational(ioc, CAN_SLEEP);
-	if (r)
-		goto out_free_resources;
-
-	ioc->non_operational_loop = 0;
-
-	return 0;
-
- out_free_resources:
-
-	ioc->remove_host = 1;
-	mpt2sas_base_free_resources(ioc);
-	_base_release_memory_pools(ioc);
-	pci_set_drvdata(ioc->pdev, NULL);
-	kfree(ioc->cpu_msix_table);
-	if (ioc->is_warpdrive)
-		kfree(ioc->reply_post_host_index);
-	kfree(ioc->pd_handles);
-	kfree(ioc->blocking_handles);
-	kfree(ioc->tm_cmds.reply);
-	kfree(ioc->transport_cmds.reply);
-	kfree(ioc->scsih_cmds.reply);
-	kfree(ioc->config_cmds.reply);
-	kfree(ioc->base_cmds.reply);
-	kfree(ioc->port_enable_cmds.reply);
-	kfree(ioc->ctl_cmds.reply);
-	kfree(ioc->ctl_cmds.sense);
-	kfree(ioc->pfacts);
-	ioc->ctl_cmds.reply = NULL;
-	ioc->base_cmds.reply = NULL;
-	ioc->tm_cmds.reply = NULL;
-	ioc->scsih_cmds.reply = NULL;
-	ioc->transport_cmds.reply = NULL;
-	ioc->config_cmds.reply = NULL;
-	ioc->pfacts = NULL;
-	return r;
-}
-
-
-/**
- * mpt2sas_base_detach - remove controller instance
- * @ioc: per adapter object
- *
- * Return nothing.
- */
-void
-mpt2sas_base_detach(struct MPT2SAS_ADAPTER *ioc)
-{
-
-	dexitprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	mpt2sas_base_stop_watchdog(ioc);
-	mpt2sas_base_free_resources(ioc);
-	_base_release_memory_pools(ioc);
-	pci_set_drvdata(ioc->pdev, NULL);
-	kfree(ioc->cpu_msix_table);
-	if (ioc->is_warpdrive)
-		kfree(ioc->reply_post_host_index);
-	kfree(ioc->pd_handles);
-	kfree(ioc->blocking_handles);
-	kfree(ioc->pfacts);
-	kfree(ioc->ctl_cmds.reply);
-	kfree(ioc->ctl_cmds.sense);
-	kfree(ioc->base_cmds.reply);
-	kfree(ioc->port_enable_cmds.reply);
-	kfree(ioc->tm_cmds.reply);
-	kfree(ioc->transport_cmds.reply);
-	kfree(ioc->scsih_cmds.reply);
-	kfree(ioc->config_cmds.reply);
-}
-
-/**
- * _base_reset_handler - reset callback handler (for base)
- * @ioc: per adapter object
- * @reset_phase: phase
- *
- * The handler for doing any required cleanup or initialization.
- *
- * The reset phase can be MPT2_IOC_PRE_RESET, MPT2_IOC_AFTER_RESET,
- * MPT2_IOC_DONE_RESET
- *
- * Return nothing.
- */
-static void
-_base_reset_handler(struct MPT2SAS_ADAPTER *ioc, int reset_phase)
-{
-	mpt2sas_scsih_reset_handler(ioc, reset_phase);
-	mpt2sas_ctl_reset_handler(ioc, reset_phase);
-	switch (reset_phase) {
-	case MPT2_IOC_PRE_RESET:
-		dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-		    "MPT2_IOC_PRE_RESET\n", ioc->name, __func__));
-		break;
-	case MPT2_IOC_AFTER_RESET:
-		dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-		    "MPT2_IOC_AFTER_RESET\n", ioc->name, __func__));
-		if (ioc->transport_cmds.status & MPT2_CMD_PENDING) {
-			ioc->transport_cmds.status |= MPT2_CMD_RESET;
-			mpt2sas_base_free_smid(ioc, ioc->transport_cmds.smid);
-			complete(&ioc->transport_cmds.done);
-		}
-		if (ioc->base_cmds.status & MPT2_CMD_PENDING) {
-			ioc->base_cmds.status |= MPT2_CMD_RESET;
-			mpt2sas_base_free_smid(ioc, ioc->base_cmds.smid);
-			complete(&ioc->base_cmds.done);
-		}
-		if (ioc->port_enable_cmds.status & MPT2_CMD_PENDING) {
-			ioc->port_enable_failed = 1;
-			ioc->port_enable_cmds.status |= MPT2_CMD_RESET;
-			mpt2sas_base_free_smid(ioc, ioc->port_enable_cmds.smid);
-			if (ioc->is_driver_loading) {
-				ioc->start_scan_failed =
-				    MPI2_IOCSTATUS_INTERNAL_ERROR;
-				ioc->start_scan = 0;
-				ioc->port_enable_cmds.status =
-						MPT2_CMD_NOT_USED;
-			} else
-				complete(&ioc->port_enable_cmds.done);
-
-		}
-		if (ioc->config_cmds.status & MPT2_CMD_PENDING) {
-			ioc->config_cmds.status |= MPT2_CMD_RESET;
-			mpt2sas_base_free_smid(ioc, ioc->config_cmds.smid);
-			ioc->config_cmds.smid = USHRT_MAX;
-			complete(&ioc->config_cmds.done);
-		}
-		break;
-	case MPT2_IOC_DONE_RESET:
-		dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-		    "MPT2_IOC_DONE_RESET\n", ioc->name, __func__));
-		break;
-	}
-}
-
-/**
- * _wait_for_commands_to_complete - reset controller
- * @ioc: Pointer to MPT_ADAPTER structure
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- *
- * This function waiting(3s) for all pending commands to complete
- * prior to putting controller in reset.
- */
-static void
-_wait_for_commands_to_complete(struct MPT2SAS_ADAPTER *ioc, int sleep_flag)
-{
-	u32 ioc_state;
-	unsigned long flags;
-	u16 i;
-
-	ioc->pending_io_count = 0;
-	if (sleep_flag != CAN_SLEEP)
-		return;
-
-	ioc_state = mpt2sas_base_get_iocstate(ioc, 0);
-	if ((ioc_state & MPI2_IOC_STATE_MASK) != MPI2_IOC_STATE_OPERATIONAL)
-		return;
-
-	/* pending command count */
-	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-	for (i = 0; i < ioc->scsiio_depth; i++)
-		if (ioc->scsi_lookup[i].cb_idx != 0xFF)
-			ioc->pending_io_count++;
-	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-
-	if (!ioc->pending_io_count)
-		return;
-
-	/* wait for pending commands to complete */
-	wait_event_timeout(ioc->reset_wq, ioc->pending_io_count == 0, 10 * HZ);
-}
-
-/**
- * mpt2sas_base_hard_reset_handler - reset controller
- * @ioc: Pointer to MPT_ADAPTER structure
- * @sleep_flag: CAN_SLEEP or NO_SLEEP
- * @type: FORCE_BIG_HAMMER or SOFT_RESET
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_base_hard_reset_handler(struct MPT2SAS_ADAPTER *ioc, int sleep_flag,
-    enum reset_type type)
-{
-	int r;
-	unsigned long flags;
-
-	dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: enter\n", ioc->name,
-	    __func__));
-
-	if (ioc->pci_error_recovery) {
-		printk(MPT2SAS_ERR_FMT "%s: pci error recovery reset\n",
-		    ioc->name, __func__);
-		r = 0;
-		goto out_unlocked;
-	}
-
-	if (mpt2sas_fwfault_debug)
-		mpt2sas_halt_firmware(ioc);
-
-	/* TODO - What we really should be doing is pulling
-	 * out all the code associated with NO_SLEEP; its never used.
-	 * That is legacy code from mpt fusion driver, ported over.
-	 * I will leave this BUG_ON here for now till its been resolved.
-	 */
-	BUG_ON(sleep_flag == NO_SLEEP);
-
-	/* wait for an active reset in progress to complete */
-	if (!mutex_trylock(&ioc->reset_in_progress_mutex)) {
-		do {
-			ssleep(1);
-		} while (ioc->shost_recovery == 1);
-		dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: exit\n", ioc->name,
-		    __func__));
-		return ioc->ioc_reset_in_progress_status;
-	}
-
-	spin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);
-	ioc->shost_recovery = 1;
-	spin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);
-
-	_base_reset_handler(ioc, MPT2_IOC_PRE_RESET);
-	_wait_for_commands_to_complete(ioc, sleep_flag);
-	_base_mask_interrupts(ioc);
-	r = _base_make_ioc_ready(ioc, sleep_flag, type);
-	if (r)
-		goto out;
-	_base_reset_handler(ioc, MPT2_IOC_AFTER_RESET);
-
-	/* If this hard reset is called while port enable is active, then
-	 * there is no reason to call make_ioc_operational
-	 */
-	if (ioc->is_driver_loading && ioc->port_enable_failed) {
-		ioc->remove_host = 1;
-		r = -EFAULT;
-		goto out;
-	}
-
-	r = _base_get_ioc_facts(ioc, CAN_SLEEP);
-	if (r)
-		goto out;
-
-	if (ioc->rdpq_array_enable && !ioc->rdpq_array_capable)
-		panic("%s: Issue occurred with flashing controller firmware."
-		      "Please reboot the system and ensure that the correct"
-		      " firmware version is running\n", ioc->name);
-
-	r = _base_make_ioc_operational(ioc, sleep_flag);
-	if (!r)
-		_base_reset_handler(ioc, MPT2_IOC_DONE_RESET);
- out:
-	dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: %s\n",
-	    ioc->name, __func__, ((r == 0) ? "SUCCESS" : "FAILED")));
-
-	spin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);
-	ioc->ioc_reset_in_progress_status = r;
-	ioc->shost_recovery = 0;
-	spin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);
-	mutex_unlock(&ioc->reset_in_progress_mutex);
-
- out_unlocked:
-	dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: exit\n", ioc->name,
-	    __func__));
-	return r;
-}
diff --git a/drivers/scsi/mpt2sas/mpt2sas_base.h b/drivers/scsi/mpt2sas/mpt2sas_base.h
deleted file mode 100644
index 6a23683c96f2..000000000000
--- a/drivers/scsi/mpt2sas/mpt2sas_base.h
+++ /dev/null
@@ -1,1215 +0,0 @@
-/*
- * This is the Fusion MPT base driver providing common API layer interface
- * for access to MPT (Message Passing Technology) firmware.
- *
- * This code is based on drivers/scsi/mpt2sas/mpt2_base.h
- * Copyright (C) 2007-2014  LSI Corporation
- * Copyright (C) 20013-2014 Avago Technologies
- *  (mailto: MPT-FusionLinux.pdl@avagotech.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * NO WARRANTY
- * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
- * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
- * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
- * solely responsible for determining the appropriateness of using and
- * distributing the Program and assumes all risks associated with its
- * exercise of rights under this Agreement, including but not limited to
- * the risks and costs of program errors, damage to or loss of data,
- * programs or equipment, and unavailability or interruption of operations.
-
- * DISCLAIMER OF LIABILITY
- * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
- * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
-
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
- * USA.
- */
-
-#ifndef MPT2SAS_BASE_H_INCLUDED
-#define MPT2SAS_BASE_H_INCLUDED
-
-#include "mpi/mpi2_type.h"
-#include "mpi/mpi2.h"
-#include "mpi/mpi2_ioc.h"
-#include "mpi/mpi2_cnfg.h"
-#include "mpi/mpi2_init.h"
-#include "mpi/mpi2_raid.h"
-#include "mpi/mpi2_tool.h"
-#include "mpi/mpi2_sas.h"
-
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_device.h>
-#include <scsi/scsi_host.h>
-#include <scsi/scsi_tcq.h>
-#include <scsi/scsi_transport_sas.h>
-#include <scsi/scsi_dbg.h>
-#include <scsi/scsi_eh.h>
-
-#include "mpt2sas_debug.h"
-
-/* driver versioning info */
-#define MPT2SAS_DRIVER_NAME		"mpt2sas"
-#define MPT2SAS_AUTHOR "Avago Technologies <MPT-FusionLinux.pdl@avagotech.com>"
-#define MPT2SAS_DESCRIPTION	"LSI MPT Fusion SAS 2.0 Device Driver"
-#define MPT2SAS_DRIVER_VERSION		"20.100.00.00"
-#define MPT2SAS_MAJOR_VERSION		20
-#define MPT2SAS_MINOR_VERSION		100
-#define MPT2SAS_BUILD_VERSION		00
-#define MPT2SAS_RELEASE_VERSION		00
-
-/*
- * Set MPT2SAS_SG_DEPTH value based on user input.
- */
-#ifdef CONFIG_SCSI_MPT2SAS_MAX_SGE
-#if     CONFIG_SCSI_MPT2SAS_MAX_SGE  < 16
-#define MPT2SAS_SG_DEPTH       16
-#elif CONFIG_SCSI_MPT2SAS_MAX_SGE  > 128
-#define MPT2SAS_SG_DEPTH       128
-#else
-#define MPT2SAS_SG_DEPTH       CONFIG_SCSI_MPT2SAS_MAX_SGE
-#endif
-#else
-#define MPT2SAS_SG_DEPTH       128 /* MAX_HW_SEGMENTS */
-#endif
-
-
-/*
- * Generic Defines
- */
-#define MPT2SAS_SATA_QUEUE_DEPTH	32
-#define MPT2SAS_SAS_QUEUE_DEPTH		254
-#define MPT2SAS_RAID_QUEUE_DEPTH	128
-
-#define MPT_NAME_LENGTH			32	/* generic length of strings */
-#define MPT_STRING_LENGTH		64
-
-#define MPT_MAX_CALLBACKS		16
-
-
-#define	 CAN_SLEEP			1
-#define  NO_SLEEP			0
-
-#define INTERNAL_CMDS_COUNT		10	/* reserved cmds */
-
-#define MPI2_HIM_MASK			0xFFFFFFFF /* mask every bit*/
-
-#define MPT2SAS_INVALID_DEVICE_HANDLE	0xFFFF
-
-
-/*
- * reset phases
- */
-#define MPT2_IOC_PRE_RESET		1 /* prior to host reset */
-#define MPT2_IOC_AFTER_RESET		2 /* just after host reset */
-#define MPT2_IOC_DONE_RESET		3 /* links re-initialized */
-
-/*
- * logging format
- */
-#define MPT2SAS_FMT			"%s: "
-#define MPT2SAS_INFO_FMT		KERN_INFO MPT2SAS_FMT
-#define MPT2SAS_NOTE_FMT		KERN_NOTICE MPT2SAS_FMT
-#define MPT2SAS_WARN_FMT		KERN_WARNING MPT2SAS_FMT
-#define MPT2SAS_ERR_FMT			KERN_ERR MPT2SAS_FMT
-
-/*
- * Dell HBA branding
- */
-#define MPT2SAS_DELL_BRANDING_SIZE                 32
-
-#define MPT2SAS_DELL_6GBPS_SAS_HBA_BRANDING        "Dell 6Gbps SAS HBA"
-#define MPT2SAS_DELL_PERC_H200_ADAPTER_BRANDING    "Dell PERC H200 Adapter"
-#define MPT2SAS_DELL_PERC_H200_INTEGRATED_BRANDING "Dell PERC H200 Integrated"
-#define MPT2SAS_DELL_PERC_H200_MODULAR_BRANDING    "Dell PERC H200 Modular"
-#define MPT2SAS_DELL_PERC_H200_EMBEDDED_BRANDING   "Dell PERC H200 Embedded"
-#define MPT2SAS_DELL_PERC_H200_BRANDING            "Dell PERC H200"
-#define MPT2SAS_DELL_6GBPS_SAS_BRANDING            "Dell 6Gbps SAS"
-
-/*
- * Dell HBA SSDIDs
- */
-#define MPT2SAS_DELL_6GBPS_SAS_HBA_SSDID           0x1F1C
-#define MPT2SAS_DELL_PERC_H200_ADAPTER_SSDID       0x1F1D
-#define MPT2SAS_DELL_PERC_H200_INTEGRATED_SSDID    0x1F1E
-#define MPT2SAS_DELL_PERC_H200_MODULAR_SSDID       0x1F1F
-#define MPT2SAS_DELL_PERC_H200_EMBEDDED_SSDID      0x1F20
-#define MPT2SAS_DELL_PERC_H200_SSDID               0x1F21
-#define MPT2SAS_DELL_6GBPS_SAS_SSDID               0x1F22
-
-/*
- * Intel HBA branding
- */
-#define MPT2SAS_INTEL_RMS25JB080_BRANDING    \
-				"Intel(R) Integrated RAID Module RMS25JB080"
-#define MPT2SAS_INTEL_RMS25JB040_BRANDING    \
-				"Intel(R) Integrated RAID Module RMS25JB040"
-#define MPT2SAS_INTEL_RMS25KB080_BRANDING    \
-				"Intel(R) Integrated RAID Module RMS25KB080"
-#define MPT2SAS_INTEL_RMS25KB040_BRANDING    \
-				"Intel(R) Integrated RAID Module RMS25KB040"
-#define MPT2SAS_INTEL_RMS25LB040_BRANDING	\
-				"Intel(R) Integrated RAID Module RMS25LB040"
-#define MPT2SAS_INTEL_RMS25LB080_BRANDING	\
-				"Intel(R) Integrated RAID Module RMS25LB080"
-#define MPT2SAS_INTEL_RMS2LL080_BRANDING	\
-				"Intel Integrated RAID Module RMS2LL080"
-#define MPT2SAS_INTEL_RMS2LL040_BRANDING	\
-				"Intel Integrated RAID Module RMS2LL040"
-#define MPT2SAS_INTEL_RS25GB008_BRANDING       \
-				"Intel(R) RAID Controller RS25GB008"
-#define MPT2SAS_INTEL_SSD910_BRANDING          \
-				"Intel(R) SSD 910 Series"
-/*
- * Intel HBA SSDIDs
- */
-#define MPT2SAS_INTEL_RMS25JB080_SSDID         0x3516
-#define MPT2SAS_INTEL_RMS25JB040_SSDID         0x3517
-#define MPT2SAS_INTEL_RMS25KB080_SSDID         0x3518
-#define MPT2SAS_INTEL_RMS25KB040_SSDID         0x3519
-#define MPT2SAS_INTEL_RMS25LB040_SSDID         0x351A
-#define MPT2SAS_INTEL_RMS25LB080_SSDID         0x351B
-#define MPT2SAS_INTEL_RMS2LL080_SSDID          0x350E
-#define MPT2SAS_INTEL_RMS2LL040_SSDID          0x350F
-#define MPT2SAS_INTEL_RS25GB008_SSDID          0x3000
-#define MPT2SAS_INTEL_SSD910_SSDID             0x3700
-
-/*
- * HP HBA branding
- */
-#define MPT2SAS_HP_3PAR_SSVID                0x1590
-#define MPT2SAS_HP_2_4_INTERNAL_BRANDING        "HP H220 Host Bus Adapter"
-#define MPT2SAS_HP_2_4_EXTERNAL_BRANDING        "HP H221 Host Bus Adapter"
-#define MPT2SAS_HP_1_4_INTERNAL_1_4_EXTERNAL_BRANDING "HP H222 Host Bus Adapter"
-#define MPT2SAS_HP_EMBEDDED_2_4_INTERNAL_BRANDING    "HP H220i Host Bus Adapter"
-#define MPT2SAS_HP_DAUGHTER_2_4_INTERNAL_BRANDING    "HP H210i Host Bus Adapter"
-
-/*
- * HO HBA SSDIDs
- */
-#define MPT2SAS_HP_2_4_INTERNAL_SSDID            0x0041
-#define MPT2SAS_HP_2_4_EXTERNAL_SSDID            0x0042
-#define MPT2SAS_HP_1_4_INTERNAL_1_4_EXTERNAL_SSDID    0x0043
-#define MPT2SAS_HP_EMBEDDED_2_4_INTERNAL_SSDID        0x0044
-#define MPT2SAS_HP_DAUGHTER_2_4_INTERNAL_SSDID        0x0046
-
-/*
- *  WarpDrive Specific Log codes
- */
-
-#define MPT2_WARPDRIVE_LOGENTRY		(0x8002)
-#define MPT2_WARPDRIVE_LC_SSDT		(0x41)
-#define MPT2_WARPDRIVE_LC_SSDLW		(0x43)
-#define MPT2_WARPDRIVE_LC_SSDLF		(0x44)
-#define MPT2_WARPDRIVE_LC_BRMF		(0x4D)
-
-/*
- * per target private data
- */
-#define MPT_TARGET_FLAGS_RAID_COMPONENT	0x01
-#define MPT_TARGET_FLAGS_VOLUME		0x02
-#define MPT_TARGET_FLAGS_DELETED	0x04
-
-/**
- * struct MPT2SAS_TARGET - starget private hostdata
- * @starget: starget object
- * @sas_address: target sas address
- * @raid_device: raid_device pointer to access volume data
- * @handle: device handle
- * @num_luns: number luns
- * @flags: MPT_TARGET_FLAGS_XXX flags
- * @deleted: target flaged for deletion
- * @tm_busy: target is busy with TM request.
- */
-struct MPT2SAS_TARGET {
-	struct scsi_target *starget;
-	u64	sas_address;
-	struct _raid_device *raid_device;
-	u16	handle;
-	int	num_luns;
-	u32	flags;
-	u8	deleted;
-	u8	tm_busy;
-};
-
-
-/*
- * per device private data
- */
-#define MPT_DEVICE_FLAGS_INIT		0x01
-#define MPT_DEVICE_TLR_ON		0x02
-
-/**
- * struct MPT2SAS_DEVICE - sdev private hostdata
- * @sas_target: starget private hostdata
- * @lun: lun number
- * @flags: MPT_DEVICE_XXX flags
- * @configured_lun: lun is configured
- * @block: device is in SDEV_BLOCK state
- * @tlr_snoop_check: flag used in determining whether to disable TLR
- */
-
-/* OEM Identifiers */
-#define MFG10_OEM_ID_INVALID                   (0x00000000)
-#define MFG10_OEM_ID_DELL                      (0x00000001)
-#define MFG10_OEM_ID_FSC                       (0x00000002)
-#define MFG10_OEM_ID_SUN                       (0x00000003)
-#define MFG10_OEM_ID_IBM                       (0x00000004)
-
-/* GENERIC Flags 0*/
-#define MFG10_GF0_OCE_DISABLED                 (0x00000001)
-#define MFG10_GF0_R1E_DRIVE_COUNT              (0x00000002)
-#define MFG10_GF0_R10_DISPLAY                  (0x00000004)
-#define MFG10_GF0_SSD_DATA_SCRUB_DISABLE       (0x00000008)
-#define MFG10_GF0_SINGLE_DRIVE_R0              (0x00000010)
-
-/* OEM Specific Flags will come from OEM specific header files */
-typedef struct _MPI2_CONFIG_PAGE_MAN_10 {
-    MPI2_CONFIG_PAGE_HEADER Header;                                 /* 00h */
-    U8                      OEMIdentifier;                          /* 04h */
-    U8                      Reserved1;                              /* 05h */
-    U16                     Reserved2;                              /* 08h */
-    U32                     Reserved3;                              /* 0Ch */
-    U32                     GenericFlags0;                          /* 10h */
-    U32                     GenericFlags1;                          /* 14h */
-    U32                     Reserved4;                              /* 18h */
-    U32                     OEMSpecificFlags0;                      /* 1Ch */
-    U32                     OEMSpecificFlags1;                      /* 20h */
-    U32                     Reserved5[18];                          /* 24h-60h*/
-} MPI2_CONFIG_PAGE_MAN_10,
-	*PTR_MPI2_CONFIG_PAGE_MAN_10,
-	Mpi2ManufacturingPage10_t, *pMpi2ManufacturingPage10_t;
-
-#define MFG_PAGE10_HIDE_SSDS_MASK	(0x00000003)
-#define MFG_PAGE10_HIDE_ALL_DISKS	(0x00)
-#define MFG_PAGE10_EXPOSE_ALL_DISKS	(0x01)
-#define MFG_PAGE10_HIDE_IF_VOL_PRESENT	(0x02)
-
-
-struct MPT2SAS_DEVICE {
-	struct MPT2SAS_TARGET *sas_target;
-	unsigned int	lun;
-	u32	flags;
-	u8	configured_lun;
-	u8	block;
-	u8	tlr_snoop_check;
-};
-
-#define MPT2_CMD_NOT_USED	0x8000	/* free */
-#define MPT2_CMD_COMPLETE	0x0001	/* completed */
-#define MPT2_CMD_PENDING	0x0002	/* pending */
-#define MPT2_CMD_REPLY_VALID	0x0004	/* reply is valid */
-#define MPT2_CMD_RESET		0x0008	/* host reset dropped the command */
-
-/**
- * struct _internal_cmd - internal commands struct
- * @mutex: mutex
- * @done: completion
- * @reply: reply message pointer
- * @sense: sense data
- * @status: MPT2_CMD_XXX status
- * @smid: system message id
- */
-struct _internal_cmd {
-	struct mutex mutex;
-	struct completion done;
-	void 	*reply;
-	void	*sense;
-	u16	status;
-	u16	smid;
-};
-
-
-/**
- * struct _sas_device - attached device information
- * @list: sas device list
- * @starget: starget object
- * @sas_address: device sas address
- * @device_name: retrieved from the SAS IDENTIFY frame.
- * @handle: device handle
- * @sas_address_parent: sas address of parent expander or sas host
- * @enclosure_handle: enclosure handle
- * @enclosure_logical_id: enclosure logical identifier
- * @volume_handle: volume handle (valid when hidden raid member)
- * @volume_wwid: volume unique identifier
- * @device_info: bitfield provides detailed info about the device
- * @id: target id
- * @channel: target channel
- * @slot: number number
- * @phy: phy identifier provided in sas device page 0
- * @responding: used in _scsih_sas_device_mark_responding
- * @pfa_led_on: flag for PFA LED status
- */
-struct _sas_device {
-	struct list_head list;
-	struct scsi_target *starget;
-	u64	sas_address;
-	u64	device_name;
-	u16	handle;
-	u64	sas_address_parent;
-	u16	enclosure_handle;
-	u64	enclosure_logical_id;
-	u16	volume_handle;
-	u64	volume_wwid;
-	u32	device_info;
-	int	id;
-	int	channel;
-	u16	slot;
-	u8	phy;
-	u8	responding;
-	u8	pfa_led_on;
-};
-
-/**
- * struct _raid_device - raid volume link list
- * @list: sas device list
- * @starget: starget object
- * @sdev: scsi device struct (volumes are single lun)
- * @wwid: unique identifier for the volume
- * @handle: device handle
- * @block_size: Block size of the volume
- * @id: target id
- * @channel: target channel
- * @volume_type: the raid level
- * @device_info: bitfield provides detailed info about the hidden components
- * @num_pds: number of hidden raid components
- * @responding: used in _scsih_raid_device_mark_responding
- * @percent_complete: resync percent complete
- * @direct_io_enabled: Whether direct io to PDs are allowed or not
- * @stripe_exponent: X where 2powX is the stripe sz in blocks
- * @block_exponent: X where 2powX is the block sz in bytes
- * @max_lba: Maximum number of LBA in the volume
- * @stripe_sz: Stripe Size of the volume
- * @device_info: Device info of the volume member disk
- * @pd_handle: Array of handles of the physical drives for direct I/O in le16
- */
-#define MPT_MAX_WARPDRIVE_PDS		8
-struct _raid_device {
-	struct list_head list;
-	struct scsi_target *starget;
-	struct scsi_device *sdev;
-	u64	wwid;
-	u16	handle;
-	u16	block_sz;
-	int	id;
-	int	channel;
-	u8	volume_type;
-	u8	num_pds;
-	u8	responding;
-	u8	percent_complete;
-	u8	direct_io_enabled;
-	u8	stripe_exponent;
-	u8	block_exponent;
-	u64	max_lba;
-	u32	stripe_sz;
-	u32	device_info;
-	u16	pd_handle[MPT_MAX_WARPDRIVE_PDS];
-};
-
-/**
- * struct _boot_device - boot device info
- * @is_raid: flag to indicate whether this is volume
- * @device: holds pointer for either struct _sas_device or
- *     struct _raid_device
- */
-struct _boot_device {
-	u8 is_raid;
-	void *device;
-};
-
-/**
- * struct _sas_port - wide/narrow sas port information
- * @port_list: list of ports belonging to expander
- * @num_phys: number of phys belonging to this port
- * @remote_identify: attached device identification
- * @rphy: sas transport rphy object
- * @port: sas transport wide/narrow port object
- * @phy_list: _sas_phy list objects belonging to this port
- */
-struct _sas_port {
-	struct list_head port_list;
-	u8	num_phys;
-	struct sas_identify remote_identify;
-	struct sas_rphy *rphy;
-	struct sas_port *port;
-	struct list_head phy_list;
-};
-
-/**
- * struct _sas_phy - phy information
- * @port_siblings: list of phys belonging to a port
- * @identify: phy identification
- * @remote_identify: attached device identification
- * @phy: sas transport phy object
- * @phy_id: unique phy id
- * @handle: device handle for this phy
- * @attached_handle: device handle for attached device
- * @phy_belongs_to_port: port has been created for this phy
- */
-struct _sas_phy {
-	struct list_head port_siblings;
-	struct sas_identify identify;
-	struct sas_identify remote_identify;
-	struct sas_phy *phy;
-	u8	phy_id;
-	u16	handle;
-	u16	attached_handle;
-	u8	phy_belongs_to_port;
-};
-
-/**
- * struct _sas_node - sas_host/expander information
- * @list: list of expanders
- * @parent_dev: parent device class
- * @num_phys: number phys belonging to this sas_host/expander
- * @sas_address: sas address of this sas_host/expander
- * @handle: handle for this sas_host/expander
- * @sas_address_parent: sas address of parent expander or sas host
- * @enclosure_handle: handle for this a member of an enclosure
- * @device_info: bitwise defining capabilities of this sas_host/expander
- * @responding: used in _scsih_expander_device_mark_responding
- * @phy: a list of phys that make up this sas_host/expander
- * @sas_port_list: list of ports attached to this sas_host/expander
- */
-struct _sas_node {
-	struct list_head list;
-	struct device *parent_dev;
-	u8	num_phys;
-	u64	sas_address;
-	u16	handle;
-	u64	sas_address_parent;
-	u16	enclosure_handle;
-	u64	enclosure_logical_id;
-	u8	responding;
-	struct	_sas_phy *phy;
-	struct list_head sas_port_list;
-};
-
-/**
- * enum reset_type - reset state
- * @FORCE_BIG_HAMMER: issue diagnostic reset
- * @SOFT_RESET: issue message_unit_reset, if fails to to big hammer
- */
-enum reset_type {
-	FORCE_BIG_HAMMER,
-	SOFT_RESET,
-};
-
-/**
- * struct chain_tracker - firmware chain tracker
- * @chain_buffer: chain buffer
- * @chain_buffer_dma: physical address
- * @tracker_list: list of free request (ioc->free_chain_list)
- */
-struct chain_tracker {
-	void *chain_buffer;
-	dma_addr_t chain_buffer_dma;
-	struct list_head tracker_list;
-};
-
-/**
- * struct scsiio_tracker - scsi mf request tracker
- * @smid: system message id
- * @scmd: scsi request pointer
- * @cb_idx: callback index
- * @direct_io: To indicate whether I/O is direct (WARPDRIVE)
- * @chain_list: list of chains associated to this IO
- * @tracker_list: list of free request (ioc->free_list)
- */
-struct scsiio_tracker {
-	u16	smid;
-	struct scsi_cmnd *scmd;
-	u8	cb_idx;
-	u8	direct_io;
-	struct list_head chain_list;
-	struct list_head tracker_list;
-};
-
-/**
- * struct request_tracker - firmware request tracker
- * @smid: system message id
- * @cb_idx: callback index
- * @tracker_list: list of free request (ioc->free_list)
- */
-struct request_tracker {
-	u16	smid;
-	u8	cb_idx;
-	struct list_head tracker_list;
-};
-
-/**
- * struct _tr_list - target reset list
- * @handle: device handle
- * @state: state machine
- */
-struct _tr_list {
-	struct list_head list;
-	u16	handle;
-	u16	state;
-};
-
-typedef void (*MPT_ADD_SGE)(void *paddr, u32 flags_length, dma_addr_t dma_addr);
-
-/**
- * struct adapter_reply_queue - the reply queue struct
- * @ioc: per adapter object
- * @msix_index: msix index into vector table
- * @vector: irq vector
- * @reply_post_host_index: head index in the pool where FW completes IO
- * @reply_post_free: reply post base virt address
- * @name: the name registered to request_irq()
- * @busy: isr is actively processing replies on another cpu
- * @list: this list
-*/
-struct adapter_reply_queue {
-	struct MPT2SAS_ADAPTER	*ioc;
-	u8			msix_index;
-	unsigned int		vector;
-	u32			reply_post_host_index;
-	Mpi2ReplyDescriptorsUnion_t *reply_post_free;
-	char			name[MPT_NAME_LENGTH];
-	atomic_t		busy;
-	cpumask_var_t		affinity_hint;
-	struct list_head	list;
-};
-
-/* IOC Facts and Port Facts converted from little endian to cpu */
-union mpi2_version_union {
-	MPI2_VERSION_STRUCT		Struct;
-	u32				Word;
-};
-
-struct mpt2sas_facts {
-	u16			MsgVersion;
-	u16			HeaderVersion;
-	u8			IOCNumber;
-	u8			VP_ID;
-	u8			VF_ID;
-	u16			IOCExceptions;
-	u16			IOCStatus;
-	u32			IOCLogInfo;
-	u8			MaxChainDepth;
-	u8			WhoInit;
-	u8			NumberOfPorts;
-	u8			MaxMSIxVectors;
-	u16			RequestCredit;
-	u16			ProductID;
-	u32			IOCCapabilities;
-	union mpi2_version_union	FWVersion;
-	u16			IOCRequestFrameSize;
-	u16			Reserved3;
-	u16			MaxInitiators;
-	u16			MaxTargets;
-	u16			MaxSasExpanders;
-	u16			MaxEnclosures;
-	u16			ProtocolFlags;
-	u16			HighPriorityCredit;
-	u16			MaxReplyDescriptorPostQueueDepth;
-	u8			ReplyFrameSize;
-	u8			MaxVolumes;
-	u16			MaxDevHandle;
-	u16			MaxPersistentEntries;
-	u16			MinDevHandle;
-};
-
-struct mpt2sas_port_facts {
-	u8			PortNumber;
-	u8			VP_ID;
-	u8			VF_ID;
-	u8			PortType;
-	u16			MaxPostedCmdBuffers;
-};
-
-struct reply_post_struct {
-	Mpi2ReplyDescriptorsUnion_t	*reply_post_free;
-	dma_addr_t			reply_post_free_dma;
-};
-
-/**
- * enum mutex_type - task management mutex type
- * @TM_MUTEX_OFF: mutex is not required becuase calling function is acquiring it
- * @TM_MUTEX_ON: mutex is required
- */
-enum mutex_type {
-	TM_MUTEX_OFF = 0,
-	TM_MUTEX_ON = 1,
-};
-
-typedef void (*MPT2SAS_FLUSH_RUNNING_CMDS)(struct MPT2SAS_ADAPTER *ioc);
-/**
- * struct MPT2SAS_ADAPTER - per adapter struct
- * @list: ioc_list
- * @shost: shost object
- * @id: unique adapter id
- * @cpu_count: number online cpus
- * @name: generic ioc string
- * @tmp_string: tmp string used for logging
- * @pdev: pci pdev object
- * @chip: memory mapped register space
- * @chip_phys: physical addrss prior to mapping
- * @logging_level: see mpt2sas_debug.h
- * @fwfault_debug: debuging FW timeouts
- * @ir_firmware: IR firmware present
- * @bars: bitmask of BAR's that must be configured
- * @mask_interrupts: ignore interrupt
- * @dma_mask: used to set the consistent dma mask
- * @fault_reset_work_q_name: fw fault work queue
- * @fault_reset_work_q: ""
- * @fault_reset_work: ""
- * @firmware_event_name: fw event work queue
- * @firmware_event_thread: ""
- * @fw_events_off: flag to turn off fw event handling
- * @fw_event_lock:
- * @fw_event_list: list of fw events
- * @aen_event_read_flag: event log was read
- * @broadcast_aen_busy: broadcast aen waiting to be serviced
- * @shost_recovery: host reset in progress
- * @ioc_reset_in_progress_lock:
- * @ioc_link_reset_in_progress: phy/hard reset in progress
- * @ignore_loginfos: ignore loginfos during task management
- * @remove_host: flag for when driver unloads, to avoid sending dev resets
- * @pci_error_recovery: flag to prevent ioc access until slot reset completes
- * @wait_for_discovery_to_complete: flag set at driver load time when
- *                                               waiting on reporting devices
- * @is_driver_loading: flag set at driver load time
- * @port_enable_failed: flag set when port enable has failed
- * @start_scan: flag set from scan_start callback, cleared from _mpt2sas_fw_work
- * @start_scan_failed: means port enable failed, return's the ioc_status
- * @msix_enable: flag indicating msix is enabled
- * @msix_vector_count: number msix vectors
- * @cpu_msix_table: table for mapping cpus to msix index
- * @cpu_msix_table_sz: table size
- * @schedule_dead_ioc_flush_running_cmds: callback to flush pending commands
- * @scsi_io_cb_idx: shost generated commands
- * @tm_cb_idx: task management commands
- * @scsih_cb_idx: scsih internal commands
- * @transport_cb_idx: transport internal commands
- * @ctl_cb_idx: clt internal commands
- * @base_cb_idx: base internal commands
- * @config_cb_idx: base internal commands
- * @tm_tr_cb_idx : device removal target reset handshake
- * @tm_tr_volume_cb_idx : volume removal target reset
- * @base_cmds:
- * @transport_cmds:
- * @scsih_cmds:
- * @tm_cmds:
- * @ctl_cmds:
- * @config_cmds:
- * @base_add_sg_single: handler for either 32/64 bit sgl's
- * @event_type: bits indicating which events to log
- * @event_context: unique id for each logged event
- * @event_log: event log pointer
- * @event_masks: events that are masked
- * @facts: static facts data
- * @pfacts: static port facts data
- * @manu_pg0: static manufacturing page 0
- * @manu_pg10: static manufacturing page 10
- * @bios_pg2: static bios page 2
- * @bios_pg3: static bios page 3
- * @ioc_pg8: static ioc page 8
- * @iounit_pg0: static iounit page 0
- * @iounit_pg1: static iounit page 1
- * @iounit_pg8: static iounit page 8
- * @sas_hba: sas host object
- * @sas_expander_list: expander object list
- * @sas_node_lock:
- * @sas_device_list: sas device object list
- * @sas_device_init_list: sas device object list (used only at init time)
- * @sas_device_lock:
- * @io_missing_delay: time for IO completed by fw when PDR enabled
- * @device_missing_delay: time for device missing by fw when PDR enabled
- * @sas_id : used for setting volume target IDs
- * @blocking_handles: bitmask used to identify which devices need blocking
- * @pd_handles : bitmask for PD handles
- * @pd_handles_sz : size of pd_handle bitmask
- * @config_page_sz: config page size
- * @config_page: reserve memory for config page payload
- * @config_page_dma:
- * @hba_queue_depth: hba request queue depth
- * @sge_size: sg element size for either 32/64 bit
- * @scsiio_depth: SCSI_IO queue depth
- * @request_sz: per request frame size
- * @request: pool of request frames
- * @request_dma:
- * @request_dma_sz:
- * @scsi_lookup: firmware request tracker list
- * @scsi_lookup_lock:
- * @free_list: free list of request
- * @chain: pool of chains
- * @pending_io_count:
- * @reset_wq:
- * @chain_dma:
- * @max_sges_in_main_message: number sg elements in main message
- * @max_sges_in_chain_message: number sg elements per chain
- * @chains_needed_per_io: max chains per io
- * @chain_offset_value_for_main_message: location 1st sg in main
- * @chain_depth: total chains allocated
- * @hi_priority_smid:
- * @hi_priority:
- * @hi_priority_dma:
- * @hi_priority_depth:
- * @hpr_lookup:
- * @hpr_free_list:
- * @internal_smid:
- * @internal:
- * @internal_dma:
- * @internal_depth:
- * @internal_lookup:
- * @internal_free_list:
- * @sense: pool of sense
- * @sense_dma:
- * @sense_dma_pool:
- * @reply_depth: hba reply queue depth:
- * @reply_sz: per reply frame size:
- * @reply: pool of replys:
- * @reply_dma:
- * @reply_dma_pool:
- * @reply_free_queue_depth: reply free depth
- * @reply_free: pool for reply free queue (32 bit addr)
- * @reply_free_dma:
- * @reply_free_dma_pool:
- * @reply_free_host_index: tail index in pool to insert free replys
- * @reply_post_queue_depth: reply post queue depth
- * @reply_post_struct: struct for reply_post_free physical & virt address
- * @rdpq_array_capable: FW supports multiple reply queue addresses in ioc_init
- * @rdpq_array_enable: rdpq_array support is enabled in the driver
- * @rdpq_array_enable_assigned: this ensures that rdpq_array_enable flag
- *				is assigned only ones
- * @reply_queue_count: number of reply queue's
- * @reply_queue_list: link list contaning the reply queue info
- * @reply_post_host_index: head index in the pool where FW completes IO
- * @delayed_tr_list: target reset link list
- * @delayed_tr_volume_list: volume target reset link list
- * @@temp_sensors_count: flag to carry the number of temperature sensors
- * @pci_access_mutex: Mutex to synchronize ioctl,sysfs show path and
- * pci resource handling. PCI resource freeing will lead to free
- * vital hardware/memory resource, which might be in use by cli/sysfs
- * path functions resulting in Null pointer reference followed by kernel
- * crash. To avoid the above race condition we use mutex syncrhonization
- * which ensures the syncrhonization between cli/sysfs_show path
- */
-struct MPT2SAS_ADAPTER {
-	struct list_head list;
-	struct Scsi_Host *shost;
-	u8		id;
-	int		cpu_count;
-	char		name[MPT_NAME_LENGTH];
-	char		tmp_string[MPT_STRING_LENGTH];
-	struct pci_dev	*pdev;
-	Mpi2SystemInterfaceRegs_t __iomem *chip;
-	resource_size_t	chip_phys;
-	int		logging_level;
-	int		fwfault_debug;
-	u8		ir_firmware;
-	int		bars;
-	u8		mask_interrupts;
-	int		dma_mask;
-
-	/* fw fault handler */
-	char		fault_reset_work_q_name[20];
-	struct workqueue_struct *fault_reset_work_q;
-	struct delayed_work fault_reset_work;
-
-	/* fw event handler */
-	char		firmware_event_name[20];
-	struct workqueue_struct	*firmware_event_thread;
-	spinlock_t	fw_event_lock;
-	struct list_head fw_event_list;
-
-	 /* misc flags */
-	int		aen_event_read_flag;
-	u8		broadcast_aen_busy;
-	u16		broadcast_aen_pending;
-	u8		shost_recovery;
-
-	struct mutex	reset_in_progress_mutex;
-	spinlock_t 	ioc_reset_in_progress_lock;
-	u8		ioc_link_reset_in_progress;
-	u8		ioc_reset_in_progress_status;
-
-	u8		ignore_loginfos;
-	u8		remove_host;
-	u8		pci_error_recovery;
-	u8		wait_for_discovery_to_complete;
-	struct completion	port_enable_done;
-	u8		is_driver_loading;
-	u8		port_enable_failed;
-
-	u8		start_scan;
-	u16		start_scan_failed;
-
-	u8		msix_enable;
-	u16		msix_vector_count;
-	u8		*cpu_msix_table;
-	resource_size_t	__iomem **reply_post_host_index;
-	u16		cpu_msix_table_sz;
-	u32		ioc_reset_count;
-	MPT2SAS_FLUSH_RUNNING_CMDS schedule_dead_ioc_flush_running_cmds;
-	u32             non_operational_loop;
-
-	/* internal commands, callback index */
-	u8		scsi_io_cb_idx;
-	u8		tm_cb_idx;
-	u8		transport_cb_idx;
-	u8		scsih_cb_idx;
-	u8		ctl_cb_idx;
-	u8		base_cb_idx;
-	u8		port_enable_cb_idx;
-	u8		config_cb_idx;
-	u8		tm_tr_cb_idx;
-	u8		tm_tr_volume_cb_idx;
-	u8		tm_sas_control_cb_idx;
-	struct _internal_cmd base_cmds;
-	struct _internal_cmd port_enable_cmds;
-	struct _internal_cmd transport_cmds;
-	struct _internal_cmd scsih_cmds;
-	struct _internal_cmd tm_cmds;
-	struct _internal_cmd ctl_cmds;
-	struct _internal_cmd config_cmds;
-
-	MPT_ADD_SGE	base_add_sg_single;
-
-	/* event log */
-	u32		event_type[MPI2_EVENT_NOTIFY_EVENTMASK_WORDS];
-	u32		event_context;
-	void		*event_log;
-	u32		event_masks[MPI2_EVENT_NOTIFY_EVENTMASK_WORDS];
-
-	/* static config pages */
-	struct mpt2sas_facts facts;
-	struct mpt2sas_port_facts *pfacts;
-	Mpi2ManufacturingPage0_t manu_pg0;
-	Mpi2BiosPage2_t	bios_pg2;
-	Mpi2BiosPage3_t	bios_pg3;
-	Mpi2IOCPage8_t ioc_pg8;
-	Mpi2IOUnitPage0_t iounit_pg0;
-	Mpi2IOUnitPage1_t iounit_pg1;
-	Mpi2IOUnitPage8_t iounit_pg8;
-
-	struct _boot_device req_boot_device;
-	struct _boot_device req_alt_boot_device;
-	struct _boot_device current_boot_device;
-
-	/* sas hba, expander, and device list */
-	struct _sas_node sas_hba;
-	struct list_head sas_expander_list;
-	spinlock_t	sas_node_lock;
-	struct list_head sas_device_list;
-	struct list_head sas_device_init_list;
-	spinlock_t	sas_device_lock;
-	struct list_head raid_device_list;
-	spinlock_t	raid_device_lock;
-	u8		io_missing_delay;
-	u16		device_missing_delay;
-	int		sas_id;
-	void		*blocking_handles;
-	void		*pd_handles;
-	u16		pd_handles_sz;
-
-	/* config page */
-	u16		config_page_sz;
-	void 		*config_page;
-	dma_addr_t	config_page_dma;
-
-	/* scsiio request */
-	u16		hba_queue_depth;
-	u16		sge_size;
-	u16 		scsiio_depth;
-	u16		request_sz;
-	u8		*request;
-	dma_addr_t	request_dma;
-	u32		request_dma_sz;
-	struct scsiio_tracker *scsi_lookup;
-	ulong		scsi_lookup_pages;
-	spinlock_t 	scsi_lookup_lock;
-	struct list_head free_list;
-	int		pending_io_count;
-	wait_queue_head_t reset_wq;
-
-	/* chain */
-	struct chain_tracker *chain_lookup;
-	struct list_head free_chain_list;
-	struct dma_pool *chain_dma_pool;
-	ulong		chain_pages;
-	u16 		max_sges_in_main_message;
-	u16		max_sges_in_chain_message;
-	u16		chains_needed_per_io;
-	u16		chain_offset_value_for_main_message;
-	u32		chain_depth;
-
-	/* hi-priority queue */
-	u16		hi_priority_smid;
-	u8		*hi_priority;
-	dma_addr_t	hi_priority_dma;
-	u16		hi_priority_depth;
-	struct request_tracker *hpr_lookup;
-	struct list_head hpr_free_list;
-
-	/* internal queue */
-	u16		internal_smid;
-	u8		*internal;
-	dma_addr_t	internal_dma;
-	u16		internal_depth;
-	struct request_tracker *internal_lookup;
-	struct list_head internal_free_list;
-
-	/* sense */
-	u8		*sense;
-	dma_addr_t	sense_dma;
-	struct dma_pool *sense_dma_pool;
-
-	/* reply */
-	u16		reply_sz;
-	u8		*reply;
-	dma_addr_t	reply_dma;
-	u32		reply_dma_max_address;
-	u32		reply_dma_min_address;
-	struct dma_pool *reply_dma_pool;
-
-	/* reply free queue */
-	u16 		reply_free_queue_depth;
-	__le32		*reply_free;
-	dma_addr_t	reply_free_dma;
-	struct dma_pool *reply_free_dma_pool;
-	u32		reply_free_host_index;
-
-	/* reply post queue */
-	u16 		reply_post_queue_depth;
-	struct reply_post_struct *reply_post;
-	u8		rdpq_array_capable;
-	u8		rdpq_array_enable;
-	u8		rdpq_array_enable_assigned;
-	struct dma_pool *reply_post_free_dma_pool;
-	u8		reply_queue_count;
-	struct list_head reply_queue_list;
-
-	struct list_head delayed_tr_list;
-	struct list_head delayed_tr_volume_list;
-	u8		temp_sensors_count;
-
-	/* diag buffer support */
-	u8		*diag_buffer[MPI2_DIAG_BUF_TYPE_COUNT];
-	u32		diag_buffer_sz[MPI2_DIAG_BUF_TYPE_COUNT];
-	dma_addr_t	diag_buffer_dma[MPI2_DIAG_BUF_TYPE_COUNT];
-	u8		diag_buffer_status[MPI2_DIAG_BUF_TYPE_COUNT];
-	u32		unique_id[MPI2_DIAG_BUF_TYPE_COUNT];
-	Mpi2ManufacturingPage10_t manu_pg10;
-	u32		product_specific[MPI2_DIAG_BUF_TYPE_COUNT][23];
-	u32		diagnostic_flags[MPI2_DIAG_BUF_TYPE_COUNT];
-	u32		ring_buffer_offset;
-	u32		ring_buffer_sz;
-	u8		is_warpdrive;
-	u8		hide_ir_msg;
-	u8		mfg_pg10_hide_flag;
-	u8		hide_drives;
-
-	struct mutex pci_access_mutex;
-};
-
-typedef u8 (*MPT_CALLBACK)(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
-    u32 reply);
-
-
-/* base shared API */
-extern struct list_head mpt2sas_ioc_list;
-/* spinlock on list operations over IOCs
- * Case: when multiple warpdrive cards(IOCs) are in use
- * Each IOC will added to the ioc list stucture on initialization.
- * Watchdog threads run at regular intervals to check IOC for any
- * fault conditions which will trigger the dead_ioc thread to
- * deallocate pci resource, resulting deleting the IOC netry from list,
- * this deletion need to protected by spinlock to enusre that
- * ioc removal is syncrhonized, if not synchronized it might lead to
- * list_del corruption as the ioc list is traversed in cli path
- */
-extern spinlock_t gioc_lock;
-void mpt2sas_base_start_watchdog(struct MPT2SAS_ADAPTER *ioc);
-void mpt2sas_base_stop_watchdog(struct MPT2SAS_ADAPTER *ioc);
-
-int mpt2sas_base_attach(struct MPT2SAS_ADAPTER *ioc);
-void mpt2sas_base_detach(struct MPT2SAS_ADAPTER *ioc);
-int mpt2sas_base_map_resources(struct MPT2SAS_ADAPTER *ioc);
-void mpt2sas_base_free_resources(struct MPT2SAS_ADAPTER *ioc);
-int mpt2sas_base_hard_reset_handler(struct MPT2SAS_ADAPTER *ioc, int sleep_flag,
-    enum reset_type type);
-
-void *mpt2sas_base_get_msg_frame(struct MPT2SAS_ADAPTER *ioc, u16 smid);
-void *mpt2sas_base_get_sense_buffer(struct MPT2SAS_ADAPTER *ioc, u16 smid);
-void mpt2sas_base_build_zero_len_sge(struct MPT2SAS_ADAPTER *ioc, void *paddr);
-__le32 mpt2sas_base_get_sense_buffer_dma(struct MPT2SAS_ADAPTER *ioc,
-    u16 smid);
-void mpt2sas_base_flush_reply_queues(struct MPT2SAS_ADAPTER *ioc);
-
-/* hi-priority queue */
-u16 mpt2sas_base_get_smid_hpr(struct MPT2SAS_ADAPTER *ioc, u8 cb_idx);
-u16 mpt2sas_base_get_smid_scsiio(struct MPT2SAS_ADAPTER *ioc, u8 cb_idx,
-    struct scsi_cmnd *scmd);
-
-u16 mpt2sas_base_get_smid(struct MPT2SAS_ADAPTER *ioc, u8 cb_idx);
-void mpt2sas_base_free_smid(struct MPT2SAS_ADAPTER *ioc, u16 smid);
-void mpt2sas_base_put_smid_scsi_io(struct MPT2SAS_ADAPTER *ioc, u16 smid,
-    u16 handle);
-void mpt2sas_base_put_smid_hi_priority(struct MPT2SAS_ADAPTER *ioc, u16 smid);
-void mpt2sas_base_put_smid_target_assist(struct MPT2SAS_ADAPTER *ioc, u16 smid,
-    u16 io_index);
-void mpt2sas_base_put_smid_default(struct MPT2SAS_ADAPTER *ioc, u16 smid);
-void mpt2sas_base_initialize_callback_handler(void);
-u8 mpt2sas_base_register_callback_handler(MPT_CALLBACK cb_func);
-void mpt2sas_base_release_callback_handler(u8 cb_idx);
-
-u8 mpt2sas_base_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
-    u32 reply);
-u8 mpt2sas_port_enable_done(struct MPT2SAS_ADAPTER *ioc, u16 smid,
-	u8 msix_index,	u32 reply);
-void *mpt2sas_base_get_reply_virt_addr(struct MPT2SAS_ADAPTER *ioc, u32 phys_addr);
-
-u32 mpt2sas_base_get_iocstate(struct MPT2SAS_ADAPTER *ioc, int cooked);
-
-void mpt2sas_base_fault_info(struct MPT2SAS_ADAPTER *ioc , u16 fault_code);
-int mpt2sas_base_sas_iounit_control(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2SasIoUnitControlReply_t *mpi_reply, Mpi2SasIoUnitControlRequest_t
-    *mpi_request);
-int mpt2sas_base_scsi_enclosure_processor(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2SepReply_t *mpi_reply, Mpi2SepRequest_t *mpi_request);
-void mpt2sas_base_validate_event_type(struct MPT2SAS_ADAPTER *ioc, u32 *event_type);
-
-void mpt2sas_halt_firmware(struct MPT2SAS_ADAPTER *ioc);
-
-void mpt2sas_base_update_missing_delay(struct MPT2SAS_ADAPTER *ioc,
-	u16 device_missing_delay, u8 io_missing_delay);
-
-int mpt2sas_port_enable(struct MPT2SAS_ADAPTER *ioc);
-
-/* scsih shared API */
-void mpt2sas_scsih_event_callback(struct MPT2SAS_ADAPTER *ioc, u8 msix_index,
-    u32 reply);
-int mpt2sas_scsih_issue_tm(struct MPT2SAS_ADAPTER *ioc, u16 handle,
-	uint channel, uint id, uint lun, u8 type, u16 smid_task,
-	ulong timeout, enum mutex_type m_type);
-void mpt2sas_scsih_set_tm_flag(struct MPT2SAS_ADAPTER *ioc, u16 handle);
-void mpt2sas_scsih_clear_tm_flag(struct MPT2SAS_ADAPTER *ioc, u16 handle);
-void mpt2sas_expander_remove(struct MPT2SAS_ADAPTER *ioc, u64 sas_address);
-void mpt2sas_device_remove_by_sas_address(struct MPT2SAS_ADAPTER *ioc,
-		u64 sas_address);
-struct _sas_node *mpt2sas_scsih_expander_find_by_handle(struct MPT2SAS_ADAPTER *ioc,
-    u16 handle);
-struct _sas_node *mpt2sas_scsih_expander_find_by_sas_address(struct MPT2SAS_ADAPTER
-    *ioc, u64 sas_address);
-struct _sas_device *mpt2sas_scsih_sas_device_find_by_sas_address(
-    struct MPT2SAS_ADAPTER *ioc, u64 sas_address);
-
-void mpt2sas_port_enable_complete(struct MPT2SAS_ADAPTER *ioc);
-void mpt2sas_scsih_reset_handler(struct MPT2SAS_ADAPTER *ioc, int reset_phase);
-
-/* config shared API */
-u8 mpt2sas_config_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
-    u32 reply);
-int mpt2sas_config_get_number_hba_phys(struct MPT2SAS_ADAPTER *ioc, u8 *num_phys);
-int mpt2sas_config_get_manufacturing_pg0(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2ConfigReply_t *mpi_reply, Mpi2ManufacturingPage0_t *config_page);
-int mpt2sas_config_get_manufacturing_pg10(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2ConfigReply_t *mpi_reply, Mpi2ManufacturingPage10_t *config_page);
-int mpt2sas_config_get_bios_pg2(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2BiosPage2_t *config_page);
-int mpt2sas_config_get_bios_pg3(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2BiosPage3_t *config_page);
-int mpt2sas_config_get_iounit_pg0(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2IOUnitPage0_t *config_page);
-int mpt2sas_config_get_sas_device_pg0(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2SasDevicePage0_t *config_page, u32 form, u32 handle);
-int mpt2sas_config_get_sas_device_pg1(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2SasDevicePage1_t *config_page, u32 form, u32 handle);
-int mpt2sas_config_get_sas_iounit_pg0(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2SasIOUnitPage0_t *config_page, u16 sz);
-int mpt2sas_config_get_iounit_pg1(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2IOUnitPage1_t *config_page);
-int mpt2sas_config_set_iounit_pg1(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2IOUnitPage1_t *config_page);
-int mpt2sas_config_get_iounit_pg8(struct MPT2SAS_ADAPTER *ioc,
-	Mpi2ConfigReply_t *mpi_reply, Mpi2IOUnitPage8_t *config_page);
-int mpt2sas_config_get_iounit_pg3(struct MPT2SAS_ADAPTER *ioc,
-	Mpi2ConfigReply_t *mpi_reply, Mpi2IOUnitPage3_t *config_page, u16 sz);
-int mpt2sas_config_get_sas_iounit_pg1(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2SasIOUnitPage1_t *config_page, u16 sz);
-int mpt2sas_config_set_sas_iounit_pg1(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2ConfigReply_t *mpi_reply, Mpi2SasIOUnitPage1_t *config_page, u16 sz);
-int mpt2sas_config_get_ioc_pg8(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2IOCPage8_t *config_page);
-int mpt2sas_config_get_expander_pg0(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2ExpanderPage0_t *config_page, u32 form, u32 handle);
-int mpt2sas_config_get_expander_pg1(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2ExpanderPage1_t *config_page, u32 phy_number, u16 handle);
-int mpt2sas_config_get_enclosure_pg0(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2SasEnclosurePage0_t *config_page, u32 form, u32 handle);
-int mpt2sas_config_get_phy_pg0(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2SasPhyPage0_t *config_page, u32 phy_number);
-int mpt2sas_config_get_phy_pg1(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2SasPhyPage1_t *config_page, u32 phy_number);
-int mpt2sas_config_get_raid_volume_pg1(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2RaidVolPage1_t *config_page, u32 form, u32 handle);
-int mpt2sas_config_get_number_pds(struct MPT2SAS_ADAPTER *ioc, u16 handle, u8 *num_pds);
-int mpt2sas_config_get_raid_volume_pg0(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2RaidVolPage0_t *config_page, u32 form, u32 handle, u16 sz);
-int mpt2sas_config_get_phys_disk_pg0(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2RaidPhysDiskPage0_t *config_page, u32 form,
-    u32 form_specific);
-int mpt2sas_config_get_volume_handle(struct MPT2SAS_ADAPTER *ioc, u16 pd_handle,
-    u16 *volume_handle);
-int mpt2sas_config_get_volume_wwid(struct MPT2SAS_ADAPTER *ioc, u16 volume_handle,
-    u64 *wwid);
-/* ctl shared API */
-extern struct device_attribute *mpt2sas_host_attrs[];
-extern struct device_attribute *mpt2sas_dev_attrs[];
-void mpt2sas_ctl_init(void);
-void mpt2sas_ctl_exit(void);
-u8 mpt2sas_ctl_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
-    u32 reply);
-void mpt2sas_ctl_reset_handler(struct MPT2SAS_ADAPTER *ioc, int reset_phase);
-void mpt2sas_ctl_event_callback(struct MPT2SAS_ADAPTER *ioc, u8 msix_index,
-    u32 reply);
-void mpt2sas_ctl_add_to_event_log(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventNotificationReply_t *mpi_reply);
-
-void mpt2sas_enable_diag_buffer(struct MPT2SAS_ADAPTER *ioc,
-	u8 bits_to_regsiter);
-
-/* transport shared API */
-u8 mpt2sas_transport_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
-    u32 reply);
-struct _sas_port *mpt2sas_transport_port_add(struct MPT2SAS_ADAPTER *ioc,
-     u16 handle, u64 sas_address);
-void mpt2sas_transport_port_remove(struct MPT2SAS_ADAPTER *ioc, u64 sas_address,
-     u64 sas_address_parent);
-int mpt2sas_transport_add_host_phy(struct MPT2SAS_ADAPTER *ioc, struct _sas_phy
-    *mpt2sas_phy, Mpi2SasPhyPage0_t phy_pg0, struct device *parent_dev);
-int mpt2sas_transport_add_expander_phy(struct MPT2SAS_ADAPTER *ioc, struct _sas_phy
-    *mpt2sas_phy, Mpi2ExpanderPage1_t expander_pg1, struct device *parent_dev);
-void mpt2sas_transport_update_links(struct MPT2SAS_ADAPTER *ioc,
-     u64 sas_address, u16 handle, u8 phy_number, u8 link_rate);
-extern struct sas_function_template mpt2sas_transport_functions;
-extern struct scsi_transport_template *mpt2sas_transport_template;
-extern int scsi_internal_device_block(struct scsi_device *sdev);
-extern u8 mpt2sas_stm_zero_smid_handler(struct MPT2SAS_ADAPTER *ioc,
-    u8 msix_index, u32 reply);
-extern int scsi_internal_device_unblock(struct scsi_device *sdev,
-					enum scsi_device_state new_state);
-
-#endif /* MPT2SAS_BASE_H_INCLUDED */
diff --git a/drivers/scsi/mpt2sas/mpt2sas_config.c b/drivers/scsi/mpt2sas/mpt2sas_config.c
deleted file mode 100644
index c43815b1a485..000000000000
--- a/drivers/scsi/mpt2sas/mpt2sas_config.c
+++ /dev/null
@@ -1,1527 +0,0 @@
-/*
- * This module provides common API for accessing firmware configuration pages
- *
- * This code is based on drivers/scsi/mpt2sas/mpt2_base.c
- * Copyright (C) 2007-2014  LSI Corporation
- * Copyright (C) 20013-2014 Avago Technologies
- *  (mailto: MPT-FusionLinux.pdl@avagotech.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * NO WARRANTY
- * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
- * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
- * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
- * solely responsible for determining the appropriateness of using and
- * distributing the Program and assumes all risks associated with its
- * exercise of rights under this Agreement, including but not limited to
- * the risks and costs of program errors, damage to or loss of data,
- * programs or equipment, and unavailability or interruption of operations.
-
- * DISCLAIMER OF LIABILITY
- * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
- * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
-
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
- * USA.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/blkdev.h>
-#include <linux/sched.h>
-#include <linux/workqueue.h>
-#include <linux/delay.h>
-#include <linux/pci.h>
-#include <linux/slab.h>
-
-#include "mpt2sas_base.h"
-
-/* local definitions */
-
-/* Timeout for config page request (in seconds) */
-#define MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT 15
-
-/* Common sgl flags for READING a config page. */
-#define MPT2_CONFIG_COMMON_SGLFLAGS ((MPI2_SGE_FLAGS_SIMPLE_ELEMENT | \
-    MPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER \
-    | MPI2_SGE_FLAGS_END_OF_LIST) << MPI2_SGE_FLAGS_SHIFT)
-
-/* Common sgl flags for WRITING a config page. */
-#define MPT2_CONFIG_COMMON_WRITE_SGLFLAGS ((MPI2_SGE_FLAGS_SIMPLE_ELEMENT | \
-    MPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER \
-    | MPI2_SGE_FLAGS_END_OF_LIST | MPI2_SGE_FLAGS_HOST_TO_IOC) \
-    << MPI2_SGE_FLAGS_SHIFT)
-
-/**
- * struct config_request - obtain dma memory via routine
- * @sz: size
- * @page: virt pointer
- * @page_dma: phys pointer
- *
- */
-struct config_request{
-	u16			sz;
-	void			*page;
-	dma_addr_t		page_dma;
-};
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-/**
- * _config_display_some_debug - debug routine
- * @ioc: per adapter object
- * @smid: system request message index
- * @calling_function_name: string pass from calling function
- * @mpi_reply: reply message frame
- * Context: none.
- *
- * Function for displaying debug info helpful when debugging issues
- * in this module.
- */
-static void
-_config_display_some_debug(struct MPT2SAS_ADAPTER *ioc, u16 smid,
-    char *calling_function_name, MPI2DefaultReply_t *mpi_reply)
-{
-	Mpi2ConfigRequest_t *mpi_request;
-	char *desc = NULL;
-
-	if (!(ioc->logging_level & MPT_DEBUG_CONFIG))
-		return;
-
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	switch (mpi_request->Header.PageType & MPI2_CONFIG_PAGETYPE_MASK) {
-	case MPI2_CONFIG_PAGETYPE_IO_UNIT:
-		desc = "io_unit";
-		break;
-	case MPI2_CONFIG_PAGETYPE_IOC:
-		desc = "ioc";
-		break;
-	case MPI2_CONFIG_PAGETYPE_BIOS:
-		desc = "bios";
-		break;
-	case MPI2_CONFIG_PAGETYPE_RAID_VOLUME:
-		desc = "raid_volume";
-		break;
-	case MPI2_CONFIG_PAGETYPE_MANUFACTURING:
-		desc = "manufaucturing";
-		break;
-	case MPI2_CONFIG_PAGETYPE_RAID_PHYSDISK:
-		desc = "physdisk";
-		break;
-	case MPI2_CONFIG_PAGETYPE_EXTENDED:
-		switch (mpi_request->ExtPageType) {
-		case MPI2_CONFIG_EXTPAGETYPE_SAS_IO_UNIT:
-			desc = "sas_io_unit";
-			break;
-		case MPI2_CONFIG_EXTPAGETYPE_SAS_EXPANDER:
-			desc = "sas_expander";
-			break;
-		case MPI2_CONFIG_EXTPAGETYPE_SAS_DEVICE:
-			desc = "sas_device";
-			break;
-		case MPI2_CONFIG_EXTPAGETYPE_SAS_PHY:
-			desc = "sas_phy";
-			break;
-		case MPI2_CONFIG_EXTPAGETYPE_LOG:
-			desc = "log";
-			break;
-		case MPI2_CONFIG_EXTPAGETYPE_ENCLOSURE:
-			desc = "enclosure";
-			break;
-		case MPI2_CONFIG_EXTPAGETYPE_RAID_CONFIG:
-			desc = "raid_config";
-			break;
-		case MPI2_CONFIG_EXTPAGETYPE_DRIVER_MAPPING:
-			desc = "driver_mapping";
-			break;
-		}
-		break;
-	}
-
-	if (!desc)
-		return;
-
-	printk(MPT2SAS_INFO_FMT "%s: %s(%d), action(%d), form(0x%08x), "
-	    "smid(%d)\n", ioc->name, calling_function_name, desc,
-	    mpi_request->Header.PageNumber, mpi_request->Action,
-	    le32_to_cpu(mpi_request->PageAddress), smid);
-
-	if (!mpi_reply)
-		return;
-
-	if (mpi_reply->IOCStatus || mpi_reply->IOCLogInfo)
-		printk(MPT2SAS_INFO_FMT
-		    "\tiocstatus(0x%04x), loginfo(0x%08x)\n",
-		    ioc->name, le16_to_cpu(mpi_reply->IOCStatus),
-		    le32_to_cpu(mpi_reply->IOCLogInfo));
-}
-#endif
-
-/**
- * _config_alloc_config_dma_memory - obtain physical memory
- * @ioc: per adapter object
- * @mem: struct config_request
- *
- * A wrapper for obtaining dma-able memory for config page request.
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_config_alloc_config_dma_memory(struct MPT2SAS_ADAPTER *ioc,
-    struct config_request *mem)
-{
-	int r = 0;
-
-	if (mem->sz > ioc->config_page_sz) {
-		mem->page = dma_alloc_coherent(&ioc->pdev->dev, mem->sz,
-		    &mem->page_dma, GFP_KERNEL);
-		if (!mem->page) {
-			printk(MPT2SAS_ERR_FMT "%s: dma_alloc_coherent"
-			    " failed asking for (%d) bytes!!\n",
-			    ioc->name, __func__, mem->sz);
-			r = -ENOMEM;
-		}
-	} else { /* use tmp buffer if less than 512 bytes */
-		mem->page = ioc->config_page;
-		mem->page_dma = ioc->config_page_dma;
-	}
-	return r;
-}
-
-/**
- * _config_free_config_dma_memory - wrapper to free the memory
- * @ioc: per adapter object
- * @mem: struct config_request
- *
- * A wrapper to free dma-able memory when using _config_alloc_config_dma_memory.
- *
- * Returns 0 for success, non-zero for failure.
- */
-static void
-_config_free_config_dma_memory(struct MPT2SAS_ADAPTER *ioc,
-    struct config_request *mem)
-{
-	if (mem->sz > ioc->config_page_sz)
-		dma_free_coherent(&ioc->pdev->dev, mem->sz, mem->page,
-		    mem->page_dma);
-}
-
-/**
- * mpt2sas_config_done - config page completion routine
- * @ioc: per adapter object
- * @smid: system request message index
- * @msix_index: MSIX table index supplied by the OS
- * @reply: reply message frame(lower 32bit addr)
- * Context: none.
- *
- * The callback handler when using _config_request.
- *
- * Return 1 meaning mf should be freed from _base_interrupt
- *        0 means the mf is freed from this function.
- */
-u8
-mpt2sas_config_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
-    u32 reply)
-{
-	MPI2DefaultReply_t *mpi_reply;
-
-	if (ioc->config_cmds.status == MPT2_CMD_NOT_USED)
-		return 1;
-	if (ioc->config_cmds.smid != smid)
-		return 1;
-	ioc->config_cmds.status |= MPT2_CMD_COMPLETE;
-	mpi_reply =  mpt2sas_base_get_reply_virt_addr(ioc, reply);
-	if (mpi_reply) {
-		ioc->config_cmds.status |= MPT2_CMD_REPLY_VALID;
-		memcpy(ioc->config_cmds.reply, mpi_reply,
-		    mpi_reply->MsgLength*4);
-	}
-	ioc->config_cmds.status &= ~MPT2_CMD_PENDING;
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-	_config_display_some_debug(ioc, smid, "config_done", mpi_reply);
-#endif
-	ioc->config_cmds.smid = USHRT_MAX;
-	complete(&ioc->config_cmds.done);
-	return 1;
-}
-
-/**
- * _config_request - main routine for sending config page requests
- * @ioc: per adapter object
- * @mpi_request: request message frame
- * @mpi_reply: reply mf payload returned from firmware
- * @timeout: timeout in seconds
- * @config_page: contents of the config page
- * @config_page_sz: size of config page
- * Context: sleep
- *
- * A generic API for config page requests to firmware.
- *
- * The ioc->config_cmds.status flag should be MPT2_CMD_NOT_USED before calling
- * this API.
- *
- * The callback index is set inside `ioc->config_cb_idx.
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_config_request(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigRequest_t
-    *mpi_request, Mpi2ConfigReply_t *mpi_reply, int timeout,
-    void *config_page, u16 config_page_sz)
-{
-	u16 smid;
-	u32 ioc_state;
-	unsigned long timeleft;
-	Mpi2ConfigRequest_t *config_request;
-	int r;
-	u8 retry_count, issue_host_reset = 0;
-	u16 wait_state_count;
-	struct config_request mem;
-
-	mutex_lock(&ioc->config_cmds.mutex);
-	if (ioc->config_cmds.status != MPT2_CMD_NOT_USED) {
-		printk(MPT2SAS_ERR_FMT "%s: config_cmd in use\n",
-		    ioc->name, __func__);
-		mutex_unlock(&ioc->config_cmds.mutex);
-		return -EAGAIN;
-	}
-
-	retry_count = 0;
-	memset(&mem, 0, sizeof(struct config_request));
-
-	mpi_request->VF_ID = 0; /* TODO */
-	mpi_request->VP_ID = 0;
-
-	if (config_page) {
-		mpi_request->Header.PageVersion = mpi_reply->Header.PageVersion;
-		mpi_request->Header.PageNumber = mpi_reply->Header.PageNumber;
-		mpi_request->Header.PageType = mpi_reply->Header.PageType;
-		mpi_request->Header.PageLength = mpi_reply->Header.PageLength;
-		mpi_request->ExtPageLength = mpi_reply->ExtPageLength;
-		mpi_request->ExtPageType = mpi_reply->ExtPageType;
-		if (mpi_request->Header.PageLength)
-			mem.sz = mpi_request->Header.PageLength * 4;
-		else
-			mem.sz = le16_to_cpu(mpi_reply->ExtPageLength) * 4;
-		r = _config_alloc_config_dma_memory(ioc, &mem);
-		if (r != 0)
-			goto out;
-		if (mpi_request->Action ==
-		    MPI2_CONFIG_ACTION_PAGE_WRITE_CURRENT ||
-		    mpi_request->Action ==
-		    MPI2_CONFIG_ACTION_PAGE_WRITE_NVRAM) {
-			ioc->base_add_sg_single(&mpi_request->PageBufferSGE,
-			    MPT2_CONFIG_COMMON_WRITE_SGLFLAGS | mem.sz,
-			    mem.page_dma);
-			memcpy(mem.page, config_page, min_t(u16, mem.sz,
-			    config_page_sz));
-		} else {
-			memset(config_page, 0, config_page_sz);
-			ioc->base_add_sg_single(&mpi_request->PageBufferSGE,
-			    MPT2_CONFIG_COMMON_SGLFLAGS | mem.sz, mem.page_dma);
-		}
-	}
-
- retry_config:
-	if (retry_count) {
-		if (retry_count > 2) { /* attempt only 2 retries */
-			r = -EFAULT;
-			goto free_mem;
-		}
-		printk(MPT2SAS_INFO_FMT "%s: attempting retry (%d)\n",
-		    ioc->name, __func__, retry_count);
-	}
-	wait_state_count = 0;
-	ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
-		if (wait_state_count++ == MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT) {
-			printk(MPT2SAS_ERR_FMT
-			    "%s: failed due to ioc not operational\n",
-			    ioc->name, __func__);
-			ioc->config_cmds.status = MPT2_CMD_NOT_USED;
-			r = -EFAULT;
-			goto free_mem;
-		}
-		ssleep(1);
-		ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-		printk(MPT2SAS_INFO_FMT "%s: waiting for "
-		    "operational state(count=%d)\n", ioc->name,
-		    __func__, wait_state_count);
-	}
-	if (wait_state_count)
-		printk(MPT2SAS_INFO_FMT "%s: ioc is operational\n",
-		    ioc->name, __func__);
-
-	smid = mpt2sas_base_get_smid(ioc, ioc->config_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		ioc->config_cmds.status = MPT2_CMD_NOT_USED;
-		r = -EAGAIN;
-		goto free_mem;
-	}
-
-	r = 0;
-	memset(mpi_reply, 0, sizeof(Mpi2ConfigReply_t));
-	ioc->config_cmds.status = MPT2_CMD_PENDING;
-	config_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	ioc->config_cmds.smid = smid;
-	memcpy(config_request, mpi_request, sizeof(Mpi2ConfigRequest_t));
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-	_config_display_some_debug(ioc, smid, "config_request", NULL);
-#endif
-	init_completion(&ioc->config_cmds.done);
-	mpt2sas_base_put_smid_default(ioc, smid);
-	timeleft = wait_for_completion_timeout(&ioc->config_cmds.done,
-	    timeout*HZ);
-	if (!(ioc->config_cmds.status & MPT2_CMD_COMPLETE)) {
-		printk(MPT2SAS_ERR_FMT "%s: timeout\n",
-		    ioc->name, __func__);
-		_debug_dump_mf(mpi_request,
-		    sizeof(Mpi2ConfigRequest_t)/4);
-		retry_count++;
-		if (ioc->config_cmds.smid == smid)
-			mpt2sas_base_free_smid(ioc, smid);
-		if ((ioc->shost_recovery) || (ioc->config_cmds.status &
-		    MPT2_CMD_RESET) || ioc->pci_error_recovery)
-			goto retry_config;
-		issue_host_reset = 1;
-		r = -EFAULT;
-		goto free_mem;
-	}
-
-	if (ioc->config_cmds.status & MPT2_CMD_REPLY_VALID)
-		memcpy(mpi_reply, ioc->config_cmds.reply,
-		    sizeof(Mpi2ConfigReply_t));
-	if (retry_count)
-		printk(MPT2SAS_INFO_FMT "%s: retry (%d) completed!!\n",
-		    ioc->name, __func__, retry_count);
-	if (config_page && mpi_request->Action ==
-	    MPI2_CONFIG_ACTION_PAGE_READ_CURRENT)
-		memcpy(config_page, mem.page, min_t(u16, mem.sz,
-		    config_page_sz));
- free_mem:
-	if (config_page)
-		_config_free_config_dma_memory(ioc, &mem);
- out:
-	ioc->config_cmds.status = MPT2_CMD_NOT_USED;
-	mutex_unlock(&ioc->config_cmds.mutex);
-
-	if (issue_host_reset)
-		mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-		    FORCE_BIG_HAMMER);
-	return r;
-}
-
-/**
- * mpt2sas_config_get_manufacturing_pg0 - obtain manufacturing page 0
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_manufacturing_pg0(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2ConfigReply_t *mpi_reply, Mpi2ManufacturingPage0_t *config_page)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_MANUFACTURING;
-	mpi_request.Header.PageNumber = 0;
-	mpi_request.Header.PageVersion = MPI2_MANUFACTURING0_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_manufacturing_pg10 - obtain manufacturing page 10
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_manufacturing_pg10(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2ConfigReply_t *mpi_reply, Mpi2ManufacturingPage10_t *config_page)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_MANUFACTURING;
-	mpi_request.Header.PageNumber = 10;
-	mpi_request.Header.PageVersion = MPI2_MANUFACTURING0_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_bios_pg2 - obtain bios page 2
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_bios_pg2(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2ConfigReply_t *mpi_reply, Mpi2BiosPage2_t *config_page)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_BIOS;
-	mpi_request.Header.PageNumber = 2;
-	mpi_request.Header.PageVersion = MPI2_BIOSPAGE2_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_bios_pg3 - obtain bios page 3
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_bios_pg3(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2BiosPage3_t *config_page)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_BIOS;
-	mpi_request.Header.PageNumber = 3;
-	mpi_request.Header.PageVersion = MPI2_BIOSPAGE3_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_iounit_pg0 - obtain iounit page 0
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_iounit_pg0(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2ConfigReply_t *mpi_reply, Mpi2IOUnitPage0_t *config_page)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_IO_UNIT;
-	mpi_request.Header.PageNumber = 0;
-	mpi_request.Header.PageVersion = MPI2_IOUNITPAGE0_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_iounit_pg1 - obtain iounit page 1
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_iounit_pg1(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2ConfigReply_t *mpi_reply, Mpi2IOUnitPage1_t *config_page)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_IO_UNIT;
-	mpi_request.Header.PageNumber = 1;
-	mpi_request.Header.PageVersion = MPI2_IOUNITPAGE1_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_set_iounit_pg1 - set iounit page 1
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_set_iounit_pg1(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2ConfigReply_t *mpi_reply, Mpi2IOUnitPage1_t *config_page)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_IO_UNIT;
-	mpi_request.Header.PageNumber = 1;
-	mpi_request.Header.PageVersion = MPI2_IOUNITPAGE1_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_WRITE_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_iounit_pg3 - obtain iounit page 3
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * @sz: size of buffer passed in config_page
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_iounit_pg3(struct MPT2SAS_ADAPTER *ioc,
-	Mpi2ConfigReply_t *mpi_reply, Mpi2IOUnitPage3_t *config_page, u16 sz)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_IO_UNIT;
-	mpi_request.Header.PageNumber = 3;
-	mpi_request.Header.PageVersion = MPI2_IOUNITPAGE3_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page, sz);
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_iounit_pg8 - obtain iounit page 8
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_iounit_pg8(struct MPT2SAS_ADAPTER *ioc,
-	Mpi2ConfigReply_t *mpi_reply, Mpi2IOUnitPage8_t *config_page)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_IO_UNIT;
-	mpi_request.Header.PageNumber = 8;
-	mpi_request.Header.PageVersion = MPI2_IOUNITPAGE8_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_ioc_pg8 - obtain ioc page 8
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_ioc_pg8(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2ConfigReply_t *mpi_reply, Mpi2IOCPage8_t *config_page)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_IOC;
-	mpi_request.Header.PageNumber = 8;
-	mpi_request.Header.PageVersion = MPI2_IOCPAGE8_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_sas_device_pg0 - obtain sas device page 0
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * @form: GET_NEXT_HANDLE or HANDLE
- * @handle: device handle
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_sas_device_pg0(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2SasDevicePage0_t *config_page, u32 form, u32 handle)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_EXTENDED;
-	mpi_request.ExtPageType = MPI2_CONFIG_EXTPAGETYPE_SAS_DEVICE;
-	mpi_request.Header.PageVersion = MPI2_SASDEVICE0_PAGEVERSION;
-	mpi_request.Header.PageNumber = 0;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.PageAddress = cpu_to_le32(form | handle);
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_sas_device_pg1 - obtain sas device page 1
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * @form: GET_NEXT_HANDLE or HANDLE
- * @handle: device handle
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_sas_device_pg1(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2SasDevicePage1_t *config_page, u32 form, u32 handle)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_EXTENDED;
-	mpi_request.ExtPageType = MPI2_CONFIG_EXTPAGETYPE_SAS_DEVICE;
-	mpi_request.Header.PageVersion = MPI2_SASDEVICE1_PAGEVERSION;
-	mpi_request.Header.PageNumber = 1;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.PageAddress = cpu_to_le32(form | handle);
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_number_hba_phys - obtain number of phys on the host
- * @ioc: per adapter object
- * @num_phys: pointer returned with the number of phys
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_number_hba_phys(struct MPT2SAS_ADAPTER *ioc, u8 *num_phys)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-	u16 ioc_status;
-	Mpi2ConfigReply_t mpi_reply;
-	Mpi2SasIOUnitPage0_t config_page;
-
-	*num_phys = 0;
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_EXTENDED;
-	mpi_request.ExtPageType = MPI2_CONFIG_EXTPAGETYPE_SAS_IO_UNIT;
-	mpi_request.Header.PageNumber = 0;
-	mpi_request.Header.PageVersion = MPI2_SASIOUNITPAGE0_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, &mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, &mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, &config_page,
-	    sizeof(Mpi2SasIOUnitPage0_t));
-	if (!r) {
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-		    MPI2_IOCSTATUS_MASK;
-		if (ioc_status == MPI2_IOCSTATUS_SUCCESS)
-			*num_phys = config_page.NumPhys;
-	}
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_sas_iounit_pg0 - obtain sas iounit page 0
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * @sz: size of buffer passed in config_page
- * Context: sleep.
- *
- * Calling function should call config_get_number_hba_phys prior to
- * this function, so enough memory is allocated for config_page.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_sas_iounit_pg0(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2SasIOUnitPage0_t *config_page, u16 sz)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_EXTENDED;
-	mpi_request.ExtPageType = MPI2_CONFIG_EXTPAGETYPE_SAS_IO_UNIT;
-	mpi_request.Header.PageNumber = 0;
-	mpi_request.Header.PageVersion = MPI2_SASIOUNITPAGE0_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page, sz);
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_sas_iounit_pg1 - obtain sas iounit page 1
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * @sz: size of buffer passed in config_page
- * Context: sleep.
- *
- * Calling function should call config_get_number_hba_phys prior to
- * this function, so enough memory is allocated for config_page.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_sas_iounit_pg1(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2SasIOUnitPage1_t *config_page, u16 sz)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_EXTENDED;
-	mpi_request.ExtPageType = MPI2_CONFIG_EXTPAGETYPE_SAS_IO_UNIT;
-	mpi_request.Header.PageNumber = 1;
-	mpi_request.Header.PageVersion = MPI2_SASIOUNITPAGE1_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page, sz);
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_set_sas_iounit_pg1 - send sas iounit page 1
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * @sz: size of buffer passed in config_page
- * Context: sleep.
- *
- * Calling function should call config_get_number_hba_phys prior to
- * this function, so enough memory is allocated for config_page.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_set_sas_iounit_pg1(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2SasIOUnitPage1_t *config_page, u16 sz)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_EXTENDED;
-	mpi_request.ExtPageType = MPI2_CONFIG_EXTPAGETYPE_SAS_IO_UNIT;
-	mpi_request.Header.PageNumber = 1;
-	mpi_request.Header.PageVersion = MPI2_SASIOUNITPAGE1_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_WRITE_CURRENT;
-	_config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page, sz);
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_WRITE_NVRAM;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page, sz);
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_expander_pg0 - obtain expander page 0
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * @form: GET_NEXT_HANDLE or HANDLE
- * @handle: expander handle
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_expander_pg0(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2ExpanderPage0_t *config_page, u32 form, u32 handle)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_EXTENDED;
-	mpi_request.ExtPageType = MPI2_CONFIG_EXTPAGETYPE_SAS_EXPANDER;
-	mpi_request.Header.PageNumber = 0;
-	mpi_request.Header.PageVersion = MPI2_SASEXPANDER0_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.PageAddress = cpu_to_le32(form | handle);
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_expander_pg1 - obtain expander page 1
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * @phy_number: phy number
- * @handle: expander handle
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_expander_pg1(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2ExpanderPage1_t *config_page, u32 phy_number,
-    u16 handle)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_EXTENDED;
-	mpi_request.ExtPageType = MPI2_CONFIG_EXTPAGETYPE_SAS_EXPANDER;
-	mpi_request.Header.PageNumber = 1;
-	mpi_request.Header.PageVersion = MPI2_SASEXPANDER1_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.PageAddress =
-	    cpu_to_le32(MPI2_SAS_EXPAND_PGAD_FORM_HNDL_PHY_NUM |
-	    (phy_number << MPI2_SAS_EXPAND_PGAD_PHYNUM_SHIFT) | handle);
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_enclosure_pg0 - obtain enclosure page 0
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * @form: GET_NEXT_HANDLE or HANDLE
- * @handle: expander handle
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_enclosure_pg0(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2SasEnclosurePage0_t *config_page, u32 form, u32 handle)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_EXTENDED;
-	mpi_request.ExtPageType = MPI2_CONFIG_EXTPAGETYPE_ENCLOSURE;
-	mpi_request.Header.PageNumber = 0;
-	mpi_request.Header.PageVersion = MPI2_SASENCLOSURE0_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.PageAddress = cpu_to_le32(form | handle);
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_phy_pg0 - obtain phy page 0
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * @phy_number: phy number
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_phy_pg0(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2SasPhyPage0_t *config_page, u32 phy_number)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_EXTENDED;
-	mpi_request.ExtPageType = MPI2_CONFIG_EXTPAGETYPE_SAS_PHY;
-	mpi_request.Header.PageNumber = 0;
-	mpi_request.Header.PageVersion = MPI2_SASPHY0_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.PageAddress =
-	    cpu_to_le32(MPI2_SAS_PHY_PGAD_FORM_PHY_NUMBER | phy_number);
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_phy_pg1 - obtain phy page 1
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * @phy_number: phy number
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_phy_pg1(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2SasPhyPage1_t *config_page, u32 phy_number)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_EXTENDED;
-	mpi_request.ExtPageType = MPI2_CONFIG_EXTPAGETYPE_SAS_PHY;
-	mpi_request.Header.PageNumber = 1;
-	mpi_request.Header.PageVersion = MPI2_SASPHY1_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.PageAddress =
-	    cpu_to_le32(MPI2_SAS_PHY_PGAD_FORM_PHY_NUMBER | phy_number);
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_raid_volume_pg1 - obtain raid volume page 1
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * @form: GET_NEXT_HANDLE or HANDLE
- * @handle: volume handle
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_raid_volume_pg1(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2ConfigReply_t *mpi_reply, Mpi2RaidVolPage1_t *config_page, u32 form,
-    u32 handle)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_RAID_VOLUME;
-	mpi_request.Header.PageNumber = 1;
-	mpi_request.Header.PageVersion = MPI2_RAIDVOLPAGE1_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.PageAddress = cpu_to_le32(form | handle);
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_number_pds - obtain number of phys disk assigned to volume
- * @ioc: per adapter object
- * @handle: volume handle
- * @num_pds: returns pds count
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_number_pds(struct MPT2SAS_ADAPTER *ioc, u16 handle,
-    u8 *num_pds)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	Mpi2RaidVolPage0_t config_page;
-	Mpi2ConfigReply_t mpi_reply;
-	int r;
-	u16 ioc_status;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	*num_pds = 0;
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_RAID_VOLUME;
-	mpi_request.Header.PageNumber = 0;
-	mpi_request.Header.PageVersion = MPI2_RAIDVOLPAGE0_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, &mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.PageAddress =
-	    cpu_to_le32(MPI2_RAID_VOLUME_PGAD_FORM_HANDLE | handle);
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, &mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, &config_page,
-	    sizeof(Mpi2RaidVolPage0_t));
-	if (!r) {
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-		    MPI2_IOCSTATUS_MASK;
-		if (ioc_status == MPI2_IOCSTATUS_SUCCESS)
-			*num_pds = config_page.NumPhysDisks;
-	}
-
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_raid_volume_pg0 - obtain raid volume page 0
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * @form: GET_NEXT_HANDLE or HANDLE
- * @handle: volume handle
- * @sz: size of buffer passed in config_page
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_raid_volume_pg0(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2ConfigReply_t *mpi_reply, Mpi2RaidVolPage0_t *config_page, u32 form,
-    u32 handle, u16 sz)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_RAID_VOLUME;
-	mpi_request.Header.PageNumber = 0;
-	mpi_request.Header.PageVersion = MPI2_RAIDVOLPAGE0_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.PageAddress = cpu_to_le32(form | handle);
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page, sz);
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_phys_disk_pg0 - obtain phys disk page 0
- * @ioc: per adapter object
- * @mpi_reply: reply mf payload returned from firmware
- * @config_page: contents of the config page
- * @form: GET_NEXT_PHYSDISKNUM, PHYSDISKNUM, DEVHANDLE
- * @form_specific: specific to the form
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_phys_disk_pg0(struct MPT2SAS_ADAPTER *ioc, Mpi2ConfigReply_t
-    *mpi_reply, Mpi2RaidPhysDiskPage0_t *config_page, u32 form,
-    u32 form_specific)
-{
-	Mpi2ConfigRequest_t mpi_request;
-	int r;
-
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_RAID_PHYSDISK;
-	mpi_request.Header.PageNumber = 0;
-	mpi_request.Header.PageVersion = MPI2_RAIDPHYSDISKPAGE0_PAGEVERSION;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.PageAddress = cpu_to_le32(form | form_specific);
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	r = _config_request(ioc, &mpi_request, mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-	    sizeof(*config_page));
- out:
-	return r;
-}
-
-/**
- * mpt2sas_config_get_volume_handle - returns volume handle for give hidden raid components
- * @ioc: per adapter object
- * @pd_handle: phys disk handle
- * @volume_handle: volume handle
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_volume_handle(struct MPT2SAS_ADAPTER *ioc, u16 pd_handle,
-    u16 *volume_handle)
-{
-	Mpi2RaidConfigurationPage0_t *config_page = NULL;
-	Mpi2ConfigRequest_t mpi_request;
-	Mpi2ConfigReply_t mpi_reply;
-	int r, i, config_page_sz;
-	u16 ioc_status;
-	int config_num;
-	u16 element_type;
-	u16 phys_disk_dev_handle;
-
-	*volume_handle = 0;
-	memset(&mpi_request, 0, sizeof(Mpi2ConfigRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_CONFIG;
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_HEADER;
-	mpi_request.Header.PageType = MPI2_CONFIG_PAGETYPE_EXTENDED;
-	mpi_request.ExtPageType = MPI2_CONFIG_EXTPAGETYPE_RAID_CONFIG;
-	mpi_request.Header.PageVersion = MPI2_RAIDCONFIG0_PAGEVERSION;
-	mpi_request.Header.PageNumber = 0;
-	mpt2sas_base_build_zero_len_sge(ioc, &mpi_request.PageBufferSGE);
-	r = _config_request(ioc, &mpi_request, &mpi_reply,
-	    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, NULL, 0);
-	if (r)
-		goto out;
-
-	mpi_request.Action = MPI2_CONFIG_ACTION_PAGE_READ_CURRENT;
-	config_page_sz = (le16_to_cpu(mpi_reply.ExtPageLength) * 4);
-	config_page = kmalloc(config_page_sz, GFP_KERNEL);
-	if (!config_page) {
-		r = -1;
-		goto out;
-	}
-	config_num = 0xff;
-	while (1) {
-		mpi_request.PageAddress = cpu_to_le32(config_num +
-		    MPI2_RAID_PGAD_FORM_GET_NEXT_CONFIGNUM);
-		r = _config_request(ioc, &mpi_request, &mpi_reply,
-		    MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT, config_page,
-		    config_page_sz);
-		if (r)
-			goto out;
-		r = -1;
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-		    MPI2_IOCSTATUS_MASK;
-		if (ioc_status != MPI2_IOCSTATUS_SUCCESS)
-			goto out;
-		for (i = 0; i < config_page->NumElements; i++) {
-			element_type = le16_to_cpu(config_page->
-			    ConfigElement[i].ElementFlags) &
-			    MPI2_RAIDCONFIG0_EFLAGS_MASK_ELEMENT_TYPE;
-			if (element_type ==
-			    MPI2_RAIDCONFIG0_EFLAGS_VOL_PHYS_DISK_ELEMENT ||
-			    element_type ==
-			    MPI2_RAIDCONFIG0_EFLAGS_OCE_ELEMENT) {
-				phys_disk_dev_handle =
-				    le16_to_cpu(config_page->ConfigElement[i].
-				    PhysDiskDevHandle);
-				if (phys_disk_dev_handle == pd_handle) {
-					*volume_handle =
-					    le16_to_cpu(config_page->
-					    ConfigElement[i].VolDevHandle);
-					r = 0;
-					goto out;
-				}
-			} else if (element_type ==
-			    MPI2_RAIDCONFIG0_EFLAGS_HOT_SPARE_ELEMENT) {
-				*volume_handle = 0;
-				r = 0;
-				goto out;
-			}
-		}
-		config_num = config_page->ConfigNum;
-	}
- out:
-	kfree(config_page);
-	return r;
-}
-
-/**
- * mpt2sas_config_get_volume_wwid - returns wwid given the volume handle
- * @ioc: per adapter object
- * @volume_handle: volume handle
- * @wwid: volume wwid
- * Context: sleep.
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_config_get_volume_wwid(struct MPT2SAS_ADAPTER *ioc, u16 volume_handle,
-    u64 *wwid)
-{
-	Mpi2ConfigReply_t mpi_reply;
-	Mpi2RaidVolPage1_t raid_vol_pg1;
-
-	*wwid = 0;
-	if (!(mpt2sas_config_get_raid_volume_pg1(ioc, &mpi_reply,
-	    &raid_vol_pg1, MPI2_RAID_VOLUME_PGAD_FORM_HANDLE,
-	    volume_handle))) {
-		*wwid = le64_to_cpu(raid_vol_pg1.WWID);
-		return 0;
-	} else
-		return -1;
-}
diff --git a/drivers/scsi/mpt2sas/mpt2sas_ctl.c b/drivers/scsi/mpt2sas/mpt2sas_ctl.c
deleted file mode 100644
index 3694b63bd993..000000000000
--- a/drivers/scsi/mpt2sas/mpt2sas_ctl.c
+++ /dev/null
@@ -1,3101 +0,0 @@
-/*
- * Management Module Support for MPT (Message Passing Technology) based
- * controllers
- *
- * This code is based on drivers/scsi/mpt2sas/mpt2_ctl.c
- * Copyright (C) 2007-2014  LSI Corporation
- * Copyright (C) 20013-2014 Avago Technologies
- *  (mailto: MPT-FusionLinux.pdl@avagotech.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * NO WARRANTY
- * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
- * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
- * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
- * solely responsible for determining the appropriateness of using and
- * distributing the Program and assumes all risks associated with its
- * exercise of rights under this Agreement, including but not limited to
- * the risks and costs of program errors, damage to or loss of data,
- * programs or equipment, and unavailability or interruption of operations.
-
- * DISCLAIMER OF LIABILITY
- * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
- * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
-
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
- * USA.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/types.h>
-#include <linux/pci.h>
-#include <linux/delay.h>
-#include <linux/mutex.h>
-#include <linux/compat.h>
-#include <linux/poll.h>
-
-#include <linux/io.h>
-#include <linux/uaccess.h>
-
-#include "mpt2sas_base.h"
-#include "mpt2sas_ctl.h"
-
-static DEFINE_MUTEX(_ctl_mutex);
-static struct fasync_struct *async_queue;
-static DECLARE_WAIT_QUEUE_HEAD(ctl_poll_wait);
-
-static int _ctl_send_release(struct MPT2SAS_ADAPTER *ioc, u8 buffer_type,
-    u8 *issue_reset);
-
-/**
- * enum block_state - blocking state
- * @NON_BLOCKING: non blocking
- * @BLOCKING: blocking
- *
- * These states are for ioctls that need to wait for a response
- * from firmware, so they probably require sleep.
- */
-enum block_state {
-	NON_BLOCKING,
-	BLOCKING,
-};
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-/**
- * _ctl_sas_device_find_by_handle - sas device search
- * @ioc: per adapter object
- * @handle: sas device handle (assigned by firmware)
- * Context: Calling function should acquire ioc->sas_device_lock
- *
- * This searches for sas_device based on sas_address, then return sas_device
- * object.
- */
-static struct _sas_device *
-_ctl_sas_device_find_by_handle(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	struct _sas_device *sas_device, *r;
-
-	r = NULL;
-	list_for_each_entry(sas_device, &ioc->sas_device_list, list) {
-		if (sas_device->handle != handle)
-			continue;
-		r = sas_device;
-		goto out;
-	}
-
- out:
-	return r;
-}
-
-/**
- * _ctl_display_some_debug - debug routine
- * @ioc: per adapter object
- * @smid: system request message index
- * @calling_function_name: string pass from calling function
- * @mpi_reply: reply message frame
- * Context: none.
- *
- * Function for displaying debug info helpful when debugging issues
- * in this module.
- */
-static void
-_ctl_display_some_debug(struct MPT2SAS_ADAPTER *ioc, u16 smid,
-    char *calling_function_name, MPI2DefaultReply_t *mpi_reply)
-{
-	Mpi2ConfigRequest_t *mpi_request;
-	char *desc = NULL;
-
-	if (!(ioc->logging_level & MPT_DEBUG_IOCTL))
-		return;
-
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	switch (mpi_request->Function) {
-	case MPI2_FUNCTION_SCSI_IO_REQUEST:
-	{
-		Mpi2SCSIIORequest_t *scsi_request =
-		    (Mpi2SCSIIORequest_t *)mpi_request;
-
-		snprintf(ioc->tmp_string, MPT_STRING_LENGTH,
-		    "scsi_io, cmd(0x%02x), cdb_len(%d)",
-		    scsi_request->CDB.CDB32[0],
-		    le16_to_cpu(scsi_request->IoFlags) & 0xF);
-		desc = ioc->tmp_string;
-		break;
-	}
-	case MPI2_FUNCTION_SCSI_TASK_MGMT:
-		desc = "task_mgmt";
-		break;
-	case MPI2_FUNCTION_IOC_INIT:
-		desc = "ioc_init";
-		break;
-	case MPI2_FUNCTION_IOC_FACTS:
-		desc = "ioc_facts";
-		break;
-	case MPI2_FUNCTION_CONFIG:
-	{
-		Mpi2ConfigRequest_t *config_request =
-		    (Mpi2ConfigRequest_t *)mpi_request;
-
-		snprintf(ioc->tmp_string, MPT_STRING_LENGTH,
-		    "config, type(0x%02x), ext_type(0x%02x), number(%d)",
-		    (config_request->Header.PageType &
-		     MPI2_CONFIG_PAGETYPE_MASK), config_request->ExtPageType,
-		    config_request->Header.PageNumber);
-		desc = ioc->tmp_string;
-		break;
-	}
-	case MPI2_FUNCTION_PORT_FACTS:
-		desc = "port_facts";
-		break;
-	case MPI2_FUNCTION_PORT_ENABLE:
-		desc = "port_enable";
-		break;
-	case MPI2_FUNCTION_EVENT_NOTIFICATION:
-		desc = "event_notification";
-		break;
-	case MPI2_FUNCTION_FW_DOWNLOAD:
-		desc = "fw_download";
-		break;
-	case MPI2_FUNCTION_FW_UPLOAD:
-		desc = "fw_upload";
-		break;
-	case MPI2_FUNCTION_RAID_ACTION:
-		desc = "raid_action";
-		break;
-	case MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH:
-	{
-		Mpi2SCSIIORequest_t *scsi_request =
-		    (Mpi2SCSIIORequest_t *)mpi_request;
-
-		snprintf(ioc->tmp_string, MPT_STRING_LENGTH,
-		    "raid_pass, cmd(0x%02x), cdb_len(%d)",
-		    scsi_request->CDB.CDB32[0],
-		    le16_to_cpu(scsi_request->IoFlags) & 0xF);
-		desc = ioc->tmp_string;
-		break;
-	}
-	case MPI2_FUNCTION_SAS_IO_UNIT_CONTROL:
-		desc = "sas_iounit_cntl";
-		break;
-	case MPI2_FUNCTION_SATA_PASSTHROUGH:
-		desc = "sata_pass";
-		break;
-	case MPI2_FUNCTION_DIAG_BUFFER_POST:
-		desc = "diag_buffer_post";
-		break;
-	case MPI2_FUNCTION_DIAG_RELEASE:
-		desc = "diag_release";
-		break;
-	case MPI2_FUNCTION_SMP_PASSTHROUGH:
-		desc = "smp_passthrough";
-		break;
-	}
-
-	if (!desc)
-		return;
-
-	printk(MPT2SAS_INFO_FMT "%s: %s, smid(%d)\n",
-	    ioc->name, calling_function_name, desc, smid);
-
-	if (!mpi_reply)
-		return;
-
-	if (mpi_reply->IOCStatus || mpi_reply->IOCLogInfo)
-		printk(MPT2SAS_INFO_FMT
-		    "\tiocstatus(0x%04x), loginfo(0x%08x)\n",
-		    ioc->name, le16_to_cpu(mpi_reply->IOCStatus),
-		    le32_to_cpu(mpi_reply->IOCLogInfo));
-
-	if (mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||
-	    mpi_request->Function ==
-	    MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH) {
-		Mpi2SCSIIOReply_t *scsi_reply =
-		    (Mpi2SCSIIOReply_t *)mpi_reply;
-		struct _sas_device *sas_device = NULL;
-		unsigned long flags;
-
-		spin_lock_irqsave(&ioc->sas_device_lock, flags);
-		sas_device = _ctl_sas_device_find_by_handle(ioc,
-		    le16_to_cpu(scsi_reply->DevHandle));
-		if (sas_device) {
-			printk(MPT2SAS_WARN_FMT "\tsas_address(0x%016llx), "
-			    "phy(%d)\n", ioc->name, (unsigned long long)
-			    sas_device->sas_address, sas_device->phy);
-			printk(MPT2SAS_WARN_FMT
-			    "\tenclosure_logical_id(0x%016llx), slot(%d)\n",
-			    ioc->name, sas_device->enclosure_logical_id,
-			    sas_device->slot);
-		}
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-		if (scsi_reply->SCSIState || scsi_reply->SCSIStatus)
-			printk(MPT2SAS_INFO_FMT
-			    "\tscsi_state(0x%02x), scsi_status"
-			    "(0x%02x)\n", ioc->name,
-			    scsi_reply->SCSIState,
-			    scsi_reply->SCSIStatus);
-	}
-}
-#endif
-
-/**
- * mpt2sas_ctl_done - ctl module completion routine
- * @ioc: per adapter object
- * @smid: system request message index
- * @msix_index: MSIX table index supplied by the OS
- * @reply: reply message frame(lower 32bit addr)
- * Context: none.
- *
- * The callback handler when using ioc->ctl_cb_idx.
- *
- * Return 1 meaning mf should be freed from _base_interrupt
- *        0 means the mf is freed from this function.
- */
-u8
-mpt2sas_ctl_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
-	u32 reply)
-{
-	MPI2DefaultReply_t *mpi_reply;
-	Mpi2SCSIIOReply_t *scsiio_reply;
-	const void *sense_data;
-	u32 sz;
-
-	if (ioc->ctl_cmds.status == MPT2_CMD_NOT_USED)
-		return 1;
-	if (ioc->ctl_cmds.smid != smid)
-		return 1;
-	ioc->ctl_cmds.status |= MPT2_CMD_COMPLETE;
-	mpi_reply = mpt2sas_base_get_reply_virt_addr(ioc, reply);
-	if (mpi_reply) {
-		memcpy(ioc->ctl_cmds.reply, mpi_reply, mpi_reply->MsgLength*4);
-		ioc->ctl_cmds.status |= MPT2_CMD_REPLY_VALID;
-		/* get sense data */
-		if (mpi_reply->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||
-		    mpi_reply->Function ==
-		    MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH) {
-			scsiio_reply = (Mpi2SCSIIOReply_t *)mpi_reply;
-			if (scsiio_reply->SCSIState &
-			    MPI2_SCSI_STATE_AUTOSENSE_VALID) {
-				sz = min_t(u32, SCSI_SENSE_BUFFERSIZE,
-				    le32_to_cpu(scsiio_reply->SenseCount));
-				sense_data = mpt2sas_base_get_sense_buffer(ioc,
-				    smid);
-				memcpy(ioc->ctl_cmds.sense, sense_data, sz);
-			}
-		}
-	}
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-	_ctl_display_some_debug(ioc, smid, "ctl_done", mpi_reply);
-#endif
-	ioc->ctl_cmds.status &= ~MPT2_CMD_PENDING;
-	complete(&ioc->ctl_cmds.done);
-	return 1;
-}
-
-/**
- * _ctl_check_event_type - determines when an event needs logging
- * @ioc: per adapter object
- * @event: firmware event
- *
- * The bitmask in ioc->event_type[] indicates which events should be
- * be saved in the driver event_log.  This bitmask is set by application.
- *
- * Returns 1 when event should be captured, or zero means no match.
- */
-static int
-_ctl_check_event_type(struct MPT2SAS_ADAPTER *ioc, u16 event)
-{
-	u16 i;
-	u32 desired_event;
-
-	if (event >= 128 || !event || !ioc->event_log)
-		return 0;
-
-	desired_event = (1 << (event % 32));
-	if (!desired_event)
-		desired_event = 1;
-	i = event / 32;
-	return desired_event & ioc->event_type[i];
-}
-
-/**
- * mpt2sas_ctl_add_to_event_log - add event
- * @ioc: per adapter object
- * @mpi_reply: reply message frame
- *
- * Return nothing.
- */
-void
-mpt2sas_ctl_add_to_event_log(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventNotificationReply_t *mpi_reply)
-{
-	struct MPT2_IOCTL_EVENTS *event_log;
-	u16 event;
-	int i;
-	u32 sz, event_data_sz;
-	u8 send_aen = 0;
-
-	if (!ioc->event_log)
-		return;
-
-	event = le16_to_cpu(mpi_reply->Event);
-
-	if (_ctl_check_event_type(ioc, event)) {
-
-		/* insert entry into circular event_log */
-		i = ioc->event_context % MPT2SAS_CTL_EVENT_LOG_SIZE;
-		event_log = ioc->event_log;
-		event_log[i].event = event;
-		event_log[i].context = ioc->event_context++;
-
-		event_data_sz = le16_to_cpu(mpi_reply->EventDataLength)*4;
-		sz = min_t(u32, event_data_sz, MPT2_EVENT_DATA_SIZE);
-		memset(event_log[i].data, 0, MPT2_EVENT_DATA_SIZE);
-		memcpy(event_log[i].data, mpi_reply->EventData, sz);
-		send_aen = 1;
-	}
-
-	/* This aen_event_read_flag flag is set until the
-	 * application has read the event log.
-	 * For MPI2_EVENT_LOG_ENTRY_ADDED, we always notify.
-	 */
-	if (event == MPI2_EVENT_LOG_ENTRY_ADDED ||
-	    (send_aen && !ioc->aen_event_read_flag)) {
-		ioc->aen_event_read_flag = 1;
-		wake_up_interruptible(&ctl_poll_wait);
-		if (async_queue)
-			kill_fasync(&async_queue, SIGIO, POLL_IN);
-	}
-}
-
-/**
- * mpt2sas_ctl_event_callback - firmware event handler (called at ISR time)
- * @ioc: per adapter object
- * @msix_index: MSIX table index supplied by the OS
- * @reply: reply message frame(lower 32bit addr)
- * Context: interrupt.
- *
- * This function merely adds a new work task into ioc->firmware_event_thread.
- * The tasks are worked from _firmware_event_work in user context.
- *
- * Returns void.
- */
-void
-mpt2sas_ctl_event_callback(struct MPT2SAS_ADAPTER *ioc, u8 msix_index,
-	u32 reply)
-{
-	Mpi2EventNotificationReply_t *mpi_reply;
-
-	mpi_reply = mpt2sas_base_get_reply_virt_addr(ioc, reply);
-	if (unlikely(!mpi_reply)) {
-		printk(MPT2SAS_ERR_FMT "mpi_reply not valid at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return;
-	}
-	mpt2sas_ctl_add_to_event_log(ioc, mpi_reply);
-	return;
-}
-
-/**
- * _ctl_verify_adapter - validates ioc_number passed from application
- * @ioc: per adapter object
- * @iocpp: The ioc pointer is returned in this.
- *
- * Return (-1) means error, else ioc_number.
- */
-static int
-_ctl_verify_adapter(int ioc_number, struct MPT2SAS_ADAPTER **iocpp)
-{
-	struct MPT2SAS_ADAPTER *ioc;
-	/* global ioc lock to protect controller on list operations */
-	spin_lock(&gioc_lock);
-	list_for_each_entry(ioc, &mpt2sas_ioc_list, list) {
-		if (ioc->id != ioc_number)
-			continue;
-		spin_unlock(&gioc_lock);
-		*iocpp = ioc;
-		return ioc_number;
-	}
-	spin_unlock(&gioc_lock);
-	*iocpp = NULL;
-	return -1;
-}
-
-/**
- * mpt2sas_ctl_reset_handler - reset callback handler (for ctl)
- * @ioc: per adapter object
- * @reset_phase: phase
- *
- * The handler for doing any required cleanup or initialization.
- *
- * The reset phase can be MPT2_IOC_PRE_RESET, MPT2_IOC_AFTER_RESET,
- * MPT2_IOC_DONE_RESET
- */
-void
-mpt2sas_ctl_reset_handler(struct MPT2SAS_ADAPTER *ioc, int reset_phase)
-{
-	int i;
-	u8 issue_reset;
-
-	switch (reset_phase) {
-	case MPT2_IOC_PRE_RESET:
-		dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-		    "MPT2_IOC_PRE_RESET\n", ioc->name, __func__));
-		for (i = 0; i < MPI2_DIAG_BUF_TYPE_COUNT; i++) {
-			if (!(ioc->diag_buffer_status[i] &
-			    MPT2_DIAG_BUFFER_IS_REGISTERED))
-				continue;
-			if ((ioc->diag_buffer_status[i] &
-			    MPT2_DIAG_BUFFER_IS_RELEASED))
-				continue;
-			_ctl_send_release(ioc, i, &issue_reset);
-		}
-		break;
-	case MPT2_IOC_AFTER_RESET:
-		dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-		    "MPT2_IOC_AFTER_RESET\n", ioc->name, __func__));
-		if (ioc->ctl_cmds.status & MPT2_CMD_PENDING) {
-			ioc->ctl_cmds.status |= MPT2_CMD_RESET;
-			mpt2sas_base_free_smid(ioc, ioc->ctl_cmds.smid);
-			complete(&ioc->ctl_cmds.done);
-		}
-		break;
-	case MPT2_IOC_DONE_RESET:
-		dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-		    "MPT2_IOC_DONE_RESET\n", ioc->name, __func__));
-
-		for (i = 0; i < MPI2_DIAG_BUF_TYPE_COUNT; i++) {
-			if (!(ioc->diag_buffer_status[i] &
-			    MPT2_DIAG_BUFFER_IS_REGISTERED))
-				continue;
-			if ((ioc->diag_buffer_status[i] &
-			    MPT2_DIAG_BUFFER_IS_RELEASED))
-				continue;
-			ioc->diag_buffer_status[i] |=
-			    MPT2_DIAG_BUFFER_IS_DIAG_RESET;
-		}
-		break;
-	}
-}
-
-/**
- * _ctl_fasync -
- * @fd -
- * @filep -
- * @mode -
- *
- * Called when application request fasyn callback handler.
- */
-static int
-_ctl_fasync(int fd, struct file *filep, int mode)
-{
-	return fasync_helper(fd, filep, mode, &async_queue);
-}
-
-/**
- * _ctl_poll -
- * @file -
- * @wait -
- *
- */
-static unsigned int
-_ctl_poll(struct file *filep, poll_table *wait)
-{
-	struct MPT2SAS_ADAPTER *ioc;
-
-	poll_wait(filep, &ctl_poll_wait, wait);
-
-	/* global ioc lock to protect controller on list operations */
-	spin_lock(&gioc_lock);
-	list_for_each_entry(ioc, &mpt2sas_ioc_list, list) {
-		if (ioc->aen_event_read_flag) {
-			spin_unlock(&gioc_lock);
-			return POLLIN | POLLRDNORM;
-		}
-	}
-	spin_unlock(&gioc_lock);
-	return 0;
-}
-
-/**
- * _ctl_set_task_mid - assign an active smid to tm request
- * @ioc: per adapter object
- * @karg - (struct mpt2_ioctl_command)
- * @tm_request - pointer to mf from user space
- *
- * Returns 0 when an smid if found, else fail.
- * during failure, the reply frame is filled.
- */
-static int
-_ctl_set_task_mid(struct MPT2SAS_ADAPTER *ioc, struct mpt2_ioctl_command *karg,
-    Mpi2SCSITaskManagementRequest_t *tm_request)
-{
-	u8 found = 0;
-	u16 i;
-	u16 handle;
-	struct scsi_cmnd *scmd;
-	struct MPT2SAS_DEVICE *priv_data;
-	unsigned long flags;
-	Mpi2SCSITaskManagementReply_t *tm_reply;
-	u32 sz;
-	u32 lun;
-	char *desc = NULL;
-
-	if (tm_request->TaskType == MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK)
-		desc = "abort_task";
-	else if (tm_request->TaskType == MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK)
-		desc = "query_task";
-	else
-		return 0;
-
-	lun = scsilun_to_int((struct scsi_lun *)tm_request->LUN);
-
-	handle = le16_to_cpu(tm_request->DevHandle);
-	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-	for (i = ioc->scsiio_depth; i && !found; i--) {
-		scmd = ioc->scsi_lookup[i - 1].scmd;
-		if (scmd == NULL || scmd->device == NULL ||
-		    scmd->device->hostdata == NULL)
-			continue;
-		if (lun != scmd->device->lun)
-			continue;
-		priv_data = scmd->device->hostdata;
-		if (priv_data->sas_target == NULL)
-			continue;
-		if (priv_data->sas_target->handle != handle)
-			continue;
-		tm_request->TaskMID = cpu_to_le16(ioc->scsi_lookup[i - 1].smid);
-		found = 1;
-	}
-	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-
-	if (!found) {
-		dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-		    "handle(0x%04x), lun(%d), no active mid!!\n", ioc->name,
-		    desc, le16_to_cpu(tm_request->DevHandle), lun));
-		tm_reply = ioc->ctl_cmds.reply;
-		tm_reply->DevHandle = tm_request->DevHandle;
-		tm_reply->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;
-		tm_reply->TaskType = tm_request->TaskType;
-		tm_reply->MsgLength = sizeof(Mpi2SCSITaskManagementReply_t)/4;
-		tm_reply->VP_ID = tm_request->VP_ID;
-		tm_reply->VF_ID = tm_request->VF_ID;
-		sz = min_t(u32, karg->max_reply_bytes, ioc->reply_sz);
-		if (copy_to_user(karg->reply_frame_buf_ptr, ioc->ctl_cmds.reply,
-		    sz))
-			printk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,
-			    __LINE__, __func__);
-		return 1;
-	}
-
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-	    "handle(0x%04x), lun(%d), task_mid(%d)\n", ioc->name,
-	    desc, le16_to_cpu(tm_request->DevHandle), lun,
-	     le16_to_cpu(tm_request->TaskMID)));
-	return 0;
-}
-
-/**
- * _ctl_do_mpt_command - main handler for MPT2COMMAND opcode
- * @ioc: per adapter object
- * @karg - (struct mpt2_ioctl_command)
- * @mf - pointer to mf in user space
- */
-static long
-_ctl_do_mpt_command(struct MPT2SAS_ADAPTER *ioc, struct mpt2_ioctl_command karg,
-	void __user *mf)
-{
-	MPI2RequestHeader_t *mpi_request = NULL, *request;
-	MPI2DefaultReply_t *mpi_reply;
-	u32 ioc_state;
-	u16 ioc_status;
-	u16 smid;
-	unsigned long timeout, timeleft;
-	u8 issue_reset;
-	u32 sz;
-	void *psge;
-	void *data_out = NULL;
-	dma_addr_t data_out_dma;
-	size_t data_out_sz = 0;
-	void *data_in = NULL;
-	dma_addr_t data_in_dma;
-	size_t data_in_sz = 0;
-	u32 sgl_flags;
-	long ret;
-	u16 wait_state_count;
-
-	issue_reset = 0;
-
-	if (ioc->ctl_cmds.status != MPT2_CMD_NOT_USED) {
-		printk(MPT2SAS_ERR_FMT "%s: ctl_cmd in use\n",
-		    ioc->name, __func__);
-		ret = -EAGAIN;
-		goto out;
-	}
-
-	wait_state_count = 0;
-	ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
-		if (wait_state_count++ == 10) {
-			printk(MPT2SAS_ERR_FMT
-			    "%s: failed due to ioc not operational\n",
-			    ioc->name, __func__);
-			ret = -EFAULT;
-			goto out;
-		}
-		ssleep(1);
-		ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-		printk(MPT2SAS_INFO_FMT "%s: waiting for "
-		    "operational state(count=%d)\n", ioc->name,
-		    __func__, wait_state_count);
-	}
-	if (wait_state_count)
-		printk(MPT2SAS_INFO_FMT "%s: ioc is operational\n",
-		    ioc->name, __func__);
-
-	mpi_request = kzalloc(ioc->request_sz, GFP_KERNEL);
-	if (!mpi_request) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a memory for "
-		    "mpi_request\n", ioc->name, __func__);
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	/* Check for overflow and wraparound */
-	if (karg.data_sge_offset * 4 > ioc->request_sz ||
-	    karg.data_sge_offset > (UINT_MAX / 4)) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	/* copy in request message frame from user */
-	if (copy_from_user(mpi_request, mf, karg.data_sge_offset*4)) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__, __LINE__,
-		    __func__);
-		ret = -EFAULT;
-		goto out;
-	}
-
-	if (mpi_request->Function == MPI2_FUNCTION_SCSI_TASK_MGMT) {
-		smid = mpt2sas_base_get_smid_hpr(ioc, ioc->ctl_cb_idx);
-		if (!smid) {
-			printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-			    ioc->name, __func__);
-			ret = -EAGAIN;
-			goto out;
-		}
-	} else {
-
-		smid = mpt2sas_base_get_smid_scsiio(ioc, ioc->ctl_cb_idx, NULL);
-		if (!smid) {
-			printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-			    ioc->name, __func__);
-			ret = -EAGAIN;
-			goto out;
-		}
-	}
-
-	ret = 0;
-	ioc->ctl_cmds.status = MPT2_CMD_PENDING;
-	memset(ioc->ctl_cmds.reply, 0, ioc->reply_sz);
-	request = mpt2sas_base_get_msg_frame(ioc, smid);
-	memcpy(request, mpi_request, karg.data_sge_offset*4);
-	ioc->ctl_cmds.smid = smid;
-	data_out_sz = karg.data_out_size;
-	data_in_sz = karg.data_in_size;
-
-	if (mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||
-	    mpi_request->Function == MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH) {
-		if (!le16_to_cpu(mpi_request->FunctionDependent1) ||
-		    le16_to_cpu(mpi_request->FunctionDependent1) >
-		    ioc->facts.MaxDevHandle) {
-			ret = -EINVAL;
-			mpt2sas_base_free_smid(ioc, smid);
-			goto out;
-		}
-	}
-
-	/* obtain dma-able memory for data transfer */
-	if (data_out_sz) /* WRITE */ {
-		data_out = pci_alloc_consistent(ioc->pdev, data_out_sz,
-		    &data_out_dma);
-		if (!data_out) {
-			printk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,
-			    __LINE__, __func__);
-			ret = -ENOMEM;
-			mpt2sas_base_free_smid(ioc, smid);
-			goto out;
-		}
-		if (copy_from_user(data_out, karg.data_out_buf_ptr,
-			data_out_sz)) {
-			printk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,
-			    __LINE__, __func__);
-			ret =  -EFAULT;
-			mpt2sas_base_free_smid(ioc, smid);
-			goto out;
-		}
-	}
-
-	if (data_in_sz) /* READ */ {
-		data_in = pci_alloc_consistent(ioc->pdev, data_in_sz,
-		    &data_in_dma);
-		if (!data_in) {
-			printk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,
-			    __LINE__, __func__);
-			ret = -ENOMEM;
-			mpt2sas_base_free_smid(ioc, smid);
-			goto out;
-		}
-	}
-
-	/* add scatter gather elements */
-	psge = (void *)request + (karg.data_sge_offset*4);
-
-	if (!data_out_sz && !data_in_sz) {
-		mpt2sas_base_build_zero_len_sge(ioc, psge);
-	} else if (data_out_sz && data_in_sz) {
-		/* WRITE sgel first */
-		sgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |
-		    MPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_HOST_TO_IOC);
-		sgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;
-		ioc->base_add_sg_single(psge, sgl_flags |
-		    data_out_sz, data_out_dma);
-
-		/* incr sgel */
-		psge += ioc->sge_size;
-
-		/* READ sgel last */
-		sgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |
-		    MPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |
-		    MPI2_SGE_FLAGS_END_OF_LIST);
-		sgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;
-		ioc->base_add_sg_single(psge, sgl_flags |
-		    data_in_sz, data_in_dma);
-	} else if (data_out_sz) /* WRITE */ {
-		sgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |
-		    MPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |
-		    MPI2_SGE_FLAGS_END_OF_LIST | MPI2_SGE_FLAGS_HOST_TO_IOC);
-		sgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;
-		ioc->base_add_sg_single(psge, sgl_flags |
-		    data_out_sz, data_out_dma);
-	} else if (data_in_sz) /* READ */ {
-		sgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |
-		    MPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |
-		    MPI2_SGE_FLAGS_END_OF_LIST);
-		sgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;
-		ioc->base_add_sg_single(psge, sgl_flags |
-		    data_in_sz, data_in_dma);
-	}
-
-	/* send command to firmware */
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-	_ctl_display_some_debug(ioc, smid, "ctl_request", NULL);
-#endif
-
-	init_completion(&ioc->ctl_cmds.done);
-	switch (mpi_request->Function) {
-	case MPI2_FUNCTION_SCSI_IO_REQUEST:
-	case MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH:
-	{
-		Mpi2SCSIIORequest_t *scsiio_request =
-		    (Mpi2SCSIIORequest_t *)request;
-		scsiio_request->SenseBufferLength = SCSI_SENSE_BUFFERSIZE;
-		scsiio_request->SenseBufferLowAddress =
-		    mpt2sas_base_get_sense_buffer_dma(ioc, smid);
-		memset(ioc->ctl_cmds.sense, 0, SCSI_SENSE_BUFFERSIZE);
-		if (mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST)
-			mpt2sas_base_put_smid_scsi_io(ioc, smid,
-			    le16_to_cpu(mpi_request->FunctionDependent1));
-		else
-			mpt2sas_base_put_smid_default(ioc, smid);
-		break;
-	}
-	case MPI2_FUNCTION_SCSI_TASK_MGMT:
-	{
-		Mpi2SCSITaskManagementRequest_t *tm_request =
-		    (Mpi2SCSITaskManagementRequest_t *)request;
-
-		dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "TASK_MGMT: "
-		    "handle(0x%04x), task_type(0x%02x)\n", ioc->name,
-		    le16_to_cpu(tm_request->DevHandle), tm_request->TaskType));
-
-		if (tm_request->TaskType ==
-		    MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK ||
-		    tm_request->TaskType ==
-		    MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK) {
-			if (_ctl_set_task_mid(ioc, &karg, tm_request)) {
-				mpt2sas_base_free_smid(ioc, smid);
-				goto out;
-			}
-		}
-
-		mpt2sas_scsih_set_tm_flag(ioc, le16_to_cpu(
-		    tm_request->DevHandle));
-		mpt2sas_base_put_smid_hi_priority(ioc, smid);
-		break;
-	}
-	case MPI2_FUNCTION_SMP_PASSTHROUGH:
-	{
-		Mpi2SmpPassthroughRequest_t *smp_request =
-		    (Mpi2SmpPassthroughRequest_t *)mpi_request;
-		u8 *data;
-
-		/* ioc determines which port to use */
-		smp_request->PhysicalPort = 0xFF;
-		if (smp_request->PassthroughFlags &
-		    MPI2_SMP_PT_REQ_PT_FLAGS_IMMEDIATE)
-			data = (u8 *)&smp_request->SGL;
-		else {
-			if (unlikely(data_out == NULL)) {
-				printk(KERN_ERR "failure at %s:%d/%s()!\n",
-				    __FILE__, __LINE__, __func__);
-				mpt2sas_base_free_smid(ioc, smid);
-				ret = -EINVAL;
-				goto out;
-			}
-			data = data_out;
-		}
-
-		if (data[1] == 0x91 && (data[10] == 1 || data[10] == 2)) {
-			ioc->ioc_link_reset_in_progress = 1;
-			ioc->ignore_loginfos = 1;
-		}
-		mpt2sas_base_put_smid_default(ioc, smid);
-		break;
-	}
-	case MPI2_FUNCTION_SAS_IO_UNIT_CONTROL:
-	{
-		Mpi2SasIoUnitControlRequest_t *sasiounit_request =
-		    (Mpi2SasIoUnitControlRequest_t *)mpi_request;
-
-		if (sasiounit_request->Operation == MPI2_SAS_OP_PHY_HARD_RESET
-		    || sasiounit_request->Operation ==
-		    MPI2_SAS_OP_PHY_LINK_RESET) {
-			ioc->ioc_link_reset_in_progress = 1;
-			ioc->ignore_loginfos = 1;
-		}
-		mpt2sas_base_put_smid_default(ioc, smid);
-		break;
-	}
-	default:
-		mpt2sas_base_put_smid_default(ioc, smid);
-		break;
-	}
-
-	if (karg.timeout < MPT2_IOCTL_DEFAULT_TIMEOUT)
-		timeout = MPT2_IOCTL_DEFAULT_TIMEOUT;
-	else
-		timeout = karg.timeout;
-	timeleft = wait_for_completion_timeout(&ioc->ctl_cmds.done,
-	    timeout*HZ);
-	if (mpi_request->Function == MPI2_FUNCTION_SCSI_TASK_MGMT) {
-		Mpi2SCSITaskManagementRequest_t *tm_request =
-		    (Mpi2SCSITaskManagementRequest_t *)mpi_request;
-		mpt2sas_scsih_clear_tm_flag(ioc, le16_to_cpu(
-		    tm_request->DevHandle));
-	} else if ((mpi_request->Function == MPI2_FUNCTION_SMP_PASSTHROUGH ||
-	    mpi_request->Function == MPI2_FUNCTION_SAS_IO_UNIT_CONTROL) &&
-		ioc->ioc_link_reset_in_progress) {
-		ioc->ioc_link_reset_in_progress = 0;
-		ioc->ignore_loginfos = 0;
-	}
-	if (!(ioc->ctl_cmds.status & MPT2_CMD_COMPLETE)) {
-		printk(MPT2SAS_ERR_FMT "%s: timeout\n", ioc->name,
-		    __func__);
-		_debug_dump_mf(mpi_request, karg.data_sge_offset);
-		if (!(ioc->ctl_cmds.status & MPT2_CMD_RESET))
-			issue_reset = 1;
-		goto issue_host_reset;
-	}
-
-	mpi_reply = ioc->ctl_cmds.reply;
-	ioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-	if (mpi_reply->Function == MPI2_FUNCTION_SCSI_TASK_MGMT &&
-	    (ioc->logging_level & MPT_DEBUG_TM)) {
-		Mpi2SCSITaskManagementReply_t *tm_reply =
-		    (Mpi2SCSITaskManagementReply_t *)mpi_reply;
-
-		printk(MPT2SAS_INFO_FMT "TASK_MGMT: "
-		    "IOCStatus(0x%04x), IOCLogInfo(0x%08x), "
-		    "TerminationCount(0x%08x)\n", ioc->name,
-		    le16_to_cpu(tm_reply->IOCStatus),
-		    le32_to_cpu(tm_reply->IOCLogInfo),
-		    le32_to_cpu(tm_reply->TerminationCount));
-	}
-#endif
-	/* copy out xdata to user */
-	if (data_in_sz) {
-		if (copy_to_user(karg.data_in_buf_ptr, data_in,
-		    data_in_sz)) {
-			printk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,
-			    __LINE__, __func__);
-			ret = -ENODATA;
-			goto out;
-		}
-	}
-
-	/* copy out reply message frame to user */
-	if (karg.max_reply_bytes) {
-		sz = min_t(u32, karg.max_reply_bytes, ioc->reply_sz);
-		if (copy_to_user(karg.reply_frame_buf_ptr, ioc->ctl_cmds.reply,
-		    sz)) {
-			printk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,
-			    __LINE__, __func__);
-			ret = -ENODATA;
-			goto out;
-		}
-	}
-
-	/* copy out sense to user */
-	if (karg.max_sense_bytes && (mpi_request->Function ==
-	    MPI2_FUNCTION_SCSI_IO_REQUEST || mpi_request->Function ==
-	    MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) {
-		sz = min_t(u32, karg.max_sense_bytes, SCSI_SENSE_BUFFERSIZE);
-		if (copy_to_user(karg.sense_data_ptr,
-			ioc->ctl_cmds.sense, sz)) {
-			printk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,
-			    __LINE__, __func__);
-			ret = -ENODATA;
-			goto out;
-		}
-	}
-
- issue_host_reset:
-	if (issue_reset) {
-		ret = -ENODATA;
-		if ((mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||
-		    mpi_request->Function ==
-		    MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH ||
-		    mpi_request->Function == MPI2_FUNCTION_SATA_PASSTHROUGH)) {
-			printk(MPT2SAS_INFO_FMT "issue target reset: handle "
-			    "= (0x%04x)\n", ioc->name,
-			    le16_to_cpu(mpi_request->FunctionDependent1));
-			mpt2sas_halt_firmware(ioc);
-			mpt2sas_scsih_issue_tm(ioc,
-			    le16_to_cpu(mpi_request->FunctionDependent1), 0, 0,
-			    0, MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET, 0, 10,
-			    TM_MUTEX_ON);
-			ioc->tm_cmds.status = MPT2_CMD_NOT_USED;
-		} else
-			mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-			    FORCE_BIG_HAMMER);
-	}
-
- out:
-
-	/* free memory associated with sg buffers */
-	if (data_in)
-		pci_free_consistent(ioc->pdev, data_in_sz, data_in,
-		    data_in_dma);
-
-	if (data_out)
-		pci_free_consistent(ioc->pdev, data_out_sz, data_out,
-		    data_out_dma);
-
-	kfree(mpi_request);
-	ioc->ctl_cmds.status = MPT2_CMD_NOT_USED;
-	return ret;
-}
-
-/**
- * _ctl_getiocinfo - main handler for MPT2IOCINFO opcode
- * @ioc: per adapter object
- * @arg - user space buffer containing ioctl content
- */
-static long
-_ctl_getiocinfo(struct MPT2SAS_ADAPTER *ioc, void __user *arg)
-{
-	struct mpt2_ioctl_iocinfo karg;
-
-	if (copy_from_user(&karg, arg, sizeof(karg))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: enter\n", ioc->name,
-	    __func__));
-
-	memset(&karg, 0 , sizeof(karg));
-	if (ioc->is_warpdrive)
-		karg.adapter_type = MPT2_IOCTL_INTERFACE_SAS2_SSS6200;
-	else
-		karg.adapter_type = MPT2_IOCTL_INTERFACE_SAS2;
-	if (ioc->pfacts)
-		karg.port_number = ioc->pfacts[0].PortNumber;
-	karg.hw_rev = ioc->pdev->revision;
-	karg.pci_id = ioc->pdev->device;
-	karg.subsystem_device = ioc->pdev->subsystem_device;
-	karg.subsystem_vendor = ioc->pdev->subsystem_vendor;
-	karg.pci_information.u.bits.bus = ioc->pdev->bus->number;
-	karg.pci_information.u.bits.device = PCI_SLOT(ioc->pdev->devfn);
-	karg.pci_information.u.bits.function = PCI_FUNC(ioc->pdev->devfn);
-	karg.pci_information.segment_id = pci_domain_nr(ioc->pdev->bus);
-	karg.firmware_version = ioc->facts.FWVersion.Word;
-	strcpy(karg.driver_version, MPT2SAS_DRIVER_NAME);
-	strcat(karg.driver_version, "-");
-	strcat(karg.driver_version, MPT2SAS_DRIVER_VERSION);
-	karg.bios_version = le32_to_cpu(ioc->bios_pg3.BiosVersion);
-
-	if (copy_to_user(arg, &karg, sizeof(karg))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-	return 0;
-}
-
-/**
- * _ctl_eventquery - main handler for MPT2EVENTQUERY opcode
- * @ioc: per adapter object
- * @arg - user space buffer containing ioctl content
- */
-static long
-_ctl_eventquery(struct MPT2SAS_ADAPTER *ioc, void __user *arg)
-{
-	struct mpt2_ioctl_eventquery karg;
-
-	if (copy_from_user(&karg, arg, sizeof(karg))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: enter\n", ioc->name,
-	    __func__));
-
-	karg.event_entries = MPT2SAS_CTL_EVENT_LOG_SIZE;
-	memcpy(karg.event_types, ioc->event_type,
-	    MPI2_EVENT_NOTIFY_EVENTMASK_WORDS * sizeof(u32));
-
-	if (copy_to_user(arg, &karg, sizeof(karg))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-	return 0;
-}
-
-/**
- * _ctl_eventenable - main handler for MPT2EVENTENABLE opcode
- * @ioc: per adapter object
- * @arg - user space buffer containing ioctl content
- */
-static long
-_ctl_eventenable(struct MPT2SAS_ADAPTER *ioc, void __user *arg)
-{
-	struct mpt2_ioctl_eventenable karg;
-
-	if (copy_from_user(&karg, arg, sizeof(karg))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: enter\n", ioc->name,
-	    __func__));
-
-	if (ioc->event_log)
-		return 0;
-	memcpy(ioc->event_type, karg.event_types,
-	    MPI2_EVENT_NOTIFY_EVENTMASK_WORDS * sizeof(u32));
-	mpt2sas_base_validate_event_type(ioc, ioc->event_type);
-
-	/* initialize event_log */
-	ioc->event_context = 0;
-	ioc->aen_event_read_flag = 0;
-	ioc->event_log = kcalloc(MPT2SAS_CTL_EVENT_LOG_SIZE,
-	    sizeof(struct MPT2_IOCTL_EVENTS), GFP_KERNEL);
-	if (!ioc->event_log) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -ENOMEM;
-	}
-	return 0;
-}
-
-/**
- * _ctl_eventreport - main handler for MPT2EVENTREPORT opcode
- * @ioc: per adapter object
- * @arg - user space buffer containing ioctl content
- */
-static long
-_ctl_eventreport(struct MPT2SAS_ADAPTER *ioc, void __user *arg)
-{
-	struct mpt2_ioctl_eventreport karg;
-	u32 number_bytes, max_events, max;
-	struct mpt2_ioctl_eventreport __user *uarg = arg;
-
-	if (copy_from_user(&karg, arg, sizeof(karg))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: enter\n", ioc->name,
-	    __func__));
-
-	number_bytes = karg.hdr.max_data_size -
-	    sizeof(struct mpt2_ioctl_header);
-	max_events = number_bytes/sizeof(struct MPT2_IOCTL_EVENTS);
-	max = min_t(u32, MPT2SAS_CTL_EVENT_LOG_SIZE, max_events);
-
-	/* If fewer than 1 event is requested, there must have
-	 * been some type of error.
-	 */
-	if (!max || !ioc->event_log)
-		return -ENODATA;
-
-	number_bytes = max * sizeof(struct MPT2_IOCTL_EVENTS);
-	if (copy_to_user(uarg->event_data, ioc->event_log, number_bytes)) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-
-	/* reset flag so SIGIO can restart */
-	ioc->aen_event_read_flag = 0;
-	return 0;
-}
-
-/**
- * _ctl_do_reset - main handler for MPT2HARDRESET opcode
- * @ioc: per adapter object
- * @arg - user space buffer containing ioctl content
- */
-static long
-_ctl_do_reset(struct MPT2SAS_ADAPTER *ioc, void __user *arg)
-{
-	struct mpt2_ioctl_diag_reset karg;
-	int retval;
-
-	if (copy_from_user(&karg, arg, sizeof(karg))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-
-	if (ioc->shost_recovery || ioc->pci_error_recovery ||
-		ioc->is_driver_loading)
-		return -EAGAIN;
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: enter\n", ioc->name,
-	    __func__));
-
-	retval = mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-	    FORCE_BIG_HAMMER);
-	printk(MPT2SAS_INFO_FMT "host reset: %s\n",
-	    ioc->name, ((!retval) ? "SUCCESS" : "FAILED"));
-	return 0;
-}
-
-/**
- * _ctl_btdh_search_sas_device - searching for sas device
- * @ioc: per adapter object
- * @btdh: btdh ioctl payload
- */
-static int
-_ctl_btdh_search_sas_device(struct MPT2SAS_ADAPTER *ioc,
-    struct mpt2_ioctl_btdh_mapping *btdh)
-{
-	struct _sas_device *sas_device;
-	unsigned long flags;
-	int rc = 0;
-
-	if (list_empty(&ioc->sas_device_list))
-		return rc;
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	list_for_each_entry(sas_device, &ioc->sas_device_list, list) {
-		if (btdh->bus == 0xFFFFFFFF && btdh->id == 0xFFFFFFFF &&
-		    btdh->handle == sas_device->handle) {
-			btdh->bus = sas_device->channel;
-			btdh->id = sas_device->id;
-			rc = 1;
-			goto out;
-		} else if (btdh->bus == sas_device->channel && btdh->id ==
-		    sas_device->id && btdh->handle == 0xFFFF) {
-			btdh->handle = sas_device->handle;
-			rc = 1;
-			goto out;
-		}
-	}
- out:
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	return rc;
-}
-
-/**
- * _ctl_btdh_search_raid_device - searching for raid device
- * @ioc: per adapter object
- * @btdh: btdh ioctl payload
- */
-static int
-_ctl_btdh_search_raid_device(struct MPT2SAS_ADAPTER *ioc,
-    struct mpt2_ioctl_btdh_mapping *btdh)
-{
-	struct _raid_device *raid_device;
-	unsigned long flags;
-	int rc = 0;
-
-	if (list_empty(&ioc->raid_device_list))
-		return rc;
-
-	spin_lock_irqsave(&ioc->raid_device_lock, flags);
-	list_for_each_entry(raid_device, &ioc->raid_device_list, list) {
-		if (btdh->bus == 0xFFFFFFFF && btdh->id == 0xFFFFFFFF &&
-		    btdh->handle == raid_device->handle) {
-			btdh->bus = raid_device->channel;
-			btdh->id = raid_device->id;
-			rc = 1;
-			goto out;
-		} else if (btdh->bus == raid_device->channel && btdh->id ==
-		    raid_device->id && btdh->handle == 0xFFFF) {
-			btdh->handle = raid_device->handle;
-			rc = 1;
-			goto out;
-		}
-	}
- out:
-	spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-	return rc;
-}
-
-/**
- * _ctl_btdh_mapping - main handler for MPT2BTDHMAPPING opcode
- * @ioc: per adapter object
- * @arg - user space buffer containing ioctl content
- */
-static long
-_ctl_btdh_mapping(struct MPT2SAS_ADAPTER *ioc, void __user *arg)
-{
-	struct mpt2_ioctl_btdh_mapping karg;
-	int rc;
-
-	if (copy_from_user(&karg, arg, sizeof(karg))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	rc = _ctl_btdh_search_sas_device(ioc, &karg);
-	if (!rc)
-		_ctl_btdh_search_raid_device(ioc, &karg);
-
-	if (copy_to_user(arg, &karg, sizeof(karg))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-	return 0;
-}
-
-/**
- * _ctl_diag_capability - return diag buffer capability
- * @ioc: per adapter object
- * @buffer_type: specifies either TRACE, SNAPSHOT, or EXTENDED
- *
- * returns 1 when diag buffer support is enabled in firmware
- */
-static u8
-_ctl_diag_capability(struct MPT2SAS_ADAPTER *ioc, u8 buffer_type)
-{
-	u8 rc = 0;
-
-	switch (buffer_type) {
-	case MPI2_DIAG_BUF_TYPE_TRACE:
-		if (ioc->facts.IOCCapabilities &
-		    MPI2_IOCFACTS_CAPABILITY_DIAG_TRACE_BUFFER)
-			rc = 1;
-		break;
-	case MPI2_DIAG_BUF_TYPE_SNAPSHOT:
-		if (ioc->facts.IOCCapabilities &
-		    MPI2_IOCFACTS_CAPABILITY_SNAPSHOT_BUFFER)
-			rc = 1;
-		break;
-	case MPI2_DIAG_BUF_TYPE_EXTENDED:
-		if (ioc->facts.IOCCapabilities &
-		    MPI2_IOCFACTS_CAPABILITY_EXTENDED_BUFFER)
-			rc = 1;
-	}
-
-	return rc;
-}
-
-/**
- * _ctl_diag_register_2 - wrapper for registering diag buffer support
- * @ioc: per adapter object
- * @diag_register: the diag_register struct passed in from user space
- *
- */
-static long
-_ctl_diag_register_2(struct MPT2SAS_ADAPTER *ioc,
-    struct mpt2_diag_register *diag_register)
-{
-	int rc, i;
-	void *request_data = NULL;
-	dma_addr_t request_data_dma;
-	u32 request_data_sz = 0;
-	Mpi2DiagBufferPostRequest_t *mpi_request;
-	Mpi2DiagBufferPostReply_t *mpi_reply;
-	u8 buffer_type;
-	unsigned long timeleft;
-	u16 smid;
-	u16 ioc_status;
-	u8 issue_reset = 0;
-
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	if (ioc->ctl_cmds.status != MPT2_CMD_NOT_USED) {
-		printk(MPT2SAS_ERR_FMT "%s: ctl_cmd in use\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-
-	buffer_type = diag_register->buffer_type;
-	if (!_ctl_diag_capability(ioc, buffer_type)) {
-		printk(MPT2SAS_ERR_FMT "%s: doesn't have capability for "
-		    "buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);
-		return -EPERM;
-	}
-
-	if (ioc->diag_buffer_status[buffer_type] &
-	    MPT2_DIAG_BUFFER_IS_REGISTERED) {
-		printk(MPT2SAS_ERR_FMT "%s: already has a registered "
-		    "buffer for buffer_type(0x%02x)\n", ioc->name, __func__,
-		    buffer_type);
-		return -EINVAL;
-	}
-
-	if (diag_register->requested_buffer_size % 4)  {
-		printk(MPT2SAS_ERR_FMT "%s: the requested_buffer_size "
-		    "is not 4 byte aligned\n", ioc->name, __func__);
-		return -EINVAL;
-	}
-
-	smid = mpt2sas_base_get_smid(ioc, ioc->ctl_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-
-	rc = 0;
-	ioc->ctl_cmds.status = MPT2_CMD_PENDING;
-	memset(ioc->ctl_cmds.reply, 0, ioc->reply_sz);
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	ioc->ctl_cmds.smid = smid;
-
-	request_data = ioc->diag_buffer[buffer_type];
-	request_data_sz = diag_register->requested_buffer_size;
-	ioc->unique_id[buffer_type] = diag_register->unique_id;
-	ioc->diag_buffer_status[buffer_type] = 0;
-	memcpy(ioc->product_specific[buffer_type],
-	    diag_register->product_specific, MPT2_PRODUCT_SPECIFIC_DWORDS);
-	ioc->diagnostic_flags[buffer_type] = diag_register->diagnostic_flags;
-
-	if (request_data) {
-		request_data_dma = ioc->diag_buffer_dma[buffer_type];
-		if (request_data_sz != ioc->diag_buffer_sz[buffer_type]) {
-			pci_free_consistent(ioc->pdev,
-			    ioc->diag_buffer_sz[buffer_type],
-			    request_data, request_data_dma);
-			request_data = NULL;
-		}
-	}
-
-	if (request_data == NULL) {
-		ioc->diag_buffer_sz[buffer_type] = 0;
-		ioc->diag_buffer_dma[buffer_type] = 0;
-		request_data = pci_alloc_consistent(
-			ioc->pdev, request_data_sz, &request_data_dma);
-		if (request_data == NULL) {
-			printk(MPT2SAS_ERR_FMT "%s: failed allocating memory"
-			    " for diag buffers, requested size(%d)\n",
-			    ioc->name, __func__, request_data_sz);
-			mpt2sas_base_free_smid(ioc, smid);
-			return -ENOMEM;
-		}
-		ioc->diag_buffer[buffer_type] = request_data;
-		ioc->diag_buffer_sz[buffer_type] = request_data_sz;
-		ioc->diag_buffer_dma[buffer_type] = request_data_dma;
-	}
-
-	mpi_request->Function = MPI2_FUNCTION_DIAG_BUFFER_POST;
-	mpi_request->BufferType = diag_register->buffer_type;
-	mpi_request->Flags = cpu_to_le32(diag_register->diagnostic_flags);
-	mpi_request->BufferAddress = cpu_to_le64(request_data_dma);
-	mpi_request->BufferLength = cpu_to_le32(request_data_sz);
-	mpi_request->VF_ID = 0; /* TODO */
-	mpi_request->VP_ID = 0;
-
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: diag_buffer(0x%p), "
-	    "dma(0x%llx), sz(%d)\n", ioc->name, __func__, request_data,
-	    (unsigned long long)request_data_dma,
-	    le32_to_cpu(mpi_request->BufferLength)));
-
-	for (i = 0; i < MPT2_PRODUCT_SPECIFIC_DWORDS; i++)
-		mpi_request->ProductSpecific[i] =
-			cpu_to_le32(ioc->product_specific[buffer_type][i]);
-
-	init_completion(&ioc->ctl_cmds.done);
-	mpt2sas_base_put_smid_default(ioc, smid);
-	timeleft = wait_for_completion_timeout(&ioc->ctl_cmds.done,
-	    MPT2_IOCTL_DEFAULT_TIMEOUT*HZ);
-
-	if (!(ioc->ctl_cmds.status & MPT2_CMD_COMPLETE)) {
-		printk(MPT2SAS_ERR_FMT "%s: timeout\n", ioc->name,
-		    __func__);
-		_debug_dump_mf(mpi_request,
-		    sizeof(Mpi2DiagBufferPostRequest_t)/4);
-		if (!(ioc->ctl_cmds.status & MPT2_CMD_RESET))
-			issue_reset = 1;
-		goto issue_host_reset;
-	}
-
-	/* process the completed Reply Message Frame */
-	if ((ioc->ctl_cmds.status & MPT2_CMD_REPLY_VALID) == 0) {
-		printk(MPT2SAS_ERR_FMT "%s: no reply message\n",
-		    ioc->name, __func__);
-		rc = -EFAULT;
-		goto out;
-	}
-
-	mpi_reply = ioc->ctl_cmds.reply;
-	ioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;
-
-	if (ioc_status == MPI2_IOCSTATUS_SUCCESS) {
-		ioc->diag_buffer_status[buffer_type] |=
-			MPT2_DIAG_BUFFER_IS_REGISTERED;
-		dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: success\n",
-		    ioc->name, __func__));
-	} else {
-		printk(MPT2SAS_INFO_FMT "%s: ioc_status(0x%04x) "
-		    "log_info(0x%08x)\n", ioc->name, __func__,
-		    ioc_status, le32_to_cpu(mpi_reply->IOCLogInfo));
-		rc = -EFAULT;
-	}
-
- issue_host_reset:
-	if (issue_reset)
-		mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-		    FORCE_BIG_HAMMER);
-
- out:
-
-	if (rc && request_data)
-		pci_free_consistent(ioc->pdev, request_data_sz,
-		    request_data, request_data_dma);
-
-	ioc->ctl_cmds.status = MPT2_CMD_NOT_USED;
-	return rc;
-}
-
-/**
- * mpt2sas_enable_diag_buffer - enabling diag_buffers support driver load time
- * @ioc: per adapter object
- * @bits_to_register: bitwise field where trace is bit 0, and snapshot is bit 1
- *
- * This is called when command line option diag_buffer_enable is enabled
- * at driver load time.
- */
-void
-mpt2sas_enable_diag_buffer(struct MPT2SAS_ADAPTER *ioc, u8 bits_to_register)
-{
-	struct mpt2_diag_register diag_register;
-
-	memset(&diag_register, 0, sizeof(struct mpt2_diag_register));
-
-	if (bits_to_register & 1) {
-		printk(MPT2SAS_INFO_FMT "registering trace buffer support\n",
-		    ioc->name);
-		diag_register.buffer_type = MPI2_DIAG_BUF_TYPE_TRACE;
-		/* register for 1MB buffers  */
-		diag_register.requested_buffer_size = (1024 * 1024);
-		diag_register.unique_id = 0x7075900;
-		_ctl_diag_register_2(ioc,  &diag_register);
-	}
-
-	if (bits_to_register & 2) {
-		printk(MPT2SAS_INFO_FMT "registering snapshot buffer support\n",
-		    ioc->name);
-		diag_register.buffer_type = MPI2_DIAG_BUF_TYPE_SNAPSHOT;
-		/* register for 2MB buffers  */
-		diag_register.requested_buffer_size = 2 * (1024 * 1024);
-		diag_register.unique_id = 0x7075901;
-		_ctl_diag_register_2(ioc,  &diag_register);
-	}
-
-	if (bits_to_register & 4) {
-		printk(MPT2SAS_INFO_FMT "registering extended buffer support\n",
-		    ioc->name);
-		diag_register.buffer_type = MPI2_DIAG_BUF_TYPE_EXTENDED;
-		/* register for 2MB buffers  */
-		diag_register.requested_buffer_size = 2 * (1024 * 1024);
-		diag_register.unique_id = 0x7075901;
-		_ctl_diag_register_2(ioc,  &diag_register);
-	}
-}
-
-/**
- * _ctl_diag_register - application register with driver
- * @ioc: per adapter object
- * @arg - user space buffer containing ioctl content
- *
- * This will allow the driver to setup any required buffers that will be
- * needed by firmware to communicate with the driver.
- */
-static long
-_ctl_diag_register(struct MPT2SAS_ADAPTER *ioc, void __user *arg)
-{
-	struct mpt2_diag_register karg;
-	long rc;
-
-	if (copy_from_user(&karg, arg, sizeof(karg))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-
-	rc = _ctl_diag_register_2(ioc, &karg);
-	return rc;
-}
-
-/**
- * _ctl_diag_unregister - application unregister with driver
- * @ioc: per adapter object
- * @arg - user space buffer containing ioctl content
- *
- * This will allow the driver to cleanup any memory allocated for diag
- * messages and to free up any resources.
- */
-static long
-_ctl_diag_unregister(struct MPT2SAS_ADAPTER *ioc, void __user *arg)
-{
-	struct mpt2_diag_unregister karg;
-	void *request_data;
-	dma_addr_t request_data_dma;
-	u32 request_data_sz;
-	u8 buffer_type;
-
-	if (copy_from_user(&karg, arg, sizeof(karg))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	buffer_type = karg.unique_id & 0x000000ff;
-	if (!_ctl_diag_capability(ioc, buffer_type)) {
-		printk(MPT2SAS_ERR_FMT "%s: doesn't have capability for "
-		    "buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);
-		return -EPERM;
-	}
-
-	if ((ioc->diag_buffer_status[buffer_type] &
-	    MPT2_DIAG_BUFFER_IS_REGISTERED) == 0) {
-		printk(MPT2SAS_ERR_FMT "%s: buffer_type(0x%02x) is not "
-		    "registered\n", ioc->name, __func__, buffer_type);
-		return -EINVAL;
-	}
-	if ((ioc->diag_buffer_status[buffer_type] &
-	    MPT2_DIAG_BUFFER_IS_RELEASED) == 0) {
-		printk(MPT2SAS_ERR_FMT "%s: buffer_type(0x%02x) has not been "
-		    "released\n", ioc->name, __func__, buffer_type);
-		return -EINVAL;
-	}
-
-	if (karg.unique_id != ioc->unique_id[buffer_type]) {
-		printk(MPT2SAS_ERR_FMT "%s: unique_id(0x%08x) is not "
-		    "registered\n", ioc->name, __func__, karg.unique_id);
-		return -EINVAL;
-	}
-
-	request_data = ioc->diag_buffer[buffer_type];
-	if (!request_data) {
-		printk(MPT2SAS_ERR_FMT "%s: doesn't have memory allocated for "
-		    "buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);
-		return -ENOMEM;
-	}
-
-	request_data_sz = ioc->diag_buffer_sz[buffer_type];
-	request_data_dma = ioc->diag_buffer_dma[buffer_type];
-	pci_free_consistent(ioc->pdev, request_data_sz,
-	    request_data, request_data_dma);
-	ioc->diag_buffer[buffer_type] = NULL;
-	ioc->diag_buffer_status[buffer_type] = 0;
-	return 0;
-}
-
-/**
- * _ctl_diag_query - query relevant info associated with diag buffers
- * @ioc: per adapter object
- * @arg - user space buffer containing ioctl content
- *
- * The application will send only buffer_type and unique_id.  Driver will
- * inspect unique_id first, if valid, fill in all the info.  If unique_id is
- * 0x00, the driver will return info specified by Buffer Type.
- */
-static long
-_ctl_diag_query(struct MPT2SAS_ADAPTER *ioc, void __user *arg)
-{
-	struct mpt2_diag_query karg;
-	void *request_data;
-	int i;
-	u8 buffer_type;
-
-	if (copy_from_user(&karg, arg, sizeof(karg))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	karg.application_flags = 0;
-	buffer_type = karg.buffer_type;
-
-	if (!_ctl_diag_capability(ioc, buffer_type)) {
-		printk(MPT2SAS_ERR_FMT "%s: doesn't have capability for "
-		    "buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);
-		return -EPERM;
-	}
-
-	if ((ioc->diag_buffer_status[buffer_type] &
-	    MPT2_DIAG_BUFFER_IS_REGISTERED) == 0) {
-		printk(MPT2SAS_ERR_FMT "%s: buffer_type(0x%02x) is not "
-		    "registered\n", ioc->name, __func__, buffer_type);
-		return -EINVAL;
-	}
-
-	if (karg.unique_id & 0xffffff00) {
-		if (karg.unique_id != ioc->unique_id[buffer_type]) {
-			printk(MPT2SAS_ERR_FMT "%s: unique_id(0x%08x) is not "
-			    "registered\n", ioc->name, __func__,
-			    karg.unique_id);
-			return -EINVAL;
-		}
-	}
-
-	request_data = ioc->diag_buffer[buffer_type];
-	if (!request_data) {
-		printk(MPT2SAS_ERR_FMT "%s: doesn't have buffer for "
-		    "buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);
-		return -ENOMEM;
-	}
-
-	if (ioc->diag_buffer_status[buffer_type] & MPT2_DIAG_BUFFER_IS_RELEASED)
-		karg.application_flags = (MPT2_APP_FLAGS_APP_OWNED |
-		    MPT2_APP_FLAGS_BUFFER_VALID);
-	else
-		karg.application_flags = (MPT2_APP_FLAGS_APP_OWNED |
-		    MPT2_APP_FLAGS_BUFFER_VALID |
-		    MPT2_APP_FLAGS_FW_BUFFER_ACCESS);
-
-	for (i = 0; i < MPT2_PRODUCT_SPECIFIC_DWORDS; i++)
-		karg.product_specific[i] =
-		    ioc->product_specific[buffer_type][i];
-
-	karg.total_buffer_size = ioc->diag_buffer_sz[buffer_type];
-	karg.driver_added_buffer_size = 0;
-	karg.unique_id = ioc->unique_id[buffer_type];
-	karg.diagnostic_flags = ioc->diagnostic_flags[buffer_type];
-
-	if (copy_to_user(arg, &karg, sizeof(struct mpt2_diag_query))) {
-		printk(MPT2SAS_ERR_FMT "%s: unable to write mpt2_diag_query "
-		    "data @ %p\n", ioc->name, __func__, arg);
-		return -EFAULT;
-	}
-	return 0;
-}
-
-/**
- * _ctl_send_release - Diag Release Message
- * @ioc: per adapter object
- * @buffer_type - specifies either TRACE, SNAPSHOT, or EXTENDED
- * @issue_reset - specifies whether host reset is required.
- *
- */
-static int
-_ctl_send_release(struct MPT2SAS_ADAPTER *ioc, u8 buffer_type, u8 *issue_reset)
-{
-	Mpi2DiagReleaseRequest_t *mpi_request;
-	Mpi2DiagReleaseReply_t *mpi_reply;
-	u16 smid;
-	u16 ioc_status;
-	u32 ioc_state;
-	int rc;
-	unsigned long timeleft;
-
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	rc = 0;
-	*issue_reset = 0;
-
-	ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-	if (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
-		dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-		    "skipping due to FAULT state\n", ioc->name,
-		    __func__));
-		rc = -EAGAIN;
-		goto out;
-	}
-
-	if (ioc->ctl_cmds.status != MPT2_CMD_NOT_USED) {
-		printk(MPT2SAS_ERR_FMT "%s: ctl_cmd in use\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-
-	smid = mpt2sas_base_get_smid(ioc, ioc->ctl_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-
-	ioc->ctl_cmds.status = MPT2_CMD_PENDING;
-	memset(ioc->ctl_cmds.reply, 0, ioc->reply_sz);
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	ioc->ctl_cmds.smid = smid;
-
-	mpi_request->Function = MPI2_FUNCTION_DIAG_RELEASE;
-	mpi_request->BufferType = buffer_type;
-	mpi_request->VF_ID = 0; /* TODO */
-	mpi_request->VP_ID = 0;
-
-	init_completion(&ioc->ctl_cmds.done);
-	mpt2sas_base_put_smid_default(ioc, smid);
-	timeleft = wait_for_completion_timeout(&ioc->ctl_cmds.done,
-	    MPT2_IOCTL_DEFAULT_TIMEOUT*HZ);
-
-	if (!(ioc->ctl_cmds.status & MPT2_CMD_COMPLETE)) {
-		printk(MPT2SAS_ERR_FMT "%s: timeout\n", ioc->name,
-		    __func__);
-		_debug_dump_mf(mpi_request,
-		    sizeof(Mpi2DiagReleaseRequest_t)/4);
-		if (!(ioc->ctl_cmds.status & MPT2_CMD_RESET))
-			*issue_reset = 1;
-		rc = -EFAULT;
-		goto out;
-	}
-
-	/* process the completed Reply Message Frame */
-	if ((ioc->ctl_cmds.status & MPT2_CMD_REPLY_VALID) == 0) {
-		printk(MPT2SAS_ERR_FMT "%s: no reply message\n",
-		    ioc->name, __func__);
-		rc = -EFAULT;
-		goto out;
-	}
-
-	mpi_reply = ioc->ctl_cmds.reply;
-	ioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;
-
-	if (ioc_status == MPI2_IOCSTATUS_SUCCESS) {
-		ioc->diag_buffer_status[buffer_type] |=
-		    MPT2_DIAG_BUFFER_IS_RELEASED;
-		dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: success\n",
-		    ioc->name, __func__));
-	} else {
-		printk(MPT2SAS_INFO_FMT "%s: ioc_status(0x%04x) "
-		    "log_info(0x%08x)\n", ioc->name, __func__,
-		    ioc_status, le32_to_cpu(mpi_reply->IOCLogInfo));
-		rc = -EFAULT;
-	}
-
- out:
-	ioc->ctl_cmds.status = MPT2_CMD_NOT_USED;
-	return rc;
-}
-
-/**
- * _ctl_diag_release - request to send Diag Release Message to firmware
- * @arg - user space buffer containing ioctl content
- *
- * This allows ownership of the specified buffer to returned to the driver,
- * allowing an application to read the buffer without fear that firmware is
- * overwritting information in the buffer.
- */
-static long
-_ctl_diag_release(struct MPT2SAS_ADAPTER *ioc, void __user *arg)
-{
-	struct mpt2_diag_release karg;
-	void *request_data;
-	int rc;
-	u8 buffer_type;
-	u8 issue_reset = 0;
-
-	if (copy_from_user(&karg, arg, sizeof(karg))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	buffer_type = karg.unique_id & 0x000000ff;
-	if (!_ctl_diag_capability(ioc, buffer_type)) {
-		printk(MPT2SAS_ERR_FMT "%s: doesn't have capability for "
-		    "buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);
-		return -EPERM;
-	}
-
-	if ((ioc->diag_buffer_status[buffer_type] &
-	    MPT2_DIAG_BUFFER_IS_REGISTERED) == 0) {
-		printk(MPT2SAS_ERR_FMT "%s: buffer_type(0x%02x) is not "
-		    "registered\n", ioc->name, __func__, buffer_type);
-		return -EINVAL;
-	}
-
-	if (karg.unique_id != ioc->unique_id[buffer_type]) {
-		printk(MPT2SAS_ERR_FMT "%s: unique_id(0x%08x) is not "
-		    "registered\n", ioc->name, __func__, karg.unique_id);
-		return -EINVAL;
-	}
-
-	if (ioc->diag_buffer_status[buffer_type] &
-	    MPT2_DIAG_BUFFER_IS_RELEASED) {
-		printk(MPT2SAS_ERR_FMT "%s: buffer_type(0x%02x) "
-		    "is already released\n", ioc->name, __func__,
-		    buffer_type);
-		return 0;
-	}
-
-	request_data = ioc->diag_buffer[buffer_type];
-
-	if (!request_data) {
-		printk(MPT2SAS_ERR_FMT "%s: doesn't have memory allocated for "
-		    "buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);
-		return -ENOMEM;
-	}
-
-	/* buffers were released by due to host reset */
-	if ((ioc->diag_buffer_status[buffer_type] &
-	    MPT2_DIAG_BUFFER_IS_DIAG_RESET)) {
-		ioc->diag_buffer_status[buffer_type] |=
-		    MPT2_DIAG_BUFFER_IS_RELEASED;
-		ioc->diag_buffer_status[buffer_type] &=
-		    ~MPT2_DIAG_BUFFER_IS_DIAG_RESET;
-		printk(MPT2SAS_ERR_FMT "%s: buffer_type(0x%02x) "
-		    "was released due to host reset\n", ioc->name, __func__,
-		    buffer_type);
-		return 0;
-	}
-
-	rc = _ctl_send_release(ioc, buffer_type, &issue_reset);
-
-	if (issue_reset)
-		mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-		    FORCE_BIG_HAMMER);
-
-	return rc;
-}
-
-/**
- * _ctl_diag_read_buffer - request for copy of the diag buffer
- * @ioc: per adapter object
- * @arg - user space buffer containing ioctl content
- */
-static long
-_ctl_diag_read_buffer(struct MPT2SAS_ADAPTER *ioc, void __user *arg)
-{
-	struct mpt2_diag_read_buffer karg;
-	struct mpt2_diag_read_buffer __user *uarg = arg;
-	void *request_data, *diag_data;
-	Mpi2DiagBufferPostRequest_t *mpi_request;
-	Mpi2DiagBufferPostReply_t *mpi_reply;
-	int rc, i;
-	u8 buffer_type;
-	unsigned long timeleft, request_size, copy_size;
-	u16 smid;
-	u16 ioc_status;
-	u8 issue_reset = 0;
-
-	if (copy_from_user(&karg, arg, sizeof(karg))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,
-	    __func__));
-
-	buffer_type = karg.unique_id & 0x000000ff;
-	if (!_ctl_diag_capability(ioc, buffer_type)) {
-		printk(MPT2SAS_ERR_FMT "%s: doesn't have capability for "
-		    "buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);
-		return -EPERM;
-	}
-
-	if (karg.unique_id != ioc->unique_id[buffer_type]) {
-		printk(MPT2SAS_ERR_FMT "%s: unique_id(0x%08x) is not "
-		    "registered\n", ioc->name, __func__, karg.unique_id);
-		return -EINVAL;
-	}
-
-	request_data = ioc->diag_buffer[buffer_type];
-	if (!request_data) {
-		printk(MPT2SAS_ERR_FMT "%s: doesn't have buffer for "
-		    "buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);
-		return -ENOMEM;
-	}
-
-	request_size = ioc->diag_buffer_sz[buffer_type];
-
-	if ((karg.starting_offset % 4) || (karg.bytes_to_read % 4)) {
-		printk(MPT2SAS_ERR_FMT "%s: either the starting_offset "
-		    "or bytes_to_read are not 4 byte aligned\n", ioc->name,
-		    __func__);
-		return -EINVAL;
-	}
-
-	if (karg.starting_offset > request_size)
-		return -EINVAL;
-
-	diag_data = (void *)(request_data + karg.starting_offset);
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: diag_buffer(%p), "
-	    "offset(%d), sz(%d)\n", ioc->name, __func__,
-	    diag_data, karg.starting_offset, karg.bytes_to_read));
-
-	/* Truncate data on requests that are too large */
-	if ((diag_data + karg.bytes_to_read < diag_data) ||
-	    (diag_data + karg.bytes_to_read > request_data + request_size))
-		copy_size = request_size - karg.starting_offset;
-	else
-		copy_size = karg.bytes_to_read;
-
-	if (copy_to_user((void __user *)uarg->diagnostic_data,
-	    diag_data, copy_size)) {
-		printk(MPT2SAS_ERR_FMT "%s: Unable to write "
-		    "mpt_diag_read_buffer_t data @ %p\n", ioc->name,
-		    __func__, diag_data);
-		return -EFAULT;
-	}
-
-	if ((karg.flags & MPT2_FLAGS_REREGISTER) == 0)
-		return 0;
-
-	dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: Reregister "
-		"buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type));
-	if ((ioc->diag_buffer_status[buffer_type] &
-	    MPT2_DIAG_BUFFER_IS_RELEASED) == 0) {
-		dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-		    "buffer_type(0x%02x) is still registered\n", ioc->name,
-		     __func__, buffer_type));
-		return 0;
-	}
-	/* Get a free request frame and save the message context.
-	*/
-
-	if (ioc->ctl_cmds.status != MPT2_CMD_NOT_USED) {
-		printk(MPT2SAS_ERR_FMT "%s: ctl_cmd in use\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-
-	smid = mpt2sas_base_get_smid(ioc, ioc->ctl_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-
-	rc = 0;
-	ioc->ctl_cmds.status = MPT2_CMD_PENDING;
-	memset(ioc->ctl_cmds.reply, 0, ioc->reply_sz);
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	ioc->ctl_cmds.smid = smid;
-
-	mpi_request->Function = MPI2_FUNCTION_DIAG_BUFFER_POST;
-	mpi_request->BufferType = buffer_type;
-	mpi_request->BufferLength =
-	    cpu_to_le32(ioc->diag_buffer_sz[buffer_type]);
-	mpi_request->BufferAddress =
-	    cpu_to_le64(ioc->diag_buffer_dma[buffer_type]);
-	for (i = 0; i < MPT2_PRODUCT_SPECIFIC_DWORDS; i++)
-		mpi_request->ProductSpecific[i] =
-			cpu_to_le32(ioc->product_specific[buffer_type][i]);
-	mpi_request->VF_ID = 0; /* TODO */
-	mpi_request->VP_ID = 0;
-
-	init_completion(&ioc->ctl_cmds.done);
-	mpt2sas_base_put_smid_default(ioc, smid);
-	timeleft = wait_for_completion_timeout(&ioc->ctl_cmds.done,
-	    MPT2_IOCTL_DEFAULT_TIMEOUT*HZ);
-
-	if (!(ioc->ctl_cmds.status & MPT2_CMD_COMPLETE)) {
-		printk(MPT2SAS_ERR_FMT "%s: timeout\n", ioc->name,
-		    __func__);
-		_debug_dump_mf(mpi_request,
-		    sizeof(Mpi2DiagBufferPostRequest_t)/4);
-		if (!(ioc->ctl_cmds.status & MPT2_CMD_RESET))
-			issue_reset = 1;
-		goto issue_host_reset;
-	}
-
-	/* process the completed Reply Message Frame */
-	if ((ioc->ctl_cmds.status & MPT2_CMD_REPLY_VALID) == 0) {
-		printk(MPT2SAS_ERR_FMT "%s: no reply message\n",
-		    ioc->name, __func__);
-		rc = -EFAULT;
-		goto out;
-	}
-
-	mpi_reply = ioc->ctl_cmds.reply;
-	ioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;
-
-	if (ioc_status == MPI2_IOCSTATUS_SUCCESS) {
-		ioc->diag_buffer_status[buffer_type] |=
-		    MPT2_DIAG_BUFFER_IS_REGISTERED;
-		dctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: success\n",
-		    ioc->name, __func__));
-	} else {
-		printk(MPT2SAS_INFO_FMT "%s: ioc_status(0x%04x) "
-		    "log_info(0x%08x)\n", ioc->name, __func__,
-		    ioc_status, le32_to_cpu(mpi_reply->IOCLogInfo));
-		rc = -EFAULT;
-	}
-
- issue_host_reset:
-	if (issue_reset)
-		mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-		    FORCE_BIG_HAMMER);
-
- out:
-
-	ioc->ctl_cmds.status = MPT2_CMD_NOT_USED;
-	return rc;
-}
-
-
-#ifdef CONFIG_COMPAT
-/**
- * _ctl_compat_mpt_command - convert 32bit pointers to 64bit.
- * @ioc: per adapter object
- * @cmd - ioctl opcode
- * @arg - (struct mpt2_ioctl_command32)
- *
- * MPT2COMMAND32 - Handle 32bit applications running on 64bit os.
- */
-static long
-_ctl_compat_mpt_command(struct MPT2SAS_ADAPTER *ioc, unsigned cmd,
-	void __user *arg)
-{
-	struct mpt2_ioctl_command32 karg32;
-	struct mpt2_ioctl_command32 __user *uarg;
-	struct mpt2_ioctl_command karg;
-
-	if (_IOC_SIZE(cmd) != sizeof(struct mpt2_ioctl_command32))
-		return -EINVAL;
-
-	uarg = (struct mpt2_ioctl_command32 __user *) arg;
-
-	if (copy_from_user(&karg32, (char __user *)arg, sizeof(karg32))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-
-	memset(&karg, 0, sizeof(struct mpt2_ioctl_command));
-	karg.hdr.ioc_number = karg32.hdr.ioc_number;
-	karg.hdr.port_number = karg32.hdr.port_number;
-	karg.hdr.max_data_size = karg32.hdr.max_data_size;
-	karg.timeout = karg32.timeout;
-	karg.max_reply_bytes = karg32.max_reply_bytes;
-	karg.data_in_size = karg32.data_in_size;
-	karg.data_out_size = karg32.data_out_size;
-	karg.max_sense_bytes = karg32.max_sense_bytes;
-	karg.data_sge_offset = karg32.data_sge_offset;
-	karg.reply_frame_buf_ptr = compat_ptr(karg32.reply_frame_buf_ptr);
-	karg.data_in_buf_ptr = compat_ptr(karg32.data_in_buf_ptr);
-	karg.data_out_buf_ptr = compat_ptr(karg32.data_out_buf_ptr);
-	karg.sense_data_ptr = compat_ptr(karg32.sense_data_ptr);
-	return _ctl_do_mpt_command(ioc, karg, &uarg->mf);
-}
-#endif
-
-/**
- * _ctl_ioctl_main - main ioctl entry point
- * @file - (struct file)
- * @cmd - ioctl opcode
- * @arg -
- * compat - handles 32 bit applications in 64bit os
- */
-static long
-_ctl_ioctl_main(struct file *file, unsigned int cmd, void __user *arg,
-	u8 compat)
-{
-	struct MPT2SAS_ADAPTER *ioc;
-	struct mpt2_ioctl_header ioctl_header;
-	enum block_state state;
-	long ret = -EINVAL;
-
-	/* get IOCTL header */
-	if (copy_from_user(&ioctl_header, (char __user *)arg,
-	    sizeof(struct mpt2_ioctl_header))) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n",
-		    __FILE__, __LINE__, __func__);
-		return -EFAULT;
-	}
-
-	if (_ctl_verify_adapter(ioctl_header.ioc_number, &ioc) == -1 || !ioc)
-		return -ENODEV;
-	/* pci_access_mutex lock acquired by ioctl path */
-	mutex_lock(&ioc->pci_access_mutex);
-	if (ioc->shost_recovery || ioc->pci_error_recovery ||
-		ioc->is_driver_loading || ioc->remove_host) {
-		ret = -EAGAIN;
-		goto out_unlock_pciaccess;
-	}
-
-	state = (file->f_flags & O_NONBLOCK) ? NON_BLOCKING : BLOCKING;
-	if (state == NON_BLOCKING) {
-		if (!mutex_trylock(&ioc->ctl_cmds.mutex)) {
-			ret = -EAGAIN;
-			goto out_unlock_pciaccess;
-		}
-	} else if (mutex_lock_interruptible(&ioc->ctl_cmds.mutex)) {
-		ret = -ERESTARTSYS;
-		goto out_unlock_pciaccess;
-	}
-
-	switch (cmd) {
-	case MPT2IOCINFO:
-		if (_IOC_SIZE(cmd) == sizeof(struct mpt2_ioctl_iocinfo))
-			ret = _ctl_getiocinfo(ioc, arg);
-		break;
-#ifdef CONFIG_COMPAT
-	case MPT2COMMAND32:
-#endif
-	case MPT2COMMAND:
-	{
-		struct mpt2_ioctl_command __user *uarg;
-		struct mpt2_ioctl_command karg;
-#ifdef CONFIG_COMPAT
-		if (compat) {
-			ret = _ctl_compat_mpt_command(ioc, cmd, arg);
-			break;
-		}
-#endif
-		if (copy_from_user(&karg, arg, sizeof(karg))) {
-			printk(KERN_ERR "failure at %s:%d/%s()!\n",
-			    __FILE__, __LINE__, __func__);
-			ret = -EFAULT;
-			break;
-		}
-
-		if (_IOC_SIZE(cmd) == sizeof(struct mpt2_ioctl_command)) {
-			uarg = arg;
-			ret = _ctl_do_mpt_command(ioc, karg, &uarg->mf);
-		}
-		break;
-	}
-	case MPT2EVENTQUERY:
-		if (_IOC_SIZE(cmd) == sizeof(struct mpt2_ioctl_eventquery))
-			ret = _ctl_eventquery(ioc, arg);
-		break;
-	case MPT2EVENTENABLE:
-		if (_IOC_SIZE(cmd) == sizeof(struct mpt2_ioctl_eventenable))
-			ret = _ctl_eventenable(ioc, arg);
-		break;
-	case MPT2EVENTREPORT:
-		ret = _ctl_eventreport(ioc, arg);
-		break;
-	case MPT2HARDRESET:
-		if (_IOC_SIZE(cmd) == sizeof(struct mpt2_ioctl_diag_reset))
-			ret = _ctl_do_reset(ioc, arg);
-		break;
-	case MPT2BTDHMAPPING:
-		if (_IOC_SIZE(cmd) == sizeof(struct mpt2_ioctl_btdh_mapping))
-			ret = _ctl_btdh_mapping(ioc, arg);
-		break;
-	case MPT2DIAGREGISTER:
-		if (_IOC_SIZE(cmd) == sizeof(struct mpt2_diag_register))
-			ret = _ctl_diag_register(ioc, arg);
-		break;
-	case MPT2DIAGUNREGISTER:
-		if (_IOC_SIZE(cmd) == sizeof(struct mpt2_diag_unregister))
-			ret = _ctl_diag_unregister(ioc, arg);
-		break;
-	case MPT2DIAGQUERY:
-		if (_IOC_SIZE(cmd) == sizeof(struct mpt2_diag_query))
-			ret = _ctl_diag_query(ioc, arg);
-		break;
-	case MPT2DIAGRELEASE:
-		if (_IOC_SIZE(cmd) == sizeof(struct mpt2_diag_release))
-			ret = _ctl_diag_release(ioc, arg);
-		break;
-	case MPT2DIAGREADBUFFER:
-		if (_IOC_SIZE(cmd) == sizeof(struct mpt2_diag_read_buffer))
-			ret = _ctl_diag_read_buffer(ioc, arg);
-		break;
-	default:
-
-		dctlprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "unsupported ioctl opcode(0x%08x)\n", ioc->name, cmd));
-		break;
-	}
-
-	mutex_unlock(&ioc->ctl_cmds.mutex);
-out_unlock_pciaccess:
-	mutex_unlock(&ioc->pci_access_mutex);
-	return ret;
-}
-
-/**
- * _ctl_ioctl - main ioctl entry point (unlocked)
- * @file - (struct file)
- * @cmd - ioctl opcode
- * @arg -
- */
-static long
-_ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	long ret;
-
-	ret = _ctl_ioctl_main(file, cmd, (void __user *)arg, 0);
-	return ret;
-}
-#ifdef CONFIG_COMPAT
-/**
- * _ctl_ioctl_compat - main ioctl entry point (compat)
- * @file -
- * @cmd -
- * @arg -
- *
- * This routine handles 32 bit applications in 64bit os.
- */
-static long
-_ctl_ioctl_compat(struct file *file, unsigned cmd, unsigned long arg)
-{
-	long ret;
-
-	ret = _ctl_ioctl_main(file, cmd, (void __user *)arg, 1);
-	return ret;
-}
-#endif
-
-/* scsi host attributes */
-
-/**
- * _ctl_version_fw_show - firmware version
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_version_fw_show(struct device *cdev, struct device_attribute *attr,
-    char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	return snprintf(buf, PAGE_SIZE, "%02d.%02d.%02d.%02d\n",
-	    (ioc->facts.FWVersion.Word & 0xFF000000) >> 24,
-	    (ioc->facts.FWVersion.Word & 0x00FF0000) >> 16,
-	    (ioc->facts.FWVersion.Word & 0x0000FF00) >> 8,
-	    ioc->facts.FWVersion.Word & 0x000000FF);
-}
-static DEVICE_ATTR(version_fw, S_IRUGO, _ctl_version_fw_show, NULL);
-
-/**
- * _ctl_version_bios_show - bios version
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_version_bios_show(struct device *cdev, struct device_attribute *attr,
-    char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	u32 version = le32_to_cpu(ioc->bios_pg3.BiosVersion);
-
-	return snprintf(buf, PAGE_SIZE, "%02d.%02d.%02d.%02d\n",
-	    (version & 0xFF000000) >> 24,
-	    (version & 0x00FF0000) >> 16,
-	    (version & 0x0000FF00) >> 8,
-	    version & 0x000000FF);
-}
-static DEVICE_ATTR(version_bios, S_IRUGO, _ctl_version_bios_show, NULL);
-
-/**
- * _ctl_version_mpi_show - MPI (message passing interface) version
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_version_mpi_show(struct device *cdev, struct device_attribute *attr,
-    char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	return snprintf(buf, PAGE_SIZE, "%03x.%02x\n",
-	    ioc->facts.MsgVersion, ioc->facts.HeaderVersion >> 8);
-}
-static DEVICE_ATTR(version_mpi, S_IRUGO, _ctl_version_mpi_show, NULL);
-
-/**
- * _ctl_version_product_show - product name
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_version_product_show(struct device *cdev, struct device_attribute *attr,
-    char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	return snprintf(buf, 16, "%s\n", ioc->manu_pg0.ChipName);
-}
-static DEVICE_ATTR(version_product, S_IRUGO,
-   _ctl_version_product_show, NULL);
-
-/**
- * _ctl_version_nvdata_persistent_show - ndvata persistent version
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_version_nvdata_persistent_show(struct device *cdev,
-    struct device_attribute *attr, char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	return snprintf(buf, PAGE_SIZE, "%08xh\n",
-	    le32_to_cpu(ioc->iounit_pg0.NvdataVersionPersistent.Word));
-}
-static DEVICE_ATTR(version_nvdata_persistent, S_IRUGO,
-    _ctl_version_nvdata_persistent_show, NULL);
-
-/**
- * _ctl_version_nvdata_default_show - nvdata default version
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_version_nvdata_default_show(struct device *cdev,
-    struct device_attribute *attr, char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	return snprintf(buf, PAGE_SIZE, "%08xh\n",
-	    le32_to_cpu(ioc->iounit_pg0.NvdataVersionDefault.Word));
-}
-static DEVICE_ATTR(version_nvdata_default, S_IRUGO,
-    _ctl_version_nvdata_default_show, NULL);
-
-/**
- * _ctl_board_name_show - board name
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_board_name_show(struct device *cdev, struct device_attribute *attr,
-    char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	return snprintf(buf, 16, "%s\n", ioc->manu_pg0.BoardName);
-}
-static DEVICE_ATTR(board_name, S_IRUGO, _ctl_board_name_show, NULL);
-
-/**
- * _ctl_board_assembly_show - board assembly name
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_board_assembly_show(struct device *cdev, struct device_attribute *attr,
-    char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	return snprintf(buf, 16, "%s\n", ioc->manu_pg0.BoardAssembly);
-}
-static DEVICE_ATTR(board_assembly, S_IRUGO,
-    _ctl_board_assembly_show, NULL);
-
-/**
- * _ctl_board_tracer_show - board tracer number
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_board_tracer_show(struct device *cdev, struct device_attribute *attr,
-    char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	return snprintf(buf, 16, "%s\n", ioc->manu_pg0.BoardTracerNumber);
-}
-static DEVICE_ATTR(board_tracer, S_IRUGO,
-    _ctl_board_tracer_show, NULL);
-
-/**
- * _ctl_io_delay_show - io missing delay
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * This is for firmware implemention for deboucing device
- * removal events.
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_io_delay_show(struct device *cdev, struct device_attribute *attr,
-    char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	return snprintf(buf, PAGE_SIZE, "%02d\n", ioc->io_missing_delay);
-}
-static DEVICE_ATTR(io_delay, S_IRUGO,
-    _ctl_io_delay_show, NULL);
-
-/**
- * _ctl_device_delay_show - device missing delay
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * This is for firmware implemention for deboucing device
- * removal events.
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_device_delay_show(struct device *cdev, struct device_attribute *attr,
-    char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	return snprintf(buf, PAGE_SIZE, "%02d\n", ioc->device_missing_delay);
-}
-static DEVICE_ATTR(device_delay, S_IRUGO,
-    _ctl_device_delay_show, NULL);
-
-/**
- * _ctl_fw_queue_depth_show - global credits
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * This is firmware queue depth limit
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_fw_queue_depth_show(struct device *cdev, struct device_attribute *attr,
-    char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	return snprintf(buf, PAGE_SIZE, "%02d\n", ioc->facts.RequestCredit);
-}
-static DEVICE_ATTR(fw_queue_depth, S_IRUGO,
-    _ctl_fw_queue_depth_show, NULL);
-
-/**
- * _ctl_sas_address_show - sas address
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * This is the controller sas address
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_host_sas_address_show(struct device *cdev, struct device_attribute *attr,
-    char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	return snprintf(buf, PAGE_SIZE, "0x%016llx\n",
-	    (unsigned long long)ioc->sas_hba.sas_address);
-}
-static DEVICE_ATTR(host_sas_address, S_IRUGO,
-    _ctl_host_sas_address_show, NULL);
-
-/**
- * _ctl_logging_level_show - logging level
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * A sysfs 'read/write' shost attribute.
- */
-static ssize_t
-_ctl_logging_level_show(struct device *cdev, struct device_attribute *attr,
-    char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	return snprintf(buf, PAGE_SIZE, "%08xh\n", ioc->logging_level);
-}
-static ssize_t
-_ctl_logging_level_store(struct device *cdev, struct device_attribute *attr,
-    const char *buf, size_t count)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	int val = 0;
-
-	if (sscanf(buf, "%x", &val) != 1)
-		return -EINVAL;
-
-	ioc->logging_level = val;
-	printk(MPT2SAS_INFO_FMT "logging_level=%08xh\n", ioc->name,
-	    ioc->logging_level);
-	return strlen(buf);
-}
-static DEVICE_ATTR(logging_level, S_IRUGO | S_IWUSR,
-    _ctl_logging_level_show, _ctl_logging_level_store);
-
-/* device attributes */
-/*
- * _ctl_fwfault_debug_show - show/store fwfault_debug
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * mpt2sas_fwfault_debug is command line option
- * A sysfs 'read/write' shost attribute.
- */
-static ssize_t
-_ctl_fwfault_debug_show(struct device *cdev,
-    struct device_attribute *attr, char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	return snprintf(buf, PAGE_SIZE, "%d\n", ioc->fwfault_debug);
-}
-static ssize_t
-_ctl_fwfault_debug_store(struct device *cdev,
-    struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	int val = 0;
-
-	if (sscanf(buf, "%d", &val) != 1)
-		return -EINVAL;
-
-	ioc->fwfault_debug = val;
-	printk(MPT2SAS_INFO_FMT "fwfault_debug=%d\n", ioc->name,
-	    ioc->fwfault_debug);
-	return strlen(buf);
-}
-static DEVICE_ATTR(fwfault_debug, S_IRUGO | S_IWUSR,
-    _ctl_fwfault_debug_show, _ctl_fwfault_debug_store);
-
-
-/**
- * _ctl_ioc_reset_count_show - ioc reset count
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * This is firmware queue depth limit
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_ioc_reset_count_show(struct device *cdev, struct device_attribute *attr,
-    char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	return snprintf(buf, PAGE_SIZE, "%08d\n", ioc->ioc_reset_count);
-}
-static DEVICE_ATTR(ioc_reset_count, S_IRUGO,
-    _ctl_ioc_reset_count_show, NULL);
-
-/**
- * _ctl_ioc_reply_queue_count_show - number of reply queues
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * This is number of reply queues
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_ioc_reply_queue_count_show(struct device *cdev,
-	 struct device_attribute *attr, char *buf)
-{
-	u8 reply_queue_count;
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	if ((ioc->facts.IOCCapabilities &
-	    MPI2_IOCFACTS_CAPABILITY_MSI_X_INDEX) && ioc->msix_enable)
-		reply_queue_count = ioc->reply_queue_count;
-	else
-		reply_queue_count = 1;
-	return snprintf(buf, PAGE_SIZE, "%d\n", reply_queue_count);
-}
-static DEVICE_ATTR(reply_queue_count, S_IRUGO,
-	 _ctl_ioc_reply_queue_count_show, NULL);
-
-/**
- * _ctl_BRM_status_show - Backup Rail Monitor Status
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * This is number of reply queues
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_BRM_status_show(struct device *cdev, struct device_attribute *attr,
-	char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	Mpi2IOUnitPage3_t *io_unit_pg3 = NULL;
-	Mpi2ConfigReply_t mpi_reply;
-	u16 backup_rail_monitor_status = 0;
-	u16 ioc_status;
-	int sz;
-	ssize_t rc = 0;
-
-	if (!ioc->is_warpdrive) {
-		printk(MPT2SAS_ERR_FMT "%s: BRM attribute is only for"\
-		    "warpdrive\n", ioc->name, __func__);
-		goto out;
-	}
-	/* pci_access_mutex lock acquired by sysfs show path */
-	mutex_lock(&ioc->pci_access_mutex);
-	if (ioc->pci_error_recovery || ioc->remove_host) {
-		mutex_unlock(&ioc->pci_access_mutex);
-		return 0;
-	}
-
-	/* allocate upto GPIOVal 36 entries */
-	sz = offsetof(Mpi2IOUnitPage3_t, GPIOVal) + (sizeof(u16) * 36);
-	io_unit_pg3 = kzalloc(sz, GFP_KERNEL);
-	if (!io_unit_pg3) {
-		printk(MPT2SAS_ERR_FMT "%s: failed allocating memory"\
-		    "for iounit_pg3: (%d) bytes\n", ioc->name, __func__, sz);
-		goto out;
-	}
-
-	if (mpt2sas_config_get_iounit_pg3(ioc, &mpi_reply, io_unit_pg3, sz) !=
-	    0) {
-		printk(MPT2SAS_ERR_FMT
-		    "%s: failed reading iounit_pg3\n", ioc->name,
-		    __func__);
-		goto out;
-	}
-
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-		printk(MPT2SAS_ERR_FMT "%s: iounit_pg3 failed with"\
-		    "ioc_status(0x%04x)\n", ioc->name, __func__, ioc_status);
-		goto out;
-	}
-
-	if (io_unit_pg3->GPIOCount < 25) {
-		printk(MPT2SAS_ERR_FMT "%s: iounit_pg3->GPIOCount less than"\
-		     "25 entries, detected (%d) entries\n", ioc->name, __func__,
-		    io_unit_pg3->GPIOCount);
-		goto out;
-	}
-
-	/* BRM status is in bit zero of GPIOVal[24] */
-	backup_rail_monitor_status = le16_to_cpu(io_unit_pg3->GPIOVal[24]);
-	rc = snprintf(buf, PAGE_SIZE, "%d\n", (backup_rail_monitor_status & 1));
-
- out:
-	kfree(io_unit_pg3);
-	mutex_unlock(&ioc->pci_access_mutex);
-	return rc;
-}
-static DEVICE_ATTR(BRM_status, S_IRUGO, _ctl_BRM_status_show, NULL);
-
-struct DIAG_BUFFER_START {
-	__le32 Size;
-	__le32 DiagVersion;
-	u8 BufferType;
-	u8 Reserved[3];
-	__le32 Reserved1;
-	__le32 Reserved2;
-	__le32 Reserved3;
-};
-/**
- * _ctl_host_trace_buffer_size_show - host buffer size (trace only)
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_host_trace_buffer_size_show(struct device *cdev,
-    struct device_attribute *attr, char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	u32 size = 0;
-	struct DIAG_BUFFER_START *request_data;
-
-	if (!ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE]) {
-		printk(MPT2SAS_ERR_FMT "%s: host_trace_buffer is not "
-		    "registered\n", ioc->name, __func__);
-		return 0;
-	}
-
-	if ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
-	    MPT2_DIAG_BUFFER_IS_REGISTERED) == 0) {
-		printk(MPT2SAS_ERR_FMT "%s: host_trace_buffer is not "
-		    "registered\n", ioc->name, __func__);
-		return 0;
-	}
-
-	request_data = (struct DIAG_BUFFER_START *)
-	    ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE];
-	if ((le32_to_cpu(request_data->DiagVersion) == 0x00000000 ||
-	    le32_to_cpu(request_data->DiagVersion) == 0x01000000) &&
-	    le32_to_cpu(request_data->Reserved3) == 0x4742444c)
-		size = le32_to_cpu(request_data->Size);
-
-	ioc->ring_buffer_sz = size;
-	return snprintf(buf, PAGE_SIZE, "%d\n", size);
-}
-static DEVICE_ATTR(host_trace_buffer_size, S_IRUGO,
-	 _ctl_host_trace_buffer_size_show, NULL);
-
-/**
- * _ctl_host_trace_buffer_show - firmware ring buffer (trace only)
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * A sysfs 'read/write' shost attribute.
- *
- * You will only be able to read 4k bytes of ring buffer at a time.
- * In order to read beyond 4k bytes, you will have to write out the
- * offset to the same attribute, it will move the pointer.
- */
-static ssize_t
-_ctl_host_trace_buffer_show(struct device *cdev, struct device_attribute *attr,
-     char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	void *request_data;
-	u32 size;
-
-	if (!ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE]) {
-		printk(MPT2SAS_ERR_FMT "%s: host_trace_buffer is not "
-		    "registered\n", ioc->name, __func__);
-		return 0;
-	}
-
-	if ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
-	    MPT2_DIAG_BUFFER_IS_REGISTERED) == 0) {
-		printk(MPT2SAS_ERR_FMT "%s: host_trace_buffer is not "
-		    "registered\n", ioc->name, __func__);
-		return 0;
-	}
-
-	if (ioc->ring_buffer_offset > ioc->ring_buffer_sz)
-		return 0;
-
-	size = ioc->ring_buffer_sz - ioc->ring_buffer_offset;
-	size = (size > PAGE_SIZE) ? PAGE_SIZE : size;
-	request_data = ioc->diag_buffer[0] + ioc->ring_buffer_offset;
-	memcpy(buf, request_data, size);
-	return size;
-}
-
-static ssize_t
-_ctl_host_trace_buffer_store(struct device *cdev, struct device_attribute *attr,
-    const char *buf, size_t count)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	int val = 0;
-
-	if (sscanf(buf, "%d", &val) != 1)
-		return -EINVAL;
-
-	ioc->ring_buffer_offset = val;
-	return strlen(buf);
-}
-static DEVICE_ATTR(host_trace_buffer, S_IRUGO | S_IWUSR,
-    _ctl_host_trace_buffer_show, _ctl_host_trace_buffer_store);
-
-/*****************************************/
-
-/**
- * _ctl_host_trace_buffer_enable_show - firmware ring buffer (trace only)
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * A sysfs 'read/write' shost attribute.
- *
- * This is a mechnism to post/release host_trace_buffers
- */
-static ssize_t
-_ctl_host_trace_buffer_enable_show(struct device *cdev,
-    struct device_attribute *attr, char *buf)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	if ((!ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE]) ||
-	   ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
-	    MPT2_DIAG_BUFFER_IS_REGISTERED) == 0))
-		return snprintf(buf, PAGE_SIZE, "off\n");
-	else if ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
-	    MPT2_DIAG_BUFFER_IS_RELEASED))
-		return snprintf(buf, PAGE_SIZE, "release\n");
-	else
-		return snprintf(buf, PAGE_SIZE, "post\n");
-}
-
-static ssize_t
-_ctl_host_trace_buffer_enable_store(struct device *cdev,
-    struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	char str[10] = "";
-	struct mpt2_diag_register diag_register;
-	u8 issue_reset = 0;
-
-	if (sscanf(buf, "%9s", str) != 1)
-		return -EINVAL;
-
-	if (!strcmp(str, "post")) {
-		/* exit out if host buffers are already posted */
-		if ((ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE]) &&
-		    (ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
-		    MPT2_DIAG_BUFFER_IS_REGISTERED) &&
-		    ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
-		    MPT2_DIAG_BUFFER_IS_RELEASED) == 0))
-			goto out;
-		memset(&diag_register, 0, sizeof(struct mpt2_diag_register));
-		printk(MPT2SAS_INFO_FMT "posting host trace buffers\n",
-		    ioc->name);
-		diag_register.buffer_type = MPI2_DIAG_BUF_TYPE_TRACE;
-		diag_register.requested_buffer_size = (1024 * 1024);
-		diag_register.unique_id = 0x7075900;
-		ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] = 0;
-		_ctl_diag_register_2(ioc,  &diag_register);
-	} else if (!strcmp(str, "release")) {
-		/* exit out if host buffers are already released */
-		if (!ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE])
-			goto out;
-		if ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
-		    MPT2_DIAG_BUFFER_IS_REGISTERED) == 0)
-			goto out;
-		if ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
-		    MPT2_DIAG_BUFFER_IS_RELEASED))
-			goto out;
-		printk(MPT2SAS_INFO_FMT "releasing host trace buffer\n",
-		    ioc->name);
-		_ctl_send_release(ioc, MPI2_DIAG_BUF_TYPE_TRACE, &issue_reset);
-	}
-
- out:
-	return strlen(buf);
-}
-static DEVICE_ATTR(host_trace_buffer_enable, S_IRUGO | S_IWUSR,
-    _ctl_host_trace_buffer_enable_show, _ctl_host_trace_buffer_enable_store);
-
-struct device_attribute *mpt2sas_host_attrs[] = {
-	&dev_attr_version_fw,
-	&dev_attr_version_bios,
-	&dev_attr_version_mpi,
-	&dev_attr_version_product,
-	&dev_attr_version_nvdata_persistent,
-	&dev_attr_version_nvdata_default,
-	&dev_attr_board_name,
-	&dev_attr_board_assembly,
-	&dev_attr_board_tracer,
-	&dev_attr_io_delay,
-	&dev_attr_device_delay,
-	&dev_attr_logging_level,
-	&dev_attr_fwfault_debug,
-	&dev_attr_fw_queue_depth,
-	&dev_attr_host_sas_address,
-	&dev_attr_ioc_reset_count,
-	&dev_attr_host_trace_buffer_size,
-	&dev_attr_host_trace_buffer,
-	&dev_attr_host_trace_buffer_enable,
-	&dev_attr_reply_queue_count,
-	&dev_attr_BRM_status,
-	NULL,
-};
-
-/**
- * _ctl_device_sas_address_show - sas address
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * This is the sas address for the target
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_device_sas_address_show(struct device *dev, struct device_attribute *attr,
-    char *buf)
-{
-	struct scsi_device *sdev = to_scsi_device(dev);
-	struct MPT2SAS_DEVICE *sas_device_priv_data = sdev->hostdata;
-
-	return snprintf(buf, PAGE_SIZE, "0x%016llx\n",
-	    (unsigned long long)sas_device_priv_data->sas_target->sas_address);
-}
-static DEVICE_ATTR(sas_address, S_IRUGO, _ctl_device_sas_address_show, NULL);
-
-/**
- * _ctl_device_handle_show - device handle
- * @cdev - pointer to embedded class device
- * @buf - the buffer returned
- *
- * This is the firmware assigned device handle
- *
- * A sysfs 'read-only' shost attribute.
- */
-static ssize_t
-_ctl_device_handle_show(struct device *dev, struct device_attribute *attr,
-    char *buf)
-{
-	struct scsi_device *sdev = to_scsi_device(dev);
-	struct MPT2SAS_DEVICE *sas_device_priv_data = sdev->hostdata;
-
-	return snprintf(buf, PAGE_SIZE, "0x%04x\n",
-	    sas_device_priv_data->sas_target->handle);
-}
-static DEVICE_ATTR(sas_device_handle, S_IRUGO, _ctl_device_handle_show, NULL);
-
-struct device_attribute *mpt2sas_dev_attrs[] = {
-	&dev_attr_sas_address,
-	&dev_attr_sas_device_handle,
-	NULL,
-};
-
-static const struct file_operations ctl_fops = {
-	.owner = THIS_MODULE,
-	.unlocked_ioctl = _ctl_ioctl,
-	.poll = _ctl_poll,
-	.fasync = _ctl_fasync,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl = _ctl_ioctl_compat,
-#endif
-	.llseek = noop_llseek,
-};
-
-static struct miscdevice ctl_dev = {
-	.minor  = MPT2SAS_MINOR,
-	.name   = MPT2SAS_DEV_NAME,
-	.fops   = &ctl_fops,
-};
-
-/**
- * mpt2sas_ctl_init - main entry point for ctl.
- *
- */
-void
-mpt2sas_ctl_init(void)
-{
-	async_queue = NULL;
-	if (misc_register(&ctl_dev) < 0)
-		printk(KERN_ERR "%s can't register misc device [minor=%d]\n",
-		    MPT2SAS_DRIVER_NAME, MPT2SAS_MINOR);
-
-	init_waitqueue_head(&ctl_poll_wait);
-}
-
-/**
- * mpt2sas_ctl_exit - exit point for ctl
- *
- */
-void
-mpt2sas_ctl_exit(void)
-{
-	struct MPT2SAS_ADAPTER *ioc;
-	int i;
-
-	list_for_each_entry(ioc, &mpt2sas_ioc_list, list) {
-
-		/* free memory associated to diag buffers */
-		for (i = 0; i < MPI2_DIAG_BUF_TYPE_COUNT; i++) {
-			if (!ioc->diag_buffer[i])
-				continue;
-			pci_free_consistent(ioc->pdev, ioc->diag_buffer_sz[i],
-			    ioc->diag_buffer[i], ioc->diag_buffer_dma[i]);
-			ioc->diag_buffer[i] = NULL;
-			ioc->diag_buffer_status[i] = 0;
-		}
-
-		kfree(ioc->event_log);
-	}
-	misc_deregister(&ctl_dev);
-}
-
diff --git a/drivers/scsi/mpt2sas/mpt2sas_ctl.h b/drivers/scsi/mpt2sas/mpt2sas_ctl.h
deleted file mode 100644
index 46b2fc5b74af..000000000000
--- a/drivers/scsi/mpt2sas/mpt2sas_ctl.h
+++ /dev/null
@@ -1,419 +0,0 @@
-/*
- * Management Module Support for MPT (Message Passing Technology) based
- * controllers
- *
- * This code is based on drivers/scsi/mpt2sas/mpt2_ctl.h
- * Copyright (C) 2007-2014  LSI Corporation
- * Copyright (C) 20013-2014 Avago Technologies
- *  (mailto: MPT-FusionLinux.pdl@avagotech.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * NO WARRANTY
- * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
- * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
- * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
- * solely responsible for determining the appropriateness of using and
- * distributing the Program and assumes all risks associated with its
- * exercise of rights under this Agreement, including but not limited to
- * the risks and costs of program errors, damage to or loss of data,
- * programs or equipment, and unavailability or interruption of operations.
-
- * DISCLAIMER OF LIABILITY
- * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
- * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
-
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
- * USA.
- */
-
-#ifndef MPT2SAS_CTL_H_INCLUDED
-#define MPT2SAS_CTL_H_INCLUDED
-
-#ifdef __KERNEL__
-#include <linux/miscdevice.h>
-#endif
-
-#define MPT2SAS_DEV_NAME	"mpt2ctl"
-#define MPT2_MAGIC_NUMBER	'L'
-#define MPT2_IOCTL_DEFAULT_TIMEOUT (10) /* in seconds */
-
-/**
- * IOCTL opcodes
- */
-#define MPT2IOCINFO	_IOWR(MPT2_MAGIC_NUMBER, 17, \
-    struct mpt2_ioctl_iocinfo)
-#define MPT2COMMAND	_IOWR(MPT2_MAGIC_NUMBER, 20, \
-    struct mpt2_ioctl_command)
-#ifdef CONFIG_COMPAT
-#define MPT2COMMAND32	_IOWR(MPT2_MAGIC_NUMBER, 20, \
-    struct mpt2_ioctl_command32)
-#endif
-#define MPT2EVENTQUERY	_IOWR(MPT2_MAGIC_NUMBER, 21, \
-    struct mpt2_ioctl_eventquery)
-#define MPT2EVENTENABLE	_IOWR(MPT2_MAGIC_NUMBER, 22, \
-    struct mpt2_ioctl_eventenable)
-#define MPT2EVENTREPORT	_IOWR(MPT2_MAGIC_NUMBER, 23, \
-    struct mpt2_ioctl_eventreport)
-#define MPT2HARDRESET	_IOWR(MPT2_MAGIC_NUMBER, 24, \
-    struct mpt2_ioctl_diag_reset)
-#define MPT2BTDHMAPPING	_IOWR(MPT2_MAGIC_NUMBER, 31, \
-    struct mpt2_ioctl_btdh_mapping)
-
-/* diag buffer support */
-#define MPT2DIAGREGISTER _IOWR(MPT2_MAGIC_NUMBER, 26, \
-    struct mpt2_diag_register)
-#define MPT2DIAGRELEASE	_IOWR(MPT2_MAGIC_NUMBER, 27, \
-    struct mpt2_diag_release)
-#define MPT2DIAGUNREGISTER _IOWR(MPT2_MAGIC_NUMBER, 28, \
-    struct mpt2_diag_unregister)
-#define MPT2DIAGQUERY	_IOWR(MPT2_MAGIC_NUMBER, 29, \
-    struct mpt2_diag_query)
-#define MPT2DIAGREADBUFFER _IOWR(MPT2_MAGIC_NUMBER, 30, \
-    struct mpt2_diag_read_buffer)
-
-/**
- * struct mpt2_ioctl_header - main header structure
- * @ioc_number -  IOC unit number
- * @port_number - IOC port number
- * @max_data_size - maximum number bytes to transfer on read
- */
-struct mpt2_ioctl_header {
-	uint32_t ioc_number;
-	uint32_t port_number;
-	uint32_t max_data_size;
-};
-
-/**
- * struct mpt2_ioctl_diag_reset - diagnostic reset
- * @hdr - generic header
- */
-struct mpt2_ioctl_diag_reset {
-	struct mpt2_ioctl_header hdr;
-};
-
-
-/**
- * struct mpt2_ioctl_pci_info - pci device info
- * @device - pci device id
- * @function - pci function id
- * @bus - pci bus id
- * @segment_id - pci segment id
- */
-struct mpt2_ioctl_pci_info {
-	union {
-		struct {
-			uint32_t device:5;
-			uint32_t function:3;
-			uint32_t bus:24;
-		} bits;
-		uint32_t  word;
-	} u;
-	uint32_t segment_id;
-};
-
-
-#define MPT2_IOCTL_INTERFACE_SCSI	(0x00)
-#define MPT2_IOCTL_INTERFACE_FC		(0x01)
-#define MPT2_IOCTL_INTERFACE_FC_IP	(0x02)
-#define MPT2_IOCTL_INTERFACE_SAS	(0x03)
-#define MPT2_IOCTL_INTERFACE_SAS2	(0x04)
-#define MPT2_IOCTL_INTERFACE_SAS2_SSS6200	(0x05)
-#define MPT2_IOCTL_VERSION_LENGTH	(32)
-
-/**
- * struct mpt2_ioctl_iocinfo - generic controller info
- * @hdr - generic header
- * @adapter_type - type of adapter (spi, fc, sas)
- * @port_number - port number
- * @pci_id - PCI Id
- * @hw_rev - hardware revision
- * @sub_system_device - PCI subsystem Device ID
- * @sub_system_vendor - PCI subsystem Vendor ID
- * @rsvd0 - reserved
- * @firmware_version - firmware version
- * @bios_version - BIOS version
- * @driver_version - driver version - 32 ASCII characters
- * @rsvd1 - reserved
- * @scsi_id - scsi id of adapter 0
- * @rsvd2 - reserved
- * @pci_information - pci info (2nd revision)
- */
-struct mpt2_ioctl_iocinfo {
-	struct mpt2_ioctl_header hdr;
-	uint32_t adapter_type;
-	uint32_t port_number;
-	uint32_t pci_id;
-	uint32_t hw_rev;
-	uint32_t subsystem_device;
-	uint32_t subsystem_vendor;
-	uint32_t rsvd0;
-	uint32_t firmware_version;
-	uint32_t bios_version;
-	uint8_t driver_version[MPT2_IOCTL_VERSION_LENGTH];
-	uint8_t rsvd1;
-	uint8_t scsi_id;
-	uint16_t rsvd2;
-	struct mpt2_ioctl_pci_info pci_information;
-};
-
-
-/* number of event log entries */
-#define MPT2SAS_CTL_EVENT_LOG_SIZE (50)
-
-/**
- * struct mpt2_ioctl_eventquery - query event count and type
- * @hdr - generic header
- * @event_entries - number of events returned by get_event_report
- * @rsvd - reserved
- * @event_types - type of events currently being captured
- */
-struct mpt2_ioctl_eventquery {
-	struct mpt2_ioctl_header hdr;
-	uint16_t event_entries;
-	uint16_t rsvd;
-	uint32_t event_types[MPI2_EVENT_NOTIFY_EVENTMASK_WORDS];
-};
-
-/**
- * struct mpt2_ioctl_eventenable - enable/disable event capturing
- * @hdr - generic header
- * @event_types - toggle off/on type of events to be captured
- */
-struct mpt2_ioctl_eventenable {
-	struct mpt2_ioctl_header hdr;
-	uint32_t event_types[4];
-};
-
-#define MPT2_EVENT_DATA_SIZE (192)
-/**
- * struct MPT2_IOCTL_EVENTS -
- * @event - the event that was reported
- * @context - unique value for each event assigned by driver
- * @data - event data returned in fw reply message
- */
-struct MPT2_IOCTL_EVENTS {
-	uint32_t event;
-	uint32_t context;
-	uint8_t data[MPT2_EVENT_DATA_SIZE];
-};
-
-/**
- * struct mpt2_ioctl_eventreport - returing event log
- * @hdr - generic header
- * @event_data - (see struct MPT2_IOCTL_EVENTS)
- */
-struct mpt2_ioctl_eventreport {
-	struct mpt2_ioctl_header hdr;
-	struct MPT2_IOCTL_EVENTS event_data[1];
-};
-
-/**
- * struct mpt2_ioctl_command - generic mpt firmware passthru ioctl
- * @hdr - generic header
- * @timeout - command timeout in seconds. (if zero then use driver default
- *  value).
- * @reply_frame_buf_ptr - reply location
- * @data_in_buf_ptr - destination for read
- * @data_out_buf_ptr - data source for write
- * @sense_data_ptr - sense data location
- * @max_reply_bytes - maximum number of reply bytes to be sent to app.
- * @data_in_size - number bytes for data transfer in (read)
- * @data_out_size - number bytes for data transfer out (write)
- * @max_sense_bytes - maximum number of bytes for auto sense buffers
- * @data_sge_offset - offset in words from the start of the request message to
- * the first SGL
- * @mf[1];
- */
-struct mpt2_ioctl_command {
-	struct mpt2_ioctl_header hdr;
-	uint32_t timeout;
-	void __user *reply_frame_buf_ptr;
-	void __user *data_in_buf_ptr;
-	void __user *data_out_buf_ptr;
-	void __user *sense_data_ptr;
-	uint32_t max_reply_bytes;
-	uint32_t data_in_size;
-	uint32_t data_out_size;
-	uint32_t max_sense_bytes;
-	uint32_t data_sge_offset;
-	uint8_t mf[1];
-};
-
-#ifdef CONFIG_COMPAT
-struct mpt2_ioctl_command32 {
-	struct mpt2_ioctl_header hdr;
-	uint32_t timeout;
-	uint32_t reply_frame_buf_ptr;
-	uint32_t data_in_buf_ptr;
-	uint32_t data_out_buf_ptr;
-	uint32_t sense_data_ptr;
-	uint32_t max_reply_bytes;
-	uint32_t data_in_size;
-	uint32_t data_out_size;
-	uint32_t max_sense_bytes;
-	uint32_t data_sge_offset;
-	uint8_t mf[1];
-};
-#endif
-
-/**
- * struct mpt2_ioctl_btdh_mapping - mapping info
- * @hdr - generic header
- * @id - target device identification number
- * @bus - SCSI bus number that the target device exists on
- * @handle - device handle for the target device
- * @rsvd - reserved
- *
- * To obtain a bus/id the application sets
- * handle to valid handle, and bus/id to 0xFFFF.
- *
- * To obtain the device handle the application sets
- * bus/id valid value, and the handle to 0xFFFF.
- */
-struct mpt2_ioctl_btdh_mapping {
-	struct mpt2_ioctl_header hdr;
-	uint32_t id;
-	uint32_t bus;
-	uint16_t handle;
-	uint16_t rsvd;
-};
-
-
-/* status bits for ioc->diag_buffer_status */
-#define MPT2_DIAG_BUFFER_IS_REGISTERED	(0x01)
-#define MPT2_DIAG_BUFFER_IS_RELEASED	(0x02)
-#define MPT2_DIAG_BUFFER_IS_DIAG_RESET	(0x04)
-
-/* application flags for mpt2_diag_register, mpt2_diag_query */
-#define MPT2_APP_FLAGS_APP_OWNED	(0x0001)
-#define MPT2_APP_FLAGS_BUFFER_VALID	(0x0002)
-#define MPT2_APP_FLAGS_FW_BUFFER_ACCESS	(0x0004)
-
-/* flags for mpt2_diag_read_buffer */
-#define MPT2_FLAGS_REREGISTER		(0x0001)
-
-#define MPT2_PRODUCT_SPECIFIC_DWORDS 		23
-
-/**
- * struct mpt2_diag_register - application register with driver
- * @hdr - generic header
- * @reserved -
- * @buffer_type - specifies either TRACE, SNAPSHOT, or EXTENDED
- * @application_flags - misc flags
- * @diagnostic_flags - specifies flags affecting command processing
- * @product_specific - product specific information
- * @requested_buffer_size - buffers size in bytes
- * @unique_id - tag specified by application that is used to signal ownership
- *  of the buffer.
- *
- * This will allow the driver to setup any required buffers that will be
- * needed by firmware to communicate with the driver.
- */
-struct mpt2_diag_register {
-	struct mpt2_ioctl_header hdr;
-	uint8_t reserved;
-	uint8_t buffer_type;
-	uint16_t application_flags;
-	uint32_t diagnostic_flags;
-	uint32_t product_specific[MPT2_PRODUCT_SPECIFIC_DWORDS];
-	uint32_t requested_buffer_size;
-	uint32_t unique_id;
-};
-
-/**
- * struct mpt2_diag_unregister - application unregister with driver
- * @hdr - generic header
- * @unique_id - tag uniquely identifies the buffer to be unregistered
- *
- * This will allow the driver to cleanup any memory allocated for diag
- * messages and to free up any resources.
- */
-struct mpt2_diag_unregister {
-	struct mpt2_ioctl_header hdr;
-	uint32_t unique_id;
-};
-
-/**
- * struct mpt2_diag_query - query relevant info associated with diag buffers
- * @hdr - generic header
- * @reserved -
- * @buffer_type - specifies either TRACE, SNAPSHOT, or EXTENDED
- * @application_flags - misc flags
- * @diagnostic_flags - specifies flags affecting command processing
- * @product_specific - product specific information
- * @total_buffer_size - diag buffer size in bytes
- * @driver_added_buffer_size - size of extra space appended to end of buffer
- * @unique_id - unique id associated with this buffer.
- *
- * The application will send only buffer_type and unique_id.  Driver will
- * inspect unique_id first, if valid, fill in all the info.  If unique_id is
- * 0x00, the driver will return info specified by Buffer Type.
- */
-struct mpt2_diag_query {
-	struct mpt2_ioctl_header hdr;
-	uint8_t reserved;
-	uint8_t buffer_type;
-	uint16_t application_flags;
-	uint32_t diagnostic_flags;
-	uint32_t product_specific[MPT2_PRODUCT_SPECIFIC_DWORDS];
-	uint32_t total_buffer_size;
-	uint32_t driver_added_buffer_size;
-	uint32_t unique_id;
-};
-
-/**
- * struct mpt2_diag_release -  request to send Diag Release Message to firmware
- * @hdr - generic header
- * @unique_id - tag uniquely identifies the buffer to be released
- *
- * This allows ownership of the specified buffer to returned to the driver,
- * allowing an application to read the buffer without fear that firmware is
- * overwritting information in the buffer.
- */
-struct mpt2_diag_release {
-	struct mpt2_ioctl_header hdr;
-	uint32_t unique_id;
-};
-
-/**
- * struct mpt2_diag_read_buffer - request for copy of the diag buffer
- * @hdr - generic header
- * @status -
- * @reserved -
- * @flags - misc flags
- * @starting_offset - starting offset within drivers buffer where to start
- *  reading data at into the specified application buffer
- * @bytes_to_read - number of bytes to copy from the drivers buffer into the
- *  application buffer starting at starting_offset.
- * @unique_id - unique id associated with this buffer.
- * @diagnostic_data - data payload
- */
-struct mpt2_diag_read_buffer {
-	struct mpt2_ioctl_header hdr;
-	uint8_t status;
-	uint8_t reserved;
-	uint16_t flags;
-	uint32_t starting_offset;
-	uint32_t bytes_to_read;
-	uint32_t unique_id;
-	uint32_t diagnostic_data[1];
-};
-
-#endif /* MPT2SAS_CTL_H_INCLUDED */
diff --git a/drivers/scsi/mpt2sas/mpt2sas_debug.h b/drivers/scsi/mpt2sas/mpt2sas_debug.h
deleted file mode 100644
index 277120d45648..000000000000
--- a/drivers/scsi/mpt2sas/mpt2sas_debug.h
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Logging Support for MPT (Message Passing Technology) based controllers
- *
- * This code is based on drivers/scsi/mpt2sas/mpt2_debug.c
- * Copyright (C) 2007-2014  LSI Corporation
- * Copyright (C) 20013-2014 Avago Technologies
- *  (mailto: MPT-FusionLinux.pdl@avagotech.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * NO WARRANTY
- * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
- * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
- * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
- * solely responsible for determining the appropriateness of using and
- * distributing the Program and assumes all risks associated with its
- * exercise of rights under this Agreement, including but not limited to
- * the risks and costs of program errors, damage to or loss of data,
- * programs or equipment, and unavailability or interruption of operations.
-
- * DISCLAIMER OF LIABILITY
- * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
- * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
-
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
- * USA.
- */
-
-#ifndef MPT2SAS_DEBUG_H_INCLUDED
-#define MPT2SAS_DEBUG_H_INCLUDED
-
-#define MPT_DEBUG			0x00000001
-#define MPT_DEBUG_MSG_FRAME		0x00000002
-#define MPT_DEBUG_SG			0x00000004
-#define MPT_DEBUG_EVENTS		0x00000008
-#define MPT_DEBUG_EVENT_WORK_TASK	0x00000010
-#define MPT_DEBUG_INIT			0x00000020
-#define MPT_DEBUG_EXIT			0x00000040
-#define MPT_DEBUG_FAIL			0x00000080
-#define MPT_DEBUG_TM			0x00000100
-#define MPT_DEBUG_REPLY			0x00000200
-#define MPT_DEBUG_HANDSHAKE		0x00000400
-#define MPT_DEBUG_CONFIG		0x00000800
-#define MPT_DEBUG_DL			0x00001000
-#define MPT_DEBUG_RESET			0x00002000
-#define MPT_DEBUG_SCSI			0x00004000
-#define MPT_DEBUG_IOCTL			0x00008000
-#define MPT_DEBUG_CSMISAS		0x00010000
-#define MPT_DEBUG_SAS			0x00020000
-#define MPT_DEBUG_TRANSPORT		0x00040000
-#define MPT_DEBUG_TASK_SET_FULL		0x00080000
-
-#define MPT_DEBUG_TARGET_MODE		0x00100000
-
-
-/*
- * CONFIG_SCSI_MPT2SAS_LOGGING - enabled in Kconfig
- */
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-#define MPT_CHECK_LOGGING(IOC, CMD, BITS)			\
-{								\
-	if (IOC->logging_level & BITS)				\
-		CMD;						\
-}
-#else
-#define MPT_CHECK_LOGGING(IOC, CMD, BITS)
-#endif /* CONFIG_SCSI_MPT2SAS_LOGGING */
-
-
-/*
- * debug macros
- */
-
-#define dprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG)
-
-#define dsgprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_SG)
-
-#define devtprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_EVENTS)
-
-#define dewtprintk(IOC, CMD)		\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_EVENT_WORK_TASK)
-
-#define dinitprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_INIT)
-
-#define dexitprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_EXIT)
-
-#define dfailprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_FAIL)
-
-#define dtmprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_TM)
-
-#define dreplyprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_REPLY)
-
-#define dhsprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_HANDSHAKE)
-
-#define dcprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_CONFIG)
-
-#define ddlprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_DL)
-
-#define drsprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_RESET)
-
-#define dsprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_SCSI)
-
-#define dctlprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_IOCTL)
-
-#define dcsmisasprintk(IOC, CMD)		\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_CSMISAS)
-
-#define dsasprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_SAS)
-
-#define dsastransport(IOC, CMD)		\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_SAS_WIDE)
-
-#define dmfprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_MSG_FRAME)
-
-#define dtsfprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_TASK_SET_FULL)
-
-#define dtransportprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_TRANSPORT)
-
-#define dTMprintk(IOC, CMD)			\
-	MPT_CHECK_LOGGING(IOC, CMD, MPT_DEBUG_TARGET_MODE)
-
-/* inline functions for dumping debug data*/
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-/**
- * _debug_dump_mf - print message frame contents
- * @mpi_request: pointer to message frame
- * @sz: number of dwords
- */
-static inline void
-_debug_dump_mf(void *mpi_request, int sz)
-{
-	int i;
-	__le32 *mfp = (__le32 *)mpi_request;
-
-	printk(KERN_INFO "mf:\n\t");
-	for (i = 0; i < sz; i++) {
-		if (i && ((i % 8) == 0))
-			printk("\n\t");
-		printk("%08x ", le32_to_cpu(mfp[i]));
-	}
-	printk("\n");
-}
-#else
-#define _debug_dump_mf(mpi_request, sz)
-#endif /* CONFIG_SCSI_MPT2SAS_LOGGING */
-
-#endif /* MPT2SAS_DEBUG_H_INCLUDED */
* Unmerged path drivers/scsi/mpt2sas/mpt2sas_module.c
diff --git a/drivers/scsi/mpt2sas/mpt2sas_scsih.c b/drivers/scsi/mpt2sas/mpt2sas_scsih.c
deleted file mode 100644
index e8767a114dc2..000000000000
--- a/drivers/scsi/mpt2sas/mpt2sas_scsih.c
+++ /dev/null
@@ -1,8734 +0,0 @@
-/*
- * Scsi Host Layer for MPT (Message Passing Technology) based controllers
- *
- * This code is based on drivers/scsi/mpt2sas/mpt2_scsih.c
- * Copyright (C) 2007-2014  LSI Corporation
- * Copyright (C) 20013-2014 Avago Technologies
- *  (mailto: MPT-FusionLinux.pdl@avagotech.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * NO WARRANTY
- * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
- * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
- * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
- * solely responsible for determining the appropriateness of using and
- * distributing the Program and assumes all risks associated with its
- * exercise of rights under this Agreement, including but not limited to
- * the risks and costs of program errors, damage to or loss of data,
- * programs or equipment, and unavailability or interruption of operations.
-
- * DISCLAIMER OF LIABILITY
- * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
- * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
-
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
- * USA.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/blkdev.h>
-#include <linux/sched.h>
-#include <linux/workqueue.h>
-#include <linux/delay.h>
-#include <linux/pci.h>
-#include <linux/interrupt.h>
-#include <linux/aer.h>
-#include <linux/raid_class.h>
-#include <linux/slab.h>
-
-#include <asm/unaligned.h>
-
-#include "mpt2sas_base.h"
-
-MODULE_AUTHOR(MPT2SAS_AUTHOR);
-MODULE_DESCRIPTION(MPT2SAS_DESCRIPTION);
-MODULE_LICENSE("GPL");
-MODULE_VERSION(MPT2SAS_DRIVER_VERSION);
-
-#define RAID_CHANNEL 1
-
-/* forward proto's */
-static void _scsih_expander_node_remove(struct MPT2SAS_ADAPTER *ioc,
-    struct _sas_node *sas_expander);
-static void _firmware_event_work(struct work_struct *work);
-
-static u8 _scsih_check_for_pending_tm(struct MPT2SAS_ADAPTER *ioc, u16 smid);
-
-static void _scsih_scan_start(struct Scsi_Host *shost);
-static int _scsih_scan_finished(struct Scsi_Host *shost, unsigned long time);
-
-/* global parameters */
-LIST_HEAD(mpt2sas_ioc_list);
-/* global ioc lock for list operations */
-DEFINE_SPINLOCK(gioc_lock);
-/* local parameters */
-static u8 scsi_io_cb_idx = -1;
-static u8 tm_cb_idx = -1;
-static u8 ctl_cb_idx = -1;
-static u8 base_cb_idx = -1;
-static u8 port_enable_cb_idx = -1;
-static u8 transport_cb_idx = -1;
-static u8 scsih_cb_idx = -1;
-static u8 config_cb_idx = -1;
-static int mpt_ids;
-
-static u8 tm_tr_cb_idx = -1 ;
-static u8 tm_tr_volume_cb_idx = -1 ;
-static u8 tm_sas_control_cb_idx = -1;
-
-/* command line options */
-static u32 logging_level;
-MODULE_PARM_DESC(logging_level, " bits for enabling additional logging info "
-    "(default=0)");
-
-static ushort max_sectors = 0xFFFF;
-module_param(max_sectors, ushort, 0);
-MODULE_PARM_DESC(max_sectors, "max sectors, range 64 to 32767  default=32767");
-
-static int missing_delay[2] = {-1, -1};
-module_param_array(missing_delay, int, NULL, 0);
-MODULE_PARM_DESC(missing_delay, " device missing delay , io missing delay");
-
-/* scsi-mid layer global parmeter is max_report_luns, which is 511 */
-#define MPT2SAS_MAX_LUN (16895)
-static int max_lun = MPT2SAS_MAX_LUN;
-module_param(max_lun, int, 0);
-MODULE_PARM_DESC(max_lun, " max lun, default=16895 ");
-
-/* diag_buffer_enable is bitwise
- * bit 0 set = TRACE
- * bit 1 set = SNAPSHOT
- * bit 2 set = EXTENDED
- *
- * Either bit can be set, or both
- */
-static int diag_buffer_enable = -1;
-module_param(diag_buffer_enable, int, 0);
-MODULE_PARM_DESC(diag_buffer_enable, " post diag buffers "
-	"(TRACE=1/SNAPSHOT=2/EXTENDED=4/default=0)");
-
-static int disable_discovery = -1;
-module_param(disable_discovery, int, 0);
-MODULE_PARM_DESC(disable_discovery, " disable discovery ");
-
-/* permit overriding the host protection capabilities mask (EEDP/T10 PI) */
-static int prot_mask = 0;
-module_param(prot_mask, int, 0);
-MODULE_PARM_DESC(prot_mask, " host protection capabilities mask, def=7 ");
-
-/**
- * struct sense_info - common structure for obtaining sense keys
- * @skey: sense key
- * @asc: additional sense code
- * @ascq: additional sense code qualifier
- */
-struct sense_info {
-	u8 skey;
-	u8 asc;
-	u8 ascq;
-};
-
-
-#define MPT2SAS_TURN_ON_PFA_LED (0xFFFC)
-#define MPT2SAS_PORT_ENABLE_COMPLETE (0xFFFD)
-#define MPT2SAS_REMOVE_UNRESPONDING_DEVICES (0xFFFF)
-/**
- * struct fw_event_work - firmware event struct
- * @list: link list framework
- * @work: work object (ioc->fault_reset_work_q)
- * @cancel_pending_work: flag set during reset handling
- * @ioc: per adapter object
- * @device_handle: device handle
- * @VF_ID: virtual function id
- * @VP_ID: virtual port id
- * @ignore: flag meaning this event has been marked to ignore
- * @event: firmware event MPI2_EVENT_XXX defined in mpt2_ioc.h
- * @event_data: reply event data payload follows
- *
- * This object stored on ioc->fw_event_list.
- */
-struct fw_event_work {
-	struct list_head 	list;
-	u8			cancel_pending_work;
-	struct delayed_work	delayed_work;
-	struct MPT2SAS_ADAPTER *ioc;
-	u16			device_handle;
-	u8			VF_ID;
-	u8			VP_ID;
-	u8			ignore;
-	u16			event;
-	struct kref		refcount;
-	char			event_data[0] __aligned(4);
-};
-
-static void fw_event_work_free(struct kref *r)
-{
-	kfree(container_of(r, struct fw_event_work, refcount));
-}
-
-static void fw_event_work_get(struct fw_event_work *fw_work)
-{
-	kref_get(&fw_work->refcount);
-}
-
-static void fw_event_work_put(struct fw_event_work *fw_work)
-{
-	kref_put(&fw_work->refcount, fw_event_work_free);
-}
-
-static struct fw_event_work *alloc_fw_event_work(int len)
-{
-	struct fw_event_work *fw_event;
-
-	fw_event = kzalloc(sizeof(*fw_event) + len, GFP_ATOMIC);
-	if (!fw_event)
-		return NULL;
-
-	kref_init(&fw_event->refcount);
-	return fw_event;
-}
-
-/* raid transport support */
-static struct raid_template *mpt2sas_raid_template;
-
-/**
- * struct _scsi_io_transfer - scsi io transfer
- * @handle: sas device handle (assigned by firmware)
- * @is_raid: flag set for hidden raid components
- * @dir: DMA_TO_DEVICE, DMA_FROM_DEVICE,
- * @data_length: data transfer length
- * @data_dma: dma pointer to data
- * @sense: sense data
- * @lun: lun number
- * @cdb_length: cdb length
- * @cdb: cdb contents
- * @timeout: timeout for this command
- * @VF_ID: virtual function id
- * @VP_ID: virtual port id
- * @valid_reply: flag set for reply message
- * @sense_length: sense length
- * @ioc_status: ioc status
- * @scsi_state: scsi state
- * @scsi_status: scsi staus
- * @log_info: log information
- * @transfer_length: data length transfer when there is a reply message
- *
- * Used for sending internal scsi commands to devices within this module.
- * Refer to _scsi_send_scsi_io().
- */
-struct _scsi_io_transfer {
-	u16	handle;
-	u8	is_raid;
-	enum dma_data_direction dir;
-	u32	data_length;
-	dma_addr_t data_dma;
-	u8 	sense[SCSI_SENSE_BUFFERSIZE];
-	u32	lun;
-	u8	cdb_length;
-	u8	cdb[32];
-	u8	timeout;
-	u8	VF_ID;
-	u8	VP_ID;
-	u8	valid_reply;
-  /* the following bits are only valid when 'valid_reply = 1' */
-	u32	sense_length;
-	u16	ioc_status;
-	u8	scsi_state;
-	u8	scsi_status;
-	u32	log_info;
-	u32	transfer_length;
-};
-
-/*
- * The pci device ids are defined in mpi/mpi2_cnfg.h.
- */
-static struct pci_device_id scsih_pci_table[] = {
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2004,
-		PCI_ANY_ID, PCI_ANY_ID },
-	/* Falcon ~ 2008*/
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2008,
-		PCI_ANY_ID, PCI_ANY_ID },
-	/* Liberator ~ 2108 */
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2108_1,
-		PCI_ANY_ID, PCI_ANY_ID },
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2108_2,
-		PCI_ANY_ID, PCI_ANY_ID },
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2108_3,
-		PCI_ANY_ID, PCI_ANY_ID },
-	/* Meteor ~ 2116 */
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2116_1,
-		PCI_ANY_ID, PCI_ANY_ID },
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2116_2,
-		PCI_ANY_ID, PCI_ANY_ID },
-	/* Thunderbolt ~ 2208 */
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_1,
-		PCI_ANY_ID, PCI_ANY_ID },
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_2,
-		PCI_ANY_ID, PCI_ANY_ID },
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_3,
-		PCI_ANY_ID, PCI_ANY_ID },
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_4,
-		PCI_ANY_ID, PCI_ANY_ID },
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_5,
-		PCI_ANY_ID, PCI_ANY_ID },
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_6,
-		PCI_ANY_ID, PCI_ANY_ID },
-	/* Mustang ~ 2308 */
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2308_1,
-		PCI_ANY_ID, PCI_ANY_ID },
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2308_2,
-		PCI_ANY_ID, PCI_ANY_ID },
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2308_3,
-		PCI_ANY_ID, PCI_ANY_ID },
-	/* SSS6200 */
-	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SSS6200,
-		PCI_ANY_ID, PCI_ANY_ID },
-	{0}	/* Terminating entry */
-};
-MODULE_DEVICE_TABLE(pci, scsih_pci_table);
-
-/**
- * _scsih_set_debug_level - global setting of ioc->logging_level.
- *
- * Note: The logging levels are defined in mpt2sas_debug.h.
- */
-static int
-_scsih_set_debug_level(const char *val, struct kernel_param *kp)
-{
-	int ret = param_set_int(val, kp);
-	struct MPT2SAS_ADAPTER *ioc;
-
-	if (ret)
-		return ret;
-
-	printk(KERN_INFO "setting logging_level(0x%08x)\n", logging_level);
-	spin_lock(&gioc_lock);
-	list_for_each_entry(ioc, &mpt2sas_ioc_list, list)
-		ioc->logging_level = logging_level;
-	spin_unlock(&gioc_lock);
-	return 0;
-}
-module_param_call(logging_level, _scsih_set_debug_level, param_get_int,
-    &logging_level, 0644);
-
-/**
- * _scsih_srch_boot_sas_address - search based on sas_address
- * @sas_address: sas address
- * @boot_device: boot device object from bios page 2
- *
- * Returns 1 when there's a match, 0 means no match.
- */
-static inline int
-_scsih_srch_boot_sas_address(u64 sas_address,
-    Mpi2BootDeviceSasWwid_t *boot_device)
-{
-	return (sas_address == le64_to_cpu(boot_device->SASAddress)) ?  1 : 0;
-}
-
-/**
- * _scsih_srch_boot_device_name - search based on device name
- * @device_name: device name specified in INDENTIFY fram
- * @boot_device: boot device object from bios page 2
- *
- * Returns 1 when there's a match, 0 means no match.
- */
-static inline int
-_scsih_srch_boot_device_name(u64 device_name,
-    Mpi2BootDeviceDeviceName_t *boot_device)
-{
-	return (device_name == le64_to_cpu(boot_device->DeviceName)) ? 1 : 0;
-}
-
-/**
- * _scsih_srch_boot_encl_slot - search based on enclosure_logical_id/slot
- * @enclosure_logical_id: enclosure logical id
- * @slot_number: slot number
- * @boot_device: boot device object from bios page 2
- *
- * Returns 1 when there's a match, 0 means no match.
- */
-static inline int
-_scsih_srch_boot_encl_slot(u64 enclosure_logical_id, u16 slot_number,
-    Mpi2BootDeviceEnclosureSlot_t *boot_device)
-{
-	return (enclosure_logical_id == le64_to_cpu(boot_device->
-	    EnclosureLogicalID) && slot_number == le16_to_cpu(boot_device->
-	    SlotNumber)) ? 1 : 0;
-}
-
-/**
- * _scsih_is_boot_device - search for matching boot device.
- * @sas_address: sas address
- * @device_name: device name specified in INDENTIFY fram
- * @enclosure_logical_id: enclosure logical id
- * @slot_number: slot number
- * @form: specifies boot device form
- * @boot_device: boot device object from bios page 2
- *
- * Returns 1 when there's a match, 0 means no match.
- */
-static int
-_scsih_is_boot_device(u64 sas_address, u64 device_name,
-    u64 enclosure_logical_id, u16 slot, u8 form,
-    Mpi2BiosPage2BootDevice_t *boot_device)
-{
-	int rc = 0;
-
-	switch (form) {
-	case MPI2_BIOSPAGE2_FORM_SAS_WWID:
-		if (!sas_address)
-			break;
-		rc = _scsih_srch_boot_sas_address(
-		    sas_address, &boot_device->SasWwid);
-		break;
-	case MPI2_BIOSPAGE2_FORM_ENCLOSURE_SLOT:
-		if (!enclosure_logical_id)
-			break;
-		rc = _scsih_srch_boot_encl_slot(
-		    enclosure_logical_id,
-		    slot, &boot_device->EnclosureSlot);
-		break;
-	case MPI2_BIOSPAGE2_FORM_DEVICE_NAME:
-		if (!device_name)
-			break;
-		rc = _scsih_srch_boot_device_name(
-		    device_name, &boot_device->DeviceName);
-		break;
-	case MPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED:
-		break;
-	}
-
-	return rc;
-}
-
-/**
- * _scsih_get_sas_address - set the sas_address for given device handle
- * @handle: device handle
- * @sas_address: sas address
- *
- * Returns 0 success, non-zero when failure
- */
-static int
-_scsih_get_sas_address(struct MPT2SAS_ADAPTER *ioc, u16 handle,
-    u64 *sas_address)
-{
-	Mpi2SasDevicePage0_t sas_device_pg0;
-	Mpi2ConfigReply_t mpi_reply;
-	u32 ioc_status;
-	*sas_address = 0;
-
-	if (handle <= ioc->sas_hba.num_phys) {
-		*sas_address = ioc->sas_hba.sas_address;
-		return 0;
-	}
-
-	if ((mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,
-	    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n", ioc->name,
-		__FILE__, __LINE__, __func__);
-		return -ENXIO;
-	}
-
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;
-	if (ioc_status == MPI2_IOCSTATUS_SUCCESS) {
-		*sas_address = le64_to_cpu(sas_device_pg0.SASAddress);
-		return 0;
-	}
-
-	/* we hit this becuase the given parent handle doesn't exist */
-	if (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)
-		return -ENXIO;
-	/* else error case */
-	printk(MPT2SAS_ERR_FMT "handle(0x%04x), ioc_status(0x%04x), "
-	    "failure at %s:%d/%s()!\n", ioc->name, handle, ioc_status,
-	     __FILE__, __LINE__, __func__);
-	return -EIO;
-}
-
-/**
- * _scsih_determine_boot_device - determine boot device.
- * @ioc: per adapter object
- * @device: either sas_device or raid_device object
- * @is_raid: [flag] 1 = raid object, 0 = sas object
- *
- * Determines whether this device should be first reported device to
- * to scsi-ml or sas transport, this purpose is for persistent boot device.
- * There are primary, alternate, and current entries in bios page 2. The order
- * priority is primary, alternate, then current.  This routine saves
- * the corresponding device object and is_raid flag in the ioc object.
- * The saved data to be used later in _scsih_probe_boot_devices().
- */
-static void
-_scsih_determine_boot_device(struct MPT2SAS_ADAPTER *ioc,
-    void *device, u8 is_raid)
-{
-	struct _sas_device *sas_device;
-	struct _raid_device *raid_device;
-	u64 sas_address;
-	u64 device_name;
-	u64 enclosure_logical_id;
-	u16 slot;
-
-	 /* only process this function when driver loads */
-	if (!ioc->is_driver_loading)
-		return;
-
-	 /* no Bios, return immediately */
-	if (!ioc->bios_pg3.BiosVersion)
-		return;
-
-	if (!is_raid) {
-		sas_device = device;
-		sas_address = sas_device->sas_address;
-		device_name = sas_device->device_name;
-		enclosure_logical_id = sas_device->enclosure_logical_id;
-		slot = sas_device->slot;
-	} else {
-		raid_device = device;
-		sas_address = raid_device->wwid;
-		device_name = 0;
-		enclosure_logical_id = 0;
-		slot = 0;
-	}
-
-	if (!ioc->req_boot_device.device) {
-		if (_scsih_is_boot_device(sas_address, device_name,
-		    enclosure_logical_id, slot,
-		    (ioc->bios_pg2.ReqBootDeviceForm &
-		    MPI2_BIOSPAGE2_FORM_MASK),
-		    &ioc->bios_pg2.RequestedBootDevice)) {
-			dinitprintk(ioc, printk(MPT2SAS_INFO_FMT
-			   "%s: req_boot_device(0x%016llx)\n",
-			    ioc->name, __func__,
-			    (unsigned long long)sas_address));
-			ioc->req_boot_device.device = device;
-			ioc->req_boot_device.is_raid = is_raid;
-		}
-	}
-
-	if (!ioc->req_alt_boot_device.device) {
-		if (_scsih_is_boot_device(sas_address, device_name,
-		    enclosure_logical_id, slot,
-		    (ioc->bios_pg2.ReqAltBootDeviceForm &
-		    MPI2_BIOSPAGE2_FORM_MASK),
-		    &ioc->bios_pg2.RequestedAltBootDevice)) {
-			dinitprintk(ioc, printk(MPT2SAS_INFO_FMT
-			   "%s: req_alt_boot_device(0x%016llx)\n",
-			    ioc->name, __func__,
-			    (unsigned long long)sas_address));
-			ioc->req_alt_boot_device.device = device;
-			ioc->req_alt_boot_device.is_raid = is_raid;
-		}
-	}
-
-	if (!ioc->current_boot_device.device) {
-		if (_scsih_is_boot_device(sas_address, device_name,
-		    enclosure_logical_id, slot,
-		    (ioc->bios_pg2.CurrentBootDeviceForm &
-		    MPI2_BIOSPAGE2_FORM_MASK),
-		    &ioc->bios_pg2.CurrentBootDevice)) {
-			dinitprintk(ioc, printk(MPT2SAS_INFO_FMT
-			   "%s: current_boot_device(0x%016llx)\n",
-			    ioc->name, __func__,
-			    (unsigned long long)sas_address));
-			ioc->current_boot_device.device = device;
-			ioc->current_boot_device.is_raid = is_raid;
-		}
-	}
-}
-
-/**
- * mpt2sas_scsih_sas_device_find_by_sas_address - sas device search
- * @ioc: per adapter object
- * @sas_address: sas address
- * Context: Calling function should acquire ioc->sas_device_lock
- *
- * This searches for sas_device based on sas_address, then return sas_device
- * object.
- */
-struct _sas_device *
-mpt2sas_scsih_sas_device_find_by_sas_address(struct MPT2SAS_ADAPTER *ioc,
-    u64 sas_address)
-{
-	struct _sas_device *sas_device;
-
-	list_for_each_entry(sas_device, &ioc->sas_device_list, list)
-		if (sas_device->sas_address == sas_address)
-			return sas_device;
-
-	list_for_each_entry(sas_device, &ioc->sas_device_init_list, list)
-		if (sas_device->sas_address == sas_address)
-			return sas_device;
-
-	return NULL;
-}
-
-/**
- * _scsih_sas_device_find_by_handle - sas device search
- * @ioc: per adapter object
- * @handle: sas device handle (assigned by firmware)
- * Context: Calling function should acquire ioc->sas_device_lock
- *
- * This searches for sas_device based on sas_address, then return sas_device
- * object.
- */
-static struct _sas_device *
-_scsih_sas_device_find_by_handle(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	struct _sas_device *sas_device;
-
-	list_for_each_entry(sas_device, &ioc->sas_device_list, list)
-		if (sas_device->handle == handle)
-			return sas_device;
-
-	list_for_each_entry(sas_device, &ioc->sas_device_init_list, list)
-		if (sas_device->handle == handle)
-			return sas_device;
-
-	return NULL;
-}
-
-/**
- * _scsih_sas_device_remove - remove sas_device from list.
- * @ioc: per adapter object
- * @sas_device: the sas_device object
- * Context: This function will acquire ioc->sas_device_lock.
- *
- * Removing object and freeing associated memory from the ioc->sas_device_list.
- */
-static void
-_scsih_sas_device_remove(struct MPT2SAS_ADAPTER *ioc,
-    struct _sas_device *sas_device)
-{
-	unsigned long flags;
-
-	if (!sas_device)
-		return;
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	list_del(&sas_device->list);
-	kfree(sas_device);
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-}
-
-
-/**
- * _scsih_sas_device_add - insert sas_device to the list.
- * @ioc: per adapter object
- * @sas_device: the sas_device object
- * Context: This function will acquire ioc->sas_device_lock.
- *
- * Adding new object to the ioc->sas_device_list.
- */
-static void
-_scsih_sas_device_add(struct MPT2SAS_ADAPTER *ioc,
-    struct _sas_device *sas_device)
-{
-	unsigned long flags;
-
-	dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: handle"
-	    "(0x%04x), sas_addr(0x%016llx)\n", ioc->name, __func__,
-	    sas_device->handle, (unsigned long long)sas_device->sas_address));
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	list_add_tail(&sas_device->list, &ioc->sas_device_list);
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-
-	if (!mpt2sas_transport_port_add(ioc, sas_device->handle,
-	     sas_device->sas_address_parent)) {
-		_scsih_sas_device_remove(ioc, sas_device);
-	} else if (!sas_device->starget) {
-		/* When asyn scanning is enabled, its not possible to remove
-		 * devices while scanning is turned on due to an oops in
-		 * scsi_sysfs_add_sdev()->add_device()->sysfs_addrm_start()
-		 */
-		if (!ioc->is_driver_loading) {
-			mpt2sas_transport_port_remove(ioc,
-			sas_device->sas_address,
-			sas_device->sas_address_parent);
-			_scsih_sas_device_remove(ioc, sas_device);
-		}
-	}
-}
-
-/**
- * _scsih_sas_device_init_add - insert sas_device to the list.
- * @ioc: per adapter object
- * @sas_device: the sas_device object
- * Context: This function will acquire ioc->sas_device_lock.
- *
- * Adding new object at driver load time to the ioc->sas_device_init_list.
- */
-static void
-_scsih_sas_device_init_add(struct MPT2SAS_ADAPTER *ioc,
-    struct _sas_device *sas_device)
-{
-	unsigned long flags;
-
-	dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: handle"
-	    "(0x%04x), sas_addr(0x%016llx)\n", ioc->name, __func__,
-	    sas_device->handle, (unsigned long long)sas_device->sas_address));
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	list_add_tail(&sas_device->list, &ioc->sas_device_init_list);
-	_scsih_determine_boot_device(ioc, sas_device, 0);
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-}
-
-/**
- * _scsih_raid_device_find_by_id - raid device search
- * @ioc: per adapter object
- * @id: sas device target id
- * @channel: sas device channel
- * Context: Calling function should acquire ioc->raid_device_lock
- *
- * This searches for raid_device based on target id, then return raid_device
- * object.
- */
-static struct _raid_device *
-_scsih_raid_device_find_by_id(struct MPT2SAS_ADAPTER *ioc, int id, int channel)
-{
-	struct _raid_device *raid_device, *r;
-
-	r = NULL;
-	list_for_each_entry(raid_device, &ioc->raid_device_list, list) {
-		if (raid_device->id == id && raid_device->channel == channel) {
-			r = raid_device;
-			goto out;
-		}
-	}
-
- out:
-	return r;
-}
-
-/**
- * _scsih_raid_device_find_by_handle - raid device search
- * @ioc: per adapter object
- * @handle: sas device handle (assigned by firmware)
- * Context: Calling function should acquire ioc->raid_device_lock
- *
- * This searches for raid_device based on handle, then return raid_device
- * object.
- */
-static struct _raid_device *
-_scsih_raid_device_find_by_handle(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	struct _raid_device *raid_device, *r;
-
-	r = NULL;
-	list_for_each_entry(raid_device, &ioc->raid_device_list, list) {
-		if (raid_device->handle != handle)
-			continue;
-		r = raid_device;
-		goto out;
-	}
-
- out:
-	return r;
-}
-
-/**
- * _scsih_raid_device_find_by_wwid - raid device search
- * @ioc: per adapter object
- * @handle: sas device handle (assigned by firmware)
- * Context: Calling function should acquire ioc->raid_device_lock
- *
- * This searches for raid_device based on wwid, then return raid_device
- * object.
- */
-static struct _raid_device *
-_scsih_raid_device_find_by_wwid(struct MPT2SAS_ADAPTER *ioc, u64 wwid)
-{
-	struct _raid_device *raid_device, *r;
-
-	r = NULL;
-	list_for_each_entry(raid_device, &ioc->raid_device_list, list) {
-		if (raid_device->wwid != wwid)
-			continue;
-		r = raid_device;
-		goto out;
-	}
-
- out:
-	return r;
-}
-
-/**
- * _scsih_raid_device_add - add raid_device object
- * @ioc: per adapter object
- * @raid_device: raid_device object
- *
- * This is added to the raid_device_list link list.
- */
-static void
-_scsih_raid_device_add(struct MPT2SAS_ADAPTER *ioc,
-    struct _raid_device *raid_device)
-{
-	unsigned long flags;
-
-	dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: handle"
-	    "(0x%04x), wwid(0x%016llx)\n", ioc->name, __func__,
-	    raid_device->handle, (unsigned long long)raid_device->wwid));
-
-	spin_lock_irqsave(&ioc->raid_device_lock, flags);
-	list_add_tail(&raid_device->list, &ioc->raid_device_list);
-	spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-}
-
-/**
- * _scsih_raid_device_remove - delete raid_device object
- * @ioc: per adapter object
- * @raid_device: raid_device object
- *
- */
-static void
-_scsih_raid_device_remove(struct MPT2SAS_ADAPTER *ioc,
-    struct _raid_device *raid_device)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&ioc->raid_device_lock, flags);
-	list_del(&raid_device->list);
-	kfree(raid_device);
-	spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-}
-
-/**
- * mpt2sas_scsih_expander_find_by_handle - expander device search
- * @ioc: per adapter object
- * @handle: expander handle (assigned by firmware)
- * Context: Calling function should acquire ioc->sas_device_lock
- *
- * This searches for expander device based on handle, then returns the
- * sas_node object.
- */
-struct _sas_node *
-mpt2sas_scsih_expander_find_by_handle(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	struct _sas_node *sas_expander, *r;
-
-	r = NULL;
-	list_for_each_entry(sas_expander, &ioc->sas_expander_list, list) {
-		if (sas_expander->handle != handle)
-			continue;
-		r = sas_expander;
-		goto out;
-	}
- out:
-	return r;
-}
-
-/**
- * mpt2sas_scsih_expander_find_by_sas_address - expander device search
- * @ioc: per adapter object
- * @sas_address: sas address
- * Context: Calling function should acquire ioc->sas_node_lock.
- *
- * This searches for expander device based on sas_address, then returns the
- * sas_node object.
- */
-struct _sas_node *
-mpt2sas_scsih_expander_find_by_sas_address(struct MPT2SAS_ADAPTER *ioc,
-    u64 sas_address)
-{
-	struct _sas_node *sas_expander, *r;
-
-	r = NULL;
-	list_for_each_entry(sas_expander, &ioc->sas_expander_list, list) {
-		if (sas_expander->sas_address != sas_address)
-			continue;
-		r = sas_expander;
-		goto out;
-	}
- out:
-	return r;
-}
-
-/**
- * _scsih_expander_node_add - insert expander device to the list.
- * @ioc: per adapter object
- * @sas_expander: the sas_device object
- * Context: This function will acquire ioc->sas_node_lock.
- *
- * Adding new object to the ioc->sas_expander_list.
- *
- * Return nothing.
- */
-static void
-_scsih_expander_node_add(struct MPT2SAS_ADAPTER *ioc,
-    struct _sas_node *sas_expander)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&ioc->sas_node_lock, flags);
-	list_add_tail(&sas_expander->list, &ioc->sas_expander_list);
-	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-}
-
-/**
- * _scsih_is_end_device - determines if device is an end device
- * @device_info: bitfield providing information about the device.
- * Context: none
- *
- * Returns 1 if end device.
- */
-static int
-_scsih_is_end_device(u32 device_info)
-{
-	if (device_info & MPI2_SAS_DEVICE_INFO_END_DEVICE &&
-		((device_info & MPI2_SAS_DEVICE_INFO_SSP_TARGET) |
-		(device_info & MPI2_SAS_DEVICE_INFO_STP_TARGET) |
-		(device_info & MPI2_SAS_DEVICE_INFO_SATA_DEVICE)))
-		return 1;
-	else
-		return 0;
-}
-
-/**
- * _scsih_scsi_lookup_get - returns scmd entry
- * @ioc: per adapter object
- * @smid: system request message index
- *
- * Returns the smid stored scmd pointer.
- */
-static struct scsi_cmnd *
-_scsih_scsi_lookup_get(struct MPT2SAS_ADAPTER *ioc, u16 smid)
-{
-	return ioc->scsi_lookup[smid - 1].scmd;
-}
-
-/**
- * _scsih_scsi_lookup_get_clear - returns scmd entry
- * @ioc: per adapter object
- * @smid: system request message index
- *
- * Returns the smid stored scmd pointer.
- * Then will derefrence the stored scmd pointer.
- */
-static inline struct scsi_cmnd *
-_scsih_scsi_lookup_get_clear(struct MPT2SAS_ADAPTER *ioc, u16 smid)
-{
-	unsigned long flags;
-	struct scsi_cmnd *scmd;
-
-	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-	scmd = ioc->scsi_lookup[smid - 1].scmd;
-	ioc->scsi_lookup[smid - 1].scmd = NULL;
-	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-
-	return scmd;
-}
-
-/**
- * _scsih_scsi_lookup_find_by_scmd - scmd lookup
- * @ioc: per adapter object
- * @smid: system request message index
- * @scmd: pointer to scsi command object
- * Context: This function will acquire ioc->scsi_lookup_lock.
- *
- * This will search for a scmd pointer in the scsi_lookup array,
- * returning the revelent smid.  A returned value of zero means invalid.
- */
-static u16
-_scsih_scsi_lookup_find_by_scmd(struct MPT2SAS_ADAPTER *ioc, struct scsi_cmnd
-    *scmd)
-{
-	u16 smid;
-	unsigned long	flags;
-	int i;
-
-	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-	smid = 0;
-	for (i = 0; i < ioc->scsiio_depth; i++) {
-		if (ioc->scsi_lookup[i].scmd == scmd) {
-			smid = ioc->scsi_lookup[i].smid;
-			goto out;
-		}
-	}
- out:
-	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-	return smid;
-}
-
-/**
- * _scsih_scsi_lookup_find_by_target - search for matching channel:id
- * @ioc: per adapter object
- * @id: target id
- * @channel: channel
- * Context: This function will acquire ioc->scsi_lookup_lock.
- *
- * This will search for a matching channel:id in the scsi_lookup array,
- * returning 1 if found.
- */
-static u8
-_scsih_scsi_lookup_find_by_target(struct MPT2SAS_ADAPTER *ioc, int id,
-    int channel)
-{
-	u8 found;
-	unsigned long	flags;
-	int i;
-
-	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-	found = 0;
-	for (i = 0 ; i < ioc->scsiio_depth; i++) {
-		if (ioc->scsi_lookup[i].scmd &&
-		    (ioc->scsi_lookup[i].scmd->device->id == id &&
-		    ioc->scsi_lookup[i].scmd->device->channel == channel)) {
-			found = 1;
-			goto out;
-		}
-	}
- out:
-	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-	return found;
-}
-
-/**
- * _scsih_scsi_lookup_find_by_lun - search for matching channel:id:lun
- * @ioc: per adapter object
- * @id: target id
- * @lun: lun number
- * @channel: channel
- * Context: This function will acquire ioc->scsi_lookup_lock.
- *
- * This will search for a matching channel:id:lun in the scsi_lookup array,
- * returning 1 if found.
- */
-static u8
-_scsih_scsi_lookup_find_by_lun(struct MPT2SAS_ADAPTER *ioc, int id,
-    unsigned int lun, int channel)
-{
-	u8 found;
-	unsigned long	flags;
-	int i;
-
-	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-	found = 0;
-	for (i = 0 ; i < ioc->scsiio_depth; i++) {
-		if (ioc->scsi_lookup[i].scmd &&
-		    (ioc->scsi_lookup[i].scmd->device->id == id &&
-		    ioc->scsi_lookup[i].scmd->device->channel == channel &&
-		    ioc->scsi_lookup[i].scmd->device->lun == lun)) {
-			found = 1;
-			goto out;
-		}
-	}
- out:
-	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-	return found;
-}
-
-/**
- * _scsih_get_chain_buffer_tracker - obtain chain tracker
- * @ioc: per adapter object
- * @smid: smid associated to an IO request
- *
- * Returns chain tracker(from ioc->free_chain_list)
- */
-static struct chain_tracker *
-_scsih_get_chain_buffer_tracker(struct MPT2SAS_ADAPTER *ioc, u16 smid)
-{
-	struct chain_tracker *chain_req;
-	unsigned long flags;
-
-	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-	if (list_empty(&ioc->free_chain_list)) {
-		spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-		dfailprintk(ioc, printk(MPT2SAS_WARN_FMT "chain buffers not "
-			"available\n", ioc->name));
-		return NULL;
-	}
-	chain_req = list_entry(ioc->free_chain_list.next,
-	    struct chain_tracker, tracker_list);
-	list_del_init(&chain_req->tracker_list);
-	list_add_tail(&chain_req->tracker_list,
-	    &ioc->scsi_lookup[smid - 1].chain_list);
-	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-	return chain_req;
-}
-
-/**
- * _scsih_build_scatter_gather - main sg creation routine
- * @ioc: per adapter object
- * @scmd: scsi command
- * @smid: system request message index
- * Context: none.
- *
- * The main routine that builds scatter gather table from a given
- * scsi request sent via the .queuecommand main handler.
- *
- * Returns 0 success, anything else error
- */
-static int
-_scsih_build_scatter_gather(struct MPT2SAS_ADAPTER *ioc,
-    struct scsi_cmnd *scmd, u16 smid)
-{
-	Mpi2SCSIIORequest_t *mpi_request;
-	dma_addr_t chain_dma;
-	struct scatterlist *sg_scmd;
-	void *sg_local, *chain;
-	u32 chain_offset;
-	u32 chain_length;
-	u32 chain_flags;
-	int sges_left;
-	u32 sges_in_segment;
-	u32 sgl_flags;
-	u32 sgl_flags_last_element;
-	u32 sgl_flags_end_buffer;
-	struct chain_tracker *chain_req;
-
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-
-	/* init scatter gather flags */
-	sgl_flags = MPI2_SGE_FLAGS_SIMPLE_ELEMENT;
-	if (scmd->sc_data_direction == DMA_TO_DEVICE)
-		sgl_flags |= MPI2_SGE_FLAGS_HOST_TO_IOC;
-	sgl_flags_last_element = (sgl_flags | MPI2_SGE_FLAGS_LAST_ELEMENT)
-	    << MPI2_SGE_FLAGS_SHIFT;
-	sgl_flags_end_buffer = (sgl_flags | MPI2_SGE_FLAGS_LAST_ELEMENT |
-	    MPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_END_OF_LIST)
-	    << MPI2_SGE_FLAGS_SHIFT;
-	sgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;
-
-	sg_scmd = scsi_sglist(scmd);
-	sges_left = scsi_dma_map(scmd);
-	if (sges_left < 0) {
-		sdev_printk(KERN_ERR, scmd->device, "pci_map_sg"
-		" failed: request for %d bytes!\n", scsi_bufflen(scmd));
-		return -ENOMEM;
-	}
-
-	sg_local = &mpi_request->SGL;
-	sges_in_segment = ioc->max_sges_in_main_message;
-	if (sges_left <= sges_in_segment)
-		goto fill_in_last_segment;
-
-	mpi_request->ChainOffset = (offsetof(Mpi2SCSIIORequest_t, SGL) +
-	    (sges_in_segment * ioc->sge_size))/4;
-
-	/* fill in main message segment when there is a chain following */
-	while (sges_in_segment) {
-		if (sges_in_segment == 1)
-			ioc->base_add_sg_single(sg_local,
-			    sgl_flags_last_element | sg_dma_len(sg_scmd),
-			    sg_dma_address(sg_scmd));
-		else
-			ioc->base_add_sg_single(sg_local, sgl_flags |
-			    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));
-		sg_scmd = sg_next(sg_scmd);
-		sg_local += ioc->sge_size;
-		sges_left--;
-		sges_in_segment--;
-	}
-
-	/* initializing the chain flags and pointers */
-	chain_flags = MPI2_SGE_FLAGS_CHAIN_ELEMENT << MPI2_SGE_FLAGS_SHIFT;
-	chain_req = _scsih_get_chain_buffer_tracker(ioc, smid);
-	if (!chain_req)
-		return -1;
-	chain = chain_req->chain_buffer;
-	chain_dma = chain_req->chain_buffer_dma;
-	do {
-		sges_in_segment = (sges_left <=
-		    ioc->max_sges_in_chain_message) ? sges_left :
-		    ioc->max_sges_in_chain_message;
-		chain_offset = (sges_left == sges_in_segment) ?
-		    0 : (sges_in_segment * ioc->sge_size)/4;
-		chain_length = sges_in_segment * ioc->sge_size;
-		if (chain_offset) {
-			chain_offset = chain_offset <<
-			    MPI2_SGE_CHAIN_OFFSET_SHIFT;
-			chain_length += ioc->sge_size;
-		}
-		ioc->base_add_sg_single(sg_local, chain_flags | chain_offset |
-		    chain_length, chain_dma);
-		sg_local = chain;
-		if (!chain_offset)
-			goto fill_in_last_segment;
-
-		/* fill in chain segments */
-		while (sges_in_segment) {
-			if (sges_in_segment == 1)
-				ioc->base_add_sg_single(sg_local,
-				    sgl_flags_last_element |
-				    sg_dma_len(sg_scmd),
-				    sg_dma_address(sg_scmd));
-			else
-				ioc->base_add_sg_single(sg_local, sgl_flags |
-				    sg_dma_len(sg_scmd),
-				    sg_dma_address(sg_scmd));
-			sg_scmd = sg_next(sg_scmd);
-			sg_local += ioc->sge_size;
-			sges_left--;
-			sges_in_segment--;
-		}
-
-		chain_req = _scsih_get_chain_buffer_tracker(ioc, smid);
-		if (!chain_req)
-			return -1;
-		chain = chain_req->chain_buffer;
-		chain_dma = chain_req->chain_buffer_dma;
-	} while (1);
-
-
- fill_in_last_segment:
-
-	/* fill the last segment */
-	while (sges_left) {
-		if (sges_left == 1)
-			ioc->base_add_sg_single(sg_local, sgl_flags_end_buffer |
-			    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));
-		else
-			ioc->base_add_sg_single(sg_local, sgl_flags |
-			    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));
-		sg_scmd = sg_next(sg_scmd);
-		sg_local += ioc->sge_size;
-		sges_left--;
-	}
-
-	return 0;
-}
-
-/**
- * _scsih_adjust_queue_depth - setting device queue depth
- * @sdev: scsi device struct
- * @qdepth: requested queue depth
- *
- *
- * Returns nothing
- */
-static void
-_scsih_adjust_queue_depth(struct scsi_device *sdev, int qdepth)
-{
-	struct Scsi_Host *shost = sdev->host;
-	int max_depth;
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-	struct _sas_device *sas_device;
-	unsigned long flags;
-
-	max_depth = shost->can_queue;
-
-	/* limit max device queue for SATA to 32 */
-	sas_device_priv_data = sdev->hostdata;
-	if (!sas_device_priv_data)
-		goto not_sata;
-	sas_target_priv_data = sas_device_priv_data->sas_target;
-	if (!sas_target_priv_data)
-		goto not_sata;
-	if ((sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME))
-		goto not_sata;
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-	   sas_device_priv_data->sas_target->sas_address);
-	if (sas_device && sas_device->device_info &
-	    MPI2_SAS_DEVICE_INFO_SATA_DEVICE)
-		max_depth = MPT2SAS_SATA_QUEUE_DEPTH;
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-
- not_sata:
-
-	if (!sdev->tagged_supported)
-		max_depth = 1;
-	if (qdepth > max_depth)
-		qdepth = max_depth;
-	scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), qdepth);
-}
-
-/**
- * _scsih_change_queue_depth - setting device queue depth
- * @sdev: scsi device struct
- * @qdepth: requested queue depth
- * @reason: SCSI_QDEPTH_DEFAULT/SCSI_QDEPTH_QFULL/SCSI_QDEPTH_RAMP_UP
- * (see include/scsi/scsi_host.h for definition)
- *
- * Returns queue depth.
- */
-static int
-_scsih_change_queue_depth(struct scsi_device *sdev, int qdepth, int reason)
-{
-	if (reason == SCSI_QDEPTH_DEFAULT || reason == SCSI_QDEPTH_RAMP_UP)
-		_scsih_adjust_queue_depth(sdev, qdepth);
-	else if (reason == SCSI_QDEPTH_QFULL)
-		scsi_track_queue_full(sdev, qdepth);
-	else
-		return -EOPNOTSUPP;
-
-	if (sdev->inquiry_len > 7)
-		sdev_printk(KERN_INFO, sdev, "qdepth(%d), tagged(%d), "
-		"simple(%d), ordered(%d), scsi_level(%d), cmd_que(%d)\n",
-		sdev->queue_depth, sdev->tagged_supported, sdev->simple_tags,
-		sdev->ordered_tags, sdev->scsi_level,
-		(sdev->inquiry[7] & 2) >> 1);
-
-	return sdev->queue_depth;
-}
-
-/**
- * _scsih_change_queue_type - changing device queue tag type
- * @sdev: scsi device struct
- * @tag_type: requested tag type
- *
- * Returns queue tag type.
- */
-static int
-_scsih_change_queue_type(struct scsi_device *sdev, int tag_type)
-{
-	if (sdev->tagged_supported) {
-		scsi_set_tag_type(sdev, tag_type);
-		if (tag_type)
-			scsi_activate_tcq(sdev, sdev->queue_depth);
-		else
-			scsi_deactivate_tcq(sdev, sdev->queue_depth);
-	} else
-		tag_type = 0;
-
-	return tag_type;
-}
-
-/**
- * _scsih_target_alloc - target add routine
- * @starget: scsi target struct
- *
- * Returns 0 if ok. Any other return is assumed to be an error and
- * the device is ignored.
- */
-static int
-_scsih_target_alloc(struct scsi_target *starget)
-{
-	struct Scsi_Host *shost = dev_to_shost(&starget->dev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-	struct _sas_device *sas_device;
-	struct _raid_device *raid_device;
-	unsigned long flags;
-	struct sas_rphy *rphy;
-
-	sas_target_priv_data = kzalloc(sizeof(*sas_target_priv_data),
-				       GFP_KERNEL);
-	if (!sas_target_priv_data)
-		return -ENOMEM;
-
-	starget->hostdata = sas_target_priv_data;
-	sas_target_priv_data->starget = starget;
-	sas_target_priv_data->handle = MPT2SAS_INVALID_DEVICE_HANDLE;
-
-	/* RAID volumes */
-	if (starget->channel == RAID_CHANNEL) {
-		spin_lock_irqsave(&ioc->raid_device_lock, flags);
-		raid_device = _scsih_raid_device_find_by_id(ioc, starget->id,
-		    starget->channel);
-		if (raid_device) {
-			sas_target_priv_data->handle = raid_device->handle;
-			sas_target_priv_data->sas_address = raid_device->wwid;
-			sas_target_priv_data->flags |= MPT_TARGET_FLAGS_VOLUME;
-			if (ioc->is_warpdrive)
-				sas_target_priv_data->raid_device = raid_device;
-			raid_device->starget = starget;
-		}
-		spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-		return 0;
-	}
-
-	/* sas/sata devices */
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	rphy = dev_to_rphy(starget->dev.parent);
-	sas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-	   rphy->identify.sas_address);
-
-	if (sas_device) {
-		sas_target_priv_data->handle = sas_device->handle;
-		sas_target_priv_data->sas_address = sas_device->sas_address;
-		sas_device->starget = starget;
-		sas_device->id = starget->id;
-		sas_device->channel = starget->channel;
-		if (test_bit(sas_device->handle, ioc->pd_handles))
-			sas_target_priv_data->flags |=
-			    MPT_TARGET_FLAGS_RAID_COMPONENT;
-	}
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-
-	return 0;
-}
-
-/**
- * _scsih_target_destroy - target destroy routine
- * @starget: scsi target struct
- *
- * Returns nothing.
- */
-static void
-_scsih_target_destroy(struct scsi_target *starget)
-{
-	struct Scsi_Host *shost = dev_to_shost(&starget->dev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-	struct _sas_device *sas_device;
-	struct _raid_device *raid_device;
-	unsigned long flags;
-	struct sas_rphy *rphy;
-
-	sas_target_priv_data = starget->hostdata;
-	if (!sas_target_priv_data)
-		return;
-
-	if (starget->channel == RAID_CHANNEL) {
-		spin_lock_irqsave(&ioc->raid_device_lock, flags);
-		raid_device = _scsih_raid_device_find_by_id(ioc, starget->id,
-		    starget->channel);
-		if (raid_device) {
-			raid_device->starget = NULL;
-			raid_device->sdev = NULL;
-		}
-		spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-		goto out;
-	}
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	rphy = dev_to_rphy(starget->dev.parent);
-	sas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-	   rphy->identify.sas_address);
-	if (sas_device && (sas_device->starget == starget) &&
-	    (sas_device->id == starget->id) &&
-	    (sas_device->channel == starget->channel))
-		sas_device->starget = NULL;
-
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-
- out:
-	kfree(sas_target_priv_data);
-	starget->hostdata = NULL;
-}
-
-/**
- * _scsih_slave_alloc - device add routine
- * @sdev: scsi device struct
- *
- * Returns 0 if ok. Any other return is assumed to be an error and
- * the device is ignored.
- */
-static int
-_scsih_slave_alloc(struct scsi_device *sdev)
-{
-	struct Scsi_Host *shost;
-	struct MPT2SAS_ADAPTER *ioc;
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	struct scsi_target *starget;
-	struct _raid_device *raid_device;
-	struct _sas_device *sas_device;
-	unsigned long flags;
-
-	sas_device_priv_data = kzalloc(sizeof(*sas_device_priv_data),
-				       GFP_KERNEL);
-	if (!sas_device_priv_data)
-		return -ENOMEM;
-
-	sas_device_priv_data->lun = sdev->lun;
-	sas_device_priv_data->flags = MPT_DEVICE_FLAGS_INIT;
-
-	starget = scsi_target(sdev);
-	sas_target_priv_data = starget->hostdata;
-	sas_target_priv_data->num_luns++;
-	sas_device_priv_data->sas_target = sas_target_priv_data;
-	sdev->hostdata = sas_device_priv_data;
-	if ((sas_target_priv_data->flags & MPT_TARGET_FLAGS_RAID_COMPONENT))
-		sdev->no_uld_attach = 1;
-
-	shost = dev_to_shost(&starget->dev);
-	ioc = shost_priv(shost);
-	if (starget->channel == RAID_CHANNEL) {
-		spin_lock_irqsave(&ioc->raid_device_lock, flags);
-		raid_device = _scsih_raid_device_find_by_id(ioc,
-		    starget->id, starget->channel);
-		if (raid_device)
-			raid_device->sdev = sdev; /* raid is single lun */
-		spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-	}
-
-	if (!(sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME)) {
-		spin_lock_irqsave(&ioc->sas_device_lock, flags);
-		sas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-				sas_target_priv_data->sas_address);
-		if (sas_device && (sas_device->starget == NULL)) {
-			sdev_printk(KERN_INFO, sdev,
-			     "%s : sas_device->starget set to starget @ %d\n",
-			     __func__, __LINE__);
-			sas_device->starget = starget;
-		}
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	}
-
-	return 0;
-}
-
-/**
- * _scsih_slave_destroy - device destroy routine
- * @sdev: scsi device struct
- *
- * Returns nothing.
- */
-static void
-_scsih_slave_destroy(struct scsi_device *sdev)
-{
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-	struct scsi_target *starget;
-	struct Scsi_Host *shost;
-	struct MPT2SAS_ADAPTER *ioc;
-	struct _sas_device *sas_device;
-	unsigned long flags;
-
-	if (!sdev->hostdata)
-		return;
-
-	starget = scsi_target(sdev);
-	sas_target_priv_data = starget->hostdata;
-	sas_target_priv_data->num_luns--;
-
-	shost = dev_to_shost(&starget->dev);
-	ioc = shost_priv(shost);
-
-	if (!(sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME)) {
-		spin_lock_irqsave(&ioc->sas_device_lock, flags);
-		sas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-		   sas_target_priv_data->sas_address);
-		if (sas_device && !sas_target_priv_data->num_luns)
-			sas_device->starget = NULL;
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	}
-
-	kfree(sdev->hostdata);
-	sdev->hostdata = NULL;
-}
-
-/**
- * _scsih_display_sata_capabilities - sata capabilities
- * @ioc: per adapter object
- * @handle: device handle
- * @sdev: scsi device struct
- */
-static void
-_scsih_display_sata_capabilities(struct MPT2SAS_ADAPTER *ioc,
-	u16 handle, struct scsi_device *sdev)
-{
-	Mpi2ConfigReply_t mpi_reply;
-	Mpi2SasDevicePage0_t sas_device_pg0;
-	u32 ioc_status;
-	u16 flags;
-	u32 device_info;
-
-	if ((mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,
-	    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return;
-	}
-
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-	    MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return;
-	}
-
-	flags = le16_to_cpu(sas_device_pg0.Flags);
-	device_info = le32_to_cpu(sas_device_pg0.DeviceInfo);
-
-	sdev_printk(KERN_INFO, sdev,
-	    "atapi(%s), ncq(%s), asyn_notify(%s), smart(%s), fua(%s), "
-	    "sw_preserve(%s)\n",
-	    (device_info & MPI2_SAS_DEVICE_INFO_ATAPI_DEVICE) ? "y" : "n",
-	    (flags & MPI2_SAS_DEVICE0_FLAGS_SATA_NCQ_SUPPORTED) ? "y" : "n",
-	    (flags & MPI2_SAS_DEVICE0_FLAGS_SATA_ASYNCHRONOUS_NOTIFY) ? "y" :
-	    "n",
-	    (flags & MPI2_SAS_DEVICE0_FLAGS_SATA_SMART_SUPPORTED) ? "y" : "n",
-	    (flags & MPI2_SAS_DEVICE0_FLAGS_SATA_FUA_SUPPORTED) ? "y" : "n",
-	    (flags & MPI2_SAS_DEVICE0_FLAGS_SATA_SW_PRESERVE) ? "y" : "n");
-}
-
-/**
- * _scsih_is_raid - return boolean indicating device is raid volume
- * @dev the device struct object
- */
-static int
-_scsih_is_raid(struct device *dev)
-{
-	struct scsi_device *sdev = to_scsi_device(dev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(sdev->host);
-
-	if (ioc->is_warpdrive)
-		return 0;
-	return (sdev->channel == RAID_CHANNEL) ? 1 : 0;
-}
-
-/**
- * _scsih_get_resync - get raid volume resync percent complete
- * @dev the device struct object
- */
-static void
-_scsih_get_resync(struct device *dev)
-{
-	struct scsi_device *sdev = to_scsi_device(dev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(sdev->host);
-	static struct _raid_device *raid_device;
-	unsigned long flags;
-	Mpi2RaidVolPage0_t vol_pg0;
-	Mpi2ConfigReply_t mpi_reply;
-	u32 volume_status_flags;
-	u8 percent_complete;
-	u16 handle;
-
-	percent_complete = 0;
-	handle = 0;
-	if (ioc->is_warpdrive)
-		goto out;
-
-	spin_lock_irqsave(&ioc->raid_device_lock, flags);
-	raid_device = _scsih_raid_device_find_by_id(ioc, sdev->id,
-	    sdev->channel);
-	if (raid_device) {
-		handle = raid_device->handle;
-		percent_complete = raid_device->percent_complete;
-	}
-	spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-
-	if (!handle)
-		goto out;
-
-	if (mpt2sas_config_get_raid_volume_pg0(ioc, &mpi_reply, &vol_pg0,
-	     MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,
-	     sizeof(Mpi2RaidVolPage0_t))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		percent_complete = 0;
-		goto out;
-	}
-
-	volume_status_flags = le32_to_cpu(vol_pg0.VolumeStatusFlags);
-	if (!(volume_status_flags &
-	    MPI2_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS))
-		percent_complete = 0;
-
- out:
-	raid_set_resync(mpt2sas_raid_template, dev, percent_complete);
-}
-
-/**
- * _scsih_get_state - get raid volume level
- * @dev the device struct object
- */
-static void
-_scsih_get_state(struct device *dev)
-{
-	struct scsi_device *sdev = to_scsi_device(dev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(sdev->host);
-	static struct _raid_device *raid_device;
-	unsigned long flags;
-	Mpi2RaidVolPage0_t vol_pg0;
-	Mpi2ConfigReply_t mpi_reply;
-	u32 volstate;
-	enum raid_state state = RAID_STATE_UNKNOWN;
-	u16 handle = 0;
-
-	spin_lock_irqsave(&ioc->raid_device_lock, flags);
-	raid_device = _scsih_raid_device_find_by_id(ioc, sdev->id,
-	    sdev->channel);
-	if (raid_device)
-		handle = raid_device->handle;
-	spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-
-	if (!raid_device)
-		goto out;
-
-	if (mpt2sas_config_get_raid_volume_pg0(ioc, &mpi_reply, &vol_pg0,
-	     MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,
-	     sizeof(Mpi2RaidVolPage0_t))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out;
-	}
-
-	volstate = le32_to_cpu(vol_pg0.VolumeStatusFlags);
-	if (volstate & MPI2_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS) {
-		state = RAID_STATE_RESYNCING;
-		goto out;
-	}
-
-	switch (vol_pg0.VolumeState) {
-	case MPI2_RAID_VOL_STATE_OPTIMAL:
-	case MPI2_RAID_VOL_STATE_ONLINE:
-		state = RAID_STATE_ACTIVE;
-		break;
-	case  MPI2_RAID_VOL_STATE_DEGRADED:
-		state = RAID_STATE_DEGRADED;
-		break;
-	case MPI2_RAID_VOL_STATE_FAILED:
-	case MPI2_RAID_VOL_STATE_MISSING:
-		state = RAID_STATE_OFFLINE;
-		break;
-	}
- out:
-	raid_set_state(mpt2sas_raid_template, dev, state);
-}
-
-/**
- * _scsih_set_level - set raid level
- * @sdev: scsi device struct
- * @volume_type: volume type
- */
-static void
-_scsih_set_level(struct scsi_device *sdev, u8 volume_type)
-{
-	enum raid_level level = RAID_LEVEL_UNKNOWN;
-
-	switch (volume_type) {
-	case MPI2_RAID_VOL_TYPE_RAID0:
-		level = RAID_LEVEL_0;
-		break;
-	case MPI2_RAID_VOL_TYPE_RAID10:
-		level = RAID_LEVEL_10;
-		break;
-	case MPI2_RAID_VOL_TYPE_RAID1E:
-		level = RAID_LEVEL_1E;
-		break;
-	case MPI2_RAID_VOL_TYPE_RAID1:
-		level = RAID_LEVEL_1;
-		break;
-	}
-
-	raid_set_level(mpt2sas_raid_template, &sdev->sdev_gendev, level);
-}
-
-/**
- * _scsih_get_volume_capabilities - volume capabilities
- * @ioc: per adapter object
- * @sas_device: the raid_device object
- *
- * Returns 0 for success, else 1
- */
-static int
-_scsih_get_volume_capabilities(struct MPT2SAS_ADAPTER *ioc,
-    struct _raid_device *raid_device)
-{
-	Mpi2RaidVolPage0_t *vol_pg0;
-	Mpi2RaidPhysDiskPage0_t pd_pg0;
-	Mpi2SasDevicePage0_t sas_device_pg0;
-	Mpi2ConfigReply_t mpi_reply;
-	u16 sz;
-	u8 num_pds;
-
-	if ((mpt2sas_config_get_number_pds(ioc, raid_device->handle,
-	    &num_pds)) || !num_pds) {
-		dfailprintk(ioc, printk(MPT2SAS_WARN_FMT
-		    "failure at %s:%d/%s()!\n", ioc->name, __FILE__, __LINE__,
-		    __func__));
-		return 1;
-	}
-
-	raid_device->num_pds = num_pds;
-	sz = offsetof(Mpi2RaidVolPage0_t, PhysDisk) + (num_pds *
-	    sizeof(Mpi2RaidVol0PhysDisk_t));
-	vol_pg0 = kzalloc(sz, GFP_KERNEL);
-	if (!vol_pg0) {
-		dfailprintk(ioc, printk(MPT2SAS_WARN_FMT
-		    "failure at %s:%d/%s()!\n", ioc->name, __FILE__, __LINE__,
-		    __func__));
-		return 1;
-	}
-
-	if ((mpt2sas_config_get_raid_volume_pg0(ioc, &mpi_reply, vol_pg0,
-	     MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, raid_device->handle, sz))) {
-		dfailprintk(ioc, printk(MPT2SAS_WARN_FMT
-		    "failure at %s:%d/%s()!\n", ioc->name, __FILE__, __LINE__,
-		    __func__));
-		kfree(vol_pg0);
-		return 1;
-	}
-
-	raid_device->volume_type = vol_pg0->VolumeType;
-
-	/* figure out what the underlying devices are by
-	 * obtaining the device_info bits for the 1st device
-	 */
-	if (!(mpt2sas_config_get_phys_disk_pg0(ioc, &mpi_reply,
-	    &pd_pg0, MPI2_PHYSDISK_PGAD_FORM_PHYSDISKNUM,
-	    vol_pg0->PhysDisk[0].PhysDiskNum))) {
-		if (!(mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply,
-		    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_HANDLE,
-		    le16_to_cpu(pd_pg0.DevHandle)))) {
-			raid_device->device_info =
-			    le32_to_cpu(sas_device_pg0.DeviceInfo);
-		}
-	}
-
-	kfree(vol_pg0);
-	return 0;
-}
-/**
- * _scsih_disable_ddio - Disable direct I/O for all the volumes
- * @ioc: per adapter object
- */
-static void
-_scsih_disable_ddio(struct MPT2SAS_ADAPTER *ioc)
-{
-	Mpi2RaidVolPage1_t vol_pg1;
-	Mpi2ConfigReply_t mpi_reply;
-	struct _raid_device *raid_device;
-	u16 handle;
-	u16 ioc_status;
-	unsigned long flags;
-
-	handle = 0xFFFF;
-	while (!(mpt2sas_config_get_raid_volume_pg1(ioc, &mpi_reply,
-	    &vol_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-		    MPI2_IOCSTATUS_MASK;
-		if (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)
-			break;
-		handle = le16_to_cpu(vol_pg1.DevHandle);
-		spin_lock_irqsave(&ioc->raid_device_lock, flags);
-		raid_device = _scsih_raid_device_find_by_handle(ioc, handle);
-		if (raid_device)
-			raid_device->direct_io_enabled = 0;
-		spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-	}
-	return;
-}
-
-
-/**
- * _scsih_get_num_volumes - Get number of volumes in the ioc
- * @ioc: per adapter object
- */
-static u8
-_scsih_get_num_volumes(struct MPT2SAS_ADAPTER *ioc)
-{
-	Mpi2RaidVolPage1_t vol_pg1;
-	Mpi2ConfigReply_t mpi_reply;
-	u16 handle;
-	u8 vol_cnt = 0;
-	u16 ioc_status;
-
-	handle = 0xFFFF;
-	while (!(mpt2sas_config_get_raid_volume_pg1(ioc, &mpi_reply,
-	    &vol_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-		    MPI2_IOCSTATUS_MASK;
-		if (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)
-			break;
-		vol_cnt++;
-		handle = le16_to_cpu(vol_pg1.DevHandle);
-	}
-	return vol_cnt;
-}
-
-
-/**
- * _scsih_init_warpdrive_properties - Set properties for warpdrive direct I/O.
- * @ioc: per adapter object
- * @raid_device: the raid_device object
- */
-static void
-_scsih_init_warpdrive_properties(struct MPT2SAS_ADAPTER *ioc,
-	struct _raid_device *raid_device)
-{
-	Mpi2RaidVolPage0_t *vol_pg0;
-	Mpi2RaidPhysDiskPage0_t pd_pg0;
-	Mpi2ConfigReply_t mpi_reply;
-	u16 sz;
-	u8 num_pds, count;
-	unsigned long stripe_sz, block_sz;
-	u8 stripe_exp, block_exp;
-	u64 dev_max_lba;
-
-	if (!ioc->is_warpdrive)
-		return;
-
-	if (ioc->mfg_pg10_hide_flag ==  MFG_PAGE10_EXPOSE_ALL_DISKS) {
-		printk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "
-		    "globally as drives are exposed\n", ioc->name);
-		return;
-	}
-	if (_scsih_get_num_volumes(ioc) > 1) {
-		_scsih_disable_ddio(ioc);
-		printk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "
-		    "globally as number of drives > 1\n", ioc->name);
-		return;
-	}
-	if ((mpt2sas_config_get_number_pds(ioc, raid_device->handle,
-	    &num_pds)) || !num_pds) {
-		printk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "
-		    "Failure in computing number of drives\n", ioc->name);
-		return;
-	}
-
-	sz = offsetof(Mpi2RaidVolPage0_t, PhysDisk) + (num_pds *
-	    sizeof(Mpi2RaidVol0PhysDisk_t));
-	vol_pg0 = kzalloc(sz, GFP_KERNEL);
-	if (!vol_pg0) {
-		printk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "
-		    "Memory allocation failure for RVPG0\n", ioc->name);
-		return;
-	}
-
-	if ((mpt2sas_config_get_raid_volume_pg0(ioc, &mpi_reply, vol_pg0,
-	     MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, raid_device->handle, sz))) {
-		printk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "
-		    "Failure in retrieving RVPG0\n", ioc->name);
-		kfree(vol_pg0);
-		return;
-	}
-
-	/*
-	 * WARPDRIVE:If number of physical disks in a volume exceeds the max pds
-	 * assumed for WARPDRIVE, disable direct I/O
-	 */
-	if (num_pds > MPT_MAX_WARPDRIVE_PDS) {
-		printk(MPT2SAS_WARN_FMT "WarpDrive : Direct IO is disabled "
-		    "for the drive with handle(0x%04x): num_mem=%d, "
-		    "max_mem_allowed=%d\n", ioc->name, raid_device->handle,
-		    num_pds, MPT_MAX_WARPDRIVE_PDS);
-		kfree(vol_pg0);
-		return;
-	}
-	for (count = 0; count < num_pds; count++) {
-		if (mpt2sas_config_get_phys_disk_pg0(ioc, &mpi_reply,
-		    &pd_pg0, MPI2_PHYSDISK_PGAD_FORM_PHYSDISKNUM,
-		    vol_pg0->PhysDisk[count].PhysDiskNum) ||
-		     le16_to_cpu(pd_pg0.DevHandle) ==
-		    MPT2SAS_INVALID_DEVICE_HANDLE) {
-			printk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is "
-			    "disabled for the drive with handle(0x%04x) member"
-			    "handle retrieval failed for member number=%d\n",
-			    ioc->name, raid_device->handle,
-			    vol_pg0->PhysDisk[count].PhysDiskNum);
-			goto out_error;
-		}
-		/* Disable direct I/O if member drive lba exceeds 4 bytes */
-		dev_max_lba = le64_to_cpu(pd_pg0.DeviceMaxLBA);
-		if (dev_max_lba >> 32) {
-			printk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is "
-			    "disabled for the drive with handle(0x%04x) member"
-			    "handle (0x%04x) unsupported max lba 0x%016llx\n",
-			    ioc->name, raid_device->handle,
-			    le16_to_cpu(pd_pg0.DevHandle),
-			    (unsigned long long)dev_max_lba);
-			goto out_error;
-		}
-
-		raid_device->pd_handle[count] = le16_to_cpu(pd_pg0.DevHandle);
-	}
-
-	/*
-	 * Assumption for WD: Direct I/O is not supported if the volume is
-	 * not RAID0
-	 */
-	if (raid_device->volume_type != MPI2_RAID_VOL_TYPE_RAID0) {
-		printk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "
-		    "for the drive with handle(0x%04x): type=%d, "
-		    "s_sz=%uK, blk_size=%u\n", ioc->name,
-		    raid_device->handle, raid_device->volume_type,
-		    (le32_to_cpu(vol_pg0->StripeSize) *
-		    le16_to_cpu(vol_pg0->BlockSize)) / 1024,
-		    le16_to_cpu(vol_pg0->BlockSize));
-		goto out_error;
-	}
-
-	stripe_sz = le32_to_cpu(vol_pg0->StripeSize);
-	stripe_exp = find_first_bit(&stripe_sz, 32);
-	if (stripe_exp == 32) {
-		printk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "
-		"for the drive with handle(0x%04x) invalid stripe sz %uK\n",
-		    ioc->name, raid_device->handle,
-		    (le32_to_cpu(vol_pg0->StripeSize) *
-		    le16_to_cpu(vol_pg0->BlockSize)) / 1024);
-		goto out_error;
-	}
-	raid_device->stripe_exponent = stripe_exp;
-	block_sz = le16_to_cpu(vol_pg0->BlockSize);
-	block_exp = find_first_bit(&block_sz, 16);
-	if (block_exp == 16) {
-		printk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "
-		    "for the drive with handle(0x%04x) invalid block sz %u\n",
-		    ioc->name, raid_device->handle,
-		    le16_to_cpu(vol_pg0->BlockSize));
-		goto out_error;
-	}
-	raid_device->block_exponent = block_exp;
-	raid_device->direct_io_enabled = 1;
-
-	printk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is Enabled for the drive"
-	    " with handle(0x%04x)\n", ioc->name, raid_device->handle);
-	/*
-	 * WARPDRIVE: Though the following fields are not used for direct IO,
-	 * stored for future purpose:
-	 */
-	raid_device->max_lba = le64_to_cpu(vol_pg0->MaxLBA);
-	raid_device->stripe_sz = le32_to_cpu(vol_pg0->StripeSize);
-	raid_device->block_sz = le16_to_cpu(vol_pg0->BlockSize);
-
-
-	kfree(vol_pg0);
-	return;
-
-out_error:
-	raid_device->direct_io_enabled = 0;
-	for (count = 0; count < num_pds; count++)
-		raid_device->pd_handle[count] = 0;
-	kfree(vol_pg0);
-	return;
-}
-
-/**
- * _scsih_enable_tlr - setting TLR flags
- * @ioc: per adapter object
- * @sdev: scsi device struct
- *
- * Enabling Transaction Layer Retries for tape devices when
- * vpd page 0x90 is present
- *
- */
-static void
-_scsih_enable_tlr(struct MPT2SAS_ADAPTER *ioc, struct scsi_device *sdev)
-{
-	/* only for TAPE */
-	if (sdev->type != TYPE_TAPE)
-		return;
-
-	if (!(ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_TLR))
-		return;
-
-	sas_enable_tlr(sdev);
-	sdev_printk(KERN_INFO, sdev, "TLR %s\n",
-	    sas_is_tlr_enabled(sdev) ? "Enabled" : "Disabled");
-	return;
-
-}
-
-/**
- * _scsih_slave_configure - device configure routine.
- * @sdev: scsi device struct
- *
- * Returns 0 if ok. Any other return is assumed to be an error and
- * the device is ignored.
- */
-static int
-_scsih_slave_configure(struct scsi_device *sdev)
-{
-	struct Scsi_Host *shost = sdev->host;
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-	struct _sas_device *sas_device;
-	struct _raid_device *raid_device;
-	unsigned long flags;
-	int qdepth;
-	u8 ssp_target = 0;
-	char *ds = "";
-	char *r_level = "";
-	u16 handle, volume_handle = 0;
-	u64 volume_wwid = 0;
-
-	qdepth = 1;
-	sas_device_priv_data = sdev->hostdata;
-	sas_device_priv_data->configured_lun = 1;
-	sas_device_priv_data->flags &= ~MPT_DEVICE_FLAGS_INIT;
-	sas_target_priv_data = sas_device_priv_data->sas_target;
-	handle = sas_target_priv_data->handle;
-
-	/* raid volume handling */
-	if (sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME) {
-
-		spin_lock_irqsave(&ioc->raid_device_lock, flags);
-		raid_device = _scsih_raid_device_find_by_handle(ioc, handle);
-		spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-		if (!raid_device) {
-			dfailprintk(ioc, printk(MPT2SAS_WARN_FMT
-			    "failure at %s:%d/%s()!\n", ioc->name, __FILE__,
-			    __LINE__, __func__));
-			return 1;
-		}
-
-		if (_scsih_get_volume_capabilities(ioc, raid_device)) {
-			dfailprintk(ioc, printk(MPT2SAS_WARN_FMT
-			    "failure at %s:%d/%s()!\n", ioc->name, __FILE__,
-			    __LINE__, __func__));
-			return 1;
-		}
-		/*
-		 * WARPDRIVE: Initialize the required data for Direct IO
-		 */
-		_scsih_init_warpdrive_properties(ioc, raid_device);
-
-		/* RAID Queue Depth Support
-		 * IS volume = underlying qdepth of drive type, either
-		 *    MPT2SAS_SAS_QUEUE_DEPTH or MPT2SAS_SATA_QUEUE_DEPTH
-		 * IM/IME/R10 = 128 (MPT2SAS_RAID_QUEUE_DEPTH)
-		 */
-		if (raid_device->device_info &
-		    MPI2_SAS_DEVICE_INFO_SSP_TARGET) {
-			qdepth = MPT2SAS_SAS_QUEUE_DEPTH;
-			ds = "SSP";
-		} else {
-			qdepth = MPT2SAS_SATA_QUEUE_DEPTH;
-			 if (raid_device->device_info &
-			    MPI2_SAS_DEVICE_INFO_SATA_DEVICE)
-				ds = "SATA";
-			else
-				ds = "STP";
-		}
-
-		switch (raid_device->volume_type) {
-		case MPI2_RAID_VOL_TYPE_RAID0:
-			r_level = "RAID0";
-			break;
-		case MPI2_RAID_VOL_TYPE_RAID1E:
-			qdepth = MPT2SAS_RAID_QUEUE_DEPTH;
-			if (ioc->manu_pg10.OEMIdentifier &&
-			    (le32_to_cpu(ioc->manu_pg10.GenericFlags0) &
-			    MFG10_GF0_R10_DISPLAY) &&
-			    !(raid_device->num_pds % 2))
-				r_level = "RAID10";
-			else
-				r_level = "RAID1E";
-			break;
-		case MPI2_RAID_VOL_TYPE_RAID1:
-			qdepth = MPT2SAS_RAID_QUEUE_DEPTH;
-			r_level = "RAID1";
-			break;
-		case MPI2_RAID_VOL_TYPE_RAID10:
-			qdepth = MPT2SAS_RAID_QUEUE_DEPTH;
-			r_level = "RAID10";
-			break;
-		case MPI2_RAID_VOL_TYPE_UNKNOWN:
-		default:
-			qdepth = MPT2SAS_RAID_QUEUE_DEPTH;
-			r_level = "RAIDX";
-			break;
-		}
-
-		if (!ioc->hide_ir_msg)
-			sdev_printk(KERN_INFO, sdev, "%s: handle(0x%04x), "
-			    "wwid(0x%016llx), pd_count(%d), type(%s)\n",
-			    r_level, raid_device->handle,
-			    (unsigned long long)raid_device->wwid,
-			    raid_device->num_pds, ds);
-		_scsih_change_queue_depth(sdev, qdepth, SCSI_QDEPTH_DEFAULT);
-		/* raid transport support */
-		if (!ioc->is_warpdrive)
-			_scsih_set_level(sdev, raid_device->volume_type);
-		return 0;
-	}
-
-	/* non-raid handling */
-	if (sas_target_priv_data->flags & MPT_TARGET_FLAGS_RAID_COMPONENT) {
-		if (mpt2sas_config_get_volume_handle(ioc, handle,
-		    &volume_handle)) {
-			dfailprintk(ioc, printk(MPT2SAS_WARN_FMT
-			    "failure at %s:%d/%s()!\n", ioc->name,
-			    __FILE__, __LINE__, __func__));
-			return 1;
-		}
-		if (volume_handle && mpt2sas_config_get_volume_wwid(ioc,
-		    volume_handle, &volume_wwid)) {
-			dfailprintk(ioc, printk(MPT2SAS_WARN_FMT
-			    "failure at %s:%d/%s()!\n", ioc->name,
-			    __FILE__, __LINE__, __func__));
-			return 1;
-		}
-	}
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-	   sas_device_priv_data->sas_target->sas_address);
-	if (!sas_device) {
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-		dfailprintk(ioc, printk(MPT2SAS_WARN_FMT
-			"failure at %s:%d/%s()!\n", ioc->name, __FILE__,
-			__LINE__, __func__));
-		return 1;
-	}
-	sas_device->volume_handle = volume_handle;
-	sas_device->volume_wwid = volume_wwid;
-	if (sas_device->device_info & MPI2_SAS_DEVICE_INFO_SSP_TARGET) {
-		qdepth = MPT2SAS_SAS_QUEUE_DEPTH;
-		ssp_target = 1;
-		ds = "SSP";
-	} else {
-		qdepth = MPT2SAS_SATA_QUEUE_DEPTH;
-		if (sas_device->device_info & MPI2_SAS_DEVICE_INFO_STP_TARGET)
-			ds = "STP";
-		else if (sas_device->device_info &
-		    MPI2_SAS_DEVICE_INFO_SATA_DEVICE)
-			ds = "SATA";
-	}
-	sdev_printk(KERN_INFO, sdev, "%s: handle(0x%04x), "
-	    "sas_addr(0x%016llx), phy(%d), device_name(0x%016llx)\n",
-	    ds, sas_device->handle,
-	    (unsigned long long)sas_device->sas_address,
-	    sas_device->phy,
-	    (unsigned long long)sas_device->device_name);
-	sdev_printk(KERN_INFO, sdev, "%s: "
-	    "enclosure_logical_id(0x%016llx), slot(%d)\n", ds,
-	    (unsigned long long) sas_device->enclosure_logical_id,
-	    sas_device->slot);
-
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	if (!ssp_target)
-		_scsih_display_sata_capabilities(ioc, handle, sdev);
-
-
-	_scsih_change_queue_depth(sdev, qdepth, SCSI_QDEPTH_DEFAULT);
-
-	if (ssp_target) {
-		sas_read_port_mode_page(sdev);
-		_scsih_enable_tlr(ioc, sdev);
-	}
-	return 0;
-}
-
-/**
- * _scsih_bios_param - fetch head, sector, cylinder info for a disk
- * @sdev: scsi device struct
- * @bdev: pointer to block device context
- * @capacity: device size (in 512 byte sectors)
- * @params: three element array to place output:
- *              params[0] number of heads (max 255)
- *              params[1] number of sectors (max 63)
- *              params[2] number of cylinders
- *
- * Return nothing.
- */
-static int
-_scsih_bios_param(struct scsi_device *sdev, struct block_device *bdev,
-    sector_t capacity, int params[])
-{
-	int		heads;
-	int		sectors;
-	sector_t	cylinders;
-	ulong 		dummy;
-
-	heads = 64;
-	sectors = 32;
-
-	dummy = heads * sectors;
-	cylinders = capacity;
-	sector_div(cylinders, dummy);
-
-	/*
-	 * Handle extended translation size for logical drives
-	 * > 1Gb
-	 */
-	if ((ulong)capacity >= 0x200000) {
-		heads = 255;
-		sectors = 63;
-		dummy = heads * sectors;
-		cylinders = capacity;
-		sector_div(cylinders, dummy);
-	}
-
-	/* return result */
-	params[0] = heads;
-	params[1] = sectors;
-	params[2] = cylinders;
-
-	return 0;
-}
-
-/**
- * _scsih_response_code - translation of device response code
- * @ioc: per adapter object
- * @response_code: response code returned by the device
- *
- * Return nothing.
- */
-static void
-_scsih_response_code(struct MPT2SAS_ADAPTER *ioc, u8 response_code)
-{
-	char *desc;
-
-	switch (response_code) {
-	case MPI2_SCSITASKMGMT_RSP_TM_COMPLETE:
-		desc = "task management request completed";
-		break;
-	case MPI2_SCSITASKMGMT_RSP_INVALID_FRAME:
-		desc = "invalid frame";
-		break;
-	case MPI2_SCSITASKMGMT_RSP_TM_NOT_SUPPORTED:
-		desc = "task management request not supported";
-		break;
-	case MPI2_SCSITASKMGMT_RSP_TM_FAILED:
-		desc = "task management request failed";
-		break;
-	case MPI2_SCSITASKMGMT_RSP_TM_SUCCEEDED:
-		desc = "task management request succeeded";
-		break;
-	case MPI2_SCSITASKMGMT_RSP_TM_INVALID_LUN:
-		desc = "invalid lun";
-		break;
-	case 0xA:
-		desc = "overlapped tag attempted";
-		break;
-	case MPI2_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC:
-		desc = "task queued, however not sent to target";
-		break;
-	default:
-		desc = "unknown";
-		break;
-	}
-	printk(MPT2SAS_WARN_FMT "response_code(0x%01x): %s\n",
-		ioc->name, response_code, desc);
-}
-
-/**
- * _scsih_tm_done - tm completion routine
- * @ioc: per adapter object
- * @smid: system request message index
- * @msix_index: MSIX table index supplied by the OS
- * @reply: reply message frame(lower 32bit addr)
- * Context: none.
- *
- * The callback handler when using scsih_issue_tm.
- *
- * Return 1 meaning mf should be freed from _base_interrupt
- *        0 means the mf is freed from this function.
- */
-static u8
-_scsih_tm_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)
-{
-	MPI2DefaultReply_t *mpi_reply;
-
-	if (ioc->tm_cmds.status == MPT2_CMD_NOT_USED)
-		return 1;
-	if (ioc->tm_cmds.smid != smid)
-		return 1;
-	mpt2sas_base_flush_reply_queues(ioc);
-	ioc->tm_cmds.status |= MPT2_CMD_COMPLETE;
-	mpi_reply =  mpt2sas_base_get_reply_virt_addr(ioc, reply);
-	if (mpi_reply) {
-		memcpy(ioc->tm_cmds.reply, mpi_reply, mpi_reply->MsgLength*4);
-		ioc->tm_cmds.status |= MPT2_CMD_REPLY_VALID;
-	}
-	ioc->tm_cmds.status &= ~MPT2_CMD_PENDING;
-	complete(&ioc->tm_cmds.done);
-	return 1;
-}
-
-/**
- * mpt2sas_scsih_set_tm_flag - set per target tm_busy
- * @ioc: per adapter object
- * @handle: device handle
- *
- * During taskmangement request, we need to freeze the device queue.
- */
-void
-mpt2sas_scsih_set_tm_flag(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	struct scsi_device *sdev;
-	u8 skip = 0;
-
-	shost_for_each_device(sdev, ioc->shost) {
-		if (skip)
-			continue;
-		sas_device_priv_data = sdev->hostdata;
-		if (!sas_device_priv_data)
-			continue;
-		if (sas_device_priv_data->sas_target->handle == handle) {
-			sas_device_priv_data->sas_target->tm_busy = 1;
-			skip = 1;
-			ioc->ignore_loginfos = 1;
-		}
-	}
-}
-
-/**
- * mpt2sas_scsih_clear_tm_flag - clear per target tm_busy
- * @ioc: per adapter object
- * @handle: device handle
- *
- * During taskmangement request, we need to freeze the device queue.
- */
-void
-mpt2sas_scsih_clear_tm_flag(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	struct scsi_device *sdev;
-	u8 skip = 0;
-
-	shost_for_each_device(sdev, ioc->shost) {
-		if (skip)
-			continue;
-		sas_device_priv_data = sdev->hostdata;
-		if (!sas_device_priv_data)
-			continue;
-		if (sas_device_priv_data->sas_target->handle == handle) {
-			sas_device_priv_data->sas_target->tm_busy = 0;
-			skip = 1;
-			ioc->ignore_loginfos = 0;
-		}
-	}
-}
-
-
-/**
- * mpt2sas_scsih_issue_tm - main routine for sending tm requests
- * @ioc: per adapter struct
- * @device_handle: device handle
- * @channel: the channel assigned by the OS
- * @id: the id assigned by the OS
- * @lun: lun number
- * @type: MPI2_SCSITASKMGMT_TASKTYPE__XXX (defined in mpi2_init.h)
- * @smid_task: smid assigned to the task
- * @timeout: timeout in seconds
- * @m_type: TM_MUTEX_ON or TM_MUTEX_OFF
- * Context: user
- *
- * A generic API for sending task management requests to firmware.
- *
- * The callback index is set inside `ioc->tm_cb_idx`.
- *
- * Return SUCCESS or FAILED.
- */
-int
-mpt2sas_scsih_issue_tm(struct MPT2SAS_ADAPTER *ioc, u16 handle, uint channel,
-    uint id, uint lun, u8 type, u16 smid_task, ulong timeout,
-	enum mutex_type m_type)
-{
-	Mpi2SCSITaskManagementRequest_t *mpi_request;
-	Mpi2SCSITaskManagementReply_t *mpi_reply;
-	u16 smid = 0;
-	u32 ioc_state;
-	unsigned long timeleft;
-	struct scsiio_tracker *scsi_lookup = NULL;
-	int rc;
-
-	if (m_type == TM_MUTEX_ON)
-		mutex_lock(&ioc->tm_cmds.mutex);
-	if (ioc->tm_cmds.status != MPT2_CMD_NOT_USED) {
-		printk(MPT2SAS_INFO_FMT "%s: tm_cmd busy!!!\n",
-		    __func__, ioc->name);
-		rc = FAILED;
-		goto err_out;
-	}
-
-	if (ioc->shost_recovery || ioc->remove_host ||
-	    ioc->pci_error_recovery) {
-		printk(MPT2SAS_INFO_FMT "%s: host reset in progress!\n",
-		    __func__, ioc->name);
-		rc = FAILED;
-		goto err_out;
-	}
-
-	ioc_state = mpt2sas_base_get_iocstate(ioc, 0);
-	if (ioc_state & MPI2_DOORBELL_USED) {
-		dhsprintk(ioc, printk(MPT2SAS_INFO_FMT "unexpected doorbell "
-		    "active!\n", ioc->name));
-		rc = mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-		    FORCE_BIG_HAMMER);
-		rc = (!rc) ? SUCCESS : FAILED;
-		goto err_out;
-	}
-
-	if ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {
-		mpt2sas_base_fault_info(ioc, ioc_state &
-		    MPI2_DOORBELL_DATA_MASK);
-		rc = mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-		    FORCE_BIG_HAMMER);
-		rc = (!rc) ? SUCCESS : FAILED;
-		goto err_out;
-	}
-
-	smid = mpt2sas_base_get_smid_hpr(ioc, ioc->tm_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		rc = FAILED;
-		goto err_out;
-	}
-
-	if (type == MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK)
-		scsi_lookup = &ioc->scsi_lookup[smid_task - 1];
-
-	dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "sending tm: handle(0x%04x),"
-	    " task_type(0x%02x), smid(%d)\n", ioc->name, handle, type,
-	    smid_task));
-	ioc->tm_cmds.status = MPT2_CMD_PENDING;
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	ioc->tm_cmds.smid = smid;
-	memset(mpi_request, 0, sizeof(Mpi2SCSITaskManagementRequest_t));
-	memset(ioc->tm_cmds.reply, 0, sizeof(Mpi2SCSITaskManagementReply_t));
-	mpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;
-	mpi_request->DevHandle = cpu_to_le16(handle);
-	mpi_request->TaskType = type;
-	mpi_request->TaskMID = cpu_to_le16(smid_task);
-	int_to_scsilun(lun, (struct scsi_lun *)mpi_request->LUN);
-	mpt2sas_scsih_set_tm_flag(ioc, handle);
-	init_completion(&ioc->tm_cmds.done);
-	mpt2sas_base_put_smid_hi_priority(ioc, smid);
-	timeleft = wait_for_completion_timeout(&ioc->tm_cmds.done, timeout*HZ);
-	if (!(ioc->tm_cmds.status & MPT2_CMD_COMPLETE)) {
-		printk(MPT2SAS_ERR_FMT "%s: timeout\n",
-		    ioc->name, __func__);
-		_debug_dump_mf(mpi_request,
-		    sizeof(Mpi2SCSITaskManagementRequest_t)/4);
-		if (!(ioc->tm_cmds.status & MPT2_CMD_RESET)) {
-			rc = mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-			    FORCE_BIG_HAMMER);
-			rc = (!rc) ? SUCCESS : FAILED;
-			ioc->tm_cmds.status = MPT2_CMD_NOT_USED;
-			mpt2sas_scsih_clear_tm_flag(ioc, handle);
-			goto err_out;
-		}
-	}
-
-	if (ioc->tm_cmds.status & MPT2_CMD_REPLY_VALID) {
-		mpi_reply = ioc->tm_cmds.reply;
-		dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "complete tm: "
-		    "ioc_status(0x%04x), loginfo(0x%08x), term_count(0x%08x)\n",
-		    ioc->name, le16_to_cpu(mpi_reply->IOCStatus),
-		    le32_to_cpu(mpi_reply->IOCLogInfo),
-		    le32_to_cpu(mpi_reply->TerminationCount)));
-		if (ioc->logging_level & MPT_DEBUG_TM) {
-			_scsih_response_code(ioc, mpi_reply->ResponseCode);
-			if (mpi_reply->IOCStatus)
-				_debug_dump_mf(mpi_request,
-				    sizeof(Mpi2SCSITaskManagementRequest_t)/4);
-		}
-	}
-
-	switch (type) {
-	case MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK:
-		rc = SUCCESS;
-		if (scsi_lookup->scmd == NULL)
-			break;
-		rc = FAILED;
-		break;
-
-	case MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET:
-		if (_scsih_scsi_lookup_find_by_target(ioc, id, channel))
-			rc = FAILED;
-		else
-			rc = SUCCESS;
-		break;
-
-	case MPI2_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET:
-	case MPI2_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET:
-		if (_scsih_scsi_lookup_find_by_lun(ioc, id, lun, channel))
-			rc = FAILED;
-		else
-			rc = SUCCESS;
-		break;
-	case MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK:
-		rc = SUCCESS;
-		break;
-	default:
-		rc = FAILED;
-		break;
-	}
-
-	mpt2sas_scsih_clear_tm_flag(ioc, handle);
-	ioc->tm_cmds.status = MPT2_CMD_NOT_USED;
-	if (m_type == TM_MUTEX_ON)
-		mutex_unlock(&ioc->tm_cmds.mutex);
-
-	return rc;
-
- err_out:
-	if (m_type == TM_MUTEX_ON)
-		mutex_unlock(&ioc->tm_cmds.mutex);
-	return rc;
-}
-
-/**
- * _scsih_tm_display_info - displays info about the device
- * @ioc: per adapter struct
- * @scmd: pointer to scsi command object
- *
- * Called by task management callback handlers.
- */
-static void
-_scsih_tm_display_info(struct MPT2SAS_ADAPTER *ioc, struct scsi_cmnd *scmd)
-{
-	struct scsi_target *starget = scmd->device->sdev_target;
-	struct MPT2SAS_TARGET *priv_target = starget->hostdata;
-	struct _sas_device *sas_device = NULL;
-	unsigned long flags;
-	char *device_str = NULL;
-
-	if (!priv_target)
-		return;
-	if (ioc->hide_ir_msg)
-		device_str = "WarpDrive";
-	else
-		device_str = "volume";
-
-	scsi_print_command(scmd);
-	if (priv_target->flags & MPT_TARGET_FLAGS_VOLUME) {
-		starget_printk(KERN_INFO, starget, "%s handle(0x%04x), "
-		    "%s wwid(0x%016llx)\n", device_str, priv_target->handle,
-		    device_str, (unsigned long long)priv_target->sas_address);
-	} else {
-		spin_lock_irqsave(&ioc->sas_device_lock, flags);
-		sas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-		    priv_target->sas_address);
-		if (sas_device) {
-			if (priv_target->flags &
-			    MPT_TARGET_FLAGS_RAID_COMPONENT) {
-				starget_printk(KERN_INFO, starget,
-				    "volume handle(0x%04x), "
-				    "volume wwid(0x%016llx)\n",
-				    sas_device->volume_handle,
-				   (unsigned long long)sas_device->volume_wwid);
-			}
-			starget_printk(KERN_INFO, starget,
-			    "handle(0x%04x), sas_address(0x%016llx), phy(%d)\n",
-			    sas_device->handle,
-			    (unsigned long long)sas_device->sas_address,
-			    sas_device->phy);
-			starget_printk(KERN_INFO, starget,
-			    "enclosure_logical_id(0x%016llx), slot(%d)\n",
-			   (unsigned long long)sas_device->enclosure_logical_id,
-			    sas_device->slot);
-		}
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	}
-}
-
-/**
- * _scsih_abort - eh threads main abort routine
- * @scmd: pointer to scsi command object
- *
- * Returns SUCCESS if command aborted else FAILED
- */
-static int
-_scsih_abort(struct scsi_cmnd *scmd)
-{
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(scmd->device->host);
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	u16 smid;
-	u16 handle;
-	int r;
-
-	sdev_printk(KERN_INFO, scmd->device, "attempting task abort! "
-	    "scmd(%p)\n", scmd);
-	_scsih_tm_display_info(ioc, scmd);
-
-	sas_device_priv_data = scmd->device->hostdata;
-	if (!sas_device_priv_data || !sas_device_priv_data->sas_target) {
-		sdev_printk(KERN_INFO, scmd->device, "device been deleted! "
-		    "scmd(%p)\n", scmd);
-		scmd->result = DID_NO_CONNECT << 16;
-		scmd->scsi_done(scmd);
-		r = SUCCESS;
-		goto out;
-	}
-
-	/* search for the command */
-	smid = _scsih_scsi_lookup_find_by_scmd(ioc, scmd);
-	if (!smid) {
-		scmd->result = DID_RESET << 16;
-		r = SUCCESS;
-		goto out;
-	}
-
-	/* for hidden raid components and volumes this is not supported */
-	if (sas_device_priv_data->sas_target->flags &
-	    MPT_TARGET_FLAGS_RAID_COMPONENT ||
-	    sas_device_priv_data->sas_target->flags & MPT_TARGET_FLAGS_VOLUME) {
-		scmd->result = DID_RESET << 16;
-		r = FAILED;
-		goto out;
-	}
-
-	mpt2sas_halt_firmware(ioc);
-
-	handle = sas_device_priv_data->sas_target->handle;
-	r = mpt2sas_scsih_issue_tm(ioc, handle, scmd->device->channel,
-	    scmd->device->id, scmd->device->lun,
-	    MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK, smid, 30, TM_MUTEX_ON);
-
- out:
-	sdev_printk(KERN_INFO, scmd->device, "task abort: %s scmd(%p)\n",
-	    ((r == SUCCESS) ? "SUCCESS" : "FAILED"), scmd);
-	return r;
-}
-
-/**
- * _scsih_dev_reset - eh threads main device reset routine
- * @scmd: pointer to scsi command object
- *
- * Returns SUCCESS if command aborted else FAILED
- */
-static int
-_scsih_dev_reset(struct scsi_cmnd *scmd)
-{
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(scmd->device->host);
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	struct _sas_device *sas_device;
-	unsigned long flags;
-	u16	handle;
-	int r;
-
-	struct scsi_target *starget = scmd->device->sdev_target;
-
-	starget_printk(KERN_INFO, starget, "attempting device reset! "
-	    "scmd(%p)\n", scmd);
-	_scsih_tm_display_info(ioc, scmd);
-
-	sas_device_priv_data = scmd->device->hostdata;
-	if (!sas_device_priv_data || !sas_device_priv_data->sas_target) {
-		starget_printk(KERN_INFO, starget, "device been deleted! "
-		    "scmd(%p)\n", scmd);
-		scmd->result = DID_NO_CONNECT << 16;
-		scmd->scsi_done(scmd);
-		r = SUCCESS;
-		goto out;
-	}
-
-	/* for hidden raid components obtain the volume_handle */
-	handle = 0;
-	if (sas_device_priv_data->sas_target->flags &
-	    MPT_TARGET_FLAGS_RAID_COMPONENT) {
-		spin_lock_irqsave(&ioc->sas_device_lock, flags);
-		sas_device = _scsih_sas_device_find_by_handle(ioc,
-		   sas_device_priv_data->sas_target->handle);
-		if (sas_device)
-			handle = sas_device->volume_handle;
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	} else
-		handle = sas_device_priv_data->sas_target->handle;
-
-	if (!handle) {
-		scmd->result = DID_RESET << 16;
-		r = FAILED;
-		goto out;
-	}
-
-	r = mpt2sas_scsih_issue_tm(ioc, handle, scmd->device->channel,
-	    scmd->device->id, scmd->device->lun,
-	    MPI2_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET, 0, 30, TM_MUTEX_ON);
-
- out:
-	sdev_printk(KERN_INFO, scmd->device, "device reset: %s scmd(%p)\n",
-	    ((r == SUCCESS) ? "SUCCESS" : "FAILED"), scmd);
-	return r;
-}
-
-/**
- * _scsih_target_reset - eh threads main target reset routine
- * @scmd: pointer to scsi command object
- *
- * Returns SUCCESS if command aborted else FAILED
- */
-static int
-_scsih_target_reset(struct scsi_cmnd *scmd)
-{
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(scmd->device->host);
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	struct _sas_device *sas_device;
-	unsigned long flags;
-	u16	handle;
-	int r;
-	struct scsi_target *starget = scmd->device->sdev_target;
-
-	starget_printk(KERN_INFO, starget, "attempting target reset! "
-	    "scmd(%p)\n", scmd);
-	_scsih_tm_display_info(ioc, scmd);
-
-	sas_device_priv_data = scmd->device->hostdata;
-	if (!sas_device_priv_data || !sas_device_priv_data->sas_target) {
-		starget_printk(KERN_INFO, starget, "target been deleted! "
-		    "scmd(%p)\n", scmd);
-		scmd->result = DID_NO_CONNECT << 16;
-		scmd->scsi_done(scmd);
-		r = SUCCESS;
-		goto out;
-	}
-
-	/* for hidden raid components obtain the volume_handle */
-	handle = 0;
-	if (sas_device_priv_data->sas_target->flags &
-	    MPT_TARGET_FLAGS_RAID_COMPONENT) {
-		spin_lock_irqsave(&ioc->sas_device_lock, flags);
-		sas_device = _scsih_sas_device_find_by_handle(ioc,
-		   sas_device_priv_data->sas_target->handle);
-		if (sas_device)
-			handle = sas_device->volume_handle;
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	} else
-		handle = sas_device_priv_data->sas_target->handle;
-
-	if (!handle) {
-		scmd->result = DID_RESET << 16;
-		r = FAILED;
-		goto out;
-	}
-
-	r = mpt2sas_scsih_issue_tm(ioc, handle, scmd->device->channel,
-	    scmd->device->id, 0, MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET, 0,
-	    30, TM_MUTEX_ON);
-
- out:
-	starget_printk(KERN_INFO, starget, "target reset: %s scmd(%p)\n",
-	    ((r == SUCCESS) ? "SUCCESS" : "FAILED"), scmd);
-	return r;
-}
-
-/**
- * _scsih_host_reset - eh threads main host reset routine
- * @scmd: pointer to scsi command object
- *
- * Returns SUCCESS if command aborted else FAILED
- */
-static int
-_scsih_host_reset(struct scsi_cmnd *scmd)
-{
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(scmd->device->host);
-	int r, retval;
-
-	printk(MPT2SAS_INFO_FMT "attempting host reset! scmd(%p)\n",
-	    ioc->name, scmd);
-	scsi_print_command(scmd);
-
-	if (ioc->is_driver_loading) {
-		printk(MPT2SAS_INFO_FMT "Blocking the host reset\n",
-							  ioc->name);
-		r = FAILED;
-		goto out;
-	}
-
-	retval = mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-	    FORCE_BIG_HAMMER);
-	r = (retval < 0) ? FAILED : SUCCESS;
-
- out:
-	printk(MPT2SAS_INFO_FMT "host reset: %s scmd(%p)\n",
-	    ioc->name, ((r == SUCCESS) ? "SUCCESS" : "FAILED"), scmd);
-
-	return r;
-}
-
-/**
- * _scsih_fw_event_add - insert and queue up fw_event
- * @ioc: per adapter object
- * @fw_event: object describing the event
- * Context: This function will acquire ioc->fw_event_lock.
- *
- * This adds the firmware event object into link list, then queues it up to
- * be processed from user context.
- *
- * Return nothing.
- */
-static void
-_scsih_fw_event_add(struct MPT2SAS_ADAPTER *ioc, struct fw_event_work *fw_event)
-{
-	unsigned long flags;
-
-	if (ioc->firmware_event_thread == NULL)
-		return;
-
-	spin_lock_irqsave(&ioc->fw_event_lock, flags);
-	fw_event_work_get(fw_event);
-	list_add_tail(&fw_event->list, &ioc->fw_event_list);
-	INIT_DELAYED_WORK(&fw_event->delayed_work, _firmware_event_work);
-	fw_event_work_get(fw_event);
-	queue_delayed_work(ioc->firmware_event_thread,
-	    &fw_event->delayed_work, 0);
-	spin_unlock_irqrestore(&ioc->fw_event_lock, flags);
-}
-
-/**
- * _scsih_fw_event_del_from_list - delete fw_event from the list
- * @ioc: per adapter object
- * @fw_event: object describing the event
- * Context: This function will acquire ioc->fw_event_lock.
- *
- * If the fw_event is on the fw_event_list, remove it and do a put.
- *
- * Return nothing.
- */
-static void
-_scsih_fw_event_del_from_list(struct MPT2SAS_ADAPTER *ioc, struct fw_event_work
-    *fw_event)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&ioc->fw_event_lock, flags);
-	if (!list_empty(&fw_event->list)) {
-		list_del_init(&fw_event->list);
-		fw_event_work_put(fw_event);
-	}
-	spin_unlock_irqrestore(&ioc->fw_event_lock, flags);
-}
-
-/**
- * _scsih_error_recovery_delete_devices - remove devices not responding
- * @ioc: per adapter object
- *
- * Return nothing.
- */
-static void
-_scsih_error_recovery_delete_devices(struct MPT2SAS_ADAPTER *ioc)
-{
-	struct fw_event_work *fw_event;
-
-	if (ioc->is_driver_loading)
-		return;
-
-	fw_event = alloc_fw_event_work(0);
-	if (!fw_event)
-		return;
-
-	fw_event->event = MPT2SAS_REMOVE_UNRESPONDING_DEVICES;
-	fw_event->ioc = ioc;
-	_scsih_fw_event_add(ioc, fw_event);
-	fw_event_work_put(fw_event);
-}
-
-/**
- * mpt2sas_port_enable_complete - port enable completed (fake event)
- * @ioc: per adapter object
- *
- * Return nothing.
- */
-void
-mpt2sas_port_enable_complete(struct MPT2SAS_ADAPTER *ioc)
-{
-	struct fw_event_work *fw_event;
-
-	fw_event = alloc_fw_event_work(0);
-	if (!fw_event)
-		return;
-	fw_event->event = MPT2SAS_PORT_ENABLE_COMPLETE;
-	fw_event->ioc = ioc;
-	_scsih_fw_event_add(ioc, fw_event);
-	fw_event_work_put(fw_event);
-}
-
-static struct fw_event_work *dequeue_next_fw_event(struct MPT2SAS_ADAPTER *ioc)
-{
-	unsigned long flags;
-	struct fw_event_work *fw_event = NULL;
-
-	spin_lock_irqsave(&ioc->fw_event_lock, flags);
-	if (!list_empty(&ioc->fw_event_list)) {
-		fw_event = list_first_entry(&ioc->fw_event_list,
-				struct fw_event_work, list);
-		list_del_init(&fw_event->list);
-	}
-	spin_unlock_irqrestore(&ioc->fw_event_lock, flags);
-
-	return fw_event;
-}
-
-/**
- * _scsih_fw_event_cleanup_queue - cleanup event queue
- * @ioc: per adapter object
- *
- * Walk the firmware event queue, either killing timers, or waiting
- * for outstanding events to complete
- *
- * Return nothing.
- */
-static void
-_scsih_fw_event_cleanup_queue(struct MPT2SAS_ADAPTER *ioc)
-{
-	struct fw_event_work *fw_event;
-
-	if (list_empty(&ioc->fw_event_list) ||
-	     !ioc->firmware_event_thread || in_interrupt())
-		return;
-
-	while ((fw_event = dequeue_next_fw_event(ioc))) {
-		/*
-		 * Wait on the fw_event to complete. If this returns 1, then
-		 * the event was never executed, and we need a put for the
-		 * reference the delayed_work had on the fw_event.
-		 *
-		 * If it did execute, we wait for it to finish, and the put will
-		 * happen from _firmware_event_work()
-		 */
-		if (cancel_delayed_work_sync(&fw_event->delayed_work))
-			fw_event_work_put(fw_event);
-
-		fw_event_work_put(fw_event);
-	}
-}
-
-/**
- * _scsih_ublock_io_all_device - unblock every device
- * @ioc: per adapter object
- *
- * change the device state from block to running
- */
-static void
-_scsih_ublock_io_all_device(struct MPT2SAS_ADAPTER *ioc)
-{
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	struct scsi_device *sdev;
-
-	shost_for_each_device(sdev, ioc->shost) {
-		sas_device_priv_data = sdev->hostdata;
-		if (!sas_device_priv_data)
-			continue;
-		if (!sas_device_priv_data->block)
-			continue;
-		sas_device_priv_data->block = 0;
-		dewtprintk(ioc, sdev_printk(KERN_INFO, sdev, "device_running, "
-		    "handle(0x%04x)\n",
-		    sas_device_priv_data->sas_target->handle));
-		scsi_internal_device_unblock(sdev, SDEV_RUNNING);
-	}
-}
-/**
- * _scsih_ublock_io_device - set the device state to SDEV_RUNNING
- * @ioc: per adapter object
- * @handle: device handle
- *
- * During device pull we need to appropiately set the sdev state.
- */
-static void
-_scsih_ublock_io_device(struct MPT2SAS_ADAPTER *ioc, u64 sas_address)
-{
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	struct scsi_device *sdev;
-
-	shost_for_each_device(sdev, ioc->shost) {
-		sas_device_priv_data = sdev->hostdata;
-		if (!sas_device_priv_data)
-			continue;
-		if (!sas_device_priv_data->block)
-			continue;
-		if (sas_device_priv_data->sas_target->sas_address ==
-								sas_address) {
-			dewtprintk(ioc, sdev_printk(KERN_INFO, sdev,
-			    MPT2SAS_INFO_FMT "SDEV_RUNNING: "
-			    "sas address(0x%016llx)\n", ioc->name,
-				(unsigned long long)sas_address));
-			sas_device_priv_data->block = 0;
-			scsi_internal_device_unblock(sdev, SDEV_RUNNING);
-		}
-	}
-}
-
-/**
- * _scsih_block_io_all_device - set the device state to SDEV_BLOCK
- * @ioc: per adapter object
- * @handle: device handle
- *
- * During device pull we need to appropiately set the sdev state.
- */
-static void
-_scsih_block_io_all_device(struct MPT2SAS_ADAPTER *ioc)
-{
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	struct scsi_device *sdev;
-
-	shost_for_each_device(sdev, ioc->shost) {
-		sas_device_priv_data = sdev->hostdata;
-		if (!sas_device_priv_data)
-			continue;
-		if (sas_device_priv_data->block)
-			continue;
-		sas_device_priv_data->block = 1;
-		dewtprintk(ioc, sdev_printk(KERN_INFO, sdev, "device_blocked, "
-		    "handle(0x%04x)\n",
-		    sas_device_priv_data->sas_target->handle));
-		scsi_internal_device_block(sdev);
-	}
-}
-
-
-/**
- * _scsih_block_io_device - set the device state to SDEV_BLOCK
- * @ioc: per adapter object
- * @handle: device handle
- *
- * During device pull we need to appropiately set the sdev state.
- */
-static void
-_scsih_block_io_device(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	struct scsi_device *sdev;
-
-	shost_for_each_device(sdev, ioc->shost) {
-		sas_device_priv_data = sdev->hostdata;
-		if (!sas_device_priv_data)
-			continue;
-		if (sas_device_priv_data->block)
-			continue;
-		if (sas_device_priv_data->sas_target->handle == handle) {
-			dewtprintk(ioc, sdev_printk(KERN_INFO, sdev,
-			    MPT2SAS_INFO_FMT "SDEV_BLOCK: "
-			    "handle(0x%04x)\n", ioc->name, handle));
-			sas_device_priv_data->block = 1;
-			scsi_internal_device_block(sdev);
-		}
-	}
-}
-
-/**
- * _scsih_block_io_to_children_attached_to_ex
- * @ioc: per adapter object
- * @sas_expander: the sas_device object
- *
- * This routine set sdev state to SDEV_BLOCK for all devices
- * attached to this expander. This function called when expander is
- * pulled.
- */
-static void
-_scsih_block_io_to_children_attached_to_ex(struct MPT2SAS_ADAPTER *ioc,
-    struct _sas_node *sas_expander)
-{
-	struct _sas_port *mpt2sas_port;
-	struct _sas_device *sas_device;
-	struct _sas_node *expander_sibling;
-	unsigned long flags;
-
-	if (!sas_expander)
-		return;
-
-	list_for_each_entry(mpt2sas_port,
-	   &sas_expander->sas_port_list, port_list) {
-		if (mpt2sas_port->remote_identify.device_type ==
-		    SAS_END_DEVICE) {
-			spin_lock_irqsave(&ioc->sas_device_lock, flags);
-			sas_device =
-			    mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-			   mpt2sas_port->remote_identify.sas_address);
-			if (sas_device)
-				set_bit(sas_device->handle,
-				    ioc->blocking_handles);
-			spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-		}
-	}
-
-	list_for_each_entry(mpt2sas_port,
-	   &sas_expander->sas_port_list, port_list) {
-
-		if (mpt2sas_port->remote_identify.device_type ==
-		    SAS_EDGE_EXPANDER_DEVICE ||
-		    mpt2sas_port->remote_identify.device_type ==
-		    SAS_FANOUT_EXPANDER_DEVICE) {
-			expander_sibling =
-			    mpt2sas_scsih_expander_find_by_sas_address(
-			    ioc, mpt2sas_port->remote_identify.sas_address);
-			_scsih_block_io_to_children_attached_to_ex(ioc,
-			    expander_sibling);
-		}
-	}
-}
-
-/**
- * _scsih_block_io_to_children_attached_directly
- * @ioc: per adapter object
- * @event_data: topology change event data
- *
- * This routine set sdev state to SDEV_BLOCK for all devices
- * direct attached during device pull.
- */
-static void
-_scsih_block_io_to_children_attached_directly(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventDataSasTopologyChangeList_t *event_data)
-{
-	int i;
-	u16 handle;
-	u16 reason_code;
-	u8 phy_number;
-
-	for (i = 0; i < event_data->NumEntries; i++) {
-		handle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);
-		if (!handle)
-			continue;
-		phy_number = event_data->StartPhyNum + i;
-		reason_code = event_data->PHY[i].PhyStatus &
-		    MPI2_EVENT_SAS_TOPO_RC_MASK;
-		if (reason_code == MPI2_EVENT_SAS_TOPO_RC_DELAY_NOT_RESPONDING)
-			_scsih_block_io_device(ioc, handle);
-	}
-}
-
-/**
- * _scsih_tm_tr_send - send task management request
- * @ioc: per adapter object
- * @handle: device handle
- * Context: interrupt time.
- *
- * This code is to initiate the device removal handshake protocol
- * with controller firmware.  This function will issue target reset
- * using high priority request queue.  It will send a sas iounit
- * control request (MPI2_SAS_OP_REMOVE_DEVICE) from this completion.
- *
- * This is designed to send muliple task management request at the same
- * time to the fifo. If the fifo is full, we will append the request,
- * and process it in a future completion.
- */
-static void
-_scsih_tm_tr_send(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	Mpi2SCSITaskManagementRequest_t *mpi_request;
-	u16 smid;
-	struct _sas_device *sas_device;
-	struct MPT2SAS_TARGET *sas_target_priv_data = NULL;
-	u64 sas_address = 0;
-	unsigned long flags;
-	struct _tr_list *delayed_tr;
-	u32 ioc_state;
-
-	if (ioc->remove_host) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host has been "
-		    "removed: handle(0x%04x)\n", __func__, ioc->name, handle));
-		return;
-	} else if (ioc->pci_error_recovery) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host in pci "
-		    "error recovery: handle(0x%04x)\n", __func__, ioc->name,
-		    handle));
-		return;
-	}
-	ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-	if (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host is not "
-		   "operational: handle(0x%04x)\n", __func__, ioc->name,
-		   handle));
-		return;
-	}
-
-	/* if PD, then return */
-	if (test_bit(handle, ioc->pd_handles))
-		return;
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_device = _scsih_sas_device_find_by_handle(ioc, handle);
-	if (sas_device && sas_device->starget &&
-	     sas_device->starget->hostdata) {
-		sas_target_priv_data = sas_device->starget->hostdata;
-		sas_target_priv_data->deleted = 1;
-		sas_address = sas_device->sas_address;
-	}
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-
-	if (sas_target_priv_data) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "setting delete flag: "
-		"handle(0x%04x), sas_addr(0x%016llx)\n", ioc->name, handle,
-			(unsigned long long)sas_address));
-		_scsih_ublock_io_device(ioc, sas_address);
-		sas_target_priv_data->handle = MPT2SAS_INVALID_DEVICE_HANDLE;
-	}
-
-	smid = mpt2sas_base_get_smid_hpr(ioc, ioc->tm_tr_cb_idx);
-	if (!smid) {
-		delayed_tr = kzalloc(sizeof(*delayed_tr), GFP_ATOMIC);
-		if (!delayed_tr)
-			return;
-		INIT_LIST_HEAD(&delayed_tr->list);
-		delayed_tr->handle = handle;
-		list_add_tail(&delayed_tr->list, &ioc->delayed_tr_list);
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "DELAYED:tr:handle(0x%04x), (open)\n",
-		    ioc->name, handle));
-		return;
-	}
-
-	dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "tr_send:handle(0x%04x), "
-	    "(open), smid(%d), cb(%d)\n", ioc->name, handle, smid,
-	    ioc->tm_tr_cb_idx));
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	memset(mpi_request, 0, sizeof(Mpi2SCSITaskManagementRequest_t));
-	mpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;
-	mpi_request->DevHandle = cpu_to_le16(handle);
-	mpi_request->TaskType = MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET;
-	mpt2sas_base_put_smid_hi_priority(ioc, smid);
-}
-
-
-
-/**
- * _scsih_sas_control_complete - completion routine
- * @ioc: per adapter object
- * @smid: system request message index
- * @msix_index: MSIX table index supplied by the OS
- * @reply: reply message frame(lower 32bit addr)
- * Context: interrupt time.
- *
- * This is the sas iounit control completion routine.
- * This code is part of the code to initiate the device removal
- * handshake protocol with controller firmware.
- *
- * Return 1 meaning mf should be freed from _base_interrupt
- *        0 means the mf is freed from this function.
- */
-static u8
-_scsih_sas_control_complete(struct MPT2SAS_ADAPTER *ioc, u16 smid,
-    u8 msix_index, u32 reply)
-{
-	Mpi2SasIoUnitControlReply_t *mpi_reply =
-	    mpt2sas_base_get_reply_virt_addr(ioc, reply);
-	if (likely(mpi_reply)) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT
-		"sc_complete:handle(0x%04x), (open) "
-		"smid(%d), ioc_status(0x%04x), loginfo(0x%08x)\n",
-		ioc->name, le16_to_cpu(mpi_reply->DevHandle), smid,
-		le16_to_cpu(mpi_reply->IOCStatus),
-		le32_to_cpu(mpi_reply->IOCLogInfo)));
-	} else {
-		printk(MPT2SAS_ERR_FMT "mpi_reply not valid at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-	}
-	return 1;
-}
-
-/**
- * _scsih_tm_tr_volume_send - send target reset request for volumes
- * @ioc: per adapter object
- * @handle: device handle
- * Context: interrupt time.
- *
- * This is designed to send muliple task management request at the same
- * time to the fifo. If the fifo is full, we will append the request,
- * and process it in a future completion.
- */
-static void
-_scsih_tm_tr_volume_send(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	Mpi2SCSITaskManagementRequest_t *mpi_request;
-	u16 smid;
-	struct _tr_list *delayed_tr;
-
-	if (ioc->shost_recovery || ioc->remove_host ||
-	    ioc->pci_error_recovery) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host reset in "
-		   "progress!\n", __func__, ioc->name));
-		return;
-	}
-
-	smid = mpt2sas_base_get_smid_hpr(ioc, ioc->tm_tr_volume_cb_idx);
-	if (!smid) {
-		delayed_tr = kzalloc(sizeof(*delayed_tr), GFP_ATOMIC);
-		if (!delayed_tr)
-			return;
-		INIT_LIST_HEAD(&delayed_tr->list);
-		delayed_tr->handle = handle;
-		list_add_tail(&delayed_tr->list, &ioc->delayed_tr_volume_list);
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "DELAYED:tr:handle(0x%04x), (open)\n",
-		    ioc->name, handle));
-		return;
-	}
-
-	dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "tr_send:handle(0x%04x), "
-	    "(open), smid(%d), cb(%d)\n", ioc->name, handle, smid,
-	    ioc->tm_tr_volume_cb_idx));
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	memset(mpi_request, 0, sizeof(Mpi2SCSITaskManagementRequest_t));
-	mpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;
-	mpi_request->DevHandle = cpu_to_le16(handle);
-	mpi_request->TaskType = MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET;
-	mpt2sas_base_put_smid_hi_priority(ioc, smid);
-}
-
-/**
- * _scsih_tm_volume_tr_complete - target reset completion
- * @ioc: per adapter object
- * @smid: system request message index
- * @msix_index: MSIX table index supplied by the OS
- * @reply: reply message frame(lower 32bit addr)
- * Context: interrupt time.
- *
- * Return 1 meaning mf should be freed from _base_interrupt
- *        0 means the mf is freed from this function.
- */
-static u8
-_scsih_tm_volume_tr_complete(struct MPT2SAS_ADAPTER *ioc, u16 smid,
-    u8 msix_index, u32 reply)
-{
-	u16 handle;
-	Mpi2SCSITaskManagementRequest_t *mpi_request_tm;
-	Mpi2SCSITaskManagementReply_t *mpi_reply =
-	    mpt2sas_base_get_reply_virt_addr(ioc, reply);
-
-	if (ioc->shost_recovery || ioc->remove_host ||
-	    ioc->pci_error_recovery) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host reset in "
-		   "progress!\n", __func__, ioc->name));
-		return 1;
-	}
-	if (unlikely(!mpi_reply)) {
-		printk(MPT2SAS_ERR_FMT "mpi_reply not valid at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return 1;
-	}
-	mpi_request_tm = mpt2sas_base_get_msg_frame(ioc, smid);
-	handle = le16_to_cpu(mpi_request_tm->DevHandle);
-	if (handle != le16_to_cpu(mpi_reply->DevHandle)) {
-		dewtprintk(ioc, printk("spurious interrupt: "
-		    "handle(0x%04x:0x%04x), smid(%d)!!!\n", handle,
-		    le16_to_cpu(mpi_reply->DevHandle), smid));
-		return 0;
-	}
-
-	dewtprintk(ioc, printk(MPT2SAS_INFO_FMT
-	    "tr_complete:handle(0x%04x), (open) smid(%d), ioc_status(0x%04x), "
-	    "loginfo(0x%08x), completed(%d)\n", ioc->name,
-	    handle, smid, le16_to_cpu(mpi_reply->IOCStatus),
-	    le32_to_cpu(mpi_reply->IOCLogInfo),
-	    le32_to_cpu(mpi_reply->TerminationCount)));
-
-	return _scsih_check_for_pending_tm(ioc, smid);
-}
-
-/**
- * _scsih_tm_tr_complete -
- * @ioc: per adapter object
- * @smid: system request message index
- * @msix_index: MSIX table index supplied by the OS
- * @reply: reply message frame(lower 32bit addr)
- * Context: interrupt time.
- *
- * This is the target reset completion routine.
- * This code is part of the code to initiate the device removal
- * handshake protocol with controller firmware.
- * It will send a sas iounit control request (MPI2_SAS_OP_REMOVE_DEVICE)
- *
- * Return 1 meaning mf should be freed from _base_interrupt
- *        0 means the mf is freed from this function.
- */
-static u8
-_scsih_tm_tr_complete(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
-    u32 reply)
-{
-	u16 handle;
-	Mpi2SCSITaskManagementRequest_t *mpi_request_tm;
-	Mpi2SCSITaskManagementReply_t *mpi_reply =
-	    mpt2sas_base_get_reply_virt_addr(ioc, reply);
-	Mpi2SasIoUnitControlRequest_t *mpi_request;
-	u16 smid_sas_ctrl;
-	u32 ioc_state;
-
-	if (ioc->remove_host) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host has been "
-		   "removed\n", __func__, ioc->name));
-		return 1;
-	} else if (ioc->pci_error_recovery) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host in pci "
-		    "error recovery\n", __func__, ioc->name));
-		return 1;
-	}
-	ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-	if (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host is not "
-		    "operational\n", __func__, ioc->name));
-		return 1;
-	}
-	if (unlikely(!mpi_reply)) {
-		printk(MPT2SAS_ERR_FMT "mpi_reply not valid at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return 1;
-	}
-	mpi_request_tm = mpt2sas_base_get_msg_frame(ioc, smid);
-	handle = le16_to_cpu(mpi_request_tm->DevHandle);
-	if (handle != le16_to_cpu(mpi_reply->DevHandle)) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "spurious interrupt: "
-		    "handle(0x%04x:0x%04x), smid(%d)!!!\n", ioc->name, handle,
-		    le16_to_cpu(mpi_reply->DevHandle), smid));
-		return 0;
-	}
-
-	dewtprintk(ioc, printk(MPT2SAS_INFO_FMT
-	    "tr_complete:handle(0x%04x), (open) smid(%d), ioc_status(0x%04x), "
-	    "loginfo(0x%08x), completed(%d)\n", ioc->name,
-	    handle, smid, le16_to_cpu(mpi_reply->IOCStatus),
-	    le32_to_cpu(mpi_reply->IOCLogInfo),
-	    le32_to_cpu(mpi_reply->TerminationCount)));
-
-	smid_sas_ctrl = mpt2sas_base_get_smid(ioc, ioc->tm_sas_control_cb_idx);
-	if (!smid_sas_ctrl) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		return 1;
-	}
-
-	dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "sc_send:handle(0x%04x), "
-	    "(open), smid(%d), cb(%d)\n", ioc->name, handle, smid_sas_ctrl,
-	    ioc->tm_sas_control_cb_idx));
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid_sas_ctrl);
-	memset(mpi_request, 0, sizeof(Mpi2SasIoUnitControlRequest_t));
-	mpi_request->Function = MPI2_FUNCTION_SAS_IO_UNIT_CONTROL;
-	mpi_request->Operation = MPI2_SAS_OP_REMOVE_DEVICE;
-	mpi_request->DevHandle = mpi_request_tm->DevHandle;
-	mpt2sas_base_put_smid_default(ioc, smid_sas_ctrl);
-
-	return _scsih_check_for_pending_tm(ioc, smid);
-}
-
-/**
- * _scsih_check_for_pending_tm - check for pending task management
- * @ioc: per adapter object
- * @smid: system request message index
- *
- * This will check delayed target reset list, and feed the
- * next reqeust.
- *
- * Return 1 meaning mf should be freed from _base_interrupt
- *        0 means the mf is freed from this function.
- */
-static u8
-_scsih_check_for_pending_tm(struct MPT2SAS_ADAPTER *ioc, u16 smid)
-{
-	struct _tr_list *delayed_tr;
-
-	if (!list_empty(&ioc->delayed_tr_volume_list)) {
-		delayed_tr = list_entry(ioc->delayed_tr_volume_list.next,
-		    struct _tr_list, list);
-		mpt2sas_base_free_smid(ioc, smid);
-		_scsih_tm_tr_volume_send(ioc, delayed_tr->handle);
-		list_del(&delayed_tr->list);
-		kfree(delayed_tr);
-		return 0;
-	}
-
-	if (!list_empty(&ioc->delayed_tr_list)) {
-		delayed_tr = list_entry(ioc->delayed_tr_list.next,
-		    struct _tr_list, list);
-		mpt2sas_base_free_smid(ioc, smid);
-		_scsih_tm_tr_send(ioc, delayed_tr->handle);
-		list_del(&delayed_tr->list);
-		kfree(delayed_tr);
-		return 0;
-	}
-
-	return 1;
-}
-
-/**
- * _scsih_check_topo_delete_events - sanity check on topo events
- * @ioc: per adapter object
- * @event_data: the event data payload
- *
- * This routine added to better handle cable breaker.
- *
- * This handles the case where driver receives multiple expander
- * add and delete events in a single shot.  When there is a delete event
- * the routine will void any pending add events waiting in the event queue.
- *
- * Return nothing.
- */
-static void
-_scsih_check_topo_delete_events(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventDataSasTopologyChangeList_t *event_data)
-{
-	struct fw_event_work *fw_event;
-	Mpi2EventDataSasTopologyChangeList_t *local_event_data;
-	u16 expander_handle;
-	struct _sas_node *sas_expander;
-	unsigned long flags;
-	int i, reason_code;
-	u16 handle;
-
-	for (i = 0 ; i < event_data->NumEntries; i++) {
-		handle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);
-		if (!handle)
-			continue;
-		reason_code = event_data->PHY[i].PhyStatus &
-		    MPI2_EVENT_SAS_TOPO_RC_MASK;
-		if (reason_code == MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING)
-			_scsih_tm_tr_send(ioc, handle);
-	}
-
-	expander_handle = le16_to_cpu(event_data->ExpanderDevHandle);
-	if (expander_handle < ioc->sas_hba.num_phys) {
-		_scsih_block_io_to_children_attached_directly(ioc, event_data);
-		return;
-	}
-	if (event_data->ExpStatus ==
-	    MPI2_EVENT_SAS_TOPO_ES_DELAY_NOT_RESPONDING) {
-		/* put expander attached devices into blocking state */
-		spin_lock_irqsave(&ioc->sas_node_lock, flags);
-		sas_expander = mpt2sas_scsih_expander_find_by_handle(ioc,
-		    expander_handle);
-		_scsih_block_io_to_children_attached_to_ex(ioc, sas_expander);
-		spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-		do {
-			handle = find_first_bit(ioc->blocking_handles,
-			    ioc->facts.MaxDevHandle);
-			if (handle < ioc->facts.MaxDevHandle)
-				_scsih_block_io_device(ioc, handle);
-		} while (test_and_clear_bit(handle, ioc->blocking_handles));
-	} else if (event_data->ExpStatus == MPI2_EVENT_SAS_TOPO_ES_RESPONDING)
-		_scsih_block_io_to_children_attached_directly(ioc, event_data);
-
-	if (event_data->ExpStatus != MPI2_EVENT_SAS_TOPO_ES_NOT_RESPONDING)
-		return;
-
-	/* mark ignore flag for pending events */
-	spin_lock_irqsave(&ioc->fw_event_lock, flags);
-	list_for_each_entry(fw_event, &ioc->fw_event_list, list) {
-		if (fw_event->event != MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST ||
-		    fw_event->ignore)
-			continue;
-		local_event_data = (Mpi2EventDataSasTopologyChangeList_t *)
-			fw_event->event_data;
-		if (local_event_data->ExpStatus ==
-		    MPI2_EVENT_SAS_TOPO_ES_ADDED ||
-		    local_event_data->ExpStatus ==
-		    MPI2_EVENT_SAS_TOPO_ES_RESPONDING) {
-			if (le16_to_cpu(local_event_data->ExpanderDevHandle) ==
-			    expander_handle) {
-				dewtprintk(ioc, printk(MPT2SAS_INFO_FMT
-				    "setting ignoring flag\n", ioc->name));
-				fw_event->ignore = 1;
-			}
-		}
-	}
-	spin_unlock_irqrestore(&ioc->fw_event_lock, flags);
-}
-
-/**
- * _scsih_set_volume_delete_flag - setting volume delete flag
- * @ioc: per adapter object
- * @handle: device handle
- *
- * This
- * Return nothing.
- */
-static void
-_scsih_set_volume_delete_flag(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	struct _raid_device *raid_device;
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-	unsigned long flags;
-
-	spin_lock_irqsave(&ioc->raid_device_lock, flags);
-	raid_device = _scsih_raid_device_find_by_handle(ioc, handle);
-	if (raid_device && raid_device->starget &&
-	    raid_device->starget->hostdata) {
-		sas_target_priv_data =
-		    raid_device->starget->hostdata;
-		sas_target_priv_data->deleted = 1;
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "setting delete flag: handle(0x%04x), "
-		    "wwid(0x%016llx)\n", ioc->name, handle,
-		    (unsigned long long) raid_device->wwid));
-	}
-	spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-}
-
-/**
- * _scsih_set_volume_handle_for_tr - set handle for target reset to volume
- * @handle: input handle
- * @a: handle for volume a
- * @b: handle for volume b
- *
- * IR firmware only supports two raid volumes.  The purpose of this
- * routine is to set the volume handle in either a or b. When the given
- * input handle is non-zero, or when a and b have not been set before.
- */
-static void
-_scsih_set_volume_handle_for_tr(u16 handle, u16 *a, u16 *b)
-{
-	if (!handle || handle == *a || handle == *b)
-		return;
-	if (!*a)
-		*a = handle;
-	else if (!*b)
-		*b = handle;
-}
-
-/**
- * _scsih_check_ir_config_unhide_events - check for UNHIDE events
- * @ioc: per adapter object
- * @event_data: the event data payload
- * Context: interrupt time.
- *
- * This routine will send target reset to volume, followed by target
- * resets to the PDs. This is called when a PD has been removed, or
- * volume has been deleted or removed. When the target reset is sent
- * to volume, the PD target resets need to be queued to start upon
- * completion of the volume target reset.
- *
- * Return nothing.
- */
-static void
-_scsih_check_ir_config_unhide_events(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventDataIrConfigChangeList_t *event_data)
-{
-	Mpi2EventIrConfigElement_t *element;
-	int i;
-	u16 handle, volume_handle, a, b;
-	struct _tr_list *delayed_tr;
-
-	a = 0;
-	b = 0;
-
-	if (ioc->is_warpdrive)
-		return;
-
-	/* Volume Resets for Deleted or Removed */
-	element = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];
-	for (i = 0; i < event_data->NumElements; i++, element++) {
-		if (element->ReasonCode ==
-		    MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED ||
-		    element->ReasonCode ==
-		    MPI2_EVENT_IR_CHANGE_RC_REMOVED) {
-			volume_handle = le16_to_cpu(element->VolDevHandle);
-			_scsih_set_volume_delete_flag(ioc, volume_handle);
-			_scsih_set_volume_handle_for_tr(volume_handle, &a, &b);
-		}
-	}
-
-	/* Volume Resets for UNHIDE events */
-	element = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];
-	for (i = 0; i < event_data->NumElements; i++, element++) {
-		if (le32_to_cpu(event_data->Flags) &
-		    MPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG)
-			continue;
-		if (element->ReasonCode == MPI2_EVENT_IR_CHANGE_RC_UNHIDE) {
-			volume_handle = le16_to_cpu(element->VolDevHandle);
-			_scsih_set_volume_handle_for_tr(volume_handle, &a, &b);
-		}
-	}
-
-	if (a)
-		_scsih_tm_tr_volume_send(ioc, a);
-	if (b)
-		_scsih_tm_tr_volume_send(ioc, b);
-
-	/* PD target resets */
-	element = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];
-	for (i = 0; i < event_data->NumElements; i++, element++) {
-		if (element->ReasonCode != MPI2_EVENT_IR_CHANGE_RC_UNHIDE)
-			continue;
-		handle = le16_to_cpu(element->PhysDiskDevHandle);
-		volume_handle = le16_to_cpu(element->VolDevHandle);
-		clear_bit(handle, ioc->pd_handles);
-		if (!volume_handle)
-			_scsih_tm_tr_send(ioc, handle);
-		else if (volume_handle == a || volume_handle == b) {
-			delayed_tr = kzalloc(sizeof(*delayed_tr), GFP_ATOMIC);
-			BUG_ON(!delayed_tr);
-			INIT_LIST_HEAD(&delayed_tr->list);
-			delayed_tr->handle = handle;
-			list_add_tail(&delayed_tr->list, &ioc->delayed_tr_list);
-			dewtprintk(ioc, printk(MPT2SAS_INFO_FMT
-			    "DELAYED:tr:handle(0x%04x), (open)\n", ioc->name,
-			    handle));
-		} else
-			_scsih_tm_tr_send(ioc, handle);
-	}
-}
-
-
-/**
- * _scsih_check_volume_delete_events - set delete flag for volumes
- * @ioc: per adapter object
- * @event_data: the event data payload
- * Context: interrupt time.
- *
- * This will handle the case when the cable connected to entire volume is
- * pulled. We will take care of setting the deleted flag so normal IO will
- * not be sent.
- *
- * Return nothing.
- */
-static void
-_scsih_check_volume_delete_events(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventDataIrVolume_t *event_data)
-{
-	u32 state;
-
-	if (event_data->ReasonCode != MPI2_EVENT_IR_VOLUME_RC_STATE_CHANGED)
-		return;
-	state = le32_to_cpu(event_data->NewValue);
-	if (state == MPI2_RAID_VOL_STATE_MISSING || state ==
-	    MPI2_RAID_VOL_STATE_FAILED)
-		_scsih_set_volume_delete_flag(ioc,
-		    le16_to_cpu(event_data->VolDevHandle));
-}
-
-/**
- * _scsih_temp_threshold_events - display temperature threshold exceeded events
- * @ioc: per adapter object
- * @event_data: the temp threshold event data
- * Context: interrupt time.
- *
- * Return nothing.
- */
-static void
-_scsih_temp_threshold_events(struct MPT2SAS_ADAPTER *ioc,
-	Mpi2EventDataTemperature_t *event_data)
-{
-	if (ioc->temp_sensors_count >= event_data->SensorNum) {
-		printk(MPT2SAS_ERR_FMT "Temperature Threshold flags %s%s%s%s"
-		  " exceeded for Sensor: %d !!!\n", ioc->name,
-		  ((le16_to_cpu(event_data->Status) & 0x1) == 1) ? "0 " : " ",
-		  ((le16_to_cpu(event_data->Status) & 0x2) == 2) ? "1 " : " ",
-		  ((le16_to_cpu(event_data->Status) & 0x4) == 4) ? "2 " : " ",
-		  ((le16_to_cpu(event_data->Status) & 0x8) == 8) ? "3 " : " ",
-		  event_data->SensorNum);
-		printk(MPT2SAS_ERR_FMT "Current Temp In Celsius: %d\n",
-			ioc->name, event_data->CurrentTemperature);
-	}
-}
-
-/**
- * _scsih_flush_running_cmds - completing outstanding commands.
- * @ioc: per adapter object
- *
- * The flushing out of all pending scmd commands following host reset,
- * where all IO is dropped to the floor.
- *
- * Return nothing.
- */
-static void
-_scsih_flush_running_cmds(struct MPT2SAS_ADAPTER *ioc)
-{
-	struct scsi_cmnd *scmd;
-	u16 smid;
-	u16 count = 0;
-
-	for (smid = 1; smid <= ioc->scsiio_depth; smid++) {
-		scmd = _scsih_scsi_lookup_get_clear(ioc, smid);
-		if (!scmd)
-			continue;
-		count++;
-		mpt2sas_base_free_smid(ioc, smid);
-		scsi_dma_unmap(scmd);
-		if (ioc->pci_error_recovery)
-			scmd->result = DID_NO_CONNECT << 16;
-		else
-			scmd->result = DID_RESET << 16;
-		scmd->scsi_done(scmd);
-	}
-	dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "completing %d cmds\n",
-	    ioc->name, count));
-}
-
-/**
- * _scsih_setup_eedp - setup MPI request for EEDP transfer
- * @scmd: pointer to scsi command object
- * @mpi_request: pointer to the SCSI_IO reqest message frame
- *
- * Supporting protection 1 and 3.
- *
- * Returns nothing
- */
-static void
-_scsih_setup_eedp(struct scsi_cmnd *scmd, Mpi2SCSIIORequest_t *mpi_request)
-{
-	u16 eedp_flags;
-	unsigned char prot_op = scsi_get_prot_op(scmd);
-	unsigned char prot_type = scsi_get_prot_type(scmd);
-
-	if (prot_type == SCSI_PROT_DIF_TYPE0 || prot_op == SCSI_PROT_NORMAL)
-		return;
-
-	if (prot_op ==  SCSI_PROT_READ_STRIP)
-		eedp_flags = MPI2_SCSIIO_EEDPFLAGS_CHECK_REMOVE_OP;
-	else if (prot_op ==  SCSI_PROT_WRITE_INSERT)
-		eedp_flags = MPI2_SCSIIO_EEDPFLAGS_INSERT_OP;
-	else
-		return;
-
-	switch (prot_type) {
-	case SCSI_PROT_DIF_TYPE1:
-	case SCSI_PROT_DIF_TYPE2:
-
-		/*
-		* enable ref/guard checking
-		* auto increment ref tag
-		*/
-		eedp_flags |= MPI2_SCSIIO_EEDPFLAGS_INC_PRI_REFTAG |
-		    MPI2_SCSIIO_EEDPFLAGS_CHECK_REFTAG |
-		    MPI2_SCSIIO_EEDPFLAGS_CHECK_GUARD;
-		mpi_request->CDB.EEDP32.PrimaryReferenceTag =
-		    cpu_to_be32(scsi_get_lba(scmd));
-		break;
-
-	case SCSI_PROT_DIF_TYPE3:
-
-		/*
-		* enable guard checking
-		*/
-		eedp_flags |= MPI2_SCSIIO_EEDPFLAGS_CHECK_GUARD;
-		break;
-	}
-	mpi_request->EEDPBlockSize = cpu_to_le32(scmd->device->sector_size);
-	mpi_request->EEDPFlags = cpu_to_le16(eedp_flags);
-}
-
-/**
- * _scsih_eedp_error_handling - return sense code for EEDP errors
- * @scmd: pointer to scsi command object
- * @ioc_status: ioc status
- *
- * Returns nothing
- */
-static void
-_scsih_eedp_error_handling(struct scsi_cmnd *scmd, u16 ioc_status)
-{
-	u8 ascq;
-
-	switch (ioc_status) {
-	case MPI2_IOCSTATUS_EEDP_GUARD_ERROR:
-		ascq = 0x01;
-		break;
-	case MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:
-		ascq = 0x02;
-		break;
-	case MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:
-		ascq = 0x03;
-		break;
-	default:
-		ascq = 0x00;
-		break;
-	}
-
-	scsi_build_sense_buffer(0, scmd->sense_buffer, ILLEGAL_REQUEST, 0x10, ascq);
-	scmd->result = DRIVER_SENSE << 24 | (DID_ABORT << 16) |
-	    SAM_STAT_CHECK_CONDITION;
-}
-
-/**
- * _scsih_scsi_direct_io_get - returns direct io flag
- * @ioc: per adapter object
- * @smid: system request message index
- *
- * Returns the smid stored scmd pointer.
- */
-static inline u8
-_scsih_scsi_direct_io_get(struct MPT2SAS_ADAPTER *ioc, u16 smid)
-{
-	return ioc->scsi_lookup[smid - 1].direct_io;
-}
-
-/**
- * _scsih_scsi_direct_io_set - sets direct io flag
- * @ioc: per adapter object
- * @smid: system request message index
- * @direct_io: Zero or non-zero value to set in the direct_io flag
- *
- * Returns Nothing.
- */
-static inline void
-_scsih_scsi_direct_io_set(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 direct_io)
-{
-	ioc->scsi_lookup[smid - 1].direct_io = direct_io;
-}
-
-
-/**
- * _scsih_setup_direct_io - setup MPI request for WARPDRIVE Direct I/O
- * @ioc: per adapter object
- * @scmd: pointer to scsi command object
- * @raid_device: pointer to raid device data structure
- * @mpi_request: pointer to the SCSI_IO reqest message frame
- * @smid: system request message index
- *
- * Returns nothing
- */
-static void
-_scsih_setup_direct_io(struct MPT2SAS_ADAPTER *ioc, struct scsi_cmnd *scmd,
-	struct _raid_device *raid_device, Mpi2SCSIIORequest_t *mpi_request,
-	u16 smid)
-{
-	sector_t v_lba, p_lba, stripe_off, column, io_size;
-	u32 stripe_sz, stripe_exp;
-	u8 num_pds, cmd = scmd->cmnd[0];
-
-	if (cmd != READ_10 && cmd != WRITE_10 &&
-	    cmd != READ_16 && cmd != WRITE_16)
-		return;
-
-	if (cmd == READ_10 || cmd == WRITE_10)
-		v_lba = get_unaligned_be32(&mpi_request->CDB.CDB32[2]);
-	else
-		v_lba = get_unaligned_be64(&mpi_request->CDB.CDB32[2]);
-
-	io_size = scsi_bufflen(scmd) >> raid_device->block_exponent;
-
-	if (v_lba + io_size - 1 > raid_device->max_lba)
-		return;
-
-	stripe_sz = raid_device->stripe_sz;
-	stripe_exp = raid_device->stripe_exponent;
-	stripe_off = v_lba & (stripe_sz - 1);
-
-	/* Return unless IO falls within a stripe */
-	if (stripe_off + io_size > stripe_sz)
-		return;
-
-	num_pds = raid_device->num_pds;
-	p_lba = v_lba >> stripe_exp;
-	column = sector_div(p_lba, num_pds);
-	p_lba = (p_lba << stripe_exp) + stripe_off;
-
-	mpi_request->DevHandle = cpu_to_le16(raid_device->pd_handle[column]);
-
-	if (cmd == READ_10 || cmd == WRITE_10)
-		put_unaligned_be32(lower_32_bits(p_lba),
-				   &mpi_request->CDB.CDB32[2]);
-	else
-		put_unaligned_be64(p_lba, &mpi_request->CDB.CDB32[2]);
-
-	_scsih_scsi_direct_io_set(ioc, smid, 1);
-}
-
-/**
- * _scsih_qcmd - main scsi request entry point
- * @scmd: pointer to scsi command object
- * @done: function pointer to be invoked on completion
- *
- * The callback index is set inside `ioc->scsi_io_cb_idx`.
- *
- * Returns 0 on success.  If there's a failure, return either:
- * SCSI_MLQUEUE_DEVICE_BUSY if the device queue is full, or
- * SCSI_MLQUEUE_HOST_BUSY if the entire host queue is full
- */
-static int
-_scsih_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *scmd)
-{
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-	struct _raid_device *raid_device;
-	Mpi2SCSIIORequest_t *mpi_request;
-	u32 mpi_control;
-	u16 smid;
-
-	sas_device_priv_data = scmd->device->hostdata;
-	if (!sas_device_priv_data || !sas_device_priv_data->sas_target) {
-		scmd->result = DID_NO_CONNECT << 16;
-		scmd->scsi_done(scmd);
-		return 0;
-	}
-
-	if (ioc->pci_error_recovery || ioc->remove_host) {
-		scmd->result = DID_NO_CONNECT << 16;
-		scmd->scsi_done(scmd);
-		return 0;
-	}
-
-	sas_target_priv_data = sas_device_priv_data->sas_target;
-	/* invalid device handle */
-	if (sas_target_priv_data->handle == MPT2SAS_INVALID_DEVICE_HANDLE) {
-		scmd->result = DID_NO_CONNECT << 16;
-		scmd->scsi_done(scmd);
-		return 0;
-	}
-
-	/* host recovery or link resets sent via IOCTLs */
-	if (ioc->shost_recovery || ioc->ioc_link_reset_in_progress)
-		return SCSI_MLQUEUE_HOST_BUSY;
-	/* device busy with task management */
-	else if (sas_device_priv_data->block || sas_target_priv_data->tm_busy)
-		return SCSI_MLQUEUE_DEVICE_BUSY;
-	/* device has been deleted */
-	else if (sas_target_priv_data->deleted) {
-		scmd->result = DID_NO_CONNECT << 16;
-		scmd->scsi_done(scmd);
-		return 0;
-	}
-
-	if (scmd->sc_data_direction == DMA_FROM_DEVICE)
-		mpi_control = MPI2_SCSIIO_CONTROL_READ;
-	else if (scmd->sc_data_direction == DMA_TO_DEVICE)
-		mpi_control = MPI2_SCSIIO_CONTROL_WRITE;
-	else
-		mpi_control = MPI2_SCSIIO_CONTROL_NODATATRANSFER;
-
-	/* set tags */
-	if (!(sas_device_priv_data->flags & MPT_DEVICE_FLAGS_INIT)) {
-		if (scmd->device->tagged_supported) {
-			if (scmd->device->ordered_tags)
-				mpi_control |= MPI2_SCSIIO_CONTROL_ORDEREDQ;
-			else
-				mpi_control |= MPI2_SCSIIO_CONTROL_SIMPLEQ;
-		} else
-			mpi_control |= MPI2_SCSIIO_CONTROL_SIMPLEQ;
-	} else
-		mpi_control |= MPI2_SCSIIO_CONTROL_SIMPLEQ;
-	/* Make sure Device is not raid volume.
-	 * We do not expose raid functionality to upper layer for warpdrive.
-	 */
-	if (!ioc->is_warpdrive && !_scsih_is_raid(&scmd->device->sdev_gendev) &&
-	    sas_is_tlr_enabled(scmd->device) && scmd->cmd_len != 32)
-		mpi_control |= MPI2_SCSIIO_CONTROL_TLR_ON;
-
-	smid = mpt2sas_base_get_smid_scsiio(ioc, ioc->scsi_io_cb_idx, scmd);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		goto out;
-	}
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	memset(mpi_request, 0, sizeof(Mpi2SCSIIORequest_t));
-	_scsih_setup_eedp(scmd, mpi_request);
-	if (scmd->cmd_len == 32)
-		mpi_control |= 4 << MPI2_SCSIIO_CONTROL_ADDCDBLEN_SHIFT;
-	mpi_request->Function = MPI2_FUNCTION_SCSI_IO_REQUEST;
-	if (sas_device_priv_data->sas_target->flags &
-	    MPT_TARGET_FLAGS_RAID_COMPONENT)
-		mpi_request->Function = MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH;
-	else
-	mpi_request->Function = MPI2_FUNCTION_SCSI_IO_REQUEST;
-	mpi_request->DevHandle =
-	    cpu_to_le16(sas_device_priv_data->sas_target->handle);
-	mpi_request->DataLength = cpu_to_le32(scsi_bufflen(scmd));
-	mpi_request->Control = cpu_to_le32(mpi_control);
-	mpi_request->IoFlags = cpu_to_le16(scmd->cmd_len);
-	mpi_request->MsgFlags = MPI2_SCSIIO_MSGFLAGS_SYSTEM_SENSE_ADDR;
-	mpi_request->SenseBufferLength = SCSI_SENSE_BUFFERSIZE;
-	mpi_request->SenseBufferLowAddress =
-	    mpt2sas_base_get_sense_buffer_dma(ioc, smid);
-	mpi_request->SGLOffset0 = offsetof(Mpi2SCSIIORequest_t, SGL) / 4;
-	mpi_request->SGLFlags = cpu_to_le16(MPI2_SCSIIO_SGLFLAGS_TYPE_MPI +
-	    MPI2_SCSIIO_SGLFLAGS_SYSTEM_ADDR);
-	mpi_request->VF_ID = 0; /* TODO */
-	mpi_request->VP_ID = 0;
-	int_to_scsilun(sas_device_priv_data->lun, (struct scsi_lun *)
-	    mpi_request->LUN);
-	memcpy(mpi_request->CDB.CDB32, scmd->cmnd, scmd->cmd_len);
-
-	if (!mpi_request->DataLength) {
-		mpt2sas_base_build_zero_len_sge(ioc, &mpi_request->SGL);
-	} else {
-		if (_scsih_build_scatter_gather(ioc, scmd, smid)) {
-			mpt2sas_base_free_smid(ioc, smid);
-			goto out;
-		}
-	}
-
-	raid_device = sas_target_priv_data->raid_device;
-	if (raid_device && raid_device->direct_io_enabled)
-		_scsih_setup_direct_io(ioc, scmd, raid_device, mpi_request,
-		    smid);
-
-	if (likely(mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST))
-		mpt2sas_base_put_smid_scsi_io(ioc, smid,
-		    le16_to_cpu(mpi_request->DevHandle));
-	else
-		mpt2sas_base_put_smid_default(ioc, smid);
-	return 0;
-
- out:
-	return SCSI_MLQUEUE_HOST_BUSY;
-}
-
-/**
- * _scsih_normalize_sense - normalize descriptor and fixed format sense data
- * @sense_buffer: sense data returned by target
- * @data: normalized skey/asc/ascq
- *
- * Return nothing.
- */
-static void
-_scsih_normalize_sense(char *sense_buffer, struct sense_info *data)
-{
-	if ((sense_buffer[0] & 0x7F) >= 0x72) {
-		/* descriptor format */
-		data->skey = sense_buffer[1] & 0x0F;
-		data->asc = sense_buffer[2];
-		data->ascq = sense_buffer[3];
-	} else {
-		/* fixed format */
-		data->skey = sense_buffer[2] & 0x0F;
-		data->asc = sense_buffer[12];
-		data->ascq = sense_buffer[13];
-	}
-}
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-/**
- * _scsih_scsi_ioc_info - translated non-successful SCSI_IO request
- * @ioc: per adapter object
- * @scmd: pointer to scsi command object
- * @mpi_reply: reply mf payload returned from firmware
- *
- * scsi_status - SCSI Status code returned from target device
- * scsi_state - state info associated with SCSI_IO determined by ioc
- * ioc_status - ioc supplied status info
- *
- * Return nothing.
- */
-static void
-_scsih_scsi_ioc_info(struct MPT2SAS_ADAPTER *ioc, struct scsi_cmnd *scmd,
-    Mpi2SCSIIOReply_t *mpi_reply, u16 smid)
-{
-	u32 response_info;
-	u8 *response_bytes;
-	u16 ioc_status = le16_to_cpu(mpi_reply->IOCStatus) &
-	    MPI2_IOCSTATUS_MASK;
-	u8 scsi_state = mpi_reply->SCSIState;
-	u8 scsi_status = mpi_reply->SCSIStatus;
-	char *desc_ioc_state = NULL;
-	char *desc_scsi_status = NULL;
-	char *desc_scsi_state = ioc->tmp_string;
-	u32 log_info = le32_to_cpu(mpi_reply->IOCLogInfo);
-	struct _sas_device *sas_device = NULL;
-	unsigned long flags;
-	struct scsi_target *starget = scmd->device->sdev_target;
-	struct MPT2SAS_TARGET *priv_target = starget->hostdata;
-	char *device_str = NULL;
-
-	if (!priv_target)
-		return;
-
-	if (ioc->hide_ir_msg)
-		device_str = "WarpDrive";
-	else
-		device_str = "volume";
-
-	if (log_info == 0x31170000)
-		return;
-
-	switch (ioc_status) {
-	case MPI2_IOCSTATUS_SUCCESS:
-		desc_ioc_state = "success";
-		break;
-	case MPI2_IOCSTATUS_INVALID_FUNCTION:
-		desc_ioc_state = "invalid function";
-		break;
-	case MPI2_IOCSTATUS_SCSI_RECOVERED_ERROR:
-		desc_ioc_state = "scsi recovered error";
-		break;
-	case MPI2_IOCSTATUS_SCSI_INVALID_DEVHANDLE:
-		desc_ioc_state = "scsi invalid dev handle";
-		break;
-	case MPI2_IOCSTATUS_SCSI_DEVICE_NOT_THERE:
-		desc_ioc_state = "scsi device not there";
-		break;
-	case MPI2_IOCSTATUS_SCSI_DATA_OVERRUN:
-		desc_ioc_state = "scsi data overrun";
-		break;
-	case MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN:
-		desc_ioc_state = "scsi data underrun";
-		break;
-	case MPI2_IOCSTATUS_SCSI_IO_DATA_ERROR:
-		desc_ioc_state = "scsi io data error";
-		break;
-	case MPI2_IOCSTATUS_SCSI_PROTOCOL_ERROR:
-		desc_ioc_state = "scsi protocol error";
-		break;
-	case MPI2_IOCSTATUS_SCSI_TASK_TERMINATED:
-		desc_ioc_state = "scsi task terminated";
-		break;
-	case MPI2_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:
-		desc_ioc_state = "scsi residual mismatch";
-		break;
-	case MPI2_IOCSTATUS_SCSI_TASK_MGMT_FAILED:
-		desc_ioc_state = "scsi task mgmt failed";
-		break;
-	case MPI2_IOCSTATUS_SCSI_IOC_TERMINATED:
-		desc_ioc_state = "scsi ioc terminated";
-		break;
-	case MPI2_IOCSTATUS_SCSI_EXT_TERMINATED:
-		desc_ioc_state = "scsi ext terminated";
-		break;
-	case MPI2_IOCSTATUS_EEDP_GUARD_ERROR:
-		desc_ioc_state = "eedp guard error";
-		break;
-	case MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:
-		desc_ioc_state = "eedp ref tag error";
-		break;
-	case MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:
-		desc_ioc_state = "eedp app tag error";
-		break;
-	default:
-		desc_ioc_state = "unknown";
-		break;
-	}
-
-	switch (scsi_status) {
-	case MPI2_SCSI_STATUS_GOOD:
-		desc_scsi_status = "good";
-		break;
-	case MPI2_SCSI_STATUS_CHECK_CONDITION:
-		desc_scsi_status = "check condition";
-		break;
-	case MPI2_SCSI_STATUS_CONDITION_MET:
-		desc_scsi_status = "condition met";
-		break;
-	case MPI2_SCSI_STATUS_BUSY:
-		desc_scsi_status = "busy";
-		break;
-	case MPI2_SCSI_STATUS_INTERMEDIATE:
-		desc_scsi_status = "intermediate";
-		break;
-	case MPI2_SCSI_STATUS_INTERMEDIATE_CONDMET:
-		desc_scsi_status = "intermediate condmet";
-		break;
-	case MPI2_SCSI_STATUS_RESERVATION_CONFLICT:
-		desc_scsi_status = "reservation conflict";
-		break;
-	case MPI2_SCSI_STATUS_COMMAND_TERMINATED:
-		desc_scsi_status = "command terminated";
-		break;
-	case MPI2_SCSI_STATUS_TASK_SET_FULL:
-		desc_scsi_status = "task set full";
-		break;
-	case MPI2_SCSI_STATUS_ACA_ACTIVE:
-		desc_scsi_status = "aca active";
-		break;
-	case MPI2_SCSI_STATUS_TASK_ABORTED:
-		desc_scsi_status = "task aborted";
-		break;
-	default:
-		desc_scsi_status = "unknown";
-		break;
-	}
-
-	desc_scsi_state[0] = '\0';
-	if (!scsi_state)
-		desc_scsi_state = " ";
-	if (scsi_state & MPI2_SCSI_STATE_RESPONSE_INFO_VALID)
-		strcat(desc_scsi_state, "response info ");
-	if (scsi_state & MPI2_SCSI_STATE_TERMINATED)
-		strcat(desc_scsi_state, "state terminated ");
-	if (scsi_state & MPI2_SCSI_STATE_NO_SCSI_STATUS)
-		strcat(desc_scsi_state, "no status ");
-	if (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_FAILED)
-		strcat(desc_scsi_state, "autosense failed ");
-	if (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID)
-		strcat(desc_scsi_state, "autosense valid ");
-
-	scsi_print_command(scmd);
-
-	if (priv_target->flags & MPT_TARGET_FLAGS_VOLUME) {
-		printk(MPT2SAS_WARN_FMT "\t%s wwid(0x%016llx)\n", ioc->name,
-		    device_str, (unsigned long long)priv_target->sas_address);
-	} else {
-		spin_lock_irqsave(&ioc->sas_device_lock, flags);
-		sas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-		    priv_target->sas_address);
-		if (sas_device) {
-			printk(MPT2SAS_WARN_FMT "\tsas_address(0x%016llx), "
-			    "phy(%d)\n", ioc->name, sas_device->sas_address,
-			    sas_device->phy);
-			printk(MPT2SAS_WARN_FMT
-			    "\tenclosure_logical_id(0x%016llx), slot(%d)\n",
-			    ioc->name, sas_device->enclosure_logical_id,
-			    sas_device->slot);
-		}
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	}
-
-	printk(MPT2SAS_WARN_FMT "\thandle(0x%04x), ioc_status(%s)(0x%04x), "
-	    "smid(%d)\n", ioc->name, le16_to_cpu(mpi_reply->DevHandle),
-	    desc_ioc_state, ioc_status, smid);
-	printk(MPT2SAS_WARN_FMT "\trequest_len(%d), underflow(%d), "
-	    "resid(%d)\n", ioc->name, scsi_bufflen(scmd), scmd->underflow,
-	    scsi_get_resid(scmd));
-	printk(MPT2SAS_WARN_FMT "\ttag(%d), transfer_count(%d), "
-	    "sc->result(0x%08x)\n", ioc->name, le16_to_cpu(mpi_reply->TaskTag),
-	    le32_to_cpu(mpi_reply->TransferCount), scmd->result);
-	printk(MPT2SAS_WARN_FMT "\tscsi_status(%s)(0x%02x), "
-	    "scsi_state(%s)(0x%02x)\n", ioc->name, desc_scsi_status,
-	    scsi_status, desc_scsi_state, scsi_state);
-
-	if (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID) {
-		struct sense_info data;
-		_scsih_normalize_sense(scmd->sense_buffer, &data);
-		printk(MPT2SAS_WARN_FMT "\t[sense_key,asc,ascq]: "
-		    "[0x%02x,0x%02x,0x%02x], count(%d)\n", ioc->name, data.skey,
-		    data.asc, data.ascq, le32_to_cpu(mpi_reply->SenseCount));
-	}
-
-	if (scsi_state & MPI2_SCSI_STATE_RESPONSE_INFO_VALID) {
-		response_info = le32_to_cpu(mpi_reply->ResponseInfo);
-		response_bytes = (u8 *)&response_info;
-		_scsih_response_code(ioc, response_bytes[0]);
-	}
-}
-#endif
-
-/**
- * _scsih_turn_on_pfa_led - illuminate PFA LED
- * @ioc: per adapter object
- * @handle: device handle
- * Context: process
- *
- * Return nothing.
- */
-static void
-_scsih_turn_on_pfa_led(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	Mpi2SepReply_t mpi_reply;
-	Mpi2SepRequest_t mpi_request;
-	struct _sas_device *sas_device;
-
-	sas_device = _scsih_sas_device_find_by_handle(ioc, handle);
-	if (!sas_device)
-		return;
-
-	memset(&mpi_request, 0, sizeof(Mpi2SepRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_SCSI_ENCLOSURE_PROCESSOR;
-	mpi_request.Action = MPI2_SEP_REQ_ACTION_WRITE_STATUS;
-	mpi_request.SlotStatus =
-	    cpu_to_le32(MPI2_SEP_REQ_SLOTSTATUS_PREDICTED_FAULT);
-	mpi_request.DevHandle = cpu_to_le16(handle);
-	mpi_request.Flags = MPI2_SEP_REQ_FLAGS_DEVHANDLE_ADDRESS;
-	if ((mpt2sas_base_scsi_enclosure_processor(ioc, &mpi_reply,
-	    &mpi_request)) != 0) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n", ioc->name,
-		__FILE__, __LINE__, __func__);
-		return;
-	}
-	sas_device->pfa_led_on = 1;
-
-
-	if (mpi_reply.IOCStatus || mpi_reply.IOCLogInfo) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT
-		 "enclosure_processor: ioc_status (0x%04x), loginfo(0x%08x)\n",
-		 ioc->name, le16_to_cpu(mpi_reply.IOCStatus),
-		 le32_to_cpu(mpi_reply.IOCLogInfo)));
-		return;
-	}
-}
-
-/**
- * _scsih_turn_off_pfa_led - turn off PFA LED
- * @ioc: per adapter object
- * @sas_device: sas device whose PFA LED has to turned off
- * Context: process
- *
- * Return nothing.
- */
-static void
-_scsih_turn_off_pfa_led(struct MPT2SAS_ADAPTER *ioc,
-	struct _sas_device *sas_device)
-{
-	Mpi2SepReply_t mpi_reply;
-	Mpi2SepRequest_t mpi_request;
-
-	memset(&mpi_request, 0, sizeof(Mpi2SepRequest_t));
-	mpi_request.Function = MPI2_FUNCTION_SCSI_ENCLOSURE_PROCESSOR;
-	mpi_request.Action = MPI2_SEP_REQ_ACTION_WRITE_STATUS;
-	mpi_request.SlotStatus = 0;
-	mpi_request.Slot = cpu_to_le16(sas_device->slot);
-	mpi_request.DevHandle = 0;
-	mpi_request.EnclosureHandle = cpu_to_le16(sas_device->enclosure_handle);
-	mpi_request.Flags = MPI2_SEP_REQ_FLAGS_ENCLOSURE_SLOT_ADDRESS;
-	if ((mpt2sas_base_scsi_enclosure_processor(ioc, &mpi_reply,
-	    &mpi_request)) != 0) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n", ioc->name,
-		__FILE__, __LINE__, __func__);
-		return;
-	}
-
-	if (mpi_reply.IOCStatus || mpi_reply.IOCLogInfo) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "enclosure_processor: "
-		    "ioc_status (0x%04x), loginfo(0x%08x)\n", ioc->name,
-		    le16_to_cpu(mpi_reply.IOCStatus),
-		    le32_to_cpu(mpi_reply.IOCLogInfo)));
-		return;
-	}
-}
-
-/**
- * _scsih_send_event_to_turn_on_pfa_led - fire delayed event
- * @ioc: per adapter object
- * @handle: device handle
- * Context: interrupt.
- *
- * Return nothing.
- */
-static void
-_scsih_send_event_to_turn_on_pfa_led(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	struct fw_event_work *fw_event;
-
-	fw_event = alloc_fw_event_work(0);
-	if (!fw_event)
-		return;
-	fw_event->event = MPT2SAS_TURN_ON_PFA_LED;
-	fw_event->device_handle = handle;
-	fw_event->ioc = ioc;
-	_scsih_fw_event_add(ioc, fw_event);
-	fw_event_work_put(fw_event);
-}
-
-/**
- * _scsih_smart_predicted_fault - process smart errors
- * @ioc: per adapter object
- * @handle: device handle
- * Context: interrupt.
- *
- * Return nothing.
- */
-static void
-_scsih_smart_predicted_fault(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	struct scsi_target *starget;
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-	Mpi2EventNotificationReply_t *event_reply;
-	Mpi2EventDataSasDeviceStatusChange_t *event_data;
-	struct _sas_device *sas_device;
-	ssize_t sz;
-	unsigned long flags;
-
-	/* only handle non-raid devices */
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_device = _scsih_sas_device_find_by_handle(ioc, handle);
-	if (!sas_device) {
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-		return;
-	}
-	starget = sas_device->starget;
-	sas_target_priv_data = starget->hostdata;
-
-	if ((sas_target_priv_data->flags & MPT_TARGET_FLAGS_RAID_COMPONENT) ||
-	   ((sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME))) {
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-		return;
-	}
-	starget_printk(KERN_WARNING, starget, "predicted fault\n");
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-
-	if (ioc->pdev->subsystem_vendor == PCI_VENDOR_ID_IBM)
-		_scsih_send_event_to_turn_on_pfa_led(ioc, handle);
-
-	/* insert into event log */
-	sz = offsetof(Mpi2EventNotificationReply_t, EventData) +
-	     sizeof(Mpi2EventDataSasDeviceStatusChange_t);
-	event_reply = kzalloc(sz, GFP_ATOMIC);
-	if (!event_reply) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return;
-	}
-
-	event_reply->Function = MPI2_FUNCTION_EVENT_NOTIFICATION;
-	event_reply->Event =
-	    cpu_to_le16(MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE);
-	event_reply->MsgLength = sz/4;
-	event_reply->EventDataLength =
-	    cpu_to_le16(sizeof(Mpi2EventDataSasDeviceStatusChange_t)/4);
-	event_data = (Mpi2EventDataSasDeviceStatusChange_t *)
-	    event_reply->EventData;
-	event_data->ReasonCode = MPI2_EVENT_SAS_DEV_STAT_RC_SMART_DATA;
-	event_data->ASC = 0x5D;
-	event_data->DevHandle = cpu_to_le16(handle);
-	event_data->SASAddress = cpu_to_le64(sas_target_priv_data->sas_address);
-	mpt2sas_ctl_add_to_event_log(ioc, event_reply);
-	kfree(event_reply);
-}
-
-/**
- * _scsih_io_done - scsi request callback
- * @ioc: per adapter object
- * @smid: system request message index
- * @msix_index: MSIX table index supplied by the OS
- * @reply: reply message frame(lower 32bit addr)
- *
- * Callback handler when using _scsih_qcmd.
- *
- * Return 1 meaning mf should be freed from _base_interrupt
- *        0 means the mf is freed from this function.
- */
-static u8
-_scsih_io_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)
-{
-	Mpi2SCSIIORequest_t *mpi_request;
-	Mpi2SCSIIOReply_t *mpi_reply;
-	struct scsi_cmnd *scmd;
-	u16 ioc_status;
-	u32 xfer_cnt;
-	u8 scsi_state;
-	u8 scsi_status;
-	u32 log_info;
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	u32 response_code = 0;
-	unsigned long flags;
-
-	mpi_reply = mpt2sas_base_get_reply_virt_addr(ioc, reply);
-	scmd = _scsih_scsi_lookup_get_clear(ioc, smid);
-	if (scmd == NULL)
-		return 1;
-
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-
-	if (mpi_reply == NULL) {
-		scmd->result = DID_OK << 16;
-		goto out;
-	}
-
-	sas_device_priv_data = scmd->device->hostdata;
-	if (!sas_device_priv_data || !sas_device_priv_data->sas_target ||
-	     sas_device_priv_data->sas_target->deleted) {
-		scmd->result = DID_NO_CONNECT << 16;
-		goto out;
-	}
-	ioc_status = le16_to_cpu(mpi_reply->IOCStatus);
-	/*
-	 * WARPDRIVE: If direct_io is set then it is directIO,
-	 * the failed direct I/O should be redirected to volume
-	 */
-	if (_scsih_scsi_direct_io_get(ioc, smid) &&
-	    ((ioc_status & MPI2_IOCSTATUS_MASK)
-	    != MPI2_IOCSTATUS_SCSI_TASK_TERMINATED)) {
-		spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-		ioc->scsi_lookup[smid - 1].scmd = scmd;
-		_scsih_scsi_direct_io_set(ioc, smid, 0);
-		spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-		memcpy(mpi_request->CDB.CDB32, scmd->cmnd, scmd->cmd_len);
-		mpi_request->DevHandle =
-		    cpu_to_le16(sas_device_priv_data->sas_target->handle);
-		mpt2sas_base_put_smid_scsi_io(ioc, smid,
-		    sas_device_priv_data->sas_target->handle);
-		return 0;
-	}
-
-
-	/* turning off TLR */
-	scsi_state = mpi_reply->SCSIState;
-	if (scsi_state & MPI2_SCSI_STATE_RESPONSE_INFO_VALID)
-		response_code =
-		    le32_to_cpu(mpi_reply->ResponseInfo) & 0xFF;
-	if (!sas_device_priv_data->tlr_snoop_check) {
-		sas_device_priv_data->tlr_snoop_check++;
-	/* Make sure Device is not raid volume.
-	 * We do not expose raid functionality to upper layer for warpdrive.
-	 */
-	if (!ioc->is_warpdrive && !_scsih_is_raid(&scmd->device->sdev_gendev) &&
-		sas_is_tlr_enabled(scmd->device) &&
-		    response_code == MPI2_SCSITASKMGMT_RSP_INVALID_FRAME) {
-			sas_disable_tlr(scmd->device);
-			sdev_printk(KERN_INFO, scmd->device, "TLR disabled\n");
-		}
-	}
-
-	xfer_cnt = le32_to_cpu(mpi_reply->TransferCount);
-	scsi_set_resid(scmd, scsi_bufflen(scmd) - xfer_cnt);
-	if (ioc_status & MPI2_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE)
-		log_info =  le32_to_cpu(mpi_reply->IOCLogInfo);
-	else
-		log_info = 0;
-	ioc_status &= MPI2_IOCSTATUS_MASK;
-	scsi_status = mpi_reply->SCSIStatus;
-
-	if (ioc_status == MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN && xfer_cnt == 0 &&
-	    (scsi_status == MPI2_SCSI_STATUS_BUSY ||
-	     scsi_status == MPI2_SCSI_STATUS_RESERVATION_CONFLICT ||
-	     scsi_status == MPI2_SCSI_STATUS_TASK_SET_FULL)) {
-		ioc_status = MPI2_IOCSTATUS_SUCCESS;
-	}
-
-	if (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID) {
-		struct sense_info data;
-		const void *sense_data = mpt2sas_base_get_sense_buffer(ioc,
-		    smid);
-		u32 sz = min_t(u32, SCSI_SENSE_BUFFERSIZE,
-		    le32_to_cpu(mpi_reply->SenseCount));
-		memcpy(scmd->sense_buffer, sense_data, sz);
-		_scsih_normalize_sense(scmd->sense_buffer, &data);
-		/* failure prediction threshold exceeded */
-		if (data.asc == 0x5D)
-			_scsih_smart_predicted_fault(ioc,
-			    le16_to_cpu(mpi_reply->DevHandle));
-	}
-
-	switch (ioc_status) {
-	case MPI2_IOCSTATUS_BUSY:
-	case MPI2_IOCSTATUS_INSUFFICIENT_RESOURCES:
-		scmd->result = SAM_STAT_BUSY;
-		break;
-
-	case MPI2_IOCSTATUS_SCSI_DEVICE_NOT_THERE:
-		scmd->result = DID_NO_CONNECT << 16;
-		break;
-
-	case MPI2_IOCSTATUS_SCSI_IOC_TERMINATED:
-		if (sas_device_priv_data->block) {
-			scmd->result = DID_TRANSPORT_DISRUPTED << 16;
-			goto out;
-		}
-		if (log_info == 0x32010081) {
-			scmd->result = DID_RESET << 16;
-			break;
-		}
-		scmd->result = DID_SOFT_ERROR << 16;
-		break;
-	case MPI2_IOCSTATUS_SCSI_TASK_TERMINATED:
-	case MPI2_IOCSTATUS_SCSI_EXT_TERMINATED:
-		scmd->result = DID_RESET << 16;
-		break;
-
-	case MPI2_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:
-		if ((xfer_cnt == 0) || (scmd->underflow > xfer_cnt))
-			scmd->result = DID_SOFT_ERROR << 16;
-		else
-			scmd->result = (DID_OK << 16) | scsi_status;
-		break;
-
-	case MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN:
-		scmd->result = (DID_OK << 16) | scsi_status;
-
-		if ((scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID))
-			break;
-
-		if (xfer_cnt < scmd->underflow) {
-			if (scsi_status == SAM_STAT_BUSY)
-				scmd->result = SAM_STAT_BUSY;
-			else
-				scmd->result = DID_SOFT_ERROR << 16;
-		} else if (scsi_state & (MPI2_SCSI_STATE_AUTOSENSE_FAILED |
-		     MPI2_SCSI_STATE_NO_SCSI_STATUS))
-			scmd->result = DID_SOFT_ERROR << 16;
-		else if (scsi_state & MPI2_SCSI_STATE_TERMINATED)
-			scmd->result = DID_RESET << 16;
-		else if (!xfer_cnt && scmd->cmnd[0] == REPORT_LUNS) {
-			mpi_reply->SCSIState = MPI2_SCSI_STATE_AUTOSENSE_VALID;
-			mpi_reply->SCSIStatus = SAM_STAT_CHECK_CONDITION;
-			scmd->result = (DRIVER_SENSE << 24) |
-			    SAM_STAT_CHECK_CONDITION;
-			scmd->sense_buffer[0] = 0x70;
-			scmd->sense_buffer[2] = ILLEGAL_REQUEST;
-			scmd->sense_buffer[12] = 0x20;
-			scmd->sense_buffer[13] = 0;
-		}
-		break;
-
-	case MPI2_IOCSTATUS_SCSI_DATA_OVERRUN:
-		scsi_set_resid(scmd, 0);
-	case MPI2_IOCSTATUS_SCSI_RECOVERED_ERROR:
-	case MPI2_IOCSTATUS_SUCCESS:
-		scmd->result = (DID_OK << 16) | scsi_status;
-		if (response_code ==
-		    MPI2_SCSITASKMGMT_RSP_INVALID_FRAME ||
-		    (scsi_state & (MPI2_SCSI_STATE_AUTOSENSE_FAILED |
-		     MPI2_SCSI_STATE_NO_SCSI_STATUS)))
-			scmd->result = DID_SOFT_ERROR << 16;
-		else if (scsi_state & MPI2_SCSI_STATE_TERMINATED)
-			scmd->result = DID_RESET << 16;
-		break;
-
-	case MPI2_IOCSTATUS_EEDP_GUARD_ERROR:
-	case MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:
-	case MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:
-		_scsih_eedp_error_handling(scmd, ioc_status);
-		break;
-	case MPI2_IOCSTATUS_SCSI_PROTOCOL_ERROR:
-	case MPI2_IOCSTATUS_INVALID_FUNCTION:
-	case MPI2_IOCSTATUS_INVALID_SGL:
-	case MPI2_IOCSTATUS_INTERNAL_ERROR:
-	case MPI2_IOCSTATUS_INVALID_FIELD:
-	case MPI2_IOCSTATUS_INVALID_STATE:
-	case MPI2_IOCSTATUS_SCSI_IO_DATA_ERROR:
-	case MPI2_IOCSTATUS_SCSI_TASK_MGMT_FAILED:
-	default:
-		scmd->result = DID_SOFT_ERROR << 16;
-		break;
-
-	}
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-	if (scmd->result && (ioc->logging_level & MPT_DEBUG_REPLY))
-		_scsih_scsi_ioc_info(ioc , scmd, mpi_reply, smid);
-#endif
-
- out:
-	scsi_dma_unmap(scmd);
-	scmd->scsi_done(scmd);
-	return 1;
-}
-
-/**
- * _scsih_sas_host_refresh - refreshing sas host object contents
- * @ioc: per adapter object
- * Context: user
- *
- * During port enable, fw will send topology events for every device. Its
- * possible that the handles may change from the previous setting, so this
- * code keeping handles updating if changed.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_host_refresh(struct MPT2SAS_ADAPTER *ioc)
-{
-	u16 sz;
-	u16 ioc_status;
-	int i;
-	Mpi2ConfigReply_t mpi_reply;
-	Mpi2SasIOUnitPage0_t *sas_iounit_pg0 = NULL;
-	u16 attached_handle;
-	u8 link_rate;
-
-	dtmprintk(ioc, printk(MPT2SAS_INFO_FMT
-	    "updating handles for sas_host(0x%016llx)\n",
-	    ioc->name, (unsigned long long)ioc->sas_hba.sas_address));
-
-	sz = offsetof(Mpi2SasIOUnitPage0_t, PhyData) + (ioc->sas_hba.num_phys
-	    * sizeof(Mpi2SasIOUnit0PhyData_t));
-	sas_iounit_pg0 = kzalloc(sz, GFP_KERNEL);
-	if (!sas_iounit_pg0) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return;
-	}
-
-	if ((mpt2sas_config_get_sas_iounit_pg0(ioc, &mpi_reply,
-	    sas_iounit_pg0, sz)) != 0)
-		goto out;
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS)
-		goto out;
-	for (i = 0; i < ioc->sas_hba.num_phys ; i++) {
-		link_rate = sas_iounit_pg0->PhyData[i].NegotiatedLinkRate >> 4;
-		if (i == 0)
-			ioc->sas_hba.handle = le16_to_cpu(sas_iounit_pg0->
-			    PhyData[0].ControllerDevHandle);
-		ioc->sas_hba.phy[i].handle = ioc->sas_hba.handle;
-		attached_handle = le16_to_cpu(sas_iounit_pg0->PhyData[i].
-		    AttachedDevHandle);
-		if (attached_handle && link_rate < MPI2_SAS_NEG_LINK_RATE_1_5)
-			link_rate = MPI2_SAS_NEG_LINK_RATE_1_5;
-		mpt2sas_transport_update_links(ioc, ioc->sas_hba.sas_address,
-		    attached_handle, i, link_rate);
-	}
- out:
-	kfree(sas_iounit_pg0);
-}
-
-/**
- * _scsih_sas_host_add - create sas host object
- * @ioc: per adapter object
- *
- * Creating host side data object, stored in ioc->sas_hba
- *
- * Return nothing.
- */
-static void
-_scsih_sas_host_add(struct MPT2SAS_ADAPTER *ioc)
-{
-	int i;
-	Mpi2ConfigReply_t mpi_reply;
-	Mpi2SasIOUnitPage0_t *sas_iounit_pg0 = NULL;
-	Mpi2SasIOUnitPage1_t *sas_iounit_pg1 = NULL;
-	Mpi2SasPhyPage0_t phy_pg0;
-	Mpi2SasDevicePage0_t sas_device_pg0;
-	Mpi2SasEnclosurePage0_t enclosure_pg0;
-	u16 ioc_status;
-	u16 sz;
-	u16 device_missing_delay;
-
-	mpt2sas_config_get_number_hba_phys(ioc, &ioc->sas_hba.num_phys);
-	if (!ioc->sas_hba.num_phys) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return;
-	}
-
-	/* sas_iounit page 0 */
-	sz = offsetof(Mpi2SasIOUnitPage0_t, PhyData) + (ioc->sas_hba.num_phys *
-	    sizeof(Mpi2SasIOUnit0PhyData_t));
-	sas_iounit_pg0 = kzalloc(sz, GFP_KERNEL);
-	if (!sas_iounit_pg0) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return;
-	}
-	if ((mpt2sas_config_get_sas_iounit_pg0(ioc, &mpi_reply,
-	    sas_iounit_pg0, sz))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out;
-	}
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-	    MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out;
-	}
-
-	/* sas_iounit page 1 */
-	sz = offsetof(Mpi2SasIOUnitPage1_t, PhyData) + (ioc->sas_hba.num_phys *
-	    sizeof(Mpi2SasIOUnit1PhyData_t));
-	sas_iounit_pg1 = kzalloc(sz, GFP_KERNEL);
-	if (!sas_iounit_pg1) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out;
-	}
-	if ((mpt2sas_config_get_sas_iounit_pg1(ioc, &mpi_reply,
-	    sas_iounit_pg1, sz))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out;
-	}
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-	    MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out;
-	}
-
-	ioc->io_missing_delay =
-	    le16_to_cpu(sas_iounit_pg1->IODeviceMissingDelay);
-	device_missing_delay =
-	    le16_to_cpu(sas_iounit_pg1->ReportDeviceMissingDelay);
-	if (device_missing_delay & MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16)
-		ioc->device_missing_delay = (device_missing_delay &
-		    MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK) * 16;
-	else
-		ioc->device_missing_delay = device_missing_delay &
-		    MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK;
-
-	ioc->sas_hba.parent_dev = &ioc->shost->shost_gendev;
-	ioc->sas_hba.phy = kcalloc(ioc->sas_hba.num_phys,
-	    sizeof(struct _sas_phy), GFP_KERNEL);
-	if (!ioc->sas_hba.phy) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out;
-	}
-	for (i = 0; i < ioc->sas_hba.num_phys ; i++) {
-		if ((mpt2sas_config_get_phy_pg0(ioc, &mpi_reply, &phy_pg0,
-		    i))) {
-			printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-			    ioc->name, __FILE__, __LINE__, __func__);
-			goto out;
-		}
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-		    MPI2_IOCSTATUS_MASK;
-		if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-			printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-			    ioc->name, __FILE__, __LINE__, __func__);
-			goto out;
-		}
-
-		if (i == 0)
-			ioc->sas_hba.handle = le16_to_cpu(sas_iounit_pg0->
-			    PhyData[0].ControllerDevHandle);
-		ioc->sas_hba.phy[i].handle = ioc->sas_hba.handle;
-		ioc->sas_hba.phy[i].phy_id = i;
-		mpt2sas_transport_add_host_phy(ioc, &ioc->sas_hba.phy[i],
-		    phy_pg0, ioc->sas_hba.parent_dev);
-	}
-	if ((mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,
-	    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, ioc->sas_hba.handle))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out;
-	}
-	ioc->sas_hba.enclosure_handle =
-	    le16_to_cpu(sas_device_pg0.EnclosureHandle);
-	ioc->sas_hba.sas_address = le64_to_cpu(sas_device_pg0.SASAddress);
-	printk(MPT2SAS_INFO_FMT "host_add: handle(0x%04x), "
-	    "sas_addr(0x%016llx), phys(%d)\n", ioc->name, ioc->sas_hba.handle,
-	    (unsigned long long) ioc->sas_hba.sas_address,
-	    ioc->sas_hba.num_phys) ;
-
-	if (ioc->sas_hba.enclosure_handle) {
-		if (!(mpt2sas_config_get_enclosure_pg0(ioc, &mpi_reply,
-		    &enclosure_pg0,
-		   MPI2_SAS_ENCLOS_PGAD_FORM_HANDLE,
-		   ioc->sas_hba.enclosure_handle))) {
-			ioc->sas_hba.enclosure_logical_id =
-			    le64_to_cpu(enclosure_pg0.EnclosureLogicalID);
-		}
-	}
-
- out:
-	kfree(sas_iounit_pg1);
-	kfree(sas_iounit_pg0);
-}
-
-/**
- * _scsih_expander_add -  creating expander object
- * @ioc: per adapter object
- * @handle: expander handle
- *
- * Creating expander object, stored in ioc->sas_expander_list.
- *
- * Return 0 for success, else error.
- */
-static int
-_scsih_expander_add(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	struct _sas_node *sas_expander;
-	Mpi2ConfigReply_t mpi_reply;
-	Mpi2ExpanderPage0_t expander_pg0;
-	Mpi2ExpanderPage1_t expander_pg1;
-	Mpi2SasEnclosurePage0_t enclosure_pg0;
-	u32 ioc_status;
-	u16 parent_handle;
-	u64 sas_address, sas_address_parent = 0;
-	int i;
-	unsigned long flags;
-	struct _sas_port *mpt2sas_port = NULL;
-	int rc = 0;
-
-	if (!handle)
-		return -1;
-
-	if (ioc->shost_recovery || ioc->pci_error_recovery)
-		return -1;
-
-	if ((mpt2sas_config_get_expander_pg0(ioc, &mpi_reply, &expander_pg0,
-	    MPI2_SAS_EXPAND_PGAD_FORM_HNDL, handle))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return -1;
-	}
-
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-	    MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return -1;
-	}
-
-	/* handle out of order topology events */
-	parent_handle = le16_to_cpu(expander_pg0.ParentDevHandle);
-	if (_scsih_get_sas_address(ioc, parent_handle, &sas_address_parent)
-	    != 0) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return -1;
-	}
-	if (sas_address_parent != ioc->sas_hba.sas_address) {
-		spin_lock_irqsave(&ioc->sas_node_lock, flags);
-		sas_expander = mpt2sas_scsih_expander_find_by_sas_address(ioc,
-		    sas_address_parent);
-		spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-		if (!sas_expander) {
-			rc = _scsih_expander_add(ioc, parent_handle);
-			if (rc != 0)
-				return rc;
-		}
-	}
-
-	spin_lock_irqsave(&ioc->sas_node_lock, flags);
-	sas_address = le64_to_cpu(expander_pg0.SASAddress);
-	sas_expander = mpt2sas_scsih_expander_find_by_sas_address(ioc,
-	    sas_address);
-	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-
-	if (sas_expander)
-		return 0;
-
-	sas_expander = kzalloc(sizeof(struct _sas_node),
-	    GFP_KERNEL);
-	if (!sas_expander) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return -1;
-	}
-
-	sas_expander->handle = handle;
-	sas_expander->num_phys = expander_pg0.NumPhys;
-	sas_expander->sas_address_parent = sas_address_parent;
-	sas_expander->sas_address = sas_address;
-
-	printk(MPT2SAS_INFO_FMT "expander_add: handle(0x%04x),"
-	    " parent(0x%04x), sas_addr(0x%016llx), phys(%d)\n", ioc->name,
-	    handle, parent_handle, (unsigned long long)
-	    sas_expander->sas_address, sas_expander->num_phys);
-
-	if (!sas_expander->num_phys)
-		goto out_fail;
-	sas_expander->phy = kcalloc(sas_expander->num_phys,
-	    sizeof(struct _sas_phy), GFP_KERNEL);
-	if (!sas_expander->phy) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		rc = -1;
-		goto out_fail;
-	}
-
-	INIT_LIST_HEAD(&sas_expander->sas_port_list);
-	mpt2sas_port = mpt2sas_transport_port_add(ioc, handle,
-	    sas_address_parent);
-	if (!mpt2sas_port) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		rc = -1;
-		goto out_fail;
-	}
-	sas_expander->parent_dev = &mpt2sas_port->rphy->dev;
-
-	for (i = 0 ; i < sas_expander->num_phys ; i++) {
-		if ((mpt2sas_config_get_expander_pg1(ioc, &mpi_reply,
-		    &expander_pg1, i, handle))) {
-			printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-			    ioc->name, __FILE__, __LINE__, __func__);
-			rc = -1;
-			goto out_fail;
-		}
-		sas_expander->phy[i].handle = handle;
-		sas_expander->phy[i].phy_id = i;
-
-		if ((mpt2sas_transport_add_expander_phy(ioc,
-		    &sas_expander->phy[i], expander_pg1,
-		    sas_expander->parent_dev))) {
-			printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-			    ioc->name, __FILE__, __LINE__, __func__);
-			rc = -1;
-			goto out_fail;
-		}
-	}
-
-	if (sas_expander->enclosure_handle) {
-		if (!(mpt2sas_config_get_enclosure_pg0(ioc, &mpi_reply,
-		    &enclosure_pg0, MPI2_SAS_ENCLOS_PGAD_FORM_HANDLE,
-		   sas_expander->enclosure_handle))) {
-			sas_expander->enclosure_logical_id =
-			    le64_to_cpu(enclosure_pg0.EnclosureLogicalID);
-		}
-	}
-
-	_scsih_expander_node_add(ioc, sas_expander);
-	 return 0;
-
- out_fail:
-
-	if (mpt2sas_port)
-		mpt2sas_transport_port_remove(ioc, sas_expander->sas_address,
-		    sas_address_parent);
-	kfree(sas_expander);
-	return rc;
-}
-
-/**
- * _scsih_done -  scsih callback handler.
- * @ioc: per adapter object
- * @smid: system request message index
- * @msix_index: MSIX table index supplied by the OS
- * @reply: reply message frame(lower 32bit addr)
- *
- * Callback handler when sending internal generated message frames.
- * The callback index passed is `ioc->scsih_cb_idx`
- *
- * Return 1 meaning mf should be freed from _base_interrupt
- *        0 means the mf is freed from this function.
- */
-static u8
-_scsih_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)
-{
-	MPI2DefaultReply_t *mpi_reply;
-
-	mpi_reply =  mpt2sas_base_get_reply_virt_addr(ioc, reply);
-	if (ioc->scsih_cmds.status == MPT2_CMD_NOT_USED)
-		return 1;
-	if (ioc->scsih_cmds.smid != smid)
-		return 1;
-	ioc->scsih_cmds.status |= MPT2_CMD_COMPLETE;
-	if (mpi_reply) {
-		memcpy(ioc->scsih_cmds.reply, mpi_reply,
-		    mpi_reply->MsgLength*4);
-		ioc->scsih_cmds.status |= MPT2_CMD_REPLY_VALID;
-	}
-	ioc->scsih_cmds.status &= ~MPT2_CMD_PENDING;
-	complete(&ioc->scsih_cmds.done);
-	return 1;
-}
-
-/**
- * mpt2sas_expander_remove - removing expander object
- * @ioc: per adapter object
- * @sas_address: expander sas_address
- *
- * Return nothing.
- */
-void
-mpt2sas_expander_remove(struct MPT2SAS_ADAPTER *ioc, u64 sas_address)
-{
-	struct _sas_node *sas_expander;
-	unsigned long flags;
-
-	if (ioc->shost_recovery)
-		return;
-
-	spin_lock_irqsave(&ioc->sas_node_lock, flags);
-	sas_expander = mpt2sas_scsih_expander_find_by_sas_address(ioc,
-	    sas_address);
-	if (sas_expander)
-		list_del(&sas_expander->list);
-	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-	if (sas_expander)
-		_scsih_expander_node_remove(ioc, sas_expander);
-}
-
-/**
- * _scsih_check_access_status - check access flags
- * @ioc: per adapter object
- * @sas_address: sas address
- * @handle: sas device handle
- * @access_flags: errors returned during discovery of the device
- *
- * Return 0 for success, else failure
- */
-static u8
-_scsih_check_access_status(struct MPT2SAS_ADAPTER *ioc, u64 sas_address,
-   u16 handle, u8 access_status)
-{
-	u8 rc = 1;
-	char *desc = NULL;
-
-	switch (access_status) {
-	case MPI2_SAS_DEVICE0_ASTATUS_NO_ERRORS:
-	case MPI2_SAS_DEVICE0_ASTATUS_SATA_NEEDS_INITIALIZATION:
-		rc = 0;
-		break;
-	case MPI2_SAS_DEVICE0_ASTATUS_SATA_CAPABILITY_FAILED:
-		desc = "sata capability failed";
-		break;
-	case MPI2_SAS_DEVICE0_ASTATUS_SATA_AFFILIATION_CONFLICT:
-		desc = "sata affiliation conflict";
-		break;
-	case MPI2_SAS_DEVICE0_ASTATUS_ROUTE_NOT_ADDRESSABLE:
-		desc = "route not addressable";
-		break;
-	case MPI2_SAS_DEVICE0_ASTATUS_SMP_ERROR_NOT_ADDRESSABLE:
-		desc = "smp error not addressable";
-		break;
-	case MPI2_SAS_DEVICE0_ASTATUS_DEVICE_BLOCKED:
-		desc = "device blocked";
-		break;
-	case MPI2_SAS_DEVICE0_ASTATUS_SATA_INIT_FAILED:
-	case MPI2_SAS_DEVICE0_ASTATUS_SIF_UNKNOWN:
-	case MPI2_SAS_DEVICE0_ASTATUS_SIF_AFFILIATION_CONFLICT:
-	case MPI2_SAS_DEVICE0_ASTATUS_SIF_DIAG:
-	case MPI2_SAS_DEVICE0_ASTATUS_SIF_IDENTIFICATION:
-	case MPI2_SAS_DEVICE0_ASTATUS_SIF_CHECK_POWER:
-	case MPI2_SAS_DEVICE0_ASTATUS_SIF_PIO_SN:
-	case MPI2_SAS_DEVICE0_ASTATUS_SIF_MDMA_SN:
-	case MPI2_SAS_DEVICE0_ASTATUS_SIF_UDMA_SN:
-	case MPI2_SAS_DEVICE0_ASTATUS_SIF_ZONING_VIOLATION:
-	case MPI2_SAS_DEVICE0_ASTATUS_SIF_NOT_ADDRESSABLE:
-	case MPI2_SAS_DEVICE0_ASTATUS_SIF_MAX:
-		desc = "sata initialization failed";
-		break;
-	default:
-		desc = "unknown";
-		break;
-	}
-
-	if (!rc)
-		return 0;
-
-	printk(MPT2SAS_ERR_FMT "discovery errors(%s): sas_address(0x%016llx), "
-	    "handle(0x%04x)\n", ioc->name, desc,
-	    (unsigned long long)sas_address, handle);
-	return rc;
-}
-
-static void
-_scsih_check_device(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	Mpi2ConfigReply_t mpi_reply;
-	Mpi2SasDevicePage0_t sas_device_pg0;
-	struct _sas_device *sas_device;
-	u32 ioc_status;
-	unsigned long flags;
-	u64 sas_address;
-	struct scsi_target *starget;
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-	u32 device_info;
-
-
-	if ((mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,
-	    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle)))
-		return;
-
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS)
-		return;
-
-	/* check if this is end device */
-	device_info = le32_to_cpu(sas_device_pg0.DeviceInfo);
-	if (!(_scsih_is_end_device(device_info)))
-		return;
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_address = le64_to_cpu(sas_device_pg0.SASAddress);
-	sas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-	    sas_address);
-
-	if (!sas_device) {
-		printk(MPT2SAS_ERR_FMT "device is not present "
-		    "handle(0x%04x), no sas_device!!!\n", ioc->name, handle);
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-		return;
-	}
-
-	if (unlikely(sas_device->handle != handle)) {
-		starget = sas_device->starget;
-		sas_target_priv_data = starget->hostdata;
-		starget_printk(KERN_INFO, starget, "handle changed from(0x%04x)"
-		   " to (0x%04x)!!!\n", sas_device->handle, handle);
-		sas_target_priv_data->handle = handle;
-		sas_device->handle = handle;
-	}
-
-	/* check if device is present */
-	if (!(le16_to_cpu(sas_device_pg0.Flags) &
-	    MPI2_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)) {
-		printk(MPT2SAS_ERR_FMT "device is not present "
-		    "handle(0x%04x), flags!!!\n", ioc->name, handle);
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-		return;
-	}
-
-	/* check if there were any issues with discovery */
-	if (_scsih_check_access_status(ioc, sas_address, handle,
-	    sas_device_pg0.AccessStatus)) {
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-		return;
-	}
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	_scsih_ublock_io_device(ioc, sas_address);
-
-}
-
-/**
- * _scsih_add_device -  creating sas device object
- * @ioc: per adapter object
- * @handle: sas device handle
- * @phy_num: phy number end device attached to
- * @is_pd: is this hidden raid component
- *
- * Creating end device object, stored in ioc->sas_device_list.
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_scsih_add_device(struct MPT2SAS_ADAPTER *ioc, u16 handle, u8 phy_num, u8 is_pd)
-{
-	Mpi2ConfigReply_t mpi_reply;
-	Mpi2SasDevicePage0_t sas_device_pg0;
-	Mpi2SasEnclosurePage0_t enclosure_pg0;
-	struct _sas_device *sas_device;
-	u32 ioc_status;
-	__le64 sas_address;
-	u32 device_info;
-	unsigned long flags;
-
-	if ((mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,
-	    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return -1;
-	}
-
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-	    MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return -1;
-	}
-
-	sas_address = le64_to_cpu(sas_device_pg0.SASAddress);
-
-	/* check if device is present */
-	if (!(le16_to_cpu(sas_device_pg0.Flags) &
-	    MPI2_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		printk(MPT2SAS_ERR_FMT "Flags = 0x%04x\n",
-		    ioc->name, le16_to_cpu(sas_device_pg0.Flags));
-		return -1;
-	}
-
-	/* check if there were any issues with discovery */
-	if (_scsih_check_access_status(ioc, sas_address, handle,
-	    sas_device_pg0.AccessStatus))
-		return -1;
-
-	/* check if this is end device */
-	device_info = le32_to_cpu(sas_device_pg0.DeviceInfo);
-	if (!(_scsih_is_end_device(device_info))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return -1;
-	}
-
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-	    sas_address);
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-
-	if (sas_device)
-		return 0;
-
-	sas_device = kzalloc(sizeof(struct _sas_device),
-	    GFP_KERNEL);
-	if (!sas_device) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return -1;
-	}
-
-	sas_device->handle = handle;
-	if (_scsih_get_sas_address(ioc, le16_to_cpu
-		(sas_device_pg0.ParentDevHandle),
-		&sas_device->sas_address_parent) != 0)
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-	sas_device->enclosure_handle =
-	    le16_to_cpu(sas_device_pg0.EnclosureHandle);
-	sas_device->slot =
-	    le16_to_cpu(sas_device_pg0.Slot);
-	sas_device->device_info = device_info;
-	sas_device->sas_address = sas_address;
-	sas_device->phy = sas_device_pg0.PhyNum;
-
-	/* get enclosure_logical_id */
-	if (sas_device->enclosure_handle && !(mpt2sas_config_get_enclosure_pg0(
-	   ioc, &mpi_reply, &enclosure_pg0, MPI2_SAS_ENCLOS_PGAD_FORM_HANDLE,
-	   sas_device->enclosure_handle)))
-		sas_device->enclosure_logical_id =
-		    le64_to_cpu(enclosure_pg0.EnclosureLogicalID);
-
-	/* get device name */
-	sas_device->device_name = le64_to_cpu(sas_device_pg0.DeviceName);
-
-	if (ioc->wait_for_discovery_to_complete)
-		_scsih_sas_device_init_add(ioc, sas_device);
-	else
-		_scsih_sas_device_add(ioc, sas_device);
-
-	return 0;
-}
-
-/**
- * _scsih_remove_device -  removing sas device object
- * @ioc: per adapter object
- * @sas_device_delete: the sas_device object
- *
- * Return nothing.
- */
-static void
-_scsih_remove_device(struct MPT2SAS_ADAPTER *ioc,
-    struct _sas_device *sas_device)
-{
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-
-	if ((ioc->pdev->subsystem_vendor == PCI_VENDOR_ID_IBM) &&
-		(sas_device->pfa_led_on)) {
-		_scsih_turn_off_pfa_led(ioc, sas_device);
-		sas_device->pfa_led_on = 0;
-	}
-
-	dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: enter: "
-	    "handle(0x%04x), sas_addr(0x%016llx)\n", ioc->name, __func__,
-		sas_device->handle, (unsigned long long)
-	    sas_device->sas_address));
-
-	if (sas_device->starget && sas_device->starget->hostdata) {
-		sas_target_priv_data = sas_device->starget->hostdata;
-		sas_target_priv_data->deleted = 1;
-		_scsih_ublock_io_device(ioc, sas_device->sas_address);
-		sas_target_priv_data->handle =
-		     MPT2SAS_INVALID_DEVICE_HANDLE;
-	}
-
-	if (!ioc->hide_drives)
-		mpt2sas_transport_port_remove(ioc,
-		    sas_device->sas_address,
-		    sas_device->sas_address_parent);
-
-	printk(MPT2SAS_INFO_FMT "removing handle(0x%04x), sas_addr"
-	    "(0x%016llx)\n", ioc->name, sas_device->handle,
-	    (unsigned long long) sas_device->sas_address);
-
-	dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: exit: "
-	    "handle(0x%04x), sas_addr(0x%016llx)\n", ioc->name, __func__,
-	    sas_device->handle, (unsigned long long)
-	    sas_device->sas_address));
-	kfree(sas_device);
-}
-/**
- * _scsih_device_remove_by_handle - removing device object by handle
- * @ioc: per adapter object
- * @handle: device handle
- *
- * Return nothing.
- */
-static void
-_scsih_device_remove_by_handle(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	struct _sas_device *sas_device;
-	unsigned long flags;
-
-	if (ioc->shost_recovery)
-		return;
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_device = _scsih_sas_device_find_by_handle(ioc, handle);
-	if (sas_device)
-		list_del(&sas_device->list);
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	if (sas_device)
-		_scsih_remove_device(ioc, sas_device);
-}
-
-/**
- * mpt2sas_device_remove_by_sas_address - removing device object by sas address
- * @ioc: per adapter object
- * @sas_address: device sas_address
- *
- * Return nothing.
- */
-void
-mpt2sas_device_remove_by_sas_address(struct MPT2SAS_ADAPTER *ioc,
-	u64 sas_address)
-{
-	struct _sas_device *sas_device;
-	unsigned long flags;
-
-	if (ioc->shost_recovery)
-		return;
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-	    sas_address);
-	if (sas_device)
-		list_del(&sas_device->list);
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	if (sas_device)
-		_scsih_remove_device(ioc, sas_device);
-}
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-/**
- * _scsih_sas_topology_change_event_debug - debug for topology event
- * @ioc: per adapter object
- * @event_data: event data payload
- * Context: user.
- */
-static void
-_scsih_sas_topology_change_event_debug(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventDataSasTopologyChangeList_t *event_data)
-{
-	int i;
-	u16 handle;
-	u16 reason_code;
-	u8 phy_number;
-	char *status_str = NULL;
-	u8 link_rate, prev_link_rate;
-
-	switch (event_data->ExpStatus) {
-	case MPI2_EVENT_SAS_TOPO_ES_ADDED:
-		status_str = "add";
-		break;
-	case MPI2_EVENT_SAS_TOPO_ES_NOT_RESPONDING:
-		status_str = "remove";
-		break;
-	case MPI2_EVENT_SAS_TOPO_ES_RESPONDING:
-	case 0:
-		status_str =  "responding";
-		break;
-	case MPI2_EVENT_SAS_TOPO_ES_DELAY_NOT_RESPONDING:
-		status_str = "remove delay";
-		break;
-	default:
-		status_str = "unknown status";
-		break;
-	}
-	printk(MPT2SAS_INFO_FMT "sas topology change: (%s)\n",
-	    ioc->name, status_str);
-	printk(KERN_INFO "\thandle(0x%04x), enclosure_handle(0x%04x) "
-	    "start_phy(%02d), count(%d)\n",
-	    le16_to_cpu(event_data->ExpanderDevHandle),
-	    le16_to_cpu(event_data->EnclosureHandle),
-	    event_data->StartPhyNum, event_data->NumEntries);
-	for (i = 0; i < event_data->NumEntries; i++) {
-		handle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);
-		if (!handle)
-			continue;
-		phy_number = event_data->StartPhyNum + i;
-		reason_code = event_data->PHY[i].PhyStatus &
-		    MPI2_EVENT_SAS_TOPO_RC_MASK;
-		switch (reason_code) {
-		case MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED:
-			status_str = "target add";
-			break;
-		case MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING:
-			status_str = "target remove";
-			break;
-		case MPI2_EVENT_SAS_TOPO_RC_DELAY_NOT_RESPONDING:
-			status_str = "delay target remove";
-			break;
-		case MPI2_EVENT_SAS_TOPO_RC_PHY_CHANGED:
-			status_str = "link rate change";
-			break;
-		case MPI2_EVENT_SAS_TOPO_RC_NO_CHANGE:
-			status_str = "target responding";
-			break;
-		default:
-			status_str = "unknown";
-			break;
-		}
-		link_rate = event_data->PHY[i].LinkRate >> 4;
-		prev_link_rate = event_data->PHY[i].LinkRate & 0xF;
-		printk(KERN_INFO "\tphy(%02d), attached_handle(0x%04x): %s:"
-		    " link rate: new(0x%02x), old(0x%02x)\n", phy_number,
-		    handle, status_str, link_rate, prev_link_rate);
-
-	}
-}
-#endif
-
-/**
- * _scsih_sas_topology_change_event - handle topology changes
- * @ioc: per adapter object
- * @fw_event: The fw_event_work object
- * Context: user.
- *
- */
-static void
-_scsih_sas_topology_change_event(struct MPT2SAS_ADAPTER *ioc,
-    struct fw_event_work *fw_event)
-{
-	int i;
-	u16 parent_handle, handle;
-	u16 reason_code;
-	u8 phy_number, max_phys;
-	struct _sas_node *sas_expander;
-	u64 sas_address;
-	unsigned long flags;
-	u8 link_rate, prev_link_rate;
-	Mpi2EventDataSasTopologyChangeList_t *event_data =
-		(Mpi2EventDataSasTopologyChangeList_t *)
-		fw_event->event_data;
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-	if (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)
-		_scsih_sas_topology_change_event_debug(ioc, event_data);
-#endif
-
-	if (ioc->remove_host || ioc->pci_error_recovery)
-		return;
-
-	if (!ioc->sas_hba.num_phys)
-		_scsih_sas_host_add(ioc);
-	else
-		_scsih_sas_host_refresh(ioc);
-
-	if (fw_event->ignore) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "ignoring expander "
-		    "event\n", ioc->name));
-		return;
-	}
-
-	parent_handle = le16_to_cpu(event_data->ExpanderDevHandle);
-
-	/* handle expander add */
-	if (event_data->ExpStatus == MPI2_EVENT_SAS_TOPO_ES_ADDED)
-		if (_scsih_expander_add(ioc, parent_handle) != 0)
-			return;
-
-	spin_lock_irqsave(&ioc->sas_node_lock, flags);
-	sas_expander = mpt2sas_scsih_expander_find_by_handle(ioc,
-	    parent_handle);
-	if (sas_expander) {
-		sas_address = sas_expander->sas_address;
-		max_phys = sas_expander->num_phys;
-	} else if (parent_handle < ioc->sas_hba.num_phys) {
-		sas_address = ioc->sas_hba.sas_address;
-		max_phys = ioc->sas_hba.num_phys;
-	} else {
-	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-		return;
-	}
-	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-
-	/* handle siblings events */
-	for (i = 0; i < event_data->NumEntries; i++) {
-		if (fw_event->ignore) {
-			dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "ignoring "
-			    "expander event\n", ioc->name));
-			return;
-		}
-		if (ioc->shost_recovery || ioc->remove_host ||
-		    ioc->pci_error_recovery)
-			return;
-		phy_number = event_data->StartPhyNum + i;
-		if (phy_number >= max_phys)
-			continue;
-		reason_code = event_data->PHY[i].PhyStatus &
-		    MPI2_EVENT_SAS_TOPO_RC_MASK;
-		if ((event_data->PHY[i].PhyStatus &
-		    MPI2_EVENT_SAS_TOPO_PHYSTATUS_VACANT) && (reason_code !=
-		    MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING))
-			continue;
-		handle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);
-		if (!handle)
-			continue;
-		link_rate = event_data->PHY[i].LinkRate >> 4;
-		prev_link_rate = event_data->PHY[i].LinkRate & 0xF;
-		switch (reason_code) {
-		case MPI2_EVENT_SAS_TOPO_RC_PHY_CHANGED:
-
-			if (ioc->shost_recovery)
-				break;
-
-			if (link_rate == prev_link_rate)
-				break;
-
-			mpt2sas_transport_update_links(ioc, sas_address,
-			    handle, phy_number, link_rate);
-
-			if (link_rate < MPI2_SAS_NEG_LINK_RATE_1_5)
-				break;
-
-			_scsih_check_device(ioc, handle);
-			break;
-		case MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED:
-
-			if (ioc->shost_recovery)
-				break;
-
-			mpt2sas_transport_update_links(ioc, sas_address,
-			    handle, phy_number, link_rate);
-
-			_scsih_add_device(ioc, handle, phy_number, 0);
-			break;
-		case MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING:
-
-			_scsih_device_remove_by_handle(ioc, handle);
-			break;
-		}
-	}
-
-	/* handle expander removal */
-	if (event_data->ExpStatus == MPI2_EVENT_SAS_TOPO_ES_NOT_RESPONDING &&
-	    sas_expander)
-		mpt2sas_expander_remove(ioc, sas_address);
-
-}
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-/**
- * _scsih_sas_device_status_change_event_debug - debug for device event
- * @event_data: event data payload
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_device_status_change_event_debug(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventDataSasDeviceStatusChange_t *event_data)
-{
-	char *reason_str = NULL;
-
-	switch (event_data->ReasonCode) {
-	case MPI2_EVENT_SAS_DEV_STAT_RC_SMART_DATA:
-		reason_str = "smart data";
-		break;
-	case MPI2_EVENT_SAS_DEV_STAT_RC_UNSUPPORTED:
-		reason_str = "unsupported device discovered";
-		break;
-	case MPI2_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET:
-		reason_str = "internal device reset";
-		break;
-	case MPI2_EVENT_SAS_DEV_STAT_RC_TASK_ABORT_INTERNAL:
-		reason_str = "internal task abort";
-		break;
-	case MPI2_EVENT_SAS_DEV_STAT_RC_ABORT_TASK_SET_INTERNAL:
-		reason_str = "internal task abort set";
-		break;
-	case MPI2_EVENT_SAS_DEV_STAT_RC_CLEAR_TASK_SET_INTERNAL:
-		reason_str = "internal clear task set";
-		break;
-	case MPI2_EVENT_SAS_DEV_STAT_RC_QUERY_TASK_INTERNAL:
-		reason_str = "internal query task";
-		break;
-	case MPI2_EVENT_SAS_DEV_STAT_RC_SATA_INIT_FAILURE:
-		reason_str = "sata init failure";
-		break;
-	case MPI2_EVENT_SAS_DEV_STAT_RC_CMP_INTERNAL_DEV_RESET:
-		reason_str = "internal device reset complete";
-		break;
-	case MPI2_EVENT_SAS_DEV_STAT_RC_CMP_TASK_ABORT_INTERNAL:
-		reason_str = "internal task abort complete";
-		break;
-	case MPI2_EVENT_SAS_DEV_STAT_RC_ASYNC_NOTIFICATION:
-		reason_str = "internal async notification";
-		break;
-	case MPI2_EVENT_SAS_DEV_STAT_RC_EXPANDER_REDUCED_FUNCTIONALITY:
-		reason_str = "expander reduced functionality";
-		break;
-	case MPI2_EVENT_SAS_DEV_STAT_RC_CMP_EXPANDER_REDUCED_FUNCTIONALITY:
-		reason_str = "expander reduced functionality complete";
-		break;
-	default:
-		reason_str = "unknown reason";
-		break;
-	}
-	printk(MPT2SAS_INFO_FMT "device status change: (%s)\n"
-	    "\thandle(0x%04x), sas address(0x%016llx), tag(%d)",
-	    ioc->name, reason_str, le16_to_cpu(event_data->DevHandle),
-	    (unsigned long long)le64_to_cpu(event_data->SASAddress),
-	    le16_to_cpu(event_data->TaskTag));
-	if (event_data->ReasonCode == MPI2_EVENT_SAS_DEV_STAT_RC_SMART_DATA)
-		printk(MPT2SAS_INFO_FMT ", ASC(0x%x), ASCQ(0x%x)\n", ioc->name,
-		    event_data->ASC, event_data->ASCQ);
-	printk(KERN_INFO "\n");
-}
-#endif
-
-/**
- * _scsih_sas_device_status_change_event - handle device status change
- * @ioc: per adapter object
- * @fw_event: The fw_event_work object
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_device_status_change_event(struct MPT2SAS_ADAPTER *ioc,
-    struct fw_event_work *fw_event)
-{
-	struct MPT2SAS_TARGET *target_priv_data;
-	struct _sas_device *sas_device;
-	u64 sas_address;
-	unsigned long flags;
-	Mpi2EventDataSasDeviceStatusChange_t *event_data =
-		(Mpi2EventDataSasDeviceStatusChange_t *)
-		fw_event->event_data;
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-	if (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)
-		_scsih_sas_device_status_change_event_debug(ioc,
-		     event_data);
-#endif
-
-	/* In MPI Revision K (0xC), the internal device reset complete was
-	 * implemented, so avoid setting tm_busy flag for older firmware.
-	 */
-	if ((ioc->facts.HeaderVersion >> 8) < 0xC)
-		return;
-
-	if (event_data->ReasonCode !=
-	    MPI2_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET &&
-	   event_data->ReasonCode !=
-	    MPI2_EVENT_SAS_DEV_STAT_RC_CMP_INTERNAL_DEV_RESET)
-		return;
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_address = le64_to_cpu(event_data->SASAddress);
-	sas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-	    sas_address);
-
-	if (!sas_device || !sas_device->starget) {
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-		return;
-	}
-
-	target_priv_data = sas_device->starget->hostdata;
-	if (!target_priv_data) {
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-		return;
-	}
-
-	if (event_data->ReasonCode ==
-	    MPI2_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET)
-		target_priv_data->tm_busy = 1;
-	else
-		target_priv_data->tm_busy = 0;
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-}
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-/**
- * _scsih_sas_enclosure_dev_status_change_event_debug - debug for enclosure event
- * @ioc: per adapter object
- * @event_data: event data payload
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_enclosure_dev_status_change_event_debug(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventDataSasEnclDevStatusChange_t *event_data)
-{
-	char *reason_str = NULL;
-
-	switch (event_data->ReasonCode) {
-	case MPI2_EVENT_SAS_ENCL_RC_ADDED:
-		reason_str = "enclosure add";
-		break;
-	case MPI2_EVENT_SAS_ENCL_RC_NOT_RESPONDING:
-		reason_str = "enclosure remove";
-		break;
-	default:
-		reason_str = "unknown reason";
-		break;
-	}
-
-	printk(MPT2SAS_INFO_FMT "enclosure status change: (%s)\n"
-	    "\thandle(0x%04x), enclosure logical id(0x%016llx)"
-	    " number slots(%d)\n", ioc->name, reason_str,
-	    le16_to_cpu(event_data->EnclosureHandle),
-	    (unsigned long long)le64_to_cpu(event_data->EnclosureLogicalID),
-	    le16_to_cpu(event_data->StartSlot));
-}
-#endif
-
-/**
- * _scsih_sas_enclosure_dev_status_change_event - handle enclosure events
- * @ioc: per adapter object
- * @fw_event: The fw_event_work object
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_enclosure_dev_status_change_event(struct MPT2SAS_ADAPTER *ioc,
-    struct fw_event_work *fw_event)
-{
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-	if (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)
-		_scsih_sas_enclosure_dev_status_change_event_debug(ioc,
-		     (Mpi2EventDataSasEnclDevStatusChange_t *)
-		     fw_event->event_data);
-#endif
-}
-
-/**
- * _scsih_sas_broadcast_primitive_event - handle broadcast events
- * @ioc: per adapter object
- * @fw_event: The fw_event_work object
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_broadcast_primitive_event(struct MPT2SAS_ADAPTER *ioc,
-    struct fw_event_work *fw_event)
-{
-	struct scsi_cmnd *scmd;
-	struct scsi_device *sdev;
-	u16 smid, handle;
-	u32 lun;
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	u32 termination_count;
-	u32 query_count;
-	Mpi2SCSITaskManagementReply_t *mpi_reply;
-	Mpi2EventDataSasBroadcastPrimitive_t *event_data =
-		(Mpi2EventDataSasBroadcastPrimitive_t *)
-		fw_event->event_data;
-	u16 ioc_status;
-	unsigned long flags;
-	int r;
-	u8 max_retries = 0;
-	u8 task_abort_retries;
-
-	mutex_lock(&ioc->tm_cmds.mutex);
-	pr_info(MPT2SAS_FMT
-		"%s: enter: phy number(%d), width(%d)\n",
-		ioc->name, __func__, event_data->PhyNum,
-		event_data->PortWidth);
-
-	_scsih_block_io_all_device(ioc);
-
-	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-	mpi_reply = ioc->tm_cmds.reply;
-broadcast_aen_retry:
-
-	/* sanity checks for retrying this loop */
-	if (max_retries++ == 5) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: giving up\n",
-		    ioc->name, __func__));
-		goto out;
-	} else if (max_retries > 1)
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: %d retry\n",
-		    ioc->name, __func__, max_retries - 1));
-
-	termination_count = 0;
-	query_count = 0;
-	for (smid = 1; smid <= ioc->scsiio_depth; smid++) {
-		if (ioc->shost_recovery)
-			goto out;
-		scmd = _scsih_scsi_lookup_get(ioc, smid);
-		if (!scmd)
-			continue;
-		sdev = scmd->device;
-		sas_device_priv_data = sdev->hostdata;
-		if (!sas_device_priv_data || !sas_device_priv_data->sas_target)
-			continue;
-		 /* skip hidden raid components */
-		if (sas_device_priv_data->sas_target->flags &
-		    MPT_TARGET_FLAGS_RAID_COMPONENT)
-			continue;
-		 /* skip volumes */
-		if (sas_device_priv_data->sas_target->flags &
-		    MPT_TARGET_FLAGS_VOLUME)
-			continue;
-
-		handle = sas_device_priv_data->sas_target->handle;
-		lun = sas_device_priv_data->lun;
-		query_count++;
-
-		if (ioc->shost_recovery)
-			goto out;
-
-		spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
-		r = mpt2sas_scsih_issue_tm(ioc, handle, 0, 0, lun,
-		    MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK, smid, 30,
-		    TM_MUTEX_OFF);
-		if (r == FAILED) {
-			sdev_printk(KERN_WARNING, sdev,
-			    "mpt2sas_scsih_issue_tm: FAILED when sending "
-			    "QUERY_TASK: scmd(%p)\n", scmd);
-			spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-			goto broadcast_aen_retry;
-		}
-		ioc_status = le16_to_cpu(mpi_reply->IOCStatus)
-		    & MPI2_IOCSTATUS_MASK;
-		if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-			sdev_printk(KERN_WARNING, sdev, "query task: FAILED "
-			    "with IOCSTATUS(0x%04x), scmd(%p)\n", ioc_status,
-			    scmd);
-			spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-			goto broadcast_aen_retry;
-		}
-
-		/* see if IO is still owned by IOC and target */
-		if (mpi_reply->ResponseCode ==
-		     MPI2_SCSITASKMGMT_RSP_TM_SUCCEEDED ||
-		     mpi_reply->ResponseCode ==
-		     MPI2_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC) {
-			spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-			continue;
-		}
-		task_abort_retries = 0;
- tm_retry:
-		if (task_abort_retries++ == 60) {
-			dewtprintk(ioc, printk(MPT2SAS_INFO_FMT
-			    "%s: ABORT_TASK: giving up\n", ioc->name,
-			    __func__));
-			spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-			goto broadcast_aen_retry;
-		}
-
-		if (ioc->shost_recovery)
-			goto out_no_lock;
-
-		r = mpt2sas_scsih_issue_tm(ioc, handle, sdev->channel, sdev->id,
-		    sdev->lun, MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK, smid, 30,
-		    TM_MUTEX_OFF);
-		if (r == FAILED) {
-			sdev_printk(KERN_WARNING, sdev,
-			    "mpt2sas_scsih_issue_tm: ABORT_TASK: FAILED : "
-			    "scmd(%p)\n", scmd);
-			goto tm_retry;
-		}
-
-		if (task_abort_retries > 1)
-			sdev_printk(KERN_WARNING, sdev,
-			    "mpt2sas_scsih_issue_tm: ABORT_TASK: RETRIES (%d):"
-			    " scmd(%p)\n",
-			    task_abort_retries - 1, scmd);
-
-		termination_count += le32_to_cpu(mpi_reply->TerminationCount);
-		spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-	}
-
-	if (ioc->broadcast_aen_pending) {
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: loop back due to"
-		     " pending AEN\n", ioc->name, __func__));
-		 ioc->broadcast_aen_pending = 0;
-		 goto broadcast_aen_retry;
-	}
-
- out:
-	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
- out_no_lock:
-
-	dewtprintk(ioc, printk(MPT2SAS_INFO_FMT
-	    "%s - exit, query_count = %d termination_count = %d\n",
-	    ioc->name, __func__, query_count, termination_count));
-
-	ioc->broadcast_aen_busy = 0;
-	if (!ioc->shost_recovery)
-		_scsih_ublock_io_all_device(ioc);
-	mutex_unlock(&ioc->tm_cmds.mutex);
-}
-
-/**
- * _scsih_sas_discovery_event - handle discovery events
- * @ioc: per adapter object
- * @fw_event: The fw_event_work object
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_discovery_event(struct MPT2SAS_ADAPTER *ioc,
-    struct fw_event_work *fw_event)
-{
-	Mpi2EventDataSasDiscovery_t *event_data =
-		(Mpi2EventDataSasDiscovery_t *)
-		fw_event->event_data;
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-	if (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK) {
-		printk(MPT2SAS_INFO_FMT "discovery event: (%s)", ioc->name,
-		    (event_data->ReasonCode == MPI2_EVENT_SAS_DISC_RC_STARTED) ?
-		    "start" : "stop");
-	if (event_data->DiscoveryStatus)
-		printk("discovery_status(0x%08x)",
-		    le32_to_cpu(event_data->DiscoveryStatus));
-	printk("\n");
-	}
-#endif
-
-	if (event_data->ReasonCode == MPI2_EVENT_SAS_DISC_RC_STARTED &&
-	    !ioc->sas_hba.num_phys) {
-		if (disable_discovery > 0 && ioc->shost_recovery) {
-			/* Wait for the reset to complete */
-			while (ioc->shost_recovery)
-				ssleep(1);
-		}
-		_scsih_sas_host_add(ioc);
-	}
-}
-
-/**
- * _scsih_reprobe_lun - reprobing lun
- * @sdev: scsi device struct
- * @no_uld_attach: sdev->no_uld_attach flag setting
- *
- **/
-static void
-_scsih_reprobe_lun(struct scsi_device *sdev, void *no_uld_attach)
-{
-	int rc;
-
-	sdev->no_uld_attach = no_uld_attach ? 1 : 0;
-	sdev_printk(KERN_INFO, sdev, "%s raid component\n",
-	    sdev->no_uld_attach ? "hidding" : "exposing");
-	rc = scsi_device_reprobe(sdev);
-}
-
-/**
- * _scsih_sas_volume_add - add new volume
- * @ioc: per adapter object
- * @element: IR config element data
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_volume_add(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventIrConfigElement_t *element)
-{
-	struct _raid_device *raid_device;
-	unsigned long flags;
-	u64 wwid;
-	u16 handle = le16_to_cpu(element->VolDevHandle);
-	int rc;
-
-	mpt2sas_config_get_volume_wwid(ioc, handle, &wwid);
-	if (!wwid) {
-		printk(MPT2SAS_ERR_FMT
-		    "failure at %s:%d/%s()!\n", ioc->name,
-		    __FILE__, __LINE__, __func__);
-		return;
-	}
-
-	spin_lock_irqsave(&ioc->raid_device_lock, flags);
-	raid_device = _scsih_raid_device_find_by_wwid(ioc, wwid);
-	spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-
-	if (raid_device)
-		return;
-
-	raid_device = kzalloc(sizeof(struct _raid_device), GFP_KERNEL);
-	if (!raid_device) {
-		printk(MPT2SAS_ERR_FMT
-		    "failure at %s:%d/%s()!\n", ioc->name,
-		    __FILE__, __LINE__, __func__);
-		return;
-	}
-
-	raid_device->id = ioc->sas_id++;
-	raid_device->channel = RAID_CHANNEL;
-	raid_device->handle = handle;
-	raid_device->wwid = wwid;
-	_scsih_raid_device_add(ioc, raid_device);
-	if (!ioc->wait_for_discovery_to_complete) {
-		rc = scsi_add_device(ioc->shost, RAID_CHANNEL,
-		    raid_device->id, 0);
-		if (rc)
-			_scsih_raid_device_remove(ioc, raid_device);
-	} else {
-		spin_lock_irqsave(&ioc->raid_device_lock, flags);
-		_scsih_determine_boot_device(ioc, raid_device, 1);
-		spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-	}
-}
-
-/**
- * _scsih_sas_volume_delete - delete volume
- * @ioc: per adapter object
- * @handle: volume device handle
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_volume_delete(struct MPT2SAS_ADAPTER *ioc, u16 handle)
-{
-	struct _raid_device *raid_device;
-	unsigned long flags;
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-	struct scsi_target *starget = NULL;
-
-	spin_lock_irqsave(&ioc->raid_device_lock, flags);
-	raid_device = _scsih_raid_device_find_by_handle(ioc, handle);
-	if (raid_device) {
-		if (raid_device->starget) {
-			starget = raid_device->starget;
-			sas_target_priv_data = starget->hostdata;
-			sas_target_priv_data->deleted = 1;
-		}
-		printk(MPT2SAS_INFO_FMT "removing handle(0x%04x), wwid"
-		    "(0x%016llx)\n", ioc->name,  raid_device->handle,
-		    (unsigned long long) raid_device->wwid);
-		list_del(&raid_device->list);
-		kfree(raid_device);
-	}
-	spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-	if (starget)
-		scsi_remove_target(&starget->dev);
-}
-
-/**
- * _scsih_sas_pd_expose - expose pd component to /dev/sdX
- * @ioc: per adapter object
- * @element: IR config element data
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_pd_expose(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventIrConfigElement_t *element)
-{
-	struct _sas_device *sas_device;
-	struct scsi_target *starget = NULL;
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-	unsigned long flags;
-	u16 handle = le16_to_cpu(element->PhysDiskDevHandle);
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_device = _scsih_sas_device_find_by_handle(ioc, handle);
-	if (sas_device) {
-		sas_device->volume_handle = 0;
-		sas_device->volume_wwid = 0;
-		clear_bit(handle, ioc->pd_handles);
-		if (sas_device->starget && sas_device->starget->hostdata) {
-			starget = sas_device->starget;
-			sas_target_priv_data = starget->hostdata;
-			sas_target_priv_data->flags &=
-			    ~MPT_TARGET_FLAGS_RAID_COMPONENT;
-		}
-	}
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	if (!sas_device)
-		return;
-
-	/* exposing raid component */
-	if (starget)
-		starget_for_each_device(starget, NULL, _scsih_reprobe_lun);
-}
-
-/**
- * _scsih_sas_pd_hide - hide pd component from /dev/sdX
- * @ioc: per adapter object
- * @element: IR config element data
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_pd_hide(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventIrConfigElement_t *element)
-{
-	struct _sas_device *sas_device;
-	struct scsi_target *starget = NULL;
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-	unsigned long flags;
-	u16 handle = le16_to_cpu(element->PhysDiskDevHandle);
-	u16 volume_handle = 0;
-	u64 volume_wwid = 0;
-
-	mpt2sas_config_get_volume_handle(ioc, handle, &volume_handle);
-	if (volume_handle)
-		mpt2sas_config_get_volume_wwid(ioc, volume_handle,
-		    &volume_wwid);
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_device = _scsih_sas_device_find_by_handle(ioc, handle);
-	if (sas_device) {
-		set_bit(handle, ioc->pd_handles);
-		if (sas_device->starget && sas_device->starget->hostdata) {
-			starget = sas_device->starget;
-			sas_target_priv_data = starget->hostdata;
-			sas_target_priv_data->flags |=
-			    MPT_TARGET_FLAGS_RAID_COMPONENT;
-			sas_device->volume_handle = volume_handle;
-			sas_device->volume_wwid = volume_wwid;
-		}
-	}
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	if (!sas_device)
-		return;
-
-	/* hiding raid component */
-	if (starget)
-		starget_for_each_device(starget, (void *)1, _scsih_reprobe_lun);
-}
-
-/**
- * _scsih_sas_pd_delete - delete pd component
- * @ioc: per adapter object
- * @element: IR config element data
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_pd_delete(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventIrConfigElement_t *element)
-{
-	u16 handle = le16_to_cpu(element->PhysDiskDevHandle);
-
-	_scsih_device_remove_by_handle(ioc, handle);
-}
-
-/**
- * _scsih_sas_pd_add - remove pd component
- * @ioc: per adapter object
- * @element: IR config element data
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_pd_add(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventIrConfigElement_t *element)
-{
-	struct _sas_device *sas_device;
-	unsigned long flags;
-	u16 handle = le16_to_cpu(element->PhysDiskDevHandle);
-	Mpi2ConfigReply_t mpi_reply;
-	Mpi2SasDevicePage0_t sas_device_pg0;
-	u32 ioc_status;
-	u64 sas_address;
-	u16 parent_handle;
-
-	set_bit(handle, ioc->pd_handles);
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_device = _scsih_sas_device_find_by_handle(ioc, handle);
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	if (sas_device)
-		return;
-
-	if ((mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,
-	    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return;
-	}
-
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-	    MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return;
-	}
-
-	parent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);
-	if (!_scsih_get_sas_address(ioc, parent_handle, &sas_address))
-		mpt2sas_transport_update_links(ioc, sas_address, handle,
-		    sas_device_pg0.PhyNum, MPI2_SAS_NEG_LINK_RATE_1_5);
-
-	_scsih_add_device(ioc, handle, 0, 1);
-}
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-/**
- * _scsih_sas_ir_config_change_event_debug - debug for IR Config Change events
- * @ioc: per adapter object
- * @event_data: event data payload
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_ir_config_change_event_debug(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventDataIrConfigChangeList_t *event_data)
-{
-	Mpi2EventIrConfigElement_t *element;
-	u8 element_type;
-	int i;
-	char *reason_str = NULL, *element_str = NULL;
-
-	element = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];
-
-	printk(MPT2SAS_INFO_FMT "raid config change: (%s), elements(%d)\n",
-	    ioc->name, (le32_to_cpu(event_data->Flags) &
-	    MPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG) ?
-	    "foreign" : "native", event_data->NumElements);
-	for (i = 0; i < event_data->NumElements; i++, element++) {
-		switch (element->ReasonCode) {
-		case MPI2_EVENT_IR_CHANGE_RC_ADDED:
-			reason_str = "add";
-			break;
-		case MPI2_EVENT_IR_CHANGE_RC_REMOVED:
-			reason_str = "remove";
-			break;
-		case MPI2_EVENT_IR_CHANGE_RC_NO_CHANGE:
-			reason_str = "no change";
-			break;
-		case MPI2_EVENT_IR_CHANGE_RC_HIDE:
-			reason_str = "hide";
-			break;
-		case MPI2_EVENT_IR_CHANGE_RC_UNHIDE:
-			reason_str = "unhide";
-			break;
-		case MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED:
-			reason_str = "volume_created";
-			break;
-		case MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED:
-			reason_str = "volume_deleted";
-			break;
-		case MPI2_EVENT_IR_CHANGE_RC_PD_CREATED:
-			reason_str = "pd_created";
-			break;
-		case MPI2_EVENT_IR_CHANGE_RC_PD_DELETED:
-			reason_str = "pd_deleted";
-			break;
-		default:
-			reason_str = "unknown reason";
-			break;
-		}
-		element_type = le16_to_cpu(element->ElementFlags) &
-		    MPI2_EVENT_IR_CHANGE_EFLAGS_ELEMENT_TYPE_MASK;
-		switch (element_type) {
-		case MPI2_EVENT_IR_CHANGE_EFLAGS_VOLUME_ELEMENT:
-			element_str = "volume";
-			break;
-		case MPI2_EVENT_IR_CHANGE_EFLAGS_VOLPHYSDISK_ELEMENT:
-			element_str = "phys disk";
-			break;
-		case MPI2_EVENT_IR_CHANGE_EFLAGS_HOTSPARE_ELEMENT:
-			element_str = "hot spare";
-			break;
-		default:
-			element_str = "unknown element";
-			break;
-		}
-		printk(KERN_INFO "\t(%s:%s), vol handle(0x%04x), "
-		    "pd handle(0x%04x), pd num(0x%02x)\n", element_str,
-		    reason_str, le16_to_cpu(element->VolDevHandle),
-		    le16_to_cpu(element->PhysDiskDevHandle),
-		    element->PhysDiskNum);
-	}
-}
-#endif
-
-/**
- * _scsih_sas_ir_config_change_event - handle ir configuration change events
- * @ioc: per adapter object
- * @fw_event: The fw_event_work object
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_ir_config_change_event(struct MPT2SAS_ADAPTER *ioc,
-    struct fw_event_work *fw_event)
-{
-	Mpi2EventIrConfigElement_t *element;
-	int i;
-	u8 foreign_config;
-	Mpi2EventDataIrConfigChangeList_t *event_data =
-		(Mpi2EventDataIrConfigChangeList_t *)
-		fw_event->event_data;
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-	if ((ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)
-	    && !ioc->hide_ir_msg)
-		_scsih_sas_ir_config_change_event_debug(ioc, event_data);
-
-#endif
-
-	if (ioc->shost_recovery)
-		return;
-
-	foreign_config = (le32_to_cpu(event_data->Flags) &
-	    MPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG) ? 1 : 0;
-
-	element = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];
-	for (i = 0; i < event_data->NumElements; i++, element++) {
-
-		switch (element->ReasonCode) {
-		case MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED:
-		case MPI2_EVENT_IR_CHANGE_RC_ADDED:
-			if (!foreign_config)
-				_scsih_sas_volume_add(ioc, element);
-			break;
-		case MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED:
-		case MPI2_EVENT_IR_CHANGE_RC_REMOVED:
-			if (!foreign_config)
-				_scsih_sas_volume_delete(ioc,
-				    le16_to_cpu(element->VolDevHandle));
-			break;
-		case MPI2_EVENT_IR_CHANGE_RC_PD_CREATED:
-			if (!ioc->is_warpdrive)
-				_scsih_sas_pd_hide(ioc, element);
-			break;
-		case MPI2_EVENT_IR_CHANGE_RC_PD_DELETED:
-			if (!ioc->is_warpdrive)
-				_scsih_sas_pd_expose(ioc, element);
-			break;
-		case MPI2_EVENT_IR_CHANGE_RC_HIDE:
-			if (!ioc->is_warpdrive)
-				_scsih_sas_pd_add(ioc, element);
-			break;
-		case MPI2_EVENT_IR_CHANGE_RC_UNHIDE:
-			if (!ioc->is_warpdrive)
-				_scsih_sas_pd_delete(ioc, element);
-			break;
-		}
-	}
-}
-
-/**
- * _scsih_sas_ir_volume_event - IR volume event
- * @ioc: per adapter object
- * @fw_event: The fw_event_work object
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_ir_volume_event(struct MPT2SAS_ADAPTER *ioc,
-    struct fw_event_work *fw_event)
-{
-	u64 wwid;
-	unsigned long flags;
-	struct _raid_device *raid_device;
-	u16 handle;
-	u32 state;
-	int rc;
-	Mpi2EventDataIrVolume_t *event_data =
-		(Mpi2EventDataIrVolume_t *)
-		fw_event->event_data;
-
-	if (ioc->shost_recovery)
-		return;
-
-	if (event_data->ReasonCode != MPI2_EVENT_IR_VOLUME_RC_STATE_CHANGED)
-		return;
-
-	handle = le16_to_cpu(event_data->VolDevHandle);
-	state = le32_to_cpu(event_data->NewValue);
-	if (!ioc->hide_ir_msg)
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: handle(0x%04x), "
-		    "old(0x%08x), new(0x%08x)\n", ioc->name, __func__,  handle,
-		    le32_to_cpu(event_data->PreviousValue), state));
-
-	switch (state) {
-	case MPI2_RAID_VOL_STATE_MISSING:
-	case MPI2_RAID_VOL_STATE_FAILED:
-		_scsih_sas_volume_delete(ioc, handle);
-		break;
-
-	case MPI2_RAID_VOL_STATE_ONLINE:
-	case MPI2_RAID_VOL_STATE_DEGRADED:
-	case MPI2_RAID_VOL_STATE_OPTIMAL:
-
-		spin_lock_irqsave(&ioc->raid_device_lock, flags);
-		raid_device = _scsih_raid_device_find_by_handle(ioc, handle);
-		spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-
-		if (raid_device)
-			break;
-
-		mpt2sas_config_get_volume_wwid(ioc, handle, &wwid);
-		if (!wwid) {
-			printk(MPT2SAS_ERR_FMT
-			    "failure at %s:%d/%s()!\n", ioc->name,
-			    __FILE__, __LINE__, __func__);
-			break;
-		}
-
-		raid_device = kzalloc(sizeof(struct _raid_device), GFP_KERNEL);
-		if (!raid_device) {
-			printk(MPT2SAS_ERR_FMT
-			    "failure at %s:%d/%s()!\n", ioc->name,
-			    __FILE__, __LINE__, __func__);
-			break;
-		}
-
-		raid_device->id = ioc->sas_id++;
-		raid_device->channel = RAID_CHANNEL;
-		raid_device->handle = handle;
-		raid_device->wwid = wwid;
-		_scsih_raid_device_add(ioc, raid_device);
-		rc = scsi_add_device(ioc->shost, RAID_CHANNEL,
-		    raid_device->id, 0);
-		if (rc)
-			_scsih_raid_device_remove(ioc, raid_device);
-		break;
-
-	case MPI2_RAID_VOL_STATE_INITIALIZING:
-	default:
-		break;
-	}
-}
-
-/**
- * _scsih_sas_ir_physical_disk_event - PD event
- * @ioc: per adapter object
- * @fw_event: The fw_event_work object
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_ir_physical_disk_event(struct MPT2SAS_ADAPTER *ioc,
-    struct fw_event_work *fw_event)
-{
-	u16 handle, parent_handle;
-	u32 state;
-	struct _sas_device *sas_device;
-	unsigned long flags;
-	Mpi2ConfigReply_t mpi_reply;
-	Mpi2SasDevicePage0_t sas_device_pg0;
-	u32 ioc_status;
-	Mpi2EventDataIrPhysicalDisk_t *event_data =
-		(Mpi2EventDataIrPhysicalDisk_t *)
-		fw_event->event_data;
-	u64 sas_address;
-
-	if (ioc->shost_recovery)
-		return;
-
-	if (event_data->ReasonCode != MPI2_EVENT_IR_PHYSDISK_RC_STATE_CHANGED)
-		return;
-
-	handle = le16_to_cpu(event_data->PhysDiskDevHandle);
-	state = le32_to_cpu(event_data->NewValue);
-
-	if (!ioc->hide_ir_msg)
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: handle(0x%04x), "
-		    "old(0x%08x), new(0x%08x)\n", ioc->name, __func__,  handle,
-		    le32_to_cpu(event_data->PreviousValue), state));
-
-	switch (state) {
-	case MPI2_RAID_PD_STATE_ONLINE:
-	case MPI2_RAID_PD_STATE_DEGRADED:
-	case MPI2_RAID_PD_STATE_REBUILDING:
-	case MPI2_RAID_PD_STATE_OPTIMAL:
-	case MPI2_RAID_PD_STATE_HOT_SPARE:
-
-		if (!ioc->is_warpdrive)
-			set_bit(handle, ioc->pd_handles);
-
-		spin_lock_irqsave(&ioc->sas_device_lock, flags);
-		sas_device = _scsih_sas_device_find_by_handle(ioc, handle);
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-
-		if (sas_device)
-			return;
-
-		if ((mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply,
-		    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_HANDLE,
-		    handle))) {
-			printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-			    ioc->name, __FILE__, __LINE__, __func__);
-			return;
-		}
-
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-		    MPI2_IOCSTATUS_MASK;
-		if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-			printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-			    ioc->name, __FILE__, __LINE__, __func__);
-			return;
-		}
-
-		parent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);
-		if (!_scsih_get_sas_address(ioc, parent_handle, &sas_address))
-			mpt2sas_transport_update_links(ioc, sas_address, handle,
-			    sas_device_pg0.PhyNum, MPI2_SAS_NEG_LINK_RATE_1_5);
-
-		_scsih_add_device(ioc, handle, 0, 1);
-
-		break;
-
-	case MPI2_RAID_PD_STATE_OFFLINE:
-	case MPI2_RAID_PD_STATE_NOT_CONFIGURED:
-	case MPI2_RAID_PD_STATE_NOT_COMPATIBLE:
-	default:
-		break;
-	}
-}
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-/**
- * _scsih_sas_ir_operation_status_event_debug - debug for IR op event
- * @ioc: per adapter object
- * @event_data: event data payload
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_ir_operation_status_event_debug(struct MPT2SAS_ADAPTER *ioc,
-    Mpi2EventDataIrOperationStatus_t *event_data)
-{
-	char *reason_str = NULL;
-
-	switch (event_data->RAIDOperation) {
-	case MPI2_EVENT_IR_RAIDOP_RESYNC:
-		reason_str = "resync";
-		break;
-	case MPI2_EVENT_IR_RAIDOP_ONLINE_CAP_EXPANSION:
-		reason_str = "online capacity expansion";
-		break;
-	case MPI2_EVENT_IR_RAIDOP_CONSISTENCY_CHECK:
-		reason_str = "consistency check";
-		break;
-	case MPI2_EVENT_IR_RAIDOP_BACKGROUND_INIT:
-		reason_str = "background init";
-		break;
-	case MPI2_EVENT_IR_RAIDOP_MAKE_DATA_CONSISTENT:
-		reason_str = "make data consistent";
-		break;
-	}
-
-	if (!reason_str)
-		return;
-
-	printk(MPT2SAS_INFO_FMT "raid operational status: (%s)"
-	    "\thandle(0x%04x), percent complete(%d)\n",
-	    ioc->name, reason_str,
-	    le16_to_cpu(event_data->VolDevHandle),
-	    event_data->PercentComplete);
-}
-#endif
-
-/**
- * _scsih_sas_ir_operation_status_event - handle RAID operation events
- * @ioc: per adapter object
- * @fw_event: The fw_event_work object
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_scsih_sas_ir_operation_status_event(struct MPT2SAS_ADAPTER *ioc,
-    struct fw_event_work *fw_event)
-{
-	Mpi2EventDataIrOperationStatus_t *event_data =
-		(Mpi2EventDataIrOperationStatus_t *)
-		fw_event->event_data;
-	static struct _raid_device *raid_device;
-	unsigned long flags;
-	u16 handle;
-
-#ifdef CONFIG_SCSI_MPT2SAS_LOGGING
-	if ((ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)
-	    && !ioc->hide_ir_msg)
-		_scsih_sas_ir_operation_status_event_debug(ioc,
-		     event_data);
-#endif
-
-	/* code added for raid transport support */
-	if (event_data->RAIDOperation == MPI2_EVENT_IR_RAIDOP_RESYNC) {
-
-		spin_lock_irqsave(&ioc->raid_device_lock, flags);
-		handle = le16_to_cpu(event_data->VolDevHandle);
-		raid_device = _scsih_raid_device_find_by_handle(ioc, handle);
-		if (raid_device)
-			raid_device->percent_complete =
-			    event_data->PercentComplete;
-		spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-	}
-}
-
-/**
- * _scsih_prep_device_scan - initialize parameters prior to device scan
- * @ioc: per adapter object
- *
- * Set the deleted flag prior to device scan.  If the device is found during
- * the scan, then we clear the deleted flag.
- */
-static void
-_scsih_prep_device_scan(struct MPT2SAS_ADAPTER *ioc)
-{
-	struct MPT2SAS_DEVICE *sas_device_priv_data;
-	struct scsi_device *sdev;
-
-	shost_for_each_device(sdev, ioc->shost) {
-		sas_device_priv_data = sdev->hostdata;
-		if (sas_device_priv_data && sas_device_priv_data->sas_target)
-			sas_device_priv_data->sas_target->deleted = 1;
-	}
-}
-
-/**
- * _scsih_mark_responding_sas_device - mark a sas_devices as responding
- * @ioc: per adapter object
- * @sas_address: sas address
- * @slot: enclosure slot id
- * @handle: device handle
- *
- * After host reset, find out whether devices are still responding.
- * Used in _scsi_remove_unresponsive_sas_devices.
- *
- * Return nothing.
- */
-static void
-_scsih_mark_responding_sas_device(struct MPT2SAS_ADAPTER *ioc, u64 sas_address,
-    u16 slot, u16 handle)
-{
-	struct MPT2SAS_TARGET *sas_target_priv_data = NULL;
-	struct scsi_target *starget;
-	struct _sas_device *sas_device;
-	unsigned long flags;
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	list_for_each_entry(sas_device, &ioc->sas_device_list, list) {
-		if (sas_device->sas_address == sas_address &&
-		    sas_device->slot == slot) {
-			sas_device->responding = 1;
-			starget = sas_device->starget;
-			if (starget && starget->hostdata) {
-				sas_target_priv_data = starget->hostdata;
-				sas_target_priv_data->tm_busy = 0;
-				sas_target_priv_data->deleted = 0;
-			} else
-				sas_target_priv_data = NULL;
-			if (starget)
-				starget_printk(KERN_INFO, starget,
-				    "handle(0x%04x), sas_addr(0x%016llx), "
-				    "enclosure logical id(0x%016llx), "
-				    "slot(%d)\n", handle,
-				    (unsigned long long)sas_device->sas_address,
-				    (unsigned long long)
-				    sas_device->enclosure_logical_id,
-				    sas_device->slot);
-			if (sas_device->handle == handle)
-				goto out;
-			printk(KERN_INFO "\thandle changed from(0x%04x)!!!\n",
-			    sas_device->handle);
-			sas_device->handle = handle;
-			if (sas_target_priv_data)
-				sas_target_priv_data->handle = handle;
-			goto out;
-		}
-	}
- out:
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-}
-
-/**
- * _scsih_search_responding_sas_devices -
- * @ioc: per adapter object
- *
- * After host reset, find out whether devices are still responding.
- * If not remove.
- *
- * Return nothing.
- */
-static void
-_scsih_search_responding_sas_devices(struct MPT2SAS_ADAPTER *ioc)
-{
-	Mpi2SasDevicePage0_t sas_device_pg0;
-	Mpi2ConfigReply_t mpi_reply;
-	u16 ioc_status;
-	__le64 sas_address;
-	u16 handle;
-	u32 device_info;
-	u16 slot;
-
-	printk(MPT2SAS_INFO_FMT "search for end-devices: start\n", ioc->name);
-
-	if (list_empty(&ioc->sas_device_list))
-		goto out;
-
-	handle = 0xFFFF;
-	while (!(mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply,
-	    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE,
-	    handle))) {
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-		    MPI2_IOCSTATUS_MASK;
-		if (ioc_status != MPI2_IOCSTATUS_SUCCESS)
-			break;
-		handle = le16_to_cpu(sas_device_pg0.DevHandle);
-		device_info = le32_to_cpu(sas_device_pg0.DeviceInfo);
-		if (!(_scsih_is_end_device(device_info)))
-			continue;
-		sas_address = le64_to_cpu(sas_device_pg0.SASAddress);
-		slot = le16_to_cpu(sas_device_pg0.Slot);
-		_scsih_mark_responding_sas_device(ioc, sas_address, slot,
-		    handle);
-	}
-out:
-	printk(MPT2SAS_INFO_FMT "search for end-devices: complete\n",
-	    ioc->name);
-}
-
-/**
- * _scsih_mark_responding_raid_device - mark a raid_device as responding
- * @ioc: per adapter object
- * @wwid: world wide identifier for raid volume
- * @handle: device handle
- *
- * After host reset, find out whether devices are still responding.
- * Used in _scsi_remove_unresponsive_raid_devices.
- *
- * Return nothing.
- */
-static void
-_scsih_mark_responding_raid_device(struct MPT2SAS_ADAPTER *ioc, u64 wwid,
-    u16 handle)
-{
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-	struct scsi_target *starget;
-	struct _raid_device *raid_device;
-	unsigned long flags;
-
-	spin_lock_irqsave(&ioc->raid_device_lock, flags);
-	list_for_each_entry(raid_device, &ioc->raid_device_list, list) {
-		if (raid_device->wwid == wwid && raid_device->starget) {
-			starget = raid_device->starget;
-			if (starget && starget->hostdata) {
-				sas_target_priv_data = starget->hostdata;
-				sas_target_priv_data->deleted = 0;
-			} else
-				sas_target_priv_data = NULL;
-			raid_device->responding = 1;
-			spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-			starget_printk(KERN_INFO, raid_device->starget,
-			    "handle(0x%04x), wwid(0x%016llx)\n", handle,
-			    (unsigned long long)raid_device->wwid);
-			/*
-			 * WARPDRIVE: The handles of the PDs might have changed
-			 * across the host reset so re-initialize the
-			 * required data for Direct IO
-			 */
-			_scsih_init_warpdrive_properties(ioc, raid_device);
-			spin_lock_irqsave(&ioc->raid_device_lock, flags);
-			if (raid_device->handle == handle) {
-				spin_unlock_irqrestore(&ioc->raid_device_lock,
-				    flags);
-				return;
-			}
-			printk(KERN_INFO "\thandle changed from(0x%04x)!!!\n",
-			    raid_device->handle);
-			raid_device->handle = handle;
-			if (sas_target_priv_data)
-				sas_target_priv_data->handle = handle;
-			spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-			return;
-		}
-	}
-
-	spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-}
-
-/**
- * _scsih_search_responding_raid_devices -
- * @ioc: per adapter object
- *
- * After host reset, find out whether devices are still responding.
- * If not remove.
- *
- * Return nothing.
- */
-static void
-_scsih_search_responding_raid_devices(struct MPT2SAS_ADAPTER *ioc)
-{
-	Mpi2RaidVolPage1_t volume_pg1;
-	Mpi2RaidVolPage0_t volume_pg0;
-	Mpi2RaidPhysDiskPage0_t pd_pg0;
-	Mpi2ConfigReply_t mpi_reply;
-	u16 ioc_status;
-	u16 handle;
-	u8 phys_disk_num;
-
-	if (!ioc->ir_firmware)
-		return;
-
-	printk(MPT2SAS_INFO_FMT "search for raid volumes: start\n",
-	    ioc->name);
-
-	if (list_empty(&ioc->raid_device_list))
-		goto out;
-
-	handle = 0xFFFF;
-	while (!(mpt2sas_config_get_raid_volume_pg1(ioc, &mpi_reply,
-	    &volume_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-		    MPI2_IOCSTATUS_MASK;
-		if (ioc_status != MPI2_IOCSTATUS_SUCCESS)
-			break;
-		handle = le16_to_cpu(volume_pg1.DevHandle);
-
-		if (mpt2sas_config_get_raid_volume_pg0(ioc, &mpi_reply,
-		    &volume_pg0, MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,
-		     sizeof(Mpi2RaidVolPage0_t)))
-			continue;
-
-		if (volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_OPTIMAL ||
-		    volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_ONLINE ||
-		    volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_DEGRADED)
-			_scsih_mark_responding_raid_device(ioc,
-			    le64_to_cpu(volume_pg1.WWID), handle);
-	}
-
-	/* refresh the pd_handles */
-	if (!ioc->is_warpdrive) {
-		phys_disk_num = 0xFF;
-		memset(ioc->pd_handles, 0, ioc->pd_handles_sz);
-		while (!(mpt2sas_config_get_phys_disk_pg0(ioc, &mpi_reply,
-		    &pd_pg0, MPI2_PHYSDISK_PGAD_FORM_GET_NEXT_PHYSDISKNUM,
-		    phys_disk_num))) {
-			ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-			    MPI2_IOCSTATUS_MASK;
-			if (ioc_status != MPI2_IOCSTATUS_SUCCESS)
-				break;
-			phys_disk_num = pd_pg0.PhysDiskNum;
-			handle = le16_to_cpu(pd_pg0.DevHandle);
-			set_bit(handle, ioc->pd_handles);
-		}
-	}
-out:
-	printk(MPT2SAS_INFO_FMT "search for responding raid volumes: "
-	    "complete\n", ioc->name);
-}
-
-/**
- * _scsih_mark_responding_expander - mark a expander as responding
- * @ioc: per adapter object
- * @sas_address: sas address
- * @handle:
- *
- * After host reset, find out whether devices are still responding.
- * Used in _scsi_remove_unresponsive_expanders.
- *
- * Return nothing.
- */
-static void
-_scsih_mark_responding_expander(struct MPT2SAS_ADAPTER *ioc, u64 sas_address,
-     u16 handle)
-{
-	struct _sas_node *sas_expander;
-	unsigned long flags;
-	int i;
-
-	spin_lock_irqsave(&ioc->sas_node_lock, flags);
-	list_for_each_entry(sas_expander, &ioc->sas_expander_list, list) {
-		if (sas_expander->sas_address != sas_address)
-			continue;
-		sas_expander->responding = 1;
-		if (sas_expander->handle == handle)
-			goto out;
-		printk(KERN_INFO "\texpander(0x%016llx): handle changed"
-		    " from(0x%04x) to (0x%04x)!!!\n",
-		    (unsigned long long)sas_expander->sas_address,
-		    sas_expander->handle, handle);
-		sas_expander->handle = handle;
-		for (i = 0 ; i < sas_expander->num_phys ; i++)
-			sas_expander->phy[i].handle = handle;
-		goto out;
-	}
- out:
-	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-}
-
-/**
- * _scsih_search_responding_expanders -
- * @ioc: per adapter object
- *
- * After host reset, find out whether devices are still responding.
- * If not remove.
- *
- * Return nothing.
- */
-static void
-_scsih_search_responding_expanders(struct MPT2SAS_ADAPTER *ioc)
-{
-	Mpi2ExpanderPage0_t expander_pg0;
-	Mpi2ConfigReply_t mpi_reply;
-	u16 ioc_status;
-	u64 sas_address;
-	u16 handle;
-
-	printk(MPT2SAS_INFO_FMT "search for expanders: start\n", ioc->name);
-
-	if (list_empty(&ioc->sas_expander_list))
-		goto out;
-
-	handle = 0xFFFF;
-	while (!(mpt2sas_config_get_expander_pg0(ioc, &mpi_reply, &expander_pg0,
-	    MPI2_SAS_EXPAND_PGAD_FORM_GET_NEXT_HNDL, handle))) {
-
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-		    MPI2_IOCSTATUS_MASK;
-		if (ioc_status != MPI2_IOCSTATUS_SUCCESS)
-			break;
-
-		handle = le16_to_cpu(expander_pg0.DevHandle);
-		sas_address = le64_to_cpu(expander_pg0.SASAddress);
-		printk(KERN_INFO "\texpander present: handle(0x%04x), "
-		    "sas_addr(0x%016llx)\n", handle,
-		    (unsigned long long)sas_address);
-		_scsih_mark_responding_expander(ioc, sas_address, handle);
-	}
-
- out:
-	printk(MPT2SAS_INFO_FMT "search for expanders: complete\n", ioc->name);
-}
-
-/**
- * _scsih_remove_unresponding_sas_devices - removing unresponding devices
- * @ioc: per adapter object
- *
- * Return nothing.
- */
-static void
-_scsih_remove_unresponding_sas_devices(struct MPT2SAS_ADAPTER *ioc)
-{
-	struct _sas_device *sas_device, *sas_device_next;
-	struct _sas_node *sas_expander, *sas_expander_next;
-	struct _raid_device *raid_device, *raid_device_next;
-	struct list_head tmp_list;
-	unsigned long flags;
-
-	printk(MPT2SAS_INFO_FMT "removing unresponding devices: start\n",
-	    ioc->name);
-
-	/* removing unresponding end devices */
-	printk(MPT2SAS_INFO_FMT "removing unresponding devices: end-devices\n",
-	    ioc->name);
-	list_for_each_entry_safe(sas_device, sas_device_next,
-	    &ioc->sas_device_list, list) {
-		if (!sas_device->responding)
-			mpt2sas_device_remove_by_sas_address(ioc,
-				sas_device->sas_address);
-		else
-			sas_device->responding = 0;
-	}
-
-	/* removing unresponding volumes */
-	if (ioc->ir_firmware) {
-		printk(MPT2SAS_INFO_FMT "removing unresponding devices: "
-		    "volumes\n", ioc->name);
-		list_for_each_entry_safe(raid_device, raid_device_next,
-		    &ioc->raid_device_list, list) {
-			if (!raid_device->responding)
-				_scsih_sas_volume_delete(ioc,
-				    raid_device->handle);
-			else
-				raid_device->responding = 0;
-		}
-	}
-	/* removing unresponding expanders */
-	printk(MPT2SAS_INFO_FMT "removing unresponding devices: expanders\n",
-	    ioc->name);
-	spin_lock_irqsave(&ioc->sas_node_lock, flags);
-	INIT_LIST_HEAD(&tmp_list);
-	list_for_each_entry_safe(sas_expander, sas_expander_next,
-	    &ioc->sas_expander_list, list) {
-		if (!sas_expander->responding)
-			list_move_tail(&sas_expander->list, &tmp_list);
-		else
-			sas_expander->responding = 0;
-	}
-	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-	list_for_each_entry_safe(sas_expander, sas_expander_next, &tmp_list,
-	    list) {
-		list_del(&sas_expander->list);
-		_scsih_expander_node_remove(ioc, sas_expander);
-	}
-	printk(MPT2SAS_INFO_FMT "removing unresponding devices: complete\n",
-	    ioc->name);
-	/* unblock devices */
-	_scsih_ublock_io_all_device(ioc);
-}
-
-static void
-_scsih_refresh_expander_links(struct MPT2SAS_ADAPTER *ioc,
-	struct _sas_node *sas_expander, u16 handle)
-{
-	Mpi2ExpanderPage1_t expander_pg1;
-	Mpi2ConfigReply_t mpi_reply;
-	int i;
-
-	for (i = 0 ; i < sas_expander->num_phys ; i++) {
-		if ((mpt2sas_config_get_expander_pg1(ioc, &mpi_reply,
-		    &expander_pg1, i, handle))) {
-			printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-			    ioc->name, __FILE__, __LINE__, __func__);
-			return;
-		}
-
-		mpt2sas_transport_update_links(ioc, sas_expander->sas_address,
-		    le16_to_cpu(expander_pg1.AttachedDevHandle), i,
-		    expander_pg1.NegotiatedLinkRate >> 4);
-	}
-}
-
-/**
- * _scsih_scan_for_devices_after_reset - scan for devices after host reset
- * @ioc: per adapter object
- *
- * Return nothing.
- */
-static void
-_scsih_scan_for_devices_after_reset(struct MPT2SAS_ADAPTER *ioc)
-{
-	Mpi2ExpanderPage0_t expander_pg0;
-	Mpi2SasDevicePage0_t sas_device_pg0;
-	Mpi2RaidVolPage1_t volume_pg1;
-	Mpi2RaidVolPage0_t volume_pg0;
-	Mpi2RaidPhysDiskPage0_t pd_pg0;
-	Mpi2EventIrConfigElement_t element;
-	Mpi2ConfigReply_t mpi_reply;
-	u8 phys_disk_num;
-	u16 ioc_status;
-	u16 handle, parent_handle;
-	u64 sas_address;
-	struct _sas_device *sas_device;
-	struct _sas_node *expander_device;
-	static struct _raid_device *raid_device;
-	u8 retry_count;
-	unsigned long flags;
-
-	printk(MPT2SAS_INFO_FMT "scan devices: start\n", ioc->name);
-
-	_scsih_sas_host_refresh(ioc);
-
-	printk(MPT2SAS_INFO_FMT "\tscan devices: expanders start\n",
-		ioc->name);
-	/* expanders */
-	handle = 0xFFFF;
-	while (!(mpt2sas_config_get_expander_pg0(ioc, &mpi_reply, &expander_pg0,
-	    MPI2_SAS_EXPAND_PGAD_FORM_GET_NEXT_HNDL, handle))) {
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-		    MPI2_IOCSTATUS_MASK;
-		if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-			printk(MPT2SAS_INFO_FMT "\tbreak from expander scan: "
-				"ioc_status(0x%04x), loginfo(0x%08x)\n",
-				ioc->name, ioc_status,
-				le32_to_cpu(mpi_reply.IOCLogInfo));
-			break;
-		}
-		handle = le16_to_cpu(expander_pg0.DevHandle);
-		spin_lock_irqsave(&ioc->sas_node_lock, flags);
-		expander_device = mpt2sas_scsih_expander_find_by_sas_address(
-		    ioc, le64_to_cpu(expander_pg0.SASAddress));
-		spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-		if (expander_device)
-			_scsih_refresh_expander_links(ioc, expander_device,
-			    handle);
-		else {
-			printk(MPT2SAS_INFO_FMT "\tBEFORE adding expander: "
-				"handle (0x%04x), sas_addr(0x%016llx)\n",
-				ioc->name, handle, (unsigned long long)
-				le64_to_cpu(expander_pg0.SASAddress));
-			_scsih_expander_add(ioc, handle);
-			printk(MPT2SAS_INFO_FMT "\tAFTER adding expander: "
-				"handle (0x%04x), sas_addr(0x%016llx)\n",
-				ioc->name, handle, (unsigned long long)
-				le64_to_cpu(expander_pg0.SASAddress));
-		}
-	}
-
-	printk(MPT2SAS_INFO_FMT "\tscan devices: expanders complete\n",
-		ioc->name);
-
-	if (!ioc->ir_firmware)
-		goto skip_to_sas;
-
-	printk(MPT2SAS_INFO_FMT "\tscan devices phys disk start\n", ioc->name);
-	/* phys disk */
-	phys_disk_num = 0xFF;
-	while (!(mpt2sas_config_get_phys_disk_pg0(ioc, &mpi_reply,
-	    &pd_pg0, MPI2_PHYSDISK_PGAD_FORM_GET_NEXT_PHYSDISKNUM,
-	    phys_disk_num))) {
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-		    MPI2_IOCSTATUS_MASK;
-		if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-			printk(MPT2SAS_INFO_FMT "\tbreak from phys disk scan:"
-				"ioc_status(0x%04x), loginfo(0x%08x)\n",
-				ioc->name, ioc_status,
-				le32_to_cpu(mpi_reply.IOCLogInfo));
-			break;
-		}
-		phys_disk_num = pd_pg0.PhysDiskNum;
-		handle = le16_to_cpu(pd_pg0.DevHandle);
-		spin_lock_irqsave(&ioc->sas_device_lock, flags);
-		sas_device = _scsih_sas_device_find_by_handle(ioc, handle);
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-		if (sas_device)
-			continue;
-		if (mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply,
-		    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_HANDLE,
-		    handle) != 0)
-			continue;
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-			MPI2_IOCSTATUS_MASK;
-		if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-			printk(MPT2SAS_INFO_FMT "\tbreak from phys disk scan "
-				"ioc_status(0x%04x), loginfo(0x%08x)\n",
-				ioc->name, ioc_status,
-				le32_to_cpu(mpi_reply.IOCLogInfo));
-			break;
-		}
-		parent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);
-		if (!_scsih_get_sas_address(ioc, parent_handle,
-		    &sas_address)) {
-			printk(MPT2SAS_INFO_FMT "\tBEFORE adding phys disk: "
-				" handle (0x%04x), sas_addr(0x%016llx)\n",
-				ioc->name, handle, (unsigned long long)
-				le64_to_cpu(sas_device_pg0.SASAddress));
-			mpt2sas_transport_update_links(ioc, sas_address,
-			    handle, sas_device_pg0.PhyNum,
-			    MPI2_SAS_NEG_LINK_RATE_1_5);
-			set_bit(handle, ioc->pd_handles);
-			retry_count = 0;
-			/* This will retry adding the end device.
-			* _scsih_add_device() will decide on retries and
-			* return "1" when it should be retried
-			*/
-			while (_scsih_add_device(ioc, handle, retry_count++,
-				1)) {
-					ssleep(1);
-			}
-			printk(MPT2SAS_INFO_FMT "\tAFTER adding phys disk: "
-				" handle (0x%04x), sas_addr(0x%016llx)\n",
-				ioc->name, handle, (unsigned long long)
-				le64_to_cpu(sas_device_pg0.SASAddress));
-		}
-	}
-
-	printk(MPT2SAS_INFO_FMT "\tscan devices: phys disk complete\n",
-		ioc->name);
-
-	printk(MPT2SAS_INFO_FMT "\tscan devices: volumes start\n", ioc->name);
-	/* volumes */
-	handle = 0xFFFF;
-	while (!(mpt2sas_config_get_raid_volume_pg1(ioc, &mpi_reply,
-	    &volume_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-		    MPI2_IOCSTATUS_MASK;
-		if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-			printk(MPT2SAS_INFO_FMT "\tbreak from volume scan: "
-				"ioc_status(0x%04x), loginfo(0x%08x)\n",
-				ioc->name, ioc_status,
-				le32_to_cpu(mpi_reply.IOCLogInfo));
-			break;
-		}
-		handle = le16_to_cpu(volume_pg1.DevHandle);
-		spin_lock_irqsave(&ioc->raid_device_lock, flags);
-		raid_device = _scsih_raid_device_find_by_wwid(ioc,
-		    le64_to_cpu(volume_pg1.WWID));
-		spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
-		if (raid_device)
-			continue;
-		if (mpt2sas_config_get_raid_volume_pg0(ioc, &mpi_reply,
-		    &volume_pg0, MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,
-		     sizeof(Mpi2RaidVolPage0_t)))
-			continue;
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-			MPI2_IOCSTATUS_MASK;
-		if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-			printk(MPT2SAS_INFO_FMT "\tbreak from volume scan: "
-				"ioc_status(0x%04x), loginfo(0x%08x)\n",
-				ioc->name, ioc_status,
-				le32_to_cpu(mpi_reply.IOCLogInfo));
-			break;
-		}
-		if (volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_OPTIMAL ||
-		    volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_ONLINE ||
-		    volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_DEGRADED) {
-			memset(&element, 0, sizeof(Mpi2EventIrConfigElement_t));
-			element.ReasonCode = MPI2_EVENT_IR_CHANGE_RC_ADDED;
-			element.VolDevHandle = volume_pg1.DevHandle;
-			printk(MPT2SAS_INFO_FMT "\tBEFORE adding volume: "
-				" handle (0x%04x)\n", ioc->name,
-				volume_pg1.DevHandle);
-			_scsih_sas_volume_add(ioc, &element);
-			printk(MPT2SAS_INFO_FMT "\tAFTER adding volume: "
-				" handle (0x%04x)\n", ioc->name,
-				volume_pg1.DevHandle);
-		}
-	}
-
-	printk(MPT2SAS_INFO_FMT "\tscan devices: volumes complete\n",
-		ioc->name);
-
- skip_to_sas:
-
-	printk(MPT2SAS_INFO_FMT "\tscan devices: end devices start\n",
-		ioc->name);
-	/* sas devices */
-	handle = 0xFFFF;
-	while (!(mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply,
-	    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE,
-	    handle))) {
-		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-		    MPI2_IOCSTATUS_MASK;
-		if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-			printk(MPT2SAS_INFO_FMT "\tbreak from end device scan:"
-				" ioc_status(0x%04x), loginfo(0x%08x)\n",
-				ioc->name, ioc_status,
-				le32_to_cpu(mpi_reply.IOCLogInfo));
-				break;
-		}
-		handle = le16_to_cpu(sas_device_pg0.DevHandle);
-		if (!(_scsih_is_end_device(
-		    le32_to_cpu(sas_device_pg0.DeviceInfo))))
-			continue;
-		spin_lock_irqsave(&ioc->sas_device_lock, flags);
-		sas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-		    le64_to_cpu(sas_device_pg0.SASAddress));
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-		if (sas_device)
-			continue;
-		parent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);
-		if (!_scsih_get_sas_address(ioc, parent_handle, &sas_address)) {
-			printk(MPT2SAS_INFO_FMT "\tBEFORE adding end device: "
-				"handle (0x%04x), sas_addr(0x%016llx)\n",
-				ioc->name, handle, (unsigned long long)
-				le64_to_cpu(sas_device_pg0.SASAddress));
-			mpt2sas_transport_update_links(ioc, sas_address, handle,
-			    sas_device_pg0.PhyNum, MPI2_SAS_NEG_LINK_RATE_1_5);
-			retry_count = 0;
-			/* This will retry adding the end device.
-			 * _scsih_add_device() will decide on retries and
-			 * return "1" when it should be retried
-			 */
-			while (_scsih_add_device(ioc, handle, retry_count++,
-				0)) {
-					ssleep(1);
-			}
-			printk(MPT2SAS_INFO_FMT "\tAFTER adding end device: "
-				"handle (0x%04x), sas_addr(0x%016llx)\n",
-				ioc->name, handle, (unsigned long long)
-				le64_to_cpu(sas_device_pg0.SASAddress));
-		}
-	}
-
-	printk(MPT2SAS_INFO_FMT "\tscan devices: end devices complete\n",
-		ioc->name);
-
-	printk(MPT2SAS_INFO_FMT "scan devices: complete\n", ioc->name);
-}
-
-
-/**
- * mpt2sas_scsih_reset_handler - reset callback handler (for scsih)
- * @ioc: per adapter object
- * @reset_phase: phase
- *
- * The handler for doing any required cleanup or initialization.
- *
- * The reset phase can be MPT2_IOC_PRE_RESET, MPT2_IOC_AFTER_RESET,
- * MPT2_IOC_DONE_RESET
- *
- * Return nothing.
- */
-void
-mpt2sas_scsih_reset_handler(struct MPT2SAS_ADAPTER *ioc, int reset_phase)
-{
-	switch (reset_phase) {
-	case MPT2_IOC_PRE_RESET:
-		dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-		    "MPT2_IOC_PRE_RESET\n", ioc->name, __func__));
-		break;
-	case MPT2_IOC_AFTER_RESET:
-		dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-		    "MPT2_IOC_AFTER_RESET\n", ioc->name, __func__));
-		if (ioc->scsih_cmds.status & MPT2_CMD_PENDING) {
-			ioc->scsih_cmds.status |= MPT2_CMD_RESET;
-			mpt2sas_base_free_smid(ioc, ioc->scsih_cmds.smid);
-			complete(&ioc->scsih_cmds.done);
-		}
-		if (ioc->tm_cmds.status & MPT2_CMD_PENDING) {
-			ioc->tm_cmds.status |= MPT2_CMD_RESET;
-			mpt2sas_base_free_smid(ioc, ioc->tm_cmds.smid);
-			complete(&ioc->tm_cmds.done);
-		}
-		_scsih_fw_event_cleanup_queue(ioc);
-		_scsih_flush_running_cmds(ioc);
-		break;
-	case MPT2_IOC_DONE_RESET:
-		dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-		    "MPT2_IOC_DONE_RESET\n", ioc->name, __func__));
-		_scsih_sas_host_refresh(ioc);
-		_scsih_prep_device_scan(ioc);
-		_scsih_search_responding_sas_devices(ioc);
-		_scsih_search_responding_raid_devices(ioc);
-		_scsih_search_responding_expanders(ioc);
-		if ((!ioc->is_driver_loading) && !(disable_discovery > 0 &&
-		    !ioc->sas_hba.num_phys)) {
-			_scsih_prep_device_scan(ioc);
-			_scsih_search_responding_sas_devices(ioc);
-			_scsih_search_responding_raid_devices(ioc);
-			_scsih_search_responding_expanders(ioc);
-			_scsih_error_recovery_delete_devices(ioc);
-		}
-		break;
-	}
-}
-
-/**
- * _firmware_event_work - delayed task for processing firmware events
- * @ioc: per adapter object
- * @work: equal to the fw_event_work object
- * Context: user.
- *
- * Return nothing.
- */
-static void
-_firmware_event_work(struct work_struct *work)
-{
-	struct fw_event_work *fw_event = container_of(work,
-	    struct fw_event_work, delayed_work.work);
-	struct MPT2SAS_ADAPTER *ioc = fw_event->ioc;
-
-	_scsih_fw_event_del_from_list(ioc, fw_event);
-
-	/* the queue is being flushed so ignore this event */
-	if (ioc->remove_host || ioc->pci_error_recovery) {
-		fw_event_work_put(fw_event);
-		return;
-	}
-
-	switch (fw_event->event) {
-	case MPT2SAS_REMOVE_UNRESPONDING_DEVICES:
-		while (scsi_host_in_recovery(ioc->shost) ||
-				ioc->shost_recovery) {
-			/*
-			 * If we're unloading, bail. Otherwise, this can become
-			 * an infinite loop.
-			 */
-			if (ioc->remove_host)
-				goto out;
-
-			ssleep(1);
-		}
-		_scsih_remove_unresponding_sas_devices(ioc);
-		_scsih_scan_for_devices_after_reset(ioc);
-		break;
-	case MPT2SAS_PORT_ENABLE_COMPLETE:
-		ioc->start_scan = 0;
-
-		if (missing_delay[0] != -1 && missing_delay[1] != -1)
-			mpt2sas_base_update_missing_delay(ioc, missing_delay[0],
-				missing_delay[1]);
-
-		dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "port enable: complete "
-		    "from worker thread\n", ioc->name));
-		break;
-	case MPT2SAS_TURN_ON_PFA_LED:
-		_scsih_turn_on_pfa_led(ioc, fw_event->device_handle);
-		break;
-	case MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST:
-		_scsih_sas_topology_change_event(ioc, fw_event);
-		break;
-	case MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE:
-		_scsih_sas_device_status_change_event(ioc,
-		    fw_event);
-		break;
-	case MPI2_EVENT_SAS_DISCOVERY:
-		_scsih_sas_discovery_event(ioc,
-		    fw_event);
-		break;
-	case MPI2_EVENT_SAS_BROADCAST_PRIMITIVE:
-		_scsih_sas_broadcast_primitive_event(ioc,
-		    fw_event);
-		break;
-	case MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE:
-		_scsih_sas_enclosure_dev_status_change_event(ioc,
-		    fw_event);
-		break;
-	case MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST:
-		_scsih_sas_ir_config_change_event(ioc, fw_event);
-		break;
-	case MPI2_EVENT_IR_VOLUME:
-		_scsih_sas_ir_volume_event(ioc, fw_event);
-		break;
-	case MPI2_EVENT_IR_PHYSICAL_DISK:
-		_scsih_sas_ir_physical_disk_event(ioc, fw_event);
-		break;
-	case MPI2_EVENT_IR_OPERATION_STATUS:
-		_scsih_sas_ir_operation_status_event(ioc, fw_event);
-		break;
-	}
-out:
-	fw_event_work_put(fw_event);
-}
-
-/**
- * mpt2sas_scsih_event_callback - firmware event handler (called at ISR time)
- * @ioc: per adapter object
- * @msix_index: MSIX table index supplied by the OS
- * @reply: reply message frame(lower 32bit addr)
- * Context: interrupt.
- *
- * This function merely adds a new work task into ioc->firmware_event_thread.
- * The tasks are worked from _firmware_event_work in user context.
- *
- * Returns void.
- */
-void
-mpt2sas_scsih_event_callback(struct MPT2SAS_ADAPTER *ioc, u8 msix_index,
-	u32 reply)
-{
-	struct fw_event_work *fw_event;
-	Mpi2EventNotificationReply_t *mpi_reply;
-	u16 event;
-	u16 sz;
-
-	/* events turned off due to host reset or driver unloading */
-	if (ioc->remove_host || ioc->pci_error_recovery)
-		return;
-
-	mpi_reply = mpt2sas_base_get_reply_virt_addr(ioc, reply);
-
-	if (unlikely(!mpi_reply)) {
-		printk(MPT2SAS_ERR_FMT "mpi_reply not valid at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return;
-	}
-
-	event = le16_to_cpu(mpi_reply->Event);
-
-	switch (event) {
-	/* handle these */
-	case MPI2_EVENT_SAS_BROADCAST_PRIMITIVE:
-	{
-		Mpi2EventDataSasBroadcastPrimitive_t *baen_data =
-		    (Mpi2EventDataSasBroadcastPrimitive_t *)
-		    mpi_reply->EventData;
-
-		if (baen_data->Primitive !=
-		    MPI2_EVENT_PRIMITIVE_ASYNCHRONOUS_EVENT)
-			return;
-
-		if (ioc->broadcast_aen_busy) {
-			ioc->broadcast_aen_pending++;
-			return;
-		} else
-			ioc->broadcast_aen_busy = 1;
-		break;
-	}
-
-	case MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST:
-		_scsih_check_topo_delete_events(ioc,
-		    (Mpi2EventDataSasTopologyChangeList_t *)
-		    mpi_reply->EventData);
-		break;
-	case MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST:
-		_scsih_check_ir_config_unhide_events(ioc,
-		    (Mpi2EventDataIrConfigChangeList_t *)
-		    mpi_reply->EventData);
-		break;
-	case MPI2_EVENT_IR_VOLUME:
-		_scsih_check_volume_delete_events(ioc,
-		    (Mpi2EventDataIrVolume_t *)
-		    mpi_reply->EventData);
-		break;
-	case MPI2_EVENT_LOG_ENTRY_ADDED:
-	{
-		Mpi2EventDataLogEntryAdded_t *log_entry;
-		__le32 *log_code;
-
-		if (!ioc->is_warpdrive)
-			break;
-
-		log_entry = (Mpi2EventDataLogEntryAdded_t *)
-		    mpi_reply->EventData;
-		log_code = (__le32 *)log_entry->LogData;
-
-		if (le16_to_cpu(log_entry->LogEntryQualifier)
-		    != MPT2_WARPDRIVE_LOGENTRY)
-			break;
-
-		switch (le32_to_cpu(*log_code)) {
-		case MPT2_WARPDRIVE_LC_SSDT:
-			printk(MPT2SAS_WARN_FMT "WarpDrive Warning: "
-			    "IO Throttling has occurred in the WarpDrive "
-			    "subsystem. Check WarpDrive documentation for "
-			    "additional details.\n", ioc->name);
-			break;
-		case MPT2_WARPDRIVE_LC_SSDLW:
-			printk(MPT2SAS_WARN_FMT "WarpDrive Warning: "
-			    "Program/Erase Cycles for the WarpDrive subsystem "
-			    "in degraded range. Check WarpDrive documentation "
-			    "for additional details.\n", ioc->name);
-			break;
-		case MPT2_WARPDRIVE_LC_SSDLF:
-			printk(MPT2SAS_ERR_FMT "WarpDrive Fatal Error: "
-			    "There are no Program/Erase Cycles for the "
-			    "WarpDrive subsystem. The storage device will be "
-			    "in read-only mode. Check WarpDrive documentation "
-			    "for additional details.\n", ioc->name);
-			break;
-		case MPT2_WARPDRIVE_LC_BRMF:
-			printk(MPT2SAS_ERR_FMT "WarpDrive Fatal Error: "
-			    "The Backup Rail Monitor has failed on the "
-			    "WarpDrive subsystem. Check WarpDrive "
-			    "documentation for additional details.\n",
-			    ioc->name);
-			break;
-		}
-
-		break;
-	}
-	case MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE:
-	case MPI2_EVENT_IR_OPERATION_STATUS:
-	case MPI2_EVENT_SAS_DISCOVERY:
-	case MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE:
-	case MPI2_EVENT_IR_PHYSICAL_DISK:
-		break;
-
-	case MPI2_EVENT_TEMP_THRESHOLD:
-		_scsih_temp_threshold_events(ioc,
-			(Mpi2EventDataTemperature_t *)
-			mpi_reply->EventData);
-		break;
-
-	default: /* ignore the rest */
-		return;
-	}
-
-	sz = le16_to_cpu(mpi_reply->EventDataLength) * 4;
-	fw_event = alloc_fw_event_work(sz);
-	if (!fw_event) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return;
-	}
-
-	memcpy(fw_event->event_data, mpi_reply->EventData, sz);
-	fw_event->ioc = ioc;
-	fw_event->VF_ID = mpi_reply->VF_ID;
-	fw_event->VP_ID = mpi_reply->VP_ID;
-	fw_event->event = event;
-	_scsih_fw_event_add(ioc, fw_event);
-	fw_event_work_put(fw_event);
-	return;
-}
-
-/* shost template */
-static struct scsi_host_template scsih_driver_template = {
-	.module				= THIS_MODULE,
-	.name				= "Fusion MPT SAS Host",
-	.proc_name			= MPT2SAS_DRIVER_NAME,
-	.queuecommand			= _scsih_qcmd,
-	.target_alloc			= _scsih_target_alloc,
-	.slave_alloc			= _scsih_slave_alloc,
-	.slave_configure		= _scsih_slave_configure,
-	.target_destroy			= _scsih_target_destroy,
-	.slave_destroy			= _scsih_slave_destroy,
-	.scan_finished			= _scsih_scan_finished,
-	.scan_start			= _scsih_scan_start,
-	.change_queue_depth 		= _scsih_change_queue_depth,
-	.change_queue_type		= _scsih_change_queue_type,
-	.eh_abort_handler		= _scsih_abort,
-	.eh_device_reset_handler	= _scsih_dev_reset,
-	.eh_target_reset_handler	= _scsih_target_reset,
-	.eh_host_reset_handler		= _scsih_host_reset,
-	.bios_param			= _scsih_bios_param,
-	.can_queue			= 1,
-	.this_id			= -1,
-	.sg_tablesize			= MPT2SAS_SG_DEPTH,
-	.max_sectors			= 32767,
-	.cmd_per_lun			= 7,
-	.use_clustering			= ENABLE_CLUSTERING,
-	.shost_attrs			= mpt2sas_host_attrs,
-	.sdev_attrs			= mpt2sas_dev_attrs,
-};
-
-/**
- * _scsih_expander_node_remove - removing expander device from list.
- * @ioc: per adapter object
- * @sas_expander: the sas_device object
- * Context: Calling function should acquire ioc->sas_node_lock.
- *
- * Removing object and freeing associated memory from the
- * ioc->sas_expander_list.
- *
- * Return nothing.
- */
-static void
-_scsih_expander_node_remove(struct MPT2SAS_ADAPTER *ioc,
-    struct _sas_node *sas_expander)
-{
-	struct _sas_port *mpt2sas_port, *next;
-
-	/* remove sibling ports attached to this expander */
-	list_for_each_entry_safe(mpt2sas_port, next,
-	   &sas_expander->sas_port_list, port_list) {
-		if (ioc->shost_recovery)
-			return;
-		if (mpt2sas_port->remote_identify.device_type ==
-		    SAS_END_DEVICE)
-			mpt2sas_device_remove_by_sas_address(ioc,
-			    mpt2sas_port->remote_identify.sas_address);
-		else if (mpt2sas_port->remote_identify.device_type ==
-		    SAS_EDGE_EXPANDER_DEVICE ||
-		    mpt2sas_port->remote_identify.device_type ==
-		    SAS_FANOUT_EXPANDER_DEVICE)
-			mpt2sas_expander_remove(ioc,
-			    mpt2sas_port->remote_identify.sas_address);
-	}
-
-	mpt2sas_transport_port_remove(ioc, sas_expander->sas_address,
-	    sas_expander->sas_address_parent);
-
-	printk(MPT2SAS_INFO_FMT "expander_remove: handle"
-	   "(0x%04x), sas_addr(0x%016llx)\n", ioc->name,
-	    sas_expander->handle, (unsigned long long)
-	    sas_expander->sas_address);
-
-	kfree(sas_expander->phy);
-	kfree(sas_expander);
-}
-
-/**
- * _scsih_ir_shutdown - IR shutdown notification
- * @ioc: per adapter object
- *
- * Sending RAID Action to alert the Integrated RAID subsystem of the IOC that
- * the host system is shutting down.
- *
- * Return nothing.
- */
-static void
-_scsih_ir_shutdown(struct MPT2SAS_ADAPTER *ioc)
-{
-	Mpi2RaidActionRequest_t *mpi_request;
-	Mpi2RaidActionReply_t *mpi_reply;
-	u16 smid;
-
-	/* is IR firmware build loaded ? */
-	if (!ioc->ir_firmware)
-		return;
-
-	mutex_lock(&ioc->scsih_cmds.mutex);
-
-	if (ioc->scsih_cmds.status != MPT2_CMD_NOT_USED) {
-		printk(MPT2SAS_ERR_FMT "%s: scsih_cmd in use\n",
-		    ioc->name, __func__);
-		goto out;
-	}
-	ioc->scsih_cmds.status = MPT2_CMD_PENDING;
-
-	smid = mpt2sas_base_get_smid(ioc, ioc->scsih_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		ioc->scsih_cmds.status = MPT2_CMD_NOT_USED;
-		goto out;
-	}
-
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	ioc->scsih_cmds.smid = smid;
-	memset(mpi_request, 0, sizeof(Mpi2RaidActionRequest_t));
-
-	mpi_request->Function = MPI2_FUNCTION_RAID_ACTION;
-	mpi_request->Action = MPI2_RAID_ACTION_SYSTEM_SHUTDOWN_INITIATED;
-
-	if (!ioc->hide_ir_msg)
-		printk(MPT2SAS_INFO_FMT "IR shutdown (sending)\n", ioc->name);
-	init_completion(&ioc->scsih_cmds.done);
-	mpt2sas_base_put_smid_default(ioc, smid);
-	wait_for_completion_timeout(&ioc->scsih_cmds.done, 10*HZ);
-
-	if (!(ioc->scsih_cmds.status & MPT2_CMD_COMPLETE)) {
-		printk(MPT2SAS_ERR_FMT "%s: timeout\n",
-		    ioc->name, __func__);
-		goto out;
-	}
-
-	if (ioc->scsih_cmds.status & MPT2_CMD_REPLY_VALID) {
-		mpi_reply = ioc->scsih_cmds.reply;
-
-		if (!ioc->hide_ir_msg)
-			printk(MPT2SAS_INFO_FMT "IR shutdown (complete): "
-			    "ioc_status(0x%04x), loginfo(0x%08x)\n",
-			    ioc->name, le16_to_cpu(mpi_reply->IOCStatus),
-			    le32_to_cpu(mpi_reply->IOCLogInfo));
-	}
-
- out:
-	ioc->scsih_cmds.status = MPT2_CMD_NOT_USED;
-	mutex_unlock(&ioc->scsih_cmds.mutex);
-}
-
-/**
- * _scsih_shutdown - routine call during system shutdown
- * @pdev: PCI device struct
- *
- * Return nothing.
- */
-static void
-_scsih_shutdown(struct pci_dev *pdev)
-{
-	struct Scsi_Host *shost = pci_get_drvdata(pdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	struct workqueue_struct	*wq;
-	unsigned long flags;
-
-	ioc->remove_host = 1;
-	_scsih_fw_event_cleanup_queue(ioc);
-
-	spin_lock_irqsave(&ioc->fw_event_lock, flags);
-	wq = ioc->firmware_event_thread;
-	ioc->firmware_event_thread = NULL;
-	spin_unlock_irqrestore(&ioc->fw_event_lock, flags);
-	if (wq)
-		destroy_workqueue(wq);
-
-	_scsih_ir_shutdown(ioc);
-	mpt2sas_base_detach(ioc);
-}
-
-/**
- * _scsih_remove - detach and remove add host
- * @pdev: PCI device struct
- *
- * Routine called when unloading the driver.
- * Return nothing.
- */
-static void
-_scsih_remove(struct pci_dev *pdev)
-{
-	struct Scsi_Host *shost = pci_get_drvdata(pdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	struct _sas_port *mpt2sas_port, *next_port;
-	struct _raid_device *raid_device, *next;
-	struct MPT2SAS_TARGET *sas_target_priv_data;
-	struct workqueue_struct	*wq;
-	unsigned long flags;
-
-	ioc->remove_host = 1;
-	_scsih_fw_event_cleanup_queue(ioc);
-
-	spin_lock_irqsave(&ioc->fw_event_lock, flags);
-	wq = ioc->firmware_event_thread;
-	ioc->firmware_event_thread = NULL;
-	spin_unlock_irqrestore(&ioc->fw_event_lock, flags);
-	if (wq)
-		destroy_workqueue(wq);
-
-	/* release all the volumes */
-	_scsih_ir_shutdown(ioc);
-	list_for_each_entry_safe(raid_device, next, &ioc->raid_device_list,
-	    list) {
-		if (raid_device->starget) {
-			sas_target_priv_data =
-			    raid_device->starget->hostdata;
-			sas_target_priv_data->deleted = 1;
-			scsi_remove_target(&raid_device->starget->dev);
-		}
-		printk(MPT2SAS_INFO_FMT "removing handle(0x%04x), wwid"
-		    "(0x%016llx)\n", ioc->name,  raid_device->handle,
-		    (unsigned long long) raid_device->wwid);
-		_scsih_raid_device_remove(ioc, raid_device);
-	}
-
-	/* free ports attached to the sas_host */
-	list_for_each_entry_safe(mpt2sas_port, next_port,
-	   &ioc->sas_hba.sas_port_list, port_list) {
-		if (mpt2sas_port->remote_identify.device_type ==
-		    SAS_END_DEVICE)
-			mpt2sas_device_remove_by_sas_address(ioc,
-			    mpt2sas_port->remote_identify.sas_address);
-		else if (mpt2sas_port->remote_identify.device_type ==
-		    SAS_EDGE_EXPANDER_DEVICE ||
-		    mpt2sas_port->remote_identify.device_type ==
-		    SAS_FANOUT_EXPANDER_DEVICE)
-			mpt2sas_expander_remove(ioc,
-			    mpt2sas_port->remote_identify.sas_address);
-	}
-
-	/* free phys attached to the sas_host */
-	if (ioc->sas_hba.num_phys) {
-		kfree(ioc->sas_hba.phy);
-		ioc->sas_hba.phy = NULL;
-		ioc->sas_hba.num_phys = 0;
-	}
-
-	sas_remove_host(shost);
-	scsi_remove_host(shost);
-	mpt2sas_base_detach(ioc);
-	spin_lock(&gioc_lock);
-	list_del(&ioc->list);
-	spin_unlock(&gioc_lock);
-	scsi_host_put(shost);
-}
-
-/**
- * _scsih_probe_boot_devices - reports 1st device
- * @ioc: per adapter object
- *
- * If specified in bios page 2, this routine reports the 1st
- * device scsi-ml or sas transport for persistent boot device
- * purposes.  Please refer to function _scsih_determine_boot_device()
- */
-static void
-_scsih_probe_boot_devices(struct MPT2SAS_ADAPTER *ioc)
-{
-	u8 is_raid;
-	void *device;
-	struct _sas_device *sas_device;
-	struct _raid_device *raid_device;
-	u16 handle;
-	u64 sas_address_parent;
-	u64 sas_address;
-	unsigned long flags;
-	int rc;
-
-	 /* no Bios, return immediately */
-	if (!ioc->bios_pg3.BiosVersion)
-		return;
-
-	device = NULL;
-	is_raid = 0;
-	if (ioc->req_boot_device.device) {
-		device =  ioc->req_boot_device.device;
-		is_raid = ioc->req_boot_device.is_raid;
-	} else if (ioc->req_alt_boot_device.device) {
-		device =  ioc->req_alt_boot_device.device;
-		is_raid = ioc->req_alt_boot_device.is_raid;
-	} else if (ioc->current_boot_device.device) {
-		device =  ioc->current_boot_device.device;
-		is_raid = ioc->current_boot_device.is_raid;
-	}
-
-	if (!device)
-		return;
-
-	if (is_raid) {
-		raid_device = device;
-		rc = scsi_add_device(ioc->shost, RAID_CHANNEL,
-		    raid_device->id, 0);
-		if (rc)
-			_scsih_raid_device_remove(ioc, raid_device);
-	} else {
-		spin_lock_irqsave(&ioc->sas_device_lock, flags);
-		sas_device = device;
-		handle = sas_device->handle;
-		sas_address_parent = sas_device->sas_address_parent;
-		sas_address = sas_device->sas_address;
-		list_move_tail(&sas_device->list, &ioc->sas_device_list);
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-
-		if (ioc->hide_drives)
-			return;
-		if (!mpt2sas_transport_port_add(ioc, sas_device->handle,
-		    sas_device->sas_address_parent)) {
-			_scsih_sas_device_remove(ioc, sas_device);
-		} else if (!sas_device->starget) {
-			if (!ioc->is_driver_loading) {
-				mpt2sas_transport_port_remove(ioc,
-					sas_address,
-					sas_address_parent);
-				_scsih_sas_device_remove(ioc, sas_device);
-			}
-		}
-	}
-}
-
-/**
- * _scsih_probe_raid - reporting raid volumes to scsi-ml
- * @ioc: per adapter object
- *
- * Called during initial loading of the driver.
- */
-static void
-_scsih_probe_raid(struct MPT2SAS_ADAPTER *ioc)
-{
-	struct _raid_device *raid_device, *raid_next;
-	int rc;
-
-	list_for_each_entry_safe(raid_device, raid_next,
-	    &ioc->raid_device_list, list) {
-		if (raid_device->starget)
-			continue;
-		rc = scsi_add_device(ioc->shost, RAID_CHANNEL,
-		    raid_device->id, 0);
-		if (rc)
-			_scsih_raid_device_remove(ioc, raid_device);
-	}
-}
-
-/**
- * _scsih_probe_sas - reporting sas devices to sas transport
- * @ioc: per adapter object
- *
- * Called during initial loading of the driver.
- */
-static void
-_scsih_probe_sas(struct MPT2SAS_ADAPTER *ioc)
-{
-	struct _sas_device *sas_device, *next;
-	unsigned long flags;
-
-	/* SAS Device List */
-	list_for_each_entry_safe(sas_device, next, &ioc->sas_device_init_list,
-	    list) {
-
-		if (ioc->hide_drives)
-			continue;
-
-		if (!mpt2sas_transport_port_add(ioc, sas_device->handle,
-		    sas_device->sas_address_parent)) {
-			list_del(&sas_device->list);
-			kfree(sas_device);
-			continue;
-		} else if (!sas_device->starget) {
-			if (!ioc->is_driver_loading) {
-				mpt2sas_transport_port_remove(ioc,
-					sas_device->sas_address,
-					sas_device->sas_address_parent);
-				list_del(&sas_device->list);
-				kfree(sas_device);
-				continue;
-			}
-		}
-		spin_lock_irqsave(&ioc->sas_device_lock, flags);
-		list_move_tail(&sas_device->list, &ioc->sas_device_list);
-		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	}
-}
-
-/**
- * _scsih_probe_devices - probing for devices
- * @ioc: per adapter object
- *
- * Called during initial loading of the driver.
- */
-static void
-_scsih_probe_devices(struct MPT2SAS_ADAPTER *ioc)
-{
-	u16 volume_mapping_flags;
-
-	if (!(ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_SCSI_INITIATOR))
-		return;  /* return when IOC doesn't support initiator mode */
-
-	_scsih_probe_boot_devices(ioc);
-
-	if (ioc->ir_firmware) {
-		volume_mapping_flags =
-		    le16_to_cpu(ioc->ioc_pg8.IRVolumeMappingFlags) &
-		    MPI2_IOCPAGE8_IRFLAGS_MASK_VOLUME_MAPPING_MODE;
-		if (volume_mapping_flags ==
-		    MPI2_IOCPAGE8_IRFLAGS_LOW_VOLUME_MAPPING) {
-			_scsih_probe_raid(ioc);
-			_scsih_probe_sas(ioc);
-		} else {
-			_scsih_probe_sas(ioc);
-			_scsih_probe_raid(ioc);
-		}
-	} else
-		_scsih_probe_sas(ioc);
-}
-
-
-/**
- * _scsih_scan_start - scsi lld callback for .scan_start
- * @shost: SCSI host pointer
- *
- * The shost has the ability to discover targets on its own instead
- * of scanning the entire bus.  In our implemention, we will kick off
- * firmware discovery.
- */
-static void
-_scsih_scan_start(struct Scsi_Host *shost)
-{
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	int rc;
-
-	if (diag_buffer_enable != -1 && diag_buffer_enable != 0)
-		mpt2sas_enable_diag_buffer(ioc, diag_buffer_enable);
-
-	if (disable_discovery > 0)
-		return;
-
-	ioc->start_scan = 1;
-	rc = mpt2sas_port_enable(ioc);
-
-	if (rc != 0)
-		printk(MPT2SAS_INFO_FMT "port enable: FAILED\n", ioc->name);
-}
-
-/**
- * _scsih_scan_finished - scsi lld callback for .scan_finished
- * @shost: SCSI host pointer
- * @time: elapsed time of the scan in jiffies
- *
- * This function will be called periodically until it returns 1 with the
- * scsi_host and the elapsed time of the scan in jiffies. In our implemention,
- * we wait for firmware discovery to complete, then return 1.
- */
-static int
-_scsih_scan_finished(struct Scsi_Host *shost, unsigned long time)
-{
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	if (disable_discovery > 0) {
-		ioc->is_driver_loading = 0;
-		ioc->wait_for_discovery_to_complete = 0;
-		return 1;
-	}
-
-	if (time >= (300 * HZ)) {
-		ioc->base_cmds.status = MPT2_CMD_NOT_USED;
-		printk(MPT2SAS_INFO_FMT "port enable: FAILED with timeout "
-		    "(timeout=300s)\n", ioc->name);
-		ioc->is_driver_loading = 0;
-		return 1;
-	}
-
-	if (ioc->start_scan)
-		return 0;
-
-	if (ioc->start_scan_failed) {
-		printk(MPT2SAS_INFO_FMT "port enable: FAILED with "
-		    "(ioc_status=0x%08x)\n", ioc->name, ioc->start_scan_failed);
-		ioc->is_driver_loading = 0;
-		ioc->wait_for_discovery_to_complete = 0;
-		ioc->remove_host = 1;
-		return 1;
-	}
-
-	printk(MPT2SAS_INFO_FMT "port enable: SUCCESS\n", ioc->name);
-	ioc->base_cmds.status = MPT2_CMD_NOT_USED;
-
-	if (ioc->wait_for_discovery_to_complete) {
-		ioc->wait_for_discovery_to_complete = 0;
-		_scsih_probe_devices(ioc);
-	}
-	mpt2sas_base_start_watchdog(ioc);
-	ioc->is_driver_loading = 0;
-	return 1;
-}
-
-
-/**
- * _scsih_probe - attach and add scsi host
- * @pdev: PCI device struct
- * @id: pci device id
- *
- * Returns 0 success, anything else error.
- */
-static int
-_scsih_probe(struct pci_dev *pdev, const struct pci_device_id *id)
-{
-	struct MPT2SAS_ADAPTER *ioc;
-	struct Scsi_Host *shost;
-	int rv;
-
-	shost = scsi_host_alloc(&scsih_driver_template,
-	    sizeof(struct MPT2SAS_ADAPTER));
-	if (!shost)
-		return -ENODEV;
-
-	/* init local params */
-	ioc = shost_priv(shost);
-	memset(ioc, 0, sizeof(struct MPT2SAS_ADAPTER));
-	INIT_LIST_HEAD(&ioc->list);
-	spin_lock(&gioc_lock);
-	list_add_tail(&ioc->list, &mpt2sas_ioc_list);
-	spin_unlock(&gioc_lock);
-	ioc->shost = shost;
-	ioc->id = mpt_ids++;
-	sprintf(ioc->name, "%s%d", MPT2SAS_DRIVER_NAME, ioc->id);
-	ioc->pdev = pdev;
-	if (id->device == MPI2_MFGPAGE_DEVID_SSS6200) {
-		ioc->is_warpdrive = 1;
-		ioc->hide_ir_msg = 1;
-	} else
-		ioc->mfg_pg10_hide_flag = MFG_PAGE10_EXPOSE_ALL_DISKS;
-	ioc->scsi_io_cb_idx = scsi_io_cb_idx;
-	ioc->tm_cb_idx = tm_cb_idx;
-	ioc->ctl_cb_idx = ctl_cb_idx;
-	ioc->base_cb_idx = base_cb_idx;
-	ioc->port_enable_cb_idx = port_enable_cb_idx;
-	ioc->transport_cb_idx = transport_cb_idx;
-	ioc->scsih_cb_idx = scsih_cb_idx;
-	ioc->config_cb_idx = config_cb_idx;
-	ioc->tm_tr_cb_idx = tm_tr_cb_idx;
-	ioc->tm_tr_volume_cb_idx = tm_tr_volume_cb_idx;
-	ioc->tm_sas_control_cb_idx = tm_sas_control_cb_idx;
-	ioc->logging_level = logging_level;
-	ioc->schedule_dead_ioc_flush_running_cmds = &_scsih_flush_running_cmds;
-	/* misc semaphores and spin locks */
-	mutex_init(&ioc->reset_in_progress_mutex);
-	/* initializing pci_access_mutex lock */
-	mutex_init(&ioc->pci_access_mutex);
-	spin_lock_init(&ioc->ioc_reset_in_progress_lock);
-	spin_lock_init(&ioc->scsi_lookup_lock);
-	spin_lock_init(&ioc->sas_device_lock);
-	spin_lock_init(&ioc->sas_node_lock);
-	spin_lock_init(&ioc->fw_event_lock);
-	spin_lock_init(&ioc->raid_device_lock);
-
-	INIT_LIST_HEAD(&ioc->sas_device_list);
-	INIT_LIST_HEAD(&ioc->sas_device_init_list);
-	INIT_LIST_HEAD(&ioc->sas_expander_list);
-	INIT_LIST_HEAD(&ioc->fw_event_list);
-	INIT_LIST_HEAD(&ioc->raid_device_list);
-	INIT_LIST_HEAD(&ioc->sas_hba.sas_port_list);
-	INIT_LIST_HEAD(&ioc->delayed_tr_list);
-	INIT_LIST_HEAD(&ioc->delayed_tr_volume_list);
-	INIT_LIST_HEAD(&ioc->reply_queue_list);
-
-	/* init shost parameters */
-	shost->max_cmd_len = 32;
-	shost->max_lun = max_lun;
-	shost->transportt = mpt2sas_transport_template;
-	shost->unique_id = ioc->id;
-
-	if (max_sectors != 0xFFFF) {
-		if (max_sectors < 64) {
-			shost->max_sectors = 64;
-			printk(MPT2SAS_WARN_FMT "Invalid value %d passed "
-			    "for max_sectors, range is 64 to 32767. Assigning "
-			    "value of 64.\n", ioc->name, max_sectors);
-		} else if (max_sectors > 32767) {
-			shost->max_sectors = 32767;
-			printk(MPT2SAS_WARN_FMT "Invalid value %d passed "
-			    "for max_sectors, range is 64 to 8192. Assigning "
-			    "default value of 32767.\n", ioc->name,
-			    max_sectors);
-		} else {
-			shost->max_sectors = max_sectors & 0xFFFE;
-			printk(MPT2SAS_INFO_FMT "The max_sectors value is "
-			    "set to %d\n", ioc->name, shost->max_sectors);
-		}
-	}
-
-	/* register EEDP capabilities with SCSI layer */
-	if (prot_mask)
-		scsi_host_set_prot(shost, prot_mask);
-	else
-		scsi_host_set_prot(shost, SHOST_DIF_TYPE1_PROTECTION
-				   | SHOST_DIF_TYPE2_PROTECTION
-				   | SHOST_DIF_TYPE3_PROTECTION);
-
-	scsi_host_set_guard(shost, SHOST_DIX_GUARD_CRC);
-
-	/* event thread */
-	snprintf(ioc->firmware_event_name, sizeof(ioc->firmware_event_name),
-	    "fw_event%d", ioc->id);
-	ioc->firmware_event_thread = create_singlethread_workqueue(
-	    ioc->firmware_event_name);
-	if (!ioc->firmware_event_thread) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		rv = -ENODEV;
-		goto out_thread_fail;
-	}
-
-	ioc->is_driver_loading = 1;
-	if ((mpt2sas_base_attach(ioc))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		rv = -ENODEV;
-		goto out_attach_fail;
-	}
-
-	if (ioc->is_warpdrive) {
-		if (ioc->mfg_pg10_hide_flag ==  MFG_PAGE10_EXPOSE_ALL_DISKS)
-			ioc->hide_drives = 0;
-		else if (ioc->mfg_pg10_hide_flag ==  MFG_PAGE10_HIDE_ALL_DISKS)
-			ioc->hide_drives = 1;
-		else {
-			if (_scsih_get_num_volumes(ioc))
-				ioc->hide_drives = 1;
-			else
-				ioc->hide_drives = 0;
-		}
-	} else
-		ioc->hide_drives = 0;
-
-	rv = scsi_add_host(shost, &pdev->dev);
-	if (rv) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out_add_shost_fail;
-	}
-
-	scsi_scan_host(shost);
-
-	return 0;
-
- out_add_shost_fail:
-	mpt2sas_base_detach(ioc);
- out_attach_fail:
-	destroy_workqueue(ioc->firmware_event_thread);
- out_thread_fail:
-	spin_lock(&gioc_lock);
-	list_del(&ioc->list);
-	spin_unlock(&gioc_lock);
-	scsi_host_put(shost);
-	return rv;
-}
-
-#ifdef CONFIG_PM
-/**
- * _scsih_suspend - power management suspend main entry point
- * @pdev: PCI device struct
- * @state: PM state change to (usually PCI_D3)
- *
- * Returns 0 success, anything else error.
- */
-static int
-_scsih_suspend(struct pci_dev *pdev, pm_message_t state)
-{
-	struct Scsi_Host *shost = pci_get_drvdata(pdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	pci_power_t device_state;
-
-	mpt2sas_base_stop_watchdog(ioc);
-	scsi_block_requests(shost);
-	_scsih_ir_shutdown(ioc);
-	device_state = pci_choose_state(pdev, state);
-	printk(MPT2SAS_INFO_FMT "pdev=0x%p, slot=%s, entering "
-	    "operating state [D%d]\n", ioc->name, pdev,
-	    pci_name(pdev), device_state);
-
-	mpt2sas_base_free_resources(ioc);
-	pci_save_state(pdev);
-	pci_set_power_state(pdev, device_state);
-	return 0;
-}
-
-/**
- * _scsih_resume - power management resume main entry point
- * @pdev: PCI device struct
- *
- * Returns 0 success, anything else error.
- */
-static int
-_scsih_resume(struct pci_dev *pdev)
-{
-	struct Scsi_Host *shost = pci_get_drvdata(pdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	pci_power_t device_state = pdev->current_state;
-	int r;
-
-	printk(MPT2SAS_INFO_FMT "pdev=0x%p, slot=%s, previous "
-	    "operating state [D%d]\n", ioc->name, pdev,
-	    pci_name(pdev), device_state);
-
-	pci_set_power_state(pdev, PCI_D0);
-	pci_enable_wake(pdev, PCI_D0, 0);
-	pci_restore_state(pdev);
-	ioc->pdev = pdev;
-	r = mpt2sas_base_map_resources(ioc);
-	if (r)
-		return r;
-
-	mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP, SOFT_RESET);
-	scsi_unblock_requests(shost);
-	mpt2sas_base_start_watchdog(ioc);
-	return 0;
-}
-#endif /* CONFIG_PM */
-
-/**
- * _scsih_pci_error_detected - Called when a PCI error is detected.
- * @pdev: PCI device struct
- * @state: PCI channel state
- *
- * Description: Called when a PCI error is detected.
- *
- * Return value:
- *      PCI_ERS_RESULT_NEED_RESET or PCI_ERS_RESULT_DISCONNECT
- */
-static pci_ers_result_t
-_scsih_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)
-{
-	struct Scsi_Host *shost = pci_get_drvdata(pdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	printk(MPT2SAS_INFO_FMT "PCI error: detected callback, state(%d)!!\n",
-	    ioc->name, state);
-
-	switch (state) {
-	case pci_channel_io_normal:
-		return PCI_ERS_RESULT_CAN_RECOVER;
-	case pci_channel_io_frozen:
-		/* Fatal error, prepare for slot reset */
-		ioc->pci_error_recovery = 1;
-		scsi_block_requests(ioc->shost);
-		mpt2sas_base_stop_watchdog(ioc);
-		mpt2sas_base_free_resources(ioc);
-		return PCI_ERS_RESULT_NEED_RESET;
-	case pci_channel_io_perm_failure:
-		/* Permanent error, prepare for device removal */
-		ioc->pci_error_recovery = 1;
-		mpt2sas_base_stop_watchdog(ioc);
-		_scsih_flush_running_cmds(ioc);
-		return PCI_ERS_RESULT_DISCONNECT;
-	}
-	return PCI_ERS_RESULT_NEED_RESET;
-}
-
-/**
- * _scsih_pci_slot_reset - Called when PCI slot has been reset.
- * @pdev: PCI device struct
- *
- * Description: This routine is called by the pci error recovery
- * code after the PCI slot has been reset, just before we
- * should resume normal operations.
- */
-static pci_ers_result_t
-_scsih_pci_slot_reset(struct pci_dev *pdev)
-{
-	struct Scsi_Host *shost = pci_get_drvdata(pdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	int rc;
-
-	printk(MPT2SAS_INFO_FMT "PCI error: slot reset callback!!\n",
-		ioc->name);
-
-	ioc->pci_error_recovery = 0;
-	ioc->pdev = pdev;
-	pci_restore_state(pdev);
-	rc = mpt2sas_base_map_resources(ioc);
-	if (rc)
-		return PCI_ERS_RESULT_DISCONNECT;
-
-
-	rc = mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-	    FORCE_BIG_HAMMER);
-
-	printk(MPT2SAS_WARN_FMT "hard reset: %s\n", ioc->name,
-	    (rc == 0) ? "success" : "failed");
-
-	if (!rc)
-		return PCI_ERS_RESULT_RECOVERED;
-	else
-		return PCI_ERS_RESULT_DISCONNECT;
-}
-
-/**
- * _scsih_pci_resume() - resume normal ops after PCI reset
- * @pdev: pointer to PCI device
- *
- * Called when the error recovery driver tells us that its
- * OK to resume normal operation. Use completion to allow
- * halted scsi ops to resume.
- */
-static void
-_scsih_pci_resume(struct pci_dev *pdev)
-{
-	struct Scsi_Host *shost = pci_get_drvdata(pdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	printk(MPT2SAS_INFO_FMT "PCI error: resume callback!!\n", ioc->name);
-
-	pci_cleanup_aer_uncorrect_error_status(pdev);
-	mpt2sas_base_start_watchdog(ioc);
-	scsi_unblock_requests(ioc->shost);
-}
-
-/**
- * _scsih_pci_mmio_enabled - Enable MMIO and dump debug registers
- * @pdev: pointer to PCI device
- */
-static pci_ers_result_t
-_scsih_pci_mmio_enabled(struct pci_dev *pdev)
-{
-	struct Scsi_Host *shost = pci_get_drvdata(pdev);
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-
-	printk(MPT2SAS_INFO_FMT "PCI error: mmio enabled callback!!\n",
-	    ioc->name);
-
-	/* TODO - dump whatever for debugging purposes */
-
-	/* Request a slot reset. */
-	return PCI_ERS_RESULT_NEED_RESET;
-}
-
-static const struct pci_error_handlers _scsih_err_handler = {
-	.error_detected = _scsih_pci_error_detected,
-	.mmio_enabled = _scsih_pci_mmio_enabled,
-	.slot_reset =	_scsih_pci_slot_reset,
-	.resume =	_scsih_pci_resume,
-};
-
-static struct pci_driver scsih_driver = {
-	.name		= MPT2SAS_DRIVER_NAME,
-	.id_table	= scsih_pci_table,
-	.probe		= _scsih_probe,
-	.remove		= _scsih_remove,
-	.shutdown	= _scsih_shutdown,
-	.err_handler	= &_scsih_err_handler,
-#ifdef CONFIG_PM
-	.suspend	= _scsih_suspend,
-	.resume		= _scsih_resume,
-#endif
-};
-
-/* raid transport support */
-static struct raid_function_template mpt2sas_raid_functions = {
-	.cookie		= &scsih_driver_template,
-	.is_raid	= _scsih_is_raid,
-	.get_resync	= _scsih_get_resync,
-	.get_state	= _scsih_get_state,
-};
-
-/**
- * _scsih_init - main entry point for this driver.
- *
- * Returns 0 success, anything else error.
- */
-static int __init
-_scsih_init(void)
-{
-	int error;
-
-	mpt_ids = 0;
-	printk(KERN_INFO "%s version %s loaded\n", MPT2SAS_DRIVER_NAME,
-	    MPT2SAS_DRIVER_VERSION);
-
-	mpt2sas_transport_template =
-	    sas_attach_transport(&mpt2sas_transport_functions);
-	if (!mpt2sas_transport_template)
-		return -ENODEV;
-	/* raid transport support */
-	mpt2sas_raid_template = raid_class_attach(&mpt2sas_raid_functions);
-	if (!mpt2sas_raid_template) {
-		sas_release_transport(mpt2sas_transport_template);
-		return -ENODEV;
-	}
-
-	mpt2sas_base_initialize_callback_handler();
-
-	 /* queuecommand callback hander */
-	scsi_io_cb_idx = mpt2sas_base_register_callback_handler(_scsih_io_done);
-
-	/* task management callback handler */
-	tm_cb_idx = mpt2sas_base_register_callback_handler(_scsih_tm_done);
-
-	/* base internal commands callback handler */
-	base_cb_idx = mpt2sas_base_register_callback_handler(mpt2sas_base_done);
-	port_enable_cb_idx = mpt2sas_base_register_callback_handler(
-		mpt2sas_port_enable_done);
-
-	/* transport internal commands callback handler */
-	transport_cb_idx = mpt2sas_base_register_callback_handler(
-	    mpt2sas_transport_done);
-
-	/* scsih internal commands callback handler */
-	scsih_cb_idx = mpt2sas_base_register_callback_handler(_scsih_done);
-
-	/* configuration page API internal commands callback handler */
-	config_cb_idx = mpt2sas_base_register_callback_handler(
-	    mpt2sas_config_done);
-
-	/* ctl module callback handler */
-	ctl_cb_idx = mpt2sas_base_register_callback_handler(mpt2sas_ctl_done);
-
-	tm_tr_cb_idx = mpt2sas_base_register_callback_handler(
-	    _scsih_tm_tr_complete);
-
-	tm_tr_volume_cb_idx = mpt2sas_base_register_callback_handler(
-	    _scsih_tm_volume_tr_complete);
-
-	tm_sas_control_cb_idx = mpt2sas_base_register_callback_handler(
-	    _scsih_sas_control_complete);
-
-	mpt2sas_ctl_init();
-
-	error = pci_register_driver(&scsih_driver);
-	if (error) {
-		/* raid transport support */
-		raid_class_release(mpt2sas_raid_template);
-		sas_release_transport(mpt2sas_transport_template);
-	}
-
-	return error;
-}
-
-/**
- * _scsih_exit - exit point for this driver (when it is a module).
- *
- * Returns 0 success, anything else error.
- */
-static void __exit
-_scsih_exit(void)
-{
-	printk(KERN_INFO "mpt2sas version %s unloading\n",
-	    MPT2SAS_DRIVER_VERSION);
-
-	pci_unregister_driver(&scsih_driver);
-
-	mpt2sas_ctl_exit();
-
-	mpt2sas_base_release_callback_handler(scsi_io_cb_idx);
-	mpt2sas_base_release_callback_handler(tm_cb_idx);
-	mpt2sas_base_release_callback_handler(base_cb_idx);
-	mpt2sas_base_release_callback_handler(port_enable_cb_idx);
-	mpt2sas_base_release_callback_handler(transport_cb_idx);
-	mpt2sas_base_release_callback_handler(scsih_cb_idx);
-	mpt2sas_base_release_callback_handler(config_cb_idx);
-	mpt2sas_base_release_callback_handler(ctl_cb_idx);
-
-	mpt2sas_base_release_callback_handler(tm_tr_cb_idx);
-	mpt2sas_base_release_callback_handler(tm_tr_volume_cb_idx);
-	mpt2sas_base_release_callback_handler(tm_sas_control_cb_idx);
-
-	/* raid transport support */
-	raid_class_release(mpt2sas_raid_template);
-	sas_release_transport(mpt2sas_transport_template);
-
-}
-
-module_init(_scsih_init);
-module_exit(_scsih_exit);
diff --git a/drivers/scsi/mpt2sas/mpt2sas_transport.c b/drivers/scsi/mpt2sas/mpt2sas_transport.c
deleted file mode 100644
index b9dbeebc6306..000000000000
--- a/drivers/scsi/mpt2sas/mpt2sas_transport.c
+++ /dev/null
@@ -1,2168 +0,0 @@
-/*
- * SAS Transport Layer for MPT (Message Passing Technology) based controllers
- *
- * This code is based on drivers/scsi/mpt2sas/mpt2_transport.c
- * Copyright (C) 2007-2014  LSI Corporation
- * Copyright (C) 20013-2014 Avago Technologies
- *  (mailto: MPT-FusionLinux.pdl@avagotech.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * NO WARRANTY
- * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
- * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
- * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
- * solely responsible for determining the appropriateness of using and
- * distributing the Program and assumes all risks associated with its
- * exercise of rights under this Agreement, including but not limited to
- * the risks and costs of program errors, damage to or loss of data,
- * programs or equipment, and unavailability or interruption of operations.
-
- * DISCLAIMER OF LIABILITY
- * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
- * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
-
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
- * USA.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/sched.h>
-#include <linux/workqueue.h>
-#include <linux/delay.h>
-#include <linux/pci.h>
-#include <linux/slab.h>
-
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_device.h>
-#include <scsi/scsi_host.h>
-#include <scsi/scsi_transport_sas.h>
-#include <scsi/scsi_dbg.h>
-
-#include "mpt2sas_base.h"
-/**
- * _transport_sas_node_find_by_sas_address - sas node search
- * @ioc: per adapter object
- * @sas_address: sas address of expander or sas host
- * Context: Calling function should acquire ioc->sas_node_lock.
- *
- * Search for either hba phys or expander device based on handle, then returns
- * the sas_node object.
- */
-static struct _sas_node *
-_transport_sas_node_find_by_sas_address(struct MPT2SAS_ADAPTER *ioc,
-    u64 sas_address)
-{
-	if (ioc->sas_hba.sas_address == sas_address)
-		return &ioc->sas_hba;
-	else
-		return mpt2sas_scsih_expander_find_by_sas_address(ioc,
-		    sas_address);
-}
-
-/**
- * _transport_convert_phy_link_rate -
- * @link_rate: link rate returned from mpt firmware
- *
- * Convert link_rate from mpi fusion into sas_transport form.
- */
-static enum sas_linkrate
-_transport_convert_phy_link_rate(u8 link_rate)
-{
-	enum sas_linkrate rc;
-
-	switch (link_rate) {
-	case MPI2_SAS_NEG_LINK_RATE_1_5:
-		rc = SAS_LINK_RATE_1_5_GBPS;
-		break;
-	case MPI2_SAS_NEG_LINK_RATE_3_0:
-		rc = SAS_LINK_RATE_3_0_GBPS;
-		break;
-	case MPI2_SAS_NEG_LINK_RATE_6_0:
-		rc = SAS_LINK_RATE_6_0_GBPS;
-		break;
-	case MPI2_SAS_NEG_LINK_RATE_PHY_DISABLED:
-		rc = SAS_PHY_DISABLED;
-		break;
-	case MPI2_SAS_NEG_LINK_RATE_NEGOTIATION_FAILED:
-		rc = SAS_LINK_RATE_FAILED;
-		break;
-	case MPI2_SAS_NEG_LINK_RATE_PORT_SELECTOR:
-		rc = SAS_SATA_PORT_SELECTOR;
-		break;
-	case MPI2_SAS_NEG_LINK_RATE_SMP_RESET_IN_PROGRESS:
-		rc = SAS_PHY_RESET_IN_PROGRESS;
-		break;
-	default:
-	case MPI2_SAS_NEG_LINK_RATE_SATA_OOB_COMPLETE:
-	case MPI2_SAS_NEG_LINK_RATE_UNKNOWN_LINK_RATE:
-		rc = SAS_LINK_RATE_UNKNOWN;
-		break;
-	}
-	return rc;
-}
-
-/**
- * _transport_set_identify - set identify for phys and end devices
- * @ioc: per adapter object
- * @handle: device handle
- * @identify: sas identify info
- *
- * Populates sas identify info.
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_transport_set_identify(struct MPT2SAS_ADAPTER *ioc, u16 handle,
-    struct sas_identify *identify)
-{
-	Mpi2SasDevicePage0_t sas_device_pg0;
-	Mpi2ConfigReply_t mpi_reply;
-	u32 device_info;
-	u32 ioc_status;
-
-	if (ioc->shost_recovery || ioc->pci_error_recovery) {
-		printk(MPT2SAS_INFO_FMT "%s: host reset in progress!\n",
-		    __func__, ioc->name);
-		return -EFAULT;
-	}
-
-	if ((mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,
-	    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return -ENXIO;
-	}
-
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-	    MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-		printk(MPT2SAS_ERR_FMT "handle(0x%04x), ioc_status(0x%04x)"
-		    "\nfailure at %s:%d/%s()!\n", ioc->name, handle, ioc_status,
-		     __FILE__, __LINE__, __func__);
-		return -EIO;
-	}
-
-	memset(identify, 0, sizeof(struct sas_identify));
-	device_info = le32_to_cpu(sas_device_pg0.DeviceInfo);
-
-	/* sas_address */
-	identify->sas_address = le64_to_cpu(sas_device_pg0.SASAddress);
-
-	/* phy number of the parent device this device is linked to */
-	identify->phy_identifier = sas_device_pg0.PhyNum;
-
-	/* device_type */
-	switch (device_info & MPI2_SAS_DEVICE_INFO_MASK_DEVICE_TYPE) {
-	case MPI2_SAS_DEVICE_INFO_NO_DEVICE:
-		identify->device_type = SAS_PHY_UNUSED;
-		break;
-	case MPI2_SAS_DEVICE_INFO_END_DEVICE:
-		identify->device_type = SAS_END_DEVICE;
-		break;
-	case MPI2_SAS_DEVICE_INFO_EDGE_EXPANDER:
-		identify->device_type = SAS_EDGE_EXPANDER_DEVICE;
-		break;
-	case MPI2_SAS_DEVICE_INFO_FANOUT_EXPANDER:
-		identify->device_type = SAS_FANOUT_EXPANDER_DEVICE;
-		break;
-	}
-
-	/* initiator_port_protocols */
-	if (device_info & MPI2_SAS_DEVICE_INFO_SSP_INITIATOR)
-		identify->initiator_port_protocols |= SAS_PROTOCOL_SSP;
-	if (device_info & MPI2_SAS_DEVICE_INFO_STP_INITIATOR)
-		identify->initiator_port_protocols |= SAS_PROTOCOL_STP;
-	if (device_info & MPI2_SAS_DEVICE_INFO_SMP_INITIATOR)
-		identify->initiator_port_protocols |= SAS_PROTOCOL_SMP;
-	if (device_info & MPI2_SAS_DEVICE_INFO_SATA_HOST)
-		identify->initiator_port_protocols |= SAS_PROTOCOL_SATA;
-
-	/* target_port_protocols */
-	if (device_info & MPI2_SAS_DEVICE_INFO_SSP_TARGET)
-		identify->target_port_protocols |= SAS_PROTOCOL_SSP;
-	if (device_info & MPI2_SAS_DEVICE_INFO_STP_TARGET)
-		identify->target_port_protocols |= SAS_PROTOCOL_STP;
-	if (device_info & MPI2_SAS_DEVICE_INFO_SMP_TARGET)
-		identify->target_port_protocols |= SAS_PROTOCOL_SMP;
-	if (device_info & MPI2_SAS_DEVICE_INFO_SATA_DEVICE)
-		identify->target_port_protocols |= SAS_PROTOCOL_SATA;
-
-	return 0;
-}
-
-/**
- * mpt2sas_transport_done -  internal transport layer callback handler.
- * @ioc: per adapter object
- * @smid: system request message index
- * @msix_index: MSIX table index supplied by the OS
- * @reply: reply message frame(lower 32bit addr)
- *
- * Callback handler when sending internal generated transport cmds.
- * The callback index passed is `ioc->transport_cb_idx`
- *
- * Return 1 meaning mf should be freed from _base_interrupt
- *        0 means the mf is freed from this function.
- */
-u8
-mpt2sas_transport_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
-    u32 reply)
-{
-	MPI2DefaultReply_t *mpi_reply;
-
-	mpi_reply =  mpt2sas_base_get_reply_virt_addr(ioc, reply);
-	if (ioc->transport_cmds.status == MPT2_CMD_NOT_USED)
-		return 1;
-	if (ioc->transport_cmds.smid != smid)
-		return 1;
-	ioc->transport_cmds.status |= MPT2_CMD_COMPLETE;
-	if (mpi_reply) {
-		memcpy(ioc->transport_cmds.reply, mpi_reply,
-		    mpi_reply->MsgLength*4);
-		ioc->transport_cmds.status |= MPT2_CMD_REPLY_VALID;
-	}
-	ioc->transport_cmds.status &= ~MPT2_CMD_PENDING;
-	complete(&ioc->transport_cmds.done);
-	return 1;
-}
-
-/* report manufacture request structure */
-struct rep_manu_request{
-	u8 smp_frame_type;
-	u8 function;
-	u8 reserved;
-	u8 request_length;
-};
-
-/* report manufacture reply structure */
-struct rep_manu_reply{
-	u8 smp_frame_type; /* 0x41 */
-	u8 function; /* 0x01 */
-	u8 function_result;
-	u8 response_length;
-	u16 expander_change_count;
-	u8 reserved0[2];
-	u8 sas_format;
-	u8 reserved2[3];
-	u8 vendor_id[SAS_EXPANDER_VENDOR_ID_LEN];
-	u8 product_id[SAS_EXPANDER_PRODUCT_ID_LEN];
-	u8 product_rev[SAS_EXPANDER_PRODUCT_REV_LEN];
-	u8 component_vendor_id[SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN];
-	u16 component_id;
-	u8 component_revision_id;
-	u8 reserved3;
-	u8 vendor_specific[8];
-};
-
-/**
- * _transport_expander_report_manufacture - obtain SMP report_manufacture
- * @ioc: per adapter object
- * @sas_address: expander sas address
- * @edev: the sas_expander_device object
- *
- * Fills in the sas_expander_device object when SMP port is created.
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_transport_expander_report_manufacture(struct MPT2SAS_ADAPTER *ioc,
-    u64 sas_address, struct sas_expander_device *edev)
-{
-	Mpi2SmpPassthroughRequest_t *mpi_request;
-	Mpi2SmpPassthroughReply_t *mpi_reply;
-	struct rep_manu_reply *manufacture_reply;
-	struct rep_manu_request *manufacture_request;
-	int rc;
-	u16 smid;
-	u32 ioc_state;
-	unsigned long timeleft;
-	void *psge;
-	u32 sgl_flags;
-	u8 issue_reset = 0;
-	void *data_out = NULL;
-	dma_addr_t data_out_dma;
-	u32 sz;
-	u16 wait_state_count;
-
-	if (ioc->shost_recovery || ioc->pci_error_recovery) {
-		printk(MPT2SAS_INFO_FMT "%s: host reset in progress!\n",
-		    __func__, ioc->name);
-		return -EFAULT;
-	}
-
-	mutex_lock(&ioc->transport_cmds.mutex);
-
-	if (ioc->transport_cmds.status != MPT2_CMD_NOT_USED) {
-		printk(MPT2SAS_ERR_FMT "%s: transport_cmds in use\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-	ioc->transport_cmds.status = MPT2_CMD_PENDING;
-
-	wait_state_count = 0;
-	ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
-		if (wait_state_count++ == 10) {
-			printk(MPT2SAS_ERR_FMT
-			    "%s: failed due to ioc not operational\n",
-			    ioc->name, __func__);
-			rc = -EFAULT;
-			goto out;
-		}
-		ssleep(1);
-		ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-		printk(MPT2SAS_INFO_FMT "%s: waiting for "
-		    "operational state(count=%d)\n", ioc->name,
-		    __func__, wait_state_count);
-	}
-	if (wait_state_count)
-		printk(MPT2SAS_INFO_FMT "%s: ioc is operational\n",
-		    ioc->name, __func__);
-
-	smid = mpt2sas_base_get_smid(ioc, ioc->transport_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-
-	rc = 0;
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	ioc->transport_cmds.smid = smid;
-
-	sz = sizeof(struct rep_manu_request) + sizeof(struct rep_manu_reply);
-	data_out = pci_alloc_consistent(ioc->pdev, sz, &data_out_dma);
-
-	if (!data_out) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,
-		    __LINE__, __func__);
-		rc = -ENOMEM;
-		mpt2sas_base_free_smid(ioc, smid);
-		goto out;
-	}
-
-	manufacture_request = data_out;
-	manufacture_request->smp_frame_type = 0x40;
-	manufacture_request->function = 1;
-	manufacture_request->reserved = 0;
-	manufacture_request->request_length = 0;
-
-	memset(mpi_request, 0, sizeof(Mpi2SmpPassthroughRequest_t));
-	mpi_request->Function = MPI2_FUNCTION_SMP_PASSTHROUGH;
-	mpi_request->PhysicalPort = 0xFF;
-	mpi_request->VF_ID = 0; /* TODO */
-	mpi_request->VP_ID = 0;
-	mpi_request->SASAddress = cpu_to_le64(sas_address);
-	mpi_request->RequestDataLength =
-	    cpu_to_le16(sizeof(struct rep_manu_request));
-	psge = &mpi_request->SGL;
-
-	/* WRITE sgel first */
-	sgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |
-	    MPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_HOST_TO_IOC);
-	sgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;
-	ioc->base_add_sg_single(psge, sgl_flags |
-	    sizeof(struct rep_manu_request), data_out_dma);
-
-	/* incr sgel */
-	psge += ioc->sge_size;
-
-	/* READ sgel last */
-	sgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |
-	    MPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |
-	    MPI2_SGE_FLAGS_END_OF_LIST);
-	sgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;
-	ioc->base_add_sg_single(psge, sgl_flags |
-	    sizeof(struct rep_manu_reply), data_out_dma +
-	    sizeof(struct rep_manu_request));
-
-	dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT "report_manufacture - "
-	    "send to sas_addr(0x%016llx)\n", ioc->name,
-	    (unsigned long long)sas_address));
-	init_completion(&ioc->transport_cmds.done);
-	mpt2sas_base_put_smid_default(ioc, smid);
-	timeleft = wait_for_completion_timeout(&ioc->transport_cmds.done,
-	    10*HZ);
-
-	if (!(ioc->transport_cmds.status & MPT2_CMD_COMPLETE)) {
-		printk(MPT2SAS_ERR_FMT "%s: timeout\n",
-		    ioc->name, __func__);
-		_debug_dump_mf(mpi_request,
-		    sizeof(Mpi2SmpPassthroughRequest_t)/4);
-		if (!(ioc->transport_cmds.status & MPT2_CMD_RESET))
-			issue_reset = 1;
-		goto issue_host_reset;
-	}
-
-	dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT "report_manufacture - "
-	    "complete\n", ioc->name));
-
-	if (ioc->transport_cmds.status & MPT2_CMD_REPLY_VALID) {
-		u8 *tmp;
-
-		mpi_reply = ioc->transport_cmds.reply;
-
-		dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "report_manufacture - reply data transfer size(%d)\n",
-		    ioc->name, le16_to_cpu(mpi_reply->ResponseDataLength)));
-
-		if (le16_to_cpu(mpi_reply->ResponseDataLength) !=
-		    sizeof(struct rep_manu_reply))
-			goto out;
-
-		manufacture_reply = data_out + sizeof(struct rep_manu_request);
-		strncpy(edev->vendor_id, manufacture_reply->vendor_id,
-		     SAS_EXPANDER_VENDOR_ID_LEN);
-		strncpy(edev->product_id, manufacture_reply->product_id,
-		     SAS_EXPANDER_PRODUCT_ID_LEN);
-		strncpy(edev->product_rev, manufacture_reply->product_rev,
-		     SAS_EXPANDER_PRODUCT_REV_LEN);
-		edev->level = manufacture_reply->sas_format & 1;
-		if (edev->level) {
-			strncpy(edev->component_vendor_id,
-			    manufacture_reply->component_vendor_id,
-			     SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN);
-			tmp = (u8 *)&manufacture_reply->component_id;
-			edev->component_id = tmp[0] << 8 | tmp[1];
-			edev->component_revision_id =
-			    manufacture_reply->component_revision_id;
-		}
-	} else
-		dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "report_manufacture - no reply\n", ioc->name));
-
- issue_host_reset:
-	if (issue_reset)
-		mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-		    FORCE_BIG_HAMMER);
- out:
-	ioc->transport_cmds.status = MPT2_CMD_NOT_USED;
-	if (data_out)
-		pci_free_consistent(ioc->pdev, sz, data_out, data_out_dma);
-
-	mutex_unlock(&ioc->transport_cmds.mutex);
-	return rc;
-}
-
-/**
- * _transport_delete_port - helper function to removing a port
- * @ioc: per adapter object
- * @mpt2sas_port: mpt2sas per port object
- *
- * Returns nothing.
- */
-static void
-_transport_delete_port(struct MPT2SAS_ADAPTER *ioc,
-	struct _sas_port *mpt2sas_port)
-{
-	u64 sas_address = mpt2sas_port->remote_identify.sas_address;
-	enum sas_device_type device_type =
-	    mpt2sas_port->remote_identify.device_type;
-
-	dev_printk(KERN_INFO, &mpt2sas_port->port->dev,
-	    "remove: sas_addr(0x%016llx)\n",
-	    (unsigned long long) sas_address);
-
-	ioc->logging_level |= MPT_DEBUG_TRANSPORT;
-	if (device_type == SAS_END_DEVICE)
-		mpt2sas_device_remove_by_sas_address(ioc, sas_address);
-	else if (device_type == SAS_EDGE_EXPANDER_DEVICE ||
-	    device_type == SAS_FANOUT_EXPANDER_DEVICE)
-		mpt2sas_expander_remove(ioc, sas_address);
-	ioc->logging_level &= ~MPT_DEBUG_TRANSPORT;
-}
-
-/**
- * _transport_delete_phy - helper function to removing single phy from port
- * @ioc: per adapter object
- * @mpt2sas_port: mpt2sas per port object
- * @mpt2sas_phy: mpt2sas per phy object
- *
- * Returns nothing.
- */
-static void
-_transport_delete_phy(struct MPT2SAS_ADAPTER *ioc,
-	struct _sas_port *mpt2sas_port, struct _sas_phy *mpt2sas_phy)
-{
-	u64 sas_address = mpt2sas_port->remote_identify.sas_address;
-
-	dev_printk(KERN_INFO, &mpt2sas_phy->phy->dev,
-	    "remove: sas_addr(0x%016llx), phy(%d)\n",
-	    (unsigned long long) sas_address, mpt2sas_phy->phy_id);
-
-	list_del(&mpt2sas_phy->port_siblings);
-	mpt2sas_port->num_phys--;
-	sas_port_delete_phy(mpt2sas_port->port, mpt2sas_phy->phy);
-	mpt2sas_phy->phy_belongs_to_port = 0;
-}
-
-/**
- * _transport_add_phy - helper function to adding single phy to port
- * @ioc: per adapter object
- * @mpt2sas_port: mpt2sas per port object
- * @mpt2sas_phy: mpt2sas per phy object
- *
- * Returns nothing.
- */
-static void
-_transport_add_phy(struct MPT2SAS_ADAPTER *ioc, struct _sas_port *mpt2sas_port,
-	struct _sas_phy *mpt2sas_phy)
-{
-	u64 sas_address = mpt2sas_port->remote_identify.sas_address;
-
-	dev_printk(KERN_INFO, &mpt2sas_phy->phy->dev,
-	    "add: sas_addr(0x%016llx), phy(%d)\n", (unsigned long long)
-	    sas_address, mpt2sas_phy->phy_id);
-
-	list_add_tail(&mpt2sas_phy->port_siblings, &mpt2sas_port->phy_list);
-	mpt2sas_port->num_phys++;
-	sas_port_add_phy(mpt2sas_port->port, mpt2sas_phy->phy);
-	mpt2sas_phy->phy_belongs_to_port = 1;
-}
-
-/**
- * _transport_add_phy_to_an_existing_port - adding new phy to existing port
- * @ioc: per adapter object
- * @sas_node: sas node object (either expander or sas host)
- * @mpt2sas_phy: mpt2sas per phy object
- * @sas_address: sas address of device/expander were phy needs to be added to
- *
- * Returns nothing.
- */
-static void
-_transport_add_phy_to_an_existing_port(struct MPT2SAS_ADAPTER *ioc,
-struct _sas_node *sas_node, struct _sas_phy *mpt2sas_phy, u64 sas_address)
-{
-	struct _sas_port *mpt2sas_port;
-	struct _sas_phy *phy_srch;
-
-	if (mpt2sas_phy->phy_belongs_to_port == 1)
-		return;
-
-	list_for_each_entry(mpt2sas_port, &sas_node->sas_port_list,
-	    port_list) {
-		if (mpt2sas_port->remote_identify.sas_address !=
-		    sas_address)
-			continue;
-		list_for_each_entry(phy_srch, &mpt2sas_port->phy_list,
-		    port_siblings) {
-			if (phy_srch == mpt2sas_phy)
-				return;
-		}
-		_transport_add_phy(ioc, mpt2sas_port, mpt2sas_phy);
-			return;
-	}
-
-}
-
-/**
- * _transport_del_phy_from_an_existing_port - delete phy from existing port
- * @ioc: per adapter object
- * @sas_node: sas node object (either expander or sas host)
- * @mpt2sas_phy: mpt2sas per phy object
- *
- * Returns nothing.
- */
-static void
-_transport_del_phy_from_an_existing_port(struct MPT2SAS_ADAPTER *ioc,
-	struct _sas_node *sas_node, struct _sas_phy *mpt2sas_phy)
-{
-	struct _sas_port *mpt2sas_port, *next;
-	struct _sas_phy *phy_srch;
-
-	if (mpt2sas_phy->phy_belongs_to_port == 0)
-		return;
-
-	list_for_each_entry_safe(mpt2sas_port, next, &sas_node->sas_port_list,
-	    port_list) {
-		list_for_each_entry(phy_srch, &mpt2sas_port->phy_list,
-		    port_siblings) {
-			if (phy_srch != mpt2sas_phy)
-				continue;
-			if (mpt2sas_port->num_phys == 1)
-				_transport_delete_port(ioc, mpt2sas_port);
-			else
-				_transport_delete_phy(ioc, mpt2sas_port,
-				    mpt2sas_phy);
-			return;
-		}
-	}
-}
-
-/**
- * _transport_sanity_check - sanity check when adding a new port
- * @ioc: per adapter object
- * @sas_node: sas node object (either expander or sas host)
- * @sas_address: sas address of device being added
- *
- * See the explanation above from _transport_delete_duplicate_port
- */
-static void
-_transport_sanity_check(struct MPT2SAS_ADAPTER *ioc, struct _sas_node *sas_node,
-     u64 sas_address)
-{
-	int i;
-
-	for (i = 0; i < sas_node->num_phys; i++) {
-		if (sas_node->phy[i].remote_identify.sas_address != sas_address)
-			continue;
-		if (sas_node->phy[i].phy_belongs_to_port == 1)
-			_transport_del_phy_from_an_existing_port(ioc, sas_node,
-			    &sas_node->phy[i]);
-	}
-}
-
-/**
- * mpt2sas_transport_port_add - insert port to the list
- * @ioc: per adapter object
- * @handle: handle of attached device
- * @sas_address: sas address of parent expander or sas host
- * Context: This function will acquire ioc->sas_node_lock.
- *
- * Adding new port object to the sas_node->sas_port_list.
- *
- * Returns mpt2sas_port.
- */
-struct _sas_port *
-mpt2sas_transport_port_add(struct MPT2SAS_ADAPTER *ioc, u16 handle,
-    u64 sas_address)
-{
-	struct _sas_phy *mpt2sas_phy, *next;
-	struct _sas_port *mpt2sas_port;
-	unsigned long flags;
-	struct _sas_node *sas_node;
-	struct sas_rphy *rphy;
-	int i;
-	struct sas_port *port;
-
-	mpt2sas_port = kzalloc(sizeof(struct _sas_port),
-	    GFP_KERNEL);
-	if (!mpt2sas_port) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return NULL;
-	}
-
-	INIT_LIST_HEAD(&mpt2sas_port->port_list);
-	INIT_LIST_HEAD(&mpt2sas_port->phy_list);
-	spin_lock_irqsave(&ioc->sas_node_lock, flags);
-	sas_node = _transport_sas_node_find_by_sas_address(ioc, sas_address);
-	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-
-	if (!sas_node) {
-		printk(MPT2SAS_ERR_FMT "%s: Could not find "
-		    "parent sas_address(0x%016llx)!\n", ioc->name,
-		    __func__, (unsigned long long)sas_address);
-		goto out_fail;
-	}
-
-	if ((_transport_set_identify(ioc, handle,
-	    &mpt2sas_port->remote_identify))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out_fail;
-	}
-
-	if (mpt2sas_port->remote_identify.device_type == SAS_PHY_UNUSED) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out_fail;
-	}
-
-	_transport_sanity_check(ioc, sas_node,
-	    mpt2sas_port->remote_identify.sas_address);
-
-	for (i = 0; i < sas_node->num_phys; i++) {
-		if (sas_node->phy[i].remote_identify.sas_address !=
-		    mpt2sas_port->remote_identify.sas_address)
-			continue;
-		list_add_tail(&sas_node->phy[i].port_siblings,
-		    &mpt2sas_port->phy_list);
-		mpt2sas_port->num_phys++;
-	}
-
-	if (!mpt2sas_port->num_phys) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out_fail;
-	}
-
-	port = sas_port_alloc_num(sas_node->parent_dev);
-	if ((sas_port_add(port))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		goto out_fail;
-	}
-
-	list_for_each_entry(mpt2sas_phy, &mpt2sas_port->phy_list,
-	    port_siblings) {
-		if ((ioc->logging_level & MPT_DEBUG_TRANSPORT))
-			dev_printk(KERN_INFO, &port->dev, "add: handle(0x%04x)"
-			    ", sas_addr(0x%016llx), phy(%d)\n", handle,
-			    (unsigned long long)
-			    mpt2sas_port->remote_identify.sas_address,
-			    mpt2sas_phy->phy_id);
-		sas_port_add_phy(port, mpt2sas_phy->phy);
-		mpt2sas_phy->phy_belongs_to_port = 1;
-	}
-
-	mpt2sas_port->port = port;
-	if (mpt2sas_port->remote_identify.device_type == SAS_END_DEVICE)
-		rphy = sas_end_device_alloc(port);
-	else
-		rphy = sas_expander_alloc(port,
-		    mpt2sas_port->remote_identify.device_type);
-
-	rphy->identify = mpt2sas_port->remote_identify;
-	if ((sas_rphy_add(rphy))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-	}
-	if ((ioc->logging_level & MPT_DEBUG_TRANSPORT))
-		dev_printk(KERN_INFO, &rphy->dev, "add: handle(0x%04x), "
-		    "sas_addr(0x%016llx)\n", handle,
-		    (unsigned long long)
-		    mpt2sas_port->remote_identify.sas_address);
-	mpt2sas_port->rphy = rphy;
-	spin_lock_irqsave(&ioc->sas_node_lock, flags);
-	list_add_tail(&mpt2sas_port->port_list, &sas_node->sas_port_list);
-	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-
-	/* fill in report manufacture */
-	if (mpt2sas_port->remote_identify.device_type ==
-	    MPI2_SAS_DEVICE_INFO_EDGE_EXPANDER ||
-	    mpt2sas_port->remote_identify.device_type ==
-	    MPI2_SAS_DEVICE_INFO_FANOUT_EXPANDER)
-		_transport_expander_report_manufacture(ioc,
-		    mpt2sas_port->remote_identify.sas_address,
-		    rphy_to_expander_device(rphy));
-
-	return mpt2sas_port;
-
- out_fail:
-	list_for_each_entry_safe(mpt2sas_phy, next, &mpt2sas_port->phy_list,
-	    port_siblings)
-		list_del(&mpt2sas_phy->port_siblings);
-	kfree(mpt2sas_port);
-	return NULL;
-}
-
-/**
- * mpt2sas_transport_port_remove - remove port from the list
- * @ioc: per adapter object
- * @sas_address: sas address of attached device
- * @sas_address_parent: sas address of parent expander or sas host
- * Context: This function will acquire ioc->sas_node_lock.
- *
- * Removing object and freeing associated memory from the
- * ioc->sas_port_list.
- *
- * Return nothing.
- */
-void
-mpt2sas_transport_port_remove(struct MPT2SAS_ADAPTER *ioc, u64 sas_address,
-    u64 sas_address_parent)
-{
-	int i;
-	unsigned long flags;
-	struct _sas_port *mpt2sas_port, *next;
-	struct _sas_node *sas_node;
-	u8 found = 0;
-	struct _sas_phy *mpt2sas_phy, *next_phy;
-
-	spin_lock_irqsave(&ioc->sas_node_lock, flags);
-	sas_node = _transport_sas_node_find_by_sas_address(ioc,
-	    sas_address_parent);
-	if (!sas_node) {
-		spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-		return;
-	}
-	list_for_each_entry_safe(mpt2sas_port, next, &sas_node->sas_port_list,
-	    port_list) {
-		if (mpt2sas_port->remote_identify.sas_address != sas_address)
-			continue;
-		found = 1;
-		list_del(&mpt2sas_port->port_list);
-		goto out;
-	}
- out:
-	if (!found) {
-		spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-		return;
-	}
-
-	for (i = 0; i < sas_node->num_phys; i++) {
-		if (sas_node->phy[i].remote_identify.sas_address == sas_address)
-			memset(&sas_node->phy[i].remote_identify, 0 ,
-			    sizeof(struct sas_identify));
-	}
-
-	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-	list_for_each_entry_safe(mpt2sas_phy, next_phy,
-	    &mpt2sas_port->phy_list, port_siblings) {
-		if ((ioc->logging_level & MPT_DEBUG_TRANSPORT))
-			dev_printk(KERN_INFO, &mpt2sas_port->port->dev,
-			    "remove: sas_addr(0x%016llx), phy(%d)\n",
-			    (unsigned long long)
-			    mpt2sas_port->remote_identify.sas_address,
-			    mpt2sas_phy->phy_id);
-		mpt2sas_phy->phy_belongs_to_port = 0;
-		sas_port_delete_phy(mpt2sas_port->port, mpt2sas_phy->phy);
-		list_del(&mpt2sas_phy->port_siblings);
-	}
-	sas_port_delete(mpt2sas_port->port);
-	kfree(mpt2sas_port);
-}
-
-/**
- * mpt2sas_transport_add_host_phy - report sas_host phy to transport
- * @ioc: per adapter object
- * @mpt2sas_phy: mpt2sas per phy object
- * @phy_pg0: sas phy page 0
- * @parent_dev: parent device class object
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_transport_add_host_phy(struct MPT2SAS_ADAPTER *ioc, struct _sas_phy
-    *mpt2sas_phy, Mpi2SasPhyPage0_t phy_pg0, struct device *parent_dev)
-{
-	struct sas_phy *phy;
-	int phy_index = mpt2sas_phy->phy_id;
-
-
-	INIT_LIST_HEAD(&mpt2sas_phy->port_siblings);
-	phy = sas_phy_alloc(parent_dev, phy_index);
-	if (!phy) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return -1;
-	}
-	if ((_transport_set_identify(ioc, mpt2sas_phy->handle,
-	    &mpt2sas_phy->identify))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return -1;
-	}
-	phy->identify = mpt2sas_phy->identify;
-	mpt2sas_phy->attached_handle = le16_to_cpu(phy_pg0.AttachedDevHandle);
-	if (mpt2sas_phy->attached_handle)
-		_transport_set_identify(ioc, mpt2sas_phy->attached_handle,
-		    &mpt2sas_phy->remote_identify);
-	phy->identify.phy_identifier = mpt2sas_phy->phy_id;
-	phy->negotiated_linkrate = _transport_convert_phy_link_rate(
-	    phy_pg0.NegotiatedLinkRate & MPI2_SAS_NEG_LINK_RATE_MASK_PHYSICAL);
-	phy->minimum_linkrate_hw = _transport_convert_phy_link_rate(
-	    phy_pg0.HwLinkRate & MPI2_SAS_HWRATE_MIN_RATE_MASK);
-	phy->maximum_linkrate_hw = _transport_convert_phy_link_rate(
-	    phy_pg0.HwLinkRate >> 4);
-	phy->minimum_linkrate = _transport_convert_phy_link_rate(
-	    phy_pg0.ProgrammedLinkRate & MPI2_SAS_PRATE_MIN_RATE_MASK);
-	phy->maximum_linkrate = _transport_convert_phy_link_rate(
-	    phy_pg0.ProgrammedLinkRate >> 4);
-
-	if ((sas_phy_add(phy))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		sas_phy_free(phy);
-		return -1;
-	}
-	if ((ioc->logging_level & MPT_DEBUG_TRANSPORT))
-		dev_printk(KERN_INFO, &phy->dev,
-		    "add: handle(0x%04x), sas_addr(0x%016llx)\n"
-		    "\tattached_handle(0x%04x), sas_addr(0x%016llx)\n",
-		    mpt2sas_phy->handle, (unsigned long long)
-		    mpt2sas_phy->identify.sas_address,
-		    mpt2sas_phy->attached_handle,
-		    (unsigned long long)
-		    mpt2sas_phy->remote_identify.sas_address);
-	mpt2sas_phy->phy = phy;
-	return 0;
-}
-
-
-/**
- * mpt2sas_transport_add_expander_phy - report expander phy to transport
- * @ioc: per adapter object
- * @mpt2sas_phy: mpt2sas per phy object
- * @expander_pg1: expander page 1
- * @parent_dev: parent device class object
- *
- * Returns 0 for success, non-zero for failure.
- */
-int
-mpt2sas_transport_add_expander_phy(struct MPT2SAS_ADAPTER *ioc, struct _sas_phy
-    *mpt2sas_phy, Mpi2ExpanderPage1_t expander_pg1, struct device *parent_dev)
-{
-	struct sas_phy *phy;
-	int phy_index = mpt2sas_phy->phy_id;
-
-	INIT_LIST_HEAD(&mpt2sas_phy->port_siblings);
-	phy = sas_phy_alloc(parent_dev, phy_index);
-	if (!phy) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return -1;
-	}
-	if ((_transport_set_identify(ioc, mpt2sas_phy->handle,
-	    &mpt2sas_phy->identify))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return -1;
-	}
-	phy->identify = mpt2sas_phy->identify;
-	mpt2sas_phy->attached_handle =
-	    le16_to_cpu(expander_pg1.AttachedDevHandle);
-	if (mpt2sas_phy->attached_handle)
-		_transport_set_identify(ioc, mpt2sas_phy->attached_handle,
-		    &mpt2sas_phy->remote_identify);
-	phy->identify.phy_identifier = mpt2sas_phy->phy_id;
-	phy->negotiated_linkrate = _transport_convert_phy_link_rate(
-	    expander_pg1.NegotiatedLinkRate &
-	    MPI2_SAS_NEG_LINK_RATE_MASK_PHYSICAL);
-	phy->minimum_linkrate_hw = _transport_convert_phy_link_rate(
-	    expander_pg1.HwLinkRate & MPI2_SAS_HWRATE_MIN_RATE_MASK);
-	phy->maximum_linkrate_hw = _transport_convert_phy_link_rate(
-	    expander_pg1.HwLinkRate >> 4);
-	phy->minimum_linkrate = _transport_convert_phy_link_rate(
-	    expander_pg1.ProgrammedLinkRate & MPI2_SAS_PRATE_MIN_RATE_MASK);
-	phy->maximum_linkrate = _transport_convert_phy_link_rate(
-	    expander_pg1.ProgrammedLinkRate >> 4);
-
-	if ((sas_phy_add(phy))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		sas_phy_free(phy);
-		return -1;
-	}
-	if ((ioc->logging_level & MPT_DEBUG_TRANSPORT))
-		dev_printk(KERN_INFO, &phy->dev,
-		    "add: handle(0x%04x), sas_addr(0x%016llx)\n"
-		    "\tattached_handle(0x%04x), sas_addr(0x%016llx)\n",
-		    mpt2sas_phy->handle, (unsigned long long)
-		    mpt2sas_phy->identify.sas_address,
-		    mpt2sas_phy->attached_handle,
-		    (unsigned long long)
-		    mpt2sas_phy->remote_identify.sas_address);
-	mpt2sas_phy->phy = phy;
-	return 0;
-}
-
-/**
- * mpt2sas_transport_update_links - refreshing phy link changes
- * @ioc: per adapter object
- * @sas_address: sas address of parent expander or sas host
- * @handle: attached device handle
- * @phy_numberv: phy number
- * @link_rate: new link rate
- *
- * Returns nothing.
- */
-void
-mpt2sas_transport_update_links(struct MPT2SAS_ADAPTER *ioc,
-     u64 sas_address, u16 handle, u8 phy_number, u8 link_rate)
-{
-	unsigned long flags;
-	struct _sas_node *sas_node;
-	struct _sas_phy *mpt2sas_phy;
-
-	if (ioc->shost_recovery || ioc->pci_error_recovery)
-		return;
-
-	spin_lock_irqsave(&ioc->sas_node_lock, flags);
-	sas_node = _transport_sas_node_find_by_sas_address(ioc, sas_address);
-	if (!sas_node) {
-		spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-		return;
-	}
-
-	mpt2sas_phy = &sas_node->phy[phy_number];
-	mpt2sas_phy->attached_handle = handle;
-	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-	if (handle && (link_rate >= MPI2_SAS_NEG_LINK_RATE_1_5)) {
-		_transport_set_identify(ioc, handle,
-		    &mpt2sas_phy->remote_identify);
-		_transport_add_phy_to_an_existing_port(ioc, sas_node,
-		    mpt2sas_phy, mpt2sas_phy->remote_identify.sas_address);
-	} else
-		memset(&mpt2sas_phy->remote_identify, 0 , sizeof(struct
-		    sas_identify));
-
-	if (mpt2sas_phy->phy)
-		mpt2sas_phy->phy->negotiated_linkrate =
-		    _transport_convert_phy_link_rate(link_rate);
-
-	if ((ioc->logging_level & MPT_DEBUG_TRANSPORT))
-		dev_printk(KERN_INFO, &mpt2sas_phy->phy->dev,
-		    "refresh: parent sas_addr(0x%016llx),\n"
-		    "\tlink_rate(0x%02x), phy(%d)\n"
-		    "\tattached_handle(0x%04x), sas_addr(0x%016llx)\n",
-		    (unsigned long long)sas_address,
-		    link_rate, phy_number, handle, (unsigned long long)
-		    mpt2sas_phy->remote_identify.sas_address);
-}
-
-static inline void *
-phy_to_ioc(struct sas_phy *phy)
-{
-	struct Scsi_Host *shost = dev_to_shost(phy->dev.parent);
-	return shost_priv(shost);
-}
-
-static inline void *
-rphy_to_ioc(struct sas_rphy *rphy)
-{
-	struct Scsi_Host *shost = dev_to_shost(rphy->dev.parent->parent);
-	return shost_priv(shost);
-}
-
-
-/* report phy error log structure */
-struct phy_error_log_request{
-	u8 smp_frame_type; /* 0x40 */
-	u8 function; /* 0x11 */
-	u8 allocated_response_length;
-	u8 request_length; /* 02 */
-	u8 reserved_1[5];
-	u8 phy_identifier;
-	u8 reserved_2[2];
-};
-
-/* report phy error log reply structure */
-struct phy_error_log_reply{
-	u8 smp_frame_type; /* 0x41 */
-	u8 function; /* 0x11 */
-	u8 function_result;
-	u8 response_length;
-	__be16 expander_change_count;
-	u8 reserved_1[3];
-	u8 phy_identifier;
-	u8 reserved_2[2];
-	__be32 invalid_dword;
-	__be32 running_disparity_error;
-	__be32 loss_of_dword_sync;
-	__be32 phy_reset_problem;
-};
-
-/**
- * _transport_get_expander_phy_error_log - return expander counters
- * @ioc: per adapter object
- * @phy: The sas phy object
- *
- * Returns 0 for success, non-zero for failure.
- *
- */
-static int
-_transport_get_expander_phy_error_log(struct MPT2SAS_ADAPTER *ioc,
-    struct sas_phy *phy)
-{
-	Mpi2SmpPassthroughRequest_t *mpi_request;
-	Mpi2SmpPassthroughReply_t *mpi_reply;
-	struct phy_error_log_request *phy_error_log_request;
-	struct phy_error_log_reply *phy_error_log_reply;
-	int rc;
-	u16 smid;
-	u32 ioc_state;
-	unsigned long timeleft;
-	void *psge;
-	u32 sgl_flags;
-	u8 issue_reset = 0;
-	void *data_out = NULL;
-	dma_addr_t data_out_dma;
-	u32 sz;
-	u16 wait_state_count;
-
-	if (ioc->shost_recovery || ioc->pci_error_recovery) {
-		printk(MPT2SAS_INFO_FMT "%s: host reset in progress!\n",
-		    __func__, ioc->name);
-		return -EFAULT;
-	}
-
-	mutex_lock(&ioc->transport_cmds.mutex);
-
-	if (ioc->transport_cmds.status != MPT2_CMD_NOT_USED) {
-		printk(MPT2SAS_ERR_FMT "%s: transport_cmds in use\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-	ioc->transport_cmds.status = MPT2_CMD_PENDING;
-
-	wait_state_count = 0;
-	ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
-		if (wait_state_count++ == 10) {
-			printk(MPT2SAS_ERR_FMT
-			    "%s: failed due to ioc not operational\n",
-			    ioc->name, __func__);
-			rc = -EFAULT;
-			goto out;
-		}
-		ssleep(1);
-		ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-		printk(MPT2SAS_INFO_FMT "%s: waiting for "
-		    "operational state(count=%d)\n", ioc->name,
-		    __func__, wait_state_count);
-	}
-	if (wait_state_count)
-		printk(MPT2SAS_INFO_FMT "%s: ioc is operational\n",
-		    ioc->name, __func__);
-
-	smid = mpt2sas_base_get_smid(ioc, ioc->transport_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	ioc->transport_cmds.smid = smid;
-
-	sz = sizeof(struct phy_error_log_request) +
-	    sizeof(struct phy_error_log_reply);
-	data_out = pci_alloc_consistent(ioc->pdev, sz, &data_out_dma);
-	if (!data_out) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,
-		    __LINE__, __func__);
-		rc = -ENOMEM;
-		mpt2sas_base_free_smid(ioc, smid);
-		goto out;
-	}
-
-	rc = -EINVAL;
-	memset(data_out, 0, sz);
-	phy_error_log_request = data_out;
-	phy_error_log_request->smp_frame_type = 0x40;
-	phy_error_log_request->function = 0x11;
-	phy_error_log_request->request_length = 2;
-	phy_error_log_request->allocated_response_length = 0;
-	phy_error_log_request->phy_identifier = phy->number;
-
-	memset(mpi_request, 0, sizeof(Mpi2SmpPassthroughRequest_t));
-	mpi_request->Function = MPI2_FUNCTION_SMP_PASSTHROUGH;
-	mpi_request->PhysicalPort = 0xFF;
-	mpi_request->VF_ID = 0; /* TODO */
-	mpi_request->VP_ID = 0;
-	mpi_request->SASAddress = cpu_to_le64(phy->identify.sas_address);
-	mpi_request->RequestDataLength =
-	    cpu_to_le16(sizeof(struct phy_error_log_request));
-	psge = &mpi_request->SGL;
-
-	/* WRITE sgel first */
-	sgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |
-	    MPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_HOST_TO_IOC);
-	sgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;
-	ioc->base_add_sg_single(psge, sgl_flags |
-	    sizeof(struct phy_error_log_request), data_out_dma);
-
-	/* incr sgel */
-	psge += ioc->sge_size;
-
-	/* READ sgel last */
-	sgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |
-	    MPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |
-	    MPI2_SGE_FLAGS_END_OF_LIST);
-	sgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;
-	ioc->base_add_sg_single(psge, sgl_flags |
-	    sizeof(struct phy_error_log_reply), data_out_dma +
-	    sizeof(struct phy_error_log_request));
-
-	dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT "phy_error_log - "
-	    "send to sas_addr(0x%016llx), phy(%d)\n", ioc->name,
-	    (unsigned long long)phy->identify.sas_address, phy->number));
-	init_completion(&ioc->transport_cmds.done);
-	mpt2sas_base_put_smid_default(ioc, smid);
-	timeleft = wait_for_completion_timeout(&ioc->transport_cmds.done,
-	    10*HZ);
-
-	if (!(ioc->transport_cmds.status & MPT2_CMD_COMPLETE)) {
-		printk(MPT2SAS_ERR_FMT "%s: timeout\n",
-		    ioc->name, __func__);
-		_debug_dump_mf(mpi_request,
-		    sizeof(Mpi2SmpPassthroughRequest_t)/4);
-		if (!(ioc->transport_cmds.status & MPT2_CMD_RESET))
-			issue_reset = 1;
-		goto issue_host_reset;
-	}
-
-	dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT "phy_error_log - "
-	    "complete\n", ioc->name));
-
-	if (ioc->transport_cmds.status & MPT2_CMD_REPLY_VALID) {
-
-		mpi_reply = ioc->transport_cmds.reply;
-
-		dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "phy_error_log - reply data transfer size(%d)\n",
-		    ioc->name, le16_to_cpu(mpi_reply->ResponseDataLength)));
-
-		if (le16_to_cpu(mpi_reply->ResponseDataLength) !=
-		    sizeof(struct phy_error_log_reply))
-			goto out;
-
-		phy_error_log_reply = data_out +
-		    sizeof(struct phy_error_log_request);
-
-		dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "phy_error_log - function_result(%d)\n",
-		    ioc->name, phy_error_log_reply->function_result));
-
-		phy->invalid_dword_count =
-		    be32_to_cpu(phy_error_log_reply->invalid_dword);
-		phy->running_disparity_error_count =
-		    be32_to_cpu(phy_error_log_reply->running_disparity_error);
-		phy->loss_of_dword_sync_count =
-		    be32_to_cpu(phy_error_log_reply->loss_of_dword_sync);
-		phy->phy_reset_problem_count =
-		    be32_to_cpu(phy_error_log_reply->phy_reset_problem);
-		rc = 0;
-	} else
-		dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "phy_error_log - no reply\n", ioc->name));
-
- issue_host_reset:
-	if (issue_reset)
-		mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-		    FORCE_BIG_HAMMER);
- out:
-	ioc->transport_cmds.status = MPT2_CMD_NOT_USED;
-	if (data_out)
-		pci_free_consistent(ioc->pdev, sz, data_out, data_out_dma);
-
-	mutex_unlock(&ioc->transport_cmds.mutex);
-	return rc;
-}
-
-/**
- * _transport_get_linkerrors - return phy counters for both hba and expanders
- * @phy: The sas phy object
- *
- * Returns 0 for success, non-zero for failure.
- *
- */
-static int
-_transport_get_linkerrors(struct sas_phy *phy)
-{
-	struct MPT2SAS_ADAPTER *ioc = phy_to_ioc(phy);
-	unsigned long flags;
-	Mpi2ConfigReply_t mpi_reply;
-	Mpi2SasPhyPage1_t phy_pg1;
-
-	spin_lock_irqsave(&ioc->sas_node_lock, flags);
-	if (_transport_sas_node_find_by_sas_address(ioc,
-	    phy->identify.sas_address) == NULL) {
-		spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-		return -EINVAL;
-	}
-	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-
-	if (phy->identify.sas_address != ioc->sas_hba.sas_address)
-		return _transport_get_expander_phy_error_log(ioc, phy);
-
-	/* get hba phy error logs */
-	if ((mpt2sas_config_get_phy_pg1(ioc, &mpi_reply, &phy_pg1,
-		    phy->number))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return -ENXIO;
-	}
-
-	if (mpi_reply.IOCStatus || mpi_reply.IOCLogInfo)
-		printk(MPT2SAS_INFO_FMT "phy(%d), ioc_status"
-		    "(0x%04x), loginfo(0x%08x)\n", ioc->name,
-		    phy->number, le16_to_cpu(mpi_reply.IOCStatus),
-		    le32_to_cpu(mpi_reply.IOCLogInfo));
-
-	phy->invalid_dword_count = le32_to_cpu(phy_pg1.InvalidDwordCount);
-	phy->running_disparity_error_count =
-	    le32_to_cpu(phy_pg1.RunningDisparityErrorCount);
-	phy->loss_of_dword_sync_count =
-	    le32_to_cpu(phy_pg1.LossDwordSynchCount);
-	phy->phy_reset_problem_count =
-	    le32_to_cpu(phy_pg1.PhyResetProblemCount);
-	return 0;
-}
-
-/**
- * _transport_get_enclosure_identifier -
- * @phy: The sas phy object
- *
- * Obtain the enclosure logical id for an expander.
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_transport_get_enclosure_identifier(struct sas_rphy *rphy, u64 *identifier)
-{
-	struct MPT2SAS_ADAPTER *ioc = rphy_to_ioc(rphy);
-	struct _sas_device *sas_device;
-	unsigned long flags;
-	int rc;
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-	    rphy->identify.sas_address);
-	if (sas_device) {
-		*identifier = sas_device->enclosure_logical_id;
-		rc = 0;
-	} else {
-		*identifier = 0;
-		rc = -ENXIO;
-	}
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	return rc;
-}
-
-/**
- * _transport_get_bay_identifier -
- * @phy: The sas phy object
- *
- * Returns the slot id for a device that resides inside an enclosure.
- */
-static int
-_transport_get_bay_identifier(struct sas_rphy *rphy)
-{
-	struct MPT2SAS_ADAPTER *ioc = rphy_to_ioc(rphy);
-	struct _sas_device *sas_device;
-	unsigned long flags;
-	int rc;
-
-	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,
-	    rphy->identify.sas_address);
-	if (sas_device)
-		rc = sas_device->slot;
-	else
-		rc = -ENXIO;
-	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
-	return rc;
-}
-
-/* phy control request structure */
-struct phy_control_request{
-	u8 smp_frame_type; /* 0x40 */
-	u8 function; /* 0x91 */
-	u8 allocated_response_length;
-	u8 request_length; /* 0x09 */
-	u16 expander_change_count;
-	u8 reserved_1[3];
-	u8 phy_identifier;
-	u8 phy_operation;
-	u8 reserved_2[13];
-	u64 attached_device_name;
-	u8 programmed_min_physical_link_rate;
-	u8 programmed_max_physical_link_rate;
-	u8 reserved_3[6];
-};
-
-/* phy control reply structure */
-struct phy_control_reply{
-	u8 smp_frame_type; /* 0x41 */
-	u8 function; /* 0x11 */
-	u8 function_result;
-	u8 response_length;
-};
-
-#define SMP_PHY_CONTROL_LINK_RESET	(0x01)
-#define SMP_PHY_CONTROL_HARD_RESET	(0x02)
-#define SMP_PHY_CONTROL_DISABLE		(0x03)
-
-/**
- * _transport_expander_phy_control - expander phy control
- * @ioc: per adapter object
- * @phy: The sas phy object
- *
- * Returns 0 for success, non-zero for failure.
- *
- */
-static int
-_transport_expander_phy_control(struct MPT2SAS_ADAPTER *ioc,
-    struct sas_phy *phy, u8 phy_operation)
-{
-	Mpi2SmpPassthroughRequest_t *mpi_request;
-	Mpi2SmpPassthroughReply_t *mpi_reply;
-	struct phy_control_request *phy_control_request;
-	struct phy_control_reply *phy_control_reply;
-	int rc;
-	u16 smid;
-	u32 ioc_state;
-	unsigned long timeleft;
-	void *psge;
-	u32 sgl_flags;
-	u8 issue_reset = 0;
-	void *data_out = NULL;
-	dma_addr_t data_out_dma;
-	u32 sz;
-	u16 wait_state_count;
-
-	if (ioc->shost_recovery) {
-		printk(MPT2SAS_INFO_FMT "%s: host reset in progress!\n",
-		    __func__, ioc->name);
-		return -EFAULT;
-	}
-
-	mutex_lock(&ioc->transport_cmds.mutex);
-
-	if (ioc->transport_cmds.status != MPT2_CMD_NOT_USED) {
-		printk(MPT2SAS_ERR_FMT "%s: transport_cmds in use\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-	ioc->transport_cmds.status = MPT2_CMD_PENDING;
-
-	wait_state_count = 0;
-	ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
-		if (wait_state_count++ == 10) {
-			printk(MPT2SAS_ERR_FMT
-			    "%s: failed due to ioc not operational\n",
-			    ioc->name, __func__);
-			rc = -EFAULT;
-			goto out;
-		}
-		ssleep(1);
-		ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-		printk(MPT2SAS_INFO_FMT "%s: waiting for "
-		    "operational state(count=%d)\n", ioc->name,
-		    __func__, wait_state_count);
-	}
-	if (wait_state_count)
-		printk(MPT2SAS_INFO_FMT "%s: ioc is operational\n",
-		    ioc->name, __func__);
-
-	smid = mpt2sas_base_get_smid(ioc, ioc->transport_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	ioc->transport_cmds.smid = smid;
-
-	sz = sizeof(struct phy_control_request) +
-	    sizeof(struct phy_control_reply);
-	data_out = pci_alloc_consistent(ioc->pdev, sz, &data_out_dma);
-	if (!data_out) {
-		printk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,
-		    __LINE__, __func__);
-		rc = -ENOMEM;
-		mpt2sas_base_free_smid(ioc, smid);
-		goto out;
-	}
-
-	rc = -EINVAL;
-	memset(data_out, 0, sz);
-	phy_control_request = data_out;
-	phy_control_request->smp_frame_type = 0x40;
-	phy_control_request->function = 0x91;
-	phy_control_request->request_length = 9;
-	phy_control_request->allocated_response_length = 0;
-	phy_control_request->phy_identifier = phy->number;
-	phy_control_request->phy_operation = phy_operation;
-	phy_control_request->programmed_min_physical_link_rate =
-	    phy->minimum_linkrate << 4;
-	phy_control_request->programmed_max_physical_link_rate =
-	    phy->maximum_linkrate << 4;
-
-	memset(mpi_request, 0, sizeof(Mpi2SmpPassthroughRequest_t));
-	mpi_request->Function = MPI2_FUNCTION_SMP_PASSTHROUGH;
-	mpi_request->PhysicalPort = 0xFF;
-	mpi_request->VF_ID = 0; /* TODO */
-	mpi_request->VP_ID = 0;
-	mpi_request->SASAddress = cpu_to_le64(phy->identify.sas_address);
-	mpi_request->RequestDataLength =
-	    cpu_to_le16(sizeof(struct phy_error_log_request));
-	psge = &mpi_request->SGL;
-
-	/* WRITE sgel first */
-	sgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |
-	    MPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_HOST_TO_IOC);
-	sgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;
-	ioc->base_add_sg_single(psge, sgl_flags |
-	    sizeof(struct phy_control_request), data_out_dma);
-
-	/* incr sgel */
-	psge += ioc->sge_size;
-
-	/* READ sgel last */
-	sgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |
-	    MPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |
-	    MPI2_SGE_FLAGS_END_OF_LIST);
-	sgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;
-	ioc->base_add_sg_single(psge, sgl_flags |
-	    sizeof(struct phy_control_reply), data_out_dma +
-	    sizeof(struct phy_control_request));
-
-	dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT "phy_control - "
-	    "send to sas_addr(0x%016llx), phy(%d), opcode(%d)\n", ioc->name,
-	    (unsigned long long)phy->identify.sas_address, phy->number,
-	    phy_operation));
-
-	init_completion(&ioc->transport_cmds.done);
-	mpt2sas_base_put_smid_default(ioc, smid);
-	timeleft = wait_for_completion_timeout(&ioc->transport_cmds.done,
-	    10*HZ);
-
-	if (!(ioc->transport_cmds.status & MPT2_CMD_COMPLETE)) {
-		printk(MPT2SAS_ERR_FMT "%s: timeout\n",
-		    ioc->name, __func__);
-		_debug_dump_mf(mpi_request,
-		    sizeof(Mpi2SmpPassthroughRequest_t)/4);
-		if (!(ioc->transport_cmds.status & MPT2_CMD_RESET))
-			issue_reset = 1;
-		goto issue_host_reset;
-	}
-
-	dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT "phy_control - "
-	    "complete\n", ioc->name));
-
-	if (ioc->transport_cmds.status & MPT2_CMD_REPLY_VALID) {
-
-		mpi_reply = ioc->transport_cmds.reply;
-
-		dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "phy_control - reply data transfer size(%d)\n",
-		    ioc->name, le16_to_cpu(mpi_reply->ResponseDataLength)));
-
-		if (le16_to_cpu(mpi_reply->ResponseDataLength) !=
-		    sizeof(struct phy_control_reply))
-			goto out;
-
-		phy_control_reply = data_out +
-		    sizeof(struct phy_control_request);
-
-		dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "phy_control - function_result(%d)\n",
-		    ioc->name, phy_control_reply->function_result));
-
-		rc = 0;
-	} else
-		dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "phy_control - no reply\n", ioc->name));
-
- issue_host_reset:
-	if (issue_reset)
-		mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-		    FORCE_BIG_HAMMER);
- out:
-	ioc->transport_cmds.status = MPT2_CMD_NOT_USED;
-	if (data_out)
-		pci_free_consistent(ioc->pdev, sz, data_out, data_out_dma);
-
-	mutex_unlock(&ioc->transport_cmds.mutex);
-	return rc;
-}
-
-/**
- * _transport_phy_reset -
- * @phy: The sas phy object
- * @hard_reset:
- *
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_transport_phy_reset(struct sas_phy *phy, int hard_reset)
-{
-	struct MPT2SAS_ADAPTER *ioc = phy_to_ioc(phy);
-	Mpi2SasIoUnitControlReply_t mpi_reply;
-	Mpi2SasIoUnitControlRequest_t mpi_request;
-	unsigned long flags;
-
-	spin_lock_irqsave(&ioc->sas_node_lock, flags);
-	if (_transport_sas_node_find_by_sas_address(ioc,
-	    phy->identify.sas_address) == NULL) {
-		spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-		return -EINVAL;
-	}
-	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-
-	/* handle expander phys */
-	if (phy->identify.sas_address != ioc->sas_hba.sas_address)
-		return _transport_expander_phy_control(ioc, phy,
-		    (hard_reset == 1) ? SMP_PHY_CONTROL_HARD_RESET :
-		    SMP_PHY_CONTROL_LINK_RESET);
-
-	/* handle hba phys */
-	memset(&mpi_request, 0, sizeof(Mpi2SasIoUnitControlReply_t));
-	mpi_request.Function = MPI2_FUNCTION_SAS_IO_UNIT_CONTROL;
-	mpi_request.Operation = hard_reset ?
-	    MPI2_SAS_OP_PHY_HARD_RESET : MPI2_SAS_OP_PHY_LINK_RESET;
-	mpi_request.PhyNum = phy->number;
-
-	if ((mpt2sas_base_sas_iounit_control(ioc, &mpi_reply, &mpi_request))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		return -ENXIO;
-	}
-
-	if (mpi_reply.IOCStatus || mpi_reply.IOCLogInfo)
-		printk(MPT2SAS_INFO_FMT "phy(%d), ioc_status"
-		    "(0x%04x), loginfo(0x%08x)\n", ioc->name,
-		    phy->number, le16_to_cpu(mpi_reply.IOCStatus),
-		    le32_to_cpu(mpi_reply.IOCLogInfo));
-
-	return 0;
-}
-
-/**
- * _transport_phy_enable - enable/disable phys
- * @phy: The sas phy object
- * @enable: enable phy when true
- *
- * Only support sas_host direct attached phys.
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_transport_phy_enable(struct sas_phy *phy, int enable)
-{
-	struct MPT2SAS_ADAPTER *ioc = phy_to_ioc(phy);
-	Mpi2SasIOUnitPage1_t *sas_iounit_pg1 = NULL;
-	Mpi2SasIOUnitPage0_t *sas_iounit_pg0 = NULL;
-	Mpi2ConfigReply_t mpi_reply;
-	u16 ioc_status;
-	u16 sz;
-	int rc = 0;
-	unsigned long flags;
-	int i, discovery_active;
-
-	spin_lock_irqsave(&ioc->sas_node_lock, flags);
-	if (_transport_sas_node_find_by_sas_address(ioc,
-	    phy->identify.sas_address) == NULL) {
-		spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-		return -EINVAL;
-	}
-	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-
-	/* handle expander phys */
-	if (phy->identify.sas_address != ioc->sas_hba.sas_address)
-		return _transport_expander_phy_control(ioc, phy,
-		    (enable == 1) ? SMP_PHY_CONTROL_LINK_RESET :
-		    SMP_PHY_CONTROL_DISABLE);
-
-	/* handle hba phys */
-
-	/* read sas_iounit page 0 */
-	sz = offsetof(Mpi2SasIOUnitPage0_t, PhyData) + (ioc->sas_hba.num_phys *
-	    sizeof(Mpi2SasIOUnit0PhyData_t));
-	sas_iounit_pg0 = kzalloc(sz, GFP_KERNEL);
-	if (!sas_iounit_pg0) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		rc = -ENOMEM;
-		goto out;
-	}
-	if ((mpt2sas_config_get_sas_iounit_pg0(ioc, &mpi_reply,
-	    sas_iounit_pg0, sz))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		rc = -ENXIO;
-		goto out;
-	}
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-	    MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		rc = -EIO;
-		goto out;
-	}
-
-	/* unable to enable/disable phys when when discovery is active */
-	for (i = 0, discovery_active = 0; i < ioc->sas_hba.num_phys ; i++) {
-		if (sas_iounit_pg0->PhyData[i].PortFlags &
-		    MPI2_SASIOUNIT0_PORTFLAGS_DISCOVERY_IN_PROGRESS) {
-			printk(MPT2SAS_ERR_FMT "discovery is active on "
-			    "port = %d, phy = %d: unable to enable/disable "
-			    "phys, try again later!\n", ioc->name,
-			    sas_iounit_pg0->PhyData[i].Port, i);
-			discovery_active = 1;
-		}
-	}
-
-	if (discovery_active) {
-		rc = -EAGAIN;
-		goto out;
-	}
-
-	/* read sas_iounit page 1 */
-	sz = offsetof(Mpi2SasIOUnitPage1_t, PhyData) + (ioc->sas_hba.num_phys *
-	    sizeof(Mpi2SasIOUnit1PhyData_t));
-	sas_iounit_pg1 = kzalloc(sz, GFP_KERNEL);
-	if (!sas_iounit_pg1) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		rc = -ENOMEM;
-		goto out;
-	}
-	if ((mpt2sas_config_get_sas_iounit_pg1(ioc, &mpi_reply,
-	    sas_iounit_pg1, sz))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		rc = -ENXIO;
-		goto out;
-	}
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-	    MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		rc = -EIO;
-		goto out;
-	}
-	/* copy Port/PortFlags/PhyFlags from page 0 */
-	for (i = 0; i < ioc->sas_hba.num_phys ; i++) {
-		sas_iounit_pg1->PhyData[i].Port =
-		    sas_iounit_pg0->PhyData[i].Port;
-		sas_iounit_pg1->PhyData[i].PortFlags =
-		    (sas_iounit_pg0->PhyData[i].PortFlags &
-		    MPI2_SASIOUNIT0_PORTFLAGS_AUTO_PORT_CONFIG);
-		sas_iounit_pg1->PhyData[i].PhyFlags =
-		    (sas_iounit_pg0->PhyData[i].PhyFlags &
-		    (MPI2_SASIOUNIT0_PHYFLAGS_ZONING_ENABLED +
-		    MPI2_SASIOUNIT0_PHYFLAGS_PHY_DISABLED));
-	}
-	if (enable)
-		sas_iounit_pg1->PhyData[phy->number].PhyFlags
-		    &= ~MPI2_SASIOUNIT1_PHYFLAGS_PHY_DISABLE;
-	else
-		sas_iounit_pg1->PhyData[phy->number].PhyFlags
-		    |= MPI2_SASIOUNIT1_PHYFLAGS_PHY_DISABLE;
-
-	mpt2sas_config_set_sas_iounit_pg1(ioc, &mpi_reply, sas_iounit_pg1, sz);
-
-	/* link reset */
-	if (enable)
-		_transport_phy_reset(phy, 0);
-
- out:
-	kfree(sas_iounit_pg1);
-	kfree(sas_iounit_pg0);
-	return rc;
-}
-
-/**
- * _transport_phy_speed - set phy min/max link rates
- * @phy: The sas phy object
- * @rates: rates defined in sas_phy_linkrates
- *
- * Only support sas_host direct attached phys.
- * Returns 0 for success, non-zero for failure.
- */
-static int
-_transport_phy_speed(struct sas_phy *phy, struct sas_phy_linkrates *rates)
-{
-	struct MPT2SAS_ADAPTER *ioc = phy_to_ioc(phy);
-	Mpi2SasIOUnitPage1_t *sas_iounit_pg1 = NULL;
-	Mpi2SasPhyPage0_t phy_pg0;
-	Mpi2ConfigReply_t mpi_reply;
-	u16 ioc_status;
-	u16 sz;
-	int i;
-	int rc = 0;
-	unsigned long flags;
-
-	spin_lock_irqsave(&ioc->sas_node_lock, flags);
-	if (_transport_sas_node_find_by_sas_address(ioc,
-	    phy->identify.sas_address) == NULL) {
-		spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-		return -EINVAL;
-	}
-	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-
-	if (!rates->minimum_linkrate)
-		rates->minimum_linkrate = phy->minimum_linkrate;
-	else if (rates->minimum_linkrate < phy->minimum_linkrate_hw)
-		rates->minimum_linkrate = phy->minimum_linkrate_hw;
-
-	if (!rates->maximum_linkrate)
-		rates->maximum_linkrate = phy->maximum_linkrate;
-	else if (rates->maximum_linkrate > phy->maximum_linkrate_hw)
-		rates->maximum_linkrate = phy->maximum_linkrate_hw;
-
-	/* handle expander phys */
-	if (phy->identify.sas_address != ioc->sas_hba.sas_address) {
-		phy->minimum_linkrate = rates->minimum_linkrate;
-		phy->maximum_linkrate = rates->maximum_linkrate;
-		return _transport_expander_phy_control(ioc, phy,
-		    SMP_PHY_CONTROL_LINK_RESET);
-	}
-
-	/* handle hba phys */
-
-	/* sas_iounit page 1 */
-	sz = offsetof(Mpi2SasIOUnitPage1_t, PhyData) + (ioc->sas_hba.num_phys *
-	    sizeof(Mpi2SasIOUnit1PhyData_t));
-	sas_iounit_pg1 = kzalloc(sz, GFP_KERNEL);
-	if (!sas_iounit_pg1) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		rc = -ENOMEM;
-		goto out;
-	}
-	if ((mpt2sas_config_get_sas_iounit_pg1(ioc, &mpi_reply,
-	    sas_iounit_pg1, sz))) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		rc = -ENXIO;
-		goto out;
-	}
-	ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
-	    MPI2_IOCSTATUS_MASK;
-	if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		rc = -EIO;
-		goto out;
-	}
-
-	for (i = 0; i < ioc->sas_hba.num_phys; i++) {
-		if (phy->number != i) {
-			sas_iounit_pg1->PhyData[i].MaxMinLinkRate =
-			    (ioc->sas_hba.phy[i].phy->minimum_linkrate +
-			    (ioc->sas_hba.phy[i].phy->maximum_linkrate << 4));
-		} else {
-			sas_iounit_pg1->PhyData[i].MaxMinLinkRate =
-			    (rates->minimum_linkrate +
-			    (rates->maximum_linkrate << 4));
-		}
-	}
-
-	if (mpt2sas_config_set_sas_iounit_pg1(ioc, &mpi_reply, sas_iounit_pg1,
-	    sz)) {
-		printk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",
-		    ioc->name, __FILE__, __LINE__, __func__);
-		rc = -ENXIO;
-		goto out;
-	}
-
-	/* link reset */
-	_transport_phy_reset(phy, 0);
-
-	/* read phy page 0, then update the rates in the sas transport phy */
-	if (!mpt2sas_config_get_phy_pg0(ioc, &mpi_reply, &phy_pg0,
-	    phy->number)) {
-		phy->minimum_linkrate = _transport_convert_phy_link_rate(
-		    phy_pg0.ProgrammedLinkRate & MPI2_SAS_PRATE_MIN_RATE_MASK);
-		phy->maximum_linkrate = _transport_convert_phy_link_rate(
-		    phy_pg0.ProgrammedLinkRate >> 4);
-		phy->negotiated_linkrate = _transport_convert_phy_link_rate(
-		    phy_pg0.NegotiatedLinkRate &
-		    MPI2_SAS_NEG_LINK_RATE_MASK_PHYSICAL);
-	}
-
- out:
-	kfree(sas_iounit_pg1);
-	return rc;
-}
-
-
-/**
- * _transport_smp_handler - transport portal for smp passthru
- * @shost: shost object
- * @rphy: sas transport rphy object
- * @req:
- *
- * This used primarily for smp_utils.
- * Example:
- *           smp_rep_general /sys/class/bsg/expander-5:0
- */
-static int
-_transport_smp_handler(struct Scsi_Host *shost, struct sas_rphy *rphy,
-    struct request *req)
-{
-	struct MPT2SAS_ADAPTER *ioc = shost_priv(shost);
-	Mpi2SmpPassthroughRequest_t *mpi_request;
-	Mpi2SmpPassthroughReply_t *mpi_reply;
-	int rc, i;
-	u16 smid;
-	u32 ioc_state;
-	unsigned long timeleft;
-	void *psge;
-	u32 sgl_flags;
-	u8 issue_reset = 0;
-	dma_addr_t dma_addr_in = 0;
-	dma_addr_t dma_addr_out = 0;
-	dma_addr_t pci_dma_in = 0;
-	dma_addr_t pci_dma_out = 0;
-	void *pci_addr_in = NULL;
-	void *pci_addr_out = NULL;
-	u16 wait_state_count;
-	struct request *rsp = req->next_rq;
-	struct bio_vec *bvec = NULL;
-
-	if (!rsp) {
-		printk(MPT2SAS_ERR_FMT "%s: the smp response space is "
-		    "missing\n", ioc->name, __func__);
-		return -EINVAL;
-	}
-	if (ioc->shost_recovery || ioc->pci_error_recovery) {
-		printk(MPT2SAS_INFO_FMT "%s: host reset in progress!\n",
-		    __func__, ioc->name);
-		return -EFAULT;
-	}
-
-	rc = mutex_lock_interruptible(&ioc->transport_cmds.mutex);
-	if (rc)
-		return rc;
-
-	if (ioc->transport_cmds.status != MPT2_CMD_NOT_USED) {
-		printk(MPT2SAS_ERR_FMT "%s: transport_cmds in use\n", ioc->name,
-		    __func__);
-		rc = -EAGAIN;
-		goto out;
-	}
-	ioc->transport_cmds.status = MPT2_CMD_PENDING;
-
-	/* Check if the request is split across multiple segments */
-	if (bio_segments(req->bio) > 1) {
-		u32 offset = 0;
-
-		/* Allocate memory and copy the request */
-		pci_addr_out = pci_alloc_consistent(ioc->pdev,
-		    blk_rq_bytes(req), &pci_dma_out);
-		if (!pci_addr_out) {
-			printk(MPT2SAS_INFO_FMT "%s(): PCI Addr out = NULL\n",
-			    ioc->name, __func__);
-			rc = -ENOMEM;
-			goto out;
-		}
-
-		bio_for_each_segment(bvec, req->bio, i) {
-			memcpy(pci_addr_out + offset,
-			    page_address(bvec->bv_page) + bvec->bv_offset,
-			    bvec->bv_len);
-			offset += bvec->bv_len;
-		}
-	} else {
-		dma_addr_out = pci_map_single(ioc->pdev, bio_data(req->bio),
-		    blk_rq_bytes(req), PCI_DMA_BIDIRECTIONAL);
-		if (!dma_addr_out) {
-			printk(MPT2SAS_INFO_FMT "%s(): DMA Addr out = NULL\n",
-			    ioc->name, __func__);
-			rc = -ENOMEM;
-			goto free_pci;
-		}
-	}
-
-	/* Check if the response needs to be populated across
-	 * multiple segments */
-	if (bio_segments(rsp->bio) > 1) {
-		pci_addr_in = pci_alloc_consistent(ioc->pdev, blk_rq_bytes(rsp),
-		    &pci_dma_in);
-		if (!pci_addr_in) {
-			printk(MPT2SAS_INFO_FMT "%s(): PCI Addr in = NULL\n",
-			    ioc->name, __func__);
-			rc = -ENOMEM;
-			goto unmap;
-		}
-	} else {
-		dma_addr_in =  pci_map_single(ioc->pdev, bio_data(rsp->bio),
-		    blk_rq_bytes(rsp), PCI_DMA_BIDIRECTIONAL);
-		if (!dma_addr_in) {
-			printk(MPT2SAS_INFO_FMT "%s(): DMA Addr in = NULL\n",
-			    ioc->name, __func__);
-			rc = -ENOMEM;
-			goto unmap;
-		}
-	}
-
-	wait_state_count = 0;
-	ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
-		if (wait_state_count++ == 10) {
-			printk(MPT2SAS_ERR_FMT
-			    "%s: failed due to ioc not operational\n",
-			    ioc->name, __func__);
-			rc = -EFAULT;
-			goto unmap;
-		}
-		ssleep(1);
-		ioc_state = mpt2sas_base_get_iocstate(ioc, 1);
-		printk(MPT2SAS_INFO_FMT "%s: waiting for "
-		    "operational state(count=%d)\n", ioc->name,
-		    __func__, wait_state_count);
-	}
-	if (wait_state_count)
-		printk(MPT2SAS_INFO_FMT "%s: ioc is operational\n",
-		    ioc->name, __func__);
-
-	smid = mpt2sas_base_get_smid(ioc, ioc->transport_cb_idx);
-	if (!smid) {
-		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
-		    ioc->name, __func__);
-		rc = -EAGAIN;
-		goto unmap;
-	}
-
-	rc = 0;
-	mpi_request = mpt2sas_base_get_msg_frame(ioc, smid);
-	ioc->transport_cmds.smid = smid;
-
-	memset(mpi_request, 0, sizeof(Mpi2SmpPassthroughRequest_t));
-	mpi_request->Function = MPI2_FUNCTION_SMP_PASSTHROUGH;
-	mpi_request->PhysicalPort = 0xFF;
-	mpi_request->VF_ID = 0; /* TODO */
-	mpi_request->VP_ID = 0;
-	mpi_request->SASAddress = (rphy) ?
-	    cpu_to_le64(rphy->identify.sas_address) :
-	    cpu_to_le64(ioc->sas_hba.sas_address);
-	mpi_request->RequestDataLength = cpu_to_le16(blk_rq_bytes(req) - 4);
-	psge = &mpi_request->SGL;
-
-	/* WRITE sgel first */
-	sgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |
-	    MPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_HOST_TO_IOC);
-	sgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;
-	if (bio_segments(req->bio) > 1) {
-		ioc->base_add_sg_single(psge, sgl_flags |
-		    (blk_rq_bytes(req) - 4), pci_dma_out);
-	} else {
-		ioc->base_add_sg_single(psge, sgl_flags |
-		    (blk_rq_bytes(req) - 4), dma_addr_out);
-	}
-
-	/* incr sgel */
-	psge += ioc->sge_size;
-
-	/* READ sgel last */
-	sgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |
-	    MPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |
-	    MPI2_SGE_FLAGS_END_OF_LIST);
-	sgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;
-	if (bio_segments(rsp->bio) > 1) {
-		ioc->base_add_sg_single(psge, sgl_flags |
-		    (blk_rq_bytes(rsp) + 4), pci_dma_in);
-	} else {
-		ioc->base_add_sg_single(psge, sgl_flags |
-		    (blk_rq_bytes(rsp) + 4), dma_addr_in);
-	}
-
-	dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT "%s - "
-	    "sending smp request\n", ioc->name, __func__));
-
-	init_completion(&ioc->transport_cmds.done);
-	mpt2sas_base_put_smid_default(ioc, smid);
-	timeleft = wait_for_completion_timeout(&ioc->transport_cmds.done,
-	    10*HZ);
-
-	if (!(ioc->transport_cmds.status & MPT2_CMD_COMPLETE)) {
-		printk(MPT2SAS_ERR_FMT "%s : timeout\n",
-		    __func__, ioc->name);
-		_debug_dump_mf(mpi_request,
-		    sizeof(Mpi2SmpPassthroughRequest_t)/4);
-		if (!(ioc->transport_cmds.status & MPT2_CMD_RESET))
-			issue_reset = 1;
-		goto issue_host_reset;
-	}
-
-	dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT "%s - "
-	    "complete\n", ioc->name, __func__));
-
-	if (ioc->transport_cmds.status & MPT2_CMD_REPLY_VALID) {
-
-		mpi_reply = ioc->transport_cmds.reply;
-
-		dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "%s - reply data transfer size(%d)\n",
-		    ioc->name, __func__,
-		    le16_to_cpu(mpi_reply->ResponseDataLength)));
-
-		memcpy(req->sense, mpi_reply, sizeof(*mpi_reply));
-		req->sense_len = sizeof(*mpi_reply);
-		req->resid_len = 0;
-		rsp->resid_len -=
-		    le16_to_cpu(mpi_reply->ResponseDataLength);
-		/* check if the resp needs to be copied from the allocated
-		 * pci mem */
-		if (bio_segments(rsp->bio) > 1) {
-			u32 offset = 0;
-			u32 bytes_to_copy =
-			    le16_to_cpu(mpi_reply->ResponseDataLength);
-			bio_for_each_segment(bvec, rsp->bio, i) {
-				if (bytes_to_copy <= bvec->bv_len) {
-					memcpy(page_address(bvec->bv_page) +
-					    bvec->bv_offset, pci_addr_in +
-					    offset, bytes_to_copy);
-					break;
-				} else {
-					memcpy(page_address(bvec->bv_page) +
-					    bvec->bv_offset, pci_addr_in +
-					    offset, bvec->bv_len);
-					bytes_to_copy -= bvec->bv_len;
-				}
-				offset += bvec->bv_len;
-			}
-		}
-	} else {
-		dtransportprintk(ioc, printk(MPT2SAS_INFO_FMT
-		    "%s - no reply\n", ioc->name, __func__));
-		rc = -ENXIO;
-	}
-
- issue_host_reset:
-	if (issue_reset) {
-		mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,
-		    FORCE_BIG_HAMMER);
-		rc = -ETIMEDOUT;
-	}
-
- unmap:
-	if (dma_addr_out)
-		pci_unmap_single(ioc->pdev, dma_addr_out, blk_rq_bytes(req),
-		    PCI_DMA_BIDIRECTIONAL);
-	if (dma_addr_in)
-		pci_unmap_single(ioc->pdev, dma_addr_in, blk_rq_bytes(rsp),
-		    PCI_DMA_BIDIRECTIONAL);
-
- free_pci:
-	if (pci_addr_out)
-		pci_free_consistent(ioc->pdev, blk_rq_bytes(req), pci_addr_out,
-		    pci_dma_out);
-
-	if (pci_addr_in)
-		pci_free_consistent(ioc->pdev, blk_rq_bytes(rsp), pci_addr_in,
-		    pci_dma_in);
-
- out:
-	ioc->transport_cmds.status = MPT2_CMD_NOT_USED;
-	mutex_unlock(&ioc->transport_cmds.mutex);
-	return rc;
-}
-
-struct sas_function_template mpt2sas_transport_functions = {
-	.get_linkerrors		= _transport_get_linkerrors,
-	.get_enclosure_identifier = _transport_get_enclosure_identifier,
-	.get_bay_identifier	= _transport_get_bay_identifier,
-	.phy_reset		= _transport_phy_reset,
-	.phy_enable		= _transport_phy_enable,
-	.set_phy_speed		= _transport_phy_speed,
-	.smp_handler		= _transport_smp_handler,
-};
-
-struct scsi_transport_template *mpt2sas_transport_template;
diff --git a/drivers/scsi/mpt3sas/Kconfig b/drivers/scsi/mpt3sas/Kconfig
index 18b64bce10cb..29061467cc17 100644
--- a/drivers/scsi/mpt3sas/Kconfig
+++ b/drivers/scsi/mpt3sas/Kconfig
@@ -41,15 +41,27 @@
 # USA.
 
 config SCSI_MPT3SAS
-	tristate "LSI MPT Fusion SAS 3.0 Device Driver"
+	tristate "LSI MPT Fusion SAS 3.0 & SAS 2.0 Device Driver"
 	depends on PCI && SCSI
 	select SCSI_SAS_ATTRS
 	select RAID_ATTRS
 	---help---
 	This driver supports PCI-Express SAS 12Gb/s Host Adapters.
 
+config SCSI_MPT2SAS_MAX_SGE
+	int "LSI MPT Fusion SAS 2.0 Max number of SG Entries (16 - 256)"
+	depends on PCI && SCSI && SCSI_MPT3SAS
+	default "128"
+	range 16 256
+	---help---
+	This option allows you to specify the maximum number of scatter-
+	gather entries per I/O. The driver default is 128, which matches
+	MAX_PHYS_SEGMENTS in most kernels.  However in SuSE kernels this
+	can be 256. However, it may decreased down to 16.  Decreasing this
+	parameter will reduce memory requirements on a per controller instance.
+
 config SCSI_MPT3SAS_MAX_SGE
-	int "LSI MPT Fusion Max number of SG Entries (16 - 256)"
+	int "LSI MPT Fusion SAS 3.0 Max number of SG Entries (16 - 256)"
 	depends on PCI && SCSI && SCSI_MPT3SAS
 	default "128"
 	range 16 256
* Unmerged path drivers/scsi/mpt3sas/Makefile
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_base.c
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_base.h
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_config.c
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_ctl.c
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_ctl.h
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_debug.h
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_scsih.c
* Unmerged path drivers/scsi/mpt3sas/mpt2sas_transport.c
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_base.c
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_base.h
diff --git a/drivers/scsi/mpt3sas/mpt3sas_config.c b/drivers/scsi/mpt3sas/mpt3sas_config.c
index 2bbb0346b462..a6914ec99cc0 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_config.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_config.c
@@ -865,7 +865,6 @@ mpt3sas_config_set_iounit_pg1(struct MPT3SAS_ADAPTER *ioc,
 	return r;
 }
 
-#ifdef SCSI_MPT2SAS
 /**
  * mpt3sas_config_get_iounit_pg3 - obtain iounit page 3
  * @ioc: per adapter object
@@ -901,7 +900,6 @@ mpt3sas_config_get_iounit_pg3(struct MPT3SAS_ADAPTER *ioc,
  out:
 	return r;
 }
-#endif
 
 /**
  * mpt3sas_config_get_iounit_pg8 - obtain iounit page 8
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_ctl.c
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_scsih.c
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_warpdrive.c
