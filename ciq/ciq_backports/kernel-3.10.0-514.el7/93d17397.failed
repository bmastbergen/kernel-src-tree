KVM: PPC: Book3S HV: Save/restore TM state in H_CEDE

jira LE-1907
cve CVE-2016-5412
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [powerpc] kvm: book3s_hv: Save/restore TM state in H_CEDE (David Gibson) [1349244] {CVE-2016-5412}
Rebuild_FUZZ: 92.93%
commit-author Paul Mackerras <paulus@ozlabs.org>
commit 93d17397e4e2182fdaad503e2f9da46202c0f1c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/93d17397.failed

It turns out that if the guest does a H_CEDE while the CPU is in
a transactional state, and the H_CEDE does a nap, and the nap
loses the architected state of the CPU (which is is allowed to do),
then we lose the checkpointed state of the virtual CPU.  In addition,
the transactional-memory state recorded in the MSR gets reset back
to non-transactional, and when we try to return to the guest, we take
a TM bad thing type of program interrupt because we are trying to
transition from non-transactional to transactional with a hrfid
instruction, which is not permitted.

The result of the program interrupt occurring at that point is that
the host CPU will hang in an infinite loop with interrupts disabled.
Thus this is a denial of service vulnerability in the host which can
be triggered by any guest (and depending on the guest kernel, it can
potentially triggered by unprivileged userspace in the guest).

This vulnerability has been assigned the ID CVE-2016-5412.

To fix this, we save the TM state before napping and restore it
on exit from the nap, when handling a H_CEDE in real mode.  The
case where H_CEDE exits to host virtual mode is already OK (as are
other hcalls which exit to host virtual mode) because the exit
path saves the TM state.

	Cc: stable@vger.kernel.org # v3.15+
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit 93d17397e4e2182fdaad503e2f9da46202c0f1c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_hv_rmhandlers.S
diff --cc arch/powerpc/kvm/book3s_hv_rmhandlers.S
index 76e46cc9d17b,543124fa11d9..000000000000
--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S
+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S
@@@ -2167,6 -2171,17 +2174,20 @@@ kvm_end_cede
  	/* Woken by external or decrementer interrupt */
  	ld	r1, HSTATE_HOST_R1(r13)
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_KVM_BOOK3S_HV_EXIT_TIMING
+ 	addi	r3, r4, VCPU_TB_RMINTR
+ 	bl	kvmhv_accumulate_time
+ #endif
+ 
+ #ifdef CONFIG_PPC_TRANSACTIONAL_MEM
+ BEGIN_FTR_SECTION
+ 	bl	kvmppc_restore_tm
+ END_FTR_SECTION_IFSET(CPU_FTR_TM)
+ #endif
+ 
++>>>>>>> 93d17397e4e2 (KVM: PPC: Book3S HV: Save/restore TM state in H_CEDE)
  	/* load up FP state */
  	bl	kvmppc_load_fp
  
* Unmerged path arch/powerpc/kvm/book3s_hv_rmhandlers.S
