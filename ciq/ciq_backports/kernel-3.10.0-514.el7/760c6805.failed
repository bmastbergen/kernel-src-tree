vxlan: move ECN decapsulation to a separate function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 760c68054e9ed1c6e43b06f916f6efc2c8a1adcc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/760c6805.failed

It simplifies the vxlan_rcv function.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 760c68054e9ed1c6e43b06f916f6efc2c8a1adcc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 000e4c57a81e,382535bc9e59..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1270,12 -1203,11 +1270,18 @@@ static void vxlan_rcv(struct vxlan_soc
  
  	/* Ignore packet loops (and multicast echo) */
  	if (ether_addr_equal(eth_hdr(skb)->h_source, vxlan->dev->dev_addr))
 -		return false;
 +		goto drop;
  
++<<<<<<< HEAD
 +	/* Re-examine inner Ethernet packet */
 +	if (remote_ip->sa.sa_family == AF_INET) {
 +		oip = ip_hdr(skb);
 +		saddr.sin.sin_addr.s_addr = oip->saddr;
++=======
+ 	/* Get address from the outer IP header */
+ 	if (vxlan_get_sk_family(vs) == AF_INET) {
+ 		saddr.sin.sin_addr.s_addr = ip_hdr(skb)->saddr;
++>>>>>>> 760c68054e9e (vxlan: move ECN decapsulation to a separate function)
  		saddr.sa.sa_family = AF_INET;
  #if IS_ENABLED(CONFIG_IPV6)
  	} else {
@@@ -1287,30 -1218,57 +1293,63 @@@
  
  	if ((vxlan->flags & VXLAN_F_LEARN) &&
  	    vxlan_snoop(skb->dev, &saddr, eth_hdr(skb)->h_source))
++<<<<<<< HEAD
 +		goto drop;
 +
++=======
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static bool vxlan_ecn_decapsulate(struct vxlan_sock *vs, void *oiph,
+ 				  struct sk_buff *skb)
+ {
+ 	int err = 0;
+ 
+ 	if (vxlan_get_sk_family(vs) == AF_INET)
+ 		err = IP_ECN_decapsulate(oiph, skb);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	else
+ 		err = IP6_ECN_decapsulate(oiph, skb);
+ #endif
+ 
+ 	if (unlikely(err) && log_ecn_error) {
+ 		if (vxlan_get_sk_family(vs) == AF_INET)
+ 			net_info_ratelimited("non-ECT from %pI4 with TOS=%#x\n",
+ 					     &((struct iphdr *)oiph)->saddr,
+ 					     ((struct iphdr *)oiph)->tos);
+ 		else
+ 			net_info_ratelimited("non-ECT from %pI6\n",
+ 					     &((struct ipv6hdr *)oiph)->saddr);
+ 	}
+ 	return err <= 1;
+ }
+ 
+ static void vxlan_rcv(struct vxlan_dev *vxlan, struct vxlan_sock *vs,
+ 		      struct sk_buff *skb, struct vxlan_metadata *md,
+ 		      struct metadata_dst *tun_dst)
+ {
+ 	struct pcpu_sw_netstats *stats;
+ 	void *oiph;
+ 
+ 	if (!vxlan_set_mac(vxlan, vs, skb))
+ 		goto drop;
+ 
+ 	if (tun_dst) {
+ 		skb_dst_set(skb, (struct dst_entry *)tun_dst);
+ 		tun_dst = NULL;
+ 	}
+ 
+ 	oiph = skb_network_header(skb);
++>>>>>>> 760c68054e9e (vxlan: move ECN decapsulation to a separate function)
  	skb_reset_network_header(skb);
 +	skb->mark = md->gbp;
  
- 	if (oip6)
- 		err = IP6_ECN_decapsulate(oip6, skb);
- 	if (oip)
- 		err = IP_ECN_decapsulate(oip, skb);
- 
- 	if (unlikely(err)) {
- 		if (log_ecn_error) {
- 			if (oip6)
- 				net_info_ratelimited("non-ECT from %pI6\n",
- 						     &oip6->saddr);
- 			if (oip)
- 				net_info_ratelimited("non-ECT from %pI4 with TOS=%#x\n",
- 						     &oip->saddr, oip->tos);
- 		}
- 		if (err > 1) {
- 			++vxlan->dev->stats.rx_frame_errors;
- 			++vxlan->dev->stats.rx_errors;
- 			goto drop;
- 		}
+ 	if (!vxlan_ecn_decapsulate(vs, oiph, skb)) {
+ 		++vxlan->dev->stats.rx_frame_errors;
+ 		++vxlan->dev->stats.rx_errors;
+ 		goto drop;
  	}
  
  	stats = this_cpu_ptr(vxlan->dev->tstats);
* Unmerged path drivers/net/vxlan.c
