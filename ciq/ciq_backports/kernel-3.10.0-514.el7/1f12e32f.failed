x86/topology: Create logical package id

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] topology: Create logical package id (Jiri Olsa) [1084618]
Rebuild_FUZZ: 94.59%
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 1f12e32f4cd5243ae46d8b933181be0d022c6793
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1f12e32f.failed

For per package oriented services we must be able to rely on the number of CPU
packages to be within bounds. Create a tracking facility, which

- calculates the number of possible packages depending on nr_cpu_ids after boot

- makes sure that the package id is within the number of possible packages. If
  the apic id is outside we map it to a logical package id if there is enough
  space available.

Provide interfaces for drivers to query the mapping and do translations from
physcial to logical ids.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Andi Kleen <andi.kleen@intel.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Harish Chegondi <harish.chegondi@intel.com>
	Cc: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Kan Liang <kan.liang@intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Luis R. Rodriguez <mcgrof@suse.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Toshi Kani <toshi.kani@hp.com>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
	Cc: linux-kernel@vger.kernel.org
Link: http://lkml.kernel.org/r/20160222221011.541071755@linutronix.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 1f12e32f4cd5243ae46d8b933181be0d022c6793)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/topology.h
#	arch/x86/kernel/cpu/intel.c
#	arch/x86/kernel/smpboot.c
diff --cc arch/x86/include/asm/topology.h
index be305348af96,7f991bd5031b..000000000000
--- a/arch/x86/include/asm/topology.h
+++ b/arch/x86/include/asm/topology.h
@@@ -119,14 -119,23 +119,32 @@@ static inline void setup_node_to_cpumas
  
  extern const struct cpumask *cpu_coregroup_mask(int cpu);
  
++<<<<<<< HEAD
 +#ifdef ENABLE_TOPO_DEFINES
++=======
+ #define topology_logical_package_id(cpu)	(cpu_data(cpu).logical_proc_id)
++>>>>>>> 1f12e32f4cd5 (x86/topology: Create logical package id)
  #define topology_physical_package_id(cpu)	(cpu_data(cpu).phys_proc_id)
  #define topology_core_id(cpu)			(cpu_data(cpu).cpu_core_id)
 -
 -#ifdef ENABLE_TOPO_DEFINES
  #define topology_core_cpumask(cpu)		(per_cpu(cpu_core_map, cpu))
++<<<<<<< HEAD
 +#define topology_thread_cpumask(cpu)		(per_cpu(cpu_sibling_map, cpu))
 +
 +/* indicates that pointers to the topology cpumask_t maps are valid */
 +#define arch_provides_topology_pointers		yes
++=======
+ #define topology_sibling_cpumask(cpu)		(per_cpu(cpu_sibling_map, cpu))
+ 
+ extern unsigned int __max_logical_packages;
+ #define topology_max_packages()			(__max_logical_packages)
+ int topology_update_package_map(unsigned int apicid, unsigned int cpu);
+ extern int topology_phys_to_logical_pkg(unsigned int pkg);
+ #else
+ #define topology_max_packages()			(1)
+ static inline int
+ topology_update_package_map(unsigned int apicid, unsigned int cpu) { return 0; }
+ static inline int topology_phys_to_logical_pkg(unsigned int pkg) { return 0; }
++>>>>>>> 1f12e32f4cd5 (x86/topology: Create logical package id)
  #endif
  
  static inline void arch_fix_phys_package_id(int num, u32 slot)
diff --cc arch/x86/kernel/cpu/intel.c
index d471d849d819,38766c2b5b00..000000000000
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@@ -153,6 -145,34 +153,37 @@@ static void early_init_intel(struct cpu
  			setup_clear_cpu_cap(X86_FEATURE_ERMS);
  		}
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * Intel Quark Core DevMan_001.pdf section 6.4.11
+ 	 * "The operating system also is required to invalidate (i.e., flush)
+ 	 *  the TLB when any changes are made to any of the page table entries.
+ 	 *  The operating system must reload CR3 to cause the TLB to be flushed"
+ 	 *
+ 	 * As a result cpu_has_pge() in arch/x86/include/asm/tlbflush.h should
+ 	 * be false so that __flush_tlb_all() causes CR3 insted of CR4.PGE
+ 	 * to be modified
+ 	 */
+ 	if (c->x86 == 5 && c->x86_model == 9) {
+ 		pr_info("Disabling PGE capability bit\n");
+ 		setup_clear_cpu_cap(X86_FEATURE_PGE);
+ 	}
+ 
+ 	if (c->cpuid_level >= 0x00000001) {
+ 		u32 eax, ebx, ecx, edx;
+ 
+ 		cpuid(0x00000001, &eax, &ebx, &ecx, &edx);
+ 		/*
+ 		 * If HTT (EDX[28]) is set EBX[16:23] contain the number of
+ 		 * apicids which are reserved per package. Store the resulting
+ 		 * shift value for the package management code.
+ 		 */
+ 		if (edx & (1U << 28))
+ 			c->x86_coreid_bits = get_count_order((ebx >> 16) & 0xff);
+ 	}
++>>>>>>> 1f12e32f4cd5 (x86/topology: Create logical package id)
  }
  
  #ifdef CONFIG_X86_32
diff --cc arch/x86/kernel/smpboot.c
index 7dbc496614e0,3bf1e0b5f827..000000000000
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@@ -100,12 -94,53 +100,59 @@@ EXPORT_PER_CPU_SYMBOL(cpu_core_map)
  DEFINE_PER_CPU_READ_MOSTLY(cpumask_var_t, cpu_llc_shared_map);
  
  /* Per CPU bogomips and other parameters */
 -DEFINE_PER_CPU_READ_MOSTLY(struct cpuinfo_x86, cpu_info);
 +DEFINE_PER_CPU_SHARED_ALIGNED(struct cpuinfo_x86, cpu_info);
  EXPORT_PER_CPU_SYMBOL(cpu_info);
 +DEFINE_PER_CPU_SHARED_ALIGNED(struct rh_cpuinfo_x86, rh_cpu_info);
 +EXPORT_PER_CPU_SYMBOL(rh_cpu_info);
  
++<<<<<<< HEAD
 +atomic_t init_deasserted;
++=======
+ /* Logical package management. We might want to allocate that dynamically */
+ static int *physical_to_logical_pkg __read_mostly;
+ static unsigned long *physical_package_map __read_mostly;;
+ static unsigned long *logical_package_map  __read_mostly;
+ static unsigned int max_physical_pkg_id __read_mostly;
+ unsigned int __max_logical_packages __read_mostly;
+ EXPORT_SYMBOL(__max_logical_packages);
+ 
+ static inline void smpboot_setup_warm_reset_vector(unsigned long start_eip)
+ {
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&rtc_lock, flags);
+ 	CMOS_WRITE(0xa, 0xf);
+ 	spin_unlock_irqrestore(&rtc_lock, flags);
+ 	local_flush_tlb();
+ 	pr_debug("1.\n");
+ 	*((volatile unsigned short *)phys_to_virt(TRAMPOLINE_PHYS_HIGH)) =
+ 							start_eip >> 4;
+ 	pr_debug("2.\n");
+ 	*((volatile unsigned short *)phys_to_virt(TRAMPOLINE_PHYS_LOW)) =
+ 							start_eip & 0xf;
+ 	pr_debug("3.\n");
+ }
+ 
+ static inline void smpboot_restore_warm_reset_vector(void)
+ {
+ 	unsigned long flags;
+ 
+ 	/*
+ 	 * Install writable page 0 entry to set BIOS data area.
+ 	 */
+ 	local_flush_tlb();
+ 
+ 	/*
+ 	 * Paranoid:  Set warm reset code and vector here back
+ 	 * to default values.
+ 	 */
+ 	spin_lock_irqsave(&rtc_lock, flags);
+ 	CMOS_WRITE(0, 0xf);
+ 	spin_unlock_irqrestore(&rtc_lock, flags);
+ 
+ 	*((volatile u32 *)phys_to_virt(TRAMPOLINE_PHYS_LOW)) = 0;
+ }
++>>>>>>> 1f12e32f4cd5 (x86/topology: Create logical package id)
  
  /*
   * Report back to the Boot Processor during boot time or to the caller processor
@@@ -244,7 -357,7 +382,11 @@@ void __init smp_store_boot_cpu_info(voi
  
  	*c = boot_cpu_data;
  	c->cpu_index = id;
++<<<<<<< HEAD
 +	*rh_c = rh_boot_cpu_data;
++=======
+ 	smp_init_package_map();
++>>>>>>> 1f12e32f4cd5 (x86/topology: Create logical package id)
  }
  
  /*
diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
index ddad3b312de4..0791ec320844 100644
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@ -129,6 +129,8 @@ struct cpuinfo_x86 {
 	u16			booted_cores;
 	/* Physical processor id: */
 	u16			phys_proc_id;
+	/* Logical processor id: */
+	u16			logical_proc_id;
 	/* Core id: */
 	u16			cpu_core_id;
 	/* Compute unit id */
* Unmerged path arch/x86/include/asm/topology.h
diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c
index 9edff4303d7a..1b8e50abdb00 100644
--- a/arch/x86/kernel/apic/apic.c
+++ b/arch/x86/kernel/apic/apic.c
@@ -2206,6 +2206,20 @@ void generic_processor_info(int apicid, int version)
 	} else
 		cpu = cpumask_next_zero(-1, cpu_present_mask);
 
+	/*
+	 * This can happen on physical hotplug. The sanity check at boot time
+	 * is done from native_smp_prepare_cpus() after num_possible_cpus() is
+	 * established.
+	 */
+	if (topology_update_package_map(apicid, cpu) < 0) {
+		int thiscpu = max + disabled_cpus;
+
+		pr_warning("ACPI: Package limit reached. Processor %d/0x%x ignored.\n",
+			   thiscpu, apicid);
+		disabled_cpus++;
+		return -ENOSPC;
+	}
+
 	/*
 	 * Validate version
 	 */
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index b7f07b3beff8..be2bc9ef3076 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -998,6 +998,8 @@ static void identify_cpu(struct cpuinfo_x86 *c)
 #ifdef CONFIG_NUMA
 	numa_add_cpu(smp_processor_id());
 #endif
+	/* The boot/hotplug time assigment got cleared, restore it */
+	c->logical_proc_id = topology_phys_to_logical_pkg(c->phys_proc_id);
 }
 
 #ifdef CONFIG_X86_64
* Unmerged path arch/x86/kernel/cpu/intel.c
* Unmerged path arch/x86/kernel/smpboot.c
