mmc: core: stop trying to switch width when only one bit is supported

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] core: stop trying to switch width when only one bit is supported (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 96.24%
commit-author Alexandre Belloni <alexandre.belloni@free-electrons.com>
commit 1c2d26e379fc8d37d55befd8589c4c252186ee58
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1c2d26e3.failed

mmc_select_bus_width() will try to switch to MMC_BUS_WIDTH_4 even if
MMC_CAP_4_BIT_DATA and MMC_CAP_8_BIT_DATA are not set in host->caps.
Return as soon as possible when those flags are not set

Fixes: 577fb13199b1 (mmc: rework selection of bus speed mode)
	Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
	Cc: <stable@vger.kernel.org> # 3.17
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 1c2d26e379fc8d37d55befd8589c4c252186ee58)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/mmc.c
diff --cc drivers/mmc/core/mmc.c
index c3e6ecc69da0,7466ce098e60..000000000000
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@@ -830,39 -850,47 +830,45 @@@ static int mmc_select_powerclass(struc
  }
  
  /*
 - * Set the bus speed for the selected speed mode.
 - */
 -static void mmc_set_bus_speed(struct mmc_card *card)
 -{
 -	unsigned int max_dtr = (unsigned int)-1;
 -
 -	if ((mmc_card_hs200(card) || mmc_card_hs400(card)) &&
 -	     max_dtr > card->ext_csd.hs200_max_dtr)
 -		max_dtr = card->ext_csd.hs200_max_dtr;
 -	else if (mmc_card_hs(card) && max_dtr > card->ext_csd.hs_max_dtr)
 -		max_dtr = card->ext_csd.hs_max_dtr;
 -	else if (max_dtr > card->csd.max_dtr)
 -		max_dtr = card->csd.max_dtr;
 -
 -	mmc_set_clock(card->host, max_dtr);
 -}
 -
 -/*
 - * Select the bus width amoung 4-bit and 8-bit(SDR).
 - * If the bus width is changed successfully, return the selected width value.
 - * Zero is returned instead of error value if the wide width is not supported.
 + * Selects the desired buswidth and switch to the HS200 mode
 + * if bus width set without error
   */
 -static int mmc_select_bus_width(struct mmc_card *card)
 +static int mmc_select_hs200(struct mmc_card *card)
  {
 +	int idx, err = -EINVAL;
 +	struct mmc_host *host;
  	static unsigned ext_csd_bits[] = {
 -		EXT_CSD_BUS_WIDTH_8,
  		EXT_CSD_BUS_WIDTH_4,
 +		EXT_CSD_BUS_WIDTH_8,
  	};
  	static unsigned bus_widths[] = {
 -		MMC_BUS_WIDTH_8,
  		MMC_BUS_WIDTH_4,
 +		MMC_BUS_WIDTH_8,
  	};
 -	struct mmc_host *host = card->host;
 -	unsigned idx, bus_width = 0;
 -	int err = 0;
  
++<<<<<<< HEAD
 +	BUG_ON(!card);
++=======
+ 	if (!mmc_can_ext_csd(card) ||
+ 	    !(host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA)))
+ 		return 0;
++>>>>>>> 1c2d26e379fc (mmc: core: stop trying to switch width when only one bit is supported)
 +
 +	host = card->host;
 +
 +	if (card->ext_csd.card_type & EXT_CSD_CARD_TYPE_SDR_1_2V &&
 +			host->caps2 & MMC_CAP2_HS200_1_2V_SDR)
 +		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);
 +
 +	if (err && card->ext_csd.card_type & EXT_CSD_CARD_TYPE_SDR_1_8V &&
 +			host->caps2 & MMC_CAP2_HS200_1_8V_SDR)
 +		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
 +
 +	/* If fails try again during next card power cycle */
 +	if (err)
 +		goto err;
  
 -	idx = (host->caps & MMC_CAP_8_BIT_DATA) ? 0 : 1;
 +	idx = (host->caps & MMC_CAP_8_BIT_DATA) ? 1 : 0;
  
  	/*
  	 * Unlike SD, MMC cards dont have a configuration register to notify
* Unmerged path drivers/mmc/core/mmc.c
