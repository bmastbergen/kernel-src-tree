rhashtable: Add multiple rehash support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit b824478b2145be78ac19e1cf44e2b9036c7a9608
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b824478b.failed

This patch adds the missing bits to allow multiple rehashes.  The
read-side as well as remove already handle this correctly.  So it's
only the rehasher and insertion that need modification to handle
this.

Note that this patch doesn't actually enable it so for now rehashing
is still only performed by the worker thread.

This patch also disables the explicit expand/shrink interface because
the table is meant to expand and shrink automatically, and continuing
to export these interfaces unnecessarily complicates the life of the
rehasher since the rehash process is now composed of two parts.

	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b824478b2145be78ac19e1cf44e2b9036c7a9608)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/rhashtable.h
#	lib/rhashtable.c
#	lib/test_rhashtable.c
diff --cc include/linux/rhashtable.h
index 0839d7b8cd60,e8ffcdb5e239..000000000000
--- a/include/linux/rhashtable.h
+++ b/include/linux/rhashtable.h
@@@ -98,22 -301,20 +98,30 @@@ static inline int lockdep_rht_bucket_is
  }
  #endif /* CONFIG_PROVE_LOCKING */
  
 -int rhashtable_init(struct rhashtable *ht,
 -		    const struct rhashtable_params *params);
 +int rhashtable_init(struct rhashtable *ht, struct rhashtable_params *params);
 +
 +void rhashtable_insert(struct rhashtable *ht, struct rhash_head *node);
 +bool rhashtable_remove(struct rhashtable *ht, struct rhash_head *node);
 +
 +bool rht_grow_above_75(const struct rhashtable *ht, size_t new_size);
 +bool rht_shrink_below_30(const struct rhashtable *ht, size_t new_size);
  
 -int rhashtable_insert_slow(struct rhashtable *ht, const void *key,
 -			   struct rhash_head *obj,
 -			   struct bucket_table *old_tbl);
++<<<<<<< HEAD
 +int rhashtable_expand(struct rhashtable *ht);
 +int rhashtable_shrink(struct rhashtable *ht);
  
 +void *rhashtable_lookup(const struct rhashtable *ht, const void *key);
 +void *rhashtable_lookup_compare(const struct rhashtable *ht, const void *key,
 +				bool (*compare)(void *, void *), void *arg);
++=======
+ int rhashtable_walk_init(struct rhashtable *ht, struct rhashtable_iter *iter);
+ void rhashtable_walk_exit(struct rhashtable_iter *iter);
+ int rhashtable_walk_start(struct rhashtable_iter *iter) __acquires(RCU);
+ void *rhashtable_walk_next(struct rhashtable_iter *iter);
+ void rhashtable_walk_stop(struct rhashtable_iter *iter) __releases(RCU);
++>>>>>>> b824478b2145 (rhashtable: Add multiple rehash support)
  
 -void rhashtable_destroy(struct rhashtable *ht);
 +void rhashtable_destroy(const struct rhashtable *ht);
  
  #define rht_dereference(p, ht) \
  	rcu_dereference_protected(p, lockdep_rht_mutex_is_held(ht))
@@@ -261,4 -464,297 +269,300 @@@
  	rht_for_each_entry_rcu_continue(tpos, pos, (tbl)->buckets[hash],\
  					tbl, hash, member)
  
++<<<<<<< HEAD
++=======
+ static inline int rhashtable_compare(struct rhashtable_compare_arg *arg,
+ 				     const void *obj)
+ {
+ 	struct rhashtable *ht = arg->ht;
+ 	const char *ptr = obj;
+ 
+ 	return memcmp(ptr + ht->p.key_offset, arg->key, ht->p.key_len);
+ }
+ 
+ /**
+  * rhashtable_lookup_fast - search hash table, inlined version
+  * @ht:		hash table
+  * @key:	the pointer to the key
+  * @params:	hash table parameters
+  *
+  * Computes the hash value for the key and traverses the bucket chain looking
+  * for a entry with an identical key. The first matching entry is returned.
+  *
+  * Returns the first entry on which the compare function returned true.
+  */
+ static inline void *rhashtable_lookup_fast(
+ 	struct rhashtable *ht, const void *key,
+ 	const struct rhashtable_params params)
+ {
+ 	struct rhashtable_compare_arg arg = {
+ 		.ht = ht,
+ 		.key = key,
+ 	};
+ 	const struct bucket_table *tbl;
+ 	struct rhash_head *he;
+ 	unsigned hash;
+ 
+ 	rcu_read_lock();
+ 
+ 	tbl = rht_dereference_rcu(ht->tbl, ht);
+ restart:
+ 	hash = rht_key_hashfn(ht, tbl, key, params);
+ 	rht_for_each_rcu(he, tbl, hash) {
+ 		if (params.obj_cmpfn ?
+ 		    params.obj_cmpfn(&arg, rht_obj(ht, he)) :
+ 		    rhashtable_compare(&arg, rht_obj(ht, he)))
+ 			continue;
+ 		rcu_read_unlock();
+ 		return rht_obj(ht, he);
+ 	}
+ 
+ 	/* Ensure we see any new tables. */
+ 	smp_rmb();
+ 
+ 	tbl = rht_dereference_rcu(tbl->future_tbl, ht);
+ 	if (unlikely(tbl))
+ 		goto restart;
+ 	rcu_read_unlock();
+ 
+ 	return NULL;
+ }
+ 
+ static inline int __rhashtable_insert_fast(
+ 	struct rhashtable *ht, const void *key, struct rhash_head *obj,
+ 	const struct rhashtable_params params)
+ {
+ 	struct rhashtable_compare_arg arg = {
+ 		.ht = ht,
+ 		.key = key,
+ 	};
+ 	int err = -EEXIST;
+ 	struct bucket_table *tbl, *new_tbl;
+ 	struct rhash_head *head;
+ 	spinlock_t *lock;
+ 	unsigned hash;
+ 
+ 	rcu_read_lock();
+ 
+ 	tbl = rht_dereference_rcu(ht->tbl, ht);
+ 
+ 	/* All insertions must grab the oldest table containing
+ 	 * the hashed bucket that is yet to be rehashed.
+ 	 */
+ 	for (;;) {
+ 		hash = rht_head_hashfn(ht, tbl, obj, params);
+ 		lock = rht_bucket_lock(tbl, hash);
+ 		spin_lock_bh(lock);
+ 
+ 		if (tbl->rehash <= hash)
+ 			break;
+ 
+ 		spin_unlock_bh(lock);
+ 		tbl = rht_dereference_rcu(tbl->future_tbl, ht);
+ 	}
+ 
+ 	new_tbl = rht_dereference_rcu(tbl->future_tbl, ht);
+ 	if (unlikely(new_tbl)) {
+ 		err = rhashtable_insert_slow(ht, key, obj, new_tbl);
+ 		goto out;
+ 	}
+ 
+ 	if (!key)
+ 		goto skip_lookup;
+ 
+ 	rht_for_each(head, tbl, hash) {
+ 		if (unlikely(!(params.obj_cmpfn ?
+ 			       params.obj_cmpfn(&arg, rht_obj(ht, head)) :
+ 			       rhashtable_compare(&arg, rht_obj(ht, head)))))
+ 			goto out;
+ 	}
+ 
+ skip_lookup:
+ 	err = 0;
+ 
+ 	head = rht_dereference_bucket(tbl->buckets[hash], tbl, hash);
+ 
+ 	RCU_INIT_POINTER(obj->next, head);
+ 
+ 	rcu_assign_pointer(tbl->buckets[hash], obj);
+ 
+ 	atomic_inc(&ht->nelems);
+ 	if (rht_grow_above_75(ht, tbl))
+ 		schedule_work(&ht->run_work);
+ 
+ out:
+ 	spin_unlock_bh(lock);
+ 	rcu_read_unlock();
+ 
+ 	return err;
+ }
+ 
+ /**
+  * rhashtable_insert_fast - insert object into hash table
+  * @ht:		hash table
+  * @obj:	pointer to hash head inside object
+  * @params:	hash table parameters
+  *
+  * Will take a per bucket spinlock to protect against mutual mutations
+  * on the same bucket. Multiple insertions may occur in parallel unless
+  * they map to the same bucket lock.
+  *
+  * It is safe to call this function from atomic context.
+  *
+  * Will trigger an automatic deferred table resizing if the size grows
+  * beyond the watermark indicated by grow_decision() which can be passed
+  * to rhashtable_init().
+  */
+ static inline int rhashtable_insert_fast(
+ 	struct rhashtable *ht, struct rhash_head *obj,
+ 	const struct rhashtable_params params)
+ {
+ 	return __rhashtable_insert_fast(ht, NULL, obj, params);
+ }
+ 
+ /**
+  * rhashtable_lookup_insert_fast - lookup and insert object into hash table
+  * @ht:		hash table
+  * @obj:	pointer to hash head inside object
+  * @params:	hash table parameters
+  *
+  * Locks down the bucket chain in both the old and new table if a resize
+  * is in progress to ensure that writers can't remove from the old table
+  * and can't insert to the new table during the atomic operation of search
+  * and insertion. Searches for duplicates in both the old and new table if
+  * a resize is in progress.
+  *
+  * This lookup function may only be used for fixed key hash table (key_len
+  * parameter set). It will BUG() if used inappropriately.
+  *
+  * It is safe to call this function from atomic context.
+  *
+  * Will trigger an automatic deferred table resizing if the size grows
+  * beyond the watermark indicated by grow_decision() which can be passed
+  * to rhashtable_init().
+  */
+ static inline int rhashtable_lookup_insert_fast(
+ 	struct rhashtable *ht, struct rhash_head *obj,
+ 	const struct rhashtable_params params)
+ {
+ 	const char *key = rht_obj(ht, obj);
+ 
+ 	BUG_ON(ht->p.obj_hashfn);
+ 
+ 	return __rhashtable_insert_fast(ht, key + ht->p.key_offset, obj,
+ 					params);
+ }
+ 
+ /**
+  * rhashtable_lookup_insert_key - search and insert object to hash table
+  *				  with explicit key
+  * @ht:		hash table
+  * @key:	key
+  * @obj:	pointer to hash head inside object
+  * @params:	hash table parameters
+  *
+  * Locks down the bucket chain in both the old and new table if a resize
+  * is in progress to ensure that writers can't remove from the old table
+  * and can't insert to the new table during the atomic operation of search
+  * and insertion. Searches for duplicates in both the old and new table if
+  * a resize is in progress.
+  *
+  * Lookups may occur in parallel with hashtable mutations and resizing.
+  *
+  * Will trigger an automatic deferred table resizing if the size grows
+  * beyond the watermark indicated by grow_decision() which can be passed
+  * to rhashtable_init().
+  *
+  * Returns zero on success.
+  */
+ static inline int rhashtable_lookup_insert_key(
+ 	struct rhashtable *ht, const void *key, struct rhash_head *obj,
+ 	const struct rhashtable_params params)
+ {
+ 	BUG_ON(!ht->p.obj_hashfn || !key);
+ 
+ 	return __rhashtable_insert_fast(ht, key, obj, params);
+ }
+ 
+ static inline int __rhashtable_remove_fast(
+ 	struct rhashtable *ht, struct bucket_table *tbl,
+ 	struct rhash_head *obj, const struct rhashtable_params params)
+ {
+ 	struct rhash_head __rcu **pprev;
+ 	struct rhash_head *he;
+ 	spinlock_t * lock;
+ 	unsigned hash;
+ 	int err = -ENOENT;
+ 
+ 	hash = rht_head_hashfn(ht, tbl, obj, params);
+ 	lock = rht_bucket_lock(tbl, hash);
+ 
+ 	spin_lock_bh(lock);
+ 
+ 	pprev = &tbl->buckets[hash];
+ 	rht_for_each(he, tbl, hash) {
+ 		if (he != obj) {
+ 			pprev = &he->next;
+ 			continue;
+ 		}
+ 
+ 		rcu_assign_pointer(*pprev, obj->next);
+ 		err = 0;
+ 		break;
+ 	}
+ 
+ 	spin_unlock_bh(lock);
+ 
+ 	return err;
+ }
+ 
+ /**
+  * rhashtable_remove_fast - remove object from hash table
+  * @ht:		hash table
+  * @obj:	pointer to hash head inside object
+  * @params:	hash table parameters
+  *
+  * Since the hash chain is single linked, the removal operation needs to
+  * walk the bucket chain upon removal. The removal operation is thus
+  * considerable slow if the hash table is not correctly sized.
+  *
+  * Will automatically shrink the table via rhashtable_expand() if the
+  * shrink_decision function specified at rhashtable_init() returns true.
+  *
+  * Returns zero on success, -ENOENT if the entry could not be found.
+  */
+ static inline int rhashtable_remove_fast(
+ 	struct rhashtable *ht, struct rhash_head *obj,
+ 	const struct rhashtable_params params)
+ {
+ 	struct bucket_table *tbl;
+ 	int err;
+ 
+ 	rcu_read_lock();
+ 
+ 	tbl = rht_dereference_rcu(ht->tbl, ht);
+ 
+ 	/* Because we have already taken (and released) the bucket
+ 	 * lock in old_tbl, if we find that future_tbl is not yet
+ 	 * visible then that guarantees the entry to still be in
+ 	 * the old tbl if it exists.
+ 	 */
+ 	while ((err = __rhashtable_remove_fast(ht, tbl, obj, params)) &&
+ 	       (tbl = rht_dereference_rcu(tbl->future_tbl, ht)))
+ 		;
+ 
+ 	if (err)
+ 		goto out;
+ 
+ 	atomic_dec(&ht->nelems);
+ 	if (rht_shrink_below_30(ht, tbl))
+ 		schedule_work(&ht->run_work);
+ 
+ out:
+ 	rcu_read_unlock();
+ 
+ 	return err;
+ }
+ 
++>>>>>>> b824478b2145 (rhashtable: Add multiple rehash support)
  #endif /* _LINUX_RHASHTABLE_H */
diff --cc lib/rhashtable.c
index 6d0c4774001c,5e04403e25f5..000000000000
--- a/lib/rhashtable.c
+++ b/lib/rhashtable.c
@@@ -114,76 -124,144 +114,197 @@@ static struct bucket_table *bucket_tabl
  	return tbl;
  }
  
++<<<<<<< HEAD
 +static void bucket_table_free(const struct bucket_table *tbl)
 +{
 +	kvfree(tbl);
 +}
++=======
+ static struct bucket_table *rhashtable_last_table(struct rhashtable *ht,
+ 						  struct bucket_table *tbl)
+ {
+ 	struct bucket_table *new_tbl;
+ 
+ 	do {
+ 		new_tbl = tbl;
+ 		tbl = rht_dereference_rcu(tbl->future_tbl, ht);
+ 	} while (tbl);
+ 
+ 	return new_tbl;
+ }
+ 
+ static int rhashtable_rehash_one(struct rhashtable *ht, unsigned old_hash)
+ {
+ 	struct bucket_table *old_tbl = rht_dereference(ht->tbl, ht);
+ 	struct bucket_table *new_tbl = rhashtable_last_table(ht,
+ 		rht_dereference_rcu(old_tbl->future_tbl, ht));
+ 	struct rhash_head __rcu **pprev = &old_tbl->buckets[old_hash];
+ 	int err = -ENOENT;
+ 	struct rhash_head *head, *next, *entry;
+ 	spinlock_t *new_bucket_lock;
+ 	unsigned new_hash;
++>>>>>>> b824478b2145 (rhashtable: Add multiple rehash support)
  
 -	rht_for_each(entry, old_tbl, old_hash) {
 -		err = 0;
 -		next = rht_dereference_bucket(entry->next, old_tbl, old_hash);
 +/**
 + * rht_grow_above_75 - returns true if nelems > 0.75 * table-size
 + * @ht:		hash table
 + * @new_size:	new table size
 + */
 +bool rht_grow_above_75(const struct rhashtable *ht, size_t new_size)
 +{
 +	/* Expand table when exceeding 75% load */
 +	return ht->nelems > (new_size / 4 * 3);
 +}
 +EXPORT_SYMBOL_GPL(rht_grow_above_75);
 +
 +/**
 + * rht_shrink_below_30 - returns true if nelems < 0.3 * table-size
 + * @ht:		hash table
 + * @new_size:	new table size
 + */
 +bool rht_shrink_below_30(const struct rhashtable *ht, size_t new_size)
 +{
 +	/* Shrink table beneath 30% load */
 +	return ht->nelems < (new_size * 3 / 10);
 +}
 +EXPORT_SYMBOL_GPL(rht_shrink_below_30);
 +
 +static void hashtable_chain_unzip(const struct rhashtable *ht,
 +				  const struct bucket_table *new_tbl,
 +				  struct bucket_table *old_tbl, size_t n)
 +{
 +	struct rhash_head *he, *p, *next;
 +	unsigned int h;
  
 -		if (rht_is_a_nulls(next))
 +	/* Old bucket empty, no work needed. */
 +	p = rht_dereference(old_tbl->buckets[n], ht);
 +	if (!p)
 +		return;
 +
 +	/* Advance the old bucket pointer one or more times until it
 +	 * reaches a node that doesn't hash to the same bucket as the
 +	 * previous node p. Call the previous node p;
 +	 */
 +	h = head_hashfn(ht, new_tbl, p);
 +	rht_for_each_continue(he, p->next, old_tbl, n) {
 +		if (head_hashfn(ht, new_tbl, he) != h)
  			break;
 +		p = he;
 +	}
 +	RCU_INIT_POINTER(old_tbl->buckets[n], p->next);
  
 -		pprev = &entry->next;
 +	/* Find the subsequent node which does hash to the same
 +	 * bucket as node P, or NULL if no such node exists.
 +	 */
 +	next = NULL;
 +	if (he) {
 +		rht_for_each_continue(he, he->next, old_tbl, n) {
 +			if (head_hashfn(ht, new_tbl, he) == h) {
 +				next = he;
 +				break;
 +			}
 +		}
  	}
  
++<<<<<<< HEAD
 +	/* Set p's next pointer to that subsequent node pointer,
 +	 * bypassing the nodes which do not hash to p's bucket
 +	 */
 +	RCU_INIT_POINTER(p->next, next);
++=======
+ 	if (err)
+ 		goto out;
+ 
+ 	new_hash = head_hashfn(ht, new_tbl, entry);
+ 
+ 	new_bucket_lock = rht_bucket_lock(new_tbl, new_hash);
+ 
+ 	spin_lock_nested(new_bucket_lock, SINGLE_DEPTH_NESTING);
+ 	head = rht_dereference_bucket(new_tbl->buckets[new_hash],
+ 				      new_tbl, new_hash);
+ 
+ 	if (rht_is_a_nulls(head))
+ 		INIT_RHT_NULLS_HEAD(entry->next, ht, new_hash);
+ 	else
+ 		RCU_INIT_POINTER(entry->next, head);
+ 
+ 	rcu_assign_pointer(new_tbl->buckets[new_hash], entry);
+ 	spin_unlock(new_bucket_lock);
+ 
+ 	rcu_assign_pointer(*pprev, next);
+ 
+ out:
+ 	return err;
+ }
+ 
+ static void rhashtable_rehash_chain(struct rhashtable *ht, unsigned old_hash)
+ {
+ 	struct bucket_table *old_tbl = rht_dereference(ht->tbl, ht);
+ 	spinlock_t *old_bucket_lock;
+ 
+ 	old_bucket_lock = rht_bucket_lock(old_tbl, old_hash);
+ 
+ 	spin_lock_bh(old_bucket_lock);
+ 	while (!rhashtable_rehash_one(ht, old_hash))
+ 		;
+ 	old_tbl->rehash++;
+ 	spin_unlock_bh(old_bucket_lock);
+ }
+ 
+ static int rhashtable_rehash_attach(struct rhashtable *ht,
+ 				    struct bucket_table *old_tbl,
+ 				    struct bucket_table *new_tbl)
+ {
+ 	/* Protect future_tbl using the first bucket lock. */
+ 	spin_lock_bh(old_tbl->locks);
+ 
+ 	/* Did somebody beat us to it? */
+ 	if (rcu_access_pointer(old_tbl->future_tbl)) {
+ 		spin_unlock_bh(old_tbl->locks);
+ 		return -EEXIST;
+ 	}
+ 
+ 	/* Make insertions go into the new, empty table right away. Deletions
+ 	 * and lookups will be attempted in both tables until we synchronize.
+ 	 */
+ 	rcu_assign_pointer(old_tbl->future_tbl, new_tbl);
+ 
+ 	/* Ensure the new table is visible to readers. */
+ 	smp_wmb();
+ 
+ 	spin_unlock_bh(old_tbl->locks);
+ 
+ 	return 0;
+ }
+ 
+ static int rhashtable_rehash_table(struct rhashtable *ht)
+ {
+ 	struct bucket_table *old_tbl = rht_dereference(ht->tbl, ht);
+ 	struct bucket_table *new_tbl;
+ 	struct rhashtable_walker *walker;
+ 	unsigned old_hash;
+ 
+ 	new_tbl = rht_dereference(old_tbl->future_tbl, ht);
+ 	if (!new_tbl)
+ 		return 0;
+ 
+ 	for (old_hash = 0; old_hash < old_tbl->size; old_hash++)
+ 		rhashtable_rehash_chain(ht, old_hash);
+ 
+ 	/* Publish the new table pointer. */
+ 	rcu_assign_pointer(ht->tbl, new_tbl);
+ 
+ 	list_for_each_entry(walker, &old_tbl->walkers, list)
+ 		walker->tbl = NULL;
+ 
+ 	/* Wait for readers. All new readers will see the new
+ 	 * table, and thus no references to the old table will
+ 	 * remain.
+ 	 */
+ 	call_rcu(&old_tbl->rcu, bucket_table_free_rcu);
+ 
+ 	return rht_dereference(new_tbl->future_tbl, ht) ? -EAGAIN : 0;
++>>>>>>> b824478b2145 (rhashtable: Add multiple rehash support)
  }
  
  /**
@@@ -196,77 -273,31 +317,94 @@@
   * This function may only be called in a context where it is safe to call
   * synchronize_rcu(), e.g. not within a rcu_read_lock() section.
   *
 - * The caller must ensure that no concurrent resizing occurs by holding
 - * ht->mutex.
 - *
 - * It is valid to have concurrent insertions and deletions protected by per
 - * bucket locks or concurrent RCU protected lookups and traversals.
 + * The caller must ensure that no concurrent table mutations take place.
 + * It is however valid to have concurrent lookups if they are RCU protected.
   */
- int rhashtable_expand(struct rhashtable *ht)
+ static int rhashtable_expand(struct rhashtable *ht)
  {
  	struct bucket_table *new_tbl, *old_tbl = rht_dereference(ht->tbl, ht);
++<<<<<<< HEAD
 +	struct rhash_head *he;
 +	unsigned int i, h;
 +	bool complete;
 +
 +	ASSERT_RHT_MUTEX(ht);
 +
 +	if (ht->p.max_shift && ht->shift >= ht->p.max_shift)
 +		return 0;
 +
 +	new_tbl = bucket_table_alloc(old_tbl->size * 2);
 +	if (new_tbl == NULL)
 +		return -ENOMEM;
 +
 +	ht->shift++;
 +
 +	/* For each new bucket, search the corresponding old bucket
 +	 * for the first entry that hashes to the new bucket, and
 +	 * link the new bucket to that entry. Since all the entries
 +	 * which will end up in the new bucket appear in the same
 +	 * old bucket, this constructs an entirely valid new hash
 +	 * table, but with multiple buckets "zipped" together into a
 +	 * single imprecise chain.
 +	 */
 +	for (i = 0; i < new_tbl->size; i++) {
 +		h = rht_bucket_index(old_tbl, i);
 +		rht_for_each(he, old_tbl, h) {
 +			if (head_hashfn(ht, new_tbl, he) == i) {
 +				RCU_INIT_POINTER(new_tbl->buckets[i], he);
 +				break;
 +			}
 +		}
 +	}
 +
 +	/* Publish the new table pointer. Lookups may now traverse
 +	 * the new table, but they will not benefit from any
 +	 * additional efficiency until later steps unzip the buckets.
 +	 */
 +	rcu_assign_pointer(ht->tbl, new_tbl);
 +
 +	/* Unzip interleaved hash chains */
 +	do {
 +		/* Wait for readers. All new readers will see the new
 +		 * table, and thus no references to the old table will
 +		 * remain.
 +		 */
 +		synchronize_rcu();
 +
 +		/* For each bucket in the old table (each of which
 +		 * contains items from multiple buckets of the new
 +		 * table): ...
 +		 */
 +		complete = true;
 +		for (i = 0; i < old_tbl->size; i++) {
 +			hashtable_chain_unzip(ht, new_tbl, old_tbl, i);
 +			if (old_tbl->buckets[i] != NULL)
 +				complete = false;
 +		}
 +	} while (!complete);
 +
 +	synchronize_rcu();
 +
 +	bucket_table_free(old_tbl);
 +	return 0;
++=======
+ 	int err;
+ 
+ 	ASSERT_RHT_MUTEX(ht);
+ 
+ 	old_tbl = rhashtable_last_table(ht, old_tbl);
+ 
+ 	new_tbl = bucket_table_alloc(ht, old_tbl->size * 2);
+ 	if (new_tbl == NULL)
+ 		return -ENOMEM;
+ 
+ 	err = rhashtable_rehash_attach(ht, old_tbl, new_tbl);
+ 	if (err)
+ 		bucket_table_free(new_tbl);
+ 
+ 	return err;
++>>>>>>> b824478b2145 (rhashtable: Add multiple rehash support)
  }
- EXPORT_SYMBOL_GPL(rhashtable_expand);
  
  /**
   * rhashtable_shrink - Shrink hash table while allowing concurrent lookups
@@@ -277,194 -311,294 +415,251 @@@
   *
   * The caller must ensure that no concurrent table mutations take place.
   * It is however valid to have concurrent lookups if they are RCU protected.
 - *
 - * It is valid to have concurrent insertions and deletions protected by per
 - * bucket locks or concurrent RCU protected lookups and traversals.
   */
- int rhashtable_shrink(struct rhashtable *ht)
+ static int rhashtable_shrink(struct rhashtable *ht)
  {
++<<<<<<< HEAD
 +	struct bucket_table *ntbl, *tbl = rht_dereference(ht->tbl, ht);
 +	unsigned int i;
++=======
+ 	struct bucket_table *new_tbl, *old_tbl = rht_dereference(ht->tbl, ht);
+ 	unsigned size = roundup_pow_of_two(atomic_read(&ht->nelems) * 3 / 2);
+ 	int err;
++>>>>>>> b824478b2145 (rhashtable: Add multiple rehash support)
  
  	ASSERT_RHT_MUTEX(ht);
  
 -	if (size < ht->p.min_size)
 -		size = ht->p.min_size;
 -
 -	if (old_tbl->size <= size)
 +	if (ht->shift <= ht->p.min_shift)
  		return 0;
  
++<<<<<<< HEAD
 +	ntbl = bucket_table_alloc(tbl->size / 2);
 +	if (ntbl == NULL)
 +		return -ENOMEM;
 +
 +	ht->shift--;
 +
 +	/* Link each bucket in the new table to the first bucket
 +	 * in the old table that contains entries which will hash
 +	 * to the new bucket.
 +	 */
 +	for (i = 0; i < ntbl->size; i++) {
 +		ntbl->buckets[i] = tbl->buckets[i];
 +		RCU_INIT_POINTER(*bucket_tail(ntbl, i),
 +				 tbl->buckets[i + ntbl->size]);
 +
 +	}
 +
 +	/* Publish the new, valid hash table */
 +	rcu_assign_pointer(ht->tbl, ntbl);
 +
 +	/* Wait for readers. No new readers will have references to the
 +	 * old hash table.
 +	 */
 +	synchronize_rcu();
 +
 +	bucket_table_free(tbl);
 +
 +	return 0;
++=======
+ 	if (rht_dereference(old_tbl->future_tbl, ht))
+ 		return -EEXIST;
+ 
+ 	new_tbl = bucket_table_alloc(ht, size);
+ 	if (new_tbl == NULL)
+ 		return -ENOMEM;
+ 
+ 	err = rhashtable_rehash_attach(ht, old_tbl, new_tbl);
+ 	if (err)
+ 		bucket_table_free(new_tbl);
+ 
+ 	return err;
++>>>>>>> b824478b2145 (rhashtable: Add multiple rehash support)
  }
- EXPORT_SYMBOL_GPL(rhashtable_shrink);
  
 -static void rht_deferred_worker(struct work_struct *work)
 +/**
 + * rhashtable_insert - insert object into hash hash table
 + * @ht:		hash table
 + * @obj:	pointer to hash head inside object
 + *
 + * Will automatically grow the table via rhashtable_expand() if the the
 + * grow_decision function specified at rhashtable_init() returns true.
 + *
 + * The caller must ensure that no concurrent table mutations occur. It is
 + * however valid to have concurrent lookups if they are RCU protected.
 + */
 +void rhashtable_insert(struct rhashtable *ht, struct rhash_head *obj)
  {
++<<<<<<< HEAD
 +	struct bucket_table *tbl = rht_dereference(ht->tbl, ht);
 +	u32 hash;
 +
 +	ASSERT_RHT_MUTEX(ht);
++=======
+ 	struct rhashtable *ht;
+ 	struct bucket_table *tbl;
+ 	int err = 0;
+ 
+ 	ht = container_of(work, struct rhashtable, run_work);
+ 	mutex_lock(&ht->mutex);
+ 	if (ht->being_destroyed)
+ 		goto unlock;
+ 
+ 	tbl = rht_dereference(ht->tbl, ht);
+ 	tbl = rhashtable_last_table(ht, tbl);
+ 
+ 	if (rht_grow_above_75(ht, tbl))
+ 		rhashtable_expand(ht);
+ 	else if (rht_shrink_below_30(ht, tbl))
+ 		rhashtable_shrink(ht);
+ 
+ 	err = rhashtable_rehash_table(ht);
+ 
+ unlock:
+ 	mutex_unlock(&ht->mutex);
+ 
+ 	if (err)
+ 		schedule_work(&ht->run_work);
+ }
+ 
+ int rhashtable_insert_slow(struct rhashtable *ht, const void *key,
+ 			   struct rhash_head *obj,
+ 			   struct bucket_table *tbl)
+ {
+ 	struct rhash_head *head;
+ 	unsigned hash;
+ 	int err = -EEXIST;
++>>>>>>> b824478b2145 (rhashtable: Add multiple rehash support)
  
+ 	tbl = rhashtable_last_table(ht, tbl);
  	hash = head_hashfn(ht, tbl, obj);
 -	spin_lock_nested(rht_bucket_lock(tbl, hash), SINGLE_DEPTH_NESTING);
 -
 -	if (key && rhashtable_lookup_fast(ht, key, ht->p))
 -		goto exit;
 -
 -	err = 0;
 -
 -	head = rht_dereference_bucket(tbl->buckets[hash], tbl, hash);
 -
 -	RCU_INIT_POINTER(obj->next, head);
 -
 +	RCU_INIT_POINTER(obj->next, tbl->buckets[hash]);
  	rcu_assign_pointer(tbl->buckets[hash], obj);
 +	ht->nelems++;
  
 -	atomic_inc(&ht->nelems);
 -
 -exit:
 -	spin_unlock(rht_bucket_lock(tbl, hash));
 -
 -	return err;
 +	if (ht->p.grow_decision && ht->p.grow_decision(ht, tbl->size))
 +		rhashtable_expand(ht);
  }
 -EXPORT_SYMBOL_GPL(rhashtable_insert_slow);
 +EXPORT_SYMBOL_GPL(rhashtable_insert);
  
  /**
 - * rhashtable_walk_init - Initialise an iterator
 - * @ht:		Table to walk over
 - * @iter:	Hash table Iterator
 - *
 - * This function prepares a hash table walk.
 + * rhashtable_remove - remove object from hash table
 + * @ht:		hash table
 + * @obj:	pointer to hash head inside object
   *
 - * Note that if you restart a walk after rhashtable_walk_stop you
 - * may see the same object twice.  Also, you may miss objects if
 - * there are removals in between rhashtable_walk_stop and the next
 - * call to rhashtable_walk_start.
 + * Since the hash chain is single linked, the removal operation needs to
 + * walk the bucket chain upon removal. The removal operation is thus
 + * considerable slow if the hash table is not correctly sized.
   *
 - * For a completely stable walk you should construct your own data
 - * structure outside the hash table.
 + * Will automatically shrink the table via rhashtable_expand() if the the
 + * shrink_decision function specified at rhashtable_init() returns true.
   *
 - * This function may sleep so you must not call it from interrupt
 - * context or with spin locks held.
 - *
 - * You must call rhashtable_walk_exit if this function returns
 - * successfully.
 + * The caller must ensure that no concurrent table mutations occur. It is
 + * however valid to have concurrent lookups if they are RCU protected.
   */
 -int rhashtable_walk_init(struct rhashtable *ht, struct rhashtable_iter *iter)
 +bool rhashtable_remove(struct rhashtable *ht, struct rhash_head *obj)
  {
 -	iter->ht = ht;
 -	iter->p = NULL;
 -	iter->slot = 0;
 -	iter->skip = 0;
 +	struct bucket_table *tbl = rht_dereference(ht->tbl, ht);
 +	struct rhash_head __rcu **pprev;
 +	struct rhash_head *he;
 +	u32 h;
  
 -	iter->walker = kmalloc(sizeof(*iter->walker), GFP_KERNEL);
 -	if (!iter->walker)
 -		return -ENOMEM;
 -
 -	mutex_lock(&ht->mutex);
 -	iter->walker->tbl = rht_dereference(ht->tbl, ht);
 -	list_add(&iter->walker->list, &iter->walker->tbl->walkers);
 -	mutex_unlock(&ht->mutex);
 -
 -	return 0;
 -}
 -EXPORT_SYMBOL_GPL(rhashtable_walk_init);
 -
 -/**
 - * rhashtable_walk_exit - Free an iterator
 - * @iter:	Hash table Iterator
 - *
 - * This function frees resources allocated by rhashtable_walk_init.
 - */
 -void rhashtable_walk_exit(struct rhashtable_iter *iter)
 -{
 -	mutex_lock(&iter->ht->mutex);
 -	if (iter->walker->tbl)
 -		list_del(&iter->walker->list);
 -	mutex_unlock(&iter->ht->mutex);
 -	kfree(iter->walker);
 -}
 -EXPORT_SYMBOL_GPL(rhashtable_walk_exit);
 -
 -/**
 - * rhashtable_walk_start - Start a hash table walk
 - * @iter:	Hash table iterator
 - *
 - * Start a hash table walk.  Note that we take the RCU lock in all
 - * cases including when we return an error.  So you must always call
 - * rhashtable_walk_stop to clean up.
 - *
 - * Returns zero if successful.
 - *
 - * Returns -EAGAIN if resize event occured.  Note that the iterator
 - * will rewind back to the beginning and you may use it immediately
 - * by calling rhashtable_walk_next.
 - */
 -int rhashtable_walk_start(struct rhashtable_iter *iter)
 -	__acquires(RCU)
 -{
 -	struct rhashtable *ht = iter->ht;
 +	ASSERT_RHT_MUTEX(ht);
  
 -	mutex_lock(&ht->mutex);
 +	h = head_hashfn(ht, tbl, obj);
  
 -	if (iter->walker->tbl)
 -		list_del(&iter->walker->list);
 +	pprev = &tbl->buckets[h];
 +	rht_for_each(he, tbl, h) {
 +		if (he != obj) {
 +			pprev = &he->next;
 +			continue;
 +		}
  
 -	rcu_read_lock();
 +		RCU_INIT_POINTER(*pprev, he->next);
 +		ht->nelems--;
  
 -	mutex_unlock(&ht->mutex);
 +		if (ht->p.shrink_decision &&
 +		    ht->p.shrink_decision(ht, tbl->size))
 +			rhashtable_shrink(ht);
  
 -	if (!iter->walker->tbl) {
 -		iter->walker->tbl = rht_dereference_rcu(ht->tbl, ht);
 -		return -EAGAIN;
 +		return true;
  	}
  
 -	return 0;
 +	return false;
  }
 -EXPORT_SYMBOL_GPL(rhashtable_walk_start);
 +EXPORT_SYMBOL_GPL(rhashtable_remove);
  
  /**
 - * rhashtable_walk_next - Return the next object and advance the iterator
 - * @iter:	Hash table iterator
 + * rhashtable_lookup - lookup key in hash table
 + * @ht:		hash table
 + * @key:	pointer to key
   *
 - * Note that you must call rhashtable_walk_stop when you are finished
 - * with the walk.
 + * Computes the hash value for the key and traverses the bucket chain looking
 + * for a entry with an identical key. The first matching entry is returned.
   *
 - * Returns the next object or NULL when the end of the table is reached.
 + * This lookup function may only be used for fixed key hash table (key_len
 + * paramter set). It will BUG() if used inappropriately.
   *
 - * Returns -EAGAIN if resize event occured.  Note that the iterator
 - * will rewind back to the beginning and you may continue to use it.
 + * Lookups may occur in parallel with hash mutations as long as the lookup is
 + * guarded by rcu_read_lock(). The caller must take care of this.
   */
 -void *rhashtable_walk_next(struct rhashtable_iter *iter)
 +void *rhashtable_lookup(const struct rhashtable *ht, const void *key)
  {
 -	struct bucket_table *tbl = iter->walker->tbl;
 -	struct rhashtable *ht = iter->ht;
 -	struct rhash_head *p = iter->p;
 -	void *obj = NULL;
 -
 -	if (p) {
 -		p = rht_dereference_bucket_rcu(p->next, tbl, iter->slot);
 -		goto next;
 -	}
 -
 -	for (; iter->slot < tbl->size; iter->slot++) {
 -		int skip = iter->skip;
 -
 -		rht_for_each_rcu(p, tbl, iter->slot) {
 -			if (!skip)
 -				break;
 -			skip--;
 -		}
 -
 -next:
 -		if (!rht_is_a_nulls(p)) {
 -			iter->skip++;
 -			iter->p = p;
 -			obj = rht_obj(ht, p);
 -			goto out;
 -		}
 -
 -		iter->skip = 0;
 +	const struct bucket_table *tbl = rht_dereference_rcu(ht->tbl, ht);
 +	struct rhash_head *he;
 +	u32 h;
 +
 +	BUG_ON(!ht->p.key_len);
 +
 +	h = key_hashfn(ht, key, ht->p.key_len);
 +	rht_for_each_rcu(he, tbl, h) {
 +		if (memcmp(rht_obj(ht, he) + ht->p.key_offset, key,
 +			   ht->p.key_len))
 +			continue;
 +		return rht_obj(ht, he);
  	}
  
 -	/* Ensure we see any new tables. */
 -	smp_rmb();
 -
 -	iter->walker->tbl = rht_dereference_rcu(tbl->future_tbl, ht);
 -	if (iter->walker->tbl) {
 -		iter->slot = 0;
 -		iter->skip = 0;
 -		return ERR_PTR(-EAGAIN);
 -	}
 -
 -	iter->p = NULL;
 -
 -out:
 -
 -	return obj;
 +	return NULL;
  }
 -EXPORT_SYMBOL_GPL(rhashtable_walk_next);
 +EXPORT_SYMBOL_GPL(rhashtable_lookup);
  
  /**
 - * rhashtable_walk_stop - Finish a hash table walk
 - * @iter:	Hash table iterator
 + * rhashtable_lookup_compare - search hash table with compare function
 + * @ht:		hash table
 + * @key:	the pointer to the key
 + * @compare:	compare function, must return true on match
 + * @arg:	argument passed on to compare function
 + *
 + * Traverses the bucket chain behind the provided hash value and calls the
 + * specified compare function for each entry.
 + *
 + * Lookups may occur in parallel with hash mutations as long as the lookup is
 + * guarded by rcu_read_lock(). The caller must take care of this.
   *
 - * Finish a hash table walk.
 + * Returns the first entry on which the compare function returned true.
   */
 -void rhashtable_walk_stop(struct rhashtable_iter *iter)
 -	__releases(RCU)
 +void *rhashtable_lookup_compare(const struct rhashtable *ht, const void *key,
 +				bool (*compare)(void *, void *), void *arg)
  {
 -	struct rhashtable *ht;
 -	struct bucket_table *tbl = iter->walker->tbl;
 -
 -	if (!tbl)
 -		goto out;
 -
 -	ht = iter->ht;
 -
 -	mutex_lock(&ht->mutex);
 -	if (tbl->rehash < tbl->size)
 -		list_add(&iter->walker->list, &tbl->walkers);
 -	else
 -		iter->walker->tbl = NULL;
 -	mutex_unlock(&ht->mutex);
 -
 -	iter->p = NULL;
 +	const struct bucket_table *tbl = rht_dereference_rcu(ht->tbl, ht);
 +	struct rhash_head *he;
 +	u32 hash;
 +
 +	hash = key_hashfn(ht, key, ht->p.key_len);
 +	rht_for_each_rcu(he, tbl, hash) {
 +		if (!compare(rht_obj(ht, he), arg))
 +			continue;
 +		return rht_obj(ht, he);
 +	}
  
 -out:
 -	rcu_read_unlock();
 +	return NULL;
  }
 -EXPORT_SYMBOL_GPL(rhashtable_walk_stop);
 +EXPORT_SYMBOL_GPL(rhashtable_lookup_compare);
  
 -static size_t rounded_hashtable_size(const struct rhashtable_params *params)
 +static size_t rounded_hashtable_size(struct rhashtable_params *params)
  {
  	return max(roundup_pow_of_two(params->nelem_hint * 4 / 3),
 -		   (unsigned long)params->min_size);
 -}
 -
 -static u32 rhashtable_jhash2(const void *key, u32 length, u32 seed)
 -{
 -	return jhash2(key, length, seed);
 +		   1UL << params->min_shift);
  }
  
  /**
* Unmerged path lib/test_rhashtable.c
* Unmerged path include/linux/rhashtable.h
* Unmerged path lib/rhashtable.c
* Unmerged path lib/test_rhashtable.c
