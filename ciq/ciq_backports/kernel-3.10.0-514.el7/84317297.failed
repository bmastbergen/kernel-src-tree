dax: fix race between simultaneous faults

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matthew Wilcox <willy@linux.intel.com>
commit 843172978bb92997310d2f7fbc172ece423cfc02
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/84317297.failed

If two threads write-fault on the same hole at the same time, the winner
of the race will return to userspace and complete their store, only to
have the loser overwrite their store with zeroes.  Fix this for now by
taking the i_mmap_sem for write instead of read, and do so outside the
call to get_block().  Now the loser of the race will see the block has
already been zeroed, and will not zero it again.

This severely limits our scalability.  I have ideas for improving it, but
those can wait for a later patch.

	Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 843172978bb92997310d2f7fbc172ece423cfc02)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
#	mm/memory.c
diff --cc mm/memory.c
index 66d68efad529,320c42e95e69..000000000000
--- a/mm/memory.c
+++ b/mm/memory.c
@@@ -3195,12 -2427,16 +3195,25 @@@ void unmap_mapping_range(struct address
  		details.last_index = ULONG_MAX;
  
  
++<<<<<<< HEAD
 +	mutex_lock(&mapping->i_mmap_mutex);
 +	if (unlikely(!RB_EMPTY_ROOT(&mapping->i_mmap)))
 +		unmap_mapping_range_tree(&mapping->i_mmap, &details);
 +	if (unlikely(!list_empty(&mapping->i_mmap_nonlinear)))
 +		unmap_mapping_range_list(&mapping->i_mmap_nonlinear, &details);
 +	mutex_unlock(&mapping->i_mmap_mutex);
++=======
+ 	/*
+ 	 * DAX already holds i_mmap_lock to serialise file truncate vs
+ 	 * page fault and page fault vs page fault.
+ 	 */
+ 	if (!IS_DAX(mapping->host))
+ 		i_mmap_lock_write(mapping);
+ 	if (unlikely(!RB_EMPTY_ROOT(&mapping->i_mmap)))
+ 		unmap_mapping_range_tree(&mapping->i_mmap, &details);
+ 	if (!IS_DAX(mapping->host))
+ 		i_mmap_unlock_write(mapping);
++>>>>>>> 843172978bb9 (dax: fix race between simultaneous faults)
  }
  EXPORT_SYMBOL(unmap_mapping_range);
  
* Unmerged path fs/dax.c
* Unmerged path fs/dax.c
* Unmerged path mm/memory.c
