drm/i915/kbl: Add WaSkipStolenMemoryFirstPage for A0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drm] i915/kbl: Add WaSkipStolenMemoryFirstPage for A0 (Rob Clark) [1348329 1349064]
Rebuild_FUZZ: 96.00%
commit-author Mika Kuoppala <mika.kuoppala@linux.intel.com>
commit 6e4f10c33a8bd0df4412bc31c0f11930e0228123
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6e4f10c3.failed

We need this for kbl a0 boards. Note that this should be also
for bxt A0 but we omit that on purpose as bxt A0's are
out of fashion already.

References: HSD#1912158, HSD#4393097
	Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
	Reviewed-by: Matthew Auld <matthew.auld@intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1465309159-30531-5-git-send-email-mika.kuoppala@intel.com
(cherry picked from commit 6e4f10c33a8bd0df4412bc31c0f11930e0228123)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_gem_stolen.c
diff --cc drivers/gpu/drm/i915/i915_gem_stolen.c
index f8da71682c96,e9cd82290408..000000000000
--- a/drivers/gpu/drm/i915/i915_gem_stolen.c
+++ b/drivers/gpu/drm/i915/i915_gem_stolen.c
@@@ -42,9 -45,54 +42,56 @@@
   * for is a boon.
   */
  
++<<<<<<< HEAD
++=======
+ int i915_gem_stolen_insert_node_in_range(struct drm_i915_private *dev_priv,
+ 					 struct drm_mm_node *node, u64 size,
+ 					 unsigned alignment, u64 start, u64 end)
+ {
+ 	int ret;
+ 
+ 	if (!drm_mm_initialized(&dev_priv->mm.stolen))
+ 		return -ENODEV;
+ 
+ 	/* See the comment at the drm_mm_init() call for more about this check.
+ 	 * WaSkipStolenMemoryFirstPage:bdw,chv,kbl (incomplete)
+ 	 */
+ 	if (start < 4096 && (IS_GEN8(dev_priv) ||
+ 			     IS_KBL_REVID(dev_priv, 0, KBL_REVID_A0)))
+ 		start = 4096;
+ 
+ 	mutex_lock(&dev_priv->mm.stolen_lock);
+ 	ret = drm_mm_insert_node_in_range(&dev_priv->mm.stolen, node, size,
+ 					  alignment, start, end,
+ 					  DRM_MM_SEARCH_DEFAULT);
+ 	mutex_unlock(&dev_priv->mm.stolen_lock);
+ 
+ 	return ret;
+ }
+ 
+ int i915_gem_stolen_insert_node(struct drm_i915_private *dev_priv,
+ 				struct drm_mm_node *node, u64 size,
+ 				unsigned alignment)
+ {
+ 	struct i915_ggtt *ggtt = &dev_priv->ggtt;
+ 
+ 	return i915_gem_stolen_insert_node_in_range(dev_priv, node, size,
+ 						    alignment, 0,
+ 						    ggtt->stolen_usable_size);
+ }
+ 
+ void i915_gem_stolen_remove_node(struct drm_i915_private *dev_priv,
+ 				 struct drm_mm_node *node)
+ {
+ 	mutex_lock(&dev_priv->mm.stolen_lock);
+ 	drm_mm_remove_node(node);
+ 	mutex_unlock(&dev_priv->mm.stolen_lock);
+ }
+ 
++>>>>>>> 6e4f10c33a8b (drm/i915/kbl: Add WaSkipStolenMemoryFirstPage for A0)
  static unsigned long i915_stolen_to_physical(struct drm_device *dev)
  {
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -	struct i915_ggtt *ggtt = &dev_priv->ggtt;
 +	struct drm_i915_private *dev_priv = dev->dev_private;
  	struct resource *r;
  	u32 base;
  
* Unmerged path drivers/gpu/drm/i915/i915_gem_stolen.c
