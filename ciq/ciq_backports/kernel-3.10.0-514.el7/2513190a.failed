fsnotify: Fix detection whether overflow event is queued

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jan Kara <jack@suse.cz>
commit 2513190a926f093dbdc301c68e6ade0bcf293f9a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2513190a.failed

Currently we didn't initialize event's list head when we removed it from
the event list. Thus a detection whether overflow event is already
queued wasn't working. Fix it by always initializing the list head when
deleting event from a list.

	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 2513190a926f093dbdc301c68e6ade0bcf293f9a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/notification.c
diff --cc fs/notify/notification.c
index a03904d119e4,6bec2f4918f9..000000000000
--- a/fs/notify/notification.c
+++ b/fs/notify/notification.c
@@@ -256,19 -130,13 +256,29 @@@ struct fsnotify_event *fsnotify_remove_
  
  	pr_debug("%s: group=%p\n", __func__, group);
  
++<<<<<<< HEAD
 +	holder = list_first_entry(&group->notification_list, struct fsnotify_event_holder, event_list);
 +
 +	event = holder->event;
 +
 +	spin_lock(&event->lock);
 +	holder->event = NULL;
 +	list_del_init(&holder->event_list);
 +	spin_unlock(&event->lock);
 +
 +	/* event == holder means we are referenced through the in event holder */
 +	if (holder != &event->holder)
 +		fsnotify_destroy_event_holder(holder);
 +
++=======
+ 	event = list_first_entry(&group->notification_list,
+ 				 struct fsnotify_event, list);
+ 	/*
+ 	 * We need to init list head for the case of overflow event so that
+ 	 * check in fsnotify_add_notify_events() works
+ 	 */
+ 	list_del_init(&event->list);
++>>>>>>> 2513190a926f (fsnotify: Fix detection whether overflow event is queued)
  	group->q_len--;
  
  	return event;
* Unmerged path fs/notify/notification.c
