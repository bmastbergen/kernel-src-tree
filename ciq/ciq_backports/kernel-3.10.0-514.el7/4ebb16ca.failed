block: introduce bdev_file_inode()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit 4ebb16ca9a06a54cdb2e7f2ce1e506fa4d432445
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4ebb16ca.failed

Similar to the file_inode() helper, provide a helper to lookup the inode for a
raw block device itself.

	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Suggested-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Jeff Moyer <jmoyer@redhat.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 4ebb16ca9a06a54cdb2e7f2ce1e506fa4d432445)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/block_dev.c
diff --cc fs/block_dev.c
index 2557803cf68e,52248bce42d2..000000000000
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@@ -154,16 -156,23 +154,21 @@@ blkdev_get_block(struct inode *inode, s
  	return 0;
  }
  
+ static struct inode *bdev_file_inode(struct file *file)
+ {
+ 	return file->f_mapping->host;
+ }
+ 
  static ssize_t
 -blkdev_direct_IO(struct kiocb *iocb, struct iov_iter *iter, loff_t offset)
 +blkdev_direct_IO(int rw, struct kiocb *iocb, const struct iovec *iov,
 +			loff_t offset, unsigned long nr_segs)
  {
  	struct file *file = iocb->ki_filp;
- 	struct inode *inode = file->f_mapping->host;
+ 	struct inode *inode = bdev_file_inode(file);
  
 -	if (IS_DAX(inode))
 -		return dax_do_io(iocb, inode, iter, offset, blkdev_get_block,
 -				NULL, DIO_SKIP_DIO_COUNT);
 -	return __blockdev_direct_IO(iocb, inode, I_BDEV(inode), iter, offset,
 -				    blkdev_get_block, NULL, NULL,
 -				    DIO_SKIP_DIO_COUNT);
 +	return __blockdev_direct_IO(rw, iocb, inode, I_BDEV(inode), iov, offset,
 +				    nr_segs, blkdev_get_block, NULL, NULL,
 +				    DIO_IGNORE_TRUNCATE);
  }
  
  int __sync_blockdev(struct block_device *bdev, int wait)
@@@ -328,8 -343,7 +333,12 @@@ static int blkdev_write_end(struct fil
   */
  static loff_t block_llseek(struct file *file, loff_t offset, int whence)
  {
++<<<<<<< HEAD
 +	struct inode *bd_inode = file->f_mapping->host;
 +	loff_t size;
++=======
+ 	struct inode *bd_inode = bdev_file_inode(file);
++>>>>>>> 4ebb16ca9a06 (block: introduce bdev_file_inode())
  	loff_t retval;
  
  	mutex_lock(&bd_inode->i_mutex);
@@@ -1633,10 -1639,11 +1642,15 @@@ static long block_ioctl(struct file *fi
   * Does not take i_mutex for the write and thus is not for general purpose
   * use.
   */
 -ssize_t blkdev_write_iter(struct kiocb *iocb, struct iov_iter *from)
 +ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,
 +			 unsigned long nr_segs, loff_t pos)
  {
  	struct file *file = iocb->ki_filp;
++<<<<<<< HEAD
++=======
+ 	struct inode *bd_inode = bdev_file_inode(file);
+ 	loff_t size = i_size_read(bd_inode);
++>>>>>>> 4ebb16ca9a06 (block: introduce bdev_file_inode())
  	struct blk_plug plug;
  	ssize_t ret;
  
@@@ -1654,14 -1669,14 +1668,14 @@@
  	blk_finish_plug(&plug);
  	return ret;
  }
 -EXPORT_SYMBOL_GPL(blkdev_write_iter);
 +EXPORT_SYMBOL_GPL(blkdev_aio_write);
  
 -ssize_t blkdev_read_iter(struct kiocb *iocb, struct iov_iter *to)
 +ssize_t blkdev_aio_read(struct kiocb *iocb, const struct iovec *iov,
 +			unsigned long nr_segs, loff_t pos)
  {
  	struct file *file = iocb->ki_filp;
- 	struct inode *bd_inode = file->f_mapping->host;
+ 	struct inode *bd_inode = bdev_file_inode(file);
  	loff_t size = i_size_read(bd_inode);
 -	loff_t pos = iocb->ki_pos;
  
  	if (pos >= size)
  		return 0;
* Unmerged path fs/block_dev.c
