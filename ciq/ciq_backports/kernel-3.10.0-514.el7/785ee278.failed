cpufreq: intel_pstate: Fix limits->max_perf rounding error

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [cpufreq] intel_pstate: Fix limits->max_perf rounding error (Prarit Bhargava) [1279617]
Rebuild_FUZZ: 91.59%
commit-author Prarit Bhargava <prarit@redhat.com>
commit 785ee27881411bd971d5e37a7fd72a5063fc1237
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/785ee278.failed

A rounding error was found in the calculation of limits->max_perf
in intel_pstate_set_policy(), which is used to calculate the max and min
pstate values in intel_pstate_get_min_max().  In that code,
limits->max_perf is truncated to 2 hex digits such that, for example,
0x169 was incorrectly calculated to 0x16 instead of 0x17.  This resulted in
the pstate being set one level too low.  This patch rounds the value of
limits->max_perf up instead of down so that the correct max pstate can
be reached.

	Signed-off-by: Prarit Bhargava <prarit@redhat.com>
	Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 785ee27881411bd971d5e37a7fd72a5063fc1237)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 9d42010c6969,8ad1f958ffe4..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -969,14 -1104,32 +969,35 @@@ static int intel_pstate_set_policy(stru
  		return 0;
  	}
  
 -	pr_debug("intel_pstate: set powersave\n");
 -	limits = &powersave_limits;
 -	limits->min_policy_pct = (policy->min * 100) / policy->cpuinfo.max_freq;
 -	limits->min_policy_pct = clamp_t(int, limits->min_policy_pct, 0 , 100);
 -	limits->max_policy_pct = DIV_ROUND_UP(policy->max * 100,
 -					      policy->cpuinfo.max_freq);
 -	limits->max_policy_pct = clamp_t(int, limits->max_policy_pct, 0 , 100);
 +	limits.min_perf_pct = (policy->min * 100) / policy->cpuinfo.max_freq;
 +	limits.min_perf_pct = clamp_t(int, limits.min_perf_pct, 0 , 100);
 +	limits.min_perf = div_fp(int_tofp(limits.min_perf_pct), int_tofp(100));
  
++<<<<<<< HEAD
 +	limits.max_policy_pct = (policy->max * 100) / policy->cpuinfo.max_freq;
 +	limits.max_policy_pct = clamp_t(int, limits.max_policy_pct, 0 , 100);
 +	limits.max_perf_pct = min(limits.max_policy_pct, limits.max_sysfs_pct);
 +	limits.max_perf = div_fp(int_tofp(limits.max_perf_pct), int_tofp(100));
++=======
+ 	/* Normalize user input to [min_policy_pct, max_policy_pct] */
+ 	limits->min_perf_pct = max(limits->min_policy_pct,
+ 				   limits->min_sysfs_pct);
+ 	limits->min_perf_pct = min(limits->max_policy_pct,
+ 				   limits->min_perf_pct);
+ 	limits->max_perf_pct = min(limits->max_policy_pct,
+ 				   limits->max_sysfs_pct);
+ 	limits->max_perf_pct = max(limits->min_policy_pct,
+ 				   limits->max_perf_pct);
+ 	limits->max_perf = round_up(limits->max_perf, 8);
+ 
+ 	/* Make sure min_perf_pct <= max_perf_pct */
+ 	limits->min_perf_pct = min(limits->max_perf_pct, limits->min_perf_pct);
+ 
+ 	limits->min_perf = div_fp(int_tofp(limits->min_perf_pct),
+ 				  int_tofp(100));
+ 	limits->max_perf = div_fp(int_tofp(limits->max_perf_pct),
+ 				  int_tofp(100));
++>>>>>>> 785ee2788141 (cpufreq: intel_pstate: Fix limits->max_perf rounding error)
  
  	if (hwp_active)
  		intel_pstate_hwp_set();
* Unmerged path drivers/cpufreq/intel_pstate.c
