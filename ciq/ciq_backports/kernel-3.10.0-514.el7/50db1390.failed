drm/i915/psr: Try to program link training times correctly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drm] i915/psr: Try to program link training times correctly (Rob Clark) [1348329 1349064]
Rebuild_FUZZ: 96.43%
commit-author Daniel Vetter <daniel.vetter@ffwll.ch>
commit 50db139018f9c94376d5f4db94a3bae65fdfac14
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/50db1390.failed

The default of 0 is 500us of link training, but that's not enough for
some platforms. Decoding this correctly means we're using 2.5ms of
link training on these platforms, which fixes flickering issues
associated with enabling PSR.

v2: Unbotch the math a bit.

v3: Drop debug hunk.

v4: Improve commit message.

	Tested-by: Lyude <cpaul@redhat.com>
	Cc: Lyude <cpaul@redhat.com>
	Cc: stable@vger.kernel.org
Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=95176
	Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
	Cc: Sonika Jindal <sonika.jindal@intel.com>
	Cc: Durgadoss R <durgadoss.r@intel.com>
	Cc: "Pandiyan, Dhinakaran" <dhinakaran.pandiyan@intel.com>
	Tested-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Reviewed-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Tested-by: fritsch@kodi.tv
	Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1463590036-17824-2-git-send-email-daniel.vetter@ffwll.ch
(cherry picked from commit 50db139018f9c94376d5f4db94a3bae65fdfac14)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_psr.c
diff --cc drivers/gpu/drm/i915/intel_psr.c
index a8f9348259ae,a788d1e9589b..000000000000
--- a/drivers/gpu/drm/i915/intel_psr.c
+++ b/drivers/gpu/drm/i915/intel_psr.c
@@@ -232,29 -270,71 +232,84 @@@ static void hsw_psr_enable_source(struc
  	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
  	struct drm_device *dev = dig_port->base.base.dev;
  	struct drm_i915_private *dev_priv = dev->dev_private;
 -
  	uint32_t max_sleep_time = 0x1f;
 -	/*
 -	 * Let's respect VBT in case VBT asks a higher idle_frame value.
 -	 * Let's use 6 as the minimum to cover all known cases including
 -	 * the off-by-one issue that HW has in some cases. Also there are
 -	 * cases where sink should be able to train
 -	 * with the 5 or 6 idle patterns.
 +	/* Lately it was identified that depending on panel idle frame count
 +	 * calculated at HW can be off by 1. So let's use what came
 +	 * from VBT + 1 and at minimum 2 to be on the safe side.
  	 */
++<<<<<<< HEAD
 +	uint32_t idle_frames = dev_priv->vbt.psr.idle_frames ?
 +			       dev_priv->vbt.psr.idle_frames + 1 : 2;
 +	uint32_t val = 0x0;
 +	const uint32_t link_entry_time = EDP_PSR_MIN_LINK_ENTRY_TIME_8_LINES;
++=======
+ 	uint32_t idle_frames = max(6, dev_priv->vbt.psr.idle_frames);
+ 	uint32_t val = EDP_PSR_ENABLE;
+ 
+ 	val |= max_sleep_time << EDP_PSR_MAX_SLEEP_TIME_SHIFT;
+ 	val |= idle_frames << EDP_PSR_IDLE_FRAME_SHIFT;
++>>>>>>> 50db139018f9 (drm/i915/psr: Try to program link training times correctly)
  
 -	if (IS_HASWELL(dev))
 -		val |= EDP_PSR_MIN_LINK_ENTRY_TIME_8_LINES;
 -
 -	if (dev_priv->psr.link_standby)
 +	if (dev_priv->psr.link_standby) {
  		val |= EDP_PSR_LINK_STANDBY;
 -
 +		val |= EDP_PSR_TP2_TP3_TIME_0us;
 +		val |= EDP_PSR_TP1_TIME_0us;
 +		val |= EDP_PSR_SKIP_AUX_EXIT;
 +	} else
 +		val |= EDP_PSR_LINK_DISABLE;
 +
++<<<<<<< HEAD
 +	I915_WRITE(EDP_PSR_CTL(dev), val |
 +		   (IS_BROADWELL(dev) ? 0 : link_entry_time) |
 +		   max_sleep_time << EDP_PSR_MAX_SLEEP_TIME_SHIFT |
 +		   idle_frames << EDP_PSR_IDLE_FRAME_SHIFT |
 +		   EDP_PSR_ENABLE);
++=======
+ 	if (dev_priv->vbt.psr.tp1_wakeup_time > 5)
+ 		val |= EDP_PSR_TP1_TIME_2500us;
+ 	else if (dev_priv->vbt.psr.tp1_wakeup_time > 1)
+ 		val |= EDP_PSR_TP1_TIME_500us;
+ 	else if (dev_priv->vbt.psr.tp1_wakeup_time > 0)
+ 		val |= EDP_PSR_TP1_TIME_100us;
+ 	else
+ 		val |= EDP_PSR_TP1_TIME_0us;
+ 
+ 	if (dev_priv->vbt.psr.tp2_tp3_wakeup_time > 5)
+ 		val |= EDP_PSR_TP2_TP3_TIME_2500us;
+ 	else if (dev_priv->vbt.psr.tp2_tp3_wakeup_time > 1)
+ 		val |= EDP_PSR_TP2_TP3_TIME_500us;
+ 	else if (dev_priv->vbt.psr.tp2_tp3_wakeup_time > 0)
+ 		val |= EDP_PSR_TP2_TP3_TIME_100us;
+ 	else
+ 		val |= EDP_PSR_TP2_TP3_TIME_0us;
+ 
+ 	if (intel_dp_source_supports_hbr2(intel_dp) &&
+ 	    drm_dp_tps3_supported(intel_dp->dpcd))
+ 		val |= EDP_PSR_TP1_TP3_SEL;
+ 	else
+ 		val |= EDP_PSR_TP1_TP2_SEL;
+ 
+ 	I915_WRITE(EDP_PSR_CTL, val);
+ 
+ 	if (!dev_priv->psr.psr2_support)
+ 		return;
+ 
+ 	/* FIXME: selective update is probably totally broken because it doesn't
+ 	 * mesh at all with our frontbuffer tracking. And the hw alone isn't
+ 	 * good enough. */
+ 	val = EDP_PSR2_ENABLE | EDP_SU_TRACK_ENABLE;
+ 
+ 	if (dev_priv->vbt.psr.tp2_tp3_wakeup_time > 5)
+ 		val |= EDP_PSR2_TP2_TIME_2500;
+ 	else if (dev_priv->vbt.psr.tp2_tp3_wakeup_time > 1)
+ 		val |= EDP_PSR2_TP2_TIME_500;
+ 	else if (dev_priv->vbt.psr.tp2_tp3_wakeup_time > 0)
+ 		val |= EDP_PSR2_TP2_TIME_100;
+ 	else
+ 		val |= EDP_PSR2_TP2_TIME_50;
+ 
+ 	I915_WRITE(EDP_PSR2_CTL, val);
++>>>>>>> 50db139018f9 (drm/i915/psr: Try to program link training times correctly)
  }
  
  static bool intel_psr_match_conditions(struct intel_dp *intel_dp)
* Unmerged path drivers/gpu/drm/i915/intel_psr.c
