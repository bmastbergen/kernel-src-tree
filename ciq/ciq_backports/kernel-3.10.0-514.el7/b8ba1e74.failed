tpm_tis: Tighten IRQ auto-probing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
commit b8ba1e744445d65dad7dd61db909e7f2b89df35e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b8ba1e74.failed

auto-probing doesn't work with shared interrupts, and the auto detection
interrupt range is for x86 only.

	Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
	Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Tested-by: Martin Wilck <Martin.Wilck@ts.fujitsu.com>
	Tested-by: Scot Doyle <lkml14@scotdoyle.com>
	Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Acked-by: Peter Huewe <peterhuewe@gmx.de>
(cherry picked from commit b8ba1e744445d65dad7dd61db909e7f2b89df35e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm_tis.c
diff --cc drivers/char/tpm/tpm_tis.c
index b6392eb21cdb,8a3509cb10da..000000000000
--- a/drivers/char/tpm/tpm_tis.c
+++ b/drivers/char/tpm/tpm_tis.c
@@@ -564,6 -599,84 +564,87 @@@ static irqreturn_t tis_int_handler(int 
  	return IRQ_HANDLED;
  }
  
++<<<<<<< HEAD
++=======
+ /* Register the IRQ and issue a command that will cause an interrupt. If an
+  * irq is seen then leave the chip setup for IRQ operation, otherwise reverse
+  * everything and leave in polling mode. Returns 0 on success.
+  */
+ static int tpm_tis_probe_irq_single(struct tpm_chip *chip, u32 intmask,
+ 				    int flags, int irq)
+ {
+ 	struct priv_data *priv = chip->vendor.priv;
+ 	u8 original_int_vec;
+ 
+ 	if (devm_request_irq(chip->pdev, irq, tis_int_handler, flags,
+ 			     chip->devname, chip) != 0) {
+ 		dev_info(chip->pdev, "Unable to request irq: %d for probe\n",
+ 			 irq);
+ 		return -1;
+ 	}
+ 	chip->vendor.irq = irq;
+ 
+ 	original_int_vec = ioread8(chip->vendor.iobase +
+ 				   TPM_INT_VECTOR(chip->vendor.locality));
+ 	iowrite8(irq,
+ 		 chip->vendor.iobase + TPM_INT_VECTOR(chip->vendor.locality));
+ 
+ 	/* Clear all existing */
+ 	iowrite32(ioread32(chip->vendor.iobase +
+ 			   TPM_INT_STATUS(chip->vendor.locality)),
+ 		  chip->vendor.iobase + TPM_INT_STATUS(chip->vendor.locality));
+ 
+ 	/* Turn on */
+ 	iowrite32(intmask | TPM_GLOBAL_INT_ENABLE,
+ 		  chip->vendor.iobase + TPM_INT_ENABLE(chip->vendor.locality));
+ 
+ 	priv->irq_tested = false;
+ 
+ 	/* Generate an interrupt by having the core call through to
+ 	 * tpm_tis_send
+ 	 */
+ 	if (chip->flags & TPM_CHIP_FLAG_TPM2)
+ 		tpm2_gen_interrupt(chip);
+ 	else
+ 		tpm_gen_interrupt(chip);
+ 
+ 	/* tpm_tis_send will either confirm the interrupt is working or it
+ 	 * will call disable_irq which undoes all of the above.
+ 	 */
+ 	if (!chip->vendor.irq) {
+ 		iowrite8(original_int_vec,
+ 			 chip->vendor.iobase +
+ 			     TPM_INT_VECTOR(chip->vendor.locality));
+ 		return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /* Try to find the IRQ the TPM is using. This is for legacy x86 systems that
+  * do not have ACPI/etc. We typically expect the interrupt to be declared if
+  * present.
+  */
+ static void tpm_tis_probe_irq(struct tpm_chip *chip, u32 intmask)
+ {
+ 	u8 original_int_vec;
+ 	int i;
+ 
+ 	original_int_vec = ioread8(chip->vendor.iobase +
+ 				   TPM_INT_VECTOR(chip->vendor.locality));
+ 
+ 	if (!original_int_vec) {
+ 		if (IS_ENABLED(CONFIG_X86))
+ 			for (i = 3; i <= 15; i++)
+ 				if (!tpm_tis_probe_irq_single(chip, intmask, 0,
+ 							      i))
+ 					return;
+ 	} else if (!tpm_tis_probe_irq_single(chip, intmask, 0,
+ 					     original_int_vec))
+ 		return;
+ }
+ 
++>>>>>>> b8ba1e744445 (tpm_tis: Tighten IRQ auto-probing)
  static bool interrupts = true;
  module_param(interrupts, bool, 0444);
  MODULE_PARM_DESC(interrupts, "Enable interrupts");
@@@ -696,98 -807,15 +777,110 @@@ static int tpm_tis_init(struct device *
  	/* INTERRUPT Setup */
  	init_waitqueue_head(&chip->vendor.read_queue);
  	init_waitqueue_head(&chip->vendor.int_queue);
++<<<<<<< HEAD
 +
 +	if (interrupts)
 +		chip->vendor.irq = irq;
 +	if (interrupts && !chip->vendor.irq) {
 +		irq_s =
 +		    ioread8(chip->vendor.iobase +
 +			    TPM_INT_VECTOR(chip->vendor.locality));
 +		irq_r = irq_s;
 +		if (irq_s) {
 +			irq_e = irq_s;
 +		} else {
 +			irq_s = 3;
 +			irq_e = 15;
 +		}
 +
 +		for (i = irq_s; i <= irq_e && chip->vendor.irq == 0; i++) {
 +			iowrite8(i, chip->vendor.iobase +
 +				 TPM_INT_VECTOR(chip->vendor.locality));
 +			if (devm_request_irq
 +			    (dev, i, tis_int_handler, IRQF_SHARED,
 +			     chip->devname, chip) != 0) {
 +				dev_info(chip->pdev,
 +					 "Unable to request irq: %d for probe\n",
 +					 i);
 +				continue;
 +			}
 +			chip->vendor.irq = i;
 +
 +			/* Clear all existing */
 +			iowrite32(ioread32
 +				  (chip->vendor.iobase +
 +				   TPM_INT_STATUS(chip->vendor.locality)),
 +				  chip->vendor.iobase +
 +				  TPM_INT_STATUS(chip->vendor.locality));
 +
 +			/* Turn on */
 +			iowrite32(intmask | TPM_GLOBAL_INT_ENABLE,
 +				  chip->vendor.iobase +
 +				  TPM_INT_ENABLE(chip->vendor.locality));
 +
 +			priv->irq_tested = false;
 +			priv->irq_probing = true;
 +
 +			/* Generate Interrupts */
 +			if (chip->flags & TPM_CHIP_FLAG_TPM2)
 +				tpm2_gen_interrupt(chip);
 +			else
 +				tpm_gen_interrupt(chip);
 +
 +			priv->irq_probing = false;
 +
 +			/* tpm_tis_send will either confirm the interrupt is
 +			 * working or it will call disable_irq which undoes
 +			 * all of the above.
 +			 */
 +			if (chip->vendor.irq)
 +				break;
 +		}
 +		if (!chip->vendor.irq)
 +			iowrite8(irq_r, chip->vendor.iobase +
 +				 TPM_INT_VECTOR(chip->vendor.locality));
 +	}
 +	if (chip->vendor.irq && !priv->irq_tested) {
 +		iowrite8(chip->vendor.irq,
 +			 chip->vendor.iobase +
 +			 TPM_INT_VECTOR(chip->vendor.locality));
 +		if (devm_request_irq
 +		    (dev, chip->vendor.irq, tis_int_handler, IRQF_SHARED,
 +		     chip->devname, chip) != 0) {
 +			dev_info(chip->pdev,
 +				 "Unable to request irq: %d for use\n",
 +				 chip->vendor.irq);
 +			chip->vendor.irq = 0;
 +		} else {
 +			/* Clear all existing */
 +			iowrite32(ioread32
 +				  (chip->vendor.iobase +
 +				   TPM_INT_STATUS(chip->vendor.locality)),
 +				  chip->vendor.iobase +
 +				  TPM_INT_STATUS(chip->vendor.locality));
 +
 +			/* Turn on */
 +			iowrite32(intmask | TPM_GLOBAL_INT_ENABLE,
 +				  chip->vendor.iobase +
 +				  TPM_INT_ENABLE(chip->vendor.locality));
 +		}
 +	}
 +
 +	if (tpm_get_timeouts(chip)) {
 +		dev_err(dev, "Could not get TPM timeouts and durations\n");
 +		rc = -ENODEV;
 +		goto out_err;
++=======
+ 	if (interrupts) {
+ 		if (tpm_info->irq) {
+ 			tpm_tis_probe_irq_single(chip, intmask, IRQF_SHARED,
+ 						 tpm_info->irq);
+ 			if (!chip->vendor.irq)
+ 				dev_err(chip->pdev, FW_BUG
+ 					"TPM interrupt not working, polling instead\n");
+ 		} else
+ 			tpm_tis_probe_irq(chip, intmask);
++>>>>>>> b8ba1e744445 (tpm_tis: Tighten IRQ auto-probing)
  	}
  
  	if (chip->flags & TPM_CHIP_FLAG_TPM2) {
* Unmerged path drivers/char/tpm/tpm_tis.c
