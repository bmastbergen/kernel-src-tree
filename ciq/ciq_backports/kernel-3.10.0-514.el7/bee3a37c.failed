libceph: reschedule tick in mon_fault()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ilya Dryomov <idryomov@gmail.com>
commit bee3a37c470e4febcb05556ceafcb70929268edd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bee3a37c.failed

Doing __schedule_delayed() in the hunting branch is pointless, as the
tick will have already been scheduled by then.

What we need to do instead is *reschedule* it in the !hunting branch,
after reopen_session() changes hunt_mult, which affects the delay.
This helps with spacing out connection attempts and avoiding things
like two back-to-back attempts followed by a longer period of waiting
around.

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit bee3a37c470e4febcb05556ceafcb70929268edd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ceph/mon_client.c
diff --cc net/ceph/mon_client.c
index 4a66c44fabbd,a2b45cf79dca..000000000000
--- a/net/ceph/mon_client.c
+++ b/net/ceph/mon_client.c
@@@ -170,18 -214,27 +170,26 @@@ static bool __sub_expired(struct ceph_m
   */
  static void __schedule_delayed(struct ceph_mon_client *monc)
  {
 -	unsigned long delay;
 +	unsigned int delay;
  
 -	if (monc->hunting)
 -		delay = CEPH_MONC_HUNT_INTERVAL * monc->hunt_mult;
 +	if (monc->cur_mon < 0 || __sub_expired(monc))
 +		delay = 10 * HZ;
  	else
++<<<<<<< HEAD
 +		delay = 20 * HZ;
 +	dout("__schedule_delayed after %u\n", delay);
 +	schedule_delayed_work(&monc->delayed_work, delay);
++=======
+ 		delay = CEPH_MONC_PING_INTERVAL;
+ 
+ 	dout("__schedule_delayed after %lu\n", delay);
+ 	mod_delayed_work(system_wq, &monc->delayed_work,
+ 			 round_jiffies_relative(delay));
++>>>>>>> bee3a37c470e (libceph: reschedule tick in mon_fault())
  }
  
 -const char *ceph_sub_str[] = {
 -	[CEPH_SUB_MDSMAP] = "mdsmap",
 -	[CEPH_SUB_MONMAP] = "monmap",
 -	[CEPH_SUB_OSDMAP] = "osdmap",
 -};
 -
  /*
 - * Send subscribe request for one or more maps, according to
 - * monc->subs.
 + * Send subscribe request for mdsmap and/or osdmap.
   */
  static void __send_subscribe(struct ceph_mon_client *monc)
  {
@@@ -1039,19 -1163,12 +1047,26 @@@ static void mon_fault(struct ceph_conne
  	if (!con->private)
  		goto out;
  
 +	if (!monc->hunting)
 +		pr_info("mon%d %s session lost, "
 +			"hunting for new mon\n", monc->cur_mon,
 +			ceph_pr_addr(&monc->con.peer_addr.in_addr));
 +
 +	__close_session(monc);
  	if (!monc->hunting) {
++<<<<<<< HEAD
 +		/* start hunting */
 +		monc->hunting = true;
 +		__open_session(monc);
 +	} else {
 +		/* already hunting, let's wait a bit */
++=======
+ 		dout("%s hunting for new mon\n", __func__);
+ 		reopen_session(monc);
++>>>>>>> bee3a37c470e (libceph: reschedule tick in mon_fault())
  		__schedule_delayed(monc);
+ 	} else {
+ 		dout("%s already hunting\n", __func__);
  	}
  out:
  	mutex_unlock(&monc->mutex);
* Unmerged path net/ceph/mon_client.c
