mmc: add support for HS400 mode of eMMC5.0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Seungwon Jeon <tgih.jun@samsung.com>
commit 0a5b6438ee482696360bb013e67b8488f63d3e9e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0a5b6438.failed

This patch adds HS400 mode support for eMMC5.0 device.  HS400 mode is high
speed DDR interface timing from HS200.  Clock frequency is up to 200MHz
and only 8-bit bus width is supported. In addition, tuning process of
HS200 is required to synchronize the command response on the CMD line
because CMD input timing for HS400 mode is the same as HS200 mode.

	Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
	Reviewed-by: Jackey Shen <jackey.shen@amd.com>
	Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
	Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Chris Ball <chris@printf.net>
(cherry picked from commit 0a5b6438ee482696360bb013e67b8488f63d3e9e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/bus.c
#	drivers/mmc/core/mmc.c
#	include/linux/mmc/host.h
#	include/linux/mmc/mmc.h
diff --cc drivers/mmc/core/bus.c
index 04c193153bfd,d2dbf02022bd..000000000000
--- a/drivers/mmc/core/bus.c
+++ b/drivers/mmc/core/bus.c
@@@ -346,9 -348,10 +346,14 @@@ int mmc_add_card(struct mmc_card *card
  		pr_info("%s: new %s%s%s%s%s card at address %04x\n",
  			mmc_hostname(card->host),
  			mmc_card_uhs(card) ? "ultra high speed " :
++<<<<<<< HEAD
 +			(mmc_card_highspeed(card) ? "high speed " : ""),
++=======
+ 			(mmc_card_hs(card) ? "high speed " : ""),
+ 			mmc_card_hs400(card) ? "HS400 " :
++>>>>>>> 0a5b6438ee48 (mmc: add support for HS400 mode of eMMC5.0)
  			(mmc_card_hs200(card) ? "HS200 " : ""),
 -			mmc_card_ddr52(card) ? "DDR " : "",
 +			mmc_card_ddr_mode(card) ? "DDR " : "",
  			uhs_bus_speed_mode, type, card->rca);
  	}
  
diff --cc drivers/mmc/core/mmc.c
index 10980284f769,793c6f7ddb04..000000000000
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@@ -240,31 -240,62 +240,43 @@@ static int mmc_get_ext_csd(struct mmc_c
  static void mmc_select_card_type(struct mmc_card *card)
  {
  	struct mmc_host *host = card->host;
- 	u8 card_type = card->ext_csd.raw_card_type & EXT_CSD_CARD_TYPE_MASK;
+ 	u8 card_type = card->ext_csd.raw_card_type;
  	u32 caps = host->caps, caps2 = host->caps2;
 -	unsigned int hs_max_dtr = 0, hs200_max_dtr = 0;
 -	unsigned int avail_type = 0;
 +	unsigned int hs_max_dtr = 0;
  
 -	if (caps & MMC_CAP_MMC_HIGHSPEED &&
 -	    card_type & EXT_CSD_CARD_TYPE_HS_26) {
 +	if (card_type & EXT_CSD_CARD_TYPE_26)
  		hs_max_dtr = MMC_HIGH_26_MAX_DTR;
 -		avail_type |= EXT_CSD_CARD_TYPE_HS_26;
 -	}
  
  	if (caps & MMC_CAP_MMC_HIGHSPEED &&
 -	    card_type & EXT_CSD_CARD_TYPE_HS_52) {
 +			card_type & EXT_CSD_CARD_TYPE_52)
  		hs_max_dtr = MMC_HIGH_52_MAX_DTR;
 -		avail_type |= EXT_CSD_CARD_TYPE_HS_52;
 -	}
  
 -	if (caps & MMC_CAP_1_8V_DDR &&
 -	    card_type & EXT_CSD_CARD_TYPE_DDR_1_8V) {
 +	if ((caps & MMC_CAP_1_8V_DDR &&
 +			card_type & EXT_CSD_CARD_TYPE_DDR_1_8V) ||
 +	    (caps & MMC_CAP_1_2V_DDR &&
 +			card_type & EXT_CSD_CARD_TYPE_DDR_1_2V))
  		hs_max_dtr = MMC_HIGH_DDR_MAX_DTR;
 -		avail_type |= EXT_CSD_CARD_TYPE_DDR_1_8V;
 -	}
  
 -	if (caps & MMC_CAP_1_2V_DDR &&
 -	    card_type & EXT_CSD_CARD_TYPE_DDR_1_2V) {
 -		hs_max_dtr = MMC_HIGH_DDR_MAX_DTR;
 -		avail_type |= EXT_CSD_CARD_TYPE_DDR_1_2V;
 -	}
 -
 -	if (caps2 & MMC_CAP2_HS200_1_8V_SDR &&
 -	    card_type & EXT_CSD_CARD_TYPE_HS200_1_8V) {
 -		hs200_max_dtr = MMC_HS200_MAX_DTR;
 -		avail_type |= EXT_CSD_CARD_TYPE_HS200_1_8V;
 -	}
 -
 -	if (caps2 & MMC_CAP2_HS200_1_2V_SDR &&
 -	    card_type & EXT_CSD_CARD_TYPE_HS200_1_2V) {
 -		hs200_max_dtr = MMC_HS200_MAX_DTR;
 -		avail_type |= EXT_CSD_CARD_TYPE_HS200_1_2V;
 -	}
 +	if ((caps2 & MMC_CAP2_HS200_1_8V_SDR &&
 +			card_type & EXT_CSD_CARD_TYPE_SDR_1_8V) ||
 +	    (caps2 & MMC_CAP2_HS200_1_2V_SDR &&
 +			card_type & EXT_CSD_CARD_TYPE_SDR_1_2V))
 +		hs_max_dtr = MMC_HS200_MAX_DTR;
  
+ 	if (caps2 & MMC_CAP2_HS400_1_8V &&
+ 	    card_type & EXT_CSD_CARD_TYPE_HS400_1_8V) {
+ 		hs200_max_dtr = MMC_HS200_MAX_DTR;
+ 		avail_type |= EXT_CSD_CARD_TYPE_HS400_1_8V;
+ 	}
+ 
+ 	if (caps2 & MMC_CAP2_HS400_1_2V &&
+ 	    card_type & EXT_CSD_CARD_TYPE_HS400_1_2V) {
+ 		hs200_max_dtr = MMC_HS200_MAX_DTR;
+ 		avail_type |= EXT_CSD_CARD_TYPE_HS400_1_2V;
+ 	}
+ 
  	card->ext_csd.hs_max_dtr = hs_max_dtr;
 -	card->ext_csd.hs200_max_dtr = hs200_max_dtr;
 -	card->mmc_avail_type = avail_type;
 +	card->ext_csd.card_type = card_type;
  }
  
  /*
@@@ -807,39 -845,47 +826,63 @@@ static int mmc_select_powerclass(struc
  }
  
  /*
 - * Set the bus speed for the selected speed mode.
 + * Selects the desired buswidth and switch to the HS200 mode
 + * if bus width set without error
   */
++<<<<<<< HEAD
 +static int mmc_select_hs200(struct mmc_card *card)
++=======
+ static void mmc_set_bus_speed(struct mmc_card *card)
+ {
+ 	unsigned int max_dtr = (unsigned int)-1;
+ 
+ 	if ((mmc_card_hs200(card) || mmc_card_hs400(card)) &&
+ 	     max_dtr > card->ext_csd.hs200_max_dtr)
+ 		max_dtr = card->ext_csd.hs200_max_dtr;
+ 	else if (mmc_card_hs(card) && max_dtr > card->ext_csd.hs_max_dtr)
+ 		max_dtr = card->ext_csd.hs_max_dtr;
+ 	else if (max_dtr > card->csd.max_dtr)
+ 		max_dtr = card->csd.max_dtr;
+ 
+ 	mmc_set_clock(card->host, max_dtr);
+ }
+ 
+ /*
+  * Select the bus width amoung 4-bit and 8-bit(SDR).
+  * If the bus width is changed successfully, return the selected width value.
+  * Zero is returned instead of error value if the wide width is not supported.
+  */
+ static int mmc_select_bus_width(struct mmc_card *card)
++>>>>>>> 0a5b6438ee48 (mmc: add support for HS400 mode of eMMC5.0)
  {
 +	int idx, err = -EINVAL;
 +	struct mmc_host *host;
  	static unsigned ext_csd_bits[] = {
 -		EXT_CSD_BUS_WIDTH_8,
  		EXT_CSD_BUS_WIDTH_4,
 +		EXT_CSD_BUS_WIDTH_8,
  	};
  	static unsigned bus_widths[] = {
 -		MMC_BUS_WIDTH_8,
  		MMC_BUS_WIDTH_4,
 +		MMC_BUS_WIDTH_8,
  	};
 -	struct mmc_host *host = card->host;
 -	unsigned idx, bus_width = 0;
 -	int err = 0;
  
 -	if ((card->csd.mmca_vsn < CSD_SPEC_VER_4) &&
 -	    !(host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA)))
 -		return 0;
 +	BUG_ON(!card);
 +
 +	host = card->host;
  
 -	idx = (host->caps & MMC_CAP_8_BIT_DATA) ? 0 : 1;
 +	if (card->ext_csd.card_type & EXT_CSD_CARD_TYPE_SDR_1_2V &&
 +			host->caps2 & MMC_CAP2_HS200_1_2V_SDR)
 +		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);
 +
 +	if (err && card->ext_csd.card_type & EXT_CSD_CARD_TYPE_SDR_1_8V &&
 +			host->caps2 & MMC_CAP2_HS200_1_8V_SDR)
 +		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
 +
 +	/* If fails try again during next card power cycle */
 +	if (err)
 +		goto err;
 +
 +	idx = (host->caps & MMC_CAP_8_BIT_DATA) ? 1 : 0;
  
  	/*
  	 * Unlike SD, MMC cards dont have a configuration register to notify
@@@ -863,27 -908,266 +906,274 @@@
  		if (err)
  			continue;
  
 -		bus_width = bus_widths[idx];
 -		mmc_set_bus_width(host, bus_width);
 +		mmc_set_bus_width(card->host, bus_widths[idx]);
  
 -		/*
 -		 * If controller can't handle bus width test,
 -		 * compare ext_csd previously read in 1 bit mode
 -		 * against ext_csd at new bus width
 -		 */
  		if (!(host->caps & MMC_CAP_BUS_WIDTH_TEST))
 -			err = mmc_compare_ext_csds(card, bus_width);
 +			err = mmc_compare_ext_csds(card, bus_widths[idx]);
  		else
++<<<<<<< HEAD
 +			err = mmc_bus_test(card, bus_widths[idx]);
++=======
+ 			err = mmc_bus_test(card, bus_width);
+ 
+ 		if (!err) {
+ 			err = bus_width;
+ 			break;
+ 		} else {
+ 			pr_warn("%s: switch to bus width %d failed\n",
+ 				mmc_hostname(host), ext_csd_bits[idx]);
+ 		}
+ 	}
+ 
+ 	return err;
+ }
+ 
+ /*
+  * Switch to the high-speed mode
+  */
+ static int mmc_select_hs(struct mmc_card *card)
+ {
+ 	int err;
+ 
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS,
+ 			   card->ext_csd.generic_cmd6_time,
+ 			   true, true, true);
+ 	if (!err)
+ 		mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
+ 
+ 	return err;
+ }
+ 
+ /*
+  * Activate wide bus and DDR if supported.
+  */
+ static int mmc_select_hs_ddr(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	u32 bus_width, ext_csd_bits;
+ 	int err = 0;
+ 
+ 	if (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_52))
+ 		return 0;
+ 
+ 	bus_width = host->ios.bus_width;
+ 	if (bus_width == MMC_BUS_WIDTH_1)
+ 		return 0;
+ 
+ 	ext_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?
+ 		EXT_CSD_DDR_BUS_WIDTH_8 : EXT_CSD_DDR_BUS_WIDTH_4;
+ 
+ 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			EXT_CSD_BUS_WIDTH,
+ 			ext_csd_bits,
+ 			card->ext_csd.generic_cmd6_time);
+ 	if (err) {
+ 		pr_warn("%s: switch to bus width %d ddr failed\n",
+ 			mmc_hostname(host), 1 << bus_width);
+ 		return err;
+ 	}
+ 
+ 	/*
+ 	 * eMMC cards can support 3.3V to 1.2V i/o (vccq)
+ 	 * signaling.
+ 	 *
+ 	 * EXT_CSD_CARD_TYPE_DDR_1_8V means 3.3V or 1.8V vccq.
+ 	 *
+ 	 * 1.8V vccq at 3.3V core voltage (vcc) is not required
+ 	 * in the JEDEC spec for DDR.
+ 	 *
+ 	 * Do not force change in vccq since we are obviously
+ 	 * working and no change to vccq is needed.
+ 	 *
+ 	 * WARNING: eMMC rules are NOT the same as SD DDR
+ 	 */
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_1_2V) {
+ 		err = __mmc_set_signal_voltage(host,
+ 				MMC_SIGNAL_VOLTAGE_120);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	mmc_set_timing(host, MMC_TIMING_MMC_DDR52);
+ 
+ 	return err;
+ }
+ 
+ static int mmc_select_hs400(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	int err = 0;
+ 
+ 	/*
+ 	 * HS400 mode requires 8-bit bus width
+ 	 */
+ 	if (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400 &&
+ 	      host->ios.bus_width == MMC_BUS_WIDTH_8))
+ 		return 0;
+ 
+ 	/*
+ 	 * Before switching to dual data rate operation for HS400,
+ 	 * it is required to convert from HS200 mode to HS mode.
+ 	 */
+ 	mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
+ 	mmc_set_bus_speed(card);
+ 
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS,
+ 			   card->ext_csd.generic_cmd6_time,
+ 			   true, true, true);
+ 	if (err) {
+ 		pr_warn("%s: switch to high-speed from hs200 failed, err:%d\n",
+ 			mmc_hostname(host), err);
+ 		return err;
+ 	}
+ 
+ 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			 EXT_CSD_BUS_WIDTH,
+ 			 EXT_CSD_DDR_BUS_WIDTH_8,
+ 			 card->ext_csd.generic_cmd6_time);
+ 	if (err) {
+ 		pr_warn("%s: switch to bus width for hs400 failed, err:%d\n",
+ 			mmc_hostname(host), err);
+ 		return err;
+ 	}
+ 
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS400,
+ 			   card->ext_csd.generic_cmd6_time,
+ 			   true, true, true);
+ 	if (err) {
+ 		pr_warn("%s: switch to hs400 failed, err:%d\n",
+ 			 mmc_hostname(host), err);
+ 		return err;
+ 	}
+ 
+ 	mmc_set_timing(host, MMC_TIMING_MMC_HS400);
+ 	mmc_set_bus_speed(card);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * For device supporting HS200 mode, the following sequence
+  * should be done before executing the tuning process.
+  * 1. set the desired bus width(4-bit or 8-bit, 1-bit is not supported)
+  * 2. switch to HS200 mode
+  * 3. set the clock to > 52Mhz and <=200MHz
+  */
+ static int mmc_select_hs200(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	int err = -EINVAL;
+ 
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_2V)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);
+ 
+ 	if (err && card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_8V)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
+ 
+ 	/* If fails try again during next card power cycle */
+ 	if (err)
+ 		goto err;
+ 
+ 	/*
+ 	 * Set the bus width(4 or 8) with host's support and
+ 	 * switch to HS200 mode if bus width is set successfully.
+ 	 */
+ 	err = mmc_select_bus_width(card);
+ 	if (!IS_ERR_VALUE(err)) {
+ 		err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 				   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS200,
+ 				   card->ext_csd.generic_cmd6_time,
+ 				   true, true, true);
++>>>>>>> 0a5b6438ee48 (mmc: add support for HS400 mode of eMMC5.0)
  		if (!err)
 -			mmc_set_timing(host, MMC_TIMING_MMC_HS200);
 +			break;
  	}
 +
 +	/* switch to HS200 mode if bus width set successfully */
 +	if (!err)
 +		err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 +				EXT_CSD_HS_TIMING, 2,
 +				card->ext_csd.generic_cmd6_time,
 +				true, true, true);
  err:
  	return err;
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Activate High Speed or HS200 mode if supported.
+  */
+ static int mmc_select_timing(struct mmc_card *card)
+ {
+ 	int err = 0;
+ 
+ 	if ((card->csd.mmca_vsn < CSD_SPEC_VER_4 &&
+ 	     card->ext_csd.hs_max_dtr == 0))
+ 		goto bus_speed;
+ 
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200)
+ 		err = mmc_select_hs200(card);
+ 	else if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS)
+ 		err = mmc_select_hs(card);
+ 
+ 	if (err && err != -EBADMSG)
+ 		return err;
+ 
+ 	if (err) {
+ 		pr_warn("%s: switch to %s failed\n",
+ 			mmc_card_hs(card) ? "high-speed" :
+ 			(mmc_card_hs200(card) ? "hs200" : ""),
+ 			mmc_hostname(card->host));
+ 		err = 0;
+ 	}
+ 
+ bus_speed:
+ 	/*
+ 	 * Set the bus speed to the selected bus timing.
+ 	 * If timing is not selected, backward compatible is the default.
+ 	 */
+ 	mmc_set_bus_speed(card);
+ 	return err;
+ }
+ 
+ /*
+  * Execute tuning sequence to seek the proper bus operating
+  * conditions for HS200 and HS400, which sends CMD21 to the device.
+  */
+ static int mmc_hs200_tuning(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	int err = 0;
+ 
+ 	/*
+ 	 * Timing should be adjusted to the HS400 target
+ 	 * operation frequency for tuning process
+ 	 */
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400 &&
+ 	    host->ios.bus_width == MMC_BUS_WIDTH_8)
+ 		if (host->ops->prepare_hs400_tuning)
+ 			host->ops->prepare_hs400_tuning(host, &host->ios);
+ 
+ 	if (host->ops->execute_tuning) {
+ 		mmc_host_clk_hold(host);
+ 		err = host->ops->execute_tuning(host,
+ 				MMC_SEND_TUNING_BLOCK_HS200);
+ 		mmc_host_clk_release(host);
+ 
+ 		if (err)
+ 			pr_warn("%s: tuning execution failed\n",
+ 				mmc_hostname(host));
+ 	}
+ 
+ 	return err;
+ }
+ 
+ /*
++>>>>>>> 0a5b6438ee48 (mmc: add support for HS400 mode of eMMC5.0)
   * Handle the detection and initialisation of a card.
   *
   * In the case of a resume, "oldcard" will contain the card
@@@ -1087,186 -1370,27 +1377,200 @@@ static int mmc_init_card(struct mmc_hos
  	}
  
  	/*
 -	 * Select timing interface
 +	 * Activate high speed (if supported)
  	 */
 -	err = mmc_select_timing(card);
 -	if (err)
 -		goto free_card;
 +	if (card->ext_csd.hs_max_dtr != 0) {
 +		err = 0;
 +		if (card->ext_csd.hs_max_dtr > 52000000 &&
 +		    host->caps2 & MMC_CAP2_HS200)
 +			err = mmc_select_hs200(card);
 +		else if	(host->caps & MMC_CAP_MMC_HIGHSPEED)
 +			err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 +					EXT_CSD_HS_TIMING, 1,
 +					card->ext_csd.generic_cmd6_time,
 +					true, true, true);
  
 +		if (err && err != -EBADMSG)
 +			goto free_card;
 +
 +		if (err) {
 +			pr_warning("%s: switch to highspeed failed\n",
 +			       mmc_hostname(card->host));
 +			err = 0;
 +		} else {
 +			if (card->ext_csd.hs_max_dtr > 52000000 &&
 +			    host->caps2 & MMC_CAP2_HS200) {
 +				mmc_card_set_hs200(card);
 +				mmc_set_timing(card->host,
 +					       MMC_TIMING_MMC_HS200);
 +			} else {
 +				mmc_card_set_highspeed(card);
 +				mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
 +			}
 +		}
 +	}
 +
 +	/*
 +	 * Compute bus speed.
 +	 */
 +	max_dtr = (unsigned int)-1;
 +
 +	if (mmc_card_highspeed(card) || mmc_card_hs200(card)) {
 +		if (max_dtr > card->ext_csd.hs_max_dtr)
 +			max_dtr = card->ext_csd.hs_max_dtr;
 +		if (mmc_card_highspeed(card) && (max_dtr > 52000000))
 +			max_dtr = 52000000;
 +	} else if (max_dtr > card->csd.max_dtr) {
 +		max_dtr = card->csd.max_dtr;
 +	}
 +
 +	mmc_set_clock(host, max_dtr);
 +
 +	/*
 +	 * Indicate DDR mode (if supported).
 +	 */
 +	if (mmc_card_highspeed(card)) {
 +		if ((card->ext_csd.card_type & EXT_CSD_CARD_TYPE_DDR_1_8V)
 +			&& (host->caps & MMC_CAP_1_8V_DDR))
 +				ddr = MMC_1_8V_DDR_MODE;
 +		else if ((card->ext_csd.card_type & EXT_CSD_CARD_TYPE_DDR_1_2V)
 +			&& (host->caps & MMC_CAP_1_2V_DDR))
 +				ddr = MMC_1_2V_DDR_MODE;
 +	}
 +
 +	/*
 +	 * Indicate HS200 SDR mode (if supported).
 +	 */
  	if (mmc_card_hs200(card)) {
 -		err = mmc_hs200_tuning(card);
 -		if (err)
 +		u32 ext_csd_bits;
 +		u32 bus_width = card->host->ios.bus_width;
 +
 +		/*
 +		 * For devices supporting HS200 mode, the bus width has
 +		 * to be set before executing the tuning function. If
 +		 * set before tuning, then device will respond with CRC
 +		 * errors for responses on CMD line. So for HS200 the
 +		 * sequence will be
 +		 * 1. set bus width 4bit / 8 bit (1 bit not supported)
 +		 * 2. switch to HS200 mode
 +		 * 3. set the clock to > 52Mhz <=200MHz and
 +		 * 4. execute tuning for HS200
 +		 */
 +		if ((host->caps2 & MMC_CAP2_HS200) &&
 +		    card->host->ops->execute_tuning) {
 +			mmc_host_clk_hold(card->host);
 +			err = card->host->ops->execute_tuning(card->host,
 +				MMC_SEND_TUNING_BLOCK_HS200);
 +			mmc_host_clk_release(card->host);
 +		}
 +		if (err) {
 +			pr_warning("%s: tuning execution failed\n",
 +				   mmc_hostname(card->host));
  			goto err;
++<<<<<<< HEAD
 +		}
 +
 +		ext_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?
 +				EXT_CSD_BUS_WIDTH_8 : EXT_CSD_BUS_WIDTH_4;
 +	}
 +
 +	/*
 +	 * Activate wide bus and DDR (if supported).
 +	 */
 +	if (!mmc_card_hs200(card) &&
 +	    (card->csd.mmca_vsn >= CSD_SPEC_VER_4) &&
 +	    (host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA))) {
 +		static unsigned ext_csd_bits[][2] = {
 +			{ EXT_CSD_BUS_WIDTH_8, EXT_CSD_DDR_BUS_WIDTH_8 },
 +			{ EXT_CSD_BUS_WIDTH_4, EXT_CSD_DDR_BUS_WIDTH_4 },
 +			{ EXT_CSD_BUS_WIDTH_1, EXT_CSD_BUS_WIDTH_1 },
 +		};
 +		static unsigned bus_widths[] = {
 +			MMC_BUS_WIDTH_8,
 +			MMC_BUS_WIDTH_4,
 +			MMC_BUS_WIDTH_1
 +		};
 +		unsigned idx, bus_width = 0;
 +
 +		if (host->caps & MMC_CAP_8_BIT_DATA)
 +			idx = 0;
 +		else
 +			idx = 1;
 +		for (; idx < ARRAY_SIZE(bus_widths); idx++) {
 +			bus_width = bus_widths[idx];
 +			if (bus_width == MMC_BUS_WIDTH_1)
 +				ddr = 0; /* no DDR for 1-bit width */
 +
 +			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 +					 EXT_CSD_BUS_WIDTH,
 +					 ext_csd_bits[idx][0],
 +					 card->ext_csd.generic_cmd6_time);
 +			if (!err) {
 +				mmc_set_bus_width(card->host, bus_width);
 +
 +				/*
 +				 * If controller can't handle bus width test,
 +				 * compare ext_csd previously read in 1 bit mode
 +				 * against ext_csd at new bus width
 +				 */
 +				if (!(host->caps & MMC_CAP_BUS_WIDTH_TEST))
 +					err = mmc_compare_ext_csds(card,
 +						bus_width);
 +				else
 +					err = mmc_bus_test(card, bus_width);
 +				if (!err)
 +					break;
 +			}
 +		}
 +
 +		if (!err && ddr) {
 +			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 +					 EXT_CSD_BUS_WIDTH,
 +					 ext_csd_bits[idx][1],
 +					 card->ext_csd.generic_cmd6_time);
 +		}
 +		if (err) {
 +			pr_warning("%s: switch to bus width %d ddr %d "
 +				"failed\n", mmc_hostname(card->host),
 +				1 << bus_width, ddr);
 +			goto free_card;
 +		} else if (ddr) {
 +			/*
 +			 * eMMC cards can support 3.3V to 1.2V i/o (vccq)
 +			 * signaling.
 +			 *
 +			 * EXT_CSD_CARD_TYPE_DDR_1_8V means 3.3V or 1.8V vccq.
 +			 *
 +			 * 1.8V vccq at 3.3V core voltage (vcc) is not required
 +			 * in the JEDEC spec for DDR.
 +			 *
 +			 * Do not force change in vccq since we are obviously
 +			 * working and no change to vccq is needed.
 +			 *
 +			 * WARNING: eMMC rules are NOT the same as SD DDR
 +			 */
 +			if (ddr == MMC_1_2V_DDR_MODE) {
 +				err = __mmc_set_signal_voltage(host,
 +					MMC_SIGNAL_VOLTAGE_120);
 +				if (err)
 +					goto err;
 +			}
 +			mmc_card_set_ddr_mode(card);
 +			mmc_set_timing(card->host, MMC_TIMING_MMC_DDR52);
 +			mmc_set_bus_width(card->host, bus_width);
++=======
+ 
+ 		err = mmc_select_hs400(card);
+ 		if (err)
+ 			goto err;
+ 	} else if (mmc_card_hs(card)) {
+ 		/* Select the desired bus width optionally */
+ 		err = mmc_select_bus_width(card);
+ 		if (!IS_ERR_VALUE(err)) {
+ 			err = mmc_select_hs_ddr(card);
+ 			if (err)
+ 				goto err;
++>>>>>>> 0a5b6438ee48 (mmc: add support for HS400 mode of eMMC5.0)
  		}
  	}
  
diff --cc include/linux/mmc/host.h
index 0cf705c83998,183087374215..000000000000
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@@ -60,13 -61,8 +60,14 @@@ struct mmc_ios 
  #define MMC_TIMING_UHS_DDR50	7
  #define MMC_TIMING_MMC_DDR52	8
  #define MMC_TIMING_MMC_HS200	9
+ #define MMC_TIMING_MMC_HS400	10
  
 +#define MMC_SDR_MODE		0
 +#define MMC_1_2V_DDR_MODE	1
 +#define MMC_1_8V_DDR_MODE	2
 +#define MMC_1_2V_SDR_MODE	3
 +#define MMC_1_8V_SDR_MODE	4
 +
  	unsigned char	signal_voltage;		/* signalling voltage (1.8V or 3.3V) */
  
  #define MMC_SIGNAL_VOLTAGE_330	0
@@@ -478,4 -481,32 +486,35 @@@ static inline unsigned int mmc_host_clk
  	return host->ios.clock;
  }
  #endif
++<<<<<<< HEAD
++=======
+ 
+ static inline int mmc_card_hs(struct mmc_card *card)
+ {
+ 	return card->host->ios.timing == MMC_TIMING_SD_HS ||
+ 		card->host->ios.timing == MMC_TIMING_MMC_HS;
+ }
+ 
+ static inline int mmc_card_uhs(struct mmc_card *card)
+ {
+ 	return card->host->ios.timing >= MMC_TIMING_UHS_SDR12 &&
+ 		card->host->ios.timing <= MMC_TIMING_UHS_DDR50;
+ }
+ 
+ static inline bool mmc_card_hs200(struct mmc_card *card)
+ {
+ 	return card->host->ios.timing == MMC_TIMING_MMC_HS200;
+ }
+ 
+ static inline bool mmc_card_ddr52(struct mmc_card *card)
+ {
+ 	return card->host->ios.timing == MMC_TIMING_MMC_DDR52;
+ }
+ 
+ static inline bool mmc_card_hs400(struct mmc_card *card)
+ {
+ 	return card->host->ios.timing == MMC_TIMING_MMC_HS400;
+ }
+ 
++>>>>>>> 0a5b6438ee48 (mmc: add support for HS400 mode of eMMC5.0)
  #endif /* LINUX_MMC_HOST_H */
diff --cc include/linux/mmc/mmc.h
index 50bcde3677ca,64ec963ed347..000000000000
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@@ -354,18 -355,25 +355,34 @@@ struct _mmc_csd 
  #define EXT_CSD_CMD_SET_SECURE		(1<<1)
  #define EXT_CSD_CMD_SET_CPSECURE	(1<<2)
  
++<<<<<<< HEAD
 +#define EXT_CSD_CARD_TYPE_26	(1<<0)	/* Card can run at 26MHz */
 +#define EXT_CSD_CARD_TYPE_52	(1<<1)	/* Card can run at 52MHz */
 +#define EXT_CSD_CARD_TYPE_MASK	0x3F	/* Mask out reserved bits */
++=======
+ #define EXT_CSD_CARD_TYPE_HS_26	(1<<0)	/* Card can run at 26MHz */
+ #define EXT_CSD_CARD_TYPE_HS_52	(1<<1)	/* Card can run at 52MHz */
+ #define EXT_CSD_CARD_TYPE_HS	(EXT_CSD_CARD_TYPE_HS_26 | \
+ 				 EXT_CSD_CARD_TYPE_HS_52)
++>>>>>>> 0a5b6438ee48 (mmc: add support for HS400 mode of eMMC5.0)
  #define EXT_CSD_CARD_TYPE_DDR_1_8V  (1<<2)   /* Card can run at 52MHz */
  					     /* DDR mode @1.8V or 3V I/O */
  #define EXT_CSD_CARD_TYPE_DDR_1_2V  (1<<3)   /* Card can run at 52MHz */
  					     /* DDR mode @1.2V I/O */
  #define EXT_CSD_CARD_TYPE_DDR_52       (EXT_CSD_CARD_TYPE_DDR_1_8V  \
  					| EXT_CSD_CARD_TYPE_DDR_1_2V)
 -#define EXT_CSD_CARD_TYPE_HS200_1_8V	(1<<4)	/* Card can run at 200MHz */
 -#define EXT_CSD_CARD_TYPE_HS200_1_2V	(1<<5)	/* Card can run at 200MHz */
 +#define EXT_CSD_CARD_TYPE_SDR_1_8V	(1<<4)	/* Card can run at 200MHz */
 +#define EXT_CSD_CARD_TYPE_SDR_1_2V	(1<<5)	/* Card can run at 200MHz */
  						/* SDR mode @1.2V I/O */
++<<<<<<< HEAD
++=======
+ #define EXT_CSD_CARD_TYPE_HS200		(EXT_CSD_CARD_TYPE_HS200_1_8V | \
+ 					 EXT_CSD_CARD_TYPE_HS200_1_2V)
+ #define EXT_CSD_CARD_TYPE_HS400_1_8V	(1<<6)	/* Card can run at 200MHz DDR, 1.8V */
+ #define EXT_CSD_CARD_TYPE_HS400_1_2V	(1<<7)	/* Card can run at 200MHz DDR, 1.2V */
+ #define EXT_CSD_CARD_TYPE_HS400		(EXT_CSD_CARD_TYPE_HS400_1_8V | \
+ 					 EXT_CSD_CARD_TYPE_HS400_1_2V)
++>>>>>>> 0a5b6438ee48 (mmc: add support for HS400 mode of eMMC5.0)
  
  #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
  #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
@@@ -373,6 -381,11 +390,14 @@@
  #define EXT_CSD_DDR_BUS_WIDTH_4	5	/* Card is in 4 bit DDR mode */
  #define EXT_CSD_DDR_BUS_WIDTH_8	6	/* Card is in 8 bit DDR mode */
  
++<<<<<<< HEAD
++=======
+ #define EXT_CSD_TIMING_BC	0	/* Backwards compatility */
+ #define EXT_CSD_TIMING_HS	1	/* High speed */
+ #define EXT_CSD_TIMING_HS200	2	/* HS200 */
+ #define EXT_CSD_TIMING_HS400	3	/* HS400 */
+ 
++>>>>>>> 0a5b6438ee48 (mmc: add support for HS400 mode of eMMC5.0)
  #define EXT_CSD_SEC_ER_EN	BIT(0)
  #define EXT_CSD_SEC_BD_BLK_EN	BIT(2)
  #define EXT_CSD_SEC_GB_CL_EN	BIT(4)
* Unmerged path drivers/mmc/core/bus.c
diff --git a/drivers/mmc/core/debugfs.c b/drivers/mmc/core/debugfs.c
index 509229b48b55..079990a9e668 100644
--- a/drivers/mmc/core/debugfs.c
+++ b/drivers/mmc/core/debugfs.c
@@ -141,6 +141,9 @@ static int mmc_ios_show(struct seq_file *s, void *data)
 	case MMC_TIMING_MMC_HS200:
 		str = "mmc high-speed SDR200";
 		break;
+	case MMC_TIMING_MMC_HS400:
+		str = "mmc HS400";
+		break;
 	default:
 		str = "invalid";
 		break;
* Unmerged path drivers/mmc/core/mmc.c
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index aa7e57f60fb2..eb01a336fe2d 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -110,6 +110,7 @@ struct mmc_ext_csd {
 	u8			raw_pwr_cl_200_360;	/* 237 */
 	u8			raw_pwr_cl_ddr_52_195;	/* 238 */
 	u8			raw_pwr_cl_ddr_52_360;	/* 239 */
+	u8			raw_pwr_cl_ddr_200_360;	/* 253 */
 	u8			raw_bkops_status;	/* 246 */
 	u8			raw_sectors[4];		/* 212 - 4 bytes */
 
* Unmerged path include/linux/mmc/host.h
* Unmerged path include/linux/mmc/mmc.h
