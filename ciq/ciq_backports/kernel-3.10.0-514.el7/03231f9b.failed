mmc: sdhci: convert reset into a library function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] sdhci: convert reset into a library function (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 94.62%
commit-author Russell King <rmk+kernel@arm.linux.org.uk>
commit 03231f9b781f24205c0af0398ce3cbef70090939
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/03231f9b.failed

Rather than having platform_reset_enter/platform_reset_exit methods,
turn the core of the reset handling into a library function which
platforms can call at the appropriate moment in their (new) reset
method.

	Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
	Tested-by: Markus Pargmann <mpa@pengutronix.de>
	Tested-by: Stephen Warren <swarren@nvidia.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Chris Ball <chris@printf.net>
(cherry picked from commit 03231f9b781f24205c0af0398ce3cbef70090939)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci-acpi.c
#	drivers/mmc/host/sdhci-bcm-kona.c
#	drivers/mmc/host/sdhci-bcm2835.c
#	drivers/mmc/host/sdhci-cns3xxx.c
#	drivers/mmc/host/sdhci-dove.c
#	drivers/mmc/host/sdhci-esdhc-imx.c
#	drivers/mmc/host/sdhci-of-arasan.c
#	drivers/mmc/host/sdhci-of-esdhc.c
#	drivers/mmc/host/sdhci-of-hlwd.c
#	drivers/mmc/host/sdhci-pci.c
#	drivers/mmc/host/sdhci-pltfm.c
#	drivers/mmc/host/sdhci-pxav2.c
#	drivers/mmc/host/sdhci-pxav3.c
#	drivers/mmc/host/sdhci-s3c.c
#	drivers/mmc/host/sdhci-sirf.c
#	drivers/mmc/host/sdhci-spear.c
#	drivers/mmc/host/sdhci-tegra.c
#	drivers/mmc/host/sdhci.c
#	drivers/mmc/host/sdhci.h
diff --cc drivers/mmc/host/sdhci-acpi.c
index ebb3f392b589,aca84a682551..000000000000
--- a/drivers/mmc/host/sdhci-acpi.c
+++ b/drivers/mmc/host/sdhci-acpi.c
@@@ -103,10 -103,14 +103,20 @@@ static void sdhci_acpi_int_hw_reset(str
  
  static const struct sdhci_ops sdhci_acpi_ops_dflt = {
  	.enable_dma = sdhci_acpi_enable_dma,
++<<<<<<< HEAD
++=======
+ 	.set_bus_width = sdhci_set_bus_width,
+ 	.reset = sdhci_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  };
  
  static const struct sdhci_ops sdhci_acpi_ops_int = {
  	.enable_dma = sdhci_acpi_enable_dma,
++<<<<<<< HEAD
++=======
+ 	.set_bus_width = sdhci_set_bus_width,
+ 	.reset = sdhci_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  	.hw_reset   = sdhci_acpi_int_hw_reset,
  };
  
diff --cc drivers/mmc/host/sdhci-bcm-kona.c
index 87175f9817c2,7b97bfab910d..000000000000
--- a/drivers/mmc/host/sdhci-bcm-kona.c
+++ b/drivers/mmc/host/sdhci-bcm-kona.c
@@@ -209,6 -209,8 +209,11 @@@ static struct sdhci_ops sdhci_bcm_kona_
  	.get_max_clock = sdhci_bcm_kona_get_max_clk,
  	.get_timeout_clock = sdhci_bcm_kona_get_timeout_clock,
  	.platform_send_init_74_clocks = sdhci_bcm_kona_init_74_clocks,
++<<<<<<< HEAD
++=======
+ 	.set_bus_width = sdhci_set_bus_width,
+ 	.reset = sdhci_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  	.card_event = sdhci_bcm_kona_card_event,
  };
  
diff --cc drivers/mmc/host/sdhci-bcm2835.c
index 0584a1c788b8,289b1c80d5fc..000000000000
--- a/drivers/mmc/host/sdhci-bcm2835.c
+++ b/drivers/mmc/host/sdhci-bcm2835.c
@@@ -133,6 -133,8 +133,11 @@@ static const struct sdhci_ops bcm2835_s
  	.read_b = bcm2835_sdhci_readb,
  	.get_max_clock = sdhci_pltfm_clk_get_max_clock,
  	.get_min_clock = bcm2835_sdhci_get_min_clock,
++<<<<<<< HEAD
++=======
+ 	.set_bus_width = sdhci_set_bus_width,
+ 	.reset = sdhci_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  };
  
  static const struct sdhci_pltfm_data bcm2835_sdhci_pdata = {
diff --cc drivers/mmc/host/sdhci-cns3xxx.c
index f2cc26633cb2,87af66bb1ea8..000000000000
--- a/drivers/mmc/host/sdhci-cns3xxx.c
+++ b/drivers/mmc/host/sdhci-cns3xxx.c
@@@ -82,6 -82,8 +82,11 @@@ out
  static const struct sdhci_ops sdhci_cns3xxx_ops = {
  	.get_max_clock	= sdhci_cns3xxx_get_max_clk,
  	.set_clock	= sdhci_cns3xxx_set_clock,
++<<<<<<< HEAD
++=======
+ 	.set_bus_width	= sdhci_set_bus_width,
+ 	.reset          = sdhci_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  };
  
  static const struct sdhci_pltfm_data sdhci_cns3xxx_pdata = {
diff --cc drivers/mmc/host/sdhci-dove.c
index 8424839660f8,1408cc11d881..000000000000
--- a/drivers/mmc/host/sdhci-dove.c
+++ b/drivers/mmc/host/sdhci-dove.c
@@@ -86,6 -86,8 +86,11 @@@ static u32 sdhci_dove_readl(struct sdhc
  static const struct sdhci_ops sdhci_dove_ops = {
  	.read_w	= sdhci_dove_readw,
  	.read_l	= sdhci_dove_readl,
++<<<<<<< HEAD
++=======
+ 	.set_bus_width = sdhci_set_bus_width,
+ 	.reset = sdhci_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  };
  
  static const struct sdhci_pltfm_data sdhci_dove_pdata = {
diff --cc drivers/mmc/host/sdhci-esdhc-imx.c
index 98f46704baa6,b1d74fa33c5f..000000000000
--- a/drivers/mmc/host/sdhci-esdhc-imx.c
+++ b/drivers/mmc/host/sdhci-esdhc-imx.c
@@@ -438,11 -882,13 +438,17 @@@ static const struct sdhci_ops sdhci_esd
  	.write_l = esdhc_writel_le,
  	.write_w = esdhc_writew_le,
  	.write_b = esdhc_writeb_le,
 -	.set_clock = esdhc_pltfm_set_clock,
 -	.get_max_clock = esdhc_pltfm_get_max_clock,
 +	.set_clock = esdhc_set_clock,
 +	.get_max_clock = sdhci_pltfm_clk_get_max_clock,
  	.get_min_clock = esdhc_pltfm_get_min_clock,
  	.get_ro = esdhc_pltfm_get_ro,
++<<<<<<< HEAD
 +	.platform_bus_width = esdhc_pltfm_bus_width,
++=======
+ 	.set_bus_width = esdhc_pltfm_set_bus_width,
+ 	.set_uhs_signaling = esdhc_set_uhs_signaling,
+ 	.reset = sdhci_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  };
  
  static const struct sdhci_pltfm_data sdhci_esdhc_imx_pdata = {
diff --cc drivers/mmc/host/sdhci-of-esdhc.c
index 37e668f5b992,4530f9957f20..000000000000
--- a/drivers/mmc/host/sdhci-of-esdhc.c
+++ b/drivers/mmc/host/sdhci-of-esdhc.c
@@@ -247,6 -308,8 +247,11 @@@ static const struct sdhci_ops sdhci_esd
  	.platform_resume = esdhc_of_resume,
  #endif
  	.adma_workaround = esdhci_of_adma_workaround,
++<<<<<<< HEAD
++=======
+ 	.set_bus_width = esdhc_pltfm_set_bus_width,
+ 	.reset = sdhci_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  };
  
  static const struct sdhci_pltfm_data sdhci_esdhc_pdata = {
diff --cc drivers/mmc/host/sdhci-of-hlwd.c
index 57c514a81ca5,fb01958cb18e..000000000000
--- a/drivers/mmc/host/sdhci-of-hlwd.c
+++ b/drivers/mmc/host/sdhci-of-hlwd.c
@@@ -58,6 -58,8 +58,11 @@@ static const struct sdhci_ops sdhci_hlw
  	.write_l = sdhci_hlwd_writel,
  	.write_w = sdhci_hlwd_writew,
  	.write_b = sdhci_hlwd_writeb,
++<<<<<<< HEAD
++=======
+ 	.set_bus_width = sdhci_set_bus_width,
+ 	.reset = sdhci_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  };
  
  static const struct sdhci_pltfm_data sdhci_hlwd_pdata = {
diff --cc drivers/mmc/host/sdhci-pci.c
index a3024b2fb30e,87f9dd91f68c..000000000000
--- a/drivers/mmc/host/sdhci-pci.c
+++ b/drivers/mmc/host/sdhci-pci.c
@@@ -955,9 -1069,18 +955,14 @@@ static void sdhci_pci_hw_reset(struct s
  	usleep_range(300, 1000);
  }
  
 -static void sdhci_pci_hw_reset(struct sdhci_host *host)
 -{
 -	struct sdhci_pci_slot *slot = sdhci_priv(host);
 -
 -	if (slot->hw_reset)
 -		slot->hw_reset(host);
 -}
 -
  static const struct sdhci_ops sdhci_pci_ops = {
  	.enable_dma	= sdhci_pci_enable_dma,
++<<<<<<< HEAD
 +	.platform_bus_width	= sdhci_pci_bus_width,
++=======
+ 	.set_bus_width	= sdhci_pci_set_bus_width,
+ 	.reset		= sdhci_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  	.hw_reset		= sdhci_pci_hw_reset,
  };
  
diff --cc drivers/mmc/host/sdhci-pltfm.c
index bef250e95418,bfbf467b61c7..000000000000
--- a/drivers/mmc/host/sdhci-pltfm.c
+++ b/drivers/mmc/host/sdhci-pltfm.c
@@@ -45,6 -45,8 +45,11 @@@ unsigned int sdhci_pltfm_clk_get_max_cl
  EXPORT_SYMBOL_GPL(sdhci_pltfm_clk_get_max_clock);
  
  static const struct sdhci_ops sdhci_pltfm_ops = {
++<<<<<<< HEAD
++=======
+ 	.set_bus_width = sdhci_set_bus_width,
+ 	.reset = sdhci_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  };
  
  #ifdef CONFIG_OF
diff --cc drivers/mmc/host/sdhci-pxav2.c
index d51e061ec576,2eee0c8b88eb..000000000000
--- a/drivers/mmc/host/sdhci-pxav2.c
+++ b/drivers/mmc/host/sdhci-pxav2.c
@@@ -113,8 -113,8 +115,13 @@@ static int pxav2_mmc_set_width(struct s
  
  static const struct sdhci_ops pxav2_sdhci_ops = {
  	.get_max_clock = sdhci_pltfm_clk_get_max_clock,
++<<<<<<< HEAD
 +	.platform_reset_exit = pxav2_set_private_registers,
 +	.platform_bus_width = pxav2_mmc_set_width,
++=======
+ 	.set_bus_width = pxav2_mmc_set_bus_width,
+ 	.reset         = pxav2_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  };
  
  #ifdef CONFIG_OF
diff --cc drivers/mmc/host/sdhci-pxav3.c
index 56d9bee93d8f,86564233ae93..000000000000
--- a/drivers/mmc/host/sdhci-pxav3.c
+++ b/drivers/mmc/host/sdhci-pxav3.c
@@@ -57,7 -58,61 +57,65 @@@
  #define SDCE_MISC_INT		(1<<2)
  #define SDCE_MISC_INT_EN	(1<<1)
  
++<<<<<<< HEAD
 +static void pxav3_set_private_registers(struct sdhci_host *host, u8 mask)
++=======
+ /*
+  * These registers are relative to the second register region, for the
+  * MBus bridge.
+  */
+ #define SDHCI_WINDOW_CTRL(i)	(0x80 + ((i) << 3))
+ #define SDHCI_WINDOW_BASE(i)	(0x84 + ((i) << 3))
+ #define SDHCI_MAX_WIN_NUM	8
+ 
+ static int mv_conf_mbus_windows(struct platform_device *pdev,
+ 				const struct mbus_dram_target_info *dram)
+ {
+ 	int i;
+ 	void __iomem *regs;
+ 	struct resource *res;
+ 
+ 	if (!dram) {
+ 		dev_err(&pdev->dev, "no mbus dram info\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+ 	if (!res) {
+ 		dev_err(&pdev->dev, "cannot get mbus registers\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	regs = ioremap(res->start, resource_size(res));
+ 	if (!regs) {
+ 		dev_err(&pdev->dev, "cannot map mbus registers\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	for (i = 0; i < SDHCI_MAX_WIN_NUM; i++) {
+ 		writel(0, regs + SDHCI_WINDOW_CTRL(i));
+ 		writel(0, regs + SDHCI_WINDOW_BASE(i));
+ 	}
+ 
+ 	for (i = 0; i < dram->num_cs; i++) {
+ 		const struct mbus_dram_window *cs = dram->cs + i;
+ 
+ 		/* Write size, attributes and target id to control register */
+ 		writel(((cs->size - 1) & 0xffff0000) |
+ 			(cs->mbus_attr << 8) |
+ 			(dram->mbus_dram_target_id << 4) | 1,
+ 			regs + SDHCI_WINDOW_CTRL(i));
+ 		/* Write base address to base register */
+ 		writel(cs->base, regs + SDHCI_WINDOW_BASE(i));
+ 	}
+ 
+ 	iounmap(regs);
+ 
+ 	return 0;
+ }
+ 
+ static void pxav3_reset(struct sdhci_host *host, u8 mask)
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  {
  	struct platform_device *pdev = to_platform_device(mmc_dev(host->mmc));
  	struct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;
@@@ -171,7 -228,8 +231,11 @@@ static const struct sdhci_ops pxav3_sdh
  	.set_uhs_signaling = pxav3_set_uhs_signaling,
  	.platform_send_init_74_clocks = pxav3_gen_init_74_clocks,
  	.get_max_clock = sdhci_pltfm_clk_get_max_clock,
++<<<<<<< HEAD
++=======
+ 	.set_bus_width = sdhci_set_bus_width,
+ 	.reset = pxav3_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  };
  
  static struct sdhci_pltfm_data sdhci_pxav3_pdata = {
diff --cc drivers/mmc/host/sdhci-s3c.c
index 926aaf6acc67,155241883751..000000000000
--- a/drivers/mmc/host/sdhci-s3c.c
+++ b/drivers/mmc/host/sdhci-s3c.c
@@@ -364,7 -361,8 +364,12 @@@ static struct sdhci_ops sdhci_s3c_ops 
  	.get_max_clock		= sdhci_s3c_get_max_clk,
  	.set_clock		= sdhci_s3c_set_clock,
  	.get_min_clock		= sdhci_s3c_get_min_clock,
++<<<<<<< HEAD
 +	.platform_bus_width	= sdhci_s3c_platform_bus_width,
++=======
+ 	.set_bus_width		= sdhci_s3c_set_bus_width,
+ 	.reset			= sdhci_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  };
  
  static void sdhci_s3c_notify_change(struct platform_device *dev, int state)
diff --cc drivers/mmc/host/sdhci-sirf.c
index 09805af0526d,5d79e10e1ba2..000000000000
--- a/drivers/mmc/host/sdhci-sirf.c
+++ b/drivers/mmc/host/sdhci-sirf.c
@@@ -30,6 -29,8 +30,11 @@@ static unsigned int sdhci_sirf_get_max_
  
  static struct sdhci_ops sdhci_sirf_ops = {
  	.get_max_clock	= sdhci_sirf_get_max_clk,
++<<<<<<< HEAD
++=======
+ 	.set_bus_width = sdhci_set_bus_width,
+ 	.reset = sdhci_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  };
  
  static struct sdhci_pltfm_data sdhci_sirf_pdata = {
diff --cc drivers/mmc/host/sdhci-spear.c
index 2151911b43ec,c2a2bedc8813..000000000000
--- a/drivers/mmc/host/sdhci-spear.c
+++ b/drivers/mmc/host/sdhci-spear.c
@@@ -37,31 -38,10 +37,36 @@@ struct spear_sdhci 
  
  /* sdhci ops */
  static const struct sdhci_ops sdhci_pltfm_ops = {
++<<<<<<< HEAD
 +	/* Nothing to do for now. */
++=======
+ 	.set_bus_width = sdhci_set_bus_width,
+ 	.reset = sdhci_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  };
  
 +/* gpio card detection interrupt handler */
 +static irqreturn_t sdhci_gpio_irq(int irq, void *dev_id)
 +{
 +	struct platform_device *pdev = dev_id;
 +	struct sdhci_host *host = platform_get_drvdata(pdev);
 +	struct spear_sdhci *sdhci = dev_get_platdata(&pdev->dev);
 +	unsigned long gpio_irq_type;
 +	int val;
 +
 +	val = gpio_get_value(sdhci->data->card_int_gpio);
 +
 +	/* val == 1 -> card removed, val == 0 -> card inserted */
 +	/* if card removed - set irq for low level, else vice versa */
 +	gpio_irq_type = val ? IRQF_TRIGGER_LOW : IRQF_TRIGGER_HIGH;
 +	irq_set_irq_type(irq, gpio_irq_type);
 +
 +	/* inform sdhci driver about card insertion/removal */
 +	tasklet_schedule(&host->card_tasklet);
 +
 +	return IRQ_HANDLED;
 +}
 +
  #ifdef CONFIG_OF
  static struct sdhci_plat_data *sdhci_probe_config_dt(struct platform_device *pdev)
  {
diff --cc drivers/mmc/host/sdhci-tegra.c
index c8b058283a06,7754c0319fda..000000000000
--- a/drivers/mmc/host/sdhci-tegra.c
+++ b/drivers/mmc/host/sdhci-tegra.c
@@@ -152,8 -153,8 +154,13 @@@ static const struct sdhci_ops tegra_sdh
  	.read_l     = tegra_sdhci_readl,
  	.read_w     = tegra_sdhci_readw,
  	.write_l    = tegra_sdhci_writel,
++<<<<<<< HEAD
 +	.platform_bus_width = tegra_sdhci_buswidth,
 +	.platform_reset_exit = tegra_sdhci_reset_exit,
++=======
+ 	.set_bus_width = tegra_sdhci_set_bus_width,
+ 	.reset      = tegra_sdhci_reset,
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  };
  
  static const struct sdhci_pltfm_data sdhci_tegra20_pdata = {
diff --cc drivers/mmc/host/sdhci.c
index 9a66ab1fa866,5e25147e92f7..000000000000
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@@ -180,22 -163,9 +180,25 @@@ static void sdhci_disable_card_detectio
  	sdhci_set_card_detection(host, false);
  }
  
- static void sdhci_reset(struct sdhci_host *host, u8 mask)
+ void sdhci_reset(struct sdhci_host *host, u8 mask)
  {
  	unsigned long timeout;
++<<<<<<< HEAD
 +	u32 uninitialized_var(ier);
 +
 +	if (host->quirks & SDHCI_QUIRK_NO_CARD_NO_RESET) {
 +		if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) &
 +			SDHCI_CARD_PRESENT))
 +			return;
 +	}
 +
 +	if (host->quirks & SDHCI_QUIRK_RESTORE_IRQS_AFTER_RESET)
 +		ier = sdhci_readl(host, SDHCI_INT_ENABLE);
 +
 +	if (host->ops->platform_reset_enter)
 +		host->ops->platform_reset_enter(host, mask);
++=======
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  
  	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
  
@@@ -220,12 -190,23 +223,21 @@@
  		timeout--;
  		mdelay(1);
  	}
+ }
+ EXPORT_SYMBOL_GPL(sdhci_reset);
  
- 	if (host->ops->platform_reset_exit)
- 		host->ops->platform_reset_exit(host, mask);
+ static void sdhci_do_reset(struct sdhci_host *host, u8 mask)
+ {
+ 	if (host->quirks & SDHCI_QUIRK_NO_CARD_NO_RESET) {
+ 		if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) &
+ 			SDHCI_CARD_PRESENT))
+ 			return;
+ 	}
+ 
+ 	host->ops->reset(host, mask);
  
 -	if (host->quirks & SDHCI_QUIRK_RESTORE_IRQS_AFTER_RESET) {
 -		sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
 -		sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
 -	}
 +	if (host->quirks & SDHCI_QUIRK_RESTORE_IRQS_AFTER_RESET)
 +		sdhci_clear_set_irqs(host, SDHCI_INT_ALL_MASK, ier);
  
  	if (host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA)) {
  		if ((host->ops->enable_dma) && (mask & SDHCI_RESET_ALL))
@@@ -238,15 -219,18 +250,15 @@@ static void sdhci_set_ios(struct mmc_ho
  static void sdhci_init(struct sdhci_host *host, int soft)
  {
  	if (soft)
- 		sdhci_reset(host, SDHCI_RESET_CMD|SDHCI_RESET_DATA);
+ 		sdhci_do_reset(host, SDHCI_RESET_CMD|SDHCI_RESET_DATA);
  	else
- 		sdhci_reset(host, SDHCI_RESET_ALL);
+ 		sdhci_do_reset(host, SDHCI_RESET_ALL);
  
 -	host->ier = SDHCI_INT_BUS_POWER | SDHCI_INT_DATA_END_BIT |
 -		    SDHCI_INT_DATA_CRC | SDHCI_INT_DATA_TIMEOUT |
 -		    SDHCI_INT_INDEX | SDHCI_INT_END_BIT | SDHCI_INT_CRC |
 -		    SDHCI_INT_TIMEOUT | SDHCI_INT_DATA_END |
 -		    SDHCI_INT_RESPONSE;
 -
 -	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
 -	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
 +	sdhci_clear_set_irqs(host, SDHCI_INT_ALL_MASK,
 +		SDHCI_INT_BUS_POWER | SDHCI_INT_DATA_END_BIT |
 +		SDHCI_INT_DATA_CRC | SDHCI_INT_DATA_TIMEOUT | SDHCI_INT_INDEX |
 +		SDHCI_INT_END_BIT | SDHCI_INT_CRC | SDHCI_INT_TIMEOUT |
 +		SDHCI_INT_DATA_END | SDHCI_INT_RESPONSE);
  
  	if (soft) {
  		/* force clock reconfiguration */
@@@ -3280,8 -3276,9 +3292,14 @@@ int sdhci_add_host(struct sdhci_host *h
  
  #ifdef SDHCI_USE_LEDS_CLASS
  reset:
++<<<<<<< HEAD
 +	sdhci_reset(host, SDHCI_RESET_ALL);
 +	sdhci_mask_irqs(host, SDHCI_INT_ALL_MASK);
++=======
+ 	sdhci_do_reset(host, SDHCI_RESET_ALL);
+ 	sdhci_writel(host, 0, SDHCI_INT_ENABLE);
+ 	sdhci_writel(host, 0, SDHCI_SIGNAL_ENABLE);
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  	free_irq(host->irq, host);
  #endif
  untasklet:
@@@ -3321,9 -3318,10 +3339,9 @@@ void sdhci_remove_host(struct sdhci_hos
  #endif
  
  	if (!dead)
- 		sdhci_reset(host, SDHCI_RESET_ALL);
+ 		sdhci_do_reset(host, SDHCI_RESET_ALL);
  
 -	sdhci_writel(host, 0, SDHCI_INT_ENABLE);
 -	sdhci_writel(host, 0, SDHCI_SIGNAL_ENABLE);
 +	sdhci_mask_irqs(host, SDHCI_INT_ALL_MASK);
  	free_irq(host->irq, host);
  
  	del_timer_sync(&host->timer);
diff --cc drivers/mmc/host/sdhci.h
index 0a3ed01887db,7d84cb3b0e00..000000000000
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@@ -397,6 -395,14 +396,17 @@@ extern void sdhci_remove_host(struct sd
  extern void sdhci_send_command(struct sdhci_host *host,
  				struct mmc_command *cmd);
  
++<<<<<<< HEAD
++=======
+ static inline bool sdhci_sdio_irq_enabled(struct sdhci_host *host)
+ {
+ 	return !!(host->flags & SDHCI_SDIO_IRQ_ENABLED);
+ }
+ 
+ void sdhci_set_bus_width(struct sdhci_host *host, int width);
+ void sdhci_reset(struct sdhci_host *host, u8 mask);
+ 
++>>>>>>> 03231f9b781f (mmc: sdhci: convert reset into a library function)
  #ifdef CONFIG_PM
  extern int sdhci_suspend_host(struct sdhci_host *host);
  extern int sdhci_resume_host(struct sdhci_host *host);
* Unmerged path drivers/mmc/host/sdhci-of-arasan.c
* Unmerged path drivers/mmc/host/sdhci-acpi.c
* Unmerged path drivers/mmc/host/sdhci-bcm-kona.c
* Unmerged path drivers/mmc/host/sdhci-bcm2835.c
* Unmerged path drivers/mmc/host/sdhci-cns3xxx.c
* Unmerged path drivers/mmc/host/sdhci-dove.c
* Unmerged path drivers/mmc/host/sdhci-esdhc-imx.c
* Unmerged path drivers/mmc/host/sdhci-of-arasan.c
* Unmerged path drivers/mmc/host/sdhci-of-esdhc.c
* Unmerged path drivers/mmc/host/sdhci-of-hlwd.c
* Unmerged path drivers/mmc/host/sdhci-pci.c
* Unmerged path drivers/mmc/host/sdhci-pltfm.c
* Unmerged path drivers/mmc/host/sdhci-pxav2.c
* Unmerged path drivers/mmc/host/sdhci-pxav3.c
* Unmerged path drivers/mmc/host/sdhci-s3c.c
* Unmerged path drivers/mmc/host/sdhci-sirf.c
* Unmerged path drivers/mmc/host/sdhci-spear.c
* Unmerged path drivers/mmc/host/sdhci-tegra.c
* Unmerged path drivers/mmc/host/sdhci.c
* Unmerged path drivers/mmc/host/sdhci.h
