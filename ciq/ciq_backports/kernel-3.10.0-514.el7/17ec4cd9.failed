zram: don't call idr_remove() from zram_remove()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jerome Marchand <jmarchan@redhat.com>
commit 17ec4cd985780a7e30aa45bb8f272237c12502a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/17ec4cd9.failed

The use of idr_remove() is forbidden in the callback functions of
idr_for_each().  It is therefore unsafe to call idr_remove in
zram_remove().

This patch moves the call to idr_remove() from zram_remove() to
hot_remove_store().  In the detroy_devices() path, idrs are removed by
idr_destroy().  This solves an use-after-free detected by KASan.

[akpm@linux-foundation.org: fix coding stype, per Sergey]
	Signed-off-by: Jerome Marchand <jmarchan@redhat.com>
	Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
	Cc: Minchan Kim <minchan@kernel.org>
	Cc: <stable@vger.kernel.org>	[4.2+]
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 17ec4cd985780a7e30aa45bb8f272237c12502a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/zram/zram_drv.c
diff --cc drivers/block/zram/zram_drv.c
index 817b95847bab,370c2f76016d..000000000000
--- a/drivers/block/zram/zram_drv.c
+++ b/drivers/block/zram/zram_drv.c
@@@ -1027,10 -1295,112 +1027,93 @@@ static void destroy_device(struct zram 
  	sysfs_remove_group(&disk_to_dev(zram->disk)->kobj,
  			&zram_disk_attr_group);
  
++<<<<<<< HEAD
++=======
+ 	/* Make sure all the pending I/O are finished */
+ 	fsync_bdev(bdev);
+ 	zram_reset_device(zram);
+ 	bdput(bdev);
+ 
+ 	pr_info("Removed device: %s\n", zram->disk->disk_name);
+ 
+ 	blk_cleanup_queue(zram->disk->queue);
++>>>>>>> 17ec4cd98578 (zram: don't call idr_remove() from zram_remove())
  	del_gendisk(zram->disk);
  	put_disk(zram->disk);
 -	kfree(zram);
 -	return 0;
 -}
  
++<<<<<<< HEAD
 +	blk_cleanup_queue(zram->queue);
++=======
+ /* zram-control sysfs attributes */
+ static ssize_t hot_add_show(struct class *class,
+ 			struct class_attribute *attr,
+ 			char *buf)
+ {
+ 	int ret;
+ 
+ 	mutex_lock(&zram_index_mutex);
+ 	ret = zram_add();
+ 	mutex_unlock(&zram_index_mutex);
+ 
+ 	if (ret < 0)
+ 		return ret;
+ 	return scnprintf(buf, PAGE_SIZE, "%d\n", ret);
+ }
+ 
+ static ssize_t hot_remove_store(struct class *class,
+ 			struct class_attribute *attr,
+ 			const char *buf,
+ 			size_t count)
+ {
+ 	struct zram *zram;
+ 	int ret, dev_id;
+ 
+ 	/* dev_id is gendisk->first_minor, which is `int' */
+ 	ret = kstrtoint(buf, 10, &dev_id);
+ 	if (ret)
+ 		return ret;
+ 	if (dev_id < 0)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&zram_index_mutex);
+ 
+ 	zram = idr_find(&zram_index_idr, dev_id);
+ 	if (zram) {
+ 		ret = zram_remove(zram);
+ 		idr_remove(&zram_index_idr, dev_id);
+ 	} else {
+ 		ret = -ENODEV;
+ 	}
+ 
+ 	mutex_unlock(&zram_index_mutex);
+ 	return ret ? ret : count;
+ }
+ 
+ static struct class_attribute zram_control_class_attrs[] = {
+ 	__ATTR_RO(hot_add),
+ 	__ATTR_WO(hot_remove),
+ 	__ATTR_NULL,
+ };
+ 
+ static struct class zram_control_class = {
+ 	.name		= "zram-control",
+ 	.owner		= THIS_MODULE,
+ 	.class_attrs	= zram_control_class_attrs,
+ };
+ 
+ static int zram_remove_cb(int id, void *ptr, void *data)
+ {
+ 	zram_remove(ptr);
+ 	return 0;
+ }
+ 
+ static void destroy_devices(void)
+ {
+ 	class_unregister(&zram_control_class);
+ 	idr_for_each(&zram_index_idr, &zram_remove_cb, NULL);
+ 	idr_destroy(&zram_index_idr);
+ 	unregister_blkdev(zram_major, "zram");
++>>>>>>> 17ec4cd98578 (zram: don't call idr_remove() from zram_remove())
  }
  
  static int __init zram_init(void)
* Unmerged path drivers/block/zram/zram_drv.c
