ipv6: datagram: Refactor dst lookup and update codes to a new function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit 7e2040db1539a904924b997a14ebd3de53172100
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7e2040db.failed

This patch moves the route lookup and update codes for connected
datagram sk to a newly created function ip6_datagram_dst_update()

It will be reused during the pmtu update in the later patch.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Cc: Cong Wang <xiyou.wangcong@gmail.com>
	Cc: Eric Dumazet <edumazet@google.com>
	Cc: Wei Wang <weiwan@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7e2040db1539a904924b997a14ebd3de53172100)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/datagram.c
diff --cc net/ipv6/datagram.c
index 88fda1924015,669585e11294..000000000000
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@@ -40,18 -40,92 +40,104 @@@ static bool ipv6_mapped_addr_any(const 
  	return ipv6_addr_v4mapped(a) && (a->s6_addr32[3] == 0);
  }
  
++<<<<<<< HEAD
 +int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 +{
 +	struct sockaddr_in6	*usin = (struct sockaddr_in6 *) uaddr;
 +	struct inet_sock      	*inet = inet_sk(sk);
 +	struct ipv6_pinfo      	*np = inet6_sk(sk);
 +	struct in6_addr		*daddr, *final_p, final;
 +	struct dst_entry	*dst;
 +	struct flowi6		fl6;
 +	struct ip6_flowlabel	*flowlabel = NULL;
 +	struct ipv6_txoptions   *opt;
++=======
+ static void ip6_datagram_flow_key_init(struct flowi6 *fl6, struct sock *sk)
+ {
+ 	struct inet_sock *inet = inet_sk(sk);
+ 	struct ipv6_pinfo *np = inet6_sk(sk);
+ 
+ 	memset(fl6, 0, sizeof(*fl6));
+ 	fl6->flowi6_proto = sk->sk_protocol;
+ 	fl6->daddr = sk->sk_v6_daddr;
+ 	fl6->saddr = np->saddr;
+ 	fl6->flowi6_oif = sk->sk_bound_dev_if;
+ 	fl6->flowi6_mark = sk->sk_mark;
+ 	fl6->fl6_dport = inet->inet_dport;
+ 	fl6->fl6_sport = inet->inet_sport;
+ 	fl6->flowlabel = np->flow_label;
+ 
+ 	if (!fl6->flowi6_oif)
+ 		fl6->flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;
+ 
+ 	if (!fl6->flowi6_oif && ipv6_addr_is_multicast(&fl6->daddr))
+ 		fl6->flowi6_oif = np->mcast_oif;
+ 
+ 	security_sk_classify_flow(sk, flowi6_to_flowi(fl6));
+ }
+ 
+ static int ip6_datagram_dst_update(struct sock *sk)
+ {
+ 	struct ip6_flowlabel *flowlabel = NULL;
+ 	struct in6_addr *final_p, final;
+ 	struct ipv6_txoptions *opt;
+ 	struct dst_entry *dst;
+ 	struct inet_sock *inet = inet_sk(sk);
+ 	struct ipv6_pinfo *np = inet6_sk(sk);
+ 	struct flowi6 fl6;
+ 	int err = 0;
+ 
+ 	if (np->sndflow && (np->flow_label & IPV6_FLOWLABEL_MASK)) {
+ 		flowlabel = fl6_sock_lookup(sk, np->flow_label);
+ 		if (!flowlabel)
+ 			return -EINVAL;
+ 	}
+ 	ip6_datagram_flow_key_init(&fl6, sk);
+ 
+ 	rcu_read_lock();
+ 	opt = flowlabel ? flowlabel->opt : rcu_dereference(np->opt);
+ 	final_p = fl6_update_dst(&fl6, opt, &final);
+ 	rcu_read_unlock();
+ 
+ 	dst = ip6_dst_lookup_flow(sk, &fl6, final_p);
+ 	if (IS_ERR(dst)) {
+ 		err = PTR_ERR(dst);
+ 		goto out;
+ 	}
+ 
+ 	if (ipv6_addr_any(&np->saddr))
+ 		np->saddr = fl6.saddr;
+ 
+ 	if (ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {
+ 		sk->sk_v6_rcv_saddr = fl6.saddr;
+ 		inet->inet_rcv_saddr = LOOPBACK4_IPV6;
+ 		if (sk->sk_prot->rehash)
+ 			sk->sk_prot->rehash(sk);
+ 	}
+ 
+ 	ip6_dst_store(sk, dst,
+ 		      ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr) ?
+ 		      &sk->sk_v6_daddr : NULL,
+ #ifdef CONFIG_IPV6_SUBTREES
+ 		      ipv6_addr_equal(&fl6.saddr, &np->saddr) ?
+ 		      &np->saddr :
+ #endif
+ 		      NULL);
+ 
+ out:
+ 	fl6_sock_release(flowlabel);
+ 	return err;
+ }
+ 
+ static int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
+ {
+ 	struct sockaddr_in6	*usin = (struct sockaddr_in6 *) uaddr;
+ 	struct inet_sock	*inet = inet_sk(sk);
+ 	struct ipv6_pinfo	*np = inet6_sk(sk);
+ 	struct in6_addr		*daddr;
++>>>>>>> 7e2040db1539 (ipv6: datagram: Refactor dst lookup and update codes to a new function)
  	int			addr_type;
  	int			err;
 -	__be32			fl6_flowlabel = 0;
  
  	if (usin->sin6_family == AF_INET) {
  		if (__ipv6_only_sock(sk))
@@@ -66,15 -140,8 +152,20 @@@
  	if (usin->sin6_family != AF_INET6)
  		return -EAFNOSUPPORT;
  
++<<<<<<< HEAD
 +	memset(&fl6, 0, sizeof(fl6));
 +	if (np->sndflow) {
 +		fl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;
 +		if (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {
 +			flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);
 +			if (flowlabel == NULL)
 +				return -EINVAL;
 +		}
 +	}
++=======
+ 	if (np->sndflow)
+ 		fl6_flowlabel = usin->sin6_flowinfo & IPV6_FLOWINFO_MASK;
++>>>>>>> 7e2040db1539 (ipv6: datagram: Refactor dst lookup and update codes to a new function)
  
  	addr_type = ipv6_addr_type(&usin->sin6_addr);
  
@@@ -154,61 -221,37 +245,43 @@@ ipv4_connected
  	 *	destination cache for it.
  	 */
  
++<<<<<<< HEAD
 +	fl6.flowi6_proto = sk->sk_protocol;
 +	fl6.daddr = sk->sk_v6_daddr;
 +	fl6.saddr = np->saddr;
 +	fl6.flowi6_oif = sk->sk_bound_dev_if;
 +	fl6.flowi6_mark = sk->sk_mark;
 +	fl6.fl6_dport = inet->inet_dport;
 +	fl6.fl6_sport = inet->inet_sport;
 +
 +	if (!fl6.flowi6_oif)
 +		fl6.flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;
 +
 +	if (!fl6.flowi6_oif && (addr_type&IPV6_ADDR_MULTICAST))
 +		fl6.flowi6_oif = np->mcast_oif;
 +
 +	security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));
 +
 +	opt = flowlabel ? flowlabel->opt : np->opt;
 +	final_p = fl6_update_dst(&fl6, opt, &final);
 +
 +	dst = ip6_dst_lookup_flow(sk, &fl6, final_p);
 +	err = 0;
 +	if (IS_ERR(dst)) {
 +		err = PTR_ERR(dst);
++=======
+ 	err = ip6_datagram_dst_update(sk);
+ 	if (err)
++>>>>>>> 7e2040db1539 (ipv6: datagram: Refactor dst lookup and update codes to a new function)
  		goto out;
- 	}
- 
- 	/* source address lookup done in ip6_dst_lookup */
- 
- 	if (ipv6_addr_any(&np->saddr))
- 		np->saddr = fl6.saddr;
- 
- 	if (ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {
- 		sk->sk_v6_rcv_saddr = fl6.saddr;
- 		inet->inet_rcv_saddr = LOOPBACK4_IPV6;
- 		if (sk->sk_prot->rehash)
- 			sk->sk_prot->rehash(sk);
- 	}
- 
- 	ip6_dst_store(sk, dst,
- 		      ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr) ?
- 		      &sk->sk_v6_daddr : NULL,
- #ifdef CONFIG_IPV6_SUBTREES
- 		      ipv6_addr_equal(&fl6.saddr, &np->saddr) ?
- 		      &np->saddr :
- #endif
- 		      NULL);
  
  	sk->sk_state = TCP_ESTABLISHED;
 -	sk_set_txhash(sk);
 +	ip6_set_txhash(sk);
  out:
- 	fl6_sock_release(flowlabel);
  	return err;
  }
 -
 -int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 -{
 -	int res;
 -
 -	lock_sock(sk);
 -	res = __ip6_datagram_connect(sk, uaddr, addr_len);
 -	release_sock(sk);
 -	return res;
 -}
  EXPORT_SYMBOL_GPL(ip6_datagram_connect);
  
 -int ip6_datagram_connect_v6_only(struct sock *sk, struct sockaddr *uaddr,
 -				 int addr_len)
 -{
 -	DECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, uaddr);
 -	if (sin6->sin6_family != AF_INET6)
 -		return -EAFNOSUPPORT;
 -	return ip6_datagram_connect(sk, uaddr, addr_len);
 -}
 -EXPORT_SYMBOL_GPL(ip6_datagram_connect_v6_only);
 -
  void ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err,
  		     __be16 port, u32 info, u8 *payload)
  {
* Unmerged path net/ipv6/datagram.c
