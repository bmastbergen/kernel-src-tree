xfs: refactor and open code log record crc check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Brian Foster <bfoster@redhat.com>
commit b94fb2d1780d7cd9d55b21e2bb879a54ed3074cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b94fb2d1.failed

Log record CRC verification currently occurs during active log recovery,
immediately before a log record is unpacked. Therefore, the CRC
calculation code is buried within the data unpack function. CRC
verification pass support only needs to go so far as check the CRC, but
this is not easily allowed as the code is currently organized.

Since we now have a new log record processing helper, pull the record
CRC verification code out from the unpack helper and open-code it at the
top of the new process helper. This facilitates the ability to modify
how records are processed based on the type of the current pass. This
patch contains no functional changes.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit b94fb2d1780d7cd9d55b21e2bb879a54ed3074cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_log_recover.c
diff --cc fs/xfs/xfs_log_recover.c
index 5a774879a6c2,9ec4bbd28d55..000000000000
--- a/fs/xfs/xfs_log_recover.c
+++ b/fs/xfs/xfs_log_recover.c
@@@ -4118,46 -4118,6 +4118,49 @@@ xlog_recover_process_iunlinks
  	mp->m_dmevmask = mp_dmevmask;
  }
  
++<<<<<<< HEAD
 +/*
 + * Upack the log buffer data and crc check it. If the check fails, issue a
 + * warning if and only if the CRC in the header is non-zero. This makes the
 + * check an advisory warning, and the zero CRC check will prevent failure
 + * warnings from being emitted when upgrading the kernel from one that does not
 + * add CRCs by default.
 + *
 + * When filesystems are CRC enabled, this CRC mismatch becomes a fatal log
 + * corruption failure
 + */
 +STATIC int
 +xlog_unpack_data_crc(
 +	struct xlog_rec_header	*rhead,
 +	xfs_caddr_t		dp,
 +	struct xlog		*log)
 +{
 +	__le32			crc;
 +
 +	crc = xlog_cksum(log, rhead, dp, be32_to_cpu(rhead->h_len));
 +	if (crc != rhead->h_crc) {
 +		if (rhead->h_crc || xfs_sb_version_hascrc(&log->l_mp->m_sb)) {
 +			xfs_alert(log->l_mp,
 +		"log record CRC mismatch: found 0x%x, expected 0x%x.",
 +					le32_to_cpu(rhead->h_crc),
 +					le32_to_cpu(crc));
 +			xfs_hex_dump(dp, 32);
 +		}
 +
 +		/*
 +		 * If we've detected a log record corruption, then we can't
 +		 * recover past this point. Abort recovery if we are enforcing
 +		 * CRC protection by punting an error back up the stack.
 +		 */
 +		if (xfs_sb_version_hascrc(&log->l_mp->m_sb))
 +			return -EFSCORRUPTED;
 +	}
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> b94fb2d1780d (xfs: refactor and open code log record crc check)
  STATIC int
  xlog_unpack_data(
  	struct xlog_rec_header	*rhead,
* Unmerged path fs/xfs/xfs_log_recover.c
