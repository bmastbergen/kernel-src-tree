be2iscsi: Rename MCC and BMBX processing functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jitendra Bhivare <jitendra.bhivare@broadcom.com>
commit 88840332a0f05833b2fea6c69584b5d20eb19ad8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/88840332.failed

beiscsi_mccq_compl -> beiscsi_mccq_compl_wait - indicate blocking call.
be_mcc_wait_compl -> be_mcc_compl_poll - indicate polling for completion.
be_mbox_db_ready_wait -> be_mbox_db_ready_poll - indicate polling for RDY.
be_mcc_compl_process -> beiscsi_process_mbox_compl - indicate BMBX compl.

	Signed-off-by: Jitendra Bhivare <jitendra.bhivare@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 88840332a0f05833b2fea6c69584b5d20eb19ad8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/be2iscsi/be_cmds.c
diff --cc drivers/scsi/be2iscsi/be_cmds.c
index f6abd01429a1,1fe8eb84333a..000000000000
--- a/drivers/scsi/be2iscsi/be_cmds.c
+++ b/drivers/scsi/be2iscsi/be_cmds.c
@@@ -406,115 -519,8 +406,115 @@@ int be_mcc_compl_process_isr(struct be_
  	return 0;
  }
  
 +static struct be_mcc_compl *be_mcc_compl_get(struct beiscsi_hba *phba)
 +{
 +	struct be_queue_info *mcc_cq = &phba->ctrl.mcc_obj.cq;
 +	struct be_mcc_compl *compl = queue_tail_node(mcc_cq);
 +
 +	if (be_mcc_compl_is_new(compl)) {
 +		queue_tail_inc(mcc_cq);
 +		return compl;
 +	}
 +	return NULL;
 +}
 +
 +/**
 + * beiscsi_fail_session(): Closing session with appropriate error
 + * @cls_session: ptr to session
 + **/
 +void beiscsi_fail_session(struct iscsi_cls_session *cls_session)
 +{
 +	iscsi_session_failure(cls_session->dd_data, ISCSI_ERR_CONN_FAILED);
 +}
 +
 +void beiscsi_async_link_state_process(struct beiscsi_hba *phba,
 +		struct be_async_event_link_state *evt)
 +{
 +	if ((evt->port_link_status == ASYNC_EVENT_LINK_DOWN) ||
 +	    ((evt->port_link_status & ASYNC_EVENT_LOGICAL) &&
 +	     (evt->port_fault != BEISCSI_PHY_LINK_FAULT_NONE))) {
 +		phba->state = BE_ADAPTER_LINK_DOWN;
 +
 +		beiscsi_log(phba, KERN_ERR,
 +			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_INIT,
 +			    "BC_%d : Link Down on Port %d\n",
 +			    evt->physical_port);
 +
 +		iscsi_host_for_each_session(phba->shost,
 +					    beiscsi_fail_session);
 +	} else if ((evt->port_link_status & ASYNC_EVENT_LINK_UP) ||
 +		    ((evt->port_link_status & ASYNC_EVENT_LOGICAL) &&
 +		     (evt->port_fault == BEISCSI_PHY_LINK_FAULT_NONE))) {
 +		phba->state = BE_ADAPTER_LINK_UP | BE_ADAPTER_CHECK_BOOT;
 +		phba->get_boot = BE_GET_BOOT_RETRIES;
 +
 +		beiscsi_log(phba, KERN_ERR,
 +			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_INIT,
 +			    "BC_%d : Link UP on Port %d\n",
 +			    evt->physical_port);
 +	}
 +}
 +
 +int beiscsi_process_mcc(struct beiscsi_hba *phba)
 +{
 +	struct be_mcc_compl *compl;
 +	int num = 0, status = 0;
 +	struct be_ctrl_info *ctrl = &phba->ctrl;
 +
 +	while ((compl = be_mcc_compl_get(phba))) {
 +		if (compl->flags & CQE_FLAGS_ASYNC_MASK) {
 +			/* Interpret flags as an async trailer */
 +			if (is_link_state_evt(compl->flags))
 +				/* Interpret compl as a async link evt */
 +				beiscsi_async_link_state_process(phba,
 +				   (struct be_async_event_link_state *) compl);
 +			else if (is_iscsi_evt(compl->flags)) {
 +				switch (iscsi_evt_type(compl->flags)) {
 +				case ASYNC_EVENT_NEW_ISCSI_TGT_DISC:
 +				case ASYNC_EVENT_NEW_ISCSI_CONN:
 +				case ASYNC_EVENT_NEW_TCP_CONN:
 +					phba->state |= BE_ADAPTER_CHECK_BOOT;
 +					phba->get_boot = BE_GET_BOOT_RETRIES;
 +					beiscsi_log(phba, KERN_ERR,
 +						    BEISCSI_LOG_CONFIG |
 +						    BEISCSI_LOG_MBOX,
 +						    "BC_%d : Async iscsi Event, flags "
 +						    "handled = 0x%08x\n",
 +						    compl->flags);
 +					break;
 +				default:
 +					phba->state |= BE_ADAPTER_CHECK_BOOT;
 +					phba->get_boot = BE_GET_BOOT_RETRIES;
 +					beiscsi_log(phba, KERN_ERR,
 +						    BEISCSI_LOG_CONFIG |
 +						    BEISCSI_LOG_MBOX,
 +						    "BC_%d : Unsupported Async iscsi "
 +						    "Event, flags = 0x%08x\n",
 +						    compl->flags);
 +				}
 +			} else
 +				beiscsi_log(phba, KERN_ERR,
 +					    BEISCSI_LOG_CONFIG |
 +					    BEISCSI_LOG_MBOX,
 +					    "BC_%d : Unsupported Async Event, flags"
 +					    " = 0x%08x\n", compl->flags);
 +
 +		} else if (compl->flags & CQE_FLAGS_COMPLETED_MASK) {
 +				status = be_mcc_compl_process(ctrl, compl);
 +				atomic_dec(&phba->ctrl.mcc_obj.q.used);
 +		}
 +		be_mcc_compl_use(compl);
 +		num++;
 +	}
 +
 +	if (num)
 +		hwi_ring_cq_db(phba, phba->ctrl.mcc_obj.cq.id, num, 1, 0);
 +
 +	return status;
 +}
 +
  /*
-  * be_mcc_wait_compl()- Wait for MBX completion
+  * be_mcc_compl_poll()- Wait for MBX completion
   * @phba: driver private structure
   *
   * Wait till no more pending mcc requests are present
@@@ -551,23 -556,7 +551,27 @@@ static int be_mcc_wait_compl(struct bei
  }
  
  /*
++<<<<<<< HEAD
 + * be_mcc_notify_wait()- Notify and wait for Compl
 + * @phba: driver private structure
 + *
 + * Notify MCC requests and wait for completion
 + *
 + * return
 + * Success: 0
 + * Failure: Non-Zero
 + **/
 +int be_mcc_notify_wait(struct beiscsi_hba *phba, unsigned int tag)
 +{
 +	be_mcc_notify(phba, tag);
 +	return be_mcc_wait_compl(phba);
 +}
 +
 +/*
 + * be_mbox_db_ready_wait()- Check ready status
++=======
+  * be_mbox_db_ready_poll()- Check ready status
++>>>>>>> 88840332a0f0 (be2iscsi: Rename MCC and BMBX processing functions)
   * @ctrl: Function specific MBX data structure
   *
   * Check for the ready status of FW to send BMBX
* Unmerged path drivers/scsi/be2iscsi/be_cmds.c
diff --git a/drivers/scsi/be2iscsi/be_cmds.h b/drivers/scsi/be2iscsi/be_cmds.h
index 522c53180d02..f1567da084ae 100644
--- a/drivers/scsi/be2iscsi/be_cmds.h
+++ b/drivers/scsi/be2iscsi/be_cmds.h
@@ -737,9 +737,9 @@ void free_mcc_tag(struct be_ctrl_info *ctrl, unsigned int tag);
 
 int be_cmd_modify_eq_delay(struct beiscsi_hba *phba, struct be_set_eqd *,
 			    int num);
-int beiscsi_mccq_compl(struct beiscsi_hba *phba,
-			uint32_t tag, struct be_mcc_wrb **wrb,
-			struct be_dma_mem *mbx_cmd_mem);
+int beiscsi_mccq_compl_wait(struct beiscsi_hba *phba,
+			    uint32_t tag, struct be_mcc_wrb **wrb,
+			    struct be_dma_mem *mbx_cmd_mem);
 /*ISCSI Functuions */
 int be_cmd_fw_initialize(struct be_ctrl_info *ctrl);
 int be_cmd_fw_uninit(struct be_ctrl_info *ctrl);
diff --git a/drivers/scsi/be2iscsi/be_iscsi.c b/drivers/scsi/be2iscsi/be_iscsi.c
index 1f1ae87225b9..5059382f6cc9 100644
--- a/drivers/scsi/be2iscsi/be_iscsi.c
+++ b/drivers/scsi/be2iscsi/be_iscsi.c
@@ -737,7 +737,7 @@ static int beiscsi_get_initname(char *buf, struct beiscsi_hba *phba)
 		return -EBUSY;
 	}
 
-	rc = beiscsi_mccq_compl(phba, tag, &wrb, NULL);
+	rc = beiscsi_mccq_compl_wait(phba, tag, &wrb, NULL);
 	if (rc) {
 		beiscsi_log(phba, KERN_ERR,
 			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
@@ -1166,7 +1166,7 @@ static int beiscsi_open_conn(struct iscsi_endpoint *ep,
 		return -EAGAIN;
 	}
 
-	ret = beiscsi_mccq_compl(phba, tag, NULL, &nonemb_cmd);
+	ret = beiscsi_mccq_compl_wait(phba, tag, NULL, &nonemb_cmd);
 	if (ret) {
 		beiscsi_log(phba, KERN_ERR,
 			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
@@ -1325,7 +1325,7 @@ static int beiscsi_close_conn(struct  beiscsi_endpoint *beiscsi_ep, int flag)
 		ret = -EAGAIN;
 	}
 
-	ret = beiscsi_mccq_compl(phba, tag, NULL, NULL);
+	ret = beiscsi_mccq_compl_wait(phba, tag, NULL, NULL);
 
 	/* Flush the CQ entries */
 	beiscsi_flush_cq(phba);
@@ -1400,7 +1400,7 @@ void beiscsi_ep_disconnect(struct iscsi_endpoint *ep)
 			    beiscsi_ep->ep_cid);
 	}
 
-	beiscsi_mccq_compl(phba, tag, NULL, NULL);
+	beiscsi_mccq_compl_wait(phba, tag, NULL, NULL);
 	beiscsi_close_conn(beiscsi_ep, tcp_upload_flag);
 free_ep:
 	msleep(BEISCSI_LOGOUT_SYNC_DELAY);
diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c
index 7885533b6626..f7b5a5d270d1 100644
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@ -286,7 +286,7 @@ static int beiscsi_eh_abort(struct scsi_cmnd *sc)
 		return FAILED;
 	}
 
-	rc = beiscsi_mccq_compl(phba, tag, NULL, &nonemb_cmd);
+	rc = beiscsi_mccq_compl_wait(phba, tag, NULL, &nonemb_cmd);
 	if (rc != -EBUSY)
 		pci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,
 				    nonemb_cmd.va, nonemb_cmd.dma);
@@ -367,7 +367,7 @@ static int beiscsi_eh_device_reset(struct scsi_cmnd *sc)
 		return FAILED;
 	}
 
-	rc = beiscsi_mccq_compl(phba, tag, NULL, &nonemb_cmd);
+	rc = beiscsi_mccq_compl_wait(phba, tag, NULL, &nonemb_cmd);
 	if (rc != -EBUSY)
 		pci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,
 				    nonemb_cmd.va, nonemb_cmd.dma);
@@ -4454,7 +4454,7 @@ static int beiscsi_get_boot_info(struct beiscsi_hba *phba)
 		goto boot_freemem;
 	}
 
-	ret = beiscsi_mccq_compl(phba, tag, NULL, &nonemb_cmd);
+	ret = beiscsi_mccq_compl_wait(phba, tag, NULL, &nonemb_cmd);
 	if (ret) {
 		beiscsi_log(phba, KERN_ERR,
 			    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,
@@ -5485,7 +5485,7 @@ static void be_eqd_update(struct beiscsi_hba *phba)
 	if (num) {
 		tag = be_cmd_modify_eq_delay(phba, set_eqd, num);
 		if (tag)
-			beiscsi_mccq_compl(phba, tag, NULL, NULL);
+			beiscsi_mccq_compl_wait(phba, tag, NULL, NULL);
 	}
 }
 
diff --git a/drivers/scsi/be2iscsi/be_mgmt.c b/drivers/scsi/be2iscsi/be_mgmt.c
index 229fa208398d..3ce54743ecf2 100644
--- a/drivers/scsi/be2iscsi/be_mgmt.c
+++ b/drivers/scsi/be2iscsi/be_mgmt.c
@@ -843,7 +843,7 @@ unsigned int mgmt_get_all_if_id(struct beiscsi_hba *phba)
 	be_mcc_notify(phba, tag);
 	mutex_unlock(&ctrl->mbox_lock);
 
-	status = beiscsi_mccq_compl(phba, tag, &wrb, NULL);
+	status = beiscsi_mccq_compl_wait(phba, tag, &wrb, NULL);
 	if (status) {
 		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,
 			    "BG_%d : Failed in mgmt_get_all_if_id\n");
@@ -894,7 +894,7 @@ static int mgmt_exec_nonemb_cmd(struct beiscsi_hba *phba,
 	be_mcc_notify(phba, tag);
 	mutex_unlock(&ctrl->mbox_lock);
 
-	rc = beiscsi_mccq_compl(phba, tag, NULL, nonemb_cmd);
+	rc = beiscsi_mccq_compl_wait(phba, tag, NULL, nonemb_cmd);
 
 	if (resp_buf)
 		memcpy(resp_buf, nonemb_cmd->va, resp_buf_len);
@@ -1357,7 +1357,7 @@ int be_mgmt_get_boot_shandle(struct beiscsi_hba *phba,
 			return -EAGAIN;
 		}
 
-		rc = beiscsi_mccq_compl(phba, tag, &wrb, NULL);
+		rc = beiscsi_mccq_compl_wait(phba, tag, &wrb, NULL);
 		if (rc) {
 			beiscsi_log(phba, KERN_ERR,
 				    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,
@@ -1391,7 +1391,7 @@ int be_mgmt_get_boot_shandle(struct beiscsi_hba *phba,
 			return -EAGAIN;
 		}
 
-		rc = beiscsi_mccq_compl(phba, tag, NULL, NULL);
+		rc = beiscsi_mccq_compl_wait(phba, tag, NULL, NULL);
 		if (rc) {
 			beiscsi_log(phba, KERN_ERR,
 				    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,
@@ -1433,7 +1433,7 @@ int mgmt_set_vlan(struct beiscsi_hba *phba,
 		return -EBUSY;
 	}
 
-	rc = beiscsi_mccq_compl(phba, tag, NULL, NULL);
+	rc = beiscsi_mccq_compl_wait(phba, tag, NULL, NULL);
 	if (rc) {
 		beiscsi_log(phba, KERN_ERR,
 			    (BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX),
@@ -1799,7 +1799,7 @@ int beiscsi_logout_fw_sess(struct beiscsi_hba *phba,
 	be_mcc_notify(phba, tag);
 	mutex_unlock(&ctrl->mbox_lock);
 
-	rc = beiscsi_mccq_compl(phba, tag, &wrb, NULL);
+	rc = beiscsi_mccq_compl_wait(phba, tag, &wrb, NULL);
 	if (rc) {
 		beiscsi_log(phba, KERN_ERR,
 			    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,
