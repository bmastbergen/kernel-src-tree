HID: i2c-hid: Only disable irq wake if it was successfully enabled during suspend

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hid] i2c-hid: Only disable irq wake if it was successfully enabled during suspend (David Arcari) [1361625]
Rebuild_FUZZ: 96.82%
commit-author Andrew Duggan <aduggan@synaptics.com>
commit d1c48038b849e9df0475621a52193a62424a4e87
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d1c48038.failed

Enabling irq wake could potentially fail and calling disable_irq_wake
after a failed call to enable_irq_wake could result in an unbalanced irq
warning. This patch warns if enable_irq_wake fails and avoids other
potential issues caused by calling disable_irq_wake on resume after
enable_irq_wake failed during suspend.

	Signed-off-by: Andrew Duggan <aduggan@synaptics.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit d1c48038b849e9df0475621a52193a62424a4e87)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/i2c-hid/i2c-hid.c
diff --cc drivers/hid/i2c-hid/i2c-hid.c
index 9c64e1db9067,2871f3c81a4c..000000000000
--- a/drivers/hid/i2c-hid/i2c-hid.c
+++ b/drivers/hid/i2c-hid/i2c-hid.c
@@@ -142,8 -145,12 +142,10 @@@ struct i2c_hid 
  	unsigned long		flags;		/* device flags */
  
  	wait_queue_head_t	wait;		/* For waiting the interrupt */
 -	struct gpio_desc	*desc;
 -	int			irq;
  
  	struct i2c_hid_platform_data pdata;
+ 
+ 	bool			irq_wake_enabled;
  };
  
  static int __i2c_hid_command(struct i2c_client *client,
@@@ -1058,14 -1093,21 +1060,28 @@@ static int i2c_hid_suspend(struct devic
  	struct i2c_hid *ihid = i2c_get_clientdata(client);
  	struct hid_device *hid = ihid->hid;
  	int ret = 0;
+ 	int wake_status;
  
 +	disable_irq(client->irq);
 +	if (device_may_wakeup(&client->dev))
 +		enable_irq_wake(client->irq);
 +
  	if (hid->driver && hid->driver->suspend)
  		ret = hid->driver->suspend(hid, PMSG_SUSPEND);
  
++<<<<<<< HEAD
++=======
+ 	disable_irq(ihid->irq);
+ 	if (device_may_wakeup(&client->dev)) {
+ 		wake_status = enable_irq_wake(ihid->irq);
+ 		if (!wake_status)
+ 			ihid->irq_wake_enabled = true;
+ 		else
+ 			hid_warn(hid, "Failed to enable irq wake: %d\n",
+ 				wake_status);
+ 	}
+ 
++>>>>>>> d1c48038b849 (HID: i2c-hid: Only disable irq wake if it was successfully enabled during suspend)
  	/* Save some power */
  	i2c_hid_set_power(client, I2C_HID_PWR_SLEEP);
  
@@@ -1078,14 -1120,21 +1094,26 @@@ static int i2c_hid_resume(struct devic
  	struct i2c_client *client = to_i2c_client(dev);
  	struct i2c_hid *ihid = i2c_get_clientdata(client);
  	struct hid_device *hid = ihid->hid;
+ 	int wake_status;
  
 -	enable_irq(ihid->irq);
 +	enable_irq(client->irq);
  	ret = i2c_hid_hwreset(client);
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD
 +	if (device_may_wakeup(&client->dev))
 +		disable_irq_wake(client->irq);
++=======
+ 	if (device_may_wakeup(&client->dev) && ihid->irq_wake_enabled) {
+ 		wake_status = disable_irq_wake(ihid->irq);
+ 		if (!wake_status)
+ 			ihid->irq_wake_enabled = false;
+ 		else
+ 			hid_warn(hid, "Failed to disable irq wake: %d\n",
+ 				wake_status);
+ 	}
++>>>>>>> d1c48038b849 (HID: i2c-hid: Only disable irq wake if it was successfully enabled during suspend)
  
  	if (hid->driver && hid->driver->reset_resume) {
  		ret = hid->driver->reset_resume(hid);
* Unmerged path drivers/hid/i2c-hid/i2c-hid.c
