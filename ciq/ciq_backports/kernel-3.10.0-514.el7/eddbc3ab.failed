mmc: slot-gpio: Remove option to explicitly free requested CD/WP GPIOs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ulf Hansson <ulf.hansson@linaro.org>
commit eddbc3abc5bf11bdfc92ef84fd97ec4d379b7278
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/eddbc3ab.failed

The slot-gpio uses the devm*_ managed functions. Still it provide APIs
to explicitly free requested CD/WP GPIOs, but these API isn't being
used.

Therefore let's simplify slot-gpio by removing these unused APIs. If it
later turns out we need some of them, we can always consider to restore
the code.

	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit eddbc3abc5bf11bdfc92ef84fd97ec4d379b7278)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/slot-gpio.c
#	include/linux/mmc/slot-gpio.h
diff --cc drivers/mmc/core/slot-gpio.c
index f33bbd48c2c0,a428f10747d2..000000000000
--- a/drivers/mmc/core/slot-gpio.c
+++ b/drivers/mmc/core/slot-gpio.c
@@@ -194,6 -164,51 +190,54 @@@ int mmc_gpio_request_cd(struct mmc_hos
  
  	if (irq < 0)
  		host->caps |= MMC_CAP_NEEDS_POLL;
++<<<<<<< HEAD
++=======
+ }
+ EXPORT_SYMBOL(mmc_gpiod_request_cd_irq);
+ 
+ /**
+  * mmc_gpio_request_cd - request a gpio for card-detection
+  * @host: mmc host
+  * @gpio: gpio number requested
+  * @debounce: debounce time in microseconds
+  *
+  * As devm_* managed functions are used in mmc_gpio_request_cd(), client
+  * drivers do not need to worry about freeing up memory.
+  *
+  * If GPIO debouncing is desired, set the debounce parameter to a non-zero
+  * value. The caller is responsible for ensuring that the GPIO driver associated
+  * with the GPIO supports debouncing, otherwise an error will be returned.
+  *
+  * Returns zero on success, else an error.
+  */
+ int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio,
+ 			unsigned int debounce)
+ {
+ 	struct mmc_gpio *ctx;
+ 	int ret;
+ 
+ 	ret = mmc_gpio_alloc(host);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ctx = host->slot.handler_priv;
+ 
+ 	ret = devm_gpio_request_one(&host->class_dev, gpio, GPIOF_DIR_IN,
+ 				    ctx->cd_label);
+ 	if (ret < 0)
+ 		/*
+ 		 * don't bother freeing memory. It might still get used by other
+ 		 * slot functions, in any case it will be freed, when the device
+ 		 * is destroyed.
+ 		 */
+ 		return ret;
+ 
+ 	if (debounce) {
+ 		ret = gpio_set_debounce(gpio, debounce);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
++>>>>>>> eddbc3abc5bf (mmc: slot-gpio: Remove option to explicitly free requested CD/WP GPIOs)
  
  	ctx->override_cd_active_level = true;
  	ctx->cd_gpio = gpio_to_desc(gpio);
@@@ -203,50 -218,106 +247,156 @@@
  EXPORT_SYMBOL(mmc_gpio_request_cd);
  
  /**
++<<<<<<< HEAD
 + * mmc_gpio_free_ro - free the write-protection gpio
 + * @host: mmc host
 + *
 + * It's provided only for cases that client drivers need to manually free
 + * up the write-protection gpio requested by mmc_gpio_request_ro().
 + */
 +void mmc_gpio_free_ro(struct mmc_host *host)
 +{
 +	struct mmc_gpio *ctx = host->slot.handler_priv;
 +	int gpio;
 +
 +	if (!ctx || !ctx->ro_gpio)
 +		return;
 +
 +	gpio = desc_to_gpio(ctx->ro_gpio);
 +	ctx->ro_gpio = NULL;
 +
 +	devm_gpio_free(&host->class_dev, gpio);
 +}
 +EXPORT_SYMBOL(mmc_gpio_free_ro);
 +
 +/**
 + * mmc_gpio_free_cd - free the card-detection gpio
 + * @host: mmc host
 + *
 + * It's provided only for cases that client drivers need to manually free
 + * up the card-detection gpio requested by mmc_gpio_request_cd().
 + */
 +void mmc_gpio_free_cd(struct mmc_host *host)
 +{
 +	struct mmc_gpio *ctx = host->slot.handler_priv;
 +	int gpio;
 +
 +	if (!ctx || !ctx->cd_gpio)
 +		return;
 +
 +	if (host->slot.cd_irq >= 0) {
 +		devm_free_irq(&host->class_dev, host->slot.cd_irq, host);
 +		host->slot.cd_irq = -EINVAL;
 +	}
 +
 +	gpio = desc_to_gpio(ctx->cd_gpio);
 +	ctx->cd_gpio = NULL;
 +
 +	devm_gpio_free(&host->class_dev, gpio);
 +}
 +EXPORT_SYMBOL(mmc_gpio_free_cd);
++=======
+  * mmc_gpiod_request_cd - request a gpio descriptor for card-detection
+  * @host: mmc host
+  * @con_id: function within the GPIO consumer
+  * @idx: index of the GPIO to obtain in the consumer
+  * @override_active_level: ignore %GPIO_ACTIVE_LOW flag
+  * @debounce: debounce time in microseconds
+  * @gpio_invert: will return whether the GPIO line is inverted or not, set
+  * to NULL to ignore
+  *
+  * Use this function in place of mmc_gpio_request_cd() to use the GPIO
+  * descriptor API.  Note that it must be called prior to mmc_add_host()
+  * otherwise the caller must also call mmc_gpiod_request_cd_irq().
+  *
+  * Returns zero on success, else an error.
+  */
+ int mmc_gpiod_request_cd(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce, bool *gpio_invert)
+ {
+ 	struct mmc_gpio *ctx;
+ 	struct gpio_desc *desc;
+ 	int ret;
+ 
+ 	ret = mmc_gpio_alloc(host);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ctx = host->slot.handler_priv;
+ 
+ 	if (!con_id)
+ 		con_id = ctx->cd_label;
+ 
+ 	desc = devm_gpiod_get_index(host->parent, con_id, idx, GPIOD_IN);
+ 	if (IS_ERR(desc))
+ 		return PTR_ERR(desc);
+ 
+ 	if (debounce) {
+ 		ret = gpiod_set_debounce(desc, debounce);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	if (gpio_invert)
+ 		*gpio_invert = !gpiod_is_active_low(desc);
+ 
+ 	ctx->override_cd_active_level = override_active_level;
+ 	ctx->cd_gpio = desc;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(mmc_gpiod_request_cd);
+ 
+ /**
+  * mmc_gpiod_request_ro - request a gpio descriptor for write protection
+  * @host: mmc host
+  * @con_id: function within the GPIO consumer
+  * @idx: index of the GPIO to obtain in the consumer
+  * @override_active_level: ignore %GPIO_ACTIVE_LOW flag
+  * @debounce: debounce time in microseconds
+  * @gpio_invert: will return whether the GPIO line is inverted or not,
+  * set to NULL to ignore
+  *
+  * Use this function in place of mmc_gpio_request_ro() to use the GPIO
+  * descriptor API.
+  *
+  * Returns zero on success, else an error.
+  */
+ int mmc_gpiod_request_ro(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce, bool *gpio_invert)
+ {
+ 	struct mmc_gpio *ctx;
+ 	struct gpio_desc *desc;
+ 	int ret;
+ 
+ 	ret = mmc_gpio_alloc(host);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ctx = host->slot.handler_priv;
+ 
+ 	if (!con_id)
+ 		con_id = ctx->ro_label;
+ 
+ 	desc = devm_gpiod_get_index(host->parent, con_id, idx, GPIOD_IN);
+ 	if (IS_ERR(desc))
+ 		return PTR_ERR(desc);
+ 
+ 	if (debounce) {
+ 		ret = gpiod_set_debounce(desc, debounce);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	if (gpio_invert)
+ 		*gpio_invert = !gpiod_is_active_low(desc);
+ 
+ 	ctx->override_ro_active_level = override_active_level;
+ 	ctx->ro_gpio = desc;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(mmc_gpiod_request_ro);
++>>>>>>> eddbc3abc5bf (mmc: slot-gpio: Remove option to explicitly free requested CD/WP GPIOs)
diff --cc include/linux/mmc/slot-gpio.h
index 7d88d27bfafa,4a36d6954631..000000000000
--- a/include/linux/mmc/slot-gpio.h
+++ b/include/linux/mmc/slot-gpio.h
@@@ -15,10 -15,17 +15,23 @@@ struct mmc_host
  
  int mmc_gpio_get_ro(struct mmc_host *host);
  int mmc_gpio_request_ro(struct mmc_host *host, unsigned int gpio);
- void mmc_gpio_free_ro(struct mmc_host *host);
  
  int mmc_gpio_get_cd(struct mmc_host *host);
++<<<<<<< HEAD
 +int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio);
 +void mmc_gpio_free_cd(struct mmc_host *host);
 +
++=======
+ int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio,
+ 			unsigned int debounce);
+ 
+ int mmc_gpiod_request_cd(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce, bool *gpio_invert);
+ int mmc_gpiod_request_ro(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce, bool *gpio_invert);
+ void mmc_gpiod_request_cd_irq(struct mmc_host *host);
+ 
++>>>>>>> eddbc3abc5bf (mmc: slot-gpio: Remove option to explicitly free requested CD/WP GPIOs)
  #endif
* Unmerged path drivers/mmc/core/slot-gpio.c
* Unmerged path include/linux/mmc/slot-gpio.h
