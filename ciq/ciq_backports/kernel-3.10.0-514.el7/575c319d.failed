mmc: dw_mmc: fix pio mode when internal dmac is enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Heiko Stuebner <heiko@sntech.de>
commit 575c319dfe872fc8bf1d57b244fb40f497ab3a47
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/575c319d.failed

The dw_mci_init_dma() may decide to not use dma, but pio instead, caused
by things like wrong dma settings in the system.

Till now the code dw_mci_init_slot() always assumed that dma is available
when CONFIG_MMC_DW_IDMAC was defined, ignoring the host->use_dma var
set during dma init.

So when now the dma init failed for whatever reason, the transfer sizes
would still be set for dma transfers, especially including the maximum
block-count calculated from host->ring_size and resulting in a

[    4.991109] ------------[ cut here ]------------
[    4.991111] kernel BUG at drivers/mmc/core/core.c:256!
[    4.991113] Internal error: Oops - BUG: 0 [#1] SMP ARM

because host->ring_size is 0 in this case and the slot init code uses
the wrong code to calculate the values.

Fix this by selecting the correct calculations using the host->use_dma
variable instead of the CONFIG_MMC_DW_IDMAC config option.

	Signed-off-by: Heiko Stuebner <heiko@sntech.de>
	Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
(cherry picked from commit 575c319dfe872fc8bf1d57b244fb40f497ab3a47)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/dw_mmc.c
diff --cc drivers/mmc/host/dw_mmc.c
index bc4f99ee919c,3c0e1993e737..000000000000
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@@ -2061,19 -2444,20 +2061,36 @@@ static int dw_mci_init_slot(struct dw_m
  		mmc->max_seg_size = host->pdata->blk_settings->max_seg_size;
  	} else {
  		/* Useful defaults if platform data is unset. */
++<<<<<<< HEAD
 +#ifdef CONFIG_MMC_DW_IDMAC
 +		mmc->max_segs = host->ring_size;
 +		mmc->max_blk_size = 65536;
 +		mmc->max_blk_count = host->ring_size;
 +		mmc->max_seg_size = 0x1000;
 +		mmc->max_req_size = mmc->max_seg_size * mmc->max_blk_count;
 +#else
 +		mmc->max_segs = 64;
 +		mmc->max_blk_size = 65536; /* BLKSIZ is 16 bits */
 +		mmc->max_blk_count = 512;
 +		mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
 +		mmc->max_seg_size = mmc->max_req_size;
 +#endif /* CONFIG_MMC_DW_IDMAC */
++=======
+ 		if (host->use_dma) {
+ 			mmc->max_segs = host->ring_size;
+ 			mmc->max_blk_size = 65536;
+ 			mmc->max_seg_size = 0x1000;
+ 			mmc->max_req_size = mmc->max_seg_size * host->ring_size;
+ 			mmc->max_blk_count = mmc->max_req_size / 512;
+ 		} else {
+ 			mmc->max_segs = 64;
+ 			mmc->max_blk_size = 65536; /* BLKSIZ is 16 bits */
+ 			mmc->max_blk_count = 512;
+ 			mmc->max_req_size = mmc->max_blk_size *
+ 					    mmc->max_blk_count;
+ 			mmc->max_seg_size = mmc->max_req_size;
+ 		}
++>>>>>>> 575c319dfe87 (mmc: dw_mmc: fix pio mode when internal dmac is enabled)
  	}
  
  	if (dw_mci_get_cd(mmc))
* Unmerged path drivers/mmc/host/dw_mmc.c
diff --git a/include/linux/mmc/dw_mmc.h b/include/linux/mmc/dw_mmc.h
index a2d9a022a8fd..c55b5252b499 100644
--- a/include/linux/mmc/dw_mmc.h
+++ b/include/linux/mmc/dw_mmc.h
@@ -141,11 +141,7 @@ struct dw_mci {
 	dma_addr_t		sg_dma;
 	void			*sg_cpu;
 	const struct dw_mci_dma_ops	*dma_ops;
-#ifdef CONFIG_MMC_DW_IDMAC
 	unsigned int		ring_size;
-#else
-	struct dw_mci_dma_data	*dma_data;
-#endif
 	u32			cmd_status;
 	u32			data_status;
 	u32			stop_cmdr;
