IB/iser: set intuitive values for mr_valid

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jenny Derzhavetz <jennyf@mellanox.com>
commit 1caa70d8a7c0e8427cb8381f29e759bda4ea2dcd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1caa70d8.failed

This parameter is described as "is mr valid indicator".
In other words, it indicates whether memory registration
is valid or not. So intuitive values would be:
mr_valid=True, when memory registration is valid and
mr_valid=False otherwise.

	Signed-off-by: Jenny Derzhavetz <jennyf@mellanox.com>
	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 1caa70d8a7c0e8427cb8381f29e759bda4ea2dcd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iser_memory.c
diff --cc drivers/infiniband/ulp/iser/iser_memory.c
index 5502beb685d5,0a798498b303..000000000000
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@@ -752,39 -397,27 +752,52 @@@ iser_reg_sig_mr(struct iscsi_iser_task 
  	if (ret)
  		goto err;
  
 -	iser_set_prot_checks(iser_task->sc, &sig_attrs->check_mask);
 +	ret = iser_set_prot_checks(iser_task->sc, &sig_attrs.check_mask);
 +	if (ret)
 +		goto err;
  
++<<<<<<< HEAD
 +	if (!pi_ctx->sig_mr_valid) {
 +		iser_inv_rkey(&inv_wr, pi_ctx->sig_mr);
 +		wr = &inv_wr;
 +	}
++=======
+ 	if (pi_ctx->sig_mr_valid)
+ 		iser_inv_rkey(iser_tx_next_wr(tx_desc), pi_ctx->sig_mr, cqe);
 -
 -	wr = sig_handover_wr(iser_tx_next_wr(tx_desc));
 -	wr->wr.opcode = IB_WR_REG_SIG_MR;
 -	wr->wr.wr_cqe = cqe;
 -	wr->wr.sg_list = &data_reg->sge;
 -	wr->wr.num_sge = 1;
 -	wr->wr.send_flags = 0;
 -	wr->sig_attrs = sig_attrs;
 -	wr->sig_mr = pi_ctx->sig_mr;
++>>>>>>> 1caa70d8a7c0 (IB/iser: set intuitive values for mr_valid)
 +
 +	memset(&sig_wr, 0, sizeof(sig_wr));
 +	sig_wr.opcode = IB_WR_REG_SIG_MR;
 +	sig_wr.wr_id = ISER_FASTREG_LI_WRID;
 +	sig_wr.sg_list = &data_reg->sge;
 +	sig_wr.num_sge = 1;
 +	sig_wr.wr.sig_handover.sig_attrs = &sig_attrs;
 +	sig_wr.wr.sig_handover.sig_mr = pi_ctx->sig_mr;
  	if (scsi_prot_sg_count(iser_task->sc))
 -		wr->prot = &prot_reg->sge;
 +		sig_wr.wr.sig_handover.prot = &prot_reg->sge;
 +	sig_wr.wr.sig_handover.access_flags = IB_ACCESS_LOCAL_WRITE |
 +					      IB_ACCESS_REMOTE_READ |
 +					      IB_ACCESS_REMOTE_WRITE;
 +
 +	if (!wr)
 +		wr = &sig_wr;
  	else
++<<<<<<< HEAD
 +		wr->next = &sig_wr;
 +
 +	ret = ib_post_send(ib_conn->qp, wr, &bad_wr);
 +	if (ret) {
 +		iser_err("reg_sig_mr failed, ret:%d\n", ret);
 +		goto err;
 +	}
 +	pi_ctx->sig_mr_valid = 0;
++=======
+ 		wr->prot = NULL;
+ 	wr->access_flags = IB_ACCESS_LOCAL_WRITE |
+ 			   IB_ACCESS_REMOTE_READ |
+ 			   IB_ACCESS_REMOTE_WRITE;
+ 	pi_ctx->sig_mr_valid = 1;
++>>>>>>> 1caa70d8a7c0 (IB/iser: set intuitive values for mr_valid)
  
  	sig_reg->sge.lkey = pi_ctx->sig_mr->lkey;
  	sig_reg->rkey = pi_ctx->sig_mr->rkey;
@@@ -803,58 -436,34 +816,67 @@@ static int iser_fast_reg_mr(struct iscs
  			    struct iser_reg_resources *rsc,
  			    struct iser_mem_reg *reg)
  {
 -	struct iser_tx_desc *tx_desc = &iser_task->desc;
 -	struct ib_cqe *cqe = &iser_task->iser_conn->ib_conn.reg_cqe;
 -	struct ib_mr *mr = rsc->mr;
 -	struct ib_reg_wr *wr;
 -	int n;
 -
 +	struct ib_conn *ib_conn = &iser_task->iser_conn->ib_conn;
 +	struct iser_device *device = ib_conn->device;
 +	struct ib_mr *mr;
 +	struct ib_fast_reg_page_list *frpl;
 +	struct ib_send_wr fastreg_wr, inv_wr;
 +	struct ib_send_wr *bad_wr, *wr = NULL;
 +	int ret, offset, size, plen;
 +
++<<<<<<< HEAD
 +	/* if there a single dma entry, dma mr suffices */
 +	if (mem->dma_nents == 1)
 +		return iser_reg_dma(device, mem, reg);
++=======
+ 	if (rsc->mr_valid)
+ 		iser_inv_rkey(iser_tx_next_wr(tx_desc), mr, cqe);
++>>>>>>> 1caa70d8a7c0 (IB/iser: set intuitive values for mr_valid)
 +
 +	mr = rsc->mr;
 +	frpl = rsc->frpl;
  
 -	n = ib_map_mr_sg(mr, mem->sg, mem->size, SIZE_4K);
 -	if (unlikely(n != mem->size)) {
 -		iser_err("failed to map sg (%d/%d)\n",
 -			 n, mem->size);
 -		return n < 0 ? n : -EINVAL;
 +	plen = iser_sg_to_page_vec(mem, device->ib_device, frpl->page_list,
 +				   &offset, &size);
 +	if (plen * SIZE_4K < size) {
 +		iser_err("fast reg page_list too short to hold this SG\n");
 +		return -EINVAL;
 +	}
 +
 +	if (!rsc->mr_valid) {
 +		iser_inv_rkey(&inv_wr, mr);
 +		wr = &inv_wr;
  	}
  
 -	wr = reg_wr(iser_tx_next_wr(tx_desc));
 -	wr->wr.opcode = IB_WR_REG_MR;
 -	wr->wr.wr_cqe = cqe;
 -	wr->wr.send_flags = 0;
 -	wr->wr.num_sge = 0;
 -	wr->mr = mr;
 -	wr->key = mr->rkey;
 -	wr->access = IB_ACCESS_LOCAL_WRITE  |
 -		     IB_ACCESS_REMOTE_WRITE |
 -		     IB_ACCESS_REMOTE_READ;
++<<<<<<< HEAD
 +	/* Prepare FASTREG WR */
 +	memset(&fastreg_wr, 0, sizeof(fastreg_wr));
 +	fastreg_wr.wr_id = ISER_FASTREG_LI_WRID;
 +	fastreg_wr.opcode = IB_WR_FAST_REG_MR;
 +	fastreg_wr.wr.fast_reg.iova_start = frpl->page_list[0] + offset;
 +	fastreg_wr.wr.fast_reg.page_list = frpl;
 +	fastreg_wr.wr.fast_reg.page_list_len = plen;
 +	fastreg_wr.wr.fast_reg.page_shift = SHIFT_4K;
 +	fastreg_wr.wr.fast_reg.length = size;
 +	fastreg_wr.wr.fast_reg.rkey = mr->rkey;
 +	fastreg_wr.wr.fast_reg.access_flags = (IB_ACCESS_LOCAL_WRITE  |
 +					       IB_ACCESS_REMOTE_WRITE |
 +					       IB_ACCESS_REMOTE_READ);
 +
 +	if (!wr)
 +		wr = &fastreg_wr;
 +	else
 +		wr->next = &fastreg_wr;
  
 +	ret = ib_post_send(ib_conn->qp, wr, &bad_wr);
 +	if (ret) {
 +		iser_err("fast registration failed, ret:%d\n", ret);
 +		return ret;
 +	}
 +	rsc->mr_valid = 0;
++=======
+ 	rsc->mr_valid = 1;
++>>>>>>> 1caa70d8a7c0 (IB/iser: set intuitive values for mr_valid)
  
  	reg->sge.lkey = mr->lkey;
  	reg->rkey = mr->rkey;
* Unmerged path drivers/infiniband/ulp/iser/iser_memory.c
diff --git a/drivers/infiniband/ulp/iser/iser_verbs.c b/drivers/infiniband/ulp/iser/iser_verbs.c
index 862a581a4df5..1b7317db532d 100644
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@ -302,7 +302,7 @@ iser_alloc_reg_res(struct ib_device *ib_device,
 		iser_err("Failed to allocate ib_fast_reg_mr err=%d\n", ret);
 		goto fast_reg_mr_failure;
 	}
-	res->mr_valid = 1;
+	res->mr_valid = 0;
 
 	return 0;
 
@@ -345,7 +345,7 @@ iser_alloc_pi_ctx(struct ib_device *ib_device,
 		ret = PTR_ERR(pi_ctx->sig_mr);
 		goto sig_mr_failure;
 	}
-	pi_ctx->sig_mr_valid = 1;
+	pi_ctx->sig_mr_valid = 0;
 	desc->pi_ctx->sig_protected = 0;
 
 	return 0;
