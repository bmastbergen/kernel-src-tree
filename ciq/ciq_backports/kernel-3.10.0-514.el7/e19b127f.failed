NVMe: Using PRACT bit to generate and verify PI by controller

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alok Pandey <pandey.alok@samsung.com>
commit e19b127f5b76ec03b9c52b64f117dc75bb39eda1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e19b127f.failed

This patch enables the PRCHK and reftag support when PRACT bit is set, and
block layer integrity is disabled.

	Signed-off-by: Alok Pandey <pandey.alok@samsung.com>
	Reviewed-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit e19b127f5b76ec03b9c52b64f117dc75bb39eda1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index db4198bd70b4,8de3de010741..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -689,33 -804,46 +689,55 @@@ static int nvme_submit_iod(struct nvme_
  	if (req->cmd_flags & REQ_RAHEAD)
  		dsmgmt |= NVME_RW_DSM_FREQ_PREFETCH;
  
 -	memset(&cmnd, 0, sizeof(cmnd));
 -	cmnd.rw.opcode = (rq_data_dir(req) ? nvme_cmd_write : nvme_cmd_read);
 -	cmnd.rw.command_id = req->tag;
 -	cmnd.rw.nsid = cpu_to_le32(ns->ns_id);
 -	cmnd.rw.prp1 = cpu_to_le64(sg_dma_address(iod->sg));
 -	cmnd.rw.prp2 = cpu_to_le64(iod->first_dma);
 -	cmnd.rw.slba = cpu_to_le64(nvme_block_nr(ns, blk_rq_pos(req)));
 -	cmnd.rw.length = cpu_to_le16((blk_rq_bytes(req) >> ns->lba_shift) - 1);
 -
 +	cmnd = &nvmeq->sq_cmds[nvmeq->sq_tail];
 +	memset(cmnd, 0, sizeof(*cmnd));
 +
++<<<<<<< HEAD
 +	cmnd->rw.opcode = (rq_data_dir(req) ? nvme_cmd_write : nvme_cmd_read);
 +	cmnd->rw.command_id = req->tag;
 +	cmnd->rw.nsid = cpu_to_le32(ns->ns_id);
 +	cmnd->rw.prp1 = cpu_to_le64(sg_dma_address(iod->sg));
 +	cmnd->rw.prp2 = cpu_to_le64(iod->first_dma);
 +	cmnd->rw.slba = cpu_to_le64(nvme_block_nr(ns, blk_rq_pos(req)));
 +	cmnd->rw.length = cpu_to_le16((blk_rq_bytes(req) >> ns->lba_shift) - 1);
 +
 +	if (blk_integrity_rq(req))
 +		cmnd->rw.metadata = cpu_to_le64(sg_dma_address(iod->meta_sg));
 +	else if (ns->ms)
 +		control |= NVME_RW_PRINFO_PRACT;
++=======
+ 	if (ns->ms) {
+ 		switch (ns->pi_type) {
+ 		case NVME_NS_DPS_PI_TYPE3:
+ 			control |= NVME_RW_PRINFO_PRCHK_GUARD;
+ 			break;
+ 		case NVME_NS_DPS_PI_TYPE1:
+ 		case NVME_NS_DPS_PI_TYPE2:
+ 			control |= NVME_RW_PRINFO_PRCHK_GUARD |
+ 					NVME_RW_PRINFO_PRCHK_REF;
+ 			cmnd.rw.reftag = cpu_to_le32(
+ 					nvme_block_nr(ns, blk_rq_pos(req)));
+ 			break;
+ 		}
+ 		if (blk_integrity_rq(req))
+ 			cmnd.rw.metadata =
+ 				cpu_to_le64(sg_dma_address(iod->meta_sg));
+ 		else
+ 			control |= NVME_RW_PRINFO_PRACT;
+ 	}
++>>>>>>> e19b127f5b76 (NVMe: Using PRACT bit to generate and verify PI by controller)
  
 -	cmnd.rw.control = cpu_to_le16(control);
 -	cmnd.rw.dsmgmt = cpu_to_le32(dsmgmt);
 +	cmnd->rw.control = cpu_to_le16(control);
 +	cmnd->rw.dsmgmt = cpu_to_le32(dsmgmt);
  
 -	__nvme_submit_cmd(nvmeq, &cmnd);
 +	if (++nvmeq->sq_tail == nvmeq->q_depth)
 +		nvmeq->sq_tail = 0;
 +	writel(nvmeq->sq_tail, nvmeq->q_db);
  
  	return 0;
 +
  }
  
 -/*
 - * NOTE: ns is NULL when called on the admin queue.
 - */
  static int nvme_queue_rq(struct blk_mq_hw_ctx *hctx,
  			 const struct blk_mq_queue_data *bd)
  {
@@@ -1931,8 -2040,7 +1953,12 @@@ static int nvme_revalidate_disk(struct 
  								!ns->ext)
  		nvme_init_integrity(ns);
  
++<<<<<<< HEAD
 +	if ((ns->ms && !blk_get_integrity(disk) &&
 +					!(ns->pi_type && ns->ms == 8)))
++=======
+ 	if (ns->ms && !(ns->ms == 8 && ns->pi_type) && !blk_get_integrity(disk))
++>>>>>>> e19b127f5b76 (NVMe: Using PRACT bit to generate and verify PI by controller)
  		set_capacity(disk, 0);
  	else
  		set_capacity(disk, le64_to_cpup(&id->nsze) << (ns->lba_shift - 9));
* Unmerged path drivers/block/nvme-core.c
