af_unix: fix hard linked sockets on overlay

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit eb0a4a47ae89aaa0674ab3180de6a162f3be2ddf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/eb0a4a47.failed

Overlayfs uses separate inodes even in the case of hard links on the
underlying filesystems.  This is a problem for AF_UNIX socket
implementation which indexes sockets based on the inode.  This resulted in
hard linked sockets not working.

The fix is to use the real, underlying inode.

Test case follows:

-- ovl-sock-test.c --
#include <unistd.h>
#include <err.h>
#include <sys/socket.h>
#include <sys/un.h>

#define SOCK "test-sock"
#define SOCK2 "test-sock2"

int main(void)
{
	int fd, fd2;
	struct sockaddr_un addr = {
		.sun_family = AF_UNIX,
		.sun_path = SOCK,
	};
	struct sockaddr_un addr2 = {
		.sun_family = AF_UNIX,
		.sun_path = SOCK2,
	};

	unlink(SOCK);
	unlink(SOCK2);
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		err(1, "socket");
	if (bind(fd, (struct sockaddr *) &addr, sizeof(addr)) == -1)
		err(1, "bind");
	if (listen(fd, 0) == -1)
		err(1, "listen");
	if (link(SOCK, SOCK2) == -1)
		err(1, "link");
	if ((fd2 = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		err(1, "socket");
	if (connect(fd2, (struct sockaddr *) &addr2, sizeof(addr2)) == -1)
		err (1, "connect");
	return 0;
}
----

	Reported-by: Alexander Morozov <alexandr.morozov@docker.com> 
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
	Cc: <stable@vger.kernel.org>
(cherry picked from commit eb0a4a47ae89aaa0674ab3180de6a162f3be2ddf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/unix/af_unix.c
diff --cc net/unix/af_unix.c
index 2ee5c63dc1ed,7748199b3568..000000000000
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@@ -304,7 -315,7 +304,11 @@@ static struct sock *unix_find_socket_by
  		    &unix_socket_table[i->i_ino & (UNIX_HASH_SIZE - 1)]) {
  		struct dentry *dentry = unix_sk(s)->path.dentry;
  
++<<<<<<< HEAD
 +		if (dentry && dentry->d_inode == i) {
++=======
+ 		if (dentry && d_real_inode(dentry) == i) {
++>>>>>>> eb0a4a47ae89 (af_unix: fix hard linked sockets on overlay)
  			sock_hold(s);
  			goto found;
  		}
@@@ -789,7 -911,7 +793,11 @@@ static struct sock *unix_find_other(str
  		err = kern_path(sunname->sun_path, LOOKUP_FOLLOW, &path);
  		if (err)
  			goto fail;
++<<<<<<< HEAD
 +		inode = path.dentry->d_inode;
++=======
+ 		inode = d_real_inode(path.dentry);
++>>>>>>> eb0a4a47ae89 (af_unix: fix hard linked sockets on overlay)
  		err = inode_permission(inode, MAY_WRITE);
  		if (err)
  			goto put_fail;
@@@ -916,9 -1048,9 +924,13 @@@ static int unix_bind(struct socket *soc
  			goto out_up;
  		}
  		addr->hash = UNIX_HASH_SIZE;
++<<<<<<< HEAD
 +		hash = path.dentry->d_inode->i_ino & (UNIX_HASH_SIZE-1);
++=======
+ 		hash = d_real_inode(dentry)->i_ino & (UNIX_HASH_SIZE - 1);
++>>>>>>> eb0a4a47ae89 (af_unix: fix hard linked sockets on overlay)
  		spin_lock(&unix_table_lock);
 -		u->path = u_path;
 +		u->path = path;
  		list = &unix_socket_table[hash];
  	} else {
  		spin_lock(&unix_table_lock);
* Unmerged path net/unix/af_unix.c
