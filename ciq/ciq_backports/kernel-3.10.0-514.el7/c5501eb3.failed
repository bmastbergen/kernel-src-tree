net: ipv4: avoid repeated calls to ip_skb_dst_mtu helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] ipv4: avoid repeated calls to ip_skb_dst_mtu helper (Thadeu Lima de Souza Cascardo) [1274845]
Rebuild_FUZZ: 95.33%
commit-author Florian Westphal <fw@strlen.de>
commit c5501eb3406d0f88b3efb2c437c4c40b35f865d8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c5501eb3.failed

ip_skb_dst_mtu is small inline helper, but its called in several places.

before: 17061      44       0   17105    42d1 net/ipv4/ip_output.o
after:  16805      44       0   16849    41d1 net/ipv4/ip_output.o

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c5501eb3406d0f88b3efb2c437c4c40b35f865d8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ip_output.c
diff --cc net/ipv4/ip_output.c
index f60554e30748,d6dd8ba04441..000000000000
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@@ -83,6 -83,10 +83,13 @@@
  int sysctl_ip_default_ttl __read_mostly = IPDEFTTL;
  EXPORT_SYMBOL(sysctl_ip_default_ttl);
  
++<<<<<<< HEAD
++=======
+ static int ip_fragment(struct sock *sk, struct sk_buff *skb,
+ 		       unsigned int mtu,
+ 		       int (*output)(struct sock *, struct sk_buff *));
+ 
++>>>>>>> c5501eb3406d (net: ipv4: avoid repeated calls to ip_skb_dst_mtu helper)
  /* Generate a checksum for an outgoing IP datagram. */
  void ip_send_check(struct iphdr *iph)
  {
@@@ -222,7 -227,9 +230,13 @@@ static int ip_finish_output_gso(struct 
  	struct sk_buff *segs;
  	int ret = 0;
  
++<<<<<<< HEAD
 +	if (skb_gso_network_seglen(skb) <= ip_skb_dst_mtu(skb))
++=======
+ 	/* common case: locally created skb or seglen is <= mtu */
+ 	if (((IPCB(skb)->flags & IPSKB_FORWARDED) == 0) ||
+ 	      skb_gso_network_seglen(skb) <= mtu)
++>>>>>>> c5501eb3406d (net: ipv4: avoid repeated calls to ip_skb_dst_mtu helper)
  		return ip_finish_output2(sk, skb);
  
  	/* Slowpath -  GSO segment length is exceeding the dst MTU.
@@@ -258,9 -265,11 +272,11 @@@
  
  static int ip_finish_output(struct sock *sk, struct sk_buff *skb)
  {
+ 	unsigned int mtu;
+ 
  #if defined(CONFIG_NETFILTER) && defined(CONFIG_XFRM)
  	/* Policy lookup after SNAT yielded a new policy */
 -	if (skb_dst(skb)->xfrm) {
 +	if (skb_dst(skb)->xfrm != NULL) {
  		IPCB(skb)->flags |= IPSKB_REROUTED;
  		return dst_output_sk(sk, skb);
  	}
@@@ -479,6 -486,28 +496,31 @@@ static void ip_copy_metadata(struct sk_
  	skb_copy_secmark(to, from);
  }
  
++<<<<<<< HEAD
++=======
+ static int ip_fragment(struct sock *sk, struct sk_buff *skb,
+ 		       unsigned int mtu,
+ 		       int (*output)(struct sock *, struct sk_buff *))
+ {
+ 	struct iphdr *iph = ip_hdr(skb);
+ 
+ 	if (unlikely(((iph->frag_off & htons(IP_DF)) && !skb->ignore_df) ||
+ 		     (IPCB(skb)->frag_max_size &&
+ 		      IPCB(skb)->frag_max_size > mtu))) {
+ 		struct rtable *rt = skb_rtable(skb);
+ 		struct net_device *dev = rt->dst.dev;
+ 
+ 		IP_INC_STATS(dev_net(dev), IPSTATS_MIB_FRAGFAILS);
+ 		icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
+ 			  htonl(mtu));
+ 		kfree_skb(skb);
+ 		return -EMSGSIZE;
+ 	}
+ 
+ 	return ip_do_fragment(sk, skb, output);
+ }
+ 
++>>>>>>> c5501eb3406d (net: ipv4: avoid repeated calls to ip_skb_dst_mtu helper)
  /*
   *	This IP datagram is too large to be sent in one piece.  Break it up into
   *	smaller pieces (each of size equal to IP header plus
* Unmerged path net/ipv4/ip_output.c
