fanotify: convert access_mutex to spinlock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jan Kara <jack@suse.cz>
commit 9573f79355ff3711c98227d14a9b7f4cb3222b97
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9573f793.failed

access_mutex is used only to guard operations on access_list.  There's
no need for sleeping within this lock so just make a spinlock out of it.

	Signed-off-by: Jan Kara <jack@suse.cz>
	Cc: Eric Paris <eparis@redhat.com>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9573f79355ff3711c98227d14a9b7f4cb3222b97)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/fanotify/fanotify_user.c
diff --cc fs/notify/fanotify/fanotify_user.c
index 8ef1b0f829ee,2a57278afb80..000000000000
--- a/fs/notify/fanotify/fanotify_user.c
+++ b/fs/notify/fanotify/fanotify_user.c
@@@ -137,25 -129,26 +137,32 @@@ static int fill_event_metadata(struct f
  }
  
  #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
 -static struct fanotify_perm_event_info *dequeue_event(
 -				struct fsnotify_group *group, int fd)
 +static struct fanotify_response_event *dequeue_re(struct fsnotify_group *group,
 +						  __s32 fd)
  {
 -	struct fanotify_perm_event_info *event, *return_e = NULL;
 +	struct fanotify_response_event *re, *return_re = NULL;
  
++<<<<<<< HEAD
 +	mutex_lock(&group->fanotify_data.access_mutex);
 +	list_for_each_entry(re, &group->fanotify_data.access_list, list) {
 +		if (re->fd != fd)
++=======
+ 	spin_lock(&group->fanotify_data.access_lock);
+ 	list_for_each_entry(event, &group->fanotify_data.access_list,
+ 			    fae.fse.list) {
+ 		if (event->fd != fd)
++>>>>>>> 9573f79355ff (fanotify: convert access_mutex to spinlock)
  			continue;
  
 -		list_del_init(&event->fae.fse.list);
 -		return_e = event;
 +		list_del_init(&re->list);
 +		return_re = re;
  		break;
  	}
- 	mutex_unlock(&group->fanotify_data.access_mutex);
+ 	spin_unlock(&group->fanotify_data.access_lock);
  
 -	pr_debug("%s: found return_re=%p\n", __func__, return_e);
 +	pr_debug("%s: found return_re=%p\n", __func__, return_re);
  
 -	return return_e;
 +	return return_re;
  }
  
  static int process_access_response(struct fsnotify_group *group,
@@@ -257,9 -207,18 +264,24 @@@ static ssize_t copy_event_to_user(struc
  			 fanotify_event_metadata.event_len))
  		goto out_close_fd;
  
++<<<<<<< HEAD
 +	ret = prepare_for_access_response(group, event, fd);
 +	if (ret)
 +		goto out_close_fd;
++=======
+ #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
+ 	if (event->mask & FAN_ALL_PERM_EVENTS) {
+ 		struct fanotify_perm_event_info *pevent;
+ 
+ 		pevent = FANOTIFY_PE(event);
+ 		pevent->fd = fd;
+ 		spin_lock(&group->fanotify_data.access_lock);
+ 		list_add_tail(&pevent->fae.fse.list,
+ 			      &group->fanotify_data.access_list);
+ 		spin_unlock(&group->fanotify_data.access_lock);
+ 	}
+ #endif
++>>>>>>> 9573f79355ff (fanotify: convert access_mutex to spinlock)
  
  	if (fd != FAN_NOFD)
  		fd_install(fd, f);
@@@ -380,22 -344,21 +402,22 @@@ static int fanotify_release(struct inod
  	struct fsnotify_group *group = file->private_data;
  
  #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
 -	struct fanotify_perm_event_info *event, *next;
 +	struct fanotify_response_event *re, *lre;
  
- 	mutex_lock(&group->fanotify_data.access_mutex);
+ 	spin_lock(&group->fanotify_data.access_lock);
  
  	atomic_inc(&group->fanotify_data.bypass_perm);
  
 -	list_for_each_entry_safe(event, next, &group->fanotify_data.access_list,
 -				 fae.fse.list) {
 -		pr_debug("%s: found group=%p event=%p\n", __func__, group,
 -			 event);
 +	list_for_each_entry_safe(re, lre, &group->fanotify_data.access_list, list) {
 +		pr_debug("%s: found group=%p re=%p event=%p\n", __func__, group,
 +			 re, re->event);
  
 -		list_del_init(&event->fae.fse.list);
 -		event->response = FAN_ALLOW;
 +		list_del_init(&re->list);
 +		re->event->response = FAN_ALLOW;
 +
 +		kmem_cache_free(fanotify_response_event_cache, re);
  	}
- 	mutex_unlock(&group->fanotify_data.access_mutex);
+ 	spin_unlock(&group->fanotify_data.access_lock);
  
  	wake_up(&group->fanotify_data.access_waitq);
  #endif
@@@ -706,11 -691,16 +728,11 @@@ SYSCALL_DEFINE2(fanotify_init, unsigne
  	group->fanotify_data.user = user;
  	atomic_inc(&user->fanotify_listeners);
  
 -	oevent = fanotify_alloc_event(NULL, FS_Q_OVERFLOW, NULL);
 -	if (unlikely(!oevent)) {
 -		fd = -ENOMEM;
 -		goto out_destroy_group;
 -	}
 -	group->overflow_event = &oevent->fse;
 -
 +	if (force_o_largefile())
 +		event_f_flags |= O_LARGEFILE;
  	group->fanotify_data.f_flags = event_f_flags;
  #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
- 	mutex_init(&group->fanotify_data.access_mutex);
+ 	spin_lock_init(&group->fanotify_data.access_lock);
  	init_waitqueue_head(&group->fanotify_data.access_waitq);
  	INIT_LIST_HEAD(&group->fanotify_data.access_list);
  	atomic_set(&group->fanotify_data.bypass_perm, 0);
* Unmerged path fs/notify/fanotify/fanotify_user.c
diff --git a/include/linux/fsnotify_backend.h b/include/linux/fsnotify_backend.h
index 4b2ee8d12f5e..540146734dfc 100644
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@ -164,7 +164,7 @@ struct fsnotify_group {
 		struct fanotify_group_private_data {
 #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
 			/* allows a group to block waiting for a userspace response */
-			struct mutex access_mutex;
+			spinlock_t access_lock;
 			struct list_head access_list;
 			wait_queue_head_t access_waitq;
 			atomic_t bypass_perm;
