netfilter: nf_tables: kill nft_validate_output_register()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Patrick McHardy <kaber@trash.net>
commit 27e6d2017abdfbdb8b790c34c93d65ee10ce2fc5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/27e6d201.failed

All users of nft_validate_register_store() first invoke
nft_validate_output_register(). There is in fact no use for using it
on its own, so simplify the code by folding the functionality into
nft_validate_register_store() and kill it.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 27e6d2017abdfbdb8b790c34c93d65ee10ce2fc5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables.h
#	net/bridge/netfilter/nft_meta_bridge.c
#	net/netfilter/nf_tables_api.c
#	net/netfilter/nft_bitwise.c
#	net/netfilter/nft_byteorder.c
#	net/netfilter/nft_ct.c
#	net/netfilter/nft_exthdr.c
#	net/netfilter/nft_immediate.c
#	net/netfilter/nft_lookup.c
#	net/netfilter/nft_meta.c
#	net/netfilter/nft_payload.c
diff --cc include/net/netfilter/nf_tables.h
index 4ab50d820db0,a8d4bd3edb26..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -113,10 -113,10 +113,17 @@@ static inline enum nft_registers nft_ty
  }
  
  int nft_validate_input_register(enum nft_registers reg);
++<<<<<<< HEAD
 +int nft_validate_output_register(enum nft_registers reg);
 +int nft_validate_data_load(const struct nft_ctx *ctx, enum nft_registers reg,
 +			   const struct nft_data *data,
 +			   enum nft_data_types type);
++=======
+ int nft_validate_register_store(const struct nft_ctx *ctx,
+ 				enum nft_registers reg,
+ 				const struct nft_data *data,
+ 				enum nft_data_types type, unsigned int len);
++>>>>>>> 27e6d2017abd (netfilter: nf_tables: kill nft_validate_output_register())
  
  
  /**
diff --cc net/bridge/netfilter/nft_meta_bridge.c
index 4f02109d708f,54d984768443..000000000000
--- a/net/bridge/netfilter/nft_meta_bridge.c
+++ b/net/bridge/netfilter/nft_meta_bridge.c
@@@ -53,7 -53,7 +53,11 @@@ static int nft_meta_bridge_get_init(con
  				    const struct nlattr * const tb[])
  {
  	struct nft_meta *priv = nft_expr_priv(expr);
++<<<<<<< HEAD
 +	int err;
++=======
+ 	unsigned int len;
++>>>>>>> 27e6d2017abd (netfilter: nf_tables: kill nft_validate_output_register())
  
  	priv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));
  	switch (priv->key) {
@@@ -65,15 -66,8 +69,20 @@@
  	}
  
  	priv->dreg = ntohl(nla_get_be32(tb[NFTA_META_DREG]));
++<<<<<<< HEAD
 +	err = nft_validate_output_register(priv->dreg);
 +	if (err < 0)
 +		return err;
 +
 +	err = nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
 +	if (err < 0)
 +		return err;
 +
 +	return 0;
++=======
+ 	return nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					   NFT_DATA_VALUE, len);
++>>>>>>> 27e6d2017abd (netfilter: nf_tables: kill nft_validate_output_register())
  }
  
  static struct nft_expr_type nft_meta_bridge_type;
diff --cc net/netfilter/nf_tables_api.c
index 399ca83793bb,f01e89fe3c35..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -3975,25 -4140,7 +3975,29 @@@ int nft_validate_input_register(enum nf
  EXPORT_SYMBOL_GPL(nft_validate_input_register);
  
  /**
++<<<<<<< HEAD
 + *	nft_validate_output_register - validate an expressions' output register
 + *
 + *	@reg: the register number
 + *
 + * 	Validate that the output register is one of the general purpose
 + * 	registers or the verdict register.
 + */
 +int nft_validate_output_register(enum nft_registers reg)
 +{
 +	if (reg < NFT_REG_VERDICT)
 +		return -EINVAL;
 +	if (reg > NFT_REG_MAX)
 +		return -ERANGE;
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(nft_validate_output_register);
 +
 +/**
 + *	nft_validate_data_load - validate an expressions' data load
++=======
+  *	nft_validate_register_store - validate an expressions' register store
++>>>>>>> 27e6d2017abd (netfilter: nf_tables: kill nft_validate_output_register())
   *
   *	@ctx: context of the expression performing the load
   * 	@reg: the destination register number
@@@ -4030,6 -4180,15 +4034,18 @@@ int nft_validate_data_load(const struc
  
  		return 0;
  	default:
++<<<<<<< HEAD
++=======
+ 		if (reg < NFT_REG_1)
+ 			return -EINVAL;
+ 		if (reg > NFT_REG_MAX)
+ 			return -ERANGE;
+ 		if (len == 0)
+ 			return -EINVAL;
+ 		if (len > FIELD_SIZEOF(struct nft_data, data))
+ 			return -ERANGE;
+ 
++>>>>>>> 27e6d2017abd (netfilter: nf_tables: kill nft_validate_output_register())
  		if (data != NULL && type != NFT_DATA_VALUE)
  			return -EINVAL;
  		return 0;
diff --cc net/netfilter/nft_bitwise.c
index 4fb6ee2c1106,d31205287366..000000000000
--- a/net/netfilter/nft_bitwise.c
+++ b/net/netfilter/nft_bitwise.c
@@@ -69,10 -71,8 +69,15 @@@ static int nft_bitwise_init(const struc
  		return err;
  
  	priv->dreg = ntohl(nla_get_be32(tb[NFTA_BITWISE_DREG]));
++<<<<<<< HEAD
 +	err = nft_validate_output_register(priv->dreg);
 +	if (err < 0)
 +		return err;
 +	err = nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
++=======
+ 	err = nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					  NFT_DATA_VALUE, priv->len);
++>>>>>>> 27e6d2017abd (netfilter: nf_tables: kill nft_validate_output_register())
  	if (err < 0)
  		return err;
  
diff --cc net/netfilter/nft_byteorder.c
index c39ed8d29df1,848bce032350..000000000000
--- a/net/netfilter/nft_byteorder.c
+++ b/net/netfilter/nft_byteorder.c
@@@ -122,7 -109,14 +122,18 @@@ static int nft_byteorder_init(const str
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	priv->sreg = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_SREG]));
+ 	err = nft_validate_input_register(priv->sreg);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	priv->dreg = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_DREG]));
+ 	return nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					   NFT_DATA_VALUE, priv->len);
++>>>>>>> 27e6d2017abd (netfilter: nf_tables: kill nft_validate_output_register())
  }
  
  static int nft_byteorder_dump(struct sk_buff *skb, const struct nft_expr *expr)
diff --cc net/netfilter/nft_ct.c
index 18d520e0ca0a,d85f9ad921f2..000000000000
--- a/net/netfilter/nft_ct.c
+++ b/net/netfilter/nft_ct.c
@@@ -274,11 -307,8 +274,16 @@@ static int nft_ct_get_init(const struc
  	}
  
  	priv->dreg = ntohl(nla_get_be32(tb[NFTA_CT_DREG]));
++<<<<<<< HEAD
 +	err = nft_validate_output_register(priv->dreg);
 +	if (err < 0)
 +		return err;
 +
 +	err = nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
++=======
+ 	err = nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					  NFT_DATA_VALUE, len);
++>>>>>>> 27e6d2017abd (netfilter: nf_tables: kill nft_validate_output_register())
  	if (err < 0)
  		return err;
  
diff --cc net/netfilter/nft_exthdr.c
index 55c939f5371f,8c4981cd813b..000000000000
--- a/net/netfilter/nft_exthdr.c
+++ b/net/netfilter/nft_exthdr.c
@@@ -69,15 -68,10 +68,22 @@@ static int nft_exthdr_init(const struc
  	priv->type   = nla_get_u8(tb[NFTA_EXTHDR_TYPE]);
  	priv->offset = ntohl(nla_get_be32(tb[NFTA_EXTHDR_OFFSET]));
  	priv->len    = ntohl(nla_get_be32(tb[NFTA_EXTHDR_LEN]));
++<<<<<<< HEAD
 +	if (priv->len == 0 ||
 +	    priv->len > FIELD_SIZEOF(struct nft_data, data))
 +		return -EINVAL;
 +
 +	priv->dreg = ntohl(nla_get_be32(tb[NFTA_EXTHDR_DREG]));
 +	err = nft_validate_output_register(priv->dreg);
 +	if (err < 0)
 +		return err;
 +	return nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
++=======
+ 	priv->dreg   = ntohl(nla_get_be32(tb[NFTA_EXTHDR_DREG]));
+ 
+ 	return nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					   NFT_DATA_VALUE, priv->len);
++>>>>>>> 27e6d2017abd (netfilter: nf_tables: kill nft_validate_output_register())
  }
  
  static int nft_exthdr_dump(struct sk_buff *skb, const struct nft_expr *expr)
diff --cc net/netfilter/nft_immediate.c
index 810385eb7249,a164c04df9fa..000000000000
--- a/net/netfilter/nft_immediate.c
+++ b/net/netfilter/nft_immediate.c
@@@ -59,7 -54,9 +54,13 @@@ static int nft_immediate_init(const str
  		return err;
  	priv->dlen = desc.len;
  
++<<<<<<< HEAD
 +	err = nft_validate_data_load(ctx, priv->dreg, &priv->data, desc.type);
++=======
+ 	priv->dreg = ntohl(nla_get_be32(tb[NFTA_IMMEDIATE_DREG]));
+ 	err = nft_validate_register_store(ctx, priv->dreg, &priv->data,
+ 					  desc.type, desc.len);
++>>>>>>> 27e6d2017abd (netfilter: nf_tables: kill nft_validate_output_register())
  	if (err < 0)
  		goto err1;
  
diff --cc net/netfilter/nft_lookup.c
index f8e400a6b239,3574543475c2..000000000000
--- a/net/netfilter/nft_lookup.c
+++ b/net/netfilter/nft_lookup.c
@@@ -76,15 -80,10 +76,22 @@@ static int nft_lookup_init(const struc
  			return -EINVAL;
  
  		priv->dreg = ntohl(nla_get_be32(tb[NFTA_LOOKUP_DREG]));
++<<<<<<< HEAD
 +		err = nft_validate_output_register(priv->dreg);
 +		if (err < 0)
 +			return err;
 +
 +		if (priv->dreg == NFT_REG_VERDICT) {
 +			if (set->dtype != NFT_DATA_VERDICT)
 +				return -EINVAL;
 +		} else if (set->dtype == NFT_DATA_VERDICT)
 +			return -EINVAL;
++=======
+ 		err = nft_validate_register_store(ctx, priv->dreg, NULL,
+ 						  set->dtype, set->dlen);
+ 		if (err < 0)
+ 			return err;
++>>>>>>> 27e6d2017abd (netfilter: nf_tables: kill nft_validate_output_register())
  	} else if (set->flags & NFT_SET_MAP)
  		return -EINVAL;
  
diff --cc net/netfilter/nft_meta.c
index a4cdc254de57,fbaee1d373bb..000000000000
--- a/net/netfilter/nft_meta.c
+++ b/net/netfilter/nft_meta.c
@@@ -217,7 -217,7 +217,11 @@@ int nft_meta_get_init(const struct nft_
  		      const struct nlattr * const tb[])
  {
  	struct nft_meta *priv = nft_expr_priv(expr);
++<<<<<<< HEAD
 +	int err;
++=======
+ 	unsigned int len;
++>>>>>>> 27e6d2017abd (netfilter: nf_tables: kill nft_validate_output_register())
  
  	priv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));
  	switch (priv->key) {
@@@ -252,15 -257,8 +256,20 @@@
  	}
  
  	priv->dreg = ntohl(nla_get_be32(tb[NFTA_META_DREG]));
++<<<<<<< HEAD
 +	err = nft_validate_output_register(priv->dreg);
 +	if (err < 0)
 +		return err;
 +
 +	err = nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
 +	if (err < 0)
 +		return err;
 +
 +	return 0;
++=======
+ 	return nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					   NFT_DATA_VALUE, len);
++>>>>>>> 27e6d2017abd (netfilter: nf_tables: kill nft_validate_output_register())
  }
  EXPORT_SYMBOL_GPL(nft_meta_get_init);
  
diff --cc net/netfilter/nft_payload.c
index 85daa84bfdfe,b2a9ef9d3df5..000000000000
--- a/net/netfilter/nft_payload.c
+++ b/net/netfilter/nft_payload.c
@@@ -67,12 -66,10 +66,18 @@@ static int nft_payload_init(const struc
  	priv->base   = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE]));
  	priv->offset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET]));
  	priv->len    = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN]));
+ 	priv->dreg   = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_DREG]));
  
++<<<<<<< HEAD
 +	priv->dreg = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_DREG]));
 +	err = nft_validate_output_register(priv->dreg);
 +	if (err < 0)
 +		return err;
 +	return nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
++=======
+ 	return nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					   NFT_DATA_VALUE, priv->len);
++>>>>>>> 27e6d2017abd (netfilter: nf_tables: kill nft_validate_output_register())
  }
  
  static int nft_payload_dump(struct sk_buff *skb, const struct nft_expr *expr)
* Unmerged path include/net/netfilter/nf_tables.h
* Unmerged path net/bridge/netfilter/nft_meta_bridge.c
* Unmerged path net/netfilter/nf_tables_api.c
* Unmerged path net/netfilter/nft_bitwise.c
* Unmerged path net/netfilter/nft_byteorder.c
* Unmerged path net/netfilter/nft_ct.c
* Unmerged path net/netfilter/nft_exthdr.c
* Unmerged path net/netfilter/nft_immediate.c
* Unmerged path net/netfilter/nft_lookup.c
* Unmerged path net/netfilter/nft_meta.c
* Unmerged path net/netfilter/nft_payload.c
