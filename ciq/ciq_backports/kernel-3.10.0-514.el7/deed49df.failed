route: check and remove route cache when we get route

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit deed49df7390d5239024199e249190328f1651e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/deed49df.failed

Since the gc of ipv4 route was removed, the route cached would has
no chance to be removed, and even it has been timeout, it still could
be used, cause no code to check it's expires.

Fix this issue by checking  and removing route cache when we get route.

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit deed49df7390d5239024199e249190328f1651e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/route.c
diff --cc net/ipv4/route.c
index bc344977f369,02c62299d717..000000000000
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@@ -1567,11 -1640,20 +1598,24 @@@ static int __mkroute_input(struct sk_bu
  
  	fnhe = find_exception(&FIB_RES_NH(*res), daddr);
  	if (do_cache) {
++<<<<<<< HEAD
 +		if (fnhe != NULL)
++=======
+ 		if (fnhe) {
++>>>>>>> deed49df7390 (route: check and remove route cache when we get route)
  			rth = rcu_dereference(fnhe->fnhe_rth_input);
- 		else
- 			rth = rcu_dereference(FIB_RES_NH(*res).nh_rth_input);
+ 			if (rth && rth->dst.expires &&
+ 			    time_after(jiffies, rth->dst.expires)) {
+ 				ip_del_fnhe(&FIB_RES_NH(*res), daddr);
+ 				fnhe = NULL;
+ 			} else {
+ 				goto rt_cache;
+ 			}
+ 		}
+ 
+ 		rth = rcu_dereference(FIB_RES_NH(*res).nh_rth_input);
  
+ rt_cache:
  		if (rt_cache_valid(rth)) {
  			skb_dst_set_noref(skb, &rth->dst);
  			goto out;
@@@ -1917,19 -2054,29 +1961,33 @@@ static struct rtable *__mkroute_output(
  		struct fib_nh *nh = &FIB_RES_NH(*res);
  
  		fnhe = find_exception(nh, fl4->daddr);
- 		if (fnhe)
+ 		if (fnhe) {
  			prth = &fnhe->fnhe_rth_output;
- 		else {
- 			if (unlikely(fl4->flowi4_flags &
- 				     FLOWI_FLAG_KNOWN_NH &&
- 				     !(nh->nh_gw &&
- 				       nh->nh_scope == RT_SCOPE_LINK))) {
- 				do_cache = false;
- 				goto add;
+ 			rth = rcu_dereference(*prth);
+ 			if (rth && rth->dst.expires &&
+ 			    time_after(jiffies, rth->dst.expires)) {
+ 				ip_del_fnhe(nh, fl4->daddr);
+ 				fnhe = NULL;
+ 			} else {
+ 				goto rt_cache;
  			}
++<<<<<<< HEAD
 +			prth = __this_cpu_ptr(nh->nh_pcpu_rth_output);
++=======
++>>>>>>> deed49df7390 (route: check and remove route cache when we get route)
+ 		}
+ 
+ 		if (unlikely(fl4->flowi4_flags &
+ 			     FLOWI_FLAG_KNOWN_NH &&
+ 			     !(nh->nh_gw &&
+ 			       nh->nh_scope == RT_SCOPE_LINK))) {
+ 			do_cache = false;
+ 			goto add;
  		}
+ 		prth = raw_cpu_ptr(nh->nh_pcpu_rth_output);
  		rth = rcu_dereference(*prth);
+ 
+ rt_cache:
  		if (rt_cache_valid(rth)) {
  			dst_hold(&rth->dst);
  			return rth;
diff --git a/include/net/ip_fib.h b/include/net/ip_fib.h
index 8aa6f829293d..9b9360a4f1d8 100644
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@ -59,6 +59,7 @@ struct fib_nh_exception {
 	struct rtable __rcu		*fnhe_rth_input;
 	struct rtable __rcu		*fnhe_rth_output;
 	unsigned long			fnhe_stamp;
+	struct rcu_head			rcu;
 };
 
 struct fnhe_hash_bucket {
* Unmerged path net/ipv4/route.c
