net/ethtool: support get coalesce per queue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] ethtool: support get coalesce per queue (Ivan Vecera) [1268334]
Rebuild_FUZZ: 95.12%
commit-author Kan Liang <kan.liang@intel.com>
commit 421797b1aa363cb897f29f7d365e068dc9d9db81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/421797b1.failed

This patch implements sub command ETHTOOL_GCOALESCE for ioctl
ETHTOOL_PERQUEUE. It introduces an interface get_per_queue_coalesce to
get coalesce of each masked queue from device driver. Then the interrupt
coalescing parameters will be copied back to user space one by one.

	Signed-off-by: Kan Liang <kan.liang@intel.com>
	Reviewed-by: Ben Hutchings <ben@decadent.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 421797b1aa363cb897f29f7d365e068dc9d9db81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/ethtool.h
#	net/core/ethtool.c
diff --cc include/linux/ethtool.h
index cdb20fccb517,de56600023a7..000000000000
--- a/include/linux/ethtool.h
+++ b/include/linux/ethtool.h
@@@ -281,32 -284,8 +286,38 @@@ struct ethtool_ops 
  			       const struct ethtool_tunable *, void *);
  	int	(*set_tunable)(struct net_device *,
  			       const struct ethtool_tunable *, const void *);
++<<<<<<< HEAD
 +
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_USE_P(1, u32	(*get_rxfh_key_size)(struct net_device *))
 +	RH_KABI_USE_P(2, int	(*get_rxfh)(struct net_device *, u32 *indir,
 +					    u8 *key, u8 *hfunc))
 +	RH_KABI_USE_P(3, int	(*set_rxfh)(struct net_device *,
 +					    const u32 *indir, const u8 *key,
 +					    const u8 hfunc))
 +	RH_KABI_RESERVE_P(4)
 +	RH_KABI_RESERVE_P(5)
 +	RH_KABI_RESERVE_P(6)
 +	RH_KABI_RESERVE_P(7)
 +	RH_KABI_RESERVE_P(8)
 +	RH_KABI_RESERVE_P(9)
 +	RH_KABI_RESERVE_P(10)
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_RESERVE_P(16)
++=======
+ 	int	(*get_per_queue_coalesce)(struct net_device *, u32,
+ 					  struct ethtool_coalesce *);
+ 
++>>>>>>> 421797b1aa36 (net/ethtool: support get coalesce per queue)
  };
  #endif /* _LINUX_ETHTOOL_H */
diff --cc net/core/ethtool.c
index 1ed11f1c82d9,2a6c3a26f63f..000000000000
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@@ -1731,6 -1888,53 +1731,56 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int ethtool_get_per_queue_coalesce(struct net_device *dev,
+ 					  void __user *useraddr,
+ 					  struct ethtool_per_queue_op *per_queue_opt)
+ {
+ 	u32 bit;
+ 	int ret;
+ 	DECLARE_BITMAP(queue_mask, MAX_NUM_QUEUE);
+ 
+ 	if (!dev->ethtool_ops->get_per_queue_coalesce)
+ 		return -EOPNOTSUPP;
+ 
+ 	useraddr += sizeof(*per_queue_opt);
+ 
+ 	bitmap_from_u32array(queue_mask,
+ 			     MAX_NUM_QUEUE,
+ 			     per_queue_opt->queue_mask,
+ 			     DIV_ROUND_UP(MAX_NUM_QUEUE, 32));
+ 
+ 	for_each_set_bit(bit, queue_mask, MAX_NUM_QUEUE) {
+ 		struct ethtool_coalesce coalesce = { .cmd = ETHTOOL_GCOALESCE };
+ 
+ 		ret = dev->ethtool_ops->get_per_queue_coalesce(dev, bit, &coalesce);
+ 		if (ret != 0)
+ 			return ret;
+ 		if (copy_to_user(useraddr, &coalesce, sizeof(coalesce)))
+ 			return -EFAULT;
+ 		useraddr += sizeof(coalesce);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int ethtool_set_per_queue(struct net_device *dev, void __user *useraddr)
+ {
+ 	struct ethtool_per_queue_op per_queue_opt;
+ 
+ 	if (copy_from_user(&per_queue_opt, useraddr, sizeof(per_queue_opt)))
+ 		return -EFAULT;
+ 
+ 	switch (per_queue_opt.sub_command) {
+ 	case ETHTOOL_GCOALESCE:
+ 		return ethtool_get_per_queue_coalesce(dev, useraddr, &per_queue_opt);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	};
+ }
+ 
++>>>>>>> 421797b1aa36 (net/ethtool: support get coalesce per queue)
  /* The main entry point in this file.  Called from net/core/dev_ioctl.c */
  
  int dev_ethtool(struct net *net, struct ifreq *ifr)
* Unmerged path include/linux/ethtool.h
* Unmerged path net/core/ethtool.c
