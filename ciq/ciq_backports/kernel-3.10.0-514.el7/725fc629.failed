kernek/fork.c: allocate idle task for a CPU always on its local node

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [kernel] fork: allocate idle task for a CPU always on its local node (Oleg Nesterov) [1339635]
Rebuild_FUZZ: 92.91%
commit-author Andi Kleen <ak@linux.intel.com>
commit 725fc629ff2545b061407305ae51016c9f928fce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/725fc629.failed

Linux preallocates the task structs of the idle tasks for all possible
CPUs.  This currently means they all end up on node 0.  This also
implies that the cache line of MWAIT, which is around the flags field in
the task struct, are all located in node 0.

We see a noticeable performance improvement on Knights Landing CPUs when
the cache lines used for MWAIT are located in the local nodes of the
CPUs using them.  I would expect this to give a (likely slight)
improvement on other systems too.

The patch implements placing the idle task in the node of its CPUs, by
passing the right target node to copy_process()

[akpm@linux-foundation.org: use NUMA_NO_NODE, not a bare -1]
Link: http://lkml.kernel.org/r/1463492694-15833-1-git-send-email-andi@firstfloor.org
	Signed-off-by: Andi Kleen <ak@linux.intel.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 725fc629ff2545b061407305ae51016c9f928fce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/fork.c
diff --cc kernel/fork.c
index a14b2bbebc6a,e67d7b773348..000000000000
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@@ -290,14 -332,22 +290,31 @@@ int __attribute__((weak)) arch_dup_task
  	return 0;
  }
  
++<<<<<<< HEAD
 +static struct task_struct *dup_task_struct(struct task_struct *orig)
 +{
 +	struct task_struct *tsk;
 +	struct thread_info *ti;
 +	unsigned long *stackend;
 +	int node = tsk_fork_get_node(orig);
++=======
+ void set_task_stack_end_magic(struct task_struct *tsk)
+ {
+ 	unsigned long *stackend;
+ 
+ 	stackend = end_of_stack(tsk);
+ 	*stackend = STACK_END_MAGIC;	/* for overflow detection */
+ }
+ 
+ static struct task_struct *dup_task_struct(struct task_struct *orig, int node)
+ {
+ 	struct task_struct *tsk;
+ 	struct thread_info *ti;
++>>>>>>> 725fc629ff25 (kernek/fork.c: allocate idle task for a CPU always on its local node)
  	int err;
  
+ 	if (node == NUMA_NO_NODE)
+ 		node = tsk_fork_get_node(orig);
  	tsk = alloc_task_struct_node(node);
  	if (!tsk)
  		return NULL;
@@@ -1150,7 -1276,9 +1167,13 @@@ static struct task_struct *copy_process
  					unsigned long stack_size,
  					int __user *child_tidptr,
  					struct pid *pid,
++<<<<<<< HEAD
 +					int trace)
++=======
+ 					int trace,
+ 					unsigned long tls,
+ 					int node)
++>>>>>>> 725fc629ff25 (kernek/fork.c: allocate idle task for a CPU always on its local node)
  {
  	int retval;
  	struct task_struct *p;
@@@ -1570,7 -1708,8 +1593,12 @@@ static inline void init_idle_pids(struc
  struct task_struct *fork_idle(int cpu)
  {
  	struct task_struct *task;
++<<<<<<< HEAD
 +	task = copy_process(CLONE_VM, 0, 0, NULL, &init_struct_pid, 0);
++=======
+ 	task = copy_process(CLONE_VM, 0, 0, NULL, &init_struct_pid, 0, 0,
+ 			    cpu_to_node(cpu));
++>>>>>>> 725fc629ff25 (kernek/fork.c: allocate idle task for a CPU always on its local node)
  	if (!IS_ERR(task)) {
  		init_idle_pids(task->pids);
  		init_idle(task, cpu);
@@@ -1614,7 -1754,7 +1642,11 @@@ long do_fork(unsigned long clone_flags
  	}
  
  	p = copy_process(clone_flags, stack_start, stack_size,
++<<<<<<< HEAD
 +			 child_tidptr, NULL, trace);
++=======
+ 			 child_tidptr, NULL, trace, tls, NUMA_NO_NODE);
++>>>>>>> 725fc629ff25 (kernek/fork.c: allocate idle task for a CPU always on its local node)
  	/*
  	 * Do this prior waking up the new thread - the thread pointer
  	 * might get invalid after that point, if the thread exits quickly.
* Unmerged path kernel/fork.c
