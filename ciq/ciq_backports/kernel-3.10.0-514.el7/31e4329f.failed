pinctrl: baytrail: Rework interrupt handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [pinctrl] baytrail: Rework interrupt handling (Prarit Bhargava) [1339663]
Rebuild_FUZZ: 88.61%
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 31e4329f99062a06dca5a493bb4495a63b2dc6ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/31e4329f.failed

Instead of handling everything in the driver's first level interrupt
handler, we can take advantage of already existing flow handlers that are
provided by the IRQ core.

This changes the functionality a bit also. Previously the driver looped
over pending interrupts in a single loop, restarting the loop if some
interrupt changed state. This caused problem with Lenovo Thinkpad 10
digitizer that it was not able to deassert the interrupt before the driver
disabled the interrupt for good (looplimit was exhausted).

Rework the interrupt handling logic a bit so that we provide proper mask,
ack and unmask operations in terms of Baytrail GPIO hardware and loop over
pending interrupts only once. If the interrupt remains asserted the first
level handler will be re-triggered automatically.

	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 31e4329f99062a06dca5a493bb4495a63b2dc6ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pinctrl/pinctrl-baytrail.c
diff --cc drivers/pinctrl/pinctrl-baytrail.c
index 409727cd72ed,2318057a309b..000000000000
--- a/drivers/pinctrl/pinctrl-baytrail.c
+++ b/drivers/pinctrl/pinctrl-baytrail.c
@@@ -250,25 -246,19 +250,15 @@@ static int byt_irq_type(struct irq_dat
  	/* For level trigges the BYT_TRIG_POS and BYT_TRIG_NEG bits
  	 * are used to indicate high and low level triggering
  	 */
 -	value &= ~(BYT_DIRECT_IRQ_EN | BYT_TRIG_POS | BYT_TRIG_NEG |
 -		   BYT_TRIG_LVL);
 +	value &= ~(BYT_TRIG_POS | BYT_TRIG_NEG | BYT_TRIG_LVL);
  
- 	switch (type) {
- 	case IRQ_TYPE_LEVEL_HIGH:
- 		value |= BYT_TRIG_LVL;
- 	case IRQ_TYPE_EDGE_RISING:
- 		value |= BYT_TRIG_POS;
- 		break;
- 	case IRQ_TYPE_LEVEL_LOW:
- 		value |= BYT_TRIG_LVL;
- 	case IRQ_TYPE_EDGE_FALLING:
- 		value |= BYT_TRIG_NEG;
- 		break;
- 	case IRQ_TYPE_EDGE_BOTH:
- 		value |= (BYT_TRIG_NEG | BYT_TRIG_POS);
- 		break;
- 	}
  	writel(value, reg);
  
+ 	if (type & IRQ_TYPE_EDGE_BOTH)
+ 		__irq_set_handler_locked(d->irq, handle_edge_irq);
+ 	else if (type & IRQ_TYPE_LEVEL_MASK)
+ 		__irq_set_handler_locked(d->irq, handle_level_irq);
+ 
  	spin_unlock_irqrestore(&vg->lock, flags);
  
  	return 0;
@@@ -430,45 -414,20 +420,31 @@@ static int byt_gpio_to_irq(struct gpio_
  static void byt_gpio_irq_handler(unsigned irq, struct irq_desc *desc)
  {
  	struct irq_data *data = irq_desc_get_irq_data(desc);
 -	struct byt_gpio *vg = to_byt_gpio(irq_desc_get_handler_data(desc));
 +	struct byt_gpio *vg = irq_data_get_irq_handler_data(data);
  	struct irq_chip *chip = irq_data_get_irq_chip(data);
- 	u32 base, pin, mask;
+ 	u32 base, pin;
  	void __iomem *reg;
- 	u32 pending;
+ 	unsigned long pending;
  	unsigned virq;
- 	int looplimit = 0;
  
  	/* check from GPIO controller which pin triggered the interrupt */
  	for (base = 0; base < vg->chip.ngpio; base += 32) {
- 
  		reg = byt_gpio_reg(&vg->chip, base, BYT_INT_STAT_REG);
++<<<<<<< HEAD:drivers/pinctrl/pinctrl-baytrail.c
 +
 +		while ((pending = readl(reg))) {
 +			pin = __ffs(pending);
 +			mask = BIT(pin);
 +			/* Clear before handling so we can't lose an edge */
 +			writel(mask, reg);
 +
 +			virq = irq_find_mapping(vg->domain, base + pin);
++=======
+ 		pending = readl(reg);
+ 		for_each_set_bit(pin, &pending, 32) {
+ 			virq = irq_find_mapping(vg->chip.irqdomain, base + pin);
++>>>>>>> 31e4329f9906 (pinctrl: baytrail: Rework interrupt handling):drivers/pinctrl/intel/pinctrl-baytrail.c
  			generic_handle_irq(virq);
- 
- 			/* In case bios or user sets triggering incorretly a pin
- 			 * might remain in "interrupt triggered" state.
- 			 */
- 			if (looplimit++ > 32) {
- 				dev_err(&vg->pdev->dev,
- 					"Gpio %d interrupt flood, disabling\n",
- 					base + pin);
- 
- 				reg = byt_gpio_reg(&vg->chip, base + pin,
- 						   BYT_CONF0_REG);
- 				mask = readl(reg);
- 				mask &= ~(BYT_TRIG_NEG | BYT_TRIG_POS |
- 					  BYT_TRIG_LVL);
- 				writel(mask, reg);
- 				mask = readl(reg); /* flush */
- 				break;
- 			}
  		}
  	}
  	chip->irq_eoi(data);
@@@ -480,30 -481,15 +498,35 @@@ static void byt_irq_unmask(struct irq_d
  
  static void byt_irq_mask(struct irq_data *d)
  {
+ 	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+ 	struct byt_gpio *vg = to_byt_gpio(gc);
+ 
+ 	byt_gpio_clear_triggering(vg, irqd_to_hwirq(d));
  }
  
 +static unsigned int byt_irq_startup(struct irq_data *d)
 +{
 +	struct byt_gpio *vg = irq_data_get_irq_chip_data(d);
 +
 +	if (gpio_lock_as_irq(&vg->chip, irqd_to_hwirq(d)))
 +		dev_err(vg->chip.dev,
 +			"unable to lock HW IRQ %lu for IRQ\n",
 +			irqd_to_hwirq(d));
 +	byt_irq_unmask(d);
 +	return 0;
 +}
 +
 +static void byt_irq_shutdown(struct irq_data *d)
 +{
 +	struct byt_gpio *vg = irq_data_get_irq_chip_data(d);
 +
 +	byt_irq_mask(d);
 +	gpio_unlock_as_irq(&vg->chip, irqd_to_hwirq(d));
 +}
 +
  static struct irq_chip byt_irqchip = {
  	.name = "BYT-GPIO",
+ 	.irq_ack = byt_irq_ack,
  	.irq_mask = byt_irq_mask,
  	.irq_unmask = byt_irq_unmask,
  	.irq_set_type = byt_irq_type,
* Unmerged path drivers/pinctrl/pinctrl-baytrail.c
