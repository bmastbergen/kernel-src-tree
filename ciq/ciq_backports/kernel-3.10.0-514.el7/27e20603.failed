PCI/MSI: Move D0 check into pci_msi_check_device()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [pci] msi: Move D0 check into pci_msi_check_device() (Myron Stowe) [1325402]
Rebuild_FUZZ: 95.83%
commit-author Alexander Gordeev <agordeev@redhat.com>
commit 27e20603c54ba633ed259284d006275f13c9f95b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/27e20603.failed

Both callers of pci_msi_check_device() check that the device is in D0
state, so move the check from the callers into pci_msi_check_device()
itself.

In pci_enable_msi_range(), note that pci_msi_check_device() never returns a
positive value any more, so the loop that called it until it returns zero
or negative is no longer necessary.

[bhelgaas: changelog, split to separate patch]
	Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 27e20603c54ba633ed259284d006275f13c9f95b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/msi.c
diff --cc drivers/pci/msi.c
index 35bd42459f55,338b027ea65f..000000000000
--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@@ -862,13 -805,15 +862,16 @@@ out_free
   * to determine if MSI/-X are supported for the device. If MSI/-X is
   * supported return 0, else return an error code.
   **/
 -static int pci_msi_check_device(struct pci_dev *dev, int nvec)
 +static int pci_msi_check_device(struct pci_dev *dev, int nvec, int type)
  {
  	struct pci_bus *bus;
 +	int ret;
  
  	/* MSI must be globally enabled and supported by the device */
- 	if (!pci_msi_enable || !dev || dev->no_msi)
+ 	if (!pci_msi_enable)
+ 		return -EINVAL;
+ 
+ 	if (!dev || dev->no_msi || dev->current_state != PCI_D0)
  		return -EINVAL;
  
  	/*
@@@ -1040,10 -937,7 +1043,14 @@@ int pci_enable_msix(struct pci_dev *dev
  	int status, nr_entries;
  	int i, j;
  
++<<<<<<< HEAD
 +	if (!entries || !dev->msix_cap || dev->current_state != PCI_D0)
 +		return -EINVAL;
 +
 +	status = pci_msi_check_device(dev, nvec, PCI_CAP_ID_MSIX);
++=======
+ 	status = pci_msi_check_device(dev, nvec);
++>>>>>>> 27e20603c54b (PCI/MSI: Move D0 check into pci_msi_check_device())
  	if (status)
  		return status;
  
@@@ -1177,17 -1075,6 +1188,20 @@@ int pci_enable_msi_range(struct pci_de
  		nvec = maxvec;
  
  	do {
++<<<<<<< HEAD
 +		rc = pci_msi_check_device(dev, nvec, PCI_CAP_ID_MSI);
 +		if (rc < 0) {
 +			return rc;
 +		} else if (rc > 0) {
 +			if (rc < minvec)
 +				return -ENOSPC;
 +			nvec = rc;
 +		}
 +	} while (rc);
 +
 +	do {
++=======
++>>>>>>> 27e20603c54b (PCI/MSI: Move D0 check into pci_msi_check_device())
  		rc = msi_capability_init(dev, nvec);
  		if (rc < 0) {
  			return rc;
* Unmerged path drivers/pci/msi.c
