mei: remove check on pm_runtime_active in __mei_cl_disconnect

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit eead035a35b59df9f956139cb2c73141751a246e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/eead035a.failed

Remove bogus check on pm_runtime_active that prevented
disconnection from a client in case the device was resuming
from power gating but not yet active.

Fix regression introduced by
18901357e70ae29e3fd1c58712a6847c2ae52eae
mei: disconnect on connection request timeout

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit eead035a35b59df9f956139cb2c73141751a246e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/client.c
diff --cc drivers/misc/mei/client.c
index 3c539de435ba,a6c87c713193..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -448,6 -726,173 +448,176 @@@ bool mei_hbuf_acquire(struct mei_devic
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mei_cl_set_disconnected - set disconnected state and clear
+  *   associated states and resources
+  *
+  * @cl: host client
+  */
+ void mei_cl_set_disconnected(struct mei_cl *cl)
+ {
+ 	struct mei_device *dev = cl->dev;
+ 
+ 	if (cl->state == MEI_FILE_DISCONNECTED ||
+ 	    cl->state == MEI_FILE_INITIALIZING)
+ 		return;
+ 
+ 	cl->state = MEI_FILE_DISCONNECTED;
+ 	mei_io_list_flush(&dev->ctrl_rd_list, cl);
+ 	mei_io_list_flush(&dev->ctrl_wr_list, cl);
+ 	cl->mei_flow_ctrl_creds = 0;
+ 	cl->timer_count = 0;
+ 
+ 	if (!cl->me_cl)
+ 		return;
+ 
+ 	if (!WARN_ON(cl->me_cl->connect_count == 0))
+ 		cl->me_cl->connect_count--;
+ 
+ 	if (cl->me_cl->connect_count == 0)
+ 		cl->me_cl->mei_flow_ctrl_creds = 0;
+ 
+ 	mei_me_cl_put(cl->me_cl);
+ 	cl->me_cl = NULL;
+ }
+ 
+ static int mei_cl_set_connecting(struct mei_cl *cl, struct mei_me_client *me_cl)
+ {
+ 	if (!mei_me_cl_get(me_cl))
+ 		return -ENOENT;
+ 
+ 	/* only one connection is allowed for fixed address clients */
+ 	if (me_cl->props.fixed_address) {
+ 		if (me_cl->connect_count) {
+ 			mei_me_cl_put(me_cl);
+ 			return -EBUSY;
+ 		}
+ 	}
+ 
+ 	cl->me_cl = me_cl;
+ 	cl->state = MEI_FILE_CONNECTING;
+ 	cl->me_cl->connect_count++;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * mei_cl_send_disconnect - send disconnect request
+  *
+  * @cl: host client
+  * @cb: callback block
+  *
+  * Return: 0, OK; otherwise, error.
+  */
+ static int mei_cl_send_disconnect(struct mei_cl *cl, struct mei_cl_cb *cb)
+ {
+ 	struct mei_device *dev;
+ 	int ret;
+ 
+ 	dev = cl->dev;
+ 
+ 	ret = mei_hbm_cl_disconnect_req(dev, cl);
+ 	cl->status = ret;
+ 	if (ret) {
+ 		cl->state = MEI_FILE_DISCONNECT_REPLY;
+ 		return ret;
+ 	}
+ 
+ 	list_move_tail(&cb->list, &dev->ctrl_rd_list.list);
+ 	cl->timer_count = MEI_CONNECT_TIMEOUT;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * mei_cl_irq_disconnect - processes close related operation from
+  *	interrupt thread context - send disconnect request
+  *
+  * @cl: client
+  * @cb: callback block.
+  * @cmpl_list: complete list.
+  *
+  * Return: 0, OK; otherwise, error.
+  */
+ int mei_cl_irq_disconnect(struct mei_cl *cl, struct mei_cl_cb *cb,
+ 			    struct mei_cl_cb *cmpl_list)
+ {
+ 	struct mei_device *dev = cl->dev;
+ 	u32 msg_slots;
+ 	int slots;
+ 	int ret;
+ 
+ 	msg_slots = mei_data2slots(sizeof(struct hbm_client_connect_request));
+ 	slots = mei_hbuf_empty_slots(dev);
+ 
+ 	if (slots < msg_slots)
+ 		return -EMSGSIZE;
+ 
+ 	ret = mei_cl_send_disconnect(cl, cb);
+ 	if (ret)
+ 		list_move_tail(&cb->list, &cmpl_list->list);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * __mei_cl_disconnect - disconnect host client from the me one
+  *     internal function runtime pm has to be already acquired
+  *
+  * @cl: host client
+  *
+  * Return: 0 on success, <0 on failure.
+  */
+ static int __mei_cl_disconnect(struct mei_cl *cl)
+ {
+ 	struct mei_device *dev;
+ 	struct mei_cl_cb *cb;
+ 	int rets;
+ 
+ 	dev = cl->dev;
+ 
+ 	cl->state = MEI_FILE_DISCONNECTING;
+ 
+ 	cb = mei_io_cb_init(cl, MEI_FOP_DISCONNECT, NULL);
+ 	rets = cb ? 0 : -ENOMEM;
+ 	if (rets)
+ 		goto out;
+ 
+ 	cl_dbg(dev, cl, "add disconnect cb to control write list\n");
+ 	list_add_tail(&cb->list, &dev->ctrl_wr_list.list);
+ 
+ 	if (mei_hbuf_acquire(dev)) {
+ 		rets = mei_cl_send_disconnect(cl, cb);
+ 		if (rets) {
+ 			cl_err(dev, cl, "failed to disconnect.\n");
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 	wait_event_timeout(cl->wait, cl->state == MEI_FILE_DISCONNECT_REPLY,
+ 			   mei_secs_to_jiffies(MEI_CL_CONNECT_TIMEOUT));
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	rets = cl->status;
+ 	if (cl->state != MEI_FILE_DISCONNECT_REPLY) {
+ 		cl_dbg(dev, cl, "timeout on disconnect from FW client.\n");
+ 		rets = -ETIME;
+ 	}
+ 
+ out:
+ 	/* we disconnect also on error */
+ 	mei_cl_set_disconnected(cl);
+ 	if (!rets)
+ 		cl_dbg(dev, cl, "successfully disconnected from FW client.\n");
+ 
+ 	mei_io_cb_free(cb);
+ 	return rets;
+ }
+ 
+ /**
++>>>>>>> eead035a35b5 (mei: remove check on pm_runtime_active in __mei_cl_disconnect)
   * mei_cl_disconnect - disconnect host client from the me one
   *
   * @cl: host client
* Unmerged path drivers/misc/mei/client.c
