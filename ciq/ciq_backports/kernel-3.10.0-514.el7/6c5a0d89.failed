NFSv4.2: LAYOUTSTATS is optional to implement

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 6c5a0d891543873aefc3aaf846c1e7afe0982ff9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6c5a0d89.failed

Make it so, by checking the return value for NFS4ERR_MOTSUPP and
caching the information as a server capability.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 6c5a0d891543873aefc3aaf846c1e7afe0982ff9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs42proc.c
#	fs/nfs/pnfs.c
diff --cc fs/nfs/nfs42proc.c
index 0899db096637,f486b80f927a..000000000000
--- a/fs/nfs/nfs42proc.c
+++ b/fs/nfs/nfs42proc.c
@@@ -166,20 -171,84 +166,97 @@@ static loff_t _nfs42_proc_llseek(struc
  	return vfs_setpos(filep, res.sr_offset, inode->i_sb->s_maxbytes);
  }
  
 -static void
 -nfs42_layoutstat_prepare(struct rpc_task *task, void *calldata)
 +loff_t nfs42_proc_llseek(struct file *filep, loff_t offset, int whence)
  {
 -	struct nfs42_layoutstat_data *data = calldata;
 -	struct nfs_server *server = NFS_SERVER(data->args.inode);
 +	struct nfs_server *server = NFS_SERVER(file_inode(filep));
 +	struct nfs4_exception exception = { };
 +	loff_t err;
  
++<<<<<<< HEAD
 +	do {
 +		err = _nfs42_proc_llseek(filep, offset, whence);
 +		if (err >= 0)
 +			break;
 +		if (err == -ENOTSUPP)
 +			return -EOPNOTSUPP;
 +		err = nfs4_handle_exception(server, err, &exception);
 +	} while (exception.retry);
 +
 +	return err;
++=======
+ 	nfs41_setup_sequence(nfs4_get_session(server), &data->args.seq_args,
+ 			     &data->res.seq_res, task);
+ }
+ 
+ static void
+ nfs42_layoutstat_done(struct rpc_task *task, void *calldata)
+ {
+ 	struct nfs42_layoutstat_data *data = calldata;
+ 
+ 	if (!nfs4_sequence_done(task, &data->res.seq_res))
+ 		return;
+ 
+ 	switch (task->tk_status) {
+ 	case 0:
+ 		break;
+ 	case -ENOTSUPP:
+ 	case -EOPNOTSUPP:
+ 		NFS_SERVER(data->inode)->caps &= ~NFS_CAP_LAYOUTSTATS;
+ 	default:
+ 		dprintk("%s server returns %d\n", __func__, task->tk_status);
+ 	}
+ }
+ 
+ static void
+ nfs42_layoutstat_release(void *calldata)
+ {
+ 	struct nfs42_layoutstat_data *data = calldata;
+ 	struct nfs_server *nfss = NFS_SERVER(data->args.inode);
+ 
+ 	if (nfss->pnfs_curr_ld->cleanup_layoutstats)
+ 		nfss->pnfs_curr_ld->cleanup_layoutstats(data);
+ 
+ 	pnfs_put_layout_hdr(NFS_I(data->args.inode)->layout);
+ 	smp_mb__before_atomic();
+ 	clear_bit(NFS_INO_LAYOUTSTATS, &NFS_I(data->args.inode)->flags);
+ 	smp_mb__after_atomic();
+ 	nfs_iput_and_deactive(data->inode);
+ 	kfree(data->args.devinfo);
+ 	kfree(data);
+ }
+ 
+ static const struct rpc_call_ops nfs42_layoutstat_ops = {
+ 	.rpc_call_prepare = nfs42_layoutstat_prepare,
+ 	.rpc_call_done = nfs42_layoutstat_done,
+ 	.rpc_release = nfs42_layoutstat_release,
+ };
+ 
+ int nfs42_proc_layoutstats_generic(struct nfs_server *server,
+ 				   struct nfs42_layoutstat_data *data)
+ {
+ 	struct rpc_message msg = {
+ 		.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTSTATS],
+ 		.rpc_argp = &data->args,
+ 		.rpc_resp = &data->res,
+ 	};
+ 	struct rpc_task_setup task_setup = {
+ 		.rpc_client = server->client,
+ 		.rpc_message = &msg,
+ 		.callback_ops = &nfs42_layoutstat_ops,
+ 		.callback_data = data,
+ 		.flags = RPC_TASK_ASYNC,
+ 	};
+ 	struct rpc_task *task;
+ 
+ 	data->inode = nfs_igrab_and_active(data->args.inode);
+ 	if (!data->inode) {
+ 		nfs42_layoutstat_release(data);
+ 		return -EAGAIN;
+ 	}
+ 	nfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 0);
+ 	task = rpc_run_task(&task_setup);
+ 	if (IS_ERR(task))
+ 		return PTR_ERR(task);
+ 	return 0;
++>>>>>>> 6c5a0d891543 (NFSv4.2: LAYOUTSTATS is optional to implement)
  }
diff --cc fs/nfs/pnfs.c
index e661b8a0925b,0ba9a02c9566..000000000000
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@@ -2236,3 -2251,63 +2236,66 @@@ struct nfs4_threshold *pnfs_mdsthreshol
  	}
  	return thp;
  }
++<<<<<<< HEAD
++=======
+ 
+ #if IS_ENABLED(CONFIG_NFS_V4_2)
+ int
+ pnfs_report_layoutstat(struct inode *inode)
+ {
+ 	struct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;
+ 	struct nfs_server *server = NFS_SERVER(inode);
+ 	struct nfs_inode *nfsi = NFS_I(inode);
+ 	struct nfs42_layoutstat_data *data;
+ 	struct pnfs_layout_hdr *hdr;
+ 	int status = 0;
+ 
+ 	if (!pnfs_enabled_sb(server) || !ld->prepare_layoutstats)
+ 		goto out;
+ 
+ 	if (!nfs_server_capable(inode, NFS_CAP_LAYOUTSTATS))
+ 		goto out;
+ 
+ 	if (test_and_set_bit(NFS_INO_LAYOUTSTATS, &nfsi->flags))
+ 		goto out;
+ 
+ 	spin_lock(&inode->i_lock);
+ 	if (!NFS_I(inode)->layout) {
+ 		spin_unlock(&inode->i_lock);
+ 		goto out;
+ 	}
+ 	hdr = NFS_I(inode)->layout;
+ 	pnfs_get_layout_hdr(hdr);
+ 	spin_unlock(&inode->i_lock);
+ 
+ 	data = kzalloc(sizeof(*data), GFP_KERNEL);
+ 	if (!data) {
+ 		status = -ENOMEM;
+ 		goto out_put;
+ 	}
+ 
+ 	data->args.fh = NFS_FH(inode);
+ 	data->args.inode = inode;
+ 	nfs4_stateid_copy(&data->args.stateid, &hdr->plh_stateid);
+ 	status = ld->prepare_layoutstats(&data->args);
+ 	if (status)
+ 		goto out_free;
+ 
+ 	status = nfs42_proc_layoutstats_generic(NFS_SERVER(inode), data);
+ 
+ out:
+ 	dprintk("%s returns %d\n", __func__, status);
+ 	return status;
+ 
+ out_free:
+ 	kfree(data);
+ out_put:
+ 	pnfs_put_layout_hdr(hdr);
+ 	smp_mb__before_atomic();
+ 	clear_bit(NFS_INO_LAYOUTSTATS, &nfsi->flags);
+ 	smp_mb__after_atomic();
+ 	goto out;
+ }
+ EXPORT_SYMBOL_GPL(pnfs_report_layoutstat);
+ #endif
++>>>>>>> 6c5a0d891543 (NFSv4.2: LAYOUTSTATS is optional to implement)
* Unmerged path fs/nfs/nfs42proc.c
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 84892e91f46e..7fd32ec9792f 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -8594,7 +8594,8 @@ static const struct nfs4_minor_version_ops nfs_v4_2_minor_ops = {
 		| NFS_CAP_ATOMIC_OPEN_V1
 		| NFS_CAP_ALLOCATE
 		| NFS_CAP_DEALLOCATE
-		| NFS_CAP_SEEK,
+		| NFS_CAP_SEEK
+		| NFS_CAP_LAYOUTSTATS,
 	.init_client = nfs41_init_client,
 	.shutdown_client = nfs41_shutdown_client,
 	.match_stateid = nfs41_match_stateid,
* Unmerged path fs/nfs/pnfs.c
diff --git a/include/linux/nfs_fs_sb.h b/include/linux/nfs_fs_sb.h
index 5e1273d4de14..a2ea1491d3df 100644
--- a/include/linux/nfs_fs_sb.h
+++ b/include/linux/nfs_fs_sb.h
@@ -237,5 +237,6 @@ struct nfs_server {
 #define NFS_CAP_SEEK		(1U << 19)
 #define NFS_CAP_ALLOCATE	(1U << 20)
 #define NFS_CAP_DEALLOCATE	(1U << 21)
+#define NFS_CAP_LAYOUTSTATS	(1U << 22)
 
 #endif
