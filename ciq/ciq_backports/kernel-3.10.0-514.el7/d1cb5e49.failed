mpt3sas: Refcount sas_device objects and fix unsafe list usage

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sreekanth Reddy <sreekanth.reddy@avagotech.com>
commit d1cb5e495e5384f6d90a8573f1be9cc79b85c862
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d1cb5e49.failed

sas_device objects can be referenced concurrently throughout the driver.
We need a way to make sure threads can't delete them out from under each
other. This patch adds the refcount and refactors the code to use it.

Additionally, we cannot iterate over the sas_device_list without holding
the lock or we risk corrupting random memory if items are added or
deleted as we iterate. This patch refactors _scsih_probe_sas() to use
the sas_device_list in a safe way.

This patch is ported from the following mpt2sas driver commit
d224fe0d6097 ("mpt2sas: Refcount sas_device objects and fix unsafe list
usage").

	Signed-off-by: Sreekanth Reddy <Sreekanth.Reddy@avagotech.com>
	Acked-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit d1cb5e495e5384f6d90a8573f1be9cc79b85c862)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpt3sas/mpt3sas_scsih.c
diff --cc drivers/scsi/mpt3sas/mpt3sas_scsih.c
index dab4affe7dc9,5dbf214ecf6d..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
@@@ -3020,8 -3084,12 +3135,12 @@@ _scsih_tm_tr_send(struct MPT3SAS_ADAPTE
  	mpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;
  	mpi_request->DevHandle = cpu_to_le16(handle);
  	mpi_request->TaskType = MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET;
 -	mpt3sas_base_put_smid_hi_priority(ioc, smid);
 +	mpt3sas_base_put_smid_hi_priority(ioc, smid, 0);
  	mpt3sas_trigger_master(ioc, MASTER_TRIGGER_DEVICE_REMOVAL);
+ 
+ out:
+ 	if (sas_device)
+ 		sas_device_put(sas_device);
  }
  
  /**
@@@ -6475,13 -6604,14 +6606,21 @@@ _scsih_sas_ir_physical_disk_event(struc
  	case MPI2_RAID_PD_STATE_OPTIMAL:
  	case MPI2_RAID_PD_STATE_HOT_SPARE:
  
++<<<<<<< HEAD
 +		set_bit(handle, ioc->pd_handles);
 +		spin_lock_irqsave(&ioc->sas_device_lock, flags);
 +		sas_device = _scsih_sas_device_find_by_handle(ioc, handle);
 +		spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
++=======
+ 		if (!ioc->is_warpdrive)
+ 			set_bit(handle, ioc->pd_handles);
++>>>>>>> d1cb5e495e53 (mpt3sas: Refcount sas_device objects and fix unsafe list usage)
  
- 		if (sas_device)
+ 		sas_device = mpt3sas_get_sdev_by_handle(ioc, handle);
+ 		if (sas_device) {
+ 			sas_device_put(sas_device);
  			return;
+ 		}
  
  		if ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply,
  		    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_HANDLE,
@@@ -7885,17 -8104,16 +8081,23 @@@ static void sas_device_make_active(stru
  static void
  _scsih_probe_sas(struct MPT3SAS_ADAPTER *ioc)
  {
- 	struct _sas_device *sas_device, *next;
- 	unsigned long flags;
+ 	struct _sas_device *sas_device;
  
++<<<<<<< HEAD
 +	/* SAS Device List */
 +	list_for_each_entry_safe(sas_device, next, &ioc->sas_device_init_list,
 +	    list) {
 +
++=======
+ 	if (ioc->hide_drives)
+ 		return;
+ 
+ 	while ((sas_device = get_next_sas_device(ioc))) {
++>>>>>>> d1cb5e495e53 (mpt3sas: Refcount sas_device objects and fix unsafe list usage)
  		if (!mpt3sas_transport_port_add(ioc, sas_device->handle,
  		    sas_device->sas_address_parent)) {
- 			list_del(&sas_device->list);
- 			kfree(sas_device);
+ 			_scsih_sas_device_remove(ioc, sas_device);
+ 			sas_device_put(sas_device);
  			continue;
  		} else if (!sas_device->starget) {
  			/*
diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.h b/drivers/scsi/mpt3sas/mpt3sas_base.h
index b65a550294a3..d2c3e214d4d7 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_base.h
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.h
@@ -248,6 +248,7 @@ struct Mpi2ManufacturingPage11_t {
  * @flags: MPT_TARGET_FLAGS_XXX flags
  * @deleted: target flaged for deletion
  * @tm_busy: target is busy with TM request.
+ * @sdev: The sas_device associated with this target
  */
 struct MPT3SAS_TARGET {
 	struct scsi_target *starget;
@@ -257,6 +258,7 @@ struct MPT3SAS_TARGET {
 	u32	flags;
 	u8	deleted;
 	u8	tm_busy;
+	struct _sas_device *sdev;
 };
 
 
@@ -358,8 +360,24 @@ struct _sas_device {
 	u8	pend_sas_rphy_add;
 	u8	enclosure_level;
 	u8	connector_name[4];
+	struct kref refcount;
 };
 
+static inline void sas_device_get(struct _sas_device *s)
+{
+	kref_get(&s->refcount);
+}
+
+static inline void sas_device_free(struct kref *r)
+{
+	kfree(container_of(r, struct _sas_device, refcount));
+}
+
+static inline void sas_device_put(struct _sas_device *s)
+{
+	kref_put(&s->refcount, sas_device_free);
+}
+
 /**
  * struct _raid_device - raid volume link list
  * @list: sas device list
@@ -1094,8 +1112,10 @@ struct _sas_node *mpt3sas_scsih_expander_find_by_handle(
 	struct MPT3SAS_ADAPTER *ioc, u16 handle);
 struct _sas_node *mpt3sas_scsih_expander_find_by_sas_address(
 	struct MPT3SAS_ADAPTER *ioc, u64 sas_address);
-struct _sas_device *mpt3sas_scsih_sas_device_find_by_sas_address(
-	struct MPT3SAS_ADAPTER *ioc, u64 sas_address);
+struct _sas_device *mpt3sas_get_sdev_by_addr(
+	 struct MPT3SAS_ADAPTER *ioc, u64 sas_address);
+struct _sas_device *__mpt3sas_get_sdev_by_addr(
+	 struct MPT3SAS_ADAPTER *ioc, u64 sas_address);
 
 void mpt3sas_port_enable_complete(struct MPT3SAS_ADAPTER *ioc);
 
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_scsih.c
diff --git a/drivers/scsi/mpt3sas/mpt3sas_transport.c b/drivers/scsi/mpt3sas/mpt3sas_transport.c
index 2b5e564eb3ae..c7506d0b3572 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_transport.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_transport.c
@@ -734,7 +734,7 @@ mpt3sas_transport_port_add(struct MPT3SAS_ADAPTER *ioc, u16 handle,
 	rphy->identify = mpt3sas_port->remote_identify;
 
 	if (mpt3sas_port->remote_identify.device_type == SAS_END_DEVICE) {
-		sas_device = mpt3sas_scsih_sas_device_find_by_sas_address(ioc,
+		sas_device = mpt3sas_get_sdev_by_addr(ioc,
 				    mpt3sas_port->remote_identify.sas_address);
 		if (!sas_device) {
 			dfailprintk(ioc, printk(MPT3SAS_FMT
@@ -750,8 +750,10 @@ mpt3sas_transport_port_add(struct MPT3SAS_ADAPTER *ioc, u16 handle,
 		    ioc->name, __FILE__, __LINE__, __func__);
 	}
 
-	if (mpt3sas_port->remote_identify.device_type == SAS_END_DEVICE)
+	if (mpt3sas_port->remote_identify.device_type == SAS_END_DEVICE) {
 		sas_device->pend_sas_rphy_add = 0;
+		sas_device_put(sas_device);
+	}
 
 	if ((ioc->logging_level & MPT_DEBUG_TRANSPORT))
 		dev_printk(KERN_INFO, &rphy->dev,
@@ -1324,15 +1326,17 @@ _transport_get_enclosure_identifier(struct sas_rphy *rphy, u64 *identifier)
 	int rc;
 
 	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_device = mpt3sas_scsih_sas_device_find_by_sas_address(ioc,
+	sas_device = __mpt3sas_get_sdev_by_addr(ioc,
 	    rphy->identify.sas_address);
 	if (sas_device) {
 		*identifier = sas_device->enclosure_logical_id;
 		rc = 0;
+		sas_device_put(sas_device);
 	} else {
 		*identifier = 0;
 		rc = -ENXIO;
 	}
+
 	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
 	return rc;
 }
@@ -1352,12 +1356,14 @@ _transport_get_bay_identifier(struct sas_rphy *rphy)
 	int rc;
 
 	spin_lock_irqsave(&ioc->sas_device_lock, flags);
-	sas_device = mpt3sas_scsih_sas_device_find_by_sas_address(ioc,
+	sas_device = __mpt3sas_get_sdev_by_addr(ioc,
 	    rphy->identify.sas_address);
-	if (sas_device)
+	if (sas_device) {
 		rc = sas_device->slot;
-	else
+		sas_device_put(sas_device);
+	} else {
 		rc = -ENXIO;
+	}
 	spin_unlock_irqrestore(&ioc->sas_device_lock, flags);
 	return rc;
 }
