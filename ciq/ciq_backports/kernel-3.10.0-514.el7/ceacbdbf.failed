dmaengine: Make the destination abbreviation coherent

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Maxime Ripard <maxime.ripard@free-electrons.com>
commit ceacbdbf65c4cf48a130db6152c6e03432c85ed1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ceacbdbf.failed

The dmaengine header abbreviates destination as at least two different strings.
Make a coherent use of a single one.

	Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
	Acked-by: Mark Brown <broonie@kernel.org>
	Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Acked-by: Stephen Warren <swarren@wwwdotorg.org>
	Signed-off-by: Vinod Koul <vinod.koul@intel.com>
(cherry picked from commit ceacbdbf65c4cf48a130db6152c6e03432c85ed1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/at_xdmac.c
#	drivers/dma/bcm2835-dma.c
#	drivers/dma/edma.c
#	drivers/dma/fsl-edma.c
#	drivers/dma/nbpfaxi.c
#	drivers/dma/omap-dma.c
#	drivers/dma/pl330.c
#	drivers/dma/sirf-dma.c
#	sound/soc/soc-generic-dmaengine-pcm.c
diff --cc drivers/dma/edma.c
index cd7e3280fadd,2b49fe6f0465..000000000000
--- a/drivers/dma/edma.c
+++ b/drivers/dma/edma.c
@@@ -530,6 -989,24 +530,27 @@@ static void __init edma_chan_init(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ #define EDMA_DMA_BUSWIDTHS	(BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \
+ 				 BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \
+ 				 BIT(DMA_SLAVE_BUSWIDTH_3_BYTES) | \
+ 				 BIT(DMA_SLAVE_BUSWIDTH_4_BYTES))
+ 
+ static int edma_dma_device_slave_caps(struct dma_chan *dchan,
+ 				      struct dma_slave_caps *caps)
+ {
+ 	caps->src_addr_widths = EDMA_DMA_BUSWIDTHS;
+ 	caps->dst_addr_widths = EDMA_DMA_BUSWIDTHS;
+ 	caps->directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);
+ 	caps->cmd_pause = true;
+ 	caps->cmd_terminate = true;
+ 	caps->residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> ceacbdbf65c4 (dmaengine: Make the destination abbreviation coherent)
  static void edma_dma_init(struct edma_cc *ecc, struct dma_device *dma,
  			  struct device *dev)
  {
diff --cc drivers/dma/omap-dma.c
index ec3fc4fd9160,ca4645c27634..000000000000
--- a/drivers/dma/omap-dma.c
+++ b/drivers/dma/omap-dma.c
@@@ -594,7 -1088,23 +594,27 @@@ static void omap_dma_free(struct omap_d
  		tasklet_kill(&c->vc.task);
  		kfree(c);
  	}
++<<<<<<< HEAD
 +	kfree(od);
++=======
+ }
+ 
+ #define OMAP_DMA_BUSWIDTHS	(BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \
+ 				 BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \
+ 				 BIT(DMA_SLAVE_BUSWIDTH_4_BYTES))
+ 
+ static int omap_dma_device_slave_caps(struct dma_chan *dchan,
+ 				      struct dma_slave_caps *caps)
+ {
+ 	caps->src_addr_widths = OMAP_DMA_BUSWIDTHS;
+ 	caps->dst_addr_widths = OMAP_DMA_BUSWIDTHS;
+ 	caps->directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);
+ 	caps->cmd_pause = true;
+ 	caps->cmd_terminate = true;
+ 	caps->residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;
+ 
+ 	return 0;
++>>>>>>> ceacbdbf65c4 (dmaengine: Make the destination abbreviation coherent)
  }
  
  static int omap_dma_probe(struct platform_device *pdev)
diff --cc drivers/dma/pl330.c
index 4c2f465be339,4a759c8718a8..000000000000
--- a/drivers/dma/pl330.c
+++ b/drivers/dma/pl330.c
@@@ -2918,6 -2616,66 +2918,69 @@@ static irqreturn_t pl330_irq_handler(in
  		return IRQ_NONE;
  }
  
++<<<<<<< HEAD
++=======
+ #define PL330_DMA_BUSWIDTHS \
+ 	BIT(DMA_SLAVE_BUSWIDTH_UNDEFINED) | \
+ 	BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \
+ 	BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \
+ 	BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) | \
+ 	BIT(DMA_SLAVE_BUSWIDTH_8_BYTES)
+ 
+ static int pl330_dma_device_slave_caps(struct dma_chan *dchan,
+ 	struct dma_slave_caps *caps)
+ {
+ 	caps->src_addr_widths = PL330_DMA_BUSWIDTHS;
+ 	caps->dst_addr_widths = PL330_DMA_BUSWIDTHS;
+ 	caps->directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);
+ 	caps->cmd_pause = false;
+ 	caps->cmd_terminate = true;
+ 	caps->residue_granularity = DMA_RESIDUE_GRANULARITY_DESCRIPTOR;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Runtime PM callbacks are provided by amba/bus.c driver.
+  *
+  * It is assumed here that IRQ safe runtime PM is chosen in probe and amba
+  * bus driver will only disable/enable the clock in runtime PM callbacks.
+  */
+ static int __maybe_unused pl330_suspend(struct device *dev)
+ {
+ 	struct amba_device *pcdev = to_amba_device(dev);
+ 
+ 	pm_runtime_disable(dev);
+ 
+ 	if (!pm_runtime_status_suspended(dev)) {
+ 		/* amba did not disable the clock */
+ 		amba_pclk_disable(pcdev);
+ 	}
+ 	amba_pclk_unprepare(pcdev);
+ 
+ 	return 0;
+ }
+ 
+ static int __maybe_unused pl330_resume(struct device *dev)
+ {
+ 	struct amba_device *pcdev = to_amba_device(dev);
+ 	int ret;
+ 
+ 	ret = amba_pclk_prepare(pcdev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (!pm_runtime_status_suspended(dev))
+ 		ret = amba_pclk_enable(pcdev);
+ 
+ 	pm_runtime_enable(dev);
+ 
+ 	return ret;
+ }
+ 
+ static SIMPLE_DEV_PM_OPS(pl330_pm, pl330_suspend, pl330_resume);
+ 
++>>>>>>> ceacbdbf65c4 (dmaengine: Make the destination abbreviation coherent)
  static int
  pl330_probe(struct amba_device *adev, const struct amba_id *id)
  {
diff --cc drivers/dma/sirf-dma.c
index 1765a0a2736d,11c85fc450a1..000000000000
--- a/drivers/dma/sirf-dma.c
+++ b/drivers/dma/sirf-dma.c
@@@ -609,6 -641,37 +609,40 @@@ bool sirfsoc_dma_filter_id(struct dma_c
  }
  EXPORT_SYMBOL(sirfsoc_dma_filter_id);
  
++<<<<<<< HEAD
++=======
+ #define SIRFSOC_DMA_BUSWIDTHS \
+ 	(BIT(DMA_SLAVE_BUSWIDTH_UNDEFINED) | \
+ 	BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \
+ 	BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \
+ 	BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) | \
+ 	BIT(DMA_SLAVE_BUSWIDTH_8_BYTES))
+ 
+ static int sirfsoc_dma_device_slave_caps(struct dma_chan *dchan,
+ 	struct dma_slave_caps *caps)
+ {
+ 	caps->src_addr_widths = SIRFSOC_DMA_BUSWIDTHS;
+ 	caps->dst_addr_widths = SIRFSOC_DMA_BUSWIDTHS;
+ 	caps->directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);
+ 	caps->cmd_pause = true;
+ 	caps->cmd_terminate = true;
+ 
+ 	return 0;
+ }
+ 
+ static struct dma_chan *of_dma_sirfsoc_xlate(struct of_phandle_args *dma_spec,
+ 	struct of_dma *ofdma)
+ {
+ 	struct sirfsoc_dma *sdma = ofdma->of_dma_data;
+ 	unsigned int request = dma_spec->args[0];
+ 
+ 	if (request >= SIRFSOC_DMA_CHANNELS)
+ 		return NULL;
+ 
+ 	return dma_get_slave_channel(&sdma->channels[request].chan);
+ }
+ 
++>>>>>>> ceacbdbf65c4 (dmaengine: Make the destination abbreviation coherent)
  static int sirfsoc_dma_probe(struct platform_device *op)
  {
  	struct device_node *dn = op->dev.of_node;
diff --cc sound/soc/soc-generic-dmaengine-pcm.c
index e29ec3cd84b1,851f7afcd5dc..000000000000
--- a/sound/soc/soc-generic-dmaengine-pcm.c
+++ b/sound/soc/soc-generic-dmaengine-pcm.c
@@@ -92,6 -110,82 +92,85 @@@ static int dmaengine_pcm_hw_params(stru
  	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
  }
  
++<<<<<<< HEAD
++=======
+ static int dmaengine_pcm_set_runtime_hwparams(struct snd_pcm_substream *substream)
+ {
+ 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+ 	struct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);
+ 	struct device *dma_dev = dmaengine_dma_dev(pcm, substream);
+ 	struct dma_chan *chan = pcm->chan[substream->stream];
+ 	struct snd_dmaengine_dai_dma_data *dma_data;
+ 	struct dma_slave_caps dma_caps;
+ 	struct snd_pcm_hardware hw;
+ 	u32 addr_widths = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |
+ 			  BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |
+ 			  BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);
+ 	int i, ret;
+ 
+ 	if (pcm->config && pcm->config->pcm_hardware)
+ 		return snd_soc_set_runtime_hwparams(substream,
+ 				pcm->config->pcm_hardware);
+ 
+ 	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+ 
+ 	memset(&hw, 0, sizeof(hw));
+ 	hw.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+ 			SNDRV_PCM_INFO_INTERLEAVED;
+ 	hw.periods_min = 2;
+ 	hw.periods_max = UINT_MAX;
+ 	hw.period_bytes_min = 256;
+ 	hw.period_bytes_max = dma_get_max_seg_size(dma_dev);
+ 	hw.buffer_bytes_max = SIZE_MAX;
+ 	hw.fifo_size = dma_data->fifo_size;
+ 
+ 	if (pcm->flags & SND_DMAENGINE_PCM_FLAG_NO_RESIDUE)
+ 		hw.info |= SNDRV_PCM_INFO_BATCH;
+ 
+ 	ret = dma_get_slave_caps(chan, &dma_caps);
+ 	if (ret == 0) {
+ 		if (dma_caps.cmd_pause)
+ 			hw.info |= SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME;
+ 		if (dma_caps.residue_granularity <= DMA_RESIDUE_GRANULARITY_SEGMENT)
+ 			hw.info |= SNDRV_PCM_INFO_BATCH;
+ 
+ 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+ 			addr_widths = dma_caps.dst_addr_widths;
+ 		else
+ 			addr_widths = dma_caps.src_addr_widths;
+ 	}
+ 
+ 	/*
+ 	 * Prepare formats mask for valid/allowed sample types. If the dma does
+ 	 * not have support for the given physical word size, it needs to be
+ 	 * masked out so user space can not use the format which produces
+ 	 * corrupted audio.
+ 	 * In case the dma driver does not implement the slave_caps the default
+ 	 * assumption is that it supports 1, 2 and 4 bytes widths.
+ 	 */
+ 	for (i = 0; i <= SNDRV_PCM_FORMAT_LAST; i++) {
+ 		int bits = snd_pcm_format_physical_width(i);
+ 
+ 		/* Enable only samples with DMA supported physical widths */
+ 		switch (bits) {
+ 		case 8:
+ 		case 16:
+ 		case 24:
+ 		case 32:
+ 		case 64:
+ 			if (addr_widths & (1 << (bits / 8)))
+ 				hw.formats |= (1LL << i);
+ 			break;
+ 		default:
+ 			/* Unsupported types */
+ 			break;
+ 		}
+ 	}
+ 
+ 	return snd_soc_set_runtime_hwparams(substream, &hw);
+ }
+ 
++>>>>>>> ceacbdbf65c4 (dmaengine: Make the destination abbreviation coherent)
  static int dmaengine_pcm_open(struct snd_pcm_substream *substream)
  {
  	struct snd_soc_pcm_runtime *rtd = substream->private_data;
* Unmerged path drivers/dma/at_xdmac.c
* Unmerged path drivers/dma/bcm2835-dma.c
* Unmerged path drivers/dma/fsl-edma.c
* Unmerged path drivers/dma/nbpfaxi.c
* Unmerged path drivers/dma/at_xdmac.c
* Unmerged path drivers/dma/bcm2835-dma.c
* Unmerged path drivers/dma/edma.c
* Unmerged path drivers/dma/fsl-edma.c
* Unmerged path drivers/dma/nbpfaxi.c
* Unmerged path drivers/dma/omap-dma.c
* Unmerged path drivers/dma/pl330.c
* Unmerged path drivers/dma/sirf-dma.c
diff --git a/include/linux/dmaengine.h b/include/linux/dmaengine.h
index 7e1eb2378f76..23940db52523 100644
--- a/include/linux/dmaengine.h
+++ b/include/linux/dmaengine.h
@@ -400,7 +400,7 @@ enum dma_residue_granularity {
 /* struct dma_slave_caps - expose capabilities of a slave channel only
  *
  * @src_addr_widths: bit mask of src addr widths the channel supports
- * @dstn_addr_widths: bit mask of dstn addr widths the channel supports
+ * @dst_addr_widths: bit mask of dstn addr widths the channel supports
  * @directions: bit mask of slave direction the channel supported
  * 	since the enum dma_transfer_direction is not defined as bits for each
  * 	type of direction, the dma controller should fill (1 << <TYPE>) and same
@@ -411,7 +411,7 @@ enum dma_residue_granularity {
  */
 struct dma_slave_caps {
 	u32 src_addr_widths;
-	u32 dstn_addr_widths;
+	u32 dst_addr_widths;
 	u32 directions;
 	bool cmd_pause;
 	bool cmd_terminate;
@@ -605,10 +605,10 @@ struct dma_device {
 	void (*device_free_chan_resources)(struct dma_chan *chan);
 
 	struct dma_async_tx_descriptor *(*device_prep_dma_memcpy)(
-		struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
+		struct dma_chan *chan, dma_addr_t dst, dma_addr_t src,
 		size_t len, unsigned long flags);
 	struct dma_async_tx_descriptor *(*device_prep_dma_xor)(
-		struct dma_chan *chan, dma_addr_t dest, dma_addr_t *src,
+		struct dma_chan *chan, dma_addr_t dst, dma_addr_t *src,
 		unsigned int src_cnt, size_t len, unsigned long flags);
 	struct dma_async_tx_descriptor *(*device_prep_dma_xor_val)(
 		struct dma_chan *chan, dma_addr_t *src,	unsigned int src_cnt,
* Unmerged path sound/soc/soc-generic-dmaengine-pcm.c
