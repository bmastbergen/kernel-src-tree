mei: iamthif: send flow control as a regular client

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit c54bf3ab7536e062b507b625bfd2befb9b2cb841
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c54bf3ab.failed

Reuse common client mechanism for sending flow control
hbm message. Add new function mei_amthif_read_start
similar to mei_cl_read_start that puts control flow request
onto the control write queue and drop mei_amthif_irq_read function

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit c54bf3ab7536e062b507b625bfd2befb9b2cb841)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/amthif.c
#	drivers/misc/mei/interrupt.c
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/amthif.c
index a11128c1997f,e6f7180fd8f2..000000000000
--- a/drivers/misc/mei/amthif.c
+++ b/drivers/misc/mei/amthif.c
@@@ -308,16 -349,12 +350,20 @@@ static int mei_amthif_send_cmd(struct m
  			return ret;
  
  		if (mei_hdr.msg_complete) {
 -			if (mei_cl_flow_ctrl_reduce(cl))
 +			if (mei_cl_flow_ctrl_reduce(&dev->iamthif_cl))
  				return -EIO;
++<<<<<<< HEAD
 +			dev->iamthif_flow_control_pending = true;
 +			dev->iamthif_state = MEI_IAMTHIF_FLOW_CONTROL;
 +			dev_dbg(&dev->pdev->dev, "add amthif cb to write waiting list\n");
 +			dev->iamthif_current_cb = cb;
 +			dev->iamthif_file_object = cb->file_object;
++=======
+ 			cb->status = mei_amthif_read_start(cl, cb->file_object);
++>>>>>>> c54bf3ab7536 (mei: iamthif: send flow control as a regular client)
  			list_add_tail(&cb->list, &dev->write_waiting_list.list);
  		} else {
 -			dev_dbg(dev->dev, "message does not complete, so add amthif cb to write list.\n");
 +			dev_dbg(&dev->pdev->dev, "message does not complete, so add amthif cb to write list.\n");
  			list_add_tail(&cb->list, &dev->write_list.list);
  		}
  	} else {
@@@ -340,19 -379,12 +388,12 @@@ int mei_amthif_write(struct mei_device 
  	if (!dev || !cb)
  		return -ENODEV;
  
- 	ret = mei_io_cb_alloc_resp_buf(cb, dev->iamthif_mtu);
- 	if (ret)
- 		return ret;
- 
  	cb->fop_type = MEI_FOP_WRITE;
- 
  	if (!list_empty(&dev->amthif_cmd_list.list) ||
  	    dev->iamthif_state != MEI_IAMTHIF_IDLE) {
 -		dev_dbg(dev->dev,
 +		dev_dbg(&dev->pdev->dev,
  			"amthif state = %d\n", dev->iamthif_state);
 -		dev_dbg(dev->dev, "AMTHIF: add cb to the wait list\n");
 +		dev_dbg(&dev->pdev->dev, "AMTHIF: add cb to the wait list\n");
  		list_add_tail(&cb->list, &dev->amthif_cmd_list.list);
  		return 0;
  	}
@@@ -382,18 -410,16 +423,29 @@@ void mei_amthif_run_next_cmd(struct mei
  	dev->iamthif_timer = 0;
  	dev->iamthif_file_object = NULL;
  
 -	dev_dbg(dev->dev, "complete amthif cmd_list cb.\n");
 +	dev_dbg(&dev->pdev->dev, "complete amthif cmd_list cb.\n");
  
++<<<<<<< HEAD
 +	list_for_each_entry_safe(cb, next, &dev->amthif_cmd_list.list, list) {
 +		list_del(&cb->list);
 +		if (!cb->cl)
 +			continue;
 +		status = mei_amthif_send_cmd(dev, cb);
 +		if (status)
 +			dev_warn(&dev->pdev->dev, "amthif write failed status = %d\n",
 +						status);
 +		break;
 +	}
++=======
+ 	cb = list_first_entry_or_null(&dev->amthif_cmd_list.list,
+ 					typeof(*cb), list);
+ 	if (!cb)
+ 		return;
+ 	list_del_init(&cb->list);
+ 	ret =  mei_amthif_send_cmd(dev, cb);
+ 	if (ret)
+ 		dev_warn(dev->dev, "amthif write failed status = %d\n", ret);
++>>>>>>> c54bf3ab7536 (mei: iamthif: send flow control as a regular client)
  }
  
  
@@@ -506,28 -525,47 +552,57 @@@ int mei_amthif_irq_write(struct mei_cl 
  }
  
  /**
 - * mei_amthif_irq_read_msg - read routine after ISR to
 + * mei_amthif_irq_read_message - read routine after ISR to
   *			handle the read amthif message
   *
 - * @cl: mei client
 + * @dev: the device structure
   * @mei_hdr: header of amthif message
 - * @complete_list: completed callbacks list
 + * @complete_list: An instance of our list structure
   *
++<<<<<<< HEAD
 + * returns 0 on success, <0 on failure.
++=======
+  * Return: Always 0; error message is in cb->status
++>>>>>>> c54bf3ab7536 (mei: iamthif: send flow control as a regular client)
   */
 -int mei_amthif_irq_read_msg(struct mei_cl *cl,
 +int mei_amthif_irq_read_msg(struct mei_device *dev,
  			    struct mei_msg_hdr *mei_hdr,
  			    struct mei_cl_cb *complete_list)
  {
  	struct mei_cl_cb *cb;
  	unsigned char *buffer;
  
++<<<<<<< HEAD
 +	BUG_ON(mei_hdr->me_addr != dev->iamthif_cl.me_client_id);
 +	BUG_ON(dev->iamthif_state != MEI_IAMTHIF_READING);
++=======
+ 	dev = cl->dev;
+ 
+ 	if (cl->state != MEI_FILE_CONNECTED)
+ 		goto err;
+ 
+ 	if (dev->iamthif_state != MEI_IAMTHIF_READING)
+ 		goto err;
+ 
+ 	list_for_each_entry(cb, &dev->read_list.list, list) {
+ 		if (cl == cb->cl)
+ 			break;
+ 	}
+ 
+ 	if (&cb->list == &dev->read_list.list) {
+ 		dev_err(dev->dev, "no reader found\n");
+ 		goto err;
+ 	}
+ 
+ 	if (dev->iamthif_mtu < dev->iamthif_msg_buf_index + mei_hdr->length) {
+ 		cb->status = -ERANGE;
+ 		goto err;
+ 	}
++>>>>>>> c54bf3ab7536 (mei: iamthif: send flow control as a regular client)
  
  	buffer = dev->iamthif_msg_buf + dev->iamthif_msg_buf_index;
 +	BUG_ON(dev->iamthif_mtu < dev->iamthif_msg_buf_index + mei_hdr->length);
 +
  	mei_read_slots(dev, buffer, mei_hdr->length);
  
  	dev->iamthif_msg_buf_index += mei_hdr->length;
@@@ -551,44 -580,16 +626,57 @@@
  	dev->iamthif_stall_timer = 0;
  	cb->buf_idx = dev->iamthif_msg_buf_index;
  	cb->read_time = jiffies;
++<<<<<<< HEAD
 +	if (dev->iamthif_ioctl) {
 +		/* found the iamthif cb */
 +		dev_dbg(&dev->pdev->dev, "complete the amthif read cb.\n ");
 +		dev_dbg(&dev->pdev->dev, "add the amthif read cb to complete.\n ");
 +		list_add_tail(&cb->list, &complete_list->list);
 +	}
 +	return 0;
 +}
 +
 +/**
 + * mei_amthif_irq_read - prepares to read amthif data.
 + *
 + * @dev: the device structure.
 + * @slots: free slots.
 + *
 + * returns 0, OK; otherwise, error.
 + */
 +int mei_amthif_irq_read(struct mei_device *dev, s32 *slots)
 +{
 +	u32 msg_slots = mei_data2slots(sizeof(struct hbm_flow_control));
 +
 +	if (*slots < msg_slots)
 +		return -EMSGSIZE;
 +
 +	*slots -= msg_slots;
 +
 +	if (mei_hbm_cl_flow_control_req(dev, &dev->iamthif_cl)) {
 +		dev_dbg(&dev->pdev->dev, "iamthif flow control failed\n");
 +		return -EIO;
 +	}
 +
 +	dev_dbg(&dev->pdev->dev, "iamthif flow control success\n");
 +	dev->iamthif_state = MEI_IAMTHIF_READING;
 +	dev->iamthif_flow_control_pending = false;
 +	dev->iamthif_msg_buf_index = 0;
 +	dev->iamthif_msg_buf_size = 0;
 +	dev->iamthif_stall_timer = MEI_IAMTHIF_STALL_TIMER;
 +	dev->hbuf_is_ready = mei_hbuf_is_ready(dev);
++=======
+ 
+ 	dev_dbg(dev->dev, "complete the amthif read cb.\n ");
+ 	list_move_tail(&cb->list, &complete_list->list);
+ 
+ 	return 0;
+ 
+ err:
+ 	mei_read_slots(dev, dev->rd_msg_buf, mei_hdr->length);
+ 	dev_dbg(dev->dev, "discarding message " MEI_HDR_FMT "\n",
+ 				MEI_HDR_PRM(mei_hdr));
++>>>>>>> c54bf3ab7536 (mei: iamthif: send flow control as a regular client)
  	return 0;
  }
  
@@@ -604,13 -621,12 +708,17 @@@ void mei_amthif_complete(struct mei_dev
  		dev->iamthif_state = MEI_IAMTHIF_READ_COMPLETE;
  		dev->iamthif_stall_timer = 0;
  		memcpy(cb->response_buffer.data,
- 				dev->iamthif_msg_buf,
- 				dev->iamthif_msg_buf_index);
+ 			dev->iamthif_msg_buf, dev->iamthif_msg_buf_index);
  		list_add_tail(&cb->list, &dev->amthif_rd_complete_list.list);
 -		dev_dbg(dev->dev, "amthif read completed\n");
 +		dev_dbg(&dev->pdev->dev, "amthif read completed\n");
  		dev->iamthif_timer = jiffies;
++<<<<<<< HEAD
 +		dev_dbg(&dev->pdev->dev, "dev->iamthif_timer = %ld\n",
 +				dev->iamthif_timer);
++=======
+ 		dev_dbg(dev->dev, "dev->iamthif_timer = %ld\n",
+ 			dev->iamthif_timer);
++>>>>>>> c54bf3ab7536 (mei: iamthif: send flow control as a regular client)
  	} else {
  		mei_amthif_run_next_cmd(dev);
  	}
diff --cc drivers/misc/mei/interrupt.c
index b8d9cfee3e87,89f2fbce160f..000000000000
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@@ -43,11 -43,9 +43,15 @@@ void mei_irq_compl_handler(struct mei_d
  
  	list_for_each_entry_safe(cb, next, &compl_list->list, list) {
  		cl = cb->cl;
++<<<<<<< HEAD
 +		list_del(&cb->list);
 +		if (!cl)
 +			continue;
++=======
+ 		list_del_init(&cb->list);
++>>>>>>> c54bf3ab7536 (mei: iamthif: send flow control as a regular client)
  
 -		dev_dbg(dev->dev, "completing call back.\n");
 +		dev_dbg(&dev->pdev->dev, "completing call back.\n");
  		if (cl == &dev->iamthif_cl)
  			mei_amthif_complete(dev, cb);
  		else
@@@ -380,25 -384,13 +384,30 @@@ int mei_irq_read_handler(struct mei_dev
  		goto end;
  	}
  
++<<<<<<< HEAD
 +	if (mei_hdr->host_addr == dev->iamthif_cl.host_client_id &&
 +	    MEI_FILE_CONNECTED == dev->iamthif_cl.state &&
 +	    dev->iamthif_state == MEI_IAMTHIF_READING) {
 +
 +		ret = mei_amthif_irq_read_msg(dev, mei_hdr, cmpl_list);
 +		if (ret) {
 +			dev_err(&dev->pdev->dev, "mei_amthif_irq_read_msg failed = %d\n",
 +					ret);
 +			goto end;
 +		}
++=======
+ 	if (cl == &dev->iamthif_cl) {
+ 		ret = mei_amthif_irq_read_msg(cl, mei_hdr, cmpl_list);
++>>>>>>> c54bf3ab7536 (mei: iamthif: send flow control as a regular client)
  	} else {
 -		ret = mei_cl_irq_read_msg(cl, mei_hdr, cmpl_list);
 +		ret = mei_cl_irq_read_msg(dev, mei_hdr, cmpl_list);
 +		if (ret) {
 +			dev_err(&dev->pdev->dev, "mei_cl_irq_read_msg failed = %d\n",
 +					ret);
 +			goto end;
 +		}
  	}
  
 -
  reset_slots:
  	/* reset the number of slots and header */
  	*slots = mei_count_full_read_slots(dev);
@@@ -449,25 -441,11 +458,13 @@@ int mei_irq_write_handler(struct mei_de
  	list = &dev->write_waiting_list;
  	list_for_each_entry_safe(cb, next, &list->list, list) {
  		cl = cb->cl;
 +		if (cl == NULL)
 +			continue;
  
  		cl->status = 0;
- 		list_del(&cb->list);
- 		if (cb->fop_type == MEI_FOP_WRITE &&
- 		    cl != &dev->iamthif_cl) {
- 			cl_dbg(dev, cl, "MEI WRITE COMPLETE\n");
- 			cl->writing_state = MEI_WRITE_COMPLETE;
- 			list_add_tail(&cb->list, &cmpl_list->list);
- 		}
- 		if (cl == &dev->iamthif_cl) {
- 			cl_dbg(dev, cl, "check iamthif flow control.\n");
- 			if (dev->iamthif_flow_control_pending) {
- 				ret = mei_amthif_irq_read(dev, &slots);
- 				if (ret)
- 					return ret;
- 			}
- 		}
+ 		cl_dbg(dev, cl, "MEI WRITE COMPLETE\n");
+ 		cl->writing_state = MEI_WRITE_COMPLETE;
+ 		list_move_tail(&cb->list, &cmpl_list->list);
  	}
  
  	if (dev->wd_state == MEI_WD_STOPPING) {
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,fc460af131d4..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -382,55 -418,98 +382,131 @@@ enum mei_pg_state 
  
  const char *mei_pg_state_str(enum mei_pg_state state);
  
 +/*
 + * mei_cfg
 + *
 + * @fw_status - FW status
 + * @quirk_probe - device exclusion quirk
 + */
 +struct mei_cfg {
 +	const struct mei_fw_status fw_status;
 +	bool (*quirk_probe)(struct pci_dev *pdev);
 +};
 +
 +
 +#define MEI_PCI_DEVICE(dev, cfg) \
 +	.vendor = PCI_VENDOR_ID_INTEL, .device = (dev), \
 +	.subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID, \
 +	.driver_data = (kernel_ulong_t)&(cfg)
 +
 +
  /**
   * struct mei_device -  MEI private device struct
 +
 + * @reset_count - limits the number of consecutive resets
 + * @hbm_state - state of host bus message protocol
   *
 - * @dev         : device on a bus
 - * @cdev        : character device
 - * @minor       : minor number allocated for device
 + * @hbm_f_pg_supported - hbm feature pgi protocol
   *
++<<<<<<< HEAD
 + * @pg_event - power gating event
 + * @mem_addr - mem mapped base register address
 +
 + * @hbuf_depth - depth of hardware host/write buffer is slots
 + * @hbuf_is_ready - query if the host host/write buffer is ready
 + * @wr_msg - the buffer for hbm control messages
 + * @cfg - per device generation config and ops
++=======
+  * @read_list   : read completion list
+  * @write_list  : write pending list
+  * @write_waiting_list : write completion list
+  * @ctrl_wr_list : pending control write list
+  * @ctrl_rd_list : pending control read list
+  *
+  * @file_list   : list of opened handles
+  * @open_handle_count: number of opened handles
+  *
+  * @device_lock : big device lock
+  * @timer_work  : MEI timer delayed work (timeouts)
+  *
+  * @recvd_hw_ready : hw ready message received flag
+  *
+  * @wait_hw_ready : wait queue for receive HW ready message form FW
+  * @wait_pg     : wait queue for receive PG message from FW
+  * @wait_hbm_start : wait queue for receive HBM start message from FW
+  * @wait_stop_wd : wait queue for receive WD stop message from FW
+  *
+  * @reset_count : number of consecutive resets
+  * @dev_state   : device state
+  * @hbm_state   : state of host bus message protocol
+  * @init_clients_timer : HBM init handshake timeout
+  *
+  * @pg_event    : power gating event
+  * @pg_domain   : runtime PM domain
+  *
+  * @rd_msg_buf  : control messages buffer
+  * @rd_msg_hdr  : read message header storage
+  *
+  * @hbuf_depth  : depth of hardware host/write buffer is slots
+  * @hbuf_is_ready : query if the host host/write buffer is ready
+  * @wr_msg      : the buffer for hbm control messages
+  *
+  * @version     : HBM protocol version in use
+  * @hbm_f_pg_supported : hbm feature pgi protocol
+  *
+  * @me_clients_rwsem: rw lock over me_clients list
+  * @me_clients  : list of FW clients
+  * @me_clients_map : FW clients bit map
+  * @host_clients_map : host clients id pool
+  * @me_client_index : last FW client index in enumeration
+  *
+  * @wd_cl       : watchdog client
+  * @wd_state    : watchdog client state
+  * @wd_pending  : watchdog command is pending
+  * @wd_timeout  : watchdog expiration timeout
+  * @wd_data     : watchdog message buffer
+  *
+  * @amthif_cmd_list : amthif list for cmd waiting
+  * @amthif_rd_complete_list : amthif list for reading completed cmd data
+  * @iamthif_file_object : file for current amthif operation
+  * @iamthif_cl  : amthif host client
+  * @iamthif_current_cb : amthif current operation callback
+  * @iamthif_open_count : number of opened amthif connections
+  * @iamthif_mtu : amthif client max message length
+  * @iamthif_timer : time stamp of current amthif command completion
+  * @iamthif_stall_timer : timer to detect amthif hang
+  * @iamthif_msg_buf : amthif current message buffer
+  * @iamthif_msg_buf_size : size of current amthif message request buffer
+  * @iamthif_msg_buf_index : current index in amthif message request buffer
+  * @iamthif_state : amthif processor state
+  * @iamthif_canceled : current amthif command is canceled
+  *
+  * @init_work   : work item for the device init
+  * @reset_work  : work item for the device reset
+  *
+  * @device_list : mei client bus list
+  *
+  * @dbgfs_dir   : debugfs mei root directory
+  *
+  * @ops:        : hw specific operations
+  * @hw          : hw specific data
++>>>>>>> c54bf3ab7536 (mei: iamthif: send flow control as a regular client)
   */
  struct mei_device {
 -	struct device *dev;
 -	struct cdev cdev;
 -	int minor;
 -
 -	struct mei_cl_cb read_list;
 -	struct mei_cl_cb write_list;
 -	struct mei_cl_cb write_waiting_list;
 -	struct mei_cl_cb ctrl_wr_list;
 -	struct mei_cl_cb ctrl_rd_list;
 +	struct pci_dev *pdev;	/* pointer to pci device struct */
 +	/*
 +	 * lists of queues
 +	 */
 +	/* array of pointers to aio lists */
 +	struct mei_cl_cb read_list;		/* driver read queue */
 +	struct mei_cl_cb write_list;		/* driver write queue */
 +	struct mei_cl_cb write_waiting_list;	/* write waiting queue */
 +	struct mei_cl_cb ctrl_wr_list;		/* managed write IOCTL list */
 +	struct mei_cl_cb ctrl_rd_list;		/* managed read IOCTL list */
  
 +	/*
 +	 * list of files
 +	 */
  	struct list_head file_list;
  	long open_handle_count;
  
@@@ -507,8 -585,6 +583,11 @@@
  	u32 iamthif_msg_buf_size;
  	u32 iamthif_msg_buf_index;
  	enum iamthif_states iamthif_state;
++<<<<<<< HEAD
 +	bool iamthif_flow_control_pending;
 +	bool iamthif_ioctl;
++=======
++>>>>>>> c54bf3ab7536 (mei: iamthif: send flow control as a regular client)
  	bool iamthif_canceled;
  
  	struct work_struct init_work;
* Unmerged path drivers/misc/mei/amthif.c
* Unmerged path drivers/misc/mei/interrupt.c
* Unmerged path drivers/misc/mei/mei_dev.h
