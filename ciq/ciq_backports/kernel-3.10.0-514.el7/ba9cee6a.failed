cxgb4/iw_cxgb4: TOS support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit ba9cee6aa67dd67ad1bf121ee20efc00241f086f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ba9cee6a.failed

This series provides support for iWARP applications to specify a TOS
value and have that map to a VLAN Priority for iw_cxgb4 iWARP connections.

In iw_cxgb4, when allocating an L2T entry, pass the skb_priority based
on the tos value in the cm_id. Also pass the correct tos value during
connection setup so the passive side gets the client's desired tos.
When sending the FLOWC work request to FW, if the egress device is
in a vlan, then use the vlan priority bits as the scheduling class.
This allows associating RDMA connections with scheduling classes to
provide traffic shaping per flow.

	Signed-off-by: Steve Wise <swise@opengridcomputing.com>
	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ba9cee6aa67dd67ad1bf121ee20efc00241f086f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/cxgb4/cm.c
diff --cc drivers/infiniband/hw/cxgb4/cm.c
index cedcb7924d6a,8cd7b5e4b03d..000000000000
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@@ -1874,7 -1943,7 +1889,11 @@@ static void set_tcp_window(struct c4iw_
  
  static int import_ep(struct c4iw_ep *ep, int iptype, __u8 *peer_ip,
  		     struct dst_entry *dst, struct c4iw_dev *cdev,
++<<<<<<< HEAD
 +		     bool clear_mpa_v1)
++=======
+ 		     bool clear_mpa_v1, enum chip_type adapter_type, u8 tos)
++>>>>>>> ba9cee6aa67d (cxgb4/iw_cxgb4: TOS support)
  {
  	struct neighbour *n;
  	int err, step;
@@@ -2000,7 -2072,9 +2019,13 @@@ static int c4iw_reconnect(struct c4iw_e
  		err = -EHOSTUNREACH;
  		goto fail3;
  	}
++<<<<<<< HEAD
 +	err = import_ep(ep, iptype, ra, ep->dst, ep->com.dev, false);
++=======
+ 	err = import_ep(ep, iptype, ra, ep->dst, ep->com.dev, false,
+ 			ep->com.dev->rdev.lldi.adapter_type,
+ 			ep->com.cm_id->tos);
++>>>>>>> ba9cee6aa67d (cxgb4/iw_cxgb4: TOS support)
  	if (err) {
  		pr_err("%s - cannot alloc l2e.\n", __func__);
  		goto fail4;
@@@ -2356,7 -2456,8 +2382,12 @@@ static int pass_accept_req(struct c4iw_
  		goto reject;
  	}
  
++<<<<<<< HEAD
 +	err = import_ep(child_ep, iptype, peer_ip, dst, dev, false);
++=======
+ 	err = import_ep(child_ep, iptype, peer_ip, dst, dev, false,
+ 			parent_ep->com.dev->rdev.lldi.adapter_type, tos);
++>>>>>>> ba9cee6aa67d (cxgb4/iw_cxgb4: TOS support)
  	if (err) {
  		printk(KERN_ERR MOD "%s - failed to allocate l2t entry!\n",
  		       __func__);
@@@ -3136,7 -3249,8 +3167,12 @@@ int c4iw_connect(struct iw_cm_id *cm_id
  		goto fail2;
  	}
  
++<<<<<<< HEAD
 +	err = import_ep(ep, iptype, ra, ep->dst, ep->com.dev, true);
++=======
+ 	err = import_ep(ep, iptype, ra, ep->dst, ep->com.dev, true,
+ 			ep->com.dev->rdev.lldi.adapter_type, cm_id->tos);
++>>>>>>> ba9cee6aa67d (cxgb4/iw_cxgb4: TOS support)
  	if (err) {
  		printk(KERN_ERR MOD "%s - cannot alloc l2e.\n", __func__);
  		goto fail3;
* Unmerged path drivers/infiniband/hw/cxgb4/cm.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4_msg.h b/drivers/net/ethernet/chelsio/cxgb4/t4_msg.h
index 5ac17ca63cdf..f0a4896ab1f5 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_msg.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_msg.h
@@ -945,6 +945,8 @@ struct cpl_l2t_write_req {
 #define L2T_W_NOREPLY_V(x) ((x) << L2T_W_NOREPLY_S)
 #define L2T_W_NOREPLY_F    L2T_W_NOREPLY_V(1U)
 
+#define CPL_L2T_VLAN_NONE 0xfff
+
 struct cpl_l2t_write_rpl {
 	union opcode_tid ot;
 	u8 status;
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h b/drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
index ae0f72f6ace9..8af6616687cd 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
@@ -561,6 +561,7 @@ enum fw_flowc_mnem {
 	FW_FLOWC_MNEM_SNDBUF,
 	FW_FLOWC_MNEM_MSS,
 	FW_FLOWC_MNEM_TXDATAPLEN_MAX,
+	FW_FLOWC_MNEM_SCHEDCLASS = 11,
 };
 
 struct fw_flowc_mnemval {
