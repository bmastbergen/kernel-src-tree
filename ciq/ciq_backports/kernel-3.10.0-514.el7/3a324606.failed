rhashtable: Enforce minimum size on initial hash table

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit 3a324606bbabfc30084ce9d08169910773ba9a92
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3a324606.failed

William Hua <william.hua@canonical.com> wrote:
>
> I wasn't aware there was an enforced minimum size. I simply set the
> nelem_hint in the rhastable_params struct to 1, expecting it to grow as
> needed. This caused a segfault afterwards when trying to insert an
> element.

OK we're doing the size computation before we enforce the limit
on min_size.

---8<---
We need to do the initial hash table size computation after we
have obtained the correct min_size/max_size parameters.  Otherwise
we may end up with a hash table whose size is outside the allowed
envelope.

Fixes: a998f712f77e ("rhashtable: Round up/down min/max_size to...")
	Reported-by: William Hua <william.hua@canonical.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3a324606bbabfc30084ce9d08169910773ba9a92)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/rhashtable.c
diff --cc lib/rhashtable.c
index 15ef938f4f67,a98e71db7dd2..000000000000
--- a/lib/rhashtable.c
+++ b/lib/rhashtable.c
@@@ -519,17 -731,66 +519,73 @@@ int rhashtable_init(struct rhashtable *
  
  	size = HASH_DEFAULT_SIZE;
  
 -	if ((!params->key_len && !params->obj_hashfn) ||
 -	    (params->obj_hashfn && !params->obj_cmpfn))
 +	if ((params->key_len && !params->hashfn) ||
 +	    (!params->key_len && !params->obj_hashfn))
  		return -EINVAL;
  
 -	if (params->nulls_base && params->nulls_base < (1U << RHT_BASE_SHIFT))
 -		return -EINVAL;
 +	params->min_shift = max_t(size_t, params->min_shift,
 +				  ilog2(HASH_MIN_SIZE));
 +
++<<<<<<< HEAD
 +	if (params->nelem_hint)
 +		size = rounded_hashtable_size(params);
  
 +	tbl = bucket_table_alloc(size);
++=======
+ 	memset(ht, 0, sizeof(*ht));
+ 	mutex_init(&ht->mutex);
+ 	spin_lock_init(&ht->lock);
+ 	memcpy(&ht->p, params, sizeof(*params));
+ 
+ 	if (params->min_size)
+ 		ht->p.min_size = roundup_pow_of_two(params->min_size);
+ 
+ 	if (params->max_size)
+ 		ht->p.max_size = rounddown_pow_of_two(params->max_size);
+ 
+ 	if (params->insecure_max_entries)
+ 		ht->p.insecure_max_entries =
+ 			rounddown_pow_of_two(params->insecure_max_entries);
+ 	else
+ 		ht->p.insecure_max_entries = ht->p.max_size * 2;
+ 
+ 	ht->p.min_size = max(ht->p.min_size, HASH_MIN_SIZE);
+ 
+ 	if (params->nelem_hint)
+ 		size = rounded_hashtable_size(&ht->p);
+ 
+ 	/* The maximum (not average) chain length grows with the
+ 	 * size of the hash table, at a rate of (log N)/(log log N).
+ 	 * The value of 16 is selected so that even if the hash
+ 	 * table grew to 2^32 you would not expect the maximum
+ 	 * chain length to exceed it unless we are under attack
+ 	 * (or extremely unlucky).
+ 	 *
+ 	 * As this limit is only to detect attacks, we don't need
+ 	 * to set it to a lower value as you'd need the chain
+ 	 * length to vastly exceed 16 to have any real effect
+ 	 * on the system.
+ 	 */
+ 	if (!params->insecure_elasticity)
+ 		ht->elasticity = 16;
+ 
+ 	if (params->locks_mul)
+ 		ht->p.locks_mul = roundup_pow_of_two(params->locks_mul);
+ 	else
+ 		ht->p.locks_mul = BUCKET_LOCKS_PER_CPU;
+ 
+ 	ht->key_len = ht->p.key_len;
+ 	if (!params->hashfn) {
+ 		ht->p.hashfn = jhash;
+ 
+ 		if (!(ht->key_len & (sizeof(u32) - 1))) {
+ 			ht->key_len /= sizeof(u32);
+ 			ht->p.hashfn = rhashtable_jhash2;
+ 		}
+ 	}
+ 
+ 	tbl = bucket_table_alloc(ht, size, GFP_KERNEL);
++>>>>>>> 3a324606bbab (rhashtable: Enforce minimum size on initial hash table)
  	if (tbl == NULL)
  		return -ENOMEM;
  
* Unmerged path lib/rhashtable.c
