libceph: protect osdc->osd_lru list with a spinlock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ilya Dryomov <idryomov@gmail.com>
commit 9dd2845ccb40452d4ac943231ea34aade4a02c68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9dd2845c.failed

OSD client is getting moved from the big per-client lock to a set of
per-session locks.  The big rwlock would only be held for read most of
the time, so a global osdc->osd_lru needs additional protection.

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 9dd2845ccb40452d4ac943231ea34aade4a02c68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ceph/osd_client.c
diff --cc net/ceph/osd_client.c
index b1bd089d52f0,d1c8e06f1261..000000000000
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@@ -1100,59 -1101,39 +1100,74 @@@ static void remove_osd(struct ceph_osd_
  	}
  }
  
++<<<<<<< HEAD
 +static void remove_all_osds(struct ceph_osd_client *osdc)
 +{
 +	dout("%s %p\n", __func__, osdc);
 +	mutex_lock(&osdc->request_mutex);
 +	while (!RB_EMPTY_ROOT(&osdc->osds)) {
 +		struct ceph_osd *osd = rb_entry(rb_first(&osdc->osds),
 +						struct ceph_osd, o_node);
 +		remove_osd(osdc, osd);
 +	}
 +	mutex_unlock(&osdc->request_mutex);
 +}
 +
 +static void __move_osd_to_lru(struct ceph_osd_client *osdc,
 +			      struct ceph_osd *osd)
++=======
+ static void __move_osd_to_lru(struct ceph_osd *osd)
++>>>>>>> 9dd2845ccb40 (libceph: protect osdc->osd_lru list with a spinlock)
  {
- 	dout("%s %p\n", __func__, osd);
+ 	struct ceph_osd_client *osdc = osd->o_osdc;
+ 
+ 	dout("%s osd %p osd%d\n", __func__, osd, osd->o_osd);
  	BUG_ON(!list_empty(&osd->o_osd_lru));
  
+ 	spin_lock(&osdc->osd_lru_lock);
  	list_add_tail(&osd->o_osd_lru, &osdc->osd_lru);
++<<<<<<< HEAD
 +	osd->lru_ttl = jiffies + osdc->client->options->osd_idle_ttl * HZ;
++=======
+ 	spin_unlock(&osdc->osd_lru_lock);
+ 
+ 	osd->lru_ttl = jiffies + osdc->client->options->osd_idle_ttl;
++>>>>>>> 9dd2845ccb40 (libceph: protect osdc->osd_lru list with a spinlock)
  }
  
- static void maybe_move_osd_to_lru(struct ceph_osd_client *osdc,
- 				  struct ceph_osd *osd)
+ static void maybe_move_osd_to_lru(struct ceph_osd *osd)
  {
- 	dout("%s %p\n", __func__, osd);
- 
  	if (list_empty(&osd->o_requests) &&
  	    list_empty(&osd->o_linger_requests))
- 		__move_osd_to_lru(osdc, osd);
+ 		__move_osd_to_lru(osd);
  }
  
  static void __remove_osd_from_lru(struct ceph_osd *osd)
  {
- 	dout("__remove_osd_from_lru %p\n", osd);
+ 	struct ceph_osd_client *osdc = osd->o_osdc;
+ 
+ 	dout("%s osd %p osd%d\n", __func__, osd, osd->o_osd);
+ 
+ 	spin_lock(&osdc->osd_lru_lock);
  	if (!list_empty(&osd->o_osd_lru))
  		list_del_init(&osd->o_osd_lru);
+ 	spin_unlock(&osdc->osd_lru_lock);
  }
  
 +static void remove_old_osds(struct ceph_osd_client *osdc)
 +{
 +	struct ceph_osd *osd, *nosd;
 +
 +	dout("__remove_old_osds %p\n", osdc);
 +	mutex_lock(&osdc->request_mutex);
 +	list_for_each_entry_safe(osd, nosd, &osdc->osd_lru, o_osd_lru) {
 +		if (time_before(jiffies, osd->lru_ttl))
 +			break;
 +		remove_osd(osdc, osd);
 +	}
 +	mutex_unlock(&osdc->request_mutex);
 +}
 +
  /*
   * reset osd connect
   */
diff --git a/include/linux/ceph/osd_client.h b/include/linux/ceph/osd_client.h
index cc16ab3e4c14..145502b1ef9b 100644
--- a/include/linux/ceph/osd_client.h
+++ b/include/linux/ceph/osd_client.h
@@ -208,6 +208,7 @@ struct ceph_osd_client {
 	struct mutex           request_mutex;
 	struct rb_root         osds;          /* osds */
 	struct list_head       osd_lru;       /* idle osds */
+	spinlock_t             osd_lru_lock;
 	u64                    last_tid;      /* tid of last request */
 	struct rb_root         requests;      /* pending requests */
 	struct list_head       req_lru;	      /* in-flight lru */
* Unmerged path net/ceph/osd_client.c
