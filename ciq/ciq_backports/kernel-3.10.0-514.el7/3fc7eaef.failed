mmc: dw_mmc: Add external dma interface support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Shawn Lin <shawn.lin@rock-chips.com>
commit 3fc7eaef44dbcbcd602b6bcd0ac6efba7a30b108
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3fc7eaef.failed

DesignWare MMC Controller can supports two types of DMA
mode: external dma and internal dma. We get a RK312x platform
integrated dw_mmc and ARM pl330 dma controller. This patch add
edmac ops to support these platforms. I've tested it on RK31xx
platform with edmac mode and RK3288 platform with idmac mode.

	Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
	Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 3fc7eaef44dbcbcd602b6bcd0ac6efba7a30b108)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/dw_mmc-pltfm.c
#	drivers/mmc/host/dw_mmc.c
#	include/linux/mmc/dw_mmc.h
diff --cc drivers/mmc/host/dw_mmc-pltfm.c
index 37873f101cdb,7e1d13b68b06..000000000000
--- a/drivers/mmc/host/dw_mmc-pltfm.c
+++ b/drivers/mmc/host/dw_mmc-pltfm.c
@@@ -47,6 -57,10 +47,13 @@@ int dw_mci_pltfm_register(struct platfo
  	host->dev = &pdev->dev;
  	host->irq_flags = 0;
  	host->pdata = pdev->dev.platform_data;
++<<<<<<< HEAD
++=======
+ 
+ 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	/* Get registers' physical base address */
+ 	host->phy_regs = (void *)(regs->start);
++>>>>>>> 3fc7eaef44db (mmc: dw_mmc: Add external dma interface support)
  	host->regs = devm_ioremap_resource(&pdev->dev, regs);
  	if (IS_ERR(host->regs))
  		return PTR_ERR(host->regs);
diff --cc drivers/mmc/host/dw_mmc.c
index bc4f99ee919c,7fe0315142e6..000000000000
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@@ -50,9 -53,35 +50,39 @@@
  #define DW_MCI_RECV_STATUS	2
  #define DW_MCI_DMA_THRESHOLD	16
  
++<<<<<<< HEAD
 +#ifdef CONFIG_MMC_DW_IDMAC
++=======
+ #define DW_MCI_FREQ_MAX	200000000	/* unit: HZ */
+ #define DW_MCI_FREQ_MIN	400000		/* unit: HZ */
+ 
+ #define IDMAC_INT_CLR		(SDMMC_IDMAC_INT_AI | SDMMC_IDMAC_INT_NI | \
+ 				 SDMMC_IDMAC_INT_CES | SDMMC_IDMAC_INT_DU | \
+ 				 SDMMC_IDMAC_INT_FBE | SDMMC_IDMAC_INT_RI | \
+ 				 SDMMC_IDMAC_INT_TI)
+ 
+ struct idmac_desc_64addr {
+ 	u32		des0;	/* Control Descriptor */
+ 
+ 	u32		des1;	/* Reserved */
+ 
+ 	u32		des2;	/*Buffer sizes */
+ #define IDMAC_64ADDR_SET_BUFFER1_SIZE(d, s) \
+ 	((d)->des2 = ((d)->des2 & cpu_to_le32(0x03ffe000)) | \
+ 	 ((cpu_to_le32(s)) & cpu_to_le32(0x1fff)))
+ 
+ 	u32		des3;	/* Reserved */
+ 
+ 	u32		des4;	/* Lower 32-bits of Buffer Address Pointer 1*/
+ 	u32		des5;	/* Upper 32-bits of Buffer Address Pointer 1*/
+ 
+ 	u32		des6;	/* Lower 32-bits of Next Descriptor Address */
+ 	u32		des7;	/* Upper 32-bits of Next Descriptor Address */
+ };
+ 
++>>>>>>> 3fc7eaef44db (mmc: dw_mmc: Add external dma interface support)
  struct idmac_desc {
 -	__le32		des0;	/* Control Descriptor */
 +	u32		des0;	/* Control Descriptor */
  #define IDMAC_DES0_DIC	BIT(1)
  #define IDMAC_DES0_LD	BIT(2)
  #define IDMAC_DES0_FD	BIT(3)
@@@ -65,47 -94,17 +95,53 @@@
  #define IDMAC_SET_BUFFER1_SIZE(d, s) \
  	((d)->des1 = ((d)->des1 & 0x03ffe000) | ((s) & 0x1fff))
  
 -	__le32		des2;	/* buffer 1 physical address */
 +	u32		des2;	/* buffer 1 physical address */
  
 -	__le32		des3;	/* buffer 2 physical address */
 +	u32		des3;	/* buffer 2 physical address */
  };
++<<<<<<< HEAD
 +#endif /* CONFIG_MMC_DW_IDMAC */
++=======
+ 
+ /* Each descriptor can transfer up to 4KB of data in chained mode */
+ #define DW_MCI_DESC_DATA_LENGTH	0x1000
++>>>>>>> 3fc7eaef44db (mmc: dw_mmc: Add external dma interface support)
 +
 +/**
 + * struct dw_mci_slot - MMC slot state
 + * @mmc: The mmc_host representing this slot.
 + * @host: The MMC controller this slot is using.
 + * @quirks: Slot-level quirks (DW_MCI_SLOT_QUIRK_XXX)
 + * @wp_gpio: If gpio_is_valid() we'll use this to read write protect.
 + * @ctype: Card type for this slot.
 + * @mrq: mmc_request currently being processed or waiting to be
 + *	processed, or NULL when the slot is idle.
 + * @queue_node: List node for placing this node in the @queue list of
 + *	&struct dw_mci.
 + * @clock: Clock rate configured by set_ios(). Protected by host->lock.
 + * @flags: Random state bits associated with the slot.
 + * @id: Number of this slot.
 + * @last_detect_state: Most recently observed card detect state.
 + */
 +struct dw_mci_slot {
 +	struct mmc_host		*mmc;
 +	struct dw_mci		*host;
 +
 +	int			quirks;
 +	int			wp_gpio;
 +
 +	u32			ctype;
  
 -static bool dw_mci_reset(struct dw_mci *host);
 -static bool dw_mci_ctrl_reset(struct dw_mci *host, u32 reset);
 -static int dw_mci_card_busy(struct mmc_host *mmc);
 +	struct mmc_request	*mrq;
 +	struct list_head	queue_node;
 +
 +	unsigned int		clock;
 +	unsigned long		flags;
 +#define DW_MMC_CARD_PRESENT	0
 +#define DW_MMC_CARD_NEED_INIT	1
 +	int			id;
 +	int			last_detect_state;
 +};
  
  #if defined(CONFIG_DEBUG_FS)
  static int dw_mci_req_show(struct seq_file *s, void *v)
@@@ -363,36 -472,105 +407,36 @@@ static void dw_mci_dmac_complete_dma(vo
  static void dw_mci_translate_sglist(struct dw_mci *host, struct mmc_data *data,
  				    unsigned int sg_len)
  {
 -	unsigned int desc_len;
  	int i;
 +	struct idmac_desc *desc = host->sg_cpu;
  
 -	if (host->dma_64bit_address == 1) {
 -		struct idmac_desc_64addr *desc_first, *desc_last, *desc;
 +	for (i = 0; i < sg_len; i++, desc++) {
 +		unsigned int length = sg_dma_len(&data->sg[i]);
 +		u32 mem_addr = sg_dma_address(&data->sg[i]);
  
 -		desc_first = desc_last = desc = host->sg_cpu;
 -
 -		for (i = 0; i < sg_len; i++) {
 -			unsigned int length = sg_dma_len(&data->sg[i]);
 -
 -			u64 mem_addr = sg_dma_address(&data->sg[i]);
 -
 -			for ( ; length ; desc++) {
 -				desc_len = (length <= DW_MCI_DESC_DATA_LENGTH) ?
 -					   length : DW_MCI_DESC_DATA_LENGTH;
 -
 -				length -= desc_len;
 -
 -				/*
 -				 * Set the OWN bit and disable interrupts
 -				 * for this descriptor
 -				 */
 -				desc->des0 = IDMAC_DES0_OWN | IDMAC_DES0_DIC |
 -							IDMAC_DES0_CH;
 +		/* Set the OWN bit and disable interrupts for this descriptor */
 +		desc->des0 = IDMAC_DES0_OWN | IDMAC_DES0_DIC | IDMAC_DES0_CH;
  
 -				/* Buffer length */
 -				IDMAC_64ADDR_SET_BUFFER1_SIZE(desc, desc_len);
 +		/* Buffer length */
 +		IDMAC_SET_BUFFER1_SIZE(desc, length);
  
 -				/* Physical address to DMA to/from */
 -				desc->des4 = mem_addr & 0xffffffff;
 -				desc->des5 = mem_addr >> 32;
 -
 -				/* Update physical address for the next desc */
 -				mem_addr += desc_len;
 -
 -				/* Save pointer to the last descriptor */
 -				desc_last = desc;
 -			}
 -		}
 -
 -		/* Set first descriptor */
 -		desc_first->des0 |= IDMAC_DES0_FD;
 -
 -		/* Set last descriptor */
 -		desc_last->des0 &= ~(IDMAC_DES0_CH | IDMAC_DES0_DIC);
 -		desc_last->des0 |= IDMAC_DES0_LD;
 -
 -	} else {
 -		struct idmac_desc *desc_first, *desc_last, *desc;
 -
 -		desc_first = desc_last = desc = host->sg_cpu;
 -
 -		for (i = 0; i < sg_len; i++) {
 -			unsigned int length = sg_dma_len(&data->sg[i]);
 -
 -			u32 mem_addr = sg_dma_address(&data->sg[i]);
 -
 -			for ( ; length ; desc++) {
 -				desc_len = (length <= DW_MCI_DESC_DATA_LENGTH) ?
 -					   length : DW_MCI_DESC_DATA_LENGTH;
 -
 -				length -= desc_len;
 -
 -				/*
 -				 * Set the OWN bit and disable interrupts
 -				 * for this descriptor
 -				 */
 -				desc->des0 = cpu_to_le32(IDMAC_DES0_OWN |
 -							 IDMAC_DES0_DIC |
 -							 IDMAC_DES0_CH);
 -
 -				/* Buffer length */
 -				IDMAC_SET_BUFFER1_SIZE(desc, desc_len);
 -
 -				/* Physical address to DMA to/from */
 -				desc->des2 = cpu_to_le32(mem_addr);
 -
 -				/* Update physical address for the next desc */
 -				mem_addr += desc_len;
 -
 -				/* Save pointer to the last descriptor */
 -				desc_last = desc;
 -			}
 -		}
 +		/* Physical address to DMA to/from */
 +		desc->des2 = mem_addr;
 +	}
  
 -		/* Set first descriptor */
 -		desc_first->des0 |= cpu_to_le32(IDMAC_DES0_FD);
 +	/* Set first descriptor */
 +	desc = host->sg_cpu;
 +	desc->des0 |= IDMAC_DES0_FD;
  
 -		/* Set last descriptor */
 -		desc_last->des0 &= cpu_to_le32(~(IDMAC_DES0_CH |
 -					       IDMAC_DES0_DIC));
 -		desc_last->des0 |= cpu_to_le32(IDMAC_DES0_LD);
 -	}
 +	/* Set last descriptor */
 +	desc = host->sg_cpu + (i - 1) * sizeof(struct idmac_desc);
 +	desc->des0 &= ~(IDMAC_DES0_CH | IDMAC_DES0_DIC);
 +	desc->des0 |= IDMAC_DES0_LD;
  
 -	wmb(); /* drain writebuffer */
 +	wmb();
  }
  
- static void dw_mci_idmac_start_dma(struct dw_mci *host, unsigned int sg_len)
+ static int dw_mci_idmac_start_dma(struct dw_mci *host, unsigned int sg_len)
  {
  	u32 temp;
  
@@@ -534,8 -867,12 +681,12 @@@ static void dw_mci_adjust_fifoth(struc
  	u32 fifo_width = 1 << host->data_shift;
  	u32 blksz_depth = blksz / fifo_width, fifoth_val;
  	u32 msize = 0, rx_wmark = 1, tx_wmark, tx_wmark_invers;
 -	int idx = ARRAY_SIZE(mszs) - 1;
 +	int idx = (sizeof(mszs) / sizeof(mszs[0])) - 1;
  
+ 	/* pio should ship this scenario */
+ 	if (!host->use_dma)
+ 		return;
+ 
  	tx_wmark = (host->fifo_depth) / 2;
  	tx_wmark_invers = host->fifo_depth - tx_wmark;
  
@@@ -639,8 -986,14 +791,12 @@@ static int dw_mci_submit_data_dma(struc
  	temp = mci_readl(host, INTMASK);
  	temp  &= ~(SDMMC_INT_RXDR | SDMMC_INT_TXDR);
  	mci_writel(host, INTMASK, temp);
 -	spin_unlock_irqrestore(&host->irq_lock, irqflags);
  
- 	host->dma_ops->start(host, sg_len);
+ 	if (host->dma_ops->start(host, sg_len)) {
+ 		/* We can't do DMA */
+ 		dev_err(host->dev, "%s: failed to start DMA.\n", __func__);
+ 		return -ENODEV;
+ 	}
  
  	return 0;
  }
@@@ -1757,15 -2456,27 +1913,37 @@@ static irqreturn_t dw_mci_interrupt(in
  
  	}
  
++<<<<<<< HEAD
 +#ifdef CONFIG_MMC_DW_IDMAC
 +	/* Handle DMA interrupts */
 +	pending = mci_readl(host, IDSTS);
 +	if (pending & (SDMMC_IDMAC_INT_TI | SDMMC_IDMAC_INT_RI)) {
 +		mci_writel(host, IDSTS, SDMMC_IDMAC_INT_TI | SDMMC_IDMAC_INT_RI);
 +		mci_writel(host, IDSTS, SDMMC_IDMAC_INT_NI);
 +		host->dma_ops->complete(host);
++=======
+ 	if (host->use_dma != TRANS_MODE_IDMAC)
+ 		return IRQ_HANDLED;
+ 
+ 	/* Handle IDMA interrupts */
+ 	if (host->dma_64bit_address == 1) {
+ 		pending = mci_readl(host, IDSTS64);
+ 		if (pending & (SDMMC_IDMAC_INT_TI | SDMMC_IDMAC_INT_RI)) {
+ 			mci_writel(host, IDSTS64, SDMMC_IDMAC_INT_TI |
+ 							SDMMC_IDMAC_INT_RI);
+ 			mci_writel(host, IDSTS64, SDMMC_IDMAC_INT_NI);
+ 			host->dma_ops->complete((void *)host);
+ 		}
+ 	} else {
+ 		pending = mci_readl(host, IDSTS);
+ 		if (pending & (SDMMC_IDMAC_INT_TI | SDMMC_IDMAC_INT_RI)) {
+ 			mci_writel(host, IDSTS, SDMMC_IDMAC_INT_TI |
+ 							SDMMC_IDMAC_INT_RI);
+ 			mci_writel(host, IDSTS, SDMMC_IDMAC_INT_NI);
+ 			host->dma_ops->complete((void *)host);
+ 		}
++>>>>>>> 3fc7eaef44db (mmc: dw_mmc: Add external dma interface support)
  	}
- #endif
  
  	return IRQ_HANDLED;
  }
@@@ -2036,38 -2578,28 +2214,57 @@@ static int dw_mci_init_slot(struct dw_m
  	if (host->pdata->caps2)
  		mmc->caps2 = host->pdata->caps2;
  
 -	dw_mci_slot_of_parse(slot);
 +	if (host->pdata->get_bus_wd)
 +		bus_width = host->pdata->get_bus_wd(slot->id);
 +	else if (host->dev->of_node)
 +		bus_width = dw_mci_of_get_bus_wd(host->dev, slot->id);
 +	else
 +		bus_width = 1;
  
 -	ret = mmc_of_parse(mmc);
 -	if (ret)
 -		goto err_host_allocated;
 +	switch (bus_width) {
 +	case 8:
 +		mmc->caps |= MMC_CAP_8_BIT_DATA;
 +	case 4:
 +		mmc->caps |= MMC_CAP_4_BIT_DATA;
 +	}
 +
++<<<<<<< HEAD
 +	if (host->pdata->quirks & DW_MCI_QUIRK_HIGHSPEED)
 +		mmc->caps |= MMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED;
  
 +	if (host->pdata->blk_settings) {
 +		mmc->max_segs = host->pdata->blk_settings->max_segs;
 +		mmc->max_blk_size = host->pdata->blk_settings->max_blk_size;
 +		mmc->max_blk_count = host->pdata->blk_settings->max_blk_count;
 +		mmc->max_req_size = host->pdata->blk_settings->max_req_size;
 +		mmc->max_seg_size = host->pdata->blk_settings->max_seg_size;
 +	} else {
 +		/* Useful defaults if platform data is unset. */
 +#ifdef CONFIG_MMC_DW_IDMAC
++=======
+ 	/* Useful defaults if platform data is unset. */
+ 	if (host->use_dma == TRANS_MODE_IDMAC) {
++>>>>>>> 3fc7eaef44db (mmc: dw_mmc: Add external dma interface support)
  		mmc->max_segs = host->ring_size;
  		mmc->max_blk_size = 65536;
 +		mmc->max_blk_count = host->ring_size;
  		mmc->max_seg_size = 0x1000;
++<<<<<<< HEAD
 +		mmc->max_req_size = mmc->max_seg_size * mmc->max_blk_count;
 +#else
++=======
+ 		mmc->max_req_size = mmc->max_seg_size * host->ring_size;
+ 		mmc->max_blk_count = mmc->max_req_size / 512;
+ 	} else if (host->use_dma == TRANS_MODE_EDMAC) {
+ 		mmc->max_segs = 64;
+ 		mmc->max_blk_size = 65536;
+ 		mmc->max_blk_count = 65535;
+ 		mmc->max_req_size =
+ 				mmc->max_blk_size * mmc->max_blk_count;
+ 		mmc->max_seg_size = mmc->max_req_size;
+ 	} else {
+ 		/* TRANS_MODE_PIO */
++>>>>>>> 3fc7eaef44db (mmc: dw_mmc: Add external dma interface support)
  		mmc->max_segs = 64;
  		mmc->max_blk_size = 65536; /* BLKSIZ is 16 bits */
  		mmc->max_blk_count = 512;
@@@ -2121,12 -2638,28 +2318,37 @@@ static void dw_mci_cleanup_slot(struct 
  
  static void dw_mci_init_dma(struct dw_mci *host)
  {
++<<<<<<< HEAD
 +	/* Alloc memory for sg translation */
 +	host->sg_cpu = dmam_alloc_coherent(host->dev, PAGE_SIZE,
 +					  &host->sg_dma, GFP_KERNEL);
 +	if (!host->sg_cpu) {
 +		dev_err(host->dev, "%s: could not alloc DMA memory\n",
 +			__func__);
++=======
+ 	int addr_config;
+ 	struct device *dev = host->dev;
+ 	struct device_node *np = dev->of_node;
+ 
+ 	/*
+ 	* Check tansfer mode from HCON[17:16]
+ 	* Clear the ambiguous description of dw_mmc databook:
+ 	* 2b'00: No DMA Interface -> Actually means using Internal DMA block
+ 	* 2b'01: DesignWare DMA Interface -> Synopsys DW-DMA block
+ 	* 2b'10: Generic DMA Interface -> non-Synopsys generic DMA block
+ 	* 2b'11: Non DW DMA Interface -> pio only
+ 	* Compared to DesignWare DMA Interface, Generic DMA Interface has a
+ 	* simpler request/acknowledge handshake mechanism and both of them
+ 	* are regarded as external dma master for dw_mmc.
+ 	*/
+ 	host->use_dma = SDMMC_GET_TRANS_MODE(mci_readl(host, HCON));
+ 	if (host->use_dma == DMA_INTERFACE_IDMA) {
+ 		host->use_dma = TRANS_MODE_IDMAC;
+ 	} else if (host->use_dma == DMA_INTERFACE_DWDMA ||
+ 		   host->use_dma == DMA_INTERFACE_GDMA) {
+ 		host->use_dma = TRANS_MODE_EDMAC;
+ 	} else {
++>>>>>>> 3fc7eaef44db (mmc: dw_mmc: Add external dma interface support)
  		goto no_dma;
  	}
  
@@@ -2156,17 -2724,17 +2413,21 @@@
  
  no_dma:
  	dev_info(host->dev, "Using PIO mode.\n");
++<<<<<<< HEAD
 +	host->use_dma = 0;
 +	return;
++=======
+ 	host->use_dma = TRANS_MODE_PIO;
++>>>>>>> 3fc7eaef44db (mmc: dw_mmc: Add external dma interface support)
  }
  
 -static bool dw_mci_ctrl_reset(struct dw_mci *host, u32 reset)
 +static bool mci_wait_reset(struct device *dev, struct dw_mci *host)
  {
  	unsigned long timeout = jiffies + msecs_to_jiffies(500);
 -	u32 ctrl;
 +	unsigned int ctrl;
  
 -	ctrl = mci_readl(host, CTRL);
 -	ctrl |= reset;
 -	mci_writel(host, CTRL, ctrl);
 +	mci_writel(host, CTRL, (SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET |
 +				SDMMC_CTRL_DMA_RESET));
  
  	/* wait till resets clear */
  	do {
@@@ -2181,6 -2750,112 +2442,115 @@@
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ static bool dw_mci_reset(struct dw_mci *host)
+ {
+ 	u32 flags = SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET;
+ 	bool ret = false;
+ 
+ 	/*
+ 	 * Reseting generates a block interrupt, hence setting
+ 	 * the scatter-gather pointer to NULL.
+ 	 */
+ 	if (host->sg) {
+ 		sg_miter_stop(&host->sg_miter);
+ 		host->sg = NULL;
+ 	}
+ 
+ 	if (host->use_dma)
+ 		flags |= SDMMC_CTRL_DMA_RESET;
+ 
+ 	if (dw_mci_ctrl_reset(host, flags)) {
+ 		/*
+ 		 * In all cases we clear the RAWINTS register to clear any
+ 		 * interrupts.
+ 		 */
+ 		mci_writel(host, RINTSTS, 0xFFFFFFFF);
+ 
+ 		/* if using dma we wait for dma_req to clear */
+ 		if (host->use_dma) {
+ 			unsigned long timeout = jiffies + msecs_to_jiffies(500);
+ 			u32 status;
+ 
+ 			do {
+ 				status = mci_readl(host, STATUS);
+ 				if (!(status & SDMMC_STATUS_DMA_REQ))
+ 					break;
+ 				cpu_relax();
+ 			} while (time_before(jiffies, timeout));
+ 
+ 			if (status & SDMMC_STATUS_DMA_REQ) {
+ 				dev_err(host->dev,
+ 					"%s: Timeout waiting for dma_req to clear during reset\n",
+ 					__func__);
+ 				goto ciu_out;
+ 			}
+ 
+ 			/* when using DMA next we reset the fifo again */
+ 			if (!dw_mci_ctrl_reset(host, SDMMC_CTRL_FIFO_RESET))
+ 				goto ciu_out;
+ 		}
+ 	} else {
+ 		/* if the controller reset bit did clear, then set clock regs */
+ 		if (!(mci_readl(host, CTRL) & SDMMC_CTRL_RESET)) {
+ 			dev_err(host->dev,
+ 				"%s: fifo/dma reset bits didn't clear but ciu was reset, doing clock update\n",
+ 				__func__);
+ 			goto ciu_out;
+ 		}
+ 	}
+ 
+ 	if (host->use_dma == TRANS_MODE_IDMAC)
+ 		/* It is also recommended that we reset and reprogram idmac */
+ 		dw_mci_idmac_reset(host);
+ 
+ 	ret = true;
+ 
+ ciu_out:
+ 	/* After a CTRL reset we need to have CIU set clock registers  */
+ 	mci_send_cmd(host->cur_slot, SDMMC_CMD_UPD_CLK, 0);
+ 
+ 	return ret;
+ }
+ 
+ static void dw_mci_cmd11_timer(unsigned long arg)
+ {
+ 	struct dw_mci *host = (struct dw_mci *)arg;
+ 
+ 	if (host->state != STATE_SENDING_CMD11) {
+ 		dev_warn(host->dev, "Unexpected CMD11 timeout\n");
+ 		return;
+ 	}
+ 
+ 	host->cmd_status = SDMMC_INT_RTO;
+ 	set_bit(EVENT_CMD_COMPLETE, &host->pending_events);
+ 	tasklet_schedule(&host->tasklet);
+ }
+ 
+ static void dw_mci_dto_timer(unsigned long arg)
+ {
+ 	struct dw_mci *host = (struct dw_mci *)arg;
+ 
+ 	switch (host->state) {
+ 	case STATE_SENDING_DATA:
+ 	case STATE_DATA_BUSY:
+ 		/*
+ 		 * If DTO interrupt does NOT come in sending data state,
+ 		 * we should notify the driver to terminate current transfer
+ 		 * and report a data timeout to the core.
+ 		 */
+ 		host->data_status = SDMMC_INT_DRTO;
+ 		set_bit(EVENT_DATA_ERROR, &host->pending_events);
+ 		set_bit(EVENT_DATA_COMPLETE, &host->pending_events);
+ 		tasklet_schedule(&host->tasklet);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 3fc7eaef44db (mmc: dw_mmc: Add external dma interface support)
  #ifdef CONFIG_OF
  static struct dw_mci_of_quirks {
  	char *quirk;
@@@ -2543,25 -3223,8 +2913,30 @@@ EXPORT_SYMBOL(dw_mci_remove)
   */
  int dw_mci_suspend(struct dw_mci *host)
  {
++<<<<<<< HEAD
 +	int i, ret = 0;
 +
 +	for (i = 0; i < host->num_slots; i++) {
 +		struct dw_mci_slot *slot = host->slot[i];
 +		if (!slot)
 +			continue;
 +		ret = mmc_suspend_host(slot->mmc);
 +		if (ret < 0) {
 +			while (--i >= 0) {
 +				slot = host->slot[i];
 +				if (slot)
 +					mmc_resume_host(host->slot[i]->mmc);
 +			}
 +			return ret;
 +		}
 +	}
 +
 +	if (host->vmmc)
 +		regulator_disable(host->vmmc);
++=======
+ 	if (host->use_dma && host->dma_ops->exit)
+ 		host->dma_ops->exit(host);
++>>>>>>> 3fc7eaef44db (mmc: dw_mmc: Add external dma interface support)
  
  	return 0;
  }
diff --cc include/linux/mmc/dw_mmc.h
index a2d9a022a8fd,f67b2ec18e6d..000000000000
--- a/include/linux/mmc/dw_mmc.h
+++ b/include/linux/mmc/dw_mmc.h
@@@ -15,6 -15,8 +15,11 @@@
  #define LINUX_MMC_DW_MMC_H
  
  #include <linux/scatterlist.h>
++<<<<<<< HEAD
++=======
+ #include <linux/mmc/core.h>
+ #include <linux/dmaengine.h>
++>>>>>>> 3fc7eaef44db (mmc: dw_mmc: Add external dma interface support)
  
  #define MAX_MCI_SLOTS	2
  
@@@ -141,11 -166,14 +157,22 @@@ struct dw_mci 
  	dma_addr_t		sg_dma;
  	void			*sg_cpu;
  	const struct dw_mci_dma_ops	*dma_ops;
++<<<<<<< HEAD
 +#ifdef CONFIG_MMC_DW_IDMAC
 +	unsigned int		ring_size;
 +#else
 +	struct dw_mci_dma_data	*dma_data;
 +#endif
++=======
+ 	/* For idmac */
+ 	unsigned int		ring_size;
+ 
+ 	/* For edmac */
+ 	struct dw_mci_dma_slave *dms;
+ 	/* Registers's physical base address */
+ 	void                    *phy_regs;
+ 
++>>>>>>> 3fc7eaef44db (mmc: dw_mmc: Add external dma interface support)
  	u32			cmd_status;
  	u32			data_status;
  	u32			stop_cmdr;
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 616bd7b87bf6..a9decbde470c 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -590,15 +590,7 @@ config MMC_DW
 	help
 	  This selects support for the Synopsys DesignWare Mobile Storage IP
 	  block, this provides host support for SD and MMC interfaces, in both
-	  PIO and external DMA modes.
-
-config MMC_DW_IDMAC
-	bool "Internal DMAC interface"
-	depends on MMC_DW
-	help
-	  This selects support for the internal DMAC block within the Synopsys
-	  Designware Mobile Storage IP block. This disables the external DMA
-	  interface.
+	  PIO, internal DMA mode and external DMA mode.
 
 config MMC_DW_PLTFM
 	tristate "Synopsys Designware MCI Support as platform device"
* Unmerged path drivers/mmc/host/dw_mmc-pltfm.c
* Unmerged path drivers/mmc/host/dw_mmc.c
diff --git a/drivers/mmc/host/dw_mmc.h b/drivers/mmc/host/dw_mmc.h
index 7f05a02a5484..121cfcf50882 100644
--- a/drivers/mmc/host/dw_mmc.h
+++ b/drivers/mmc/host/dw_mmc.h
@@ -133,6 +133,12 @@
 #define SDMMC_SET_FIFOTH(m, r, t)	(((m) & 0x7) << 28 | \
 					 ((r) & 0xFFF) << 16 | \
 					 ((t) & 0xFFF))
+/* HCON register defines */
+#define DMA_INTERFACE_IDMA		(0x0)
+#define DMA_INTERFACE_DWDMA		(0x1)
+#define DMA_INTERFACE_GDMA		(0x2)
+#define DMA_INTERFACE_NODMA		(0x3)
+#define SDMMC_GET_TRANS_MODE(x)		(((x)>>16) & 0x3)
 /* Internal DMAC interrupt defines */
 #define SDMMC_IDMAC_INT_AI		BIT(9)
 #define SDMMC_IDMAC_INT_NI		BIT(8)
* Unmerged path include/linux/mmc/dw_mmc.h
