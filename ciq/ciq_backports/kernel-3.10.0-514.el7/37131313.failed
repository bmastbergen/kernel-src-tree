KVM: x86: add KVM_CAP_X2APIC_API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] kvm: add KVM_CAP_X2APIC_API (Radim Krcmar) [1273718]
Rebuild_FUZZ: 91.53%
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit 3713131345fbea291cbd859d248e06ed77815962
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/37131313.failed

KVM_CAP_X2APIC_API is a capability for features related to x2APIC
enablement.  KVM_X2APIC_API_32BIT_FORMAT feature can be enabled to
extend APIC ID in get/set ioctl and MSI addresses to 32 bits.
Both are needed to support x2APIC.

The feature has to be enableable and disabled by default, because
get/set ioctl shifted and truncated APIC ID to 8 bits by using a
non-standard protocol inspired by xAPIC and the change is not
backward-compatible.

Changes to MSI addresses follow the format used by interrupt remapping
unit.  The upper address word, that used to be 0, contains upper 24 bits
of the LAPIC address in its upper 24 bits.  Lower 8 bits are reserved as
0.  Using the upper address word is not backward-compatible either as we
didn't check that userspace zeroed the word.  Reserved bits are still
not explicitly checked, but non-zero data will affect LAPIC addresses,
which will cause a bug.

	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 3713131345fbea291cbd859d248e06ed77815962)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virtual/kvm/api.txt
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/irq_comm.c
#	arch/x86/kvm/lapic.c
#	arch/x86/kvm/vmx.c
#	arch/x86/kvm/x86.c
#	include/uapi/linux/kvm.h
diff --cc Documentation/virtual/kvm/api.txt
index d54a8098c59b,e34e51fa28b0..000000000000
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@@ -1428,8 -1482,25 +1428,23 @@@ struct kvm_irq_routing_msi 
  	__u32 pad;
  };
  
++<<<<<<< HEAD
++=======
+ On x86, address_hi is ignored unless the KVM_X2APIC_API_USE_32BIT_IDS
+ feature of KVM_CAP_X2APIC_API capability is enabled.  If it is enabled,
+ address_hi bits 31-8 provide bits 31-8 of the destination id.  Bits 7-0 of
+ address_hi must be zero.
+ 
+ struct kvm_irq_routing_s390_adapter {
+ 	__u64 ind_addr;
+ 	__u64 summary_addr;
+ 	__u64 ind_offset;
+ 	__u32 summary_offset;
+ 	__u32 adapter_id;
+ };
++>>>>>>> 3713131345fb (KVM: x86: add KVM_CAP_X2APIC_API)
  
 -struct kvm_irq_routing_hv_sint {
 -	__u32 vcpu;
 -	__u32 sint;
 -};
 -
 -4.53 KVM_ASSIGN_SET_MSIX_NR (deprecated)
 +4.53 KVM_ASSIGN_SET_MSIX_NR
  
  Capability: none
  Architectures: x86
@@@ -1531,9 -1613,13 +1557,13 @@@ struct kvm_lapic_state 
  	char regs[KVM_APIC_REG_SIZE];
  };
  
 -Copies the input argument into the Local APIC registers.  The data format
 +Copies the input argument into the the Local APIC registers.  The data format
  and layout are the same as documented in the architecture manual.
  
+ The format of the APIC ID register (bytes 32-35 of struct kvm_lapic_state's
+ regs field) depends on the state of the KVM_CAP_X2APIC_API capability.
+ See the note in KVM_GET_LAPIC.
+ 
  
  4.59 KVM_IOEVENTFD
  
@@@ -3081,3 -3747,136 +3115,139 @@@ userspace from doing that
  If the hcall number specified is not one that has an in-kernel
  implementation, the KVM_ENABLE_CAP ioctl will fail with an EINVAL
  error.
++<<<<<<< HEAD
++=======
+ 
+ 7.2 KVM_CAP_S390_USER_SIGP
+ 
+ Architectures: s390
+ Parameters: none
+ 
+ This capability controls which SIGP orders will be handled completely in user
+ space. With this capability enabled, all fast orders will be handled completely
+ in the kernel:
+ - SENSE
+ - SENSE RUNNING
+ - EXTERNAL CALL
+ - EMERGENCY SIGNAL
+ - CONDITIONAL EMERGENCY SIGNAL
+ 
+ All other orders will be handled completely in user space.
+ 
+ Only privileged operation exceptions will be checked for in the kernel (or even
+ in the hardware prior to interception). If this capability is not enabled, the
+ old way of handling SIGP orders is used (partially in kernel and user space).
+ 
+ 7.3 KVM_CAP_S390_VECTOR_REGISTERS
+ 
+ Architectures: s390
+ Parameters: none
+ Returns: 0 on success, negative value on error
+ 
+ Allows use of the vector registers introduced with z13 processor, and
+ provides for the synchronization between host and user space.  Will
+ return -EINVAL if the machine does not support vectors.
+ 
+ 7.4 KVM_CAP_S390_USER_STSI
+ 
+ Architectures: s390
+ Parameters: none
+ 
+ This capability allows post-handlers for the STSI instruction. After
+ initial handling in the kernel, KVM exits to user space with
+ KVM_EXIT_S390_STSI to allow user space to insert further data.
+ 
+ Before exiting to userspace, kvm handlers should fill in s390_stsi field of
+ vcpu->run:
+ struct {
+ 	__u64 addr;
+ 	__u8 ar;
+ 	__u8 reserved;
+ 	__u8 fc;
+ 	__u8 sel1;
+ 	__u16 sel2;
+ } s390_stsi;
+ 
+ @addr - guest address of STSI SYSIB
+ @fc   - function code
+ @sel1 - selector 1
+ @sel2 - selector 2
+ @ar   - access register number
+ 
+ KVM handlers should exit to userspace with rc = -EREMOTE.
+ 
+ 7.5 KVM_CAP_SPLIT_IRQCHIP
+ 
+ Architectures: x86
+ Parameters: args[0] - number of routes reserved for userspace IOAPICs
+ Returns: 0 on success, -1 on error
+ 
+ Create a local apic for each processor in the kernel. This can be used
+ instead of KVM_CREATE_IRQCHIP if the userspace VMM wishes to emulate the
+ IOAPIC and PIC (and also the PIT, even though this has to be enabled
+ separately).
+ 
+ This capability also enables in kernel routing of interrupt requests;
+ when KVM_CAP_SPLIT_IRQCHIP only routes of KVM_IRQ_ROUTING_MSI type are
+ used in the IRQ routing table.  The first args[0] MSI routes are reserved
+ for the IOAPIC pins.  Whenever the LAPIC receives an EOI for these routes,
+ a KVM_EXIT_IOAPIC_EOI vmexit will be reported to userspace.
+ 
+ Fails if VCPU has already been created, or if the irqchip is already in the
+ kernel (i.e. KVM_CREATE_IRQCHIP has already been called).
+ 
+ 7.6 KVM_CAP_S390_RI
+ 
+ Architectures: s390
+ Parameters: none
+ 
+ Allows use of runtime-instrumentation introduced with zEC12 processor.
+ Will return -EINVAL if the machine does not support runtime-instrumentation.
+ Will return -EBUSY if a VCPU has already been created.
+ 
+ 7.7 KVM_CAP_X2APIC_API
+ 
+ Architectures: x86
+ Parameters: args[0] - features that should be enabled
+ Returns: 0 on success, -EINVAL when args[0] contains invalid features
+ 
+ Valid feature flags in args[0] are
+ 
+ #define KVM_X2APIC_API_USE_32BIT_IDS            (1ULL << 0)
+ 
+ Enabling KVM_X2APIC_API_USE_32BIT_IDS changes the behavior of
+ KVM_SET_GSI_ROUTING, KVM_SIGNAL_MSI, KVM_SET_LAPIC, and KVM_GET_LAPIC,
+ allowing the use of 32-bit APIC IDs.  See KVM_CAP_X2APIC_API in their
+ respective sections.
+ 
+ 
+ 
+ 8. Other capabilities.
+ ----------------------
+ 
+ This section lists capabilities that give information about other
+ features of the KVM implementation.
+ 
+ 8.1 KVM_CAP_PPC_HWRNG
+ 
+ Architectures: ppc
+ 
+ This capability, if KVM_CHECK_EXTENSION indicates that it is
+ available, means that that the kernel has an implementation of the
+ H_RANDOM hypercall backed by a hardware random-number generator.
+ If present, the kernel H_RANDOM handler can be enabled for guest use
+ with the KVM_CAP_PPC_ENABLE_HCALL capability.
+ 
+ 8.2 KVM_CAP_HYPERV_SYNIC
+ 
+ Architectures: x86
+ This capability, if KVM_CHECK_EXTENSION indicates that it is
+ available, means that that the kernel has an implementation of the
+ Hyper-V Synthetic interrupt controller(SynIC). Hyper-V SynIC is
+ used to support Windows Hyper-V based guest paravirt drivers(VMBus).
+ 
+ In order to use SynIC, it has to be activated by setting this
+ capability via KVM_ENABLE_CAP ioctl on the vcpu fd. Note that this
+ will disable the use of APIC hardware virtualization even if supported
+ by the CPU, as it's incompatible with SynIC auto-EOI behavior.
++>>>>>>> 3713131345fb (KVM: x86: add KVM_CAP_X2APIC_API)
diff --cc arch/x86/include/asm/kvm_host.h
index 5d383a89c9d4,7c00ba3242d7..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -657,6 -772,18 +657,21 @@@ struct kvm_arch 
  	u32 bsp_vcpu_id;
  
  	u64 disabled_quirks;
++<<<<<<< HEAD
++=======
+ 
+ 	bool irqchip_split;
+ 	u8 nr_reserved_ioapic_pins;
+ 
+ 	bool disabled_lapic_found;
+ 
+ 	/* Struct members for AVIC */
+ 	u32 ldr_mode;
+ 	struct page *avic_logical_id_table_page;
+ 	struct page *avic_physical_id_table_page;
+ 
+ 	bool x2apic_format;
++>>>>>>> 3713131345fb (KVM: x86: add KVM_CAP_X2APIC_API)
  };
  
  struct kvm_vm_stat {
@@@ -1212,6 -1366,21 +1227,6 @@@ bool kvm_vcpu_is_bsp(struct kvm_vcpu *v
  bool kvm_intr_is_single_vcpu(struct kvm *kvm, struct kvm_lapic_irq *irq,
  			     struct kvm_vcpu **dest_vcpu);
  
- void kvm_set_msi_irq(struct kvm_kernel_irq_routing_entry *e,
+ void kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,
  		     struct kvm_lapic_irq *irq);
 -
 -static inline void kvm_arch_vcpu_blocking(struct kvm_vcpu *vcpu)
 -{
 -	if (kvm_x86_ops->vcpu_blocking)
 -		kvm_x86_ops->vcpu_blocking(vcpu);
 -}
 -
 -static inline void kvm_arch_vcpu_unblocking(struct kvm_vcpu *vcpu)
 -{
 -	if (kvm_x86_ops->vcpu_unblocking)
 -		kvm_x86_ops->vcpu_unblocking(vcpu);
 -}
 -
 -static inline void kvm_arch_vcpu_block_finish(struct kvm_vcpu *vcpu) {}
 -
  #endif /* _ASM_X86_KVM_HOST_H */
diff --cc arch/x86/kvm/irq_comm.c
index 6baa9b6a480d,25810b144b58..000000000000
--- a/arch/x86/kvm/irq_comm.c
+++ b/arch/x86/kvm/irq_comm.c
@@@ -259,7 -302,15 +275,10 @@@ int kvm_set_routing_entry(struct kvm_ke
  		e->msi.address_lo = ue->u.msi.address_lo;
  		e->msi.address_hi = ue->u.msi.address_hi;
  		e->msi.data = ue->u.msi.data;
+ 
+ 		if (kvm_msi_route_invalid(kvm, e))
+ 			goto out;
  		break;
 -	case KVM_IRQ_ROUTING_HV_SINT:
 -		e->set = kvm_hv_set_sint;
 -		e->hv_sint.vcpu = ue->u.hv_sint.vcpu;
 -		e->hv_sint.sint = ue->u.hv_sint.sint;
 -		break;
  	default:
  		goto out;
  	}
@@@ -327,3 -378,64 +346,67 @@@ int kvm_setup_default_irq_routing(struc
  	return kvm_set_irq_routing(kvm, default_routing,
  				   ARRAY_SIZE(default_routing), 0);
  }
++<<<<<<< HEAD
++=======
+ 
+ static const struct kvm_irq_routing_entry empty_routing[] = {};
+ 
+ int kvm_setup_empty_irq_routing(struct kvm *kvm)
+ {
+ 	return kvm_set_irq_routing(kvm, empty_routing, 0, 0);
+ }
+ 
+ void kvm_arch_post_irq_routing_update(struct kvm *kvm)
+ {
+ 	if (ioapic_in_kernel(kvm) || !irqchip_in_kernel(kvm))
+ 		return;
+ 	kvm_make_scan_ioapic_request(kvm);
+ }
+ 
+ void kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,
+ 			    ulong *ioapic_handled_vectors)
+ {
+ 	struct kvm *kvm = vcpu->kvm;
+ 	struct kvm_kernel_irq_routing_entry *entry;
+ 	struct kvm_irq_routing_table *table;
+ 	u32 i, nr_ioapic_pins;
+ 	int idx;
+ 
+ 	idx = srcu_read_lock(&kvm->irq_srcu);
+ 	table = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+ 	nr_ioapic_pins = min_t(u32, table->nr_rt_entries,
+ 			       kvm->arch.nr_reserved_ioapic_pins);
+ 	for (i = 0; i < nr_ioapic_pins; ++i) {
+ 		hlist_for_each_entry(entry, &table->map[i], link) {
+ 			struct kvm_lapic_irq irq;
+ 
+ 			if (entry->type != KVM_IRQ_ROUTING_MSI)
+ 				continue;
+ 
+ 			kvm_set_msi_irq(vcpu->kvm, entry, &irq);
+ 
+ 			if (irq.level && kvm_apic_match_dest(vcpu, NULL, 0,
+ 						irq.dest_id, irq.dest_mode))
+ 				__set_bit(irq.vector, ioapic_handled_vectors);
+ 		}
+ 	}
+ 	srcu_read_unlock(&kvm->irq_srcu, idx);
+ }
+ 
+ int kvm_arch_set_irq(struct kvm_kernel_irq_routing_entry *irq, struct kvm *kvm,
+ 		     int irq_source_id, int level, bool line_status)
+ {
+ 	switch (irq->type) {
+ 	case KVM_IRQ_ROUTING_HV_SINT:
+ 		return kvm_hv_set_sint(irq, kvm, irq_source_id, level,
+ 				       line_status);
+ 	default:
+ 		return -EWOULDBLOCK;
+ 	}
+ }
+ 
+ void kvm_arch_irq_routing_update(struct kvm *kvm)
+ {
+ 	kvm_hv_irq_routing_update(kvm);
+ }
++>>>>>>> 3713131345fb (KVM: x86: add KVM_CAP_X2APIC_API)
diff --cc arch/x86/kvm/lapic.c
index 8b28377e3167,d27a7829a4ce..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -1892,10 -1979,43 +1892,40 @@@ int kvm_get_apic_interrupt(struct kvm_v
  	return vector;
  }
  
++<<<<<<< HEAD
 +void kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,
 +		struct kvm_lapic_state *s)
++=======
+ static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,
+ 		struct kvm_lapic_state *s, bool set)
+ {
+ 	if (apic_x2apic_mode(vcpu->arch.apic)) {
+ 		u32 *id = (u32 *)(s->regs + APIC_ID);
+ 
+ 		if (vcpu->kvm->arch.x2apic_format) {
+ 			if (*id != vcpu->vcpu_id)
+ 				return -EINVAL;
+ 		} else {
+ 			if (set)
+ 				*id >>= 24;
+ 			else
+ 				*id <<= 24;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int kvm_apic_get_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
+ {
+ 	memcpy(s->regs, vcpu->arch.apic->regs, sizeof(*s));
+ 	return kvm_apic_state_fixup(vcpu, s, false);
+ }
+ 
+ int kvm_apic_set_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
++>>>>>>> 3713131345fb (KVM: x86: add KVM_CAP_X2APIC_API)
  {
  	struct kvm_lapic *apic = vcpu->arch.apic;
 -	int r;
 -
  
  	kvm_lapic_set_base(vcpu, vcpu->arch.apic_base);
  	/* set SPIV separately to get count of SW disabled APICs right */
diff --cc arch/x86/kvm/vmx.c
index 2a45db3ac9a4,b61cdadf8623..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -9854,6 -10922,243 +9854,246 @@@ static void vmx_enable_log_dirty_pt_mas
  	kvm_mmu_clear_dirty_pt_masked(kvm, memslot, offset, mask);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * This routine does the following things for vCPU which is going
+  * to be blocked if VT-d PI is enabled.
+  * - Store the vCPU to the wakeup list, so when interrupts happen
+  *   we can find the right vCPU to wake up.
+  * - Change the Posted-interrupt descriptor as below:
+  *      'NDST' <-- vcpu->pre_pcpu
+  *      'NV' <-- POSTED_INTR_WAKEUP_VECTOR
+  * - If 'ON' is set during this process, which means at least one
+  *   interrupt is posted for this vCPU, we cannot block it, in
+  *   this case, return 1, otherwise, return 0.
+  *
+  */
+ static int pi_pre_block(struct kvm_vcpu *vcpu)
+ {
+ 	unsigned long flags;
+ 	unsigned int dest;
+ 	struct pi_desc old, new;
+ 	struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+ 
+ 	if (!kvm_arch_has_assigned_device(vcpu->kvm) ||
+ 		!irq_remapping_cap(IRQ_POSTING_CAP))
+ 		return 0;
+ 
+ 	vcpu->pre_pcpu = vcpu->cpu;
+ 	spin_lock_irqsave(&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			  vcpu->pre_pcpu), flags);
+ 	list_add_tail(&vcpu->blocked_vcpu_list,
+ 		      &per_cpu(blocked_vcpu_on_cpu,
+ 		      vcpu->pre_pcpu));
+ 	spin_unlock_irqrestore(&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			       vcpu->pre_pcpu), flags);
+ 
+ 	do {
+ 		old.control = new.control = pi_desc->control;
+ 
+ 		/*
+ 		 * We should not block the vCPU if
+ 		 * an interrupt is posted for it.
+ 		 */
+ 		if (pi_test_on(pi_desc) == 1) {
+ 			spin_lock_irqsave(&per_cpu(blocked_vcpu_on_cpu_lock,
+ 					  vcpu->pre_pcpu), flags);
+ 			list_del(&vcpu->blocked_vcpu_list);
+ 			spin_unlock_irqrestore(
+ 					&per_cpu(blocked_vcpu_on_cpu_lock,
+ 					vcpu->pre_pcpu), flags);
+ 			vcpu->pre_pcpu = -1;
+ 
+ 			return 1;
+ 		}
+ 
+ 		WARN((pi_desc->sn == 1),
+ 		     "Warning: SN field of posted-interrupts "
+ 		     "is set before blocking\n");
+ 
+ 		/*
+ 		 * Since vCPU can be preempted during this process,
+ 		 * vcpu->cpu could be different with pre_pcpu, we
+ 		 * need to set pre_pcpu as the destination of wakeup
+ 		 * notification event, then we can find the right vCPU
+ 		 * to wakeup in wakeup handler if interrupts happen
+ 		 * when the vCPU is in blocked state.
+ 		 */
+ 		dest = cpu_physical_id(vcpu->pre_pcpu);
+ 
+ 		if (x2apic_enabled())
+ 			new.ndst = dest;
+ 		else
+ 			new.ndst = (dest << 8) & 0xFF00;
+ 
+ 		/* set 'NV' to 'wakeup vector' */
+ 		new.nv = POSTED_INTR_WAKEUP_VECTOR;
+ 	} while (cmpxchg(&pi_desc->control, old.control,
+ 			new.control) != old.control);
+ 
+ 	return 0;
+ }
+ 
+ static int vmx_pre_block(struct kvm_vcpu *vcpu)
+ {
+ 	if (pi_pre_block(vcpu))
+ 		return 1;
+ 
+ 	if (kvm_lapic_hv_timer_in_use(vcpu))
+ 		kvm_lapic_switch_to_sw_timer(vcpu);
+ 
+ 	return 0;
+ }
+ 
+ static void pi_post_block(struct kvm_vcpu *vcpu)
+ {
+ 	struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+ 	struct pi_desc old, new;
+ 	unsigned int dest;
+ 	unsigned long flags;
+ 
+ 	if (!kvm_arch_has_assigned_device(vcpu->kvm) ||
+ 		!irq_remapping_cap(IRQ_POSTING_CAP))
+ 		return;
+ 
+ 	do {
+ 		old.control = new.control = pi_desc->control;
+ 
+ 		dest = cpu_physical_id(vcpu->cpu);
+ 
+ 		if (x2apic_enabled())
+ 			new.ndst = dest;
+ 		else
+ 			new.ndst = (dest << 8) & 0xFF00;
+ 
+ 		/* Allow posting non-urgent interrupts */
+ 		new.sn = 0;
+ 
+ 		/* set 'NV' to 'notification vector' */
+ 		new.nv = POSTED_INTR_VECTOR;
+ 	} while (cmpxchg(&pi_desc->control, old.control,
+ 			new.control) != old.control);
+ 
+ 	if(vcpu->pre_pcpu != -1) {
+ 		spin_lock_irqsave(
+ 			&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			vcpu->pre_pcpu), flags);
+ 		list_del(&vcpu->blocked_vcpu_list);
+ 		spin_unlock_irqrestore(
+ 			&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			vcpu->pre_pcpu), flags);
+ 		vcpu->pre_pcpu = -1;
+ 	}
+ }
+ 
+ static void vmx_post_block(struct kvm_vcpu *vcpu)
+ {
+ 	if (kvm_x86_ops->set_hv_timer)
+ 		kvm_lapic_switch_to_hv_timer(vcpu);
+ 
+ 	pi_post_block(vcpu);
+ }
+ 
+ /*
+  * vmx_update_pi_irte - set IRTE for Posted-Interrupts
+  *
+  * @kvm: kvm
+  * @host_irq: host irq of the interrupt
+  * @guest_irq: gsi of the interrupt
+  * @set: set or unset PI
+  * returns 0 on success, < 0 on failure
+  */
+ static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,
+ 			      uint32_t guest_irq, bool set)
+ {
+ 	struct kvm_kernel_irq_routing_entry *e;
+ 	struct kvm_irq_routing_table *irq_rt;
+ 	struct kvm_lapic_irq irq;
+ 	struct kvm_vcpu *vcpu;
+ 	struct vcpu_data vcpu_info;
+ 	int idx, ret = -EINVAL;
+ 
+ 	if (!kvm_arch_has_assigned_device(kvm) ||
+ 		!irq_remapping_cap(IRQ_POSTING_CAP))
+ 		return 0;
+ 
+ 	idx = srcu_read_lock(&kvm->irq_srcu);
+ 	irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+ 	BUG_ON(guest_irq >= irq_rt->nr_rt_entries);
+ 
+ 	hlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {
+ 		if (e->type != KVM_IRQ_ROUTING_MSI)
+ 			continue;
+ 		/*
+ 		 * VT-d PI cannot support posting multicast/broadcast
+ 		 * interrupts to a vCPU, we still use interrupt remapping
+ 		 * for these kind of interrupts.
+ 		 *
+ 		 * For lowest-priority interrupts, we only support
+ 		 * those with single CPU as the destination, e.g. user
+ 		 * configures the interrupts via /proc/irq or uses
+ 		 * irqbalance to make the interrupts single-CPU.
+ 		 *
+ 		 * We will support full lowest-priority interrupt later.
+ 		 */
+ 
+ 		kvm_set_msi_irq(kvm, e, &irq);
+ 		if (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu)) {
+ 			/*
+ 			 * Make sure the IRTE is in remapped mode if
+ 			 * we don't handle it in posted mode.
+ 			 */
+ 			ret = irq_set_vcpu_affinity(host_irq, NULL);
+ 			if (ret < 0) {
+ 				printk(KERN_INFO
+ 				   "failed to back to remapped mode, irq: %u\n",
+ 				   host_irq);
+ 				goto out;
+ 			}
+ 
+ 			continue;
+ 		}
+ 
+ 		vcpu_info.pi_desc_addr = __pa(vcpu_to_pi_desc(vcpu));
+ 		vcpu_info.vector = irq.vector;
+ 
+ 		trace_kvm_pi_irte_update(vcpu->vcpu_id, host_irq, e->gsi,
+ 				vcpu_info.vector, vcpu_info.pi_desc_addr, set);
+ 
+ 		if (set)
+ 			ret = irq_set_vcpu_affinity(host_irq, &vcpu_info);
+ 		else {
+ 			/* suppress notification event before unposting */
+ 			pi_set_sn(vcpu_to_pi_desc(vcpu));
+ 			ret = irq_set_vcpu_affinity(host_irq, NULL);
+ 			pi_clear_sn(vcpu_to_pi_desc(vcpu));
+ 		}
+ 
+ 		if (ret < 0) {
+ 			printk(KERN_INFO "%s: failed to update PI IRTE\n",
+ 					__func__);
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	ret = 0;
+ out:
+ 	srcu_read_unlock(&kvm->irq_srcu, idx);
+ 	return ret;
+ }
+ 
+ static void vmx_setup_mce(struct kvm_vcpu *vcpu)
+ {
+ 	if (vcpu->arch.mcg_cap & MCG_LMCE_P)
+ 		to_vmx(vcpu)->msr_ia32_feature_control_valid_bits |=
+ 			FEATURE_CONTROL_LMCE;
+ 	else
+ 		to_vmx(vcpu)->msr_ia32_feature_control_valid_bits &=
+ 			~FEATURE_CONTROL_LMCE;
+ }
+ 
++>>>>>>> 3713131345fb (KVM: x86: add KVM_CAP_X2APIC_API)
  static struct kvm_x86_ops vmx_x86_ops = {
  	.cpu_has_kvm_support = cpu_has_kvm_support,
  	.disabled_by_bios = vmx_disabled_by_bios,
diff --cc arch/x86/kvm/x86.c
index 733894b44f8d,d86f563a6896..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -89,8 -90,11 +89,10 @@@ static u64 __read_mostly efer_reserved_
  #define VM_STAT(x) offsetof(struct kvm, stat.x), KVM_STAT_VM
  #define VCPU_STAT(x) offsetof(struct kvm_vcpu, stat.x), KVM_STAT_VCPU
  
+ #define KVM_X2APIC_API_VALID_FLAGS (KVM_X2APIC_API_USE_32BIT_IDS)
+ 
  static void update_cr8_intercept(struct kvm_vcpu *vcpu);
  static void process_nmi(struct kvm_vcpu *vcpu);
 -static void enter_smm(struct kvm_vcpu *vcpu);
  static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);
  
  struct kvm_x86_ops *kvm_x86_ops __read_mostly;
@@@ -3970,6 -3782,38 +3975,41 @@@ static int kvm_vm_ioctl_enable_cap(stru
  		kvm->arch.disabled_quirks = cap->args[0];
  		r = 0;
  		break;
++<<<<<<< HEAD
++=======
+ 	case KVM_CAP_SPLIT_IRQCHIP: {
+ 		mutex_lock(&kvm->lock);
+ 		r = -EINVAL;
+ 		if (cap->args[0] > MAX_NR_RESERVED_IOAPIC_PINS)
+ 			goto split_irqchip_unlock;
+ 		r = -EEXIST;
+ 		if (irqchip_in_kernel(kvm))
+ 			goto split_irqchip_unlock;
+ 		if (kvm->created_vcpus)
+ 			goto split_irqchip_unlock;
+ 		r = kvm_setup_empty_irq_routing(kvm);
+ 		if (r)
+ 			goto split_irqchip_unlock;
+ 		/* Pairs with irqchip_in_kernel. */
+ 		smp_wmb();
+ 		kvm->arch.irqchip_split = true;
+ 		kvm->arch.nr_reserved_ioapic_pins = cap->args[0];
+ 		r = 0;
+ split_irqchip_unlock:
+ 		mutex_unlock(&kvm->lock);
+ 		break;
+ 	}
+ 	case KVM_CAP_X2APIC_API:
+ 		r = -EINVAL;
+ 		if (cap->args[0] & ~KVM_X2APIC_API_VALID_FLAGS)
+ 			break;
+ 
+ 		if (cap->args[0] & KVM_X2APIC_API_USE_32BIT_IDS)
+ 			kvm->arch.x2apic_format = true;
+ 
+ 		r = 0;
+ 		break;
++>>>>>>> 3713131345fb (KVM: x86: add KVM_CAP_X2APIC_API)
  	default:
  		r = -EINVAL;
  		break;
diff --cc include/uapi/linux/kvm.h
index 39df9ac6ee22,f704403e19a0..000000000000
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@@ -682,6 -856,17 +682,20 @@@ struct kvm_ppc_smmu_info 
  #define KVM_CAP_DISABLE_QUIRKS 116
  #define KVM_CAP_X86_SMM 117
  #define KVM_CAP_MULTI_ADDRESS_SPACE 118
++<<<<<<< HEAD
++=======
+ #define KVM_CAP_GUEST_DEBUG_HW_BPS 119
+ #define KVM_CAP_GUEST_DEBUG_HW_WPS 120
+ #define KVM_CAP_SPLIT_IRQCHIP 121
+ #define KVM_CAP_IOEVENTFD_ANY_LENGTH 122
+ #define KVM_CAP_HYPERV_SYNIC 123
+ #define KVM_CAP_S390_RI 124
+ #define KVM_CAP_SPAPR_TCE_64 125
+ #define KVM_CAP_ARM_PMU_V3 126
+ #define KVM_CAP_VCPU_ATTRIBUTES 127
+ #define KVM_CAP_MAX_VCPU_ID 128
+ #define KVM_CAP_X2APIC_API 129
++>>>>>>> 3713131345fb (KVM: x86: add KVM_CAP_X2APIC_API)
  
  #ifdef KVM_CAP_IRQ_ROUTING
  
* Unmerged path Documentation/virtual/kvm/api.txt
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/irq_comm.c
* Unmerged path arch/x86/kvm/lapic.c
* Unmerged path arch/x86/kvm/vmx.c
* Unmerged path arch/x86/kvm/x86.c
diff --git a/include/trace/events/kvm.h b/include/trace/events/kvm.h
index d0ad285f79c2..ff4bcbc18032 100644
--- a/include/trace/events/kvm.h
+++ b/include/trace/events/kvm.h
@@ -148,8 +148,9 @@ TRACE_EVENT(kvm_msi_set_irq,
 		__entry->data		= data;
 	),
 
-	TP_printk("dst %u vec %u (%s|%s|%s%s)",
-		  (u8)(__entry->address >> 12), (u8)__entry->data,
+	TP_printk("dst %llx vec %u (%s|%s|%s%s)",
+		  (u8)(__entry->address >> 12) | ((__entry->address >> 32) & 0xffffff00),
+		  (u8)__entry->data,
 		  __print_symbolic((__entry->data >> 8 & 0x7), kvm_deliver_mode),
 		  (__entry->address & (1<<2)) ? "logical" : "physical",
 		  (__entry->data & (1<<15)) ? "level" : "edge",
* Unmerged path include/uapi/linux/kvm.h
