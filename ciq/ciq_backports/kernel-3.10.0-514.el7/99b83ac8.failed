KVM: nVMX: emulate the INVVPID instruction

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Wanpeng Li <wanpeng.li@hotmail.com>
commit 99b83ac893b84ed1a62ad6d1f2b6cc32026b9e85
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/99b83ac8.failed

Add the INVVPID instruction emulation.

	Reviewed-by: Wincy Van <fanwenyi0529@gmail.com>
	Signed-off-by: Wanpeng Li <wanpeng.li@hotmail.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 99b83ac893b84ed1a62ad6d1f2b6cc32026b9e85)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index dd100a1ff95e,9b6ab311d0bd..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -409,6 -425,24 +409,27 @@@ struct nested_vmx 
  
  	/* to migrate it to L2 if VM_ENTRY_LOAD_DEBUG_CONTROLS is off */
  	u64 vmcs01_debugctl;
++<<<<<<< HEAD
++=======
+ 
+ 	u32 nested_vmx_procbased_ctls_low;
+ 	u32 nested_vmx_procbased_ctls_high;
+ 	u32 nested_vmx_true_procbased_ctls_low;
+ 	u32 nested_vmx_secondary_ctls_low;
+ 	u32 nested_vmx_secondary_ctls_high;
+ 	u32 nested_vmx_pinbased_ctls_low;
+ 	u32 nested_vmx_pinbased_ctls_high;
+ 	u32 nested_vmx_exit_ctls_low;
+ 	u32 nested_vmx_exit_ctls_high;
+ 	u32 nested_vmx_true_exit_ctls_low;
+ 	u32 nested_vmx_entry_ctls_low;
+ 	u32 nested_vmx_entry_ctls_high;
+ 	u32 nested_vmx_true_entry_ctls_low;
+ 	u32 nested_vmx_misc_low;
+ 	u32 nested_vmx_misc_high;
+ 	u32 nested_vmx_ept_caps;
+ 	u32 nested_vmx_vpid_caps;
++>>>>>>> 99b83ac893b8 (KVM: nVMX: emulate the INVVPID instruction)
  };
  
  #define POSTED_INTR_ON  0
@@@ -2451,12 -2609,14 +2472,14 @@@ static __init void nested_vmx_setup_ctl
  		 * for single context invalidation. Hence, only advertise
  		 * support for global context invalidation.
  		 */
 -		vmx->nested.nested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT;
 +		nested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT;
  	} else
 -		vmx->nested.nested_vmx_ept_caps = 0;
 +		nested_vmx_ept_caps = 0;
  
+ 	vmx->nested.nested_vmx_vpid_caps = 0;
+ 
  	if (enable_unrestricted_guest)
 -		vmx->nested.nested_vmx_secondary_ctls_high |=
 +		nested_vmx_secondary_ctls_high |=
  			SECONDARY_EXEC_UNRESTRICTED_GUEST;
  
  	/* miscellaneous data */
diff --git a/arch/x86/include/asm/vmx.h b/arch/x86/include/asm/vmx.h
index b963514887da..5dc54293b12c 100644
--- a/arch/x86/include/asm/vmx.h
+++ b/arch/x86/include/asm/vmx.h
@@ -413,6 +413,7 @@ enum vmcs_field {
 #define VMX_EPT_EXTENT_CONTEXT_BIT		(1ull << 25)
 #define VMX_EPT_EXTENT_GLOBAL_BIT		(1ull << 26)
 
+#define VMX_VPID_INVVPID_BIT                    (1ull << 0) /* (32 - 32) */
 #define VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT      (1ull << 9) /* (41 - 32) */
 #define VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT      (1ull << 10) /* (42 - 32) */
 
* Unmerged path arch/x86/kvm/vmx.c
