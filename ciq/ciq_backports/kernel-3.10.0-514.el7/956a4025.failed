dm: fix sparse "unexpected unlock" warnings in ioctl code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mike Snitzer <snitzer@redhat.com>
commit 956a4025808df4abfe2fe25a11feb4c8f33fc336
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/956a4025.failed

Rename dm_get_live_table_for_ioctl to dm_grab_bdev_for_ioctl and have it
do the dm_{get,put}_live_table() rather than split those operations.

The dm_grab_bdev_for_ioctl() callers only care about the block_device
associated with a singleton DM device so there isn't any need to retain
a reference to the live DM table.  It is sufficient to:
1) dm_get_live_table()
2) bdgrab() the bdev associated with the singleton table's target
3) dm_put_live_table()
4) bdput() the bdev

	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 956a4025808df4abfe2fe25a11feb4c8f33fc336)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index 66c19dce3920,a712fd73a55f..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -557,18 -556,17 +557,32 @@@ static int dm_blk_getgeo(struct block_d
  	return dm_get_geometry(md, geo);
  }
  
++<<<<<<< HEAD
 +static int dm_blk_ioctl(struct block_device *bdev, fmode_t mode,
 +			unsigned int cmd, unsigned long arg)
++=======
+ static int dm_grab_bdev_for_ioctl(struct mapped_device *md,
+ 				  struct block_device **bdev,
+ 				  fmode_t *mode)
++>>>>>>> 956a4025808d (dm: fix sparse "unexpected unlock" warnings in ioctl code)
  {
 -	struct dm_target *tgt;
 +	struct mapped_device *md = bdev->bd_disk->private_data;
 +	int srcu_idx;
  	struct dm_table *map;
++<<<<<<< HEAD
 +	struct dm_target *tgt;
 +	int r = -ENOTTY;
 +
 +retry:
 +	map = dm_get_live_table(md, &srcu_idx);
 +
++=======
+ 	int srcu_idx, r;
+ 
+ retry:
+ 	r = -ENOTTY;
+ 	map = dm_get_live_table(md, &srcu_idx);
++>>>>>>> 956a4025808d (dm: fix sparse "unexpected unlock" warnings in ioctl code)
  	if (!map || !dm_table_get_size(map))
  		goto out;
  
@@@ -585,16 -583,47 +599,57 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	r = tgt->type->ioctl(tgt, cmd, arg);
 +
 +out:
 +	dm_put_live_table(md, srcu_idx);
 +
 +	if (r == -ENOTCONN) {
++=======
+ 	r = tgt->type->prepare_ioctl(tgt, bdev, mode);
+ 	if (r < 0)
+ 		goto out;
+ 
+ 	bdgrab(*bdev);
+ 	dm_put_live_table(md, srcu_idx);
+ 	return r;
+ 
+ out:
+ 	dm_put_live_table(md, srcu_idx);
+ 	if (r == -ENOTCONN && !fatal_signal_pending(current)) {
++>>>>>>> 956a4025808d (dm: fix sparse "unexpected unlock" warnings in ioctl code)
  		msleep(10);
  		goto retry;
  	}
 -	return r;
 -}
  
++<<<<<<< HEAD
++=======
+ static int dm_blk_ioctl(struct block_device *bdev, fmode_t mode,
+ 			unsigned int cmd, unsigned long arg)
+ {
+ 	struct mapped_device *md = bdev->bd_disk->private_data;
+ 	int r;
+ 
+ 	r = dm_grab_bdev_for_ioctl(md, &bdev, &mode);
+ 	if (r < 0)
+ 		return r;
+ 
+ 	if (r > 0) {
+ 		/*
+ 		 * Target determined this ioctl is being issued against
+ 		 * a logical partition of the parent bdev; so extra
+ 		 * validation is needed.
+ 		 */
+ 		r = scsi_verify_blk_ioctl(NULL, cmd);
+ 		if (r)
+ 			goto out;
+ 	}
+ 
+ 	r =  __blkdev_driver_ioctl(bdev, mode, cmd, arg);
+ out:
+ 	bdput(bdev);
++>>>>>>> 956a4025808d (dm: fix sparse "unexpected unlock" warnings in ioctl code)
  	return r;
  }
  
@@@ -3755,11 -3558,10 +3810,15 @@@ static int dm_pr_register(struct block_
  {
  	struct mapped_device *md = bdev->bd_disk->private_data;
  	const struct pr_ops *ops;
 +	struct dm_target *tgt;
  	fmode_t mode;
- 	int srcu_idx, r;
+ 	int r;
  
++<<<<<<< HEAD
 +	r = dm_get_live_table_for_ioctl(md, &tgt, &bdev, &mode, &srcu_idx);
++=======
+ 	r = dm_grab_bdev_for_ioctl(md, &bdev, &mode);
++>>>>>>> 956a4025808d (dm: fix sparse "unexpected unlock" warnings in ioctl code)
  	if (r < 0)
  		return r;
  
@@@ -3778,11 -3580,10 +3837,15 @@@ static int dm_pr_reserve(struct block_d
  {
  	struct mapped_device *md = bdev->bd_disk->private_data;
  	const struct pr_ops *ops;
 +	struct dm_target *tgt;
  	fmode_t mode;
- 	int srcu_idx, r;
+ 	int r;
  
++<<<<<<< HEAD
 +	r = dm_get_live_table_for_ioctl(md, &tgt, &bdev, &mode, &srcu_idx);
++=======
+ 	r = dm_grab_bdev_for_ioctl(md, &bdev, &mode);
++>>>>>>> 956a4025808d (dm: fix sparse "unexpected unlock" warnings in ioctl code)
  	if (r < 0)
  		return r;
  
@@@ -3800,11 -3601,10 +3863,15 @@@ static int dm_pr_release(struct block_d
  {
  	struct mapped_device *md = bdev->bd_disk->private_data;
  	const struct pr_ops *ops;
 +	struct dm_target *tgt;
  	fmode_t mode;
- 	int srcu_idx, r;
+ 	int r;
  
++<<<<<<< HEAD
 +	r = dm_get_live_table_for_ioctl(md, &tgt, &bdev, &mode, &srcu_idx);
++=======
+ 	r = dm_grab_bdev_for_ioctl(md, &bdev, &mode);
++>>>>>>> 956a4025808d (dm: fix sparse "unexpected unlock" warnings in ioctl code)
  	if (r < 0)
  		return r;
  
@@@ -3823,11 -3623,10 +3890,15 @@@ static int dm_pr_preempt(struct block_d
  {
  	struct mapped_device *md = bdev->bd_disk->private_data;
  	const struct pr_ops *ops;
 +	struct dm_target *tgt;
  	fmode_t mode;
- 	int srcu_idx, r;
+ 	int r;
  
++<<<<<<< HEAD
 +	r = dm_get_live_table_for_ioctl(md, &tgt, &bdev, &mode, &srcu_idx);
++=======
+ 	r = dm_grab_bdev_for_ioctl(md, &bdev, &mode);
++>>>>>>> 956a4025808d (dm: fix sparse "unexpected unlock" warnings in ioctl code)
  	if (r < 0)
  		return r;
  
@@@ -3845,11 -3644,10 +3916,15 @@@ static int dm_pr_clear(struct block_dev
  {
  	struct mapped_device *md = bdev->bd_disk->private_data;
  	const struct pr_ops *ops;
 +	struct dm_target *tgt;
  	fmode_t mode;
- 	int srcu_idx, r;
+ 	int r;
  
++<<<<<<< HEAD
 +	r = dm_get_live_table_for_ioctl(md, &tgt, &bdev, &mode, &srcu_idx);
++=======
+ 	r = dm_grab_bdev_for_ioctl(md, &bdev, &mode);
++>>>>>>> 956a4025808d (dm: fix sparse "unexpected unlock" warnings in ioctl code)
  	if (r < 0)
  		return r;
  
* Unmerged path drivers/md/dm.c
