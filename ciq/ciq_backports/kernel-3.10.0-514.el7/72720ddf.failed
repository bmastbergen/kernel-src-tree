IB/hfi1: Fix minor format error

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ira Weiny <ira.weiny@intel.com>
commit 72720ddfc6d2256d62c4d8a644cf2ac54a27af90
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/72720ddf.failed

Brackets should be on the next line of a function

	Reviewed-by: Dean Luick <dean.luick@intel.com>
	Signed-off-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 72720ddfc6d2256d62c4d8a644cf2ac54a27af90)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/user_sdma.c
diff --cc drivers/staging/hfi1/user_sdma.c
index 1bbea48cb011,86c28851491c..000000000000
--- a/drivers/staging/hfi1/user_sdma.c
+++ b/drivers/staging/hfi1/user_sdma.c
@@@ -1039,40 -1088,144 +1039,69 @@@ static inline int num_user_pages(const 
  	return 1 + ((epage - spage) >> PAGE_SHIFT);
  }
  
 -static u32 sdma_cache_evict(struct hfi1_user_sdma_pkt_q *pq, u32 npages)
 -{
 -	u32 cleared = 0;
 -	struct sdma_mmu_node *node, *ptr;
 -	struct list_head to_evict = LIST_HEAD_INIT(to_evict);
 -
 -	spin_lock(&pq->evict_lock);
 -	list_for_each_entry_safe_reverse(node, ptr, &pq->evict, list) {
 -		/* Make sure that no one is still using the node. */
 -		if (!atomic_read(&node->refcount)) {
 -			set_bit(SDMA_CACHE_NODE_EVICT, &node->flags);
 -			list_del_init(&node->list);
 -			list_add(&node->list, &to_evict);
 -			cleared += node->npages;
 -			if (cleared >= npages)
 -				break;
 -		}
 -	}
 -	spin_unlock(&pq->evict_lock);
 -
 -	list_for_each_entry_safe(node, ptr, &to_evict, list)
 -		hfi1_mmu_rb_remove(&pq->sdma_rb_root, &node->rb);
 -
 -	return cleared;
 -}
 -
  static int pin_vector_pages(struct user_sdma_request *req,
++<<<<<<< HEAD:drivers/staging/hfi1/user_sdma.c
 +			    struct user_sdma_iovec *iovec) {
 +	int pinned, npages;
++=======
+ 			    struct user_sdma_iovec *iovec)
+ {
+ 	int ret = 0, pinned, npages, cleared;
+ 	struct page **pages;
+ 	struct hfi1_user_sdma_pkt_q *pq = req->pq;
+ 	struct sdma_mmu_node *node = NULL;
+ 	struct mmu_rb_node *rb_node;
+ 
+ 	rb_node = hfi1_mmu_rb_extract(&pq->sdma_rb_root,
+ 				      (unsigned long)iovec->iov.iov_base,
+ 				      iovec->iov.iov_len);
+ 	if (rb_node && !IS_ERR(rb_node))
+ 		node = container_of(rb_node, struct sdma_mmu_node, rb);
+ 	else
+ 		rb_node = NULL;
+ 
+ 	if (!node) {
+ 		node = kzalloc(sizeof(*node), GFP_KERNEL);
+ 		if (!node)
+ 			return -ENOMEM;
+ 
+ 		node->rb.addr = (unsigned long)iovec->iov.iov_base;
+ 		node->pq = pq;
+ 		atomic_set(&node->refcount, 0);
+ 		INIT_LIST_HEAD(&node->list);
+ 	}
++>>>>>>> 72720ddfc6d2 (IB/hfi1: Fix minor format error):drivers/infiniband/hw/hfi1/user_sdma.c
  
  	npages = num_user_pages(&iovec->iov);
 -	if (node->npages < npages) {
 -		pages = kcalloc(npages, sizeof(*pages), GFP_KERNEL);
 -		if (!pages) {
 -			SDMA_DBG(req, "Failed page array alloc");
 -			ret = -ENOMEM;
 -			goto bail;
 -		}
 -		memcpy(pages, node->pages, node->npages * sizeof(*pages));
 +	iovec->pages = kcalloc(npages, sizeof(*iovec->pages), GFP_KERNEL);
 +	if (!iovec->pages) {
 +		SDMA_DBG(req, "Failed page array alloc");
 +		return -ENOMEM;
 +	}
  
 -		npages -= node->npages;
 +	pinned = hfi1_acquire_user_pages((unsigned long)iovec->iov.iov_base,
 +					 npages, 0, iovec->pages);
  
 -		/*
 -		 * If rb_node is NULL, it means that this is brand new node
 -		 * and, therefore not on the eviction list.
 -		 * If, however, the rb_node is non-NULL, it means that the
 -		 * node is already in RB tree and, therefore on the eviction
 -		 * list (nodes are unconditionally inserted in the eviction
 -		 * list). In that case, we have to remove the node prior to
 -		 * calling the eviction function in order to prevent it from
 -		 * freeing this node.
 -		 */
 -		if (rb_node) {
 -			spin_lock(&pq->evict_lock);
 -			list_del_init(&node->list);
 -			spin_unlock(&pq->evict_lock);
 -		}
 -retry:
 -		if (!hfi1_can_pin_pages(pq->dd, pq->n_locked, npages)) {
 -			cleared = sdma_cache_evict(pq, npages);
 -			if (cleared >= npages)
 -				goto retry;
 -		}
 -		pinned = hfi1_acquire_user_pages(
 -			((unsigned long)iovec->iov.iov_base +
 -			 (node->npages * PAGE_SIZE)), npages, 0,
 -			pages + node->npages);
 -		if (pinned < 0) {
 -			kfree(pages);
 -			ret = pinned;
 -			goto bail;
 -		}
 -		if (pinned != npages) {
 -			unpin_vector_pages(current->mm, pages, node->npages,
 -					   pinned);
 -			ret = -EFAULT;
 -			goto bail;
 -		}
 -		kfree(node->pages);
 -		node->rb.len = iovec->iov.iov_len;
 -		node->pages = pages;
 -		node->npages += pinned;
 -		npages = node->npages;
 -		spin_lock(&pq->evict_lock);
 -		list_add(&node->list, &pq->evict);
 -		pq->n_locked += pinned;
 -		spin_unlock(&pq->evict_lock);
 -	}
 -	iovec->pages = node->pages;
 -	iovec->npages = npages;
 -	iovec->node = node;
 +	if (pinned < 0)
 +		return pinned;
  
 -	ret = hfi1_mmu_rb_insert(&req->pq->sdma_rb_root, &node->rb);
 -	if (ret) {
 -		spin_lock(&pq->evict_lock);
 -		if (!list_empty(&node->list))
 -			list_del(&node->list);
 -		pq->n_locked -= node->npages;
 -		spin_unlock(&pq->evict_lock);
 -		goto bail;
 +	iovec->npages = pinned;
 +	if (pinned != npages) {
 +		SDMA_DBG(req, "Failed to pin pages (%d/%u)", pinned, npages);
 +		unpin_vector_pages(iovec);
 +		return -EFAULT;
  	}
  	return 0;
 -bail:
 -	if (rb_node)
 -		unpin_vector_pages(current->mm, node->pages, 0, node->npages);
 -	kfree(node);
 -	return ret;
  }
  
 -static void unpin_vector_pages(struct mm_struct *mm, struct page **pages,
 -			       unsigned start, unsigned npages)
 +static void unpin_vector_pages(struct user_sdma_iovec *iovec)
  {
 -	hfi1_release_user_pages(mm, pages + start, npages, 0);
 -	kfree(pages);
 +	hfi1_release_user_pages(iovec->pages, iovec->npages, 0);
 +
 +	kfree(iovec->pages);
 +	iovec->pages = NULL;
 +	iovec->npages = 0;
 +	iovec->offset = 0;
  }
  
  static int check_header_template(struct user_sdma_request *req,
* Unmerged path drivers/staging/hfi1/user_sdma.c
