mei: fix kernel-doc warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit ce23139c6c2ee92d5eace20f6f10d716cf295a5b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ce23139c.failed

Add missed parameters descriptions and return values descriptions

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit ce23139c6c2ee92d5eace20f6f10d716cf295a5b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/client.c
#	drivers/misc/mei/debugfs.c
#	drivers/misc/mei/hw-me.c
#	drivers/misc/mei/hw-me.h
#	drivers/misc/mei/hw-txe.c
#	drivers/misc/mei/hw.h
#	drivers/misc/mei/init.c
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/client.c
index 22a9268f24eb,bc9ba5359bc6..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -719,8 -760,9 +723,9 @@@ int mei_cl_flow_ctrl_reduce(struct mei_
   * mei_cl_read_start - the start read client message function.
   *
   * @cl: host client
+  * @length: number of bytes to read
   *
 - * Return: 0 on success, <0 on failure.
 + * returns 0 on success, <0 on failure.
   */
  int mei_cl_read_start(struct mei_cl *cl, size_t length)
  {
@@@ -876,12 -917,13 +881,17 @@@ int mei_cl_irq_write(struct mei_cl *cl
  
  /**
   * mei_cl_write - submit a write cb to mei device
 - *	assumes device_lock is locked
 +	assumes device_lock is locked
   *
   * @cl: host client
++<<<<<<< HEAD
 + * @cl: write callback with filled data
++=======
+  * @cb: write callback with filled data
+  * @blocking: block until completed
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
   *
 - * Return: number of bytes sent on success, <0 on failure.
 + * returns number of bytes sent on success, <0 on failure.
   */
  int mei_cl_write(struct mei_cl *cl, struct mei_cl_cb *cb, bool blocking)
  {
diff --cc drivers/misc/mei/debugfs.c
index 85d1d2217fb8,ce1566715f80..000000000000
--- a/drivers/misc/mei/debugfs.c
+++ b/drivers/misc/mei/debugfs.c
@@@ -165,8 -173,12 +165,15 @@@ void mei_dbgfs_deregister(struct mei_de
  }
  
  /**
 - * mei_dbgfs_register - Add the debugfs files
 + * Add the debugfs files
   *
++<<<<<<< HEAD
++=======
+  * @dev: the mei device structure
+  * @name: the mei device name
+  *
+  * Return: 0 on success, <0 on failure.
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
   */
  int mei_dbgfs_register(struct mei_device *dev, const char *name)
  {
diff --cc drivers/misc/mei/hw-me.c
index 241eae550b0c,4f2fd6fc1e23..000000000000
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@@ -93,7 -93,8 +93,12 @@@ static inline u32 mei_hcsr_read(const s
   * mei_hcsr_set - writes H_CSR register to the mei device,
   * and ignores the H_IS bit for it is write-one-to-zero.
   *
++<<<<<<< HEAD
 + * @dev: the device structure
++=======
+  * @hw: the me hardware structure
+  * @hcsr: new register value
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
   */
  static inline void mei_hcsr_set(struct mei_me_hw *hw, u32 hcsr)
  {
@@@ -101,6 -102,36 +106,39 @@@
  	mei_me_reg_write(hw, H_CSR, hcsr);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * mei_me_fw_status - read fw status register from pci config space
+  *
+  * @dev: mei device
+  * @fw_status: fw status register values
+  *
+  * Return: 0 on success, error otherwise
+  */
+ static int mei_me_fw_status(struct mei_device *dev,
+ 			    struct mei_fw_status *fw_status)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev->dev);
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 	const struct mei_fw_status *fw_src = &hw->cfg->fw_status;
+ 	int ret;
+ 	int i;
+ 
+ 	if (!fw_status)
+ 		return -EINVAL;
+ 
+ 	fw_status->count = fw_src->count;
+ 	for (i = 0; i < fw_src->count && i < MEI_FW_STATUS_MAX; i++) {
+ 		ret = pci_read_config_dword(pdev,
+ 			fw_src->status[i], &fw_status->status[i]);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
  
  /**
   * mei_me_hw_config - configure hw dependent settings
diff --cc drivers/misc/mei/hw-me.h
index 98ceac2cee68,e6a59a62573a..000000000000
--- a/drivers/misc/mei/hw-me.h
+++ b/drivers/misc/mei/hw-me.h
@@@ -24,7 -26,37 +24,39 @@@
  #include "mei_dev.h"
  #include "client.h"
  
++<<<<<<< HEAD
++=======
+ /*
+  * mei_cfg - mei device configuration
+  *
+  * @fw_status: FW status
+  * @quirk_probe: device exclusion quirk
+  */
+ struct mei_cfg {
+ 	const struct mei_fw_status fw_status;
+ 	bool (*quirk_probe)(struct pci_dev *pdev);
+ };
+ 
+ 
+ #define MEI_PCI_DEVICE(dev, cfg) \
+ 	.vendor = PCI_VENDOR_ID_INTEL, .device = (dev), \
+ 	.subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID, \
+ 	.driver_data = (kernel_ulong_t)&(cfg)
+ 
+ 
+ #define MEI_ME_RPM_TIMEOUT    500 /* ms */
+ 
+ /**
+  * struct mei_me_hw - me hw specific data
+  *
+  * @cfg: per device generation config and ops
+  * @mem_addr:  io memory address
+  * @host_hw_state: cached host state
+  * @me_hw_state:   cached me (fw) state
+  * @pg_state:      power gating state
+  */
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
  struct mei_me_hw {
 -	const struct mei_cfg *cfg;
  	void __iomem *mem_addr;
  	/*
  	 * hw states of host and fw(ME)
diff --cc drivers/misc/mei/hw-txe.c
index f1cd166094f2,d3cf042fc509..000000000000
--- a/drivers/misc/mei/hw-txe.c
+++ b/drivers/misc/mei/hw-txe.c
@@@ -274,8 -290,9 +286,9 @@@ static int mei_txe_aliveness_wait(struc
   * mei_txe_aliveness_set_sync - sets an wait for aliveness to complete
   *
   * @dev: the device structure
+  * @req: requested aliveness value
   *
 - * Return: 0 on success and < 0 otherwise
 + * returns returns 0 on success and < 0 otherwise
   */
  int mei_txe_aliveness_set_sync(struct mei_device *dev, u32 req)
  {
@@@ -559,6 -601,42 +582,45 @@@ static int mei_txe_readiness_wait(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ const struct mei_fw_status mei_txe_fw_sts = {
+ 	.count = 2,
+ 	.status[0] = PCI_CFG_TXE_FW_STS0,
+ 	.status[1] = PCI_CFG_TXE_FW_STS1
+ };
+ 
+ /**
+  * mei_txe_fw_status - read fw status register from pci config space
+  *
+  * @dev: mei device
+  * @fw_status: fw status register values
+  *
+  * Return: 0 on success, error otherwise
+  */
+ static int mei_txe_fw_status(struct mei_device *dev,
+ 			     struct mei_fw_status *fw_status)
+ {
+ 	const struct mei_fw_status *fw_src = &mei_txe_fw_sts;
+ 	struct pci_dev *pdev = to_pci_dev(dev->dev);
+ 	int ret;
+ 	int i;
+ 
+ 	if (!fw_status)
+ 		return -EINVAL;
+ 
+ 	fw_status->count = fw_src->count;
+ 	for (i = 0; i < fw_src->count && i < MEI_FW_STATUS_MAX; i++) {
+ 		ret = pci_read_config_dword(pdev,
+ 			fw_src->status[i], &fw_status->status[i]);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
  /**
   *  mei_txe_hw_config - configure hardware at the start of the devices
   *
@@@ -588,7 -667,8 +650,12 @@@ static void mei_txe_hw_config(struct me
   * @dev: the device structure
   * @header: header of message
   * @buf: message buffer will be written
++<<<<<<< HEAD
 + * returns 1 if success, 0 - otherwise.
++=======
+  *
+  * Return: 0 if success, <0 - otherwise.
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
   */
  
  static int mei_txe_write(struct mei_device *dev,
@@@ -653,7 -735,7 +720,11 @@@
   *
   * @dev: the device structure
   *
++<<<<<<< HEAD
 + * returns the PAYLOAD_SIZE - 4
++=======
+  * Return: the PAYLOAD_SIZE - 4
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
   */
  static size_t mei_txe_hbuf_max_len(const struct mei_device *dev)
  {
@@@ -801,7 -884,7 +872,11 @@@ static int mei_txe_hw_reset(struct mei_
   *
   * @dev: the device structure
   *
++<<<<<<< HEAD
 + * returns 0 on success and < 0 in case of error
++=======
+  * Return: 0 on success an error code otherwise
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
   */
  static int mei_txe_hw_start(struct mei_device *dev)
  {
@@@ -930,8 -1016,7 +1007,12 @@@ irqreturn_t mei_txe_irq_quick_handler(i
   * @irq: The irq number
   * @dev_id: pointer to the device structure
   *
++<<<<<<< HEAD
 + * returns irqreturn_t
 + *
++=======
+  * Return: IRQ_HANDLED
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
   */
  irqreturn_t mei_txe_irq_thread_handler(int irq, void *dev_id)
  {
@@@ -1085,14 -1161,11 +1166,19 @@@ const struct mei_cfg mei_txe_cfg = 
  /**
   * mei_txe_dev_init - allocates and initializes txe hardware specific structure
   *
++<<<<<<< HEAD
 + * @pdev - pci device
 + * @cfg - per device generation config
 + *
 + * returns struct mei_device * on success or NULL;
++=======
+  * @pdev: pci device
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
   *
+  * Return: struct mei_device * on success or NULL
   */
 -struct mei_device *mei_txe_dev_init(struct pci_dev *pdev)
 +struct mei_device *mei_txe_dev_init(struct pci_dev *pdev,
 +				    const struct mei_cfg *cfg)
  {
  	struct mei_device *dev;
  	struct mei_txe_hw *hw;
diff --cc drivers/misc/mei/hw.h
index 50526f92f092,16fef6dc4dd7..000000000000
--- a/drivers/misc/mei/hw.h
+++ b/drivers/misc/mei/hw.h
@@@ -97,6 -97,35 +97,38 @@@ enum mei_stop_reason_types 
  	SYSTEM_S5_ENTRY = 0x08
  };
  
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * enum mei_hbm_status  - mei host bus messages return values
+  *
+  * @MEI_HBMS_SUCCESS           : status success
+  * @MEI_HBMS_CLIENT_NOT_FOUND  : client not found
+  * @MEI_HBMS_ALREADY_EXISTS    : connection already established
+  * @MEI_HBMS_REJECTED          : connection is rejected
+  * @MEI_HBMS_INVALID_PARAMETER : invalid parameter
+  * @MEI_HBMS_NOT_ALLOWED       : operation not allowed
+  * @MEI_HBMS_ALREADY_STARTED   : system is already started
+  * @MEI_HBMS_NOT_STARTED       : system not started
+  *
+  * @MEI_HBMS_MAX               : sentinel
+  */
+ enum mei_hbm_status {
+ 	MEI_HBMS_SUCCESS           = 0,
+ 	MEI_HBMS_CLIENT_NOT_FOUND  = 1,
+ 	MEI_HBMS_ALREADY_EXISTS    = 2,
+ 	MEI_HBMS_REJECTED          = 3,
+ 	MEI_HBMS_INVALID_PARAMETER = 4,
+ 	MEI_HBMS_NOT_ALLOWED       = 5,
+ 	MEI_HBMS_ALREADY_STARTED   = 6,
+ 	MEI_HBMS_NOT_STARTED       = 7,
+ 
+ 	MEI_HBMS_MAX
+ };
+ 
+ 
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
  /*
   * Client Connect Status
   * used by hbm_client_connect_response.status
diff --cc drivers/misc/mei/init.c
index 08331e745faf,7901d076c127..000000000000
--- a/drivers/misc/mei/init.c
+++ b/drivers/misc/mei/init.c
@@@ -57,11 -56,9 +57,14 @@@ const char *mei_pg_state_str(enum mei_p
  
  
  /**
 - * mei_cancel_work - Cancel mei background jobs
 + * mei_cancel_work. Cancel mei background jobs
   *
   * @dev: the device structure
++<<<<<<< HEAD
 + *
 + * returns 0 on success or < 0 if the reset hasn't succeeded
++=======
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
   */
  void mei_cancel_work(struct mei_device *dev)
  {
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,71744b16cc8c..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -189,8 -186,15 +189,20 @@@ struct mei_cl
  /**
   * struct mei_cl_cb - file operation callback structure
   *
++<<<<<<< HEAD
 + * @cl - file client who is running this operation
 + * @fop_type - file operation type
++=======
+  * @list: link in callback queue
+  * @cl: file client who is running this operation
+  * @fop_type: file operation type
+  * @request_buffer: buffer to store request data
+  * @response_buffer: buffer to store response data
+  * @buf_idx: last read index
+  * @read_time: last read operation time stamp (iamthif)
+  * @file_object: pointer to file structure
+  * @internal: communication between driver and FW flag
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
   */
  struct mei_cl_cb {
  	struct list_head list;
@@@ -213,7 -239,7 +247,11 @@@ struct mei_cl 
  	wait_queue_head_t rx_wait;
  	wait_queue_head_t wait;
  	int status;
++<<<<<<< HEAD
 +	/* ID of client connected */
++=======
+ 	uuid_le cl_uuid;
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
  	u8 host_client_id;
  	u8 me_client_id;
  	u8 mei_flow_ctrl_creds;
@@@ -332,11 -359,12 +370,13 @@@ void mei_cl_bus_exit(void)
   * when being probed and shall use it for doing ME bus I/O.
   *
   * @dev: linux driver model device pointer
 + * @uuid: me client uuid
   * @cl: mei client
   * @ops: ME transport ops
+  * @event_work: async work to execute event callback
   * @event_cb: Drivers register this callback to get asynchronous ME
   *	events (e.g. Rx buffer pending) notifications.
+  * @event_context: event callback run context
   * @events: Events bitmask sent to the driver.
   * @priv_data: client private data
   */
@@@ -382,55 -410,99 +422,145 @@@ enum mei_pg_state 
  
  const char *mei_pg_state_str(enum mei_pg_state state);
  
 +/*
 + * mei_cfg
 + *
 + * @fw_status - FW status
 + * @quirk_probe - device exclusion quirk
 + */
 +struct mei_cfg {
 +	const struct mei_fw_status fw_status;
 +	bool (*quirk_probe)(struct pci_dev *pdev);
 +};
 +
 +
 +#define MEI_PCI_DEVICE(dev, cfg) \
 +	.vendor = PCI_VENDOR_ID_INTEL, .device = (dev), \
 +	.subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID, \
 +	.driver_data = (kernel_ulong_t)&(cfg)
 +
 +
  /**
   * struct mei_device -  MEI private device struct
++<<<<<<< HEAD
 +
 + * @reset_count - limits the number of consecutive resets
 + * @hbm_state - state of host bus message protocol
 + *
 + * @hbm_f_pg_supported - hbm feature pgi protocol
 + *
 + * @pg_event - power gating event
 + * @mem_addr - mem mapped base register address
 +
 + * @hbuf_depth - depth of hardware host/write buffer is slots
 + * @hbuf_is_ready - query if the host host/write buffer is ready
 + * @wr_msg - the buffer for hbm control messages
 + * @cfg - per device generation config and ops
 + */
 +struct mei_device {
 +	struct pci_dev *pdev;	/* pointer to pci device struct */
 +	/*
 +	 * lists of queues
 +	 */
 +	/* array of pointers to aio lists */
 +	struct mei_cl_cb read_list;		/* driver read queue */
 +	struct mei_cl_cb write_list;		/* driver write queue */
 +	struct mei_cl_cb write_waiting_list;	/* write waiting queue */
 +	struct mei_cl_cb ctrl_wr_list;		/* managed write IOCTL list */
 +	struct mei_cl_cb ctrl_rd_list;		/* managed read IOCTL list */
++=======
+  *
+  * @dev         : device on a bus
+  * @cdev        : character device
+  * @minor       : minor number allocated for device
+  *
+  * @read_list   : read completion list
+  * @write_list  : write pending list
+  * @write_waiting_list : write completion list
+  * @ctrl_wr_list : pending control write list
+  * @ctrl_rd_list : pending control read list
+  *
+  * @file_list   : list of opened handles
+  * @open_handle_count: number of opened handles
+  *
+  * @device_lock : big device lock
+  * @timer_work  : MEI timer delayed work (timeouts)
+  *
+  * @recvd_hw_ready : hw ready message received flag
+  *
+  * @wait_hw_ready : wait queue for receive HW ready message form FW
+  * @wait_pg     : wait queue for receive PG message from FW
+  * @wait_hbm_start : wait queue for receive HBM start message from FW
+  * @wait_stop_wd : wait queue for receive WD stop message from FW
+  *
+  * @reset_count : number of consecutive resets
+  * @dev_state   : device state
+  * @hbm_state   : state of host bus message protocol
+  * @init_clients_timer : HBM init handshake timeout
+  *
+  * @pg_event    : power gating event
+  * @pg_domain   : runtime PM domain
+  *
+  * @rd_msg_buf  : control messages buffer
+  * @rd_msg_hdr  : read message header storage
+  *
+  * @hbuf_depth  : depth of hardware host/write buffer is slots
+  * @hbuf_is_ready : query if the host host/write buffer is ready
+  * @wr_msg      : the buffer for hbm control messages
+  *
+  * @version     : HBM protocol version in use
+  * @hbm_f_pg_supported : hbm feature pgi protocol
+  *
+  * @me_clients  : list of FW clients
+  * @me_clients_map : FW clients bit map
+  * @host_clients_map : host clients id pool
+  * @me_client_index : last FW client index in enumeration
+  *
+  * @wd_cl       : watchdog client
+  * @wd_state    : watchdog client state
+  * @wd_pending  : watchdog command is pending
+  * @wd_timeout  : watchdog expiration timeout
+  * @wd_data     : watchdog message buffer
+  *
+  * @amthif_cmd_list : amthif list for cmd waiting
+  * @amthif_rd_complete_list : amthif list for reading completed cmd data
+  * @iamthif_file_object : file for current amthif operation
+  * @iamthif_cl  : amthif host client
+  * @iamthif_current_cb : amthif current operation callback
+  * @iamthif_open_count : number of opened amthif connections
+  * @iamthif_mtu : amthif client max message length
+  * @iamthif_timer : time stamp of current amthif command completion
+  * @iamthif_stall_timer : timer to detect amthif hang
+  * @iamthif_msg_buf : amthif current message buffer
+  * @iamthif_msg_buf_size : size of current amthif message request buffer
+  * @iamthif_msg_buf_index : current index in amthif message request buffer
+  * @iamthif_state : amthif processor state
+  * @iamthif_flow_control_pending: amthif waits for flow control
+  * @iamthif_ioctl : wait for completion if amthif control message
+  * @iamthif_canceled : current amthif command is canceled
+  *
+  * @init_work   : work item for the device init
+  * @reset_work  : work item for the device reset
+  *
+  * @device_list : mei client bus list
+  *
+  * @dbgfs_dir   : debugfs mei root directory
+  *
+  * @ops:        : hw specific operations
+  * @hw          : hw specific data
+  */
+ struct mei_device {
+ 	struct device *dev;
+ 	struct cdev cdev;
+ 	int minor;
+ 
+ 	struct mei_cl_cb read_list;
+ 	struct mei_cl_cb write_list;
+ 	struct mei_cl_cb write_waiting_list;
+ 	struct mei_cl_cb ctrl_wr_list;
+ 	struct mei_cl_cb ctrl_rd_list;
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
  
- 	/*
- 	 * list of files
- 	 */
  	struct list_head file_list;
  	long open_handle_count;
  
@@@ -461,8 -530,11 +588,8 @@@
  	 * Power Gating support
  	 */
  	enum mei_pg_event pg_event;
 -#ifdef CONFIG_PM_RUNTIME
 -	struct dev_pm_domain pg_domain;
 -#endif /* CONFIG_PM_RUNTIME */
  
- 	unsigned char rd_msg_buf[MEI_RD_MSG_BUF_SIZE];	/* control messages */
+ 	unsigned char rd_msg_buf[MEI_RD_MSG_BUF_SIZE];
  	u32 rd_msg_hdr;
  
  	/* write buffer */
@@@ -535,8 -604,10 +662,15 @@@ static inline unsigned long mei_secs_to
  /**
   * mei_data2slots - get slots - number of (dwords) from a message length
   *	+ size of the mei header
++<<<<<<< HEAD
 + * @length - size of the messages in bytes
 + * returns  - number of slots
++=======
+  *
+  * @length: size of the messages in bytes
+  *
+  * Return: number of slots
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
   */
  static inline u32 mei_data2slots(size_t length)
  {
@@@ -544,9 -615,11 +678,17 @@@
  }
  
  /**
++<<<<<<< HEAD
 + * mei_slots2data- get data in slots - bytes from slots
 + * @slots -  number of available slots
 + * returns  - number of bytes in slots
++=======
+  * mei_slots2data - get data in slots - bytes from slots
+  *
+  * @slots: number of available slots
+  *
+  * Return: number of bytes in slots
++>>>>>>> ce23139c6c2e (mei: fix kernel-doc warnings)
   */
  static inline u32 mei_slots2data(int slots)
  {
diff --git a/drivers/misc/mei/amthif.c b/drivers/misc/mei/amthif.c
index a11128c1997f..1d80df709459 100644
--- a/drivers/misc/mei/amthif.c
+++ b/drivers/misc/mei/amthif.c
@@ -65,6 +65,7 @@ void mei_amthif_reset_params(struct mei_device *dev)
  *
  * @dev: the device structure
  *
+ * Return: 0 on success, <0 on failure.
  */
 int mei_amthif_host_init(struct mei_device *dev)
 {
@@ -359,7 +360,7 @@ int mei_amthif_write(struct mei_device *dev, struct mei_cl_cb *cb)
 	return mei_amthif_send_cmd(dev, cb);
 }
 /**
- * mei_amthif_run_next_cmd
+ * mei_amthif_run_next_cmd - send next amt command from queue
  *
  * @dev: the device structure
  *
@@ -506,7 +507,7 @@ int mei_amthif_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,
 }
 
 /**
- * mei_amthif_irq_read_message - read routine after ISR to
+ * mei_amthif_irq_read_msg - read routine after ISR to
  *			handle the read amthif message
  *
  * @dev: the device structure
* Unmerged path drivers/misc/mei/client.c
* Unmerged path drivers/misc/mei/debugfs.c
diff --git a/drivers/misc/mei/hbm.c b/drivers/misc/mei/hbm.c
index e04f10ba9aa2..1a84b7d98d1b 100644
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@ -163,6 +163,8 @@ void mei_hbm_cl_hdr(struct mei_cl *cl, u8 hbm_cmd, void *buf, size_t len)
  * @cl: client
  * @hbm_cmd: host bus message command
  * @len: buffer length
+ *
+ * Return: 0 on success, <0 on failure.
  */
 static inline
 int mei_hbm_cl_write(struct mei_device *dev,
* Unmerged path drivers/misc/mei/hw-me.c
* Unmerged path drivers/misc/mei/hw-me.h
* Unmerged path drivers/misc/mei/hw-txe.c
diff --git a/drivers/misc/mei/hw-txe.h b/drivers/misc/mei/hw-txe.h
index e244af79167f..63b775a86c81 100644
--- a/drivers/misc/mei/hw-txe.h
+++ b/drivers/misc/mei/hw-txe.h
@@ -40,6 +40,7 @@
  * @mem_addr:            SeC and BRIDGE bars
  * @aliveness:           aliveness (power gating) state of the hardware
  * @readiness:           readiness state of the hardware
+ * @slots:               number of empty slots
  * @wait_aliveness_resp: aliveness wait queue
  * @intr_cause:          translated interrupt cause
  */
* Unmerged path drivers/misc/mei/hw.h
* Unmerged path drivers/misc/mei/init.c
diff --git a/drivers/misc/mei/interrupt.c b/drivers/misc/mei/interrupt.c
index b8d9cfee3e87..2f9297256e2c 100644
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@ -87,7 +87,7 @@ static bool mei_cl_is_reading(struct mei_cl *cl, struct mei_msg_hdr *mei_hdr)
 }
 
 /**
- * mei_irq_read_client_message - process client message
+ * mei_cl_irq_read_msg - process client message
  *
  * @dev: the device structure
  * @mei_hdr: header of mei client message
@@ -234,7 +234,7 @@ static int mei_cl_irq_disconnect(struct mei_cl *cl, struct mei_cl_cb *cb,
 
 
 /**
- * mei_cl_irq_close - processes client read related operation from the
+ * mei_cl_irq_read - processes client read related operation from the
  *	interrupt thread context - request for flow control credits
  *
  * @cl: client
* Unmerged path drivers/misc/mei/mei_dev.h
diff --git a/drivers/misc/mei/nfc.c b/drivers/misc/mei/nfc.c
index 2b65e8021f0d..d672531e1a64 100644
--- a/drivers/misc/mei/nfc.c
+++ b/drivers/misc/mei/nfc.c
@@ -92,9 +92,14 @@ struct mei_nfc_hci_hdr {
  * @cl: NFC host client
  * @cl_info: NFC info host client
  * @init_work: perform connection to the info client
+ * @send_wq: send completion wait queue
  * @fw_ivn: NFC Interface Version Number
  * @vendor_id: NFC manufacturer ID
  * @radio_type: NFC radio type
+ * @bus_name: bus name
+ *
+ * @req_id:  message counter
+ * @recv_req_id: reception message counter
  */
 struct mei_nfc_dev {
 	struct mei_cl *cl;
diff --git a/drivers/misc/mei/pci-me.c b/drivers/misc/mei/pci-me.c
index 1eebd0f6a9f0..4ab3aae19c73 100644
--- a/drivers/misc/mei/pci-me.c
+++ b/drivers/misc/mei/pci-me.c
@@ -95,7 +95,7 @@ MODULE_DEVICE_TABLE(pci, mei_me_pci_tbl);
 static DEFINE_MUTEX(mei_mutex);
 
 /**
- * mei_quirk_probe - probe for devices that doesn't valid ME interface
+ * mei_me_quirk_probe - probe for devices that doesn't valid ME interface
  *
  * @pdev: PCI device structure
  * @cfg: per generation config
@@ -114,7 +114,7 @@ static bool mei_me_quirk_probe(struct pci_dev *pdev,
 }
 
 /**
- * mei_probe - Device Initialization Routine
+ * mei_me_probe - Device Initialization Routine
  *
  * @pdev: PCI device structure
  * @ent: entry in kcs_pci_tbl
@@ -241,7 +241,7 @@ end:
 }
 
 /**
- * mei_remove - Device Removal Routine
+ * mei_me_remove - Device Removal Routine
  *
  * @pdev: PCI device structure
  *
