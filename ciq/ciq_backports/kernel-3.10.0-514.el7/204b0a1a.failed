x86, efi: Abstract x86 efi_early calls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matt Fleming <matt.fleming@intel.com>
commit 204b0a1a4b92612c957a042df1a3be0e9cc79391
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/204b0a1a.failed

The ARM EFI boot stub doesn't need to care about the efi_early
infrastructure that x86 requires in order to do mixed mode thunking. So
wrap everything up in an efi_call_early() macro.

This allows x86 to do the necessary indirection jumps to call whatever
firmware interface is necessary (native or mixed mode), but also allows
the ARM folks to mask the fact that they don't support relocation in the
boot stub and need to pass 'sys_table_arg' to every function.

[ hpa: there are no object code changes from this patch ]

	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
Link: http://lkml.kernel.org/r/20140326091011.GB2958@console-pimps.org
	Cc: Roy Franz <roy.franz@linaro.org>
	Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
(cherry picked from commit 204b0a1a4b92612c957a042df1a3be0e9cc79391)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/eboot.c
#	drivers/firmware/efi/efi-stub-helper.c
diff --cc arch/x86/boot/compressed/eboot.c
index a1ae20b40077,1e6146137f8e..000000000000
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@@ -20,6 -19,270 +20,273 @@@
  
  static efi_system_table_t *sys_table;
  
++<<<<<<< HEAD
++=======
+ static struct efi_config *efi_early;
+ 
+ #define efi_call_early(f, ...)						\
+ 	efi_early->call(efi_early->f, __VA_ARGS__);
+ 
+ #define BOOT_SERVICES(bits)						\
+ static void setup_boot_services##bits(struct efi_config *c)		\
+ {									\
+ 	efi_system_table_##bits##_t *table;				\
+ 	efi_boot_services_##bits##_t *bt;				\
+ 									\
+ 	table = (typeof(table))sys_table;				\
+ 									\
+ 	c->text_output = table->con_out;				\
+ 									\
+ 	bt = (typeof(bt))(unsigned long)(table->boottime);		\
+ 									\
+ 	c->allocate_pool = bt->allocate_pool;				\
+ 	c->allocate_pages = bt->allocate_pages;				\
+ 	c->get_memory_map = bt->get_memory_map;				\
+ 	c->free_pool = bt->free_pool;					\
+ 	c->free_pages = bt->free_pages;					\
+ 	c->locate_handle = bt->locate_handle;				\
+ 	c->handle_protocol = bt->handle_protocol;			\
+ 	c->exit_boot_services = bt->exit_boot_services;			\
+ }
+ BOOT_SERVICES(32);
+ BOOT_SERVICES(64);
+ 
+ static void efi_printk(efi_system_table_t *, char *);
+ static void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
+ 
+ static efi_status_t
+ __file_size32(void *__fh, efi_char16_t *filename_16,
+ 	      void **handle, u64 *file_sz)
+ {
+ 	efi_file_handle_32_t *h, *fh = __fh;
+ 	efi_file_info_t *info;
+ 	efi_status_t status;
+ 	efi_guid_t info_guid = EFI_FILE_INFO_ID;
+ 	u32 info_sz;
+ 
+ 	status = efi_early->call((unsigned long)fh->open, fh, &h, filename_16,
+ 				 EFI_FILE_MODE_READ, (u64)0);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to open file: ");
+ 		efi_char16_printk(sys_table, filename_16);
+ 		efi_printk(sys_table, "\n");
+ 		return status;
+ 	}
+ 
+ 	*handle = h;
+ 
+ 	info_sz = 0;
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, NULL);
+ 	if (status != EFI_BUFFER_TOO_SMALL) {
+ 		efi_printk(sys_table, "Failed to get file info size\n");
+ 		return status;
+ 	}
+ 
+ grow:
+ 	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
+ 				info_sz, (void **)&info);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to alloc mem for file info\n");
+ 		return status;
+ 	}
+ 
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, info);
+ 	if (status == EFI_BUFFER_TOO_SMALL) {
+ 		efi_call_early(free_pool, info);
+ 		goto grow;
+ 	}
+ 
+ 	*file_sz = info->file_size;
+ 	efi_call_early(free_pool, info);
+ 
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to get initrd info\n");
+ 
+ 	return status;
+ }
+ 
+ static efi_status_t
+ __file_size64(void *__fh, efi_char16_t *filename_16,
+ 	      void **handle, u64 *file_sz)
+ {
+ 	efi_file_handle_64_t *h, *fh = __fh;
+ 	efi_file_info_t *info;
+ 	efi_status_t status;
+ 	efi_guid_t info_guid = EFI_FILE_INFO_ID;
+ 	u32 info_sz;
+ 
+ 	status = efi_early->call((unsigned long)fh->open, fh, &h, filename_16,
+ 				 EFI_FILE_MODE_READ, (u64)0);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to open file: ");
+ 		efi_char16_printk(sys_table, filename_16);
+ 		efi_printk(sys_table, "\n");
+ 		return status;
+ 	}
+ 
+ 	*handle = h;
+ 
+ 	info_sz = 0;
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, NULL);
+ 	if (status != EFI_BUFFER_TOO_SMALL) {
+ 		efi_printk(sys_table, "Failed to get file info size\n");
+ 		return status;
+ 	}
+ 
+ grow:
+ 	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
+ 				info_sz, (void **)&info);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to alloc mem for file info\n");
+ 		return status;
+ 	}
+ 
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, info);
+ 	if (status == EFI_BUFFER_TOO_SMALL) {
+ 		efi_call_early(free_pool, info);
+ 		goto grow;
+ 	}
+ 
+ 	*file_sz = info->file_size;
+ 	efi_call_early(free_pool, info);
+ 
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to get initrd info\n");
+ 
+ 	return status;
+ }
+ static efi_status_t
+ efi_file_size(efi_system_table_t *sys_table, void *__fh,
+ 	      efi_char16_t *filename_16, void **handle, u64 *file_sz)
+ {
+ 	if (efi_early->is64)
+ 		return __file_size64(__fh, filename_16, handle, file_sz);
+ 
+ 	return __file_size32(__fh, filename_16, handle, file_sz);
+ }
+ 
+ static inline efi_status_t
+ efi_file_read(void *__fh, void *handle, unsigned long *size, void *addr)
+ {
+ 	unsigned long func;
+ 
+ 	if (efi_early->is64) {
+ 		efi_file_handle_64_t *fh = __fh;
+ 
+ 		func = (unsigned long)fh->read;
+ 		return efi_early->call(func, handle, size, addr);
+ 	} else {
+ 		efi_file_handle_32_t *fh = __fh;
+ 
+ 		func = (unsigned long)fh->read;
+ 		return efi_early->call(func, handle, size, addr);
+ 	}
+ }
+ 
+ static inline efi_status_t efi_file_close(void *__fh, void *handle)
+ {
+ 	if (efi_early->is64) {
+ 		efi_file_handle_64_t *fh = __fh;
+ 
+ 		return efi_early->call((unsigned long)fh->close, handle);
+ 	} else {
+ 		efi_file_handle_32_t *fh = __fh;
+ 
+ 		return efi_early->call((unsigned long)fh->close, handle);
+ 	}
+ }
+ 
+ static inline efi_status_t __open_volume32(void *__image, void **__fh)
+ {
+ 	efi_file_io_interface_t *io;
+ 	efi_loaded_image_32_t *image = __image;
+ 	efi_file_handle_32_t *fh;
+ 	efi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;
+ 	efi_status_t status;
+ 	void *handle = (void *)(unsigned long)image->device_handle;
+ 	unsigned long func;
+ 
+ 	status = efi_call_early(handle_protocol, handle,
+ 				&fs_proto, (void **)&io);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to handle fs_proto\n");
+ 		return status;
+ 	}
+ 
+ 	func = (unsigned long)io->open_volume;
+ 	status = efi_early->call(func, io, &fh);
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to open volume\n");
+ 
+ 	*__fh = fh;
+ 	return status;
+ }
+ 
+ static inline efi_status_t __open_volume64(void *__image, void **__fh)
+ {
+ 	efi_file_io_interface_t *io;
+ 	efi_loaded_image_64_t *image = __image;
+ 	efi_file_handle_64_t *fh;
+ 	efi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;
+ 	efi_status_t status;
+ 	void *handle = (void *)(unsigned long)image->device_handle;
+ 	unsigned long func;
+ 
+ 	status = efi_call_early(handle_protocol, handle,
+ 				&fs_proto, (void **)&io);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to handle fs_proto\n");
+ 		return status;
+ 	}
+ 
+ 	func = (unsigned long)io->open_volume;
+ 	status = efi_early->call(func, io, &fh);
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to open volume\n");
+ 
+ 	*__fh = fh;
+ 	return status;
+ }
+ 
+ static inline efi_status_t
+ efi_open_volume(efi_system_table_t *sys_table, void *__image, void **__fh)
+ {
+ 	if (efi_early->is64)
+ 		return __open_volume64(__image, __fh);
+ 
+ 	return __open_volume32(__image, __fh);
+ }
+ 
+ static void efi_char16_printk(efi_system_table_t *table, efi_char16_t *str)
+ {
+ 	unsigned long output_string;
+ 	size_t offset;
+ 
+ 	if (efi_early->is64) {
+ 		struct efi_simple_text_output_protocol_64 *out;
+ 		u64 *func;
+ 
+ 		offset = offsetof(typeof(*out), output_string);
+ 		output_string = efi_early->text_output + offset;
+ 		func = (u64 *)output_string;
+ 
+ 		efi_early->call(*func, efi_early->text_output, str);
+ 	} else {
+ 		struct efi_simple_text_output_protocol_32 *out;
+ 		u32 *func;
+ 
+ 		offset = offsetof(typeof(*out), output_string);
+ 		output_string = efi_early->text_output + offset;
+ 		func = (u32 *)output_string;
+ 
+ 		efi_early->call(*func, efi_early->text_output, str);
+ 	}
+ }
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  
  #include "../../../../drivers/firmware/efi/efi-stub-helper.c"
  
@@@ -48,33 -309,233 +315,258 @@@ static void find_bits(unsigned long mas
  	*size = len;
  }
  
++<<<<<<< HEAD
++=======
+ static efi_status_t
+ __setup_efi_pci32(efi_pci_io_protocol_32 *pci, struct pci_setup_rom **__rom)
+ {
+ 	struct pci_setup_rom *rom = NULL;
+ 	efi_status_t status;
+ 	unsigned long size;
+ 	uint64_t attributes;
+ 
+ 	status = efi_early->call(pci->attributes, pci,
+ 				 EfiPciIoAttributeOperationGet, 0, 0,
+ 				 &attributes);
+ 	if (status != EFI_SUCCESS)
+ 		return status;
+ 
+ 	if (!pci->romimage || !pci->romsize)
+ 		return EFI_INVALID_PARAMETER;
+ 
+ 	size = pci->romsize + sizeof(*rom);
+ 
+ 	status = efi_call_early(allocate_pool, EFI_LOADER_DATA, size, &rom);
+ 	if (status != EFI_SUCCESS)
+ 		return status;
+ 
+ 	memset(rom, 0, sizeof(*rom));
+ 
+ 	rom->data.type = SETUP_PCI;
+ 	rom->data.len = size - sizeof(struct setup_data);
+ 	rom->data.next = 0;
+ 	rom->pcilen = pci->romsize;
+ 	*__rom = rom;
+ 
+ 	status = efi_early->call(pci->pci.read, pci, EfiPciIoWidthUint16,
+ 				 PCI_VENDOR_ID, 1, &(rom->vendor));
+ 
+ 	if (status != EFI_SUCCESS)
+ 		goto free_struct;
+ 
+ 	status = efi_early->call(pci->pci.read, pci, EfiPciIoWidthUint16,
+ 				 PCI_DEVICE_ID, 1, &(rom->devid));
+ 
+ 	if (status != EFI_SUCCESS)
+ 		goto free_struct;
+ 
+ 	status = efi_early->call(pci->get_location, pci, &(rom->segment),
+ 				 &(rom->bus), &(rom->device), &(rom->function));
+ 
+ 	if (status != EFI_SUCCESS)
+ 		goto free_struct;
+ 
+ 	memcpy(rom->romdata, pci->romimage, pci->romsize);
+ 	return status;
+ 
+ free_struct:
+ 	efi_call_early(free_pool, rom);
+ 	return status;
+ }
+ 
+ static efi_status_t
+ setup_efi_pci32(struct boot_params *params, void **pci_handle,
+ 		unsigned long size)
+ {
+ 	efi_pci_io_protocol_32 *pci = NULL;
+ 	efi_guid_t pci_proto = EFI_PCI_IO_PROTOCOL_GUID;
+ 	u32 *handles = (u32 *)(unsigned long)pci_handle;
+ 	efi_status_t status;
+ 	unsigned long nr_pci;
+ 	struct setup_data *data;
+ 	int i;
+ 
+ 	data = (struct setup_data *)(unsigned long)params->hdr.setup_data;
+ 
+ 	while (data && data->next)
+ 		data = (struct setup_data *)(unsigned long)data->next;
+ 
+ 	nr_pci = size / sizeof(u32);
+ 	for (i = 0; i < nr_pci; i++) {
+ 		struct pci_setup_rom *rom = NULL;
+ 		u32 h = handles[i];
+ 
+ 		status = efi_call_early(handle_protocol, h,
+ 					&pci_proto, (void **)&pci);
+ 
+ 		if (status != EFI_SUCCESS)
+ 			continue;
+ 
+ 		if (!pci)
+ 			continue;
+ 
+ 		status = __setup_efi_pci32(pci, &rom);
+ 		if (status != EFI_SUCCESS)
+ 			continue;
+ 
+ 		if (data)
+ 			data->next = (unsigned long)rom;
+ 		else
+ 			params->hdr.setup_data = (unsigned long)rom;
+ 
+ 		data = (struct setup_data *)rom;
+ 
+ 	}
+ 
+ 	return status;
+ }
+ 
+ static efi_status_t
+ __setup_efi_pci64(efi_pci_io_protocol_64 *pci, struct pci_setup_rom **__rom)
+ {
+ 	struct pci_setup_rom *rom;
+ 	efi_status_t status;
+ 	unsigned long size;
+ 	uint64_t attributes;
+ 
+ 	status = efi_early->call(pci->attributes, pci,
+ 				 EfiPciIoAttributeOperationGet, 0,
+ 				 &attributes);
+ 	if (status != EFI_SUCCESS)
+ 		return status;
+ 
+ 	if (!pci->romimage || !pci->romsize)
+ 		return EFI_INVALID_PARAMETER;
+ 
+ 	size = pci->romsize + sizeof(*rom);
+ 
+ 	status = efi_call_early(allocate_pool, EFI_LOADER_DATA, size, &rom);
+ 	if (status != EFI_SUCCESS)
+ 		return status;
+ 
+ 	rom->data.type = SETUP_PCI;
+ 	rom->data.len = size - sizeof(struct setup_data);
+ 	rom->data.next = 0;
+ 	rom->pcilen = pci->romsize;
+ 	*__rom = rom;
+ 
+ 	status = efi_early->call(pci->pci.read, pci, EfiPciIoWidthUint16,
+ 				 PCI_VENDOR_ID, 1, &(rom->vendor));
+ 
+ 	if (status != EFI_SUCCESS)
+ 		goto free_struct;
+ 
+ 	status = efi_early->call(pci->pci.read, pci, EfiPciIoWidthUint16,
+ 				 PCI_DEVICE_ID, 1, &(rom->devid));
+ 
+ 	if (status != EFI_SUCCESS)
+ 		goto free_struct;
+ 
+ 	status = efi_early->call(pci->get_location, pci, &(rom->segment),
+ 				 &(rom->bus), &(rom->device), &(rom->function));
+ 
+ 	if (status != EFI_SUCCESS)
+ 		goto free_struct;
+ 
+ 	memcpy(rom->romdata, pci->romimage, pci->romsize);
+ 	return status;
+ 
+ free_struct:
+ 	efi_call_early(free_pool, rom);
+ 	return status;
+ 
+ }
+ 
+ static efi_status_t
+ setup_efi_pci64(struct boot_params *params, void **pci_handle,
+ 		unsigned long size)
+ {
+ 	efi_pci_io_protocol_64 *pci = NULL;
+ 	efi_guid_t pci_proto = EFI_PCI_IO_PROTOCOL_GUID;
+ 	u64 *handles = (u64 *)(unsigned long)pci_handle;
+ 	efi_status_t status;
+ 	unsigned long nr_pci;
+ 	struct setup_data *data;
+ 	int i;
+ 
+ 	data = (struct setup_data *)(unsigned long)params->hdr.setup_data;
+ 
+ 	while (data && data->next)
+ 		data = (struct setup_data *)(unsigned long)data->next;
+ 
+ 	nr_pci = size / sizeof(u64);
+ 	for (i = 0; i < nr_pci; i++) {
+ 		struct pci_setup_rom *rom = NULL;
+ 		u64 h = handles[i];
+ 
+ 		status = efi_call_early(handle_protocol, h,
+ 					&pci_proto, (void **)&pci);
+ 
+ 		if (status != EFI_SUCCESS)
+ 			continue;
+ 
+ 		if (!pci)
+ 			continue;
+ 
+ 		status = __setup_efi_pci64(pci, &rom);
+ 		if (status != EFI_SUCCESS)
+ 			continue;
+ 
+ 		if (data)
+ 			data->next = (unsigned long)rom;
+ 		else
+ 			params->hdr.setup_data = (unsigned long)rom;
+ 
+ 		data = (struct setup_data *)rom;
+ 
+ 	}
+ 
+ 	return status;
+ }
+ 
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  static efi_status_t setup_efi_pci(struct boot_params *params)
  {
 +	efi_pci_io_protocol *pci;
  	efi_status_t status;
 -	void **pci_handle = NULL;
 +	void **pci_handle;
  	efi_guid_t pci_proto = EFI_PCI_IO_PROTOCOL_GUID;
 -	unsigned long size = 0;
 +	unsigned long nr_pci, size = 0;
 +	int i;
 +	struct setup_data *data;
 +
++<<<<<<< HEAD
 +	data = (struct setup_data *)(unsigned long)params->hdr.setup_data;
  
 +	while (data && data->next)
 +		data = (struct setup_data *)(unsigned long)data->next;
 +
 +	status = efi_call_phys5(sys_table->boottime->locate_handle,
 +				EFI_LOCATE_BY_PROTOCOL, &pci_proto,
 +				NULL, &size, pci_handle);
 +
 +	if (status == EFI_BUFFER_TOO_SMALL) {
 +		status = efi_call_phys3(sys_table->boottime->allocate_pool,
 +					EFI_LOADER_DATA, size, &pci_handle);
++=======
+ 	status = efi_call_early(locate_handle,
+ 				EFI_LOCATE_BY_PROTOCOL,
+ 				&pci_proto, NULL, &size, pci_handle);
+ 
+ 	if (status == EFI_BUFFER_TOO_SMALL) {
+ 		status = efi_call_early(allocate_pool,
+ 					EFI_LOADER_DATA,
+ 					size, (void **)&pci_handle);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  
  		if (status != EFI_SUCCESS)
  			return status;
  
++<<<<<<< HEAD
 +		status = efi_call_phys5(sys_table->boottime->locate_handle,
++=======
+ 		status = efi_call_early(locate_handle,
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  					EFI_LOCATE_BY_PROTOCOL, &pci_proto,
  					NULL, &size, pci_handle);
  	}
@@@ -82,86 -543,13 +574,90 @@@
  	if (status != EFI_SUCCESS)
  		goto free_handle;
  
 -	if (efi_early->is64)
 -		status = setup_efi_pci64(params, pci_handle, size);
 -	else
 -		status = setup_efi_pci32(params, pci_handle, size);
 +	nr_pci = size / sizeof(void *);
 +	for (i = 0; i < nr_pci; i++) {
 +		void *h = pci_handle[i];
 +		uint64_t attributes;
 +		struct pci_setup_rom *rom;
 +
 +		status = efi_call_phys3(sys_table->boottime->handle_protocol,
 +					h, &pci_proto, &pci);
 +
 +		if (status != EFI_SUCCESS)
 +			continue;
 +
 +		if (!pci)
 +			continue;
 +
 +#ifdef CONFIG_X86_64
 +		status = efi_call_phys4(pci->attributes, pci,
 +					EfiPciIoAttributeOperationGet, 0,
 +					&attributes);
 +#else
 +		status = efi_call_phys5(pci->attributes, pci,
 +					EfiPciIoAttributeOperationGet, 0, 0,
 +					&attributes);
 +#endif
 +		if (status != EFI_SUCCESS)
 +			continue;
 +
 +		if (!pci->romimage || !pci->romsize)
 +			continue;
 +
 +		size = pci->romsize + sizeof(*rom);
 +
 +		status = efi_call_phys3(sys_table->boottime->allocate_pool,
 +				EFI_LOADER_DATA, size, &rom);
 +
 +		if (status != EFI_SUCCESS)
 +			continue;
 +
 +		rom->data.type = SETUP_PCI;
 +		rom->data.len = size - sizeof(struct setup_data);
 +		rom->data.next = 0;
 +		rom->pcilen = pci->romsize;
 +
 +		status = efi_call_phys5(pci->pci.read, pci,
 +					EfiPciIoWidthUint16, PCI_VENDOR_ID,
 +					1, &(rom->vendor));
 +
 +		if (status != EFI_SUCCESS)
 +			goto free_struct;
 +
 +		status = efi_call_phys5(pci->pci.read, pci,
 +					EfiPciIoWidthUint16, PCI_DEVICE_ID,
 +					1, &(rom->devid));
 +
 +		if (status != EFI_SUCCESS)
 +			goto free_struct;
 +
 +		status = efi_call_phys5(pci->get_location, pci,
 +					&(rom->segment), &(rom->bus),
 +					&(rom->device), &(rom->function));
 +
 +		if (status != EFI_SUCCESS)
 +			goto free_struct;
 +
 +		memcpy(rom->romdata, pci->romimage, pci->romsize);
 +
 +		if (data)
 +			data->next = (unsigned long)rom;
 +		else
 +			params->hdr.setup_data = (unsigned long)rom;
 +
 +		data = (struct setup_data *)rom;
 +
 +		continue;
 +	free_struct:
 +		efi_call_phys1(sys_table->boottime->free_pool, rom);
 +	}
  
  free_handle:
++<<<<<<< HEAD
 +	efi_call_phys1(sys_table->boottime->free_pool, pci_handle);
++=======
+ 	efi_call_early(free_pool, pci_handle);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  	return status;
  }
  
@@@ -298,13 -601,331 +794,340 @@@ static efi_status_t setup_gop(struct sc
  		si->rsvd_size = 0;
  		si->rsvd_pos = 0;
  	}
++<<<<<<< HEAD
++=======
+ }
+ 
+ static efi_status_t
+ __gop_query32(struct efi_graphics_output_protocol_32 *gop32,
+ 	      struct efi_graphics_output_mode_info **info,
+ 	      unsigned long *size, u32 *fb_base)
+ {
+ 	struct efi_graphics_output_protocol_mode_32 *mode;
+ 	efi_status_t status;
+ 	unsigned long m;
+ 
+ 	m = gop32->mode;
+ 	mode = (struct efi_graphics_output_protocol_mode_32 *)m;
+ 
+ 	status = efi_early->call(gop32->query_mode, gop32,
+ 				 mode->mode, size, info);
+ 	if (status != EFI_SUCCESS)
+ 		return status;
+ 
+ 	*fb_base = mode->frame_buffer_base;
+ 	return status;
+ }
+ 
+ static efi_status_t
+ setup_gop32(struct screen_info *si, efi_guid_t *proto,
+ 	    unsigned long size, void **gop_handle)
+ {
+ 	struct efi_graphics_output_protocol_32 *gop32, *first_gop;
+ 	unsigned long nr_gops;
+ 	u16 width, height;
+ 	u32 pixels_per_scan_line;
+ 	u32 fb_base;
+ 	struct efi_pixel_bitmask pixel_info;
+ 	int pixel_format;
+ 	efi_status_t status;
+ 	u32 *handles = (u32 *)(unsigned long)gop_handle;
+ 	int i;
+ 
+ 	first_gop = NULL;
+ 	gop32 = NULL;
+ 
+ 	nr_gops = size / sizeof(u32);
+ 	for (i = 0; i < nr_gops; i++) {
+ 		struct efi_graphics_output_mode_info *info = NULL;
+ 		efi_guid_t conout_proto = EFI_CONSOLE_OUT_DEVICE_GUID;
+ 		bool conout_found = false;
+ 		void *dummy = NULL;
+ 		u32 h = handles[i];
+ 
+ 		status = efi_call_early(handle_protocol, h,
+ 					proto, (void **)&gop32);
+ 		if (status != EFI_SUCCESS)
+ 			continue;
+ 
+ 		status = efi_call_early(handle_protocol, h,
+ 					&conout_proto, &dummy);
+ 		if (status == EFI_SUCCESS)
+ 			conout_found = true;
+ 
+ 		status = __gop_query32(gop32, &info, &size, &fb_base);
+ 		if (status == EFI_SUCCESS && (!first_gop || conout_found)) {
+ 			/*
+ 			 * Systems that use the UEFI Console Splitter may
+ 			 * provide multiple GOP devices, not all of which are
+ 			 * backed by real hardware. The workaround is to search
+ 			 * for a GOP implementing the ConOut protocol, and if
+ 			 * one isn't found, to just fall back to the first GOP.
+ 			 */
+ 			width = info->horizontal_resolution;
+ 			height = info->vertical_resolution;
+ 			pixel_format = info->pixel_format;
+ 			pixel_info = info->pixel_information;
+ 			pixels_per_scan_line = info->pixels_per_scan_line;
+ 
+ 			/*
+ 			 * Once we've found a GOP supporting ConOut,
+ 			 * don't bother looking any further.
+ 			 */
+ 			first_gop = gop32;
+ 			if (conout_found)
+ 				break;
+ 		}
+ 	}
+ 
+ 	/* Did we find any GOPs? */
+ 	if (!first_gop)
+ 		goto out;
+ 
+ 	/* EFI framebuffer */
+ 	si->orig_video_isVGA = VIDEO_TYPE_EFI;
+ 
+ 	si->lfb_width = width;
+ 	si->lfb_height = height;
+ 	si->lfb_base = fb_base;
+ 	si->pages = 1;
+ 
+ 	setup_pixel_info(si, pixels_per_scan_line, pixel_info, pixel_format);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  
  	si->lfb_size = si->lfb_linelength * si->lfb_height;
  
  	si->capabilities |= VIDEO_CAPABILITY_SKIP_QUIRKS;
++<<<<<<< HEAD
 +
 +free_handle:
 +	efi_call_phys1(sys_table->boottime->free_pool, gop_handle);
++=======
+ out:
+ 	return status;
+ }
+ 
+ static efi_status_t
+ __gop_query64(struct efi_graphics_output_protocol_64 *gop64,
+ 	      struct efi_graphics_output_mode_info **info,
+ 	      unsigned long *size, u32 *fb_base)
+ {
+ 	struct efi_graphics_output_protocol_mode_64 *mode;
+ 	efi_status_t status;
+ 	unsigned long m;
+ 
+ 	m = gop64->mode;
+ 	mode = (struct efi_graphics_output_protocol_mode_64 *)m;
+ 
+ 	status = efi_early->call(gop64->query_mode, gop64,
+ 				 mode->mode, size, info);
+ 	if (status != EFI_SUCCESS)
+ 		return status;
+ 
+ 	*fb_base = mode->frame_buffer_base;
+ 	return status;
+ }
+ 
+ static efi_status_t
+ setup_gop64(struct screen_info *si, efi_guid_t *proto,
+ 	    unsigned long size, void **gop_handle)
+ {
+ 	struct efi_graphics_output_protocol_64 *gop64, *first_gop;
+ 	unsigned long nr_gops;
+ 	u16 width, height;
+ 	u32 pixels_per_scan_line;
+ 	u32 fb_base;
+ 	struct efi_pixel_bitmask pixel_info;
+ 	int pixel_format;
+ 	efi_status_t status;
+ 	u64 *handles = (u64 *)(unsigned long)gop_handle;
+ 	int i;
+ 
+ 	first_gop = NULL;
+ 	gop64 = NULL;
+ 
+ 	nr_gops = size / sizeof(u64);
+ 	for (i = 0; i < nr_gops; i++) {
+ 		struct efi_graphics_output_mode_info *info = NULL;
+ 		efi_guid_t conout_proto = EFI_CONSOLE_OUT_DEVICE_GUID;
+ 		bool conout_found = false;
+ 		void *dummy = NULL;
+ 		u64 h = handles[i];
+ 
+ 		status = efi_call_early(handle_protocol, h,
+ 					proto, (void **)&gop64);
+ 		if (status != EFI_SUCCESS)
+ 			continue;
+ 
+ 		status = efi_call_early(handle_protocol, h,
+ 					&conout_proto, &dummy);
+ 		if (status == EFI_SUCCESS)
+ 			conout_found = true;
+ 
+ 		status = __gop_query64(gop64, &info, &size, &fb_base);
+ 		if (status == EFI_SUCCESS && (!first_gop || conout_found)) {
+ 			/*
+ 			 * Systems that use the UEFI Console Splitter may
+ 			 * provide multiple GOP devices, not all of which are
+ 			 * backed by real hardware. The workaround is to search
+ 			 * for a GOP implementing the ConOut protocol, and if
+ 			 * one isn't found, to just fall back to the first GOP.
+ 			 */
+ 			width = info->horizontal_resolution;
+ 			height = info->vertical_resolution;
+ 			pixel_format = info->pixel_format;
+ 			pixel_info = info->pixel_information;
+ 			pixels_per_scan_line = info->pixels_per_scan_line;
+ 
+ 			/*
+ 			 * Once we've found a GOP supporting ConOut,
+ 			 * don't bother looking any further.
+ 			 */
+ 			first_gop = gop64;
+ 			if (conout_found)
+ 				break;
+ 		}
+ 	}
+ 
+ 	/* Did we find any GOPs? */
+ 	if (!first_gop)
+ 		goto out;
+ 
+ 	/* EFI framebuffer */
+ 	si->orig_video_isVGA = VIDEO_TYPE_EFI;
+ 
+ 	si->lfb_width = width;
+ 	si->lfb_height = height;
+ 	si->lfb_base = fb_base;
+ 	si->pages = 1;
+ 
+ 	setup_pixel_info(si, pixels_per_scan_line, pixel_info, pixel_format);
+ 
+ 	si->lfb_size = si->lfb_linelength * si->lfb_height;
+ 
+ 	si->capabilities |= VIDEO_CAPABILITY_SKIP_QUIRKS;
+ out:
+ 	return status;
+ }
+ 
+ /*
+  * See if we have Graphics Output Protocol
+  */
+ static efi_status_t setup_gop(struct screen_info *si, efi_guid_t *proto,
+ 			      unsigned long size)
+ {
+ 	efi_status_t status;
+ 	void **gop_handle = NULL;
+ 
+ 	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
+ 				size, (void **)&gop_handle);
+ 	if (status != EFI_SUCCESS)
+ 		return status;
+ 
+ 	status = efi_call_early(locate_handle,
+ 				EFI_LOCATE_BY_PROTOCOL,
+ 				proto, NULL, &size, gop_handle);
+ 	if (status != EFI_SUCCESS)
+ 		goto free_handle;
+ 
+ 	if (efi_early->is64)
+ 		status = setup_gop64(si, proto, size, gop_handle);
+ 	else
+ 		status = setup_gop32(si, proto, size, gop_handle);
+ 
+ free_handle:
+ 	efi_call_early(free_pool, gop_handle);
+ 	return status;
+ }
+ 
+ static efi_status_t
+ setup_uga32(void **uga_handle, unsigned long size, u32 *width, u32 *height)
+ {
+ 	struct efi_uga_draw_protocol *uga = NULL, *first_uga;
+ 	efi_guid_t uga_proto = EFI_UGA_PROTOCOL_GUID;
+ 	unsigned long nr_ugas;
+ 	u32 *handles = (u32 *)uga_handle;;
+ 	efi_status_t status;
+ 	int i;
+ 
+ 	first_uga = NULL;
+ 	nr_ugas = size / sizeof(u32);
+ 	for (i = 0; i < nr_ugas; i++) {
+ 		efi_guid_t pciio_proto = EFI_PCI_IO_PROTOCOL_GUID;
+ 		u32 w, h, depth, refresh;
+ 		void *pciio;
+ 		u32 handle = handles[i];
+ 
+ 		status = efi_call_early(handle_protocol, handle,
+ 					&uga_proto, (void **)&uga);
+ 		if (status != EFI_SUCCESS)
+ 			continue;
+ 
+ 		efi_call_early(handle_protocol, handle, &pciio_proto, &pciio);
+ 
+ 		status = efi_early->call((unsigned long)uga->get_mode, uga,
+ 					 &w, &h, &depth, &refresh);
+ 		if (status == EFI_SUCCESS && (!first_uga || pciio)) {
+ 			*width = w;
+ 			*height = h;
+ 
+ 			/*
+ 			 * Once we've found a UGA supporting PCIIO,
+ 			 * don't bother looking any further.
+ 			 */
+ 			if (pciio)
+ 				break;
+ 
+ 			first_uga = uga;
+ 		}
+ 	}
+ 
+ 	return status;
+ }
+ 
+ static efi_status_t
+ setup_uga64(void **uga_handle, unsigned long size, u32 *width, u32 *height)
+ {
+ 	struct efi_uga_draw_protocol *uga = NULL, *first_uga;
+ 	efi_guid_t uga_proto = EFI_UGA_PROTOCOL_GUID;
+ 	unsigned long nr_ugas;
+ 	u64 *handles = (u64 *)uga_handle;;
+ 	efi_status_t status;
+ 	int i;
+ 
+ 	first_uga = NULL;
+ 	nr_ugas = size / sizeof(u64);
+ 	for (i = 0; i < nr_ugas; i++) {
+ 		efi_guid_t pciio_proto = EFI_PCI_IO_PROTOCOL_GUID;
+ 		u32 w, h, depth, refresh;
+ 		void *pciio;
+ 		u64 handle = handles[i];
+ 
+ 		status = efi_call_early(handle_protocol, handle,
+ 					&uga_proto, (void **)&uga);
+ 		if (status != EFI_SUCCESS)
+ 			continue;
+ 
+ 		efi_call_early(handle_protocol, handle, &pciio_proto, &pciio);
+ 
+ 		status = efi_early->call((unsigned long)uga->get_mode, uga,
+ 					 &w, &h, &depth, &refresh);
+ 		if (status == EFI_SUCCESS && (!first_uga || pciio)) {
+ 			*width = w;
+ 			*height = h;
+ 
+ 			/*
+ 			 * Once we've found a UGA supporting PCIIO,
+ 			 * don't bother looking any further.
+ 			 */
+ 			if (pciio)
+ 				break;
+ 
+ 			first_uga = uga;
+ 		}
+ 	}
+ 
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  	return status;
  }
  
@@@ -319,16 -938,15 +1142,27 @@@ static efi_status_t setup_uga(struct sc
  	efi_status_t status;
  	u32 width, height;
  	void **uga_handle = NULL;
 +	int i;
 +
++<<<<<<< HEAD
 +	status = efi_call_phys3(sys_table->boottime->allocate_pool,
 +				EFI_LOADER_DATA, size, &uga_handle);
 +	if (status != EFI_SUCCESS)
 +		return status;
  
 +	status = efi_call_phys5(sys_table->boottime->locate_handle,
 +				EFI_LOCATE_BY_PROTOCOL, uga_proto,
 +				NULL, &size, uga_handle);
++=======
+ 	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
+ 				size, (void **)&uga_handle);
+ 	if (status != EFI_SUCCESS)
+ 		return status;
+ 
+ 	status = efi_call_early(locate_handle,
+ 				EFI_LOCATE_BY_PROTOCOL,
+ 				uga_proto, NULL, &size, uga_handle);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  	if (status != EFI_SUCCESS)
  		goto free_handle;
  
@@@ -385,9 -977,8 +1219,13 @@@
  	si->rsvd_size = 8;
  	si->rsvd_pos = 24;
  
 +
  free_handle:
++<<<<<<< HEAD
 +	efi_call_phys1(sys_table->boottime->free_pool, uga_handle);
++=======
+ 	efi_call_early(free_pool, uga_handle);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  	return status;
  }
  
@@@ -405,17 -996,17 +1243,29 @@@ void setup_graphics(struct boot_params 
  	memset(si, 0, sizeof(*si));
  
  	size = 0;
++<<<<<<< HEAD
 +	status = efi_call_phys5(sys_table->boottime->locate_handle,
 +				EFI_LOCATE_BY_PROTOCOL, &graphics_proto,
 +				NULL, &size, gop_handle);
++=======
+ 	status = efi_call_early(locate_handle,
+ 				EFI_LOCATE_BY_PROTOCOL,
+ 				&graphics_proto, NULL, &size, gop_handle);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  	if (status == EFI_BUFFER_TOO_SMALL)
  		status = setup_gop(si, &graphics_proto, size);
  
  	if (status != EFI_SUCCESS) {
  		size = 0;
++<<<<<<< HEAD
 +		status = efi_call_phys5(sys_table->boottime->locate_handle,
 +					EFI_LOCATE_BY_PROTOCOL, &uga_proto,
 +					NULL, &size, uga_handle);
++=======
+ 		status = efi_call_early(locate_handle,
+ 					EFI_LOCATE_BY_PROTOCOL,
+ 					&uga_proto, NULL, &size, uga_handle);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  		if (status == EFI_BUFFER_TOO_SMALL)
  			setup_uga(si, &uga_proto, size);
  	}
@@@ -499,8 -1044,13 +1349,18 @@@ struct boot_params *make_boot_params(vo
  	if (sys_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)
  		return NULL;
  
++<<<<<<< HEAD
 +	status = efi_call_phys3(sys_table->boottime->handle_protocol,
 +				handle, &proto, (void *)&image);
++=======
+ 	if (efi_early->is64)
+ 		setup_boot_services64(efi_early);
+ 	else
+ 		setup_boot_services32(efi_early);
+ 
+ 	status = efi_call_early(handle_protocol, handle,
+ 				&proto, (void *)&image);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  	if (status != EFI_SUCCESS) {
  		efi_printk(sys_table, "Failed to get handle for LOADED_IMAGE_PROTOCOL\n");
  		return NULL;
@@@ -688,14 -1239,13 +1548,23 @@@ static efi_status_t alloc_e820ext(u32 n
  		sizeof(struct e820entry) * nr_desc;
  
  	if (*e820ext) {
++<<<<<<< HEAD
 +		efi_call_phys1(sys_table->boottime->free_pool, *e820ext);
++=======
+ 		efi_call_early(free_pool, *e820ext);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  		*e820ext = NULL;
  		*e820ext_size = 0;
  	}
  
++<<<<<<< HEAD
 +	status = efi_call_phys3(sys_table->boottime->allocate_pool,
 +				EFI_LOADER_DATA, size, e820ext);
 +
++=======
+ 	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
+ 				size, (void **)e820ext);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  	if (status == EFI_SUCCESS)
  		*e820ext_size = size;
  
@@@ -738,7 -1289,7 +1607,11 @@@ get_map
  		if (status != EFI_SUCCESS)
  			goto free_mem_map;
  
++<<<<<<< HEAD
 +		efi_call_phys1(sys_table->boottime->free_pool, mem_map);
++=======
+ 		efi_call_early(free_pool, mem_map);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  		goto get_map; /* Allocated memory, get map again */
  	}
  
@@@ -755,8 -1308,7 +1628,12 @@@
  #endif
  
  	/* Might as well exit boot services now */
++<<<<<<< HEAD
 +	status = efi_call_phys2(sys_table->boottime->exit_boot_services,
 +				handle, key);
++=======
+ 	status = efi_call_early(exit_boot_services, handle, key);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  	if (status != EFI_SUCCESS) {
  		/*
  		 * ExitBootServices() will fail if any of the event
@@@ -769,7 -1321,7 +1646,11 @@@
  			goto free_mem_map;
  
  		called_exit = true;
++<<<<<<< HEAD
 +		efi_call_phys1(sys_table->boottime->free_pool, mem_map);
++=======
+ 		efi_call_early(free_pool, mem_map);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  		goto get_map;
  	}
  
@@@ -783,7 -1335,7 +1664,11 @@@
  	return EFI_SUCCESS;
  
  free_mem_map:
++<<<<<<< HEAD
 +	efi_call_phys1(sys_table->boottime->free_pool, mem_map);
++=======
+ 	efi_call_early(free_pool, mem_map);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  	return status;
  }
  
@@@ -815,9 -1376,8 +1700,14 @@@ struct boot_params *efi_main(void *hand
  
  	setup_efi_pci(boot_params);
  
++<<<<<<< HEAD
 +	status = efi_call_phys3(sys_table->boottime->allocate_pool,
 +				EFI_LOADER_DATA, sizeof(*gdt),
 +				(void **)&gdt);
++=======
+ 	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
+ 				sizeof(*gdt), (void **)&gdt);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  	if (status != EFI_SUCCESS) {
  		efi_printk(sys_table, "Failed to alloc mem for gdt structure\n");
  		goto fail;
diff --cc drivers/firmware/efi/efi-stub-helper.c
index f243c3499856,ff50aeebf0d9..000000000000
--- a/drivers/firmware/efi/efi-stub-helper.c
+++ b/drivers/firmware/efi/efi-stub-helper.c
@@@ -65,20 -53,23 +65,39 @@@ again
  	 * allocation which may be in a new descriptor region.
  	 */
  	*map_size += sizeof(*m);
++<<<<<<< HEAD
 +	status = efi_call_phys3(sys_table_arg->boottime->allocate_pool,
 +				EFI_LOADER_DATA, *map_size, (void **)&m);
 +	if (status != EFI_SUCCESS)
 +		goto fail;
 +
 +	status = efi_call_phys5(sys_table_arg->boottime->get_memory_map,
 +				map_size, m, &key, desc_size, &desc_version);
 +	if (status == EFI_BUFFER_TOO_SMALL) {
 +		efi_call_phys1(sys_table_arg->boottime->free_pool, m);
++=======
+ 	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
+ 				*map_size, (void **)&m);
+ 	if (status != EFI_SUCCESS)
+ 		goto fail;
+ 
+ 	*desc_size = 0;
+ 	key = 0;
+ 	status = efi_call_early(get_memory_map, map_size, m,
+ 				&key, desc_size, &desc_version);
+ 	if (status == EFI_BUFFER_TOO_SMALL) {
+ 		efi_call_early(free_pool, m);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  		goto again;
  	}
  
  	if (status != EFI_SUCCESS)
++<<<<<<< HEAD
 +		efi_call_phys1(sys_table_arg->boottime->free_pool, m);
++=======
+ 		efi_call_early(free_pool, m);
+ 
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  	if (key_ptr && status == EFI_SUCCESS)
  		*key_ptr = key;
  	if (desc_ver && status == EFI_SUCCESS)
@@@ -150,7 -149,7 +169,11 @@@ again
  	if (!max_addr)
  		status = EFI_NOT_FOUND;
  	else {
++<<<<<<< HEAD
 +		status = efi_call_phys4(sys_table_arg->boottime->allocate_pages,
++=======
+ 		status = efi_call_early(allocate_pages,
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  					EFI_ALLOCATE_ADDRESS, EFI_LOADER_DATA,
  					nr_pages, &max_addr);
  		if (status != EFI_SUCCESS) {
@@@ -162,8 -161,7 +185,12 @@@
  		*addr = max_addr;
  	}
  
++<<<<<<< HEAD
 +	efi_call_phys1(sys_table_arg->boottime->free_pool, map);
 +
++=======
+ 	efi_call_early(free_pool, map);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  fail:
  	return status;
  }
@@@ -215,7 -221,7 +242,11 @@@ static efi_status_t efi_low_alloc(efi_s
  		if ((start + size) > end)
  			continue;
  
++<<<<<<< HEAD
 +		status = efi_call_phys4(sys_table_arg->boottime->allocate_pages,
++=======
+ 		status = efi_call_early(allocate_pages,
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  					EFI_ALLOCATE_ADDRESS, EFI_LOADER_DATA,
  					nr_pages, &start);
  		if (status == EFI_SUCCESS) {
@@@ -227,7 -233,7 +258,11 @@@
  	if (i == map_size / desc_size)
  		status = EFI_NOT_FOUND;
  
++<<<<<<< HEAD
 +	efi_call_phys1(sys_table_arg->boottime->free_pool, map);
++=======
+ 	efi_call_early(free_pool, map);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  fail:
  	return status;
  }
@@@ -241,7 -247,7 +276,11 @@@ static void efi_free(efi_system_table_
  		return;
  
  	nr_pages = round_up(size, EFI_PAGE_SIZE) / EFI_PAGE_SIZE;
++<<<<<<< HEAD
 +	efi_call_phys2(sys_table_arg->boottime->free_pages, addr, nr_pages);
++=======
+ 	efi_call_early(free_pages, addr, nr_pages);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  }
  
  
@@@ -291,15 -304,13 +330,20 @@@ static efi_status_t handle_ramdisks(efi
  			str++;
  	}
  
 -	if (!nr_files)
 +	if (!nr_initrds)
  		return EFI_SUCCESS;
  
++<<<<<<< HEAD
 +	status = efi_call_phys3(sys_table_arg->boottime->allocate_pool,
 +				EFI_LOADER_DATA,
 +				nr_initrds * sizeof(*initrds),
 +				&initrds);
++=======
+ 	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
+ 				nr_files * sizeof(*files), (void **)&files);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  	if (status != EFI_SUCCESS) {
 -		efi_printk(sys_table_arg, "Failed to alloc mem for file handle list\n");
 +		efi_printk(sys_table_arg, "Failed to alloc mem for initrds\n");
  		goto fail;
  	}
  
@@@ -457,10 -413,10 +501,14 @@@ grow
  
  	}
  
++<<<<<<< HEAD
 +	efi_call_phys1(sys_table_arg->boottime->free_pool, initrds);
++=======
+ 	efi_call_early(free_pool, files);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  
 -	*load_addr = file_addr;
 -	*load_size = file_size_total;
 +	hdr->ramdisk_image = initrd_addr;
 +	hdr->ramdisk_size = initrd_total;
  
  	return status;
  
@@@ -469,12 -425,12 +517,18 @@@ free_initrd_total
  
  close_handles:
  	for (k = j; k < i; k++)
++<<<<<<< HEAD
 +		efi_call_phys1(fh->close, initrds[k].handle);
 +free_initrds:
 +	efi_call_phys1(sys_table_arg->boottime->free_pool, initrds);
++=======
+ 		efi_file_close(fh, files[k].handle);
+ free_files:
+ 	efi_call_early(free_pool, files);
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  fail:
 -	*load_addr = 0;
 -	*load_size = 0;
 +	hdr->ramdisk_image = 0;
 +	hdr->ramdisk_size = 0;
  
  	return status;
  }
@@@ -486,30 -457,47 +540,46 @@@ static efi_status_t relocate_kernel(str
  
  	/*
  	 * The EFI firmware loader could have placed the kernel image
++<<<<<<< HEAD
 +	 * anywhere in memory, but the kernel has various restrictions
 +	 * on the max physical address it can run at. Attempt to move
 +	 * the kernel to boot_params.pref_address, or as low as
++=======
+ 	 * anywhere in memory, but the kernel has restrictions on the
+ 	 * max physical address it can run at.  Some architectures
+ 	 * also have a prefered address, so first try to relocate
+ 	 * to the preferred address.  If that fails, allocate as low
+ 	 * as possible while respecting the required alignment.
+ 	 */
+ 	nr_pages = round_up(alloc_size, EFI_PAGE_SIZE) / EFI_PAGE_SIZE;
+ 	status = efi_call_early(allocate_pages,
+ 				EFI_ALLOCATE_ADDRESS, EFI_LOADER_DATA,
+ 				nr_pages, &efi_addr);
+ 	new_addr = efi_addr;
+ 	/*
+ 	 * If preferred address allocation failed allocate as low as
++>>>>>>> 204b0a1a4b92 (x86, efi: Abstract x86 efi_early calls)
  	 * possible.
  	 */
 +	start = hdr->pref_address;
 +	nr_pages = round_up(hdr->init_size, EFI_PAGE_SIZE) / EFI_PAGE_SIZE;
 +
 +	status = efi_call_phys4(sys_table->boottime->allocate_pages,
 +				EFI_ALLOCATE_ADDRESS, EFI_LOADER_DATA,
 +				nr_pages, &start);
  	if (status != EFI_SUCCESS) {
 -		status = efi_low_alloc(sys_table_arg, alloc_size, alignment,
 -				       &new_addr);
 -	}
 -	if (status != EFI_SUCCESS) {
 -		efi_printk(sys_table_arg, "ERROR: Failed to allocate usable memory for kernel.\n");
 -		return status;
 +		status = efi_low_alloc(sys_table, hdr->init_size,
 +				   hdr->kernel_alignment, &start);
 +		if (status != EFI_SUCCESS)
 +			efi_printk(sys_table, "Failed to alloc mem for kernel\n");
  	}
  
 -	/*
 -	 * We know source/dest won't overlap since both memory ranges
 -	 * have been allocated by UEFI, so we can safely use memcpy.
 -	 */
 -	memcpy((void *)new_addr, (void *)cur_image_addr, image_size);
 +	if (status == EFI_SUCCESS)
 +		memcpy((void *)start, (void *)(unsigned long)hdr->code32_start,
 +		       hdr->init_size);
  
 -	/* Return the new address of the relocated image. */
 -	*image_addr = new_addr;
 +	hdr->pref_address = hdr->code32_start;
 +	hdr->code32_start = (__u32)start;
  
  	return status;
  }
* Unmerged path arch/x86/boot/compressed/eboot.c
* Unmerged path drivers/firmware/efi/efi-stub-helper.c
