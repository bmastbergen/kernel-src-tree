bridge: Fix network header pointer for vlan tagged packets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
commit df356d5e81b04dd51dd9f23f2bce7d73dd929899
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/df356d5e.failed

There are several devices that can receive vlan tagged packets with
CHECKSUM_PARTIAL like tap, possibly veth and xennet.
When (multiple) vlan tagged packets with CHECKSUM_PARTIAL are forwarded
by bridge to a device with the IP_CSUM feature, they end up with checksum
error because before entering bridge, the network header is set to
ETH_HLEN (not including vlan header length) in __netif_receive_skb_core(),
get_rps_cpu(), or drivers' rx functions, and nobody fixes the pointer later.

Since the network header is exepected to be ETH_HLEN in flow-dissection
and hash-calculation in RPS in rx path, and since the header pointer fix
is needed only in tx path, set the appropriate network header on forwarding
packets.

	Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit df356d5e81b04dd51dd9f23f2bce7d73dd929899)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_forward.c
diff --cc net/bridge/br_forward.c
index 7040bea232a3,fa7bfced888e..000000000000
--- a/net/bridge/br_forward.c
+++ b/net/bridge/br_forward.c
@@@ -42,18 -37,33 +42,43 @@@ static inline unsigned int packet_lengt
  
  int br_dev_queue_push_xmit(struct sock *sk, struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	/* ip_fragment doesn't copy the MAC header */
 +	if (nf_bridge_maybe_copy_header(skb) ||
 +	    (packet_length(skb) > skb->dev->mtu && !skb_is_gso(skb))) {
 +		kfree_skb(skb);
 +	} else {
 +		skb_push(skb, ETH_HLEN);
 +		br_drop_fake_rtable(skb);
 +		dev_queue_xmit(skb);
++=======
+ 	if (!is_skb_forwardable(skb->dev, skb))
+ 		goto drop;
+ 
+ 	skb_push(skb, ETH_HLEN);
+ 	br_drop_fake_rtable(skb);
+ 	skb_sender_cpu_clear(skb);
+ 
+ 	if (skb->ip_summed == CHECKSUM_PARTIAL &&
+ 	    (skb->protocol == htons(ETH_P_8021Q) ||
+ 	     skb->protocol == htons(ETH_P_8021AD))) {
+ 		int depth;
+ 
+ 		if (!__vlan_get_protocol(skb, skb->protocol, &depth))
+ 			goto drop;
+ 
+ 		skb_set_network_header(skb, depth);
++>>>>>>> df356d5e81b0 (bridge: Fix network header pointer for vlan tagged packets)
  	}
  
+ 	dev_queue_xmit(skb);
+ 
+ 	return 0;
+ 
+ drop:
+ 	kfree_skb(skb);
  	return 0;
  }
 -EXPORT_SYMBOL_GPL(br_dev_queue_push_xmit);
  
  int br_forward_finish(struct sock *sk, struct sk_buff *skb)
  {
* Unmerged path net/bridge/br_forward.c
