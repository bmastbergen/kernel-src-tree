powercap / RAPL: handle domains with different energy units

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [powercap] rapl: handle domains with different energy units (Steve Best) [1274035]
Rebuild_FUZZ: 89.72%
commit-author Jacob Pan <jacob.jun.pan@linux.intel.com>
commit d474a4d365aaa5c7aabcf11a74ea43aa23f6f2e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d474a4d3.failed

The current driver assumes all RAPL domains within a CPU package
have the same energy unit. This is no longer true for HSW server
CPUs since DRAM domain has is own fixed energy unit which can be
different than the package energy unit enumerated by package
power MSR. In fact, the default HSW EP package power unit is 61uJ
whereas DRAM domain unit is 15.3uJ. The result is that DRAM power
consumption is counted 4x more than real power reported by energy
counters, similarly for max_energy_range_uj of DRAM domain.

This patch adds domain specific energy unit per cpu type, it allows
domain energy unit to override package energy unit if non zero.

Please see this document for details.
"Intel Xeon Processor E5-1600 and E5-2600 v3 Product Families, Volume 2 of 2.
 Datasheet, September 2014, Reference Number: 330784-001 "

	Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Cc: 3.10+ <stable@vger.kernel.org> # 3.10+
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit d474a4d365aaa5c7aabcf11a74ea43aa23f6f2e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/powercap/intel_rapl.c
diff --cc drivers/powercap/intel_rapl.c
index 0fe8b75d996c,63d4033eb683..000000000000
--- a/drivers/powercap/intel_rapl.c
+++ b/drivers/powercap/intel_rapl.c
@@@ -70,14 -71,9 +70,14 @@@
  #define RAPL_PRIMITIVE_DERIVED       BIT(1) /* not from raw data */
  #define RAPL_PRIMITIVE_DUMMY         BIT(2)
  
 +/* scale RAPL units to avoid floating point math inside kernel */
 +#define POWER_UNIT_SCALE     (1000000)
 +#define ENERGY_UNIT_SCALE    (1000000)
 +#define TIME_UNIT_SCALE      (1000000)
 +
  #define TIME_WINDOW_MAX_MSEC 40000
  #define TIME_WINDOW_MIN_MSEC 250
- 
+ #define ENERGY_UNIT_SCALE    1000 /* scale from driver unit to powercap unit */
  enum unit_type {
  	ARBITRARY_UNIT, /* no translation */
  	POWER_UNIT,
@@@ -188,6 -185,19 +189,22 @@@ struct rapl_package 
  					*/
  	struct list_head plist;
  };
++<<<<<<< HEAD
++=======
+ 
+ struct rapl_defaults {
+ 	int (*check_unit)(struct rapl_package *rp, int cpu);
+ 	void (*set_floor_freq)(struct rapl_domain *rd, bool mode);
+ 	u64 (*compute_time_window)(struct rapl_package *rp, u64 val,
+ 				bool to_raw);
+ 	unsigned int dram_domain_energy_unit;
+ };
+ static struct rapl_defaults *rapl_defaults;
+ 
+ /* Sideband MBI registers */
+ #define IOSF_CPU_POWER_BUDGET_CTL (0x2)
+ 
++>>>>>>> d474a4d365aa (powercap / RAPL: handle domains with different energy units)
  #define PACKAGE_PLN_INT_SAVED   BIT(0)
  #define MAX_PRIM_NAME (32)
  
@@@ -650,13 -658,13 +675,15 @@@ static void rapl_init_domains(struct ra
  	}
  }
  
- static u64 rapl_unit_xlate(int package, enum unit_type type, u64 value,
+ static u64 rapl_unit_xlate(struct rapl_domain *rd, int package,
+ 			enum unit_type type, u64 value,
  			int to_raw)
  {
 -	u64 units = 1;
 +	u64 divisor = 1;
 +	int scale = 1; /* scale to user friendly data without floating point */
 +	u64 f, y; /* fraction and exp. used for time unit */
  	struct rapl_package *rp;
+ 	u64 scale = 1;
  
  	rp = find_package_by_id(package);
  	if (!rp)
@@@ -669,37 -676,25 +696,53 @@@
  		break;
  	case ENERGY_UNIT:
  		scale = ENERGY_UNIT_SCALE;
++<<<<<<< HEAD
 +		divisor = rp->energy_unit_divisor;
++=======
+ 		/* per domain unit takes precedence */
+ 		if (rd && rd->domain_energy_unit)
+ 			units = rd->domain_energy_unit;
+ 		else
+ 			units = rp->energy_unit;
++>>>>>>> d474a4d365aa (powercap / RAPL: handle domains with different energy units)
  		break;
  	case TIME_UNIT:
 -		return rapl_defaults->compute_time_window(rp, value, to_raw);
 +		divisor = rp->time_unit_divisor;
 +		scale = TIME_UNIT_SCALE;
 +		/* special processing based on 2^Y*(1+F)/4 = val/divisor, refer
 +		 * to Intel Software Developer's manual Vol. 3a, CH 14.7.4.
 +		 */
 +		if (!to_raw) {
 +			f = (value & 0x60) >> 5;
 +			y = value & 0x1f;
 +			value = (1 << y) * (4 + f) * scale / 4;
 +			return div64_u64(value, divisor);
 +		} else {
 +			do_div(value, scale);
 +			value *= divisor;
 +			y = ilog2(value);
 +			f = div64_u64(4 * (value - (1 << y)), 1 << y);
 +			value = (y & 0x1f) | ((f & 0x3) << 5);
 +			return value;
 +		}
 +		break;
  	case ARBITRARY_UNIT:
  	default:
  		return value;
  	};
  
  	if (to_raw)
++<<<<<<< HEAD
 +		return div64_u64(value * divisor, scale);
 +	else
 +		return div64_u64(value * scale, divisor);
++=======
+ 		return div64_u64(value, units) * scale;
+ 
+ 	value *= units;
+ 
+ 	return div64_u64(value, scale);
++>>>>>>> d474a4d365aa (powercap / RAPL: handle domains with different energy units)
  }
  
  /* in the order of enum rapl_primitives */
@@@ -833,12 -828,18 +876,27 @@@ static int rapl_write_data_raw(struct r
  	return 0;
  }
  
++<<<<<<< HEAD
 +static const struct x86_cpu_id energy_unit_quirk_ids[] = {
 +	{ X86_VENDOR_INTEL, 6, 0x37},/* Valleyview */
 +	{}
 +};
 +
 +static int rapl_check_unit(struct rapl_package *rp, int cpu)
++=======
+ /*
+  * Raw RAPL data stored in MSRs are in certain scales. We need to
+  * convert them into standard units based on the units reported in
+  * the RAPL unit MSRs. This is specific to CPUs as the method to
+  * calculate units differ on different CPUs.
+  * We convert the units to below format based on CPUs.
+  * i.e.
+  * energy unit: picoJoules  : Represented in picoJoules by default
+  * power unit : microWatts  : Represented in milliWatts by default
+  * time unit  : microseconds: Represented in seconds by default
+  */
+ static int rapl_check_unit_core(struct rapl_package *rp, int cpu)
++>>>>>>> d474a4d365aa (powercap / RAPL: handle domains with different energy units)
  {
  	u64 msr_val;
  	u32 value;
@@@ -849,36 -850,47 +907,74 @@@
  		return -ENODEV;
  	}
  
 +	/* Raw RAPL data stored in MSRs are in certain scales. We need to
 +	 * convert them into standard units based on the divisors reported in
 +	 * the RAPL unit MSRs.
 +	 * i.e.
 +	 * energy unit: 1/enery_unit_divisor Joules
 +	 * power unit: 1/power_unit_divisor Watts
 +	 * time unit: 1/time_unit_divisor Seconds
 +	 */
  	value = (msr_val & ENERGY_UNIT_MASK) >> ENERGY_UNIT_OFFSET;
++<<<<<<< HEAD
 +	/* some CPUs have different way to calculate energy unit */
 +	if (x86_match_cpu(energy_unit_quirk_ids))
 +		rp->energy_unit_divisor = 1000000 / (1 << value);
 +	else
 +		rp->energy_unit_divisor = 1 << value;
++=======
+ 	rp->energy_unit = ENERGY_UNIT_SCALE * 1000000 / (1 << value);
++>>>>>>> d474a4d365aa (powercap / RAPL: handle domains with different energy units)
  
  	value = (msr_val & POWER_UNIT_MASK) >> POWER_UNIT_OFFSET;
 -	rp->power_unit = 1000000 / (1 << value);
 +	rp->power_unit_divisor = 1 << value;
  
  	value = (msr_val & TIME_UNIT_MASK) >> TIME_UNIT_OFFSET;
 -	rp->time_unit = 1000000 / (1 << value);
 -
 +	rp->time_unit_divisor = 1 << value;
 +
++<<<<<<< HEAD
 +	pr_debug("Physical package %d units: energy=%d, time=%d, power=%d\n",
 +		rp->id,
 +		rp->energy_unit_divisor,
 +		rp->time_unit_divisor,
 +		rp->power_unit_divisor);
++=======
+ 	pr_debug("Core CPU package %d energy=%dpJ, time=%dus, power=%duW\n",
+ 		rp->id, rp->energy_unit, rp->time_unit, rp->power_unit);
++>>>>>>> d474a4d365aa (powercap / RAPL: handle domains with different energy units)
  
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int rapl_check_unit_atom(struct rapl_package *rp, int cpu)
+ {
+ 	u64 msr_val;
+ 	u32 value;
+ 
+ 	if (rdmsrl_safe_on_cpu(cpu, MSR_RAPL_POWER_UNIT, &msr_val)) {
+ 		pr_err("Failed to read power unit MSR 0x%x on CPU %d, exit.\n",
+ 			MSR_RAPL_POWER_UNIT, cpu);
+ 		return -ENODEV;
+ 	}
+ 	value = (msr_val & ENERGY_UNIT_MASK) >> ENERGY_UNIT_OFFSET;
+ 	rp->energy_unit = ENERGY_UNIT_SCALE * 1 << value;
+ 
+ 	value = (msr_val & POWER_UNIT_MASK) >> POWER_UNIT_OFFSET;
+ 	rp->power_unit = (1 << value) * 1000;
+ 
+ 	value = (msr_val & TIME_UNIT_MASK) >> TIME_UNIT_OFFSET;
+ 	rp->time_unit = 1000000 / (1 << value);
+ 
+ 	pr_debug("Atom package %d energy=%dpJ, time=%dus, power=%duW\n",
+ 		rp->id, rp->energy_unit, rp->time_unit, rp->power_unit);
+ 
+ 	return 0;
+ }
+ 
+ 
++>>>>>>> d474a4d365aa (powercap / RAPL: handle domains with different energy units)
  /* REVISIT:
   * When package power limit is set artificially low by RAPL, LVT
   * thermal interrupt for package power limit should be ignored
@@@ -946,22 -958,115 +1042,134 @@@ static void package_power_limit_irq_res
  	wrmsr_on_cpu(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);
  }
  
++<<<<<<< HEAD
 +static const struct x86_cpu_id rapl_ids[] = {
 +	{ X86_VENDOR_INTEL, 6, 0x2a},/* Sandy Bridge */
 +	{ X86_VENDOR_INTEL, 6, 0x2d},/* Sandy Bridge EP */
 +	{ X86_VENDOR_INTEL, 6, 0x37},/* Valleyview */
 +	{ X86_VENDOR_INTEL, 6, 0x3a},/* Ivy Bridge */
 +	{ X86_VENDOR_INTEL, 6, 0x3c},/* Haswell */
 +	{ X86_VENDOR_INTEL, 6, 0x3d},/* Broadwell */
 +	{ X86_VENDOR_INTEL, 6, 0x3f},/* Haswell */
 +	{ X86_VENDOR_INTEL, 6, 0x4f},/* Broadwell servers */
 +	{ X86_VENDOR_INTEL, 6, 0x45},/* Haswell ULT */
 +	{ X86_VENDOR_INTEL, 6, 0x47},/* Broadwell-H */
 +	{ X86_VENDOR_INTEL, 6, 0x4E},/* Skylake */
 +	{ X86_VENDOR_INTEL, 6, 0x56},/* Future Xeon */
 +	{ X86_VENDOR_INTEL, 6, 0x57},/* Knights Landing */
 +	{ X86_VENDOR_INTEL, 6, 0x5E},/* Skylake-H/S */
 +	/* TODO: Add more CPU IDs after testing */
++=======
+ static void set_floor_freq_default(struct rapl_domain *rd, bool mode)
+ {
+ 	int nr_powerlimit = find_nr_power_limit(rd);
+ 
+ 	/* always enable clamp such that p-state can go below OS requested
+ 	 * range. power capping priority over guranteed frequency.
+ 	 */
+ 	rapl_write_data_raw(rd, PL1_CLAMP, mode);
+ 
+ 	/* some domains have pl2 */
+ 	if (nr_powerlimit > 1) {
+ 		rapl_write_data_raw(rd, PL2_ENABLE, mode);
+ 		rapl_write_data_raw(rd, PL2_CLAMP, mode);
+ 	}
+ }
+ 
+ static void set_floor_freq_atom(struct rapl_domain *rd, bool enable)
+ {
+ 	static u32 power_ctrl_orig_val;
+ 	u32 mdata;
+ 
+ 	if (!power_ctrl_orig_val)
+ 		iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_PMC_READ,
+ 			IOSF_CPU_POWER_BUDGET_CTL, &power_ctrl_orig_val);
+ 	mdata = power_ctrl_orig_val;
+ 	if (enable) {
+ 		mdata &= ~(0x7f << 8);
+ 		mdata |= 1 << 8;
+ 	}
+ 	iosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_PMC_WRITE,
+ 		IOSF_CPU_POWER_BUDGET_CTL, mdata);
+ }
+ 
+ static u64 rapl_compute_time_window_core(struct rapl_package *rp, u64 value,
+ 					bool to_raw)
+ {
+ 	u64 f, y; /* fraction and exp. used for time unit */
+ 
+ 	/*
+ 	 * Special processing based on 2^Y*(1+F/4), refer
+ 	 * to Intel Software Developer's manual Vol.3B: CH 14.9.3.
+ 	 */
+ 	if (!to_raw) {
+ 		f = (value & 0x60) >> 5;
+ 		y = value & 0x1f;
+ 		value = (1 << y) * (4 + f) * rp->time_unit / 4;
+ 	} else {
+ 		do_div(value, rp->time_unit);
+ 		y = ilog2(value);
+ 		f = div64_u64(4 * (value - (1 << y)), 1 << y);
+ 		value = (y & 0x1f) | ((f & 0x3) << 5);
+ 	}
+ 	return value;
+ }
+ 
+ static u64 rapl_compute_time_window_atom(struct rapl_package *rp, u64 value,
+ 					bool to_raw)
+ {
+ 	/*
+ 	 * Atom time unit encoding is straight forward val * time_unit,
+ 	 * where time_unit is default to 1 sec. Never 0.
+ 	 */
+ 	if (!to_raw)
+ 		return (value) ? value *= rp->time_unit : rp->time_unit;
+ 	else
+ 		value = div64_u64(value, rp->time_unit);
+ 
+ 	return value;
+ }
+ 
+ static const struct rapl_defaults rapl_defaults_core = {
+ 	.check_unit = rapl_check_unit_core,
+ 	.set_floor_freq = set_floor_freq_default,
+ 	.compute_time_window = rapl_compute_time_window_core,
+ };
+ 
+ static const struct rapl_defaults rapl_defaults_hsw_server = {
+ 	.check_unit = rapl_check_unit_core,
+ 	.set_floor_freq = set_floor_freq_default,
+ 	.compute_time_window = rapl_compute_time_window_core,
+ 	.dram_domain_energy_unit = 15300,
+ };
+ 
+ static const struct rapl_defaults rapl_defaults_atom = {
+ 	.check_unit = rapl_check_unit_atom,
+ 	.set_floor_freq = set_floor_freq_atom,
+ 	.compute_time_window = rapl_compute_time_window_atom,
+ };
+ 
+ #define RAPL_CPU(_model, _ops) {			\
+ 		.vendor = X86_VENDOR_INTEL,		\
+ 		.family = 6,				\
+ 		.model = _model,			\
+ 		.driver_data = (kernel_ulong_t)&_ops,	\
+ 		}
+ 
+ static const struct x86_cpu_id rapl_ids[] = {
+ 	RAPL_CPU(0x2a, rapl_defaults_core),/* Sandy Bridge */
+ 	RAPL_CPU(0x2d, rapl_defaults_core),/* Sandy Bridge EP */
+ 	RAPL_CPU(0x37, rapl_defaults_atom),/* Valleyview */
+ 	RAPL_CPU(0x3a, rapl_defaults_core),/* Ivy Bridge */
+ 	RAPL_CPU(0x3c, rapl_defaults_core),/* Haswell */
+ 	RAPL_CPU(0x3d, rapl_defaults_core),/* Broadwell */
+ 	RAPL_CPU(0x3f, rapl_defaults_hsw_server),/* Haswell servers */
+ 	RAPL_CPU(0x45, rapl_defaults_core),/* Haswell ULT */
+ 	RAPL_CPU(0x4C, rapl_defaults_atom),/* Braswell */
+ 	RAPL_CPU(0x4A, rapl_defaults_atom),/* Tangier */
+ 	RAPL_CPU(0x56, rapl_defaults_core),/* Future Xeon */
+ 	RAPL_CPU(0x5A, rapl_defaults_atom),/* Annidale */
++>>>>>>> d474a4d365aa (powercap / RAPL: handle domains with different energy units)
  	{}
  };
  MODULE_DEVICE_TABLE(x86cpu, rapl_ids);
* Unmerged path drivers/powercap/intel_rapl.c
