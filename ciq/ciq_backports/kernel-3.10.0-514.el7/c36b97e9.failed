GFS2: Protect freeing directory hash table with i_lock spin_lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit c36b97e9430defab4b52ee370c18745343d92f6d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c36b97e9.failed

This patch changes function gfs2_dir_hash_inval so it uses the
i_lock spin_lock to protect the in-core hash table, i_hash_cache.
This will prevent double-frees due to a race between gfs2_evict_inode
and inode invalidation.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit c36b97e9430defab4b52ee370c18745343d92f6d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/dir.c
diff --cc fs/gfs2/dir.c
index e95eadc3e343,ad8a5b757cc7..000000000000
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@@ -392,12 -388,14 +392,21 @@@ static __be64 *gfs2_dir_get_hash_table(
   */
  void gfs2_dir_hash_inval(struct gfs2_inode *ip)
  {
- 	__be64 *hc = ip->i_hash_cache;
+ 	__be64 *hc;
+ 
+ 	spin_lock(&ip->i_inode.i_lock);
+ 	hc = ip->i_hash_cache;
  	ip->i_hash_cache = NULL;
++<<<<<<< HEAD
 +	if (is_vmalloc_addr(hc))
 +		vfree(hc);
 +	else
 +		kfree(hc);
++=======
+ 	spin_unlock(&ip->i_inode.i_lock);
+ 
+ 	kvfree(hc);
++>>>>>>> c36b97e9430d (GFS2: Protect freeing directory hash table with i_lock spin_lock)
  }
  
  static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)
* Unmerged path fs/gfs2/dir.c
