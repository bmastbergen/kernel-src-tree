pmem: switch to devm_ allocations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 708ab62bef1ed3a3cf065a4138bd87f5d083cfeb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/708ab62b.failed

	Signed-off-by: Christoph Hellwig <hch@lst.de>
[djbw: tools/testing/nvdimm/ and memunmap_pmem support]
	Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 708ab62bef1ed3a3cf065a4138bd87f5d083cfeb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/pmem.c
#	include/linux/pmem.h
#	tools/testing/nvdimm/Kbuild
#	tools/testing/nvdimm/test/iomap.c
diff --cc drivers/block/pmem.c
index 0069d751af83,eb7552d939e1..000000000000
--- a/drivers/block/pmem.c
+++ b/drivers/block/pmem.c
@@@ -105,32 -118,41 +105,64 @@@ static struct pmem_device *pmem_alloc(s
  		struct resource *res, int id)
  {
  	struct pmem_device *pmem;
 +	struct gendisk *disk;
 +	int err;
  
++<<<<<<< HEAD:drivers/block/pmem.c
 +	err = -ENOMEM;
 +	pmem = kzalloc(sizeof(*pmem), GFP_KERNEL);
++=======
+ 	pmem = devm_kzalloc(dev, sizeof(*pmem), GFP_KERNEL);
++>>>>>>> 708ab62bef1e (pmem: switch to devm_ allocations):drivers/nvdimm/pmem.c
  	if (!pmem)
 -		return ERR_PTR(-ENOMEM);
 +		goto out;
  
  	pmem->phys_addr = res->start;
  	pmem->size = resource_size(res);
 -	if (!arch_has_pmem_api())
 -		dev_warn(dev, "unable to guarantee persistence of writes\n");
  
++<<<<<<< HEAD:drivers/block/pmem.c
 +	err = -EINVAL;
 +	if (!request_mem_region(pmem->phys_addr, pmem->size, "pmem")) {
 +		dev_warn(dev, "could not reserve region [0x%pa:0x%zx]\n",
 +				&pmem->phys_addr, pmem->size);
 +		goto out_free_dev;
 +	}
 +
 +	/*
 +	 * Map the memory as non-cachable, as we can't write back the contents
 +	 * of the CPU caches in case of a crash.
 +	 */
 +	err = -ENOMEM;
 +	pmem->virt_addr = ioremap_nocache(pmem->phys_addr, pmem->size);
 +	if (!pmem->virt_addr)
 +		goto out_release_region;
++=======
+ 	if (!devm_request_mem_region(dev, pmem->phys_addr, pmem->size,
+ 			dev_name(dev))) {
+ 		dev_warn(dev, "could not reserve region [0x%pa:0x%zx]\n",
+ 				&pmem->phys_addr, pmem->size);
+ 		return ERR_PTR(-EBUSY);
+ 	}
+ 
+ 	pmem->virt_addr = memremap_pmem(dev, pmem->phys_addr, pmem->size);
+ 	if (!pmem->virt_addr)
+ 		return ERR_PTR(-ENXIO);
+ 
+ 	return pmem;
+ }
+ 
+ static void pmem_detach_disk(struct pmem_device *pmem)
+ {
+ 	del_gendisk(pmem->pmem_disk);
+ 	put_disk(pmem->pmem_disk);
+ 	blk_cleanup_queue(pmem->pmem_queue);
+ }
+ 
+ static int pmem_attach_disk(struct nd_namespace_common *ndns,
+ 		struct pmem_device *pmem)
+ {
+ 	struct gendisk *disk;
++>>>>>>> 708ab62bef1e (pmem: switch to devm_ allocations):drivers/nvdimm/pmem.c
  
  	pmem->pmem_queue = blk_alloc_queue(GFP_KERNEL);
  	if (!pmem->pmem_queue)
@@@ -158,31 -182,31 +190,34 @@@
  	pmem->pmem_disk = disk;
  
  	add_disk(disk);
 -	revalidate_disk(disk);
  
 -	return 0;
 +	return pmem;
 +
 +out_free_queue:
 +	blk_cleanup_queue(pmem->pmem_queue);
 +out_unmap:
 +	iounmap(pmem->virt_addr);
 +out_release_region:
 +	release_mem_region(pmem->phys_addr, pmem->size);
 +out_free_dev:
 +	kfree(pmem);
 +out:
 +	return ERR_PTR(err);
  }
  
 -static int pmem_rw_bytes(struct nd_namespace_common *ndns,
 -		resource_size_t offset, void *buf, size_t size, int rw)
++<<<<<<< HEAD:drivers/block/pmem.c
 +static void pmem_free(struct pmem_device *pmem)
  {
 -	struct pmem_device *pmem = dev_get_drvdata(ndns->claim);
 -
 -	if (unlikely(offset + size > pmem->size)) {
 -		dev_WARN_ONCE(&ndns->dev, 1, "request out of range\n");
 -		return -EFAULT;
 -	}
 -
 -	if (rw == READ)
 -		memcpy_from_pmem(buf, pmem->virt_addr + offset, size);
 -	else {
 -		memcpy_to_pmem(pmem->virt_addr + offset, buf, size);
 -		wmb_pmem();
 -	}
 -
 -	return 0;
 +	del_gendisk(pmem->pmem_disk);
 +	put_disk(pmem->pmem_disk);
 +	blk_cleanup_queue(pmem->pmem_queue);
 +	iounmap(pmem->virt_addr);
 +	release_mem_region(pmem->phys_addr, pmem->size);
 +	kfree(pmem);
  }
  
++=======
++>>>>>>> 708ab62bef1e (pmem: switch to devm_ allocations):drivers/nvdimm/pmem.c
  static int nd_pmem_probe(struct device *dev)
  {
  	struct nd_region *nd_region = to_nd_region(dev->parent);
@@@ -194,15 -224,26 +229,35 @@@
  		return PTR_ERR(pmem);
  
  	dev_set_drvdata(dev, pmem);
++<<<<<<< HEAD:drivers/block/pmem.c
 +
 +	return 0;
++=======
+ 	ndns->rw_bytes = pmem_rw_bytes;
+ 
+ 	if (is_nd_btt(dev))
+ 		return nvdimm_namespace_attach_btt(ndns);
+ 
+ 	if (nd_btt_probe(ndns, pmem) == 0)
+ 		/* we'll come back as btt-pmem */
+ 		return -ENXIO;
+ 	return pmem_attach_disk(ndns, pmem);
++>>>>>>> 708ab62bef1e (pmem: switch to devm_ allocations):drivers/nvdimm/pmem.c
  }
  
  static int nd_pmem_remove(struct device *dev)
  {
  	struct pmem_device *pmem = dev_get_drvdata(dev);
  
++<<<<<<< HEAD:drivers/block/pmem.c
 +	pmem_free(pmem);
++=======
+ 	if (is_nd_btt(dev))
+ 		nvdimm_namespace_detach_btt(to_nd_btt(dev)->ndns);
+ 	else
+ 		pmem_detach_disk(pmem);
+ 
++>>>>>>> 708ab62bef1e (pmem: switch to devm_ allocations):drivers/nvdimm/pmem.c
  	return 0;
  }
  
* Unmerged path include/linux/pmem.h
* Unmerged path tools/testing/nvdimm/Kbuild
* Unmerged path tools/testing/nvdimm/test/iomap.c
* Unmerged path drivers/block/pmem.c
* Unmerged path include/linux/pmem.h
* Unmerged path tools/testing/nvdimm/Kbuild
* Unmerged path tools/testing/nvdimm/test/iomap.c
