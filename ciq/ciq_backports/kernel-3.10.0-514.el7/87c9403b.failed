virtio_balloon: fix PFN format for virtio-1

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Michael S. Tsirkin <mst@redhat.com>
commit 87c9403b0d1de4676b0bd273eea68fcf6de68e68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/87c9403b.failed

Everything should be LE when using virtio-1, but
the linux balloon driver does not seem to care about that.

	Reported-by: Cornelia Huck <cornelia.huck@de.ibm.com>
	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
	Tested-by: Cornelia Huck <cornelia.huck@de.ibm.com>
	Reviewed-by: Cornelia Huck <cornelia.huck@de.ibm.com>
(cherry picked from commit 87c9403b0d1de4676b0bd273eea68fcf6de68e68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/virtio/virtio_balloon.c
diff --cc drivers/virtio/virtio_balloon.c
index 5e461066deb2,476c0e3a7150..000000000000
--- a/drivers/virtio/virtio_balloon.c
+++ b/drivers/virtio/virtio_balloon.c
@@@ -72,10 -75,9 +72,10 @@@ struct virtio_balloon 
  
  	/* The array of pfns we tell the Host about. */
  	unsigned int num_pfns;
- 	u32 pfns[VIRTIO_BALLOON_ARRAY_PFNS_MAX];
+ 	__virtio32 pfns[VIRTIO_BALLOON_ARRAY_PFNS_MAX];
  
  	/* Memory statistics */
 +	int need_stats_update;
  	struct virtio_balloon_stat stats[VIRTIO_BALLOON_S_NR];
  
  	/* To register callback in oom notifier call chain */
@@@ -122,21 -124,25 +122,23 @@@ static void tell_host(struct virtio_bal
  
  	/* When host has read buffer, this completes via balloon_ack */
  	wait_event(vb->acked, virtqueue_get_buf(vq, &len));
 -
  }
  
- static void set_page_pfns(u32 pfns[], struct page *page)
+ static void set_page_pfns(struct virtio_balloon *vb,
+ 			  __virtio32 pfns[], struct page *page)
  {
  	unsigned int i;
  
  	/* Set balloon pfns pointing at this page.
  	 * Note that the first pfn points at start of the page. */
  	for (i = 0; i < VIRTIO_BALLOON_PAGES_PER_PAGE; i++)
- 		pfns[i] = page_to_balloon_pfn(page) + i;
+ 		pfns[i] = cpu_to_virtio32(vb->vdev,
+ 					  page_to_balloon_pfn(page) + i);
  }
  
 -static unsigned fill_balloon(struct virtio_balloon *vb, size_t num)
 +static void fill_balloon(struct virtio_balloon *vb, size_t num)
  {
 -	struct balloon_dev_info *vb_dev_info = &vb->vb_dev_info;
 -	unsigned num_allocated_pages;
 +	struct balloon_dev_info *vb_dev_info = vb->vb_dev_info;
  
  	/* We can only do one array worth at a time. */
  	num = min(num, ARRAY_SIZE(vb->pfns));
@@@ -154,25 -160,35 +156,36 @@@
  			msleep(200);
  			break;
  		}
- 		set_page_pfns(vb->pfns + vb->num_pfns, page);
+ 		set_page_pfns(vb, vb->pfns + vb->num_pfns, page);
  		vb->num_pages += VIRTIO_BALLOON_PAGES_PER_PAGE;
 -		if (!virtio_has_feature(vb->vdev,
 -					VIRTIO_BALLOON_F_DEFLATE_ON_OOM))
 -			adjust_managed_page_count(page, -1);
 +		totalram_pages--;
  	}
  
 -	num_allocated_pages = vb->num_pfns;
  	/* Did we get any? */
  	if (vb->num_pfns != 0)
  		tell_host(vb, vb->inflate_vq);
  	mutex_unlock(&vb->balloon_lock);
 -
 -	return num_allocated_pages;
  }
  
 -static void release_pages_balloon(struct virtio_balloon *vb)
 +static void release_pages_by_pfn(const u32 pfns[], unsigned int num)
  {
  	unsigned int i;
+ 	struct page *page;
  
  	/* Find pfns pointing at start of each page, get pages and free them. */
++<<<<<<< HEAD
 +	for (i = 0; i < num; i += VIRTIO_BALLOON_PAGES_PER_PAGE) {
 +		balloon_page_free(balloon_pfn_to_page(pfns[i]));
 +		totalram_pages++;
++=======
+ 	for (i = 0; i < vb->num_pfns; i += VIRTIO_BALLOON_PAGES_PER_PAGE) {
+ 		page = balloon_pfn_to_page(virtio32_to_cpu(vb->vdev,
+ 							   vb->pfns[i]));
+ 		if (!virtio_has_feature(vb->vdev,
+ 					VIRTIO_BALLOON_F_DEFLATE_ON_OOM))
+ 			adjust_managed_page_count(page, 1);
+ 		put_page(page); /* balloon reference */
++>>>>>>> 87c9403b0d1d (virtio_balloon: fix PFN format for virtio-1)
  	}
  }
  
@@@ -447,24 -466,22 +460,24 @@@ static int virtballoon_migratepage(stru
  	if (!mutex_trylock(&vb->balloon_lock))
  		return -EAGAIN;
  
 -	get_page(newpage); /* balloon reference */
 -
  	/* balloon's page migration 1st step  -- inflate "newpage" */
  	spin_lock_irqsave(&vb_dev_info->pages_lock, flags);
 -	balloon_page_insert(vb_dev_info, newpage);
 +	balloon_page_insert(newpage, mapping, &vb_dev_info->pages);
  	vb_dev_info->isolated_pages--;
 -	__count_vm_event(BALLOON_MIGRATE);
  	spin_unlock_irqrestore(&vb_dev_info->pages_lock, flags);
  	vb->num_pfns = VIRTIO_BALLOON_PAGES_PER_PAGE;
- 	set_page_pfns(vb->pfns, newpage);
+ 	set_page_pfns(vb, vb->pfns, newpage);
  	tell_host(vb, vb->inflate_vq);
  
 -	/* balloon's page migration 2nd step -- deflate "page" */
 +	/*
 +	 * balloon's page migration 2nd step -- deflate "page"
 +	 *
 +	 * It's safe to delete page->lru here because this page is at
 +	 * an isolated migration list, and this step is expected to happen here
 +	 */
  	balloon_page_delete(page);
  	vb->num_pfns = VIRTIO_BALLOON_PAGES_PER_PAGE;
- 	set_page_pfns(vb->pfns, page);
+ 	set_page_pfns(vb, vb->pfns, page);
  	tell_host(vb, vb->deflate_vq);
  
  	mutex_unlock(&vb->balloon_lock);
* Unmerged path drivers/virtio/virtio_balloon.c
