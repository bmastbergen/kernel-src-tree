bridge: move mac header copying into br_netfilter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Florian Westphal <fw@strlen.de>
commit 8bd63cf1a426e69bf4f611b08978f721e46c194f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8bd63cf1.failed

The mac header only has to be copied back into the skb for
fragments generated by ip_fragment(), which only happens
for bridge forwarded packets with nf-call-iptables=1 && active nf_defrag.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 8bd63cf1a426e69bf4f611b08978f721e46c194f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_forward.c
#	net/bridge/br_netfilter.c
diff --cc net/bridge/br_forward.c
index 7040bea232a3,32541d4f72e8..000000000000
--- a/net/bridge/br_forward.c
+++ b/net/bridge/br_forward.c
@@@ -30,21 -30,14 +30,25 @@@ static int deliver_clone(const struct n
  static inline int should_deliver(const struct net_bridge_port *p,
  				 const struct sk_buff *skb)
  {
 -	return ((p->flags & BR_HAIRPIN_MODE) || skb->dev != p->dev) &&
 +	return (((p->flags & BR_HAIRPIN_MODE) || skb->dev != p->dev) &&
  		br_allowed_egress(p->br, nbp_get_vlan_info(p), skb) &&
 -		p->state == BR_STATE_FORWARDING;
 +		p->state == BR_STATE_FORWARDING);
  }
  
 -int br_dev_queue_push_xmit(struct sk_buff *skb)
 +static inline unsigned int packet_length(const struct sk_buff *skb)
  {
 +	return skb->len - (skb->protocol == htons(ETH_P_8021Q) ? VLAN_HLEN : 0);
 +}
 +
 +int br_dev_queue_push_xmit(struct sock *sk, struct sk_buff *skb)
 +{
++<<<<<<< HEAD
 +	/* ip_fragment doesn't copy the MAC header */
 +	if (nf_bridge_maybe_copy_header(skb) ||
 +	    (packet_length(skb) > skb->dev->mtu && !skb_is_gso(skb))) {
++=======
+ 	if (!is_skb_forwardable(skb->dev, skb)) {
++>>>>>>> 8bd63cf1a426 (bridge: move mac header copying into br_netfilter)
  		kfree_skb(skb);
  	} else {
  		skb_push(skb, ETH_HLEN);
diff --cc net/bridge/br_netfilter.c
index d354bf857875,e5479112c4a3..000000000000
--- a/net/bridge/br_netfilter.c
+++ b/net/bridge/br_netfilter.c
@@@ -822,20 -763,53 +822,57 @@@ static unsigned int br_nf_forward_arp(c
  	return NF_STOLEN;
  }
  
++<<<<<<< HEAD
 +#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV4)
 +static int br_nf_dev_queue_xmit(struct sock *sk, struct sk_buff *skb)
++=======
+ #if IS_ENABLED(CONFIG_NF_DEFRAG_IPV4)
+ static bool nf_bridge_copy_header(struct sk_buff *skb)
+ {
+ 	int err;
+ 	unsigned int header_size;
+ 
+ 	nf_bridge_update_protocol(skb);
+ 	header_size = ETH_HLEN + nf_bridge_encap_header_len(skb);
+ 	err = skb_cow_head(skb, header_size);
+ 	if (err)
+ 		return false;
+ 
+ 	skb_copy_to_linear_data_offset(skb, -header_size,
+ 				       skb->nf_bridge->data, header_size);
+ 	__skb_push(skb, nf_bridge_encap_header_len(skb));
+ 	return true;
+ }
+ 
+ static int br_nf_push_frag_xmit(struct sk_buff *skb)
+ {
+ 	if (!nf_bridge_copy_header(skb)) {
+ 		kfree_skb(skb);
+ 		return 0;
+ 	}
+ 
+ 	return br_dev_queue_push_xmit(skb);
+ }
+ 
+ static int br_nf_dev_queue_xmit(struct sk_buff *skb)
++>>>>>>> 8bd63cf1a426 (bridge: move mac header copying into br_netfilter)
  {
  	int ret;
 -	int frag_max_size;
  
 -	/* This is wrong! We should preserve the original fragment
 -	 * boundaries by preserving frag_list rather than refragmenting.
 -	 */
 -	if (skb->protocol == htons(ETH_P_IP) &&
 +	if (skb->nfct != NULL && skb->protocol == htons(ETH_P_IP) &&
  	    skb->len + nf_bridge_mtu_reduction(skb) > skb->dev->mtu &&
  	    !skb_is_gso(skb)) {
 -		frag_max_size = BR_INPUT_SKB_CB(skb)->frag_max_size;
  		if (br_parse_ip_options(skb))
  			/* Drop invalid packet */
  			return NF_DROP;
++<<<<<<< HEAD
 +		ret = ip_fragment(sk, skb, br_dev_queue_push_xmit);
++=======
+ 		IPCB(skb)->frag_max_size = frag_max_size;
+ 		ret = ip_fragment(skb, br_nf_push_frag_xmit);
++>>>>>>> 8bd63cf1a426 (bridge: move mac header copying into br_netfilter)
  	} else
 -		ret = br_dev_queue_push_xmit(skb);
 +		ret = br_dev_queue_push_xmit(sk, skb);
  
  	return ret;
  }
diff --git a/include/linux/netfilter_bridge.h b/include/linux/netfilter_bridge.h
index 754600083b7e..5cc3cd297de7 100644
--- a/include/linux/netfilter_bridge.h
+++ b/include/linux/netfilter_bridge.h
@@ -44,36 +44,6 @@ static inline void nf_bridge_update_protocol(struct sk_buff *skb)
 		skb->protocol = htons(ETH_P_PPP_SES);
 }
 
-/* Fill in the header for fragmented IP packets handled by
- * the IPv4 connection tracking code.
- *
- * Only used in br_forward.c
- */
-static inline int nf_bridge_copy_header(struct sk_buff *skb)
-{
-	int err;
-	unsigned int header_size;
-
-	nf_bridge_update_protocol(skb);
-	header_size = ETH_HLEN + nf_bridge_encap_header_len(skb);
-	err = skb_cow_head(skb, header_size);
-	if (err)
-		return err;
-
-	skb_copy_to_linear_data_offset(skb, -header_size,
-				       skb->nf_bridge->data, header_size);
-	__skb_push(skb, nf_bridge_encap_header_len(skb));
-	return 0;
-}
-
-static inline int nf_bridge_maybe_copy_header(struct sk_buff *skb)
-{
-	if (skb->nf_bridge &&
-	    skb->nf_bridge->mask & (BRNF_BRIDGED | BRNF_BRIDGED_DNAT))
-		return nf_bridge_copy_header(skb);
-  	return 0;
-}
-
 static inline unsigned int nf_bridge_mtu_reduction(const struct sk_buff *skb)
 {
 	if (unlikely(skb->nf_bridge->mask & BRNF_PPPoE))
@@ -119,7 +89,6 @@ static inline void br_drop_fake_rtable(struct sk_buff *skb)
 }
 
 #else
-#define nf_bridge_maybe_copy_header(skb)	(0)
 #define nf_bridge_pad(skb)			(0)
 #define br_drop_fake_rtable(skb)	        do { } while (0)
 #endif /* CONFIG_BRIDGE_NETFILTER */
* Unmerged path net/bridge/br_forward.c
* Unmerged path net/bridge/br_netfilter.c
