udp: Simplify __udp*_lib_mcast_deliver.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] udp: Simplify __udp*_lib_mcast_deliver (Jiri Benc) [1297504]
Rebuild_FUZZ: 98.70%
commit-author David Held <drheld@google.com>
commit 5cf3d46192fccf68b4a4759e4d7346e41c669a76
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5cf3d461.failed

Switch to using sk_nulls_for_each which shortens the code and makes it
easier to update.

	Signed-off-by: David Held <drheld@google.com>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5cf3d46192fccf68b4a4759e4d7346e41c669a76)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp.c
#	net/ipv6/udp.c
diff --cc net/ipv4/udp.c
index 556580e2c4f8,bbcc33737ef1..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -578,34 -574,24 +578,55 @@@ struct sock *udp4_lib_lookup(struct ne
  }
  EXPORT_SYMBOL_GPL(udp4_lib_lookup);
  
++<<<<<<< HEAD
 +static inline struct sock *udp_v4_mcast_next(struct net *net, struct sock *sk,
 +					     __be16 loc_port, __be32 loc_addr,
 +					     __be16 rmt_port, __be32 rmt_addr,
 +					     int dif)
 +{
 +	struct hlist_nulls_node *node;
 +	struct sock *s = sk;
 +	unsigned short hnum = ntohs(loc_port);
 +
 +	sk_nulls_for_each_from(s, node) {
 +		struct inet_sock *inet = inet_sk(s);
 +
 +		if (!net_eq(sock_net(s), net) ||
 +		    udp_sk(s)->udp_port_hash != hnum ||
 +		    (inet->inet_daddr && inet->inet_daddr != rmt_addr) ||
 +		    (inet->inet_dport != rmt_port && inet->inet_dport) ||
 +		    (inet->inet_rcv_saddr &&
 +		     inet->inet_rcv_saddr != loc_addr) ||
 +		    ipv6_only_sock(s) ||
 +		    (s->sk_bound_dev_if && s->sk_bound_dev_if != dif))
 +			continue;
 +		if (!ip_mc_sf_allow(s, loc_addr, rmt_addr, dif))
 +			continue;
 +		goto found;
 +	}
 +	s = NULL;
 +found:
 +	return s;
++=======
+ static inline bool __udp_is_mcast_sock(struct net *net, struct sock *sk,
+ 				       __be16 loc_port, __be32 loc_addr,
+ 				       __be16 rmt_port, __be32 rmt_addr,
+ 				       int dif, unsigned short hnum)
+ {
+ 	struct inet_sock *inet = inet_sk(sk);
+ 
+ 	if (!net_eq(sock_net(sk), net) ||
+ 	    udp_sk(sk)->udp_port_hash != hnum ||
+ 	    (inet->inet_daddr && inet->inet_daddr != rmt_addr) ||
+ 	    (inet->inet_dport != rmt_port && inet->inet_dport) ||
+ 	    (inet->inet_rcv_saddr && inet->inet_rcv_saddr != loc_addr) ||
+ 	    ipv6_only_sock(sk) ||
+ 	    (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))
+ 		return false;
+ 	if (!ip_mc_sf_allow(sk, loc_addr, rmt_addr, dif))
+ 		return false;
+ 	return true;
++>>>>>>> 5cf3d46192fc (udp: Simplify __udp*_lib_mcast_deliver.)
  }
  
  /*
diff --cc net/ipv6/udp.c
index 2c9dae38dffd,7d3bd80085be..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -700,44 -702,26 +700,62 @@@ drop
  	return -1;
  }
  
- static struct sock *udp_v6_mcast_next(struct net *net, struct sock *sk,
- 				      __be16 loc_port, const struct in6_addr *loc_addr,
- 				      __be16 rmt_port, const struct in6_addr *rmt_addr,
- 				      int dif)
+ static bool __udp_v6_is_mcast_sock(struct net *net, struct sock *sk,
+ 				   __be16 loc_port, const struct in6_addr *loc_addr,
+ 				   __be16 rmt_port, const struct in6_addr *rmt_addr,
+ 				   int dif, unsigned short hnum)
  {
++<<<<<<< HEAD
 +	struct hlist_nulls_node *node;
 +	struct sock *s = sk;
 +	unsigned short num = ntohs(loc_port);
 +
 +	sk_nulls_for_each_from(s, node) {
 +		struct inet_sock *inet = inet_sk(s);
 +
 +		if (!net_eq(sock_net(s), net))
 +			continue;
 +
 +		if (udp_sk(s)->udp_port_hash == num &&
 +		    s->sk_family == PF_INET6) {
 +			if (inet->inet_dport) {
 +				if (inet->inet_dport != rmt_port)
 +					continue;
 +			}
 +			if (!ipv6_addr_any(&sk->sk_v6_daddr) &&
 +			    !ipv6_addr_equal(&sk->sk_v6_daddr, rmt_addr))
 +				continue;
 +
 +			if (s->sk_bound_dev_if && s->sk_bound_dev_if != dif)
 +				continue;
 +
 +			if (!ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {
 +				if (!ipv6_addr_equal(&sk->sk_v6_rcv_saddr, loc_addr))
 +					continue;
 +			}
 +			if (!inet6_mc_check(s, loc_addr, rmt_addr))
 +				continue;
 +			return s;
 +		}
 +	}
 +	return NULL;
++=======
+ 	struct inet_sock *inet = inet_sk(sk);
+ 
+ 	if (!net_eq(sock_net(sk), net))
+ 		return false;
+ 
+ 	if (udp_sk(sk)->udp_port_hash != hnum ||
+ 	    sk->sk_family != PF_INET6 ||
+ 	    (inet->inet_dport && inet->inet_dport != rmt_port) ||
+ 	    (!ipv6_addr_any(&sk->sk_v6_daddr) &&
+ 		    !ipv6_addr_equal(&sk->sk_v6_daddr, rmt_addr)) ||
+ 	    (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))
+ 		return false;
+ 	if (!inet6_mc_check(sk, loc_addr, rmt_addr))
+ 		return false;
+ 	return true;
++>>>>>>> 5cf3d46192fc (udp: Simplify __udp*_lib_mcast_deliver.)
  }
  
  static void flush_stack(struct sock **stack, unsigned int count,
* Unmerged path net/ipv4/udp.c
* Unmerged path net/ipv6/udp.c
