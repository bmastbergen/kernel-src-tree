openvswitch: Reject ct_state masks for unknown bits

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Joe Stringer <joestringer@nicira.com>
commit 9e384715e9e702704c6941c575f0e6b322132a3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9e384715.failed

Currently, 0-bits are generated in ct_state where the bit position is
undefined, and matches are accepted on these bit-positions. If userspace
requests to match the 0-value for this bit then it may expect only a
subset of traffic to match this value, whereas currently all packets
will have this bit set to 0. Fix this by rejecting such masks.

	Signed-off-by: Joe Stringer <joestringer@nicira.com>
	Acked-by: Pravin B Shelar <pshelar@nicira.com>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9e384715e9e702704c6941c575f0e6b322132a3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/conntrack.h
#	net/openvswitch/flow_netlink.c
diff --cc net/openvswitch/flow_netlink.c
index 953a2c4bca92,bd710bc37469..000000000000
--- a/net/openvswitch/flow_netlink.c
+++ b/net/openvswitch/flow_netlink.c
@@@ -768,6 -811,43 +768,46 @@@ static int metadata_from_nlattrs(struc
  			return -EINVAL;
  		*attrs &= ~(1 << OVS_KEY_ATTR_TUNNEL);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (*attrs & (1 << OVS_KEY_ATTR_CT_STATE) &&
+ 	    ovs_ct_verify(net, OVS_KEY_ATTR_CT_STATE)) {
+ 		u32 ct_state = nla_get_u32(a[OVS_KEY_ATTR_CT_STATE]);
+ 
+ 		if (ct_state & ~CT_SUPPORTED_MASK) {
+ 			OVS_NLERR(log, "ct_state flags %08x unsupported",
+ 				  ct_state);
+ 			return -EINVAL;
+ 		}
+ 
+ 		SW_FLOW_KEY_PUT(match, ct.state, ct_state, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_STATE);
+ 	}
+ 	if (*attrs & (1 << OVS_KEY_ATTR_CT_ZONE) &&
+ 	    ovs_ct_verify(net, OVS_KEY_ATTR_CT_ZONE)) {
+ 		u16 ct_zone = nla_get_u16(a[OVS_KEY_ATTR_CT_ZONE]);
+ 
+ 		SW_FLOW_KEY_PUT(match, ct.zone, ct_zone, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_ZONE);
+ 	}
+ 	if (*attrs & (1 << OVS_KEY_ATTR_CT_MARK) &&
+ 	    ovs_ct_verify(net, OVS_KEY_ATTR_CT_MARK)) {
+ 		u32 mark = nla_get_u32(a[OVS_KEY_ATTR_CT_MARK]);
+ 
+ 		SW_FLOW_KEY_PUT(match, ct.mark, mark, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_MARK);
+ 	}
+ 	if (*attrs & (1 << OVS_KEY_ATTR_CT_LABELS) &&
+ 	    ovs_ct_verify(net, OVS_KEY_ATTR_CT_LABELS)) {
+ 		const struct ovs_key_ct_labels *cl;
+ 
+ 		cl = nla_data(a[OVS_KEY_ATTR_CT_LABELS]);
+ 		SW_FLOW_KEY_MEMCPY(match, ct.labels, cl->ct_labels,
+ 				   sizeof(*cl), is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_LABELS);
+ 	}
++>>>>>>> 9e384715e9e7 (openvswitch: Reject ct_state masks for unknown bits)
  	return 0;
  }
  
@@@ -1012,10 -1092,16 +1052,17 @@@ static void nlattr_set(struct nlattr *a
  
  	/* The nlattr stream should already have been validated */
  	nla_for_each_nested(nla, attr, rem) {
 -		if (tbl[nla_type(nla)].len == OVS_ATTR_NESTED) {
 -			if (tbl[nla_type(nla)].next)
 -				tbl = tbl[nla_type(nla)].next;
 -			nlattr_set(nla, val, tbl);
 -		} else {
 +		if (tbl && tbl[nla_type(nla)].len == OVS_ATTR_NESTED)
 +			nlattr_set(nla, val, tbl[nla_type(nla)].next);
 +		else
  			memset(nla_data(nla), val, nla_len(nla));
++<<<<<<< HEAD
++=======
+ 		}
+ 
+ 		if (nla_type(nla) == OVS_KEY_ATTR_CT_STATE)
+ 			*(u32 *)nla_data(nla) &= CT_SUPPORTED_MASK;
++>>>>>>> 9e384715e9e7 (openvswitch: Reject ct_state masks for unknown bits)
  	}
  }
  
* Unmerged path net/openvswitch/conntrack.h
* Unmerged path net/openvswitch/conntrack.h
* Unmerged path net/openvswitch/flow_netlink.c
