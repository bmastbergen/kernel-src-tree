mei: bus: kill mei_cl_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit d4b78c7290dd0aa41596ad527877a6d70bf64110
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d4b78c72.failed

since we move all nfc hanling to the mei_phy module
we can kill mei_cl_ops

	Cc: Samuel Ortiz <sameo@linux.intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit d4b78c7290dd0aa41596ad527877a6d70bf64110)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,609a2d2c2dba..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -289,35 -328,15 +289,14 @@@ struct mei_hw_ops 
  
  /* MEI bus API*/
  
- /**
-  * struct mei_cl_ops - MEI CL device ops
-  * This structure allows ME host clients to implement technology
-  * specific operations.
-  *
-  * @enable: Enable an MEI CL device. Some devices require specific
-  *	HECI commands to initialize completely.
-  * @disable: Disable an MEI CL device.
-  * @send: Tx hook for the device. This allows ME host clients to trap
-  *	the device driver buffers before actually physically
-  *	pushing it to the ME.
-  * @recv: Rx hook for the device. This allows ME host clients to trap the
-  *	ME buffers before forwarding them to the device driver.
-  */
- struct mei_cl_ops {
- 	int (*enable)(struct mei_cl_device *device);
- 	int (*disable)(struct mei_cl_device *device);
- 	int (*send)(struct mei_cl_device *device, u8 *buf, size_t length);
- 	int (*recv)(struct mei_cl_device *device, u8 *buf, size_t length);
- };
- 
  struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 -					struct mei_me_client *me_cl,
 -					struct mei_cl *cl,
 -					char *name);
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops);
  void mei_cl_remove_device(struct mei_cl_device *device);
  
 -ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 -			bool blocking);
 -ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_async_send(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
  void mei_cl_bus_rx_event(struct mei_cl *cl);
  void mei_cl_bus_remove_devices(struct mei_device *dev);
  int mei_cl_bus_init(void);
@@@ -332,21 -352,23 +311,24 @@@ void mei_cl_bus_exit(void)
   * when being probed and shall use it for doing ME bus I/O.
   *
   * @dev: linux driver model device pointer
 - * @me_cl: me client
 + * @uuid: me client uuid
   * @cl: mei client
++<<<<<<< HEAD
 + * @ops: ME transport ops
++=======
+  * @name: device name
+  * @event_work: async work to execute event callback
++>>>>>>> d4b78c7290dd (mei: bus: kill mei_cl_ops)
   * @event_cb: Drivers register this callback to get asynchronous ME
   *	events (e.g. Rx buffer pending) notifications.
 - * @event_context: event callback run context
   * @events: Events bitmask sent to the driver.
   * @priv_data: client private data
   */
  struct mei_cl_device {
  	struct device dev;
  
 -	struct mei_me_client *me_cl;
  	struct mei_cl *cl;
 -	char name[MEI_CL_NAME_SIZE];
  
- 	const struct mei_cl_ops *ops;
- 
  	struct work_struct event_work;
  	mei_cl_event_cb_t event_cb;
  	void *event_context;
* Unmerged path drivers/misc/mei/mei_dev.h
