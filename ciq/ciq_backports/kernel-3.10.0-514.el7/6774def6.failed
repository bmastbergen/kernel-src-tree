treewide: fix typo in printk and Kconfig

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Masanari Iida <standby24x7@gmail.com>
commit 6774def6422f6eac53f1828c317bf3b08a8f5a60
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6774def6.failed

This patch fix spelling typo in printk and Kconfig within
various part of kernel sources.

	Signed-off-by: Masanari Iida <standby24x7@gmail.com>
	Acked-by: Randy Dunlap <rdunlap@infradead.org>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 6774def6422f6eac53f1828c317bf3b08a8f5a60)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/e500_mmu_host.c
#	tools/usb/ffs-aio-example/multibuff/device_app/aio_multibuff.c
diff --cc arch/powerpc/kvm/e500_mmu_host.c
index 82aafd61162a,cc536d4a75ef..000000000000
--- a/arch/powerpc/kvm/e500_mmu_host.c
+++ b/arch/powerpc/kvm/e500_mmu_host.c
@@@ -577,6 -609,97 +577,100 @@@ void kvmppc_mmu_map(struct kvm_vcpu *vc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_KVM_BOOKE_HV
+ int kvmppc_load_last_inst(struct kvm_vcpu *vcpu, enum instruction_type type,
+ 			  u32 *instr)
+ {
+ 	gva_t geaddr;
+ 	hpa_t addr;
+ 	hfn_t pfn;
+ 	hva_t eaddr;
+ 	u32 mas1, mas2, mas3;
+ 	u64 mas7_mas3;
+ 	struct page *page;
+ 	unsigned int addr_space, psize_shift;
+ 	bool pr;
+ 	unsigned long flags;
+ 
+ 	/* Search TLB for guest pc to get the real address */
+ 	geaddr = kvmppc_get_pc(vcpu);
+ 
+ 	addr_space = (vcpu->arch.shared->msr & MSR_IS) >> MSR_IR_LG;
+ 
+ 	local_irq_save(flags);
+ 	mtspr(SPRN_MAS6, (vcpu->arch.pid << MAS6_SPID_SHIFT) | addr_space);
+ 	mtspr(SPRN_MAS5, MAS5_SGS | get_lpid(vcpu));
+ 	asm volatile("tlbsx 0, %[geaddr]\n" : :
+ 		     [geaddr] "r" (geaddr));
+ 	mtspr(SPRN_MAS5, 0);
+ 	mtspr(SPRN_MAS8, 0);
+ 	mas1 = mfspr(SPRN_MAS1);
+ 	mas2 = mfspr(SPRN_MAS2);
+ 	mas3 = mfspr(SPRN_MAS3);
+ #ifdef CONFIG_64BIT
+ 	mas7_mas3 = mfspr(SPRN_MAS7_MAS3);
+ #else
+ 	mas7_mas3 = ((u64)mfspr(SPRN_MAS7) << 32) | mas3;
+ #endif
+ 	local_irq_restore(flags);
+ 
+ 	/*
+ 	 * If the TLB entry for guest pc was evicted, return to the guest.
+ 	 * There are high chances to find a valid TLB entry next time.
+ 	 */
+ 	if (!(mas1 & MAS1_VALID))
+ 		return EMULATE_AGAIN;
+ 
+ 	/*
+ 	 * Another thread may rewrite the TLB entry in parallel, don't
+ 	 * execute from the address if the execute permission is not set
+ 	 */
+ 	pr = vcpu->arch.shared->msr & MSR_PR;
+ 	if (unlikely((pr && !(mas3 & MAS3_UX)) ||
+ 		     (!pr && !(mas3 & MAS3_SX)))) {
+ 		pr_err_ratelimited(
+ 			"%s: Instruction emulation from guest address %08lx without execute permission\n",
+ 			__func__, geaddr);
+ 		return EMULATE_AGAIN;
+ 	}
+ 
+ 	/*
+ 	 * The real address will be mapped by a cacheable, memory coherent,
+ 	 * write-back page. Check for mismatches when LRAT is used.
+ 	 */
+ 	if (has_feature(vcpu, VCPU_FTR_MMU_V2) &&
+ 	    unlikely((mas2 & MAS2_I) || (mas2 & MAS2_W) || !(mas2 & MAS2_M))) {
+ 		pr_err_ratelimited(
+ 			"%s: Instruction emulation from guest address %08lx mismatches storage attributes\n",
+ 			__func__, geaddr);
+ 		return EMULATE_AGAIN;
+ 	}
+ 
+ 	/* Get pfn */
+ 	psize_shift = MAS1_GET_TSIZE(mas1) + 10;
+ 	addr = (mas7_mas3 & (~0ULL << psize_shift)) |
+ 	       (geaddr & ((1ULL << psize_shift) - 1ULL));
+ 	pfn = addr >> PAGE_SHIFT;
+ 
+ 	/* Guard against emulation from devices area */
+ 	if (unlikely(!page_is_ram(pfn))) {
+ 		pr_err_ratelimited("%s: Instruction emulation from non-RAM host address %08llx is not supported\n",
+ 			 __func__, addr);
+ 		return EMULATE_AGAIN;
+ 	}
+ 
+ 	/* Map a page and get guest's instruction */
+ 	page = pfn_to_page(pfn);
+ 	eaddr = (unsigned long)kmap_atomic(page);
+ 	*instr = *(u32 *)(eaddr | (unsigned long)(addr & ~PAGE_MASK));
+ 	kunmap_atomic((u32 *)eaddr);
+ 
+ 	return EMULATE_DONE;
+ }
+ #else
++>>>>>>> 6774def6422f (treewide: fix typo in printk and Kconfig)
  int kvmppc_load_last_inst(struct kvm_vcpu *vcpu, enum instruction_type type,
  			  u32 *instr)
  {
* Unmerged path tools/usb/ffs-aio-example/multibuff/device_app/aio_multibuff.c
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 2a75ff249e71..f7c834fa71a4 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -1147,7 +1147,7 @@ static int __init edac_devinit(void)
 		name = edac_device_names[i];
 		dev = platform_device_register_simple(name, -1, NULL, 0);
 		if (IS_ERR(dev)) {
-			pr_err("Registation of %s failed!\n", name);
+			pr_err("Registration of %s failed!\n", name);
 			err = PTR_ERR(dev);
 		}
 	}
@@ -1158,7 +1158,7 @@ static int __init edac_devinit(void)
 		dev = platform_device_register_simple("octeon_lmc_edac",
 						      i, NULL, 0);
 		if (IS_ERR(dev)) {
-			pr_err("Registation of octeon_lmc_edac %d failed!\n", i);
+			pr_err("Registration of octeon_lmc_edac %d failed!\n", i);
 			err = PTR_ERR(dev);
 		}
 	}
diff --git a/arch/mips/pci/pci-octeon.c b/arch/mips/pci/pci-octeon.c
index 95c2ea815cac..deeeaee19fb2 100644
--- a/arch/mips/pci/pci-octeon.c
+++ b/arch/mips/pci/pci-octeon.c
@@ -707,7 +707,7 @@ static int __init octeon_pci_setup(void)
 
 	if (IS_ERR(platform_device_register_simple("octeon_pci_edac",
 						   -1, NULL, 0)))
-		pr_err("Registation of co_pci_edac failed!\n");
+		pr_err("Registration of co_pci_edac failed!\n");
 
 	octeon_pci_dma_init();
 
* Unmerged path arch/powerpc/kvm/e500_mmu_host.c
diff --git a/drivers/isdn/mISDN/l1oip_core.c b/drivers/isdn/mISDN/l1oip_core.c
index 2c0d2c2bf946..1492422543ec 100644
--- a/drivers/isdn/mISDN/l1oip_core.c
+++ b/drivers/isdn/mISDN/l1oip_core.c
@@ -1338,7 +1338,7 @@ init_card(struct l1oip *hc, int pri, int bundle)
 	if (id[l1oip_cnt] == 0) {
 		printk(KERN_WARNING "Warning: No 'id' value given or "
 		       "0, this is highly unsecure. Please use 32 "
-		       "bit randmom number 0x...\n");
+		       "bit random number 0x...\n");
 	}
 	hc->id = id[l1oip_cnt];
 	if (debug & DEBUG_L1OIP_INIT)
diff --git a/drivers/media/pci/ttpci/budget-patch.c b/drivers/media/pci/ttpci/budget-patch.c
index 2cb35c23d2ac..a4d8867e1d7b 100644
--- a/drivers/media/pci/ttpci/budget-patch.c
+++ b/drivers/media/pci/ttpci/budget-patch.c
@@ -490,7 +490,7 @@ static int budget_patch_attach (struct saa7146_dev* dev, struct saa7146_pci_exte
 
 	if(detected == 0)
 		printk("budget-patch not detected or saa7146 in non-default state.\n"
-		       "try enabling ressetting of 7146 with MASK_31 in MC1 register\n");
+		       "try enabling resetting of 7146 with MASK_31 in MC1 register\n");
 
 	else
 		printk("BUDGET-PATCH DETECTED.\n");
diff --git a/drivers/s390/char/tape_3590.c b/drivers/s390/char/tape_3590.c
index 327cb19ad0b0..d3d1936057b4 100644
--- a/drivers/s390/char/tape_3590.c
+++ b/drivers/s390/char/tape_3590.c
@@ -1090,7 +1090,7 @@ tape_3590_print_io_sim_msg_f1(struct tape_device *device, struct irb *irb)
 				"channel path 0x%x on CU",
 				sense->fmt.f71.md[1]);
 		else
-			snprintf(service, BUFSIZE, "Repair will disable cannel"
+			snprintf(service, BUFSIZE, "Repair will disable channel"
 				" paths (0x%x-0x%x) on CU",
 				sense->fmt.f71.md[1], sense->fmt.f71.md[2]);
 		break;
@@ -1481,7 +1481,7 @@ tape_3590_irq(struct tape_device *device, struct tape_request *request,
 	}
 
 	if (irb->scsw.cmd.dstat & DEV_STAT_CHN_END) {
-		DBF_EVENT(2, "cannel end\n");
+		DBF_EVENT(2, "channel end\n");
 		return TAPE_IO_PENDING;
 	}
 
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 7e7006fd404e..ff8c385f38c3 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -664,7 +664,7 @@ config PDC_CONSOLE
 	  Saying Y here will enable the software based PDC console to be 
 	  used as the system console.  This is useful for machines in 
 	  which the hardware based console has not been written yet.  The
-	  following steps must be competed to use the PDC console:
+	  following steps must be completed to use the PDC console:
 
 	    1. create the device entry (mknod /dev/ttyB0 c 11 0)
 	    2. Edit the /etc/inittab to start a getty listening on /dev/ttyB0
diff --git a/drivers/usb/gadget/f_hid.c b/drivers/usb/gadget/f_hid.c
index 6e69a8e8d22a..82fc42c795b1 100644
--- a/drivers/usb/gadget/f_hid.c
+++ b/drivers/usb/gadget/f_hid.c
@@ -404,7 +404,7 @@ static int hidg_setup(struct usb_function *f,
 
 	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
 		  | HID_REQ_SET_REPORT):
-		VDBG(cdev, "set_report | wLenght=%d\n", ctrl->wLength);
+		VDBG(cdev, "set_report | wLength=%d\n", ctrl->wLength);
 		goto stall;
 		break;
 
diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c
index f6459dfb6f54..5e44407aa099 100644
--- a/drivers/usb/host/ehci-sysfs.c
+++ b/drivers/usb/host/ehci-sysfs.c
@@ -132,7 +132,7 @@ static ssize_t store_uframe_periodic_max(struct device *dev,
 
 		if (allocated_max > uframe_periodic_max) {
 			ehci_info(ehci,
-				"cannot decrease uframe_periodic_max becase "
+				"cannot decrease uframe_periodic_max because "
 				"periodic bandwidth is already allocated "
 				"(%u > %u)\n",
 				allocated_max, uframe_periodic_max);
diff --git a/drivers/usb/host/fotg210-hcd.c b/drivers/usb/host/fotg210-hcd.c
index fce13bcc4a3e..50842433bb22 100644
--- a/drivers/usb/host/fotg210-hcd.c
+++ b/drivers/usb/host/fotg210-hcd.c
@@ -5019,7 +5019,7 @@ static ssize_t store_uframe_periodic_max(struct device *dev,
 
 		if (allocated_max > uframe_periodic_max) {
 			fotg210_info(fotg210,
-				"cannot decrease uframe_periodic_max becase "
+				"cannot decrease uframe_periodic_max because "
 				"periodic bandwidth is already allocated "
 				"(%u > %u)\n",
 				allocated_max, uframe_periodic_max);
diff --git a/drivers/usb/host/fusbh200-hcd.c b/drivers/usb/host/fusbh200-hcd.c
index 79ce799406c9..eaa2412db82d 100644
--- a/drivers/usb/host/fusbh200-hcd.c
+++ b/drivers/usb/host/fusbh200-hcd.c
@@ -4959,7 +4959,7 @@ static ssize_t store_uframe_periodic_max(struct device *dev,
 
 		if (allocated_max > uframe_periodic_max) {
 			fusbh200_info(fusbh200,
-				"cannot decrease uframe_periodic_max becase "
+				"cannot decrease uframe_periodic_max because "
 				"periodic bandwidth is already allocated "
 				"(%u > %u)\n",
 				allocated_max, uframe_periodic_max);
diff --git a/fs/reiserfs/journal.c b/fs/reiserfs/journal.c
index 742fdd4c209a..414c55673d50 100644
--- a/fs/reiserfs/journal.c
+++ b/fs/reiserfs/journal.c
@@ -2712,7 +2712,7 @@ int journal_init(struct super_block *sb, const char *j_dev_name,
 
 	if (journal_init_dev(sb, journal, j_dev_name) != 0) {
 		reiserfs_warning(sb, "sh-462",
-				 "unable to initialize jornal device");
+				 "unable to initialize journal device");
 		goto free_and_return;
 	}
 
* Unmerged path tools/usb/ffs-aio-example/multibuff/device_app/aio_multibuff.c
