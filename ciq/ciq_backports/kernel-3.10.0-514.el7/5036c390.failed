raid5: allow r5l_io_unit allocations to fail

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 5036c3902054358ee293b8cecfea13342d8019e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5036c390.failed

And propagate the error up the stack so we can add the stripe
to no_stripes_list and retry our log operation later.  This avoids
blocking raid5d due to reclaim, an it allows to get rid of the
deadlock-prone GFP_NOFAIL allocation.

shli: add missing mempool_destroy()

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: NeilBrown <neilb@suse.com>
(cherry picked from commit 5036c3902054358ee293b8cecfea13342d8019e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5-cache.c
diff --cc drivers/md/raid5-cache.c
index 32663089824b,6d2b4789a928..000000000000
--- a/drivers/md/raid5-cache.c
+++ b/drivers/md/raid5-cache.c
@@@ -75,8 -75,12 +75,11 @@@ struct r5l_log 
  	struct list_head finished_ios;	/* io_units which settle down in log disk */
  	struct bio flush_bio;
  
+ 	struct list_head no_mem_stripes;   /* pending stripes, -ENOMEM */
+ 
  	struct kmem_cache *io_kc;
+ 	mempool_t *io_pool;
  	struct bio_set *bs;
 -	mempool_t *meta_pool;
  
  	struct md_thread *reclaim_thread;
  	unsigned long reclaim_target;	/* number of space that need to be
@@@ -301,10 -290,12 +304,13 @@@ static struct r5l_io_unit *r5l_new_meta
  	struct r5l_io_unit *io;
  	struct r5l_meta_block *block;
  
- 	/* We can't handle memory allocate failure so far */
- 	io = kmem_cache_zalloc(log->io_kc, GFP_NOIO | __GFP_NOFAIL);
+ 	io = mempool_alloc(log->io_pool, GFP_ATOMIC);
+ 	if (!io)
+ 		return NULL;
+ 	memset(io, 0, sizeof(*io));
+ 
  	io->log = log;
 +	bio_list_init(&io->bios);
  	INIT_LIST_HEAD(&io->log_sibling);
  	INIT_LIST_HEAD(&io->stripe_list);
  	io->state = IO_UNIT_RUNNING;
@@@ -565,7 -593,8 +602,12 @@@ static bool r5l_complete_finished_ios(s
  		log->next_cp_seq = io->seq;
  
  		list_del(&io->log_sibling);
++<<<<<<< HEAD
 +		r5l_free_io_unit(log, io);
++=======
+ 		mempool_free(io, log->io_pool);
+ 		r5l_run_no_mem_stripe(log);
++>>>>>>> 5036c3902054 (raid5: allow r5l_io_unit allocations to fail)
  
  		found = true;
  	}
@@@ -1192,8 -1239,13 +1240,10 @@@ int r5l_init_log(struct r5conf *conf, s
  error:
  	md_unregister_thread(&log->reclaim_thread);
  reclaim_thread:
 -	mempool_destroy(log->meta_pool);
 -out_mempool:
  	bioset_free(log->bs);
  io_bs:
+ 	mempool_destroy(log->io_pool);
+ io_pool:
  	kmem_cache_destroy(log->io_kc);
  io_kc:
  	kfree(log);
@@@ -1203,7 -1255,9 +1253,8 @@@
  void r5l_exit_log(struct r5l_log *log)
  {
  	md_unregister_thread(&log->reclaim_thread);
 -	mempool_destroy(log->meta_pool);
  	bioset_free(log->bs);
+ 	mempool_destroy(log->io_pool);
  	kmem_cache_destroy(log->io_kc);
  	kfree(log);
  }
* Unmerged path drivers/md/raid5-cache.c
