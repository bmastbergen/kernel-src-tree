route: Extend flow representation with tunnel key

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Thomas Graf <tgraf@suug.ch>
commit 1b7179d3adff0ab71f85ee24d7de28ccb7734b89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1b7179d3.failed

Add a new flowi_tunnel structure which is a subset of ip_tunnel_key to
allow routes to match on tunnel metadata. For now, the tunnel id is
added to flowi_tunnel which allows for routes to be bound to specific
virtual tunnels.

	Signed-off-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1b7179d3adff0ab71f85ee24d7de28ccb7734b89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/flow.h
#	net/ipv4/fib_frontend.c
#	net/ipv4/route.c
diff --cc include/net/flow.h
index 37ddd080c536,3098ae33a178..000000000000
--- a/include/net/flow.h
+++ b/include/net/flow.h
@@@ -11,6 -11,18 +11,21 @@@
  #include <linux/in6.h>
  #include <linux/atomic.h>
  
++<<<<<<< HEAD
++=======
+ /*
+  * ifindex generation is per-net namespace, and loopback is
+  * always the 1st device in ns (see net_dev_init), thus any
+  * loopback device should get ifindex 1
+  */
+ 
+ #define LOOPBACK_IFINDEX	1
+ 
+ struct flowi_tunnel {
+ 	__be64			tun_id;
+ };
+ 
++>>>>>>> 1b7179d3adff (route: Extend flow representation with tunnel key)
  struct flowi_common {
  	int	flowic_oif;
  	int	flowic_iif;
@@@ -20,9 -32,9 +35,10 @@@
  	__u8	flowic_proto;
  	__u8	flowic_flags;
  #define FLOWI_FLAG_ANYSRC		0x01
 -#define FLOWI_FLAG_KNOWN_NH		0x02
 +/* This has changed to 0x02 upstream. Preserved here to remain ABI compatible. */
 +#define FLOWI_FLAG_KNOWN_NH		0x04
  	__u32	flowic_secid;
+ 	struct flowi_tunnel flowic_tun_key;
  };
  
  union flowi_uli {
diff --cc net/ipv4/fib_frontend.c
index 59c306b4d24b,6b98de0d7949..000000000000
--- a/net/ipv4/fib_frontend.c
+++ b/net/ipv4/fib_frontend.c
@@@ -219,7 -280,8 +219,12 @@@ __be32 fib_compute_spec_dst(struct sk_b
  		fl4.flowi4_tos = RT_TOS(ip_hdr(skb)->tos);
  		fl4.flowi4_scope = scope;
  		fl4.flowi4_mark = IN_DEV_SRC_VMARK(in_dev) ? skb->mark : 0;
++<<<<<<< HEAD
 +		if (!fib_lookup(net, &fl4, &res))
++=======
+ 		fl4.flowi4_tun_key.tun_id = 0;
+ 		if (!fib_lookup(net, &fl4, &res, 0))
++>>>>>>> 1b7179d3adff (route: Extend flow representation with tunnel key)
  			return FIB_RES_PREFSRC(net, res);
  	} else {
  		scope = RT_SCOPE_LINK;
diff --cc net/ipv4/route.c
index bb601e82773a,91da18be0a71..000000000000
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@@ -89,7 -89,9 +89,8 @@@
  #include <linux/rcupdate.h>
  #include <linux/times.h>
  #include <linux/slab.h>
 -#include <linux/jhash.h>
  #include <net/dst.h>
+ #include <net/dst_metadata.h>
  #include <net/net_namespace.h>
  #include <net/protocol.h>
  #include <net/ip.h>
@@@ -1657,6 -1693,13 +1660,16 @@@ static int ip_route_input_slow(struct s
  	   by fib_lookup.
  	 */
  
++<<<<<<< HEAD
++=======
+ 	tun_info = skb_tunnel_info(skb);
+ 	if (tun_info && tun_info->mode == IP_TUNNEL_INFO_RX)
+ 		fl4.flowi4_tun_key.tun_id = tun_info->key.tun_id;
+ 	else
+ 		fl4.flowi4_tun_key.tun_id = 0;
+ 	skb_dst_drop(skb);
+ 
++>>>>>>> 1b7179d3adff (route: Extend flow representation with tunnel key)
  	if (ipv4_is_multicast(saddr) || ipv4_is_lbcast(saddr))
  		goto martian_source;
  
* Unmerged path include/net/flow.h
* Unmerged path net/ipv4/fib_frontend.c
* Unmerged path net/ipv4/route.c
