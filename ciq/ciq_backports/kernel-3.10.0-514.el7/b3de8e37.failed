mei: bus: call device disable handler prior to disconnection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit b3de8e3719e582f3182bb504295e4a8e43c8c96f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b3de8e37.failed

call device's disable handler prior to disconnection
so it can possibly close the communication with fw client
in graceful way

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit b3de8e3719e582f3182bb504295e4a8e43c8c96f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/bus.c
diff --cc drivers/misc/mei/bus.c
index ca8736c3675b,45896f95fed1..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -461,51 -475,26 +466,58 @@@ int mei_cl_disable_device(struct mei_cl
  	mutex_lock(&dev->device_lock);
  
  	if (cl->state != MEI_FILE_CONNECTED) {
++<<<<<<< HEAD
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev, "Already disconnected");
 +
 +		return 0;
++=======
+ 		dev_err(dev->dev, "Already disconnected");
+ 		err = 0;
+ 		goto out;
++>>>>>>> b3de8e3719e5 (mei: bus: call device disable handler prior to disconnection)
  	}
  
  	cl->state = MEI_FILE_DISCONNECTING;
  
  	err = mei_cl_disconnect(cl);
  	if (err < 0) {
++<<<<<<< HEAD
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev,
 +			"Could not disconnect from the ME client");
 +
 +		return err;
++=======
+ 		dev_err(dev->dev, "Could not disconnect from the ME client");
+ 		goto out;
++>>>>>>> b3de8e3719e5 (mei: bus: call device disable handler prior to disconnection)
  	}
  
  	/* Flush queues and remove any pending read */
 -	mei_cl_flush_queues(cl, NULL);
 +	mei_cl_flush_queues(cl);
 +
 +	if (cl->read_cb) {
 +		struct mei_cl_cb *cb = NULL;
 +
 +		cb = mei_cl_find_read_cb(cl);
 +		/* Remove entry from read list */
 +		if (cb)
 +			list_del(&cb->list);
 +
 +		cb = cl->read_cb;
 +		cl->read_cb = NULL;
 +
 +		if (cb) {
 +			mei_io_cb_free(cb);
 +			cb = NULL;
 +		}
 +	}
  
- 	device->event_cb = NULL;
- 
+ out:
  	mutex_unlock(&dev->device_lock);
+ 	return err;
  
- 	if (!device->ops || !device->ops->disable)
- 		return 0;
- 
- 	return device->ops->disable(device);
  }
  EXPORT_SYMBOL_GPL(mei_cl_disable_device);
  
* Unmerged path drivers/misc/mei/bus.c
