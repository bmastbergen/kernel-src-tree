udp: Remove udp_offloads

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tom Herbert <tom@herbertland.com>
commit 46aa2f30aa7fe03a4dcd732b009284c02ff4f093
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/46aa2f30.failed

Now that the UDP encapsulation GRO functions have been moved to the UDP
socket we not longer need the udp_offload insfrastructure so removing it.

	Signed-off-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 46aa2f30aa7fe03a4dcd732b009284c02ff4f093)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/ipv4/udp_offload.c
diff --cc include/linux/netdevice.h
index 95e53059b81a,cb4e508b3f38..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1871,24 -2159,7 +1871,28 @@@ struct packet_offload 
  	struct list_head	 list;
  };
  
++<<<<<<< HEAD
 +struct udp_offload;
 +
 +struct udp_offload_callbacks {
 +	struct sk_buff		**(*gro_receive)(struct sk_buff **head,
 +						 struct sk_buff *skb,
 +						 struct udp_offload *uoff);
 +	int			(*gro_complete)(struct sk_buff *skb,
 +						int nhoff,
 +						struct udp_offload *uoff);
 +};
 +
 +struct udp_offload {
 +	__be16			 port;
 +	u8			 ipproto;
 +	struct udp_offload_callbacks callbacks;
 +};
 +
 +/* often modified stats are per cpu, other are shared (netdev->stats) */
++=======
+ /* often modified stats are per-CPU, other are shared (netdev->stats) */
++>>>>>>> 46aa2f30aa7f (udp: Remove udp_offloads)
  struct pcpu_sw_netstats {
  	u64     rx_packets;
  	u64     rx_bytes;
diff --cc net/ipv4/udp_offload.c
index ecc9ae7d83dd,6230cf4b0d2d..000000000000
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@@ -243,60 -242,9 +231,63 @@@ out
  	return segs;
  }
  
++<<<<<<< HEAD
 +int udp_add_offload(struct net *net, struct udp_offload *uo)
 +{
 +	struct udp_offload_priv *new_offload = kzalloc(sizeof(*new_offload), GFP_ATOMIC);
 +
 +	if (!new_offload)
 +		return -ENOMEM;
 +
 +	write_pnet(&new_offload->net, net);
 +	new_offload->offload = uo;
 +
 +	spin_lock(&udp_offload_lock);
 +	new_offload->next = udp_offload_base;
 +	rcu_assign_pointer(udp_offload_base, new_offload);
 +	spin_unlock(&udp_offload_lock);
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL(udp_add_offload);
 +
 +static void udp_offload_free_routine(struct rcu_head *head)
 +{
 +	struct udp_offload_priv *ou_priv = container_of(head, struct udp_offload_priv, rcu);
 +	kfree(ou_priv);
 +}
 +
 +void udp_del_offload(struct udp_offload *uo)
 +{
 +	struct udp_offload_priv __rcu **head = &udp_offload_base;
 +	struct udp_offload_priv *uo_priv;
 +
 +	spin_lock(&udp_offload_lock);
 +
 +	uo_priv = udp_deref_protected(*head);
 +	for (; uo_priv != NULL;
 +	     uo_priv = udp_deref_protected(*head)) {
 +		if (uo_priv->offload == uo) {
 +			rcu_assign_pointer(*head,
 +					   udp_deref_protected(uo_priv->next));
 +			goto unlock;
 +		}
 +		head = &uo_priv->next;
 +	}
 +	pr_warn("udp_del_offload: didn't find offload for port %d\n", ntohs(uo->port));
 +unlock:
 +	spin_unlock(&udp_offload_lock);
 +	if (uo_priv != NULL)
 +		call_rcu(&uo_priv->rcu, udp_offload_free_routine);
 +}
 +EXPORT_SYMBOL(udp_del_offload);
 +
++=======
++>>>>>>> 46aa2f30aa7f (udp: Remove udp_offloads)
  struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,
 -				 struct udphdr *uh, udp_lookup_t lookup)
 +				 struct udphdr *uh)
  {
 +	struct udp_offload_priv *uo_priv;
  	struct sk_buff *p, **pp = NULL;
  	struct udphdr *uh2;
  	unsigned int off = skb_gro_offset(skb);
@@@ -308,17 -257,14 +299,24 @@@
  	     !NAPI_GRO_CB(skb)->csum_valid))
  		goto out;
  
 -	/* mark that this skb passed once through the tunnel gro layer */
 -	NAPI_GRO_CB(skb)->encap_mark = 1;
 +	/* mark that this skb passed once through the udp gro layer */
 +	NAPI_GRO_CB(skb)->udp_mark = 1;
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	uo_priv = rcu_dereference(udp_offload_base);
 +	for (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {
 +		if (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&
 +		    uo_priv->offload->port == uh->dest &&
 +		    uo_priv->offload->callbacks.gro_receive)
 +			goto unflush;
 +	}
++=======
+ 	sk = (*lookup)(skb, uh->source, uh->dest);
+ 
+ 	if (sk && udp_sk(sk)->gro_receive)
+ 		goto unflush;
++>>>>>>> 46aa2f30aa7f (udp: Remove udp_offloads)
  	goto out_unlock;
  
  unflush:
* Unmerged path include/linux/netdevice.h
diff --git a/include/net/protocol.h b/include/net/protocol.h
index 9f04bbb664ad..426b64ab0ae7 100644
--- a/include/net/protocol.h
+++ b/include/net/protocol.h
@@ -102,9 +102,6 @@ extern int	inet_del_offload(const struct net_offload *prot, unsigned char num);
 extern void	inet_register_protosw(struct inet_protosw *p);
 extern void	inet_unregister_protosw(struct inet_protosw *p);
 
-int  udp_add_offload(struct net *net, struct udp_offload *prot);
-void udp_del_offload(struct udp_offload *prot);
-
 #if IS_ENABLED(CONFIG_IPV6)
 extern int	inet6_add_protocol(const struct inet6_protocol *prot, unsigned char num);
 extern int	inet6_del_protocol(const struct inet6_protocol *prot, unsigned char num);
* Unmerged path net/ipv4/udp_offload.c
