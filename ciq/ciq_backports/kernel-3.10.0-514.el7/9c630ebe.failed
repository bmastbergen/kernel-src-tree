ovl: simplify permission checking

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 9c630ebefeeee4363ffd29f2f9b18eddafc6479c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9c630ebe.failed

The fact that we always do permission checking on the overlay inode and
clear MAY_WRITE for checking access to the lower inode allows cruft to be
removed from ovl_permission().

1) "default_permissions" option effectively did generic_permission() on the
overlay inode with i_mode, i_uid and i_gid updated from underlying
filesystem.  This is what we do by default now.  It did the update using
vfs_getattr() but that's only needed if the underlying filesystem can
change (which is not allowed).  We may later introduce a "paranoia_mode"
that verifies that mode/uid/gid are not changed.

2) splitting out the IS_RDONLY() check from inode_permission() also becomes
unnecessary once we remove the MAY_WRITE from the lower inode check.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 9c630ebefeeee4363ffd29f2f9b18eddafc6479c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/inode.c
diff --cc fs/overlayfs/inode.c
index cec7c3f64b1e,66f42f5cf705..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -73,89 -117,34 +73,109 @@@ static int ovl_getattr(struct vfsmount 
  
  int ovl_permission(struct inode *inode, int mask)
  {
 -	struct ovl_entry *oe = inode->i_private;
 -	bool is_upper;
 -	struct dentry *realdentry = ovl_entry_real(oe, &is_upper);
 +	struct ovl_entry *oe;
 +	struct dentry *alias = NULL;
  	struct inode *realinode;
 -	const struct cred *old_cred;
 +	struct dentry *realdentry;
 +	bool is_upper;
  	int err;
  
++<<<<<<< HEAD
 +	if (S_ISDIR(inode->i_mode)) {
 +		oe = inode->i_private;
 +	} else if (mask & MAY_NOT_BLOCK) {
 +		return -ECHILD;
 +	} else {
 +		/*
 +		 * For non-directories find an alias and get the info
 +		 * from there.
 +		 */
 +		alias = d_find_any_alias(inode);
 +		if (WARN_ON(!alias))
 +			return -ENOENT;
 +
 +		oe = alias->d_fsdata;
 +	}
 +
 +	realdentry = ovl_entry_real(oe, &is_upper);
 +
 +	if (ovl_is_default_permissions(inode)) {
 +		struct kstat stat;
 +		struct path realpath = { .dentry = realdentry };
 +
 +		if (mask & MAY_NOT_BLOCK)
 +			return -ECHILD;
 +
 +		realpath.mnt = ovl_entry_mnt_real(oe, inode, is_upper);
 +
 +		err = vfs_getattr(&realpath, &stat);
 +		if (err)
 +			goto out_dput;
 +
 +		err = -ESTALE;
 +		if ((stat.mode ^ inode->i_mode) & S_IFMT)
 +			goto out_dput;
 +
 +		inode->i_mode = stat.mode;
 +		inode->i_uid = stat.uid;
 +		inode->i_gid = stat.gid;
 +
 +		err = generic_permission(inode, mask);
 +		goto out_dput;
 +	}
 +
++=======
++>>>>>>> 9c630ebefeee (ovl: simplify permission checking)
  	/* Careful in RCU walk mode */
 -	realinode = d_inode_rcu(realdentry);
 +	realinode = ACCESS_ONCE(realdentry->d_inode);
  	if (!realinode) {
  		WARN_ON(!(mask & MAY_NOT_BLOCK));
 -		return -ENOENT;
 +		err = -ENOENT;
 +		goto out_dput;
 +	}
 +
++<<<<<<< HEAD
 +	if (mask & MAY_WRITE) {
 +		umode_t mode = realinode->i_mode;
 +
 +		/*
 +		 * Writes will always be redirected to upper layer, so
 +		 * ignore lower layer being read-only.
 +		 *
 +		 * If the overlay itself is read-only then proceed
 +		 * with the permission check, don't return EROFS.
 +		 * This will only happen if this is the lower layer of
 +		 * another overlayfs.
 +		 *
 +		 * If upper fs becomes read-only after the overlay was
 +		 * constructed return EROFS to prevent modification of
 +		 * upper layer.
 +		 */
 +		err = -EROFS;
 +		if (is_upper && !IS_RDONLY(inode) && IS_RDONLY(realinode) &&
 +		    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
 +			goto out_dput;
  	}
  
 +	err = __inode_permission(realinode, mask);
 +out_dput:
 +	dput(alias);
++=======
+ 	/*
+ 	 * Check overlay inode with the creds of task and underlying inode
+ 	 * with creds of mounter
+ 	 */
+ 	err = generic_permission(inode, mask);
+ 	if (err)
+ 		return err;
+ 
+ 	old_cred = ovl_override_creds(inode->i_sb);
+ 	if (!is_upper)
+ 		mask &= ~(MAY_WRITE | MAY_APPEND);
+ 	err = inode_permission(realinode, mask);
+ 	revert_creds(old_cred);
+ 
++>>>>>>> 9c630ebefeee (ovl: simplify permission checking)
  	return err;
  }
  
* Unmerged path fs/overlayfs/inode.c
diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 26a0f54fc56c..52c72b07a2b4 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -145,7 +145,6 @@ struct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper);
 struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 				    bool is_upper);
 struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
-bool ovl_is_default_permissions(struct inode *inode);
 void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 struct dentry *ovl_workdir(struct dentry *dentry);
 int ovl_want_write(struct dentry *dentry);
diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c
index 5c0fb1f1eab2..9e34c5fffee9 100644
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@ -176,13 +176,6 @@ struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry)
 	return oe->cache;
 }
 
-bool ovl_is_default_permissions(struct inode *inode)
-{
-	struct ovl_fs *ofs = inode->i_sb->s_fs_info;
-
-	return ofs->config.default_permissions;
-}
-
 void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache)
 {
 	struct ovl_entry *oe = dentry->d_fsdata;
