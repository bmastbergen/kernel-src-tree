mei: iamthif: use regular client read functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 331e4187017e5dc12fddfcca3f8041e5610ea23b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/331e4187.failed

Reduce code duplication in amthif by reusing
regular client read functions.

The change also removes the need for amthif
own buffering

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 331e4187017e5dc12fddfcca3f8041e5610ea23b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/amthif.c
#	drivers/misc/mei/interrupt.c
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/amthif.c
index a11128c1997f,4060e2f40286..000000000000
--- a/drivers/misc/mei/amthif.c
+++ b/drivers/misc/mei/amthif.c
@@@ -50,10 -49,7 +50,8 @@@ void mei_amthif_reset_params(struct mei
  {
  	/* reset iamthif parameters. */
  	dev->iamthif_current_cb = NULL;
- 	dev->iamthif_msg_buf_size = 0;
- 	dev->iamthif_msg_buf_index = 0;
  	dev->iamthif_canceled = false;
 +	dev->iamthif_ioctl = false;
  	dev->iamthif_state = MEI_IAMTHIF_IDLE;
  	dev->iamthif_timer = 0;
  	dev->iamthif_stall_timer = 0;
@@@ -69,8 -66,8 +67,13 @@@
  int mei_amthif_host_init(struct mei_device *dev)
  {
  	struct mei_cl *cl = &dev->iamthif_cl;
++<<<<<<< HEAD
 +	unsigned char *msg_buf;
 +	int ret, i;
++=======
+ 	struct mei_me_client *me_cl;
+ 	int ret;
++>>>>>>> 331e4187017e (mei: iamthif: use regular client read functions)
  
  	dev->iamthif_state = MEI_IAMTHIF_IDLE;
  
@@@ -87,27 -84,14 +90,30 @@@
  
  	/* Assign iamthif_mtu to the value received from ME  */
  
 -	dev->iamthif_mtu = me_cl->props.max_msg_length;
 -	dev_dbg(dev->dev, "IAMTHIF_MTU = %d\n", dev->iamthif_mtu);
 +	dev->iamthif_mtu = dev->me_clients[i].props.max_msg_length;
 +	dev_dbg(&dev->pdev->dev, "IAMTHIF_MTU = %d\n",
 +			dev->me_clients[i].props.max_msg_length);
 +
++<<<<<<< HEAD
 +	kfree(dev->iamthif_msg_buf);
 +	dev->iamthif_msg_buf = NULL;
  
 +	/* allocate storage for ME message buffer */
 +	msg_buf = kcalloc(dev->iamthif_mtu,
 +			sizeof(unsigned char), GFP_KERNEL);
 +	if (!msg_buf)
 +		return -ENOMEM;
 +
 +	dev->iamthif_msg_buf = msg_buf;
++=======
++>>>>>>> 331e4187017e (mei: iamthif: use regular client read functions)
  
  	ret = mei_cl_link(cl, MEI_IAMTHIF_HOST_CLIENT_ID);
 +
  	if (ret < 0) {
 -		dev_err(dev->dev, "amthif: failed cl_link %d\n", ret);
 -		goto out;
 +		dev_err(&dev->pdev->dev,
 +			"amthif: failed link client %d\n", ret);
 +		return ret;
  	}
  
  	ret = mei_cl_connect(cl, NULL);
@@@ -257,23 -240,60 +263,64 @@@ out
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mei_amthif_read_start - queue message for sending read credential
+  *
+  * @cl: host client
+  * @file: file pointer of message recipient
+  *
+  * Return: 0 on success, <0 on failure.
+  */
+ static int mei_amthif_read_start(struct mei_cl *cl, struct file *file)
+ {
+ 	struct mei_device *dev = cl->dev;
+ 	struct mei_cl_cb *cb;
+ 	size_t length = dev->iamthif_mtu;
+ 	int rets;
+ 
+ 	cb = mei_io_cb_init(cl, file);
+ 	if (!cb) {
+ 		rets = -ENOMEM;
+ 		goto err;
+ 	}
+ 
+ 	rets = mei_io_cb_alloc_resp_buf(cb, length);
+ 	if (rets)
+ 		goto err;
+ 
+ 	cb->fop_type = MEI_FOP_READ;
+ 	list_add_tail(&cb->list, &dev->ctrl_wr_list.list);
+ 
+ 	dev->iamthif_state = MEI_IAMTHIF_READING;
+ 	dev->iamthif_file_object = cb->file_object;
+ 	dev->iamthif_current_cb = cb;
+ 
+ 	return 0;
+ err:
+ 	mei_io_cb_free(cb);
+ 	return rets;
+ }
+ 
+ /**
++>>>>>>> 331e4187017e (mei: iamthif: use regular client read functions)
   * mei_amthif_send_cmd - send amthif command to the ME
   *
 - * @cl: the host client
 + * @dev: the device structure
   * @cb: mei call back struct
   *
 - * Return: 0 on success, <0 on failure.
 + * returns 0 on success, <0 on failure.
 + *
   */
 -static int mei_amthif_send_cmd(struct mei_cl *cl, struct mei_cl_cb *cb)
 +static int mei_amthif_send_cmd(struct mei_device *dev, struct mei_cl_cb *cb)
  {
 -	struct mei_device *dev;
 +	struct mei_msg_hdr mei_hdr;
  	int ret;
  
 -	if (!cl->dev || !cb)
 +	if (!dev || !cb)
  		return -ENODEV;
  
 -	dev = cl->dev;
 +	dev_dbg(&dev->pdev->dev, "write data to amthif client.\n");
  
  	dev->iamthif_state = MEI_IAMTHIF_WRITING;
  	dev->iamthif_current_cb = cb;
@@@ -327,76 -311,59 +374,107 @@@
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mei_amthif_run_next_cmd - send next amt command from queue
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success, <0 on failure.
+  */
+ int mei_amthif_run_next_cmd(struct mei_device *dev)
+ {
+ 	struct mei_cl *cl = &dev->iamthif_cl;
+ 	struct mei_cl_cb *cb;
+ 
+ 	dev->iamthif_canceled = false;
+ 	dev->iamthif_state = MEI_IAMTHIF_IDLE;
+ 	dev->iamthif_timer = 0;
+ 	dev->iamthif_file_object = NULL;
+ 
+ 	dev_dbg(dev->dev, "complete amthif cmd_list cb.\n");
+ 
+ 	cb = list_first_entry_or_null(&dev->amthif_cmd_list.list,
+ 					typeof(*cb), list);
+ 	if (!cb)
+ 		return 0;
+ 
+ 	list_del_init(&cb->list);
+ 	return mei_amthif_send_cmd(cl, cb);
+ }
+ 
+ /**
++>>>>>>> 331e4187017e (mei: iamthif: use regular client read functions)
   * mei_amthif_write - write amthif data to amthif client
   *
 - * @cl: host client
 + * @dev: the device structure
   * @cb: mei call back struct
   *
 - * Return: 0 on success, <0 on failure.
 + * returns 0 on success, <0 on failure.
 + *
   */
 -int mei_amthif_write(struct mei_cl *cl, struct mei_cl_cb *cb)
 +int mei_amthif_write(struct mei_device *dev, struct mei_cl_cb *cb)
  {
 +	int ret;
  
 -	struct mei_device *dev;
 -
 -	if (WARN_ON(!cl || !cl->dev))
 +	if (!dev || !cb)
  		return -ENODEV;
  
 -	if (WARN_ON(!cb))
 -		return -EINVAL;
 -
 -	dev = cl->dev;
 +	ret = mei_io_cb_alloc_resp_buf(cb, dev->iamthif_mtu);
 +	if (ret)
 +		return ret;
  
  	cb->fop_type = MEI_FOP_WRITE;
 -	list_add_tail(&cb->list, &dev->amthif_cmd_list.list);
 -	return mei_amthif_run_next_cmd(dev);
 +
 +	if (!list_empty(&dev->amthif_cmd_list.list) ||
 +	    dev->iamthif_state != MEI_IAMTHIF_IDLE) {
 +		dev_dbg(&dev->pdev->dev,
 +			"amthif state = %d\n", dev->iamthif_state);
 +		dev_dbg(&dev->pdev->dev, "AMTHIF: add cb to the wait list\n");
 +		list_add_tail(&cb->list, &dev->amthif_cmd_list.list);
 +		return 0;
 +	}
 +	return mei_amthif_send_cmd(dev, cb);
 +}
 +/**
 + * mei_amthif_run_next_cmd
 + *
 + * @dev: the device structure
 + *
 + * returns 0 on success, <0 on failure.
 + */
 +void mei_amthif_run_next_cmd(struct mei_device *dev)
 +{
 +	struct mei_cl_cb *cb;
 +	struct mei_cl_cb *next;
 +	int status;
 +
 +	if (!dev)
 +		return;
 +
 +	dev->iamthif_msg_buf_size = 0;
 +	dev->iamthif_msg_buf_index = 0;
 +	dev->iamthif_canceled = false;
 +	dev->iamthif_ioctl = true;
 +	dev->iamthif_state = MEI_IAMTHIF_IDLE;
 +	dev->iamthif_timer = 0;
 +	dev->iamthif_file_object = NULL;
 +
 +	dev_dbg(&dev->pdev->dev, "complete amthif cmd_list cb.\n");
 +
 +	list_for_each_entry_safe(cb, next, &dev->amthif_cmd_list.list, list) {
 +		list_del(&cb->list);
 +		if (!cb->cl)
 +			continue;
 +		status = mei_amthif_send_cmd(dev, cb);
 +		if (status)
 +			dev_warn(&dev->pdev->dev, "amthif write failed status = %d\n",
 +						status);
 +		break;
 +	}
  }
  
 +
  unsigned int mei_amthif_poll(struct mei_device *dev,
  		struct file *file, poll_table *wait)
  {
@@@ -506,89 -415,38 +584,116 @@@ int mei_amthif_irq_write(struct mei_cl 
  }
  
  /**
 - * mei_amthif_irq_read_msg - read routine after ISR to
 + * mei_amthif_irq_read_message - read routine after ISR to
   *			handle the read amthif message
   *
 - * @cl: mei client
 + * @dev: the device structure
   * @mei_hdr: header of amthif message
++<<<<<<< HEAD
 + * @complete_list: An instance of our list structure
 + *
 + * returns 0 on success, <0 on failure.
++=======
+  * @cmpl_list: completed callbacks list
+  *
+  * Return: -ENODEV if cb is NULL 0 otherwise; error message is in cb->status
++>>>>>>> 331e4187017e (mei: iamthif: use regular client read functions)
   */
 -int mei_amthif_irq_read_msg(struct mei_cl *cl,
 +int mei_amthif_irq_read_msg(struct mei_device *dev,
  			    struct mei_msg_hdr *mei_hdr,
- 			    struct mei_cl_cb *complete_list)
+ 			    struct mei_cl_cb *cmpl_list)
  {
++<<<<<<< HEAD
 +	struct mei_cl_cb *cb;
 +	unsigned char *buffer;
 +
 +	BUG_ON(mei_hdr->me_addr != dev->iamthif_cl.me_client_id);
 +	BUG_ON(dev->iamthif_state != MEI_IAMTHIF_READING);
 +
 +	buffer = dev->iamthif_msg_buf + dev->iamthif_msg_buf_index;
 +	BUG_ON(dev->iamthif_mtu < dev->iamthif_msg_buf_index + mei_hdr->length);
 +
 +	mei_read_slots(dev, buffer, mei_hdr->length);
 +
 +	dev->iamthif_msg_buf_index += mei_hdr->length;
++=======
+ 	struct mei_device *dev;
+ 	int ret;
+ 
+ 	dev = cl->dev;
+ 
+ 	if (dev->iamthif_state != MEI_IAMTHIF_READING)
+ 		return 0;
+ 
+ 	ret = mei_cl_irq_read_msg(cl, mei_hdr, cmpl_list);
+ 	if (ret)
+ 		return ret;
++>>>>>>> 331e4187017e (mei: iamthif: use regular client read functions)
  
  	if (!mei_hdr->msg_complete)
  		return 0;
  
++<<<<<<< HEAD
 +	dev_dbg(&dev->pdev->dev, "amthif_message_buffer_index =%d\n",
 +			mei_hdr->length);
 +
 +	dev_dbg(&dev->pdev->dev, "completed amthif read.\n ");
 +	if (!dev->iamthif_current_cb)
 +		return -ENODEV;
 +
 +	cb = dev->iamthif_current_cb;
 +	dev->iamthif_current_cb = NULL;
 +
 +	if (!cb->cl)
 +		return -ENODEV;
 +
 +	dev->iamthif_stall_timer = 0;
 +	cb->buf_idx = dev->iamthif_msg_buf_index;
 +	cb->read_time = jiffies;
 +	if (dev->iamthif_ioctl) {
 +		/* found the iamthif cb */
 +		dev_dbg(&dev->pdev->dev, "complete the amthif read cb.\n ");
 +		dev_dbg(&dev->pdev->dev, "add the amthif read cb to complete.\n ");
 +		list_add_tail(&cb->list, &complete_list->list);
 +	}
 +	return 0;
 +}
 +
 +/**
 + * mei_amthif_irq_read - prepares to read amthif data.
 + *
 + * @dev: the device structure.
 + * @slots: free slots.
 + *
 + * returns 0, OK; otherwise, error.
 + */
 +int mei_amthif_irq_read(struct mei_device *dev, s32 *slots)
 +{
 +	u32 msg_slots = mei_data2slots(sizeof(struct hbm_flow_control));
 +
 +	if (*slots < msg_slots)
 +		return -EMSGSIZE;
 +
 +	*slots -= msg_slots;
 +
 +	if (mei_hbm_cl_flow_control_req(dev, &dev->iamthif_cl)) {
 +		dev_dbg(&dev->pdev->dev, "iamthif flow control failed\n");
 +		return -EIO;
 +	}
 +
 +	dev_dbg(&dev->pdev->dev, "iamthif flow control success\n");
 +	dev->iamthif_state = MEI_IAMTHIF_READING;
 +	dev->iamthif_flow_control_pending = false;
 +	dev->iamthif_msg_buf_index = 0;
 +	dev->iamthif_msg_buf_size = 0;
 +	dev->iamthif_stall_timer = MEI_IAMTHIF_STALL_TIMER;
 +	dev->hbuf_is_ready = mei_hbuf_is_ready(dev);
++=======
+ 	dev_dbg(dev->dev, "completed amthif read.\n ");
+ 	dev->iamthif_current_cb = NULL;
+ 	dev->iamthif_stall_timer = 0;
+ 
++>>>>>>> 331e4187017e (mei: iamthif: use regular client read functions)
  	return 0;
  }
  
@@@ -603,14 -461,27 +708,17 @@@ void mei_amthif_complete(struct mei_dev
  	if (dev->iamthif_canceled != 1) {
  		dev->iamthif_state = MEI_IAMTHIF_READ_COMPLETE;
  		dev->iamthif_stall_timer = 0;
++<<<<<<< HEAD
 +		memcpy(cb->response_buffer.data,
 +				dev->iamthif_msg_buf,
 +				dev->iamthif_msg_buf_index);
++=======
++>>>>>>> 331e4187017e (mei: iamthif: use regular client read functions)
  		list_add_tail(&cb->list, &dev->amthif_rd_complete_list.list);
 -		dev_dbg(dev->dev, "amthif read completed\n");
 +		dev_dbg(&dev->pdev->dev, "amthif read completed\n");
  		dev->iamthif_timer = jiffies;
 -		dev_dbg(dev->dev, "dev->iamthif_timer = %ld\n",
 -			dev->iamthif_timer);
 +		dev_dbg(&dev->pdev->dev, "dev->iamthif_timer = %ld\n",
 +				dev->iamthif_timer);
  	} else {
  		mei_amthif_run_next_cmd(dev);
  	}
diff --cc drivers/misc/mei/interrupt.c
index b8d9cfee3e87,466c1d22fb16..000000000000
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@@ -87,73 -82,97 +87,119 @@@ static bool mei_cl_is_reading(struct me
  }
  
  /**
++<<<<<<< HEAD
 + * mei_irq_read_client_message - process client message
++=======
+  * mei_irq_discard_msg  - discard received message
+  *
+  * @dev: mei device
+  * @hdr: message header
+  */
+ static inline
+ void mei_irq_discard_msg(struct mei_device *dev, struct mei_msg_hdr *hdr)
+ {
+ 	/*
+ 	 * no need to check for size as it is guarantied
+ 	 * that length fits into rd_msg_buf
+ 	 */
+ 	mei_read_slots(dev, dev->rd_msg_buf, hdr->length);
+ 	dev_dbg(dev->dev, "discarding message " MEI_HDR_FMT "\n",
+ 		MEI_HDR_PRM(hdr));
+ }
+ 
+ /**
+  * mei_cl_irq_read_msg - process client message
++>>>>>>> 331e4187017e (mei: iamthif: use regular client read functions)
   *
 - * @cl: reading client
 + * @dev: the device structure
   * @mei_hdr: header of mei client message
 - * @complete_list: completion list
 + * @complete_list: An instance of our list structure
   *
 - * Return: always 0
 + * returns 0 on success, <0 on failure.
   */
++<<<<<<< HEAD
 +static int mei_cl_irq_read_msg(struct mei_device *dev,
 +			       struct mei_msg_hdr *mei_hdr,
 +			       struct mei_cl_cb *complete_list)
++=======
+ int mei_cl_irq_read_msg(struct mei_cl *cl,
+ 		       struct mei_msg_hdr *mei_hdr,
+ 		       struct mei_cl_cb *complete_list)
++>>>>>>> 331e4187017e (mei: iamthif: use regular client read functions)
  {
 -	struct mei_device *dev = cl->dev;
 -	struct mei_cl_cb *cb;
 +	struct mei_cl *cl;
 +	struct mei_cl_cb *cb, *next;
  	unsigned char *buffer = NULL;
  
 -	list_for_each_entry(cb, &dev->read_list.list, list) {
 -		if (cl == cb->cl)
 -			break;
 -	}
 +	list_for_each_entry_safe(cb, next, &dev->read_list.list, list) {
 +		cl = cb->cl;
 +		if (!cl || !mei_cl_is_reading(cl, mei_hdr))
 +			continue;
  
 -	if (&cb->list == &dev->read_list.list) {
 -		dev_err(dev->dev, "no reader found\n");
 -		goto out;
 -	}
 +		cl->reading_state = MEI_READING;
  
 -	if (!mei_cl_is_reading(cl)) {
 -		cl_err(dev, cl, "cl is not reading state=%d reading state=%d\n",
 -			cl->state, cl->reading_state);
 -		goto out;
 -	}
 +		if (cb->response_buffer.size == 0 ||
 +		    cb->response_buffer.data == NULL) {
 +			cl_err(dev, cl, "response buffer is not allocated.\n");
 +			list_del(&cb->list);
 +			return -ENOMEM;
 +		}
  
 -	cl->reading_state = MEI_READING;
 +		if (cb->response_buffer.size < mei_hdr->length + cb->buf_idx) {
 +			cl_dbg(dev, cl, "message overflow. size %d len %d idx %ld\n",
 +				cb->response_buffer.size,
 +				mei_hdr->length, cb->buf_idx);
 +			buffer = krealloc(cb->response_buffer.data,
 +					  mei_hdr->length + cb->buf_idx,
 +					  GFP_KERNEL);
 +
 +			if (!buffer) {
 +				list_del(&cb->list);
 +				return -ENOMEM;
 +			}
 +			cb->response_buffer.data = buffer;
 +			cb->response_buffer.size =
 +				mei_hdr->length + cb->buf_idx;
 +		}
  
 -	if (cb->response_buffer.size == 0 ||
 -	    cb->response_buffer.data == NULL) {
 -		cl_err(dev, cl, "response buffer is not allocated.\n");
 -		list_move_tail(&cb->list, &complete_list->list);
 -		cb->status = -ENOMEM;
 -		goto out;
 -	}
 +		buffer = cb->response_buffer.data + cb->buf_idx;
 +		mei_read_slots(dev, buffer, mei_hdr->length);
  
 -	if (cb->response_buffer.size < mei_hdr->length + cb->buf_idx) {
 -		cl_dbg(dev, cl, "message overflow. size %d len %d idx %ld\n",
 -			cb->response_buffer.size, mei_hdr->length, cb->buf_idx);
 -		buffer = krealloc(cb->response_buffer.data,
 -				  mei_hdr->length + cb->buf_idx,
 -				  GFP_KERNEL);
 -
 -		if (!buffer) {
 -			cb->status = -ENOMEM;
 -			list_move_tail(&cb->list, &complete_list->list);
 -			goto out;
 +		cb->buf_idx += mei_hdr->length;
 +		if (mei_hdr->msg_complete) {
 +			cl->status = 0;
 +			list_del(&cb->list);
 +			cl_dbg(dev, cl, "completed read length = %lu\n",
 +				cb->buf_idx);
 +			list_add_tail(&cb->list, &complete_list->list);
  		}
 -		cb->response_buffer.data = buffer;
 -		cb->response_buffer.size = mei_hdr->length + cb->buf_idx;
 +		break;
  	}
  
++<<<<<<< HEAD
 +	dev_dbg(&dev->pdev->dev, "message read\n");
 +	if (!buffer) {
 +		mei_read_slots(dev, dev->rd_msg_buf, mei_hdr->length);
 +		dev_dbg(&dev->pdev->dev, "discarding message " MEI_HDR_FMT "\n",
 +				MEI_HDR_PRM(mei_hdr));
 +	}
++=======
+ 	buffer = cb->response_buffer.data + cb->buf_idx;
+ 	mei_read_slots(dev, buffer, mei_hdr->length);
+ 
+ 	cb->buf_idx += mei_hdr->length;
+ 
+ 	if (mei_hdr->msg_complete) {
+ 		cb->read_time = jiffies;
+ 		cl_dbg(dev, cl, "completed read length = %lu\n",
+ 			cb->buf_idx);
+ 		list_move_tail(&cb->list, &complete_list->list);
+ 	}
+ 
+ out:
+ 	if (!buffer)
+ 		mei_irq_discard_msg(dev, mei_hdr);
++>>>>>>> 331e4187017e (mei: iamthif: use regular client read functions)
  
  	return 0;
  }
@@@ -595,12 -582,9 +641,10 @@@ void mei_timer(struct work_struct *work
  
  	if (dev->iamthif_stall_timer) {
  		if (--dev->iamthif_stall_timer == 0) {
 -			dev_err(dev->dev, "timer: amthif  hanged.\n");
 +			dev_err(&dev->pdev->dev, "timer: amthif  hanged.\n");
  			mei_reset(dev);
- 			dev->iamthif_msg_buf_size = 0;
- 			dev->iamthif_msg_buf_index = 0;
  			dev->iamthif_canceled = false;
 +			dev->iamthif_ioctl = true;
  			dev->iamthif_state = MEI_IAMTHIF_IDLE;
  			dev->iamthif_timer = 0;
  
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,57a47d6b63ee..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -382,55 -420,95 +382,128 @@@ enum mei_pg_state 
  
  const char *mei_pg_state_str(enum mei_pg_state state);
  
 +/*
 + * mei_cfg
 + *
 + * @fw_status - FW status
 + * @quirk_probe - device exclusion quirk
 + */
 +struct mei_cfg {
 +	const struct mei_fw_status fw_status;
 +	bool (*quirk_probe)(struct pci_dev *pdev);
 +};
 +
 +
 +#define MEI_PCI_DEVICE(dev, cfg) \
 +	.vendor = PCI_VENDOR_ID_INTEL, .device = (dev), \
 +	.subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID, \
 +	.driver_data = (kernel_ulong_t)&(cfg)
 +
 +
  /**
   * struct mei_device -  MEI private device struct
 +
 + * @reset_count - limits the number of consecutive resets
 + * @hbm_state - state of host bus message protocol
   *
 - * @dev         : device on a bus
 - * @cdev        : character device
 - * @minor       : minor number allocated for device
 + * @hbm_f_pg_supported - hbm feature pgi protocol
   *
++<<<<<<< HEAD
 + * @pg_event - power gating event
 + * @mem_addr - mem mapped base register address
 +
 + * @hbuf_depth - depth of hardware host/write buffer is slots
 + * @hbuf_is_ready - query if the host host/write buffer is ready
 + * @wr_msg - the buffer for hbm control messages
 + * @cfg - per device generation config and ops
++=======
+  * @read_list   : read completion list
+  * @write_list  : write pending list
+  * @write_waiting_list : write completion list
+  * @ctrl_wr_list : pending control write list
+  * @ctrl_rd_list : pending control read list
+  *
+  * @file_list   : list of opened handles
+  * @open_handle_count: number of opened handles
+  *
+  * @device_lock : big device lock
+  * @timer_work  : MEI timer delayed work (timeouts)
+  *
+  * @recvd_hw_ready : hw ready message received flag
+  *
+  * @wait_hw_ready : wait queue for receive HW ready message form FW
+  * @wait_pg     : wait queue for receive PG message from FW
+  * @wait_hbm_start : wait queue for receive HBM start message from FW
+  * @wait_stop_wd : wait queue for receive WD stop message from FW
+  *
+  * @reset_count : number of consecutive resets
+  * @dev_state   : device state
+  * @hbm_state   : state of host bus message protocol
+  * @init_clients_timer : HBM init handshake timeout
+  *
+  * @pg_event    : power gating event
+  * @pg_domain   : runtime PM domain
+  *
+  * @rd_msg_buf  : control messages buffer
+  * @rd_msg_hdr  : read message header storage
+  *
+  * @hbuf_depth  : depth of hardware host/write buffer is slots
+  * @hbuf_is_ready : query if the host host/write buffer is ready
+  * @wr_msg      : the buffer for hbm control messages
+  *
+  * @version     : HBM protocol version in use
+  * @hbm_f_pg_supported : hbm feature pgi protocol
+  *
+  * @me_clients_rwsem: rw lock over me_clients list
+  * @me_clients  : list of FW clients
+  * @me_clients_map : FW clients bit map
+  * @host_clients_map : host clients id pool
+  * @me_client_index : last FW client index in enumeration
+  *
+  * @wd_cl       : watchdog client
+  * @wd_state    : watchdog client state
+  * @wd_pending  : watchdog command is pending
+  * @wd_timeout  : watchdog expiration timeout
+  * @wd_data     : watchdog message buffer
+  *
+  * @amthif_cmd_list : amthif list for cmd waiting
+  * @amthif_rd_complete_list : amthif list for reading completed cmd data
+  * @iamthif_file_object : file for current amthif operation
+  * @iamthif_cl  : amthif host client
+  * @iamthif_current_cb : amthif current operation callback
+  * @iamthif_open_count : number of opened amthif connections
+  * @iamthif_mtu : amthif client max message length
+  * @iamthif_timer : time stamp of current amthif command completion
+  * @iamthif_stall_timer : timer to detect amthif hang
+  * @iamthif_state : amthif processor state
+  * @iamthif_canceled : current amthif command is canceled
+  *
+  * @init_work   : work item for the device init
+  * @reset_work  : work item for the device reset
+  *
+  * @device_list : mei client bus list
+  *
+  * @dbgfs_dir   : debugfs mei root directory
+  *
+  * @ops:        : hw specific operations
+  * @hw          : hw specific data
++>>>>>>> 331e4187017e (mei: iamthif: use regular client read functions)
   */
  struct mei_device {
 -	struct device *dev;
 -	struct cdev cdev;
 -	int minor;
 -
 -	struct mei_cl_cb read_list;
 -	struct mei_cl_cb write_list;
 -	struct mei_cl_cb write_waiting_list;
 -	struct mei_cl_cb ctrl_wr_list;
 -	struct mei_cl_cb ctrl_rd_list;
 +	struct pci_dev *pdev;	/* pointer to pci device struct */
 +	/*
 +	 * lists of queues
 +	 */
 +	/* array of pointers to aio lists */
 +	struct mei_cl_cb read_list;		/* driver read queue */
 +	struct mei_cl_cb write_list;		/* driver write queue */
 +	struct mei_cl_cb write_waiting_list;	/* write waiting queue */
 +	struct mei_cl_cb ctrl_wr_list;		/* managed write IOCTL list */
 +	struct mei_cl_cb ctrl_rd_list;		/* managed read IOCTL list */
  
 +	/*
 +	 * list of files
 +	 */
  	struct list_head file_list;
  	long open_handle_count;
  
@@@ -503,12 -580,7 +576,9 @@@
  	int iamthif_mtu;
  	unsigned long iamthif_timer;
  	u32 iamthif_stall_timer;
- 	unsigned char *iamthif_msg_buf; /* Note: memory has to be allocated */
- 	u32 iamthif_msg_buf_size;
- 	u32 iamthif_msg_buf_index;
  	enum iamthif_states iamthif_state;
 +	bool iamthif_flow_control_pending;
 +	bool iamthif_ioctl;
  	bool iamthif_canceled;
  
  	struct work_struct init_work;
* Unmerged path drivers/misc/mei/amthif.c
diff --git a/drivers/misc/mei/client.h b/drivers/misc/mei/client.h
index bf2b0b1b493d..588b6f1488f7 100644
--- a/drivers/misc/mei/client.h
+++ b/drivers/misc/mei/client.h
@@ -85,6 +85,8 @@ bool mei_cl_is_other_connecting(struct mei_cl *cl);
 int mei_cl_disconnect(struct mei_cl *cl);
 int mei_cl_connect(struct mei_cl *cl, struct file *file);
 int mei_cl_read_start(struct mei_cl *cl, size_t length);
+int mei_cl_irq_read_msg(struct mei_cl *cl, struct mei_msg_hdr *hdr,
+			struct mei_cl_cb *cmpl_list);
 int mei_cl_write(struct mei_cl *cl, struct mei_cl_cb *cb, bool blocking);
 int mei_cl_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,
 		     struct mei_cl_cb *cmpl_list);
* Unmerged path drivers/misc/mei/interrupt.c
* Unmerged path drivers/misc/mei/mei_dev.h
