geneve: fix populating tclass in geneve_get_v6_dst

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit 95caf6f71a9998b5382e3fb9abbca34c02e8f74f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/95caf6f7.failed

The struct flowi6's flowi6_tos is not used in IPv6 route lookup, the
traffic class information is handled in the flowi6's flowlabel member
instead. For example, for policy routing, fib6_rule_match() uses
ip6_tclass() that is applied on the flowlabel for matching on tclass,
which would currently not work as expected.

Fixes: 3a56f86f1be6 ("geneve: handle ipv6 priority like ipv4 tos")
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 95caf6f71a9998b5382e3fb9abbca34c02e8f74f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
diff --cc drivers/net/geneve.c
index d82906728571,bc168894bda3..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -609,6 -821,68 +609,69 @@@ static struct rtable *geneve_get_rt(str
  	return rt;
  }
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_IPV6)
+ static struct dst_entry *geneve_get_v6_dst(struct sk_buff *skb,
+ 					   struct net_device *dev,
+ 					   struct flowi6 *fl6,
+ 					   struct ip_tunnel_info *info)
+ {
+ 	bool use_cache = ip_tunnel_dst_cache_usable(skb, info);
+ 	struct geneve_dev *geneve = netdev_priv(dev);
+ 	struct geneve_sock *gs6 = geneve->sock6;
+ 	struct dst_entry *dst = NULL;
+ 	struct dst_cache *dst_cache;
+ 	__u8 prio;
+ 
+ 	memset(fl6, 0, sizeof(*fl6));
+ 	fl6->flowi6_mark = skb->mark;
+ 	fl6->flowi6_proto = IPPROTO_UDP;
+ 
+ 	if (info) {
+ 		fl6->daddr = info->key.u.ipv6.dst;
+ 		fl6->saddr = info->key.u.ipv6.src;
+ 		fl6->flowlabel = ip6_make_flowinfo(RT_TOS(info->key.tos),
+ 						   info->key.label);
+ 		dst_cache = &info->dst_cache;
+ 	} else {
+ 		prio = geneve->tos;
+ 		if (prio == 1) {
+ 			const struct iphdr *iip = ip_hdr(skb);
+ 
+ 			prio = ip_tunnel_get_dsfield(iip, skb);
+ 			use_cache = false;
+ 		}
+ 
+ 		fl6->flowlabel = ip6_make_flowinfo(RT_TOS(prio),
+ 						   geneve->label);
+ 		fl6->daddr = geneve->remote.sin6.sin6_addr;
+ 		dst_cache = &geneve->dst_cache;
+ 	}
+ 
+ 	if (use_cache) {
+ 		dst = dst_cache_get_ip6(dst_cache, &fl6->saddr);
+ 		if (dst)
+ 			return dst;
+ 	}
+ 
+ 	if (ipv6_stub->ipv6_dst_lookup(geneve->net, gs6->sock->sk, &dst, fl6)) {
+ 		netdev_dbg(dev, "no route to %pI6\n", &fl6->daddr);
+ 		return ERR_PTR(-ENETUNREACH);
+ 	}
+ 	if (dst->dev == dev) { /* is this necessary? */
+ 		netdev_dbg(dev, "circular route to %pI6\n", &fl6->daddr);
+ 		dst_release(dst);
+ 		return ERR_PTR(-ELOOP);
+ 	}
+ 
+ 	if (use_cache)
+ 		dst_cache_set_ip6(dst_cache, dst, &fl6->saddr);
+ 	return dst;
+ }
+ #endif
+ 
++>>>>>>> 95caf6f71a99 (geneve: fix populating tclass in geneve_get_v6_dst)
  /* Convert 64 bit tunnel ID to 24 bit VNI. */
  static void tunnel_id_to_vni(__be64 tun_id, __u8 *vni)
  {
@@@ -704,6 -986,178 +767,181 @@@ err
  	return NETDEV_TX_OK;
  }
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_IPV6)
+ static netdev_tx_t geneve6_xmit_skb(struct sk_buff *skb, struct net_device *dev,
+ 				    struct ip_tunnel_info *info)
+ {
+ 	struct geneve_dev *geneve = netdev_priv(dev);
+ 	struct geneve_sock *gs6 = geneve->sock6;
+ 	struct dst_entry *dst = NULL;
+ 	const struct iphdr *iip; /* interior IP header */
+ 	int err = -EINVAL;
+ 	struct flowi6 fl6;
+ 	__u8 prio, ttl;
+ 	__be16 sport;
+ 	__be32 label;
+ 	bool xnet = !net_eq(geneve->net, dev_net(geneve->dev));
+ 	u32 flags = geneve->flags;
+ 
+ 	if (geneve->collect_md) {
+ 		if (unlikely(!info || !(info->mode & IP_TUNNEL_INFO_TX))) {
+ 			netdev_dbg(dev, "no tunnel metadata\n");
+ 			goto tx_error;
+ 		}
+ 	}
+ 
+ 	dst = geneve_get_v6_dst(skb, dev, &fl6, info);
+ 	if (IS_ERR(dst)) {
+ 		err = PTR_ERR(dst);
+ 		goto tx_error;
+ 	}
+ 
+ 	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
+ 	skb_reset_mac_header(skb);
+ 
+ 	iip = ip_hdr(skb);
+ 
+ 	if (info) {
+ 		const struct ip_tunnel_key *key = &info->key;
+ 		u8 *opts = NULL;
+ 		u8 vni[3];
+ 
+ 		tunnel_id_to_vni(key->tun_id, vni);
+ 		if (info->options_len)
+ 			opts = ip_tunnel_info_opts(info);
+ 
+ 		if (key->tun_flags & TUNNEL_CSUM)
+ 			flags &= ~GENEVE_F_UDP_ZERO_CSUM6_TX;
+ 		else
+ 			flags |= GENEVE_F_UDP_ZERO_CSUM6_TX;
+ 
+ 		err = geneve6_build_skb(dst, skb, key->tun_flags, vni,
+ 					info->options_len, opts,
+ 					flags, xnet);
+ 		if (unlikely(err))
+ 			goto err;
+ 
+ 		prio = ip_tunnel_ecn_encap(key->tos, iip, skb);
+ 		ttl = key->ttl;
+ 		label = info->key.label;
+ 	} else {
+ 		err = geneve6_build_skb(dst, skb, 0, geneve->vni,
+ 					0, NULL, flags, xnet);
+ 		if (unlikely(err))
+ 			goto err;
+ 
+ 		prio = ip_tunnel_ecn_encap(ip6_tclass(fl6.flowlabel),
+ 					   iip, skb);
+ 		ttl = geneve->ttl;
+ 		if (!ttl && ipv6_addr_is_multicast(&fl6.daddr))
+ 			ttl = 1;
+ 		ttl = ttl ? : ip6_dst_hoplimit(dst);
+ 		label = geneve->label;
+ 	}
+ 
+ 	udp_tunnel6_xmit_skb(dst, gs6->sock->sk, skb, dev,
+ 			     &fl6.saddr, &fl6.daddr, prio, ttl, label,
+ 			     sport, geneve->dst_port,
+ 			     !!(flags & GENEVE_F_UDP_ZERO_CSUM6_TX));
+ 	return NETDEV_TX_OK;
+ 
+ tx_error:
+ 	dev_kfree_skb(skb);
+ err:
+ 	if (err == -ELOOP)
+ 		dev->stats.collisions++;
+ 	else if (err == -ENETUNREACH)
+ 		dev->stats.tx_carrier_errors++;
+ 	else
+ 		dev->stats.tx_errors++;
+ 	return NETDEV_TX_OK;
+ }
+ #endif
+ 
+ static netdev_tx_t geneve_xmit(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct geneve_dev *geneve = netdev_priv(dev);
+ 	struct ip_tunnel_info *info = NULL;
+ 
+ 	if (geneve->collect_md)
+ 		info = skb_tunnel_info(skb);
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if ((info && ip_tunnel_info_af(info) == AF_INET6) ||
+ 	    (!info && geneve->remote.sa.sa_family == AF_INET6))
+ 		return geneve6_xmit_skb(skb, dev, info);
+ #endif
+ 	return geneve_xmit_skb(skb, dev, info);
+ }
+ 
+ static int __geneve_change_mtu(struct net_device *dev, int new_mtu, bool strict)
+ {
+ 	/* The max_mtu calculation does not take account of GENEVE
+ 	 * options, to avoid excluding potentially valid
+ 	 * configurations.
+ 	 */
+ 	int max_mtu = IP_MAX_MTU - GENEVE_BASE_HLEN - sizeof(struct iphdr)
+ 		- dev->hard_header_len;
+ 
+ 	if (new_mtu < 68)
+ 		return -EINVAL;
+ 
+ 	if (new_mtu > max_mtu) {
+ 		if (strict)
+ 			return -EINVAL;
+ 
+ 		new_mtu = max_mtu;
+ 	}
+ 
+ 	dev->mtu = new_mtu;
+ 	return 0;
+ }
+ 
+ static int geneve_change_mtu(struct net_device *dev, int new_mtu)
+ {
+ 	return __geneve_change_mtu(dev, new_mtu, true);
+ }
+ 
+ static int geneve_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
+ {
+ 	struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 	struct geneve_dev *geneve = netdev_priv(dev);
+ 	struct rtable *rt;
+ 	struct flowi4 fl4;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	struct dst_entry *dst;
+ 	struct flowi6 fl6;
+ #endif
+ 
+ 	if (ip_tunnel_info_af(info) == AF_INET) {
+ 		rt = geneve_get_v4_rt(skb, dev, &fl4, info);
+ 		if (IS_ERR(rt))
+ 			return PTR_ERR(rt);
+ 
+ 		ip_rt_put(rt);
+ 		info->key.u.ipv4.src = fl4.saddr;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	} else if (ip_tunnel_info_af(info) == AF_INET6) {
+ 		dst = geneve_get_v6_dst(skb, dev, &fl6, info);
+ 		if (IS_ERR(dst))
+ 			return PTR_ERR(dst);
+ 
+ 		dst_release(dst);
+ 		info->key.u.ipv6.src = fl6.saddr;
+ #endif
+ 	} else {
+ 		return -EINVAL;
+ 	}
+ 
+ 	info->key.tp_src = udp_flow_src_port(geneve->net, skb,
+ 					     1, USHRT_MAX, true);
+ 	info->key.tp_dst = geneve->dst_port;
+ 	return 0;
+ }
+ 
++>>>>>>> 95caf6f71a99 (geneve: fix populating tclass in geneve_get_v6_dst)
  static const struct net_device_ops geneve_netdev_ops = {
  	.ndo_init		= geneve_init,
  	.ndo_uninit		= geneve_uninit,
* Unmerged path drivers/net/geneve.c
