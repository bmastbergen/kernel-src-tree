sctp: add SCTP_PR_ASSOC_STATUS on sctp sockopt

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit 826d253d57b11f69add81c8086d2e7f1dce5ec77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/826d253d.failed

This patch adds SCTP_PR_ASSOC_STATUS to sctp sockopt, which is used
to dump the prsctp statistics info from the asoc. The prsctp statistics
includes abandoned_sent/unsent from the asoc. abandoned_sent is the
count of the packets we drop packets from retransmit/transmited queue,
and abandoned_unsent is the count of the packets we drop from out_queue
according to the policy.

Note: another option for prsctp statistics dump described in rfc is
SCTP_PR_STREAM_STATUS, which is used to dump the prsctp statistics
info from each stream. But by now, linux doesn't yet have per stream
statistics info, it needs rfc6525 to be implemented. As the prsctp
statistics for each stream has to be based on per stream statistics,
we will delay it until rfc6525 is done in linux.

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 826d253d57b11f69add81c8086d2e7f1dce5ec77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/sctp.h
#	net/sctp/socket.c
diff --cc include/uapi/linux/sctp.h
index 66b466e4ca08,d304f4c9792c..000000000000
--- a/include/uapi/linux/sctp.h
+++ b/include/uapi/linux/sctp.h
@@@ -110,9 -112,40 +110,15 @@@ typedef __s32 sctp_assoc_t
  #define SCTP_SOCKOPT_CONNECTX	110		/* CONNECTX requests. */
  #define SCTP_SOCKOPT_CONNECTX3	111	/* CONNECTX requests (updated) */
  #define SCTP_GET_ASSOC_STATS	112	/* Read only */
++<<<<<<< HEAD
++=======
+ #define SCTP_PR_SUPPORTED	113
+ #define SCTP_DEFAULT_PRINFO	114
+ #define SCTP_PR_ASSOC_STATUS	115
++>>>>>>> 826d253d57b1 (sctp: add SCTP_PR_ASSOC_STATUS on sctp sockopt)
  
 -/* PR-SCTP policies */
 -#define SCTP_PR_SCTP_NONE	0x0000
 -#define SCTP_PR_SCTP_TTL	0x0010
 -#define SCTP_PR_SCTP_RTX	0x0020
 -#define SCTP_PR_SCTP_PRIO	0x0030
 -#define SCTP_PR_SCTP_MAX	SCTP_PR_SCTP_PRIO
 -#define SCTP_PR_SCTP_MASK	0x0030
 -
 -#define __SCTP_PR_INDEX(x)	((x >> 4) - 1)
 -#define SCTP_PR_INDEX(x)	__SCTP_PR_INDEX(SCTP_PR_SCTP_ ## x)
 -
 -#define SCTP_PR_POLICY(x)	((x) & SCTP_PR_SCTP_MASK)
 -#define SCTP_PR_SET_POLICY(flags, x)	\
 -	do {				\
 -		flags &= ~SCTP_PR_SCTP_MASK;	\
 -		flags |= x;		\
 -	} while (0)
 -
 -#define SCTP_PR_TTL_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_TTL)
 -#define SCTP_PR_RTX_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_RTX)
 -#define SCTP_PR_PRIO_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_PRIO)
 -
 -/* These are bit fields for msghdr->msg_flags.  See section 5.1.  */
 -/* On user space Linux, these live in <bits/socket.h> as an enum.  */
 -enum sctp_msg_flags {
 -	MSG_NOTIFICATION = 0x8000,
 -#define MSG_NOTIFICATION MSG_NOTIFICATION
 -};
 -
 -/* 5.3.1 SCTP Initiation Structure (SCTP_INIT)
 +/*
 + * 5.2.1 SCTP Initiation Structure (SCTP_INIT)
   *
   *   This cmsghdr structure provides information for initializing new
   *   SCTP associations with sendmsg().  The SCTP_INITMSG socket option
@@@ -843,4 -927,21 +849,24 @@@ struct sctp_paddrthlds 
  	__u16 spt_pathpfthld;
  };
  
++<<<<<<< HEAD
++=======
+ /*
+  * Socket Option for Getting the Association/Stream-Specific PR-SCTP Status
+  */
+ struct sctp_prstatus {
+ 	sctp_assoc_t sprstat_assoc_id;
+ 	__u16 sprstat_sid;
+ 	__u16 sprstat_policy;
+ 	__u64 sprstat_abandoned_unsent;
+ 	__u64 sprstat_abandoned_sent;
+ };
+ 
+ struct sctp_default_prinfo {
+ 	sctp_assoc_t pr_assoc_id;
+ 	__u32 pr_value;
+ 	__u16 pr_policy;
+ };
+ 
++>>>>>>> 826d253d57b1 (sctp: add SCTP_PR_ASSOC_STATUS on sctp sockopt)
  #endif /* _UAPI_SCTP_H */
diff --cc net/sctp/socket.c
index 34a2b15b5d0d,c3167c43a9c1..000000000000
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@@ -5860,8 -6206,190 +5860,195 @@@ static int sctp_getsockopt_assoc_stats(
  	return 0;
  }
  
++<<<<<<< HEAD
 +SCTP_STATIC int sctp_getsockopt(struct sock *sk, int level, int optname,
 +				char __user *optval, int __user *optlen)
++=======
+ static int sctp_getsockopt_recvrcvinfo(struct sock *sk,	int len,
+ 				       char __user *optval,
+ 				       int __user *optlen)
+ {
+ 	int val = 0;
+ 
+ 	if (len < sizeof(int))
+ 		return -EINVAL;
+ 
+ 	len = sizeof(int);
+ 	if (sctp_sk(sk)->recvrcvinfo)
+ 		val = 1;
+ 	if (put_user(len, optlen))
+ 		return -EFAULT;
+ 	if (copy_to_user(optval, &val, len))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
+ static int sctp_getsockopt_recvnxtinfo(struct sock *sk,	int len,
+ 				       char __user *optval,
+ 				       int __user *optlen)
+ {
+ 	int val = 0;
+ 
+ 	if (len < sizeof(int))
+ 		return -EINVAL;
+ 
+ 	len = sizeof(int);
+ 	if (sctp_sk(sk)->recvnxtinfo)
+ 		val = 1;
+ 	if (put_user(len, optlen))
+ 		return -EFAULT;
+ 	if (copy_to_user(optval, &val, len))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
+ static int sctp_getsockopt_pr_supported(struct sock *sk, int len,
+ 					char __user *optval,
+ 					int __user *optlen)
+ {
+ 	struct sctp_assoc_value params;
+ 	struct sctp_association *asoc;
+ 	int retval = -EFAULT;
+ 
+ 	if (len < sizeof(params)) {
+ 		retval = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	len = sizeof(params);
+ 	if (copy_from_user(&params, optval, len))
+ 		goto out;
+ 
+ 	asoc = sctp_id2assoc(sk, params.assoc_id);
+ 	if (asoc) {
+ 		params.assoc_value = asoc->prsctp_enable;
+ 	} else if (!params.assoc_id) {
+ 		struct sctp_sock *sp = sctp_sk(sk);
+ 
+ 		params.assoc_value = sp->ep->prsctp_enable;
+ 	} else {
+ 		retval = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (put_user(len, optlen))
+ 		goto out;
+ 
+ 	if (copy_to_user(optval, &params, len))
+ 		goto out;
+ 
+ 	retval = 0;
+ 
+ out:
+ 	return retval;
+ }
+ 
+ static int sctp_getsockopt_default_prinfo(struct sock *sk, int len,
+ 					  char __user *optval,
+ 					  int __user *optlen)
+ {
+ 	struct sctp_default_prinfo info;
+ 	struct sctp_association *asoc;
+ 	int retval = -EFAULT;
+ 
+ 	if (len < sizeof(info)) {
+ 		retval = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	len = sizeof(info);
+ 	if (copy_from_user(&info, optval, len))
+ 		goto out;
+ 
+ 	asoc = sctp_id2assoc(sk, info.pr_assoc_id);
+ 	if (asoc) {
+ 		info.pr_policy = SCTP_PR_POLICY(asoc->default_flags);
+ 		info.pr_value = asoc->default_timetolive;
+ 	} else if (!info.pr_assoc_id) {
+ 		struct sctp_sock *sp = sctp_sk(sk);
+ 
+ 		info.pr_policy = SCTP_PR_POLICY(sp->default_flags);
+ 		info.pr_value = sp->default_timetolive;
+ 	} else {
+ 		retval = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (put_user(len, optlen))
+ 		goto out;
+ 
+ 	if (copy_to_user(optval, &info, len))
+ 		goto out;
+ 
+ 	retval = 0;
+ 
+ out:
+ 	return retval;
+ }
+ 
+ static int sctp_getsockopt_pr_assocstatus(struct sock *sk, int len,
+ 					  char __user *optval,
+ 					  int __user *optlen)
+ {
+ 	struct sctp_prstatus params;
+ 	struct sctp_association *asoc;
+ 	int policy;
+ 	int retval = -EINVAL;
+ 
+ 	if (len < sizeof(params))
+ 		goto out;
+ 
+ 	len = sizeof(params);
+ 	if (copy_from_user(&params, optval, len)) {
+ 		retval = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	policy = params.sprstat_policy;
+ 	if (policy & ~SCTP_PR_SCTP_MASK)
+ 		goto out;
+ 
+ 	asoc = sctp_id2assoc(sk, params.sprstat_assoc_id);
+ 	if (!asoc)
+ 		goto out;
+ 
+ 	if (policy == SCTP_PR_SCTP_NONE) {
+ 		params.sprstat_abandoned_unsent = 0;
+ 		params.sprstat_abandoned_sent = 0;
+ 		for (policy = 0; policy <= SCTP_PR_INDEX(MAX); policy++) {
+ 			params.sprstat_abandoned_unsent +=
+ 				asoc->abandoned_unsent[policy];
+ 			params.sprstat_abandoned_sent +=
+ 				asoc->abandoned_sent[policy];
+ 		}
+ 	} else {
+ 		params.sprstat_abandoned_unsent =
+ 			asoc->abandoned_unsent[__SCTP_PR_INDEX(policy)];
+ 		params.sprstat_abandoned_sent =
+ 			asoc->abandoned_sent[__SCTP_PR_INDEX(policy)];
+ 	}
+ 
+ 	if (put_user(len, optlen)) {
+ 		retval = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	if (copy_to_user(optval, &params, len)) {
+ 		retval = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	retval = 0;
+ 
+ out:
+ 	return retval;
+ }
+ 
+ static int sctp_getsockopt(struct sock *sk, int level, int optname,
+ 			   char __user *optval, int __user *optlen)
++>>>>>>> 826d253d57b1 (sctp: add SCTP_PR_ASSOC_STATUS on sctp sockopt)
  {
  	int retval = 0;
  	int len;
@@@ -6004,6 -6535,23 +6191,26 @@@
  	case SCTP_GET_ASSOC_STATS:
  		retval = sctp_getsockopt_assoc_stats(sk, len, optval, optlen);
  		break;
++<<<<<<< HEAD
++=======
+ 	case SCTP_RECVRCVINFO:
+ 		retval = sctp_getsockopt_recvrcvinfo(sk, len, optval, optlen);
+ 		break;
+ 	case SCTP_RECVNXTINFO:
+ 		retval = sctp_getsockopt_recvnxtinfo(sk, len, optval, optlen);
+ 		break;
+ 	case SCTP_PR_SUPPORTED:
+ 		retval = sctp_getsockopt_pr_supported(sk, len, optval, optlen);
+ 		break;
+ 	case SCTP_DEFAULT_PRINFO:
+ 		retval = sctp_getsockopt_default_prinfo(sk, len, optval,
+ 							optlen);
+ 		break;
+ 	case SCTP_PR_ASSOC_STATUS:
+ 		retval = sctp_getsockopt_pr_assocstatus(sk, len, optval,
+ 							optlen);
+ 		break;
++>>>>>>> 826d253d57b1 (sctp: add SCTP_PR_ASSOC_STATUS on sctp sockopt)
  	default:
  		retval = -ENOPROTOOPT;
  		break;
diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7fbce55da678..1bb624399154 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1868,6 +1868,9 @@ struct sctp_association {
 	     temp:1;		/* Is it a temporary association? */
 
 	struct sctp_priv_assoc_stats stats;
+
+	__u64 abandoned_unsent[SCTP_PR_INDEX(MAX) + 1];
+	__u64 abandoned_sent[SCTP_PR_INDEX(MAX) + 1];
 };
 
 
* Unmerged path include/uapi/linux/sctp.h
* Unmerged path net/sctp/socket.c
