x86/efi: Fix boot failure with EFI stub

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] efi: Fix boot failure with EFI stub (Lenny Szubowicz) [1310154]
Rebuild_FUZZ: 94.59%
commit-author Matt Fleming <matt.fleming@intel.com>
commit 396f1a08db212138418b38f784e4bbe516d2fdb2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/396f1a08.failed

commit 54b52d872680 ("x86/efi: Build our own EFI services pointer
table") introduced a regression because the 64-bit file_size()
implementation passed a pointer to a 32-bit data object, instead of a
pointer to a 64-bit object.

Because the firmware treats the object as 64-bits regardless it was
reading random values from the stack for the upper 32-bits.

This resulted in people being unable to boot their machines, after
seeing the following error messages,

    Failed to get file info size
    Failed to alloc highmem for files

	Reported-by: Dzmitry Sledneu <dzmitry.sledneu@gmail.com>
	Reported-by: Koen Kooi <koen@dominion.thruhere.net>
	Tested-by: Koen Kooi <koen@dominion.thruhere.net>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit 396f1a08db212138418b38f784e4bbe516d2fdb2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/eboot.c
diff --cc arch/x86/boot/compressed/eboot.c
index a1ae20b40077,280165524ee4..000000000000
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@@ -20,6 -19,270 +20,273 @@@
  
  static efi_system_table_t *sys_table;
  
++<<<<<<< HEAD
++=======
+ static struct efi_config *efi_early;
+ 
+ #define efi_call_early(f, ...)						\
+ 	efi_early->call(efi_early->f, __VA_ARGS__);
+ 
+ #define BOOT_SERVICES(bits)						\
+ static void setup_boot_services##bits(struct efi_config *c)		\
+ {									\
+ 	efi_system_table_##bits##_t *table;				\
+ 	efi_boot_services_##bits##_t *bt;				\
+ 									\
+ 	table = (typeof(table))sys_table;				\
+ 									\
+ 	c->text_output = table->con_out;				\
+ 									\
+ 	bt = (typeof(bt))(unsigned long)(table->boottime);		\
+ 									\
+ 	c->allocate_pool = bt->allocate_pool;				\
+ 	c->allocate_pages = bt->allocate_pages;				\
+ 	c->get_memory_map = bt->get_memory_map;				\
+ 	c->free_pool = bt->free_pool;					\
+ 	c->free_pages = bt->free_pages;					\
+ 	c->locate_handle = bt->locate_handle;				\
+ 	c->handle_protocol = bt->handle_protocol;			\
+ 	c->exit_boot_services = bt->exit_boot_services;			\
+ }
+ BOOT_SERVICES(32);
+ BOOT_SERVICES(64);
+ 
+ static void efi_printk(efi_system_table_t *, char *);
+ static void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
+ 
+ static efi_status_t
+ __file_size32(void *__fh, efi_char16_t *filename_16,
+ 	      void **handle, u64 *file_sz)
+ {
+ 	efi_file_handle_32_t *h, *fh = __fh;
+ 	efi_file_info_t *info;
+ 	efi_status_t status;
+ 	efi_guid_t info_guid = EFI_FILE_INFO_ID;
+ 	u32 info_sz;
+ 
+ 	status = efi_early->call((unsigned long)fh->open, fh, &h, filename_16,
+ 				 EFI_FILE_MODE_READ, (u64)0);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to open file: ");
+ 		efi_char16_printk(sys_table, filename_16);
+ 		efi_printk(sys_table, "\n");
+ 		return status;
+ 	}
+ 
+ 	*handle = h;
+ 
+ 	info_sz = 0;
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, NULL);
+ 	if (status != EFI_BUFFER_TOO_SMALL) {
+ 		efi_printk(sys_table, "Failed to get file info size\n");
+ 		return status;
+ 	}
+ 
+ grow:
+ 	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
+ 				info_sz, (void **)&info);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to alloc mem for file info\n");
+ 		return status;
+ 	}
+ 
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, info);
+ 	if (status == EFI_BUFFER_TOO_SMALL) {
+ 		efi_call_early(free_pool, info);
+ 		goto grow;
+ 	}
+ 
+ 	*file_sz = info->file_size;
+ 	efi_call_early(free_pool, info);
+ 
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to get initrd info\n");
+ 
+ 	return status;
+ }
+ 
+ static efi_status_t
+ __file_size64(void *__fh, efi_char16_t *filename_16,
+ 	      void **handle, u64 *file_sz)
+ {
+ 	efi_file_handle_64_t *h, *fh = __fh;
+ 	efi_file_info_t *info;
+ 	efi_status_t status;
+ 	efi_guid_t info_guid = EFI_FILE_INFO_ID;
+ 	u64 info_sz;
+ 
+ 	status = efi_early->call((unsigned long)fh->open, fh, &h, filename_16,
+ 				 EFI_FILE_MODE_READ, (u64)0);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to open file: ");
+ 		efi_char16_printk(sys_table, filename_16);
+ 		efi_printk(sys_table, "\n");
+ 		return status;
+ 	}
+ 
+ 	*handle = h;
+ 
+ 	info_sz = 0;
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, NULL);
+ 	if (status != EFI_BUFFER_TOO_SMALL) {
+ 		efi_printk(sys_table, "Failed to get file info size\n");
+ 		return status;
+ 	}
+ 
+ grow:
+ 	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
+ 				info_sz, (void **)&info);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to alloc mem for file info\n");
+ 		return status;
+ 	}
+ 
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, info);
+ 	if (status == EFI_BUFFER_TOO_SMALL) {
+ 		efi_call_early(free_pool, info);
+ 		goto grow;
+ 	}
+ 
+ 	*file_sz = info->file_size;
+ 	efi_call_early(free_pool, info);
+ 
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to get initrd info\n");
+ 
+ 	return status;
+ }
+ static efi_status_t
+ efi_file_size(efi_system_table_t *sys_table, void *__fh,
+ 	      efi_char16_t *filename_16, void **handle, u64 *file_sz)
+ {
+ 	if (efi_early->is64)
+ 		return __file_size64(__fh, filename_16, handle, file_sz);
+ 
+ 	return __file_size32(__fh, filename_16, handle, file_sz);
+ }
+ 
+ static inline efi_status_t
+ efi_file_read(void *__fh, void *handle, unsigned long *size, void *addr)
+ {
+ 	unsigned long func;
+ 
+ 	if (efi_early->is64) {
+ 		efi_file_handle_64_t *fh = __fh;
+ 
+ 		func = (unsigned long)fh->read;
+ 		return efi_early->call(func, handle, size, addr);
+ 	} else {
+ 		efi_file_handle_32_t *fh = __fh;
+ 
+ 		func = (unsigned long)fh->read;
+ 		return efi_early->call(func, handle, size, addr);
+ 	}
+ }
+ 
+ static inline efi_status_t efi_file_close(void *__fh, void *handle)
+ {
+ 	if (efi_early->is64) {
+ 		efi_file_handle_64_t *fh = __fh;
+ 
+ 		return efi_early->call((unsigned long)fh->close, handle);
+ 	} else {
+ 		efi_file_handle_32_t *fh = __fh;
+ 
+ 		return efi_early->call((unsigned long)fh->close, handle);
+ 	}
+ }
+ 
+ static inline efi_status_t __open_volume32(void *__image, void **__fh)
+ {
+ 	efi_file_io_interface_t *io;
+ 	efi_loaded_image_32_t *image = __image;
+ 	efi_file_handle_32_t *fh;
+ 	efi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;
+ 	efi_status_t status;
+ 	void *handle = (void *)(unsigned long)image->device_handle;
+ 	unsigned long func;
+ 
+ 	status = efi_call_early(handle_protocol, handle,
+ 				&fs_proto, (void **)&io);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to handle fs_proto\n");
+ 		return status;
+ 	}
+ 
+ 	func = (unsigned long)io->open_volume;
+ 	status = efi_early->call(func, io, &fh);
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to open volume\n");
+ 
+ 	*__fh = fh;
+ 	return status;
+ }
+ 
+ static inline efi_status_t __open_volume64(void *__image, void **__fh)
+ {
+ 	efi_file_io_interface_t *io;
+ 	efi_loaded_image_64_t *image = __image;
+ 	efi_file_handle_64_t *fh;
+ 	efi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;
+ 	efi_status_t status;
+ 	void *handle = (void *)(unsigned long)image->device_handle;
+ 	unsigned long func;
+ 
+ 	status = efi_call_early(handle_protocol, handle,
+ 				&fs_proto, (void **)&io);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to handle fs_proto\n");
+ 		return status;
+ 	}
+ 
+ 	func = (unsigned long)io->open_volume;
+ 	status = efi_early->call(func, io, &fh);
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to open volume\n");
+ 
+ 	*__fh = fh;
+ 	return status;
+ }
+ 
+ static inline efi_status_t
+ efi_open_volume(efi_system_table_t *sys_table, void *__image, void **__fh)
+ {
+ 	if (efi_early->is64)
+ 		return __open_volume64(__image, __fh);
+ 
+ 	return __open_volume32(__image, __fh);
+ }
+ 
+ static void efi_char16_printk(efi_system_table_t *table, efi_char16_t *str)
+ {
+ 	unsigned long output_string;
+ 	size_t offset;
+ 
+ 	if (efi_early->is64) {
+ 		struct efi_simple_text_output_protocol_64 *out;
+ 		u64 *func;
+ 
+ 		offset = offsetof(typeof(*out), output_string);
+ 		output_string = efi_early->text_output + offset;
+ 		func = (u64 *)output_string;
+ 
+ 		efi_early->call(*func, efi_early->text_output, str);
+ 	} else {
+ 		struct efi_simple_text_output_protocol_32 *out;
+ 		u32 *func;
+ 
+ 		offset = offsetof(typeof(*out), output_string);
+ 		output_string = efi_early->text_output + offset;
+ 		func = (u32 *)output_string;
+ 
+ 		efi_early->call(*func, efi_early->text_output, str);
+ 	}
+ }
++>>>>>>> 396f1a08db21 (x86/efi: Fix boot failure with EFI stub)
  
  #include "../../../../drivers/firmware/efi/efi-stub-helper.c"
  
* Unmerged path arch/x86/boot/compressed/eboot.c
