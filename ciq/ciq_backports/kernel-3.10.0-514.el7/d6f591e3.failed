Drivers: hv: vmbus: channge vmbus_connection.channel_lock to mutex

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hv] vmbus: channge vmbus_connection.channel_lock to mutex (Vitaly Kuznetsov) [1321073]
Rebuild_FUZZ: 89.08%
commit-author Dexuan Cui <decui@microsoft.com>
commit d6f591e339d23f434efda11917da511870891472
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d6f591e3.failed

spinlock is unnecessary here.
mutex is enough.

	Signed-off-by: Dexuan Cui <decui@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit d6f591e339d23f434efda11917da511870891472)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/channel_mgmt.c
diff --cc drivers/hv/channel_mgmt.c
index 90655a5e0695,d0131717c1d5..000000000000
--- a/drivers/hv/channel_mgmt.c
+++ b/drivers/hv/channel_mgmt.c
@@@ -201,9 -206,11 +201,15 @@@ void hv_process_channel_removal(struct 
  	}
  
  	if (channel->primary_channel == NULL) {
- 		spin_lock_irqsave(&vmbus_connection.channel_lock, flags);
+ 		mutex_lock(&vmbus_connection.channel_mutex);
  		list_del(&channel->listentry);
++<<<<<<< HEAD
 +		spin_unlock_irqrestore(&vmbus_connection.channel_lock, flags);
++=======
+ 		mutex_unlock(&vmbus_connection.channel_mutex);
+ 
+ 		primary_channel = channel;
++>>>>>>> d6f591e339d2 (Drivers: hv: vmbus: channge vmbus_connection.channel_lock to mutex)
  	} else {
  		primary_channel = channel->primary_channel;
  		spin_lock_irqsave(&primary_channel->lock, flags);
@@@ -247,25 -265,12 +253,25 @@@ static void vmbus_process_offer(struct 
  		}
  	}
  
 -	if (fnew)
 +	if (fnew) {
  		list_add_tail(&newchannel->listentry,
  			      &vmbus_connection.chn_list);
 +		enq = true;
 +	}
  
- 	spin_unlock_irqrestore(&vmbus_connection.channel_lock, flags);
+ 	mutex_unlock(&vmbus_connection.channel_mutex);
  
 +	if (enq) {
 +		if (newchannel->target_cpu != get_cpu()) {
 +			put_cpu();
 +			smp_call_function_single(newchannel->target_cpu,
 +						 percpu_channel_enq,
 +						 newchannel, true);
 +		} else {
 +			percpu_channel_enq(newchannel);
 +			put_cpu();
 +		}
 +	}
  	if (!fnew) {
  		/*
  		 * Check to see if this is a sub-channel.
* Unmerged path drivers/hv/channel_mgmt.c
diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 7104e1a87971..6e458df2f9e4 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -141,7 +141,7 @@ int vmbus_connect(void)
 	spin_lock_init(&vmbus_connection.channelmsg_lock);
 
 	INIT_LIST_HEAD(&vmbus_connection.chn_list);
-	spin_lock_init(&vmbus_connection.channel_lock);
+	mutex_init(&vmbus_connection.channel_mutex);
 
 	/*
 	 * Setup the vmbus event connection for channel interrupt
@@ -277,11 +277,10 @@ struct vmbus_channel *relid2channel(u32 relid)
 {
 	struct vmbus_channel *channel;
 	struct vmbus_channel *found_channel  = NULL;
-	unsigned long flags;
 	struct list_head *cur, *tmp;
 	struct vmbus_channel *cur_sc;
 
-	spin_lock_irqsave(&vmbus_connection.channel_lock, flags);
+	mutex_lock(&vmbus_connection.channel_mutex);
 	list_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {
 		if (channel->offermsg.child_relid == relid) {
 			found_channel = channel;
@@ -300,7 +299,7 @@ struct vmbus_channel *relid2channel(u32 relid)
 			}
 		}
 	}
-	spin_unlock_irqrestore(&vmbus_connection.channel_lock, flags);
+	mutex_unlock(&vmbus_connection.channel_mutex);
 
 	return found_channel;
 }
diff --git a/drivers/hv/hyperv_vmbus.h b/drivers/hv/hyperv_vmbus.h
index 0420c9441ddc..514da2235068 100644
--- a/drivers/hv/hyperv_vmbus.h
+++ b/drivers/hv/hyperv_vmbus.h
@@ -650,7 +650,7 @@ struct vmbus_connection {
 
 	/* List of channels */
 	struct list_head chn_list;
-	spinlock_t channel_lock;
+	struct mutex channel_mutex;
 
 	struct workqueue_struct *work_queue;
 };
