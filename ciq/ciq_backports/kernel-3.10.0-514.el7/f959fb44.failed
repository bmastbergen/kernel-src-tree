sctp: add SCTP_DEFAULT_PRINFO into sctp sockopt

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit f959fb442c35f4b61fea341401b8463dd0a1b959
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f959fb44.failed

This patch adds SCTP_DEFAULT_PRINFO to sctp sockopt. It is used
to set/get sctp Partially Reliable Policies' default params,
which includes 3 policies (ttl, rtx, prio) and their values.

Still, if we set policy params in sndinfo, we will use the params
of sndinfo against chunks, instead of the default params.

In this patch, we will use 5-8bit of sp/asoc->default_flags
to store prsctp policies, and reuse asoc->default_timetolive
to store their values. It means if we enable and set prsctp
policy, prior ttl timeout in sctp will not work any more.

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f959fb442c35f4b61fea341401b8463dd0a1b959)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/sctp.h
#	net/sctp/socket.c
diff --cc include/uapi/linux/sctp.h
index 66b466e4ca08,984cf2e9a61d..000000000000
--- a/include/uapi/linux/sctp.h
+++ b/include/uapi/linux/sctp.h
@@@ -110,9 -112,39 +110,36 @@@ typedef __s32 sctp_assoc_t
  #define SCTP_SOCKOPT_CONNECTX	110		/* CONNECTX requests. */
  #define SCTP_SOCKOPT_CONNECTX3	111	/* CONNECTX requests (updated) */
  #define SCTP_GET_ASSOC_STATS	112	/* Read only */
++<<<<<<< HEAD
++=======
+ #define SCTP_PR_SUPPORTED	113
+ #define SCTP_DEFAULT_PRINFO	114
+ 
+ /* PR-SCTP policies */
+ #define SCTP_PR_SCTP_NONE	0x0000
+ #define SCTP_PR_SCTP_TTL	0x0010
+ #define SCTP_PR_SCTP_RTX	0x0020
+ #define SCTP_PR_SCTP_PRIO	0x0030
+ #define SCTP_PR_SCTP_MAX	SCTP_PR_SCTP_PRIO
+ #define SCTP_PR_SCTP_MASK	0x0030
+ 
+ #define __SCTP_PR_INDEX(x)	((x >> 4) - 1)
+ #define SCTP_PR_INDEX(x)	__SCTP_PR_INDEX(SCTP_PR_SCTP_ ## x)
+ 
+ #define SCTP_PR_POLICY(x)	((x) & SCTP_PR_SCTP_MASK)
+ #define SCTP_PR_SET_POLICY(flags, x)	\
+ 	do {				\
+ 		flags &= ~SCTP_PR_SCTP_MASK;	\
+ 		flags |= x;		\
+ 	} while (0)
+ 
+ #define SCTP_PR_TTL_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_TTL)
+ #define SCTP_PR_RTX_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_RTX)
+ #define SCTP_PR_PRIO_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_PRIO)
++>>>>>>> f959fb442c35 (sctp: add SCTP_DEFAULT_PRINFO into sctp sockopt)
  
 -/* These are bit fields for msghdr->msg_flags.  See section 5.1.  */
 -/* On user space Linux, these live in <bits/socket.h> as an enum.  */
 -enum sctp_msg_flags {
 -	MSG_NOTIFICATION = 0x8000,
 -#define MSG_NOTIFICATION MSG_NOTIFICATION
 -};
 -
 -/* 5.3.1 SCTP Initiation Structure (SCTP_INIT)
 +/*
 + * 5.2.1 SCTP Initiation Structure (SCTP_INIT)
   *
   *   This cmsghdr structure provides information for initializing new
   *   SCTP associations with sendmsg().  The SCTP_INITMSG socket option
diff --cc net/sctp/socket.c
index 34a2b15b5d0d,c03fe1b76706..000000000000
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@@ -3585,6 -3629,112 +3585,115 @@@ static int sctp_setsockopt_paddr_thresh
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int sctp_setsockopt_recvrcvinfo(struct sock *sk,
+ 				       char __user *optval,
+ 				       unsigned int optlen)
+ {
+ 	int val;
+ 
+ 	if (optlen < sizeof(int))
+ 		return -EINVAL;
+ 	if (get_user(val, (int __user *) optval))
+ 		return -EFAULT;
+ 
+ 	sctp_sk(sk)->recvrcvinfo = (val == 0) ? 0 : 1;
+ 
+ 	return 0;
+ }
+ 
+ static int sctp_setsockopt_recvnxtinfo(struct sock *sk,
+ 				       char __user *optval,
+ 				       unsigned int optlen)
+ {
+ 	int val;
+ 
+ 	if (optlen < sizeof(int))
+ 		return -EINVAL;
+ 	if (get_user(val, (int __user *) optval))
+ 		return -EFAULT;
+ 
+ 	sctp_sk(sk)->recvnxtinfo = (val == 0) ? 0 : 1;
+ 
+ 	return 0;
+ }
+ 
+ static int sctp_setsockopt_pr_supported(struct sock *sk,
+ 					char __user *optval,
+ 					unsigned int optlen)
+ {
+ 	struct sctp_assoc_value params;
+ 	struct sctp_association *asoc;
+ 	int retval = -EINVAL;
+ 
+ 	if (optlen != sizeof(params))
+ 		goto out;
+ 
+ 	if (copy_from_user(&params, optval, optlen)) {
+ 		retval = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	asoc = sctp_id2assoc(sk, params.assoc_id);
+ 	if (asoc) {
+ 		asoc->prsctp_enable = !!params.assoc_value;
+ 	} else if (!params.assoc_id) {
+ 		struct sctp_sock *sp = sctp_sk(sk);
+ 
+ 		sp->ep->prsctp_enable = !!params.assoc_value;
+ 	} else {
+ 		goto out;
+ 	}
+ 
+ 	retval = 0;
+ 
+ out:
+ 	return retval;
+ }
+ 
+ static int sctp_setsockopt_default_prinfo(struct sock *sk,
+ 					  char __user *optval,
+ 					  unsigned int optlen)
+ {
+ 	struct sctp_default_prinfo info;
+ 	struct sctp_association *asoc;
+ 	int retval = -EINVAL;
+ 
+ 	if (optlen != sizeof(info))
+ 		goto out;
+ 
+ 	if (copy_from_user(&info, optval, sizeof(info))) {
+ 		retval = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	if (info.pr_policy & ~SCTP_PR_SCTP_MASK)
+ 		goto out;
+ 
+ 	if (info.pr_policy == SCTP_PR_SCTP_NONE)
+ 		info.pr_value = 0;
+ 
+ 	asoc = sctp_id2assoc(sk, info.pr_assoc_id);
+ 	if (asoc) {
+ 		SCTP_PR_SET_POLICY(asoc->default_flags, info.pr_policy);
+ 		asoc->default_timetolive = info.pr_value;
+ 	} else if (!info.pr_assoc_id) {
+ 		struct sctp_sock *sp = sctp_sk(sk);
+ 
+ 		SCTP_PR_SET_POLICY(sp->default_flags, info.pr_policy);
+ 		sp->default_timetolive = info.pr_value;
+ 	} else {
+ 		goto out;
+ 	}
+ 
+ 	retval = 0;
+ 
+ out:
+ 	return retval;
+ }
+ 
++>>>>>>> f959fb442c35 (sctp: add SCTP_DEFAULT_PRINFO into sctp sockopt)
  /* API 6.2 setsockopt(), getsockopt()
   *
   * Applications use setsockopt() and getsockopt() to set or retrieve
@@@ -3737,6 -3889,18 +3846,21 @@@ SCTP_STATIC int sctp_setsockopt(struct 
  	case SCTP_PEER_ADDR_THLDS:
  		retval = sctp_setsockopt_paddr_thresholds(sk, optval, optlen);
  		break;
++<<<<<<< HEAD
++=======
+ 	case SCTP_RECVRCVINFO:
+ 		retval = sctp_setsockopt_recvrcvinfo(sk, optval, optlen);
+ 		break;
+ 	case SCTP_RECVNXTINFO:
+ 		retval = sctp_setsockopt_recvnxtinfo(sk, optval, optlen);
+ 		break;
+ 	case SCTP_PR_SUPPORTED:
+ 		retval = sctp_setsockopt_pr_supported(sk, optval, optlen);
+ 		break;
+ 	case SCTP_DEFAULT_PRINFO:
+ 		retval = sctp_setsockopt_default_prinfo(sk, optval, optlen);
+ 		break;
++>>>>>>> f959fb442c35 (sctp: add SCTP_DEFAULT_PRINFO into sctp sockopt)
  	default:
  		retval = -ENOPROTOOPT;
  		break;
@@@ -5860,8 -6206,132 +5984,137 @@@ static int sctp_getsockopt_assoc_stats(
  	return 0;
  }
  
++<<<<<<< HEAD
 +SCTP_STATIC int sctp_getsockopt(struct sock *sk, int level, int optname,
 +				char __user *optval, int __user *optlen)
++=======
+ static int sctp_getsockopt_recvrcvinfo(struct sock *sk,	int len,
+ 				       char __user *optval,
+ 				       int __user *optlen)
+ {
+ 	int val = 0;
+ 
+ 	if (len < sizeof(int))
+ 		return -EINVAL;
+ 
+ 	len = sizeof(int);
+ 	if (sctp_sk(sk)->recvrcvinfo)
+ 		val = 1;
+ 	if (put_user(len, optlen))
+ 		return -EFAULT;
+ 	if (copy_to_user(optval, &val, len))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
+ static int sctp_getsockopt_recvnxtinfo(struct sock *sk,	int len,
+ 				       char __user *optval,
+ 				       int __user *optlen)
+ {
+ 	int val = 0;
+ 
+ 	if (len < sizeof(int))
+ 		return -EINVAL;
+ 
+ 	len = sizeof(int);
+ 	if (sctp_sk(sk)->recvnxtinfo)
+ 		val = 1;
+ 	if (put_user(len, optlen))
+ 		return -EFAULT;
+ 	if (copy_to_user(optval, &val, len))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
+ static int sctp_getsockopt_pr_supported(struct sock *sk, int len,
+ 					char __user *optval,
+ 					int __user *optlen)
+ {
+ 	struct sctp_assoc_value params;
+ 	struct sctp_association *asoc;
+ 	int retval = -EFAULT;
+ 
+ 	if (len < sizeof(params)) {
+ 		retval = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	len = sizeof(params);
+ 	if (copy_from_user(&params, optval, len))
+ 		goto out;
+ 
+ 	asoc = sctp_id2assoc(sk, params.assoc_id);
+ 	if (asoc) {
+ 		params.assoc_value = asoc->prsctp_enable;
+ 	} else if (!params.assoc_id) {
+ 		struct sctp_sock *sp = sctp_sk(sk);
+ 
+ 		params.assoc_value = sp->ep->prsctp_enable;
+ 	} else {
+ 		retval = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (put_user(len, optlen))
+ 		goto out;
+ 
+ 	if (copy_to_user(optval, &params, len))
+ 		goto out;
+ 
+ 	retval = 0;
+ 
+ out:
+ 	return retval;
+ }
+ 
+ static int sctp_getsockopt_default_prinfo(struct sock *sk, int len,
+ 					  char __user *optval,
+ 					  int __user *optlen)
+ {
+ 	struct sctp_default_prinfo info;
+ 	struct sctp_association *asoc;
+ 	int retval = -EFAULT;
+ 
+ 	if (len < sizeof(info)) {
+ 		retval = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	len = sizeof(info);
+ 	if (copy_from_user(&info, optval, len))
+ 		goto out;
+ 
+ 	asoc = sctp_id2assoc(sk, info.pr_assoc_id);
+ 	if (asoc) {
+ 		info.pr_policy = SCTP_PR_POLICY(asoc->default_flags);
+ 		info.pr_value = asoc->default_timetolive;
+ 	} else if (!info.pr_assoc_id) {
+ 		struct sctp_sock *sp = sctp_sk(sk);
+ 
+ 		info.pr_policy = SCTP_PR_POLICY(sp->default_flags);
+ 		info.pr_value = sp->default_timetolive;
+ 	} else {
+ 		retval = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (put_user(len, optlen))
+ 		goto out;
+ 
+ 	if (copy_to_user(optval, &info, len))
+ 		goto out;
+ 
+ 	retval = 0;
+ 
+ out:
+ 	return retval;
+ }
+ 
+ static int sctp_getsockopt(struct sock *sk, int level, int optname,
+ 			   char __user *optval, int __user *optlen)
++>>>>>>> f959fb442c35 (sctp: add SCTP_DEFAULT_PRINFO into sctp sockopt)
  {
  	int retval = 0;
  	int len;
@@@ -6004,6 -6477,19 +6257,22 @@@
  	case SCTP_GET_ASSOC_STATS:
  		retval = sctp_getsockopt_assoc_stats(sk, len, optval, optlen);
  		break;
++<<<<<<< HEAD
++=======
+ 	case SCTP_RECVRCVINFO:
+ 		retval = sctp_getsockopt_recvrcvinfo(sk, len, optval, optlen);
+ 		break;
+ 	case SCTP_RECVNXTINFO:
+ 		retval = sctp_getsockopt_recvnxtinfo(sk, len, optval, optlen);
+ 		break;
+ 	case SCTP_PR_SUPPORTED:
+ 		retval = sctp_getsockopt_pr_supported(sk, len, optval, optlen);
+ 		break;
+ 	case SCTP_DEFAULT_PRINFO:
+ 		retval = sctp_getsockopt_default_prinfo(sk, len, optval,
+ 							optlen);
+ 		break;
++>>>>>>> f959fb442c35 (sctp: add SCTP_DEFAULT_PRINFO into sctp sockopt)
  	default:
  		retval = -ENOPROTOOPT;
  		break;
* Unmerged path include/uapi/linux/sctp.h
* Unmerged path net/sctp/socket.c
