perf hists: Add helper functions for hierarchy mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit 8c01872fe3c17fde1ce74eecf523d6d7fce5ffec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8c01872f.failed

The rb_hierarchy_{next,prev,last} functions are to traverse all hist
entries in a hierarchy.  They will be used by various function which
supports hierarchy output.

As the rb_hierarchy_next() is used to traverse the whole hierarchy, it
sometime needs to visit entries regardless of current folding state.  So
add enum hierarchy_move_dir and pass it to __rb_hierarchy_next() for
those cases.

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Acked-by: Pekka Enberg <penberg@kernel.org>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1456326830-30456-5-git-send-email-namhyung@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 8c01872fe3c17fde1ce74eecf523d6d7fce5ffec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/hist.c
diff --cc tools/perf/util/hist.c
index e1380b8f8200,358af7ed07af..000000000000
--- a/tools/perf/util/hist.c
+++ b/tools/perf/util/hist.c
@@@ -1315,6 -1483,79 +1315,82 @@@ void hists__output_resort(struct hists 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ void perf_evsel__output_resort(struct perf_evsel *evsel, struct ui_progress *prog)
+ {
+ 	bool use_callchain;
+ 
+ 	if (evsel && symbol_conf.use_callchain && !symbol_conf.show_ref_callgraph)
+ 		use_callchain = evsel->attr.sample_type & PERF_SAMPLE_CALLCHAIN;
+ 	else
+ 		use_callchain = symbol_conf.use_callchain;
+ 
+ 	output_resort(evsel__hists(evsel), prog, use_callchain);
+ }
+ 
+ void hists__output_resort(struct hists *hists, struct ui_progress *prog)
+ {
+ 	output_resort(hists, prog, symbol_conf.use_callchain);
+ }
+ 
+ static bool can_goto_child(struct hist_entry *he, enum hierarchy_move_dir hmd)
+ {
+ 	if (he->leaf || hmd == HMD_FORCE_SIBLING)
+ 		return false;
+ 
+ 	if (he->unfolded || hmd == HMD_FORCE_CHILD)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ struct rb_node *rb_hierarchy_last(struct rb_node *node)
+ {
+ 	struct hist_entry *he = rb_entry(node, struct hist_entry, rb_node);
+ 
+ 	while (can_goto_child(he, HMD_NORMAL)) {
+ 		node = rb_last(&he->hroot_out);
+ 		he = rb_entry(node, struct hist_entry, rb_node);
+ 	}
+ 	return node;
+ }
+ 
+ struct rb_node *__rb_hierarchy_next(struct rb_node *node, enum hierarchy_move_dir hmd)
+ {
+ 	struct hist_entry *he = rb_entry(node, struct hist_entry, rb_node);
+ 
+ 	if (can_goto_child(he, hmd))
+ 		node = rb_first(&he->hroot_out);
+ 	else
+ 		node = rb_next(node);
+ 
+ 	while (node == NULL) {
+ 		he = he->parent_he;
+ 		if (he == NULL)
+ 			break;
+ 
+ 		node = rb_next(&he->rb_node);
+ 	}
+ 	return node;
+ }
+ 
+ struct rb_node *rb_hierarchy_prev(struct rb_node *node)
+ {
+ 	struct hist_entry *he = rb_entry(node, struct hist_entry, rb_node);
+ 
+ 	node = rb_prev(node);
+ 	if (node)
+ 		return rb_hierarchy_last(node);
+ 
+ 	he = he->parent_he;
+ 	if (he == NULL)
+ 		return NULL;
+ 
+ 	return &he->rb_node;
+ }
+ 
++>>>>>>> 8c01872fe3c1 (perf hists: Add helper functions for hierarchy mode)
  static void hists__remove_entry_filter(struct hists *hists, struct hist_entry *h,
  				       enum hist_filter filter)
  {
* Unmerged path tools/perf/util/hist.c
diff --git a/tools/perf/util/hist.h b/tools/perf/util/hist.h
index 2e5b433c74ba..17048c0334be 100644
--- a/tools/perf/util/hist.h
+++ b/tools/perf/util/hist.h
@@ -383,4 +383,20 @@ int perf_hist_config(const char *var, const char *value);
 
 void perf_hpp_list__init(struct perf_hpp_list *list);
 
+enum hierarchy_move_dir {
+	HMD_NORMAL,
+	HMD_FORCE_SIBLING,
+	HMD_FORCE_CHILD,
+};
+
+struct rb_node *rb_hierarchy_last(struct rb_node *node);
+struct rb_node *__rb_hierarchy_next(struct rb_node *node,
+				    enum hierarchy_move_dir hmd);
+struct rb_node *rb_hierarchy_prev(struct rb_node *node);
+
+static inline struct rb_node *rb_hierarchy_next(struct rb_node *node)
+{
+	return __rb_hierarchy_next(node, HMD_NORMAL);
+}
+
 #endif	/* __PERF_HIST_H */
