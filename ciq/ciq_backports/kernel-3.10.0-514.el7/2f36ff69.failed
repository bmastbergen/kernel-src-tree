usb: phy: generic: allow multiples calls to usb_phy_generic_register()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Felipe Balbi <balbi@ti.com>
commit 2f36ff6915c6c00df8b9962d9c6c7992befcf8ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2f36ff69.failed

it's now very easy to return a platform_device pointer
and have the caller pass it as argument when calling
usb_phy_generic_unregister().

	Signed-off-by: Felipe Balbi <balbi@ti.com>
(cherry picked from commit 2f36ff6915c6c00df8b9962d9c6c7992befcf8ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/musb/am35x.c
#	drivers/usb/musb/blackfin.c
#	drivers/usb/musb/da8xx.c
#	drivers/usb/musb/tusb6010.c
#	drivers/usb/phy/phy-nop.c
#	include/linux/usb/nop-usb-xceiv.h
diff --cc drivers/usb/musb/am35x.c
index dbe6007a6386,0a34dd859555..000000000000
--- a/drivers/usb/musb/am35x.c
+++ b/drivers/usb/musb/am35x.c
@@@ -513,25 -504,23 +514,39 @@@ static int am35x_probe(struct platform_
  
  	pdata->platform_ops		= &am35x_ops;
  
++<<<<<<< HEAD
++=======
+ 	glue->phy = usb_phy_generic_register();
+ 	if (IS_ERR(glue->phy))
+ 		goto err7;
++>>>>>>> 2f36ff6915c6 (usb: phy: generic: allow multiples calls to usb_phy_generic_register())
  	platform_set_drvdata(pdev, glue);
  
 -	pinfo = am35x_dev_info;
 -	pinfo.parent = &pdev->dev;
 -	pinfo.res = pdev->resource;
 -	pinfo.num_res = pdev->num_resources;
 -	pinfo.data = pdata;
 -	pinfo.size_data = sizeof(*pdata);
 +	ret = platform_device_add_resources(musb, pdev->resource,
 +			pdev->num_resources);
 +	if (ret) {
 +		dev_err(&pdev->dev, "failed to add resources\n");
 +		goto err7;
 +	}
  
++<<<<<<< HEAD
 +	ret = platform_device_add_data(musb, pdata, sizeof(*pdata));
 +	if (ret) {
 +		dev_err(&pdev->dev, "failed to add platform_data\n");
 +		goto err7;
 +	}
 +
 +	ret = platform_device_add(musb);
 +	if (ret) {
 +		dev_err(&pdev->dev, "failed to register musb device\n");
 +		goto err7;
++=======
+ 	glue->musb = musb = platform_device_register_full(&pinfo);
+ 	if (IS_ERR(musb)) {
+ 		ret = PTR_ERR(musb);
+ 		dev_err(&pdev->dev, "failed to register musb device: %d\n", ret);
+ 		goto err8;
++>>>>>>> 2f36ff6915c6 (usb: phy: generic: allow multiples calls to usb_phy_generic_register())
  	}
  
  	return 0;
@@@ -563,6 -552,7 +581,10 @@@ static int am35x_remove(struct platform
  	struct am35x_glue	*glue = platform_get_drvdata(pdev);
  
  	platform_device_unregister(glue->musb);
++<<<<<<< HEAD
++=======
+ 	usb_phy_generic_unregister(glue->phy);
++>>>>>>> 2f36ff6915c6 (usb: phy: generic: allow multiples calls to usb_phy_generic_register())
  	clk_disable(glue->clk);
  	clk_disable(glue->phy_clk);
  	clk_put(glue->clk);
diff --cc drivers/usb/musb/blackfin.c
index 72743225a0ef,d40d5f0b5528..000000000000
--- a/drivers/usb/musb/blackfin.c
+++ b/drivers/usb/musb/blackfin.c
@@@ -476,10 -476,26 +477,16 @@@ static int bfin_probe(struct platform_d
  
  	pdata->platform_ops		= &bfin_ops;
  
++<<<<<<< HEAD
++=======
+ 	glue->phy = usb_phy_generic_register();
+ 	if (IS_ERR(glue->phy))
+ 		goto err2;
++>>>>>>> 2f36ff6915c6 (usb: phy: generic: allow multiples calls to usb_phy_generic_register())
  	platform_set_drvdata(pdev, glue);
  
 -	memset(musb_resources, 0x00, sizeof(*musb_resources) *
 -			ARRAY_SIZE(musb_resources));
 -
 -	musb_resources[0].name = pdev->resource[0].name;
 -	musb_resources[0].start = pdev->resource[0].start;
 -	musb_resources[0].end = pdev->resource[0].end;
 -	musb_resources[0].flags = pdev->resource[0].flags;
 -
 -	musb_resources[1].name = pdev->resource[1].name;
 -	musb_resources[1].start = pdev->resource[1].start;
 -	musb_resources[1].end = pdev->resource[1].end;
 -	musb_resources[1].flags = pdev->resource[1].flags;
 -
 -	ret = platform_device_add_resources(musb, musb_resources,
 -			ARRAY_SIZE(musb_resources));
 +	ret = platform_device_add_resources(musb, pdev->resource,
 +			pdev->num_resources);
  	if (ret) {
  		dev_err(&pdev->dev, "failed to add resources\n");
  		goto err3;
@@@ -514,6 -533,7 +524,10 @@@ static int bfin_remove(struct platform_
  	struct bfin_glue		*glue = platform_get_drvdata(pdev);
  
  	platform_device_unregister(glue->musb);
++<<<<<<< HEAD
++=======
+ 	usb_phy_generic_unregister(glue->phy);
++>>>>>>> 2f36ff6915c6 (usb: phy: generic: allow multiples calls to usb_phy_generic_register())
  	kfree(glue);
  
  	return 0;
diff --cc drivers/usb/musb/da8xx.c
index 17d600a46123,058775e647ad..000000000000
--- a/drivers/usb/musb/da8xx.c
+++ b/drivers/usb/musb/da8xx.c
@@@ -518,25 -511,38 +519,53 @@@ static int da8xx_probe(struct platform_
  
  	pdata->platform_ops		= &da8xx_ops;
  
++<<<<<<< HEAD
++=======
+ 	glue->phy = usb_phy_generic_register();
+ 	if (IS_ERR(glue->phy)) {
+ 		ret = PTR_ERR(glue->phy);
+ 		goto err5;
+ 	}
++>>>>>>> 2f36ff6915c6 (usb: phy: generic: allow multiples calls to usb_phy_generic_register())
  	platform_set_drvdata(pdev, glue);
  
 -	memset(musb_resources, 0x00, sizeof(*musb_resources) *
 -			ARRAY_SIZE(musb_resources));
 +	ret = platform_device_add_resources(musb, pdev->resource,
 +			pdev->num_resources);
 +	if (ret) {
 +		dev_err(&pdev->dev, "failed to add resources\n");
 +		goto err5;
 +	}
  
 -	musb_resources[0].name = pdev->resource[0].name;
 -	musb_resources[0].start = pdev->resource[0].start;
 -	musb_resources[0].end = pdev->resource[0].end;
 -	musb_resources[0].flags = pdev->resource[0].flags;
 +	ret = platform_device_add_data(musb, pdata, sizeof(*pdata));
 +	if (ret) {
 +		dev_err(&pdev->dev, "failed to add platform_data\n");
 +		goto err5;
 +	}
  
++<<<<<<< HEAD
 +	ret = platform_device_add(musb);
 +	if (ret) {
 +		dev_err(&pdev->dev, "failed to register musb device\n");
 +		goto err5;
++=======
+ 	musb_resources[1].name = pdev->resource[1].name;
+ 	musb_resources[1].start = pdev->resource[1].start;
+ 	musb_resources[1].end = pdev->resource[1].end;
+ 	musb_resources[1].flags = pdev->resource[1].flags;
+ 
+ 	pinfo = da8xx_dev_info;
+ 	pinfo.parent = &pdev->dev;
+ 	pinfo.res = musb_resources;
+ 	pinfo.num_res = ARRAY_SIZE(musb_resources);
+ 	pinfo.data = pdata;
+ 	pinfo.size_data = sizeof(*pdata);
+ 
+ 	glue->musb = musb = platform_device_register_full(&pinfo);
+ 	if (IS_ERR(musb)) {
+ 		ret = PTR_ERR(musb);
+ 		dev_err(&pdev->dev, "failed to register musb device: %d\n", ret);
+ 		goto err6;
++>>>>>>> 2f36ff6915c6 (usb: phy: generic: allow multiples calls to usb_phy_generic_register())
  	}
  
  	return 0;
@@@ -562,6 -568,7 +594,10 @@@ static int da8xx_remove(struct platform
  	struct da8xx_glue		*glue = platform_get_drvdata(pdev);
  
  	platform_device_unregister(glue->musb);
++<<<<<<< HEAD
++=======
+ 	usb_phy_generic_unregister(glue->phy);
++>>>>>>> 2f36ff6915c6 (usb: phy: generic: allow multiples calls to usb_phy_generic_register())
  	clk_disable(glue->clk);
  	clk_put(glue->clk);
  	kfree(glue);
diff --cc drivers/usb/musb/tusb6010.c
index 709d4364825f,f38a8dbd6075..000000000000
--- a/drivers/usb/musb/tusb6010.c
+++ b/drivers/usb/musb/tusb6010.c
@@@ -1220,6 -1223,7 +1221,10 @@@ static int tusb_remove(struct platform_
  	struct tusb6010_glue		*glue = platform_get_drvdata(pdev);
  
  	platform_device_unregister(glue->musb);
++<<<<<<< HEAD
++=======
+ 	usb_phy_generic_unregister(glue->phy);
++>>>>>>> 2f36ff6915c6 (usb: phy: generic: allow multiples calls to usb_phy_generic_register())
  	kfree(glue);
  
  	return 0;
diff --cc drivers/usb/phy/phy-nop.c
index 638cc5dade35,7594e5069ae5..000000000000
--- a/drivers/usb/phy/phy-nop.c
+++ b/drivers/usb/phy/phy-nop.c
@@@ -35,35 -35,24 +35,45 @@@
  #include <linux/clk.h>
  #include <linux/regulator/consumer.h>
  #include <linux/of.h>
 -#include <linux/of_gpio.h>
 -#include <linux/gpio.h>
 -#include <linux/delay.h>
  
 -#include "phy-generic.h"
 +struct nop_usb_xceiv {
 +	struct usb_phy phy;
 +	struct device *dev;
 +	struct clk *clk;
 +	struct regulator *vcc;
 +	struct regulator *reset;
 +};
 +
++<<<<<<< HEAD:drivers/usb/phy/phy-nop.c
 +static struct platform_device *pd;
  
 +void usb_nop_xceiv_register(void)
 +{
 +	if (pd)
 +		return;
 +	pd = platform_device_register_simple("nop_usb_xceiv", -1, NULL, 0);
 +	if (!pd) {
 +		printk(KERN_ERR "Unable to register usb nop transceiver\n");
 +		return;
 +	}
++=======
+ struct platform_device *usb_phy_generic_register(void)
+ {
+ 	return platform_device_register_simple("usb_phy_generic",
+ 			PLATFORM_DEVID_AUTO, NULL, 0);
++>>>>>>> 2f36ff6915c6 (usb: phy: generic: allow multiples calls to usb_phy_generic_register()):drivers/usb/phy/phy-generic.c
  }
 -EXPORT_SYMBOL_GPL(usb_phy_generic_register);
 +EXPORT_SYMBOL(usb_nop_xceiv_register);
  
++<<<<<<< HEAD:drivers/usb/phy/phy-nop.c
 +void usb_nop_xceiv_unregister(void)
++=======
+ void usb_phy_generic_unregister(struct platform_device *pdev)
++>>>>>>> 2f36ff6915c6 (usb: phy: generic: allow multiples calls to usb_phy_generic_register()):drivers/usb/phy/phy-generic.c
  {
- 	platform_device_unregister(pd);
- 	pd = NULL;
+ 	platform_device_unregister(pdev);
  }
 -EXPORT_SYMBOL_GPL(usb_phy_generic_unregister);
 +EXPORT_SYMBOL(usb_nop_xceiv_unregister);
  
  static int nop_set_suspend(struct usb_phy *x, int suspend)
  {
diff --cc include/linux/usb/nop-usb-xceiv.h
index 127a0b702dbd,8346bcc50c2f..000000000000
--- a/include/linux/usb/nop-usb-xceiv.h
+++ b/include/linux/usb/nop-usb-xceiv.h
@@@ -15,14 -15,15 +15,26 @@@ struct nop_usb_xceiv_platform_data 
  
  #if defined(CONFIG_NOP_USB_XCEIV) || (defined(CONFIG_NOP_USB_XCEIV_MODULE) && defined(MODULE))
  /* sometimes transceivers are accessed only through e.g. ULPI */
++<<<<<<< HEAD:include/linux/usb/nop-usb-xceiv.h
 +extern void usb_nop_xceiv_register(void);
 +extern void usb_nop_xceiv_unregister(void);
 +#else
 +static inline void usb_nop_xceiv_register(void)
++=======
+ extern struct platform_device *usb_phy_generic_register(void);
+ extern void usb_phy_generic_unregister(struct platform_device *);
+ #else
+ static inline struct platform_device *usb_phy_generic_register(void)
++>>>>>>> 2f36ff6915c6 (usb: phy: generic: allow multiples calls to usb_phy_generic_register()):include/linux/usb/usb_phy_generic.h
  {
+ 	return NULL;
  }
  
++<<<<<<< HEAD:include/linux/usb/nop-usb-xceiv.h
 +static inline void usb_nop_xceiv_unregister(void)
++=======
+ static inline void usb_phy_generic_unregister(struct platform_device *pdev)
++>>>>>>> 2f36ff6915c6 (usb: phy: generic: allow multiples calls to usb_phy_generic_register()):include/linux/usb/usb_phy_generic.h
  {
  }
  #endif
* Unmerged path drivers/usb/musb/am35x.c
* Unmerged path drivers/usb/musb/blackfin.c
* Unmerged path drivers/usb/musb/da8xx.c
* Unmerged path drivers/usb/musb/tusb6010.c
* Unmerged path drivers/usb/phy/phy-nop.c
* Unmerged path include/linux/usb/nop-usb-xceiv.h
