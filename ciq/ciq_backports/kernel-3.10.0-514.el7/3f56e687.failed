perf/core: Disable the event on a truncated AUX record

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Shishkin <alexander.shishkin@linux.intel.com>
commit 3f56e687a138481894a1088d5aa7d41951bdb020
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3f56e687.failed

When the PMU driver reports a truncated AUX record, it effectively means
that there is no more usable room in the event's AUX buffer (even though
there may still be some room, so that perf_aux_output_begin() doesn't take
action). At this point the consumer still has to be woken up and the event
has to be disabled, otherwise the event will just keep spinning between
perf_aux_output_begin() and perf_aux_output_end() until its context gets
unscheduled.

Again, for cpu-wide events this means never, so once in this condition,
they will be forever losing data.

Fix this by disabling the event and waking up the consumer in case of a
truncated AUX record.

	Reported-by: Markus Metzger <markus.t.metzger@intel.com>
	Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
	Cc: vince@deater.net
Link: http://lkml.kernel.org/r/1462886313-13660-3-git-send-email-alexander.shishkin@linux.intel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 3f56e687a138481894a1088d5aa7d41951bdb020)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/ring_buffer.c
diff --cc kernel/events/ring_buffer.c
index ff31cb94ec3e,ae9b90dc9a5a..000000000000
--- a/kernel/events/ring_buffer.c
+++ b/kernel/events/ring_buffer.c
@@@ -241,6 -288,368 +241,371 @@@ ring_buffer_init(struct ring_buffer *rb
  
  	INIT_LIST_HEAD(&rb->event_list);
  	spin_lock_init(&rb->event_lock);
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * perf_output_begin() only checks rb->paused, therefore
+ 	 * rb->paused must be true if we have no pages for output.
+ 	 */
+ 	if (!rb->nr_pages)
+ 		rb->paused = 1;
+ }
+ 
+ /*
+  * This is called before hardware starts writing to the AUX area to
+  * obtain an output handle and make sure there's room in the buffer.
+  * When the capture completes, call perf_aux_output_end() to commit
+  * the recorded data to the buffer.
+  *
+  * The ordering is similar to that of perf_output_{begin,end}, with
+  * the exception of (B), which should be taken care of by the pmu
+  * driver, since ordering rules will differ depending on hardware.
+  *
+  * Call this from pmu::start(); see the comment in perf_aux_output_end()
+  * about its use in pmu callbacks. Both can also be called from the PMI
+  * handler if needed.
+  */
+ void *perf_aux_output_begin(struct perf_output_handle *handle,
+ 			    struct perf_event *event)
+ {
+ 	struct perf_event *output_event = event;
+ 	unsigned long aux_head, aux_tail;
+ 	struct ring_buffer *rb;
+ 
+ 	if (output_event->parent)
+ 		output_event = output_event->parent;
+ 
+ 	/*
+ 	 * Since this will typically be open across pmu::add/pmu::del, we
+ 	 * grab ring_buffer's refcount instead of holding rcu read lock
+ 	 * to make sure it doesn't disappear under us.
+ 	 */
+ 	rb = ring_buffer_get(output_event);
+ 	if (!rb)
+ 		return NULL;
+ 
+ 	if (!rb_has_aux(rb) || !atomic_inc_not_zero(&rb->aux_refcount))
+ 		goto err;
+ 
+ 	/*
+ 	 * If rb::aux_mmap_count is zero (and rb_has_aux() above went through),
+ 	 * the aux buffer is in perf_mmap_close(), about to get freed.
+ 	 */
+ 	if (!atomic_read(&rb->aux_mmap_count))
+ 		goto err_put;
+ 
+ 	/*
+ 	 * Nesting is not supported for AUX area, make sure nested
+ 	 * writers are caught early
+ 	 */
+ 	if (WARN_ON_ONCE(local_xchg(&rb->aux_nest, 1)))
+ 		goto err_put;
+ 
+ 	aux_head = local_read(&rb->aux_head);
+ 
+ 	handle->rb = rb;
+ 	handle->event = event;
+ 	handle->head = aux_head;
+ 	handle->size = 0;
+ 
+ 	/*
+ 	 * In overwrite mode, AUX data stores do not depend on aux_tail,
+ 	 * therefore (A) control dependency barrier does not exist. The
+ 	 * (B) <-> (C) ordering is still observed by the pmu driver.
+ 	 */
+ 	if (!rb->aux_overwrite) {
+ 		aux_tail = ACCESS_ONCE(rb->user_page->aux_tail);
+ 		handle->wakeup = local_read(&rb->aux_wakeup) + rb->aux_watermark;
+ 		if (aux_head - aux_tail < perf_aux_size(rb))
+ 			handle->size = CIRC_SPACE(aux_head, aux_tail, perf_aux_size(rb));
+ 
+ 		/*
+ 		 * handle->size computation depends on aux_tail load; this forms a
+ 		 * control dependency barrier separating aux_tail load from aux data
+ 		 * store that will be enabled on successful return
+ 		 */
+ 		if (!handle->size) { /* A, matches D */
+ 			event->pending_disable = 1;
+ 			perf_output_wakeup(handle);
+ 			local_set(&rb->aux_nest, 0);
+ 			goto err_put;
+ 		}
+ 	}
+ 
+ 	return handle->rb->aux_priv;
+ 
+ err_put:
+ 	/* can't be last */
+ 	rb_free_aux(rb);
+ 
+ err:
+ 	ring_buffer_put(rb);
+ 	handle->event = NULL;
+ 
+ 	return NULL;
+ }
+ 
+ /*
+  * Commit the data written by hardware into the ring buffer by adjusting
+  * aux_head and posting a PERF_RECORD_AUX into the perf buffer. It is the
+  * pmu driver's responsibility to observe ordering rules of the hardware,
+  * so that all the data is externally visible before this is called.
+  *
+  * Note: this has to be called from pmu::stop() callback, as the assumption
+  * of the AUX buffer management code is that after pmu::stop(), the AUX
+  * transaction must be stopped and therefore drop the AUX reference count.
+  */
+ void perf_aux_output_end(struct perf_output_handle *handle, unsigned long size,
+ 			 bool truncated)
+ {
+ 	struct ring_buffer *rb = handle->rb;
+ 	bool wakeup = truncated;
+ 	unsigned long aux_head;
+ 	u64 flags = 0;
+ 
+ 	if (truncated)
+ 		flags |= PERF_AUX_FLAG_TRUNCATED;
+ 
+ 	/* in overwrite mode, driver provides aux_head via handle */
+ 	if (rb->aux_overwrite) {
+ 		flags |= PERF_AUX_FLAG_OVERWRITE;
+ 
+ 		aux_head = handle->head;
+ 		local_set(&rb->aux_head, aux_head);
+ 	} else {
+ 		aux_head = local_read(&rb->aux_head);
+ 		local_add(size, &rb->aux_head);
+ 	}
+ 
+ 	if (size || flags) {
+ 		/*
+ 		 * Only send RECORD_AUX if we have something useful to communicate
+ 		 */
+ 
+ 		perf_event_aux_event(handle->event, aux_head, size, flags);
+ 	}
+ 
+ 	aux_head = rb->user_page->aux_head = local_read(&rb->aux_head);
+ 
+ 	if (aux_head - local_read(&rb->aux_wakeup) >= rb->aux_watermark) {
+ 		wakeup = true;
+ 		local_add(rb->aux_watermark, &rb->aux_wakeup);
+ 	}
+ 
+ 	if (wakeup) {
+ 		if (truncated)
+ 			handle->event->pending_disable = 1;
+ 		perf_output_wakeup(handle);
+ 	}
+ 
+ 	handle->event = NULL;
+ 
+ 	local_set(&rb->aux_nest, 0);
+ 	/* can't be last */
+ 	rb_free_aux(rb);
+ 	ring_buffer_put(rb);
+ }
+ 
+ /*
+  * Skip over a given number of bytes in the AUX buffer, due to, for example,
+  * hardware's alignment constraints.
+  */
+ int perf_aux_output_skip(struct perf_output_handle *handle, unsigned long size)
+ {
+ 	struct ring_buffer *rb = handle->rb;
+ 	unsigned long aux_head;
+ 
+ 	if (size > handle->size)
+ 		return -ENOSPC;
+ 
+ 	local_add(size, &rb->aux_head);
+ 
+ 	aux_head = rb->user_page->aux_head = local_read(&rb->aux_head);
+ 	if (aux_head - local_read(&rb->aux_wakeup) >= rb->aux_watermark) {
+ 		perf_output_wakeup(handle);
+ 		local_add(rb->aux_watermark, &rb->aux_wakeup);
+ 		handle->wakeup = local_read(&rb->aux_wakeup) +
+ 				 rb->aux_watermark;
+ 	}
+ 
+ 	handle->head = aux_head;
+ 	handle->size -= size;
+ 
+ 	return 0;
+ }
+ 
+ void *perf_get_aux(struct perf_output_handle *handle)
+ {
+ 	/* this is only valid between perf_aux_output_begin and *_end */
+ 	if (!handle->event)
+ 		return NULL;
+ 
+ 	return handle->rb->aux_priv;
+ }
+ 
+ #define PERF_AUX_GFP	(GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY)
+ 
+ static struct page *rb_alloc_aux_page(int node, int order)
+ {
+ 	struct page *page;
+ 
+ 	if (order > MAX_ORDER)
+ 		order = MAX_ORDER;
+ 
+ 	do {
+ 		page = alloc_pages_node(node, PERF_AUX_GFP, order);
+ 	} while (!page && order--);
+ 
+ 	if (page && order) {
+ 		/*
+ 		 * Communicate the allocation size to the driver:
+ 		 * if we managed to secure a high-order allocation,
+ 		 * set its first page's private to this order;
+ 		 * !PagePrivate(page) means it's just a normal page.
+ 		 */
+ 		split_page(page, order);
+ 		SetPagePrivate(page);
+ 		set_page_private(page, order);
+ 	}
+ 
+ 	return page;
+ }
+ 
+ static void rb_free_aux_page(struct ring_buffer *rb, int idx)
+ {
+ 	struct page *page = virt_to_page(rb->aux_pages[idx]);
+ 
+ 	ClearPagePrivate(page);
+ 	page->mapping = NULL;
+ 	__free_page(page);
+ }
+ 
+ static void __rb_free_aux(struct ring_buffer *rb)
+ {
+ 	int pg;
+ 
+ 	/*
+ 	 * Should never happen, the last reference should be dropped from
+ 	 * perf_mmap_close() path, which first stops aux transactions (which
+ 	 * in turn are the atomic holders of aux_refcount) and then does the
+ 	 * last rb_free_aux().
+ 	 */
+ 	WARN_ON_ONCE(in_atomic());
+ 
+ 	if (rb->aux_priv) {
+ 		rb->free_aux(rb->aux_priv);
+ 		rb->free_aux = NULL;
+ 		rb->aux_priv = NULL;
+ 	}
+ 
+ 	if (rb->aux_nr_pages) {
+ 		for (pg = 0; pg < rb->aux_nr_pages; pg++)
+ 			rb_free_aux_page(rb, pg);
+ 
+ 		kfree(rb->aux_pages);
+ 		rb->aux_nr_pages = 0;
+ 	}
+ }
+ 
+ int rb_alloc_aux(struct ring_buffer *rb, struct perf_event *event,
+ 		 pgoff_t pgoff, int nr_pages, long watermark, int flags)
+ {
+ 	bool overwrite = !(flags & RING_BUFFER_WRITABLE);
+ 	int node = (event->cpu == -1) ? -1 : cpu_to_node(event->cpu);
+ 	int ret = -ENOMEM, max_order = 0;
+ 
+ 	if (!has_aux(event))
+ 		return -ENOTSUPP;
+ 
+ 	if (event->pmu->capabilities & PERF_PMU_CAP_AUX_NO_SG) {
+ 		/*
+ 		 * We need to start with the max_order that fits in nr_pages,
+ 		 * not the other way around, hence ilog2() and not get_order.
+ 		 */
+ 		max_order = ilog2(nr_pages);
+ 
+ 		/*
+ 		 * PMU requests more than one contiguous chunks of memory
+ 		 * for SW double buffering
+ 		 */
+ 		if ((event->pmu->capabilities & PERF_PMU_CAP_AUX_SW_DOUBLEBUF) &&
+ 		    !overwrite) {
+ 			if (!max_order)
+ 				return -EINVAL;
+ 
+ 			max_order--;
+ 		}
+ 	}
+ 
+ 	rb->aux_pages = kzalloc_node(nr_pages * sizeof(void *), GFP_KERNEL, node);
+ 	if (!rb->aux_pages)
+ 		return -ENOMEM;
+ 
+ 	rb->free_aux = event->pmu->free_aux;
+ 	for (rb->aux_nr_pages = 0; rb->aux_nr_pages < nr_pages;) {
+ 		struct page *page;
+ 		int last, order;
+ 
+ 		order = min(max_order, ilog2(nr_pages - rb->aux_nr_pages));
+ 		page = rb_alloc_aux_page(node, order);
+ 		if (!page)
+ 			goto out;
+ 
+ 		for (last = rb->aux_nr_pages + (1 << page_private(page));
+ 		     last > rb->aux_nr_pages; rb->aux_nr_pages++)
+ 			rb->aux_pages[rb->aux_nr_pages] = page_address(page++);
+ 	}
+ 
+ 	/*
+ 	 * In overwrite mode, PMUs that don't support SG may not handle more
+ 	 * than one contiguous allocation, since they rely on PMI to do double
+ 	 * buffering. In this case, the entire buffer has to be one contiguous
+ 	 * chunk.
+ 	 */
+ 	if ((event->pmu->capabilities & PERF_PMU_CAP_AUX_NO_SG) &&
+ 	    overwrite) {
+ 		struct page *page = virt_to_page(rb->aux_pages[0]);
+ 
+ 		if (page_private(page) != max_order)
+ 			goto out;
+ 	}
+ 
+ 	rb->aux_priv = event->pmu->setup_aux(event->cpu, rb->aux_pages, nr_pages,
+ 					     overwrite);
+ 	if (!rb->aux_priv)
+ 		goto out;
+ 
+ 	ret = 0;
+ 
+ 	/*
+ 	 * aux_pages (and pmu driver's private data, aux_priv) will be
+ 	 * referenced in both producer's and consumer's contexts, thus
+ 	 * we keep a refcount here to make sure either of the two can
+ 	 * reference them safely.
+ 	 */
+ 	atomic_set(&rb->aux_refcount, 1);
+ 
+ 	rb->aux_overwrite = overwrite;
+ 	rb->aux_watermark = watermark;
+ 
+ 	if (!rb->aux_watermark && !rb->aux_overwrite)
+ 		rb->aux_watermark = nr_pages << (PAGE_SHIFT - 1);
+ 
+ out:
+ 	if (!ret)
+ 		rb->aux_pgoff = pgoff;
+ 	else
+ 		__rb_free_aux(rb);
+ 
+ 	return ret;
+ }
+ 
+ void rb_free_aux(struct ring_buffer *rb)
+ {
+ 	if (atomic_dec_and_test(&rb->aux_refcount))
+ 		__rb_free_aux(rb);
++>>>>>>> 3f56e687a138 (perf/core: Disable the event on a truncated AUX record)
  }
  
  #ifndef CONFIG_PERF_USE_VMALLOC
* Unmerged path kernel/events/ring_buffer.c
