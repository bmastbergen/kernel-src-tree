raid5-cache: add journal hot add/remove support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Shaohua Li <shli@fb.com>
commit f6b6ec5cfac306c1eea66f074050864efcb11851
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f6b6ec5c.failed

Add support for journal disk hot add/remove. Mostly trival checks in md
part. The raid5 part is a little tricky. For hot-remove, we can't wait
pending write as it's called from raid5d. The wait will cause deadlock.
We simplily fail the hot-remove. A hot-remove retry can success
eventually since if journal disk is faulty all pending write will be
failed and finish. For hot-add, since an array supporting journal but
without journal disk will be marked read-only, we are safe to hot add
journal without stopping IO (should be read IO, while journal only
handles write IO).

	Signed-off-by: Shaohua Li <shli@fb.com>
	Signed-off-by: NeilBrown <neilb@suse.com>
(cherry picked from commit f6b6ec5cfac306c1eea66f074050864efcb11851)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
diff --cc drivers/md/md.c
index 2c145cdcbc69,c0c3e6dec248..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -5923,12 -6046,58 +5925,48 @@@ static int add_new_disk(struct mddev *m
  		else
  			clear_bit(WriteMostly, &rdev->flags);
  
++<<<<<<< HEAD
++=======
+ 		if (info->state & (1<<MD_DISK_JOURNAL)) {
+ 			struct md_rdev *rdev2;
+ 			bool has_journal = false;
+ 
+ 			/* make sure no existing journal disk */
+ 			rdev_for_each(rdev2, mddev) {
+ 				if (test_bit(Journal, &rdev2->flags)) {
+ 					has_journal = true;
+ 					break;
+ 				}
+ 			}
+ 			if (has_journal) {
+ 				export_rdev(rdev);
+ 				return -EBUSY;
+ 			}
+ 			set_bit(Journal, &rdev->flags);
+ 		}
+ 		/*
+ 		 * check whether the device shows up in other nodes
+ 		 */
+ 		if (mddev_is_clustered(mddev)) {
+ 			if (info->state & (1 << MD_DISK_CANDIDATE))
+ 				set_bit(Candidate, &rdev->flags);
+ 			else if (info->state & (1 << MD_DISK_CLUSTER_ADD)) {
+ 				/* --add initiated by this node */
+ 				err = md_cluster_ops->add_new_disk(mddev, rdev);
+ 				if (err) {
+ 					export_rdev(rdev);
+ 					return err;
+ 				}
+ 			}
+ 		}
+ 
++>>>>>>> f6b6ec5cfac3 (raid5-cache: add journal hot add/remove support)
  		rdev->raid_disk = -1;
  		err = bind_rdev_to_array(rdev, mddev);
 -
  		if (err)
  			export_rdev(rdev);
 -
 -		if (mddev_is_clustered(mddev)) {
 -			if (info->state & (1 << MD_DISK_CANDIDATE))
 -				md_cluster_ops->new_disk_ack(mddev, (err == 0));
 -			else {
 -				if (err)
 -					md_cluster_ops->add_new_disk_cancel(mddev);
 -				else
 -					err = add_bound_rdev(rdev);
 -			}
 -
 -		} else if (!err)
 +		else
  			err = add_bound_rdev(rdev);
 -
  		return err;
  	}
  
@@@ -7905,12 -8198,14 +7943,21 @@@ static int remove_and_add_spares(struc
  			continue;
  		if (test_bit(Faulty, &rdev->flags))
  			continue;
++<<<<<<< HEAD
 +		if (mddev->ro &&
 +		    ! (rdev->saved_raid_disk >= 0 &&
 +		       !test_bit(Bitmap_sync, &rdev->flags)))
 +			continue;
++=======
+ 		if (!test_bit(Journal, &rdev->flags)) {
+ 			if (mddev->ro &&
+ 			    ! (rdev->saved_raid_disk >= 0 &&
+ 			       !test_bit(Bitmap_sync, &rdev->flags)))
+ 				continue;
++>>>>>>> f6b6ec5cfac3 (raid5-cache: add journal hot add/remove support)
  
- 		rdev->recovery_offset = 0;
+ 			rdev->recovery_offset = 0;
+ 		}
  		if (mddev->pers->
  		    hot_add_disk(mddev, rdev) == 0) {
  			if (sysfs_link_rdev(mddev, rdev))
* Unmerged path drivers/md/md.c
diff --git a/drivers/md/raid5-cache.c b/drivers/md/raid5-cache.c
index d81461835099..ba7572e07e40 100644
--- a/drivers/md/raid5-cache.c
+++ b/drivers/md/raid5-cache.c
@@ -810,10 +810,18 @@ void r5l_quiesce(struct r5l_log *log, int state)
 
 bool r5l_log_disk_error(struct r5conf *conf)
 {
+	struct r5l_log *log;
+	bool ret;
 	/* don't allow write if journal disk is missing */
-	if (!conf->log)
-		return test_bit(MD_HAS_JOURNAL, &conf->mddev->flags);
-	return test_bit(Faulty, &conf->log->rdev->flags);
+	rcu_read_lock();
+	log = rcu_dereference(conf->log);
+
+	if (!log)
+		ret = test_bit(MD_HAS_JOURNAL, &conf->mddev->flags);
+	else
+		ret = test_bit(Faulty, &log->rdev->flags);
+	rcu_read_unlock();
+	return ret;
 }
 
 struct r5l_recovery_ctx {
@@ -1176,7 +1184,7 @@ int r5l_init_log(struct r5conf *conf, struct md_rdev *rdev)
 	if (r5l_load_log(log))
 		goto error;
 
-	conf->log = log;
+	rcu_assign_pointer(conf->log, log);
 	return 0;
 error:
 	md_unregister_thread(&log->reclaim_thread);
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index 823afab2352b..e70d2eae356c 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -7048,14 +7048,19 @@ static int raid5_remove_disk(struct mddev *mddev, struct md_rdev *rdev)
 	struct disk_info *p = conf->disks + number;
 
 	print_raid5_conf(conf);
-	if (test_bit(Journal, &rdev->flags)) {
+	if (test_bit(Journal, &rdev->flags) && conf->log) {
+		struct r5l_log *log;
 		/*
-		 * journal disk is not removable, but we need give a chance to
-		 * update superblock of other disks. Otherwise journal disk
-		 * will be considered as 'fresh'
+		 * we can't wait pending write here, as this is called in
+		 * raid5d, wait will deadlock.
 		 */
-		set_bit(MD_CHANGE_DEVS, &mddev->flags);
-		return -EINVAL;
+		if (atomic_read(&mddev->writes_pending))
+			return -EBUSY;
+		log = conf->log;
+		conf->log = NULL;
+		synchronize_rcu();
+		r5l_exit_log(log);
+		return 0;
 	}
 	if (rdev == p->rdev)
 		rdevp = &p->rdev;
@@ -7119,8 +7124,21 @@ static int raid5_add_disk(struct mddev *mddev, struct md_rdev *rdev)
 	int first = 0;
 	int last = conf->raid_disks - 1;
 
-	if (test_bit(Journal, &rdev->flags))
-		return -EINVAL;
+	if (test_bit(Journal, &rdev->flags)) {
+		char b[BDEVNAME_SIZE];
+		if (conf->log)
+			return -EBUSY;
+
+		rdev->raid_disk = 0;
+		/*
+		 * The array is in readonly mode if journal is missing, so no
+		 * write requests running. We should be safe
+		 */
+		r5l_init_log(conf, rdev);
+		printk(KERN_INFO"md/raid:%s: using device %s as journal\n",
+		       mdname(mddev), bdevname(rdev->bdev, b));
+		return 0;
+	}
 	if (mddev->recovery_disabled == conf->recovery_disabled)
 		return -EBUSY;
 
