nfs: centralize pgio error cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peng Tao <tao.peng@primarydata.com>
commit 2bff2288579f1e4af2f05a7f7443c85b7766d5ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2bff2288.failed

In case we fail during setting things up for read/write IO, set
pg_error in IO descriptor and do the cleanup in nfs_pageio_add_request,
where we clean up all pages that are still hanging around on the IO
descriptor.

	Signed-off-by: Peng Tao <tao.peng@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 2bff2288579f1e4af2f05a7f7443c85b7766d5ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pagelist.c
diff --cc fs/nfs/pagelist.c
index e9e1ba73f39d,7c71b71016b5..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -1185,6 -1181,28 +1178,31 @@@ int nfs_pageio_add_request(struct nfs_p
  	}
  
  	return 1;
++<<<<<<< HEAD
++=======
+ 
+ out_failed:
+ 	/*
+ 	 * We might have failed before sending any reqs over wire.
+ 	 * Clean up rest of the reqs in mirror pg_list.
+ 	 */
+ 	if (desc->pg_error) {
+ 		struct nfs_pgio_mirror *mirror;
+ 		void (*func)(struct list_head *);
+ 
+ 		/* remember fatal errors */
+ 		if (nfs_error_is_fatal(desc->pg_error))
+ 			mapping_set_error(desc->pg_inode->i_mapping,
+ 					  desc->pg_error);
+ 
+ 		func = desc->pg_completion_ops->error_cleanup;
+ 		for (midx = 0; midx < desc->pg_mirror_count; midx++) {
+ 			mirror = &desc->pg_mirrors[midx];
+ 			func(&mirror->pg_list);
+ 		}
+ 	}
+ 	return 0;
++>>>>>>> 2bff2288579f (nfs: centralize pgio error cleanup)
  }
  
  /*
* Unmerged path fs/nfs/pagelist.c
diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c
index 8e2d6c267509..38c117f486ac 100644
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@ -1954,15 +1954,13 @@ static void pnfs_writehdr_free(struct nfs_pgio_header *hdr)
 int
 pnfs_generic_pg_writepages(struct nfs_pageio_descriptor *desc)
 {
-	struct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);
-
 	struct nfs_pgio_header *hdr;
 	int ret;
 
 	hdr = nfs_pgio_header_alloc(desc->pg_rw_ops);
 	if (!hdr) {
-		desc->pg_completion_ops->error_cleanup(&mirror->pg_list);
-		return -ENOMEM;
+		desc->pg_error = -ENOMEM;
+		return desc->pg_error;
 	}
 	nfs_pgheader_init(desc, hdr, pnfs_writehdr_free);
 
@@ -2085,15 +2083,13 @@ static void pnfs_readhdr_free(struct nfs_pgio_header *hdr)
 int
 pnfs_generic_pg_readpages(struct nfs_pageio_descriptor *desc)
 {
-	struct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);
-
 	struct nfs_pgio_header *hdr;
 	int ret;
 
 	hdr = nfs_pgio_header_alloc(desc->pg_rw_ops);
 	if (!hdr) {
-		desc->pg_completion_ops->error_cleanup(&mirror->pg_list);
-		return -ENOMEM;
+		desc->pg_error = -ENOMEM;
+		return desc->pg_error;
 	}
 	nfs_pgheader_init(desc, hdr, pnfs_readhdr_free);
 	hdr->lseg = pnfs_get_lseg(desc->pg_lseg);
