hv_netvsc: use skb_get_hash() instead of a homegrown implementation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 757647e10e55c01fb7a9c4356529442e316a7c72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/757647e1.failed

Recent changes to 'struct flow_keys' (e.g commit d34af823ff40 ("net: Add
VLAN ID to flow_keys")) introduced a performance regression in netvsc
driver. Is problem is, however, not the above mentioned commit but the
fact that netvsc_set_hash() function did some assumptions on the struct
flow_keys data layout and this is wrong.

Get rid of netvsc_set_hash() by switching to skb_get_hash(). This change
will also imply switching to Jenkins hash from the currently used Toeplitz
but it seems there is no good excuse for Toeplitz to stay.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 757647e10e55c01fb7a9c4356529442e316a7c72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index 56b76b7b9a27,1d3a66563bac..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -191,66 -196,8 +191,71 @@@ static void *init_ppi_data(struct rndis
  	return ppi;
  }
  
++<<<<<<< HEAD
 +union sub_key {
 +	u64 k;
 +	struct {
 +		u8 pad[3];
 +		u8 kb;
 +		u32 ka;
 +	};
 +};
 +
 +/* Toeplitz hash function
 + * data: network byte order
 + * return: host byte order
 + */
 +static u32 comp_hash(u8 *key, int klen, void *data, int dlen)
 +{
 +	union sub_key subk;
 +	int k_next = 4;
 +	u8 dt;
 +	int i, j;
 +	u32 ret = 0;
 +
 +	subk.k = 0;
 +	subk.ka = ntohl(*(u32 *)key);
 +
 +	for (i = 0; i < dlen; i++) {
 +		subk.kb = key[k_next];
 +		k_next = (k_next + 1) % klen;
 +		dt = ((u8 *)data)[i];
 +		for (j = 0; j < 8; j++) {
 +			if (dt & 0x80)
 +				ret ^= subk.ka;
 +			dt <<= 1;
 +			subk.k <<= 1;
 +		}
 +	}
 +
 +	return ret;
 +}
 +
 +static bool netvsc_set_hash(u32 *hash, struct sk_buff *skb)
 +{
 +	struct flow_keys flow;
 +	int data_len;
 +
 +	if (!skb_flow_dissect(skb, &flow) ||
 +	    !(flow.n_proto == htons(ETH_P_IP) ||
 +	      flow.n_proto == htons(ETH_P_IPV6)))
 +		return false;
 +
 +	if (flow.ip_proto == IPPROTO_TCP)
 +		data_len = 12;
 +	else
 +		data_len = 8;
 +
 +	*hash = comp_hash(netvsc_hash_key, HASH_KEYLEN, &flow, data_len);
 +
 +	return true;
 +}
 +
 +static u16 netvsc_select_queue(struct net_device *ndev, struct sk_buff *skb)
++=======
+ static u16 netvsc_select_queue(struct net_device *ndev, struct sk_buff *skb,
+ 			void *accel_priv, select_queue_fallback_t fallback)
++>>>>>>> 757647e10e55 (hv_netvsc: use skb_get_hash() instead of a homegrown implementation)
  {
  	struct net_device_context *net_device_ctx = netdev_priv(ndev);
  	struct hv_device *hdev =  net_device_ctx->device_ctx;
@@@ -261,12 -208,13 +266,10 @@@
  	if (nvsc_dev == NULL || ndev->real_num_tx_queues <= 1)
  		return 0;
  
- 	if (netvsc_set_hash(&hash, skb)) {
- 		q_idx = nvsc_dev->send_table[hash % VRSS_SEND_TAB_SIZE] %
- 			ndev->real_num_tx_queues;
- 		skb_set_hash(skb, hash, PKT_HASH_TYPE_L3);
- 	}
+ 	hash = skb_get_hash(skb);
+ 	q_idx = nvsc_dev->send_table[hash % VRSS_SEND_TAB_SIZE] %
+ 		ndev->real_num_tx_queues;
  
 -	if (!nvsc_dev->chn_table[q_idx])
 -		q_idx = 0;
 -
  	return q_idx;
  }
  
* Unmerged path drivers/net/hyperv/netvsc_drv.c
