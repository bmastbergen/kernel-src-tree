ovl: handle ATTR_KILL*

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit b99c2d913810e56682a538c9f2394d76fca808f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b99c2d91.failed

Before 4bacc9c9234c ("overlayfs: Make f_path...") file->f_path pointed to
the underlying file, hence suid/sgid removal on write worked fine.

After that patch file->f_path pointed to the overlay file, and the file
mode bits weren't copied to overlay_inode->i_mode.  So the suid/sgid
removal simply stopped working.

The fix is to copy the mode bits, but then ovl_setattr() needs to clear
ATTR_MODE to avoid the BUG() in notify_change().  So do this first, then in
the next patch copy the mode.

	Reported-by: Eryu Guan <eguan@redhat.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Fixes: 4bacc9c9234c ("overlayfs: Make f_path always point to the overlay and f_inode to the underlay")
	Cc: <stable@vger.kernel.org>
(cherry picked from commit b99c2d913810e56682a538c9f2394d76fca808f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/inode.c
diff --cc fs/overlayfs/inode.c
index fadb018e83fe,1233992a7c47..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -49,14 -59,40 +49,28 @@@ int ovl_setattr(struct dentry *dentry, 
  	if (err)
  		goto out;
  
 -	if (attr->ia_valid & ATTR_SIZE) {
 -		struct inode *realinode = d_inode(ovl_dentry_real(dentry));
 -
 -		err = -ETXTBSY;
 -		if (atomic_read(&realinode->i_writecount) < 0)
 -			goto out_drop_write;
 -	}
 -
  	err = ovl_copy_up(dentry);
  	if (!err) {
 -		struct inode *winode = NULL;
 -
  		upperdentry = ovl_dentry_upper(dentry);
  
++<<<<<<< HEAD
 +		mutex_lock(&upperdentry->d_inode->i_mutex);
++=======
+ 		if (attr->ia_valid & ATTR_SIZE) {
+ 			winode = d_inode(upperdentry);
+ 			err = get_write_access(winode);
+ 			if (err)
+ 				goto out_drop_write;
+ 		}
+ 
+ 		if (attr->ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID))
+ 			attr->ia_valid &= ~ATTR_MODE;
+ 
+ 		inode_lock(upperdentry->d_inode);
++>>>>>>> b99c2d913810 (ovl: handle ATTR_KILL*)
  		err = notify_change(upperdentry, attr, NULL);
 -		if (!err)
 -			ovl_copyattr(upperdentry->d_inode, dentry->d_inode);
 -		inode_unlock(upperdentry->d_inode);
 -
 -		if (winode)
 -			put_write_access(winode);
 +		mutex_unlock(&upperdentry->d_inode->i_mutex);
  	}
 -out_drop_write:
  	ovl_drop_write(dentry);
  out:
  	return err;
* Unmerged path fs/overlayfs/inode.c
