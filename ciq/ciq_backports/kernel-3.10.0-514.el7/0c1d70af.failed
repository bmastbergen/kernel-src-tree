net: use dst_cache for vxlan device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] use dst_cache for vxlan device (Jiri Benc) [1323141]
Rebuild_FUZZ: 92.31%
commit-author Paolo Abeni <pabeni@redhat.com>
commit 0c1d70af924b966cc71e9e48920b2b635441aa50
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0c1d70af.failed

In case of UDP traffic with datagram length
below MTU this give about 3% performance increase
when tunneling over ipv4 and about 70% when
tunneling over ipv6.

	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Suggested-and-acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0c1d70af924b966cc71e9e48920b2b635441aa50)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
#	include/net/vxlan.h
diff --cc drivers/net/vxlan.c
index 000e4c57a81e,ad673037bd73..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1737,14 -1759,82 +1747,92 @@@ static int vxlan6_xmit_skb(struct dst_e
  		vxlan_build_gbp_hdr(vxh, vxflags, md);
  
  	skb_set_inner_protocol(skb, htons(ETH_P_TEB));
 +
 +	udp_tunnel6_xmit_skb(dst, sk, skb, dev, saddr, daddr, prio,
 +			     ttl, src_port, dst_port,
 +			     !!(vxflags & VXLAN_F_UDP_ZERO_CSUM6_TX));
  	return 0;
++<<<<<<< HEAD
 +err:
 +	dst_release(dst);
 +	return err;
++=======
+ }
+ 
+ static struct rtable *vxlan_get_route(struct vxlan_dev *vxlan,
+ 				      struct sk_buff *skb, int oif, u8 tos,
+ 				      __be32 daddr, __be32 *saddr,
+ 				      struct dst_cache *dst_cache,
+ 				      struct ip_tunnel_info *info)
+ {
+ 	struct rtable *rt = NULL;
+ 	bool use_cache = false;
+ 	struct flowi4 fl4;
+ 
+ 	/* when the ip_tunnel_info is availble, the tos used for lookup is
+ 	 * packet independent, so we can use the cache
+ 	 */
+ 	if (dst_cache && !skb->mark && (!tos || info)) {
+ 		use_cache = true;
+ 		rt = dst_cache_get_ip4(dst_cache, saddr);
+ 		if (rt)
+ 			return rt;
+ 	}
+ 
+ 	memset(&fl4, 0, sizeof(fl4));
+ 	fl4.flowi4_oif = oif;
+ 	fl4.flowi4_tos = RT_TOS(tos);
+ 	fl4.flowi4_mark = skb->mark;
+ 	fl4.flowi4_proto = IPPROTO_UDP;
+ 	fl4.daddr = daddr;
+ 	fl4.saddr = vxlan->cfg.saddr.sin.sin_addr.s_addr;
+ 
+ 	rt = ip_route_output_key(vxlan->net, &fl4);
+ 	if (!IS_ERR(rt)) {
+ 		*saddr = fl4.saddr;
+ 		if (use_cache)
+ 			dst_cache_set_ip4(dst_cache, &rt->dst, fl4.saddr);
+ 	}
+ 	return rt;
+ }
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static struct dst_entry *vxlan6_get_route(struct vxlan_dev *vxlan,
+ 					  struct sk_buff *skb, int oif,
+ 					  const struct in6_addr *daddr,
+ 					  struct in6_addr *saddr,
+ 					  struct dst_cache *dst_cache)
+ {
+ 	bool use_cache = false;
+ 	struct dst_entry *ndst;
+ 	struct flowi6 fl6;
+ 	int err;
+ 
+ 	if (dst_cache && !skb->mark) {
+ 		use_cache = true;
+ 		ndst = dst_cache_get_ip6(dst_cache, saddr);
+ 		if (ndst)
+ 			return ndst;
+ 	}
+ 
+ 	memset(&fl6, 0, sizeof(fl6));
+ 	fl6.flowi6_oif = oif;
+ 	fl6.daddr = *daddr;
+ 	fl6.saddr = vxlan->cfg.saddr.sin6.sin6_addr;
+ 	fl6.flowi6_mark = skb->mark;
+ 	fl6.flowi6_proto = IPPROTO_UDP;
+ 
+ 	err = ipv6_stub->ipv6_dst_lookup(vxlan->net,
+ 					 vxlan->vn6_sock->sock->sk,
+ 					 &ndst, &fl6);
+ 	if (err < 0)
+ 		return ERR_PTR(err);
+ 
+ 	*saddr = fl6.saddr;
+ 	if (use_cache)
+ 		dst_cache_set_ip6(dst_cache, ndst, saddr);
+ 	return ndst;
++>>>>>>> 0c1d70af924b (net: use dst_cache for vxlan device)
  }
  #endif
  
@@@ -1907,19 -1945,38 +1995,37 @@@ static void vxlan_xmit_one(struct sk_bu
  	if (tos == 1)
  		tos = ip_tunnel_get_dsfield(old_iph, skb);
  
 -	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
 -				     vxlan->cfg.port_max, true);
 -
 -	if (info) {
 -		ttl = info->key.ttl;
 -		tos = info->key.tos;
 -		udp_sum = !!(info->key.tun_flags & TUNNEL_CSUM);
 -
 -		if (info->options_len)
 -			md = ip_tunnel_info_opts(info);
 -	} else {
 -		md->gbp = skb->mark;
 -	}
 +	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->port_min,
 +				     vxlan->port_max, true);
  
  	if (dst->sa.sa_family == AF_INET) {
 -		__be32 saddr;
 -
 +		memset(&fl4, 0, sizeof(fl4));
 +		fl4.flowi4_oif = rdst->remote_ifindex;
 +		fl4.flowi4_tos = RT_TOS(tos);
 +		fl4.flowi4_mark = skb->mark;
 +		fl4.flowi4_proto = IPPROTO_UDP;
 +		fl4.daddr = dst->sin.sin_addr.s_addr;
 +		fl4.saddr = vxlan->saddr.sin.sin_addr.s_addr;
 +
++<<<<<<< HEAD
 +		rt = ip_route_output_key(vxlan->net, &fl4);
++=======
+ 		if (!vxlan->vn4_sock)
+ 			goto drop;
+ 		sk = vxlan->vn4_sock->sock->sk;
+ 
+ 		if (info) {
+ 			if (info->key.tun_flags & TUNNEL_DONT_FRAGMENT)
+ 				df = htons(IP_DF);
+ 		} else {
+ 			udp_sum = !!(flags & VXLAN_F_UDP_CSUM);
+ 		}
+ 
+ 		rt = vxlan_get_route(vxlan, skb,
+ 				     rdst ? rdst->remote_ifindex : 0, tos,
+ 				     dst->sin.sin_addr.s_addr, &saddr,
+ 				     rdst ? &rdst->dst_cache : NULL, info);
++>>>>>>> 0c1d70af924b (net: use dst_cache for vxlan device)
  		if (IS_ERR(rt)) {
  			netdev_dbg(dev, "no route to %pI4\n",
  				   &dst->sin.sin_addr.s_addr);
@@@ -1969,17 -2019,18 +2075,25 @@@
  #if IS_ENABLED(CONFIG_IPV6)
  	} else {
  		struct dst_entry *ndst;
 -		struct in6_addr saddr;
 +		struct flowi6 fl6;
  		u32 rt6i_flags;
  
 -		if (!vxlan->vn6_sock)
 -			goto drop;
 -		sk = vxlan->vn6_sock->sock->sk;
 +		memset(&fl6, 0, sizeof(fl6));
 +		fl6.flowi6_oif = rdst->remote_ifindex;
 +		fl6.daddr = dst->sin6.sin6_addr;
 +		fl6.saddr = vxlan->saddr.sin6.sin6_addr;
 +		fl6.flowi6_mark = skb->mark;
 +		fl6.flowi6_proto = IPPROTO_UDP;
  
++<<<<<<< HEAD
 +		if (ipv6_stub->ipv6_dst_lookup(sk, &ndst, &fl6)) {
++=======
+ 		ndst = vxlan6_get_route(vxlan, skb,
+ 					rdst ? rdst->remote_ifindex : 0,
+ 					&dst->sin6.sin6_addr, &saddr,
+ 					rdst ? &rdst->dst_cache : NULL);
+ 		if (IS_ERR(ndst)) {
++>>>>>>> 0c1d70af924b (net: use dst_cache for vxlan device)
  			netdev_dbg(dev, "no route to %pI6\n",
  				   &dst->sin6.sin6_addr);
  			dev->stats.tx_carrier_errors++;
@@@ -2295,13 -2353,46 +2409,53 @@@ static int __vxlan_change_mtu(struct ne
  	return 0;
  }
  
 -static int vxlan_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
 +static int vxlan_change_mtu(struct net_device *dev, int new_mtu)
  {
  	struct vxlan_dev *vxlan = netdev_priv(dev);
++<<<<<<< HEAD
 +	struct vxlan_rdst *dst = &vxlan->default_dst;
 +	struct net_device *lowerdev = __dev_get_by_index(vxlan->net,
 +							 dst->remote_ifindex);
 +	return __vxlan_change_mtu(dev, lowerdev, dst, new_mtu, true);
++=======
+ 	struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 	__be16 sport, dport;
+ 
+ 	sport = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
+ 				  vxlan->cfg.port_max, true);
+ 	dport = info->key.tp_dst ? : vxlan->cfg.dst_port;
+ 
+ 	if (ip_tunnel_info_af(info) == AF_INET) {
+ 		struct rtable *rt;
+ 
+ 		if (!vxlan->vn4_sock)
+ 			return -EINVAL;
+ 		rt = vxlan_get_route(vxlan, skb, 0, info->key.tos,
+ 				     info->key.u.ipv4.dst,
+ 				     &info->key.u.ipv4.src, NULL, info);
+ 		if (IS_ERR(rt))
+ 			return PTR_ERR(rt);
+ 		ip_rt_put(rt);
+ 	} else {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		struct dst_entry *ndst;
+ 
+ 		if (!vxlan->vn6_sock)
+ 			return -EINVAL;
+ 		ndst = vxlan6_get_route(vxlan, skb, 0,
+ 					&info->key.u.ipv6.dst,
+ 					&info->key.u.ipv6.src, NULL);
+ 		if (IS_ERR(ndst))
+ 			return PTR_ERR(ndst);
+ 		dst_release(ndst);
+ #else /* !CONFIG_IPV6 */
+ 		return -EPFNOSUPPORT;
+ #endif
+ 	}
+ 	info->key.tp_src = sport;
+ 	info->key.tp_dst = dport;
+ 	return 0;
++>>>>>>> 0c1d70af924b (net: use dst_cache for vxlan device)
  }
  
  static const struct net_device_ops vxlan_netdev_ops = {
diff --cc include/net/vxlan.h
index b3828bd87f8a,b314e4af89c5..000000000000
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@@ -114,6 -135,62 +114,65 @@@ struct vxlan_sock 
  	u32		  flags;
  };
  
++<<<<<<< HEAD
++=======
+ union vxlan_addr {
+ 	struct sockaddr_in sin;
+ 	struct sockaddr_in6 sin6;
+ 	struct sockaddr sa;
+ };
+ 
+ struct vxlan_rdst {
+ 	union vxlan_addr	 remote_ip;
+ 	__be16			 remote_port;
+ 	u32			 remote_vni;
+ 	u32			 remote_ifindex;
+ 	struct list_head	 list;
+ 	struct rcu_head		 rcu;
+ 	struct dst_cache	 dst_cache;
+ };
+ 
+ struct vxlan_config {
+ 	union vxlan_addr	remote_ip;
+ 	union vxlan_addr	saddr;
+ 	u32			vni;
+ 	int			remote_ifindex;
+ 	int			mtu;
+ 	__be16			dst_port;
+ 	u16			port_min;
+ 	u16			port_max;
+ 	u8			tos;
+ 	u8			ttl;
+ 	u32			flags;
+ 	unsigned long		age_interval;
+ 	unsigned int		addrmax;
+ 	bool			no_share;
+ };
+ 
+ /* Pseudo network device */
+ struct vxlan_dev {
+ 	struct hlist_node hlist;	/* vni hash table */
+ 	struct list_head  next;		/* vxlan's per namespace list */
+ 	struct vxlan_sock *vn4_sock;	/* listening socket for IPv4 */
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	struct vxlan_sock *vn6_sock;	/* listening socket for IPv6 */
+ #endif
+ 	struct net_device *dev;
+ 	struct net	  *net;		/* netns for packet i/o */
+ 	struct vxlan_rdst default_dst;	/* default destination */
+ 	u32		  flags;	/* VXLAN_F_* in vxlan.h */
+ 
+ 	struct timer_list age_timer;
+ 	spinlock_t	  hash_lock;
+ 	unsigned int	  addrcnt;
+ 	struct gro_cells  gro_cells;
+ 
+ 	struct vxlan_config	cfg;
+ 
+ 	struct hlist_head fdb_head[FDB_HASH_SIZE];
+ };
+ 
++>>>>>>> 0c1d70af924b (net: use dst_cache for vxlan device)
  #define VXLAN_F_LEARN			0x01
  #define VXLAN_F_PROXY			0x02
  #define VXLAN_F_RSC			0x04
* Unmerged path drivers/net/vxlan.c
* Unmerged path include/net/vxlan.h
