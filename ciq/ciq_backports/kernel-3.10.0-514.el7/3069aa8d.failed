md: override md superblock recovery_offset for journal device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [md] override md superblock recovery_offset for journal device (Jes Sorensen) [1250578 1265947 1273343 1299140 1307091 1312828 1320563 1340839]
Rebuild_FUZZ: 96.61%
commit-author Shaohua Li <shli@fb.com>
commit 3069aa8def32b0c2b83cd27d1c37ed30b47ce879
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3069aa8d.failed

Journal device stores data in a log structure. We need record the log
start. Here we override md superblock recovery_offset for this purpose.
This field of a journal device is meaningless otherwise.

	Signed-off-by: Shaohua Li <shli@fb.com>
	Signed-off-by: NeilBrown <neilb@suse.com>
(cherry picked from commit 3069aa8def32b0c2b83cd27d1c37ed30b47ce879)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
diff --cc drivers/md/md.c
index 09cc33b8b337,3592beb6931e..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -1656,6 -1638,16 +1656,19 @@@ static int super_1_validate(struct mdde
  		case MD_DISK_ROLE_FAULTY: /* faulty */
  			set_bit(Faulty, &rdev->flags);
  			break;
++<<<<<<< HEAD
++=======
+ 		case MD_DISK_ROLE_JOURNAL: /* journal device */
+ 			if (!(le32_to_cpu(sb->feature_map) & MD_FEATURE_JOURNAL)) {
+ 				/* journal device without journal feature */
+ 				printk(KERN_WARNING
+ 				  "md: journal device provided without journal feature, ignoring the device\n");
+ 				return -EINVAL;
+ 			}
+ 			set_bit(Journal, &rdev->flags);
+ 			rdev->journal_tail = le64_to_cpu(sb->journal_tail);
+ 			break;
++>>>>>>> 3069aa8def32 (md: override md superblock recovery_offset for journal device)
  		default:
  			rdev->saved_raid_disk = role;
  			if ((le32_to_cpu(sb->feature_map) &
* Unmerged path drivers/md/md.c
diff --git a/drivers/md/md.h b/drivers/md/md.h
index f8d82442ce8b..30025072541e 100644
--- a/drivers/md/md.h
+++ b/drivers/md/md.h
@@ -85,10 +85,16 @@ struct md_rdev {
 					 * array and could again if we did a partial
 					 * resync from the bitmap
 					 */
-	sector_t	recovery_offset;/* If this device has been partially
+	union {
+		sector_t recovery_offset;/* If this device has been partially
 					 * recovered, this is where we were
 					 * up to.
 					 */
+		sector_t journal_tail;	/* If this device is a journal device,
+					 * this is the journal tail (journal
+					 * recovery start point)
+					 */
+	};
 
 	atomic_t	nr_pending;	/* number of pending requests.
 					 * only maintained for arrays that
diff --git a/include/uapi/linux/raid/md_p.h b/include/uapi/linux/raid/md_p.h
index 2b8150485007..53c1432addd9 100644
--- a/include/uapi/linux/raid/md_p.h
+++ b/include/uapi/linux/raid/md_p.h
@@ -248,7 +248,10 @@ struct mdp_superblock_1 {
 	__le64	data_offset;	/* sector start of data, often 0 */
 	__le64	data_size;	/* sectors in this device that can be used for data */
 	__le64	super_offset;	/* sector start of this superblock */
-	__le64	recovery_offset;/* sectors before this offset (from data_offset) have been recovered */
+	union {
+		__le64	recovery_offset;/* sectors before this offset (from data_offset) have been recovered */
+		__le64	journal_tail;/* journal tail of journal device (from data_offset) */
+	};
 	__le32	dev_number;	/* permanent identifier of this  device - not role in raid */
 	__le32	cnt_corrected_read; /* number of read errors that were corrected by re-writing */
 	__u8	device_uuid[16]; /* user-space setable, ignored by kernel */
