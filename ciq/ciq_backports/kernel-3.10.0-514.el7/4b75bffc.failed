mmc: core: Fix error paths and messages in mmc_init_card

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] core: Fix error paths and messages in mmc_init_card (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 95.33%
commit-author Andrew Gabbasov <andrew_gabbasov@mentor.com>
commit 4b75bffc77c40ac3c17a3ea9bbdc3a733c34591b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4b75bffc.failed

In mmc_init_card function some of the branches in error handling paths
go to "err" label, which skips removing of newly allocated card structure,
that will actually not be used. Fix that by using proper "free_card" label.

Also, some messages in these branches are reported as warnings,
although the operation processing is not continued. Change these
messages to error level.

	Signed-off-by: Andrew Gabbasov <andrew_gabbasov@mentor.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 4b75bffc77c40ac3c17a3ea9bbdc3a733c34591b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/mmc.c
diff --cc drivers/mmc/core/mmc.c
index b5e112ab86f3,bcde451f6d91..000000000000
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@@ -889,27 -932,314 +889,322 @@@ static int mmc_select_hs200(struct mmc_
  		if (err)
  			continue;
  
 -		bus_width = bus_widths[idx];
 -		mmc_set_bus_width(host, bus_width);
 +		mmc_set_bus_width(card->host, bus_widths[idx]);
  
 -		/*
 -		 * If controller can't handle bus width test,
 -		 * compare ext_csd previously read in 1 bit mode
 -		 * against ext_csd at new bus width
 -		 */
  		if (!(host->caps & MMC_CAP_BUS_WIDTH_TEST))
 -			err = mmc_compare_ext_csds(card, bus_width);
 +			err = mmc_compare_ext_csds(card, bus_widths[idx]);
  		else
++<<<<<<< HEAD
 +			err = mmc_bus_test(card, bus_widths[idx]);
++=======
+ 			err = mmc_bus_test(card, bus_width);
+ 
+ 		if (!err) {
+ 			err = bus_width;
+ 			break;
+ 		} else {
+ 			pr_warn("%s: switch to bus width %d failed\n",
+ 				mmc_hostname(host), ext_csd_bits[idx]);
+ 		}
+ 	}
+ 
+ 	return err;
+ }
+ 
+ /*
+  * Switch to the high-speed mode
+  */
+ static int mmc_select_hs(struct mmc_card *card)
+ {
+ 	int err;
+ 
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS,
+ 			   card->ext_csd.generic_cmd6_time,
+ 			   true, true, true);
+ 	if (!err)
+ 		mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
+ 
+ 	return err;
+ }
+ 
+ /*
+  * Activate wide bus and DDR if supported.
+  */
+ static int mmc_select_hs_ddr(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	u32 bus_width, ext_csd_bits;
+ 	int err = 0;
+ 
+ 	if (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_52))
+ 		return 0;
+ 
+ 	bus_width = host->ios.bus_width;
+ 	if (bus_width == MMC_BUS_WIDTH_1)
+ 		return 0;
+ 
+ 	ext_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?
+ 		EXT_CSD_DDR_BUS_WIDTH_8 : EXT_CSD_DDR_BUS_WIDTH_4;
+ 
+ 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			EXT_CSD_BUS_WIDTH,
+ 			ext_csd_bits,
+ 			card->ext_csd.generic_cmd6_time);
+ 	if (err) {
+ 		pr_err("%s: switch to bus width %d ddr failed\n",
+ 			mmc_hostname(host), 1 << bus_width);
+ 		return err;
+ 	}
+ 
+ 	/*
+ 	 * eMMC cards can support 3.3V to 1.2V i/o (vccq)
+ 	 * signaling.
+ 	 *
+ 	 * EXT_CSD_CARD_TYPE_DDR_1_8V means 3.3V or 1.8V vccq.
+ 	 *
+ 	 * 1.8V vccq at 3.3V core voltage (vcc) is not required
+ 	 * in the JEDEC spec for DDR.
+ 	 *
+ 	 * Even (e)MMC card can support 3.3v to 1.2v vccq, but not all
+ 	 * host controller can support this, like some of the SDHCI
+ 	 * controller which connect to an eMMC device. Some of these
+ 	 * host controller still needs to use 1.8v vccq for supporting
+ 	 * DDR mode.
+ 	 *
+ 	 * So the sequence will be:
+ 	 * if (host and device can both support 1.2v IO)
+ 	 *	use 1.2v IO;
+ 	 * else if (host and device can both support 1.8v IO)
+ 	 *	use 1.8v IO;
+ 	 * so if host and device can only support 3.3v IO, this is the
+ 	 * last choice.
+ 	 *
+ 	 * WARNING: eMMC rules are NOT the same as SD DDR
+ 	 */
+ 	err = -EINVAL;
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_1_2V)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);
+ 
+ 	if (err && (card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_1_8V))
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
+ 
+ 	/* make sure vccq is 3.3v after switching disaster */
+ 	if (err)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330);
+ 
+ 	if (!err)
+ 		mmc_set_timing(host, MMC_TIMING_MMC_DDR52);
+ 
+ 	return err;
+ }
+ 
+ static int mmc_select_hs400(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	int err = 0;
+ 
+ 	/*
+ 	 * HS400 mode requires 8-bit bus width
+ 	 */
+ 	if (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400 &&
+ 	      host->ios.bus_width == MMC_BUS_WIDTH_8))
+ 		return 0;
+ 
+ 	/*
+ 	 * Before switching to dual data rate operation for HS400,
+ 	 * it is required to convert from HS200 mode to HS mode.
+ 	 */
+ 	mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
+ 	mmc_set_bus_speed(card);
+ 
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS,
+ 			   card->ext_csd.generic_cmd6_time,
+ 			   true, true, true);
+ 	if (err) {
+ 		pr_err("%s: switch to high-speed from hs200 failed, err:%d\n",
+ 			mmc_hostname(host), err);
+ 		return err;
+ 	}
+ 
+ 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			 EXT_CSD_BUS_WIDTH,
+ 			 EXT_CSD_DDR_BUS_WIDTH_8,
+ 			 card->ext_csd.generic_cmd6_time);
+ 	if (err) {
+ 		pr_err("%s: switch to bus width for hs400 failed, err:%d\n",
+ 			mmc_hostname(host), err);
+ 		return err;
+ 	}
+ 
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS400,
+ 			   card->ext_csd.generic_cmd6_time,
+ 			   true, true, true);
+ 	if (err) {
+ 		pr_err("%s: switch to hs400 failed, err:%d\n",
+ 			 mmc_hostname(host), err);
+ 		return err;
+ 	}
+ 
+ 	mmc_set_timing(host, MMC_TIMING_MMC_HS400);
+ 	mmc_set_bus_speed(card);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * For device supporting HS200 mode, the following sequence
+  * should be done before executing the tuning process.
+  * 1. set the desired bus width(4-bit or 8-bit, 1-bit is not supported)
+  * 2. switch to HS200 mode
+  * 3. set the clock to > 52Mhz and <=200MHz
+  */
+ static int mmc_select_hs200(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	int err = -EINVAL;
+ 
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_2V)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);
+ 
+ 	if (err && card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_8V)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
+ 
+ 	/* If fails try again during next card power cycle */
+ 	if (err)
+ 		goto err;
+ 
+ 	/*
+ 	 * Set the bus width(4 or 8) with host's support and
+ 	 * switch to HS200 mode if bus width is set successfully.
+ 	 */
+ 	err = mmc_select_bus_width(card);
+ 	if (!IS_ERR_VALUE(err)) {
+ 		err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 				   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS200,
+ 				   card->ext_csd.generic_cmd6_time,
+ 				   true, true, true);
++>>>>>>> 4b75bffc77c4 (mmc: core: Fix error paths and messages in mmc_init_card)
  		if (!err)
 -			mmc_set_timing(host, MMC_TIMING_MMC_HS200);
 +			break;
  	}
 +
 +	/* switch to HS200 mode if bus width set successfully */
 +	if (!err)
 +		err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 +				EXT_CSD_HS_TIMING, 2,
 +				card->ext_csd.generic_cmd6_time,
 +				true, true, true);
  err:
  	return err;
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Activate High Speed or HS200 mode if supported.
+  */
+ static int mmc_select_timing(struct mmc_card *card)
+ {
+ 	int err = 0;
+ 
+ 	if ((card->csd.mmca_vsn < CSD_SPEC_VER_4 &&
+ 	     card->ext_csd.hs_max_dtr == 0))
+ 		goto bus_speed;
+ 
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200)
+ 		err = mmc_select_hs200(card);
+ 	else if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS)
+ 		err = mmc_select_hs(card);
+ 
+ 	if (err && err != -EBADMSG)
+ 		return err;
+ 
+ 	if (err) {
+ 		pr_warn("%s: switch to %s failed\n",
+ 			mmc_card_hs(card) ? "high-speed" :
+ 			(mmc_card_hs200(card) ? "hs200" : ""),
+ 			mmc_hostname(card->host));
+ 		err = 0;
+ 	}
+ 
+ bus_speed:
+ 	/*
+ 	 * Set the bus speed to the selected bus timing.
+ 	 * If timing is not selected, backward compatible is the default.
+ 	 */
+ 	mmc_set_bus_speed(card);
+ 	return err;
+ }
+ 
+ const u8 tuning_blk_pattern_4bit[MMC_TUNING_BLK_PATTERN_4BIT_SIZE] = {
+ 	0xff, 0x0f, 0xff, 0x00, 0xff, 0xcc, 0xc3, 0xcc,
+ 	0xc3, 0x3c, 0xcc, 0xff, 0xfe, 0xff, 0xfe, 0xef,
+ 	0xff, 0xdf, 0xff, 0xdd, 0xff, 0xfb, 0xff, 0xfb,
+ 	0xbf, 0xff, 0x7f, 0xff, 0x77, 0xf7, 0xbd, 0xef,
+ 	0xff, 0xf0, 0xff, 0xf0, 0x0f, 0xfc, 0xcc, 0x3c,
+ 	0xcc, 0x33, 0xcc, 0xcf, 0xff, 0xef, 0xff, 0xee,
+ 	0xff, 0xfd, 0xff, 0xfd, 0xdf, 0xff, 0xbf, 0xff,
+ 	0xbb, 0xff, 0xf7, 0xff, 0xf7, 0x7f, 0x7b, 0xde,
+ };
+ EXPORT_SYMBOL(tuning_blk_pattern_4bit);
+ 
+ const u8 tuning_blk_pattern_8bit[MMC_TUNING_BLK_PATTERN_8BIT_SIZE] = {
+ 	0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
+ 	0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,
+ 	0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
+ 	0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
+ 	0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
+ 	0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
+ 	0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
+ 	0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
+ 	0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
+ 	0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,
+ 	0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,
+ 	0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
+ 	0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
+ 	0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
+ 	0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
+ 	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
+ };
+ EXPORT_SYMBOL(tuning_blk_pattern_8bit);
+ 
+ /*
+  * Execute tuning sequence to seek the proper bus operating
+  * conditions for HS200 and HS400, which sends CMD21 to the device.
+  */
+ static int mmc_hs200_tuning(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	int err = 0;
+ 
+ 	/*
+ 	 * Timing should be adjusted to the HS400 target
+ 	 * operation frequency for tuning process
+ 	 */
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400 &&
+ 	    host->ios.bus_width == MMC_BUS_WIDTH_8)
+ 		if (host->ops->prepare_hs400_tuning)
+ 			host->ops->prepare_hs400_tuning(host, &host->ios);
+ 
+ 	if (host->ops->execute_tuning) {
+ 		mmc_host_clk_hold(host);
+ 		err = host->ops->execute_tuning(host,
+ 				MMC_SEND_TUNING_BLOCK_HS200);
+ 		mmc_host_clk_release(host);
+ 
+ 		if (err)
+ 			pr_err("%s: tuning execution failed\n",
+ 				mmc_hostname(host));
+ 	}
+ 
+ 	return err;
+ }
+ 
+ /*
++>>>>>>> 4b75bffc77c4 (mmc: core: Fix error paths and messages in mmc_init_card)
   * Handle the detection and initialisation of a card.
   *
   * In the case of a resume, "oldcard" will contain the card
@@@ -1120,186 -1449,27 +1415,203 @@@ static int mmc_init_card(struct mmc_hos
  	}
  
  	/*
 -	 * Select timing interface
 +	 * Activate high speed (if supported)
  	 */
 -	err = mmc_select_timing(card);
 -	if (err)
 -		goto free_card;
 +	if (card->ext_csd.hs_max_dtr != 0) {
 +		err = 0;
 +		if (card->ext_csd.hs_max_dtr > 52000000 &&
 +		    host->caps2 & MMC_CAP2_HS200)
 +			err = mmc_select_hs200(card);
 +		else if	(host->caps & MMC_CAP_MMC_HIGHSPEED)
 +			err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 +					EXT_CSD_HS_TIMING, 1,
 +					card->ext_csd.generic_cmd6_time,
 +					true, true, true);
 +
 +		if (err && err != -EBADMSG)
 +			goto free_card;
 +
 +		if (err) {
 +			pr_warning("%s: switch to highspeed failed\n",
 +			       mmc_hostname(card->host));
 +			err = 0;
 +		} else {
 +			if (card->ext_csd.hs_max_dtr > 52000000 &&
 +			    host->caps2 & MMC_CAP2_HS200) {
 +				mmc_card_set_hs200(card);
 +				mmc_set_timing(card->host,
 +					       MMC_TIMING_MMC_HS200);
 +			} else {
 +				mmc_card_set_highspeed(card);
 +				mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
 +			}
 +		}
 +	}
 +
 +	/*
 +	 * Compute bus speed.
 +	 */
 +	max_dtr = (unsigned int)-1;
 +
 +	if (mmc_card_highspeed(card) || mmc_card_hs200(card)) {
 +		if (max_dtr > card->ext_csd.hs_max_dtr)
 +			max_dtr = card->ext_csd.hs_max_dtr;
 +		if (mmc_card_highspeed(card) && (max_dtr > 52000000))
 +			max_dtr = 52000000;
 +	} else if (max_dtr > card->csd.max_dtr) {
 +		max_dtr = card->csd.max_dtr;
 +	}
 +
 +	mmc_set_clock(host, max_dtr);
 +
 +	/*
 +	 * Indicate DDR mode (if supported).
 +	 */
 +	if (mmc_card_highspeed(card)) {
 +		if ((card->ext_csd.card_type & EXT_CSD_CARD_TYPE_DDR_1_8V)
 +			&& (host->caps & MMC_CAP_1_8V_DDR))
 +				ddr = MMC_1_8V_DDR_MODE;
 +		else if ((card->ext_csd.card_type & EXT_CSD_CARD_TYPE_DDR_1_2V)
 +			&& (host->caps & MMC_CAP_1_2V_DDR))
 +				ddr = MMC_1_2V_DDR_MODE;
 +	}
  
 +	/*
 +	 * Indicate HS200 SDR mode (if supported).
 +	 */
  	if (mmc_card_hs200(card)) {
++<<<<<<< HEAD
 +		u32 ext_csd_bits;
 +		u32 bus_width = card->host->ios.bus_width;
 +
 +		/*
 +		 * For devices supporting HS200 mode, the bus width has
 +		 * to be set before executing the tuning function. If
 +		 * set before tuning, then device will respond with CRC
 +		 * errors for responses on CMD line. So for HS200 the
 +		 * sequence will be
 +		 * 1. set bus width 4bit / 8 bit (1 bit not supported)
 +		 * 2. switch to HS200 mode
 +		 * 3. set the clock to > 52Mhz <=200MHz and
 +		 * 4. execute tuning for HS200
 +		 */
 +		if ((host->caps2 & MMC_CAP2_HS200) &&
 +		    card->host->ops->execute_tuning) {
 +			mmc_host_clk_hold(card->host);
 +			err = card->host->ops->execute_tuning(card->host,
 +				MMC_SEND_TUNING_BLOCK_HS200);
 +			mmc_host_clk_release(card->host);
 +		}
 +		if (err) {
 +			pr_warning("%s: tuning execution failed\n",
 +				   mmc_hostname(card->host));
 +			goto err;
 +		}
 +
 +		ext_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?
 +				EXT_CSD_BUS_WIDTH_8 : EXT_CSD_BUS_WIDTH_4;
 +	}
 +
 +	/*
 +	 * Activate wide bus and DDR (if supported).
 +	 */
 +	if (!mmc_card_hs200(card) &&
 +	    (card->csd.mmca_vsn >= CSD_SPEC_VER_4) &&
 +	    (host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA))) {
 +		static unsigned ext_csd_bits[][2] = {
 +			{ EXT_CSD_BUS_WIDTH_8, EXT_CSD_DDR_BUS_WIDTH_8 },
 +			{ EXT_CSD_BUS_WIDTH_4, EXT_CSD_DDR_BUS_WIDTH_4 },
 +			{ EXT_CSD_BUS_WIDTH_1, EXT_CSD_BUS_WIDTH_1 },
 +		};
 +		static unsigned bus_widths[] = {
 +			MMC_BUS_WIDTH_8,
 +			MMC_BUS_WIDTH_4,
 +			MMC_BUS_WIDTH_1
 +		};
 +		unsigned idx, bus_width = 0;
 +
 +		if (host->caps & MMC_CAP_8_BIT_DATA)
 +			idx = 0;
 +		else
 +			idx = 1;
 +		for (; idx < ARRAY_SIZE(bus_widths); idx++) {
 +			bus_width = bus_widths[idx];
 +			if (bus_width == MMC_BUS_WIDTH_1)
 +				ddr = 0; /* no DDR for 1-bit width */
 +
 +			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 +					 EXT_CSD_BUS_WIDTH,
 +					 ext_csd_bits[idx][0],
 +					 card->ext_csd.generic_cmd6_time);
 +			if (!err) {
 +				mmc_set_bus_width(card->host, bus_width);
 +
 +				/*
 +				 * If controller can't handle bus width test,
 +				 * compare ext_csd previously read in 1 bit mode
 +				 * against ext_csd at new bus width
 +				 */
 +				if (!(host->caps & MMC_CAP_BUS_WIDTH_TEST))
 +					err = mmc_compare_ext_csds(card,
 +						bus_width);
 +				else
 +					err = mmc_bus_test(card, bus_width);
 +				if (!err)
 +					break;
 +			}
 +		}
 +
 +		if (!err && ddr) {
 +			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 +					 EXT_CSD_BUS_WIDTH,
 +					 ext_csd_bits[idx][1],
 +					 card->ext_csd.generic_cmd6_time);
 +		}
 +		if (err) {
 +			pr_warning("%s: switch to bus width %d ddr %d "
 +				"failed\n", mmc_hostname(card->host),
 +				1 << bus_width, ddr);
 +			goto free_card;
 +		} else if (ddr) {
 +			/*
 +			 * eMMC cards can support 3.3V to 1.2V i/o (vccq)
 +			 * signaling.
 +			 *
 +			 * EXT_CSD_CARD_TYPE_DDR_1_8V means 3.3V or 1.8V vccq.
 +			 *
 +			 * 1.8V vccq at 3.3V core voltage (vcc) is not required
 +			 * in the JEDEC spec for DDR.
 +			 *
 +			 * Do not force change in vccq since we are obviously
 +			 * working and no change to vccq is needed.
 +			 *
 +			 * WARNING: eMMC rules are NOT the same as SD DDR
 +			 */
 +			if (ddr == MMC_1_2V_DDR_MODE) {
 +				err = __mmc_set_signal_voltage(host,
 +					MMC_SIGNAL_VOLTAGE_120);
 +				if (err)
 +					goto err;
 +			}
 +			mmc_card_set_ddr_mode(card);
 +			mmc_set_timing(card->host, MMC_TIMING_MMC_DDR52);
 +			mmc_set_bus_width(card->host, bus_width);
++=======
+ 		err = mmc_hs200_tuning(card);
+ 		if (err)
+ 			goto free_card;
+ 
+ 		err = mmc_select_hs400(card);
+ 		if (err)
+ 			goto free_card;
+ 	} else if (mmc_card_hs(card)) {
+ 		/* Select the desired bus width optionally */
+ 		err = mmc_select_bus_width(card);
+ 		if (!IS_ERR_VALUE(err)) {
+ 			err = mmc_select_hs_ddr(card);
+ 			if (err)
+ 				goto free_card;
++>>>>>>> 4b75bffc77c4 (mmc: core: Fix error paths and messages in mmc_init_card)
  		}
  	}
  
* Unmerged path drivers/mmc/core/mmc.c
