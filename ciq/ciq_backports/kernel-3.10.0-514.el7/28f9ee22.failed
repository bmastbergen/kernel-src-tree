vlan: Do not put vlan headers back on bridge and macvlan ports

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vlad Yasevich <vyasevich@gmail.com>
commit 28f9ee22bcdd84726dbf6267d0b58f254166b900
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/28f9ee22.failed

When a vlan is configured with REORDER_HEADER set to 0, the vlan
header is put back into the packet and makes it appear that
the vlan header is still there even after it's been processed.
This posses a problem for bridge and macvlan ports.  The packets
passed to those device may be forwarded and at the time of the
forward, vlan headers end up being unexpectedly present.

With the patch, we make sure that we do not put the vlan header
back (when REORDER_HEADER is 0) if a bridge or macvlan has
been configured on top of the vlan device.

	Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 28f9ee22bcdd84726dbf6267d0b58f254166b900)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
diff --cc include/linux/netdevice.h
index 341e8588b936,67bfac1abfc1..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -3488,6 -3842,31 +3488,34 @@@ static inline bool netif_supports_nofcs
  	return dev->priv_flags & IFF_SUPP_NOFCS;
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool netif_is_l3_master(const struct net_device *dev)
+ {
+ 	return dev->priv_flags & IFF_L3MDEV_MASTER;
+ }
+ 
+ static inline bool netif_is_l3_slave(const struct net_device *dev)
+ {
+ 	return dev->priv_flags & IFF_L3MDEV_SLAVE;
+ }
+ 
+ static inline bool netif_is_bridge_master(const struct net_device *dev)
+ {
+ 	return dev->priv_flags & IFF_EBRIDGE;
+ }
+ 
+ static inline bool netif_is_bridge_port(const struct net_device *dev)
+ {
+ 	return dev->priv_flags & IFF_BRIDGE_PORT;
+ }
+ 
+ static inline bool netif_is_ovs_master(const struct net_device *dev)
+ {
+ 	return dev->priv_flags & IFF_OPENVSWITCH;
+ }
+ 
++>>>>>>> 28f9ee22bcdd (vlan: Do not put vlan headers back on bridge and macvlan ports)
  /* This device needs to keep skb dst for qdisc enqueue or ndo_start_xmit() */
  static inline void netif_keep_dst(struct net_device *dev)
  {
* Unmerged path include/linux/netdevice.h
diff --git a/net/8021q/vlan_core.c b/net/8021q/vlan_core.c
index 1fe4f0fb04d1..7fa275e4cd2c 100644
--- a/net/8021q/vlan_core.c
+++ b/net/8021q/vlan_core.c
@@ -30,7 +30,9 @@ bool vlan_do_receive(struct sk_buff **skbp)
 			skb->pkt_type = PACKET_HOST;
 	}
 
-	if (!(vlan_dev_priv(vlan_dev)->flags & VLAN_FLAG_REORDER_HDR)) {
+	if (!(vlan_dev_priv(vlan_dev)->flags & VLAN_FLAG_REORDER_HDR) &&
+	    !netif_is_macvlan_port(vlan_dev) &&
+	    !netif_is_bridge_port(vlan_dev)) {
 		unsigned int offset = skb->data - skb_mac_header(skb);
 
 		/*
