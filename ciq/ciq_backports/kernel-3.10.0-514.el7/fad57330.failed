i40e/i40evf: Clean-up Rx packet checksum handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Duyck <aduyck@mirantis.com>
commit fad57330b6d0710fdf39dc1c2b28ccebb97ae8a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fad57330.failed

This is mostly a minor clean-up for the Rx checksum path in order to avoid
some of the unnecessary conditional checks that were being applied.

	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit fad57330b6d0710fdf39dc1c2b28ccebb97ae8a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_txrx.c
#	drivers/net/ethernet/intel/i40evf/i40e_txrx.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 5a3abb58e191,ded73c021510..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@@ -1388,16 -1389,7 +1388,20 @@@ static inline void i40e_rx_checksum(str
  				    u16 rx_ptype)
  {
  	struct i40e_rx_ptype_decoded decoded = decode_rx_desc_ptype(rx_ptype);
++<<<<<<< HEAD
 +	bool ipv4 = false, ipv6 = false;
 +	bool ipv4_tunnel, ipv6_tunnel;
 +	__wsum rx_udp_csum;
 +	struct iphdr *iph;
 +	__sum16 csum;
 +
 +	ipv4_tunnel = (rx_ptype >= I40E_RX_PTYPE_GRENAT4_MAC_PAY3) &&
 +		     (rx_ptype <= I40E_RX_PTYPE_GRENAT4_MACVLAN_IPV6_ICMP_PAY4);
 +	ipv6_tunnel = (rx_ptype >= I40E_RX_PTYPE_GRENAT6_MAC_PAY3) &&
 +		     (rx_ptype <= I40E_RX_PTYPE_GRENAT6_MACVLAN_IPV6_ICMP_PAY4);
++=======
+ 	bool ipv4, ipv6, ipv4_tunnel, ipv6_tunnel;
++>>>>>>> fad57330b6d0 (i40e/i40evf: Clean-up Rx packet checksum handling)
  
  	skb->ip_summed = CHECKSUM_NONE;
  
@@@ -1442,38 -1432,18 +1444,43 @@@
  	if (rx_error & BIT(I40E_RX_DESC_ERROR_PPRS_SHIFT))
  		return;
  
 -	/* The hardware supported by this driver does not validate outer
 -	 * checksums for tunneled VXLAN or GENEVE frames.  I don't agree
 -	 * with it but the specification states that you "MAY validate", it
 -	 * doesn't make it a hard requirement so if we have validated the
 -	 * inner checksum report CHECKSUM_UNNECESSARY.
 +	/* If VXLAN/GENEVE traffic has an outer UDPv4 checksum we need to check
 +	 * it in the driver, hardware does not do it for us.
 +	 * Since L3L4P bit was set we assume a valid IHL value (>=5)
 +	 * so the total length of IPv4 header is IHL*4 bytes
 +	 * The UDP_0 bit *may* bet set if the *inner* header is UDP
  	 */
 +	if (!(vsi->back->flags & I40E_FLAG_OUTER_UDP_CSUM_CAPABLE) &&
 +	    (ipv4_tunnel)) {
 +		skb->transport_header = skb->mac_header +
 +					sizeof(struct ethhdr) +
 +					(ip_hdr(skb)->ihl * 4);
 +
 +		/* Add 4 bytes for VLAN tagged packets */
 +		skb->transport_header += (skb->protocol == htons(ETH_P_8021Q) ||
 +					  skb->protocol == htons(ETH_P_8021AD))
 +					  ? VLAN_HLEN : 0;
 +
 +		if ((ip_hdr(skb)->protocol == IPPROTO_UDP) &&
 +		    (udp_hdr(skb)->check != 0)) {
 +			rx_udp_csum = udp_csum(skb);
 +			iph = ip_hdr(skb);
 +			csum = csum_tcpudp_magic(
 +					iph->saddr, iph->daddr,
 +					(skb->len - skb_transport_offset(skb)),
 +					IPPROTO_UDP, rx_udp_csum);
 +
 +			if (udp_hdr(skb)->check != csum)
 +				goto checksum_fail;
 +
 +		} /* else its GRE and so no outer UDP header */
 +	}
  
+ 	ipv4_tunnel = (rx_ptype >= I40E_RX_PTYPE_GRENAT4_MAC_PAY3) &&
+ 		     (rx_ptype <= I40E_RX_PTYPE_GRENAT4_MACVLAN_IPV6_ICMP_PAY4);
+ 	ipv6_tunnel = (rx_ptype >= I40E_RX_PTYPE_GRENAT6_MAC_PAY3) &&
+ 		     (rx_ptype <= I40E_RX_PTYPE_GRENAT6_MACVLAN_IPV6_ICMP_PAY4);
+ 
  	skb->ip_summed = CHECKSUM_UNNECESSARY;
  	skb->csum_level = ipv4_tunnel || ipv6_tunnel;
  
diff --cc drivers/net/ethernet/intel/i40evf/i40e_txrx.c
index f6384b0c8220,3f40e0e26066..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
@@@ -857,16 -861,7 +857,20 @@@ static inline void i40e_rx_checksum(str
  				    u16 rx_ptype)
  {
  	struct i40e_rx_ptype_decoded decoded = decode_rx_desc_ptype(rx_ptype);
++<<<<<<< HEAD
 +	bool ipv4 = false, ipv6 = false;
 +	bool ipv4_tunnel, ipv6_tunnel;
 +	__wsum rx_udp_csum;
 +	struct iphdr *iph;
 +	__sum16 csum;
 +
 +	ipv4_tunnel = (rx_ptype >= I40E_RX_PTYPE_GRENAT4_MAC_PAY3) &&
 +		     (rx_ptype <= I40E_RX_PTYPE_GRENAT4_MACVLAN_IPV6_ICMP_PAY4);
 +	ipv6_tunnel = (rx_ptype >= I40E_RX_PTYPE_GRENAT6_MAC_PAY3) &&
 +		     (rx_ptype <= I40E_RX_PTYPE_GRENAT6_MACVLAN_IPV6_ICMP_PAY4);
++=======
+ 	bool ipv4, ipv6, ipv4_tunnel, ipv6_tunnel;
++>>>>>>> fad57330b6d0 (i40e/i40evf: Clean-up Rx packet checksum handling)
  
  	skb->ip_summed = CHECKSUM_NONE;
  
@@@ -911,37 -904,18 +913,42 @@@
  	if (rx_error & BIT(I40E_RX_DESC_ERROR_PPRS_SHIFT))
  		return;
  
 -	/* The hardware supported by this driver does not validate outer
 -	 * checksums for tunneled VXLAN or GENEVE frames.  I don't agree
 -	 * with it but the specification states that you "MAY validate", it
 -	 * doesn't make it a hard requirement so if we have validated the
 -	 * inner checksum report CHECKSUM_UNNECESSARY.
 +	/* If VXLAN traffic has an outer UDPv4 checksum we need to check
 +	 * it in the driver, hardware does not do it for us.
 +	 * Since L3L4P bit was set we assume a valid IHL value (>=5)
 +	 * so the total length of IPv4 header is IHL*4 bytes
 +	 * The UDP_0 bit *may* bet set if the *inner* header is UDP
  	 */
 +	if (ipv4_tunnel) {
 +		skb->transport_header = skb->mac_header +
 +					sizeof(struct ethhdr) +
 +					(ip_hdr(skb)->ihl * 4);
 +
 +		/* Add 4 bytes for VLAN tagged packets */
 +		skb->transport_header += (skb->protocol == htons(ETH_P_8021Q) ||
 +					  skb->protocol == htons(ETH_P_8021AD))
 +					  ? VLAN_HLEN : 0;
 +
 +		if ((ip_hdr(skb)->protocol == IPPROTO_UDP) &&
 +		    (udp_hdr(skb)->check != 0)) {
 +			rx_udp_csum = udp_csum(skb);
 +			iph = ip_hdr(skb);
 +			csum = csum_tcpudp_magic(iph->saddr, iph->daddr,
 +						 (skb->len -
 +						  skb_transport_offset(skb)),
 +						 IPPROTO_UDP, rx_udp_csum);
 +
 +			if (udp_hdr(skb)->check != csum)
 +				goto checksum_fail;
 +
 +		} /* else its GRE and so no outer UDP header */
 +	}
  
+ 	ipv4_tunnel = (rx_ptype >= I40E_RX_PTYPE_GRENAT4_MAC_PAY3) &&
+ 		     (rx_ptype <= I40E_RX_PTYPE_GRENAT4_MACVLAN_IPV6_ICMP_PAY4);
+ 	ipv6_tunnel = (rx_ptype >= I40E_RX_PTYPE_GRENAT6_MAC_PAY3) &&
+ 		     (rx_ptype <= I40E_RX_PTYPE_GRENAT6_MACVLAN_IPV6_ICMP_PAY4);
+ 
  	skb->ip_summed = CHECKSUM_UNNECESSARY;
  	skb->csum_level = ipv4_tunnel || ipv6_tunnel;
  
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_txrx.c
