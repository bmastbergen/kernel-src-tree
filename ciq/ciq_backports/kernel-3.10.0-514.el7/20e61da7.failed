ipv4: fail early when creating netdev named all or default

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit 20e61da7ffcfd84a1b6f797e745608572e5bc218
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/20e61da7.failed

We create a proc dir for each network device, this will cause
conflicts when the devices have name "all" or "default".

Rather than emitting an ugly kernel warning, we could just
fail earlier by checking the device name.

	Reported-by: Stephane Chazelas <stephane.chazelas@gmail.com>
	Cc: "David S. Miller" <davem@davemloft.net>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 20e61da7ffcfd84a1b6f797e745608572e5bc218)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip.h
diff --cc include/net/ip.h
index ac68d6939a5b,09b32da1b929..000000000000
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@@ -224,11 -209,25 +224,26 @@@ static inline void snmp_mib_free(void _
  
  void inet_get_local_port_range(struct net *net, int *low, int *high);
  
 -#ifdef CONFIG_SYSCTL
 -static inline int inet_is_local_reserved_port(struct net *net, int port)
 +extern unsigned long *sysctl_local_reserved_ports;
 +static inline int inet_is_reserved_local_port(int port)
  {
 -	if (!net->ipv4.sysctl_local_reserved_ports)
 -		return 0;
 -	return test_bit(port, net->ipv4.sysctl_local_reserved_ports);
 +	return test_bit(port, sysctl_local_reserved_ports);
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline bool sysctl_dev_name_is_allowed(const char *name)
+ {
+ 	return strcmp(name, "default") != 0  && strcmp(name, "all") != 0;
+ }
+ 
+ #else
+ static inline int inet_is_local_reserved_port(struct net *net, int port)
+ {
+ 	return 0;
+ }
+ #endif
++>>>>>>> 20e61da7ffcf (ipv4: fail early when creating netdev named all or default)
  
  extern int sysctl_ip_nonlocal_bind;
  
* Unmerged path include/net/ip.h
diff --git a/net/ipv4/devinet.c b/net/ipv4/devinet.c
index 25ce9bd1a367..707d50149750 100644
--- a/net/ipv4/devinet.c
+++ b/net/ipv4/devinet.c
@@ -179,11 +179,12 @@ static BLOCKING_NOTIFIER_HEAD(inetaddr_chain);
 static void inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,
 			 int destroy);
 #ifdef CONFIG_SYSCTL
-static void devinet_sysctl_register(struct in_device *idev);
+static int devinet_sysctl_register(struct in_device *idev);
 static void devinet_sysctl_unregister(struct in_device *idev);
 #else
-static void devinet_sysctl_register(struct in_device *idev)
+static int devinet_sysctl_register(struct in_device *idev)
 {
+	return 0;
 }
 static void devinet_sysctl_unregister(struct in_device *idev)
 {
@@ -230,6 +231,7 @@ EXPORT_SYMBOL(in_dev_finish_destroy);
 static struct in_device *inetdev_init(struct net_device *dev)
 {
 	struct in_device *in_dev;
+	int err = -ENOMEM;
 
 	ASSERT_RTNL();
 
@@ -250,7 +252,13 @@ static struct in_device *inetdev_init(struct net_device *dev)
 	/* Account for reference dev->ip_ptr (below) */
 	in_dev_hold(in_dev);
 
-	devinet_sysctl_register(in_dev);
+	err = devinet_sysctl_register(in_dev);
+	if (err) {
+		in_dev->dead = 1;
+		in_dev_put(in_dev);
+		in_dev = NULL;
+		goto out;
+	}
 	ip_mc_init_dev(in_dev);
 	if (dev->flags & IFF_UP)
 		ip_mc_up(in_dev);
@@ -258,7 +266,7 @@ static struct in_device *inetdev_init(struct net_device *dev)
 	/* we can receive as soon as ip_ptr is set -- do this last */
 	rcu_assign_pointer(dev->ip_ptr, in_dev);
 out:
-	return in_dev;
+	return in_dev ?: ERR_PTR(err);
 out_kfree:
 	kfree(in_dev);
 	in_dev = NULL;
@@ -1346,8 +1354,8 @@ static int inetdev_event(struct notifier_block *this, unsigned long event,
 	if (!in_dev) {
 		if (event == NETDEV_REGISTER) {
 			in_dev = inetdev_init(dev);
-			if (!in_dev)
-				return notifier_from_errno(-ENOMEM);
+			if (IS_ERR(in_dev))
+				return notifier_from_errno(PTR_ERR(in_dev));
 			if (dev->flags & IFF_LOOPBACK) {
 				IN_DEV_CONF_SET(in_dev, NOXFRM, 1);
 				IN_DEV_CONF_SET(in_dev, NOPOLICY, 1);
@@ -2159,11 +2167,21 @@ static void __devinet_sysctl_unregister(struct ipv4_devconf *cnf)
 	kfree(t);
 }
 
-static void devinet_sysctl_register(struct in_device *idev)
+static int devinet_sysctl_register(struct in_device *idev)
 {
-	neigh_sysctl_register(idev->dev, idev->arp_parms, NULL);
-	__devinet_sysctl_register(dev_net(idev->dev), idev->dev->name,
+	int err;
+
+	if (!sysctl_dev_name_is_allowed(idev->dev->name))
+		return -EINVAL;
+
+	err = neigh_sysctl_register(idev->dev, idev->arp_parms, NULL);
+	if (err)
+		return err;
+	err = __devinet_sysctl_register(dev_net(idev->dev), idev->dev->name,
 					&idev->cnf);
+	if (err)
+		neigh_sysctl_unregister(idev->arp_parms);
+	return err;
 }
 
 static void devinet_sysctl_unregister(struct in_device *idev)
