netfilter: nf_tables: use struct nft_verdict within struct nft_data

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Patrick McHardy <kaber@trash.net>
commit 1ca2e1702c050aff352cb3efc8a649363dbaeab2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1ca2e170.failed

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 1ca2e1702c050aff352cb3efc8a649363dbaeab2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index 399ca83793bb,0bb16a1561d2..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -3881,13 -4041,18 +3881,21 @@@ static int nf_tables_loop_check_setelem
  					const struct nft_set_iter *iter,
  					const struct nft_set_elem *elem)
  {
 -	const struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);
 -	const struct nft_data *data;
 -
 -	if (nft_set_ext_exists(ext, NFT_SET_EXT_FLAGS) &&
 -	    *nft_set_ext_flags(ext) & NFT_SET_ELEM_INTERVAL_END)
 +	if (elem->flags & NFT_SET_ELEM_INTERVAL_END)
  		return 0;
  
++<<<<<<< HEAD
 +	switch (elem->data.verdict) {
 +	case NFT_JUMP:
 +	case NFT_GOTO:
 +		return nf_tables_check_loops(ctx, elem->data.chain);
++=======
+ 	data = nft_set_ext_data(ext);
+ 	switch (data->verdict.code) {
+ 	case NFT_JUMP:
+ 	case NFT_GOTO:
+ 		return nf_tables_check_loops(ctx, data->verdict.chain);
++>>>>>>> 1ca2e1702c05 (netfilter: nf_tables: use struct nft_verdict within struct nft_data)
  	default:
  		return 0;
  	}
@@@ -4013,11 -4168,13 +4022,18 @@@ int nft_validate_data_load(const struc
  
  	switch (reg) {
  	case NFT_REG_VERDICT:
 -		if (type != NFT_DATA_VERDICT)
 +		if (data == NULL || type != NFT_DATA_VERDICT)
  			return -EINVAL;
  
++<<<<<<< HEAD
 +		if (data->verdict == NFT_GOTO || data->verdict == NFT_JUMP) {
 +			err = nf_tables_check_loops(ctx, data->chain);
++=======
+ 		if (data != NULL &&
+ 		    (data->verdict.code == NFT_GOTO ||
+ 		     data->verdict.code == NFT_JUMP)) {
+ 			err = nf_tables_check_loops(ctx, data->verdict.chain);
++>>>>>>> 1ca2e1702c05 (netfilter: nf_tables: use struct nft_verdict within struct nft_data)
  			if (err < 0)
  				return err;
  
diff --git a/include/net/netfilter/nf_tables.h b/include/net/netfilter/nf_tables.h
index 4ab50d820db0..b9550edb43fe 100644
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -38,11 +38,8 @@ static inline void nft_set_pktinfo(struct nft_pktinfo *pkt,
 
 struct nft_data {
 	union {
-		u32				data[4];
-		struct {
-			u32			verdict;
-			struct nft_chain	*chain;
-		};
+		u32			data[4];
+		struct nft_verdict	verdict;
 	};
 } __attribute__((aligned(__alignof__(u64))));
 
* Unmerged path net/netfilter/nf_tables_api.c
