KVM: x86: use generic function for MSI parsing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] kvm: use generic function for MSI parsing (Radim Krcmar) [1273718]
Rebuild_FUZZ: 94.25%
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit 3159d36ad799a117eb2f898de4c6b7777e4dc045
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3159d36a.failed

	Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 3159d36ad799a117eb2f898de4c6b7777e4dc045)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/irq_comm.c
diff --cc arch/x86/kvm/irq_comm.c
index 6baa9b6a480d,47ad681a33fd..000000000000
--- a/arch/x86/kvm/irq_comm.c
+++ b/arch/x86/kvm/irq_comm.c
@@@ -327,3 -358,64 +327,67 @@@ int kvm_setup_default_irq_routing(struc
  	return kvm_set_irq_routing(kvm, default_routing,
  				   ARRAY_SIZE(default_routing), 0);
  }
++<<<<<<< HEAD
++=======
+ 
+ static const struct kvm_irq_routing_entry empty_routing[] = {};
+ 
+ int kvm_setup_empty_irq_routing(struct kvm *kvm)
+ {
+ 	return kvm_set_irq_routing(kvm, empty_routing, 0, 0);
+ }
+ 
+ void kvm_arch_post_irq_routing_update(struct kvm *kvm)
+ {
+ 	if (ioapic_in_kernel(kvm) || !irqchip_in_kernel(kvm))
+ 		return;
+ 	kvm_make_scan_ioapic_request(kvm);
+ }
+ 
+ void kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,
+ 			    ulong *ioapic_handled_vectors)
+ {
+ 	struct kvm *kvm = vcpu->kvm;
+ 	struct kvm_kernel_irq_routing_entry *entry;
+ 	struct kvm_irq_routing_table *table;
+ 	u32 i, nr_ioapic_pins;
+ 	int idx;
+ 
+ 	idx = srcu_read_lock(&kvm->irq_srcu);
+ 	table = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+ 	nr_ioapic_pins = min_t(u32, table->nr_rt_entries,
+ 			       kvm->arch.nr_reserved_ioapic_pins);
+ 	for (i = 0; i < nr_ioapic_pins; ++i) {
+ 		hlist_for_each_entry(entry, &table->map[i], link) {
+ 			struct kvm_lapic_irq irq;
+ 
+ 			if (entry->type != KVM_IRQ_ROUTING_MSI)
+ 				continue;
+ 
+ 			kvm_set_msi_irq(entry, &irq);
+ 
+ 			if (irq.level && kvm_apic_match_dest(vcpu, NULL, 0,
+ 						irq.dest_id, irq.dest_mode))
+ 				__set_bit(irq.vector, ioapic_handled_vectors);
+ 		}
+ 	}
+ 	srcu_read_unlock(&kvm->irq_srcu, idx);
+ }
+ 
+ int kvm_arch_set_irq(struct kvm_kernel_irq_routing_entry *irq, struct kvm *kvm,
+ 		     int irq_source_id, int level, bool line_status)
+ {
+ 	switch (irq->type) {
+ 	case KVM_IRQ_ROUTING_HV_SINT:
+ 		return kvm_hv_set_sint(irq, kvm, irq_source_id, level,
+ 				       line_status);
+ 	default:
+ 		return -EWOULDBLOCK;
+ 	}
+ }
+ 
+ void kvm_arch_irq_routing_update(struct kvm *kvm)
+ {
+ 	kvm_hv_irq_routing_update(kvm);
+ }
++>>>>>>> 3159d36ad799 (KVM: x86: use generic function for MSI parsing)
* Unmerged path arch/x86/kvm/irq_comm.c
