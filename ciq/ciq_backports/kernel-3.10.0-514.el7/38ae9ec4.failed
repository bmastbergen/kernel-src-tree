powerpc/pseries: Move controller ops from ppc_md to controller_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [powerpc] pseries: Move controller ops from ppc_md to controller_ops (Gustavo Duarte) [1275657]
Rebuild_FUZZ: 93.55%
commit-author Daniel Axtens <dja@axtens.net>
commit 38ae9ec40f06f3aef5c25314f432113cf2c1340a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/38ae9ec4.failed

This moves the pSeries platform to use the pci_controller_ops structure,
rather than ppc_md for PCI controller operations.

	Signed-off-by: Daniel Axtens <dja@axtens.net>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 38ae9ec40f06f3aef5c25314f432113cf2c1340a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/pseries/iommu.c
diff --cc arch/powerpc/platforms/pseries/iommu.c
index 3d2a17966bda,61d5a17f45c0..000000000000
--- a/arch/powerpc/platforms/pseries/iommu.c
+++ b/arch/powerpc/platforms/pseries/iommu.c
@@@ -52,74 -49,8 +52,75 @@@
  #include <asm/mmzone.h>
  #include <asm/plpar_wrappers.h>
  
+ #include "pseries.h"
  
 +static struct iommu_table_group *iommu_pseries_alloc_group(int node)
 +{
 +	struct iommu_table_group *table_group = NULL;
 +	struct iommu_table *tbl = NULL;
 +	struct iommu_table_group_link *tgl = NULL;
 +
 +	table_group = kzalloc_node(sizeof(struct iommu_table_group), GFP_KERNEL,
 +			   node);
 +	if (!table_group)
 +		goto fail_exit;
 +
 +	tbl = kzalloc_node(sizeof(struct iommu_table), GFP_KERNEL, node);
 +	if (!tbl)
 +		goto fail_exit;
 +
 +	tgl = kzalloc_node(sizeof(struct iommu_table_group_link), GFP_KERNEL,
 +			node);
 +	if (!tgl)
 +		goto fail_exit;
 +
 +	INIT_LIST_HEAD_RCU(&tbl->it_group_list);
 +	tgl->table_group = table_group;
 +	list_add_rcu(&tgl->next, &tbl->it_group_list);
 +
 +	table_group->tables[0] = tbl;
 +
 +	return table_group;
 +
 +fail_exit:
 +	kfree(tgl);
 +	kfree(table_group);
 +	kfree(tbl);
 +
 +	return NULL;
 +}
 +
 +static void iommu_pseries_free_group(struct iommu_table_group *table_group,
 +		const char *node_name)
 +{
 +	struct iommu_table *tbl;
 +#ifdef CONFIG_IOMMU_API
 +	struct iommu_table_group_link *tgl;
 +#endif
 +
 +	if (!table_group)
 +		return;
 +
 +	tbl = table_group->tables[0];
 +#ifdef CONFIG_IOMMU_API
 +	tgl = list_first_entry_or_null(&tbl->it_group_list,
 +			struct iommu_table_group_link, next);
 +
 +	WARN_ON_ONCE(!tgl);
 +	if (tgl) {
 +		list_del_rcu(&tgl->next);
 +		kfree(tgl);
 +	}
 +	if (table_group->group) {
 +		iommu_group_put(table_group->group);
 +		BUG_ON(table_group->group);
 +	}
 +#endif
 +	iommu_free_table(tbl, node_name);
 +
 +	kfree(table_group);
 +}
 +
  static void tce_invalidate_pSeries_sw(struct iommu_table *tbl,
  				      __be64 *startp, __be64 *endp)
  {
@@@ -1390,13 -1300,24 +1391,34 @@@ void iommu_init_early_pSeries(void
  		return;
  
  	if (firmware_has_feature(FW_FEATURE_LPAR)) {
++<<<<<<< HEAD
 +		ppc_md.pci_dma_bus_setup = pci_dma_bus_setup_pSeriesLP;
 +		ppc_md.pci_dma_dev_setup = pci_dma_dev_setup_pSeriesLP;
 +		ppc_md.dma_set_mask = dma_set_mask_pSeriesLP;
 +		ppc_md.dma_get_required_mask = dma_get_required_mask_pSeriesLP;
 +	} else {
 +		ppc_md.pci_dma_bus_setup = pci_dma_bus_setup_pSeries;
 +		ppc_md.pci_dma_dev_setup = pci_dma_dev_setup_pSeries;
++=======
+ 		if (firmware_has_feature(FW_FEATURE_MULTITCE)) {
+ 			ppc_md.tce_build = tce_buildmulti_pSeriesLP;
+ 			ppc_md.tce_free	 = tce_freemulti_pSeriesLP;
+ 		} else {
+ 			ppc_md.tce_build = tce_build_pSeriesLP;
+ 			ppc_md.tce_free	 = tce_free_pSeriesLP;
+ 		}
+ 		ppc_md.tce_get   = tce_get_pSeriesLP;
+ 		pseries_pci_controller_ops.dma_bus_setup = pci_dma_bus_setup_pSeriesLP;
+ 		pseries_pci_controller_ops.dma_dev_setup = pci_dma_dev_setup_pSeriesLP;
+ 		ppc_md.dma_set_mask = dma_set_mask_pSeriesLP;
+ 		ppc_md.dma_get_required_mask = dma_get_required_mask_pSeriesLP;
+ 	} else {
+ 		ppc_md.tce_build = tce_build_pSeries;
+ 		ppc_md.tce_free  = tce_free_pSeries;
+ 		ppc_md.tce_get   = tce_get_pseries;
+ 		pseries_pci_controller_ops.dma_bus_setup = pci_dma_bus_setup_pSeries;
+ 		pseries_pci_controller_ops.dma_dev_setup = pci_dma_dev_setup_pSeries;
++>>>>>>> 38ae9ec40f06 (powerpc/pseries: Move controller ops from ppc_md to controller_ops)
  	}
  
  
* Unmerged path arch/powerpc/platforms/pseries/iommu.c
diff --git a/arch/powerpc/platforms/pseries/pci_dlpar.c b/arch/powerpc/platforms/pseries/pci_dlpar.c
index 4a67e6992640..38d75177486d 100644
--- a/arch/powerpc/platforms/pseries/pci_dlpar.c
+++ b/arch/powerpc/platforms/pseries/pci_dlpar.c
@@ -32,6 +32,8 @@
 #include <asm/firmware.h>
 #include <asm/eeh.h>
 
+#include "pseries.h"
+
 static struct pci_bus *
 find_bus_among_children(struct pci_bus *bus,
                         struct device_node *dn)
@@ -75,6 +77,7 @@ struct pci_controller *init_phb_dynamic(struct device_node *dn)
 		return NULL;
 	rtas_setup_phb(phb);
 	pci_process_bridge_OF_ranges(phb, dn, 0);
+	phb->controller_ops = pseries_pci_controller_ops;
 
 	pci_devs_phb_init_dynamic(phb);
 
diff --git a/arch/powerpc/platforms/pseries/pseries.h b/arch/powerpc/platforms/pseries/pseries.h
index 1796c5438cc6..cd64672e24f8 100644
--- a/arch/powerpc/platforms/pseries/pseries.h
+++ b/arch/powerpc/platforms/pseries/pseries.h
@@ -65,6 +65,8 @@ extern int dlpar_detach_node(struct device_node *);
 struct pci_host_bridge;
 int pseries_root_bridge_prepare(struct pci_host_bridge *bridge);
 
+extern struct pci_controller_ops pseries_pci_controller_ops;
+
 unsigned long pseries_memory_block_size(void);
 
 #endif /* _PSERIES_PSERIES_H */
diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index f4c77d11ec51..a1721730c522 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -491,6 +491,7 @@ static void __init find_and_init_phbs(void)
 		rtas_setup_phb(phb);
 		pci_process_bridge_OF_ranges(phb, node, 0);
 		isa_bridge_find_early(phb);
+		phb->controller_ops = pseries_pci_controller_ops;
 	}
 
 	of_node_put(root);
@@ -854,6 +855,10 @@ static void pSeries_power_off(void)
 void pSeries_final_fixup(void) { }
 #endif
 
+struct pci_controller_ops pseries_pci_controller_ops = {
+	.probe_mode		= pSeries_pci_probe_mode,
+};
+
 define_machine(pseries) {
 	.name			= "pSeries",
 	.probe			= pSeries_probe,
@@ -862,7 +867,6 @@ define_machine(pseries) {
 	.show_cpuinfo		= pSeries_show_cpuinfo,
 	.log_error		= pSeries_log_error,
 	.pcibios_fixup		= pSeries_final_fixup,
-	.pci_probe_mode		= pSeries_pci_probe_mode,
 	.restart		= rtas_restart,
 	.power_off		= pSeries_power_off,
 	.halt			= rtas_halt,
