IB/qib: Support query gid in rdmavt

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit 2366754632d3e52a97bf607a22bcca592a46f3f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/23667546.failed

Query gid is in rdmavt, but still relies on the driver to maintain the
guid table. Add the necessary driver call back and remove the existing
verb handler.

	Reviewed-by: Harish Chegondi <harish.chegondi@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 2366754632d3e52a97bf607a22bcca592a46f3f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/qib/qib_verbs.c
diff --cc drivers/infiniband/hw/qib/qib_verbs.c
index c4417a1f33be,a3a13a52876d..000000000000
--- a/drivers/infiniband/hw/qib/qib_verbs.c
+++ b/drivers/infiniband/hw/qib/qib_verbs.c
@@@ -1727,82 -1421,19 +1727,87 @@@ static int qib_modify_port(struct ib_de
  	return 0;
  }
  
- static int qib_query_gid(struct ib_device *ibdev, u8 port,
- 			 int index, union ib_gid *gid)
+ static int qib_get_guid_be(struct rvt_dev_info *rdi, struct rvt_ibport *rvp,
+ 			   int guid_index, __be64 *guid)
  {
- 	struct qib_devdata *dd = dd_from_ibdev(ibdev);
- 	int ret = 0;
+ 	struct qib_ibport *ibp = container_of(rvp, struct qib_ibport, rvp);
+ 	struct qib_pportdata *ppd = ppd_from_ibp(ibp);
  
- 	if (!port || port > dd->num_pports)
- 		ret = -EINVAL;
- 	else {
- 		struct qib_ibport *ibp = to_iport(ibdev, port);
- 		struct qib_pportdata *ppd = ppd_from_ibp(ibp);
+ 	if (guid_index == 0)
+ 		*guid = ppd->guid;
+ 	else if (guid_index < QIB_GUIDS_PER_PORT)
+ 		*guid = ibp->guids[guid_index - 1];
+ 	else
+ 		return -EINVAL;
  
++<<<<<<< HEAD
 +		gid->global.subnet_prefix = ibp->gid_prefix;
 +		if (index == 0)
 +			gid->global.interface_id = ppd->guid;
 +		else if (index < QIB_GUIDS_PER_PORT)
 +			gid->global.interface_id = ibp->guids[index - 1];
 +		else
 +			ret = -EINVAL;
 +	}
 +
 +	return ret;
++=======
++	return 0;
++>>>>>>> 2366754632d3 (IB/qib: Support query gid in rdmavt)
 +}
 +
 +static struct ib_pd *qib_alloc_pd(struct ib_device *ibdev,
 +				  struct ib_ucontext *context,
 +				  struct ib_udata *udata)
 +{
 +	struct qib_ibdev *dev = to_idev(ibdev);
 +	struct qib_pd *pd;
 +	struct ib_pd *ret;
 +
 +	/*
 +	 * This is actually totally arbitrary.  Some correctness tests
 +	 * assume there's a maximum number of PDs that can be allocated.
 +	 * We don't actually have this limit, but we fail the test if
 +	 * we allow allocations of more than we report for this value.
 +	 */
 +
 +	pd = kmalloc(sizeof(*pd), GFP_KERNEL);
 +	if (!pd) {
 +		ret = ERR_PTR(-ENOMEM);
 +		goto bail;
 +	}
 +
 +	spin_lock(&dev->n_pds_lock);
 +	if (dev->n_pds_allocated == ib_qib_max_pds) {
 +		spin_unlock(&dev->n_pds_lock);
 +		kfree(pd);
 +		ret = ERR_PTR(-ENOMEM);
 +		goto bail;
 +	}
 +
 +	dev->n_pds_allocated++;
 +	spin_unlock(&dev->n_pds_lock);
 +
 +	/* ib_alloc_pd() will initialize pd->ibpd. */
 +	pd->user = udata != NULL;
 +
 +	ret = &pd->ibpd;
 +
 +bail:
 +	return ret;
 +}
 +
 +static int qib_dealloc_pd(struct ib_pd *ibpd)
 +{
 +	struct qib_pd *pd = to_ipd(ibpd);
 +	struct qib_ibdev *dev = to_idev(ibpd->device);
 +
 +	spin_lock(&dev->n_pds_lock);
 +	dev->n_pds_allocated--;
 +	spin_unlock(&dev->n_pds_lock);
 +
 +	kfree(pd);
 +
  	return 0;
  }
  
@@@ -2230,48 -1688,7 +2235,51 @@@ int qib_register_ib_device(struct qib_d
  	ibdev->modify_device = qib_modify_device;
  	ibdev->query_port = qib_query_port;
  	ibdev->modify_port = qib_modify_port;
++<<<<<<< HEAD
 +	ibdev->query_pkey = qib_query_pkey;
 +	ibdev->query_gid = qib_query_gid;
 +	ibdev->alloc_ucontext = qib_alloc_ucontext;
 +	ibdev->dealloc_ucontext = qib_dealloc_ucontext;
 +	ibdev->alloc_pd = qib_alloc_pd;
 +	ibdev->dealloc_pd = qib_dealloc_pd;
 +	ibdev->create_ah = qib_create_ah;
 +	ibdev->destroy_ah = qib_destroy_ah;
 +	ibdev->modify_ah = qib_modify_ah;
 +	ibdev->query_ah = qib_query_ah;
 +	ibdev->create_srq = qib_create_srq;
 +	ibdev->modify_srq = qib_modify_srq;
 +	ibdev->query_srq = qib_query_srq;
 +	ibdev->destroy_srq = qib_destroy_srq;
 +	ibdev->create_qp = qib_create_qp;
 +	ibdev->modify_qp = qib_modify_qp;
 +	ibdev->query_qp = qib_query_qp;
 +	ibdev->destroy_qp = qib_destroy_qp;
 +	ibdev->post_send = qib_post_send;
 +	ibdev->post_recv = qib_post_receive;
 +	ibdev->post_srq_recv = qib_post_srq_receive;
 +	ibdev->create_cq = qib_create_cq;
 +	ibdev->destroy_cq = qib_destroy_cq;
 +	ibdev->resize_cq = qib_resize_cq;
 +	ibdev->poll_cq = qib_poll_cq;
 +	ibdev->req_notify_cq = qib_req_notify_cq;
 +	ibdev->get_dma_mr = qib_get_dma_mr;
 +	ibdev->reg_phys_mr = qib_reg_phys_mr;
 +	ibdev->reg_user_mr = qib_reg_user_mr;
 +	ibdev->dereg_mr = qib_dereg_mr;
 +	ibdev->alloc_mr = qib_alloc_mr;
 +	ibdev->alloc_fast_reg_page_list = qib_alloc_fast_reg_page_list;
 +	ibdev->free_fast_reg_page_list = qib_free_fast_reg_page_list;
 +	ibdev->alloc_fmr = qib_alloc_fmr;
 +	ibdev->map_phys_fmr = qib_map_phys_fmr;
 +	ibdev->unmap_fmr = qib_unmap_fmr;
 +	ibdev->dealloc_fmr = qib_dealloc_fmr;
 +	ibdev->attach_mcast = qib_multicast_attach;
 +	ibdev->detach_mcast = qib_multicast_detach;
++=======
++>>>>>>> 2366754632d3 (IB/qib: Support query gid in rdmavt)
  	ibdev->process_mad = qib_process_mad;
 +	ibdev->mmap = qib_mmap;
 +	ibdev->dma_ops = NULL;
  	ibdev->get_port_immutable = qib_port_immutable;
  
  	snprintf(ibdev->node_desc, sizeof(ibdev->node_desc),
@@@ -2283,11 -1700,52 +2291,43 @@@
  	dd->verbs_dev.rdi.driver_f.port_callback = qib_create_port_files;
  	dd->verbs_dev.rdi.driver_f.get_card_name = qib_get_card_name;
  	dd->verbs_dev.rdi.driver_f.get_pci_dev = qib_get_pci_dev;
 -	dd->verbs_dev.rdi.driver_f.check_ah = qib_check_ah;
 -	dd->verbs_dev.rdi.driver_f.notify_new_ah = qib_notify_new_ah;
 -	dd->verbs_dev.rdi.driver_f.alloc_qpn = alloc_qpn;
 -	dd->verbs_dev.rdi.driver_f.qp_priv_alloc = qp_priv_alloc;
 -	dd->verbs_dev.rdi.driver_f.qp_priv_free = qp_priv_free;
 -	dd->verbs_dev.rdi.driver_f.free_all_qps = qib_free_all_qps;
 -	dd->verbs_dev.rdi.driver_f.notify_qp_reset = notify_qp_reset;
 -	dd->verbs_dev.rdi.driver_f.do_send = qib_do_send;
 -	dd->verbs_dev.rdi.driver_f.schedule_send = qib_schedule_send;
 -	dd->verbs_dev.rdi.driver_f.quiesce_qp = quiesce_qp;
 -	dd->verbs_dev.rdi.driver_f.stop_send_queue = stop_send_queue;
 -	dd->verbs_dev.rdi.driver_f.flush_qp_waiters = flush_qp_waiters;
 -	dd->verbs_dev.rdi.driver_f.notify_error_qp = notify_error_qp;
 -	dd->verbs_dev.rdi.driver_f.mtu_to_path_mtu = mtu_to_path_mtu;
 -	dd->verbs_dev.rdi.driver_f.mtu_from_qp = mtu_from_qp;
 -	dd->verbs_dev.rdi.driver_f.get_pmtu_from_attr = get_pmtu_from_attr;
 +	dd->verbs_dev.rdi.dparms.props.max_pd = ib_qib_max_pds;
 +	dd->verbs_dev.rdi.flags = (RVT_FLAG_MR_INIT_DRIVER |
 +				   RVT_FLAG_QP_INIT_DRIVER |
 +				   RVT_FLAG_CQ_INIT_DRIVER);
  
++<<<<<<< HEAD
++=======
+ 	dd->verbs_dev.rdi.dparms.max_rdma_atomic = QIB_MAX_RDMA_ATOMIC;
+ 	dd->verbs_dev.rdi.driver_f.get_guid_be = qib_get_guid_be;
+ 	dd->verbs_dev.rdi.dparms.lkey_table_size = qib_lkey_table_size;
+ 	dd->verbs_dev.rdi.dparms.qp_table_size = ib_qib_qp_table_size;
+ 	dd->verbs_dev.rdi.dparms.qpn_start = 1;
+ 	dd->verbs_dev.rdi.dparms.qpn_res_start = QIB_KD_QP;
+ 	dd->verbs_dev.rdi.dparms.qpn_res_end = QIB_KD_QP; /* Reserve one QP */
+ 	dd->verbs_dev.rdi.dparms.qpn_inc = 1;
+ 	dd->verbs_dev.rdi.dparms.qos_shift = 1;
+ 	dd->verbs_dev.rdi.dparms.psn_mask = QIB_PSN_MASK;
+ 	dd->verbs_dev.rdi.dparms.psn_shift = QIB_PSN_SHIFT;
+ 	dd->verbs_dev.rdi.dparms.psn_modify_mask = QIB_PSN_MASK;
+ 	dd->verbs_dev.rdi.dparms.nports = dd->num_pports;
+ 	dd->verbs_dev.rdi.dparms.npkeys = qib_get_npkeys(dd);
+ 	dd->verbs_dev.rdi.dparms.node = dd->assigned_node_id;
+ 	snprintf(dd->verbs_dev.rdi.dparms.cq_name,
+ 		 sizeof(dd->verbs_dev.rdi.dparms.cq_name),
+ 		 "qib_cq%d", dd->unit);
+ 
+ 	qib_fill_device_attr(dd);
+ 
+ 	ppd = dd->pport;
+ 	for (i = 0; i < dd->num_pports; i++, ppd++) {
+ 		ctxt = ppd->hw_pidx;
+ 		rvt_init_port(&dd->verbs_dev.rdi,
+ 			      &ppd->ibport_data.rvp,
+ 			      i,
+ 			      dd->rcd[ctxt]->pkeys);
+ 	}
++>>>>>>> 2366754632d3 (IB/qib: Support query gid in rdmavt)
  
  	ret = rvt_register_device(&dd->verbs_dev.rdi);
  	if (ret)
* Unmerged path drivers/infiniband/hw/qib/qib_verbs.c
