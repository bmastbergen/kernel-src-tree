ceph: simplify two mount_timeout sites

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ilya Dryomov <idryomov@gmail.com>
commit 5be73034771c8f18b241f1974803865a4de2cad1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5be73034.failed

No need to bifurcate wait now that we've got ceph_timeout_jiffies().

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
	Reviewed-by: Alex Elder <elder@linaro.org>
	Reviewed-by: Yan, Zheng <zyan@redhat.com>
(cherry picked from commit 5be73034771c8f18b241f1974803865a4de2cad1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/dir.c
#	fs/ceph/mds_client.c
diff --cc fs/ceph/dir.c
index 67bdd35eda74,3dec27e36417..000000000000
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@@ -1237,17 -1257,11 +1237,25 @@@ static int ceph_dir_fsync(struct file *
  
  		dout("dir_fsync %p wait on tid %llu (until %llu)\n",
  		     inode, req->r_tid, last_tid);
++<<<<<<< HEAD
 +		if (req->r_timeout) {
 +			unsigned long time_left = wait_for_completion_timeout(
 +							&req->r_safe_completion,
 +							req->r_timeout);
 +			if (time_left > 0)
 +				ret = 0;
 +			else
 +				ret = -EIO;  /* timed out */
 +		} else {
 +			wait_for_completion(&req->r_safe_completion);
 +		}
++=======
+ 		ret = !wait_for_completion_timeout(&req->r_safe_completion,
+ 					ceph_timeout_jiffies(req->r_timeout));
+ 		if (ret)
+ 			ret = -EIO;  /* timed out */
+ 
++>>>>>>> 5be73034771c (ceph: simplify two mount_timeout sites)
  		ceph_mdsc_put_request(req);
  
  		spin_lock(&ci->i_unsafe_lock);
diff --cc fs/ceph/mds_client.c
index fd7b72499c76,5be2d287a26c..000000000000
--- a/fs/ceph/mds_client.c
+++ b/fs/ceph/mds_client.c
@@@ -2266,15 -2266,18 +2266,27 @@@ int ceph_mdsc_do_request(struct ceph_md
  	/* wait */
  	mutex_unlock(&mdsc->mutex);
  	dout("do_request waiting\n");
++<<<<<<< HEAD
 +	if (req->r_timeout) {
 +		err = (long)wait_for_completion_killable_timeout(
 +			&req->r_completion, req->r_timeout);
 +		if (err == 0)
 +			err = -EIO;
 +	} else if (req->r_wait_for_completion) {
++=======
+ 	if (!req->r_timeout && req->r_wait_for_completion) {
++>>>>>>> 5be73034771c (ceph: simplify two mount_timeout sites)
  		err = req->r_wait_for_completion(mdsc, req);
  	} else {
- 		err = wait_for_completion_killable(&req->r_completion);
+ 		long timeleft = wait_for_completion_killable_timeout(
+ 					&req->r_completion,
+ 					ceph_timeout_jiffies(req->r_timeout));
+ 		if (timeleft > 0)
+ 			err = 0;
+ 		else if (!timeleft)
+ 			err = -EIO;  /* timed out */
+ 		else
+ 			err = timeleft;  /* killed */
  	}
  	dout("do_request waited, got %d\n", err);
  	mutex_lock(&mdsc->mutex);
* Unmerged path fs/ceph/dir.c
* Unmerged path fs/ceph/mds_client.c
