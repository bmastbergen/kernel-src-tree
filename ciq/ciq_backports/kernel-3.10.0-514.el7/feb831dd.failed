IB/hfi1: Use the neighbor link down reason only when valid

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dean Luick <dean.luick@intel.com>
commit feb831ddf2f2cfbc4d26d9df3a982790f6fbbf6a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/feb831dd.failed

The 8051 uses a link down reason to inform the driver why the
link went down.  The neighbor planned link down reason code is
only valid when a link down idle message is received by the 8051.
Enhance the explanation on why the link went down.

	Reviewed-by: Easwar Hariharan <easwar.hariharan@intel.com>
	Signed-off-by: Dean Luick <dean.luick@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit feb831ddf2f2cfbc4d26d9df3a982790f6fbbf6a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/chip.c
diff --cc drivers/staging/hfi1/chip.c
index 6f8d1a8ae6f4,45ff8aea9132..000000000000
--- a/drivers/staging/hfi1/chip.c
+++ b/drivers/staging/hfi1/chip.c
@@@ -6834,21 -6890,64 +6904,68 @@@ static const char *link_down_reason_str
  void handle_link_down(struct work_struct *work)
  {
  	u8 lcl_reason, neigh_reason = 0;
+ 	u8 link_down_reason;
  	struct hfi1_pportdata *ppd = container_of(work, struct hfi1_pportdata,
- 								link_down_work);
+ 						  link_down_work);
+ 	int was_up;
+ 	static const char ldr_str[] = "Link down reason: ";
  
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +	/* go offline first, then deal with reasons */
++=======
+ 	if ((ppd->host_link_state &
+ 	     (HLS_DN_POLL | HLS_VERIFY_CAP | HLS_GOING_UP)) &&
+ 	     ppd->port_type == PORT_TYPE_FIXED)
+ 		ppd->offline_disabled_reason =
+ 			HFI1_ODR_MASK(OPA_LINKDOWN_REASON_NOT_INSTALLED);
+ 
+ 	/* Go offline first, then deal with reading/writing through 8051 */
+ 	was_up = !!(ppd->host_link_state & HLS_UP);
++>>>>>>> feb831ddf2f2 (IB/hfi1: Use the neighbor link down reason only when valid):drivers/staging/rdma/hfi1/chip.c
  	set_link_state(ppd, HLS_DN_OFFLINE);
  
- 	lcl_reason = 0;
- 	read_planned_down_reason_code(ppd->dd, &neigh_reason);
+ 	if (was_up) {
+ 		lcl_reason = 0;
+ 		/* link down reason is only valid if the link was up */
+ 		read_link_down_reason(ppd->dd, &link_down_reason);
+ 		switch (link_down_reason) {
+ 		case LDR_LINK_TRANSFER_ACTIVE_LOW:
+ 			/* the link went down, no idle message reason */
+ 			dd_dev_info(ppd->dd, "%sUnexpected link down\n",
+ 				    ldr_str);
+ 			break;
+ 		case LDR_RECEIVED_LINKDOWN_IDLE_MSG:
+ 			/*
+ 			 * The neighbor reason is only valid if an idle message
+ 			 * was received for it.
+ 			 */
+ 			read_planned_down_reason_code(ppd->dd, &neigh_reason);
+ 			dd_dev_info(ppd->dd,
+ 				    "%sNeighbor link down message %d, %s\n",
+ 				    ldr_str, neigh_reason,
+ 				    link_down_reason_str(neigh_reason));
+ 			break;
+ 		case LDR_RECEIVED_HOST_OFFLINE_REQ:
+ 			dd_dev_info(ppd->dd,
+ 				    "%sHost requested link to go offline\n",
+ 				    ldr_str);
+ 			break;
+ 		default:
+ 			dd_dev_info(ppd->dd, "%sUnknown reason 0x%x\n",
+ 				    ldr_str, link_down_reason);
+ 			break;
+ 		}
  
- 	/*
- 	 * If no reason, assume peer-initiated but missed
- 	 * LinkGoingDown idle flits.
- 	 */
- 	if (neigh_reason == 0)
- 		lcl_reason = OPA_LINKDOWN_REASON_NEIGHBOR_UNKNOWN;
+ 		/*
+ 		 * If no reason, assume peer-initiated but missed
+ 		 * LinkGoingDown idle flits.
+ 		 */
+ 		if (neigh_reason == 0)
+ 			lcl_reason = OPA_LINKDOWN_REASON_NEIGHBOR_UNKNOWN;
+ 	} else {
+ 		/* went down while polling or going up */
+ 		lcl_reason = OPA_LINKDOWN_REASON_TRANSIENT;
+ 	}
  
  	set_link_down_reason(ppd, lcl_reason, neigh_reason, 0);
  
* Unmerged path drivers/staging/hfi1/chip.c
diff --git a/drivers/staging/hfi1/chip.h b/drivers/staging/hfi1/chip.h
index dc82815c53a0..11f65609b3f4 100644
--- a/drivers/staging/hfi1/chip.h
+++ b/drivers/staging/hfi1/chip.h
@@ -386,6 +386,7 @@
 #define LAST_REMOTE_STATE_COMPLETE   0x13
 #define LINK_QUALITY_INFO            0x14
 #define REMOTE_DEVICE_ID	     0x15
+#define LINK_DOWN_REASON	     0x16
 
 /* Lane ID for general configuration registers */
 #define GENERAL_CONFIG 4
@@ -490,6 +491,11 @@
 #define PWRM_BER_CONTROL	0x1
 #define PWRM_BANDWIDTH_CONTROL	0x2
 
+/* 8051 link down reasons */
+#define LDR_LINK_TRANSFER_ACTIVE_LOW   0xa
+#define LDR_RECEIVED_LINKDOWN_IDLE_MSG 0xb
+#define LDR_RECEIVED_HOST_OFFLINE_REQ  0xc
+
 /* verify capability fabric CRC size bits */
 enum {
 	CAP_CRC_14B = (1 << 0), /* 14b CRC */
