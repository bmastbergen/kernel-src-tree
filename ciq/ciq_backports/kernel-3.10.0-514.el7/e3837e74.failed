tpm_tis: Refactor the interrupt setup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
commit e3837e74a06dc38ab79529758a3667fbff2fdc17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e3837e74.failed

Now that the probe and run cases are merged together we can use a
much simpler setup flow where probe and normal setup are done with
exactly the same code.

Since the new flow always calls tpm_gen_interrupt to confirm the IRQ
there is also no longer any need to call tpm_get_timeouts twice.

	Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
	Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Tested-by: Martin Wilck <Martin.Wilck@ts.fujitsu.com>
	Tested-by: Scot Doyle <lkml14@scotdoyle.com>
	Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Acked-by: Peter Huewe <peterhuewe@gmx.de>
(cherry picked from commit e3837e74a06dc38ab79529758a3667fbff2fdc17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm_tis.c
diff --cc drivers/char/tpm/tpm_tis.c
index b6392eb21cdb,c29ae69f1df6..000000000000
--- a/drivers/char/tpm/tpm_tis.c
+++ b/drivers/char/tpm/tpm_tis.c
@@@ -582,13 -691,11 +651,12 @@@ static void tpm_tis_remove(struct tpm_c
  	release_locality(chip, chip->vendor.locality, 1);
  }
  
 -static int tpm_tis_init(struct device *dev, struct tpm_info *tpm_info,
 -			acpi_handle acpi_dev_handle)
 +static int tpm_tis_init(struct device *dev, acpi_handle acpi_dev_handle,
 +			resource_size_t start, resource_size_t len,
 +			unsigned int irq)
  {
  	u32 vendor, intfcaps, intmask;
- 	int rc, i, irq_s, irq_e, probe;
- 	int irq_r = -1;
+ 	int rc, probe;
  	struct tpm_chip *chip;
  	struct priv_data *priv;
  
@@@ -696,98 -803,14 +764,109 @@@
  	/* INTERRUPT Setup */
  	init_waitqueue_head(&chip->vendor.read_queue);
  	init_waitqueue_head(&chip->vendor.int_queue);
++<<<<<<< HEAD
 +
 +	if (interrupts)
 +		chip->vendor.irq = irq;
 +	if (interrupts && !chip->vendor.irq) {
 +		irq_s =
 +		    ioread8(chip->vendor.iobase +
 +			    TPM_INT_VECTOR(chip->vendor.locality));
 +		irq_r = irq_s;
 +		if (irq_s) {
 +			irq_e = irq_s;
 +		} else {
 +			irq_s = 3;
 +			irq_e = 15;
 +		}
 +
 +		for (i = irq_s; i <= irq_e && chip->vendor.irq == 0; i++) {
 +			iowrite8(i, chip->vendor.iobase +
 +				 TPM_INT_VECTOR(chip->vendor.locality));
 +			if (devm_request_irq
 +			    (dev, i, tis_int_handler, IRQF_SHARED,
 +			     chip->devname, chip) != 0) {
 +				dev_info(chip->pdev,
 +					 "Unable to request irq: %d for probe\n",
 +					 i);
 +				continue;
 +			}
 +			chip->vendor.irq = i;
 +
 +			/* Clear all existing */
 +			iowrite32(ioread32
 +				  (chip->vendor.iobase +
 +				   TPM_INT_STATUS(chip->vendor.locality)),
 +				  chip->vendor.iobase +
 +				  TPM_INT_STATUS(chip->vendor.locality));
 +
 +			/* Turn on */
 +			iowrite32(intmask | TPM_GLOBAL_INT_ENABLE,
 +				  chip->vendor.iobase +
 +				  TPM_INT_ENABLE(chip->vendor.locality));
 +
 +			priv->irq_tested = false;
 +			priv->irq_probing = true;
 +
 +			/* Generate Interrupts */
 +			if (chip->flags & TPM_CHIP_FLAG_TPM2)
 +				tpm2_gen_interrupt(chip);
 +			else
 +				tpm_gen_interrupt(chip);
 +
 +			priv->irq_probing = false;
 +
 +			/* tpm_tis_send will either confirm the interrupt is
 +			 * working or it will call disable_irq which undoes
 +			 * all of the above.
 +			 */
 +			if (chip->vendor.irq)
 +				break;
 +		}
 +		if (!chip->vendor.irq)
 +			iowrite8(irq_r, chip->vendor.iobase +
 +				 TPM_INT_VECTOR(chip->vendor.locality));
 +	}
 +	if (chip->vendor.irq && !priv->irq_tested) {
 +		iowrite8(chip->vendor.irq,
 +			 chip->vendor.iobase +
 +			 TPM_INT_VECTOR(chip->vendor.locality));
 +		if (devm_request_irq
 +		    (dev, chip->vendor.irq, tis_int_handler, IRQF_SHARED,
 +		     chip->devname, chip) != 0) {
 +			dev_info(chip->pdev,
 +				 "Unable to request irq: %d for use\n",
 +				 chip->vendor.irq);
 +			chip->vendor.irq = 0;
 +		} else {
 +			/* Clear all existing */
 +			iowrite32(ioread32
 +				  (chip->vendor.iobase +
 +				   TPM_INT_STATUS(chip->vendor.locality)),
 +				  chip->vendor.iobase +
 +				  TPM_INT_STATUS(chip->vendor.locality));
 +
 +			/* Turn on */
 +			iowrite32(intmask | TPM_GLOBAL_INT_ENABLE,
 +				  chip->vendor.iobase +
 +				  TPM_INT_ENABLE(chip->vendor.locality));
 +		}
 +	}
 +
 +	if (tpm_get_timeouts(chip)) {
 +		dev_err(dev, "Could not get TPM timeouts and durations\n");
 +		rc = -ENODEV;
 +		goto out_err;
++=======
+ 	if (interrupts) {
+ 		if (tpm_info->irq) {
+ 			tpm_tis_probe_irq_single(chip, intmask, tpm_info->irq);
+ 			if (!chip->vendor.irq)
+ 				dev_err(chip->pdev, FW_BUG
+ 					"TPM interrupt not working, polling instead\n");
+ 		} else
+ 			tpm_tis_probe_irq(chip, intmask);
++>>>>>>> e3837e74a06d (tpm_tis: Refactor the interrupt setup)
  	}
  
  	if (chip->flags & TPM_CHIP_FLAG_TPM2) {
* Unmerged path drivers/char/tpm/tpm_tis.c
