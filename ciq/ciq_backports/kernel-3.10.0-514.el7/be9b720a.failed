NFC: mei_phy: move all nfc logic from mei driver to nfc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [nfc] mei_phy: move all nfc logic from mei driver to nfc (Jeremy McNicoll) [1273503]
Rebuild_FUZZ: 95.24%
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit be9b720a0ccba096d669bc86634f900b82b9bf71
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/be9b720a.failed

move nfc logic to mei_phy module, we prefer as much as
possible not to deal with a particualr client protocol
in the mei generic infrasutcutre

	Cc: Samuel Ortiz <sameo@linux.intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit be9b720a0ccba096d669bc86634f900b82b9bf71)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/bus.c
#	drivers/misc/mei/mei_dev.h
#	drivers/misc/mei/nfc.c
#	drivers/nfc/mei_phy.c
diff --cc drivers/misc/mei/bus.c
index ca8736c3675b,de8fd089a8a4..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -153,26 -216,27 +153,43 @@@ static struct mei_cl *mei_bus_find_mei_
  
  	return NULL;
  }
 -
  struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
++<<<<<<< HEAD
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops)
++=======
+ 					struct mei_me_client *me_cl,
+ 					struct mei_cl *cl,
+ 					char *name)
++>>>>>>> be9b720a0ccb (NFC: mei_phy: move all nfc logic from mei driver to nfc)
  {
  	struct mei_cl_device *device;
 +	struct mei_cl *cl;
  	int status;
  
 +	cl = mei_bus_find_mei_cl_by_uuid(dev, uuid);
 +	if (cl == NULL)
 +		return NULL;
 +
  	device = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
  	if (!device)
  		return NULL;
  
++<<<<<<< HEAD
 +	device->cl = cl;
 +	device->ops = ops;
 +
 +	device->dev.parent = &dev->pdev->dev;
++=======
+ 	device->me_cl = mei_me_cl_get(me_cl);
+ 	if (!device->me_cl) {
+ 		kfree(device);
+ 		return NULL;
+ 	}
+ 
+ 	device->cl = cl;
+ 	device->dev.parent = dev->dev;
++>>>>>>> be9b720a0ccb (NFC: mei_phy: move all nfc logic from mei driver to nfc)
  	device->dev.bus = &mei_cl_bus_type;
  	device->dev.type = &mei_cl_device_type;
  
@@@ -225,7 -292,7 +242,11 @@@ void mei_cl_driver_unregister(struct me
  }
  EXPORT_SYMBOL_GPL(mei_cl_driver_unregister);
  
++<<<<<<< HEAD
 +static int ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
++=======
+ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
++>>>>>>> be9b720a0ccb (NFC: mei_phy: move all nfc logic from mei driver to nfc)
  			bool blocking)
  {
  	struct mei_device *dev;
@@@ -329,20 -403,10 +350,24 @@@ int __mei_cl_recv(struct mei_cl *cl, u
  out:
  	mutex_unlock(&dev->device_lock);
  
 -	return rets;
 +	return r_length;
 +}
 +
++<<<<<<< HEAD
 +inline int __mei_cl_async_send(struct mei_cl *cl, u8 *buf, size_t length)
 +{
 +	return ___mei_cl_send(cl, buf, length, 0);
 +}
 +
 +inline int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length)
 +{
 +	return ___mei_cl_send(cl, buf, length, 1);
  }
  
 +int mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
++=======
+ ssize_t mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
++>>>>>>> be9b720a0ccb (NFC: mei_phy: move all nfc logic from mei driver to nfc)
  {
  	struct mei_cl *cl = device->cl;
  
@@@ -356,9 -417,9 +378,9 @@@
  }
  EXPORT_SYMBOL_GPL(mei_cl_send);
  
 -ssize_t mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length)
 +int mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length)
  {
- 	struct mei_cl *cl =  device->cl;
+ 	struct mei_cl *cl = device->cl;
  
  	if (cl == NULL)
  		return -ENODEV;
@@@ -437,13 -501,10 +456,10 @@@ int mei_cl_enable_device(struct mei_cl_
  
  	mutex_unlock(&dev->device_lock);
  
 -	if (device->event_cb)
 -		mei_cl_read_start(device->cl, 0, NULL);
 +	if (device->event_cb && !cl->read_cb)
 +		mei_cl_read_start(device->cl, 0);
  
- 	if (!device->ops || !device->ops->enable)
- 		return 0;
- 
- 	return device->ops->enable(device);
+ 	return 0;
  }
  EXPORT_SYMBOL_GPL(mei_cl_enable_device);
  
@@@ -458,24 -519,20 +474,29 @@@ int mei_cl_disable_device(struct mei_cl
  
  	dev = cl->dev;
  
++<<<<<<< HEAD
++=======
+ 	device->event_cb = NULL;
+ 
++>>>>>>> be9b720a0ccb (NFC: mei_phy: move all nfc logic from mei driver to nfc)
  	mutex_lock(&dev->device_lock);
  
 -	if (!mei_cl_is_connected(cl)) {
 -		dev_err(dev->dev, "Already disconnected");
 -		err = 0;
 -		goto out;
 +	if (cl->state != MEI_FILE_CONNECTED) {
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev, "Already disconnected");
 +
 +		return 0;
  	}
  
 +	cl->state = MEI_FILE_DISCONNECTING;
 +
  	err = mei_cl_disconnect(cl);
  	if (err < 0) {
 -		dev_err(dev->dev, "Could not disconnect from the ME client");
 -		goto out;
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev,
 +			"Could not disconnect from the ME client");
 +
 +		return err;
  	}
  
  	/* Flush queues and remove any pending read */
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,2175bff2730f..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -311,13 -350,14 +311,24 @@@ struct mei_cl_ops 
  };
  
  struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
++<<<<<<< HEAD
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops);
 +void mei_cl_remove_device(struct mei_cl_device *device);
 +
 +int __mei_cl_async_send(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
++=======
+ 					struct mei_me_client *me_cl,
+ 					struct mei_cl *cl,
+ 					char *name);
+ void mei_cl_remove_device(struct mei_cl_device *device);
+ 
+ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
+ 			bool blocking);
+ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
++>>>>>>> be9b720a0ccb (NFC: mei_phy: move all nfc logic from mei driver to nfc)
  void mei_cl_bus_rx_event(struct mei_cl *cl);
  void mei_cl_bus_remove_devices(struct mei_device *dev);
  int mei_cl_bus_init(void);
diff --cc drivers/misc/mei/nfc.c
index 2b65e8021f0d,b983c4ecad38..000000000000
--- a/drivers/misc/mei/nfc.c
+++ b/drivers/misc/mei/nfc.c
@@@ -95,8 -98,11 +95,13 @@@ struct mei_nfc_hci_hdr 
   * @fw_ivn: NFC Interface Version Number
   * @vendor_id: NFC manufacturer ID
   * @radio_type: NFC radio type
++<<<<<<< HEAD
++=======
+  * @bus_name: bus name
+  *
++>>>>>>> be9b720a0ccb (NFC: mei_phy: move all nfc logic from mei driver to nfc)
   */
  struct mei_nfc_dev {
 -	struct mei_me_client *me_cl;
  	struct mei_cl *cl;
  	struct mei_cl *cl_info;
  	struct work_struct init_work;
@@@ -105,13 -110,8 +109,10 @@@
  	u8 vendor_id;
  	u8 radio_type;
  	char *bus_name;
- 
- 	u16 req_id;
- 	u16 recv_req_id;
  };
  
 +static struct mei_nfc_dev nfc_dev;
 +
  /* UUIDs for NFC F/W clients */
  const uuid_le mei_nfc_guid = UUID_LE(0x0bb17a78, 0x2a8e, 0x4c50,
  				     0x94, 0xd4, 0x50, 0x26,
@@@ -191,73 -195,6 +192,76 @@@ static int mei_nfc_build_bus_name(struc
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int mei_nfc_connect(struct mei_nfc_dev *ndev)
 +{
 +	struct mei_device *dev;
 +	struct mei_cl *cl;
 +	struct mei_nfc_cmd *cmd, *reply;
 +	struct mei_nfc_connect *connect;
 +	struct mei_nfc_connect_resp *connect_resp;
 +	size_t connect_length, connect_resp_length;
 +	int bytes_recv, ret;
 +
 +	cl = ndev->cl;
 +	dev = cl->dev;
 +
 +	connect_length = sizeof(struct mei_nfc_cmd) +
 +			sizeof(struct mei_nfc_connect);
 +
 +	connect_resp_length = sizeof(struct mei_nfc_cmd) +
 +			sizeof(struct mei_nfc_connect_resp);
 +
 +	cmd = kzalloc(connect_length, GFP_KERNEL);
 +	if (!cmd)
 +		return -ENOMEM;
 +	connect = (struct mei_nfc_connect *)cmd->data;
 +
 +	reply = kzalloc(connect_resp_length, GFP_KERNEL);
 +	if (!reply) {
 +		kfree(cmd);
 +		return -ENOMEM;
 +	}
 +
 +	connect_resp = (struct mei_nfc_connect_resp *)reply->data;
 +
 +	cmd->command = MEI_NFC_CMD_MAINTENANCE;
 +	cmd->data_size = 3;
 +	cmd->sub_command = MEI_NFC_SUBCMD_CONNECT;
 +	connect->fw_ivn = ndev->fw_ivn;
 +	connect->vendor_id = ndev->vendor_id;
 +
 +	ret = __mei_cl_send(cl, (u8 *)cmd, connect_length);
 +	if (ret < 0) {
 +		dev_err(&dev->pdev->dev, "Could not send connect cmd\n");
 +		goto err;
 +	}
 +
 +	bytes_recv = __mei_cl_recv(cl, (u8 *)reply, connect_resp_length);
 +	if (bytes_recv < 0) {
 +		dev_err(&dev->pdev->dev, "Could not read connect response\n");
 +		ret = bytes_recv;
 +		goto err;
 +	}
 +
 +	dev_info(&dev->pdev->dev, "IVN 0x%x Vendor ID 0x%x\n",
 +		 connect_resp->fw_ivn, connect_resp->vendor_id);
 +
 +	dev_info(&dev->pdev->dev, "ME FW %d.%d.%d.%d\n",
 +		connect_resp->me_major, connect_resp->me_minor,
 +		connect_resp->me_hotfix, connect_resp->me_build);
 +
 +	ret = 0;
 +
 +err:
 +	kfree(reply);
 +	kfree(cmd);
 +
 +	return ret;
 +}
 +
++=======
++>>>>>>> be9b720a0ccb (NFC: mei_phy: move all nfc logic from mei driver to nfc)
  static int mei_nfc_if_version(struct mei_nfc_dev *ndev)
  {
  	struct mei_device *dev;
@@@ -277,9 -214,9 +281,9 @@@
  	cmd.data_size = 1;
  	cmd.sub_command = MEI_NFC_SUBCMD_IF_VERSION;
  
- 	ret = __mei_cl_send(cl, (u8 *)&cmd, sizeof(struct mei_nfc_cmd));
+ 	ret = __mei_cl_send(cl, (u8 *)&cmd, sizeof(struct mei_nfc_cmd), 1);
  	if (ret < 0) {
 -		dev_err(dev->dev, "Could not send IF version cmd\n");
 +		dev_err(&dev->pdev->dev, "Could not send IF version cmd\n");
  		return ret;
  	}
  
@@@ -309,100 -246,6 +313,103 @@@ err
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int mei_nfc_enable(struct mei_cl_device *cldev)
 +{
 +	struct mei_device *dev;
 +	struct mei_nfc_dev *ndev = &nfc_dev;
 +	int ret;
 +
 +	dev = ndev->cl->dev;
 +
 +	ret = mei_nfc_connect(ndev);
 +	if (ret < 0) {
 +		dev_err(&dev->pdev->dev, "Could not connect to NFC");
 +		return ret;
 +	}
 +
 +	return 0;
 +}
 +
 +static int mei_nfc_disable(struct mei_cl_device *cldev)
 +{
 +	return 0;
 +}
 +
 +static int mei_nfc_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
 +{
 +	struct mei_device *dev;
 +	struct mei_nfc_dev *ndev;
 +	struct mei_nfc_hci_hdr *hdr;
 +	u8 *mei_buf;
 +	int err;
 +
 +	ndev = (struct mei_nfc_dev *) cldev->priv_data;
 +	dev = ndev->cl->dev;
 +
 +	mei_buf = kzalloc(length + MEI_NFC_HEADER_SIZE, GFP_KERNEL);
 +	if (!mei_buf)
 +		return -ENOMEM;
 +
 +	hdr = (struct mei_nfc_hci_hdr *) mei_buf;
 +	hdr->cmd = MEI_NFC_CMD_HCI_SEND;
 +	hdr->status = 0;
 +	hdr->req_id = ndev->req_id;
 +	hdr->reserved = 0;
 +	hdr->data_size = length;
 +
 +	memcpy(mei_buf + MEI_NFC_HEADER_SIZE, buf, length);
 +
 +	err = __mei_cl_send(ndev->cl, mei_buf, length + MEI_NFC_HEADER_SIZE);
 +	if (err < 0)
 +		return err;
 +
 +	kfree(mei_buf);
 +
 +	if (!wait_event_interruptible_timeout(ndev->send_wq,
 +				ndev->recv_req_id == ndev->req_id, HZ)) {
 +		dev_err(&dev->pdev->dev, "NFC MEI command timeout\n");
 +		err = -ETIME;
 +	} else {
 +		ndev->req_id++;
 +	}
 +
 +	return err;
 +}
 +
 +static int mei_nfc_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
 +{
 +	struct mei_nfc_dev *ndev;
 +	struct mei_nfc_hci_hdr *hci_hdr;
 +	int received_length;
 +
 +	ndev = (struct mei_nfc_dev *)cldev->priv_data;
 +
 +	received_length = __mei_cl_recv(ndev->cl, buf, length);
 +	if (received_length < 0)
 +		return received_length;
 +
 +	hci_hdr = (struct mei_nfc_hci_hdr *) buf;
 +
 +	if (hci_hdr->cmd == MEI_NFC_CMD_HCI_SEND) {
 +		ndev->recv_req_id = hci_hdr->req_id;
 +		wake_up(&ndev->send_wq);
 +
 +		return 0;
 +	}
 +
 +	return received_length;
 +}
 +
 +static struct mei_cl_ops nfc_ops = {
 +	.enable = mei_nfc_enable,
 +	.disable = mei_nfc_disable,
 +	.send = mei_nfc_send,
 +	.recv = mei_nfc_recv,
 +};
 +
++=======
++>>>>>>> be9b720a0ccb (NFC: mei_phy: move all nfc logic from mei driver to nfc)
  static void mei_nfc_init(struct work_struct *work)
  {
  	struct mei_device *dev;
@@@ -455,10 -304,10 +462,15 @@@
  		return;
  	}
  
++<<<<<<< HEAD
 +	cldev = mei_cl_add_device(dev, mei_nfc_guid, ndev->bus_name, &nfc_ops);
++=======
+ 	cldev = mei_cl_add_device(dev, ndev->me_cl, ndev->cl,
+ 				  ndev->bus_name);
++>>>>>>> be9b720a0ccb (NFC: mei_phy: move all nfc logic from mei driver to nfc)
  	if (!cldev) {
 -		dev_err(dev->dev, "Could not add the NFC device to the MEI bus\n");
 +		dev_err(&dev->pdev->dev,
 +			"Could not add the NFC device to the MEI bus\n");
  
  		goto err;
  	}
@@@ -523,21 -367,11 +535,18 @@@ int mei_nfc_host_init(struct mei_devic
  		goto err;
  	}
  
 -	list_add_tail(&cl->device_link, &dev->device_list);
 +	cl->me_client_id = dev->me_clients[i].client_id;
 +
 +	ret = mei_cl_link(cl, MEI_HOST_CLIENT_ID_ANY);
 +	if (ret)
 +		goto err;
 +
 +	cl->device_uuid = mei_nfc_guid;
 +
  
 -	ndev->cl = cl;
 +	list_add_tail(&cl->device_link, &dev->device_list);
  
- 	ndev->req_id = 1;
- 
  	INIT_WORK(&ndev->init_work, mei_nfc_init);
- 	init_waitqueue_head(&ndev->send_wq);
  	schedule_work(&ndev->init_work);
  
  	return 0;
diff --cc drivers/nfc/mei_phy.c
index 606bf55e76ec,7f1495d649bb..000000000000
--- a/drivers/nfc/mei_phy.c
+++ b/drivers/nfc/mei_phy.c
@@@ -55,33 -115,50 +115,62 @@@ static int mei_nfc_if_version(struct nf
  
  	pr_info("%s\n", __func__);
  
- 	if (phy->powered == 1)
- 		return 0;
+ 	memset(&cmd, 0, sizeof(struct mei_nfc_cmd));
+ 	cmd.command = MEI_NFC_CMD_MAINTENANCE;
+ 	cmd.data_size = 1;
+ 	cmd.sub_command = MEI_NFC_SUBCMD_IF_VERSION;
  
- 	r = mei_cl_enable_device(phy->device);
+ 	r = mei_cl_send(phy->device, (u8 *)&cmd, sizeof(struct mei_nfc_cmd));
  	if (r < 0) {
++<<<<<<< HEAD
 +		pr_err("MEI_PHY: Could not enable device\n");
 +		return r;
 +	}
 +
 +	r = mei_cl_register_event_cb(phy->device, nfc_mei_event_cb, phy);
 +	if (r) {
 +		pr_err("MEY_PHY: Event cb registration failed\n");
 +		mei_cl_disable_device(phy->device);
 +		phy->powered = 0;
- 
++=======
+ 		pr_err("Could not send IF version cmd\n");
  		return r;
  	}
  
- 	phy->powered = 1;
+ 	/* to be sure on the stack we alloc memory */
+ 	if_version_length = sizeof(struct mei_nfc_reply) +
+ 		sizeof(struct mei_nfc_if_version);
++>>>>>>> be9b720a0ccb (NFC: mei_phy: move all nfc logic from mei driver to nfc)
  
- 	return 0;
+ 	reply = kzalloc(if_version_length, GFP_KERNEL);
+ 	if (!reply)
+ 		return -ENOMEM;
+ 
+ 	bytes_recv = mei_cl_recv(phy->device, (u8 *)reply, if_version_length);
+ 	if (bytes_recv < 0 || bytes_recv < sizeof(struct mei_nfc_reply)) {
+ 		pr_err("Could not read IF version\n");
+ 		r = -EIO;
+ 		goto err;
+ 	}
+ 
+ 	version = (struct mei_nfc_if_version *)reply->data;
+ 
+ 	phy->fw_ivn = version->fw_ivn;
+ 	phy->vendor_id = version->vendor_id;
+ 	phy->radio_type = version->radio_type;
+ 
+ err:
+ 	kfree(reply);
+ 	return r;
  }
- EXPORT_SYMBOL_GPL(nfc_mei_phy_enable);
  
- void nfc_mei_phy_disable(void *phy_id)
+ static int mei_nfc_connect(struct nfc_mei_phy *phy)
  {
- 	struct nfc_mei_phy *phy = phy_id;
+ 	struct mei_nfc_cmd *cmd, *reply;
+ 	struct mei_nfc_connect *connect;
+ 	struct mei_nfc_connect_resp *connect_resp;
+ 	size_t connect_length, connect_resp_length;
+ 	int bytes_recv, r;
  
  	pr_info("%s\n", __func__);
  
@@@ -125,9 -308,9 +320,9 @@@ static void nfc_mei_event_cb(struct mei
  		if (!skb)
  			return;
  
- 		reply_size = mei_cl_recv(device, skb->data, MEI_NFC_MAX_READ);
+ 		reply_size = mei_nfc_recv(phy, skb->data, MEI_NFC_MAX_READ);
  		if (reply_size < MEI_NFC_HEADER_SIZE) {
 -			kfree_skb(skb);
 +			kfree(skb);
  			return;
  		}
  
* Unmerged path drivers/misc/mei/bus.c
* Unmerged path drivers/misc/mei/mei_dev.h
* Unmerged path drivers/misc/mei/nfc.c
* Unmerged path drivers/nfc/mei_phy.c
diff --git a/drivers/nfc/mei_phy.h b/drivers/nfc/mei_phy.h
index d669900f8278..c824e3b77f86 100644
--- a/drivers/nfc/mei_phy.h
+++ b/drivers/nfc/mei_phy.h
@@ -7,23 +7,42 @@
 #define MEI_NFC_HEADER_SIZE 10
 #define MEI_NFC_MAX_HCI_PAYLOAD 300
 
+/**
+ * struct nfc_mei_phy
+ *
+ * @device: mei device
+ * @hdev:   nfc hci device
+
+ * @send_wq: send completion wait queue
+ * @fw_ivn: NFC Interface Version Number
+ * @vendor_id: NFC manufacturer ID
+ * @radio_type: NFC radio type
+ * @reserved: reserved for alignment
+ * @req_id:  message counter
+ * @recv_req_id: reception message counter
+ * @powered: the device is in powered state
+ * @hard_fault: < 0 if hardware error occurred
+ *    and prevents normal operation.
+ */
 struct nfc_mei_phy {
 	struct mei_cl_device *device;
 	struct nfc_hci_dev *hdev;
 
-	int powered;
+	wait_queue_head_t send_wq;
+	u8 fw_ivn;
+	u8 vendor_id;
+	u8 radio_type;
+	u8 reserved;
+
+	u16 req_id;
+	u16 recv_req_id;
 
-	int hard_fault;		/*
-				 * < 0 if hardware error occured
-				 * and prevents normal operation.
-				 */
+	int powered;
+	int hard_fault;
 };
 
 extern struct nfc_phy_ops mei_phy_ops;
 
-int nfc_mei_phy_enable(void *phy_id);
-void nfc_mei_phy_disable(void *phy_id);
-void nfc_mei_event_cb(struct mei_cl_device *device, u32 events, void *context);
 struct nfc_mei_phy *nfc_mei_phy_alloc(struct mei_cl_device *device);
 void nfc_mei_phy_free(struct nfc_mei_phy *phy);
 
