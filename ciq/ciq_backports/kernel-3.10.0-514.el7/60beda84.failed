perf: Untangle 'owner' confusion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit 60beda849343494b2a598b927630bbe293c1cc6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/60beda84.failed

There are two concepts of owner wrt an event and they are conflated:

 - event::owner / event::owner_list,
   used by prctl(.option = PR_TASK_PERF_EVENTS_{EN,DIS}ABLE).

 - the 'owner' of the event object, typically the file descriptor.

Currently these two concepts are conflated, which gives trouble with
scm_rights passing of file descriptors. Passing the event and then
closing the creating task would render the event 'orphan' and would
have it cleared out. Unlikely what is expectd.

This patch untangles these two concepts by using PERF_EVENT_STATE_EXIT
to denote the second type.

	Reported-by: Alexei Starovoitov <alexei.starovoitov@gmail.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 60beda849343494b2a598b927630bbe293c1cc6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/core.c
diff --cc kernel/events/core.c
index e086d60d319b,e549cf2accdd..000000000000
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@@ -1517,7 -1650,7 +1517,11 @@@ out
   */
  static bool is_orphaned_event(struct perf_event *event)
  {
++<<<<<<< HEAD
 +	return event && !is_kernel_event(event) && !event->owner;
++=======
+ 	return event && event->state == PERF_EVENT_STATE_EXIT;
++>>>>>>> 60beda849343 (perf: Untangle 'owner' confusion)
  }
  
  /*
@@@ -1631,21 -1770,8 +1635,26 @@@ group_sched_out(struct perf_event *grou
  		cpuctx->exclusive = 0;
  }
  
++<<<<<<< HEAD
 +struct remove_event {
 +	struct perf_event *event;
 +	bool detach_group;
 +};
 +
 +static void ___perf_remove_from_context(void *info)
 +{
 +	struct remove_event *re = info;
 +	struct perf_event *event = re->event;
 +	struct perf_event_context *ctx = event->ctx;
 +
 +	if (re->detach_group)
 +		perf_group_detach(event);
 +	list_del_event(event, ctx);
 +}
++=======
+ #define DETACH_GROUP	0x01UL
+ #define DETACH_STATE	0x02UL
++>>>>>>> 60beda849343 (perf: Untangle 'owner' confusion)
  
  /*
   * Cross CPU call to remove a performance event
@@@ -1653,25 -1779,28 +1662,32 @@@
   * We disable the event on the hardware level first. After that we
   * remove it from the context list.
   */
 -static void
 -__perf_remove_from_context(struct perf_event *event,
 -			   struct perf_cpu_context *cpuctx,
 -			   struct perf_event_context *ctx,
 -			   void *info)
 +static int __perf_remove_from_context(void *info)
  {
 -	unsigned long flags = (unsigned long)info;
 +	struct remove_event *re = info;
 +	struct perf_event *event = re->event;
 +	struct perf_event_context *ctx = event->ctx;
 +	struct perf_cpu_context *cpuctx = __get_cpu_context(ctx);
  
 +	raw_spin_lock(&ctx->lock);
  	event_sched_out(event, cpuctx, ctx);
 -	if (flags & DETACH_GROUP)
 +	if (re->detach_group)
  		perf_group_detach(event);
  	list_del_event(event, ctx);
++<<<<<<< HEAD
 +	if (!ctx->nr_events && cpuctx->task_ctx == ctx) {
++=======
+ 	if (flags & DETACH_STATE)
+ 		event->state = PERF_EVENT_STATE_EXIT;
+ 
+ 	if (!ctx->nr_events && ctx->is_active) {
++>>>>>>> 60beda849343 (perf: Untangle 'owner' confusion)
  		ctx->is_active = 0;
 -		if (ctx->task) {
 -			WARN_ON_ONCE(cpuctx->task_ctx != ctx);
 -			cpuctx->task_ctx = NULL;
 -		}
 +		cpuctx->task_ctx = NULL;
  	}
 +	raw_spin_unlock(&ctx->lock);
 +
 +	return 0;
  }
  
  /*
@@@ -3613,9 -3804,16 +3629,20 @@@ static void put_event(struct perf_even
  	 */
  	ctx = perf_event_ctx_lock_nested(event, SINGLE_DEPTH_NESTING);
  	WARN_ON_ONCE(ctx->parent_ctx);
++<<<<<<< HEAD
 +	perf_remove_from_context(event, true);
++=======
+ 	perf_remove_from_context(event, DETACH_GROUP | DETACH_STATE);
++>>>>>>> 60beda849343 (perf: Untangle 'owner' confusion)
  	perf_event_ctx_unlock(event, ctx);
  
+ 	/*
+ 	 * At this point we must have event->state == PERF_EVENT_STATE_EXIT,
+ 	 * either from the above perf_remove_from_context() or through
+ 	 * perf_event_exit_event().
+ 	 */
+ 	WARN_ON_ONCE(event->state != PERF_EVENT_STATE_EXIT);
+ 
  	_free_event(event);
  }
  
* Unmerged path kernel/events/core.c
