i40e: Add support for configuring VF RSS

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mitch Williams <mitch.a.williams@intel.com>
commit c4e1868c3aa1992de1cba600e7083fcd49bd20b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c4e1868c.failed

Add support for configuring RSS on behalf of the VFs. This removes the
burden of dealing with different hardware interfaces from the VF
drivers, allowing for better future compatibility.

Change-ID: Icea75d3f37241ee8e447be5779e5abb53ddf04c0
	Signed-off-by: Mitch Williams <mitch.a.williams@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit c4e1868c3aa1992de1cba600e7083fcd49bd20b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index d901afb6a12a,c3645886670e..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -1205,24 -1341,63 +1205,45 @@@ static int i40e_vc_get_vf_resources_msg
  	vsi = pf->vsi[vf->lan_vsi_idx];
  	if (!vsi->info.pvid)
  		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_VLAN;
++<<<<<<< HEAD
 +	if (pf->flags & I40E_FLAG_RSS_AQ_CAPABLE) {
 +		if (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ)
 +			vfres->vf_offload_flags |=
 +				I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ;
++=======
+ 
+ 	if (i40e_vf_client_capable(pf, vf->vf_id, I40E_CLIENT_IWARP) &&
+ 	    (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_IWARP)) {
+ 		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_IWARP;
+ 		set_bit(I40E_VF_STAT_IWARPENA, &vf->vf_states);
+ 	}
+ 
+ 	if (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF) {
+ 		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF;
++>>>>>>> c4e1868c3aa1 (i40e: Add support for configuring VF RSS)
  	} else {
- 		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_RSS_REG;
+ 		if ((pf->flags & I40E_FLAG_RSS_AQ_CAPABLE) &&
+ 		    (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ))
+ 			vfres->vf_offload_flags |=
+ 					I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ;
+ 		else
+ 			vfres->vf_offload_flags |=
+ 					I40E_VIRTCHNL_VF_OFFLOAD_RSS_REG;
  	}
 -
 -	if (pf->flags & I40E_FLAG_MULTIPLE_TCP_UDP_RSS_PCTYPE) {
 -		if (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2)
 -			vfres->vf_offload_flags |=
 -				I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2;
 -	}
 -
 -	if (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_RX_POLLING) {
 -		if (pf->flags & I40E_FLAG_MFP_ENABLED) {
 -			dev_err(&pf->pdev->dev,
 -				"VF %d requested polling mode: this feature is supported only when the device is running in single function per port (SFP) mode\n",
 -				 vf->vf_id);
 -			ret = I40E_ERR_PARAM;
 -			goto err;
 -		}
 -		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_RX_POLLING;
 -	}
 -
 -	if (pf->flags & I40E_FLAG_WB_ON_ITR_CAPABLE) {
 -		if (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_WB_ON_ITR)
 -			vfres->vf_offload_flags |=
 -					I40E_VIRTCHNL_VF_OFFLOAD_WB_ON_ITR;
 -	}
 -
  	vfres->num_vsis = num_vsis;
  	vfres->num_queue_pairs = vf->num_queue_pairs;
  	vfres->max_vectors = pf->hw.func_caps.num_msix_vectors_vf;
+ 	vfres->rss_key_size = I40E_HKEY_ARRAY_SIZE;
+ 	vfres->rss_lut_size = I40E_VF_HLUT_ARRAY_SIZE;
+ 
  	if (vf->lan_vsi_idx) {
 -		vfres->vsi_res[0].vsi_id = vf->lan_vsi_id;
 -		vfres->vsi_res[0].vsi_type = I40E_VSI_SRIOV;
 -		vfres->vsi_res[0].num_queue_pairs = vsi->alloc_queue_pairs;
 -		/* VFs only use TC 0 */
 -		vfres->vsi_res[0].qset_handle
 -					  = le16_to_cpu(vsi->info.qs_handle[0]);
 -		ether_addr_copy(vfres->vsi_res[0].default_mac_addr,
 -				vf->default_lan_addr.addr);
 +		vfres->vsi_res[i].vsi_id = vf->lan_vsi_id;
 +		vfres->vsi_res[i].vsi_type = I40E_VSI_SRIOV;
 +		vfres->vsi_res[i].num_queue_pairs =
 +		    pf->vsi[vf->lan_vsi_idx]->alloc_queue_pairs;
 +		memcpy(vfres->vsi_res[i].default_mac_addr,
 +		       vf->default_lan_addr.addr, ETH_ALEN);
 +		i++;
  	}
  	set_bit(I40E_VF_STAT_ACTIVE, &vf->vf_states);
  
@@@ -1801,6 -1983,205 +1822,208 @@@ error_param
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * i40e_vc_iwarp_msg
+  * @vf: pointer to the VF info
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  *
+  * called from the VF for the iwarp msgs
+  **/
+ static int i40e_vc_iwarp_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)
+ {
+ 	struct i40e_pf *pf = vf->pf;
+ 	int abs_vf_id = vf->vf_id + pf->hw.func_caps.vf_base_id;
+ 	i40e_status aq_ret = 0;
+ 
+ 	if (!test_bit(I40E_VF_STAT_ACTIVE, &vf->vf_states) ||
+ 	    !test_bit(I40E_VF_STAT_IWARPENA, &vf->vf_states)) {
+ 		aq_ret = I40E_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	i40e_notify_client_of_vf_msg(pf->vsi[pf->lan_vsi], abs_vf_id,
+ 				     msg, msglen);
+ 
+ error_param:
+ 	/* send the response to the VF */
+ 	return i40e_vc_send_resp_to_vf(vf, I40E_VIRTCHNL_OP_IWARP,
+ 				       aq_ret);
+ }
+ 
+ /**
+  * i40e_vc_iwarp_qvmap_msg
+  * @vf: pointer to the VF info
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  * @config: config qvmap or release it
+  *
+  * called from the VF for the iwarp msgs
+  **/
+ static int i40e_vc_iwarp_qvmap_msg(struct i40e_vf *vf, u8 *msg, u16 msglen,
+ 				   bool config)
+ {
+ 	struct i40e_virtchnl_iwarp_qvlist_info *qvlist_info =
+ 				(struct i40e_virtchnl_iwarp_qvlist_info *)msg;
+ 	i40e_status aq_ret = 0;
+ 
+ 	if (!test_bit(I40E_VF_STAT_ACTIVE, &vf->vf_states) ||
+ 	    !test_bit(I40E_VF_STAT_IWARPENA, &vf->vf_states)) {
+ 		aq_ret = I40E_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	if (config) {
+ 		if (i40e_config_iwarp_qvlist(vf, qvlist_info))
+ 			aq_ret = I40E_ERR_PARAM;
+ 	} else {
+ 		i40e_release_iwarp_qvlist(vf);
+ 	}
+ 
+ error_param:
+ 	/* send the response to the VF */
+ 	return i40e_vc_send_resp_to_vf(vf,
+ 			       config ? I40E_VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP :
+ 			       I40E_VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP,
+ 			       aq_ret);
+ }
+ 
+ /**
+  * i40e_vc_config_rss_key
+  * @vf: pointer to the VF info
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  *
+  * Configure the VF's RSS key
+  **/
+ static int i40e_vc_config_rss_key(struct i40e_vf *vf, u8 *msg, u16 msglen)
+ {
+ 	struct i40e_virtchnl_rss_key *vrk =
+ 		(struct i40e_virtchnl_rss_key *)msg;
+ 	struct i40e_pf *pf = vf->pf;
+ 	struct i40e_vsi *vsi = NULL;
+ 	u16 vsi_id = vrk->vsi_id;
+ 	i40e_status aq_ret = 0;
+ 
+ 	if (!test_bit(I40E_VF_STAT_ACTIVE, &vf->vf_states) ||
+ 	    !test_bit(I40E_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps) ||
+ 	    !i40e_vc_isvalid_vsi_id(vf, vsi_id) ||
+ 	    (vrk->key_len != I40E_HKEY_ARRAY_SIZE)) {
+ 		aq_ret = I40E_ERR_PARAM;
+ 		goto err;
+ 	}
+ 
+ 	vsi = pf->vsi[vf->lan_vsi_idx];
+ 	aq_ret = i40e_config_rss(vsi, vrk->key, NULL, 0);
+ err:
+ 	/* send the response to the VF */
+ 	return i40e_vc_send_resp_to_vf(vf, I40E_VIRTCHNL_OP_CONFIG_RSS_KEY,
+ 				       aq_ret);
+ }
+ 
+ /**
+  * i40e_vc_config_rss_lut
+  * @vf: pointer to the VF info
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  *
+  * Configure the VF's RSS LUT
+  **/
+ static int i40e_vc_config_rss_lut(struct i40e_vf *vf, u8 *msg, u16 msglen)
+ {
+ 	struct i40e_virtchnl_rss_lut *vrl =
+ 		(struct i40e_virtchnl_rss_lut *)msg;
+ 	struct i40e_pf *pf = vf->pf;
+ 	struct i40e_vsi *vsi = NULL;
+ 	u16 vsi_id = vrl->vsi_id;
+ 	i40e_status aq_ret = 0;
+ 
+ 	if (!test_bit(I40E_VF_STAT_ACTIVE, &vf->vf_states) ||
+ 	    !test_bit(I40E_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps) ||
+ 	    !i40e_vc_isvalid_vsi_id(vf, vsi_id) ||
+ 	    (vrl->lut_entries != I40E_VF_HLUT_ARRAY_SIZE)) {
+ 		aq_ret = I40E_ERR_PARAM;
+ 		goto err;
+ 	}
+ 
+ 	vsi = pf->vsi[vf->lan_vsi_idx];
+ 	aq_ret = i40e_config_rss(vsi, NULL, vrl->lut, I40E_VF_HLUT_ARRAY_SIZE);
+ 	/* send the response to the VF */
+ err:
+ 	return i40e_vc_send_resp_to_vf(vf, I40E_VIRTCHNL_OP_CONFIG_RSS_LUT,
+ 				       aq_ret);
+ }
+ 
+ /**
+  * i40e_vc_get_rss_hena
+  * @vf: pointer to the VF info
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  *
+  * Return the RSS HENA bits allowed by the hardware
+  **/
+ static int i40e_vc_get_rss_hena(struct i40e_vf *vf, u8 *msg, u16 msglen)
+ {
+ 	struct i40e_virtchnl_rss_hena *vrh = NULL;
+ 	struct i40e_pf *pf = vf->pf;
+ 	i40e_status aq_ret = 0;
+ 	int len = 0;
+ 
+ 	if (!test_bit(I40E_VF_STAT_ACTIVE, &vf->vf_states) ||
+ 	    !test_bit(I40E_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps)) {
+ 		aq_ret = I40E_ERR_PARAM;
+ 		goto err;
+ 	}
+ 	len = sizeof(struct i40e_virtchnl_rss_hena);
+ 
+ 	vrh = kzalloc(len, GFP_KERNEL);
+ 	if (!vrh) {
+ 		aq_ret = I40E_ERR_NO_MEMORY;
+ 		len = 0;
+ 		goto err;
+ 	}
+ 	vrh->hena = i40e_pf_get_default_rss_hena(pf);
+ err:
+ 	/* send the response back to the VF */
+ 	aq_ret = i40e_vc_send_msg_to_vf(vf, I40E_VIRTCHNL_OP_GET_RSS_HENA_CAPS,
+ 					aq_ret, (u8 *)vrh, len);
+ 	return aq_ret;
+ }
+ 
+ /**
+  * i40e_vc_set_rss_hena
+  * @vf: pointer to the VF info
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  *
+  * Set the RSS HENA bits for the VF
+  **/
+ static int i40e_vc_set_rss_hena(struct i40e_vf *vf, u8 *msg, u16 msglen)
+ {
+ 	struct i40e_virtchnl_rss_hena *vrh =
+ 		(struct i40e_virtchnl_rss_hena *)msg;
+ 	struct i40e_pf *pf = vf->pf;
+ 	struct i40e_hw *hw = &pf->hw;
+ 	i40e_status aq_ret = 0;
+ 
+ 	if (!test_bit(I40E_VF_STAT_ACTIVE, &vf->vf_states) ||
+ 	    !test_bit(I40E_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps)) {
+ 		aq_ret = I40E_ERR_PARAM;
+ 		goto err;
+ 	}
+ 	i40e_write_rx_ctl(hw, I40E_VFQF_HENA1(0, vf->vf_id), (u32)vrh->hena);
+ 	i40e_write_rx_ctl(hw, I40E_VFQF_HENA1(1, vf->vf_id),
+ 			  (u32)(vrh->hena >> 32));
+ 
+ 	/* send the response to the VF */
+ err:
+ 	return i40e_vc_send_resp_to_vf(vf, I40E_VIRTCHNL_OP_SET_RSS_HENA,
+ 				       aq_ret);
+ }
+ 
+ /**
++>>>>>>> c4e1868c3aa1 (i40e: Add support for configuring VF RSS)
   * i40e_vc_validate_vf_msg
   * @vf: pointer to the VF info
   * @msg: pointer to the msg buffer
@@@ -1895,6 -2276,62 +2118,65 @@@ static int i40e_vc_validate_vf_msg(stru
  	case I40E_VIRTCHNL_OP_GET_STATS:
  		valid_len = sizeof(struct i40e_virtchnl_queue_select);
  		break;
++<<<<<<< HEAD
++=======
+ 	case I40E_VIRTCHNL_OP_IWARP:
+ 		/* These messages are opaque to us and will be validated in
+ 		 * the RDMA client code. We just need to check for nonzero
+ 		 * length. The firmware will enforce max length restrictions.
+ 		 */
+ 		if (msglen)
+ 			valid_len = msglen;
+ 		else
+ 			err_msg_format = true;
+ 		break;
+ 	case I40E_VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP:
+ 		valid_len = 0;
+ 		break;
+ 	case I40E_VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP:
+ 		valid_len = sizeof(struct i40e_virtchnl_iwarp_qvlist_info);
+ 		if (msglen >= valid_len) {
+ 			struct i40e_virtchnl_iwarp_qvlist_info *qv =
+ 				(struct i40e_virtchnl_iwarp_qvlist_info *)msg;
+ 			if (qv->num_vectors == 0) {
+ 				err_msg_format = true;
+ 				break;
+ 			}
+ 			valid_len += ((qv->num_vectors - 1) *
+ 				sizeof(struct i40e_virtchnl_iwarp_qv_info));
+ 		}
+ 		break;
+ 	case I40E_VIRTCHNL_OP_CONFIG_RSS_KEY:
+ 		valid_len = sizeof(struct i40e_virtchnl_rss_key);
+ 		if (msglen >= valid_len) {
+ 			struct i40e_virtchnl_rss_key *vrk =
+ 				(struct i40e_virtchnl_rss_key *)msg;
+ 			if (vrk->key_len != I40E_HKEY_ARRAY_SIZE) {
+ 				err_msg_format = true;
+ 				break;
+ 			}
+ 			valid_len += vrk->key_len - 1;
+ 		}
+ 		break;
+ 	case I40E_VIRTCHNL_OP_CONFIG_RSS_LUT:
+ 		valid_len = sizeof(struct i40e_virtchnl_rss_lut);
+ 		if (msglen >= valid_len) {
+ 			struct i40e_virtchnl_rss_lut *vrl =
+ 				(struct i40e_virtchnl_rss_lut *)msg;
+ 			if (vrl->lut_entries != I40E_VF_HLUT_ARRAY_SIZE) {
+ 				err_msg_format = true;
+ 				break;
+ 			}
+ 			valid_len += vrl->lut_entries - 1;
+ 		}
+ 		break;
+ 	case I40E_VIRTCHNL_OP_GET_RSS_HENA_CAPS:
+ 		valid_len = 0;
+ 		break;
+ 	case I40E_VIRTCHNL_OP_SET_RSS_HENA:
+ 		valid_len = sizeof(struct i40e_virtchnl_rss_hena);
+ 		break;
++>>>>>>> c4e1868c3aa1 (i40e: Add support for configuring VF RSS)
  	/* These are always errors coming from the VF. */
  	case I40E_VIRTCHNL_OP_EVENT:
  	case I40E_VIRTCHNL_OP_UNKNOWN:
@@@ -1985,6 -2421,28 +2267,31 @@@ int i40e_vc_process_vf_msg(struct i40e_
  	case I40E_VIRTCHNL_OP_GET_STATS:
  		ret = i40e_vc_get_stats_msg(vf, msg, msglen);
  		break;
++<<<<<<< HEAD
++=======
+ 	case I40E_VIRTCHNL_OP_IWARP:
+ 		ret = i40e_vc_iwarp_msg(vf, msg, msglen);
+ 		break;
+ 	case I40E_VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP:
+ 		ret = i40e_vc_iwarp_qvmap_msg(vf, msg, msglen, true);
+ 		break;
+ 	case I40E_VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP:
+ 		ret = i40e_vc_iwarp_qvmap_msg(vf, msg, msglen, false);
+ 		break;
+ 	case I40E_VIRTCHNL_OP_CONFIG_RSS_KEY:
+ 		ret = i40e_vc_config_rss_key(vf, msg, msglen);
+ 		break;
+ 	case I40E_VIRTCHNL_OP_CONFIG_RSS_LUT:
+ 		ret = i40e_vc_config_rss_lut(vf, msg, msglen);
+ 		break;
+ 	case I40E_VIRTCHNL_OP_GET_RSS_HENA_CAPS:
+ 		ret = i40e_vc_get_rss_hena(vf, msg, msglen);
+ 		break;
+ 	case I40E_VIRTCHNL_OP_SET_RSS_HENA:
+ 		ret = i40e_vc_set_rss_hena(vf, msg, msglen);
+ 		break;
+ 
++>>>>>>> c4e1868c3aa1 (i40e: Add support for configuring VF RSS)
  	case I40E_VIRTCHNL_OP_UNKNOWN:
  	default:
  		dev_err(&pf->pdev->dev, "Unsupported opcode %d from VF %d\n",
diff --git a/drivers/net/ethernet/intel/i40e/i40e.h b/drivers/net/ethernet/intel/i40e/i40e.h
index 7038cf1926c5..62b560083eaa 100644
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@ -186,6 +186,7 @@ struct i40e_lump_tracking {
 
 #define I40E_HKEY_ARRAY_SIZE ((I40E_PFQF_HKEY_MAX_INDEX + 1) * 4)
 #define I40E_HLUT_ARRAY_SIZE ((I40E_PFQF_HLUT_MAX_INDEX + 1) * 4)
+#define I40E_VF_HLUT_ARRAY_SIZE ((I40E_VFQF_HLUT1_MAX_INDEX + 1) * 4)
 
 enum i40e_fd_stat_idx {
 	I40E_FD_STAT_ATR,
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index d2f65266466a..cff505663a0c 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -7997,24 +7997,45 @@ static int i40e_config_rss_reg(struct i40e_vsi *vsi, const u8 *seed,
 {
 	struct i40e_pf *pf = vsi->back;
 	struct i40e_hw *hw = &pf->hw;
+	u16 vf_id = vsi->vf_id;
 	u8 i;
 
 	/* Fill out hash function seed */
 	if (seed) {
 		u32 *seed_dw = (u32 *)seed;
 
-		for (i = 0; i <= I40E_PFQF_HKEY_MAX_INDEX; i++)
-			i40e_write_rx_ctl(hw, I40E_PFQF_HKEY(i), seed_dw[i]);
+		if (vsi->type == I40E_VSI_MAIN) {
+			for (i = 0; i <= I40E_PFQF_HKEY_MAX_INDEX; i++)
+				i40e_write_rx_ctl(hw, I40E_PFQF_HKEY(i),
+						  seed_dw[i]);
+		} else if (vsi->type == I40E_VSI_SRIOV) {
+			for (i = 0; i <= I40E_VFQF_HKEY1_MAX_INDEX; i++)
+				i40e_write_rx_ctl(hw,
+						  I40E_VFQF_HKEY1(i, vf_id),
+						  seed_dw[i]);
+		} else {
+			dev_err(&pf->pdev->dev, "Cannot set RSS seed - invalid VSI type\n");
+		}
 	}
 
 	if (lut) {
 		u32 *lut_dw = (u32 *)lut;
 
-		if (lut_size != I40E_HLUT_ARRAY_SIZE)
-			return -EINVAL;
-
-		for (i = 0; i <= I40E_PFQF_HLUT_MAX_INDEX; i++)
-			wr32(hw, I40E_PFQF_HLUT(i), lut_dw[i]);
+		if (vsi->type == I40E_VSI_MAIN) {
+			if (lut_size != I40E_HLUT_ARRAY_SIZE)
+				return -EINVAL;
+			for (i = 0; i <= I40E_PFQF_HLUT_MAX_INDEX; i++)
+				wr32(hw, I40E_PFQF_HLUT(i), lut_dw[i]);
+		} else if (vsi->type == I40E_VSI_SRIOV) {
+			if (lut_size != I40E_VF_HLUT_ARRAY_SIZE)
+				return -EINVAL;
+			for (i = 0; i <= I40E_VFQF_HLUT_MAX_INDEX; i++)
+				i40e_write_rx_ctl(hw,
+						  I40E_VFQF_HLUT1(i, vf_id),
+						  lut_dw[i]);
+		} else {
+			dev_err(&pf->pdev->dev, "Cannot set RSS LUT - invalid VSI type\n");
+		}
 	}
 	i40e_flush(hw);
 
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
