IB/hfi1: Always turn on CDRs for low power QSFP modules

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Easwar Hariharan <easwar.hariharan@intel.com>
commit 145dd2b3995830ab4bf14f1dc7d44dc5d2b7cb10
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/145dd2b3.failed

Clock and data recovery mechanisms (CDRs) in active QSFP modules
can be turned on or off to improve the bit error rate observed on
the channel. Signal integrity and bit error rate requirements require
us to always turn on any CDRs present in low power cables (power
dissipation 2.5W or lower). However, we adhere to the platform
designer's settings (provided in the platform configuration) for
higher power cables (dissipation 3.5W or higher) if the platform
designer has determined that the platform requires the CDRs to be
turned on (or off) and is capable of supplying and cooling the higher
power modules.

This patch also introduces the get_qsfp_power_class function to
centralize the bit twiddling required to determine the QSFP power class
across the code. Reusing this function improves the readability of code
that depends on knowing the power class of the cable, such as the
active and optical channel tuning algorithm.

	Reviewed-by: Dean Luick <dean.luick@intel.com>
	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Easwar Hariharan <easwar.hariharan@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 145dd2b3995830ab4bf14f1dc7d44dc5d2b7cb10)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/chip.c
#	drivers/staging/rdma/hfi1/platform.c
diff --cc drivers/staging/hfi1/chip.c
index 689fb76865d1,962cca0fa858..000000000000
--- a/drivers/staging/hfi1/chip.c
+++ b/drivers/staging/hfi1/chip.c
@@@ -6215,46 -6226,11 +6210,50 @@@ static void handle_8051_request(struct 
  	case HREQ_READ_CONFIG:
  	case HREQ_SET_TX_EQ_ABS:
  	case HREQ_SET_TX_EQ_REL:
+ 	case HREQ_ENABLE:
  		dd_dev_info(dd, "8051 request: request 0x%x not supported\n",
 -			    type);
 +			type);
  		hreq_response(dd, HREQ_NOT_SUPPORTED, 0);
  		break;
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +
 +	case HREQ_ENABLE:
 +		lanes = data & 0xF;
 +		for (i = 0; lanes; lanes >>= 1, i++) {
 +			if (!(lanes & 1))
 +				continue;
 +			if (data & 0x200) {
 +				/* enable TX CDR */
 +				if (cache[QSFP_MOD_PWR_OFFS] & 0x8 &&
 +				    cache[QSFP_CDR_INFO_OFFS] & 0x80)
 +					cdr_ctrl_byte |= (1 << (i + 4));
 +			} else {
 +				/* disable TX CDR */
 +				if (cache[QSFP_MOD_PWR_OFFS] & 0x8 &&
 +				    cache[QSFP_CDR_INFO_OFFS] & 0x80)
 +					cdr_ctrl_byte &= ~(1 << (i + 4));
 +			}
 +
 +			if (data & 0x800) {
 +				/* enable RX CDR */
 +				if (cache[QSFP_MOD_PWR_OFFS] & 0x4 &&
 +				    cache[QSFP_CDR_INFO_OFFS] & 0x40)
 +					cdr_ctrl_byte |= (1 << i);
 +			} else {
 +				/* disable RX CDR */
 +				if (cache[QSFP_MOD_PWR_OFFS] & 0x4 &&
 +				    cache[QSFP_CDR_INFO_OFFS] & 0x40)
 +					cdr_ctrl_byte &= ~(1 << i);
 +			}
 +		}
 +		qsfp_write(ppd, ppd->dd->hfi1_id, QSFP_CDR_CTRL_BYTE_OFFS,
 +			   &cdr_ctrl_byte, 1);
 +		hreq_response(dd, HREQ_SUCCESS, data);
 +		refresh_qsfp_cache(ppd, &ppd->qsfp_info);
 +		break;
 +
++=======
++>>>>>>> 145dd2b39958 (IB/hfi1: Always turn on CDRs for low power QSFP modules):drivers/staging/rdma/hfi1/chip.c
  	case HREQ_CONFIG_DONE:
  		hreq_response(dd, HREQ_SUCCESS, 0);
  		break;
* Unmerged path drivers/staging/rdma/hfi1/platform.c
* Unmerged path drivers/staging/hfi1/chip.c
diff --git a/drivers/staging/hfi1/chip.h b/drivers/staging/hfi1/chip.h
index dc82815c53a0..29e0250182cc 100644
--- a/drivers/staging/hfi1/chip.h
+++ b/drivers/staging/hfi1/chip.h
@@ -677,7 +677,6 @@ void handle_verify_cap(struct work_struct *work);
 void handle_freeze(struct work_struct *work);
 void handle_link_up(struct work_struct *work);
 void handle_link_down(struct work_struct *work);
-void handle_8051_request(struct work_struct *work);
 void handle_link_downgrade(struct work_struct *work);
 void handle_link_bounce(struct work_struct *work);
 void handle_sma_message(struct work_struct *work);
diff --git a/drivers/staging/hfi1/hfi.h b/drivers/staging/hfi1/hfi.h
index ec4274792def..4cc93eaf81a9 100644
--- a/drivers/staging/hfi1/hfi.h
+++ b/drivers/staging/hfi1/hfi.h
@@ -599,7 +599,6 @@ struct hfi1_pportdata {
 	struct work_struct link_vc_work;
 	struct work_struct link_up_work;
 	struct work_struct link_down_work;
-	struct work_struct dc_host_req_work;
 	struct work_struct sma_message_work;
 	struct work_struct freeze_work;
 	struct work_struct link_downgrade_work;
diff --git a/drivers/staging/hfi1/init.c b/drivers/staging/hfi1/init.c
index 9c4bb834cbe9..e157dd775f8f 100644
--- a/drivers/staging/hfi1/init.c
+++ b/drivers/staging/hfi1/init.c
@@ -494,7 +494,6 @@ void hfi1_init_pportdata(struct pci_dev *pdev, struct hfi1_pportdata *ppd,
 	INIT_WORK(&ppd->link_vc_work, handle_verify_cap);
 	INIT_WORK(&ppd->link_up_work, handle_link_up);
 	INIT_WORK(&ppd->link_down_work, handle_link_down);
-	INIT_WORK(&ppd->dc_host_req_work, handle_8051_request);
 	INIT_WORK(&ppd->freeze_work, handle_freeze);
 	INIT_WORK(&ppd->link_downgrade_work, handle_link_downgrade);
 	INIT_WORK(&ppd->sma_message_work, handle_sma_message);
diff --git a/drivers/staging/hfi1/qsfp.c b/drivers/staging/hfi1/qsfp.c
index b16ff11927bd..14bf65c2441b 100644
--- a/drivers/staging/hfi1/qsfp.c
+++ b/drivers/staging/hfi1/qsfp.c
@@ -433,7 +433,28 @@ const char * const hfi1_qsfp_devtech[16] = {
 #define QSFP_DUMP_CHUNK 16 /* Holds longest string */
 #define QSFP_DEFAULT_HDR_CNT 224
 
-static const char *pwr_codes = "1.5W2.0W2.5W3.5W";
+#define QSFP_PWR(pbyte) (((pbyte) >> 6) & 3)
+#define QSFP_HIGH_PWR(pbyte) ((pbyte) & 3)
+/* For use with QSFP_HIGH_PWR macro */
+#define QSFP_HIGH_PWR_UNUSED	0 /* Bits [1:0] = 00 implies low power module */
+
+/*
+ * Takes power class byte [Page 00 Byte 129] in SFF 8636
+ * Returns power class as integer (1 through 7, per SFF 8636 rev 2.4)
+ */
+int get_qsfp_power_class(u8 power_byte)
+{
+	if (QSFP_HIGH_PWR(power_byte) == QSFP_HIGH_PWR_UNUSED)
+		/* power classes count from 1, their bit encodings from 0 */
+		return (QSFP_PWR(power_byte) + 1);
+	/*
+	 * 00 in the high power classes stands for unused, bringing
+	 * balance to the off-by-1 offset above, we add 4 here to
+	 * account for the difference between the low and high power
+	 * groups
+	 */
+	return (QSFP_HIGH_PWR(power_byte) + 4);
+}
 
 int qsfp_mod_present(struct hfi1_pportdata *ppd)
 {
@@ -504,6 +525,16 @@ set_zeroes:
 	return ret;
 }
 
+static const char *pwr_codes[8] = {"N/AW",
+				  "1.5W",
+				  "2.0W",
+				  "2.5W",
+				  "3.5W",
+				  "4.0W",
+				  "4.5W",
+				  "5.0W"
+				 };
+
 int qsfp_dump(struct hfi1_pportdata *ppd, char *buf, int len)
 {
 	u8 *cache = &ppd->qsfp_info.cache[0];
@@ -513,6 +544,7 @@ int qsfp_dump(struct hfi1_pportdata *ppd, char *buf, int len)
 	int bidx = 0;
 	u8 *atten = &cache[QSFP_ATTEN_OFFS];
 	u8 *vendor_oui = &cache[QSFP_VOUI_OFFS];
+	u8 power_byte = 0;
 
 	sofar = 0;
 	lenstr[0] = ' ';
@@ -523,9 +555,9 @@ int qsfp_dump(struct hfi1_pportdata *ppd, char *buf, int len)
 		if (QSFP_IS_CU(cache[QSFP_MOD_TECH_OFFS]))
 			sprintf(lenstr, "%dM ", cache[QSFP_MOD_LEN_OFFS]);
 
+		power_byte = cache[QSFP_MOD_PWR_OFFS];
 		sofar += scnprintf(buf + sofar, len - sofar, "PWR:%.3sW\n",
-				pwr_codes +
-				(QSFP_PWR(cache[QSFP_MOD_PWR_OFFS]) * 4));
+				pwr_codes[get_qsfp_power_class(power_byte)]);
 
 		sofar += scnprintf(buf + sofar, len - sofar, "TECH:%s%s\n",
 				lenstr,
diff --git a/drivers/staging/hfi1/qsfp.h b/drivers/staging/hfi1/qsfp.h
index b5bc61780bca..c756949de5a8 100644
--- a/drivers/staging/hfi1/qsfp.h
+++ b/drivers/staging/hfi1/qsfp.h
@@ -85,8 +85,9 @@
 /* Byte 128 is Identifier: must be 0x0c for QSFP, or 0x0d for QSFP+ */
 #define QSFP_MOD_ID_OFFS 128
 /*
- * Byte 129 is "Extended Identifier". We only care about D7,D6: Power class
- *  0:1.5W, 1:2.0W, 2:2.5W, 3:3.5W
+ * Byte 129 is "Extended Identifier".
+ * For bits [7:6]: 0:1.5W, 1:2.0W, 2:2.5W, 3:3.5W
+ * For bits [1:0]: 0:Unused, 1:4W, 2:4.5W, 3:5W
  */
 #define QSFP_MOD_PWR_OFFS 129
 /* Byte 130 is Connector type. Not Intel req'd */
@@ -193,6 +194,9 @@ extern const char *const hfi1_qsfp_devtech[16];
 #define QSFP_HIGH_BIAS_WARNING		0x22
 #define QSFP_LOW_BIAS_WARNING		0x11
 
+#define QSFP_ATTEN_SDR(attenarray) (attenarray[0])
+#define QSFP_ATTEN_DDR(attenarray) (attenarray[1])
+
 /*
  * struct qsfp_data encapsulates state of QSFP device for one port.
  * it will be part of port-specific data if a board supports QSFP.
@@ -204,12 +208,6 @@ extern const char *const hfi1_qsfp_devtech[16];
  * and let the qsfp_lock arbitrate access to common resources.
  *
  */
-
-#define QSFP_PWR(pbyte) (((pbyte) >> 6) & 3)
-#define QSFP_HIGH_PWR(pbyte) (((pbyte) & 3) | 4)
-#define QSFP_ATTEN_SDR(attenarray) (attenarray[0])
-#define QSFP_ATTEN_DDR(attenarray) (attenarray[1])
-
 struct qsfp_data {
 	/* Helps to find our way */
 	struct hfi1_pportdata *ppd;
@@ -224,6 +222,7 @@ struct qsfp_data {
 
 int refresh_qsfp_cache(struct hfi1_pportdata *ppd,
 		       struct qsfp_data *cp);
+int get_qsfp_power_class(u8 power_byte);
 int qsfp_mod_present(struct hfi1_pportdata *ppd);
 int get_cable_info(struct hfi1_devdata *dd, u32 port_num, u32 addr,
 		   u32 len, u8 *data);
* Unmerged path drivers/staging/rdma/hfi1/platform.c
