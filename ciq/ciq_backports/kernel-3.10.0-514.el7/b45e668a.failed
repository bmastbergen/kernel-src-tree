mmc: sdhci: add platform set_timeout hook

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] sdhci: add platform set_timeout hook (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 93.51%
commit-author Aisheng Dong <b29396@freescale.com>
commit b45e668af4439bfc52ed92af44b6400661ba7ec8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b45e668a.failed

Currently the common code assume 0xE is the maximum timeout counter
value and use it to write into the timeout counter register.
However, it's fairly possible that some other SoCs may have different
max timeout register value. That means 0xE may be incorrect and
becomes meaningless.

It's also possible that other platforms has different timeout
calculation algorithm. To be flexible, this patch provides a .set_timeout
hook for those platforms to set the timeout on their way if they need.

	Reviewed-by: Shawn Guo <shawn.guo@linaro.org>
	Signed-off-by: Dong Aisheng <b29396@freescale.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit b45e668af4439bfc52ed92af44b6400661ba7ec8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci.h
diff --cc drivers/mmc/host/sdhci.h
index 704d0c2abf12,9828ff83d84c..000000000000
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@@ -281,8 -281,10 +281,15 @@@ struct sdhci_ops 
  	unsigned int	(*get_max_clock)(struct sdhci_host *host);
  	unsigned int	(*get_min_clock)(struct sdhci_host *host);
  	unsigned int	(*get_timeout_clock)(struct sdhci_host *host);
++<<<<<<< HEAD
 +	int		(*platform_bus_width)(struct sdhci_host *host,
 +					       int width);
++=======
+ 	unsigned int	(*get_max_timeout_count)(struct sdhci_host *host);
+ 	void		(*set_timeout)(struct sdhci_host *host,
+ 				       struct mmc_command *cmd);
+ 	void		(*set_bus_width)(struct sdhci_host *host, int width);
++>>>>>>> b45e668af443 (mmc: sdhci: add platform set_timeout hook)
  	void (*platform_send_init_74_clocks)(struct sdhci_host *host,
  					     u8 power_mode);
  	unsigned int    (*get_ro)(struct sdhci_host *host);
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 083c3f4ebb88..01ecb264058b 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -725,19 +725,28 @@ static void sdhci_set_transfer_irqs(struct sdhci_host *host)
 		sdhci_clear_set_irqs(host, dma_irqs, pio_irqs);
 }
 
-static void sdhci_prepare_data(struct sdhci_host *host, struct mmc_command *cmd)
+static void sdhci_set_timeout(struct sdhci_host *host, struct mmc_command *cmd)
 {
 	u8 count;
+
+	if (host->ops->set_timeout) {
+		host->ops->set_timeout(host, cmd);
+	} else {
+		count = sdhci_calc_timeout(host, cmd);
+		sdhci_writeb(host, count, SDHCI_TIMEOUT_CONTROL);
+	}
+}
+
+static void sdhci_prepare_data(struct sdhci_host *host, struct mmc_command *cmd)
+{
 	u8 ctrl;
 	struct mmc_data *data = cmd->data;
 	int ret;
 
 	WARN_ON(host->data);
 
-	if (data || (cmd->flags & MMC_RSP_BUSY)) {
-		count = sdhci_calc_timeout(host, cmd);
-		sdhci_writeb(host, count, SDHCI_TIMEOUT_CONTROL);
-	}
+	if (data || (cmd->flags & MMC_RSP_BUSY))
+		sdhci_set_timeout(host, cmd);
 
 	if (!data)
 		return;
* Unmerged path drivers/mmc/host/sdhci.h
