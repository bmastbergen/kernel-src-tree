mmc: core: fix card detection regression

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] core: fix card detection regression (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 93.33%
commit-author Kristina Martsenko <kristina.martsenko@gmail.com>
commit a31b0c6c19bf28c54999c3cd8cc3a7c8ba565a45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a31b0c6c.failed

Since commit 89168b489915 ("mmc: core: restore detect line inversion
semantics"), the SD card on i.MX28 (and possibly other) devices isn't
detected and booting stops at:

[    4.120617] Waiting for root device /dev/mmcblk0p3...

This is caused by the MMC_CAP2_CD_ACTIVE_HIGH flag being set incorrectly
when the host controller doesn't use a GPIO for card detection (but
instead uses a dedicated pin). In this case mmc_gpiod_request_cd() will
return before assigning to the gpio_invert variable, leaving the
variable uninitialized. The variable then gets used to set the flag.
This patch fixes the issue by making sure gpio_invert is set to false
when a GPIO isn't used. After this patch, i.MX28 boots fine.

The MMC_CAP2_RO_ACTIVE_HIGH (write protect) flag is also set incorrectly
for the exact same reason (it uses the same uninitialized variable), so
this patch fixes that too.

Fixes: 89168b489915 ("mmc: core: restore detect line inversion semantics")
	Reported-by: Stefan Wahren <stefan.wahren@i2se.com>
	Signed-off-by: Kristina Mart≈°enko <kristina.martsenko@gmail.com>
	Tested-by: Fabio Estevam <fabio.estevam@freescale.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit a31b0c6c19bf28c54999c3cd8cc3a7c8ba565a45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/host.c
diff --cc drivers/mmc/core/host.c
index 5e896e1f24c1,270d58a4c43d..000000000000
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@@ -310,9 -310,9 +310,15 @@@ int mmc_of_parse(struct mmc_host *host
  {
  	struct device_node *np;
  	u32 bus_width;
++<<<<<<< HEAD
 +	bool explicit_inv_wp, gpio_inv_wp = false;
 +	enum of_gpio_flags flags;
 +	int len, ret, gpio;
++=======
+ 	int len, ret;
+ 	bool cd_cap_invert, cd_gpio_invert = false;
+ 	bool ro_cap_invert, ro_gpio_invert = false;
++>>>>>>> a31b0c6c19bf (mmc: core: fix card detection regression)
  
  	if (!host->parent || !host->parent->of_node)
  		return 0;
@@@ -360,59 -360,56 +366,109 @@@
  	if (of_find_property(np, "non-removable", &len)) {
  		host->caps |= MMC_CAP_NONREMOVABLE;
  	} else {
++<<<<<<< HEAD
 +		bool explicit_inv_cd, gpio_inv_cd = false;
 +
 +		explicit_inv_cd = of_property_read_bool(np, "cd-inverted");
++=======
+ 		cd_cap_invert = of_property_read_bool(np, "cd-inverted");
++>>>>>>> a31b0c6c19bf (mmc: core: fix card detection regression)
  
  		if (of_find_property(np, "broken-cd", &len))
  			host->caps |= MMC_CAP_NEEDS_POLL;
  
++<<<<<<< HEAD
 +		gpio = of_get_named_gpio_flags(np, "cd-gpios", 0, &flags);
 +		if (gpio == -EPROBE_DEFER)
 +			return gpio;
 +		if (gpio_is_valid(gpio)) {
 +			if (!(flags & OF_GPIO_ACTIVE_LOW))
 +				gpio_inv_cd = true;
 +
 +			ret = mmc_gpio_request_cd(host, gpio);
 +			if (ret < 0) {
 +				dev_err(host->parent,
 +					"Failed to request CD GPIO #%d: %d!\n",
 +					gpio, ret);
 +				return ret;
 +			} else {
 +				dev_info(host->parent, "Got CD GPIO #%d.\n",
 +					 gpio);
 +			}
 +		}
 +
 +		if (explicit_inv_cd ^ gpio_inv_cd)
++=======
+ 		ret = mmc_gpiod_request_cd(host, "cd", 0, true,
+ 					   0, &cd_gpio_invert);
+ 		if (ret) {
+ 			if (ret == -EPROBE_DEFER)
+ 				return ret;
+ 			if (ret != -ENOENT) {
+ 				dev_err(host->parent,
+ 					"Failed to request CD GPIO: %d\n",
+ 					ret);
+ 			}
+ 		} else
+ 			dev_info(host->parent, "Got CD GPIO\n");
+ 
+ 		/*
+ 		 * There are two ways to flag that the CD line is inverted:
+ 		 * through the cd-inverted flag and by the GPIO line itself
+ 		 * being inverted from the GPIO subsystem. This is a leftover
+ 		 * from the times when the GPIO subsystem did not make it
+ 		 * possible to flag a line as inverted.
+ 		 *
+ 		 * If the capability on the host AND the GPIO line are
+ 		 * both inverted, the end result is that the CD line is
+ 		 * not inverted.
+ 		 */
+ 		if (cd_cap_invert ^ cd_gpio_invert)
++>>>>>>> a31b0c6c19bf (mmc: core: fix card detection regression)
  			host->caps2 |= MMC_CAP2_CD_ACTIVE_HIGH;
  	}
  
  	/* Parse Write Protection */
++<<<<<<< HEAD
 +	explicit_inv_wp = of_property_read_bool(np, "wp-inverted");
 +
 +	gpio = of_get_named_gpio_flags(np, "wp-gpios", 0, &flags);
 +	if (gpio == -EPROBE_DEFER) {
 +		ret = -EPROBE_DEFER;
 +		goto out;
 +	}
 +	if (gpio_is_valid(gpio)) {
 +		if (!(flags & OF_GPIO_ACTIVE_LOW))
 +			gpio_inv_wp = true;
 +
 +		ret = mmc_gpio_request_ro(host, gpio);
 +		if (ret < 0) {
++=======
+ 	ro_cap_invert = of_property_read_bool(np, "wp-inverted");
+ 
+ 	ret = mmc_gpiod_request_ro(host, "wp", 0, false, 0, &ro_gpio_invert);
+ 	if (ret) {
+ 		if (ret == -EPROBE_DEFER)
+ 			goto out;
+ 		if (ret != -ENOENT) {
++>>>>>>> a31b0c6c19bf (mmc: core: fix card detection regression)
  			dev_err(host->parent,
 -				"Failed to request WP GPIO: %d\n",
 -				ret);
 +				"Failed to request WP GPIO: %d!\n", ret);
 +			goto out;
 +		} else {
 +				dev_info(host->parent, "Got WP GPIO #%d.\n",
 +					 gpio);
  		}
++<<<<<<< HEAD
 +	}
 +	if (explicit_inv_wp ^ gpio_inv_wp)
++=======
+ 	} else
+ 		dev_info(host->parent, "Got WP GPIO\n");
+ 
+ 	/* See the comment on CD inversion above */
+ 	if (ro_cap_invert ^ ro_gpio_invert)
++>>>>>>> a31b0c6c19bf (mmc: core: fix card detection regression)
  		host->caps2 |= MMC_CAP2_RO_ACTIVE_HIGH;
  
  	if (of_find_property(np, "cap-sd-highspeed", &len))
* Unmerged path drivers/mmc/core/host.c
