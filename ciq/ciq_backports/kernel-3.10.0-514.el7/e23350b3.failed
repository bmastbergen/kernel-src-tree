mmc: core: Factor out common code in drive strength selection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] core: Factor out common code in drive strength selection (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 95.73%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit e23350b35deb77ef8e33c35dbb0ed1dab9e8ab86
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e23350b3.failed

Make a new function out of common code used for drive
strength selection.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit e23350b35deb77ef8e33c35dbb0ed1dab9e8ab86)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/sd.c
#	drivers/mmc/core/sdio.c
diff --cc drivers/mmc/core/sd.c
index da5e61e128a5,9771b84db4b3..000000000000
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@@ -388,64 -386,28 +388,75 @@@ out
  
  static int sd_select_driver_type(struct mmc_card *card, u8 *status)
  {
++<<<<<<< HEAD
 +	int host_drv_type = SD_DRIVER_TYPE_B;
 +	int card_drv_type = SD_DRIVER_TYPE_B;
 +	int drive_strength;
 +	int err;
 +
 +	/*
 +	 * If the host doesn't support any of the Driver Types A,C or D,
 +	 * or there is no board specific handler then default Driver
 +	 * Type B is used.
 +	 */
 +	if (!(card->host->caps & (MMC_CAP_DRIVER_TYPE_A | MMC_CAP_DRIVER_TYPE_C
 +	    | MMC_CAP_DRIVER_TYPE_D)))
 +		return 0;
 +
 +	if (!card->host->ops->select_drive_strength)
 +		return 0;
 +
 +	if (card->host->caps & MMC_CAP_DRIVER_TYPE_A)
 +		host_drv_type |= SD_DRIVER_TYPE_A;
 +
 +	if (card->host->caps & MMC_CAP_DRIVER_TYPE_C)
 +		host_drv_type |= SD_DRIVER_TYPE_C;
 +
 +	if (card->host->caps & MMC_CAP_DRIVER_TYPE_D)
 +		host_drv_type |= SD_DRIVER_TYPE_D;
 +
 +	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_A)
 +		card_drv_type |= SD_DRIVER_TYPE_A;
 +
 +	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
 +		card_drv_type |= SD_DRIVER_TYPE_C;
 +
 +	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_D)
 +		card_drv_type |= SD_DRIVER_TYPE_D;
 +
 +	/*
 +	 * The drive strength that the hardware can support
 +	 * depends on the board design.  Pass the appropriate
 +	 * information and let the hardware specific code
 +	 * return what is possible given the options
 +	 */
 +	mmc_host_clk_hold(card->host);
 +	drive_strength = card->host->ops->select_drive_strength(
 +		card->sw_caps.uhs_max_dtr,
 +		host_drv_type, card_drv_type);
 +	mmc_host_clk_release(card->host);
++=======
+ 	int card_drv_type, drive_strength, drv_type;
+ 	int err;
+ 
+ 	card_drv_type = card->sw_caps.sd3_drv_type | SD_DRIVER_TYPE_B;
+ 
+ 	drive_strength = mmc_select_drive_strength(card,
+ 						   card->sw_caps.uhs_max_dtr,
+ 						   card_drv_type, &drv_type);
++>>>>>>> e23350b35deb (mmc: core: Factor out common code in drive strength selection)
  
 -	if (drive_strength) {
 -		err = mmc_sd_switch(card, 1, 2, drive_strength, status);
 -		if (err)
 -			return err;
 -		if ((status[15] & 0xF) != drive_strength) {
 -			pr_warn("%s: Problem setting drive strength!\n",
 -				mmc_hostname(card->host));
 -			return 0;
 -		}
 +	err = mmc_sd_switch(card, 1, 2, drive_strength, status);
 +	if (err)
 +		return err;
 +
 +	if ((status[15] & 0xF) != drive_strength) {
 +		pr_warning("%s: Problem setting drive strength!\n",
 +			mmc_hostname(card->host));
 +		return 0;
  	}
  
 -	if (drv_type)
 -		mmc_set_driver_type(card->host, drv_type);
 +	mmc_set_driver_type(card->host, drive_strength);
  
  	return 0;
  }
diff --cc drivers/mmc/core/sdio.c
index d2f16e27144d,73b091331c96..000000000000
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@@ -402,69 -402,35 +402,81 @@@ static unsigned char host_drive_to_sdio
  
  static void sdio_select_driver_type(struct mmc_card *card)
  {
++<<<<<<< HEAD
 +	int host_drv_type = SD_DRIVER_TYPE_B;
 +	int card_drv_type = SD_DRIVER_TYPE_B;
 +	int drive_strength;
 +	unsigned char card_strength;
 +	int err;
 +
 +	/*
 +	 * If the host doesn't support any of the Driver Types A,C or D,
 +	 * or there is no board specific handler then default Driver
 +	 * Type B is used.
 +	 */
 +	if (!(card->host->caps &
 +		(MMC_CAP_DRIVER_TYPE_A |
 +		 MMC_CAP_DRIVER_TYPE_C |
 +		 MMC_CAP_DRIVER_TYPE_D)))
 +		return;
 +
 +	if (!card->host->ops->select_drive_strength)
 +		return;
 +
 +	if (card->host->caps & MMC_CAP_DRIVER_TYPE_A)
 +		host_drv_type |= SD_DRIVER_TYPE_A;
 +
 +	if (card->host->caps & MMC_CAP_DRIVER_TYPE_C)
 +		host_drv_type |= SD_DRIVER_TYPE_C;
 +
 +	if (card->host->caps & MMC_CAP_DRIVER_TYPE_D)
 +		host_drv_type |= SD_DRIVER_TYPE_D;
 +
 +	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_A)
 +		card_drv_type |= SD_DRIVER_TYPE_A;
 +
 +	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
 +		card_drv_type |= SD_DRIVER_TYPE_C;
 +
 +	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_D)
 +		card_drv_type |= SD_DRIVER_TYPE_D;
 +
 +	/*
 +	 * The drive strength that the hardware can support
 +	 * depends on the board design.  Pass the appropriate
 +	 * information and let the hardware specific code
 +	 * return what is possible given the options
 +	 */
 +	drive_strength = card->host->ops->select_drive_strength(
 +		card->sw_caps.uhs_max_dtr,
 +		host_drv_type, card_drv_type);
++=======
+ 	int card_drv_type, drive_strength, drv_type;
+ 	unsigned char card_strength;
+ 	int err;
+ 
+ 	card_drv_type = card->sw_caps.sd3_drv_type | SD_DRIVER_TYPE_B;
+ 
+ 	drive_strength = mmc_select_drive_strength(card,
+ 						   card->sw_caps.uhs_max_dtr,
+ 						   card_drv_type, &drv_type);
++>>>>>>> e23350b35deb (mmc: core: Factor out common code in drive strength selection)
  
 -	if (drive_strength) {
 -		/* if error just use default for drive strength B */
 -		err = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_DRIVE_STRENGTH, 0,
 -				       &card_strength);
 -		if (err)
 -			return;
 +	/* if error just use default for drive strength B */
 +	err = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_DRIVE_STRENGTH, 0,
 +		&card_strength);
 +	if (err)
 +		return;
  
 -		card_strength &= ~(SDIO_DRIVE_DTSx_MASK<<SDIO_DRIVE_DTSx_SHIFT);
 -		card_strength |= host_drive_to_sdio_drive(drive_strength);
 +	card_strength &= ~(SDIO_DRIVE_DTSx_MASK<<SDIO_DRIVE_DTSx_SHIFT);
 +	card_strength |= host_drive_to_sdio_drive(drive_strength);
  
 -		/* if error default to drive strength B */
 -		err = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_DRIVE_STRENGTH,
 -				       card_strength, NULL);
 -		if (err)
 -			return;
 -	}
 +	err = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_DRIVE_STRENGTH,
 +		card_strength, NULL);
  
 -	if (drv_type)
 -		mmc_set_driver_type(card->host, drv_type);
 +	/* if error default to drive strength B */
 +	if (!err)
 +		mmc_set_driver_type(card->host, drive_strength);
  }
  
  
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 5372081810b2..7618fdba271b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1592,6 +1592,44 @@ void mmc_set_driver_type(struct mmc_host *host, unsigned int drv_type)
 	mmc_host_clk_release(host);
 }
 
+int mmc_select_drive_strength(struct mmc_card *card, unsigned int max_dtr,
+			      int card_drv_type, int *drv_type)
+{
+	struct mmc_host *host = card->host;
+	int host_drv_type = SD_DRIVER_TYPE_B;
+	int drive_strength;
+
+	*drv_type = 0;
+
+	if (!host->ops->select_drive_strength)
+		return 0;
+
+	/* Use SD definition of driver strength for hosts */
+	if (host->caps & MMC_CAP_DRIVER_TYPE_A)
+		host_drv_type |= SD_DRIVER_TYPE_A;
+
+	if (host->caps & MMC_CAP_DRIVER_TYPE_C)
+		host_drv_type |= SD_DRIVER_TYPE_C;
+
+	if (host->caps & MMC_CAP_DRIVER_TYPE_D)
+		host_drv_type |= SD_DRIVER_TYPE_D;
+
+	/*
+	 * The drive strength that the hardware can support
+	 * depends on the board design.  Pass the appropriate
+	 * information and let the hardware specific code
+	 * return what is possible given the options
+	 */
+	mmc_host_clk_hold(host);
+	drive_strength = host->ops->select_drive_strength(card, max_dtr,
+							  host_drv_type,
+							  card_drv_type,
+							  drv_type);
+	mmc_host_clk_release(host);
+
+	return drive_strength;
+}
+
 /*
  * Apply power to the MMC stack.  This is a two-stage process.
  * First, we enable power to the card without the clock running.
diff --git a/drivers/mmc/core/core.h b/drivers/mmc/core/core.h
index f712f6e0bc34..fbedbede0bc2 100644
--- a/drivers/mmc/core/core.h
+++ b/drivers/mmc/core/core.h
@@ -49,6 +49,8 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr);
 int __mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage);
 void mmc_set_timing(struct mmc_host *host, unsigned int timing);
 void mmc_set_driver_type(struct mmc_host *host, unsigned int drv_type);
+int mmc_select_drive_strength(struct mmc_card *card, unsigned int max_dtr,
+			      int card_drv_type, int *drv_type);
 void mmc_power_up(struct mmc_host *host, u32 ocr);
 void mmc_power_off(struct mmc_host *host);
 void mmc_power_cycle(struct mmc_host *host, u32 ocr);
* Unmerged path drivers/mmc/core/sd.c
* Unmerged path drivers/mmc/core/sdio.c
