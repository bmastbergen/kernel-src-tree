net: fix sk_mem_reclaim_partial()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] fix sk_mem_reclaim_partial() (Paolo Abeni) [1290901]
Rebuild_FUZZ: 91.80%
commit-author Eric Dumazet <edumazet@google.com>
commit 1a24e04e4b50939daa3041682b38b82c896ca438
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1a24e04e.failed

sk_mem_reclaim_partial() goal is to ensure each socket has
one SK_MEM_QUANTUM forward allocation. This is needed both for
performance and better handling of memory pressure situations in
follow up patches.

SK_MEM_QUANTUM is currently a page, but might be reduced to 4096 bytes
as some arches have 64KB pages.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1a24e04e4b50939daa3041682b38b82c896ca438)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sock.h
diff --cc include/net/sock.h
index ae98ecc11e79,4581a60636f8..000000000000
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@@ -1409,8 -1367,8 +1409,13 @@@ static inline struct inode *SOCK_INODE(
  /*
   * Functions for memory accounting
   */
++<<<<<<< HEAD
 +extern int __sk_mem_schedule(struct sock *sk, int size, int kind);
 +extern void __sk_mem_reclaim(struct sock *sk);
++=======
+ int __sk_mem_schedule(struct sock *sk, int size, int kind);
+ void __sk_mem_reclaim(struct sock *sk, int amount);
++>>>>>>> 1a24e04e4b50 (net: fix sk_mem_reclaim_partial())
  
  #define SK_MEM_QUANTUM ((int)PAGE_SIZE)
  #define SK_MEM_QUANTUM_SHIFT ilog2(SK_MEM_QUANTUM)
* Unmerged path include/net/sock.h
diff --git a/net/core/sock.c b/net/core/sock.c
index 2c815b001fc9..df09574c738d 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -2074,12 +2074,13 @@ EXPORT_SYMBOL(__sk_mem_schedule);
 /**
  *	__sk_reclaim - reclaim memory_allocated
  *	@sk: socket
+ *	@amount: number of bytes (rounded down to a SK_MEM_QUANTUM multiple)
  */
-void __sk_mem_reclaim(struct sock *sk)
+void __sk_mem_reclaim(struct sock *sk, int amount)
 {
-	sk_memory_allocated_sub(sk,
-				sk->sk_forward_alloc >> SK_MEM_QUANTUM_SHIFT);
-	sk->sk_forward_alloc &= SK_MEM_QUANTUM - 1;
+	amount >>= SK_MEM_QUANTUM_SHIFT;
+	sk_memory_allocated_sub(sk, amount);
+	sk->sk_forward_alloc -= amount << SK_MEM_QUANTUM_SHIFT;
 
 	if (sk_under_memory_pressure(sk) &&
 	    (sk_memory_allocated(sk) < sk_prot_mem_limits(sk, 0)))
