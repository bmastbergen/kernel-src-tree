hv_netvsc: Set vRSS with num_chn in RNDIS filter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Andrew Schwartzmeyer <andschwa@microsoft.com>
commit 8ebdcc52b9b8a53e3ba2643f515d41fff44d4743
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8ebdcc52.failed

Uses device_info->num_chn to pass user provided number of vRSS
queues (from ethtool --set-channels) to rndis_filter_device_add. If
nonzero and less than the maximum, set net_device->num_chn to the given
value; else default to prior algorithm.

Always initialize struct device_info to 0, otherwise not all its fields
are guaranteed to be 0, which is necessary when checking if num_chn has
been purposefully set.

	Signed-off-by: Andrew Schwartzmeyer <andschwa@microsoft.com>
	Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8ebdcc52b9b8a53e3ba2643f515d41fff44d4743)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/rndis_filter.c
diff --cc drivers/net/hyperv/hyperv_net.h
index cf498664d989,5fa98f599b3d..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -156,6 -161,8 +156,11 @@@ struct netvsc_device_info 
  	unsigned char mac_adr[ETH_ALEN];
  	bool link_state;	/* 0 - link up, 1 - link down */
  	int  ring_size;
++<<<<<<< HEAD
++=======
+ 	u32  max_num_vrss_chns;
+ 	u32  num_chn;
++>>>>>>> 8ebdcc52b9b8 (hv_netvsc: Set vRSS with num_chn in RNDIS filter)
  };
  
  enum rndis_device_state {
diff --cc drivers/net/hyperv/rndis_filter.c
index 4f78abd49222,5931a799aa17..000000000000
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@@ -1107,9 -1115,26 +1107,29 @@@ int rndis_filter_device_add(struct hv_d
  	if (ret || rsscap.num_recv_que < 2)
  		goto out;
  
 -	num_rss_qs = min(device_info->max_num_vrss_chns, rsscap.num_recv_que);
 -
  	net_device->max_chn = rsscap.num_recv_que;
++<<<<<<< HEAD
 +	net_device->num_chn = (num_online_cpus() < rsscap.num_recv_que) ?
 +			       num_online_cpus() : rsscap.num_recv_que;
++=======
+ 
+ 	/*
+ 	 * We will limit the VRSS channels to the number CPUs in the NUMA node
+ 	 * the primary channel is currently bound to.
+ 	 */
+ 	node_cpu_mask = cpumask_of_node(cpu_to_node(dev->channel->target_cpu));
+ 	num_possible_rss_qs = cpumask_weight(node_cpu_mask);
+ 
+ 	/* We will use the given number of channels if available. */
+ 	if (device_info->num_chn && device_info->num_chn < net_device->max_chn)
+ 		net_device->num_chn = device_info->num_chn;
+ 	else
+ 		net_device->num_chn = min(num_possible_rss_qs, num_rss_qs);
+ 
+ 	num_rss_qs = net_device->num_chn - 1;
+ 	net_device->num_sc_offered = num_rss_qs;
+ 
++>>>>>>> 8ebdcc52b9b8 (hv_netvsc: Set vRSS with num_chn in RNDIS filter)
  	if (net_device->num_chn == 1)
  		goto out;
  
* Unmerged path drivers/net/hyperv/hyperv_net.h
diff --git a/drivers/net/hyperv/netvsc_drv.c b/drivers/net/hyperv/netvsc_drv.c
index 56b76b7b9a27..f7dab93a63d1 100644
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@ -757,6 +757,8 @@ static int netvsc_change_mtu(struct net_device *ndev, int mtu)
 
 	ndevctx->device_ctx = hdev;
 	hv_set_drvdata(hdev, ndev);
+
+	memset(&device_info, 0, sizeof(device_info));
 	device_info.ring_size = ring_size;
 	rndis_filter_device_add(hdev, &device_info);
 
@@ -893,6 +895,7 @@ static int netvsc_probe(struct hv_device *dev,
 	SET_NETDEV_DEV(net, &dev->device);
 
 	/* Notify the netvsc driver of the new device */
+	memset(&device_info, 0, sizeof(device_info));
 	device_info.ring_size = ring_size;
 	ret = rndis_filter_device_add(dev, &device_info);
 	if (ret != 0) {
* Unmerged path drivers/net/hyperv/rndis_filter.c
