mmc: sdhci: Define maximum segments

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] sdhci: Define maximum segments (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 92.31%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 4fb213f81fe51ace7dea7d2f7cc2417fa2a2dd9e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4fb213f8.failed

Define the maximum number of segments instead of
having the constant 128 appearing in the code in
various places.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 4fb213f81fe51ace7dea7d2f7cc2417fa2a2dd9e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci.c
diff --cc drivers/mmc/host/sdhci.c
index e2d27069abbd,586c7391a066..000000000000
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@@ -2871,21 -2872,26 +2871,29 @@@ int sdhci_add_host(struct sdhci_host *h
  
  	if (host->flags & SDHCI_USE_ADMA) {
  		/*
 -		 * The DMA descriptor table size is calculated as the maximum
 -		 * number of segments times 2, to allow for an alignment
 -		 * descriptor for each segment, plus 1 for a nop end descriptor,
 -		 * all multipled by the descriptor size.
 +		 * We need to allocate descriptors for all sg entries
 +		 * (128) and potentially one alignment transfer for
 +		 * each of those entries.
  		 */
++<<<<<<< HEAD
++=======
+ 		host->adma_table_sz = (SDHCI_MAX_SEGS * 2 + 1) * 8;
+ 		host->align_buffer_sz = SDHCI_MAX_SEGS * 4;
+ 		host->desc_sz = 8;
+ 		host->align_sz = 4;
+ 		host->align_mask = 3;
++>>>>>>> 4fb213f81fe5 (mmc: sdhci: Define maximum segments)
  		host->adma_table = dma_alloc_coherent(mmc_dev(mmc),
 -						      host->adma_table_sz,
 +						      ADMA_SIZE,
  						      &host->adma_addr,
  						      GFP_KERNEL);
 -		host->align_buffer = kmalloc(host->align_buffer_sz, GFP_KERNEL);
 +		host->align_buffer = kmalloc(128 * 4, GFP_KERNEL);
  		if (!host->adma_table || !host->align_buffer) {
 -			dma_free_coherent(mmc_dev(mmc), host->adma_table_sz,
 +			dma_free_coherent(mmc_dev(mmc), ADMA_SIZE,
  					  host->adma_table, host->adma_addr);
  			kfree(host->align_buffer);
 -			pr_warn("%s: Unable to allocate ADMA buffers - falling back to standard DMA\n",
 +			pr_warning("%s: Unable to allocate ADMA "
 +				"buffers. Falling back to standard DMA.\n",
  				mmc_hostname(mmc));
  			host->flags &= ~SDHCI_USE_ADMA;
  			host->adma_table = NULL;
* Unmerged path drivers/mmc/host/sdhci.c
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index 4dea27050ed1..06aa00b4e3d7 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -266,6 +266,12 @@
 #define SDHCI_DEFAULT_BOUNDARY_SIZE  (512 * 1024)
 #define SDHCI_DEFAULT_BOUNDARY_ARG   (ilog2(SDHCI_DEFAULT_BOUNDARY_SIZE) - 12)
 
+/*
+ * Maximum segments assuming a 512KiB maximum requisition size and a minimum
+ * 4KiB page size.
+ */
+#define SDHCI_MAX_SEGS		128
+
 struct sdhci_ops {
 #ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
 	u32		(*read_l)(struct sdhci_host *host, int reg);
