staging/rdma/hfi1: Remove mmap from hfi1

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Remove mmap from hfi1 (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 88.89%
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit 92c24be1e8a1a9110428130271c7dc670fb1e0a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/92c24be1.failed

Mmap data structure has already been moved to rdmavt and hfi1 supports
it. Now that the mmap functionality has also been moved to rdmavt its
time for hfi1 to use that as well.

	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 92c24be1e8a1a9110428130271c7dc670fb1e0a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/Makefile
#	drivers/staging/hfi1/mmap.c
#	drivers/staging/hfi1/verbs.c
#	drivers/staging/hfi1/verbs.h
diff --cc drivers/staging/hfi1/Makefile
index 2e5daa6cdcc2,55077f396cf9..000000000000
--- a/drivers/staging/hfi1/Makefile
+++ b/drivers/staging/hfi1/Makefile
@@@ -7,10 -7,10 +7,15 @@@
  #
  obj-$(CONFIG_INFINIBAND_HFI1) += hfi1.o
  
++<<<<<<< HEAD:drivers/staging/hfi1/Makefile
 +hfi1-y := chip.o cq.o device.o diag.o dma.o driver.o eprom.o file_ops.o firmware.o \
 +	init.o intr.o keys.o mad.o mmap.o mr.o pcie.o pio.o pio_copy.o \
++=======
+ hfi1-y := chip.o cq.o device.o diag.o driver.o efivar.o eprom.o file_ops.o firmware.o \
+ 	init.o intr.o mad.o pcie.o pio.o pio_copy.o \
++>>>>>>> 92c24be1e8a1 (staging/rdma/hfi1: Remove mmap from hfi1):drivers/staging/rdma/hfi1/Makefile
  	qp.o qsfp.o rc.o ruc.o sdma.o srq.o sysfs.o trace.o twsi.o \
 -	uc.o ud.o user_exp_rcv.o user_pages.o user_sdma.o verbs_mcast.o verbs.o
 +	uc.o ud.o user_pages.o user_sdma.o verbs_mcast.o verbs.o
  hfi1-$(CONFIG_DEBUG_FS) += debugfs.o
  
  CFLAGS_trace.o = -I$(src)
diff --cc drivers/staging/hfi1/verbs.c
index cfa74cbcf382,11f08ea77559..000000000000
--- a/drivers/staging/hfi1/verbs.c
+++ b/drivers/staging/hfi1/verbs.c
@@@ -1876,34 -1796,7 +1876,35 @@@ int hfi1_register_ib_device(struct hfi1
  	dev->mem_timer.function = mem_timer;
  	dev->mem_timer.data = (unsigned long) dev;
  
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +	/*
 +	 * The top hfi1_lkey_table_size bits are used to index the
 +	 * table.  The lower 8 bits can be owned by the user (copied from
 +	 * the LKEY).  The remaining bits act as a generation number or tag.
 +	 */
 +	spin_lock_init(&dev->lk_table.lock);
 +	dev->lk_table.max = 1 << hfi1_lkey_table_size;
 +	/* ensure generation is at least 4 bits (keys.c) */
 +	if (hfi1_lkey_table_size > RVT_MAX_LKEY_TABLE_BITS) {
 +		dd_dev_warn(dd, "lkey bits %u too large, reduced to %u\n",
 +			      hfi1_lkey_table_size, RVT_MAX_LKEY_TABLE_BITS);
 +		hfi1_lkey_table_size = RVT_MAX_LKEY_TABLE_BITS;
 +	}
 +	lk_tab_size = dev->lk_table.max * sizeof(*dev->lk_table.table);
 +	dev->lk_table.table = (struct rvt_mregion __rcu **)
 +		vmalloc(lk_tab_size);
 +	if (dev->lk_table.table == NULL) {
 +		ret = -ENOMEM;
 +		goto err_lk;
 +	}
 +	RCU_INIT_POINTER(dev->dma_mr, NULL);
 +	for (i = 0; i < dev->lk_table.max; i++)
 +		RCU_INIT_POINTER(dev->lk_table.table[i], NULL);
 +	INIT_LIST_HEAD(&dev->pending_mmaps);
 +	spin_lock_init(&dev->pending_lock);
++=======
++>>>>>>> 92c24be1e8a1 (staging/rdma/hfi1: Remove mmap from hfi1):drivers/staging/rdma/hfi1/verbs.c
  	seqlock_init(&dev->iowait_lock);
- 	dev->mmap_offset = PAGE_SIZE;
- 	spin_lock_init(&dev->mmap_offset_lock);
  	INIT_LIST_HEAD(&dev->txwait);
  	INIT_LIST_HEAD(&dev->memwait);
  
@@@ -2011,8 -1902,8 +2012,13 @@@
  	ibdev->attach_mcast = hfi1_multicast_attach;
  	ibdev->detach_mcast = hfi1_multicast_detach;
  	ibdev->process_mad = hfi1_process_mad;
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +	ibdev->mmap = hfi1_mmap;
 +	ibdev->dma_ops = &hfi1_dma_mapping_ops;
++=======
+ 	ibdev->mmap = NULL;
+ 	ibdev->dma_ops = NULL;
++>>>>>>> 92c24be1e8a1 (staging/rdma/hfi1: Remove mmap from hfi1):drivers/staging/rdma/hfi1/verbs.c
  	ibdev->get_port_immutable = port_immutable;
  
  	strncpy(ibdev->node_desc, init_utsname()->nodename,
diff --cc drivers/staging/hfi1/verbs.h
index 34fa7beced4f,eb1297825225..000000000000
--- a/drivers/staging/hfi1/verbs.h
+++ b/drivers/staging/hfi1/verbs.h
@@@ -700,14 -423,9 +700,18 @@@ struct hfi1_ibport 
  	u8 sc_to_sl[32];
  };
  
 +
  struct hfi1_qp_ibdev;
  struct hfi1_ibdev {
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.h
 +	struct ib_device ibdev;
 +	struct list_head pending_mmaps;
 +	spinlock_t mmap_offset_lock; /* protect mmap_offset */
 +	u32 mmap_offset;
 +	struct rvt_mregion __rcu *dma_mr;
++=======
+ 	struct rvt_dev_info rdi; /* Must be first */
++>>>>>>> 92c24be1e8a1 (staging/rdma/hfi1: Remove mmap from hfi1):drivers/staging/rdma/hfi1/verbs.h
  
  	struct hfi1_qp_ibdev *qp_dev;
  
@@@ -1030,21 -674,12 +1031,27 @@@ static inline void hfi1_put_ss(struct h
  	}
  }
  
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.h
 +void hfi1_release_mmap_info(struct kref *ref);
 +
 +struct hfi1_mmap_info *hfi1_create_mmap_info(struct hfi1_ibdev *dev, u32 size,
 +					     struct ib_ucontext *context,
 +					     void *obj);
 +
 +void hfi1_update_mmap_info(struct hfi1_ibdev *dev, struct hfi1_mmap_info *ip,
 +			   u32 size, void *obj);
 +
 +int hfi1_mmap(struct ib_ucontext *context, struct vm_area_struct *vma);
 +
 +int hfi1_get_rwqe(struct hfi1_qp *qp, int wr_id_only);
++=======
+ int hfi1_get_rwqe(struct rvt_qp *qp, int wr_id_only);
+ 
+ void hfi1_migrate_qp(struct rvt_qp *qp);
++>>>>>>> 92c24be1e8a1 (staging/rdma/hfi1: Remove mmap from hfi1):drivers/staging/rdma/hfi1/verbs.h
  
  int hfi1_ruc_check_hdr(struct hfi1_ibport *ibp, struct hfi1_ib_header *hdr,
 -		       int has_grh, struct rvt_qp *qp, u32 bth0);
 +		       int has_grh, struct hfi1_qp *qp, u32 bth0);
  
  u32 hfi1_make_grh(struct hfi1_ibport *ibp, struct ib_grh *hdr,
  		  struct ib_global_route *grh, u32 hwords, u32 nwords);
* Unmerged path drivers/staging/hfi1/mmap.c
* Unmerged path drivers/staging/hfi1/Makefile
diff --git a/drivers/staging/hfi1/cq.c b/drivers/staging/hfi1/cq.c
index 4f046ffe7e60..6394855a9cd0 100644
--- a/drivers/staging/hfi1/cq.c
+++ b/drivers/staging/hfi1/cq.c
@@ -277,7 +277,7 @@ struct ib_cq *hfi1_create_cq(
 	if (udata && udata->outlen >= sizeof(__u64)) {
 		int err;
 
-		cq->ip = hfi1_create_mmap_info(dev, sz, context, wc);
+		cq->ip = rvt_create_mmap_info(&dev->rdi, sz, context, wc);
 		if (!cq->ip) {
 			ret = ERR_PTR(-ENOMEM);
 			goto bail_wc;
@@ -303,9 +303,9 @@ struct ib_cq *hfi1_create_cq(
 	spin_unlock(&dev->n_cqs_lock);
 
 	if (cq->ip) {
-		spin_lock_irq(&dev->pending_lock);
-		list_add(&cq->ip->pending_mmaps, &dev->pending_mmaps);
-		spin_unlock_irq(&dev->pending_lock);
+		spin_lock_irq(&dev->rdi.pending_lock);
+		list_add(&cq->ip->pending_mmaps, &dev->rdi.pending_mmaps);
+		spin_unlock_irq(&dev->rdi.pending_lock);
 	}
 
 	/*
@@ -355,7 +355,7 @@ int hfi1_destroy_cq(struct ib_cq *ibcq)
 	dev->n_cqs_allocated--;
 	spin_unlock(&dev->n_cqs_lock);
 	if (cq->ip)
-		kref_put(&cq->ip->ref, hfi1_release_mmap_info);
+		kref_put(&cq->ip->ref, rvt_release_mmap_info);
 	else
 		vfree(cq->queue);
 	kfree(cq);
@@ -481,7 +481,7 @@ int hfi1_resize_cq(struct ib_cq *ibcq, int cqe, struct ib_udata *udata)
 		struct hfi1_ibdev *dev = to_idev(ibcq->device);
 		struct hfi1_mmap_info *ip = cq->ip;
 
-		hfi1_update_mmap_info(dev, ip, sz, wc);
+		rvt_update_mmap_info(&dev->rdi, ip, sz, wc);
 
 		/*
 		 * Return the offset to mmap.
@@ -494,10 +494,10 @@ int hfi1_resize_cq(struct ib_cq *ibcq, int cqe, struct ib_udata *udata)
 				goto bail;
 		}
 
-		spin_lock_irq(&dev->pending_lock);
+		spin_lock_irq(&dev->rdi.pending_lock);
 		if (list_empty(&ip->pending_mmaps))
-			list_add(&ip->pending_mmaps, &dev->pending_mmaps);
-		spin_unlock_irq(&dev->pending_lock);
+			list_add(&ip->pending_mmaps, &dev->rdi.pending_mmaps);
+		spin_unlock_irq(&dev->rdi.pending_lock);
 	}
 
 	ret = 0;
* Unmerged path drivers/staging/hfi1/mmap.c
diff --git a/drivers/staging/hfi1/qp.c b/drivers/staging/hfi1/qp.c
index 9ffed6e14d8e..5ff6fc1bbc0c 100644
--- a/drivers/staging/hfi1/qp.c
+++ b/drivers/staging/hfi1/qp.c
@@ -1193,7 +1193,7 @@ struct ib_qp *hfi1_create_qp(struct ib_pd *ibpd,
 		} else {
 			u32 s = sizeof(struct hfi1_rwq) + qp->r_rq.size * sz;
 
-			qp->ip = hfi1_create_mmap_info(dev, s,
+			qp->ip = rvt_create_mmap_info(&dev->rdi, s,
 						      ibpd->uobject->context,
 						      qp->r_rq.wq);
 			if (!qp->ip) {
@@ -1221,9 +1221,9 @@ struct ib_qp *hfi1_create_qp(struct ib_pd *ibpd,
 	spin_unlock(&dev->n_qps_lock);
 
 	if (qp->ip) {
-		spin_lock_irq(&dev->pending_lock);
-		list_add(&qp->ip->pending_mmaps, &dev->pending_mmaps);
-		spin_unlock_irq(&dev->pending_lock);
+		spin_lock_irq(&dev->rdi.pending_lock);
+		list_add(&qp->ip->pending_mmaps, &dev->rdi.pending_mmaps);
+		spin_unlock_irq(&dev->rdi.pending_lock);
 	}
 
 	ret = &qp->ibqp;
@@ -1254,7 +1254,7 @@ struct ib_qp *hfi1_create_qp(struct ib_pd *ibpd,
 
 bail_ip:
 	if (qp->ip)
-		kref_put(&qp->ip->ref, hfi1_release_mmap_info);
+		kref_put(&qp->ip->ref, rvt_release_mmap_info);
 	else
 		vfree(qp->r_rq.wq);
 	free_qpn(&dev->qp_dev->qpn_table, qp->ibqp.qp_num);
@@ -1314,7 +1314,7 @@ int hfi1_destroy_qp(struct ib_qp *ibqp)
 	spin_unlock(&dev->n_qps_lock);
 
 	if (qp->ip)
-		kref_put(&qp->ip->ref, hfi1_release_mmap_info);
+		kref_put(&qp->ip->ref, rvt_release_mmap_info);
 	else
 		vfree(qp->r_rq.wq);
 	vfree(qp->s_wq);
diff --git a/drivers/staging/hfi1/srq.c b/drivers/staging/hfi1/srq.c
index 67786d417493..688951de15e8 100644
--- a/drivers/staging/hfi1/srq.c
+++ b/drivers/staging/hfi1/srq.c
@@ -165,8 +165,8 @@ struct ib_srq *hfi1_create_srq(struct ib_pd *ibpd,
 		u32 s = sizeof(struct hfi1_rwq) + srq->rq.size * sz;
 
 		srq->ip =
-		    hfi1_create_mmap_info(dev, s, ibpd->uobject->context,
-					  srq->rq.wq);
+		    rvt_create_mmap_info(&dev->rdi, s, ibpd->uobject->context,
+					 srq->rq.wq);
 		if (!srq->ip) {
 			ret = ERR_PTR(-ENOMEM);
 			goto bail_wq;
@@ -200,9 +200,9 @@ struct ib_srq *hfi1_create_srq(struct ib_pd *ibpd,
 	spin_unlock(&dev->n_srqs_lock);
 
 	if (srq->ip) {
-		spin_lock_irq(&dev->pending_lock);
-		list_add(&srq->ip->pending_mmaps, &dev->pending_mmaps);
-		spin_unlock_irq(&dev->pending_lock);
+		spin_lock_irq(&dev->rdi.pending_lock);
+		list_add(&srq->ip->pending_mmaps, &dev->rdi.pending_mmaps);
+		spin_unlock_irq(&dev->rdi.pending_lock);
 	}
 
 	ret = &srq->ibsrq;
@@ -324,7 +324,7 @@ int hfi1_modify_srq(struct ib_srq *ibsrq, struct ib_srq_attr *attr,
 			struct hfi1_ibdev *dev = to_idev(srq->ibsrq.device);
 			u32 s = sizeof(struct hfi1_rwq) + size * sz;
 
-			hfi1_update_mmap_info(dev, ip, s, wq);
+			rvt_update_mmap_info(&dev->rdi, ip, s, wq);
 
 			/*
 			 * Return the offset to mmap.
@@ -341,11 +341,11 @@ int hfi1_modify_srq(struct ib_srq *ibsrq, struct ib_srq_attr *attr,
 			 * Put user mapping info onto the pending list
 			 * unless it already is on the list.
 			 */
-			spin_lock_irq(&dev->pending_lock);
+			spin_lock_irq(&dev->rdi.pending_lock);
 			if (list_empty(&ip->pending_mmaps))
 				list_add(&ip->pending_mmaps,
-					 &dev->pending_mmaps);
-			spin_unlock_irq(&dev->pending_lock);
+					 &dev->rdi.pending_mmaps);
+			spin_unlock_irq(&dev->rdi.pending_lock);
 		}
 	} else if (attr_mask & IB_SRQ_LIMIT) {
 		spin_lock_irq(&srq->rq.lock);
@@ -388,7 +388,7 @@ int hfi1_destroy_srq(struct ib_srq *ibsrq)
 	dev->n_srqs_allocated--;
 	spin_unlock(&dev->n_srqs_lock);
 	if (srq->ip)
-		kref_put(&srq->ip->ref, hfi1_release_mmap_info);
+		kref_put(&srq->ip->ref, rvt_release_mmap_info);
 	else
 		vfree(srq->rq.wq);
 	kfree(srq);
* Unmerged path drivers/staging/hfi1/verbs.c
* Unmerged path drivers/staging/hfi1/verbs.h
