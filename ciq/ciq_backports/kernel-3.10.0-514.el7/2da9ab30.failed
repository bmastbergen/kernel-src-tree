xprtrdma: Remove reply tasklet

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 2da9ab3008f359857eb594b0b4b0fee62f2a73c2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2da9ab30.failed

Clean up: The reply tasklet is no longer used.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
Tested-By: Devesh Sharma <devesh.sharma@avagotech.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 2da9ab3008f359857eb594b0b4b0fee62f2a73c2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/verbs.c
diff --cc net/sunrpc/xprtrdma/verbs.c
index 6115ededb593,3dd5a7c951c5..000000000000
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@@ -68,75 -68,35 +68,68 @@@
   * internal functions
   */
  
 -static struct workqueue_struct *rpcrdma_receive_wq;
++<<<<<<< HEAD
 +/*
 + * handle replies in tasklet context, using a single, global list
 + * rdma tasklet function -- just turn around and call the func
 + * for all replies on the list
 + */
  
 -int
 -rpcrdma_alloc_wq(void)
 -{
 -	struct workqueue_struct *recv_wq;
 +static DEFINE_SPINLOCK(rpcrdma_tk_lock_g);
 +static LIST_HEAD(rpcrdma_tasklets_g);
  
 -	recv_wq = alloc_workqueue("xprtrdma_receive",
 -				  WQ_MEM_RECLAIM | WQ_UNBOUND | WQ_HIGHPRI,
 -				  0);
 -	if (!recv_wq)
 -		return -ENOMEM;
 +static void
 +rpcrdma_run_tasklet(unsigned long data)
 +{
 +	struct rpcrdma_rep *rep;
 +	unsigned long flags;
  
 -	rpcrdma_receive_wq = recv_wq;
 -	return 0;
 -}
 +	data = data;
 +	spin_lock_irqsave(&rpcrdma_tk_lock_g, flags);
 +	while (!list_empty(&rpcrdma_tasklets_g)) {
 +		rep = list_entry(rpcrdma_tasklets_g.next,
 +				 struct rpcrdma_rep, rr_list);
 +		list_del(&rep->rr_list);
 +		spin_unlock_irqrestore(&rpcrdma_tk_lock_g, flags);
  
 -void
 -rpcrdma_destroy_wq(void)
 -{
 -	struct workqueue_struct *wq;
 +		rpcrdma_reply_handler(rep);
  
 -	if (rpcrdma_receive_wq) {
 -		wq = rpcrdma_receive_wq;
 -		rpcrdma_receive_wq = NULL;
 -		destroy_workqueue(wq);
 +		spin_lock_irqsave(&rpcrdma_tk_lock_g, flags);
  	}
 +	spin_unlock_irqrestore(&rpcrdma_tk_lock_g, flags);
  }
  
 +static DECLARE_TASKLET(rpcrdma_tasklet_g, rpcrdma_run_tasklet, 0UL);
 +
 +static const char * const async_event[] = {
 +	"CQ error",
 +	"QP fatal error",
 +	"QP request error",
 +	"QP access error",
 +	"communication established",
 +	"send queue drained",
 +	"path migration successful",
 +	"path mig error",
 +	"device fatal error",
 +	"port active",
 +	"port error",
 +	"LID change",
 +	"P_key change",
 +	"SM change",
 +	"SRQ error",
 +	"SRQ limit reached",
 +	"last WQE reached",
 +	"client reregister",
 +	"GID change",
 +};
++=======
++static struct workqueue_struct *rpcrdma_receive_wq;
++>>>>>>> 2da9ab3008f3 (xprtrdma: Remove reply tasklet)
 +
 +#define ASYNC_MSG(status)					\
 +	((status) < ARRAY_SIZE(async_event) ?			\
 +		async_event[(status)] : "unknown async error")
 +
- static void
- rpcrdma_schedule_tasklet(struct list_head *sched_list)
- {
- 	unsigned long flags;
- 
- 	spin_lock_irqsave(&rpcrdma_tk_lock_g, flags);
- 	list_splice_tail(sched_list, &rpcrdma_tasklets_g);
- 	spin_unlock_irqrestore(&rpcrdma_tk_lock_g, flags);
- 	tasklet_schedule(&rpcrdma_tasklet_g);
- }
- 
  static void
  rpcrdma_qp_async_error_upcall(struct ib_event *event, void *context)
  {
* Unmerged path net/sunrpc/xprtrdma/verbs.c
