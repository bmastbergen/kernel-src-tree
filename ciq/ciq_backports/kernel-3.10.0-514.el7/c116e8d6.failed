x86/efi: Split the boot stub into 32/64 code paths

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] efi: Split the boot stub into 32/64 code paths (Lenny Szubowicz) [1310154]
Rebuild_FUZZ: 95.83%
commit-author Matt Fleming <matt.fleming@intel.com>
commit c116e8d60adabfd545a269fccab85e77febc1643
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c116e8d6.failed

Make the decision which code path to take at runtime based on
efi_early->is64.

	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit c116e8d60adabfd545a269fccab85e77febc1643)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/eboot.c
diff --cc arch/x86/boot/compressed/eboot.c
index a1ae20b40077,ab1f3a2f1e1e..000000000000
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@@ -20,6 -19,267 +20,270 @@@
  
  static efi_system_table_t *sys_table;
  
++<<<<<<< HEAD
++=======
+ static struct efi_config *efi_early;
+ 
+ #define BOOT_SERVICES(bits)						\
+ static void setup_boot_services##bits(struct efi_config *c)		\
+ {									\
+ 	efi_system_table_##bits##_t *table;				\
+ 	efi_boot_services_##bits##_t *bt;				\
+ 									\
+ 	table = (typeof(table))sys_table;				\
+ 									\
+ 	c->text_output = table->con_out;				\
+ 									\
+ 	bt = (typeof(bt))(unsigned long)(table->boottime);		\
+ 									\
+ 	c->allocate_pool = bt->allocate_pool;				\
+ 	c->allocate_pages = bt->allocate_pages;				\
+ 	c->get_memory_map = bt->get_memory_map;				\
+ 	c->free_pool = bt->free_pool;					\
+ 	c->free_pages = bt->free_pages;					\
+ 	c->locate_handle = bt->locate_handle;				\
+ 	c->handle_protocol = bt->handle_protocol;			\
+ 	c->exit_boot_services = bt->exit_boot_services;			\
+ }
+ BOOT_SERVICES(32);
+ BOOT_SERVICES(64);
+ 
+ static void efi_printk(efi_system_table_t *, char *);
+ static void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
+ 
+ static efi_status_t
+ __file_size32(void *__fh, efi_char16_t *filename_16,
+ 	      void **handle, u64 *file_sz)
+ {
+ 	efi_file_handle_32_t *h, *fh = __fh;
+ 	efi_file_info_t *info;
+ 	efi_status_t status;
+ 	efi_guid_t info_guid = EFI_FILE_INFO_ID;
+ 	u32 info_sz;
+ 
+ 	status = efi_early->call((unsigned long)fh->open, fh, &h, filename_16,
+ 				 EFI_FILE_MODE_READ, (u64)0);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to open file: ");
+ 		efi_char16_printk(sys_table, filename_16);
+ 		efi_printk(sys_table, "\n");
+ 		return status;
+ 	}
+ 
+ 	*handle = h;
+ 
+ 	info_sz = 0;
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, NULL);
+ 	if (status != EFI_BUFFER_TOO_SMALL) {
+ 		efi_printk(sys_table, "Failed to get file info size\n");
+ 		return status;
+ 	}
+ 
+ grow:
+ 	status = efi_early->call(efi_early->allocate_pool, EFI_LOADER_DATA,
+ 				 info_sz, (void **)&info);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to alloc mem for file info\n");
+ 		return status;
+ 	}
+ 
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, info);
+ 	if (status == EFI_BUFFER_TOO_SMALL) {
+ 		efi_early->call(efi_early->free_pool, info);
+ 		goto grow;
+ 	}
+ 
+ 	*file_sz = info->file_size;
+ 	efi_early->call(efi_early->free_pool, info);
+ 
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to get initrd info\n");
+ 
+ 	return status;
+ }
+ 
+ static efi_status_t
+ __file_size64(void *__fh, efi_char16_t *filename_16,
+ 	      void **handle, u64 *file_sz)
+ {
+ 	efi_file_handle_64_t *h, *fh = __fh;
+ 	efi_file_info_t *info;
+ 	efi_status_t status;
+ 	efi_guid_t info_guid = EFI_FILE_INFO_ID;
+ 	u32 info_sz;
+ 
+ 	status = efi_early->call((unsigned long)fh->open, fh, &h, filename_16,
+ 				 EFI_FILE_MODE_READ, (u64)0);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to open file: ");
+ 		efi_char16_printk(sys_table, filename_16);
+ 		efi_printk(sys_table, "\n");
+ 		return status;
+ 	}
+ 
+ 	*handle = h;
+ 
+ 	info_sz = 0;
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, NULL);
+ 	if (status != EFI_BUFFER_TOO_SMALL) {
+ 		efi_printk(sys_table, "Failed to get file info size\n");
+ 		return status;
+ 	}
+ 
+ grow:
+ 	status = efi_early->call(efi_early->allocate_pool, EFI_LOADER_DATA,
+ 				 info_sz, (void **)&info);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to alloc mem for file info\n");
+ 		return status;
+ 	}
+ 
+ 	status = efi_early->call((unsigned long)h->get_info, h, &info_guid,
+ 				 &info_sz, info);
+ 	if (status == EFI_BUFFER_TOO_SMALL) {
+ 		efi_early->call(efi_early->free_pool, info);
+ 		goto grow;
+ 	}
+ 
+ 	*file_sz = info->file_size;
+ 	efi_early->call(efi_early->free_pool, info);
+ 
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to get initrd info\n");
+ 
+ 	return status;
+ }
+ static efi_status_t
+ efi_file_size(efi_system_table_t *sys_table, void *__fh,
+ 	      efi_char16_t *filename_16, void **handle, u64 *file_sz)
+ {
+ 	if (efi_early->is64)
+ 		return __file_size64(__fh, filename_16, handle, file_sz);
+ 
+ 	return __file_size32(__fh, filename_16, handle, file_sz);
+ }
+ 
+ static inline efi_status_t
+ efi_file_read(void *__fh, void *handle, unsigned long *size, void *addr)
+ {
+ 	unsigned long func;
+ 
+ 	if (efi_early->is64) {
+ 		efi_file_handle_64_t *fh = __fh;
+ 
+ 		func = (unsigned long)fh->read;
+ 		return efi_early->call(func, handle, size, addr);
+ 	} else {
+ 		efi_file_handle_32_t *fh = __fh;
+ 
+ 		func = (unsigned long)fh->read;
+ 		return efi_early->call(func, handle, size, addr);
+ 	}
+ }
+ 
+ static inline efi_status_t efi_file_close(void *__fh, void *handle)
+ {
+ 	if (efi_early->is64) {
+ 		efi_file_handle_64_t *fh = __fh;
+ 
+ 		return efi_early->call((unsigned long)fh->close, handle);
+ 	} else {
+ 		efi_file_handle_32_t *fh = __fh;
+ 
+ 		return efi_early->call((unsigned long)fh->close, handle);
+ 	}
+ }
+ 
+ static inline efi_status_t __open_volume32(void *__image, void **__fh)
+ {
+ 	efi_file_io_interface_t *io;
+ 	efi_loaded_image_32_t *image = __image;
+ 	efi_file_handle_32_t *fh;
+ 	efi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;
+ 	efi_status_t status;
+ 	void *handle = (void *)(unsigned long)image->device_handle;
+ 	unsigned long func;
+ 
+ 	status = efi_early->call(efi_early->handle_protocol, handle,
+ 				 &fs_proto, (void **)&io);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to handle fs_proto\n");
+ 		return status;
+ 	}
+ 
+ 	func = (unsigned long)io->open_volume;
+ 	status = efi_early->call(func, io, &fh);
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to open volume\n");
+ 
+ 	*__fh = fh;
+ 	return status;
+ }
+ 
+ static inline efi_status_t __open_volume64(void *__image, void **__fh)
+ {
+ 	efi_file_io_interface_t *io;
+ 	efi_loaded_image_64_t *image = __image;
+ 	efi_file_handle_64_t *fh;
+ 	efi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;
+ 	efi_status_t status;
+ 	void *handle = (void *)(unsigned long)image->device_handle;
+ 	unsigned long func;
+ 
+ 	status = efi_early->call(efi_early->handle_protocol, handle,
+ 				 &fs_proto, (void **)&io);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table, "Failed to handle fs_proto\n");
+ 		return status;
+ 	}
+ 
+ 	func = (unsigned long)io->open_volume;
+ 	status = efi_early->call(func, io, &fh);
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table, "Failed to open volume\n");
+ 
+ 	*__fh = fh;
+ 	return status;
+ }
+ 
+ static inline efi_status_t
+ efi_open_volume(efi_system_table_t *sys_table, void *__image, void **__fh)
+ {
+ 	if (efi_early->is64)
+ 		return __open_volume64(__image, __fh);
+ 
+ 	return __open_volume32(__image, __fh);
+ }
+ 
+ static void efi_char16_printk(efi_system_table_t *table, efi_char16_t *str)
+ {
+ 	unsigned long output_string;
+ 	size_t offset;
+ 
+ 	if (efi_early->is64) {
+ 		struct efi_simple_text_output_protocol_64 *out;
+ 		u64 *func;
+ 
+ 		offset = offsetof(typeof(*out), output_string);
+ 		output_string = efi_early->text_output + offset;
+ 		func = (u64 *)output_string;
+ 
+ 		efi_early->call(*func, efi_early->text_output, str);
+ 	} else {
+ 		struct efi_simple_text_output_protocol_32 *out;
+ 		u32 *func;
+ 
+ 		offset = offsetof(typeof(*out), output_string);
+ 		output_string = efi_early->text_output + offset;
+ 		func = (u32 *)output_string;
+ 
+ 		efi_early->call(*func, efi_early->text_output, str);
+ 	}
+ }
++>>>>>>> c116e8d60ada (x86/efi: Split the boot stub into 32/64 code paths)
  
  #include "../../../../drivers/firmware/efi/efi-stub-helper.c"
  
@@@ -48,28 -306,232 +312,241 @@@ static void find_bits(unsigned long mas
  	*size = len;
  }
  
- static efi_status_t setup_efi_pci(struct boot_params *params)
+ static efi_status_t
+ __setup_efi_pci32(efi_pci_io_protocol_32 *pci, struct pci_setup_rom **__rom)
  {
- 	efi_pci_io_protocol *pci;
+ 	struct pci_setup_rom *rom = NULL;
  	efi_status_t status;
++<<<<<<< HEAD
 +	void **pci_handle;
++=======
+ 	unsigned long size;
+ 	uint64_t attributes;
+ 
+ 	status = efi_early->call(pci->attributes, pci,
+ 				 EfiPciIoAttributeOperationGet, 0, 0,
+ 				 &attributes);
+ 	if (status != EFI_SUCCESS)
+ 		return status;
+ 
+ 	if (!pci->romimage || !pci->romsize)
+ 		return EFI_INVALID_PARAMETER;
+ 
+ 	size = pci->romsize + sizeof(*rom);
+ 
+ 	status = efi_early->call(efi_early->allocate_pool,
+ 				 EFI_LOADER_DATA, size, &rom);
+ 
+ 	if (status != EFI_SUCCESS)
+ 		return status;
+ 
+ 	memset(rom, 0, sizeof(*rom));
+ 
+ 	rom->data.type = SETUP_PCI;
+ 	rom->data.len = size - sizeof(struct setup_data);
+ 	rom->data.next = 0;
+ 	rom->pcilen = pci->romsize;
+ 	*__rom = rom;
+ 
+ 	status = efi_early->call(pci->pci.read, pci, EfiPciIoWidthUint16,
+ 				 PCI_VENDOR_ID, 1, &(rom->vendor));
+ 
+ 	if (status != EFI_SUCCESS)
+ 		goto free_struct;
+ 
+ 	status = efi_early->call(pci->pci.read, pci, EfiPciIoWidthUint16,
+ 				 PCI_DEVICE_ID, 1, &(rom->devid));
+ 
+ 	if (status != EFI_SUCCESS)
+ 		goto free_struct;
+ 
+ 	status = efi_early->call(pci->get_location, pci, &(rom->segment),
+ 				 &(rom->bus), &(rom->device), &(rom->function));
+ 
+ 	if (status != EFI_SUCCESS)
+ 		goto free_struct;
+ 
+ 	memcpy(rom->romdata, pci->romimage, pci->romsize);
+ 	return status;
+ 
+ free_struct:
+ 	efi_early->call(efi_early->free_pool, rom);
+ 	return status;
+ }
+ 
+ static efi_status_t
+ setup_efi_pci32(struct boot_params *params, void **pci_handle,
+ 		unsigned long size)
+ {
+ 	efi_pci_io_protocol_32 *pci = NULL;
++>>>>>>> c116e8d60ada (x86/efi: Split the boot stub into 32/64 code paths)
  	efi_guid_t pci_proto = EFI_PCI_IO_PROTOCOL_GUID;
- 	unsigned long nr_pci, size = 0;
- 	int i;
+ 	u32 *handles = (u32 *)(unsigned long)pci_handle;
+ 	efi_status_t status;
+ 	unsigned long nr_pci;
  	struct setup_data *data;
+ 	int i;
  
  	data = (struct setup_data *)(unsigned long)params->hdr.setup_data;
  
  	while (data && data->next)
  		data = (struct setup_data *)(unsigned long)data->next;
  
++<<<<<<< HEAD
 +	status = efi_call_phys5(sys_table->boottime->locate_handle,
 +				EFI_LOCATE_BY_PROTOCOL, &pci_proto,
 +				NULL, &size, pci_handle);
++=======
+ 	nr_pci = size / sizeof(u32);
+ 	for (i = 0; i < nr_pci; i++) {
+ 		struct pci_setup_rom *rom = NULL;
+ 		u32 h = handles[i];
+ 
+ 		status = efi_early->call(efi_early->handle_protocol, h,
+ 					 &pci_proto, (void **)&pci);
+ 
+ 		if (status != EFI_SUCCESS)
+ 			continue;
+ 
+ 		if (!pci)
+ 			continue;
+ 
+ 		status = __setup_efi_pci32(pci, &rom);
+ 		if (status != EFI_SUCCESS)
+ 			continue;
+ 
+ 		if (data)
+ 			data->next = (unsigned long)rom;
+ 		else
+ 			params->hdr.setup_data = (unsigned long)rom;
+ 
+ 		data = (struct setup_data *)rom;
+ 
+ 	}
+ 
+ 	return status;
+ }
+ 
+ static efi_status_t
+ __setup_efi_pci64(efi_pci_io_protocol_64 *pci, struct pci_setup_rom **__rom)
+ {
+ 	struct pci_setup_rom *rom;
+ 	efi_status_t status;
+ 	unsigned long size;
+ 	uint64_t attributes;
+ 
+ 	status = efi_early->call(pci->attributes, pci,
+ 				 EfiPciIoAttributeOperationGet, 0,
+ 				 &attributes);
+ 	if (status != EFI_SUCCESS)
+ 		return status;
+ 
+ 	if (!pci->romimage || !pci->romsize)
+ 		return EFI_INVALID_PARAMETER;
+ 
+ 	size = pci->romsize + sizeof(*rom);
+ 
+ 	status = efi_early->call(efi_early->allocate_pool,
+ 				 EFI_LOADER_DATA, size, &rom);
+ 
+ 	if (status != EFI_SUCCESS)
+ 		return status;
+ 
+ 	rom->data.type = SETUP_PCI;
+ 	rom->data.len = size - sizeof(struct setup_data);
+ 	rom->data.next = 0;
+ 	rom->pcilen = pci->romsize;
+ 	*__rom = rom;
+ 
+ 	status = efi_early->call(pci->pci.read, pci, EfiPciIoWidthUint16,
+ 				 PCI_VENDOR_ID, 1, &(rom->vendor));
+ 
+ 	if (status != EFI_SUCCESS)
+ 		goto free_struct;
+ 
+ 	status = efi_early->call(pci->pci.read, pci, EfiPciIoWidthUint16,
+ 				 PCI_DEVICE_ID, 1, &(rom->devid));
+ 
+ 	if (status != EFI_SUCCESS)
+ 		goto free_struct;
+ 
+ 	status = efi_early->call(pci->get_location, pci, &(rom->segment),
+ 				 &(rom->bus), &(rom->device), &(rom->function));
+ 
+ 	if (status != EFI_SUCCESS)
+ 		goto free_struct;
+ 
+ 	memcpy(rom->romdata, pci->romimage, pci->romsize);
+ 	return status;
+ 
+ free_struct:
+ 	efi_early->call(efi_early->free_pool, rom);
+ 	return status;
+ 
+ }
+ 
+ static efi_status_t
+ setup_efi_pci64(struct boot_params *params, void **pci_handle,
+ 		unsigned long size)
+ {
+ 	efi_pci_io_protocol_64 *pci = NULL;
+ 	efi_guid_t pci_proto = EFI_PCI_IO_PROTOCOL_GUID;
+ 	u64 *handles = (u64 *)(unsigned long)pci_handle;
+ 	efi_status_t status;
+ 	unsigned long nr_pci;
+ 	struct setup_data *data;
+ 	int i;
+ 
+ 	data = (struct setup_data *)(unsigned long)params->hdr.setup_data;
+ 
+ 	while (data && data->next)
+ 		data = (struct setup_data *)(unsigned long)data->next;
+ 
+ 	nr_pci = size / sizeof(u64);
+ 	for (i = 0; i < nr_pci; i++) {
+ 		struct pci_setup_rom *rom = NULL;
+ 		u64 h = handles[i];
+ 
+ 		status = efi_early->call(efi_early->handle_protocol, h,
+ 					 &pci_proto, (void **)&pci);
+ 
+ 		if (status != EFI_SUCCESS)
+ 			continue;
+ 
+ 		if (!pci)
+ 			continue;
+ 
+ 		status = __setup_efi_pci64(pci, &rom);
+ 		if (status != EFI_SUCCESS)
+ 			continue;
+ 
+ 		if (data)
+ 			data->next = (unsigned long)rom;
+ 		else
+ 			params->hdr.setup_data = (unsigned long)rom;
+ 
+ 		data = (struct setup_data *)rom;
+ 
+ 	}
+ 
+ 	return status;
+ }
+ 
+ static efi_status_t setup_efi_pci(struct boot_params *params)
+ {
+ 	efi_status_t status;
+ 	void **pci_handle = NULL;
+ 	efi_guid_t pci_proto = EFI_PCI_IO_PROTOCOL_GUID;
+ 	unsigned long size = 0;
+ 
+ 	status = efi_early->call(efi_early->locate_handle,
+ 				 EFI_LOCATE_BY_PROTOCOL,
+ 				 &pci_proto, NULL, &size, pci_handle);
++>>>>>>> c116e8d60ada (x86/efi: Split the boot stub into 32/64 code paths)
  
  	if (status == EFI_BUFFER_TOO_SMALL) {
 -		status = efi_early->call(efi_early->allocate_pool,
 -					 EFI_LOADER_DATA,
 -					 size, (void **)&pci_handle);
 +		status = efi_call_phys3(sys_table->boottime->allocate_pool,
 +					EFI_LOADER_DATA, size, &pci_handle);
  
  		if (status != EFI_SUCCESS)
  			return status;
@@@ -82,178 -544,20 +559,186 @@@
  	if (status != EFI_SUCCESS)
  		goto free_handle;
  
++<<<<<<< HEAD
 +	nr_pci = size / sizeof(void *);
 +	for (i = 0; i < nr_pci; i++) {
 +		void *h = pci_handle[i];
 +		uint64_t attributes;
 +		struct pci_setup_rom *rom;
 +
 +		status = efi_call_phys3(sys_table->boottime->handle_protocol,
 +					h, &pci_proto, &pci);
 +
 +		if (status != EFI_SUCCESS)
 +			continue;
 +
 +		if (!pci)
 +			continue;
 +
 +#ifdef CONFIG_X86_64
 +		status = efi_call_phys4(pci->attributes, pci,
 +					EfiPciIoAttributeOperationGet, 0,
 +					&attributes);
 +#else
 +		status = efi_call_phys5(pci->attributes, pci,
 +					EfiPciIoAttributeOperationGet, 0, 0,
 +					&attributes);
 +#endif
 +		if (status != EFI_SUCCESS)
 +			continue;
 +
 +		if (!pci->romimage || !pci->romsize)
 +			continue;
 +
 +		size = pci->romsize + sizeof(*rom);
 +
 +		status = efi_call_phys3(sys_table->boottime->allocate_pool,
 +				EFI_LOADER_DATA, size, &rom);
 +
 +		if (status != EFI_SUCCESS)
 +			continue;
 +
 +		rom->data.type = SETUP_PCI;
 +		rom->data.len = size - sizeof(struct setup_data);
 +		rom->data.next = 0;
 +		rom->pcilen = pci->romsize;
 +
 +		status = efi_call_phys5(pci->pci.read, pci,
 +					EfiPciIoWidthUint16, PCI_VENDOR_ID,
 +					1, &(rom->vendor));
 +
 +		if (status != EFI_SUCCESS)
 +			goto free_struct;
 +
 +		status = efi_call_phys5(pci->pci.read, pci,
 +					EfiPciIoWidthUint16, PCI_DEVICE_ID,
 +					1, &(rom->devid));
 +
 +		if (status != EFI_SUCCESS)
 +			goto free_struct;
 +
 +		status = efi_call_phys5(pci->get_location, pci,
 +					&(rom->segment), &(rom->bus),
 +					&(rom->device), &(rom->function));
 +
 +		if (status != EFI_SUCCESS)
 +			goto free_struct;
 +
 +		memcpy(rom->romdata, pci->romimage, pci->romsize);
 +
 +		if (data)
 +			data->next = (unsigned long)rom;
 +		else
 +			params->hdr.setup_data = (unsigned long)rom;
 +
 +		data = (struct setup_data *)rom;
 +
 +		continue;
 +	free_struct:
 +		efi_call_phys1(sys_table->boottime->free_pool, rom);
 +	}
++=======
+ 	if (efi_early->is64)
+ 		status = setup_efi_pci64(params, pci_handle, size);
+ 	else
+ 		status = setup_efi_pci32(params, pci_handle, size);
++>>>>>>> c116e8d60ada (x86/efi: Split the boot stub into 32/64 code paths)
  
  free_handle:
 -	efi_early->call(efi_early->free_pool, pci_handle);
 +	efi_call_phys1(sys_table->boottime->free_pool, pci_handle);
  	return status;
  }
  
- /*
-  * See if we have Graphics Output Protocol
-  */
- static efi_status_t setup_gop(struct screen_info *si, efi_guid_t *proto,
- 			      unsigned long size)
+ static void
+ setup_pixel_info(struct screen_info *si, u32 pixels_per_scan_line,
+ 		 struct efi_pixel_bitmask pixel_info, int pixel_format)
  {
++<<<<<<< HEAD
 +	struct efi_graphics_output_protocol *gop, *first_gop;
 +	struct efi_pixel_bitmask pixel_info;
 +	unsigned long nr_gops;
 +	efi_status_t status;
 +	void **gop_handle;
 +	u16 width, height;
 +	u32 fb_base, fb_size;
 +	u32 pixels_per_scan_line;
 +	int pixel_format;
 +	int i;
 +
 +	status = efi_call_phys3(sys_table->boottime->allocate_pool,
 +				EFI_LOADER_DATA, size, &gop_handle);
 +	if (status != EFI_SUCCESS)
 +		return status;
 +
 +	status = efi_call_phys5(sys_table->boottime->locate_handle,
 +				EFI_LOCATE_BY_PROTOCOL, proto,
 +				NULL, &size, gop_handle);
 +	if (status != EFI_SUCCESS)
 +		goto free_handle;
 +
 +	first_gop = NULL;
 +
 +	nr_gops = size / sizeof(void *);
 +	for (i = 0; i < nr_gops; i++) {
 +		struct efi_graphics_output_mode_info *info;
 +		efi_guid_t conout_proto = EFI_CONSOLE_OUT_DEVICE_GUID;
 +		bool conout_found = false;
 +		void *dummy;
 +		void *h = gop_handle[i];
 +
 +		status = efi_call_phys3(sys_table->boottime->handle_protocol,
 +					h, proto, &gop);
 +		if (status != EFI_SUCCESS)
 +			continue;
 +
 +		status = efi_call_phys3(sys_table->boottime->handle_protocol,
 +					h, &conout_proto, &dummy);
 +
 +		if (status == EFI_SUCCESS)
 +			conout_found = true;
 +
 +		status = efi_call_phys4(gop->query_mode, gop,
 +					gop->mode->mode, &size, &info);
 +		if (status == EFI_SUCCESS && (!first_gop || conout_found)) {
 +			/*
 +			 * Systems that use the UEFI Console Splitter may
 +			 * provide multiple GOP devices, not all of which are
 +			 * backed by real hardware. The workaround is to search
 +			 * for a GOP implementing the ConOut protocol, and if
 +			 * one isn't found, to just fall back to the first GOP.
 +			 */
 +			width = info->horizontal_resolution;
 +			height = info->vertical_resolution;
 +			fb_base = gop->mode->frame_buffer_base;
 +			fb_size = gop->mode->frame_buffer_size;
 +			pixel_format = info->pixel_format;
 +			pixel_info = info->pixel_information;
 +			pixels_per_scan_line = info->pixels_per_scan_line;
 +
 +			/*
 +			 * Once we've found a GOP supporting ConOut,
 +			 * don't bother looking any further.
 +			 */
 +			first_gop = gop;
 +			if (conout_found)
 +				break;
 +		}
 +	}
 +
 +	/* Did we find any GOPs? */
 +	if (!first_gop)
 +		goto free_handle;
 +
 +	/* EFI framebuffer */
 +	si->orig_video_isVGA = VIDEO_TYPE_EFI;
 +
 +	si->lfb_width = width;
 +	si->lfb_height = height;
 +	si->lfb_base = fb_base;
 +	si->pages = 1;
 +
++=======
++>>>>>>> c116e8d60ada (x86/efi: Split the boot stub into 32/64 code paths)
  	if (pixel_format == PIXEL_RGB_RESERVED_8BIT_PER_COLOR) {
  		si->lfb_depth = 32;
  		si->lfb_linelength = pixels_per_scan_line * 4;
@@@ -309,51 -811,66 +992,85 @@@ out
  }
  
  /*
-  * See if we have Universal Graphics Adapter (UGA) protocol
+  * See if we have Graphics Output Protocol
   */
- static efi_status_t setup_uga(struct screen_info *si, efi_guid_t *uga_proto,
+ static efi_status_t setup_gop(struct screen_info *si, efi_guid_t *proto,
  			      unsigned long size)
  {
- 	struct efi_uga_draw_protocol *uga, *first_uga;
+ 	efi_status_t status;
+ 	void **gop_handle = NULL;
+ 
+ 	status = efi_early->call(efi_early->allocate_pool, EFI_LOADER_DATA,
+ 				 size, (void **)&gop_handle);
+ 	if (status != EFI_SUCCESS)
+ 		return status;
+ 
+ 	status = efi_early->call(efi_early->locate_handle,
+ 				 EFI_LOCATE_BY_PROTOCOL,
+ 				 proto, NULL, &size, gop_handle);
+ 	if (status != EFI_SUCCESS)
+ 		goto free_handle;
+ 
+ 	if (efi_early->is64)
+ 		status = setup_gop64(si, proto, size, gop_handle);
+ 	else
+ 		status = setup_gop32(si, proto, size, gop_handle);
+ 
+ free_handle:
 -	efi_early->call(efi_early->free_pool, gop_handle);
++	efi_call_phys1(sys_table->boottime->free_pool, gop_handle);
+ 	return status;
+ }
+ 
+ static efi_status_t
+ setup_uga32(void **uga_handle, unsigned long size, u32 *width, u32 *height)
+ {
+ 	struct efi_uga_draw_protocol *uga = NULL, *first_uga;
+ 	efi_guid_t uga_proto = EFI_UGA_PROTOCOL_GUID;
  	unsigned long nr_ugas;
+ 	u32 *handles = (u32 *)uga_handle;;
  	efi_status_t status;
- 	u32 width, height;
- 	void **uga_handle = NULL;
  	int i;
  
++<<<<<<< HEAD
 +	status = efi_call_phys3(sys_table->boottime->allocate_pool,
 +				EFI_LOADER_DATA, size, &uga_handle);
 +	if (status != EFI_SUCCESS)
 +		return status;
 +
 +	status = efi_call_phys5(sys_table->boottime->locate_handle,
 +				EFI_LOCATE_BY_PROTOCOL, uga_proto,
 +				NULL, &size, uga_handle);
 +	if (status != EFI_SUCCESS)
 +		goto free_handle;
 +
++=======
++>>>>>>> c116e8d60ada (x86/efi: Split the boot stub into 32/64 code paths)
  	first_uga = NULL;
- 
- 	nr_ugas = size / sizeof(void *);
+ 	nr_ugas = size / sizeof(u32);
  	for (i = 0; i < nr_ugas; i++) {
  		efi_guid_t pciio_proto = EFI_PCI_IO_PROTOCOL_GUID;
- 		void *handle = uga_handle[i];
  		u32 w, h, depth, refresh;
  		void *pciio;
+ 		u32 handle = handles[i];
  
++<<<<<<< HEAD
 +		status = efi_call_phys3(sys_table->boottime->handle_protocol,
 +					handle, uga_proto, &uga);
++=======
+ 		status = efi_early->call(efi_early->handle_protocol, handle,
+ 					 &uga_proto, (void **)&uga);
++>>>>>>> c116e8d60ada (x86/efi: Split the boot stub into 32/64 code paths)
  		if (status != EFI_SUCCESS)
  			continue;
  
 -		efi_early->call(efi_early->handle_protocol, handle,
 -				&pciio_proto, &pciio);
 +		efi_call_phys3(sys_table->boottime->handle_protocol,
 +			       handle, &pciio_proto, &pciio);
  
 -		status = efi_early->call((unsigned long)uga->get_mode, uga,
 -					 &w, &h, &depth, &refresh);
 +		status = efi_call_phys5(uga->get_mode, uga, &w, &h,
 +					&depth, &refresh);
  		if (status == EFI_SUCCESS && (!first_uga || pciio)) {
- 			width = w;
- 			height = h;
+ 			*width = w;
+ 			*height = h;
  
  			/*
  			 * Once we've found a UGA supporting PCIIO,
@@@ -385,9 -980,8 +1180,8 @@@ static efi_status_t setup_uga(struct sc
  	si->rsvd_size = 8;
  	si->rsvd_pos = 24;
  
- 
  free_handle:
 -	efi_early->call(efi_early->free_pool, uga_handle);
 +	efi_call_phys1(sys_table->boottime->free_pool, uga_handle);
  	return status;
  }
  
* Unmerged path arch/x86/boot/compressed/eboot.c
