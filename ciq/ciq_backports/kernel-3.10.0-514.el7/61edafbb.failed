netfilter: nf_tables: consolide set element destruction

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Patrick McHardy <kaber@trash.net>
commit 61edafbb47e9f46fb850035b1f8f062564445704
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/61edafbb.failed

With the conversion to set extensions, it is now possible to consolidate
the different set element destruction functions.

The set implementations' ->remove() functions are changed to only take
the element out of their internal data structures. Elements will be freed
in a batched fashion after the global transaction's completion RCU grace
period.

This reduces the amount of grace periods required for nft_hash from N
to zero additional ones, additionally this guarantees that the set
elements' extensions of all implementations can be used under RCU
protection.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 61edafbb47e9f46fb850035b1f8f062564445704)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables.h
#	net/netfilter/nf_tables_api.c
#	net/netfilter/nft_hash.c
#	net/netfilter/nft_rbtree.c
diff --cc include/net/netfilter/nf_tables.h
index b84b4f62eade,6ac63323afd2..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -416,6 -417,14 +416,17 @@@ static inline u8 *nft_set_ext_flags(con
  	return nft_set_ext(ext, NFT_SET_EXT_FLAGS);
  }
  
++<<<<<<< HEAD
++=======
+ static inline struct nft_set_ext *nft_set_elem_ext(const struct nft_set *set,
+ 						   void *elem)
+ {
+ 	return elem + set->ops->elemsize;
+ }
+ 
+ void nft_set_elem_destroy(const struct nft_set *set, void *elem);
+ 
++>>>>>>> 61edafbb47e9 (netfilter: nf_tables: consolide set element destruction)
  /**
   *	struct nft_expr_type - nf_tables expression type
   *
diff --cc net/netfilter/nf_tables_api.c
index 08f3e1550f56,b35512f1934c..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -3125,6 -3132,41 +3125,44 @@@ static struct nft_trans *nft_trans_elem
  	return trans;
  }
  
++<<<<<<< HEAD
++=======
+ static void *nft_set_elem_init(const struct nft_set *set,
+ 			       const struct nft_set_ext_tmpl *tmpl,
+ 			       const struct nft_data *key,
+ 			       const struct nft_data *data,
+ 			       gfp_t gfp)
+ {
+ 	struct nft_set_ext *ext;
+ 	void *elem;
+ 
+ 	elem = kzalloc(set->ops->elemsize + tmpl->len, gfp);
+ 	if (elem == NULL)
+ 		return NULL;
+ 
+ 	ext = nft_set_elem_ext(set, elem);
+ 	nft_set_ext_init(ext, tmpl);
+ 
+ 	memcpy(nft_set_ext_key(ext), key, set->klen);
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
+ 		memcpy(nft_set_ext_data(ext), data, set->dlen);
+ 
+ 	return elem;
+ }
+ 
+ void nft_set_elem_destroy(const struct nft_set *set, void *elem)
+ {
+ 	struct nft_set_ext *ext = nft_set_elem_ext(set, elem);
+ 
+ 	nft_data_uninit(nft_set_ext_key(ext), NFT_DATA_VALUE);
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
+ 		nft_data_uninit(nft_set_ext_data(ext), set->dtype);
+ 
+ 	kfree(elem);
+ }
+ EXPORT_SYMBOL_GPL(nft_set_elem_destroy);
+ 
++>>>>>>> 61edafbb47e9 (netfilter: nf_tables: consolide set element destruction)
  static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,
  			    const struct nlattr *attr)
  {
@@@ -3635,16 -3705,12 +3677,22 @@@ static int nf_tables_commit(struct sk_b
  			break;
  		case NFT_MSG_DELSETELEM:
  			te = (struct nft_trans_elem *)trans->data;
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> 61edafbb47e9 (netfilter: nf_tables: consolide set element destruction)
  			nf_tables_setelem_notify(&trans->ctx, te->set,
  						 &te->elem,
  						 NFT_MSG_DELSETELEM, 0);
  			te->set->ops->get(te->set, &te->elem);
++<<<<<<< HEAD
 +			nft_data_uninit(&te->elem.key, NFT_DATA_VALUE);
 +			if (te->set->flags & NFT_SET_MAP &&
 +			    !(te->elem.flags & NFT_SET_ELEM_INTERVAL_END))
 +				nft_data_uninit(&te->elem.data, te->set->dtype);
++=======
++>>>>>>> 61edafbb47e9 (netfilter: nf_tables: consolide set element destruction)
  			te->set->ops->remove(te->set, &te->elem);
- 			nft_trans_destroy(trans);
  			break;
  		}
  	}
@@@ -3747,13 -3816,9 +3799,17 @@@ static int nf_tables_abort(struct sk_bu
  		case NFT_MSG_NEWSETELEM:
  			nft_trans_elem_set(trans)->nelems--;
  			te = (struct nft_trans_elem *)trans->data;
++<<<<<<< HEAD
 +			te->set->ops->get(te->set, &te->elem);
 +			nft_data_uninit(&te->elem.key, NFT_DATA_VALUE);
 +			if (te->set->flags & NFT_SET_MAP &&
 +			    !(te->elem.flags & NFT_SET_ELEM_INTERVAL_END))
 +				nft_data_uninit(&te->elem.data, te->set->dtype);
++=======
+ 
+ 			te->set->ops->get(te->set, &te->elem);
++>>>>>>> 61edafbb47e9 (netfilter: nf_tables: consolide set element destruction)
  			te->set->ops->remove(te->set, &te->elem);
- 			nft_trans_destroy(trans);
  			break;
  		case NFT_MSG_DELSETELEM:
  			nft_trans_elem_set(trans)->nelems++;
diff --cc net/netfilter/nft_hash.c
index f14a5e14123a,94bf25def37f..000000000000
--- a/net/netfilter/nft_hash.c
+++ b/net/netfilter/nft_hash.c
@@@ -46,69 -85,23 +46,76 @@@ static bool nft_hash_lookup(const struc
  static int nft_hash_insert(const struct nft_set *set,
  			   const struct nft_set_elem *elem)
  {
 -	struct nft_hash *priv = nft_set_priv(set);
 -	struct nft_hash_elem *he = elem->priv;
 -	struct nft_hash_cmp_arg arg = {
 -		.set	 = set,
 -		.key	 = &elem->key,
 -	};
 +	struct rhashtable *priv = nft_set_priv(set);
 +	struct nft_hash_elem *he;
 +	unsigned int size;
 +
 +	if (elem->flags != 0)
 +		return -EINVAL;
 +
 +	size = sizeof(*he);
 +	if (set->flags & NFT_SET_MAP)
 +		size += sizeof(he->data[0]);
  
 -	return rhashtable_lookup_insert_key(&priv->ht, &arg, &he->node,
 -					    nft_hash_params);
 +	he = kzalloc(size, GFP_KERNEL);
 +	if (he == NULL)
 +		return -ENOMEM;
 +
 +	nft_data_copy(&he->key, &elem->key);
 +	if (set->flags & NFT_SET_MAP)
 +		nft_data_copy(he->data, &elem->data);
 +
 +	rhashtable_insert(priv, &he->node);
 +
 +	return 0;
 +}
 +
++<<<<<<< HEAD
 +static void nft_hash_elem_destroy(const struct nft_set *set,
 +				  struct nft_hash_elem *he)
 +{
 +	nft_data_uninit(&he->key, NFT_DATA_VALUE);
 +	if (set->flags & NFT_SET_MAP)
 +		nft_data_uninit(he->data, set->dtype);
 +	kfree(he);
  }
  
++=======
++>>>>>>> 61edafbb47e9 (netfilter: nf_tables: consolide set element destruction)
  static void nft_hash_remove(const struct nft_set *set,
  			    const struct nft_set_elem *elem)
  {
 -	struct nft_hash *priv = nft_set_priv(set);
 +	struct rhashtable *priv = nft_set_priv(set);
  
++<<<<<<< HEAD
 +	rhashtable_remove(priv, elem->cookie);
 +	synchronize_rcu();
 +	kfree(elem->cookie);
++=======
+ 	rhashtable_remove_fast(&priv->ht, elem->cookie, nft_hash_params);
++>>>>>>> 61edafbb47e9 (netfilter: nf_tables: consolide set element destruction)
 +}
 +
 +struct nft_compare_arg {
 +	const struct nft_set *set;
 +	struct nft_set_elem *elem;
 +};
 +
 +static bool nft_hash_compare(void *ptr, void *arg)
 +{
 +	struct nft_hash_elem *he = ptr;
 +	struct nft_compare_arg *x = arg;
 +
 +	if (!nft_data_cmp(&he->key, &x->elem->key, x->set->klen)) {
 +		x->elem->cookie = he;
 +		x->elem->flags = 0;
 +		if (x->set->flags & NFT_SET_MAP)
 +			nft_data_copy(&x->elem->data, he->data);
 +
 +		return true;
 +	}
 +
 +	return false;
  }
  
  static int nft_hash_get(const struct nft_set *set, struct nft_set_elem *elem)
@@@ -171,34 -188,26 +178,51 @@@ static int nft_hash_init(const struct n
  			 const struct nft_set_desc *desc,
  			 const struct nlattr * const tb[])
  {
 -	struct nft_hash *priv = nft_set_priv(set);
 -	struct rhashtable_params params = nft_hash_params;
 +	struct rhashtable *priv = nft_set_priv(set);
 +	struct rhashtable_params params = {
 +		.nelem_hint = desc->size ? : NFT_HASH_ELEMENT_HINT,
 +		.head_offset = offsetof(struct nft_hash_elem, node),
 +		.key_offset = offsetof(struct nft_hash_elem, key),
 +		.key_len = set->klen,
 +		.hashfn = jhash,
 +		.grow_decision = rht_grow_above_75,
 +		.shrink_decision = rht_shrink_below_30,
 +		.mutex_is_held = lockdep_nfnl_lock_is_held,
 +	};
  
++<<<<<<< HEAD
 +	return rhashtable_init(priv, &params);
++=======
+ 	params.nelem_hint = desc->size ?: NFT_HASH_ELEMENT_HINT;
+ 	params.key_len	  = set->klen;
+ 
+ 	return rhashtable_init(&priv->ht, &params);
+ }
+ 
+ static void nft_hash_elem_destroy(void *ptr, void *arg)
+ {
+ 	nft_set_elem_destroy((const struct nft_set *)arg, ptr);
++>>>>>>> 61edafbb47e9 (netfilter: nf_tables: consolide set element destruction)
  }
  
  static void nft_hash_destroy(const struct nft_set *set)
  {
 -	struct nft_hash *priv = nft_set_priv(set);
 +	const struct rhashtable *priv = nft_set_priv(set);
 +	const struct bucket_table *tbl = priv->tbl;
 +	struct nft_hash_elem *he;
 +	struct rhash_head *pos, *next;
 +	unsigned int i;
  
++<<<<<<< HEAD
 +	for (i = 0; i < tbl->size; i++) {
 +		rht_for_each_entry_safe(he, pos, next, tbl, i, node)
 +			nft_hash_elem_destroy(set, he);
 +	}
 +	rhashtable_destroy(priv);
++=======
+ 	rhashtable_free_and_destroy(&priv->ht, nft_hash_elem_destroy,
+ 				    (void *)set);
++>>>>>>> 61edafbb47e9 (netfilter: nf_tables: consolide set element destruction)
  }
  
  static bool nft_hash_estimate(const struct nft_set_desc *desc, u32 features,
diff --cc net/netfilter/nft_rbtree.c
index 2c75361077f7,332c6afc77e9..000000000000
--- a/net/netfilter/nft_rbtree.c
+++ b/net/netfilter/nft_rbtree.c
@@@ -72,17 -72,6 +72,20 @@@ out
  	return false;
  }
  
++<<<<<<< HEAD
 +static void nft_rbtree_elem_destroy(const struct nft_set *set,
 +				    struct nft_rbtree_elem *rbe)
 +{
 +	nft_data_uninit(&rbe->key, NFT_DATA_VALUE);
 +	if (set->flags & NFT_SET_MAP &&
 +	    !(rbe->flags & NFT_SET_ELEM_INTERVAL_END))
 +		nft_data_uninit(rbe->data, set->dtype);
 +
 +	kfree(rbe);
 +}
 +
++=======
++>>>>>>> 61edafbb47e9 (netfilter: nf_tables: consolide set element destruction)
  static int __nft_rbtree_insert(const struct nft_set *set,
  			       struct nft_rbtree_elem *new)
  {
* Unmerged path include/net/netfilter/nf_tables.h
* Unmerged path net/netfilter/nf_tables_api.c
* Unmerged path net/netfilter/nft_hash.c
* Unmerged path net/netfilter/nft_rbtree.c
