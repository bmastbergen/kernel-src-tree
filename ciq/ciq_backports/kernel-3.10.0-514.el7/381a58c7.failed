mei: me: use io register wrappers consistently

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 381a58c70985ca1256b0f51aa6694f79662bb166
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/381a58c7.failed

1. Use mei_device structure as the first argument to the io
register access wrappers so we'll have access to the device
structure needed for tracing.

2. Use wrapper consistently

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 381a58c70985ca1256b0f51aa6694f79662bb166)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/hw-me.c
diff --cc drivers/misc/mei/hw-me.c
index 1707fa5ea02a,ac82b56ccbb5..000000000000
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@@ -59,9 -59,9 +59,9 @@@ static inline void mei_me_reg_write(con
   *
   * @dev: the device structure
   *
 - * Return: ME_CB_RW register value (u32)
 + * returns ME_CB_RW register value (u32)
   */
- static u32 mei_me_mecbrw_read(const struct mei_device *dev)
+ static inline u32 mei_me_mecbrw_read(const struct mei_device *dev)
  {
  	return mei_me_reg_read(to_me_hw(dev), ME_CB_RW);
  }
@@@ -70,11 -82,11 +82,11 @@@ static inline void mei_me_hcbww_write(s
   *
   * @dev: the device structure
   *
 - * Return: ME_CSR_HA register value (u32)
 + * returns ME_CSR_HA register value (u32)
   */
- static inline u32 mei_me_mecsr_read(const struct mei_me_hw *hw)
+ static inline u32 mei_me_mecsr_read(const struct mei_device *dev)
  {
- 	return mei_me_reg_read(hw, ME_CSR_HA);
+ 	return mei_me_reg_read(to_me_hw(dev), ME_CSR_HA);
  }
  
  /**
@@@ -82,11 -94,22 +94,22 @@@
   *
   * @dev: the device structure
   *
 - * Return: H_CSR register value (u32)
 + * returns H_CSR register value (u32)
   */
- static inline u32 mei_hcsr_read(const struct mei_me_hw *hw)
+ static inline u32 mei_hcsr_read(const struct mei_device *dev)
+ {
+ 	return mei_me_reg_read(to_me_hw(dev), H_CSR);
+ }
+ 
+ /**
+  * mei_hcsr_write - writes H_CSR register to the mei device
+  *
+  * @dev: the device structure
+  * @reg: new register value
+  */
+ static inline void mei_hcsr_write(struct mei_device *dev, u32 reg)
  {
- 	return mei_me_reg_read(hw, H_CSR);
+ 	mei_me_reg_write(to_me_hw(dev), H_CSR, reg);
  }
  
  /**
@@@ -94,13 -117,44 +117,17 @@@
   * and ignores the H_IS bit for it is write-one-to-zero.
   *
   * @dev: the device structure
++<<<<<<< HEAD
++=======
+  * @reg: new register value
++>>>>>>> 381a58c70985 (mei: me: use io register wrappers consistently)
   */
- static inline void mei_hcsr_set(struct mei_me_hw *hw, u32 hcsr)
+ static inline void mei_hcsr_set(struct mei_device *dev, u32 reg)
  {
- 	hcsr &= ~H_IS;
- 	mei_me_reg_write(hw, H_CSR, hcsr);
+ 	reg &= ~H_IS;
+ 	mei_hcsr_write(dev, reg);
  }
  
 -/**
 - * mei_me_fw_status - read fw status register from pci config space
 - *
 - * @dev: mei device
 - * @fw_status: fw status register values
 - *
 - * Return: 0 on success, error otherwise
 - */
 -static int mei_me_fw_status(struct mei_device *dev,
 -			    struct mei_fw_status *fw_status)
 -{
 -	struct pci_dev *pdev = to_pci_dev(dev->dev);
 -	struct mei_me_hw *hw = to_me_hw(dev);
 -	const struct mei_fw_status *fw_src = &hw->cfg->fw_status;
 -	int ret;
 -	int i;
 -
 -	if (!fw_status)
 -		return -EINVAL;
 -
 -	fw_status->count = fw_src->count;
 -	for (i = 0; i < fw_src->count && i < MEI_FW_STATUS_MAX; i++) {
 -		ret = pci_read_config_dword(pdev,
 -			fw_src->status[i], &fw_status->status[i]);
 -		if (ret)
 -			return ret;
 -	}
 -
 -	return 0;
 -}
  
  /**
   * mei_me_hw_config - configure hw dependent settings
@@@ -137,10 -193,10 +164,15 @@@ static inline enum mei_pg_state mei_me_
   */
  static void mei_me_intr_clear(struct mei_device *dev)
  {
++<<<<<<< HEAD
 +	struct mei_me_hw *hw = to_me_hw(dev);
 +	u32 hcsr = mei_hcsr_read(hw);
++=======
+ 	u32 hcsr = mei_hcsr_read(dev);
+ 
++>>>>>>> 381a58c70985 (mei: me: use io register wrappers consistently)
  	if ((hcsr & H_IS) == H_IS)
- 		mei_me_reg_write(hw, H_CSR, hcsr);
+ 		mei_hcsr_write(dev, hcsr);
  }
  /**
   * mei_me_intr_enable - enables mei device interrupts
@@@ -149,10 -205,10 +181,15 @@@
   */
  static void mei_me_intr_enable(struct mei_device *dev)
  {
++<<<<<<< HEAD
 +	struct mei_me_hw *hw = to_me_hw(dev);
 +	u32 hcsr = mei_hcsr_read(hw);
++=======
+ 	u32 hcsr = mei_hcsr_read(dev);
+ 
++>>>>>>> 381a58c70985 (mei: me: use io register wrappers consistently)
  	hcsr |= H_IE;
- 	mei_hcsr_set(hw, hcsr);
+ 	mei_hcsr_set(dev, hcsr);
  }
  
  /**
@@@ -162,10 -218,10 +199,15 @@@
   */
  static void mei_me_intr_disable(struct mei_device *dev)
  {
++<<<<<<< HEAD
 +	struct mei_me_hw *hw = to_me_hw(dev);
 +	u32 hcsr = mei_hcsr_read(hw);
++=======
+ 	u32 hcsr = mei_hcsr_read(dev);
+ 
++>>>>>>> 381a58c70985 (mei: me: use io register wrappers consistently)
  	hcsr  &= ~H_IE;
- 	mei_hcsr_set(hw, hcsr);
+ 	mei_hcsr_set(dev, hcsr);
  }
  
  /**
@@@ -222,13 -278,13 +262,13 @@@ static int mei_me_hw_reset(struct mei_d
  	 * Host reads the H_CSR once to ensure that the
  	 * posted write to H_CSR completes.
  	 */
- 	hcsr = mei_hcsr_read(hw);
+ 	hcsr = mei_hcsr_read(dev);
  
  	if ((hcsr & H_RST) == 0)
 -		dev_warn(dev->dev, "H_RST is not set = 0x%08X", hcsr);
 +		dev_warn(&dev->pdev->dev, "H_RST is not set = 0x%08X", hcsr);
  
  	if ((hcsr & H_RDY) == H_RDY)
 -		dev_warn(dev->dev, "H_RDY is not cleared 0x%08X", hcsr);
 +		dev_warn(&dev->pdev->dev, "H_RDY is not cleared 0x%08X", hcsr);
  
  	if (intr_enable == false)
  		mei_me_hw_reset_release(dev);
@@@ -239,17 -295,16 +279,24 @@@
  /**
   * mei_me_host_set_ready - enable device
   *
 - * @dev: mei device
 + * @dev - mei device
 + * returns bool
   */
 +
  static void mei_me_host_set_ready(struct mei_device *dev)
  {
++<<<<<<< HEAD
 +	struct mei_me_hw *hw = to_me_hw(dev);
 +	hw->host_hw_state = mei_hcsr_read(hw);
 +	hw->host_hw_state |= H_IE | H_IG | H_RDY;
 +	mei_hcsr_set(hw, hw->host_hw_state);
++=======
+ 	u32 hcsr = mei_hcsr_read(dev);
+ 
+ 	hcsr |= H_IE | H_IG | H_RDY;
+ 	mei_hcsr_set(dev, hcsr);
++>>>>>>> 381a58c70985 (mei: me: use io register wrappers consistently)
  }
 -
  /**
   * mei_me_host_is_ready - check whether the host has turned ready
   *
@@@ -258,9 -313,9 +305,15 @@@
   */
  static bool mei_me_host_is_ready(struct mei_device *dev)
  {
++<<<<<<< HEAD
 +	struct mei_me_hw *hw = to_me_hw(dev);
 +	hw->host_hw_state = mei_hcsr_read(hw);
 +	return (hw->host_hw_state & H_RDY) == H_RDY;
++=======
+ 	u32 hcsr = mei_hcsr_read(dev);
+ 
+ 	return (hcsr & H_RDY) == H_RDY;
++>>>>>>> 381a58c70985 (mei: me: use io register wrappers consistently)
  }
  
  /**
@@@ -271,11 -326,18 +324,17 @@@
   */
  static bool mei_me_hw_is_ready(struct mei_device *dev)
  {
++<<<<<<< HEAD
 +	struct mei_me_hw *hw = to_me_hw(dev);
 +	hw->me_hw_state = mei_me_mecsr_read(hw);
 +	return (hw->me_hw_state & ME_RDY_HRA) == ME_RDY_HRA;
++=======
+ 	u32 mecsr = mei_me_mecsr_read(dev);
+ 
+ 	return (mecsr & ME_RDY_HRA) == ME_RDY_HRA;
++>>>>>>> 381a58c70985 (mei: me: use io register wrappers consistently)
  }
  
 -/**
 - * mei_me_hw_ready_wait - wait until the me(hw) has turned ready
 - *  or timeout is reached
 - *
 - * @dev: mei device
 - * Return: 0 on success, error otherwise
 - */
  static int mei_me_hw_ready_wait(struct mei_device *dev)
  {
  	mutex_unlock(&dev->device_lock);
@@@ -313,13 -383,13 +372,20 @@@ static int mei_me_hw_start(struct mei_d
   */
  static unsigned char mei_hbuf_filled_slots(struct mei_device *dev)
  {
++<<<<<<< HEAD
 +	struct mei_me_hw *hw = to_me_hw(dev);
 +	char read_ptr, write_ptr;
 +
 +	hw->host_hw_state = mei_hcsr_read(hw);
++=======
+ 	u32 hcsr;
+ 	char read_ptr, write_ptr;
+ 
+ 	hcsr = mei_hcsr_read(dev);
++>>>>>>> 381a58c70985 (mei: me: use io register wrappers consistently)
  
 -	read_ptr = (char) ((hcsr & H_CBRP) >> 8);
 -	write_ptr = (char) ((hcsr & H_CBWP) >> 16);
 +	read_ptr = (char) ((hw->host_hw_state & H_CBRP) >> 8);
 +	write_ptr = (char) ((hw->host_hw_state & H_CBWP) >> 16);
  
  	return (unsigned char) (write_ptr - read_ptr);
  }
@@@ -402,12 -478,13 +467,12 @@@ static int mei_me_write_message(struct 
  	rem = length & 0x3;
  	if (rem > 0) {
  		u32 reg = 0;
 -
  		memcpy(&reg, &buf[length - rem], rem);
- 		mei_me_reg_write(hw, H_CB_WW, reg);
+ 		mei_me_hcbww_write(dev, reg);
  	}
  
- 	hcsr = mei_hcsr_read(hw) | H_IG;
- 	mei_hcsr_set(hw, hcsr);
+ 	hcsr = mei_hcsr_read(dev) | H_IG;
+ 	mei_hcsr_set(dev, hcsr);
  	if (!mei_me_hw_is_ready(dev))
  		return -EIO;
  
@@@ -423,14 -500,14 +488,25 @@@
   */
  static int mei_me_count_full_read_slots(struct mei_device *dev)
  {
++<<<<<<< HEAD
 +	struct mei_me_hw *hw = to_me_hw(dev);
 +	char read_ptr, write_ptr;
 +	unsigned char buffer_depth, filled_slots;
 +
 +	hw->me_hw_state = mei_me_mecsr_read(hw);
 +	buffer_depth = (unsigned char)((hw->me_hw_state & ME_CBD_HRA) >> 24);
 +	read_ptr = (char) ((hw->me_hw_state & ME_CBRP_HRA) >> 8);
 +	write_ptr = (char) ((hw->me_hw_state & ME_CBWP_HRA) >> 16);
++=======
+ 	u32 me_csr;
+ 	char read_ptr, write_ptr;
+ 	unsigned char buffer_depth, filled_slots;
+ 
+ 	me_csr = mei_me_mecsr_read(dev);
+ 	buffer_depth = (unsigned char)((me_csr & ME_CBD_HRA) >> 24);
+ 	read_ptr = (char) ((me_csr & ME_CBRP_HRA) >> 8);
+ 	write_ptr = (char) ((me_csr & ME_CBWP_HRA) >> 16);
++>>>>>>> 381a58c70985 (mei: me: use io register wrappers consistently)
  	filled_slots = (unsigned char) (write_ptr - read_ptr);
  
  	/* check for overflow */
* Unmerged path drivers/misc/mei/hw-me.c
