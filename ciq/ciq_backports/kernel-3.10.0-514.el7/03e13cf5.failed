clockevents: Implement unbind functionality

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 03e13cf5ee60584fe0c831682c67212effb7fca4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/03e13cf5.failed

Provide a sysfs interface to allow unbinding of clockevent
devices. The device is unbound if it is unused or if there is a
replacement device available. Unbinding of broadcast devices is not
supported as we don't want to foster that nonsense. If no replacement
device is available the unbind returns -EBUSY. Unbind is available
from the kernel and through sysfs, which is necessary to drop the
module refcount.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: John Stultz <john.stultz@linaro.org>
	Cc: Magnus Damm <magnus.damm@gmail.com>
Link: http://lkml.kernel.org/r/20130425143436.499216659@linutronix.de
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 03e13cf5ee60584fe0c831682c67212effb7fca4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/clocksource.c
#	kernel/time/tick-common.c
#	kernel/time/tick-internal.h
diff --cc kernel/time/clocksource.c
index 9f88a1c9b783,6d05b00410cc..000000000000
--- a/kernel/time/clocksource.c
+++ b/kernel/time/clocksource.c
@@@ -31,7 -31,83 +31,87 @@@
  #include <linux/tick.h>
  #include <linux/kthread.h>
  
++<<<<<<< HEAD
 +#include "timekeeping_internal.h"
++=======
+ #include "tick-internal.h"
+ 
+ void timecounter_init(struct timecounter *tc,
+ 		      const struct cyclecounter *cc,
+ 		      u64 start_tstamp)
+ {
+ 	tc->cc = cc;
+ 	tc->cycle_last = cc->read(cc);
+ 	tc->nsec = start_tstamp;
+ }
+ EXPORT_SYMBOL_GPL(timecounter_init);
+ 
+ /**
+  * timecounter_read_delta - get nanoseconds since last call of this function
+  * @tc:         Pointer to time counter
+  *
+  * When the underlying cycle counter runs over, this will be handled
+  * correctly as long as it does not run over more than once between
+  * calls.
+  *
+  * The first call to this function for a new time counter initializes
+  * the time tracking and returns an undefined result.
+  */
+ static u64 timecounter_read_delta(struct timecounter *tc)
+ {
+ 	cycle_t cycle_now, cycle_delta;
+ 	u64 ns_offset;
+ 
+ 	/* read cycle counter: */
+ 	cycle_now = tc->cc->read(tc->cc);
+ 
+ 	/* calculate the delta since the last timecounter_read_delta(): */
+ 	cycle_delta = (cycle_now - tc->cycle_last) & tc->cc->mask;
+ 
+ 	/* convert to nanoseconds: */
+ 	ns_offset = cyclecounter_cyc2ns(tc->cc, cycle_delta);
+ 
+ 	/* update time stamp of timecounter_read_delta() call: */
+ 	tc->cycle_last = cycle_now;
+ 
+ 	return ns_offset;
+ }
+ 
+ u64 timecounter_read(struct timecounter *tc)
+ {
+ 	u64 nsec;
+ 
+ 	/* increment time by nanoseconds since last call */
+ 	nsec = timecounter_read_delta(tc);
+ 	nsec += tc->nsec;
+ 	tc->nsec = nsec;
+ 
+ 	return nsec;
+ }
+ EXPORT_SYMBOL_GPL(timecounter_read);
+ 
+ u64 timecounter_cyc2time(struct timecounter *tc,
+ 			 cycle_t cycle_tstamp)
+ {
+ 	u64 cycle_delta = (cycle_tstamp - tc->cycle_last) & tc->cc->mask;
+ 	u64 nsec;
+ 
+ 	/*
+ 	 * Instead of always treating cycle_tstamp as more recent
+ 	 * than tc->cycle_last, detect when it is too far in the
+ 	 * future and treat it as old time stamp instead.
+ 	 */
+ 	if (cycle_delta > tc->cc->mask / 2) {
+ 		cycle_delta = (tc->cycle_last - cycle_tstamp) & tc->cc->mask;
+ 		nsec = tc->nsec - cyclecounter_cyc2ns(tc->cc, cycle_delta);
+ 	} else {
+ 		nsec = cyclecounter_cyc2ns(tc->cc, cycle_delta) + tc->nsec;
+ 	}
+ 
+ 	return nsec;
+ }
+ EXPORT_SYMBOL_GPL(timecounter_cyc2time);
++>>>>>>> 03e13cf5ee60 (clockevents: Implement unbind functionality)
  
  /**
   * clocks_calc_mult_shift - calculate mult/shift factors for scaled math of clocks
diff --cc kernel/time/tick-common.c
index b2f41b05d9e4,5edfb4806032..000000000000
--- a/kernel/time/tick-common.c
+++ b/kernel/time/tick-common.c
@@@ -255,7 -248,21 +266,25 @@@ static bool tick_check_preferred(struc
  }
  
  /*
++<<<<<<< HEAD
 + * Check, if the new registered device should be used.
++=======
+  * Check whether the new device is a better fit than curdev. curdev
+  * can be NULL !
+  */
+ bool tick_check_replacement(struct clock_event_device *curdev,
+ 			    struct clock_event_device *newdev)
+ {
+ 	if (tick_check_percpu(curdev, newdev, smp_processor_id()))
+ 		return false;
+ 
+ 	return tick_check_preferred(curdev, newdev);
+ }
+ 
+ /*
+  * Check, if the new registered device should be used. Called with
+  * clockevents_lock held and interrupts disabled.
++>>>>>>> 03e13cf5ee60 (clockevents: Implement unbind functionality)
   */
  void tick_check_new_device(struct clock_event_device *newdev)
  {
diff --cc kernel/time/tick-internal.h
index 4b574148f4f0,be1690eaecff..000000000000
--- a/kernel/time/tick-internal.h
+++ b/kernel/time/tick-internal.h
@@@ -18,8 -20,14 +20,18 @@@ extern int tick_do_timer_cpu __read_mos
  
  extern void tick_setup_periodic(struct clock_event_device *dev, int broadcast);
  extern void tick_handle_periodic(struct clock_event_device *dev);
 +extern int tick_notify(unsigned long reason, void *dev);
  extern void tick_check_new_device(struct clock_event_device *dev);
++<<<<<<< HEAD
++=======
+ extern void tick_handover_do_timer(int *cpup);
+ extern void tick_shutdown(unsigned int *cpup);
+ extern void tick_suspend(void);
+ extern void tick_resume(void);
+ extern bool tick_check_replacement(struct clock_event_device *curdev,
+ 				   struct clock_event_device *newdev);
+ extern void tick_install_replacement(struct clock_event_device *dev);
++>>>>>>> 03e13cf5ee60 (clockevents: Implement unbind functionality)
  
  extern void clockevents_shutdown(struct clock_event_device *dev);
  
diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 3abe1e9a1bde..89a2bedaf658 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -148,6 +148,7 @@ static inline unsigned long div_sc(unsigned long ticks, unsigned long nsec,
 extern u64 clockevent_delta2ns(unsigned long latch,
 			       struct clock_event_device *evt);
 extern void clockevents_register_device(struct clock_event_device *dev);
+extern int clockevents_unbind_device(struct clock_event_device *ced, int cpu);
 
 extern void clockevents_config(struct clock_event_device *dev, u32 freq);
 extern void clockevents_config_and_register(struct clock_event_device *dev,
diff --git a/kernel/time/clockevents.c b/kernel/time/clockevents.c
index ac1d2ea08259..11c8caf6cf02 100644
--- a/kernel/time/clockevents.c
+++ b/kernel/time/clockevents.c
@@ -25,6 +25,13 @@ static LIST_HEAD(clockevent_devices);
 static LIST_HEAD(clockevents_released);
 /* Protection for the above */
 static DEFINE_RAW_SPINLOCK(clockevents_lock);
+/* Protection for unbind operations */
+static DEFINE_MUTEX(clockevents_mutex);
+
+struct ce_unbind {
+	struct clock_event_device *ce;
+	int res;
+};
 
 static u64 cev_delta2ns(unsigned long latch, struct clock_event_device *evt,
 			bool ismax)
@@ -280,6 +287,90 @@ static void clockevents_notify_released(void)
 	}
 }
 
+/*
+ * Try to install a replacement clock event device
+ */
+static int clockevents_replace(struct clock_event_device *ced)
+{
+	struct clock_event_device *dev, *newdev = NULL;
+
+	list_for_each_entry(dev, &clockevent_devices, list) {
+		if (dev == ced || dev->mode != CLOCK_EVT_MODE_UNUSED)
+			continue;
+
+		if (!tick_check_replacement(newdev, dev))
+			continue;
+
+		if (!try_module_get(dev->owner))
+			continue;
+
+		if (newdev)
+			module_put(newdev->owner);
+		newdev = dev;
+	}
+	if (newdev) {
+		tick_install_replacement(newdev);
+		list_del_init(&ced->list);
+	}
+	return newdev ? 0 : -EBUSY;
+}
+
+/*
+ * Called with clockevents_mutex and clockevents_lock held
+ */
+static int __clockevents_try_unbind(struct clock_event_device *ced, int cpu)
+{
+	/* Fast track. Device is unused */
+	if (ced->mode == CLOCK_EVT_MODE_UNUSED) {
+		list_del_init(&ced->list);
+		return 0;
+	}
+
+	return ced == per_cpu(tick_cpu_device, cpu).evtdev ? -EAGAIN : -EBUSY;
+}
+
+/*
+ * SMP function call to unbind a device
+ */
+static void __clockevents_unbind(void *arg)
+{
+	struct ce_unbind *cu = arg;
+	int res;
+
+	raw_spin_lock(&clockevents_lock);
+	res = __clockevents_try_unbind(cu->ce, smp_processor_id());
+	if (res == -EAGAIN)
+		res = clockevents_replace(cu->ce);
+	cu->res = res;
+	raw_spin_unlock(&clockevents_lock);
+}
+
+/*
+ * Issues smp function call to unbind a per cpu device. Called with
+ * clockevents_mutex held.
+ */
+static int clockevents_unbind(struct clock_event_device *ced, int cpu)
+{
+	struct ce_unbind cu = { .ce = ced, .res = -ENODEV };
+
+	smp_call_function_single(cpu, __clockevents_unbind, &cu, 1);
+	return cu.res;
+}
+
+/*
+ * Unbind a clockevents device.
+ */
+int clockevents_unbind_device(struct clock_event_device *ced, int cpu)
+{
+	int ret;
+
+	mutex_lock(&clockevents_mutex);
+	ret = clockevents_unbind(ced, cpu);
+	mutex_unlock(&clockevents_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(clockevents_unbind);
+
 /**
  * clockevents_register_device - register a clock event device
  * @dev:	device to register
@@ -513,6 +604,38 @@ static ssize_t sysfs_show_current_tick_dev(struct device *dev,
 }
 static DEVICE_ATTR(current_device, 0444, sysfs_show_current_tick_dev, NULL);
 
+/* We don't support the abomination of removable broadcast devices */
+static ssize_t sysfs_unbind_tick_dev(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	char name[CS_NAME_LEN];
+	size_t ret = sysfs_get_uname(buf, name, count);
+	struct clock_event_device *ce;
+
+	if (ret < 0)
+		return ret;
+
+	ret = -ENODEV;
+	mutex_lock(&clockevents_mutex);
+	raw_spin_lock_irq(&clockevents_lock);
+	list_for_each_entry(ce, &clockevent_devices, list) {
+		if (!strcmp(ce->name, name)) {
+			ret = __clockevents_try_unbind(ce, dev->id);
+			break;
+		}
+	}
+	raw_spin_unlock_irq(&clockevents_lock);
+	/*
+	 * We hold clockevents_mutex, so ce can't go away
+	 */
+	if (ret == -EAGAIN)
+		ret = clockevents_unbind(ce, dev->id);
+	mutex_unlock(&clockevents_mutex);
+	return ret ? ret : count;
+}
+static DEVICE_ATTR(unbind_device, 0200, NULL, sysfs_unbind_tick_dev);
+
 #ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
 static struct device tick_bc_dev = {
 	.init_name	= "broadcast",
@@ -555,6 +678,8 @@ static int __init tick_init_sysfs(void)
 		err = device_register(dev);
 		if (!err)
 			err = device_create_file(dev, &dev_attr_current_device);
+		if (!err)
+			err = device_create_file(dev, &dev_attr_unbind_device);
 		if (err)
 			return err;
 	}
* Unmerged path kernel/time/clocksource.c
* Unmerged path kernel/time/tick-common.c
* Unmerged path kernel/time/tick-internal.h
