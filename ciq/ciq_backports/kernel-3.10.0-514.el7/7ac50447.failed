raid1/raid10: slow down resync if there is non-resync activity pending

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomasz Majchrzak <tomasz.majchrzak@intel.com>
commit 7ac504472263180745ac94242f1d253eb7284e48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7ac50447.failed

A performance drop of mkfs has been observed on RAID10 during resync
since commit 09314799e4f0 ("md: remove 'go_faster' option from
->sync_request()"). Resync sends so many IOs it slows down non-resync
IOs significantly (few times). Add a short delay to a resync. The
previous long sleep (1s) has proven unnecessary, even very short delay
brings performance right.

The change also applied to raid1. The problem has not been observed on
raid1, however it shares barriers code with raid10 so it might be an
issue for some setup too.

	Suggested-by: NeilBrown <neilb@suse.com>
Link: http://lkml.kernel.org/r/20160609134555.GA9104@proton.igk.intel.com
	Signed-off-by: Tomasz Majchrzak <tomasz.majchrzak@intel.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 7ac504472263180745ac94242f1d253eb7284e48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid1.c
diff --cc drivers/md/raid1.c
index 2703acb0b400,358a08e656f6..000000000000
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@@ -2554,7 -2535,19 +2554,23 @@@ static sector_t sync_request(struct mdd
  		return sync_blocks;
  	}
  
++<<<<<<< HEAD
 +	bitmap_cond_end_sync(mddev->bitmap, sector_nr);
++=======
+ 	/*
+ 	 * If there is non-resync activity waiting for a turn, then let it
+ 	 * though before starting on this new sync request.
+ 	 */
+ 	if (conf->nr_waiting)
+ 		schedule_timeout_uninterruptible(1);
+ 
+ 	/* we are incrementing sector_nr below. To be safe, we check against
+ 	 * sector_nr + two times RESYNC_SECTORS
+ 	 */
+ 
+ 	bitmap_cond_end_sync(mddev->bitmap, sector_nr,
+ 		mddev_is_clustered(mddev) && (sector_nr + 2 * RESYNC_SECTORS > conf->cluster_sync_high));
++>>>>>>> 7ac504472263 (raid1/raid10: slow down resync if there is non-resync activity pending)
  	r1_bio = mempool_alloc(conf->r1buf_pool, GFP_NOIO);
  
  	raise_barrier(conf, sector_nr);
* Unmerged path drivers/md/raid1.c
diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c
index 4423eafa0752..175d466abbc6 100644
--- a/drivers/md/raid10.c
+++ b/drivers/md/raid10.c
@@ -3049,6 +3049,13 @@ static sector_t sync_request(struct mddev *mddev, sector_t sector_nr,
 	    max_sector > (sector_nr | chunk_mask))
 		max_sector = (sector_nr | chunk_mask) + 1;
 
+	/*
+	 * If there is non-resync activity waiting for a turn, then let it
+	 * though before starting on this new sync request.
+	 */
+	if (conf->nr_waiting)
+		schedule_timeout_uninterruptible(1);
+
 	/* Again, very different code for resync and recovery.
 	 * Both must result in an r10bio with a list of bios that
 	 * have bi_end_io, bi_sector, bi_bdev set,
