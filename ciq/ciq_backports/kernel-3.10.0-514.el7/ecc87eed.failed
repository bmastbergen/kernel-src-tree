device property: fix potential NULL pointer dereference

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit ecc87eed7beeb50c0be0b73322d62135277ea2b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ecc87eed.failed

In device_add_property_set() we check pset parameter for a NULL, but few lines
later we do a pointer arithmetic without check that will crash kernel in the
set_secondary_fwnode().

Here we check if pset parameter is NULL and return immediately.

Fixes: 16ba08d5c9ec (device property: Introduce firmware node type for platform data)
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit ecc87eed7beeb50c0be0b73322d62135277ea2b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/property.c
diff --cc drivers/base/property.c
index 6a94ef6e83c9,37a7bb7b239d..000000000000
--- a/drivers/base/property.c
+++ b/drivers/base/property.c
@@@ -10,10 -10,104 +10,105 @@@
   * published by the Free Software Foundation.
   */
  
 -#include <linux/acpi.h>
 +#include <linux/property.h>
++<<<<<<< HEAD
  #include <linux/export.h>
 -#include <linux/kernel.h>
 +#include <linux/acpi.h>
  #include <linux/of.h>
 -#include <linux/of_address.h>
 -#include <linux/property.h>
++=======
+ 
+ /**
+  * device_add_property_set - Add a collection of properties to a device object.
+  * @dev: Device to add properties to.
+  * @pset: Collection of properties to add.
+  *
+  * Associate a collection of device properties represented by @pset with @dev
+  * as its secondary firmware node.
+  */
+ void device_add_property_set(struct device *dev, struct property_set *pset)
+ {
+ 	if (!pset)
+ 		return;
+ 
+ 	pset->fwnode.type = FWNODE_PDATA;
+ 	set_secondary_fwnode(dev, &pset->fwnode);
+ }
+ EXPORT_SYMBOL_GPL(device_add_property_set);
+ 
+ static inline bool is_pset(struct fwnode_handle *fwnode)
+ {
+ 	return fwnode && fwnode->type == FWNODE_PDATA;
+ }
+ 
+ static inline struct property_set *to_pset(struct fwnode_handle *fwnode)
+ {
+ 	return is_pset(fwnode) ?
+ 		container_of(fwnode, struct property_set, fwnode) : NULL;
+ }
+ 
+ static struct property_entry *pset_prop_get(struct property_set *pset,
+ 					    const char *name)
+ {
+ 	struct property_entry *prop;
+ 
+ 	if (!pset || !pset->properties)
+ 		return NULL;
+ 
+ 	for (prop = pset->properties; prop->name; prop++)
+ 		if (!strcmp(name, prop->name))
+ 			return prop;
+ 
+ 	return NULL;
+ }
+ 
+ static int pset_prop_read_array(struct property_set *pset, const char *name,
+ 				enum dev_prop_type type, void *val, size_t nval)
+ {
+ 	struct property_entry *prop;
+ 	unsigned int item_size;
+ 
+ 	prop = pset_prop_get(pset, name);
+ 	if (!prop)
+ 		return -ENODATA;
+ 
+ 	if (prop->type != type)
+ 		return -EPROTO;
+ 
+ 	if (!val)
+ 		return prop->nval;
+ 
+ 	if (prop->nval < nval)
+ 		return -EOVERFLOW;
+ 
+ 	switch (type) {
+ 	case DEV_PROP_U8:
+ 		item_size = sizeof(u8);
+ 		break;
+ 	case DEV_PROP_U16:
+ 		item_size = sizeof(u16);
+ 		break;
+ 	case DEV_PROP_U32:
+ 		item_size = sizeof(u32);
+ 		break;
+ 	case DEV_PROP_U64:
+ 		item_size = sizeof(u64);
+ 		break;
+ 	case DEV_PROP_STRING:
+ 		item_size = sizeof(const char *);
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 	memcpy(val, prop->value.raw_data, nval * item_size);
+ 	return 0;
+ }
+ 
+ static inline struct fwnode_handle *dev_fwnode(struct device *dev)
+ {
+ 	return IS_ENABLED(CONFIG_OF) && dev->of_node ?
+ 		&dev->of_node->fwnode : dev->fwnode;
+ }
++>>>>>>> ecc87eed7bee (device property: fix potential NULL pointer dereference)
  
  /**
   * device_property_present - check if a property of a device is present
* Unmerged path drivers/base/property.c
