nvme: protect against simultaneous shutdown invocations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Keith Busch <keith.busch@intel.com>
commit 77bf25ea70200cddf083f74b7f617e5f07fac8bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/77bf25ea.failed

	Signed-off-by: Keith Busch <keith.busch@intel.com>
[hch: split from a larger patch]
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 77bf25ea70200cddf083f74b7f617e5f07fac8bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index 2a6eb55ad96c,ad6d5cce42d5..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -95,6 -93,43 +96,46 @@@ struct async_cmd_info 
  };
  
  /*
++<<<<<<< HEAD:drivers/block/nvme-core.c
++=======
+  * Represents an NVM Express device.  Each nvme_dev is a PCI function.
+  */
+ struct nvme_dev {
+ 	struct list_head node;
+ 	struct nvme_queue **queues;
+ 	struct blk_mq_tag_set tagset;
+ 	struct blk_mq_tag_set admin_tagset;
+ 	u32 __iomem *dbs;
+ 	struct device *dev;
+ 	struct dma_pool *prp_page_pool;
+ 	struct dma_pool *prp_small_pool;
+ 	unsigned queue_count;
+ 	unsigned online_queues;
+ 	unsigned max_qid;
+ 	int q_depth;
+ 	u32 db_stride;
+ 	struct msix_entry *entry;
+ 	void __iomem *bar;
+ 	struct work_struct reset_work;
+ 	struct work_struct probe_work;
+ 	struct work_struct scan_work;
+ 	struct mutex shutdown_lock;
+ 	bool subsystem;
+ 	void __iomem *cmb;
+ 	dma_addr_t cmb_dma_addr;
+ 	u64 cmb_size;
+ 	u32 cmbsz;
+ 
+ 	struct nvme_ctrl ctrl;
+ };
+ 
+ static inline struct nvme_dev *to_nvme_dev(struct nvme_ctrl *ctrl)
+ {
+ 	return container_of(ctrl, struct nvme_dev, ctrl);
+ }
+ 
+ /*
++>>>>>>> 77bf25ea7020 (nvme: protect against simultaneous shutdown invocations):drivers/nvme/host/pci.c
   * An NVM Express queue.  Each device has at least two (one for admin
   * commands and one for I/O commands).
   */
@@@ -2748,9 -2075,10 +2789,10 @@@ static void nvme_dev_shutdown(struct nv
  
  	nvme_dev_list_remove(dev);
  
+ 	mutex_lock(&dev->shutdown_lock);
  	if (dev->bar) {
  		nvme_freeze_queues(dev);
 -		csts = readl(dev->bar + NVME_REG_CSTS);
 +		csts = readl(&dev->bar->csts);
  	}
  	if (csts & NVME_CSTS_CFS || !(csts & NVME_CSTS_RDY)) {
  		for (i = dev->queue_count - 1; i >= 0; i--) {
@@@ -2766,20 -2094,12 +2808,21 @@@
  
  	for (i = dev->queue_count - 1; i >= 0; i--)
  		nvme_clear_queue(dev->queues[i]);
+ 	mutex_unlock(&dev->shutdown_lock);
  }
  
 +static void nvme_dev_remove(struct nvme_dev *dev)
 +{
 +	struct nvme_ns *ns, *next;
 +
 +	list_for_each_entry_safe(ns, next, &dev->namespaces, list)
 +		nvme_ns_remove(ns);
 +}
 +
  static int nvme_setup_prp_pools(struct nvme_dev *dev)
  {
 -	dev->prp_page_pool = dma_pool_create("prp list page", dev->dev,
 +	struct device *dmadev = &dev->pci_dev->dev;
 +	dev->prp_page_pool = dma_pool_create("prp list page", dmadev,
  						PAGE_SIZE, PAGE_SIZE, 0);
  	if (!dev->prp_page_pool)
  		return -ENOMEM;
@@@ -3122,11 -2330,16 +3165,22 @@@ static int nvme_probe(struct pci_dev *p
  	if (!dev->queues)
  		goto free;
  
 -	dev->dev = get_device(&pdev->dev);
 +	INIT_LIST_HEAD(&dev->namespaces);
 +	INIT_WORK(&dev->reset_work, nvme_reset_failed_dev);
 +	dev->pci_dev = pci_dev_get(pdev);
  	pci_set_drvdata(pdev, dev);
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +	result = nvme_set_instance(dev);
++=======
+ 
+ 	INIT_LIST_HEAD(&dev->node);
+ 	INIT_WORK(&dev->scan_work, nvme_dev_scan);
+ 	INIT_WORK(&dev->probe_work, nvme_probe_work);
+ 	INIT_WORK(&dev->reset_work, nvme_reset_work);
+ 	mutex_init(&dev->shutdown_lock);
+ 
+ 	result = nvme_setup_prp_pools(dev);
++>>>>>>> 77bf25ea7020 (nvme: protect against simultaneous shutdown invocations):drivers/nvme/host/pci.c
  	if (result)
  		goto put_pci;
  
* Unmerged path drivers/block/nvme-core.c
