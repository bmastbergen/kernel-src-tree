btrfs: scrub: setup all fields for sblock_to_check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Zhao Lei <zhaolei@cn.fujitsu.com>
commit 4734b7ed79e1230602927a38bc4d04dbe9dd09c1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4734b7ed.failed

scrub_setup_recheck_block() isn't setup all necessary fields for
sblock_to_check because history reason.

So current code need more arguments in severial functions,
and more local variables, just to passing these lacked values to
necessary place.

This patch setup above fields to sblock_to_check in
scrub_setup_recheck_block(), for:
1: more cleanup for function arg, local variable
2: to make sblock_to_check complete, then we can use sblock_to_check
   without concern about some uninitialized member.

	Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit 4734b7ed79e1230602927a38bc4d04dbe9dd09c1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/scrub.c
diff --cc fs/btrfs/scrub.c
index 44b6152bbfa8,12ed8a77f11c..000000000000
--- a/fs/btrfs/scrub.c
+++ b/fs/btrfs/scrub.c
@@@ -1333,15 -1311,18 +1333,25 @@@ static inline void scrub_stripe_index_a
  	}
  }
  
 -static int scrub_setup_recheck_block(struct scrub_block *original_sblock,
 +static int scrub_setup_recheck_block(struct scrub_ctx *sctx,
 +				     struct btrfs_fs_info *fs_info,
 +				     struct scrub_block *original_sblock,
 +				     u64 length, u64 logical,
  				     struct scrub_block *sblocks_for_recheck)
  {
++<<<<<<< HEAD
++=======
+ 	struct scrub_ctx *sctx = original_sblock->sctx;
+ 	struct btrfs_fs_info *fs_info = sctx->dev_root->fs_info;
+ 	u64 length = original_sblock->page_count * PAGE_SIZE;
+ 	u64 logical = original_sblock->pagev[0]->logical;
+ 	u64 generation = original_sblock->pagev[0]->generation;
+ 	u64 flags = original_sblock->pagev[0]->flags;
+ 	u64 have_csum = original_sblock->pagev[0]->have_csum;
++>>>>>>> 4734b7ed79e1 (btrfs: scrub: setup all fields for sblock_to_check)
  	struct scrub_recover *recover;
  	struct btrfs_bio *bbio;
 +	u64 *raid_map;
  	u64 sublen;
  	u64 mapped_length;
  	u64 stripe_offset;
@@@ -1396,11 -1373,9 +1406,12 @@@
  			struct scrub_block *sblock;
  			struct scrub_page *page;
  
 +			if (mirror_index >= BTRFS_MAX_MIRRORS)
 +				break;
 +
  			sblock = sblocks_for_recheck + mirror_index;
  			sblock->sctx = sctx;
+ 
  			page = kzalloc(sizeof(*page), GFP_NOFS);
  			if (!page) {
  leave_nomem:
@@@ -1412,9 -1387,19 +1423,17 @@@
  			}
  			scrub_page_get(page);
  			sblock->pagev[page_index] = page;
+ 			page->sblock = sblock;
+ 			page->flags = flags;
+ 			page->generation = generation;
  			page->logical = logical;
+ 			page->have_csum = have_csum;
+ 			if (have_csum)
+ 				memcpy(page->csum,
+ 				       original_sblock->pagev[0]->csum,
+ 				       sctx->csum_size);
  
 -			scrub_stripe_index_and_offset(logical,
 -						      bbio->map_type,
 -						      bbio->raid_map,
 +			scrub_stripe_index_and_offset(logical, raid_map,
  						      mapped_length,
  						      bbio->num_stripes -
  						      bbio->num_tgtdevs,
* Unmerged path fs/btrfs/scrub.c
