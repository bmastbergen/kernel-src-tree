IB/srp: Do not register memory if never_register has been set

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit c222a39f0d2652ff32e10a95979af9bf906b9844
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c222a39f.failed

This makes it easier to test the code path that does not use
memory registration (srp_map_sg_dma()).

	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Sagi Grimberg <sagi@grimberg.me>
	Cc: Laurence Oberman <loberman@redhat.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit c222a39f0d2652ff32e10a95979af9bf906b9844)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/srp/ib_srp.c
diff --cc drivers/infiniband/ulp/srp/ib_srp.c
index eb57f69536ed,0b576c50e866..000000000000
--- a/drivers/infiniband/ulp/srp/ib_srp.c
+++ b/drivers/infiniband/ulp/srp/ib_srp.c
@@@ -99,7 -100,10 +100,14 @@@ module_param(register_always, bool, 044
  MODULE_PARM_DESC(register_always,
  		 "Use memory registration even for contiguous memory regions");
  
++<<<<<<< HEAD
 +static struct kernel_param_ops srp_tmo_ops;
++=======
+ module_param(never_register, bool, 0444);
+ MODULE_PARM_DESC(never_register, "Never register memory");
+ 
+ static const struct kernel_param_ops srp_tmo_ops;
++>>>>>>> c222a39f0d26 (IB/srp: Do not register memory if never_register has been set)
  
  static int srp_reconnect_delay = 10;
  module_param_cb(reconnect_delay, &srp_tmo_ops, &srp_reconnect_delay,
@@@ -3478,13 -3535,30 +3486,30 @@@ static void srp_add_one(struct ib_devic
  	 * minimum of 4096 bytes. We're unlikely to build large sglists
  	 * out of smaller entries.
  	 */
 -	mr_page_shift		= max(12, ffs(device->attrs.page_size_cap) - 1);
 +	mr_page_shift		= max(12, ffs(dev_attr->page_size_cap) - 1);
  	srp_dev->mr_page_size	= 1 << mr_page_shift;
  	srp_dev->mr_page_mask	= ~((u64) srp_dev->mr_page_size - 1);
 -	max_pages_per_mr	= device->attrs.max_mr_size;
 +	max_pages_per_mr	= dev_attr->max_mr_size;
  	do_div(max_pages_per_mr, srp_dev->mr_page_size);
 -	pr_debug("%s: %llu / %u = %llu <> %u\n", __func__,
 -		 device->attrs.max_mr_size, srp_dev->mr_page_size,
 -		 max_pages_per_mr, SRP_MAX_PAGES_PER_MR);
  	srp_dev->max_pages_per_mr = min_t(u64, SRP_MAX_PAGES_PER_MR,
  					  max_pages_per_mr);
++<<<<<<< HEAD
++=======
+ 
+ 	srp_dev->has_fmr = (device->alloc_fmr && device->dealloc_fmr &&
+ 			    device->map_phys_fmr && device->unmap_fmr);
+ 	srp_dev->has_fr = (device->attrs.device_cap_flags &
+ 			   IB_DEVICE_MEM_MGT_EXTENSIONS);
+ 	if (!never_register && !srp_dev->has_fmr && !srp_dev->has_fr) {
+ 		dev_warn(&device->dev, "neither FMR nor FR is supported\n");
+ 	} else if (!never_register &&
+ 		   device->attrs.max_mr_size >= 2 * srp_dev->mr_page_size) {
+ 		srp_dev->use_fast_reg = (srp_dev->has_fr &&
+ 					 (!srp_dev->has_fmr || prefer_fr));
+ 		srp_dev->use_fmr = !srp_dev->use_fast_reg && srp_dev->has_fmr;
+ 	}
+ 
++>>>>>>> c222a39f0d26 (IB/srp: Do not register memory if never_register has been set)
  	if (srp_dev->use_fast_reg) {
  		srp_dev->max_pages_per_mr =
  			min_t(u32, srp_dev->max_pages_per_mr,
* Unmerged path drivers/infiniband/ulp/srp/ib_srp.c
