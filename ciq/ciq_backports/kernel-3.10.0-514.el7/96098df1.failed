gpiolib: fix chip order in gpio list

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Julien Grossholtz <julien.grossholtz@savoirfairelinux.com>
commit 96098df125c0a966631ec114081d8f5630a0e4b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/96098df1.failed

In some situations the gpio_list order is not correct.
As a consequence gpiochip_find_base returns the same
base number twice. This happens when a first ship is added
with manual base number, then other ships are added using
automatic base number.

To prevent this behaviour, this patch add the new chip after
the last element of the gpio list.

	Signed-off-by: Julien Grossholtz <julien.grossholtz@savoirfairelinux.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 96098df125c0a966631ec114081d8f5630a0e4b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpiolib.c
diff --cc drivers/gpio/gpiolib.c
index 9b50ed619d38,a1805734aef8..000000000000
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@@ -1127,25 -189,80 +1127,94 @@@ static inline void gpiochip_unexport(st
   */
  static int gpiochip_add_to_list(struct gpio_chip *chip)
  {
 -	struct gpio_chip *iterator;
 -	struct gpio_chip *previous = NULL;
 +	struct list_head *pos = &gpio_chips;
 +	struct gpio_chip *_chip;
 +	int err = 0;
  
 -	if (list_empty(&gpio_chips)) {
 -		list_add_tail(&chip->list, &gpio_chips);
 -		return 0;
 +	/* find where to insert our chip */
 +	list_for_each(pos, &gpio_chips) {
 +		_chip = list_entry(pos, struct gpio_chip, list);
 +		/* shall we insert before _chip? */
 +		if (_chip->base >= chip->base + chip->ngpio)
 +			break;
  	}
  
++<<<<<<< HEAD
 +	/* are we stepping on the chip right before? */
 +	if (pos != &gpio_chips && pos->prev != &gpio_chips) {
 +		_chip = list_entry(pos->prev, struct gpio_chip, list);
 +		if (_chip->base + _chip->ngpio > chip->base) {
 +			dev_err(chip->dev,
 +			       "GPIO integer space overlap, cannot add chip\n");
 +			err = -EBUSY;
++=======
+ 	list_for_each_entry(iterator, &gpio_chips, list) {
+ 		if (iterator->base >= chip->base + chip->ngpio) {
+ 			/*
+ 			 * Iterator is the first GPIO chip so there is no
+ 			 * previous one
+ 			 */
+ 			if (!previous) {
+ 				goto found;
+ 			} else {
+ 				/*
+ 				 * We found a valid range(means
+ 				 * [base, base + ngpio - 1]) between previous
+ 				 * and iterator chip.
+ 				 */
+ 				if (previous->base + previous->ngpio
+ 						<= chip->base)
+ 					goto found;
+ 			}
+ 		}
+ 		previous = iterator;
+ 	}
+ 
+ 	/*
+ 	 * We are beyond the last chip in the list and iterator now
+ 	 * points to the head.
+ 	 * Let iterator point to the last chip in the list.
+ 	 */
+ 
+ 	iterator = list_last_entry(&gpio_chips, struct gpio_chip, list);
+ 	if (iterator->base + iterator->ngpio <= chip->base) {
+ 		list_add(&chip->list, &iterator->list);
+ 		return 0;
+ 	}
+ 
+ 	dev_err(chip->parent,
+ 	       "GPIO integer space overlap, cannot add chip\n");
+ 	return -EBUSY;
+ 
+ found:
+ 	list_add_tail(&chip->list, &iterator->list);
+ 	return 0;
+ }
+ 
+ /**
+  * Convert a GPIO name to its descriptor
+  */
+ static struct gpio_desc *gpio_name_to_desc(const char * const name)
+ {
+ 	struct gpio_chip *chip;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&gpio_lock, flags);
+ 
+ 	list_for_each_entry(chip, &gpio_chips, list) {
+ 		int i;
+ 
+ 		for (i = 0; i != chip->ngpio; ++i) {
+ 			struct gpio_desc *gpio = &chip->desc[i];
+ 
+ 			if (!gpio->name || !name)
+ 				continue;
+ 
+ 			if (!strcmp(gpio->name, name)) {
+ 				spin_unlock_irqrestore(&gpio_lock, flags);
+ 				return gpio;
+ 			}
++>>>>>>> 96098df125c0 (gpiolib: fix chip order in gpio list)
  		}
  	}
  
* Unmerged path drivers/gpio/gpiolib.c
