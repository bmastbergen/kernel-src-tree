mmc: core: consistent handling of initial values

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] core: consistent handling of initial values (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 94.51%
commit-author Johan Rudholm <johan.rudholm@axis.com>
commit 2d079c43bc5ade7b41610b356bf117e14037a584
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2d079c43.failed

mmc_do_hw_reset(), mmc_power_up() and mmc_power_off() all set similar
initial values for bus_mode, bus_width, chip_select and timing. Let's
make this handling simpler and more consistent by sticking them
together in a common function. This will introduce small changes in
behavior in the following places:

mmc_power_off():

  For SPI hosts, explicitly set bus_mode = MMC_BUSMODE_PUSHPULL and
  chip_select = MMC_CS_HIGH, before we left them as they were.

  For non-SPI hosts, set bus_mode = MMC_BUSMODE_PUSHPULL instead of
  MMC_BUSMODE_OPENDRAIN as before.

  These two changes should not be a problem since the device will be
  powered off anyway.

mmc_do_hw_reset():

  Always set bus_mode = MMC_BUSMODE_PUSHPULL, as required by SD/SDIO
  cards. MMC cards require MMC_BUSMODE_OPENDRAIN, but this is taken
  care of by mmc_init_card() and mmc_attach_mmc().

	Signed-off-by: Johan Rudholm <johanru@axis.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 2d079c43bc5ade7b41610b356bf117e14037a584)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/core.c
diff --cc drivers/mmc/core/core.c
index c85117ee87f6,5bda29bff8eb..000000000000
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@@ -2277,17 -2283,8 +2282,22 @@@ static int mmc_do_hw_reset(struct mmc_h
  		}
  	}
  
++<<<<<<< HEAD
 +	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_HIGHSPEED_DDR);
 +	if (mmc_host_is_spi(host)) {
 +		host->ios.chip_select = MMC_CS_HIGH;
 +		host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
 +	} else {
 +		host->ios.chip_select = MMC_CS_DONTCARE;
 +		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
 +	}
 +	host->ios.bus_width = MMC_BUS_WIDTH_1;
 +	host->ios.timing = MMC_TIMING_LEGACY;
 +	mmc_set_ios(host);
++=======
+ 	/* Set initial state and call mmc_set_ios */
+ 	mmc_set_initial_state(host);
++>>>>>>> 2d079c43bc5a (mmc: core: consistent handling of initial values)
  
  	mmc_host_clk_release(host);
  
* Unmerged path drivers/mmc/core/core.c
diff --git a/drivers/mmc/core/core.h b/drivers/mmc/core/core.h
index 443a584660f0..d76597c65e3a 100644
--- a/drivers/mmc/core/core.h
+++ b/drivers/mmc/core/core.h
@@ -49,6 +49,7 @@ void mmc_set_driver_type(struct mmc_host *host, unsigned int drv_type);
 void mmc_power_up(struct mmc_host *host, u32 ocr);
 void mmc_power_off(struct mmc_host *host);
 void mmc_power_cycle(struct mmc_host *host, u32 ocr);
+void mmc_set_initial_state(struct mmc_host *host);
 
 static inline void mmc_delay(unsigned int ms)
 {
