net/mlx5e: Add support for RXALL netdev feature

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [include] mlx5e: Add support for RXALL netdev feature (kamal heib) [1275159 1296272 1296405 1298421 1298422 1298423 1298424 1298425]
Rebuild_FUZZ: 95.56%
commit-author Eran Ben Elisha <eranbe@mellanox.com>
commit 94cb1ebbafd509210887eea6ced55c40da7b4baa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/94cb1ebb.failed

Introduce new access register named Ports Check Mask Register (PCMR) to
control all HW checks on port. With this register, the driver can
enable/disable Hardware FCS validation.

When RXALL is enabled/disabled using ndo_set_features, enable/disable
fcs check at HW.
User can change HW configuration using rx-all flag at ethtool.

	Signed-off-by: Eran Ben Elisha <eranbe@mellanox.com>
	Signed-off-by: Gal Pressman <galp@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 94cb1ebbafd509210887eea6ced55c40da7b4baa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/port.c
#	include/linux/mlx5/port.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index b70e3293db0b,ad0cb4aa593b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2017,8 -2114,79 +2017,84 @@@ static int mlx5e_set_features(struct ne
  	return err;
  }
  
++<<<<<<< HEAD
 +#define MXL5_HW_MIN_MTU 64
 +#define MXL5E_MIN_MTU (MXL5_HW_MIN_MTU + ETH_FCS_LEN)
++=======
+ static int set_feature_vlan_filter(struct net_device *netdev, bool enable)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	if (enable)
+ 		mlx5e_enable_vlan_filter(priv);
+ 	else
+ 		mlx5e_disable_vlan_filter(priv);
+ 
+ 	return 0;
+ }
+ 
+ static int set_feature_tc_num_filters(struct net_device *netdev, bool enable)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	if (!enable && mlx5e_tc_num_filters(priv)) {
+ 		netdev_err(netdev,
+ 			   "Active offloaded tc filters, can't turn hw_tc_offload off\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int set_feature_rx_all(struct net_device *netdev, bool enable)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 
+ 	return mlx5_set_port_fcs(mdev, !enable);
+ }
+ 
+ static int mlx5e_handle_feature(struct net_device *netdev,
+ 				netdev_features_t wanted_features,
+ 				netdev_features_t feature,
+ 				mlx5e_feature_handler feature_handler)
+ {
+ 	netdev_features_t changes = wanted_features ^ netdev->features;
+ 	bool enable = !!(wanted_features & feature);
+ 	int err;
+ 
+ 	if (!(changes & feature))
+ 		return 0;
+ 
+ 	err = feature_handler(netdev, enable);
+ 	if (err) {
+ 		netdev_err(netdev, "%s feature 0x%llx failed err %d\n",
+ 			   enable ? "Enable" : "Disable", feature, err);
+ 		return err;
+ 	}
+ 
+ 	MLX5E_SET_FEATURE(netdev, feature, enable);
+ 	return 0;
+ }
+ 
+ static int mlx5e_set_features(struct net_device *netdev,
+ 			      netdev_features_t features)
+ {
+ 	int err;
+ 
+ 	err  = mlx5e_handle_feature(netdev, features, NETIF_F_LRO,
+ 				    set_feature_lro);
+ 	err |= mlx5e_handle_feature(netdev, features,
+ 				    NETIF_F_HW_VLAN_CTAG_FILTER,
+ 				    set_feature_vlan_filter);
+ 	err |= mlx5e_handle_feature(netdev, features, NETIF_F_HW_TC,
+ 				    set_feature_tc_num_filters);
+ 	err |= mlx5e_handle_feature(netdev, features, NETIF_F_RXALL,
+ 				    set_feature_rx_all);
+ 
+ 	return err ? -EINVAL : 0;
+ }
++>>>>>>> 94cb1ebbafd5 (net/mlx5e: Add support for RXALL netdev feature)
  
  static int mlx5e_change_mtu(struct net_device *netdev, int new_mtu)
  {
@@@ -2280,10 -2609,35 +2358,41 @@@ static void mlx5e_build_netdev(struct n
  	netdev->hw_features      |= NETIF_F_HW_VLAN_CTAG_RX;
  	netdev->hw_features      |= NETIF_F_HW_VLAN_CTAG_FILTER;
  
++<<<<<<< HEAD
++=======
+ 	if (mlx5e_vxlan_allowed(mdev)) {
+ 		netdev->hw_features     |= NETIF_F_GSO_UDP_TUNNEL;
+ 		netdev->hw_enc_features |= NETIF_F_IP_CSUM;
+ 		netdev->hw_enc_features |= NETIF_F_RXCSUM;
+ 		netdev->hw_enc_features |= NETIF_F_TSO;
+ 		netdev->hw_enc_features |= NETIF_F_TSO6;
+ 		netdev->hw_enc_features |= NETIF_F_RXHASH;
+ 		netdev->hw_enc_features |= NETIF_F_GSO_UDP_TUNNEL;
+ 	}
+ 
+ 	mlx5_query_port_fcs(mdev, &fcs_supported, &fcs_enabled);
+ 
+ 	if (fcs_supported)
+ 		netdev->hw_features |= NETIF_F_RXALL;
+ 
++>>>>>>> 94cb1ebbafd5 (net/mlx5e: Add support for RXALL netdev feature)
  	netdev->features          = netdev->hw_features;
  	if (!priv->params.lro_en)
  		netdev->features  &= ~NETIF_F_LRO;
  
++<<<<<<< HEAD
++=======
+ 	if (fcs_enabled)
+ 		netdev->features  &= ~NETIF_F_RXALL;
+ 
+ #define FT_CAP(f) MLX5_CAP_FLOWTABLE(mdev, flow_table_properties_nic_receive.f)
+ 	if (FT_CAP(flow_modify_en) &&
+ 	    FT_CAP(modify_root) &&
+ 	    FT_CAP(identified_miss_table_mode) &&
+ 	    FT_CAP(flow_table_modify))
+ 		priv->netdev->hw_features      |= NETIF_F_HW_TC;
+ 
++>>>>>>> 94cb1ebbafd5 (net/mlx5e: Add support for RXALL netdev feature)
  	netdev->features         |= NETIF_F_HIGHDMA;
  
  	netdev->priv_flags       |= IFF_UNICAST_FLT;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/port.c
index ed339867cddb,c37740f30fbe..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/port.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/port.c
@@@ -428,3 -428,231 +428,234 @@@ int mlx5_query_port_pfc(struct mlx5_cor
  	return 0;
  }
  EXPORT_SYMBOL_GPL(mlx5_query_port_pfc);
++<<<<<<< HEAD
++=======
+ 
+ int mlx5_max_tc(struct mlx5_core_dev *mdev)
+ {
+ 	u8 num_tc = MLX5_CAP_GEN(mdev, max_tc) ? : 8;
+ 
+ 	return num_tc - 1;
+ }
+ 
+ int mlx5_set_port_prio_tc(struct mlx5_core_dev *mdev, u8 *prio_tc)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(qtct_reg)];
+ 	u32 out[MLX5_ST_SZ_DW(qtct_reg)];
+ 	int err;
+ 	int i;
+ 
+ 	memset(in, 0, sizeof(in));
+ 	for (i = 0; i < 8; i++) {
+ 		if (prio_tc[i] > mlx5_max_tc(mdev))
+ 			return -EINVAL;
+ 
+ 		MLX5_SET(qtct_reg, in, prio, i);
+ 		MLX5_SET(qtct_reg, in, tclass, prio_tc[i]);
+ 
+ 		err = mlx5_core_access_reg(mdev, in, sizeof(in), out,
+ 					   sizeof(out), MLX5_REG_QTCT, 0, 1);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(mlx5_set_port_prio_tc);
+ 
+ static int mlx5_set_port_qetcr_reg(struct mlx5_core_dev *mdev, u32 *in,
+ 				   int inlen)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(qtct_reg)];
+ 
+ 	if (!MLX5_CAP_GEN(mdev, ets))
+ 		return -ENOTSUPP;
+ 
+ 	return mlx5_core_access_reg(mdev, in, inlen, out, sizeof(out),
+ 				    MLX5_REG_QETCR, 0, 1);
+ }
+ 
+ static int mlx5_query_port_qetcr_reg(struct mlx5_core_dev *mdev, u32 *out,
+ 				     int outlen)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(qtct_reg)];
+ 
+ 	if (!MLX5_CAP_GEN(mdev, ets))
+ 		return -ENOTSUPP;
+ 
+ 	memset(in, 0, sizeof(in));
+ 	return mlx5_core_access_reg(mdev, in, sizeof(in), out, outlen,
+ 				    MLX5_REG_QETCR, 0, 0);
+ }
+ 
+ int mlx5_set_port_tc_group(struct mlx5_core_dev *mdev, u8 *tc_group)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(qetc_reg)];
+ 	int i;
+ 
+ 	memset(in, 0, sizeof(in));
+ 
+ 	for (i = 0; i <= mlx5_max_tc(mdev); i++) {
+ 		MLX5_SET(qetc_reg, in, tc_configuration[i].g, 1);
+ 		MLX5_SET(qetc_reg, in, tc_configuration[i].group, tc_group[i]);
+ 	}
+ 
+ 	return mlx5_set_port_qetcr_reg(mdev, in, sizeof(in));
+ }
+ EXPORT_SYMBOL_GPL(mlx5_set_port_tc_group);
+ 
+ int mlx5_set_port_tc_bw_alloc(struct mlx5_core_dev *mdev, u8 *tc_bw)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(qetc_reg)];
+ 	int i;
+ 
+ 	memset(in, 0, sizeof(in));
+ 
+ 	for (i = 0; i <= mlx5_max_tc(mdev); i++) {
+ 		MLX5_SET(qetc_reg, in, tc_configuration[i].b, 1);
+ 		MLX5_SET(qetc_reg, in, tc_configuration[i].bw_allocation, tc_bw[i]);
+ 	}
+ 
+ 	return mlx5_set_port_qetcr_reg(mdev, in, sizeof(in));
+ }
+ EXPORT_SYMBOL_GPL(mlx5_set_port_tc_bw_alloc);
+ 
+ int mlx5_modify_port_ets_rate_limit(struct mlx5_core_dev *mdev,
+ 				    u8 *max_bw_value,
+ 				    u8 *max_bw_units)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(qetc_reg)];
+ 	void *ets_tcn_conf;
+ 	int i;
+ 
+ 	memset(in, 0, sizeof(in));
+ 
+ 	MLX5_SET(qetc_reg, in, port_number, 1);
+ 
+ 	for (i = 0; i <= mlx5_max_tc(mdev); i++) {
+ 		ets_tcn_conf = MLX5_ADDR_OF(qetc_reg, in, tc_configuration[i]);
+ 
+ 		MLX5_SET(ets_tcn_config_reg, ets_tcn_conf, r, 1);
+ 		MLX5_SET(ets_tcn_config_reg, ets_tcn_conf, max_bw_units,
+ 			 max_bw_units[i]);
+ 		MLX5_SET(ets_tcn_config_reg, ets_tcn_conf, max_bw_value,
+ 			 max_bw_value[i]);
+ 	}
+ 
+ 	return mlx5_set_port_qetcr_reg(mdev, in, sizeof(in));
+ }
+ EXPORT_SYMBOL_GPL(mlx5_modify_port_ets_rate_limit);
+ 
+ int mlx5_query_port_ets_rate_limit(struct mlx5_core_dev *mdev,
+ 				   u8 *max_bw_value,
+ 				   u8 *max_bw_units)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(qetc_reg)];
+ 	void *ets_tcn_conf;
+ 	int err;
+ 	int i;
+ 
+ 	err = mlx5_query_port_qetcr_reg(mdev, out, sizeof(out));
+ 	if (err)
+ 		return err;
+ 
+ 	for (i = 0; i <= mlx5_max_tc(mdev); i++) {
+ 		ets_tcn_conf = MLX5_ADDR_OF(qetc_reg, out, tc_configuration[i]);
+ 
+ 		max_bw_value[i] = MLX5_GET(ets_tcn_config_reg, ets_tcn_conf,
+ 					   max_bw_value);
+ 		max_bw_units[i] = MLX5_GET(ets_tcn_config_reg, ets_tcn_conf,
+ 					   max_bw_units);
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(mlx5_query_port_ets_rate_limit);
+ 
+ int mlx5_set_port_wol(struct mlx5_core_dev *mdev, u8 wol_mode)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(set_wol_rol_in)];
+ 	u32 out[MLX5_ST_SZ_DW(set_wol_rol_out)];
+ 
+ 	memset(in, 0, sizeof(in));
+ 	memset(out, 0, sizeof(out));
+ 
+ 	MLX5_SET(set_wol_rol_in, in, opcode, MLX5_CMD_OP_SET_WOL_ROL);
+ 	MLX5_SET(set_wol_rol_in, in, wol_mode_valid, 1);
+ 	MLX5_SET(set_wol_rol_in, in, wol_mode, wol_mode);
+ 
+ 	return mlx5_cmd_exec_check_status(mdev, in, sizeof(in),
+ 					  out, sizeof(out));
+ }
+ EXPORT_SYMBOL_GPL(mlx5_set_port_wol);
+ 
+ int mlx5_query_port_wol(struct mlx5_core_dev *mdev, u8 *wol_mode)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(query_wol_rol_in)];
+ 	u32 out[MLX5_ST_SZ_DW(query_wol_rol_out)];
+ 	int err;
+ 
+ 	memset(in, 0, sizeof(in));
+ 	memset(out, 0, sizeof(out));
+ 
+ 	MLX5_SET(query_wol_rol_in, in, opcode, MLX5_CMD_OP_QUERY_WOL_ROL);
+ 
+ 	err = mlx5_cmd_exec_check_status(mdev, in, sizeof(in),
+ 					 out, sizeof(out));
+ 
+ 	if (!err)
+ 		*wol_mode = MLX5_GET(query_wol_rol_out, out, wol_mode);
+ 
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(mlx5_query_port_wol);
+ 
+ static int mlx5_query_ports_check(struct mlx5_core_dev *mdev, u32 *out,
+ 				  int outlen)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(pcmr_reg)];
+ 
+ 	memset(in, 0, sizeof(in));
+ 	MLX5_SET(pcmr_reg, in, local_port, 1);
+ 
+ 	return mlx5_core_access_reg(mdev, in, sizeof(in), out,
+ 				    outlen, MLX5_REG_PCMR, 0, 0);
+ }
+ 
+ static int mlx5_set_ports_check(struct mlx5_core_dev *mdev, u32 *in, int inlen)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(pcmr_reg)];
+ 
+ 	return mlx5_core_access_reg(mdev, in, inlen, out,
+ 				    sizeof(out), MLX5_REG_PCMR, 0, 1);
+ }
+ 
+ int mlx5_set_port_fcs(struct mlx5_core_dev *mdev, u8 enable)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(pcmr_reg)];
+ 
+ 	memset(in, 0, sizeof(in));
+ 	MLX5_SET(pcmr_reg, in, local_port, 1);
+ 	MLX5_SET(pcmr_reg, in, fcs_chk, enable);
+ 
+ 	return mlx5_set_ports_check(mdev, in, sizeof(in));
+ }
+ 
+ void mlx5_query_port_fcs(struct mlx5_core_dev *mdev, bool *supported,
+ 			 bool *enabled)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(pcmr_reg)];
+ 	/* Default values for FW which do not support MLX5_REG_PCMR */
+ 	*supported = false;
+ 	*enabled = true;
+ 
+ 	if (!MLX5_CAP_GEN(mdev, ports_check))
+ 		return;
+ 
+ 	if (mlx5_query_ports_check(mdev, out, sizeof(out)))
+ 		return;
+ 
+ 	*supported = !!(MLX5_GET(pcmr_reg, out, fcs_cap));
+ 	*enabled = !!(MLX5_GET(pcmr_reg, out, fcs_chk));
+ }
++>>>>>>> 94cb1ebbafd5 (net/mlx5e: Add support for RXALL netdev feature)
diff --cc include/linux/mlx5/port.h
index 66ed80185fae,577e953d0aa7..000000000000
--- a/include/linux/mlx5/port.h
+++ b/include/linux/mlx5/port.h
@@@ -70,4 -70,22 +70,25 @@@ int mlx5_set_port_pfc(struct mlx5_core_
  int mlx5_query_port_pfc(struct mlx5_core_dev *dev, u8 *pfc_en_tx,
  			u8 *pfc_en_rx);
  
++<<<<<<< HEAD
++=======
+ int mlx5_max_tc(struct mlx5_core_dev *mdev);
+ 
+ int mlx5_set_port_prio_tc(struct mlx5_core_dev *mdev, u8 *prio_tc);
+ int mlx5_set_port_tc_group(struct mlx5_core_dev *mdev, u8 *tc_group);
+ int mlx5_set_port_tc_bw_alloc(struct mlx5_core_dev *mdev, u8 *tc_bw);
+ int mlx5_modify_port_ets_rate_limit(struct mlx5_core_dev *mdev,
+ 				    u8 *max_bw_value,
+ 				    u8 *max_bw_unit);
+ int mlx5_query_port_ets_rate_limit(struct mlx5_core_dev *mdev,
+ 				   u8 *max_bw_value,
+ 				   u8 *max_bw_unit);
+ int mlx5_set_port_wol(struct mlx5_core_dev *mdev, u8 wol_mode);
+ int mlx5_query_port_wol(struct mlx5_core_dev *mdev, u8 *wol_mode);
+ 
+ int mlx5_set_port_fcs(struct mlx5_core_dev *mdev, u8 enable);
+ void mlx5_query_port_fcs(struct mlx5_core_dev *mdev, bool *supported,
+ 			 bool *enabled);
+ 
++>>>>>>> 94cb1ebbafd5 (net/mlx5e: Add support for RXALL netdev feature)
  #endif /* __MLX5_PORT_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/port.c
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index d4e17c4128c4..4bad6315258b 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -110,6 +110,7 @@ enum {
 	MLX5_REG_PMPE		 = 0x5010,
 	MLX5_REG_PELC		 = 0x500e,
 	MLX5_REG_PVLC		 = 0x500f,
+	MLX5_REG_PCMR		 = 0x5041,
 	MLX5_REG_PMLP		 = 0, /* TBD */
 	MLX5_REG_NODE_DESC	 = 0x6001,
 	MLX5_REG_HOST_ENDIANNESS = 0x7004,
* Unmerged path include/linux/mlx5/port.h
