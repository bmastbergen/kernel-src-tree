vxlan: move IPv6 outpute route calculation to a function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit e5d4b29fe86a911f447d2f1e95383e04c7cfb465
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e5d4b29f.failed

Will be used also for ndo_fill_metadata_dst.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e5d4b29fe86a911f447d2f1e95383e04c7cfb465)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 4e5b7ab9acd0,5a38558da157..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1821,8 -1847,35 +1821,36 @@@ int vxlan_xmit_skb(struct rtable *rt, s
  				   ttl, df, src_port, dst_port, xnet,
  				   !(vxflags & VXLAN_F_UDP_CSUM));
  }
 +EXPORT_SYMBOL_GPL(vxlan_xmit_skb);
  
+ #if IS_ENABLED(CONFIG_IPV6)
+ static struct dst_entry *vxlan6_get_route(struct vxlan_dev *vxlan,
+ 					  struct sk_buff *skb, int oif,
+ 					  const struct in6_addr *daddr,
+ 					  struct in6_addr *saddr)
+ {
+ 	struct dst_entry *ndst;
+ 	struct flowi6 fl6;
+ 	int err;
+ 
+ 	memset(&fl6, 0, sizeof(fl6));
+ 	fl6.flowi6_oif = oif;
+ 	fl6.daddr = *daddr;
+ 	fl6.saddr = vxlan->cfg.saddr.sin6.sin6_addr;
+ 	fl6.flowi6_mark = skb->mark;
+ 	fl6.flowi6_proto = IPPROTO_UDP;
+ 
+ 	err = ipv6_stub->ipv6_dst_lookup(vxlan->net,
+ 					 vxlan->vn6_sock->sock->sk,
+ 					 &ndst, &fl6);
+ 	if (err < 0)
+ 		return ERR_PTR(err);
+ 
+ 	*saddr = fl6.saddr;
+ 	return ndst;
+ }
+ #endif
+ 
  /* Bypass encapsulation if the destination is local */
  static void vxlan_encap_bypass(struct sk_buff *skb, struct vxlan_dev *src_vxlan,
  			       struct vxlan_dev *dst_vxlan)
@@@ -1969,17 -2063,17 +1997,28 @@@ static void vxlan_xmit_one(struct sk_bu
  #if IS_ENABLED(CONFIG_IPV6)
  	} else {
  		struct dst_entry *ndst;
- 		struct flowi6 fl6;
+ 		struct in6_addr saddr;
  		u32 rt6i_flags;
  
++<<<<<<< HEAD
 +		memset(&fl6, 0, sizeof(fl6));
 +		fl6.flowi6_oif = rdst->remote_ifindex;
 +		fl6.daddr = dst->sin6.sin6_addr;
 +		fl6.saddr = vxlan->saddr.sin6.sin6_addr;
 +		fl6.flowi6_mark = skb->mark;
 +		fl6.flowi6_proto = IPPROTO_UDP;
 +
 +		if (ipv6_stub->ipv6_dst_lookup(sk, &ndst, &fl6)) {
++=======
+ 		if (!vxlan->vn6_sock)
+ 			goto drop;
+ 		sk = vxlan->vn6_sock->sock->sk;
+ 
+ 		ndst = vxlan6_get_route(vxlan, skb,
+ 					rdst ? rdst->remote_ifindex : 0,
+ 					&dst->sin6.sin6_addr, &saddr);
+ 		if (IS_ERR(ndst)) {
++>>>>>>> e5d4b29fe86a (vxlan: move IPv6 outpute route calculation to a function)
  			netdev_dbg(dev, "no route to %pI6\n",
  				   &dst->sin6.sin6_addr);
  			dev->stats.tx_carrier_errors++;
@@@ -2011,13 -2105,10 +2050,18 @@@
  		}
  
  		ttl = ttl ? : ip6_dst_hoplimit(ndst);
++<<<<<<< HEAD
 +		md.vni = htonl(vni << 8);
 +		md.gbp = skb->mark;
 +
 +		err = vxlan6_xmit_skb(ndst, sk, skb, dev, &fl6.saddr, &fl6.daddr,
 +				      0, ttl, src_port, dst_port, &md,
++=======
+ 		err = vxlan6_xmit_skb(ndst, sk, skb, dev, &saddr, &dst->sin6.sin6_addr,
+ 				      0, ttl, src_port, dst_port, htonl(vni << 8), md,
++>>>>>>> e5d4b29fe86a (vxlan: move IPv6 outpute route calculation to a function)
  				      !net_eq(vxlan->net, dev_net(vxlan->dev)),
 -				      flags);
 +				      vxlan->flags);
  #endif
  	}
  
* Unmerged path drivers/net/vxlan.c
