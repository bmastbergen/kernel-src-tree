mm, meminit: suppress unused memory variable warning

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mm] meminit: suppress unused memory variable warning (George Beshers) [727269]
Rebuild_FUZZ: 96.00%
commit-author Mel Gorman <mgorman@suse.de>
commit ae026b2aa19350f3c863df2dce7e0511dd78ff49
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ae026b2a.failed

The kbuild test robot reported the following

  tree:   git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git master
  head:   14a6f1989dae9445d4532941bdd6bbad84f4c8da
  commit: 3b242c66ccbd60cf47ab0e8992119d9617548c23 x86: mm: enable deferred struct page initialisation on x86-64
  date:   3 days ago
  config: x86_64-randconfig-x006-201527 (attached as .config)
  reproduce:
    git checkout 3b242c66ccbd60cf47ab0e8992119d9617548c23
    # save the attached .config to linux build tree
    make ARCH=x86_64

  All warnings (new ones prefixed by >>):

     mm/page_alloc.c: In function 'early_page_uninitialised':
  >> mm/page_alloc.c:247:6: warning: unused variable 'nid' [-Wunused-variable]
       int nid = early_pfn_to_nid(pfn);

It's due to the NODE_DATA macro ignoring the nid parameter on !NUMA
configurations.  This patch avoids the warning by not declaring nid.

	Signed-off-by: Mel Gorman <mgorman@suse.de>
	Reported-by: Wu Fengguang <fengguang.wu@intel.com>
	Cc: "Kirill A. Shutemov" <kirill@shutemov.name>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ae026b2aa19350f3c863df2dce7e0511dd78ff49)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_alloc.c
diff --cc mm/page_alloc.c
index 20d353397e7d,ac05e7ae399e..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -229,10 -237,79 +229,82 @@@ EXPORT_SYMBOL(nr_online_nodes)
  
  int page_group_by_mobility_disabled __read_mostly;
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT
+ static inline void reset_deferred_meminit(pg_data_t *pgdat)
+ {
+ 	pgdat->first_deferred_pfn = ULONG_MAX;
+ }
+ 
+ /* Returns true if the struct page for the pfn is uninitialised */
+ static inline bool __meminit early_page_uninitialised(unsigned long pfn)
+ {
+ 	if (pfn >= NODE_DATA(early_pfn_to_nid(pfn))->first_deferred_pfn)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static inline bool early_page_nid_uninitialised(unsigned long pfn, int nid)
+ {
+ 	if (pfn >= NODE_DATA(nid)->first_deferred_pfn)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ /*
+  * Returns false when the remaining initialisation should be deferred until
+  * later in the boot cycle when it can be parallelised.
+  */
+ static inline bool update_defer_init(pg_data_t *pgdat,
+ 				unsigned long pfn, unsigned long zone_end,
+ 				unsigned long *nr_initialised)
+ {
+ 	/* Always populate low zones for address-contrained allocations */
+ 	if (zone_end < pgdat_end_pfn(pgdat))
+ 		return true;
+ 
+ 	/* Initialise at least 2G of the highest zone */
+ 	(*nr_initialised)++;
+ 	if (*nr_initialised > (2UL << (30 - PAGE_SHIFT)) &&
+ 	    (pfn & (PAGES_PER_SECTION - 1)) == 0) {
+ 		pgdat->first_deferred_pfn = pfn;
+ 		return false;
+ 	}
+ 
+ 	return true;
+ }
+ #else
+ static inline void reset_deferred_meminit(pg_data_t *pgdat)
+ {
+ }
+ 
+ static inline bool early_page_uninitialised(unsigned long pfn)
+ {
+ 	return false;
+ }
+ 
+ static inline bool early_page_nid_uninitialised(unsigned long pfn, int nid)
+ {
+ 	return false;
+ }
+ 
+ static inline bool update_defer_init(pg_data_t *pgdat,
+ 				unsigned long pfn, unsigned long zone_end,
+ 				unsigned long *nr_initialised)
+ {
+ 	return true;
+ }
+ #endif
+ 
+ 
++>>>>>>> ae026b2aa193 (mm, meminit: suppress unused memory variable warning)
  void set_pageblock_migratetype(struct page *page, int migratetype)
  {
 -	if (unlikely(page_group_by_mobility_disabled &&
 -		     migratetype < MIGRATE_PCPTYPES))
 +
 +	if (unlikely(page_group_by_mobility_disabled))
  		migratetype = MIGRATE_UNMOVABLE;
  
  	set_pageblock_flags_group(page, (unsigned long)migratetype,
* Unmerged path mm/page_alloc.c
