kvm: x86: zero EFER on INIT

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 5690891bcec5fcfda38da974ffa5488e36a59811
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5690891b.failed

Not zeroing EFER means that a 32-bit firmware cannot enter paging mode
without clearing EFER.LME first (which it should not know about).
Yang Zhang from Intel confirmed that the manual is wrong and EFER is
cleared to zero on INIT.

Fixes: d28bc9dd25ce023270d2e039e7c98d38ecbf7758
	Cc: stable@vger.kernel.org
	Cc: Yang Z Zhang <yang.z.zhang@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 5690891bcec5fcfda38da974ffa5488e36a59811)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm.c
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/svm.c
index 6bde6308a751,f2c8e4917688..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -1205,6 -1208,12 +1205,15 @@@ static void svm_vcpu_reset(struct kvm_v
  	u32 dummy;
  	u32 eax = 1;
  
++<<<<<<< HEAD
++=======
+ 	if (!init_event) {
+ 		svm->vcpu.arch.apic_base = APIC_DEFAULT_PHYS_BASE |
+ 					   MSR_IA32_APICBASE_ENABLE;
+ 		if (kvm_vcpu_is_reset_bsp(&svm->vcpu))
+ 			svm->vcpu.arch.apic_base |= MSR_IA32_APICBASE_BSP;
+ 	}
++>>>>>>> 5690891bcec5 (kvm: x86: zero EFER on INIT)
  	init_vmcb(svm);
  
  	kvm_cpuid(vcpu, &eax, &dummy, &dummy, &dummy);
@@@ -1262,11 -1271,6 +1271,14 @@@ static struct kvm_vcpu *svm_create_vcpu
  	svm->vmcb_pa = page_to_pfn(page) << PAGE_SHIFT;
  	svm->asid_generation = 0;
  	init_vmcb(svm);
++<<<<<<< HEAD
 +
 +	svm->vcpu.arch.apic_base = APIC_DEFAULT_PHYS_BASE |
 +				   MSR_IA32_APICBASE_ENABLE;
 +	if (kvm_vcpu_is_reset_bsp(&svm->vcpu))
 +		svm->vcpu.arch.apic_base |= MSR_IA32_APICBASE_BSP;
++=======
++>>>>>>> 5690891bcec5 (kvm: x86: zero EFER on INIT)
  
  	svm_init_osvw(&svm->vcpu);
  
diff --cc arch/x86/kvm/vmx.c
index a58f09b8a8c8,4d0aa31a42ba..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -4545,14 -4928,15 +4545,24 @@@ static void vmx_vcpu_reset(struct kvm_v
  	if (vmx->vpid != 0)
  		vmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);
  
++<<<<<<< HEAD
 +	vmx->vcpu.arch.cr0 = X86_CR0_NW | X86_CR0_CD | X86_CR0_ET;
 +	vmx_set_cr0(&vmx->vcpu, kvm_read_cr0(vcpu)); /* enter rmode */
 +	vmx_set_cr4(&vmx->vcpu, 0);
 +	vmx_set_efer(&vmx->vcpu, 0);
 +	vmx_fpu_activate(&vmx->vcpu);
 +	update_exception_bitmap(&vmx->vcpu);
++=======
+ 	cr0 = X86_CR0_NW | X86_CR0_CD | X86_CR0_ET;
+ 	vmx_set_cr0(vcpu, cr0); /* enter rmode */
+ 	vmx->vcpu.arch.cr0 = cr0;
+ 	vmx_set_cr4(vcpu, 0);
+ 	vmx_set_efer(vcpu, 0);
+ 	vmx_fpu_activate(vcpu);
+ 	update_exception_bitmap(vcpu);
++>>>>>>> 5690891bcec5 (kvm: x86: zero EFER on INIT)
  
 -	vpid_sync_context(vmx->vpid);
 +	vpid_sync_context(vmx);
  }
  
  /*
* Unmerged path arch/x86/kvm/svm.c
* Unmerged path arch/x86/kvm/vmx.c
