xprtrdma: Remove unused LOCAL_INV recovery logic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 06b00880b0abd60c595088ae0bd7d210ee953f15
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/06b00880.failed

Clean up: Remove functions no longer used to recover broken FRMRs.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Reviewed-by: Steve Wise <swise@opengridcomputing.com>
	Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
	Reviewed-by: Devesh Sharma <devesh.sharma@avagotech.com>
Tested-By: Devesh Sharma <devesh.sharma@avagotech.com>
	Reviewed-by: Doug Ledford <dledford@redhat.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 06b00880b0abd60c595088ae0bd7d210ee953f15)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/verbs.c
diff --cc net/sunrpc/xprtrdma/verbs.c
index a035813686ee,a891cf769199..000000000000
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@@ -1243,110 -1215,6 +1216,113 @@@ rpcrdma_buffer_put_sendbuf(struct rpcrd
  	}
  }
  
++<<<<<<< HEAD
 +/* rpcrdma_unmap_one() was already done during deregistration.
 + * Redo only the ib_post_send().
 + */
 +static void
 +rpcrdma_retry_local_inv(struct rpcrdma_mw *r, struct rpcrdma_ia *ia)
 +{
 +	struct rpcrdma_xprt *r_xprt =
 +				container_of(ia, struct rpcrdma_xprt, rx_ia);
 +	struct ib_send_wr invalidate_wr, *bad_wr;
 +	int rc;
 +
 +	dprintk("RPC:       %s: FRMR %p is stale\n", __func__, r);
 +
 +	/* When this FRMR is re-inserted into rb_mws, it is no longer stale */
 +	r->r.frmr.fr_state = FRMR_IS_INVALID;
 +
 +	memset(&invalidate_wr, 0, sizeof(invalidate_wr));
 +	invalidate_wr.wr_id = (unsigned long)(void *)r;
 +	invalidate_wr.opcode = IB_WR_LOCAL_INV;
 +	invalidate_wr.ex.invalidate_rkey = r->r.frmr.fr_mr->rkey;
 +	DECR_CQCOUNT(&r_xprt->rx_ep);
 +
 +	dprintk("RPC:       %s: frmr %p invalidating rkey %08x\n",
 +		__func__, r, r->r.frmr.fr_mr->rkey);
 +
 +	read_lock(&ia->ri_qplock);
 +	rc = ib_post_send(ia->ri_id->qp, &invalidate_wr, &bad_wr);
 +	read_unlock(&ia->ri_qplock);
 +	if (rc) {
 +		/* Force rpcrdma_buffer_get() to retry */
 +		r->r.frmr.fr_state = FRMR_IS_STALE;
 +		dprintk("RPC:       %s: ib_post_send failed, %i\n",
 +			__func__, rc);
 +	}
 +}
 +
 +static void
 +rpcrdma_retry_flushed_linv(struct list_head *stale,
 +			   struct rpcrdma_buffer *buf)
 +{
 +	struct rpcrdma_ia *ia = rdmab_to_ia(buf);
 +	struct list_head *pos;
 +	struct rpcrdma_mw *r;
 +	unsigned long flags;
 +
 +	list_for_each(pos, stale) {
 +		r = list_entry(pos, struct rpcrdma_mw, mw_list);
 +		rpcrdma_retry_local_inv(r, ia);
 +	}
 +
 +	spin_lock_irqsave(&buf->rb_lock, flags);
 +	list_splice_tail(stale, &buf->rb_mws);
 +	spin_unlock_irqrestore(&buf->rb_lock, flags);
 +}
 +
 +static struct rpcrdma_req *
 +rpcrdma_buffer_get_frmrs(struct rpcrdma_req *req, struct rpcrdma_buffer *buf,
 +			 struct list_head *stale)
 +{
 +	struct rpcrdma_mw *r;
 +	int i;
 +
 +	i = RPCRDMA_MAX_SEGS - 1;
 +	while (!list_empty(&buf->rb_mws)) {
 +		r = list_entry(buf->rb_mws.next,
 +			       struct rpcrdma_mw, mw_list);
 +		list_del(&r->mw_list);
 +		if (r->r.frmr.fr_state == FRMR_IS_STALE) {
 +			list_add(&r->mw_list, stale);
 +			continue;
 +		}
 +		req->rl_segments[i].rl_mw = r;
 +		if (unlikely(i-- == 0))
 +			return req;	/* Success */
 +	}
 +
 +	/* Not enough entries on rb_mws for this req */
 +	rpcrdma_buffer_put_sendbuf(req, buf);
 +	rpcrdma_buffer_put_mrs(req, buf);
 +	return NULL;
 +}
 +
 +static struct rpcrdma_req *
 +rpcrdma_buffer_get_fmrs(struct rpcrdma_req *req, struct rpcrdma_buffer *buf)
 +{
 +	struct rpcrdma_mw *r;
 +	int i;
 +
 +	i = RPCRDMA_MAX_SEGS - 1;
 +	while (!list_empty(&buf->rb_mws)) {
 +		r = list_entry(buf->rb_mws.next,
 +			       struct rpcrdma_mw, mw_list);
 +		list_del(&r->mw_list);
 +		req->rl_segments[i].rl_mw = r;
 +		if (unlikely(i-- == 0))
 +			return req;	/* Success */
 +	}
 +
 +	/* Not enough entries on rb_mws for this req */
 +	rpcrdma_buffer_put_sendbuf(req, buf);
 +	rpcrdma_buffer_put_mrs(req, buf);
 +	return NULL;
 +}
 +
++=======
++>>>>>>> 06b00880b0ab (xprtrdma: Remove unused LOCAL_INV recovery logic)
  /*
   * Get a set of request/reply buffers.
   *
* Unmerged path net/sunrpc/xprtrdma/verbs.c
