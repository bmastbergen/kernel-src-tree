net/mlx5e: Add ethtool support for interface identify (LED blinking)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [include] mlx5e: Add ethtool support for interface identify (LED blinking) (kamal heib) [1275159 1296272 1296405 1298421 1298422 1298423 1298424 1298425]
Rebuild_FUZZ: 96.97%
commit-author Gal Pressman <galp@mellanox.com>
commit da54d24ec3ef736de04c61a01653776a9750334f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/da54d24e.failed

Add the needed hardware command and mlx5_ifc structs for managing LED
control.
Add set_phys_id ethtool callback to support ethtool -p flag.

	Signed-off-by: Gal Pressman <galp@mellanox.com>
	Signed-off-by: Eugenia Emantayev <eugenia@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit da54d24ec3ef736de04c61a01653776a9750334f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index 72a2892f3570,a2c444ec191b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -858,6 -983,182 +858,185 @@@ static int mlx5e_set_pauseparam(struct 
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int mlx5e_get_ts_info(struct net_device *dev,
+ 			     struct ethtool_ts_info *info)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 	int ret;
+ 
+ 	ret = ethtool_op_get_ts_info(dev, info);
+ 	if (ret)
+ 		return ret;
+ 
+ 	info->phc_index = priv->tstamp.ptp ?
+ 			  ptp_clock_index(priv->tstamp.ptp) : -1;
+ 
+ 	if (!MLX5_CAP_GEN(priv->mdev, device_frequency_khz))
+ 		return 0;
+ 
+ 	info->so_timestamping |= SOF_TIMESTAMPING_TX_HARDWARE |
+ 				 SOF_TIMESTAMPING_RX_HARDWARE |
+ 				 SOF_TIMESTAMPING_RAW_HARDWARE;
+ 
+ 	info->tx_types = (BIT(1) << HWTSTAMP_TX_OFF) |
+ 			 (BIT(1) << HWTSTAMP_TX_ON);
+ 
+ 	info->rx_filters = (BIT(1) << HWTSTAMP_FILTER_NONE) |
+ 			   (BIT(1) << HWTSTAMP_FILTER_ALL);
+ 
+ 	return 0;
+ }
+ 
+ static __u32 mlx5e_get_wol_supported(struct mlx5_core_dev *mdev)
+ {
+ 	__u32 ret = 0;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_g))
+ 		ret |= WAKE_MAGIC;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_s))
+ 		ret |= WAKE_MAGICSECURE;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_a))
+ 		ret |= WAKE_ARP;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_b))
+ 		ret |= WAKE_BCAST;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_m))
+ 		ret |= WAKE_MCAST;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_u))
+ 		ret |= WAKE_UCAST;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_p))
+ 		ret |= WAKE_PHY;
+ 
+ 	return ret;
+ }
+ 
+ static __u32 mlx5e_refomrat_wol_mode_mlx5_to_linux(u8 mode)
+ {
+ 	__u32 ret = 0;
+ 
+ 	if (mode & MLX5_WOL_MAGIC)
+ 		ret |= WAKE_MAGIC;
+ 
+ 	if (mode & MLX5_WOL_SECURED_MAGIC)
+ 		ret |= WAKE_MAGICSECURE;
+ 
+ 	if (mode & MLX5_WOL_ARP)
+ 		ret |= WAKE_ARP;
+ 
+ 	if (mode & MLX5_WOL_BROADCAST)
+ 		ret |= WAKE_BCAST;
+ 
+ 	if (mode & MLX5_WOL_MULTICAST)
+ 		ret |= WAKE_MCAST;
+ 
+ 	if (mode & MLX5_WOL_UNICAST)
+ 		ret |= WAKE_UCAST;
+ 
+ 	if (mode & MLX5_WOL_PHY_ACTIVITY)
+ 		ret |= WAKE_PHY;
+ 
+ 	return ret;
+ }
+ 
+ static u8 mlx5e_refomrat_wol_mode_linux_to_mlx5(__u32 mode)
+ {
+ 	u8 ret = 0;
+ 
+ 	if (mode & WAKE_MAGIC)
+ 		ret |= MLX5_WOL_MAGIC;
+ 
+ 	if (mode & WAKE_MAGICSECURE)
+ 		ret |= MLX5_WOL_SECURED_MAGIC;
+ 
+ 	if (mode & WAKE_ARP)
+ 		ret |= MLX5_WOL_ARP;
+ 
+ 	if (mode & WAKE_BCAST)
+ 		ret |= MLX5_WOL_BROADCAST;
+ 
+ 	if (mode & WAKE_MCAST)
+ 		ret |= MLX5_WOL_MULTICAST;
+ 
+ 	if (mode & WAKE_UCAST)
+ 		ret |= MLX5_WOL_UNICAST;
+ 
+ 	if (mode & WAKE_PHY)
+ 		ret |= MLX5_WOL_PHY_ACTIVITY;
+ 
+ 	return ret;
+ }
+ 
+ static void mlx5e_get_wol(struct net_device *netdev,
+ 			  struct ethtool_wolinfo *wol)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	u8 mlx5_wol_mode;
+ 	int err;
+ 
+ 	memset(wol, 0, sizeof(*wol));
+ 
+ 	wol->supported = mlx5e_get_wol_supported(mdev);
+ 	if (!wol->supported)
+ 		return;
+ 
+ 	err = mlx5_query_port_wol(mdev, &mlx5_wol_mode);
+ 	if (err)
+ 		return;
+ 
+ 	wol->wolopts = mlx5e_refomrat_wol_mode_mlx5_to_linux(mlx5_wol_mode);
+ }
+ 
+ static int mlx5e_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	__u32 wol_supported = mlx5e_get_wol_supported(mdev);
+ 	u32 mlx5_wol_mode;
+ 
+ 	if (!wol_supported)
+ 		return -ENOTSUPP;
+ 
+ 	if (wol->wolopts & ~wol_supported)
+ 		return -EINVAL;
+ 
+ 	mlx5_wol_mode = mlx5e_refomrat_wol_mode_linux_to_mlx5(wol->wolopts);
+ 
+ 	return mlx5_set_port_wol(mdev, mlx5_wol_mode);
+ }
+ 
+ static int mlx5e_set_phys_id(struct net_device *dev,
+ 			     enum ethtool_phys_id_state state)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	u16 beacon_duration;
+ 
+ 	if (!MLX5_CAP_GEN(mdev, beacon_led))
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (state) {
+ 	case ETHTOOL_ID_ACTIVE:
+ 		beacon_duration = MLX5_BEACON_DURATION_INF;
+ 		break;
+ 	case ETHTOOL_ID_INACTIVE:
+ 		beacon_duration = MLX5_BEACON_DURATION_OFF;
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return mlx5_set_port_beacon(mdev, beacon_duration);
+ }
+ 
++>>>>>>> da54d24ec3ef (net/mlx5e: Add ethtool support for interface identify (LED blinking))
  const struct ethtool_ops mlx5e_ethtool_ops = {
  	.get_drvinfo       = mlx5e_get_drvinfo,
  	.get_link          = ethtool_op_get_link,
@@@ -881,4 -1182,8 +1060,11 @@@
  	.set_tunable       = mlx5e_set_tunable,
  	.get_pauseparam    = mlx5e_get_pauseparam,
  	.set_pauseparam    = mlx5e_set_pauseparam,
++<<<<<<< HEAD
++=======
+ 	.get_ts_info       = mlx5e_get_ts_info,
+ 	.set_phys_id       = mlx5e_set_phys_id,
+ 	.get_wol	   = mlx5e_get_wol,
+ 	.set_wol	   = mlx5e_set_wol,
++>>>>>>> da54d24ec3ef (net/mlx5e: Add ethtool support for interface identify (LED blinking))
  };
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/port.c b/drivers/net/ethernet/mellanox/mlx5/core/port.c
index ed339867cddb..142d2f5c8c53 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/port.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/port.c
@@ -115,6 +115,19 @@ int mlx5_query_port_ptys(struct mlx5_core_dev *dev, u32 *ptys,
 }
 EXPORT_SYMBOL_GPL(mlx5_query_port_ptys);
 
+int mlx5_set_port_beacon(struct mlx5_core_dev *dev, u16 beacon_duration)
+{
+	u32 out[MLX5_ST_SZ_DW(mlcr_reg)];
+	u32 in[MLX5_ST_SZ_DW(mlcr_reg)];
+
+	memset(in, 0, sizeof(in));
+	MLX5_SET(mlcr_reg, in, local_port, 1);
+	MLX5_SET(mlcr_reg, in, beacon_duration, beacon_duration);
+
+	return mlx5_core_access_reg(dev, in, sizeof(in), out,
+				    sizeof(out), MLX5_REG_MLCR, 0, 1);
+}
+
 int mlx5_query_port_proto_cap(struct mlx5_core_dev *dev,
 			      u32 *proto_cap, int proto_mask)
 {
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index d4e17c4128c4..476acec24701 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -113,6 +113,7 @@ enum {
 	MLX5_REG_PMLP		 = 0, /* TBD */
 	MLX5_REG_NODE_DESC	 = 0x6001,
 	MLX5_REG_HOST_ENDIANNESS = 0x7004,
+	MLX5_REG_MLCR		 = 0x902b,
 };
 
 enum {
diff --git a/include/linux/mlx5/port.h b/include/linux/mlx5/port.h
index 66ed80185fae..f513d0c7f5c3 100644
--- a/include/linux/mlx5/port.h
+++ b/include/linux/mlx5/port.h
@@ -35,6 +35,11 @@
 
 #include <linux/mlx5/driver.h>
 
+enum mlx5_beacon_duration {
+	MLX5_BEACON_DURATION_OFF = 0x0,
+	MLX5_BEACON_DURATION_INF = 0xffff,
+};
+
 int mlx5_set_port_caps(struct mlx5_core_dev *dev, u8 port_num, u32 caps);
 int mlx5_query_port_ptys(struct mlx5_core_dev *dev, u32 *ptys,
 			 int ptys_size, int proto_mask, u8 local_port);
@@ -53,6 +58,7 @@ int mlx5_set_port_admin_status(struct mlx5_core_dev *dev,
 			       enum mlx5_port_status status);
 int mlx5_query_port_admin_status(struct mlx5_core_dev *dev,
 				 enum mlx5_port_status *status);
+int mlx5_set_port_beacon(struct mlx5_core_dev *dev, u16 beacon_duration);
 
 int mlx5_set_port_mtu(struct mlx5_core_dev *dev, u16 mtu, u8 port);
 void mlx5_query_port_max_mtu(struct mlx5_core_dev *dev, u16 *max_mtu, u8 port);
