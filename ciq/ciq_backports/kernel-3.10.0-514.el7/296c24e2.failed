xfs: wire up Q_XGETNEXTQUOTA / get_nextdqblk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Eric Sandeen <sandeen@sandeen.net>
commit 296c24e26ee3af2dbfecb482e6bc9560bd34c455
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/296c24e2.failed

Add code to allow the Q_XGETNEXTQUOTA quotactl to quickly find
all active quotas by examining the quota inode, and skipping
over unallocated or uninitialized regions.

Userspace can then use this interface rather than i.e. a
getpwent() loop when asked to report all active quotas.

	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 296c24e26ee3af2dbfecb482e6bc9560bd34c455)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_qm.h
#	fs/xfs/xfs_qm_syscalls.c
#	fs/xfs/xfs_quotaops.c
diff --cc fs/xfs/xfs_qm.h
index 7c9eec96746d,c68a38f528ba..000000000000
--- a/fs/xfs/xfs_qm.h
+++ b/fs/xfs/xfs_qm.h
@@@ -166,14 -164,10 +166,19 @@@ extern void		xfs_qm_dqrele_all_inodes(s
  
  /* quota ops */
  extern int		xfs_qm_scall_trunc_qfiles(struct xfs_mount *, uint);
++<<<<<<< HEAD
 +extern int		xfs_qm_scall_getquota(struct xfs_mount *, xfs_dqid_t,
 +					uint, struct fs_disk_quota *);
++=======
+ extern int		xfs_qm_scall_getquota(struct xfs_mount *, xfs_dqid_t *,
+ 					uint, struct qc_dqblk *, uint);
++>>>>>>> 296c24e26ee3 (xfs: wire up Q_XGETNEXTQUOTA / get_nextdqblk)
  extern int		xfs_qm_scall_setqlim(struct xfs_mount *, xfs_dqid_t, uint,
 -					struct qc_dqblk *);
 +					struct fs_disk_quota *);
 +extern int		xfs_qm_scall_getqstat(struct xfs_mount *,
 +					struct fs_quota_stat *);
 +extern int		xfs_qm_scall_getqstatv(struct xfs_mount *,
 +					struct fs_quota_statv *);
  extern int		xfs_qm_scall_quotaon(struct xfs_mount *, uint);
  extern int		xfs_qm_scall_quotaoff(struct xfs_mount *, uint);
  
diff --cc fs/xfs/xfs_qm_syscalls.c
index 784c41b3ad84,0a252863f82b..000000000000
--- a/fs/xfs/xfs_qm_syscalls.c
+++ b/fs/xfs/xfs_qm_syscalls.c
@@@ -792,9 -635,10 +792,14 @@@ out
  int
  xfs_qm_scall_getquota(
  	struct xfs_mount	*mp,
- 	xfs_dqid_t		id,
+ 	xfs_dqid_t		*id,
  	uint			type,
++<<<<<<< HEAD
 +	struct fs_disk_quota	*dst)
++=======
+ 	struct qc_dqblk		*dst,
+ 	uint			dqget_flags)
++>>>>>>> 296c24e26ee3 (xfs: wire up Q_XGETNEXTQUOTA / get_nextdqblk)
  {
  	struct xfs_dquot	*dqp;
  	int			error;
@@@ -817,29 -661,29 +822,32 @@@
  		goto out_put;
  	}
  
+ 	/* Fill in the ID we actually read from disk */
+ 	*id = be32_to_cpu(dqp->q_core.d_id);
+ 
  	memset(dst, 0, sizeof(*dst));
 -	dst->d_spc_hardlimit =
 -		XFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_blk_hardlimit));
 -	dst->d_spc_softlimit =
 -		XFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_blk_softlimit));
 +	dst->d_version = FS_DQUOT_VERSION;
 +	dst->d_flags = xfs_qm_export_qtype_flags(dqp->q_core.d_flags);
 +	dst->d_id = be32_to_cpu(dqp->q_core.d_id);
 +	dst->d_blk_hardlimit =
 +		XFS_FSB_TO_BB(mp, be64_to_cpu(dqp->q_core.d_blk_hardlimit));
 +	dst->d_blk_softlimit =
 +		XFS_FSB_TO_BB(mp, be64_to_cpu(dqp->q_core.d_blk_softlimit));
  	dst->d_ino_hardlimit = be64_to_cpu(dqp->q_core.d_ino_hardlimit);
  	dst->d_ino_softlimit = be64_to_cpu(dqp->q_core.d_ino_softlimit);
 -	dst->d_space = XFS_FSB_TO_B(mp, dqp->q_res_bcount);
 -	dst->d_ino_count = dqp->q_res_icount;
 -	dst->d_spc_timer = be32_to_cpu(dqp->q_core.d_btimer);
 -	dst->d_ino_timer = be32_to_cpu(dqp->q_core.d_itimer);
 -	dst->d_ino_warns = be16_to_cpu(dqp->q_core.d_iwarns);
 -	dst->d_spc_warns = be16_to_cpu(dqp->q_core.d_bwarns);
 -	dst->d_rt_spc_hardlimit =
 -		XFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_rtb_hardlimit));
 -	dst->d_rt_spc_softlimit =
 -		XFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_rtb_softlimit));
 -	dst->d_rt_space = XFS_FSB_TO_B(mp, dqp->q_res_rtbcount);
 -	dst->d_rt_spc_timer = be32_to_cpu(dqp->q_core.d_rtbtimer);
 -	dst->d_rt_spc_warns = be16_to_cpu(dqp->q_core.d_rtbwarns);
 +	dst->d_bcount = XFS_FSB_TO_BB(mp, dqp->q_res_bcount);
 +	dst->d_icount = dqp->q_res_icount;
 +	dst->d_btimer = be32_to_cpu(dqp->q_core.d_btimer);
 +	dst->d_itimer = be32_to_cpu(dqp->q_core.d_itimer);
 +	dst->d_iwarns = be16_to_cpu(dqp->q_core.d_iwarns);
 +	dst->d_bwarns = be16_to_cpu(dqp->q_core.d_bwarns);
 +	dst->d_rtb_hardlimit =
 +		XFS_FSB_TO_BB(mp, be64_to_cpu(dqp->q_core.d_rtb_hardlimit));
 +	dst->d_rtb_softlimit =
 +		XFS_FSB_TO_BB(mp, be64_to_cpu(dqp->q_core.d_rtb_softlimit));
 +	dst->d_rtbcount = XFS_FSB_TO_BB(mp, dqp->q_res_rtbcount);
 +	dst->d_rtbtimer = be32_to_cpu(dqp->q_core.d_rtbtimer);
 +	dst->d_rtbwarns = be16_to_cpu(dqp->q_core.d_rtbwarns);
  
  	/*
  	 * Internally, we don't reset all the timers when quota enforcement
@@@ -858,17 -702,17 +866,27 @@@
  	}
  
  #ifdef DEBUG
++<<<<<<< HEAD
 +	if (((XFS_IS_UQUOTA_ENFORCED(mp) && dst->d_flags == FS_USER_QUOTA) ||
 +	     (XFS_IS_GQUOTA_ENFORCED(mp) && dst->d_flags == FS_GROUP_QUOTA) ||
 +	     (XFS_IS_PQUOTA_ENFORCED(mp) && dst->d_flags == FS_PROJ_QUOTA)) &&
 +	    dst->d_id != 0) {
 +		if ((dst->d_bcount > dst->d_blk_softlimit) &&
 +		    (dst->d_blk_softlimit > 0)) {
 +			ASSERT(dst->d_btimer != 0);
++=======
+ 	if (((XFS_IS_UQUOTA_ENFORCED(mp) && type == XFS_DQ_USER) ||
+ 	     (XFS_IS_GQUOTA_ENFORCED(mp) && type == XFS_DQ_GROUP) ||
+ 	     (XFS_IS_PQUOTA_ENFORCED(mp) && type == XFS_DQ_PROJ)) &&
+ 	    *id != 0) {
+ 		if ((dst->d_space > dst->d_spc_softlimit) &&
+ 		    (dst->d_spc_softlimit > 0)) {
+ 			ASSERT(dst->d_spc_timer != 0);
++>>>>>>> 296c24e26ee3 (xfs: wire up Q_XGETNEXTQUOTA / get_nextdqblk)
  		}
 -		if ((dst->d_ino_count > dst->d_ino_softlimit) &&
 +		if ((dst->d_icount > dst->d_ino_softlimit) &&
  		    (dst->d_ino_softlimit > 0)) {
 -			ASSERT(dst->d_ino_timer != 0);
 +			ASSERT(dst->d_itimer != 0);
  		}
  	}
  #endif
diff --cc fs/xfs/xfs_quotaops.c
index 8fcd20dbf89a,f82d79a8c694..000000000000
--- a/fs/xfs/xfs_quotaops.c
+++ b/fs/xfs/xfs_quotaops.c
@@@ -131,17 -228,48 +131,53 @@@ STATIC in
  xfs_fs_get_dqblk(
  	struct super_block	*sb,
  	struct kqid		qid,
 -	struct qc_dqblk		*qdq)
 +	struct fs_disk_quota	*fdq)
  {
  	struct xfs_mount	*mp = XFS_M(sb);
+ 	xfs_dqid_t		id;
  
  	if (!XFS_IS_QUOTA_RUNNING(mp))
  		return -ENOSYS;
  	if (!XFS_IS_QUOTA_ON(mp))
  		return -ESRCH;
  
++<<<<<<< HEAD
 +	return xfs_qm_scall_getquota(mp, from_kqid(&init_user_ns, qid),
 +				      xfs_quota_type(qid.type), fdq);
++=======
+ 	id = from_kqid(&init_user_ns, qid);
+ 	return xfs_qm_scall_getquota(mp, &id,
+ 				      xfs_quota_type(qid.type), qdq, 0);
+ }
+ 
+ /* Return quota info for active quota >= this qid */
+ STATIC int
+ xfs_fs_get_nextdqblk(
+ 	struct super_block	*sb,
+ 	struct kqid		*qid,
+ 	struct qc_dqblk		*qdq)
+ {
+ 	int			ret;
+ 	struct xfs_mount	*mp = XFS_M(sb);
+ 	xfs_dqid_t		id;
+ 
+ 	if (!XFS_IS_QUOTA_RUNNING(mp))
+ 		return -ENOSYS;
+ 	if (!XFS_IS_QUOTA_ON(mp))
+ 		return -ESRCH;
+ 
+ 	id = from_kqid(&init_user_ns, *qid);
+ 	ret = xfs_qm_scall_getquota(mp, &id,
+ 				    xfs_quota_type(qid->type), qdq,
+ 				    XFS_QMOPT_DQNEXT);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* ID may be different, so convert back what we got */
+ 	*qid = make_kqid(current_user_ns(), qid->type, id);
+ 	return 0;
+ 	
++>>>>>>> 296c24e26ee3 (xfs: wire up Q_XGETNEXTQUOTA / get_nextdqblk)
  }
  
  STATIC int
@@@ -164,10 -292,12 +200,11 @@@ xfs_fs_set_dqblk
  }
  
  const struct quotactl_ops xfs_quotactl_operations = {
 -	.get_state		= xfs_fs_get_quota_state,
 -	.set_info		= xfs_fs_set_info,
 -	.quota_enable		= xfs_quota_enable,
 -	.quota_disable		= xfs_quota_disable,
 +	.get_xstatev		= xfs_fs_get_xstatev,
 +	.get_xstate		= xfs_fs_get_xstate,
 +	.set_xstate		= xfs_fs_set_xstate,
  	.rm_xquota		= xfs_fs_rm_xquota,
  	.get_dqblk		= xfs_fs_get_dqblk,
+ 	.get_nextdqblk		= xfs_fs_get_nextdqblk,
  	.set_dqblk		= xfs_fs_set_dqblk,
  };
diff --git a/fs/xfs/libxfs/xfs_quota_defs.h b/fs/xfs/libxfs/xfs_quota_defs.h
index 1b0a08379759..428d88207887 100644
--- a/fs/xfs/libxfs/xfs_quota_defs.h
+++ b/fs/xfs/libxfs/xfs_quota_defs.h
@@ -37,7 +37,7 @@ typedef __uint16_t	xfs_qwarncnt_t;
 #define XFS_DQ_PROJ		0x0002		/* project quota */
 #define XFS_DQ_GROUP		0x0004		/* a group quota */
 #define XFS_DQ_DIRTY		0x0008		/* dquot is dirty */
-#define XFS_DQ_FREEING		0x0010		/* dquot is beeing torn down */
+#define XFS_DQ_FREEING		0x0010		/* dquot is being torn down */
 
 #define XFS_DQ_ALLTYPES		(XFS_DQ_USER|XFS_DQ_PROJ|XFS_DQ_GROUP)
 
@@ -116,6 +116,7 @@ typedef __uint16_t	xfs_qwarncnt_t;
 #define XFS_QMOPT_DQREPAIR	0x0001000 /* repair dquot if damaged */
 #define XFS_QMOPT_GQUOTA	0x0002000 /* group dquot requested */
 #define XFS_QMOPT_ENOSPC	0x0004000 /* enospc instead of edquot (prj) */
+#define XFS_QMOPT_DQNEXT	0x0008000 /* return next dquot >= this ID */
 
 /*
  * flags to xfs_trans_mod_dquot to indicate which field needs to be
diff --git a/fs/xfs/xfs_dquot.c b/fs/xfs/xfs_dquot.c
index be09cd6e2e23..e9e347d8029d 100644
--- a/fs/xfs/xfs_dquot.c
+++ b/fs/xfs/xfs_dquot.c
@@ -688,6 +688,56 @@ error0:
 	return error;
 }
 
+/*
+ * Advance to the next id in the current chunk, or if at the
+ * end of the chunk, skip ahead to first id in next allocated chunk
+ * using the SEEK_DATA interface.
+ */
+int
+xfs_dq_get_next_id(
+	xfs_mount_t		*mp,
+	uint			type,
+	xfs_dqid_t		*id,
+	loff_t			eof)
+{
+	struct xfs_inode	*quotip;
+	xfs_fsblock_t		start;
+	loff_t			offset;
+	uint			lock;
+	xfs_dqid_t		next_id;
+	int			error = 0;
+
+	/* Simple advance */
+	next_id = *id + 1;
+
+	/* If new ID is within the current chunk, advancing it sufficed */
+	if (next_id % mp->m_quotainfo->qi_dqperchunk) {
+		*id = next_id;
+		return 0;
+	}
+
+	/* Nope, next_id is now past the current chunk, so find the next one */
+	start = (xfs_fsblock_t)next_id / mp->m_quotainfo->qi_dqperchunk;
+
+	quotip = xfs_quota_inode(mp, type);
+	lock = xfs_ilock_data_map_shared(quotip);
+
+	offset = __xfs_seek_hole_data(VFS_I(quotip), XFS_FSB_TO_B(mp, start),
+				      eof, SEEK_DATA);
+	if (offset < 0)
+		error = offset;
+
+	xfs_iunlock(quotip, lock);
+
+	/* -ENXIO is essentially "no more data" */
+	if (error)
+		return (error == -ENXIO ? -ENOENT: error);
+
+	/* Convert next data offset back to a quota id */
+	*id = XFS_B_TO_FSB(mp, offset) * mp->m_quotainfo->qi_dqperchunk;
+	return 0;
+}
+
 /*
  * Given the file system, inode OR id, and type (UDQUOT/GDQUOT), return a
  * a locked dquot, doing an allocation (if requested) as needed.
@@ -708,6 +758,7 @@ xfs_qm_dqget(
 	struct xfs_quotainfo	*qi = mp->m_quotainfo;
 	struct radix_tree_root *tree = xfs_dquot_tree(qi, type);
 	struct xfs_dquot	*dqp;
+	loff_t			eof = 0;
 	int			error;
 
 	ASSERT(XFS_IS_QUOTA_RUNNING(mp));
@@ -735,6 +786,21 @@ xfs_qm_dqget(
 	}
 #endif
 
+	/* Get the end of the quota file if we need it */
+	if (flags & XFS_QMOPT_DQNEXT) {
+		struct xfs_inode	*quotip;
+		xfs_fileoff_t		last;
+		uint			lock_mode;
+
+		quotip = xfs_quota_inode(mp, type);
+		lock_mode = xfs_ilock_data_map_shared(quotip);
+		error = xfs_bmap_last_offset(quotip, &last, XFS_DATA_FORK);
+		xfs_iunlock(quotip, lock_mode);
+		if (error)
+			return error;
+		eof = XFS_FSB_TO_B(mp, last);
+	}
+
 restart:
 	mutex_lock(&qi->qi_tree_lock);
 	dqp = radix_tree_lookup(tree, id);
@@ -748,6 +814,18 @@ restart:
 			goto restart;
 		}
 
+		/* uninit / unused quota found in radix tree, keep looking  */
+		if (flags & XFS_QMOPT_DQNEXT) {
+			if (XFS_IS_DQUOT_UNINITIALIZED(dqp)) {
+				xfs_dqunlock(dqp);
+				mutex_unlock(&qi->qi_tree_lock);
+				error = xfs_dq_get_next_id(mp, type, &id, eof);
+				if (error)
+					return error;
+				goto restart;
+			}
+		}
+
 		dqp->q_nrefs++;
 		mutex_unlock(&qi->qi_tree_lock);
 
@@ -774,6 +852,13 @@ restart:
 	if (ip)
 		xfs_ilock(ip, XFS_ILOCK_EXCL);
 
+	/* If we are asked to find next active id, keep looking */
+	if (error == -ENOENT && (flags & XFS_QMOPT_DQNEXT)) {
+		error = xfs_dq_get_next_id(mp, type, &id, eof);
+		if (!error)
+			goto restart;
+	}
+
 	if (error)
 		return error;
 
@@ -824,6 +909,17 @@ restart:
 	qi->qi_dquots++;
 	mutex_unlock(&qi->qi_tree_lock);
 
+	/* If we are asked to find next active id, keep looking */
+	if (flags & XFS_QMOPT_DQNEXT) {
+		if (XFS_IS_DQUOT_UNINITIALIZED(dqp)) {
+			xfs_qm_dqput(dqp);
+			error = xfs_dq_get_next_id(mp, type, &id, eof);
+			if (error)
+				return error;
+			goto restart;
+		}
+	}
+
  dqret:
 	ASSERT((ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL));
 	trace_xfs_dqget_miss(dqp);
* Unmerged path fs/xfs/xfs_qm.h
* Unmerged path fs/xfs/xfs_qm_syscalls.c
* Unmerged path fs/xfs/xfs_quotaops.c
