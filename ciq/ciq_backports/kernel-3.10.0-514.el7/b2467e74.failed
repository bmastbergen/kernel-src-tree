KVM: nVMX: remove incorrect vpid check in nested invvpid emulation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Haozhong Zhang <haozhong.zhang@intel.com>
commit b2467e744f89fcb2e723143c2b78bcbaf391828a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b2467e74.failed

This patch removes the vpid check when emulating nested invvpid
instruction of type all-contexts invalidation. The existing code is
incorrect because:
 (1) According to Intel SDM Vol 3, Section "INVVPID - Invalidate
     Translations Based on VPID", invvpid instruction does not check
     vpid in the invvpid descriptor when its type is all-contexts
     invalidation.
 (2) According to the same document, invvpid of type all-contexts
     invalidation does not require there is an active VMCS, so/and
     get_vmcs12() in the existing code may result in a NULL-pointer
     dereference. In practice, it can crash both KVM itself and L1
     hypervisors that use invvpid (e.g. Xen).

	Signed-off-by: Haozhong Zhang <haozhong.zhang@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit b2467e744f89fcb2e723143c2b78bcbaf391828a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index dd100a1ff95e,af823a388c19..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -6966,7 -7352,58 +6966,62 @@@ static int handle_invept(struct kvm_vcp
  
  static int handle_invvpid(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	kvm_queue_exception(vcpu, UD_VECTOR);
++=======
+ 	struct vcpu_vmx *vmx = to_vmx(vcpu);
+ 	u32 vmx_instruction_info;
+ 	unsigned long type, types;
+ 	gva_t gva;
+ 	struct x86_exception e;
+ 	int vpid;
+ 
+ 	if (!(vmx->nested.nested_vmx_secondary_ctls_high &
+ 	      SECONDARY_EXEC_ENABLE_VPID) ||
+ 			!(vmx->nested.nested_vmx_vpid_caps & VMX_VPID_INVVPID_BIT)) {
+ 		kvm_queue_exception(vcpu, UD_VECTOR);
+ 		return 1;
+ 	}
+ 
+ 	if (!nested_vmx_check_permission(vcpu))
+ 		return 1;
+ 
+ 	vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);
+ 	type = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);
+ 
+ 	types = (vmx->nested.nested_vmx_vpid_caps >> 8) & 0x7;
+ 
+ 	if (!(types & (1UL << type))) {
+ 		nested_vmx_failValid(vcpu,
+ 			VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);
+ 		return 1;
+ 	}
+ 
+ 	/* according to the intel vmx instruction reference, the memory
+ 	 * operand is read even if it isn't needed (e.g., for type==global)
+ 	 */
+ 	if (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),
+ 			vmx_instruction_info, false, &gva))
+ 		return 1;
+ 	if (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &vpid,
+ 				sizeof(u32), &e)) {
+ 		kvm_inject_page_fault(vcpu, &e);
+ 		return 1;
+ 	}
+ 
+ 	switch (type) {
+ 	case VMX_VPID_EXTENT_ALL_CONTEXT:
+ 		__vmx_flush_tlb(vcpu, to_vmx(vcpu)->nested.vpid02);
+ 		nested_vmx_succeed(vcpu);
+ 		break;
+ 	default:
+ 		/* Trap single context invalidation invvpid calls */
+ 		BUG_ON(1);
+ 		break;
+ 	}
+ 
+ 	skip_emulated_instruction(vcpu);
++>>>>>>> b2467e744f89 (KVM: nVMX: remove incorrect vpid check in nested invvpid emulation)
  	return 1;
  }
  
* Unmerged path arch/x86/kvm/vmx.c
