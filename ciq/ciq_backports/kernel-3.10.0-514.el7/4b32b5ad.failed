ipv6: Stop rt6_info from using inet_peer's metrics

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit 4b32b5ad31a68a661f761c76dfd0d076636d3ae9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4b32b5ad.failed

inet_peer is indexed by the dst address alone.  However, the fib6 tree
could have multiple routing entries (rt6_info) for the same dst. For
example,
1. A /128 dst via multiple gateways.
2. A RTF_CACHE route cloned from a /128 route.

In the above cases, all of them will share the same metrics and
step on each other.

This patch will steer away from inet_peer's metrics and use
dst_cow_metrics_generic() for everything.

Change Highlights:
1. Remove rt6_cow_metrics() which currently acquires metrics from
   inet_peer for DST_HOST route (i.e. /128 route).
2. Add rt6i_pmtu to take care of the pmtu update to avoid creating a
   full size metrics just to override the RTAX_MTU.
3. After (2), the RTF_CACHE route can also share the metrics with its
   dst.from route, by:
   dst_init_metrics(&cache_rt->dst, dst_metrics_ptr(cache_rt->dst.from), true);
4. Stop creating RTF_CACHE route by cloning another RTF_CACHE route.  Instead,
   directly clone from rt->dst.

   [ Currently, cloning from another RTF_CACHE is only possible during
     rt6_do_redirect().  Also, the old clone is removed from the tree
     immediately after the new clone is added. ]

   In case of cloning from an older redirect RTF_CACHE, it should work as
   before.

   In case of cloning from an older pmtu RTF_CACHE, this patch will forget
   the pmtu and re-learn it (if there is any) from the redirected route.

The _rt6i_peer and DST_METRICS_FORCE_OVERWRITE will be removed
in the next cleanup patch.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Reviewed-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Cc: Steffen Klassert <steffen.klassert@secunet.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4b32b5ad31a68a661f761c76dfd0d076636d3ae9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip6_fib.h
#	net/ipv6/route.c
diff --cc include/net/ip6_fib.h
index 3a818e1c0aa8,7383a8cc8f84..000000000000
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@@ -124,15 -123,10 +124,20 @@@ struct rt6_info 
  	struct inet6_dev		*rt6i_idev;
  	unsigned long			_rt6i_peer;
  
++<<<<<<< HEAD
 +	/* RHEL specific:
 +	 * this field is not used any more since commit
 +	 * "ipv6: remove rt6i_genid"
 +	 */
 +	u32				rt6i_genid;
 +
++=======
+ 	u32				rt6i_metric;
+ 	u32				rt6i_pmtu;
++>>>>>>> 4b32b5ad31a6 (ipv6: Stop rt6_info from using inet_peer's metrics)
  	/* more non-fragment space at head required */
  	unsigned short			rt6i_nfheader_len;
 +
  	u8				rt6i_protocol;
  };
  
diff --cc net/ipv6/route.c
index 322d385093bd,4d6eb5d90cb4..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -104,35 -105,44 +105,14 @@@ static struct rt6_info *rt6_get_route_i
  					   const struct in6_addr *gwaddr, int ifindex);
  #endif
  
 -static void rt6_bind_peer(struct rt6_info *rt, int create)
 -{
 -	struct inet_peer_base *base;
 -	struct inet_peer *peer;
 -
 -	base = inetpeer_base_ptr(rt->_rt6i_peer);
 -	if (!base)
 -		return;
 -
 -	peer = inet_getpeer_v6(base, &rt->rt6i_dst.addr, create);
 -	if (peer) {
 -		if (!rt6_set_peer(rt, peer))
 -			inet_putpeer(peer);
 -	}
 -}
 -
 -static struct inet_peer *__rt6_get_peer(struct rt6_info *rt, int create)
 -{
 -	if (rt6_has_peer(rt))
 -		return rt6_peer_ptr(rt);
 -
 -	rt6_bind_peer(rt, create);
 -	return (rt6_has_peer(rt) ? rt6_peer_ptr(rt) : NULL);
 -}
 -
 -static struct inet_peer *rt6_get_peer_create(struct rt6_info *rt)
 -{
 -	return __rt6_get_peer(rt, 1);
 -}
 -
  static u32 *ipv6_cow_metrics(struct dst_entry *dst, unsigned long old)
  {
- 	struct rt6_info *rt = (struct rt6_info *) dst;
- 	struct inet_peer *peer;
- 	u32 *p = NULL;
+ 	struct rt6_info *rt = (struct rt6_info *)dst;
  
- 	if (!(rt->dst.flags & DST_HOST))
+ 	if (rt->rt6i_flags & RTF_CACHE)
+ 		return NULL;
+ 	else
  		return dst_cow_metrics_generic(dst, old);
- 
- 	peer = rt6_get_peer_create(rt);
- 	if (peer) {
- 		u32 *old_p = __DST_METRICS_PTR(old);
- 		unsigned long prev, new;
- 
- 		p = peer->metrics;
- 		if (inet_metrics_new(peer) ||
- 		    (old & DST_METRICS_FORCE_OVERWRITE))
- 			memcpy(p, old_p, sizeof(u32) * RTAX_MAX);
- 
- 		new = (unsigned long) p;
- 		prev = cmpxchg(&dst->_metrics, old, new);
- 
- 		if (prev != old) {
- 			p = __DST_METRICS_PTR(prev);
- 			if (prev & DST_METRICS_READ_ONLY)
- 				p = NULL;
- 		}
- 	}
- 	return p;
  }
  
  static inline const void *choose_neigh_daddr(struct rt6_info *rt,
@@@ -306,29 -312,8 +285,24 @@@ static void ip6_dst_destroy(struct dst_
  
  	dst->from = NULL;
  	dst_release(from);
- 
- 	if (rt6_has_peer(rt)) {
- 		struct inet_peer *peer = rt6_peer_ptr(rt);
- 		inet_putpeer(peer);
- 	}
  }
  
 +void rt6_bind_peer(struct rt6_info *rt, int create)
 +{
 +	struct inet_peer_base *base;
 +	struct inet_peer *peer;
 +
 +	base = inetpeer_base_ptr(rt->_rt6i_peer);
 +	if (!base)
 +		return;
 +
 +	peer = inet_getpeer_v6(base, &rt->rt6i_dst.addr, create);
 +	if (peer) {
 +		if (!rt6_set_peer(rt, peer))
 +			inet_putpeer(peer);
 +	}
 +}
 +
  static void ip6_dst_ifdown(struct dst_entry *dst, struct net_device *dev,
  			   int how)
  {
@@@ -1170,13 -1160,10 +1154,18 @@@ static void ip6_rt_update_pmtu(struct d
  		struct net *net = dev_net(dst->dev);
  
  		rt6->rt6i_flags |= RTF_MODIFIED;
 -		if (mtu < IPV6_MIN_MTU)
 +		if (mtu < IPV6_MIN_MTU) {
 +			u32 features = dst_metric(dst, RTAX_FEATURES);
  			mtu = IPV6_MIN_MTU;
++<<<<<<< HEAD
 +			features |= RTAX_FEATURE_ALLFRAG;
 +			dst_metric_set(dst, RTAX_FEATURES, features);
 +		}
 +		dst_metric_set(dst, RTAX_MTU, mtu);
++=======
+ 
+ 		rt6->rt6i_pmtu = mtu;
++>>>>>>> 4b32b5ad31a6 (ipv6: Stop rt6_info from using inet_peer's metrics)
  		rt6_update_expires(rt6, net->ipv6.sysctl.ip6_rt_mtu_expires);
  	}
  }
* Unmerged path include/net/ip6_fib.h
* Unmerged path net/ipv6/route.c
