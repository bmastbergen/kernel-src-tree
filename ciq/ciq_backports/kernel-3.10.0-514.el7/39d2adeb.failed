sctp: fix the transports round robin issue when init is retransmitted

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit 39d2adebf137de5f900843f69f5e500932e31047
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/39d2adeb.failed

prior to this patch, at the beginning if we have two paths in one assoc,
they may have the same params other than the last_time_heard, it will try
the paths like this:

1st cycle
  try trans1 fail.
  then trans2 is selected.(cause it's last_time_heard is after trans1).

2nd cycle:
  try  trans2 fail
  then trans2 is selected.(cause it's last_time_heard is after trans1).

3rd cycle:
  try  trans2 fail
  then trans2 is selected.(cause it's last_time_heard is after trans1).

....

trans1 will never have change to be selected, which is not what we expect.
we should keeping round robin all the paths if they are just added at the
beginning.

So at first every tranport's last_time_heard should be initialized 0, so
that we ensure they have the same value at the beginning, only by this,
all the transports could get equal chance to be selected.

Then for sctp_trans_elect_best, it should return the trans_next one when
*trans == *trans_next, so that we can try next if it fails,  but now it
always return trans. so we can fix it by exchanging these two params when
we calls sctp_trans_elect_tie().

Fixes: 4c47af4d5eb2 ('net: sctp: rework multihoming retransmission path selection to rfc4960')
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Acked-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 39d2adebf137de5f900843f69f5e500932e31047)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/associola.c
#	net/sctp/transport.c
diff --cc net/sctp/associola.c
index 95613ef42a0c,cd873446433c..000000000000
--- a/net/sctp/associola.c
+++ b/net/sctp/associola.c
@@@ -1295,72 -1190,192 +1295,126 @@@ void sctp_assoc_update(struct sctp_asso
  }
  
  /* Update the retran path for sending a retransmitted packet.
 - * See also RFC4960, 6.4. Multi-Homed SCTP Endpoints:
 - *
 - *   When there is outbound data to send and the primary path
 - *   becomes inactive (e.g., due to failures), or where the
 - *   SCTP user explicitly requests to send data to an
 - *   inactive destination transport address, before reporting
 - *   an error to its ULP, the SCTP endpoint should try to send
 - *   the data to an alternate active destination transport
 - *   address if one exists.
 - *
 - *   When retransmitting data that timed out, if the endpoint
 - *   is multihomed, it should consider each source-destination
 - *   address pair in its retransmission selection policy.
 - *   When retransmitting timed-out data, the endpoint should
 - *   attempt to pick the most divergent source-destination
 - *   pair from the original source-destination pair to which
 - *   the packet was transmitted.
 - *
 - *   Note: Rules for picking the most divergent source-destination
 - *   pair are an implementation decision and are not specified
 - *   within this document.
 - *
 - * Our basic strategy is to round-robin transports in priorities
 - * according to sctp_trans_score() e.g., if no such
 - * transport with state SCTP_ACTIVE exists, round-robin through
 - * SCTP_UNKNOWN, etc. You get the picture.
 + * Round-robin through the active transports, else round-robin
 + * through the inactive transports as this is the next best thing
 + * we can try.
   */
++<<<<<<< HEAD
++=======
+ static u8 sctp_trans_score(const struct sctp_transport *trans)
+ {
+ 	switch (trans->state) {
+ 	case SCTP_ACTIVE:
+ 		return 3;	/* best case */
+ 	case SCTP_UNKNOWN:
+ 		return 2;
+ 	case SCTP_PF:
+ 		return 1;
+ 	default: /* case SCTP_INACTIVE */
+ 		return 0;	/* worst case */
+ 	}
+ }
+ 
+ static struct sctp_transport *sctp_trans_elect_tie(struct sctp_transport *trans1,
+ 						   struct sctp_transport *trans2)
+ {
+ 	if (trans1->error_count > trans2->error_count) {
+ 		return trans2;
+ 	} else if (trans1->error_count == trans2->error_count &&
+ 		   ktime_after(trans2->last_time_heard,
+ 			       trans1->last_time_heard)) {
+ 		return trans2;
+ 	} else {
+ 		return trans1;
+ 	}
+ }
+ 
+ static struct sctp_transport *sctp_trans_elect_best(struct sctp_transport *curr,
+ 						    struct sctp_transport *best)
+ {
+ 	u8 score_curr, score_best;
+ 
+ 	if (best == NULL || curr == best)
+ 		return curr;
+ 
+ 	score_curr = sctp_trans_score(curr);
+ 	score_best = sctp_trans_score(best);
+ 
+ 	/* First, try a score-based selection if both transport states
+ 	 * differ. If we're in a tie, lets try to make a more clever
+ 	 * decision here based on error counts and last time heard.
+ 	 */
+ 	if (score_curr > score_best)
+ 		return curr;
+ 	else if (score_curr == score_best)
+ 		return sctp_trans_elect_tie(best, curr);
+ 	else
+ 		return best;
+ }
+ 
++>>>>>>> 39d2adebf137 (sctp: fix the transports round robin issue when init is retransmitted)
  void sctp_assoc_update_retran_path(struct sctp_association *asoc)
  {
 -	struct sctp_transport *trans = asoc->peer.retran_path;
 -	struct sctp_transport *trans_next = NULL;
 +	struct sctp_transport *t, *next;
 +	struct list_head *head = &asoc->peer.transport_addr_list;
 +	struct list_head *pos;
  
 -	/* We're done as we only have the one and only path. */
  	if (asoc->peer.transport_count == 1)
  		return;
 -	/* If active_path and retran_path are the same and active,
 -	 * then this is the only active path. Use it.
 -	 */
 -	if (asoc->peer.active_path == asoc->peer.retran_path &&
 -	    asoc->peer.active_path->state == SCTP_ACTIVE)
 -		return;
  
 -	/* Iterate from retran_path's successor back to retran_path. */
 -	for (trans = list_next_entry(trans, transports); 1;
 -	     trans = list_next_entry(trans, transports)) {
 -		/* Manually skip the head element. */
 -		if (&trans->transports == &asoc->peer.transport_addr_list)
 -			continue;
 -		if (trans->state == SCTP_UNCONFIRMED)
 -			continue;
 -		trans_next = sctp_trans_elect_best(trans, trans_next);
 -		/* Active is good enough for immediate return. */
 -		if (trans_next->state == SCTP_ACTIVE)
 -			break;
 -		/* We've reached the end, time to update path. */
 -		if (trans == asoc->peer.retran_path)
 -			break;
 -	}
 +	/* Find the next transport in a round-robin fashion. */
 +	t = asoc->peer.retran_path;
 +	pos = &t->transports;
 +	next = NULL;
  
 -	asoc->peer.retran_path = trans_next;
 +	while (1) {
 +		/* Skip the head. */
 +		if (pos->next == head)
 +			pos = head->next;
 +		else
 +			pos = pos->next;
  
 -	pr_debug("%s: association:%p updated new path to addr:%pISpc\n",
 -		 __func__, asoc, &asoc->peer.retran_path->ipaddr.sa);
 -}
 +		t = list_entry(pos, struct sctp_transport, transports);
  
 -static void sctp_select_active_and_retran_path(struct sctp_association *asoc)
 -{
 -	struct sctp_transport *trans, *trans_pri = NULL, *trans_sec = NULL;
 -	struct sctp_transport *trans_pf = NULL;
 -
 -	/* Look for the two most recently used active transports. */
 -	list_for_each_entry(trans, &asoc->peer.transport_addr_list,
 -			    transports) {
 -		/* Skip uninteresting transports. */
 -		if (trans->state == SCTP_INACTIVE ||
 -		    trans->state == SCTP_UNCONFIRMED)
 -			continue;
 -		/* Keep track of the best PF transport from our
 -		 * list in case we don't find an active one.
 +		/* We have exhausted the list, but didn't find any
 +		 * other active transports.  If so, use the next
 +		 * transport.
  		 */
 -		if (trans->state == SCTP_PF) {
 -			trans_pf = sctp_trans_elect_best(trans, trans_pf);
 -			continue;
 -		}
 -		/* For active transports, pick the most recent ones. */
 -		if (trans_pri == NULL ||
 -		    ktime_after(trans->last_time_heard,
 -				trans_pri->last_time_heard)) {
 -			trans_sec = trans_pri;
 -			trans_pri = trans;
 -		} else if (trans_sec == NULL ||
 -			   ktime_after(trans->last_time_heard,
 -				       trans_sec->last_time_heard)) {
 -			trans_sec = trans;
 +		if (t == asoc->peer.retran_path) {
 +			t = next;
 +			break;
  		}
 -	}
  
 -	/* RFC 2960 6.4 Multi-Homed SCTP Endpoints
 -	 *
 -	 * By default, an endpoint should always transmit to the primary
 -	 * path, unless the SCTP user explicitly specifies the
 -	 * destination transport address (and possibly source transport
 -	 * address) to use. [If the primary is active but not most recent,
 -	 * bump the most recently used transport.]
 -	 */
 -	if ((asoc->peer.primary_path->state == SCTP_ACTIVE ||
 -	     asoc->peer.primary_path->state == SCTP_UNKNOWN) &&
 -	     asoc->peer.primary_path != trans_pri) {
 -		trans_sec = trans_pri;
 -		trans_pri = asoc->peer.primary_path;
 -	}
 +		/* Try to find an active transport. */
  
 -	/* We did not find anything useful for a possible retransmission
 -	 * path; either primary path that we found is the the same as
 -	 * the current one, or we didn't generally find an active one.
 -	 */
 -	if (trans_sec == NULL)
 -		trans_sec = trans_pri;
 -
 -	/* If we failed to find a usable transport, just camp on the
 -	 * active or pick a PF iff it's the better choice.
 -	 */
 -	if (trans_pri == NULL) {
 -		trans_pri = sctp_trans_elect_best(asoc->peer.active_path, trans_pf);
 -		trans_sec = trans_pri;
 +		if ((t->state == SCTP_ACTIVE) ||
 +		    (t->state == SCTP_UNKNOWN)) {
 +			break;
 +		} else {
 +			/* Keep track of the next transport in case
 +			 * we don't find any active transport.
 +			 */
 +			if (t->state != SCTP_UNCONFIRMED && !next)
 +				next = t;
 +		}
  	}
  
 -	/* Set the active and retran transports. */
 -	asoc->peer.active_path = trans_pri;
 -	asoc->peer.retran_path = trans_sec;
 +	if (t)
 +		asoc->peer.retran_path = t;
 +	else
 +		t = asoc->peer.retran_path;
 +
 +	SCTP_DEBUG_PRINTK_IPADDR("sctp_assoc_update_retran_path:association"
 +				 " %p addr: ",
 +				 " port: %d\n",
 +				 asoc,
 +				 (&t->ipaddr),
 +				 ntohs(t->ipaddr.v4.sin_port));
  }
  
 -struct sctp_transport *
 -sctp_assoc_choose_alter_transport(struct sctp_association *asoc,
 -				  struct sctp_transport *last_sent_to)
 +/* Choose the transport for sending retransmit packet.  */
 +struct sctp_transport *sctp_assoc_choose_alter_transport(
 +	struct sctp_association *asoc, struct sctp_transport *last_sent_to)
  {
  	/* If this is the first time packet is sent, use the active path,
  	 * else use the retran path. If the last packet was sent over the
diff --cc net/sctp/transport.c
index 098f1d5f769e,d517153891a6..000000000000
--- a/net/sctp/transport.c
+++ b/net/sctp/transport.c
@@@ -79,7 -72,7 +79,11 @@@ static struct sctp_transport *sctp_tran
  	 */
  	peer->rto = msecs_to_jiffies(net->sctp.rto_initial);
  
++<<<<<<< HEAD
 +	peer->last_time_heard = jiffies;
++=======
+ 	peer->last_time_heard = ktime_set(0, 0);
++>>>>>>> 39d2adebf137 (sctp: fix the transports round robin issue when init is retransmitted)
  	peer->last_time_ecne_reduced = jiffies;
  
  	peer->param_flags = SPP_HB_DISABLE |
* Unmerged path net/sctp/associola.c
* Unmerged path net/sctp/transport.c
