mei: me: wait for power gating exit confirmation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit 3dc196eae1db548f05e53e5875ff87b8ff79f249
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3dc196ea.failed

Fix the hbm power gating state machine so it will wait till it receives
confirmation interrupt for the PG_ISOLATION_EXIT message.

In process of the suspend flow the devices first have to exit from the
power gating state (runtime pm resume).
If we do not handle the confirmation interrupt after sending
PG_ISOLATION_EXIT message, we may receive it already after the suspend
flow has changed the device state and interrupt will be interpreted as a
spurious event, consequently link reset will be invoked which will
prevent the device from completing the suspend flow

kernel: [6603] mei_reset:136: mei_me 0000:00:16.0: powering down: end of reset
kernel: [476] mei_me_irq_thread_handler:643: mei_me 0000:00:16.0: function called after ISR to handle the interrupt processing.
kernel: mei_me 0000:00:16.0: FW not ready: resetting

	Cc: <stable@vger.kernel.org> #3.18+
	Cc: Gabriele Mazzotta <gabriele.mzt@gmail.com>
Link: https://bugzilla.kernel.org/show_bug.cgi?id=86241
Link: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=770397
	Tested-by: Gabriele Mazzotta <gabriele.mzt@gmail.com>
	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 3dc196eae1db548f05e53e5875ff87b8ff79f249)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/client.c
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/client.c
index 3c539de435ba,6decbe136ea7..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -432,8 -714,8 +432,13 @@@ void mei_host_client_init(struct work_s
  bool mei_hbuf_acquire(struct mei_device *dev)
  {
  	if (mei_pg_state(dev) == MEI_PG_ON ||
++<<<<<<< HEAD
 +	    dev->pg_event == MEI_PG_EVENT_WAIT) {
 +		dev_dbg(&dev->pdev->dev, "device is in pg\n");
++=======
+ 	    mei_pg_in_transition(dev)) {
+ 		dev_dbg(dev->dev, "device is in pg\n");
++>>>>>>> 3dc196eae1db (mei: me: wait for power gating exit confirmation)
  		return false;
  	}
  
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,453f6a333b42..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -231,30 -267,32 +231,37 @@@ struct mei_cl 
  
  /** struct mei_hw_ops
   *
 - * @host_is_ready    : query for host readiness
 + * @host_is_ready    - query for host readiness
  
 - * @hw_is_ready      : query if hw is ready
 - * @hw_reset         : reset hw
 - * @hw_start         : start hw after reset
 - * @hw_config        : configure hw
 + * @hw_is_ready      - query if hw is ready
 + * @hw_reset         - reset hw
 + * @hw_start         - start hw after reset
 + * @hw_config        - configure hw
  
++<<<<<<< HEAD
 + * @pg_state         - power gating state of the device
 + * @pg_is_enabled    - is power gating enabled
++=======
+  * @fw_status        : get fw status registers
+  * @pg_state         : power gating state of the device
+  * @pg_in_transition : is device now in pg transition
+  * @pg_is_enabled    : is power gating enabled
++>>>>>>> 3dc196eae1db (mei: me: wait for power gating exit confirmation)
  
 - * @intr_clear       : clear pending interrupts
 - * @intr_enable      : enable interrupts
 - * @intr_disable     : disable interrupts
 + * @intr_clear       - clear pending interrupts
 + * @intr_enable      - enable interrupts
 + * @intr_disable     - disable interrupts
  
 - * @hbuf_free_slots  : query for write buffer empty slots
 - * @hbuf_is_ready    : query if write buffer is empty
 - * @hbuf_max_len     : query for write buffer max len
 + * @hbuf_free_slots  - query for write buffer empty slots
 + * @hbuf_is_ready    - query if write buffer is empty
 + * @hbuf_max_len     - query for write buffer max len
  
 - * @write            : write a message to FW
 + * @write            - write a message to FW
  
 - * @rdbuf_full_slots : query how many slots are filled
 + * @rdbuf_full_slots - query how many slots are filled
  
 - * @read_hdr         : get first 4 bytes (header)
 - * @read             : read a buffer from the FW
 + * @read_hdr         - get first 4 bytes (header)
 + * @read             - read a buffer from the FW
   */
  struct mei_hw_ops {
  
@@@ -265,7 -303,10 +272,8 @@@
  	int (*hw_start)(struct mei_device *dev);
  	void (*hw_config)(struct mei_device *dev);
  
 -
 -	int (*fw_status)(struct mei_device *dev, struct mei_fw_status *fw_sts);
  	enum mei_pg_state (*pg_state)(struct mei_device *dev);
+ 	bool (*pg_in_transition)(struct mei_device *dev);
  	bool (*pg_is_enabled)(struct mei_device *dev);
  
  	void (*intr_clear)(struct mei_device *dev);
* Unmerged path drivers/misc/mei/client.c
diff --git a/drivers/misc/mei/hw-me.c b/drivers/misc/mei/hw-me.c
index 1707fa5ea02a..9cf485d065c3 100644
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@ -560,17 +560,46 @@ int mei_me_pg_unset_sync(struct mei_device *dev)
 	mutex_lock(&dev->device_lock);
 
 reply:
-	if (dev->pg_event == MEI_PG_EVENT_RECEIVED)
-		ret = mei_hbm_pg(dev, MEI_PG_ISOLATION_EXIT_RES_CMD);
+	if (dev->pg_event != MEI_PG_EVENT_RECEIVED) {
+		ret = -ETIME;
+		goto out;
+	}
+
+	dev->pg_event = MEI_PG_EVENT_INTR_WAIT;
+	ret = mei_hbm_pg(dev, MEI_PG_ISOLATION_EXIT_RES_CMD);
+	if (ret)
+		return ret;
+
+	mutex_unlock(&dev->device_lock);
+	wait_event_timeout(dev->wait_pg,
+		dev->pg_event == MEI_PG_EVENT_INTR_RECEIVED, timeout);
+	mutex_lock(&dev->device_lock);
+
+	if (dev->pg_event == MEI_PG_EVENT_INTR_RECEIVED)
+		ret = 0;
 	else
 		ret = -ETIME;
 
+out:
 	dev->pg_event = MEI_PG_EVENT_IDLE;
 	hw->pg_state = MEI_PG_OFF;
 
 	return ret;
 }
 
+/**
+ * mei_me_pg_in_transition - is device now in pg transition
+ *
+ * @dev: the device structure
+ *
+ * Return: true if in pg transition, false otherwise
+ */
+static bool mei_me_pg_in_transition(struct mei_device *dev)
+{
+	return dev->pg_event >= MEI_PG_EVENT_WAIT &&
+	       dev->pg_event <= MEI_PG_EVENT_INTR_WAIT;
+}
+
 /**
  * mei_me_pg_is_enabled - detect if PG is supported by HW
  *
@@ -602,6 +631,24 @@ notsupported:
 	return false;
 }
 
+/**
+ * mei_me_pg_intr - perform pg processing in interrupt thread handler
+ *
+ * @dev: the device structure
+ */
+static void mei_me_pg_intr(struct mei_device *dev)
+{
+	struct mei_me_hw *hw = to_me_hw(dev);
+
+	if (dev->pg_event != MEI_PG_EVENT_INTR_WAIT)
+		return;
+
+	dev->pg_event = MEI_PG_EVENT_INTR_RECEIVED;
+	hw->pg_state = MEI_PG_OFF;
+	if (waitqueue_active(&dev->wait_pg))
+		wake_up(&dev->wait_pg);
+}
+
 /**
  * mei_me_irq_quick_handler - The ISR of the MEI device
  *
@@ -660,6 +707,8 @@ irqreturn_t mei_me_irq_thread_handler(int irq, void *dev_id)
 		goto end;
 	}
 
+	mei_me_pg_intr(dev);
+
 	/*  check if we need to start the dev */
 	if (!mei_host_is_ready(dev)) {
 		if (mei_hw_is_ready(dev)) {
@@ -698,9 +747,10 @@ irqreturn_t mei_me_irq_thread_handler(int irq, void *dev_id)
 	/*
 	 * During PG handshake only allowed write is the replay to the
 	 * PG exit message, so block calling write function
-	 * if the pg state is not idle
+	 * if the pg event is in PG handshake
 	 */
-	if (dev->pg_event == MEI_PG_EVENT_IDLE) {
+	if (dev->pg_event != MEI_PG_EVENT_WAIT &&
+	    dev->pg_event != MEI_PG_EVENT_RECEIVED) {
 		rets = mei_irq_write_handler(dev, &complete_list);
 		dev->hbuf_is_ready = mei_hbuf_is_ready(dev);
 	}
@@ -724,6 +774,7 @@ static const struct mei_hw_ops mei_me_hw_ops = {
 	.hw_config = mei_me_hw_config,
 	.hw_start = mei_me_hw_start,
 
+	.pg_in_transition = mei_me_pg_in_transition,
 	.pg_is_enabled = mei_me_pg_is_enabled,
 
 	.intr_clear = mei_me_intr_clear,
diff --git a/drivers/misc/mei/hw-txe.c b/drivers/misc/mei/hw-txe.c
index ac1dee3e0a8b..53a673a69b93 100644
--- a/drivers/misc/mei/hw-txe.c
+++ b/drivers/misc/mei/hw-txe.c
@@ -284,6 +284,18 @@ int mei_txe_aliveness_set_sync(struct mei_device *dev, u32 req)
 	return 0;
 }
 
+/**
+ * mei_txe_pg_in_transition - is device now in pg transition
+ *
+ * @dev: the device structure
+ *
+ * Return: true if in pg transition, false otherwise
+ */
+static bool mei_txe_pg_in_transition(struct mei_device *dev)
+{
+	return dev->pg_event == MEI_PG_EVENT_WAIT;
+}
+
 /**
  * mei_txe_pg_is_enabled - detect if PG is supported by HW
  *
@@ -1053,6 +1065,7 @@ static const struct mei_hw_ops mei_txe_hw_ops = {
 	.hw_config = mei_txe_hw_config,
 	.hw_start = mei_txe_hw_start,
 
+	.pg_in_transition = mei_txe_pg_in_transition,
 	.pg_is_enabled = mei_txe_pg_is_enabled,
 
 	.intr_clear = mei_txe_intr_clear,
* Unmerged path drivers/misc/mei/mei_dev.h
