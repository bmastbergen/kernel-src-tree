NVMe: Fix memory leak on retried commands

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Keith Busch <keith.busch@intel.com>
commit 0dfc70c33409afc232ef0b9ec210535dfbf9bc61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0dfc70c3.failed

Resources are reallocated for requeued commands, so unmap and release
the iod for the failed command.

It's a pretty bad memory leak and causes a kernel hang if you remove a
drive because of a busy dma pool. You'll get messages spewing like this:

  nvme 0000:xx:xx.x: dma_pool_destroy prp list 256, ffff880420dec000 busy

and lock up pci and the driver since removal never completes while
holding a lock.

	Cc: stable@vger.kernel.org
	Cc: <stable@vger.kernel.org> # 4.0.x-
	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 0dfc70c33409afc232ef0b9ec210535dfbf9bc61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index 52b54f2ad0a7,ccc0c1f93daa..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -509,8 -603,9 +509,13 @@@ static void req_completion(struct nvme_
  	struct nvme_iod *iod = ctx;
  	struct request *req = iod_get_private(iod);
  	struct nvme_cmd_info *cmd_rq = blk_mq_rq_to_pdu(req);
 +
  	u16 status = le16_to_cpup(&cqe->status) >> 1;
++<<<<<<< HEAD
++=======
+ 	bool requeue = false;
+ 	int error = 0;
++>>>>>>> 0dfc70c33409 (NVMe: Fix memory leak on retried commands)
  
  	if (unlikely(status)) {
  		if (!(status & NVME_SC_DNR || blk_noretry_request(req))
@@@ -522,27 -618,44 +528,33 @@@
  			if (!blk_queue_stopped(req->q))
  				blk_mq_kick_requeue_list(req->q);
  			spin_unlock_irqrestore(req->q->queue_lock, flags);
- 			return;
+ 			goto release_iod;
  		}
 -
 -		if (req->cmd_type == REQ_TYPE_DRV_PRIV) {
 -			if (cmd_rq->ctx == CMD_CTX_CANCELLED)
 -				error = -EINTR;
 -			else
 -				error = status;
 -		} else {
 -			error = nvme_error_status(status);
 -		}
 -	}
 -
 -	if (req->cmd_type == REQ_TYPE_DRV_PRIV) {
 -		u32 result = le32_to_cpup(&cqe->result);
 -		req->special = (void *)(uintptr_t)result;
 -	}
 +		req->errors = nvme_error_status(status);
 +	} else
 +		req->errors = 0;
  
  	if (cmd_rq->aborted)
 -		dev_warn(nvmeq->dev->dev,
 +		dev_warn(&nvmeq->dev->pci_dev->dev,
  			"completing aborted command with status:%04x\n",
 -			error);
 +			status);
  
+ release_iod:
  	if (iod->nents) {
 -		dma_unmap_sg(nvmeq->dev->dev, iod->sg, iod->nents,
 +		dma_unmap_sg(&nvmeq->dev->pci_dev->dev, iod->sg, iod->nents,
  			rq_data_dir(req) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 -		if (blk_integrity_rq(req)) {
 -			if (!rq_data_dir(req))
 -				nvme_dif_remap(req, nvme_dif_complete);
 -			dma_unmap_sg(nvmeq->dev->dev, iod->meta_sg, 1,
 +		if (blk_integrity_rq(req))
 +			dma_unmap_sg(&nvmeq->dev->pci_dev->dev, iod->meta_sg, 1,
  				rq_data_dir(req) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 -		}
  	}
  	nvme_free_iod(nvmeq->dev, iod);
  
++<<<<<<< HEAD
 +	blk_mq_complete_request(req);
++=======
+ 	if (likely(!requeue))
+ 		blk_mq_complete_request(req, error);
++>>>>>>> 0dfc70c33409 (NVMe: Fix memory leak on retried commands)
  }
  
  /* length is in bytes.  gfp flags indicates whether we may sleep. */
* Unmerged path drivers/block/nvme-core.c
