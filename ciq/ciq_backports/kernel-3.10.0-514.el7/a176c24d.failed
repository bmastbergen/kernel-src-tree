mei: nfc: clean nfc internal struct on host exit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit a176c24dc9a82b3304a31233bfc37e97c42de09b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a176c24d.failed

NFC internal structure cleaning was dropped by commit

commit 487056932d372cc4f6c636f21a928d6667b151d7
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Mon Feb 17 15:13:19 2014 +0200

    mei: Remove all bus devices from the mei_dev list when stopping the MEI

    When stopping the MEI, we should remove and potentially unregister
    all bus devices queued on the mei_dev linked list.

We allocate nfc_dev and free it across the reset
so we do not keep it in dirty state

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit a176c24dc9a82b3304a31233bfc37e97c42de09b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/nfc.c
diff --cc drivers/misc/mei/nfc.c
index 2b65e8021f0d,60ca9240368e..000000000000
--- a/drivers/misc/mei/nfc.c
+++ b/drivers/misc/mei/nfc.c
@@@ -478,14 -481,25 +480,24 @@@ err
  
  int mei_nfc_host_init(struct mei_device *dev)
  {
- 	struct mei_nfc_dev *ndev = &nfc_dev;
+ 	struct mei_nfc_dev *ndev;
  	struct mei_cl *cl_info, *cl = NULL;
 -	struct mei_me_client *me_cl;
 -	int ret;
 +	int i, ret;
  
- 	/* already initialized */
- 	if (ndev->cl_info)
+ 
+ 	/* in case of internal reset bail out
+ 	 * as the device is already setup
+ 	 */
+ 	cl = mei_cl_bus_find_cl_by_uuid(dev, mei_nfc_guid);
+ 	if (cl)
  		return 0;
  
+ 	ndev = kzalloc(sizeof(struct mei_nfc_dev), GFP_KERNEL);
+ 	if (!ndev) {
+ 		ret = -ENOMEM;
+ 		goto err;
+ 	}
+ 
  	ndev->cl_info = mei_cl_allocate(dev);
  	ndev->cl = mei_cl_allocate(dev);
  
@@@ -550,8 -562,31 +562,36 @@@ err
  
  void mei_nfc_host_exit(struct mei_device *dev)
  {
++<<<<<<< HEAD
 +	struct mei_nfc_dev *ndev = &nfc_dev;
 +	cancel_work_sync(&ndev->init_work);
++=======
+ 	struct mei_nfc_dev *ndev;
+ 	struct mei_cl *cl;
+ 	struct mei_cl_device *cldev;
+ 
+ 	cl = mei_cl_bus_find_cl_by_uuid(dev, mei_nfc_guid);
+ 	if (!cl)
+ 		return;
+ 
+ 	cldev = cl->device;
+ 	if (!cldev)
+ 		return;
+ 
+ 	ndev = (struct mei_nfc_dev *)cldev->priv_data;
+ 	if (ndev)
+ 		cancel_work_sync(&ndev->init_work);
+ 
+ 	cldev->priv_data = NULL;
+ 
+ 	mutex_lock(&dev->device_lock);
+ 	/* Need to remove the device here
+ 	 * since mei_nfc_free will unlink the clients
+ 	 */
+ 	mei_cl_remove_device(cldev);
+ 	mei_nfc_free(ndev);
+ 	mutex_unlock(&dev->device_lock);
++>>>>>>> a176c24dc9a8 (mei: nfc: clean nfc internal struct on host exit)
  }
  
  
diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index ca8736c3675b..bf26e4176128 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -141,7 +141,7 @@ static struct device_type mei_cl_device_type = {
 	.release	= mei_cl_dev_release,
 };
 
-static struct mei_cl *mei_bus_find_mei_cl_by_uuid(struct mei_device *dev,
+struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *dev,
 						uuid_le uuid)
 {
 	struct mei_cl *cl;
@@ -161,7 +161,7 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 	struct mei_cl *cl;
 	int status;
 
-	cl = mei_bus_find_mei_cl_by_uuid(dev, uuid);
+	cl = mei_cl_bus_find_cl_by_uuid(dev, uuid);
 	if (cl == NULL)
 		return NULL;
 
diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h
index 1b981b70f5aa..0e9896608361 100644
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -322,6 +322,7 @@ void mei_cl_bus_rx_event(struct mei_cl *cl);
 void mei_cl_bus_remove_devices(struct mei_device *dev);
 int mei_cl_bus_init(void);
 void mei_cl_bus_exit(void);
+struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *dev, uuid_le uuid);
 
 
 /**
* Unmerged path drivers/misc/mei/nfc.c
