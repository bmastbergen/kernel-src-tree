perf report: Fix indentation of dynamic entries in hierarchy

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit d3a72fd8187b7fa0014394c9dec95ba349b3301e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d3a72fd8.failed

When dynamic entries are used in the hierarchy mode with multiple
events, the output might not be aligned properly.  In the hierarchy
mode, the each sort column is indented using total number of sort keys.
So it keeps track of number of sort keys when adding them.  However
a dynamic sort key can be added more than once when multiple events have
same field names.  This results in unnecessarily long indentation in the
output.

For example perf kmem records following events:

  $ perf evlist --trace-fields -i perf.data.kmem
  kmem:kmalloc: trace_fields: call_site,ptr,bytes_req,bytes_alloc,gfp_flags
  kmem:kmalloc_node: trace_fields: call_site,ptr,bytes_req,bytes_alloc,gfp_flags,node
  kmem:kfree: trace_fields: call_site,ptr
  kmem:kmem_cache_alloc: trace_fields: call_site,ptr,bytes_req,bytes_alloc,gfp_flags
  kmem:kmem_cache_alloc_node: trace_fields: call_site,ptr,bytes_req,bytes_alloc,gfp_flags,node
  kmem:kmem_cache_free: trace_fields: call_site,ptr
  kmem:mm_page_alloc: trace_fields: page,order,gfp_flags,migratetype
  kmem:mm_page_free: trace_fields: page,order

As you can see, many field names shared between kmem events.  So adding
'ptr' dynamic sort key alone will set nr_sort_keys to 6.  And this adds
many unnecessary spaces between columns.

Before:

  $ perf report -i perf.data.kmem --hierarchy -s ptr -g none --stdio
  ...
  #                Overhead                 ptr
  # .......................  ...................................
  #
      99.89%                 0xffff8803ffb79720
       0.06%                 0xffff8803d228a000
       0.03%                 0xffff8803f7678f00
       0.00%                 0xffff880401dc5280
       0.00%                 0xffff880406172380
       0.00%                 0xffff8803ffac3a00
       0.00%                 0xffff8803ffac1600

After:

  # Overhead                 ptr
  # ........  ....................
  #
      99.89%  0xffff8803ffb79720
       0.06%  0xffff8803d228a000
       0.03%  0xffff8803f7678f00
       0.00%  0xffff880401dc5280
       0.00%  0xffff880406172380
       0.00%  0xffff8803ffac3a00
       0.00%  0xffff8803ffac1600

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1456512767-1164-2-git-send-email-namhyung@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit d3a72fd8187b7fa0014394c9dec95ba349b3301e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/ui/browsers/hists.c
#	tools/perf/ui/stdio/hist.c
#	tools/perf/util/hist.h
diff --cc tools/perf/ui/browsers/hists.c
index d1445dd5bb7f,5f74c6723c53..000000000000
--- a/tools/perf/ui/browsers/hists.c
+++ b/tools/perf/ui/browsers/hists.c
@@@ -1347,6 -1632,7 +1347,10 @@@ static unsigned int hist_browser__refre
  	u16 header_offset = 0;
  	struct rb_node *nd;
  	struct hist_browser *hb = container_of(browser, struct hist_browser, b);
++<<<<<<< HEAD
++=======
+ 	int nr_sort = hb->hists->nr_sort_keys;
++>>>>>>> d3a72fd8187b (perf report: Fix indentation of dynamic entries in hierarchy)
  
  	if (hb->show_headers) {
  		hist_browser__show_headers(hb);
@@@ -1597,6 -1969,7 +1601,10 @@@ static int hist_browser__fprintf(struc
  	struct rb_node *nd = hists__filter_entries(rb_first(browser->b.entries),
  						   browser->min_pcnt);
  	int printed = 0;
++<<<<<<< HEAD
++=======
+ 	int nr_sort = browser->hists->nr_sort_keys;
++>>>>>>> d3a72fd8187b (perf report: Fix indentation of dynamic entries in hierarchy)
  
  	while (nd) {
  		struct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);
diff --cc tools/perf/ui/stdio/hist.c
index 28fcb1ee0342,5733d6c196be..000000000000
--- a/tools/perf/ui/stdio/hist.c
+++ b/tools/perf/ui/stdio/hist.c
@@@ -423,6 -494,13 +423,16 @@@ static int hist_entry__fprintf(struct h
  	if (size == 0 || size > bfsz)
  		size = hpp.size = bfsz;
  
++<<<<<<< HEAD
++=======
+ 	if (symbol_conf.report_hierarchy) {
+ 		int nr_sort = hists->nr_sort_keys;
+ 
+ 		return hist_entry__hierarchy_fprintf(he, &hpp, nr_sort,
+ 						     hists, fp);
+ 	}
+ 
++>>>>>>> d3a72fd8187b (perf report: Fix indentation of dynamic entries in hierarchy)
  	hist_entry__snprintf(he, &hpp);
  
  	ret = fprintf(fp, "%s\n", bf);
@@@ -433,6 -511,106 +443,109 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int print_hierarchy_indent(const char *sep, int nr_sort,
+ 				  const char *line, FILE *fp)
+ {
+ 	if (sep != NULL || nr_sort < 1)
+ 		return 0;
+ 
+ 	return fprintf(fp, "%-.*s", (nr_sort - 1) * HIERARCHY_INDENT, line);
+ }
+ 
+ static int print_hierarchy_header(struct hists *hists, struct perf_hpp *hpp,
+ 				  const char *sep, FILE *fp)
+ {
+ 	bool first = true;
+ 	int nr_sort;
+ 	unsigned width = 0;
+ 	unsigned header_width = 0;
+ 	struct perf_hpp_fmt *fmt;
+ 
+ 	nr_sort = hists->nr_sort_keys;
+ 
+ 	/* preserve max indent depth for column headers */
+ 	print_hierarchy_indent(sep, nr_sort, spaces, fp);
+ 
+ 	hists__for_each_format(hists, fmt) {
+ 		if (perf_hpp__is_sort_entry(fmt) || perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		if (!first)
+ 			fprintf(fp, "%s", sep ?: "  ");
+ 		else
+ 			first = false;
+ 
+ 		fmt->header(fmt, hpp, hists_to_evsel(hists));
+ 		fprintf(fp, "%s", hpp->buf);
+ 	}
+ 
+ 	/* combine sort headers with ' / ' */
+ 	first = true;
+ 	hists__for_each_format(hists, fmt) {
+ 		if (!perf_hpp__is_sort_entry(fmt) && !perf_hpp__is_dynamic_entry(fmt))
+ 			continue;
+ 		if (perf_hpp__should_skip(fmt, hists))
+ 			continue;
+ 
+ 		if (!first)
+ 			header_width += fprintf(fp, " / ");
+ 		else {
+ 			header_width += fprintf(fp, "%s", sep ?: "  ");
+ 			first = false;
+ 		}
+ 
+ 		fmt->header(fmt, hpp, hists_to_evsel(hists));
+ 		rtrim(hpp->buf);
+ 
+ 		header_width += fprintf(fp, "%s", hpp->buf);
+ 	}
+ 
+ 	/* preserve max indent depth for combined sort headers */
+ 	print_hierarchy_indent(sep, nr_sort, spaces, fp);
+ 
+ 	fprintf(fp, "\n# ");
+ 
+ 	/* preserve max indent depth for initial dots */
+ 	print_hierarchy_indent(sep, nr_sort, dots, fp);
+ 
+ 	first = true;
+ 	hists__for_each_format(hists, fmt) {
+ 		if (perf_hpp__is_sort_entry(fmt) || perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		if (!first)
+ 			fprintf(fp, "%s", sep ?: "  ");
+ 		else
+ 			first = false;
+ 
+ 		width = fmt->width(fmt, hpp, hists_to_evsel(hists));
+ 		fprintf(fp, "%.*s", width, dots);
+ 	}
+ 
+ 	hists__for_each_format(hists, fmt) {
+ 		if (!perf_hpp__is_sort_entry(fmt) && !perf_hpp__is_dynamic_entry(fmt))
+ 			continue;
+ 		if (perf_hpp__should_skip(fmt, hists))
+ 			continue;
+ 
+ 		width = fmt->width(fmt, hpp, hists_to_evsel(hists));
+ 		if (width > header_width)
+ 			header_width = width;
+ 	}
+ 
+ 	fprintf(fp, "%s%-.*s", sep ?: "  ", header_width, dots);
+ 
+ 	/* preserve max indent depth for dots under sort headers */
+ 	print_hierarchy_indent(sep, nr_sort, dots, fp);
+ 
+ 	fprintf(fp, "\n#\n");
+ 
+ 	return 2;
+ }
+ 
++>>>>>>> d3a72fd8187b (perf report: Fix indentation of dynamic entries in hierarchy)
  size_t hists__fprintf(struct hists *hists, bool show_header, int max_rows,
  		      int max_cols, float min_pcnt, FILE *fp)
  {
@@@ -537,6 -723,20 +650,23 @@@ print_entries
  		if (max_rows && ++nr_rows >= max_rows)
  			break;
  
++<<<<<<< HEAD
++=======
+ 		/*
+ 		 * If all children are filtered out or percent-limited,
+ 		 * display "no entry >= x.xx%" message.
+ 		 */
+ 		if (!h->leaf && !hist_entry__has_hierarchy_children(h, min_pcnt)) {
+ 			int nr_sort = hists->nr_sort_keys;
+ 
+ 			print_hierarchy_indent(sep, nr_sort + h->depth + 1, spaces, fp);
+ 			fprintf(fp, "%*sno entry >= %.2f%%\n", indent, "", min_pcnt);
+ 
+ 			if (max_rows && ++nr_rows >= max_rows)
+ 				break;
+ 		}
+ 
++>>>>>>> d3a72fd8187b (perf report: Fix indentation of dynamic entries in hierarchy)
  		if (h->ms.map == NULL && verbose > 1) {
  			__map_groups__fprintf_maps(h->thread->mg,
  						   MAP__FUNCTION, fp);
diff --cc tools/perf/util/hist.h
index 1d52912874e9,da5e50586bfd..000000000000
--- a/tools/perf/util/hist.h
+++ b/tools/perf/util/hist.h
@@@ -71,6 -76,9 +71,12 @@@ struct hists 
  	struct events_stats	stats;
  	u64			event_stream;
  	u16			col_len[HISTC_NR_COLS];
++<<<<<<< HEAD
++=======
+ 	int			socket_filter;
+ 	struct perf_hpp_list	*hpp_list;
+ 	int			nr_sort_keys;
++>>>>>>> d3a72fd8187b (perf report: Fix indentation of dynamic entries in hierarchy)
  };
  
  struct hist_entry_iter;
* Unmerged path tools/perf/ui/browsers/hists.c
* Unmerged path tools/perf/ui/stdio/hist.c
* Unmerged path tools/perf/util/hist.h
diff --git a/tools/perf/util/sort.c b/tools/perf/util/sort.c
index 8f36c1d6fd38..9fe3456a9433 100644
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@ -2319,6 +2319,9 @@ out:
 int setup_sorting(struct perf_evlist *evlist)
 {
 	int err;
+	struct hists *hists;
+	struct perf_evsel *evsel;
+	struct perf_hpp_fmt *fmt;
 
 	err = __setup_sorting(evlist);
 	if (err < 0)
@@ -2330,6 +2333,22 @@ int setup_sorting(struct perf_evlist *evlist)
 			return err;
 	}
 
+	evlist__for_each(evlist, evsel) {
+		hists = evsel__hists(evsel);
+		hists->nr_sort_keys = perf_hpp_list.nr_sort_keys;
+
+		/*
+		 * If dynamic entries were used, it might add multiple
+		 * entries to each evsel for a single field name.  Set
+		 * actual number of sort keys for each hists.
+		 */
+		perf_hpp_list__for_each_sort_list(&perf_hpp_list, fmt) {
+			if (perf_hpp__is_dynamic_entry(fmt) &&
+			    !perf_hpp__defined_dynamic_entry(fmt, hists))
+				hists->nr_sort_keys--;
+		}
+	}
+
 	reset_dimensions();
 
 	/*
