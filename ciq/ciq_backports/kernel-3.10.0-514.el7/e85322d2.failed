audit: cull redundancy in audit_rule_change

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Richard Guy Briggs <rgb@redhat.com>
commit e85322d21cfebeac64f58a204e9adc0bc5c1e46f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e85322d2.failed

Re-factor audit_rule_change() to reduce the amount of code redundancy and
simplify the logic.

	Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
	Signed-off-by: Eric Paris <eparis@redhat.com>
(cherry picked from commit e85322d21cfebeac64f58a204e9adc0bc5c1e46f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/auditfilter.c
diff --cc kernel/auditfilter.c
index 814c273352d7,d214cd073a58..000000000000
--- a/kernel/auditfilter.c
+++ b/kernel/auditfilter.c
@@@ -1048,52 -1064,65 +1048,93 @@@ int audit_receive_filter(int type, __u3
  	int err = 0;
  	struct audit_entry *entry;
  
+ 	entry = audit_data_to_entry(data, datasz);
+ 	if (IS_ERR(entry))
+ 		return PTR_ERR(entry);
+ 
  	switch (type) {
 +	case AUDIT_LIST_RULES:
 +		/* We can't just spew out the rules here because we might fill
 +		 * the available socket buffer space and deadlock waiting for
 +		 * auditctl to read from it... which isn't ever going to
 +		 * happen if we're actually running in the context of auditctl
 +		 * trying to _send_ the stuff */
 +
 +		dest = kmalloc(sizeof(struct audit_netlink_list), GFP_KERNEL);
 +		if (!dest)
 +			return -ENOMEM;
 +		dest->portid = portid;
 +		skb_queue_head_init(&dest->q);
 +
 +		mutex_lock(&audit_filter_mutex);
 +		audit_list_rules(portid, seq, &dest->q);
 +		mutex_unlock(&audit_filter_mutex);
 +
 +		tsk = kthread_run(audit_send_list, dest, "audit_send_list");
 +		if (IS_ERR(tsk)) {
 +			skb_queue_purge(&dest->q);
 +			kfree(dest);
 +			err = PTR_ERR(tsk);
 +		}
 +		break;
  	case AUDIT_ADD_RULE:
- 		entry = audit_data_to_entry(data, datasz);
- 		if (IS_ERR(entry))
- 			return PTR_ERR(entry);
- 
  		err = audit_add_rule(entry);
  		audit_log_rule_change("add_rule", &entry->rule, !err);
- 		if (err)
- 			audit_free_rule(entry);
  		break;
  	case AUDIT_DEL_RULE:
- 		entry = audit_data_to_entry(data, datasz);
- 		if (IS_ERR(entry))
- 			return PTR_ERR(entry);
- 
  		err = audit_del_rule(entry);
  		audit_log_rule_change("remove_rule", &entry->rule, !err);
- 		audit_free_rule(entry);
  		break;
  	default:
++<<<<<<< HEAD
 +		return -EINVAL;
++=======
+ 		err = -EINVAL;
+ 		WARN_ON(1);
+ 	}
+ 
+ 	if (err || type == AUDIT_DEL_RULE)
+ 		audit_free_rule(entry);
+ 
+ 	return err;
+ }
+ 
+ /**
+  * audit_list_rules_send - list the audit rules
+  * @request_skb: skb of request we are replying to (used to target the reply)
+  * @seq: netlink audit message sequence (serial) number
+  */
+ int audit_list_rules_send(struct sk_buff *request_skb, int seq)
+ {
+ 	u32 portid = NETLINK_CB(request_skb).portid;
+ 	struct net *net = sock_net(NETLINK_CB(request_skb).sk);
+ 	struct task_struct *tsk;
+ 	struct audit_netlink_list *dest;
+ 	int err = 0;
+ 
+ 	/* We can't just spew out the rules here because we might fill
+ 	 * the available socket buffer space and deadlock waiting for
+ 	 * auditctl to read from it... which isn't ever going to
+ 	 * happen if we're actually running in the context of auditctl
+ 	 * trying to _send_ the stuff */
+ 
+ 	dest = kmalloc(sizeof(struct audit_netlink_list), GFP_KERNEL);
+ 	if (!dest)
+ 		return -ENOMEM;
+ 	dest->net = get_net(net);
+ 	dest->portid = portid;
+ 	skb_queue_head_init(&dest->q);
+ 
+ 	mutex_lock(&audit_filter_mutex);
+ 	audit_list_rules(portid, seq, &dest->q);
+ 	mutex_unlock(&audit_filter_mutex);
+ 
+ 	tsk = kthread_run(audit_send_list, dest, "audit_send_list");
+ 	if (IS_ERR(tsk)) {
+ 		skb_queue_purge(&dest->q);
+ 		kfree(dest);
+ 		err = PTR_ERR(tsk);
++>>>>>>> e85322d21cfe (audit: cull redundancy in audit_rule_change)
  	}
  
  	return err;
* Unmerged path kernel/auditfilter.c
