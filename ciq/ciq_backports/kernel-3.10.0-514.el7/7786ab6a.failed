mpt3sas: Ported WarpDrive product SSS6200 support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sreekanth Reddy <sreekanth.reddy@avagotech.com>
commit 7786ab6aff9cea97eb0a8d67705c68e97a664bf3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7786ab6a.failed

Ported the following list of WarpDrive-specific patches:

1. commit 0bdccdb0a090ad8dc5f851cad5e843244c410ee8 ("mpt2sas: WarpDrive
   New product SSS6200 support added")

2. commit 82a452581230b3ffc9d6475dffdb2568497b5fec ("mpt2sas: WarpDrive
   Infinite command retries due to wrong scsi command entry in MPI
   message")

3. commit ba96bd0b1d4a4e11f23671e1f375a5c8f46b0fe7 ("mpt2sas: Support
   for greater than 2TB capacity WarpDrive")

4. commit 4da7af9494b2f98a1503a2634059300c3e4615e6 ("mpt2sas: Do not
   retry a timed out direct IO for Warpdrive")

5. commit daeaa9df92bd742f4e6d4d6039d689277a8e31bd ("mpt2sas: Avoid type
   casting for direct I/O commands").

Also set the mpt2_ioctl_iocinfo adapter_type to:

1. MPT3_IOCTL_INTERFACE_SAS3 for Gen3 HBAs

2. MPT2_IOCTL_INTERFACE_SAS2_SSS6200 for Warp Drive

3. MPT2_IOCTL_INTERFACE_SAS2  for other Gen2 HBAs

	Signed-off-by: Sreekanth Reddy <Sreekanth.Reddy@avagotech.com>
	Acked-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 7786ab6aff9cea97eb0a8d67705c68e97a664bf3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpt3sas/mpt3sas_base.c
#	drivers/scsi/mpt3sas/mpt3sas_ctl.c
#	drivers/scsi/mpt3sas/mpt3sas_scsih.c
diff --cc drivers/scsi/mpt3sas/mpt3sas_base.c
index f059d10b7a92,f7f2ab5ecc4f..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_base.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c
@@@ -5017,19 -5061,16 +5046,32 @@@ mpt3sas_base_attach(struct MPT3SAS_ADAP
  		goto out_free_resources;
  	}
  
++<<<<<<< HEAD
 +	/* Check whether the controller revision is C0 or above.
 +	 * only C0 and above revision controllers support 96 MSI-X vectors.
 +	 */
 +	revision = ioc->pdev->revision;
 +
 +	if ((ioc->pdev->device == MPI25_MFGPAGE_DEVID_SAS3004 ||
 +	     ioc->pdev->device == MPI25_MFGPAGE_DEVID_SAS3008 ||
 +	     ioc->pdev->device == MPI25_MFGPAGE_DEVID_SAS3108_1 ||
 +	     ioc->pdev->device == MPI25_MFGPAGE_DEVID_SAS3108_2 ||
 +	     ioc->pdev->device == MPI25_MFGPAGE_DEVID_SAS3108_5 ||
 +	     ioc->pdev->device == MPI25_MFGPAGE_DEVID_SAS3108_6) &&
 +	     (revision >= 0x02))
 +		ioc->msix96_vector = 1;
++=======
+ 	if (ioc->is_warpdrive) {
+ 		ioc->reply_post_host_index = kcalloc(ioc->cpu_msix_table_sz,
+ 		    sizeof(resource_size_t *), GFP_KERNEL);
+ 		if (!ioc->reply_post_host_index) {
+ 			dfailprintk(ioc, pr_info(MPT3SAS_FMT "allocation "
+ 				"for cpu_msix_table failed!!!\n", ioc->name));
+ 			r = -ENOMEM;
+ 			goto out_free_resources;
+ 		}
+ 	}
++>>>>>>> 7786ab6aff9c (mpt3sas: Ported WarpDrive product SSS6200 support)
  
  	ioc->rdpq_array_enable_assigned = 0;
  	ioc->dma_mask = 0;
diff --cc drivers/scsi/mpt3sas/mpt3sas_ctl.c
index 18a74e9c0d85,3f22754adb4f..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_ctl.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_ctl.c
@@@ -1027,9 -1026,25 +1027,29 @@@ _ctl_getiocinfo(struct MPT3SAS_ADAPTER 
  	karg.pci_information.u.bits.function = PCI_FUNC(ioc->pdev->devfn);
  	karg.pci_information.segment_id = pci_domain_nr(ioc->pdev->bus);
  	karg.firmware_version = ioc->facts.FWVersion.Word;
 -	strcpy(karg.driver_version, driver_name);
 +	strcpy(karg.driver_version, MPT3SAS_DRIVER_NAME);
  	strcat(karg.driver_version, "-");
++<<<<<<< HEAD
 +	strcat(karg.driver_version, MPT3SAS_DRIVER_VERSION);
++=======
+ 	switch  (ioc->hba_mpi_version_belonged) {
+ 	case MPI2_VERSION:
+ 		if (ioc->is_warpdrive)
+ 			karg.adapter_type = MPT2_IOCTL_INTERFACE_SAS2_SSS6200;
+ 		else
+ 			karg.adapter_type = MPT2_IOCTL_INTERFACE_SAS2;
+ 		strcat(karg.driver_version, MPT2SAS_DRIVER_VERSION);
+ 		break;
+ 	case MPI25_VERSION:
+ 		karg.adapter_type = MPT3_IOCTL_INTERFACE_SAS3;
+ 		strcat(karg.driver_version, MPT3SAS_DRIVER_VERSION);
+ 		break;
+ 	}
+ 	if (ioc->hba_mpi_version_belonged == MPI2_VERSION)
+ 		strcat(karg.driver_version, MPT2SAS_DRIVER_VERSION);
+ 	else
+ 		strcat(karg.driver_version, MPT3SAS_DRIVER_VERSION);
++>>>>>>> 7786ab6aff9c (mpt3sas: Ported WarpDrive product SSS6200 support)
  	karg.bios_version = le32_to_cpu(ioc->bios_pg3.BiosVersion);
  
  	if (copy_to_user(arg, &karg, sizeof(karg))) {
diff --cc drivers/scsi/mpt3sas/mpt3sas_scsih.c
index dab4affe7dc9,dc6b0ba851a6..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
@@@ -75,8 -71,21 +76,26 @@@ static int _scsih_add_device(struct MPT
  
  static u8 _scsih_check_for_pending_tm(struct MPT3SAS_ADAPTER *ioc, u16 smid);
  
++<<<<<<< HEAD
 +static void _scsih_scan_start(struct Scsi_Host *shost);
 +static int _scsih_scan_finished(struct Scsi_Host *shost, unsigned long time);
++=======
+ #ifdef SCSI_MPT2SAS
+ static void _scsih_disable_ddio(struct MPT3SAS_ADAPTER *ioc);
+ static u8 _scsih_get_num_volumes(struct MPT3SAS_ADAPTER *ioc);
+ static void
+ _scsih_init_warpdrive_properties(struct MPT3SAS_ADAPTER *ioc,
+ 	struct _raid_device *raid_device);
+ static inline u8
+ _scsih_scsi_direct_io_get(struct MPT3SAS_ADAPTER *ioc, u16 smid);
+ static inline void
+ _scsih_scsi_direct_io_set(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 direct_io);
+ static void
+ _scsih_setup_direct_io(struct MPT3SAS_ADAPTER *ioc, struct scsi_cmnd *scmd,
+ 	struct _raid_device *raid_device, Mpi2SCSIIORequest_t *mpi_request,
+ 	u16 smid);
+ #endif
++>>>>>>> 7786ab6aff9c (mpt3sas: Ported WarpDrive product SSS6200 support)
  
  /* global parameters */
  LIST_HEAD(mpt3sas_ioc_list);
@@@ -1457,14 -1397,17 +1478,17 @@@ _scsih_display_sata_capabilities(struc
   */
  
  /**
 - * scsih_is_raid - return boolean indicating device is raid volume
 + * _scsih_is_raid - return boolean indicating device is raid volume
   * @dev the device struct object
   */
 -int
 -scsih_is_raid(struct device *dev)
 +static int
 +_scsih_is_raid(struct device *dev)
  {
  	struct scsi_device *sdev = to_scsi_device(dev);
+ 	struct MPT3SAS_ADAPTER *ioc = shost_priv(sdev->host);
  
+ 	if (ioc->is_warpdrive)
+ 		return 0;
  	return (sdev->channel == RAID_CHANNEL) ? 1 : 0;
  }
  
@@@ -1798,17 -1748,19 +1829,19 @@@ _scsih_slave_configure(struct scsi_devi
  			break;
  		}
  
- 		sdev_printk(KERN_INFO, sdev,
- 			"%s: handle(0x%04x), wwid(0x%016llx), pd_count(%d), type(%s)\n",
- 			 r_level, raid_device->handle,
- 			 (unsigned long long)raid_device->wwid,
- 			 raid_device->num_pds, ds);
- 
+ 		if (!ioc->hide_ir_msg)
+ 			sdev_printk(KERN_INFO, sdev,
+ 			   "%s: handle(0x%04x), wwid(0x%016llx),"
+ 			    " pd_count(%d), type(%s)\n",
+ 			    r_level, raid_device->handle,
+ 			    (unsigned long long)raid_device->wwid,
+ 			    raid_device->num_pds, ds);
  
 -		scsih_change_queue_depth(sdev, qdepth);
 +		_scsih_change_queue_depth(sdev, qdepth, SCSI_QDEPTH_DEFAULT);
  
- /* raid transport support */
- 		_scsih_set_level(sdev, raid_device->volume_type);
+ 		/* raid transport support */
+ 		if (!ioc->is_warpdrive)
+ 			_scsih_set_level(sdev, raid_device->volume_type);
  		return 0;
  	}
  
@@@ -3688,8 -3640,9 +3727,9 @@@ _scsih_eedp_error_handling(struct scsi_
  }
  
  
+ 
  /**
 - * scsih_qcmd - main scsi request entry point
 + * _scsih_qcmd - main scsi request entry point
   * @scmd: pointer to scsi command object
   * @done: function pointer to be invoked on completion
   *
@@@ -3759,18 -3715,13 +3802,22 @@@ _scsih_qcmd(struct Scsi_Host *shost, st
  		mpi_control = MPI2_SCSIIO_CONTROL_NODATATRANSFER;
  
  	/* set tags */
 -	mpi_control |= MPI2_SCSIIO_CONTROL_SIMPLEQ;
 +	if (!(sas_device_priv_data->flags & MPT_DEVICE_FLAGS_INIT)) {
 +		if (scmd->device->tagged_supported) {
 +			if (scmd->device->ordered_tags)
 +				mpi_control |= MPI2_SCSIIO_CONTROL_ORDEREDQ;
 +			else
 +				mpi_control |= MPI2_SCSIIO_CONTROL_SIMPLEQ;
 +		} else
 +			mpi_control |= MPI2_SCSIIO_CONTROL_SIMPLEQ;
 +	} else
 +		mpi_control |= MPI2_SCSIIO_CONTROL_SIMPLEQ;
  
- 	if ((sas_device_priv_data->flags & MPT_DEVICE_TLR_ON) &&
+ 	/* Make sure Device is not raid volume.
+ 	 * We do not expose raid functionality to upper layer for warpdrive.
+ 	 */
+ 	if (!ioc->is_warpdrive && !scsih_is_raid(&scmd->device->sdev_gendev)
+ 	    && (sas_device_priv_data->flags & MPT_DEVICE_TLR_ON) &&
  	    scmd->cmd_len != 32)
  		mpi_control |= MPI2_SCSIIO_CONTROL_TLR_ON;
  
@@@ -8032,8 -8066,55 +8192,58 @@@ _scsih_scan_finished(struct Scsi_Host *
  	return 1;
  }
  
++<<<<<<< HEAD
++=======
+ void
+ _scsih_determine_hba_mpi_version(struct MPT3SAS_ADAPTER *ioc) {
+ 
+ 	switch (ioc->pdev->device) {
+ 	case MPI2_MFGPAGE_DEVID_SSS6200:
+ 		ioc->is_warpdrive = 1;
+ 		ioc->hide_ir_msg = 1;
+ 	case MPI2_MFGPAGE_DEVID_SAS2004:
+ 	case MPI2_MFGPAGE_DEVID_SAS2008:
+ 	case MPI2_MFGPAGE_DEVID_SAS2108_1:
+ 	case MPI2_MFGPAGE_DEVID_SAS2108_2:
+ 	case MPI2_MFGPAGE_DEVID_SAS2108_3:
+ 	case MPI2_MFGPAGE_DEVID_SAS2116_1:
+ 	case MPI2_MFGPAGE_DEVID_SAS2116_2:
+ 	case MPI2_MFGPAGE_DEVID_SAS2208_1:
+ 	case MPI2_MFGPAGE_DEVID_SAS2208_2:
+ 	case MPI2_MFGPAGE_DEVID_SAS2208_3:
+ 	case MPI2_MFGPAGE_DEVID_SAS2208_4:
+ 	case MPI2_MFGPAGE_DEVID_SAS2208_5:
+ 	case MPI2_MFGPAGE_DEVID_SAS2208_6:
+ 	case MPI2_MFGPAGE_DEVID_SAS2308_1:
+ 	case MPI2_MFGPAGE_DEVID_SAS2308_2:
+ 	case MPI2_MFGPAGE_DEVID_SAS2308_3:
+ 		ioc->hba_mpi_version_belonged = MPI2_VERSION;
+ 		break;
+ 	case MPI25_MFGPAGE_DEVID_SAS3004:
+ 	case MPI25_MFGPAGE_DEVID_SAS3008:
+ 	case MPI25_MFGPAGE_DEVID_SAS3108_1:
+ 	case MPI25_MFGPAGE_DEVID_SAS3108_2:
+ 	case MPI25_MFGPAGE_DEVID_SAS3108_5:
+ 	case MPI25_MFGPAGE_DEVID_SAS3108_6:
+ 		ioc->hba_mpi_version_belonged = MPI25_VERSION;
+ 
+ 		/* Check whether the controller revision is C0 or above.
+ 		 * only C0 and above revision controllers support 96 MSI-X
+ 		 * vectors.
+ 		 */
+ 		if (ioc->pdev->revision >= SAS3_PCI_DEVICE_C0_REVISION)
+ 			ioc->msix96_vector = 1;
+ 		break;
+ 	}
+ 
+ 	if ((ioc->pdev->device != MPI2_MFGPAGE_DEVID_SSS6200) &&
+ 	    (ioc->hba_mpi_version_belonged == MPI2_VERSION))
+ 		ioc->mfg_pg10_hide_flag = MFG_PAGE10_EXPOSE_ALL_DISKS;
+ }
+ 
++>>>>>>> 7786ab6aff9c (mpt3sas: Ported WarpDrive product SSS6200 support)
  /**
 - * scsih_probe - attach and add scsi host
 + * _scsih_probe - attach and add scsi host
   * @pdev: PCI device struct
   * @id: pci device id
   *
@@@ -8058,7 -8133,6 +8268,10 @@@ _scsih_probe(struct pci_dev *pdev, cons
  	list_add_tail(&ioc->list, &mpt3sas_ioc_list);
  	ioc->shost = shost;
  	ioc->id = mpt_ids++;
++<<<<<<< HEAD
 +	sprintf(ioc->name, "%s%d", MPT3SAS_DRIVER_NAME, ioc->id);
++=======
++>>>>>>> 7786ab6aff9c (mpt3sas: Ported WarpDrive product SSS6200 support)
  	ioc->pdev = pdev;
  	ioc->scsi_io_cb_idx = scsi_io_cb_idx;
  	ioc->tm_cb_idx = tm_cb_idx;
@@@ -8483,5 -8515,6 +8713,11 @@@ _scsih_exit(void
  	sas_release_transport(mpt3sas_transport_template);
  }
  
++<<<<<<< HEAD
 +module_init(_scsih_init);
 +module_exit(_scsih_exit);
++=======
+ #ifdef SCSI_MPT2SAS
+ #include "../mpt2sas/mpt2sas_warpdrive.c"
+ #endif
++>>>>>>> 7786ab6aff9c (mpt3sas: Ported WarpDrive product SSS6200 support)
diff --git a/drivers/scsi/mpt2sas/mpt2sas_warpdrive.c b/drivers/scsi/mpt2sas/mpt2sas_warpdrive.c
new file mode 100644
index 000000000000..c4fcbc227346
--- /dev/null
+++ b/drivers/scsi/mpt2sas/mpt2sas_warpdrive.c
@@ -0,0 +1,338 @@
+/*
+ * Scsi Host Layer for MPT (Message Passing Technology) based controllers
+ *
+ * Copyright (C) 2012-2014  LSI Corporation
+ * Copyright (C) 2013-2015 Avago Technologies
+ *  (mailto: MPT-FusionLinux.pdl@avagotech.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * NO WARRANTY
+ * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
+ * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
+ * solely responsible for determining the appropriateness of using and
+ * distributing the Program and assumes all risks associated with its
+ * exercise of rights under this Agreement, including but not limited to
+ * the risks and costs of program errors, damage to or loss of data,
+ * programs or equipment, and unavailability or interruption of operations.
+
+ * DISCLAIMER OF LIABILITY
+ * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
+ * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program.
+ */
+
+/**
+ * _scsih_disable_ddio - Disable direct I/O for all the volumes
+ * @ioc: per adapter object
+ */
+static void
+_scsih_disable_ddio(struct MPT3SAS_ADAPTER *ioc)
+{
+	Mpi2RaidVolPage1_t vol_pg1;
+	Mpi2ConfigReply_t mpi_reply;
+	struct _raid_device *raid_device;
+	u16 handle;
+	u16 ioc_status;
+	unsigned long flags;
+
+	handle = 0xFFFF;
+	while (!(mpt3sas_config_get_raid_volume_pg1(ioc, &mpi_reply,
+	    &vol_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {
+		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
+		    MPI2_IOCSTATUS_MASK;
+		if (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)
+			break;
+		handle = le16_to_cpu(vol_pg1.DevHandle);
+		spin_lock_irqsave(&ioc->raid_device_lock, flags);
+		raid_device = _scsih_raid_device_find_by_handle(ioc, handle);
+		if (raid_device)
+			raid_device->direct_io_enabled = 0;
+		spin_unlock_irqrestore(&ioc->raid_device_lock, flags);
+	}
+	return;
+}
+
+
+/**
+ * _scsih_get_num_volumes - Get number of volumes in the ioc
+ * @ioc: per adapter object
+ */
+static u8
+_scsih_get_num_volumes(struct MPT3SAS_ADAPTER *ioc)
+{
+	Mpi2RaidVolPage1_t vol_pg1;
+	Mpi2ConfigReply_t mpi_reply;
+	u16 handle;
+	u8 vol_cnt = 0;
+	u16 ioc_status;
+
+	handle = 0xFFFF;
+	while (!(mpt3sas_config_get_raid_volume_pg1(ioc, &mpi_reply,
+	    &vol_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {
+		ioc_status = le16_to_cpu(mpi_reply.IOCStatus) &
+		    MPI2_IOCSTATUS_MASK;
+		if (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)
+			break;
+		vol_cnt++;
+		handle = le16_to_cpu(vol_pg1.DevHandle);
+	}
+	return vol_cnt;
+}
+
+
+/**
+ * _scsih_init_warpdrive_properties - Set properties for warpdrive direct I/O.
+ * @ioc: per adapter object
+ * @raid_device: the raid_device object
+ */
+static void
+_scsih_init_warpdrive_properties(struct MPT3SAS_ADAPTER *ioc,
+	struct _raid_device *raid_device)
+{
+	Mpi2RaidVolPage0_t *vol_pg0;
+	Mpi2RaidPhysDiskPage0_t pd_pg0;
+	Mpi2ConfigReply_t mpi_reply;
+	u16 sz;
+	u8 num_pds, count;
+	unsigned long stripe_sz, block_sz;
+	u8 stripe_exp, block_exp;
+	u64 dev_max_lba;
+
+	if (!ioc->is_warpdrive)
+		return;
+
+	if (ioc->mfg_pg10_hide_flag ==  MFG_PAGE10_EXPOSE_ALL_DISKS) {
+		pr_info(MPT3SAS_FMT "WarpDrive : Direct IO is disabled "
+		    "globally as drives are exposed\n", ioc->name);
+		return;
+	}
+	if (_scsih_get_num_volumes(ioc) > 1) {
+		_scsih_disable_ddio(ioc);
+		pr_info(MPT3SAS_FMT "WarpDrive : Direct IO is disabled "
+		    "globally as number of drives > 1\n", ioc->name);
+		return;
+	}
+	if ((mpt3sas_config_get_number_pds(ioc, raid_device->handle,
+	    &num_pds)) || !num_pds) {
+		pr_info(MPT3SAS_FMT "WarpDrive : Direct IO is disabled "
+		    "Failure in computing number of drives\n", ioc->name);
+		return;
+	}
+
+	sz = offsetof(Mpi2RaidVolPage0_t, PhysDisk) + (num_pds *
+	    sizeof(Mpi2RaidVol0PhysDisk_t));
+	vol_pg0 = kzalloc(sz, GFP_KERNEL);
+	if (!vol_pg0) {
+		pr_info(MPT3SAS_FMT "WarpDrive : Direct IO is disabled "
+		    "Memory allocation failure for RVPG0\n", ioc->name);
+		return;
+	}
+
+	if ((mpt3sas_config_get_raid_volume_pg0(ioc, &mpi_reply, vol_pg0,
+	     MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, raid_device->handle, sz))) {
+		pr_info(MPT3SAS_FMT "WarpDrive : Direct IO is disabled "
+		    "Failure in retrieving RVPG0\n", ioc->name);
+		kfree(vol_pg0);
+		return;
+	}
+
+	/*
+	 * WARPDRIVE:If number of physical disks in a volume exceeds the max pds
+	 * assumed for WARPDRIVE, disable direct I/O
+	 */
+	if (num_pds > MPT_MAX_WARPDRIVE_PDS) {
+		pr_warn(MPT3SAS_FMT "WarpDrive : Direct IO is disabled "
+		    "for the drive with handle(0x%04x): num_mem=%d, "
+		    "max_mem_allowed=%d\n", ioc->name, raid_device->handle,
+		    num_pds, MPT_MAX_WARPDRIVE_PDS);
+		kfree(vol_pg0);
+		return;
+	}
+	for (count = 0; count < num_pds; count++) {
+		if (mpt3sas_config_get_phys_disk_pg0(ioc, &mpi_reply,
+		    &pd_pg0, MPI2_PHYSDISK_PGAD_FORM_PHYSDISKNUM,
+		    vol_pg0->PhysDisk[count].PhysDiskNum) ||
+		    pd_pg0.DevHandle == MPT3SAS_INVALID_DEVICE_HANDLE) {
+			pr_info(MPT3SAS_FMT "WarpDrive : Direct IO is "
+			    "disabled for the drive with handle(0x%04x) member"
+			    "handle retrieval failed for member number=%d\n",
+			    ioc->name, raid_device->handle,
+			    vol_pg0->PhysDisk[count].PhysDiskNum);
+			goto out_error;
+		}
+		/* Disable direct I/O if member drive lba exceeds 4 bytes */
+		dev_max_lba = le64_to_cpu(pd_pg0.DeviceMaxLBA);
+		if (dev_max_lba >> 32) {
+			pr_info(MPT3SAS_FMT "WarpDrive : Direct IO is "
+			    "disabled for the drive with handle(0x%04x) member"
+			    " handle (0x%04x) unsupported max lba 0x%016llx\n",
+			    ioc->name, raid_device->handle,
+			    le16_to_cpu(pd_pg0.DevHandle),
+			    (unsigned long long)dev_max_lba);
+			goto out_error;
+		}
+
+		raid_device->pd_handle[count] = le16_to_cpu(pd_pg0.DevHandle);
+	}
+
+	/*
+	 * Assumption for WD: Direct I/O is not supported if the volume is
+	 * not RAID0
+	 */
+	if (raid_device->volume_type != MPI2_RAID_VOL_TYPE_RAID0) {
+		pr_info(MPT3SAS_FMT "WarpDrive : Direct IO is disabled "
+		    "for the drive with handle(0x%04x): type=%d, "
+		    "s_sz=%uK, blk_size=%u\n", ioc->name,
+		    raid_device->handle, raid_device->volume_type,
+		    (le32_to_cpu(vol_pg0->StripeSize) *
+		    le16_to_cpu(vol_pg0->BlockSize)) / 1024,
+		    le16_to_cpu(vol_pg0->BlockSize));
+		goto out_error;
+	}
+
+	stripe_sz = le32_to_cpu(vol_pg0->StripeSize);
+	stripe_exp = find_first_bit(&stripe_sz, 32);
+	if (stripe_exp == 32) {
+		pr_info(MPT3SAS_FMT "WarpDrive : Direct IO is disabled "
+		"for the drive with handle(0x%04x) invalid stripe sz %uK\n",
+		    ioc->name, raid_device->handle,
+		    (le32_to_cpu(vol_pg0->StripeSize) *
+		    le16_to_cpu(vol_pg0->BlockSize)) / 1024);
+		goto out_error;
+	}
+	raid_device->stripe_exponent = stripe_exp;
+	block_sz = le16_to_cpu(vol_pg0->BlockSize);
+	block_exp = find_first_bit(&block_sz, 16);
+	if (block_exp == 16) {
+		pr_info(MPT3SAS_FMT "WarpDrive : Direct IO is disabled "
+		    "for the drive with handle(0x%04x) invalid block sz %u\n",
+		    ioc->name, raid_device->handle,
+		    le16_to_cpu(vol_pg0->BlockSize));
+		goto out_error;
+	}
+	raid_device->block_exponent = block_exp;
+	raid_device->direct_io_enabled = 1;
+
+	pr_info(MPT3SAS_FMT "WarpDrive : Direct IO is Enabled for the drive"
+	    " with handle(0x%04x)\n", ioc->name, raid_device->handle);
+	/*
+	 * WARPDRIVE: Though the following fields are not used for direct IO,
+	 * stored for future purpose:
+	 */
+	raid_device->max_lba = le64_to_cpu(vol_pg0->MaxLBA);
+	raid_device->stripe_sz = le32_to_cpu(vol_pg0->StripeSize);
+	raid_device->block_sz = le16_to_cpu(vol_pg0->BlockSize);
+
+
+	kfree(vol_pg0);
+	return;
+
+out_error:
+	raid_device->direct_io_enabled = 0;
+	for (count = 0; count < num_pds; count++)
+		raid_device->pd_handle[count] = 0;
+	kfree(vol_pg0);
+	return;
+}
+
+/**
+ * _scsih_scsi_direct_io_get - returns direct io flag
+ * @ioc: per adapter object
+ * @smid: system request message index
+ *
+ * Returns the smid stored scmd pointer.
+ */
+static inline u8
+_scsih_scsi_direct_io_get(struct MPT3SAS_ADAPTER *ioc, u16 smid)
+{
+	return ioc->scsi_lookup[smid - 1].direct_io;
+}
+
+/**
+ * _scsih_scsi_direct_io_set - sets direct io flag
+ * @ioc: per adapter object
+ * @smid: system request message index
+ * @direct_io: Zero or non-zero value to set in the direct_io flag
+ *
+ * Returns Nothing.
+ */
+static inline void
+_scsih_scsi_direct_io_set(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 direct_io)
+{
+	ioc->scsi_lookup[smid - 1].direct_io = direct_io;
+}
+
+/**
+ * _scsih_setup_direct_io - setup MPI request for WARPDRIVE Direct I/O
+ * @ioc: per adapter object
+ * @scmd: pointer to scsi command object
+ * @raid_device: pointer to raid device data structure
+ * @mpi_request: pointer to the SCSI_IO reqest message frame
+ * @smid: system request message index
+ *
+ * Returns nothing
+ */
+static void
+_scsih_setup_direct_io(struct MPT3SAS_ADAPTER *ioc, struct scsi_cmnd *scmd,
+	struct _raid_device *raid_device, Mpi2SCSIIORequest_t *mpi_request,
+	u16 smid)
+{
+	sector_t v_lba, p_lba, stripe_off, stripe_unit, column, io_size;
+	u32 stripe_sz, stripe_exp;
+	u8 num_pds, cmd = scmd->cmnd[0];
+
+	if (cmd != READ_10 && cmd != WRITE_10 &&
+	    cmd != READ_16 && cmd != WRITE_16)
+		return;
+
+	if (cmd == READ_10 || cmd == WRITE_10)
+		v_lba = get_unaligned_be32(&mpi_request->CDB.CDB32[2]);
+	else
+		v_lba = get_unaligned_be64(&mpi_request->CDB.CDB32[2]);
+
+	io_size = scsi_bufflen(scmd) >> raid_device->block_exponent;
+
+	if (v_lba + io_size - 1 > raid_device->max_lba)
+		return;
+
+	stripe_sz = raid_device->stripe_sz;
+	stripe_exp = raid_device->stripe_exponent;
+	stripe_off = v_lba & (stripe_sz - 1);
+
+	/* Return unless IO falls within a stripe */
+	if (stripe_off + io_size > stripe_sz)
+		return;
+
+	num_pds = raid_device->num_pds;
+	p_lba = v_lba >> stripe_exp;
+	stripe_unit = p_lba / num_pds;
+	column = p_lba % num_pds;
+	p_lba = (stripe_unit << stripe_exp) + stripe_off;
+	mpi_request->DevHandle = cpu_to_le16(raid_device->pd_handle[column]);
+
+	if (cmd == READ_10 || cmd == WRITE_10)
+		put_unaligned_be32(lower_32_bits(p_lba),
+				   &mpi_request->CDB.CDB32[2]);
+	else
+		put_unaligned_be64(p_lba, &mpi_request->CDB.CDB32[2]);
+
+	_scsih_scsi_direct_io_set(ioc, smid, 1);
+}
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_base.c
diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.h b/drivers/scsi/mpt3sas/mpt3sas_base.h
index c1cb629b580d..8a49a88fa408 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_base.h
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.h
@@ -123,6 +123,16 @@
  */
 #define MPT3SAS_FMT			"%s: "
 
+/*
+ *  WarpDrive Specific Log codes
+ */
+
+#define MPT2_WARPDRIVE_LOGENTRY		(0x8002)
+#define MPT2_WARPDRIVE_LC_SSDT			(0x41)
+#define MPT2_WARPDRIVE_LC_SSDLW		(0x43)
+#define MPT2_WARPDRIVE_LC_SSDLF		(0x44)
+#define MPT2_WARPDRIVE_LC_BRMF			(0x4D)
+
 /*
  * per target private data
  */
@@ -243,6 +253,7 @@ struct Mpi2ManufacturingPage11_t {
  * struct MPT3SAS_TARGET - starget private hostdata
  * @starget: starget object
  * @sas_address: target sas address
+ * @raid_device: raid_device pointer to access volume data
  * @handle: device handle
  * @num_luns: number luns
  * @flags: MPT_TARGET_FLAGS_XXX flags
@@ -252,6 +263,7 @@ struct Mpi2ManufacturingPage11_t {
 struct MPT3SAS_TARGET {
 	struct scsi_target *starget;
 	u64	sas_address;
+	struct _raid_device *raid_device;
 	u16	handle;
 	int	num_luns;
 	u32	flags;
@@ -266,6 +278,11 @@ struct MPT3SAS_TARGET {
 #define MPT_DEVICE_FLAGS_INIT		0x01
 #define MPT_DEVICE_TLR_ON		0x02
 
+#define MFG_PAGE10_HIDE_SSDS_MASK	(0x00000003)
+#define MFG_PAGE10_HIDE_ALL_DISKS	(0x00)
+#define MFG_PAGE10_EXPOSE_ALL_DISKS	(0x01)
+#define MFG_PAGE10_HIDE_IF_VOL_PRESENT	(0x02)
+
 /**
  * struct MPT3SAS_DEVICE - sdev private hostdata
  * @sas_target: starget private hostdata
@@ -367,6 +384,7 @@ struct _sas_device {
  * @sdev: scsi device struct (volumes are single lun)
  * @wwid: unique identifier for the volume
  * @handle: device handle
+ * @block_size: Block size of the volume
  * @id: target id
  * @channel: target channel
  * @volume_type: the raid level
@@ -374,6 +392,13 @@ struct _sas_device {
  * @num_pds: number of hidden raid components
  * @responding: used in _scsih_raid_device_mark_responding
  * @percent_complete: resync percent complete
+ * @direct_io_enabled: Whether direct io to PDs are allowed or not
+ * @stripe_exponent: X where 2powX is the stripe sz in blocks
+ * @block_exponent: X where 2powX is the block sz in bytes
+ * @max_lba: Maximum number of LBA in the volume
+ * @stripe_sz: Stripe Size of the volume
+ * @device_info: Device info of the volume member disk
+ * @pd_handle: Array of handles of the physical drives for direct I/O in le16
  */
 #define MPT_MAX_WARPDRIVE_PDS		8
 struct _raid_device {
@@ -382,13 +407,20 @@ struct _raid_device {
 	struct scsi_device *sdev;
 	u64	wwid;
 	u16	handle;
+	u16	block_sz;
 	int	id;
 	int	channel;
 	u8	volume_type;
 	u8	num_pds;
 	u8	responding;
 	u8	percent_complete;
+	u8	direct_io_enabled;
+	u8	stripe_exponent;
+	u8	block_exponent;
+	u64	max_lba;
+	u32	stripe_sz;
 	u32	device_info;
+	u16	pd_handle[MPT_MAX_WARPDRIVE_PDS];
 };
 
 /**
@@ -497,6 +529,7 @@ struct chain_tracker {
  * @smid: system message id
  * @scmd: scsi request pointer
  * @cb_idx: callback index
+ * @direct_io: To indicate whether I/O is direct (WARPDRIVE)
  * @tracker_list: list of free request (ioc->free_list)
  * @msix_io: IO's msix
  */
@@ -504,6 +537,7 @@ struct scsiio_tracker {
 	u16	smid;
 	struct scsi_cmnd *scmd;
 	u8	cb_idx;
+	u8	direct_io;
 	struct list_head chain_list;
 	struct list_head tracker_list;
 	u16     msix_io;
@@ -831,6 +865,7 @@ struct MPT3SAS_ADAPTER {
 	u16		msix_vector_count;
 	u8		*cpu_msix_table;
 	u16		cpu_msix_table_sz;
+	resource_size_t __iomem **reply_post_host_index;
 	u32		ioc_reset_count;
 	MPT3SAS_FLUSH_RUNNING_CMDS schedule_dead_ioc_flush_running_cmds;
 	u32             non_operational_loop;
@@ -1001,6 +1036,10 @@ struct MPT3SAS_ADAPTER {
 	u32		diagnostic_flags[MPI2_DIAG_BUF_TYPE_COUNT];
 	u32		ring_buffer_offset;
 	u32		ring_buffer_sz;
+	u8		is_warpdrive;
+	u8		hide_ir_msg;
+	u8		mfg_pg10_hide_flag;
+	u8		hide_drives;
 	spinlock_t	diag_trigger_lock;
 	u8		diag_trigger_active;
 	struct SL_WH_MASTER_TRIGGER_T diag_trigger_master;
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_ctl.c
diff --git a/drivers/scsi/mpt3sas/mpt3sas_ctl.h b/drivers/scsi/mpt3sas/mpt3sas_ctl.h
index f43e3c2c3353..89408356d252 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_ctl.h
+++ b/drivers/scsi/mpt3sas/mpt3sas_ctl.h
@@ -141,6 +141,7 @@ struct mpt3_ioctl_pci_info {
 #define MPT2_IOCTL_INTERFACE_FC_IP	(0x02)
 #define MPT2_IOCTL_INTERFACE_SAS	(0x03)
 #define MPT2_IOCTL_INTERFACE_SAS2	(0x04)
+#define MPT2_IOCTL_INTERFACE_SAS2_SSS6200	(0x05)
 #define MPT3_IOCTL_INTERFACE_SAS3	(0x06)
 #define MPT2_IOCTL_VERSION_LENGTH	(32)
 
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_scsih.c
