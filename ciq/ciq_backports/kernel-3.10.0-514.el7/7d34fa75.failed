vxlan: fix too large pskb_may_pull with remote checksum

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 7d34fa75d3ee99a90ebb33c2917aa9152fb36a9c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7d34fa75.failed

vxlan_remcsum is called after iptunnel_pull_header and thus the skb has
vxlan header already pulled. Don't include vxlan header again in the
calculation.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7d34fa75d3ee99a90ebb33c2917aa9152fb36a9c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 9215c93ac7ca,1c0fa364323e..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1127,30 -1140,112 +1127,35 @@@ static int vxlan_igmp_leave(struct vxla
  	return ret;
  }
  
 -static bool vxlan_remcsum(struct vxlanhdr *unparsed,
 -			  struct sk_buff *skb, u32 vxflags)
 +static struct vxlanhdr *vxlan_remcsum(struct sk_buff *skb, struct vxlanhdr *vh,
 +				      size_t hdrlen, u32 data, bool nopartial)
  {
- 	size_t start, offset, plen;
+ 	size_t start, offset;
  
 -	if (!(unparsed->vx_flags & VXLAN_HF_RCO) || skb->remcsum_offload)
 -		goto out;
 -
 -	start = vxlan_rco_start(unparsed->vx_vni);
 -	offset = start + vxlan_rco_offset(unparsed->vx_vni);
 -
 -	if (!pskb_may_pull(skb, offset + sizeof(u16)))
 -		return false;
 -
 -	skb_remcsum_process(skb, (void *)(vxlan_hdr(skb) + 1), start, offset,
 -			    !!(vxflags & VXLAN_F_REMCSUM_NOPARTIAL));
 -out:
 -	unparsed->vx_flags &= ~VXLAN_HF_RCO;
 -	unparsed->vx_vni &= VXLAN_VNI_MASK;
 -	return true;
 -}
 -
 -static void vxlan_parse_gbp_hdr(struct vxlanhdr *unparsed,
 -				struct sk_buff *skb, u32 vxflags,
 -				struct vxlan_metadata *md)
 -{
 -	struct vxlanhdr_gbp *gbp = (struct vxlanhdr_gbp *)unparsed;
 -	struct metadata_dst *tun_dst;
 -
 -	if (!(unparsed->vx_flags & VXLAN_HF_GBP))
 -		goto out;
 -
 -	md->gbp = ntohs(gbp->policy_id);
 -
 -	tun_dst = (struct metadata_dst *)skb_dst(skb);
 -	if (tun_dst) {
 -		tun_dst->u.tun_info.key.tun_flags |= TUNNEL_VXLAN_OPT;
 -		tun_dst->u.tun_info.options_len = sizeof(*md);
 -	}
 -	if (gbp->dont_learn)
 -		md->gbp |= VXLAN_GBP_DONT_LEARN;
 -
 -	if (gbp->policy_applied)
 -		md->gbp |= VXLAN_GBP_POLICY_APPLIED;
 -
 -	/* In flow-based mode, GBP is carried in dst_metadata */
 -	if (!(vxflags & VXLAN_F_COLLECT_METADATA))
 -		skb->mark = md->gbp;
 -out:
 -	unparsed->vx_flags &= ~VXLAN_GBP_USED_BITS;
 -}
 -
 -static bool vxlan_set_mac(struct vxlan_dev *vxlan,
 -			  struct vxlan_sock *vs,
 -			  struct sk_buff *skb)
 -{
 -	union vxlan_addr saddr;
 -
 -	skb_reset_mac_header(skb);
 -	skb->protocol = eth_type_trans(skb, vxlan->dev);
 -	skb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);
 +	if (skb->remcsum_offload)
 +		return vh;
  
 -	/* Ignore packet loops (and multicast echo) */
 -	if (ether_addr_equal(eth_hdr(skb)->h_source, vxlan->dev->dev_addr))
 -		return false;
 +	start = (data & VXLAN_RCO_MASK) << VXLAN_RCO_SHIFT;
 +	offset = start + ((data & VXLAN_RCO_UDP) ?
 +			  offsetof(struct udphdr, check) :
 +			  offsetof(struct tcphdr, check));
  
 -	/* Get address from the outer IP header */
 -	if (vxlan_get_sk_family(vs) == AF_INET) {
 -		saddr.sin.sin_addr.s_addr = ip_hdr(skb)->saddr;
 -		saddr.sa.sa_family = AF_INET;
 -#if IS_ENABLED(CONFIG_IPV6)
 -	} else {
 -		saddr.sin6.sin6_addr = ipv6_hdr(skb)->saddr;
 -		saddr.sa.sa_family = AF_INET6;
 -#endif
 -	}
++<<<<<<< HEAD
 +	plen = hdrlen + offset + sizeof(u16);
  
 -	if ((vxlan->flags & VXLAN_F_LEARN) &&
 -	    vxlan_snoop(skb->dev, &saddr, eth_hdr(skb)->h_source))
 +	if (!pskb_may_pull(skb, plen))
 +		return NULL;
++=======
++	if (!pskb_may_pull(skb, offset + sizeof(u16)))
+ 		return false;
++>>>>>>> 7d34fa75d3ee (vxlan: fix too large pskb_may_pull with remote checksum)
  
 -	return true;
 -}
 +	vh = (struct vxlanhdr *)(udp_hdr(skb) + 1);
  
 -static bool vxlan_ecn_decapsulate(struct vxlan_sock *vs, void *oiph,
 -				  struct sk_buff *skb)
 -{
 -	int err = 0;
 +	skb_remcsum_process(skb, (void *)vh + hdrlen, start, offset,
 +			    nopartial);
  
 -	if (vxlan_get_sk_family(vs) == AF_INET)
 -		err = IP_ECN_decapsulate(oiph, skb);
 -#if IS_ENABLED(CONFIG_IPV6)
 -	else
 -		err = IP6_ECN_decapsulate(oiph, skb);
 -#endif
 -
 -	if (unlikely(err) && log_ecn_error) {
 -		if (vxlan_get_sk_family(vs) == AF_INET)
 -			net_info_ratelimited("non-ECT from %pI4 with TOS=%#x\n",
 -					     &((struct iphdr *)oiph)->saddr,
 -					     ((struct iphdr *)oiph)->tos);
 -		else
 -			net_info_ratelimited("non-ECT from %pI6\n",
 -					     &((struct ipv6hdr *)oiph)->saddr);
 -	}
 -	return err <= 1;
 +	return vh;
  }
  
  /* Callback from net/ipv4/udp.c to receive packets */
* Unmerged path drivers/net/vxlan.c
