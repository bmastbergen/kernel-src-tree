staging/rdma/hfi1: Fix logical continuations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Fix logical continuations (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 90.00%
commit-author Jubin John <jubin.john@intel.com>
commit d0d236ea34e6ce2d9106a8f61f92b6af3995d6ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d0d236ea.failed

Move logical continuations to previous line to fix checkpatch check:
CHECK: Logical continuations should be on the previous line

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Jubin John <jubin.john@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit d0d236ea34e6ce2d9106a8f61f92b6af3995d6ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/chip.c
#	drivers/staging/hfi1/firmware.c
diff --cc drivers/staging/hfi1/chip.c
index 2f61b64fc695,b4c017abab9f..000000000000
--- a/drivers/staging/hfi1/chip.c
+++ b/drivers/staging/hfi1/chip.c
@@@ -7545,9 -7565,9 +7543,15 @@@ static void handle_8051_interrupt(struc
  	if (queue_link_down) {
  		/* if the link is already going down or disabled, do not
  		 * queue another */
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +		if ((ppd->host_link_state
 +				    & (HLS_GOING_OFFLINE|HLS_LINK_COOLDOWN))
 +				|| ppd->link_enabled == 0) {
++=======
+ 		if ((ppd->host_link_state &
+ 		    (HLS_GOING_OFFLINE | HLS_LINK_COOLDOWN)) ||
+ 		    ppd->link_enabled == 0) {
++>>>>>>> d0d236ea34e6 (staging/rdma/hfi1: Fix logical continuations):drivers/staging/rdma/hfi1/chip.c
  			dd_dev_info(dd, "%s: not queuing link down\n",
  				__func__);
  		} else {
diff --cc drivers/staging/hfi1/firmware.c
index 0b23e3eaf574,1af5e3406f04..000000000000
--- a/drivers/staging/hfi1/firmware.c
+++ b/drivers/staging/hfi1/firmware.c
@@@ -385,19 -391,13 +385,29 @@@ static int invalid_header(struct hfi1_d
  static int verify_css_header(struct hfi1_devdata *dd, struct css_header *css)
  {
  	/* verify CSS header fields (most sizes are in DW, so add /4) */
++<<<<<<< HEAD:drivers/staging/hfi1/firmware.c
 +	if (invalid_header(dd, "module_type", css->module_type, CSS_MODULE_TYPE)
 +			|| invalid_header(dd, "header_len", css->header_len,
 +					(sizeof(struct firmware_file)/4))
 +			|| invalid_header(dd, "header_version",
 +					css->header_version, CSS_HEADER_VERSION)
 +			|| invalid_header(dd, "module_vendor",
 +					css->module_vendor, CSS_MODULE_VENDOR)
 +			|| invalid_header(dd, "key_size",
 +					css->key_size, KEY_SIZE/4)
 +			|| invalid_header(dd, "modulus_size",
 +					css->modulus_size, KEY_SIZE/4)
 +			|| invalid_header(dd, "exponent_size",
 +					css->exponent_size, EXPONENT_SIZE/4)) {
++=======
+ 	if (invalid_header(dd, "module_type", css->module_type, CSS_MODULE_TYPE) ||
+ 	    invalid_header(dd, "header_len", css->header_len, (sizeof(struct firmware_file) / 4)) ||
+ 	    invalid_header(dd, "header_version", css->header_version, CSS_HEADER_VERSION) ||
+ 	    invalid_header(dd, "module_vendor", css->module_vendor, CSS_MODULE_VENDOR) ||
+ 	    invalid_header(dd, "key_size", css->key_size, KEY_SIZE / 4) ||
+ 	    invalid_header(dd, "modulus_size", css->modulus_size, KEY_SIZE / 4) ||
+ 	    invalid_header(dd, "exponent_size", css->exponent_size, EXPONENT_SIZE / 4)) {
++>>>>>>> d0d236ea34e6 (staging/rdma/hfi1: Fix logical continuations):drivers/staging/rdma/hfi1/firmware.c
  		return -EINVAL;
  	}
  	return 0;
* Unmerged path drivers/staging/hfi1/chip.c
diff --git a/drivers/staging/hfi1/driver.c b/drivers/staging/hfi1/driver.c
index 31605ee909b6..a53d616097f7 100644
--- a/drivers/staging/hfi1/driver.c
+++ b/drivers/staging/hfi1/driver.c
@@ -1109,9 +1109,9 @@ int set_mtu(struct hfi1_pportdata *ppd)
 	ppd->ibmaxlen = ppd->ibmtu + lrh_max_header_bytes(ppd->dd);
 
 	mutex_lock(&ppd->hls_lock);
-	if (ppd->host_link_state == HLS_UP_INIT
-			|| ppd->host_link_state == HLS_UP_ARMED
-			|| ppd->host_link_state == HLS_UP_ACTIVE)
+	if (ppd->host_link_state == HLS_UP_INIT ||
+	    ppd->host_link_state == HLS_UP_ARMED ||
+	    ppd->host_link_state == HLS_UP_ACTIVE)
 		is_up = 1;
 
 	drain = !is_ax(dd) && is_up;
diff --git a/drivers/staging/hfi1/file_ops.c b/drivers/staging/hfi1/file_ops.c
index 5d56ff3d1c23..34255c1c9392 100644
--- a/drivers/staging/hfi1/file_ops.c
+++ b/drivers/staging/hfi1/file_ops.c
@@ -2006,12 +2006,12 @@ static ssize_t ui_read(struct file *filp, char __user *buf, size_t count,
 		 * them.  These registers are defined as having a read value
 		 * of 0.
 		 */
-		else if (csr_off == ASIC_GPIO_CLEAR
-				|| csr_off == ASIC_GPIO_FORCE
-				|| csr_off == ASIC_QSFP1_CLEAR
-				|| csr_off == ASIC_QSFP1_FORCE
-				|| csr_off == ASIC_QSFP2_CLEAR
-				|| csr_off == ASIC_QSFP2_FORCE)
+		else if (csr_off == ASIC_GPIO_CLEAR ||
+			 csr_off == ASIC_GPIO_FORCE ||
+			 csr_off == ASIC_QSFP1_CLEAR ||
+			 csr_off == ASIC_QSFP1_FORCE ||
+			 csr_off == ASIC_QSFP2_CLEAR ||
+			 csr_off == ASIC_QSFP2_FORCE)
 			data = 0;
 		else if (csr_off >= barlen) {
 			/*
* Unmerged path drivers/staging/hfi1/firmware.c
diff --git a/drivers/staging/hfi1/intr.c b/drivers/staging/hfi1/intr.c
index 75a0fb55e7a2..431661a4cad4 100644
--- a/drivers/staging/hfi1/intr.c
+++ b/drivers/staging/hfi1/intr.c
@@ -131,8 +131,7 @@ void handle_linkup_change(struct hfi1_devdata *dd, u32 linkup)
 		 * NOTE: This uses this device's vAU, vCU, and vl15_init for
 		 * the remote values.  Both sides must be using the values.
 		 */
-		if (quick_linkup
-			    || dd->icode == ICODE_FUNCTIONAL_SIMULATOR) {
+		if (quick_linkup || dd->icode == ICODE_FUNCTIONAL_SIMULATOR) {
 			set_up_vl15(dd, dd->vau, dd->vl15_init);
 			assign_remote_cm_au_table(dd, dd->vcu);
 			ppd->neighbor_guid =
diff --git a/drivers/staging/hfi1/mad.c b/drivers/staging/hfi1/mad.c
index b6006cf469fc..392bd9357bd1 100644
--- a/drivers/staging/hfi1/mad.c
+++ b/drivers/staging/hfi1/mad.c
@@ -1164,8 +1164,8 @@ static int __subn_set_opa_portinfo(struct opa_smp *smp, u32 am, u8 *data,
 	ppd->port_error_action = be32_to_cpu(pi->port_error_action);
 	lwe = be16_to_cpu(pi->link_width.enabled);
 	if (lwe) {
-		if (lwe == OPA_LINK_WIDTH_RESET
-				|| lwe == OPA_LINK_WIDTH_RESET_OLD)
+		if (lwe == OPA_LINK_WIDTH_RESET ||
+		    lwe == OPA_LINK_WIDTH_RESET_OLD)
 			set_link_width_enabled(ppd, ppd->link_width_supported);
 		else if ((lwe & ~ppd->link_width_supported) == 0)
 			set_link_width_enabled(ppd, lwe);
@@ -1174,8 +1174,8 @@ static int __subn_set_opa_portinfo(struct opa_smp *smp, u32 am, u8 *data,
 	}
 	lwe = be16_to_cpu(pi->link_width_downgrade.enabled);
 	/* LWD.E is always applied - 0 means "disabled" */
-	if (lwe == OPA_LINK_WIDTH_RESET
-			|| lwe == OPA_LINK_WIDTH_RESET_OLD) {
+	if (lwe == OPA_LINK_WIDTH_RESET ||
+	    lwe == OPA_LINK_WIDTH_RESET_OLD) {
 		set_link_width_downgrade_enabled(ppd,
 				ppd->link_width_downgrade_supported);
 	} else if ((lwe & ~ppd->link_width_downgrade_supported) == 0) {
@@ -2322,8 +2322,8 @@ static int pma_get_opa_portstatus(struct opa_pma_mad *pmp,
 		return reply((struct ib_mad_hdr *)pmp);
 	}
 
-	if (nports != 1 || (port_num && port_num != port)
-	    || num_vls > OPA_MAX_VLS || (vl_select_mask & ~VL_MASK_ALL)) {
+	if (nports != 1 || (port_num && port_num != port) ||
+	    num_vls > OPA_MAX_VLS || (vl_select_mask & ~VL_MASK_ALL)) {
 		pmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;
 		return reply((struct ib_mad_hdr *)pmp);
 	}
diff --git a/drivers/staging/hfi1/sdma.c b/drivers/staging/hfi1/sdma.c
index 8a57bc183ce2..875087e44227 100644
--- a/drivers/staging/hfi1/sdma.c
+++ b/drivers/staging/hfi1/sdma.c
@@ -692,8 +692,8 @@ static void sdma_set_state(struct sdma_engine *sde,
 	ss->previous_op = ss->current_op;
 	ss->current_state = next_state;
 
-	if (ss->previous_state != sdma_state_s99_running
-		&& next_state == sdma_state_s99_running)
+	if (ss->previous_state != sdma_state_s99_running &&
+	    next_state == sdma_state_s99_running)
 		sdma_flush(sde);
 
 	if (action[next_state].op_enable)
