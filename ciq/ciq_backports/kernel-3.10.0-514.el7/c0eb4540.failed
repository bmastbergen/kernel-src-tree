hv_netvsc: Don't ask for additional head room in the skb

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author KY Srinivasan <kys@microsoft.com>
commit c0eb454034aab783dc602739237a63b30867f5bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c0eb4540.failed

The rndis header is 116 bytes big and can be placed in the default
head room that will be available in the skb. Since the netvsc packet
is less than 48 bytes, we can use the skb control buffer
for the netvsc packet. With these changes we don't need to
ask for additional head room.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c0eb454034aab783dc602739237a63b30867f5bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index 56b76b7b9a27,b820888409bc..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -424,50 -432,67 +424,83 @@@ static int netvsc_start_xmit(struct sk_
  	int  hdr_offset;
  	u32 net_trans_info;
  	u32 hash;
++<<<<<<< HEAD
 +	u32 skb_length = skb->len;
 +
++=======
+ 	u32 skb_length;
+ 	struct hv_page_buffer page_buf[MAX_PAGE_BUFFER_COUNT];
+ 	struct netvsc_stats *tx_stats = this_cpu_ptr(net_device_ctx->tx_stats);
++>>>>>>> c0eb454034aa (hv_netvsc: Don't ask for additional head room in the skb)
  
  	/* We will atmost need two pages to describe the rndis
  	 * header. We can only transmit MAX_PAGE_BUFFER_COUNT number
 -	 * of pages in a single packet. If skb is scattered around
 -	 * more pages we try linearizing it.
 +	 * of pages in a single packet.
  	 */
 -
 -check_size:
 -	skb_length = skb->len;
  	num_data_pgs = netvsc_get_slots(skb) + 2;
 -	if (num_data_pgs > MAX_PAGE_BUFFER_COUNT && linear) {
 -		net_alert_ratelimited("packet too big: %u pages (%u bytes)\n",
 -				      num_data_pgs, skb->len);
 -		ret = -EFAULT;
 -		goto drop;
 -	} else if (num_data_pgs > MAX_PAGE_BUFFER_COUNT) {
 -		if (skb_linearize(skb)) {
 -			net_alert_ratelimited("failed to linearize skb\n");
 -			ret = -ENOMEM;
 -			goto drop;
 -		}
 -		linear = true;
 -		goto check_size;
 +	if (num_data_pgs > MAX_PAGE_BUFFER_COUNT) {
 +		netdev_err(net, "Packet too big: %u\n", skb->len);
 +		dev_kfree_skb(skb);
 +		net->stats.tx_dropped++;
 +		return NETDEV_TX_OK;
  	}
  
++<<<<<<< HEAD
 +	/* Allocate a netvsc packet based on # of frags. */
 +	packet = kzalloc(sizeof(struct hv_netvsc_packet) +
 +			 (num_data_pgs * sizeof(struct hv_page_buffer)) +
 +			 sizeof(struct rndis_message) +
 +			 NDIS_VLAN_PPI_SIZE + NDIS_CSUM_PPI_SIZE +
 +			 NDIS_LSO_PPI_SIZE + NDIS_HASH_PPI_SIZE, GFP_ATOMIC);
 +	if (!packet) {
 +		/* out of memory, drop packet */
 +		netdev_err(net, "unable to allocate hv_netvsc_packet\n");
 +
 +		dev_kfree_skb(skb);
 +		net->stats.tx_dropped++;
 +		return NETDEV_TX_OK;
 +	}
++=======
+ 	/*
+ 	 * Place the rndis header in the skb head room and
+ 	 * the skb->cb will be used for hv_netvsc_packet
+ 	 * structure.
+ 	 */
+ 	ret = skb_cow_head(skb, RNDIS_AND_PPI_SIZE);
+ 	if (ret) {
+ 		netdev_err(net, "unable to alloc hv_netvsc_packet\n");
+ 		ret = -ENOMEM;
+ 		goto drop;
+ 	}
+ 	/* Use the skb control buffer for building up the packet */
+ 	BUILD_BUG_ON(sizeof(struct hv_netvsc_packet) >
+ 			FIELD_SIZEOF(struct sk_buff, cb));
+ 	packet = (struct hv_netvsc_packet *)skb->cb;
+ 
+ 	packet->status = 0;
+ 	packet->xmit_more = skb->xmit_more;
++>>>>>>> c0eb454034aa (hv_netvsc: Don't ask for additional head room in the skb)
  
  	packet->vlan_tci = skb->vlan_tci;
 -	packet->page_buf = page_buf;
  
  	packet->q_idx = skb_get_queue_mapping(skb);
  
  	packet->is_data_pkt = true;
  	packet->total_data_buflen = skb->len;
  
++<<<<<<< HEAD
 +	packet->rndis_msg = (struct rndis_message *)((unsigned long)packet +
 +				sizeof(struct hv_netvsc_packet) +
 +				(num_data_pgs * sizeof(struct hv_page_buffer)));
++=======
+ 	rndis_msg = (struct rndis_message *)skb->head;
+ 
+ 	memset(rndis_msg, 0, RNDIS_AND_PPI_SIZE);
++>>>>>>> c0eb454034aa (hv_netvsc: Don't ask for additional head room in the skb)
  
  	/* Set the completion routine */
 -	packet->completion_func = 1;
 +	packet->send_completion = netvsc_xmit_completion;
 +	packet->send_completion_ctx = packet;
  	packet->send_completion_tid = (unsigned long)skb;
  
  	isvlan = packet->vlan_tci & VLAN_TAG_PRESENT;
diff --git a/drivers/net/hyperv/hyperv_net.h b/drivers/net/hyperv/hyperv_net.h
index cf498664d989..a2e4f2dd1967 100644
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@ -125,6 +125,9 @@ struct ndis_tcp_ip_checksum_info;
 /*
  * Represent netvsc packet which contains 1 RNDIS and 1 ethernet frame
  * within the RNDIS
+ *
+ * The size of this structure is less than 48 bytes and we can now
+ * place this structure in the skb->cb field.
  */
 struct hv_netvsc_packet {
 	/* Bookkeeping stuff */
* Unmerged path drivers/net/hyperv/netvsc_drv.c
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index eb7e9fa3e472..f3364eb668e5 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -140,7 +140,9 @@ static inline bool dev_xmit_complete(int rc)
  *	used.
  */
 
-#if defined(CONFIG_WLAN) || IS_ENABLED(CONFIG_AX25)
+#if defined(CONFIG_HYPERV_NET)
+# define LL_MAX_HEADER 128
+#elif defined(CONFIG_WLAN) || IS_ENABLED(CONFIG_AX25)
 # if defined(CONFIG_MAC80211_MESH)
 #  define LL_MAX_HEADER 128
 # else
