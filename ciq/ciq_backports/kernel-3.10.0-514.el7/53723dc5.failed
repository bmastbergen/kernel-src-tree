iommu: Allocate a default domain for iommu groups

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [iommu] Allocate a default domain for iommu groups (Myron Stowe) [1050021]
Rebuild_FUZZ: 92.31%
commit-author Joerg Roedel <jroedel@suse.de>
commit 53723dc59ff3ab504c739000b287ded49aeb2019
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/53723dc5.failed

The default domain will be used (if supported by the iommu
driver) when the devices in the iommu group are not attached
to any other domain.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 53723dc59ff3ab504c739000b287ded49aeb2019)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iommu.c
diff --cc drivers/iommu/iommu.c
index 382a30656c3c,49eb9bfe518e..000000000000
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@@ -876,39 -939,28 +893,54 @@@ void iommu_set_fault_handler(struct iom
  }
  EXPORT_SYMBOL_GPL(iommu_set_fault_handler);
  
- struct iommu_domain *iommu_domain_alloc(struct bus_type *bus)
+ static struct iommu_domain *__iommu_domain_alloc(struct bus_type *bus,
+ 						 unsigned type)
  {
 +	const struct iommu_ops *ops;
  	struct iommu_domain *domain;
  
  	if (bus == NULL || bus->iommu_ops == NULL)
  		return NULL;
  
++<<<<<<< HEAD
 +	ops = bus->iommu_ops;
 +
 +	if (ops->domain_alloc)
 +		domain = ops->domain_alloc();
 +	else
 +		domain = kzalloc(sizeof(*domain), GFP_KERNEL);
 +
 +	if (!domain)
 +		return NULL;
 +
 +	domain->ops = bus->iommu_ops;
 +
 +	if (ops->domain_init && domain->ops->domain_init(domain))
 +		goto out_free;
++=======
+ 	domain = bus->iommu_ops->domain_alloc(type);
+ 	if (!domain)
+ 		return NULL;
+ 
+ 	domain->ops  = bus->iommu_ops;
+ 	domain->type = type;
++>>>>>>> 53723dc59ff3 (iommu: Allocate a default domain for iommu groups)
  
  	return domain;
 +
 +out_free:
 +	if (ops->domain_free)
 +		ops->domain_free(domain);
 +	else
 +		kfree(domain);
 +
 +	return NULL;
  }
+ 
+ struct iommu_domain *iommu_domain_alloc(struct bus_type *bus)
+ {
+ 	return __iommu_domain_alloc(bus, IOMMU_DOMAIN_UNMANAGED);
+ }
  EXPORT_SYMBOL_GPL(iommu_domain_alloc);
  
  void iommu_domain_free(struct iommu_domain *domain)
* Unmerged path drivers/iommu/iommu.c
