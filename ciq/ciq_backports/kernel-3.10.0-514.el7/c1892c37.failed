vfs: fix deadlock in file_remove_privs() on overlayfs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit c1892c37769cf89c7e7ba57528ae2ccb5d153c9b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c1892c37.failed

file_remove_privs() is called with inode lock on file_inode(), which
proceeds to calling notify_change() on file->f_path.dentry.  Which triggers
the WARN_ON_ONCE(!inode_is_locked(inode)) in addition to deadlocking later
when ovl_setattr tries to lock the underlying inode again.

Fix this mess by not mixing the layers, but doing everything on underlying
dentry/inode.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Fixes: 07a2daab49c5 ("ovl: Copy up underlying inode's ->i_mode to overlay inode")
	Cc: <stable@vger.kernel.org>
(cherry picked from commit c1892c37769cf89c7e7ba57528ae2ccb5d153c9b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/inode.c
diff --cc fs/inode.c
index 237190a851c4,68db39050446..000000000000
--- a/fs/inode.c
+++ b/fs/inode.c
@@@ -1658,27 -1734,26 +1658,41 @@@ static int __remove_suid(struct dentry 
  	return notify_change(dentry, &newattrs, NULL);
  }
  
 -/*
 - * Remove special file priviledges (suid, capabilities) when file is written
 - * to or truncated.
 - */
 -int file_remove_privs(struct file *file)
 +int file_remove_suid(struct file *file)
  {
++<<<<<<< HEAD
 +	struct dentry *dentry = file->f_path.dentry;
 +	struct inode *inode = dentry->d_inode;
 +	int killsuid;
 +	int killpriv;
++=======
+ 	struct dentry *dentry = file_dentry(file);
+ 	struct inode *inode = file_inode(file);
+ 	int kill;
++>>>>>>> c1892c37769c (vfs: fix deadlock in file_remove_privs() on overlayfs)
  	int error = 0;
  
  	/* Fast path for nothing security related */
  	if (IS_NOSEC(inode))
  		return 0;
  
++<<<<<<< HEAD
 +	killsuid = should_remove_suid(dentry);
 +	killpriv = security_inode_need_killpriv(dentry);
 +
 +	if (killpriv < 0)
 +		return killpriv;
 +	if (killpriv)
 +		error = security_inode_killpriv(dentry);
 +	if (!error && killsuid)
 +		error = __remove_suid(dentry, killsuid);
++=======
+ 	kill = dentry_needs_remove_privs(dentry);
+ 	if (kill < 0)
+ 		return kill;
+ 	if (kill)
+ 		error = __remove_privs(dentry, kill);
++>>>>>>> c1892c37769c (vfs: fix deadlock in file_remove_privs() on overlayfs)
  	if (!error)
  		inode_has_no_xattr(inode);
  
* Unmerged path fs/inode.c
