pagemap: introduce pagemap_entry_t without pmshift bits

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Pavel Emelyanov <xemul@parallels.com>
commit 2b0a9f017548f05e42fbf7e67c4a626c1ebd5e12
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2b0a9f01.failed

These bits are always constant (== PAGE_SHIFT) and just occupy space in
the entry.  Moreover, in next patch we will need to report one more bit
in the pagemap, but all bits are already busy on it.

That said, describe the pagemap entry that has 6 more free zero bits.

	Signed-off-by: Pavel Emelyanov <xemul@parallels.com>
	Cc: Matt Mackall <mpm@selenic.com>
	Cc: Xiao Guangrong <xiaoguangrong@linux.vnet.ibm.com>
	Cc: Glauber Costa <glommer@parallels.com>
	Cc: Marcelo Tosatti <mtosatti@redhat.com>
	Cc: KOSAKI Motohiro <kosaki.motohiro@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 2b0a9f017548f05e42fbf7e67c4a626c1ebd5e12)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/task_mmu.c
diff --cc fs/proc/task_mmu.c
index 452c618feb42,39d641292579..000000000000
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@@ -811,8 -805,9 +811,9 @@@ typedef struct 
  } pagemap_entry_t;
  
  struct pagemapread {
 -	int pos, len;
 +	int pos, len;		/* units: PM_ENTRY_BYTES, not bytes */
  	pagemap_entry_t *buffer;
+ 	bool v2;
  };
  
  #define PAGEMAP_WALK_SIZE	(PMD_SIZE)
@@@ -922,10 -919,9 +925,10 @@@ static int pagemap_pte_range(pmd_t *pmd
  {
  	struct vm_area_struct *vma;
  	struct pagemapread *pm = walk->private;
 +	spinlock_t *ptl;
  	pte_t *pte;
  	int err = 0;
- 	pagemap_entry_t pme = make_pme(PM_NOT_PRESENT);
+ 	pagemap_entry_t pme = make_pme(PM_NOT_PRESENT(pm->v2));
  
  	/* find the first VMA at or above 'addr' */
  	vma = find_vma(walk->mm, addr);
@@@ -1058,8 -1054,9 +1061,14 @@@ static ssize_t pagemap_read(struct fil
  	if (!count)
  		goto out_task;
  
++<<<<<<< HEAD
 +	pm.len = (PAGEMAP_WALK_SIZE >> PAGE_SHIFT);
 +	pm.buffer = kmalloc(pm.len * PM_ENTRY_BYTES, GFP_TEMPORARY);
++=======
+ 	pm.v2 = false;
+ 	pm.len = PM_ENTRY_BYTES * (PAGEMAP_WALK_SIZE >> PAGE_SHIFT);
+ 	pm.buffer = kmalloc(pm.len, GFP_TEMPORARY);
++>>>>>>> 2b0a9f017548 (pagemap: introduce pagemap_entry_t without pmshift bits)
  	ret = -ENOMEM;
  	if (!pm.buffer)
  		goto out_task;
* Unmerged path fs/proc/task_mmu.c
