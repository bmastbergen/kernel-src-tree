tunnels: Allow IPv6 UDP checksums to be correctly controlled.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] tunnels: Allow IPv6 UDP checksums to be correctly controlled (Lance Richardson) [1283886]
Rebuild_FUZZ: 99.17%
commit-author Jesse Gross <jesse@kernel.org>
commit 35e2d1152b22eae99c961affbe85374bef05a775
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/35e2d115.failed

When configuring checksums on UDP tunnels, the flags are different
for IPv4 vs. IPv6 (and reversed). However, when lightweight tunnels
are enabled the flags used are always the IPv4 versions, which are
ignored in the IPv6 code paths. This uses the correct IPv6 flags, so
checksums can be controlled appropriately.

Fixes: a725e514 ("vxlan: metadata based tunneling for IPv6")
Fixes: abe492b4 ("geneve: UDP checksum configuration via netlink")
	Signed-off-by: Jesse Gross <jesse@kernel.org>
	Acked-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 35e2d1152b22eae99c961affbe85374bef05a775)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
#	drivers/net/vxlan.c
diff --cc drivers/net/geneve.c
index 7c79843ccb40,0b14ac3b8d11..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -704,6 -937,145 +704,148 @@@ err
  	return NETDEV_TX_OK;
  }
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_IPV6)
+ static netdev_tx_t geneve6_xmit_skb(struct sk_buff *skb, struct net_device *dev,
+ 				    struct ip_tunnel_info *info)
+ {
+ 	struct geneve_dev *geneve = netdev_priv(dev);
+ 	struct geneve_sock *gs6 = geneve->sock6;
+ 	struct dst_entry *dst = NULL;
+ 	const struct iphdr *iip; /* interior IP header */
+ 	int err = -EINVAL;
+ 	struct flowi6 fl6;
+ 	__u8 prio, ttl;
+ 	__be16 sport;
+ 	bool xnet = !net_eq(geneve->net, dev_net(geneve->dev));
+ 	u32 flags = geneve->flags;
+ 
+ 	if (geneve->collect_md) {
+ 		if (unlikely(!info || !(info->mode & IP_TUNNEL_INFO_TX))) {
+ 			netdev_dbg(dev, "no tunnel metadata\n");
+ 			goto tx_error;
+ 		}
+ 	}
+ 
+ 	dst = geneve_get_v6_dst(skb, dev, &fl6, info);
+ 	if (IS_ERR(dst)) {
+ 		err = PTR_ERR(dst);
+ 		goto tx_error;
+ 	}
+ 
+ 	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
+ 	skb_reset_mac_header(skb);
+ 
+ 	iip = ip_hdr(skb);
+ 
+ 	if (info) {
+ 		const struct ip_tunnel_key *key = &info->key;
+ 		u8 *opts = NULL;
+ 		u8 vni[3];
+ 
+ 		tunnel_id_to_vni(key->tun_id, vni);
+ 		if (key->tun_flags & TUNNEL_GENEVE_OPT)
+ 			opts = ip_tunnel_info_opts(info);
+ 
+ 		if (key->tun_flags & TUNNEL_CSUM)
+ 			flags &= ~GENEVE_F_UDP_ZERO_CSUM6_TX;
+ 		else
+ 			flags |= GENEVE_F_UDP_ZERO_CSUM6_TX;
+ 
+ 		err = geneve6_build_skb(dst, skb, key->tun_flags, vni,
+ 					info->options_len, opts,
+ 					flags, xnet);
+ 		if (unlikely(err))
+ 			goto err;
+ 
+ 		prio = ip_tunnel_ecn_encap(key->tos, iip, skb);
+ 		ttl = key->ttl;
+ 	} else {
+ 		err = geneve6_build_skb(dst, skb, 0, geneve->vni,
+ 					0, NULL, flags, xnet);
+ 		if (unlikely(err))
+ 			goto err;
+ 
+ 		prio = ip_tunnel_ecn_encap(fl6.flowi6_tos, iip, skb);
+ 		ttl = geneve->ttl;
+ 		if (!ttl && ipv6_addr_is_multicast(&fl6.daddr))
+ 			ttl = 1;
+ 		ttl = ttl ? : ip6_dst_hoplimit(dst);
+ 	}
+ 	udp_tunnel6_xmit_skb(dst, gs6->sock->sk, skb, dev,
+ 			     &fl6.saddr, &fl6.daddr, prio, ttl,
+ 			     sport, geneve->dst_port,
+ 			     !!(flags & GENEVE_F_UDP_ZERO_CSUM6_TX));
+ 	return NETDEV_TX_OK;
+ 
+ tx_error:
+ 	dev_kfree_skb(skb);
+ err:
+ 	if (err == -ELOOP)
+ 		dev->stats.collisions++;
+ 	else if (err == -ENETUNREACH)
+ 		dev->stats.tx_carrier_errors++;
+ 	else
+ 		dev->stats.tx_errors++;
+ 	return NETDEV_TX_OK;
+ }
+ #endif
+ 
+ static netdev_tx_t geneve_xmit(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct geneve_dev *geneve = netdev_priv(dev);
+ 	struct ip_tunnel_info *info = NULL;
+ 
+ 	if (geneve->collect_md)
+ 		info = skb_tunnel_info(skb);
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if ((info && ip_tunnel_info_af(info) == AF_INET6) ||
+ 	    (!info && geneve->remote.sa.sa_family == AF_INET6))
+ 		return geneve6_xmit_skb(skb, dev, info);
+ #endif
+ 	return geneve_xmit_skb(skb, dev, info);
+ }
+ 
+ static int geneve_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
+ {
+ 	struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 	struct geneve_dev *geneve = netdev_priv(dev);
+ 	struct rtable *rt;
+ 	struct flowi4 fl4;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	struct dst_entry *dst;
+ 	struct flowi6 fl6;
+ #endif
+ 
+ 	if (ip_tunnel_info_af(info) == AF_INET) {
+ 		rt = geneve_get_v4_rt(skb, dev, &fl4, info);
+ 		if (IS_ERR(rt))
+ 			return PTR_ERR(rt);
+ 
+ 		ip_rt_put(rt);
+ 		info->key.u.ipv4.src = fl4.saddr;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	} else if (ip_tunnel_info_af(info) == AF_INET6) {
+ 		dst = geneve_get_v6_dst(skb, dev, &fl6, info);
+ 		if (IS_ERR(dst))
+ 			return PTR_ERR(dst);
+ 
+ 		dst_release(dst);
+ 		info->key.u.ipv6.src = fl6.saddr;
+ #endif
+ 	} else {
+ 		return -EINVAL;
+ 	}
+ 
+ 	info->key.tp_src = udp_flow_src_port(geneve->net, skb,
+ 					     1, USHRT_MAX, true);
+ 	info->key.tp_dst = geneve->dst_port;
+ 	return 0;
+ }
+ 
++>>>>>>> 35e2d1152b22 (tunnels: Allow IPv6 UDP checksums to be correctly controlled.)
  static const struct net_device_ops geneve_netdev_ops = {
  	.ndo_init		= geneve_init,
  	.ndo_uninit		= geneve_uninit,
diff --cc drivers/net/vxlan.c
index f5682e47e53a,a85b1fcb3130..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1907,12 -1981,36 +1907,43 @@@ static void vxlan_xmit_one(struct sk_bu
  	if (tos == 1)
  		tos = ip_tunnel_get_dsfield(old_iph, skb);
  
++<<<<<<< HEAD
 +	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->port_min,
 +				     vxlan->port_max, true);
 +
 +	if (dst->sa.sa_family == AF_INET) {
++=======
+ 	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
+ 				     vxlan->cfg.port_max, true);
+ 
+ 	if (info) {
+ 		ttl = info->key.ttl;
+ 		tos = info->key.tos;
+ 
+ 		if (info->options_len)
+ 			md = ip_tunnel_info_opts(info);
+ 	} else {
+ 		md->gbp = skb->mark;
+ 	}
+ 
+ 	if (dst->sa.sa_family == AF_INET) {
+ 		if (!vxlan->vn4_sock)
+ 			goto drop;
+ 		sk = vxlan->vn4_sock->sock->sk;
+ 
+ 		if (info) {
+ 			if (info->key.tun_flags & TUNNEL_DONT_FRAGMENT)
+ 				df = htons(IP_DF);
+ 
+ 			if (info->key.tun_flags & TUNNEL_CSUM)
+ 				flags |= VXLAN_F_UDP_CSUM;
+ 			else
+ 				flags &= ~VXLAN_F_UDP_CSUM;
+ 		}
+ 
++>>>>>>> 35e2d1152b22 (tunnels: Allow IPv6 UDP checksums to be correctly controlled.)
  		memset(&fl4, 0, sizeof(fl4));
 -		fl4.flowi4_oif = rdst ? rdst->remote_ifindex : 0;
 +		fl4.flowi4_oif = rdst->remote_ifindex;
  		fl4.flowi4_tos = RT_TOS(tos);
  		fl4.flowi4_mark = skb->mark;
  		fl4.flowi4_proto = IPPROTO_UDP;
@@@ -2010,14 -2103,18 +2041,21 @@@
  			return;
  		}
  
+ 		if (info) {
+ 			if (info->key.tun_flags & TUNNEL_CSUM)
+ 				flags &= ~VXLAN_F_UDP_ZERO_CSUM6_TX;
+ 			else
+ 				flags |= VXLAN_F_UDP_ZERO_CSUM6_TX;
+ 		}
+ 
  		ttl = ttl ? : ip6_dst_hoplimit(ndst);
 -		err = vxlan6_xmit_skb(ndst, sk, skb, dev, &saddr, &dst->sin6.sin6_addr,
 -				      0, ttl, src_port, dst_port, htonl(vni << 8), md,
 +		md.vni = htonl(vni << 8);
 +		md.gbp = skb->mark;
 +
 +		err = vxlan6_xmit_skb(ndst, sk, skb, dev, &fl6.saddr, &fl6.daddr,
 +				      0, ttl, src_port, dst_port, &md,
  				      !net_eq(vxlan->net, dev_net(vxlan->dev)),
 -				      flags);
 +				      vxlan->flags);
  #endif
  	}
  
* Unmerged path drivers/net/geneve.c
* Unmerged path drivers/net/vxlan.c
