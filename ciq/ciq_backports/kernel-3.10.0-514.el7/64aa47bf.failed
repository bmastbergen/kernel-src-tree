KVM: x86: add kvm_apic_map_get_dest_lapic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] kvm: add kvm_apic_map_get_dest_lapic (Radim Krcmar) [1273718]
Rebuild_FUZZ: 93.51%
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit 64aa47bfc45323040d5db8f30cbd6851f2606c7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/64aa47bf.failed

kvm_irq_delivery_to_apic_fast and kvm_intr_is_single_vcpu_fast both
compute the interrupt destination.  Factor the code.

'struct kvm_lapic **dst = NULL' had to be added to silence GCC.
GCC might complain about potential NULL access in the future, because it
missed conditions that avoided uninitialized uses of dst.

	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 64aa47bfc45323040d5db8f30cbd6851f2606c7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/lapic.c
diff --cc arch/x86/kvm/lapic.c
index 2330983674b9,2987843657db..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -673,7 -644,118 +673,92 @@@ bool kvm_apic_match_dest(struct kvm_vcp
  		return false;
  	}
  }
 -EXPORT_SYMBOL_GPL(kvm_apic_match_dest);
 -
 -int kvm_vector_to_index(u32 vector, u32 dest_vcpus,
 -		       const unsigned long *bitmap, u32 bitmap_size)
 -{
 -	u32 mod;
 -	int i, idx = -1;
 -
 -	mod = vector % dest_vcpus;
 -
 -	for (i = 0; i <= mod; i++) {
 -		idx = find_next_bit(bitmap, bitmap_size, idx + 1);
 -		BUG_ON(idx == bitmap_size);
 -	}
 -
 -	return idx;
 -}
 -
 -static void kvm_apic_disabled_lapic_found(struct kvm *kvm)
 -{
 -	if (!kvm->arch.disabled_lapic_found) {
 -		kvm->arch.disabled_lapic_found = true;
 -		printk(KERN_INFO
 -		       "Disabled LAPIC found during irq injection\n");
 -	}
 -}
  
+ /* Return true if the interrupt can be handled by using *bitmap as index mask
+  * for valid destinations in *dst array.
+  * Return false if kvm_apic_map_get_dest_lapic did nothing useful.
+  * Note: we may have zero kvm_lapic destinations when we return true, which
+  * means that the interrupt should be dropped.  In this case, *bitmap would be
+  * zero and *dst undefined.
+  */
+ static inline bool kvm_apic_map_get_dest_lapic(struct kvm *kvm,
+ 		struct kvm_lapic **src, struct kvm_lapic_irq *irq,
+ 		struct kvm_apic_map *map, struct kvm_lapic ***dst,
+ 		unsigned long *bitmap)
+ {
+ 	int i, lowest;
+ 	bool x2apic_ipi;
+ 	u16 cid;
+ 
+ 	if (irq->shorthand == APIC_DEST_SELF && src) {
+ 		*dst = src;
+ 		*bitmap = 1;
+ 		return true;
+ 	} else if (irq->shorthand)
+ 		return false;
+ 
+ 	x2apic_ipi = src && *src && apic_x2apic_mode(*src);
+ 	if (irq->dest_id == (x2apic_ipi ? X2APIC_BROADCAST : APIC_BROADCAST))
+ 		return false;
+ 
+ 	if (!map)
+ 		return false;
+ 
+ 	if (irq->dest_mode == APIC_DEST_PHYSICAL) {
+ 		if (irq->dest_id >= ARRAY_SIZE(map->phys_map)) {
+ 			*bitmap = 0;
+ 		} else {
+ 			*dst = &map->phys_map[irq->dest_id];
+ 			*bitmap = 1;
+ 		}
+ 		return true;
+ 	}
+ 
+ 	if (!kvm_apic_logical_map_valid(map))
+ 		return false;
+ 
+ 	apic_logical_id(map, irq->dest_id, &cid, (u16 *)bitmap);
+ 
+ 	if (cid >= ARRAY_SIZE(map->logical_map)) {
+ 		*bitmap = 0;
+ 		return true;
+ 	}
+ 
+ 	*dst = map->logical_map[cid];
+ 
+ 	if (!kvm_lowest_prio_delivery(irq))
+ 		return true;
+ 
+ 	if (!kvm_vector_hashing_enabled()) {
+ 		lowest = -1;
+ 		for_each_set_bit(i, bitmap, 16) {
+ 			if (!(*dst)[i])
+ 				continue;
+ 			if (lowest < 0)
+ 				lowest = i;
+ 			else if (kvm_apic_compare_prio((*dst)[i]->vcpu,
+ 						(*dst)[lowest]->vcpu) < 0)
+ 				lowest = i;
+ 		}
+ 	} else {
+ 		if (!*bitmap)
+ 			return true;
+ 
+ 		lowest = kvm_vector_to_index(irq->vector, hweight16(*bitmap),
+ 				bitmap, 16);
+ 
+ 		if (!(*dst)[lowest]) {
+ 			kvm_apic_disabled_lapic_found(kvm);
+ 			*bitmap = 0;
+ 			return true;
+ 		}
+ 	}
+ 
+ 	*bitmap = (lowest >= 0) ? 1 << lowest : 0;
+ 
+ 	return true;
+ }
+ 
  bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,
  		struct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)
  {
@@@ -693,62 -775,16 +778,49 @@@
  	rcu_read_lock();
  	map = rcu_dereference(kvm->arch.apic_map);
  
- 	if (!map) {
- 		ret = false;
- 		goto out;
- 	}
- 
- 	if (irq->dest_mode == APIC_DEST_PHYSICAL) {
- 		if (irq->dest_id >= ARRAY_SIZE(map->phys_map))
- 			goto out;
- 
- 		dst = &map->phys_map[irq->dest_id];
- 	} else {
- 		u16 cid;
- 
- 		if (!kvm_apic_logical_map_valid(map)) {
- 			ret = false;
- 			goto out;
+ 	ret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);
+ 	if (ret)
+ 		for_each_set_bit(i, &bitmap, 16) {
+ 			if (!dst[i])
+ 				continue;
+ 			if (*r < 0)
+ 				*r = 0;
+ 			*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);
  		}
  
++<<<<<<< HEAD
 +		apic_logical_id(map, irq->dest_id, &cid, (u16 *)&bitmap);
 +
 +		if (cid >= ARRAY_SIZE(map->logical_map))
 +			goto out;
 +
 +		dst = map->logical_map[cid];
 +
 +		if (irq->delivery_mode == APIC_DM_LOWEST) {
 +			int l = -1;
 +			for_each_set_bit(i, &bitmap, 16) {
 +				if (!dst[i])
 +					continue;
 +				if (l < 0)
 +					l = i;
 +				else if (kvm_apic_compare_prio(dst[i]->vcpu, dst[l]->vcpu) < 0)
 +					l = i;
 +			}
 +
 +			bitmap = (l >= 0) ? 1 << l : 0;
 +		}
 +	}
 +
 +	for_each_set_bit(i, &bitmap, 16) {
 +		if (!dst[i])
 +			continue;
 +		if (*r < 0)
 +			*r = 0;
 +		*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);
 +	}
 +out:
++=======
++>>>>>>> 64aa47bfc453 (KVM: x86: add kvm_apic_map_get_dest_lapic)
  	rcu_read_unlock();
  	return ret;
  }
@@@ -780,71 -817,13 +853,78 @@@ bool kvm_intr_is_single_vcpu_fast(struc
  	rcu_read_lock();
  	map = rcu_dereference(kvm->arch.apic_map);
  
- 	if (!map)
- 		goto out;
+ 	if (kvm_apic_map_get_dest_lapic(kvm, NULL, irq, map, &dst, &bitmap) &&
+ 			hweight16(bitmap) == 1) {
+ 		unsigned long i = find_first_bit(&bitmap, 16);
  
++<<<<<<< HEAD
 +	if (irq->dest_mode == APIC_DEST_PHYSICAL) {
 +		if (irq->dest_id == 0xFF)
 +			goto out;
 +
 +		if (irq->dest_id >= ARRAY_SIZE(map->phys_map))
 +			goto out;
 +
 +		dst = map->phys_map[irq->dest_id];
 +		if (dst && kvm_apic_present(dst->vcpu))
 +			*dest_vcpu = dst->vcpu;
 +		else
 +			goto out;
 +	} else {
 +		u16 cid;
 +		unsigned long bitmap = 1;
 +		int i, r = 0;
 +
 +		if (!kvm_apic_logical_map_valid(map))
 +			goto out;
 +
 +		apic_logical_id(map, irq->dest_id, &cid, (u16 *)&bitmap);
 +
 +		if (cid >= ARRAY_SIZE(map->logical_map))
 +			goto out;
 +
 +		if (kvm_vector_hashing_enabled() &&
 +				kvm_lowest_prio_delivery(irq)) {
 +			int idx;
 +			unsigned int dest_vcpus;
 +
 +			dest_vcpus = hweight16(bitmap);
 +			if (dest_vcpus == 0)
 +				goto out;
 +
 +			idx = kvm_vector_to_index(irq->vector, dest_vcpus,
 +						  &bitmap, 16);
 +
 +			/*
 +			 * We may find a hardware disabled LAPIC here, if that
 +			 * is the case, print out a error message once for each
 +			 * guest and return
 +			 */
 +			dst = map->logical_map[cid][idx];
 +			if (!dst && !kvm->arch.disabled_lapic_found) {
 +				kvm->arch.disabled_lapic_found = true;
 +				printk(KERN_INFO
 +					"Disabled LAPIC found during irq injection\n");
 +				goto out;
 +			}
 +
 +			*dest_vcpu = dst->vcpu;
 +		} else {
 +			for_each_set_bit(i, &bitmap, 16) {
 +				dst = map->logical_map[cid][i];
 +				if (++r == 2)
 +					goto out;
 +			}
 +
 +			if (dst && kvm_apic_present(dst->vcpu))
 +				*dest_vcpu = dst->vcpu;
 +			else
 +				goto out;
++=======
+ 		if (dst[i]) {
+ 			*dest_vcpu = dst[i]->vcpu;
+ 			ret = true;
++>>>>>>> 64aa47bfc453 (KVM: x86: add kvm_apic_map_get_dest_lapic)
  		}
  	}
  
* Unmerged path arch/x86/kvm/lapic.c
