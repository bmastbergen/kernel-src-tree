IB/hfi1: Add RSM rule for user FECN handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dean Luick <dean.luick@intel.com>
commit 8f000f7f6e0ad8973f76cc64ecbc4d84099ff959
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8f000f7f.failed

Add a receive side mapping rule to extract expected user packets with
the FECN bit set and place them in an eager buffer.  This will allow
user libraries to recognize that a FECN was sent when using header
suppression and respond appropriately.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Dean Luick <dean.luick@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 8f000f7f6e0ad8973f76cc64ecbc4d84099ff959)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/chip.c
diff --cc drivers/staging/hfi1/chip.c
index 689fb76865d1,386309c67efd..000000000000
--- a/drivers/staging/hfi1/chip.c
+++ b/drivers/staging/hfi1/chip.c
@@@ -12742,12 -12630,16 +12744,14 @@@ static int set_up_context_variables(str
  	int total_contexts;
  	int ret;
  	unsigned ngroups;
+ 	int qos_rmt_count;
+ 	int user_rmt_reduced;
  
  	/*
 -	 * Kernel receive contexts:
 -	 * - min of 2 or 1 context/numa (excluding control context)
 +	 * Kernel contexts: (to be fixed later):
 +	 * - min or 2 or 1 context/numa
  	 * - Context 0 - control context (VL15/multicast/error)
 -	 * - Context 1 - first kernel context
 -	 * - Context 2 - second kernel context
 -	 * ...
 +	 * - Context 1 - default context
  	 */
  	if (n_krcvqs)
  		/*
@@@ -13635,14 -13650,86 +13652,91 @@@ bail
  	init_qpmap_table(dd, FIRST_KERNEL_KCTXT, dd->n_krcv_queues - 1);
  }
  
+ static void init_user_fecn_handling(struct hfi1_devdata *dd,
+ 				    struct rsm_map_table *rmt)
+ {
+ 	struct rsm_rule_data rrd;
+ 	u64 reg;
+ 	int i, idx, regoff, regidx;
+ 	u8 offset;
+ 
+ 	/* there needs to be enough room in the map table */
+ 	if (rmt->used + dd->num_user_contexts >= NUM_MAP_ENTRIES) {
+ 		dd_dev_err(dd, "User FECN handling disabled - too many user contexts allocated\n");
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * RSM will extract the destination context as an index into the
+ 	 * map table.  The destination contexts are a sequential block
+ 	 * in the range first_user_ctxt...num_rcv_contexts-1 (inclusive).
+ 	 * Map entries are accessed as offset + extracted value.  Adjust
+ 	 * the added offset so this sequence can be placed anywhere in
+ 	 * the table - as long as the entries themselves do not wrap.
+ 	 * There are only enough bits in offset for the table size, so
+ 	 * start with that to allow for a "negative" offset.
+ 	 */
+ 	offset = (u8)(NUM_MAP_ENTRIES + (int)rmt->used -
+ 						(int)dd->first_user_ctxt);
+ 
+ 	for (i = dd->first_user_ctxt, idx = rmt->used;
+ 				i < dd->num_rcv_contexts; i++, idx++) {
+ 		/* replace with identity mapping */
+ 		regoff = (idx % 8) * 8;
+ 		regidx = idx / 8;
+ 		reg = rmt->map[regidx];
+ 		reg &= ~(RCV_RSM_MAP_TABLE_RCV_CONTEXT_A_MASK << regoff);
+ 		reg |= (u64)i << regoff;
+ 		rmt->map[regidx] = reg;
+ 	}
+ 
+ 	/*
+ 	 * For RSM intercept of Expected FECN packets:
+ 	 * o packet type 0 - expected
+ 	 * o match on F (bit 95), using select/match 1, and
+ 	 * o match on SH (bit 133), using select/match 2.
+ 	 *
+ 	 * Use index 1 to extract the 8-bit receive context from DestQP
+ 	 * (start at bit 64).  Use that as the RSM map table index.
+ 	 */
+ 	rrd.offset = offset;
+ 	rrd.pkt_type = 0;
+ 	rrd.field1_off = 95;
+ 	rrd.field2_off = 133;
+ 	rrd.index1_off = 64;
+ 	rrd.index1_width = 8;
+ 	rrd.index2_off = 0;
+ 	rrd.index2_width = 0;
+ 	rrd.mask1 = 1;
+ 	rrd.value1 = 1;
+ 	rrd.mask2 = 1;
+ 	rrd.value2 = 1;
+ 
+ 	/* add rule 1 */
+ 	add_rsm_rule(dd, 1, &rrd);
+ 
+ 	rmt->used += dd->num_user_contexts;
+ }
+ 
  static void init_rxe(struct hfi1_devdata *dd)
  {
 -	struct rsm_map_table *rmt;
 -
  	/* enable all receive errors */
  	write_csr(dd, RCV_ERR_MASK, ~0ull);
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +	/* setup QPN map table - start where VL15 context leaves off */
 +	init_qos(
 +		dd,
 +		dd->n_krcv_queues > MIN_KERNEL_KCTXTS ? MIN_KERNEL_KCTXTS : 0);
++=======
+ 
+ 	rmt = alloc_rsm_map_table(dd);
+ 	/* set up QOS, including the QPN map table */
+ 	init_qos(dd, rmt);
+ 	init_user_fecn_handling(dd, rmt);
+ 	complete_rsm_map_table(dd, rmt);
+ 	kfree(rmt);
+ 
++>>>>>>> 8f000f7f6e0a (IB/hfi1: Add RSM rule for user FECN handling):drivers/staging/rdma/hfi1/chip.c
  	/*
  	 * make sure RcvCtrl.RcvWcb <= PCIe Device Control
  	 * Register Max_Payload_Size (PCI_EXP_DEVCTL in Linux PCIe config
* Unmerged path drivers/staging/hfi1/chip.c
