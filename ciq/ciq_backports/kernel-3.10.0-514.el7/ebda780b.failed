raid5: update analysis state for failed stripe

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Shaohua Li <shli@fb.com>
commit ebda780bce8d58ec0abab157397c9e099c41a05f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ebda780b.failed

handle_failed_stripe() makes the stripe fail, eg, all IO will return
with a failure, but it doesn't update stripe_head_state. Later
handle_stripe() has special handling for raid6 for handle_stripe_fill().
That check before handle_stripe_fill() doesn't skip the failed stripe
and we get a kernel crash in need_this_block.  This patch clear the
analysis state to make sure no functions wrongly called after
handle_failed_stripe()

	Signed-off-by: Shaohua Li <shli@fb.com>
	Signed-off-by: NeilBrown <neilb@suse.com>
(cherry picked from commit ebda780bce8d58ec0abab157397c9e099c41a05f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5.c
diff --cc drivers/md/raid5.c
index 5e75c2e2a98e,2105e5f1fd31..000000000000
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@@ -3147,7 -3150,9 +3147,13 @@@ handle_failed_stripe(struct r5conf *con
  			spin_unlock_irq(&sh->stripe_lock);
  			if (test_and_clear_bit(R5_Overlap, &sh->dev[i].flags))
  				wake_up(&conf->wait_for_overlap);
++<<<<<<< HEAD
 +			while (bi && bi->bi_sector <
++=======
+ 			if (bi)
+ 				s->to_read--;
+ 			while (bi && bi->bi_iter.bi_sector <
++>>>>>>> ebda780bce8d (raid5: update analysis state for failed stripe)
  			       sh->dev[i].sector + STRIPE_SECTORS) {
  				struct bio *nextbi =
  					r5_next_bio(bi, sh->dev[i].sector);
* Unmerged path drivers/md/raid5.c
