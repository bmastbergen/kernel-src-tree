perf: Fix STATE_EXIT usage

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit 6e801e016917989ab8a7ddfc4229a15a5621622a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6e801e01.failed

We should never attempt to enable a STATE_EXIT event.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 6e801e016917989ab8a7ddfc4229a15a5621622a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/core.c
diff --cc kernel/events/core.c
index e086d60d319b,d84374fa44e5..000000000000
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@@ -2146,44 -2245,30 +2146,50 @@@ static void __perf_event_mark_enabled(s
  /*
   * Cross CPU call to enable a performance event
   */
 -static void __perf_event_enable(struct perf_event *event,
 -				struct perf_cpu_context *cpuctx,
 -				struct perf_event_context *ctx,
 -				void *info)
 +static int __perf_event_enable(void *info)
  {
 +	struct perf_event *event = info;
 +	struct perf_event_context *ctx = event->ctx;
  	struct perf_event *leader = event->group_leader;
 -	struct perf_event_context *task_ctx;
 +	struct perf_cpu_context *cpuctx = __get_cpu_context(ctx);
 +	struct perf_event_context *task_ctx = cpuctx->task_ctx;
  
 +	/*
 +	 * There's a time window between 'ctx->is_active' check
 +	 * in perf_event_enable function and this place having:
 +	 *   - IRQs on
 +	 *   - ctx->lock unlocked
 +	 *
 +	 * where the task could be killed and 'ctx' deactivated
 +	 * by perf_event_exit_task.
 +	 */
 +	if (!ctx->is_active)
 +		return -EINVAL;
 +
 +	perf_ctx_lock(cpuctx, task_ctx);
 +	WARN_ON_ONCE(&cpuctx->ctx != ctx && task_ctx != ctx);
 +	update_context_time(ctx);
 +
++<<<<<<< HEAD
 +	if (event->state >= PERF_EVENT_STATE_INACTIVE)
 +		goto unlock;
 +
 +	/*
 +	 * set current task's cgroup time reference point
 +	 */
 +	perf_cgroup_set_timestamp(current, ctx);
++=======
+ 	if (event->state >= PERF_EVENT_STATE_INACTIVE ||
+ 	    event->state <= PERF_EVENT_STATE_ERROR)
+ 		return;
++>>>>>>> 6e801e016917 (perf: Fix STATE_EXIT usage)
  
 -	update_context_time(ctx);
  	__perf_event_mark_enabled(event);
  
 -	if (!ctx->is_active)
 -		return;
 -
  	if (!event_filter_match(event)) {
 -		if (is_cgroup_event(event)) {
 -			perf_cgroup_set_timestamp(current, ctx); // XXX ?
 +		if (is_cgroup_event(event))
  			perf_cgroup_defer_enabled(event);
 -		}
 -		return;
 +		goto unlock;
  	}
  
  	/*
* Unmerged path kernel/events/core.c
