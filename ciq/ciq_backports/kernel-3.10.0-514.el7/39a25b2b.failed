ovl: define ->get_acl() for overlay inodes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vivek Goyal <vgoyal@redhat.com>
commit 39a25b2b37629f65e5a1eba1b353d0b47687c2ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/39a25b2b.failed

Now we are planning to do DAC permission checks on overlay inode
itself. And to make it work, we will need to make sure we can get acls from
underlying inode. So define ->get_acl() for overlay inodes and this in turn
calls into underlying filesystem to get acls, if any.

	Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 39a25b2b37629f65e5a1eba1b353d0b47687c2ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/dir.c
#	fs/overlayfs/inode.c
#	fs/overlayfs/overlayfs.h
diff --cc fs/overlayfs/dir.c
index a1caf19083f8,aa6320557196..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -912,6 -921,5 +912,10 @@@ const struct inode_operations_wrapper o
  	.getxattr	= ovl_getxattr,
  	.listxattr	= ovl_listxattr,
  	.removexattr	= ovl_removexattr,
++<<<<<<< HEAD
 +	},
 +	.rename2	= ovl_rename2,
++=======
+ 	.get_acl	= ovl_get_acl,
++>>>>>>> 39a25b2b3762 (ovl: define ->get_acl() for overlay inodes)
  };
diff --cc fs/overlayfs/inode.c
index cec7c3f64b1e,a574108f52a8..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -399,8 -370,7 +415,12 @@@ static const struct inode_operations_wr
  	.getxattr	= ovl_getxattr,
  	.listxattr	= ovl_listxattr,
  	.removexattr	= ovl_removexattr,
++<<<<<<< HEAD
 +	},
 +	.dentry_open	= ovl_dentry_open,
++=======
+ 	.get_acl	= ovl_get_acl,
++>>>>>>> 39a25b2b3762 (ovl: define ->get_acl() for overlay inodes)
  };
  
  static const struct inode_operations ovl_symlink_inode_operations = {
diff --cc fs/overlayfs/overlayfs.h
index 26a0f54fc56c,75128c70aa6a..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -172,12 -173,15 +173,17 @@@ int ovl_check_d_type_supported(struct p
  /* inode.c */
  int ovl_setattr(struct dentry *dentry, struct iattr *attr);
  int ovl_permission(struct inode *inode, int mask);
 -int ovl_setxattr(struct dentry *dentry, struct inode *inode,
 -		 const char *name, const void *value,
 -		 size_t size, int flags);
 -ssize_t ovl_getxattr(struct dentry *dentry, struct inode *inode,
 -		     const char *name, void *value, size_t size);
 +int ovl_setxattr(struct dentry *dentry, const char *name,
 +		 const void *value, size_t size, int flags);
 +ssize_t ovl_getxattr(struct dentry *dentry, const char *name,
 +		     void *value, size_t size);
  ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
  int ovl_removexattr(struct dentry *dentry, const char *name);
++<<<<<<< HEAD
++=======
+ struct posix_acl *ovl_get_acl(struct inode *inode, int type);
+ int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
++>>>>>>> 39a25b2b3762 (ovl: define ->get_acl() for overlay inodes)
  
  struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,
  			    struct ovl_entry *oe);
* Unmerged path fs/overlayfs/dir.c
* Unmerged path fs/overlayfs/inode.c
* Unmerged path fs/overlayfs/overlayfs.h
diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c
index 5c0fb1f1eab2..88ca333bdd15 100644
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@ -157,6 +157,13 @@ struct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper)
 	return realdentry;
 }
 
+struct inode *ovl_inode_real(struct inode *inode)
+{
+	bool tmp;
+
+	return d_inode(ovl_entry_real(inode->i_private, &tmp));
+}
+
 struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 				    bool is_upper)
 {
@@ -1146,6 +1153,7 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)
 	sb->s_op = &ovl_super_operations;
 	sb->s_root = root_dentry;
 	sb->s_fs_info = ufs;
+	sb->s_flags |= MS_POSIXACL;
 
 	return 0;
 
