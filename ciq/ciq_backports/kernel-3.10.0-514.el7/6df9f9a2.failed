gfs2: Lock holder cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 6df9f9a253c7dc9f8ed18bf89d762de350a31813
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6df9f9a2.failed

Make the code more readable by cleaning up the different ways of
initializing lock holders and checking for initialized lock holders:
mark lock holders as uninitialized by setting the holder's glock to NULL
(gfs2_holder_mark_uninitialized) instead of zeroing out the entire
object or using a separate flag.  Recognize initialized holders by their
non-NULL glock (gfs2_holder_initialized).  Don't zero out holder objects
which are immeditiately initialized via gfs2_holder_init or
gfs2_glock_nq_init.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 6df9f9a253c7dc9f8ed18bf89d762de350a31813)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/dentry.c
#	fs/gfs2/file.c
#	fs/gfs2/inode.c
#	fs/gfs2/super.c
diff --cc fs/gfs2/dentry.c
index d3a5d4e29ba5,5173b98ca036..000000000000
--- a/fs/gfs2/dentry.c
+++ b/fs/gfs2/dentry.c
@@@ -116,11 -113,11 +116,16 @@@ static int gfs2_dentry_delete(const str
  {
  	struct gfs2_inode *ginode;
  
 -	if (d_really_is_negative(dentry))
 +	if (!dentry->d_inode)
  		return 0;
  
++<<<<<<< HEAD
 +	ginode = GFS2_I(dentry->d_inode);
 +	if (!ginode->i_iopen_gh.gh_gl)
++=======
+ 	ginode = GFS2_I(d_inode(dentry));
+ 	if (!gfs2_holder_initialized(&ginode->i_iopen_gh))
++>>>>>>> 6df9f9a253c7 (gfs2: Lock holder cleanup)
  		return 0;
  
  	if (test_bit(GLF_DEMOTE, &ginode->i_iopen_gh.gh_gl->gl_flags))
diff --cc fs/gfs2/file.c
index 1c8355288e7e,320e65e61938..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -1126,8 -1097,8 +1126,13 @@@ static void do_unflock(struct file *fil
  	struct gfs2_holder *fl_gh = &fp->f_fl_gh;
  
  	mutex_lock(&fp->f_fl_mutex);
++<<<<<<< HEAD
 +	flock_lock_file_wait(file, fl);
 +	if (fl_gh->gh_gl) {
++=======
+ 	locks_lock_file_wait(file, fl);
+ 	if (gfs2_holder_initialized(fl_gh)) {
++>>>>>>> 6df9f9a253c7 (gfs2: Lock holder cleanup)
  		gfs2_glock_dq(fl_gh);
  		gfs2_holder_uninit(fl_gh);
  	}
diff --cc fs/gfs2/inode.c
index afe33e59be1b,de54d605cd09..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -92,14 -126,15 +92,25 @@@ struct inode *gfs2_inode_lookup(struct 
  	struct inode *inode;
  	struct gfs2_inode *ip;
  	struct gfs2_glock *io_gl = NULL;
++<<<<<<< HEAD
 +	int error;
 +
 +	inode = iget_locked(sb, (unsigned long)no_addr);
++=======
+ 	struct gfs2_holder i_gh;
+ 	int error;
+ 
+ 	gfs2_holder_mark_uninitialized(&i_gh);
+ 	inode = gfs2_iget(sb, no_addr);
+ 	if (!inode)
+ 		return ERR_PTR(-ENOMEM);
+ 
++>>>>>>> 6df9f9a253c7 (gfs2: Lock holder cleanup)
  	ip = GFS2_I(inode);
 +	ip->i_no_addr = no_addr;
 +
 +	if (!inode)
 +		return ERR_PTR(-ENOBUFS);
  
  	if (inode->i_state & I_NEW) {
  		struct gfs2_sbd *sdp = GFS2_SB(inode);
@@@ -114,6 -149,25 +125,28 @@@
  		if (unlikely(error))
  			goto fail_put;
  
++<<<<<<< HEAD
++=======
+ 		if (type == DT_UNKNOWN || blktype != GFS2_BLKST_FREE) {
+ 			/*
+ 			 * The GL_SKIP flag indicates to skip reading the inode
+ 			 * block.  We read the inode with gfs2_inode_refresh
+ 			 * after possibly checking the block type.
+ 			 */
+ 			error = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE,
+ 						   GL_SKIP, &i_gh);
+ 			if (error)
+ 				goto fail_put;
+ 
+ 			if (blktype != GFS2_BLKST_FREE) {
+ 				error = gfs2_check_blk_type(sdp, no_addr,
+ 							    blktype);
+ 				if (error)
+ 					goto fail_put;
+ 			}
+ 		}
+ 
++>>>>>>> 6df9f9a253c7 (gfs2: Lock holder cleanup)
  		set_bit(GIF_INVALID, &ip->i_flags);
  		error = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);
  		if (unlikely(error))
@@@ -136,6 -190,8 +169,11 @@@
  		unlock_new_inode(inode);
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (gfs2_holder_initialized(&i_gh))
+ 		gfs2_glock_dq_uninit(&i_gh);
++>>>>>>> 6df9f9a253c7 (gfs2: Lock holder cleanup)
  	return inode;
  
  fail_refresh:
@@@ -143,10 -199,11 +181,15 @@@
  	ip->i_iopen_gh.gh_gl->gl_object = NULL;
  	gfs2_glock_dq_wait(&ip->i_iopen_gh);
  	gfs2_holder_uninit(&ip->i_iopen_gh);
 -fail_put:
 +fail_iopen:
  	if (io_gl)
  		gfs2_glock_put(io_gl);
++<<<<<<< HEAD
 +fail_put:
++=======
+ 	if (gfs2_holder_initialized(&i_gh))
+ 		gfs2_glock_dq_uninit(&i_gh);
++>>>>>>> 6df9f9a253c7 (gfs2: Lock holder cleanup)
  	ip->i_gl->gl_object = NULL;
  fail:
  	iget_failed(inode);
@@@ -1253,10 -1349,10 +1295,10 @@@ static int gfs2_rename(struct inode *od
  {
  	struct gfs2_inode *odip = GFS2_I(odir);
  	struct gfs2_inode *ndip = GFS2_I(ndir);
 -	struct gfs2_inode *ip = GFS2_I(d_inode(odentry));
 +	struct gfs2_inode *ip = GFS2_I(odentry->d_inode);
  	struct gfs2_inode *nip = NULL;
  	struct gfs2_sbd *sdp = GFS2_SB(odir);
- 	struct gfs2_holder ghs[5], r_gh = { .gh_gl = NULL, };
+ 	struct gfs2_holder ghs[5], r_gh;
  	struct gfs2_rgrpd *nrgd;
  	unsigned int num_gh;
  	int dir_rename = 0;
@@@ -1264,8 -1360,9 +1306,14 @@@
  	unsigned int x;
  	int error;
  
++<<<<<<< HEAD
 +	if (ndentry->d_inode) {
 +		nip = GFS2_I(ndentry->d_inode);
++=======
+ 	gfs2_holder_mark_uninitialized(&r_gh);
+ 	if (d_really_is_positive(ndentry)) {
+ 		nip = GFS2_I(d_inode(ndentry));
++>>>>>>> 6df9f9a253c7 (gfs2: Lock holder cleanup)
  		if (ip == nip)
  			return 0;
  	}
diff --cc fs/gfs2/super.c
index 5c8a97adb7fd,3a7e60bb39f8..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -839,18 -851,12 +839,23 @@@ static int gfs2_make_fs_ro(struct gfs2_
  	gfs2_quota_sync(sdp->sd_vfs, 0);
  	gfs2_statfs_sync(sdp->sd_vfs, 0);
  
 -	gfs2_log_flush(sdp, NULL, SHUTDOWN_FLUSH);
 -	wait_event(sdp->sd_reserving_log_wait, atomic_read(&sdp->sd_reserving_log) == 0);
 -	gfs2_assert_warn(sdp, atomic_read(&sdp->sd_log_blks_free) == sdp->sd_jdesc->jd_blocks);
 +	error = gfs2_glock_nq_init(sdp->sd_trans_gl, LM_ST_SHARED, GL_NOCACHE,
 +				   &t_gh);
 +	if (error && !test_bit(SDF_SHUTDOWN, &sdp->sd_flags))
 +		return error;
 +
++<<<<<<< HEAD
 +	gfs2_meta_syncfs(sdp);
 +	gfs2_log_shutdown(sdp);
  
 +	clear_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags);
 +
 +	if (t_gh.gh_gl)
 +		gfs2_glock_dq_uninit(&t_gh);
++=======
+ 	if (gfs2_holder_initialized(&freeze_gh))
+ 		gfs2_glock_dq_uninit(&freeze_gh);
++>>>>>>> 6df9f9a253c7 (gfs2: Lock holder cleanup)
  
  	gfs2_quota_cleanup(sdp);
  
@@@ -992,7 -1031,15 +997,17 @@@ static int gfs2_unfreeze(struct super_b
  {
  	struct gfs2_sbd *sdp = sb->s_fs_info;
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&sdp->sd_freeze_mutex);
+         if (atomic_read(&sdp->sd_freeze_state) != SFS_FROZEN ||
+ 	    !gfs2_holder_initialized(&sdp->sd_freeze_gh)) {
+ 		mutex_unlock(&sdp->sd_freeze_mutex);
+                 return 0;
+ 	}
+ 
++>>>>>>> 6df9f9a253c7 (gfs2: Lock holder cleanup)
  	gfs2_glock_dq_uninit(&sdp->sd_freeze_gh);
 -	mutex_unlock(&sdp->sd_freeze_mutex);
  	return 0;
  }
  
@@@ -1554,10 -1611,10 +1573,10 @@@ out_truncate
  
  out_unlock:
  	/* Error path for case 1 */
 -	if (gfs2_rs_active(&ip->i_res))
 -		gfs2_rs_deltree(&ip->i_res);
 +	if (gfs2_rs_active(ip->i_res))
 +		gfs2_rs_deltree(ip->i_res);
  
- 	if (ip->i_iopen_gh.gh_gl) {
+ 	if (gfs2_holder_initialized(&ip->i_iopen_gh)) {
  		if (test_bit(HIF_HOLDER, &ip->i_iopen_gh.gh_iflags)) {
  			ip->i_iopen_gh.gh_flags |= GL_NOCACHE;
  			gfs2_glock_dq_wait(&ip->i_iopen_gh);
* Unmerged path fs/gfs2/dentry.c
* Unmerged path fs/gfs2/file.c
diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index 8d60e81f5dfd..dcc19b384676 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -849,7 +849,7 @@ void gfs2_holder_uninit(struct gfs2_holder *gh)
 {
 	put_pid(gh->gh_owner_pid);
 	gfs2_glock_put(gh->gh_gl);
-	gh->gh_gl = NULL;
+	gfs2_holder_mark_uninitialized(gh);
 	gh->gh_ip = 0;
 }
 
diff --git a/fs/gfs2/glock.h b/fs/gfs2/glock.h
index 6647d77366ba..14ff3e6e010a 100644
--- a/fs/gfs2/glock.h
+++ b/fs/gfs2/glock.h
@@ -247,4 +247,14 @@ extern void gfs2_unregister_debugfs(void);
 
 extern const struct lm_lockops gfs2_dlm_ops;
 
+static inline void gfs2_holder_mark_uninitialized(struct gfs2_holder *gh)
+{
+	gh->gh_gl = NULL;
+}
+
+static inline bool gfs2_holder_initialized(struct gfs2_holder *gh)
+{
+	return gh->gh_gl;
+}
+
 #endif /* __GLOCK_DOT_H__ */
* Unmerged path fs/gfs2/inode.c
diff --git a/fs/gfs2/main.c b/fs/gfs2/main.c
index 6144ccf87adf..adb896a50636 100644
--- a/fs/gfs2/main.c
+++ b/fs/gfs2/main.c
@@ -40,7 +40,7 @@ static void gfs2_init_inode_once(void *foo)
 	INIT_LIST_HEAD(&ip->i_trunc_list);
 	ip->i_res = NULL;
 	ip->i_hash_cache = NULL;
-	ip->i_iopen_gh.gh_gl = NULL;
+	gfs2_holder_mark_uninitialized(&ip->i_iopen_gh);
 }
 
 static void gfs2_init_glock_once(void *foo)
diff --git a/fs/gfs2/quota.c b/fs/gfs2/quota.c
index 481208bbcaf7..724448e9d999 100644
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@ -841,7 +841,7 @@ static int do_sync(unsigned int num_qd, struct gfs2_quota_data **qda)
 	gfs2_write_calc_reserv(ip, sizeof(struct gfs2_quota),
 			      &data_blocks, &ind_blocks);
 
-	ghs = kcalloc(num_qd, sizeof(struct gfs2_holder), GFP_NOFS);
+	ghs = kmalloc(num_qd * sizeof(struct gfs2_holder), GFP_NOFS);
 	if (!ghs)
 		return -ENOMEM;
 
diff --git a/fs/gfs2/rgrp.c b/fs/gfs2/rgrp.c
index a8aed1b6a8b1..1465954976ed 100644
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@ -2081,7 +2081,7 @@ void gfs2_inplace_release(struct gfs2_inode *ip)
 {
 	struct gfs2_blkreserv *rs = ip->i_res;
 
-	if (rs->rs_rgd_gh.gh_gl)
+	if (gfs2_holder_initialized(&rs->rs_rgd_gh))
 		gfs2_glock_dq_uninit(&rs->rs_rgd_gh);
 }
 
@@ -2557,7 +2557,7 @@ void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state)
 {
 	unsigned int x;
 
-	rlist->rl_ghs = kcalloc(rlist->rl_rgrps, sizeof(struct gfs2_holder),
+	rlist->rl_ghs = kmalloc(rlist->rl_rgrps * sizeof(struct gfs2_holder),
 				GFP_NOFS | __GFP_NOFAIL);
 	for (x = 0; x < rlist->rl_rgrps; x++)
 		gfs2_holder_init(rlist->rl_rgd[x]->rd_gl,
* Unmerged path fs/gfs2/super.c
