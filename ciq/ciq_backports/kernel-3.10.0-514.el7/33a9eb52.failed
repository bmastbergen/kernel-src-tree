IB/hfi1: Fix QOS rule mappings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dean Luick <dean.luick@intel.com>
commit 33a9eb527172cb46711705c858ccd605e32c82f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/33a9eb52.failed

The QOS RSM rule mappings are off by one, referencing a kernel receive
context that does not exist.

Correctly start the QOS RSM map entries at FIRST_KERNEL_CONTEXT rather
than MIN_KERNEL_KCTXTS.  Remove the cruft that hid this.

Change the QP map table so all traffic not caught by QOS RSM goes to
the control context rather than the first QOS context.

Correct comments to match the actual code operation and intent.

	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Dean Luick <dean.luick@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 33a9eb527172cb46711705c858ccd605e32c82f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/chip.c
diff --cc drivers/staging/hfi1/chip.c
index 46f1612f1411,79dc29ae6e68..000000000000
--- a/drivers/staging/hfi1/chip.c
+++ b/drivers/staging/hfi1/chip.c
@@@ -12751,15 -12684,13 +12753,13 @@@ static int set_up_context_variables(str
  	 */
  	if (n_krcvqs)
  		/*
- 		 * Don't count context 0 in n_krcvqs since
- 		 * is isn't used for normal verbs traffic.
- 		 *
- 		 * krcvqs will reflect number of kernel
- 		 * receive contexts above 0.
+ 		 * n_krcvqs is the sum of module parameter kernel receive
+ 		 * contexts, krcvqs[].  It does not include the control
+ 		 * context, so add that.
  		 */
- 		num_kernel_contexts = n_krcvqs + MIN_KERNEL_KCTXTS - 1;
+ 		num_kernel_contexts = n_krcvqs + 1;
  	else
 -		num_kernel_contexts = num_online_nodes() + 1;
 +		num_kernel_contexts = num_online_nodes();
  	num_kernel_contexts =
  		max_t(int, MIN_KERNEL_KCTXTS, num_kernel_contexts);
  	/*
@@@ -13610,22 -13540,21 +13605,28 @@@ static void init_qos(struct hfi1_devdat
  		write_csr(dd, RCV_RSM_MAP_TABLE + (8 * i), rsmmap[i]);
  	/* add rule0 */
  	write_csr(dd, RCV_RSM_CFG /* + (8 * 0) */,
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +		RCV_RSM_CFG_ENABLE_OR_CHAIN_RSM0_MASK
 +			<< RCV_RSM_CFG_ENABLE_OR_CHAIN_RSM0_SHIFT |
 +		2ull << RCV_RSM_CFG_PACKET_TYPE_SHIFT);
++=======
+ 		  RCV_RSM_CFG_ENABLE_OR_CHAIN_RSM0_MASK <<
+ 			RCV_RSM_CFG_ENABLE_OR_CHAIN_RSM0_SHIFT |
+ 		  2ull << RCV_RSM_CFG_PACKET_TYPE_SHIFT);
++>>>>>>> 33a9eb527172 (IB/hfi1: Fix QOS rule mappings):drivers/staging/rdma/hfi1/chip.c
  	write_csr(dd, RCV_RSM_SELECT /* + (8 * 0) */,
 -		  LRH_BTH_MATCH_OFFSET << RCV_RSM_SELECT_FIELD1_OFFSET_SHIFT |
 -		  LRH_SC_MATCH_OFFSET << RCV_RSM_SELECT_FIELD2_OFFSET_SHIFT |
 -		  LRH_SC_SELECT_OFFSET << RCV_RSM_SELECT_INDEX1_OFFSET_SHIFT |
 -		  ((u64)n) << RCV_RSM_SELECT_INDEX1_WIDTH_SHIFT |
 -		  QPN_SELECT_OFFSET << RCV_RSM_SELECT_INDEX2_OFFSET_SHIFT |
 -		  ((u64)m + (u64)n) << RCV_RSM_SELECT_INDEX2_WIDTH_SHIFT);
 +		LRH_BTH_MATCH_OFFSET
 +			<< RCV_RSM_SELECT_FIELD1_OFFSET_SHIFT |
 +		LRH_SC_MATCH_OFFSET << RCV_RSM_SELECT_FIELD2_OFFSET_SHIFT |
 +		LRH_SC_SELECT_OFFSET << RCV_RSM_SELECT_INDEX1_OFFSET_SHIFT |
 +		((u64)n) << RCV_RSM_SELECT_INDEX1_WIDTH_SHIFT |
 +		QPN_SELECT_OFFSET << RCV_RSM_SELECT_INDEX2_OFFSET_SHIFT |
 +		((u64)m + (u64)n) << RCV_RSM_SELECT_INDEX2_WIDTH_SHIFT);
  	write_csr(dd, RCV_RSM_MATCH /* + (8 * 0) */,
 -		  LRH_BTH_MASK << RCV_RSM_MATCH_MASK1_SHIFT |
 -		  LRH_BTH_VALUE << RCV_RSM_MATCH_VALUE1_SHIFT |
 -		  LRH_SC_MASK << RCV_RSM_MATCH_MASK2_SHIFT |
 -		  LRH_SC_VALUE << RCV_RSM_MATCH_VALUE2_SHIFT);
 +		LRH_BTH_MASK << RCV_RSM_MATCH_MASK1_SHIFT |
 +		LRH_BTH_VALUE << RCV_RSM_MATCH_VALUE1_SHIFT |
 +		LRH_SC_MASK << RCV_RSM_MATCH_MASK2_SHIFT |
 +		LRH_SC_VALUE << RCV_RSM_MATCH_VALUE2_SHIFT);
  	/* Enable RSM */
  	add_rcvctrl(dd, RCV_CTRL_RCV_RSM_ENABLE_SMASK);
  	kfree(rsmmap);
@@@ -13643,9 -13572,7 +13644,13 @@@ static void init_rxe(struct hfi1_devdat
  	/* enable all receive errors */
  	write_csr(dd, RCV_ERR_MASK, ~0ull);
  	/* setup QPN map table - start where VL15 context leaves off */
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +	init_qos(
 +		dd,
 +		dd->n_krcv_queues > MIN_KERNEL_KCTXTS ? MIN_KERNEL_KCTXTS : 0);
++=======
+ 	init_qos(dd);
++>>>>>>> 33a9eb527172 (IB/hfi1: Fix QOS rule mappings):drivers/staging/rdma/hfi1/chip.c
  	/*
  	 * make sure RcvCtrl.RcvWcb <= PCIe Device Control
  	 * Register Max_Payload_Size (PCI_EXP_DEVCTL in Linux PCIe config
* Unmerged path drivers/staging/hfi1/chip.c
