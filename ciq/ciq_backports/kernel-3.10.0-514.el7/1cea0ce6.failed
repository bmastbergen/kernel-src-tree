KVM: VMX: drop rdtscp_enabled field

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xiao Guangrong <guangrong.xiao@linux.intel.com>
commit 1cea0ce68ed76490ffa64a9e2a7a40104efe9352
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1cea0ce6.failed

Check cpuid bit instead of it

	Signed-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 1cea0ce68ed76490ffa64a9e2a7a40104efe9352)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.h
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/cpuid.h
index c346c610bd63,d434ee952b00..000000000000
--- a/arch/x86/kvm/cpuid.h
+++ b/arch/x86/kvm/cpuid.h
@@@ -127,4 -133,20 +127,23 @@@ static inline bool guest_cpuid_has_mpx(
  	best = kvm_find_cpuid_entry(vcpu, 7, 0);
  	return best && (best->ebx & bit(X86_FEATURE_MPX));
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline bool guest_cpuid_has_pcommit(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvm_cpuid_entry2 *best;
+ 
+ 	best = kvm_find_cpuid_entry(vcpu, 7, 0);
+ 	return best && (best->ebx & bit(X86_FEATURE_PCOMMIT));
+ }
+ 
+ static inline bool guest_cpuid_has_rdtscp(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvm_cpuid_entry2 *best;
+ 
+ 	best = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);
+ 	return best && (best->edx & bit(X86_FEATURE_RDTSCP));
+ }
++>>>>>>> 1cea0ce68ed7 (KVM: VMX: drop rdtscp_enabled field)
  #endif
diff --cc arch/x86/kvm/vmx.c
index 5076c6cc9e1b,6f3f97f6e248..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -2573,8 -2667,13 +2571,8 @@@ static int vmx_get_msr(struct kvm_vcpu 
  		if (!nested_vmx_allowed(vcpu))
  			return 1;
  		return vmx_get_vmx_msr(vcpu, msr_info->index, &msr_info->data);
 -	case MSR_IA32_XSS:
 -		if (!vmx_xsaves_supported())
 -			return 1;
 -		msr_info->data = vcpu->arch.ia32_xss;
 -		break;
  	case MSR_TSC_AUX:
- 		if (!to_vmx(vcpu)->rdtscp_enabled)
+ 		if (!guest_cpuid_has_rdtscp(vcpu))
  			return 1;
  		/* Otherwise falls through */
  	default:
@@@ -2664,8 -2762,24 +2662,8 @@@ static int vmx_set_msr(struct kvm_vcpu 
  		break;
  	case MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:
  		return 1; /* they are read-only */
 -	case MSR_IA32_XSS:
 -		if (!vmx_xsaves_supported())
 -			return 1;
 -		/*
 -		 * The only supported bit as of Skylake is bit 8, but
 -		 * it is not supported on KVM.
 -		 */
 -		if (data != 0)
 -			return 1;
 -		vcpu->arch.ia32_xss = data;
 -		if (vcpu->arch.ia32_xss != host_xss)
 -			add_atomic_switch_msr(vmx, MSR_IA32_XSS,
 -				vcpu->arch.ia32_xss, host_xss);
 -		else
 -			clear_atomic_switch_msr(vmx, MSR_IA32_XSS);
 -		break;
  	case MSR_TSC_AUX:
- 		if (!vmx->rdtscp_enabled)
+ 		if (!guest_cpuid_has_rdtscp(vcpu))
  			return 1;
  		/* Check reserved bit, higher 32 bits should be zero */
  		if ((data >> 32) != 0)
@@@ -8363,20 -8678,20 +8361,33 @@@ static void vmx_cpuid_update(struct kvm
  {
  	struct kvm_cpuid_entry2 *best;
  	struct vcpu_vmx *vmx = to_vmx(vcpu);
 -	u32 secondary_exec_ctl = vmx_secondary_exec_control(vmx);
 +	u32 exec_control;
  
- 	vmx->rdtscp_enabled = false;
  	if (vmx_rdtscp_supported()) {
++<<<<<<< HEAD
 +		exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);
 +		if (exec_control & SECONDARY_EXEC_RDTSCP) {
 +			best = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);
 +			if (best && (best->edx & bit(X86_FEATURE_RDTSCP)))
 +				vmx->rdtscp_enabled = true;
 +			else {
 +				exec_control &= ~SECONDARY_EXEC_RDTSCP;
 +				vmcs_write32(SECONDARY_VM_EXEC_CONTROL,
 +						exec_control);
 +			}
++=======
+ 		bool rdtscp_enabled = guest_cpuid_has_rdtscp(vcpu);
+ 		if (!rdtscp_enabled)
+ 			secondary_exec_ctl &= ~SECONDARY_EXEC_RDTSCP;
+ 
+ 		if (nested) {
+ 			if (rdtscp_enabled)
+ 				vmx->nested.nested_vmx_secondary_ctls_high |=
+ 					SECONDARY_EXEC_RDTSCP;
+ 			else
+ 				vmx->nested.nested_vmx_secondary_ctls_high &=
+ 					~SECONDARY_EXEC_RDTSCP;
++>>>>>>> 1cea0ce68ed7 (KVM: VMX: drop rdtscp_enabled field)
  		}
  	}
  
* Unmerged path arch/x86/kvm/cpuid.h
* Unmerged path arch/x86/kvm/vmx.c
