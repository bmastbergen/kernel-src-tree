ovl: fix sgid on directory

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit bb0d2b8ad29630b580ac903f989e704e23462357
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bb0d2b8a.failed

When creating directory in workdir, the group/sgid inheritance from the
parent dir was omitted completely.  Fix this by calling inode_init_owner()
on overlay inode and using the resulting uid/gid/mode to create the file.

Unfortunately the sgid bit can be stripped off due to umask, so need to
reset the mode in this case in workdir before moving the directory in
place.

	Reported-by: Eryu Guan <eguan@redhat.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit bb0d2b8ad29630b580ac903f989e704e23462357)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/dir.c
diff --cc fs/overlayfs/dir.c
index 02a117bdec65,8beeed34dad6..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -391,8 -409,9 +406,7 @@@ static int ovl_create_or_link(struct de
  {
  	int err;
  	struct inode *inode;
 -	const struct cred *old_cred;
 -	struct cred *override_cred;
  	struct kstat stat = {
- 		.mode = mode,
  		.rdev = rdev,
  	};
  
@@@ -405,30 -424,34 +419,55 @@@
  	if (err)
  		goto out_iput;
  
++<<<<<<< HEAD
 +	if (!ovl_dentry_is_opaque(dentry)) {
 +		err = ovl_create_upper(dentry, inode, &stat, link, hardlink);
 +	} else {
 +		const struct cred *old_cred;
 +		struct cred *override_cred;
 +
 +		old_cred = ovl_override_creds(dentry->d_sb);
 +
 +		err = -ENOMEM;
 +		override_cred = prepare_creds();
 +		if (override_cred) {
 +			override_cred->fsuid = old_cred->fsuid;
 +			override_cred->fsgid = old_cred->fsgid;
 +			put_cred(override_creds(override_cred));
 +			put_cred(override_cred);
++=======
+ 	inode_init_owner(inode, dentry->d_parent->d_inode, mode);
+ 	stat.mode = inode->i_mode;
+ 
+ 	old_cred = ovl_override_creds(dentry->d_sb);
+ 	err = -ENOMEM;
+ 	override_cred = prepare_creds();
+ 	if (override_cred) {
+ 		override_cred->fsuid = inode->i_uid;
+ 		override_cred->fsgid = inode->i_gid;
+ 		put_cred(override_creds(override_cred));
+ 		put_cred(override_cred);
++>>>>>>> bb0d2b8ad296 (ovl: fix sgid on directory)
  
 -		if (!ovl_dentry_is_opaque(dentry))
 -			err = ovl_create_upper(dentry, inode, &stat, link,
 -						hardlink);
 -		else
  			err = ovl_create_over_whiteout(dentry, inode, &stat,
 -							link, hardlink);
 +						       link, hardlink);
 +		}
 +		revert_creds(old_cred);
  	}
++<<<<<<< HEAD
 +
 +	if (!err)
++=======
+ 	revert_creds(old_cred);
+ 	if (!err) {
+ 		struct inode *realinode = d_inode(ovl_dentry_upper(dentry));
+ 
+ 		WARN_ON(inode->i_mode != realinode->i_mode);
+ 		WARN_ON(!uid_eq(inode->i_uid, realinode->i_uid));
+ 		WARN_ON(!gid_eq(inode->i_gid, realinode->i_gid));
++>>>>>>> bb0d2b8ad296 (ovl: fix sgid on directory)
  		inode = NULL;
+ 	}
  out_iput:
  	iput(inode);
  out:
* Unmerged path fs/overlayfs/dir.c
