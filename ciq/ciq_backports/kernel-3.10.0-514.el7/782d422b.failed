KVM: x86: split kvm_vcpu_ready_for_interrupt_injection out of dm_request_for_irq_injection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matt Gingell <gingell@google.com>
commit 782d422bcaee4680c640fbc8ce8c45524fd11790
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/782d422b.failed

This patch breaks out a new function kvm_vcpu_ready_for_interrupt_injection.
This routine encapsulates the logic required to determine whether a vcpu
is ready to accept an interrupt injection, which is now required on
multiple paths.

	Reviewed-by: Steve Rutherford <srutherford@google.com>
	Signed-off-by: Matt Gingell <gingell@google.com>
Fixes: 1c1a9ce973a7863dd46767226bce2a5f12d48bc6
	Cc: stable@vger.kernel.org
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 782d422bcaee4680c640fbc8ce8c45524fd11790)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index 733894b44f8d,32f6b760682c..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -3064,6 -2763,26 +3064,29 @@@ static int kvm_vcpu_ioctl_set_lapic(str
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)
+ {
+ 	return (!lapic_in_kernel(vcpu) ||
+ 		kvm_apic_accept_pic_intr(vcpu));
+ }
+ 
+ /*
+  * if userspace requested an interrupt window, check that the
+  * interrupt window is open.
+  *
+  * No need to exit to userspace if we already have an interrupt queued.
+  */
+ static int kvm_vcpu_ready_for_interrupt_injection(struct kvm_vcpu *vcpu)
+ {
+ 	return kvm_arch_interrupt_allowed(vcpu) &&
+ 		!kvm_cpu_has_interrupt(vcpu) &&
+ 		!kvm_event_needs_reinjection(vcpu) &&
+ 		kvm_cpu_accept_dm_intr(vcpu);
+ }
+ 
++>>>>>>> 782d422bcaee (KVM: x86: split kvm_vcpu_ready_for_interrupt_injection out of dm_request_for_irq_injection)
  static int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,
  				    struct kvm_interrupt *irq)
  {
@@@ -6247,17 -5930,10 +6270,16 @@@ static int emulator_fix_hypercall(struc
  	return emulator_write_emulated(ctxt, rip, instruction, 3, NULL);
  }
  
- /*
-  * Check if userspace requested an interrupt window, and that the
-  * interrupt window is open.
-  *
-  * No need to exit to userspace if we already have an interrupt queued.
-  */
  static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	return (!irqchip_in_kernel(vcpu->kvm) && !kvm_cpu_has_interrupt(vcpu) &&
 +		vcpu->run->request_interrupt_window &&
 +		kvm_arch_interrupt_allowed(vcpu));
++=======
+ 	return vcpu->run->request_interrupt_window &&
+ 		likely(!pic_in_kernel(vcpu->kvm));
++>>>>>>> 782d422bcaee (KVM: x86: split kvm_vcpu_ready_for_interrupt_injection out of dm_request_for_irq_injection)
  }
  
  static void post_kvm_run_save(struct kvm_vcpu *vcpu)
@@@ -6268,13 -5944,9 +6290,19 @@@
  	kvm_run->flags = is_smm(vcpu) ? KVM_RUN_X86_SMM : 0;
  	kvm_run->cr8 = kvm_get_cr8(vcpu);
  	kvm_run->apic_base = kvm_get_apic_base(vcpu);
++<<<<<<< HEAD
 +	if (irqchip_in_kernel(vcpu->kvm))
 +		kvm_run->ready_for_interrupt_injection = 1;
 +	else
 +		kvm_run->ready_for_interrupt_injection =
 +			kvm_arch_interrupt_allowed(vcpu) &&
 +			!kvm_cpu_has_interrupt(vcpu) &&
 +			!kvm_event_needs_reinjection(vcpu);
++=======
+ 	kvm_run->ready_for_interrupt_injection =
+ 		pic_in_kernel(vcpu->kvm) ||
+ 		kvm_vcpu_ready_for_interrupt_injection(vcpu);
++>>>>>>> 782d422bcaee (KVM: x86: split kvm_vcpu_ready_for_interrupt_injection out of dm_request_for_irq_injection)
  }
  
  static void update_cr8_intercept(struct kvm_vcpu *vcpu)
@@@ -6958,9 -6662,10 +6986,16 @@@ static int vcpu_run(struct kvm_vcpu *vc
  		if (kvm_cpu_has_pending_timer(vcpu))
  			kvm_inject_pending_timer_irqs(vcpu);
  
++<<<<<<< HEAD
 +		if (dm_request_for_irq_injection(vcpu)) {
 +			r = -EINTR;
 +			vcpu->run->exit_reason = KVM_EXIT_INTR;
++=======
+ 		if (dm_request_for_irq_injection(vcpu) &&
+ 			kvm_vcpu_ready_for_interrupt_injection(vcpu)) {
+ 			r = 0;
+ 			vcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;
++>>>>>>> 782d422bcaee (KVM: x86: split kvm_vcpu_ready_for_interrupt_injection out of dm_request_for_irq_injection)
  			++vcpu->stat.request_irq_exits;
  			break;
  		}
* Unmerged path arch/x86/kvm/x86.c
