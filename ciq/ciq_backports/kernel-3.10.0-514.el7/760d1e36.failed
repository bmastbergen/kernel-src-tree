hv_netvsc: Eliminate vlan_tci from struct hv_netvsc_packet

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author KY Srinivasan <kys@microsoft.com>
commit 760d1e36cc16fa6444dd2000ac645455de1ecd51
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/760d1e36.failed

Eliminate vlan_tci from struct hv_netvsc_packet.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 760d1e36cc16fa6444dd2000ac645455de1ecd51)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/netvsc_drv.c
#	drivers/net/hyperv/rndis_filter.c
diff --cc drivers/net/hyperv/hyperv_net.h
index cf498664d989,f4130af09244..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -128,28 -127,19 +128,31 @@@ struct ndis_tcp_ip_checksum_info
   */
  struct hv_netvsc_packet {
  	/* Bookkeeping stuff */
 -	u8 cp_partial; /* partial copy into send buffer */
 +	u32 status;
  
 -	u8 rmsg_size; /* RNDIS header and PPI size */
 -	u8 rmsg_pgcnt; /* page count of RNDIS header and PPI */
 -	u8 page_buf_cnt;
++<<<<<<< HEAD
 +	bool is_data_pkt;
 +	u16 vlan_tci;
  
++=======
++>>>>>>> 760d1e36cc16 (hv_netvsc: Eliminate vlan_tci from struct hv_netvsc_packet)
  	u16 q_idx;
 +	struct vmbus_channel *channel;
 +
 +	u64 send_completion_tid;
 +	void *send_completion_ctx;
 +	void (*send_completion)(void *context);
 +
  	u32 send_buf_index;
  
 +	/* This points to the memory after page_buf */
 +	struct rndis_message *rndis_msg;
 +
  	u32 total_data_buflen;
 +	/* Points to the send/receive buffer where the ethernet frame is */
 +	void *data;
 +	u32 page_buf_cnt;
 +	struct hv_page_buffer page_buf[0];
  };
  
  struct netvsc_device_info {
@@@ -183,12 -175,19 +186,19 @@@ struct rndis_device 
  int netvsc_device_add(struct hv_device *device, void *additional_info);
  int netvsc_device_remove(struct hv_device *device);
  int netvsc_send(struct hv_device *device,
 -		struct hv_netvsc_packet *packet,
 -		struct rndis_message *rndis_msg,
 -		struct hv_page_buffer **page_buffer,
 -		struct sk_buff *skb);
 +		struct hv_netvsc_packet *packet);
  void netvsc_linkstatus_callback(struct hv_device *device_obj,
 -				struct rndis_message *resp);
 +				unsigned int status);
  int netvsc_recv_callback(struct hv_device *device_obj,
  			struct hv_netvsc_packet *packet,
++<<<<<<< HEAD
 +			struct ndis_tcp_ip_checksum_info *csum_info);
++=======
+ 			void **data,
+ 			struct ndis_tcp_ip_checksum_info *csum_info,
+ 			struct vmbus_channel *channel,
+ 			u16 vlan_tci);
++>>>>>>> 760d1e36cc16 (hv_netvsc: Eliminate vlan_tci from struct hv_netvsc_packet)
  void netvsc_channel_cb(void *context);
  int rndis_filter_open(struct hv_device *dev);
  int rndis_filter_close(struct hv_device *dev);
diff --cc drivers/net/hyperv/netvsc_drv.c
index 56b76b7b9a27,1c8db9afdcda..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -429,51 -433,56 +429,50 @@@ static int netvsc_start_xmit(struct sk_
  
  	/* We will atmost need two pages to describe the rndis
  	 * header. We can only transmit MAX_PAGE_BUFFER_COUNT number
 -	 * of pages in a single packet. If skb is scattered around
 -	 * more pages we try linearizing it.
 +	 * of pages in a single packet.
  	 */
 -
 -check_size:
 -	skb_length = skb->len;
  	num_data_pgs = netvsc_get_slots(skb) + 2;
 -	if (num_data_pgs > MAX_PAGE_BUFFER_COUNT && linear) {
 -		net_alert_ratelimited("packet too big: %u pages (%u bytes)\n",
 -				      num_data_pgs, skb->len);
 -		ret = -EFAULT;
 -		goto drop;
 -	} else if (num_data_pgs > MAX_PAGE_BUFFER_COUNT) {
 -		if (skb_linearize(skb)) {
 -			net_alert_ratelimited("failed to linearize skb\n");
 -			ret = -ENOMEM;
 -			goto drop;
 -		}
 -		linear = true;
 -		goto check_size;
 +	if (num_data_pgs > MAX_PAGE_BUFFER_COUNT) {
 +		netdev_err(net, "Packet too big: %u\n", skb->len);
 +		dev_kfree_skb(skb);
 +		net->stats.tx_dropped++;
 +		return NETDEV_TX_OK;
  	}
  
 -	/*
 -	 * Place the rndis header in the skb head room and
 -	 * the skb->cb will be used for hv_netvsc_packet
 -	 * structure.
 -	 */
 -	ret = skb_cow_head(skb, RNDIS_AND_PPI_SIZE);
 -	if (ret) {
 -		netdev_err(net, "unable to alloc hv_netvsc_packet\n");
 -		ret = -ENOMEM;
 -		goto drop;
 +	/* Allocate a netvsc packet based on # of frags. */
 +	packet = kzalloc(sizeof(struct hv_netvsc_packet) +
 +			 (num_data_pgs * sizeof(struct hv_page_buffer)) +
 +			 sizeof(struct rndis_message) +
 +			 NDIS_VLAN_PPI_SIZE + NDIS_CSUM_PPI_SIZE +
 +			 NDIS_LSO_PPI_SIZE + NDIS_HASH_PPI_SIZE, GFP_ATOMIC);
 +	if (!packet) {
 +		/* out of memory, drop packet */
 +		netdev_err(net, "unable to allocate hv_netvsc_packet\n");
 +
 +		dev_kfree_skb(skb);
 +		net->stats.tx_dropped++;
 +		return NETDEV_TX_OK;
  	}
 -	/* Use the skb control buffer for building up the packet */
 -	BUILD_BUG_ON(sizeof(struct hv_netvsc_packet) >
 -			FIELD_SIZEOF(struct sk_buff, cb));
 -	packet = (struct hv_netvsc_packet *)skb->cb;
  
- 	packet->vlan_tci = skb->vlan_tci;
  
  	packet->q_idx = skb_get_queue_mapping(skb);
  
 +	packet->is_data_pkt = true;
  	packet->total_data_buflen = skb->len;
  
 -	rndis_msg = (struct rndis_message *)skb->head;
 +	packet->rndis_msg = (struct rndis_message *)((unsigned long)packet +
 +				sizeof(struct hv_netvsc_packet) +
 +				(num_data_pgs * sizeof(struct hv_page_buffer)));
  
 -	memset(rndis_msg, 0, RNDIS_AND_PPI_SIZE);
 +	/* Set the completion routine */
 +	packet->send_completion = netvsc_xmit_completion;
 +	packet->send_completion_ctx = packet;
 +	packet->send_completion_tid = (unsigned long)skb;
  
- 	isvlan = packet->vlan_tci & VLAN_TAG_PRESENT;
+ 	isvlan = skb->vlan_tci & VLAN_TAG_PRESENT;
  
  	/* Add the rndis header */
 +	rndis_msg = packet->rndis_msg;
  	rndis_msg->ndis_msg_type = RNDIS_MSG_PACKET;
  	rndis_msg->msg_len = packet->total_data_buflen;
  	rndis_pkt = &rndis_msg->msg.pkt;
@@@ -650,10 -670,15 +649,17 @@@ void netvsc_linkstatus_callback(struct 
   */
  int netvsc_recv_callback(struct hv_device *device_obj,
  				struct hv_netvsc_packet *packet,
++<<<<<<< HEAD
 +				struct ndis_tcp_ip_checksum_info *csum_info)
++=======
+ 				void **data,
+ 				struct ndis_tcp_ip_checksum_info *csum_info,
+ 				struct vmbus_channel *channel,
+ 				u16 vlan_tci)
++>>>>>>> 760d1e36cc16 (hv_netvsc: Eliminate vlan_tci from struct hv_netvsc_packet)
  {
  	struct net_device *net;
 -	struct net_device_context *net_device_ctx;
  	struct sk_buff *skb;
 -	struct netvsc_stats *rx_stats;
  
  	net = ((struct netvsc_device *)hv_get_drvdata(device_obj))->ndev;
  	if (!net || net->reg_state != NETREG_REGISTERED) {
@@@ -688,15 -713,17 +694,15 @@@
  			skb->ip_summed = CHECKSUM_NONE;
  	}
  
- 	if (packet->vlan_tci & VLAN_TAG_PRESENT)
+ 	if (vlan_tci & VLAN_TAG_PRESENT)
  		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
- 				       packet->vlan_tci);
+ 				       vlan_tci);
  
 -	skb_record_rx_queue(skb, channel->
 +	skb_record_rx_queue(skb, packet->channel->
  			    offermsg.offer.sub_channel_index);
  
 -	u64_stats_update_begin(&rx_stats->syncp);
 -	rx_stats->packets++;
 -	rx_stats->bytes += packet->total_data_buflen;
 -	u64_stats_update_end(&rx_stats->syncp);
 +	net->stats.rx_packets++;
 +	net->stats.rx_bytes += packet->total_data_buflen;
  
  	/*
  	 * Pass the skb back up. Network stack will deallocate the skb when it
diff --cc drivers/net/hyperv/rndis_filter.c
index 4f78abd49222,a37bbda37ffa..000000000000
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@@ -407,9 -390,8 +408,12 @@@ static void rndis_filter_receive_data(s
  	}
  
  	csum_info = rndis_get_ppi(rndis_pkt, TCPIP_CHKSUM_PKTINFO);
++<<<<<<< HEAD
 +	netvsc_recv_callback(dev->net_dev->dev, pkt, csum_info);
++=======
+ 	return netvsc_recv_callback(dev->net_dev->dev, pkt, data,
+ 				    csum_info, channel, vlan_tci);
++>>>>>>> 760d1e36cc16 (hv_netvsc: Eliminate vlan_tci from struct hv_netvsc_packet)
  }
  
  int rndis_filter_receive(struct hv_device *dev,
* Unmerged path drivers/net/hyperv/hyperv_net.h
* Unmerged path drivers/net/hyperv/netvsc_drv.c
* Unmerged path drivers/net/hyperv/rndis_filter.c
