nvme: factor reset code into a common helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 90667892c5a78b47080359883a569a260e9e87ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/90667892.failed

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 90667892c5a78b47080359883a569a260e9e87ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index f5099f908371,e03a95bd4ee4..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -79,7 -84,7 +79,11 @@@ static wait_queue_head_t nvme_kthread_w
  
  static struct class *nvme_class;
  
++<<<<<<< HEAD
 +static void nvme_reset_failed_dev(struct work_struct *ws);
++=======
+ static int __nvme_reset(struct nvme_dev *dev);
++>>>>>>> 90667892c5a7 (nvme: factor reset code into a common helper)
  static int nvme_reset(struct nvme_dev *dev);
  static int nvme_process_cq(struct nvme_queue *nvmeq);
  
@@@ -1094,19 -1277,13 +1098,29 @@@ static void nvme_abort_req(struct reque
  	struct nvme_command cmd;
  
  	if (!nvmeq->qid || cmd_rq->aborted) {
++<<<<<<< HEAD
 +		unsigned long flags;
 +
 +		spin_lock_irqsave(&dev_list_lock, flags);
 +		if (work_busy(&dev->reset_work))
 +			goto out;
 +		list_del_init(&dev->node);
 +		dev_warn(&dev->pci_dev->dev,
 +			"I/O %d QID %d timeout, reset controller\n",
 +							req->tag, nvmeq->qid);
 +		PREPARE_WORK(&dev->reset_work, nvme_reset_failed_dev);
 +		queue_work(nvme_workq, &dev->reset_work);
 + out:
 +		spin_unlock_irqrestore(&dev_list_lock, flags);
++=======
+ 		spin_lock(&dev_list_lock);
+ 		if (!__nvme_reset(dev)) {
+ 			dev_warn(dev->dev,
+ 				 "I/O %d QID %d timeout, reset controller\n",
+ 				 req->tag, nvmeq->qid);
+ 		}
+ 		spin_unlock(&dev_list_lock);
++>>>>>>> 90667892c5a7 (nvme: factor reset code into a common helper)
  		return;
  	}
  
@@@ -1977,15 -2078,11 +1991,23 @@@ static int nvme_kthread(void *data
  
  			if ((dev->subsystem && (csts & NVME_CSTS_NSSRO)) ||
  							csts & NVME_CSTS_CFS) {
++<<<<<<< HEAD
 +				if (work_busy(&dev->reset_work))
 +					continue;
 +				list_del_init(&dev->node);
 +				dev_warn(&dev->pci_dev->dev,
 +					"Failed status: %x, reset controller\n",
 +					readl(&dev->bar->csts));
 +				PREPARE_WORK(&dev->reset_work,
 +							nvme_reset_failed_dev);
 +				queue_work(nvme_workq, &dev->reset_work);
++=======
+ 				if (!__nvme_reset(dev)) {
+ 					dev_warn(dev->dev,
+ 						"Failed status: %x, reset controller\n",
+ 						readl(&dev->bar->csts));
+ 				}
++>>>>>>> 90667892c5a7 (nvme: factor reset code into a common helper)
  				continue;
  			}
  			for (i = 0; i < dev->queue_count; i++) {
@@@ -2953,10 -3069,13 +2975,20 @@@ static void nvme_dev_reset(struct nvme_
  	schedule_work(&dev->probe_work);
  }
  
++<<<<<<< HEAD
 +static void nvme_reset_failed_dev(struct work_struct *ws)
 +{
 +	struct nvme_dev *dev = container_of(ws, struct nvme_dev, reset_work);
 +	nvme_dev_reset(dev);
++=======
+ static int __nvme_reset(struct nvme_dev *dev)
+ {
+ 	if (work_pending(&dev->reset_work))
+ 		return -EBUSY;
+ 	list_del_init(&dev->node);
+ 	queue_work(nvme_workq, &dev->reset_work);
+ 	return 0;
++>>>>>>> 90667892c5a7 (nvme: factor reset code into a common helper)
  }
  
  static int nvme_reset(struct nvme_dev *dev)
@@@ -2967,11 -3086,7 +2999,15 @@@
  		return -ENODEV;
  
  	spin_lock(&dev_list_lock);
++<<<<<<< HEAD
 +	if (!work_pending(&dev->reset_work)) {
 +		PREPARE_WORK(&dev->reset_work, nvme_reset_failed_dev);
 +		queue_work(nvme_workq, &dev->reset_work);
 +		ret = 0;
 +	}
++=======
+ 	ret = __nvme_reset(dev);
++>>>>>>> 90667892c5a7 (nvme: factor reset code into a common helper)
  	spin_unlock(&dev_list_lock);
  
  	if (!ret) {
* Unmerged path drivers/block/nvme-core.c
