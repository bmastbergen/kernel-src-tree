mmc: core: Don't print reset warning if reset is not supported

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] core: Don't print reset warning if reset is not supported (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 95.80%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 0250fdf257b1e5febba19b7cc536a3c9431e50bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0250fdf2.failed

Check the error code for EOPNOTSUPP and do not print
reset warning in that case.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 0250fdf257b1e5febba19b7cc536a3c9431e50bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/core.c
diff --cc drivers/mmc/core/core.c
index a84cf370bf80,8c61ddd7748c..000000000000
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@@ -2314,59 -2355,26 +2314,64 @@@ static void mmc_hw_reset_for_init(struc
  	mmc_host_clk_release(host);
  }
  
 +int mmc_can_reset(struct mmc_card *card)
 +{
 +	u8 rst_n_function;
 +
 +	if (!mmc_card_mmc(card))
 +		return 0;
 +	rst_n_function = card->ext_csd.rst_n_function;
 +	if ((rst_n_function & EXT_CSD_RST_N_EN_MASK) != EXT_CSD_RST_N_ENABLED)
 +		return 0;
 +	return 1;
 +}
 +EXPORT_SYMBOL(mmc_can_reset);
 +
  int mmc_hw_reset(struct mmc_host *host)
  {
 -	int ret;
 +	struct mmc_card *card = host->card;
 +	u32 status;
 +
 +	if (!(host->caps & MMC_CAP_HW_RESET) || !host->ops->hw_reset)
 +		return -EOPNOTSUPP;
  
 -	if (!host->card)
 +	if (!card)
  		return -EINVAL;
  
 -	mmc_bus_get(host);
 -	if (!host->bus_ops || host->bus_dead || !host->bus_ops->reset) {
 -		mmc_bus_put(host);
 +	if (!mmc_can_reset(card))
  		return -EOPNOTSUPP;
 +
 +	mmc_host_clk_hold(host);
 +	mmc_set_clock(host, host->f_init);
 +
 +	host->ops->hw_reset(host);
 +
 +	/* If the reset has happened, then a status command will fail */
 +	if (!mmc_send_status(card, &status)) {
 +		mmc_host_clk_release(host);
 +		return -ENOSYS;
  	}
  
 -	ret = host->bus_ops->reset(host);
 -	mmc_bus_put(host);
 +	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_HIGHSPEED_DDR);
 +	if (mmc_host_is_spi(host)) {
 +		host->ios.chip_select = MMC_CS_HIGH;
 +		host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
 +	} else {
 +		host->ios.chip_select = MMC_CS_DONTCARE;
 +		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
 +	}
 +	host->ios.bus_width = MMC_BUS_WIDTH_1;
 +	host->ios.timing = MMC_TIMING_LEGACY;
 +	mmc_set_ios(host);
  
++<<<<<<< HEAD
 +	mmc_host_clk_release(host);
++=======
+ 	if (ret != -EOPNOTSUPP)
+ 		pr_warn("%s: tried to reset card\n", mmc_hostname(host));
++>>>>>>> 0250fdf257b1 (mmc: core: Don't print reset warning if reset is not supported)
  
 -	return ret;
 +	return host->bus_ops->power_restore(host);
  }
  EXPORT_SYMBOL(mmc_hw_reset);
  
* Unmerged path drivers/mmc/core/core.c
