evm: Fix build warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hv] vmbus: fix build warning (Cathy Avery) [1300325]
Rebuild_FUZZ: 89.36%
commit-author Roberto Sassu <roberto.sassu@huawei.com>
commit 996e0a97ebd7b11cb785794e2a83c20c1add9d92
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/996e0a97.failed

Fix build warnings (function parameters description) for
evm_read_protected_xattrs(), evm_set_key() and evm_verifyxattr().

Fixes: 7626676320f3 ("evm: provide a function to set the EVM key from the kernel") # v4.5+
Fixes: 8314b6732ae4 ("ima: Define new template fields xattrnames, xattrlengths and xattrvalues") # v5.14+
Fixes: 2960e6cb5f7c ("evm: additional parameter to pass integrity cache entry 'iint'") # v3.2+
	Signed-off-by: Roberto Sassu <roberto.sassu@huawei.com>
	Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>
(cherry picked from commit 996e0a97ebd7b11cb785794e2a83c20c1add9d92)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/integrity/evm/evm_crypto.c
#	security/integrity/evm/evm_main.c
diff --cc security/integrity/evm/evm_crypto.c
index e90ab0e20db8,0dae649f3740..000000000000
--- a/security/integrity/evm/evm_crypto.c
+++ b/security/integrity/evm/evm_crypto.c
@@@ -30,11 -31,51 +30,55 @@@ struct crypto_shash *hash_tfm
  
  static DEFINE_MUTEX(mutex);
  
++<<<<<<< HEAD
 +static struct shash_desc *init_desc(char type)
++=======
+ #define EVM_SET_KEY_BUSY 0
+ 
+ static unsigned long evm_set_key_flags;
+ 
+ static const char evm_hmac[] = "hmac(sha1)";
+ 
+ /**
+  * evm_set_key() - set EVM HMAC key from the kernel
+  * @key: pointer to a buffer with the key data
+  * @keylen: length of the key data
+  *
+  * This function allows setting the EVM HMAC key from the kernel
+  * without using the "encrypted" key subsystem keys. It can be used
+  * by the crypto HW kernel module which has its own way of managing
+  * keys.
+  *
+  * key length should be between 32 and 128 bytes long
+  */
+ int evm_set_key(void *key, size_t keylen)
+ {
+ 	int rc;
+ 
+ 	rc = -EBUSY;
+ 	if (test_and_set_bit(EVM_SET_KEY_BUSY, &evm_set_key_flags))
+ 		goto busy;
+ 	rc = -EINVAL;
+ 	if (keylen > MAX_KEY_SIZE)
+ 		goto inval;
+ 	memcpy(evmkey, key, keylen);
+ 	evm_initialized |= EVM_INIT_HMAC;
+ 	pr_info("key initialized\n");
+ 	return 0;
+ inval:
+ 	clear_bit(EVM_SET_KEY_BUSY, &evm_set_key_flags);
+ busy:
+ 	pr_err("key initialization failed\n");
+ 	return rc;
+ }
+ EXPORT_SYMBOL_GPL(evm_set_key);
+ 
+ static struct shash_desc *init_desc(char type, uint8_t hash_algo)
++>>>>>>> 996e0a97ebd7 (evm: Fix build warnings)
  {
  	long rc;
 -	const char *algo;
 -	struct crypto_shash **tfm, *tmp_tfm;
 +	char *algo;
 +	struct crypto_shash **tfm;
  	struct shash_desc *desc;
  
  	if (type == EVM_XATTR_HMAC) {
diff --cc security/integrity/evm/evm_main.c
index 3315414a64e2,c9b6e2a43478..000000000000
--- a/security/integrity/evm/evm_main.c
+++ b/security/integrity/evm/evm_main.c
@@@ -185,6 -304,85 +185,87 @@@ static int evm_protected_xattr(const ch
  	return found;
  }
  
++<<<<<<< HEAD
++=======
+ static int evm_protected_xattr(const char *req_xattr_name)
+ {
+ 	return evm_protected_xattr_common(req_xattr_name, false);
+ }
+ 
+ int evm_protected_xattr_if_enabled(const char *req_xattr_name)
+ {
+ 	return evm_protected_xattr_common(req_xattr_name, true);
+ }
+ 
+ /**
+  * evm_read_protected_xattrs - read EVM protected xattr names, lengths, values
+  * @dentry: dentry of the read xattrs
+  * @buffer: buffer xattr names, lengths or values are copied to
+  * @buffer_size: size of buffer
+  * @type: n: names, l: lengths, v: values
+  * @canonical_fmt: data format (true: little endian, false: native format)
+  *
+  * Read protected xattr names (separated by |), lengths (u32) or values for a
+  * given dentry and return the total size of copied data. If buffer is NULL,
+  * just return the total size.
+  *
+  * Returns the total size on success, a negative value on error.
+  */
+ int evm_read_protected_xattrs(struct dentry *dentry, u8 *buffer,
+ 			      int buffer_size, char type, bool canonical_fmt)
+ {
+ 	struct xattr_list *xattr;
+ 	int rc, size, total_size = 0;
+ 
+ 	list_for_each_entry_lockless(xattr, &evm_config_xattrnames, list) {
+ 		rc = __vfs_getxattr(dentry, d_backing_inode(dentry),
+ 				    xattr->name, NULL, 0);
+ 		if (rc < 0 && rc == -ENODATA)
+ 			continue;
+ 		else if (rc < 0)
+ 			return rc;
+ 
+ 		switch (type) {
+ 		case 'n':
+ 			size = strlen(xattr->name) + 1;
+ 			if (buffer) {
+ 				if (total_size)
+ 					*(buffer + total_size - 1) = '|';
+ 
+ 				memcpy(buffer + total_size, xattr->name, size);
+ 			}
+ 			break;
+ 		case 'l':
+ 			size = sizeof(u32);
+ 			if (buffer) {
+ 				if (canonical_fmt)
+ 					rc = (__force int)cpu_to_le32(rc);
+ 
+ 				*(u32 *)(buffer + total_size) = rc;
+ 			}
+ 			break;
+ 		case 'v':
+ 			size = rc;
+ 			if (buffer) {
+ 				rc = __vfs_getxattr(dentry,
+ 					d_backing_inode(dentry), xattr->name,
+ 					buffer + total_size,
+ 					buffer_size - total_size);
+ 				if (rc < 0)
+ 					return rc;
+ 			}
+ 			break;
+ 		default:
+ 			return -EINVAL;
+ 		}
+ 
+ 		total_size += size;
+ 	}
+ 
+ 	return total_size;
+ }
+ 
++>>>>>>> 996e0a97ebd7 (evm: Fix build warnings)
  /**
   * evm_verifyxattr - verify the integrity of the requested xattr
   * @dentry: object of the verify xattr
* Unmerged path security/integrity/evm/evm_crypto.c
* Unmerged path security/integrity/evm/evm_main.c
