sched/wait: Fix a kthread race with wait_woken()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit cb6538e740d7543cd989128625cf8cac4b471e0a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/cb6538e7.failed

There is a race between kthread_stop() and the new wait_woken() that
can result in a lack of progress.

CPU 0                                    | CPU 1
                                         |
rfcomm_run()                             | kthread_stop()
  ...                                    |
  if (!test_bit(KTHREAD_SHOULD_STOP))    |
                                         |   set_bit(KTHREAD_SHOULD_STOP)
                                         |   wake_up_process()
    wait_woken()                         |   wait_for_completion()
      set_current_state(INTERRUPTIBLE)   |
      if (!WQ_FLAG_WOKEN)                |
        schedule_timeout()               |
                                         |

After which both tasks will wait.. forever.

Fix this by having wait_woken() check for kthread_should_stop() but
only for kthreads (obviously).

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Peter Hurley <peter@hurleysoftware.com>
	Cc: Oleg Nesterov <oleg@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit cb6538e740d7543cd989128625cf8cac4b471e0a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/wait.c
diff --cc kernel/wait.c
index d550920e040c,852143a79f36..000000000000
--- a/kernel/wait.c
+++ b/kernel/wait.c
@@@ -170,6 -298,71 +171,74 @@@ int autoremove_wake_function(wait_queue
  }
  EXPORT_SYMBOL(autoremove_wake_function);
  
++<<<<<<< HEAD:kernel/wait.c
++=======
+ static inline bool is_kthread_should_stop(void)
+ {
+ 	return (current->flags & PF_KTHREAD) && kthread_should_stop();
+ }
+ 
+ /*
+  * DEFINE_WAIT_FUNC(wait, woken_wake_func);
+  *
+  * add_wait_queue(&wq, &wait);
+  * for (;;) {
+  *     if (condition)
+  *         break;
+  *
+  *     p->state = mode;				condition = true;
+  *     smp_mb(); // A				smp_wmb(); // C
+  *     if (!wait->flags & WQ_FLAG_WOKEN)	wait->flags |= WQ_FLAG_WOKEN;
+  *         schedule()				try_to_wake_up();
+  *     p->state = TASK_RUNNING;		    ~~~~~~~~~~~~~~~~~~
+  *     wait->flags &= ~WQ_FLAG_WOKEN;		condition = true;
+  *     smp_mb() // B				smp_wmb(); // C
+  *						wait->flags |= WQ_FLAG_WOKEN;
+  * }
+  * remove_wait_queue(&wq, &wait);
+  *
+  */
+ long wait_woken(wait_queue_t *wait, unsigned mode, long timeout)
+ {
+ 	set_current_state(mode); /* A */
+ 	/*
+ 	 * The above implies an smp_mb(), which matches with the smp_wmb() from
+ 	 * woken_wake_function() such that if we observe WQ_FLAG_WOKEN we must
+ 	 * also observe all state before the wakeup.
+ 	 */
+ 	if (!(wait->flags & WQ_FLAG_WOKEN) && !is_kthread_should_stop())
+ 		timeout = schedule_timeout(timeout);
+ 	__set_current_state(TASK_RUNNING);
+ 
+ 	/*
+ 	 * The below implies an smp_mb(), it too pairs with the smp_wmb() from
+ 	 * woken_wake_function() such that we must either observe the wait
+ 	 * condition being true _OR_ WQ_FLAG_WOKEN such that we will not miss
+ 	 * an event.
+ 	 */
+ 	set_mb(wait->flags, wait->flags & ~WQ_FLAG_WOKEN); /* B */
+ 
+ 	return timeout;
+ }
+ EXPORT_SYMBOL(wait_woken);
+ 
+ int woken_wake_function(wait_queue_t *wait, unsigned mode, int sync, void *key)
+ {
+ 	/*
+ 	 * Although this function is called under waitqueue lock, LOCK
+ 	 * doesn't imply write barrier and the users expects write
+ 	 * barrier semantics on wakeup functions.  The following
+ 	 * smp_wmb() is equivalent to smp_wmb() in try_to_wake_up()
+ 	 * and is paired with set_mb() in wait_woken().
+ 	 */
+ 	smp_wmb(); /* C */
+ 	wait->flags |= WQ_FLAG_WOKEN;
+ 
+ 	return default_wake_function(wait, mode, sync, key);
+ }
+ EXPORT_SYMBOL(woken_wake_function);
+ 
++>>>>>>> cb6538e740d7 (sched/wait: Fix a kthread race with wait_woken()):kernel/sched/wait.c
  int wake_bit_function(wait_queue_t *wait, unsigned mode, int sync, void *arg)
  {
  	struct wait_bit_key *key = arg;
* Unmerged path kernel/wait.c
