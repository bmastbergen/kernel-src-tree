vxlan: fix test which detect duplicate vxlan iface

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Nicolas Dichtel <nicolas.dichtel@6wind.com>
commit 07b9b37c227cb8d88d478b4a9c5634fee514ede1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/07b9b37c.failed

When a vxlan interface is created, the driver checks that there is not
another vxlan interface with the same properties. To do this, it checks
the existing vxlan udp socket. Since commit 1c51a9159dde, the creation of
the vxlan socket is done only when the interface is set up, thus it breaks
that test.

Example:
$ ip l a vxlan10 type vxlan id 10 group 239.0.0.10 dev eth0 dstport 0
$ ip l a vxlan11 type vxlan id 10 group 239.0.0.10 dev eth0 dstport 0
$ ip -br l | grep vxlan
vxlan10          DOWN           f2:55:1c:6a:fb:00 <BROADCAST,MULTICAST>
vxlan11          DOWN           7a:cb:b9:38:59:0d <BROADCAST,MULTICAST>

Instead of checking sockets, let's loop over the vxlan iface list.

Fixes: 1c51a9159dde ("vxlan: fix race caused by dropping rtnl_unlock")
	Reported-by: Thomas Faivre <thomas.faivre@6wind.com>
	Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 07b9b37c227cb8d88d478b4a9c5634fee514ede1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 4e5b7ab9acd0,405a7b6cca25..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -2564,59 -2713,74 +2564,59 @@@ struct vxlan_sock *vxlan_sock_add(struc
  		}
  		spin_unlock(&vn->sock_lock);
  	}
 -	if (!vs)
 -		vs = vxlan_socket_create(vxlan->net, ipv6,
 -					 vxlan->cfg.dst_port, vxlan->flags);
 -	if (IS_ERR(vs))
 -		return PTR_ERR(vs);
 -#if IS_ENABLED(CONFIG_IPV6)
 -	if (ipv6)
 -		vxlan->vn6_sock = vs;
 -	else
 -#endif
 -		vxlan->vn4_sock = vs;
 -	vxlan_vs_add_dev(vs, vxlan);
 -	return 0;
 -}
 -
 -static int vxlan_sock_add(struct vxlan_dev *vxlan)
 -{
 -	bool ipv6 = vxlan->flags & VXLAN_F_IPV6;
 -	bool metadata = vxlan->flags & VXLAN_F_COLLECT_METADATA;
 -	int ret = 0;
  
 -	vxlan->vn4_sock = NULL;
 -#if IS_ENABLED(CONFIG_IPV6)
 -	vxlan->vn6_sock = NULL;
 -	if (ipv6 || metadata)
 -		ret = __vxlan_sock_add(vxlan, true);
 -#endif
 -	if (!ret && (!ipv6 || metadata))
 -		ret = __vxlan_sock_add(vxlan, false);
 -	if (ret < 0)
 -		vxlan_sock_release(vxlan);
 -	return ret;
 +	return vxlan_socket_create(net, port, rcv, data, flags);
  }
 +EXPORT_SYMBOL_GPL(vxlan_sock_add);
  
 -static int vxlan_dev_configure(struct net *src_net, struct net_device *dev,
 -			       struct vxlan_config *conf)
 +static int vxlan_newlink(struct net *src_net, struct net_device *dev,
 +			 struct nlattr *tb[], struct nlattr *data[])
  {
  	struct vxlan_net *vn = net_generic(src_net, vxlan_net_id);
- 	struct vxlan_dev *vxlan = netdev_priv(dev);
+ 	struct vxlan_dev *vxlan = netdev_priv(dev), *tmp;
  	struct vxlan_rdst *dst = &vxlan->default_dst;
 -	unsigned short needed_headroom = ETH_HLEN;
 +	__u32 vni;
  	int err;
  	bool use_ipv6 = false;
 -	__be16 default_port = vxlan->cfg.dst_port;
  
 -	vxlan->net = src_net;
 +	if (!data[IFLA_VXLAN_ID])
 +		return -EINVAL;
  
 -	dst->remote_vni = conf->vni;
 +	vxlan->net = src_net;
  
 -	memcpy(&dst->remote_ip, &conf->remote_ip, sizeof(conf->remote_ip));
 +	vni = nla_get_u32(data[IFLA_VXLAN_ID]);
 +	dst->remote_vni = vni;
  
  	/* Unless IPv6 is explicitly requested, assume IPv4 */
 -	if (!dst->remote_ip.sa.sa_family)
 -		dst->remote_ip.sa.sa_family = AF_INET;
 +	dst->remote_ip.sa.sa_family = AF_INET;
 +	if (data[IFLA_VXLAN_GROUP]) {
 +		dst->remote_ip.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_GROUP]);
 +	} else if (data[IFLA_VXLAN_GROUP6]) {
 +		if (!IS_ENABLED(CONFIG_IPV6))
 +			return -EPFNOSUPPORT;
  
 -	if (dst->remote_ip.sa.sa_family == AF_INET6 ||
 -	    vxlan->cfg.saddr.sa.sa_family == AF_INET6) {
 +		dst->remote_ip.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_GROUP6]);
 +		dst->remote_ip.sa.sa_family = AF_INET6;
 +		use_ipv6 = true;
 +	}
 +
 +	if (data[IFLA_VXLAN_LOCAL]) {
 +		vxlan->saddr.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_LOCAL]);
 +		vxlan->saddr.sa.sa_family = AF_INET;
 +	} else if (data[IFLA_VXLAN_LOCAL6]) {
  		if (!IS_ENABLED(CONFIG_IPV6))
  			return -EPFNOSUPPORT;
 +
 +		/* TODO: respect scope id */
 +		vxlan->saddr.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_LOCAL6]);
 +		vxlan->saddr.sa.sa_family = AF_INET6;
  		use_ipv6 = true;
 -		vxlan->flags |= VXLAN_F_IPV6;
  	}
  
 -	if (conf->remote_ifindex) {
 +	if (data[IFLA_VXLAN_LINK] &&
 +	    (dst->remote_ifindex = nla_get_u32(data[IFLA_VXLAN_LINK]))) {
  		struct net_device *lowerdev
 -			 = __dev_get_by_index(src_net, conf->remote_ifindex);
 -
 -		dst->remote_ifindex = conf->remote_ifindex;
 +			 = __dev_get_by_index(src_net, dst->remote_ifindex);
  
  		if (!lowerdev) {
  			pr_info("ifindex %d does not exist\n", dst->remote_ifindex);
@@@ -2634,46 -2797,153 +2634,47 @@@
  		}
  #endif
  
 -		if (!conf->mtu)
 +		if (!tb[IFLA_MTU])
  			dev->mtu = lowerdev->mtu - (use_ipv6 ? VXLAN6_HEADROOM : VXLAN_HEADROOM);
  
 -		needed_headroom = lowerdev->hard_header_len;
 -	}
 -
 -	if (use_ipv6 || conf->flags & VXLAN_F_COLLECT_METADATA)
 -		needed_headroom += VXLAN6_HEADROOM;
 -	else
 -		needed_headroom += VXLAN_HEADROOM;
 -	dev->needed_headroom = needed_headroom;
 -
 -	memcpy(&vxlan->cfg, conf, sizeof(*conf));
 -	if (!vxlan->cfg.dst_port)
 -		vxlan->cfg.dst_port = default_port;
 -	vxlan->flags |= conf->flags;
 -
 -	if (!vxlan->cfg.age_interval)
 -		vxlan->cfg.age_interval = FDB_AGE_DEFAULT;
 -
 -	list_for_each_entry(tmp, &vn->vxlan_list, next) {
 -		if (tmp->cfg.vni == conf->vni &&
 -		    (tmp->default_dst.remote_ip.sa.sa_family == AF_INET6 ||
 -		     tmp->cfg.saddr.sa.sa_family == AF_INET6) == use_ipv6 &&
 -		    tmp->cfg.dst_port == vxlan->cfg.dst_port &&
 -		    (tmp->flags & VXLAN_F_RCV_FLAGS) ==
 -		    (vxlan->flags & VXLAN_F_RCV_FLAGS))
 -		return -EEXIST;
 -	}
 -
 -	dev->ethtool_ops = &vxlan_ethtool_ops;
 -
 -	/* create an fdb entry for a valid default destination */
 -	if (!vxlan_addr_any(&vxlan->default_dst.remote_ip)) {
 -		err = vxlan_fdb_create(vxlan, all_zeros_mac,
 -				       &vxlan->default_dst.remote_ip,
 -				       NUD_REACHABLE|NUD_PERMANENT,
 -				       NLM_F_EXCL|NLM_F_CREATE,
 -				       vxlan->cfg.dst_port,
 -				       vxlan->default_dst.remote_vni,
 -				       vxlan->default_dst.remote_ifindex,
 -				       NTF_SELF);
 -		if (err)
 -			return err;
 -	}
 -
 -	err = register_netdevice(dev);
 -	if (err) {
 -		vxlan_fdb_delete_default(vxlan);
 -		return err;
 -	}
 -
 -	list_add(&vxlan->next, &vn->vxlan_list);
 -
 -	return 0;
 -}
 -
 -struct net_device *vxlan_dev_create(struct net *net, const char *name,
 -				    u8 name_assign_type, struct vxlan_config *conf)
 -{
 -	struct nlattr *tb[IFLA_MAX+1];
 -	struct net_device *dev;
 -	int err;
 -
 -	memset(&tb, 0, sizeof(tb));
 -
 -	dev = rtnl_create_link(net, name, name_assign_type,
 -			       &vxlan_link_ops, tb);
 -	if (IS_ERR(dev))
 -		return dev;
 -
 -	err = vxlan_dev_configure(net, dev, conf);
 -	if (err < 0) {
 -		free_netdev(dev);
 -		return ERR_PTR(err);
 -	}
 -
 -	return dev;
 -}
 -EXPORT_SYMBOL_GPL(vxlan_dev_create);
 -
 -static int vxlan_newlink(struct net *src_net, struct net_device *dev,
 -			 struct nlattr *tb[], struct nlattr *data[])
 -{
 -	struct vxlan_config conf;
 -	int err;
 -
 -	memset(&conf, 0, sizeof(conf));
 -
 -	if (data[IFLA_VXLAN_ID])
 -		conf.vni = nla_get_u32(data[IFLA_VXLAN_ID]);
 -
 -	if (data[IFLA_VXLAN_GROUP]) {
 -		conf.remote_ip.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_GROUP]);
 -	} else if (data[IFLA_VXLAN_GROUP6]) {
 -		if (!IS_ENABLED(CONFIG_IPV6))
 -			return -EPFNOSUPPORT;
 -
 -		conf.remote_ip.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_GROUP6]);
 -		conf.remote_ip.sa.sa_family = AF_INET6;
 -	}
 -
 -	if (data[IFLA_VXLAN_LOCAL]) {
 -		conf.saddr.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_LOCAL]);
 -		conf.saddr.sa.sa_family = AF_INET;
 -	} else if (data[IFLA_VXLAN_LOCAL6]) {
 -		if (!IS_ENABLED(CONFIG_IPV6))
 -			return -EPFNOSUPPORT;
 -
 -		/* TODO: respect scope id */
 -		conf.saddr.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_LOCAL6]);
 -		conf.saddr.sa.sa_family = AF_INET6;
 +		dev->needed_headroom = lowerdev->hard_header_len +
 +				       (use_ipv6 ? VXLAN6_HEADROOM : VXLAN_HEADROOM);
 +	} else if (use_ipv6) {
 +		vxlan->flags |= VXLAN_F_IPV6;
 +		dev->needed_headroom = ETH_HLEN + VXLAN6_HEADROOM;
 +	} else {
 +		dev->needed_headroom = ETH_HLEN + VXLAN_HEADROOM;
  	}
  
 -	if (data[IFLA_VXLAN_LINK])
 -		conf.remote_ifindex = nla_get_u32(data[IFLA_VXLAN_LINK]);
 -
  	if (data[IFLA_VXLAN_TOS])
 -		conf.tos  = nla_get_u8(data[IFLA_VXLAN_TOS]);
 +		vxlan->tos  = nla_get_u8(data[IFLA_VXLAN_TOS]);
  
  	if (data[IFLA_VXLAN_TTL])
 -		conf.ttl = nla_get_u8(data[IFLA_VXLAN_TTL]);
 +		vxlan->ttl = nla_get_u8(data[IFLA_VXLAN_TTL]);
  
  	if (!data[IFLA_VXLAN_LEARNING] || nla_get_u8(data[IFLA_VXLAN_LEARNING]))
 -		conf.flags |= VXLAN_F_LEARN;
 +		vxlan->flags |= VXLAN_F_LEARN;
  
  	if (data[IFLA_VXLAN_AGEING])
 -		conf.age_interval = nla_get_u32(data[IFLA_VXLAN_AGEING]);
 +		vxlan->age_interval = nla_get_u32(data[IFLA_VXLAN_AGEING]);
 +	else
 +		vxlan->age_interval = FDB_AGE_DEFAULT;
  
  	if (data[IFLA_VXLAN_PROXY] && nla_get_u8(data[IFLA_VXLAN_PROXY]))
 -		conf.flags |= VXLAN_F_PROXY;
 +		vxlan->flags |= VXLAN_F_PROXY;
  
  	if (data[IFLA_VXLAN_RSC] && nla_get_u8(data[IFLA_VXLAN_RSC]))
 -		conf.flags |= VXLAN_F_RSC;
 +		vxlan->flags |= VXLAN_F_RSC;
  
++<<<<<<< HEAD
  	if (data[IFLA_VXLAN_L2MISS] && nla_get_u8(data[IFLA_VXLAN_L2MISS]))
 -		conf.flags |= VXLAN_F_L2MISS;
 +		vxlan->flags |= VXLAN_F_L2MISS;
  
  	if (data[IFLA_VXLAN_L3MISS] && nla_get_u8(data[IFLA_VXLAN_L3MISS]))
 -		conf.flags |= VXLAN_F_L3MISS;
 +		vxlan->flags |= VXLAN_F_L3MISS;
  
  	if (data[IFLA_VXLAN_LIMIT])
 -		conf.addrmax = nla_get_u32(data[IFLA_VXLAN_LIMIT]);
 -
 -	if (data[IFLA_VXLAN_COLLECT_METADATA] &&
 -	    nla_get_u8(data[IFLA_VXLAN_COLLECT_METADATA]))
 -		conf.flags |= VXLAN_F_COLLECT_METADATA;
 +		vxlan->addrmax = nla_get_u32(data[IFLA_VXLAN_LIMIT]);
  
  	if (data[IFLA_VXLAN_PORT_RANGE]) {
  		const struct ifla_vxlan_port_range *p
@@@ -2702,45 -2972,30 +2703,54 @@@
  
  	if (data[IFLA_VXLAN_REMCSUM_RX] &&
  	    nla_get_u8(data[IFLA_VXLAN_REMCSUM_RX]))
 -		conf.flags |= VXLAN_F_REMCSUM_RX;
 +		vxlan->flags |= VXLAN_F_REMCSUM_RX;
  
  	if (data[IFLA_VXLAN_GBP])
 -		conf.flags |= VXLAN_F_GBP;
 +		vxlan->flags |= VXLAN_F_GBP;
  
  	if (data[IFLA_VXLAN_REMCSUM_NOPARTIAL])
 -		conf.flags |= VXLAN_F_REMCSUM_NOPARTIAL;
 +		vxlan->flags |= VXLAN_F_REMCSUM_NOPARTIAL;
  
 -	err = vxlan_dev_configure(src_net, dev, &conf);
 -	switch (err) {
 -	case -ENODEV:
 -		pr_info("ifindex %d does not exist\n", conf.remote_ifindex);
 -		break;
 +	if (vxlan_find_vni(src_net, vni, use_ipv6 ? AF_INET6 : AF_INET,
 +			   vxlan->dst_port, vxlan->flags)) {
 +		pr_info("duplicate VNI %u\n", vni);
++=======
++	list_for_each_entry(tmp, &vn->vxlan_list, next) {
++		if (tmp->cfg.vni == conf->vni &&
++		    (tmp->default_dst.remote_ip.sa.sa_family == AF_INET6 ||
++		     tmp->cfg.saddr.sa.sa_family == AF_INET6) == use_ipv6 &&
++		    tmp->cfg.dst_port == vxlan->cfg.dst_port &&
++		    (tmp->flags & VXLAN_F_RCV_FLAGS) ==
++		    (vxlan->flags & VXLAN_F_RCV_FLAGS))
++>>>>>>> 07b9b37c227c (vxlan: fix test which detect duplicate vxlan iface)
 +		return -EEXIST;
 +	}
  
 -	case -EPERM:
 -		pr_info("IPv6 is disabled via sysctl\n");
 -		break;
 +	dev->ethtool_ops = &vxlan_ethtool_ops;
  
 -	case -EEXIST:
 -		pr_info("duplicate VNI %u\n", conf.vni);
 -		break;
 +	/* create an fdb entry for a valid default destination */
 +	if (!vxlan_addr_any(&vxlan->default_dst.remote_ip)) {
 +		err = vxlan_fdb_create(vxlan, all_zeros_mac,
 +				       &vxlan->default_dst.remote_ip,
 +				       NUD_REACHABLE|NUD_PERMANENT,
 +				       NLM_F_EXCL|NLM_F_CREATE,
 +				       vxlan->dst_port,
 +				       vxlan->default_dst.remote_vni,
 +				       vxlan->default_dst.remote_ifindex,
 +				       NTF_SELF);
 +		if (err)
 +			return err;
  	}
  
 -	return err;
 +	err = register_netdevice(dev);
 +	if (err) {
 +		vxlan_fdb_delete_default(vxlan);
 +		return err;
 +	}
 +
 +	list_add(&vxlan->next, &vn->vxlan_list);
 +
 +	return 0;
  }
  
  static void vxlan_dellink(struct net_device *dev, struct list_head *head)
* Unmerged path drivers/net/vxlan.c
