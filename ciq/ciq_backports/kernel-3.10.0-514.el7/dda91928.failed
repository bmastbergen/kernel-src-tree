net: sctp: remove SCTP_STATIC macro

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] sctp: remove SCTP_STATIC macro (Marcelo Leitner) [1337639]
Rebuild_FUZZ: 92.31%
commit-author Daniel Borkmann <dborkman@redhat.com>
commit dda9192851dcf904b4d1095480834f2a4f814ae3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/dda91928.failed

SCTP_STATIC is just another define for the static keyword. It's use
is inconsistent in the SCTP code anyway and it was introduced in the
initial implementation of SCTP in 2.5. We have a regression suite in
lksctp-tools, but this is for user space only, so noone makes use of
this macro anymore. The kernel test suite for 2.5 is incompatible with
the current SCTP code anyway.

So simply Remove it, to be more consistent with the rest of the kernel
code.

	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Acked-by: Vlad Yasevich <vyasevich@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit dda9192851dcf904b4d1095480834f2a4f814ae3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/socket.c
diff --cc net/sctp/socket.c
index 034c1b60f4e3,75fe92ac2e9c..000000000000
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@@ -1385,22 -1376,14 +1380,28 @@@ static int sctp_setsockopt_connectx(str
  /*
   * New (hopefully final) interface for the API.
   * We use the sctp_getaddrs_old structure so that use-space library
 - * can avoid any unnecessary allocations.   The only defferent part
 + * can avoid any unnecessary allocations. The only different part
   * is that we store the actual length of the address buffer into the
 - * addrs_num structure member.  That way we can re-use the existing
 + * addrs_num structure member. That way we can re-use the existing
   * code.
   */
++<<<<<<< HEAD
 +#ifdef CONFIG_COMPAT
 +struct compat_sctp_getaddrs_old {
 +	sctp_assoc_t	assoc_id;
 +	s32		addr_num;
 +	compat_uptr_t	addrs;		/* struct sockaddr * */
 +};
 +#endif
 +
 +SCTP_STATIC int sctp_getsockopt_connectx3(struct sock* sk, int len,
 +					char __user *optval,
 +					int __user *optlen)
++=======
+ static int sctp_getsockopt_connectx3(struct sock* sk, int len,
+ 				     char __user *optval,
+ 				     int __user *optlen)
++>>>>>>> dda9192851dc (net: sctp: remove SCTP_STATIC macro)
  {
  	struct sctp_getaddrs_old param;
  	sctp_assoc_t assoc_id = 0;
@@@ -3881,10 -3854,9 +3882,10 @@@ out
   * initialized the SCTP-specific portion of the sock.
   * The sock structure should already be zero-filled memory.
   */
- SCTP_STATIC int sctp_init_sock(struct sock *sk)
+ static int sctp_init_sock(struct sock *sk)
  {
  	struct net *net = sock_net(sk);
 +	struct sctp_endpoint *ep;
  	struct sctp_sock *sp;
  
  	SCTP_DEBUG_PRINTK("sctp_init_sock(sk: %p)\n", sk);
@@@ -4024,10 -3987,8 +4025,15 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +/* Cleanup any SCTP per socket resources. Must be called with
 + * sock_net(sk)->sctp.addr_wq_lock held if sp->do_auto_asconf is true
 + */
 +SCTP_STATIC void sctp_destroy_sock(struct sock *sk)
++=======
+ /* Cleanup any SCTP per socket resources.  */
+ static void sctp_destroy_sock(struct sock *sk)
++>>>>>>> dda9192851dc (net: sctp: remove SCTP_STATIC macro)
  {
  	struct sctp_sock *sp;
  
diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.h
index bb0f96d481fd..3ff52ac835a1 100644
--- a/include/net/sctp/sctp.h
+++ b/include/net/sctp/sctp.h
@@ -99,14 +99,6 @@
 #define SCTP_PROTOSW_FLAG INET_PROTOSW_PERMANENT
 #endif
 
-
-/* Certain internal static functions need to be exported when
- * compiled into the test frame.
- */
-#ifndef SCTP_STATIC
-#define SCTP_STATIC static
-#endif
-
 /*
  * Function declarations.
  */
diff --git a/net/sctp/chunk.c b/net/sctp/chunk.c
index 3a4892aa38ae..2139596d407c 100644
--- a/net/sctp/chunk.c
+++ b/net/sctp/chunk.c
@@ -66,7 +66,7 @@ static void sctp_datamsg_init(struct sctp_datamsg *msg)
 }
 
 /* Allocate and initialize datamsg. */
-SCTP_STATIC struct sctp_datamsg *sctp_datamsg_new(gfp_t gfp)
+static struct sctp_datamsg *sctp_datamsg_new(gfp_t gfp)
 {
 	struct sctp_datamsg *msg;
 	msg = kmalloc(sizeof(struct sctp_datamsg), gfp);
diff --git a/net/sctp/input.c b/net/sctp/input.c
index c53999ec1d68..9f7c64188a33 100644
--- a/net/sctp/input.c
+++ b/net/sctp/input.c
@@ -1039,11 +1039,11 @@ hit:
 }
 
 /* Look up an association. BH-safe. */
-SCTP_STATIC
+static
 struct sctp_association *sctp_lookup_association(struct net *net,
 						 const union sctp_addr *laddr,
 						 const union sctp_addr *paddr,
-					    struct sctp_transport **transportp)
+						 struct sctp_transport **transportp)
 {
 	struct sctp_association *asoc;
 
diff --git a/net/sctp/ipv6.c b/net/sctp/ipv6.c
index 09aaba531950..1f8f5afd4563 100644
--- a/net/sctp/ipv6.c
+++ b/net/sctp/ipv6.c
@@ -145,8 +145,8 @@ static struct notifier_block sctp_inet6addr_notifier = {
 };
 
 /* ICMP error handler. */
-SCTP_STATIC void sctp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
-			     u8 type, u8 code, int offset, __be32 info)
+static void sctp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
+			u8 type, u8 code, int offset, __be32 info)
 {
 	struct inet6_dev *idev;
 	struct sock *sk;
diff --git a/net/sctp/protocol.c b/net/sctp/protocol.c
index ce4856e5bfb8..3286f7506e51 100644
--- a/net/sctp/protocol.c
+++ b/net/sctp/protocol.c
@@ -1346,7 +1346,7 @@ static struct pernet_operations sctp_ctrlsock_ops = {
 };
 
 /* Initialize the universe into something sensible.  */
-SCTP_STATIC __init int sctp_init(void)
+static __init int sctp_init(void)
 {
 	int i;
 	int status = -EINVAL;
@@ -1537,7 +1537,7 @@ err_chunk_cachep:
 }
 
 /* Exit handler for the SCTP protocol.  */
-SCTP_STATIC __exit void sctp_exit(void)
+static __exit void sctp_exit(void)
 {
 	/* BUG.  This should probably do something useful like clean
 	 * up all the remaining associations and all that memory.
diff --git a/net/sctp/sm_make_chunk.c b/net/sctp/sm_make_chunk.c
index 226deffa4e7d..979edb86c0e3 100644
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@ -68,9 +68,8 @@
 #include <net/sctp/sctp.h>
 #include <net/sctp/sm.h>
 
-SCTP_STATIC
-struct sctp_chunk *sctp_make_chunk(const struct sctp_association *asoc,
-				   __u8 type, __u8 flags, int paylen);
+static struct sctp_chunk *sctp_make_chunk(const struct sctp_association *asoc,
+					  __u8 type, __u8 flags, int paylen);
 static sctp_cookie_param_t *sctp_pack_cookie(const struct sctp_endpoint *ep,
 					const struct sctp_association *asoc,
 					const struct sctp_chunk *init_chunk,
@@ -1354,9 +1353,8 @@ const union sctp_addr *sctp_source(const struct sctp_chunk *chunk)
 /* Create a new chunk, setting the type and flags headers from the
  * arguments, reserving enough space for a 'paylen' byte payload.
  */
-SCTP_STATIC
-struct sctp_chunk *sctp_make_chunk(const struct sctp_association *asoc,
-				   __u8 type, __u8 flags, int paylen)
+static struct sctp_chunk *sctp_make_chunk(const struct sctp_association *asoc,
+					  __u8 type, __u8 flags, int paylen)
 {
 	struct sctp_chunk *retval;
 	sctp_chunkhdr_t *chunk_hdr;
* Unmerged path net/sctp/socket.c
diff --git a/net/sctp/tsnmap.c b/net/sctp/tsnmap.c
index 396c45174e5b..b46019568a86 100644
--- a/net/sctp/tsnmap.c
+++ b/net/sctp/tsnmap.c
@@ -161,8 +161,8 @@ int sctp_tsnmap_mark(struct sctp_tsnmap *map, __u32 tsn,
 
 
 /* Initialize a Gap Ack Block iterator from memory being provided.  */
-SCTP_STATIC void sctp_tsnmap_iter_init(const struct sctp_tsnmap *map,
-				       struct sctp_tsnmap_iter *iter)
+static void sctp_tsnmap_iter_init(const struct sctp_tsnmap *map,
+				  struct sctp_tsnmap_iter *iter)
 {
 	/* Only start looking one past the Cumulative TSN Ack Point.  */
 	iter->start = map->cumulative_tsn_ack_point + 1;
@@ -171,9 +171,9 @@ SCTP_STATIC void sctp_tsnmap_iter_init(const struct sctp_tsnmap *map,
 /* Get the next Gap Ack Blocks. Returns 0 if there was not another block
  * to get.
  */
-SCTP_STATIC int sctp_tsnmap_next_gap_ack(const struct sctp_tsnmap *map,
-					 struct sctp_tsnmap_iter *iter,
-					 __u16 *start, __u16 *end)
+static int sctp_tsnmap_next_gap_ack(const struct sctp_tsnmap *map,
+				    struct sctp_tsnmap_iter *iter,
+				    __u16 *start, __u16 *end)
 {
 	int ended = 0;
 	__u16 start_ = 0, end_ = 0, offset;
diff --git a/net/sctp/ulpevent.c b/net/sctp/ulpevent.c
index 10c018a5b9fe..44a45dbee4df 100644
--- a/net/sctp/ulpevent.c
+++ b/net/sctp/ulpevent.c
@@ -57,9 +57,9 @@ static void sctp_ulpevent_release_frag_data(struct sctp_ulpevent *event);
 
 
 /* Initialize an ULP event from an given skb.  */
-SCTP_STATIC void sctp_ulpevent_init(struct sctp_ulpevent *event,
-				    int msg_flags,
-				    unsigned int len)
+static void sctp_ulpevent_init(struct sctp_ulpevent *event,
+			       int msg_flags,
+			       unsigned int len)
 {
 	memset(event, 0, sizeof(struct sctp_ulpevent));
 	event->msg_flags = msg_flags;
@@ -67,8 +67,8 @@ SCTP_STATIC void sctp_ulpevent_init(struct sctp_ulpevent *event,
 }
 
 /* Create a new sctp_ulpevent.  */
-SCTP_STATIC struct sctp_ulpevent *sctp_ulpevent_new(int size, int msg_flags,
-						    gfp_t gfp)
+static struct sctp_ulpevent *sctp_ulpevent_new(int size, int msg_flags,
+					       gfp_t gfp)
 {
 	struct sctp_ulpevent *event;
 	struct sk_buff *skb;
