x86/mce: Add a wrapper around mce_log() for injection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] mce: Add a wrapper around mce_log() for injection (Prarit Bhargava) [1301710]
Rebuild_FUZZ: 96.08%
commit-author Borislav Petkov <bp@suse.de>
commit a79da38494ec23f1a7d6ee734e07e9575fd18b58
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a79da384.failed

Will be used by an injector module in a following patch.

Additionally, add a missing module export reported by 0-DAY
kernel test.

	Reported-by: kbuild test robot <fengguang.wu@intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Tony Luck <tony.luck@intel.com>
Link: http://lkml.kernel.org/r/1439396985-12812-13-git-send-email-bp@alien8.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit a79da38494ec23f1a7d6ee734e07e9575fd18b58)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/mcheck/mce.c
diff --cc arch/x86/kernel/cpu/mcheck/mce.c
index 443c1c40000e,e4e6646cac46..000000000000
--- a/arch/x86/kernel/cpu/mcheck/mce.c
+++ b/arch/x86/kernel/cpu/mcheck/mce.c
@@@ -194,43 -199,15 +194,55 @@@ void mce_log(struct mce *mce
  	set_bit(0, &mce_need_notify);
  }
  
++<<<<<<< HEAD
 +static void drain_mcelog_buffer(void)
 +{
 +	unsigned int next, i, prev = 0;
 +
 +	next = ACCESS_ONCE(mcelog.next);
 +
 +	do {
 +		struct mce *m;
 +
 +		/* drain what was logged during boot */
 +		for (i = prev; i < next; i++) {
 +			unsigned long start = jiffies;
 +			unsigned retries = 1;
 +
 +			m = &mcelog.entry[i];
 +
 +			while (!m->finished) {
 +				if (time_after_eq(jiffies, start + 2*retries))
 +					retries++;
 +
 +				cpu_relax();
 +
 +				if (!m->finished && retries >= 4) {
 +					pr_err("skipping error being logged currently!\n");
 +					break;
 +				}
 +			}
 +			smp_rmb();
 +			atomic_notifier_call_chain(&x86_mce_decoder_chain, 0, m);
 +		}
 +
 +		memset(mcelog.entry + prev, 0, (next - prev) * sizeof(*m));
 +		prev = next;
 +		next = cmpxchg(&mcelog.next, prev, 0);
 +	} while (next != prev);
 +}
 +
++=======
+ void mce_inject_log(struct mce *m)
+ {
+ 	mutex_lock(&mce_chrdev_read_mutex);
+ 	mce_log(m);
+ 	mutex_unlock(&mce_chrdev_read_mutex);
+ }
+ EXPORT_SYMBOL_GPL(mce_inject_log);
+ 
+ static struct notifier_block mce_srao_nb;
++>>>>>>> a79da38494ec (x86/mce: Add a wrapper around mce_log() for injection)
  
  void mce_register_decode_chain(struct notifier_block *nb)
  {
diff --git a/arch/x86/kernel/cpu/mcheck/mce-internal.h b/arch/x86/kernel/cpu/mcheck/mce-internal.h
index ea8b62264c14..547720efd923 100644
--- a/arch/x86/kernel/cpu/mcheck/mce-internal.h
+++ b/arch/x86/kernel/cpu/mcheck/mce-internal.h
@@ -79,3 +79,5 @@ static inline int apei_clear_mce(u64 record_id)
 	return -EINVAL;
 }
 #endif
+
+void mce_inject_log(struct mce *m);
* Unmerged path arch/x86/kernel/cpu/mcheck/mce.c
