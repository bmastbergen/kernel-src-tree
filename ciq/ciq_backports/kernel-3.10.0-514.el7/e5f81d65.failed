drm/i915/kbl: Init gen9 workarounds

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drm] i915/kbl: Init gen9 workarounds (Rob Clark) [1348329 1349064]
Rebuild_FUZZ: 93.94%
commit-author Mika Kuoppala <mika.kuoppala@linux.intel.com>
commit e5f81d65ac5a04020d790caf63b2324730ba0277
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e5f81d65.failed

Kabylake is part of gen9 family so init the generic gen9
workarounds for it.

v2: rebase

	Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
	Reviewed-by: Matthew Auld <matthew.auld@intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1465309159-30531-3-git-send-email-mika.kuoppala@intel.com
(cherry picked from commit e5f81d65ac5a04020d790caf63b2324730ba0277)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_ringbuffer.c
diff --cc drivers/gpu/drm/i915/intel_ringbuffer.c
index 005b5e04de4d,f97f70fdda7b..000000000000
--- a/drivers/gpu/drm/i915/intel_ringbuffer.c
+++ b/drivers/gpu/drm/i915/intel_ringbuffer.c
@@@ -904,61 -905,105 +904,138 @@@ static int chv_init_workarounds(struct 
  	return 0;
  }
  
 -static int gen9_init_workarounds(struct intel_engine_cs *engine)
 +static int gen9_init_workarounds(struct intel_engine_cs *ring)
  {
 -	struct drm_i915_private *dev_priv = engine->i915;
 -	uint32_t tmp;
 -	int ret;
 +	struct drm_device *dev = ring->dev;
 +	struct drm_i915_private *dev_priv = dev->dev_private;
  
++<<<<<<< HEAD
 +	/* WaDisablePartialInstShootdown:skl */
++=======
+ 	/* WaEnableLbsSlaRetryTimerDecrement:skl,bxt,kbl */
+ 	I915_WRITE(BDW_SCRATCH1, I915_READ(BDW_SCRATCH1) |
+ 		   GEN9_LBS_SLA_RETRY_TIMER_DECREMENT_ENABLE);
+ 
+ 	/* WaDisableKillLogic:bxt,skl,kbl */
+ 	I915_WRITE(GAM_ECOCHK, I915_READ(GAM_ECOCHK) |
+ 		   ECOCHK_DIS_TLB);
+ 
+ 	/* WaClearFlowControlGpgpuContextSave:skl,bxt,kbl */
+ 	/* WaDisablePartialInstShootdown:skl,bxt,kbl */
++>>>>>>> e5f81d65ac5a (drm/i915/kbl: Init gen9 workarounds)
  	WA_SET_BIT_MASKED(GEN8_ROW_CHICKEN,
 -			  FLOW_CONTROL_ENABLE |
  			  PARTIAL_INSTRUCTION_SHOOTDOWN_DISABLE);
  
++<<<<<<< HEAD
 +	/* Syncing dependencies between camera and graphics */
++=======
+ 	/* Syncing dependencies between camera and graphics:skl,bxt,kbl */
++>>>>>>> e5f81d65ac5a (drm/i915/kbl: Init gen9 workarounds)
  	WA_SET_BIT_MASKED(HALF_SLICE_CHICKEN3,
  			  GEN9_DISABLE_OCL_OOB_SUPPRESS_LOGIC);
  
 -	/* WaDisableDgMirrorFixInHalfSliceChicken5:skl,bxt */
 -	if (IS_SKL_REVID(dev_priv, 0, SKL_REVID_B0) ||
 -	    IS_BXT_REVID(dev_priv, 0, BXT_REVID_A1))
 +	if (INTEL_REVID(dev) == SKL_REVID_A0 ||
 +	    INTEL_REVID(dev) == SKL_REVID_B0) {
 +		/* WaDisableDgMirrorFixInHalfSliceChicken5:skl */
  		WA_CLR_BIT_MASKED(GEN9_HALF_SLICE_CHICKEN5,
  				  GEN9_DG_MIRROR_FIX_ENABLE);
 +	}
  
 -	/* WaSetDisablePixMaskCammingAndRhwoInCommonSliceChicken:skl,bxt */
 -	if (IS_SKL_REVID(dev_priv, 0, SKL_REVID_B0) ||
 -	    IS_BXT_REVID(dev_priv, 0, BXT_REVID_A1)) {
++<<<<<<< HEAD
 +	if (IS_SKYLAKE(dev) && INTEL_REVID(dev) <= SKL_REVID_B0) {
 +		/* WaSetDisablePixMaskCammingAndRhwoInCommonSliceChicken:skl */
  		WA_SET_BIT_MASKED(GEN7_COMMON_SLICE_CHICKEN1,
  				  GEN9_RHWO_OPTIMIZATION_DISABLE);
 +		WA_SET_BIT_MASKED(GEN9_SLICE_COMMON_ECO_CHICKEN0,
 +				  DISABLE_PIXEL_MASK_CAMMING);
 +	}
 +
 +	if (INTEL_REVID(dev) >= SKL_REVID_C0) {
 +		/* WaEnableYV12BugFixInHalfSliceChicken7:skl */
 +		WA_SET_BIT_MASKED(GEN9_HALF_SLICE_CHICKEN7,
 +				  GEN9_ENABLE_YV12_BUGFIX);
 +	}
 +
 +	if (INTEL_REVID(dev) <= SKL_REVID_D0) {
  		/*
 -		 * WA also requires GEN9_SLICE_COMMON_ECO_CHICKEN0[14:14] to be set
 -		 * but we do that in per ctx batchbuffer as there is an issue
 -		 * with this register not getting restored on ctx restore
 +		 *Use Force Non-Coherent whenever executing a 3D context. This
 +		 * is a workaround for a possible hang in the unlikely event
 +		 * a TLB invalidation occurs during a PSD flush.
  		 */
 +		/* WaForceEnableNonCoherent:skl */
 +		WA_SET_BIT_MASKED(HDC_CHICKEN0,
 +				  HDC_FORCE_NON_COHERENT);
  	}
  
 +	/* Wa4x4STCOptimizationDisable:skl */
 +	WA_SET_BIT_MASKED(CACHE_MODE_1, GEN8_4x4_STC_OPTIMIZATION_DISABLE);
 +
 +	/* WaDisablePartialResolveInVc:skl */
 +	WA_SET_BIT_MASKED(CACHE_MODE_1, GEN9_PARTIAL_RESOLVE_IN_VC_DISABLE);
 +
 +	/* WaCcsTlbPrefetchDisable:skl */
 +	WA_CLR_BIT_MASKED(GEN9_HALF_SLICE_CHICKEN5,
 +			  GEN9_CCS_TLB_PREFETCH_ENABLE);
 +
++=======
+ 	/* WaEnableYV12BugFixInHalfSliceChicken7:skl,bxt,kbl */
+ 	/* WaEnableSamplerGPGPUPreemptionSupport:skl,bxt,kbl */
+ 	WA_SET_BIT_MASKED(GEN9_HALF_SLICE_CHICKEN7,
+ 			  GEN9_ENABLE_YV12_BUGFIX |
+ 			  GEN9_ENABLE_GPGPU_PREEMPTION);
+ 
+ 	/* Wa4x4STCOptimizationDisable:skl,bxt,kbl */
+ 	/* WaDisablePartialResolveInVc:skl,bxt,kbl */
+ 	WA_SET_BIT_MASKED(CACHE_MODE_1, (GEN8_4x4_STC_OPTIMIZATION_DISABLE |
+ 					 GEN9_PARTIAL_RESOLVE_IN_VC_DISABLE));
+ 
+ 	/* WaCcsTlbPrefetchDisable:skl,bxt,kbl */
+ 	WA_CLR_BIT_MASKED(GEN9_HALF_SLICE_CHICKEN5,
+ 			  GEN9_CCS_TLB_PREFETCH_ENABLE);
+ 
+ 	/* WaDisableMaskBasedCammingInRCC:skl,bxt */
+ 	if (IS_SKL_REVID(dev_priv, SKL_REVID_C0, SKL_REVID_C0) ||
+ 	    IS_BXT_REVID(dev_priv, 0, BXT_REVID_A1))
+ 		WA_SET_BIT_MASKED(SLICE_ECO_CHICKEN0,
+ 				  PIXEL_MASK_CAMMING_DISABLE);
+ 
+ 	/* WaForceContextSaveRestoreNonCoherent:skl,bxt */
+ 	tmp = HDC_FORCE_CONTEXT_SAVE_RESTORE_NON_COHERENT;
+ 	if (IS_SKL_REVID(dev_priv, SKL_REVID_F0, REVID_FOREVER) ||
+ 	    IS_BXT_REVID(dev_priv, BXT_REVID_B0, REVID_FOREVER))
+ 		tmp |= HDC_FORCE_CSR_NON_COHERENT_OVR_DISABLE;
+ 	WA_SET_BIT_MASKED(HDC_CHICKEN0, tmp);
+ 
+ 	/* WaDisableSamplerPowerBypassForSOPingPong:skl,bxt,kbl */
+ 	if (IS_SKYLAKE(dev_priv) ||
+ 	    IS_KABYLAKE(dev_priv) ||
+ 	    IS_BXT_REVID(dev_priv, 0, BXT_REVID_B0))
+ 		WA_SET_BIT_MASKED(HALF_SLICE_CHICKEN3,
+ 				  GEN8_SAMPLER_POWER_BYPASS_DIS);
+ 
+ 	/* WaDisableSTUnitPowerOptimization:skl,bxt,kbl */
+ 	WA_SET_BIT_MASKED(HALF_SLICE_CHICKEN2, GEN8_ST_PO_DISABLE);
+ 
+ 	/* WaOCLCoherentLineFlush:skl,bxt,kbl */
+ 	I915_WRITE(GEN8_L3SQCREG4, (I915_READ(GEN8_L3SQCREG4) |
+ 				    GEN8_LQSC_FLUSH_COHERENT_LINES));
+ 
+ 	/* WaVFEStateAfterPipeControlwithMediaStateClear:skl,bxt */
+ 	ret = wa_ring_whitelist_reg(engine, GEN9_CTX_PREEMPT_REG);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* WaEnablePreemptionGranularityControlByUMD:skl,bxt,kbl */
+ 	ret= wa_ring_whitelist_reg(engine, GEN8_CS_CHICKEN1);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* WaAllowUMDToModifyHDCChicken1:skl,bxt,kbl */
+ 	ret = wa_ring_whitelist_reg(engine, GEN8_HDC_CHICKEN1);
+ 	if (ret)
+ 		return ret;
+ 
++>>>>>>> e5f81d65ac5a (drm/i915/kbl: Init gen9 workarounds)
  	return 0;
  }
  
@@@ -1024,29 -1114,111 +1101,99 @@@ static int skl_init_workarounds(struct 
  				  HDC_FENCE_DEST_SLM_DISABLE |
  				  HDC_BARRIER_PERFORMANCE_DISABLE);
  
 -	/* WaDisableSbeCacheDispatchPortSharing:skl */
 -	if (IS_SKL_REVID(dev_priv, 0, SKL_REVID_F0))
 -		WA_SET_BIT_MASKED(
 -			GEN7_HALF_SLICE_CHICKEN1,
 -			GEN7_SBE_SS_CACHE_DISPATCH_PORT_SHARING_DISABLE);
 -
 -	/* WaDisableGafsUnitClkGating:skl */
 -	WA_SET_BIT(GEN7_UCGCTL4, GEN8_EU_GAUNIT_CLOCK_GATE_DISABLE);
 -
 -	/* WaDisableLSQCROPERFforOCL:skl */
 -	ret = wa_ring_whitelist_reg(engine, GEN8_L3SQCREG4);
 -	if (ret)
 -		return ret;
 -
 -	return skl_tune_iz_hashing(engine);
 +	return skl_tune_iz_hashing(ring);
  }
  
 -static int bxt_init_workarounds(struct intel_engine_cs *engine)
 +int init_workarounds_ring(struct intel_engine_cs *ring)
  {
 -	struct drm_i915_private *dev_priv = engine->i915;
 -	int ret;
 +	struct drm_device *dev = ring->dev;
 +	struct drm_i915_private *dev_priv = dev->dev_private;
  
++<<<<<<< HEAD
 +	WARN_ON(ring->id != RCS);
++=======
+ 	ret = gen9_init_workarounds(engine);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* WaStoreMultiplePTEenable:bxt */
+ 	/* This is a requirement according to Hardware specification */
+ 	if (IS_BXT_REVID(dev_priv, 0, BXT_REVID_A1))
+ 		I915_WRITE(TILECTL, I915_READ(TILECTL) | TILECTL_TLBPF);
+ 
+ 	/* WaSetClckGatingDisableMedia:bxt */
+ 	if (IS_BXT_REVID(dev_priv, 0, BXT_REVID_A1)) {
+ 		I915_WRITE(GEN7_MISCCPCTL, (I915_READ(GEN7_MISCCPCTL) &
+ 					    ~GEN8_DOP_CLOCK_GATE_MEDIA_ENABLE));
+ 	}
+ 
+ 	/* WaDisableThreadStallDopClockGating:bxt */
+ 	WA_SET_BIT_MASKED(GEN8_ROW_CHICKEN,
+ 			  STALL_DOP_GATING_DISABLE);
+ 
+ 	/* WaDisableSbeCacheDispatchPortSharing:bxt */
+ 	if (IS_BXT_REVID(dev_priv, 0, BXT_REVID_B0)) {
+ 		WA_SET_BIT_MASKED(
+ 			GEN7_HALF_SLICE_CHICKEN1,
+ 			GEN7_SBE_SS_CACHE_DISPATCH_PORT_SHARING_DISABLE);
+ 	}
+ 
+ 	/* WaDisableObjectLevelPreemptionForTrifanOrPolygon:bxt */
+ 	/* WaDisableObjectLevelPreemptionForInstancedDraw:bxt */
+ 	/* WaDisableObjectLevelPreemtionForInstanceId:bxt */
+ 	/* WaDisableLSQCROPERFforOCL:bxt */
+ 	if (IS_BXT_REVID(dev_priv, 0, BXT_REVID_A1)) {
+ 		ret = wa_ring_whitelist_reg(engine, GEN9_CS_DEBUG_MODE1);
+ 		if (ret)
+ 			return ret;
+ 
+ 		ret = wa_ring_whitelist_reg(engine, GEN8_L3SQCREG4);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	/* WaProgramL3SqcReg1DefaultForPerf:bxt */
+ 	if (IS_BXT_REVID(dev_priv, BXT_REVID_B0, REVID_FOREVER))
+ 		I915_WRITE(GEN8_L3SQCREG1, L3_GENERAL_PRIO_CREDITS(62) |
+ 					   L3_HIGH_PRIO_CREDITS(2));
+ 
+ 	return 0;
+ }
+ 
+ static int kbl_init_workarounds(struct intel_engine_cs *engine)
+ {
+ 	int ret;
+ 
+ 	ret = gen9_init_workarounds(engine);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return 0;
+ }
+ 
+ int init_workarounds_ring(struct intel_engine_cs *engine)
+ {
+ 	struct drm_i915_private *dev_priv = engine->i915;
+ 
+ 	WARN_ON(engine->id != RCS);
++>>>>>>> e5f81d65ac5a (drm/i915/kbl: Init gen9 workarounds)
  
  	dev_priv->workarounds.count = 0;
 -	dev_priv->workarounds.hw_whitelist_count[RCS] = 0;
 -
 -	if (IS_BROADWELL(dev_priv))
 -		return bdw_init_workarounds(engine);
  
 -	if (IS_CHERRYVIEW(dev_priv))
 -		return chv_init_workarounds(engine);
 +	if (IS_BROADWELL(dev))
 +		return bdw_init_workarounds(ring);
  
 -	if (IS_SKYLAKE(dev_priv))
 -		return skl_init_workarounds(engine);
 +	if (IS_CHERRYVIEW(dev))
 +		return chv_init_workarounds(ring);
  
 -	if (IS_BROXTON(dev_priv))
 -		return bxt_init_workarounds(engine);
 +	if (IS_SKYLAKE(dev))
 +		return skl_init_workarounds(ring);
 +	else if (IS_GEN9(dev))
 +		return gen9_init_workarounds(ring);
  
+ 	if (IS_KABYLAKE(dev_priv))
+ 		return kbl_init_workarounds(engine);
+ 
  	return 0;
  }
  
* Unmerged path drivers/gpu/drm/i915/intel_ringbuffer.c
