mei: bus: blacklist clients by number of connections

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit dd070a1694c563bd7ba5239dd3038ff1420cf856
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/dd070a16.failed

Currently we support only clients with single connection
and fixed address clients so all other clients are blacklisted

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit dd070a1694c563bd7ba5239dd3038ff1420cf856)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/bus-fixup.c
diff --cc drivers/misc/mei/bus-fixup.c
index 2b65e8021f0d,fd6470f42671..000000000000
--- a/drivers/misc/mei/bus-fixup.c
+++ b/drivers/misc/mei/bus-fixup.c
@@@ -25,6 -27,41 +25,44 @@@
  #include "mei_dev.h"
  #include "client.h"
  
++<<<<<<< HEAD
++=======
+ #define MEI_UUID_NFC_INFO UUID_LE(0xd2de1625, 0x382d, 0x417d, \
+ 			0x48, 0xa4, 0xef, 0xab, 0xba, 0x8a, 0x12, 0x06)
+ 
+ #define MEI_UUID_ANY NULL_UUID_LE
+ 
+ /**
+  * number_of_connections - determine whether an client be on the bus
+  *    according number of connections
+  *    We support only clients:
+  *       1. with single connection
+  *       2. and fixed clients (max_number_of_connections == 0)
+  *
+  * @cldev: me clients device
+  */
+ static void number_of_connections(struct mei_cl_device *cldev)
+ {
+ 	dev_dbg(&cldev->dev, "running hook %s on %pUl\n",
+ 			__func__, mei_me_cl_uuid(cldev->me_cl));
+ 
+ 	if (cldev->me_cl->props.max_number_of_connections > 1)
+ 		cldev->do_match = 0;
+ }
+ 
+ /**
+  * blacklist - blacklist a client from the bus
+  *
+  * @cldev: me clients device
+  */
+ static void blacklist(struct mei_cl_device *cldev)
+ {
+ 	dev_dbg(&cldev->dev, "running hook %s on %pUl\n",
+ 			__func__, mei_me_cl_uuid(cldev->me_cl));
+ 	cldev->do_match = 0;
+ }
+ 
++>>>>>>> dd070a1694c5 (mei: bus: blacklist clients by number of connections)
  struct mei_nfc_cmd {
  	u8 command;
  	u8 status;
@@@ -548,10 -416,64 +586,43 @@@ err
  	return ret;
  }
  
 -void mei_nfc_host_exit(struct mei_device *bus)
 +void mei_nfc_host_exit(struct mei_device *dev)
  {
 -	struct mei_nfc_dev *ndev;
 -	struct mei_cl *cl;
 -	struct mei_cl_device *cldev;
 -
 -	cl = mei_cl_bus_find_cl_by_uuid(bus, mei_nfc_guid);
 -	if (!cl)
 -		return;
 -
 -	cldev = cl->cldev;
 -	if (!cldev)
 -		return;
 -
 -	ndev = (struct mei_nfc_dev *)cldev->priv_data;
 -	if (ndev)
 -		cancel_work_sync(&ndev->init_work);
 -
 -	cldev->priv_data = NULL;
 -
 -	/* Need to remove the device here
 -	 * since mei_nfc_free will unlink the clients
 -	 */
 -	mei_cl_remove_device(cldev);
 -
 -	mutex_lock(&bus->device_lock);
 -	mei_nfc_free(ndev);
 -	mutex_unlock(&bus->device_lock);
 +	struct mei_nfc_dev *ndev = &nfc_dev;
 +	cancel_work_sync(&ndev->init_work);
  }
  
++<<<<<<< HEAD
++=======
+ #define MEI_FIXUP(_uuid, _hook) { _uuid, _hook }
+ 
+ static struct mei_fixup {
+ 
+ 	const uuid_le uuid;
+ 	void (*hook)(struct mei_cl_device *cldev);
+ } mei_fixups[] = {
+ 	MEI_FIXUP(MEI_UUID_ANY, number_of_connections),
+ 	MEI_FIXUP(MEI_UUID_NFC_INFO, blacklist),
+ };
+ 
+ /**
+  * mei_cl_dev_fixup - run fixup handlers
+  *
+  * @cldev: me client device
+  */
+ void mei_cl_dev_fixup(struct mei_cl_device *cldev)
+ {
+ 	struct mei_fixup *f;
+ 	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(mei_fixups); i++) {
+ 
+ 		f = &mei_fixups[i];
+ 		if (uuid_le_cmp(f->uuid, MEI_UUID_ANY) == 0 ||
+ 		    uuid_le_cmp(f->uuid, *uuid) == 0)
+ 			f->hook(cldev);
+ 	}
+ }
++>>>>>>> dd070a1694c5 (mei: bus: blacklist clients by number of connections)
  
* Unmerged path drivers/misc/mei/bus-fixup.c
