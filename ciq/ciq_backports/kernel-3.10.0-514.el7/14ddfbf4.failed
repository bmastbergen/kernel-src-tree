tpm_crb: drop struct resource res from struct crb_priv

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
commit 14ddfbf488a0223b19abf7e4634e6e676a91a12d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/14ddfbf4.failed

The iomem resource is needed only temporarily so it is better to pass
it on instead of storing it permanently. Named the variable as io_res
so that the code better documents itself.

	Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Reviewed-by: Stefan Berger <stefanb@linux.vnet.ibm.com>
(cherry picked from commit 14ddfbf488a0223b19abf7e4634e6e676a91a12d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm_crb.c
diff --cc drivers/char/tpm/tpm_crb.c
index 575071101beb,733cd0e20598..000000000000
--- a/drivers/char/tpm/tpm_crb.c
+++ b/drivers/char/tpm/tpm_crb.c
@@@ -91,6 -77,7 +91,10 @@@ enum crb_flags 
  
  struct crb_priv {
  	unsigned int flags;
++<<<<<<< HEAD
++=======
+ 	void __iomem *iobase;
++>>>>>>> 14ddfbf488a0 (tpm_crb: drop struct resource res from struct crb_priv)
  	struct crb_control_area __iomem *cca;
  	u8 __iomem *cmd;
  	u8 __iomem *rsp;
@@@ -299,6 -221,127 +303,130 @@@ static int crb_acpi_add(struct acpi_dev
  	return tpm_chip_register(chip);
  }
  
++<<<<<<< HEAD
++=======
+ static int crb_check_resource(struct acpi_resource *ares, void *data)
+ {
+ 	struct resource *io_res = data;
+ 	struct resource res;
+ 
+ 	if (acpi_dev_resource_memory(ares, &res)) {
+ 		*io_res = res;
+ 		io_res->name = NULL;
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ static void __iomem *crb_map_res(struct device *dev, struct crb_priv *priv,
+ 				 struct resource *io_res, u64 start, u32 size)
+ {
+ 	struct resource new_res = {
+ 		.start	= start,
+ 		.end	= start + size - 1,
+ 		.flags	= IORESOURCE_MEM,
+ 	};
+ 
+ 	/* Detect a 64 bit address on a 32 bit system */
+ 	if (start != new_res.start)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	if (!resource_contains(io_res, &new_res))
+ 		return devm_ioremap_resource(dev, &new_res);
+ 
+ 	return priv->iobase + (new_res.start - io_res->start);
+ }
+ 
+ static int crb_map_io(struct acpi_device *device, struct crb_priv *priv,
+ 		      struct acpi_table_tpm2 *buf)
+ {
+ 	struct list_head resources;
+ 	struct resource io_res;
+ 	struct device *dev = &device->dev;
+ 	u64 pa;
+ 	int ret;
+ 
+ 	INIT_LIST_HEAD(&resources);
+ 	ret = acpi_dev_get_resources(device, &resources, crb_check_resource,
+ 				     &io_res);
+ 	if (ret < 0)
+ 		return ret;
+ 	acpi_dev_free_resource_list(&resources);
+ 
+ 	if (resource_type(&io_res) != IORESOURCE_MEM) {
+ 		dev_err(dev,
+ 			FW_BUG "TPM2 ACPI table does not define a memory resource\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	priv->iobase = devm_ioremap_resource(dev, &io_res);
+ 	if (IS_ERR(priv->iobase))
+ 		return PTR_ERR(priv->iobase);
+ 
+ 	priv->cca = crb_map_res(dev, priv, &io_res, buf->control_address,
+ 				0x1000);
+ 	if (IS_ERR(priv->cca))
+ 		return PTR_ERR(priv->cca);
+ 
+ 	pa = ((u64) ioread32(&priv->cca->cmd_pa_high) << 32) |
+ 	      (u64) ioread32(&priv->cca->cmd_pa_low);
+ 	priv->cmd = crb_map_res(dev, priv, &io_res, pa,
+ 				ioread32(&priv->cca->cmd_size));
+ 	if (IS_ERR(priv->cmd))
+ 		return PTR_ERR(priv->cmd);
+ 
+ 	memcpy_fromio(&pa, &priv->cca->rsp_pa, 8);
+ 	pa = le64_to_cpu(pa);
+ 	priv->rsp = crb_map_res(dev, priv, &io_res, pa,
+ 				ioread32(&priv->cca->rsp_size));
+ 	return PTR_ERR_OR_ZERO(priv->rsp);
+ }
+ 
+ static int crb_acpi_add(struct acpi_device *device)
+ {
+ 	struct acpi_table_tpm2 *buf;
+ 	struct crb_priv *priv;
+ 	struct device *dev = &device->dev;
+ 	acpi_status status;
+ 	u32 sm;
+ 	int rc;
+ 
+ 	status = acpi_get_table(ACPI_SIG_TPM2, 1,
+ 				(struct acpi_table_header **) &buf);
+ 	if (ACPI_FAILURE(status) || buf->header.length < sizeof(*buf)) {
+ 		dev_err(dev, FW_BUG "failed to get TPM2 ACPI table\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Should the FIFO driver handle this? */
+ 	sm = buf->start_method;
+ 	if (sm == ACPI_TPM2_MEMORY_MAPPED)
+ 		return -ENODEV;
+ 
+ 	priv = devm_kzalloc(dev, sizeof(struct crb_priv), GFP_KERNEL);
+ 	if (!priv)
+ 		return -ENOMEM;
+ 
+ 	/* The reason for the extra quirk is that the PTT in 4th Gen Core CPUs
+ 	 * report only ACPI start but in practice seems to require both
+ 	 * ACPI start and CRB start.
+ 	 */
+ 	if (sm == ACPI_TPM2_COMMAND_BUFFER || sm == ACPI_TPM2_MEMORY_MAPPED ||
+ 	    !strcmp(acpi_device_hid(device), "MSFT0101"))
+ 		priv->flags |= CRB_FL_CRB_START;
+ 
+ 	if (sm == ACPI_TPM2_START_METHOD ||
+ 	    sm == ACPI_TPM2_COMMAND_BUFFER_WITH_START_METHOD)
+ 		priv->flags |= CRB_FL_ACPI_START;
+ 
+ 	rc = crb_map_io(device, priv, buf);
+ 	if (rc)
+ 		return rc;
+ 
+ 	return crb_init(device, priv);
+ }
+ 
++>>>>>>> 14ddfbf488a0 (tpm_crb: drop struct resource res from struct crb_priv)
  static int crb_acpi_remove(struct acpi_device *device)
  {
  	struct device *dev = &device->dev;
* Unmerged path drivers/char/tpm/tpm_crb.c
