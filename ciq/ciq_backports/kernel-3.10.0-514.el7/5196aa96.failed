IB/qib: Remove create and free mad agents

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit 5196aa96e18a7b3ccbf5ec4705fe7981aee03771
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5196aa96.failed

Get rid of create and free mad agent from the driver and use rdmavt
version.

	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 5196aa96e18a7b3ccbf5ec4705fe7981aee03771)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/qib/qib_iba7322.c
#	drivers/infiniband/hw/qib/qib_mad.c
#	drivers/infiniband/hw/qib/qib_verbs.h
diff --cc drivers/infiniband/hw/qib/qib_iba7322.c
index 181e226c8045,a15992259257..000000000000
--- a/drivers/infiniband/hw/qib/qib_iba7322.c
+++ b/drivers/infiniband/hw/qib/qib_iba7322.c
@@@ -5515,7 -5515,7 +5515,11 @@@ static void try_7322_ipg(struct qib_ppo
  			ret = PTR_ERR(ah);
  		else {
  			send_buf->ah = ah;
++<<<<<<< HEAD
 +			ibp->smi_ah = to_iah(ah);
++=======
+ 			ibp->rvp.smi_ah = ibah_to_rvtah(ah);
++>>>>>>> 5196aa96e18a (IB/qib: Remove create and free mad agents)
  			ret = 0;
  		}
  	} else {
diff --cc drivers/infiniband/hw/qib/qib_mad.c
index c65d3aac236c,12735379bfab..000000000000
--- a/drivers/infiniband/hw/qib/qib_mad.c
+++ b/drivers/infiniband/hw/qib/qib_mad.c
@@@ -99,26 -100,26 +99,36 @@@ static void qib_send_trap(struct qib_ib
  	/* o14-1: smp->mkey = 0; */
  	memcpy(smp->data, data, len);
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&ibp->lock, flags);
 +	if (!ibp->sm_ah) {
 +		if (ibp->sm_lid != be16_to_cpu(IB_LID_PERMISSIVE)) {
++=======
+ 	spin_lock_irqsave(&ibp->rvp.lock, flags);
+ 	if (!ibp->rvp.sm_ah) {
+ 		if (ibp->rvp.sm_lid != be16_to_cpu(IB_LID_PERMISSIVE)) {
++>>>>>>> 5196aa96e18a (IB/qib: Remove create and free mad agents)
  			struct ib_ah *ah;
  
 -			ah = qib_create_qp0_ah(ibp, ibp->rvp.sm_lid);
 +			ah = qib_create_qp0_ah(ibp, ibp->sm_lid);
  			if (IS_ERR(ah))
  				ret = PTR_ERR(ah);
  			else {
  				send_buf->ah = ah;
++<<<<<<< HEAD
 +				ibp->sm_ah = to_iah(ah);
++=======
+ 				ibp->rvp.sm_ah = ibah_to_rvtah(ah);
++>>>>>>> 5196aa96e18a (IB/qib: Remove create and free mad agents)
  				ret = 0;
  			}
  		} else
  			ret = -EINVAL;
  	} else {
- 		send_buf->ah = &ibp->sm_ah->ibah;
+ 		send_buf->ah = &ibp->rvp.sm_ah->ibah;
  		ret = 0;
  	}
 -	spin_unlock_irqrestore(&ibp->rvp.lock, flags);
 +	spin_unlock_irqrestore(&ibp->lock, flags);
  
  	if (!ret)
  		ret = ib_post_send_mad(send_buf, NULL);
@@@ -706,21 -708,21 +716,31 @@@ static int subn_set_portinfo(struct ib_
  	smlid = be16_to_cpu(pip->sm_lid);
  	msl = pip->neighbormtu_mastersmsl & 0xF;
  	/* Must be a valid unicast LID address. */
 -	if (smlid == 0 || smlid >= be16_to_cpu(IB_MULTICAST_LID_BASE))
 +	if (smlid == 0 || smlid >= QIB_MULTICAST_LID_BASE)
  		smp->status |= IB_SMP_INVALID_FIELD;
++<<<<<<< HEAD
 +	else if (smlid != ibp->sm_lid || msl != ibp->sm_sl) {
 +		spin_lock_irqsave(&ibp->lock, flags);
 +		if (ibp->sm_ah) {
 +			if (smlid != ibp->sm_lid)
 +				ibp->sm_ah->attr.dlid = smlid;
 +			if (msl != ibp->sm_sl)
 +				ibp->sm_ah->attr.sl = msl;
++=======
+ 	else if (smlid != ibp->rvp.sm_lid || msl != ibp->rvp.sm_sl) {
+ 		spin_lock_irqsave(&ibp->rvp.lock, flags);
+ 		if (ibp->rvp.sm_ah) {
+ 			if (smlid != ibp->rvp.sm_lid)
+ 				ibp->rvp.sm_ah->attr.dlid = smlid;
+ 			if (msl != ibp->rvp.sm_sl)
+ 				ibp->rvp.sm_ah->attr.sl = msl;
++>>>>>>> 5196aa96e18a (IB/qib: Remove create and free mad agents)
  		}
 -		spin_unlock_irqrestore(&ibp->rvp.lock, flags);
 -		if (smlid != ibp->rvp.sm_lid)
 -			ibp->rvp.sm_lid = smlid;
 -		if (msl != ibp->rvp.sm_sl)
 -			ibp->rvp.sm_sl = msl;
 +		spin_unlock_irqrestore(&ibp->lock, flags);
 +		if (smlid != ibp->sm_lid)
 +			ibp->sm_lid = smlid;
 +		if (msl != ibp->sm_sl)
 +			ibp->sm_sl = msl;
  		event.event = IB_EVENT_SM_CHANGE;
  		ib_dispatch_event(&event);
  	}
@@@ -2473,71 -2469,28 +2487,84 @@@ done
  	mod_timer(&ppd->cong_stats.timer, jiffies + HZ);
  }
  
- int qib_create_agents(struct qib_ibdev *dev)
+ void qib_notify_create_mad_agent(struct rvt_dev_info *rdi, int port_idx)
  {
- 	struct qib_devdata *dd = dd_from_dev(dev);
- 	struct ib_mad_agent *agent;
- 	struct qib_ibport *ibp;
- 	int p;
- 	int ret;
+ 	struct qib_ibdev *ibdev = container_of(rdi, struct qib_ibdev, rdi);
+ 	struct qib_devdata *dd = container_of(ibdev,
+ 					      struct qib_devdata, verbs_dev);
  
++<<<<<<< HEAD
 +	for (p = 0; p < dd->num_pports; p++) {
 +		ibp = &dd->pport[p].ibport_data;
 +		agent = ib_register_mad_agent(&dev->rdi.ibdev, p + 1,
 +					      IB_QPT_SMI,
 +					      NULL, 0, send_handler,
 +					      NULL, NULL, 0);
 +		if (IS_ERR(agent)) {
 +			ret = PTR_ERR(agent);
 +			goto err;
 +		}
 +
 +		/* Initialize xmit_wait structure */
 +		dd->pport[p].cong_stats.counter = 0;
 +		init_timer(&dd->pport[p].cong_stats.timer);
 +		dd->pport[p].cong_stats.timer.function = xmit_wait_timer_func;
 +		dd->pport[p].cong_stats.timer.data =
 +			(unsigned long)(&dd->pport[p]);
 +		dd->pport[p].cong_stats.timer.expires = 0;
 +		add_timer(&dd->pport[p].cong_stats.timer);
 +
 +		ibp->send_agent = agent;
 +	}
 +
 +	return 0;
 +
 +err:
 +	for (p = 0; p < dd->num_pports; p++) {
 +		ibp = &dd->pport[p].ibport_data;
 +		if (ibp->send_agent) {
 +			agent = ibp->send_agent;
 +			ibp->send_agent = NULL;
 +			ib_unregister_mad_agent(agent);
 +		}
 +	}
 +
 +	return ret;
++=======
+ 	/* Initialize xmit_wait structure */
+ 	dd->pport[port_idx].cong_stats.counter = 0;
+ 	init_timer(&dd->pport[port_idx].cong_stats.timer);
+ 	dd->pport[port_idx].cong_stats.timer.function = xmit_wait_timer_func;
+ 	dd->pport[port_idx].cong_stats.timer.data =
+ 		(unsigned long)(&dd->pport[port_idx]);
+ 	dd->pport[port_idx].cong_stats.timer.expires = 0;
+ 	add_timer(&dd->pport[port_idx].cong_stats.timer);
++>>>>>>> 5196aa96e18a (IB/qib: Remove create and free mad agents)
  }
  
- void qib_free_agents(struct qib_ibdev *dev)
+ void qib_notify_free_mad_agent(struct rvt_dev_info *rdi, int port_idx)
  {
- 	struct qib_devdata *dd = dd_from_dev(dev);
- 	struct ib_mad_agent *agent;
- 	struct qib_ibport *ibp;
- 	int p;
+ 	struct qib_ibdev *ibdev = container_of(rdi, struct qib_ibdev, rdi);
+ 	struct qib_devdata *dd = container_of(ibdev,
+ 					      struct qib_devdata, verbs_dev);
  
++<<<<<<< HEAD
 +	for (p = 0; p < dd->num_pports; p++) {
 +		ibp = &dd->pport[p].ibport_data;
 +		if (ibp->send_agent) {
 +			agent = ibp->send_agent;
 +			ibp->send_agent = NULL;
 +			ib_unregister_mad_agent(agent);
 +		}
 +		if (ibp->sm_ah) {
 +			ib_destroy_ah(&ibp->sm_ah->ibah);
 +			ibp->sm_ah = NULL;
 +		}
 +		if (dd->pport[p].cong_stats.timer.data)
 +			del_timer_sync(&dd->pport[p].cong_stats.timer);
 +	}
++=======
+ 	if (dd->pport[port_idx].cong_stats.timer.data)
+ 		del_timer_sync(&dd->pport[port_idx].cong_stats.timer);
++>>>>>>> 5196aa96e18a (IB/qib: Remove create and free mad agents)
  }
diff --cc drivers/infiniband/hw/qib/qib_verbs.h
index ca366073af4f,3383d565b8db..000000000000
--- a/drivers/infiniband/hw/qib/qib_verbs.h
+++ b/drivers/infiniband/hw/qib/qib_verbs.h
@@@ -685,21 -306,8 +685,25 @@@ struct qib_pma_counters 
  };
  
  struct qib_ibport {
++<<<<<<< HEAD
 +	struct qib_qp __rcu *qp0;
 +	struct qib_qp __rcu *qp1;
 +	struct ib_mad_agent *send_agent;	/* agent for SMI (traps) */
 +	struct qib_ah *sm_ah;
 +	struct qib_ah *smi_ah;
 +	struct rb_root mcast_tree;
 +	spinlock_t lock;		/* protect changes in this struct */
 +
 +	/* non-zero when timer is set */
 +	unsigned long mkey_lease_timeout;
 +	unsigned long trap_timeout;
 +	__be64 gid_prefix;      /* in network order */
 +	__be64 mkey;
++=======
+ 	struct rvt_ibport rvp;
++>>>>>>> 5196aa96e18a (IB/qib: Remove create and free mad agents)
  	__be64 guids[QIB_GUIDS_PER_PORT	- 1];	/* writable GUIDs */
 +	u64 tid;		/* TID for traps */
  	struct qib_pma_counters __percpu *pmastats;
  	u64 z_unicast_xmit;     /* starting count for PMA */
  	u64 z_unicast_rcv;      /* starting count for PMA */
* Unmerged path drivers/infiniband/hw/qib/qib_iba7322.c
* Unmerged path drivers/infiniband/hw/qib/qib_mad.c
diff --git a/drivers/infiniband/hw/qib/qib_verbs.c b/drivers/infiniband/hw/qib/qib_verbs.c
index c4417a1f33be..3bd474414fac 100644
--- a/drivers/infiniband/hw/qib/qib_verbs.c
+++ b/drivers/infiniband/hw/qib/qib_verbs.c
@@ -2291,23 +2291,16 @@ int qib_register_ib_device(struct qib_devdata *dd)
 
 	ret = rvt_register_device(&dd->verbs_dev.rdi);
 	if (ret)
-		goto err_reg;
-
-	ret = qib_create_agents(dev);
-	if (ret)
-		goto err_agents;
+		goto err_tx;
 
 	ret = qib_verbs_register_sysfs(dd);
 	if (ret)
 		goto err_class;
 
-	goto bail;
+	return ret;
 
 err_class:
-	qib_free_agents(dev);
-err_agents:
 	rvt_unregister_device(&dd->verbs_dev.rdi);
-err_reg:
 err_tx:
 	while (!list_empty(&dev->txreq_free)) {
 		struct list_head *l = dev->txreq_free.next;
@@ -2328,7 +2321,6 @@ err_lk:
 	kfree(dev->qp_table);
 err_qpt:
 	qib_dev_err(dd, "cannot register verbs: %d!\n", -ret);
-bail:
 	return ret;
 }
 
@@ -2340,8 +2332,6 @@ void qib_unregister_ib_device(struct qib_devdata *dd)
 
 	qib_verbs_unregister_sysfs(dd);
 
-	qib_free_agents(dev);
-
 	rvt_unregister_device(&dd->verbs_dev.rdi);
 
 	if (!list_empty(&dev->piowait))
* Unmerged path drivers/infiniband/hw/qib/qib_verbs.h
