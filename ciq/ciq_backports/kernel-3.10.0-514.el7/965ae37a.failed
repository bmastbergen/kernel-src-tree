mei: implement async notification hbm messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 965ae37ab86eb8cd327c5752dc9e2190d33db25c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/965ae37a.failed

Implement sending and reception handlers for the
async event notification hbm commands.
Add client notification book keeping data required for the messages
    notify_en to indicate whether notification is enabled
    notify_ev to indicate whether an event is pending

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 965ae37ab86eb8cd327c5752dc9e2190d33db25c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/hbm.c
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/hbm.c
index 3cb8e1000d69,8a73fa06f3c4..000000000000
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@@ -288,6 -312,215 +288,125 @@@ static int mei_hbm_enum_clients_req(str
  	return 0;
  }
  
 -/*
 - * mei_hbm_me_cl_add - add new me client to the list
 - *
 - * @dev: the device structure
 - * @res: hbm property response
 - *
 - * Return: 0 on success and -ENOMEM on allocation failure
 - */
 -
 -static int mei_hbm_me_cl_add(struct mei_device *dev,
 -			     struct hbm_props_response *res)
 -{
 -	struct mei_me_client *me_cl;
 -	const uuid_le *uuid = &res->client_properties.protocol_name;
 -
 -	mei_me_cl_rm_by_uuid(dev, uuid);
 -
 -	me_cl = kzalloc(sizeof(struct mei_me_client), GFP_KERNEL);
 -	if (!me_cl)
 -		return -ENOMEM;
 -
 -	mei_me_cl_init(me_cl);
 -
 -	me_cl->props = res->client_properties;
 -	me_cl->client_id = res->me_addr;
 -	me_cl->mei_flow_ctrl_creds = 0;
 -
 -	mei_me_cl_add(dev, me_cl);
 -
 -	return 0;
 -}
 -
 -/**
 - * mei_hbm_add_cl_resp - send response to fw on client add request
 - *
 - * @dev: the device structure
 - * @addr: me address
 - * @status: response status
 - *
 - * Return: 0 on success and < 0 on failure
 - */
 -static int mei_hbm_add_cl_resp(struct mei_device *dev, u8 addr, u8 status)
 -{
 -	struct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;
 -	struct hbm_add_client_response *resp;
 -	const size_t len = sizeof(struct hbm_add_client_response);
 -	int ret;
 -
 -	dev_dbg(dev->dev, "adding client response\n");
 -
 -	resp = (struct hbm_add_client_response *)dev->wr_msg.data;
 -
 -	mei_hbm_hdr(mei_hdr, len);
 -	memset(resp, 0, sizeof(struct hbm_add_client_response));
 -
 -	resp->hbm_cmd = MEI_HBM_ADD_CLIENT_RES_CMD;
 -	resp->me_addr = addr;
 -	resp->status  = status;
 -
 -	ret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);
 -	if (ret)
 -		dev_err(dev->dev, "add client response write failed: ret = %d\n",
 -			ret);
 -	return ret;
 -}
 -
 -/**
 - * mei_hbm_fw_add_cl_req - request from the fw to add a client
 - *
 - * @dev: the device structure
 - * @req: add client request
 - *
 - * Return: 0 on success and < 0 on failure
 - */
 -static int mei_hbm_fw_add_cl_req(struct mei_device *dev,
 -			      struct hbm_add_client_request *req)
 -{
 -	int ret;
 -	u8 status = MEI_HBMS_SUCCESS;
 -
 -	BUILD_BUG_ON(sizeof(struct hbm_add_client_request) !=
 -			sizeof(struct hbm_props_response));
 -
 -	ret = mei_hbm_me_cl_add(dev, (struct hbm_props_response *)req);
 -	if (ret)
 -		status = !MEI_HBMS_SUCCESS;
 -
 -	return mei_hbm_add_cl_resp(dev, req->me_addr, status);
 -}
 -
+ /**
+  * mei_hbm_cl_notify_req - send notification request
+  *
+  * @dev: the device structure
+  * @cl: a client to disconnect from
+  * @start: true for start false for stop
+  *
+  * Return: 0 on success and -EIO on write failure
+  */
+ int mei_hbm_cl_notify_req(struct mei_device *dev,
+ 			  struct mei_cl *cl, u8 start)
+ {
+ 
+ 	struct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;
+ 	struct hbm_notification_request *req;
+ 	const size_t len = sizeof(struct hbm_notification_request);
+ 	int ret;
+ 
+ 	mei_hbm_hdr(mei_hdr, len);
+ 	mei_hbm_cl_hdr(cl, MEI_HBM_NOTIFY_REQ_CMD, dev->wr_msg.data, len);
+ 
+ 	req = (struct hbm_notification_request *)dev->wr_msg.data;
+ 	req->start = start;
+ 
+ 	ret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);
+ 	if (ret)
+ 		dev_err(dev->dev, "notify request failed: ret = %d\n", ret);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  *  notify_res_to_fop - convert notification response to the proper
+  *      notification FOP
+  *
+  * @cmd: client notification start response command
+  *
+  * Return:  MEI_FOP_NOTIFY_START or MEI_FOP_NOTIFY_STOP;
+  */
+ static inline enum mei_cb_file_ops notify_res_to_fop(struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct hbm_notification_response *rs =
+ 		(struct hbm_notification_response *)cmd;
+ 
+ 	if (rs->start == MEI_HBM_NOTIFICATION_START)
+ 		return MEI_FOP_NOTIFY_START;
+ 	else
+ 		return MEI_FOP_NOTIFY_STOP;
+ }
+ 
+ /**
+  * mei_hbm_cl_notify_start_res - update the client state according
+  *       notify start response
+  *
+  * @dev: the device structure
+  * @cl: mei host client
+  * @cmd: client notification start response command
+  */
+ static void mei_hbm_cl_notify_start_res(struct mei_device *dev,
+ 					struct mei_cl *cl,
+ 					struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct hbm_notification_response *rs =
+ 		(struct hbm_notification_response *)cmd;
+ 
+ 	cl_dbg(dev, cl, "hbm: notify start response status=%d\n", rs->status);
+ 
+ 	if (rs->status == MEI_HBMS_SUCCESS ||
+ 	    rs->status == MEI_HBMS_ALREADY_STARTED) {
+ 		cl->notify_en = true;
+ 		cl->status = 0;
+ 	} else {
+ 		cl->status = -EINVAL;
+ 	}
+ }
+ 
+ /**
+  * mei_hbm_cl_notify_stop_res - update the client state according
+  *       notify stop response
+  *
+  * @dev: the device structure
+  * @cl: mei host client
+  * @cmd: client notification stop response command
+  */
+ static void mei_hbm_cl_notify_stop_res(struct mei_device *dev,
+ 				       struct mei_cl *cl,
+ 				       struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct hbm_notification_response *rs =
+ 		(struct hbm_notification_response *)cmd;
+ 
+ 	cl_dbg(dev, cl, "hbm: notify stop response status=%d\n", rs->status);
+ 
+ 	if (rs->status == MEI_HBMS_SUCCESS ||
+ 	    rs->status == MEI_HBMS_NOT_STARTED) {
+ 		cl->notify_en = false;
+ 		cl->status = 0;
+ 	} else {
+ 		/* TODO: spec is not clear yet about other possible issues */
+ 		cl->status = -EINVAL;
+ 	}
+ }
+ 
+ /**
+  * mei_hbm_cl_notify - signal notification event
+  *
+  * @dev: the device structure
+  * @cmd: notification client message
+  */
+ static void mei_hbm_cl_notify(struct mei_device *dev,
+ 			      struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct mei_cl *cl;
+ 
+ 	cl = mei_hbm_cl_find_by_cmd(dev, cmd);
+ 	if (cl && cl->notify_en)
+ 		cl->notify_ev = true;
+ }
+ 
  /**
   * mei_hbm_prop_req - request property for a single client
   *
@@@ -607,11 -830,17 +726,17 @@@ static void mei_hbm_cl_res(struct mei_d
  
  	switch (fop_type) {
  	case MEI_FOP_CONNECT:
 -		mei_hbm_cl_connect_res(dev, cl, rs);
 +		mei_hbm_cl_connect_res(cl, rs);
  		break;
  	case MEI_FOP_DISCONNECT:
 -		mei_hbm_cl_disconnect_res(dev, cl, rs);
 +		mei_hbm_cl_disconnect_res(cl, rs);
  		break;
+ 	case MEI_FOP_NOTIFY_START:
+ 		mei_hbm_cl_notify_start_res(dev, cl, rs);
+ 		break;
+ 	case MEI_FOP_NOTIFY_STOP:
+ 		mei_hbm_cl_notify_stop_res(dev, cl, rs);
+ 		break;
  	default:
  		return;
  	}
@@@ -911,6 -1133,39 +1036,42 @@@ int mei_hbm_dispatch(struct mei_device 
  			return -EIO;
  		}
  		break;
++<<<<<<< HEAD
++=======
+ 
+ 	case MEI_HBM_ADD_CLIENT_REQ_CMD:
+ 		dev_dbg(dev->dev, "hbm: add client request received\n");
+ 		/*
+ 		 * after the host receives the enum_resp
+ 		 * message clients may be added or removed
+ 		 */
+ 		if (dev->hbm_state <= MEI_HBM_ENUM_CLIENTS &&
+ 		    dev->hbm_state >= MEI_HBM_STOPPED) {
+ 			dev_err(dev->dev, "hbm: add client: state mismatch, [%d, %d]\n",
+ 				dev->dev_state, dev->hbm_state);
+ 			return -EPROTO;
+ 		}
+ 		add_cl_req = (struct hbm_add_client_request *)mei_msg;
+ 		ret = mei_hbm_fw_add_cl_req(dev, add_cl_req);
+ 		if (ret) {
+ 			dev_err(dev->dev, "hbm: add client: failed to send response %d\n",
+ 				ret);
+ 			return -EIO;
+ 		}
+ 		dev_dbg(dev->dev, "hbm: add client request processed\n");
+ 		break;
+ 
+ 	case MEI_HBM_NOTIFY_RES_CMD:
+ 		dev_dbg(dev->dev, "hbm: notify response received\n");
+ 		mei_hbm_cl_res(dev, cl_cmd, notify_res_to_fop(cl_cmd));
+ 		break;
+ 
+ 	case MEI_HBM_NOTIFICATION_CMD:
+ 		dev_dbg(dev->dev, "hbm: notification\n");
+ 		mei_hbm_cl_notify(dev, cl_cmd);
+ 		break;
+ 
++>>>>>>> 965ae37ab86e (mei: implement async notification hbm messages)
  	default:
  		BUG();
  		break;
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,362ebb15ccd9..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -134,11 -131,13 +134,21 @@@ enum mei_wd_states 
  
  /**
   * enum mei_cb_file_ops  - file operation associated with the callback
++<<<<<<< HEAD
 + * @MEI_FOP_READ      - read
 + * @MEI_FOP_WRITE     - write
 + * @MEI_FOP_CONNECT   - connect
 + * @MEI_FOP_DISCONNECT - disconnect
 + * @MEI_FOP_DISCONNECT_RSP - disconnect response
++=======
+  * @MEI_FOP_READ:       read
+  * @MEI_FOP_WRITE:      write
+  * @MEI_FOP_CONNECT:    connect
+  * @MEI_FOP_DISCONNECT: disconnect
+  * @MEI_FOP_DISCONNECT_RSP: disconnect response
+  * @MEI_FOP_NOTIFY_START:   start notification
+  * @MEI_FOP_NOTIFY_STOP:    stop notification
++>>>>>>> 965ae37ab86e (mei: implement async notification hbm messages)
   */
  enum mei_cb_file_ops {
  	MEI_FOP_READ = 0,
@@@ -201,10 -220,35 +213,37 @@@ struct mei_cl_cb 
  	unsigned long buf_idx;
  	unsigned long read_time;
  	struct file *file_object;
 -	int status;
  	u32 internal:1;
 -	u32 completed:1;
  };
  
++<<<<<<< HEAD
 +/* MEI client instance carried as file->private_data*/
++=======
+ /**
+  * struct mei_cl - me client host representation
+  *    carried in file->private_data
+  *
+  * @link: link in the clients list
+  * @dev: mei parent device
+  * @state: file operation state
+  * @tx_wait: wait queue for tx completion
+  * @rx_wait: wait queue for rx completion
+  * @wait:  wait queue for management operation
+  * @status: connection status
+  * @me_cl: fw client connected
+  * @host_client_id: host id
+  * @mei_flow_ctrl_creds: transmit flow credentials
+  * @timer_count:  watchdog timer for operation completion
+  * @reserved: reserved for alignment
+  * @notify_en: notification - enabled/disabled
+  * @notify_ev: pending notification event
+  * @writing_state: state of the tx
+  * @rd_pending: pending read credits
+  * @rd_completed: completed read
+  *
+  * @cldev: device on the mei client bus
+  */
++>>>>>>> 965ae37ab86e (mei: implement async notification hbm messages)
  struct mei_cl {
  	struct list_head link;
  	struct mei_device *dev;
@@@ -213,20 -257,18 +252,26 @@@
  	wait_queue_head_t rx_wait;
  	wait_queue_head_t wait;
  	int status;
 -	struct mei_me_client *me_cl;
 +	/* ID of client connected */
  	u8 host_client_id;
 +	u8 me_client_id;
  	u8 mei_flow_ctrl_creds;
  	u8 timer_count;
++<<<<<<< HEAD
 +	enum mei_file_transaction_states reading_state;
++=======
+ 	u8 reserved;
+ 	u8 notify_en;
+ 	u8 notify_ev;
++>>>>>>> 965ae37ab86e (mei: implement async notification hbm messages)
  	enum mei_file_transaction_states writing_state;
 -	struct list_head rd_pending;
 -	struct list_head rd_completed;
 +	int sm_state;
 +	struct mei_cl_cb *read_cb;
  
 -	struct mei_cl_device *cldev;
 +	/* MEI CL bus data */
 +	struct mei_cl_device *device;
 +	struct list_head device_link;
 +	uuid_le device_uuid;
  };
  
  /** struct mei_hw_ops
* Unmerged path drivers/misc/mei/hbm.c
diff --git a/drivers/misc/mei/hbm.h b/drivers/misc/mei/hbm.h
index 09d8e7e9a365..df7ff97bb801 100644
--- a/drivers/misc/mei/hbm.h
+++ b/drivers/misc/mei/hbm.h
@@ -63,6 +63,8 @@ int mei_hbm_cl_disconnect_rsp(struct mei_device *dev, struct mei_cl *cl);
 int mei_hbm_cl_connect_req(struct mei_device *dev, struct mei_cl *cl);
 bool mei_hbm_version_is_supported(struct mei_device *dev);
 int mei_hbm_pg(struct mei_device *dev, u8 pg_cmd);
+int mei_hbm_cl_notify_req(struct mei_device *dev,
+			  struct mei_cl *cl, u8 request);
 
 #endif /* _MEI_HBM_H_ */
 
* Unmerged path drivers/misc/mei/mei_dev.h
