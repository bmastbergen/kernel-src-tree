drm/i915/gen9: fix plane_blocks_per_line on watermarks calculations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drm] i915/gen9: fix plane_blocks_per_line on watermarks calculations (Lyude Paul) [1341633 1355776]
Rebuild_FUZZ: 96.92%
commit-author Paulo Zanoni <paulo.r.zanoni@intel.com>
commit 7a1a8aed67e0a60772defe3f6499eb340da48634
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7a1a8aed.failed

The confusing thing is that plane_blocks_per_line is listed as part of
the method 2 calculation but is also used for other things. We
calculated it in two different places and different ways: one inside
skl_wm_method2() and the other inside skl_compute_plane_wm(). The
skl_wm_method2() implementation is the one that matches the
specification.

With this patch we fix the skl_compute_plane_wm() calculation and just
pass it as a parameter to skl_wm_method2(). We also take care to not
modify the value of plane_bytes_per_line since we're going to rely on
it having a correct value in later patches.

This should affect the watermarks for Linear and Y-tiled.

From my analysis, it looks like the two plane_blocks_per_line
variables got out of sync on 0fda65680e92, but we can't really say
that commit was a regression, it looks like just an incomplete fix.
There's always the possibility that 0fda65680e92 matched our
specification at that time, and then later the specification changed.

v2: Try to add a "Fixes" tag (Maarten).

Fixes: 0fda65680e92 ("drm/i915/skl: Update watermarks for Y tiling")
	Cc: stable@vger.kernel.org
	Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
	Reviewed-by: Lyude <cpaul@redhat.com>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1474578035-424-7-git-send-email-paulo.r.zanoni@intel.com
(cherry picked from commit 7a1a8aed67e0a60772defe3f6499eb340da48634)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index b2b6b26d47bc,051eda99a53a..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -2748,27 -3494,14 +2748,33 @@@ static uint32_t skl_wm_method1(uint32_
  }
  
  static uint32_t skl_wm_method2(uint32_t pixel_rate, uint32_t pipe_htotal,
++<<<<<<< HEAD
 +			       uint32_t horiz_pixels, uint8_t bytes_per_pixel,
 +			       uint64_t tiling, uint32_t latency)
++=======
+ 			       uint32_t latency, uint32_t plane_blocks_per_line)
++>>>>>>> 7a1a8aed67e0 (drm/i915/gen9: fix plane_blocks_per_line on watermarks calculations)
  {
  	uint32_t ret;
- 	uint32_t plane_bytes_per_line, plane_blocks_per_line;
  	uint32_t wm_intermediate_val;
  
  	if (latency == 0)
  		return UINT_MAX;
  
++<<<<<<< HEAD
 +	plane_bytes_per_line = horiz_pixels * bytes_per_pixel;
 +
 +	if (tiling == I915_FORMAT_MOD_Y_TILED ||
 +	    tiling == I915_FORMAT_MOD_Yf_TILED) {
 +		plane_bytes_per_line *= 4;
 +		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);
 +		plane_blocks_per_line /= 4;
 +	} else {
 +		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);
 +	}
 +
++=======
++>>>>>>> 7a1a8aed67e0 (drm/i915/gen9: fix plane_blocks_per_line on watermarks calculations)
  	wm_intermediate_val = latency * pixel_rate;
  	ret = DIV_ROUND_UP(wm_intermediate_val, pipe_htotal * 1000) *
  				plane_blocks_per_line;
@@@ -2878,41 -3549,70 +2884,90 @@@ static bool skl_compute_plane_wm(const 
  	uint32_t plane_bytes_per_line, plane_blocks_per_line;
  	uint32_t res_blocks, res_lines;
  	uint32_t selected_result;
 -	uint8_t cpp;
 -	uint32_t width = 0, height = 0;
 -	uint32_t plane_pixel_rate;
 -	uint32_t y_min_scanlines;
 -
 -	if (latency == 0 || !cstate->base.active || !intel_pstate->base.visible) {
 -		*enabled = false;
 -		return 0;
 -	}
  
 -	width = drm_rect_width(&intel_pstate->base.src) >> 16;
 -	height = drm_rect_height(&intel_pstate->base.src) >> 16;
 +	if (latency == 0 || !p->active || !p_params->enabled)
 +		return false;
  
 +	method1 = skl_wm_method1(p->pixel_rate,
 +				 p_params->bytes_per_pixel,
 +				 latency);
 +	method2 = skl_wm_method2(p->pixel_rate,
 +				 p->pipe_htotal,
 +				 p_params->horiz_pixels,
 +				 p_params->bytes_per_pixel,
 +				 p_params->tiling,
 +				 latency);
 +
++<<<<<<< HEAD
 +	plane_bytes_per_line = p_params->horiz_pixels *
 +					p_params->bytes_per_pixel;
 +	plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);
++=======
+ 	if (intel_rotation_90_or_270(pstate->rotation))
+ 		swap(width, height);
+ 
+ 	cpp = drm_format_plane_cpp(fb->pixel_format, 0);
+ 	plane_pixel_rate = skl_adjusted_plane_pixel_rate(cstate, intel_pstate);
+ 
+ 	if (intel_rotation_90_or_270(pstate->rotation)) {
+ 		int cpp = (fb->pixel_format == DRM_FORMAT_NV12) ?
+ 			drm_format_plane_cpp(fb->pixel_format, 1) :
+ 			drm_format_plane_cpp(fb->pixel_format, 0);
+ 
+ 		switch (cpp) {
+ 		case 1:
+ 			y_min_scanlines = 16;
+ 			break;
+ 		case 2:
+ 			y_min_scanlines = 8;
+ 			break;
+ 		default:
+ 			WARN(1, "Unsupported pixel depth for rotation");
+ 		case 4:
+ 			y_min_scanlines = 4;
+ 			break;
+ 		}
+ 	} else {
+ 		y_min_scanlines = 4;
+ 	}
+ 
+ 	plane_bytes_per_line = width * cpp;
+ 	if (fb->modifier[0] == I915_FORMAT_MOD_Y_TILED ||
+ 	    fb->modifier[0] == I915_FORMAT_MOD_Yf_TILED) {
+ 		plane_blocks_per_line =
+ 		      DIV_ROUND_UP(plane_bytes_per_line * y_min_scanlines, 512);
+ 		plane_blocks_per_line /= y_min_scanlines;
+ 	} else if (fb->modifier[0] == DRM_FORMAT_MOD_NONE) {
+ 		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512)
+ 					+ 1;
+ 	} else {
+ 		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);
+ 	}
+ 
+ 	method1 = skl_wm_method1(plane_pixel_rate, cpp, latency);
+ 	method2 = skl_wm_method2(plane_pixel_rate,
+ 				 cstate->base.adjusted_mode.crtc_htotal,
+ 				 latency,
+ 				 plane_blocks_per_line);
 -
 -	if (fb->modifier[0] == I915_FORMAT_MOD_Y_TILED ||
 -	    fb->modifier[0] == I915_FORMAT_MOD_Yf_TILED) {
 -		uint32_t y_tile_minimum = plane_blocks_per_line *
 -					  y_min_scanlines;
++>>>>>>> 7a1a8aed67e0 (drm/i915/gen9: fix plane_blocks_per_line on watermarks calculations)
 +
 +	if (p_params->tiling == I915_FORMAT_MOD_Y_TILED ||
 +	    p_params->tiling == I915_FORMAT_MOD_Yf_TILED) {
 +		uint32_t min_scanlines = 4;
 +		uint32_t y_tile_minimum;
 +		if (intel_rotation_90_or_270(p_params->rotation)) {
 +			switch (p_params->bytes_per_pixel) {
 +			case 1:
 +				min_scanlines = 16;
 +				break;
 +			case 2:
 +				min_scanlines = 8;
 +				break;
 +			case 8:
 +				WARN(1, "Unsupported pixel depth for rotation");
 +			}
 +		}
 +		y_tile_minimum = plane_blocks_per_line * min_scanlines;
  		selected_result = max(method2, y_tile_minimum);
  	} else {
  		if ((ddb_allocation / plane_blocks_per_line) >= 1)
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
