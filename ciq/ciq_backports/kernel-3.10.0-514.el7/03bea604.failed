ovl: get_write_access() in truncate

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 03bea60409328de54e4ff7ec41672e12a9cb0908
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/03bea604.failed

When truncating a file we should check write access on the underlying
inode.  And we should do so on the lower file as well (before copy-up) for
consistency.

Original patch and test case by Aihua Zhang.

 - - >o >o - - test.c - - >o >o - -
#include <stdio.h>
#include <errno.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
	int ret;

	ret = truncate(argv[0], 4096);
	if (ret != -1) {
		fprintf(stderr, "truncate(argv[0]) should have failed\n");
		return 1;
	}
	if (errno != ETXTBSY) {
		perror("truncate(argv[0])");
		return 1;
	}

	return 0;
}
 - - >o >o - - >o >o - - >o >o - -

	Reported-by: Aihua Zhang <zhangaihua1@huawei.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
	Cc: <stable@vger.kernel.org>
(cherry picked from commit 03bea60409328de54e4ff7ec41672e12a9cb0908)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/inode.c
diff --cc fs/overlayfs/inode.c
index fadb018e83fe,c831c2e5f803..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -49,14 -59,37 +49,43 @@@ int ovl_setattr(struct dentry *dentry, 
  	if (err)
  		goto out;
  
+ 	if (attr->ia_valid & ATTR_SIZE) {
+ 		struct inode *realinode = d_inode(ovl_dentry_real(dentry));
+ 
+ 		err = -ETXTBSY;
+ 		if (atomic_read(&realinode->i_writecount) < 0)
+ 			goto out_drop_write;
+ 	}
+ 
  	err = ovl_copy_up(dentry);
  	if (!err) {
+ 		struct inode *winode = NULL;
+ 
  		upperdentry = ovl_dentry_upper(dentry);
  
++<<<<<<< HEAD
 +		mutex_lock(&upperdentry->d_inode->i_mutex);
 +		err = notify_change(upperdentry, attr, NULL);
 +		mutex_unlock(&upperdentry->d_inode->i_mutex);
++=======
+ 		if (attr->ia_valid & ATTR_SIZE) {
+ 			winode = d_inode(upperdentry);
+ 			err = get_write_access(winode);
+ 			if (err)
+ 				goto out_drop_write;
+ 		}
+ 
+ 		inode_lock(upperdentry->d_inode);
+ 		err = notify_change(upperdentry, attr, NULL);
+ 		if (!err)
+ 			ovl_copyattr(upperdentry->d_inode, dentry->d_inode);
+ 		inode_unlock(upperdentry->d_inode);
+ 
+ 		if (winode)
+ 			put_write_access(winode);
++>>>>>>> 03bea6040932 (ovl: get_write_access() in truncate)
  	}
+ out_drop_write:
  	ovl_drop_write(dentry);
  out:
  	return err;
* Unmerged path fs/overlayfs/inode.c
