tty: Preset lock subclass for nested tty locks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [tty] Preset lock subclass for nested tty locks ("Herton R. Krzesinski") [1327403]
Rebuild_FUZZ: 94.25%
commit-author Peter Hurley <peter@hurleysoftware.com>
commit 2febdb632bb96235b94b8fccaf882a78f8f4b2bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2febdb63.failed

Eliminate the requirement of specifying the tty lock nesting at
lock time; instead, set the lock subclass for slave ptys at pty
install (normal ttys and master ptys use subclass 0).

	Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 2febdb632bb96235b94b8fccaf882a78f8f4b2bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/tty_mutex.c
#	include/linux/tty.h
diff --cc drivers/tty/tty_mutex.c
index 2e41abebbcba,4486741190c4..000000000000
--- a/drivers/tty/tty_mutex.c
+++ b/drivers/tty/tty_mutex.c
@@@ -45,29 -44,23 +39,45 @@@ void __lockfunc tty_unlock(struct tty_s
  }
  EXPORT_SYMBOL(tty_unlock);
  
 -void __lockfunc tty_lock_slave(struct tty_struct *tty)
 +/*
 + * Getting the big tty mutex for a pair of ttys with lock ordering
 + * On a non pty/tty pair tty2 can be NULL which is just fine.
 + */
 +void __lockfunc tty_lock_pair(struct tty_struct *tty,
 +					struct tty_struct *tty2)
  {
++<<<<<<< HEAD
 +	if (tty < tty2) {
 +		tty_lock(tty);
 +		tty_lock_nested(tty2, TTY_MUTEX_NESTED);
 +	} else {
 +		if (tty2 && tty2 != tty)
 +			tty_lock(tty2);
 +		tty_lock_nested(tty, TTY_MUTEX_NESTED);
++=======
+ 	if (tty && tty != tty->link) {
+ 		WARN_ON(!mutex_is_locked(&tty->link->legacy_mutex) ||
+ 			!tty->driver->type == TTY_DRIVER_TYPE_PTY ||
+ 			!tty->driver->type == PTY_TYPE_SLAVE);
+ 		tty_lock(tty);
++>>>>>>> 2febdb632bb9 (tty: Preset lock subclass for nested tty locks)
  	}
  }
 +EXPORT_SYMBOL(tty_lock_pair);
  
 -void __lockfunc tty_unlock_slave(struct tty_struct *tty)
 +void __lockfunc tty_unlock_pair(struct tty_struct *tty,
 +						struct tty_struct *tty2)
  {
 -	if (tty && tty != tty->link)
 -		tty_unlock(tty);
 +	tty_unlock(tty);
 +	if (tty2 && tty2 != tty)
 +		tty_unlock(tty2);
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(tty_unlock_pair);
++=======
+ 
+ void tty_set_lock_subclass(struct tty_struct *tty)
+ {
+ 	lockdep_set_subclass(&tty->legacy_mutex, TTY_MUTEX_SLAVE);
+ }
++>>>>>>> 2febdb632bb9 (tty: Preset lock subclass for nested tty locks)
diff --cc include/linux/tty.h
index 47ea59da6369,196c352a5ce8..000000000000
--- a/include/linux/tty.h
+++ b/include/linux/tty.h
@@@ -624,11 -638,9 +624,17 @@@ extern long vt_compat_ioctl(struct tty_
  /* functions for preparation of BKL removal */
  extern void __lockfunc tty_lock(struct tty_struct *tty);
  extern void __lockfunc tty_unlock(struct tty_struct *tty);
++<<<<<<< HEAD
 +extern void __lockfunc tty_lock_pair(struct tty_struct *tty,
 +				struct tty_struct *tty2);
 +extern void __lockfunc tty_unlock_pair(struct tty_struct *tty,
 +				struct tty_struct *tty2);
 +
++=======
+ extern void __lockfunc tty_lock_slave(struct tty_struct *tty);
+ extern void __lockfunc tty_unlock_slave(struct tty_struct *tty);
+ extern void tty_set_lock_subclass(struct tty_struct *tty);
++>>>>>>> 2febdb632bb9 (tty: Preset lock subclass for nested tty locks)
  /*
   * this shall be called only from where BTM is held (like close)
   *
diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index c672158d4566..ebe05fe56717 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -350,6 +350,8 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	}
 	initialize_tty_struct(o_tty, driver->other, idx);
 
+	tty_set_lock_subclass(o_tty);
+
 	if (legacy) {
 		/* We always use new tty termios data so we can do this
 		   the easy way .. */
* Unmerged path drivers/tty/tty_mutex.c
* Unmerged path include/linux/tty.h
