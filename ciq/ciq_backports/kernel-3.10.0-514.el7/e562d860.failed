netfilter: nf_tables: kill nft_data_cmp()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Patrick McHardy <kaber@trash.net>
commit e562d860d7c8ad28f83dc4c9094fd3ae648ea0d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e562d860.failed

Only needlessly complicates things due to requiring specific argument
types. Use memcmp directly.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit e562d860d7c8ad28f83dc4c9094fd3ae648ea0d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables.h
#	net/netfilter/nft_cmp.c
#	net/netfilter/nft_hash.c
#	net/netfilter/nft_rbtree.c
diff --cc include/net/netfilter/nf_tables.h
index 4ab50d820db0,fca0b5def629..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -46,12 -54,20 +46,29 @@@ struct nft_data 
  	};
  } __attribute__((aligned(__alignof__(u64))));
  
++<<<<<<< HEAD
 +static inline int nft_data_cmp(const struct nft_data *d1,
 +			       const struct nft_data *d2,
 +			       unsigned int len)
 +{
 +	return memcmp(d1->data, d2->data, len);
 +}
++=======
+ /**
+  *	struct nft_regs - nf_tables register set
+  *
+  *	@data: data registers
+  *	@verdict: verdict register
+  *
+  *	The first four data registers alias to the verdict register.
+  */
+ struct nft_regs {
+ 	union {
+ 		struct nft_data 	data[NFT_REG_MAX + 1];
+ 		struct nft_verdict	verdict;
+ 	};
+ };
++>>>>>>> e562d860d7c8 (netfilter: nf_tables: kill nft_data_cmp())
  
  static inline void nft_data_copy(struct nft_data *dst,
  				 const struct nft_data *src)
diff --cc net/netfilter/nft_cmp.c
index e2b3f51c81f1,b7e1c58864cf..000000000000
--- a/net/netfilter/nft_cmp.c
+++ b/net/netfilter/nft_cmp.c
@@@ -31,7 -31,7 +31,11 @@@ static void nft_cmp_eval(const struct n
  	const struct nft_cmp_expr *priv = nft_expr_priv(expr);
  	int d;
  
++<<<<<<< HEAD
 +	d = nft_data_cmp(&data[priv->sreg], &priv->data, priv->len);
++=======
+ 	d = memcmp(&regs->data[priv->sreg], &priv->data, priv->len);
++>>>>>>> e562d860d7c8 (netfilter: nf_tables: kill nft_data_cmp())
  	switch (priv->op) {
  	case NFT_CMP_EQ:
  		if (d != 0)
diff --cc net/netfilter/nft_hash.c
index f14a5e14123a,26ba4e192121..000000000000
--- a/net/netfilter/nft_hash.c
+++ b/net/netfilter/nft_hash.c
@@@ -23,22 -24,68 +23,62 @@@
  /* We target a hash table size of 4, element hint is 75% of final size */
  #define NFT_HASH_ELEMENT_HINT 3
  
 -struct nft_hash {
 -	struct rhashtable		ht;
 -	struct delayed_work		gc_work;
 -};
 -
  struct nft_hash_elem {
  	struct rhash_head		node;
 -	struct nft_set_ext		ext;
 +	struct nft_data			key;
 +	struct nft_data			data[];
  };
  
++<<<<<<< HEAD
++=======
+ struct nft_hash_cmp_arg {
+ 	const struct nft_set		*set;
+ 	const struct nft_data		*key;
+ 	u8				genmask;
+ };
+ 
+ static const struct rhashtable_params nft_hash_params;
+ 
+ static inline u32 nft_hash_key(const void *data, u32 len, u32 seed)
+ {
+ 	const struct nft_hash_cmp_arg *arg = data;
+ 
+ 	return jhash(arg->key, len, seed);
+ }
+ 
+ static inline u32 nft_hash_obj(const void *data, u32 len, u32 seed)
+ {
+ 	const struct nft_hash_elem *he = data;
+ 
+ 	return jhash(nft_set_ext_key(&he->ext), len, seed);
+ }
+ 
+ static inline int nft_hash_cmp(struct rhashtable_compare_arg *arg,
+ 			       const void *ptr)
+ {
+ 	const struct nft_hash_cmp_arg *x = arg->key;
+ 	const struct nft_hash_elem *he = ptr;
+ 
+ 	if (memcmp(nft_set_ext_key(&he->ext), x->key, x->set->klen))
+ 		return 1;
+ 	if (nft_set_elem_expired(&he->ext))
+ 		return 1;
+ 	if (!nft_set_elem_active(&he->ext, x->genmask))
+ 		return 1;
+ 	return 0;
+ }
+ 
++>>>>>>> e562d860d7c8 (netfilter: nf_tables: kill nft_data_cmp())
  static bool nft_hash_lookup(const struct nft_set *set,
  			    const struct nft_data *key,
 -			    const struct nft_set_ext **ext)
 +			    struct nft_data *data)
  {
 -	struct nft_hash *priv = nft_set_priv(set);
 +	const struct rhashtable *priv = nft_set_priv(set);
  	const struct nft_hash_elem *he;
 -	struct nft_hash_cmp_arg arg = {
 -		.genmask = nft_genmask_cur(read_pnet(&set->pnet)),
 -		.set	 = set,
 -		.key	 = key,
 -	};
  
 -	he = rhashtable_lookup_fast(&priv->ht, &arg, nft_hash_params);
 -	if (he != NULL)
 -		*ext = &he->ext;
 +	he = rhashtable_lookup(priv, key);
 +	if (he && set->flags & NFT_SET_MAP)
 +		nft_data_copy(data, he->data);
  
  	return !!he;
  }
diff --cc net/netfilter/nft_rbtree.c
index 2c75361077f7,b398f1a856d5..000000000000
--- a/net/netfilter/nft_rbtree.c
+++ b/net/netfilter/nft_rbtree.c
@@@ -45,7 -45,7 +45,11 @@@ static bool nft_rbtree_lookup(const str
  	while (parent != NULL) {
  		rbe = rb_entry(parent, struct nft_rbtree_elem, node);
  
++<<<<<<< HEAD
 +		d = nft_data_cmp(&rbe->key, key, set->klen);
++=======
+ 		d = memcmp(nft_set_ext_key(&rbe->ext), key, set->klen);
++>>>>>>> e562d860d7c8 (netfilter: nf_tables: kill nft_data_cmp())
  		if (d < 0) {
  			parent = parent->rb_left;
  			interval = rbe;
@@@ -96,7 -91,9 +100,13 @@@ static int __nft_rbtree_insert(const st
  	while (*p != NULL) {
  		parent = *p;
  		rbe = rb_entry(parent, struct nft_rbtree_elem, node);
++<<<<<<< HEAD
 +		d = nft_data_cmp(&rbe->key, &new->key, set->klen);
++=======
+ 		d = memcmp(nft_set_ext_key(&rbe->ext),
+ 			   nft_set_ext_key(&new->ext),
+ 			   set->klen);
++>>>>>>> e562d860d7c8 (netfilter: nf_tables: kill nft_data_cmp())
  		if (d < 0)
  			p = &parent->rb_left;
  		else if (d > 0)
@@@ -162,7 -153,7 +172,11 @@@ static int nft_rbtree_get(const struct 
  	while (parent != NULL) {
  		rbe = rb_entry(parent, struct nft_rbtree_elem, node);
  
++<<<<<<< HEAD
 +		d = nft_data_cmp(&rbe->key, &elem->key, set->klen);
++=======
+ 		d = memcmp(nft_set_ext_key(&rbe->ext), &elem->key, set->klen);
++>>>>>>> e562d860d7c8 (netfilter: nf_tables: kill nft_data_cmp())
  		if (d < 0)
  			parent = parent->rb_left;
  		else if (d > 0)
* Unmerged path include/net/netfilter/nf_tables.h
* Unmerged path net/netfilter/nft_cmp.c
* Unmerged path net/netfilter/nft_hash.c
* Unmerged path net/netfilter/nft_rbtree.c
