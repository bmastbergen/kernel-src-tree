pinctrl: baytrail: Save pin context over system sleep

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [pinctrl] baytrail: Save pin context over system sleep (Prarit Bhargava) [1339663]
Rebuild_FUZZ: 90.72%
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit fcc18deb7682dafcf6176b4af81d1554ffabd8b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fcc18deb.failed

The BIOS might reconfigure pins as it needs when S3 is entered. This might
cause drivers using the GPIOs to fail because the state was wrong or
interrupts stopped working.

Fix this by saving and restoring enough pin context over system sleep.

	Reported-by: Hans Holmberg <hans.holmberg@intel.com>
	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit fcc18deb7682dafcf6176b4af81d1554ffabd8b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pinctrl/pinctrl-baytrail.c
diff --cc drivers/pinctrl/pinctrl-baytrail.c
index 409727cd72ed,2062c224e32f..000000000000
--- a/drivers/pinctrl/pinctrl-baytrail.c
+++ b/drivers/pinctrl/pinctrl-baytrail.c
@@@ -137,9 -138,13 +141,14 @@@ static struct pinctrl_gpio_range byt_ra
  	},
  };
  
+ struct byt_gpio_pin_context {
+ 	u32 conf0;
+ 	u32 val;
+ };
+ 
  struct byt_gpio {
  	struct gpio_chip		chip;
 +	struct irq_domain		*domain;
  	struct platform_device		*pdev;
  	spinlock_t			lock;
  	void __iomem			*reg_base;
@@@ -614,28 -591,13 +624,35 @@@ static int byt_gpio_probe(struct platfo
  	gc->set = byt_gpio_set;
  	gc->dbg_show = byt_gpio_dbg_show;
  	gc->base = -1;
 -	gc->can_sleep = false;
 +	gc->can_sleep = 0;
  	gc->dev = dev;
  
++<<<<<<< HEAD:drivers/pinctrl/pinctrl-baytrail.c
 +	/* set up interrupts  */
 +	irq_rc = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 +	if (irq_rc && irq_rc->start) {
 +		hwirq = irq_rc->start;
 +		gc->to_irq = byt_gpio_to_irq;
 +
 +		vg->domain = irq_domain_add_linear(NULL, gc->ngpio,
 +						   &byt_gpio_irq_ops, vg);
 +		if (!vg->domain)
 +			return -ENXIO;
 +
 +		byt_gpio_irq_init_hw(vg);
 +
 +		irq_set_handler_data(hwirq, vg);
 +		irq_set_chained_handler(hwirq, byt_gpio_irq_handler);
 +
 +		/* Register interrupt handlers for gpio signaled acpi events */
 +		acpi_gpiochip_request_interrupts(gc);
 +	}
++=======
+ #ifdef CONFIG_PM_SLEEP
+ 	vg->saved_context = devm_kcalloc(&pdev->dev, gc->ngpio,
+ 				       sizeof(*vg->saved_context), GFP_KERNEL);
+ #endif
++>>>>>>> fcc18deb7682 (pinctrl: baytrail: Save pin context over system sleep):drivers/pinctrl/intel/pinctrl-baytrail.c
  
  	ret = gpiochip_add(gc);
  	if (ret) {
* Unmerged path drivers/pinctrl/pinctrl-baytrail.c
