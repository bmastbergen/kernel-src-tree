qed: Replace memset with eth_zero_addr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] Replace memset with eth_zero_addr (Don Dutile) [1169955 1259940 1262728 1275187 1275209 1275423 1275425 1289615 1291874 1292284 1292872 1296195 1296269 1296338 1296344 1298707 1302166 1310156]
Rebuild_FUZZ: 92.96%
commit-author Shyam Saini <mayhs11saini@gmail.com>
commit 0ee28e31553a6f2ed13223e565ae5a4d7a376942
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0ee28e31.failed

Use eth_zero_addr to assign zero address to the given address array
instead of memset when the second argument in memset is address
of zero. Also, it makes the code clearer

	Signed-off-by: Shyam Saini <mayhs11saini@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0ee28e31553a6f2ed13223e565ae5a4d7a376942)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_sriov.c
diff --cc drivers/net/ethernet/qlogic/qed/qed_sriov.c
index c325ee857ecd,3f4bf31f45e0..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_sriov.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_sriov.c
@@@ -1106,7 -1224,10 +1106,14 @@@ void qed_iov_clean_vf(struct qed_hwfn *
  		return;
  
  	/* Clear the VF mac */
++<<<<<<< HEAD
 +	memset(vf_info->mac, 0, ETH_ALEN);
++=======
+ 	eth_zero_addr(vf_info->mac);
+ 
+ 	vf_info->rx_accept_mode = 0;
+ 	vf_info->tx_accept_mode = 0;
++>>>>>>> 0ee28e31553a (qed: Replace memset with eth_zero_addr)
  }
  
  static void qed_iov_vf_cleanup(struct qed_hwfn *p_hwfn,
@@@ -2222,8 -2611,81 +2229,86 @@@ static int qed_iov_vf_update_unicast_sh
  	return 0;
  }
  
++<<<<<<< HEAD
 +int qed_iov_chk_ucast(struct qed_hwfn *hwfn,
 +		      int vfid, struct qed_filter_ucast *params)
++=======
+ static int qed_iov_vf_update_mac_shadow(struct qed_hwfn *p_hwfn,
+ 					struct qed_vf_info *p_vf,
+ 					struct qed_filter_ucast *p_params)
+ {
+ 	int i;
+ 
+ 	/* If we're in forced-mode, we don't allow any change */
+ 	if (p_vf->bulletin.p_virt->valid_bitmap & BIT(MAC_ADDR_FORCED))
+ 		return 0;
+ 
+ 	/* First remove entries and then add new ones */
+ 	if (p_params->opcode == QED_FILTER_REMOVE) {
+ 		for (i = 0; i < QED_ETH_VF_NUM_MAC_FILTERS; i++) {
+ 			if (ether_addr_equal(p_vf->shadow_config.macs[i],
+ 					     p_params->mac)) {
+ 				eth_zero_addr(p_vf->shadow_config.macs[i]);
+ 				break;
+ 			}
+ 		}
+ 
+ 		if (i == QED_ETH_VF_NUM_MAC_FILTERS) {
+ 			DP_VERBOSE(p_hwfn, QED_MSG_IOV,
+ 				   "MAC isn't configured\n");
+ 			return -EINVAL;
+ 		}
+ 	} else if (p_params->opcode == QED_FILTER_REPLACE ||
+ 		   p_params->opcode == QED_FILTER_FLUSH) {
+ 		for (i = 0; i < QED_ETH_VF_NUM_MAC_FILTERS; i++)
+ 			eth_zero_addr(p_vf->shadow_config.macs[i]);
+ 	}
+ 
+ 	/* List the new MAC address */
+ 	if (p_params->opcode != QED_FILTER_ADD &&
+ 	    p_params->opcode != QED_FILTER_REPLACE)
+ 		return 0;
+ 
+ 	for (i = 0; i < QED_ETH_VF_NUM_MAC_FILTERS; i++) {
+ 		if (is_zero_ether_addr(p_vf->shadow_config.macs[i])) {
+ 			ether_addr_copy(p_vf->shadow_config.macs[i],
+ 					p_params->mac);
+ 			DP_VERBOSE(p_hwfn, QED_MSG_IOV,
+ 				   "Added MAC at %d entry in shadow\n", i);
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (i == QED_ETH_VF_NUM_MAC_FILTERS) {
+ 		DP_VERBOSE(p_hwfn, QED_MSG_IOV, "No available place for MAC\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qed_iov_vf_update_unicast_shadow(struct qed_hwfn *p_hwfn,
+ 				 struct qed_vf_info *p_vf,
+ 				 struct qed_filter_ucast *p_params)
+ {
+ 	int rc = 0;
+ 
+ 	if (p_params->type == QED_FILTER_MAC) {
+ 		rc = qed_iov_vf_update_mac_shadow(p_hwfn, p_vf, p_params);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	if (p_params->type == QED_FILTER_VLAN)
+ 		rc = qed_iov_vf_update_vlan_shadow(p_hwfn, p_vf, p_params);
+ 
+ 	return rc;
+ }
+ 
+ static int qed_iov_chk_ucast(struct qed_hwfn *hwfn,
+ 			     int vfid, struct qed_filter_ucast *params)
++>>>>>>> 0ee28e31553a (qed: Replace memset with eth_zero_addr)
  {
  	struct qed_public_vf_info *vf;
  
diff --git a/drivers/net/ethernet/qlogic/qed/qed_l2.c b/drivers/net/ethernet/qlogic/qed/qed_l2.c
index 8fba87dd48af..b6260b00f5db 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_l2.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_l2.c
@@ -1691,7 +1691,7 @@ static int qed_fill_eth_dev_info(struct qed_dev *cdev,
 	qed_fill_dev_info(cdev, &info->common);
 
 	if (IS_VF(cdev))
-		memset(info->common.hw_mac, 0, ETH_ALEN);
+		eth_zero_addr(info->common.hw_mac);
 
 	return 0;
 }
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_sriov.c
