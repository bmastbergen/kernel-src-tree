cxl: Poll for outstanding IRQs when detaching a context

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Michael Neuling <mikey@neuling.org>
commit 2bc79ffcbb817873cc43d63118008ab75181b73d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2bc79ffc.failed

When detaching contexts, we may still have interrupts in the system
which are yet to be delivered to any CPU and be acked in the PSL.
This can result in a subsequent unrelated process getting an spurious
IRQ or an interrupt for a non-existent context.

This polls the PSL to ensure that the PSL is clear of IRQs for the
detached context, before removing the context from the idr.

	Signed-off-by: Michael Neuling <mikey@neuling.org>
	Tested-by: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
	Acked-by: Ian Munsie <imunsie@au1.ibm.com>
	Tested-by: Vaibhav Jain <vaibhav@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 2bc79ffcbb817873cc43d63118008ab75181b73d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/cxl/cxl.h
#	drivers/misc/cxl/native.c
diff --cc drivers/misc/cxl/cxl.h
index ea4888bb5ce4,73dc2a33da74..000000000000
--- a/drivers/misc/cxl/cxl.h
+++ b/drivers/misc/cxl/cxl.h
@@@ -769,6 -815,73 +770,75 @@@ void cxl_pci_vphb_reconfigure(struct cx
  void cxl_pci_vphb_remove(struct cxl_afu *afu);
  
  extern struct pci_driver cxl_pci_driver;
 -extern struct platform_driver cxl_of_driver;
  int afu_allocate_irqs(struct cxl_context *ctx, u32 count);
  
++<<<<<<< HEAD
++=======
+ int afu_open(struct inode *inode, struct file *file);
+ int afu_release(struct inode *inode, struct file *file);
+ long afu_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+ int afu_mmap(struct file *file, struct vm_area_struct *vm);
+ unsigned int afu_poll(struct file *file, struct poll_table_struct *poll);
+ ssize_t afu_read(struct file *file, char __user *buf, size_t count, loff_t *off);
+ extern const struct file_operations afu_fops;
+ 
+ struct cxl *cxl_guest_init_adapter(struct device_node *np, struct platform_device *dev);
+ void cxl_guest_remove_adapter(struct cxl *adapter);
+ int cxl_of_read_adapter_handle(struct cxl *adapter, struct device_node *np);
+ int cxl_of_read_adapter_properties(struct cxl *adapter, struct device_node *np);
+ ssize_t cxl_guest_read_adapter_vpd(struct cxl *adapter, void *buf, size_t len);
+ ssize_t cxl_guest_read_afu_vpd(struct cxl_afu *afu, void *buf, size_t len);
+ int cxl_guest_init_afu(struct cxl *adapter, int slice, struct device_node *afu_np);
+ void cxl_guest_remove_afu(struct cxl_afu *afu);
+ int cxl_of_read_afu_handle(struct cxl_afu *afu, struct device_node *afu_np);
+ int cxl_of_read_afu_properties(struct cxl_afu *afu, struct device_node *afu_np);
+ int cxl_guest_add_chardev(struct cxl *adapter);
+ void cxl_guest_remove_chardev(struct cxl *adapter);
+ void cxl_guest_reload_module(struct cxl *adapter);
+ int cxl_of_probe(struct platform_device *pdev);
+ 
+ struct cxl_backend_ops {
+ 	struct module *module;
+ 	int (*adapter_reset)(struct cxl *adapter);
+ 	int (*alloc_one_irq)(struct cxl *adapter);
+ 	void (*release_one_irq)(struct cxl *adapter, int hwirq);
+ 	int (*alloc_irq_ranges)(struct cxl_irq_ranges *irqs,
+ 				struct cxl *adapter, unsigned int num);
+ 	void (*release_irq_ranges)(struct cxl_irq_ranges *irqs,
+ 				struct cxl *adapter);
+ 	int (*setup_irq)(struct cxl *adapter, unsigned int hwirq,
+ 			unsigned int virq);
+ 	irqreturn_t (*handle_psl_slice_error)(struct cxl_context *ctx,
+ 					u64 dsisr, u64 errstat);
+ 	irqreturn_t (*psl_interrupt)(int irq, void *data);
+ 	int (*ack_irq)(struct cxl_context *ctx, u64 tfc, u64 psl_reset_mask);
+ 	void (*irq_wait)(struct cxl_context *ctx);
+ 	int (*attach_process)(struct cxl_context *ctx, bool kernel,
+ 			u64 wed, u64 amr);
+ 	int (*detach_process)(struct cxl_context *ctx);
+ 	bool (*support_attributes)(const char *attr_name, enum cxl_attrs type);
+ 	bool (*link_ok)(struct cxl *cxl, struct cxl_afu *afu);
+ 	void (*release_afu)(struct device *dev);
+ 	ssize_t (*afu_read_err_buffer)(struct cxl_afu *afu, char *buf,
+ 				loff_t off, size_t count);
+ 	int (*afu_check_and_enable)(struct cxl_afu *afu);
+ 	int (*afu_activate_mode)(struct cxl_afu *afu, int mode);
+ 	int (*afu_deactivate_mode)(struct cxl_afu *afu, int mode);
+ 	int (*afu_reset)(struct cxl_afu *afu);
+ 	int (*afu_cr_read8)(struct cxl_afu *afu, int cr_idx, u64 offset, u8 *val);
+ 	int (*afu_cr_read16)(struct cxl_afu *afu, int cr_idx, u64 offset, u16 *val);
+ 	int (*afu_cr_read32)(struct cxl_afu *afu, int cr_idx, u64 offset, u32 *val);
+ 	int (*afu_cr_read64)(struct cxl_afu *afu, int cr_idx, u64 offset, u64 *val);
+ 	int (*afu_cr_write8)(struct cxl_afu *afu, int cr_idx, u64 offset, u8 val);
+ 	int (*afu_cr_write16)(struct cxl_afu *afu, int cr_idx, u64 offset, u16 val);
+ 	int (*afu_cr_write32)(struct cxl_afu *afu, int cr_idx, u64 offset, u32 val);
+ 	ssize_t (*read_adapter_vpd)(struct cxl *adapter, void *buf, size_t count);
+ };
+ extern const struct cxl_backend_ops cxl_native_ops;
+ extern const struct cxl_backend_ops cxl_guest_ops;
+ extern const struct cxl_backend_ops *cxl_ops;
+ 
+ /* check if the given pci_dev is on the the cxl vphb bus */
+ bool cxl_pci_is_vphb_device(struct pci_dev *dev);
++>>>>>>> 2bc79ffcbb81 (cxl: Poll for outstanding IRQs when detaching a context)
  #endif
diff --cc drivers/misc/cxl/native.c
index 588c4e3aa772,ecf7557cd657..000000000000
--- a/drivers/misc/cxl/native.c
+++ b/drivers/misc/cxl/native.c
@@@ -797,7 -798,36 +798,40 @@@ static irqreturn_t cxl_irq_multiplexed(
  	return fail_psl_irq(afu, &irq_info);
  }
  
++<<<<<<< HEAD
 +static irqreturn_t cxl_slice_irq_err(int irq, void *data)
++=======
+ void native_irq_wait(struct cxl_context *ctx)
+ {
+ 	u64 dsisr;
+ 	int timeout = 1000;
+ 	int ph;
+ 
+ 	/*
+ 	 * Wait until no further interrupts are presented by the PSL
+ 	 * for this context.
+ 	 */
+ 	while (timeout--) {
+ 		ph = cxl_p2n_read(ctx->afu, CXL_PSL_PEHandle_An) & 0xffff;
+ 		if (ph != ctx->pe)
+ 			return;
+ 		dsisr = cxl_p2n_read(ctx->afu, CXL_PSL_DSISR_An);
+ 		if ((dsisr & CXL_PSL_DSISR_PENDING) == 0)
+ 			return;
+ 		/*
+ 		 * We are waiting for the workqueue to process our
+ 		 * irq, so need to let that run here.
+ 		 */
+ 		msleep(1);
+ 	}
+ 
+ 	dev_warn(&ctx->afu->dev, "WARNING: waiting on DSI for PE %i"
+ 		 " DSISR %016llx!\n", ph, dsisr);
+ 	return;
+ }
+ 
+ static irqreturn_t native_slice_irq_err(int irq, void *data)
++>>>>>>> 2bc79ffcbb81 (cxl: Poll for outstanding IRQs when detaching a context)
  {
  	struct cxl_afu *afu = data;
  	u64 fir_slice, errstat, serr, afu_debug;
@@@ -998,7 -1041,88 +1032,88 @@@ u8 cxl_afu_cr_read8(struct cxl_afu *afu
  {
  	u64 aligned_off = off & ~0x3L;
  	u32 val;
 -	int rc;
  
 -	rc = native_afu_cr_read32(afu, cr, aligned_off, &val);
 -	if (!rc)
 -		*out = (val >> ((off & 0x3) * 8)) & 0xff;
 -	return rc;
 +	val = cxl_afu_cr_read32(afu, cr, aligned_off);
 +	return (val >> ((off & 0x3) * 8)) & 0xff;
  }
++<<<<<<< HEAD
++=======
+ 
+ static int native_afu_cr_write32(struct cxl_afu *afu, int cr, u64 off, u32 in)
+ {
+ 	if (unlikely(!cxl_ops->link_ok(afu->adapter, afu)))
+ 		return -EIO;
+ 	if (unlikely(off >= afu->crs_len))
+ 		return -ERANGE;
+ 	out_le32(afu->native->afu_desc_mmio + afu->crs_offset +
+ 		(cr * afu->crs_len) + off, in);
+ 	return 0;
+ }
+ 
+ static int native_afu_cr_write16(struct cxl_afu *afu, int cr, u64 off, u16 in)
+ {
+ 	u64 aligned_off = off & ~0x3L;
+ 	u32 val32, mask, shift;
+ 	int rc;
+ 
+ 	rc = native_afu_cr_read32(afu, cr, aligned_off, &val32);
+ 	if (rc)
+ 		return rc;
+ 	shift = (off & 0x3) * 8;
+ 	WARN_ON(shift == 24);
+ 	mask = 0xffff << shift;
+ 	val32 = (val32 & ~mask) | (in << shift);
+ 
+ 	rc = native_afu_cr_write32(afu, cr, aligned_off, val32);
+ 	return rc;
+ }
+ 
+ static int native_afu_cr_write8(struct cxl_afu *afu, int cr, u64 off, u8 in)
+ {
+ 	u64 aligned_off = off & ~0x3L;
+ 	u32 val32, mask, shift;
+ 	int rc;
+ 
+ 	rc = native_afu_cr_read32(afu, cr, aligned_off, &val32);
+ 	if (rc)
+ 		return rc;
+ 	shift = (off & 0x3) * 8;
+ 	mask = 0xff << shift;
+ 	val32 = (val32 & ~mask) | (in << shift);
+ 
+ 	rc = native_afu_cr_write32(afu, cr, aligned_off, val32);
+ 	return rc;
+ }
+ 
+ const struct cxl_backend_ops cxl_native_ops = {
+ 	.module = THIS_MODULE,
+ 	.adapter_reset = cxl_pci_reset,
+ 	.alloc_one_irq = cxl_pci_alloc_one_irq,
+ 	.release_one_irq = cxl_pci_release_one_irq,
+ 	.alloc_irq_ranges = cxl_pci_alloc_irq_ranges,
+ 	.release_irq_ranges = cxl_pci_release_irq_ranges,
+ 	.setup_irq = cxl_pci_setup_irq,
+ 	.handle_psl_slice_error = native_handle_psl_slice_error,
+ 	.psl_interrupt = NULL,
+ 	.ack_irq = native_ack_irq,
+ 	.irq_wait = native_irq_wait,
+ 	.attach_process = native_attach_process,
+ 	.detach_process = native_detach_process,
+ 	.support_attributes = native_support_attributes,
+ 	.link_ok = cxl_adapter_link_ok,
+ 	.release_afu = cxl_pci_release_afu,
+ 	.afu_read_err_buffer = cxl_pci_afu_read_err_buffer,
+ 	.afu_check_and_enable = native_afu_check_and_enable,
+ 	.afu_activate_mode = native_afu_activate_mode,
+ 	.afu_deactivate_mode = native_afu_deactivate_mode,
+ 	.afu_reset = native_afu_reset,
+ 	.afu_cr_read8 = native_afu_cr_read8,
+ 	.afu_cr_read16 = native_afu_cr_read16,
+ 	.afu_cr_read32 = native_afu_cr_read32,
+ 	.afu_cr_read64 = native_afu_cr_read64,
+ 	.afu_cr_write8 = native_afu_cr_write8,
+ 	.afu_cr_write16 = native_afu_cr_write16,
+ 	.afu_cr_write32 = native_afu_cr_write32,
+ 	.read_adapter_vpd = cxl_pci_read_adapter_vpd,
+ };
++>>>>>>> 2bc79ffcbb81 (cxl: Poll for outstanding IRQs when detaching a context)
diff --git a/drivers/misc/cxl/context.c b/drivers/misc/cxl/context.c
index 7053331db9ff..6669630771e7 100644
--- a/drivers/misc/cxl/context.c
+++ b/drivers/misc/cxl/context.c
@@ -219,6 +219,13 @@ int __detach_context(struct cxl_context *ctx)
 		cxl_adapter_link_ok(ctx->afu->adapter));
 	flush_work(&ctx->fault_work); /* Only needed for dedicated process */
 
+	/*
+	 * Wait until no further interrupts are presented by the PSL
+	 * for this context.
+	 */
+	if (cxl_ops->irq_wait)
+		cxl_ops->irq_wait(ctx);
+
 	/* release the reference to the group leader and mm handling pid */
 	put_pid(ctx->pid);
 	put_pid(ctx->glpid);
* Unmerged path drivers/misc/cxl/cxl.h
* Unmerged path drivers/misc/cxl/native.c
