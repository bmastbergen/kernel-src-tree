cfg80211: handle failed skb allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Gregory Greenman <gregory.greenman@intel.com>
commit 16a910a6722b7a8680409e634c7c0dac073c01e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/16a910a6.failed

Handle the case when dev_alloc_skb returns NULL.

	Cc: stable@vger.kernel.org
Fixes: 2b67f944f88c2 ("cfg80211: reuse existing page fragments in A-MSDU rx")
	Signed-off-by: Gregory Greenman <gregory.greenman@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
	Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
(cherry picked from commit 16a910a6722b7a8680409e634c7c0dac073c01e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/wireless/util.c
diff --cc net/wireless/util.c
index 7e4e3fffe7ce,b7d1592bd5b8..000000000000
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@@ -644,6 -644,98 +644,101 @@@ int ieee80211_data_from_8023(struct sk_
  }
  EXPORT_SYMBOL(ieee80211_data_from_8023);
  
++<<<<<<< HEAD
++=======
+ static void
+ __frame_add_frag(struct sk_buff *skb, struct page *page,
+ 		 void *ptr, int len, int size)
+ {
+ 	struct skb_shared_info *sh = skb_shinfo(skb);
+ 	int page_offset;
+ 
+ 	page_ref_inc(page);
+ 	page_offset = ptr - page_address(page);
+ 	skb_add_rx_frag(skb, sh->nr_frags, page, page_offset, len, size);
+ }
+ 
+ static void
+ __ieee80211_amsdu_copy_frag(struct sk_buff *skb, struct sk_buff *frame,
+ 			    int offset, int len)
+ {
+ 	struct skb_shared_info *sh = skb_shinfo(skb);
+ 	const skb_frag_t *frag = &sh->frags[-1];
+ 	struct page *frag_page;
+ 	void *frag_ptr;
+ 	int frag_len, frag_size;
+ 	int head_size = skb->len - skb->data_len;
+ 	int cur_len;
+ 
+ 	frag_page = virt_to_head_page(skb->head);
+ 	frag_ptr = skb->data;
+ 	frag_size = head_size;
+ 
+ 	while (offset >= frag_size) {
+ 		offset -= frag_size;
+ 		frag++;
+ 		frag_page = skb_frag_page(frag);
+ 		frag_ptr = skb_frag_address(frag);
+ 		frag_size = skb_frag_size(frag);
+ 	}
+ 
+ 	frag_ptr += offset;
+ 	frag_len = frag_size - offset;
+ 
+ 	cur_len = min(len, frag_len);
+ 
+ 	__frame_add_frag(frame, frag_page, frag_ptr, cur_len, frag_size);
+ 	len -= cur_len;
+ 
+ 	while (len > 0) {
+ 		frag++;
+ 		frag_len = skb_frag_size(frag);
+ 		cur_len = min(len, frag_len);
+ 		__frame_add_frag(frame, skb_frag_page(frag),
+ 				 skb_frag_address(frag), cur_len, frag_len);
+ 		len -= cur_len;
+ 	}
+ }
+ 
+ static struct sk_buff *
+ __ieee80211_amsdu_copy(struct sk_buff *skb, unsigned int hlen,
+ 		       int offset, int len, bool reuse_frag)
+ {
+ 	struct sk_buff *frame;
+ 	int cur_len = len;
+ 
+ 	if (skb->len - offset < len)
+ 		return NULL;
+ 
+ 	/*
+ 	 * When reusing framents, copy some data to the head to simplify
+ 	 * ethernet header handling and speed up protocol header processing
+ 	 * in the stack later.
+ 	 */
+ 	if (reuse_frag)
+ 		cur_len = min_t(int, len, 32);
+ 
+ 	/*
+ 	 * Allocate and reserve two bytes more for payload
+ 	 * alignment since sizeof(struct ethhdr) is 14.
+ 	 */
+ 	frame = dev_alloc_skb(hlen + sizeof(struct ethhdr) + 2 + cur_len);
+ 	if (!frame)
+ 		return NULL;
+ 
+ 	skb_reserve(frame, hlen + sizeof(struct ethhdr) + 2);
+ 	skb_copy_bits(skb, offset, skb_put(frame, cur_len), cur_len);
+ 
+ 	len -= cur_len;
+ 	if (!len)
+ 		return frame;
+ 
+ 	offset += cur_len;
+ 	__ieee80211_amsdu_copy_frag(skb, frame, offset, len);
+ 
+ 	return frame;
+ }
++>>>>>>> 16a910a6722b (cfg80211: handle failed skb allocation)
  
  void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,
  			      const u8 *addr, enum nl80211_iftype iftype,
* Unmerged path net/wireless/util.c
