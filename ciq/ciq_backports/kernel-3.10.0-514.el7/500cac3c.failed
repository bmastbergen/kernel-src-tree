ovl: append MAY_READ when diluting write checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vivek Goyal <vgoyal@redhat.com>
commit 500cac3ccee65526d5075da3af2674101305bf8c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/500cac3c.failed

Right now we remove MAY_WRITE/MAY_APPEND bits from mask if realfile is on
lower/. This is done as files on lower will never be written and will be
copied up. But to copy up a file, mounter should have MAY_READ permission
otherwise copy up will fail. So set MAY_READ in mask when MAY_WRITE is
reset.

Dan Walsh noticed this when he did access(lowerfile, W_OK) and it returned
True (context mounts) but when he tried to actually write to file, it
failed as mounter did not have permission on lower file.

[SzM] don't set MAY_READ if only MAY_APPEND is set without MAY_WRITE; this
won't trigger a copy-up.

	Reported-by: Dan Walsh <dwalsh@redhat.com>
	Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 500cac3ccee65526d5075da3af2674101305bf8c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/inode.c
diff --cc fs/overlayfs/inode.c
index f3730d33febd,1b885c156028..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -73,89 -117,34 +73,100 @@@ static int ovl_getattr(struct vfsmount 
  
  int ovl_permission(struct inode *inode, int mask)
  {
 +	struct ovl_entry *oe;
 +	struct dentry *alias = NULL;
 +	struct inode *realinode;
 +	struct dentry *realdentry;
  	bool is_upper;
 -	struct inode *realinode = ovl_inode_real(inode, &is_upper);
 -	const struct cred *old_cred;
  	int err;
  
 -	/* Careful in RCU walk mode */
 -	if (!realinode) {
 -		WARN_ON(!(mask & MAY_NOT_BLOCK));
 +	if (S_ISDIR(inode->i_mode)) {
 +		oe = inode->i_private;
 +	} else if (mask & MAY_NOT_BLOCK) {
  		return -ECHILD;
 +	} else {
 +		/*
 +		 * For non-directories find an alias and get the info
 +		 * from there.
 +		 */
 +		alias = d_find_any_alias(inode);
 +		if (WARN_ON(!alias))
 +			return -ENOENT;
 +
 +		oe = alias->d_fsdata;
  	}
  
 -	/*
 -	 * Check overlay inode with the creds of task and underlying inode
 -	 * with creds of mounter
 -	 */
 -	err = generic_permission(inode, mask);
 -	if (err)
 -		return err;
 +	realdentry = ovl_entry_real(oe, &is_upper);
  
++<<<<<<< HEAD
 +	if (ovl_is_default_permissions(inode)) {
 +		struct kstat stat;
 +		struct path realpath = { .dentry = realdentry };
++=======
+ 	old_cred = ovl_override_creds(inode->i_sb);
+ 	if (!is_upper && !special_file(realinode->i_mode) && mask & MAY_WRITE) {
+ 		mask &= ~(MAY_WRITE | MAY_APPEND);
+ 		/* Make sure mounter can read file for copy up later */
+ 		mask |= MAY_READ;
+ 	}
+ 	err = inode_permission(realinode, mask);
+ 	revert_creds(old_cred);
++>>>>>>> 500cac3ccee6 (ovl: append MAY_READ when diluting write checks)
 +
 +		if (mask & MAY_NOT_BLOCK)
 +			return -ECHILD;
 +
 +		realpath.mnt = ovl_entry_mnt_real(oe, inode, is_upper);
 +
 +		err = vfs_getattr(&realpath, &stat);
 +		if (err)
 +			goto out_dput;
 +
 +		err = -ESTALE;
 +		if ((stat.mode ^ inode->i_mode) & S_IFMT)
 +			goto out_dput;
 +
 +		inode->i_mode = stat.mode;
 +		inode->i_uid = stat.uid;
 +		inode->i_gid = stat.gid;
 +
 +		err = generic_permission(inode, mask);
 +		goto out_dput;
 +	}
 +
 +	/* Careful in RCU walk mode */
 +	realinode = ACCESS_ONCE(realdentry->d_inode);
 +	if (!realinode) {
 +		WARN_ON(!(mask & MAY_NOT_BLOCK));
 +		err = -ENOENT;
 +		goto out_dput;
 +	}
 +
 +	if (mask & MAY_WRITE) {
 +		umode_t mode = realinode->i_mode;
 +
 +		/*
 +		 * Writes will always be redirected to upper layer, so
 +		 * ignore lower layer being read-only.
 +		 *
 +		 * If the overlay itself is read-only then proceed
 +		 * with the permission check, don't return EROFS.
 +		 * This will only happen if this is the lower layer of
 +		 * another overlayfs.
 +		 *
 +		 * If upper fs becomes read-only after the overlay was
 +		 * constructed return EROFS to prevent modification of
 +		 * upper layer.
 +		 */
 +		err = -EROFS;
 +		if (is_upper && !IS_RDONLY(inode) && IS_RDONLY(realinode) &&
 +		    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
 +			goto out_dput;
 +	}
  
 +	err = __inode_permission(realinode, mask);
 +out_dput:
 +	dput(alias);
  	return err;
  }
  
* Unmerged path fs/overlayfs/inode.c
