ACPI / property: Refine consistency check for PRP0001

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 5c53b262c861dc99aefb215eec579ae438d64fdd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5c53b262.failed

Refine the check for the presence of the "compatible" property
if the PRP0001 device ID is present in the device's list of
ACPI/PNP IDs to also print the message if _DSD is missing
entirely or the format of it is incorrect.

One special case to take into accout is that the "compatible"
property need not be provided for devices having the PRP0001
device ID in their lists of ACPI/PNP IDs if they are ancestors
of PRP0001 devices with the "compatible" property present.
This is to cover heriarchies of device objects where the kernel
is only supposed to use a struct device representation for the
topmost one and the others represent, for example, functional
blocks of a composite device.

While at it, reduce the log level of the message to "info"
and reduce the log level of the "broken _DSD" message to
"debug" (noise reduction).

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 5c53b262c861dc99aefb215eec579ae438d64fdd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/property.c
diff --cc drivers/acpi/property.c
index 2541b1fd1fa5,76075eea5f64..000000000000
--- a/drivers/acpi/property.c
+++ b/drivers/acpi/property.c
@@@ -76,13 -76,50 +76,59 @@@ static bool acpi_properties_format_vali
  	return true;
  }
  
++<<<<<<< HEAD
 +void acpi_init_properties(struct acpi_device *adev)
 +{
 +	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
++=======
+ static void acpi_init_of_compatible(struct acpi_device *adev)
+ {
+ 	const union acpi_object *of_compatible;
+ 	int ret;
+ 
+ 	ret = acpi_dev_get_property_array(adev, "compatible", ACPI_TYPE_STRING,
+ 					  &of_compatible);
+ 	if (ret) {
+ 		ret = acpi_dev_get_property(adev, "compatible",
+ 					    ACPI_TYPE_STRING, &of_compatible);
+ 		if (ret) {
+ 			if (adev->parent
+ 			    && adev->parent->flags.of_compatible_ok)
+ 				goto out;
+ 
+ 			return;
+ 		}
+ 	}
+ 	adev->data.of_compatible = of_compatible;
+ 
+  out:
+ 	adev->flags.of_compatible_ok = 1;
+ }
+ 
+ void acpi_init_properties(struct acpi_device *adev)
+ {
+ 	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
+ 	bool acpi_of = false;
+ 	struct acpi_hardware_id *hwid;
++>>>>>>> 5c53b262c861 (ACPI / property: Refine consistency check for PRP0001)
  	const union acpi_object *desc;
  	acpi_status status;
  	int i;
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Check if the special PRP0001 ACPI ID is present and in that case we
+ 	 * fill in Device Tree compatible properties for this device.
+ 	 */
+ 	list_for_each_entry(hwid, &adev->pnp.ids, list) {
+ 		if (!strcmp(hwid->id, "PRP0001")) {
+ 			acpi_of = true;
+ 			break;
+ 		}
+ 	}
+ 
++>>>>>>> 5c53b262c861 (ACPI / property: Refine consistency check for PRP0001)
  	status = acpi_evaluate_object_typed(adev->handle, "_DSD", NULL, &buf,
  					    ACPI_TYPE_PACKAGE);
  	if (ACPI_FAILURE(status))
@@@ -119,7 -156,11 +165,15 @@@
  
  		adev->data.pointer = buf.pointer;
  		adev->data.properties = properties;
++<<<<<<< HEAD
 +		return;
++=======
+ 
+ 		if (acpi_of)
+ 			acpi_init_of_compatible(adev);
+ 
+ 		goto out;
++>>>>>>> 5c53b262c861 (ACPI / property: Refine consistency check for PRP0001)
  	}
  
   fail:
* Unmerged path drivers/acpi/property.c
diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
index 8bcd3caab412..1db676c657e2 100644
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@ -209,7 +209,8 @@ struct acpi_device_flags {
 	u32 visited:1;
 	u32 hotplug_notify:1;
 	u32 is_dock_station:1;
-	u32 reserved:23;
+	u32 of_compatible_ok:1;
+	u32 reserved:22;
 };
 
 /* File System */
