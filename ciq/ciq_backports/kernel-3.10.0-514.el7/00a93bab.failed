openvswitch: add tunnel protocol to sw_flow_key

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 00a93babd06aaad31d23384cda576ede0f586a8c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/00a93bab.failed

Store tunnel protocol (AF_INET or AF_INET6) in sw_flow_key. This field now
also acts as an indicator whether the flow contains tunnel data (this was
previously indicated by tun_key.u.ipv4.dst being set but with IPv6 addresses
in an union with IPv4 ones this won't work anymore).

The new field was added to a hole in sw_flow_key.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Acked-by: Pravin B Shelar <pshelar@nicira.com>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 00a93babd06aaad31d23384cda576ede0f586a8c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/flow.c
#	net/openvswitch/flow_netlink.c
#	net/openvswitch/flow_table.c
diff --cc net/openvswitch/flow.c
index 8673468c1276,0ea128eeeab2..000000000000
--- a/net/openvswitch/flow.c
+++ b/net/openvswitch/flow.c
@@@ -685,9 -698,10 +685,13 @@@ int ovs_flow_key_extract(const struct i
  {
  	/* Extract metadata from packet. */
  	if (tun_info) {
++<<<<<<< HEAD
++=======
+ 		key->tun_proto = ip_tunnel_info_af(tun_info);
++>>>>>>> 00a93babd06a (openvswitch: add tunnel protocol to sw_flow_key)
  		memcpy(&key->tun_key, &tun_info->key, sizeof(key->tun_key));
  
 -		if (tun_info->options_len) {
 +		if (tun_info->options) {
  			BUILD_BUG_ON((1 << (sizeof(tun_info->options_len) *
  						   8)) - 1
  					> sizeof(key->tun_opts));
diff --cc net/openvswitch/flow_netlink.c
index 7f4707e70b38,6be701f6b31b..000000000000
--- a/net/openvswitch/flow_netlink.c
+++ b/net/openvswitch/flow_netlink.c
@@@ -1116,7 -1198,7 +1120,11 @@@ int ovs_nla_get_match(struct sw_flow_ma
  			/* The userspace does not send tunnel attributes that
  			 * are 0, but we should not wildcard them nonetheless.
  			 */
++<<<<<<< HEAD
 +			if (match->key->tun_key.ipv4_dst)
++=======
+ 			if (match->key->tun_proto)
++>>>>>>> 00a93babd06a (openvswitch: add tunnel protocol to sw_flow_key)
  				SW_FLOW_KEY_MEMSET_FIELD(match, tun_key,
  							 0xff, true);
  
@@@ -1287,7 -1371,7 +1295,11 @@@ static int __ovs_nla_put_key(const stru
  	if (nla_put_u32(skb, OVS_KEY_ATTR_PRIORITY, output->phy.priority))
  		goto nla_put_failure;
  
++<<<<<<< HEAD
 +	if ((swkey->tun_key.ipv4_dst || is_mask)) {
++=======
+ 	if ((swkey->tun_proto || is_mask)) {
++>>>>>>> 00a93babd06a (openvswitch: add tunnel protocol to sw_flow_key)
  		const void *opts = NULL;
  
  		if (output->tun_key.tun_flags & TUNNEL_OPTIONS_PRESENT)
@@@ -1827,21 -1917,17 +1839,23 @@@ static int validate_and_copy_set_tun(co
  
  	tun_info = &tun_dst->u.tun_info;
  	tun_info->mode = IP_TUNNEL_INFO_TX;
+ 	if (key.tun_proto == AF_INET6)
+ 		tun_info->mode |= IP_TUNNEL_INFO_IPV6;
  	tun_info->key = key.tun_key;
 +	tun_info->options_len = key.tun_opts_len;
 +
 +	if (tun_info->options_len) {
 +		/* We need to store the options in the action itself since
 +		 * everything else will go away after flow setup. We can append
 +		 * it to tun_info and then point there.
 +		 */
 +		memcpy((tun_info + 1),
 +		       TUN_METADATA_OPTS(&key, key.tun_opts_len), key.tun_opts_len);
 +		tun_info->options = (tun_info + 1);
 +	} else {
 +		tun_info->options = NULL;
 +	}
  
 -	/* We need to store the options in the action itself since
 -	 * everything else will go away after flow setup. We can append
 -	 * it to tun_info and then point there.
 -	 */
 -	ip_tunnel_info_opts_set(tun_info,
 -				TUN_METADATA_OPTS(&key, key.tun_opts_len),
 -				key.tun_opts_len);
  	add_nested_action_end(*sfa, start);
  
  	return err;
diff --cc net/openvswitch/flow_table.c
index 89c596500853,95dbcedf0bd4..000000000000
--- a/net/openvswitch/flow_table.c
+++ b/net/openvswitch/flow_table.c
@@@ -427,7 -427,7 +427,11 @@@ static u32 flow_hash(const struct sw_fl
  
  static int flow_key_start(const struct sw_flow_key *key)
  {
++<<<<<<< HEAD
 +	if (key->tun_key.ipv4_dst)
++=======
+ 	if (key->tun_proto)
++>>>>>>> 00a93babd06a (openvswitch: add tunnel protocol to sw_flow_key)
  		return 0;
  	else
  		return rounddown(offsetof(struct sw_flow_key, phy),
* Unmerged path net/openvswitch/flow.c
diff --git a/net/openvswitch/flow.h b/net/openvswitch/flow.h
index 082a87bac819..5535fc4a278b 100644
--- a/net/openvswitch/flow.h
+++ b/net/openvswitch/flow.h
@@ -63,6 +63,7 @@ struct sw_flow_key {
 		u32	skb_mark;	/* SKB mark. */
 		u16	in_port;	/* Input switch port (or DP_MAX_PORTS). */
 	} __packed phy; /* Safe when right after 'tun_key'. */
+	u8 tun_proto;			/* Protocol of encapsulating tunnel. */
 	u32 ovs_flow_hash;		/* Datapath computed hash value.  */
 	u32 recirc_id;			/* Recirculation ID.  */
 	struct {
* Unmerged path net/openvswitch/flow_netlink.c
* Unmerged path net/openvswitch/flow_table.c
