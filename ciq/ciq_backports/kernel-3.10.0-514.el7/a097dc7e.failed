GFS2: Make rgrp reservations part of the gfs2_inode structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit a097dc7e24cba7980bc5e2df461a4ef228e97e59
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a097dc7e.failed

Before this patch, multi-block reservation structures were allocated
from a special slab. This patch folds the structure into the gfs2_inode
structure. The disadvantage is that the gfs2_inode needs more memory,
even when a file is opened read-only. The advantages are: (a) we don't
need the special slab and the extra time it takes to allocate and
deallocate from it. (b) we no longer need to worry that the structure
exists for things like quota management. (c) This also allows us to
remove the calls to get_write_access and put_write_access since we
know the structure will exist.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit a097dc7e24cba7980bc5e2df461a4ef228e97e59)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/file.c
#	fs/gfs2/incore.h
#	fs/gfs2/inode.c
#	fs/gfs2/main.c
#	fs/gfs2/quota.c
#	fs/gfs2/quota.h
#	fs/gfs2/rgrp.c
#	fs/gfs2/super.c
#	fs/gfs2/util.c
#	fs/gfs2/util.h
diff --cc fs/gfs2/file.c
index 96a7ba9500e8,3ead27d64bf0..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -405,13 -397,9 +405,17 @@@ static int gfs2_page_mkwrite(struct vm_
  	/* Update file times before taking page lock */
  	file_update_time(vma->vm_file);
  
++<<<<<<< HEAD
 +	ret = get_write_access(inode);
 +	if (ret)
 +		goto out;
 +
 +	ret = gfs2_rs_alloc(ip);
++=======
+ 	ret = gfs2_rsqa_alloc(ip);
++>>>>>>> a097dc7e24cb (GFS2: Make rgrp reservations part of the gfs2_inode structure)
  	if (ret)
- 		goto out_write_access;
+ 		goto out;
  
  	gfs2_size_hint(vma->vm_file, pos, PAGE_CACHE_SIZE);
  
diff --cc fs/gfs2/incore.h
index 2caf75dc0244,25d0f12aaec5..000000000000
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@@ -373,7 -393,8 +373,12 @@@ struct gfs2_inode 
  	struct gfs2_glock *i_gl; /* Move into i_gh? */
  	struct gfs2_holder i_iopen_gh;
  	struct gfs2_holder i_gh; /* for prepare/commit_write only */
++<<<<<<< HEAD
 +	struct gfs2_blkreserv *i_res; /* rgrp multi-block reservation */
++=======
+ 	struct gfs2_qadata *i_qadata; /* quota allocation data */
+ 	struct gfs2_blkreserv i_res; /* rgrp multi-block reservation */
++>>>>>>> a097dc7e24cb (GFS2: Make rgrp reservations part of the gfs2_inode structure)
  	struct gfs2_rgrpd *i_rgd;
  	u64 i_goal;	/* goal block for allocations */
  	struct rw_semaphore i_rw_mutex;
diff --cc fs/gfs2/inode.c
index 4b5ce5a448da,a8ce2e99cf5d..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -1804,11 -1859,7 +1804,15 @@@ static int setattr_chown(struct inode *
  	if (!(attr->ia_valid & ATTR_GID) || gid_eq(ogid, ngid))
  		ogid = ngid = NO_GID_QUOTA_CHANGE;
  
++<<<<<<< HEAD
 +	error = get_write_access(inode);
 +	if (error)
 +		return error;
 +
 +	error = gfs2_rs_alloc(ip);
++=======
+ 	error = gfs2_rsqa_alloc(ip);
++>>>>>>> a097dc7e24cb (GFS2: Make rgrp reservations part of the gfs2_inode structure)
  	if (error)
  		goto out;
  
diff --cc fs/gfs2/main.c
index 8bc711b547e8,1d709d496364..000000000000
--- a/fs/gfs2/main.c
+++ b/fs/gfs2/main.c
@@@ -38,7 -41,9 +38,13 @@@ static void gfs2_init_inode_once(void *
  	inode_init_once(&ip->i_inode);
  	init_rwsem(&ip->i_rw_mutex);
  	INIT_LIST_HEAD(&ip->i_trunc_list);
++<<<<<<< HEAD
 +	ip->i_res = NULL;
++=======
+ 	ip->i_qadata = NULL;
+ 	memset(&ip->i_res, 0, sizeof(ip->i_res));
+ 	RB_CLEAR_NODE(&ip->i_res.rs_node);
++>>>>>>> a097dc7e24cb (GFS2: Make rgrp reservations part of the gfs2_inode structure)
  	ip->i_hash_cache = NULL;
  }
  
@@@ -132,10 -137,10 +138,17 @@@ static int __init init_gfs2_fs(void
  	if (!gfs2_quotad_cachep)
  		goto fail;
  
++<<<<<<< HEAD
 +	gfs2_rsrv_cachep = kmem_cache_create("gfs2_mblk",
 +					     sizeof(struct gfs2_blkreserv),
 +					       0, 0, NULL);
 +	if (!gfs2_rsrv_cachep)
++=======
+ 	gfs2_qadata_cachep = kmem_cache_create("gfs2_qadata",
+ 					       sizeof(struct gfs2_qadata),
+ 					       0, 0, NULL);
+ 	if (!gfs2_qadata_cachep)
++>>>>>>> a097dc7e24cb (GFS2: Make rgrp reservations part of the gfs2_inode structure)
  		goto fail;
  
  	register_shrinker(&gfs2_qd_shrinker);
@@@ -183,8 -195,8 +196,13 @@@ fail_lru
  	unregister_shrinker(&gfs2_qd_shrinker);
  	gfs2_glock_exit();
  
++<<<<<<< HEAD
 +	if (gfs2_rsrv_cachep)
 +		kmem_cache_destroy(gfs2_rsrv_cachep);
++=======
+ 	if (gfs2_qadata_cachep)
+ 		kmem_cache_destroy(gfs2_qadata_cachep);
++>>>>>>> a097dc7e24cb (GFS2: Make rgrp reservations part of the gfs2_inode structure)
  
  	if (gfs2_quotad_cachep)
  		kmem_cache_destroy(gfs2_quotad_cachep);
@@@ -227,7 -240,7 +245,11 @@@ static void __exit exit_gfs2_fs(void
  	rcu_barrier();
  
  	mempool_destroy(gfs2_page_pool);
++<<<<<<< HEAD
 +	kmem_cache_destroy(gfs2_rsrv_cachep);
++=======
+ 	kmem_cache_destroy(gfs2_qadata_cachep);
++>>>>>>> a097dc7e24cb (GFS2: Make rgrp reservations part of the gfs2_inode structure)
  	kmem_cache_destroy(gfs2_quotad_cachep);
  	kmem_cache_destroy(gfs2_rgrpd_cachep);
  	kmem_cache_destroy(gfs2_bufdata_cachep);
diff --cc fs/gfs2/quota.c
index 481208bbcaf7,63a72109976c..000000000000
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@@ -515,6 -527,39 +515,42 @@@ static void qdsb_put(struct gfs2_quota_
  	qd_put(qd);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * gfs2_qa_alloc - make sure we have a quota allocations data structure,
+  *                 if necessary
+  * @ip: the inode for this reservation
+  */
+ int gfs2_qa_alloc(struct gfs2_inode *ip)
+ {
+ 	int error = 0;
+ 	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
+ 
+ 	if (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)
+ 		return 0;
+ 
+ 	down_write(&ip->i_rw_mutex);
+ 	if (ip->i_qadata == NULL) {
+ 		ip->i_qadata = kmem_cache_zalloc(gfs2_qadata_cachep, GFP_NOFS);
+ 		if (!ip->i_qadata)
+ 			error = -ENOMEM;
+ 	}
+ 	up_write(&ip->i_rw_mutex);
+ 	return error;
+ }
+ 
+ void gfs2_qa_delete(struct gfs2_inode *ip, atomic_t *wcount)
+ {
+ 	down_write(&ip->i_rw_mutex);
+ 	if (ip->i_qadata && ((wcount == NULL) || (atomic_read(wcount) <= 1))) {
+ 		kmem_cache_free(gfs2_qadata_cachep, ip->i_qadata);
+ 		ip->i_qadata = NULL;
+ 	}
+ 	up_write(&ip->i_rw_mutex);
+ }
+ 
++>>>>>>> a097dc7e24cb (GFS2: Make rgrp reservations part of the gfs2_inode structure)
  int gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)
  {
  	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
diff --cc fs/gfs2/quota.h
index ad04b3acae2b,5e47c935a515..000000000000
--- a/fs/gfs2/quota.h
+++ b/fs/gfs2/quota.h
@@@ -18,6 -18,8 +18,11 @@@ struct gfs2_sbd
  #define NO_UID_QUOTA_CHANGE INVALID_UID
  #define NO_GID_QUOTA_CHANGE INVALID_GID
  
++<<<<<<< HEAD
++=======
+ extern int gfs2_qa_alloc(struct gfs2_inode *ip);
+ extern void gfs2_qa_delete(struct gfs2_inode *ip, atomic_t *wcount);
++>>>>>>> a097dc7e24cb (GFS2: Make rgrp reservations part of the gfs2_inode structure)
  extern int gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid);
  extern void gfs2_quota_unhold(struct gfs2_inode *ip);
  
diff --cc fs/gfs2/rgrp.c
index 28da34fba03d,b879925ce134..000000000000
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@@ -569,27 -596,13 +569,31 @@@ void gfs2_free_clones(struct gfs2_rgrp
  }
  
  /**
 - * gfs2_rsqa_alloc - make sure we have a reservation assigned to the inode
 - *                 plus a quota allocations data structure, if necessary
 + * gfs2_rs_alloc - make sure we have a reservation assigned to the inode
   * @ip: the inode for this reservation
   */
 -int gfs2_rsqa_alloc(struct gfs2_inode *ip)
 +int gfs2_rs_alloc(struct gfs2_inode *ip)
  {
++<<<<<<< HEAD
 +	int error = 0;
 +
 +	down_write(&ip->i_rw_mutex);
 +	if (ip->i_res)
 +		goto out;
 +
 +	ip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);
 +	if (!ip->i_res) {
 +		error = -ENOMEM;
 +		goto out;
 +	}
 +
 +	RB_CLEAR_NODE(&ip->i_res->rs_node);
 +out:
 +	up_write(&ip->i_rw_mutex);
 +	return error;
++=======
+ 	return gfs2_qa_alloc(ip);
++>>>>>>> a097dc7e24cb (GFS2: Make rgrp reservations part of the gfs2_inode structure)
  }
  
  static void dump_rs(struct seq_file *seq, const struct gfs2_blkreserv *rs)
@@@ -650,22 -664,20 +654,29 @@@ void gfs2_rs_deltree(struct gfs2_blkres
  }
  
  /**
 - * gfs2_rsqa_delete - delete a multi-block reservation and quota allocation
 + * gfs2_rs_delete - delete a multi-block reservation
   * @ip: The inode for this reservation
 - * @wcount: The inode's write count, or NULL
   *
   */
 -void gfs2_rsqa_delete(struct gfs2_inode *ip, atomic_t *wcount)
 +void gfs2_rs_delete(struct gfs2_inode *ip)
  {
 +	struct inode *inode = &ip->i_inode;
 +
  	down_write(&ip->i_rw_mutex);
++<<<<<<< HEAD
 +	if (ip->i_res && atomic_read(&inode->i_writecount) <= 1) {
 +		gfs2_rs_deltree(ip->i_res);
 +		BUG_ON(ip->i_res->rs_free);
 +		kmem_cache_free(gfs2_rsrv_cachep, ip->i_res);
 +		ip->i_res = NULL;
++=======
+ 	if ((wcount == NULL) || (atomic_read(wcount) <= 1)) {
+ 		gfs2_rs_deltree(&ip->i_res);
+ 		BUG_ON(ip->i_res.rs_free);
++>>>>>>> a097dc7e24cb (GFS2: Make rgrp reservations part of the gfs2_inode structure)
  	}
  	up_write(&ip->i_rw_mutex);
+ 	gfs2_qa_delete(ip, wcount);
  }
  
  /**
@@@ -2257,6 -2280,35 +2268,38 @@@ out
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * gfs2_set_alloc_start - Set starting point for block allocation
+  * @rbm: The rbm which will be set to the required location
+  * @ip: The gfs2 inode
+  * @dinode: Flag to say if allocation includes a new inode
+  *
+  * This sets the starting point from the reservation if one is active
+  * otherwise it falls back to guessing a start point based on the
+  * inode's goal block or the last allocation point in the rgrp.
+  */
+ 
+ static void gfs2_set_alloc_start(struct gfs2_rbm *rbm,
+ 				 const struct gfs2_inode *ip, bool dinode)
+ {
+ 	u64 goal;
+ 
+ 	if (gfs2_rs_active(&ip->i_res)) {
+ 		*rbm = ip->i_res.rs_rbm;
+ 		return;
+ 	}
+ 
+ 	if (!dinode && rgrp_contains_block(rbm->rgd, ip->i_goal))
+ 		goal = ip->i_goal;
+ 	else
+ 		goal = rbm->rgd->rd_last_alloc + rbm->rgd->rd_data0;
+ 
+ 	gfs2_rbm_from_block(rbm, goal);
+ }
+ 
+ /**
++>>>>>>> a097dc7e24cb (GFS2: Make rgrp reservations part of the gfs2_inode structure)
   * gfs2_alloc_blocks - Allocate one or more blocks of data and/or a dinode
   * @ip: the inode to allocate the block for
   * @bn: Used to return the starting block number
diff --cc fs/gfs2/super.c
index 7c8f12885717,64f03c821b5d..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1589,7 -1632,9 +1589,13 @@@ static struct inode *gfs2_alloc_inode(s
  		ip->i_flags = 0;
  		ip->i_gl = NULL;
  		ip->i_rgd = NULL;
++<<<<<<< HEAD
 +		ip->i_res = NULL;
++=======
+ 		memset(&ip->i_res, 0, sizeof(ip->i_res));
+ 		RB_CLEAR_NODE(&ip->i_res.rs_node);
+ 		ip->i_rahead = 0;
++>>>>>>> a097dc7e24cb (GFS2: Make rgrp reservations part of the gfs2_inode structure)
  	}
  	return &ip->i_inode;
  }
diff --cc fs/gfs2/util.c
index cdacc01e25b8,cf645835710f..000000000000
--- a/fs/gfs2/util.c
+++ b/fs/gfs2/util.c
@@@ -25,7 -27,7 +25,11 @@@ struct kmem_cache *gfs2_inode_cachep __
  struct kmem_cache *gfs2_bufdata_cachep __read_mostly;
  struct kmem_cache *gfs2_rgrpd_cachep __read_mostly;
  struct kmem_cache *gfs2_quotad_cachep __read_mostly;
++<<<<<<< HEAD
 +struct kmem_cache *gfs2_rsrv_cachep __read_mostly;
++=======
+ struct kmem_cache *gfs2_qadata_cachep __read_mostly;
++>>>>>>> a097dc7e24cb (GFS2: Make rgrp reservations part of the gfs2_inode structure)
  mempool_t *gfs2_page_pool __read_mostly;
  
  void gfs2_assert_i(struct gfs2_sbd *sdp)
diff --cc fs/gfs2/util.h
index b7ffb09b99ea,c81295f407f6..000000000000
--- a/fs/gfs2/util.h
+++ b/fs/gfs2/util.h
@@@ -148,7 -149,7 +148,11 @@@ extern struct kmem_cache *gfs2_inode_ca
  extern struct kmem_cache *gfs2_bufdata_cachep;
  extern struct kmem_cache *gfs2_rgrpd_cachep;
  extern struct kmem_cache *gfs2_quotad_cachep;
++<<<<<<< HEAD
 +extern struct kmem_cache *gfs2_rsrv_cachep;
++=======
+ extern struct kmem_cache *gfs2_qadata_cachep;
++>>>>>>> a097dc7e24cb (GFS2: Make rgrp reservations part of the gfs2_inode structure)
  extern mempool_t *gfs2_page_pool;
  
  static inline unsigned int gfs2_tune_get_i(struct gfs2_tune *gt,
diff --git a/fs/gfs2/bmap.c b/fs/gfs2/bmap.c
index c9e860161c6f..89798d34bb98 100644
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@ -787,8 +787,8 @@ static int do_strip(struct gfs2_inode *ip, struct buffer_head *dibh,
 	if (error)
 		goto out_rlist;
 
-	if (gfs2_rs_active(ip->i_res)) /* needs to be done with the rgrp glock held */
-		gfs2_rs_deltree(ip->i_res);
+	if (gfs2_rs_active(&ip->i_res)) /* needs to be done with the rgrp glock held */
+		gfs2_rs_deltree(&ip->i_res);
 
 	error = gfs2_trans_begin(sdp, rg_blocks + RES_DINODE +
 				 RES_INDIRECT + RES_STATFS + RES_QUOTA,
@@ -1290,10 +1290,6 @@ int gfs2_setattr_size(struct inode *inode, u64 newsize)
 	if (ret)
 		return ret;
 
-	ret = get_write_access(inode);
-	if (ret)
-		return ret;
-
 	inode_dio_wait(inode);
 
 	ret = gfs2_rs_alloc(GFS2_I(inode));
@@ -1308,7 +1304,7 @@ int gfs2_setattr_size(struct inode *inode, u64 newsize)
 
 	ret = do_shrink(inode, oldsize, newsize);
 out:
-	put_write_access(inode);
+	gfs2_rsqa_delete(ip, NULL);
 	return ret;
 }
 
* Unmerged path fs/gfs2/file.c
* Unmerged path fs/gfs2/incore.h
* Unmerged path fs/gfs2/inode.c
* Unmerged path fs/gfs2/main.c
* Unmerged path fs/gfs2/quota.c
* Unmerged path fs/gfs2/quota.h
* Unmerged path fs/gfs2/rgrp.c
diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index c4023545919a..8cc206a312d3 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -78,7 +78,7 @@ extern int gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,
 extern int gfs2_fitrim(struct file *filp, void __user *argp);
 
 /* This is how to tell if a reservation is in the rgrp tree: */
-static inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)
+static inline bool gfs2_rs_active(const struct gfs2_blkreserv *rs)
 {
 	return rs && !RB_EMPTY_NODE(&rs->rs_node);
 }
* Unmerged path fs/gfs2/super.c
* Unmerged path fs/gfs2/util.c
* Unmerged path fs/gfs2/util.h
