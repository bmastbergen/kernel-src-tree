hv_netvsc: Implement support for VF drivers on Hyper-V

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author KY Srinivasan <kys@microsoft.com>
commit 84bf9cefb162b197da20a0f4388929f4b5ba5db4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/84bf9cef.failed

Support VF drivers on Hyper-V. On Hyper-V, each VF instance presented to
the guest has an associated synthetic interface that shares the MAC address
with the VF instance. Typically these are bonded together to support
live migration. By default, the host delivers all the incoming packets
on the synthetic interface. Once the VF is up, we need to explicitly switch
the data path on the host to divert traffic onto the VF interface. Even after
switching the data path, broadcast and multicast packets are always delivered
on the synthetic interface and these will have to be injected back onto the
VF interface (if VF is up).
This patch implements the necessary support in netvsc to support Linux
VF drivers.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 84bf9cefb162b197da20a0f4388929f4b5ba5db4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/hyperv_net.h
index cf498664d989,6700a4dca7c8..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -201,6 -202,7 +201,10 @@@ int rndis_filter_receive(struct hv_devi
  int rndis_filter_set_packet_filter(struct rndis_device *dev, u32 new_filter);
  int rndis_filter_set_device_mac(struct hv_device *hdev, char *mac);
  
++<<<<<<< HEAD
++=======
+ void netvsc_switch_datapath(struct netvsc_device *nv_dev, bool vf);
++>>>>>>> 84bf9cefb162 (hv_netvsc: Implement support for VF drivers on Hyper-V)
  
  #define NVSP_INVALID_PROTOCOL_VERSION	((u32)0xFFFFFFFF)
  
@@@ -595,8 -621,60 +599,63 @@@ struct nvsp_message 
  #define NETVSC_PACKET_SIZE                      4096
  
  #define VRSS_SEND_TAB_SIZE 16
 -#define VRSS_CHANNEL_MAX 64
  
++<<<<<<< HEAD
 +/* Per netvsc channel-specific */
++=======
+ #define RNDIS_MAX_PKT_DEFAULT 8
+ #define RNDIS_PKT_ALIGN_DEFAULT 8
+ 
+ struct multi_send_data {
+ 	struct sk_buff *skb; /* skb containing the pkt */
+ 	struct hv_netvsc_packet *pkt; /* netvsc pkt pending */
+ 	u32 count; /* counter of batched packets */
+ };
+ 
+ struct netvsc_stats {
+ 	u64 packets;
+ 	u64 bytes;
+ 	struct u64_stats_sync syncp;
+ };
+ 
+ struct netvsc_reconfig {
+ 	struct list_head list;
+ 	u32 event;
+ };
+ 
+ struct garp_wrk {
+ 	struct work_struct dwrk;
+ 	struct net_device *netdev;
+ 	struct netvsc_device *netvsc_dev;
+ };
+ 
+ /* The context of the netvsc device  */
+ struct net_device_context {
+ 	/* point back to our device context */
+ 	struct hv_device *device_ctx;
+ 	/* reconfigure work */
+ 	struct delayed_work dwork;
+ 	/* last reconfig time */
+ 	unsigned long last_reconfig;
+ 	/* reconfig events */
+ 	struct list_head reconfig_events;
+ 	/* list protection */
+ 	spinlock_t lock;
+ 
+ 	struct work_struct work;
+ 	u32 msg_enable; /* debug level */
+ 	struct garp_wrk gwrk;
+ 
+ 	struct netvsc_stats __percpu *tx_stats;
+ 	struct netvsc_stats __percpu *rx_stats;
+ 
+ 	/* Ethtool settings */
+ 	u8 duplex;
+ 	u32 speed;
+ };
+ 
+ /* Per netvsc device */
++>>>>>>> 84bf9cefb162 (hv_netvsc: Implement support for VF drivers on Hyper-V)
  struct netvsc_device {
  	struct hv_device *dev;
  
@@@ -647,6 -727,23 +706,26 @@@
  	unsigned char *cb_buffer;
  	/* The sub channel callback buffer */
  	unsigned char *sub_cb_buf;
++<<<<<<< HEAD
++=======
+ 
+ 	struct multi_send_data msd[VRSS_CHANNEL_MAX];
+ 	u32 max_pkt; /* max number of pkt in one send, e.g. 8 */
+ 	u32 pkt_align; /* alignment bytes, e.g. 8 */
+ 
+ 	/* The net device context */
+ 	struct net_device_context *nd_ctx;
+ 
+ 	/* 1: allocated, serial number is valid. 0: not allocated */
+ 	u32 vf_alloc;
+ 	/* Serial number of the VF to team with */
+ 	u32 vf_serial;
+ 	atomic_t open_cnt;
+ 	/* State to manage the associated VF interface. */
+ 	bool vf_inject;
+ 	struct net_device *vf_netdev;
+ 	atomic_t vf_use_cnt;
++>>>>>>> 84bf9cefb162 (hv_netvsc: Implement support for VF drivers on Hyper-V)
  };
  
  /* NdisInitialize message */
diff --cc drivers/net/hyperv/netvsc_drv.c
index 822e657fcee7,bfdb568ac6b8..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -636,45 -597,37 +636,58 @@@ void netvsc_linkstatus_callback(struct 
  		return;
  
  	ndev_ctx = netdev_priv(net);
 -
 -	event = kzalloc(sizeof(*event), GFP_ATOMIC);
 -	if (!event)
 -		return;
 -	event->event = indicate->status;
 -
 -	spin_lock_irqsave(&ndev_ctx->lock, flags);
 -	list_add_tail(&event->list, &ndev_ctx->reconfig_events);
 -	spin_unlock_irqrestore(&ndev_ctx->lock, flags);
 -
 -	schedule_delayed_work(&ndev_ctx->dwork, 0);
 +	if (status == 1) {
 +		schedule_delayed_work(&ndev_ctx->dwork, 0);
 +		schedule_delayed_work(&ndev_ctx->dwork, msecs_to_jiffies(20));
 +	} else {
 +		schedule_delayed_work(&ndev_ctx->dwork, 0);
 +	}
  }
  
- /*
-  * netvsc_recv_callback -  Callback when we receive a packet from the
-  * "wire" on the specified device.
-  */
- int netvsc_recv_callback(struct hv_device *device_obj,
+ 
+ static struct sk_buff *netvsc_alloc_recv_skb(struct net_device *net,
  				struct hv_netvsc_packet *packet,
++<<<<<<< HEAD
 +				struct ndis_tcp_ip_checksum_info *csum_info)
 +{
 +	struct net_device *net;
 +	struct sk_buff *skb;
 +
 +	net = ((struct netvsc_device *)hv_get_drvdata(device_obj))->ndev;
 +	if (!net || net->reg_state != NETREG_REGISTERED) {
 +		packet->status = NVSP_STAT_FAIL;
 +		return 0;
 +	}
 +
 +	/* Allocate a skb - TODO direct I/O to pages? */
 +	skb = netdev_alloc_skb_ip_align(net, packet->total_data_buflen);
 +	if (unlikely(!skb)) {
 +		++net->stats.rx_dropped;
 +		packet->status = NVSP_STAT_FAIL;
 +		return 0;
 +	}
++=======
+ 				struct ndis_tcp_ip_checksum_info *csum_info,
+ 				void *data, u16 vlan_tci)
+ {
+ 	struct sk_buff *skb;
+ 
+ 	skb = netdev_alloc_skb_ip_align(net, packet->total_data_buflen);
+ 	if (!skb)
+ 		return skb;
++>>>>>>> 84bf9cefb162 (hv_netvsc: Implement support for VF drivers on Hyper-V)
  
  	/*
  	 * Copy to skb. This copy is needed here since the memory pointed by
  	 * hv_netvsc_packet cannot be deallocated
  	 */
++<<<<<<< HEAD
 +	memcpy(skb_put(skb, packet->total_data_buflen), packet->data,
 +		packet->total_data_buflen);
++=======
+ 	memcpy(skb_put(skb, packet->total_data_buflen), data,
+ 	       packet->total_data_buflen);
++>>>>>>> 84bf9cefb162 (hv_netvsc: Implement support for VF drivers on Hyper-V)
  
  	skb->protocol = eth_type_trans(skb, net);
  	if (csum_info) {
@@@ -688,15 -641,86 +701,88 @@@
  			skb->ip_summed = CHECKSUM_NONE;
  	}
  
 -	if (vlan_tci & VLAN_TAG_PRESENT)
 +	if (packet->vlan_tci & VLAN_TAG_PRESENT)
  		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
 -				       vlan_tci);
 +				       packet->vlan_tci);
  
++<<<<<<< HEAD
 +	skb_record_rx_queue(skb, packet->channel->
++=======
+ 	return skb;
+ }
+ 
+ /*
+  * netvsc_recv_callback -  Callback when we receive a packet from the
+  * "wire" on the specified device.
+  */
+ int netvsc_recv_callback(struct hv_device *device_obj,
+ 				struct hv_netvsc_packet *packet,
+ 				void **data,
+ 				struct ndis_tcp_ip_checksum_info *csum_info,
+ 				struct vmbus_channel *channel,
+ 				u16 vlan_tci)
+ {
+ 	struct net_device *net;
+ 	struct net_device_context *net_device_ctx;
+ 	struct sk_buff *skb;
+ 	struct sk_buff *vf_skb;
+ 	struct netvsc_stats *rx_stats;
+ 	struct netvsc_device *netvsc_dev = hv_get_drvdata(device_obj);
+ 	u32 bytes_recvd = packet->total_data_buflen;
+ 	int ret = 0;
+ 
+ 	net = netvsc_dev->ndev;
+ 	if (!net || net->reg_state != NETREG_REGISTERED)
+ 		return NVSP_STAT_FAIL;
+ 
+ 	if (READ_ONCE(netvsc_dev->vf_inject)) {
+ 		atomic_inc(&netvsc_dev->vf_use_cnt);
+ 		if (!READ_ONCE(netvsc_dev->vf_inject)) {
+ 			/*
+ 			 * We raced; just move on.
+ 			 */
+ 			atomic_dec(&netvsc_dev->vf_use_cnt);
+ 			goto vf_injection_done;
+ 		}
+ 
+ 		/*
+ 		 * Inject this packet into the VF inerface.
+ 		 * On Hyper-V, multicast and brodcast packets
+ 		 * are only delivered on the synthetic interface
+ 		 * (after subjecting these to policy filters on
+ 		 * the host). Deliver these via the VF interface
+ 		 * in the guest.
+ 		 */
+ 		vf_skb = netvsc_alloc_recv_skb(netvsc_dev->vf_netdev, packet,
+ 					       csum_info, *data, vlan_tci);
+ 		if (vf_skb != NULL) {
+ 			++netvsc_dev->vf_netdev->stats.rx_packets;
+ 			netvsc_dev->vf_netdev->stats.rx_bytes += bytes_recvd;
+ 			netif_receive_skb(vf_skb);
+ 		} else {
+ 			++net->stats.rx_dropped;
+ 			ret = NVSP_STAT_FAIL;
+ 		}
+ 		atomic_dec(&netvsc_dev->vf_use_cnt);
+ 		return ret;
+ 	}
+ 
+ vf_injection_done:
+ 	net_device_ctx = netdev_priv(net);
+ 	rx_stats = this_cpu_ptr(net_device_ctx->rx_stats);
+ 
+ 	/* Allocate a skb - TODO direct I/O to pages? */
+ 	skb = netvsc_alloc_recv_skb(net, packet, csum_info, *data, vlan_tci);
+ 	if (unlikely(!skb)) {
+ 		++net->stats.rx_dropped;
+ 		return NVSP_STAT_FAIL;
+ 	}
+ 	skb_record_rx_queue(skb, channel->
++>>>>>>> 84bf9cefb162 (hv_netvsc: Implement support for VF drivers on Hyper-V)
  			    offermsg.offer.sub_channel_index);
  
 -	u64_stats_update_begin(&rx_stats->syncp);
 -	rx_stats->packets++;
 -	rx_stats->bytes += packet->total_data_buflen;
 -	u64_stats_update_end(&rx_stats->syncp);
 +	net->stats.rx_packets++;
 +	net->stats.rx_bytes += packet->total_data_buflen;
  
  	/*
  	 * Pass the skb back up. Network stack will deallocate the skb when it
@@@ -857,9 -1136,192 +943,178 @@@ static void netvsc_link_change(struct w
  
  	if (notify)
  		netdev_notify_peers(net);
 -
 -	/* link_watch only sends one notification with current state per
 -	 * second, handle next reconfig event in 2 seconds.
 -	 */
 -	if (reschedule)
 -		schedule_delayed_work(&ndev_ctx->dwork, LINKCHANGE_INT);
  }
  
 -static void netvsc_free_netdev(struct net_device *netdev)
 -{
 -	struct net_device_context *net_device_ctx = netdev_priv(netdev);
 -
 -	free_percpu(net_device_ctx->tx_stats);
 -	free_percpu(net_device_ctx->rx_stats);
 -	free_netdev(netdev);
 -}
  
+ static void netvsc_notify_peers(struct work_struct *wrk)
+ {
+ 	struct garp_wrk *gwrk;
+ 
+ 	gwrk = container_of(wrk, struct garp_wrk, dwrk);
+ 
+ 	netdev_notify_peers(gwrk->netdev);
+ 
+ 	atomic_dec(&gwrk->netvsc_dev->vf_use_cnt);
+ }
+ 
+ static struct netvsc_device *get_netvsc_device(char *mac)
+ {
+ 	struct net_device *dev;
+ 	struct net_device_context *netvsc_ctx = NULL;
+ 	int rtnl_locked;
+ 
+ 	rtnl_locked = rtnl_trylock();
+ 
+ 	for_each_netdev(&init_net, dev) {
+ 		if (memcmp(dev->dev_addr, mac, ETH_ALEN) == 0) {
+ 			if (dev->netdev_ops != &device_ops)
+ 				continue;
+ 			netvsc_ctx = netdev_priv(dev);
+ 			break;
+ 		}
+ 	}
+ 	if (rtnl_locked)
+ 		rtnl_unlock();
+ 
+ 	if (netvsc_ctx == NULL)
+ 		return NULL;
+ 
+ 	return hv_get_drvdata(netvsc_ctx->device_ctx);
+ }
+ 
+ static int netvsc_register_vf(struct net_device *vf_netdev)
+ {
+ 	struct netvsc_device *netvsc_dev;
+ 	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
+ 
+ 	if (eth_ops == NULL || eth_ops == &ethtool_ops)
+ 		return NOTIFY_DONE;
+ 
+ 	/*
+ 	 * We will use the MAC address to locate the synthetic interface to
+ 	 * associate with the VF interface. If we don't find a matching
+ 	 * synthetic interface, move on.
+ 	 */
+ 	netvsc_dev = get_netvsc_device(vf_netdev->dev_addr);
+ 	if (netvsc_dev == NULL)
+ 		return NOTIFY_DONE;
+ 
+ 	netdev_info(netvsc_dev->ndev, "VF registering: %s\n", vf_netdev->name);
+ 	/*
+ 	 * Take a reference on the module.
+ 	 */
+ 	try_module_get(THIS_MODULE);
+ 	netvsc_dev->vf_netdev = vf_netdev;
+ 	return NOTIFY_OK;
+ }
+ 
+ 
+ static int netvsc_vf_up(struct net_device *vf_netdev)
+ {
+ 	struct netvsc_device *netvsc_dev;
+ 	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
+ 	struct net_device_context *net_device_ctx;
+ 
+ 	if (eth_ops == &ethtool_ops)
+ 		return NOTIFY_DONE;
+ 
+ 	netvsc_dev = get_netvsc_device(vf_netdev->dev_addr);
+ 
+ 	if ((netvsc_dev == NULL) || (netvsc_dev->vf_netdev == NULL))
+ 		return NOTIFY_DONE;
+ 
+ 	netdev_info(netvsc_dev->ndev, "VF up: %s\n", vf_netdev->name);
+ 	net_device_ctx = netdev_priv(netvsc_dev->ndev);
+ 	netvsc_dev->vf_inject = true;
+ 
+ 	/*
+ 	 * Open the device before switching data path.
+ 	 */
+ 	rndis_filter_open(net_device_ctx->device_ctx);
+ 
+ 	/*
+ 	 * notify the host to switch the data path.
+ 	 */
+ 	netvsc_switch_datapath(netvsc_dev, true);
+ 	netdev_info(netvsc_dev->ndev, "Data path switched to VF: %s\n",
+ 		    vf_netdev->name);
+ 
+ 	netif_carrier_off(netvsc_dev->ndev);
+ 
+ 	/*
+ 	 * Now notify peers. We are scheduling work to
+ 	 * notify peers; take a reference to prevent
+ 	 * the VF interface from vanishing.
+ 	 */
+ 	atomic_inc(&netvsc_dev->vf_use_cnt);
+ 	net_device_ctx->gwrk.netdev = vf_netdev;
+ 	net_device_ctx->gwrk.netvsc_dev = netvsc_dev;
+ 	schedule_work(&net_device_ctx->gwrk.dwrk);
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ 
+ static int netvsc_vf_down(struct net_device *vf_netdev)
+ {
+ 	struct netvsc_device *netvsc_dev;
+ 	struct net_device_context *net_device_ctx;
+ 	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
+ 
+ 	if (eth_ops == &ethtool_ops)
+ 		return NOTIFY_DONE;
+ 
+ 	netvsc_dev = get_netvsc_device(vf_netdev->dev_addr);
+ 
+ 	if ((netvsc_dev == NULL) || (netvsc_dev->vf_netdev == NULL))
+ 		return NOTIFY_DONE;
+ 
+ 	netdev_info(netvsc_dev->ndev, "VF down: %s\n", vf_netdev->name);
+ 	net_device_ctx = netdev_priv(netvsc_dev->ndev);
+ 	netvsc_dev->vf_inject = false;
+ 	/*
+ 	 * Wait for currently active users to
+ 	 * drain out.
+ 	 */
+ 
+ 	while (atomic_read(&netvsc_dev->vf_use_cnt) != 0)
+ 		udelay(50);
+ 	netvsc_switch_datapath(netvsc_dev, false);
+ 	netdev_info(netvsc_dev->ndev, "Data path switched from VF: %s\n",
+ 		    vf_netdev->name);
+ 	rndis_filter_close(net_device_ctx->device_ctx);
+ 	netif_carrier_on(netvsc_dev->ndev);
+ 	/*
+ 	 * Notify peers.
+ 	 */
+ 	atomic_inc(&netvsc_dev->vf_use_cnt);
+ 	net_device_ctx->gwrk.netdev = netvsc_dev->ndev;
+ 	net_device_ctx->gwrk.netvsc_dev = netvsc_dev;
+ 	schedule_work(&net_device_ctx->gwrk.dwrk);
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ 
+ static int netvsc_unregister_vf(struct net_device *vf_netdev)
+ {
+ 	struct netvsc_device *netvsc_dev;
+ 	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
+ 
+ 	if (eth_ops == &ethtool_ops)
+ 		return NOTIFY_DONE;
+ 
+ 	netvsc_dev = get_netvsc_device(vf_netdev->dev_addr);
+ 	if (netvsc_dev == NULL)
+ 		return NOTIFY_DONE;
+ 	netdev_info(netvsc_dev->ndev, "VF unregistering: %s\n",
+ 		    vf_netdev->name);
+ 
+ 	netvsc_dev->vf_netdev = NULL;
+ 	module_put(THIS_MODULE);
+ 	return NOTIFY_OK;
+ }
+ 
  static int netvsc_probe(struct hv_device *dev,
  			const struct hv_vmbus_device_id *dev_id)
  {
@@@ -881,15 -1343,34 +1136,16 @@@
  	hv_set_drvdata(dev, net);
  	INIT_DELAYED_WORK(&net_device_ctx->dwork, netvsc_link_change);
  	INIT_WORK(&net_device_ctx->work, do_set_multicast);
+ 	INIT_WORK(&net_device_ctx->gwrk.dwrk, netvsc_notify_peers);
  
 -	spin_lock_init(&net_device_ctx->lock);
 -	INIT_LIST_HEAD(&net_device_ctx->reconfig_events);
 -
  	net->netdev_ops = &device_ops;
  
 -	net->hw_features = NETVSC_HW_FEATURES;
 -	net->features = NETVSC_HW_FEATURES | NETIF_F_HW_VLAN_CTAG_TX;
 +	net->hw_features = NETIF_F_RXCSUM | NETIF_F_SG | NETIF_F_IP_CSUM |
 +				NETIF_F_TSO;
 +	net->features = NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_SG | NETIF_F_RXCSUM |
 +			NETIF_F_IP_CSUM | NETIF_F_TSO;
  
 -	net->ethtool_ops = &ethtool_ops;
 +	SET_ETHTOOL_OPS(net, &ethtool_ops);
  	SET_NETDEV_DEV(net, &dev->device);
  
  	/* We always need headroom for rndis header */
* Unmerged path drivers/net/hyperv/hyperv_net.h
diff --git a/drivers/net/hyperv/netvsc.c b/drivers/net/hyperv/netvsc.c
index 74ee1b57e623..36529db92416 100644
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@ -33,6 +33,30 @@
 
 #include "hyperv_net.h"
 
+/*
+ * Switch the data path from the synthetic interface to the VF
+ * interface.
+ */
+void netvsc_switch_datapath(struct netvsc_device *nv_dev, bool vf)
+{
+	struct nvsp_message *init_pkt = &nv_dev->channel_init_pkt;
+	struct hv_device *dev = nv_dev->dev;
+
+	memset(init_pkt, 0, sizeof(struct nvsp_message));
+	init_pkt->hdr.msg_type = NVSP_MSG4_TYPE_SWITCH_DATA_PATH;
+	if (vf)
+		init_pkt->msg.v4_msg.active_dp.active_datapath =
+			NVSP_DATAPATH_VF;
+	else
+		init_pkt->msg.v4_msg.active_dp.active_datapath =
+			NVSP_DATAPATH_SYNTHETIC;
+
+	vmbus_sendpacket(dev->channel, init_pkt,
+			       sizeof(struct nvsp_message),
+			       (unsigned long)init_pkt,
+			       VM_PKT_DATA_INBAND, 0);
+}
+
 
 static struct netvsc_device *alloc_net_device(struct hv_device *device)
 {
@@ -52,9 +76,14 @@ static struct netvsc_device *alloc_net_device(struct hv_device *device)
 	init_waitqueue_head(&net_device->wait_drain);
 	net_device->start_remove = false;
 	net_device->destroy = false;
+	atomic_set(&net_device->open_cnt, 0);
+	atomic_set(&net_device->vf_use_cnt, 0);
 	net_device->dev = device;
 	net_device->ndev = ndev;
 
+	net_device->vf_netdev = NULL;
+	net_device->vf_inject = false;
+
 	hv_set_drvdata(device, net_device);
 	return net_device;
 }
* Unmerged path drivers/net/hyperv/netvsc_drv.c
diff --git a/drivers/net/hyperv/rndis_filter.c b/drivers/net/hyperv/rndis_filter.c
index 5962b79e0a28..f2042445ba32 100644
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@ -1191,6 +1191,9 @@ int rndis_filter_open(struct hv_device *dev)
 	if (!net_device)
 		return -EINVAL;
 
+	if (atomic_inc_return(&net_device->open_cnt) != 1)
+		return 0;
+
 	return rndis_filter_open_device(net_device->extension);
 }
 
@@ -1201,5 +1204,8 @@ int rndis_filter_close(struct hv_device *dev)
 	if (!nvdev)
 		return -EINVAL;
 
+	if (atomic_dec_return(&nvdev->open_cnt) != 0)
+		return 0;
+
 	return rndis_filter_close_device(nvdev->extension);
 }
