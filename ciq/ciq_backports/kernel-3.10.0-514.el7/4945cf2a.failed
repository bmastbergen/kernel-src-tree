perf tools: Add more sort entry check functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit 4945cf2aa1ed61994c158f22f26ea6101059a8d4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4945cf2a.failed

Those functions are for checkinf if a given perf_hpp_fmt is a
filter-related sort entry.  With hierarchy mode, it needs to check
filters on the hist entries with its own hpp format list.

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Tested-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1457531222-18130-3-git-send-email-namhyung@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 4945cf2aa1ed61994c158f22f26ea6101059a8d4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/hist.h
#	tools/perf/util/sort.c
diff --cc tools/perf/util/hist.h
index 1d52912874e9,6870a1bfd762..000000000000
--- a/tools/perf/util/hist.h
+++ b/tools/perf/util/hist.h
@@@ -272,16 -305,39 +272,28 @@@ enum 
  void perf_hpp__init(void);
  void perf_hpp__column_unregister(struct perf_hpp_fmt *format);
  void perf_hpp__cancel_cumulate(void);
 -void perf_hpp__setup_output_field(struct perf_hpp_list *list);
 -void perf_hpp__reset_output_field(struct perf_hpp_list *list);
 -void perf_hpp__append_sort_keys(struct perf_hpp_list *list);
 -int perf_hpp__setup_hists_formats(struct perf_hpp_list *list,
 -				  struct perf_evlist *evlist);
 -
 +void perf_hpp__setup_output_field(void);
 +void perf_hpp__reset_output_field(void);
 +void perf_hpp__append_sort_keys(void);
  
  bool perf_hpp__is_sort_entry(struct perf_hpp_fmt *format);
++<<<<<<< HEAD
 +bool perf_hpp__same_sort_entry(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b);
++=======
+ bool perf_hpp__is_dynamic_entry(struct perf_hpp_fmt *format);
+ bool perf_hpp__defined_dynamic_entry(struct perf_hpp_fmt *fmt, struct hists *hists);
+ bool perf_hpp__is_trace_entry(struct perf_hpp_fmt *fmt);
+ bool perf_hpp__is_srcline_entry(struct perf_hpp_fmt *fmt);
+ bool perf_hpp__is_srcfile_entry(struct perf_hpp_fmt *fmt);
+ bool perf_hpp__is_thread_entry(struct perf_hpp_fmt *fmt);
+ bool perf_hpp__is_comm_entry(struct perf_hpp_fmt *fmt);
+ bool perf_hpp__is_dso_entry(struct perf_hpp_fmt *fmt);
+ bool perf_hpp__is_sym_entry(struct perf_hpp_fmt *fmt);
++>>>>>>> 4945cf2aa1ed (perf tools: Add more sort entry check functions)
  
 -struct perf_hpp_fmt *perf_hpp_fmt__dup(struct perf_hpp_fmt *fmt);
 -
 -int hist_entry__filter(struct hist_entry *he, int type, const void *arg);
 -
 -static inline bool perf_hpp__should_skip(struct perf_hpp_fmt *format,
 -					 struct hists *hists)
 +static inline bool perf_hpp__should_skip(struct perf_hpp_fmt *format)
  {
 -	if (format->elide)
 -		return true;
 -
 -	if (perf_hpp__is_dynamic_entry(format) &&
 -	    !perf_hpp__defined_dynamic_entry(format, hists))
 -		return true;
 -
 -	return false;
 +	return format->elide;
  }
  
  void perf_hpp__reset_width(struct perf_hpp_fmt *fmt, struct hists *hists);
diff --cc tools/perf/util/sort.c
index 8f36c1d6fd38,61c74022e47f..000000000000
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@@ -1448,8 -1483,56 +1448,59 @@@ static int64_t __sort__hpp_sort(struct 
  	return sort_fn(a, b);
  }
  
++<<<<<<< HEAD
++=======
+ bool perf_hpp__is_sort_entry(struct perf_hpp_fmt *format)
+ {
+ 	return format->header == __sort__hpp_header;
+ }
+ 
+ #define MK_SORT_ENTRY_CHK(key)					\
+ bool perf_hpp__is_ ## key ## _entry(struct perf_hpp_fmt *fmt)	\
+ {								\
+ 	struct hpp_sort_entry *hse;				\
+ 								\
+ 	if (!perf_hpp__is_sort_entry(fmt))			\
+ 		return false;					\
+ 								\
+ 	hse = container_of(fmt, struct hpp_sort_entry, hpp);	\
+ 	return hse->se == &sort_ ## key ;			\
+ }
+ 
+ MK_SORT_ENTRY_CHK(trace)
+ MK_SORT_ENTRY_CHK(srcline)
+ MK_SORT_ENTRY_CHK(srcfile)
+ MK_SORT_ENTRY_CHK(thread)
+ MK_SORT_ENTRY_CHK(comm)
+ MK_SORT_ENTRY_CHK(dso)
+ MK_SORT_ENTRY_CHK(sym)
+ 
+ 
+ static bool __sort__hpp_equal(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b)
+ {
+ 	struct hpp_sort_entry *hse_a;
+ 	struct hpp_sort_entry *hse_b;
+ 
+ 	if (!perf_hpp__is_sort_entry(a) || !perf_hpp__is_sort_entry(b))
+ 		return false;
+ 
+ 	hse_a = container_of(a, struct hpp_sort_entry, hpp);
+ 	hse_b = container_of(b, struct hpp_sort_entry, hpp);
+ 
+ 	return hse_a->se == hse_b->se;
+ }
+ 
+ static void hse_free(struct perf_hpp_fmt *fmt)
+ {
+ 	struct hpp_sort_entry *hse;
+ 
+ 	hse = container_of(fmt, struct hpp_sort_entry, hpp);
+ 	free(hse);
+ }
+ 
++>>>>>>> 4945cf2aa1ed (perf tools: Add more sort entry check functions)
  static struct hpp_sort_entry *
 -__sort_dimension__alloc_hpp(struct sort_dimension *sd, int level)
 +__sort_dimension__alloc_hpp(struct sort_dimension *sd)
  {
  	struct hpp_sort_entry *hse;
  
* Unmerged path tools/perf/util/hist.h
* Unmerged path tools/perf/util/sort.c
