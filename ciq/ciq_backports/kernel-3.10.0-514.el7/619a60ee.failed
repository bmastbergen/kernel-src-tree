sctp: Remove outqueue empty state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vlad Yasevich <vyasevich@gmail.com>
commit 619a60ee04be33238721a15c1f9704a2a515a33e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/619a60ee.failed

The SCTP outqueue structure maintains a data chunks
that are pending transmission, the list of chunks that
are pending a retransmission and a length of data in
flight.  It also tries to keep the emtpy state so that
it can performe shutdown sequence or notify user.

The problem is that the empy state is inconsistently
tracked.  It is possible to completely drain the queue
without sending anything when using PR-SCTP.  In this
case, the empty state will not be correctly state as
report by Jamal Hadi Salim <jhs@mojatatu.com>.  This
can cause an association to be perminantly stuck in the
SHUTDOWN_PENDING state.

Additionally, SCTP is incredibly inefficient when setting
the empty state.  Even though all the data is availaible
in the outqueue structure, we ignore it and walk a list
of trasnports.

In the end, we can completely remove the extra empty
state and figure out if the queue is empty by looking
at 3 things:  length of pending data, length of in-flight
data, and exisiting of retransmit data.  All of these
are already in the strucutre.

	Reported-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: Vlad Yasevich <vyasevich@gmail.com>
	Acked-by: Neil Horman <nhorman@tuxdriver.com>
	Tested-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 619a60ee04be33238721a15c1f9704a2a515a33e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/outqueue.c
diff --cc net/sctp/outqueue.c
index 86122121a5ef,59268f6e2c36..000000000000
--- a/net/sctp/outqueue.c
+++ b/net/sctp/outqueue.c
@@@ -1286,35 -1264,22 +1280,43 @@@ int sctp_outq_sack(struct sctp_outq *q
  
  	sctp_generate_fwdtsn(q, sack_ctsn);
  
 -	pr_debug("%s: sack cumulative tsn ack:0x%x\n", __func__, sack_ctsn);
 -	pr_debug("%s: cumulative tsn ack of assoc:%p is 0x%x, "
 -		 "advertised peer ack point:0x%x\n", __func__, asoc, ctsn,
 -		 asoc->adv_peer_ack_point);
 +	SCTP_DEBUG_PRINTK("%s: sack Cumulative TSN Ack is 0x%x.\n",
 +			  __func__, sack_ctsn);
 +	SCTP_DEBUG_PRINTK("%s: Cumulative TSN Ack of association, "
 +			  "%p is 0x%x. Adv peer ack point: 0x%x\n",
 +			  __func__, asoc, ctsn, asoc->adv_peer_ack_point);
 +
++<<<<<<< HEAD
 +	/* See if all chunks are acked.
 +	 * Make sure the empty queue handler will get run later.
 +	 */
 +	q->empty = (list_empty(&q->out_chunk_list) &&
 +		    list_empty(&q->retransmit));
 +	if (!q->empty)
 +		goto finish;
 +
 +	list_for_each_entry(transport, transport_list, transports) {
 +		q->empty = q->empty && list_empty(&transport->transmitted);
 +		if (!q->empty)
 +			goto finish;
 +	}
  
 +	SCTP_DEBUG_PRINTK("sack queue is empty.\n");
 +finish:
 +	return q->empty;
++=======
+ 	return sctp_outq_is_empty(q);
++>>>>>>> 619a60ee04be (sctp: Remove outqueue empty state)
  }
  
- /* Is the outqueue empty?  */
+ /* Is the outqueue empty?
+  * The queue is empty when we have not pending data, no in-flight data
+  * and nothing pending retransmissions.
+  */
  int sctp_outq_is_empty(const struct sctp_outq *q)
  {
- 	return q->empty;
+ 	return q->out_qlen == 0 && q->outstanding_bytes == 0 &&
+ 	       list_empty(&q->retransmit);
  }
  
  /********************************************************************
diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 9c5254863e24..2c57e007db8d 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1060,9 +1060,6 @@ struct sctp_outq {
 
 	/* Corked? */
 	char cork;
-
-	/* Is this structure empty?  */
-	char empty;
 };
 
 void sctp_outq_init(struct sctp_association *, struct sctp_outq *);
* Unmerged path net/sctp/outqueue.c
