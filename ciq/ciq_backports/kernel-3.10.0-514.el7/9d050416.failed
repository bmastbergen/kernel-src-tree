x86/nmi: Enable nested do_nmi() handling for 64-bit kernels

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] nmi: Enable nested do_nmi() handling for 64-bit kernels (Jiri Olsa) [1365704]
Rebuild_FUZZ: 96.49%
commit-author Andy Lutomirski <luto@kernel.org>
commit 9d05041679904b12c12421cbcf9cb5f4860a8d7b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9d050416.failed

32-bit kernels handle nested NMIs in C.  Enable the exact same
handling on 64-bit kernels as well.  This isn't currently
necessary, but it will become necessary once the asm code starts
allowing limited nesting.

	Signed-off-by: Andy Lutomirski <luto@kernel.org>
	Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
	Cc: Borislav Petkov <bp@suse.de>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: stable@vger.kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 9d05041679904b12c12421cbcf9cb5f4860a8d7b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/nmi.c
diff --cc arch/x86/kernel/nmi.c
index 60308053fdb2,d8766b1c9974..000000000000
--- a/arch/x86/kernel/nmi.c
+++ b/arch/x86/kernel/nmi.c
@@@ -357,17 -405,18 +357,17 @@@ static __kprobes void default_do_nmi(st
  	else
  		unknown_nmi_error(reason, regs);
  }
 -NOKPROBE_SYMBOL(default_do_nmi);
  
  /*
-  * NMIs can hit breakpoints which will cause it to lose its
-  * NMI context with the CPU when the breakpoint does an iret.
-  */
- #ifdef CONFIG_X86_32
- /*
-  * For i386, NMIs use the same stack as the kernel, and we can
-  * add a workaround to the iret problem in C (preventing nested
-  * NMIs if an NMI takes a trap). Simply have 3 states the NMI
-  * can be in:
+  * NMIs can hit breakpoints which will cause it to lose its NMI context
+  * with the CPU when the breakpoint or page fault does an IRET.
+  *
+  * As a result, NMIs can nest if NMIs get unmasked due an IRET during
+  * NMI processing.  On x86_64, the asm glue protects us from nested NMIs
+  * if the outer NMI came from kernel mode, but we can still nest if the
+  * outer NMI came from user mode.
+  *
+  * To handle these nested NMIs, we have three states:
   *
   *  1) not running
   *  2) executing
@@@ -465,22 -500,8 +451,16 @@@ nmi_restart
  		debug_stack_set_zero();
  		this_cpu_write(update_debug_stack, 1);
  	}
- }
- 
- static inline void nmi_nesting_postprocess(void)
- {
- 	if (unlikely(this_cpu_read(update_debug_stack))) {
- 		debug_stack_reset();
- 		this_cpu_write(update_debug_stack, 0);
- 	}
- }
  #endif
  
++<<<<<<< HEAD
 +dotraplinkage notrace __kprobes void
 +do_nmi(struct pt_regs *regs, long error_code)
 +{
 +	nmi_nesting_preprocess(regs);
 +
++=======
++>>>>>>> 9d0504167990 (x86/nmi: Enable nested do_nmi() handling for 64-bit kernels)
  	nmi_enter();
  
  	inc_irq_stat(__nmi_count);
@@@ -490,9 -511,19 +470,18 @@@
  
  	nmi_exit();
  
- 	/* On i386, may loop back to preprocess */
- 	nmi_nesting_postprocess();
+ #ifdef CONFIG_X86_64
+ 	if (unlikely(this_cpu_read(update_debug_stack))) {
+ 		debug_stack_reset();
+ 		this_cpu_write(update_debug_stack, 0);
+ 	}
+ #endif
+ 
+ 	if (unlikely(this_cpu_read(nmi_cr2) != read_cr2()))
+ 		write_cr2(this_cpu_read(nmi_cr2));
+ 	if (this_cpu_dec_return(nmi_state))
+ 		goto nmi_restart;
  }
 -NOKPROBE_SYMBOL(do_nmi);
  
  void stop_nmi(void)
  {
* Unmerged path arch/x86/kernel/nmi.c
