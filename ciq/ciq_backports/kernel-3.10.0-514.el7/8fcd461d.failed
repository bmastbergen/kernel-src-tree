nfsd: do nfs4_check_fh in nfs4_check_file instead of nfs4_check_olstateid

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jeff Layton <jlayton@poochiereds.net>
commit 8fcd461db7c09337b6d2e22d25eb411123f379e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8fcd461d.failed

Currently, preprocess_stateid_op calls nfs4_check_olstateid which
verifies that the open stateid corresponds to the current filehandle in the
call by calling nfs4_check_fh.

If the stateid is a NFS4_DELEG_STID however, then no such check is done.
This could cause incorrect enforcement of permissions, because the
nfsd_permission() call in nfs4_check_file uses current the current
filehandle, but any subsequent IO operation will use the file descriptor
in the stateid.

Move the call to nfs4_check_fh into nfs4_check_file instead so that it
can be done for all stateid types.

	Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
	Cc: stable@vger.kernel.org
[bfields: moved fh check to avoid NULL deref in special stateid case]
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 8fcd461db7c09337b6d2e22d25eb411123f379e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4state.c
diff --cc fs/nfsd/nfs4state.c
index 0a0ff7c79780,95202719a1fd..000000000000
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@@ -4499,20 -4573,83 +4499,87 @@@ nfsd4_lookup_stateid(struct nfsd4_compo
  	return nfs_ok;
  }
  
++<<<<<<< HEAD
++=======
+ static struct file *
+ nfs4_find_file(struct nfs4_stid *s, int flags)
+ {
+ 	if (!s)
+ 		return NULL;
+ 
+ 	switch (s->sc_type) {
+ 	case NFS4_DELEG_STID:
+ 		if (WARN_ON_ONCE(!s->sc_file->fi_deleg_file))
+ 			return NULL;
+ 		return get_file(s->sc_file->fi_deleg_file);
+ 	case NFS4_OPEN_STID:
+ 	case NFS4_LOCK_STID:
+ 		if (flags & RD_STATE)
+ 			return find_readable_file(s->sc_file);
+ 		else
+ 			return find_writeable_file(s->sc_file);
+ 		break;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static __be32
+ nfs4_check_olstateid(struct svc_fh *fhp, struct nfs4_ol_stateid *ols, int flags)
+ {
+ 	__be32 status;
+ 
+ 	status = nfsd4_check_openowner_confirmed(ols);
+ 	if (status)
+ 		return status;
+ 	return nfs4_check_openmode(ols, flags);
+ }
+ 
+ static __be32
+ nfs4_check_file(struct svc_rqst *rqstp, struct svc_fh *fhp, struct nfs4_stid *s,
+ 		struct file **filpp, bool *tmp_file, int flags)
+ {
+ 	int acc = (flags & RD_STATE) ? NFSD_MAY_READ : NFSD_MAY_WRITE;
+ 	struct file *file;
+ 	__be32 status;
+ 
+ 	file = nfs4_find_file(s, flags);
+ 	if (file) {
+ 		status = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,
+ 				acc | NFSD_MAY_OWNER_OVERRIDE);
+ 		if (status) {
+ 			fput(file);
+ 			return status;
+ 		}
+ 
+ 		*filpp = file;
+ 	} else {
+ 		status = nfsd_open(rqstp, fhp, S_IFREG, acc, filpp);
+ 		if (status)
+ 			return status;
+ 
+ 		if (tmp_file)
+ 			*tmp_file = true;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 8fcd461db7c0 (nfsd: do nfs4_check_fh in nfs4_check_file instead of nfs4_check_olstateid)
  /*
 - * Checks for stateid operations
 - */
 +* Checks for stateid operations
 +*/
  __be32
 -nfs4_preprocess_stateid_op(struct svc_rqst *rqstp,
 -		struct nfsd4_compound_state *cstate, stateid_t *stateid,
 -		int flags, struct file **filpp, bool *tmp_file)
 +nfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,
 +			   stateid_t *stateid, int flags, struct file **filpp)
  {
 -	struct svc_fh *fhp = &cstate->current_fh;
 -	struct inode *ino = d_inode(fhp->fh_dentry);
 -	struct net *net = SVC_NET(rqstp);
 +	struct nfs4_stid *s;
 +	struct nfs4_ol_stateid *stp = NULL;
 +	struct nfs4_delegation *dp = NULL;
 +	struct svc_fh *current_fh = &cstate->current_fh;
 +	struct inode *ino = current_fh->fh_dentry->d_inode;
  	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
 -	struct nfs4_stid *s = NULL;
 +	struct file *file = NULL;
  	__be32 status;
  
  	if (filpp)
@@@ -4571,13 -4685,18 +4638,23 @@@
  		break;
  	default:
  		status = nfserr_bad_stateid;
 -		break;
 +		goto out;
  	}
++<<<<<<< HEAD
 +	status = nfs_ok;
 +	if (file)
 +		*filpp = file;
++=======
+ 	if (status)
+ 		goto out;
+ 	status = nfs4_check_fh(fhp, s);
+ 
+ done:
+ 	if (!status && filpp)
+ 		status = nfs4_check_file(rqstp, fhp, s, filpp, tmp_file, flags);
++>>>>>>> 8fcd461db7c0 (nfsd: do nfs4_check_fh in nfs4_check_file instead of nfs4_check_olstateid)
  out:
 -	if (s)
 -		nfs4_put_stid(s);
 +	nfs4_put_stid(s);
  	return status;
  }
  
* Unmerged path fs/nfsd/nfs4state.c
