mei: export mei client device struct to external use

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit dbac993f6a6df24d5edc362667e524ba43543472
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/dbac993f.failed

	Cc: Samuel Ortiz <sameo@linux.intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit dbac993f6a6df24d5edc362667e524ba43543472)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,70a644f688b0..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -322,41 -341,9 +322,45 @@@ void mei_cl_bus_rx_event(struct mei_cl 
  void mei_cl_bus_remove_devices(struct mei_device *dev);
  int mei_cl_bus_init(void);
  void mei_cl_bus_exit(void);
 -struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *dev, uuid_le uuid);
 +
++<<<<<<< HEAD
  
  /**
 + * struct mei_cl_device - MEI device handle
 + * An mei_cl_device pointer is returned from mei_add_device()
 + * and links MEI bus clients to their actual ME host client pointer.
 + * Drivers for MEI devices will get an mei_cl_device pointer
 + * when being probed and shall use it for doing ME bus I/O.
 + *
 + * @dev: linux driver model device pointer
 + * @uuid: me client uuid
 + * @cl: mei client
 + * @ops: ME transport ops
 + * @event_cb: Drivers register this callback to get asynchronous ME
 + *	events (e.g. Rx buffer pending) notifications.
 + * @events: Events bitmask sent to the driver.
 + * @priv_data: client private data
 + */
 +struct mei_cl_device {
 +	struct device dev;
 +
 +	struct mei_cl *cl;
 +
 +	const struct mei_cl_ops *ops;
 +
 +	struct work_struct event_work;
 +	mei_cl_event_cb_t event_cb;
 +	void *event_context;
 +	unsigned long events;
 +
 +	void *priv_data;
 +};
 +
 +
 + /**
++=======
++/**
++>>>>>>> dbac993f6a6d (mei: export mei client device struct to external use)
   * enum mei_pg_event - power gating transition events
   *
   * @MEI_PG_EVENT_IDLE: the driver is not in power gating transition
* Unmerged path drivers/misc/mei/mei_dev.h
diff --git a/include/linux/mei_cl_bus.h b/include/linux/mei_cl_bus.h
index d14af7b722ef..f0bb8eeb9477 100644
--- a/include/linux/mei_cl_bus.h
+++ b/include/linux/mei_cl_bus.h
@@ -6,6 +6,42 @@
 
 struct mei_cl_device;
 
+typedef void (*mei_cl_event_cb_t)(struct mei_cl_device *device,
+			       u32 events, void *context);
+
+/**
+ * struct mei_cl_device - MEI device handle
+ * An mei_cl_device pointer is returned from mei_add_device()
+ * and links MEI bus clients to their actual ME host client pointer.
+ * Drivers for MEI devices will get an mei_cl_device pointer
+ * when being probed and shall use it for doing ME bus I/O.
+ *
+ * @dev: linux driver model device pointer
+ * @me_cl: me client
+ * @cl: mei client
+ * @name: device name
+ * @event_work: async work to execute event callback
+ * @event_cb: Drivers register this callback to get asynchronous ME
+ *	events (e.g. Rx buffer pending) notifications.
+ * @event_context: event callback run context
+ * @events: Events bitmask sent to the driver.
+ * @priv_data: client private data
+ */
+struct mei_cl_device {
+	struct device dev;
+
+	struct mei_me_client *me_cl;
+	struct mei_cl *cl;
+	char name[MEI_CL_NAME_SIZE];
+
+	struct work_struct event_work;
+	mei_cl_event_cb_t event_cb;
+	void *event_context;
+	unsigned long events;
+
+	void *priv_data;
+};
+
 struct mei_cl_driver {
 	struct device_driver driver;
 	const char *name;
@@ -27,8 +63,6 @@ void mei_cl_driver_unregister(struct mei_cl_driver *driver);
 int mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length);
 int mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length);
 
-typedef void (*mei_cl_event_cb_t)(struct mei_cl_device *device,
-			       u32 events, void *context);
 int mei_cl_register_event_cb(struct mei_cl_device *device,
 			  mei_cl_event_cb_t read_cb, void *context);
 
