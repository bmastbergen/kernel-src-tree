rhashtable: Prevent spurious EBUSY errors on insertion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit 3cf92222a39cc7842c373dd90a0c204fa7d7cced
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3cf92222.failed

Thomas and Phil observed that under stress rhashtable insertion
sometimes failed with EBUSY, even though this error should only
ever been seen when we're under attack and our hash chain length
has grown to an unacceptable level, even after a rehash.

It turns out that the logic for detecting whether there is an
existing rehash is faulty.  In particular, when two threads both
try to grow the same table at the same time, one of them may see
the newly grown table and thus erroneously conclude that it had
been rehashed.  This is what leads to the EBUSY error.

This patch fixes this by remembering the current last table we
used during insertion so that rhashtable_insert_rehash can detect
when another thread has also done a resize/rehash.  When this is
detected we will give up our resize/rehash and simply retry the
insertion with the new table.

	Reported-by: Thomas Graf <tgraf@suug.ch>
	Reported-by: Phil Sutter <phil@nwl.cc>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Tested-by: Phil Sutter <phil@nwl.cc>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3cf92222a39cc7842c373dd90a0c204fa7d7cced)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/rhashtable.h
#	lib/rhashtable.c
diff --cc include/linux/rhashtable.h
index 0839d7b8cd60,e50b31d18462..000000000000
--- a/include/linux/rhashtable.h
+++ b/include/linux/rhashtable.h
@@@ -18,7 -17,37 +18,41 @@@
  #ifndef _LINUX_RHASHTABLE_H
  #define _LINUX_RHASHTABLE_H
  
++<<<<<<< HEAD
 +#include <linux/rculist.h>
++=======
+ #include <linux/atomic.h>
+ #include <linux/compiler.h>
+ #include <linux/err.h>
+ #include <linux/errno.h>
+ #include <linux/jhash.h>
+ #include <linux/list_nulls.h>
+ #include <linux/workqueue.h>
+ #include <linux/mutex.h>
+ #include <linux/rcupdate.h>
+ 
+ /*
+  * The end of the chain is marked with a special nulls marks which has
+  * the following format:
+  *
+  * +-------+-----------------------------------------------------+-+
+  * | Base  |                      Hash                           |1|
+  * +-------+-----------------------------------------------------+-+
+  *
+  * Base (4 bits) : Reserved to distinguish between multiple tables.
+  *                 Specified via &struct rhashtable_params.nulls_base.
+  * Hash (27 bits): Full hash (unmasked) of first element added to bucket
+  * 1 (1 bit)     : Nulls marker (always set)
+  *
+  * The remaining bits of the next pointer remain unused for now.
+  */
+ #define RHT_BASE_BITS		4
+ #define RHT_HASH_BITS		27
+ #define RHT_BASE_SHIFT		RHT_HASH_BITS
+ 
+ /* Base bits plus 1 bit for nulls marker */
+ #define RHT_HASH_RESERVED_SPACE	(RHT_BASE_BITS + 1)
++>>>>>>> 3cf92222a39c (rhashtable: Prevent spurious EBUSY errors on insertion)
  
  struct rhash_head {
  	struct rhash_head __rcu		*next;
@@@ -98,22 -337,25 +132,30 @@@ static inline int lockdep_rht_bucket_is
  }
  #endif /* CONFIG_PROVE_LOCKING */
  
 -int rhashtable_init(struct rhashtable *ht,
 -		    const struct rhashtable_params *params);
 +int rhashtable_init(struct rhashtable *ht, struct rhashtable_params *params);
  
++<<<<<<< HEAD
 +void rhashtable_insert(struct rhashtable *ht, struct rhash_head *node);
 +bool rhashtable_remove(struct rhashtable *ht, struct rhash_head *node);
++=======
+ struct bucket_table *rhashtable_insert_slow(struct rhashtable *ht,
+ 					    const void *key,
+ 					    struct rhash_head *obj,
+ 					    struct bucket_table *old_tbl);
+ int rhashtable_insert_rehash(struct rhashtable *ht, struct bucket_table *tbl);
++>>>>>>> 3cf92222a39c (rhashtable: Prevent spurious EBUSY errors on insertion)
 +
 +bool rht_grow_above_75(const struct rhashtable *ht, size_t new_size);
 +bool rht_shrink_below_30(const struct rhashtable *ht, size_t new_size);
 +
 +int rhashtable_expand(struct rhashtable *ht);
 +int rhashtable_shrink(struct rhashtable *ht);
  
 -int rhashtable_walk_init(struct rhashtable *ht, struct rhashtable_iter *iter);
 -void rhashtable_walk_exit(struct rhashtable_iter *iter);
 -int rhashtable_walk_start(struct rhashtable_iter *iter) __acquires(RCU);
 -void *rhashtable_walk_next(struct rhashtable_iter *iter);
 -void rhashtable_walk_stop(struct rhashtable_iter *iter) __releases(RCU);
 +void *rhashtable_lookup(const struct rhashtable *ht, const void *key);
 +void *rhashtable_lookup_compare(const struct rhashtable *ht, const void *key,
 +				bool (*compare)(void *, void *), void *arg);
  
 -void rhashtable_free_and_destroy(struct rhashtable *ht,
 -				 void (*free_fn)(void *ptr, void *arg),
 -				 void *arg);
 -void rhashtable_destroy(struct rhashtable *ht);
 +void rhashtable_destroy(const struct rhashtable *ht);
  
  #define rht_dereference(p, ht) \
  	rcu_dereference_protected(p, lockdep_rht_mutex_is_held(ht))
@@@ -261,4 -505,322 +303,325 @@@
  	rht_for_each_entry_rcu_continue(tpos, pos, (tbl)->buckets[hash],\
  					tbl, hash, member)
  
++<<<<<<< HEAD
++=======
+ static inline int rhashtable_compare(struct rhashtable_compare_arg *arg,
+ 				     const void *obj)
+ {
+ 	struct rhashtable *ht = arg->ht;
+ 	const char *ptr = obj;
+ 
+ 	return memcmp(ptr + ht->p.key_offset, arg->key, ht->p.key_len);
+ }
+ 
+ /**
+  * rhashtable_lookup_fast - search hash table, inlined version
+  * @ht:		hash table
+  * @key:	the pointer to the key
+  * @params:	hash table parameters
+  *
+  * Computes the hash value for the key and traverses the bucket chain looking
+  * for a entry with an identical key. The first matching entry is returned.
+  *
+  * Returns the first entry on which the compare function returned true.
+  */
+ static inline void *rhashtable_lookup_fast(
+ 	struct rhashtable *ht, const void *key,
+ 	const struct rhashtable_params params)
+ {
+ 	struct rhashtable_compare_arg arg = {
+ 		.ht = ht,
+ 		.key = key,
+ 	};
+ 	const struct bucket_table *tbl;
+ 	struct rhash_head *he;
+ 	unsigned int hash;
+ 
+ 	rcu_read_lock();
+ 
+ 	tbl = rht_dereference_rcu(ht->tbl, ht);
+ restart:
+ 	hash = rht_key_hashfn(ht, tbl, key, params);
+ 	rht_for_each_rcu(he, tbl, hash) {
+ 		if (params.obj_cmpfn ?
+ 		    params.obj_cmpfn(&arg, rht_obj(ht, he)) :
+ 		    rhashtable_compare(&arg, rht_obj(ht, he)))
+ 			continue;
+ 		rcu_read_unlock();
+ 		return rht_obj(ht, he);
+ 	}
+ 
+ 	/* Ensure we see any new tables. */
+ 	smp_rmb();
+ 
+ 	tbl = rht_dereference_rcu(tbl->future_tbl, ht);
+ 	if (unlikely(tbl))
+ 		goto restart;
+ 	rcu_read_unlock();
+ 
+ 	return NULL;
+ }
+ 
+ /* Internal function, please use rhashtable_insert_fast() instead */
+ static inline int __rhashtable_insert_fast(
+ 	struct rhashtable *ht, const void *key, struct rhash_head *obj,
+ 	const struct rhashtable_params params)
+ {
+ 	struct rhashtable_compare_arg arg = {
+ 		.ht = ht,
+ 		.key = key,
+ 	};
+ 	struct bucket_table *tbl, *new_tbl;
+ 	struct rhash_head *head;
+ 	spinlock_t *lock;
+ 	unsigned int elasticity;
+ 	unsigned int hash;
+ 	int err;
+ 
+ restart:
+ 	rcu_read_lock();
+ 
+ 	tbl = rht_dereference_rcu(ht->tbl, ht);
+ 
+ 	/* All insertions must grab the oldest table containing
+ 	 * the hashed bucket that is yet to be rehashed.
+ 	 */
+ 	for (;;) {
+ 		hash = rht_head_hashfn(ht, tbl, obj, params);
+ 		lock = rht_bucket_lock(tbl, hash);
+ 		spin_lock_bh(lock);
+ 
+ 		if (tbl->rehash <= hash)
+ 			break;
+ 
+ 		spin_unlock_bh(lock);
+ 		tbl = rht_dereference_rcu(tbl->future_tbl, ht);
+ 	}
+ 
+ 	new_tbl = rht_dereference_rcu(tbl->future_tbl, ht);
+ 	if (unlikely(new_tbl)) {
+ 		tbl = rhashtable_insert_slow(ht, key, obj, new_tbl);
+ 		if (!IS_ERR_OR_NULL(tbl))
+ 			goto slow_path;
+ 
+ 		err = PTR_ERR(tbl);
+ 		goto out;
+ 	}
+ 
+ 	err = -E2BIG;
+ 	if (unlikely(rht_grow_above_max(ht, tbl)))
+ 		goto out;
+ 
+ 	if (unlikely(rht_grow_above_100(ht, tbl))) {
+ slow_path:
+ 		spin_unlock_bh(lock);
+ 		err = rhashtable_insert_rehash(ht, tbl);
+ 		rcu_read_unlock();
+ 		if (err)
+ 			return err;
+ 
+ 		goto restart;
+ 	}
+ 
+ 	err = -EEXIST;
+ 	elasticity = ht->elasticity;
+ 	rht_for_each(head, tbl, hash) {
+ 		if (key &&
+ 		    unlikely(!(params.obj_cmpfn ?
+ 			       params.obj_cmpfn(&arg, rht_obj(ht, head)) :
+ 			       rhashtable_compare(&arg, rht_obj(ht, head)))))
+ 			goto out;
+ 		if (!--elasticity)
+ 			goto slow_path;
+ 	}
+ 
+ 	err = 0;
+ 
+ 	head = rht_dereference_bucket(tbl->buckets[hash], tbl, hash);
+ 
+ 	RCU_INIT_POINTER(obj->next, head);
+ 
+ 	rcu_assign_pointer(tbl->buckets[hash], obj);
+ 
+ 	atomic_inc(&ht->nelems);
+ 	if (rht_grow_above_75(ht, tbl))
+ 		schedule_work(&ht->run_work);
+ 
+ out:
+ 	spin_unlock_bh(lock);
+ 	rcu_read_unlock();
+ 
+ 	return err;
+ }
+ 
+ /**
+  * rhashtable_insert_fast - insert object into hash table
+  * @ht:		hash table
+  * @obj:	pointer to hash head inside object
+  * @params:	hash table parameters
+  *
+  * Will take a per bucket spinlock to protect against mutual mutations
+  * on the same bucket. Multiple insertions may occur in parallel unless
+  * they map to the same bucket lock.
+  *
+  * It is safe to call this function from atomic context.
+  *
+  * Will trigger an automatic deferred table resizing if the size grows
+  * beyond the watermark indicated by grow_decision() which can be passed
+  * to rhashtable_init().
+  */
+ static inline int rhashtable_insert_fast(
+ 	struct rhashtable *ht, struct rhash_head *obj,
+ 	const struct rhashtable_params params)
+ {
+ 	return __rhashtable_insert_fast(ht, NULL, obj, params);
+ }
+ 
+ /**
+  * rhashtable_lookup_insert_fast - lookup and insert object into hash table
+  * @ht:		hash table
+  * @obj:	pointer to hash head inside object
+  * @params:	hash table parameters
+  *
+  * Locks down the bucket chain in both the old and new table if a resize
+  * is in progress to ensure that writers can't remove from the old table
+  * and can't insert to the new table during the atomic operation of search
+  * and insertion. Searches for duplicates in both the old and new table if
+  * a resize is in progress.
+  *
+  * This lookup function may only be used for fixed key hash table (key_len
+  * parameter set). It will BUG() if used inappropriately.
+  *
+  * It is safe to call this function from atomic context.
+  *
+  * Will trigger an automatic deferred table resizing if the size grows
+  * beyond the watermark indicated by grow_decision() which can be passed
+  * to rhashtable_init().
+  */
+ static inline int rhashtable_lookup_insert_fast(
+ 	struct rhashtable *ht, struct rhash_head *obj,
+ 	const struct rhashtable_params params)
+ {
+ 	const char *key = rht_obj(ht, obj);
+ 
+ 	BUG_ON(ht->p.obj_hashfn);
+ 
+ 	return __rhashtable_insert_fast(ht, key + ht->p.key_offset, obj,
+ 					params);
+ }
+ 
+ /**
+  * rhashtable_lookup_insert_key - search and insert object to hash table
+  *				  with explicit key
+  * @ht:		hash table
+  * @key:	key
+  * @obj:	pointer to hash head inside object
+  * @params:	hash table parameters
+  *
+  * Locks down the bucket chain in both the old and new table if a resize
+  * is in progress to ensure that writers can't remove from the old table
+  * and can't insert to the new table during the atomic operation of search
+  * and insertion. Searches for duplicates in both the old and new table if
+  * a resize is in progress.
+  *
+  * Lookups may occur in parallel with hashtable mutations and resizing.
+  *
+  * Will trigger an automatic deferred table resizing if the size grows
+  * beyond the watermark indicated by grow_decision() which can be passed
+  * to rhashtable_init().
+  *
+  * Returns zero on success.
+  */
+ static inline int rhashtable_lookup_insert_key(
+ 	struct rhashtable *ht, const void *key, struct rhash_head *obj,
+ 	const struct rhashtable_params params)
+ {
+ 	BUG_ON(!ht->p.obj_hashfn || !key);
+ 
+ 	return __rhashtable_insert_fast(ht, key, obj, params);
+ }
+ 
+ /* Internal function, please use rhashtable_remove_fast() instead */
+ static inline int __rhashtable_remove_fast(
+ 	struct rhashtable *ht, struct bucket_table *tbl,
+ 	struct rhash_head *obj, const struct rhashtable_params params)
+ {
+ 	struct rhash_head __rcu **pprev;
+ 	struct rhash_head *he;
+ 	spinlock_t * lock;
+ 	unsigned int hash;
+ 	int err = -ENOENT;
+ 
+ 	hash = rht_head_hashfn(ht, tbl, obj, params);
+ 	lock = rht_bucket_lock(tbl, hash);
+ 
+ 	spin_lock_bh(lock);
+ 
+ 	pprev = &tbl->buckets[hash];
+ 	rht_for_each(he, tbl, hash) {
+ 		if (he != obj) {
+ 			pprev = &he->next;
+ 			continue;
+ 		}
+ 
+ 		rcu_assign_pointer(*pprev, obj->next);
+ 		err = 0;
+ 		break;
+ 	}
+ 
+ 	spin_unlock_bh(lock);
+ 
+ 	return err;
+ }
+ 
+ /**
+  * rhashtable_remove_fast - remove object from hash table
+  * @ht:		hash table
+  * @obj:	pointer to hash head inside object
+  * @params:	hash table parameters
+  *
+  * Since the hash chain is single linked, the removal operation needs to
+  * walk the bucket chain upon removal. The removal operation is thus
+  * considerable slow if the hash table is not correctly sized.
+  *
+  * Will automatically shrink the table via rhashtable_expand() if the
+  * shrink_decision function specified at rhashtable_init() returns true.
+  *
+  * Returns zero on success, -ENOENT if the entry could not be found.
+  */
+ static inline int rhashtable_remove_fast(
+ 	struct rhashtable *ht, struct rhash_head *obj,
+ 	const struct rhashtable_params params)
+ {
+ 	struct bucket_table *tbl;
+ 	int err;
+ 
+ 	rcu_read_lock();
+ 
+ 	tbl = rht_dereference_rcu(ht->tbl, ht);
+ 
+ 	/* Because we have already taken (and released) the bucket
+ 	 * lock in old_tbl, if we find that future_tbl is not yet
+ 	 * visible then that guarantees the entry to still be in
+ 	 * the old tbl if it exists.
+ 	 */
+ 	while ((err = __rhashtable_remove_fast(ht, tbl, obj, params)) &&
+ 	       (tbl = rht_dereference_rcu(tbl->future_tbl, ht)))
+ 		;
+ 
+ 	if (err)
+ 		goto out;
+ 
+ 	atomic_dec(&ht->nelems);
+ 	if (unlikely(ht->p.automatic_shrinking &&
+ 		     rht_shrink_below_30(ht, tbl)))
+ 		schedule_work(&ht->run_work);
+ 
+ out:
+ 	rcu_read_unlock();
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 3cf92222a39c (rhashtable: Prevent spurious EBUSY errors on insertion)
  #endif /* _LINUX_RHASHTABLE_H */
diff --cc lib/rhashtable.c
index 15ef938f4f67,2ff7ed91663a..000000000000
--- a/lib/rhashtable.c
+++ b/lib/rhashtable.c
@@@ -393,69 -388,250 +393,169 @@@ bool rhashtable_remove(struct rhashtabl
  
  	return false;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(rhashtable_remove);
++=======
+ 
+ int rhashtable_insert_rehash(struct rhashtable *ht,
+ 			     struct bucket_table *tbl)
+ {
+ 	struct bucket_table *old_tbl;
+ 	struct bucket_table *new_tbl;
+ 	unsigned int size;
+ 	int err;
+ 
+ 	old_tbl = rht_dereference_rcu(ht->tbl, ht);
+ 
+ 	size = tbl->size;
+ 
+ 	err = -EBUSY;
+ 
+ 	if (rht_grow_above_75(ht, tbl))
+ 		size *= 2;
+ 	/* Do not schedule more than one rehash */
+ 	else if (old_tbl != tbl)
+ 		goto fail;
+ 
+ 	err = -ENOMEM;
+ 
+ 	new_tbl = bucket_table_alloc(ht, size, GFP_ATOMIC);
+ 	if (new_tbl == NULL)
+ 		goto fail;
+ 
+ 	err = rhashtable_rehash_attach(ht, tbl, new_tbl);
+ 	if (err) {
+ 		bucket_table_free(new_tbl);
+ 		if (err == -EEXIST)
+ 			err = 0;
+ 	} else
+ 		schedule_work(&ht->run_work);
+ 
+ 	return err;
+ 
+ fail:
+ 	/* Do not fail the insert if someone else did a rehash. */
+ 	if (likely(rcu_dereference_raw(tbl->future_tbl)))
+ 		return 0;
+ 
+ 	/* Schedule async rehash to retry allocation in process context. */
+ 	if (err == -ENOMEM)
+ 		schedule_work(&ht->run_work);
+ 
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(rhashtable_insert_rehash);
+ 
+ struct bucket_table *rhashtable_insert_slow(struct rhashtable *ht,
+ 					    const void *key,
+ 					    struct rhash_head *obj,
+ 					    struct bucket_table *tbl)
+ {
+ 	struct rhash_head *head;
+ 	unsigned int hash;
+ 	int err;
+ 
+ 	tbl = rhashtable_last_table(ht, tbl);
+ 	hash = head_hashfn(ht, tbl, obj);
+ 	spin_lock_nested(rht_bucket_lock(tbl, hash), SINGLE_DEPTH_NESTING);
+ 
+ 	err = -EEXIST;
+ 	if (key && rhashtable_lookup_fast(ht, key, ht->p))
+ 		goto exit;
+ 
+ 	err = -E2BIG;
+ 	if (unlikely(rht_grow_above_max(ht, tbl)))
+ 		goto exit;
+ 
+ 	err = -EAGAIN;
+ 	if (rhashtable_check_elasticity(ht, tbl, hash) ||
+ 	    rht_grow_above_100(ht, tbl))
+ 		goto exit;
+ 
+ 	err = 0;
+ 
+ 	head = rht_dereference_bucket(tbl->buckets[hash], tbl, hash);
+ 
+ 	RCU_INIT_POINTER(obj->next, head);
+ 
+ 	rcu_assign_pointer(tbl->buckets[hash], obj);
+ 
+ 	atomic_inc(&ht->nelems);
+ 
+ exit:
+ 	spin_unlock(rht_bucket_lock(tbl, hash));
+ 
+ 	if (err == 0)
+ 		return NULL;
+ 	else if (err == -EAGAIN)
+ 		return tbl;
+ 	else
+ 		return ERR_PTR(err);
+ }
+ EXPORT_SYMBOL_GPL(rhashtable_insert_slow);
++>>>>>>> 3cf92222a39c (rhashtable: Prevent spurious EBUSY errors on insertion)
  
  /**
 - * rhashtable_walk_init - Initialise an iterator
 - * @ht:		Table to walk over
 - * @iter:	Hash table Iterator
 - *
 - * This function prepares a hash table walk.
 + * rhashtable_lookup - lookup key in hash table
 + * @ht:		hash table
 + * @key:	pointer to key
   *
 - * Note that if you restart a walk after rhashtable_walk_stop you
 - * may see the same object twice.  Also, you may miss objects if
 - * there are removals in between rhashtable_walk_stop and the next
 - * call to rhashtable_walk_start.
 + * Computes the hash value for the key and traverses the bucket chain looking
 + * for a entry with an identical key. The first matching entry is returned.
   *
 - * For a completely stable walk you should construct your own data
 - * structure outside the hash table.
 + * This lookup function may only be used for fixed key hash table (key_len
 + * paramter set). It will BUG() if used inappropriately.
   *
 - * This function may sleep so you must not call it from interrupt
 - * context or with spin locks held.
 - *
 - * You must call rhashtable_walk_exit if this function returns
 - * successfully.
 + * Lookups may occur in parallel with hash mutations as long as the lookup is
 + * guarded by rcu_read_lock(). The caller must take care of this.
   */
 -int rhashtable_walk_init(struct rhashtable *ht, struct rhashtable_iter *iter)
 +void *rhashtable_lookup(const struct rhashtable *ht, const void *key)
  {
 -	iter->ht = ht;
 -	iter->p = NULL;
 -	iter->slot = 0;
 -	iter->skip = 0;
 -
 -	iter->walker = kmalloc(sizeof(*iter->walker), GFP_KERNEL);
 -	if (!iter->walker)
 -		return -ENOMEM;
 -
 -	mutex_lock(&ht->mutex);
 -	iter->walker->tbl = rht_dereference(ht->tbl, ht);
 -	list_add(&iter->walker->list, &iter->walker->tbl->walkers);
 -	mutex_unlock(&ht->mutex);
 -
 -	return 0;
 -}
 -EXPORT_SYMBOL_GPL(rhashtable_walk_init);
 -
 -/**
 - * rhashtable_walk_exit - Free an iterator
 - * @iter:	Hash table Iterator
 - *
 - * This function frees resources allocated by rhashtable_walk_init.
 - */
 -void rhashtable_walk_exit(struct rhashtable_iter *iter)
 -{
 -	mutex_lock(&iter->ht->mutex);
 -	if (iter->walker->tbl)
 -		list_del(&iter->walker->list);
 -	mutex_unlock(&iter->ht->mutex);
 -	kfree(iter->walker);
 -}
 -EXPORT_SYMBOL_GPL(rhashtable_walk_exit);
 -
 -/**
 - * rhashtable_walk_start - Start a hash table walk
 - * @iter:	Hash table iterator
 - *
 - * Start a hash table walk.  Note that we take the RCU lock in all
 - * cases including when we return an error.  So you must always call
 - * rhashtable_walk_stop to clean up.
 - *
 - * Returns zero if successful.
 - *
 - * Returns -EAGAIN if resize event occured.  Note that the iterator
 - * will rewind back to the beginning and you may use it immediately
 - * by calling rhashtable_walk_next.
 - */
 -int rhashtable_walk_start(struct rhashtable_iter *iter)
 -	__acquires(RCU)
 -{
 -	struct rhashtable *ht = iter->ht;
 -
 -	mutex_lock(&ht->mutex);
 -
 -	if (iter->walker->tbl)
 -		list_del(&iter->walker->list);
 -
 -	rcu_read_lock();
 -
 -	mutex_unlock(&ht->mutex);
 -
 -	if (!iter->walker->tbl) {
 -		iter->walker->tbl = rht_dereference_rcu(ht->tbl, ht);
 -		return -EAGAIN;
 +	const struct bucket_table *tbl = rht_dereference_rcu(ht->tbl, ht);
 +	struct rhash_head *he;
 +	u32 h;
 +
 +	BUG_ON(!ht->p.key_len);
 +
 +	h = key_hashfn(ht, key, ht->p.key_len);
 +	rht_for_each_rcu(he, tbl, h) {
 +		if (memcmp(rht_obj(ht, he) + ht->p.key_offset, key,
 +			   ht->p.key_len))
 +			continue;
 +		return rht_obj(ht, he);
  	}
  
 -	return 0;
 +	return NULL;
  }
 -EXPORT_SYMBOL_GPL(rhashtable_walk_start);
 +EXPORT_SYMBOL_GPL(rhashtable_lookup);
  
  /**
 - * rhashtable_walk_next - Return the next object and advance the iterator
 - * @iter:	Hash table iterator
 + * rhashtable_lookup_compare - search hash table with compare function
 + * @ht:		hash table
 + * @key:	the pointer to the key
 + * @compare:	compare function, must return true on match
 + * @arg:	argument passed on to compare function
   *
 - * Note that you must call rhashtable_walk_stop when you are finished
 - * with the walk.
 + * Traverses the bucket chain behind the provided hash value and calls the
 + * specified compare function for each entry.
   *
 - * Returns the next object or NULL when the end of the table is reached.
 + * Lookups may occur in parallel with hash mutations as long as the lookup is
 + * guarded by rcu_read_lock(). The caller must take care of this.
   *
 - * Returns -EAGAIN if resize event occured.  Note that the iterator
 - * will rewind back to the beginning and you may continue to use it.
 + * Returns the first entry on which the compare function returned true.
   */
 -void *rhashtable_walk_next(struct rhashtable_iter *iter)
 +void *rhashtable_lookup_compare(const struct rhashtable *ht, const void *key,
 +				bool (*compare)(void *, void *), void *arg)
  {
 -	struct bucket_table *tbl = iter->walker->tbl;
 -	struct rhashtable *ht = iter->ht;
 -	struct rhash_head *p = iter->p;
 -
 -	if (p) {
 -		p = rht_dereference_bucket_rcu(p->next, tbl, iter->slot);
 -		goto next;
 -	}
 -
 -	for (; iter->slot < tbl->size; iter->slot++) {
 -		int skip = iter->skip;
 -
 -		rht_for_each_rcu(p, tbl, iter->slot) {
 -			if (!skip)
 -				break;
 -			skip--;
 -		}
 -
 -next:
 -		if (!rht_is_a_nulls(p)) {
 -			iter->skip++;
 -			iter->p = p;
 -			return rht_obj(ht, p);
 -		}
 -
 -		iter->skip = 0;
 -	}
 -
 -	iter->p = NULL;
 -
 -	/* Ensure we see any new tables. */
 -	smp_rmb();
 -
 -	iter->walker->tbl = rht_dereference_rcu(tbl->future_tbl, ht);
 -	if (iter->walker->tbl) {
 -		iter->slot = 0;
 -		iter->skip = 0;
 -		return ERR_PTR(-EAGAIN);
 +	const struct bucket_table *tbl = rht_dereference_rcu(ht->tbl, ht);
 +	struct rhash_head *he;
 +	u32 hash;
 +
 +	hash = key_hashfn(ht, key, ht->p.key_len);
 +	rht_for_each_rcu(he, tbl, hash) {
 +		if (!compare(rht_obj(ht, he), arg))
 +			continue;
 +		return rht_obj(ht, he);
  	}
  
  	return NULL;
* Unmerged path include/linux/rhashtable.h
* Unmerged path lib/rhashtable.c
