inet_diag: factorize code in new inet_diag_msg_common_fill() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Eric Dumazet <edumazet@google.com>
commit a4458343ac5986d010290915df6ab884afacbdb7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a4458343.failed

Now the three type of sockets share a common base, we can factorize
code in inet_diag_msg_common_fill().

inet_diag_entry no longer requires saddr_storage & daddr_storage
and the extra copies.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a4458343ac5986d010290915df6ab884afacbdb7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/inet_diag.c
diff --cc net/ipv4/inet_diag.c
index f92539b6465e,ac7b5c909fe7..000000000000
--- a/net/ipv4/inet_diag.c
+++ b/net/ipv4/inet_diag.c
@@@ -71,18 -66,28 +67,43 @@@ static inline void inet_diag_unlock_han
  	mutex_unlock(&inet_diag_table_mutex);
  }
  
++<<<<<<< HEAD
 +static size_t inet_sk_attr_size(void)
 +{
 +	return	  nla_total_size(sizeof(struct tcp_info))
 +		+ nla_total_size(1) /* INET_DIAG_SHUTDOWN */
 +		+ nla_total_size(1) /* INET_DIAG_TOS */
 +		+ nla_total_size(1) /* INET_DIAG_TCLASS */
 +		+ nla_total_size(sizeof(struct inet_diag_meminfo))
 +		+ nla_total_size(sizeof(struct inet_diag_msg))
 +		+ nla_total_size(SK_MEMINFO_VARS * sizeof(u32))
 +		+ nla_total_size(TCP_CA_NAME_MAX)
 +		+ nla_total_size(sizeof(struct tcpvegas_info))
 +		+ 64;
++=======
+ static void inet_diag_msg_common_fill(struct inet_diag_msg *r, struct sock *sk)
+ {
+ 	r->idiag_family = sk->sk_family;
+ 
+ 	r->id.idiag_sport = htons(sk->sk_num);
+ 	r->id.idiag_dport = sk->sk_dport;
+ 	r->id.idiag_if = sk->sk_bound_dev_if;
+ 	sock_diag_save_cookie(sk, r->id.idiag_cookie);
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (sk->sk_family == AF_INET6) {
+ 		*(struct in6_addr *)r->id.idiag_src = sk->sk_v6_rcv_saddr;
+ 		*(struct in6_addr *)r->id.idiag_dst = sk->sk_v6_daddr;
+ 	} else
+ #endif
+ 	{
+ 	memset(&r->id.idiag_src, 0, sizeof(r->id.idiag_src));
+ 	memset(&r->id.idiag_dst, 0, sizeof(r->id.idiag_dst));
+ 
+ 	r->id.idiag_src[0] = sk->sk_rcv_saddr;
+ 	r->id.idiag_dst[0] = sk->sk_daddr;
+ 	}
++>>>>>>> a4458343ac59 (inet_diag: factorize code in new inet_diag_msg_common_fill() helper)
  }
  
  int inet_sk_diag_fill(struct sock *sk, struct inet_connection_sock *icsk,
@@@ -109,9 -113,9 +130,9 @@@
  		return -EMSGSIZE;
  
  	r = nlmsg_data(nlh);
 -	BUG_ON((1 << sk->sk_state) & (TCPF_TIME_WAIT | TCPF_NEW_SYN_RECV));
 +	BUG_ON(sk->sk_state == TCP_TIME_WAIT);
  
- 	r->idiag_family = sk->sk_family;
+ 	inet_diag_msg_common_fill(r, sk);
  	r->idiag_state = sk->sk_state;
  	r->idiag_timer = 0;
  	r->idiag_retrans = 0;
@@@ -140,10 -133,6 +150,13 @@@
  
  #if IS_ENABLED(CONFIG_IPV6)
  	if (r->idiag_family == AF_INET6) {
++<<<<<<< HEAD
 +
 +		*(struct in6_addr *)r->id.idiag_src = sk->sk_v6_rcv_saddr;
 +		*(struct in6_addr *)r->id.idiag_dst = sk->sk_v6_daddr;
 +
++=======
++>>>>>>> a4458343ac59 (inet_diag: factorize code in new inet_diag_msg_common_fill() helper)
  		if (ext & (1 << (INET_DIAG_TCLASS - 1)))
  			if (nla_put_u8(skb, INET_DIAG_TCLASS,
  				       inet6_sk(sk)->tclass) < 0)
@@@ -276,21 -250,9 +289,24 @@@ static int inet_twsk_diag_fill(struct i
  	if (tmo < 0)
  		tmo = 0;
  
- 	r->idiag_family	      = tw->tw_family;
+ 	inet_diag_msg_common_fill(r, sk);
  	r->idiag_retrans      = 0;
  
++<<<<<<< HEAD
 +	r->id.idiag_if	      = tw->tw_bound_dev_if;
 +	sock_diag_save_cookie(tw, r->id.idiag_cookie);
 +
 +	r->id.idiag_sport     = tw->tw_sport;
 +	r->id.idiag_dport     = tw->tw_dport;
 +
 +	memset(&r->id.idiag_src, 0, sizeof(r->id.idiag_src));
 +	memset(&r->id.idiag_dst, 0, sizeof(r->id.idiag_dst));
 +
 +	r->id.idiag_src[0]    = tw->tw_rcv_saddr;
 +	r->id.idiag_dst[0]    = tw->tw_daddr;
 +
++=======
++>>>>>>> a4458343ac59 (inet_diag: factorize code in new inet_diag_msg_common_fill() helper)
  	r->idiag_state	      = tw->tw_substate;
  	r->idiag_timer	      = 3;
  	r->idiag_expires      = jiffies_to_msecs(tmo);
@@@ -298,14 -260,9 +314,8 @@@
  	r->idiag_wqueue	      = 0;
  	r->idiag_uid	      = 0;
  	r->idiag_inode	      = 0;
- #if IS_ENABLED(CONFIG_IPV6)
- 	if (tw->tw_family == AF_INET6) {
- 		*(struct in6_addr *)r->id.idiag_src = tw->tw_v6_rcv_saddr;
- 		*(struct in6_addr *)r->id.idiag_dst = tw->tw_v6_daddr;
- 	}
- #endif
  
 -	nlmsg_end(skb, nlh);
 -	return 0;
 +	return nlmsg_end(skb, nlh);
  }
  
  static int sk_diag_fill(struct sock *sk, struct sk_buff *skb,
@@@ -516,26 -473,33 +526,47 @@@ static int inet_diag_bc_run(const struc
  	return len == 0;
  }
  
+ /* This helper is available for all sockets (ESTABLISH, TIMEWAIT, SYN_RECV)
+  */
+ static void entry_fill_addrs(struct inet_diag_entry *entry,
+ 			     const struct sock *sk)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (sk->sk_family == AF_INET6) {
+ 		entry->saddr = sk->sk_v6_rcv_saddr.s6_addr32;
+ 		entry->daddr = sk->sk_v6_daddr.s6_addr32;
+ 	} else
+ #endif
+ 	{
+ 		entry->saddr = &sk->sk_rcv_saddr;
+ 		entry->daddr = &sk->sk_daddr;
+ 	}
+ }
+ 
  int inet_diag_bc_sk(const struct nlattr *bc, struct sock *sk)
  {
 -	struct inet_sock *inet = inet_sk(sk);
  	struct inet_diag_entry entry;
 +	struct inet_sock *inet = inet_sk(sk);
  
 -	if (!bc)
 +	if (bc == NULL)
  		return 1;
  
  	entry.family = sk->sk_family;
++<<<<<<< HEAD
 +#if IS_ENABLED(CONFIG_IPV6)
 +	if (entry.family == AF_INET6) {
 +
 +		entry.saddr = sk->sk_v6_rcv_saddr.s6_addr32;
 +		entry.daddr = sk->sk_v6_daddr.s6_addr32;
 +	} else
 +#endif
 +	{
 +		entry.saddr = &inet->inet_rcv_saddr;
 +		entry.daddr = &inet->inet_daddr;
 +	}
++=======
+ 	entry_fill_addrs(&entry, sk);
++>>>>>>> a4458343ac59 (inet_diag: factorize code in new inet_diag_msg_common_fill() helper)
  	entry.sport = inet->inet_num;
  	entry.dport = ntohs(inet->inet_dport);
  	entry.userlocks = (sk->sk_state != TCP_TIME_WAIT) ? sk->sk_userlocks : 0;
@@@ -714,36 -677,6 +745,39 @@@ static int inet_twsk_diag_dump(struct s
  				   cb->nlh->nlmsg_seq, NLM_F_MULTI, cb->nlh);
  }
  
++<<<<<<< HEAD
 +/* Get the IPv4, IPv6, or IPv4-mapped-IPv6 local and remote addresses
 + * from a request_sock. For IPv4-mapped-IPv6 we must map IPv4 to IPv6.
 + */
 +static inline void inet_diag_req_addrs(const struct sock *sk,
 +				       const struct request_sock *req,
 +				       struct inet_diag_entry *entry)
 +{
 +	struct inet_request_sock *ireq = inet_rsk(req);
 +
 +#if IS_ENABLED(CONFIG_IPV6)
 +	if (sk->sk_family == AF_INET6) {
 +		if (req->rsk_ops->family == AF_INET6) {
 +			entry->saddr = ireq->ir_v6_loc_addr.s6_addr32;
 +			entry->daddr = ireq->ir_v6_rmt_addr.s6_addr32;
 +		} else if (req->rsk_ops->family == AF_INET) {
 +			ipv6_addr_set_v4mapped(ireq->ir_loc_addr,
 +					       &entry->saddr_storage);
 +			ipv6_addr_set_v4mapped(ireq->ir_rmt_addr,
 +					       &entry->daddr_storage);
 +			entry->saddr = entry->saddr_storage.s6_addr32;
 +			entry->daddr = entry->daddr_storage.s6_addr32;
 +		}
 +	} else
 +#endif
 +	{
 +		entry->saddr = &ireq->ir_loc_addr;
 +		entry->daddr = &ireq->ir_rmt_addr;
 +	}
 +}
 +
++=======
++>>>>>>> a4458343ac59 (inet_diag: factorize code in new inet_diag_msg_common_fill() helper)
  static int inet_diag_fill_req(struct sk_buff *skb, struct sock *sk,
  			      struct request_sock *req,
  			      struct user_namespace *user_ns,
@@@ -762,42 -694,26 +796,57 @@@
  		return -EMSGSIZE;
  
  	r = nlmsg_data(nlh);
++<<<<<<< HEAD
 +	r->idiag_family = sk->sk_family;
++=======
+ 	inet_diag_msg_common_fill(r, (struct sock *)ireq);
++>>>>>>> a4458343ac59 (inet_diag: factorize code in new inet_diag_msg_common_fill() helper)
  	r->idiag_state = TCP_SYN_RECV;
  	r->idiag_timer = 1;
  	r->idiag_retrans = req->num_retrans;
  
++<<<<<<< HEAD
 +	r->id.idiag_if = sk->sk_bound_dev_if;
 +	sock_diag_save_cookie(req, r->id.idiag_cookie);
++=======
+ 	BUILD_BUG_ON(offsetof(struct inet_request_sock, ir_cookie) !=
+ 		     offsetof(struct sock, sk_cookie));
++>>>>>>> a4458343ac59 (inet_diag: factorize code in new inet_diag_msg_common_fill() helper)
  
  	tmo = req->expires - jiffies;
  	if (tmo < 0)
  		tmo = 0;
  
++<<<<<<< HEAD
 +	r->id.idiag_sport = inet->inet_sport;
 +	r->id.idiag_dport = ireq->ir_rmt_port;
 +
 +	memset(&r->id.idiag_src, 0, sizeof(r->id.idiag_src));
 +	memset(&r->id.idiag_dst, 0, sizeof(r->id.idiag_dst));
 +
 +	r->id.idiag_src[0] = ireq->ir_loc_addr;
 +	r->id.idiag_dst[0] = ireq->ir_rmt_addr;
 +
++=======
++>>>>>>> a4458343ac59 (inet_diag: factorize code in new inet_diag_msg_common_fill() helper)
  	r->idiag_expires = jiffies_to_msecs(tmo);
  	r->idiag_rqueue = 0;
  	r->idiag_wqueue = 0;
  	r->idiag_uid = from_kuid_munged(user_ns, sock_i_uid(sk));
  	r->idiag_inode = 0;
++<<<<<<< HEAD
 +#if IS_ENABLED(CONFIG_IPV6)
 +	if (r->idiag_family == AF_INET6) {
 +		struct inet_diag_entry entry;
 +		inet_diag_req_addrs(sk, req, &entry);
 +		memcpy(r->id.idiag_src, entry.saddr, sizeof(struct in6_addr));
 +		memcpy(r->id.idiag_dst, entry.daddr, sizeof(struct in6_addr));
 +	}
 +#endif
++=======
++>>>>>>> a4458343ac59 (inet_diag: factorize code in new inet_diag_msg_common_fill() helper)
  
 -	nlmsg_end(skb, nlh);
 -	return 0;
 +	return nlmsg_end(skb, nlh);
  }
  
  static int inet_diag_dump_reqs(struct sk_buff *skb, struct sock *sk,
* Unmerged path net/ipv4/inet_diag.c
