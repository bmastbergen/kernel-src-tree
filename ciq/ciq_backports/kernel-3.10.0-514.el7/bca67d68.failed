mei: always initialize the callback with the intended operation type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit bca67d681c4864b74fa5fae9ee47e562d1e272b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bca67d68.failed

We set the operation type at initialization time as each cb is used only
for a single type of operation

As a byproduct we add a convenient wrapper for allocating cb with
the data buffer.

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit bca67d681c4864b74fa5fae9ee47e562d1e272b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/amthif.c
#	drivers/misc/mei/bus.c
#	drivers/misc/mei/client.c
#	drivers/misc/mei/client.h
#	drivers/misc/mei/hbm.c
#	drivers/misc/mei/main.c
diff --cc drivers/misc/mei/amthif.c
index a11128c1997f,3fdd22395b9f..000000000000
--- a/drivers/misc/mei/amthif.c
+++ b/drivers/misc/mei/amthif.c
@@@ -257,23 -240,59 +257,63 @@@ out
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mei_amthif_read_start - queue message for sending read credential
+  *
+  * @cl: host client
+  * @file: file pointer of message recipient
+  *
+  * Return: 0 on success, <0 on failure.
+  */
+ static int mei_amthif_read_start(struct mei_cl *cl, struct file *file)
+ {
+ 	struct mei_device *dev = cl->dev;
+ 	struct mei_cl_cb *cb;
+ 	size_t length = dev->iamthif_mtu;
+ 	int rets;
+ 
+ 	cb = mei_io_cb_init(cl, MEI_FOP_READ, file);
+ 	if (!cb) {
+ 		rets = -ENOMEM;
+ 		goto err;
+ 	}
+ 
+ 	rets = mei_io_cb_alloc_buf(cb, length);
+ 	if (rets)
+ 		goto err;
+ 
+ 	list_add_tail(&cb->list, &dev->ctrl_wr_list.list);
+ 
+ 	dev->iamthif_state = MEI_IAMTHIF_READING;
+ 	dev->iamthif_file_object = cb->file_object;
+ 	dev->iamthif_current_cb = cb;
+ 
+ 	return 0;
+ err:
+ 	mei_io_cb_free(cb);
+ 	return rets;
+ }
+ 
+ /**
++>>>>>>> bca67d681c48 (mei: always initialize the callback with the intended operation type)
   * mei_amthif_send_cmd - send amthif command to the ME
   *
 - * @cl: the host client
 + * @dev: the device structure
   * @cb: mei call back struct
   *
 - * Return: 0 on success, <0 on failure.
 + * returns 0 on success, <0 on failure.
 + *
   */
 -static int mei_amthif_send_cmd(struct mei_cl *cl, struct mei_cl_cb *cb)
 +static int mei_amthif_send_cmd(struct mei_device *dev, struct mei_cl_cb *cb)
  {
 -	struct mei_device *dev;
 +	struct mei_msg_hdr mei_hdr;
  	int ret;
  
 -	if (!cl->dev || !cb)
 +	if (!dev || !cb)
  		return -ENODEV;
  
 -	dev = cl->dev;
 +	dev_dbg(&dev->pdev->dev, "write data to amthif client.\n");
  
  	dev->iamthif_state = MEI_IAMTHIF_WRITING;
  	dev->iamthif_current_cb = cb;
@@@ -327,76 -310,58 +367,81 @@@
  }
  
  /**
 - * mei_amthif_run_next_cmd - send next amt command from queue
 + * mei_amthif_write - write amthif data to amthif client
   *
   * @dev: the device structure
 + * @cb: mei call back struct
 + *
 + * returns 0 on success, <0 on failure.
   *
 - * Return: 0 on success, <0 on failure.
   */
 -int mei_amthif_run_next_cmd(struct mei_device *dev)
 +int mei_amthif_write(struct mei_device *dev, struct mei_cl_cb *cb)
  {
 -	struct mei_cl *cl = &dev->iamthif_cl;
 -	struct mei_cl_cb *cb;
 +	int ret;
  
 -	dev->iamthif_canceled = false;
 -	dev->iamthif_state = MEI_IAMTHIF_IDLE;
 -	dev->iamthif_timer = 0;
 -	dev->iamthif_file_object = NULL;
 +	if (!dev || !cb)
 +		return -ENODEV;
  
 -	dev_dbg(dev->dev, "complete amthif cmd_list cb.\n");
 +	ret = mei_io_cb_alloc_resp_buf(cb, dev->iamthif_mtu);
 +	if (ret)
 +		return ret;
  
 -	cb = list_first_entry_or_null(&dev->amthif_cmd_list.list,
 -					typeof(*cb), list);
 -	if (!cb)
 -		return 0;
++<<<<<<< HEAD
 +	cb->fop_type = MEI_FOP_WRITE;
  
 -	list_del_init(&cb->list);
 -	return mei_amthif_send_cmd(cl, cb);
 +	if (!list_empty(&dev->amthif_cmd_list.list) ||
 +	    dev->iamthif_state != MEI_IAMTHIF_IDLE) {
 +		dev_dbg(&dev->pdev->dev,
 +			"amthif state = %d\n", dev->iamthif_state);
 +		dev_dbg(&dev->pdev->dev, "AMTHIF: add cb to the wait list\n");
 +		list_add_tail(&cb->list, &dev->amthif_cmd_list.list);
 +		return 0;
 +	}
 +	return mei_amthif_send_cmd(dev, cb);
++=======
++	list_add_tail(&cb->list, &dev->amthif_cmd_list.list);
++	return mei_amthif_run_next_cmd(dev);
++>>>>>>> bca67d681c48 (mei: always initialize the callback with the intended operation type)
  }
 -
  /**
 - * mei_amthif_write - write amthif data to amthif client
 + * mei_amthif_run_next_cmd
   *
 - * @cl: host client
 - * @cb: mei call back struct
 + * @dev: the device structure
   *
 - * Return: 0 on success, <0 on failure.
 + * returns 0 on success, <0 on failure.
   */
 -int mei_amthif_write(struct mei_cl *cl, struct mei_cl_cb *cb)
 +void mei_amthif_run_next_cmd(struct mei_device *dev)
  {
 +	struct mei_cl_cb *cb;
 +	struct mei_cl_cb *next;
 +	int status;
  
 -	struct mei_device *dev;
 -
 -	if (WARN_ON(!cl || !cl->dev))
 -		return -ENODEV;
 +	if (!dev)
 +		return;
  
 -	if (WARN_ON(!cb))
 -		return -EINVAL;
 +	dev->iamthif_msg_buf_size = 0;
 +	dev->iamthif_msg_buf_index = 0;
 +	dev->iamthif_canceled = false;
 +	dev->iamthif_ioctl = true;
 +	dev->iamthif_state = MEI_IAMTHIF_IDLE;
 +	dev->iamthif_timer = 0;
 +	dev->iamthif_file_object = NULL;
  
 -	dev = cl->dev;
 +	dev_dbg(&dev->pdev->dev, "complete amthif cmd_list cb.\n");
  
 -	list_add_tail(&cb->list, &dev->amthif_cmd_list.list);
 -	return mei_amthif_run_next_cmd(dev);
 +	list_for_each_entry_safe(cb, next, &dev->amthif_cmd_list.list, list) {
 +		list_del(&cb->list);
 +		if (!cb->cl)
 +			continue;
 +		status = mei_amthif_send_cmd(dev, cb);
 +		if (status)
 +			dev_warn(&dev->pdev->dev, "amthif write failed status = %d\n",
 +						status);
 +		break;
 +	}
  }
  
 +
  unsigned int mei_amthif_poll(struct mei_device *dev,
  		struct file *file, poll_table *wait)
  {
diff --cc drivers/misc/mei/bus.c
index ca8736c3675b,3e6ffed9402a..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -238,30 -237,31 +238,40 @@@ static int ___mei_cl_send(struct mei_c
  
  	dev = cl->dev;
  
 -	mutex_lock(&dev->device_lock);
 -	if (cl->state != MEI_FILE_CONNECTED) {
 -		rets = -ENODEV;
 -		goto out;
 -	}
 +	if (cl->state != MEI_FILE_CONNECTED)
 +		return -ENODEV;
  
  	/* Check if we have an ME client device */
 -	me_cl = mei_me_cl_by_uuid_id(dev, &cl->cl_uuid, cl->me_client_id);
 -	if (!me_cl) {
 -		rets = -ENOTTY;
 -		goto out;
 -	}
 +	id = mei_me_cl_by_id(dev, cl->me_client_id);
 +	if (id < 0)
 +		return id;
  
 -	if (length > me_cl->props.max_msg_length) {
 -		rets = -EFBIG;
 -		goto out;
 +	if (length > dev->me_clients[id].props.max_msg_length)
 +		return -EINVAL;
 +
++<<<<<<< HEAD
 +	cb = mei_io_cb_init(cl, NULL);
 +	if (!cb)
 +		return -ENOMEM;
 +
 +	rets = mei_io_cb_alloc_req_buf(cb, length);
 +	if (rets < 0) {
 +		mei_io_cb_free(cb);
 +		return rets;
  	}
  
 +	memcpy(cb->request_buffer.data, buf, length);
 +
 +	mutex_lock(&dev->device_lock);
++=======
+ 	cb = mei_cl_alloc_cb(cl, length, MEI_FOP_WRITE, NULL);
+ 	if (!cb) {
+ 		rets = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	memcpy(cb->buf.data, buf, length);
++>>>>>>> bca67d681c48 (mei: always initialize the callback with the intended operation type)
  
  	rets = mei_cl_write(cl, cb, blocking);
  
@@@ -287,11 -289,9 +297,17 @@@ int __mei_cl_recv(struct mei_cl *cl, u
  	mutex_lock(&dev->device_lock);
  
  	if (!cl->read_cb) {
++<<<<<<< HEAD
 +		err = mei_cl_read_start(cl, length);
 +		if (err < 0) {
 +			mutex_unlock(&dev->device_lock);
 +			return err;
 +		}
++=======
+ 		rets = mei_cl_read_start(cl, length, NULL);
+ 		if (rets < 0)
+ 			goto out;
++>>>>>>> bca67d681c48 (mei: always initialize the callback with the intended operation type)
  	}
  
  	if (cl->reading_state != MEI_READ_COMPLETE &&
diff --cc drivers/misc/mei/client.c
index 3c539de435ba,57461016f1ff..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -152,12 -383,14 +152,18 @@@ void mei_io_cb_free(struct mei_cl_cb *c
  /**
   * mei_io_cb_init - allocate and initialize io callback
   *
++<<<<<<< HEAD
 + * @cl - mei client
++=======
+  * @cl: mei client
+  * @type: operation type
++>>>>>>> bca67d681c48 (mei: always initialize the callback with the intended operation type)
   * @fp: pointer to file structure
   *
 - * Return: mei_cl_cb pointer or NULL;
 + * returns mei_cl_cb pointer or NULL;
   */
- struct mei_cl_cb *mei_io_cb_init(struct mei_cl *cl, struct file *fp)
+ struct mei_cl_cb *mei_io_cb_init(struct mei_cl *cl, enum mei_cb_file_ops type,
+ 				 struct file *fp)
  {
  	struct mei_cl_cb *cb;
  
@@@ -222,8 -432,33 +229,35 @@@ int mei_io_cb_alloc_resp_buf(struct mei
  	return 0;
  }
  
 +
 +
+ /**
+  * mei_cl_alloc_cb - a convenient wrapper for allocating read cb
+  *
+  * @cl: host client
+  * @length: size of the buffer
+  * @type: operation type
+  * @fp: associated file pointer (might be NULL)
+  *
+  * Return: cb on success and NULL on failure
+  */
+ struct mei_cl_cb *mei_cl_alloc_cb(struct mei_cl *cl, size_t length,
+ 				  enum mei_cb_file_ops type, struct file *fp)
+ {
+ 	struct mei_cl_cb *cb;
+ 
+ 	cb = mei_io_cb_init(cl, type, fp);
+ 	if (!cb)
+ 		return NULL;
+ 
+ 	if (mei_io_cb_alloc_buf(cb, length)) {
+ 		mei_io_cb_free(cb);
+ 		return NULL;
+ 	}
+ 
+ 	return cb;
+ }
+ 
  /**
   * mei_cl_flush_queues - flushes queue lists belonging to cl.
   *
@@@ -720,10 -957,12 +748,15 @@@ int mei_cl_flow_ctrl_reduce(struct mei_
   * mei_cl_read_start - the start read client message function.
   *
   * @cl: host client
++<<<<<<< HEAD
++=======
+  * @length: number of bytes to read
+  * @fp: pointer to file structure
++>>>>>>> bca67d681c48 (mei: always initialize the callback with the intended operation type)
   *
 - * Return: 0 on success, <0 on failure.
 + * returns 0 on success, <0 on failure.
   */
- int mei_cl_read_start(struct mei_cl *cl, size_t length)
+ int mei_cl_read_start(struct mei_cl *cl, size_t length, struct file *fp)
  {
  	struct mei_device *dev;
  	struct mei_cl_cb *cb;
@@@ -755,24 -997,15 +788,28 @@@
  		return rets;
  	}
  
++<<<<<<< HEAD
 +	cb = mei_io_cb_init(cl, NULL);
 +	if (!cb) {
 +		rets = -ENOMEM;
 +		goto out;
 +	}
 +
 +	/* always allocate at least client max message */
 +	length = max_t(size_t, length, dev->me_clients[i].props.max_msg_length);
 +	rets = mei_io_cb_alloc_resp_buf(cb, length);
++=======
+ 	cb = mei_cl_alloc_cb(cl, length, MEI_FOP_READ, fp);
+ 	rets = cb ? 0 : -ENOMEM;
++>>>>>>> bca67d681c48 (mei: always initialize the callback with the intended operation type)
  	if (rets)
  		goto out;
  
- 	cb->fop_type = MEI_FOP_READ;
  	if (mei_hbuf_acquire(dev)) {
 -		rets = mei_hbm_cl_flow_control_req(dev, cl);
 -		if (rets < 0)
 +		if (mei_hbm_cl_flow_control_req(dev, cl)) {
 +			rets = -ENODEV;
  			goto out;
 +		}
  
  		list_add_tail(&cb->list, &dev->read_list.list);
  	} else {
diff --cc drivers/misc/mei/client.h
index bf2b0b1b493d,f7d0285b5f57..000000000000
--- a/drivers/misc/mei/client.h
+++ b/drivers/misc/mei/client.h
@@@ -30,10 -47,10 +30,11 @@@ int mei_me_cl_by_id(struct mei_device *
  /*
   * MEI IO Functions
   */
- struct mei_cl_cb *mei_io_cb_init(struct mei_cl *cl, struct file *fp);
+ struct mei_cl_cb *mei_io_cb_init(struct mei_cl *cl, enum mei_cb_file_ops type,
+ 				 struct file *fp);
  void mei_io_cb_free(struct mei_cl_cb *priv_cb);
 -int mei_io_cb_alloc_buf(struct mei_cl_cb *cb, size_t length);
 +int mei_io_cb_alloc_req_buf(struct mei_cl_cb *cb, size_t length);
 +int mei_io_cb_alloc_resp_buf(struct mei_cl_cb *cb, size_t length);
  
  
  /**
@@@ -84,7 -103,9 +87,13 @@@ static inline bool mei_cl_is_transition
  bool mei_cl_is_other_connecting(struct mei_cl *cl);
  int mei_cl_disconnect(struct mei_cl *cl);
  int mei_cl_connect(struct mei_cl *cl, struct file *file);
++<<<<<<< HEAD
 +int mei_cl_read_start(struct mei_cl *cl, size_t length);
++=======
+ int mei_cl_read_start(struct mei_cl *cl, size_t length, struct file *fp);
+ int mei_cl_irq_read_msg(struct mei_cl *cl, struct mei_msg_hdr *hdr,
+ 			struct mei_cl_cb *cmpl_list);
++>>>>>>> bca67d681c48 (mei: always initialize the callback with the intended operation type)
  int mei_cl_write(struct mei_cl *cl, struct mei_cl_cb *cb, bool blocking);
  int mei_cl_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,
  		     struct mei_cl_cb *cmpl_list);
diff --cc drivers/misc/mei/hbm.c
index 3cb8e1000d69,2c581dcaf3b1..000000000000
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@@ -636,23 -678,17 +636,31 @@@ static int mei_hbm_fw_disconnect_req(st
  	struct mei_cl *cl;
  	struct mei_cl_cb *cb;
  
 -	cl = mei_hbm_cl_find_by_cmd(dev, disconnect_req);
 -	if (cl) {
 -		cl_dbg(dev, cl, "disconnect request received\n");
 -		cl->state = MEI_FILE_DISCONNECTED;
 -		cl->timer_count = 0;
 +	list_for_each_entry(cl, &dev->file_list, link) {
 +		if (mei_hbm_cl_addr_equal(cl, disconnect_req)) {
 +			dev_dbg(&dev->pdev->dev, "disconnect request host client %d ME client %d.\n",
 +					disconnect_req->host_addr,
 +					disconnect_req->me_addr);
 +			cl->state = MEI_FILE_DISCONNECTED;
 +			cl->timer_count = 0;
 +
++<<<<<<< HEAD
 +			cb = mei_io_cb_init(cl, NULL);
 +			if (!cb)
 +				return -ENOMEM;
 +			cb->fop_type = MEI_FOP_DISCONNECT_RSP;
 +			cl_dbg(dev, cl, "add disconnect response as first\n");
 +			list_add(&cb->list, &dev->ctrl_wr_list.list);
  
 +			break;
 +		}
++=======
+ 		cb = mei_io_cb_init(cl, MEI_FOP_DISCONNECT_RSP, NULL);
+ 		if (!cb)
+ 			return -ENOMEM;
+ 		cl_dbg(dev, cl, "add disconnect response as first\n");
+ 		list_add(&cb->list, &dev->ctrl_wr_list.list);
++>>>>>>> bca67d681c48 (mei: always initialize the callback with the intended operation type)
  	}
  	return 0;
  }
diff --cc drivers/misc/mei/main.c
index b23f9eba9e3a,369de0a070f1..000000000000
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@@ -232,9 -209,9 +232,9 @@@ static ssize_t mei_read(struct file *fi
  		*offset = 0;
  	}
  
- 	err = mei_cl_read_start(cl, length);
+ 	err = mei_cl_read_start(cl, length, file);
  	if (err && err != -EBUSY) {
 -		dev_dbg(dev->dev,
 +		dev_dbg(&dev->pdev->dev,
  			"mei start read failure with status = %d\n", err);
  		rets = err;
  		goto out;
@@@ -403,13 -388,10 +402,16 @@@ static ssize_t mei_write(struct file *f
  		rets = -ENOMEM;
  		goto out;
  	}
++<<<<<<< HEAD
 +	rets = mei_io_cb_alloc_req_buf(write_cb, length);
 +	if (rets)
 +		goto out;
++=======
++>>>>>>> bca67d681c48 (mei: always initialize the callback with the intended operation type)
  
 -	rets = copy_from_user(write_cb->buf.data, ubuf, length);
 +	rets = copy_from_user(write_cb->request_buffer.data, ubuf, length);
  	if (rets) {
 -		dev_dbg(dev->dev, "failed to copy data from userland\n");
 +		dev_dbg(&dev->pdev->dev, "failed to copy data from userland\n");
  		rets = -EFAULT;
  		goto out;
  	}
* Unmerged path drivers/misc/mei/amthif.c
* Unmerged path drivers/misc/mei/bus.c
* Unmerged path drivers/misc/mei/client.c
* Unmerged path drivers/misc/mei/client.h
* Unmerged path drivers/misc/mei/hbm.c
* Unmerged path drivers/misc/mei/main.c
