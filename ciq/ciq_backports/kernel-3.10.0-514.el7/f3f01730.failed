hpsa: add function is_logical_device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Kevin Barnett <kevin.barnett@pmcs.com>
commit f3f017305d4da61b64098f3d89cb64563c95087a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f3f01730.failed

simplify checking for logical/physical devices

	Reviewed-by: Scott Teel <scott.teel@pmcs.com>
	Reviewed-by: Justin Lindley <justin.lindley@pmcs.com>
	Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Reviewed-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Don Brace <don.brace@pmcs.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit f3f017305d4da61b64098f3d89cb64563c95087a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.c
diff --cc drivers/scsi/hpsa.c
index e6b21f6ebf7d,21892c155b01..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -732,6 -731,99 +737,102 @@@ static ssize_t host_show_hp_ssd_smart_p
  	return snprintf(buf, 20, "%d\n", offload_enabled);
  }
  
++<<<<<<< HEAD
++=======
+ #define MAX_PATHS 8
+ #define PATH_STRING_LEN 50
+ 
+ static ssize_t path_info_show(struct device *dev,
+ 	     struct device_attribute *attr, char *buf)
+ {
+ 	struct ctlr_info *h;
+ 	struct scsi_device *sdev;
+ 	struct hpsa_scsi_dev_t *hdev;
+ 	unsigned long flags;
+ 	int i;
+ 	int output_len = 0;
+ 	u8 box;
+ 	u8 bay;
+ 	u8 path_map_index = 0;
+ 	char *active;
+ 	unsigned char phys_connector[2];
+ 	unsigned char path[MAX_PATHS][PATH_STRING_LEN];
+ 
+ 	memset(path, 0, MAX_PATHS * PATH_STRING_LEN);
+ 	sdev = to_scsi_device(dev);
+ 	h = sdev_to_hba(sdev);
+ 	spin_lock_irqsave(&h->devlock, flags);
+ 	hdev = sdev->hostdata;
+ 	if (!hdev) {
+ 		spin_unlock_irqrestore(&h->devlock, flags);
+ 		return -ENODEV;
+ 	}
+ 
+ 	bay = hdev->bay;
+ 	for (i = 0; i < MAX_PATHS; i++) {
+ 		path_map_index = 1<<i;
+ 		if (i == hdev->active_path_index)
+ 			active = "Active";
+ 		else if (hdev->path_map & path_map_index)
+ 			active = "Inactive";
+ 		else
+ 			continue;
+ 
+ 		output_len = snprintf(path[i],
+ 				PATH_STRING_LEN, "[%d:%d:%d:%d] %20.20s ",
+ 				h->scsi_host->host_no,
+ 				hdev->bus, hdev->target, hdev->lun,
+ 				scsi_device_type(hdev->devtype));
+ 
+ 		if (is_ext_target(h, hdev) ||
+ 			hdev->devtype == TYPE_RAID ||
+ 			is_logical_device(hdev)) {
+ 			output_len += snprintf(path[i] + output_len,
+ 						PATH_STRING_LEN, "%s\n",
+ 						active);
+ 			continue;
+ 		}
+ 
+ 		box = hdev->box[i];
+ 		memcpy(&phys_connector, &hdev->phys_connector[i],
+ 			sizeof(phys_connector));
+ 		if (phys_connector[0] < '0')
+ 			phys_connector[0] = '0';
+ 		if (phys_connector[1] < '0')
+ 			phys_connector[1] = '0';
+ 		if (hdev->phys_connector[i] > 0)
+ 			output_len += snprintf(path[i] + output_len,
+ 				PATH_STRING_LEN,
+ 				"PORT: %.2s ",
+ 				phys_connector);
+ 		if (hdev->devtype == TYPE_DISK && hdev->expose_device) {
+ 			if (box == 0 || box == 0xFF) {
+ 				output_len += snprintf(path[i] + output_len,
+ 					PATH_STRING_LEN,
+ 					"BAY: %hhu %s\n",
+ 					bay, active);
+ 			} else {
+ 				output_len += snprintf(path[i] + output_len,
+ 					PATH_STRING_LEN,
+ 					"BOX: %hhu BAY: %hhu %s\n",
+ 					box, bay, active);
+ 			}
+ 		} else if (box != 0 && box != 0xFF) {
+ 			output_len += snprintf(path[i] + output_len,
+ 				PATH_STRING_LEN, "BOX: %hhu %s\n",
+ 				box, active);
+ 		} else
+ 			output_len += snprintf(path[i] + output_len,
+ 				PATH_STRING_LEN, "%s\n", active);
+ 	}
+ 
+ 	spin_unlock_irqrestore(&h->devlock, flags);
+ 	return snprintf(buf, output_len+1, "%s%s%s%s%s%s%s%s",
+ 		path[0], path[1], path[2], path[3],
+ 		path[4], path[5], path[6], path[7]);
+ }
+ 
++>>>>>>> f3f017305d4d (hpsa: add function is_logical_device)
  static DEVICE_ATTR(raid_level, S_IRUGO, raid_level_show, NULL);
  static DEVICE_ATTR(lunid, S_IRUGO, lunid_show, NULL);
  static DEVICE_ATTR(unique_id, S_IRUGO, unique_id_show, NULL);
* Unmerged path drivers/scsi/hpsa.c
