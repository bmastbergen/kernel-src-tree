i40e: Limit the number of MAC and VLAN addresses that can be added for VFs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Anjali Singhai Jain <anjali.singhai@intel.com>
commit 5f527ba962e277963b08f4c7f12fbeeac3f34e3c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5f527ba9.failed

If the VF is privileged/trusted it can do as it may please including
but not limited to hogging resources and playing unfair.
But if the VF is not privileged/trusted it still can add some number
(8) of MAC and VLAN addresses.
Other restrictions with respect to Port VLAN and normal VLAN still apply
to not privileged/trusted VF.

Change-Id: I3a9529201b184c8873e1ad2e300aff468c9e6296
	Signed-off-by: Anjali Singhai Jain <anjali.singhai@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 5f527ba962e277963b08f4c7f12fbeeac3f34e3c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index d901afb6a12a,a8a65e030611..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -1561,8 -1865,13 +1565,13 @@@ static inline int i40e_check_vf_permiss
  		 * assigned to it so do not return an error in that case.
  		 */
  		dev_err(&pf->pdev->dev,
 -			"VF attempting to override administratively set MAC address, reload the VF driver to resume normal operation\n");
 +			"VF attempting to override administratively set MAC address\nPlease reload the VF driver to resume normal operation\n");
  		ret = -EPERM;
+ 	} else if ((vf->num_mac >= I40E_VC_MAX_MAC_ADDR_PER_VF) &&
+ 		   !test_bit(I40E_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps)) {
+ 		dev_err(&pf->pdev->dev,
+ 			"VF is not trusted, switch the VF to trusted to add more functionality\n");
+ 		ret = -EPERM;
  	}
  	return ret;
  }
@@@ -1738,10 -2059,24 +1756,27 @@@ static int i40e_vc_add_vlan_msg(struct 
  	for (i = 0; i < vfl->num_elements; i++) {
  		/* add new VLAN filter */
  		int ret = i40e_vsi_add_vlan(vsi, vfl->vlan_id[i]);
++<<<<<<< HEAD
++=======
+ 		if (!ret)
+ 			vf->num_vlan++;
+ 
+ 		if (test_bit(I40E_VF_STAT_UC_PROMISC, &vf->vf_states))
+ 			i40e_aq_set_vsi_uc_promisc_on_vlan(&pf->hw, vsi->seid,
+ 							   true,
+ 							   vfl->vlan_id[i],
+ 							   NULL);
+ 		if (test_bit(I40E_VF_STAT_MC_PROMISC, &vf->vf_states))
+ 			i40e_aq_set_vsi_mc_promisc_on_vlan(&pf->hw, vsi->seid,
+ 							   true,
+ 							   vfl->vlan_id[i],
+ 							   NULL);
+ 
++>>>>>>> 5f527ba962e2 (i40e: Limit the number of MAC and VLAN addresses that can be added for VFs)
  		if (ret)
  			dev_err(&pf->pdev->dev,
 -				"Unable to add VLAN filter %d for VF %d, error %d\n",
 -				vfl->vlan_id[i], vf->vf_id, ret);
 +				"Unable to add VF vlan filter %d, error %d\n",
 +				vfl->vlan_id[i], ret);
  	}
  
  error_param:
@@@ -1789,10 -2123,24 +1823,27 @@@ static int i40e_vc_remove_vlan_msg(stru
  
  	for (i = 0; i < vfl->num_elements; i++) {
  		int ret = i40e_vsi_kill_vlan(vsi, vfl->vlan_id[i]);
++<<<<<<< HEAD
++=======
+ 		if (!ret)
+ 			vf->num_vlan--;
+ 
+ 		if (test_bit(I40E_VF_STAT_UC_PROMISC, &vf->vf_states))
+ 			i40e_aq_set_vsi_uc_promisc_on_vlan(&pf->hw, vsi->seid,
+ 							   false,
+ 							   vfl->vlan_id[i],
+ 							   NULL);
+ 		if (test_bit(I40E_VF_STAT_MC_PROMISC, &vf->vf_states))
+ 			i40e_aq_set_vsi_mc_promisc_on_vlan(&pf->hw, vsi->seid,
+ 							   false,
+ 							   vfl->vlan_id[i],
+ 							   NULL);
+ 
++>>>>>>> 5f527ba962e2 (i40e: Limit the number of MAC and VLAN addresses that can be added for VFs)
  		if (ret)
  			dev_err(&pf->pdev->dev,
 -				"Unable to delete VLAN filter %d for VF %d, error %d\n",
 -				vfl->vlan_id[i], vf->vf_id, ret);
 +				"Unable to delete VF vlan filter %d, error %d\n",
 +				vfl->vlan_id[i], ret);
  	}
  
  error_param:
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
index 0e0c46595393,bf54873d9c04..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
@@@ -107,6 -111,11 +107,14 @@@ struct i40e_vf 
  	bool link_forced;
  	bool link_up;		/* only valid if VF link is forced */
  	bool spoofchk;
++<<<<<<< HEAD
++=======
+ 	u16 num_mac;
+ 	u16 num_vlan;
+ 
+ 	/* RDMA Client */
+ 	struct i40e_virtchnl_iwarp_qvlist_info *qvlist_info;
++>>>>>>> 5f527ba962e2 (i40e: Limit the number of MAC and VLAN addresses that can be added for VFs)
  };
  
  void i40e_free_vfs(struct i40e_pf *pf);
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
