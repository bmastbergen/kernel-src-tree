netfilter: nf_tables: prepare for expressions associated to set elements

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Patrick McHardy <kaber@trash.net>
commit f25ad2e907f110378159fe5e088aa13176faaa5b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f25ad2e9.failed

Preparation to attach expressions to set elements: add a set extension
type to hold an expression and dump the expression information with the
set element.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit f25ad2e907f110378159fe5e088aa13176faaa5b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables.h
#	include/uapi/linux/netfilter/nf_tables.h
#	net/netfilter/nf_tables_api.c
diff --cc include/net/netfilter/nf_tables.h
index fe3f11dfb297,d45a871b3da6..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -328,12 -368,20 +328,26 @@@ void nf_tables_unbind_set(const struct 
   *	@NFT_SET_EXT_KEY: element key
   *	@NFT_SET_EXT_DATA: mapping data
   *	@NFT_SET_EXT_FLAGS: element flags
++<<<<<<< HEAD
++=======
+  *	@NFT_SET_EXT_TIMEOUT: element timeout
+  *	@NFT_SET_EXT_EXPIRATION: element expiration time
+  *	@NFT_SET_EXT_USERDATA: user data associated with the element
+  *	@NFT_SET_EXT_EXPR: expression assiociated with the element
++>>>>>>> f25ad2e907f1 (netfilter: nf_tables: prepare for expressions associated to set elements)
   *	@NFT_SET_EXT_NUM: number of extension types
   */
  enum nft_set_extensions {
  	NFT_SET_EXT_KEY,
  	NFT_SET_EXT_DATA,
  	NFT_SET_EXT_FLAGS,
++<<<<<<< HEAD
++=======
+ 	NFT_SET_EXT_TIMEOUT,
+ 	NFT_SET_EXT_EXPIRATION,
+ 	NFT_SET_EXT_USERDATA,
+ 	NFT_SET_EXT_EXPR,
++>>>>>>> f25ad2e907f1 (netfilter: nf_tables: prepare for expressions associated to set elements)
  	NFT_SET_EXT_NUM
  };
  
@@@ -428,6 -478,44 +442,47 @@@ static inline u8 *nft_set_ext_flags(con
  	return nft_set_ext(ext, NFT_SET_EXT_FLAGS);
  }
  
++<<<<<<< HEAD
++=======
+ static inline u64 *nft_set_ext_timeout(const struct nft_set_ext *ext)
+ {
+ 	return nft_set_ext(ext, NFT_SET_EXT_TIMEOUT);
+ }
+ 
+ static inline unsigned long *nft_set_ext_expiration(const struct nft_set_ext *ext)
+ {
+ 	return nft_set_ext(ext, NFT_SET_EXT_EXPIRATION);
+ }
+ 
+ static inline struct nft_userdata *nft_set_ext_userdata(const struct nft_set_ext *ext)
+ {
+ 	return nft_set_ext(ext, NFT_SET_EXT_USERDATA);
+ }
+ 
+ static inline struct nft_expr *nft_set_ext_expr(const struct nft_set_ext *ext)
+ {
+ 	return nft_set_ext(ext, NFT_SET_EXT_EXPR);
+ }
+ 
+ static inline bool nft_set_elem_expired(const struct nft_set_ext *ext)
+ {
+ 	return nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION) &&
+ 	       time_is_before_eq_jiffies(*nft_set_ext_expiration(ext));
+ }
+ 
+ static inline struct nft_set_ext *nft_set_elem_ext(const struct nft_set *set,
+ 						   void *elem)
+ {
+ 	return elem + set->ops->elemsize;
+ }
+ 
+ void *nft_set_elem_init(const struct nft_set *set,
+ 			const struct nft_set_ext_tmpl *tmpl,
+ 			const u32 *key, const u32 *data,
+ 			u64 timeout, gfp_t gfp);
+ void nft_set_elem_destroy(const struct nft_set *set, void *elem);
+ 
++>>>>>>> f25ad2e907f1 (netfilter: nf_tables: prepare for expressions associated to set elements)
  /**
   *	struct nft_set_gc_batch_head - nf_tables set garbage collection batch
   *
diff --cc include/uapi/linux/netfilter/nf_tables.h
index 971d245e7378,f9c5af22a6af..000000000000
--- a/include/uapi/linux/netfilter/nf_tables.h
+++ b/include/uapi/linux/netfilter/nf_tables.h
@@@ -290,12 -319,20 +290,26 @@@ enum nft_set_elem_flags 
   * @NFTA_SET_ELEM_KEY: key value (NLA_NESTED: nft_data)
   * @NFTA_SET_ELEM_DATA: data value of mapping (NLA_NESTED: nft_data_attributes)
   * @NFTA_SET_ELEM_FLAGS: bitmask of nft_set_elem_flags (NLA_U32)
++<<<<<<< HEAD
++=======
+  * @NFTA_SET_ELEM_TIMEOUT: timeout value (NLA_U64)
+  * @NFTA_SET_ELEM_EXPIRATION: expiration time (NLA_U64)
+  * @NFTA_SET_ELEM_USERDATA: user data (NLA_BINARY)
+  * @NFTA_SET_ELEM_EXPR: expression (NLA_NESTED: nft_expr_attributes)
++>>>>>>> f25ad2e907f1 (netfilter: nf_tables: prepare for expressions associated to set elements)
   */
  enum nft_set_elem_attributes {
  	NFTA_SET_ELEM_UNSPEC,
  	NFTA_SET_ELEM_KEY,
  	NFTA_SET_ELEM_DATA,
  	NFTA_SET_ELEM_FLAGS,
++<<<<<<< HEAD
++=======
+ 	NFTA_SET_ELEM_TIMEOUT,
+ 	NFTA_SET_ELEM_EXPIRATION,
+ 	NFTA_SET_ELEM_USERDATA,
+ 	NFTA_SET_ELEM_EXPR,
++>>>>>>> f25ad2e907f1 (netfilter: nf_tables: prepare for expressions associated to set elements)
  	__NFTA_SET_ELEM_MAX
  };
  #define NFTA_SET_ELEM_MAX	(__NFTA_SET_ELEM_MAX - 1)
diff --cc net/netfilter/nf_tables_api.c
index cb98882ec65a,8830811550ec..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -2893,13 -2899,14 +2893,16 @@@ void nf_tables_unbind_set(const struct 
  
  const struct nft_set_ext_type nft_set_ext_types[] = {
  	[NFT_SET_EXT_KEY]		= {
 -		.align	= __alignof__(u32),
 +		.len	= sizeof(struct nft_data),
 +		.align	= __alignof__(struct nft_data),
  	},
  	[NFT_SET_EXT_DATA]		= {
 -		.align	= __alignof__(u32),
 +		.len	= sizeof(struct nft_data),
 +		.align	= __alignof__(struct nft_data),
  	},
+ 	[NFT_SET_EXT_EXPR]		= {
+ 		.align	= __alignof__(struct nft_expr),
+ 	},
  	[NFT_SET_EXT_FLAGS]		= {
  		.len	= sizeof(u8),
  		.align	= __alignof__(u8),
@@@ -2971,9 -2993,42 +2974,37 @@@ static int nf_tables_fill_setelem(struc
  			  set->dlen) < 0)
  		goto nla_put_failure;
  
++<<<<<<< HEAD
 +	if (elem->flags != 0)
 +		if (nla_put_be32(skb, NFTA_SET_ELEM_FLAGS, htonl(elem->flags)))
++=======
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_EXPR) &&
+ 	    nft_expr_dump(skb, NFTA_SET_ELEM_EXPR, nft_set_ext_expr(ext)) < 0)
+ 		goto nla_put_failure;
+ 
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_FLAGS) &&
+ 	    nla_put_be32(skb, NFTA_SET_ELEM_FLAGS,
+ 		         htonl(*nft_set_ext_flags(ext))))
+ 		goto nla_put_failure;
+ 
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_TIMEOUT) &&
+ 	    nla_put_be64(skb, NFTA_SET_ELEM_TIMEOUT,
+ 			 cpu_to_be64(*nft_set_ext_timeout(ext))))
+ 		goto nla_put_failure;
+ 
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) {
+ 		unsigned long expires, now = jiffies;
+ 
+ 		expires = *nft_set_ext_expiration(ext);
+ 		if (time_before(now, expires))
+ 			expires -= now;
+ 		else
+ 			expires = 0;
+ 
+ 		if (nla_put_be64(skb, NFTA_SET_ELEM_EXPIRATION,
+ 				 cpu_to_be64(jiffies_to_msecs(expires))))
++>>>>>>> f25ad2e907f1 (netfilter: nf_tables: prepare for expressions associated to set elements)
  			goto nla_put_failure;
 -	}
 -
 -	if (nft_set_ext_exists(ext, NFT_SET_EXT_USERDATA)) {
 -		struct nft_userdata *udata;
 -
 -		udata = nft_set_ext_userdata(ext);
 -		if (nla_put(skb, NFTA_SET_ELEM_USERDATA,
 -			    udata->len + 1, udata->data))
 -			goto nla_put_failure;
 -	}
  
  	nla_nest_end(skb, nest);
  	return 0;
@@@ -3193,6 -3249,47 +3224,50 @@@ static struct nft_trans *nft_trans_elem
  	return trans;
  }
  
++<<<<<<< HEAD
++=======
+ void *nft_set_elem_init(const struct nft_set *set,
+ 			const struct nft_set_ext_tmpl *tmpl,
+ 			const u32 *key, const u32 *data,
+ 			u64 timeout, gfp_t gfp)
+ {
+ 	struct nft_set_ext *ext;
+ 	void *elem;
+ 
+ 	elem = kzalloc(set->ops->elemsize + tmpl->len, gfp);
+ 	if (elem == NULL)
+ 		return NULL;
+ 
+ 	ext = nft_set_elem_ext(set, elem);
+ 	nft_set_ext_init(ext, tmpl);
+ 
+ 	memcpy(nft_set_ext_key(ext), key, set->klen);
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
+ 		memcpy(nft_set_ext_data(ext), data, set->dlen);
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION))
+ 		*nft_set_ext_expiration(ext) =
+ 			jiffies + msecs_to_jiffies(timeout);
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_TIMEOUT))
+ 		*nft_set_ext_timeout(ext) = timeout;
+ 
+ 	return elem;
+ }
+ 
+ void nft_set_elem_destroy(const struct nft_set *set, void *elem)
+ {
+ 	struct nft_set_ext *ext = nft_set_elem_ext(set, elem);
+ 
+ 	nft_data_uninit(nft_set_ext_key(ext), NFT_DATA_VALUE);
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
+ 		nft_data_uninit(nft_set_ext_data(ext), set->dtype);
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_EXPR))
+ 		nf_tables_expr_destroy(NULL, nft_set_ext_expr(ext));
+ 
+ 	kfree(elem);
+ }
+ EXPORT_SYMBOL_GPL(nft_set_elem_destroy);
+ 
++>>>>>>> f25ad2e907f1 (netfilter: nf_tables: prepare for expressions associated to set elements)
  static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,
  			    const struct nlattr *attr)
  {
* Unmerged path include/net/netfilter/nf_tables.h
* Unmerged path include/uapi/linux/netfilter/nf_tables.h
* Unmerged path net/netfilter/nf_tables_api.c
