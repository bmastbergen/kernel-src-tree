ixgbe: Add support for x550em_a 10G MAC type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mark Rustad <mark.d.rustad@intel.com>
commit 49425dfc74512bef9cf15eafb5de0fc98f024e20
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/49425dfc.failed

Add support for x550em_a 10G MAC type to the ixgbe driver. The new
MAC includes new firmware commands that need to be used to control
PHY and IOSF access, so that support is also added. The interface
supported is a native SFP+ interface.

	Signed-off-by: Mark Rustad <mark.d.rustad@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 49425dfc74512bef9cf15eafb5de0fc98f024e20)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe.h
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
#	drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c
#	drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe.h
index f553a1b87d29,d10ed62993c1..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
@@@ -863,13 -861,15 +864,23 @@@ enum ixgbe_boards 
  	board_X540,
  	board_X550,
  	board_X550EM_x,
+ 	board_x550em_a,
  };
  
++<<<<<<< HEAD
 +extern struct ixgbe_info ixgbe_82598_info;
 +extern struct ixgbe_info ixgbe_82599_info;
 +extern struct ixgbe_info ixgbe_X540_info;
 +extern struct ixgbe_info ixgbe_X550_info;
 +extern struct ixgbe_info ixgbe_X550EM_x_info;
++=======
+ extern const struct ixgbe_info ixgbe_82598_info;
+ extern const struct ixgbe_info ixgbe_82599_info;
+ extern const struct ixgbe_info ixgbe_X540_info;
+ extern const struct ixgbe_info ixgbe_X550_info;
+ extern const struct ixgbe_info ixgbe_X550EM_x_info;
+ extern const struct ixgbe_info ixgbe_x550em_a_info;
++>>>>>>> 49425dfc7451 (ixgbe: Add support for x550em_a 10G MAC type)
  #ifdef CONFIG_IXGBE_DCB
  extern const struct dcbnl_rtnl_ops dcbnl_ops;
  #endif
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index c49a5686fdd6,eb93319337a1..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -74,10 -70,10 +74,14 @@@ char ixgbe_default_device_descr[] 
  static char ixgbe_default_device_descr[] =
  			      "Intel(R) 10 Gigabit Network Connection";
  #endif
 -#define DRV_VERSION "4.2.1-k"
 +#define DRV_VERSION "4.0.1-k-rh7.2"
  const char ixgbe_driver_version[] = DRV_VERSION;
  static const char ixgbe_copyright[] =
++<<<<<<< HEAD
 +				"Copyright (c) 1999-2014 Intel Corporation.";
++=======
+ 				"Copyright (c) 1999-2016 Intel Corporation.";
++>>>>>>> 49425dfc7451 (ixgbe: Add support for x550em_a 10G MAC type)
  
  static const char ixgbe_overheat_msg[] = "Network adapter has been stopped because it has over heated. Restart the computer. If the problem persists, power off the system and replace the adapter";
  
@@@ -3944,8 -4037,13 +3964,9 @@@ static void ixgbe_vlan_strip_disable(st
  	case ixgbe_mac_X540:
  	case ixgbe_mac_X550:
  	case ixgbe_mac_X550EM_x:
+ 	case ixgbe_mac_x550em_a:
  		for (i = 0; i < adapter->num_rx_queues; i++) {
 -			struct ixgbe_ring *ring = adapter->rx_ring[i];
 -
 -			if (ring->l2_accel_priv)
 -				continue;
 -			j = ring->reg_idx;
 +			j = adapter->rx_ring[i]->reg_idx;
  			vlnctrl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(j));
  			vlnctrl &= ~IXGBE_RXDCTL_VME;
  			IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(j), vlnctrl);
@@@ -3976,8 -4074,13 +3997,9 @@@ static void ixgbe_vlan_strip_enable(str
  	case ixgbe_mac_X540:
  	case ixgbe_mac_X550:
  	case ixgbe_mac_X550EM_x:
+ 	case ixgbe_mac_x550em_a:
  		for (i = 0; i < adapter->num_rx_queues; i++) {
 -			struct ixgbe_ring *ring = adapter->rx_ring[i];
 -
 -			if (ring->l2_accel_priv)
 -				continue;
 -			j = ring->reg_idx;
 +			j = adapter->rx_ring[i]->reg_idx;
  			vlnctrl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(j));
  			vlnctrl |= IXGBE_RXDCTL_VME;
  			IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(j), vlnctrl);
@@@ -3988,6 -4091,131 +4010,134 @@@
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void ixgbe_vlan_promisc_enable(struct ixgbe_adapter *adapter)
+ {
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	u32 vlnctrl, i;
+ 
+ 	switch (hw->mac.type) {
+ 	case ixgbe_mac_82599EB:
+ 	case ixgbe_mac_X540:
+ 	case ixgbe_mac_X550:
+ 	case ixgbe_mac_X550EM_x:
+ 	case ixgbe_mac_x550em_a:
+ 	default:
+ 		if (adapter->flags & IXGBE_FLAG_VMDQ_ENABLED)
+ 			break;
+ 		/* fall through */
+ 	case ixgbe_mac_82598EB:
+ 		/* legacy case, we can just disable VLAN filtering */
+ 		vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);
+ 		vlnctrl &= ~(IXGBE_VLNCTRL_VFE | IXGBE_VLNCTRL_CFIEN);
+ 		IXGBE_WRITE_REG(hw, IXGBE_VLNCTRL, vlnctrl);
+ 		return;
+ 	}
+ 
+ 	/* We are already in VLAN promisc, nothing to do */
+ 	if (adapter->flags2 & IXGBE_FLAG2_VLAN_PROMISC)
+ 		return;
+ 
+ 	/* Set flag so we don't redo unnecessary work */
+ 	adapter->flags2 |= IXGBE_FLAG2_VLAN_PROMISC;
+ 
+ 	/* Add PF to all active pools */
+ 	for (i = IXGBE_VLVF_ENTRIES; --i;) {
+ 		u32 reg_offset = IXGBE_VLVFB(i * 2 + VMDQ_P(0) / 32);
+ 		u32 vlvfb = IXGBE_READ_REG(hw, reg_offset);
+ 
+ 		vlvfb |= 1 << (VMDQ_P(0) % 32);
+ 		IXGBE_WRITE_REG(hw, reg_offset, vlvfb);
+ 	}
+ 
+ 	/* Set all bits in the VLAN filter table array */
+ 	for (i = hw->mac.vft_size; i--;)
+ 		IXGBE_WRITE_REG(hw, IXGBE_VFTA(i), ~0U);
+ }
+ 
+ #define VFTA_BLOCK_SIZE 8
+ static void ixgbe_scrub_vfta(struct ixgbe_adapter *adapter, u32 vfta_offset)
+ {
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	u32 vfta[VFTA_BLOCK_SIZE] = { 0 };
+ 	u32 vid_start = vfta_offset * 32;
+ 	u32 vid_end = vid_start + (VFTA_BLOCK_SIZE * 32);
+ 	u32 i, vid, word, bits;
+ 
+ 	for (i = IXGBE_VLVF_ENTRIES; --i;) {
+ 		u32 vlvf = IXGBE_READ_REG(hw, IXGBE_VLVF(i));
+ 
+ 		/* pull VLAN ID from VLVF */
+ 		vid = vlvf & VLAN_VID_MASK;
+ 
+ 		/* only concern outselves with a certain range */
+ 		if (vid < vid_start || vid >= vid_end)
+ 			continue;
+ 
+ 		if (vlvf) {
+ 			/* record VLAN ID in VFTA */
+ 			vfta[(vid - vid_start) / 32] |= 1 << (vid % 32);
+ 
+ 			/* if PF is part of this then continue */
+ 			if (test_bit(vid, adapter->active_vlans))
+ 				continue;
+ 		}
+ 
+ 		/* remove PF from the pool */
+ 		word = i * 2 + VMDQ_P(0) / 32;
+ 		bits = ~(1 << (VMDQ_P(0) % 32));
+ 		bits &= IXGBE_READ_REG(hw, IXGBE_VLVFB(word));
+ 		IXGBE_WRITE_REG(hw, IXGBE_VLVFB(word), bits);
+ 	}
+ 
+ 	/* extract values from active_vlans and write back to VFTA */
+ 	for (i = VFTA_BLOCK_SIZE; i--;) {
+ 		vid = (vfta_offset + i) * 32;
+ 		word = vid / BITS_PER_LONG;
+ 		bits = vid % BITS_PER_LONG;
+ 
+ 		vfta[i] |= adapter->active_vlans[word] >> bits;
+ 
+ 		IXGBE_WRITE_REG(hw, IXGBE_VFTA(vfta_offset + i), vfta[i]);
+ 	}
+ }
+ 
+ static void ixgbe_vlan_promisc_disable(struct ixgbe_adapter *adapter)
+ {
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	u32 vlnctrl, i;
+ 
+ 	switch (hw->mac.type) {
+ 	case ixgbe_mac_82599EB:
+ 	case ixgbe_mac_X540:
+ 	case ixgbe_mac_X550:
+ 	case ixgbe_mac_X550EM_x:
+ 	case ixgbe_mac_x550em_a:
+ 	default:
+ 		if (adapter->flags & IXGBE_FLAG_VMDQ_ENABLED)
+ 			break;
+ 		/* fall through */
+ 	case ixgbe_mac_82598EB:
+ 		vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);
+ 		vlnctrl &= ~IXGBE_VLNCTRL_CFIEN;
+ 		vlnctrl |= IXGBE_VLNCTRL_VFE;
+ 		IXGBE_WRITE_REG(hw, IXGBE_VLNCTRL, vlnctrl);
+ 		return;
+ 	}
+ 
+ 	/* We are not in VLAN promisc, nothing to do */
+ 	if (!(adapter->flags2 & IXGBE_FLAG2_VLAN_PROMISC))
+ 		return;
+ 
+ 	/* Set flag so we don't redo unnecessary work */
+ 	adapter->flags2 &= ~IXGBE_FLAG2_VLAN_PROMISC;
+ 
+ 	for (i = 0; i < hw->mac.vft_size; i += VFTA_BLOCK_SIZE)
+ 		ixgbe_scrub_vfta(adapter, i);
+ }
+ 
++>>>>>>> 49425dfc7451 (ixgbe: Add support for x550em_a 10G MAC type)
  static void ixgbe_restore_vlan(struct ixgbe_adapter *adapter)
  {
  	u16 vid = 1;
@@@ -4361,6 -4576,20 +4511,23 @@@ static void ixgbe_napi_disable_all(stru
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void ixgbe_clear_vxlan_port(struct ixgbe_adapter *adapter)
+ {
+ 	switch (adapter->hw.mac.type) {
+ 	case ixgbe_mac_X550:
+ 	case ixgbe_mac_X550EM_x:
+ 	case ixgbe_mac_x550em_a:
+ 		IXGBE_WRITE_REG(&adapter->hw, IXGBE_VXLANCTRL, 0);
+ 		adapter->vxlan_port = 0;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 49425dfc7451 (ixgbe: Add support for x550em_a 10G MAC type)
  #ifdef CONFIG_IXGBE_DCB
  /**
   * ixgbe_configure_dcb - Configure DCB hardware
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c
index e5ba04025e2b,bdc8fdcc07a5..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c
@@@ -1,7 -1,7 +1,11 @@@
  /*******************************************************************************
  
    Intel 10 Gigabit PCI Express Linux driver
++<<<<<<< HEAD
 +  Copyright(c) 1999 - 2013 Intel Corporation.
++=======
+   Copyright(c) 1999 - 2016 Intel Corporation.
++>>>>>>> 49425dfc7451 (ixgbe: Add support for x550em_a 10G MAC type)
  
    This program is free software; you can redistribute it and/or modify it
    under the terms and conditions of the GNU General Public License,
@@@ -203,7 -296,67 +207,71 @@@ static cycle_t ixgbe_ptp_read(const str
  }
  
  /**
++<<<<<<< HEAD
 + * ixgbe_ptp_adjfreq
++=======
+  * ixgbe_ptp_convert_to_hwtstamp - convert register value to hw timestamp
+  * @adapter: private adapter structure
+  * @hwtstamp: stack timestamp structure
+  * @systim: unsigned 64bit system time value
+  *
+  * We need to convert the adapter's RX/TXSTMP registers into a hwtstamp value
+  * which can be used by the stack's ptp functions.
+  *
+  * The lock is used to protect consistency of the cyclecounter and the SYSTIME
+  * registers. However, it does not need to protect against the Rx or Tx
+  * timestamp registers, as there can't be a new timestamp until the old one is
+  * unlatched by reading.
+  *
+  * In addition to the timestamp in hardware, some controllers need a software
+  * overflow cyclecounter, and this function takes this into account as well.
+  **/
+ static void ixgbe_ptp_convert_to_hwtstamp(struct ixgbe_adapter *adapter,
+ 					  struct skb_shared_hwtstamps *hwtstamp,
+ 					  u64 timestamp)
+ {
+ 	unsigned long flags;
+ 	struct timespec64 systime;
+ 	u64 ns;
+ 
+ 	memset(hwtstamp, 0, sizeof(*hwtstamp));
+ 
+ 	switch (adapter->hw.mac.type) {
+ 	/* X550 and later hardware supposedly represent time using a seconds
+ 	 * and nanoseconds counter, instead of raw 64bits nanoseconds. We need
+ 	 * to convert the timestamp into cycles before it can be fed to the
+ 	 * cyclecounter. We need an actual cyclecounter because some revisions
+ 	 * of hardware run at a higher frequency and thus the counter does
+ 	 * not represent seconds/nanoseconds. Instead it can be thought of as
+ 	 * cycles and billions of cycles.
+ 	 */
+ 	case ixgbe_mac_X550:
+ 	case ixgbe_mac_X550EM_x:
+ 	case ixgbe_mac_x550em_a:
+ 		/* Upper 32 bits represent billions of cycles, lower 32 bits
+ 		 * represent cycles. However, we use timespec64_to_ns for the
+ 		 * correct math even though the units haven't been corrected
+ 		 * yet.
+ 		 */
+ 		systime.tv_sec = timestamp >> 32;
+ 		systime.tv_nsec = timestamp & 0xFFFFFFFF;
+ 
+ 		timestamp = timespec64_to_ns(&systime);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	spin_lock_irqsave(&adapter->tmreg_lock, flags);
+ 	ns = timecounter_cyc2time(&adapter->hw_tc, timestamp);
+ 	spin_unlock_irqrestore(&adapter->tmreg_lock, flags);
+ 
+ 	hwtstamp->hwtstamp = ns_to_ktime(ns);
+ }
+ 
+ /**
+  * ixgbe_ptp_adjfreq_82599
++>>>>>>> 49425dfc7451 (ixgbe: Add support for x550em_a 10G MAC type)
   * @ptp: the ptp clock structure
   * @ppb: parts per billion adjustment from base
   *
@@@ -651,6 -915,33 +719,36 @@@ static int ixgbe_ptp_set_timestamp_mode
  		return 0;
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Per-packet timestamping only works if the filter is set to all
+ 	 * packets. Since this is desired, always timestamp all packets as long
+ 	 * as any Rx filter was configured.
+ 	 */
+ 	switch (hw->mac.type) {
+ 	case ixgbe_mac_X550:
+ 	case ixgbe_mac_X550EM_x:
+ 	case ixgbe_mac_x550em_a:
+ 		/* enable timestamping all packets only if at least some
+ 		 * packets were requested. Otherwise, play nice and disable
+ 		 * timestamping
+ 		 */
+ 		if (config->rx_filter == HWTSTAMP_FILTER_NONE)
+ 			break;
+ 
+ 		tsync_rx_ctl = IXGBE_TSYNCRXCTL_ENABLED |
+ 			       IXGBE_TSYNCRXCTL_TYPE_ALL |
+ 			       IXGBE_TSYNCRXCTL_TSIP_UT_EN;
+ 		config->rx_filter = HWTSTAMP_FILTER_ALL;
+ 		adapter->flags |= IXGBE_FLAG_RX_HWTSTAMP_ENABLED;
+ 		adapter->flags &= ~IXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER;
+ 		is_l2 = true;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
++>>>>>>> 49425dfc7451 (ixgbe: Add support for x550em_a 10G MAC type)
  	/* define ethertype filter for timestamping L2 packets */
  	if (is_l2)
  		IXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_1588),
@@@ -754,19 -1031,80 +852,51 @@@ void ixgbe_ptp_start_cyclecounter(struc
  		break;
  	case IXGBE_LINK_SPEED_10GB_FULL:
  	default:
 -		*shift = IXGBE_INCVAL_SHIFT_10GB;
 -		*incval = IXGBE_INCVAL_10GB;
 +		incval = IXGBE_INCVAL_10GB;
 +		shift = IXGBE_INCVAL_SHIFT_10GB;
  		break;
  	}
 -}
  
 -/**
 - * ixgbe_ptp_start_cyclecounter - create the cycle counter from hw
 - * @adapter: pointer to the adapter structure
 - *
 - * This function should be called to set the proper values for the TIMINCA
 - * register and tell the cyclecounter structure what the tick rate of SYSTIME
 - * is. It does not directly modify SYSTIME registers or the timecounter
 - * structure. It should be called whenever a new TIMINCA value is necessary,
 - * such as during initialization or when the link speed changes.
 - */
 -void ixgbe_ptp_start_cyclecounter(struct ixgbe_adapter *adapter)
 -{
 -	struct ixgbe_hw *hw = &adapter->hw;
 -	struct cyclecounter cc;
 -	unsigned long flags;
 -	u32 incval = 0;
 -	u32 tsauxc = 0;
 -	u32 fuse0 = 0;
 -
 -	/* For some of the boards below this mask is technically incorrect.
 -	 * The timestamp mask overflows at approximately 61bits. However the
 -	 * particular hardware does not overflow on an even bitmask value.
 -	 * Instead, it overflows due to conversion of upper 32bits billions of
 -	 * cycles. Timecounters are not really intended for this purpose so
 -	 * they do not properly function if the overflow point isn't 2^N-1.
 -	 * However, the actual SYSTIME values in question take ~138 years to
 -	 * overflow. In practice this means they won't actually overflow. A
 -	 * proper fix to this problem would require modification of the
 -	 * timecounter delta calculations.
 +	/**
 +	 * Modify the calculated values to fit within the correct
 +	 * number of bits specified by the hardware. The 82599 doesn't
 +	 * have the same space as the X540, so bitshift the calculated
 +	 * values to fit.
  	 */
 -	cc.mask = CLOCKSOURCE_MASK(64);
 -	cc.mult = 1;
 -	cc.shift = 0;
 -
  	switch (hw->mac.type) {
++<<<<<<< HEAD
++=======
+ 	case ixgbe_mac_X550EM_x:
+ 		/* SYSTIME assumes X550EM_x board frequency is 300Mhz, and is
+ 		 * designed to represent seconds and nanoseconds when this is
+ 		 * the case. However, some revisions of hardware have a 400Mhz
+ 		 * clock and we have to compensate for this frequency
+ 		 * variation using corrected mult and shift values.
+ 		 */
+ 		fuse0 = IXGBE_READ_REG(hw, IXGBE_FUSES0_GROUP(0));
+ 		if (!(fuse0 & IXGBE_FUSES0_300MHZ)) {
+ 			cc.mult = 3;
+ 			cc.shift = 2;
+ 		}
+ 		/* fallthrough */
+ 	case ixgbe_mac_x550em_a:
+ 	case ixgbe_mac_X550:
+ 		cc.read = ixgbe_ptp_read_X550;
+ 
+ 		/* enable SYSTIME counter */
+ 		IXGBE_WRITE_REG(hw, IXGBE_SYSTIMR, 0);
+ 		IXGBE_WRITE_REG(hw, IXGBE_SYSTIML, 0);
+ 		IXGBE_WRITE_REG(hw, IXGBE_SYSTIMH, 0);
+ 		tsauxc = IXGBE_READ_REG(hw, IXGBE_TSAUXC);
+ 		IXGBE_WRITE_REG(hw, IXGBE_TSAUXC,
+ 				tsauxc & ~IXGBE_TSAUXC_DISABLE_SYSTIME);
+ 		IXGBE_WRITE_REG(hw, IXGBE_TSIM, IXGBE_TSIM_TXTS);
+ 		IXGBE_WRITE_REG(hw, IXGBE_EIMS, IXGBE_EIMS_TIMESYNC);
+ 
+ 		IXGBE_WRITE_FLUSH(hw);
+ 		break;
++>>>>>>> 49425dfc7451 (ixgbe: Add support for x550em_a 10G MAC type)
  	case ixgbe_mac_X540:
 -		cc.read = ixgbe_ptp_read_82599;
 -
 -		ixgbe_ptp_link_speed_adjust(adapter, &cc.shift, &incval);
  		IXGBE_WRITE_REG(hw, IXGBE_TIMINCA, incval);
  		break;
  	case ixgbe_mac_82599EB:
@@@ -891,8 -1224,26 +1021,28 @@@ static int ixgbe_ptp_create_clock(struc
  		adapter->ptp_caps.settime64 = ixgbe_ptp_settime;
  		adapter->ptp_caps.enable = ixgbe_ptp_feature_enable;
  		break;
++<<<<<<< HEAD
++=======
+ 	case ixgbe_mac_X550:
+ 	case ixgbe_mac_X550EM_x:
+ 	case ixgbe_mac_x550em_a:
+ 		snprintf(adapter->ptp_caps.name, 16, "%s", netdev->name);
+ 		adapter->ptp_caps.owner = THIS_MODULE;
+ 		adapter->ptp_caps.max_adj = 30000000;
+ 		adapter->ptp_caps.n_alarm = 0;
+ 		adapter->ptp_caps.n_ext_ts = 0;
+ 		adapter->ptp_caps.n_per_out = 0;
+ 		adapter->ptp_caps.pps = 0;
+ 		adapter->ptp_caps.adjfreq = ixgbe_ptp_adjfreq_X550;
+ 		adapter->ptp_caps.adjtime = ixgbe_ptp_adjtime;
+ 		adapter->ptp_caps.gettime64 = ixgbe_ptp_gettime;
+ 		adapter->ptp_caps.settime64 = ixgbe_ptp_settime;
+ 		adapter->ptp_caps.enable = ixgbe_ptp_feature_enable;
+ 		adapter->ptp_setup_sdp = NULL;
+ 		break;
++>>>>>>> 49425dfc7451 (ixgbe: Add support for x550em_a 10G MAC type)
  	default:
  		adapter->ptp_clock = NULL;
 -		adapter->ptp_setup_sdp = NULL;
  		return -EOPNOTSUPP;
  	}
  
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
index 87208b133171,ba161b5077eb..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
@@@ -2515,7 -2705,11 +2705,15 @@@ static const u32 ixgbe_mvals_X550EM_x[I
  	IXGBE_MVALS_INIT(X550EM_x)
  };
  
++<<<<<<< HEAD
 +struct ixgbe_info ixgbe_X550_info = {
++=======
+ static const u32 ixgbe_mvals_x550em_a[IXGBE_MVALS_IDX_LIMIT] = {
+ 	IXGBE_MVALS_INIT(X550EM_a)
+ };
+ 
+ const struct ixgbe_info ixgbe_X550_info = {
++>>>>>>> 49425dfc7451 (ixgbe: Add support for x550em_a 10G MAC type)
  	.mac			= ixgbe_mac_X550,
  	.get_invariants		= &ixgbe_get_invariants_X540,
  	.mac_ops		= &mac_ops_X550,
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe.h
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
index 7724953735ff..91378034b22d 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
@@ -1623,6 +1623,7 @@ s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw,
 	switch (hw->mac.type) {
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_x550em_a:
 		IXGBE_WRITE_REG(hw, IXGBE_FDIRSCTPM, ~fdirtcpm);
 		break;
 	default:
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
index 8c560da29d23..11450bd8ec9c 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
@@ -2855,6 +2855,7 @@ u16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_x550em_a:
 		pcie_offset = IXGBE_PCIE_MSIX_82599_CAPS;
 		max_msix_count = IXGBE_MAX_MSIX_VECTORS_82599;
 		break;
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
index 02c7333a9c83..f8fb2acc2632 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 
   Intel 10 Gigabit PCI Express Linux driver
-  Copyright(c) 1999 - 2014 Intel Corporation.
+  Copyright(c) 1999 - 2016 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify it
   under the terms and conditions of the GNU General Public License,
@@ -293,6 +293,7 @@ s32 ixgbe_dcb_hw_config(struct ixgbe_hw *hw,
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_x550em_a:
 		return ixgbe_dcb_hw_config_82599(hw, pfc_en, refill, max,
 						 bwgid, ptype, prio_tc);
 	default:
@@ -311,6 +312,7 @@ s32 ixgbe_dcb_hw_pfc_config(struct ixgbe_hw *hw, u8 pfc_en, u8 *prio_tc)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_x550em_a:
 		return ixgbe_dcb_config_pfc_82599(hw, pfc_en, prio_tc);
 	default:
 		break;
@@ -368,6 +370,7 @@ s32 ixgbe_dcb_hw_ets_config(struct ixgbe_hw *hw,
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_x550em_a:
 		ixgbe_dcb_config_rx_arbiter_82599(hw, refill, max,
 						  bwg_id, prio_type, prio_tc);
 		ixgbe_dcb_config_tx_desc_arbiter_82599(hw, refill, max,
@@ -398,6 +401,7 @@ void ixgbe_dcb_read_rtrup2tc(struct ixgbe_hw *hw, u8 *map)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_x550em_a:
 		ixgbe_dcb_read_rtrup2tc_82599(hw, map);
 		break;
 	default:
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
index 6f0c5798a192..5b3525e7ffe3 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 
   Intel 10 Gigabit PCI Express Linux driver
-  Copyright(c) 1999 - 2014 Intel Corporation.
+  Copyright(c) 1999 - 2016 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify it
   under the terms and conditions of the GNU General Public License,
@@ -547,6 +547,7 @@ static void ixgbe_get_regs(struct net_device *netdev,
 		case ixgbe_mac_X540:
 		case ixgbe_mac_X550:
 		case ixgbe_mac_X550EM_x:
+		case ixgbe_mac_x550em_a:
 			regs_buff[35 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTL_82599(i));
 			regs_buff[43 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTH_82599(i));
 			break;
@@ -660,6 +661,7 @@ static void ixgbe_get_regs(struct net_device *netdev,
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_x550em_a:
 		regs_buff[830] = IXGBE_READ_REG(hw, IXGBE_RTTDCS);
 		regs_buff[832] = IXGBE_READ_REG(hw, IXGBE_RTRPCS);
 		for (i = 0; i < 8; i++)
@@ -1460,6 +1462,7 @@ static int ixgbe_reg_test(struct ixgbe_adapter *adapter, u64 *data)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_x550em_a:
 		toggle = 0x7FFFF30F;
 		test = reg_test_82599;
 		break;
@@ -1689,6 +1692,7 @@ static void ixgbe_free_desc_rings(struct ixgbe_adapter *adapter)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_x550em_a:
 		reg_ctl = IXGBE_READ_REG(hw, IXGBE_DMATXCTL);
 		reg_ctl &= ~IXGBE_DMATXCTL_TE;
 		IXGBE_WRITE_REG(hw, IXGBE_DMATXCTL, reg_ctl);
@@ -1728,6 +1732,7 @@ static int ixgbe_setup_desc_rings(struct ixgbe_adapter *adapter)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_x550em_a:
 		reg_data = IXGBE_READ_REG(&adapter->hw, IXGBE_DMATXCTL);
 		reg_data |= IXGBE_DMATXCTL_TE;
 		IXGBE_WRITE_REG(&adapter->hw, IXGBE_DMATXCTL, reg_data);
@@ -1788,6 +1793,7 @@ static int ixgbe_setup_loopback_test(struct ixgbe_adapter *adapter)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_x550em_a:
 		reg_data = IXGBE_READ_REG(hw, IXGBE_MACC);
 		reg_data |= IXGBE_MACC_FLU;
 		IXGBE_WRITE_REG(hw, IXGBE_MACC, reg_data);
@@ -2994,6 +3000,7 @@ static int ixgbe_get_ts_info(struct net_device *dev,
 	switch (adapter->hw.mac.type) {
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_x550em_a:
 	case ixgbe_mac_X540:
 	case ixgbe_mac_82599EB:
 		info->so_timestamping =
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c
index 3afb2c7f4974..e93acb761784 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 
   Intel 10 Gigabit PCI Express Linux driver
-  Copyright(c) 1999 - 2013 Intel Corporation.
+  Copyright(c) 1999 - 2016 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify it
   under the terms and conditions of the GNU General Public License,
@@ -128,6 +128,7 @@ static void ixgbe_get_first_reg_idx(struct ixgbe_adapter *adapter, u8 tc,
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_x550em_a:
 		if (num_tcs > 4) {
 			/*
 			 * TCs    : TC0/1 TC2/3 TC4-7
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c
index 9993a471d668..8d3d3b6342a6 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c
@@ -307,6 +307,7 @@ static s32 ixgbe_check_for_rst_pf(struct ixgbe_hw *hw, u16 vf_number)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_x550em_a:
 		vflre = IXGBE_READ_REG(hw, IXGBE_VFLREC(reg_offset));
 		break;
 	default:
@@ -430,6 +431,7 @@ void ixgbe_init_mbx_params_pf(struct ixgbe_hw *hw)
 	if (hw->mac.type != ixgbe_mac_82599EB &&
 	    hw->mac.type != ixgbe_mac_X550 &&
 	    hw->mac.type != ixgbe_mac_X550EM_x &&
+	    hw->mac.type != ixgbe_mac_x550em_a &&
 	    hw->mac.type != ixgbe_mac_X540)
 		return;
 
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
index 8c49fb6400a4..c20762b05f9b 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
@@ -2611,6 +2611,20 @@ enum ixgbe_fdir_pballoc_type {
 #define FW_MAX_READ_BUFFER_SIZE		1024
 #define FW_DISABLE_RXEN_CMD		0xDE
 #define FW_DISABLE_RXEN_LEN		0x1
+#define FW_PHY_MGMT_REQ_CMD		0x20
+#define FW_PHY_TOKEN_REQ_CMD		0x0A
+#define FW_PHY_TOKEN_REQ_LEN		2
+#define FW_PHY_TOKEN_REQ		0
+#define FW_PHY_TOKEN_REL		1
+#define FW_PHY_TOKEN_OK			1
+#define FW_PHY_TOKEN_RETRY		0x80
+#define FW_PHY_TOKEN_DELAY		5	/* milliseconds */
+#define FW_PHY_TOKEN_WAIT		5	/* seconds */
+#define FW_PHY_TOKEN_RETRIES ((FW_PHY_TOKEN_WAIT * 1000) / FW_PHY_TOKEN_DELAY)
+#define FW_INT_PHY_REQ_CMD		0xB
+#define FW_INT_PHY_REQ_LEN		10
+#define FW_INT_PHY_REQ_READ		0
+#define FW_INT_PHY_REQ_WRITE		1
 
 /* Host Interface Command Structures */
 struct ixgbe_hic_hdr {
@@ -2679,6 +2693,28 @@ struct ixgbe_hic_disable_rxen {
 	u16 pad3;
 };
 
+struct ixgbe_hic_phy_token_req {
+	struct ixgbe_hic_hdr hdr;
+	u8 port_number;
+	u8 command_type;
+	u16 pad;
+};
+
+struct ixgbe_hic_internal_phy_req {
+	struct ixgbe_hic_hdr hdr;
+	u8 port_number;
+	u8 command_type;
+	__be16 address;
+	u16 rsv1;
+	__be32 write_data;
+	u16 pad;
+} __packed;
+
+struct ixgbe_hic_internal_phy_resp {
+	struct ixgbe_hic_hdr hdr;
+	__be32 read_data;
+};
+
 /* Transmit Descriptor - Advanced */
 union ixgbe_adv_tx_desc {
 	struct {
@@ -3511,6 +3547,8 @@ struct ixgbe_info {
 #define IXGBE_ERR_INVALID_ARGUMENT              -32
 #define IXGBE_ERR_HOST_INTERFACE_COMMAND        -33
 #define IXGBE_ERR_FDIR_CMD_INCOMPLETE		-38
+#define IXGBE_ERR_FW_RESP_INVALID		-39
+#define IXGBE_ERR_TOKEN_RETRY			-40
 #define IXGBE_NOT_IMPLEMENTED                   0x7FFFFFFF
 
 #define IXGBE_FUSES0_GROUP(_i)		(0x11158 + ((_i) * 4))
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
