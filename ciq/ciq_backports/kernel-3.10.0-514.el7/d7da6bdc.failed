iommu: Improve error handling when setting bus iommu

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [iommu] Improve error handling when setting bus iommu (Myron Stowe) [1287300]
Rebuild_FUZZ: 92.78%
commit-author Heiko St√ºbner <heiko@sntech.de>
commit d7da6bdc322bb79c4326dff7c2727236a48c4be9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d7da6bdc.failed

When some part of bus_set_iommu fails it should undo any made changes
and not simply leave everything as is.

This includes unregistering the bus notifier in iommu_bus_init when
add_iommu_group fails and also setting the bus->iommu_ops back to NULL.

	Signed-off-by: Heiko Stuebner <heiko@sntech.de>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit d7da6bdc322bb79c4326dff7c2727236a48c4be9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iommu.c
diff --cc drivers/iommu/iommu.c
index 58da13944bc3,02e4313e937c..000000000000
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@@ -794,14 -799,34 +794,43 @@@ static int iommu_bus_notifier(struct no
  	return 0;
  }
  
 -static int iommu_bus_init(struct bus_type *bus, const struct iommu_ops *ops)
 +static struct notifier_block iommu_bus_nb = {
 +	.notifier_call = iommu_bus_notifier,
 +};
 +
 +static void iommu_bus_init(struct bus_type *bus, struct iommu_ops *ops)
  {
++<<<<<<< HEAD
 +	bus_register_notifier(bus, &iommu_bus_nb);
 +	bus_for_each_dev(bus, NULL, ops, add_iommu_group);
++=======
+ 	int err;
+ 	struct notifier_block *nb;
+ 	struct iommu_callback_data cb = {
+ 		.ops = ops,
+ 	};
+ 
+ 	nb = kzalloc(sizeof(struct notifier_block), GFP_KERNEL);
+ 	if (!nb)
+ 		return -ENOMEM;
+ 
+ 	nb->notifier_call = iommu_bus_notifier;
+ 
+ 	err = bus_register_notifier(bus, nb);
+ 	if (err) {
+ 		kfree(nb);
+ 		return err;
+ 	}
+ 
+ 	err = bus_for_each_dev(bus, NULL, &cb, add_iommu_group);
+ 	if (err) {
+ 		bus_unregister_notifier(bus, nb);
+ 		kfree(nb);
+ 		return err;
+ 	}
+ 
+ 	return 0;
++>>>>>>> d7da6bdc322b (iommu: Improve error handling when setting bus iommu)
  }
  
  /**
@@@ -817,17 -842,21 +846,27 @@@
   * is set up. With this function the iommu-driver can set the iommu-ops
   * afterwards.
   */
 -int bus_set_iommu(struct bus_type *bus, const struct iommu_ops *ops)
 +int bus_set_iommu(struct bus_type *bus, struct iommu_ops *ops)
  {
+ 	int err;
+ 
  	if (bus->iommu_ops != NULL)
  		return -EBUSY;
  
  	bus->iommu_ops = ops;
  
  	/* Do IOMMU specific setup for this bus-type */
++<<<<<<< HEAD
 +	iommu_bus_init(bus, ops);
 +
 +	return 0;
++=======
+ 	err = iommu_bus_init(bus, ops);
+ 	if (err)
+ 		bus->iommu_ops = NULL;
+ 
+ 	return err;
++>>>>>>> d7da6bdc322b (iommu: Improve error handling when setting bus iommu)
  }
  EXPORT_SYMBOL_GPL(bus_set_iommu);
  
* Unmerged path drivers/iommu/iommu.c
