staging/rdma/hfi1: Use address handle in rdmavt and remove from hfi1

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Use address handle in rdmavt and remove from hfi1 (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 93.75%
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit 15723f06fb9d80cbfd895c32c6023881c7d0e0b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/15723f06.failed

Original patch from Kamal Heib <kamalh@mellanox.com>, split
apart from original and modified to accomodate recent changes
in rdmavt.

Remove AH from hfi1 and use rdmavt version.

	Signed-off-by: Kamal Heib <kamalh@mellanox.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 15723f06fb9d80cbfd895c32c6023881c7d0e0b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/common.h
#	drivers/staging/hfi1/qp.c
#	drivers/staging/hfi1/ruc.c
#	drivers/staging/hfi1/ud.c
#	drivers/staging/hfi1/verbs.c
diff --cc drivers/staging/hfi1/common.h
index 5dd92720faae,cb5ca794ac08..000000000000
--- a/drivers/staging/hfi1/common.h
+++ b/drivers/staging/hfi1/common.h
@@@ -349,11 -348,10 +348,15 @@@ struct hfi1_message_header 
  #define HFI1_QPN_MASK 0xFFFFFF
  #define HFI1_FECN_SHIFT 31
  #define HFI1_FECN_MASK 1
 -#define HFI1_FECN_SMASK BIT(HFI1_FECN_SHIFT)
 +#define HFI1_FECN_SMASK (1 << HFI1_FECN_SHIFT)
  #define HFI1_BECN_SHIFT 30
  #define HFI1_BECN_MASK 1
++<<<<<<< HEAD:drivers/staging/hfi1/common.h
 +#define HFI1_BECN_SMASK (1 << HFI1_BECN_SHIFT)
 +#define HFI1_MULTICAST_LID_BASE 0xC000
++=======
+ #define HFI1_BECN_SMASK BIT(HFI1_BECN_SHIFT)
++>>>>>>> 15723f06fb9d (staging/rdma/hfi1: Use address handle in rdmavt and remove from hfi1):drivers/staging/rdma/hfi1/common.h
  
  static inline __u64 rhf_to_cpu(const __le32 *rbuf)
  {
diff --cc drivers/staging/hfi1/qp.c
index 9ffed6e14d8e,9fcf052b62bd..000000000000
--- a/drivers/staging/hfi1/qp.c
+++ b/drivers/staging/hfi1/qp.c
@@@ -424,7 -424,7 +424,11 @@@ static void clear_mr_refs(struct hfi1_q
  			if (qp->ibqp.qp_type == IB_QPT_UD ||
  			    qp->ibqp.qp_type == IB_QPT_SMI ||
  			    qp->ibqp.qp_type == IB_QPT_GSI)
++<<<<<<< HEAD:drivers/staging/hfi1/qp.c
 +				atomic_dec(&to_iah(wqe->wr.wr.ud.ah)->refcount);
++=======
+ 				atomic_dec(&ibah_to_rvtah(wqe->ud_wr.ah)->refcount);
++>>>>>>> 15723f06fb9d (staging/rdma/hfi1: Use address handle in rdmavt and remove from hfi1):drivers/staging/rdma/hfi1/qp.c
  			if (++qp->s_last >= qp->s_size)
  				qp->s_last = 0;
  		}
@@@ -640,9 -640,9 +644,9 @@@ int hfi1_modify_qp(struct ib_qp *ibqp, 
  	if (attr_mask & IB_QP_AV) {
  		u8 sc;
  
 -		if (attr->ah_attr.dlid >= be16_to_cpu(IB_MULTICAST_LID_BASE))
 +		if (attr->ah_attr.dlid >= HFI1_MULTICAST_LID_BASE)
  			goto inval;
- 		if (hfi1_check_ah(qp->ibqp.device, &attr->ah_attr))
+ 		if (rvt_check_ah(qp->ibqp.device, &attr->ah_attr))
  			goto inval;
  		sc = ah_to_sc(ibqp->device, &attr->ah_attr);
  		if (!qp_to_sdma_engine(qp, sc) &&
@@@ -653,9 -653,10 +657,9 @@@
  	if (attr_mask & IB_QP_ALT_PATH) {
  		u8 sc;
  
 -		if (attr->alt_ah_attr.dlid >=
 -		    be16_to_cpu(IB_MULTICAST_LID_BASE))
 +		if (attr->alt_ah_attr.dlid >= HFI1_MULTICAST_LID_BASE)
  			goto inval;
- 		if (hfi1_check_ah(qp->ibqp.device, &attr->alt_ah_attr))
+ 		if (rvt_check_ah(qp->ibqp.device, &attr->alt_ah_attr))
  			goto inval;
  		if (attr->alt_pkey_index >= hfi1_get_npkeys(dd))
  			goto inval;
diff --cc drivers/staging/hfi1/ruc.c
index c4280b6f47d4,33bcfe5bfd13..000000000000
--- a/drivers/staging/hfi1/ruc.c
+++ b/drivers/staging/hfi1/ruc.c
@@@ -893,7 -893,7 +893,11 @@@ void hfi1_send_complete(struct hfi1_qp 
  	if (qp->ibqp.qp_type == IB_QPT_UD ||
  	    qp->ibqp.qp_type == IB_QPT_SMI ||
  	    qp->ibqp.qp_type == IB_QPT_GSI)
++<<<<<<< HEAD:drivers/staging/hfi1/ruc.c
 +		atomic_dec(&to_iah(wqe->wr.wr.ud.ah)->refcount);
++=======
+ 		atomic_dec(&ibah_to_rvtah(wqe->ud_wr.ah)->refcount);
++>>>>>>> 15723f06fb9d (staging/rdma/hfi1: Use address handle in rdmavt and remove from hfi1):drivers/staging/rdma/hfi1/ruc.c
  
  	/* See ch. 11.2.4.1 and 10.7.3.1 */
  	if (!(qp->s_flags & HFI1_S_SIGNAL_REQ_WR) ||
diff --cc drivers/staging/hfi1/ud.c
index a7f67b0111da,820fef211edf..000000000000
--- a/drivers/staging/hfi1/ud.c
+++ b/drivers/staging/hfi1/ud.c
@@@ -98,7 -98,7 +98,11 @@@ static void ud_loopback(struct hfi1_qp 
  		goto drop;
  	}
  
++<<<<<<< HEAD:drivers/staging/hfi1/ud.c
 +	ah_attr = &to_iah(swqe->wr.wr.ud.ah)->attr;
++=======
+ 	ah_attr = &ibah_to_rvtah(swqe->ud_wr.ah)->attr;
++>>>>>>> 15723f06fb9d (staging/rdma/hfi1: Use address handle in rdmavt and remove from hfi1):drivers/staging/rdma/hfi1/ud.c
  	ppd = ppd_from_ibp(ibp);
  
  	if (qp->ibqp.qp_num > 1) {
@@@ -309,12 -309,12 +313,18 @@@ int hfi1_make_ud_req(struct hfi1_qp *qp
  	/* Construct the header. */
  	ibp = to_iport(qp->ibqp.device, qp->port_num);
  	ppd = ppd_from_ibp(ibp);
++<<<<<<< HEAD:drivers/staging/hfi1/ud.c
 +	ah_attr = &to_iah(wqe->wr.wr.ud.ah)->attr;
 +	if (ah_attr->dlid < HFI1_MULTICAST_LID_BASE ||
 +	    ah_attr->dlid == HFI1_PERMISSIVE_LID) {
++=======
+ 	ah_attr = &ibah_to_rvtah(wqe->ud_wr.ah)->attr;
+ 	if (ah_attr->dlid < be16_to_cpu(IB_MULTICAST_LID_BASE) ||
+ 	    ah_attr->dlid == be16_to_cpu(IB_LID_PERMISSIVE)) {
++>>>>>>> 15723f06fb9d (staging/rdma/hfi1: Use address handle in rdmavt and remove from hfi1):drivers/staging/rdma/hfi1/ud.c
  		lid = ah_attr->dlid & ~((1 << ppd->lmc) - 1);
  		if (unlikely(!loopback && (lid == ppd->lid ||
 -		    (lid == be16_to_cpu(IB_LID_PERMISSIVE) &&
 +		    (lid == HFI1_PERMISSIVE_LID &&
  		     qp->ibqp.qp_type == IB_QPT_GSI)))) {
  			/*
  			 * If DMAs are in progress, we can't generate
diff --cc drivers/staging/hfi1/verbs.c
index cfa74cbcf382,021e21153b90..000000000000
--- a/drivers/staging/hfi1/verbs.c
+++ b/drivers/staging/hfi1/verbs.c
@@@ -443,9 -455,7 +443,13 @@@ static int post_one_send(struct hfi1_q
  		if (wqe->length > 0x80000000U)
  			goto bail_inval_free;
  	} else {
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +		struct hfi1_ah *ah = to_iah(wr->wr.ud.ah);
 +
 +		atomic_inc(&ah->refcount);
++=======
+ 		atomic_inc(&ibah_to_rvtah(ud_wr(wr)->ah)->refcount);
++>>>>>>> 15723f06fb9d (staging/rdma/hfi1: Use address handle in rdmavt and remove from hfi1):drivers/staging/rdma/hfi1/verbs.c
  	}
  	wqe->ssn = qp->s_ssn++;
  	qp->s_head = next;
@@@ -2018,7 -1912,20 +1909,24 @@@ int hfi1_register_ib_device(struct hfi1
  	strncpy(ibdev->node_desc, init_utsname()->nodename,
  		sizeof(ibdev->node_desc));
  
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +	ret = ib_register_device(ibdev, hfi1_create_port_files);
++=======
+ 	/*
+ 	 * Fill in rvt info object.
+ 	 */
+ 	dd->verbs_dev.rdi.driver_f.port_callback = hfi1_create_port_files;
+ 	dd->verbs_dev.rdi.driver_f.get_card_name = get_card_name;
+ 	dd->verbs_dev.rdi.driver_f.get_pci_dev = get_pci_dev;
+ 	dd->verbs_dev.rdi.driver_f.check_ah = hfi1_check_ah;
+ 	dd->verbs_dev.rdi.dparms.props.max_ah = hfi1_max_ahs;
+ 	dd->verbs_dev.rdi.dparms.props.max_pd = hfi1_max_pds;
+ 	dd->verbs_dev.rdi.flags = (RVT_FLAG_MR_INIT_DRIVER |
+ 				   RVT_FLAG_QP_INIT_DRIVER |
+ 				   RVT_FLAG_CQ_INIT_DRIVER);
+ 
+ 	ret = rvt_register_device(&dd->verbs_dev.rdi);
++>>>>>>> 15723f06fb9d (staging/rdma/hfi1: Use address handle in rdmavt and remove from hfi1):drivers/staging/rdma/hfi1/verbs.c
  	if (ret)
  		goto err_reg;
  
* Unmerged path drivers/staging/hfi1/common.h
diff --git a/drivers/staging/hfi1/mad.c b/drivers/staging/hfi1/mad.c
index a26383d2332e..7a8e4b0232e3 100644
--- a/drivers/staging/hfi1/mad.c
+++ b/drivers/staging/hfi1/mad.c
@@ -137,7 +137,7 @@ static void send_trap(struct hfi1_ibport *ibp, void *data, unsigned len)
 				ret = PTR_ERR(ah);
 			else {
 				send_buf->ah = ah;
-				ibp->sm_ah = to_iah(ah);
+				ibp->sm_ah = ibah_to_rvtah(ah);
 				ret = 0;
 			}
 		} else
* Unmerged path drivers/staging/hfi1/qp.c
* Unmerged path drivers/staging/hfi1/ruc.c
* Unmerged path drivers/staging/hfi1/ud.c
* Unmerged path drivers/staging/hfi1/verbs.c
diff --git a/drivers/staging/hfi1/verbs.h b/drivers/staging/hfi1/verbs.h
index 34fa7beced4f..80ca5c3ce5e1 100644
--- a/drivers/staging/hfi1/verbs.h
+++ b/drivers/staging/hfi1/verbs.h
@@ -233,13 +233,6 @@ struct hfi1_mcast {
 	int n_attached;
 };
 
-/* Address Handle */
-struct hfi1_ah {
-	struct ib_ah ibah;
-	struct ib_ah_attr attr;
-	atomic_t refcount;
-};
-
 /*
  * This structure is used by hfi1_mmap() to validate an offset
  * when an mmap() request is made.  The vm_area_struct then uses
@@ -646,8 +639,8 @@ static inline void inc_opstats(
 struct hfi1_ibport {
 	struct hfi1_qp __rcu *qp[2];
 	struct ib_mad_agent *send_agent;	/* agent for SMI (traps) */
-	struct hfi1_ah *sm_ah;
-	struct hfi1_ah *smi_ah;
+	struct rvt_ah *sm_ah;
+	struct rvt_ah *smi_ah;
 	struct rb_root mcast_tree;
 	spinlock_t lock;		/* protect changes in this struct */
 
@@ -729,8 +722,6 @@ struct hfi1_ibdev {
 	u64 n_kmem_wait;
 	u64 n_send_schedule;
 
-	u32 n_ahs_allocated;    /* number of AHs allocated for device */
-	spinlock_t n_ahs_lock;
 	u32 n_cqs_allocated;    /* number of CQs allocated for device */
 	spinlock_t n_cqs_lock;
 	u32 n_qps_allocated;    /* number of QPs allocated for device */
@@ -768,11 +759,6 @@ static inline struct hfi1_mr *to_imr(struct ib_mr *ibmr)
 	return container_of(ibmr, struct hfi1_mr, ibmr);
 }
 
-static inline struct hfi1_ah *to_iah(struct ib_ah *ibah)
-{
-	return container_of(ibah, struct hfi1_ah, ibah);
-}
-
 static inline struct hfi1_cq *to_icq(struct ib_cq *ibcq)
 {
 	return container_of(ibcq, struct hfi1_cq, ibcq);
@@ -916,8 +902,6 @@ void hfi1_rc_hdrerr(
 
 u8 ah_to_sc(struct ib_device *ibdev, struct ib_ah_attr *ah_attr);
 
-int hfi1_check_ah(struct ib_device *ibdev, struct ib_ah_attr *ah_attr);
-
 struct ib_ah *hfi1_create_qp0_ah(struct hfi1_ibport *ibp, u16 dlid);
 
 void hfi1_rc_rnr_retry(unsigned long arg);
