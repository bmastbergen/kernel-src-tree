openvswitch: Reject ct_state unsupported bits

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Joe Stringer <joestringer@nicira.com>
commit 6f225952461b5e9b5520d0dc6e2ff0af57874fbb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6f225952.failed

Previously, if userspace specified ct_state bits in the flow key which
are currently undefined (and therefore unsupported), then they would be
ignored. This could cause unexpected behaviour in future if userspace is
extended to support additional bits but attempts to communicate with the
current version of the kernel. This patch rectifies the situation by
rejecting such ct_state bits.

Fixes: 7f8a436eaa2c "openvswitch: Add conntrack action"
	Signed-off-by: Joe Stringer <joestringer@nicira.com>
	Acked-by: Pravin B Shelar <pshelar@nicira.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6f225952461b5e9b5520d0dc6e2ff0af57874fbb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/conntrack.h
#	net/openvswitch/flow_netlink.c
diff --cc net/openvswitch/flow_netlink.c
index 953a2c4bca92,d47b5c5c640e..000000000000
--- a/net/openvswitch/flow_netlink.c
+++ b/net/openvswitch/flow_netlink.c
@@@ -768,6 -811,43 +768,46 @@@ static int metadata_from_nlattrs(struc
  			return -EINVAL;
  		*attrs &= ~(1 << OVS_KEY_ATTR_TUNNEL);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (*attrs & (1 << OVS_KEY_ATTR_CT_STATE) &&
+ 	    ovs_ct_verify(net, OVS_KEY_ATTR_CT_STATE)) {
+ 		u8 ct_state = nla_get_u8(a[OVS_KEY_ATTR_CT_STATE]);
+ 
+ 		if (!is_mask && !ovs_ct_state_supported(ct_state)) {
+ 			OVS_NLERR(log, "ct_state flags %02x unsupported",
+ 				  ct_state);
+ 			return -EINVAL;
+ 		}
+ 
+ 		SW_FLOW_KEY_PUT(match, ct.state, ct_state, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_STATE);
+ 	}
+ 	if (*attrs & (1 << OVS_KEY_ATTR_CT_ZONE) &&
+ 	    ovs_ct_verify(net, OVS_KEY_ATTR_CT_ZONE)) {
+ 		u16 ct_zone = nla_get_u16(a[OVS_KEY_ATTR_CT_ZONE]);
+ 
+ 		SW_FLOW_KEY_PUT(match, ct.zone, ct_zone, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_ZONE);
+ 	}
+ 	if (*attrs & (1 << OVS_KEY_ATTR_CT_MARK) &&
+ 	    ovs_ct_verify(net, OVS_KEY_ATTR_CT_MARK)) {
+ 		u32 mark = nla_get_u32(a[OVS_KEY_ATTR_CT_MARK]);
+ 
+ 		SW_FLOW_KEY_PUT(match, ct.mark, mark, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_MARK);
+ 	}
+ 	if (*attrs & (1 << OVS_KEY_ATTR_CT_LABELS) &&
+ 	    ovs_ct_verify(net, OVS_KEY_ATTR_CT_LABELS)) {
+ 		const struct ovs_key_ct_labels *cl;
+ 
+ 		cl = nla_data(a[OVS_KEY_ATTR_CT_LABELS]);
+ 		SW_FLOW_KEY_MEMCPY(match, ct.labels, cl->ct_labels,
+ 				   sizeof(*cl), is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_LABELS);
+ 	}
++>>>>>>> 6f225952461b (openvswitch: Reject ct_state unsupported bits)
  	return 0;
  }
  
* Unmerged path net/openvswitch/conntrack.h
* Unmerged path net/openvswitch/conntrack.h
* Unmerged path net/openvswitch/flow_netlink.c
