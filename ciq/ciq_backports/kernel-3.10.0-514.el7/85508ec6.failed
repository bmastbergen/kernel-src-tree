zram: use idr instead of `zram_devices' array

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
commit 85508ec6cbc21645927b6ac05e3b2748119a3e23
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/85508ec6.failed

This patch makes some preparations for on-demand device add/remove
functionality.

Remove `zram_devices' array and switch to id-to-pointer translation (idr).
idr doesn't bloat zram struct with additional members, f.e.  list_head,
yet still provides ability to match the device_id with the device pointer.

No user-space visible changes.

[Julia.Lawall@lip6.fr: return -ENOMEM when `queue' alloc fails]
	Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
	Reported-by: Julia Lawall <Julia.Lawall@lip6.fr>
	Acked-by: Minchan Kim <minchan@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 85508ec6cbc21645927b6ac05e3b2748119a3e23)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/zram/zram_drv.c
diff --cc drivers/block/zram/zram_drv.c
index f4772ab5159f,addb18d1b8d7..000000000000
--- a/drivers/block/zram/zram_drv.c
+++ b/drivers/block/zram/zram_drv.c
@@@ -945,23 -1154,34 +945,39 @@@ static struct attribute_group zram_disk
  	.attrs = zram_disk_attrs,
  };
  
- static int create_device(struct zram *zram, int device_id)
+ static int zram_add(int device_id)
  {
++<<<<<<< HEAD
 +	int ret = -ENOMEM;
++=======
+ 	struct zram *zram;
+ 	struct request_queue *queue;
+ 	int ret;
+ 
+ 	zram = kzalloc(sizeof(struct zram), GFP_KERNEL);
+ 	if (!zram)
+ 		return -ENOMEM;
+ 
+ 	ret = idr_alloc(&zram_index_idr, zram, device_id,
+ 			device_id + 1, GFP_KERNEL);
+ 	if (ret < 0)
+ 		goto out_free_dev;
++>>>>>>> 85508ec6cbc2 (zram: use idr instead of `zram_devices' array)
  
  	init_rwsem(&zram->init_lock);
  
 -	queue = blk_alloc_queue(GFP_KERNEL);
 -	if (!queue) {
 +	zram->queue = blk_alloc_queue(GFP_KERNEL);
 +	if (!zram->queue) {
  		pr_err("Error allocating disk queue for device %d\n",
  			device_id);
- 		goto out;
+ 		ret = -ENOMEM;
+ 		goto out_free_idr;
  	}
  
 -	blk_queue_make_request(queue, zram_make_request);
 +	blk_queue_make_request(zram->queue, zram_make_request);
 +	zram->queue->queuedata = zram;
  
- 	 /* gendisk structure */
+ 	/* gendisk structure */
  	zram->disk = alloc_disk(1);
  	if (!zram->disk) {
  		pr_warn("Error allocating disk structure for device %d\n",
@@@ -1008,20 -1245,43 +1024,60 @@@ out_free_disk
  	del_gendisk(zram->disk);
  	put_disk(zram->disk);
  out_free_queue:
++<<<<<<< HEAD
 +	blk_cleanup_queue(zram->queue);
 +out:
 +	return ret;
 +}
 +
 +static void destroy_device(struct zram *zram)
 +{
 +	sysfs_remove_group(&disk_to_dev(zram->disk)->kobj,
 +			&zram_disk_attr_group);
 +
 +	del_gendisk(zram->disk);
 +	put_disk(zram->disk);
 +
 +	blk_cleanup_queue(zram->queue);
++=======
+ 	blk_cleanup_queue(queue);
+ out_free_idr:
+ 	idr_remove(&zram_index_idr, device_id);
+ out_free_dev:
+ 	kfree(zram);
+ 	return ret;
+ }
+ 
+ static void zram_remove(struct zram *zram)
+ {
+ 	/*
+ 	 * Remove sysfs first, so no one will perform a disksize
+ 	 * store while we destroy the devices
+ 	 */
+ 	sysfs_remove_group(&disk_to_dev(zram->disk)->kobj,
+ 			&zram_disk_attr_group);
+ 
+ 	zram_reset_device(zram);
+ 	idr_remove(&zram_index_idr, zram->disk->first_minor);
+ 	blk_cleanup_queue(zram->disk->queue);
+ 	del_gendisk(zram->disk);
+ 	put_disk(zram->disk);
+ 	kfree(zram);
+ }
+ 
+ static int zram_remove_cb(int id, void *ptr, void *data)
+ {
+ 	zram_remove(ptr);
+ 	return 0;
+ }
+ 
+ static void destroy_devices(void)
+ {
+ 	idr_for_each(&zram_index_idr, &zram_remove_cb, NULL);
+ 	idr_destroy(&zram_index_idr);
+ 	unregister_blkdev(zram_major, "zram");
+ 	pr_info("Destroyed device(s)\n");
++>>>>>>> 85508ec6cbc2 (zram: use idr instead of `zram_devices' array)
  }
  
  static int __init zram_init(void)
@@@ -1038,57 -1297,26 +1094,73 @@@
  	zram_major = register_blkdev(0, "zram");
  	if (zram_major <= 0) {
  		pr_warn("Unable to get major number\n");
 -		return -EBUSY;
 +		ret = -EBUSY;
 +		goto out;
  	}
  
++<<<<<<< HEAD
 +	/* Allocate the device array and initialize each one */
 +	zram_devices = kzalloc(num_devices * sizeof(struct zram), GFP_KERNEL);
 +	if (!zram_devices) {
 +		ret = -ENOMEM;
 +		goto unregister;
 +	}
 +
 +	for (dev_id = 0; dev_id < num_devices; dev_id++) {
 +		ret = create_device(&zram_devices[dev_id], dev_id);
 +		if (ret)
 +			goto free_devices;
++=======
+ 	for (dev_id = 0; dev_id < num_devices; dev_id++) {
+ 		ret = zram_add(dev_id);
+ 		if (ret != 0)
+ 			goto out_error;
++>>>>>>> 85508ec6cbc2 (zram: use idr instead of `zram_devices' array)
  	}
  
 -	pr_info("Created %u device(s)\n", num_devices);
 +	pr_info("Created %u device(s) ...\n", num_devices);
 +
  	return 0;
  
++<<<<<<< HEAD
 +free_devices:
 +	while (dev_id)
 +		destroy_device(&zram_devices[--dev_id]);
 +	kfree(zram_devices);
 +unregister:
 +	unregister_blkdev(zram_major, "zram");
 +out:
++=======
+ out_error:
+ 	destroy_devices();
++>>>>>>> 85508ec6cbc2 (zram: use idr instead of `zram_devices' array)
  	return ret;
  }
  
  static void __exit zram_exit(void)
  {
++<<<<<<< HEAD
 +	int i;
 +	struct zram *zram;
 +
 +	for (i = 0; i < num_devices; i++) {
 +		zram = &zram_devices[i];
 +
 +		destroy_device(zram);
 +		/*
 +		 * Shouldn't access zram->disk after destroy_device
 +		 * because destroy_device already released zram->disk.
 +		 */
 +		zram_reset_device(zram, false);
 +	}
 +
 +	unregister_blkdev(zram_major, "zram");
 +
 +	kfree(zram_devices);
 +	pr_debug("Cleanup done!\n");
++=======
+ 	destroy_devices();
++>>>>>>> 85508ec6cbc2 (zram: use idr instead of `zram_devices' array)
  }
  
  module_init(zram_init);
* Unmerged path drivers/block/zram/zram_drv.c
