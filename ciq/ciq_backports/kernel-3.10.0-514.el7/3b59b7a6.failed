IB/srp: Move code out of a loop

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit 3b59b7a693b0e5b2dc244bcd78899aa2585a434b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3b59b7a6.failed

Since all srp_map_finish_fr() callers pass a non-zero value as
the fourth argument (sg_nents), the sg_nents == 0 check in that
function can be removed. Add a count == 0 check in the caller
of that function.

	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Sagi Grimberg <sagi@grimberg.me>
	Cc: Laurence Oberman <loberman@redhat.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 3b59b7a693b0e5b2dc244bcd78899aa2585a434b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/srp/ib_srp.c
diff --cc drivers/infiniband/ulp/srp/ib_srp.c
index 6673c6f5b7ae,ce2c379272cf..000000000000
--- a/drivers/infiniband/ulp/srp/ib_srp.c
+++ b/drivers/infiniband/ulp/srp/ib_srp.c
@@@ -1319,6 -1313,15 +1319,18 @@@ static int srp_map_finish_fr(struct srp
  	if (state->fr.next >= state->fr.end)
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	WARN_ON_ONCE(!dev->use_fast_reg);
+ 
+ 	if (sg_nents == 1 && target->global_mr) {
+ 		srp_map_desc(state, sg_dma_address(state->sg),
+ 			     sg_dma_len(state->sg),
+ 			     target->global_mr->rkey);
+ 		return 1;
+ 	}
+ 
++>>>>>>> 3b59b7a693b0 (IB/srp: Move code out of a loop)
  	desc = srp_fr_pool_get(ch->fr_pool);
  	if (!desc)
  		return -ENOMEM;
@@@ -1421,9 -1402,61 +1433,67 @@@ static int srp_map_sg_entry(struct srp_
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int srp_map_sg(struct srp_map_state *state, struct srp_rdma_ch *ch,
 +		      struct srp_request *req, struct scatterlist *scat,
 +		      int count)
++=======
+ static int srp_map_sg_fmr(struct srp_map_state *state, struct srp_rdma_ch *ch,
+ 			  struct srp_request *req, struct scatterlist *scat,
+ 			  int count)
+ {
+ 	struct scatterlist *sg;
+ 	int i, ret;
+ 
+ 	state->desc = req->indirect_desc;
+ 	state->pages = req->map_page;
+ 	state->fmr.next = req->fmr_list;
+ 	state->fmr.end = req->fmr_list + ch->target->cmd_sg_cnt;
+ 
+ 	for_each_sg(scat, sg, count, i) {
+ 		ret = srp_map_sg_entry(state, ch, sg, i);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	ret = srp_map_finish_fmr(state, ch);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return 0;
+ }
+ 
+ static int srp_map_sg_fr(struct srp_map_state *state, struct srp_rdma_ch *ch,
+ 			 struct srp_request *req, struct scatterlist *scat,
+ 			 int count)
+ {
+ 	state->desc = req->indirect_desc;
+ 	state->fr.next = req->fr_list;
+ 	state->fr.end = req->fr_list + ch->target->cmd_sg_cnt;
+ 	state->sg = scat;
+ 
+ 	if (count == 0)
+ 		return 0;
+ 
+ 	while (count) {
+ 		int i, n;
+ 
+ 		n = srp_map_finish_fr(state, req, ch, count);
+ 		if (unlikely(n < 0))
+ 			return n;
+ 
+ 		count -= n;
+ 		for (i = 0; i < n; i++)
+ 			state->sg = sg_next(state->sg);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int srp_map_sg_dma(struct srp_map_state *state, struct srp_rdma_ch *ch,
+ 			  struct srp_request *req, struct scatterlist *scat,
+ 			  int count)
++>>>>>>> 3b59b7a693b0 (IB/srp: Move code out of a loop)
  {
  	struct srp_target_port *target = ch->target;
  	struct srp_device *dev = target->srp_host->srp_dev;
* Unmerged path drivers/infiniband/ulp/srp/ib_srp.c
