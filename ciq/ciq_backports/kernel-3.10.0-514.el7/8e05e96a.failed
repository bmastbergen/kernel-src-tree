sched: Mark __schedule() stack frame as non-standard

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [kernel] revert "sched: Mark __schedule() stack frame as non-standard" (Josh Poimboeuf) [1347232]
Rebuild_FUZZ: 92.04%
commit-author Josh Poimboeuf <jpoimboe@redhat.com>
commit 8e05e96ac949c80704d0a38420bf60dcf18c938f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8e05e96a.failed

objtool reports the following warnings for __schedule():

  kernel/sched/core.o: warning: objtool:__schedule()+0x3c0: duplicate frame pointer save
  kernel/sched/core.o: warning: objtool:__schedule()+0x3fd: sibling call from callable instruction with changed frame pointer
  kernel/sched/core.o: warning: objtool:__schedule()+0x40a: call without frame pointer save/setup
  kernel/sched/core.o: warning: objtool:__schedule()+0x7fd: frame pointer state mismatch
  kernel/sched/core.o: warning: objtool:__schedule()+0x421: frame pointer state mismatch

Basically it's confused by two unusual attributes of the switch_to()
macro:

1. It saves prev's frame pointer to the old stack and restores next's
   frame pointer from the new stack.

2. For new tasks it jumps directly to ret_from_fork.

Eventually it would probably be a good idea to clean up the
ret_from_fork hack so that new tasks are created with a valid initial
stack, as suggested by Andy:

  https://lkml.kernel.org/r/CALCETrWsqCw4L1qKO9j9L5F+4ED4viuLQTFc=n1pKBZfFPQUFg@mail.gmail.com

Then __schedule() could return normally into the new code and objtool
hopefully wouldn't have a problem anymore.

In the meantime, mark its stack frame as non-standard so we can have a
baseline with no objtool warnings.  The marker also serves as a reminder
that this code could be improved a bit.

	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
	Cc: Bernd Petrovitsch <bernd@petrovitsch.priv.at>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Chris J Arges <chris.j.arges@canonical.com>
	Cc: Jiri Slaby <jslaby@suse.cz>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Michal Marek <mmarek@suse.cz>
	Cc: Namhyung Kim <namhyung@gmail.com>
	Cc: Pedro Alves <palves@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: live-patching@vger.kernel.org
Link: http://lkml.kernel.org/r/91190e324ebd7fcd01748d508d0dfd4693e84d91.1456719558.git.jpoimboe@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 8e05e96ac949c80704d0a38420bf60dcf18c938f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/core.c
diff --cc kernel/sched/core.c
index 8f3f375de9d1,641043dfc773..000000000000
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@@ -73,6 -73,8 +73,11 @@@
  #include <linux/init_task.h>
  #include <linux/binfmts.h>
  #include <linux/context_tracking.h>
++<<<<<<< HEAD
++=======
+ #include <linux/compiler.h>
+ #include <linux/frame.h>
++>>>>>>> 8e05e96ac949 (sched: Mark __schedule() stack frame as non-standard)
  
  #include <asm/switch_to.h>
  #include <asm/tlb.h>
@@@ -3267,24 -3279,17 +3272,25 @@@ need_resched
  		rq->curr = next;
  		++*switch_count;
  
 -		trace_sched_switch(preempt, prev, next);
 -		rq = context_switch(rq, prev, next); /* unlocks the rq */
 -		cpu = cpu_of(rq);
 -	} else {
 -		lockdep_unpin_lock(&rq->lock);
 +		context_switch(rq, prev, next); /* unlocks the rq */
 +		/*
 +		 * The context switch have flipped the stack from under us
 +		 * and restored the local variables which were saved when
 +		 * this task called schedule() in the past. prev == current
 +		 * is still correct, but it can be moved to another cpu/rq.
 +		 */
 +		cpu = smp_processor_id();
 +		rq = cpu_rq(cpu);
 +	} else
  		raw_spin_unlock_irq(&rq->lock);
 -	}
  
 -	balance_callback(rq);
 +	post_schedule(rq);
 +
 +	sched_preempt_enable_no_resched();
 +	if (need_resched())
 +		goto need_resched;
  }
+ STACK_FRAME_NON_STANDARD(__schedule); /* switch_to() */
  
  static inline void sched_submit_work(struct task_struct *tsk)
  {
* Unmerged path kernel/sched/core.c
