staging/rdma/hfi1: avoid passing pmtu

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: avoid passing pmtu (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 87.88%
commit-author Mike Marciniszyn <mike.marciniszyn@intel.com>
commit 1235bef8f04bf020b03f32e083e34bc91fc51343
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1235bef8.failed

It is in the qp.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 1235bef8f04bf020b03f32e083e34bc91fc51343)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/rc.c
diff --cc drivers/staging/hfi1/rc.c
index dd57d65aa9b2,d54d3ad1ed18..000000000000
--- a/drivers/staging/hfi1/rc.c
+++ b/drivers/staging/hfi1/rc.c
@@@ -88,24 -200,26 +88,35 @@@ static void start_timer(struct hfi1_qp 
   * @dev: the device for this QP
   * @qp: a pointer to the QP
   * @ohdr: a pointer to the IB header being constructed
++<<<<<<< HEAD:drivers/staging/hfi1/rc.c
 + * @pmtu: the path MTU
++=======
+  * @ps: the xmit packet state
++>>>>>>> 1235bef8f04b (staging/rdma/hfi1: avoid passing pmtu):drivers/staging/rdma/hfi1/rc.c
   *
   * Return 1 if constructed; otherwise, return 0.
   * Note that we are in the responder's side of the QP context.
   * Note the QP s_lock must be held.
   */
++<<<<<<< HEAD:drivers/staging/hfi1/rc.c
 +static int make_rc_ack(struct hfi1_ibdev *dev, struct hfi1_qp *qp,
 +		       struct hfi1_other_headers *ohdr, u32 pmtu)
++=======
+ static int make_rc_ack(struct hfi1_ibdev *dev, struct rvt_qp *qp,
+ 		       struct hfi1_other_headers *ohdr,
+ 		       struct hfi1_pkt_state *ps)
++>>>>>>> 1235bef8f04b (staging/rdma/hfi1: avoid passing pmtu):drivers/staging/rdma/hfi1/rc.c
  {
 -	struct rvt_ack_entry *e;
 +	struct hfi1_ack_entry *e;
  	u32 hwords;
  	u32 len;
  	u32 bth0;
  	u32 bth2;
  	int middle = 0;
+ 	u32 pmtu = qp->pmtu;
  
  	/* Don't send an ACK if we aren't supposed to. */
 -	if (!(ib_rvt_state_ops[qp->state] & RVT_PROCESS_RECV_OK))
 +	if (!(ib_hfi1_state_ops[qp->state] & HFI1_PROCESS_RECV_OK))
  		goto bail;
  
  	/* header size in 32-bit words LRH+BTH = (8+12)/4. */
@@@ -276,26 -390,25 +287,32 @@@ int hfi1_make_rc_req(struct hfi1_qp *qp
  	int middle = 0;
  	int delta;
  
 -	ps->s_txreq = get_txreq(ps->dev, qp);
 -	if (IS_ERR(ps->s_txreq))
 -		goto bail_no_tx;
 -
 -	ohdr = &ps->s_txreq->phdr.hdr.u.oth;
 +	ohdr = &priv->s_hdr->ibh.u.oth;
  	if (qp->remote_ah_attr.ah_flags & IB_AH_GRH)
 -		ohdr = &ps->s_txreq->phdr.hdr.u.l.oth;
 +		ohdr = &priv->s_hdr->ibh.u.l.oth;
 +
 +	/*
 +	 * The lock is needed to synchronize between the sending tasklet,
 +	 * the receive interrupt handler, and timeout re-sends.
 +	 */
 +	spin_lock_irqsave(&qp->s_lock, flags);
  
  	/* Sending responses has higher priority over sending requests. */
++<<<<<<< HEAD:drivers/staging/hfi1/rc.c
 +	if ((qp->s_flags & HFI1_S_RESP_PENDING) &&
 +	    make_rc_ack(dev, qp, ohdr, pmtu))
 +		goto done;
++=======
+ 	if ((qp->s_flags & RVT_S_RESP_PENDING) &&
+ 	    make_rc_ack(dev, qp, ohdr, ps))
+ 		return 1;
++>>>>>>> 1235bef8f04b (staging/rdma/hfi1: avoid passing pmtu):drivers/staging/rdma/hfi1/rc.c
  
 -	if (!(ib_rvt_state_ops[qp->state] & RVT_PROCESS_SEND_OK)) {
 -		if (!(ib_rvt_state_ops[qp->state] & RVT_FLUSH_SEND))
 +	if (!(ib_hfi1_state_ops[qp->state] & HFI1_PROCESS_SEND_OK)) {
 +		if (!(ib_hfi1_state_ops[qp->state] & HFI1_FLUSH_SEND))
  			goto bail;
  		/* We are in the error state, flush the work request. */
 -		smp_read_barrier_depends(); /* see post_one_send() */
 -		if (qp->s_last == ACCESS_ONCE(qp->s_head))
 +		if (qp->s_last == qp->s_head)
  			goto bail;
  		/* If DMAs are in progress, we can't flush immediately. */
  		if (atomic_read(&priv->s_iowait.sdma_busy)) {
* Unmerged path drivers/staging/hfi1/rc.c
