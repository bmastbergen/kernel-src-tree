rhashtable: Make selftest modular

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Geert Uytterhoeven <geert@linux-m68k.org>
commit 9d6dbe1bbaf8bf03804c164fb67a98646bf2f622
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9d6dbe1b.failed

Allow the selftest on the resizable hash table to be built modular, just
like all other tests that do not depend on DEBUG_KERNEL.

	Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9d6dbe1bbaf8bf03804c164fb67a98646bf2f622)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/Kconfig.debug
#	lib/Makefile
#	lib/rhashtable.c
diff --cc lib/Kconfig.debug
index b42d9b05227b,a8f3c9993229..000000000000
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@@ -1349,6 -1550,51 +1349,54 @@@ config INTERVAL_TREE_TES
  	help
  	  A benchmark measuring the performance of the interval tree library
  
++<<<<<<< HEAD
++=======
+ config PERCPU_TEST
+ 	tristate "Per cpu operations test"
+ 	depends on m && DEBUG_KERNEL
+ 	help
+ 	  Enable this option to build test module which validates per-cpu
+ 	  operations.
+ 
+ 	  If unsure, say N.
+ 
+ config ATOMIC64_SELFTEST
+ 	bool "Perform an atomic64_t self-test at boot"
+ 	help
+ 	  Enable this option to test the atomic64_t functions at boot.
+ 
+ 	  If unsure, say N.
+ 
+ config ASYNC_RAID6_TEST
+ 	tristate "Self test for hardware accelerated raid6 recovery"
+ 	depends on ASYNC_RAID6_RECOV
+ 	select ASYNC_MEMCPY
+ 	---help---
+ 	  This is a one-shot self test that permutes through the
+ 	  recovery of all the possible two disk failure scenarios for a
+ 	  N-disk array.  Recovery is performed with the asynchronous
+ 	  raid6 recovery routines, and will optionally use an offload
+ 	  engine if one is available.
+ 
+ 	  If unsure, say N.
+ 
+ config TEST_STRING_HELPERS
+ 	tristate "Test functions located in the string_helpers module at runtime"
+ 
+ config TEST_KSTRTOX
+ 	tristate "Test kstrto*() family of functions at runtime"
+ 
+ config TEST_RHASHTABLE
+ 	tristate "Perform selftest on resizable hash table"
+ 	default n
+ 	help
+ 	  Enable this option to test the rhashtable functions at boot.
+ 
+ 	  If unsure, say N.
+ 
+ endmenu # runtime tests
+ 
++>>>>>>> 9d6dbe1bbaf8 (rhashtable: Make selftest modular)
  config PROVIDE_OHCI1394_DMA_INIT
  	bool "Remote debugging over FireWire early on boot"
  	depends on PCI && X86
diff --cc lib/Makefile
index d25b4f7d5137,a8cf98d14199..000000000000
--- a/lib/Makefile
+++ b/lib/Makefile
@@@ -31,6 -31,11 +31,14 @@@ obj-y += string_helpers.
  obj-$(CONFIG_TEST_STRING_HELPERS) += test-string_helpers.o
  obj-y += kstrtox.o
  obj-$(CONFIG_TEST_KSTRTOX) += test-kstrtox.o
++<<<<<<< HEAD
++=======
+ obj-$(CONFIG_TEST_LKM) += test_module.o
+ obj-$(CONFIG_TEST_USER_COPY) += test_user_copy.o
+ obj-$(CONFIG_TEST_BPF) += test_bpf.o
+ obj-$(CONFIG_TEST_FIRMWARE) += test_firmware.o
+ obj-$(CONFIG_TEST_RHASHTABLE) += test_rhashtable.o
++>>>>>>> 9d6dbe1bbaf8 (rhashtable: Make selftest modular)
  
  ifeq ($(CONFIG_DEBUG_KOBJECT),y)
  CFLAGS_kobject.o += -DDEBUG
diff --cc lib/rhashtable.c
index be20e9720492,c41e21096373..000000000000
--- a/lib/rhashtable.c
+++ b/lib/rhashtable.c
@@@ -549,214 -923,15 +549,217 @@@ EXPORT_SYMBOL_GPL(rhashtable_init)
   * has to make sure that no resizing may happen by unpublishing the hashtable
   * and waiting for the quiescent cycle before releasing the bucket array.
   */
 -void rhashtable_destroy(struct rhashtable *ht)
 +void rhashtable_destroy(const struct rhashtable *ht)
  {
 -	ht->being_destroyed = true;
 +	bucket_table_free(ht->tbl);
 +}
 +EXPORT_SYMBOL_GPL(rhashtable_destroy);
++<<<<<<< HEAD
 +
 +/**************************************************************************
 + * Self Test
 + **************************************************************************/
 +
 +#ifdef CONFIG_TEST_RHASHTABLE
  
 -	if (ht->p.grow_decision || ht->p.shrink_decision)
 -		cancel_work_sync(&ht->run_work);
 +#define TEST_HT_SIZE	8
 +#define TEST_ENTRIES	2048
 +#define TEST_PTR	((void *) 0xdeadbeef)
 +#define TEST_NEXPANDS	4
  
 -	mutex_lock(&ht->mutex);
 -	bucket_table_free(rht_dereference(ht->tbl, ht));
 -	mutex_unlock(&ht->mutex);
 +static int test_mutex_is_held(void)
 +{
 +	return 1;
  }
 -EXPORT_SYMBOL_GPL(rhashtable_destroy);
 +
 +struct test_obj {
 +	void			*ptr;
 +	int			value;
 +	struct rhash_head	node;
 +};
 +
 +static int __init test_rht_lookup(struct rhashtable *ht)
 +{
 +	unsigned int i;
 +
 +	for (i = 0; i < TEST_ENTRIES * 2; i++) {
 +		struct test_obj *obj;
 +		bool expected = !(i % 2);
 +		u32 key = i;
 +
 +		obj = rhashtable_lookup(ht, &key);
 +
 +		if (expected && !obj) {
 +			pr_warn("Test failed: Could not find key %u\n", key);
 +			return -ENOENT;
 +		} else if (!expected && obj) {
 +			pr_warn("Test failed: Unexpected entry found for key %u\n",
 +				key);
 +			return -EEXIST;
 +		} else if (expected && obj) {
 +			if (obj->ptr != TEST_PTR || obj->value != i) {
 +				pr_warn("Test failed: Lookup value mismatch %p!=%p, %u!=%u\n",
 +					obj->ptr, TEST_PTR, obj->value, i);
 +				return -EINVAL;
 +			}
 +		}
 +	}
 +
 +	return 0;
 +}
 +
 +static void test_bucket_stats(struct rhashtable *ht, bool quiet)
 +{
 +	unsigned int cnt, rcu_cnt, i, total = 0;
 +	struct rhash_head *pos;
 +	struct test_obj *obj;
 +	struct bucket_table *tbl;
 +
 +	tbl = rht_dereference_rcu(ht->tbl, ht);
 +	for (i = 0; i < tbl->size; i++) {
 +		rcu_cnt = cnt = 0;
 +
 +		if (!quiet)
 +			pr_info(" [%#4x/%zu]", i, tbl->size);
 +
 +		rht_for_each_entry_rcu(obj, pos, tbl, i, node) {
 +			cnt++;
 +			total++;
 +			if (!quiet)
 +				pr_cont(" [%p],", obj);
 +		}
 +
 +		rht_for_each_entry_rcu(obj, pos, tbl, i, node)
 +			rcu_cnt++;
 +
 +		if (rcu_cnt != cnt)
 +			pr_warn("Test failed: Chain count mismach %d != %d",
 +				cnt, rcu_cnt);
 +
 +		if (!quiet)
 +			pr_cont("\n  [%#x] first element: %p, chain length: %u\n",
 +				i, tbl->buckets[i], cnt);
 +	}
 +
 +	pr_info("  Traversal complete: counted=%u, nelems=%zu, entries=%d\n",
 +		total, ht->nelems, TEST_ENTRIES);
 +
 +	if (total != ht->nelems || total != TEST_ENTRIES)
 +		pr_warn("Test failed: Total count mismatch ^^^");
 +}
 +
 +static int __init test_rhashtable(struct rhashtable *ht)
 +{
 +	struct bucket_table *tbl;
 +	struct test_obj *obj;
 +	struct rhash_head *pos, *next;
 +	int err;
 +	unsigned int i;
 +
 +	/*
 +	 * Insertion Test:
 +	 * Insert TEST_ENTRIES into table with all keys even numbers
 +	 */
 +	pr_info("  Adding %d keys\n", TEST_ENTRIES);
 +	for (i = 0; i < TEST_ENTRIES; i++) {
 +		struct test_obj *obj;
 +
 +		obj = kzalloc(sizeof(*obj), GFP_KERNEL);
 +		if (!obj) {
 +			err = -ENOMEM;
 +			goto error;
 +		}
 +
 +		obj->ptr = TEST_PTR;
 +		obj->value = i * 2;
 +
 +		rhashtable_insert(ht, &obj->node);
 +	}
 +
 +	rcu_read_lock();
 +	test_bucket_stats(ht, true);
 +	test_rht_lookup(ht);
 +	rcu_read_unlock();
 +
 +	for (i = 0; i < TEST_NEXPANDS; i++) {
 +		pr_info("  Table expansion iteration %u...\n", i);
 +		rhashtable_expand(ht);
 +
 +		rcu_read_lock();
 +		pr_info("  Verifying lookups...\n");
 +		test_rht_lookup(ht);
 +		rcu_read_unlock();
 +	}
 +
 +	for (i = 0; i < TEST_NEXPANDS; i++) {
 +		pr_info("  Table shrinkage iteration %u...\n", i);
 +		rhashtable_shrink(ht);
 +
 +		rcu_read_lock();
 +		pr_info("  Verifying lookups...\n");
 +		test_rht_lookup(ht);
 +		rcu_read_unlock();
 +	}
 +
 +	rcu_read_lock();
 +	test_bucket_stats(ht, true);
 +	rcu_read_unlock();
 +
 +	pr_info("  Deleting %d keys\n", TEST_ENTRIES);
 +	for (i = 0; i < TEST_ENTRIES; i++) {
 +		u32 key = i * 2;
 +
 +		obj = rhashtable_lookup(ht, &key);
 +		BUG_ON(!obj);
 +
 +		rhashtable_remove(ht, &obj->node);
 +		kfree(obj);
 +	}
 +
 +	return 0;
 +
 +error:
 +	tbl = rht_dereference_rcu(ht->tbl, ht);
 +	for (i = 0; i < tbl->size; i++)
 +		rht_for_each_entry_safe(obj, pos, next, tbl, i, node)
 +			kfree(obj);
 +
 +	return err;
 +}
 +
 +static int __init test_rht_init(void)
 +{
 +	struct rhashtable ht;
 +	struct rhashtable_params params = {
 +		.nelem_hint = TEST_HT_SIZE,
 +		.head_offset = offsetof(struct test_obj, node),
 +		.key_offset = offsetof(struct test_obj, value),
 +		.key_len = sizeof(int),
 +		.hashfn = jhash,
 +		.mutex_is_held = &test_mutex_is_held,
 +		.grow_decision = rht_grow_above_75,
 +		.shrink_decision = rht_shrink_below_30,
 +	};
 +	int err;
 +
 +	pr_info("Running resizable hashtable tests...\n");
 +
 +	err = rhashtable_init(&ht, &params);
 +	if (err < 0) {
 +		pr_warn("Test failed: Unable to initialize hashtable: %d\n",
 +			err);
 +		return err;
 +	}
 +
 +	err = test_rhashtable(&ht);
 +
 +	rhashtable_destroy(&ht);
 +
 +	return err;
 +}
 +
 +subsys_initcall(test_rht_init);
 +
 +#endif /* CONFIG_TEST_RHASHTABLE */
++=======
++>>>>>>> 9d6dbe1bbaf8 (rhashtable: Make selftest modular)
* Unmerged path lib/Kconfig.debug
* Unmerged path lib/Makefile
* Unmerged path lib/rhashtable.c
diff --git a/lib/test_rhashtable.c b/lib/test_rhashtable.c
new file mode 100644
index 000000000000..1dfeba73fc74
--- /dev/null
+++ b/lib/test_rhashtable.c
@@ -0,0 +1,227 @@
+/*
+ * Resizable, Scalable, Concurrent Hash Table
+ *
+ * Copyright (c) 2014 Thomas Graf <tgraf@suug.ch>
+ * Copyright (c) 2008-2014 Patrick McHardy <kaber@trash.net>
+ *
+ * Based on the following paper:
+ * https://www.usenix.org/legacy/event/atc11/tech/final_files/Triplett.pdf
+ *
+ * Code partially derived from nft_hash
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/**************************************************************************
+ * Self Test
+ **************************************************************************/
+
+#include <linux/init.h>
+#include <linux/jhash.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/rcupdate.h>
+#include <linux/rhashtable.h>
+#include <linux/slab.h>
+
+
+#define TEST_HT_SIZE	8
+#define TEST_ENTRIES	2048
+#define TEST_PTR	((void *) 0xdeadbeef)
+#define TEST_NEXPANDS	4
+
+struct test_obj {
+	void			*ptr;
+	int			value;
+	struct rhash_head	node;
+};
+
+static int __init test_rht_lookup(struct rhashtable *ht)
+{
+	unsigned int i;
+
+	for (i = 0; i < TEST_ENTRIES * 2; i++) {
+		struct test_obj *obj;
+		bool expected = !(i % 2);
+		u32 key = i;
+
+		obj = rhashtable_lookup(ht, &key);
+
+		if (expected && !obj) {
+			pr_warn("Test failed: Could not find key %u\n", key);
+			return -ENOENT;
+		} else if (!expected && obj) {
+			pr_warn("Test failed: Unexpected entry found for key %u\n",
+				key);
+			return -EEXIST;
+		} else if (expected && obj) {
+			if (obj->ptr != TEST_PTR || obj->value != i) {
+				pr_warn("Test failed: Lookup value mismatch %p!=%p, %u!=%u\n",
+					obj->ptr, TEST_PTR, obj->value, i);
+				return -EINVAL;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static void test_bucket_stats(struct rhashtable *ht, bool quiet)
+{
+	unsigned int cnt, rcu_cnt, i, total = 0;
+	struct rhash_head *pos;
+	struct test_obj *obj;
+	struct bucket_table *tbl;
+
+	tbl = rht_dereference_rcu(ht->tbl, ht);
+	for (i = 0; i < tbl->size; i++) {
+		rcu_cnt = cnt = 0;
+
+		if (!quiet)
+			pr_info(" [%#4x/%zu]", i, tbl->size);
+
+		rht_for_each_entry_rcu(obj, pos, tbl, i, node) {
+			cnt++;
+			total++;
+			if (!quiet)
+				pr_cont(" [%p],", obj);
+		}
+
+		rht_for_each_entry_rcu(obj, pos, tbl, i, node)
+			rcu_cnt++;
+
+		if (rcu_cnt != cnt)
+			pr_warn("Test failed: Chain count mismach %d != %d",
+				cnt, rcu_cnt);
+
+		if (!quiet)
+			pr_cont("\n  [%#x] first element: %p, chain length: %u\n",
+				i, tbl->buckets[i], cnt);
+	}
+
+	pr_info("  Traversal complete: counted=%u, nelems=%u, entries=%d\n",
+		total, atomic_read(&ht->nelems), TEST_ENTRIES);
+
+	if (total != atomic_read(&ht->nelems) || total != TEST_ENTRIES)
+		pr_warn("Test failed: Total count mismatch ^^^");
+}
+
+static int __init test_rhashtable(struct rhashtable *ht)
+{
+	struct bucket_table *tbl;
+	struct test_obj *obj;
+	struct rhash_head *pos, *next;
+	int err;
+	unsigned int i;
+
+	/*
+	 * Insertion Test:
+	 * Insert TEST_ENTRIES into table with all keys even numbers
+	 */
+	pr_info("  Adding %d keys\n", TEST_ENTRIES);
+	for (i = 0; i < TEST_ENTRIES; i++) {
+		struct test_obj *obj;
+
+		obj = kzalloc(sizeof(*obj), GFP_KERNEL);
+		if (!obj) {
+			err = -ENOMEM;
+			goto error;
+		}
+
+		obj->ptr = TEST_PTR;
+		obj->value = i * 2;
+
+		rhashtable_insert(ht, &obj->node);
+	}
+
+	rcu_read_lock();
+	test_bucket_stats(ht, true);
+	test_rht_lookup(ht);
+	rcu_read_unlock();
+
+	for (i = 0; i < TEST_NEXPANDS; i++) {
+		pr_info("  Table expansion iteration %u...\n", i);
+		mutex_lock(&ht->mutex);
+		rhashtable_expand(ht);
+		mutex_unlock(&ht->mutex);
+
+		rcu_read_lock();
+		pr_info("  Verifying lookups...\n");
+		test_rht_lookup(ht);
+		rcu_read_unlock();
+	}
+
+	for (i = 0; i < TEST_NEXPANDS; i++) {
+		pr_info("  Table shrinkage iteration %u...\n", i);
+		mutex_lock(&ht->mutex);
+		rhashtable_shrink(ht);
+		mutex_unlock(&ht->mutex);
+
+		rcu_read_lock();
+		pr_info("  Verifying lookups...\n");
+		test_rht_lookup(ht);
+		rcu_read_unlock();
+	}
+
+	rcu_read_lock();
+	test_bucket_stats(ht, true);
+	rcu_read_unlock();
+
+	pr_info("  Deleting %d keys\n", TEST_ENTRIES);
+	for (i = 0; i < TEST_ENTRIES; i++) {
+		u32 key = i * 2;
+
+		obj = rhashtable_lookup(ht, &key);
+		BUG_ON(!obj);
+
+		rhashtable_remove(ht, &obj->node);
+		kfree(obj);
+	}
+
+	return 0;
+
+error:
+	tbl = rht_dereference_rcu(ht->tbl, ht);
+	for (i = 0; i < tbl->size; i++)
+		rht_for_each_entry_safe(obj, pos, next, tbl, i, node)
+			kfree(obj);
+
+	return err;
+}
+
+static int __init test_rht_init(void)
+{
+	struct rhashtable ht;
+	struct rhashtable_params params = {
+		.nelem_hint = TEST_HT_SIZE,
+		.head_offset = offsetof(struct test_obj, node),
+		.key_offset = offsetof(struct test_obj, value),
+		.key_len = sizeof(int),
+		.hashfn = jhash,
+		.nulls_base = (3U << RHT_BASE_SHIFT),
+		.grow_decision = rht_grow_above_75,
+		.shrink_decision = rht_shrink_below_30,
+	};
+	int err;
+
+	pr_info("Running resizable hashtable tests...\n");
+
+	err = rhashtable_init(&ht, &params);
+	if (err < 0) {
+		pr_warn("Test failed: Unable to initialize hashtable: %d\n",
+			err);
+		return err;
+	}
+
+	err = test_rhashtable(&ht);
+
+	rhashtable_destroy(&ht);
+
+	return err;
+}
+
+module_init(test_rht_init);
+
+MODULE_LICENSE("GPL v2");
