nfs42: add CLONE proc functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peng Tao <tao.peng@primarydata.com>
commit e5341f3a5762d17be9cdd06257c02c0098bdcab8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e5341f3a.failed

	Signed-off-by: Peng Tao <tao.peng@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit e5341f3a5762d17be9cdd06257c02c0098bdcab8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs42.h
#	fs/nfs/nfs42proc.c
#	fs/nfs/nfs4proc.c
#	include/linux/nfs_fs_sb.h
diff --cc fs/nfs/nfs42.h
index 7afb8947dfdf,b587ccd31083..000000000000
--- a/fs/nfs/nfs42.h
+++ b/fs/nfs/nfs42.h
@@@ -9,8 -15,8 +9,14 @@@
  int nfs42_proc_allocate(struct file *, loff_t, loff_t);
  int nfs42_proc_deallocate(struct file *, loff_t, loff_t);
  loff_t nfs42_proc_llseek(struct file *, loff_t, int);
++<<<<<<< HEAD
 +
 +/* nfs4.2xdr.h */
 +extern struct rpc_procinfo nfs4_2_procedures[];
++=======
+ int nfs42_proc_layoutstats_generic(struct nfs_server *,
+ 				   struct nfs42_layoutstat_data *);
+ int nfs42_proc_clone(struct file *, struct file *, loff_t, loff_t, loff_t);
++>>>>>>> e5341f3a5762 (nfs42: add CLONE proc functions)
  
  #endif /* __LINUX_FS_NFS_NFS4_2_H */
diff --cc fs/nfs/nfs42proc.c
index 0899db096637,3e92a3cde15d..000000000000
--- a/fs/nfs/nfs42proc.c
+++ b/fs/nfs/nfs42proc.c
@@@ -183,3 -188,157 +183,160 @@@ loff_t nfs42_proc_llseek(struct file *f
  
  	return err;
  }
++<<<<<<< HEAD
++=======
+ 
+ 
+ static void
+ nfs42_layoutstat_prepare(struct rpc_task *task, void *calldata)
+ {
+ 	struct nfs42_layoutstat_data *data = calldata;
+ 	struct nfs_server *server = NFS_SERVER(data->args.inode);
+ 
+ 	nfs41_setup_sequence(nfs4_get_session(server), &data->args.seq_args,
+ 			     &data->res.seq_res, task);
+ }
+ 
+ static void
+ nfs42_layoutstat_done(struct rpc_task *task, void *calldata)
+ {
+ 	struct nfs42_layoutstat_data *data = calldata;
+ 
+ 	if (!nfs4_sequence_done(task, &data->res.seq_res))
+ 		return;
+ 
+ 	switch (task->tk_status) {
+ 	case 0:
+ 		break;
+ 	case -ENOTSUPP:
+ 	case -EOPNOTSUPP:
+ 		NFS_SERVER(data->inode)->caps &= ~NFS_CAP_LAYOUTSTATS;
+ 	default:
+ 		dprintk("%s server returns %d\n", __func__, task->tk_status);
+ 	}
+ }
+ 
+ static void
+ nfs42_layoutstat_release(void *calldata)
+ {
+ 	struct nfs42_layoutstat_data *data = calldata;
+ 	struct nfs_server *nfss = NFS_SERVER(data->args.inode);
+ 
+ 	if (nfss->pnfs_curr_ld->cleanup_layoutstats)
+ 		nfss->pnfs_curr_ld->cleanup_layoutstats(data);
+ 
+ 	pnfs_put_layout_hdr(NFS_I(data->args.inode)->layout);
+ 	smp_mb__before_atomic();
+ 	clear_bit(NFS_INO_LAYOUTSTATS, &NFS_I(data->args.inode)->flags);
+ 	smp_mb__after_atomic();
+ 	nfs_iput_and_deactive(data->inode);
+ 	kfree(data->args.devinfo);
+ 	kfree(data);
+ }
+ 
+ static const struct rpc_call_ops nfs42_layoutstat_ops = {
+ 	.rpc_call_prepare = nfs42_layoutstat_prepare,
+ 	.rpc_call_done = nfs42_layoutstat_done,
+ 	.rpc_release = nfs42_layoutstat_release,
+ };
+ 
+ int nfs42_proc_layoutstats_generic(struct nfs_server *server,
+ 				   struct nfs42_layoutstat_data *data)
+ {
+ 	struct rpc_message msg = {
+ 		.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTSTATS],
+ 		.rpc_argp = &data->args,
+ 		.rpc_resp = &data->res,
+ 	};
+ 	struct rpc_task_setup task_setup = {
+ 		.rpc_client = server->client,
+ 		.rpc_message = &msg,
+ 		.callback_ops = &nfs42_layoutstat_ops,
+ 		.callback_data = data,
+ 		.flags = RPC_TASK_ASYNC,
+ 	};
+ 	struct rpc_task *task;
+ 
+ 	data->inode = nfs_igrab_and_active(data->args.inode);
+ 	if (!data->inode) {
+ 		nfs42_layoutstat_release(data);
+ 		return -EAGAIN;
+ 	}
+ 	nfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 0);
+ 	task = rpc_run_task(&task_setup);
+ 	if (IS_ERR(task))
+ 		return PTR_ERR(task);
+ 	return 0;
+ }
+ 
+ static int _nfs42_proc_clone(struct rpc_message *msg, struct file *src_f,
+ 			     struct file *dst_f, loff_t src_offset,
+ 			     loff_t dst_offset, loff_t count)
+ {
+ 	struct inode *src_inode = file_inode(src_f);
+ 	struct inode *dst_inode = file_inode(dst_f);
+ 	struct nfs_server *server = NFS_SERVER(dst_inode);
+ 	struct nfs42_clone_args args = {
+ 		.src_fh = NFS_FH(src_inode),
+ 		.dst_fh = NFS_FH(dst_inode),
+ 		.src_offset = src_offset,
+ 		.dst_offset = dst_offset,
+ 		.dst_bitmask = server->cache_consistency_bitmask,
+ 	};
+ 	struct nfs42_clone_res res = {
+ 		.server	= server,
+ 	};
+ 	int status;
+ 
+ 	msg->rpc_argp = &args;
+ 	msg->rpc_resp = &res;
+ 
+ 	status = nfs42_set_rw_stateid(&args.src_stateid, src_f, FMODE_READ);
+ 	if (status)
+ 		return status;
+ 
+ 	status = nfs42_set_rw_stateid(&args.dst_stateid, dst_f, FMODE_WRITE);
+ 	if (status)
+ 		return status;
+ 
+ 	res.dst_fattr = nfs_alloc_fattr();
+ 	if (!res.dst_fattr)
+ 		return -ENOMEM;
+ 
+ 	status = nfs4_call_sync(server->client, server, msg,
+ 				&args.seq_args, &res.seq_res, 0);
+ 	if (status == 0)
+ 		status = nfs_post_op_update_inode(dst_inode, res.dst_fattr);
+ 
+ 	kfree(res.dst_fattr);
+ 	return status;
+ }
+ 
+ int nfs42_proc_clone(struct file *src_f, struct file *dst_f,
+ 		     loff_t src_offset, loff_t dst_offset, loff_t count)
+ {
+ 	struct rpc_message msg = {
+ 		.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLONE],
+ 	};
+ 	struct inode *inode = file_inode(src_f);
+ 	struct nfs_server *server = NFS_SERVER(file_inode(src_f));
+ 	struct nfs4_exception exception = { };
+ 	int err;
+ 
+ 	if (!nfs_server_capable(inode, NFS_CAP_CLONE))
+ 		return -EOPNOTSUPP;
+ 
+ 	do {
+ 		err = _nfs42_proc_clone(&msg, src_f, dst_f, src_offset,
+ 					dst_offset, count);
+ 		if (err == -ENOTSUPP || err == -EOPNOTSUPP) {
+ 			NFS_SERVER(inode)->caps &= ~NFS_CAP_CLONE;
+ 			return -EOPNOTSUPP;
+ 		}
+ 		err = nfs4_handle_exception(server, err, &exception);
+ 	} while (exception.retry);
+ 
+ 	return err;
+ 
+ }
++>>>>>>> e5341f3a5762 (nfs42: add CLONE proc functions)
diff --cc fs/nfs/nfs4proc.c
index a94bb4181044,9688b1a9787f..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -8683,7 -8728,9 +8683,13 @@@ static const struct nfs4_minor_version_
  		| NFS_CAP_ATOMIC_OPEN_V1
  		| NFS_CAP_ALLOCATE
  		| NFS_CAP_DEALLOCATE
++<<<<<<< HEAD
 +		| NFS_CAP_SEEK,
++=======
+ 		| NFS_CAP_SEEK
+ 		| NFS_CAP_LAYOUTSTATS
+ 		| NFS_CAP_CLONE,
++>>>>>>> e5341f3a5762 (nfs42: add CLONE proc functions)
  	.init_client = nfs41_init_client,
  	.shutdown_client = nfs41_shutdown_client,
  	.match_stateid = nfs41_match_stateid,
diff --cc include/linux/nfs_fs_sb.h
index 605f1d7ae5fa,a50de1002b20..000000000000
--- a/include/linux/nfs_fs_sb.h
+++ b/include/linux/nfs_fs_sb.h
@@@ -242,5 -242,7 +242,10 @@@ struct nfs_server 
  #define NFS_CAP_SEEK		(1U << 19)
  #define NFS_CAP_ALLOCATE	(1U << 20)
  #define NFS_CAP_DEALLOCATE	(1U << 21)
++<<<<<<< HEAD
++=======
+ #define NFS_CAP_LAYOUTSTATS	(1U << 22)
+ #define NFS_CAP_CLONE		(1U << 23)
++>>>>>>> e5341f3a5762 (nfs42: add CLONE proc functions)
  
  #endif
* Unmerged path fs/nfs/nfs42.h
* Unmerged path fs/nfs/nfs42proc.c
* Unmerged path fs/nfs/nfs4proc.c
* Unmerged path include/linux/nfs_fs_sb.h
