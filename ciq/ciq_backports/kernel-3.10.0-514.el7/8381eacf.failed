ipv6: Make __ipv6_select_ident static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vlad Yasevich <vyasevich@gmail.com>
commit 8381eacf5c3b35cf7755f4bc521c4d56d24c1cd9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8381eacf.failed

Make __ipv6_select_ident() static as it isn't used outside
the file.

Fixes: 0508c07f5e0c9 (ipv6: Select fragment id during UFO segmentation if not set.)
	Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8381eacf5c3b35cf7755f4bc521c4d56d24c1cd9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/output_core.c
diff --cc net/ipv6/output_core.c
index f55ca250c2c9,74581f706c4d..000000000000
--- a/net/ipv6/output_core.c
+++ b/net/ipv6/output_core.c
@@@ -6,6 -6,58 +6,60 @@@
  #include <net/ipv6.h>
  #include <net/ip6_fib.h>
  #include <net/addrconf.h>
++<<<<<<< HEAD
++=======
+ #include <net/secure_seq.h>
+ 
+ static u32 __ipv6_select_ident(u32 hashrnd, struct in6_addr *dst,
+ 			       struct in6_addr *src)
+ {
+ 	u32 hash, id;
+ 
+ 	hash = __ipv6_addr_jhash(dst, hashrnd);
+ 	hash = __ipv6_addr_jhash(src, hash);
+ 
+ 	/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,
+ 	 * set the hight order instead thus minimizing possible future
+ 	 * collisions.
+ 	 */
+ 	id = ip_idents_reserve(hash, 1);
+ 	if (unlikely(!id))
+ 		id = 1 << 31;
+ 
+ 	return id;
+ }
+ 
+ /* This function exists only for tap drivers that must support broken
+  * clients requesting UFO without specifying an IPv6 fragment ID.
+  *
+  * This is similar to ipv6_select_ident() but we use an independent hash
+  * seed to limit information leakage.
+  *
+  * The network header must be set before calling this.
+  */
+ void ipv6_proxy_select_ident(struct sk_buff *skb)
+ {
+ 	static u32 ip6_proxy_idents_hashrnd __read_mostly;
+ 	struct in6_addr buf[2];
+ 	struct in6_addr *addrs;
+ 	u32 id;
+ 
+ 	addrs = skb_header_pointer(skb,
+ 				   skb_network_offset(skb) +
+ 				   offsetof(struct ipv6hdr, saddr),
+ 				   sizeof(buf), buf);
+ 	if (!addrs)
+ 		return;
+ 
+ 	net_get_random_once(&ip6_proxy_idents_hashrnd,
+ 			    sizeof(ip6_proxy_idents_hashrnd));
+ 
+ 	id = __ipv6_select_ident(ip6_proxy_idents_hashrnd,
+ 				 &addrs[1], &addrs[0]);
+ 	skb_shinfo(skb)->ip6_frag_id = htonl(id);
+ }
+ EXPORT_SYMBOL_GPL(ipv6_proxy_select_ident);
++>>>>>>> 8381eacf5c3b (ipv6: Make __ipv6_select_ident static)
  
  void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)
  {
* Unmerged path net/ipv6/output_core.c
