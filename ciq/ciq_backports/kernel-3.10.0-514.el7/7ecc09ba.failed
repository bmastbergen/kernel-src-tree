mmc: tmio: tmio_mmc_host has .dma

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
commit 7ecc09bab1e856e6730a4dd8a3bc1c28bb6ab3be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7ecc09ba.failed

Current .dma is implemented under tmio_mmc_data.
It goes to tmio_mmc_host by this patch.

	Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
	Acked-by: Lee Jones <lee.jones@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 7ecc09bab1e856e6730a4dd8a3bc1c28bb6ab3be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sh_mobile_sdhi.c
#	drivers/mmc/host/tmio_mmc_dma.c
#	include/linux/mfd/tmio.h
diff --cc drivers/mmc/host/sh_mobile_sdhi.c
index 79ee6f0c45bd,288e78d2c7a1..000000000000
--- a/drivers/mmc/host/sh_mobile_sdhi.c
+++ b/drivers/mmc/host/sh_mobile_sdhi.c
@@@ -154,6 -207,14 +154,17 @@@ static int sh_mobile_sdhi_probe(struct 
  		goto eclkget;
  	}
  
++<<<<<<< HEAD
++=======
+ 	host = tmio_mmc_host_alloc(pdev);
+ 	if (!host) {
+ 		ret = -ENOMEM;
+ 		goto eprobe;
+ 	}
+ 
+ 	host->dma		= dma_priv;
+ 
++>>>>>>> 7ecc09bab1e8 (mmc: tmio: tmio_mmc_host has .dma)
  	mmc_data->clk_enable = sh_mobile_sdhi_clk_enable;
  	mmc_data->clk_disable = sh_mobile_sdhi_clk_disable;
  	mmc_data->capabilities = MMC_CAP_MMC_HIGHSPEED;
@@@ -185,6 -240,9 +196,12 @@@
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	dma_priv->alignment_shift = 1; /* 2-byte alignment */
+ 	dma_priv->filter = shdma_chan_filter;
+ 
++>>>>>>> 7ecc09bab1e8 (mmc: tmio: tmio_mmc_host has .dma)
  	/*
  	 * All SDHI blocks support 2-byte and larger block sizes in 4-bit
  	 * bus width mode.
diff --cc drivers/mmc/host/tmio_mmc_dma.c
index a8aaa7871c0d,6c214d60bbb6..000000000000
--- a/drivers/mmc/host/tmio_mmc_dma.c
+++ b/drivers/mmc/host/tmio_mmc_dma.c
@@@ -264,7 -260,8 +262,12 @@@ out
  void tmio_mmc_request_dma(struct tmio_mmc_host *host, struct tmio_mmc_data *pdata)
  {
  	/* We can only either use DMA for both Tx and Rx or not use it at all */
++<<<<<<< HEAD
 +	if (!pdata->dma)
++=======
+ 	if (!host->dma || (!host->pdev->dev.of_node &&
+ 		(!host->dma->chan_priv_tx || !host->dma->chan_priv_rx)))
++>>>>>>> 7ecc09bab1e8 (mmc: tmio: tmio_mmc_host has .dma)
  		return;
  
  	if (!host->chan_tx && !host->chan_rx) {
@@@ -280,33 -277,39 +283,58 @@@
  		dma_cap_zero(mask);
  		dma_cap_set(DMA_SLAVE, mask);
  
++<<<<<<< HEAD
 +		host->chan_tx = dma_request_channel(mask, pdata->dma->filter,
 +						    pdata->dma->chan_priv_tx);
++=======
+ 		host->chan_tx = dma_request_slave_channel_compat(mask,
+ 					host->dma->filter, host->dma->chan_priv_tx,
+ 					&host->pdev->dev, "tx");
++>>>>>>> 7ecc09bab1e8 (mmc: tmio: tmio_mmc_host has .dma)
  		dev_dbg(&host->pdev->dev, "%s: TX: got channel %p\n", __func__,
  			host->chan_tx);
  
  		if (!host->chan_tx)
  			return;
  
++<<<<<<< HEAD
 +		cfg.slave_id = pdata->dma->slave_id_tx;
++=======
+ 		if (host->dma->chan_priv_tx)
+ 			cfg.slave_id = host->dma->slave_id_tx;
++>>>>>>> 7ecc09bab1e8 (mmc: tmio: tmio_mmc_host has .dma)
  		cfg.direction = DMA_MEM_TO_DEV;
 -		cfg.dst_addr = res->start + (CTL_SD_DATA_PORT << host->pdata->bus_shift);
 -		cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
 +		cfg.dst_addr = res->start + (CTL_SD_DATA_PORT << host->bus_shift);
  		cfg.src_addr = 0;
  		ret = dmaengine_slave_config(host->chan_tx, &cfg);
  		if (ret < 0)
  			goto ecfgtx;
  
++<<<<<<< HEAD
 +		host->chan_rx = dma_request_channel(mask, pdata->dma->filter,
 +						    pdata->dma->chan_priv_rx);
++=======
+ 		host->chan_rx = dma_request_slave_channel_compat(mask,
+ 					host->dma->filter, host->dma->chan_priv_rx,
+ 					&host->pdev->dev, "rx");
++>>>>>>> 7ecc09bab1e8 (mmc: tmio: tmio_mmc_host has .dma)
  		dev_dbg(&host->pdev->dev, "%s: RX: got channel %p\n", __func__,
  			host->chan_rx);
  
  		if (!host->chan_rx)
  			goto ereqrx;
  
++<<<<<<< HEAD
 +		cfg.slave_id = pdata->dma->slave_id_rx;
 +		cfg.direction = DMA_DEV_TO_MEM;
 +		cfg.src_addr = cfg.dst_addr;
++=======
+ 		if (host->dma->chan_priv_rx)
+ 			cfg.slave_id = host->dma->slave_id_rx;
+ 		cfg.direction = DMA_DEV_TO_MEM;
+ 		cfg.src_addr = cfg.dst_addr + host->dma->dma_rx_offset;
+ 		cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
++>>>>>>> 7ecc09bab1e8 (mmc: tmio: tmio_mmc_host has .dma)
  		cfg.dst_addr = 0;
  		ret = dmaengine_slave_config(host->chan_rx, &cfg);
  		if (ret < 0)
diff --cc include/linux/mfd/tmio.h
index 38409958f913,8d708c7cf681..000000000000
--- a/include/linux/mfd/tmio.h
+++ b/include/linux/mfd/tmio.h
@@@ -84,15 -112,6 +84,18 @@@ void tmio_core_mmc_clk_div(void __iome
  
  struct dma_chan;
  
++<<<<<<< HEAD
 +struct tmio_mmc_dma {
 +	void *chan_priv_tx;
 +	void *chan_priv_rx;
 +	int slave_id_tx;
 +	int slave_id_rx;
 +	int alignment_shift;
 +	bool (*filter)(struct dma_chan *chan, void *arg);
 +};
 +
++=======
++>>>>>>> 7ecc09bab1e8 (mmc: tmio: tmio_mmc_host has .dma)
  struct tmio_mmc_host;
  
  /*
@@@ -103,9 -122,8 +106,12 @@@ struct tmio_mmc_data 
  	unsigned long			capabilities;
  	unsigned long			capabilities2;
  	unsigned long			flags;
 -	unsigned long			bus_shift;
  	u32				ocr_mask;	/* available voltages */
++<<<<<<< HEAD
 +	struct tmio_mmc_dma		*dma;
 +	struct device			*dev;
++=======
++>>>>>>> 7ecc09bab1e8 (mmc: tmio: tmio_mmc_host has .dma)
  	unsigned int			cd_gpio;
  	void (*set_pwr)(struct platform_device *host, int state);
  	void (*set_clk_div)(struct platform_device *host, int state);
* Unmerged path drivers/mmc/host/sh_mobile_sdhi.c
diff --git a/drivers/mmc/host/tmio_mmc.h b/drivers/mmc/host/tmio_mmc.h
index d857f5c6e7d9..54720f6aef88 100644
--- a/drivers/mmc/host/tmio_mmc.h
+++ b/drivers/mmc/host/tmio_mmc.h
@@ -40,6 +40,16 @@
 
 struct tmio_mmc_data;
 
+struct tmio_mmc_dma {
+	void *chan_priv_tx;
+	void *chan_priv_rx;
+	int slave_id_tx;
+	int slave_id_rx;
+	int alignment_shift;
+	dma_addr_t dma_rx_offset;
+	bool (*filter)(struct dma_chan *chan, void *arg);
+};
+
 struct tmio_mmc_host {
 	void __iomem *ctl;
 	unsigned long bus_shift;
@@ -63,6 +73,7 @@ struct tmio_mmc_host {
 
 	struct platform_device *pdev;
 	struct tmio_mmc_data *pdata;
+	struct tmio_mmc_dma	*dma;
 
 	/* DMA support */
 	bool			force_pio;
* Unmerged path drivers/mmc/host/tmio_mmc_dma.c
* Unmerged path include/linux/mfd/tmio.h
