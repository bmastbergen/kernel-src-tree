drm/i915/gen9: fix the watermark res_blocks value

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drm] i915/gen9: fix the watermark res_blocks value (Lyude Paul) [1341633 1355776]
Rebuild_FUZZ: 95.74%
commit-author Paulo Zanoni <paulo.r.zanoni@intel.com>
commit 75676ed423a6acf9e2b1df52fbc036a51e11fb7a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/75676ed4.failed

We forgot the "res_blocks += y_tile_minimum" that's described on step
V of our documentation.

Again, this should only affect the Y tiling cases.

It looks like the relevant code was introduced in 0fda65680e92, but
there's always the possibility that it matched our specification when
it was introduced, and then the specification changed while the code
stayed the same. So we can't really say this was a regression, but
let's try to add a "Fixes" tag anyway to help backporting.

v2: Try to add a "Fixes" tag (Maarten).

Fixes: 0fda65680e92 ("drm/i915/skl: Update watermarks for Y tiling")
	Cc: stable@vger.kernel.org
	Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
	Reviewed-by: Lyude <cpaul@redhat.com>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1474578035-424-8-git-send-email-paulo.r.zanoni@intel.com
(cherry picked from commit 75676ed423a6acf9e2b1df52fbc036a51e11fb7a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index b2b6b26d47bc,fd7465cd9b21..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -2878,41 -3549,70 +2878,78 @@@ static bool skl_compute_plane_wm(const 
  	uint32_t plane_bytes_per_line, plane_blocks_per_line;
  	uint32_t res_blocks, res_lines;
  	uint32_t selected_result;
++<<<<<<< HEAD
++=======
+ 	uint8_t cpp;
+ 	uint32_t width = 0, height = 0;
+ 	uint32_t plane_pixel_rate;
+ 	uint32_t y_tile_minimum, y_min_scanlines;
++>>>>>>> 75676ed423a6 (drm/i915/gen9: fix the watermark res_blocks value)
  
 -	if (latency == 0 || !cstate->base.active || !intel_pstate->base.visible) {
 -		*enabled = false;
 -		return 0;
 -	}
 -
 -	width = drm_rect_width(&intel_pstate->base.src) >> 16;
 -	height = drm_rect_height(&intel_pstate->base.src) >> 16;
 -
 -	if (intel_rotation_90_or_270(pstate->rotation))
 -		swap(width, height);
 -
 -	cpp = drm_format_plane_cpp(fb->pixel_format, 0);
 -	plane_pixel_rate = skl_adjusted_plane_pixel_rate(cstate, intel_pstate);
 -
 -	if (intel_rotation_90_or_270(pstate->rotation)) {
 -		int cpp = (fb->pixel_format == DRM_FORMAT_NV12) ?
 -			drm_format_plane_cpp(fb->pixel_format, 1) :
 -			drm_format_plane_cpp(fb->pixel_format, 0);
 +	if (latency == 0 || !p->active || !p_params->enabled)
 +		return false;
  
 -		switch (cpp) {
 -		case 1:
 -			y_min_scanlines = 16;
 -			break;
 -		case 2:
 -			y_min_scanlines = 8;
 -			break;
 -		default:
 -			WARN(1, "Unsupported pixel depth for rotation");
 -		case 4:
 -			y_min_scanlines = 4;
 -			break;
 +	method1 = skl_wm_method1(p->pixel_rate,
 +				 p_params->bytes_per_pixel,
 +				 latency);
 +	method2 = skl_wm_method2(p->pixel_rate,
 +				 p->pipe_htotal,
 +				 p_params->horiz_pixels,
 +				 p_params->bytes_per_pixel,
 +				 p_params->tiling,
 +				 latency);
 +
 +	plane_bytes_per_line = p_params->horiz_pixels *
 +					p_params->bytes_per_pixel;
 +	plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);
 +
 +	if (p_params->tiling == I915_FORMAT_MOD_Y_TILED ||
 +	    p_params->tiling == I915_FORMAT_MOD_Yf_TILED) {
 +		uint32_t min_scanlines = 4;
 +		uint32_t y_tile_minimum;
 +		if (intel_rotation_90_or_270(p_params->rotation)) {
 +			switch (p_params->bytes_per_pixel) {
 +			case 1:
 +				min_scanlines = 16;
 +				break;
 +			case 2:
 +				min_scanlines = 8;
 +				break;
 +			case 8:
 +				WARN(1, "Unsupported pixel depth for rotation");
 +			}
  		}
++<<<<<<< HEAD
 +		y_tile_minimum = plane_blocks_per_line * min_scanlines;
++=======
+ 	} else {
+ 		y_min_scanlines = 4;
+ 	}
+ 
+ 	plane_bytes_per_line = width * cpp;
+ 	if (fb->modifier[0] == I915_FORMAT_MOD_Y_TILED ||
+ 	    fb->modifier[0] == I915_FORMAT_MOD_Yf_TILED) {
+ 		plane_blocks_per_line =
+ 		      DIV_ROUND_UP(plane_bytes_per_line * y_min_scanlines, 512);
+ 		plane_blocks_per_line /= y_min_scanlines;
+ 	} else if (fb->modifier[0] == DRM_FORMAT_MOD_NONE) {
+ 		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512)
+ 					+ 1;
+ 	} else {
+ 		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);
+ 	}
+ 
+ 	method1 = skl_wm_method1(plane_pixel_rate, cpp, latency);
+ 	method2 = skl_wm_method2(plane_pixel_rate,
+ 				 cstate->base.adjusted_mode.crtc_htotal,
+ 				 latency,
+ 				 plane_blocks_per_line);
+ 
+ 	y_tile_minimum = plane_blocks_per_line * y_min_scanlines;
+ 
+ 	if (fb->modifier[0] == I915_FORMAT_MOD_Y_TILED ||
+ 	    fb->modifier[0] == I915_FORMAT_MOD_Yf_TILED) {
++>>>>>>> 75676ed423a6 (drm/i915/gen9: fix the watermark res_blocks value)
  		selected_result = max(method2, y_tile_minimum);
  	} else {
  		if ((ddb_allocation / plane_blocks_per_line) >= 1)
@@@ -2925,15 -3625,34 +2962,24 @@@
  	res_lines = DIV_ROUND_UP(selected_result, plane_blocks_per_line);
  
  	if (level >= 1 && level <= 7) {
++<<<<<<< HEAD
 +		if (p_params->tiling == I915_FORMAT_MOD_Y_TILED ||
 +		    p_params->tiling == I915_FORMAT_MOD_Yf_TILED)
 +			res_lines += 4;
 +		else
++=======
+ 		if (fb->modifier[0] == I915_FORMAT_MOD_Y_TILED ||
+ 		    fb->modifier[0] == I915_FORMAT_MOD_Yf_TILED) {
+ 			res_blocks += y_tile_minimum;
+ 			res_lines += y_min_scanlines;
+ 		} else {
++>>>>>>> 75676ed423a6 (drm/i915/gen9: fix the watermark res_blocks value)
  			res_blocks++;
+ 		}
  	}
  
 -	if (res_blocks >= ddb_allocation || res_lines > 31) {
 -		*enabled = false;
 -
 -		/*
 -		 * If there are no valid level 0 watermarks, then we can't
 -		 * support this display configuration.
 -		 */
 -		if (level) {
 -			return 0;
 -		} else {
 -			DRM_DEBUG_KMS("Requested display configuration exceeds system watermark limitations\n");
 -			DRM_DEBUG_KMS("Plane %d.%d: blocks required = %u/%u, lines required = %u/31\n",
 -				      to_intel_crtc(cstate->base.crtc)->pipe,
 -				      skl_wm_plane_id(to_intel_plane(pstate->plane)),
 -				      res_blocks, ddb_allocation, res_lines);
 -
 -			return -EINVAL;
 -		}
 -	}
 +	if (res_blocks >= ddb_allocation || res_lines > 31)
 +		return false;
  
  	*out_blocks = res_blocks;
  	*out_lines = res_lines;
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
