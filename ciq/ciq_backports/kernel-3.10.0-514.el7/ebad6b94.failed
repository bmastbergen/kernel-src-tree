mei: me: d0i3: move mei_me_hw_reset down in the file

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit ebad6b945ee2e7e93454ba52030b93e08290317c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ebad6b94.failed

Move mei_me_hw_reset down in the source file to avoid
forward declarations when introducing d0i3 flow in the next patch.

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit ebad6b945ee2e7e93454ba52030b93e08290317c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/hw-me.c
diff --cc drivers/misc/mei/hw-me.c
index 1707fa5ea02a,448f28133489..000000000000
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@@ -185,56 -290,6 +185,59 @@@ static void mei_me_hw_reset_release(str
  	/* complete this write before we set host ready on another CPU */
  	mmiowb();
  }
++<<<<<<< HEAD
 +/**
 + * mei_me_hw_reset - resets fw via mei csr register.
 + *
 + * @dev: the device structure
 + * @intr_enable: if interrupt should be enabled after reset.
 + */
 +static int mei_me_hw_reset(struct mei_device *dev, bool intr_enable)
 +{
 +	struct mei_me_hw *hw = to_me_hw(dev);
 +	u32 hcsr = mei_hcsr_read(hw);
 +
 +	/* H_RST may be found lit before reset is started,
 +	 * for example if preceding reset flow hasn't completed.
 +	 * In that case asserting H_RST will be ignored, therefore
 +	 * we need to clean H_RST bit to start a successful reset sequence.
 +	 */
 +	if ((hcsr & H_RST) == H_RST) {
 +		dev_warn(dev->dev, "H_RST is set = 0x%08X", hcsr);
 +		hcsr &= ~H_RST;
 +		mei_hcsr_set(hw, hcsr);
 +		hcsr = mei_hcsr_read(hw);
 +	}
 +
 +	hcsr |= H_RST | H_IG | H_IS;
 +
 +	if (intr_enable)
 +		hcsr |= H_IE;
 +	else
 +		hcsr &= ~H_IE;
 +
 +	dev->recvd_hw_ready = false;
 +	mei_me_reg_write(hw, H_CSR, hcsr);
 +
 +	/*
 +	 * Host reads the H_CSR once to ensure that the
 +	 * posted write to H_CSR completes.
 +	 */
 +	hcsr = mei_hcsr_read(hw);
 +
 +	if ((hcsr & H_RST) == 0)
 +		dev_warn(&dev->pdev->dev, "H_RST is not set = 0x%08X", hcsr);
 +
 +	if ((hcsr & H_RDY) == H_RDY)
 +		dev_warn(&dev->pdev->dev, "H_RDY is not cleared 0x%08X", hcsr);
 +
 +	if (intr_enable == false)
 +		mei_me_hw_reset_release(dev);
 +
 +	return 0;
 +}
++=======
++>>>>>>> ebad6b945ee2 (mei: me: d0i3: move mei_me_hw_reset down in the file)
  
  /**
   * mei_me_host_set_ready - enable device
@@@ -603,6 -725,365 +606,368 @@@ notsupported
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mei_me_d0i3_set - write d0i3 register bit on mei device.
+  *
+  * @dev: the device structure
+  * @intr: ask for interrupt
+  *
+  * Return: D0I3C register value
+  */
+ static u32 mei_me_d0i3_set(struct mei_device *dev, bool intr)
+ {
+ 	u32 reg = mei_me_d0i3c_read(dev);
+ 
+ 	reg |= H_D0I3C_I3;
+ 	if (intr)
+ 		reg |= H_D0I3C_IR;
+ 	else
+ 		reg &= ~H_D0I3C_IR;
+ 	mei_me_d0i3c_write(dev, reg);
+ 	/* read it to ensure HW consistency */
+ 	reg = mei_me_d0i3c_read(dev);
+ 	return reg;
+ }
+ 
+ /**
+  * mei_me_d0i3_unset - clean d0i3 register bit on mei device.
+  *
+  * @dev: the device structure
+  *
+  * Return: D0I3C register value
+  */
+ static u32 mei_me_d0i3_unset(struct mei_device *dev)
+ {
+ 	u32 reg = mei_me_d0i3c_read(dev);
+ 
+ 	reg &= ~H_D0I3C_I3;
+ 	reg |= H_D0I3C_IR;
+ 	mei_me_d0i3c_write(dev, reg);
+ 	/* read it to ensure HW consistency */
+ 	reg = mei_me_d0i3c_read(dev);
+ 	return reg;
+ }
+ 
+ /**
+  * mei_me_d0i3_enter_sync - perform d0i3 entry procedure
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ static int mei_me_d0i3_enter_sync(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 	unsigned long d0i3_timeout = mei_secs_to_jiffies(MEI_D0I3_TIMEOUT);
+ 	unsigned long pgi_timeout = mei_secs_to_jiffies(MEI_PGI_TIMEOUT);
+ 	int ret;
+ 	u32 reg;
+ 
+ 	reg = mei_me_d0i3c_read(dev);
+ 	if (reg & H_D0I3C_I3) {
+ 		/* we are in d0i3, nothing to do */
+ 		dev_dbg(dev->dev, "d0i3 set not needed\n");
+ 		ret = 0;
+ 		goto on;
+ 	}
+ 
+ 	/* PGI entry procedure */
+ 	dev->pg_event = MEI_PG_EVENT_WAIT;
+ 
+ 	ret = mei_hbm_pg(dev, MEI_PG_ISOLATION_ENTRY_REQ_CMD);
+ 	if (ret)
+ 		/* FIXME: should we reset here? */
+ 		goto out;
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 	wait_event_timeout(dev->wait_pg,
+ 		dev->pg_event == MEI_PG_EVENT_RECEIVED, pgi_timeout);
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (dev->pg_event != MEI_PG_EVENT_RECEIVED) {
+ 		ret = -ETIME;
+ 		goto out;
+ 	}
+ 	/* end PGI entry procedure */
+ 
+ 	dev->pg_event = MEI_PG_EVENT_INTR_WAIT;
+ 
+ 	reg = mei_me_d0i3_set(dev, true);
+ 	if (!(reg & H_D0I3C_CIP)) {
+ 		dev_dbg(dev->dev, "d0i3 enter wait not needed\n");
+ 		ret = 0;
+ 		goto on;
+ 	}
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 	wait_event_timeout(dev->wait_pg,
+ 		dev->pg_event == MEI_PG_EVENT_INTR_RECEIVED, d0i3_timeout);
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (dev->pg_event != MEI_PG_EVENT_INTR_RECEIVED) {
+ 		reg = mei_me_d0i3c_read(dev);
+ 		if (!(reg & H_D0I3C_I3)) {
+ 			ret = -ETIME;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	ret = 0;
+ on:
+ 	hw->pg_state = MEI_PG_ON;
+ out:
+ 	dev->pg_event = MEI_PG_EVENT_IDLE;
+ 	dev_dbg(dev->dev, "d0i3 enter ret = %d\n", ret);
+ 	return ret;
+ }
+ 
+ /**
+  * mei_me_d0i3_enter - perform d0i3 entry procedure
+  *   no hbm PG handshake
+  *   no waiting for confirmation; runs with interrupts
+  *   disabled
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ static int mei_me_d0i3_enter(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 	u32 reg;
+ 
+ 	reg = mei_me_d0i3c_read(dev);
+ 	if (reg & H_D0I3C_I3) {
+ 		/* we are in d0i3, nothing to do */
+ 		dev_dbg(dev->dev, "already d0i3 : set not needed\n");
+ 		goto on;
+ 	}
+ 
+ 	mei_me_d0i3_set(dev, false);
+ on:
+ 	hw->pg_state = MEI_PG_ON;
+ 	dev->pg_event = MEI_PG_EVENT_IDLE;
+ 	dev_dbg(dev->dev, "d0i3 enter\n");
+ 	return 0;
+ }
+ 
+ /**
+  * mei_me_d0i3_exit_sync - perform d0i3 exit procedure
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ static int mei_me_d0i3_exit_sync(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 	unsigned long timeout = mei_secs_to_jiffies(MEI_D0I3_TIMEOUT);
+ 	int ret;
+ 	u32 reg;
+ 
+ 	dev->pg_event = MEI_PG_EVENT_INTR_WAIT;
+ 
+ 	reg = mei_me_d0i3c_read(dev);
+ 	if (!(reg & H_D0I3C_I3)) {
+ 		/* we are not in d0i3, nothing to do */
+ 		dev_dbg(dev->dev, "d0i3 exit not needed\n");
+ 		ret = 0;
+ 		goto off;
+ 	}
+ 
+ 	reg = mei_me_d0i3_unset(dev);
+ 	if (!(reg & H_D0I3C_CIP)) {
+ 		dev_dbg(dev->dev, "d0i3 exit wait not needed\n");
+ 		ret = 0;
+ 		goto off;
+ 	}
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 	wait_event_timeout(dev->wait_pg,
+ 		dev->pg_event == MEI_PG_EVENT_INTR_RECEIVED, timeout);
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (dev->pg_event != MEI_PG_EVENT_INTR_RECEIVED) {
+ 		reg = mei_me_d0i3c_read(dev);
+ 		if (reg & H_D0I3C_I3) {
+ 			ret = -ETIME;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	ret = 0;
+ off:
+ 	hw->pg_state = MEI_PG_OFF;
+ out:
+ 	dev->pg_event = MEI_PG_EVENT_IDLE;
+ 
+ 	dev_dbg(dev->dev, "d0i3 exit ret = %d\n", ret);
+ 	return ret;
+ }
+ 
+ /**
+  * mei_me_pg_legacy_intr - perform legacy pg processing
+  *			   in interrupt thread handler
+  *
+  * @dev: the device structure
+  */
+ static void mei_me_pg_legacy_intr(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 
+ 	if (dev->pg_event != MEI_PG_EVENT_INTR_WAIT)
+ 		return;
+ 
+ 	dev->pg_event = MEI_PG_EVENT_INTR_RECEIVED;
+ 	hw->pg_state = MEI_PG_OFF;
+ 	if (waitqueue_active(&dev->wait_pg))
+ 		wake_up(&dev->wait_pg);
+ }
+ 
+ /**
+  * mei_me_d0i3_intr - perform d0i3 processing in interrupt thread handler
+  *
+  * @dev: the device structure
+  */
+ static void mei_me_d0i3_intr(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 
+ 	if (dev->pg_event == MEI_PG_EVENT_INTR_WAIT &&
+ 	    (hw->intr_source & H_D0I3C_IS)) {
+ 		dev->pg_event = MEI_PG_EVENT_INTR_RECEIVED;
+ 		if (hw->pg_state == MEI_PG_ON) {
+ 			hw->pg_state = MEI_PG_OFF;
+ 			if (dev->hbm_state != MEI_HBM_IDLE) {
+ 				/*
+ 				 * force H_RDY because it could be
+ 				 * wiped off during PG
+ 				 */
+ 				dev_dbg(dev->dev, "d0i3 set host ready\n");
+ 				mei_me_host_set_ready(dev);
+ 			}
+ 		} else {
+ 			hw->pg_state = MEI_PG_ON;
+ 		}
+ 
+ 		wake_up(&dev->wait_pg);
+ 	}
+ 
+ 	if (hw->pg_state == MEI_PG_ON && (hw->intr_source & H_IS)) {
+ 		/*
+ 		 * HW sent some data and we are in D0i3, so
+ 		 * we got here because of HW initiated exit from D0i3.
+ 		 * Start runtime pm resume sequence to exit low power state.
+ 		 */
+ 		dev_dbg(dev->dev, "d0i3 want resume\n");
+ 		mei_hbm_pg_resume(dev);
+ 	}
+ }
+ 
+ /**
+  * mei_me_pg_intr - perform pg processing in interrupt thread handler
+  *
+  * @dev: the device structure
+  */
+ static void mei_me_pg_intr(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 
+ 	if (hw->d0i3_supported)
+ 		mei_me_d0i3_intr(dev);
+ 	else
+ 		mei_me_pg_legacy_intr(dev);
+ }
+ 
+ /**
+  * mei_me_pg_enter_sync - perform runtime pm entry procedure
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ int mei_me_pg_enter_sync(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 
+ 	if (hw->d0i3_supported)
+ 		return mei_me_d0i3_enter_sync(dev);
+ 	else
+ 		return mei_me_pg_legacy_enter_sync(dev);
+ }
+ 
+ /**
+  * mei_me_pg_exit_sync - perform runtime pm exit procedure
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ int mei_me_pg_exit_sync(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 
+ 	if (hw->d0i3_supported)
+ 		return mei_me_d0i3_exit_sync(dev);
+ 	else
+ 		return mei_me_pg_legacy_exit_sync(dev);
+ }
+ 
+ /**
+  * mei_me_hw_reset - resets fw via mei csr register.
+  *
+  * @dev: the device structure
+  * @intr_enable: if interrupt should be enabled after reset.
+  *
+  * Return: always 0
+  */
+ static int mei_me_hw_reset(struct mei_device *dev, bool intr_enable)
+ {
+ 	u32 hcsr = mei_hcsr_read(dev);
+ 
+ 	/* H_RST may be found lit before reset is started,
+ 	 * for example if preceding reset flow hasn't completed.
+ 	 * In that case asserting H_RST will be ignored, therefore
+ 	 * we need to clean H_RST bit to start a successful reset sequence.
+ 	 */
+ 	if ((hcsr & H_RST) == H_RST) {
+ 		dev_warn(dev->dev, "H_RST is set = 0x%08X", hcsr);
+ 		hcsr &= ~H_RST;
+ 		mei_hcsr_set(dev, hcsr);
+ 		hcsr = mei_hcsr_read(dev);
+ 	}
+ 
+ 	hcsr |= H_RST | H_IG | H_CSR_IS_MASK;
+ 
+ 	if (intr_enable)
+ 		hcsr |= H_CSR_IE_MASK;
+ 	else
+ 		hcsr &= ~H_CSR_IE_MASK;
+ 
+ 	dev->recvd_hw_ready = false;
+ 	mei_hcsr_write(dev, hcsr);
+ 
+ 	/*
+ 	 * Host reads the H_CSR once to ensure that the
+ 	 * posted write to H_CSR completes.
+ 	 */
+ 	hcsr = mei_hcsr_read(dev);
+ 
+ 	if ((hcsr & H_RST) == 0)
+ 		dev_warn(dev->dev, "H_RST is not set = 0x%08X", hcsr);
+ 
+ 	if ((hcsr & H_RDY) == H_RDY)
+ 		dev_warn(dev->dev, "H_RDY is not cleared 0x%08X", hcsr);
+ 
+ 	if (intr_enable == false)
+ 		mei_me_hw_reset_release(dev);
+ 
+ 	return 0;
+ }
+ 
+ /**
++>>>>>>> ebad6b945ee2 (mei: me: d0i3: move mei_me_hw_reset down in the file)
   * mei_me_irq_quick_handler - The ISR of the MEI device
   *
   * @irq: The irq number
* Unmerged path drivers/misc/mei/hw-me.c
