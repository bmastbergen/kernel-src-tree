net: Detect drivers that reschedule NAPI and exhaust budget

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] Detect drivers that reschedule NAPI and exhaust budget (Ivan Vecera) [1334372]
Rebuild_FUZZ: 95.58%
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit 001ce546bb537bb5b7821f05633556a0c9787e32
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/001ce546.failed

The commit d75b1ade567ffab085e8adbbdacf0092d10cd09c (net: less
interrupt masking in NAPI) required drivers to leave poll_list
empty if the entire budget is consumed.

We have already had two broken drivers so let's add a check for
this.

	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 001ce546bb537bb5b7821f05633556a0c9787e32)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/dev.c
diff --cc net/core/dev.c
index ce5758e98847,c0cf1293df06..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -4470,6 -4557,68 +4470,71 @@@ void netif_napi_del(struct napi_struct 
  }
  EXPORT_SYMBOL(netif_napi_del);
  
++<<<<<<< HEAD
++=======
+ static int napi_poll(struct napi_struct *n, struct list_head *repoll)
+ {
+ 	void *have;
+ 	int work, weight;
+ 
+ 	list_del_init(&n->poll_list);
+ 
+ 	have = netpoll_poll_lock(n);
+ 
+ 	weight = n->weight;
+ 
+ 	/* This NAPI_STATE_SCHED test is for avoiding a race
+ 	 * with netpoll's poll_napi().  Only the entity which
+ 	 * obtains the lock and sees NAPI_STATE_SCHED set will
+ 	 * actually make the ->poll() call.  Therefore we avoid
+ 	 * accidentally calling ->poll() when NAPI is not scheduled.
+ 	 */
+ 	work = 0;
+ 	if (test_bit(NAPI_STATE_SCHED, &n->state)) {
+ 		work = n->poll(n, weight);
+ 		trace_napi_poll(n);
+ 	}
+ 
+ 	WARN_ON_ONCE(work > weight);
+ 
+ 	if (likely(work < weight))
+ 		goto out_unlock;
+ 
+ 	/* Drivers must not modify the NAPI state if they
+ 	 * consume the entire weight.  In such cases this code
+ 	 * still "owns" the NAPI instance and therefore can
+ 	 * move the instance around on the list at-will.
+ 	 */
+ 	if (unlikely(napi_disable_pending(n))) {
+ 		napi_complete(n);
+ 		goto out_unlock;
+ 	}
+ 
+ 	if (n->gro_list) {
+ 		/* flush too old packets
+ 		 * If HZ < 1000, flush all packets.
+ 		 */
+ 		napi_gro_flush(n, HZ >= 1000);
+ 	}
+ 
+ 	/* Some drivers may have called napi_schedule
+ 	 * prior to exhausting their budget.
+ 	 */
+ 	if (unlikely(!list_empty(&n->poll_list))) {
+ 		pr_warn_once("%s: Budget exhausted after napi rescheduled\n",
+ 			     n->dev ? n->dev->name : "backlog");
+ 		goto out_unlock;
+ 	}
+ 
+ 	list_add_tail(&n->poll_list, repoll);
+ 
+ out_unlock:
+ 	netpoll_poll_unlock(have);
+ 
+ 	return work;
+ }
+ 
++>>>>>>> 001ce546bb53 (net: Detect drivers that reschedule NAPI and exhaust budget)
  static void net_rx_action(struct softirq_action *h)
  {
  	struct softnet_data *sd = this_cpu_ptr(&softnet_data);
* Unmerged path net/core/dev.c
