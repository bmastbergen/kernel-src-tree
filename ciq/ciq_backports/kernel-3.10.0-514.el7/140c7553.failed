mei: drop unneeded client NULL check in cb structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit 140c7553231dcd119ebda8c27dec7f06aef7e323
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/140c7553.failed

The pointer to client in the callback structure (cb->cl)
can't be NULL with current locking.
We can drop check and warnings as in some cases this just
uselessly complicates the code flow.

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 140c7553231dcd119ebda8c27dec7f06aef7e323)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/amthif.c
diff --cc drivers/misc/mei/amthif.c
index a11128c1997f,0b5a3156917c..000000000000
--- a/drivers/misc/mei/amthif.c
+++ b/drivers/misc/mei/amthif.c
@@@ -382,18 -373,16 +381,29 @@@ void mei_amthif_run_next_cmd(struct mei
  	dev->iamthif_timer = 0;
  	dev->iamthif_file_object = NULL;
  
 -	dev_dbg(dev->dev, "complete amthif cmd_list cb.\n");
 +	dev_dbg(&dev->pdev->dev, "complete amthif cmd_list cb.\n");
  
++<<<<<<< HEAD
 +	list_for_each_entry_safe(cb, next, &dev->amthif_cmd_list.list, list) {
 +		list_del(&cb->list);
 +		if (!cb->cl)
 +			continue;
 +		status = mei_amthif_send_cmd(dev, cb);
 +		if (status)
 +			dev_warn(&dev->pdev->dev, "amthif write failed status = %d\n",
 +						status);
 +		break;
 +	}
++=======
+ 	cb = list_first_entry_or_null(&dev->amthif_cmd_list.list,
+ 					typeof(*cb), list);
+ 	if (!cb)
+ 		return;
+ 	list_del(&cb->list);
+ 	ret =  mei_amthif_send_cmd(dev, cb);
+ 	if (ret)
+ 		dev_warn(dev->dev, "amthif write failed status = %d\n", ret);
++>>>>>>> 140c7553231d (mei: drop unneeded client NULL check in cb structure)
  }
  
  
* Unmerged path drivers/misc/mei/amthif.c
diff --git a/drivers/misc/mei/client.c b/drivers/misc/mei/client.c
index 22a9268f24eb..d8a0b12890ac 100644
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@ -103,7 +103,7 @@ static void __mei_io_list_flush(struct mei_cl_cb *list,
 
 	/* enable removing everything if no cl is specified */
 	list_for_each_entry_safe(cb, next, &list->list, list) {
-		if (!cl || (cb->cl && mei_cl_cmp_id(cl, cb->cl))) {
+		if (!cl || mei_cl_cmp_id(cl, cb->cl)) {
 			list_del(&cb->list);
 			if (free)
 				mei_io_cb_free(cb);
diff --git a/drivers/misc/mei/hbm.c b/drivers/misc/mei/hbm.c
index e04f10ba9aa2..3048d121a541 100644
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@ -587,11 +587,6 @@ static void mei_hbm_cl_res(struct mei_device *dev,
 	list_for_each_entry_safe(cb, next, &dev->ctrl_rd_list.list, list) {
 
 		cl = cb->cl;
-		/* this should not happen */
-		if (WARN_ON(!cl)) {
-			list_del_init(&cb->list);
-			continue;
-		}
 
 		if (cb->fop_type != fop_type)
 			continue;
diff --git a/drivers/misc/mei/interrupt.c b/drivers/misc/mei/interrupt.c
index b8d9cfee3e87..e589f3187bb8 100644
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@ -44,8 +44,6 @@ void mei_irq_compl_handler(struct mei_device *dev, struct mei_cl_cb *compl_list)
 	list_for_each_entry_safe(cb, next, &compl_list->list, list) {
 		cl = cb->cl;
 		list_del(&cb->list);
-		if (!cl)
-			continue;
 
 		dev_dbg(&dev->pdev->dev, "completing call back.\n");
 		if (cl == &dev->iamthif_cl)
@@ -105,7 +103,7 @@ static int mei_cl_irq_read_msg(struct mei_device *dev,
 
 	list_for_each_entry_safe(cb, next, &dev->read_list.list, list) {
 		cl = cb->cl;
-		if (!cl || !mei_cl_is_reading(cl, mei_hdr))
+		if (!mei_cl_is_reading(cl, mei_hdr))
 			continue;
 
 		cl->reading_state = MEI_READING;
@@ -449,8 +447,6 @@ int mei_irq_write_handler(struct mei_device *dev, struct mei_cl_cb *cmpl_list)
 	list = &dev->write_waiting_list;
 	list_for_each_entry_safe(cb, next, &list->list, list) {
 		cl = cb->cl;
-		if (cl == NULL)
-			continue;
 
 		cl->status = 0;
 		list_del(&cb->list);
@@ -489,10 +485,6 @@ int mei_irq_write_handler(struct mei_device *dev, struct mei_cl_cb *cmpl_list)
 	dev_dbg(&dev->pdev->dev, "complete control write list cb.\n");
 	list_for_each_entry_safe(cb, next, &dev->ctrl_wr_list.list, list) {
 		cl = cb->cl;
-		if (!cl) {
-			list_del(&cb->list);
-			return -ENODEV;
-		}
 		switch (cb->fop_type) {
 		case MEI_FOP_DISCONNECT:
 			/* send disconnect message */
@@ -530,8 +522,6 @@ int mei_irq_write_handler(struct mei_device *dev, struct mei_cl_cb *cmpl_list)
 	dev_dbg(&dev->pdev->dev, "complete write list cb.\n");
 	list_for_each_entry_safe(cb, next, &dev->write_list.list, list) {
 		cl = cb->cl;
-		if (cl == NULL)
-			continue;
 		if (cl == &dev->iamthif_cl)
 			ret = mei_amthif_irq_write(cl, cb, cmpl_list);
 		else
