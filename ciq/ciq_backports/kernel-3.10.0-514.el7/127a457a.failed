KVM: x86: fix interrupt window handling in split IRQ chip case

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matt Gingell <gingell@google.com>
commit 127a457acb2131fdb31c68c98cf11eda8ba7b380
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/127a457a.failed

This patch ensures that dm_request_for_irq_injection and
post_kvm_run_save are in sync, avoiding that an endless ping-pong
between userspace (who correctly notices that IF=0) and
the kernel (who insists that userspace handles its request
for the interrupt window).

To synchronize them, it also adds checks for kvm_arch_interrupt_allowed
and !kvm_event_needs_reinjection.  These are always needed, not
just for in-kernel LAPIC.

	Signed-off-by: Matt Gingell <gingell@google.com>
[A collage of two patches from Matt. - Paolo]
Fixes: 1c1a9ce973a7863dd46767226bce2a5f12d48bc6
	Cc: stable@vger.kernel.org
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 127a457acb2131fdb31c68c98cf11eda8ba7b380)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index 733894b44f8d,46ed8edad793..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -6255,9 -5924,19 +6261,25 @@@ static int emulator_fix_hypercall(struc
   */
  static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	return (!irqchip_in_kernel(vcpu->kvm) && !kvm_cpu_has_interrupt(vcpu) &&
 +		vcpu->run->request_interrupt_window &&
 +		kvm_arch_interrupt_allowed(vcpu));
++=======
+ 	if (!vcpu->run->request_interrupt_window || pic_in_kernel(vcpu->kvm))
+ 		return false;
+ 
+ 	if (!kvm_arch_interrupt_allowed(vcpu))
+ 		return false;
+ 
+ 	if (kvm_cpu_has_interrupt(vcpu))
+ 		return false;
+ 
+ 	if (kvm_event_needs_reinjection(vcpu))
+ 		return false;
+ 
+ 	return kvm_cpu_accept_dm_intr(vcpu);
++>>>>>>> 127a457acb21 (KVM: x86: fix interrupt window handling in split IRQ chip case)
  }
  
  static void post_kvm_run_save(struct kvm_vcpu *vcpu)
@@@ -6268,13 -5947,12 +6290,22 @@@
  	kvm_run->flags = is_smm(vcpu) ? KVM_RUN_X86_SMM : 0;
  	kvm_run->cr8 = kvm_get_cr8(vcpu);
  	kvm_run->apic_base = kvm_get_apic_base(vcpu);
++<<<<<<< HEAD
 +	if (irqchip_in_kernel(vcpu->kvm))
 +		kvm_run->ready_for_interrupt_injection = 1;
 +	else
 +		kvm_run->ready_for_interrupt_injection =
 +			kvm_arch_interrupt_allowed(vcpu) &&
 +			!kvm_cpu_has_interrupt(vcpu) &&
 +			!kvm_event_needs_reinjection(vcpu);
++=======
+ 	kvm_run->ready_for_interrupt_injection =
+ 		pic_in_kernel(vcpu->kvm) ||
+ 		(kvm_arch_interrupt_allowed(vcpu) &&
+ 		 !kvm_cpu_has_interrupt(vcpu) &&
+ 		 !kvm_event_needs_reinjection(vcpu) &&
+ 		 kvm_cpu_accept_dm_intr(vcpu));
++>>>>>>> 127a457acb21 (KVM: x86: fix interrupt window handling in split IRQ chip case)
  }
  
  static void update_cr8_intercept(struct kvm_vcpu *vcpu)
* Unmerged path arch/x86/kvm/x86.c
