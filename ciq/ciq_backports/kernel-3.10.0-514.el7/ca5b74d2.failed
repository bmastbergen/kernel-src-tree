ACPI: Introduce has_acpi_companion()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit ca5b74d2675a44f54aacb919c1cf022463e2f738
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ca5b74d2.failed

Now that the ACPI companions of devices are represented by pointers
to struct fwnode_handle, it is not quite efficient to check whether
or not an ACPI companion of a device is present by evaluating the
ACPI_COMPANION() macro.

For this reason, introduce a special static inline routine for that,
has_acpi_companion(), and update the code to use it where applicable.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit ca5b74d2675a44f54aacb919c1cf022463e2f738)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/busses/i2c-designware-platdrv.c
#	include/linux/acpi.h
diff --cc drivers/i2c/busses/i2c-designware-platdrv.c
index 0823e1a30e3a,538d6910b550..000000000000
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@@ -135,12 -163,41 +135,47 @@@ static int dw_i2c_probe(struct platform
  	dev->irq = irq;
  	platform_set_drvdata(pdev, dev);
  
 -	/* fast mode by default because of legacy reasons */
 -	clk_freq = 400000;
 +	dev->clk = devm_clk_get(&pdev->dev, NULL);
 +	dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
  
++<<<<<<< HEAD
 +	if (IS_ERR(dev->clk))
 +		return PTR_ERR(dev->clk);
 +	clk_prepare_enable(dev->clk);
++=======
+ 	if (has_acpi_companion(&pdev->dev)) {
+ 		dw_i2c_acpi_configure(pdev);
+ 	} else if (pdev->dev.of_node) {
+ 		of_property_read_u32(pdev->dev.of_node,
+ 					"i2c-sda-hold-time-ns", &ht);
+ 
+ 		of_property_read_u32(pdev->dev.of_node,
+ 				     "i2c-sda-falling-time-ns",
+ 				     &dev->sda_falling_time);
+ 		of_property_read_u32(pdev->dev.of_node,
+ 				     "i2c-scl-falling-time-ns",
+ 				     &dev->scl_falling_time);
+ 
+ 		of_property_read_u32(pdev->dev.of_node, "clock-frequency",
+ 				     &clk_freq);
+ 
+ 		/* Only standard mode at 100kHz and fast mode at 400kHz
+ 		 * are supported.
+ 		 */
+ 		if (clk_freq != 100000 && clk_freq != 400000) {
+ 			dev_err(&pdev->dev, "Only 100kHz and 400kHz supported");
+ 			return -EINVAL;
+ 		}
+ 	} else {
+ 		pdata = dev_get_platdata(&pdev->dev);
+ 		if (pdata)
+ 			clk_freq = pdata->i2c_scl_freq;
+ 	}
+ 
+ 	r = i2c_dw_eval_lock_support(dev);
+ 	if (r)
+ 		return r;
++>>>>>>> ca5b74d2675a (ACPI: Introduce has_acpi_companion())
  
  	dev->functionality =
  		I2C_FUNC_I2C |
@@@ -210,6 -286,9 +245,12 @@@ static int dw_i2c_remove(struct platfor
  	pm_runtime_put(&pdev->dev);
  	pm_runtime_disable(&pdev->dev);
  
++<<<<<<< HEAD
++=======
+ 	if (has_acpi_companion(&pdev->dev))
+ 		dw_i2c_acpi_unconfigure(pdev);
+ 
++>>>>>>> ca5b74d2675a (ACPI: Introduce has_acpi_companion())
  	return 0;
  }
  
diff --cc include/linux/acpi.h
index 364918faf44f,ec488d03b518..000000000000
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@@ -50,10 -53,16 +50,15 @@@ static inline acpi_handle acpi_device_h
  	return adev ? adev->handle : NULL;
  }
  
 -#define ACPI_COMPANION(dev)		acpi_node((dev)->fwnode)
 -#define ACPI_COMPANION_SET(dev, adev)	(dev)->fwnode = (adev) ? \
 -	acpi_fwnode_handle(adev) : NULL
 +#define ACPI_COMPANION(dev)		((dev)->acpi_node.companion)
 +#define ACPI_COMPANION_SET(dev, adev)	ACPI_COMPANION(dev) = (adev)
  #define ACPI_HANDLE(dev)		acpi_device_handle(ACPI_COMPANION(dev))
  
+ static inline bool has_acpi_companion(struct device *dev)
+ {
+ 	return is_acpi_node(dev->fwnode);
+ }
+ 
  static inline void acpi_preset_companion(struct device *dev,
  					 struct acpi_device *parent, u64 addr)
  {
@@@ -426,6 -460,33 +431,36 @@@ static inline bool acpi_driver_match_de
  #define ACPI_COMPANION_SET(dev, adev)	do { } while (0)
  #define ACPI_HANDLE(dev)		(NULL)
  
++<<<<<<< HEAD
++=======
+ struct fwnode_handle;
+ 
+ static inline bool is_acpi_node(struct fwnode_handle *fwnode)
+ {
+ 	return false;
+ }
+ 
+ static inline struct acpi_device *acpi_node(struct fwnode_handle *fwnode)
+ {
+ 	return NULL;
+ }
+ 
+ static inline struct fwnode_handle *acpi_fwnode_handle(struct acpi_device *adev)
+ {
+ 	return NULL;
+ }
+ 
+ static inline bool has_acpi_companion(struct device *dev)
+ {
+ 	return false;
+ }
+ 
+ static inline const char *acpi_dev_name(struct acpi_device *adev)
+ {
+ 	return NULL;
+ }
+ 
++>>>>>>> ca5b74d2675a (ACPI: Introduce has_acpi_companion())
  static inline void acpi_early_init(void) { }
  
  static inline int early_acpi_boot_init(void)
diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 155fd5762768..88d84c3c923b 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -168,7 +168,7 @@ int acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)
 	unsigned int node_id;
 	int retval = -EINVAL;
 
-	if (ACPI_COMPANION(dev)) {
+	if (has_acpi_companion(dev)) {
 		if (acpi_dev) {
 			dev_warn(dev, "ACPI companion already set\n");
 			return -EINVAL;
@@ -218,7 +218,7 @@ int acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)
 	list_add(&physical_node->node, physnode_list);
 	acpi_dev->physical_node_count++;
 
-	if (!ACPI_COMPANION(dev))
+	if (!has_acpi_companion(dev))
 		ACPI_COMPANION_SET(dev, acpi_dev);
 
 	acpi_physnode_link_name(physical_node_name, node_id);
* Unmerged path drivers/i2c/busses/i2c-designware-platdrv.c
diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c
index bb8ed4832156..8225cecf0305 100644
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@ -728,7 +728,7 @@ static struct intel_iommu *device_to_iommu(struct device *dev, u8 *bus, u8 *devf
 	if (dev_is_pci(dev)) {
 		pdev = to_pci_dev(dev);
 		segment = pci_domain_nr(pdev->bus);
-	} else if (ACPI_COMPANION(dev))
+	} else if (has_acpi_companion(dev))
 		dev = &ACPI_COMPANION(dev)->dev;
 
 	rcu_read_lock();
* Unmerged path include/linux/acpi.h
