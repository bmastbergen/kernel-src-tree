quota: Fixup comments about return value of Q_[X]GETNEXTQUOTA

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Eric Sandeen <sandeen@redhat.com>
commit ba58148b6f0408b791e097ab2967c8f6da959fd9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ba58148b.failed

We actually return ENOENT, not ESRCH, when there is no structure with
higher ID from ->get_nextdqblk. Fixup comments.

	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit ba58148b6f0408b791e097ab2967c8f6da959fd9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/quota/quota.c
diff --cc fs/quota/quota.c
index 8f489c65f2a6,a925f629a00a..000000000000
--- a/fs/quota/quota.c
+++ b/fs/quota/quota.c
@@@ -150,16 -222,44 +150,25 @@@ static int quota_getquota(struct super_
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void copy_from_if_dqblk(struct fs_disk_quota *dst, struct if_dqblk *src)
++=======
+ /*
+  * Return quota for next active quota >= this id, if any exists,
+  * otherwise return -ENOENT via ->get_nextdqblk
+  */
+ static int quota_getnextquota(struct super_block *sb, int type, qid_t id,
+ 			  void __user *addr)
++>>>>>>> ba58148b6f04 (quota: Fixup comments about return value of Q_[X]GETNEXTQUOTA)
  {
 -	struct kqid qid;
 -	struct qc_dqblk fdq;
 -	struct if_nextdqblk idq;
 -	int ret;
 -
 -	if (!sb->s_qcop->get_nextdqblk)
 -		return -ENOSYS;
 -	qid = make_kqid(current_user_ns(), type, id);
 -	if (!qid_valid(qid))
 -		return -EINVAL;
 -	ret = sb->s_qcop->get_nextdqblk(sb, &qid, &fdq);
 -	if (ret)
 -		return ret;
 -	/* struct if_nextdqblk is a superset of struct if_dqblk */
 -	copy_to_if_dqblk((struct if_dqblk *)&idq, &fdq);
 -	idq.dqb_id = from_kqid(current_user_ns(), qid);
 -	if (copy_to_user(addr, &idq, sizeof(idq)))
 -		return -EFAULT;
 -	return 0;
 -}
 -
 -static void copy_from_if_dqblk(struct qc_dqblk *dst, struct if_dqblk *src)
 -{
 -	dst->d_spc_hardlimit = qbtos(src->dqb_bhardlimit);
 -	dst->d_spc_softlimit = qbtos(src->dqb_bsoftlimit);
 -	dst->d_space = src->dqb_curspace;
 +	dst->d_blk_hardlimit = src->dqb_bhardlimit;
 +	dst->d_blk_softlimit  = src->dqb_bsoftlimit;
 +	dst->d_bcount = src->dqb_curspace;
  	dst->d_ino_hardlimit = src->dqb_ihardlimit;
  	dst->d_ino_softlimit = src->dqb_isoftlimit;
 -	dst->d_ino_count = src->dqb_curinodes;
 -	dst->d_spc_timer = src->dqb_btime;
 -	dst->d_ino_timer = src->dqb_itime;
 +	dst->d_icount = src->dqb_curinodes;
 +	dst->d_btimer = src->dqb_btime;
 +	dst->d_itimer = src->dqb_itime;
  
  	dst->d_fieldmask = 0;
  	if (src->dqb_valid & QIF_BLIMITS)
@@@ -271,8 -644,39 +280,44 @@@ static int quota_getxquota(struct super
  	qid = make_kqid(current_user_ns(), type, id);
  	if (!qid_valid(qid))
  		return -EINVAL;
++<<<<<<< HEAD
 +	ret = sb->s_qcop->get_dqblk(sb, qid, &fdq);
 +	if (!ret && copy_to_user(addr, &fdq, sizeof(fdq)))
++=======
+ 	ret = sb->s_qcop->get_dqblk(sb, qid, &qdq);
+ 	if (ret)
+ 		return ret;
+ 	copy_to_xfs_dqblk(&fdq, &qdq, type, id);
+ 	if (copy_to_user(addr, &fdq, sizeof(fdq)))
+ 		return -EFAULT;
+ 	return ret;
+ }
+ 
+ /*
+  * Return quota for next active quota >= this id, if any exists,
+  * otherwise return -ENOENT via ->get_nextdqblk.
+  */
+ static int quota_getnextxquota(struct super_block *sb, int type, qid_t id,
+ 			    void __user *addr)
+ {
+ 	struct fs_disk_quota fdq;
+ 	struct qc_dqblk qdq;
+ 	struct kqid qid;
+ 	qid_t id_out;
+ 	int ret;
+ 
+ 	if (!sb->s_qcop->get_nextdqblk)
+ 		return -ENOSYS;
+ 	qid = make_kqid(current_user_ns(), type, id);
+ 	if (!qid_valid(qid))
+ 		return -EINVAL;
+ 	ret = sb->s_qcop->get_nextdqblk(sb, &qid, &qdq);
+ 	if (ret)
+ 		return ret;
+ 	id_out = from_kqid(current_user_ns(), qid);
+ 	copy_to_xfs_dqblk(&fdq, &qdq, type, id_out);
+ 	if (copy_to_user(addr, &fdq, sizeof(fdq)))
++>>>>>>> ba58148b6f04 (quota: Fixup comments about return value of Q_[X]GETNEXTQUOTA)
  		return -EFAULT;
  	return ret;
  }
* Unmerged path fs/quota/quota.c
