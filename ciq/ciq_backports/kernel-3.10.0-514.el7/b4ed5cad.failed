vxlan: consolidate csum flag handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit b4ed5cad24c1072033efbffa680c84c9ba19c798
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b4ed5cad.failed

The flag for tx checksumming for tunneling over IPv4 and IPv6 is different.
Decide whether to do tx checksumming in vxlan_xmit_one and pass it on as
a separate flag. This will allow for tx path consolidation in the next
patch.

Unfortunately, gcc is not clever enough to see that udp_sum is always
initialized and gives an uninitialized variable warning. Set it to false to
silence the warning.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b4ed5cad24c1072033efbffa680c84c9ba19c798)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index aaa12a1f2042,fe3fd4808f4d..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1665,8 -1689,9 +1665,14 @@@ static int vxlan6_xmit_skb(struct dst_e
  			   struct sk_buff *skb,
  			   struct net_device *dev, struct in6_addr *saddr,
  			   struct in6_addr *daddr, __u8 prio, __u8 ttl,
++<<<<<<< HEAD
 +			   __be16 src_port, __be16 dst_port,
 +			   struct vxlan_metadata *md, bool xnet, u32 vxflags)
++=======
+ 			   __be16 src_port, __be16 dst_port, __be32 vni,
+ 			   struct vxlan_metadata *md, bool xnet, u32 vxflags,
+ 			   bool udp_sum)
++>>>>>>> b4ed5cad24c1 (vxlan: consolidate csum flag handling)
  {
  	struct vxlanhdr *vxh;
  	int min_headroom;
@@@ -1748,10 -1772,11 +1753,18 @@@ err
  }
  #endif
  
++<<<<<<< HEAD
 +int vxlan_xmit_skb(struct rtable *rt, struct sock *sk, struct sk_buff *skb,
 +		   __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,
 +		   __be16 src_port, __be16 dst_port,
 +		   struct vxlan_metadata *md, bool xnet, u32 vxflags)
++=======
+ static int vxlan_xmit_skb(struct rtable *rt, struct sock *sk, struct sk_buff *skb,
+ 			  __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,
+ 			  __be16 src_port, __be16 dst_port, __be32 vni,
+ 			  struct vxlan_metadata *md, bool xnet, u32 vxflags,
+ 			  bool udp_sum)
++>>>>>>> b4ed5cad24c1 (vxlan: consolidate csum flag handling)
  {
  	struct vxlanhdr *vxh;
  	int min_headroom;
@@@ -1817,11 -1842,59 +1830,17 @@@
  
  	skb_set_inner_protocol(skb, htons(ETH_P_TEB));
  
++<<<<<<< HEAD
 +	return udp_tunnel_xmit_skb(rt, sk, skb, src, dst, tos,
 +				   ttl, df, src_port, dst_port, xnet,
 +				   !(vxflags & VXLAN_F_UDP_CSUM));
++=======
+ 	udp_tunnel_xmit_skb(rt, sk, skb, src, dst, tos, ttl, df,
+ 			    src_port, dst_port, xnet, nocheck);
+ 	return 0;
++>>>>>>> b4ed5cad24c1 (vxlan: consolidate csum flag handling)
  }
 -
 -static struct rtable *vxlan_get_route(struct vxlan_dev *vxlan,
 -				      struct sk_buff *skb, int oif, u8 tos,
 -				      __be32 daddr, __be32 *saddr)
 -{
 -	struct rtable *rt = NULL;
 -	struct flowi4 fl4;
 -
 -	memset(&fl4, 0, sizeof(fl4));
 -	fl4.flowi4_oif = oif;
 -	fl4.flowi4_tos = RT_TOS(tos);
 -	fl4.flowi4_mark = skb->mark;
 -	fl4.flowi4_proto = IPPROTO_UDP;
 -	fl4.daddr = daddr;
 -	fl4.saddr = vxlan->cfg.saddr.sin.sin_addr.s_addr;
 -
 -	rt = ip_route_output_key(vxlan->net, &fl4);
 -	if (!IS_ERR(rt))
 -		*saddr = fl4.saddr;
 -	return rt;
 -}
 -
 -#if IS_ENABLED(CONFIG_IPV6)
 -static struct dst_entry *vxlan6_get_route(struct vxlan_dev *vxlan,
 -					  struct sk_buff *skb, int oif,
 -					  const struct in6_addr *daddr,
 -					  struct in6_addr *saddr)
 -{
 -	struct dst_entry *ndst;
 -	struct flowi6 fl6;
 -	int err;
 -
 -	memset(&fl6, 0, sizeof(fl6));
 -	fl6.flowi6_oif = oif;
 -	fl6.daddr = *daddr;
 -	fl6.saddr = vxlan->cfg.saddr.sin6.sin6_addr;
 -	fl6.flowi6_mark = skb->mark;
 -	fl6.flowi6_proto = IPPROTO_UDP;
 -
 -	err = ipv6_stub->ipv6_dst_lookup(vxlan->net,
 -					 vxlan->vn6_sock->sock->sk,
 -					 &ndst, &fl6);
 -	if (err < 0)
 -		return ERR_PTR(err);
 -
 -	*saddr = fl6.saddr;
 -	return ndst;
 -}
 -#endif
 +EXPORT_SYMBOL_GPL(vxlan_xmit_skb);
  
  /* Bypass encapsulation if the destination is local */
  static void vxlan_encap_bypass(struct sk_buff *skb, struct vxlan_dev *src_vxlan,
@@@ -1883,10 -1958,30 +1902,15 @@@ static void vxlan_xmit_one(struct sk_bu
  	__be16 df = 0;
  	__u8 tos, ttl;
  	int err;
++<<<<<<< HEAD
++=======
+ 	u32 flags = vxlan->flags;
+ 	bool udp_sum = false;
++>>>>>>> b4ed5cad24c1 (vxlan: consolidate csum flag handling)
  
 -	info = skb_tunnel_info(skb);
 -
 -	if (rdst) {
 -		dst_port = rdst->remote_port ? rdst->remote_port : vxlan->cfg.dst_port;
 -		vni = rdst->remote_vni;
 -		dst = &rdst->remote_ip;
 -	} else {
 -		if (!info) {
 -			WARN_ONCE(1, "%s: Missing encapsulation instructions\n",
 -				  dev->name);
 -			goto drop;
 -		}
 -		dst_port = info->key.tp_dst ? : vxlan->cfg.dst_port;
 -		vni = be64_to_cpu(info->key.tun_id);
 -		remote_ip.sa.sa_family = ip_tunnel_info_af(info);
 -		if (remote_ip.sa.sa_family == AF_INET)
 -			remote_ip.sin.sin_addr.s_addr = info->key.u.ipv4.dst;
 -		else
 -			remote_ip.sin6.sin6_addr = info->key.u.ipv6.dst;
 -		dst = &remote_ip;
 -	}
 +	dst_port = rdst->remote_port ? rdst->remote_port : vxlan->dst_port;
 +	vni = rdst->remote_vni;
 +	dst = &rdst->remote_ip;
  
  	if (vxlan_addr_any(dst)) {
  		if (did_rsc) {
@@@ -1907,19 -2002,37 +1931,52 @@@
  	if (tos == 1)
  		tos = ip_tunnel_get_dsfield(old_iph, skb);
  
++<<<<<<< HEAD
 +	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->port_min,
 +				     vxlan->port_max, true);
++=======
+ 	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
+ 				     vxlan->cfg.port_max, true);
+ 
+ 	if (info) {
+ 		ttl = info->key.ttl;
+ 		tos = info->key.tos;
+ 		udp_sum = !!(info->key.tun_flags & TUNNEL_CSUM);
+ 
+ 		if (info->options_len)
+ 			md = ip_tunnel_info_opts(info);
+ 	} else {
+ 		md->gbp = skb->mark;
+ 	}
++>>>>>>> b4ed5cad24c1 (vxlan: consolidate csum flag handling)
  
  	if (dst->sa.sa_family == AF_INET) {
 -		__be32 saddr;
 -
 +		memset(&fl4, 0, sizeof(fl4));
 +		fl4.flowi4_oif = rdst->remote_ifindex;
 +		fl4.flowi4_tos = RT_TOS(tos);
 +		fl4.flowi4_mark = skb->mark;
 +		fl4.flowi4_proto = IPPROTO_UDP;
 +		fl4.daddr = dst->sin.sin_addr.s_addr;
 +		fl4.saddr = vxlan->saddr.sin.sin_addr.s_addr;
 +
++<<<<<<< HEAD
 +		rt = ip_route_output_key(vxlan->net, &fl4);
++=======
+ 		if (!vxlan->vn4_sock)
+ 			goto drop;
+ 		sk = vxlan->vn4_sock->sock->sk;
+ 
+ 		if (info) {
+ 			if (info->key.tun_flags & TUNNEL_DONT_FRAGMENT)
+ 				df = htons(IP_DF);
+ 		} else {
+ 			udp_sum = !!(flags & VXLAN_F_UDP_CSUM);
+ 		}
+ 
+ 		rt = vxlan_get_route(vxlan, skb,
+ 				     rdst ? rdst->remote_ifindex : 0, tos,
+ 				     dst->sin.sin_addr.s_addr, &saddr);
++>>>>>>> b4ed5cad24c1 (vxlan: consolidate csum flag handling)
  		if (IS_ERR(rt)) {
  			netdev_dbg(dev, "no route to %pI4\n",
  				   &dst->sin.sin_addr.s_addr);
@@@ -1951,14 -2064,11 +2008,18 @@@
  
  		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip4_dst_hoplimit(&rt->dst);
 -		err = vxlan_xmit_skb(rt, sk, skb, saddr,
 +		md.vni = htonl(vni << 8);
 +		md.gbp = skb->mark;
 +
 +		err = vxlan_xmit_skb(rt, sk, skb, fl4.saddr,
  				     dst->sin.sin_addr.s_addr, tos, ttl, df,
 -				     src_port, dst_port, htonl(vni << 8), md,
 +				     src_port, dst_port, &md,
  				     !net_eq(vxlan->net, dev_net(vxlan->dev)),
++<<<<<<< HEAD
 +				     vxlan->flags);
++=======
+ 				     flags, udp_sum);
++>>>>>>> b4ed5cad24c1 (vxlan: consolidate csum flag handling)
  		if (err < 0) {
  			/* skb is already freed. */
  			skb = NULL;
@@@ -2010,14 -2118,14 +2071,24 @@@
  			return;
  		}
  
++<<<<<<< HEAD
++=======
+ 		if (!info)
+ 			udp_sum = !(flags & VXLAN_F_UDP_ZERO_CSUM6_TX);
+ 
++>>>>>>> b4ed5cad24c1 (vxlan: consolidate csum flag handling)
  		ttl = ttl ? : ip6_dst_hoplimit(ndst);
 -		err = vxlan6_xmit_skb(ndst, sk, skb, dev, &saddr, &dst->sin6.sin6_addr,
 -				      0, ttl, src_port, dst_port, htonl(vni << 8), md,
 +		md.vni = htonl(vni << 8);
 +		md.gbp = skb->mark;
 +
 +		err = vxlan6_xmit_skb(ndst, sk, skb, dev, &fl6.saddr, &fl6.daddr,
 +				      0, ttl, src_port, dst_port, &md,
  				      !net_eq(vxlan->net, dev_net(vxlan->dev)),
++<<<<<<< HEAD
 +				      vxlan->flags);
++=======
+ 				      flags, udp_sum);
++>>>>>>> b4ed5cad24c1 (vxlan: consolidate csum flag handling)
  #endif
  	}
  
* Unmerged path drivers/net/vxlan.c
