IB/iser: Support the remote invalidation exception

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jenny Derzhavetz <jennyf@mellanox.com>
commit 59caaed7a72a0e3750dfb84636dae6b781559310
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/59caaed7.failed

Declare that we support remote invalidation in case we are:
1. using fastreg method
2. always registering memory

Detect the invalidated rkey from the work completion info so we
won't invalidate it locally. The spec mandates that we must not rely
on the target remote invalidate our rkey so we must check it upon
a receive (scsi response) completion.

	Signed-off-by: Jenny Derzhavetz <jennyf@mellanox.com>
	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 59caaed7a72a0e3750dfb84636dae6b781559310)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iscsi_iser.h
#	drivers/infiniband/ulp/iser/iser_initiator.c
#	drivers/infiniband/ulp/iser/iser_verbs.c
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.h
index dfd5c4290bc2,95f0a64e076b..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@@ -537,6 -525,9 +539,12 @@@ struct iser_conn 
  	unsigned int 		     rx_desc_head;
  	struct iser_rx_desc	     *rx_descs;
  	u32                          num_rx_descs;
++<<<<<<< HEAD
++=======
+ 	unsigned short               scsi_sg_tablesize;
+ 	unsigned int                 scsi_max_sectors;
+ 	bool			     snd_w_inv;
++>>>>>>> 59caaed7a72a (IB/iser: Support the remote invalidation exception)
  };
  
  /**
diff --cc drivers/infiniband/ulp/iser/iser_initiator.c
index 5458fffc8b40,ed54b388e7ad..000000000000
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@@ -554,45 -556,126 +554,141 @@@ send_control_error
  	return err;
  }
  
 -void iser_login_rsp(struct ib_cq *cq, struct ib_wc *wc)
 +/**
 + * iser_rcv_dto_completion - recv DTO completion
 + */
 +void iser_rcv_completion(struct iser_rx_desc *rx_desc,
 +			 unsigned long rx_xfer_len,
 +			 struct ib_conn *ib_conn)
  {
 -	struct ib_conn *ib_conn = wc->qp->qp_context;
 -	struct iser_conn *iser_conn = to_iser_conn(ib_conn);
 -	struct iser_login_desc *desc = iser_login(wc->wr_cqe);
 +	struct iser_conn *iser_conn = container_of(ib_conn, struct iser_conn,
 +						   ib_conn);
  	struct iscsi_hdr *hdr;
  	char *data;
 -	int length;
 -
 -	if (unlikely(wc->status != IB_WC_SUCCESS)) {
 -		iser_err_comp(wc, "login_rsp");
 -		return;
 +	u64 rx_dma;
 +	int rx_buflen, outstanding, count, err;
 +
 +	/* differentiate between login to all other PDUs */
 +	if (rx_desc == (void *)&iser_conn->login_desc) {
 +		rx_dma = iser_conn->login_desc.rsp_dma;
 +		rx_buflen = ISER_RX_LOGIN_SIZE;
 +		hdr = iser_conn->login_desc.rsp + sizeof(struct iser_hdr);
 +		data = iser_conn->login_desc.rsp + ISER_HEADERS_LEN;
 +	} else {
 +		rx_dma = rx_desc->dma_addr;
 +		rx_buflen = ISER_RX_PAYLOAD_SIZE;
 +		hdr = &rx_desc->iscsi_header;
 +		data = rx_desc->data;
  	}
  
 -	ib_dma_sync_single_for_cpu(ib_conn->device->ib_device,
 -				   desc->rsp_dma, ISER_RX_LOGIN_SIZE,
 -				   DMA_FROM_DEVICE);
 +	ib_dma_sync_single_for_cpu(ib_conn->device->ib_device, rx_dma,
 +				   rx_buflen, DMA_FROM_DEVICE);
  
 -	hdr = desc->rsp + sizeof(struct iser_ctrl);
 -	data = desc->rsp + ISER_HEADERS_LEN;
 -	length = wc->byte_len - ISER_HEADERS_LEN;
  
  	iser_dbg("op 0x%x itt 0x%x dlen %d\n", hdr->opcode,
 -		 hdr->itt, length);
 +			hdr->itt, (int)(rx_xfer_len - ISER_HEADERS_LEN));
  
 -	iscsi_iser_recv(iser_conn->iscsi_conn, hdr, data, length);
 +	iscsi_iser_recv(iser_conn->iscsi_conn, hdr, data,
 +			rx_xfer_len - ISER_HEADERS_LEN);
  
++<<<<<<< HEAD
 +	ib_dma_sync_single_for_device(ib_conn->device->ib_device, rx_dma,
 +				      rx_buflen, DMA_FROM_DEVICE);
++=======
+ 	ib_dma_sync_single_for_device(ib_conn->device->ib_device,
+ 				      desc->rsp_dma, ISER_RX_LOGIN_SIZE,
+ 				      DMA_FROM_DEVICE);
+ 
+ 	ib_conn->post_recv_buf_count--;
+ }
+ 
+ static inline void
+ iser_inv_desc(struct iser_fr_desc *desc, u32 rkey)
+ {
+ 	if (likely(rkey == desc->rsc.mr->rkey))
+ 		desc->rsc.mr_valid = 0;
+ 	else if (likely(rkey == desc->pi_ctx->sig_mr->rkey))
+ 		desc->pi_ctx->sig_mr_valid = 0;
+ }
+ 
+ static int
+ iser_check_remote_inv(struct iser_conn *iser_conn,
+ 		      struct ib_wc *wc,
+ 		      struct iscsi_hdr *hdr)
+ {
+ 	if (wc->wc_flags & IB_WC_WITH_INVALIDATE) {
+ 		struct iscsi_task *task;
+ 		u32 rkey = wc->ex.invalidate_rkey;
+ 
+ 		iser_dbg("conn %p: remote invalidation for rkey %#x\n",
+ 			 iser_conn, rkey);
+ 
+ 		if (unlikely(!iser_conn->snd_w_inv)) {
+ 			iser_err("conn %p: unexepected remote invalidation, "
+ 				 "terminating connection\n", iser_conn);
+ 			return -EPROTO;
+ 		}
+ 
+ 		task = iscsi_itt_to_ctask(iser_conn->iscsi_conn, hdr->itt);
+ 		if (likely(task)) {
+ 			struct iscsi_iser_task *iser_task = task->dd_data;
+ 			struct iser_fr_desc *desc;
+ 
+ 			if (iser_task->dir[ISER_DIR_IN]) {
+ 				desc = iser_task->rdma_reg[ISER_DIR_IN].mem_h;
+ 				iser_inv_desc(desc, rkey);
+ 			}
+ 
+ 			if (iser_task->dir[ISER_DIR_OUT]) {
+ 				desc = iser_task->rdma_reg[ISER_DIR_OUT].mem_h;
+ 				iser_inv_desc(desc, rkey);
+ 			}
+ 		} else {
+ 			iser_err("failed to get task for itt=%d\n", hdr->itt);
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ 
+ void iser_task_rsp(struct ib_cq *cq, struct ib_wc *wc)
+ {
+ 	struct ib_conn *ib_conn = wc->qp->qp_context;
+ 	struct iser_conn *iser_conn = to_iser_conn(ib_conn);
+ 	struct iser_rx_desc *desc = iser_rx(wc->wr_cqe);
+ 	struct iscsi_hdr *hdr;
+ 	int length;
+ 	int outstanding, count, err;
+ 
+ 	if (unlikely(wc->status != IB_WC_SUCCESS)) {
+ 		iser_err_comp(wc, "task_rsp");
+ 		return;
+ 	}
+ 
+ 	ib_dma_sync_single_for_cpu(ib_conn->device->ib_device,
+ 				   desc->dma_addr, ISER_RX_PAYLOAD_SIZE,
+ 				   DMA_FROM_DEVICE);
+ 
+ 	hdr = &desc->iscsi_header;
+ 	length = wc->byte_len - ISER_HEADERS_LEN;
+ 
+ 	iser_dbg("op 0x%x itt 0x%x dlen %d\n", hdr->opcode,
+ 		 hdr->itt, length);
+ 
+ 	if (iser_check_remote_inv(iser_conn, wc, hdr)) {
+ 		iscsi_conn_failure(iser_conn->iscsi_conn,
+ 				   ISCSI_ERR_CONN_FAILED);
+ 		return;
+ 	}
+ 
+ 	iscsi_iser_recv(iser_conn->iscsi_conn, hdr, desc->data, length);
+ 
+ 	ib_dma_sync_single_for_device(ib_conn->device->ib_device,
+ 				      desc->dma_addr, ISER_RX_PAYLOAD_SIZE,
+ 				      DMA_FROM_DEVICE);
++>>>>>>> 59caaed7a72a (IB/iser: Support the remote invalidation exception)
  
  	/* decrementing conn->post_recv_buf_count only --after-- freeing the   *
  	 * task eliminates the need to worry on tasks which are completed in   *
diff --cc drivers/infiniband/ulp/iser/iser_verbs.c
index 862a581a4df5,40c0f4978e2f..000000000000
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@@ -830,10 -812,11 +830,18 @@@ static void iser_route_handler(struct r
  	conn_param.rnr_retry_count     = 6;
  
  	memset(&req_hdr, 0, sizeof(req_hdr));
++<<<<<<< HEAD
 +	req_hdr.flags = (ISER_ZBVA_NOT_SUPPORTED |
 +			ISER_SEND_W_INV_NOT_SUPPORTED);
 +	conn_param.private_data		= (void *)&req_hdr;
 +	conn_param.private_data_len	= sizeof(struct iser_cm_hdr);
++=======
+ 	req_hdr.flags = ISER_ZBVA_NOT_SUP;
+ 	if (!device->remote_inv_sup)
+ 		req_hdr.flags |= ISER_SEND_W_INV_NOT_SUP;
+ 	conn_param.private_data	= (void *)&req_hdr;
+ 	conn_param.private_data_len = sizeof(struct iser_cm_hdr);
++>>>>>>> 59caaed7a72a (IB/iser: Support the remote invalidation exception)
  
  	ret = rdma_connect(cma_id, &conn_param);
  	if (ret) {
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.h
* Unmerged path drivers/infiniband/ulp/iser/iser_initiator.c
diff --git a/drivers/infiniband/ulp/iser/iser_memory.c b/drivers/infiniband/ulp/iser/iser_memory.c
index 5502beb685d5..98349387388f 100644
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@ -70,6 +70,7 @@ int iser_assign_reg_ops(struct iser_device *device)
 	if (dev_attr->device_cap_flags & IB_DEVICE_MEM_MGT_EXTENSIONS) {
 		iser_info("FastReg supported, using FastReg for registration\n");
 		device->reg_ops = &fastreg_ops;
+		device->remote_inv_sup = iser_always_reg;
 	} else {
 		iser_err("IB device does not support FMRs nor FastRegs, can't register memory\n");
 		return -1;
* Unmerged path drivers/infiniband/ulp/iser/iser_verbs.c
