drivers:hv: Modify hv_vmbus to search for all MMIO ranges available.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hv] Modify hv_vmbus to search for all MMIO ranges available (Vitaly Kuznetsov) [1321073]
Rebuild_FUZZ: 89.43%
commit-author Jake Oshins <jakeo@microsoft.com>
commit 7f163a6fd957a85f7f66a129db1ad243a44399ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7f163a6f.failed

This patch changes the logic in hv_vmbus to record all of the ranges in the
VM's firmware (BIOS or UEFI) that offer regions of memory-mapped I/O space for
use by paravirtual front-end drivers.  The old logic just found one range
above 4GB and called it good.  This logic will find any ranges above 1MB.

It would have been possible with this patch to just use existing resource
allocation functions, rather than keep track of the entire set of Hyper-V
related MMIO regions in VMBus.  This strategy, however, is not sufficient
when the resource allocator needs to be aware of the constraints of a
Hyper-V virtual machine, which is what happens in the next patch in the series.
So this first patch exists to show the first steps in reworking the MMIO
allocation paths for Hyper-V front-end drivers.

	Signed-off-by: Jake Oshins <jakeo@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 7f163a6fd957a85f7f66a129db1ad243a44399ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/vmbus_drv.c
diff --cc drivers/hv/vmbus_drv.c
index 42f61fe233fb,ee59e06c2194..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -103,17 -102,9 +103,14 @@@ static struct notifier_block hyperv_pan
  	.notifier_call = hyperv_panic_event,
  };
  
- struct resource hyperv_mmio = {
- 	.name  = "hyperv mmio",
- 	.flags = IORESOURCE_MEM,
- };
+ struct resource *hyperv_mmio;
  EXPORT_SYMBOL_GPL(hyperv_mmio);
  
 +struct hv_device_info {
 +	struct hv_ring_buffer_debug_info inbound;
 +	struct hv_ring_buffer_debug_info outbound;
 +};
 +
  static int vmbus_exists(void)
  {
  	if (hv_acpi_dev == NULL)
@@@ -999,10 -1038,53 +1012,58 @@@ static acpi_status vmbus_walk_resources
  		break;
  
  	case ACPI_RESOURCE_TYPE_ADDRESS64:
++<<<<<<< HEAD
 +		hyperv_mmio.start = res->data.address64.minimum;
 +		hyperv_mmio.end = res->data.address64.maximum;
++=======
+ 		start = res->data.address64.address.minimum;
+ 		end = res->data.address64.address.maximum;
++>>>>>>> 7f163a6fd957 (drivers:hv: Modify hv_vmbus to search for all MMIO ranges available.)
  		break;
+ 
+ 	default:
+ 		/* Unused resource type */
+ 		return AE_OK;
+ 
  	}
+ 	/*
+ 	 * Ignore ranges that are below 1MB, as they're not
+ 	 * necessary or useful here.
+ 	 */
+ 	if (end < 0x100000)
+ 		return AE_OK;
+ 
+ 	new_res = kzalloc(sizeof(*new_res), GFP_ATOMIC);
+ 	if (!new_res)
+ 		return AE_NO_MEMORY;
+ 
+ 	/* If this range overlaps the virtual TPM, truncate it. */
+ 	if (end > VTPM_BASE_ADDRESS && start < VTPM_BASE_ADDRESS)
+ 		end = VTPM_BASE_ADDRESS;
+ 
+ 	new_res->name = "hyperv mmio";
+ 	new_res->flags = IORESOURCE_MEM;
+ 	new_res->start = start;
+ 	new_res->end = end;
+ 
+ 	do {
+ 		if (!*old_res) {
+ 			*old_res = new_res;
+ 			break;
+ 		}
+ 
+ 		if ((*old_res)->end < new_res->start) {
+ 			new_res->sibling = *old_res;
+ 			if (prev_res)
+ 				(*prev_res)->sibling = new_res;
+ 			*old_res = new_res;
+ 			break;
+ 		}
+ 
+ 		prev_res = old_res;
+ 		old_res = &(*old_res)->sibling;
+ 
+ 	} while (1);
  
  	return AE_OK;
  }
* Unmerged path drivers/hv/vmbus_drv.c
diff --git a/drivers/video/hyperv_fb.c b/drivers/video/hyperv_fb.c
index 807ee22ef229..b54ee1c05a5f 100644
--- a/drivers/video/hyperv_fb.c
+++ b/drivers/video/hyperv_fb.c
@@ -688,7 +688,7 @@ static int hvfb_getmem(struct fb_info *info)
 	par->mem.name = KBUILD_MODNAME;
 	par->mem.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
 	if (gen2vm) {
-		ret = allocate_resource(&hyperv_mmio, &par->mem,
+		ret = allocate_resource(hyperv_mmio, &par->mem,
 					screen_fb_size,
 					0, -1,
 					screen_fb_size,
diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 5538109db318..a45f3efe115c 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1214,7 +1214,7 @@ void hv_vss_deinit(void);
 void hv_vss_onchannelcallback(void *);
 void hv_process_channel_removal(struct vmbus_channel *channel, u32 relid);
 
-extern struct resource hyperv_mmio;
+extern struct resource *hyperv_mmio;
 
 /*
  * Negotiated version with the Host.
