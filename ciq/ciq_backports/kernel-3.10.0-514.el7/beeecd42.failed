net: cdc_ncm/cdc_mbim: adding NCM protocol statistics

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bjørn Mork <bjorn@mork.no>
commit beeecd42c3b41d17d0bf1d839db99274c287f514
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/beeecd42.failed

To have an idea of the effects of the protocol coalescing
it's useful to have some counters showing the different
aspects.

Due to the asymmetrical usbnet interface the netdev
rx_bytes counter has been counting real received payload,
while the tx_bytes counter has included the NCM/MBIM
framing overhead. This overhead can be many times the
payload because of the aggressive padding strategy of
this driver, and will vary a lot depending on device
and traffic.

With very few exceptions, users are only interested in
the payload size.  Having an somewhat accurate payload
byte counter is particularly important for mobile
broadband devices, which many NCM devices and of course
all MBIM devices are. Users and userspace applications
will use this counter to monitor account quotas.

Having protocol specific counters for the overhead, we are
now able to correct the tx_bytes netdev counter so that
it shows the real payload

	Signed-off-by: Bjørn Mork <bjorn@mork.no>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit beeecd42c3b41d17d0bf1d839db99274c287f514)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/cdc_ncm.c
#	include/linux/usb/cdc_ncm.h
diff --cc drivers/net/usb/cdc_ncm.c
index 4bae7ffa5334,f4b439847d04..000000000000
--- a/drivers/net/usb/cdc_ncm.c
+++ b/drivers/net/usb/cdc_ncm.c
@@@ -68,31 -65,270 +68,152 @@@ static void cdc_ncm_tx_timeout_start(st
  static enum hrtimer_restart cdc_ncm_tx_timer_cb(struct hrtimer *hr_timer);
  static struct usb_driver cdc_ncm_driver;
  
++<<<<<<< HEAD
 +static void
 +cdc_ncm_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
++=======
+ struct cdc_ncm_stats {
+ 	char stat_string[ETH_GSTRING_LEN];
+ 	int sizeof_stat;
+ 	int stat_offset;
+ };
+ 
+ #define CDC_NCM_STAT(str, m) { \
+ 		.stat_string = str, \
+ 		.sizeof_stat = sizeof(((struct cdc_ncm_ctx *)0)->m), \
+ 		.stat_offset = offsetof(struct cdc_ncm_ctx, m) }
+ #define CDC_NCM_SIMPLE_STAT(m)	CDC_NCM_STAT(__stringify(m), m)
+ 
+ static const struct cdc_ncm_stats cdc_ncm_gstrings_stats[] = {
+ 	CDC_NCM_SIMPLE_STAT(tx_reason_ntb_full),
+ 	CDC_NCM_SIMPLE_STAT(tx_reason_ndp_full),
+ 	CDC_NCM_SIMPLE_STAT(tx_reason_timeout),
+ 	CDC_NCM_SIMPLE_STAT(tx_reason_max_datagram),
+ 	CDC_NCM_SIMPLE_STAT(tx_overhead),
+ 	CDC_NCM_SIMPLE_STAT(tx_ntbs),
+ 	CDC_NCM_SIMPLE_STAT(rx_overhead),
+ 	CDC_NCM_SIMPLE_STAT(rx_ntbs),
+ };
+ 
+ static int cdc_ncm_get_sset_count(struct net_device __always_unused *netdev, int sset)
+ {
+ 	switch (sset) {
+ 	case ETH_SS_STATS:
+ 		return ARRAY_SIZE(cdc_ncm_gstrings_stats);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static void cdc_ncm_get_ethtool_stats(struct net_device *netdev,
+ 				    struct ethtool_stats __always_unused *stats,
+ 				    u64 *data)
+ {
+ 	struct usbnet *dev = netdev_priv(netdev);
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 	int i;
+ 	char *p = NULL;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(cdc_ncm_gstrings_stats); i++) {
+ 		p = (char *)ctx + cdc_ncm_gstrings_stats[i].stat_offset;
+ 		data[i] = (cdc_ncm_gstrings_stats[i].sizeof_stat == sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
+ 	}
+ }
+ 
+ static void cdc_ncm_get_strings(struct net_device __always_unused *netdev, u32 stringset, u8 *data)
+ {
+ 	u8 *p = data;
+ 	int i;
+ 
+ 	switch (stringset) {
+ 	case ETH_SS_STATS:
+ 		for (i = 0; i < ARRAY_SIZE(cdc_ncm_gstrings_stats); i++) {
+ 			memcpy(p, cdc_ncm_gstrings_stats[i].stat_string, ETH_GSTRING_LEN);
+ 			p += ETH_GSTRING_LEN;
+ 		}
+ 	}
+ }
+ 
+ static int cdc_ncm_get_coalesce(struct net_device *netdev,
+ 				struct ethtool_coalesce *ec)
++>>>>>>> beeecd42c3b4 (net: cdc_ncm/cdc_mbim: adding NCM protocol statistics)
  {
 -	struct usbnet *dev = netdev_priv(netdev);
 -	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
 +	struct usbnet *dev = netdev_priv(net);
  
 -	/* assuming maximum sized dgrams and ignoring NDPs */
 -	ec->rx_max_coalesced_frames = ctx->rx_max / ctx->max_datagram_size;
 -	ec->tx_max_coalesced_frames = ctx->tx_max / ctx->max_datagram_size;
 -
 -	/* the timer will fire CDC_NCM_TIMER_PENDING_CNT times in a row */
 -	ec->tx_coalesce_usecs = (ctx->timer_interval * CDC_NCM_TIMER_PENDING_CNT) / NSEC_PER_USEC;
 -	return 0;
 +	strlcpy(info->driver, dev->driver_name, sizeof(info->driver));
 +	strlcpy(info->version, DRIVER_VERSION, sizeof(info->version));
 +	strlcpy(info->fw_version, dev->driver_info->description,
 +		sizeof(info->fw_version));
 +	usb_make_path(dev->udev, info->bus_info, sizeof(info->bus_info));
  }
  
++<<<<<<< HEAD
 +static u8 cdc_ncm_setup(struct usbnet *dev)
++=======
+ static void cdc_ncm_update_rxtx_max(struct usbnet *dev, u32 new_rx, u32 new_tx);
+ 
+ static int cdc_ncm_set_coalesce(struct net_device *netdev,
+ 				struct ethtool_coalesce *ec)
+ {
+ 	struct usbnet *dev = netdev_priv(netdev);
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 	u32 new_rx_max = ctx->rx_max;
+ 	u32 new_tx_max = ctx->tx_max;
+ 
+ 	/* assuming maximum sized dgrams and a single NDP */
+ 	if (ec->rx_max_coalesced_frames)
+ 		new_rx_max = ec->rx_max_coalesced_frames * ctx->max_datagram_size;
+ 	if (ec->tx_max_coalesced_frames)
+ 		new_tx_max = ec->tx_max_coalesced_frames * ctx->max_datagram_size;
+ 
+ 	if (ec->tx_coalesce_usecs &&
+ 	    (ec->tx_coalesce_usecs < CDC_NCM_TIMER_INTERVAL_MIN * CDC_NCM_TIMER_PENDING_CNT ||
+ 	     ec->tx_coalesce_usecs > CDC_NCM_TIMER_INTERVAL_MAX * CDC_NCM_TIMER_PENDING_CNT))
+ 		return -EINVAL;
+ 
+ 	spin_lock_bh(&ctx->mtx);
+ 	ctx->timer_interval = ec->tx_coalesce_usecs * NSEC_PER_USEC / CDC_NCM_TIMER_PENDING_CNT;
+ 	if (!ctx->timer_interval)
+ 		ctx->tx_timer_pending = 0;
+ 	spin_unlock_bh(&ctx->mtx);
+ 
+ 	/* inform device of new values */
+ 	if (new_rx_max != ctx->rx_max || new_tx_max != ctx->tx_max)
+ 		cdc_ncm_update_rxtx_max(dev, new_rx_max, new_tx_max);
+ 	return 0;
+ }
+ 
+ static const struct ethtool_ops cdc_ncm_ethtool_ops = {
+ 	.get_settings      = usbnet_get_settings,
+ 	.set_settings      = usbnet_set_settings,
+ 	.get_link          = usbnet_get_link,
+ 	.nway_reset        = usbnet_nway_reset,
+ 	.get_drvinfo       = usbnet_get_drvinfo,
+ 	.get_msglevel      = usbnet_get_msglevel,
+ 	.set_msglevel      = usbnet_set_msglevel,
+ 	.get_ts_info       = ethtool_op_get_ts_info,
+ 	.get_sset_count    = cdc_ncm_get_sset_count,
+ 	.get_strings       = cdc_ncm_get_strings,
+ 	.get_ethtool_stats = cdc_ncm_get_ethtool_stats,
+ 	.get_coalesce      = cdc_ncm_get_coalesce,
+ 	.set_coalesce      = cdc_ncm_set_coalesce,
+ };
+ 
+ /* handle rx_max and tx_max changes */
+ static void cdc_ncm_update_rxtx_max(struct usbnet *dev, u32 new_rx, u32 new_tx)
++>>>>>>> beeecd42c3b4 (net: cdc_ncm/cdc_mbim: adding NCM protocol statistics)
  {
  	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
 -	u8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;
 -	u32 val, max, min;
 -
 -	/* clamp new_rx to sane values */
 -	min = USB_CDC_NCM_NTB_MIN_IN_SIZE;
 -	max = min_t(u32, CDC_NCM_NTB_MAX_SIZE_RX, le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize));
 -
 -	/* dwNtbInMaxSize spec violation? Use MIN size for both limits */
 -	if (max < min) {
 -		dev_warn(&dev->intf->dev, "dwNtbInMaxSize=%u is too small. Using %u\n",
 -			 le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize), min);
 -		max = min;
 -	}
 -
 -	val = clamp_t(u32, new_rx, min, max);
 -	if (val != new_rx) {
 -		dev_dbg(&dev->intf->dev, "rx_max must be in the [%u, %u] range. Using %u\n",
 -			min, max, val);
 -	}
 -
 -	/* usbnet use these values for sizing rx queues */
 -	dev->rx_urb_size = val;
 -
 -	/* inform device about NTB input size changes */
 -	if (val != ctx->rx_max) {
 -		__le32 dwNtbInMaxSize = cpu_to_le32(val);
 -
 -		dev_info(&dev->intf->dev, "setting rx_max = %u\n", val);
 -
 -		/* need to unlink rx urbs before increasing buffer size */
 -		if (netif_running(dev->net) && dev->rx_urb_size > ctx->rx_max)
 -			usbnet_unlink_rx_urbs(dev);
 -
 -		/* tell device to use new size */
 -		if (usbnet_write_cmd(dev, USB_CDC_SET_NTB_INPUT_SIZE,
 -				     USB_TYPE_CLASS | USB_DIR_OUT
 -				     | USB_RECIP_INTERFACE,
 -				     0, iface_no, &dwNtbInMaxSize, 4) < 0)
 -			dev_dbg(&dev->intf->dev, "Setting NTB Input Size failed\n");
 -		else
 -			ctx->rx_max = val;
 -	}
 -
 -	/* clamp new_tx to sane values */
 -	min = ctx->max_datagram_size + ctx->max_ndp_size + sizeof(struct usb_cdc_ncm_nth16);
 -	max = min_t(u32, CDC_NCM_NTB_MAX_SIZE_TX, le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize));
 -
 -	/* some devices set dwNtbOutMaxSize too low for the above default */
 -	min = min(min, max);
 -
 -	val = clamp_t(u32, new_tx, min, max);
 -	if (val != new_tx) {
 -		dev_dbg(&dev->intf->dev, "tx_max must be in the [%u, %u] range. Using %u\n",
 -			min, max, val);
 -	}
 -	if (val != ctx->tx_max)
 -		dev_info(&dev->intf->dev, "setting tx_max = %u\n", val);
 -
 -	/* Adding a pad byte here if necessary simplifies the handling
 -	 * in cdc_ncm_fill_tx_frame, making tx_max always represent
 -	 * the real skb max size.
 -	 *
 -	 * We cannot use dev->maxpacket here because this is called from
 -	 * .bind which is called before usbnet sets up dev->maxpacket
 -	 */
 -	if (val != le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize) &&
 -	    val % usb_maxpacket(dev->udev, dev->out, 1) == 0)
 -		val++;
 -
 -	/* we might need to flush any pending tx buffers if running */
 -	if (netif_running(dev->net) && val > ctx->tx_max) {
 -		netif_tx_lock_bh(dev->net);
 -		usbnet_start_xmit(NULL, dev->net);
 -		ctx->tx_max = val;
 -		netif_tx_unlock_bh(dev->net);
 -	} else {
 -		ctx->tx_max = val;
 -	}
 -
 -	dev->hard_mtu = ctx->tx_max;
 -
 -	/* max qlen depend on hard_mtu and rx_urb_size */
 -	usbnet_update_max_qlen(dev);
 -
 -	/* never pad more than 3 full USB packets per transfer */
 -	ctx->min_tx_pkt = clamp_t(u16, ctx->tx_max - 3 * usb_maxpacket(dev->udev, dev->out, 1),
 -				  CDC_NCM_MIN_TX_PKT, ctx->tx_max);
 -}
 -
 -/* helpers for NCM and MBIM differences */
 -static u8 cdc_ncm_flags(struct usbnet *dev)
 -{
 -	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
 -
 -	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting) && ctx->mbim_desc)
 -		return ctx->mbim_desc->bmNetworkCapabilities;
 -	if (ctx->func_desc)
 -		return ctx->func_desc->bmNetworkCapabilities;
 -	return 0;
 -}
 -
 -static int cdc_ncm_eth_hlen(struct usbnet *dev)
 -{
 -	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting))
 -		return 0;
 -	return ETH_HLEN;
 -}
 -
 -static u32 cdc_ncm_min_dgram_size(struct usbnet *dev)
 -{
 -	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting))
 -		return CDC_MBIM_MIN_DATAGRAM_SIZE;
 -	return CDC_NCM_MIN_DATAGRAM_SIZE;
 -}
 -
 -static u32 cdc_ncm_max_dgram_size(struct usbnet *dev)
 -{
 -	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
 -
 -	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting) && ctx->mbim_desc)
 -		return le16_to_cpu(ctx->mbim_desc->wMaxSegmentSize);
 -	if (ctx->ether_desc)
 -		return le16_to_cpu(ctx->ether_desc->wMaxSegmentSize);
 -	return CDC_NCM_MAX_DATAGRAM_SIZE;
 -}
 -
 -/* initial one-time device setup.  MUST be called with the data interface
 - * in altsetting 0
 - */
 -static int cdc_ncm_init(struct usbnet *dev)
 -{
 -	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
 -	u8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;
 +	u32 val;
 +	u8 flags;
 +	u8 iface_no;
  	int err;
 +	int eth_hlen;
 +	u16 mbim_mtu;
 +	u16 ntb_fmt_supported;
 +	__le16 max_datagram_size;
 +
 +	iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;
  
  	err = usbnet_read_cmd(dev, USB_CDC_GET_NTB_PARAMETERS,
  			      USB_TYPE_CLASS | USB_DIR_IN
diff --cc include/linux/usb/cdc_ncm.h
index 55b6feead93b,88d2d7f1820f..000000000000
--- a/include/linux/usb/cdc_ncm.h
+++ b/include/linux/usb/cdc_ncm.h
@@@ -119,6 -115,18 +119,21 @@@ struct cdc_ncm_ctx 
  	u16 tx_seq;
  	u16 rx_seq;
  	u16 connected;
++<<<<<<< HEAD
++=======
+ 	u16 min_tx_pkt;
+ 
+ 	/* statistics */
+ 	u32 tx_curr_frame_payload;
+ 	u32 tx_reason_ntb_full;
+ 	u32 tx_reason_ndp_full;
+ 	u32 tx_reason_timeout;
+ 	u32 tx_reason_max_datagram;
+ 	u64 tx_overhead;
+ 	u64 tx_ntbs;
+ 	u64 rx_overhead;
+ 	u64 rx_ntbs;
++>>>>>>> beeecd42c3b4 (net: cdc_ncm/cdc_mbim: adding NCM protocol statistics)
  };
  
  u8 cdc_ncm_select_altsetting(struct usb_interface *intf);
diff --git a/drivers/net/usb/cdc_mbim.c b/drivers/net/usb/cdc_mbim.c
index a164dab06678..146ba3c557de 100644
--- a/drivers/net/usb/cdc_mbim.c
+++ b/drivers/net/usb/cdc_mbim.c
@@ -420,6 +420,7 @@ static int cdc_mbim_rx_fixup(struct usbnet *dev, struct sk_buff *skb_in)
 	struct usb_cdc_ncm_dpe16 *dpe16;
 	int ndpoffset;
 	int loopcount = 50; /* arbitrary max preventing infinite loop */
+	u32 payload = 0;
 	u8 *c;
 	u16 tci;
 
@@ -482,6 +483,7 @@ next_ndp:
 			if (!skb)
 				goto error;
 			usbnet_skb_return(dev, skb);
+			payload += len;	/* count payload bytes in this NTB */
 		}
 	}
 err_ndp:
@@ -490,6 +492,10 @@ err_ndp:
 	if (ndpoffset && loopcount--)
 		goto next_ndp;
 
+	/* update stats */
+	ctx->rx_overhead += skb_in->len - payload;
+	ctx->rx_ntbs++;
+
 	return 1;
 error:
 	return 0;
* Unmerged path drivers/net/usb/cdc_ncm.c
* Unmerged path include/linux/usb/cdc_ncm.h
