ceph: kill ceph_get_dentry_parent_inode()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Yan, Zheng <zyan@redhat.com>
commit 641235d8f823574961d225bdbfaef299842aa38c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/641235d8.failed

use vfs helper dget_parent() instead

	Signed-off-by: Yan, Zheng <zyan@redhat.com>
(cherry picked from commit 641235d8f823574961d225bdbfaef299842aa38c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/dir.c
#	fs/ceph/super.h
diff --cc fs/ceph/dir.c
index 67bdd35eda74,c37820bcb66b..000000000000
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@@ -68,23 -68,6 +68,26 @@@ out_unlock
  	return 0;
  }
  
++<<<<<<< HEAD
 +struct inode *ceph_get_dentry_parent_inode(struct dentry *dentry)
 +{
 +	struct inode *inode = NULL;
 +
 +	if (!dentry)
 +		return NULL;
 +
 +	spin_lock(&dentry->d_lock);
 +	if (!IS_ROOT(dentry)) {
 +		inode = dentry->d_parent->d_inode;
 +		ihold(inode);
 +	}
 +	spin_unlock(&dentry->d_lock);
 +	return inode;
 +}
 +
 +
++=======
++>>>>>>> 641235d8f823 (ceph: kill ceph_get_dentry_parent_inode())
  /*
   * for readdir, we encode the directory frag and offset within that
   * frag into f_pos.
@@@ -1069,11 -1089,11 +1073,12 @@@ static int ceph_d_revalidate(struct den
  	if (flags & LOOKUP_RCU)
  		return -ECHILD;
  
 -	dout("d_revalidate %p '%pd' inode %p offset %lld\n", dentry,
 -	     dentry, d_inode(dentry), ceph_dentry(dentry)->offset);
 +	dout("d_revalidate %p '%.*s' inode %p offset %lld\n", dentry,
 +	     dentry->d_name.len, dentry->d_name.name, dentry->d_inode,
 +	     ceph_dentry(dentry)->offset);
  
- 	dir = ceph_get_dentry_parent_inode(dentry);
+ 	parent = dget_parent(dentry);
+ 	dir = d_inode(parent);
  
  	/* always trust cached snapped dentries, snapdir dentry */
  	if (ceph_snap(dir) != CEPH_NOSNAP) {
@@@ -1096,9 -1116,9 +1101,10 @@@
  		ceph_dentry_lru_touch(dentry);
  	} else {
  		ceph_dir_clear_complete(dir);
 +		d_drop(dentry);
  	}
- 	iput(dir);
+ 
+ 	dput(parent);
  	return valid;
  }
  
diff --cc fs/ceph/super.h
index 1c439e8e6c74,e705c4d612d7..000000000000
--- a/fs/ceph/super.h
+++ b/fs/ceph/super.h
@@@ -859,7 -957,7 +859,11 @@@ extern void ceph_dentry_lru_touch(struc
  extern void ceph_dentry_lru_del(struct dentry *dn);
  extern void ceph_invalidate_dentry_lease(struct dentry *dentry);
  extern unsigned ceph_dentry_hash(struct inode *dir, struct dentry *dn);
++<<<<<<< HEAD
 +extern struct inode *ceph_get_dentry_parent_inode(struct dentry *dentry);
++=======
+ extern void ceph_readdir_cache_release(struct ceph_readdir_cache_control *ctl);
++>>>>>>> 641235d8f823 (ceph: kill ceph_get_dentry_parent_inode())
  
  /*
   * our d_ops vary depending on whether the inode is live,
* Unmerged path fs/ceph/dir.c
* Unmerged path fs/ceph/super.h
