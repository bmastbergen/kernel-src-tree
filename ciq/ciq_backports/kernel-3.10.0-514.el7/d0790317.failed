IB/hfi1: Remove EPROM functionality from data device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit d079031742023a00e1deda0fa847d403b4b91c76
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d0790317.failed

Remove EPROM handling from the cdev which is used for user application
data traffic.

	Reviewed-by: Dean Luick <dean.luick@intel.com>
	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit d079031742023a00e1deda0fa847d403b4b91c76)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/eprom.c
#	drivers/staging/hfi1/file_ops.c
diff --cc drivers/staging/hfi1/eprom.c
index 4668c094ceef,36b77943cbfd..000000000000
--- a/drivers/staging/hfi1/eprom.c
+++ b/drivers/staging/hfi1/eprom.c
@@@ -94,357 -55,12 +58,364 @@@
  /* controller interface speeds */
  #define EP_SPEED_FULL 0x2	/* full speed */
  
++<<<<<<< HEAD:drivers/staging/hfi1/eprom.c
 +/* controller status register 1 bits */
 +#define SR1_BUSY 0x1ull		/* the BUSY bit in SR1 */
 +
 +/* sleep length while waiting for controller */
 +#define WAIT_SLEEP_US 100	/* must be larger than 5 (see usage) */
 +#define COUNT_DELAY_SEC(n) ((n) * (1000000/WAIT_SLEEP_US))
 +
 +/* GPIO pins */
 +#define EPROM_WP_N BIT_ULL(14)	/* EPROM write line */
 +
++=======
++>>>>>>> d07903174202 (IB/hfi1: Remove EPROM functionality from data device):drivers/staging/rdma/hfi1/eprom.c
 +/*
 + * Use the EP mutex to guard against other callers from within the driver.
 + * Also covers usage of eprom_available.
 + */
++<<<<<<< HEAD:drivers/staging/hfi1/eprom.c
 +static DEFINE_MUTEX(eprom_mutex);
 +static int eprom_available;	/* default: not available */
 +
 +/*
 + * Turn on external enable line that allows writing on the flash.
 + */
 +static void write_enable(struct hfi1_devdata *dd)
 +{
 +	/* raise signal */
 +	write_csr(dd, ASIC_GPIO_OUT,
 +		read_csr(dd, ASIC_GPIO_OUT) | EPROM_WP_N);
 +	/* raise enable */
 +	write_csr(dd, ASIC_GPIO_OE,
 +		read_csr(dd, ASIC_GPIO_OE) | EPROM_WP_N);
 +}
 +
 +/*
 + * Turn off external enable line that allows writing on the flash.
 + */
 +static void write_disable(struct hfi1_devdata *dd)
 +{
 +	/* lower signal */
 +	write_csr(dd, ASIC_GPIO_OUT,
 +		read_csr(dd, ASIC_GPIO_OUT) & ~EPROM_WP_N);
 +	/* lower enable */
 +	write_csr(dd, ASIC_GPIO_OE,
 +		read_csr(dd, ASIC_GPIO_OE) & ~EPROM_WP_N);
 +}
 +
 +/*
 + * Wait for the device to become not busy.  Must be called after all
 + * write or erase operations.
 + */
 +static int wait_for_not_busy(struct hfi1_devdata *dd)
 +{
 +	unsigned long count = 0;
 +	u64 reg;
 +	int ret = 0;
 +
 +	/* starts page mode */
 +	write_csr(dd, ASIC_EEP_ADDR_CMD, CMD_READ_SR1);
 +	while (1) {
 +		udelay(WAIT_SLEEP_US);
 +		usleep_range(WAIT_SLEEP_US - 5, WAIT_SLEEP_US + 5);
 +		count++;
 +		reg = read_csr(dd, ASIC_EEP_DATA);
 +		if ((reg & SR1_BUSY) == 0)
 +			break;
 +		/* 200s is the largest time for a 128Mb device */
 +		if (count > COUNT_DELAY_SEC(200)) {
 +			dd_dev_err(dd, "waited too long for SPI FLASH busy to clear - failing\n");
 +			ret = -ETIMEDOUT;
 +			break; /* break, not goto - must stop page mode */
 +		}
 +	}
 +
 +	/* stop page mode with a NOP */
 +	write_csr(dd, ASIC_EEP_ADDR_CMD, CMD_NOP);
 +
 +	return ret;
 +}
 +
 +/*
 + * Read the device ID from the SPI controller.
 + */
 +static u32 read_device_id(struct hfi1_devdata *dd)
 +{
 +	/* read the Manufacture Device ID */
 +	write_csr(dd, ASIC_EEP_ADDR_CMD, CMD_READ_MANUF_DEV_ID);
 +	return (u32)read_csr(dd, ASIC_EEP_DATA);
 +}
 +
  /*
 - * How long to wait for the EPROM to become available, in ms.
 - * The spec 32 Mb EPROM takes around 40s to erase then write.
 - * Double it for safety.
 + * Erase the whole flash.
   */
 +static int erase_chip(struct hfi1_devdata *dd)
 +{
 +	int ret;
 +
 +	write_enable(dd);
 +
 +	write_csr(dd, ASIC_EEP_ADDR_CMD, CMD_WRITE_ENABLE);
 +	write_csr(dd, ASIC_EEP_ADDR_CMD, CMD_CHIP_ERASE);
 +	ret = wait_for_not_busy(dd);
 +
 +	write_disable(dd);
 +
 +	return ret;
 +}
 +
 +/*
 + * Erase a range.
 + */
 +static int erase_range(struct hfi1_devdata *dd, u32 start, u32 len)
 +{
 +	u32 end = start + len;
 +	int ret = 0;
 +
 +	if (end < start)
 +		return -EINVAL;
 +
 +	/* check the end points for the minimum erase */
 +	if ((start & MASK_4KB) || (end & MASK_4KB)) {
 +		dd_dev_err(dd,
 +			"%s: non-aligned range (0x%x,0x%x) for a 4KB erase\n",
 +			__func__, start, end);
 +		return -EINVAL;
 +	}
 +
 +	write_enable(dd);
 +
 +	while (start < end) {
 +		write_csr(dd, ASIC_EEP_ADDR_CMD, CMD_WRITE_ENABLE);
 +		/* check in order of largest to smallest */
 +		if (((start & MASK_64KB) == 0) && (start + SIZE_64KB <= end)) {
 +			write_csr(dd, ASIC_EEP_ADDR_CMD,
 +				  CMD_SECTOR_ERASE_64KB(start));
 +			start += SIZE_64KB;
 +		} else if (((start & MASK_32KB) == 0) &&
 +			   (start + SIZE_32KB <= end)) {
 +			write_csr(dd, ASIC_EEP_ADDR_CMD,
 +				  CMD_SECTOR_ERASE_32KB(start));
 +			start += SIZE_32KB;
 +		} else {	/* 4KB will work */
 +			write_csr(dd, ASIC_EEP_ADDR_CMD,
 +				  CMD_SECTOR_ERASE_4KB(start));
 +			start += SIZE_4KB;
 +		}
 +		ret = wait_for_not_busy(dd);
 +		if (ret)
 +			goto done;
 +	}
 +
 +done:
 +	write_disable(dd);
 +
 +	return ret;
 +}
 +
 +/*
 + * Read a 256 byte (64 dword) EPROM page.
 + * All callers have verified the offset is at a page boundary.
 + */
 +static void read_page(struct hfi1_devdata *dd, u32 offset, u32 *result)
 +{
 +	int i;
 +
 +	write_csr(dd, ASIC_EEP_ADDR_CMD, CMD_READ_DATA(offset));
 +	for (i = 0; i < EP_PAGE_SIZE/sizeof(u32); i++)
 +		result[i] = (u32)read_csr(dd, ASIC_EEP_DATA);
 +	write_csr(dd, ASIC_EEP_ADDR_CMD, CMD_NOP); /* close open page */
 +}
 +
 +/*
 + * Read length bytes starting at offset.  Copy to user address addr.
 + */
 +static int read_length(struct hfi1_devdata *dd, u32 start, u32 len, u64 addr)
 +{
 +	u32 offset;
 +	u32 buffer[EP_PAGE_SIZE/sizeof(u32)];
 +	int ret = 0;
 +
 +	/* reject anything not on an EPROM page boundary */
 +	if ((start & EEP_PAGE_MASK) || (len & EEP_PAGE_MASK))
 +		return -EINVAL;
 +
 +	for (offset = 0; offset < len; offset += EP_PAGE_SIZE) {
 +		read_page(dd, start + offset, buffer);
 +		if (copy_to_user((void __user *)(addr + offset),
 +						buffer, EP_PAGE_SIZE)) {
 +			ret = -EFAULT;
 +			goto done;
 +		}
 +	}
 +
 +done:
 +	return ret;
 +}
 +
 +/*
 + * Write a 256 byte (64 dword) EPROM page.
 + * All callers have verified the offset is at a page boundary.
 + */
 +static int write_page(struct hfi1_devdata *dd, u32 offset, u32 *data)
 +{
 +	int i;
 +
 +	write_csr(dd, ASIC_EEP_ADDR_CMD, CMD_WRITE_ENABLE);
 +	write_csr(dd, ASIC_EEP_DATA, data[0]);
 +	write_csr(dd, ASIC_EEP_ADDR_CMD, CMD_PAGE_PROGRAM(offset));
 +	for (i = 1; i < EP_PAGE_SIZE/sizeof(u32); i++)
 +		write_csr(dd, ASIC_EEP_DATA, data[i]);
 +	/* will close the open page */
 +	return wait_for_not_busy(dd);
 +}
 +
 +/*
 + * Write length bytes starting at offset.  Read from user address addr.
 + */
 +static int write_length(struct hfi1_devdata *dd, u32 start, u32 len, u64 addr)
 +{
 +	u32 offset;
 +	u32 buffer[EP_PAGE_SIZE/sizeof(u32)];
 +	int ret = 0;
 +
 +	/* reject anything not on an EPROM page boundary */
 +	if ((start & EEP_PAGE_MASK) || (len & EEP_PAGE_MASK))
 +		return -EINVAL;
 +
 +	write_enable(dd);
 +
 +	for (offset = 0; offset < len; offset += EP_PAGE_SIZE) {
 +		if (copy_from_user(buffer, (void __user *)(addr + offset),
 +						EP_PAGE_SIZE)) {
 +			ret = -EFAULT;
 +			goto done;
 +		}
 +		ret = write_page(dd, start + offset, buffer);
 +		if (ret)
 +			goto done;
 +	}
 +
 +done:
 +	write_disable(dd);
 +	return ret;
 +}
 +
 +/* convert an range composite to a length, in bytes */
 +static inline u32 extract_rlen(u32 composite)
 +{
 +	return (composite & 0xffff) * EP_PAGE_SIZE;
 +}
 +
 +/* convert an range composite to a start, in bytes */
 +static inline u32 extract_rstart(u32 composite)
 +{
 +	return (composite >> 16) * EP_PAGE_SIZE;
 +}
 +
 +/*
 + * Perform the given operation on the EPROM.  Called from user space.  The
 + * user credentials have already been checked.
 + *
 + * Return 0 on success, -ERRNO on error
 + */
 +int handle_eprom_command(struct file *fp, const struct hfi1_cmd *cmd)
 +{
 +	struct hfi1_devdata *dd;
 +	u32 dev_id;
 +	u32 rlen;	/* range length */
 +	u32 rstart;	/* range start */
 +	int i_minor;
 +	int ret = 0;
 +
 +	/*
 +	 * Map the device file to device data using the relative minor.
 +	 * The device file minor number is the unit number + 1.  0 is
 +	 * the generic device file - reject it.
 +	 */
 +	i_minor = iminor(file_inode(fp)) - HFI1_USER_MINOR_BASE;
 +	if (i_minor <= 0)
 +		return -EINVAL;
 +	dd = hfi1_lookup(i_minor - 1);
 +	if (!dd) {
 +		pr_err("%s: cannot find unit %d!\n", __func__, i_minor);
 +		return -EINVAL;
 +	}
 +
 +	/* lock against other callers touching the ASIC block */
 +	mutex_lock(&eprom_mutex);
 +
 +	/* some platforms do not have an EPROM */
 +	if (!eprom_available) {
 +		ret = -ENOSYS;
 +		goto done_asic;
 +	}
 +
 +	/* lock against the other HFI on another OS */
 +	ret = acquire_hw_mutex(dd);
 +	if (ret) {
 +		dd_dev_err(dd,
 +			"%s: unable to acquire hw mutex, no EPROM support\n",
 +			__func__);
 +		goto done_asic;
 +	}
 +
 +	dd_dev_info(dd, "%s: cmd: type %d, len 0x%x, addr 0x%016llx\n",
 +		__func__, cmd->type, cmd->len, cmd->addr);
 +
 +	switch (cmd->type) {
 +	case HFI1_CMD_EP_INFO:
 +		if (cmd->len != sizeof(u32)) {
 +			ret = -ERANGE;
 +			break;
 +		}
 +		dev_id = read_device_id(dd);
 +		/* addr points to a u32 user buffer */
 +		if (copy_to_user((void __user *)cmd->addr, &dev_id,
 +								sizeof(u32)))
 +			ret = -EFAULT;
 +		break;
 +
 +	case HFI1_CMD_EP_ERASE_CHIP:
 +		ret = erase_chip(dd);
 +		break;
 +
 +	case HFI1_CMD_EP_ERASE_RANGE:
 +		rlen = extract_rlen(cmd->len);
 +		rstart = extract_rstart(cmd->len);
 +		ret = erase_range(dd, rstart, rlen);
 +		break;
 +
 +	case HFI1_CMD_EP_READ_RANGE:
 +		rlen = extract_rlen(cmd->len);
 +		rstart = extract_rstart(cmd->len);
 +		ret = read_length(dd, rstart, rlen, cmd->addr);
 +		break;
 +
 +	case HFI1_CMD_EP_WRITE_RANGE:
 +		rlen = extract_rlen(cmd->len);
 +		rstart = extract_rstart(cmd->len);
 +		ret = write_length(dd, rstart, rlen, cmd->addr);
 +		break;
 +
 +	default:
 +		dd_dev_err(dd, "%s: unexpected command %d\n",
 +			__func__, cmd->type);
 +		ret = -EINVAL;
 +		break;
 +	}
 +
 +	release_hw_mutex(dd);
 +done_asic:
 +	mutex_unlock(&eprom_mutex);
 +	return ret;
 +}
 +
++=======
+ #define EPROM_TIMEOUT 80000 /* ms */
++>>>>>>> d07903174202 (IB/hfi1: Remove EPROM functionality from data device):drivers/staging/rdma/hfi1/eprom.c
  /*
   * Initialize the EPROM handler.
   */
diff --cc drivers/staging/hfi1/file_ops.c
index e659deb91d74,2eddd3305c6a..000000000000
--- a/drivers/staging/hfi1/file_ops.c
+++ b/drivers/staging/hfi1/file_ops.c
@@@ -214,8 -189,11 +214,7 @@@ static ssize_t hfi1_file_write(struct f
  	void *dest = NULL;
  	__u64 user_val = 0;
  	int uctxt_required = 1;
- 	int must_be_root = 0;
  
 -	/* FIXME: This interface cannot continue out of staging */
 -	if (WARN_ON_ONCE(!ib_safe_file_access(fp)))
 -		return -EACCES;
 -
  	if (count < sizeof(cmd)) {
  		ret = -EINVAL;
  		goto bail;
@@@ -254,16 -233,6 +253,19 @@@
  		copy = 0;
  		user_val = cmd.addr;
  		break;
++<<<<<<< HEAD:drivers/staging/hfi1/file_ops.c
 +	case HFI1_CMD_EP_INFO:
 +	case HFI1_CMD_EP_ERASE_CHIP:
 +	case HFI1_CMD_EP_ERASE_RANGE:
 +	case HFI1_CMD_EP_READ_RANGE:
 +	case HFI1_CMD_EP_WRITE_RANGE:
 +		uctxt_required = 0;	/* assigned user context not required */
 +		must_be_root = 1;	/* validate user */
 +		copy = 0;
 +		break;
 +	case HFI1_CMD_TID_INVAL_READ:
++=======
++>>>>>>> d07903174202 (IB/hfi1: Remove EPROM functionality from data device):drivers/staging/rdma/hfi1/file_ops.c
  	default:
  		ret = -EINVAL;
  		goto bail;
* Unmerged path drivers/staging/hfi1/eprom.c
* Unmerged path drivers/staging/hfi1/file_ops.c
diff --git a/include/uapi/rdma/hfi/hfi1_user.h b/include/uapi/rdma/hfi/hfi1_user.h
index ffb34be0d3fb..6f12a649f359 100644
--- a/include/uapi/rdma/hfi/hfi1_user.h
+++ b/include/uapi/rdma/hfi/hfi1_user.h
@@ -122,13 +122,6 @@
 #define HFI1_CMD_SET_PKEY        11     /* set context's pkey */
 #define HFI1_CMD_CTXT_RESET      12     /* reset context's HW send context */
 #define HFI1_CMD_TID_INVAL_READ  13     /* read TID cache invalidations */
-/* separate EPROM commands from normal PSM commands */
-#define HFI1_CMD_EP_INFO         64      /* read EPROM device ID */
-#define HFI1_CMD_EP_ERASE_CHIP   65      /* erase whole EPROM */
-/* range 66-74 no longer used */
-#define HFI1_CMD_EP_ERASE_RANGE  75      /* erase EPROM range */
-#define HFI1_CMD_EP_READ_RANGE   76      /* read EPROM range */
-#define HFI1_CMD_EP_WRITE_RANGE  77      /* write EPROM range */
 
 #define _HFI1_EVENT_FROZEN_BIT         0
 #define _HFI1_EVENT_LINKDOWN_BIT       1
