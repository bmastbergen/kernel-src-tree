sched/wait: Introduce wait_on_bit_timeout()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Johan Hedberg <johan.hedberg@intel.com>
commit 44fc0e5eec00db5fba748803c95920098089c4cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/44fc0e5e.failed

Add a new wait_on_bit_timeout() helper, basically the same as
wait_on_bit() except that it also takes a 'timeout' parameter.

All the building blocks like bit_wait_timeout() and
out_of_line_wait_on_bit_timeout() are already in place so the
addition is rather simple.

	Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: davem@davemloft.net
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
Link: http://lkml.kernel.org/r/1422616476-2917-2-git-send-email-johan.hedberg@gmail.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 44fc0e5eec00db5fba748803c95920098089c4cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/wait.h
diff --cc include/linux/wait.h
index 65da9e322613,537d58eea8a0..000000000000
--- a/include/linux/wait.h
+++ b/include/linux/wait.h
@@@ -995,10 -949,92 +995,92 @@@ int wake_bit_function(wait_queue_t *wai
   * call wait_on_bit() in threads waiting for the bit to clear.
   * One uses wait_on_bit() where one is waiting for the bit to clear,
   * but has no intention of setting it.
 - * Returned value will be zero if the bit was cleared, or non-zero
 - * if the process received a signal and the mode permitted wakeup
 - * on that signal.
   */
 -static inline int
 -wait_on_bit(void *word, int bit, unsigned mode)
 +static inline int wait_on_bit(void *word, int bit,
 +				int (*action)(void *), unsigned mode)
  {
++<<<<<<< HEAD
++=======
+ 	might_sleep();
+ 	if (!test_bit(bit, word))
+ 		return 0;
+ 	return out_of_line_wait_on_bit(word, bit,
+ 				       bit_wait,
+ 				       mode);
+ }
+ 
+ /**
+  * wait_on_bit_io - wait for a bit to be cleared
+  * @word: the word being waited on, a kernel virtual address
+  * @bit: the bit of the word being waited on
+  * @mode: the task state to sleep in
+  *
+  * Use the standard hashed waitqueue table to wait for a bit
+  * to be cleared.  This is similar to wait_on_bit(), but calls
+  * io_schedule() instead of schedule() for the actual waiting.
+  *
+  * Returned value will be zero if the bit was cleared, or non-zero
+  * if the process received a signal and the mode permitted wakeup
+  * on that signal.
+  */
+ static inline int
+ wait_on_bit_io(void *word, int bit, unsigned mode)
+ {
+ 	might_sleep();
+ 	if (!test_bit(bit, word))
+ 		return 0;
+ 	return out_of_line_wait_on_bit(word, bit,
+ 				       bit_wait_io,
+ 				       mode);
+ }
+ 
+ /**
+  * wait_on_bit_timeout - wait for a bit to be cleared or a timeout elapses
+  * @word: the word being waited on, a kernel virtual address
+  * @bit: the bit of the word being waited on
+  * @mode: the task state to sleep in
+  * @timeout: timeout, in jiffies
+  *
+  * Use the standard hashed waitqueue table to wait for a bit
+  * to be cleared. This is similar to wait_on_bit(), except also takes a
+  * timeout parameter.
+  *
+  * Returned value will be zero if the bit was cleared before the
+  * @timeout elapsed, or non-zero if the @timeout elapsed or process
+  * received a signal and the mode permitted wakeup on that signal.
+  */
+ static inline int
+ wait_on_bit_timeout(void *word, int bit, unsigned mode, unsigned long timeout)
+ {
+ 	might_sleep();
+ 	if (!test_bit(bit, word))
+ 		return 0;
+ 	return out_of_line_wait_on_bit_timeout(word, bit,
+ 					       bit_wait_timeout,
+ 					       mode, timeout);
+ }
+ 
+ /**
+  * wait_on_bit_action - wait for a bit to be cleared
+  * @word: the word being waited on, a kernel virtual address
+  * @bit: the bit of the word being waited on
+  * @action: the function used to sleep, which may take special actions
+  * @mode: the task state to sleep in
+  *
+  * Use the standard hashed waitqueue table to wait for a bit
+  * to be cleared, and allow the waiting action to be specified.
+  * This is like wait_on_bit() but allows fine control of how the waiting
+  * is done.
+  *
+  * Returned value will be zero if the bit was cleared, or non-zero
+  * if the process received a signal and the mode permitted wakeup
+  * on that signal.
+  */
+ static inline int
+ wait_on_bit_action(void *word, int bit, wait_bit_action_f *action, unsigned mode)
+ {
+ 	might_sleep();
++>>>>>>> 44fc0e5eec00 (sched/wait: Introduce wait_on_bit_timeout())
  	if (!test_bit(bit, word))
  		return 0;
  	return out_of_line_wait_on_bit(word, bit, action, mode);
* Unmerged path include/linux/wait.h
