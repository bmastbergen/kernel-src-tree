HID: use to_hid_device()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hid] use to_hid_device() (Benjamin Tissoires) [1311883]
Rebuild_FUZZ: 88.37%
commit-author Geliang Tang <geliangtang@163.com>
commit ee79a8f840a45d331bc33e55cbcc89bba417671c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ee79a8f8.failed

Use to_hid_device() instead of container_of().

	Signed-off-by: Geliang Tang <geliangtang@163.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit ee79a8f840a45d331bc33e55cbcc89bba417671c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/hid-cp2112.c
#	drivers/hid/hid-gt683r.c
#	drivers/hid/hid-lenovo.c
#	drivers/hid/hid-sony.c
#	drivers/hid/wacom_sys.c
diff --cc drivers/hid/hid-sony.c
index 312098e4af4f,9bbf5a725139..000000000000
--- a/drivers/hid/hid-sony.c
+++ b/drivers/hid/hid-sony.c
@@@ -188,8 -1429,831 +188,836 @@@ static int sixaxis_set_operational_usb(
  
  static int sixaxis_set_operational_bt(struct hid_device *hdev)
  {
++<<<<<<< HEAD
 +	unsigned char buf[] = { 0xf4,  0x42, 0x03, 0x00, 0x00 };
 +	return hdev->hid_output_raw_report(hdev, buf, sizeof(buf), HID_FEATURE_REPORT);
++=======
+ 	static const __u8 report[] = { 0xf4, 0x42, 0x03, 0x00, 0x00 };
+ 	__u8 *buf;
+ 	int ret;
+ 
+ 	buf = kmemdup(report, sizeof(report), GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	ret = hid_hw_raw_request(hdev, buf[0], buf, sizeof(report),
+ 				  HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
+ 
+ 	kfree(buf);
+ 
+ 	return ret;
+ }
+ 
+ /*
+  * Requesting feature report 0x02 in Bluetooth mode changes the state of the
+  * controller so that it sends full input reports of type 0x11.
+  */
+ static int dualshock4_set_operational_bt(struct hid_device *hdev)
+ {
+ 	__u8 *buf;
+ 	int ret;
+ 
+ 	buf = kmalloc(DS4_REPORT_0x02_SIZE, GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	ret = hid_hw_raw_request(hdev, 0x02, buf, DS4_REPORT_0x02_SIZE,
+ 				HID_FEATURE_REPORT, HID_REQ_GET_REPORT);
+ 
+ 	kfree(buf);
+ 
+ 	return ret;
+ }
+ 
+ static void sixaxis_set_leds_from_id(struct sony_sc *sc)
+ {
+ 	static const __u8 sixaxis_leds[10][4] = {
+ 				{ 0x01, 0x00, 0x00, 0x00 },
+ 				{ 0x00, 0x01, 0x00, 0x00 },
+ 				{ 0x00, 0x00, 0x01, 0x00 },
+ 				{ 0x00, 0x00, 0x00, 0x01 },
+ 				{ 0x01, 0x00, 0x00, 0x01 },
+ 				{ 0x00, 0x01, 0x00, 0x01 },
+ 				{ 0x00, 0x00, 0x01, 0x01 },
+ 				{ 0x01, 0x00, 0x01, 0x01 },
+ 				{ 0x00, 0x01, 0x01, 0x01 },
+ 				{ 0x01, 0x01, 0x01, 0x01 }
+ 	};
+ 
+ 	int id = sc->device_id;
+ 
+ 	BUILD_BUG_ON(MAX_LEDS < ARRAY_SIZE(sixaxis_leds[0]));
+ 
+ 	if (id < 0)
+ 		return;
+ 
+ 	id %= 10;
+ 	memcpy(sc->led_state, sixaxis_leds[id], sizeof(sixaxis_leds[id]));
+ }
+ 
+ static void dualshock4_set_leds_from_id(struct sony_sc *sc)
+ {
+ 	/* The first 4 color/index entries match what the PS4 assigns */
+ 	static const __u8 color_code[7][3] = {
+ 			/* Blue   */	{ 0x00, 0x00, 0x01 },
+ 			/* Red	  */	{ 0x01, 0x00, 0x00 },
+ 			/* Green  */	{ 0x00, 0x01, 0x00 },
+ 			/* Pink   */	{ 0x02, 0x00, 0x01 },
+ 			/* Orange */	{ 0x02, 0x01, 0x00 },
+ 			/* Teal   */	{ 0x00, 0x01, 0x01 },
+ 			/* White  */	{ 0x01, 0x01, 0x01 }
+ 	};
+ 
+ 	int id = sc->device_id;
+ 
+ 	BUILD_BUG_ON(MAX_LEDS < ARRAY_SIZE(color_code[0]));
+ 
+ 	if (id < 0)
+ 		return;
+ 
+ 	id %= 7;
+ 	memcpy(sc->led_state, color_code[id], sizeof(color_code[id]));
+ }
+ 
+ static void buzz_set_leds(struct sony_sc *sc)
+ {
+ 	struct hid_device *hdev = sc->hdev;
+ 	struct list_head *report_list =
+ 		&hdev->report_enum[HID_OUTPUT_REPORT].report_list;
+ 	struct hid_report *report = list_entry(report_list->next,
+ 		struct hid_report, list);
+ 	__s32 *value = report->field[0]->value;
+ 
+ 	BUILD_BUG_ON(MAX_LEDS < 4);
+ 
+ 	value[0] = 0x00;
+ 	value[1] = sc->led_state[0] ? 0xff : 0x00;
+ 	value[2] = sc->led_state[1] ? 0xff : 0x00;
+ 	value[3] = sc->led_state[2] ? 0xff : 0x00;
+ 	value[4] = sc->led_state[3] ? 0xff : 0x00;
+ 	value[5] = 0x00;
+ 	value[6] = 0x00;
+ 	hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
+ }
+ 
+ static void sony_set_leds(struct sony_sc *sc)
+ {
+ 	if (!(sc->quirks & BUZZ_CONTROLLER))
+ 		schedule_work(&sc->state_worker);
+ 	else
+ 		buzz_set_leds(sc);
+ }
+ 
+ static void sony_led_set_brightness(struct led_classdev *led,
+ 				    enum led_brightness value)
+ {
+ 	struct device *dev = led->dev->parent;
+ 	struct hid_device *hdev = to_hid_device(dev);
+ 	struct sony_sc *drv_data;
+ 
+ 	int n;
+ 	int force_update;
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	if (!drv_data) {
+ 		hid_err(hdev, "No device data\n");
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * The Sixaxis on USB will override any LED settings sent to it
+ 	 * and keep flashing all of the LEDs until the PS button is pressed.
+ 	 * Updates, even if redundant, must be always be sent to the
+ 	 * controller to avoid having to toggle the state of an LED just to
+ 	 * stop the flashing later on.
+ 	 */
+ 	force_update = !!(drv_data->quirks & SIXAXIS_CONTROLLER_USB);
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		if (led == drv_data->leds[n] && (force_update ||
+ 			(value != drv_data->led_state[n] ||
+ 			drv_data->led_delay_on[n] ||
+ 			drv_data->led_delay_off[n]))) {
+ 
+ 			drv_data->led_state[n] = value;
+ 
+ 			/* Setting the brightness stops the blinking */
+ 			drv_data->led_delay_on[n] = 0;
+ 			drv_data->led_delay_off[n] = 0;
+ 
+ 			sony_set_leds(drv_data);
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ static enum led_brightness sony_led_get_brightness(struct led_classdev *led)
+ {
+ 	struct device *dev = led->dev->parent;
+ 	struct hid_device *hdev = to_hid_device(dev);
+ 	struct sony_sc *drv_data;
+ 
+ 	int n;
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	if (!drv_data) {
+ 		hid_err(hdev, "No device data\n");
+ 		return LED_OFF;
+ 	}
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		if (led == drv_data->leds[n])
+ 			return drv_data->led_state[n];
+ 	}
+ 
+ 	return LED_OFF;
+ }
+ 
+ static int sony_led_blink_set(struct led_classdev *led, unsigned long *delay_on,
+ 				unsigned long *delay_off)
+ {
+ 	struct device *dev = led->dev->parent;
+ 	struct hid_device *hdev = to_hid_device(dev);
+ 	struct sony_sc *drv_data = hid_get_drvdata(hdev);
+ 	int n;
+ 	__u8 new_on, new_off;
+ 
+ 	if (!drv_data) {
+ 		hid_err(hdev, "No device data\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Max delay is 255 deciseconds or 2550 milliseconds */
+ 	if (*delay_on > 2550)
+ 		*delay_on = 2550;
+ 	if (*delay_off > 2550)
+ 		*delay_off = 2550;
+ 
+ 	/* Blink at 1 Hz if both values are zero */
+ 	if (!*delay_on && !*delay_off)
+ 		*delay_on = *delay_off = 500;
+ 
+ 	new_on = *delay_on / 10;
+ 	new_off = *delay_off / 10;
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		if (led == drv_data->leds[n])
+ 			break;
+ 	}
+ 
+ 	/* This LED is not registered on this device */
+ 	if (n >= drv_data->led_count)
+ 		return -EINVAL;
+ 
+ 	/* Don't schedule work if the values didn't change */
+ 	if (new_on != drv_data->led_delay_on[n] ||
+ 		new_off != drv_data->led_delay_off[n]) {
+ 		drv_data->led_delay_on[n] = new_on;
+ 		drv_data->led_delay_off[n] = new_off;
+ 		schedule_work(&drv_data->state_worker);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void sony_leds_remove(struct sony_sc *sc)
+ {
+ 	struct led_classdev *led;
+ 	int n;
+ 
+ 	BUG_ON(!(sc->quirks & SONY_LED_SUPPORT));
+ 
+ 	for (n = 0; n < sc->led_count; n++) {
+ 		led = sc->leds[n];
+ 		sc->leds[n] = NULL;
+ 		if (!led)
+ 			continue;
+ 		led_classdev_unregister(led);
+ 		kfree(led);
+ 	}
+ 
+ 	sc->led_count = 0;
+ }
+ 
+ static int sony_leds_init(struct sony_sc *sc)
+ {
+ 	struct hid_device *hdev = sc->hdev;
+ 	int n, ret = 0;
+ 	int use_ds4_names;
+ 	struct led_classdev *led;
+ 	size_t name_sz;
+ 	char *name;
+ 	size_t name_len;
+ 	const char *name_fmt;
+ 	static const char * const ds4_name_str[] = { "red", "green", "blue",
+ 						  "global" };
+ 	__u8 max_brightness[MAX_LEDS] = { [0 ... (MAX_LEDS - 1)] = 1 };
+ 	__u8 use_hw_blink[MAX_LEDS] = { 0 };
+ 
+ 	BUG_ON(!(sc->quirks & SONY_LED_SUPPORT));
+ 
+ 	if (sc->quirks & BUZZ_CONTROLLER) {
+ 		sc->led_count = 4;
+ 		use_ds4_names = 0;
+ 		name_len = strlen("::buzz#");
+ 		name_fmt = "%s::buzz%d";
+ 		/* Validate expected report characteristics. */
+ 		if (!hid_validate_values(hdev, HID_OUTPUT_REPORT, 0, 0, 7))
+ 			return -ENODEV;
+ 	} else if (sc->quirks & DUALSHOCK4_CONTROLLER) {
+ 		dualshock4_set_leds_from_id(sc);
+ 		sc->led_state[3] = 1;
+ 		sc->led_count = 4;
+ 		memset(max_brightness, 255, 3);
+ 		use_hw_blink[3] = 1;
+ 		use_ds4_names = 1;
+ 		name_len = 0;
+ 		name_fmt = "%s:%s";
+ 	} else if (sc->quirks & MOTION_CONTROLLER) {
+ 		sc->led_count = 3;
+ 		memset(max_brightness, 255, 3);
+ 		use_ds4_names = 1;
+ 		name_len = 0;
+ 		name_fmt = "%s:%s";
+ 	} else if (sc->quirks & NAVIGATION_CONTROLLER) {
+ 		static const __u8 navigation_leds[4] = {0x01, 0x00, 0x00, 0x00};
+ 
+ 		memcpy(sc->led_state, navigation_leds, sizeof(navigation_leds));
+ 		sc->led_count = 1;
+ 		memset(use_hw_blink, 1, 4);
+ 		use_ds4_names = 0;
+ 		name_len = strlen("::sony#");
+ 		name_fmt = "%s::sony%d";
+ 	} else {
+ 		sixaxis_set_leds_from_id(sc);
+ 		sc->led_count = 4;
+ 		memset(use_hw_blink, 1, 4);
+ 		use_ds4_names = 0;
+ 		name_len = strlen("::sony#");
+ 		name_fmt = "%s::sony%d";
+ 	}
+ 
+ 	/*
+ 	 * Clear LEDs as we have no way of reading their initial state. This is
+ 	 * only relevant if the driver is loaded after somebody actively set the
+ 	 * LEDs to on
+ 	 */
+ 	sony_set_leds(sc);
+ 
+ 	name_sz = strlen(dev_name(&hdev->dev)) + name_len + 1;
+ 
+ 	for (n = 0; n < sc->led_count; n++) {
+ 
+ 		if (use_ds4_names)
+ 			name_sz = strlen(dev_name(&hdev->dev)) + strlen(ds4_name_str[n]) + 2;
+ 
+ 		led = kzalloc(sizeof(struct led_classdev) + name_sz, GFP_KERNEL);
+ 		if (!led) {
+ 			hid_err(hdev, "Couldn't allocate memory for LED %d\n", n);
+ 			ret = -ENOMEM;
+ 			goto error_leds;
+ 		}
+ 
+ 		name = (void *)(&led[1]);
+ 		if (use_ds4_names)
+ 			snprintf(name, name_sz, name_fmt, dev_name(&hdev->dev),
+ 			ds4_name_str[n]);
+ 		else
+ 			snprintf(name, name_sz, name_fmt, dev_name(&hdev->dev), n + 1);
+ 		led->name = name;
+ 		led->brightness = sc->led_state[n];
+ 		led->max_brightness = max_brightness[n];
+ 		led->brightness_get = sony_led_get_brightness;
+ 		led->brightness_set = sony_led_set_brightness;
+ 
+ 		if (use_hw_blink[n])
+ 			led->blink_set = sony_led_blink_set;
+ 
+ 		sc->leds[n] = led;
+ 
+ 		ret = led_classdev_register(&hdev->dev, led);
+ 		if (ret) {
+ 			hid_err(hdev, "Failed to register LED %d\n", n);
+ 			sc->leds[n] = NULL;
+ 			kfree(led);
+ 			goto error_leds;
+ 		}
+ 	}
+ 
+ 	return ret;
+ 
+ error_leds:
+ 	sony_leds_remove(sc);
+ 
+ 	return ret;
+ }
+ 
+ static void sixaxis_state_worker(struct work_struct *work)
+ {
+ 	static const union sixaxis_output_report_01 default_report = {
+ 		.buf = {
+ 			0x01,
+ 			0x00, 0xff, 0x00, 0xff, 0x00,
+ 			0x00, 0x00, 0x00, 0x00, 0x00,
+ 			0xff, 0x27, 0x10, 0x00, 0x32,
+ 			0xff, 0x27, 0x10, 0x00, 0x32,
+ 			0xff, 0x27, 0x10, 0x00, 0x32,
+ 			0xff, 0x27, 0x10, 0x00, 0x32,
+ 			0x00, 0x00, 0x00, 0x00, 0x00
+ 		}
+ 	};
+ 	struct sony_sc *sc = container_of(work, struct sony_sc, state_worker);
+ 	struct sixaxis_output_report *report =
+ 		(struct sixaxis_output_report *)sc->output_report_dmabuf;
+ 	int n;
+ 
+ 	/* Initialize the report with default values */
+ 	memcpy(report, &default_report, sizeof(struct sixaxis_output_report));
+ 
+ #ifdef CONFIG_SONY_FF
+ 	report->rumble.right_motor_on = sc->right ? 1 : 0;
+ 	report->rumble.left_motor_force = sc->left;
+ #endif
+ 
+ 	report->leds_bitmap |= sc->led_state[0] << 1;
+ 	report->leds_bitmap |= sc->led_state[1] << 2;
+ 	report->leds_bitmap |= sc->led_state[2] << 3;
+ 	report->leds_bitmap |= sc->led_state[3] << 4;
+ 
+ 	/* Set flag for all leds off, required for 3rd party INTEC controller */
+ 	if ((report->leds_bitmap & 0x1E) == 0)
+ 		report->leds_bitmap |= 0x20;
+ 
+ 	/*
+ 	 * The LEDs in the report are indexed in reverse order to their
+ 	 * corresponding light on the controller.
+ 	 * Index 0 = LED 4, index 1 = LED 3, etc...
+ 	 *
+ 	 * In the case of both delay values being zero (blinking disabled) the
+ 	 * default report values should be used or the controller LED will be
+ 	 * always off.
+ 	 */
+ 	for (n = 0; n < 4; n++) {
+ 		if (sc->led_delay_on[n] || sc->led_delay_off[n]) {
+ 			report->led[3 - n].duty_off = sc->led_delay_off[n];
+ 			report->led[3 - n].duty_on = sc->led_delay_on[n];
+ 		}
+ 	}
+ 
+ 	hid_hw_raw_request(sc->hdev, report->report_id, (__u8 *)report,
+ 			sizeof(struct sixaxis_output_report),
+ 			HID_OUTPUT_REPORT, HID_REQ_SET_REPORT);
+ }
+ 
+ static void dualshock4_state_worker(struct work_struct *work)
+ {
+ 	struct sony_sc *sc = container_of(work, struct sony_sc, state_worker);
+ 	struct hid_device *hdev = sc->hdev;
+ 	__u8 *buf = sc->output_report_dmabuf;
+ 	int offset;
+ 
+ 	if (sc->quirks & DUALSHOCK4_CONTROLLER_USB) {
+ 		memset(buf, 0, DS4_REPORT_0x05_SIZE);
+ 		buf[0] = 0x05;
+ 		buf[1] = 0xFF;
+ 		offset = 4;
+ 	} else {
+ 		memset(buf, 0, DS4_REPORT_0x11_SIZE);
+ 		buf[0] = 0x11;
+ 		buf[1] = 0x80;
+ 		buf[3] = 0x0F;
+ 		offset = 6;
+ 	}
+ 
+ #ifdef CONFIG_SONY_FF
+ 	buf[offset++] = sc->right;
+ 	buf[offset++] = sc->left;
+ #else
+ 	offset += 2;
+ #endif
+ 
+ 	/* LED 3 is the global control */
+ 	if (sc->led_state[3]) {
+ 		buf[offset++] = sc->led_state[0];
+ 		buf[offset++] = sc->led_state[1];
+ 		buf[offset++] = sc->led_state[2];
+ 	} else {
+ 		offset += 3;
+ 	}
+ 
+ 	/* If both delay values are zero the DualShock 4 disables blinking. */
+ 	buf[offset++] = sc->led_delay_on[3];
+ 	buf[offset++] = sc->led_delay_off[3];
+ 
+ 	if (sc->quirks & DUALSHOCK4_CONTROLLER_USB)
+ 		hid_hw_output_report(hdev, buf, DS4_REPORT_0x05_SIZE);
+ 	else
+ 		hid_hw_raw_request(hdev, 0x11, buf, DS4_REPORT_0x11_SIZE,
+ 				HID_OUTPUT_REPORT, HID_REQ_SET_REPORT);
+ }
+ 
+ static void motion_state_worker(struct work_struct *work)
+ {
+ 	struct sony_sc *sc = container_of(work, struct sony_sc, state_worker);
+ 	struct hid_device *hdev = sc->hdev;
+ 	struct motion_output_report_02 *report =
+ 		(struct motion_output_report_02 *)sc->output_report_dmabuf;
+ 
+ 	memset(report, 0, MOTION_REPORT_0x02_SIZE);
+ 
+ 	report->type = 0x02; /* set leds */
+ 	report->r = sc->led_state[0];
+ 	report->g = sc->led_state[1];
+ 	report->b = sc->led_state[2];
+ 
+ #ifdef CONFIG_SONY_FF
+ 	report->rumble = max(sc->right, sc->left);
+ #endif
+ 
+ 	hid_hw_output_report(hdev, (__u8 *)report, MOTION_REPORT_0x02_SIZE);
+ }
+ 
+ static int sony_allocate_output_report(struct sony_sc *sc)
+ {
+ 	if ((sc->quirks & SIXAXIS_CONTROLLER) ||
+ 			(sc->quirks & NAVIGATION_CONTROLLER))
+ 		sc->output_report_dmabuf =
+ 			kmalloc(sizeof(union sixaxis_output_report_01),
+ 				GFP_KERNEL);
+ 	else if (sc->quirks & DUALSHOCK4_CONTROLLER_BT)
+ 		sc->output_report_dmabuf = kmalloc(DS4_REPORT_0x11_SIZE,
+ 						GFP_KERNEL);
+ 	else if (sc->quirks & DUALSHOCK4_CONTROLLER_USB)
+ 		sc->output_report_dmabuf = kmalloc(DS4_REPORT_0x05_SIZE,
+ 						GFP_KERNEL);
+ 	else if (sc->quirks & MOTION_CONTROLLER)
+ 		sc->output_report_dmabuf = kmalloc(MOTION_REPORT_0x02_SIZE,
+ 						GFP_KERNEL);
+ 	else
+ 		return 0;
+ 
+ 	if (!sc->output_report_dmabuf)
+ 		return -ENOMEM;
+ 
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_SONY_FF
+ static int sony_play_effect(struct input_dev *dev, void *data,
+ 			    struct ff_effect *effect)
+ {
+ 	struct hid_device *hid = input_get_drvdata(dev);
+ 	struct sony_sc *sc = hid_get_drvdata(hid);
+ 
+ 	if (effect->type != FF_RUMBLE)
+ 		return 0;
+ 
+ 	sc->left = effect->u.rumble.strong_magnitude / 256;
+ 	sc->right = effect->u.rumble.weak_magnitude / 256;
+ 
+ 	schedule_work(&sc->state_worker);
+ 	return 0;
+ }
+ 
+ static int sony_init_ff(struct sony_sc *sc)
+ {
+ 	struct hid_input *hidinput = list_entry(sc->hdev->inputs.next,
+ 						struct hid_input, list);
+ 	struct input_dev *input_dev = hidinput->input;
+ 
+ 	input_set_capability(input_dev, EV_FF, FF_RUMBLE);
+ 	return input_ff_create_memless(input_dev, NULL, sony_play_effect);
+ }
+ 
+ #else
+ static int sony_init_ff(struct sony_sc *sc)
+ {
+ 	return 0;
+ }
+ 
+ #endif
+ 
+ static int sony_battery_get_property(struct power_supply *psy,
+ 				     enum power_supply_property psp,
+ 				     union power_supply_propval *val)
+ {
+ 	struct sony_sc *sc = power_supply_get_drvdata(psy);
+ 	unsigned long flags;
+ 	int ret = 0;
+ 	u8 battery_charging, battery_capacity, cable_state;
+ 
+ 	spin_lock_irqsave(&sc->lock, flags);
+ 	battery_charging = sc->battery_charging;
+ 	battery_capacity = sc->battery_capacity;
+ 	cable_state = sc->cable_state;
+ 	spin_unlock_irqrestore(&sc->lock, flags);
+ 
+ 	switch (psp) {
+ 	case POWER_SUPPLY_PROP_PRESENT:
+ 		val->intval = 1;
+ 		break;
+ 	case POWER_SUPPLY_PROP_SCOPE:
+ 		val->intval = POWER_SUPPLY_SCOPE_DEVICE;
+ 		break;
+ 	case POWER_SUPPLY_PROP_CAPACITY:
+ 		val->intval = battery_capacity;
+ 		break;
+ 	case POWER_SUPPLY_PROP_STATUS:
+ 		if (battery_charging)
+ 			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+ 		else
+ 			if (battery_capacity == 100 && cable_state)
+ 				val->intval = POWER_SUPPLY_STATUS_FULL;
+ 			else
+ 				val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 	return ret;
+ }
+ 
+ static int sony_battery_probe(struct sony_sc *sc)
+ {
+ 	struct power_supply_config psy_cfg = { .drv_data = sc, };
+ 	struct hid_device *hdev = sc->hdev;
+ 	int ret;
+ 
+ 	/*
+ 	 * Set the default battery level to 100% to avoid low battery warnings
+ 	 * if the battery is polled before the first device report is received.
+ 	 */
+ 	sc->battery_capacity = 100;
+ 
+ 	sc->battery_desc.properties = sony_battery_props;
+ 	sc->battery_desc.num_properties = ARRAY_SIZE(sony_battery_props);
+ 	sc->battery_desc.get_property = sony_battery_get_property;
+ 	sc->battery_desc.type = POWER_SUPPLY_TYPE_BATTERY;
+ 	sc->battery_desc.use_for_apm = 0;
+ 	sc->battery_desc.name = kasprintf(GFP_KERNEL,
+ 					  "sony_controller_battery_%pMR",
+ 					  sc->mac_address);
+ 	if (!sc->battery_desc.name)
+ 		return -ENOMEM;
+ 
+ 	sc->battery = power_supply_register(&hdev->dev, &sc->battery_desc,
+ 					    &psy_cfg);
+ 	if (IS_ERR(sc->battery)) {
+ 		ret = PTR_ERR(sc->battery);
+ 		hid_err(hdev, "Unable to register battery device\n");
+ 		goto err_free;
+ 	}
+ 
+ 	power_supply_powers(sc->battery, &hdev->dev);
+ 	return 0;
+ 
+ err_free:
+ 	kfree(sc->battery_desc.name);
+ 	sc->battery_desc.name = NULL;
+ 	return ret;
+ }
+ 
+ static void sony_battery_remove(struct sony_sc *sc)
+ {
+ 	if (!sc->battery_desc.name)
+ 		return;
+ 
+ 	power_supply_unregister(sc->battery);
+ 	kfree(sc->battery_desc.name);
+ 	sc->battery_desc.name = NULL;
+ }
+ 
+ /*
+  * If a controller is plugged in via USB while already connected via Bluetooth
+  * it will show up as two devices. A global list of connected controllers and
+  * their MAC addresses is maintained to ensure that a device is only connected
+  * once.
+  */
+ static int sony_check_add_dev_list(struct sony_sc *sc)
+ {
+ 	struct sony_sc *entry;
+ 	unsigned long flags;
+ 	int ret;
+ 
+ 	spin_lock_irqsave(&sony_dev_list_lock, flags);
+ 
+ 	list_for_each_entry(entry, &sony_device_list, list_node) {
+ 		ret = memcmp(sc->mac_address, entry->mac_address,
+ 				sizeof(sc->mac_address));
+ 		if (!ret) {
+ 			ret = -EEXIST;
+ 			hid_info(sc->hdev, "controller with MAC address %pMR already connected\n",
+ 				sc->mac_address);
+ 			goto unlock;
+ 		}
+ 	}
+ 
+ 	ret = 0;
+ 	list_add(&(sc->list_node), &sony_device_list);
+ 
+ unlock:
+ 	spin_unlock_irqrestore(&sony_dev_list_lock, flags);
+ 	return ret;
+ }
+ 
+ static void sony_remove_dev_list(struct sony_sc *sc)
+ {
+ 	unsigned long flags;
+ 
+ 	if (sc->list_node.next) {
+ 		spin_lock_irqsave(&sony_dev_list_lock, flags);
+ 		list_del(&(sc->list_node));
+ 		spin_unlock_irqrestore(&sony_dev_list_lock, flags);
+ 	}
+ }
+ 
+ static int sony_get_bt_devaddr(struct sony_sc *sc)
+ {
+ 	int ret;
+ 
+ 	/* HIDP stores the device MAC address as a string in the uniq field. */
+ 	ret = strlen(sc->hdev->uniq);
+ 	if (ret != 17)
+ 		return -EINVAL;
+ 
+ 	ret = sscanf(sc->hdev->uniq,
+ 		"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+ 		&sc->mac_address[5], &sc->mac_address[4], &sc->mac_address[3],
+ 		&sc->mac_address[2], &sc->mac_address[1], &sc->mac_address[0]);
+ 
+ 	if (ret != 6)
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ static int sony_check_add(struct sony_sc *sc)
+ {
+ 	__u8 *buf = NULL;
+ 	int n, ret;
+ 
+ 	if ((sc->quirks & DUALSHOCK4_CONTROLLER_BT) ||
+ 	    (sc->quirks & MOTION_CONTROLLER_BT) ||
+ 	    (sc->quirks & NAVIGATION_CONTROLLER_BT) ||
+ 	    (sc->quirks & SIXAXIS_CONTROLLER_BT)) {
+ 		/*
+ 		 * sony_get_bt_devaddr() attempts to parse the Bluetooth MAC
+ 		 * address from the uniq string where HIDP stores it.
+ 		 * As uniq cannot be guaranteed to be a MAC address in all cases
+ 		 * a failure of this function should not prevent the connection.
+ 		 */
+ 		if (sony_get_bt_devaddr(sc) < 0) {
+ 			hid_warn(sc->hdev, "UNIQ does not contain a MAC address; duplicate check skipped\n");
+ 			return 0;
+ 		}
+ 	} else if (sc->quirks & DUALSHOCK4_CONTROLLER_USB) {
+ 		buf = kmalloc(DS4_REPORT_0x81_SIZE, GFP_KERNEL);
+ 		if (!buf)
+ 			return -ENOMEM;
+ 
+ 		/*
+ 		 * The MAC address of a DS4 controller connected via USB can be
+ 		 * retrieved with feature report 0x81. The address begins at
+ 		 * offset 1.
+ 		 */
+ 		ret = hid_hw_raw_request(sc->hdev, 0x81, buf,
+ 				DS4_REPORT_0x81_SIZE, HID_FEATURE_REPORT,
+ 				HID_REQ_GET_REPORT);
+ 
+ 		if (ret != DS4_REPORT_0x81_SIZE) {
+ 			hid_err(sc->hdev, "failed to retrieve feature report 0x81 with the DualShock 4 MAC address\n");
+ 			ret = ret < 0 ? ret : -EINVAL;
+ 			goto out_free;
+ 		}
+ 
+ 		memcpy(sc->mac_address, &buf[1], sizeof(sc->mac_address));
+ 	} else if ((sc->quirks & SIXAXIS_CONTROLLER_USB) ||
+ 			(sc->quirks & NAVIGATION_CONTROLLER_USB)) {
+ 		buf = kmalloc(SIXAXIS_REPORT_0xF2_SIZE, GFP_KERNEL);
+ 		if (!buf)
+ 			return -ENOMEM;
+ 
+ 		/*
+ 		 * The MAC address of a Sixaxis controller connected via USB can
+ 		 * be retrieved with feature report 0xf2. The address begins at
+ 		 * offset 4.
+ 		 */
+ 		ret = hid_hw_raw_request(sc->hdev, 0xf2, buf,
+ 				SIXAXIS_REPORT_0xF2_SIZE, HID_FEATURE_REPORT,
+ 				HID_REQ_GET_REPORT);
+ 
+ 		if (ret != SIXAXIS_REPORT_0xF2_SIZE) {
+ 			hid_err(sc->hdev, "failed to retrieve feature report 0xf2 with the Sixaxis MAC address\n");
+ 			ret = ret < 0 ? ret : -EINVAL;
+ 			goto out_free;
+ 		}
+ 
+ 		/*
+ 		 * The Sixaxis device MAC in the report is big-endian and must
+ 		 * be byte-swapped.
+ 		 */
+ 		for (n = 0; n < 6; n++)
+ 			sc->mac_address[5-n] = buf[4+n];
+ 	} else {
+ 		return 0;
+ 	}
+ 
+ 	ret = sony_check_add_dev_list(sc);
+ 
+ out_free:
+ 
+ 	kfree(buf);
+ 
+ 	return ret;
+ }
+ 
+ static int sony_set_device_id(struct sony_sc *sc)
+ {
+ 	int ret;
+ 
+ 	/*
+ 	 * Only DualShock 4 or Sixaxis controllers get an id.
+ 	 * All others are set to -1.
+ 	 */
+ 	if ((sc->quirks & SIXAXIS_CONTROLLER) ||
+ 	    (sc->quirks & DUALSHOCK4_CONTROLLER)) {
+ 		ret = ida_simple_get(&sony_device_id_allocator, 0, 0,
+ 					GFP_KERNEL);
+ 		if (ret < 0) {
+ 			sc->device_id = -1;
+ 			return ret;
+ 		}
+ 		sc->device_id = ret;
+ 	} else {
+ 		sc->device_id = -1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void sony_release_device_id(struct sony_sc *sc)
+ {
+ 	if (sc->device_id >= 0) {
+ 		ida_simple_remove(&sony_device_id_allocator, sc->device_id);
+ 		sc->device_id = -1;
+ 	}
+ }
+ 
+ static inline void sony_init_work(struct sony_sc *sc,
+ 					void (*worker)(struct work_struct *))
+ {
+ 	if (!sc->worker_initialized)
+ 		INIT_WORK(&sc->state_worker, worker);
+ 
+ 	sc->worker_initialized = 1;
+ }
+ 
+ static inline void sony_cancel_work_sync(struct sony_sc *sc)
+ {
+ 	if (sc->worker_initialized)
+ 		cancel_work_sync(&sc->state_worker);
++>>>>>>> ee79a8f840a4 (HID: use to_hid_device())
  }
  
  static int sony_probe(struct hid_device *hdev, const struct hid_device_id *id)
* Unmerged path drivers/hid/hid-cp2112.c
* Unmerged path drivers/hid/hid-gt683r.c
* Unmerged path drivers/hid/hid-lenovo.c
* Unmerged path drivers/hid/wacom_sys.c
diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
index e354ab28c2b2..2e8e2671a021 100644
--- a/drivers/hid/hid-core.c
+++ b/drivers/hid/hid-core.c
@@ -625,7 +625,7 @@ static void hid_close_report(struct hid_device *device)
 
 static void hid_device_release(struct device *dev)
 {
-	struct hid_device *hid = container_of(dev, struct hid_device, dev);
+	struct hid_device *hid = to_hid_device(dev);
 
 	hid_close_report(hid);
 	kfree(hid->dev_rdesc);
@@ -1509,7 +1509,7 @@ read_report_descriptor(struct file *filp, struct kobject *kobj,
 		char *buf, loff_t off, size_t count)
 {
 	struct device *dev = container_of(kobj, struct device, kobj);
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 
 	if (off >= hdev->rsize)
 		return 0;
@@ -1526,7 +1526,7 @@ static ssize_t
 show_country(struct device *dev, struct device_attribute *attr,
 		char *buf)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 
 	return sprintf(buf, "%02x\n", hdev->country & 0xff);
 }
@@ -2009,7 +2009,7 @@ static const struct hid_device_id *hid_match_device(struct hid_device *hdev,
 static int hid_bus_match(struct device *dev, struct device_driver *drv)
 {
 	struct hid_driver *hdrv = container_of(drv, struct hid_driver, driver);
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 
 	return hid_match_device(hdev, hdrv) != NULL;
 }
@@ -2018,7 +2018,7 @@ static int hid_device_probe(struct device *dev)
 {
 	struct hid_driver *hdrv = container_of(dev->driver,
 			struct hid_driver, driver);
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	const struct hid_device_id *id;
 	int ret = 0;
 
@@ -2060,7 +2060,7 @@ unlock_driver_lock:
 
 static int hid_device_remove(struct device *dev)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct hid_driver *hdrv;
 	int ret = 0;
 
@@ -2108,7 +2108,7 @@ static struct device_attribute hid_dev_attrs[] = {
 
 static int hid_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);	
 
 	if (add_uevent_var(env, "HID_ID=%04X:%08X:%08X",
 			hdev->bus, hdev->vendor, hdev->product))
* Unmerged path drivers/hid/hid-cp2112.c
* Unmerged path drivers/hid/hid-gt683r.c
* Unmerged path drivers/hid/hid-lenovo.c
diff --git a/drivers/hid/hid-lg4ff.c b/drivers/hid/hid-lg4ff.c
index 351805362290..1f2671981a68 100644
--- a/drivers/hid/hid-lg4ff.c
+++ b/drivers/hid/hid-lg4ff.c
@@ -453,7 +453,7 @@ static void lg4ff_led_set_brightness(struct led_classdev *led_cdev,
 			enum led_brightness value)
 {
 	struct device *dev = led_cdev->dev->parent;
-	struct hid_device *hid = container_of(dev, struct hid_device, dev);
+	struct hid_device *hid = to_hid_device(dev);
 	struct lg_drv_data *drv_data = hid_get_drvdata(hid);
 	struct lg4ff_device_entry *entry;
 	int i, state = 0;
@@ -488,7 +488,7 @@ static void lg4ff_led_set_brightness(struct led_classdev *led_cdev,
 static enum led_brightness lg4ff_led_get_brightness(struct led_classdev *led_cdev)
 {
 	struct device *dev = led_cdev->dev->parent;
-	struct hid_device *hid = container_of(dev, struct hid_device, dev);
+	struct hid_device *hid = to_hid_device(dev);
 	struct lg_drv_data *drv_data = hid_get_drvdata(hid);
 	struct lg4ff_device_entry *entry;
 	int i, value = 0;
diff --git a/drivers/hid/hid-multitouch.c b/drivers/hid/hid-multitouch.c
index ac1a207a60ca..6cdd64f4695b 100644
--- a/drivers/hid/hid-multitouch.c
+++ b/drivers/hid/hid-multitouch.c
@@ -275,7 +275,7 @@ static ssize_t mt_show_quirks(struct device *dev,
 			   struct device_attribute *attr,
 			   char *buf)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct mt_device *td = hid_get_drvdata(hdev);
 
 	return sprintf(buf, "%u\n", td->mtclass.quirks);
@@ -285,7 +285,7 @@ static ssize_t mt_set_quirks(struct device *dev,
 			  struct device_attribute *attr,
 			  const char *buf, size_t count)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct mt_device *td = hid_get_drvdata(hdev);
 
 	unsigned long val;
diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index 5482156ab4de..e071fc03ea81 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -173,7 +173,7 @@ static ssize_t show_phys_width(struct device *dev,
 			       struct device_attribute *attr,
 			       char *buf)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	return sprintf(buf, "%d\n", nd->sensor_physical_width);
@@ -185,7 +185,7 @@ static ssize_t show_phys_height(struct device *dev,
 				struct device_attribute *attr,
 				char *buf)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	return sprintf(buf, "%d\n", nd->sensor_physical_height);
@@ -197,7 +197,7 @@ static ssize_t show_log_width(struct device *dev,
 			      struct device_attribute *attr,
 			      char *buf)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	return sprintf(buf, "%d\n", nd->sensor_logical_width);
@@ -209,7 +209,7 @@ static ssize_t show_log_height(struct device *dev,
 			       struct device_attribute *attr,
 			       char *buf)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	return sprintf(buf, "%d\n", nd->sensor_logical_height);
@@ -221,7 +221,7 @@ static ssize_t show_min_width(struct device *dev,
 			      struct device_attribute *attr,
 			      char *buf)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	return sprintf(buf, "%d\n", nd->min_width *
@@ -233,7 +233,7 @@ static ssize_t set_min_width(struct device *dev,
 			     struct device_attribute *attr,
 			     const char *buf, size_t count)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	unsigned long val;
@@ -256,7 +256,7 @@ static ssize_t show_min_height(struct device *dev,
 			       struct device_attribute *attr,
 			       char *buf)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	return sprintf(buf, "%d\n", nd->min_height *
@@ -268,7 +268,7 @@ static ssize_t set_min_height(struct device *dev,
 			      struct device_attribute *attr,
 			      const char *buf, size_t count)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	unsigned long val;
@@ -292,7 +292,7 @@ static ssize_t show_activate_slack(struct device *dev,
 				   struct device_attribute *attr,
 				   char *buf)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	return sprintf(buf, "%d\n", nd->activate_slack);
@@ -302,7 +302,7 @@ static ssize_t set_activate_slack(struct device *dev,
 				  struct device_attribute *attr,
 				  const char *buf, size_t count)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	unsigned long val;
@@ -325,7 +325,7 @@ static ssize_t show_activation_width(struct device *dev,
 				     struct device_attribute *attr,
 				     char *buf)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	return sprintf(buf, "%d\n", nd->activation_width *
@@ -337,7 +337,7 @@ static ssize_t set_activation_width(struct device *dev,
 				    struct device_attribute *attr,
 				    const char *buf, size_t count)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	unsigned long val;
@@ -361,7 +361,7 @@ static ssize_t show_activation_height(struct device *dev,
 				      struct device_attribute *attr,
 				      char *buf)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	return sprintf(buf, "%d\n", nd->activation_height *
@@ -373,7 +373,7 @@ static ssize_t set_activation_height(struct device *dev,
 				     struct device_attribute *attr,
 				     const char *buf, size_t count)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	unsigned long val;
@@ -397,7 +397,7 @@ static ssize_t show_deactivate_slack(struct device *dev,
 				     struct device_attribute *attr,
 				     char *buf)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	return sprintf(buf, "%d\n", -nd->deactivate_slack);
@@ -407,7 +407,7 @@ static ssize_t set_deactivate_slack(struct device *dev,
 				    struct device_attribute *attr,
 				    const char *buf, size_t count)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
 	unsigned long val;
diff --git a/drivers/hid/hid-picolcd_leds.c b/drivers/hid/hid-picolcd_leds.c
index e994f9c29012..a802b4f49c7b 100644
--- a/drivers/hid/hid-picolcd_leds.c
+++ b/drivers/hid/hid-picolcd_leds.c
@@ -66,7 +66,7 @@ static void picolcd_led_set_brightness(struct led_classdev *led_cdev,
 	int i, state = 0;
 
 	dev  = led_cdev->dev->parent;
-	hdev = container_of(dev, struct hid_device, dev);
+	hdev = to_hid_device(dev);
 	data = hid_get_drvdata(hdev);
 	if (!data)
 		return;
@@ -93,7 +93,7 @@ static enum led_brightness picolcd_led_get_brightness(struct led_classdev *led_c
 	int i, value = 0;
 
 	dev  = led_cdev->dev->parent;
-	hdev = container_of(dev, struct hid_device, dev);
+	hdev = to_hid_device(dev);
 	data = hid_get_drvdata(hdev);
 	for (i = 0; i < 8; i++)
 		if (led_cdev == data->led[i]) {
diff --git a/drivers/hid/hid-prodikeys.c b/drivers/hid/hid-prodikeys.c
index 7ed828056414..0a3ff8f2b9f4 100644
--- a/drivers/hid/hid-prodikeys.c
+++ b/drivers/hid/hid-prodikeys.c
@@ -103,7 +103,7 @@ MODULE_PARM_DESC(enable, "Enable for the PC-MIDI virtual audio driver");
 static ssize_t show_channel(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct pk_device *pk = hid_get_drvdata(hdev);
 
 	dbg_hid("pcmidi sysfs read channel=%u\n", pk->pm->midi_channel);
@@ -116,7 +116,7 @@ static ssize_t show_channel(struct device *dev,
 static ssize_t store_channel(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct pk_device *pk = hid_get_drvdata(hdev);
 
 	unsigned channel = 0;
@@ -140,7 +140,7 @@ static struct device_attribute *sysfs_device_attr_channel = {
 static ssize_t show_sustain(struct device *dev,
  struct device_attribute *attr, char *buf)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct pk_device *pk = hid_get_drvdata(hdev);
 
 	dbg_hid("pcmidi sysfs read sustain=%u\n", pk->pm->midi_sustain);
@@ -153,7 +153,7 @@ static ssize_t show_sustain(struct device *dev,
 static ssize_t store_sustain(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct pk_device *pk = hid_get_drvdata(hdev);
 
 	unsigned sustain = 0;
@@ -179,7 +179,7 @@ static struct device_attribute *sysfs_device_attr_sustain = {
 static ssize_t show_octave(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct pk_device *pk = hid_get_drvdata(hdev);
 
 	dbg_hid("pcmidi sysfs read octave=%d\n", pk->pm->midi_octave);
@@ -192,7 +192,7 @@ static ssize_t show_octave(struct device *dev,
 static ssize_t store_octave(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
-	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct hid_device *hdev = to_hid_device(dev);
 	struct pk_device *pk = hid_get_drvdata(hdev);
 
 	int octave = 0;
* Unmerged path drivers/hid/hid-sony.c
diff --git a/drivers/hid/hid-steelseries.c b/drivers/hid/hid-steelseries.c
index 3edd4ac36494..ec18768b124a 100644
--- a/drivers/hid/hid-steelseries.c
+++ b/drivers/hid/hid-steelseries.c
@@ -141,7 +141,7 @@ static void steelseries_srws1_led_all_set_brightness(struct led_classdev *led_cd
 			enum led_brightness value)
 {
 	struct device *dev = led_cdev->dev->parent;
-	struct hid_device *hid = container_of(dev, struct hid_device, dev);
+	struct hid_device *hid = to_hid_device(dev);
 	struct steelseries_srws1_data *drv_data = hid_get_drvdata(hid);
 
 	if (!drv_data) {
@@ -160,7 +160,7 @@ static void steelseries_srws1_led_all_set_brightness(struct led_classdev *led_cd
 static enum led_brightness steelseries_srws1_led_all_get_brightness(struct led_classdev *led_cdev)
 {
 	struct device *dev = led_cdev->dev->parent;
-	struct hid_device *hid = container_of(dev, struct hid_device, dev);
+	struct hid_device *hid = to_hid_device(dev);
 	struct steelseries_srws1_data *drv_data;
 
 	drv_data = hid_get_drvdata(hid);
@@ -177,7 +177,7 @@ static void steelseries_srws1_led_set_brightness(struct led_classdev *led_cdev,
 			enum led_brightness value)
 {
 	struct device *dev = led_cdev->dev->parent;
-	struct hid_device *hid = container_of(dev, struct hid_device, dev);
+	struct hid_device *hid = to_hid_device(dev);
 	struct steelseries_srws1_data *drv_data = hid_get_drvdata(hid);
 	int i, state = 0;
 
@@ -205,7 +205,7 @@ static void steelseries_srws1_led_set_brightness(struct led_classdev *led_cdev,
 static enum led_brightness steelseries_srws1_led_get_brightness(struct led_classdev *led_cdev)
 {
 	struct device *dev = led_cdev->dev->parent;
-	struct hid_device *hid = container_of(dev, struct hid_device, dev);
+	struct hid_device *hid = to_hid_device(dev);
 	struct steelseries_srws1_data *drv_data;
 	int i, value = 0;
 
diff --git a/drivers/hid/hid-wiimote.h b/drivers/hid/hid-wiimote.h
index c81dbeb086c5..0ebe7e45b305 100644
--- a/drivers/hid/hid-wiimote.h
+++ b/drivers/hid/hid-wiimote.h
@@ -113,8 +113,7 @@ enum wiiproto_reqs {
 	WIIPROTO_REQ_MAX
 };
 
-#define dev_to_wii(pdev) hid_get_drvdata(container_of(pdev, struct hid_device, \
-									dev))
+#define dev_to_wii(pdev) hid_get_drvdata(to_hid_device(pdev))
 
 extern void wiiproto_req_drm(struct wiimote_data *wdata, __u8 drm);
 extern int wiimote_cmd_write(struct wiimote_data *wdata, __u32 offset,
* Unmerged path drivers/hid/wacom_sys.c
