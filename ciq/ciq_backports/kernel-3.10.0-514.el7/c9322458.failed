netfilter: bridge: avoid unused label warning

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Arnd Bergmann <arnd@arndb.de>
commit c9322458119ecf2e5cf41dcb204aaf67238b2147
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c9322458.failed

With the ARM mini2440_defconfig, the bridge netfilter code gets
built with both CONFIG_NF_DEFRAG_IPV4 and CONFIG_NF_DEFRAG_IPV6
disabled, which leads to a harmless gcc warning:

net/bridge/br_netfilter_hooks.c: In function 'br_nf_dev_queue_xmit':
net/bridge/br_netfilter_hooks.c:792:2: warning: label 'drop' defined but not used [-Wunused-label]

This gets rid of the warning by cleaning up the code to avoid
the respective #ifdefs causing this problem, and replacing them
with if(IS_ENABLED()) checks. I have verified that the resulting
object code is unchanged, and an additional advantage is that
we now get compile coverage of the unused functions in more
configurations.

	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
Fixes: dd302b59bde0 ("netfilter: bridge: don't leak skb in error paths")
	Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit c9322458119ecf2e5cf41dcb204aaf67238b2147)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_netfilter.c
diff --cc net/bridge/br_netfilter.c
index 9c51a9410f9c,18905d4781db..000000000000
--- a/net/bridge/br_netfilter.c
+++ b/net/bridge/br_netfilter.c
@@@ -110,72 -108,25 +110,84 @@@ static inline __be16 pppoe_proto(const 
  	 pppoe_proto(skb) == htons(PPP_IPV6) && \
  	 brnf_filter_pppoe_tagged)
  
 -/* largest possible L2 header, see br_nf_dev_queue_xmit() */
 -#define NF_BRIDGE_MAX_MAC_HEADER_LENGTH (PPPOE_SES_HLEN + ETH_HLEN)
 +static void fake_update_pmtu(struct dst_entry *dst, struct sock *sk,
 +			     struct sk_buff *skb, u32 mtu)
 +{
 +}
 +
++<<<<<<< HEAD:net/bridge/br_netfilter.c
 +static void fake_redirect(struct dst_entry *dst, struct sock *sk,
 +			  struct sk_buff *skb)
 +{
 +}
 +
 +static u32 *fake_cow_metrics(struct dst_entry *dst, unsigned long old)
 +{
 +	return NULL;
 +}
 +
 +static struct neighbour *fake_neigh_lookup(const struct dst_entry *dst,
 +					   struct sk_buff *skb,
 +					   const void *daddr)
 +{
 +	return NULL;
 +}
 +
 +static unsigned int fake_mtu(const struct dst_entry *dst)
 +{
 +	return dst->dev->mtu;
 +}
 +
 +static struct dst_ops fake_dst_ops = {
 +	.family =		AF_INET,
 +	.protocol =		cpu_to_be16(ETH_P_IP),
 +	.update_pmtu =		fake_update_pmtu,
 +	.redirect =		fake_redirect,
 +	.cow_metrics =		fake_cow_metrics,
 +	.neigh_lookup =		fake_neigh_lookup,
 +	.mtu =			fake_mtu,
 +};
  
 +/*
 + * Initialize bogus route table used to keep netfilter happy.
 + * Currently, we fill in the PMTU entry because netfilter
 + * refragmentation needs it, and the rt_flags entry because
 + * ipt_REJECT needs it.  Future netfilter modules might
 + * require us to fill additional fields.
 + */
 +static const u32 br_dst_default_metrics[RTAX_MAX] = {
 +	[RTAX_MTU - 1] = 1500,
 +};
++=======
+ struct brnf_frag_data {
+ 	char mac[NF_BRIDGE_MAX_MAC_HEADER_LENGTH];
+ 	u8 encap_size;
+ 	u8 size;
+ 	u16 vlan_tci;
+ 	__be16 vlan_proto;
+ };
+ 
+ static DEFINE_PER_CPU(struct brnf_frag_data, brnf_frag_data_storage);
++>>>>>>> c9322458119e (netfilter: bridge: avoid unused label warning):net/bridge/br_netfilter_hooks.c
  
 -static void nf_bridge_info_free(struct sk_buff *skb)
 +void br_netfilter_rtable_init(struct net_bridge *br)
  {
 -	if (skb->nf_bridge) {
 -		nf_bridge_put(skb->nf_bridge);
 -		skb->nf_bridge = NULL;
 -	}
 +	struct rtable *rt = &br->fake_rtable;
 +
 +	atomic_set(&rt->dst.__refcnt, 1);
 +	rt->dst.dev = br->dev;
 +	rt->dst.path = &rt->dst;
 +	dst_init_metrics(&rt->dst, br_dst_default_metrics, true);
 +	rt->dst.flags	= DST_NOXFRM | DST_NOPEER | DST_FAKE_RTABLE;
 +	rt->dst.ops = &fake_dst_ops;
 +}
 +
 +static inline struct rtable *bridge_parent_rtable(const struct net_device *dev)
 +{
 +	struct net_bridge_port *port;
 +
 +	port = br_port_get_rcu(dev);
 +	return port ? &port->br->fake_rtable : NULL;
  }
  
  static inline struct net_device *bridge_parent(const struct net_device *dev)
@@@ -848,38 -664,139 +860,141 @@@ static unsigned int br_nf_forward_arp(c
  	return NF_STOLEN;
  }
  
++<<<<<<< HEAD:net/bridge/br_netfilter.c
 +#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV4)
 +static int br_nf_dev_queue_xmit(struct sock *sk, struct sk_buff *skb)
++=======
+ static int br_nf_push_frag_xmit(struct net *net, struct sock *sk, struct sk_buff *skb)
++>>>>>>> c9322458119e (netfilter: bridge: avoid unused label warning):net/bridge/br_netfilter_hooks.c
  {
 -	struct brnf_frag_data *data;
 -	int err;
 -
 -	data = this_cpu_ptr(&brnf_frag_data_storage);
 -	err = skb_cow_head(skb, data->size);
 -
 -	if (err) {
 -		kfree_skb(skb);
 -		return 0;
 -	}
 -
 -	if (data->vlan_tci) {
 -		skb->vlan_tci = data->vlan_tci;
 -		skb->vlan_proto = data->vlan_proto;
 -	}
 +	int ret;
  
 -	skb_copy_to_linear_data_offset(skb, -data->size, data->mac, data->size);
 -	__skb_push(skb, data->encap_size);
 +	if (skb->nfct != NULL && skb->protocol == htons(ETH_P_IP) &&
 +	    skb->len + nf_bridge_mtu_reduction(skb) > skb->dev->mtu &&
 +	    !skb_is_gso(skb)) {
 +		if (br_parse_ip_options(skb))
 +			/* Drop invalid packet */
 +			return NF_DROP;
 +		ret = ip_fragment(sk, skb, br_dev_queue_push_xmit);
 +	} else
 +		ret = br_dev_queue_push_xmit(sk, skb);
  
 -	nf_bridge_info_free(skb);
 -	return br_dev_queue_push_xmit(net, sk, skb);
 +	return ret;
  }
 -static int br_nf_push_frag_xmit_sk(struct sock *sk, struct sk_buff *skb)
 +#else
 +static int br_nf_dev_queue_xmit(struct sock *sk, struct sk_buff *skb)
  {
 -	struct net *net = dev_net(skb_dst(skb)->dev);
 -	return br_nf_push_frag_xmit(net, sk, skb);
 +        return br_dev_queue_push_xmit(sk, skb);
  }
- #endif
  
++<<<<<<< HEAD:net/bridge/br_netfilter.c
++=======
+ static int
+ br_nf_ip_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,
+ 		  int (*output)(struct sock *, struct sk_buff *))
+ {
+ 	unsigned int mtu = ip_skb_dst_mtu(skb);
+ 	struct iphdr *iph = ip_hdr(skb);
+ 
+ 	if (unlikely(((iph->frag_off & htons(IP_DF)) && !skb->ignore_df) ||
+ 		     (IPCB(skb)->frag_max_size &&
+ 		      IPCB(skb)->frag_max_size > mtu))) {
+ 		IP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS);
+ 		kfree_skb(skb);
+ 		return -EMSGSIZE;
+ 	}
+ 
+ 	return ip_do_fragment(sk, skb, output);
+ }
+ 
+ static unsigned int nf_bridge_mtu_reduction(const struct sk_buff *skb)
+ {
+ 	if (skb->nf_bridge->orig_proto == BRNF_PROTO_PPPOE)
+ 		return PPPOE_SES_HLEN;
+ 	return 0;
+ }
+ 
+ static int br_nf_dev_queue_xmit(struct net *net, struct sock *sk, struct sk_buff *skb)
+ {
+ 	struct nf_bridge_info *nf_bridge;
+ 	unsigned int mtu_reserved;
+ 
+ 	mtu_reserved = nf_bridge_mtu_reduction(skb);
+ 
+ 	if (skb_is_gso(skb) || skb->len + mtu_reserved <= skb->dev->mtu) {
+ 		nf_bridge_info_free(skb);
+ 		return br_dev_queue_push_xmit(net, sk, skb);
+ 	}
+ 
+ 	nf_bridge = nf_bridge_info_get(skb);
+ 
+ 	/* This is wrong! We should preserve the original fragment
+ 	 * boundaries by preserving frag_list rather than refragmenting.
+ 	 */
+ 	if (IS_ENABLED(CONFIG_NF_DEFRAG_IPV4) &&
+ 	    skb->protocol == htons(ETH_P_IP)) {
+ 		struct brnf_frag_data *data;
+ 
+ 		if (br_validate_ipv4(net, skb))
+ 			goto drop;
+ 
+ 		IPCB(skb)->frag_max_size = nf_bridge->frag_max_size;
+ 
+ 		nf_bridge_update_protocol(skb);
+ 
+ 		data = this_cpu_ptr(&brnf_frag_data_storage);
+ 
+ 		data->vlan_tci = skb->vlan_tci;
+ 		data->vlan_proto = skb->vlan_proto;
+ 		data->encap_size = nf_bridge_encap_header_len(skb);
+ 		data->size = ETH_HLEN + data->encap_size;
+ 
+ 		skb_copy_from_linear_data_offset(skb, -data->size, data->mac,
+ 						 data->size);
+ 
+ 		return br_nf_ip_fragment(net, sk, skb, br_nf_push_frag_xmit_sk);
+ 	}
+ 	if (IS_ENABLED(CONFIG_NF_DEFRAG_IPV6) &&
+ 	    skb->protocol == htons(ETH_P_IPV6)) {
+ 		const struct nf_ipv6_ops *v6ops = nf_get_ipv6_ops();
+ 		struct brnf_frag_data *data;
+ 
+ 		if (br_validate_ipv6(net, skb))
+ 			goto drop;
+ 
+ 		IP6CB(skb)->frag_max_size = nf_bridge->frag_max_size;
+ 
+ 		nf_bridge_update_protocol(skb);
+ 
+ 		data = this_cpu_ptr(&brnf_frag_data_storage);
+ 		data->encap_size = nf_bridge_encap_header_len(skb);
+ 		data->size = ETH_HLEN + data->encap_size;
+ 
+ 		skb_copy_from_linear_data_offset(skb, -data->size, data->mac,
+ 						 data->size);
+ 
+ 		if (v6ops)
+ 			return v6ops->fragment(sk, skb, br_nf_push_frag_xmit_sk);
+ 
+ 		kfree_skb(skb);
+ 		return -EMSGSIZE;
+ 	}
+ 	nf_bridge_info_free(skb);
+ 	return br_dev_queue_push_xmit(net, sk, skb);
+  drop:
+ 	kfree_skb(skb);
+ 	return 0;
+ }
+ 
++>>>>>>> c9322458119e (netfilter: bridge: avoid unused label warning):net/bridge/br_netfilter_hooks.c
  /* PF_BRIDGE/POST_ROUTING ********************************************/
 -static unsigned int br_nf_post_routing(void *priv,
 +static unsigned int br_nf_post_routing(const struct nf_hook_ops *ops,
  				       struct sk_buff *skb,
 +				       const struct net_device *in,
 +				       const struct net_device *out,
  				       const struct nf_hook_state *state)
  {
 -	struct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);
 +	struct nf_bridge_info *nf_bridge = skb->nf_bridge;
  	struct net_device *realoutdev = bridge_parent(skb->dev);
  	u_int8_t pf;
  
* Unmerged path net/bridge/br_netfilter.c
