vfs: document ->d_real()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit e698b8a43659f9ece192fcab215abcadac8f88d7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e698b8a4.failed

Add missing documentation for the d_op->d_real() method and d_real()
helper.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit e698b8a43659f9ece192fcab215abcadac8f88d7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/dcache.h
diff --cc include/linux/dcache.h
index 5888528c0fa0,14df83609c7f..000000000000
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@@ -158,6 -139,8 +158,11 @@@ struct dentry_operations 
  	char *(*d_dname)(struct dentry *, char *, int);
  	struct vfsmount *(*d_automount)(struct path *);
  	int (*d_manage)(struct dentry *, bool);
++<<<<<<< HEAD
++=======
+ 	struct dentry *(*d_real)(struct dentry *, const struct inode *,
+ 				 unsigned int);
++>>>>>>> e698b8a43659 (vfs: document ->d_real())
  } ____cacheline_aligned;
  
  /*
@@@ -459,6 -441,152 +464,104 @@@ static inline bool d_is_positive(const 
  	return !d_is_negative(dentry);
  }
  
 -/**
 - * d_really_is_negative - Determine if a dentry is really negative (ignoring fallthroughs)
 - * @dentry: The dentry in question
 - *
 - * Returns true if the dentry represents either an absent name or a name that
 - * doesn't map to an inode (ie. ->d_inode is NULL).  The dentry could represent
 - * a true miss, a whiteout that isn't represented by a 0,0 chardev or a
 - * fallthrough marker in an opaque directory.
 - *
 - * Note!  (1) This should be used *only* by a filesystem to examine its own
 - * dentries.  It should not be used to look at some other filesystem's
 - * dentries.  (2) It should also be used in combination with d_inode() to get
 - * the inode.  (3) The dentry may have something attached to ->d_lower and the
 - * type field of the flags may be set to something other than miss or whiteout.
 - */
 -static inline bool d_really_is_negative(const struct dentry *dentry)
 -{
 -	return dentry->d_inode == NULL;
 -}
 -
 -/**
 - * d_really_is_positive - Determine if a dentry is really positive (ignoring fallthroughs)
 - * @dentry: The dentry in question
 - *
 - * Returns true if the dentry represents a name that maps to an inode
 - * (ie. ->d_inode is not NULL).  The dentry might still represent a whiteout if
 - * that is represented on medium as a 0,0 chardev.
 - *
 - * Note!  (1) This should be used *only* by a filesystem to examine its own
 - * dentries.  It should not be used to look at some other filesystem's
 - * dentries.  (2) It should also be used in combination with d_inode() to get
 - * the inode.
 - */
 -static inline bool d_really_is_positive(const struct dentry *dentry)
 -{
 -	return dentry->d_inode != NULL;
 -}
 -
 -static inline int simple_positive(struct dentry *dentry)
 -{
 -	return d_really_is_positive(dentry) && !d_unhashed(dentry);
 -}
 -
 -extern void d_set_fallthru(struct dentry *dentry);
 -
 -static inline bool d_is_fallthru(const struct dentry *dentry)
 -{
 -	return dentry->d_flags & DCACHE_FALLTHRU;
 -}
 -
 -
  extern int sysctl_vfs_cache_pressure;
  
++<<<<<<< HEAD
++=======
+ static inline unsigned long vfs_pressure_ratio(unsigned long val)
+ {
+ 	return mult_frac(val, sysctl_vfs_cache_pressure, 100);
+ }
+ 
+ /**
+  * d_inode - Get the actual inode of this dentry
+  * @dentry: The dentry to query
+  *
+  * This is the helper normal filesystems should use to get at their own inodes
+  * in their own dentries and ignore the layering superimposed upon them.
+  */
+ static inline struct inode *d_inode(const struct dentry *dentry)
+ {
+ 	return dentry->d_inode;
+ }
+ 
+ /**
+  * d_inode_rcu - Get the actual inode of this dentry with ACCESS_ONCE()
+  * @dentry: The dentry to query
+  *
+  * This is the helper normal filesystems should use to get at their own inodes
+  * in their own dentries and ignore the layering superimposed upon them.
+  */
+ static inline struct inode *d_inode_rcu(const struct dentry *dentry)
+ {
+ 	return ACCESS_ONCE(dentry->d_inode);
+ }
+ 
+ /**
+  * d_backing_inode - Get upper or lower inode we should be using
+  * @upper: The upper layer
+  *
+  * This is the helper that should be used to get at the inode that will be used
+  * if this dentry were to be opened as a file.  The inode may be on the upper
+  * dentry or it may be on a lower dentry pinned by the upper.
+  *
+  * Normal filesystems should not use this to access their own inodes.
+  */
+ static inline struct inode *d_backing_inode(const struct dentry *upper)
+ {
+ 	struct inode *inode = upper->d_inode;
+ 
+ 	return inode;
+ }
+ 
+ /**
+  * d_backing_dentry - Get upper or lower dentry we should be using
+  * @upper: The upper layer
+  *
+  * This is the helper that should be used to get the dentry of the inode that
+  * will be used if this dentry were opened as a file.  It may be the upper
+  * dentry or it may be a lower dentry pinned by the upper.
+  *
+  * Normal filesystems should not use this to access their own dentries.
+  */
+ static inline struct dentry *d_backing_dentry(struct dentry *upper)
+ {
+ 	return upper;
+ }
+ 
+ /**
+  * d_real - Return the real dentry
+  * @dentry: the dentry to query
+  * @inode: inode to select the dentry from multiple layers (can be NULL)
+  * @flags: open flags to control copy-up behavior
+  *
+  * If dentry is on an union/overlay, then return the underlying, real dentry.
+  * Otherwise return the dentry itself.
+  *
+  * See also: Documentation/filesystems/vfs.txt
+  */
+ static inline struct dentry *d_real(struct dentry *dentry,
+ 				    const struct inode *inode,
+ 				    unsigned int flags)
+ {
+ 	if (unlikely(dentry->d_flags & DCACHE_OP_REAL))
+ 		return dentry->d_op->d_real(dentry, inode, flags);
+ 	else
+ 		return dentry;
+ }
+ 
+ /**
+  * d_real_inode - Return the real inode
+  * @dentry: The dentry to query
+  *
+  * If dentry is on an union/overlay, then return the underlying, real inode.
+  * Otherwise return d_inode().
+  */
+ static inline struct inode *d_real_inode(struct dentry *dentry)
+ {
+ 	return d_backing_inode(d_real(dentry, NULL, 0));
+ }
+ 
+ 
++>>>>>>> e698b8a43659 (vfs: document ->d_real())
  #endif	/* __LINUX_DCACHE_H */
diff --git a/Documentation/filesystems/Locking b/Documentation/filesystems/Locking
index af63b7f9e0d8..6d4eae30118f 100644
--- a/Documentation/filesystems/Locking
+++ b/Documentation/filesystems/Locking
@@ -20,6 +20,8 @@ prototypes:
 	char *(*d_dname)((struct dentry *dentry, char *buffer, int buflen);
 	struct vfsmount *(*d_automount)(struct path *path);
 	int (*d_manage)(struct dentry *, bool);
+	struct dentry *(*d_real)(struct dentry *, const struct inode *,
+				 unsigned int);
 
 locking rules:
 		rename_lock	->d_lock	may block	rcu-walk
@@ -34,6 +36,7 @@ d_iput:		no		no		yes		no
 d_dname:	no		no		no		no
 d_automount:	no		no		yes		no
 d_manage:	no		no		yes (ref-walk)	maybe
+d_real		no		no		yes 		no
 
 --------------------------- inode_operations --------------------------- 
 prototypes:
diff --git a/Documentation/filesystems/vfs.txt b/Documentation/filesystems/vfs.txt
index 49cef1203c04..7f8c48fb27b5 100644
--- a/Documentation/filesystems/vfs.txt
+++ b/Documentation/filesystems/vfs.txt
@@ -934,6 +934,8 @@ struct dentry_operations {
 	char *(*d_dname)(struct dentry *, char *, int);
 	struct vfsmount *(*d_automount)(struct path *);
 	int (*d_manage)(struct dentry *, bool);
+	struct dentry *(*d_real)(struct dentry *, const struct inode *,
+				 unsigned int);
 };
 
   d_revalidate: called when the VFS needs to revalidate a dentry. This
@@ -1055,6 +1057,24 @@ struct dentry_operations {
 	This function is only used if DCACHE_MANAGE_TRANSIT is set on the
 	dentry being transited from.
 
+  d_real: overlay/union type filesystems implement this method to return one of
+	the underlying dentries hidden by the overlay.  It is used in three
+	different modes:
+
+	Called from open it may need to copy-up the file depending on the
+	supplied open flags.  This mode is selected with a non-zero flags
+	argument.  In this mode the d_real method can return an error.
+
+	Called from file_dentry() it returns the real dentry matching the inode
+	argument.  The real dentry may be from a lower layer already copied up,
+	but still referenced from the file.  This mode is selected with a
+	non-NULL inode argument.  This will always succeed.
+
+	With NULL inode and zero flags the topmost real underlying dentry is
+	returned.  This will always succeed.
+
+	This method is never called with both non-NULL inode and non-zero flags.
+
 Example :
 
 static char *pipefs_dname(struct dentry *dent, char *buffer, int buflen)
* Unmerged path include/linux/dcache.h
