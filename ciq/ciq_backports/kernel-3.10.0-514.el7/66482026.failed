dm: do not return target from dm_get_live_table_for_ioctl()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mike Snitzer <snitzer@redhat.com>
commit 664820265d70a759dceca87b6eb200cd2b93cda8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/66482026.failed

None of the callers actually used the returned target.
Also, just reuse bdev pointer passed to dm_blk_ioctl().

	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 664820265d70a759dceca87b6eb200cd2b93cda8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index 66c19dce3920,e9e74e6274d4..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -557,18 -556,17 +557,26 @@@ static int dm_blk_getgeo(struct block_d
  	return dm_get_geometry(md, geo);
  }
  
++<<<<<<< HEAD
 +static int dm_blk_ioctl(struct block_device *bdev, fmode_t mode,
 +			unsigned int cmd, unsigned long arg)
 +{
 +	struct mapped_device *md = bdev->bd_disk->private_data;
 +	int srcu_idx;
++=======
+ static int dm_get_live_table_for_ioctl(struct mapped_device *md,
+ 				       struct block_device **bdev,
+ 				       fmode_t *mode, int *srcu_idx)
+ {
+ 	struct dm_target *tgt;
++>>>>>>> 664820265d70 (dm: do not return target from dm_get_live_table_for_ioctl())
  	struct dm_table *map;
 -	int r;
 +	struct dm_target *tgt;
 +	int r = -ENOTTY;
  
  retry:
 -	r = -ENOTTY;
 -	map = dm_get_live_table(md, srcu_idx);
 +	map = dm_get_live_table(md, &srcu_idx);
 +
  	if (!map || !dm_table_get_size(map))
  		goto out;
  
@@@ -577,7 -575,7 +585,11 @@@
  		goto out;
  
  	tgt = dm_table_get_target(map, 0);
++<<<<<<< HEAD
 +	if (!tgt->type->ioctl)
++=======
+ 	if (!tgt->type->prepare_ioctl)
++>>>>>>> 664820265d70 (dm: do not return target from dm_get_live_table_for_ioctl())
  		goto out;
  
  	if (dm_suspended_md(md)) {
@@@ -585,16 -583,45 +597,51 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	r = tgt->type->ioctl(tgt, cmd, arg);
++=======
+ 	r = tgt->type->prepare_ioctl(tgt, bdev, mode);
+ 	if (r < 0)
+ 		goto out;
+ 
+ 	return r;
++>>>>>>> 664820265d70 (dm: do not return target from dm_get_live_table_for_ioctl())
  
  out:
 -	dm_put_live_table(md, *srcu_idx);
 -	if (r == -ENOTCONN && !fatal_signal_pending(current)) {
 +	dm_put_live_table(md, srcu_idx);
 +
 +	if (r == -ENOTCONN) {
  		msleep(10);
  		goto retry;
  	}
 -	return r;
 -}
  
++<<<<<<< HEAD
++=======
+ static int dm_blk_ioctl(struct block_device *bdev, fmode_t mode,
+ 			unsigned int cmd, unsigned long arg)
+ {
+ 	struct mapped_device *md = bdev->bd_disk->private_data;
+ 	int srcu_idx, r;
+ 
+ 	r = dm_get_live_table_for_ioctl(md, &bdev, &mode, &srcu_idx);
+ 	if (r < 0)
+ 		return r;
+ 
+ 	if (r > 0) {
+ 		/*
+ 		 * Target determined this ioctl is being issued against
+ 		 * a logical partition of the parent bdev; so extra
+ 		 * validation is needed.
+ 		 */
+ 		r = scsi_verify_blk_ioctl(NULL, cmd);
+ 		if (r)
+ 			goto out;
+ 	}
+ 
+ 	r =  __blkdev_driver_ioctl(bdev, mode, cmd, arg);
+ out:
+ 	dm_put_live_table(md, srcu_idx);
++>>>>>>> 664820265d70 (dm: do not return target from dm_get_live_table_for_ioctl())
  	return r;
  }
  
* Unmerged path drivers/md/dm.c
