tcp: add tcpi_segs_in and tcpi_segs_out to tcp_info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Marcelo Ricardo Leitner <mleitner@redhat.com>
commit 2efd055c53c06b7e89c167c98069bab9afce7e59
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2efd055c.failed

This patch tracks the total number of inbound and outbound segments on a
TCP socket. One may use this number to have an idea on connection
quality when compared against the retransmissions.

RFC4898 named these : tcpEStatsPerfSegsIn and tcpEStatsPerfSegsOut

These are a 32bit field each and can be fetched both from TCP_INFO
getsockopt() if one has a handle on a TCP socket, or from inet_diag
netlink facility (iproute2/ss patch will follow)

Note that tp->segs_out was placed near tp->snd_nxt for good data
locality and minimal performance impact, while tp->segs_in was placed
near tp->bytes_received for the same reason.

Join work with Eric Dumazet.

Note that received SYN are accounted on the listener, but sent SYNACK
are not accounted.

	Signed-off-by: Marcelo Ricardo Leitner <mleitner@redhat.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2efd055c53c06b7e89c167c98069bab9afce7e59)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/tcp.h
#	include/uapi/linux/tcp.h
#	net/ipv4/tcp.c
#	net/ipv4/tcp_output.c
diff --cc include/linux/tcp.h
index 1c6e31feb254,f0212026c77f..000000000000
--- a/include/linux/tcp.h
+++ b/include/linux/tcp.h
@@@ -147,6 -145,13 +147,16 @@@ struct tcp_sock 
   *	read the code and the spec side by side (and laugh ...)
   *	See RFC793 and RFC1122. The RFC writes these in capitals.
   */
++<<<<<<< HEAD
++=======
+ 	u64	bytes_received;	/* RFC4898 tcpEStatsAppHCThruOctetsReceived
+ 				 * sum(delta(rcv_nxt)), or how many bytes
+ 				 * were acked.
+ 				 */
+ 	u32	segs_in;	/* RFC4898 tcpEStatsPerfSegsIn
+ 				 * total number of segments in.
+ 				 */
++>>>>>>> 2efd055c53c0 (tcp: add tcpi_segs_in and tcpi_segs_out to tcp_info)
   	u32	rcv_nxt;	/* What we want to receive next 	*/
  	u32	copied_seq;	/* Head of yet unread data		*/
  	u32	rcv_wup;	/* rcv_nxt on last window update sent	*/
diff --cc include/uapi/linux/tcp.h
index 6666e98a0af9,65a77b071e22..000000000000
--- a/include/uapi/linux/tcp.h
+++ b/include/uapi/linux/tcp.h
@@@ -189,7 -192,10 +189,14 @@@ struct tcp_info 
  
  	__u64	tcpi_pacing_rate;
  	__u64	tcpi_max_pacing_rate;
++<<<<<<< HEAD
 +	__u64	tcpi_bytes_acked; /* RFC4898 tcpEStatsAppHCThruOctetsAcked */
++=======
+ 	__u64	tcpi_bytes_acked;    /* RFC4898 tcpEStatsAppHCThruOctetsAcked */
+ 	__u64	tcpi_bytes_received; /* RFC4898 tcpEStatsAppHCThruOctetsReceived */
+ 	__u32	tcpi_segs_out;	     /* RFC4898 tcpEStatsPerfSegsOut */
+ 	__u32	tcpi_segs_in;	     /* RFC4898 tcpEStatsPerfSegsIn */
++>>>>>>> 2efd055c53c0 (tcp: add tcpi_segs_in and tcpi_segs_out to tcp_info)
  };
  
  /* for TCP_MD5SIG socket option */
diff --cc net/ipv4/tcp.c
index d8ad7f7bb200,7f3e721b9e69..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -2688,6 -2694,9 +2688,12 @@@ void tcp_get_info(struct sock *sk, stru
  
  	spin_lock_bh(&sk->sk_lock.slock);
  	info->tcpi_bytes_acked = tp->bytes_acked;
++<<<<<<< HEAD
++=======
+ 	info->tcpi_bytes_received = tp->bytes_received;
+ 	info->tcpi_segs_out = tp->segs_out;
+ 	info->tcpi_segs_in = tp->segs_in;
++>>>>>>> 2efd055c53c0 (tcp: add tcpi_segs_in and tcpi_segs_out to tcp_info)
  	spin_unlock_bh(&sk->sk_lock.slock);
  }
  EXPORT_SYMBOL_GPL(tcp_get_info);
diff --cc net/ipv4/tcp_output.c
index ddd2a6fe0e83,534e5fdb04c1..000000000000
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@@ -1006,9 -1027,18 +1006,16 @@@ static int tcp_transmit_skb(struct soc
  		TCP_ADD_STATS(sock_net(sk), TCP_MIB_OUTSEGS,
  			      tcp_skb_pcount(skb));
  
++<<<<<<< HEAD
++=======
+ 	tp->segs_out += tcp_skb_pcount(skb);
+ 	/* OK, its time to fill skb_shinfo(skb)->gso_segs */
+ 	skb_shinfo(skb)->gso_segs = tcp_skb_pcount(skb);
+ 
++>>>>>>> 2efd055c53c0 (tcp: add tcpi_segs_in and tcpi_segs_out to tcp_info)
  	/* Our usage of tstamp should remain private */
  	skb->tstamp.tv64 = 0;
 -
 -	/* Cleanup our debris for IP stacks */
 -	memset(skb->cb, 0, max(sizeof(struct inet_skb_parm),
 -			       sizeof(struct inet6_skb_parm)));
 -
 -	err = icsk->icsk_af_ops->queue_xmit(sk, skb, &inet->cork.fl);
 +	err = icsk->icsk_af_ops->queue_xmit(skb, &inet->cork.fl);
  
  	if (likely(err <= 0))
  		return err;
* Unmerged path include/linux/tcp.h
* Unmerged path include/uapi/linux/tcp.h
* Unmerged path net/ipv4/tcp.c
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index 2ea261af04d9..971029ea85c1 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -1692,6 +1692,7 @@ process:
 	skb->dev = NULL;
 
 	bh_lock_sock_nested(sk);
+	tcp_sk(sk)->segs_in += max_t(u16, 1, skb_shinfo(skb)->gso_segs);
 	ret = 0;
 	if (!sock_owned_by_user(sk)) {
 		if (!tcp_prequeue(sk, skb))
diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
index 5129a4495bc8..3fb7222d3235 100644
--- a/net/ipv4/tcp_minisocks.c
+++ b/net/ipv4/tcp_minisocks.c
@@ -468,6 +468,7 @@ struct sock *tcp_create_openreq_child(struct sock *sk, struct request_sock *req,
 
 		newtp->rcv_wup = newtp->copied_seq =
 		newtp->rcv_nxt = treq->rcv_isn + 1;
+		newtp->segs_in = 0;
 
 		newtp->snd_sml = newtp->snd_una =
 		newtp->snd_nxt = newtp->snd_up = treq->snt_isn + 1;
* Unmerged path net/ipv4/tcp_output.c
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index 2ab7bcc949ac..efebafa78919 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -1441,6 +1441,7 @@ process:
 	skb->dev = NULL;
 
 	bh_lock_sock_nested(sk);
+	tcp_sk(sk)->segs_in += max_t(u16, 1, skb_shinfo(skb)->gso_segs);
 	ret = 0;
 	if (!sock_owned_by_user(sk)) {
 		if (!tcp_prequeue(sk, skb))
