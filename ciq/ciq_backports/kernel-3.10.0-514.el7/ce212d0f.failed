vxlan: interpret IP headers for ECN correctly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit ce212d0f6f5523ca9eb8020267f1aa4eb6869ba8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ce212d0f.failed

When looking for outer IP header, use the actual socket address family, not
the address family of the default destination which is not set for metadata
based interfaces (and doesn't have to match the address family of the
received packet even if it was set).

Fix also the misleading comment.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ce212d0f6f5523ca9eb8020267f1aa4eb6869ba8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 4e5b7ab9acd0,ba363cedef80..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1154,6 -1148,100 +1154,103 @@@ static struct vxlanhdr *vxlan_remcsum(s
  	return vh;
  }
  
++<<<<<<< HEAD
++=======
+ static void vxlan_rcv(struct vxlan_sock *vs, struct sk_buff *skb,
+ 		      struct vxlan_metadata *md, u32 vni,
+ 		      struct metadata_dst *tun_dst)
+ {
+ 	struct iphdr *oip = NULL;
+ 	struct ipv6hdr *oip6 = NULL;
+ 	struct vxlan_dev *vxlan;
+ 	struct pcpu_sw_netstats *stats;
+ 	union vxlan_addr saddr;
+ 	int err = 0;
+ 
+ 	/* For flow based devices, map all packets to VNI 0 */
+ 	if (vs->flags & VXLAN_F_COLLECT_METADATA)
+ 		vni = 0;
+ 
+ 	/* Is this VNI defined? */
+ 	vxlan = vxlan_vs_find_vni(vs, vni);
+ 	if (!vxlan)
+ 		goto drop;
+ 
+ 	skb_reset_mac_header(skb);
+ 	skb_scrub_packet(skb, !net_eq(vxlan->net, dev_net(vxlan->dev)));
+ 	skb->protocol = eth_type_trans(skb, vxlan->dev);
+ 	skb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);
+ 
+ 	/* Ignore packet loops (and multicast echo) */
+ 	if (ether_addr_equal(eth_hdr(skb)->h_source, vxlan->dev->dev_addr))
+ 		goto drop;
+ 
+ 	/* Get data from the outer IP header */
+ 	if (vxlan_get_sk_family(vs) == AF_INET) {
+ 		oip = ip_hdr(skb);
+ 		saddr.sin.sin_addr.s_addr = oip->saddr;
+ 		saddr.sa.sa_family = AF_INET;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	} else {
+ 		oip6 = ipv6_hdr(skb);
+ 		saddr.sin6.sin6_addr = oip6->saddr;
+ 		saddr.sa.sa_family = AF_INET6;
+ #endif
+ 	}
+ 
+ 	if (tun_dst) {
+ 		skb_dst_set(skb, (struct dst_entry *)tun_dst);
+ 		tun_dst = NULL;
+ 	}
+ 
+ 	if ((vxlan->flags & VXLAN_F_LEARN) &&
+ 	    vxlan_snoop(skb->dev, &saddr, eth_hdr(skb)->h_source))
+ 		goto drop;
+ 
+ 	skb_reset_network_header(skb);
+ 	/* In flow-based mode, GBP is carried in dst_metadata */
+ 	if (!(vs->flags & VXLAN_F_COLLECT_METADATA))
+ 		skb->mark = md->gbp;
+ 
+ 	if (oip6)
+ 		err = IP6_ECN_decapsulate(oip6, skb);
+ 	if (oip)
+ 		err = IP_ECN_decapsulate(oip, skb);
+ 
+ 	if (unlikely(err)) {
+ 		if (log_ecn_error) {
+ 			if (oip6)
+ 				net_info_ratelimited("non-ECT from %pI6\n",
+ 						     &oip6->saddr);
+ 			if (oip)
+ 				net_info_ratelimited("non-ECT from %pI4 with TOS=%#x\n",
+ 						     &oip->saddr, oip->tos);
+ 		}
+ 		if (err > 1) {
+ 			++vxlan->dev->stats.rx_frame_errors;
+ 			++vxlan->dev->stats.rx_errors;
+ 			goto drop;
+ 		}
+ 	}
+ 
+ 	stats = this_cpu_ptr(vxlan->dev->tstats);
+ 	u64_stats_update_begin(&stats->syncp);
+ 	stats->rx_packets++;
+ 	stats->rx_bytes += skb->len;
+ 	u64_stats_update_end(&stats->syncp);
+ 
+ 	gro_cells_receive(&vxlan->gro_cells, skb);
+ 
+ 	return;
+ drop:
+ 	if (tun_dst)
+ 		dst_release((struct dst_entry *)tun_dst);
+ 
+ 	/* Consume bad packet */
+ 	kfree_skb(skb);
+ }
+ 
++>>>>>>> ce212d0f6f55 (vxlan: interpret IP headers for ECN correctly)
  /* Callback from net/ipv4/udp.c to receive packets */
  static int vxlan_udp_encap_recv(struct sock *sk, struct sk_buff *skb)
  {
* Unmerged path drivers/net/vxlan.c
