zram: support REQ_DISCARD

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Joonsoo Kim <iamjoonsoo.kim@lge.com>
commit f4659d8e620d08bd1a84a8aec5d2f5294a242764
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f4659d8e.failed

zram is ram based block device and can be used by backend of filesystem.
When filesystem deletes a file, it normally doesn't do anything on data
block of that file.  It just marks on metadata of that file.  This
behavior has no problem on disk based block device, but has problems on
ram based block device, since we can't free memory used for data block.
To overcome this disadvantage, there is REQ_DISCARD functionality.  If
block device support REQ_DISCARD and filesystem is mounted with discard
option, filesystem sends REQ_DISCARD to block device whenever some data
blocks are discarded.  All we have to do is to handle this request.

This patch implements to flag up QUEUE_FLAG_DISCARD and handle this
REQ_DISCARD request.  With it, we can free memory used by zram if it isn't
used.

[akpm@linux-foundation.org: tweak comments]
	Signed-off-by: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Minchan Kim <minchan@kernel.org>
	Cc: Nitin Gupta <ngupta@vflare.org>
	Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
	Cc: Jerome Marchand <jmarchan@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit f4659d8e620d08bd1a84a8aec5d2f5294a242764)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/zram/zram_drv.c
diff --cc drivers/block/zram/zram_drv.c
index b625e985f469,9849b5233bf4..000000000000
--- a/drivers/block/zram/zram_drv.c
+++ b/drivers/block/zram/zram_drv.c
@@@ -670,28 -716,27 +711,38 @@@ out
  	return ret;
  }
  
 -static void __zram_make_request(struct zram *zram, struct bio *bio)
 +static void __zram_make_request(struct zram *zram, struct bio *bio, int rw)
  {
 -	int offset;
 +	int i, offset;
  	u32 index;
 -	struct bio_vec bvec;
 -	struct bvec_iter iter;
 +	struct bio_vec *bvec;
 +
 +	switch (rw) {
 +	case READ:
 +		atomic64_inc(&zram->stats.num_reads);
 +		break;
 +	case WRITE:
 +		atomic64_inc(&zram->stats.num_writes);
 +		break;
 +	}
  
 -	index = bio->bi_iter.bi_sector >> SECTORS_PER_PAGE_SHIFT;
 -	offset = (bio->bi_iter.bi_sector &
 -		  (SECTORS_PER_PAGE - 1)) << SECTOR_SHIFT;
++<<<<<<< HEAD
 +	index = bio->bi_sector >> SECTORS_PER_PAGE_SHIFT;
 +	offset = (bio->bi_sector & (SECTORS_PER_PAGE - 1)) << SECTOR_SHIFT;
  
 +	bio_for_each_segment(bvec, bio, i) {
++=======
+ 	if (unlikely(bio->bi_rw & REQ_DISCARD)) {
+ 		zram_bio_discard(zram, index, offset, bio);
+ 		bio_endio(bio, 0);
+ 		return;
+ 	}
+ 
+ 	bio_for_each_segment(bvec, bio, iter) {
++>>>>>>> f4659d8e620d (zram: support REQ_DISCARD)
  		int max_transfer_size = PAGE_SIZE - offset;
  
 -		if (bvec.bv_len > max_transfer_size) {
 +		if (bvec->bv_len > max_transfer_size) {
  			/*
  			 * zram_bvec_rw() can only make operation on a single
  			 * zram page. Split the bio vector.
* Unmerged path drivers/block/zram/zram_drv.c
