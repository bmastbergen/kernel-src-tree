net: cdc_ncm: use true max dgram count for header estimates

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bjørn Mork <bjorn@mork.no>
commit 70559b8970e52aa9962dc823fd4498af06809544
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/70559b89.failed

Many newer NCM and MBIM devices will request a maximum tx
datagram count which is much smaller than our hard-coded
absolute max. We can reduce the overhead without sacrificing
any of the simplicity for these devices, by simply using the
true negotiated count in when calculated the maximum NTH and
NDP header sizes.

	Signed-off-by: Bjørn Mork <bjorn@mork.no>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 70559b8970e52aa9962dc823fd4498af06809544)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/cdc_ncm.c
#	include/linux/usb/cdc_ncm.h
diff --cc drivers/net/usb/cdc_ncm.c
index 4bae7ffa5334,b9b562b9128a..000000000000
--- a/drivers/net/usb/cdc_ncm.c
+++ b/drivers/net/usb/cdc_ncm.c
@@@ -68,31 -65,201 +68,163 @@@ static void cdc_ncm_tx_timeout_start(st
  static enum hrtimer_restart cdc_ncm_tx_timer_cb(struct hrtimer *hr_timer);
  static struct usb_driver cdc_ncm_driver;
  
 -static int cdc_ncm_get_coalesce(struct net_device *netdev,
 -				struct ethtool_coalesce *ec)
 +static void
 +cdc_ncm_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
  {
 -	struct usbnet *dev = netdev_priv(netdev);
 -	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
 +	struct usbnet *dev = netdev_priv(net);
  
 -	/* assuming maximum sized dgrams and ignoring NDPs */
 -	ec->rx_max_coalesced_frames = ctx->rx_max / ctx->max_datagram_size;
 -	ec->tx_max_coalesced_frames = ctx->tx_max / ctx->max_datagram_size;
 -
 -	/* the timer will fire CDC_NCM_TIMER_PENDING_CNT times in a row */
 -	ec->tx_coalesce_usecs = (ctx->timer_interval * CDC_NCM_TIMER_PENDING_CNT) / NSEC_PER_USEC;
 -	return 0;
 -}
 -
 -static void cdc_ncm_update_rxtx_max(struct usbnet *dev, u32 new_rx, u32 new_tx);
 -
 -static int cdc_ncm_set_coalesce(struct net_device *netdev,
 -				struct ethtool_coalesce *ec)
 -{
 -	struct usbnet *dev = netdev_priv(netdev);
 -	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
 -	u32 new_rx_max = ctx->rx_max;
 -	u32 new_tx_max = ctx->tx_max;
 -
 -	/* assuming maximum sized dgrams and a single NDP */
 -	if (ec->rx_max_coalesced_frames)
 -		new_rx_max = ec->rx_max_coalesced_frames * ctx->max_datagram_size;
 -	if (ec->tx_max_coalesced_frames)
 -		new_tx_max = ec->tx_max_coalesced_frames * ctx->max_datagram_size;
 -
 -	if (ec->tx_coalesce_usecs &&
 -	    (ec->tx_coalesce_usecs < CDC_NCM_TIMER_INTERVAL_MIN * CDC_NCM_TIMER_PENDING_CNT ||
 -	     ec->tx_coalesce_usecs > CDC_NCM_TIMER_INTERVAL_MAX * CDC_NCM_TIMER_PENDING_CNT))
 -		return -EINVAL;
 -
 -	spin_lock_bh(&ctx->mtx);
 -	ctx->timer_interval = ec->tx_coalesce_usecs * NSEC_PER_USEC / CDC_NCM_TIMER_PENDING_CNT;
 -	if (!ctx->timer_interval)
 -		ctx->tx_timer_pending = 0;
 -	spin_unlock_bh(&ctx->mtx);
 -
 -	/* inform device of new values */
 -	if (new_rx_max != ctx->rx_max || new_tx_max != ctx->tx_max)
 -		cdc_ncm_update_rxtx_max(dev, new_rx_max, new_tx_max);
 -	return 0;
 +	strlcpy(info->driver, dev->driver_name, sizeof(info->driver));
 +	strlcpy(info->version, DRIVER_VERSION, sizeof(info->version));
 +	strlcpy(info->fw_version, dev->driver_info->description,
 +		sizeof(info->fw_version));
 +	usb_make_path(dev->udev, info->bus_info, sizeof(info->bus_info));
  }
  
 -static const struct ethtool_ops cdc_ncm_ethtool_ops = {
 -	.get_settings      = usbnet_get_settings,
 -	.set_settings      = usbnet_set_settings,
 -	.get_link          = usbnet_get_link,
 -	.nway_reset        = usbnet_nway_reset,
 -	.get_drvinfo       = usbnet_get_drvinfo,
 -	.get_msglevel      = usbnet_get_msglevel,
 -	.set_msglevel      = usbnet_set_msglevel,
 -	.get_ts_info       = ethtool_op_get_ts_info,
 -	.get_coalesce      = cdc_ncm_get_coalesce,
 -	.set_coalesce      = cdc_ncm_set_coalesce,
 -};
 -
 -/* handle rx_max and tx_max changes */
 -static void cdc_ncm_update_rxtx_max(struct usbnet *dev, u32 new_rx, u32 new_tx)
 +static u8 cdc_ncm_setup(struct usbnet *dev)
  {
  	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
++<<<<<<< HEAD
 +	u32 val;
 +	u8 flags;
 +	u8 iface_no;
++=======
+ 	u8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;
+ 	u32 val, max, min;
+ 
+ 	/* clamp new_rx to sane values */
+ 	min = USB_CDC_NCM_NTB_MIN_IN_SIZE;
+ 	max = min_t(u32, CDC_NCM_NTB_MAX_SIZE_RX, le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize));
+ 
+ 	/* dwNtbInMaxSize spec violation? Use MIN size for both limits */
+ 	if (max < min) {
+ 		dev_warn(&dev->intf->dev, "dwNtbInMaxSize=%u is too small. Using %u\n",
+ 			 le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize), min);
+ 		max = min;
+ 	}
+ 
+ 	val = clamp_t(u32, new_rx, min, max);
+ 	if (val != new_rx) {
+ 		dev_dbg(&dev->intf->dev, "rx_max must be in the [%u, %u] range. Using %u\n",
+ 			min, max, val);
+ 	}
+ 
+ 	/* usbnet use these values for sizing rx queues */
+ 	dev->rx_urb_size = val;
+ 
+ 	/* inform device about NTB input size changes */
+ 	if (val != ctx->rx_max) {
+ 		__le32 dwNtbInMaxSize = cpu_to_le32(val);
+ 
+ 		dev_info(&dev->intf->dev, "setting rx_max = %u\n", val);
+ 
+ 		/* need to unlink rx urbs before increasing buffer size */
+ 		if (netif_running(dev->net) && dev->rx_urb_size > ctx->rx_max)
+ 			usbnet_unlink_rx_urbs(dev);
+ 
+ 		/* tell device to use new size */
+ 		if (usbnet_write_cmd(dev, USB_CDC_SET_NTB_INPUT_SIZE,
+ 				     USB_TYPE_CLASS | USB_DIR_OUT
+ 				     | USB_RECIP_INTERFACE,
+ 				     0, iface_no, &dwNtbInMaxSize, 4) < 0)
+ 			dev_dbg(&dev->intf->dev, "Setting NTB Input Size failed\n");
+ 		else
+ 			ctx->rx_max = val;
+ 	}
+ 
+ 	/* clamp new_tx to sane values */
+ 	min = ctx->max_datagram_size + ctx->max_ndp_size + sizeof(struct usb_cdc_ncm_nth16);
+ 	max = min_t(u32, CDC_NCM_NTB_MAX_SIZE_TX, le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize));
+ 
+ 	/* some devices set dwNtbOutMaxSize too low for the above default */
+ 	min = min(min, max);
+ 
+ 	val = clamp_t(u32, new_tx, min, max);
+ 	if (val != new_tx) {
+ 		dev_dbg(&dev->intf->dev, "tx_max must be in the [%u, %u] range. Using %u\n",
+ 			min, max, val);
+ 	}
+ 	if (val != ctx->tx_max)
+ 		dev_info(&dev->intf->dev, "setting tx_max = %u\n", val);
+ 
+ 	/* Adding a pad byte here if necessary simplifies the handling
+ 	 * in cdc_ncm_fill_tx_frame, making tx_max always represent
+ 	 * the real skb max size.
+ 	 *
+ 	 * We cannot use dev->maxpacket here because this is called from
+ 	 * .bind which is called before usbnet sets up dev->maxpacket
+ 	 */
+ 	if (val != le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize) &&
+ 	    val % usb_maxpacket(dev->udev, dev->out, 1) == 0)
+ 		val++;
+ 
+ 	/* we might need to flush any pending tx buffers if running */
+ 	if (netif_running(dev->net) && val > ctx->tx_max) {
+ 		netif_tx_lock_bh(dev->net);
+ 		usbnet_start_xmit(NULL, dev->net);
+ 		ctx->tx_max = val;
+ 		netif_tx_unlock_bh(dev->net);
+ 	} else {
+ 		ctx->tx_max = val;
+ 	}
+ 
+ 	dev->hard_mtu = ctx->tx_max;
+ 
+ 	/* max qlen depend on hard_mtu and rx_urb_size */
+ 	usbnet_update_max_qlen(dev);
+ }
+ 
+ /* helpers for NCM and MBIM differences */
+ static u8 cdc_ncm_flags(struct usbnet *dev)
+ {
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 
+ 	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting) && ctx->mbim_desc)
+ 		return ctx->mbim_desc->bmNetworkCapabilities;
+ 	if (ctx->func_desc)
+ 		return ctx->func_desc->bmNetworkCapabilities;
+ 	return 0;
+ }
+ 
+ static int cdc_ncm_eth_hlen(struct usbnet *dev)
+ {
+ 	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting))
+ 		return 0;
+ 	return ETH_HLEN;
+ }
+ 
+ static u32 cdc_ncm_min_dgram_size(struct usbnet *dev)
+ {
+ 	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting))
+ 		return CDC_MBIM_MIN_DATAGRAM_SIZE;
+ 	return CDC_NCM_MIN_DATAGRAM_SIZE;
+ }
+ 
+ static u32 cdc_ncm_max_dgram_size(struct usbnet *dev)
+ {
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 
+ 	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting) && ctx->mbim_desc)
+ 		return le16_to_cpu(ctx->mbim_desc->wMaxSegmentSize);
+ 	if (ctx->ether_desc)
+ 		return le16_to_cpu(ctx->ether_desc->wMaxSegmentSize);
+ 	return CDC_NCM_MAX_DATAGRAM_SIZE;
+ }
+ 
+ /* initial one-time device setup.  MUST be called with the data interface
+  * in altsetting 0
+  */
+ static int cdc_ncm_init(struct usbnet *dev)
+ {
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 	u8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;
++>>>>>>> 70559b8970e5 (net: cdc_ncm: use true max dgram count for header estimates)
  	int err;
 +	int eth_hlen;
 +	u16 mbim_mtu;
 +	u16 ntb_fmt_supported;
 +	__le16 max_datagram_size;
 +
 +	iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;
  
  	err = usbnet_read_cmd(dev, USB_CDC_GET_NTB_PARAMETERS,
  			      USB_TYPE_CLASS | USB_DIR_IN
@@@ -147,37 -318,68 +279,74 @@@
  			(ctx->tx_max_datagrams > CDC_NCM_DPT_DATAGRAMS_MAX))
  		ctx->tx_max_datagrams = CDC_NCM_DPT_DATAGRAMS_MAX;
  
++<<<<<<< HEAD
 +	/* verify maximum size of received NTB in bytes */
 +	if (ctx->rx_max < USB_CDC_NCM_NTB_MIN_IN_SIZE) {
 +		dev_dbg(&dev->intf->dev, "Using min receive length=%d\n",
 +			USB_CDC_NCM_NTB_MIN_IN_SIZE);
 +		ctx->rx_max = USB_CDC_NCM_NTB_MIN_IN_SIZE;
++=======
+ 	/* set up maximum NDP size */
+ 	ctx->max_ndp_size = sizeof(struct usb_cdc_ncm_ndp16) + (ctx->tx_max_datagrams + 1) * sizeof(struct usb_cdc_ncm_dpe16);
+ 
+ 	/* initial coalescing timer interval */
+ 	ctx->timer_interval = CDC_NCM_TIMER_INTERVAL_USEC * NSEC_PER_USEC;
+ 
+ 	return 0;
+ }
+ 
+ /* set a new max datagram size */
+ static void cdc_ncm_set_dgram_size(struct usbnet *dev, int new_size)
+ {
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 	u8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;
+ 	__le16 max_datagram_size;
+ 	u16 mbim_mtu;
+ 	int err;
+ 
+ 	/* set default based on descriptors */
+ 	ctx->max_datagram_size = clamp_t(u32, new_size,
+ 					 cdc_ncm_min_dgram_size(dev),
+ 					 CDC_NCM_MAX_DATAGRAM_SIZE);
+ 
+ 	/* inform the device about the selected Max Datagram Size? */
+ 	if (!(cdc_ncm_flags(dev) & USB_CDC_NCM_NCAP_MAX_DATAGRAM_SIZE))
+ 		goto out;
+ 
+ 	/* read current mtu value from device */
+ 	err = usbnet_read_cmd(dev, USB_CDC_GET_MAX_DATAGRAM_SIZE,
+ 			      USB_TYPE_CLASS | USB_DIR_IN | USB_RECIP_INTERFACE,
+ 			      0, iface_no, &max_datagram_size, 2);
+ 	if (err < 0) {
+ 		dev_dbg(&dev->intf->dev, "GET_MAX_DATAGRAM_SIZE failed\n");
+ 		goto out;
++>>>>>>> 70559b8970e5 (net: cdc_ncm: use true max dgram count for header estimates)
  	}
  
 -	if (le16_to_cpu(max_datagram_size) == ctx->max_datagram_size)
 -		goto out;
 -
 -	max_datagram_size = cpu_to_le16(ctx->max_datagram_size);
 -	err = usbnet_write_cmd(dev, USB_CDC_SET_MAX_DATAGRAM_SIZE,
 -			       USB_TYPE_CLASS | USB_DIR_OUT | USB_RECIP_INTERFACE,
 -			       0, iface_no, &max_datagram_size, 2);
 -	if (err < 0)
 -		dev_dbg(&dev->intf->dev, "SET_MAX_DATAGRAM_SIZE failed\n");
 +	if (ctx->rx_max > CDC_NCM_NTB_MAX_SIZE_RX) {
 +		dev_dbg(&dev->intf->dev, "Using default maximum receive length=%d\n",
 +			CDC_NCM_NTB_MAX_SIZE_RX);
 +		ctx->rx_max = CDC_NCM_NTB_MAX_SIZE_RX;
 +	}
  
 -out:
 -	/* set MTU to max supported by the device if necessary */
 -	dev->net->mtu = min_t(int, dev->net->mtu, ctx->max_datagram_size - cdc_ncm_eth_hlen(dev));
 +	/* inform device about NTB input size changes */
 +	if (ctx->rx_max != le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize)) {
 +		__le32 dwNtbInMaxSize = cpu_to_le32(ctx->rx_max);
  
 -	/* do not exceed operater preferred MTU */
 -	if (ctx->mbim_extended_desc) {
 -		mbim_mtu = le16_to_cpu(ctx->mbim_extended_desc->wMTU);
 -		if (mbim_mtu != 0 && mbim_mtu < dev->net->mtu)
 -			dev->net->mtu = mbim_mtu;
 +		err = usbnet_write_cmd(dev, USB_CDC_SET_NTB_INPUT_SIZE,
 +				       USB_TYPE_CLASS | USB_DIR_OUT
 +				       | USB_RECIP_INTERFACE,
 +				       0, iface_no, &dwNtbInMaxSize, 4);
 +		if (err < 0)
 +			dev_dbg(&dev->intf->dev, "Setting NTB Input Size failed\n");
  	}
 -}
  
 -static void cdc_ncm_fix_modulus(struct usbnet *dev)
 -{
 -	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
 -	u32 val;
 +	/* verify maximum size of transmitted NTB in bytes */
 +	if (ctx->tx_max > CDC_NCM_NTB_MAX_SIZE_TX) {
 +		dev_dbg(&dev->intf->dev, "Using default maximum transmit length=%d\n",
 +			CDC_NCM_NTB_MAX_SIZE_TX);
 +		ctx->tx_max = CDC_NCM_NTB_MAX_SIZE_TX;
 +	}
  
  	/*
  	 * verify that the structure alignment is:
diff --cc include/linux/usb/cdc_ncm.h
index 55b6feead93b,60a44b8a464e..000000000000
--- a/include/linux/usb/cdc_ncm.h
+++ b/include/linux/usb/cdc_ncm.h
@@@ -72,17 -72,10 +72,8 @@@
  /* Restart the timer, if amount of datagrams is less than given value */
  #define	CDC_NCM_RESTART_TIMER_DATAGRAM_CNT	3
  #define	CDC_NCM_TIMER_PENDING_CNT		2
 -#define CDC_NCM_TIMER_INTERVAL_USEC		400UL
 -#define CDC_NCM_TIMER_INTERVAL_MIN		5UL
 -#define CDC_NCM_TIMER_INTERVAL_MAX		(15UL * USEC_PER_SEC)
 +#define CDC_NCM_TIMER_INTERVAL			(400UL * NSEC_PER_USEC)
  
- /* The following macro defines the minimum header space */
- #define	CDC_NCM_MIN_HDR_SIZE \
- 	(sizeof(struct usb_cdc_ncm_nth16) + sizeof(struct usb_cdc_ncm_ndp16) + \
- 	(CDC_NCM_DPT_DATAGRAMS_MAX + 1) * sizeof(struct usb_cdc_ncm_dpe16))
- 
- #define CDC_NCM_NDP_SIZE \
- 	(sizeof(struct usb_cdc_ncm_ndp16) +				\
- 	      (CDC_NCM_DPT_DATAGRAMS_MAX + 1) * sizeof(struct usb_cdc_ncm_dpe16))
- 
  #define cdc_ncm_comm_intf_is_mbim(x)  ((x)->desc.bInterfaceSubClass == USB_CDC_SUBCLASS_MBIM && \
  				       (x)->desc.bInterfaceProtocol == USB_CDC_PROTO_NONE)
  #define cdc_ncm_data_intf_is_mbim(x)  ((x)->desc.bInterfaceProtocol == USB_CDC_MBIM_PROTO_NTB)
@@@ -107,6 -100,9 +98,12 @@@ struct cdc_ncm_ctx 
  	spinlock_t mtx;
  	atomic_t stop;
  
++<<<<<<< HEAD
++=======
+ 	u64 timer_interval;
+ 	u32 max_ndp_size;
+ 
++>>>>>>> 70559b8970e5 (net: cdc_ncm: use true max dgram count for header estimates)
  	u32 tx_timer_pending;
  	u32 tx_curr_frame_num;
  	u32 rx_max;
* Unmerged path drivers/net/usb/cdc_ncm.c
* Unmerged path include/linux/usb/cdc_ncm.h
