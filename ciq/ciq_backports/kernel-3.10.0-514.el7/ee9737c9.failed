x86/uaccess/64: Make the __copy_user_nocache() assembly code more readable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] uaccess/64: Make the __copy_user_nocache() assembly code more readable (Jeff Moyer) [1346083 1346084 1346445 1346449 1346472 1347091 1359806]
Rebuild_FUZZ: 97.22%
commit-author Toshi Kani <toshi.kani@hpe.com>
commit ee9737c924706aaa72c2ead93e3ad5644681dc1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ee9737c9.failed

Add comments to __copy_user_nocache() to clarify its procedures
and alignment requirements.

Also change numeric branch target labels to named local labels.

No code changed:

 arch/x86/lib/copy_user_64.o:

    text    data     bss     dec     hex filename
    1239       0       0    1239     4d7 copy_user_64.o.before
    1239       0       0    1239     4d7 copy_user_64.o.after

 md5:
    58bed94c2db98c1ca9a2d46d0680aaae  copy_user_64.o.before.asm
    58bed94c2db98c1ca9a2d46d0680aaae  copy_user_64.o.after.asm

	Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
	Cc: <stable@vger.kernel.org>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Borislav Petkov <bp@suse.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Luis R. Rodriguez <mcgrof@suse.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Toshi Kani <toshi.kani@hp.com>
	Cc: brian.boylston@hpe.com
	Cc: dan.j.williams@intel.com
	Cc: linux-nvdimm@lists.01.org
	Cc: micah.parrish@hpe.com
	Cc: ross.zwisler@linux.intel.com
	Cc: vishal.l.verma@intel.com
Link: http://lkml.kernel.org/r/1455225857-12039-2-git-send-email-toshi.kani@hpe.com
[ Small readability edits and added object file comparison. ]
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit ee9737c924706aaa72c2ead93e3ad5644681dc1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/lib/copy_user_64.S
diff --cc arch/x86/lib/copy_user_64.S
index a30ca15be21c,a644aad1f112..000000000000
--- a/arch/x86/lib/copy_user_64.S
+++ b/arch/x86/lib/copy_user_64.S
@@@ -294,5 -228,126 +294,130 @@@ ENTRY(copy_user_enhanced_fast_string
  	.previous
  
  	_ASM_EXTABLE(1b,12b)
 +	CFI_ENDPROC
  ENDPROC(copy_user_enhanced_fast_string)
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * copy_user_nocache - Uncached memory copy with exception handling
+  * This will force destination out of cache for more performance.
+  *
+  * Note: Cached memory copy is used when destination or size is not
+  * naturally aligned. That is:
+  *  - Require 8-byte alignment when size is 8 bytes or larger.
+  */
+ ENTRY(__copy_user_nocache)
+ 	ASM_STAC
+ 
+ 	/* If size is less than 8 bytes, go to byte copy */
+ 	cmpl $8,%edx
+ 	jb .L_1b_cache_copy_entry
+ 
+ 	/* If destination is not 8-byte aligned, "cache" copy to align it */
+ 	ALIGN_DESTINATION
+ 
+ 	/* Set 4x8-byte copy count and remainder */
+ 	movl %edx,%ecx
+ 	andl $63,%edx
+ 	shrl $6,%ecx
+ 	jz .L_8b_nocache_copy_entry	/* jump if count is 0 */
+ 
+ 	/* Perform 4x8-byte nocache loop-copy */
+ .L_4x8b_nocache_copy_loop:
+ 1:	movq (%rsi),%r8
+ 2:	movq 1*8(%rsi),%r9
+ 3:	movq 2*8(%rsi),%r10
+ 4:	movq 3*8(%rsi),%r11
+ 5:	movnti %r8,(%rdi)
+ 6:	movnti %r9,1*8(%rdi)
+ 7:	movnti %r10,2*8(%rdi)
+ 8:	movnti %r11,3*8(%rdi)
+ 9:	movq 4*8(%rsi),%r8
+ 10:	movq 5*8(%rsi),%r9
+ 11:	movq 6*8(%rsi),%r10
+ 12:	movq 7*8(%rsi),%r11
+ 13:	movnti %r8,4*8(%rdi)
+ 14:	movnti %r9,5*8(%rdi)
+ 15:	movnti %r10,6*8(%rdi)
+ 16:	movnti %r11,7*8(%rdi)
+ 	leaq 64(%rsi),%rsi
+ 	leaq 64(%rdi),%rdi
+ 	decl %ecx
+ 	jnz .L_4x8b_nocache_copy_loop
+ 
+ 	/* Set 8-byte copy count and remainder */
+ .L_8b_nocache_copy_entry:
+ 	movl %edx,%ecx
+ 	andl $7,%edx
+ 	shrl $3,%ecx
+ 	jz .L_1b_cache_copy_entry	/* jump if count is 0 */
+ 
+ 	/* Perform 8-byte nocache loop-copy */
+ .L_8b_nocache_copy_loop:
+ 20:	movq (%rsi),%r8
+ 21:	movnti %r8,(%rdi)
+ 	leaq 8(%rsi),%rsi
+ 	leaq 8(%rdi),%rdi
+ 	decl %ecx
+ 	jnz .L_8b_nocache_copy_loop
+ 
+ 	/* If no byte left, we're done */
+ .L_1b_cache_copy_entry:
+ 	andl %edx,%edx
+ 	jz .L_finish_copy
+ 
+ 	/* Perform byte "cache" loop-copy for the remainder */
+ 	movl %edx,%ecx
+ .L_1b_cache_copy_loop:
+ 40:	movb (%rsi),%al
+ 41:	movb %al,(%rdi)
+ 	incq %rsi
+ 	incq %rdi
+ 	decl %ecx
+ 	jnz .L_1b_cache_copy_loop
+ 
+ 	/* Finished copying; fence the prior stores */
+ .L_finish_copy:
+ 	xorl %eax,%eax
+ 	ASM_CLAC
+ 	sfence
+ 	ret
+ 
+ 	.section .fixup,"ax"
+ .L_fixup_4x8b_copy:
+ 	shll $6,%ecx
+ 	addl %ecx,%edx
+ 	jmp .L_fixup_handle_tail
+ .L_fixup_8b_copy:
+ 	lea (%rdx,%rcx,8),%rdx
+ 	jmp .L_fixup_handle_tail
+ .L_fixup_1b_copy:
+ 	movl %ecx,%edx
+ .L_fixup_handle_tail:
+ 	sfence
+ 	jmp copy_user_handle_tail
+ 	.previous
+ 
+ 	_ASM_EXTABLE(1b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(2b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(3b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(4b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(5b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(6b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(7b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(8b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(9b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(10b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(11b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(12b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(13b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(14b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(15b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(16b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(20b,.L_fixup_8b_copy)
+ 	_ASM_EXTABLE(21b,.L_fixup_8b_copy)
+ 	_ASM_EXTABLE(40b,.L_fixup_1b_copy)
+ 	_ASM_EXTABLE(41b,.L_fixup_1b_copy)
+ ENDPROC(__copy_user_nocache)
++>>>>>>> ee9737c92470 (x86/uaccess/64: Make the __copy_user_nocache() assembly code more readable)
* Unmerged path arch/x86/lib/copy_user_64.S
