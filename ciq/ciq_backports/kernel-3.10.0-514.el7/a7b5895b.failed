perf hists: Add more helper functions for the hierarchy mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit a7b5895b91fb97f2b0dcc2e3ce47413c18d19ca5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a7b5895b.failed

The hists__overhead_width() is to calculate width occupied by the
overhead (and others) columns before the sort columns.

The hist_entry__has_hiearchy_children() is to check whether an entry has
lower entries (children) in the hierarchy to be shown in the output.
This means the children should not be filtered out and above the percent
limit.

These two functions will be used to show information when all children
of an entry is omitted by the percent limit (or filter).

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1456488800-28124-1-git-send-email-namhyung@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit a7b5895b91fb97f2b0dcc2e3ce47413c18d19ca5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/hist.c
#	tools/perf/util/hist.h
diff --cc tools/perf/util/hist.c
index 9a525a5b649f,e71691977a95..000000000000
--- a/tools/perf/util/hist.c
+++ b/tools/perf/util/hist.c
@@@ -1341,6 -1509,104 +1341,107 @@@ void hists__output_resort(struct hists 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ void perf_evsel__output_resort(struct perf_evsel *evsel, struct ui_progress *prog)
+ {
+ 	bool use_callchain;
+ 
+ 	if (evsel && symbol_conf.use_callchain && !symbol_conf.show_ref_callgraph)
+ 		use_callchain = evsel->attr.sample_type & PERF_SAMPLE_CALLCHAIN;
+ 	else
+ 		use_callchain = symbol_conf.use_callchain;
+ 
+ 	output_resort(evsel__hists(evsel), prog, use_callchain);
+ }
+ 
+ void hists__output_resort(struct hists *hists, struct ui_progress *prog)
+ {
+ 	output_resort(hists, prog, symbol_conf.use_callchain);
+ }
+ 
+ static bool can_goto_child(struct hist_entry *he, enum hierarchy_move_dir hmd)
+ {
+ 	if (he->leaf || hmd == HMD_FORCE_SIBLING)
+ 		return false;
+ 
+ 	if (he->unfolded || hmd == HMD_FORCE_CHILD)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ struct rb_node *rb_hierarchy_last(struct rb_node *node)
+ {
+ 	struct hist_entry *he = rb_entry(node, struct hist_entry, rb_node);
+ 
+ 	while (can_goto_child(he, HMD_NORMAL)) {
+ 		node = rb_last(&he->hroot_out);
+ 		he = rb_entry(node, struct hist_entry, rb_node);
+ 	}
+ 	return node;
+ }
+ 
+ struct rb_node *__rb_hierarchy_next(struct rb_node *node, enum hierarchy_move_dir hmd)
+ {
+ 	struct hist_entry *he = rb_entry(node, struct hist_entry, rb_node);
+ 
+ 	if (can_goto_child(he, hmd))
+ 		node = rb_first(&he->hroot_out);
+ 	else
+ 		node = rb_next(node);
+ 
+ 	while (node == NULL) {
+ 		he = he->parent_he;
+ 		if (he == NULL)
+ 			break;
+ 
+ 		node = rb_next(&he->rb_node);
+ 	}
+ 	return node;
+ }
+ 
+ struct rb_node *rb_hierarchy_prev(struct rb_node *node)
+ {
+ 	struct hist_entry *he = rb_entry(node, struct hist_entry, rb_node);
+ 
+ 	node = rb_prev(node);
+ 	if (node)
+ 		return rb_hierarchy_last(node);
+ 
+ 	he = he->parent_he;
+ 	if (he == NULL)
+ 		return NULL;
+ 
+ 	return &he->rb_node;
+ }
+ 
+ bool hist_entry__has_hierarchy_children(struct hist_entry *he, float limit)
+ {
+ 	struct rb_node *node;
+ 	struct hist_entry *child;
+ 	float percent;
+ 
+ 	if (he->leaf)
+ 		return false;
+ 
+ 	node = rb_first(&he->hroot_out);
+ 	child = rb_entry(node, struct hist_entry, rb_node);
+ 
+ 	while (node && child->filtered) {
+ 		node = rb_next(node);
+ 		child = rb_entry(node, struct hist_entry, rb_node);
+ 	}
+ 
+ 	if (node)
+ 		percent = hist_entry__get_percent_limit(child);
+ 	else
+ 		percent = 0;
+ 
+ 	return node && percent >= limit;
+ }
+ 
++>>>>>>> a7b5895b91fb (perf hists: Add more helper functions for the hierarchy mode)
  static void hists__remove_entry_filter(struct hists *hists, struct hist_entry *h,
  				       enum hist_filter filter)
  {
diff --cc tools/perf/util/hist.h
index 1d52912874e9,da3e7b6e4615..000000000000
--- a/tools/perf/util/hist.h
+++ b/tools/perf/util/hist.h
@@@ -384,4 -422,24 +385,27 @@@ int perf_hist_config(const char *var, c
  
  void perf_hpp_list__init(struct perf_hpp_list *list);
  
++<<<<<<< HEAD
++=======
+ enum hierarchy_move_dir {
+ 	HMD_NORMAL,
+ 	HMD_FORCE_SIBLING,
+ 	HMD_FORCE_CHILD,
+ };
+ 
+ struct rb_node *rb_hierarchy_last(struct rb_node *node);
+ struct rb_node *__rb_hierarchy_next(struct rb_node *node,
+ 				    enum hierarchy_move_dir hmd);
+ struct rb_node *rb_hierarchy_prev(struct rb_node *node);
+ 
+ static inline struct rb_node *rb_hierarchy_next(struct rb_node *node)
+ {
+ 	return __rb_hierarchy_next(node, HMD_NORMAL);
+ }
+ 
+ #define HIERARCHY_INDENT  3
+ 
+ bool hist_entry__has_hierarchy_children(struct hist_entry *he, float limit);
+ 
++>>>>>>> a7b5895b91fb (perf hists: Add more helper functions for the hierarchy mode)
  #endif	/* __PERF_HIST_H */
diff --git a/tools/perf/ui/hist.c b/tools/perf/ui/hist.c
index ad40452da995..5c05ac48880c 100644
--- a/tools/perf/ui/hist.c
+++ b/tools/perf/ui/hist.c
@@ -637,6 +637,28 @@ unsigned int hists__sort_list_width(struct hists *hists)
 	return ret;
 }
 
+unsigned int hists__overhead_width(struct hists *hists)
+{
+	struct perf_hpp_fmt *fmt;
+	int ret = 0;
+	bool first = true;
+	struct perf_hpp dummy_hpp;
+
+	hists__for_each_format(hists, fmt) {
+		if (perf_hpp__is_sort_entry(fmt) || perf_hpp__is_dynamic_entry(fmt))
+			break;
+
+		if (first)
+			first = false;
+		else
+			ret += 2;
+
+		ret += fmt->width(fmt, &dummy_hpp, hists_to_evsel(hists));
+	}
+
+	return ret;
+}
+
 void perf_hpp__reset_width(struct perf_hpp_fmt *fmt, struct hists *hists)
 {
 	if (perf_hpp__is_sort_entry(fmt))
* Unmerged path tools/perf/util/hist.c
* Unmerged path tools/perf/util/hist.h
