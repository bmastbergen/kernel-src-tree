IB/hfi1: Add pin query function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mitko Haralanov <mitko.haralanov@intel.com>
commit 2c97ce4f3c292e9ab75c7b6b4d9f69f0a9ee241d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2c97ce4f.failed

System administrators can use the locked memory
ulimit setting to set the maximum amount of memory
a user can lock/pin. However, this setting alone is not
enough to guarantee good operation of the hfi1 driver
due to the fact that the setting does not have fine
enough granularity to account for the limit being used
by multiple user processes and caches.

Therefore, a better limiting algorithm is needed. This
is where the new hfi1_can_pin_pages() function and the
cache_size module parameter come in.

The function works by looking at the ulimit and cache_size
value to compute a cache size. The algorithm examines the
ulimit value and, if it is not "unlimited", computes a
per-cache limit based on the number of configured user
contexts.

After that, the lower of the two - cache_size and computed
per-cache limit - is used.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Reviewed-by: Dean Luick <dean.luick@intel.com>
	Signed-off-by: Mitko Haralanov <mitko.haralanov@intel.com>
	Signed-off-by: Jubin John <jubin.john@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 2c97ce4f3c292e9ab75c7b6b4d9f69f0a9ee241d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/user_pages.c
diff --cc drivers/staging/hfi1/user_pages.c
index 692de658f0dc,bd7a8ab0d635..000000000000
--- a/drivers/staging/hfi1/user_pages.c
+++ b/drivers/staging/hfi1/user_pages.c
@@@ -54,26 -52,42 +55,61 @@@
  
  #include "hfi.h"
  
++<<<<<<< HEAD:drivers/staging/hfi1/user_pages.c
 +/**
 + * hfi1_map_page - a safety wrapper around pci_map_page()
 + *
 + */
 +dma_addr_t hfi1_map_page(struct pci_dev *hwdev, struct page *page,
 +			 unsigned long offset, size_t size, int direction)
 +{
 +	dma_addr_t phys;
 +
 +	phys = pci_map_page(hwdev, page, offset, size, direction);
 +
 +	return phys;
 +}
 +
 +int hfi1_acquire_user_pages(unsigned long vaddr, size_t npages, bool writable,
 +			    struct page **pages)
++=======
+ static unsigned long cache_size = 256;
+ module_param(cache_size, ulong, S_IRUGO | S_IWUSR);
+ MODULE_PARM_DESC(cache_size, "Send and receive side cache size limit (in MB)");
+ 
+ /*
+  * Determine whether the caller can pin pages.
+  *
+  * This function should be used in the implementation of buffer caches.
+  * The cache implementation should call this function prior to attempting
+  * to pin buffer pages in order to determine whether they should do so.
+  * The function computes cache limits based on the configured ulimit and
+  * cache size. Use of this function is especially important for caches
+  * which are not limited in any other way (e.g. by HW resources) and, thus,
+  * could keeping caching buffers.
+  *
+  */
+ bool hfi1_can_pin_pages(struct hfi1_devdata *dd, u32 nlocked, u32 npages)
++>>>>>>> 2c97ce4f3c29 (IB/hfi1: Add pin query function):drivers/staging/rdma/hfi1/user_pages.c
  {
- 	unsigned long pinned, lock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;
+ 	unsigned long ulimit = rlimit(RLIMIT_MEMLOCK), pinned, cache_limit,
+ 		size = (cache_size * (1UL << 20)); /* convert to bytes */
+ 	unsigned usr_ctxts = dd->num_rcv_contexts - dd->first_user_ctxt;
  	bool can_lock = capable(CAP_IPC_LOCK);
- 	int ret;
+ 
+ 	/*
+ 	 * Calculate per-cache size. The calculation below uses only a quarter
+ 	 * of the available per-context limit. This leaves space for other
+ 	 * pinning. Should we worry about shared ctxts?
+ 	 */
+ 	cache_limit = (ulimit / usr_ctxts) / 4;
+ 
+ 	/* If ulimit isn't set to "unlimited" and is smaller than cache_size. */
+ 	if (ulimit != (-1UL) && size > cache_limit)
+ 		size = cache_limit;
+ 
+ 	/* Convert to number of pages */
+ 	size = DIV_ROUND_UP(size, PAGE_SIZE);
  
  	down_read(&current->mm->mmap_sem);
  	pinned = current->mm->pinned_vm;
diff --git a/drivers/staging/hfi1/hfi.h b/drivers/staging/hfi1/hfi.h
index 6438dccf5749..fe8c3f2887a2 100644
--- a/drivers/staging/hfi1/hfi.h
+++ b/drivers/staging/hfi1/hfi.h
@@ -1630,6 +1630,7 @@ void shutdown_led_override(struct hfi1_pportdata *ppd);
  */
 #define DEFAULT_RCVHDR_ENTSIZE 32
 
+bool hfi1_can_pin_pages(struct hfi1_devdata *, u32, u32);
 int hfi1_acquire_user_pages(unsigned long, size_t, bool, struct page **);
 void hfi1_release_user_pages(struct page **, size_t, bool);
 
* Unmerged path drivers/staging/hfi1/user_pages.c
