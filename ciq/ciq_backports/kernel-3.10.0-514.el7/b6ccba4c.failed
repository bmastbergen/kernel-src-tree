net: add a possibility to get private from netdev_adjacent->list

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] add a possibility to get private from netdev_adjacent->list (Ivan Vecera) [1268334]
Rebuild_FUZZ: 95.93%
commit-author Veaceslav Falico <vfalico@redhat.com>
commit b6ccba4c681fdaf0070e580bf951badf7edc860b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b6ccba4c.failed

It will be useful to get first/last element.

CC: "David S. Miller" <davem@davemloft.net>
CC: Eric Dumazet <edumazet@google.com>
CC: Jiri Pirko <jiri@resnulli.us>
CC: Alexander Duyck <alexander.h.duyck@intel.com>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b6ccba4c681fdaf0070e580bf951badf7edc860b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/core/dev.c
diff --cc include/linux/netdevice.h
index 7b10147de03d,b4cfb63f264e..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -3273,30 -2820,57 +3273,71 @@@ extern int		netdev_tstamp_prequeue
  extern int		weight_p;
  extern int		bpf_jit_enable;
  
 -extern bool netdev_has_upper_dev(struct net_device *dev,
 +bool netdev_has_upper_dev(struct net_device *dev, struct net_device *upper_dev);
 +bool netdev_has_any_upper_dev(struct net_device *dev);
 +struct net_device *netdev_master_upper_dev_get(struct net_device *dev);
 +struct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev);
 +int netdev_upper_dev_link(struct net_device *dev, struct net_device *upper_dev);
 +int netdev_master_upper_dev_link(struct net_device *dev,
  				 struct net_device *upper_dev);
 -extern bool netdev_has_any_upper_dev(struct net_device *dev);
 -extern struct net_device *netdev_all_upper_get_next_dev_rcu(struct net_device *dev,
 -							    struct list_head **iter);
 -
 -/* iterate through upper list, must be called under RCU read lock */
 -#define netdev_for_each_all_upper_dev_rcu(dev, updev, iter) \
 -	for (iter = &(dev)->all_adj_list.upper, \
 -	     updev = netdev_all_upper_get_next_dev_rcu(dev, &(iter)); \
 -	     updev; \
 -	     updev = netdev_all_upper_get_next_dev_rcu(dev, &(iter)))
 -
 +void netdev_upper_dev_unlink(struct net_device *dev,
 +			     struct net_device *upper_dev);
 +void *netdev_lower_dev_get_private_rcu(struct net_device *dev,
 +				       struct net_device *lower_dev);
 +void *netdev_lower_dev_get_private(struct net_device *dev,
 +				   struct net_device *lower_dev);
 +
 +/* RSS keys are 40 or 52 bytes long */
 +#define NETDEV_RSS_KEY_LEN 52
 +extern u8 netdev_rss_key[NETDEV_RSS_KEY_LEN];
 +void netdev_rss_key_fill(void *buffer, size_t len);
 +
++<<<<<<< HEAD
 +int skb_checksum_help(struct sk_buff *skb);
 +struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
 +				  netdev_features_t features, bool tx_path);
 +struct sk_buff *skb_mac_gso_segment(struct sk_buff *skb,
 +				    netdev_features_t features);
++=======
+ extern void *netdev_lower_get_next_private(struct net_device *dev,
+ 					   struct list_head **iter);
+ extern void *netdev_lower_get_next_private_rcu(struct net_device *dev,
+ 					       struct list_head **iter);
+ 
+ #define netdev_for_each_lower_private(dev, priv, iter) \
+ 	for (iter = (dev)->adj_list.lower.next, \
+ 	     priv = netdev_lower_get_next_private(dev, &(iter)); \
+ 	     priv; \
+ 	     priv = netdev_lower_get_next_private(dev, &(iter)))
+ 
+ #define netdev_for_each_lower_private_rcu(dev, priv, iter) \
+ 	for (iter = &(dev)->adj_list.lower, \
+ 	     priv = netdev_lower_get_next_private_rcu(dev, &(iter)); \
+ 	     priv; \
+ 	     priv = netdev_lower_get_next_private_rcu(dev, &(iter)))
+ 
+ extern void *netdev_adjacent_get_private(struct list_head *adj_list);
+ extern struct net_device *netdev_master_upper_dev_get(struct net_device *dev);
+ extern struct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev);
+ extern int netdev_upper_dev_link(struct net_device *dev,
+ 				 struct net_device *upper_dev);
+ extern int netdev_master_upper_dev_link(struct net_device *dev,
+ 					struct net_device *upper_dev);
+ extern int netdev_master_upper_dev_link_private(struct net_device *dev,
+ 						struct net_device *upper_dev,
+ 						void *private);
+ extern void netdev_upper_dev_unlink(struct net_device *dev,
+ 				    struct net_device *upper_dev);
+ extern void *netdev_lower_dev_get_private_rcu(struct net_device *dev,
+ 					      struct net_device *lower_dev);
+ extern void *netdev_lower_dev_get_private(struct net_device *dev,
+ 					  struct net_device *lower_dev);
+ extern int skb_checksum_help(struct sk_buff *skb);
+ extern struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
+ 	netdev_features_t features, bool tx_path);
+ extern struct sk_buff *skb_mac_gso_segment(struct sk_buff *skb,
+ 					  netdev_features_t features);
++>>>>>>> b6ccba4c681f (net: add a possibility to get private from netdev_adjacent->list)
  
  static inline
  struct sk_buff *skb_gso_segment(struct sk_buff *skb, netdev_features_t features)
diff --cc net/core/dev.c
index 004e3f31d664,acc11810805f..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -4606,7 -4466,18 +4606,22 @@@ struct net_device *netdev_master_upper_
  }
  EXPORT_SYMBOL(netdev_master_upper_dev_get);
  
++<<<<<<< HEAD
 +/* netdev_upper_get_next_dev_rcu - Get the next dev from upper list
++=======
+ void *netdev_adjacent_get_private(struct list_head *adj_list)
+ {
+ 	struct netdev_adjacent *adj;
+ 
+ 	adj = list_entry(adj_list, struct netdev_adjacent, list);
+ 
+ 	return adj->private;
+ }
+ EXPORT_SYMBOL(netdev_adjacent_get_private);
+ 
+ /**
+  * netdev_all_upper_get_next_dev_rcu - Get the next dev from upper list
++>>>>>>> b6ccba4c681f (net: add a possibility to get private from netdev_adjacent->list)
   * @dev: device
   * @iter: list_head ** of the current position
   *
* Unmerged path include/linux/netdevice.h
* Unmerged path net/core/dev.c
