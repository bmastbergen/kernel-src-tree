iser-target: release stale iser connections

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 2f1b6b7d9a815f341b18dfd26a363f37d4d3c96a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2f1b6b7d.failed

When receiving a new iser connect request we serialize
the pending requests by adding the newly created iser connection
to the np accept list and let the login thread process the connect
request one by one (np_accept_wait).

In case we received a disconnect request before the iser_conn
has begun processing (still linked in np_accept_list) we should
detach it from the list and clean it up and not have the login
thread process a stale connection. We do it only when the connection
state is not already terminating (initiator driven disconnect) as
this might lead us to access np_accept_mutex after the np was released
in live shutdown scenarios.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Jenny Falkovich <jennyf@mellanox.com>
	Cc: stable@vger.kernel.org # 3.10+
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 2f1b6b7d9a815f341b18dfd26a363f37d4d3c96a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/isert/ib_isert.c
diff --cc drivers/infiniband/ulp/isert/ib_isert.c
index ad0c40a65af4,bad1f5d32227..000000000000
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@@ -953,12 -947,12 +953,21 @@@ isert_disconnected_handler(struct rdma_
  		goto out;
  
  	mutex_lock(&isert_np->np_accept_mutex);
++<<<<<<< HEAD
 +        if (!list_empty(&isert_conn->accept_node)) {
 +                list_del_init(&isert_conn->accept_node);
 +                isert_put_conn(isert_conn);
 +                queue_work(isert_release_wq, &isert_conn->release_work);
 +        }
 +        mutex_unlock(&isert_np->np_accept_mutex);
++=======
+ 	if (!list_empty(&isert_conn->accept_node)) {
+ 		list_del_init(&isert_conn->accept_node);
+ 		isert_put_conn(isert_conn);
+ 		queue_work(isert_release_wq, &isert_conn->release_work);
+ 	}
+ 	mutex_unlock(&isert_np->np_accept_mutex);
++>>>>>>> 2f1b6b7d9a81 (iser-target: release stale iser connections)
  
  out:
  	return 0;
* Unmerged path drivers/infiniband/ulp/isert/ib_isert.c
