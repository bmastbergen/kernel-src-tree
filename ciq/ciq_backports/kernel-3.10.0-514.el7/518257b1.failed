dm mpath: switch to using bitops for state flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mike Snitzer <snitzer@redhat.com>
commit 518257b13276d07a19e6ae0608b8e5ee73383ce4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/518257b1.failed

Mechanical change that doesn't make any real effort to reduce the use of
m->lock; that will come later (once atomics are used for counters, etc).

	Suggested-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Tested-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 518257b13276d07a19e6ae0608b8e5ee73383ce4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-mpath.c
diff --cc drivers/md/dm-mpath.c
index e077a28bdb3f,598d4a1123e0..000000000000
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@@ -595,10 -618,11 +613,15 @@@ static struct pgpath *parse_path(struc
  		goto bad;
  	}
  
- 	if (m->retain_attached_hw_handler || m->hw_handler_name)
+ 	if (test_bit(MPATHF_RETAIN_ATTACHED_HW_HANDLER, &m->flags) || m->hw_handler_name)
  		q = bdev_get_queue(p->path.dev->bdev);
  
++<<<<<<< HEAD
 +	if (m->retain_attached_hw_handler) {
++=======
+ 	if (test_bit(MPATHF_RETAIN_ATTACHED_HW_HANDLER, &m->flags)) {
+ retain:
++>>>>>>> 518257b13276 (dm mpath: switch to using bitops for state flags)
  		attached_handler_name = scsi_dh_attached_handler_name(q, GFP_KERNEL);
  		if (attached_handler_name) {
  			/*
@@@ -1585,27 -1590,26 +1609,45 @@@ static int multipath_ioctl(struct dm_ta
  	if (!m->current_pgpath)
  		__choose_pgpath(m, 0);
  
++<<<<<<< HEAD
 +	pgpath = m->current_pgpath;
 +
 +	if (pgpath) {
 +		bdev = pgpath->path.dev->bdev;
 +		mode = pgpath->path.dev->mode;
++=======
+ 	if (m->current_pgpath) {
+ 		if (!test_bit(MPATHF_QUEUE_IO, &m->flags)) {
+ 			*bdev = m->current_pgpath->path.dev->bdev;
+ 			*mode = m->current_pgpath->path.dev->mode;
+ 			r = 0;
+ 		} else {
+ 			/* pg_init has not started or completed */
+ 			r = -ENOTCONN;
+ 		}
+ 	} else {
+ 		/* No path is available */
+ 		if (test_bit(MPATHF_QUEUE_IF_NO_PATH, &m->flags))
+ 			r = -ENOTCONN;
+ 		else
+ 			r = -EIO;
++>>>>>>> 518257b13276 (dm mpath: switch to using bitops for state flags)
  	}
  
 +	if ((pgpath && m->queue_io) || (!pgpath && m->queue_if_no_path))
 +		r = -ENOTCONN;
 +	else if (!bdev)
 +		r = -EIO;
 +
  	spin_unlock_irqrestore(&m->lock, flags);
  
 -	if (r == -ENOTCONN) {
 +	/*
 +	 * Only pass ioctls through if the device sizes match exactly.
 +	 */
 +	if (!r && ti->len != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)
 +		r = scsi_verify_blk_ioctl(NULL, cmd);
 +
 +	if (r == -ENOTCONN && !fatal_signal_pending(current)) {
  		spin_lock_irqsave(&m->lock, flags);
  		if (!m->current_pg) {
  			/* Path status changed, redo selection */
* Unmerged path drivers/md/dm-mpath.c
