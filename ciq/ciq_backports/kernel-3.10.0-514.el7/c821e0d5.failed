qla2xxx: Collect PCI register checks and board_disable scheduling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Joe Lawrence <joe.lawrence@stratus.com>
commit c821e0d5b20006acdaca7aa378097a084986e37b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c821e0d5.failed

Add an uint16_t variant of qla2x00_check_reg_for_disconnect and use
these routines to check and schedule a PCI-disconnected board from a
centralized place.

	Signed-off-by: Joe Lawrence <joe.lawrence@stratus.com>
	Acked-by: Chad Dupuis <chad.dupuis@qlogic.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit c821e0d5b20006acdaca7aa378097a084986e37b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_isr.c
#	drivers/scsi/qla2xxx/qla_mr.c
#	drivers/scsi/qla2xxx/qla_nx.c
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index 4a34762f8a9c,43ef0db9654e..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -465,6 -475,8 +465,11 @@@ extern uint8_t *qla25xx_read_nvram_data
  extern int qla25xx_write_nvram_data(scsi_qla_host_t *, uint8_t *, uint32_t,
  				    uint32_t);
  extern int qla2x00_is_a_vp_did(scsi_qla_host_t *, uint32_t);
++<<<<<<< HEAD
++=======
+ bool qla2x00_check_reg32_for_disconnect(scsi_qla_host_t *, uint32_t);
+ bool qla2x00_check_reg16_for_disconnect(scsi_qla_host_t *, uint16_t);
++>>>>>>> c821e0d5b200 (qla2xxx: Collect PCI register checks and board_disable scheduling)
  
  extern int qla2x00_beacon_on(struct scsi_qla_host *);
  extern int qla2x00_beacon_off(struct scsi_qla_host *);
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index f12cf90f18f9,016ebed880f5..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -56,6 -56,8 +56,11 @@@ qla2100_intr_handler(int irq, void *dev
  	vha = pci_get_drvdata(ha->pdev);
  	for (iter = 50; iter--; ) {
  		hccr = RD_REG_WORD(&reg->hccr);
++<<<<<<< HEAD
++=======
+ 		if (qla2x00_check_reg16_for_disconnect(vha, hccr))
+ 			break;
++>>>>>>> c821e0d5b200 (qla2xxx: Collect PCI register checks and board_disable scheduling)
  		if (hccr & HCCR_RISC_PAUSE) {
  			if (pci_channel_offline(ha->pdev))
  				break;
@@@ -110,6 -112,28 +115,31 @@@
  	return (IRQ_HANDLED);
  }
  
++<<<<<<< HEAD
++=======
+ bool
+ qla2x00_check_reg32_for_disconnect(scsi_qla_host_t *vha, uint32_t reg)
+ {
+ 	/* Check for PCI disconnection */
+ 	if (reg == 0xffffffff) {
+ 		/*
+ 		 * Schedule this on the default system workqueue so that all the
+ 		 * adapter workqueues and the DPC thread can be shutdown
+ 		 * cleanly.
+ 		 */
+ 		schedule_work(&vha->hw->board_disable);
+ 		return true;
+ 	} else
+ 		return false;
+ }
+ 
+ bool
+ qla2x00_check_reg16_for_disconnect(scsi_qla_host_t *vha, uint16_t reg)
+ {
+ 	return qla2x00_check_reg32_for_disconnect(vha, 0xffff0000 | reg);
+ }
+ 
++>>>>>>> c821e0d5b200 (qla2xxx: Collect PCI register checks and board_disable scheduling)
  /**
   * qla2300_intr_handler() - Process interrupts for the ISP23xx and ISP63xx.
   * @irq:
@@@ -148,6 -172,8 +178,11 @@@ qla2300_intr_handler(int irq, void *dev
  	vha = pci_get_drvdata(ha->pdev);
  	for (iter = 50; iter--; ) {
  		stat = RD_REG_DWORD(&reg->u.isp2300.host_status);
++<<<<<<< HEAD
++=======
+ 		if (qla2x00_check_reg32_for_disconnect(vha, stat))
+ 			break;
++>>>>>>> c821e0d5b200 (qla2xxx: Collect PCI register checks and board_disable scheduling)
  		if (stat & HSR_RISC_PAUSED) {
  			if (unlikely(pci_channel_offline(ha->pdev)))
  				break;
@@@ -2659,6 -2629,8 +2694,11 @@@ qla24xx_intr_handler(int irq, void *dev
  	vha = pci_get_drvdata(ha->pdev);
  	for (iter = 50; iter--; ) {
  		stat = RD_REG_DWORD(&reg->host_status);
++<<<<<<< HEAD
++=======
+ 		if (qla2x00_check_reg32_for_disconnect(vha, stat))
+ 			break;
++>>>>>>> c821e0d5b200 (qla2xxx: Collect PCI register checks and board_disable scheduling)
  		if (stat & HSRX_RISC_PAUSED) {
  			if (unlikely(pci_channel_offline(ha->pdev)))
  				break;
@@@ -2741,6 -2714,13 +2781,16 @@@ qla24xx_msix_rsp_q(int irq, void *dev_i
  	spin_lock_irqsave(&ha->hardware_lock, flags);
  
  	vha = pci_get_drvdata(ha->pdev);
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Use host_status register to check to PCI disconnection before we
+ 	 * we process the response queue.
+ 	 */
+ 	stat = RD_REG_DWORD(&reg->host_status);
+ 	if (qla2x00_check_reg32_for_disconnect(vha, stat))
+ 		goto out;
++>>>>>>> c821e0d5b200 (qla2xxx: Collect PCI register checks and board_disable scheduling)
  	qla24xx_process_response_queue(vha, rsp);
  	if (!ha->flags.disable_msix_handshake) {
  		WRT_REG_DWORD(&reg->hccr, HCCRX_CLR_RISC_INT);
@@@ -2772,11 -2756,14 +2822,16 @@@ qla25xx_msix_rsp_q(int irq, void *dev_i
  		reg = &ha->iobase->isp24;
  		spin_lock_irqsave(&ha->hardware_lock, flags);
  		WRT_REG_DWORD(&reg->hccr, HCCRX_CLR_RISC_INT);
 -		hccr = RD_REG_DWORD_RELAXED(&reg->hccr);
 +		RD_REG_DWORD_RELAXED(&reg->hccr);
  		spin_unlock_irqrestore(&ha->hardware_lock, flags);
  	}
++<<<<<<< HEAD
++=======
+ 	if (qla2x00_check_reg32_for_disconnect(vha, hccr))
+ 		goto out;
++>>>>>>> c821e0d5b200 (qla2xxx: Collect PCI register checks and board_disable scheduling)
  	queue_work_on((int) (rsp->id - 1), ha->wq, &rsp->q_work);
  
 -out:
  	return IRQ_HANDLED;
  }
  
@@@ -2807,6 -2794,8 +2862,11 @@@ qla24xx_msix_default(int irq, void *dev
  	vha = pci_get_drvdata(ha->pdev);
  	do {
  		stat = RD_REG_DWORD(&reg->host_status);
++<<<<<<< HEAD
++=======
+ 		if (qla2x00_check_reg32_for_disconnect(vha, stat))
+ 			break;
++>>>>>>> c821e0d5b200 (qla2xxx: Collect PCI register checks and board_disable scheduling)
  		if (stat & HSRX_RISC_PAUSED) {
  			if (unlikely(pci_channel_offline(ha->pdev)))
  				break;
diff --cc drivers/scsi/qla2xxx/qla_mr.c
index 66f065e04689,8ecf6decea67..000000000000
--- a/drivers/scsi/qla2xxx/qla_mr.c
+++ b/drivers/scsi/qla2xxx/qla_mr.c
@@@ -2927,6 -2924,8 +2927,11 @@@ qlafx00_intr_handler(int irq, void *dev
  	vha = pci_get_drvdata(ha->pdev);
  	for (iter = 50; iter--; clr_intr = 0) {
  		stat = QLAFX00_RD_INTR_REG(ha);
++<<<<<<< HEAD
++=======
+ 		if (qla2x00_check_reg32_for_disconnect(vha, stat))
+ 			break;
++>>>>>>> c821e0d5b200 (qla2xxx: Collect PCI register checks and board_disable scheduling)
  		intr_stat = stat & QLAFX00_HST_INT_STS_BITS;
  		if (!intr_stat)
  			break;
diff --cc drivers/scsi/qla2xxx/qla_nx.c
index 1391432be569,25626006baff..000000000000
--- a/drivers/scsi/qla2xxx/qla_nx.c
+++ b/drivers/scsi/qla2xxx/qla_nx.c
@@@ -2121,7 -2122,10 +2121,14 @@@ qla82xx_msix_default(int irq, void *dev
  	spin_lock_irqsave(&ha->hardware_lock, flags);
  	vha = pci_get_drvdata(ha->pdev);
  	do {
++<<<<<<< HEAD
 +		if (RD_REG_DWORD(&reg->host_int)) {
++=======
+ 		host_int = RD_REG_DWORD(&reg->host_int);
+ 		if (qla2x00_check_reg32_for_disconnect(vha, host_int))
+ 			break;
+ 		if (host_int) {
++>>>>>>> c821e0d5b200 (qla2xxx: Collect PCI register checks and board_disable scheduling)
  			stat = RD_REG_DWORD(&reg->host_status);
  
  			switch (stat & 0xff) {
@@@ -2178,8 -2183,12 +2185,14 @@@ qla82xx_msix_rsp_q(int irq, void *dev_i
  	reg = &ha->iobase->isp82;
  	spin_lock_irqsave(&ha->hardware_lock, flags);
  	vha = pci_get_drvdata(ha->pdev);
++<<<<<<< HEAD
++=======
+ 	host_int = RD_REG_DWORD(&reg->host_int);
+ 	if (qla2x00_check_reg32_for_disconnect(vha, host_int))
+ 		goto out;
++>>>>>>> c821e0d5b200 (qla2xxx: Collect PCI register checks and board_disable scheduling)
  	qla24xx_process_response_queue(vha, rsp);
  	WRT_REG_DWORD(&reg->host_int, 0);
 -out:
  	spin_unlock_irqrestore(&ha->hardware_lock, flags);
  	return IRQ_HANDLED;
  }
@@@ -2208,7 -2218,10 +2221,14 @@@ qla82xx_poll(int irq, void *dev_id
  	spin_lock_irqsave(&ha->hardware_lock, flags);
  	vha = pci_get_drvdata(ha->pdev);
  
++<<<<<<< HEAD
 +	if (RD_REG_DWORD(&reg->host_int)) {
++=======
+ 	host_int = RD_REG_DWORD(&reg->host_int);
+ 	if (qla2x00_check_reg32_for_disconnect(vha, host_int))
+ 		goto out;
+ 	if (host_int) {
++>>>>>>> c821e0d5b200 (qla2xxx: Collect PCI register checks and board_disable scheduling)
  		stat = RD_REG_DWORD(&reg->host_status);
  		switch (stat & 0xff) {
  		case 0x1:
diff --cc drivers/scsi/qla2xxx/qla_os.c
index be94eef42519,3bfa89d1da75..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -5109,9 -5177,14 +5109,14 @@@ qla2x00_timer(scsi_qla_host_t *vha
  		return;
  	}
  
 -	/*
 -	 * Hardware read to raise pending EEH errors during mailbox waits. If
 -	 * the read returns -1 then disable the board.
 -	 */
 -	if (!pci_channel_offline(ha->pdev)) {
 +	/* Hardware read to raise pending EEH errors during mailbox waits. */
 +	if (!pci_channel_offline(ha->pdev))
  		pci_read_config_word(ha->pdev, PCI_VENDOR_ID, &w);
++<<<<<<< HEAD
++=======
+ 		qla2x00_check_reg16_for_disconnect(vha, w);
+ 	}
++>>>>>>> c821e0d5b200 (qla2xxx: Collect PCI register checks and board_disable scheduling)
  
  	/* Make sure qla82xx_watchdog is run only for physical port */
  	if (!vha->vp_idx && IS_P3P_TYPE(ha)) {
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
* Unmerged path drivers/scsi/qla2xxx/qla_mr.c
* Unmerged path drivers/scsi/qla2xxx/qla_nx.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
