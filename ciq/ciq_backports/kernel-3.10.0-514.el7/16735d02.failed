tree-wide: use reinit_completion instead of INIT_COMPLETION

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Wolfram Sang <wsa@the-dreams.de>
commit 16735d022f72b20ddbb2274b8e109f69575e9b2b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/16735d02.failed

Use this new function to make code more comprehensible, since we are
reinitialzing the completion, not initializing.

[akpm@linux-foundation.org: linux-next resyncs]
	Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
	Acked-by: Linus Walleij <linus.walleij@linaro.org> (personally at LCE13)
	Cc: Ingo Molnar <mingo@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 16735d022f72b20ddbb2274b8e109f69575e9b2b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/busses/i2c-wmt.c
#	drivers/iio/adc/nau7802.c
#	drivers/misc/mic/card/mic_virtio.c
#	drivers/misc/mic/host/mic_boot.c
#	drivers/net/ieee802154/mrf24j40.c
#	drivers/net/wireless/ath/ath10k/htc.c
#	drivers/net/wireless/ath/ath10k/mac.c
#	drivers/net/wireless/ath/wil6210/main.c
#	drivers/spi/spi-mpc512x-psc.c
#	drivers/spi/spi-s3c64xx.c
#	drivers/spi/spi-sirf.c
#	drivers/spi/spi-tegra114.c
#	drivers/spi/spi-tegra20-slink.c
#	drivers/spi/spi.c
#	drivers/video/omap2/displays-new/encoder-tpd12s015.c
#	sound/firewire/dice.c
diff --cc drivers/net/ieee802154/mrf24j40.c
index ede3ce4912f9,c6e46d6e9f75..000000000000
--- a/drivers/net/ieee802154/mrf24j40.c
+++ b/drivers/net/ieee802154/mrf24j40.c
@@@ -345,6 -343,8 +345,11 @@@ static int mrf24j40_tx(struct ieee80215
  	if (ret)
  		goto err;
  
++<<<<<<< HEAD
++=======
+ 	reinit_completion(&devrec->tx_complete);
+ 
++>>>>>>> 16735d022f72 (tree-wide: use reinit_completion instead of INIT_COMPLETION)
  	/* Set TXNTRIG bit of TXNCON to send packet */
  	ret = read_short_reg(devrec, REG_TXNCON, &val);
  	if (ret)
diff --cc drivers/net/wireless/ath/wil6210/main.c
index c2a238426425,fd30cddd5882..000000000000
--- a/drivers/net/wireless/ath/wil6210/main.c
+++ b/drivers/net/wireless/ath/wil6210/main.c
@@@ -747,19 -250,13 +747,23 @@@ int wil_reset(struct wil6210_priv *wil
  
  	/* init after reset */
  	wil->pending_connect_cid = -1;
++<<<<<<< HEAD
 +	wil->ap_isolate = 0;
  	reinit_completion(&wil->wmi_ready);
 +	reinit_completion(&wil->wmi_call);
++=======
++	reinit_completion(&wil->wmi_ready);
++>>>>>>> 16735d022f72 (tree-wide: use reinit_completion instead of INIT_COMPLETION)
  
 -	/* TODO: release MAC reset */
 -	wil6210_enable_irq(wil);
 +	if (load_fw) {
 +		wil_configure_interrupt_moderation(wil);
 +		wil_unmask_irq(wil);
  
 -	/* we just started MAC, wait for FW ready */
 -	rc = wil_wait_for_fw_ready(wil);
 +		/* we just started MAC, wait for FW ready */
 +		rc = wil_wait_for_fw_ready(wil);
 +		if (rc == 0) /* check FW is responsive */
 +			rc = wmi_echo(wil);
 +	}
  
  	return rc;
  }
diff --cc drivers/spi/spi-mpc512x-psc.c
index dfddf336912d,9602bbd8d7ea..000000000000
--- a/drivers/spi/spi-mpc512x-psc.c
+++ b/drivers/spi/spi-mpc512x-psc.c
@@@ -145,6 -138,186 +145,189 @@@ static int mpc512x_psc_spi_transfer_rxt
  	if (!tx_buf && !rx_buf && t->len)
  		return -EINVAL;
  
++<<<<<<< HEAD
++=======
+ 	while (rx_len || tx_len) {
+ 		size_t txcount;
+ 		u8 data;
+ 		size_t fifosz;
+ 		size_t rxcount;
+ 		int rxtries;
+ 
+ 		/*
+ 		 * send the TX bytes in as large a chunk as possible
+ 		 * but neither exceed the TX nor the RX FIFOs
+ 		 */
+ 		fifosz = MPC512x_PSC_FIFO_SZ(in_be32(&fifo->txsz));
+ 		txcount = min(fifosz, tx_len);
+ 		fifosz = MPC512x_PSC_FIFO_SZ(in_be32(&fifo->rxsz));
+ 		fifosz -= in_be32(&fifo->rxcnt) + 1;
+ 		txcount = min(fifosz, txcount);
+ 		if (txcount) {
+ 
+ 			/* fill the TX FIFO */
+ 			while (txcount-- > 0) {
+ 				data = tx_buf ? *tx_buf++ : 0;
+ 				if (tx_len == EOFBYTE && t->cs_change)
+ 					setbits32(&fifo->txcmd,
+ 						  MPC512x_PSC_FIFO_EOF);
+ 				out_8(&fifo->txdata_8, data);
+ 				tx_len--;
+ 			}
+ 
+ 			/* have the ISR trigger when the TX FIFO is empty */
+ 			reinit_completion(&mps->txisrdone);
+ 			out_be32(&fifo->txisr, MPC512x_PSC_FIFO_EMPTY);
+ 			out_be32(&fifo->tximr, MPC512x_PSC_FIFO_EMPTY);
+ 			wait_for_completion(&mps->txisrdone);
+ 		}
+ 
+ 		/*
+ 		 * consume as much RX data as the FIFO holds, while we
+ 		 * iterate over the transfer's TX data length
+ 		 *
+ 		 * only insist in draining all the remaining RX bytes
+ 		 * when the TX bytes were exhausted (that's at the very
+ 		 * end of this transfer, not when still iterating over
+ 		 * the transfer's chunks)
+ 		 */
+ 		rxtries = 50;
+ 		do {
+ 
+ 			/*
+ 			 * grab whatever was in the FIFO when we started
+ 			 * looking, don't bother fetching what was added to
+ 			 * the FIFO while we read from it -- we'll return
+ 			 * here eventually and prefer sending out remaining
+ 			 * TX data
+ 			 */
+ 			fifosz = in_be32(&fifo->rxcnt);
+ 			rxcount = min(fifosz, rx_len);
+ 			while (rxcount-- > 0) {
+ 				data = in_8(&fifo->rxdata_8);
+ 				if (rx_buf)
+ 					*rx_buf++ = data;
+ 				rx_len--;
+ 			}
+ 
+ 			/*
+ 			 * come back later if there still is TX data to send,
+ 			 * bail out of the RX drain loop if all of the TX data
+ 			 * was sent and all of the RX data was received (i.e.
+ 			 * when the transmission has completed)
+ 			 */
+ 			if (tx_len)
+ 				break;
+ 			if (!rx_len)
+ 				break;
+ 
+ 			/*
+ 			 * TX data transmission has completed while RX data
+ 			 * is still pending -- that's a transient situation
+ 			 * which depends on wire speed and specific
+ 			 * hardware implementation details (buffering) yet
+ 			 * should resolve very quickly
+ 			 *
+ 			 * just yield for a moment to not hog the CPU for
+ 			 * too long when running SPI at low speed
+ 			 *
+ 			 * the timeout range is rather arbitrary and tries
+ 			 * to balance throughput against system load; the
+ 			 * chosen values result in a minimal timeout of 50
+ 			 * times 10us and thus work at speeds as low as
+ 			 * some 20kbps, while the maximum timeout at the
+ 			 * transfer's end could be 5ms _if_ nothing else
+ 			 * ticks in the system _and_ RX data still wasn't
+ 			 * received, which only occurs in situations that
+ 			 * are exceptional; removing the unpredictability
+ 			 * of the timeout either decreases throughput
+ 			 * (longer timeouts), or puts more load on the
+ 			 * system (fixed short timeouts) or requires the
+ 			 * use of a timeout API instead of a counter and an
+ 			 * unknown inner delay
+ 			 */
+ 			usleep_range(10, 100);
+ 
+ 		} while (--rxtries > 0);
+ 		if (!tx_len && rx_len && !rxtries) {
+ 			/*
+ 			 * not enough RX bytes even after several retries
+ 			 * and the resulting rather long timeout?
+ 			 */
+ 			rxcount = in_be32(&fifo->rxcnt);
+ 			dev_warn(&spi->dev,
+ 				 "short xfer, missing %zd RX bytes, FIFO level %zd\n",
+ 				 rx_len, rxcount);
+ 		}
+ 
+ 		/*
+ 		 * drain and drop RX data which "should not be there" in
+ 		 * the first place, for undisturbed transmission this turns
+ 		 * into a NOP (except for the FIFO level fetch)
+ 		 */
+ 		if (!tx_len && !rx_len) {
+ 			while (in_be32(&fifo->rxcnt))
+ 				in_8(&fifo->rxdata_8);
+ 		}
+ 
+ 	}
+ 	return 0;
+ }
+ 
+ static int mpc512x_psc_spi_msg_xfer(struct spi_master *master,
+ 				    struct spi_message *m)
+ {
+ 	struct spi_device *spi;
+ 	unsigned cs_change;
+ 	int status;
+ 	struct spi_transfer *t;
+ 
+ 	spi = m->spi;
+ 	cs_change = 1;
+ 	status = 0;
+ 	list_for_each_entry(t, &m->transfers, transfer_list) {
+ 		if (t->bits_per_word || t->speed_hz) {
+ 			status = mpc512x_psc_spi_transfer_setup(spi, t);
+ 			if (status < 0)
+ 				break;
+ 		}
+ 
+ 		if (cs_change)
+ 			mpc512x_psc_spi_activate_cs(spi);
+ 		cs_change = t->cs_change;
+ 
+ 		status = mpc512x_psc_spi_transfer_rxtx(spi, t);
+ 		if (status)
+ 			break;
+ 		m->actual_length += t->len;
+ 
+ 		if (t->delay_usecs)
+ 			udelay(t->delay_usecs);
+ 
+ 		if (cs_change)
+ 			mpc512x_psc_spi_deactivate_cs(spi);
+ 	}
+ 
+ 	m->status = status;
+ 	m->complete(m->context);
+ 
+ 	if (status || !cs_change)
+ 		mpc512x_psc_spi_deactivate_cs(spi);
+ 
+ 	mpc512x_psc_spi_transfer_setup(spi, NULL);
+ 
+ 	spi_finalize_current_message(master);
+ 	return status;
+ }
+ 
+ static int mpc512x_psc_spi_prep_xfer_hw(struct spi_master *master)
+ {
+ 	struct mpc512x_psc_spi *mps = spi_master_get_devdata(master);
+ 	struct mpc52xx_psc __iomem *psc = mps->psc;
+ 
+ 	dev_dbg(&master->dev, "%s()\n", __func__);
+ 
++>>>>>>> 16735d022f72 (tree-wide: use reinit_completion instead of INIT_COMPLETION)
  	/* Zero MR2 */
  	in_8(&psc->mode);
  	out_8(&psc->mode, 0x0);
diff --cc drivers/spi/spi-s3c64xx.c
index 71cc3e6ef47c,4c4b0a1219a7..000000000000
--- a/drivers/spi/spi-s3c64xx.c
+++ b/drivers/spi/spi-s3c64xx.c
@@@ -834,91 -876,80 +834,95 @@@ static int s3c64xx_spi_transfer_one_mes
  	/* Configure feedback delay */
  	writel(cs->fb_delay & 0x3, sdd->regs + S3C64XX_SPI_FB_CLK);
  
 -	return 0;
 -}
 +	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
  
 -static int s3c64xx_spi_transfer_one(struct spi_master *master,
 -				    struct spi_device *spi,
 -				    struct spi_transfer *xfer)
 -{
 -	struct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);
 -	int status;
 -	u32 speed;
 -	u8 bpw;
 -	unsigned long flags;
 -	int use_dma;
 +		unsigned long flags;
 +		int use_dma;
  
++<<<<<<< HEAD
 +		INIT_COMPLETION(sdd->xfer_completion);
++=======
+ 		reinit_completion(&sdd->xfer_completion);
++>>>>>>> 16735d022f72 (tree-wide: use reinit_completion instead of INIT_COMPLETION)
  
 -	/* Only BPW and Speed may change across transfers */
 -	bpw = xfer->bits_per_word;
 -	speed = xfer->speed_hz ? : spi->max_speed_hz;
 +		/* Only BPW and Speed may change across transfers */
 +		bpw = xfer->bits_per_word;
 +		speed = xfer->speed_hz ? : spi->max_speed_hz;
  
 -	if (xfer->len % (bpw / 8)) {
 -		dev_err(&spi->dev,
 -			"Xfer length(%u) not a multiple of word size(%u)\n",
 -			xfer->len, bpw / 8);
 -		return -EIO;
 -	}
 +		if (xfer->len % (bpw / 8)) {
 +			dev_err(&spi->dev,
 +				"Xfer length(%u) not a multiple of word size(%u)\n",
 +				xfer->len, bpw / 8);
 +			status = -EIO;
 +			goto out;
 +		}
  
 -	if (bpw != sdd->cur_bpw || speed != sdd->cur_speed) {
 -		sdd->cur_bpw = bpw;
 -		sdd->cur_speed = speed;
 -		s3c64xx_spi_config(sdd);
 -	}
 +		if (bpw != sdd->cur_bpw || speed != sdd->cur_speed) {
 +			sdd->cur_bpw = bpw;
 +			sdd->cur_speed = speed;
 +			s3c64xx_spi_config(sdd);
 +		}
  
 -	/* Polling method for xfers not bigger than FIFO capacity */
 -	use_dma = 0;
 -	if (!is_polling(sdd) &&
 -	    (sdd->rx_dma.ch && sdd->tx_dma.ch &&
 -	     (xfer->len > ((FIFO_LVL_MASK(sdd) >> 1) + 1))))
 -		use_dma = 1;
 +		/* Polling method for xfers not bigger than FIFO capacity */
 +		use_dma = 0;
 +		if (sdd->rx_dma.ch && sdd->tx_dma.ch &&
 +		    (xfer->len > ((FIFO_LVL_MASK(sdd) >> 1) + 1)))
 +			use_dma = 1;
  
 -	spin_lock_irqsave(&sdd->lock, flags);
 +		spin_lock_irqsave(&sdd->lock, flags);
  
 -	/* Pending only which is to be done */
 -	sdd->state &= ~RXBUSY;
 -	sdd->state &= ~TXBUSY;
 +		/* Pending only which is to be done */
 +		sdd->state &= ~RXBUSY;
 +		sdd->state &= ~TXBUSY;
  
 -	enable_datapath(sdd, spi, xfer, use_dma);
 +		enable_datapath(sdd, spi, xfer, use_dma);
  
 -	/* Start the signals */
 -	writel(0, sdd->regs + S3C64XX_SPI_SLAVE_SEL);
 +		/* Slave Select */
 +		enable_cs(sdd, spi);
  
 -	/* Start the signals */
 -	writel(0, sdd->regs + S3C64XX_SPI_SLAVE_SEL);
 +		/* Start the signals */
 +		writel(0, sdd->regs + S3C64XX_SPI_SLAVE_SEL);
  
 -	spin_unlock_irqrestore(&sdd->lock, flags);
 +		spin_unlock_irqrestore(&sdd->lock, flags);
  
 -	status = wait_for_xfer(sdd, xfer, use_dma);
 -
 -	if (status) {
 -		dev_err(&spi->dev, "I/O Error: rx-%d tx-%d res:rx-%c tx-%c len-%d\n",
 -			xfer->rx_buf ? 1 : 0, xfer->tx_buf ? 1 : 0,
 -			(sdd->state & RXBUSY) ? 'f' : 'p',
 -			(sdd->state & TXBUSY) ? 'f' : 'p',
 -			xfer->len);
 -
 -		if (use_dma) {
 -			if (xfer->tx_buf != NULL
 -			    && (sdd->state & TXBUSY))
 -				s3c64xx_spi_dma_stop(sdd, &sdd->tx_dma);
 -			if (xfer->rx_buf != NULL
 -			    && (sdd->state & RXBUSY))
 -				s3c64xx_spi_dma_stop(sdd, &sdd->rx_dma);
 +		status = wait_for_xfer(sdd, xfer, use_dma);
 +
 +		/* Quiese the signals */
 +		writel(S3C64XX_SPI_SLAVE_SIG_INACT,
 +		       sdd->regs + S3C64XX_SPI_SLAVE_SEL);
 +
 +		if (status) {
 +			dev_err(&spi->dev, "I/O Error: rx-%d tx-%d res:rx-%c tx-%c len-%d\n",
 +				xfer->rx_buf ? 1 : 0, xfer->tx_buf ? 1 : 0,
 +				(sdd->state & RXBUSY) ? 'f' : 'p',
 +				(sdd->state & TXBUSY) ? 'f' : 'p',
 +				xfer->len);
 +
 +			if (use_dma) {
 +				if (xfer->tx_buf != NULL
 +						&& (sdd->state & TXBUSY))
 +					s3c64xx_spi_dma_stop(sdd, &sdd->tx_dma);
 +				if (xfer->rx_buf != NULL
 +						&& (sdd->state & RXBUSY))
 +					s3c64xx_spi_dma_stop(sdd, &sdd->rx_dma);
 +			}
 +
 +			goto out;
  		}
 -	} else {
 +
 +		if (xfer->delay_usecs)
 +			udelay(xfer->delay_usecs);
 +
 +		if (xfer->cs_change) {
 +			/* Hint that the next mssg is gonna be
 +			   for the same device */
 +			if (list_is_last(&xfer->transfer_list,
 +						&msg->transfers))
 +				cs_toggle = 1;
 +		}
 +
 +		msg->actual_length += xfer->len;
 +
  		flush_fifo(sdd);
  	}
  
diff --cc drivers/spi/spi-sirf.c
index 0808cd56bf8d,ed5e501c4652..000000000000
--- a/drivers/spi/spi-sirf.c
+++ b/drivers/spi/spi-sirf.c
@@@ -289,10 -302,11 +289,18 @@@ static int spi_sirfsoc_transfer(struct 
  	int timeout = t->len * 10;
  	sspi = spi_master_get_devdata(spi->master);
  
++<<<<<<< HEAD
 +	sspi->tx = t->tx_buf;
 +	sspi->rx = t->rx_buf;
 +	sspi->left_tx_cnt = sspi->left_rx_cnt = t->len;
 +	INIT_COMPLETION(sspi->done);
++=======
+ 	sspi->tx = t->tx_buf ? t->tx_buf : sspi->dummypage;
+ 	sspi->rx = t->rx_buf ? t->rx_buf : sspi->dummypage;
+ 	sspi->left_tx_word = sspi->left_rx_word = t->len / sspi->word_width;
+ 	reinit_completion(&sspi->rx_done);
+ 	reinit_completion(&sspi->tx_done);
++>>>>>>> 16735d022f72 (tree-wide: use reinit_completion instead of INIT_COMPLETION)
  
  	writel(SIRFSOC_SPI_INT_MASK_ALL, sspi->base + SIRFSOC_SPI_INT_STATUS);
  
diff --cc drivers/spi/spi-tegra114.c
index 598eb45e8008,aaecfb3ebf58..000000000000
--- a/drivers/spi/spi-tegra114.c
+++ b/drivers/spi/spi-tegra114.c
@@@ -816,19 -841,20 +816,35 @@@ static int tegra_spi_transfer_one_messa
  	msg->status = 0;
  	msg->actual_length = 0;
  
 +	ret = pm_runtime_get_sync(tspi->dev);
 +	if (ret < 0) {
 +		dev_err(tspi->dev, "runtime PM get failed: %d\n", ret);
 +		msg->status = ret;
 +		spi_finalize_current_message(master);
 +		return ret;
 +	}
 +
 +	single_xfer = list_is_singular(&msg->transfers);
  	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
++<<<<<<< HEAD
 +		INIT_COMPLETION(tspi->xfer_completion);
 +		ret = tegra_spi_start_transfer_one(spi, xfer,
 +					is_first_msg, single_xfer);
++=======
+ 		unsigned long cmd1;
+ 
+ 		reinit_completion(&tspi->xfer_completion);
+ 
+ 		cmd1 = tegra_spi_setup_transfer_one(spi, xfer, is_first_msg);
+ 
+ 		if (!xfer->len) {
+ 			ret = 0;
+ 			skip = true;
+ 			goto complete_xfer;
+ 		}
+ 
+ 		ret = tegra_spi_start_transfer_one(spi, xfer, cmd1);
++>>>>>>> 16735d022f72 (tree-wide: use reinit_completion instead of INIT_COMPLETION)
  		if (ret < 0) {
  			dev_err(tspi->dev,
  				"spi can not start transfer, err %d\n", ret);
diff --cc drivers/spi/spi-tegra20-slink.c
index 3faf88d003de,e66715ba37ed..000000000000
--- a/drivers/spi/spi-tegra20-slink.c
+++ b/drivers/spi/spi-tegra20-slink.c
@@@ -824,65 -803,72 +824,70 @@@ static int tegra_slink_setup(struct spi
  	return 0;
  }
  
 -static int tegra_slink_prepare_message(struct spi_master *master,
 -				       struct spi_message *msg)
 +static int tegra_slink_transfer_one_message(struct spi_master *master,
 +			struct spi_message *msg)
  {
 +	bool is_first_msg = true;
 +	int single_xfer;
  	struct tegra_slink_data *tspi = spi_master_get_devdata(master);
 +	struct spi_transfer *xfer;
  	struct spi_device *spi = msg->spi;
 -
 -	tegra_slink_clear_status(tspi);
 -
 -	tspi->command_reg = tspi->def_command_reg;
 -	tspi->command_reg |= SLINK_CS_SW | SLINK_CS_VALUE;
 -
 -	tspi->command2_reg = tspi->def_command2_reg;
 -	tspi->command2_reg |= SLINK_SS_EN_CS(spi->chip_select);
 -
 -	tspi->command_reg &= ~SLINK_MODES;
 -	if (spi->mode & SPI_CPHA)
 -		tspi->command_reg |= SLINK_CK_SDA;
 -
 -	if (spi->mode & SPI_CPOL)
 -		tspi->command_reg |= SLINK_IDLE_SCLK_DRIVE_HIGH;
 -	else
 -		tspi->command_reg |= SLINK_IDLE_SCLK_DRIVE_LOW;
 -
 -	return 0;
 -}
 -
 -static int tegra_slink_transfer_one(struct spi_master *master,
 -				    struct spi_device *spi,
 -				    struct spi_transfer *xfer)
 -{
 -	struct tegra_slink_data *tspi = spi_master_get_devdata(master);
  	int ret;
  
++<<<<<<< HEAD
 +	msg->status = 0;
 +	msg->actual_length = 0;
 +	ret = pm_runtime_get_sync(tspi->dev);
++=======
+ 	reinit_completion(&tspi->xfer_completion);
+ 	ret = tegra_slink_start_transfer_one(spi, xfer);
++>>>>>>> 16735d022f72 (tree-wide: use reinit_completion instead of INIT_COMPLETION)
  	if (ret < 0) {
 -		dev_err(tspi->dev,
 -			"spi can not start transfer, err %d\n", ret);
 -		return ret;
 +		dev_err(tspi->dev, "runtime get failed: %d\n", ret);
 +		goto done;
  	}
  
 -	ret = wait_for_completion_timeout(&tspi->xfer_completion,
 -					  SLINK_DMA_TIMEOUT);
 -	if (WARN_ON(ret == 0)) {
 -		dev_err(tspi->dev,
 -			"spi trasfer timeout, err %d\n", ret);
 -		return -EIO;
 -	}
 -
 -	if (tspi->tx_status)
 -		return tspi->tx_status;
 -	if (tspi->rx_status)
 -		return tspi->rx_status;
 -
 -	return 0;
 -}
 -
 -static int tegra_slink_unprepare_message(struct spi_master *master,
 -					 struct spi_message *msg)
 -{
 -	struct tegra_slink_data *tspi = spi_master_get_devdata(master);
 +	single_xfer = list_is_singular(&msg->transfers);
 +	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 +		INIT_COMPLETION(tspi->xfer_completion);
 +		ret = tegra_slink_start_transfer_one(spi, xfer,
 +					is_first_msg, single_xfer);
 +		if (ret < 0) {
 +			dev_err(tspi->dev,
 +				"spi can not start transfer, err %d\n", ret);
 +			goto exit;
 +		}
 +		is_first_msg = false;
 +		ret = wait_for_completion_timeout(&tspi->xfer_completion,
 +						SLINK_DMA_TIMEOUT);
 +		if (WARN_ON(ret == 0)) {
 +			dev_err(tspi->dev,
 +				"spi trasfer timeout, err %d\n", ret);
 +			ret = -EIO;
 +			goto exit;
 +		}
  
 +		if (tspi->tx_status ||  tspi->rx_status) {
 +			dev_err(tspi->dev, "Error in Transfer\n");
 +			ret = -EIO;
 +			goto exit;
 +		}
 +		msg->actual_length += xfer->len;
 +		if (xfer->cs_change && xfer->delay_usecs) {
 +			tegra_slink_writel(tspi, tspi->def_command_reg,
 +					SLINK_COMMAND);
 +			udelay(xfer->delay_usecs);
 +		}
 +	}
 +	ret = 0;
 +exit:
  	tegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);
  	tegra_slink_writel(tspi, tspi->def_command2_reg, SLINK_COMMAND2);
 -
 -	return 0;
 +	pm_runtime_put(tspi->dev);
 +done:
 +	msg->status = ret;
 +	spi_finalize_current_message(master);
 +	return ret;
  }
  
  static irqreturn_t handle_cpu_based_xfer(struct tegra_slink_data *tspi)
diff --cc drivers/spi/spi.c
index bff6fccdf1f3,8d85ddc46011..000000000000
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@@ -523,6 -540,95 +523,98 @@@ int spi_register_board_info(struct spi_
  
  /*-------------------------------------------------------------------------*/
  
++<<<<<<< HEAD
++=======
+ static void spi_set_cs(struct spi_device *spi, bool enable)
+ {
+ 	if (spi->mode & SPI_CS_HIGH)
+ 		enable = !enable;
+ 
+ 	if (spi->cs_gpio >= 0)
+ 		gpio_set_value(spi->cs_gpio, !enable);
+ 	else if (spi->master->set_cs)
+ 		spi->master->set_cs(spi, !enable);
+ }
+ 
+ /*
+  * spi_transfer_one_message - Default implementation of transfer_one_message()
+  *
+  * This is a standard implementation of transfer_one_message() for
+  * drivers which impelment a transfer_one() operation.  It provides
+  * standard handling of delays and chip select management.
+  */
+ static int spi_transfer_one_message(struct spi_master *master,
+ 				    struct spi_message *msg)
+ {
+ 	struct spi_transfer *xfer;
+ 	bool cur_cs = true;
+ 	bool keep_cs = false;
+ 	int ret = 0;
+ 
+ 	spi_set_cs(msg->spi, true);
+ 
+ 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+ 		trace_spi_transfer_start(msg, xfer);
+ 
+ 		reinit_completion(&master->xfer_completion);
+ 
+ 		ret = master->transfer_one(master, msg->spi, xfer);
+ 		if (ret < 0) {
+ 			dev_err(&msg->spi->dev,
+ 				"SPI transfer failed: %d\n", ret);
+ 			goto out;
+ 		}
+ 
+ 		if (ret > 0)
+ 			wait_for_completion(&master->xfer_completion);
+ 
+ 		trace_spi_transfer_stop(msg, xfer);
+ 
+ 		if (msg->status != -EINPROGRESS)
+ 			goto out;
+ 
+ 		if (xfer->delay_usecs)
+ 			udelay(xfer->delay_usecs);
+ 
+ 		if (xfer->cs_change) {
+ 			if (list_is_last(&xfer->transfer_list,
+ 					 &msg->transfers)) {
+ 				keep_cs = true;
+ 			} else {
+ 				cur_cs = !cur_cs;
+ 				spi_set_cs(msg->spi, cur_cs);
+ 			}
+ 		}
+ 
+ 		msg->actual_length += xfer->len;
+ 	}
+ 
+ out:
+ 	if (ret != 0 || !keep_cs)
+ 		spi_set_cs(msg->spi, false);
+ 
+ 	if (msg->status == -EINPROGRESS)
+ 		msg->status = ret;
+ 
+ 	spi_finalize_current_message(master);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * spi_finalize_current_transfer - report completion of a transfer
+  *
+  * Called by SPI drivers using the core transfer_one_message()
+  * implementation to notify it that the current interrupt driven
+  * transfer has finised and the next one may be scheduled.
+  */
+ void spi_finalize_current_transfer(struct spi_master *master)
+ {
+ 	complete(&master->xfer_completion);
+ }
+ EXPORT_SYMBOL_GPL(spi_finalize_current_transfer);
+ 
++>>>>>>> 16735d022f72 (tree-wide: use reinit_completion instead of INIT_COMPLETION)
  /**
   * spi_pump_messages - kthread work function which processes spi message queue
   * @work: pointer to kthread work struct contained in the master struct
* Unmerged path drivers/i2c/busses/i2c-wmt.c
* Unmerged path drivers/iio/adc/nau7802.c
* Unmerged path drivers/misc/mic/card/mic_virtio.c
* Unmerged path drivers/misc/mic/host/mic_boot.c
* Unmerged path drivers/net/wireless/ath/ath10k/htc.c
* Unmerged path drivers/net/wireless/ath/ath10k/mac.c
* Unmerged path drivers/video/omap2/displays-new/encoder-tpd12s015.c
* Unmerged path sound/firewire/dice.c
diff --git a/arch/arm/mach-tegra/apbio.c b/arch/arm/mach-tegra/apbio.c
index d7aa52ea6cfc..bc471973cf04 100644
--- a/arch/arm/mach-tegra/apbio.c
+++ b/arch/arm/mach-tegra/apbio.c
@@ -114,7 +114,7 @@ static int do_dma_transfer(unsigned long apb_add,
 	dma_desc->callback = apb_dma_complete;
 	dma_desc->callback_param = NULL;
 
-	INIT_COMPLETION(tegra_apb_wait);
+	reinit_completion(&tegra_apb_wait);
 
 	dmaengine_submit(dma_desc);
 	dma_async_issue_pending(tegra_apb_dma_chan);
diff --git a/arch/powerpc/platforms/powermac/low_i2c.c b/arch/powerpc/platforms/powermac/low_i2c.c
index fc536f2971c0..7553b6a77c64 100644
--- a/arch/powerpc/platforms/powermac/low_i2c.c
+++ b/arch/powerpc/platforms/powermac/low_i2c.c
@@ -452,7 +452,7 @@ static int kw_i2c_xfer(struct pmac_i2c_bus *bus, u8 addrdir, int subsize,
 	 */
 	if (use_irq) {
 		/* Clear completion */
-		INIT_COMPLETION(host->complete);
+		reinit_completion(&host->complete);
 		/* Ack stale interrupts */
 		kw_write_reg(reg_isr, kw_read_reg(reg_isr));
 		/* Arm timeout */
@@ -717,7 +717,7 @@ static int pmu_i2c_xfer(struct pmac_i2c_bus *bus, u8 addrdir, int subsize,
 			return -EINVAL;
 		}
 
-		INIT_COMPLETION(comp);
+		reinit_completion(&comp);
 		req->data[0] = PMU_I2C_CMD;
 		req->reply[0] = 0xff;
 		req->nbytes = sizeof(struct pmu_i2c_hdr) + 1;
@@ -748,7 +748,7 @@ static int pmu_i2c_xfer(struct pmac_i2c_bus *bus, u8 addrdir, int subsize,
 
 		hdr->bus = PMU_I2C_BUS_STATUS;
 
-		INIT_COMPLETION(comp);
+		reinit_completion(&comp);
 		req->data[0] = PMU_I2C_CMD;
 		req->reply[0] = 0xff;
 		req->nbytes = 2;
diff --git a/arch/powerpc/platforms/pseries/suspend.c b/arch/powerpc/platforms/pseries/suspend.c
index 3cb4c7f32c0e..b87b97849d4c 100644
--- a/arch/powerpc/platforms/pseries/suspend.c
+++ b/arch/powerpc/platforms/pseries/suspend.c
@@ -124,7 +124,7 @@ static int pseries_prepare_late(void)
 	atomic_set(&suspend_data.done, 0);
 	atomic_set(&suspend_data.error, 0);
 	suspend_data.complete = &suspend_work;
-	INIT_COMPLETION(suspend_work);
+	reinit_completion(&suspend_work);
 	return 0;
 }
 
diff --git a/crypto/af_alg.c b/crypto/af_alg.c
index bf948e134981..6a3ad8011585 100644
--- a/crypto/af_alg.c
+++ b/crypto/af_alg.c
@@ -436,7 +436,7 @@ int af_alg_wait_for_completion(int err, struct af_alg_completion *completion)
 	case -EINPROGRESS:
 	case -EBUSY:
 		wait_for_completion(&completion->completion);
-		INIT_COMPLETION(completion->completion);
+		reinit_completion(&completion->completion);
 		err = completion->err;
 		break;
 	};
diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
index 25a5934f0e50..1ab8258fcf56 100644
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -493,7 +493,7 @@ static inline int do_one_ahash_op(struct ahash_request *req, int ret)
 		ret = wait_for_completion_interruptible(&tr->completion);
 		if (!ret)
 			ret = tr->err;
-		INIT_COMPLETION(tr->completion);
+		reinit_completion(&tr->completion);
 	}
 	return ret;
 }
@@ -721,7 +721,7 @@ static inline int do_one_acipher_op(struct ablkcipher_request *req, int ret)
 		ret = wait_for_completion_interruptible(&tr->completion);
 		if (!ret)
 			ret = tr->err;
-		INIT_COMPLETION(tr->completion);
+		reinit_completion(&tr->completion);
 	}
 
 	return ret;
diff --git a/crypto/testmgr.c b/crypto/testmgr.c
index 2fb2f95f3e72..027e942de73f 100644
--- a/crypto/testmgr.c
+++ b/crypto/testmgr.c
@@ -186,7 +186,7 @@ static int do_one_async_hash_op(struct ahash_request *req,
 		ret = wait_for_completion_interruptible(&tr->completion);
 		if (!ret)
 			ret = tr->err;
-		INIT_COMPLETION(tr->completion);
+		reinit_completion(&tr->completion);
 	}
 	return ret;
 }
@@ -333,7 +333,7 @@ static int test_hash(struct crypto_ahash *tfm, struct hash_testvec *template,
 				ret = wait_for_completion_interruptible(
 					&tresult.completion);
 				if (!ret && !(ret = tresult.err)) {
-					INIT_COMPLETION(tresult.completion);
+					reinit_completion(&tresult.completion);
 					break;
 				}
 				/* fall through */
@@ -511,7 +511,7 @@ static int __test_aead(struct crypto_aead *tfm, int enc,
 				ret = wait_for_completion_interruptible(
 					&result.completion);
 				if (!ret && !(ret = result.err)) {
-					INIT_COMPLETION(result.completion);
+					reinit_completion(&result.completion);
 					break;
 				}
 			case -EBADMSG:
@@ -661,7 +661,7 @@ static int __test_aead(struct crypto_aead *tfm, int enc,
 				ret = wait_for_completion_interruptible(
 					&result.completion);
 				if (!ret && !(ret = result.err)) {
-					INIT_COMPLETION(result.completion);
+					reinit_completion(&result.completion);
 					break;
 				}
 			case -EBADMSG:
@@ -925,7 +925,7 @@ static int __test_skcipher(struct crypto_ablkcipher *tfm, int enc,
 				ret = wait_for_completion_interruptible(
 					&result.completion);
 				if (!ret && !((ret = result.err))) {
-					INIT_COMPLETION(result.completion);
+					reinit_completion(&result.completion);
 					break;
 				}
 				/* fall through */
@@ -1025,7 +1025,7 @@ static int __test_skcipher(struct crypto_ablkcipher *tfm, int enc,
 				ret = wait_for_completion_interruptible(
 					&result.completion);
 				if (!ret && !((ret = result.err))) {
-					INIT_COMPLETION(result.completion);
+					reinit_completion(&result.completion);
 					break;
 				}
 				/* fall through */
diff --git a/drivers/ata/libata-eh.c b/drivers/ata/libata-eh.c
index e326202d1de9..4973810ee483 100644
--- a/drivers/ata/libata-eh.c
+++ b/drivers/ata/libata-eh.c
@@ -3015,7 +3015,7 @@ static inline void ata_eh_pull_park_action(struct ata_port *ap)
 	 * ourselves at the beginning of each pass over the loop.
 	 *
 	 * Additionally, all write accesses to &ap->park_req_pending
-	 * through INIT_COMPLETION() (see below) or complete_all()
+	 * through reinit_completion() (see below) or complete_all()
 	 * (see ata_scsi_park_store()) are protected by the host lock.
 	 * As a result we have that park_req_pending.done is zero on
 	 * exit from this function, i.e. when ATA_EH_PARK actions for
@@ -3029,7 +3029,7 @@ static inline void ata_eh_pull_park_action(struct ata_port *ap)
 	 */
 
 	spin_lock_irqsave(ap->lock, flags);
-	INIT_COMPLETION(ap->park_req_pending);
+	reinit_completion(&ap->park_req_pending);
 	ata_for_each_link(link, ap, EDGE) {
 		ata_for_each_dev(dev, link, ALL) {
 			struct ata_eh_info *ehi = &link->eh_info;
diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index a37dac9fb45c..113d0ce615c7 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -682,7 +682,7 @@ void dpm_resume(pm_message_t state)
 	async_error = 0;
 
 	list_for_each_entry(dev, &dpm_suspended_list, power.entry) {
-		INIT_COMPLETION(dev->power.completion);
+		reinit_completion(&dev->power.completion);
 		if (is_async(dev)) {
 			get_device(dev);
 			async_schedule(async_resume, dev);
@@ -1158,7 +1158,7 @@ static void async_suspend(void *data, async_cookie_t cookie)
 
 static int device_suspend(struct device *dev)
 {
-	INIT_COMPLETION(dev->power.completion);
+	reinit_completion(&dev->power.completion);
 
 	if (pm_async_enabled && dev->power.async_suspend) {
 		get_device(dev);
diff --git a/drivers/block/amiflop.c b/drivers/block/amiflop.c
index 4ff85b8785ee..748dea4f34dc 100644
--- a/drivers/block/amiflop.c
+++ b/drivers/block/amiflop.c
@@ -343,7 +343,7 @@ static int fd_motor_on(int nr)
 		unit[nr].motor = 1;
 		fd_select(nr);
 
-		INIT_COMPLETION(motor_on_completion);
+		reinit_completion(&motor_on_completion);
 		motor_on_timer.data = nr;
 		mod_timer(&motor_on_timer, jiffies + HZ/2);
 
diff --git a/drivers/block/cciss.c b/drivers/block/cciss.c
index 90a4e6b940ac..b3a5836f143e 100644
--- a/drivers/block/cciss.c
+++ b/drivers/block/cciss.c
@@ -2808,7 +2808,7 @@ resend_cmd2:
 		/* erase the old error information */
 		memset(c->err_info, 0, sizeof(ErrorInfo_struct));
 		return_status = IO_OK;
-		INIT_COMPLETION(wait);
+		reinit_completion(&wait);
 		goto resend_cmd2;
 	}
 
@@ -3669,7 +3669,7 @@ static int add_to_scan_list(struct ctlr_info *h)
 		}
 	}
 	if (!found && !h->busy_scanning) {
-		INIT_COMPLETION(h->scan_wait);
+		reinit_completion(&h->scan_wait);
 		list_add_tail(&h->scan_list, &scan_q);
 		ret = 1;
 	}
diff --git a/drivers/char/hw_random/timeriomem-rng.c b/drivers/char/hw_random/timeriomem-rng.c
index 3e75737f5fe1..019b0681f3db 100644
--- a/drivers/char/hw_random/timeriomem-rng.c
+++ b/drivers/char/hw_random/timeriomem-rng.c
@@ -79,7 +79,7 @@ static int timeriomem_rng_data_read(struct hwrng *rng, u32 *data)
 	priv->expires = cur + delay;
 	priv->present = 0;
 
-	INIT_COMPLETION(priv->completion);
+	reinit_completion(&priv->completion);
 	mod_timer(&priv->timer, priv->expires);
 
 	return 4;
diff --git a/drivers/crypto/tegra-aes.c b/drivers/crypto/tegra-aes.c
index 85ea7525fa36..14d95c0c03c9 100644
--- a/drivers/crypto/tegra-aes.c
+++ b/drivers/crypto/tegra-aes.c
@@ -268,7 +268,7 @@ static int aes_start_crypt(struct tegra_aes_dev *dd, u32 in_addr, u32 out_addr,
 	aes_writel(dd, value, TEGRA_AES_SECURE_INPUT_SELECT);
 
 	aes_writel(dd, out_addr, TEGRA_AES_SECURE_DEST_ADDR);
-	INIT_COMPLETION(dd->op_complete);
+	reinit_completion(&dd->op_complete);
 
 	for (i = 0; i < AES_HW_MAX_ICQ_LENGTH - 1; i++) {
 		do {
diff --git a/drivers/firewire/core-transaction.c b/drivers/firewire/core-transaction.c
index 28a94c7ec6e5..d3f8356640df 100644
--- a/drivers/firewire/core-transaction.c
+++ b/drivers/firewire/core-transaction.c
@@ -477,7 +477,7 @@ void fw_send_phy_config(struct fw_card *card,
 	phy_config_packet.header[1] = data;
 	phy_config_packet.header[2] = ~data;
 	phy_config_packet.generation = generation;
-	INIT_COMPLETION(phy_config_done);
+	reinit_completion(&phy_config_done);
 
 	card->driver->send_request(card, &phy_config_packet);
 	wait_for_completion_timeout(&phy_config_done, timeout);
diff --git a/drivers/hid/hid-wiimote.h b/drivers/hid/hid-wiimote.h
index c81dbeb086c5..9064368e389e 100644
--- a/drivers/hid/hid-wiimote.h
+++ b/drivers/hid/hid-wiimote.h
@@ -182,7 +182,7 @@ static inline int wiimote_cmd_acquire(struct wiimote_data *wdata)
 static inline void wiimote_cmd_set(struct wiimote_data *wdata, int cmd,
 								__u32 opt)
 {
-	INIT_COMPLETION(wdata->state.ready);
+	reinit_completion(&wdata->state.ready);
 	wdata->state.cmd = cmd;
 	wdata->state.opt = opt;
 }
diff --git a/drivers/hwmon/jz4740-hwmon.c b/drivers/hwmon/jz4740-hwmon.c
index e0d66b9590ab..a183e488db78 100644
--- a/drivers/hwmon/jz4740-hwmon.c
+++ b/drivers/hwmon/jz4740-hwmon.c
@@ -66,7 +66,7 @@ static ssize_t jz4740_hwmon_read_adcin(struct device *dev,
 
 	mutex_lock(&hwmon->lock);
 
-	INIT_COMPLETION(*completion);
+	reinit_completion(completion);
 
 	enable_irq(hwmon->irq);
 	hwmon->cell->enable(to_platform_device(dev));
diff --git a/drivers/i2c/busses/i2c-at91.c b/drivers/i2c/busses/i2c-at91.c
index fd059308affa..8edba9de76df 100644
--- a/drivers/i2c/busses/i2c-at91.c
+++ b/drivers/i2c/busses/i2c-at91.c
@@ -371,7 +371,7 @@ static int at91_do_twi_transfer(struct at91_twi_dev *dev)
 	dev_dbg(dev->dev, "transfer: %s %d bytes.\n",
 		(dev->msg->flags & I2C_M_RD) ? "read" : "write", dev->buf_len);
 
-	INIT_COMPLETION(dev->cmd_complete);
+	reinit_completion(&dev->cmd_complete);
 	dev->transfer_status = 0;
 
 	if (!dev->buf_len) {
diff --git a/drivers/i2c/busses/i2c-bcm2835.c b/drivers/i2c/busses/i2c-bcm2835.c
index ea4b08fc3353..d7e8600f31fb 100644
--- a/drivers/i2c/busses/i2c-bcm2835.c
+++ b/drivers/i2c/busses/i2c-bcm2835.c
@@ -151,7 +151,7 @@ static int bcm2835_i2c_xfer_msg(struct bcm2835_i2c_dev *i2c_dev,
 
 	i2c_dev->msg_buf = msg->buf;
 	i2c_dev->msg_buf_remaining = msg->len;
-	INIT_COMPLETION(i2c_dev->completion);
+	reinit_completion(&i2c_dev->completion);
 
 	bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C, BCM2835_I2C_C_CLEAR);
 
diff --git a/drivers/i2c/busses/i2c-davinci.c b/drivers/i2c/busses/i2c-davinci.c
index 4ab4259e57d8..b3bd5f54d8ef 100644
--- a/drivers/i2c/busses/i2c-davinci.c
+++ b/drivers/i2c/busses/i2c-davinci.c
@@ -325,7 +325,7 @@ i2c_davinci_xfer_msg(struct i2c_adapter *adap, struct i2c_msg *msg, int stop)
 
 	davinci_i2c_write_reg(dev, DAVINCI_I2C_CNT_REG, dev->buf_len);
 
-	INIT_COMPLETION(dev->cmd_complete);
+	reinit_completion(&dev->cmd_complete);
 	dev->cmd_err = 0;
 
 	/* Take I2C out of reset and configure it as master */
diff --git a/drivers/i2c/busses/i2c-designware-core.c b/drivers/i2c/busses/i2c-designware-core.c
index bc5abe76f91f..c776669b490f 100644
--- a/drivers/i2c/busses/i2c-designware-core.c
+++ b/drivers/i2c/busses/i2c-designware-core.c
@@ -560,7 +560,7 @@ i2c_dw_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
 	mutex_lock(&dev->lock);
 	pm_runtime_get_sync(dev->dev);
 
-	INIT_COMPLETION(dev->cmd_complete);
+	reinit_completion(&dev->cmd_complete);
 	dev->msgs = msgs;
 	dev->msgs_num = num;
 	dev->cmd_err = 0;
diff --git a/drivers/i2c/busses/i2c-ismt.c b/drivers/i2c/busses/i2c-ismt.c
index 018c9f7b61e5..3b2f19292c15 100644
--- a/drivers/i2c/busses/i2c-ismt.c
+++ b/drivers/i2c/busses/i2c-ismt.c
@@ -577,7 +577,7 @@ static int ismt_access(struct i2c_adapter *adap, u16 addr,
 		desc->dptr_high = upper_32_bits(dma_addr);
 	}
 
-	INIT_COMPLETION(priv->cmp);
+	reinit_completion(&priv->cmp);
 
 	/* Add the descriptor */
 	ismt_submit_desc(priv);
diff --git a/drivers/i2c/busses/i2c-mxs.c b/drivers/i2c/busses/i2c-mxs.c
index a37160671d32..f31e84a8f939 100644
--- a/drivers/i2c/busses/i2c-mxs.c
+++ b/drivers/i2c/busses/i2c-mxs.c
@@ -498,7 +498,7 @@ static int mxs_i2c_xfer_msg(struct i2c_adapter *adap, struct i2c_msg *msg,
 		if (ret)
 			mxs_i2c_reset(i2c);
 	} else {
-		INIT_COMPLETION(i2c->cmd_complete);
+		reinit_completion(&i2c->cmd_complete);
 		ret = mxs_i2c_dma_setup_xfer(adap, msg, flags);
 		if (ret)
 			return ret;
diff --git a/drivers/i2c/busses/i2c-omap.c b/drivers/i2c/busses/i2c-omap.c
index 329688307871..6cbb62fdc4ef 100644
--- a/drivers/i2c/busses/i2c-omap.c
+++ b/drivers/i2c/busses/i2c-omap.c
@@ -543,7 +543,7 @@ static int omap_i2c_xfer_msg(struct i2c_adapter *adap,
 	w |= OMAP_I2C_BUF_RXFIF_CLR | OMAP_I2C_BUF_TXFIF_CLR;
 	omap_i2c_write_reg(dev, OMAP_I2C_BUF_REG, w);
 
-	INIT_COMPLETION(dev->cmd_complete);
+	reinit_completion(&dev->cmd_complete);
 	dev->cmd_err = 0;
 
 	w = OMAP_I2C_CON_EN | OMAP_I2C_CON_MST | OMAP_I2C_CON_STT;
diff --git a/drivers/i2c/busses/i2c-tegra.c b/drivers/i2c/busses/i2c-tegra.c
index c457cb447c66..e661edee4d0c 100644
--- a/drivers/i2c/busses/i2c-tegra.c
+++ b/drivers/i2c/busses/i2c-tegra.c
@@ -544,7 +544,7 @@ static int tegra_i2c_xfer_msg(struct tegra_i2c_dev *i2c_dev,
 	i2c_dev->msg_buf_remaining = msg->len;
 	i2c_dev->msg_err = I2C_ERR_NONE;
 	i2c_dev->msg_read = (msg->flags & I2C_M_RD);
-	INIT_COMPLETION(i2c_dev->msg_complete);
+	reinit_completion(&i2c_dev->msg_complete);
 
 	packet_header = (0 << PACKET_HEADER0_HEADER_SIZE_SHIFT) |
 			PACKET_HEADER0_PROTOCOL_I2C |
* Unmerged path drivers/i2c/busses/i2c-wmt.c
diff --git a/drivers/iio/adc/ad_sigma_delta.c b/drivers/iio/adc/ad_sigma_delta.c
index f0d6335ae087..e766bf72fe9c 100644
--- a/drivers/iio/adc/ad_sigma_delta.c
+++ b/drivers/iio/adc/ad_sigma_delta.c
@@ -188,7 +188,7 @@ static int ad_sd_calibrate(struct ad_sigma_delta *sigma_delta,
 
 	spi_bus_lock(sigma_delta->spi->master);
 	sigma_delta->bus_locked = true;
-	INIT_COMPLETION(sigma_delta->completion);
+	reinit_completion(&sigma_delta->completion);
 
 	ret = ad_sigma_delta_set_mode(sigma_delta, mode);
 	if (ret < 0)
@@ -259,7 +259,7 @@ int ad_sigma_delta_single_conversion(struct iio_dev *indio_dev,
 
 	spi_bus_lock(sigma_delta->spi->master);
 	sigma_delta->bus_locked = true;
-	INIT_COMPLETION(sigma_delta->completion);
+	reinit_completion(&sigma_delta->completion);
 
 	ad_sigma_delta_set_mode(sigma_delta, AD_SD_MODE_SINGLE);
 
@@ -343,7 +343,7 @@ static int ad_sd_buffer_postdisable(struct iio_dev *indio_dev)
 {
 	struct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);
 
-	INIT_COMPLETION(sigma_delta->completion);
+	reinit_completion(&sigma_delta->completion);
 	wait_for_completion_timeout(&sigma_delta->completion, HZ);
 
 	if (!sigma_delta->irq_dis) {
* Unmerged path drivers/iio/adc/nau7802.c
diff --git a/drivers/input/touchscreen/cyttsp_core.c b/drivers/input/touchscreen/cyttsp_core.c
index ae89d2609ab0..6e928f29dfea 100644
--- a/drivers/input/touchscreen/cyttsp_core.c
+++ b/drivers/input/touchscreen/cyttsp_core.c
@@ -240,7 +240,7 @@ static int cyttsp_soft_reset(struct cyttsp *ts)
 	int retval;
 
 	/* wait for interrupt to set ready completion */
-	INIT_COMPLETION(ts->bl_ready);
+	reinit_completion(&ts->bl_ready);
 	ts->state = CY_BL_STATE;
 
 	enable_irq(ts->irq);
diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c
index f717762864fc..34844e5c63c7 100644
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@ -945,7 +945,7 @@ static int crypt_convert(struct crypt_config *cc,
 		/* async */
 		case -EBUSY:
 			wait_for_completion(&ctx->restart);
-			INIT_COMPLETION(ctx->restart);
+			reinit_completion(&ctx->restart);
 			/* fall through*/
 		case -EINPROGRESS:
 			ctx->req = NULL;
diff --git a/drivers/media/platform/blackfin/bfin_capture.c b/drivers/media/platform/blackfin/bfin_capture.c
index 0e55b087076f..195f76bd6c2b 100644
--- a/drivers/media/platform/blackfin/bfin_capture.c
+++ b/drivers/media/platform/blackfin/bfin_capture.c
@@ -428,7 +428,7 @@ static int bcap_start_streaming(struct vb2_queue *vq, unsigned int count)
 		return ret;
 	}
 
-	INIT_COMPLETION(bcap_dev->comp);
+	reinit_completion(&bcap_dev->comp);
 	bcap_dev->stop = false;
 	return 0;
 }
diff --git a/drivers/media/radio/radio-wl1273.c b/drivers/media/radio/radio-wl1273.c
index 97c2c18803ef..9cf6731fb816 100644
--- a/drivers/media/radio/radio-wl1273.c
+++ b/drivers/media/radio/radio-wl1273.c
@@ -375,7 +375,7 @@ static int wl1273_fm_set_tx_freq(struct wl1273_device *radio, unsigned int freq)
 	if (r)
 		return r;
 
-	INIT_COMPLETION(radio->busy);
+	reinit_completion(&radio->busy);
 
 	/* wait for the FR IRQ */
 	r = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(2000));
@@ -389,7 +389,7 @@ static int wl1273_fm_set_tx_freq(struct wl1273_device *radio, unsigned int freq)
 	if (r)
 		return r;
 
-	INIT_COMPLETION(radio->busy);
+	reinit_completion(&radio->busy);
 
 	/* wait for the POWER_ENB IRQ */
 	r = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(1000));
@@ -444,7 +444,7 @@ static int wl1273_fm_set_rx_freq(struct wl1273_device *radio, unsigned int freq)
 		goto err;
 	}
 
-	INIT_COMPLETION(radio->busy);
+	reinit_completion(&radio->busy);
 
 	r = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(2000));
 	if (!r) {
@@ -805,7 +805,7 @@ static int wl1273_fm_set_seek(struct wl1273_device *radio,
 	if (level < SCHAR_MIN || level > SCHAR_MAX)
 		return -EINVAL;
 
-	INIT_COMPLETION(radio->busy);
+	reinit_completion(&radio->busy);
 	dev_dbg(radio->dev, "%s: BUSY\n", __func__);
 
 	r = core->write(core, WL1273_INT_MASK_SET, radio->irq_flags);
@@ -847,7 +847,7 @@ static int wl1273_fm_set_seek(struct wl1273_device *radio,
 	if (r)
 		goto out;
 
-	INIT_COMPLETION(radio->busy);
+	reinit_completion(&radio->busy);
 	dev_dbg(radio->dev, "%s: BUSY\n", __func__);
 
 	r = core->write(core, WL1273_TUNER_MODE_SET, TUNER_MODE_AUTO_SEEK);
diff --git a/drivers/media/radio/si470x/radio-si470x-common.c b/drivers/media/radio/si470x/radio-si470x-common.c
index 5c57e5b0f949..0bd250068285 100644
--- a/drivers/media/radio/si470x/radio-si470x-common.c
+++ b/drivers/media/radio/si470x/radio-si470x-common.c
@@ -218,7 +218,7 @@ static int si470x_set_chan(struct si470x_device *radio, unsigned short chan)
 		goto done;
 
 	/* wait till tune operation has completed */
-	INIT_COMPLETION(radio->completion);
+	reinit_completion(&radio->completion);
 	retval = wait_for_completion_timeout(&radio->completion,
 			msecs_to_jiffies(tune_timeout));
 	if (!retval)
@@ -341,7 +341,7 @@ static int si470x_set_seek(struct si470x_device *radio,
 		return retval;
 
 	/* wait till tune operation has completed */
-	INIT_COMPLETION(radio->completion);
+	reinit_completion(&radio->completion);
 	retval = wait_for_completion_timeout(&radio->completion,
 			msecs_to_jiffies(seek_timeout));
 	if (!retval)
diff --git a/drivers/media/rc/iguanair.c b/drivers/media/rc/iguanair.c
index a4ab2e6b3f82..bd354d75ac10 100644
--- a/drivers/media/rc/iguanair.c
+++ b/drivers/media/rc/iguanair.c
@@ -207,7 +207,7 @@ static int iguanair_send(struct iguanair *ir, unsigned size)
 {
 	int rc;
 
-	INIT_COMPLETION(ir->completion);
+	reinit_completion(&ir->completion);
 
 	ir->urb_out->transfer_buffer_length = size;
 	rc = usb_submit_urb(ir->urb_out, GFP_KERNEL);
diff --git a/drivers/memstick/core/memstick.c b/drivers/memstick/core/memstick.c
index ffcb10ac4341..b78f62306283 100644
--- a/drivers/memstick/core/memstick.c
+++ b/drivers/memstick/core/memstick.c
@@ -253,7 +253,7 @@ void memstick_new_req(struct memstick_host *host)
 {
 	if (host->card) {
 		host->retries = cmd_retries;
-		INIT_COMPLETION(host->card->mrq_complete);
+		reinit_completion(&host->card->mrq_complete);
 		host->request(host);
 	}
 }
diff --git a/drivers/memstick/host/r592.c b/drivers/memstick/host/r592.c
index 9718661c1fb6..a96a1b9b01ad 100644
--- a/drivers/memstick/host/r592.c
+++ b/drivers/memstick/host/r592.c
@@ -290,7 +290,7 @@ static int r592_transfer_fifo_dma(struct r592_device *dev)
 	dbg_verbose("doing dma transfer");
 
 	dev->dma_error = 0;
-	INIT_COMPLETION(dev->dma_done);
+	reinit_completion(&dev->dma_done);
 
 	/* TODO: hidden assumption about nenth beeing always 1 */
 	sg_count = dma_map_sg(&dev->pci_dev->dev, &dev->req->sg, 1, is_write ?
* Unmerged path drivers/misc/mic/card/mic_virtio.c
* Unmerged path drivers/misc/mic/host/mic_boot.c
diff --git a/drivers/misc/ti-st/st_kim.c b/drivers/misc/ti-st/st_kim.c
index 83269f1d16e3..044b331aaa3f 100644
--- a/drivers/misc/ti-st/st_kim.c
+++ b/drivers/misc/ti-st/st_kim.c
@@ -218,7 +218,7 @@ static long read_local_version(struct kim_data_s *kim_gdata, char *bts_scr_name)
 
 	pr_debug("%s", __func__);
 
-	INIT_COMPLETION(kim_gdata->kim_rcvd);
+	reinit_completion(&kim_gdata->kim_rcvd);
 	if (4 != st_int_write(kim_gdata->core_data, read_ver_cmd, 4)) {
 		pr_err("kim: couldn't write 4 bytes");
 		return -EIO;
@@ -229,7 +229,7 @@ static long read_local_version(struct kim_data_s *kim_gdata, char *bts_scr_name)
 		pr_err(" waiting for ver info- timed out ");
 		return -ETIMEDOUT;
 	}
-	INIT_COMPLETION(kim_gdata->kim_rcvd);
+	reinit_completion(&kim_gdata->kim_rcvd);
 	/* the positions 12 & 13 in the response buffer provide with the
 	 * chip, major & minor numbers
 	 */
@@ -362,7 +362,7 @@ static long download_firmware(struct kim_data_s *kim_gdata)
 			/* reinit completion before sending for the
 			 * relevant wait
 			 */
-			INIT_COMPLETION(kim_gdata->kim_rcvd);
+			reinit_completion(&kim_gdata->kim_rcvd);
 
 			/*
 			 * Free space found in uart buffer, call st_int_write
@@ -398,7 +398,7 @@ static long download_firmware(struct kim_data_s *kim_gdata)
 				release_firmware(kim_gdata->fw_entry);
 				return -ETIMEDOUT;
 			}
-			INIT_COMPLETION(kim_gdata->kim_rcvd);
+			reinit_completion(&kim_gdata->kim_rcvd);
 			break;
 		case ACTION_DELAY:	/* sleep */
 			pr_info("sleep command in scr");
@@ -474,7 +474,7 @@ long st_kim_start(void *kim_data)
 		gpio_set_value(kim_gdata->nshutdown, GPIO_HIGH);
 		mdelay(100);
 		/* re-initialize the completion */
-		INIT_COMPLETION(kim_gdata->ldisc_installed);
+		reinit_completion(&kim_gdata->ldisc_installed);
 		/* send notification to UIM */
 		kim_gdata->ldisc_install = 1;
 		pr_info("ldisc_install = 1");
@@ -525,7 +525,7 @@ long st_kim_stop(void *kim_data)
 		kim_gdata->kim_pdev->dev.platform_data;
 	struct tty_struct	*tty = kim_gdata->core_data->tty;
 
-	INIT_COMPLETION(kim_gdata->ldisc_installed);
+	reinit_completion(&kim_gdata->ldisc_installed);
 
 	if (tty) {	/* can be called before ldisc is installed */
 		/* Flush any pending characters in the driver and discipline. */
diff --git a/drivers/mtd/nand/mxc_nand.c b/drivers/mtd/nand/mxc_nand.c
index 07e5784e5cd3..980c7fc21690 100644
--- a/drivers/mtd/nand/mxc_nand.c
+++ b/drivers/mtd/nand/mxc_nand.c
@@ -395,7 +395,7 @@ static void wait_op_done(struct mxc_nand_host *host, int useirq)
 
 	if (useirq) {
 		if (!host->devtype_data->check_int(host)) {
-			INIT_COMPLETION(host->op_completion);
+			reinit_completion(&host->op_completion);
 			irq_control(host, 1);
 			wait_for_completion(&host->op_completion);
 		}
diff --git a/drivers/mtd/nand/r852.c b/drivers/mtd/nand/r852.c
index 4495f8551fa0..23dc7117e12c 100644
--- a/drivers/mtd/nand/r852.c
+++ b/drivers/mtd/nand/r852.c
@@ -181,7 +181,7 @@ static void r852_do_dma(struct r852_device *dev, uint8_t *buf, int do_read)
 	/* Set dma direction */
 	dev->dma_dir = do_read;
 	dev->dma_stage = 1;
-	INIT_COMPLETION(dev->dma_done);
+	reinit_completion(&dev->dma_done);
 
 	dbg_verbose("doing dma %s ", do_read ? "read" : "write");
 
diff --git a/drivers/mtd/onenand/omap2.c b/drivers/mtd/onenand/omap2.c
index d98b198edd53..e4c552d0cbc1 100644
--- a/drivers/mtd/onenand/omap2.c
+++ b/drivers/mtd/onenand/omap2.c
@@ -159,7 +159,7 @@ static int omap2_onenand_wait(struct mtd_info *mtd, int state)
 				syscfg = read_reg(c, ONENAND_REG_SYS_CFG1);
 		}
 
-		INIT_COMPLETION(c->irq_done);
+		reinit_completion(&c->irq_done);
 		if (c->gpio_irq) {
 			result = gpio_get_value(c->gpio_irq);
 			if (result == -1) {
@@ -349,7 +349,7 @@ static int omap3_onenand_read_bufferram(struct mtd_info *mtd, int area,
 	omap_set_dma_dest_params(c->dma_channel, 0, OMAP_DMA_AMODE_POST_INC,
 				 dma_dst, 0, 0);
 
-	INIT_COMPLETION(c->dma_done);
+	reinit_completion(&c->dma_done);
 	omap_start_dma(c->dma_channel);
 
 	timeout = jiffies + msecs_to_jiffies(20);
@@ -420,7 +420,7 @@ static int omap3_onenand_write_bufferram(struct mtd_info *mtd, int area,
 	omap_set_dma_dest_params(c->dma_channel, 0, OMAP_DMA_AMODE_POST_INC,
 				 dma_dst, 0, 0);
 
-	INIT_COMPLETION(c->dma_done);
+	reinit_completion(&c->dma_done);
 	omap_start_dma(c->dma_channel);
 
 	timeout = jiffies + msecs_to_jiffies(20);
@@ -499,7 +499,7 @@ static int omap2_onenand_read_bufferram(struct mtd_info *mtd, int area,
 	omap_set_dma_dest_params(c->dma_channel, 0, OMAP_DMA_AMODE_POST_INC,
 				 dma_dst, 0, 0);
 
-	INIT_COMPLETION(c->dma_done);
+	reinit_completion(&c->dma_done);
 	omap_start_dma(c->dma_channel);
 	wait_for_completion(&c->dma_done);
 
@@ -544,7 +544,7 @@ static int omap2_onenand_write_bufferram(struct mtd_info *mtd, int area,
 	omap_set_dma_dest_params(c->dma_channel, 0, OMAP_DMA_AMODE_POST_INC,
 				 dma_dst, 0, 0);
 
-	INIT_COMPLETION(c->dma_done);
+	reinit_completion(&c->dma_done);
 	omap_start_dma(c->dma_channel);
 	wait_for_completion(&c->dma_done);
 
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
index 1bc0aaa20696..a880e9bac0c7 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
@@ -3788,7 +3788,7 @@ static int qlcnic_83xx_resume(struct qlcnic_adapter *adapter)
 
 void qlcnic_83xx_reinit_mbx_work(struct qlcnic_mailbox *mbx)
 {
-	INIT_COMPLETION(mbx->completion);
+	reinit_completion(&mbx->completion);
 	set_bit(QLC_83XX_MBX_READY, &mbx->status);
 }
 
diff --git a/drivers/net/ieee802154/at86rf230.c b/drivers/net/ieee802154/at86rf230.c
index 6f10b4964726..2cbe1c249996 100644
--- a/drivers/net/ieee802154/at86rf230.c
+++ b/drivers/net/ieee802154/at86rf230.c
@@ -561,7 +561,7 @@ at86rf230_xmit(struct ieee802154_dev *dev, struct sk_buff *skb)
 
 	spin_lock_irqsave(&lp->lock, flags);
 	lp->is_tx = 1;
-	INIT_COMPLETION(lp->tx_complete);
+	reinit_completion(&lp->tx_complete);
 	spin_unlock_irqrestore(&lp->lock, flags);
 
 	rc = at86rf230_write_fbuf(lp, skb->data, skb->len);
* Unmerged path drivers/net/ieee802154/mrf24j40.c
* Unmerged path drivers/net/wireless/ath/ath10k/htc.c
* Unmerged path drivers/net/wireless/ath/ath10k/mac.c
* Unmerged path drivers/net/wireless/ath/wil6210/main.c
diff --git a/drivers/net/wireless/zd1211rw/zd_usb.c b/drivers/net/wireless/zd1211rw/zd_usb.c
index 7ef0b4a181e1..84d94f572a46 100644
--- a/drivers/net/wireless/zd1211rw/zd_usb.c
+++ b/drivers/net/wireless/zd1211rw/zd_usb.c
@@ -1619,7 +1619,7 @@ static void prepare_read_regs_int(struct zd_usb *usb,
 	atomic_set(&intr->read_regs_enabled, 1);
 	intr->read_regs.req = req;
 	intr->read_regs.req_count = count;
-	INIT_COMPLETION(intr->read_regs.completion);
+	reinit_completion(&intr->read_regs.completion);
 	spin_unlock_irq(&intr->lock);
 }
 
diff --git a/drivers/parport/parport_ip32.c b/drivers/parport/parport_ip32.c
index d4716273651e..c864f82bd37d 100644
--- a/drivers/parport/parport_ip32.c
+++ b/drivers/parport/parport_ip32.c
@@ -1331,7 +1331,7 @@ static unsigned int parport_ip32_fwp_wait_interrupt(struct parport *p)
 			break;
 
 		/* Initialize mutex used to take interrupts into account */
-		INIT_COMPLETION(priv->irq_complete);
+		reinit_completion(&priv->irq_complete);
 
 		/* Enable serviceIntr */
 		parport_ip32_frob_econtrol(p, ECR_SERVINTR, 0);
@@ -1446,7 +1446,7 @@ static size_t parport_ip32_fifo_write_block_dma(struct parport *p,
 	priv->irq_mode = PARPORT_IP32_IRQ_HERE;
 
 	parport_ip32_dma_start(DMA_TO_DEVICE, (void *)buf, len);
-	INIT_COMPLETION(priv->irq_complete);
+	reinit_completion(&priv->irq_complete);
 	parport_ip32_frob_econtrol(p, ECR_DMAEN | ECR_SERVINTR, ECR_DMAEN);
 
 	nfault_timeout = min((unsigned long)physport->cad->timeout,
diff --git a/drivers/platform/x86/apple-gmux.c b/drivers/platform/x86/apple-gmux.c
index 5db179c1c579..cd49c6b47595 100644
--- a/drivers/platform/x86/apple-gmux.c
+++ b/drivers/platform/x86/apple-gmux.c
@@ -289,7 +289,7 @@ static int gmux_switchto(enum vga_switcheroo_client_id id)
 static int gmux_set_discrete_state(struct apple_gmux_data *gmux_data,
 				   enum vga_switcheroo_state state)
 {
-	INIT_COMPLETION(gmux_data->powerchange_done);
+	reinit_completion(&gmux_data->powerchange_done);
 
 	if (state == VGA_SWITCHEROO_ON) {
 		gmux_write8(gmux_data, GMUX_PORT_DISCRETE_POWER, 1);
diff --git a/drivers/power/ab8500_fg.c b/drivers/power/ab8500_fg.c
index c5391f5c372d..272ad0724513 100644
--- a/drivers/power/ab8500_fg.c
+++ b/drivers/power/ab8500_fg.c
@@ -574,8 +574,8 @@ int ab8500_fg_inst_curr_start(struct ab8500_fg *di)
 	}
 
 	/* Return and WFI */
-	INIT_COMPLETION(di->ab8500_fg_started);
-	INIT_COMPLETION(di->ab8500_fg_complete);
+	reinit_completion(&di->ab8500_fg_started);
+	reinit_completion(&di->ab8500_fg_complete);
 	enable_irq(di->irq);
 
 	/* Note: cc_lock is still locked */
diff --git a/drivers/power/jz4740-battery.c b/drivers/power/jz4740-battery.c
index c675553d4647..3c2fb0ca40a6 100644
--- a/drivers/power/jz4740-battery.c
+++ b/drivers/power/jz4740-battery.c
@@ -73,7 +73,7 @@ static long jz_battery_read_voltage(struct jz_battery *battery)
 
 	mutex_lock(&battery->lock);
 
-	INIT_COMPLETION(battery->read_completion);
+	reinit_completion(&battery->read_completion);
 
 	enable_irq(battery->irq);
 	battery->cell->enable(battery->pdev);
diff --git a/drivers/rtc/rtc-hid-sensor-time.c b/drivers/rtc/rtc-hid-sensor-time.c
index 63024505dddc..0f3771549588 100644
--- a/drivers/rtc/rtc-hid-sensor-time.c
+++ b/drivers/rtc/rtc-hid-sensor-time.c
@@ -189,7 +189,7 @@ static int hid_rtc_read_time(struct device *dev, struct rtc_time *tm)
 		platform_get_drvdata(to_platform_device(dev));
 	int ret;
 
-	INIT_COMPLETION(time_state->comp_last_time);
+	reinit_completion(&time_state->comp_last_time);
 	/* get a report with all values through requesting one value */
 	sensor_hub_input_attr_get_raw_value(time_state->common_attributes.hsdev,
 			HID_USAGE_SENSOR_TIME, hid_time_addresses[0],
diff --git a/drivers/spi/spi-bcm2835.c b/drivers/spi/spi-bcm2835.c
index 89c0b5033114..90ca44311134 100644
--- a/drivers/spi/spi-bcm2835.c
+++ b/drivers/spi/spi-bcm2835.c
@@ -217,7 +217,7 @@ static int bcm2835_spi_start_transfer(struct spi_device *spi,
 		cs |= spi->chip_select;
 	}
 
-	INIT_COMPLETION(bs->done);
+	reinit_completion(&bs->done);
 	bs->tx_buf = tfr->tx_buf;
 	bs->rx_buf = tfr->rx_buf;
 	bs->len = tfr->len;
diff --git a/drivers/spi/spi-clps711x.c b/drivers/spi/spi-clps711x.c
index a11cbf02691a..1cd587ed0967 100644
--- a/drivers/spi/spi-clps711x.c
+++ b/drivers/spi/spi-clps711x.c
@@ -111,7 +111,7 @@ static int spi_clps711x_transfer_one_message(struct spi_master *master,
 
 		gpio_set_value(cs, !!(msg->spi->mode & SPI_CS_HIGH));
 
-		INIT_COMPLETION(hw->done);
+		reinit_completion(&hw->done);
 
 		hw->count = 0;
 		hw->len = xfer->len;
diff --git a/drivers/spi/spi-davinci.c b/drivers/spi/spi-davinci.c
index df0aacc6fc3b..9b5a685149d6 100644
--- a/drivers/spi/spi-davinci.c
+++ b/drivers/spi/spi-davinci.c
@@ -554,7 +554,7 @@ static int davinci_spi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	clear_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);
 	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);
 
-	INIT_COMPLETION(dspi->done);
+	reinit_completion(&dspi->done);
 
 	if (spicfg->io_type == SPI_IO_TYPE_INTR)
 		set_io_bits(dspi->base + SPIINT, SPIINT_MASKINT);
diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 24610ca8955d..6a8298476872 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -236,7 +236,7 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	mpc8xxx_spi->tx = t->tx_buf;
 	mpc8xxx_spi->rx = t->rx_buf;
 
-	INIT_COMPLETION(mpc8xxx_spi->done);
+	reinit_completion(&mpc8xxx_spi->done);
 
 	/* Set SPCOM[CS] and SPCOM[TRANLEN] field */
 	if ((t->len - 1) > SPCOM_TRANLEN_MAX) {
diff --git a/drivers/spi/spi-fsl-spi.c b/drivers/spi/spi-fsl-spi.c
index 14e202ee7036..1f113bbb29e2 100644
--- a/drivers/spi/spi-fsl-spi.c
+++ b/drivers/spi/spi-fsl-spi.c
@@ -339,7 +339,7 @@ static int fsl_spi_bufs(struct spi_device *spi, struct spi_transfer *t,
 	mpc8xxx_spi->tx = t->tx_buf;
 	mpc8xxx_spi->rx = t->rx_buf;
 
-	INIT_COMPLETION(mpc8xxx_spi->done);
+	reinit_completion(&mpc8xxx_spi->done);
 
 	if (mpc8xxx_spi->flags & SPI_CPM_MODE)
 		ret = fsl_spi_cpm_bufs(mpc8xxx_spi, t, is_dma_mapped);
* Unmerged path drivers/spi/spi-mpc512x-psc.c
diff --git a/drivers/spi/spi-mxs.c b/drivers/spi/spi-mxs.c
index 84982768cd10..b2db41457b26 100644
--- a/drivers/spi/spi-mxs.c
+++ b/drivers/spi/spi-mxs.c
@@ -238,7 +238,7 @@ static int mxs_spi_txrx_dma(struct mxs_spi *spi, int cs,
 	if (!dma_xfer)
 		return -ENOMEM;
 
-	INIT_COMPLETION(spi->c);
+	reinit_completion(&spi->c);
 
 	ctrl0 = readl(ssp->base + HW_SSP_CTRL0);
 	ctrl0 &= ~BM_SSP_CTRL0_XFER_COUNT;
* Unmerged path drivers/spi/spi-s3c64xx.c
diff --git a/drivers/spi/spi-sh-msiof.c b/drivers/spi/spi-sh-msiof.c
index 2bc5a6b86300..3c3479776813 100644
--- a/drivers/spi/spi-sh-msiof.c
+++ b/drivers/spi/spi-sh-msiof.c
@@ -465,7 +465,7 @@ static int sh_msiof_spi_txrx_once(struct sh_msiof_spi_priv *p,
 	ret = ret ? ret : sh_msiof_modify_ctr_wait(p, 0, CTR_TXE);
 
 	/* start by setting frame bit */
-	INIT_COMPLETION(p->done);
+	reinit_completion(&p->done);
 	ret = ret ? ret : sh_msiof_modify_ctr_wait(p, 0, CTR_TFSE);
 	if (ret) {
 		dev_err(&p->pdev->dev, "failed to start hardware\n");
* Unmerged path drivers/spi/spi-sirf.c
* Unmerged path drivers/spi/spi-tegra114.c
diff --git a/drivers/spi/spi-tegra20-sflash.c b/drivers/spi/spi-tegra20-sflash.c
index 09df8e22dba0..8c7567b77ff4 100644
--- a/drivers/spi/spi-tegra20-sflash.c
+++ b/drivers/spi/spi-tegra20-sflash.c
@@ -345,7 +345,7 @@ static int tegra_sflash_transfer_one_message(struct spi_master *master,
 	msg->actual_length = 0;
 	single_xfer = list_is_singular(&msg->transfers);
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
-		INIT_COMPLETION(tsd->xfer_completion);
+		reinit_completion(&tsd->xfer_completion);
 		ret = tegra_sflash_start_transfer_one(spi, xfer,
 					is_first_msg, single_xfer);
 		if (ret < 0) {
* Unmerged path drivers/spi/spi-tegra20-slink.c
diff --git a/drivers/spi/spi-xilinx.c b/drivers/spi/spi-xilinx.c
index 34d18dcfa0db..a0759f53c0ad 100644
--- a/drivers/spi/spi-xilinx.c
+++ b/drivers/spi/spi-xilinx.c
@@ -273,7 +273,7 @@ static int xilinx_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
 	xspi->tx_ptr = t->tx_buf;
 	xspi->rx_ptr = t->rx_buf;
 	xspi->remaining_bytes = t->len;
-	INIT_COMPLETION(xspi->done);
+	reinit_completion(&xspi->done);
 
 
 	/* Enable the transmit empty interrupt, which we use to determine
* Unmerged path drivers/spi/spi.c
diff --git a/drivers/staging/iio/adc/mxs-lradc.c b/drivers/staging/iio/adc/mxs-lradc.c
index 972a0723afac..365f0aa9d199 100644
--- a/drivers/staging/iio/adc/mxs-lradc.c
+++ b/drivers/staging/iio/adc/mxs-lradc.c
@@ -252,7 +252,7 @@ static int mxs_lradc_read_raw(struct iio_dev *iio_dev,
 	if (!ret)
 		return -EBUSY;
 
-	INIT_COMPLETION(lradc->completion);
+	reinit_completion(&lradc->completion);
 
 	/*
 	 * No buffered operation in progress, map the channel and trigger it.
diff --git a/drivers/staging/media/solo6x10/solo6x10-p2m.c b/drivers/staging/media/solo6x10/solo6x10-p2m.c
index 333594189b81..7f2f2472655b 100644
--- a/drivers/staging/media/solo6x10/solo6x10-p2m.c
+++ b/drivers/staging/media/solo6x10/solo6x10-p2m.c
@@ -87,7 +87,7 @@ int solo_p2m_dma_desc(struct solo_dev *solo_dev,
 	if (mutex_lock_interruptible(&p2m_dev->mutex))
 		return -EINTR;
 
-	INIT_COMPLETION(p2m_dev->completion);
+	reinit_completion(&p2m_dev->completion);
 	p2m_dev->error = 0;
 
 	if (desc_cnt > 1 && solo_dev->type != SOLO_DEV_6110 && desc_mode) {
diff --git a/drivers/staging/tidspbridge/core/sync.c b/drivers/staging/tidspbridge/core/sync.c
index 7bb550acaf4a..743ff09d82d2 100644
--- a/drivers/staging/tidspbridge/core/sync.c
+++ b/drivers/staging/tidspbridge/core/sync.c
@@ -72,7 +72,7 @@ int sync_wait_on_multiple_events(struct sync_object **events,
 	spin_lock_bh(&sync_lock);
 	for (i = 0; i < count; i++) {
 		if (completion_done(&events[i]->comp)) {
-			INIT_COMPLETION(events[i]->comp);
+			reinit_completion(&events[i]->comp);
 			*index = i;
 			spin_unlock_bh(&sync_lock);
 			status = 0;
@@ -92,7 +92,7 @@ int sync_wait_on_multiple_events(struct sync_object **events,
 	spin_lock_bh(&sync_lock);
 	for (i = 0; i < count; i++) {
 		if (completion_done(&events[i]->comp)) {
-			INIT_COMPLETION(events[i]->comp);
+			reinit_completion(&events[i]->comp);
 			*index = i;
 			status = 0;
 		}
diff --git a/drivers/staging/tidspbridge/include/dspbridge/sync.h b/drivers/staging/tidspbridge/include/dspbridge/sync.h
index 58a0d5c5543d..fc19b9707087 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/sync.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/sync.h
@@ -59,7 +59,7 @@ static inline void sync_init_event(struct sync_object *event)
 
 static inline void sync_reset_event(struct sync_object *event)
 {
-	INIT_COMPLETION(event->comp);
+	reinit_completion(&event->comp);
 	event->multi_comp = NULL;
 }
 
diff --git a/drivers/staging/tidspbridge/rmgr/drv_interface.c b/drivers/staging/tidspbridge/rmgr/drv_interface.c
index df0f37ea1ee5..9d75a9507a3c 100644
--- a/drivers/staging/tidspbridge/rmgr/drv_interface.c
+++ b/drivers/staging/tidspbridge/rmgr/drv_interface.c
@@ -332,7 +332,7 @@ static void bridge_recover(struct work_struct *work)
 	struct dev_object *dev;
 	struct cfg_devnode *dev_node;
 	if (atomic_read(&bridge_cref)) {
-		INIT_COMPLETION(bridge_comp);
+		reinit_completion(&bridge_comp);
 		while (!wait_for_completion_timeout(&bridge_comp,
 						msecs_to_jiffies(REC_TIMEOUT)))
 			pr_info("%s:%d handle(s) still opened\n",
@@ -348,7 +348,7 @@ static void bridge_recover(struct work_struct *work)
 
 void bridge_recover_schedule(void)
 {
-	INIT_COMPLETION(bridge_open_comp);
+	reinit_completion(&bridge_open_comp);
 	recover = true;
 	queue_work(bridge_rec_queue, &bridge_recovery_work);
 }
@@ -389,7 +389,7 @@ static int omap3_bridge_startup(struct platform_device *pdev)
 #ifdef CONFIG_TIDSPBRIDGE_RECOVERY
 	bridge_rec_queue = create_workqueue("bridge_rec_queue");
 	INIT_WORK(&bridge_recovery_work, bridge_recover);
-	INIT_COMPLETION(bridge_comp);
+	reinit_completion(&bridge_comp);
 #endif
 
 #ifdef CONFIG_PM
diff --git a/drivers/tty/metag_da.c b/drivers/tty/metag_da.c
index 0e888621f484..7332e2ca4615 100644
--- a/drivers/tty/metag_da.c
+++ b/drivers/tty/metag_da.c
@@ -495,7 +495,7 @@ static int dashtty_write(struct tty_struct *tty, const unsigned char *buf,
 	count = dport->xmit_cnt;
 	/* xmit buffer no longer empty? */
 	if (count)
-		INIT_COMPLETION(dport->xmit_empty);
+		reinit_completion(&dport->xmit_empty);
 	mutex_unlock(&dport->xmit_lock);
 
 	if (total) {
diff --git a/drivers/usb/c67x00/c67x00-sched.c b/drivers/usb/c67x00/c67x00-sched.c
index aa491627a45b..892cc96466eb 100644
--- a/drivers/usb/c67x00/c67x00-sched.c
+++ b/drivers/usb/c67x00/c67x00-sched.c
@@ -344,7 +344,7 @@ void c67x00_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		/* it could happen that we reinitialize this completion, while
 		 * somebody was waiting for that completion.  The timeout and
 		 * while loop handle such cases, but this might be improved */
-		INIT_COMPLETION(c67x00->endpoint_disable);
+		reinit_completion(&c67x00->endpoint_disable);
 		c67x00_sched_kick(c67x00);
 		wait_for_completion_timeout(&c67x00->endpoint_disable, 1 * HZ);
 
diff --git a/drivers/usb/gadget/f_fs.c b/drivers/usb/gadget/f_fs.c
index b6e9d917221e..9be31b0303ac 100644
--- a/drivers/usb/gadget/f_fs.c
+++ b/drivers/usb/gadget/f_fs.c
@@ -373,7 +373,7 @@ static int __ffs_ep0_queue_wait(struct ffs_data *ffs, char *data, size_t len)
 	if (req->buf == NULL)
 		req->buf = (void *)0xDEADBABE;
 
-	INIT_COMPLETION(ffs->ep0req_completion);
+	reinit_completion(&ffs->ep0req_completion);
 
 	ret = usb_ep_queue(ffs->gadget->ep0, req, GFP_ATOMIC);
 	if (unlikely(ret < 0))
diff --git a/drivers/usb/serial/mos7720.c b/drivers/usb/serial/mos7720.c
index 426d240f5a46..4f70df33975a 100644
--- a/drivers/usb/serial/mos7720.c
+++ b/drivers/usb/serial/mos7720.c
@@ -452,7 +452,7 @@ static int parport_prologue(struct parport *pp)
 		return -1;
 	}
 	mos_parport->msg_pending = true;   /* synch usb call pending */
-	INIT_COMPLETION(mos_parport->syncmsg_compl);
+	reinit_completion(&mos_parport->syncmsg_compl);
 	spin_unlock(&release_lock);
 
 	mutex_lock(&mos_parport->serial->disc_mutex);
diff --git a/drivers/video/exynos/exynos_mipi_dsi_common.c b/drivers/video/exynos/exynos_mipi_dsi_common.c
index 520fc9bd887b..c1d8cc3346ae 100644
--- a/drivers/video/exynos/exynos_mipi_dsi_common.c
+++ b/drivers/video/exynos/exynos_mipi_dsi_common.c
@@ -220,7 +220,7 @@ int exynos_mipi_dsi_wr_data(struct mipi_dsim_device *dsim, unsigned int data_id,
 	case MIPI_DSI_DCS_LONG_WRITE:
 	{
 		unsigned int size, payload = 0;
-		INIT_COMPLETION(dsim_wr_comp);
+		reinit_completion(&dsim_wr_comp);
 
 		size = data_size * 4;
 
@@ -356,7 +356,7 @@ int exynos_mipi_dsi_rd_data(struct mipi_dsim_device *dsim, unsigned int data_id,
 	msleep(20);
 
 	mutex_lock(&dsim->lock);
-	INIT_COMPLETION(dsim_rd_comp);
+	reinit_completion(&dsim_rd_comp);
 	exynos_mipi_dsi_rd_tx_header(dsim,
 		MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE, req_size);
 
* Unmerged path drivers/video/omap2/displays-new/encoder-tpd12s015.c
diff --git a/fs/ecryptfs/crypto.c b/fs/ecryptfs/crypto.c
index f71ec125290d..5dc0a209a609 100644
--- a/fs/ecryptfs/crypto.c
+++ b/fs/ecryptfs/crypto.c
@@ -399,7 +399,7 @@ static int encrypt_scatterlist(struct ecryptfs_crypt_stat *crypt_stat,
 
 		wait_for_completion(&ecr->completion);
 		rc = ecr->rc;
-		INIT_COMPLETION(ecr->completion);
+		reinit_completion(&ecr->completion);
 	}
 out:
 	ablkcipher_request_free(req);
diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c
index 38fcbfb16c6f..40484322ad69 100644
--- a/fs/nfs/nfs4state.c
+++ b/fs/nfs/nfs4state.c
@@ -244,7 +244,7 @@ static int nfs4_drain_slot_tbl(struct nfs4_slot_table *tbl)
 	set_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state);
 	spin_lock(&tbl->slot_tbl_lock);
 	if (tbl->highest_used_slotid != NFS4_NO_SLOT) {
-		INIT_COMPLETION(tbl->complete);
+		reinit_completion(&tbl->complete);
 		spin_unlock(&tbl->slot_tbl_lock);
 		return wait_for_completion_interruptible(&tbl->complete);
 	}
diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c
index 3a44a648dae7..3407b2c62b21 100644
--- a/fs/ocfs2/dlmglue.c
+++ b/fs/ocfs2/dlmglue.c
@@ -1304,7 +1304,7 @@ static int ocfs2_wait_for_mask(struct ocfs2_mask_waiter *mw)
 {
 	wait_for_completion(&mw->mw_complete);
 	/* Re-arm the completion in case we want to wait on it again */
-	INIT_COMPLETION(mw->mw_complete);
+	reinit_completion(&mw->mw_complete);
 	return mw->mw_status;
 }
 
@@ -1355,7 +1355,7 @@ static int ocfs2_wait_for_mask_interruptible(struct ocfs2_mask_waiter *mw,
 	else
 		ret = mw->mw_status;
 	/* Re-arm the completion in case we want to wait on it again */
-	INIT_COMPLETION(mw->mw_complete);
+	reinit_completion(&mw->mw_complete);
 	return ret;
 }
 
* Unmerged path sound/firewire/dice.c
diff --git a/sound/soc/samsung/ac97.c b/sound/soc/samsung/ac97.c
index cb88ead98917..ea5b6ce5eb4d 100644
--- a/sound/soc/samsung/ac97.c
+++ b/sound/soc/samsung/ac97.c
@@ -74,7 +74,7 @@ static void s3c_ac97_activate(struct snd_ac97 *ac97)
 	if (stat == S3C_AC97_GLBSTAT_MAINSTATE_ACTIVE)
 		return; /* Return if already active */
 
-	INIT_COMPLETION(s3c_ac97.done);
+	reinit_completion(&s3c_ac97.done);
 
 	ac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);
 	ac_glbctrl = S3C_AC97_GLBCTRL_ACLINKON;
@@ -103,7 +103,7 @@ static unsigned short s3c_ac97_read(struct snd_ac97 *ac97,
 
 	s3c_ac97_activate(ac97);
 
-	INIT_COMPLETION(s3c_ac97.done);
+	reinit_completion(&s3c_ac97.done);
 
 	ac_codec_cmd = readl(s3c_ac97.regs + S3C_AC97_CODEC_CMD);
 	ac_codec_cmd = S3C_AC97_CODEC_CMD_READ | AC_CMD_ADDR(reg);
@@ -140,7 +140,7 @@ static void s3c_ac97_write(struct snd_ac97 *ac97, unsigned short reg,
 
 	s3c_ac97_activate(ac97);
 
-	INIT_COMPLETION(s3c_ac97.done);
+	reinit_completion(&s3c_ac97.done);
 
 	ac_codec_cmd = readl(s3c_ac97.regs + S3C_AC97_CODEC_CMD);
 	ac_codec_cmd = AC_CMD_ADDR(reg) | AC_CMD_DATA(val);
