cxlflash: Fix to prevent EEH recovery failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
commit 8e78262328ecfbe9d72ac40328ecf5e7ff6fc3bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8e782623.failed

The process_sense() routine can perform a read capacity which
can take some time to complete. If an EEH occurs while waiting
on the read capacity, the EEH handler will wait to obtain the
context's mutex in order to put the context in an error state.
The EEH handler will sit and wait until the context is free,
but this wait can potentially last forever (deadlock) if the
scsi_execute() that performs the read capacity experiences a
timeout and calls into the reset callback. When that occurs,
the reset callback sees that the device is already being reset
and waits for the reset to complete. This leaves two threads
waiting on the other.

To address this issue, make the context unavailable to new,
non-system owned threads and release the context while calling
into process_sense(). After returning from process_sense() the
context mutex is reacquired and the context is made available
again. The context can be safely moved to the error state if
needed during the unavailable window as no other threads will
hold its reference.

	Signed-off-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Signed-off-by: Manoj N. Kumar <manoj@linux.vnet.ibm.com>
	Reviewed-by: Brian King <brking@linux.vnet.ibm.com>
	Reviewed-by: Daniel Axtens <dja@axtens.net>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Signed-off-by: James Bottomley <JBottomley@Odin.com>
(cherry picked from commit 8e78262328ecfbe9d72ac40328ecf5e7ff6fc3bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/cxlflash/superpipe.c
* Unmerged path drivers/scsi/cxlflash/superpipe.c
* Unmerged path drivers/scsi/cxlflash/superpipe.c
