net/ethtool: support set coalesce per queue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] ethtool: support set coalesce per queue (Ivan Vecera) [1268334]
Rebuild_FUZZ: 95.12%
commit-author Kan Liang <kan.liang@intel.com>
commit f38d138a7da6510a1184e3bc5f425deb187c3265
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f38d138a.failed

This patch implements sub command ETHTOOL_SCOALESCE for ioctl
ETHTOOL_PERQUEUE. It introduces an interface set_per_queue_coalesce to
set coalesce of each masked queue to device driver. The wanted coalesce
information are stored in "data" for each masked queue, which can copy
from userspace.
If it fails to set coalesce to device driver, the value which already
set to specific queue will be tried to rollback.

	Signed-off-by: Kan Liang <kan.liang@intel.com>
	Reviewed-by: Ben Hutchings <ben@decadent.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f38d138a7da6510a1184e3bc5f425deb187c3265)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/ethtool.h
#	net/core/ethtool.c
diff --cc include/linux/ethtool.h
index cdb20fccb517,472d7d7b01c2..000000000000
--- a/include/linux/ethtool.h
+++ b/include/linux/ethtool.h
@@@ -206,6 -201,16 +206,19 @@@ static inline u32 ethtool_rxfh_indir_de
   * @get_module_eeprom: Get the eeprom information from the plug-in module
   * @get_eee: Get Energy-Efficient (EEE) supported and status.
   * @set_eee: Set EEE status (enable/disable) as well as LPI timers.
++<<<<<<< HEAD
++=======
+  * @get_per_queue_coalesce: Get interrupt coalescing parameters per queue.
+  *	It must check that the given queue number is valid. If neither a RX nor
+  *	a TX queue has this number, return -EINVAL. If only a RX queue or a TX
+  *	queue has this number, set the inapplicable fields to ~0 and return 0.
+  *	Returns a negative error code or zero.
+  * @set_per_queue_coalesce: Set interrupt coalescing parameters per queue.
+  *	It must check that the given queue number is valid. If neither a RX nor
+  *	a TX queue has this number, return -EINVAL. If only a RX queue or a TX
+  *	queue has this number, ignore the inapplicable fields.
+  *	Returns a negative error code or zero.
++>>>>>>> f38d138a7da6 (net/ethtool: support set coalesce per queue)
   *
   * All operations are optional (i.e. the function pointer may be set
   * to %NULL) and callers must take this into account.  Callers must
@@@ -281,32 -289,10 +294,39 @@@ struct ethtool_ops 
  			       const struct ethtool_tunable *, void *);
  	int	(*set_tunable)(struct net_device *,
  			       const struct ethtool_tunable *, const void *);
++<<<<<<< HEAD
++=======
+ 	int	(*get_per_queue_coalesce)(struct net_device *, u32,
+ 					  struct ethtool_coalesce *);
+ 	int	(*set_per_queue_coalesce)(struct net_device *, u32,
+ 					  struct ethtool_coalesce *);
++>>>>>>> f38d138a7da6 (net/ethtool: support set coalesce per queue)
  
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_USE_P(1, u32	(*get_rxfh_key_size)(struct net_device *))
 +	RH_KABI_USE_P(2, int	(*get_rxfh)(struct net_device *, u32 *indir,
 +					    u8 *key, u8 *hfunc))
 +	RH_KABI_USE_P(3, int	(*set_rxfh)(struct net_device *,
 +					    const u32 *indir, const u8 *key,
 +					    const u8 hfunc))
 +	RH_KABI_RESERVE_P(4)
 +	RH_KABI_RESERVE_P(5)
 +	RH_KABI_RESERVE_P(6)
 +	RH_KABI_RESERVE_P(7)
 +	RH_KABI_RESERVE_P(8)
 +	RH_KABI_RESERVE_P(9)
 +	RH_KABI_RESERVE_P(10)
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_RESERVE_P(16)
  };
  #endif /* _LINUX_ETHTOOL_H */
diff --cc net/core/ethtool.c
index 1ed11f1c82d9,2406101002b1..000000000000
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@@ -1731,6 -1888,114 +1731,117 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int ethtool_get_per_queue_coalesce(struct net_device *dev,
+ 					  void __user *useraddr,
+ 					  struct ethtool_per_queue_op *per_queue_opt)
+ {
+ 	u32 bit;
+ 	int ret;
+ 	DECLARE_BITMAP(queue_mask, MAX_NUM_QUEUE);
+ 
+ 	if (!dev->ethtool_ops->get_per_queue_coalesce)
+ 		return -EOPNOTSUPP;
+ 
+ 	useraddr += sizeof(*per_queue_opt);
+ 
+ 	bitmap_from_u32array(queue_mask,
+ 			     MAX_NUM_QUEUE,
+ 			     per_queue_opt->queue_mask,
+ 			     DIV_ROUND_UP(MAX_NUM_QUEUE, 32));
+ 
+ 	for_each_set_bit(bit, queue_mask, MAX_NUM_QUEUE) {
+ 		struct ethtool_coalesce coalesce = { .cmd = ETHTOOL_GCOALESCE };
+ 
+ 		ret = dev->ethtool_ops->get_per_queue_coalesce(dev, bit, &coalesce);
+ 		if (ret != 0)
+ 			return ret;
+ 		if (copy_to_user(useraddr, &coalesce, sizeof(coalesce)))
+ 			return -EFAULT;
+ 		useraddr += sizeof(coalesce);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int ethtool_set_per_queue_coalesce(struct net_device *dev,
+ 					  void __user *useraddr,
+ 					  struct ethtool_per_queue_op *per_queue_opt)
+ {
+ 	u32 bit;
+ 	int i, ret = 0;
+ 	int n_queue;
+ 	struct ethtool_coalesce *backup = NULL, *tmp = NULL;
+ 	DECLARE_BITMAP(queue_mask, MAX_NUM_QUEUE);
+ 
+ 	if ((!dev->ethtool_ops->set_per_queue_coalesce) ||
+ 	    (!dev->ethtool_ops->get_per_queue_coalesce))
+ 		return -EOPNOTSUPP;
+ 
+ 	useraddr += sizeof(*per_queue_opt);
+ 
+ 	bitmap_from_u32array(queue_mask,
+ 			     MAX_NUM_QUEUE,
+ 			     per_queue_opt->queue_mask,
+ 			     DIV_ROUND_UP(MAX_NUM_QUEUE, 32));
+ 	n_queue = bitmap_weight(queue_mask, MAX_NUM_QUEUE);
+ 	tmp = backup = kmalloc_array(n_queue, sizeof(*backup), GFP_KERNEL);
+ 	if (!backup)
+ 		return -ENOMEM;
+ 
+ 	for_each_set_bit(bit, queue_mask, MAX_NUM_QUEUE) {
+ 		struct ethtool_coalesce coalesce;
+ 
+ 		ret = dev->ethtool_ops->get_per_queue_coalesce(dev, bit, tmp);
+ 		if (ret != 0)
+ 			goto roll_back;
+ 
+ 		tmp++;
+ 
+ 		if (copy_from_user(&coalesce, useraddr, sizeof(coalesce))) {
+ 			ret = -EFAULT;
+ 			goto roll_back;
+ 		}
+ 
+ 		ret = dev->ethtool_ops->set_per_queue_coalesce(dev, bit, &coalesce);
+ 		if (ret != 0)
+ 			goto roll_back;
+ 
+ 		useraddr += sizeof(coalesce);
+ 	}
+ 
+ roll_back:
+ 	if (ret != 0) {
+ 		tmp = backup;
+ 		for_each_set_bit(i, queue_mask, bit) {
+ 			dev->ethtool_ops->set_per_queue_coalesce(dev, i, tmp);
+ 			tmp++;
+ 		}
+ 	}
+ 	kfree(backup);
+ 
+ 	return ret;
+ }
+ 
+ static int ethtool_set_per_queue(struct net_device *dev, void __user *useraddr)
+ {
+ 	struct ethtool_per_queue_op per_queue_opt;
+ 
+ 	if (copy_from_user(&per_queue_opt, useraddr, sizeof(per_queue_opt)))
+ 		return -EFAULT;
+ 
+ 	switch (per_queue_opt.sub_command) {
+ 	case ETHTOOL_GCOALESCE:
+ 		return ethtool_get_per_queue_coalesce(dev, useraddr, &per_queue_opt);
+ 	case ETHTOOL_SCOALESCE:
+ 		return ethtool_set_per_queue_coalesce(dev, useraddr, &per_queue_opt);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	};
+ }
+ 
++>>>>>>> f38d138a7da6 (net/ethtool: support set coalesce per queue)
  /* The main entry point in this file.  Called from net/core/dev_ioctl.c */
  
  int dev_ethtool(struct net *net, struct ifreq *ifr)
* Unmerged path include/linux/ethtool.h
* Unmerged path net/core/ethtool.c
