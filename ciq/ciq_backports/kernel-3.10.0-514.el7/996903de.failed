mmc: core: add core-level function for sending tuning commands

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Minda Chen <Minda.Chen@csr.com>
commit 996903de92f0c7a32d8c83f37d7ebcea0def8660
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/996903de.failed

According to the SD card spec, Add a manual tuning command function
for SDR104/HS200.
Sending command 19 or command 21 to read data and compare with the
tunning block pattern.

This patch will help to decrease some platform private codes in SDHCI
platform_execute_tuning() callbacks.

	Signed-off-by: Minda Chen <Minda.Chen@csr.com>
	Signed-off-by: Barry Song <Baohua.Song@csr.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 996903de92f0c7a32d8c83f37d7ebcea0def8660)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mmc/core.h
diff --cc include/linux/mmc/core.h
index f206e29f94d7,c4bdaa128693..000000000000
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@@ -154,7 -154,8 +154,12 @@@ extern void mmc_start_bkops(struct mmc_
  extern int __mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int, bool,
  			bool, bool);
  extern int mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int);
++<<<<<<< HEAD
 +extern int mmc_send_ext_csd(struct mmc_card *card, u8 *ext_csd);
++=======
+ extern int mmc_send_tuning(struct mmc_card *card);
+ extern int mmc_get_ext_csd(struct mmc_card *card, u8 **new_ext_csd);
++>>>>>>> 996903de92f0 (mmc: core: add core-level function for sending tuning commands)
  
  #define MMC_ERASE_ARG		0x00000000
  #define MMC_SECURE_ERASE_ARG	0x80000000
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index 7d8324d583f4..143c1a338867 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -524,6 +524,76 @@ int mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,
 }
 EXPORT_SYMBOL_GPL(mmc_switch);
 
+int mmc_send_tuning(struct mmc_card *card)
+{
+	struct mmc_request mrq = {NULL};
+	struct mmc_command cmd = {0};
+	struct mmc_data data = {0};
+	struct scatterlist sg;
+	struct mmc_host *mmc = card->host;
+	struct mmc_ios *ios = &mmc->ios;
+	const u8 *tuning_block_pattern;
+	int size, err = 0;
+	u8 *data_buf;
+	u32 opcode;
+
+	if (ios->bus_width == MMC_BUS_WIDTH_8) {
+		tuning_block_pattern = tuning_blk_pattern_8bit;
+		size = sizeof(tuning_blk_pattern_8bit);
+		opcode = MMC_SEND_TUNING_BLOCK_HS200;
+	} else if (ios->bus_width == MMC_BUS_WIDTH_4) {
+		tuning_block_pattern = tuning_blk_pattern_4bit;
+		size = sizeof(tuning_blk_pattern_4bit);
+		opcode = MMC_SEND_TUNING_BLOCK;
+	} else
+		return -EINVAL;
+
+	data_buf = kzalloc(size, GFP_KERNEL);
+	if (!data_buf)
+		return -ENOMEM;
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+
+	cmd.opcode = opcode;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+
+	data.blksz = size;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+
+	/*
+	 * According to the tuning specs, Tuning process
+	 * is normally shorter 40 executions of CMD19,
+	 * and timeout value should be shorter than 150 ms
+	 */
+	data.timeout_ns = 150 * NSEC_PER_MSEC;
+
+	data.sg = &sg;
+	data.sg_len = 1;
+	sg_init_one(&sg, data_buf, size);
+
+	mmc_wait_for_req(mmc, &mrq);
+
+	if (cmd.error) {
+		err = cmd.error;
+		goto out;
+	}
+
+	if (data.error) {
+		err = data.error;
+		goto out;
+	}
+
+	if (memcmp(data_buf, tuning_block_pattern, size))
+		err = -EIO;
+
+out:
+	kfree(data_buf);
+	return err;
+}
+EXPORT_SYMBOL_GPL(mmc_send_tuning);
+
 static int
 mmc_send_bus_test(struct mmc_card *card, struct mmc_host *host, u8 opcode,
 		  u8 len)
* Unmerged path include/linux/mmc/core.h
