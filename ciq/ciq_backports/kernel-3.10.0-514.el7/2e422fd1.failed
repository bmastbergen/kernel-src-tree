perf tools: Add 'trace_fields' dynamic sort key

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit 2e422fd1e4b0a1c0ca11d360be2147c87911dd1a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2e422fd1.failed

The 'trace_fields' sort key is similar as 'trace' sort key, but it shows
each fields separately.  Each event will get different columns as their
fields.

  $ perf report -s trace_fields --stdio
  # To display the perf.data header info, please use --header/--header-only options.
  #
  #
  # Total Lost Samples: 0
  #
  # Samples: 20K of event 'kmem:kmalloc'
  # Event count (approx.): 20533
  #
  # Overhead  Command           call_site                 ptr  bytes_req  bytes_alloc            gfp_flags
  # ........  .......  ..................  ..................  .........  ...........  ...................
  #
      99.89%  perf       ffffffffa01d4396  0xffff8803ffb79720         96           96    GFP_NOFS|GFP_ZERO
       0.06%  sleep      ffffffff8114e1cd  0xffff8803d228a000       4096         4096           GFP_KERNEL
       0.03%  perf       ffffffff811d6ae6  0xffff8803f7678f00        240          256  GFP_KERNEL|GFP_ZERO
       0.00%  perf       ffffffff812263c1  0xffff880406172380        128          128           GFP_KERNEL
       0.00%  perf       ffffffff812264b9  0xffff8803ffac1600        504          512           GFP_KERNEL
       0.00%  perf       ffffffff81226634  0xffff880401dc5280         28           32           GFP_KERNEL
       0.00%  sleep      ffffffff81226da9  0xffff8803ffac3a00        392          512           GFP_KERNEL

  # Samples: 20K of event 'kmem:kfree'
  # Event count (approx.): 20597
  #
  # Overhead           call_site                 ptr
  # ........  ..................  ..................
  #
      99.58%    ffffffffa01d85ad  0xffff8803ffb79720
       0.07%    ffffffff81443f5c  0xffff8803f7669400
       0.02%    ffffffff811d5753  0xffff8803f7678f00
       0.01%    ffffffff81443f5c  0xffff8803f766be00
       0.01%    ffffffff8114e359  0xffff8803d228a000
       0.01%    ffffffff81443f5c  0xffff8800d156dc00
       0.01%    ffffffff81443f5c  0xffff8803f7669400
       0.01%    ffffffff8114e359  0xffff8803d228a000
       0.01%    ffffffff8114e359  0xffff8803d228a000
       0.01%    ffffffff8114e359  0xffff8803d228a000

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1450804030-29193-13-git-send-email-namhyung@kernel.org
[ Combined with "perf tools: Fix segfault when using -s trace_fields" ]
Link: http://lkml.kernel.org/r/1451991518-25673-1-git-send-email-namhyung@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 2e422fd1e4b0a1c0ca11d360be2147c87911dd1a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/sort.c
diff --cc tools/perf/util/sort.c
index 7a0efdc373c2,79aa71d26d9f..000000000000
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@@ -1749,12 -1836,140 +1749,143 @@@ __alloc_dynamic_entry(struct perf_evse
  	return hde;
  }
  
++<<<<<<< HEAD
++=======
+ static int parse_field_name(char *str, char **event, char **field, char **opt)
+ {
+ 	char *event_name, *field_name, *opt_name;
+ 
+ 	event_name = str;
+ 	field_name = strchr(str, '.');
+ 
+ 	if (field_name) {
+ 		*field_name++ = '\0';
+ 	} else {
+ 		event_name = NULL;
+ 		field_name = str;
+ 	}
+ 
+ 	opt_name = strchr(field_name, '/');
+ 	if (opt_name)
+ 		*opt_name++ = '\0';
+ 
+ 	*event = event_name;
+ 	*field = field_name;
+ 	*opt   = opt_name;
+ 
+ 	return 0;
+ }
+ 
+ /* find match evsel using a given event name.  The event name can be:
+  *   1. NULL - only valid for single event session
+  *   2. '%' + event index (e.g. '%1' for first event)
+  *   3. full event name (e.g. sched:sched_switch)
+  *   4. partial event name (should not contain ':')
+  */
+ static struct perf_evsel *find_evsel(struct perf_evlist *evlist, char *event_name)
+ {
+ 	struct perf_evsel *evsel = NULL;
+ 	struct perf_evsel *pos;
+ 	bool full_name;
+ 
+ 	/* case 1 */
+ 	if (event_name == NULL) {
+ 		if (evlist->nr_entries != 1) {
+ 			pr_debug("event name should be given\n");
+ 			return NULL;
+ 		}
+ 
+ 		return perf_evlist__first(evlist);
+ 	}
+ 
+ 	/* case 2 */
+ 	if (event_name[0] == '%') {
+ 		int nr = strtol(event_name+1, NULL, 0);
+ 
+ 		if (nr > evlist->nr_entries)
+ 			return NULL;
+ 
+ 		evsel = perf_evlist__first(evlist);
+ 		while (--nr > 0)
+ 			evsel = perf_evsel__next(evsel);
+ 
+ 		return evsel;
+ 	}
+ 
+ 	full_name = !!strchr(event_name, ':');
+ 	evlist__for_each(evlist, pos) {
+ 		/* case 3 */
+ 		if (full_name && !strcmp(pos->name, event_name))
+ 			return pos;
+ 		/* case 4 */
+ 		if (!full_name && strstr(pos->name, event_name)) {
+ 			if (evsel) {
+ 				pr_debug("'%s' event is ambiguous: it can be %s or %s\n",
+ 					 event_name, evsel->name, pos->name);
+ 				return NULL;
+ 			}
+ 			evsel = pos;
+ 		}
+ 	}
+ 
+ 	return evsel;
+ }
+ 
+ static int __dynamic_dimension__add(struct perf_evsel *evsel,
+ 				    struct format_field *field,
+ 				    bool raw_trace)
+ {
+ 	struct hpp_dynamic_entry *hde;
+ 
+ 	hde = __alloc_dynamic_entry(evsel, field);
+ 	if (hde == NULL)
+ 		return -ENOMEM;
+ 
+ 	hde->raw_trace = raw_trace;
+ 
+ 	perf_hpp__register_sort_field(&hde->hpp);
+ 	return 0;
+ }
+ 
+ static int add_evsel_fields(struct perf_evsel *evsel, bool raw_trace)
+ {
+ 	int ret;
+ 	struct format_field *field;
+ 
+ 	field = evsel->tp_format->format.fields;
+ 	while (field) {
+ 		ret = __dynamic_dimension__add(evsel, field, raw_trace);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		field = field->next;
+ 	}
+ 	return 0;
+ }
+ 
+ static int add_all_dynamic_fields(struct perf_evlist *evlist, bool raw_trace)
+ {
+ 	int ret;
+ 	struct perf_evsel *evsel;
+ 
+ 	evlist__for_each(evlist, evsel) {
+ 		if (evsel->attr.type != PERF_TYPE_TRACEPOINT)
+ 			continue;
+ 
+ 		ret = add_evsel_fields(evsel, raw_trace);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 2e422fd1e4b0 (perf tools: Add 'trace_fields' dynamic sort key)
  static int add_dynamic_entry(struct perf_evlist *evlist, const char *tok)
  {
 -	char *str, *event_name, *field_name, *opt_name;
 -	struct perf_evsel *evsel;
 +	char *str, *event_name, *field_name;
 +	struct perf_evsel *evsel, *pos;
  	struct format_field *field;
 -	bool raw_trace = symbol_conf.raw_trace;
 +	struct hpp_dynamic_entry *hde;
  	int ret = 0;
  
  	if (evlist == NULL)
@@@ -1770,16 -1983,22 +1901,25 @@@
  		ret = -EINVAL;
  		goto out;
  	}
 +	*field_name++ = '\0';
  
 -	if (opt_name) {
 -		if (strcmp(opt_name, "raw")) {
 -			pr_debug("unsupported field option %s\n", opt_name);
 -			ret = -EINVAL;
 -			goto out;
 +	evsel = NULL;
 +	evlist__for_each(evlist, pos) {
 +		if (!strcmp(pos->name, event_name)) {
 +			evsel = pos;
 +			break;
  		}
 -		raw_trace = true;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (!strcmp(field_name, "trace_fields")) {
+ 		ret = add_all_dynamic_fields(evlist, raw_trace);
+ 		goto out;
+ 	}
+ 
+ 	evsel = find_evsel(evlist, event_name);
++>>>>>>> 2e422fd1e4b0 (perf tools: Add 'trace_fields' dynamic sort key)
  	if (evsel == NULL) {
  		pr_debug("Cannot find event: %s\n", event_name);
  		ret = -ENOENT;
@@@ -1792,22 -2011,19 +1932,36 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	field = pevent_find_any_field(evsel->tp_format, field_name);
 +	if (field == NULL) {
 +		pr_debug("Cannot find event field for %s.%s\n",
 +		       event_name, field_name);
 +		ret = -ENOENT;
 +		goto out;
++=======
+ 	if (!strcmp(field_name, "*")) {
+ 		ret = add_evsel_fields(evsel, raw_trace);
+ 	} else {
+ 		field = pevent_find_any_field(evsel->tp_format, field_name);
+ 		if (field == NULL) {
+ 			pr_debug("Cannot find event field for %s.%s\n",
+ 				 event_name, field_name);
+ 			return -ENOENT;
+ 		}
+ 
+ 		ret = __dynamic_dimension__add(evsel, field, raw_trace);
++>>>>>>> 2e422fd1e4b0 (perf tools: Add 'trace_fields' dynamic sort key)
 +	}
 +
 +	hde = __alloc_dynamic_entry(evsel, field);
 +	if (hde == NULL) {
 +		ret = -ENOMEM;
 +		goto out;
  	}
  
 +	perf_hpp__register_sort_field(&hde->hpp);
 +
  out:
  	free(str);
  	return ret;
* Unmerged path tools/perf/util/sort.c
