bus: subsys: update return type of ->remove_dev() to void

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 71db87ba570038497db1227b7dc61113c4156565
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/71db87ba.failed

Its return value is not used by the subsys core and nothing meaningful
can be done with it, even if we want to use it. The subsys device is
anyway getting removed.

Update prototype of ->remove_dev() to make its return type as void. Fix
all usage sites as well.

	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 71db87ba570038497db1227b7dc61113c4156565)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/tile/kernel/sysfs.c
#	drivers/cpufreq/cpufreq.c
#	drivers/net/rionet.c
diff --cc arch/tile/kernel/sysfs.c
index e25b0a89c18f,825867c53853..000000000000
--- a/arch/tile/kernel/sysfs.c
+++ b/arch/tile/kernel/sysfs.c
@@@ -157,6 -157,64 +157,67 @@@ hvconfig_bin_read(struct file *filp, st
  	return count;
  }
  
++<<<<<<< HEAD
++=======
+ static ssize_t hv_stats_show(struct device *dev,
+ 			     struct device_attribute *attr,
+ 			     char *page)
+ {
+ 	int cpu = dev->id;
+ 	long lotar = HV_XY_TO_LOTAR(cpu_x(cpu), cpu_y(cpu));
+ 
+ 	ssize_t n = hv_confstr(HV_CONFSTR_HV_STATS,
+ 			       (unsigned long)page, PAGE_SIZE - 1,
+ 			       lotar, 0);
+ 	n = n < 0 ? 0 : min(n, (ssize_t)PAGE_SIZE - 1);
+ 	page[n] = '\0';
+ 	return n;
+ }
+ 
+ static ssize_t hv_stats_store(struct device *dev,
+ 			      struct device_attribute *attr,
+ 			      const char *page,
+ 			      size_t count)
+ {
+ 	int cpu = dev->id;
+ 	long lotar = HV_XY_TO_LOTAR(cpu_x(cpu), cpu_y(cpu));
+ 
+ 	ssize_t n = hv_confstr(HV_CONFSTR_HV_STATS, 0, 0, lotar, 1);
+ 	return n < 0 ? n : count;
+ }
+ 
+ static DEVICE_ATTR(hv_stats, 0644, hv_stats_show, hv_stats_store);
+ 
+ static int hv_stats_device_add(struct device *dev, struct subsys_interface *sif)
+ {
+ 	int err, cpu = dev->id;
+ 
+ 	if (!cpu_online(cpu))
+ 		return 0;
+ 
+ 	err = sysfs_create_file(&dev->kobj, &dev_attr_hv_stats.attr);
+ 
+ 	return err;
+ }
+ 
+ static void hv_stats_device_remove(struct device *dev,
+ 				   struct subsys_interface *sif)
+ {
+ 	int cpu = dev->id;
+ 
+ 	if (cpu_online(cpu))
+ 		sysfs_remove_file(&dev->kobj, &dev_attr_hv_stats.attr);
+ }
+ 
+ 
+ static struct subsys_interface hv_stats_interface = {
+ 	.name			= "hv_stats",
+ 	.subsys			= &cpu_subsys,
+ 	.add_dev		= hv_stats_device_add,
+ 	.remove_dev		= hv_stats_device_remove,
+ };
+ 
++>>>>>>> 71db87ba5700 (bus: subsys: update return type of ->remove_dev() to void)
  static int __init create_sysfs_entries(void)
  {
  	int err = 0;
diff --cc drivers/cpufreq/cpufreq.c
index 1eac8b4523be,6da25c10bdfd..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -1468,8 -1523,33 +1468,38 @@@ static void cpufreq_remove_dev(struct d
  	unsigned int cpu = dev->id;
  	int ret;
  
++<<<<<<< HEAD
 +	if (cpu_is_offline(cpu))
 +		return 0;
++=======
+ 	/*
+ 	 * Only possible if 'cpu' is getting physically removed now. A hotplug
+ 	 * notifier should have already been called and we just need to remove
+ 	 * link or free policy here.
+ 	 */
+ 	if (cpu_is_offline(cpu)) {
+ 		struct cpufreq_policy *policy = per_cpu(cpufreq_cpu_data, cpu);
+ 		struct cpumask mask;
+ 
+ 		if (!policy)
+ 			return;
+ 
+ 		cpumask_copy(&mask, policy->related_cpus);
+ 		cpumask_clear_cpu(cpu, &mask);
+ 
+ 		/*
+ 		 * Free policy only if all policy->related_cpus are removed
+ 		 * physically.
+ 		 */
+ 		if (cpumask_intersects(&mask, cpu_present_mask)) {
+ 			remove_cpu_dev_symlink(policy, cpu);
+ 			return;
+ 		}
+ 
+ 		cpufreq_policy_free(policy, true);
+ 		return;
+ 	}
++>>>>>>> 71db87ba5700 (bus: subsys: update return type of ->remove_dev() to void)
  
  	ret = __cpufreq_remove_dev_prepare(dev, sif);
  
diff --cc drivers/net/rionet.c
index f433b594388e,01f08a7751f7..000000000000
--- a/drivers/net/rionet.c
+++ b/drivers/net/rionet.c
@@@ -385,24 -396,26 +385,31 @@@ static int rionet_close(struct net_devi
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void rionet_remove(struct rio_dev *rdev)
++=======
+ static void rionet_remove_dev(struct device *dev, struct subsys_interface *sif)
++>>>>>>> 71db87ba5700 (bus: subsys: update return type of ->remove_dev() to void)
  {
 -	struct rio_dev *rdev = to_rio_dev(dev);
 +	struct net_device *ndev = rio_get_drvdata(rdev);
  	unsigned char netid = rdev->net->hport->id;
  	struct rionet_peer *peer, *tmp;
  
 -	if (dev_rionet_capable(rdev)) {
 -		list_for_each_entry_safe(peer, tmp, &nets[netid].peers, node) {
 -			if (peer->rdev == rdev) {
 -				if (nets[netid].active[rdev->destid]) {
 -					nets[netid].active[rdev->destid] = NULL;
 -					nets[netid].nact--;
 -				}
 +	unregister_netdev(ndev);
  
 -				list_del(&peer->node);
 -				kfree(peer);
 -				break;
 -			}
 -		}
 +	free_pages((unsigned long)nets[netid].active, get_order(sizeof(void *) *
 +			RIO_MAX_ROUTE_ENTRIES(rdev->net->hport->sys_size)));
 +	nets[netid].active = NULL;
 +
 +	list_for_each_entry_safe(peer, tmp, &nets[netid].peers, node) {
 +		list_del(&peer->node);
 +		kfree(peer);
  	}
++<<<<<<< HEAD
 +
 +	free_netdev(ndev);
++=======
++>>>>>>> 71db87ba5700 (bus: subsys: update return type of ->remove_dev() to void)
  }
  
  static void rionet_get_drvinfo(struct net_device *ndev,
diff --git a/arch/sh/kernel/cpu/sh4/sq.c b/arch/sh/kernel/cpu/sh4/sq.c
index 0a47bd3e7bee..4ca78ed71ad2 100644
--- a/arch/sh/kernel/cpu/sh4/sq.c
+++ b/arch/sh/kernel/cpu/sh4/sq.c
@@ -355,13 +355,12 @@ static int sq_dev_add(struct device *dev, struct subsys_interface *sif)
 	return error;
 }
 
-static int sq_dev_remove(struct device *dev, struct subsys_interface *sif)
+static void sq_dev_remove(struct device *dev, struct subsys_interface *sif)
 {
 	unsigned int cpu = dev->id;
 	struct kobject *kobj = sq_kobject[cpu];
 
 	kobject_put(kobj);
-	return 0;
 }
 
 static struct subsys_interface sq_interface = {
* Unmerged path arch/tile/kernel/sysfs.c
diff --git a/arch/x86/kernel/cpu/microcode/core.c b/arch/x86/kernel/cpu/microcode/core.c
index 9ca8f8b3983f..361bd7931748 100644
--- a/arch/x86/kernel/cpu/microcode/core.c
+++ b/arch/x86/kernel/cpu/microcode/core.c
@@ -377,17 +377,16 @@ static int mc_device_add(struct device *dev, struct subsys_interface *sif)
 	return err;
 }
 
-static int mc_device_remove(struct device *dev, struct subsys_interface *sif)
+static void mc_device_remove(struct device *dev, struct subsys_interface *sif)
 {
 	int cpu = dev->id;
 
 	if (!cpu_online(cpu))
-		return 0;
+		return;
 
 	pr_debug("CPU%d removed\n", cpu);
 	microcode_fini_cpu(cpu);
 	sysfs_remove_group(&dev->kobj, &mc_attr_group);
-	return 0;
 }
 
 static struct subsys_interface mc_cpu_interface = {
* Unmerged path drivers/cpufreq/cpufreq.c
* Unmerged path drivers/net/rionet.c
diff --git a/include/linux/device.h b/include/linux/device.h
index 16fec9b06e34..f4a81ba8cb5a 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -331,7 +331,7 @@ struct subsys_interface {
 	struct bus_type *subsys;
 	struct list_head node;
 	int (*add_dev)(struct device *dev, struct subsys_interface *sif);
-	int (*remove_dev)(struct device *dev, struct subsys_interface *sif);
+	void (*remove_dev)(struct device *dev, struct subsys_interface *sif);
 };
 
 int subsys_interface_register(struct subsys_interface *sif);
