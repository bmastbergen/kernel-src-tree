i40e/i40evf: Add support for IPv4 encapsulated in IPv6

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Duyck <aduyck@mirantis.com>
commit a0064728f8a34f7a5afd9df86d9cdd8210977c8d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a0064728.failed

This patch fixes two issues.  First was the fact that iphdr(skb)->protocl
was being used to test for the outer transport protocol.  This completely
breaks IPv6 support.  Second was the fact that we cleared the flag for v4
going to v6, but we didn't take care of txflags going the other way.  As
such we would have the v6 flag still set even if the inner header was v4.

	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit a0064728f8a34f7a5afd9df86d9cdd8210977c8d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_txrx.c
#	drivers/net/ethernet/intel/i40evf/i40e_txrx.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 5a3abb58e191,1404cae04b83..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@@ -2420,15 -2392,38 +2420,29 @@@ static void i40e_tx_enable_csum(struct 
  				struct i40e_ring *tx_ring,
  				u32 *cd_tunneling)
  {
 -	union {
 -		struct iphdr *v4;
 -		struct ipv6hdr *v6;
 -		unsigned char *hdr;
 -	} ip;
 -	union {
 -		struct tcphdr *tcp;
 -		struct udphdr *udp;
 -		unsigned char *hdr;
 -	} l4;
 +	struct ipv6hdr *this_ipv6_hdr;
 +	unsigned int this_tcp_hdrlen;
 +	struct iphdr *this_ip_hdr;
 +	u32 network_hdr_len;
 +	u8 l4_hdr = 0;
  	u32 l4_tunnel = 0;
 -	u8 l4_proto = 0;
 -
 -	ip.hdr = skb_network_header(skb);
 -	l4.hdr = skb_transport_header(skb);
  
  	if (skb->encapsulation) {
- 		switch (ip_hdr(skb)->protocol) {
+ 		/* define outer network header type */
+ 		if (*tx_flags & I40E_TX_FLAGS_IPV4) {
+ 			if (*tx_flags & I40E_TX_FLAGS_TSO)
+ 				*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV4;
+ 			else
+ 				*cd_tunneling |=
+ 					 I40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;
+ 			l4_proto = ip.v4->protocol;
+ 		} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
+ 			*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV6;
+ 			l4_proto = ip.v6->nexthdr;
+ 		}
+ 
+ 		/* define outer transport */
+ 		switch (l4_proto) {
  		case IPPROTO_UDP:
  			l4_tunnel = I40E_TXD_CTX_UDP_TUNNELING;
  			*tx_flags |= I40E_TX_FLAGS_UDP_TUNNEL;
@@@ -2439,21 -2435,11 +2454,29 @@@
  		default:
  			return;
  		}
++<<<<<<< HEAD
 +		network_hdr_len = skb_inner_network_header_len(skb);
 +		this_ip_hdr = inner_ip_hdr(skb);
 +		this_ipv6_hdr = inner_ipv6_hdr(skb);
 +		this_tcp_hdrlen = inner_tcp_hdrlen(skb);
 +
 +		if (*tx_flags & I40E_TX_FLAGS_IPV4) {
 +			if (*tx_flags & I40E_TX_FLAGS_TSO) {
 +				*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV4;
 +			} else {
 +				*cd_tunneling |=
 +					 I40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;
 +			}
 +		} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
 +			*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV6;
 +		}
++=======
+ 
+ 		/* switch L4 header pointer from outer to inner */
+ 		ip.hdr = skb_inner_network_header(skb);
+ 		l4.hdr = skb_inner_transport_header(skb);
+ 		l4_proto = 0;
++>>>>>>> a0064728f8a3 (i40e/i40evf: Add support for IPv4 encapsulated in IPv6)
  
  		/* Now set the ctx descriptor fields */
  		*cd_tunneling |= (skb_network_header_len(skb) >> 2) <<
@@@ -2462,24 -2448,13 +2485,34 @@@
  				   ((skb_inner_network_offset(skb) -
  					skb_transport_offset(skb)) >> 1) <<
  				   I40E_TXD_CTX_QW0_NATLEN_SHIFT;
++<<<<<<< HEAD
 +		if (this_ip_hdr->version == 6) {
 +			*tx_flags &= ~I40E_TX_FLAGS_IPV4;
 +			*tx_flags |= I40E_TX_FLAGS_IPV6;
 +		}
 +		if ((tx_ring->flags & I40E_TXR_FLAGS_OUTER_UDP_CSUM) &&
 +		    (l4_tunnel == I40E_TXD_CTX_UDP_TUNNELING)        &&
 +		    (*cd_tunneling & I40E_TXD_CTX_QW0_EXT_IP_MASK)) {
 +			oudph->check = ~csum_tcpudp_magic(oiph->saddr,
 +					oiph->daddr,
 +					(skb->len - skb_transport_offset(skb)),
 +					IPPROTO_UDP, 0);
 +			*cd_tunneling |= I40E_TXD_CTX_QW0_L4T_CS_MASK;
 +		}
 +	} else {
 +		network_hdr_len = skb_network_header_len(skb);
 +		this_ip_hdr = ip_hdr(skb);
 +		this_ipv6_hdr = ipv6_hdr(skb);
 +		this_tcp_hdrlen = tcp_hdrlen(skb);
++=======
+ 
+ 		/* reset type as we transition from outer to inner headers */
+ 		*tx_flags &= ~(I40E_TX_FLAGS_IPV4 | I40E_TX_FLAGS_IPV6);
+ 		if (ip.v4->version == 4)
+ 			*tx_flags |= I40E_TX_FLAGS_IPV4;
+ 		if (ip.v6->version == 6)
+ 			*tx_flags |= I40E_TX_FLAGS_IPV6;
++>>>>>>> a0064728f8a3 (i40e/i40evf: Add support for IPv4 encapsulated in IPv6)
  	}
  
  	/* Enable IP checksum offloads */
diff --cc drivers/net/ethernet/intel/i40evf/i40e_txrx.c
index f6384b0c8220,39d5f807f08c..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
@@@ -1628,15 -1609,38 +1628,29 @@@ static void i40e_tx_enable_csum(struct 
  				struct i40e_ring *tx_ring,
  				u32 *cd_tunneling)
  {
 -	union {
 -		struct iphdr *v4;
 -		struct ipv6hdr *v6;
 -		unsigned char *hdr;
 -	} ip;
 -	union {
 -		struct tcphdr *tcp;
 -		struct udphdr *udp;
 -		unsigned char *hdr;
 -	} l4;
 +	struct ipv6hdr *this_ipv6_hdr;
 +	unsigned int this_tcp_hdrlen;
 +	struct iphdr *this_ip_hdr;
 +	u32 network_hdr_len;
 +	u8 l4_hdr = 0;
  	u32 l4_tunnel = 0;
 -	u8 l4_proto = 0;
 -
 -	ip.hdr = skb_network_header(skb);
 -	l4.hdr = skb_transport_header(skb);
  
  	if (skb->encapsulation) {
- 		switch (ip_hdr(skb)->protocol) {
+ 		/* define outer network header type */
+ 		if (*tx_flags & I40E_TX_FLAGS_IPV4) {
+ 			if (*tx_flags & I40E_TX_FLAGS_TSO)
+ 				*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV4;
+ 			else
+ 				*cd_tunneling |=
+ 					 I40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;
+ 			l4_proto = ip.v4->protocol;
+ 		} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
+ 			*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV6;
+ 			l4_proto = ip.v6->nexthdr;
+ 		}
+ 
+ 		/* define outer transport */
+ 		switch (l4_proto) {
  		case IPPROTO_UDP:
  			l4_tunnel = I40E_TXD_CTX_UDP_TUNNELING;
  			*tx_flags |= I40E_TX_FLAGS_VXLAN_TUNNEL;
@@@ -1644,21 -1652,11 +1662,29 @@@
  		default:
  			return;
  		}
++<<<<<<< HEAD
 +		network_hdr_len = skb_inner_network_header_len(skb);
 +		this_ip_hdr = inner_ip_hdr(skb);
 +		this_ipv6_hdr = inner_ipv6_hdr(skb);
 +		this_tcp_hdrlen = inner_tcp_hdrlen(skb);
 +
 +		if (*tx_flags & I40E_TX_FLAGS_IPV4) {
 +			if (*tx_flags & I40E_TX_FLAGS_TSO) {
 +				*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV4;
 +			} else {
 +				*cd_tunneling |=
 +					 I40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;
 +			}
 +		} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
 +			*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV6;
 +		}
++=======
+ 
+ 		/* switch L4 header pointer from outer to inner */
+ 		ip.hdr = skb_inner_network_header(skb);
+ 		l4.hdr = skb_inner_transport_header(skb);
+ 		l4_proto = 0;
++>>>>>>> a0064728f8a3 (i40e/i40evf: Add support for IPv4 encapsulated in IPv6)
  
  		/* Now set the ctx descriptor fields */
  		*cd_tunneling |= (skb_network_header_len(skb) >> 2) <<
@@@ -1667,26 -1665,13 +1693,36 @@@
  				   ((skb_inner_network_offset(skb) -
  					skb_transport_offset(skb)) >> 1) <<
  				   I40E_TXD_CTX_QW0_NATLEN_SHIFT;
++<<<<<<< HEAD
 +		if (this_ip_hdr->version == 6) {
 +			*tx_flags &= ~I40E_TX_FLAGS_IPV4;
 +			*tx_flags |= I40E_TX_FLAGS_IPV6;
 +		}
 +
 +
 +		if ((tx_ring->flags & I40E_TXR_FLAGS_OUTER_UDP_CSUM) &&
 +		    (l4_tunnel == I40E_TXD_CTX_UDP_TUNNELING)        &&
 +		    (*cd_tunneling & I40E_TXD_CTX_QW0_EXT_IP_MASK)) {
 +			oudph->check = ~csum_tcpudp_magic(oiph->saddr,
 +					oiph->daddr,
 +					(skb->len - skb_transport_offset(skb)),
 +					IPPROTO_UDP, 0);
 +			*cd_tunneling |= I40E_TXD_CTX_QW0_L4T_CS_MASK;
 +		}
 +	} else {
 +		network_hdr_len = skb_network_header_len(skb);
 +		this_ip_hdr = ip_hdr(skb);
 +		this_ipv6_hdr = ipv6_hdr(skb);
 +		this_tcp_hdrlen = tcp_hdrlen(skb);
++=======
+ 
+ 		/* reset type as we transition from outer to inner headers */
+ 		*tx_flags &= ~(I40E_TX_FLAGS_IPV4 | I40E_TX_FLAGS_IPV6);
+ 		if (ip.v4->version == 4)
+ 			*tx_flags |= I40E_TX_FLAGS_IPV4;
+ 		if (ip.v6->version == 6)
+ 			*tx_flags |= I40E_TX_FLAGS_IPV6;
++>>>>>>> a0064728f8a3 (i40e/i40evf: Add support for IPv4 encapsulated in IPv6)
  	}
  
  	/* Enable IP checksum offloads */
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_txrx.c
