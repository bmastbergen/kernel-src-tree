hv_netvsc: try linearizing big SKBs before dropping them

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit e88f7e078e47d4261a22e6f20a574620cbfc7a4b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e88f7e07.failed

In netvsc_start_xmit() we can handle packets which are scattered around not
more than MAX_PAGE_BUFFER_COUNT-2 pages. It is, however, easy to create a
packet which is not big in size but occupies more pages (e.g. if it uses frags
on compound pages boundaries). When we drop such packet it cases sender to try
resending it but in most cases it will try resending the same packet which will
also get dropped, this will cause the particular connection to stick. To solve
the issue we can try linearizing skb.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e88f7e078e47d4261a22e6f20a574620cbfc7a4b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index f6bc78f79972,448716787e73..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -383,37 -384,59 +384,65 @@@ static int netvsc_start_xmit(struct sk_
  	int  hdr_offset;
  	u32 net_trans_info;
  	u32 hash;
++<<<<<<< HEAD
 +	u32 skb_length = skb->len;
++=======
+ 	u32 skb_length;
+ 	u32 head_room;
+ 	u32 pkt_sz;
+ 	struct hv_page_buffer page_buf[MAX_PAGE_BUFFER_COUNT];
++>>>>>>> e88f7e078e47 (hv_netvsc: try linearizing big SKBs before dropping them)
  
  
  	/* We will atmost need two pages to describe the rndis
  	 * header. We can only transmit MAX_PAGE_BUFFER_COUNT number
- 	 * of pages in a single packet.
+ 	 * of pages in a single packet. If skb is scattered around
+ 	 * more pages we try linearizing it.
  	 */
+ 
+ check_size:
+ 	skb_length = skb->len;
+ 	head_room = skb_headroom(skb);
  	num_data_pgs = netvsc_get_slots(skb) + 2;
++<<<<<<< HEAD
 +	if (num_data_pgs > MAX_PAGE_BUFFER_COUNT) {
 +		netdev_err(net, "Packet too big: %u\n", skb->len);
 +		dev_kfree_skb(skb);
 +		net->stats.tx_dropped++;
 +		return NETDEV_TX_OK;
++=======
+ 	if (num_data_pgs > MAX_PAGE_BUFFER_COUNT && linear) {
+ 		net_alert_ratelimited("packet too big: %u pages (%u bytes)\n",
+ 				      num_data_pgs, skb->len);
+ 		ret = -EFAULT;
+ 		goto drop;
+ 	} else if (num_data_pgs > MAX_PAGE_BUFFER_COUNT) {
+ 		if (skb_linearize(skb)) {
+ 			net_alert_ratelimited("failed to linearize skb\n");
+ 			ret = -ENOMEM;
+ 			goto drop;
+ 		}
+ 		linear = true;
+ 		goto check_size;
++>>>>>>> e88f7e078e47 (hv_netvsc: try linearizing big SKBs before dropping them)
  	}
  
 -	pkt_sz = sizeof(struct hv_netvsc_packet) + RNDIS_AND_PPI_SIZE;
 -
 -	if (head_room < pkt_sz) {
 -		packet = kmalloc(pkt_sz, GFP_ATOMIC);
 -		if (!packet) {
 -			/* out of memory, drop packet */
 -			netdev_err(net, "unable to alloc hv_netvsc_packet\n");
 -			ret = -ENOMEM;
 -			goto drop;
 -		}
 -		packet->part_of_skb = false;
 -	} else {
 -		/* Use the headroom for building up the packet */
 -		packet = (struct hv_netvsc_packet *)skb->head;
 -		packet->part_of_skb = true;
 +	/* Allocate a netvsc packet based on # of frags. */
 +	packet = kzalloc(sizeof(struct hv_netvsc_packet) +
 +			 (num_data_pgs * sizeof(struct hv_page_buffer)) +
 +			 sizeof(struct rndis_message) +
 +			 NDIS_VLAN_PPI_SIZE + NDIS_CSUM_PPI_SIZE +
 +			 NDIS_LSO_PPI_SIZE + NDIS_HASH_PPI_SIZE, GFP_ATOMIC);
 +	if (!packet) {
 +		/* out of memory, drop packet */
 +		netdev_err(net, "unable to allocate hv_netvsc_packet\n");
 +
 +		dev_kfree_skb(skb);
 +		net->stats.tx_dropped++;
 +		return NETDEV_TX_OK;
  	}
  
 -	packet->status = 0;
 -	packet->xmit_more = skb->xmit_more;
 -
  	packet->vlan_tci = skb->vlan_tci;
 -	packet->page_buf = page_buf;
  
  	packet->q_idx = skb_get_queue_mapping(skb);
  
* Unmerged path drivers/net/hyperv/netvsc_drv.c
