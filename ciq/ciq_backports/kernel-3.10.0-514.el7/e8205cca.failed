iscsi-target: split iscsi_target_rx_thread()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Varun Prakash <varun@chelsio.com>
commit e8205cca0abd126418c18030fb8c9ef272080d70
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e8205cca.failed

split iscsi_target_rx_thread() into two parts,
1. iscsi_target_rx_thread() is common to all
   transport drivers, it will call Rx function
   registered by transport driver.

2. iscsit_get_rx_pdu() is Rx function for
   ISCSI_TCP transport.

	Signed-off-by: Varun Prakash <varun@chelsio.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit e8205cca0abd126418c18030fb8c9ef272080d70)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/iscsi/iscsi_target.c
diff --cc drivers/target/iscsi/iscsi_target.c
index c4fef98585d3,a827b7afe42c..000000000000
--- a/drivers/target/iscsi/iscsi_target.c
+++ b/drivers/target/iscsi/iscsi_target.c
@@@ -521,6 -682,8 +522,11 @@@ static struct iscsit_transport iscsi_ta
  	.iscsit_queue_data_in	= iscsit_queue_rsp,
  	.iscsit_queue_status	= iscsit_queue_rsp,
  	.iscsit_aborted_task	= iscsit_aborted_task,
++<<<<<<< HEAD
++=======
+ 	.iscsit_xmit_pdu	= iscsit_xmit_pdu,
+ 	.iscsit_get_rx_pdu	= iscsit_get_rx_pdu,
++>>>>>>> e8205cca0abd (iscsi-target: split iscsi_target_rx_thread())
  	.iscsit_get_sup_prot_ops = iscsit_get_sup_prot_ops,
  };
  
@@@ -4075,30 -3922,23 +4081,47 @@@ reject
  	return iscsit_add_reject(conn, ISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);
  }
  
++<<<<<<< HEAD
 +int iscsi_target_rx_thread(void *arg)
++=======
+ static bool iscsi_target_check_conn_state(struct iscsi_conn *conn)
+ {
+ 	bool ret;
+ 
+ 	spin_lock_bh(&conn->state_lock);
+ 	ret = (conn->conn_state != TARG_CONN_STATE_LOGGED_IN);
+ 	spin_unlock_bh(&conn->state_lock);
+ 
+ 	return ret;
+ }
+ 
+ static void iscsit_get_rx_pdu(struct iscsi_conn *conn)
++>>>>>>> e8205cca0abd (iscsi-target: split iscsi_target_rx_thread())
  {
  	int ret;
  	u8 buffer[ISCSI_HDR_LEN], opcode;
  	u32 checksum = 0, digest = 0;
- 	struct iscsi_conn *conn = arg;
  	struct kvec iov;
++<<<<<<< HEAD
 +	/*
 +	 * Allow ourselves to be interrupted by SIGINT so that a
 +	 * connection recovery / failure event can be triggered externally.
 +	 */
 +	allow_signal(SIGINT);
 +
 +	if (conn->conn_transport->transport_type == ISCSI_INFINIBAND) {
 +		struct completion comp;
 +		int rc;
 +
 +		init_completion(&comp);
 +		rc = wait_for_completion_interruptible(&comp);
 +		if (rc < 0)
 +			goto transport_err;
 +
 +		goto transport_err;
 +	}
++=======
++>>>>>>> e8205cca0abd (iscsi-target: split iscsi_target_rx_thread())
  
  	while (!kthread_should_stop()) {
  		/*
@@@ -4126,10 -3966,10 +4149,10 @@@
  			ret = rx_data(conn, &iov, 1, ISCSI_CRC_LEN);
  			if (ret != ISCSI_CRC_LEN) {
  				iscsit_rx_thread_wait_for_tcp(conn);
- 				goto transport_err;
+ 				return;
  			}
  
 -			iscsit_do_crypto_hash_buf(conn->conn_rx_hash,
 +			iscsit_do_crypto_hash_buf(&conn->conn_rx_hash,
  					buffer, ISCSI_HDR_LEN,
  					0, NULL, (u8 *)&checksum);
  
* Unmerged path drivers/target/iscsi/iscsi_target.c
