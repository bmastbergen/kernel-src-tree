mei: iamthif: use client write functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 8660172e1d6528be02eba78516ff8282e694bb26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8660172e.failed

Reduce code duplication in amthif code by reusing
regular client write functions.
Add completed flag to cb so amthif client can add
rx credits on write completion

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 8660172e1d6528be02eba78516ff8282e694bb26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/amthif.c
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/amthif.c
index a11128c1997f,916625a8f037..000000000000
--- a/drivers/misc/mei/amthif.c
+++ b/drivers/misc/mei/amthif.c
@@@ -259,120 -257,88 +259,155 @@@ out
  /**
   * mei_amthif_send_cmd - send amthif command to the ME
   *
-  * @dev: the device structure
+  * @cl: the host client
   * @cb: mei call back struct
   *
++<<<<<<< HEAD
 + * returns 0 on success, <0 on failure.
 + *
++=======
+  * Return: 0 on success, <0 on failure.
++>>>>>>> 8660172e1d65 (mei: iamthif: use client write functions)
   */
- static int mei_amthif_send_cmd(struct mei_device *dev, struct mei_cl_cb *cb)
+ static int mei_amthif_send_cmd(struct mei_cl *cl, struct mei_cl_cb *cb)
  {
++<<<<<<< HEAD
 +	struct mei_msg_hdr mei_hdr;
++=======
+ 	struct mei_device *dev;
++>>>>>>> 8660172e1d65 (mei: iamthif: use client write functions)
  	int ret;
  
- 	if (!dev || !cb)
+ 	if (!cl->dev || !cb)
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	dev_dbg(&dev->pdev->dev, "write data to amthif client.\n");
++=======
+ 	dev = cl->dev;
++>>>>>>> 8660172e1d65 (mei: iamthif: use client write functions)
  
  	dev->iamthif_state = MEI_IAMTHIF_WRITING;
  	dev->iamthif_current_cb = cb;
  	dev->iamthif_file_object = cb->file_object;
  	dev->iamthif_canceled = false;
++<<<<<<< HEAD
 +	dev->iamthif_ioctl = true;
 +	dev->iamthif_msg_buf_size = cb->request_buffer.size;
 +	memcpy(dev->iamthif_msg_buf, cb->request_buffer.data,
 +	       cb->request_buffer.size);
 +
 +	ret = mei_cl_flow_ctrl_creds(&dev->iamthif_cl);
 +	if (ret < 0)
 +		return ret;
 +
 +	if (ret && mei_hbuf_acquire(dev)) {
 +		ret = 0;
 +		if (cb->request_buffer.size > mei_hbuf_max_len(dev)) {
 +			mei_hdr.length = mei_hbuf_max_len(dev);
 +			mei_hdr.msg_complete = 0;
 +		} else {
 +			mei_hdr.length = cb->request_buffer.size;
 +			mei_hdr.msg_complete = 1;
 +		}
 +
 +		mei_hdr.host_addr = dev->iamthif_cl.host_client_id;
 +		mei_hdr.me_addr = dev->iamthif_cl.me_client_id;
 +		mei_hdr.reserved = 0;
 +		mei_hdr.internal = 0;
 +		dev->iamthif_msg_buf_index += mei_hdr.length;
 +		ret = mei_write_message(dev, &mei_hdr, dev->iamthif_msg_buf);
 +		if (ret)
 +			return ret;
 +
 +		if (mei_hdr.msg_complete) {
 +			if (mei_cl_flow_ctrl_reduce(&dev->iamthif_cl))
 +				return -EIO;
 +			dev->iamthif_flow_control_pending = true;
 +			dev->iamthif_state = MEI_IAMTHIF_FLOW_CONTROL;
 +			dev_dbg(&dev->pdev->dev, "add amthif cb to write waiting list\n");
 +			dev->iamthif_current_cb = cb;
 +			dev->iamthif_file_object = cb->file_object;
 +			list_add_tail(&cb->list, &dev->write_waiting_list.list);
 +		} else {
 +			dev_dbg(&dev->pdev->dev, "message does not complete, so add amthif cb to write list.\n");
 +			list_add_tail(&cb->list, &dev->write_list.list);
 +		}
 +	} else {
 +		list_add_tail(&cb->list, &dev->write_list.list);
 +	}
++=======
+ 
+ 	ret = mei_cl_write(cl, cb, false);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	if (cb->completed)
+ 		cb->status = mei_amthif_read_start(cl, cb->file_object);
+ 
++>>>>>>> 8660172e1d65 (mei: iamthif: use client write functions)
  	return 0;
  }
  
  /**
++<<<<<<< HEAD
 + * mei_amthif_write - write amthif data to amthif client
 + *
 + * @dev: the device structure
 + * @cb: mei call back struct
 + *
 + * returns 0 on success, <0 on failure.
 + *
 + */
 +int mei_amthif_write(struct mei_device *dev, struct mei_cl_cb *cb)
 +{
 +	int ret;
 +
 +	if (!dev || !cb)
 +		return -ENODEV;
 +
 +	ret = mei_io_cb_alloc_resp_buf(cb, dev->iamthif_mtu);
 +	if (ret)
 +		return ret;
 +
 +	cb->fop_type = MEI_FOP_WRITE;
 +
 +	if (!list_empty(&dev->amthif_cmd_list.list) ||
 +	    dev->iamthif_state != MEI_IAMTHIF_IDLE) {
 +		dev_dbg(&dev->pdev->dev,
 +			"amthif state = %d\n", dev->iamthif_state);
 +		dev_dbg(&dev->pdev->dev, "AMTHIF: add cb to the wait list\n");
 +		list_add_tail(&cb->list, &dev->amthif_cmd_list.list);
 +		return 0;
 +	}
 +	return mei_amthif_send_cmd(dev, cb);
 +}
 +/**
 + * mei_amthif_run_next_cmd
 + *
 + * @dev: the device structure
 + *
 + * returns 0 on success, <0 on failure.
++=======
+  * mei_amthif_run_next_cmd - send next amt command from queue
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success, <0 on failure.
++>>>>>>> 8660172e1d65 (mei: iamthif: use client write functions)
   */
- void mei_amthif_run_next_cmd(struct mei_device *dev)
+ int mei_amthif_run_next_cmd(struct mei_device *dev)
  {
+ 	struct mei_cl *cl = &dev->iamthif_cl;
  	struct mei_cl_cb *cb;
++<<<<<<< HEAD
 +	struct mei_cl_cb *next;
 +	int status;
 +
 +	if (!dev)
 +		return;
++=======
++>>>>>>> 8660172e1d65 (mei: iamthif: use client write functions)
  
  	dev->iamthif_msg_buf_size = 0;
  	dev->iamthif_msg_buf_index = 0;
@@@ -382,20 -347,42 +417,55 @@@
  	dev->iamthif_timer = 0;
  	dev->iamthif_file_object = NULL;
  
 -	dev_dbg(dev->dev, "complete amthif cmd_list cb.\n");
 +	dev_dbg(&dev->pdev->dev, "complete amthif cmd_list cb.\n");
  
++<<<<<<< HEAD
 +	list_for_each_entry_safe(cb, next, &dev->amthif_cmd_list.list, list) {
 +		list_del(&cb->list);
 +		if (!cb->cl)
 +			continue;
 +		status = mei_amthif_send_cmd(dev, cb);
 +		if (status)
 +			dev_warn(&dev->pdev->dev, "amthif write failed status = %d\n",
 +						status);
 +		break;
 +	}
++=======
+ 	cb = list_first_entry_or_null(&dev->amthif_cmd_list.list,
+ 					typeof(*cb), list);
+ 	if (!cb)
+ 		return 0;
+ 
+ 	list_del_init(&cb->list);
+ 	return mei_amthif_send_cmd(cl, cb);
++>>>>>>> 8660172e1d65 (mei: iamthif: use client write functions)
  }
  
+ /**
+  * mei_amthif_write - write amthif data to amthif client
+  *
+  * @cl: host client
+  * @cb: mei call back struct
+  *
+  * Return: 0 on success, <0 on failure.
+  */
+ int mei_amthif_write(struct mei_cl *cl, struct mei_cl_cb *cb)
+ {
+ 
+ 	struct mei_device *dev;
+ 
+ 	if (WARN_ON(!cl || !cl->dev))
+ 		return -ENODEV;
+ 
+ 	if (WARN_ON(!cb))
+ 		return -EINVAL;
+ 
+ 	dev = cl->dev;
+ 
+ 	cb->fop_type = MEI_FOP_WRITE;
+ 	list_add_tail(&cb->list, &dev->amthif_cmd_list.list);
+ 	return mei_amthif_run_next_cmd(dev);
+ }
  
  unsigned int mei_amthif_poll(struct mei_device *dev,
  		struct file *file, poll_table *wait)
@@@ -436,71 -422,14 +506,71 @@@
  int mei_amthif_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,
  			 struct mei_cl_cb *cmpl_list)
  {
- 	struct mei_device *dev = cl->dev;
- 	struct mei_msg_hdr mei_hdr;
- 	size_t len = dev->iamthif_msg_buf_size - dev->iamthif_msg_buf_index;
- 	u32 msg_slots = mei_data2slots(len);
- 	int slots;
- 	int rets;
+ 	int ret;
  
- 	rets = mei_cl_flow_ctrl_creds(cl);
- 	if (rets < 0)
- 		return rets;
+ 	ret = mei_cl_irq_write(cl, cb, cmpl_list);
+ 	if (ret)
+ 		return ret;
  
++<<<<<<< HEAD
 +	if (rets == 0) {
 +		cl_dbg(dev, cl, "No flow control credentials: not sending.\n");
 +		return 0;
 +	}
 +
 +	mei_hdr.host_addr = cl->host_client_id;
 +	mei_hdr.me_addr = cl->me_client_id;
 +	mei_hdr.reserved = 0;
 +	mei_hdr.internal = 0;
 +
 +	slots = mei_hbuf_empty_slots(dev);
 +
 +	if (slots >= msg_slots) {
 +		mei_hdr.length = len;
 +		mei_hdr.msg_complete = 1;
 +	/* Split the message only if we can write the whole host buffer */
 +	} else if (slots == dev->hbuf_depth) {
 +		msg_slots = slots;
 +		len = (slots * sizeof(u32)) - sizeof(struct mei_msg_hdr);
 +		mei_hdr.length = len;
 +		mei_hdr.msg_complete = 0;
 +	} else {
 +		/* wait for next time the host buffer is empty */
 +		return 0;
 +	}
 +
 +	dev_dbg(&dev->pdev->dev, MEI_HDR_FMT,  MEI_HDR_PRM(&mei_hdr));
 +
 +	rets = mei_write_message(dev, &mei_hdr,
 +			dev->iamthif_msg_buf + dev->iamthif_msg_buf_index);
 +	if (rets) {
 +		dev->iamthif_state = MEI_IAMTHIF_IDLE;
 +		cl->status = rets;
 +		list_del(&cb->list);
 +		return rets;
 +	}
 +
 +	if (mei_cl_flow_ctrl_reduce(cl))
 +		return -EIO;
 +
 +	dev->iamthif_msg_buf_index += mei_hdr.length;
 +	cl->status = 0;
 +
 +	if (mei_hdr.msg_complete) {
 +		dev->iamthif_state = MEI_IAMTHIF_FLOW_CONTROL;
 +		dev->iamthif_flow_control_pending = true;
 +
 +		/* save iamthif cb sent to amthif client */
 +		cb->buf_idx = dev->iamthif_msg_buf_index;
 +		dev->iamthif_current_cb = cb;
 +
 +		list_move_tail(&cb->list, &dev->write_waiting_list.list);
 +	}
 +
++=======
+ 	if (cb->completed)
+ 		cb->status = mei_amthif_read_start(cl, cb->file_object);
++>>>>>>> 8660172e1d65 (mei: iamthif: use client write functions)
  
  	return 0;
  }
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,2f2242f1bed1..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -189,8 -191,17 +189,22 @@@ struct mei_cl
  /**
   * struct mei_cl_cb - file operation callback structure
   *
++<<<<<<< HEAD
 + * @cl - file client who is running this operation
 + * @fop_type - file operation type
++=======
+  * @list: link in callback queue
+  * @cl: file client who is running this operation
+  * @fop_type: file operation type
+  * @request_buffer: buffer to store request data
+  * @response_buffer: buffer to store response data
+  * @buf_idx: last read index
+  * @read_time: last read operation time stamp (iamthif)
+  * @file_object: pointer to file structure
+  * @status: io status of the cb
+  * @internal: communication between driver and FW flag
+  * @completed: the transfer or reception has completed
++>>>>>>> 8660172e1d65 (mei: iamthif: use client write functions)
   */
  struct mei_cl_cb {
  	struct list_head list;
@@@ -201,10 -212,34 +215,11 @@@
  	unsigned long buf_idx;
  	unsigned long read_time;
  	struct file *file_object;
 -	int status;
  	u32 internal:1;
+ 	u32 completed:1;
  };
  
 -/**
 - * struct mei_cl - me client host representation
 - *    carried in file->private_data
 - *
 - * @link: link in the clients list
 - * @dev: mei parent device
 - * @state: file operation state
 - * @tx_wait: wait queue for tx completion
 - * @rx_wait: wait queue for rx completion
 - * @wait:  wait queue for management operation
 - * @status: connection status
 - * @cl_uuid: client uuid name
 - * @host_client_id: host id
 - * @me_client_id: me/fw id
 - * @mei_flow_ctrl_creds: transmit flow credentials
 - * @timer_count:  watchdog timer for operation completion
 - * @reading_state: state of the rx
 - * @writing_state: state of the tx
 - * @read_cb: current pending reading callback
 - *
 - * @device: device on the mei client bus
 - * @device_link:  link to bus clients
 - */
 +/* MEI client instance carried as file->private_data*/
  struct mei_cl {
  	struct list_head link;
  	struct mei_device *dev;
* Unmerged path drivers/misc/mei/amthif.c
diff --git a/drivers/misc/mei/client.c b/drivers/misc/mei/client.c
index 3c539de435ba..4f02104a9ad8 100644
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@ -865,6 +865,7 @@ int mei_cl_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,
 	cl->status = 0;
 	cl->writing_state = MEI_WRITING;
 	cb->buf_idx += mei_hdr.length;
+	cb->completed = mei_hdr.msg_complete == 1;
 
 	if (mei_hdr.msg_complete) {
 		if (mei_cl_flow_ctrl_reduce(cl))
@@ -952,6 +953,7 @@ int mei_cl_write(struct mei_cl *cl, struct mei_cl_cb *cb, bool blocking)
 
 	cl->writing_state = MEI_WRITING;
 	cb->buf_idx = mei_hdr.length;
+	cb->completed = mei_hdr.msg_complete == 1;
 
 out:
 	if (mei_hdr.msg_complete) {
diff --git a/drivers/misc/mei/main.c b/drivers/misc/mei/main.c
index b23f9eba9e3a..59d8c0098848 100644
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@ -425,7 +425,7 @@ static ssize_t mei_write(struct file *file, const char __user *ubuf,
 		cl->sm_state |= MEI_WD_STATE_INDEPENDENCE_MSG_SENT;
 
 	if (cl == &dev->iamthif_cl) {
-		rets = mei_amthif_write(dev, write_cb);
+		rets = mei_amthif_write(cl, write_cb);
 
 		if (rets) {
 			dev_err(&dev->pdev->dev,
* Unmerged path drivers/misc/mei/mei_dev.h
