ipv4: L3 hash-based multipath

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peter Nørlund <pch@ordbogen.com>
commit 0e884c78ee19e902f300ed147083c28a0c6302f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0e884c78.failed

Replaces the per-packet multipath with a hash-based multipath using
source and destination address.

	Signed-off-by: Peter Nørlund <pch@ordbogen.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0e884c78ee19e902f300ed147083c28a0c6302f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip_fib.h
#	net/ipv4/fib_semantics.c
diff --cc include/net/ip_fib.h
index 5d7223476d03,7a51fd8d99e4..000000000000
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@@ -309,10 -315,20 +309,23 @@@ static inline int fib_num_tclassid_user
  
  /* Exported by fib_semantics.c */
  int ip_fib_check_default(__be32 gw, struct net_device *dev);
 -int fib_sync_down_dev(struct net_device *dev, unsigned long event);
 +int fib_sync_down_dev(struct net_device *dev, int force);
  int fib_sync_down_addr(struct net *net, __be32 local);
++<<<<<<< HEAD
 +int fib_sync_up(struct net_device *dev);
 +void fib_select_multipath(struct fib_result *res);
++=======
+ int fib_sync_up(struct net_device *dev, unsigned int nh_flags);
+ 
+ extern u32 fib_multipath_secret __read_mostly;
+ 
+ static inline int fib_multipath_hash(__be32 saddr, __be32 daddr)
+ {
+ 	return jhash_2words(saddr, daddr, fib_multipath_secret) >> 1;
+ }
+ 
+ void fib_select_multipath(struct fib_result *res, int hash);
++>>>>>>> 0e884c78ee19 (ipv4: L3 hash-based multipath)
  
  /* Exported by fib_trie.c */
  void fib_trie_init(void);
diff --cc net/ipv4/fib_semantics.c
index c1ff5dc475fa,0c49d2f3bbc0..000000000000
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@@ -479,12 -523,103 +478,72 @@@ static int fib_get_nhs(struct fib_info 
  	} endfor_nexthops(fi);
  
  	return 0;
 -
 -err_inval:
 -	ret = -EINVAL;
 -
 -errout:
 -	return ret;
  }
  
- #endif
+ static void fib_rebalance(struct fib_info *fi)
+ {
+ 	int total;
+ 	int w;
+ 	struct in_device *in_dev;
+ 
+ 	if (fi->fib_nhs < 2)
+ 		return;
+ 
+ 	total = 0;
+ 	for_nexthops(fi) {
+ 		if (nh->nh_flags & RTNH_F_DEAD)
+ 			continue;
+ 
+ 		in_dev = __in_dev_get_rcu(nh->nh_dev);
+ 
+ 		if (in_dev &&
+ 		    IN_DEV_IGNORE_ROUTES_WITH_LINKDOWN(in_dev) &&
+ 		    nh->nh_flags & RTNH_F_LINKDOWN)
+ 			continue;
+ 
+ 		total += nh->nh_weight;
+ 	} endfor_nexthops(fi);
+ 
+ 	w = 0;
+ 	change_nexthops(fi) {
+ 		int upper_bound;
+ 
+ 		in_dev = __in_dev_get_rcu(nexthop_nh->nh_dev);
+ 
+ 		if (nexthop_nh->nh_flags & RTNH_F_DEAD) {
+ 			upper_bound = -1;
+ 		} else if (in_dev &&
+ 			   IN_DEV_IGNORE_ROUTES_WITH_LINKDOWN(in_dev) &&
+ 			   nexthop_nh->nh_flags & RTNH_F_LINKDOWN) {
+ 			upper_bound = -1;
+ 		} else {
+ 			w += nexthop_nh->nh_weight;
+ 			upper_bound = DIV_ROUND_CLOSEST(2147483648LL * w,
+ 							total) - 1;
+ 		}
+ 
+ 		atomic_set(&nexthop_nh->nh_upper_bound, upper_bound);
+ 	} endfor_nexthops(fi);
+ 
+ 	net_get_random_once(&fib_multipath_secret,
+ 			    sizeof(fib_multipath_secret));
+ }
+ 
+ static inline void fib_add_weight(struct fib_info *fi,
+ 				  const struct fib_nh *nh)
+ {
+ 	fi->fib_weight += nh->nh_weight;
+ }
+ 
+ #else /* CONFIG_IP_ROUTE_MULTIPATH */
+ 
+ #define fib_rebalance(fi) do { } while (0)
+ #define fib_add_weight(fi, nh) do { } while (0)
+ 
+ #endif /* CONFIG_IP_ROUTE_MULTIPATH */
  
 -static int fib_encap_match(struct net *net, u16 encap_type,
 -			   struct nlattr *encap,
 -			   int oif, const struct fib_nh *nh,
 -			   const struct fib_config *cfg)
 -{
 -	struct lwtunnel_state *lwtstate;
 -	struct net_device *dev = NULL;
 -	int ret, result = 0;
 -
 -	if (encap_type == LWTUNNEL_ENCAP_NONE)
 -		return 0;
 -
 -	if (oif)
 -		dev = __dev_get_by_index(net, oif);
 -	ret = lwtunnel_build_state(dev, encap_type, encap,
 -				   AF_INET, cfg, &lwtstate);
 -	if (!ret) {
 -		result = lwtunnel_cmp_encap(lwtstate, nh->nh_lwtstate);
 -		lwtstate_free(lwtstate);
 -	}
 -
 -	return result;
 -}
 -
  int fib_nh_match(struct fib_config *cfg, struct fib_info *fi)
  {
 -	struct net *net = cfg->fc_nlinfo.nl_net;
  #ifdef CONFIG_IP_ROUTE_MULTIPATH
  	struct rtnexthop *rtnh;
  	int remaining;
@@@ -1146,13 -1370,15 +1208,25 @@@ int fib_sync_down_dev(struct net_devic
  				dead++;
  			else if (nexthop_nh->nh_dev == dev &&
  				 nexthop_nh->nh_scope != scope) {
++<<<<<<< HEAD
 +				nexthop_nh->nh_flags |= RTNH_F_DEAD;
 +#ifdef CONFIG_IP_ROUTE_MULTIPATH
 +				spin_lock_bh(&fib_multipath_lock);
 +				fi->fib_power -= nexthop_nh->nh_power;
 +				nexthop_nh->nh_power = 0;
 +				spin_unlock_bh(&fib_multipath_lock);
 +#endif
++=======
+ 				switch (event) {
+ 				case NETDEV_DOWN:
+ 				case NETDEV_UNREGISTER:
+ 					nexthop_nh->nh_flags |= RTNH_F_DEAD;
+ 					/* fall through */
+ 				case NETDEV_CHANGE:
+ 					nexthop_nh->nh_flags |= RTNH_F_LINKDOWN;
+ 					break;
+ 				}
++>>>>>>> 0e884c78ee19 (ipv4: L3 hash-based multipath)
  				dead++;
  			}
  #ifdef CONFIG_IP_ROUTE_MULTIPATH
@@@ -1163,9 -1390,19 +1237,11 @@@
  #endif
  		} endfor_nexthops(fi)
  		if (dead == fi->fib_nhs) {
 -			switch (event) {
 -			case NETDEV_DOWN:
 -			case NETDEV_UNREGISTER:
 -				fi->fib_flags |= RTNH_F_DEAD;
 -				/* fall through */
 -			case NETDEV_CHANGE:
 -				fi->fib_flags |= RTNH_F_LINKDOWN;
 -				break;
 -			}
 +			fi->fib_flags |= RTNH_F_DEAD;
  			ret++;
  		}
+ 
+ 		fib_rebalance(fi);
  	}
  
  	return ret;
@@@ -1271,67 -1525,32 +1347,68 @@@ int fib_sync_up(struct net_device *dev
  			    !__in_dev_get_rtnl(dev))
  				continue;
  			alive++;
++<<<<<<< HEAD
 +			spin_lock_bh(&fib_multipath_lock);
 +			nexthop_nh->nh_power = 0;
 +			nexthop_nh->nh_flags &= ~RTNH_F_DEAD;
 +			spin_unlock_bh(&fib_multipath_lock);
++=======
+ 			nexthop_nh->nh_flags &= ~nh_flags;
++>>>>>>> 0e884c78ee19 (ipv4: L3 hash-based multipath)
  		} endfor_nexthops(fi)
  
  		if (alive > 0) {
 -			fi->fib_flags &= ~nh_flags;
 +			fi->fib_flags &= ~RTNH_F_DEAD;
  			ret++;
  		}
+ 
+ 		fib_rebalance(fi);
  	}
  
  	return ret;
  }
  
++<<<<<<< HEAD
 +/*
 + * The algorithm is suboptimal, but it provides really
 + * fair weighted route distribution.
 + */
 +void fib_select_multipath(struct fib_result *res)
 +{
 +	struct fib_info *fi = res->fi;
 +	int w;
 +
 +	spin_lock_bh(&fib_multipath_lock);
 +	if (fi->fib_power <= 0) {
 +		int power = 0;
 +		change_nexthops(fi) {
 +			if (!(nexthop_nh->nh_flags & RTNH_F_DEAD)) {
 +				power += nexthop_nh->nh_weight;
 +				nexthop_nh->nh_power = nexthop_nh->nh_weight;
 +			}
 +		} endfor_nexthops(fi);
 +		fi->fib_power = power;
 +		if (power <= 0) {
 +			spin_unlock_bh(&fib_multipath_lock);
 +			/* Race condition: route has just become dead. */
 +			res->nh_sel = 0;
 +			return;
 +		}
 +	}
++=======
+ #ifdef CONFIG_IP_ROUTE_MULTIPATH
  
+ void fib_select_multipath(struct fib_result *res, int hash)
+ {
+ 	struct fib_info *fi = res->fi;
  
- 	/* w should be random number [0..fi->fib_power-1],
- 	 * it is pretty bad approximation.
- 	 */
- 
- 	w = jiffies % fi->fib_power;
+ 	for_nexthops(fi) {
+ 		if (hash > atomic_read(&nh->nh_upper_bound))
+ 			continue;
++>>>>>>> 0e884c78ee19 (ipv4: L3 hash-based multipath)
  
- 	change_nexthops(fi) {
- 		if (!(nexthop_nh->nh_flags & RTNH_F_DEAD) &&
- 		    nexthop_nh->nh_power) {
- 			w -= nexthop_nh->nh_power;
- 			if (w <= 0) {
- 				nexthop_nh->nh_power--;
- 				fi->fib_power--;
- 				res->nh_sel = nhsel;
- 				spin_unlock_bh(&fib_multipath_lock);
- 				return;
- 			}
- 		}
+ 		res->nh_sel = nhsel;
+ 		return;
  	} endfor_nexthops(fi);
  
  	/* Race condition: route has just become dead. */
* Unmerged path include/net/ip_fib.h
* Unmerged path net/ipv4/fib_semantics.c
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index 92306c5a6897..c0b57de29e44 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -1579,8 +1579,12 @@ static int ip_mkroute_input(struct sk_buff *skb,
 			    __be32 daddr, __be32 saddr, u32 tos)
 {
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
-	if (res->fi && res->fi->fib_nhs > 1)
-		fib_select_multipath(res);
+	if (res->fi && res->fi->fib_nhs > 1) {
+		int h;
+
+		h = fib_multipath_hash(saddr, daddr);
+		fib_select_multipath(res, h);
+	}
 #endif
 
 	/* create a routing cache entry */
@@ -2107,8 +2111,12 @@ struct rtable *__ip_route_output_key(struct net *net, struct flowi4 *fl4)
 	}
 
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
-	if (res.fi->fib_nhs > 1 && fl4->flowi4_oif == 0)
-		fib_select_multipath(&res);
+	if (res.fi->fib_nhs > 1 && fl4->flowi4_oif == 0) {
+		int h;
+
+		h = fib_multipath_hash(fl4->saddr, fl4->daddr);
+		fib_select_multipath(&res, h);
+	}
 	else
 #endif
 	if (!res.prefixlen &&
