sctp: merge the seq_start/next/exits in remaddrs and assocs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit b5e2f4e6998a2b999da8fa0290b692f0bd85c8b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b5e2f4e6.failed

In sctp proc, these three functions in remaddrs and assocs are the
same. we should merge them into one.

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b5e2f4e6998a2b999da8fa0290b692f0bd85c8b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/proc.c
diff --cc net/sctp/proc.c
index aaeecb033eeb,9fe139368ad7..000000000000
--- a/net/sctp/proc.c
+++ b/net/sctp/proc.c
@@@ -288,16 -277,47 +288,51 @@@ void sctp_eps_proc_exit(struct net *net
  	remove_proc_entry("eps", net->sctp.proc_net_sctp);
  }
  
 -struct sctp_ht_iter {
 -	struct seq_net_private p;
 -	struct rhashtable_iter hti;
 -};
  
++<<<<<<< HEAD
 +static void * sctp_assocs_seq_start(struct seq_file *seq, loff_t *pos)
++=======
+ static void *sctp_transport_seq_start(struct seq_file *seq, loff_t *pos)
++>>>>>>> b5e2f4e6998a (sctp: merge the seq_start/next/exits in remaddrs and assocs)
  {
 -	struct sctp_ht_iter *iter = seq->private;
 -	int err = sctp_transport_walk_start(&iter->hti);
 +	if (*pos >= sctp_assoc_hashsize)
 +		return NULL;
  
 -	if (err)
 -		return ERR_PTR(err);
 +	if (*pos < 0)
 +		*pos = 0;
  
++<<<<<<< HEAD
 +	if (*pos == 0)
++=======
+ 	return sctp_transport_get_idx(seq_file_net(seq), &iter->hti, *pos);
+ }
+ 
+ static void sctp_transport_seq_stop(struct seq_file *seq, void *v)
+ {
+ 	struct sctp_ht_iter *iter = seq->private;
+ 
+ 	sctp_transport_walk_stop(&iter->hti);
+ }
+ 
+ static void *sctp_transport_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+ {
+ 	struct sctp_ht_iter *iter = seq->private;
+ 
+ 	++*pos;
+ 
+ 	return sctp_transport_get_next(seq_file_net(seq), &iter->hti);
+ }
+ 
+ /* Display sctp associations (/proc/net/sctp/assocs). */
+ static int sctp_assocs_seq_show(struct seq_file *seq, void *v)
+ {
+ 	struct sctp_transport *transport;
+ 	struct sctp_association *assoc;
+ 	struct sctp_ep_common *epb;
+ 	struct sock *sk;
+ 
+ 	if (v == SEQ_START_TOKEN) {
++>>>>>>> b5e2f4e6998a (sctp: merge the seq_start/next/exits in remaddrs and assocs)
  		seq_printf(seq, " ASSOC     SOCK   STY SST ST HBKT "
  				"ASSOC-ID TX_QUEUE RX_QUEUE UID INODE LPORT "
  				"RPORT LADDRS <-> RADDRS "
@@@ -414,114 -406,76 +449,117 @@@ void sctp_assocs_proc_exit(struct net *
  	remove_proc_entry("assocs", net->sctp.proc_net_sctp);
  }
  
 -static int sctp_remaddr_seq_show(struct seq_file *seq, void *v)
++<<<<<<< HEAD
 +static void *sctp_remaddr_seq_start(struct seq_file *seq, loff_t *pos)
  {
 -	struct sctp_association *assoc;
 -	struct sctp_transport *transport, *tsp;
 +	if (*pos >= sctp_assoc_hashsize)
 +		return NULL;
  
 -	if (v == SEQ_START_TOKEN) {
 +	if (*pos < 0)
 +		*pos = 0;
 +
 +	if (*pos == 0)
  		seq_printf(seq, "ADDR ASSOC_ID HB_ACT RTO MAX_PATH_RTX "
  				"REM_ADDR_RTX START STATE\n");
 -		return 0;
 -	}
  
 -	transport = (struct sctp_transport *)v;
 -	if (!sctp_transport_hold(transport))
 -		return 0;
 -	assoc = transport->asoc;
 -
 -	list_for_each_entry_rcu(tsp, &assoc->peer.transport_addr_list,
 -				transports) {
 -		/*
 -		 * The remote address (ADDR)
 -		 */
 -		tsp->af_specific->seq_dump_addr(seq, &tsp->ipaddr);
 -		seq_printf(seq, " ");
 -		/*
 -		 * The association ID (ASSOC_ID)
 -		 */
 -		seq_printf(seq, "%d ", tsp->asoc->assoc_id);
 -
 -		/*
 -		 * If the Heartbeat is active (HB_ACT)
 -		 * Note: 1 = Active, 0 = Inactive
 -		 */
 -		seq_printf(seq, "%d ", timer_pending(&tsp->hb_timer));
 -
 -		/*
 -		 * Retransmit time out (RTO)
 -		 */
 -		seq_printf(seq, "%lu ", tsp->rto);
 -
 -		/*
 -		 * Maximum path retransmit count (PATH_MAX_RTX)
 -		 */
 -		seq_printf(seq, "%d ", tsp->pathmaxrxt);
 -
 -		/*
 -		 * remote address retransmit count (REM_ADDR_RTX)
 -		 * Note: We don't have a way to tally this at the moment
 -		 * so lets just leave it as zero for the moment
 -		 */
 -		seq_puts(seq, "0 ");
 -
 -		/*
 -		 * remote address start time (START).  This is also not
 -		 * currently implemented, but we can record it with a
 -		 * jiffies marker in a subsequent patch
 -		 */
 -		seq_puts(seq, "0 ");
 -
 -		/*
 -		 * The current state of this destination. I.e.
 -		 * SCTP_ACTIVE, SCTP_INACTIVE, ...
 -		 */
 -		seq_printf(seq, "%d", tsp->state);
 +	return (void *)pos;
 +}
  
 -		seq_printf(seq, "\n");
 +static void *sctp_remaddr_seq_next(struct seq_file *seq, void *v, loff_t *pos)
 +{
 +	if (++*pos >= sctp_assoc_hashsize)
 +		return NULL;
 +
 +	return pos;
 +}
 +
 +static void sctp_remaddr_seq_stop(struct seq_file *seq, void *v)
 +{
 +}
 +
++=======
++>>>>>>> b5e2f4e6998a (sctp: merge the seq_start/next/exits in remaddrs and assocs)
 +static int sctp_remaddr_seq_show(struct seq_file *seq, void *v)
 +{
 +	struct sctp_hashbucket *head;
 +	struct sctp_ep_common *epb;
 +	struct sctp_association *assoc;
 +	struct sctp_transport *tsp;
 +	int    hash = *(loff_t *)v;
 +
 +	if (hash >= sctp_assoc_hashsize)
 +		return -ENOMEM;
 +
 +	head = &sctp_assoc_hashtable[hash];
 +	sctp_local_bh_disable();
 +	read_lock(&head->lock);
 +	rcu_read_lock();
 +	sctp_for_each_hentry(epb, &head->chain) {
 +		if (!net_eq(sock_net(epb->sk), seq_file_net(seq)))
 +			continue;
 +		assoc = sctp_assoc(epb);
 +		list_for_each_entry_rcu(tsp, &assoc->peer.transport_addr_list,
 +					transports) {
 +			if (tsp->dead)
 +				continue;
 +
 +			/*
 +			 * The remote address (ADDR)
 +			 */
 +			tsp->af_specific->seq_dump_addr(seq, &tsp->ipaddr);
 +			seq_printf(seq, " ");
 +
 +			/*
 +			 * The association ID (ASSOC_ID)
 +			 */
 +			seq_printf(seq, "%d ", tsp->asoc->assoc_id);
 +
 +			/*
 +			 * If the Heartbeat is active (HB_ACT)
 +			 * Note: 1 = Active, 0 = Inactive
 +			 */
 +			seq_printf(seq, "%d ", timer_pending(&tsp->hb_timer));
 +
 +			/*
 +			 * Retransmit time out (RTO)
 +			 */
 +			seq_printf(seq, "%lu ", tsp->rto);
 +
 +			/*
 +			 * Maximum path retransmit count (PATH_MAX_RTX)
 +			 */
 +			seq_printf(seq, "%d ", tsp->pathmaxrxt);
 +
 +			/*
 +			 * remote address retransmit count (REM_ADDR_RTX)
 +			 * Note: We don't have a way to tally this at the moment
 +			 * so lets just leave it as zero for the moment
 +			 */
 +			seq_puts(seq, "0 ");
 +
 +			/*
 +			 * remote address start time (START).  This is also not
 +			 * currently implemented, but we can record it with a
 +			 * jiffies marker in a subsequent patch
 +			 */
 +			seq_puts(seq, "0 ");
 +
 +			/*
 +			 * The current state of this destination. I.e.
 +			 * SCTP_ACTIVE, SCTP_INACTIVE, ...
 +			 */
 +			seq_printf(seq, "%d", tsp->state);
 +
 +			seq_printf(seq, "\n");
 +		}
  	}
  
 -	sctp_transport_put(transport);
 +	rcu_read_unlock();
 +	read_unlock(&head->lock);
 +	sctp_local_bh_enable();
  
  	return 0;
 +
  }
  
  static const struct seq_operations sctp_remaddr_ops = {
* Unmerged path net/sctp/proc.c
