ovs/gre,geneve: fix error path when creating an iface

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] openvswitch: gre, geneve: fix error path when creating an iface (Eric Garver) [1297476]
Rebuild_FUZZ: 89.66%
commit-author Nicolas Dichtel <nicolas.dichtel@6wind.com>
commit 106da663ff495e0aea3ac15b8317aa410754fcac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/106da663.failed

After ipgre_newlink()/geneve_configure() call, the netdev is registered.

Fixes: 7e059158d57b ("vxlan, gre, geneve: Set a large MTU on ovs-created tunnel devices")
CC: David Wragg <david@weave.works>
	Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 106da663ff495e0aea3ac15b8317aa410754fcac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
#	net/ipv4/ip_gre.c
diff --cc drivers/net/geneve.c
index d82906728571,086c2dae4c3d..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -1005,12 -1517,27 +1006,35 @@@ struct net_device *geneve_dev_create_fb
  	if (IS_ERR(dev))
  		return dev;
  
++<<<<<<< HEAD
 +	err = geneve_configure(net, dev, 0, 0, 0, 0, htons(dst_port), true);
++=======
+ 	err = geneve_configure(net, dev, &geneve_remote_unspec,
+ 			       0, 0, 0, 0, htons(dst_port), true,
+ 			       GENEVE_F_UDP_ZERO_CSUM6_RX);
++>>>>>>> 106da663ff49 (ovs/gre,geneve: fix error path when creating an iface)
  	if (err) {
  		free_netdev(dev);
  		return ERR_PTR(err);
  	}
++<<<<<<< HEAD
 +	return dev;
++=======
+ 
+ 	/* openvswitch users expect packet sizes to be unrestricted,
+ 	 * so set the largest MTU we can.
+ 	 */
+ 	err = __geneve_change_mtu(dev, IP_MAX_MTU, false);
+ 	if (err)
+ 		goto err;
+ 
+ 	return dev;
+ 
+  err:
+ 	geneve_dellink(dev, &list_kill);
+ 	unregister_netdevice_many(&list_kill);
+ 	return ERR_PTR(err);
++>>>>>>> 106da663ff49 (ovs/gre,geneve: fix error path when creating an iface)
  }
  EXPORT_SYMBOL_GPL(geneve_dev_create_fb);
  
diff --cc net/ipv4/ip_gre.c
index 3ae6be751377,08deba679c8c..000000000000
--- a/net/ipv4/ip_gre.c
+++ b/net/ipv4/ip_gre.c
@@@ -853,9 -1116,50 +853,53 @@@ static struct rtnl_link_ops ipgre_tap_o
  	.get_link_net	= ip_tunnel_get_link_net,
  };
  
++<<<<<<< HEAD
++=======
+ struct net_device *gretap_fb_dev_create(struct net *net, const char *name,
+ 					u8 name_assign_type)
+ {
+ 	struct nlattr *tb[IFLA_MAX + 1];
+ 	struct net_device *dev;
+ 	LIST_HEAD(list_kill);
+ 	struct ip_tunnel *t;
+ 	int err;
+ 
+ 	memset(&tb, 0, sizeof(tb));
+ 
+ 	dev = rtnl_create_link(net, name, name_assign_type,
+ 			       &ipgre_tap_ops, tb);
+ 	if (IS_ERR(dev))
+ 		return dev;
+ 
+ 	/* Configure flow based GRE device. */
+ 	t = netdev_priv(dev);
+ 	t->collect_md = true;
+ 
+ 	err = ipgre_newlink(net, dev, tb, NULL);
+ 	if (err < 0) {
+ 		free_netdev(dev);
+ 		return ERR_PTR(err);
+ 	}
+ 
+ 	/* openvswitch users expect packet sizes to be unrestricted,
+ 	 * so set the largest MTU we can.
+ 	 */
+ 	err = __ip_tunnel_change_mtu(dev, IP_MAX_MTU, false);
+ 	if (err)
+ 		goto out;
+ 
+ 	return dev;
+ out:
+ 	ip_tunnel_dellink(dev, &list_kill);
+ 	unregister_netdevice_many(&list_kill);
+ 	return ERR_PTR(err);
+ }
+ EXPORT_SYMBOL_GPL(gretap_fb_dev_create);
+ 
++>>>>>>> 106da663ff49 (ovs/gre,geneve: fix error path when creating an iface)
  static int __net_init ipgre_tap_init_net(struct net *net)
  {
 -	return ip_tunnel_init_net(net, gre_tap_net_id, &ipgre_tap_ops, "gretap0");
 +	return ip_tunnel_init_net(net, gre_tap_net_id, &ipgre_tap_ops, NULL);
  }
  
  static void __net_exit ipgre_tap_exit_net(struct net *net)
* Unmerged path drivers/net/geneve.c
* Unmerged path net/ipv4/ip_gre.c
