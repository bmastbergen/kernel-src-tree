i2c: designware: Mask all interrupts during i2c controller enable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [i2c] designware: Mask all interrupts during i2c controller enable (Prarit Bhargava) [1339663]
Rebuild_FUZZ: 96.00%
commit-author Du, Wenkai <wenkai.du@intel.com>
commit 47bb27e78867997040a228328f2a631c3c7f2c82
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/47bb27e7.failed

There have been "i2c_designware 80860F41:00: controller timed out" errors
on a number of Baytrail platforms. The issue is caused by incorrect value in
Interrupt Mask Register (DW_IC_INTR_MASK)  when i2c core is being enabled.
This causes call to __i2c_dw_enable() to immediately start the transfer which
leads to timeout. There are 3 failure modes observed:

1. Failure in S0 to S3 resume path

The default value after reset for DW_IC_INTR_MASK is 0x8ff. When we start
the first transaction after resuming from system sleep, TX_EMPTY interrupt
is already unmasked because of the hardware default.

2. Failure in normal operational path

This failure happens rarely and is hard to reproduce. Debug trace showed that
DW_IC_INTR_MASK had value of 0x254 when failure occurred, which meant
TX_EMPTY was unmasked.

3. Failure in S3 to S0 suspend path

This failure also happens rarely and is hard to reproduce. Adding debug trace
that read DW_IC_INTR_MASK made this failure not reproducible. But from ISR
call trace we could conclude TX_EMPTY was unmasked when problem occurred.

The patch masks all interrupts before the controller is enabled to resolve the
faulty DW_IC_INTR_MASK conditions.

	Signed-off-by: Wenkai Du <wenkai.du@intel.com>
	Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
[wsa: improved the comment and removed typo in commit msg]
	Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
	Cc: stable@kernel.org
(cherry picked from commit 47bb27e78867997040a228328f2a631c3c7f2c82)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/busses/i2c-designware-core.c
diff --cc drivers/i2c/busses/i2c-designware-core.c
index bc5abe76f91f,3c20e4bd6dd1..000000000000
--- a/drivers/i2c/busses/i2c-designware-core.c
+++ b/drivers/i2c/busses/i2c-designware-core.c
@@@ -368,17 -399,32 +368,29 @@@ static void i2c_dw_xfer_init(struct dw_
  	/* Disable the adapter */
  	__i2c_dw_enable(dev, false);
  
 +	/* set the slave (target) address */
 +	dw_writel(dev, msgs[dev->msg_write_idx].addr, DW_IC_TAR);
 +
  	/* if the slave address is ten bit address, enable 10BITADDR */
  	ic_con = dw_readl(dev, DW_IC_CON);
 -	if (msgs[dev->msg_write_idx].flags & I2C_M_TEN) {
 +	if (msgs[dev->msg_write_idx].flags & I2C_M_TEN)
  		ic_con |= DW_IC_CON_10BITADDR_MASTER;
 -		/*
 -		 * If I2C_DYNAMIC_TAR_UPDATE is set, the 10-bit addressing
 -		 * mode has to be enabled via bit 12 of IC_TAR register.
 -		 * We set it always as I2C_DYNAMIC_TAR_UPDATE can't be
 -		 * detected from registers.
 -		 */
 -		ic_tar = DW_IC_TAR_10BITADDR_MASTER;
 -	} else {
 +	else
  		ic_con &= ~DW_IC_CON_10BITADDR_MASTER;
 -	}
 -
  	dw_writel(dev, ic_con, DW_IC_CON);
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Set the slave (target) address and enable 10-bit addressing mode
+ 	 * if applicable.
+ 	 */
+ 	dw_writel(dev, msgs[dev->msg_write_idx].addr | ic_tar, DW_IC_TAR);
+ 
+ 	/* enforce disabled interrupts (due to HW issues) */
+ 	i2c_dw_disable_int(dev);
+ 
++>>>>>>> 47bb27e78867 (i2c: designware: Mask all interrupts during i2c controller enable)
  	/* Enable the adapter */
  	__i2c_dw_enable(dev, true);
  
* Unmerged path drivers/i2c/busses/i2c-designware-core.c
