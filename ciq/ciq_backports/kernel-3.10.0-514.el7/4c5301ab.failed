i2c: designware: Convert to use unified device property API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 4c5301abbf81f4351416cec1e8a02647d96e6fd1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4c5301ab.failed

With ACPI _DSD (introduced in ACPI v5.1) it is now possible to pass device
configuration information from ACPI in addition to DT. In order to support
this, convert the driver to use the unified device property accessors
instead of DT specific.

Change to ordering a bit so that we first try platform data and if that's
not available look from device properties. ACPI *CNT methods are then used
as last resort to override everything else.

	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
	Acked-by: Wolfram Sang <wsa@the-dreams.de>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 4c5301abbf81f4351416cec1e8a02647d96e6fd1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/busses/i2c-designware-platdrv.c
diff --cc drivers/i2c/busses/i2c-designware-platdrv.c
index 0f48d5184f50,06061b5a71b3..000000000000
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@@ -129,8 -128,9 +130,9 @@@ static inline int dw_i2c_acpi_configure
  }
  #endif
  
 -static int dw_i2c_plat_probe(struct platform_device *pdev)
 +static int dw_i2c_probe(struct platform_device *pdev)
  {
+ 	struct dw_i2c_platform_data *pdata = dev_get_platdata(&pdev->dev);
  	struct dw_i2c_dev *dev;
  	struct i2c_adapter *adap;
  	struct resource *mem;
@@@ -155,12 -154,36 +157,42 @@@
  	dev->irq = irq;
  	platform_set_drvdata(pdev, dev);
  
 -	/* fast mode by default because of legacy reasons */
 -	clk_freq = 400000;
 +	dev->clk = devm_clk_get(&pdev->dev, NULL);
 +	dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
  
++<<<<<<< HEAD
 +	if (IS_ERR(dev->clk))
 +		return PTR_ERR(dev->clk);
 +	clk_prepare_enable(dev->clk);
++=======
+ 	if (pdata) {
+ 		clk_freq = pdata->i2c_scl_freq;
+ 	} else {
+ 		device_property_read_u32(&pdev->dev, "i2c-sda-hold-time-ns",
+ 					 &ht);
+ 		device_property_read_u32(&pdev->dev, "i2c-sda-falling-time-ns",
+ 					 &dev->sda_falling_time);
+ 		device_property_read_u32(&pdev->dev, "i2c-scl-falling-time-ns",
+ 					 &dev->scl_falling_time);
+ 		device_property_read_u32(&pdev->dev, "clock-frequency",
+ 					 &clk_freq);
+ 	}
+ 
+ 	if (has_acpi_companion(&pdev->dev))
+ 		dw_i2c_acpi_configure(pdev);
+ 
+ 	/*
+ 	 * Only standard mode at 100kHz and fast mode at 400kHz are supported.
+ 	 */
+ 	if (clk_freq != 100000 && clk_freq != 400000) {
+ 		dev_err(&pdev->dev, "Only 100kHz and 400kHz supported");
+ 		return -EINVAL;
+ 	}
+ 
+ 	r = i2c_dw_eval_lock_support(dev);
+ 	if (r)
+ 		return r;
++>>>>>>> 4c5301abbf81 (i2c: designware: Convert to use unified device property API)
  
  	dev->functionality =
  		I2C_FUNC_I2C |
* Unmerged path drivers/i2c/busses/i2c-designware-platdrv.c
