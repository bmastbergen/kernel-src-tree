mei: iamthif: fix device reset on mei_amthif_irq_read_msg

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit db4756fd2f16efae8469dd1e37710919a0af9370
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/db4756fd.failed

On failure mei_amthif_irq_read_msg returns an error
that will cause device reset but the issue is software one
so instead we should propagate error to caller and just
clean the read queues.
As a side effect also removes useless BUG_ONs

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit db4756fd2f16efae8469dd1e37710919a0af9370)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/amthif.c
diff --cc drivers/misc/mei/amthif.c
index a11128c1997f,2ad2f94678c8..000000000000
--- a/drivers/misc/mei/amthif.c
+++ b/drivers/misc/mei/amthif.c
@@@ -196,26 -192,29 +196,45 @@@ int mei_amthif_read(struct mei_device *
  		if (wait_ret)
  			return -ERESTARTSYS;
  
 -		dev_dbg(dev->dev, "woke up from sleep\n");
 +		dev_dbg(&dev->pdev->dev, "woke up from sleep\n");
  	}
  
+ 	if (cb->status) {
+ 		rets = cb->status;
+ 		dev_dbg(dev->dev, "read operation failed %d\n", rets);
+ 		goto free;
+ 	}
  
 -	dev_dbg(dev->dev, "Got amthif data\n");
 +	dev_dbg(&dev->pdev->dev, "Got amthif data\n");
  	dev->iamthif_timer = 0;
  
++<<<<<<< HEAD
 +	if (cb) {
 +		timeout = cb->read_time +
 +			mei_secs_to_jiffies(MEI_IAMTHIF_READ_TIMER);
 +		dev_dbg(&dev->pdev->dev, "amthif timeout = %lud\n",
 +				timeout);
 +
 +		if  (time_after(jiffies, timeout)) {
 +			dev_dbg(&dev->pdev->dev, "amthif Time out\n");
 +			/* 15 sec for the message has expired */
 +			list_del(&cb->list);
 +			rets = -ETIME;
 +			goto free;
 +		}
++=======
+ 	timeout = cb->read_time +
+ 		mei_secs_to_jiffies(MEI_IAMTHIF_READ_TIMER);
+ 	dev_dbg(dev->dev, "amthif timeout = %lud\n",
+ 			timeout);
+ 
+ 	if  (time_after(jiffies, timeout)) {
+ 		dev_dbg(dev->dev, "amthif Time out\n");
+ 		/* 15 sec for the message has expired */
+ 		list_del(&cb->list);
+ 		rets = -ETIME;
+ 		goto free;
++>>>>>>> db4756fd2f16 (mei: iamthif: fix device reset on mei_amthif_irq_read_msg)
  	}
  	/* if the whole message will fit remove it from the list */
  	if (cb->buf_idx >= *offset && length >= (cb->buf_idx - *offset))
@@@ -506,16 -501,16 +525,20 @@@ int mei_amthif_irq_write(struct mei_cl 
  }
  
  /**
 - * mei_amthif_irq_read_msg - read routine after ISR to
 + * mei_amthif_irq_read_message - read routine after ISR to
   *			handle the read amthif message
   *
-  * @dev: the device structure
+  * @cl: mei client
   * @mei_hdr: header of amthif message
-  * @complete_list: An instance of our list structure
+  * @complete_list: completed callbacks list
   *
++<<<<<<< HEAD
 + * returns 0 on success, <0 on failure.
++=======
+  * Return: -ENODEV if cb is NULL 0 otherwise; error message is in cb->status
++>>>>>>> db4756fd2f16 (mei: iamthif: fix device reset on mei_amthif_irq_read_msg)
   */
- int mei_amthif_irq_read_msg(struct mei_device *dev,
+ int mei_amthif_irq_read_msg(struct mei_cl *cl,
  			    struct mei_msg_hdr *mei_hdr,
  			    struct mei_cl_cb *complete_list)
  {
@@@ -535,29 -547,26 +575,43 @@@
  	if (!mei_hdr->msg_complete)
  		return 0;
  
++<<<<<<< HEAD
 +	dev_dbg(&dev->pdev->dev, "amthif_message_buffer_index =%d\n",
 +			mei_hdr->length);
 +
 +	dev_dbg(&dev->pdev->dev, "completed amthif read.\n ");
 +	if (!dev->iamthif_current_cb)
 +		return -ENODEV;
++=======
+ 	dev_dbg(dev->dev, "completed amthif read.\n ");
++>>>>>>> db4756fd2f16 (mei: iamthif: fix device reset on mei_amthif_irq_read_msg)
  
- 	cb = dev->iamthif_current_cb;
  	dev->iamthif_current_cb = NULL;
  
 +	if (!cb->cl)
 +		return -ENODEV;
 +
  	dev->iamthif_stall_timer = 0;
  	cb->buf_idx = dev->iamthif_msg_buf_index;
  	cb->read_time = jiffies;
  	if (dev->iamthif_ioctl) {
  		/* found the iamthif cb */
++<<<<<<< HEAD
 +		dev_dbg(&dev->pdev->dev, "complete the amthif read cb.\n ");
 +		dev_dbg(&dev->pdev->dev, "add the amthif read cb to complete.\n ");
++=======
+ 		dev_dbg(dev->dev, "complete the amthif read cb.\n ");
++>>>>>>> db4756fd2f16 (mei: iamthif: fix device reset on mei_amthif_irq_read_msg)
  		list_add_tail(&cb->list, &complete_list->list);
  	}
+ 
  	return 0;
+ 
+ err:
+ 	mei_read_slots(dev, dev->rd_msg_buf, mei_hdr->length);
+ 	dev_dbg(dev->dev, "discarding message " MEI_HDR_FMT "\n",
+ 				MEI_HDR_PRM(mei_hdr));
+ 	return ret;
  }
  
  /**
* Unmerged path drivers/misc/mei/amthif.c
diff --git a/drivers/misc/mei/interrupt.c b/drivers/misc/mei/interrupt.c
index b8d9cfee3e87..36bd11b0565c 100644
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@ -380,11 +380,8 @@ int mei_irq_read_handler(struct mei_device *dev,
 		goto end;
 	}
 
-	if (mei_hdr->host_addr == dev->iamthif_cl.host_client_id &&
-	    MEI_FILE_CONNECTED == dev->iamthif_cl.state &&
-	    dev->iamthif_state == MEI_IAMTHIF_READING) {
-
-		ret = mei_amthif_irq_read_msg(dev, mei_hdr, cmpl_list);
+	if (cl == &dev->iamthif_cl) {
+		ret = mei_amthif_irq_read_msg(cl, mei_hdr, cmpl_list);
 		if (ret) {
 			dev_err(&dev->pdev->dev, "mei_amthif_irq_read_msg failed = %d\n",
 					ret);
diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h
index 1b981b70f5aa..f241d2cefa42 100644
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -600,7 +600,7 @@ int mei_amthif_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,
 			struct mei_cl_cb *cmpl_list);
 
 void mei_amthif_complete(struct mei_device *dev, struct mei_cl_cb *cb);
-int mei_amthif_irq_read_msg(struct mei_device *dev,
+int mei_amthif_irq_read_msg(struct mei_cl *cl,
 			    struct mei_msg_hdr *mei_hdr,
 			    struct mei_cl_cb *complete_list);
 int mei_amthif_irq_read(struct mei_device *dev, s32 *slots);
