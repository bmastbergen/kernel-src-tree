net: add netdev_adjacent->private and allow to use it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] add netdev_adjacent->private and allow to use it (Ivan Vecera) [1268334]
Rebuild_FUZZ: 95.05%
commit-author Veaceslav Falico <vfalico@redhat.com>
commit 402dae9614557296e84543008a8e582c28fb1db3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/402dae96.failed

Currently, even though we can access any linked device, we can't attach
anything to it, which is vital to properly manage them.

To fix this, add a new void *private to netdev_adjacent and functions
setting/getting it (per link), so that we can save, per example, bonding's
slave structures there, per slave device.

netdev_master_upper_dev_link_private(dev, upper_dev, private) links dev to
upper dev and populates the neighbour link only with private.

netdev_lower_dev_get_private{,_rcu}() returns the private, if found.

CC: "David S. Miller" <davem@davemloft.net>
CC: Eric Dumazet <edumazet@google.com>
CC: Jiri Pirko <jiri@resnulli.us>
CC: Alexander Duyck <alexander.h.duyck@intel.com>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 402dae9614557296e84543008a8e582c28fb1db3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/core/dev.c
diff --cc include/linux/netdevice.h
index 7b10147de03d,75d5beac463b..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -3273,30 -2820,39 +3273,53 @@@ extern int		netdev_tstamp_prequeue
  extern int		weight_p;
  extern int		bpf_jit_enable;
  
 -extern bool netdev_has_upper_dev(struct net_device *dev,
 +bool netdev_has_upper_dev(struct net_device *dev, struct net_device *upper_dev);
 +bool netdev_has_any_upper_dev(struct net_device *dev);
 +struct net_device *netdev_master_upper_dev_get(struct net_device *dev);
 +struct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev);
 +int netdev_upper_dev_link(struct net_device *dev, struct net_device *upper_dev);
 +int netdev_master_upper_dev_link(struct net_device *dev,
  				 struct net_device *upper_dev);
 -extern bool netdev_has_any_upper_dev(struct net_device *dev);
 -extern struct net_device *netdev_all_upper_get_next_dev_rcu(struct net_device *dev,
 -							    struct list_head **iter);
 -
 -/* iterate through upper list, must be called under RCU read lock */
 -#define netdev_for_each_all_upper_dev_rcu(dev, updev, iter) \
 -	for (iter = &(dev)->all_adj_list.upper, \
 -	     updev = netdev_all_upper_get_next_dev_rcu(dev, &(iter)); \
 -	     updev; \
 -	     updev = netdev_all_upper_get_next_dev_rcu(dev, &(iter)))
 -
 +void netdev_upper_dev_unlink(struct net_device *dev,
 +			     struct net_device *upper_dev);
 +void *netdev_lower_dev_get_private_rcu(struct net_device *dev,
 +				       struct net_device *lower_dev);
 +void *netdev_lower_dev_get_private(struct net_device *dev,
 +				   struct net_device *lower_dev);
 +
 +/* RSS keys are 40 or 52 bytes long */
 +#define NETDEV_RSS_KEY_LEN 52
 +extern u8 netdev_rss_key[NETDEV_RSS_KEY_LEN];
 +void netdev_rss_key_fill(void *buffer, size_t len);
 +
++<<<<<<< HEAD
 +int skb_checksum_help(struct sk_buff *skb);
 +struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
 +				  netdev_features_t features, bool tx_path);
 +struct sk_buff *skb_mac_gso_segment(struct sk_buff *skb,
 +				    netdev_features_t features);
++=======
+ extern struct net_device *netdev_master_upper_dev_get(struct net_device *dev);
+ extern struct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev);
+ extern int netdev_upper_dev_link(struct net_device *dev,
+ 				 struct net_device *upper_dev);
+ extern int netdev_master_upper_dev_link(struct net_device *dev,
+ 					struct net_device *upper_dev);
+ extern int netdev_master_upper_dev_link_private(struct net_device *dev,
+ 						struct net_device *upper_dev,
+ 						void *private);
+ extern void netdev_upper_dev_unlink(struct net_device *dev,
+ 				    struct net_device *upper_dev);
+ extern void *netdev_lower_dev_get_private_rcu(struct net_device *dev,
+ 					      struct net_device *lower_dev);
+ extern void *netdev_lower_dev_get_private(struct net_device *dev,
+ 					  struct net_device *lower_dev);
+ extern int skb_checksum_help(struct sk_buff *skb);
+ extern struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
+ 	netdev_features_t features, bool tx_path);
+ extern struct sk_buff *skb_mac_gso_segment(struct sk_buff *skb,
+ 					  netdev_features_t features);
++>>>>>>> 402dae961455 (net: add netdev_adjacent->private and allow to use it)
  
  static inline
  struct sk_buff *skb_gso_segment(struct sk_buff *skb, netdev_features_t features)
diff --cc net/core/dev.c
index 004e3f31d664,c69ab74fb201..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -4498,53 -4369,42 +4498,63 @@@ softnet_break
  
  struct netdev_adjacent {
  	struct net_device *dev;
 -
 -	/* upper master flag, there can only be one master device per list */
  	bool master;
++<<<<<<< HEAD
++=======
+ 
+ 	/* counter for the number of times this device was added to us */
+ 	u16 ref_nr;
+ 
+ 	/* private field for the users */
+ 	void *private;
+ 
++>>>>>>> 402dae961455 (net: add netdev_adjacent->private and allow to use it)
  	struct list_head list;
  	struct rcu_head rcu;
 +	struct list_head search_list;
  };
  
 -static struct netdev_adjacent *__netdev_find_adj_rcu(struct net_device *dev,
 -						     struct net_device *adj_dev,
 -						     struct list_head *adj_list)
 +static void __append_search_uppers(struct list_head *search_list,
 +				   struct net_device *dev)
  {
 -	struct netdev_adjacent *adj;
 +	struct netdev_adjacent *upper;
  
 -	list_for_each_entry_rcu(adj, adj_list, list) {
 -		if (adj->dev == adj_dev)
 -			return adj;
 +	list_for_each_entry(upper, &dev->upper_dev_list, list) {
 +		/* check if this upper is not already in search list */
 +		if (list_empty(&upper->search_list))
 +			list_add_tail(&upper->search_list, search_list);
  	}
 -	return NULL;
  }
  
 -static struct netdev_adjacent *__netdev_find_adj(struct net_device *dev,
 -						 struct net_device *adj_dev,
 -						 struct list_head *adj_list)
 +static bool __netdev_search_upper_dev(struct net_device *dev,
 +				      struct net_device *upper_dev)
  {
 -	struct netdev_adjacent *adj;
 +	LIST_HEAD(search_list);
 +	struct netdev_adjacent *upper;
 +	struct netdev_adjacent *tmp;
 +	bool ret = false;
 +
 +	__append_search_uppers(&search_list, dev);
 +	list_for_each_entry(upper, &search_list, search_list) {
 +		if (upper->dev == upper_dev) {
 +			ret = true;
 +			break;
 +		}
 +		__append_search_uppers(&search_list, upper->dev);
 +	}
 +	list_for_each_entry_safe(upper, tmp, &search_list, search_list)
 +		INIT_LIST_HEAD(&upper->search_list);
 +	return ret;
 +}
 +
 +static struct netdev_adjacent *__netdev_find_upper(struct net_device *dev,
 +						struct net_device *upper_dev)
 +{
 +	struct netdev_adjacent *upper;
  
 -	list_for_each_entry(adj, adj_list, list) {
 -		if (adj->dev == adj_dev)
 -			return adj;
 +	list_for_each_entry(upper, &dev->upper_dev_list, list) {
 +		if (upper->dev == upper_dev)
 +			return upper;
  	}
  	return NULL;
  }
@@@ -4650,10 -4510,155 +4660,157 @@@ struct net_device *netdev_master_upper_
  }
  EXPORT_SYMBOL(netdev_master_upper_dev_get_rcu);
  
++<<<<<<< HEAD
++=======
+ static int __netdev_adjacent_dev_insert(struct net_device *dev,
+ 					struct net_device *adj_dev,
+ 					struct list_head *dev_list,
+ 					void *private, bool master)
+ {
+ 	struct netdev_adjacent *adj;
+ 
+ 	adj = __netdev_find_adj(dev, adj_dev, dev_list);
+ 
+ 	if (adj) {
+ 		adj->ref_nr++;
+ 		return 0;
+ 	}
+ 
+ 	adj = kmalloc(sizeof(*adj), GFP_KERNEL);
+ 	if (!adj)
+ 		return -ENOMEM;
+ 
+ 	adj->dev = adj_dev;
+ 	adj->master = master;
+ 	adj->ref_nr = 1;
+ 	adj->private = private;
+ 	dev_hold(adj_dev);
+ 
+ 	pr_debug("dev_hold for %s, because of link added from %s to %s\n",
+ 		 adj_dev->name, dev->name, adj_dev->name);
+ 
+ 	/* Ensure that master link is always the first item in list. */
+ 	if (master)
+ 		list_add_rcu(&adj->list, dev_list);
+ 	else
+ 		list_add_tail_rcu(&adj->list, dev_list);
+ 
+ 	return 0;
+ }
+ 
+ void __netdev_adjacent_dev_remove(struct net_device *dev,
+ 				  struct net_device *adj_dev,
+ 				  struct list_head *dev_list)
+ {
+ 	struct netdev_adjacent *adj;
+ 
+ 	adj = __netdev_find_adj(dev, adj_dev, dev_list);
+ 
+ 	if (!adj) {
+ 		pr_err("tried to remove device %s from %s\n",
+ 		       dev->name, adj_dev->name);
+ 		BUG();
+ 	}
+ 
+ 	if (adj->ref_nr > 1) {
+ 		pr_debug("%s to %s ref_nr-- = %d\n", dev->name, adj_dev->name,
+ 			 adj->ref_nr-1);
+ 		adj->ref_nr--;
+ 		return;
+ 	}
+ 
+ 	list_del_rcu(&adj->list);
+ 	pr_debug("dev_put for %s, because link removed from %s to %s\n",
+ 		 adj_dev->name, dev->name, adj_dev->name);
+ 	dev_put(adj_dev);
+ 	kfree_rcu(adj, rcu);
+ }
+ 
+ int __netdev_adjacent_dev_link_lists(struct net_device *dev,
+ 				     struct net_device *upper_dev,
+ 				     struct list_head *up_list,
+ 				     struct list_head *down_list,
+ 				     void *private, bool master)
+ {
+ 	int ret;
+ 
+ 	ret = __netdev_adjacent_dev_insert(dev, upper_dev, up_list, private,
+ 					   master);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = __netdev_adjacent_dev_insert(upper_dev, dev, down_list, private,
+ 					   false);
+ 	if (ret) {
+ 		__netdev_adjacent_dev_remove(dev, upper_dev, up_list);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int __netdev_adjacent_dev_link(struct net_device *dev,
+ 			       struct net_device *upper_dev)
+ {
+ 	return __netdev_adjacent_dev_link_lists(dev, upper_dev,
+ 						&dev->all_adj_list.upper,
+ 						&upper_dev->all_adj_list.lower,
+ 						NULL, false);
+ }
+ 
+ void __netdev_adjacent_dev_unlink_lists(struct net_device *dev,
+ 					struct net_device *upper_dev,
+ 					struct list_head *up_list,
+ 					struct list_head *down_list)
+ {
+ 	__netdev_adjacent_dev_remove(dev, upper_dev, up_list);
+ 	__netdev_adjacent_dev_remove(upper_dev, dev, down_list);
+ }
+ 
+ void __netdev_adjacent_dev_unlink(struct net_device *dev,
+ 				  struct net_device *upper_dev)
+ {
+ 	__netdev_adjacent_dev_unlink_lists(dev, upper_dev,
+ 					   &dev->all_adj_list.upper,
+ 					   &upper_dev->all_adj_list.lower);
+ }
+ 
+ int __netdev_adjacent_dev_link_neighbour(struct net_device *dev,
+ 					 struct net_device *upper_dev,
+ 					 void *private, bool master)
+ {
+ 	int ret = __netdev_adjacent_dev_link(dev, upper_dev);
+ 
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = __netdev_adjacent_dev_link_lists(dev, upper_dev,
+ 					       &dev->adj_list.upper,
+ 					       &upper_dev->adj_list.lower,
+ 					       private, master);
+ 	if (ret) {
+ 		__netdev_adjacent_dev_unlink(dev, upper_dev);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void __netdev_adjacent_dev_unlink_neighbour(struct net_device *dev,
+ 					    struct net_device *upper_dev)
+ {
+ 	__netdev_adjacent_dev_unlink(dev, upper_dev);
+ 	__netdev_adjacent_dev_unlink_lists(dev, upper_dev,
+ 					   &dev->adj_list.upper,
+ 					   &upper_dev->adj_list.lower);
+ }
+ 
++>>>>>>> 402dae961455 (net: add netdev_adjacent->private and allow to use it)
  static int __netdev_upper_dev_link(struct net_device *dev,
- 				   struct net_device *upper_dev, bool master)
+ 				   struct net_device *upper_dev, bool master,
+ 				   void *private)
  {
 -	struct netdev_adjacent *i, *j, *to_i, *to_j;
 -	int ret = 0;
 +	struct netdev_adjacent *upper;
  
  	ASSERT_RTNL();
  
@@@ -4670,22 -4675,83 +4827,29 @@@
  	if (master && netdev_master_upper_dev_get(dev))
  		return -EBUSY;
  
++<<<<<<< HEAD
 +	upper = kmalloc(sizeof(*upper), GFP_KERNEL);
 +	if (!upper)
 +		return -ENOMEM;
++=======
+ 	ret = __netdev_adjacent_dev_link_neighbour(dev, upper_dev, private,
+ 						   master);
+ 	if (ret)
+ 		return ret;
++>>>>>>> 402dae961455 (net: add netdev_adjacent->private and allow to use it)
  
 -	/* Now that we linked these devs, make all the upper_dev's
 -	 * all_adj_list.upper visible to every dev's all_adj_list.lower an
 -	 * versa, and don't forget the devices itself. All of these
 -	 * links are non-neighbours.
 -	 */
 -	list_for_each_entry(i, &dev->all_adj_list.lower, list) {
 -		list_for_each_entry(j, &upper_dev->all_adj_list.upper, list) {
 -			pr_debug("Interlinking %s with %s, non-neighbour\n",
 -				 i->dev->name, j->dev->name);
 -			ret = __netdev_adjacent_dev_link(i->dev, j->dev);
 -			if (ret)
 -				goto rollback_mesh;
 -		}
 -	}
 -
 -	/* add dev to every upper_dev's upper device */
 -	list_for_each_entry(i, &upper_dev->all_adj_list.upper, list) {
 -		pr_debug("linking %s's upper device %s with %s\n",
 -			 upper_dev->name, i->dev->name, dev->name);
 -		ret = __netdev_adjacent_dev_link(dev, i->dev);
 -		if (ret)
 -			goto rollback_upper_mesh;
 -	}
 +	upper->dev = upper_dev;
 +	upper->master = master;
 +	INIT_LIST_HEAD(&upper->search_list);
  
 -	/* add upper_dev to every dev's lower device */
 -	list_for_each_entry(i, &dev->all_adj_list.lower, list) {
 -		pr_debug("linking %s's lower device %s with %s\n", dev->name,
 -			 i->dev->name, upper_dev->name);
 -		ret = __netdev_adjacent_dev_link(i->dev, upper_dev);
 -		if (ret)
 -			goto rollback_lower_mesh;
 -	}
 +	/* Ensure that master upper link is always the first item in list. */
 +	if (master)
 +		list_add_rcu(&upper->list, &dev->upper_dev_list);
 +	else
 +		list_add_tail_rcu(&upper->list, &dev->upper_dev_list);
 +	dev_hold(upper_dev);
  
 -	call_netdevice_notifiers(NETDEV_CHANGEUPPER, dev);
  	return 0;
 -
 -rollback_lower_mesh:
 -	to_i = i;
 -	list_for_each_entry(i, &dev->all_adj_list.lower, list) {
 -		if (i == to_i)
 -			break;
 -		__netdev_adjacent_dev_unlink(i->dev, upper_dev);
 -	}
 -
 -	i = NULL;
 -
 -rollback_upper_mesh:
 -	to_i = i;
 -	list_for_each_entry(i, &upper_dev->all_adj_list.upper, list) {
 -		if (i == to_i)
 -			break;
 -		__netdev_adjacent_dev_unlink(dev, i->dev);
 -	}
 -
 -	i = j = NULL;
 -
 -rollback_mesh:
 -	to_i = i;
 -	to_j = j;
 -	list_for_each_entry(i, &dev->all_adj_list.lower, list) {
 -		list_for_each_entry(j, &upper_dev->all_adj_list.upper, list) {
 -			if (i == to_i && j == to_j)
 -				break;
 -			__netdev_adjacent_dev_unlink(i->dev, j->dev);
 -		}
 -		if (i == to_i)
 -			break;
 -	}
 -
 -	__netdev_adjacent_dev_unlink_neighbour(dev, upper_dev);
 -
 -	return ret;
  }
  
  /**
* Unmerged path include/linux/netdevice.h
* Unmerged path net/core/dev.c
