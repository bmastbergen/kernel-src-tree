be2iscsi: Fix be_mcc_compl_poll to use tag_state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jitendra Bhivare <jitendra.bhivare@broadcom.com>
commit 69fd6d7b42374400f311d2eff59fc37cc184b6b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/69fd6d7b.failed

be_mcc_compl_poll waits till 'used' count of MCC WRBQ is zero. This is
to determine the completion of an MCC sent.

Change function to poll for the tag of MCC sent, instead, and wait till
its tag_state is cleared.

	Signed-off-by: Jitendra Bhivare <jitendra.bhivare@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 69fd6d7b42374400f311d2eff59fc37cc184b6b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/be2iscsi/be_cmds.c
diff --cc drivers/scsi/be2iscsi/be_cmds.c
index f6abd01429a1,60db2de9ed8a..000000000000
--- a/drivers/scsi/be2iscsi/be_cmds.c
+++ b/drivers/scsi/be2iscsi/be_cmds.c
@@@ -139,8 -126,30 +126,30 @@@ unsigned int alloc_mcc_tag(struct beisc
  	return tag;
  }
  
+ void free_mcc_tag(struct be_ctrl_info *ctrl, unsigned int tag)
+ {
+ 	spin_lock_bh(&ctrl->mcc_lock);
+ 	tag = tag & MCC_Q_CMD_TAG_MASK;
+ 	ctrl->mcc_tag[ctrl->mcc_free_index] = tag;
+ 	if (ctrl->mcc_free_index == (MAX_MCC_CMD - 1))
+ 		ctrl->mcc_free_index = 0;
+ 	else
+ 		ctrl->mcc_free_index++;
+ 	ctrl->mcc_tag_available++;
+ 	spin_unlock_bh(&ctrl->mcc_lock);
+ }
+ 
+ /**
+  * beiscsi_fail_session(): Closing session with appropriate error
+  * @cls_session: ptr to session
+  **/
+ void beiscsi_fail_session(struct iscsi_cls_session *cls_session)
+ {
+ 	iscsi_session_failure(cls_session->dd_data, ISCSI_ERR_CONN_FAILED);
+ }
+ 
  /*
 - * beiscsi_mccq_compl_wait()- Process completion in MCC CQ
 + * beiscsi_mccq_compl()- Wait for completion of MBX
   * @phba: Driver private structure
   * @tag: Tag for the MBX Command
   * @wrb: the WRB used for the MBX Command
@@@ -254,39 -263,6 +263,42 @@@ int beiscsi_mccq_compl(struct beiscsi_h
  	return rc;
  }
  
++<<<<<<< HEAD
 +void free_mcc_tag(struct be_ctrl_info *ctrl, unsigned int tag)
 +{
 +	spin_lock(&ctrl->mcc_lock);
 +	tag = tag & MCC_Q_CMD_TAG_MASK;
 +	ctrl->mcc_tag[ctrl->mcc_free_index] = tag;
 +	if (ctrl->mcc_free_index == (MAX_MCC_CMD - 1))
 +		ctrl->mcc_free_index = 0;
 +	else
 +		ctrl->mcc_free_index++;
 +	ctrl->mcc_tag_available++;
 +	spin_unlock(&ctrl->mcc_lock);
 +}
 +
 +bool is_link_state_evt(u32 trailer)
 +{
 +	return (((trailer >> ASYNC_TRAILER_EVENT_CODE_SHIFT) &
 +		  ASYNC_TRAILER_EVENT_CODE_MASK) ==
 +		  ASYNC_EVENT_CODE_LINK_STATE);
 +}
 +
 +static bool is_iscsi_evt(u32 trailer)
 +{
 +	return (((trailer >> ASYNC_TRAILER_EVENT_CODE_SHIFT) &
 +		  ASYNC_TRAILER_EVENT_CODE_MASK) ==
 +		  ASYNC_EVENT_CODE_ISCSI);
 +}
 +
 +static int iscsi_evt_type(u32 trailer)
 +{
 +	return ((trailer >> ASYNC_TRAILER_EVENT_TYPE_SHIFT) &
 +		 ASYNC_TRAILER_EVENT_TYPE_MASK);
 +}
 +
++=======
++>>>>>>> 69fd6d7b4237 (be2iscsi: Fix be_mcc_compl_poll to use tag_state)
  static inline bool be_mcc_compl_is_new(struct be_mcc_compl *compl)
  {
  	if (compl->flags != 0) {
@@@ -348,8 -324,129 +360,134 @@@ static int be_mcc_compl_process(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
 +int be_mcc_compl_process_isr(struct be_ctrl_info *ctrl,
 +				    struct be_mcc_compl *compl)
++=======
+ static void beiscsi_process_async_link(struct beiscsi_hba *phba,
+ 				       struct be_mcc_compl *compl)
+ {
+ 	struct be_async_event_link_state *evt;
+ 
+ 	evt = (struct be_async_event_link_state *)compl;
+ 
+ 	phba->port_speed = evt->port_speed;
+ 	/**
+ 	 * Check logical link status in ASYNC event.
+ 	 * This has been newly introduced in SKH-R Firmware 10.0.338.45.
+ 	 **/
+ 	if (evt->port_link_status & BE_ASYNC_LINK_UP_MASK) {
+ 		phba->state = BE_ADAPTER_LINK_UP | BE_ADAPTER_CHECK_BOOT;
+ 		phba->get_boot = BE_GET_BOOT_RETRIES;
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BC_%d : Link Up on Port %d tag 0x%x\n",
+ 			      evt->physical_port, evt->event_tag);
+ 	} else {
+ 		phba->state = BE_ADAPTER_LINK_DOWN;
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BC_%d : Link Down on Port %d tag 0x%x\n",
+ 			      evt->physical_port, evt->event_tag);
+ 		iscsi_host_for_each_session(phba->shost,
+ 					    beiscsi_fail_session);
+ 	}
+ }
+ 
+ static char *beiscsi_port_misconf_event_msg[] = {
+ 	"Physical Link is functional.",
+ 	"Optics faulted/incorrectly installed/not installed - Reseat optics, if issue not resolved, replace.",
+ 	"Optics of two types installed - Remove one optic or install matching pair of optics.",
+ 	"Incompatible optics - Replace with compatible optics for card to function.",
+ 	"Unqualified optics - Replace with Avago optics for Warranty and Technical Support.",
+ 	"Uncertified optics - Replace with Avago Certified optics to enable link operation."
+ };
+ 
+ static void beiscsi_process_async_sli(struct beiscsi_hba *phba,
+ 				      struct be_mcc_compl *compl)
+ {
+ 	struct be_async_event_sli *async_sli;
+ 	u8 evt_type, state, old_state, le;
+ 	char *sev = KERN_WARNING;
+ 	char *msg = NULL;
+ 
+ 	evt_type = compl->flags >> ASYNC_TRAILER_EVENT_TYPE_SHIFT;
+ 	evt_type &= ASYNC_TRAILER_EVENT_TYPE_MASK;
+ 
+ 	/* processing only MISCONFIGURED physical port event */
+ 	if (evt_type != ASYNC_SLI_EVENT_TYPE_MISCONFIGURED)
+ 		return;
+ 
+ 	async_sli = (struct be_async_event_sli *)compl;
+ 	state = async_sli->event_data1 >>
+ 		 (phba->fw_config.phys_port * 8) & 0xff;
+ 	le = async_sli->event_data2 >>
+ 		 (phba->fw_config.phys_port * 8) & 0xff;
+ 
+ 	old_state = phba->optic_state;
+ 	phba->optic_state = state;
+ 
+ 	if (state >= ARRAY_SIZE(beiscsi_port_misconf_event_msg)) {
+ 		/* fw is reporting a state we don't know, log and return */
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			    "BC_%d : Port %c: Unrecognized optic state 0x%x\n",
+ 			    phba->port_name, async_sli->event_data1);
+ 		return;
+ 	}
+ 
+ 	if (ASYNC_SLI_LINK_EFFECT_VALID(le)) {
+ 		/* log link effect for unqualified-4, uncertified-5 optics */
+ 		if (state > 3)
+ 			msg = (ASYNC_SLI_LINK_EFFECT_STATE(le)) ?
+ 				" Link is non-operational." :
+ 				" Link is operational.";
+ 		/* 1 - info */
+ 		if (ASYNC_SLI_LINK_EFFECT_SEV(le) == 1)
+ 			sev = KERN_INFO;
+ 		/* 2 - error */
+ 		if (ASYNC_SLI_LINK_EFFECT_SEV(le) == 2)
+ 			sev = KERN_ERR;
+ 	}
+ 
+ 	if (old_state != phba->optic_state)
+ 		__beiscsi_log(phba, sev, "BC_%d : Port %c: %s%s\n",
+ 			      phba->port_name,
+ 			      beiscsi_port_misconf_event_msg[state],
+ 			      !msg ? "" : msg);
+ }
+ 
+ void beiscsi_process_async_event(struct beiscsi_hba *phba,
+ 				struct be_mcc_compl *compl)
+ {
+ 	char *sev = KERN_INFO;
+ 	u8 evt_code;
+ 
+ 	/* interpret flags as an async trailer */
+ 	evt_code = compl->flags >> ASYNC_TRAILER_EVENT_CODE_SHIFT;
+ 	evt_code &= ASYNC_TRAILER_EVENT_CODE_MASK;
+ 	switch (evt_code) {
+ 	case ASYNC_EVENT_CODE_LINK_STATE:
+ 		beiscsi_process_async_link(phba, compl);
+ 		break;
+ 	case ASYNC_EVENT_CODE_ISCSI:
+ 		phba->state |= BE_ADAPTER_CHECK_BOOT;
+ 		phba->get_boot = BE_GET_BOOT_RETRIES;
+ 		sev = KERN_ERR;
+ 		break;
+ 	case ASYNC_EVENT_CODE_SLI:
+ 		beiscsi_process_async_sli(phba, compl);
+ 		break;
+ 	default:
+ 		/* event not registered */
+ 		sev = KERN_ERR;
+ 	}
+ 
+ 	beiscsi_log(phba, sev, BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+ 		    "BC_%d : ASYNC Event %x: status 0x%08x flags 0x%08x\n",
+ 		    evt_code, compl->status, compl->flags);
+ }
+ 
+ int beiscsi_process_mcc_compl(struct be_ctrl_info *ctrl,
+ 			      struct be_mcc_compl *compl)
++>>>>>>> 69fd6d7b4237 (be2iscsi: Fix be_mcc_compl_poll to use tag_state)
  {
  	struct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);
  	u16 compl_status, extd_status;
@@@ -524,18 -517,19 +662,25 @@@ int beiscsi_process_mcc(struct beiscsi_
   * Failure: Non-Zero
   *
   **/
 -int be_mcc_compl_poll(struct beiscsi_hba *phba, unsigned int tag)
 +static int be_mcc_wait_compl(struct beiscsi_hba *phba)
  {
++<<<<<<< HEAD
 +	int i, status;
++=======
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	int i;
+ 
++>>>>>>> 69fd6d7b4237 (be2iscsi: Fix be_mcc_compl_poll to use tag_state)
  	for (i = 0; i < mcc_timeout; i++) {
  		if (beiscsi_error(phba))
  			return -EIO;
  
 -		beiscsi_process_mcc_cq(phba);
 +		status = beiscsi_process_mcc(phba);
 +		if (status)
 +			return status;
  
- 		if (atomic_read(&phba->ctrl.mcc_obj.q.used) == 0)
+ 		if (!test_bit(MCC_TAG_STATE_RUNNING,
+ 			      &ctrl->ptag_state[tag].tag_state))
  			break;
  		udelay(100);
  	}
* Unmerged path drivers/scsi/be2iscsi/be_cmds.c
