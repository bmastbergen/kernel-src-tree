i2c: designware: make SCL and SDA falling time configurable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Romain Baeriswyl <Romain.Baeriswyl@abilis.com>
commit 6468276b22069d4442aafcd8c59e5d8ccae23f5f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6468276b.failed

This patch allows to set independantly SCL and SDA falling times.
The tLOW period is computed by taking into account the SCL falling time.
The tHIGH period is computed by taking into account the SDA falling time.

For instance in case the margin on tLOW is considered too small, it can
be increased by increasing the SCL falling time which is by default set
at 300ns.

The same applies for tHIGH period with the help of SDA falling time.

	Signed-off-by: Romain Baeriswyl <romainba@abilis.com>
	Reviewed-by: Christian Ruppert <christian.ruppert@abilis.com>
	Acked-by: Shinya Kuribayashi <skuribay@pobox.com>
	Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
(cherry picked from commit 6468276b22069d4442aafcd8c59e5d8ccae23f5f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/devicetree/bindings/i2c/i2c-designware.txt
#	drivers/i2c/busses/i2c-designware-core.h
#	drivers/i2c/busses/i2c-designware-platdrv.c
diff --cc Documentation/devicetree/bindings/i2c/i2c-designware.txt
index e42a2ee233e6,5199b0c8cf7a..000000000000
--- a/Documentation/devicetree/bindings/i2c/i2c-designware.txt
+++ b/Documentation/devicetree/bindings/i2c/i2c-designware.txt
@@@ -10,6 -10,16 +10,19 @@@ Recommended properties 
  
   - clock-frequency : desired I2C bus clock frequency in Hz.
  
++<<<<<<< HEAD
++=======
+ Optional properties :
+  - i2c-sda-hold-time-ns : should contain the SDA hold time in nanoseconds.
+    This option is only supported in hardware blocks version 1.11a or newer.
+ 
+  - i2c-scl-falling-time : should contain the SCL falling time in nanoseconds.
+    This value which is by default 300ns is used to compute the tLOW period.
+ 
+  - i2c-sda-falling-time : should contain the SDA falling time in nanoseconds.
+    This value which is by default 300ns is used to compute the tHIGH period.
+ 
++>>>>>>> 6468276b2206 (i2c: designware: make SCL and SDA falling time configurable)
  Example :
  
  	i2c@f0000 {
@@@ -20,3 -30,16 +33,19 @@@
  		interrupts = <11>;
  		clock-frequency = <400000>;
  	};
++<<<<<<< HEAD
++=======
+ 
+ 	i2c@1120000 {
+ 		#address-cells = <1>;
+ 		#size-cells = <0>;
+ 		compatible = "snps,designware-i2c";
+ 		reg = <0x1120000 0x1000>;
+ 		interrupt-parent = <&ictl>;
+ 		interrupts = <12 1>;
+ 		clock-frequency = <400000>;
+ 		i2c-sda-hold-time-ns = <300>;
+ 		i2c-sda-falling-time-ns = <300>;
+ 		i2c-scl-falling-time-ns = <300>;
+ 	};
++>>>>>>> 6468276b2206 (i2c: designware: make SCL and SDA falling time configurable)
diff --cc drivers/i2c/busses/i2c-designware-core.h
index e761ad18dd61,d66b6cbc9edc..000000000000
--- a/drivers/i2c/busses/i2c-designware-core.h
+++ b/drivers/i2c/busses/i2c-designware-core.h
@@@ -90,6 -98,13 +90,16 @@@ struct dw_i2c_dev 
  	unsigned int		tx_fifo_depth;
  	unsigned int		rx_fifo_depth;
  	int			rx_outstanding;
++<<<<<<< HEAD
++=======
+ 	u32			sda_hold_time;
+ 	u32			sda_falling_time;
+ 	u32			scl_falling_time;
+ 	u16			ss_hcnt;
+ 	u16			ss_lcnt;
+ 	u16			fs_hcnt;
+ 	u16			fs_lcnt;
++>>>>>>> 6468276b2206 (i2c: designware: make SCL and SDA falling time configurable)
  };
  
  #define ACCESS_SWAP		0x00000001
diff --cc drivers/i2c/busses/i2c-designware-platdrv.c
index af62ac49167f,fc243992b4b4..000000000000
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@@ -150,6 -151,23 +150,26 @@@ static int dw_i2c_probe(struct platform
  		return PTR_ERR(dev->clk);
  	clk_prepare_enable(dev->clk);
  
++<<<<<<< HEAD
++=======
+ 	if (pdev->dev.of_node) {
+ 		u32 ht = 0;
+ 		u32 ic_clk = dev->get_clk_rate_khz(dev);
+ 
+ 		of_property_read_u32(pdev->dev.of_node,
+ 					"i2c-sda-hold-time-ns", &ht);
+ 		dev->sda_hold_time = div_u64((u64)ic_clk * ht + 500000,
+ 					     1000000);
+ 
+ 		of_property_read_u32(pdev->dev.of_node,
+ 				     "i2c-sda-falling-time-ns",
+ 				     &dev->sda_falling_time);
+ 		of_property_read_u32(pdev->dev.of_node,
+ 				     "i2c-scl-falling-time-ns",
+ 				     &dev->scl_falling_time);
+ 	}
+ 
++>>>>>>> 6468276b2206 (i2c: designware: make SCL and SDA falling time configurable)
  	dev->functionality =
  		I2C_FUNC_I2C |
  		I2C_FUNC_10BIT_ADDR |
* Unmerged path Documentation/devicetree/bindings/i2c/i2c-designware.txt
diff --git a/drivers/i2c/busses/i2c-designware-core.c b/drivers/i2c/busses/i2c-designware-core.c
index bc5abe76f91f..80bb5ceb95d6 100644
--- a/drivers/i2c/busses/i2c-designware-core.c
+++ b/drivers/i2c/busses/i2c-designware-core.c
@@ -213,7 +213,7 @@ i2c_dw_scl_hcnt(u32 ic_clk, u32 tSYMBOL, u32 tf, int cond, int offset)
 		 *
 		 * If your hardware is free from tHD;STA issue, try this one.
 		 */
-		return (ic_clk * tSYMBOL + 5000) / 10000 - 8 + offset;
+		return (ic_clk * tSYMBOL + 500000) / 1000000 - 8 + offset;
 	else
 		/*
 		 * Conditional expression:
@@ -229,7 +229,8 @@ i2c_dw_scl_hcnt(u32 ic_clk, u32 tSYMBOL, u32 tf, int cond, int offset)
 		 * The reason why we need to take into account "tf" here,
 		 * is the same as described in i2c_dw_scl_lcnt().
 		 */
-		return (ic_clk * (tSYMBOL + tf) + 5000) / 10000 - 3 + offset;
+		return (ic_clk * (tSYMBOL + tf) + 500000) / 1000000
+			- 3 + offset;
 }
 
 static u32 i2c_dw_scl_lcnt(u32 ic_clk, u32 tLOW, u32 tf, int offset)
@@ -245,7 +246,7 @@ static u32 i2c_dw_scl_lcnt(u32 ic_clk, u32 tLOW, u32 tf, int offset)
 	 * account the fall time of SCL signal (tf).  Default tf value
 	 * should be 0.3 us, for safety.
 	 */
-	return ((ic_clk * (tLOW + tf) + 5000) / 10000) - 1 + offset;
+	return ((ic_clk * (tLOW + tf) + 500000) / 1000000) - 1 + offset;
 }
 
 static void __i2c_dw_enable(struct dw_i2c_dev *dev, bool enable)
@@ -282,6 +283,7 @@ int i2c_dw_init(struct dw_i2c_dev *dev)
 	u32 input_clock_khz;
 	u32 hcnt, lcnt;
 	u32 reg;
+	u32 sda_falling_time, scl_falling_time;
 
 	input_clock_khz = dev->get_clk_rate_khz(dev);
 
@@ -303,15 +305,18 @@ int i2c_dw_init(struct dw_i2c_dev *dev)
 
 	/* set standard and fast speed deviders for high/low periods */
 
+	sda_falling_time = dev->sda_falling_time ?: 300; /* ns */
+	scl_falling_time = dev->scl_falling_time ?: 300; /* ns */
+
 	/* Standard-mode */
 	hcnt = i2c_dw_scl_hcnt(input_clock_khz,
-				40,	/* tHD;STA = tHIGH = 4.0 us */
-				3,	/* tf = 0.3 us */
+				4000,	/* tHD;STA = tHIGH = 4.0 us */
+				sda_falling_time,
 				0,	/* 0: DW default, 1: Ideal */
 				0);	/* No offset */
 	lcnt = i2c_dw_scl_lcnt(input_clock_khz,
-				47,	/* tLOW = 4.7 us */
-				3,	/* tf = 0.3 us */
+				4700,	/* tLOW = 4.7 us */
+				scl_falling_time,
 				0);	/* No offset */
 	dw_writel(dev, hcnt, DW_IC_SS_SCL_HCNT);
 	dw_writel(dev, lcnt, DW_IC_SS_SCL_LCNT);
@@ -319,13 +324,13 @@ int i2c_dw_init(struct dw_i2c_dev *dev)
 
 	/* Fast-mode */
 	hcnt = i2c_dw_scl_hcnt(input_clock_khz,
-				6,	/* tHD;STA = tHIGH = 0.6 us */
-				3,	/* tf = 0.3 us */
+				600,	/* tHD;STA = tHIGH = 0.6 us */
+				sda_falling_time,
 				0,	/* 0: DW default, 1: Ideal */
 				0);	/* No offset */
 	lcnt = i2c_dw_scl_lcnt(input_clock_khz,
-				13,	/* tLOW = 1.3 us */
-				3,	/* tf = 0.3 us */
+				1300,	/* tLOW = 1.3 us */
+				scl_falling_time,
 				0);	/* No offset */
 	dw_writel(dev, hcnt, DW_IC_FS_SCL_HCNT);
 	dw_writel(dev, lcnt, DW_IC_FS_SCL_LCNT);
* Unmerged path drivers/i2c/busses/i2c-designware-core.h
* Unmerged path drivers/i2c/busses/i2c-designware-platdrv.c
