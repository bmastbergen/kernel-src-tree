GFS2: Clean up reservation removal

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Steven Whitehouse <swhiteho@redhat.com>
commit af5c269799feaef110e59ce55b497cdd08712b0c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/af5c2697.failed

The reservation for an inode should be cleared when it is truncated so
that we can start again at a different offset for future allocations.
We could try and do better than that, by resetting the search based on
where the truncation started from, but this is only a first step.

In addition, there are three callers of gfs2_rs_delete() but only one
of those should really be testing the value of i_writecount. While
we get away with that in the other cases currently, I think it would
be better if we made that test specific to the one case which
requires it.

	Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
(cherry picked from commit af5c269799feaef110e59ce55b497cdd08712b0c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/inode.c
#	fs/gfs2/super.c
diff --cc fs/gfs2/inode.c
index 4b5ce5a448da,4b79c19100d2..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -722,8 -711,9 +722,14 @@@ fail_gunlock2
  fail_free_inode:
  	if (ip->i_gl)
  		gfs2_glock_put(ip->i_gl);
++<<<<<<< HEAD
 +	gfs2_rs_delete(ip);
 +	free_vfs_inode = 1;
++=======
+ 	gfs2_rs_delete(ip, NULL);
+ 	free_inode_nonrcu(inode);
+ 	inode = NULL;
++>>>>>>> af5c269799fe (GFS2: Clean up reservation removal)
  fail_gunlock:
  	gfs2_glock_dq_uninit(ghs);
  	if (inode && !IS_ERR(inode)) {
diff --cc fs/gfs2/super.c
index 7c8f12885717,35da5b19c0de..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1563,8 -1525,8 +1563,13 @@@ out_unlock
  		fs_warn(sdp, "gfs2_evict_inode: %d\n", error);
  out:
  	/* Case 3 starts here */
++<<<<<<< HEAD
 +	truncate_inode_pages_final(&inode->i_data);
 +	gfs2_rs_delete(ip);
++=======
+ 	truncate_inode_pages(&inode->i_data, 0);
+ 	gfs2_rs_delete(ip, NULL);
++>>>>>>> af5c269799fe (GFS2: Clean up reservation removal)
  	gfs2_ordered_del_inode(ip);
  	clear_inode(inode);
  	gfs2_dir_hash_inval(ip);
diff --git a/fs/gfs2/bmap.c b/fs/gfs2/bmap.c
index c9e860161c6f..9d28e44c8559 100644
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@ -1281,6 +1281,7 @@ do_grow_qunlock:
 
 int gfs2_setattr_size(struct inode *inode, u64 newsize)
 {
+	struct gfs2_inode *ip = GFS2_I(inode);
 	int ret;
 	u64 oldsize;
 
@@ -1296,7 +1297,7 @@ int gfs2_setattr_size(struct inode *inode, u64 newsize)
 
 	inode_dio_wait(inode);
 
-	ret = gfs2_rs_alloc(GFS2_I(inode));
+	ret = gfs2_rs_alloc(ip);
 	if (ret)
 		goto out;
 
@@ -1306,6 +1307,7 @@ int gfs2_setattr_size(struct inode *inode, u64 newsize)
 		goto out;
 	}
 
+	gfs2_rs_deltree(ip->i_res);
 	ret = do_shrink(inode, oldsize, newsize);
 out:
 	put_write_access(inode);
diff --git a/fs/gfs2/file.c b/fs/gfs2/file.c
index 96a7ba9500e8..f4aa1ea5ab3e 100644
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@ -631,7 +631,7 @@ static int gfs2_release(struct inode *inode, struct file *file)
 	if (!(file->f_mode & FMODE_WRITE))
 		return 0;
 
-	gfs2_rs_delete(ip);
+	gfs2_rs_delete(ip, &inode->i_writecount);
 	return 0;
 }
 
* Unmerged path fs/gfs2/inode.c
diff --git a/fs/gfs2/rgrp.c b/fs/gfs2/rgrp.c
index 28da34fba03d..6d8d801ad886 100644
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@ -652,14 +652,13 @@ void gfs2_rs_deltree(struct gfs2_blkreserv *rs)
 /**
  * gfs2_rs_delete - delete a multi-block reservation
  * @ip: The inode for this reservation
+ * @wcount: The inode's write count, or NULL
  *
  */
-void gfs2_rs_delete(struct gfs2_inode *ip)
+void gfs2_rs_delete(struct gfs2_inode *ip, atomic_t *wcount)
 {
-	struct inode *inode = &ip->i_inode;
-
 	down_write(&ip->i_rw_mutex);
-	if (ip->i_res && atomic_read(&inode->i_writecount) <= 1) {
+	if (ip->i_res && ((wcount == NULL) || (atomic_read(wcount) <= 1))) {
 		gfs2_rs_deltree(ip->i_res);
 		BUG_ON(ip->i_res->rs_free);
 		kmem_cache_free(gfs2_rsrv_cachep, ip->i_res);
diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index c4023545919a..dab96987e6d2 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -51,7 +51,7 @@ extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
 
 extern int gfs2_rs_alloc(struct gfs2_inode *ip);
 extern void gfs2_rs_deltree(struct gfs2_blkreserv *rs);
-extern void gfs2_rs_delete(struct gfs2_inode *ip);
+extern void gfs2_rs_delete(struct gfs2_inode *ip, atomic_t *wcount);
 extern void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta);
 extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
 extern void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);
* Unmerged path fs/gfs2/super.c
