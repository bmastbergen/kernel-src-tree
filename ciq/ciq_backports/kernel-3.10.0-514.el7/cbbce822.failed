SCHED: add some "wait..on_bit...timeout()" interfaces.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [kernel] sched: add some "wait..on_bit...timeout()" interfaces (Benjamin Coddington) [1315327]
Rebuild_FUZZ: 99.07%
commit-author NeilBrown <neilb@suse.de>
commit cbbce82209490df8b68da9aec0d642451fe0a668
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/cbbce822.failed

In commit c1221321b7c25b53204447cff9949a6d5a7ddddc
   sched: Allow wait_on_bit_action() functions to support a timeout

I suggested that a "wait_on_bit_timeout()" interface would not meet my
need.  This isn't true - I was just over-engineering.

Including a 'private' field in wait_bit_key instead of a focused
"timeout" field was just premature generalization.  If some other
use is ever found, it can be generalized or added later.

So this patch renames "private" to "timeout" with a meaning "stop
waiting when "jiffies" reaches or passes "timeout",
and adds two of the many possible wait..bit..timeout() interfaces:

wait_on_page_bit_killable_timeout(), which is the one I want to use,
and out_of_line_wait_on_bit_timeout() which is a reasonably general
example.  Others can be added as needed.

	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: NeilBrown <neilb@suse.de>
	Acked-by: Ingo Molnar <mingo@kernel.org>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit cbbce82209490df8b68da9aec0d642451fe0a668)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/wait.h
#	kernel/wait.c
diff --cc include/linux/wait.h
index 65da9e322613,80115bf88671..000000000000
--- a/include/linux/wait.h
+++ b/include/linux/wait.h
@@@ -21,9 -22,10 +21,16 @@@ struct __wait_queue 
  };
  
  struct wait_bit_key {
++<<<<<<< HEAD
 +	void *flags;
 +	int bit_nr;
 +#define WAIT_ATOMIC_T_BIT_NR -1
++=======
+ 	void			*flags;
+ 	int			bit_nr;
+ #define WAIT_ATOMIC_T_BIT_NR	-1
+ 	unsigned long		timeout;
++>>>>>>> cbbce8220949 (SCHED: add some "wait..on_bit...timeout()" interfaces.)
  };
  
  struct wait_bit_queue {
@@@ -147,12 -149,13 +154,18 @@@ void __wake_up_sync_key(wait_queue_head
  void __wake_up_locked(wait_queue_head_t *q, unsigned int mode, int nr);
  void __wake_up_sync(wait_queue_head_t *q, unsigned int mode, int nr);
  void __wake_up_bit(wait_queue_head_t *, void *, int);
 -int __wait_on_bit(wait_queue_head_t *, struct wait_bit_queue *, wait_bit_action_f *, unsigned);
 -int __wait_on_bit_lock(wait_queue_head_t *, struct wait_bit_queue *, wait_bit_action_f *, unsigned);
 +int __wait_on_bit(wait_queue_head_t *, struct wait_bit_queue *, int (*)(void *), unsigned);
 +int __wait_on_bit_lock(wait_queue_head_t *, struct wait_bit_queue *, int (*)(void *), unsigned);
  void wake_up_bit(void *, int);
  void wake_up_atomic_t(atomic_t *);
++<<<<<<< HEAD
 +int out_of_line_wait_on_bit(void *, int, int (*)(void *), unsigned);
 +int out_of_line_wait_on_bit_lock(void *, int, int (*)(void *), unsigned);
++=======
+ int out_of_line_wait_on_bit(void *, int, wait_bit_action_f *, unsigned);
+ int out_of_line_wait_on_bit_timeout(void *, int, wait_bit_action_f *, unsigned, unsigned long);
+ int out_of_line_wait_on_bit_lock(void *, int, wait_bit_action_f *, unsigned);
++>>>>>>> cbbce8220949 (SCHED: add some "wait..on_bit...timeout()" interfaces.)
  int out_of_line_wait_on_atomic_t(atomic_t *, int (*)(atomic_t *), unsigned);
  wait_queue_head_t *bit_waitqueue(void *, int);
  
@@@ -982,6 -857,12 +995,15 @@@ int wake_bit_function(wait_queue_t *wai
  		(wait)->flags = 0;					\
  	} while (0)
  
++<<<<<<< HEAD
++=======
+ 
+ extern int bit_wait(struct wait_bit_key *);
+ extern int bit_wait_io(struct wait_bit_key *);
+ extern int bit_wait_timeout(struct wait_bit_key *);
+ extern int bit_wait_io_timeout(struct wait_bit_key *);
+ 
++>>>>>>> cbbce8220949 (SCHED: add some "wait..on_bit...timeout()" interfaces.)
  /**
   * wait_on_bit - wait for a bit to be cleared
   * @word: the word being waited on, a kernel virtual address
diff --cc kernel/wait.c
index d550920e040c,5a62915f47a8..000000000000
--- a/kernel/wait.c
+++ b/kernel/wait.c
@@@ -216,9 -343,21 +216,21 @@@ int __sched out_of_line_wait_on_bit(voi
  }
  EXPORT_SYMBOL(out_of_line_wait_on_bit);
  
+ int __sched out_of_line_wait_on_bit_timeout(
+ 	void *word, int bit, wait_bit_action_f *action,
+ 	unsigned mode, unsigned long timeout)
+ {
+ 	wait_queue_head_t *wq = bit_waitqueue(word, bit);
+ 	DEFINE_WAIT_BIT(wait, word, bit);
+ 
+ 	wait.key.timeout = jiffies + timeout;
+ 	return __wait_on_bit(wq, &wait, action, mode);
+ }
+ EXPORT_SYMBOL_GPL(out_of_line_wait_on_bit_timeout);
+ 
  int __sched
  __wait_on_bit_lock(wait_queue_head_t *wq, struct wait_bit_queue *q,
 -			wait_bit_action_f *action, unsigned mode)
 +			int (*action)(void *), unsigned mode)
  {
  	do {
  		int ret;
@@@ -375,3 -514,45 +387,48 @@@ void wake_up_atomic_t(atomic_t *p
  	__wake_up_bit(atomic_t_waitqueue(p), p, WAIT_ATOMIC_T_BIT_NR);
  }
  EXPORT_SYMBOL(wake_up_atomic_t);
++<<<<<<< HEAD:kernel/wait.c
++=======
+ 
+ __sched int bit_wait(struct wait_bit_key *word)
+ {
+ 	if (signal_pending_state(current->state, current))
+ 		return 1;
+ 	schedule();
+ 	return 0;
+ }
+ EXPORT_SYMBOL(bit_wait);
+ 
+ __sched int bit_wait_io(struct wait_bit_key *word)
+ {
+ 	if (signal_pending_state(current->state, current))
+ 		return 1;
+ 	io_schedule();
+ 	return 0;
+ }
+ EXPORT_SYMBOL(bit_wait_io);
+ 
+ __sched int bit_wait_timeout(struct wait_bit_key *word)
+ {
+ 	unsigned long now = ACCESS_ONCE(jiffies);
+ 	if (signal_pending_state(current->state, current))
+ 		return 1;
+ 	if (time_after_eq(now, word->timeout))
+ 		return -EAGAIN;
+ 	schedule_timeout(word->timeout - now);
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(bit_wait_timeout);
+ 
+ __sched int bit_wait_io_timeout(struct wait_bit_key *word)
+ {
+ 	unsigned long now = ACCESS_ONCE(jiffies);
+ 	if (signal_pending_state(current->state, current))
+ 		return 1;
+ 	if (time_after_eq(now, word->timeout))
+ 		return -EAGAIN;
+ 	io_schedule_timeout(word->timeout - now);
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(bit_wait_io_timeout);
++>>>>>>> cbbce8220949 (SCHED: add some "wait..on_bit...timeout()" interfaces.):kernel/sched/wait.c
diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h
index 5c0d28084fa4..c12e6cd1f8ca 100644
--- a/include/linux/pagemap.h
+++ b/include/linux/pagemap.h
@@ -402,6 +402,8 @@ static inline int lock_page_or_retry(struct page *page, struct mm_struct *mm,
 extern void wait_on_page_bit(struct page *page, int bit_nr);
 
 extern int wait_on_page_bit_killable(struct page *page, int bit_nr);
+extern int wait_on_page_bit_killable_timeout(struct page *page,
+					     int bit_nr, unsigned long timeout);
 
 static inline int wait_on_page_locked_killable(struct page *page)
 {
* Unmerged path include/linux/wait.h
* Unmerged path kernel/wait.c
diff --git a/mm/filemap.c b/mm/filemap.c
index 47bfefb20cf3..770327045eb4 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -702,6 +702,19 @@ int wait_on_page_bit_killable(struct page *page, int bit_nr)
 			     sleep_on_page_killable, TASK_KILLABLE);
 }
 
+int wait_on_page_bit_killable_timeout(struct page *page,
+				       int bit_nr, unsigned long timeout)
+{
+	DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);
+
+	wait.key.timeout = jiffies + timeout;
+	if (!test_bit(bit_nr, &page->flags))
+		return 0;
+	return __wait_on_bit(page_waitqueue(page), &wait,
+			     bit_wait_io_timeout, TASK_KILLABLE);
+}
+EXPORT_SYMBOL_GPL(wait_on_page_bit_killable_timeout);
+
 /**
  * add_page_wait_queue - Add an arbitrary waiter to a page's wait queue
  * @page: Page defining the wait queue of interest
