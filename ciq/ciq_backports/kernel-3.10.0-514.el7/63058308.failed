udp: Add udp6_lib_lookup_skb and udp4_lib_lookup_skb

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tom Herbert <tom@herbertland.com>
commit 63058308cd55182bbfd7a87970bd57883fcfbd2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/63058308.failed

Add externally visible functions to lookup a UDP socket by skb. This
will be used for GRO in UDP sockets. These functions also check
if skb->dst is set, and if it is not skb->dev is used to get dev_net.
This allows calling lookup functions before dst has been set on the
skbuff.

	Signed-off-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 63058308cd55182bbfd7a87970bd57883fcfbd2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/udp.h
#	net/ipv4/udp.c
#	net/ipv6/udp.c
diff --cc include/net/udp.h
index 912b9df8457c,3aa0b3ec1fb0..000000000000
--- a/include/net/udp.h
+++ b/include/net/udp.h
@@@ -224,39 -243,45 +224,81 @@@ static inline __be16 udp_flow_src_port(
  }
  
  /* net/ipv4/udp.c */
++<<<<<<< HEAD
 +extern int udp_get_port(struct sock *sk, unsigned short snum,
 +			int (*saddr_cmp)(const struct sock *,
 +					 const struct sock *));
 +extern void udp_err(struct sk_buff *, u32);
 +extern int udp_sendmsg(struct kiocb *iocb, struct sock *sk,
 +			    struct msghdr *msg, size_t len);
 +extern int udp_push_pending_frames(struct sock *sk);
 +extern void udp_flush_pending_frames(struct sock *sk);
 +extern int udp_rcv(struct sk_buff *skb);
 +extern int udp_ioctl(struct sock *sk, int cmd, unsigned long arg);
 +extern int udp_disconnect(struct sock *sk, int flags);
 +extern unsigned int udp_poll(struct file *file, struct socket *sock,
 +			     poll_table *wait);
 +extern struct sk_buff *skb_udp_tunnel_segment(struct sk_buff *skb,
 +					      netdev_features_t features,
 +					      bool is_ipv6);
 +extern int udp_lib_getsockopt(struct sock *sk, int level, int optname,
 +			      char __user *optval, int __user *optlen);
 +extern int udp_lib_setsockopt(struct sock *sk, int level, int optname,
 +			      char __user *optval, unsigned int optlen,
 +			      int (*push_pending_frames)(struct sock *));
 +extern struct sock *udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,
 +				    __be32 daddr, __be16 dport,
 +				    int dif);
 +extern struct sock *__udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,
 +				    __be32 daddr, __be16 dport,
 +				    int dif, struct udp_table *tbl);
 +extern struct sock *udp6_lib_lookup(struct net *net, const struct in6_addr *saddr, __be16 sport,
 +				    const struct in6_addr *daddr, __be16 dport,
 +				    int dif);
 +extern struct sock *__udp6_lib_lookup(struct net *net, const struct in6_addr *saddr, __be16 sport,
 +				    const struct in6_addr *daddr, __be16 dport,
 +				    int dif, struct udp_table *tbl);
++=======
+ void udp_v4_early_demux(struct sk_buff *skb);
+ int udp_get_port(struct sock *sk, unsigned short snum,
+ 		 int (*saddr_cmp)(const struct sock *,
+ 				  const struct sock *));
+ void udp_err(struct sk_buff *, u32);
+ int udp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len);
+ int udp_push_pending_frames(struct sock *sk);
+ void udp_flush_pending_frames(struct sock *sk);
+ void udp4_hwcsum(struct sk_buff *skb, __be32 src, __be32 dst);
+ int udp_rcv(struct sk_buff *skb);
+ int udp_ioctl(struct sock *sk, int cmd, unsigned long arg);
+ int udp_disconnect(struct sock *sk, int flags);
+ unsigned int udp_poll(struct file *file, struct socket *sock, poll_table *wait);
+ struct sk_buff *skb_udp_tunnel_segment(struct sk_buff *skb,
+ 				       netdev_features_t features,
+ 				       bool is_ipv6);
+ int udp_lib_getsockopt(struct sock *sk, int level, int optname,
+ 		       char __user *optval, int __user *optlen);
+ int udp_lib_setsockopt(struct sock *sk, int level, int optname,
+ 		       char __user *optval, unsigned int optlen,
+ 		       int (*push_pending_frames)(struct sock *));
+ struct sock *udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,
+ 			     __be32 daddr, __be16 dport, int dif);
+ struct sock *__udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,
+ 			       __be32 daddr, __be16 dport, int dif,
+ 			       struct udp_table *tbl, struct sk_buff *skb);
+ struct sock *udp4_lib_lookup_skb(struct sk_buff *skb,
+ 				 __be16 sport, __be16 dport);
+ struct sock *udp6_lib_lookup(struct net *net,
+ 			     const struct in6_addr *saddr, __be16 sport,
+ 			     const struct in6_addr *daddr, __be16 dport,
+ 			     int dif);
+ struct sock *__udp6_lib_lookup(struct net *net,
+ 			       const struct in6_addr *saddr, __be16 sport,
+ 			       const struct in6_addr *daddr, __be16 dport,
+ 			       int dif, struct udp_table *tbl,
+ 			       struct sk_buff *skb);
+ struct sock *udp6_lib_lookup_skb(struct sk_buff *skb,
+ 				 __be16 sport, __be16 dport);
++>>>>>>> 63058308cd55 (udp: Add udp6_lib_lookup_skb and udp4_lib_lookup_skb)
  
  /*
   * 	SNMP statistics for UDP and UDP-Lite
diff --cc net/ipv4/udp.c
index 556580e2c4f8,3563788d064f..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -560,17 -597,31 +560,38 @@@ static inline struct sock *__udp4_lib_l
  						 __be16 sport, __be16 dport,
  						 struct udp_table *udptable)
  {
 +	struct sock *sk;
  	const struct iphdr *iph = ip_hdr(skb);
  
 -	return __udp4_lib_lookup(dev_net(skb_dst(skb)->dev), iph->saddr, sport,
 -				 iph->daddr, dport, inet_iif(skb),
 -				 udptable, skb);
 +	if (unlikely(sk = skb_steal_sock(skb)))
 +		return sk;
 +	else
 +		return __udp4_lib_lookup(dev_net(skb_dst(skb)->dev), iph->saddr, sport,
 +					 iph->daddr, dport, inet_iif(skb),
 +					 udptable);
  }
  
++<<<<<<< HEAD
++=======
+ struct sock *udp4_lib_lookup_skb(struct sk_buff *skb,
+ 				 __be16 sport, __be16 dport)
+ {
+ 	const struct iphdr *iph = ip_hdr(skb);
+ 	const struct net_device *dev =
+ 	    skb_dst(skb) ? skb_dst(skb)->dev : skb->dev;
+ 
+ 	return __udp4_lib_lookup(dev_net(dev), iph->saddr, sport,
+ 				 iph->daddr, dport, inet_iif(skb),
+ 				 &udp_table, skb);
+ }
+ EXPORT_SYMBOL_GPL(udp4_lib_lookup_skb);
+ 
+ /* Must be called under rcu_read_lock().
+  * Does increment socket refcount.
+  */
+ #if IS_ENABLED(CONFIG_NETFILTER_XT_MATCH_SOCKET) || \
+     IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TPROXY)
++>>>>>>> 63058308cd55 (udp: Add udp6_lib_lookup_skb and udp4_lib_lookup_skb)
  struct sock *udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,
  			     __be32 daddr, __be16 dport, int dif)
  {
diff --cc net/ipv6/udp.c
index 2c9dae38dffd,a050b70b9101..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -362,9 -323,27 +362,30 @@@ static struct sock *__udp6_lib_lookup_s
  		return sk;
  	return __udp6_lib_lookup(dev_net(skb_dst(skb)->dev), &iph->saddr, sport,
  				 &iph->daddr, dport, inet6_iif(skb),
 -				 udptable, skb);
 +				 udptable);
  }
  
++<<<<<<< HEAD
++=======
+ struct sock *udp6_lib_lookup_skb(struct sk_buff *skb,
+ 				 __be16 sport, __be16 dport)
+ {
+ 	const struct ipv6hdr *iph = ipv6_hdr(skb);
+ 	const struct net_device *dev =
+ 	    skb_dst(skb) ? skb_dst(skb)->dev : skb->dev;
+ 
+ 	return __udp6_lib_lookup(dev_net(dev), &iph->saddr, sport,
+ 				 &iph->daddr, dport, inet6_iif(skb),
+ 				 &udp_table, skb);
+ }
+ EXPORT_SYMBOL_GPL(udp6_lib_lookup_skb);
+ 
+ /* Must be called under rcu_read_lock().
+  * Does increment socket refcount.
+  */
+ #if IS_ENABLED(CONFIG_NETFILTER_XT_MATCH_SOCKET) || \
+     IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TPROXY)
++>>>>>>> 63058308cd55 (udp: Add udp6_lib_lookup_skb and udp4_lib_lookup_skb)
  struct sock *udp6_lib_lookup(struct net *net, const struct in6_addr *saddr, __be16 sport,
  			     const struct in6_addr *daddr, __be16 dport, int dif)
  {
* Unmerged path include/net/udp.h
* Unmerged path net/ipv4/udp.c
* Unmerged path net/ipv6/udp.c
