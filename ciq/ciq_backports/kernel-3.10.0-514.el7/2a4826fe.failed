net/mlx5_core: Add VF param when querying vport counter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [include] mlx5_core: Add VF param when querying vport counter (kamal heib) [1275159 1296272 1296405 1298421 1298422 1298423 1298424 1298425]
Rebuild_FUZZ: 96.23%
commit-author Eli Cohen <eli@mellanox.com>
commit 2a4826fe746e01712ca53902ee75c1a1f6c0a4aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2a4826fe.failed

Add a vf parameter to mlx5_core_query_vport_counter so we can call it to
query counters of virtual functions. Also update current users of the
API.

PFs may call mlx5_core_query_vport_counter with other_vport set to
indicate that they are querying a virtual function. The virtual
function to be queried is given by the vf parameter. Virtual function
numbering is zero based so the first VF is 0 and so on. When a PF
queries its own function, the other_vport parameter is cleared.

	Signed-off-by: Eli Cohen <eli@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 2a4826fe746e01712ca53902ee75c1a1f6c0a4aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/vport.c
#	include/linux/mlx5/vport.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/vport.c
index 076197efea9b,2b836d0b4738..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/vport.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/vport.c
@@@ -750,3 -809,85 +750,88 @@@ int mlx5_modify_nic_vport_promisc(struc
  	return err;
  }
  EXPORT_SYMBOL_GPL(mlx5_modify_nic_vport_promisc);
++<<<<<<< HEAD
++=======
+ 
+ enum mlx5_vport_roce_state {
+ 	MLX5_VPORT_ROCE_DISABLED = 0,
+ 	MLX5_VPORT_ROCE_ENABLED  = 1,
+ };
+ 
+ static int mlx5_nic_vport_update_roce_state(struct mlx5_core_dev *mdev,
+ 					    enum mlx5_vport_roce_state state)
+ {
+ 	void *in;
+ 	int inlen = MLX5_ST_SZ_BYTES(modify_nic_vport_context_in);
+ 	int err;
+ 
+ 	in = mlx5_vzalloc(inlen);
+ 	if (!in) {
+ 		mlx5_core_warn(mdev, "failed to allocate inbox\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	MLX5_SET(modify_nic_vport_context_in, in, field_select.roce_en, 1);
+ 	MLX5_SET(modify_nic_vport_context_in, in, nic_vport_context.roce_en,
+ 		 state);
+ 
+ 	err = mlx5_modify_nic_vport_context(mdev, in, inlen);
+ 
+ 	kvfree(in);
+ 
+ 	return err;
+ }
+ 
+ int mlx5_nic_vport_enable_roce(struct mlx5_core_dev *mdev)
+ {
+ 	return mlx5_nic_vport_update_roce_state(mdev, MLX5_VPORT_ROCE_ENABLED);
+ }
+ EXPORT_SYMBOL_GPL(mlx5_nic_vport_enable_roce);
+ 
+ int mlx5_nic_vport_disable_roce(struct mlx5_core_dev *mdev)
+ {
+ 	return mlx5_nic_vport_update_roce_state(mdev, MLX5_VPORT_ROCE_DISABLED);
+ }
+ EXPORT_SYMBOL_GPL(mlx5_nic_vport_disable_roce);
+ 
+ int mlx5_core_query_vport_counter(struct mlx5_core_dev *dev, u8 other_vport,
+ 				  int vf, u8 port_num, void *out,
+ 				  size_t out_sz)
+ {
+ 	int	in_sz = MLX5_ST_SZ_BYTES(query_vport_counter_in);
+ 	int	is_group_manager;
+ 	void   *in;
+ 	int	err;
+ 
+ 	is_group_manager = MLX5_CAP_GEN(dev, vport_group_manager);
+ 	in = mlx5_vzalloc(in_sz);
+ 	if (!in) {
+ 		err = -ENOMEM;
+ 		return err;
+ 	}
+ 
+ 	MLX5_SET(query_vport_counter_in, in, opcode,
+ 		 MLX5_CMD_OP_QUERY_VPORT_COUNTER);
+ 	if (other_vport) {
+ 		if (is_group_manager) {
+ 			MLX5_SET(query_vport_counter_in, in, other_vport, 1);
+ 			MLX5_SET(query_vport_counter_in, in, vport_number, vf + 1);
+ 		} else {
+ 			err = -EPERM;
+ 			goto free;
+ 		}
+ 	}
+ 	if (MLX5_CAP_GEN(dev, num_ports) == 2)
+ 		MLX5_SET(query_vport_counter_in, in, port_num, port_num);
+ 
+ 	err = mlx5_cmd_exec(dev, in, in_sz, out,  out_sz);
+ 	if (err)
+ 		goto free;
+ 	err = mlx5_cmd_status_to_err_v2(out);
+ 
+ free:
+ 	kvfree(in);
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(mlx5_core_query_vport_counter);
++>>>>>>> 2a4826fe746e (net/mlx5_core: Add VF param when querying vport counter)
diff --cc include/linux/mlx5/vport.h
index 638f2ca7a527,aafb3e48b5f8..000000000000
--- a/include/linux/mlx5/vport.h
+++ b/include/linux/mlx5/vport.h
@@@ -85,4 -90,10 +85,13 @@@ int mlx5_modify_nic_vport_vlans(struct 
  				u16 vlans[],
  				int list_size);
  
++<<<<<<< HEAD
++=======
+ int mlx5_nic_vport_enable_roce(struct mlx5_core_dev *mdev);
+ int mlx5_nic_vport_disable_roce(struct mlx5_core_dev *mdev);
+ int mlx5_core_query_vport_counter(struct mlx5_core_dev *dev, u8 other_vport,
+ 				  int vf, u8 port_num, void *out,
+ 				  size_t out_sz);
+ 
++>>>>>>> 2a4826fe746e (net/mlx5_core: Add VF param when querying vport counter)
  #endif /* __MLX5_VPORT_H__ */
diff --git a/drivers/infiniband/hw/mlx5/mad.c b/drivers/infiniband/hw/mlx5/mad.c
index 41d8a0036465..1534af113058 100644
--- a/drivers/infiniband/hw/mlx5/mad.c
+++ b/drivers/infiniband/hw/mlx5/mad.c
@@ -208,7 +208,7 @@ static int process_pma_cmd(struct ib_device *ibdev, u8 port_num,
 		if (!out_cnt)
 			return IB_MAD_RESULT_FAILURE;
 
-		err = mlx5_core_query_vport_counter(dev->mdev, 0,
+		err = mlx5_core_query_vport_counter(dev->mdev, 0, 0,
 						    port_num, out_cnt, sz);
 		if (!err)
 			pma_cnt_ext_assign(pma_cnt_ext, out_cnt);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/vport.c
* Unmerged path include/linux/mlx5/vport.h
