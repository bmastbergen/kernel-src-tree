libceph: schedule tick from ceph_osdc_init()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ilya Dryomov <idryomov@gmail.com>
commit fbca963532eba779bffa14c70d1dc619e6bfa16d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fbca9635.failed

Both homeless OSD sessions and watch/notify v2, introduced in later
commits, require periodic ticks which don't depend on ->num_requests.
Schedule the initial tick from ceph_osdc_init() and reschedule from
handle_timeout() unconditionally.

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit fbca963532eba779bffa14c70d1dc619e6bfa16d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ceph/osd_client.c
diff --cc net/ceph/osd_client.c
index 4e649b707367,41dabce9c9c3..000000000000
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@@ -1163,17 -1138,6 +1163,20 @@@ static int __reset_osd(struct ceph_osd_
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void __schedule_osd_timeout(struct ceph_osd_client *osdc)
 +{
 +	schedule_delayed_work(&osdc->timeout_work,
 +			osdc->client->options->osd_keepalive_timeout * HZ);
 +}
 +
 +static void __cancel_osd_timeout(struct ceph_osd_client *osdc)
 +{
 +	cancel_delayed_work(&osdc->timeout_work);
 +}
 +
++=======
++>>>>>>> fbca963532eb (libceph: schedule tick from ceph_osdc_init())
  /*
   * Register request, assign tid.  If this is the first request, set up
   * the timeout event.
@@@ -1520,14 -1673,19 +1514,11 @@@ static int __ceph_osdc_start_request(st
  	return 0;
  }
  
 -static void __complete_request(struct ceph_osd_request *req)
 -{
 -	if (req->r_callback)
 -		req->r_callback(req);
 -	else
 -		complete_all(&req->r_completion);
 -}
 -
  /*
-  * Timeout callback, called every N seconds when 1 or more osd
-  * requests has been active for more than N seconds.  When this
-  * happens, we ping all OSDs with requests who have timed out to
-  * ensure any communications channel reset is detected.  Reset the
-  * request timeouts another N seconds in the future as we go.
-  * Reschedule the timeout event another N seconds in future (unless
-  * there are no open requests).
+  * Timeout callback, called every N seconds.  When 1 or more OSD
+  * requests has been active for more than N seconds, we send a keepalive
+  * (tag + timestamp) to its OSD to ensure any communications channel
+  * reset is detected.
   */
  static void handle_timeout(struct work_struct *work)
  {
@@@ -2617,6 -2728,11 +2610,14 @@@ int ceph_osdc_init(struct ceph_osd_clie
  	if (!osdc->notify_wq)
  		goto out_msgpool_reply;
  
++<<<<<<< HEAD
++=======
+ 	schedule_delayed_work(&osdc->timeout_work,
+ 			      osdc->client->options->osd_keepalive_timeout);
+ 	schedule_delayed_work(&osdc->osds_timeout_work,
+ 	    round_jiffies_relative(osdc->client->options->osd_idle_ttl));
+ 
++>>>>>>> fbca963532eb (libceph: schedule tick from ceph_osdc_init())
  	return 0;
  
  out_msgpool_reply:
* Unmerged path net/ceph/osd_client.c
