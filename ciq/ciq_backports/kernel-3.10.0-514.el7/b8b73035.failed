mei: consume flow control on the first chunk of writing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit b8b730357967ac2ec49dcffd2dc2b354f0fdd011
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b8b73035.failed

Consume the write flow control on the first chunk of the write instead
of on the buffer completion.
We can safely assume that the consequent chunks have the flow control
granted.

This addresses two issues:

1. Blocks other callbacks from the same client riding on the client's
flow control and prevents interleaving of messages as FW cannot distinguish
between two messages from the same client.

2. Fixes single buffer flow control arbitration in a clean way, without
connection/disconnection book keeping

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit b8b730357967ac2ec49dcffd2dc2b354f0fdd011)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/client.c
diff --cc drivers/misc/mei/client.c
index 3c539de435ba,ce88c2199b2c..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -448,6 -730,117 +448,120 @@@ bool mei_hbuf_acquire(struct mei_devic
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mei_cl_set_disconnected - set disconnected state and clear
+  *   associated states and resources
+  *
+  * @cl: host client
+  */
+ void mei_cl_set_disconnected(struct mei_cl *cl)
+ {
+ 	struct mei_device *dev = cl->dev;
+ 
+ 	if (cl->state == MEI_FILE_DISCONNECTED ||
+ 	    cl->state == MEI_FILE_INITIALIZING)
+ 		return;
+ 
+ 	cl->state = MEI_FILE_DISCONNECTED;
+ 	mei_io_list_flush(&dev->ctrl_rd_list, cl);
+ 	mei_io_list_flush(&dev->ctrl_wr_list, cl);
+ 	cl->mei_flow_ctrl_creds = 0;
+ 	cl->timer_count = 0;
+ 
+ 	if (!cl->me_cl)
+ 		return;
+ 
+ 	if (!WARN_ON(cl->me_cl->connect_count == 0))
+ 		cl->me_cl->connect_count--;
+ 
+ 	mei_me_cl_put(cl->me_cl);
+ 	cl->me_cl = NULL;
+ }
+ 
+ static int mei_cl_set_connecting(struct mei_cl *cl, struct mei_me_client *me_cl)
+ {
+ 	if (!mei_me_cl_get(me_cl))
+ 		return -ENOENT;
+ 
+ 	/* only one connection is allowed for fixed address clients */
+ 	if (me_cl->props.fixed_address) {
+ 		if (me_cl->connect_count) {
+ 			mei_me_cl_put(me_cl);
+ 			return -EBUSY;
+ 		}
+ 	}
+ 
+ 	cl->me_cl = me_cl;
+ 	cl->state = MEI_FILE_CONNECTING;
+ 	cl->me_cl->connect_count++;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * mei_cl_send_disconnect - send disconnect request
+  *
+  * @cl: host client
+  * @cb: callback block
+  *
+  * Return: 0, OK; otherwise, error.
+  */
+ static int mei_cl_send_disconnect(struct mei_cl *cl, struct mei_cl_cb *cb)
+ {
+ 	struct mei_device *dev;
+ 	int ret;
+ 
+ 	dev = cl->dev;
+ 
+ 	ret = mei_hbm_cl_disconnect_req(dev, cl);
+ 	cl->status = ret;
+ 	if (ret) {
+ 		cl->state = MEI_FILE_DISCONNECT_REPLY;
+ 		return ret;
+ 	}
+ 
+ 	list_move_tail(&cb->list, &dev->ctrl_rd_list.list);
+ 	cl->timer_count = MEI_CONNECT_TIMEOUT;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * mei_cl_irq_disconnect - processes close related operation from
+  *	interrupt thread context - send disconnect request
+  *
+  * @cl: client
+  * @cb: callback block.
+  * @cmpl_list: complete list.
+  *
+  * Return: 0, OK; otherwise, error.
+  */
+ int mei_cl_irq_disconnect(struct mei_cl *cl, struct mei_cl_cb *cb,
+ 			    struct mei_cl_cb *cmpl_list)
+ {
+ 	struct mei_device *dev = cl->dev;
+ 	u32 msg_slots;
+ 	int slots;
+ 	int ret;
+ 
+ 	msg_slots = mei_data2slots(sizeof(struct hbm_client_connect_request));
+ 	slots = mei_hbuf_empty_slots(dev);
+ 
+ 	if (slots < msg_slots)
+ 		return -EMSGSIZE;
+ 
+ 	ret = mei_cl_send_disconnect(cl, cb);
+ 	if (ret)
+ 		list_move_tail(&cb->list, &cmpl_list->list);
+ 
+ 	return ret;
+ }
+ 
+ 
+ 
+ /**
++>>>>>>> b8b730357967 (mei: consume flow control on the first chunk of writing)
   * mei_cl_disconnect - disconnect host client from the me one
   *
   * @cl: host client
@@@ -818,9 -1276,11 +933,11 @@@ int mei_cl_irq_write(struct mei_cl *cl
  
  	dev = cl->dev;
  
 -	buf = &cb->buf;
 +	buf = &cb->request_buffer;
  
- 	rets = mei_cl_flow_ctrl_creds(cl);
+ 	first_chunk = cb->buf_idx == 0;
+ 
+ 	rets = first_chunk ? mei_cl_flow_ctrl_creds(cl) : 1;
  	if (rets < 0)
  		return rets;
  
@@@ -865,13 -1325,16 +982,15 @@@
  	cl->status = 0;
  	cl->writing_state = MEI_WRITING;
  	cb->buf_idx += mei_hdr.length;
 -	cb->completed = mei_hdr.msg_complete == 1;
  
- 	if (mei_hdr.msg_complete) {
+ 	if (first_chunk) {
  		if (mei_cl_flow_ctrl_reduce(cl))
  			return -EIO;
- 		list_move_tail(&cb->list, &dev->write_waiting_list.list);
  	}
  
+ 	if (mei_hdr.msg_complete)
+ 		list_move_tail(&cb->list, &dev->write_waiting_list.list);
+ 
  	return 0;
  }
  
@@@ -950,20 -1413,19 +1069,18 @@@ int mei_cl_write(struct mei_cl *cl, str
  	if (rets)
  		goto err;
  
+ 	rets = mei_cl_flow_ctrl_reduce(cl);
+ 	if (rets)
+ 		goto err;
+ 
  	cl->writing_state = MEI_WRITING;
  	cb->buf_idx = mei_hdr.length;
 -	cb->completed = mei_hdr.msg_complete == 1;
  
  out:
- 	if (mei_hdr.msg_complete) {
- 		rets = mei_cl_flow_ctrl_reduce(cl);
- 		if (rets < 0)
- 			goto err;
- 
+ 	if (mei_hdr.msg_complete)
  		list_add_tail(&cb->list, &dev->write_waiting_list.list);
- 	} else {
+ 	else
  		list_add_tail(&cb->list, &dev->write_list.list);
- 	}
- 
  
  	if (blocking && cl->writing_state != MEI_WRITE_COMPLETE) {
  
* Unmerged path drivers/misc/mei/client.c
