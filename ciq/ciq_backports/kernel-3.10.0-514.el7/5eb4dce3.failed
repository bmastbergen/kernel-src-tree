net: relax setup_tc ndo op handle restriction

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] relax setup_tc ndo op handle restriction (Ivan Vecera) [1268334]
Rebuild_FUZZ: 94.12%
commit-author John Fastabend <john.fastabend@gmail.com>
commit 5eb4dce3b3471ec9d1ea2945fa3d2bab4ac7e100
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5eb4dce3.failed

I added this check in setup_tc to multiple drivers,

 if (handle != TC_H_ROOT || tc->type != TC_SETUP_MQPRIO)

Unfortunately restricting to TC_H_ROOT like this breaks the old
instantiation of mqprio to setup a hardware qdisc. This patch
relaxes the test to only check the type to make it equivalent
to the check before I broke it. With this the old instantiation
continues to work.

A good smoke test is to setup mqprio with,

# tc qdisc add dev eth4 root mqprio num_tc 8 \
  map 0 1 2 3 4 5 6 7 \
  queues 0@0 1@1 2@2 3@3 4@4 5@5 6@6 7@7

Fixes: e4c6734eaab9 ("net: rework ndo tc op to consume additional qdisc handle paramete")
	Reported-by: Singh Krishneil <krishneil.k.singh@intel.com>
	Reported-by: Jake Keller <jacob.e.keller@intel.com>
CC: Murali Karicheri <m-karicheri2@ti.com>
CC: Shradha Shah <sshah@solarflare.com>
CC: Or Gerlitz <ogerlitz@mellanox.com>
CC: Ariel Elior <ariel.elior@qlogic.com>
CC: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
CC: Bruce Allan <bruce.w.allan@intel.com>
CC: Jesse Brandeburg <jesse.brandeburg@intel.com>
CC: Don Skidmore <donald.c.skidmore@intel.com>
	Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5eb4dce3b3471ec9d1ea2945fa3d2bab4ac7e100)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/xgbe-drv.c
#	drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
#	drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
#	drivers/net/ethernet/mellanox/mlx4/en_netdev.c
#	drivers/net/ethernet/sfc/tx.c
#	drivers/net/ethernet/ti/netcp_core.c
diff --cc drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
index 9d9661974791,a949783c8fc3..000000000000
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
@@@ -4207,6 -4272,14 +4207,17 @@@ int bnx2x_setup_tc(struct net_device *d
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ int __bnx2x_setup_tc(struct net_device *dev, u32 handle, __be16 proto,
+ 		     struct tc_to_netdev *tc)
+ {
+ 	if (tc->type != TC_SETUP_MQPRIO)
+ 		return -EINVAL;
+ 	return bnx2x_setup_tc(dev, tc->tc);
+ }
+ 
++>>>>>>> 5eb4dce3b347 (net: relax setup_tc ndo op handle restriction)
  /* called with rtnl_lock */
  int bnx2x_change_mac_addr(struct net_device *dev, void *p)
  {
diff --cc drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
index 0159d99139e6,d09a8dd71fc2..000000000000
--- a/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
+++ b/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
@@@ -1184,6 -1194,23 +1184,26 @@@ int fm10k_setup_tc(struct net_device *d
  	interface->flags |= FM10K_FLAG_SWPRI_CONFIG;
  
  	return 0;
++<<<<<<< HEAD
++=======
+ err_open:
+ 	fm10k_mbx_free_irq(interface);
+ err_mbx_irq:
+ 	fm10k_clear_queueing_scheme(interface);
+ err_queueing_scheme:
+ 	netif_device_detach(dev);
+ 
+ 	return err;
+ }
+ 
+ static int __fm10k_setup_tc(struct net_device *dev, u32 handle, __be16 proto,
+ 			    struct tc_to_netdev *tc)
+ {
+ 	if (tc->type != TC_SETUP_MQPRIO)
+ 		return -EINVAL;
+ 
+ 	return fm10k_setup_tc(dev, tc->tc);
++>>>>>>> 5eb4dce3b347 (net: relax setup_tc ndo op handle restriction)
  }
  
  static int fm10k_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index e464f2e3e2eb,4d6223da4a19..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -7521,6 -8206,225 +7521,228 @@@ int ixgbe_setup_tc(struct net_device *d
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int ixgbe_delete_clsu32(struct ixgbe_adapter *adapter,
+ 			       struct tc_cls_u32_offload *cls)
+ {
+ 	int err;
+ 
+ 	spin_lock(&adapter->fdir_perfect_lock);
+ 	err = ixgbe_update_ethtool_fdir_entry(adapter, NULL, cls->knode.handle);
+ 	spin_unlock(&adapter->fdir_perfect_lock);
+ 	return err;
+ }
+ 
+ static int ixgbe_configure_clsu32_add_hnode(struct ixgbe_adapter *adapter,
+ 					    __be16 protocol,
+ 					    struct tc_cls_u32_offload *cls)
+ {
+ 	/* This ixgbe devices do not support hash tables at the moment
+ 	 * so abort when given hash tables.
+ 	 */
+ 	if (cls->hnode.divisor > 0)
+ 		return -EINVAL;
+ 
+ 	set_bit(TC_U32_USERHTID(cls->hnode.handle), &adapter->tables);
+ 	return 0;
+ }
+ 
+ static int ixgbe_configure_clsu32_del_hnode(struct ixgbe_adapter *adapter,
+ 					    struct tc_cls_u32_offload *cls)
+ {
+ 	clear_bit(TC_U32_USERHTID(cls->hnode.handle), &adapter->tables);
+ 	return 0;
+ }
+ 
+ static int ixgbe_configure_clsu32(struct ixgbe_adapter *adapter,
+ 				  __be16 protocol,
+ 				  struct tc_cls_u32_offload *cls)
+ {
+ 	u32 loc = cls->knode.handle & 0xfffff;
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	struct ixgbe_mat_field *field_ptr;
+ 	struct ixgbe_fdir_filter *input;
+ 	union ixgbe_atr_input mask;
+ #ifdef CONFIG_NET_CLS_ACT
+ 	const struct tc_action *a;
+ #endif
+ 	int i, err = 0;
+ 	u8 queue;
+ 	u32 handle;
+ 
+ 	memset(&mask, 0, sizeof(union ixgbe_atr_input));
+ 	handle = cls->knode.handle;
+ 
+ 	/* At the moment cls_u32 jumps to transport layer and skips past
+ 	 * L2 headers. The canonical method to match L2 frames is to use
+ 	 * negative values. However this is error prone at best but really
+ 	 * just broken because there is no way to "know" what sort of hdr
+ 	 * is in front of the transport layer. Fix cls_u32 to support L2
+ 	 * headers when needed.
+ 	 */
+ 	if (protocol != htons(ETH_P_IP))
+ 		return -EINVAL;
+ 
+ 	if (cls->knode.link_handle ||
+ 	    cls->knode.link_handle >= IXGBE_MAX_LINK_HANDLE) {
+ 		struct ixgbe_nexthdr *nexthdr = ixgbe_ipv4_jumps;
+ 		u32 uhtid = TC_U32_USERHTID(cls->knode.link_handle);
+ 
+ 		if (!test_bit(uhtid, &adapter->tables))
+ 			return -EINVAL;
+ 
+ 		for (i = 0; nexthdr[i].jump; i++) {
+ 			if (nexthdr->o != cls->knode.sel->offoff ||
+ 			    nexthdr->s != cls->knode.sel->offshift ||
+ 			    nexthdr->m != cls->knode.sel->offmask ||
+ 			    /* do not support multiple key jumps its just mad */
+ 			    cls->knode.sel->nkeys > 1)
+ 				return -EINVAL;
+ 
+ 			if (nexthdr->off != cls->knode.sel->keys[0].off ||
+ 			    nexthdr->val != cls->knode.sel->keys[0].val ||
+ 			    nexthdr->mask != cls->knode.sel->keys[0].mask)
+ 				return -EINVAL;
+ 
+ 			if (uhtid >= IXGBE_MAX_LINK_HANDLE)
+ 				return -EINVAL;
+ 
+ 			adapter->jump_tables[uhtid] = nexthdr->jump;
+ 		}
+ 		return 0;
+ 	}
+ 
+ 	if (loc >= ((1024 << adapter->fdir_pballoc) - 2)) {
+ 		e_err(drv, "Location out of range\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* cls u32 is a graph starting at root node 0x800. The driver tracks
+ 	 * links and also the fields used to advance the parser across each
+ 	 * link (e.g. nexthdr/eat parameters from 'tc'). This way we can map
+ 	 * the u32 graph onto the hardware parse graph denoted in ixgbe_model.h
+ 	 * To add support for new nodes update ixgbe_model.h parse structures
+ 	 * this function _should_ be generic try not to hardcode values here.
+ 	 */
+ 	if (TC_U32_USERHTID(handle) == 0x800) {
+ 		field_ptr = adapter->jump_tables[0];
+ 	} else {
+ 		if (TC_U32_USERHTID(handle) >= ARRAY_SIZE(adapter->jump_tables))
+ 			return -EINVAL;
+ 
+ 		field_ptr = adapter->jump_tables[TC_U32_USERHTID(handle)];
+ 	}
+ 
+ 	if (!field_ptr)
+ 		return -EINVAL;
+ 
+ 	input = kzalloc(sizeof(*input), GFP_KERNEL);
+ 	if (!input)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < cls->knode.sel->nkeys; i++) {
+ 		int off = cls->knode.sel->keys[i].off;
+ 		__be32 val = cls->knode.sel->keys[i].val;
+ 		__be32 m = cls->knode.sel->keys[i].mask;
+ 		bool found_entry = false;
+ 		int j;
+ 
+ 		for (j = 0; field_ptr[j].val; j++) {
+ 			if (field_ptr[j].off == off &&
+ 			    field_ptr[j].mask == m) {
+ 				field_ptr[j].val(input, &mask, val, m);
+ 				input->filter.formatted.flow_type |=
+ 					field_ptr[j].type;
+ 				found_entry = true;
+ 				break;
+ 			}
+ 		}
+ 
+ 		if (!found_entry)
+ 			goto err_out;
+ 	}
+ 
+ 	mask.formatted.flow_type = IXGBE_ATR_L4TYPE_IPV6_MASK |
+ 				   IXGBE_ATR_L4TYPE_MASK;
+ 
+ 	if (input->filter.formatted.flow_type == IXGBE_ATR_FLOW_TYPE_IPV4)
+ 		mask.formatted.flow_type &= IXGBE_ATR_L4TYPE_IPV6_MASK;
+ 
+ #ifdef CONFIG_NET_CLS_ACT
+ 	if (list_empty(&cls->knode.exts->actions))
+ 		goto err_out;
+ 
+ 	list_for_each_entry(a, &cls->knode.exts->actions, list) {
+ 		if (!is_tcf_gact_shot(a))
+ 			goto err_out;
+ 	}
+ #endif
+ 
+ 	input->action = IXGBE_FDIR_DROP_QUEUE;
+ 	queue = IXGBE_FDIR_DROP_QUEUE;
+ 	input->sw_idx = loc;
+ 
+ 	spin_lock(&adapter->fdir_perfect_lock);
+ 
+ 	if (hlist_empty(&adapter->fdir_filter_list)) {
+ 		memcpy(&adapter->fdir_mask, &mask, sizeof(mask));
+ 		err = ixgbe_fdir_set_input_mask_82599(hw, &mask);
+ 		if (err)
+ 			goto err_out_w_lock;
+ 	} else if (memcmp(&adapter->fdir_mask, &mask, sizeof(mask))) {
+ 		err = -EINVAL;
+ 		goto err_out_w_lock;
+ 	}
+ 
+ 	ixgbe_atr_compute_perfect_hash_82599(&input->filter, &mask);
+ 	err = ixgbe_fdir_write_perfect_filter_82599(hw, &input->filter,
+ 						    input->sw_idx, queue);
+ 	if (!err)
+ 		ixgbe_update_ethtool_fdir_entry(adapter, input, input->sw_idx);
+ 	spin_unlock(&adapter->fdir_perfect_lock);
+ 
+ 	return err;
+ err_out_w_lock:
+ 	spin_unlock(&adapter->fdir_perfect_lock);
+ err_out:
+ 	kfree(input);
+ 	return -EINVAL;
+ }
+ 
+ int __ixgbe_setup_tc(struct net_device *dev, u32 handle, __be16 proto,
+ 		     struct tc_to_netdev *tc)
+ {
+ 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+ 
+ 	if (TC_H_MAJ(handle) == TC_H_MAJ(TC_H_INGRESS) &&
+ 	    tc->type == TC_SETUP_CLSU32) {
+ 		switch (tc->cls_u32->command) {
+ 		case TC_CLSU32_NEW_KNODE:
+ 		case TC_CLSU32_REPLACE_KNODE:
+ 			return ixgbe_configure_clsu32(adapter,
+ 						      proto, tc->cls_u32);
+ 		case TC_CLSU32_DELETE_KNODE:
+ 			return ixgbe_delete_clsu32(adapter, tc->cls_u32);
+ 		case TC_CLSU32_NEW_HNODE:
+ 		case TC_CLSU32_REPLACE_HNODE:
+ 			return ixgbe_configure_clsu32_add_hnode(adapter, proto,
+ 								tc->cls_u32);
+ 		case TC_CLSU32_DELETE_HNODE:
+ 			return ixgbe_configure_clsu32_del_hnode(adapter,
+ 								tc->cls_u32);
+ 		default:
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	if (tc->type != TC_SETUP_MQPRIO)
+ 		return -EINVAL;
+ 
+ 	return ixgbe_setup_tc(dev, tc->tc);
+ }
+ 
++>>>>>>> 5eb4dce3b347 (net: relax setup_tc ndo op handle restriction)
  #ifdef CONFIG_PCI_IOV
  void ixgbe_sriov_reinit(struct ixgbe_adapter *adapter)
  {
diff --cc drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index e17d408bbaa2,16b26d17c54c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@@ -69,6 -70,15 +69,18 @@@ int mlx4_en_setup_tc(struct net_device 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int __mlx4_en_setup_tc(struct net_device *dev, u32 handle, __be16 proto,
+ 			      struct tc_to_netdev *tc)
+ {
+ 	if (tc->type != TC_SETUP_MQPRIO)
+ 		return -EINVAL;
+ 
+ 	return mlx4_en_setup_tc(dev, tc->tc);
+ }
+ 
++>>>>>>> 5eb4dce3b347 (net: relax setup_tc ndo op handle restriction)
  #ifdef CONFIG_RFS_ACCEL
  
  struct mlx4_en_filter {
diff --cc drivers/net/ethernet/sfc/tx.c
index f7a0ec1bca97,233778911557..000000000000
--- a/drivers/net/ethernet/sfc/tx.c
+++ b/drivers/net/ethernet/sfc/tx.c
@@@ -567,9 -568,14 +567,17 @@@ int efx_setup_tc(struct net_device *net
  	struct efx_nic *efx = netdev_priv(net_dev);
  	struct efx_channel *channel;
  	struct efx_tx_queue *tx_queue;
 -	unsigned tc, num_tc;
 +	unsigned tc;
  	int rc;
  
++<<<<<<< HEAD
++=======
+ 	if (ntc->type != TC_SETUP_MQPRIO)
+ 		return -EINVAL;
+ 
+ 	num_tc = ntc->tc;
+ 
++>>>>>>> 5eb4dce3b347 (net: relax setup_tc ndo op handle restriction)
  	if (efx_nic_rev(efx) < EFX_REV_FALCON_B0 || num_tc > EFX_MAX_TX_TC)
  		return -EINVAL;
  
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-drv.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
* Unmerged path drivers/net/ethernet/ti/netcp_core.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-drv.c
* Unmerged path drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
* Unmerged path drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_netdev.c
* Unmerged path drivers/net/ethernet/sfc/tx.c
* Unmerged path drivers/net/ethernet/ti/netcp_core.c
