IB/hfi1: Extract RSM map table init from QOS

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dean Luick <dean.luick@intel.com>
commit 372cc85a13c97d6c743cb8df25b52fa5e93d73f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/372cc85a.failed

Refactor the allocation, tracking, and writing of the RSM map table
into its own set of routines.  This will allow the map table to be
passed to multiple users to fill in as needed.  Start with the original
user, QOS.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Dean Luick <dean.luick@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 372cc85a13c97d6c743cb8df25b52fa5e93d73f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/chip.c
diff --cc drivers/staging/hfi1/chip.c
index 689fb76865d1,234c0784b97b..000000000000
--- a/drivers/staging/hfi1/chip.c
+++ b/drivers/staging/hfi1/chip.c
@@@ -13535,22 -13469,18 +13579,30 @@@ static void complete_rsm_map_table(stru
  /**
   * init_qos - init RX qos
   * @dd - device data
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 + * @first_context
++=======
+  * @rmt - RSM map table
++>>>>>>> 372cc85a13c9 (IB/hfi1: Extract RSM map table init from QOS):drivers/staging/rdma/hfi1/chip.c
   *
 - * This routine initializes Rule 0 and the RSM map table to implement
 - * quality of service (qos).
 + * This routine initializes Rule 0 and the
 + * RSM map table to implement qos.
   *
 - * If all of the limit tests succeed, qos is applied based on the array
 - * interpretation of krcvqs where entry 0 is VL0.
 + * If all of the limit tests succeed,
 + * qos is applied based on the array
 + * interpretation of krcvqs where
 + * entry 0 is VL0.
 + *
 + * The number of vl bits (n) and the number of qpn
 + * bits (m) are computed to feed both the RSM map table
 + * and the single rule.
   *
 - * The number of vl bits (n) and the number of qpn bits (m) are computed to
 - * feed both the RSM map table and the single rule.
   */
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +static void init_qos(struct hfi1_devdata *dd, u32 first_ctxt)
++=======
+ static void init_qos(struct hfi1_devdata *dd, struct rsm_map_table *rmt)
++>>>>>>> 372cc85a13c9 (IB/hfi1: Extract RSM map table init from QOS):drivers/staging/rdma/hfi1/chip.c
  {
  	u8 max_by_vl = 0;
  	unsigned qpns_per_vl, ctxt, i, qpn, n = 1, m;
@@@ -13575,12 -13505,12 +13627,18 @@@
  	m = ilog2(qpns_per_vl);
  	if ((m + n) > 7)
  		goto bail;
- 	rsmmap = kmalloc_array(NUM_MAP_REGS, sizeof(u64), GFP_KERNEL);
- 	if (!rsmmap)
+ 	/* enough room in the map table? */
+ 	rmt_entries = 1 << (m + n);
+ 	if (rmt->used + rmt_entries >= NUM_MAP_ENTRIES)
  		goto bail;
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +	memset(rsmmap, rxcontext, NUM_MAP_REGS * sizeof(u64));
 +	/* init the local copy of the table */
 +	for (i = 0, ctxt = first_ctxt; i < num_vls; i++) {
++=======
+ 	/* add qos entries to the the RSM map table */
+ 	for (i = 0, ctxt = FIRST_KERNEL_KCTXT; i < num_vls; i++) {
++>>>>>>> 372cc85a13c9 (IB/hfi1: Extract RSM map table init from QOS):drivers/staging/rdma/hfi1/chip.c
  		unsigned tctxt;
  
  		for (qpn = 0, tctxt = ctxt;
@@@ -13602,32 -13532,28 +13660,47 @@@
  		}
  		ctxt += krcvqs[i];
  	}
- 	/* flush cached copies to chip */
- 	for (i = 0; i < NUM_MAP_REGS; i++)
- 		write_csr(dd, RCV_RSM_MAP_TABLE + (8 * i), rsmmap[i]);
  	/* add rule0 */
  	write_csr(dd, RCV_RSM_CFG /* + (8 * 0) */,
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +		RCV_RSM_CFG_ENABLE_OR_CHAIN_RSM0_MASK
 +			<< RCV_RSM_CFG_ENABLE_OR_CHAIN_RSM0_SHIFT |
 +		2ull << RCV_RSM_CFG_PACKET_TYPE_SHIFT);
++=======
+ 		  (u64)rmt->used << RCV_RSM_CFG_OFFSET_SHIFT |
+ 		  RCV_RSM_CFG_ENABLE_OR_CHAIN_RSM0_MASK <<
+ 			RCV_RSM_CFG_ENABLE_OR_CHAIN_RSM0_SHIFT |
+ 		  2ull << RCV_RSM_CFG_PACKET_TYPE_SHIFT);
++>>>>>>> 372cc85a13c9 (IB/hfi1: Extract RSM map table init from QOS):drivers/staging/rdma/hfi1/chip.c
  	write_csr(dd, RCV_RSM_SELECT /* + (8 * 0) */,
 -		  LRH_BTH_MATCH_OFFSET << RCV_RSM_SELECT_FIELD1_OFFSET_SHIFT |
 -		  LRH_SC_MATCH_OFFSET << RCV_RSM_SELECT_FIELD2_OFFSET_SHIFT |
 -		  LRH_SC_SELECT_OFFSET << RCV_RSM_SELECT_INDEX1_OFFSET_SHIFT |
 -		  ((u64)n) << RCV_RSM_SELECT_INDEX1_WIDTH_SHIFT |
 -		  QPN_SELECT_OFFSET << RCV_RSM_SELECT_INDEX2_OFFSET_SHIFT |
 -		  ((u64)m + (u64)n) << RCV_RSM_SELECT_INDEX2_WIDTH_SHIFT);
 +		LRH_BTH_MATCH_OFFSET
 +			<< RCV_RSM_SELECT_FIELD1_OFFSET_SHIFT |
 +		LRH_SC_MATCH_OFFSET << RCV_RSM_SELECT_FIELD2_OFFSET_SHIFT |
 +		LRH_SC_SELECT_OFFSET << RCV_RSM_SELECT_INDEX1_OFFSET_SHIFT |
 +		((u64)n) << RCV_RSM_SELECT_INDEX1_WIDTH_SHIFT |
 +		QPN_SELECT_OFFSET << RCV_RSM_SELECT_INDEX2_OFFSET_SHIFT |
 +		((u64)m + (u64)n) << RCV_RSM_SELECT_INDEX2_WIDTH_SHIFT);
  	write_csr(dd, RCV_RSM_MATCH /* + (8 * 0) */,
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +		LRH_BTH_MASK << RCV_RSM_MATCH_MASK1_SHIFT |
 +		LRH_BTH_VALUE << RCV_RSM_MATCH_VALUE1_SHIFT |
 +		LRH_SC_MASK << RCV_RSM_MATCH_MASK2_SHIFT |
 +		LRH_SC_VALUE << RCV_RSM_MATCH_VALUE2_SHIFT);
 +	/* Enable RSM */
 +	add_rcvctrl(dd, RCV_CTRL_RCV_RSM_ENABLE_SMASK);
 +	kfree(rsmmap);
 +	/* map everything else to first context */
 +	init_qpmap_table(dd, FIRST_KERNEL_KCTXT, MIN_KERNEL_KCTXTS - 1);
++=======
+ 		  LRH_BTH_MASK << RCV_RSM_MATCH_MASK1_SHIFT |
+ 		  LRH_BTH_VALUE << RCV_RSM_MATCH_VALUE1_SHIFT |
+ 		  LRH_SC_MASK << RCV_RSM_MATCH_MASK2_SHIFT |
+ 		  LRH_SC_VALUE << RCV_RSM_MATCH_VALUE2_SHIFT);
+ 	/* mark RSM map entries as used */
+ 	rmt->used += rmt_entries;
+ 	/* map everything else to the mcast/err/vl15 context */
+ 	init_qpmap_table(dd, HFI1_CTRL_CTXT, HFI1_CTRL_CTXT);
++>>>>>>> 372cc85a13c9 (IB/hfi1: Extract RSM map table init from QOS):drivers/staging/rdma/hfi1/chip.c
  	dd->qos_shift = n + 1;
  	return;
  bail:
@@@ -13637,12 -13563,17 +13710,24 @@@
  
  static void init_rxe(struct hfi1_devdata *dd)
  {
+ 	struct rsm_map_table *rmt;
+ 
  	/* enable all receive errors */
  	write_csr(dd, RCV_ERR_MASK, ~0ull);
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +	/* setup QPN map table - start where VL15 context leaves off */
 +	init_qos(
 +		dd,
 +		dd->n_krcv_queues > MIN_KERNEL_KCTXTS ? MIN_KERNEL_KCTXTS : 0);
++=======
+ 
+ 	rmt = alloc_rsm_map_table(dd);
+ 	/* set up QOS, including the QPN map table */
+ 	init_qos(dd, rmt);
+ 	complete_rsm_map_table(dd, rmt);
+ 	kfree(rmt);
+ 
++>>>>>>> 372cc85a13c9 (IB/hfi1: Extract RSM map table init from QOS):drivers/staging/rdma/hfi1/chip.c
  	/*
  	 * make sure RcvCtrl.RcvWcb <= PCIe Device Control
  	 * Register Max_Payload_Size (PCI_EXP_DEVCTL in Linux PCIe config
* Unmerged path drivers/staging/hfi1/chip.c
diff --git a/drivers/staging/hfi1/chip_registers.h b/drivers/staging/hfi1/chip_registers.h
index 3cd3352af2ce..0cb26e058922 100644
--- a/drivers/staging/hfi1/chip_registers.h
+++ b/drivers/staging/hfi1/chip_registers.h
@@ -774,6 +774,7 @@
 #define RCV_RSM_CFG_ENABLE_OR_CHAIN_RSM0_MASK 0x1ull
 #define RCV_RSM_CFG_ENABLE_OR_CHAIN_RSM0_SHIFT 0
 #define RCV_RSM_CFG_PACKET_TYPE_SHIFT 60
+#define RCV_RSM_CFG_OFFSET_SHIFT 32
 #define RCV_RSM_MAP_TABLE (RXE + 0x000000000900)
 #define RCV_RSM_MAP_TABLE_RCV_CONTEXT_A_MASK 0xFFull
 #define RCV_RSM_MATCH (RXE + 0x000000000800)
