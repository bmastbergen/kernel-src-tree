drivers:hv: Export a function that maps Linux CPU num onto Hyper-V proc num

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hv] Export a function that maps Linux CPU num onto Hyper-V proc num (Vitaly Kuznetsov) [1321073]
Rebuild_FUZZ: 91.30%
commit-author Jake Oshins <jakeo@microsoft.com>
commit 619848bd074343ff2bdeeafca0be39748f6da372
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/619848bd.failed

This patch exposes the mapping between Linux CPU number and Hyper-V virtual
processor number.  This is necessary because the hypervisor needs to know which
virtual processors to target when making a mapping in the Interrupt Redirection
Table in the I/O MMU.

	Signed-off-by: Jake Oshins <jakeo@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 619848bd074343ff2bdeeafca0be39748f6da372)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/vmbus_drv.c
#	include/linux/hyperv.h
diff --cc drivers/hv/vmbus_drv.c
index 305d2da27594,c01b689e39b1..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -1047,6 -1099,117 +1047,120 @@@ static acpi_status vmbus_walk_resources
  	return AE_OK;
  }
  
++<<<<<<< HEAD
++=======
+ static int vmbus_acpi_remove(struct acpi_device *device)
+ {
+ 	struct resource *cur_res;
+ 	struct resource *next_res;
+ 
+ 	if (hyperv_mmio) {
+ 		for (cur_res = hyperv_mmio; cur_res; cur_res = next_res) {
+ 			next_res = cur_res->sibling;
+ 			kfree(cur_res);
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * vmbus_allocate_mmio() - Pick a memory-mapped I/O range.
+  * @new:		If successful, supplied a pointer to the
+  *			allocated MMIO space.
+  * @device_obj:		Identifies the caller
+  * @min:		Minimum guest physical address of the
+  *			allocation
+  * @max:		Maximum guest physical address
+  * @size:		Size of the range to be allocated
+  * @align:		Alignment of the range to be allocated
+  * @fb_overlap_ok:	Whether this allocation can be allowed
+  *			to overlap the video frame buffer.
+  *
+  * This function walks the resources granted to VMBus by the
+  * _CRS object in the ACPI namespace underneath the parent
+  * "bridge" whether that's a root PCI bus in the Generation 1
+  * case or a Module Device in the Generation 2 case.  It then
+  * attempts to allocate from the global MMIO pool in a way that
+  * matches the constraints supplied in these parameters and by
+  * that _CRS.
+  *
+  * Return: 0 on success, -errno on failure
+  */
+ int vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,
+ 			resource_size_t min, resource_size_t max,
+ 			resource_size_t size, resource_size_t align,
+ 			bool fb_overlap_ok)
+ {
+ 	struct resource *iter;
+ 	resource_size_t range_min, range_max, start, local_min, local_max;
+ 	const char *dev_n = dev_name(&device_obj->device);
+ 	u32 fb_end = screen_info.lfb_base + (screen_info.lfb_size << 1);
+ 	int i;
+ 
+ 	for (iter = hyperv_mmio; iter; iter = iter->sibling) {
+ 		if ((iter->start >= max) || (iter->end <= min))
+ 			continue;
+ 
+ 		range_min = iter->start;
+ 		range_max = iter->end;
+ 
+ 		/* If this range overlaps the frame buffer, split it into
+ 		   two tries. */
+ 		for (i = 0; i < 2; i++) {
+ 			local_min = range_min;
+ 			local_max = range_max;
+ 			if (fb_overlap_ok || (range_min >= fb_end) ||
+ 			    (range_max <= screen_info.lfb_base)) {
+ 				i++;
+ 			} else {
+ 				if ((range_min <= screen_info.lfb_base) &&
+ 				    (range_max >= screen_info.lfb_base)) {
+ 					/*
+ 					 * The frame buffer is in this window,
+ 					 * so trim this into the part that
+ 					 * preceeds the frame buffer.
+ 					 */
+ 					local_max = screen_info.lfb_base - 1;
+ 					range_min = fb_end;
+ 				} else {
+ 					range_min = fb_end;
+ 					continue;
+ 				}
+ 			}
+ 
+ 			start = (local_min + align - 1) & ~(align - 1);
+ 			for (; start + size - 1 <= local_max; start += align) {
+ 				*new = request_mem_region_exclusive(start, size,
+ 								    dev_n);
+ 				if (*new)
+ 					return 0;
+ 			}
+ 		}
+ 	}
+ 
+ 	return -ENXIO;
+ }
+ EXPORT_SYMBOL_GPL(vmbus_allocate_mmio);
+ 
+ /**
+  * vmbus_cpu_number_to_vp_number() - Map CPU to VP.
+  * @cpu_number: CPU number in Linux terms
+  *
+  * This function returns the mapping between the Linux processor
+  * number and the hypervisor's virtual processor number, useful
+  * in making hypercalls and such that talk about specific
+  * processors.
+  *
+  * Return: Virtual processor number in Hyper-V terms
+  */
+ int vmbus_cpu_number_to_vp_number(int cpu_number)
+ {
+ 	return hv_context.vp_index[cpu_number];
+ }
+ EXPORT_SYMBOL_GPL(vmbus_cpu_number_to_vp_number);
+ 
++>>>>>>> 619848bd0743 (drivers:hv: Export a function that maps Linux CPU num onto Hyper-V proc num)
  static int vmbus_acpi_add(struct acpi_device *device)
  {
  	acpi_status result;
diff --cc include/linux/hyperv.h
index 941b7d440f67,fddb3e0e8feb..000000000000
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@@ -962,6 -978,13 +962,16 @@@ int __must_check __vmbus_driver_registe
  					 const char *mod_name);
  void vmbus_driver_unregister(struct hv_driver *hv_driver);
  
++<<<<<<< HEAD
++=======
+ int vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,
+ 			resource_size_t min, resource_size_t max,
+ 			resource_size_t size, resource_size_t align,
+ 			bool fb_overlap_ok);
+ 
+ int vmbus_cpu_number_to_vp_number(int cpu_number);
+ 
++>>>>>>> 619848bd0743 (drivers:hv: Export a function that maps Linux CPU num onto Hyper-V proc num)
  /**
   * VMBUS_DEVICE - macro used to describe a specific hyperv vmbus device
   *
* Unmerged path drivers/hv/vmbus_drv.c
* Unmerged path include/linux/hyperv.h
