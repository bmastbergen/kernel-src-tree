cancel the setfilesize transation when io error happen

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Zhaohongjiang <zhaohongjiang@huawei.com>
commit 5cb13dcd0fac071b45c4bebe1801a08ff0d89cad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5cb13dcd.failed

When I ran xfstest/073 case, the remount process was blocked to wait
transactions to be zero. I found there was a io error happened, and
the setfilesize transaction was not released properly. We should add
the changes to cancel the io error in this case.

Reproduction steps:
1. dd if=/dev/zero of=xfs1.img bs=1M count=2048
2. mkfs.xfs xfs1.img
3. losetup -f ./xfs1.img /dev/loop0
4. mount -t xfs /dev/loop0 /home/test_dir/
5. mkdir /home/test_dir/test
6. mkfs.xfs -dfile,name=image,size=2g
7. mount -t xfs -o loop image /home/test_dir/test
8. cp a file bigger than 2g to /home/test_dir/test
9. mount -t xfs -o remount,ro /home/test_dir/test

[ dchinner: moved io error detection to xfs_setfilesize_ioend() after
  transaction context restoration. ]

	Signed-off-by: Zhao Hongjiang <zhaohongjiang@huawei.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>
(cherry picked from commit 5cb13dcd0fac071b45c4bebe1801a08ff0d89cad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_aops.c
diff --cc fs/xfs/xfs_aops.c
index bb6024910e57,e485e31813fa..000000000000
--- a/fs/xfs/xfs_aops.c
+++ b/fs/xfs/xfs_aops.c
@@@ -172,7 -154,31 +172,35 @@@ xfs_setfilesize
  	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
  	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
  
++<<<<<<< HEAD
 +	return xfs_trans_commit(tp, 0);
++=======
+ 	return xfs_trans_commit(tp);
+ }
+ 
+ STATIC int
+ xfs_setfilesize_ioend(
+ 	struct xfs_ioend	*ioend)
+ {
+ 	struct xfs_inode	*ip = XFS_I(ioend->io_inode);
+ 	struct xfs_trans	*tp = ioend->io_append_trans;
+ 
+ 	/*
+ 	 * The transaction may have been allocated in the I/O submission thread,
+ 	 * thus we need to mark ourselves as being in a transaction manually.
+ 	 * Similarly for freeze protection.
+ 	 */
+ 	current_set_flags_nested(&tp->t_pflags, PF_FSTRANS);
+ 	__sb_writers_acquired(VFS_I(ip)->i_sb, SB_FREEZE_FS);
+ 
+ 	/* we abort the update if there was an IO error */
+ 	if (ioend->io_error) {
+ 		xfs_trans_cancel(tp);
+ 		return ioend->io_error;
+ 	}
+ 
+ 	return xfs_setfilesize(ip, tp, ioend->io_offset, ioend->io_size);
++>>>>>>> 5cb13dcd0fac (cancel the setfilesize transation when io error happen)
  }
  
  /*
@@@ -219,26 -222,17 +245,31 @@@ xfs_end_io
  	/*
  	 * For unwritten extents we need to issue transactions to convert a
  	 * range to normal written extens after the data I/O has finished.
+ 	 * Detecting and handling completion IO errors is done individually
+ 	 * for each case as different cleanup operations need to be performed
+ 	 * on error.
  	 */
  	if (ioend->io_type == XFS_IO_UNWRITTEN) {
+ 		if (ioend->io_error)
+ 			goto done;
  		error = xfs_iomap_write_unwritten(ip, ioend->io_offset,
  						  ioend->io_size);
 +	} else if (ioend->io_isdirect && xfs_ioend_is_append(ioend)) {
 +		/*
 +		 * For direct I/O we do not know if we need to allocate blocks
 +		 * or not so we can't preallocate an append transaction as that
 +		 * results in nested reservations and log space deadlocks. Hence
 +		 * allocate the transaction here. While this is sub-optimal and
 +		 * can block IO completion for some time, we're stuck with doing
 +		 * it this way until we can pass the ioend to the direct IO
 +		 * allocation callbacks and avoid nesting that way.
 +		 */
 +		error = xfs_setfilesize_trans_alloc(ioend);
 +		if (error)
 +			goto done;
 +		error = xfs_setfilesize(ioend);
  	} else if (ioend->io_append_trans) {
 -		error = xfs_setfilesize_ioend(ioend);
 +		error = xfs_setfilesize(ioend);
  	} else {
  		ASSERT(!xfs_ioend_is_append(ioend));
  	}
* Unmerged path fs/xfs/xfs_aops.c
