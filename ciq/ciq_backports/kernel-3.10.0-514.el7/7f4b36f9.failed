get rid of files_defer_init()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 7f4b36f9bb930b3b2105a9a2cb0121fa7028c432
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7f4b36f9.failed

the only thing it's doing these days is calculation of
upper limit for fs.nr_open sysctl and that can be done
statically

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 7f4b36f9bb930b3b2105a9a2cb0121fa7028c432)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/file_table.c
#	include/linux/fdtable.h
diff --cc fs/file_table.c
index 52ef2a338a0e,718e8e5224f8..000000000000
--- a/fs/file_table.c
+++ b/fs/file_table.c
@@@ -360,6 -325,5 +360,10 @@@ void __init files_init(unsigned long me
  
  	n = (mempages * (PAGE_SIZE / 1024)) / 10;
  	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
++<<<<<<< HEAD
 +	files_defer_init();
 +	percpu_counter_init(&nr_files, 0, GFP_KERNEL);
++=======
+ 	percpu_counter_init(&nr_files, 0);
++>>>>>>> 7f4b36f9bb93 (get rid of files_defer_init())
  } 
diff --cc include/linux/fdtable.h
index 085197bd8812,230f87bdf5ad..000000000000
--- a/include/linux/fdtable.h
+++ b/include/linux/fdtable.h
@@@ -72,16 -63,30 +72,29 @@@ struct file_operations
  struct vfsmount;
  struct dentry;
  
++<<<<<<< HEAD
 +extern void __init files_defer_init(void);
 +
 +static inline struct file * fcheck_files(struct files_struct *files, unsigned int fd)
++=======
+ #define rcu_dereference_check_fdtable(files, fdtfd) \
+ 	rcu_dereference_check((fdtfd), lockdep_is_held(&(files)->file_lock))
+ 
+ #define files_fdtable(files) \
+ 	rcu_dereference_check_fdtable((files), (files)->fdt)
+ 
+ /*
+  * The caller must ensure that fd table isn't shared or hold rcu or file lock
+  */
+ static inline struct file *__fcheck_files(struct files_struct *files, unsigned int fd)
++>>>>>>> 7f4b36f9bb93 (get rid of files_defer_init())
  {
 -	struct fdtable *fdt = rcu_dereference_raw(files->fdt);
 +	struct file * file = NULL;
 +	struct fdtable *fdt = files_fdtable(files);
  
  	if (fd < fdt->max_fds)
 -		return rcu_dereference_raw(fdt->fd[fd]);
 -	return NULL;
 -}
 -
 -static inline struct file *fcheck_files(struct files_struct *files, unsigned int fd)
 -{
 -	rcu_lockdep_assert(rcu_read_lock_held() ||
 -			   lockdep_is_held(&files->file_lock),
 -			   "suspicious rcu_dereference_check() usage");
 -	return __fcheck_files(files, fd);
 +		file = rcu_dereference_check_fdtable(files, fdt->fd[fd]);
 +	return file;
  }
  
  /*
diff --git a/fs/file.c b/fs/file.c
index 4a78f981557a..f6c1a14c646d 100644
--- a/fs/file.c
+++ b/fs/file.c
@@ -25,7 +25,10 @@
 
 int sysctl_nr_open __read_mostly = 1024*1024;
 int sysctl_nr_open_min = BITS_PER_LONG;
-int sysctl_nr_open_max = 1024 * 1024; /* raised later */
+/* our max() is unusable in constant expressions ;-/ */
+#define __const_max(x, y) ((x) < (y) ? (x) : (y))
+int sysctl_nr_open_max = __const_max(INT_MAX, ~(size_t)0/sizeof(void *)) &
+			 -BITS_PER_LONG;
 
 static void *alloc_fdmem(size_t size)
 {
@@ -437,12 +440,6 @@ void exit_files(struct task_struct *tsk)
 	}
 }
 
-void __init files_defer_init(void)
-{
-	sysctl_nr_open_max = min((size_t)INT_MAX, ~(size_t)0/sizeof(void *)) &
-			     -BITS_PER_LONG;
-}
-
 struct files_struct init_files = {
 	.count		= ATOMIC_INIT(1),
 	.fdt		= &init_files.fdtab,
* Unmerged path fs/file_table.c
* Unmerged path include/linux/fdtable.h
