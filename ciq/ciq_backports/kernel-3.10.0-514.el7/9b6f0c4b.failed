usbcore: rename struct dev_state to struct usb_dev_state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Valentina Manea <valentina.manea.m@gmail.com>
commit 9b6f0c4b98171f2a354e1e461fefa90ec2baafa6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9b6f0c4b.failed

Since it is needed outside usbcore and exposed in include/linux/usb.h,
it conflicts with enum dev_state in rt2x00 wireless driver.

Mark it as usb specific to avoid conflicts in the future.

	Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 9b6f0c4b98171f2a354e1e461fefa90ec2baafa6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/usbip/stub_dev.c
#	drivers/usb/core/devio.c
#	drivers/usb/core/hub.h
#	include/linux/usb.h
diff --cc drivers/staging/usbip/stub_dev.c
index 83d629afdfe1,773d8ca07a00..000000000000
--- a/drivers/staging/usbip/stub_dev.c
+++ b/drivers/staging/usbip/stub_dev.c
@@@ -412,23 -378,33 +412,39 @@@ static int stub_probe(struct usb_interf
  	if (!sdev)
  		return -ENOMEM;
  
 -	dev_info(&udev->dev,
 -		"usbip-host: register new device (bus %u dev %u)\n",
 -		udev->bus->busnum, udev->devnum);
 +	dev_info(&interface->dev, "usbip-host: register new device "
 +		 "(bus %u dev %u ifn %u)\n", udev->bus->busnum, udev->devnum,
 +		 interface->cur_altsetting->desc.bInterfaceNumber);
  
 +	busid_priv->interf_count = 0;
  	busid_priv->shutdown_busid = 0;
  
 -	/* set private data to usb_device */
 -	dev_set_drvdata(&udev->dev, sdev);
 +	/* set private data to usb_interface */
 +	usb_set_intfdata(interface, sdev);
 +	busid_priv->interf_count++;
  	busid_priv->sdev = sdev;
 -	busid_priv->udev = udev;
  
++<<<<<<< HEAD
 +	err = stub_add_files(&interface->dev);
++=======
+ 	/*
+ 	 * Claim this hub port.
+ 	 * It doesn't matter what value we pass as owner
+ 	 * (struct dev_state) as long as it is unique.
+ 	 */
+ 	rc = usb_hub_claim_port(udev->parent, udev->portnum,
+ 			(struct usb_dev_state *) udev);
+ 	if (rc) {
+ 		dev_dbg(&udev->dev, "unable to claim port\n");
+ 		return rc;
+ 	}
+ 
+ 	err = stub_add_files(&udev->dev);
++>>>>>>> 9b6f0c4b9817 (usbcore: rename struct dev_state to struct usb_dev_state)
  	if (err) {
 -		dev_err(&udev->dev, "stub_add_files for %s\n", udev_busid);
 -		dev_set_drvdata(&udev->dev, NULL);
 +		dev_err(&interface->dev, "stub_add_files for %s\n", udev_busid);
 +		usb_set_intfdata(interface, NULL);
 +		usb_put_intf(interface);
  		usb_put_dev(udev);
  		kthread_stop_put(sdev->ud.eh);
  
@@@ -484,11 -460,13 +500,19 @@@ static void stub_disconnect(struct usb_
  	/*
  	 * NOTE: rx/tx threads are invoked for each usb_device.
  	 */
 -	stub_remove_files(&udev->dev);
 +	stub_remove_files(&interface->dev);
  
++<<<<<<< HEAD
 +	/* If usb reset is called from event handler */
 +	if (busid_priv->sdev->ud.eh == current) {
 +		busid_priv->interf_count--;
++=======
+ 	/* release port */
+ 	rc = usb_hub_release_port(udev->parent, udev->portnum,
+ 				  (struct usb_dev_state *) udev);
+ 	if (rc) {
+ 		dev_dbg(&udev->dev, "unable to release port\n");
++>>>>>>> 9b6f0c4b9817 (usbcore: rename struct dev_state to struct usb_dev_state)
  		return;
  	}
  
diff --cc drivers/usb/core/devio.c
index f0fa800f4c65,2a8afe6754b8..000000000000
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@@ -1126,21 -1043,7 +1126,25 @@@ static int proc_bulk(struct usb_dev_sta
  	return ret;
  }
  
++<<<<<<< HEAD
 +static void check_reset_of_active_ep(struct usb_device *udev,
 +		unsigned int epnum, char *ioctl_name)
 +{
 +	struct usb_host_endpoint **eps;
 +	struct usb_host_endpoint *ep;
 +
 +	eps = (epnum & USB_DIR_IN) ? udev->ep_in : udev->ep_out;
 +	ep = eps[epnum & 0x0f];
 +	if (ep && !list_empty(&ep->urb_list))
 +		dev_warn(&udev->dev, "Process %d (%s) called USBDEVFS_%s for active endpoint 0x%02x\n",
 +				task_pid_nr(current), current->comm,
 +				ioctl_name, epnum);
 +}
 +
 +static int proc_resetep(struct dev_state *ps, void __user *arg)
++=======
+ static int proc_resetep(struct usb_dev_state *ps, void __user *arg)
++>>>>>>> 9b6f0c4b9817 (usbcore: rename struct dev_state to struct usb_dev_state)
  {
  	unsigned int ep;
  	int ret;
@@@ -1713,10 -1613,10 +1717,10 @@@ static int proc_reapurb(struct usb_dev_
  	}
  	if (signal_pending(current))
  		return -EINTR;
 -	return -EIO;
 +	return -ENODEV;
  }
  
- static int proc_reapurbnonblock(struct dev_state *ps, void __user *arg)
+ static int proc_reapurbnonblock(struct usb_dev_state *ps, void __user *arg)
  {
  	int retval;
  	struct async *as;
@@@ -1856,10 -1755,10 +1860,10 @@@ static int proc_reapurb_compat(struct u
  	}
  	if (signal_pending(current))
  		return -EINTR;
 -	return -EIO;
 +	return -ENODEV;
  }
  
- static int proc_reapurbnonblock_compat(struct dev_state *ps, void __user *arg)
+ static int proc_reapurbnonblock_compat(struct usb_dev_state *ps, void __user *arg)
  {
  	int retval;
  	struct async *as;
diff --cc drivers/usb/core/hub.h
index 7a565f16e260,33bcb2c6f90a..000000000000
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@@ -96,14 -89,11 +96,18 @@@ struct usb_hub 
  struct usb_port {
  	struct usb_device *child;
  	struct device dev;
++<<<<<<< HEAD
 +	struct dev_state *port_owner;
 +	struct usb_port *peer;
 +	struct dev_pm_qos_request *req;
++=======
+ 	struct usb_dev_state *port_owner;
++>>>>>>> 9b6f0c4b9817 (usbcore: rename struct dev_state to struct usb_dev_state)
  	enum usb_port_connect_type connect_type;
 +	usb_port_location_t location;
 +	struct mutex status_lock;
  	u8 portnum;
 -	unsigned power_is_on:1;
 -	unsigned did_runtime_put:1;
 +	unsigned int is_superspeed:1;
  };
  
  #define to_usb_port(_dev) \
diff --cc include/linux/usb.h
index ad6cebf08123,b55600a1edc3..000000000000
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@@ -393,6 -366,8 +393,11 @@@ struct usb_bus 
  #endif
  };
  
++<<<<<<< HEAD
++=======
+ struct usb_dev_state;
+ 
++>>>>>>> 9b6f0c4b9817 (usbcore: rename struct dev_state to struct usb_dev_state)
  /* ----------------------------------------------------------------------- */
  
  struct usb_tt;
@@@ -776,6 -751,11 +781,14 @@@ extern struct usb_host_interface *usb_f
  		unsigned int iface_num,
  		unsigned int alt_num);
  
++<<<<<<< HEAD
++=======
+ /* port claiming functions */
+ int usb_hub_claim_port(struct usb_device *hdev, unsigned port1,
+ 		struct usb_dev_state *owner);
+ int usb_hub_release_port(struct usb_device *hdev, unsigned port1,
+ 		struct usb_dev_state *owner);
++>>>>>>> 9b6f0c4b9817 (usbcore: rename struct dev_state to struct usb_dev_state)
  
  /**
   * usb_make_path - returns stable device path in the usb tree
* Unmerged path drivers/staging/usbip/stub_dev.c
* Unmerged path drivers/usb/core/devio.c
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 820ddf2f8ff4..091b9655ad43 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1863,7 +1863,7 @@ hub_ioctl(struct usb_interface *intf, unsigned int code, void *user_data)
  * to one of these "claimed" ports, the program will "own" the device.
  */
 static int find_port_owner(struct usb_device *hdev, unsigned port1,
-		struct dev_state ***ppowner)
+		struct usb_dev_state ***ppowner)
 {
 	struct usb_hub *hub = usb_hub_to_struct_hub(hdev);
 
@@ -1881,10 +1881,10 @@ static int find_port_owner(struct usb_device *hdev, unsigned port1,
 
 /* In the following three functions, the caller must hold hdev's lock */
 int usb_hub_claim_port(struct usb_device *hdev, unsigned port1,
-		       struct dev_state *owner)
+		       struct usb_dev_state *owner)
 {
 	int rc;
-	struct dev_state **powner;
+	struct usb_dev_state **powner;
 
 	rc = find_port_owner(hdev, port1, &powner);
 	if (rc)
@@ -1896,10 +1896,10 @@ int usb_hub_claim_port(struct usb_device *hdev, unsigned port1,
 }
 
 int usb_hub_release_port(struct usb_device *hdev, unsigned port1,
-			 struct dev_state *owner)
+			 struct usb_dev_state *owner)
 {
 	int rc;
-	struct dev_state **powner;
+	struct usb_dev_state **powner;
 
 	rc = find_port_owner(hdev, port1, &powner);
 	if (rc)
@@ -1910,7 +1910,7 @@ int usb_hub_release_port(struct usb_device *hdev, unsigned port1,
 	return rc;
 }
 
-void usb_hub_release_all_ports(struct usb_device *hdev, struct dev_state *owner)
+void usb_hub_release_all_ports(struct usb_device *hdev, struct usb_dev_state *owner)
 {
 	struct usb_hub *hub = usb_hub_to_struct_hub(hdev);
 	int n;
* Unmerged path drivers/usb/core/hub.h
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 76158b8467ed..cdc6922ab97f 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -2,7 +2,7 @@
 #include <linux/acpi.h>
 
 struct usb_hub_descriptor;
-struct dev_state;
+struct usb_dev_state;
 
 /* Functions local to drivers/usb/core/ */
 
@@ -62,7 +62,7 @@ extern int usb_hub_claim_port(struct usb_device *hdev, unsigned port,
 extern int usb_hub_release_port(struct usb_device *hdev, unsigned port,
 		struct dev_state *owner);
 extern void usb_hub_release_all_ports(struct usb_device *hdev,
-		struct dev_state *owner);
+		struct usb_dev_state *owner);
 extern bool usb_device_is_owned(struct usb_device *udev);
 
 extern int  usb_hub_init(void);
* Unmerged path include/linux/usb.h
