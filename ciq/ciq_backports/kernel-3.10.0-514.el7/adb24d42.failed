mmc: mmc: Fix incorrect use of driver strength switching HS200 and HS400

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] mmc: Fix incorrect use of driver strength switching HS200 and HS400 (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 96.40%
commit-author Wenkai Du <wenkai.du@intel.com>
commit adb24d42a516bca8b9741ed21206509daaab5b13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/adb24d42.failed

Commit cc4f414c885c ("mmc: mmc: Add driver strength selection")
added driver strength selection for eMMC HS200 and HS400 modes.
That patch also set the driver stength when transitioning through
High Speed mode to HS200/HS400, but driver strength is not defined
for High Speed mode.  While the JEDEC specification is not clear
on this point it has been observed to cause problems for some eMMC,
and removing the driver strength setting in this case makes it
consistent with the normal use of High Speed mode.

	Signed-off-by: Wenkai Du <wenkai.du@intel.com>
	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Cc: stable@vger.kernel.org # v4.2+
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit adb24d42a516bca8b9741ed21206509daaab5b13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/mmc.c
diff --cc drivers/mmc/core/mmc.c
index de6bcae94d53,549c56e8cf6b..000000000000
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@@ -900,23 -927,372 +900,333 @@@ static int mmc_select_hs200(struct mmc_
  		if (err)
  			continue;
  
 -		bus_width = bus_widths[idx];
 -		mmc_set_bus_width(host, bus_width);
 +		mmc_set_bus_width(card->host, bus_widths[idx]);
  
 -		/*
 -		 * If controller can't handle bus width test,
 -		 * compare ext_csd previously read in 1 bit mode
 -		 * against ext_csd at new bus width
 -		 */
  		if (!(host->caps & MMC_CAP_BUS_WIDTH_TEST))
 -			err = mmc_compare_ext_csds(card, bus_width);
 +			err = mmc_compare_ext_csds(card, bus_widths[idx]);
  		else
 -			err = mmc_bus_test(card, bus_width);
 -
 -		if (!err) {
 -			err = bus_width;
 +			err = mmc_bus_test(card, bus_widths[idx]);
 +		if (!err)
  			break;
 -		} else {
 -			pr_warn("%s: switch to bus width %d failed\n",
 -				mmc_hostname(host), ext_csd_bits[idx]);
 -		}
  	}
  
 -	return err;
 -}
 -
 -/*
 - * Switch to the high-speed mode
 - */
 -static int mmc_select_hs(struct mmc_card *card)
 -{
 -	int err;
 -
 -	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 -			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS,
 -			   card->ext_csd.generic_cmd6_time,
 -			   true, true, true);
 +	/* switch to HS200 mode if bus width set successfully */
  	if (!err)
++<<<<<<< HEAD
++=======
+ 		mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
+ 
+ 	return err;
+ }
+ 
+ /*
+  * Activate wide bus and DDR if supported.
+  */
+ static int mmc_select_hs_ddr(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	u32 bus_width, ext_csd_bits;
+ 	int err = 0;
+ 
+ 	if (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_52))
+ 		return 0;
+ 
+ 	bus_width = host->ios.bus_width;
+ 	if (bus_width == MMC_BUS_WIDTH_1)
+ 		return 0;
+ 
+ 	ext_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?
+ 		EXT_CSD_DDR_BUS_WIDTH_8 : EXT_CSD_DDR_BUS_WIDTH_4;
+ 
+ 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			EXT_CSD_BUS_WIDTH,
+ 			ext_csd_bits,
+ 			card->ext_csd.generic_cmd6_time);
+ 	if (err) {
+ 		pr_err("%s: switch to bus width %d ddr failed\n",
+ 			mmc_hostname(host), 1 << bus_width);
+ 		return err;
+ 	}
+ 
+ 	/*
+ 	 * eMMC cards can support 3.3V to 1.2V i/o (vccq)
+ 	 * signaling.
+ 	 *
+ 	 * EXT_CSD_CARD_TYPE_DDR_1_8V means 3.3V or 1.8V vccq.
+ 	 *
+ 	 * 1.8V vccq at 3.3V core voltage (vcc) is not required
+ 	 * in the JEDEC spec for DDR.
+ 	 *
+ 	 * Even (e)MMC card can support 3.3v to 1.2v vccq, but not all
+ 	 * host controller can support this, like some of the SDHCI
+ 	 * controller which connect to an eMMC device. Some of these
+ 	 * host controller still needs to use 1.8v vccq for supporting
+ 	 * DDR mode.
+ 	 *
+ 	 * So the sequence will be:
+ 	 * if (host and device can both support 1.2v IO)
+ 	 *	use 1.2v IO;
+ 	 * else if (host and device can both support 1.8v IO)
+ 	 *	use 1.8v IO;
+ 	 * so if host and device can only support 3.3v IO, this is the
+ 	 * last choice.
+ 	 *
+ 	 * WARNING: eMMC rules are NOT the same as SD DDR
+ 	 */
+ 	err = -EINVAL;
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_1_2V)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);
+ 
+ 	if (err && (card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_1_8V))
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
+ 
+ 	/* make sure vccq is 3.3v after switching disaster */
+ 	if (err)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330);
+ 
+ 	if (!err)
+ 		mmc_set_timing(host, MMC_TIMING_MMC_DDR52);
+ 
+ 	return err;
+ }
+ 
+ /* Caller must hold re-tuning */
+ static int mmc_switch_status(struct mmc_card *card)
+ {
+ 	u32 status;
+ 	int err;
+ 
+ 	err = mmc_send_status(card, &status);
+ 	if (err)
+ 		return err;
+ 
+ 	return mmc_switch_status_error(card->host, status);
+ }
+ 
+ static int mmc_select_hs400(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	bool send_status = true;
+ 	unsigned int max_dtr;
+ 	int err = 0;
+ 	u8 val;
+ 
+ 	/*
+ 	 * HS400 mode requires 8-bit bus width
+ 	 */
+ 	if (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400 &&
+ 	      host->ios.bus_width == MMC_BUS_WIDTH_8))
+ 		return 0;
+ 
+ 	if (host->caps & MMC_CAP_WAIT_WHILE_BUSY)
+ 		send_status = false;
+ 
+ 	/* Reduce frequency to HS frequency */
+ 	max_dtr = card->ext_csd.hs_max_dtr;
+ 	mmc_set_clock(host, max_dtr);
+ 
+ 	/* Switch card to HS mode */
+ 	val = EXT_CSD_TIMING_HS;
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			   EXT_CSD_HS_TIMING, val,
+ 			   card->ext_csd.generic_cmd6_time,
+ 			   true, send_status, true);
+ 	if (err) {
+ 		pr_err("%s: switch to high-speed from hs200 failed, err:%d\n",
+ 			mmc_hostname(host), err);
+ 		return err;
+ 	}
+ 
+ 	/* Set host controller to HS timing */
+ 	mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
+ 
+ 	if (!send_status) {
+ 		err = mmc_switch_status(card);
+ 		if (err)
+ 			goto out_err;
+ 	}
+ 
+ 	/* Switch card to DDR */
+ 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			 EXT_CSD_BUS_WIDTH,
+ 			 EXT_CSD_DDR_BUS_WIDTH_8,
+ 			 card->ext_csd.generic_cmd6_time);
+ 	if (err) {
+ 		pr_err("%s: switch to bus width for hs400 failed, err:%d\n",
+ 			mmc_hostname(host), err);
+ 		return err;
+ 	}
+ 
+ 	/* Switch card to HS400 */
+ 	val = EXT_CSD_TIMING_HS400 |
+ 	      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			   EXT_CSD_HS_TIMING, val,
+ 			   card->ext_csd.generic_cmd6_time,
+ 			   true, send_status, true);
+ 	if (err) {
+ 		pr_err("%s: switch to hs400 failed, err:%d\n",
+ 			 mmc_hostname(host), err);
+ 		return err;
+ 	}
+ 
+ 	/* Set host controller to HS400 timing and frequency */
+ 	mmc_set_timing(host, MMC_TIMING_MMC_HS400);
+ 	mmc_set_bus_speed(card);
+ 
+ 	if (!send_status) {
+ 		err = mmc_switch_status(card);
+ 		if (err)
+ 			goto out_err;
+ 	}
+ 
+ 	return 0;
+ 
+ out_err:
+ 	pr_err("%s: %s failed, error %d\n", mmc_hostname(card->host),
+ 	       __func__, err);
+ 	return err;
+ }
+ 
+ int mmc_hs200_to_hs400(struct mmc_card *card)
+ {
+ 	return mmc_select_hs400(card);
+ }
+ 
+ int mmc_hs400_to_hs200(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	bool send_status = true;
+ 	unsigned int max_dtr;
+ 	int err;
+ 	u8 val;
+ 
+ 	if (host->caps & MMC_CAP_WAIT_WHILE_BUSY)
+ 		send_status = false;
+ 
+ 	/* Reduce frequency to HS */
+ 	max_dtr = card->ext_csd.hs_max_dtr;
+ 	mmc_set_clock(host, max_dtr);
+ 
+ 	/* Switch HS400 to HS DDR */
+ 	val = EXT_CSD_TIMING_HS;
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING,
+ 			   val, card->ext_csd.generic_cmd6_time,
+ 			   true, send_status, true);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	mmc_set_timing(host, MMC_TIMING_MMC_DDR52);
+ 
+ 	if (!send_status) {
+ 		err = mmc_switch_status(card);
+ 		if (err)
+ 			goto out_err;
+ 	}
+ 
+ 	/* Switch HS DDR to HS */
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_BUS_WIDTH,
+ 			   EXT_CSD_BUS_WIDTH_8, card->ext_csd.generic_cmd6_time,
+ 			   true, send_status, true);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	mmc_set_timing(host, MMC_TIMING_MMC_HS);
+ 
+ 	if (!send_status) {
+ 		err = mmc_switch_status(card);
+ 		if (err)
+ 			goto out_err;
+ 	}
+ 
+ 	/* Switch HS to HS200 */
+ 	val = EXT_CSD_TIMING_HS200 |
+ 	      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING,
+ 			   val, card->ext_csd.generic_cmd6_time, true,
+ 			   send_status, true);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	mmc_set_timing(host, MMC_TIMING_MMC_HS200);
+ 
+ 	if (!send_status) {
+ 		err = mmc_switch_status(card);
+ 		if (err)
+ 			goto out_err;
+ 	}
+ 
+ 	mmc_set_bus_speed(card);
+ 
+ 	return 0;
+ 
+ out_err:
+ 	pr_err("%s: %s failed, error %d\n", mmc_hostname(card->host),
+ 	       __func__, err);
+ 	return err;
+ }
+ 
+ static void mmc_select_driver_type(struct mmc_card *card)
+ {
+ 	int card_drv_type, drive_strength, drv_type;
+ 
+ 	card_drv_type = card->ext_csd.raw_driver_strength |
+ 			mmc_driver_type_mask(0);
+ 
+ 	drive_strength = mmc_select_drive_strength(card,
+ 						   card->ext_csd.hs200_max_dtr,
+ 						   card_drv_type, &drv_type);
+ 
+ 	card->drive_strength = drive_strength;
+ 
+ 	if (drv_type)
+ 		mmc_set_driver_type(card->host, drv_type);
+ }
+ 
+ /*
+  * For device supporting HS200 mode, the following sequence
+  * should be done before executing the tuning process.
+  * 1. set the desired bus width(4-bit or 8-bit, 1-bit is not supported)
+  * 2. switch to HS200 mode
+  * 3. set the clock to > 52Mhz and <=200MHz
+  */
+ static int mmc_select_hs200(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	bool send_status = true;
+ 	unsigned int old_timing;
+ 	int err = -EINVAL;
+ 	u8 val;
+ 
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_2V)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);
+ 
+ 	if (err && card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_8V)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
+ 
+ 	/* If fails try again during next card power cycle */
+ 	if (err)
+ 		goto err;
+ 
+ 	mmc_select_driver_type(card);
+ 
+ 	if (host->caps & MMC_CAP_WAIT_WHILE_BUSY)
+ 		send_status = false;
+ 
+ 	/*
+ 	 * Set the bus width(4 or 8) with host's support and
+ 	 * switch to HS200 mode if bus width is set successfully.
+ 	 */
+ 	err = mmc_select_bus_width(card);
+ 	if (!IS_ERR_VALUE(err)) {
+ 		val = EXT_CSD_TIMING_HS200 |
+ 		      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;
++>>>>>>> adb24d42a516 (mmc: mmc: Fix incorrect use of driver strength switching HS200 and HS400)
  		err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 -				   EXT_CSD_HS_TIMING, val,
 -				   card->ext_csd.generic_cmd6_time,
 -				   true, send_status, true);
 -		if (err)
 -			goto err;
 -		old_timing = host->ios.timing;
 -		mmc_set_timing(host, MMC_TIMING_MMC_HS200);
 -		if (!send_status) {
 -			err = mmc_switch_status(card);
 -			/*
 -			 * mmc_select_timing() assumes timing has not changed if
 -			 * it is a switch error.
 -			 */
 -			if (err == -EBADMSG)
 -				mmc_set_timing(host, old_timing);
 -		}
 -	}
 +				EXT_CSD_HS_TIMING, 2,
 +				card->ext_csd.generic_cmd6_time,
 +				true, true, true);
  err:
 -	if (err)
 -		pr_err("%s: %s failed, error %d\n", mmc_hostname(card->host),
 -		       __func__, err);
  	return err;
  }
  
* Unmerged path drivers/mmc/core/mmc.c
