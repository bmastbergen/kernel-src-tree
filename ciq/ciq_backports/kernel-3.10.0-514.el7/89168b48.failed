mmc: core: restore detect line inversion semantics

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Linus Walleij <linus.walleij@linaro.org>
commit 89168b48991537bec2573b3b6a8841df74465b12
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/89168b48.failed

commit 98e90de99a0c43bd434da814c882c4332441871e
"mmc: host: switch OF parser to use gpio descriptors"
switched the semantic behaviour of card detect and read
only flags such that the inversion capability flag would
only be set if inversion was explicitly specified in the
device tree, in the hopes that no-one was using double
inversion.

It turns out that the XOR:ing between the explicit
inversion was indeed in use, so we need to restore the
old semantics where both ways of inversion are checked
and the end result XOR:ed.

	Reported-by: Javier Martinez Canillas <javier@dowhile0.org>
	Tested-by: Javier Martinez Canillas <javier@dowhile0.org>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 89168b48991537bec2573b3b6a8841df74465b12)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/host.c
#	drivers/mmc/core/slot-gpio.c
#	drivers/mmc/host/mmci.c
#	include/linux/mmc/slot-gpio.h
diff --cc drivers/mmc/core/host.c
index 5e896e1f24c1,03c53b72a2d6..000000000000
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@@ -310,9 -310,8 +310,14 @@@ int mmc_of_parse(struct mmc_host *host
  {
  	struct device_node *np;
  	u32 bus_width;
++<<<<<<< HEAD
 +	bool explicit_inv_wp, gpio_inv_wp = false;
 +	enum of_gpio_flags flags;
 +	int len, ret, gpio;
++=======
+ 	int len, ret;
+ 	bool cap_invert, gpio_invert;
++>>>>>>> 89168b489915 (mmc: core: restore detect line inversion semantics)
  
  	if (!host->parent || !host->parent->of_node)
  		return 0;
@@@ -360,61 -359,64 +365,112 @@@
  	if (of_find_property(np, "non-removable", &len)) {
  		host->caps |= MMC_CAP_NONREMOVABLE;
  	} else {
++<<<<<<< HEAD
 +		bool explicit_inv_cd, gpio_inv_cd = false;
 +
 +		explicit_inv_cd = of_property_read_bool(np, "cd-inverted");
++=======
+ 		if (of_property_read_bool(np, "cd-inverted"))
+ 			cap_invert = true;
+ 		else
+ 			cap_invert = false;
++>>>>>>> 89168b489915 (mmc: core: restore detect line inversion semantics)
  
  		if (of_find_property(np, "broken-cd", &len))
  			host->caps |= MMC_CAP_NEEDS_POLL;
  
++<<<<<<< HEAD
 +		gpio = of_get_named_gpio_flags(np, "cd-gpios", 0, &flags);
 +		if (gpio == -EPROBE_DEFER)
 +			return gpio;
 +		if (gpio_is_valid(gpio)) {
 +			if (!(flags & OF_GPIO_ACTIVE_LOW))
 +				gpio_inv_cd = true;
 +
 +			ret = mmc_gpio_request_cd(host, gpio);
 +			if (ret < 0) {
++=======
+ 		ret = mmc_gpiod_request_cd(host, "cd", 0, true,
+ 					   0, &gpio_invert);
+ 		if (ret) {
+ 			if (ret == -EPROBE_DEFER)
+ 				return ret;
+ 			if (ret != -ENOENT) {
++>>>>>>> 89168b489915 (mmc: core: restore detect line inversion semantics)
  				dev_err(host->parent,
 -					"Failed to request CD GPIO: %d\n",
 -					ret);
 +					"Failed to request CD GPIO #%d: %d!\n",
 +					gpio, ret);
 +				return ret;
 +			} else {
 +				dev_info(host->parent, "Got CD GPIO #%d.\n",
 +					 gpio);
  			}
++<<<<<<< HEAD
 +		}
 +
 +		if (explicit_inv_cd ^ gpio_inv_cd)
++=======
+ 		} else
+ 			dev_info(host->parent, "Got CD GPIO\n");
+ 
+ 		/*
+ 		 * There are two ways to flag that the CD line is inverted:
+ 		 * through the cd-inverted flag and by the GPIO line itself
+ 		 * being inverted from the GPIO subsystem. This is a leftover
+ 		 * from the times when the GPIO subsystem did not make it
+ 		 * possible to flag a line as inverted.
+ 		 *
+ 		 * If the capability on the host AND the GPIO line are
+ 		 * both inverted, the end result is that the CD line is
+ 		 * not inverted.
+ 		 */
+ 		if (cap_invert ^ gpio_invert)
++>>>>>>> 89168b489915 (mmc: core: restore detect line inversion semantics)
  			host->caps2 |= MMC_CAP2_CD_ACTIVE_HIGH;
  	}
  
  	/* Parse Write Protection */
++<<<<<<< HEAD
 +	explicit_inv_wp = of_property_read_bool(np, "wp-inverted");
 +
 +	gpio = of_get_named_gpio_flags(np, "wp-gpios", 0, &flags);
 +	if (gpio == -EPROBE_DEFER) {
 +		ret = -EPROBE_DEFER;
 +		goto out;
 +	}
 +	if (gpio_is_valid(gpio)) {
 +		if (!(flags & OF_GPIO_ACTIVE_LOW))
 +			gpio_inv_wp = true;
 +
 +		ret = mmc_gpio_request_ro(host, gpio);
 +		if (ret < 0) {
++=======
+ 	if (of_property_read_bool(np, "wp-inverted"))
+ 		cap_invert = true;
+ 	else
+ 		cap_invert = false;
+ 
+ 	ret = mmc_gpiod_request_ro(host, "wp", 0, false, 0, &gpio_invert);
+ 	if (ret) {
+ 		if (ret == -EPROBE_DEFER)
+ 			goto out;
+ 		if (ret != -ENOENT) {
++>>>>>>> 89168b489915 (mmc: core: restore detect line inversion semantics)
  			dev_err(host->parent,
 -				"Failed to request WP GPIO: %d\n",
 -				ret);
 +				"Failed to request WP GPIO: %d!\n", ret);
 +			goto out;
 +		} else {
 +				dev_info(host->parent, "Got WP GPIO #%d.\n",
 +					 gpio);
  		}
 -	} else
 -		dev_info(host->parent, "Got WP GPIO\n");
 +	}
 +	if (explicit_inv_wp ^ gpio_inv_wp)
 +		host->caps2 |= MMC_CAP2_RO_ACTIVE_HIGH;
  
+ 	/* See the comment on CD inversion above */
+ 	if (cap_invert ^ gpio_invert)
+ 		host->caps2 |= MMC_CAP2_RO_ACTIVE_HIGH;
+ 
  	if (of_find_property(np, "cap-sd-highspeed", &len))
  		host->caps |= MMC_CAP_SD_HIGHSPEED;
  	if (of_find_property(np, "cap-mmc-highspeed", &len))
diff --cc drivers/mmc/core/slot-gpio.c
index f33bbd48c2c0,69bbf2adb329..000000000000
--- a/drivers/mmc/core/slot-gpio.c
+++ b/drivers/mmc/core/slot-gpio.c
@@@ -250,3 -273,135 +250,138 @@@ void mmc_gpio_free_cd(struct mmc_host *
  	devm_gpio_free(&host->class_dev, gpio);
  }
  EXPORT_SYMBOL(mmc_gpio_free_cd);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * mmc_gpiod_request_cd - request a gpio descriptor for card-detection
+  * @host: mmc host
+  * @con_id: function within the GPIO consumer
+  * @idx: index of the GPIO to obtain in the consumer
+  * @override_active_level: ignore %GPIO_ACTIVE_LOW flag
+  * @debounce: debounce time in microseconds
+  * @gpio_invert: will return whether the GPIO line is inverted or not, set
+  * to NULL to ignore
+  *
+  * Use this function in place of mmc_gpio_request_cd() to use the GPIO
+  * descriptor API.  Note that it is paired with mmc_gpiod_free_cd() not
+  * mmc_gpio_free_cd().  Note also that it must be called prior to mmc_add_host()
+  * otherwise the caller must also call mmc_gpiod_request_cd_irq().
+  *
+  * Returns zero on success, else an error.
+  */
+ int mmc_gpiod_request_cd(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce, bool *gpio_invert)
+ {
+ 	struct mmc_gpio *ctx;
+ 	struct gpio_desc *desc;
+ 	int ret;
+ 
+ 	ret = mmc_gpio_alloc(host);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ctx = host->slot.handler_priv;
+ 
+ 	if (!con_id)
+ 		con_id = ctx->cd_label;
+ 
+ 	desc = devm_gpiod_get_index(host->parent, con_id, idx, GPIOD_IN);
+ 	if (IS_ERR(desc))
+ 		return PTR_ERR(desc);
+ 
+ 	if (debounce) {
+ 		ret = gpiod_set_debounce(desc, debounce);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	if (gpio_invert)
+ 		*gpio_invert = !gpiod_is_active_low(desc);
+ 
+ 	ctx->override_cd_active_level = override_active_level;
+ 	ctx->cd_gpio = desc;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(mmc_gpiod_request_cd);
+ 
+ /**
+  * mmc_gpiod_request_ro - request a gpio descriptor for write protection
+  * @host: mmc host
+  * @con_id: function within the GPIO consumer
+  * @idx: index of the GPIO to obtain in the consumer
+  * @override_active_level: ignore %GPIO_ACTIVE_LOW flag
+  * @debounce: debounce time in microseconds
+  * @gpio_invert: will return whether the GPIO line is inverted or not,
+  * set to NULL to ignore
+  *
+  * Use this function in place of mmc_gpio_request_ro() to use the GPIO
+  * descriptor API.  Note that it is paired with mmc_gpiod_free_ro() not
+  * mmc_gpio_free_ro().
+  *
+  * Returns zero on success, else an error.
+  */
+ int mmc_gpiod_request_ro(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce, bool *gpio_invert)
+ {
+ 	struct mmc_gpio *ctx;
+ 	struct gpio_desc *desc;
+ 	int ret;
+ 
+ 	ret = mmc_gpio_alloc(host);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ctx = host->slot.handler_priv;
+ 
+ 	if (!con_id)
+ 		con_id = ctx->ro_label;
+ 
+ 	desc = devm_gpiod_get_index(host->parent, con_id, idx, GPIOD_IN);
+ 	if (IS_ERR(desc))
+ 		return PTR_ERR(desc);
+ 
+ 	if (debounce) {
+ 		ret = gpiod_set_debounce(desc, debounce);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	if (gpio_invert)
+ 		*gpio_invert = !gpiod_is_active_low(desc);
+ 
+ 	ctx->override_ro_active_level = override_active_level;
+ 	ctx->ro_gpio = desc;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(mmc_gpiod_request_ro);
+ 
+ /**
+  * mmc_gpiod_free_cd - free the card-detection gpio descriptor
+  * @host: mmc host
+  *
+  * It's provided only for cases that client drivers need to manually free
+  * up the card-detection gpio requested by mmc_gpiod_request_cd().
+  */
+ void mmc_gpiod_free_cd(struct mmc_host *host)
+ {
+ 	struct mmc_gpio *ctx = host->slot.handler_priv;
+ 
+ 	if (!ctx || !ctx->cd_gpio)
+ 		return;
+ 
+ 	if (host->slot.cd_irq >= 0) {
+ 		devm_free_irq(&host->class_dev, host->slot.cd_irq, host);
+ 		host->slot.cd_irq = -EINVAL;
+ 	}
+ 
+ 	devm_gpiod_put(host->parent, ctx->cd_gpio);
+ 
+ 	ctx->cd_gpio = NULL;
+ }
+ EXPORT_SYMBOL(mmc_gpiod_free_cd);
++>>>>>>> 89168b489915 (mmc: core: restore detect line inversion semantics)
diff --cc drivers/mmc/host/mmci.c
index f4f3038c1df0,43af791e2e45..000000000000
--- a/drivers/mmc/host/mmci.c
+++ b/drivers/mmc/host/mmci.c
@@@ -1485,54 -1674,41 +1485,86 @@@ static int mmci_probe(struct amba_devic
  	writel(0, host->base + MMCIMASK1);
  	writel(0xfff, host->base + MMCICLEAR);
  
++<<<<<<< HEAD
 +	if (plat->gpio_cd == -EPROBE_DEFER) {
 +		ret = -EPROBE_DEFER;
 +		goto err_gpio_cd;
 +	}
 +	if (gpio_is_valid(plat->gpio_cd)) {
 +		ret = gpio_request(plat->gpio_cd, DRIVER_NAME " (cd)");
 +		if (ret == 0)
 +			ret = gpio_direction_input(plat->gpio_cd);
 +		if (ret == 0)
 +			host->gpio_cd = plat->gpio_cd;
 +		else if (ret != -ENOSYS)
 +			goto err_gpio_cd;
 +
 +		/*
 +		 * A gpio pin that will detect cards when inserted and removed
 +		 * will most likely want to trigger on the edges if it is
 +		 * 0 when ejected and 1 when inserted (or mutatis mutandis
 +		 * for the inverted case) so we request triggers on both
 +		 * edges.
 +		 */
 +		ret = request_any_context_irq(gpio_to_irq(plat->gpio_cd),
 +				mmci_cd_irq,
 +				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
 +				DRIVER_NAME " (cd)", host);
 +		if (ret >= 0)
 +			host->gpio_cd_irq = gpio_to_irq(plat->gpio_cd);
 +	}
 +	if (plat->gpio_wp == -EPROBE_DEFER) {
 +		ret = -EPROBE_DEFER;
 +		goto err_gpio_wp;
 +	}
 +	if (gpio_is_valid(plat->gpio_wp)) {
 +		ret = gpio_request(plat->gpio_wp, DRIVER_NAME " (wp)");
 +		if (ret == 0)
 +			ret = gpio_direction_input(plat->gpio_wp);
 +		if (ret == 0)
 +			host->gpio_wp = plat->gpio_wp;
 +		else if (ret != -ENOSYS)
 +			goto err_gpio_wp;
++=======
+ 	/*
+ 	 * If:
+ 	 * - not using DT but using a descriptor table, or
+ 	 * - using a table of descriptors ALONGSIDE DT, or
+ 	 * look up these descriptors named "cd" and "wp" right here, fail
+ 	 * silently of these do not exist and proceed to try platform data
+ 	 */
+ 	if (!np) {
+ 		ret = mmc_gpiod_request_cd(mmc, "cd", 0, false, 0, NULL);
+ 		if (ret < 0) {
+ 			if (ret == -EPROBE_DEFER)
+ 				goto clk_disable;
+ 			else if (gpio_is_valid(plat->gpio_cd)) {
+ 				ret = mmc_gpio_request_cd(mmc, plat->gpio_cd, 0);
+ 				if (ret)
+ 					goto clk_disable;
+ 			}
+ 		}
+ 
+ 		ret = mmc_gpiod_request_ro(mmc, "wp", 0, false, 0, NULL);
+ 		if (ret < 0) {
+ 			if (ret == -EPROBE_DEFER)
+ 				goto clk_disable;
+ 			else if (gpio_is_valid(plat->gpio_wp)) {
+ 				ret = mmc_gpio_request_ro(mmc, plat->gpio_wp);
+ 				if (ret)
+ 					goto clk_disable;
+ 			}
+ 		}
++>>>>>>> 89168b489915 (mmc: core: restore detect line inversion semantics)
  	}
  
 -	ret = devm_request_irq(&dev->dev, dev->irq[0], mmci_irq, IRQF_SHARED,
 -			DRIVER_NAME " (cmd)", host);
 +	if ((host->plat->status || host->gpio_cd != -ENOSYS)
 +	    && host->gpio_cd_irq < 0)
 +		mmc->caps |= MMC_CAP_NEEDS_POLL;
 +
 +	ret = request_irq(dev->irq[0], mmci_irq, IRQF_SHARED, DRIVER_NAME " (cmd)", host);
  	if (ret)
 -		goto clk_disable;
 +		goto unmap;
  
  	if (!dev->irq[1])
  		host->singleirq = true;
diff --cc include/linux/mmc/slot-gpio.h
index 7d88d27bfafa,e56fa24c9322..000000000000
--- a/include/linux/mmc/slot-gpio.h
+++ b/include/linux/mmc/slot-gpio.h
@@@ -18,7 -18,17 +18,19 @@@ int mmc_gpio_request_ro(struct mmc_hos
  void mmc_gpio_free_ro(struct mmc_host *host);
  
  int mmc_gpio_get_cd(struct mmc_host *host);
 -int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio,
 -			unsigned int debounce);
 +int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio);
  void mmc_gpio_free_cd(struct mmc_host *host);
  
++<<<<<<< HEAD
++=======
+ int mmc_gpiod_request_cd(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce, bool *gpio_invert);
+ int mmc_gpiod_request_ro(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce, bool *gpio_invert);
+ void mmc_gpiod_free_cd(struct mmc_host *host);
+ void mmc_gpiod_request_cd_irq(struct mmc_host *host);
+ 
++>>>>>>> 89168b489915 (mmc: core: restore detect line inversion semantics)
  #endif
* Unmerged path drivers/mmc/core/host.c
* Unmerged path drivers/mmc/core/slot-gpio.c
* Unmerged path drivers/mmc/host/mmci.c
diff --git a/drivers/mmc/host/sdhci-acpi.c b/drivers/mmc/host/sdhci-acpi.c
index c20a51799e59..11fb7017b58a 100644
--- a/drivers/mmc/host/sdhci-acpi.c
+++ b/drivers/mmc/host/sdhci-acpi.c
@@ -343,7 +343,7 @@ static int sdhci_acpi_probe(struct platform_device *pdev)
 	if (sdhci_acpi_flag(c, SDHCI_ACPI_SD_CD)) {
 		bool v = sdhci_acpi_flag(c, SDHCI_ACPI_SD_CD_OVERRIDE_LEVEL);
 
-		if (mmc_gpiod_request_cd(host->mmc, NULL, 0, v, 0)) {
+		if (mmc_gpiod_request_cd(host->mmc, NULL, 0, v, 0, NULL)) {
 			dev_warn(dev, "failed to setup card detect gpio\n");
 			c->use_runtime_pm = false;
 		}
* Unmerged path include/linux/mmc/slot-gpio.h
