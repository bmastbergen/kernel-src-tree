ipv6: allow routes to be configured with expire values

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] ipv6: allow routes to be configured with expire (Xin Long) [1275587]
Rebuild_FUZZ: 93.07%
commit-author Xin Long <lucien.xin@gmail.com>
commit 32bc201e1974976b7d3fea9a9b17bb7392ca6394
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/32bc201e.failed

Add the support for adding expire value to routes,  requested by
Tom Gundersen <teg@jklm.no> for systemd-networkd, and NetworkManager
wants it too.

implement it by adding the new RTNETLINK attribute RTA_EXPIRES.

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 32bc201e1974976b7d3fea9a9b17bb7392ca6394)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/rtnetlink.h
#	net/ipv6/route.c
diff --cc include/uapi/linux/rtnetlink.h
index a94764ea9e9c,ca764b5da86d..000000000000
--- a/include/uapi/linux/rtnetlink.h
+++ b/include/uapi/linux/rtnetlink.h
@@@ -304,6 -306,12 +304,15 @@@ enum rtattr_type_t 
  	RTA_TABLE,
  	RTA_MARK,
  	RTA_MFC_STATS,
++<<<<<<< HEAD
++=======
+ 	RTA_VIA,
+ 	RTA_NEWDST,
+ 	RTA_PREF,
+ 	RTA_ENCAP_TYPE,
+ 	RTA_ENCAP,
+ 	RTA_EXPIRES,
++>>>>>>> 32bc201e1974 (ipv6: allow routes to be configured with expire values)
  	__RTA_MAX
  };
  
diff --cc net/ipv6/route.c
index 46deeb1736da,3c8834bc822d..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -2393,6 -2706,10 +2393,13 @@@ static const struct nla_policy rtm_ipv6
  	[RTA_PRIORITY]          = { .type = NLA_U32 },
  	[RTA_METRICS]           = { .type = NLA_NESTED },
  	[RTA_MULTIPATH]		= { .len = sizeof(struct rtnexthop) },
++<<<<<<< HEAD
++=======
+ 	[RTA_PREF]              = { .type = NLA_U8 },
+ 	[RTA_ENCAP_TYPE]	= { .type = NLA_U16 },
+ 	[RTA_ENCAP]		= { .type = NLA_NESTED },
+ 	[RTA_EXPIRES]		= { .type = NLA_U32 },
++>>>>>>> 32bc201e1974 (ipv6: allow routes to be configured with expire values)
  };
  
  static int rtm_to_fib6_config(struct sk_buff *skb, struct nlmsghdr *nlh,
@@@ -2475,6 -2796,29 +2482,32 @@@
  		cfg->fc_mp_len = nla_len(tb[RTA_MULTIPATH]);
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (tb[RTA_PREF]) {
+ 		pref = nla_get_u8(tb[RTA_PREF]);
+ 		if (pref != ICMPV6_ROUTER_PREF_LOW &&
+ 		    pref != ICMPV6_ROUTER_PREF_HIGH)
+ 			pref = ICMPV6_ROUTER_PREF_MEDIUM;
+ 		cfg->fc_flags |= RTF_PREF(pref);
+ 	}
+ 
+ 	if (tb[RTA_ENCAP])
+ 		cfg->fc_encap = tb[RTA_ENCAP];
+ 
+ 	if (tb[RTA_ENCAP_TYPE])
+ 		cfg->fc_encap_type = nla_get_u16(tb[RTA_ENCAP_TYPE]);
+ 
+ 	if (tb[RTA_EXPIRES]) {
+ 		unsigned long timeout = addrconf_timeout_fixup(nla_get_u32(tb[RTA_EXPIRES]), HZ);
+ 
+ 		if (addrconf_finite_timeout(timeout)) {
+ 			cfg->fc_expires = jiffies_to_clock_t(timeout * HZ);
+ 			cfg->fc_flags |= RTF_EXPIRES;
+ 		}
+ 	}
+ 
++>>>>>>> 32bc201e1974 (ipv6: allow routes to be configured with expire values)
  	err = 0;
  errout:
  	return err;
* Unmerged path include/uapi/linux/rtnetlink.h
* Unmerged path net/ipv6/route.c
