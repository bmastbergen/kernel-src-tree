KVM: Add an arch specific hooks in 'struct kvm_kernel_irqfd'

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Feng Wu <feng.wu@intel.com>
commit f70c20aaf141adb715a2d750c55154073b02a9c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f70c20aa.failed

This patch adds an arch specific hooks 'arch_update' in
'struct kvm_kernel_irqfd'. On Intel side, it is used to
update the IRTE when VT-d posted-interrupts is used.

	Signed-off-by: Feng Wu <feng.wu@intel.com>
	Reviewed-by: Alex Williamson <alex.williamson@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit f70c20aaf141adb715a2d750c55154073b02a9c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kvm_host.h
#	virt/kvm/eventfd.c
diff --cc include/linux/kvm_host.h
index fa2bee22c9da,5c3f4538807f..000000000000
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@@ -1097,5 -1164,15 +1097,19 @@@ static inline void kvm_vcpu_set_dy_elig
  {
  }
  #endif /* CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT */
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_HAVE_KVM_IRQ_BYPASS
+ int kvm_arch_irq_bypass_add_producer(struct irq_bypass_consumer *,
+ 			   struct irq_bypass_producer *);
+ void kvm_arch_irq_bypass_del_producer(struct irq_bypass_consumer *,
+ 			   struct irq_bypass_producer *);
+ void kvm_arch_irq_bypass_stop(struct irq_bypass_consumer *);
+ void kvm_arch_irq_bypass_start(struct irq_bypass_consumer *);
+ int kvm_arch_update_irqfd_routing(struct kvm *kvm, unsigned int host_irq,
+ 				  uint32_t guest_irq, bool set);
+ #endif /* CONFIG_HAVE_KVM_IRQ_BYPASS */
++>>>>>>> f70c20aaf141 (KVM: Add an arch specific hooks in 'struct kvm_kernel_irqfd')
  #endif
 +
diff --cc virt/kvm/eventfd.c
index cbd035d485e6,b637965746bb..000000000000
--- a/virt/kvm/eventfd.c
+++ b/virt/kvm/eventfd.c
@@@ -256,6 -256,25 +256,28 @@@ static void irqfd_update(struct kvm *kv
  	write_seqcount_end(&irqfd->irq_entry_sc);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_HAVE_KVM_IRQ_BYPASS
+ void __attribute__((weak)) kvm_arch_irq_bypass_stop(
+ 				struct irq_bypass_consumer *cons)
+ {
+ }
+ 
+ void __attribute__((weak)) kvm_arch_irq_bypass_start(
+ 				struct irq_bypass_consumer *cons)
+ {
+ }
+ 
+ int  __attribute__((weak)) kvm_arch_update_irqfd_routing(
+ 				struct kvm *kvm, unsigned int host_irq,
+ 				uint32_t guest_irq, bool set)
+ {
+ 	return 0;
+ }
+ #endif
+ 
++>>>>>>> f70c20aaf141 (KVM: Add an arch specific hooks in 'struct kvm_kernel_irqfd')
  static int
  kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args)
  {
* Unmerged path include/linux/kvm_host.h
* Unmerged path virt/kvm/eventfd.c
