IB/mlx5: Add port protocol stats

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mark Bloch <markb@mellanox.com>
commit 0ad17a8f7fa000cbfc51eedd7fddd20f7664e4b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0ad17a8f.failed

Expose new counters using the get protocol stats callback.
We expose the following counters:

|------------------------------------------------------------------------|
|      Name           | IB | EN |           Description                  |
|------------------------------------------------------------------------|
|rx_write_requests    | +  | -  | Number of received WRITE requests for  |
|                     |    |    | the associated QP.                     |
|------------------------------------------------------------------------|
|rx_read_requests     | +  | -  | Number of received READ requests for   |
|                     |    |    | the associated QP.                     |
|------------------------------------------------------------------------|
|rx_atomic_requests   | +  | -  | Number of received ATOMIC requests for |
|                     |    |    | the associated QP.                     |
|------------------------------------------------------------------------|
|out_of_buffer        | +  | +  | Number of drops occurred due to lack   |
|                     |    |    | of WQE for the associated QPs/RQs.     |
|------------------------------------------------------------------------|
|out_of_sequence      | +  | -  | Number of errors in the packet         |
|                     |    |    | transport sequence number              |
|------------------------------------------------------------------------|
|duplicate_request    | +  | +  | Number of received duplicated packets. |
|                     |    |    | A request that previously executed is  |
|                     |    |    | named duplicated.                      |
|------------------------------------------------------------------------|
|rnr_nak_retry_err    | +  | +  | Number of received RNR NAC packets.    |
|                     |    |    | The QP retry limit did not exceed.     |
|------------------------------------------------------------------------|
|packet_seq_err       | +  | +  | Number of received NAK - sequence error|
|                     |    |    | packets. The QP retry limit did not    |
|                     |    |    | exceed.                                |
|------------------------------------------------------------------------|
|implied_nak_err      | +  | +  | Number of times the requester detected |
|                     |    |    | an ACK with a PSN larger than expected |
|                     |    |    | PSN for RDMA READ or ATOMIC response   |
|                     |    |    | The QP retry limit did not exceed.     |
|------------------------------------------------------------------------|
|local_ack_timeout_err| +  | -  | Number of NO ACK responses from        |
|                     |    |    | responder within timer interval.       |
|                     |    |    | The QP retry limit did not exceed.     |
|------------------------------------------------------------------------|

Counters are available if all of them are supported.

	Signed-off-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Reviewed-by: Christoph Lameter <cl@linux.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 0ad17a8f7fa000cbfc51eedd7fddd20f7664e4b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index 71f4724287d5,11e48665d953..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -2261,6 -2541,113 +2261,116 @@@ static void mlx5_disable_roce(struct ml
  	unregister_netdevice_notifier(&dev->roce.nb);
  }
  
++<<<<<<< HEAD
++=======
+ static void mlx5_ib_dealloc_q_counters(struct mlx5_ib_dev *dev)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < dev->num_ports; i++)
+ 		mlx5_core_dealloc_q_counter(dev->mdev,
+ 					    dev->port[i].q_cnt_id);
+ }
+ 
+ static int mlx5_ib_alloc_q_counters(struct mlx5_ib_dev *dev)
+ {
+ 	int i;
+ 	int ret;
+ 
+ 	for (i = 0; i < dev->num_ports; i++) {
+ 		ret = mlx5_core_alloc_q_counter(dev->mdev,
+ 						&dev->port[i].q_cnt_id);
+ 		if (ret) {
+ 			mlx5_ib_warn(dev,
+ 				     "couldn't allocate queue counter for port %d, err %d\n",
+ 				     i + 1, ret);
+ 			goto dealloc_counters;
+ 		}
+ 	}
+ 
+ 	return 0;
+ 
+ dealloc_counters:
+ 	while (--i >= 0)
+ 		mlx5_core_dealloc_q_counter(dev->mdev,
+ 					    dev->port[i].q_cnt_id);
+ 
+ 	return ret;
+ }
+ 
+ static const char const *names[] = {
+ 	"rx_write_requests",
+ 	"rx_read_requests",
+ 	"rx_atomic_requests",
+ 	"out_of_buffer",
+ 	"out_of_sequence",
+ 	"duplicate_request",
+ 	"rnr_nak_retry_err",
+ 	"packet_seq_err",
+ 	"implied_nak_seq_err",
+ 	"local_ack_timeout_err",
+ };
+ 
+ static const size_t stats_offsets[] = {
+ 	MLX5_BYTE_OFF(query_q_counter_out, rx_write_requests),
+ 	MLX5_BYTE_OFF(query_q_counter_out, rx_read_requests),
+ 	MLX5_BYTE_OFF(query_q_counter_out, rx_atomic_requests),
+ 	MLX5_BYTE_OFF(query_q_counter_out, out_of_buffer),
+ 	MLX5_BYTE_OFF(query_q_counter_out, out_of_sequence),
+ 	MLX5_BYTE_OFF(query_q_counter_out, duplicate_request),
+ 	MLX5_BYTE_OFF(query_q_counter_out, rnr_nak_retry_err),
+ 	MLX5_BYTE_OFF(query_q_counter_out, packet_seq_err),
+ 	MLX5_BYTE_OFF(query_q_counter_out, implied_nak_seq_err),
+ 	MLX5_BYTE_OFF(query_q_counter_out, local_ack_timeout_err),
+ };
+ 
+ static struct rdma_hw_stats *mlx5_ib_alloc_hw_stats(struct ib_device *ibdev,
+ 						    u8 port_num)
+ {
+ 	BUILD_BUG_ON(ARRAY_SIZE(names) != ARRAY_SIZE(stats_offsets));
+ 
+ 	/* We support only per port stats */
+ 	if (port_num == 0)
+ 		return NULL;
+ 
+ 	return rdma_alloc_hw_stats_struct(names, ARRAY_SIZE(names),
+ 					  RDMA_HW_STATS_DEFAULT_LIFESPAN);
+ }
+ 
+ static int mlx5_ib_get_hw_stats(struct ib_device *ibdev,
+ 				struct rdma_hw_stats *stats,
+ 				u8 port, int index)
+ {
+ 	struct mlx5_ib_dev *dev = to_mdev(ibdev);
+ 	int outlen = MLX5_ST_SZ_BYTES(query_q_counter_out);
+ 	void *out;
+ 	__be32 val;
+ 	int ret;
+ 	int i;
+ 
+ 	if (!port || !stats)
+ 		return -ENOSYS;
+ 
+ 	out = mlx5_vzalloc(outlen);
+ 	if (!out)
+ 		return -ENOMEM;
+ 
+ 	ret = mlx5_core_query_q_counter(dev->mdev,
+ 					dev->port[port - 1].q_cnt_id, 0,
+ 					out, outlen);
+ 	if (ret)
+ 		goto free;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(names); i++) {
+ 		val = *(__be32 *)(out + stats_offsets[i]);
+ 		stats->value[i] = (u64)be32_to_cpu(val);
+ 	}
+ free:
+ 	kvfree(out);
+ 	return ARRAY_SIZE(names);
+ }
+ 
++>>>>>>> 0ad17a8f7fa0 (IB/mlx5: Add port protocol stats)
  static void *mlx5_ib_add(struct mlx5_core_dev *mdev)
  {
  	struct mlx5_ib_dev *dev;
@@@ -2386,6 -2776,28 +2496,23 @@@
  
  	mlx5_ib_internal_fill_odp_caps(dev);
  
++<<<<<<< HEAD
++=======
+ 	if (MLX5_CAP_GEN(mdev, imaicl)) {
+ 		dev->ib_dev.alloc_mw		= mlx5_ib_alloc_mw;
+ 		dev->ib_dev.dealloc_mw		= mlx5_ib_dealloc_mw;
+ 		dev->ib_dev.uverbs_cmd_mask |=
+ 			(1ull << IB_USER_VERBS_CMD_ALLOC_MW)	|
+ 			(1ull << IB_USER_VERBS_CMD_DEALLOC_MW);
+ 	}
+ 
+ 	if (MLX5_CAP_GEN(dev->mdev, out_of_seq_cnt) &&
+ 	    MLX5_CAP_GEN(dev->mdev, retransmission_q_counters)) {
+ 		dev->ib_dev.get_hw_stats	= mlx5_ib_get_hw_stats;
+ 		dev->ib_dev.alloc_hw_stats	= mlx5_ib_alloc_hw_stats;
+ 	}
+ 
++>>>>>>> 0ad17a8f7fa0 (IB/mlx5: Add port protocol stats)
  	if (MLX5_CAP_GEN(mdev, xrc)) {
  		dev->ib_dev.alloc_xrcd = mlx5_ib_alloc_xrcd;
  		dev->ib_dev.dealloc_xrcd = mlx5_ib_dealloc_xrcd;
* Unmerged path drivers/infiniband/hw/mlx5/main.c
