IB/iser: Don't register memory for all immediate data writes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jenny Derzhavetz <jennyf@mellanox.com>
commit b5f04b00f73d8f5d7755f5be7d05258641d99126
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b5f04b00.failed

When all the task data is sent as immediate data, we are
allowed to use the local_dma_lkey as it is not sent to
the wire.

	Signed-off-by: Jenny Derzhavetz <jennyf@mellanox.com>
	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit b5f04b00f73d8f5d7755f5be7d05258641d99126)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iscsi_iser.h
#	drivers/infiniband/ulp/iser/iser_initiator.c
#	drivers/infiniband/ulp/iser/iser_memory.c
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.h
index dfd5c4290bc2,a6356bc54d85..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@@ -635,10 -657,11 +635,18 @@@ void iser_finalize_rdma_unaligned_sg(st
  				     struct iser_data_buf *mem,
  				     enum iser_data_dir cmd_dir);
  
++<<<<<<< HEAD
 +int  iser_reg_rdma_mem_fmr(struct iscsi_iser_task *task,
 +			   enum iser_data_dir cmd_dir);
 +int  iser_reg_rdma_mem_fastreg(struct iscsi_iser_task *task,
 +			       enum iser_data_dir cmd_dir);
++=======
+ int iser_reg_rdma_mem(struct iscsi_iser_task *task,
+ 		      enum iser_data_dir dir,
+ 		      bool all_imm);
+ void iser_unreg_rdma_mem(struct iscsi_iser_task *task,
+ 			 enum iser_data_dir dir);
++>>>>>>> b5f04b00f73d (IB/iser: Don't register memory for all immediate data writes)
  
  int  iser_connect(struct iser_conn *iser_conn,
  		  struct sockaddr *src_addr,
diff --cc drivers/infiniband/ulp/iser/iser_initiator.c
index 5458fffc8b40,bc96dcb11b87..000000000000
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@@ -73,7 -72,7 +73,11 @@@ static int iser_prepare_read_cmd(struc
  			return err;
  	}
  
++<<<<<<< HEAD
 +	err = device->reg_ops->reg_rdma_mem(iser_task, ISER_DIR_IN);
++=======
+ 	err = iser_reg_rdma_mem(iser_task, ISER_DIR_IN, false);
++>>>>>>> b5f04b00f73d (IB/iser: Don't register memory for all immediate data writes)
  	if (err) {
  		iser_err("Failed to set up Data-IN RDMA\n");
  		return err;
@@@ -128,7 -126,8 +132,12 @@@ iser_prepare_write_cmd(struct iscsi_tas
  			return err;
  	}
  
++<<<<<<< HEAD
 +	err = device->reg_ops->reg_rdma_mem(iser_task, ISER_DIR_OUT);
++=======
+ 	err = iser_reg_rdma_mem(iser_task, ISER_DIR_OUT,
+ 				buf_out->data_len == imm_sz);
++>>>>>>> b5f04b00f73d (IB/iser: Don't register memory for all immediate data writes)
  	if (err != 0) {
  		iser_err("Failed to register write cmd RDMA mem\n");
  		return err;
diff --cc drivers/infiniband/ulp/iser/iser_memory.c
index 5502beb685d5,088610e66477..000000000000
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@@ -858,72 -467,83 +862,112 @@@ static int iser_fast_reg_mr(struct iscs
  
  	reg->sge.lkey = mr->lkey;
  	reg->rkey = mr->rkey;
 -	reg->sge.addr = mr->iova;
 -	reg->sge.length = mr->length;
 +	reg->sge.addr = frpl->page_list[0] + offset;
 +	reg->sge.length = size;
  
 -	iser_dbg("lkey=0x%x rkey=0x%x addr=0x%llx length=0x%x\n",
 -		 reg->sge.lkey, reg->rkey, reg->sge.addr, reg->sge.length);
 +	iser_dbg("fast reg: lkey=0x%x, rkey=0x%x, addr=0x%llx,"
 +		 " length=0x%x\n", reg->sge.lkey, reg->rkey,
 +		 reg->sge.addr, reg->sge.length);
  
 -	return 0;
 +	return ret;
  }
  
 -static int
 -iser_reg_prot_sg(struct iscsi_iser_task *task,
 -		 struct iser_data_buf *mem,
 -		 struct iser_fr_desc *desc,
 -		 bool use_dma_key,
 -		 struct iser_mem_reg *reg)
 +/**
 + * iser_reg_rdma_mem_fastreg - Registers memory intended for RDMA,
 + * using Fast Registration WR (if possible) obtaining rkey and va
 + *
 + * returns 0 on success, errno code on failure
 + */
 +int iser_reg_rdma_mem_fastreg(struct iscsi_iser_task *iser_task,
 +			      enum iser_data_dir cmd_dir)
  {
++<<<<<<< HEAD
 +	struct ib_conn *ib_conn = &iser_task->iser_conn->ib_conn;
++=======
+ 	struct iser_device *device = task->iser_conn->ib_conn.device;
+ 
+ 	if (use_dma_key)
+ 		return iser_reg_dma(device, mem, reg);
+ 
+ 	return device->reg_ops->reg_mem(task, mem, &desc->pi_ctx->rsc, reg);
+ }
+ 
+ static int
+ iser_reg_data_sg(struct iscsi_iser_task *task,
+ 		 struct iser_data_buf *mem,
+ 		 struct iser_fr_desc *desc,
+ 		 bool use_dma_key,
+ 		 struct iser_mem_reg *reg)
+ {
+ 	struct iser_device *device = task->iser_conn->ib_conn.device;
+ 
+ 	if (use_dma_key)
+ 		return iser_reg_dma(device, mem, reg);
+ 
+ 	return device->reg_ops->reg_mem(task, mem, &desc->rsc, reg);
+ }
+ 
+ int iser_reg_rdma_mem(struct iscsi_iser_task *task,
+ 		      enum iser_data_dir dir,
+ 		      bool all_imm)
+ {
+ 	struct ib_conn *ib_conn = &task->iser_conn->ib_conn;
++>>>>>>> b5f04b00f73d (IB/iser: Don't register memory for all immediate data writes)
  	struct iser_device *device = ib_conn->device;
 -	struct iser_data_buf *mem = &task->data[dir];
 -	struct iser_mem_reg *reg = &task->rdma_reg[dir];
 -	struct iser_mem_reg *data_reg;
 +	struct ib_device *ibdev = device->ib_device;
 +	struct iser_data_buf *mem = &iser_task->data[cmd_dir];
 +	struct iser_mem_reg *mem_reg = &iser_task->rdma_reg[cmd_dir];
  	struct iser_fr_desc *desc = NULL;
 -	bool use_dma_key;
 -	int err;
 -
 +	int err, aligned_len;
 +
++<<<<<<< HEAD
 +	aligned_len = iser_data_buf_aligned_len(mem, ibdev);
 +	if (aligned_len != mem->dma_nents) {
 +		err = fall_to_bounce_buf(iser_task, mem, cmd_dir);
 +		if (err) {
 +			iser_err("failed to allocate bounce buffer\n");
 +			return err;
 +		}
++=======
+ 	use_dma_key = mem->dma_nents == 1 && (all_imm || !iser_always_reg) &&
+ 		      scsi_get_prot_op(task->sc) == SCSI_PROT_NORMAL;
+ 
+ 	if (!use_dma_key) {
+ 		desc = device->reg_ops->reg_desc_get(ib_conn);
+ 		reg->mem_h = desc;
++>>>>>>> b5f04b00f73d (IB/iser: Don't register memory for all immediate data writes)
  	}
  
 -	if (scsi_get_prot_op(task->sc) == SCSI_PROT_NORMAL)
 -		data_reg = reg;
 -	else
 -		data_reg = &task->desc.data_reg;
 +	if (mem->dma_nents != 1 ||
 +	    scsi_get_prot_op(iser_task->sc) != SCSI_PROT_NORMAL) {
 +		desc = device->reg_ops->reg_desc_get(ib_conn);
 +		mem_reg->mem_h = desc;
 +	}
  
 -	err = iser_reg_data_sg(task, mem, desc, use_dma_key, data_reg);
 -	if (unlikely(err))
 +	err = iser_fast_reg_mr(iser_task, mem,
 +			       desc ? &desc->rsc : NULL, mem_reg);
 +	if (err)
  		goto err_reg;
  
 -	if (scsi_get_prot_op(task->sc) != SCSI_PROT_NORMAL) {
 -		struct iser_mem_reg *prot_reg = &task->desc.prot_reg;
 -
 -		if (scsi_prot_sg_count(task->sc)) {
 -			mem = &task->prot[dir];
 -			err = iser_reg_prot_sg(task, mem, desc,
 -					       use_dma_key, prot_reg);
 -			if (unlikely(err))
 +	if (scsi_get_prot_op(iser_task->sc) != SCSI_PROT_NORMAL) {
 +		struct iser_mem_reg prot_reg;
 +
 +		memset(&prot_reg, 0, sizeof(prot_reg));
 +		if (scsi_prot_sg_count(iser_task->sc)) {
 +			mem = &iser_task->prot[cmd_dir];
 +			aligned_len = iser_data_buf_aligned_len(mem, ibdev);
 +			if (aligned_len != mem->dma_nents) {
 +				err = fall_to_bounce_buf(iser_task, mem,
 +							 cmd_dir);
 +				if (err) {
 +					iser_err("failed to allocate bounce buffer\n");
 +					return err;
 +				}
 +			}
 +
 +			err = iser_fast_reg_mr(iser_task, mem,
 +					       &desc->pi_ctx->rsc, &prot_reg);
 +			if (err)
  				goto err_reg;
  		}
  
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.h
* Unmerged path drivers/infiniband/ulp/iser/iser_initiator.c
* Unmerged path drivers/infiniband/ulp/iser/iser_memory.c
