netfilter: nf_tables: convert expressions to u32 register pointers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Patrick McHardy <kaber@trash.net>
commit fad136ea0d32ead1f62e3e2a3d436c26d74e5289
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fad136ea.failed

Simple conversion to use u32 pointers to the beginning of the registers
to keep follow up patches smaller.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit fad136ea0d32ead1f62e3e2a3d436c26d74e5289)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/netfilter/nft_meta_bridge.c
#	net/netfilter/nf_tables_core.c
#	net/netfilter/nft_bitwise.c
#	net/netfilter/nft_byteorder.c
#	net/netfilter/nft_ct.c
#	net/netfilter/nft_exthdr.c
#	net/netfilter/nft_meta.c
#	net/netfilter/nft_payload.c
diff --cc net/bridge/netfilter/nft_meta_bridge.c
index 4f02109d708f,6184b1548759..000000000000
--- a/net/bridge/netfilter/nft_meta_bridge.c
+++ b/net/bridge/netfilter/nft_meta_bridge.c
@@@ -24,7 -24,7 +24,11 @@@ static void nft_meta_bridge_get_eval(co
  {
  	const struct nft_meta *priv = nft_expr_priv(expr);
  	const struct net_device *in = pkt->in, *out = pkt->out;
++<<<<<<< HEAD
 +	struct nft_data *dest = &data[priv->dreg];
++=======
+ 	u32 *dest = &regs->data[priv->dreg].data[0];
++>>>>>>> fad136ea0d32 (netfilter: nf_tables: convert expressions to u32 register pointers)
  	const struct net_bridge_port *p;
  
  	switch (priv->key) {
@@@ -40,12 -40,12 +44,12 @@@
  		goto out;
  	}
  
- 	strncpy((char *)dest->data, p->br->dev->name, sizeof(dest->data));
+ 	strncpy((char *)dest, p->br->dev->name, IFNAMSIZ);
  	return;
  out:
 -	return nft_meta_get_eval(expr, regs, pkt);
 +	return nft_meta_get_eval(expr, data, pkt);
  err:
 -	regs->verdict.code = NFT_BREAK;
 +	data[NFT_REG_VERDICT].verdict = NFT_BREAK;
  }
  
  static int nft_meta_bridge_get_init(const struct nft_ctx *ctx,
diff --cc net/netfilter/nf_tables_core.c
index 8c00baffe14b,5ef07d17b358..000000000000
--- a/net/netfilter/nf_tables_core.c
+++ b/net/netfilter/nf_tables_core.c
@@@ -80,7 -81,7 +80,11 @@@ static bool nft_payload_fast_eval(cons
  {
  	const struct nft_payload *priv = nft_expr_priv(expr);
  	const struct sk_buff *skb = pkt->skb;
++<<<<<<< HEAD
 +	struct nft_data *dest = &data[priv->dreg];
++=======
+ 	u32 *dest = &regs->data[priv->dreg].data[0];
++>>>>>>> fad136ea0d32 (netfilter: nf_tables: convert expressions to u32 register pointers)
  	unsigned char *ptr;
  
  	if (priv->base == NFT_PAYLOAD_NETWORK_HEADER)
diff --cc net/netfilter/nft_bitwise.c
index 4fb6ee2c1106,d55b5451ce20..000000000000
--- a/net/netfilter/nft_bitwise.c
+++ b/net/netfilter/nft_bitwise.c
@@@ -30,14 -30,12 +30,17 @@@ static void nft_bitwise_eval(const stru
  			     const struct nft_pktinfo *pkt)
  {
  	const struct nft_bitwise *priv = nft_expr_priv(expr);
++<<<<<<< HEAD
 +	const struct nft_data *src = &data[priv->sreg];
 +	struct nft_data *dst = &data[priv->dreg];
++=======
+ 	const u32  *src = &regs->data[priv->sreg].data[0];
+ 	u32 *dst = &regs->data[priv->dreg].data[0];
++>>>>>>> fad136ea0d32 (netfilter: nf_tables: convert expressions to u32 register pointers)
  	unsigned int i;
  
- 	for (i = 0; i < DIV_ROUND_UP(priv->len, 4); i++) {
- 		dst->data[i] = (src->data[i] & priv->mask.data[i]) ^
- 			       priv->xor.data[i];
- 	}
+ 	for (i = 0; i < DIV_ROUND_UP(priv->len, 4); i++)
+ 		dst[i] = (src[i] & priv->mask.data[i]) ^ priv->xor.data[i];
  }
  
  static const struct nla_policy nft_bitwise_policy[NFTA_BITWISE_MAX + 1] = {
diff --cc net/netfilter/nft_byteorder.c
index c39ed8d29df1,d6290db4c756..000000000000
--- a/net/netfilter/nft_byteorder.c
+++ b/net/netfilter/nft_byteorder.c
@@@ -30,7 -30,8 +30,12 @@@ static void nft_byteorder_eval(const st
  			       const struct nft_pktinfo *pkt)
  {
  	const struct nft_byteorder *priv = nft_expr_priv(expr);
++<<<<<<< HEAD
 +	struct nft_data *src = &data[priv->sreg], *dst = &data[priv->dreg];
++=======
+ 	u32 *src = &regs->data[priv->sreg].data[0];
+ 	u32 *dst = &regs->data[priv->dreg].data[0];
++>>>>>>> fad136ea0d32 (netfilter: nf_tables: convert expressions to u32 register pointers)
  	union { u32 u32; u16 u16; } *s, *d;
  	unsigned int i;
  
diff --cc net/netfilter/nft_ct.c
index 18d520e0ca0a,0166f28c4b90..000000000000
--- a/net/netfilter/nft_ct.c
+++ b/net/netfilter/nft_ct.c
@@@ -35,7 -35,7 +35,11 @@@ static void nft_ct_get_eval(const struc
  			    const struct nft_pktinfo *pkt)
  {
  	const struct nft_ct *priv = nft_expr_priv(expr);
++<<<<<<< HEAD
 +	struct nft_data *dest = &data[priv->dreg];
++=======
+ 	u32 *dest = &regs->data[priv->dreg].data[0];
++>>>>>>> fad136ea0d32 (netfilter: nf_tables: convert expressions to u32 register pointers)
  	enum ip_conntrack_info ctinfo;
  	const struct nf_conn *ct;
  	const struct nf_conn_help *help;
@@@ -95,9 -95,7 +99,13 @@@
  		helper = rcu_dereference(help->helper);
  		if (helper == NULL)
  			goto err;
++<<<<<<< HEAD
 +		if (strlen(helper->name) >= sizeof(dest->data))
 +			goto err;
 +		strncpy((char *)dest->data, helper->name, sizeof(dest->data));
++=======
+ 		strncpy((char *)dest, helper->name, NF_CT_HELPER_NAME_LEN);
++>>>>>>> fad136ea0d32 (netfilter: nf_tables: convert expressions to u32 register pointers)
  		return;
  #ifdef CONFIG_NF_CONNTRACK_LABELS
  	case NFT_CT_LABELS: {
@@@ -109,13 -107,11 +117,20 @@@
  			return;
  		}
  
 +		BUILD_BUG_ON(NF_CT_LABELS_MAX_SIZE > sizeof(dest->data));
  		size = labels->words * sizeof(long);
++<<<<<<< HEAD
 +
 +		memcpy(dest->data, labels->bits, size);
 +		if (size < sizeof(dest->data))
 +			memset(((char *) dest->data) + size, 0,
 +			       sizeof(dest->data) - size);
++=======
+ 		memcpy(dest, labels->bits, size);
+ 		if (size < NF_CT_LABELS_MAX_SIZE)
+ 			memset(((char *) dest) + size, 0,
+ 			       NF_CT_LABELS_MAX_SIZE - size);
++>>>>>>> fad136ea0d32 (netfilter: nf_tables: convert expressions to u32 register pointers)
  		return;
  	}
  #endif
diff --cc net/netfilter/nft_exthdr.c
index 55c939f5371f,a85db7504986..000000000000
--- a/net/netfilter/nft_exthdr.c
+++ b/net/netfilter/nft_exthdr.c
@@@ -30,7 -30,7 +30,11 @@@ static void nft_exthdr_eval(const struc
  			    const struct nft_pktinfo *pkt)
  {
  	struct nft_exthdr *priv = nft_expr_priv(expr);
++<<<<<<< HEAD
 +	struct nft_data *dest = &data[priv->dreg];
++=======
+ 	u32 *dest = &regs->data[priv->dreg].data[0];
++>>>>>>> fad136ea0d32 (netfilter: nf_tables: convert expressions to u32 register pointers)
  	unsigned int offset = 0;
  	int err;
  
diff --cc net/netfilter/nft_meta.c
index a4cdc254de57,a6da806f207b..000000000000
--- a/net/netfilter/nft_meta.c
+++ b/net/netfilter/nft_meta.c
@@@ -31,7 -31,7 +31,11 @@@ void nft_meta_get_eval(const struct nft
  	const struct nft_meta *priv = nft_expr_priv(expr);
  	const struct sk_buff *skb = pkt->skb;
  	const struct net_device *in = pkt->in, *out = pkt->out;
++<<<<<<< HEAD
 +	struct nft_data *dest = &data[priv->dreg];
++=======
+ 	u32 *dest = &regs->data[priv->dreg].data[0];
++>>>>>>> fad136ea0d32 (netfilter: nf_tables: convert expressions to u32 register pointers)
  
  	switch (priv->key) {
  	case NFT_META_LEN:
@@@ -80,10 -80,10 +84,10 @@@
  	case NFT_META_OIFTYPE:
  		if (out == NULL)
  			goto err;
- 		*(u16 *)dest->data = out->type;
+ 		*(u16 *)dest = out->type;
  		break;
  	case NFT_META_SKUID:
 -		if (skb->sk == NULL || !sk_fullsock(skb->sk))
 +		if (skb->sk == NULL || skb->sk->sk_state == TCP_TIME_WAIT)
  			goto err;
  
  		read_lock_bh(&skb->sk->sk_callback_lock);
diff --cc net/netfilter/nft_payload.c
index 85daa84bfdfe,6bb0592fde06..000000000000
--- a/net/netfilter/nft_payload.c
+++ b/net/netfilter/nft_payload.c
@@@ -23,7 -23,7 +23,11 @@@ static void nft_payload_eval(const stru
  {
  	const struct nft_payload *priv = nft_expr_priv(expr);
  	const struct sk_buff *skb = pkt->skb;
++<<<<<<< HEAD
 +	struct nft_data *dest = &data[priv->dreg];
++=======
+ 	u32 *dest = &regs->data[priv->dreg].data[0];
++>>>>>>> fad136ea0d32 (netfilter: nf_tables: convert expressions to u32 register pointers)
  	int offset;
  
  	switch (priv->base) {
* Unmerged path net/bridge/netfilter/nft_meta_bridge.c
* Unmerged path net/netfilter/nf_tables_core.c
* Unmerged path net/netfilter/nft_bitwise.c
* Unmerged path net/netfilter/nft_byteorder.c
* Unmerged path net/netfilter/nft_ct.c
* Unmerged path net/netfilter/nft_exthdr.c
* Unmerged path net/netfilter/nft_meta.c
* Unmerged path net/netfilter/nft_payload.c
