usb: sysfs: make locking interruptible

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Oliver Neukum <oneukum@suse.com>
commit 7dd9cba5bb90ffa9c60c1533b715dc91c5082cd9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7dd9cba5.failed

232275a USB: fix substandard locking for the sysfs files
introduced needed locking into sysfs operations on USB devices
It, however, uses uninterruptible sleep and if the error
handling is on extreme cases of sleep lengths of 10s of seconds
are possible. Unless we are removing the device we should use
interruptible sleep.

	Signed-off-by: Oliver Neukum <oneukum@suse.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 7dd9cba5bb90ffa9c60c1533b715dc91c5082cd9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/core/sysfs.c
diff --cc drivers/usb/core/sysfs.c
index 18958ee8ade1,7a6209314997..000000000000
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@@ -542,6 -553,50 +561,53 @@@ static ssize_t usb2_lpm_besl_store(stru
  }
  static DEVICE_ATTR_RW(usb2_lpm_besl);
  
++<<<<<<< HEAD
++=======
+ static ssize_t usb3_hardware_lpm_u1_show(struct device *dev,
+ 				      struct device_attribute *attr, char *buf)
+ {
+ 	struct usb_device *udev = to_usb_device(dev);
+ 	const char *p;
+ 	int rc;
+ 
+ 	rc = usb_lock_device_interruptible(udev);
+ 	if (rc < 0)
+ 		return -EINTR;
+ 
+ 	if (udev->usb3_lpm_u1_enabled)
+ 		p = "enabled";
+ 	else
+ 		p = "disabled";
+ 
+ 	usb_unlock_device(udev);
+ 
+ 	return sprintf(buf, "%s\n", p);
+ }
+ static DEVICE_ATTR_RO(usb3_hardware_lpm_u1);
+ 
+ static ssize_t usb3_hardware_lpm_u2_show(struct device *dev,
+ 				      struct device_attribute *attr, char *buf)
+ {
+ 	struct usb_device *udev = to_usb_device(dev);
+ 	const char *p;
+ 	int rc;
+ 
+ 	rc = usb_lock_device_interruptible(udev);
+ 	if (rc < 0)
+ 		return -EINTR;
+ 
+ 	if (udev->usb3_lpm_u2_enabled)
+ 		p = "enabled";
+ 	else
+ 		p = "disabled";
+ 
+ 	usb_unlock_device(udev);
+ 
+ 	return sprintf(buf, "%s\n", p);
+ }
+ static DEVICE_ATTR_RO(usb3_hardware_lpm_u2);
+ 
++>>>>>>> 7dd9cba5bb90 (usb: sysfs: make locking interruptible)
  static struct attribute *usb2_hardware_lpm_attr[] = {
  	&dev_attr_usb2_hardware_lpm.attr,
  	&dev_attr_usb2_lpm_l1_timeout.attr,
* Unmerged path drivers/usb/core/sysfs.c
diff --git a/include/linux/device.h b/include/linux/device.h
index 16fec9b06e34..89e7e1c52319 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -905,6 +905,11 @@ static inline void device_lock(struct device *dev)
 	mutex_lock(&dev->mutex);
 }
 
+static inline int device_lock_interruptible(struct device *dev)
+{
+	return mutex_lock_interruptible(&dev->mutex);
+}
+
 static inline int device_trylock(struct device *dev)
 {
 	return mutex_trylock(&dev->mutex);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5d0f53f28f68..d0723f6e23af 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -640,9 +640,10 @@ extern struct usb_device *usb_hub_find_child(struct usb_device *hdev,
 		if (!child) continue; else
 
 /* USB device locking */
-#define usb_lock_device(udev)		device_lock(&(udev)->dev)
-#define usb_unlock_device(udev)		device_unlock(&(udev)->dev)
-#define usb_trylock_device(udev)	device_trylock(&(udev)->dev)
+#define usb_lock_device(udev)			device_lock(&(udev)->dev)
+#define usb_unlock_device(udev)			device_unlock(&(udev)->dev)
+#define usb_lock_device_interruptible(udev)	device_lock_interruptible(&(udev)->dev)
+#define usb_trylock_device(udev)		device_trylock(&(udev)->dev)
 extern int usb_lock_device_for_reset(struct usb_device *udev,
 				     const struct usb_interface *iface);
 
