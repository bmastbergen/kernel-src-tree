drm/dp/mst: Validate port in drm_dp_payload_send_msg()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drm] dp_mst: Validate port in drm_dp_payload_send_msg() (Rob Clark) [1072036 1115530 1202702 1211398 1272159 1329087 1331031]
Rebuild_FUZZ: 94.23%
commit-author cpaul@redhat.com <cpaul@redhat.com>
commit deba0a2af9592b2022a0bce7b085a318b53ce1db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/deba0a2a.failed

With the joys of things running concurrently, there's always a chance
that the port we get passed in drm_dp_payload_send_msg() isn't actually
valid anymore. Because of this, we need to make sure we validate the
reference to the port before we use it otherwise we risk running into
various race conditions. For instance, on the Dell MST monitor I have
here for testing, hotplugging it enough times causes us to kernel panic:

[drm:intel_mst_enable_dp] 1
[drm:drm_dp_update_payload_part2] payload 0 1
[drm:intel_get_hpd_pins] hotplug event received, stat 0x00200000, dig 0x10101011, pins 0x00000020
[drm:intel_hpd_irq_handler] digital hpd port B - short
[drm:intel_dp_hpd_pulse] got hpd irq on port B - short
[drm:intel_dp_check_mst_status] got esi 00 10 00
[drm:drm_dp_update_payload_part2] payload 1 1
general protection fault: 0000 [#1] SMP
â€¦
Call Trace:
 [<ffffffffa012b632>] drm_dp_update_payload_part2+0xc2/0x130 [drm_kms_helper]
 [<ffffffffa032ef08>] intel_mst_enable_dp+0xf8/0x180 [i915]
 [<ffffffffa0310dbd>] haswell_crtc_enable+0x3ed/0x8c0 [i915]
 [<ffffffffa030c84d>] intel_atomic_commit+0x5ad/0x1590 [i915]
 [<ffffffffa01db877>] ? drm_atomic_set_crtc_for_connector+0x57/0xe0 [drm]
 [<ffffffffa01dc4e7>] drm_atomic_commit+0x37/0x60 [drm]
 [<ffffffffa0130a3a>] drm_atomic_helper_set_config+0x7a/0xb0 [drm_kms_helper]
 [<ffffffffa01cc482>] drm_mode_set_config_internal+0x62/0x100 [drm]
 [<ffffffffa01d02ad>] drm_mode_setcrtc+0x3cd/0x4e0 [drm]
 [<ffffffffa01c18e3>] drm_ioctl+0x143/0x510 [drm]
 [<ffffffffa01cfee0>] ? drm_mode_setplane+0x1b0/0x1b0 [drm]
 [<ffffffff810f79a7>] ? hrtimer_start_range_ns+0x1b7/0x3a0
 [<ffffffff81212962>] do_vfs_ioctl+0x92/0x570
 [<ffffffff81590852>] ? __sys_recvmsg+0x42/0x80
 [<ffffffff81212eb9>] SyS_ioctl+0x79/0x90
 [<ffffffff816b4e32>] entry_SYSCALL_64_fastpath+0x1a/0xa4
RIP  [<ffffffffa012b026>] drm_dp_payload_send_msg+0x146/0x1f0 [drm_kms_helper]

Which occurs because of the hotplug event shown in the log, which ends
up causing DRM's dp helpers to drop the port we're updating the payload
on and panic.

CC: stable@vger.kernel.org
	Signed-off-by: Lyude <cpaul@redhat.com>
	Reviewed-by: David Airlie <airlied@linux.ie>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit deba0a2af9592b2022a0bce7b085a318b53ce1db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/drm_dp_mst_topology.c
diff --cc drivers/gpu/drm/drm_dp_mst_topology.c
index 30a3f1b915ea,e17fbdaf874b..000000000000
--- a/drivers/gpu/drm/drm_dp_mst_topology.c
+++ b/drivers/gpu/drm/drm_dp_mst_topology.c
@@@ -1553,11 -1668,24 +1553,28 @@@ static int drm_dp_payload_send_msg(stru
  {
  	struct drm_dp_sideband_msg_tx *txmsg;
  	struct drm_dp_mst_branch *mstb;
 -	int len, ret, port_num;
 -	u8 sinks[DRM_DP_MAX_SDP_STREAMS];
 -	int i;
 +	int ret;
  
++<<<<<<< HEAD
 +	mstb = drm_dp_get_validated_mstb_ref(mgr, port->parent);
 +	if (!mstb)
 +		return -EINVAL;
++=======
+ 	port = drm_dp_get_validated_port_ref(mgr, port);
+ 	if (!port)
+ 		return -EINVAL;
+ 
+ 	port_num = port->port_num;
+ 	mstb = drm_dp_get_validated_mstb_ref(mgr, port->parent);
+ 	if (!mstb) {
+ 		mstb = drm_dp_get_last_connected_port_and_mstb(mgr, port->parent, &port_num);
+ 
+ 		if (!mstb) {
+ 			drm_dp_put_port(port);
+ 			return -EINVAL;
+ 		}
+ 	}
++>>>>>>> deba0a2af959 (drm/dp/mst: Validate port in drm_dp_payload_send_msg())
  
  	txmsg = kzalloc(sizeof(*txmsg), GFP_KERNEL);
  	if (!txmsg) {
* Unmerged path drivers/gpu/drm/drm_dp_mst_topology.c
