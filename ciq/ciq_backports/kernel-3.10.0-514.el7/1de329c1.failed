x86/platform/UV: Support UV4 socket address changes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] platform/uv: Support UV4 socket address changes (Frank Ramsay) [1276458]
Rebuild_FUZZ: 95.92%
commit-author Mike Travis <travis@sgi.com>
commit 1de329c10d9fbac4031f8eb30c4921c6efbf9faa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1de329c1.failed

With the UV4 system architecture addressing changes, BIOS now provides
this information via an EFI system table.  This is the initial decoding
of that system table.  It also collects the sizing information for
later allocation of dynamic conversion tables.

	Tested-by: Dimitri Sivanich <sivanich@sgi.com>
	Tested-by: John Estabrook <estabrook@sgi.com>
	Tested-by: Gary Kroening <gfk@sgi.com>
	Tested-by: Nathan Zimmer <nzimmer@sgi.com>
	Signed-off-by: Mike Travis <travis@sgi.com>
	Reviewed-by: Dimitri Sivanich <sivanich@sgi.com>
	Cc: Andrew Banman <abanman@sgi.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Len Brown <len.brown@intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Russ Anderson <rja@sgi.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/20160429215405.503022681@asylum.americas.sgi.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 1de329c10d9fbac4031f8eb30c4921c6efbf9faa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/apic/x2apic_uv_x.c
diff --cc arch/x86/kernel/apic/x2apic_uv_x.c
index fd86a4f25c81,128f47e7b018..000000000000
--- a/arch/x86/kernel/apic/x2apic_uv_x.c
+++ b/arch/x86/kernel/apic/x2apic_uv_x.c
@@@ -306,9 -301,22 +306,26 @@@ EXPORT_SYMBOL_GPL(uv_possible_blades)
  unsigned long sn_rtc_cycles_per_second;
  EXPORT_SYMBOL(sn_rtc_cycles_per_second);
  
++<<<<<<< HEAD
++=======
+ /* the following values are used for the per node hub info struct */
+ static __initdata unsigned short *_node_to_pnode;
+ static __initdata unsigned short _min_socket, _max_socket;
+ static __initdata unsigned short _min_pnode, _max_pnode, _gr_table_len;
+ static __initdata struct uv_gam_range_entry *uv_gre_table;
+ static __initdata struct uv_gam_parameters *uv_gp_table;
+ #define	SOCK_EMPTY	((unsigned short)~0)
+ 
+ extern int uv_hub_info_version(void)
+ {
+ 	return UV_HUB_INFO_VERSION;
+ }
+ EXPORT_SYMBOL(uv_hub_info_version);
+ 
++>>>>>>> 1de329c10d9f (x86/platform/UV: Support UV4 socket address changes)
  static int uv_wakeup_secondary(int phys_apicid, unsigned long start_rip)
  {
 +#ifdef CONFIG_SMP
  	unsigned long val;
  	int pnode;
  
@@@ -1030,11 -1030,147 +1062,101 @@@ void __init uv_init_hub_info(struct uv_
  
  	pr_info("UV: gnode_upper:0x%lx gnode_extra:0x%x\n",
  		hub_info->gnode_upper, hub_info->gnode_extra);
+ }
+ 
+ static void __init decode_gam_params(unsigned long ptr)
+ {
+ 	uv_gp_table = (struct uv_gam_parameters *)ptr;
+ 
+ 	pr_info("UV: GAM Params...\n");
+ 	pr_info("UV: mmr_base/shift:0x%llx/%d gru_base/shift:0x%llx/%d gpa_shift:%d\n",
+ 		uv_gp_table->mmr_base, uv_gp_table->mmr_shift,
+ 		uv_gp_table->gru_base, uv_gp_table->gru_shift,
+ 		uv_gp_table->gpa_shift);
+ }
  
- 	pr_info("UV: global MMR base 0x%lx\n", hub_info->global_mmr_base);
+ static void __init decode_gam_rng_tbl(unsigned long ptr)
+ {
+ 	struct uv_gam_range_entry *gre = (struct uv_gam_range_entry *)ptr;
+ 	unsigned long lgre = 0;
+ 	int index = 0;
+ 	int sock_min = 999999, pnode_min = 99999;
+ 	int sock_max = -1, pnode_max = -1;
+ 
+ 	uv_gre_table = gre;
+ 	for (; gre->type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {
+ 		if (!index) {
+ 			pr_info("UV: GAM Range Table...\n");
+ 			pr_info("UV:  # %20s %14s %5s %4s %5s %3s %2s %3s\n",
+ 				"Range", "", "Size", "Type", "NASID",
+ 				"SID", "PN", "PXM");
+ 		}
+ 		pr_info(
+ 		"UV: %2d: 0x%014lx-0x%014lx %5luG %3d   %04x  %02x %02x %3d\n",
+ 			index++,
+ 			(unsigned long)lgre << UV_GAM_RANGE_SHFT,
+ 			(unsigned long)gre->limit << UV_GAM_RANGE_SHFT,
+ 			((unsigned long)(gre->limit - lgre)) >>
+ 				(30 - UV_GAM_RANGE_SHFT), /* 64M -> 1G */
+ 			gre->type, gre->nasid, gre->sockid,
+ 			gre->pnode, gre->pxm);
+ 
+ 		lgre = gre->limit;
+ 		if (sock_min > gre->sockid)
+ 			sock_min = gre->sockid;
+ 		if (sock_max < gre->sockid)
+ 			sock_max = gre->sockid;
+ 		if (pnode_min > gre->pnode)
+ 			pnode_min = gre->pnode;
+ 		if (pnode_max < gre->pnode)
+ 			pnode_max = gre->pnode;
+ 	}
  
+ 	_min_socket = sock_min;
+ 	_max_socket = sock_max;
+ 	_min_pnode = pnode_min;
+ 	_max_pnode = pnode_max;
+ 	_gr_table_len = index;
+ 	pr_info(
+ 	"UV: GRT: %d entries, sockets(min:%x,max:%x) pnodes(min:%x,max:%x)\n",
+ 		index, _min_socket, _max_socket, _min_pnode, _max_pnode);
+ }
+ 
+ static void __init decode_uv_systab(void)
+ {
+ 	struct uv_systab *st;
+ 	int i;
+ 
+ 	st = uv_systab;
+ 	if ((!st || st->revision < UV_SYSTAB_VERSION_UV4) && !is_uv4_hub())
+ 		return;
+ 	if (st->revision != UV_SYSTAB_VERSION_UV4_LATEST) {
+ 		pr_crit(
+ 		"UV: BIOS UVsystab version(%x) mismatch, expecting(%x)\n",
+ 			st->revision, UV_SYSTAB_VERSION_UV4_LATEST);
+ 		BUG();
+ 	}
+ 
+ 	for (i = 0; st->entry[i].type != UV_SYSTAB_TYPE_UNUSED; i++) {
+ 		unsigned long ptr = st->entry[i].offset;
+ 
+ 		if (!ptr)
+ 			continue;
+ 
+ 		ptr = ptr + (unsigned long)st;
+ 
+ 		switch (st->entry[i].type) {
+ 		case UV_SYSTAB_TYPE_GAM_PARAMS:
+ 			decode_gam_params(ptr);
+ 			break;
+ 
+ 		case UV_SYSTAB_TYPE_GAM_RNG_TBL:
+ 			decode_gam_rng_tbl(ptr);
+ 			break;
+ 		}
+ 	}
  }
  
 -/*
 - * Setup physical blade translations from UVH_NODE_PRESENT_TABLE
 - * .. NB: UVH_NODE_PRESENT_TABLE is going away,
 - * .. being replaced by GAM Range Table
 - */
 -static __init void boot_init_possible_blades(struct uv_hub_info_s *hub_info)
 -{
 -	size_t bytes;
 -	int blade, i, j, uv_pb = 0, num_nodes = num_possible_nodes();
 -
 -	pr_info("UV: NODE_PRESENT_DEPTH = %d\n", UVH_NODE_PRESENT_TABLE_DEPTH);
 -	for (i = 0; i < UVH_NODE_PRESENT_TABLE_DEPTH; i++) {
 -		unsigned long np;
 -
 -		np = uv_read_local_mmr(UVH_NODE_PRESENT_TABLE + i * 8);
 -		if (np)
 -			pr_info("UV: NODE_PRESENT(%d) = 0x%016lx\n", i, np);
 -
 -		uv_pb += hweight64(np);
 -	}
 -	if (uv_possible_blades != uv_pb)
 -		uv_possible_blades = uv_pb;
 -
 -	bytes = num_nodes * sizeof(_node_to_pnode[0]);
 -	_node_to_pnode = kmalloc(bytes, GFP_KERNEL);
 -	BUG_ON(!_node_to_pnode);
 -
 -	for (blade = 0, i = 0; i < UVH_NODE_PRESENT_TABLE_DEPTH; i++) {
 -		unsigned short pnode;
 -		unsigned long present =
 -			uv_read_local_mmr(UVH_NODE_PRESENT_TABLE + i * 8);
 -
 -		for (j = 0; j < 64; j++) {
 -			if (!test_bit(j, &present))
 -				continue;
 -			pnode = (i * 64 + j) & hub_info->pnode_mask;
 -			_node_to_pnode[blade++] = pnode;
 -		}
 -		if (blade > num_nodes) {
 -			pr_err("UV: blade count(%d) exceeds node count(%d)!\n",
 -				blade, num_nodes);
 -			BUG();
 -		}
 -	}
 -}
 -
  void __init uv_system_init(void)
  {
  	struct uv_hub_info_s hub_info = {0};
@@@ -1050,13 -1186,17 +1172,15 @@@
  		return;
  	}
  	pr_info("UV: Found %s hub\n", hub);
 -
 -	/* We now only need to map the MMRs on UV1 */
 -	if (is_uv1_hub())
 -		map_low_mmrs();
 +	map_low_mmrs();
  
+ 	uv_bios_init();			/* get uv_systab for decoding */
+ 	decode_uv_systab();
  	uv_init_hub_info(&hub_info);
 -	uv_possible_blades = num_possible_nodes();
 -	if (!_node_to_pnode)
 -		boot_init_possible_blades(&hub_info);
 +
 +	for(i = 0; i < UVH_NODE_PRESENT_TABLE_DEPTH; i++)
 +		uv_possible_blades +=
 +		  hweight64(uv_read_local_mmr( UVH_NODE_PRESENT_TABLE + i * 8));
  
  	/* uv_num_possible_blades() is really the hub count */
  	pr_info("UV: Found %d hubs, %d nodes, %d cpus\n",
@@@ -1064,84 -1204,68 +1188,87 @@@
  			num_possible_nodes(),
  			num_possible_cpus());
  
 -	uv_bios_get_sn_info(0, &uv_type, &sn_partition_id, &sn_coherency_id,
 -			    &sn_region_size, &system_serial_number);
 -	hub_info.coherency_domain_number = sn_coherency_id;
 -	uv_rtc_init();
++<<<<<<< HEAD
 +	bytes = sizeof(struct uv_blade_info) * uv_num_possible_blades();
 +	uv_blade_info = kzalloc(bytes, GFP_KERNEL);
 +	BUG_ON(!uv_blade_info);
  
 -	bytes = sizeof(void *) * uv_num_possible_blades();
 -	__uv_hub_info_list = kzalloc(bytes, GFP_KERNEL);
 -	BUG_ON(!__uv_hub_info_list);
 +	for (blade = 0; blade < uv_num_possible_blades(); blade++)
 +		uv_blade_info[blade].memory_nid = -1;
  
 -	bytes = sizeof(struct uv_hub_info_s);
 -	for_each_node(nodeid) {
 -		struct uv_hub_info_s *new_hub;
 -		unsigned short pnode;
  
 -		if (__uv_hub_info_list[nodeid]) {
 -			pr_err("UV: Node %d UV HUB already initialized!?\n",
 -				nodeid);
 -			BUG();
 -		}
 +	bytes = sizeof(uv_node_to_blade[0]) * num_possible_nodes();
 +	uv_node_to_blade = kmalloc(bytes, GFP_KERNEL);
 +	BUG_ON(!uv_node_to_blade);
 +	memset(uv_node_to_blade, 255, bytes);
  
 -		/* Allocate new per hub info list */
 -		new_hub = (nodeid == 0) ?
 -			&uv_hub_info_node0 :
 -			kzalloc_node(bytes, GFP_KERNEL, nodeid);
 -		BUG_ON(!new_hub);
 -		__uv_hub_info_list[nodeid] = new_hub;
 -		new_hub = uv_hub_info_list(nodeid);
 -		BUG_ON(!new_hub);
 -		*new_hub = hub_info;
 -
 -		pnode = _node_to_pnode[nodeid];
 -		min_pnode = min(pnode, min_pnode);
 -		max_pnode = max(pnode, max_pnode);
 -		new_hub->pnode = pnode;
 -		new_hub->numa_blade_id = uv_node_to_blade_id(nodeid);
 -		new_hub->memory_nid = -1;
 -		new_hub->nr_possible_cpus = 0;
 -		new_hub->nr_online_cpus = 0;
 +	bytes = sizeof(uv_cpu_to_blade[0]) * num_possible_cpus();
 +	uv_cpu_to_blade = kmalloc(bytes, GFP_KERNEL);
 +	BUG_ON(!uv_cpu_to_blade);
 +	memset(uv_cpu_to_blade, 255, bytes);
 +
 +	blade = 0;
 +	for (i = 0; i < UVH_NODE_PRESENT_TABLE_DEPTH; i++) {
 +		unsigned long present =
 +			uv_read_local_mmr(UVH_NODE_PRESENT_TABLE + i * 8);
 +		for (j = 0; j < 64; j++) {
 +			if (!test_bit(j, &present))
 +				continue;
 +			pnode = (i * 64 + j) & hub_info.pnode_mask;
 +			uv_blade_info[blade].pnode = pnode;
 +			uv_blade_info[blade].nr_possible_cpus = 0;
 +			uv_blade_info[blade].nr_online_cpus = 0;
 +			min_pnode = min(pnode, min_pnode);
 +			max_pnode = max(pnode, max_pnode);
 +			blade++;
 +		}
  	}
  
 -	/* Initialize per cpu info */
 -	for_each_possible_cpu(cpu) {
 -		int apicid = per_cpu(x86_cpu_to_apicid, cpu);
 +	uv_bios_init();
++=======
++>>>>>>> 1de329c10d9f (x86/platform/UV: Support UV4 socket address changes)
 +	uv_bios_get_sn_info(0, &uv_type, &sn_partition_id, &sn_coherency_id,
 +			    &sn_region_size, &system_serial_number);
 +	hub_info.coherency_domain_number = sn_coherency_id;
 +	uv_rtc_init();
  
 -		nodeid = cpu_to_node(cpu);
 -		uv_cpu_info_per(cpu)->p_uv_hub_info = uv_hub_info_list(nodeid);
 -		uv_cpu_info_per(cpu)->blade_cpu_id =
 -			uv_cpu_hub_info(cpu)->nr_possible_cpus++;
 -		if (uv_cpu_hub_info(cpu)->memory_nid == -1)
 -			uv_cpu_hub_info(cpu)->memory_nid = cpu_to_node(cpu);
 -		uv_cpu_scir_info(cpu)->offset = uv_scir_offset(apicid);
 +	for_each_present_cpu(cpu) {
 +		int apicid = per_cpu(x86_cpu_to_apicid, cpu);
 +		int nodeid = cpu_to_node(cpu);
 +		int lcpu;
 +
 +		*uv_cpu_hub_info(cpu) = hub_info;	/* common hub values */
 +		pnode = uv_apicid_to_pnode(apicid);
 +		blade = boot_pnode_to_blade(pnode);
 +		lcpu = uv_blade_info[blade].nr_possible_cpus;
 +		uv_blade_info[blade].nr_possible_cpus++;
 +
 +		/* Any node on the blade, else will contain -1. */
 +		uv_blade_info[blade].memory_nid = nodeid;
 +
 +		uv_cpu_hub_info(cpu)->numa_blade_id = blade;
 +		uv_cpu_hub_info(cpu)->pnode = pnode;
 +		uv_node_to_blade[nodeid] = blade;
 +		uv_cpu_to_blade[cpu] = blade;
 +
 +		/* Initialize per cpu info list */
 +		uv_cpu_info_per(cpu)->p_uv_hub_info = uv_cpu_hub_info(cpu);
 +		uv_cpu_info_per(cpu)->blade_cpu_id = lcpu;
 +		uv_cpu_info_per(cpu)->scir.offset = uv_scir_offset(apicid);
  	}
  
 -	/* Display per node info */
 -	for_each_node(nodeid) {
 -		pr_info("UV: UVHUB node:%2d pn:%02x nrcpus:%d\n",
 -			nodeid,
 -			uv_hub_info_list(nodeid)->pnode,
 -			uv_hub_info_list(nodeid)->nr_possible_cpus);
 +	/* Add blade/pnode info for nodes without cpus */
 +	for_each_online_node(nid) {
 +		unsigned long paddr;
 +
 +		if (uv_node_to_blade[nid] >= 0)
 +			continue;
 +		paddr = node_start_pfn(nid) << PAGE_SHIFT;
 +		pnode = uv_gpa_to_pnode(uv_soc_phys_ram_to_gpa(paddr));
 +		blade = boot_pnode_to_blade(pnode);
 +		uv_node_to_blade[nid] = blade;
  	}
  
 -	pr_info("UV: min_pnode:%02x max_pnode:%02x\n", min_pnode, max_pnode);
  	map_gru_high(max_pnode);
  	map_mmr_high(max_pnode);
  	map_mmioh_high(min_pnode, max_pnode);
diff --git a/arch/x86/include/asm/uv/uv_hub.h b/arch/x86/include/asm/uv/uv_hub.h
index 74f8c4a9bc11..68307d2b2c7f 100644
--- a/arch/x86/include/asm/uv/uv_hub.h
+++ b/arch/x86/include/asm/uv/uv_hub.h
@@ -146,15 +146,21 @@ struct uv_scir_s {
  */
 struct uv_hub_info_s {
 	unsigned long		global_mmr_base;
+	unsigned long		global_mmr_shift;
 	unsigned long		gpa_mask;
-	unsigned int		gnode_extra;
+	unsigned short		min_socket;
+	unsigned short		min_pnode;
 	unsigned char		hub_revision;
 	unsigned char		apic_pnode_shift;
+	unsigned char		gpa_shift;
 	unsigned char		m_shift;
 	unsigned char		n_lshift;
+	unsigned int		gnode_extra;
 	unsigned long		gnode_upper;
 	unsigned long		lowmem_remap_top;
 	unsigned long		lowmem_remap_base;
+	unsigned long		global_gru_base;
+	unsigned long		global_gru_shift;
 	unsigned short		pnode;
 	unsigned short		pnode_mask;
 	unsigned short		coherency_domain_number;
@@ -330,7 +336,8 @@ union uvh_apicid {
 #define UV_GLOBAL_GRU_MMR_BASE		0x4000000
 
 #define UV_GLOBAL_MMR32_PNODE_SHIFT	15
-#define UV_GLOBAL_MMR64_PNODE_SHIFT	26
+#define _UV_GLOBAL_MMR64_PNODE_SHIFT	26
+#define UV_GLOBAL_MMR64_PNODE_SHIFT	(uv_hub_info->global_mmr_shift)
 
 #define UV_GLOBAL_MMR32_PNODE_BITS(p)	((p) << (UV_GLOBAL_MMR32_PNODE_SHIFT))
 
* Unmerged path arch/x86/kernel/apic/x2apic_uv_x.c
