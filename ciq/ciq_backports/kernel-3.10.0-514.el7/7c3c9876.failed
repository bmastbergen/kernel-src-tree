iommu/vt-d: Make sure copied over IR entries are not reused

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [iommu] vt-d: Make sure copied over IR entries are not reused (Myron Stowe) [1050021]
Rebuild_FUZZ: 94.64%
commit-author Joerg Roedel <jroedel@suse.de>
commit 7c3c9876d98a76b97d16c0f46cb108e95542b212
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7c3c9876.failed

Walk over the copied entries and mark the present ones as
allocated.

	Tested-by: ZhenHua Li <zhen-hual@hp.com>
	Tested-by: Baoquan He <bhe@redhat.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 7c3c9876d98a76b97d16c0f46cb108e95542b212)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel_irq_remapping.c
diff --cc drivers/iommu/intel_irq_remapping.c
index 085a116a8b0a,14e10de4a548..000000000000
--- a/drivers/iommu/intel_irq_remapping.c
+++ b/drivers/iommu/intel_irq_remapping.c
@@@ -424,11 -447,59 +424,62 @@@ static int set_msi_sid(struct irte *irt
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int iommu_load_old_irte(struct intel_iommu *iommu)
+ {
+ 	struct irte *old_ir_table;
+ 	phys_addr_t irt_phys;
+ 	unsigned int i;
+ 	size_t size;
+ 	u64 irta;
+ 
+ 	if (!is_kdump_kernel()) {
+ 		pr_warn("IRQ remapping was enabled on %s but we are not in kdump mode\n",
+ 			iommu->name);
+ 		clear_ir_pre_enabled(iommu);
+ 		iommu_disable_irq_remapping(iommu);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Check whether the old ir-table has the same size as ours */
+ 	irta = dmar_readq(iommu->reg + DMAR_IRTA_REG);
+ 	if ((irta & INTR_REMAP_TABLE_REG_SIZE_MASK)
+ 	     != INTR_REMAP_TABLE_REG_SIZE)
+ 		return -EINVAL;
+ 
+ 	irt_phys = irta & VTD_PAGE_MASK;
+ 	size     = INTR_REMAP_TABLE_ENTRIES*sizeof(struct irte);
+ 
+ 	/* Map the old IR table */
+ 	old_ir_table = ioremap_cache(irt_phys, size);
+ 	if (!old_ir_table)
+ 		return -ENOMEM;
+ 
+ 	/* Copy data over */
+ 	memcpy(iommu->ir_table->base, old_ir_table, size);
+ 
+ 	__iommu_flush_cache(iommu, iommu->ir_table->base, size);
+ 
+ 	/*
+ 	 * Now check the table for used entries and mark those as
+ 	 * allocated in the bitmap
+ 	 */
+ 	for (i = 0; i < INTR_REMAP_TABLE_ENTRIES; i++) {
+ 		if (iommu->ir_table->base[i].present)
+ 			bitmap_set(iommu->ir_table->bitmap, i, 1);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ 
++>>>>>>> 7c3c9876d98a (iommu/vt-d: Make sure copied over IR entries are not reused)
  static void iommu_set_irq_remapping(struct intel_iommu *iommu, int mode)
  {
 -	unsigned long flags;
  	u64 addr;
  	u32 sts;
 +	unsigned long flags;
  
  	addr = virt_to_phys((void *)iommu->ir_table->base);
  
* Unmerged path drivers/iommu/intel_irq_remapping.c
