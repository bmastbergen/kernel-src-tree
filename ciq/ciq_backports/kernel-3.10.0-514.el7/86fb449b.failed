pNFS/flexfiles: Fix an Oopsable typo in ff_mirror_match_fh()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 86fb449b07b8215443a30782dca5755d5b8b0577
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/86fb449b.failed

Jeff reports seeing an Oops in ff_layout_alloc_lseg. Turns out
copy+paste has played cruel tricks on a nested loop.

	Reported-by: Jeff Layton <jeff.layton@primarydata.com>
	Cc: stable@vger.kernel.org # 4.3+
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 86fb449b07b8215443a30782dca5755d5b8b0577)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/flexfilelayout/flexfilelayout.c
diff --cc fs/nfs/flexfilelayout/flexfilelayout.c
index 559bc6842087,405f46ba490e..000000000000
--- a/fs/nfs/flexfilelayout/flexfilelayout.c
+++ b/fs/nfs/flexfilelayout/flexfilelayout.c
@@@ -135,6 -136,66 +135,69 @@@ decode_name(struct xdr_stream *xdr, u3
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static bool ff_mirror_match_fh(const struct nfs4_ff_layout_mirror *m1,
+ 		const struct nfs4_ff_layout_mirror *m2)
+ {
+ 	int i, j;
+ 
+ 	if (m1->fh_versions_cnt != m2->fh_versions_cnt)
+ 		return false;
+ 	for (i = 0; i < m1->fh_versions_cnt; i++) {
+ 		bool found_fh = false;
+ 		for (j = 0; j < m2->fh_versions_cnt; j++) {
+ 			if (nfs_compare_fh(&m1->fh_versions[i],
+ 					&m2->fh_versions[j]) == 0) {
+ 				found_fh = true;
+ 				break;
+ 			}
+ 		}
+ 		if (!found_fh)
+ 			return false;
+ 	}
+ 	return true;
+ }
+ 
+ static struct nfs4_ff_layout_mirror *
+ ff_layout_add_mirror(struct pnfs_layout_hdr *lo,
+ 		struct nfs4_ff_layout_mirror *mirror)
+ {
+ 	struct nfs4_flexfile_layout *ff_layout = FF_LAYOUT_FROM_HDR(lo);
+ 	struct nfs4_ff_layout_mirror *pos;
+ 	struct inode *inode = lo->plh_inode;
+ 
+ 	spin_lock(&inode->i_lock);
+ 	list_for_each_entry(pos, &ff_layout->mirrors, mirrors) {
+ 		if (mirror->mirror_ds != pos->mirror_ds)
+ 			continue;
+ 		if (!ff_mirror_match_fh(mirror, pos))
+ 			continue;
+ 		if (atomic_inc_not_zero(&pos->ref)) {
+ 			spin_unlock(&inode->i_lock);
+ 			return pos;
+ 		}
+ 	}
+ 	list_add(&mirror->mirrors, &ff_layout->mirrors);
+ 	mirror->layout = lo;
+ 	spin_unlock(&inode->i_lock);
+ 	return mirror;
+ }
+ 
+ static void
+ ff_layout_remove_mirror(struct nfs4_ff_layout_mirror *mirror)
+ {
+ 	struct inode *inode;
+ 	if (mirror->layout == NULL)
+ 		return;
+ 	inode = mirror->layout->plh_inode;
+ 	spin_lock(&inode->i_lock);
+ 	list_del(&mirror->mirrors);
+ 	spin_unlock(&inode->i_lock);
+ 	mirror->layout = NULL;
+ }
+ 
++>>>>>>> 86fb449b07b8 (pNFS/flexfiles: Fix an Oopsable typo in ff_mirror_match_fh())
  static struct nfs4_ff_layout_mirror *ff_layout_alloc_mirror(gfp_t gfp_flags)
  {
  	struct nfs4_ff_layout_mirror *mirror;
* Unmerged path fs/nfs/flexfilelayout/flexfilelayout.c
