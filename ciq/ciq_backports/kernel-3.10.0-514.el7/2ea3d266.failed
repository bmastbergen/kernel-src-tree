ACPI: Translate resource into master side address for bridge window resources

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [acpi] Translate resource into master side address for bridge window resources (Myron Stowe) [1344513]
Rebuild_FUZZ: 95.95%
commit-author Jiang Liu <jiang.liu@linux.intel.com>
commit 2ea3d266bab3b497238113b20136f7c3f69ad9c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2ea3d266.failed

Add translation_offset into the result address for bridge window
resources to form the master side address.

Currently acpi_dev_resource_{ext_}address_space() are only used for
devices instead of bridges, so it won't break current users. Later
it will be used to support PCI host bridge drivers.

	Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 2ea3d266bab3b497238113b20136f7c3f69ad9c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/resource.c
diff --cc drivers/acpi/resource.c
index 75d12a1b01ad,4dc8cfb2e94e..000000000000
--- a/drivers/acpi/resource.c
+++ b/drivers/acpi/resource.c
@@@ -171,45 -184,48 +171,64 @@@ bool acpi_dev_resource_io(struct acpi_r
  }
  EXPORT_SYMBOL_GPL(acpi_dev_resource_io);
  
 -static bool acpi_decode_space(struct resource_win *win,
 -			      struct acpi_resource_address *addr,
 -			      struct acpi_address64_attribute *attr)
 +/**
 + * acpi_dev_resource_address_space - Extract ACPI address space information.
 + * @ares: Input ACPI resource object.
 + * @res: Output generic resource object.
 + *
 + * Check if the given ACPI resource object represents an address space resource
 + * and if that's the case, use the information in it to populate the generic
 + * resource object pointed to by @res.
 + */
 +bool acpi_dev_resource_address_space(struct acpi_resource *ares,
 +				     struct resource *res)
  {
 -	u8 iodec = attr->granularity == 0xfff ? ACPI_DECODE_10 : ACPI_DECODE_16;
 -	bool wp = addr->info.mem.write_protect;
 -	u64 len = attr->address_length;
 -	struct resource *res = &win->res;
 +	acpi_status status;
 +	struct acpi_resource_address64 addr;
 +	bool window;
 +	u64 len;
 +	u8 io_decode;
  
 -	/*
 -	 * Filter out invalid descriptor according to ACPI Spec 5.0, section
 -	 * 6.4.3.5 Address Space Resource Descriptors.
 -	 */
 -	if ((addr->min_address_fixed != addr->max_address_fixed && len) ||
 -	    (addr->min_address_fixed && addr->max_address_fixed && !len))
 -		pr_debug("ACPI: Invalid address space min_addr_fix %d, max_addr_fix %d, len %llx\n",
 -			 addr->min_address_fixed, addr->max_address_fixed, len);
 +	status = acpi_resource_to_address64(ares, &addr);
 +	if (ACPI_FAILURE(status))
 +		return false;
  
 -	res->start = attr->minimum;
 -	res->end = attr->maximum;
 +	res->start = addr.minimum;
 +	res->end = addr.maximum;
 +	window = addr.producer_consumer == ACPI_PRODUCER;
  
++<<<<<<< HEAD
 +	switch(addr.resource_type) {
++=======
+ 	/*
+ 	 * For bridges that translate addresses across the bridge,
+ 	 * translation_offset is the offset that must be added to the
+ 	 * address on the secondary side to obtain the address on the
+ 	 * primary side. Non-bridge devices must list 0 for all Address
+ 	 * Translation offset bits.
+ 	 */
+ 	if (addr->producer_consumer == ACPI_PRODUCER) {
+ 		res->start += attr->translation_offset;
+ 		res->end += attr->translation_offset;
+ 	} else if (attr->translation_offset) {
+ 		pr_debug("ACPI: translation_offset(%lld) is invalid for non-bridge device.\n",
+ 			 attr->translation_offset);
+ 	}
+ 
+ 	switch (addr->resource_type) {
++>>>>>>> 2ea3d266bab3 (ACPI: Translate resource into master side address for bridge window resources)
  	case ACPI_MEMORY_RANGE:
 -		acpi_dev_memresource_flags(res, len, wp);
 +		len = addr.maximum - addr.minimum + 1;
 +		res->flags = acpi_dev_memresource_flags(len,
 +						addr.info.mem.write_protect,
 +						window);
  		break;
  	case ACPI_IO_RANGE:
 -		acpi_dev_ioresource_flags(res, len, iodec);
 +		io_decode = addr.granularity == 0xfff ?
 +				ACPI_DECODE_10 : ACPI_DECODE_16;
 +		res->flags = acpi_dev_ioresource_flags(addr.minimum,
 +						       addr.maximum,
 +						       io_decode, window);
  		break;
  	case ACPI_BUS_NUMBER_RANGE:
  		res->flags = IORESOURCE_BUS;
* Unmerged path drivers/acpi/resource.c
