KVM: VMX: avoid guest hang on invalid invvpid instruction

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit f6870ee9e53430f2a318ccf0dd5e66bb46194e43
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f6870ee9.failed

A guest executing an invalid invvpid instruction would hang
because the instruction pointer was not updated.

	Reported-by: jmontleo@redhat.com
	Tested-by: jmontleo@redhat.com
	Cc: stable@vger.kernel.org
Fixes: 99b83ac893b84ed1a62ad6d1f2b6cc32026b9e85
	Reviewed-by: David Matlack <dmatlack@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit f6870ee9e53430f2a318ccf0dd5e66bb46194e43)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index a7d76dce5145,0ce009cc23f1..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -6982,7 -7433,59 +6982,63 @@@ static int handle_invept(struct kvm_vcp
  
  static int handle_invvpid(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	kvm_queue_exception(vcpu, UD_VECTOR);
++=======
+ 	struct vcpu_vmx *vmx = to_vmx(vcpu);
+ 	u32 vmx_instruction_info;
+ 	unsigned long type, types;
+ 	gva_t gva;
+ 	struct x86_exception e;
+ 	int vpid;
+ 
+ 	if (!(vmx->nested.nested_vmx_secondary_ctls_high &
+ 	      SECONDARY_EXEC_ENABLE_VPID) ||
+ 			!(vmx->nested.nested_vmx_vpid_caps & VMX_VPID_INVVPID_BIT)) {
+ 		kvm_queue_exception(vcpu, UD_VECTOR);
+ 		return 1;
+ 	}
+ 
+ 	if (!nested_vmx_check_permission(vcpu))
+ 		return 1;
+ 
+ 	vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);
+ 	type = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);
+ 
+ 	types = (vmx->nested.nested_vmx_vpid_caps >> 8) & 0x7;
+ 
+ 	if (!(types & (1UL << type))) {
+ 		nested_vmx_failValid(vcpu,
+ 			VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);
+ 		skip_emulated_instruction(vcpu);
+ 		return 1;
+ 	}
+ 
+ 	/* according to the intel vmx instruction reference, the memory
+ 	 * operand is read even if it isn't needed (e.g., for type==global)
+ 	 */
+ 	if (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),
+ 			vmx_instruction_info, false, &gva))
+ 		return 1;
+ 	if (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &vpid,
+ 				sizeof(u32), &e)) {
+ 		kvm_inject_page_fault(vcpu, &e);
+ 		return 1;
+ 	}
+ 
+ 	switch (type) {
+ 	case VMX_VPID_EXTENT_ALL_CONTEXT:
+ 		__vmx_flush_tlb(vcpu, to_vmx(vcpu)->nested.vpid02);
+ 		nested_vmx_succeed(vcpu);
+ 		break;
+ 	default:
+ 		/* Trap single context invalidation invvpid calls */
+ 		BUG_ON(1);
+ 		break;
+ 	}
+ 
+ 	skip_emulated_instruction(vcpu);
++>>>>>>> f6870ee9e534 (KVM: VMX: avoid guest hang on invalid invvpid instruction)
  	return 1;
  }
  
* Unmerged path arch/x86/kvm/vmx.c
