dlm: sctp_accept_from_sock() can be static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author kbuild test robot <fengguang.wu@intel.com>
commit 18df8a87badac0ab05679df9bd44b5033e30d97c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/18df8a87.failed

	Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
	Signed-off-by: David Teigland <teigland@redhat.com>
(cherry picked from commit 18df8a87badac0ab05679df9bd44b5033e30d97c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dlm/lowcomms.c
diff --cc fs/dlm/lowcomms.c
index 3e5965dbf351,c6da6c33ae46..000000000000
--- a/fs/dlm/lowcomms.c
+++ b/fs/dlm/lowcomms.c
@@@ -1061,6 -760,120 +1061,123 @@@ accept_err
  	return result;
  }
  
++<<<<<<< HEAD
++=======
+ static int sctp_accept_from_sock(struct connection *con)
+ {
+ 	/* Check that the new node is in the lockspace */
+ 	struct sctp_prim prim;
+ 	int nodeid;
+ 	int prim_len, ret;
+ 	int addr_len;
+ 	struct connection *newcon;
+ 	struct connection *addcon;
+ 	struct socket *newsock;
+ 
+ 	mutex_lock(&connections_lock);
+ 	if (!dlm_allow_conn) {
+ 		mutex_unlock(&connections_lock);
+ 		return -1;
+ 	}
+ 	mutex_unlock(&connections_lock);
+ 
+ 	mutex_lock_nested(&con->sock_mutex, 0);
+ 
+ 	ret = kernel_accept(con->sock, &newsock, O_NONBLOCK);
+ 	if (ret < 0)
+ 		goto accept_err;
+ 
+ 	memset(&prim, 0, sizeof(struct sctp_prim));
+ 	prim_len = sizeof(struct sctp_prim);
+ 
+ 	ret = kernel_getsockopt(newsock, IPPROTO_SCTP, SCTP_PRIMARY_ADDR,
+ 				(char *)&prim, &prim_len);
+ 	if (ret < 0) {
+ 		log_print("getsockopt/sctp_primary_addr failed: %d", ret);
+ 		goto accept_err;
+ 	}
+ 
+ 	make_sockaddr(&prim.ssp_addr, 0, &addr_len);
+ 	if (addr_to_nodeid(&prim.ssp_addr, &nodeid)) {
+ 		unsigned char *b = (unsigned char *)&prim.ssp_addr;
+ 
+ 		log_print("reject connect from unknown addr");
+ 		print_hex_dump_bytes("ss: ", DUMP_PREFIX_NONE,
+ 				     b, sizeof(struct sockaddr_storage));
+ 		goto accept_err;
+ 	}
+ 
+ 	newcon = nodeid2con(nodeid, GFP_NOFS);
+ 	if (!newcon) {
+ 		ret = -ENOMEM;
+ 		goto accept_err;
+ 	}
+ 
+ 	mutex_lock_nested(&newcon->sock_mutex, 1);
+ 
+ 	if (newcon->sock) {
+ 		struct connection *othercon = newcon->othercon;
+ 
+ 		if (!othercon) {
+ 			othercon = kmem_cache_zalloc(con_cache, GFP_NOFS);
+ 			if (!othercon) {
+ 				log_print("failed to allocate incoming socket");
+ 				mutex_unlock(&newcon->sock_mutex);
+ 				ret = -ENOMEM;
+ 				goto accept_err;
+ 			}
+ 			othercon->nodeid = nodeid;
+ 			othercon->rx_action = receive_from_sock;
+ 			mutex_init(&othercon->sock_mutex);
+ 			INIT_WORK(&othercon->swork, process_send_sockets);
+ 			INIT_WORK(&othercon->rwork, process_recv_sockets);
+ 			set_bit(CF_IS_OTHERCON, &othercon->flags);
+ 		}
+ 		if (!othercon->sock) {
+ 			newcon->othercon = othercon;
+ 			othercon->sock = newsock;
+ 			newsock->sk->sk_user_data = othercon;
+ 			add_sock(newsock, othercon);
+ 			addcon = othercon;
+ 		} else {
+ 			printk("Extra connection from node %d attempted\n", nodeid);
+ 			ret = -EAGAIN;
+ 			mutex_unlock(&newcon->sock_mutex);
+ 			goto accept_err;
+ 		}
+ 	} else {
+ 		newsock->sk->sk_user_data = newcon;
+ 		newcon->rx_action = receive_from_sock;
+ 		add_sock(newsock, newcon);
+ 		addcon = newcon;
+ 	}
+ 
+ 	log_print("connected to %d", nodeid);
+ 
+ 	mutex_unlock(&newcon->sock_mutex);
+ 
+ 	/*
+ 	 * Add it to the active queue in case we got data
+ 	 * between processing the accept adding the socket
+ 	 * to the read_sockets list
+ 	 */
+ 	if (!test_and_set_bit(CF_READ_PENDING, &addcon->flags))
+ 		queue_work(recv_workqueue, &addcon->rwork);
+ 	mutex_unlock(&con->sock_mutex);
+ 
+ 	return 0;
+ 
+ accept_err:
+ 	mutex_unlock(&con->sock_mutex);
+ 	if (newsock)
+ 		sock_release(newsock);
+ 	if (ret != -EAGAIN)
+ 		log_print("error accepting connection from node: %d", ret);
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 18df8a87bada (dlm: sctp_accept_from_sock() can be static)
  static void free_entry(struct writequeue_entry *e)
  {
  	__free_page(e->page);
* Unmerged path fs/dlm/lowcomms.c
