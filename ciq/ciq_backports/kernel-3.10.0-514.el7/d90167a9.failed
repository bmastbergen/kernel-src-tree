x86/mce: Ensure offline CPUs don't participate in rendezvous process

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] mce: Ensure offline CPUs don't participate in rendezvous process (Prarit Bhargava) [1301710]
Rebuild_FUZZ: 96.97%
commit-author Ashok Raj <ashok.raj@intel.com>
commit d90167a941f62860f35eb960e1012aa2d30e7e94
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d90167a9.failed

Intel's MCA implementation broadcasts MCEs to all CPUs on the
node. This poses a problem for offlined CPUs which cannot
participate in the rendezvous process:

  Kernel panic - not syncing: Timeout: Not all CPUs entered broadcast exception handler
  Kernel Offset: disabled
  Rebooting in 100 seconds..

More specifically, Linux does a soft offline of a CPU when
writing a 0 to /sys/devices/system/cpu/cpuX/online, which
doesn't prevent the #MC exception from being broadcasted to that
CPU.

Ensure that offline CPUs don't participate in the MCE rendezvous
and clear the RIP valid status bit so that a second MCE won't
cause a shutdown.

Without the patch, mce_start() will increment mce_callin and
wait for all CPUs. Offlined CPUs should avoid participating in
the rendezvous process altogether.

	Signed-off-by: Ashok Raj <ashok.raj@intel.com>
[ Massage commit message. ]
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Tony Luck <tony.luck@intel.com>
	Cc: <stable@vger.kernel.org>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-edac <linux-edac@vger.kernel.org>
Link: http://lkml.kernel.org/r/1449742346-21470-2-git-send-email-bp@alien8.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit d90167a941f62860f35eb960e1012aa2d30e7e94)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/mcheck/mce.c
diff --cc arch/x86/kernel/cpu/mcheck/mce.c
index cedd2739979e,7e8a736d09db..000000000000
--- a/arch/x86/kernel/cpu/mcheck/mce.c
+++ b/arch/x86/kernel/cpu/mcheck/mce.c
@@@ -1052,6 -999,19 +1052,22 @@@ void do_machine_check(struct pt_regs *r
  	int flags = MF_ACTION_REQUIRED;
  	int lmce = 0;
  
++<<<<<<< HEAD
++=======
+ 	/* If this CPU is offline, just bail out. */
+ 	if (cpu_is_offline(smp_processor_id())) {
+ 		u64 mcgstatus;
+ 
+ 		mcgstatus = mce_rdmsrl(MSR_IA32_MCG_STATUS);
+ 		if (mcgstatus & MCG_STATUS_RIPV) {
+ 			mce_wrmsrl(MSR_IA32_MCG_STATUS, 0);
+ 			return;
+ 		}
+ 	}
+ 
+ 	ist_enter(regs);
+ 
++>>>>>>> d90167a941f6 (x86/mce: Ensure offline CPUs don't participate in rendezvous process)
  	this_cpu_inc(mce_exception_count);
  
  	if (!cfg->banks)
* Unmerged path arch/x86/kernel/cpu/mcheck/mce.c
