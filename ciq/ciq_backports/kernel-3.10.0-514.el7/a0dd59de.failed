btrfs: Fix calculate typo caused by ambiguous meaning of logic_end

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Zhao Lei <zhaolei@cn.fujitsu.com>
commit a0dd59de3c73fbb3b738eaf333732f2f27254a2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a0dd59de.failed

For example, in scrub_raid56_parity(), following lines are used
to judge is all data processed:
 place1: if (key.objectid > logic_end) ...
 place2: if (logic_start >= logic_end) ...
 ...
 (place2 is typo, is should be ">", it is copied from other
  place, where logic_end's meaning is different, long story...)

We can fix above typo directly, but the root reason is ambiguous
meaning of logic_end in scrub raid56 parity.

In other place, XXX_end is pointed to data which is not included,
and we need to process segment of [XXX_start, XXX_end).

But for scrub raid56 parity, logic_end is pointed to lattest data
need to process, and introduced many "+ 1" and "- 1" in code as
below:
 length = sparity->logic_end - sparity->logic_start + 1
 logic_end - logic_start + 1
 stripe_logical + increment - 1

This patch changed logic_end's meaning to make it in normal understanding
in raid56 parity functions and data struct alone with above bugfix.

	Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit a0dd59de3c73fbb3b738eaf333732f2f27254a2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/scrub.c
diff --cc fs/btrfs/scrub.c
index 7b28b8314430,185595a7be10..000000000000
--- a/fs/btrfs/scrub.c
+++ b/fs/btrfs/scrub.c
@@@ -2718,11 -2702,11 +2718,11 @@@ static void scrub_parity_check_and_repa
  			   sparity->nsectors))
  		goto out;
  
- 	length = sparity->logic_end - sparity->logic_start + 1;
+ 	length = sparity->logic_end - sparity->logic_start;
  	ret = btrfs_map_sblock(sctx->dev_root->fs_info, WRITE,
  			       sparity->logic_start,
 -			       &length, &bbio, 0, 1);
 -	if (ret || !bbio || !bbio->raid_map)
 +			       &length, &bbio, 0, &raid_map);
 +	if (ret || !bbio || !raid_map)
  		goto bbio_out;
  
  	bio = btrfs_io_bio_alloc(GFP_NOFS, 0);
@@@ -3169,6 -3131,24 +3169,27 @@@ static noinline_for_stack int scrub_str
  			scrub_blocked_if_needed(fs_info);
  		}
  
++<<<<<<< HEAD
++=======
+ 		/* for raid56, we skip parity stripe */
+ 		if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {
+ 			ret = get_raid56_logic_offset(physical, num, map,
+ 						      &logical,
+ 						      &stripe_logical);
+ 			logical += base;
+ 			if (ret) {
+ 				stripe_logical += base;
+ 				stripe_end = stripe_logical + increment;
+ 				ret = scrub_raid56_parity(sctx, map, scrub_dev,
+ 							  ppath, stripe_logical,
+ 							  stripe_end);
+ 				if (ret)
+ 					goto out;
+ 				goto skip;
+ 			}
+ 		}
+ 
++>>>>>>> a0dd59de3c73 (btrfs: Fix calculate typo caused by ambiguous meaning of logic_end)
  		if (btrfs_fs_incompat(fs_info, SKINNY_METADATA))
  			key.type = BTRFS_METADATA_ITEM_KEY;
  		else
* Unmerged path fs/btrfs/scrub.c
