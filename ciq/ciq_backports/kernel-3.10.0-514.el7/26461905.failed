netfilter: Allow calling into nat helper without skb_dst.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] netfilter: Allow calling into nat helper without skb_dst (Lance Richardson) [1297465]
Rebuild_FUZZ: 99.12%
commit-author Jarno Rajahalme <jarno@ovn.org>
commit 264619055bd52bc2278af848472176642d759874
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/26461905.failed

NAT checksum recalculation code assumes existence of skb_dst, which
becomes a problem for a later patch in the series ("openvswitch:
Interface with NAT.").  Simplify this by removing the check on
skb_dst, as the checksum will be dealt with later in the stack.

	Suggested-by: Pravin Shelar <pshelar@nicira.com>
	Signed-off-by: Jarno Rajahalme <jarno@ovn.org>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 264619055bd52bc2278af848472176642d759874)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
#	net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
diff --cc net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
index b550885b5986,f8aad03d674b..000000000000
--- a/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
@@@ -127,33 -127,21 +127,41 @@@ static void nf_nat_ipv4_csum_recalc(str
  				    u8 proto, void *data, __sum16 *check,
  				    int datalen, int oldlen)
  {
- 	const struct iphdr *iph = ip_hdr(skb);
- 	struct rtable *rt = skb_rtable(skb);
- 
  	if (skb->ip_summed != CHECKSUM_PARTIAL) {
++<<<<<<< HEAD
 +		if (!(rt->rt_flags & RTCF_LOCAL) &&
 +		    (!skb->dev || skb->dev->features & NETIF_F_V4_CSUM)) {
 +			skb->ip_summed = CHECKSUM_PARTIAL;
 +			skb->csum_start = skb_headroom(skb) +
 +					  skb_network_offset(skb) +
 +					  ip_hdrlen(skb);
 +			skb->csum_offset = (void *)check - data;
 +			*check = ~csum_tcpudp_magic(iph->saddr, iph->daddr,
 +						    datalen, proto, 0);
 +		} else {
 +			*check = 0;
 +			*check = csum_tcpudp_magic(iph->saddr, iph->daddr,
 +						   datalen, proto,
 +						   csum_partial(data, datalen,
 +								0));
 +			if (proto == IPPROTO_UDP && !*check)
 +				*check = CSUM_MANGLED_0;
 +		}
++=======
+ 		const struct iphdr *iph = ip_hdr(skb);
+ 
+ 		skb->ip_summed = CHECKSUM_PARTIAL;
+ 		skb->csum_start = skb_headroom(skb) + skb_network_offset(skb) +
+ 			ip_hdrlen(skb);
+ 		skb->csum_offset = (void *)check - data;
+ 		*check = ~csum_tcpudp_magic(iph->saddr, iph->daddr, datalen,
+ 					    proto, 0);
++>>>>>>> 264619055bd5 (netfilter: Allow calling into nat helper without skb_dst.)
  	} else
  		inet_proto_csum_replace2(check, skb,
 -					 htons(oldlen), htons(datalen), true);
 +					 htons(oldlen), htons(datalen), 1);
  }
  
 -#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  static int nf_nat_ipv4_nlattr_to_range(struct nlattr *tb[],
  				       struct nf_nat_range *range)
  {
diff --cc net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
index 807f34dfe7f5,e0be97e636a4..000000000000
--- a/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
+++ b/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
@@@ -131,33 -131,21 +131,41 @@@ static void nf_nat_ipv6_csum_recalc(str
  				    u8 proto, void *data, __sum16 *check,
  				    int datalen, int oldlen)
  {
- 	const struct ipv6hdr *ipv6h = ipv6_hdr(skb);
- 	struct rt6_info *rt = (struct rt6_info *)skb_dst(skb);
- 
  	if (skb->ip_summed != CHECKSUM_PARTIAL) {
++<<<<<<< HEAD
 +		if (!(rt->rt6i_flags & RTF_LOCAL) &&
 +		    (!skb->dev || skb->dev->features & NETIF_F_V6_CSUM)) {
 +			skb->ip_summed = CHECKSUM_PARTIAL;
 +			skb->csum_start = skb_headroom(skb) +
 +					  skb_network_offset(skb) +
 +					  (data - (void *)skb->data);
 +			skb->csum_offset = (void *)check - data;
 +			*check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr,
 +						  datalen, proto, 0);
 +		} else {
 +			*check = 0;
 +			*check = csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr,
 +						 datalen, proto,
 +						 csum_partial(data, datalen,
 +							      0));
 +			if (proto == IPPROTO_UDP && !*check)
 +				*check = CSUM_MANGLED_0;
 +		}
++=======
+ 		const struct ipv6hdr *ipv6h = ipv6_hdr(skb);
+ 
+ 		skb->ip_summed = CHECKSUM_PARTIAL;
+ 		skb->csum_start = skb_headroom(skb) + skb_network_offset(skb) +
+ 			(data - (void *)skb->data);
+ 		skb->csum_offset = (void *)check - data;
+ 		*check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr,
+ 					  datalen, proto, 0);
++>>>>>>> 264619055bd5 (netfilter: Allow calling into nat helper without skb_dst.)
  	} else
  		inet_proto_csum_replace2(check, skb,
 -					 htons(oldlen), htons(datalen), true);
 +					 htons(oldlen), htons(datalen), 1);
  }
  
 -#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  static int nf_nat_ipv6_nlattr_to_range(struct nlattr *tb[],
  				       struct nf_nat_range *range)
  {
* Unmerged path net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
* Unmerged path net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
