netfilter: Convert nft_hash to inlined rhashtable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit fa3773211eb61f2a08ffc399a98af53594ba1509
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fa377321.failed

This patch converts nft_hash to the inlined rhashtable interface.

This patch also replaces the call to rhashtable_lookup_compare with
a straight rhashtable_lookup_fast because it's simply doing a memcmp
(in fact nft_hash_lookup already uses memcmp instead of nft_data_cmp).

Furthermore, the compare function is only meant to compare, it is not
supposed to have side-effects.  The current side-effect code can
simply be moved into the nft_hash_get.

	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fa3773211eb61f2a08ffc399a98af53594ba1509)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_hash.c
diff --cc net/netfilter/nft_hash.c
index f14a5e14123a,4585c5724391..000000000000
--- a/net/netfilter/nft_hash.c
+++ b/net/netfilter/nft_hash.c
@@@ -33,10 -35,10 +35,10 @@@ static bool nft_hash_lookup(const struc
  			    const struct nft_data *key,
  			    struct nft_data *data)
  {
 -	struct rhashtable *priv = nft_set_priv(set);
 +	const struct rhashtable *priv = nft_set_priv(set);
  	const struct nft_hash_elem *he;
  
- 	he = rhashtable_lookup(priv, key);
+ 	he = rhashtable_lookup_fast(priv, key, nft_hash_params);
  	if (he && set->flags & NFT_SET_MAP)
  		nft_data_copy(data, he->data);
  
@@@ -89,41 -94,21 +94,29 @@@ static void nft_hash_remove(const struc
  	kfree(elem->cookie);
  }
  
- struct nft_compare_arg {
- 	const struct nft_set *set;
- 	struct nft_set_elem *elem;
- };
- 
- static bool nft_hash_compare(void *ptr, void *arg)
- {
- 	struct nft_hash_elem *he = ptr;
- 	struct nft_compare_arg *x = arg;
- 
- 	if (!nft_data_cmp(&he->key, &x->elem->key, x->set->klen)) {
- 		x->elem->cookie = he;
- 		x->elem->flags = 0;
- 		if (x->set->flags & NFT_SET_MAP)
- 			nft_data_copy(&x->elem->data, he->data);
- 
- 		return true;
- 	}
- 
- 	return false;
- }
- 
  static int nft_hash_get(const struct nft_set *set, struct nft_set_elem *elem)
  {
++<<<<<<< HEAD
 +	const struct rhashtable *priv = nft_set_priv(set);
 +	struct nft_compare_arg arg = {
 +		.set = set,
 +		.elem = elem,
 +	};
++=======
+ 	struct rhashtable *priv = nft_set_priv(set);
+ 	struct nft_hash_elem *he;
++>>>>>>> fa3773211eb6 (netfilter: Convert nft_hash to inlined rhashtable)
  
- 	if (rhashtable_lookup_compare(priv, &elem->key,
- 				      &nft_hash_compare, &arg))
- 		return 0;
+ 	he = rhashtable_lookup_fast(priv, &elem->key, nft_hash_params);
+ 	if (!he)
+ 		return -ENOENT;
  
- 	return -ENOENT;
+ 	elem->cookie = he;
+ 	elem->flags = 0;
+ 	if (set->flags & NFT_SET_MAP)
+ 		nft_data_copy(&elem->data, he->data);
+ 
+ 	return 0;
  }
  
  static void nft_hash_walk(const struct nft_ctx *ctx, const struct nft_set *set,
@@@ -162,26 -166,21 +155,41 @@@ static unsigned int nft_hash_privsize(c
  	return sizeof(struct rhashtable);
  }
  
++<<<<<<< HEAD
 +static int lockdep_nfnl_lock_is_held(void)
 +{
 +	return lockdep_nfnl_is_held(NFNL_SUBSYS_NFTABLES);
 +}
++=======
+ static const struct rhashtable_params nft_hash_params = {
+ 	.head_offset = offsetof(struct nft_hash_elem, node),
+ 	.key_offset = offsetof(struct nft_hash_elem, key),
+ 	.hashfn = jhash,
+ };
++>>>>>>> fa3773211eb6 (netfilter: Convert nft_hash to inlined rhashtable)
  
  static int nft_hash_init(const struct nft_set *set,
  			 const struct nft_set_desc *desc,
  			 const struct nlattr * const tb[])
  {
  	struct rhashtable *priv = nft_set_priv(set);
++<<<<<<< HEAD
 +	struct rhashtable_params params = {
 +		.nelem_hint = desc->size ? : NFT_HASH_ELEMENT_HINT,
 +		.head_offset = offsetof(struct nft_hash_elem, node),
 +		.key_offset = offsetof(struct nft_hash_elem, key),
 +		.key_len = set->klen,
 +		.hashfn = jhash,
 +		.grow_decision = rht_grow_above_75,
 +		.shrink_decision = rht_shrink_below_30,
 +		.mutex_is_held = lockdep_nfnl_lock_is_held,
 +	};
++=======
+ 	struct rhashtable_params params = nft_hash_params;
+ 
+ 	params.nelem_hint = desc->size ?: NFT_HASH_ELEMENT_HINT;
+ 	params.key_len = set->klen;
++>>>>>>> fa3773211eb6 (netfilter: Convert nft_hash to inlined rhashtable)
  
  	return rhashtable_init(priv, &params);
  }
* Unmerged path net/netfilter/nft_hash.c
