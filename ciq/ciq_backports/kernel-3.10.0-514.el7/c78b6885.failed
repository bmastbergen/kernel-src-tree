ACPI: Set flag IORESOURCE_UNSET for unassigned resources

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [acpi] Set flag IORESOURCE_UNSET for unassigned resources (Myron Stowe) [1344513]
Rebuild_FUZZ: 94.34%
commit-author Jiang Liu <jiang.liu@linux.intel.com>
commit c78b688561e684098a11012ca21a6d578f9dfb67
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c78b6885.failed

Also set flag IORESOURCE_UNSET for unassigned resource in addition to
IORESOURCE_DISABLED to mark resource as unassigned.

	Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit c78b688561e684098a11012ca21a6d578f9dfb67)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/resource.c
diff --cc drivers/acpi/resource.c
index 75d12a1b01ad,5bf73a9f26d9..000000000000
--- a/drivers/acpi/resource.c
+++ b/drivers/acpi/resource.c
@@@ -34,21 -34,34 +34,45 @@@
  #define valid_IRQ(i) (true)
  #endif
  
 -static bool acpi_dev_resource_len_valid(u64 start, u64 end, u64 len, bool io)
 +static unsigned long acpi_dev_memresource_flags(u64 len, u8 write_protect,
 +						bool window)
  {
 -	u64 reslen = end - start + 1;
 +	unsigned long flags = IORESOURCE_MEM;
  
++<<<<<<< HEAD
 +	if (len == 0)
 +		flags |= IORESOURCE_DISABLED;
++=======
+ 	/*
+ 	 * CHECKME: len might be required to check versus a minimum
+ 	 * length as well. 1 for io is fine, but for memory it does
+ 	 * not make any sense at all.
+ 	 */
+ 	if (len && reslen && reslen == len && start <= end)
+ 		return true;
+ 
+ 	pr_info("ACPI: invalid or unassigned resource %s [%016llx - %016llx] length [%016llx]\n",
+ 		io ? "io" : "mem", start, end, len);
+ 
+ 	return false;
+ }
+ 
+ static void acpi_dev_memresource_flags(struct resource *res, u64 len,
+ 				       u8 write_protect)
+ {
+ 	res->flags = IORESOURCE_MEM;
+ 
+ 	if (!acpi_dev_resource_len_valid(res->start, res->end, len, false))
+ 		res->flags |= IORESOURCE_DISABLED | IORESOURCE_UNSET;
++>>>>>>> c78b688561e6 (ACPI: Set flag IORESOURCE_UNSET for unassigned resources)
  
  	if (write_protect == ACPI_READ_WRITE_MEMORY)
 -		res->flags |= IORESOURCE_MEM_WRITEABLE;
 +		flags |= IORESOURCE_MEM_WRITEABLE;
 +
 +	if (window)
 +		flags |= IORESOURCE_WINDOW;
 +
 +	return flags;
  }
  
  static void acpi_dev_get_memresource(struct resource *res, u64 start, u64 len,
@@@ -106,21 -120,19 +130,31 @@@ bool acpi_dev_resource_memory(struct ac
  }
  EXPORT_SYMBOL_GPL(acpi_dev_resource_memory);
  
 -static void acpi_dev_ioresource_flags(struct resource *res, u64 len,
 -				      u8 io_decode)
 +static unsigned int acpi_dev_ioresource_flags(u64 start, u64 end, u8 io_decode,
 +					      bool window)
  {
++<<<<<<< HEAD
 +	int flags = IORESOURCE_IO;
++=======
+ 	res->flags = IORESOURCE_IO;
+ 
+ 	if (!acpi_dev_resource_len_valid(res->start, res->end, len, true))
+ 		res->flags |= IORESOURCE_DISABLED | IORESOURCE_UNSET;
+ 
+ 	if (res->end >= 0x10003)
+ 		res->flags |= IORESOURCE_DISABLED | IORESOURCE_UNSET;
++>>>>>>> c78b688561e6 (ACPI: Set flag IORESOURCE_UNSET for unassigned resources)
  
  	if (io_decode == ACPI_DECODE_16)
 -		res->flags |= IORESOURCE_IO_16BIT_ADDR;
 +		flags |= IORESOURCE_IO_16BIT_ADDR;
 +
 +	if (start > end || end >= 0x10003)
 +		flags |= IORESOURCE_DISABLED;
 +
 +	if (window)
 +		flags |= IORESOURCE_WINDOW;
 +
 +	return flags;
  }
  
  static void acpi_dev_get_ioresource(struct resource *res, u64 start, u64 len,
* Unmerged path drivers/acpi/resource.c
