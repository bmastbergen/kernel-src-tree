staging/rdma/hfi1: Fix code alignment

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Fix code alignment (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 87.88%
commit-author Jubin John <jubin.john@intel.com>
commit 17fb4f2923d7fc7ee778dedc0aa60ab6f402f56c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/17fb4f29.failed

Fix code alignment to fix checkpatch check:
CHECK: Alignment should match open parenthesis

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Jubin John <jubin.john@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 17fb4f2923d7fc7ee778dedc0aa60ab6f402f56c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/chip.c
#	drivers/staging/hfi1/debugfs.c
#	drivers/staging/hfi1/driver.c
#	drivers/staging/hfi1/file_ops.c
#	drivers/staging/hfi1/firmware.c
#	drivers/staging/hfi1/mad.c
#	drivers/staging/hfi1/pcie.c
#	drivers/staging/hfi1/rc.c
#	drivers/staging/hfi1/sdma.c
#	drivers/staging/hfi1/trace.c
#	drivers/staging/hfi1/trace.h
#	drivers/staging/hfi1/ud.c
diff --cc drivers/staging/hfi1/chip.c
index 5343ebf88f1b,ce61883d146c..000000000000
--- a/drivers/staging/hfi1/chip.c
+++ b/drivers/staging/hfi1/chip.c
@@@ -5417,14 -5429,14 +5418,14 @@@ static void update_rcverr_timer(unsigne
  	u32 cur_ovfl_cnt = read_dev_cntr(dd, C_RCV_OVF, CNTR_INVALID_VL);
  
  	if (dd->rcv_ovfl_cnt < cur_ovfl_cnt &&
- 		ppd->port_error_action & OPA_PI_MASK_EX_BUFFER_OVERRUN) {
+ 	    ppd->port_error_action & OPA_PI_MASK_EX_BUFFER_OVERRUN) {
  		dd_dev_info(dd, "%s: PortErrorAction bounce\n", __func__);
- 		set_link_down_reason(ppd,
- 		  OPA_LINKDOWN_REASON_EXCESSIVE_BUFFER_OVERRUN, 0,
- 			OPA_LINKDOWN_REASON_EXCESSIVE_BUFFER_OVERRUN);
+ 		set_link_down_reason(
+ 		ppd, OPA_LINKDOWN_REASON_EXCESSIVE_BUFFER_OVERRUN, 0,
+ 		OPA_LINKDOWN_REASON_EXCESSIVE_BUFFER_OVERRUN);
  		queue_work(ppd->hfi1_wq, &ppd->link_bounce_work);
  	}
 -	dd->rcv_ovfl_cnt = (u32)cur_ovfl_cnt;
 +	dd->rcv_ovfl_cnt = (u32) cur_ovfl_cnt;
  
  	mod_timer(&dd->rcverr_timer, jiffies + HZ * RCVERR_CHECK_TIME);
  }
@@@ -5919,9 -5933,8 +5922,9 @@@ static void handle_qsfp_int(struct hfi1
  	u64 qsfp_int_mgmt = (u64)(QSFP_HFI0_INT_N | QSFP_HFI0_MODPRST_N);
  
  	if (reg & QSFP_HFI0_MODPRST_N) {
 +
  		dd_dev_info(dd, "%s: ModPresent triggered QSFP interrupt\n",
- 				__func__);
+ 			    __func__);
  
  		if (!qsfp_mod_present(ppd)) {
  			ppd->driver_link_ready = 0;
@@@ -5936,14 -5949,13 +5939,21 @@@
  			 * an interrupt when a cable is inserted
  			 */
  			ppd->qsfp_info.cache_valid = 0;
 -			ppd->qsfp_info.reset_needed = 0;
 -			ppd->qsfp_info.limiting_active = 0;
 +			ppd->qsfp_info.qsfp_interrupt_functional = 0;
  			spin_unlock_irqrestore(&ppd->qsfp_info.qsfp_lock,
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +						flags);
 +			write_csr(dd,
 +					dd->hfi1_id ?
 +						ASIC_QSFP2_INVERT :
 +						ASIC_QSFP1_INVERT,
 +				qsfp_int_mgmt);
++=======
+ 					       flags);
+ 			/* Invert the ModPresent pin now to detect plug-in */
+ 			write_csr(dd, dd->hfi1_id ? ASIC_QSFP2_INVERT :
+ 				  ASIC_QSFP1_INVERT, qsfp_int_mgmt);
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/chip.c
  
  			if ((ppd->offline_disabled_reason >
  			  HFI1_ODR_MASK(
@@@ -5968,24 -5980,26 +5978,24 @@@
  			ppd->qsfp_info.cache_valid = 0;
  			ppd->qsfp_info.cache_refresh_required = 1;
  			spin_unlock_irqrestore(&ppd->qsfp_info.qsfp_lock,
- 						flags);
+ 					       flags);
  
 -			/*
 -			 * Stop inversion of ModPresent pin to detect
 -			 * removal of the cable
 -			 */
  			qsfp_int_mgmt &= ~(u64)QSFP_HFI0_MODPRST_N;
 -			write_csr(dd, dd->hfi1_id ? ASIC_QSFP2_INVERT :
 -				  ASIC_QSFP1_INVERT, qsfp_int_mgmt);
 -
 -			ppd->offline_disabled_reason =
 -				HFI1_ODR_MASK(OPA_LINKDOWN_REASON_TRANSIENT);
 +			write_csr(dd,
 +					dd->hfi1_id ?
 +						ASIC_QSFP2_INVERT :
 +						ASIC_QSFP1_INVERT,
 +				qsfp_int_mgmt);
  		}
  	}
  
  	if (reg & QSFP_HFI0_INT_N) {
 +
  		dd_dev_info(dd, "%s: IntN triggered QSFP interrupt\n",
- 				__func__);
+ 			    __func__);
  		spin_lock_irqsave(&ppd->qsfp_info.qsfp_lock, flags);
  		ppd->qsfp_info.check_interrupt_flags = 1;
 +		ppd->qsfp_info.qsfp_interrupt_functional = 1;
  		spin_unlock_irqrestore(&ppd->qsfp_info.qsfp_lock, flags);
  	}
  
@@@ -6348,11 -6363,10 +6359,18 @@@ static void lcb_shutdown(struct hfi1_de
  	/* set dcc reset csr: DCC_CFG_RESET.{reset_lcb,reset_rx_fpe} = 1 */
  	dd->lcb_err_en = read_csr(dd, DC_LCB_ERR_EN);
  	reg = read_csr(dd, DCC_CFG_RESET);
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +	write_csr(dd, DCC_CFG_RESET,
 +		reg
 +		| (1ull << DCC_CFG_RESET_RESET_LCB_SHIFT)
 +		| (1ull << DCC_CFG_RESET_RESET_RX_FPE_SHIFT));
 +	(void) read_csr(dd, DCC_CFG_RESET); /* make sure the write completed */
++=======
+ 	write_csr(dd, DCC_CFG_RESET, reg |
+ 		  (1ull << DCC_CFG_RESET_RESET_LCB_SHIFT) |
+ 		  (1ull << DCC_CFG_RESET_RESET_RX_FPE_SHIFT));
+ 	(void)read_csr(dd, DCC_CFG_RESET); /* make sure the write completed */
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/chip.c
  	if (!abort) {
  		udelay(1);    /* must hold for the longer of 16cclks or 20ns */
  		write_csr(dd, DCC_CFG_RESET, reg);
@@@ -6794,11 -6813,12 +6811,11 @@@ void handle_link_up(struct work_struct 
  	if ((ppd->link_speed_active & ppd->link_speed_enabled) == 0) {
  		/* oops - current speed is not enabled, bounce */
  		dd_dev_err(ppd->dd,
- 			"Link speed active 0x%x is outside enabled 0x%x, downing link\n",
- 			ppd->link_speed_active, ppd->link_speed_enabled);
+ 			   "Link speed active 0x%x is outside enabled 0x%x, downing link\n",
+ 			   ppd->link_speed_active, ppd->link_speed_enabled);
  		set_link_down_reason(ppd, OPA_LINKDOWN_REASON_SPEED_POLICY, 0,
- 			OPA_LINKDOWN_REASON_SPEED_POLICY);
+ 				     OPA_LINKDOWN_REASON_SPEED_POLICY);
  		set_link_state(ppd, HLS_DN_OFFLINE);
 -		tune_serdes(ppd);
  		start_link(ppd);
  	}
  }
@@@ -7339,28 -7364,27 +7348,33 @@@ retry
  
  		/* bounce if not at starting active width */
  		if ((ppd->link_width_active !=
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +					ppd->link_width_downgrade_tx_active)
 +				|| (ppd->link_width_active !=
 +					ppd->link_width_downgrade_rx_active)) {
++=======
+ 		     ppd->link_width_downgrade_tx_active) ||
+ 		    (ppd->link_width_active !=
+ 		     ppd->link_width_downgrade_rx_active)) {
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/chip.c
  			dd_dev_err(ppd->dd,
- 				"Link downgrade is disabled and link has downgraded, downing link\n");
+ 				   "Link downgrade is disabled and link has downgraded, downing link\n");
  			dd_dev_err(ppd->dd,
- 				"  original 0x%x, tx active 0x%x, rx active 0x%x\n",
- 				ppd->link_width_active,
- 				ppd->link_width_downgrade_tx_active,
- 				ppd->link_width_downgrade_rx_active);
+ 				   "  original 0x%x, tx active 0x%x, rx active 0x%x\n",
+ 				   ppd->link_width_active,
+ 				   ppd->link_width_downgrade_tx_active,
+ 				   ppd->link_width_downgrade_rx_active);
  			do_bounce = 1;
  		}
 -	} else if ((lwde & ppd->link_width_downgrade_tx_active) == 0 ||
 -		   (lwde & ppd->link_width_downgrade_rx_active) == 0) {
 +	} else if ((lwde & ppd->link_width_downgrade_tx_active) == 0
 +		|| (lwde & ppd->link_width_downgrade_rx_active) == 0) {
  		/* Tx or Rx is outside the enabled policy */
  		dd_dev_err(ppd->dd,
- 			"Link is outside of downgrade allowed, downing link\n");
+ 			   "Link is outside of downgrade allowed, downing link\n");
  		dd_dev_err(ppd->dd,
- 			"  enabled 0x%x, tx active 0x%x, rx active 0x%x\n",
- 			lwde,
- 			ppd->link_width_downgrade_tx_active,
- 			ppd->link_width_downgrade_rx_active);
+ 			   "  enabled 0x%x, tx active 0x%x, rx active 0x%x\n",
+ 			   lwde, ppd->link_width_downgrade_tx_active,
+ 			   ppd->link_width_downgrade_rx_active);
  		do_bounce = 1;
  	}
  
@@@ -7369,8 -7393,9 +7383,8 @@@ done
  
  	if (do_bounce) {
  		set_link_down_reason(ppd, OPA_LINKDOWN_REASON_WIDTH_POLICY, 0,
- 		  OPA_LINKDOWN_REASON_WIDTH_POLICY);
+ 				     OPA_LINKDOWN_REASON_WIDTH_POLICY);
  		set_link_state(ppd, HLS_DN_OFFLINE);
 -		tune_serdes(ppd);
  		start_link(ppd);
  	}
  }
@@@ -7544,13 -7572,15 +7561,13 @@@ static void handle_8051_interrupt(struc
  	}
  
  	if (queue_link_down) {
 -		/*
 -		 * if the link is already going down or disabled, do not
 -		 * queue another
 -		 */
 -		if ((ppd->host_link_state &
 -		    (HLS_GOING_OFFLINE | HLS_LINK_COOLDOWN)) ||
 -		    ppd->link_enabled == 0) {
 +		/* if the link is already going down or disabled, do not
 +		 * queue another */
 +		if ((ppd->host_link_state
 +				    & (HLS_GOING_OFFLINE|HLS_LINK_COOLDOWN))
 +				|| ppd->link_enabled == 0) {
  			dd_dev_info(dd, "%s: not queuing link down\n",
- 				__func__);
+ 				    __func__);
  		} else {
  			queue_work(ppd->hfi1_wq, &ppd->link_down_work);
  		}
@@@ -7965,7 -7999,7 +7982,11 @@@ static irqreturn_t general_interrupt(in
  
  	/* phase 2: call the appropriate handler */
  	for_each_set_bit(bit, (unsigned long *)&regs[0],
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +						CCE_NUM_INT_CSRS*64) {
++=======
+ 			 CCE_NUM_INT_CSRS * 64) {
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/chip.c
  		is_interrupt(dd, bit);
  	}
  
@@@ -7988,13 -8022,13 +8009,23 @@@ static irqreturn_t sdma_interrupt(int i
  
  	/* This read_csr is really bad in the hot path */
  	status = read_csr(dd,
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +			CCE_INT_STATUS + (8*(IS_SDMA_START/64)))
 +			& sde->imask;
 +	if (likely(status)) {
 +		/* clear the interrupt(s) */
 +		write_csr(dd,
 +			CCE_INT_CLEAR + (8*(IS_SDMA_START/64)),
 +			status);
++=======
+ 			  CCE_INT_STATUS + (8 * (IS_SDMA_START / 64)))
+ 			  & sde->imask;
+ 	if (likely(status)) {
+ 		/* clear the interrupt(s) */
+ 		write_csr(dd,
+ 			  CCE_INT_CLEAR + (8 * (IS_SDMA_START / 64)),
+ 			  status);
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/chip.c
  
  		/* handle the interrupt(s) */
  		sdma_engine_interrupt(sde, status);
@@@ -9038,27 -9110,34 +9067,49 @@@ static void reset_qsfp(struct hfi1_ppor
  	struct hfi1_devdata *dd = ppd->dd;
  	u64 mask, qsfp_mask;
  
 -	/* Disable INT_N from triggering QSFP interrupts */
 -	set_qsfp_int_n(ppd, 0);
 -
 -	/* Reset the QSFP */
  	mask = (u64)QSFP_HFI0_RESET_N;
 -	qsfp_mask = read_csr(dd, dd->hfi1_id ? ASIC_QSFP2_OE : ASIC_QSFP1_OE);
 +	qsfp_mask = read_csr(dd,
 +		dd->hfi1_id ? ASIC_QSFP2_OE : ASIC_QSFP1_OE);
  	qsfp_mask |= mask;
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +	write_csr(dd,
 +		dd->hfi1_id ? ASIC_QSFP2_OE : ASIC_QSFP1_OE,
 +		qsfp_mask);
 +
 +	qsfp_mask = read_csr(dd,
 +		dd->hfi1_id ? ASIC_QSFP2_OUT : ASIC_QSFP1_OUT);
 +	qsfp_mask &= ~mask;
 +	write_csr(dd,
 +		dd->hfi1_id ? ASIC_QSFP2_OUT : ASIC_QSFP1_OUT,
 +		qsfp_mask);
++=======
+ 	write_csr(dd, dd->hfi1_id ? ASIC_QSFP2_OE : ASIC_QSFP1_OE, qsfp_mask);
+ 
+ 	qsfp_mask = read_csr(dd,
+ 			     dd->hfi1_id ? ASIC_QSFP2_OUT : ASIC_QSFP1_OUT);
+ 	qsfp_mask &= ~mask;
+ 	write_csr(dd,
+ 		  dd->hfi1_id ? ASIC_QSFP2_OUT : ASIC_QSFP1_OUT, qsfp_mask);
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/chip.c
  
  	udelay(10);
  
  	qsfp_mask |= mask;
  	write_csr(dd,
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +		dd->hfi1_id ? ASIC_QSFP2_OUT : ASIC_QSFP1_OUT,
 +		qsfp_mask);
++=======
+ 		  dd->hfi1_id ? ASIC_QSFP2_OUT : ASIC_QSFP1_OUT, qsfp_mask);
+ 
+ 	wait_for_qsfp_init(ppd);
+ 
+ 	/*
+ 	 * Allow INT_N to trigger the QSFP interrupt to watch
+ 	 * for alarms and warnings
+ 	 */
+ 	set_qsfp_int_n(ppd, 1);
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/chip.c
  }
  
  static int handle_qsfp_error_conditions(struct hfi1_pportdata *ppd,
@@@ -9242,29 -9277,17 +9277,33 @@@ static void qsfp_event(struct work_stru
  		if (qsfp_read(ppd, dd->hfi1_id, 6,
  			      &qsfp_interrupt_status[0], 16) != 16) {
  			dd_dev_info(dd,
- 				"%s: Failed to read status of QSFP module\n",
- 				__func__);
+ 				    "%s: Failed to read status of QSFP module\n",
+ 				    __func__);
  		} else {
  			unsigned long flags;
 +			u8 data_status;
  
 -			handle_qsfp_error_conditions(
 -					ppd, qsfp_interrupt_status);
  			spin_lock_irqsave(&ppd->qsfp_info.qsfp_lock, flags);
  			ppd->qsfp_info.check_interrupt_flags = 0;
  			spin_unlock_irqrestore(&ppd->qsfp_info.qsfp_lock,
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +								flags);
 +
 +			if (qsfp_read(ppd, dd->hfi1_id, 2, &data_status, 1)
 +				 != 1) {
 +				dd_dev_info(dd,
 +				"%s: Failed to read status of QSFP module\n",
 +					__func__);
 +			}
 +			if (!(data_status & QSFP_DATA_NOT_READY)) {
 +				do_pre_lni_host_behaviors(ppd);
 +				start_link(ppd);
 +			} else
 +				handle_qsfp_error_conditions(ppd,
 +						qsfp_interrupt_status);
++=======
+ 					       flags);
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/chip.c
  		}
  	}
  }
@@@ -9390,8 -9406,10 +9429,8 @@@ void hfi1_quiet_serdes(struct hfi1_ppor
  	ppd->driver_link_ready = 0;
  	ppd->link_enabled = 0;
  
 -	ppd->offline_disabled_reason =
 -			HFI1_ODR_MASK(OPA_LINKDOWN_REASON_SMA_DISABLED);
  	set_link_down_reason(ppd, OPA_LINKDOWN_REASON_SMA_DISABLED, 0,
- 	  OPA_LINKDOWN_REASON_SMA_DISABLED);
+ 			     OPA_LINKDOWN_REASON_SMA_DISABLED);
  	set_link_state(ppd, HLS_DN_OFFLINE);
  
  	/* disable the port */
@@@ -9989,14 -10016,14 +10031,14 @@@ int set_link_state(struct hfi1_pportdat
  		state = dd->link_default;
  
  	/* interpret poll -> poll as a link bounce */
 -	poll_bounce = ppd->host_link_state == HLS_DN_POLL &&
 -		      state == HLS_DN_POLL;
 +	poll_bounce = ppd->host_link_state == HLS_DN_POLL
 +				&& state == HLS_DN_POLL;
  
  	dd_dev_info(dd, "%s: current %s, new %s %s%s\n", __func__,
- 		link_state_name(ppd->host_link_state),
- 		link_state_name(orig_new_state),
- 		poll_bounce ? "(bounce) " : "",
- 		link_state_reason_name(ppd, state));
+ 		    link_state_name(ppd->host_link_state),
+ 		    link_state_name(orig_new_state),
+ 		    poll_bounce ? "(bounce) " : "",
+ 		    link_state_reason_name(ppd, state));
  
  	was_up = !!(ppd->host_link_state & HLS_UP);
  
@@@ -10084,10 -10111,9 +10126,10 @@@
  			/* logical state didn't change, stay at armed */
  			ppd->host_link_state = HLS_UP_ARMED;
  			dd_dev_err(dd,
- 				"%s: logical state did not change to ACTIVE\n",
- 				__func__);
+ 				   "%s: logical state did not change to ACTIVE\n",
+ 				   __func__);
  		} else {
 +
  			/* tell all engines to go running */
  			sdma_all_running(dd);
  
@@@ -11102,10 -11131,13 +11146,11 @@@ static void adjust_rcv_timeout(struct h
  	}
  
  	rcd->rcvavail_timeout = timeout;
 -	/*
 -	 * timeout cannot be larger than rcv_intr_timeout_csr which has already
 -	 * been verified to be in range
 -	 */
 +	/* timeout cannot be larger than rcv_intr_timeout_csr which has already
 +	   been verified to be in range */
  	write_kctxt_csr(dd, rcd->ctxt, RCV_AVAIL_TIME_OUT,
- 		(u64)timeout << RCV_AVAIL_TIME_OUT_TIME_OUT_RELOAD_SHIFT);
+ 			(u64)timeout <<
+ 			RCV_AVAIL_TIME_OUT_TIME_OUT_RELOAD_SHIFT);
  }
  
  void update_usrhead(struct hfi1_ctxtdata *rcd, u32 hd, u32 updegr, u32 egrhd,
@@@ -12424,12 -12430,12 +12466,21 @@@ static void remap_sdma_interrupts(struc
  	 *	SDMAProgress
  	 *	SDMAIdle
  	 */
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +	remap_intr(dd, IS_SDMA_START + 0*TXE_NUM_SDMA_ENGINES + engine,
 +		msix_intr);
 +	remap_intr(dd, IS_SDMA_START + 1*TXE_NUM_SDMA_ENGINES + engine,
 +		msix_intr);
 +	remap_intr(dd, IS_SDMA_START + 2*TXE_NUM_SDMA_ENGINES + engine,
 +		msix_intr);
++=======
+ 	remap_intr(dd, IS_SDMA_START + 0 * TXE_NUM_SDMA_ENGINES + engine,
+ 		   msix_intr);
+ 	remap_intr(dd, IS_SDMA_START + 1 * TXE_NUM_SDMA_ENGINES + engine,
+ 		   msix_intr);
+ 	remap_intr(dd, IS_SDMA_START + 2 * TXE_NUM_SDMA_ENGINES + engine,
+ 		   msix_intr);
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/chip.c
  }
  
  static int request_intx_irq(struct hfi1_devdata *dd)
@@@ -12568,25 -12525,27 +12619,25 @@@ static int request_msix_irqs(struct hfi
  				 DRIVER_NAME "_%d kctxt%d", dd->unit, idx);
  			err_info = "receive context";
  			remap_intr(dd, IS_RCVAVAIL_START + idx, i);
 -			me->type = IRQ_RCVCTXT;
  		} else {
  			/* not in our expected range - complain, then
 -			 * ignore it
 -			 */
 +			   ignore it */
  			dd_dev_err(dd,
- 				"Unexpected extra MSI-X interrupt %d\n", i);
+ 				   "Unexpected extra MSI-X interrupt %d\n", i);
  			continue;
  		}
  		/* no argument, no interrupt */
 -		if (!arg)
 +		if (arg == NULL)
  			continue;
  		/* make sure the name is terminated */
 -		me->name[sizeof(me->name) - 1] = 0;
 +		me->name[sizeof(me->name)-1] = 0;
  
  		ret = request_threaded_irq(me->msix.vector, handler, thread, 0,
- 						me->name, arg);
+ 					   me->name, arg);
  		if (ret) {
  			dd_dev_err(dd,
- 				"unable to allocate %s interrupt, vector %d, index %d, err %d\n",
- 				 err_info, me->msix.vector, idx, ret);
+ 				   "unable to allocate %s interrupt, vector %d, index %d, err %d\n",
+ 				   err_info, me->msix.vector, idx, ret);
  			return ret;
  		}
  		/*
@@@ -12807,13 -12727,14 +12858,13 @@@ static int set_up_context_variables(str
  	dd->num_rcv_contexts = total_contexts;
  	dd->n_krcv_queues = num_kernel_contexts;
  	dd->first_user_ctxt = num_kernel_contexts;
 -	dd->num_user_contexts = num_user_contexts;
  	dd->freectxts = num_user_contexts;
  	dd_dev_info(dd,
- 		"rcv contexts: chip %d, used %d (kernel %d, user %d)\n",
- 		(int)dd->chip_rcv_contexts,
- 		(int)dd->num_rcv_contexts,
- 		(int)dd->n_krcv_queues,
- 		(int)dd->num_rcv_contexts - dd->n_krcv_queues);
+ 		    "rcv contexts: chip %d, used %d (kernel %d, user %d)\n",
+ 		    (int)dd->chip_rcv_contexts,
+ 		    (int)dd->num_rcv_contexts,
+ 		    (int)dd->n_krcv_queues,
+ 		    (int)dd->num_rcv_contexts - dd->n_krcv_queues);
  
  	/*
  	 * Receive array allocation:
@@@ -12929,8 -12852,8 +12980,13 @@@ static void write_uninitialized_csrs_an
  
  	/* RcvArray */
  	for (i = 0; i < dd->chip_rcv_array_count; i++)
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +		write_csr(dd, RCV_ARRAY + (8*i),
 +					RCV_ARRAY_RT_WRITE_ENABLE_SMASK);
++=======
+ 		write_csr(dd, RCV_ARRAY + (8 * i),
+ 			  RCV_ARRAY_RT_WRITE_ENABLE_SMASK);
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/chip.c
  
  	/* RcvQPMapTable */
  	for (i = 0; i < 32; i++)
@@@ -13167,18 -13092,17 +13223,17 @@@ static void reset_txe_csrs(struct hfi1_
  	write_csr(dd, SEND_ERR_CLEAR, ~0ull);
  	/* SEND_ERR_FORCE read-only */
  	for (i = 0; i < VL_ARB_LOW_PRIO_TABLE_SIZE; i++)
 -		write_csr(dd, SEND_LOW_PRIORITY_LIST + (8 * i), 0);
 +		write_csr(dd, SEND_LOW_PRIORITY_LIST + (8*i), 0);
  	for (i = 0; i < VL_ARB_HIGH_PRIO_TABLE_SIZE; i++)
 -		write_csr(dd, SEND_HIGH_PRIORITY_LIST + (8 * i), 0);
 -	for (i = 0; i < dd->chip_send_contexts / NUM_CONTEXTS_PER_SET; i++)
 -		write_csr(dd, SEND_CONTEXT_SET_CTRL + (8 * i), 0);
 +		write_csr(dd, SEND_HIGH_PRIORITY_LIST + (8*i), 0);
 +	for (i = 0; i < dd->chip_send_contexts/NUM_CONTEXTS_PER_SET; i++)
 +		write_csr(dd, SEND_CONTEXT_SET_CTRL + (8*i), 0);
  	for (i = 0; i < TXE_NUM_32_BIT_COUNTER; i++)
 -		write_csr(dd, SEND_COUNTER_ARRAY32 + (8 * i), 0);
 +		write_csr(dd, SEND_COUNTER_ARRAY32 + (8*i), 0);
  	for (i = 0; i < TXE_NUM_64_BIT_COUNTER; i++)
 -		write_csr(dd, SEND_COUNTER_ARRAY64 + (8 * i), 0);
 +		write_csr(dd, SEND_COUNTER_ARRAY64 + (8*i), 0);
  	write_csr(dd, SEND_CM_CTRL, SEND_CM_CTRL_RESETCSR);
- 	write_csr(dd, SEND_CM_GLOBAL_CREDIT,
- 					SEND_CM_GLOBAL_CREDIT_RESETCSR);
+ 	write_csr(dd, SEND_CM_GLOBAL_CREDIT, SEND_CM_GLOBAL_CREDIT_RESETCSR);
  	/* SEND_CM_CREDIT_USED_STATUS read-only */
  	write_csr(dd, SEND_CM_TIMER_CTRL, 0);
  	write_csr(dd, SEND_CM_LOCAL_AU_TABLE0_TO3, 0);
@@@ -13778,24 -13700,21 +13831,33 @@@ static void assign_cm_au_table(struct h
  			       u32 csr0to3, u32 csr4to7)
  {
  	write_csr(dd, csr0to3,
- 		   0ull <<
- 			SEND_CM_LOCAL_AU_TABLE0_TO3_LOCAL_AU_TABLE0_SHIFT
- 		|  1ull <<
- 			SEND_CM_LOCAL_AU_TABLE0_TO3_LOCAL_AU_TABLE1_SHIFT
- 		|  2ull * cu <<
- 			SEND_CM_LOCAL_AU_TABLE0_TO3_LOCAL_AU_TABLE2_SHIFT
- 		|  4ull * cu <<
- 			SEND_CM_LOCAL_AU_TABLE0_TO3_LOCAL_AU_TABLE3_SHIFT);
+ 		  0ull << SEND_CM_LOCAL_AU_TABLE0_TO3_LOCAL_AU_TABLE0_SHIFT |
+ 		  1ull << SEND_CM_LOCAL_AU_TABLE0_TO3_LOCAL_AU_TABLE1_SHIFT |
+ 		  2ull * cu <<
+ 		  SEND_CM_LOCAL_AU_TABLE0_TO3_LOCAL_AU_TABLE2_SHIFT |
+ 		  4ull * cu <<
+ 		  SEND_CM_LOCAL_AU_TABLE0_TO3_LOCAL_AU_TABLE3_SHIFT);
  	write_csr(dd, csr4to7,
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +		   8ull * cu <<
 +			SEND_CM_LOCAL_AU_TABLE4_TO7_LOCAL_AU_TABLE4_SHIFT
 +		| 16ull * cu <<
 +			SEND_CM_LOCAL_AU_TABLE4_TO7_LOCAL_AU_TABLE5_SHIFT
 +		| 32ull * cu <<
 +			SEND_CM_LOCAL_AU_TABLE4_TO7_LOCAL_AU_TABLE6_SHIFT
 +		| 64ull * cu <<
 +			SEND_CM_LOCAL_AU_TABLE4_TO7_LOCAL_AU_TABLE7_SHIFT);
 +
++=======
+ 		  8ull * cu <<
+ 		  SEND_CM_LOCAL_AU_TABLE4_TO7_LOCAL_AU_TABLE4_SHIFT |
+ 		  16ull * cu <<
+ 		  SEND_CM_LOCAL_AU_TABLE4_TO7_LOCAL_AU_TABLE5_SHIFT |
+ 		  32ull * cu <<
+ 		  SEND_CM_LOCAL_AU_TABLE4_TO7_LOCAL_AU_TABLE6_SHIFT |
+ 		  64ull * cu <<
+ 		  SEND_CM_LOCAL_AU_TABLE4_TO7_LOCAL_AU_TABLE7_SHIFT);
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/chip.c
  }
  
  static void assign_local_cm_au_table(struct hfi1_devdata *dd, u8 vcu)
diff --cc drivers/staging/hfi1/debugfs.c
index 133878fc142c,0b0fd8a70ccf..000000000000
--- a/drivers/staging/hfi1/debugfs.c
+++ b/drivers/staging/hfi1/debugfs.c
@@@ -152,8 -150,8 +152,13 @@@ static int _opcode_stats_seq_show(struc
  	if (!n_packets && !n_bytes)
  		return SEQ_SKIP;
  	seq_printf(s, "%02llx %llu/%llu\n", i,
++<<<<<<< HEAD:drivers/staging/hfi1/debugfs.c
 +		(unsigned long long) n_packets,
 +		(unsigned long long) n_bytes);
++=======
+ 		   (unsigned long long)n_packets,
+ 		   (unsigned long long)n_bytes);
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/debugfs.c
  
  	return 0;
  }
diff --cc drivers/staging/hfi1/driver.c
index 31605ee909b6,50a3b5adab0a..000000000000
--- a/drivers/staging/hfi1/driver.c
+++ b/drivers/staging/hfi1/driver.c
@@@ -419,9 -438,8 +419,9 @@@ drop
  }
  
  static inline void init_packet(struct hfi1_ctxtdata *rcd,
- 			      struct hfi1_packet *packet)
+ 			       struct hfi1_packet *packet)
  {
 +
  	packet->rsize = rcd->rcvhdrqentsize; /* words */
  	packet->maxcnt = rcd->rcvhdrq_cnt * packet->rsize; /* words */
  	packet->rcd = rcd;
@@@ -683,8 -700,9 +683,14 @@@ static inline int process_rcv_packet(st
  		 * The +2 is the size of the RHF.
  		 */
  		prefetch_range(packet->ebuf,
++<<<<<<< HEAD:drivers/staging/hfi1/driver.c
 +			packet->tlen - ((packet->rcd->rcvhdrqentsize -
 +				  (rhf_hdrq_offset(packet->rhf)+2)) * 4));
++=======
+ 			       packet->tlen - ((packet->rcd->rcvhdrqentsize -
+ 					       (rhf_hdrq_offset(packet->rhf)
+ 						+ 2)) * 4));
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/driver.c
  	}
  
  	/*
@@@ -941,12 -956,12 +947,12 @@@ int handle_receive_interrupt(struct hfi
  		}
  	}
  
 -	prescan_rxq(rcd, &packet);
 +	prescan_rxq(&packet);
  
  	while (last == RCV_PKT_OK) {
- 
- 		if (unlikely(dd->do_drop && atomic_xchg(&dd->drop_packet,
- 			DROP_PACKET_OFF) == DROP_PACKET_ON)) {
+ 		if (unlikely(dd->do_drop &&
+ 			     atomic_xchg(&dd->drop_packet, DROP_PACKET_OFF) ==
+ 			     DROP_PACKET_ON)) {
  			dd->do_drop = 0;
  
  			/* On to the next packet */
@@@ -1219,9 -1233,9 +1224,15 @@@ void hfi1_set_led_override(struct hfi1_
  	 */
  	if (atomic_inc_return(&ppd->led_override_timer_active) == 1) {
  		/* Need to start timer */
++<<<<<<< HEAD:drivers/staging/hfi1/driver.c
 +		init_timer(&ppd->led_override_timer);
 +		ppd->led_override_timer.function = run_led_override;
 +		ppd->led_override_timer.data = (unsigned long) ppd;
++=======
+ 		setup_timer(&ppd->led_override_timer, run_led_override,
+ 			    (unsigned long)ppd);
+ 
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/driver.c
  		ppd->led_override_timer.expires = jiffies + 1;
  		add_timer(&ppd->led_override_timer);
  	} else {
diff --cc drivers/staging/hfi1/file_ops.c
index 5d56ff3d1c23,1bd1545d083d..000000000000
--- a/drivers/staging/hfi1/file_ops.c
+++ b/drivers/staging/hfi1/file_ops.c
@@@ -1131,10 -1145,10 +1131,17 @@@ static int user_init(struct file *fp
  	 * has done it.
  	 */
  	if (fd->subctxt) {
++<<<<<<< HEAD:drivers/staging/hfi1/file_ops.c
 +		ret = wait_event_interruptible(uctxt->wait,
 +			!test_bit(HFI1_CTXT_MASTER_UNINIT,
 +			&uctxt->event_flags));
 +		goto done;
++=======
+ 		ret = wait_event_interruptible(uctxt->wait, !test_bit(
+ 					       HFI1_CTXT_MASTER_UNINIT,
+ 					       &uctxt->event_flags));
+ 		goto expected;
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/file_ops.c
  	}
  
  	/* initialize poll variables... */
@@@ -1967,10 -1590,9 +1974,10 @@@ static loff_t ui_lseek(struct file *fil
  	return filp->f_pos;
  }
  
 +
  /* NOTE: assumes unsigned long is 8 bytes */
  static ssize_t ui_read(struct file *filp, char __user *buf, size_t count,
- 			loff_t *f_pos)
+ 		       loff_t *f_pos)
  {
  	struct hfi1_devdata *dd = filp->private_data;
  	void __iomem *base = dd->kregbase;
diff --cc drivers/staging/hfi1/firmware.c
index 41352d015553,52a3e8c95a07..000000000000
--- a/drivers/staging/hfi1/firmware.c
+++ b/drivers/staging/hfi1/firmware.c
@@@ -387,19 -393,19 +387,35 @@@ static int invalid_header(struct hfi1_d
  static int verify_css_header(struct hfi1_devdata *dd, struct css_header *css)
  {
  	/* verify CSS header fields (most sizes are in DW, so add /4) */
++<<<<<<< HEAD:drivers/staging/hfi1/firmware.c
 +	if (invalid_header(dd, "module_type", css->module_type, CSS_MODULE_TYPE)
 +			|| invalid_header(dd, "header_len", css->header_len,
 +					(sizeof(struct firmware_file)/4))
 +			|| invalid_header(dd, "header_version",
 +					css->header_version, CSS_HEADER_VERSION)
 +			|| invalid_header(dd, "module_vendor",
 +					css->module_vendor, CSS_MODULE_VENDOR)
 +			|| invalid_header(dd, "key_size",
 +					css->key_size, KEY_SIZE/4)
 +			|| invalid_header(dd, "modulus_size",
 +					css->modulus_size, KEY_SIZE/4)
 +			|| invalid_header(dd, "exponent_size",
 +					css->exponent_size, EXPONENT_SIZE/4)) {
++=======
+ 	if (invalid_header(dd, "module_type", css->module_type,
+ 			   CSS_MODULE_TYPE) ||
+ 	    invalid_header(dd, "header_len", css->header_len,
+ 			   (sizeof(struct firmware_file) / 4)) ||
+ 	    invalid_header(dd, "header_version", css->header_version,
+ 			   CSS_HEADER_VERSION) ||
+ 	    invalid_header(dd, "module_vendor", css->module_vendor,
+ 			   CSS_MODULE_VENDOR) ||
+ 	    invalid_header(dd, "key_size", css->key_size, KEY_SIZE / 4) ||
+ 	    invalid_header(dd, "modulus_size", css->modulus_size,
+ 			   KEY_SIZE / 4) ||
+ 	    invalid_header(dd, "exponent_size", css->exponent_size,
+ 			   EXPONENT_SIZE / 4)) {
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/firmware.c
  		return -EINVAL;
  	}
  	return 0;
@@@ -531,9 -537,10 +547,16 @@@ static int obtain_one_firmware(struct h
  	} else {
  		/* css->size check failed */
  		dd_dev_err(dd,
++<<<<<<< HEAD:drivers/staging/hfi1/firmware.c
 +			"invalid firmware header field size: expected 0x%lx or 0x%lx, actual 0x%x\n",
 +			fdet->fw->size/4, (fdet->fw->size - AUGMENT_SIZE)/4,
 +			css->size);
++=======
+ 			   "invalid firmware header field size: expected 0x%lx or 0x%lx, actual 0x%x\n",
+ 			   fdet->fw->size / 4,
+ 			   (fdet->fw->size - AUGMENT_SIZE) / 4,
+ 			   css->size);
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/firmware.c
  
  		ret = -EINVAL;
  	}
@@@ -691,9 -703,13 +714,14 @@@ static int obtain_firmware(struct hfi1_
  	if (platform_config_load) {
  		platform_config = NULL;
  		err = request_firmware(&platform_config, platform_config_name,
++<<<<<<< HEAD:drivers/staging/hfi1/firmware.c
 +						&dd->pcidev->dev);
 +		if (err)
++=======
+ 				       &dd->pcidev->dev);
+ 		if (err) {
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/firmware.c
  			platform_config = NULL;
 -			goto done;
 -		}
 -		dd->platform_config.data = platform_config->data;
 -		dd->platform_config.size = platform_config->size;
  	}
  
  done:
@@@ -1285,11 -1302,13 +1314,11 @@@ static int load_pcie_serdes_firmware(st
  	/* step 3: enable XDMEM access */
  	sbus_request(dd, ra, 0x01, WRITE_SBUS_RECEIVER, 0x00000d40);
  	/* step 4: load firmware into SBus Master XDMEM */
 -	/*
 -	 * NOTE: the dmem address, write_en, and wdata are all pre-packed,
 -	 * we only need to pick up the bytes and write them
 -	 */
 +	/* NOTE: the dmem address, write_en, and wdata are all pre-packed,
 +	   we only need to pick up the bytes and write them */
  	for (i = 0; i < fdet->firmware_len; i += 4) {
  		sbus_request(dd, ra, 0x04, WRITE_SBUS_RECEIVER,
- 					*(u32 *)&fdet->firmware_ptr[i]);
+ 			     *(u32 *)&fdet->firmware_ptr[i]);
  	}
  	/* step 5: disable XDMEM access */
  	sbus_request(dd, ra, 0x01, WRITE_SBUS_RECEIVER, 0x00000140);
@@@ -1480,7 -1559,8 +1509,12 @@@ int parse_platform_config(struct hfi1_d
  		header2 = *(ptr + 1);
  		if (header1 != ~header2) {
  			dd_dev_info(dd, "%s: Failed validation at offset %ld\n",
++<<<<<<< HEAD:drivers/staging/hfi1/firmware.c
 +				__func__, (ptr - (u32 *)platform_config->data));
++=======
+ 				    __func__, (ptr - (u32 *)
+ 					       dd->platform_config.data));
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/firmware.c
  			goto bail;
  		}
  
@@@ -1520,9 -1603,10 +1554,16 @@@
  				break;
  			default:
  				dd_dev_info(dd,
++<<<<<<< HEAD:drivers/staging/hfi1/firmware.c
 +				      "%s: Unknown data table %d, offset %ld\n",
 +					__func__, table_type,
 +				       (ptr - (u32 *)platform_config->data));
++=======
+ 					    "%s: Unknown data table %d, offset %ld\n",
+ 					    __func__, table_type,
+ 					    (ptr - (u32 *)
+ 					     dd->platform_config.data));
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/firmware.c
  				goto bail; /* We don't trust this file now */
  			}
  			pcfgcache->config_tables[table_type].table = ptr;
diff --cc drivers/staging/hfi1/mad.c
index 4900f79eb54a,7619b752789e..000000000000
--- a/drivers/staging/hfi1/mad.c
+++ b/drivers/staging/hfi1/mad.c
@@@ -528,8 -534,8 +528,13 @@@ static int __subn_get_opa_portinfo(stru
  	ppd = dd->pport + (port - 1);
  	ibp = &ppd->ibport_data;
  
++<<<<<<< HEAD:drivers/staging/hfi1/mad.c
 +	if (ppd->vls_supported/2 > ARRAY_SIZE(pi->neigh_mtu.pvlx_to_mtu) ||
 +		ppd->vls_supported > ARRAY_SIZE(dd->vld)) {
++=======
+ 	if (ppd->vls_supported / 2 > ARRAY_SIZE(pi->neigh_mtu.pvlx_to_mtu) ||
+ 	    ppd->vls_supported > ARRAY_SIZE(dd->vld)) {
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/mad.c
  		smp->status |= IB_SMP_INVALID_FIELD;
  		return reply((struct ib_mad_hdr *)smp);
  	}
@@@ -1094,7 -1101,7 +1098,11 @@@ static int __subn_set_opa_portinfo(stru
  
  	/* Must be a valid unicast LID address. */
  	if ((lid == 0 && ls_old > IB_PORT_INIT) ||
++<<<<<<< HEAD:drivers/staging/hfi1/mad.c
 +	     lid >= HFI1_MULTICAST_LID_BASE) {
++=======
+ 	    lid >= be16_to_cpu(IB_MULTICAST_LID_BASE)) {
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/mad.c
  		smp->status |= IB_SMP_INVALID_FIELD;
  		pr_warn("SubnSet(OPA_PortInfo) lid invalid 0x%x\n",
  			lid);
@@@ -1127,23 -1134,23 +1135,27 @@@
  
  	/* Must be a valid unicast LID address. */
  	if ((smlid == 0 && ls_old > IB_PORT_INIT) ||
++<<<<<<< HEAD:drivers/staging/hfi1/mad.c
 +	     smlid >= HFI1_MULTICAST_LID_BASE) {
++=======
+ 	    smlid >= be16_to_cpu(IB_MULTICAST_LID_BASE)) {
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/mad.c
  		smp->status |= IB_SMP_INVALID_FIELD;
  		pr_warn("SubnSet(OPA_PortInfo) smlid invalid 0x%x\n", smlid);
 -	} else if (smlid != ibp->rvp.sm_lid || msl != ibp->rvp.sm_sl) {
 +	} else if (smlid != ibp->sm_lid || msl != ibp->sm_sl) {
  		pr_warn("SubnSet(OPA_PortInfo) smlid 0x%x\n", smlid);
 -		spin_lock_irqsave(&ibp->rvp.lock, flags);
 -		if (ibp->rvp.sm_ah) {
 -			if (smlid != ibp->rvp.sm_lid)
 -				ibp->rvp.sm_ah->attr.dlid = smlid;
 -			if (msl != ibp->rvp.sm_sl)
 -				ibp->rvp.sm_ah->attr.sl = msl;
 +		spin_lock_irqsave(&ibp->lock, flags);
 +		if (ibp->sm_ah) {
 +			if (smlid != ibp->sm_lid)
 +				ibp->sm_ah->attr.dlid = smlid;
 +			if (msl != ibp->sm_sl)
 +				ibp->sm_ah->attr.sl = msl;
  		}
 -		spin_unlock_irqrestore(&ibp->rvp.lock, flags);
 -		if (smlid != ibp->rvp.sm_lid)
 -			ibp->rvp.sm_lid = smlid;
 -		if (msl != ibp->rvp.sm_sl)
 -			ibp->rvp.sm_sl = msl;
 +		spin_unlock_irqrestore(&ibp->lock, flags);
 +		if (smlid != ibp->sm_lid)
 +			ibp->sm_lid = smlid;
 +		if (msl != ibp->sm_sl)
 +			ibp->sm_sl = msl;
  		event.event = IB_EVENT_SM_CHANGE;
  		ib_dispatch_event(&event);
  	}
@@@ -1174,10 -1181,12 +1186,12 @@@
  	}
  	lwe = be16_to_cpu(pi->link_width_downgrade.enabled);
  	/* LWD.E is always applied - 0 means "disabled" */
 -	if (lwe == OPA_LINK_WIDTH_RESET ||
 -	    lwe == OPA_LINK_WIDTH_RESET_OLD) {
 +	if (lwe == OPA_LINK_WIDTH_RESET
 +			|| lwe == OPA_LINK_WIDTH_RESET_OLD) {
  		set_link_width_downgrade_enabled(ppd,
- 				ppd->link_width_downgrade_supported);
+ 						 ppd->
+ 						 link_width_downgrade_supported
+ 						 );
  	} else if ((lwe & ~ppd->link_width_downgrade_supported) == 0) {
  		/* only set and apply if something changed */
  		if (lwe != ppd->link_width_downgrade_enabled) {
@@@ -1195,22 -1204,24 +1209,35 @@@
  			smp->status |= IB_SMP_INVALID_FIELD;
  	}
  
 -	ibp->rvp.mkeyprot =
 -		(pi->mkeyprotect_lmc & OPA_PI_MASK_MKEY_PROT_BIT) >> 6;
 -	ibp->rvp.vl_high_limit = be16_to_cpu(pi->vl.high_limit) & 0xFF;
 +	ibp->mkeyprot = (pi->mkeyprotect_lmc & OPA_PI_MASK_MKEY_PROT_BIT) >> 6;
 +	ibp->vl_high_limit = be16_to_cpu(pi->vl.high_limit) & 0xFF;
  	(void)hfi1_set_ib_cfg(ppd, HFI1_IB_CFG_VL_HIGH_LIMIT,
 -				    ibp->rvp.vl_high_limit);
 +				    ibp->vl_high_limit);
  
++<<<<<<< HEAD:drivers/staging/hfi1/mad.c
 +	if (ppd->vls_supported/2 > ARRAY_SIZE(pi->neigh_mtu.pvlx_to_mtu) ||
 +		ppd->vls_supported > ARRAY_SIZE(dd->vld)) {
++=======
+ 	if (ppd->vls_supported / 2 > ARRAY_SIZE(pi->neigh_mtu.pvlx_to_mtu) ||
+ 	    ppd->vls_supported > ARRAY_SIZE(dd->vld)) {
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/mad.c
  		smp->status |= IB_SMP_INVALID_FIELD;
  		return reply((struct ib_mad_hdr *)smp);
  	}
  	for (i = 0; i < ppd->vls_supported; i++) {
  		if ((i % 2) == 0)
++<<<<<<< HEAD:drivers/staging/hfi1/mad.c
 +			mtu = enum_to_mtu((pi->neigh_mtu.pvlx_to_mtu[i/2] >> 4)
 +					  & 0xF);
 +		else
 +			mtu = enum_to_mtu(pi->neigh_mtu.pvlx_to_mtu[i/2] & 0xF);
++=======
+ 			mtu = enum_to_mtu((pi->neigh_mtu.pvlx_to_mtu[i / 2] >>
+ 					   4) & 0xF);
+ 		else
+ 			mtu = enum_to_mtu(pi->neigh_mtu.pvlx_to_mtu[i / 2] &
+ 					  0xF);
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/mad.c
  		if (mtu == 0xffff) {
  			pr_warn("SubnSet(OPA_PortInfo) mtu invalid %d (0x%x)\n",
  				mtu,
@@@ -1782,10 -1803,12 +1809,10 @@@ static int __subn_get_opa_cable_info(st
  #define __CI_PAGE_MASK ~(__CI_PAGE_SIZE - 1)
  #define __CI_PAGE_NUM(a) ((a) & __CI_PAGE_MASK)
  
 -	/*
 -	 * check that addr is within spec, and
 -	 * addr and (addr + len - 1) are on the same "page"
 -	 */
 +	/* check that addr is within spec, and
 +	 * addr and (addr + len - 1) are on the same "page" */
  	if (addr >= 4096 ||
- 		(__CI_PAGE_NUM(addr) != __CI_PAGE_NUM(addr + len - 1))) {
+ 	    (__CI_PAGE_NUM(addr) != __CI_PAGE_NUM(addr + len - 1))) {
  		smp->status |= IB_SMP_INVALID_FIELD;
  		return reply((struct ib_mad_hdr *)smp);
  	}
@@@ -2295,9 -2321,9 +2322,10 @@@ static void a0_portstatus(struct hfi1_p
  	}
  }
  
 +
  static int pma_get_opa_portstatus(struct opa_pma_mad *pmp,
- 			struct ib_device *ibdev, u8 port, u32 *resp_len)
+ 				  struct ib_device *ibdev,
+ 				  u8 port, u32 *resp_len)
  {
  	struct opa_port_status_req *req =
  		(struct opa_port_status_req *)pmp->data;
@@@ -4065,11 -4098,11 +4097,19 @@@ static int process_subn(struct ib_devic
  		     smp->method == IB_MGMT_METHOD_SET) &&
  		    port_num && port_num <= ibdev->phys_port_cnt &&
  		    port != port_num)
++<<<<<<< HEAD:drivers/staging/hfi1/mad.c
 +			(void) check_mkey(to_iport(ibdev, port_num),
 +					  (struct ib_mad_hdr *)smp, 0,
 +					  smp->mkey,
 +					  (__force __be32)smp->dr_slid,
 +					  smp->return_path, smp->hop_cnt);
++=======
+ 			(void)check_mkey(to_iport(ibdev, port_num),
+ 					 (struct ib_mad_hdr *)smp, 0,
+ 					 smp->mkey,
+ 					 (__force __be32)smp->dr_slid,
+ 					 smp->return_path, smp->hop_cnt);
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/mad.c
  		ret = IB_MAD_RESULT_FAILURE;
  		return ret;
  	}
diff --cc drivers/staging/hfi1/pcie.c
index 986a471703d4,cbd61cf6549a..000000000000
--- a/drivers/staging/hfi1/pcie.c
+++ b/drivers/staging/hfi1/pcie.c
@@@ -835,8 -836,8 +831,13 @@@ static void write_gasket_interrupt(stru
  				   u16 code, u16 data)
  {
  	write_csr(dd, ASIC_PCIE_SD_INTRPT_LIST + (index * 8),
++<<<<<<< HEAD:drivers/staging/hfi1/pcie.c
 +	    (((u64)code << ASIC_PCIE_SD_INTRPT_LIST_INTRPT_CODE_SHIFT)
 +	    |((u64)data << ASIC_PCIE_SD_INTRPT_LIST_INTRPT_DATA_SHIFT)));
++=======
+ 		  (((u64)code << ASIC_PCIE_SD_INTRPT_LIST_INTRPT_CODE_SHIFT) |
+ 		   ((u64)data << ASIC_PCIE_SD_INTRPT_LIST_INTRPT_DATA_SHIFT)));
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/pcie.c
  }
  
  /*
diff --cc drivers/staging/hfi1/rc.c
index dd57d65aa9b2,28ff638cd371..000000000000
--- a/drivers/staging/hfi1/rc.c
+++ b/drivers/staging/hfi1/rc.c
@@@ -1648,11 -1773,11 +1648,16 @@@ static inline void rc_cancel_ack(struc
   * schedule a response to be sent.
   */
  static noinline int rc_rcv_error(struct hfi1_other_headers *ohdr, void *data,
++<<<<<<< HEAD:drivers/staging/hfi1/rc.c
 +			struct hfi1_qp *qp, u32 opcode, u32 psn, int diff,
 +			struct hfi1_ctxtdata *rcd)
++=======
+ 				 struct rvt_qp *qp, u32 opcode, u32 psn,
+ 				 int diff, struct hfi1_ctxtdata *rcd)
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/rc.c
  {
  	struct hfi1_ibport *ibp = to_iport(qp->ibqp.device, qp->port_num);
 -	struct rvt_ack_entry *e;
 +	struct hfi1_ack_entry *e;
  	unsigned long flags;
  	u8 i, prev;
  	int old_req;
diff --cc drivers/staging/hfi1/sdma.c
index 8a57bc183ce2,74086eabbb25..000000000000
--- a/drivers/staging/hfi1/sdma.c
+++ b/drivers/staging/hfi1/sdma.c
@@@ -1035,10 -1015,10 +1035,10 @@@ int sdma_init(struct hfi1_devdata *dd, 
  	dd_dev_info(dd, "SDMA mod_num_sdma: %u\n", mod_num_sdma);
  	dd_dev_info(dd, "SDMA chip_sdma_engines: %u\n", dd->chip_sdma_engines);
  	dd_dev_info(dd, "SDMA chip_sdma_mem_size: %u\n",
- 		dd->chip_sdma_mem_size);
+ 		    dd->chip_sdma_mem_size);
  
  	per_sdma_credits =
 -		dd->chip_sdma_mem_size / (num_engines * SDMA_BLOCK_SIZE);
 +		dd->chip_sdma_mem_size/(num_engines * SDMA_BLOCK_SIZE);
  
  	/* set up freeze waitqueue */
  	init_waitqueue_head(&dd->sdma_unfreeze_wq);
@@@ -1663,12 -1622,10 +1663,19 @@@ static void sdma_setlengen(struct sdma_
  	 * generation counter.
  	 */
  	write_sde_csr(sde, SD(LEN_GEN),
++<<<<<<< HEAD:drivers/staging/hfi1/sdma.c
 +		(sde->descq_cnt/64) << SD(LEN_GEN_LENGTH_SHIFT)
 +	);
 +	write_sde_csr(sde, SD(LEN_GEN),
 +		((sde->descq_cnt/64) << SD(LEN_GEN_LENGTH_SHIFT))
 +		| (4ULL << SD(LEN_GEN_GENERATION_SHIFT))
 +	);
++=======
+ 		      (sde->descq_cnt / 64) << SD(LEN_GEN_LENGTH_SHIFT));
+ 	write_sde_csr(sde, SD(LEN_GEN),
+ 		      ((sde->descq_cnt / 64) << SD(LEN_GEN_LENGTH_SHIFT)) |
+ 		      (4ULL << SD(LEN_GEN_GENERATION_SHIFT)));
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/sdma.c
  }
  
  static inline void sdma_update_tail(struct sdma_engine *sde, u16 tail)
@@@ -3095,5 -3049,6 +3099,10 @@@ void _sdma_engine_progress_schedule
  	trace_hfi1_sdma_engine_progress(sde, sde->progress_mask);
  	/* assume we have selected a good cpu */
  	write_csr(sde->dd,
++<<<<<<< HEAD:drivers/staging/hfi1/sdma.c
 +		  CCE_INT_FORCE + (8*(IS_SDMA_START/64)), sde->progress_mask);
++=======
+ 		  CCE_INT_FORCE + (8 * (IS_SDMA_START / 64)),
+ 		  sde->progress_mask);
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/sdma.c
  }
diff --cc drivers/staging/hfi1/trace.c
index 10122e84cb2f,99fd01751492..000000000000
--- a/drivers/staging/hfi1/trace.c
+++ b/drivers/staging/hfi1/trace.c
@@@ -154,19 -154,20 +154,33 @@@ const char *parse_everbs_hdrs
  	case OP(RC, COMPARE_SWAP):
  	case OP(RC, FETCH_ADD):
  		trace_seq_printf(p, ATOMICETH_PRN,
++<<<<<<< HEAD:drivers/staging/hfi1/trace.c
 +			(unsigned long long)ib_u64_get(eh->atomic_eth.vaddr),
 +			eh->atomic_eth.rkey,
 +			(unsigned long long)ib_u64_get(
 +				(__be32 *)&eh->atomic_eth.swap_data),
 +			(unsigned long long) ib_u64_get(
++=======
+ 				 (unsigned long long)ib_u64_get(
+ 				 eh->atomic_eth.vaddr),
+ 				 eh->atomic_eth.rkey,
+ 				 (unsigned long long)ib_u64_get(
+ 				 (__be32 *)&eh->atomic_eth.swap_data),
+ 				 (unsigned long long)ib_u64_get(
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/trace.c
  				 (__be32 *)&eh->atomic_eth.compare_data));
  		break;
  	/* deth */
  	case OP(UD, SEND_ONLY):
  	case OP(UD, SEND_ONLY_WITH_IMMEDIATE):
  		trace_seq_printf(p, DETH_PRN,
++<<<<<<< HEAD:drivers/staging/hfi1/trace.c
 +			be32_to_cpu(eh->ud.deth[0]),
 +			be32_to_cpu(eh->ud.deth[1]) & HFI1_QPN_MASK);
++=======
+ 				 be32_to_cpu(eh->ud.deth[0]),
+ 				 be32_to_cpu(eh->ud.deth[1]) & RVT_QPN_MASK);
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/trace.c
  		break;
  	}
  	trace_seq_putc(p, 0);
diff --cc drivers/staging/hfi1/trace.h
index 86c12ebfd4f0,dfa996715736..000000000000
--- a/drivers/staging/hfi1/trace.h
+++ b/drivers/staging/hfi1/trace.h
@@@ -119,46 -118,75 +118,43 @@@ TRACE_EVENT(hfi1_rcvhdr
  );
  
  TRACE_EVENT(hfi1_receive_interrupt,
- 	TP_PROTO(struct hfi1_devdata *dd, u32 ctxt),
- 	TP_ARGS(dd, ctxt),
- 	TP_STRUCT__entry(
- 		DD_DEV_ENTRY(dd)
- 		__field(u32, ctxt)
- 		__field(u8, slow_path)
- 		__field(u8, dma_rtail)
- 	),
- 	TP_fast_assign(
- 		DD_DEV_ASSIGN(dd);
- 		__entry->ctxt = ctxt;
- 		if (dd->rcd[ctxt]->do_interrupt ==
- 		    &handle_receive_interrupt) {
- 			__entry->slow_path = 1;
- 			__entry->dma_rtail = 0xFF;
- 		} else if (dd->rcd[ctxt]->do_interrupt ==
- 			&handle_receive_interrupt_dma_rtail){
- 			__entry->dma_rtail = 1;
- 			__entry->slow_path = 0;
- 		} else if (dd->rcd[ctxt]->do_interrupt ==
- 			 &handle_receive_interrupt_nodma_rtail) {
- 			__entry->dma_rtail = 0;
- 			__entry->slow_path = 0;
- 		}
- 	),
- 	TP_printk(
- 		"[%s] ctxt %d SlowPath: %d DmaRtail: %d",
- 		__get_str(dev),
- 		__entry->ctxt,
- 		__entry->slow_path,
- 		__entry->dma_rtail
- 	)
+ 	    TP_PROTO(struct hfi1_devdata *dd, u32 ctxt),
+ 	    TP_ARGS(dd, ctxt),
+ 	    TP_STRUCT__entry(DD_DEV_ENTRY(dd)
+ 			     __field(u32, ctxt)
+ 			     __field(u8, slow_path)
+ 			     __field(u8, dma_rtail)
+ 			     ),
+ 	    TP_fast_assign(DD_DEV_ASSIGN(dd);
+ 			   __entry->ctxt = ctxt;
+ 			   if (dd->rcd[ctxt]->do_interrupt ==
+ 			       &handle_receive_interrupt) {
+ 				__entry->slow_path = 1;
+ 				__entry->dma_rtail = 0xFF;
+ 			   } else if (dd->rcd[ctxt]->do_interrupt ==
+ 				      &handle_receive_interrupt_dma_rtail){
+ 				__entry->dma_rtail = 1;
+ 				__entry->slow_path = 0;
+ 			   } else if (dd->rcd[ctxt]->do_interrupt ==
+ 				      &handle_receive_interrupt_nodma_rtail) {
+ 				__entry->dma_rtail = 0;
+ 				__entry->slow_path = 0;
+ 			   }
+ 			   ),
+ 	    TP_printk("[%s] ctxt %d SlowPath: %d DmaRtail: %d",
+ 		      __get_str(dev),
+ 		      __entry->ctxt,
+ 		      __entry->slow_path,
+ 		      __entry->dma_rtail
+ 		      )
  );
  
 -TRACE_EVENT(hfi1_exp_tid_reg,
 -	    TP_PROTO(unsigned ctxt, u16 subctxt, u32 rarr,
 -		     u32 npages, unsigned long va, unsigned long pa,
 -		     dma_addr_t dma),
 -	    TP_ARGS(ctxt, subctxt, rarr, npages, va, pa, dma),
 -	    TP_STRUCT__entry(
 -		    __field(unsigned, ctxt)
 -		    __field(u16, subctxt)
 -		    __field(u32, rarr)
 -		    __field(u32, npages)
 -		    __field(unsigned long, va)
 -		    __field(unsigned long, pa)
 -		    __field(dma_addr_t, dma)
 -		    ),
 -	    TP_fast_assign(
 -		    __entry->ctxt = ctxt;
 -		    __entry->subctxt = subctxt;
 -		    __entry->rarr = rarr;
 -		    __entry->npages = npages;
 -		    __entry->va = va;
 -		    __entry->pa = pa;
 -		    __entry->dma = dma;
 -		    ),
 -	    TP_printk("[%u:%u] entry:%u, %u pages @ 0x%lx, va:0x%lx dma:0x%llx",
 -		      __entry->ctxt,
 -		      __entry->subctxt,
 -		      __entry->rarr,
 -		      __entry->npages,
 -		      __entry->pa,
 -		      __entry->va,
 -		      __entry->dma
 -		    )
 -	);
 +const char *print_u64_array(struct trace_seq *, u64 *, int);
  
 -TRACE_EVENT(hfi1_exp_tid_unreg,
 -	    TP_PROTO(unsigned ctxt, u16 subctxt, u32 rarr, u32 npages,
 -		     unsigned long va, unsigned long pa, dma_addr_t dma),
 -	    TP_ARGS(ctxt, subctxt, rarr, npages, va, pa, dma),
 +TRACE_EVENT(hfi1_exp_tid_map,
 +	    TP_PROTO(unsigned ctxt, u16 subctxt, int dir,
 +		     unsigned long *maps, u16 count),
 +	    TP_ARGS(ctxt, subctxt, dir, maps, count),
  	    TP_STRUCT__entry(
  		    __field(unsigned, ctxt)
  		    __field(u16, subctxt)
@@@ -294,27 -322,27 +284,51 @@@ TRACE_EVENT(hfi1_wantpiointr
  );
  
  DECLARE_EVENT_CLASS(hfi1_qpsleepwakeup_template,
++<<<<<<< HEAD:drivers/staging/hfi1/trace.h
 +	TP_PROTO(struct hfi1_qp *qp, u32 flags),
 +	TP_ARGS(qp, flags),
 +	TP_STRUCT__entry(
 +		DD_DEV_ENTRY(dd_from_ibdev(qp->ibqp.device))
 +		__field(u32, qpn)
 +		__field(u32, flags)
 +		__field(u32, s_flags)
 +	),
 +	TP_fast_assign(
 +		DD_DEV_ASSIGN(dd_from_ibdev(qp->ibqp.device))
 +		__entry->flags = flags;
 +		__entry->qpn = qp->ibqp.qp_num;
 +		__entry->s_flags = qp->s_flags;
 +	),
 +	TP_printk(
 +		"[%s] qpn 0x%x flags 0x%x s_flags 0x%x",
 +		__get_str(dev),
 +		__entry->qpn,
 +		__entry->flags,
 +		__entry->s_flags
 +	)
++=======
+ 		    TP_PROTO(struct rvt_qp *qp, u32 flags),
+ 		    TP_ARGS(qp, flags),
+ 		    TP_STRUCT__entry(
+ 			    DD_DEV_ENTRY(dd_from_ibdev(qp->ibqp.device))
+ 			    __field(u32, qpn)
+ 			    __field(u32, flags)
+ 			    __field(u32, s_flags)
+ 			    ),
+ 		    TP_fast_assign(
+ 			    DD_DEV_ASSIGN(dd_from_ibdev(qp->ibqp.device))
+ 			    __entry->flags = flags;
+ 			    __entry->qpn = qp->ibqp.qp_num;
+ 			    __entry->s_flags = qp->s_flags;
+ 			    ),
+ 		    TP_printk(
+ 			    "[%s] qpn 0x%x flags 0x%x s_flags 0x%x",
+ 			    __get_str(dev),
+ 			    __entry->qpn,
+ 			    __entry->flags,
+ 			    __entry->s_flags
+ 			    )
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/trace.h
  );
  
  DEFINE_EVENT(hfi1_qpsleepwakeup_template, hfi1_qpwakeup,
@@@ -428,117 -418,115 +437,198 @@@ __print_symbolic(opcode
  #define EHDR_PRN "%s"
  
  DECLARE_EVENT_CLASS(hfi1_ibhdr_template,
- 	TP_PROTO(struct hfi1_devdata *dd,
- 		 struct hfi1_ib_header *hdr),
- 	TP_ARGS(dd, hdr),
- 	TP_STRUCT__entry(
- 		DD_DEV_ENTRY(dd)
- 		/* LRH */
- 		__field(u8, vl)
- 		__field(u8, lver)
- 		__field(u8, sl)
- 		__field(u8, lnh)
- 		__field(u16, dlid)
- 		__field(u16, len)
- 		__field(u16, slid)
- 		/* BTH */
- 		__field(u8, opcode)
- 		__field(u8, se)
- 		__field(u8, m)
- 		__field(u8, pad)
- 		__field(u8, tver)
- 		__field(u16, pkey)
- 		__field(u8, f)
- 		__field(u8, b)
- 		__field(u32, qpn)
- 		__field(u8, a)
- 		__field(u32, psn)
- 		/* extended headers */
- 		__dynamic_array(u8, ehdrs, ibhdr_exhdr_len(hdr))
- 	),
- 	TP_fast_assign(
- 		struct hfi1_other_headers *ohdr;
- 
+ 		    TP_PROTO(struct hfi1_devdata *dd,
+ 			     struct hfi1_ib_header *hdr),
+ 		    TP_ARGS(dd, hdr),
+ 		    TP_STRUCT__entry(
+ 			    DD_DEV_ENTRY(dd)
+ 			    /* LRH */
+ 			    __field(u8, vl)
+ 			    __field(u8, lver)
+ 			    __field(u8, sl)
+ 			    __field(u8, lnh)
+ 			    __field(u16, dlid)
+ 			    __field(u16, len)
+ 			    __field(u16, slid)
+ 			    /* BTH */
+ 			    __field(u8, opcode)
+ 			    __field(u8, se)
+ 			    __field(u8, m)
+ 			    __field(u8, pad)
+ 			    __field(u8, tver)
+ 			    __field(u16, pkey)
+ 			    __field(u8, f)
+ 			    __field(u8, b)
+ 			    __field(u32, qpn)
+ 			    __field(u8, a)
+ 			    __field(u32, psn)
+ 			    /* extended headers */
+ 			    __dynamic_array(u8, ehdrs, ibhdr_exhdr_len(hdr))
+ 			    ),
+ 		    TP_fast_assign(
+ 			   struct hfi1_other_headers *ohdr;
+ 
++<<<<<<< HEAD:drivers/staging/hfi1/trace.h
 +		DD_DEV_ASSIGN(dd);
 +		/* LRH */
 +		__entry->vl =
 +			(u8)(be16_to_cpu(hdr->lrh[0]) >> 12);
 +		__entry->lver =
 +			(u8)(be16_to_cpu(hdr->lrh[0]) >> 8) & 0xf;
 +		__entry->sl =
 +			(u8)(be16_to_cpu(hdr->lrh[0]) >> 4) & 0xf;
 +		__entry->lnh =
 +			(u8)(be16_to_cpu(hdr->lrh[0]) & 3);
 +		__entry->dlid =
 +			be16_to_cpu(hdr->lrh[1]);
 +		/* allow for larger len */
 +		__entry->len =
 +			be16_to_cpu(hdr->lrh[2]);
 +		__entry->slid =
 +			be16_to_cpu(hdr->lrh[3]);
 +		/* BTH */
 +		if (__entry->lnh == HFI1_LRH_BTH)
 +			ohdr = &hdr->u.oth;
 +		else
 +			ohdr = &hdr->u.l.oth;
 +		__entry->opcode =
 +			(be32_to_cpu(ohdr->bth[0]) >> 24) & 0xff;
 +		__entry->se =
 +			(be32_to_cpu(ohdr->bth[0]) >> 23) & 1;
 +		__entry->m =
 +			 (be32_to_cpu(ohdr->bth[0]) >> 22) & 1;
 +		__entry->pad =
 +			(be32_to_cpu(ohdr->bth[0]) >> 20) & 3;
 +		__entry->tver =
 +			(be32_to_cpu(ohdr->bth[0]) >> 16) & 0xf;
 +		__entry->pkey =
 +			be32_to_cpu(ohdr->bth[0]) & 0xffff;
 +		__entry->f =
 +			(be32_to_cpu(ohdr->bth[1]) >> HFI1_FECN_SHIFT)
 +			& HFI1_FECN_MASK;
 +		__entry->b =
 +			(be32_to_cpu(ohdr->bth[1]) >> HFI1_BECN_SHIFT)
 +			& HFI1_BECN_MASK;
 +		__entry->qpn =
 +			be32_to_cpu(ohdr->bth[1]) & HFI1_QPN_MASK;
 +		__entry->a =
 +			(be32_to_cpu(ohdr->bth[2]) >> 31) & 1;
 +		/* allow for larger PSN */
 +		__entry->psn =
 +			be32_to_cpu(ohdr->bth[2]) & 0x7fffffff;
 +		/* extended headers */
 +		 memcpy(
 +			__get_dynamic_array(ehdrs),
 +			&ohdr->u,
 +			ibhdr_exhdr_len(hdr));
 +	),
 +	TP_printk("[%s] " LRH_PRN " " BTH_PRN " " EHDR_PRN,
 +		__get_str(dev),
 +		/* LRH */
 +		__entry->vl,
 +		__entry->lver,
 +		__entry->sl,
 +		__entry->lnh, show_lnh(__entry->lnh),
 +		__entry->dlid,
 +		__entry->len,
 +		__entry->slid,
 +		/* BTH */
 +		__entry->opcode, show_ib_opcode(__entry->opcode),
 +		__entry->se,
 +		__entry->m,
 +		__entry->pad,
 +		__entry->tver,
 +		__entry->pkey,
 +		__entry->f,
 +		__entry->b,
 +		__entry->qpn,
 +		__entry->a,
 +		__entry->psn,
 +		/* extended headers */
 +		__parse_ib_ehdrs(
 +			__entry->opcode,
 +			(void *)__get_dynamic_array(ehdrs))
 +	)
++=======
+ 			   DD_DEV_ASSIGN(dd);
+ 			   /* LRH */
+ 			   __entry->vl =
+ 			   (u8)(be16_to_cpu(hdr->lrh[0]) >> 12);
+ 			   __entry->lver =
+ 			   (u8)(be16_to_cpu(hdr->lrh[0]) >> 8) & 0xf;
+ 			   __entry->sl =
+ 			   (u8)(be16_to_cpu(hdr->lrh[0]) >> 4) & 0xf;
+ 			   __entry->lnh =
+ 			   (u8)(be16_to_cpu(hdr->lrh[0]) & 3);
+ 			   __entry->dlid =
+ 			   be16_to_cpu(hdr->lrh[1]);
+ 			   /* allow for larger len */
+ 			   __entry->len =
+ 			   be16_to_cpu(hdr->lrh[2]);
+ 			   __entry->slid =
+ 			   be16_to_cpu(hdr->lrh[3]);
+ 			   /* BTH */
+ 			   if (__entry->lnh == HFI1_LRH_BTH)
+ 				ohdr = &hdr->u.oth;
+ 			   else
+ 				ohdr = &hdr->u.l.oth;
+ 			  __entry->opcode =
+ 			  (be32_to_cpu(ohdr->bth[0]) >> 24) & 0xff;
+ 			  __entry->se =
+ 			  (be32_to_cpu(ohdr->bth[0]) >> 23) & 1;
+ 			  __entry->m =
+ 			  (be32_to_cpu(ohdr->bth[0]) >> 22) & 1;
+ 			  __entry->pad =
+ 			  (be32_to_cpu(ohdr->bth[0]) >> 20) & 3;
+ 			  __entry->tver =
+ 			  (be32_to_cpu(ohdr->bth[0]) >> 16) & 0xf;
+ 			  __entry->pkey =
+ 			  be32_to_cpu(ohdr->bth[0]) & 0xffff;
+ 			  __entry->f =
+ 			  (be32_to_cpu(ohdr->bth[1]) >> HFI1_FECN_SHIFT) &
+ 			  HFI1_FECN_MASK;
+ 			  __entry->b =
+ 			  (be32_to_cpu(ohdr->bth[1]) >> HFI1_BECN_SHIFT) &
+ 			  HFI1_BECN_MASK;
+ 			  __entry->qpn =
+ 			  be32_to_cpu(ohdr->bth[1]) & RVT_QPN_MASK;
+ 			  __entry->a =
+ 			  (be32_to_cpu(ohdr->bth[2]) >> 31) & 1;
+ 			  /* allow for larger PSN */
+ 			  __entry->psn =
+ 			  be32_to_cpu(ohdr->bth[2]) & 0x7fffffff;
+ 			  /* extended headers */
+ 			  memcpy(__get_dynamic_array(ehdrs), &ohdr->u,
+ 				 ibhdr_exhdr_len(hdr));
+ 			 ),
+ 		    TP_printk("[%s] " LRH_PRN " " BTH_PRN " " EHDR_PRN,
+ 			      __get_str(dev),
+ 			      /* LRH */
+ 			      __entry->vl,
+ 			      __entry->lver,
+ 			      __entry->sl,
+ 			      __entry->lnh, show_lnh(__entry->lnh),
+ 			      __entry->dlid,
+ 			      __entry->len,
+ 			      __entry->slid,
+ 			      /* BTH */
+ 			      __entry->opcode, show_ib_opcode(__entry->opcode),
+ 			      __entry->se,
+ 			      __entry->m,
+ 			      __entry->pad,
+ 			      __entry->tver,
+ 			      __entry->pkey,
+ 			      __entry->f,
+ 			      __entry->b,
+ 			      __entry->qpn,
+ 			      __entry->a,
+ 			      __entry->psn,
+ 			      /* extended headers */
+ 			      __parse_ib_ehdrs(
+ 					__entry->opcode,
+ 					(void *)__get_dynamic_array(ehdrs))
+ 			     )
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/trace.h
  );
  
  DEFINE_EVENT(hfi1_ibhdr_template, input_ibhdr,
@@@ -556,15 -544,14 +646,15 @@@ DEFINE_EVENT(hfi1_ibhdr_template, outpu
  #undef TRACE_SYSTEM
  #define TRACE_SYSTEM hfi1_snoop
  
 +
  TRACE_EVENT(snoop_capture,
- 	TP_PROTO(struct hfi1_devdata *dd,
- 		 int hdr_len,
- 		 struct hfi1_ib_header *hdr,
- 		 int data_len,
- 		 void *data),
- 	TP_ARGS(dd, hdr_len, hdr, data_len, data),
- 	TP_STRUCT__entry(
+ 	    TP_PROTO(struct hfi1_devdata *dd,
+ 		     int hdr_len,
+ 		     struct hfi1_ib_header *hdr,
+ 		     int data_len,
+ 		     void *data),
+ 	    TP_ARGS(dd, hdr_len, hdr, data_len, data),
+ 	    TP_STRUCT__entry(
  		DD_DEV_ENTRY(dd)
  		__field(u16, slid)
  		__field(u16, dlid)
@@@ -708,52 -691,48 +794,49 @@@ TRACE_EVENT(hfi1_ctxt_info
  	)
  
  DECLARE_EVENT_CLASS(hfi1_bct_template,
- 	TP_PROTO(struct hfi1_devdata *dd, struct buffer_control *bc),
- 	TP_ARGS(dd, bc),
- 	TP_STRUCT__entry(
- 		DD_DEV_ENTRY(dd)
- 		__dynamic_array(u8, bct, sizeof(*bc))
- 	),
- 	TP_fast_assign(
- 		DD_DEV_ASSIGN(dd);
- 		memcpy(
- 			__get_dynamic_array(bct),
- 			bc,
- 			sizeof(*bc));
- 	),
- 	TP_printk(BCT_FORMAT,
- 		BCT(overall_shared_limit),
- 
- 		BCT(vl[0].dedicated),
- 		BCT(vl[0].shared),
- 
- 		BCT(vl[1].dedicated),
- 		BCT(vl[1].shared),
- 
- 		BCT(vl[2].dedicated),
- 		BCT(vl[2].shared),
- 
- 		BCT(vl[3].dedicated),
- 		BCT(vl[3].shared),
- 
- 		BCT(vl[4].dedicated),
- 		BCT(vl[4].shared),
- 
- 		BCT(vl[5].dedicated),
- 		BCT(vl[5].shared),
- 
- 		BCT(vl[6].dedicated),
- 		BCT(vl[6].shared),
- 
- 		BCT(vl[7].dedicated),
- 		BCT(vl[7].shared),
- 
- 		BCT(vl[15].dedicated),
- 		BCT(vl[15].shared)
- 	)
+ 		    TP_PROTO(struct hfi1_devdata *dd,
+ 			     struct buffer_control *bc),
+ 		    TP_ARGS(dd, bc),
+ 		    TP_STRUCT__entry(DD_DEV_ENTRY(dd)
+ 				     __dynamic_array(u8, bct, sizeof(*bc))
+ 				     ),
+ 		    TP_fast_assign(DD_DEV_ASSIGN(dd);
+ 				   memcpy(__get_dynamic_array(bct), bc,
+ 					  sizeof(*bc));
+ 				   ),
+ 		    TP_printk(BCT_FORMAT,
+ 			      BCT(overall_shared_limit),
+ 
+ 			      BCT(vl[0].dedicated),
+ 			      BCT(vl[0].shared),
+ 
+ 			      BCT(vl[1].dedicated),
+ 			      BCT(vl[1].shared),
+ 
+ 			      BCT(vl[2].dedicated),
+ 			      BCT(vl[2].shared),
+ 
+ 			      BCT(vl[3].dedicated),
+ 			      BCT(vl[3].shared),
+ 
+ 			      BCT(vl[4].dedicated),
+ 			      BCT(vl[4].shared),
+ 
+ 			      BCT(vl[5].dedicated),
+ 			      BCT(vl[5].shared),
+ 
+ 			      BCT(vl[6].dedicated),
+ 			      BCT(vl[6].shared),
+ 
+ 			      BCT(vl[7].dedicated),
+ 			      BCT(vl[7].shared),
+ 
+ 			      BCT(vl[15].dedicated),
+ 			      BCT(vl[15].shared)
+ 			      )
  );
  
 +
  DEFINE_EVENT(hfi1_bct_template, bct_set,
  	     TP_PROTO(struct hfi1_devdata *dd, struct buffer_control *bc),
  	     TP_ARGS(dd, bc));
@@@ -1254,42 -1184,42 +1288,81 @@@ TRACE_EVENT(hfi1_sdma_state
  #define TRACE_SYSTEM hfi1_rc
  
  DECLARE_EVENT_CLASS(hfi1_rc_template,
++<<<<<<< HEAD:drivers/staging/hfi1/trace.h
 +	TP_PROTO(struct hfi1_qp *qp, u32 psn),
 +	TP_ARGS(qp, psn),
 +	TP_STRUCT__entry(
 +		DD_DEV_ENTRY(dd_from_ibdev(qp->ibqp.device))
 +		__field(u32, qpn)
 +		__field(u32, s_flags)
 +		__field(u32, psn)
 +		__field(u32, s_psn)
 +		__field(u32, s_next_psn)
 +		__field(u32, s_sending_psn)
 +		__field(u32, s_sending_hpsn)
 +		__field(u32, r_psn)
 +	),
 +	TP_fast_assign(
 +		DD_DEV_ASSIGN(dd_from_ibdev(qp->ibqp.device))
 +		__entry->qpn = qp->ibqp.qp_num;
 +		__entry->s_flags = qp->s_flags;
 +		__entry->psn = psn;
 +		__entry->s_psn = qp->s_psn;
 +		__entry->s_next_psn = qp->s_next_psn;
 +		__entry->s_sending_psn = qp->s_sending_psn;
 +		__entry->s_sending_hpsn = qp->s_sending_hpsn;
 +		__entry->r_psn = qp->r_psn;
 +	),
 +	TP_printk(
 +		"[%s] qpn 0x%x s_flags 0x%x psn 0x%x s_psn 0x%x s_next_psn 0x%x s_sending_psn 0x%x sending_hpsn 0x%x r_psn 0x%x",
 +		__get_str(dev),
 +		__entry->qpn,
 +		__entry->s_flags,
 +		__entry->psn,
 +		__entry->s_psn,
 +		__entry->s_next_psn,
 +		__entry->s_sending_psn,
 +		__entry->s_sending_hpsn,
 +		__entry->r_psn
 +	)
++=======
+ 		    TP_PROTO(struct rvt_qp *qp, u32 psn),
+ 		    TP_ARGS(qp, psn),
+ 		    TP_STRUCT__entry(
+ 			DD_DEV_ENTRY(dd_from_ibdev(qp->ibqp.device))
+ 			__field(u32, qpn)
+ 			__field(u32, s_flags)
+ 			__field(u32, psn)
+ 			__field(u32, s_psn)
+ 			__field(u32, s_next_psn)
+ 			__field(u32, s_sending_psn)
+ 			__field(u32, s_sending_hpsn)
+ 			__field(u32, r_psn)
+ 			),
+ 		    TP_fast_assign(
+ 			DD_DEV_ASSIGN(dd_from_ibdev(qp->ibqp.device))
+ 			__entry->qpn = qp->ibqp.qp_num;
+ 			__entry->s_flags = qp->s_flags;
+ 			__entry->psn = psn;
+ 			__entry->s_psn = qp->s_psn;
+ 			__entry->s_next_psn = qp->s_next_psn;
+ 			__entry->s_sending_psn = qp->s_sending_psn;
+ 			__entry->s_sending_hpsn = qp->s_sending_hpsn;
+ 			__entry->r_psn = qp->r_psn;
+ 			),
+ 		    TP_printk(
+ 			"[%s] qpn 0x%x s_flags 0x%x psn 0x%x s_psn 0x%x s_next_psn 0x%x s_sending_psn 0x%x sending_hpsn 0x%x r_psn 0x%x",
+ 			__get_str(dev),
+ 			__entry->qpn,
+ 			__entry->s_flags,
+ 			__entry->psn,
+ 			__entry->s_psn,
+ 			__entry->s_next_psn,
+ 			__entry->s_sending_psn,
+ 			__entry->s_sending_hpsn,
+ 			__entry->r_psn
+ 			)
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/trace.h
  );
  
  DEFINE_EVENT(hfi1_rc_template, hfi1_rc_sendcomplete,
diff --cc drivers/staging/hfi1/ud.c
index a7f67b0111da,ea8f706cf4ec..000000000000
--- a/drivers/staging/hfi1/ud.c
+++ b/drivers/staging/hfi1/ud.c
@@@ -309,13 -316,15 +309,21 @@@ int hfi1_make_ud_req(struct hfi1_qp *qp
  	/* Construct the header. */
  	ibp = to_iport(qp->ibqp.device, qp->port_num);
  	ppd = ppd_from_ibp(ibp);
 -	ah_attr = &ibah_to_rvtah(wqe->ud_wr.ah)->attr;
 -	if (ah_attr->dlid < be16_to_cpu(IB_MULTICAST_LID_BASE) ||
 -	    ah_attr->dlid == be16_to_cpu(IB_LID_PERMISSIVE)) {
 +	ah_attr = &to_iah(wqe->wr.wr.ud.ah)->attr;
 +	if (ah_attr->dlid < HFI1_MULTICAST_LID_BASE ||
 +	    ah_attr->dlid == HFI1_PERMISSIVE_LID) {
  		lid = ah_attr->dlid & ~((1 << ppd->lmc) - 1);
++<<<<<<< HEAD:drivers/staging/hfi1/ud.c
 +		if (unlikely(!loopback && (lid == ppd->lid ||
 +		    (lid == HFI1_PERMISSIVE_LID &&
 +		     qp->ibqp.qp_type == IB_QPT_GSI)))) {
++=======
+ 		if (unlikely(!loopback &&
+ 			     (lid == ppd->lid ||
+ 			      (lid == be16_to_cpu(IB_LID_PERMISSIVE) &&
+ 			      qp->ibqp.qp_type == IB_QPT_GSI)))) {
+ 			unsigned long flags;
++>>>>>>> 17fb4f2923d7 (staging/rdma/hfi1: Fix code alignment):drivers/staging/rdma/hfi1/ud.c
  			/*
  			 * If DMAs are in progress, we can't generate
  			 * a completion for the loopback packet since
* Unmerged path drivers/staging/hfi1/chip.c
* Unmerged path drivers/staging/hfi1/debugfs.c
* Unmerged path drivers/staging/hfi1/driver.c
diff --git a/drivers/staging/hfi1/eprom.c b/drivers/staging/hfi1/eprom.c
index 4668c094ceef..714a94e74cdc 100644
--- a/drivers/staging/hfi1/eprom.c
+++ b/drivers/staging/hfi1/eprom.c
@@ -117,11 +117,9 @@ static int eprom_available;	/* default: not available */
 static void write_enable(struct hfi1_devdata *dd)
 {
 	/* raise signal */
-	write_csr(dd, ASIC_GPIO_OUT,
-		read_csr(dd, ASIC_GPIO_OUT) | EPROM_WP_N);
+	write_csr(dd, ASIC_GPIO_OUT, read_csr(dd, ASIC_GPIO_OUT) | EPROM_WP_N);
 	/* raise enable */
-	write_csr(dd, ASIC_GPIO_OE,
-		read_csr(dd, ASIC_GPIO_OE) | EPROM_WP_N);
+	write_csr(dd, ASIC_GPIO_OE, read_csr(dd, ASIC_GPIO_OE) | EPROM_WP_N);
 }
 
 /*
@@ -130,11 +128,9 @@ static void write_enable(struct hfi1_devdata *dd)
 static void write_disable(struct hfi1_devdata *dd)
 {
 	/* lower signal */
-	write_csr(dd, ASIC_GPIO_OUT,
-		read_csr(dd, ASIC_GPIO_OUT) & ~EPROM_WP_N);
+	write_csr(dd, ASIC_GPIO_OUT, read_csr(dd, ASIC_GPIO_OUT) & ~EPROM_WP_N);
 	/* lower enable */
-	write_csr(dd, ASIC_GPIO_OE,
-		read_csr(dd, ASIC_GPIO_OE) & ~EPROM_WP_N);
+	write_csr(dd, ASIC_GPIO_OE, read_csr(dd, ASIC_GPIO_OE) & ~EPROM_WP_N);
 }
 
 /*
@@ -212,8 +208,8 @@ static int erase_range(struct hfi1_devdata *dd, u32 start, u32 len)
 	/* check the end points for the minimum erase */
 	if ((start & MASK_4KB) || (end & MASK_4KB)) {
 		dd_dev_err(dd,
-			"%s: non-aligned range (0x%x,0x%x) for a 4KB erase\n",
-			__func__, start, end);
+			   "%s: non-aligned range (0x%x,0x%x) for a 4KB erase\n",
+			   __func__, start, end);
 		return -EINVAL;
 	}
 
@@ -277,7 +273,7 @@ static int read_length(struct hfi1_devdata *dd, u32 start, u32 len, u64 addr)
 	for (offset = 0; offset < len; offset += EP_PAGE_SIZE) {
 		read_page(dd, start + offset, buffer);
 		if (copy_to_user((void __user *)(addr + offset),
-						buffer, EP_PAGE_SIZE)) {
+				 buffer, EP_PAGE_SIZE)) {
 			ret = -EFAULT;
 			goto done;
 		}
@@ -321,7 +317,7 @@ static int write_length(struct hfi1_devdata *dd, u32 start, u32 len, u64 addr)
 
 	for (offset = 0; offset < len; offset += EP_PAGE_SIZE) {
 		if (copy_from_user(buffer, (void __user *)(addr + offset),
-						EP_PAGE_SIZE)) {
+				   EP_PAGE_SIZE)) {
 			ret = -EFAULT;
 			goto done;
 		}
@@ -389,13 +385,13 @@ int handle_eprom_command(struct file *fp, const struct hfi1_cmd *cmd)
 	ret = acquire_hw_mutex(dd);
 	if (ret) {
 		dd_dev_err(dd,
-			"%s: unable to acquire hw mutex, no EPROM support\n",
-			__func__);
+			   "%s: unable to acquire hw mutex, no EPROM support\n",
+			   __func__);
 		goto done_asic;
 	}
 
 	dd_dev_info(dd, "%s: cmd: type %d, len 0x%x, addr 0x%016llx\n",
-		__func__, cmd->type, cmd->len, cmd->addr);
+		    __func__, cmd->type, cmd->len, cmd->addr);
 
 	switch (cmd->type) {
 	case HFI1_CMD_EP_INFO:
@@ -406,7 +402,7 @@ int handle_eprom_command(struct file *fp, const struct hfi1_cmd *cmd)
 		dev_id = read_device_id(dd);
 		/* addr points to a u32 user buffer */
 		if (copy_to_user((void __user *)cmd->addr, &dev_id,
-								sizeof(u32)))
+				 sizeof(u32)))
 			ret = -EFAULT;
 		break;
 
@@ -434,7 +430,7 @@ int handle_eprom_command(struct file *fp, const struct hfi1_cmd *cmd)
 
 	default:
 		dd_dev_err(dd, "%s: unexpected command %d\n",
-			__func__, cmd->type);
+			   __func__, cmd->type);
 		ret = -EINVAL;
 		break;
 	}
@@ -470,19 +466,18 @@ int eprom_init(struct hfi1_devdata *dd)
 	ret = acquire_hw_mutex(dd);
 	if (ret) {
 		dd_dev_err(dd,
-			"%s: unable to acquire hw mutex, no EPROM support\n",
-			__func__);
+			   "%s: unable to acquire hw mutex, no EPROM support\n",
+			   __func__);
 		goto done_asic;
 	}
 
 	/* reset EPROM to be sure it is in a good state */
 
 	/* set reset */
-	write_csr(dd, ASIC_EEP_CTL_STAT,
-					ASIC_EEP_CTL_STAT_EP_RESET_SMASK);
+	write_csr(dd, ASIC_EEP_CTL_STAT, ASIC_EEP_CTL_STAT_EP_RESET_SMASK);
 	/* clear reset, set speed */
 	write_csr(dd, ASIC_EEP_CTL_STAT,
-			EP_SPEED_FULL << ASIC_EEP_CTL_STAT_RATE_SPI_SHIFT);
+		  EP_SPEED_FULL << ASIC_EEP_CTL_STAT_RATE_SPI_SHIFT);
 
 	/* wake the device with command "release powerdown NoID" */
 	write_csr(dd, ASIC_EEP_ADDR_CMD, CMD_RELEASE_POWERDOWN_NOID);
* Unmerged path drivers/staging/hfi1/file_ops.c
* Unmerged path drivers/staging/hfi1/firmware.c
diff --git a/drivers/staging/hfi1/hfi.h b/drivers/staging/hfi1/hfi.h
index 6438dccf5749..e96c4a869979 100644
--- a/drivers/staging/hfi1/hfi.h
+++ b/drivers/staging/hfi1/hfi.h
@@ -1676,8 +1676,9 @@ void restore_pci_variables(struct hfi1_devdata *dd);
 int do_pcie_gen3_transition(struct hfi1_devdata *dd);
 int parse_platform_config(struct hfi1_devdata *dd);
 int get_platform_config_field(struct hfi1_devdata *dd,
-			enum platform_config_table_type_encoding table_type,
-			int table_index, int field_index, u32 *data, u32 len);
+			      enum platform_config_table_type_encoding
+			      table_type, int table_index, int field_index,
+			      u32 *data, u32 len);
 
 dma_addr_t hfi1_map_page(struct pci_dev *, struct page *, unsigned long,
 			 size_t, int);
diff --git a/drivers/staging/hfi1/init.c b/drivers/staging/hfi1/init.c
index c64c8dd680db..29cfd7779560 100644
--- a/drivers/staging/hfi1/init.c
+++ b/drivers/staging/hfi1/init.c
@@ -151,7 +151,7 @@ int hfi1_create_ctxts(struct hfi1_devdata *dd)
 		rcd = hfi1_create_ctxtdata(ppd, i);
 		if (!rcd) {
 			dd_dev_err(dd,
-				"Unable to allocate kernel receive context, failing\n");
+				   "Unable to allocate kernel receive context, failing\n");
 			goto nomem;
 		}
 		/*
@@ -172,7 +172,7 @@ int hfi1_create_ctxts(struct hfi1_devdata *dd)
 		rcd->sc = sc_alloc(dd, SC_ACK, rcd->rcvhdrqentsize, dd->node);
 		if (!rcd->sc) {
 			dd_dev_err(dd,
-				"Unable to allocate kernel send context, failing\n");
+				   "Unable to allocate kernel send context, failing\n");
 			dd->rcd[rcd->ctxt] = NULL;
 			hfi1_free_ctxtdata(dd, rcd);
 			goto nomem;
@@ -733,7 +733,7 @@ int hfi1_init(struct hfi1_devdata *dd, int reinit)
 			lastfail = hfi1_setup_eagerbufs(rcd);
 		if (lastfail)
 			dd_dev_err(dd,
-				"failed to allocate kernel ctxt's rcvhdrq and/or egr bufs\n");
+				   "failed to allocate kernel ctxt's rcvhdrq and/or egr bufs\n");
 	}
 	if (lastfail)
 		ret = lastfail;
@@ -795,8 +795,8 @@ done:
 			lastfail = bringup_serdes(ppd);
 			if (lastfail)
 				dd_dev_info(dd,
-					"Failed to bring up port %u\n",
-					ppd->port);
+					    "Failed to bring up port %u\n",
+					    ppd->port);
 
 			/*
 			 * Set status even if port serdes is not initialized
@@ -1532,8 +1532,8 @@ int hfi1_create_rcvhdrq(struct hfi1_devdata *dd, struct hfi1_ctxtdata *rcd)
 
 		if (!rcd->rcvhdrq) {
 			dd_dev_err(dd,
-				"attempt to allocate %d bytes for ctxt %u rcvhdrq failed\n",
-				amt, rcd->ctxt);
+				   "attempt to allocate %d bytes for ctxt %u rcvhdrq failed\n",
+				   amt, rcd->ctxt);
 			goto bail;
 		}
 
@@ -1577,8 +1577,8 @@ int hfi1_create_rcvhdrq(struct hfi1_devdata *dd, struct hfi1_ctxtdata *rcd)
 
 bail_free:
 	dd_dev_err(dd,
-		"attempt to allocate 1 page for ctxt %u rcvhdrqtailaddr failed\n",
-		rcd->ctxt);
+		   "attempt to allocate 1 page for ctxt %u rcvhdrqtailaddr failed\n",
+		   rcd->ctxt);
 	vfree(rcd->user_event_mask);
 	rcd->user_event_mask = NULL;
 	dma_free_coherent(&dd->pcidev->dev, amt, rcd->rcvhdrq,
@@ -1668,7 +1668,7 @@ int hfi1_setup_eagerbufs(struct hfi1_ctxtdata *rcd)
 			if (rcd->egrbufs.rcvtid_size == round_mtu ||
 			    !HFI1_CAP_KGET_MASK(rcd->flags, MULTI_PKT_EGR)) {
 				dd_dev_err(dd, "ctxt%u: Failed to allocate eager buffers\n",
-					rcd->ctxt);
+					   rcd->ctxt);
 				goto bail_rcvegrbuf_phys;
 			}
 
@@ -1751,14 +1751,14 @@ int hfi1_setup_eagerbufs(struct hfi1_ctxtdata *rcd)
 
 	for (idx = 0; idx < rcd->egrbufs.alloced; idx++) {
 		hfi1_put_tid(dd, rcd->eager_base + idx, PT_EAGER,
-			      rcd->egrbufs.rcvtids[idx].phys, order);
+			     rcd->egrbufs.rcvtids[idx].phys, order);
 		cond_resched();
 	}
 	goto bail;
 
 bail_rcvegrbuf_phys:
 	for (idx = 0; idx < rcd->egrbufs.alloced &&
-		     rcd->egrbufs.buffers[idx].addr;
+	     rcd->egrbufs.buffers[idx].addr;
 	     idx++) {
 		dma_free_coherent(&dd->pcidev->dev,
 				  rcd->egrbufs.buffers[idx].len,
diff --git a/drivers/staging/hfi1/intr.c b/drivers/staging/hfi1/intr.c
index 75a0fb55e7a2..757dc7070b80 100644
--- a/drivers/staging/hfi1/intr.c
+++ b/drivers/staging/hfi1/intr.c
@@ -136,18 +136,16 @@ void handle_linkup_change(struct hfi1_devdata *dd, u32 linkup)
 			set_up_vl15(dd, dd->vau, dd->vl15_init);
 			assign_remote_cm_au_table(dd, dd->vcu);
 			ppd->neighbor_guid =
-				read_csr(dd,
-					DC_DC8051_STS_REMOTE_GUID);
+				read_csr(dd, DC_DC8051_STS_REMOTE_GUID);
 			ppd->neighbor_type =
 				read_csr(dd, DC_DC8051_STS_REMOTE_NODE_TYPE) &
 					DC_DC8051_STS_REMOTE_NODE_TYPE_VAL_MASK;
 			ppd->neighbor_port_number =
 				read_csr(dd, DC_DC8051_STS_REMOTE_PORT_NO) &
-					DC_DC8051_STS_REMOTE_PORT_NO_VAL_SMASK;
-			dd_dev_info(dd,
-				"Neighbor GUID: %llx Neighbor type %d\n",
-				ppd->neighbor_guid,
-				ppd->neighbor_type);
+					 DC_DC8051_STS_REMOTE_PORT_NO_VAL_SMASK;
+			dd_dev_info(dd, "Neighbor GUID: %llx Neighbor type %d\n",
+				    ppd->neighbor_guid,
+				    ppd->neighbor_type);
 		}
 
 		/* physical link went up */
* Unmerged path drivers/staging/hfi1/mad.c
* Unmerged path drivers/staging/hfi1/pcie.c
diff --git a/drivers/staging/hfi1/pio.c b/drivers/staging/hfi1/pio.c
index 1d987a3b7c8d..bff68b668817 100644
--- a/drivers/staging/hfi1/pio.c
+++ b/drivers/staging/hfi1/pio.c
@@ -509,7 +509,7 @@ static void sc_hw_free(struct hfi1_devdata *dd, u32 sw_index, u32 hw_context)
 	sci = &dd->send_contexts[sw_index];
 	if (!sci->allocated) {
 		dd_dev_err(dd, "%s: sw_index %u not allocated? hw_context %u\n",
-			__func__, sw_index, hw_context);
+			   __func__, sw_index, hw_context);
 	}
 	sci->allocated = 0;
 	dd->hw_to_sw[hw_context] = INVALID_SCI;
@@ -625,7 +625,7 @@ void sc_set_cr_threshold(struct send_context *sc, u32 new_threshold)
 				& SC(CREDIT_CTRL_THRESHOLD_MASK))
 			   << SC(CREDIT_CTRL_THRESHOLD_SHIFT));
 		write_kctxt_csr(sc->dd, sc->hw_context,
-			SC(CREDIT_CTRL), sc->credit_ctrl);
+				SC(CREDIT_CTRL), sc->credit_ctrl);
 
 		/* force a credit return on change to avoid a possible stall */
 		force_return = 1;
@@ -763,9 +763,9 @@ struct send_context *sc_alloc(struct hfi1_devdata *dd, int type,
 
 	/* set the default partition key */
 	write_kctxt_csr(dd, hw_context, SC(CHECK_PARTITION_KEY),
-		(DEFAULT_PKEY &
-			SC(CHECK_PARTITION_KEY_VALUE_MASK))
-		    << SC(CHECK_PARTITION_KEY_VALUE_SHIFT));
+			(DEFAULT_PKEY &
+			 SC(CHECK_PARTITION_KEY_VALUE_MASK)) <<
+			SC(CHECK_PARTITION_KEY_VALUE_SHIFT));
 
 	/* per context type checks */
 	if (type == SC_USER) {
@@ -778,8 +778,8 @@ struct send_context *sc_alloc(struct hfi1_devdata *dd, int type,
 
 	/* set the send context check opcode mask and value */
 	write_kctxt_csr(dd, hw_context, SC(CHECK_OPCODE),
-		((u64)opmask << SC(CHECK_OPCODE_MASK_SHIFT)) |
-		((u64)opval << SC(CHECK_OPCODE_VALUE_SHIFT)));
+			((u64)opmask << SC(CHECK_OPCODE_MASK_SHIFT)) |
+			((u64)opval << SC(CHECK_OPCODE_VALUE_SHIFT)));
 
 	/* set up credit return */
 	reg = pa & SC(CREDIT_RETURN_ADDR_ADDRESS_SMASK);
@@ -797,7 +797,7 @@ struct send_context *sc_alloc(struct hfi1_devdata *dd, int type,
 		thresh = sc_percent_to_threshold(sc, 50);
 	} else if (type == SC_USER) {
 		thresh = sc_percent_to_threshold(sc,
-				user_credit_return_threshold);
+						 user_credit_return_threshold);
 	} else { /* kernel */
 		thresh = sc_mtu_to_threshold(sc, hfi1_max_mtu, hdrqentsize);
 	}
@@ -971,11 +971,11 @@ static void sc_wait_for_packet_egress(struct send_context *sc, int pause)
 		if (loop > 500) {
 			/* timed out - bounce the link */
 			dd_dev_err(dd,
-				"%s: context %u(%u) timeout waiting for packets to egress, remaining count %u, bouncing link\n",
-				__func__, sc->sw_index,
-				sc->hw_context, (u32)reg);
+				   "%s: context %u(%u) timeout waiting for packets to egress, remaining count %u, bouncing link\n",
+				   __func__, sc->sw_index,
+				   sc->hw_context, (u32)reg);
 			queue_work(dd->pport->hfi1_wq,
-				&dd->pport->link_bounce_work);
+				   &dd->pport->link_bounce_work);
 			break;
 		}
 		loop++;
@@ -1021,7 +1021,7 @@ int sc_restart(struct send_context *sc)
 		return -EINVAL;
 
 	dd_dev_info(dd, "restarting send context %u(%u)\n", sc->sw_index,
-		sc->hw_context);
+		    sc->hw_context);
 
 	/*
 	 * Step 1: Wait for the context to actually halt.
@@ -1036,7 +1036,7 @@ int sc_restart(struct send_context *sc)
 			break;
 		if (loop > 100) {
 			dd_dev_err(dd, "%s: context %u(%u) not halting, skipping\n",
-				__func__, sc->sw_index, sc->hw_context);
+				   __func__, sc->sw_index, sc->hw_context);
 			return -ETIME;
 		}
 		loop++;
@@ -1062,9 +1062,9 @@ int sc_restart(struct send_context *sc)
 				break;
 			if (loop > 100) {
 				dd_dev_err(dd,
-					"%s: context %u(%u) timeout waiting for PIO buffers to zero, remaining %d\n",
-					__func__, sc->sw_index,
-					sc->hw_context, count);
+					   "%s: context %u(%u) timeout waiting for PIO buffers to zero, remaining %d\n",
+					   __func__, sc->sw_index,
+					   sc->hw_context, count);
 			}
 			loop++;
 			udelay(1);
@@ -1177,18 +1177,18 @@ void pio_reset_all(struct hfi1_devdata *dd)
 	if (ret == -EIO) {
 		/* clear the error */
 		write_csr(dd, SEND_PIO_ERR_CLEAR,
-			SEND_PIO_ERR_CLEAR_PIO_INIT_SM_IN_ERR_SMASK);
+			  SEND_PIO_ERR_CLEAR_PIO_INIT_SM_IN_ERR_SMASK);
 	}
 
 	/* reset init all */
 	write_csr(dd, SEND_PIO_INIT_CTXT,
-			SEND_PIO_INIT_CTXT_PIO_ALL_CTXT_INIT_SMASK);
+		  SEND_PIO_INIT_CTXT_PIO_ALL_CTXT_INIT_SMASK);
 	udelay(2);
 	ret = pio_init_wait_progress(dd);
 	if (ret < 0) {
 		dd_dev_err(dd,
-			"PIO send context init %s while initializing all PIO blocks\n",
-			ret == -ETIMEDOUT ? "is stuck" : "had an error");
+			   "PIO send context init %s while initializing all PIO blocks\n",
+			   ret == -ETIMEDOUT ? "is stuck" : "had an error");
 	}
 }
 
@@ -1236,8 +1236,7 @@ int sc_enable(struct send_context *sc)
 	 */
 	reg = read_kctxt_csr(dd, sc->hw_context, SC(ERR_STATUS));
 	if (reg)
-		write_kctxt_csr(dd, sc->hw_context, SC(ERR_CLEAR),
-			reg);
+		write_kctxt_csr(dd, sc->hw_context, SC(ERR_CLEAR), reg);
 
 	/*
 	 * The HW PIO initialization engine can handle only one init
@@ -1295,7 +1294,7 @@ void sc_return_credits(struct send_context *sc)
 
 	/* a 0->1 transition schedules a credit return */
 	write_kctxt_csr(sc->dd, sc->hw_context, SC(CREDIT_FORCE),
-		SC(CREDIT_FORCE_FORCE_RETURN_SMASK));
+			SC(CREDIT_FORCE_FORCE_RETURN_SMASK));
 	/*
 	 * Ensure that the write is flushed and the credit return is
 	 * scheduled. We care more about the 0 -> 1 transition.
@@ -1321,7 +1320,7 @@ void sc_drop(struct send_context *sc)
 		return;
 
 	dd_dev_info(sc->dd, "%s: context %u(%u) - not implemented\n",
-			__func__, sc->sw_index, sc->hw_context);
+		    __func__, sc->sw_index, sc->hw_context);
 }
 
 /*
@@ -1469,7 +1468,7 @@ void sc_add_credit_return_intr(struct send_context *sc)
 	if (sc->credit_intr_count == 0) {
 		sc->credit_ctrl |= SC(CREDIT_CTRL_CREDIT_INTR_SMASK);
 		write_kctxt_csr(sc->dd, sc->hw_context,
-			SC(CREDIT_CTRL), sc->credit_ctrl);
+				SC(CREDIT_CTRL), sc->credit_ctrl);
 	}
 	sc->credit_intr_count++;
 	spin_unlock_irqrestore(&sc->credit_ctrl_lock, flags);
@@ -1491,7 +1490,7 @@ void sc_del_credit_return_intr(struct send_context *sc)
 	if (sc->credit_intr_count == 0) {
 		sc->credit_ctrl &= ~SC(CREDIT_CTRL_CREDIT_INTR_SMASK);
 		write_kctxt_csr(sc->dd, sc->hw_context,
-			SC(CREDIT_CTRL), sc->credit_ctrl);
+				SC(CREDIT_CTRL), sc->credit_ctrl);
 	}
 	spin_unlock_irqrestore(&sc->credit_ctrl_lock, flags);
 }
@@ -1663,7 +1662,7 @@ void sc_group_release_update(struct hfi1_devdata *dd, u32 hw_context)
 	sw_index = dd->hw_to_sw[hw_context];
 	if (unlikely(sw_index >= dd->num_send_contexts)) {
 		dd_dev_err(dd, "%s: invalid hw (%u) to sw (%u) mapping\n",
-			__func__, hw_context, sw_index);
+			   __func__, hw_context, sw_index);
 		goto done;
 	}
 	sc = dd->send_contexts[sw_index].sc;
@@ -1676,8 +1675,8 @@ void sc_group_release_update(struct hfi1_devdata *dd, u32 hw_context)
 		sw_index = dd->hw_to_sw[gc];
 		if (unlikely(sw_index >= dd->num_send_contexts)) {
 			dd_dev_err(dd,
-				"%s: invalid hw (%u) to sw (%u) mapping\n",
-				__func__, hw_context, sw_index);
+				   "%s: invalid hw (%u) to sw (%u) mapping\n",
+				   __func__, hw_context, sw_index);
 			continue;
 		}
 		sc_release_update(dd->send_contexts[sw_index].sc);
@@ -1774,8 +1773,8 @@ int init_credit_return(struct hfi1_devdata *dd)
 		if (dd->cr_base[i].va == NULL) {
 			set_dev_node(&dd->pcidev->dev, dd->node);
 			dd_dev_err(dd,
-				"Unable to allocate credit return DMA range for NUMA %d\n",
-				i);
+				   "Unable to allocate credit return DMA range for NUMA %d\n",
+				   i);
 			ret = -ENOMEM;
 			goto done;
 		}
@@ -1799,10 +1798,10 @@ void free_credit_return(struct hfi1_devdata *dd)
 	for (i = 0; i < num_numa; i++) {
 		if (dd->cr_base[i].va) {
 			dma_free_coherent(&dd->pcidev->dev,
-				TXE_NUM_CONTEXTS
-					* sizeof(struct credit_return),
-				dd->cr_base[i].va,
-				dd->cr_base[i].pa);
+					  TXE_NUM_CONTEXTS *
+					  sizeof(struct credit_return),
+					  dd->cr_base[i].va,
+					  dd->cr_base[i].pa);
 		}
 	}
 	kfree(dd->cr_base);
diff --git a/drivers/staging/hfi1/pio.h b/drivers/staging/hfi1/pio.h
index c2498f71658f..df375e64fed7 100644
--- a/drivers/staging/hfi1/pio.h
+++ b/drivers/staging/hfi1/pio.h
@@ -184,7 +184,7 @@ void sc_flush(struct send_context *sc);
 void sc_drop(struct send_context *sc);
 void sc_stop(struct send_context *sc, int bit);
 struct pio_buf *sc_buffer_alloc(struct send_context *sc, u32 dw_len,
-			pio_release_cb cb, void *arg);
+				pio_release_cb cb, void *arg);
 void sc_release_update(struct send_context *sc);
 void sc_return_credits(struct send_context *sc);
 void sc_group_release_update(struct hfi1_devdata *dd, u32 hw_context);
@@ -218,7 +218,7 @@ void pio_send_control(struct hfi1_devdata *dd, int op);
 void pio_copy(struct hfi1_devdata *dd, struct pio_buf *pbuf, u64 pbc,
 	      const void *from, size_t count);
 void seg_pio_copy_start(struct pio_buf *pbuf, u64 pbc,
-					const void *from, size_t nbytes);
+			const void *from, size_t nbytes);
 void seg_pio_copy_mid(struct pio_buf *pbuf, const void *from, size_t nbytes);
 void seg_pio_copy_end(struct pio_buf *pbuf);
 
diff --git a/drivers/staging/hfi1/pio_copy.c b/drivers/staging/hfi1/pio_copy.c
index ebb0bafc68cb..804f7165cd4f 100644
--- a/drivers/staging/hfi1/pio_copy.c
+++ b/drivers/staging/hfi1/pio_copy.c
@@ -196,7 +196,7 @@ void pio_copy(struct hfi1_devdata *dd, struct pio_buf *pbuf, u64 pbc,
  * o nbytes must not span a QW boundary
  */
 static inline void read_low_bytes(struct pio_buf *pbuf, const void *from,
-							unsigned int nbytes)
+				  unsigned int nbytes)
 {
 	unsigned long off;
 
@@ -223,7 +223,7 @@ static inline void read_low_bytes(struct pio_buf *pbuf, const void *from,
  * o nbytes may span a QW boundary
  */
 static inline void read_extra_bytes(struct pio_buf *pbuf,
-					const void *from, unsigned int nbytes)
+				    const void *from, unsigned int nbytes)
 {
 	unsigned long off = (unsigned long)from & 0x7;
 	unsigned int room, xbytes;
@@ -362,7 +362,7 @@ static inline void jcopy(u8 *dest, const u8 *src, u32 n)
  * o from may _not_ be u64 aligned.
  */
 static inline void read_low_bytes(struct pio_buf *pbuf, const void *from,
-							unsigned int nbytes)
+				  unsigned int nbytes)
 {
 	jcopy(&pbuf->carry.val8[0], from, nbytes);
 	pbuf->carry_bytes = nbytes;
@@ -377,7 +377,7 @@ static inline void read_low_bytes(struct pio_buf *pbuf, const void *from,
  * o nbytes may span a QW boundary
  */
 static inline void read_extra_bytes(struct pio_buf *pbuf,
-					const void *from, unsigned int nbytes)
+				    const void *from, unsigned int nbytes)
 {
 	jcopy(&pbuf->carry.val8[pbuf->carry_bytes], from, nbytes);
 	pbuf->carry_bytes += nbytes;
@@ -433,7 +433,7 @@ static inline int carry_write8(struct pio_buf *pbuf, void *dest)
 		u64 zero = 0;
 
 		jcopy(&pbuf->carry.val8[pbuf->carry_bytes], (u8 *)&zero,
-						8 - pbuf->carry_bytes);
+		      8 - pbuf->carry_bytes);
 		writeq(pbuf->carry.val64, dest);
 		return 1;
 	}
@@ -453,7 +453,7 @@ static inline int carry_write8(struct pio_buf *pbuf, void *dest)
  * @nbytes: bytes to copy
  */
 void seg_pio_copy_start(struct pio_buf *pbuf, u64 pbc,
-				const void *from, size_t nbytes)
+			const void *from, size_t nbytes)
 {
 	void __iomem *dest = pbuf->start + SOP_DISTANCE;
 	void __iomem *send = dest + PIO_BLOCK_SIZE;
@@ -639,7 +639,7 @@ static void mid_copy_mix(struct pio_buf *pbuf, const void *from, size_t nbytes)
  * Must handle nbytes < 8.
  */
 static void mid_copy_straight(struct pio_buf *pbuf,
-						const void *from, size_t nbytes)
+			      const void *from, size_t nbytes)
 {
 	void __iomem *dest = pbuf->start + (pbuf->qw_written * sizeof(u64));
 	void __iomem *dend;			/* 8-byte data end */
diff --git a/drivers/staging/hfi1/qsfp.c b/drivers/staging/hfi1/qsfp.c
index c9d1e64ef681..dc6bb0799045 100644
--- a/drivers/staging/hfi1/qsfp.c
+++ b/drivers/staging/hfi1/qsfp.c
@@ -470,7 +470,7 @@ int get_cable_info(struct hfi1_devdata *dd, u32 port_num, u32 addr, u32 len,
 
 	if (port_num > dd->num_pports || port_num < 1) {
 		dd_dev_info(dd, "%s: Invalid port number %d\n",
-				__func__, port_num);
+			    __func__, port_num);
 		ret = -EINVAL;
 		goto set_zeroes;
 	}
* Unmerged path drivers/staging/hfi1/rc.c
diff --git a/drivers/staging/hfi1/ruc.c b/drivers/staging/hfi1/ruc.c
index c4280b6f47d4..90b5298d0f14 100644
--- a/drivers/staging/hfi1/ruc.c
+++ b/drivers/staging/hfi1/ruc.c
@@ -281,9 +281,10 @@ int hfi1_ruc_check_hdr(struct hfi1_ibport *ibp, struct hfi1_ib_header *hdr,
 			guid = get_sguid(ibp, qp->alt_ah_attr.grh.sgid_index);
 			if (!gid_ok(&hdr->u.l.grh.dgid, ibp->gid_prefix, guid))
 				goto err;
-			if (!gid_ok(&hdr->u.l.grh.sgid,
-			    qp->alt_ah_attr.grh.dgid.global.subnet_prefix,
-			    qp->alt_ah_attr.grh.dgid.global.interface_id))
+			if (!gid_ok(
+				&hdr->u.l.grh.sgid,
+				qp->alt_ah_attr.grh.dgid.global.subnet_prefix,
+				qp->alt_ah_attr.grh.dgid.global.interface_id))
 				goto err;
 		}
 		if (unlikely(rcv_pkey_check(ppd_from_ibp(ibp), (u16)bth0,
@@ -314,9 +315,10 @@ int hfi1_ruc_check_hdr(struct hfi1_ibport *ibp, struct hfi1_ib_header *hdr,
 					 qp->remote_ah_attr.grh.sgid_index);
 			if (!gid_ok(&hdr->u.l.grh.dgid, ibp->gid_prefix, guid))
 				goto err;
-			if (!gid_ok(&hdr->u.l.grh.sgid,
-			    qp->remote_ah_attr.grh.dgid.global.subnet_prefix,
-			    qp->remote_ah_attr.grh.dgid.global.interface_id))
+			if (!gid_ok(
+			     &hdr->u.l.grh.sgid,
+			     qp->remote_ah_attr.grh.dgid.global.subnet_prefix,
+			     qp->remote_ah_attr.grh.dgid.global.interface_id))
 				goto err;
 		}
 		if (unlikely(rcv_pkey_check(ppd_from_ibp(ibp), (u16)bth0,
* Unmerged path drivers/staging/hfi1/sdma.c
diff --git a/drivers/staging/hfi1/sysfs.c b/drivers/staging/hfi1/sysfs.c
index 1645ca8a2c0f..335ba71b2cdd 100644
--- a/drivers/staging/hfi1/sysfs.c
+++ b/drivers/staging/hfi1/sysfs.c
@@ -62,8 +62,8 @@
  * Congestion control table size followed by table entries
  */
 static ssize_t read_cc_table_bin(struct file *filp, struct kobject *kobj,
-		struct bin_attribute *bin_attr,
-		char *buf, loff_t pos, size_t count)
+				 struct bin_attribute *bin_attr,
+				 char *buf, loff_t pos, size_t count)
 {
 	int ret;
 	struct hfi1_pportdata *ppd =
@@ -115,8 +115,8 @@ static struct bin_attribute cc_table_bin_attr = {
  * trigger threshold and the minimum injection rate delay.
  */
 static ssize_t read_cc_setting_bin(struct file *filp, struct kobject *kobj,
-		struct bin_attribute *bin_attr,
-		char *buf, loff_t pos, size_t count)
+				   struct bin_attribute *bin_attr,
+				   char *buf, loff_t pos, size_t count)
 {
 	int ret;
 	struct hfi1_pportdata *ppd =
@@ -515,7 +515,7 @@ static ssize_t show_nctxts(struct device *device,
 }
 
 static ssize_t show_nfreectxts(struct device *device,
-			   struct device_attribute *attr, char *buf)
+			       struct device_attribute *attr, char *buf)
 {
 	struct hfi1_ibdev *dev =
 		container_of(device, struct hfi1_ibdev, ibdev.dev);
@@ -630,8 +630,8 @@ int hfi1_create_port_files(struct ib_device *ibdev, u8 port_num,
 
 	if (!port_num || port_num > dd->num_pports) {
 		dd_dev_err(dd,
-			"Skipping infiniband class with invalid port %u\n",
-			port_num);
+			   "Skipping infiniband class with invalid port %u\n",
+			   port_num);
 		return -ENODEV;
 	}
 	ppd = &dd->pport[port_num - 1];
@@ -671,34 +671,32 @@ int hfi1_create_port_files(struct ib_device *ibdev, u8 port_num,
 				   kobj, "CCMgtA");
 	if (ret) {
 		dd_dev_err(dd,
-		 "Skipping Congestion Control sysfs info, (err %d) port %u\n",
-		 ret, port_num);
+			   "Skipping Congestion Control sysfs info, (err %d) port %u\n",
+			   ret, port_num);
 		goto bail_vl2mtu;
 	}
 
 	kobject_uevent(&ppd->pport_cc_kobj, KOBJ_ADD);
 
-	ret = sysfs_create_bin_file(&ppd->pport_cc_kobj,
-				&cc_setting_bin_attr);
+	ret = sysfs_create_bin_file(&ppd->pport_cc_kobj, &cc_setting_bin_attr);
 	if (ret) {
 		dd_dev_err(dd,
-		 "Skipping Congestion Control setting sysfs info, (err %d) port %u\n",
-		 ret, port_num);
+			   "Skipping Congestion Control setting sysfs info, (err %d) port %u\n",
+			   ret, port_num);
 		goto bail_cc;
 	}
 
-	ret = sysfs_create_bin_file(&ppd->pport_cc_kobj,
-				&cc_table_bin_attr);
+	ret = sysfs_create_bin_file(&ppd->pport_cc_kobj, &cc_table_bin_attr);
 	if (ret) {
 		dd_dev_err(dd,
-		 "Skipping Congestion Control table sysfs info, (err %d) port %u\n",
-		 ret, port_num);
+			   "Skipping Congestion Control table sysfs info, (err %d) port %u\n",
+			   ret, port_num);
 		goto bail_cc_entry_bin;
 	}
 
 	dd_dev_info(dd,
-		"IB%u: Congestion Control Agent enabled for port %d\n",
-		dd->unit, port_num);
+		    "IB%u: Congestion Control Agent enabled for port %d\n",
+		    dd->unit, port_num);
 
 	return 0;
 
* Unmerged path drivers/staging/hfi1/trace.c
* Unmerged path drivers/staging/hfi1/trace.h
diff --git a/drivers/staging/hfi1/twsi.c b/drivers/staging/hfi1/twsi.c
index d7dfdd231669..6c7f198299f6 100644
--- a/drivers/staging/hfi1/twsi.c
+++ b/drivers/staging/hfi1/twsi.c
@@ -131,7 +131,7 @@ static void scl_out(struct hfi1_devdata *dd, u32 target, u8 bit)
 		}
 		if (rise_usec <= 0)
 			dd_dev_err(dd, "SCL interface stuck low > %d uSec\n",
-				    SCL_WAIT_USEC);
+				   SCL_WAIT_USEC);
 	}
 	i2c_wait_for_writes(dd, target);
 }
diff --git a/drivers/staging/hfi1/uc.c b/drivers/staging/hfi1/uc.c
index fc90d4f544e4..abc1c303b1a3 100644
--- a/drivers/staging/hfi1/uc.c
+++ b/drivers/staging/hfi1/uc.c
@@ -299,7 +299,7 @@ void hfi1_uc_rcv(struct hfi1_packet *packet)
 			sl = ibp->sc_to_sl[sc5];
 
 			process_becn(ppd, sl, rlid, lqpn, rqpn,
-					IB_CC_SVCTYPE_UC);
+				     IB_CC_SVCTYPE_UC);
 		}
 
 		if (bth1 & HFI1_FECN_SMASK) {
* Unmerged path drivers/staging/hfi1/ud.c
diff --git a/drivers/staging/hfi1/user_sdma.c b/drivers/staging/hfi1/user_sdma.c
index 512387cf7039..b78f496ac657 100644
--- a/drivers/staging/hfi1/user_sdma.c
+++ b/drivers/staging/hfi1/user_sdma.c
@@ -724,7 +724,7 @@ free_req:
 }
 
 static inline u32 compute_data_length(struct user_sdma_request *req,
-					    struct user_sdma_txreq *tx)
+				      struct user_sdma_txreq *tx)
 {
 	/*
 	 * Determine the proper size of the packet data.
diff --git a/drivers/staging/hfi1/verbs.c b/drivers/staging/hfi1/verbs.c
index d228eb7fc4f0..4e2426da896b 100644
--- a/drivers/staging/hfi1/verbs.c
+++ b/drivers/staging/hfi1/verbs.c
@@ -1278,7 +1278,8 @@ static inline int egress_pkey_check(struct hfi1_pportdata *ppd,
 
 	/* The most likely matching pkey has index qp->s_pkey_index */
 	if (unlikely(!egress_pkey_matches_entry(pkey,
-					ppd->pkeys[qp->s_pkey_index]))) {
+						ppd->pkeys
+						[qp->s_pkey_index]))) {
 		/* no match - try the entire table */
 		for (; i < MAX_PKEY_VALUES; i++) {
 			if (egress_pkey_matches_entry(pkey, ppd->pkeys[i]))
