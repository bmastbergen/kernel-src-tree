perf callchain: Per-event type selection support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Kan Liang <kan.liang@intel.com>
commit d457c96392bb418bd998f3ccf93e0e4c958fcd0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d457c963.failed

This patchkit adds the ability to set callgraph mode (fp, dwarf, lbr) per
event. This in term can reduce sampling overhead and the size of the
perf.data.

Here is an example.

  perf record -e 'cpu/cpu-cycles,period=1000,call-graph=fp,time=1/,cpu/instructions,call-graph=lbr/' sleep 1

 perf evlist -v
 cpu/cpu-cycles,period=1000,call-graph=fp,time=1/: type: 4, size: 112,
 config: 0x3c, { sample_period, sample_freq }: 1000, sample_type:
 IP|TID|TIME|CALLCHAIN|PERIOD|IDENTIFIER, read_format: ID, disabled: 1,
 inherit: 1, mmap: 1, comm: 1, enable_on_exec: 1, task: 1, sample_id_all:
 1, exclude_guest: 1, mmap2: 1, comm_exec: 1
 cpu/instructions,call-graph=lbr/: type: 4, size: 112, config: 0xc0, {
 sample_period, sample_freq }: 4000, sample_type:
 IP|TID|TIME|CALLCHAIN|PERIOD|BRANCH_STACK|IDENTIFIER, read_format: ID,
 disabled: 1, inherit: 1, freq: 1, enable_on_exec: 1, sample_id_all: 1,
 exclude_guest: 1

	Signed-off-by: Kan Liang <kan.liang@intel.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
Link: http://lkml.kernel.org/r/1439289050-40510-1-git-send-email-kan.liang@intel.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit d457c96392bb418bd998f3ccf93e0e4c958fcd0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Documentation/perf-record.txt
#	tools/perf/util/evsel.c
#	tools/perf/util/evsel.h
#	tools/perf/util/parse-events.c
#	tools/perf/util/parse-events.h
#	tools/perf/util/parse-events.l
#	tools/perf/util/pmu.c
diff --cc tools/perf/Documentation/perf-record.txt
index 1c99db2877d3,7f82dec2b541..000000000000
--- a/tools/perf/Documentation/perf-record.txt
+++ b/tools/perf/Documentation/perf-record.txt
@@@ -46,10 -46,16 +46,20 @@@ OPTION
            /sys/bus/event_sources/devices/<pmu>/format/*
  
  	  There are also some params which are not defined in .../<pmu>/format/*.
 -	  These params can be used to overload default config values per event.
 +	  These params can be used to set event defaults.
  	  Here is a list of the params.
  	  - 'period': Set event sampling period
- 
++<<<<<<< HEAD
++
++=======
+ 	  - 'freq': Set event sampling frequency
+ 	  - 'time': Disable/enable time stamping. Acceptable values are 1 for
+ 		    enabling time stamping. 0 for disabling time stamping.
+ 		    The default is 1.
+ 	  - 'call-graph': Disable/enable callgraph. Acceptable str are "fp" for
+ 			 FP mode, "dwarf" for DWARF mode, "lbr" for LBR mode.
+ 	  - 'stack-size': user stack size for dwarf mode
++>>>>>>> d457c96392bb (perf callchain: Per-event type selection support)
  	  Note: If user explicitly sets options which conflict with the params,
  	  the value set by the params will be overridden.
  
diff --cc tools/perf/util/evsel.c
index 79e3bf22feec,6647925d5f28..000000000000
--- a/tools/perf/util/evsel.c
+++ b/tools/perf/util/evsel.c
@@@ -583,6 -588,92 +583,95 @@@ perf_evsel__config_callgraph(struct per
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ perf_evsel__reset_callgraph(struct perf_evsel *evsel,
+ 			    struct callchain_param *param)
+ {
+ 	struct perf_event_attr *attr = &evsel->attr;
+ 
+ 	perf_evsel__reset_sample_bit(evsel, CALLCHAIN);
+ 	if (param->record_mode == CALLCHAIN_LBR) {
+ 		perf_evsel__reset_sample_bit(evsel, BRANCH_STACK);
+ 		attr->branch_sample_type &= ~(PERF_SAMPLE_BRANCH_USER |
+ 					      PERF_SAMPLE_BRANCH_CALL_STACK);
+ 	}
+ 	if (param->record_mode == CALLCHAIN_DWARF) {
+ 		perf_evsel__reset_sample_bit(evsel, REGS_USER);
+ 		perf_evsel__reset_sample_bit(evsel, STACK_USER);
+ 	}
+ }
+ 
+ static void apply_config_terms(struct perf_evsel *evsel,
+ 			       struct record_opts *opts)
+ {
+ 	struct perf_evsel_config_term *term;
+ 	struct list_head *config_terms = &evsel->config_terms;
+ 	struct perf_event_attr *attr = &evsel->attr;
+ 	struct callchain_param param;
+ 	u32 dump_size = 0;
+ 	char *callgraph_buf = NULL;
+ 
+ 	/* callgraph default */
+ 	param.record_mode = callchain_param.record_mode;
+ 
+ 	list_for_each_entry(term, config_terms, list) {
+ 		switch (term->type) {
+ 		case PERF_EVSEL__CONFIG_TERM_PERIOD:
+ 			attr->sample_period = term->val.period;
+ 			attr->freq = 0;
+ 			break;
+ 		case PERF_EVSEL__CONFIG_TERM_FREQ:
+ 			attr->sample_freq = term->val.freq;
+ 			attr->freq = 1;
+ 			break;
+ 		case PERF_EVSEL__CONFIG_TERM_TIME:
+ 			if (term->val.time)
+ 				perf_evsel__set_sample_bit(evsel, TIME);
+ 			else
+ 				perf_evsel__reset_sample_bit(evsel, TIME);
+ 			break;
+ 		case PERF_EVSEL__CONFIG_TERM_CALLGRAPH:
+ 			callgraph_buf = term->val.callgraph;
+ 			break;
+ 		case PERF_EVSEL__CONFIG_TERM_STACK_USER:
+ 			dump_size = term->val.stack_user;
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ 
+ 	/* User explicitly set per-event callgraph, clear the old setting and reset. */
+ 	if ((callgraph_buf != NULL) || (dump_size > 0)) {
+ 
+ 		/* parse callgraph parameters */
+ 		if (callgraph_buf != NULL) {
+ 			param.enabled = true;
+ 			if (parse_callchain_record(callgraph_buf, &param)) {
+ 				pr_err("per-event callgraph setting for %s failed. "
+ 				       "Apply callgraph global setting for it\n",
+ 				       evsel->name);
+ 				return;
+ 			}
+ 		}
+ 		if (dump_size > 0) {
+ 			dump_size = round_up(dump_size, sizeof(u64));
+ 			param.dump_size = dump_size;
+ 		}
+ 
+ 		/* If global callgraph set, clear it */
+ 		if (callchain_param.enabled)
+ 			perf_evsel__reset_callgraph(evsel, &callchain_param);
+ 
+ 		/* set perf-event callgraph */
+ 		if (param.enabled)
+ 			perf_evsel__config_callgraph(evsel, opts, &param);
+ 	}
+ }
+ 
++>>>>>>> d457c96392bb (perf callchain: Per-event type selection support)
  /*
   * The enable_on_exec/disabled value strategy:
   *
@@@ -765,6 -859,18 +854,21 @@@ void perf_evsel__config(struct perf_evs
  		attr->disabled = 0;
  		attr->enable_on_exec = 0;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	clockid = opts->clockid;
+ 	if (opts->use_clockid) {
+ 		attr->use_clockid = 1;
+ 		attr->clockid = opts->clockid;
+ 	}
+ 
+ 	/*
+ 	 * Apply event specific term settings,
+ 	 * it overloads any global configuration.
+ 	 */
+ 	apply_config_terms(evsel, opts);
++>>>>>>> d457c96392bb (perf callchain: Per-event type selection support)
  }
  
  static int perf_evsel__alloc_fd(struct perf_evsel *evsel, int ncpus, int nthreads)
diff --cc tools/perf/util/evsel.h
index a7e233d23541,93ac6b128149..000000000000
--- a/tools/perf/util/evsel.h
+++ b/tools/perf/util/evsel.h
@@@ -31,6 -31,33 +31,36 @@@ struct perf_sample_id 
  
  struct cgroup_sel;
  
++<<<<<<< HEAD
++=======
+ /*
+  * The 'struct perf_evsel_config_term' is used to pass event
+  * specific configuration data to perf_evsel__config routine.
+  * It is allocated within event parsing and attached to
+  * perf_evsel::config_terms list head.
+ */
+ enum {
+ 	PERF_EVSEL__CONFIG_TERM_PERIOD,
+ 	PERF_EVSEL__CONFIG_TERM_FREQ,
+ 	PERF_EVSEL__CONFIG_TERM_TIME,
+ 	PERF_EVSEL__CONFIG_TERM_CALLGRAPH,
+ 	PERF_EVSEL__CONFIG_TERM_STACK_USER,
+ 	PERF_EVSEL__CONFIG_TERM_MAX,
+ };
+ 
+ struct perf_evsel_config_term {
+ 	struct list_head	list;
+ 	int	type;
+ 	union {
+ 		u64	period;
+ 		u64	freq;
+ 		bool	time;
+ 		char	*callgraph;
+ 		u64	stack_user;
+ 	} val;
+ };
+ 
++>>>>>>> d457c96392bb (perf callchain: Per-event type selection support)
  /** struct perf_evsel - event selector
   *
   * @name - Can be set to retain the original event name passed by the user,
diff --cc tools/perf/util/parse-events.c
index 4d13728779c2,d826e6f515db..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -598,6 -606,20 +598,23 @@@ do {									   
  		 * attr->branch_sample_type = term->val.num;
  		 */
  		break;
++<<<<<<< HEAD
++=======
+ 	case PARSE_EVENTS__TERM_TYPE_TIME:
+ 		CHECK_TYPE_VAL(NUM);
+ 		if (term->val.num > 1) {
+ 			err->str = strdup("expected 0 or 1");
+ 			err->idx = term->err_val;
+ 			return -EINVAL;
+ 		}
+ 		break;
+ 	case PARSE_EVENTS__TERM_TYPE_CALLGRAPH:
+ 		CHECK_TYPE_VAL(STR);
+ 		break;
+ 	case PARSE_EVENTS__TERM_TYPE_STACKSIZE:
+ 		CHECK_TYPE_VAL(NUM);
+ 		break;
++>>>>>>> d457c96392bb (perf callchain: Per-event type selection support)
  	case PARSE_EVENTS__TERM_TYPE_NAME:
  		CHECK_TYPE_VAL(STR);
  		break;
@@@ -622,6 -644,50 +639,53 @@@ static int config_attr(struct perf_even
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int get_config_terms(struct list_head *head_config,
+ 			    struct list_head *head_terms __maybe_unused)
+ {
+ #define ADD_CONFIG_TERM(__type, __name, __val)			\
+ do {								\
+ 	struct perf_evsel_config_term *__t;			\
+ 								\
+ 	__t = zalloc(sizeof(*__t));				\
+ 	if (!__t)						\
+ 		return -ENOMEM;					\
+ 								\
+ 	INIT_LIST_HEAD(&__t->list);				\
+ 	__t->type       = PERF_EVSEL__CONFIG_TERM_ ## __type;	\
+ 	__t->val.__name = __val;				\
+ 	list_add_tail(&__t->list, head_terms);			\
+ } while (0)
+ 
+ 	struct parse_events_term *term;
+ 
+ 	list_for_each_entry(term, head_config, list) {
+ 		switch (term->type_term) {
+ 		case PARSE_EVENTS__TERM_TYPE_SAMPLE_PERIOD:
+ 			ADD_CONFIG_TERM(PERIOD, period, term->val.num);
+ 			break;
+ 		case PARSE_EVENTS__TERM_TYPE_SAMPLE_FREQ:
+ 			ADD_CONFIG_TERM(FREQ, freq, term->val.num);
+ 			break;
+ 		case PARSE_EVENTS__TERM_TYPE_TIME:
+ 			ADD_CONFIG_TERM(TIME, time, term->val.num);
+ 			break;
+ 		case PARSE_EVENTS__TERM_TYPE_CALLGRAPH:
+ 			ADD_CONFIG_TERM(CALLGRAPH, callgraph, term->val.str);
+ 			break;
+ 		case PARSE_EVENTS__TERM_TYPE_STACKSIZE:
+ 			ADD_CONFIG_TERM(STACK_USER, stack_user, term->val.num);
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ #undef ADD_EVSEL_CONFIG
+ 	return 0;
+ }
+ 
++>>>>>>> d457c96392bb (perf callchain: Per-event type selection support)
  int parse_events_add_numeric(struct parse_events_evlist *data,
  			     struct list_head *list,
  			     u32 type, u64 config,
diff --cc tools/perf/util/parse-events.h
index 2063048a4354,a09b0e210997..000000000000
--- a/tools/perf/util/parse-events.h
+++ b/tools/perf/util/parse-events.h
@@@ -62,7 -62,11 +62,13 @@@ enum 
  	PARSE_EVENTS__TERM_TYPE_CONFIG2,
  	PARSE_EVENTS__TERM_TYPE_NAME,
  	PARSE_EVENTS__TERM_TYPE_SAMPLE_PERIOD,
 -	PARSE_EVENTS__TERM_TYPE_SAMPLE_FREQ,
  	PARSE_EVENTS__TERM_TYPE_BRANCH_SAMPLE_TYPE,
++<<<<<<< HEAD
++=======
+ 	PARSE_EVENTS__TERM_TYPE_TIME,
+ 	PARSE_EVENTS__TERM_TYPE_CALLGRAPH,
+ 	PARSE_EVENTS__TERM_TYPE_STACKSIZE,
++>>>>>>> d457c96392bb (perf callchain: Per-event type selection support)
  };
  
  struct parse_events_term {
diff --cc tools/perf/util/parse-events.l
index 13cef3c65565,936d566f48d8..000000000000
--- a/tools/perf/util/parse-events.l
+++ b/tools/perf/util/parse-events.l
@@@ -182,7 -182,11 +182,13 @@@ config1			{ return term(yyscanner, PARS
  config2			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_CONFIG2); }
  name			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_NAME); }
  period			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_SAMPLE_PERIOD); }
 -freq			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_SAMPLE_FREQ); }
  branch_type		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_BRANCH_SAMPLE_TYPE); }
++<<<<<<< HEAD
++=======
+ time			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_TIME); }
+ call-graph		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_CALLGRAPH); }
+ stack-size		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_STACKSIZE); }
++>>>>>>> d457c96392bb (perf callchain: Per-event type selection support)
  ,			{ return ','; }
  "/"			{ BEGIN(INITIAL); return '/'; }
  {name_minus}		{ return str(yyscanner, PE_NAME); }
diff --cc tools/perf/util/pmu.c
index 3eac7baefbaa,84cad054d6f7..000000000000
--- a/tools/perf/util/pmu.c
+++ b/tools/perf/util/pmu.c
@@@ -634,7 -634,9 +634,13 @@@ static char *formats_error_string(struc
  {
  	struct perf_pmu_format *format;
  	char *err, *str;
++<<<<<<< HEAD
 +	static const char *static_terms = "config,config1,config2,name,period,branch_type\n";
++=======
+ 	static const char *static_terms = "config,config1,config2,name,"
+ 					  "period,freq,branch_type,time,"
+ 					  "call-graph,stack-size\n";
++>>>>>>> d457c96392bb (perf callchain: Per-event type selection support)
  	unsigned i = 0;
  
  	if (!asprintf(&str, "valid terms:"))
* Unmerged path tools/perf/Documentation/perf-record.txt
* Unmerged path tools/perf/util/evsel.c
* Unmerged path tools/perf/util/evsel.h
* Unmerged path tools/perf/util/parse-events.c
* Unmerged path tools/perf/util/parse-events.h
* Unmerged path tools/perf/util/parse-events.l
* Unmerged path tools/perf/util/pmu.c
