i40e: Move NVM event wait check to NVM code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Shannon Nelson <shannon.nelson@intel.com>
commit bab2fb60dcdd0f9d8715749d056ddd6c465b1875
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bab2fb60.failed

The logic that checks AQ events for NVM done events is better kept
in nvm.c with the rest of the nvmupdate handling code.

Change-ID: I2ea58980df8ecaa3726b28a37bff3dfcb8df03dc
	Signed-off-by: Shannon Nelson <shannon.nelson@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit bab2fb60dcdd0f9d8715749d056ddd6c465b1875)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_adminq.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_adminq.c
index 88892430df0c,43bb4139d896..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_adminq.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_adminq.c
@@@ -1012,34 -1013,14 +1002,45 @@@ i40e_status i40e_clean_arq_element(stru
  	hw->aq.arq.next_to_clean = ntc;
  	hw->aq.arq.next_to_use = ntu;
  
++<<<<<<< HEAD
 +clean_arq_element_out:
 +	/* Set pending if needed, unlock and return */
 +	if (pending != NULL)
 +		*pending = (ntc > ntu ? hw->aq.arq.count : 0) + (ntu - ntc);
 +
 +clean_arq_element_err:
 +	mutex_unlock(&hw->aq.arq_mutex);
 +
 +	if (i40e_is_nvm_update_op(&e->desc)) {
 +		if (hw->aq.nvm_release_on_done) {
 +			i40e_release_nvm(hw);
 +			hw->aq.nvm_release_on_done = false;
 +		}
 +
 +		switch (hw->nvmupd_state) {
 +		case I40E_NVMUPD_STATE_INIT_WAIT:
 +			hw->nvmupd_state = I40E_NVMUPD_STATE_INIT;
 +			break;
 +
 +		case I40E_NVMUPD_STATE_WRITE_WAIT:
 +			hw->nvmupd_state = I40E_NVMUPD_STATE_WRITING;
 +			break;
 +
 +		default:
 +			break;
 +		}
 +	}
 +
++=======
+ 	i40e_nvmupd_check_wait_event(hw, le16_to_cpu(e->desc.opcode));
+ clean_arq_element_out:
+ 	/* Set pending if needed, unlock and return */
+ 	if (pending)
+ 		*pending = (ntc > ntu ? hw->aq.arq.count : 0) + (ntu - ntc);
+ clean_arq_element_err:
+ 	mutex_unlock(&hw->aq.arq_mutex);
+ 
++>>>>>>> bab2fb60dcdd (i40e: Move NVM event wait check to NVM code)
  	return ret_code;
  }
  
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_adminq.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_nvm.c b/drivers/net/ethernet/intel/i40e/i40e_nvm.c
index 5294ffd8c4f0..b9d880d89110 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_nvm.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_nvm.c
@@ -1029,6 +1029,37 @@ retry:
 	return status;
 }
 
+/**
+ * i40e_nvmupd_check_wait_event - handle NVM update operation events
+ * @hw: pointer to the hardware structure
+ * @opcode: the event that just happened
+ **/
+void i40e_nvmupd_check_wait_event(struct i40e_hw *hw, u16 opcode)
+{
+	if (opcode == i40e_aqc_opc_nvm_erase ||
+	    opcode == i40e_aqc_opc_nvm_update) {
+		i40e_debug(hw, I40E_DEBUG_NVM,
+			   "NVMUPD: clearing wait on opcode 0x%04x\n", opcode);
+		if (hw->nvm_release_on_done) {
+			i40e_release_nvm(hw);
+			hw->nvm_release_on_done = false;
+		}
+
+		switch (hw->nvmupd_state) {
+		case I40E_NVMUPD_STATE_INIT_WAIT:
+			hw->nvmupd_state = I40E_NVMUPD_STATE_INIT;
+			break;
+
+		case I40E_NVMUPD_STATE_WRITE_WAIT:
+			hw->nvmupd_state = I40E_NVMUPD_STATE_WRITING;
+			break;
+
+		default:
+			break;
+		}
+	}
+}
+
 /**
  * i40e_nvmupd_validate_command - Validate given command
  * @hw: pointer to hardware structure
diff --git a/drivers/net/ethernet/intel/i40e/i40e_prototype.h b/drivers/net/ethernet/intel/i40e/i40e_prototype.h
index e250b5c5057e..011f6275b8a0 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_prototype.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_prototype.h
@@ -301,6 +301,7 @@ i40e_status i40e_validate_nvm_checksum(struct i40e_hw *hw,
 i40e_status i40e_nvmupd_command(struct i40e_hw *hw,
 				struct i40e_nvm_access *cmd,
 				u8 *bytes, int *);
+void i40e_nvmupd_check_wait_event(struct i40e_hw *hw, u16 opcode);
 void i40e_set_pci_config_data(struct i40e_hw *hw, u16 link_status);
 
 extern struct i40e_rx_ptype_decoded i40e_ptype_lookup[];
