scsi: add support for multiple hardware queues

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [scsi] add support for multiple hardware queues (Ewan Milne) [1308703]
Rebuild_FUZZ: 93.02%
commit-author Bart Van Assche <bvanassche@acm.org>
commit efec4b90f1a9b4c80827e4b8c0863334e13b0bf1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/efec4b90.failed

Allow a SCSI LLD to declare how many hardware queues it supports
by setting Scsi_Host.nr_hw_queues before calling scsi_add_host().

	Signed-off-by: Bart Van Assche <bvanassche@acm.org>
	Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
	Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit efec4b90f1a9b4c80827e4b8c0863334e13b0bf1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_lib.c
diff --cc drivers/scsi/scsi_lib.c
index ab3c3045f4ba,38f8c85957b6..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -2115,19 -2104,16 +2115,30 @@@ int scsi_mq_setup_tags(struct Scsi_Hos
  	if (scsi_host_get_prot(shost))
  		cmd_size += sizeof(struct scsi_data_buffer) + sgl_size;
  
++<<<<<<< HEAD
 +	shost->tag_set = kzalloc(sizeof(*shost->tag_set), GFP_KERNEL);
 +	if (!shost->tag_set)
 +		return -ENOMEM;
++=======
+ 	memset(&shost->tag_set, 0, sizeof(shost->tag_set));
+ 	shost->tag_set.ops = &scsi_mq_ops;
+ 	shost->tag_set.nr_hw_queues = shost->nr_hw_queues ? : 1;
+ 	shost->tag_set.queue_depth = shost->can_queue;
+ 	shost->tag_set.cmd_size = cmd_size;
+ 	shost->tag_set.numa_node = NUMA_NO_NODE;
+ 	shost->tag_set.flags = BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE;
+ 	shost->tag_set.driver_data = shost;
++>>>>>>> efec4b90f1a9 (scsi: add support for multiple hardware queues)
 +
 +	shost->tag_set->ops = &scsi_mq_ops;
 +	shost->tag_set->nr_hw_queues = 1;
 +	shost->tag_set->queue_depth = shost->can_queue;
 +	shost->tag_set->cmd_size = cmd_size;
 +	shost->tag_set->numa_node = NUMA_NO_NODE;
 +	shost->tag_set->flags = BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE;
 +	shost->tag_set->driver_data = shost;
  
 -	return blk_mq_alloc_tag_set(&shost->tag_set);
 +	return blk_mq_alloc_tag_set(shost->tag_set);
  }
  
  void scsi_mq_destroy_tags(struct Scsi_Host *shost)
* Unmerged path drivers/scsi/scsi_lib.c
diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 86d856e16ad5..e5ed3b56e378 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -678,6 +678,14 @@ struct Scsi_Host {
 	short unsigned int sg_prot_tablesize;
 	short unsigned int max_sectors;
 	unsigned long dma_boundary;
+	/*
+	 * In scsi-mq mode, the number of hardware queues supported by the LLD.
+	 *
+	 * Note: it is assumed that each hardware queue has a queue depth of
+	 * can_queue. In other words, the total queue depth per host
+	 * is nr_hw_queues * can_queue.
+	 */
+	unsigned nr_hw_queues;
 	/* 
 	 * Used to assign serial numbers to the cmds.
 	 * Protected by the host lock.
