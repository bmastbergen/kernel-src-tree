mm, dax, gpu: convert vm_insert_mixed to pfn_t

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mm] dax, gpu: convert vm_insert_mixed to pfn_t (Jeff Moyer) [1346083 1346084 1346445 1346449 1346472 1347091 1359806]
Rebuild_FUZZ: 95.45%
commit-author Dan Williams <dan.j.williams@intel.com>
commit 01c8f1c44b83a0825b573e7c723b033cece37b86
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/01c8f1c4.failed

Convert the raw unsigned long 'pfn' argument to pfn_t for the purpose of
evaluating the PFN_MAP and PFN_DEV flags.  When both are set it triggers
_PAGE_DEVMAP to be set in the resulting pte.

There are no functional changes to the gpu drivers as a result of this
conversion.

	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Cc: Dave Hansen <dave@sr71.net>
	Cc: David Airlie <airlied@linux.ie>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 01c8f1c44b83a0825b573e7c723b033cece37b86)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/exynos/exynos_drm_gem.c
#	drivers/gpu/drm/msm/msm_gem.c
#	drivers/gpu/drm/omapdrm/omap_gem.c
#	fs/dax.c
#	include/linux/pfn_t.h
diff --cc drivers/gpu/drm/exynos/exynos_drm_gem.c
index cf4543ffa079,32358c5e3db4..000000000000
--- a/drivers/gpu/drm/exynos/exynos_drm_gem.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_gem.c
@@@ -10,8 -10,11 +10,13 @@@
   */
  
  #include <drm/drmP.h>
 -#include <drm/drm_vma_manager.h>
  
  #include <linux/shmem_fs.h>
++<<<<<<< HEAD
++=======
+ #include <linux/dma-buf.h>
+ #include <linux/pfn_t.h>
++>>>>>>> 01c8f1c44b83 (mm, dax, gpu: convert vm_insert_mixed to pfn_t)
  #include <drm/exynos_drm.h>
  
  #include "exynos_drm_drv.h"
@@@ -769,17 -483,28 +774,23 @@@ int exynos_drm_gem_fault(struct vm_area
  
  	page_offset = ((unsigned long)vmf->virtual_address -
  			vma->vm_start) >> PAGE_SHIFT;
 +	f_vaddr = (unsigned long)vmf->virtual_address;
  
 -	if (page_offset >= (exynos_gem->size >> PAGE_SHIFT)) {
 -		DRM_ERROR("invalid page offset\n");
 -		ret = -EINVAL;
 -		goto out;
 -	}
 +	mutex_lock(&dev->struct_mutex);
  
++<<<<<<< HEAD
 +	ret = exynos_drm_gem_map_buf(obj, vma, f_vaddr, page_offset);
 +	if (ret < 0)
 +		DRM_ERROR("failed to map a buffer with user.\n");
++=======
+ 	pfn = page_to_pfn(exynos_gem->pages[page_offset]);
+ 	ret = vm_insert_mixed(vma, (unsigned long)vmf->virtual_address,
+ 			__pfn_to_pfn_t(pfn, PFN_DEV));
++>>>>>>> 01c8f1c44b83 (mm, dax, gpu: convert vm_insert_mixed to pfn_t)
  
 -out:
 -	switch (ret) {
 -	case 0:
 -	case -ERESTARTSYS:
 -	case -EINTR:
 -		return VM_FAULT_NOPAGE;
 -	case -ENOMEM:
 -		return VM_FAULT_OOM;
 -	default:
 -		return VM_FAULT_SIGBUS;
 -	}
 +	mutex_unlock(&dev->struct_mutex);
 +
 +	return convert_to_vm_err_msg(ret);
  }
  
  int exynos_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma)
diff --cc drivers/gpu/drm/omapdrm/omap_gem.c
index ebbdf4132e9c,ceba5459ceb7..000000000000
--- a/drivers/gpu/drm/omapdrm/omap_gem.c
+++ b/drivers/gpu/drm/omapdrm/omap_gem.c
@@@ -17,9 -17,11 +17,15 @@@
   * this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  
++<<<<<<< HEAD
++=======
+ #include <linux/shmem_fs.h>
+ #include <linux/spinlock.h>
+ #include <linux/pfn_t.h>
++>>>>>>> 01c8f1c44b83 (mm, dax, gpu: convert vm_insert_mixed to pfn_t)
  
 -#include <drm/drm_vma_manager.h>
 +#include <linux/spinlock.h>
 +#include <linux/shmem_fs.h>
  
  #include "omap_drv.h"
  #include "omap_dmm_tiler.h"
* Unmerged path drivers/gpu/drm/msm/msm_gem.c
* Unmerged path fs/dax.c
* Unmerged path include/linux/pfn_t.h
diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h
index baa6c1dd0ecb..82ce056576ae 100644
--- a/arch/x86/include/asm/pgtable.h
+++ b/arch/x86/include/asm/pgtable.h
@@ -246,6 +246,11 @@ static inline pte_t pte_mkspecial(pte_t pte)
 	return pte_set_flags(pte, _PAGE_SPECIAL);
 }
 
+static inline pte_t pte_mkdevmap(pte_t pte)
+{
+	return pte_set_flags(pte, _PAGE_SPECIAL|_PAGE_DEVMAP);
+}
+
 static inline pmd_t pmd_set_flags(pmd_t pmd, pmdval_t set)
 {
 	pmdval_t v = native_pmd_val(pmd);
* Unmerged path drivers/gpu/drm/exynos/exynos_drm_gem.c
diff --git a/drivers/gpu/drm/gma500/framebuffer.c b/drivers/gpu/drm/gma500/framebuffer.c
index 2d42ce6d3757..a61643031fe4 100644
--- a/drivers/gpu/drm/gma500/framebuffer.c
+++ b/drivers/gpu/drm/gma500/framebuffer.c
@@ -21,6 +21,7 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/string.h>
+#include <linux/pfn_t.h>
 #include <linux/mm.h>
 #include <linux/tty.h>
 #include <linux/slab.h>
@@ -132,7 +133,8 @@ static int psbfb_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 	for (i = 0; i < page_num; i++) {
 		pfn = (phys_addr >> PAGE_SHIFT);
 
-		ret = vm_insert_mixed(vma, address, pfn);
+		ret = vm_insert_mixed(vma, address,
+				__pfn_to_pfn_t(pfn, PFN_DEV));
 		if (unlikely((ret == -EBUSY) || (ret != 0 && i > 0)))
 			break;
 		else if (unlikely(ret != 0)) {
* Unmerged path drivers/gpu/drm/msm/msm_gem.c
* Unmerged path drivers/gpu/drm/omapdrm/omap_gem.c
diff --git a/drivers/gpu/drm/ttm/ttm_bo_vm.c b/drivers/gpu/drm/ttm/ttm_bo_vm.c
index 8fb7213277cc..06d26dc438b2 100644
--- a/drivers/gpu/drm/ttm/ttm_bo_vm.c
+++ b/drivers/gpu/drm/ttm/ttm_bo_vm.c
@@ -35,6 +35,7 @@
 #include <ttm/ttm_placement.h>
 #include <drm/drm_vma_manager.h>
 #include <linux/mm.h>
+#include <linux/pfn_t.h>
 #include <linux/rbtree.h>
 #include <linux/module.h>
 #include <linux/uaccess.h>
@@ -229,7 +230,8 @@ static int ttm_bo_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 		}
 
 		if (vma->vm_flags & VM_MIXEDMAP)
-			ret = vm_insert_mixed(&cvma, address, pfn);
+			ret = vm_insert_mixed(&cvma, address,
+					__pfn_to_pfn_t(pfn, PFN_DEV));
 		else
 			ret = vm_insert_pfn(&cvma, address, pfn);
 
* Unmerged path fs/dax.c
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 449f02cd1f7b..1691cfc2661b 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1970,7 +1970,7 @@ int vm_insert_page(struct vm_area_struct *, unsigned long addr, struct page *);
 int vm_insert_pfn(struct vm_area_struct *vma, unsigned long addr,
 			unsigned long pfn);
 int vm_insert_mixed(struct vm_area_struct *vma, unsigned long addr,
-			unsigned long pfn);
+			pfn_t pfn);
 int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len);
 
 
* Unmerged path include/linux/pfn_t.h
diff --git a/mm/memory.c b/mm/memory.c
index 66d68efad529..9e5bcf7564a1 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -50,6 +50,7 @@
 #include <linux/export.h>
 #include <linux/delayacct.h>
 #include <linux/init.h>
+#include <linux/pfn_t.h>
 #include <linux/writeback.h>
 #include <linux/memcontrol.h>
 #include <linux/mmu_notifier.h>
@@ -2365,7 +2366,7 @@ int vm_insert_page(struct vm_area_struct *vma, unsigned long addr,
 EXPORT_SYMBOL(vm_insert_page);
 
 static int insert_pfn(struct vm_area_struct *vma, unsigned long addr,
-			unsigned long pfn, pgprot_t prot)
+			pfn_t pfn, pgprot_t prot)
 {
 	struct mm_struct *mm = vma->vm_mm;
 	int retval;
@@ -2381,7 +2382,10 @@ static int insert_pfn(struct vm_area_struct *vma, unsigned long addr,
 		goto out_unlock;
 
 	/* Ok, finally just insert the thing.. */
-	entry = pte_mkspecial(pfn_pte(pfn, prot));
+	if (pfn_t_devmap(pfn))
+		entry = pte_mkdevmap(pfn_t_pte(pfn, prot));
+	else
+		entry = pte_mkspecial(pfn_t_pte(pfn, prot));
 	set_pte_at(mm, addr, pte, entry);
 	update_mmu_cache(vma, addr, pte); /* XXX: why not for insert_page? */
 
@@ -2431,14 +2435,14 @@ int vm_insert_pfn(struct vm_area_struct *vma, unsigned long addr,
 	if (track_pfn_insert(vma, &pgprot, pfn))
 		return -EINVAL;
 
-	ret = insert_pfn(vma, addr, pfn, pgprot);
+	ret = insert_pfn(vma, addr, __pfn_to_pfn_t(pfn, PFN_DEV), pgprot);
 
 	return ret;
 }
 EXPORT_SYMBOL(vm_insert_pfn);
 
 int vm_insert_mixed(struct vm_area_struct *vma, unsigned long addr,
-			unsigned long pfn)
+			pfn_t pfn)
 {
 	BUG_ON(!(vma->vm_flags & VM_MIXEDMAP));
 
@@ -2452,10 +2456,10 @@ int vm_insert_mixed(struct vm_area_struct *vma, unsigned long addr,
 	 * than insert_pfn).  If a zero_pfn were inserted into a VM_MIXEDMAP
 	 * without pte special, it would there be refcounted as a normal page.
 	 */
-	if (!HAVE_PTE_SPECIAL && pfn_valid(pfn)) {
+	if (!HAVE_PTE_SPECIAL && pfn_t_valid(pfn)) {
 		struct page *page;
 
-		page = pfn_to_page(pfn);
+		page = pfn_t_to_page(pfn);
 		return insert_page(vma, addr, page, vma->vm_page_prot);
 	}
 	return insert_pfn(vma, addr, pfn, vma->vm_page_prot);
