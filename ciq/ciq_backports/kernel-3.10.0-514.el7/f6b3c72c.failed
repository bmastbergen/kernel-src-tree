x86/irq: Define a global vector for VT-d Posted-Interrupts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] irq: Define a global vector for VT-d Posted-Interrupts (Paolo Bonzini) [1301888]
Rebuild_FUZZ: 96.43%
commit-author Feng Wu <feng.wu@intel.com>
commit f6b3c72c23661e5534cd2eede16e9bac7ebb761c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f6b3c72c.failed

Currently, we use a global vector as the Posted-Interrupts
Notification Event for all the vCPUs in the system. We need
to introduce another global vector for VT-d Posted-Interrtups,
which will be used to wakeup the sleep vCPU when an external
interrupt from a direct-assigned device happens for that vCPU.

[ tglx: Removed a gazillion of extra newlines ]

	Signed-off-by: Feng Wu <feng.wu@intel.com>
	Cc: jiang.liu@linux.intel.com
Link: http://lkml.kernel.org/r/1432026437-16560-4-git-send-email-feng.wu@intel.com
	Suggested-by: Yang Zhang <yang.z.zhang@intel.com>
	Acked-by: H. Peter Anvin <hpa@linux.intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit f6b3c72c23661e5534cd2eede16e9bac7ebb761c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/hw_irq.h
diff --cc arch/x86/include/asm/hw_irq.h
index 4ab2c8af2de0,10c80d4f8386..000000000000
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@@ -26,56 -26,23 +26,65 @@@
  #include <asm/sections.h>
  
  /* Interrupt handlers registered during init_IRQ */
++<<<<<<< HEAD
 +extern void apic_timer_interrupt(void);
 +extern void x86_platform_ipi(void);
 +extern void kvm_posted_intr_ipi(void);
 +extern void error_interrupt(void);
 +extern void irq_work_interrupt(void);
++=======
+ extern asmlinkage void apic_timer_interrupt(void);
+ extern asmlinkage void x86_platform_ipi(void);
+ extern asmlinkage void kvm_posted_intr_ipi(void);
+ extern asmlinkage void kvm_posted_intr_wakeup_ipi(void);
+ extern asmlinkage void error_interrupt(void);
+ extern asmlinkage void irq_work_interrupt(void);
 -
 -extern asmlinkage void spurious_interrupt(void);
 -extern asmlinkage void thermal_interrupt(void);
 -extern asmlinkage void reschedule_interrupt(void);
 -
 -extern asmlinkage void irq_move_cleanup_interrupt(void);
 -extern asmlinkage void reboot_interrupt(void);
 -extern asmlinkage void threshold_interrupt(void);
 -
 -extern asmlinkage void call_function_interrupt(void);
 -extern asmlinkage void call_function_single_interrupt(void);
++>>>>>>> f6b3c72c2366 (x86/irq: Define a global vector for VT-d Posted-Interrupts)
 +
 +extern void spurious_interrupt(void);
 +extern void thermal_interrupt(void);
 +extern void reschedule_interrupt(void);
 +
 +extern void invalidate_interrupt(void);
 +extern void invalidate_interrupt0(void);
 +extern void invalidate_interrupt1(void);
 +extern void invalidate_interrupt2(void);
 +extern void invalidate_interrupt3(void);
 +extern void invalidate_interrupt4(void);
 +extern void invalidate_interrupt5(void);
 +extern void invalidate_interrupt6(void);
 +extern void invalidate_interrupt7(void);
 +extern void invalidate_interrupt8(void);
 +extern void invalidate_interrupt9(void);
 +extern void invalidate_interrupt10(void);
 +extern void invalidate_interrupt11(void);
 +extern void invalidate_interrupt12(void);
 +extern void invalidate_interrupt13(void);
 +extern void invalidate_interrupt14(void);
 +extern void invalidate_interrupt15(void);
 +extern void invalidate_interrupt16(void);
 +extern void invalidate_interrupt17(void);
 +extern void invalidate_interrupt18(void);
 +extern void invalidate_interrupt19(void);
 +extern void invalidate_interrupt20(void);
 +extern void invalidate_interrupt21(void);
 +extern void invalidate_interrupt22(void);
 +extern void invalidate_interrupt23(void);
 +extern void invalidate_interrupt24(void);
 +extern void invalidate_interrupt25(void);
 +extern void invalidate_interrupt26(void);
 +extern void invalidate_interrupt27(void);
 +extern void invalidate_interrupt28(void);
 +extern void invalidate_interrupt29(void);
 +extern void invalidate_interrupt30(void);
 +extern void invalidate_interrupt31(void);
 +
 +extern void irq_move_cleanup_interrupt(void);
 +extern void reboot_interrupt(void);
 +extern void threshold_interrupt(void);
 +
 +extern void call_function_interrupt(void);
 +extern void call_function_single_interrupt(void);
  
  #ifdef CONFIG_TRACING
  /* Interrupt handlers registered during init_IRQ */
@@@ -92,77 -59,101 +101,78 @@@ extern void trace_call_function_single_
  #define trace_irq_move_cleanup_interrupt  irq_move_cleanup_interrupt
  #define trace_reboot_interrupt  reboot_interrupt
  #define trace_kvm_posted_intr_ipi kvm_posted_intr_ipi
+ #define trace_kvm_posted_intr_wakeup_ipi kvm_posted_intr_wakeup_ipi
  #endif /* CONFIG_TRACING */
  
 -#ifdef	CONFIG_X86_LOCAL_APIC
 -struct irq_data;
 -struct pci_dev;
 -struct msi_desc;
 -
 -enum irq_alloc_type {
 -	X86_IRQ_ALLOC_TYPE_IOAPIC = 1,
 -	X86_IRQ_ALLOC_TYPE_HPET,
 -	X86_IRQ_ALLOC_TYPE_MSI,
 -	X86_IRQ_ALLOC_TYPE_MSIX,
 -	X86_IRQ_ALLOC_TYPE_DMAR,
 -	X86_IRQ_ALLOC_TYPE_UV,
 +/* IOAPIC */
 +#define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1<<(x)) & io_apic_irqs))
 +extern unsigned long io_apic_irqs;
 +
 +extern void init_VISWS_APIC_irqs(void);
 +extern void setup_IO_APIC(void);
 +extern void disable_IO_APIC(void);
 +
 +struct io_apic_irq_attr {
 +	int ioapic;
 +	int ioapic_pin;
 +	int trigger;
 +	int polarity;
  };
  
 -struct irq_alloc_info {
 -	enum irq_alloc_type	type;
 -	u32			flags;
 -	const struct cpumask	*mask;	/* CPU mask for vector allocation */
 -	union {
 -		int		unused;
 -#ifdef	CONFIG_HPET_TIMER
 -		struct {
 -			int		hpet_id;
 -			int		hpet_index;
 -			void		*hpet_data;
 -		};
 -#endif
 -#ifdef	CONFIG_PCI_MSI
 -		struct {
 -			struct pci_dev	*msi_dev;
 -			irq_hw_number_t	msi_hwirq;
 -		};
 -#endif
 -#ifdef	CONFIG_X86_IO_APIC
 -		struct {
 -			int		ioapic_id;
 -			int		ioapic_pin;
 -			int		ioapic_node;
 -			u32		ioapic_trigger : 1;
 -			u32		ioapic_polarity : 1;
 -			u32		ioapic_valid : 1;
 -			struct IO_APIC_route_entry *ioapic_entry;
 -		};
 -#endif
 -#ifdef	CONFIG_DMAR_TABLE
 -		struct {
 -			int		dmar_id;
 -			void		*dmar_data;
 -		};
 -#endif
 -#ifdef	CONFIG_HT_IRQ
 -		struct {
 -			int		ht_pos;
 -			int		ht_idx;
 -			struct pci_dev	*ht_dev;
 -			void		*ht_update;
 -		};
 -#endif
 -#ifdef	CONFIG_X86_UV
 -		struct {
 -			int		uv_limit;
 -			int		uv_blade;
 -			unsigned long	uv_offset;
 -			char		*uv_name;
 -		};
 -#endif
 -	};
 +static inline void set_io_apic_irq_attr(struct io_apic_irq_attr *irq_attr,
 +					int ioapic, int ioapic_pin,
 +					int trigger, int polarity)
 +{
 +	irq_attr->ioapic	= ioapic;
 +	irq_attr->ioapic_pin	= ioapic_pin;
 +	irq_attr->trigger	= trigger;
 +	irq_attr->polarity	= polarity;
 +}
 +
 +/* Intel specific interrupt remapping information */
 +struct irq_2_iommu {
 +	struct intel_iommu *iommu;
 +	u16 irte_index;
 +	u16 sub_handle;
 +	u8  irte_mask;
  };
  
 +/* AMD specific interrupt remapping information */
 +struct irq_2_irte {
 +	u16 devid; /* Device ID for IRTE table */
 +	u16 index; /* Index into IRTE table*/
 +};
 +
 +/*
 + * This is performance-critical, we want to do it O(1)
 + *
 + * Most irqs are mapped 1:1 with pins.
 + */
  struct irq_cfg {
 -	unsigned int		dest_apicid;
 +	struct irq_pin_list	*irq_2_pin;
 +	cpumask_var_t		domain;
 +	cpumask_var_t		old_domain;
  	u8			vector;
 +	u8			move_in_progress : 1;
 +#ifdef CONFIG_IRQ_REMAP
 +	u8			remapped : 1;
 +	union {
 +		struct irq_2_iommu irq_2_iommu;
 +		struct irq_2_irte  irq_2_irte;
 +	};
 +#endif
  };
  
 -extern struct irq_cfg *irq_cfg(unsigned int irq);
 -extern struct irq_cfg *irqd_cfg(struct irq_data *irq_data);
 -extern void lock_vector_lock(void);
 -extern void unlock_vector_lock(void);
 -extern void setup_vector_irq(int cpu);
 -#ifdef CONFIG_SMP
 +extern int assign_irq_vector(int, struct irq_cfg *, const struct cpumask *);
  extern void send_cleanup_vector(struct irq_cfg *);
 -extern void irq_complete_move(struct irq_cfg *cfg);
 -#else
 -static inline void send_cleanup_vector(struct irq_cfg *c) { }
 -static inline void irq_complete_move(struct irq_cfg *c) { }
 -#endif
  
 -extern void apic_ack_edge(struct irq_data *data);
 -#else	/*  CONFIG_X86_LOCAL_APIC */
 -static inline void lock_vector_lock(void) {}
 -static inline void unlock_vector_lock(void) {}
 -#endif	/* CONFIG_X86_LOCAL_APIC */
 +struct irq_data;
 +int __ioapic_set_affinity(struct irq_data *, const struct cpumask *,
 +			  unsigned int *dest_id);
 +extern int IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin, struct io_apic_irq_attr *irq_attr);
 +extern void setup_ioapic_dest(void);
 +
 +extern void enable_IO_APIC(void);
  
  /* Statistics */
  extern atomic_t irq_err_count;
diff --git a/arch/x86/include/asm/entry_arch.h b/arch/x86/include/asm/entry_arch.h
index dc5fa661465f..27ca0afcccd7 100644
--- a/arch/x86/include/asm/entry_arch.h
+++ b/arch/x86/include/asm/entry_arch.h
@@ -23,6 +23,8 @@ BUILD_INTERRUPT(x86_platform_ipi, X86_PLATFORM_IPI_VECTOR)
 #ifdef CONFIG_HAVE_KVM
 BUILD_INTERRUPT3(kvm_posted_intr_ipi, POSTED_INTR_VECTOR,
 		 smp_kvm_posted_intr_ipi)
+BUILD_INTERRUPT3(kvm_posted_intr_wakeup_ipi, POSTED_INTR_WAKEUP_VECTOR,
+		 smp_kvm_posted_intr_wakeup_ipi)
 #endif
 
 /*
diff --git a/arch/x86/include/asm/hardirq.h b/arch/x86/include/asm/hardirq.h
index 0886952762b8..bf83aba30e6c 100644
--- a/arch/x86/include/asm/hardirq.h
+++ b/arch/x86/include/asm/hardirq.h
@@ -14,6 +14,7 @@ typedef struct {
 #endif
 #ifdef CONFIG_HAVE_KVM
 	unsigned int kvm_posted_intr_ipis;
+	unsigned int kvm_posted_intr_wakeup_ipis;
 #endif
 	unsigned int x86_platform_ipis;	/* arch dependent */
 	unsigned int apic_perf_irqs;
* Unmerged path arch/x86/include/asm/hw_irq.h
diff --git a/arch/x86/include/asm/irq.h b/arch/x86/include/asm/irq.h
index ff00bd5b4caa..d5d73012c8db 100644
--- a/arch/x86/include/asm/irq.h
+++ b/arch/x86/include/asm/irq.h
@@ -30,6 +30,10 @@ extern void fixup_irqs(void);
 extern void irq_force_complete_move(int);
 #endif
 
+#ifdef CONFIG_HAVE_KVM
+extern void kvm_set_posted_intr_wakeup_handler(void (*handler)(void));
+#endif
+
 extern void (*x86_platform_ipi_callback)(void);
 extern void native_init_IRQ(void);
 extern bool handle_irq(unsigned irq, struct pt_regs *regs);
diff --git a/arch/x86/include/asm/irq_vectors.h b/arch/x86/include/asm/irq_vectors.h
index 5702d7e3111d..134334900748 100644
--- a/arch/x86/include/asm/irq_vectors.h
+++ b/arch/x86/include/asm/irq_vectors.h
@@ -105,6 +105,7 @@
 /* Vector for KVM to deliver posted interrupt IPI */
 #ifdef CONFIG_HAVE_KVM
 #define POSTED_INTR_VECTOR		0xf2
+#define POSTED_INTR_WAKEUP_VECTOR	0xf1
 #endif
 
 /*
diff --git a/arch/x86/kernel/entry_64.S b/arch/x86/kernel/entry_64.S
index 39c3b8e356d9..e027a525c911 100644
--- a/arch/x86/kernel/entry_64.S
+++ b/arch/x86/kernel/entry_64.S
@@ -984,6 +984,8 @@ apicinterrupt X86_PLATFORM_IPI_VECTOR \
 #ifdef CONFIG_HAVE_KVM
 apicinterrupt3 POSTED_INTR_VECTOR \
 	kvm_posted_intr_ipi smp_kvm_posted_intr_ipi
+apicinterrupt3 POSTED_INTR_WAKEUP_VECTOR \
+	kvm_posted_intr_wakeup_ipi smp_kvm_posted_intr_wakeup_ipi
 #endif
 
 #ifdef CONFIG_X86_MCE_THRESHOLD
diff --git a/arch/x86/kernel/irq.c b/arch/x86/kernel/irq.c
index 4ab5f9ad5a0c..b200ffa0aad9 100644
--- a/arch/x86/kernel/irq.c
+++ b/arch/x86/kernel/irq.c
@@ -238,6 +238,18 @@ void smp_x86_platform_ipi(struct pt_regs *regs)
 }
 
 #ifdef CONFIG_HAVE_KVM
+static void dummy_handler(void) {}
+static void (*kvm_posted_intr_wakeup_handler)(void) = dummy_handler;
+
+void kvm_set_posted_intr_wakeup_handler(void (*handler)(void))
+{
+	if (handler)
+		kvm_posted_intr_wakeup_handler = handler;
+	else
+		kvm_posted_intr_wakeup_handler = dummy_handler;
+}
+EXPORT_SYMBOL_GPL(kvm_set_posted_intr_wakeup_handler);
+
 /*
  * Handler for POSTED_INTERRUPT_VECTOR.
  */
@@ -257,6 +269,20 @@ void smp_kvm_posted_intr_ipi(struct pt_regs *regs)
 
 	set_irq_regs(old_regs);
 }
+
+/*
+ * Handler for POSTED_INTERRUPT_WAKEUP_VECTOR.
+ */
+__visible void smp_kvm_posted_intr_wakeup_ipi(struct pt_regs *regs)
+{
+	struct pt_regs *old_regs = set_irq_regs(regs);
+
+	entering_ack_irq();
+	inc_irq_stat(kvm_posted_intr_wakeup_ipis);
+	kvm_posted_intr_wakeup_handler();
+	exiting_irq();
+	set_irq_regs(old_regs);
+}
 #endif
 
 void smp_trace_x86_platform_ipi(struct pt_regs *regs)
diff --git a/arch/x86/kernel/irqinit.c b/arch/x86/kernel/irqinit.c
index 1e6cff5814fa..bc3ef49710ae 100644
--- a/arch/x86/kernel/irqinit.c
+++ b/arch/x86/kernel/irqinit.c
@@ -169,6 +169,8 @@ static void __init apic_intr_init(void)
 #ifdef CONFIG_HAVE_KVM
 	/* IPI for KVM to deliver posted interrupt */
 	alloc_intr_gate(POSTED_INTR_VECTOR, kvm_posted_intr_ipi);
+	/* IPI for KVM to deliver interrupt to wake up tasks */
+	alloc_intr_gate(POSTED_INTR_WAKEUP_VECTOR, kvm_posted_intr_wakeup_ipi);
 #endif
 
 	/* IPI vectors for APIC spurious and error interrupts */
