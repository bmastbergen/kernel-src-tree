target/user: Use sense_reason_t in tcmu_queue_cmd_ring

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Andy Grover <agrover@redhat.com>
commit 02eb924fabc5b699c0d9d354491e6f0767e3c139
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/02eb924f.failed

Instead of using -ERROR-style returns, use sense_reason_t. This lets us
remove tcmu_pass_op(), and return more correct sense values.

	Signed-off-by: Andy Grover <agrover@redhat.com>
	Signed-off-by: Bryant G. Ly <bryantly@linux.vnet.ibm.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 02eb924fabc5b699c0d9d354491e6f0767e3c139)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_user.c
diff --cc drivers/target/target_core_user.c
index 1a1bcf71ec9d,0cd1c61ba2ed..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -282,15 -397,16 +283,15 @@@ tcmu_queue_cmd_ring(struct tcmu_cmd *tc
  	size_t base_command_size, command_size;
  	struct tcmu_mailbox *mb;
  	struct tcmu_cmd_entry *entry;
 +	int i;
 +	struct scatterlist *sg;
  	struct iovec *iov;
 -	int iov_cnt;
 +	int iov_cnt = 0;
  	uint32_t cmd_head;
  	uint64_t cdb_off;
 -	bool copy_to_data_area;
 -	size_t data_length;
 -	DECLARE_BITMAP(old_bitmap, DATA_BLOCK_BITS);
  
  	if (test_bit(TCMU_DEV_BIT_BROKEN, &udev->flags))
- 		return -EINVAL;
+ 		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
  
  	/*
  	 * Must be a certain minimum size for response sense info, but
@@@ -1015,124 -1131,15 +1017,130 @@@ static sector_t tcmu_get_blocks(struct 
  }
  
  static sense_reason_t
++<<<<<<< HEAD
 +tcmu_execute_rw(struct se_cmd *se_cmd, struct scatterlist *sgl, u32 sgl_nents,
 +		enum dma_data_direction data_direction)
 +{
 +	int ret;
 +
 +	ret = tcmu_queue_cmd(se_cmd);
 +
 +	if (ret != 0)
 +		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
 +	else
 +		return TCM_NO_SENSE;
 +}
 +
 +static sense_reason_t
 +tcmu_pass_op(struct se_cmd *se_cmd)
 +{
 +	int ret = tcmu_queue_cmd(se_cmd);
 +
 +	if (ret != 0)
 +		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
 +	else
 +		return TCM_NO_SENSE;
 +}
 +
 +static struct sbc_ops tcmu_sbc_ops = {
 +	.execute_rw = tcmu_execute_rw,
 +	.execute_sync_cache	= tcmu_pass_op,
 +	.execute_write_same	= tcmu_pass_op,
 +	.execute_write_same_unmap = tcmu_pass_op,
 +	.execute_unmap		= tcmu_pass_op,
 +};
 +
 +static sense_reason_t
 +tcmu_parse_cdb(struct se_cmd *cmd)
 +{
 +	unsigned char *cdb = cmd->t_task_cdb;
 +	struct tcmu_dev *udev = TCMU_DEV(cmd->se_dev);
 +	sense_reason_t ret;
 +
 +	switch (udev->pass_level) {
 +	case TCMU_PASS_ALL:
 +		/* We're just like pscsi, then */
 +		/*
 +		 * For REPORT LUNS we always need to emulate the response, for everything
 +		 * else, pass it up.
 +		 */
 +		switch (cdb[0]) {
 +		case REPORT_LUNS:
 +			cmd->execute_cmd = spc_emulate_report_luns;
 +			break;
 +		case READ_6:
 +		case READ_10:
 +		case READ_12:
 +		case READ_16:
 +		case WRITE_6:
 +		case WRITE_10:
 +		case WRITE_12:
 +		case WRITE_16:
 +		case WRITE_VERIFY:
 +			cmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;
 +			/* FALLTHROUGH */
 +		default:
 +			cmd->execute_cmd = tcmu_pass_op;
 +		}
 +		ret = TCM_NO_SENSE;
 +		break;
 +	case TCMU_PASS_IO:
 +		ret = sbc_parse_cdb(cmd, &tcmu_sbc_ops);
 +		break;
 +	default:
 +		pr_err("Unknown tcm-user pass level %d\n", udev->pass_level);
 +		ret = TCM_CHECK_CONDITION_ABORT_CMD;
 +	}
 +
 +	return ret;
++=======
+ tcmu_parse_cdb(struct se_cmd *cmd)
+ {
+ 	return passthrough_parse_cdb(cmd, tcmu_queue_cmd);
++>>>>>>> 02eb924fabc5 (target/user: Use sense_reason_t in tcmu_queue_cmd_ring)
  }
  
 -static const struct target_backend_ops tcmu_ops = {
 +DEF_TB_DEFAULT_ATTRIBS(tcmu);
 +
 +static struct configfs_attribute *tcmu_backend_dev_attrs[] = {
 +	&tcmu_dev_attrib_emulate_model_alias.attr,
 +	&tcmu_dev_attrib_emulate_dpo.attr,
 +	&tcmu_dev_attrib_emulate_fua_write.attr,
 +	&tcmu_dev_attrib_emulate_fua_read.attr,
 +	&tcmu_dev_attrib_emulate_write_cache.attr,
 +	&tcmu_dev_attrib_emulate_ua_intlck_ctrl.attr,
 +	&tcmu_dev_attrib_emulate_tas.attr,
 +	&tcmu_dev_attrib_emulate_tpu.attr,
 +	&tcmu_dev_attrib_emulate_tpws.attr,
 +	&tcmu_dev_attrib_emulate_caw.attr,
 +	&tcmu_dev_attrib_emulate_3pc.attr,
 +	&tcmu_dev_attrib_pi_prot_type.attr,
 +	&tcmu_dev_attrib_hw_pi_prot_type.attr,
 +	&tcmu_dev_attrib_pi_prot_format.attr,
 +	&tcmu_dev_attrib_enforce_pr_isids.attr,
 +	&tcmu_dev_attrib_is_nonrot.attr,
 +	&tcmu_dev_attrib_emulate_rest_reord.attr,
 +	&tcmu_dev_attrib_force_pr_aptpl.attr,
 +	&tcmu_dev_attrib_hw_block_size.attr,
 +	&tcmu_dev_attrib_block_size.attr,
 +	&tcmu_dev_attrib_hw_max_sectors.attr,
 +	&tcmu_dev_attrib_optimal_sectors.attr,
 +	&tcmu_dev_attrib_hw_queue_depth.attr,
 +	&tcmu_dev_attrib_queue_depth.attr,
 +	&tcmu_dev_attrib_max_unmap_lba_count.attr,
 +	&tcmu_dev_attrib_max_unmap_block_desc_count.attr,
 +	&tcmu_dev_attrib_unmap_granularity.attr,
 +	&tcmu_dev_attrib_unmap_granularity_alignment.attr,
 +	&tcmu_dev_attrib_max_write_same_len.attr,
 +	NULL,
 +};
 +
 +static struct se_subsystem_api tcmu_template = {
  	.name			= "user",
 +	.inquiry_prod		= "USER",
 +	.inquiry_rev		= TCMU_VERSION,
  	.owner			= THIS_MODULE,
 -	.transport_flags	= TRANSPORT_FLAG_PASSTHROUGH,
 +	.transport_type		= TRANSPORT_PLUGIN_VHBA_PDEV,
  	.attach_hba		= tcmu_attach_hba,
  	.detach_hba		= tcmu_detach_hba,
  	.alloc_device		= tcmu_alloc_device,
* Unmerged path drivers/target/target_core_user.c
