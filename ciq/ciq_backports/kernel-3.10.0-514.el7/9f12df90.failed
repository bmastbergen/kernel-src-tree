ixgbe: Store VXLAN port number in network order

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Duyck <aduyck@mirantis.com>
commit 9f12df906cd807a05d71aa53a951532d1dd3b888
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9f12df90.failed

The VXLAN port number should be stored in network order instead of in host
order as it is accessed from the hot-path in ATR.  This way we can avoid
having to do any byte swaps in order to validate the port number.

I moved the vxlan_port value into a hole in the read-mostly region of the
adapter struct.  This way it should be in a warm cache-line instead of in
some isolated region in memory when it needs to be accessed.

In addition I went through and stripped a bunch of unneeded ifdef flags
since having an extra variable present doesn't really hurt anything and
makes the code easier to read.  I also went through and dropped the
NETIF_F_RXCSUM flag which was being set in hw_encap_features but provides
no value as the flag is not evaluated in the Rx path.

	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 9f12df906cd807a05d71aa53a951532d1dd3b888)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe.h
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe.h
index 8ee2e75ec3ec,458549c06a4f..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
@@@ -676,6 -661,8 +676,11 @@@ struct ixgbe_adapter 
  #define IXGBE_FLAG2_RSS_FIELD_IPV6_UDP		(u32)(1 << 9)
  #define IXGBE_FLAG2_PTP_PPS_ENABLED		(u32)(1 << 10)
  #define IXGBE_FLAG2_PHY_INTERRUPT		(u32)(1 << 11)
++<<<<<<< HEAD
++=======
+ #define IXGBE_FLAG2_VXLAN_REREG_NEEDED		BIT(12)
+ #define IXGBE_FLAG2_VLAN_PROMISC		BIT(13)
++>>>>>>> 9f12df906cd8 (ixgbe: Store VXLAN port number in network order)
  
  	/* Tx fast path data */
  	int num_tx_queues;
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index f19dfa0e85cb,f67c9a6429ac..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -4350,6 -4525,19 +4350,22 @@@ static void ixgbe_napi_disable_all(stru
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void ixgbe_clear_vxlan_port(struct ixgbe_adapter *adapter)
+ {
+ 	switch (adapter->hw.mac.type) {
+ 	case ixgbe_mac_X550:
+ 	case ixgbe_mac_X550EM_x:
+ 		IXGBE_WRITE_REG(&adapter->hw, IXGBE_VXLANCTRL, 0);
+ 		adapter->vxlan_port = 0;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 9f12df906cd8 (ixgbe: Store VXLAN port number in network order)
  #ifdef CONFIG_IXGBE_DCB
  /**
   * ixgbe_configure_dcb - Configure DCB hardware
@@@ -7109,6 -7558,7 +7125,10 @@@ static void ixgbe_atr(struct ixgbe_rin
  		struct ipv6hdr *ipv6;
  	} hdr;
  	struct tcphdr *th;
++<<<<<<< HEAD
++=======
+ 	struct sk_buff *skb;
++>>>>>>> 9f12df906cd8 (ixgbe: Store VXLAN port number in network order)
  	__be16 vlan_id;
  
  	/* if ring doesn't have a interrupt vector, cannot perform ATR */
@@@ -7122,16 -7572,51 +7142,36 @@@
  	ring->atr_count++;
  
  	/* snag network header to get L4 type and address */
++<<<<<<< HEAD
 +	hdr.network = skb_network_header(first->skb);
++=======
+ 	skb = first->skb;
+ 	hdr.network = skb_network_header(skb);
+ 	th = tcp_hdr(skb);
+ #ifdef CONFIG_IXGBE_VXLAN
+ 	if (skb->encapsulation &&
+ 	    first->protocol == htons(ETH_P_IP) &&
+ 	    hdr.ipv4->protocol != IPPROTO_UDP) {
+ 		struct ixgbe_adapter *adapter = q_vector->adapter;
+ 
+ 		/* verify the port is recognized as VXLAN */
+ 		if (adapter->vxlan_port &&
+ 		    udp_hdr(skb)->dest == adapter->vxlan_port) {
+ 			hdr.network = skb_inner_network_header(skb);
+ 			th = inner_tcp_hdr(skb);
+ 		}
+ 	}
+ #endif /* CONFIG_IXGBE_VXLAN */
++>>>>>>> 9f12df906cd8 (ixgbe: Store VXLAN port number in network order)
  
  	/* Currently only IPv4/IPv6 with TCP is supported */
 -	switch (hdr.ipv4->version) {
 -	case IPVERSION:
 -		if (hdr.ipv4->protocol != IPPROTO_TCP)
 -			return;
 -		break;
 -	case 6:
 -		if (likely((unsigned char *)th - hdr.network ==
 -			   sizeof(struct ipv6hdr))) {
 -			if (hdr.ipv6->nexthdr != IPPROTO_TCP)
 -				return;
 -		} else {
 -			__be16 frag_off;
 -			u8 l4_hdr;
 -
 -			ipv6_skip_exthdr(skb, hdr.network - skb->data +
 -					      sizeof(struct ipv6hdr),
 -					 &l4_hdr, &frag_off);
 -			if (unlikely(frag_off))
 -				return;
 -			if (l4_hdr != IPPROTO_TCP)
 -				return;
 -		}
 -		break;
 -	default:
 +	if ((first->protocol != htons(ETH_P_IPV6) ||
 +	     hdr.ipv6->nexthdr != IPPROTO_TCP) &&
 +	    (first->protocol != htons(ETH_P_IP) ||
 +	     hdr.ipv4->protocol != IPPROTO_TCP))
  		return;
 -	}
 +
 +	th = tcp_hdr(first->skb);
  
  	/* skip this packet since it is invalid or the socket is closing */
  	if (!th || th->fin)
@@@ -7178,8 -7665,14 +7218,14 @@@
  			     hdr.ipv6->daddr.s6_addr32[1] ^
  			     hdr.ipv6->daddr.s6_addr32[2] ^
  			     hdr.ipv6->daddr.s6_addr32[3];
 -		break;
 -	default:
 -		break;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (hdr.network != skb_network_header(skb))
+ 		input.formatted.flow_type |= IXGBE_ATR_L4TYPE_TUNNEL_MASK;
+ 
++>>>>>>> 9f12df906cd8 (ixgbe: Store VXLAN port number in network order)
  	/* This assumes the Rx queue and Tx queue are bound to the same CPU */
  	ixgbe_fdir_add_signature_filter_82599(&q_vector->adapter->hw,
  					      input, common, ring->queue_index);
@@@ -7792,9 -8528,70 +7838,73 @@@ static int ixgbe_set_features(struct ne
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_IXGBE_VXLAN
+ /**
+  * ixgbe_add_vxlan_port - Get notifications about VXLAN ports that come up
+  * @dev: The port's netdev
+  * @sa_family: Socket Family that VXLAN is notifiying us about
+  * @port: New UDP port number that VXLAN started listening to
+  **/
+ static void ixgbe_add_vxlan_port(struct net_device *dev, sa_family_t sa_family,
+ 				 __be16 port)
+ {
+ 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 
+ 	if (!(adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE))
+ 		return;
+ 
+ 	if (sa_family == AF_INET6)
+ 		return;
+ 
+ 	if (adapter->vxlan_port == port)
+ 		return;
+ 
+ 	if (adapter->vxlan_port) {
+ 		netdev_info(dev,
+ 			    "Hit Max num of VXLAN ports, not adding port %d\n",
+ 			    ntohs(port));
+ 		return;
+ 	}
+ 
+ 	adapter->vxlan_port = port;
+ 	IXGBE_WRITE_REG(hw, IXGBE_VXLANCTRL, ntohs(port));
+ }
+ 
+ /**
+  * ixgbe_del_vxlan_port - Get notifications about VXLAN ports that go away
+  * @dev: The port's netdev
+  * @sa_family: Socket Family that VXLAN is notifying us about
+  * @port: UDP port number that VXLAN stopped listening to
+  **/
+ static void ixgbe_del_vxlan_port(struct net_device *dev, sa_family_t sa_family,
+ 				 __be16 port)
+ {
+ 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+ 
+ 	if (!(adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE))
+ 		return;
+ 
+ 	if (sa_family == AF_INET6)
+ 		return;
+ 
+ 	if (adapter->vxlan_port != port) {
+ 		netdev_info(dev, "Port %d was not found, not deleting\n",
+ 			    ntohs(port));
+ 		return;
+ 	}
+ 
+ 	ixgbe_clear_vxlan_port(adapter);
+ 	adapter->flags2 |= IXGBE_FLAG2_VXLAN_REREG_NEEDED;
+ }
+ #endif /* CONFIG_IXGBE_VXLAN */
+ 
++>>>>>>> 9f12df906cd8 (ixgbe: Store VXLAN port number in network order)
  static int ixgbe_ndo_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
  			     struct net_device *dev,
 -			     const unsigned char *addr, u16 vid,
 +			     const unsigned char *addr,
  			     u16 flags)
  {
  	/* guarantee we can provide a unique filter for the unicast address */
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe.h
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
