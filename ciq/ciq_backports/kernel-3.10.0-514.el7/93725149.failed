net: qmi_wwan: MDM9x30 specific power management

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bjørn Mork <bjorn@mork.no>
commit 93725149794d3d418cf1eddcae60c7b536c5faa1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/93725149.failed

MDM9x30 based modems appear to go into a deeper sleep when
suspended without "Remote Wakeup" enabled.  The QMI interface
will not respond unless a "set DTR" control request is sent
on resume. The effect is similar to a QMI_CTL SYNC request,
resetting (some of) the firmware state.

We allow userspace sessions to span multiple character device
open/close sequences.  This means that userspace can depend
on firmware state while both the netdev and the character
device are closed.  We have disabled "needs_remote_wakeup" at
this point to allow devices without remote wakeup support to
be auto-suspended.

To make sure the MDM9x30 keeps firmware state, we need to
keep "needs_remote_wakeup" always set. We also need to
issue a "set DTR" request to enable the QMI interface.

	Signed-off-by: Bjørn Mork <bjorn@mork.no>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 93725149794d3d418cf1eddcae60c7b536c5faa1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/qmi_wwan.c
diff --cc drivers/net/usb/qmi_wwan.c
index 9cec903098a0,fc9dd452a3b5..000000000000
--- a/drivers/net/usb/qmi_wwan.c
+++ b/drivers/net/usb/qmi_wwan.c
@@@ -381,10 -294,30 +395,34 @@@ static int qmi_wwan_bind(struct usbnet 
  		usb_driver_release_interface(driver, info->data);
  	}
  
++<<<<<<< HEAD
 +	/* Never use the same address on both ends of the link, even
 +	 * if the buggy firmware told us to.
++=======
+ 	/* disabling remote wakeup on MDM9x30 devices has the same
+ 	 * effect as clearing DTR. The device will not respond to QMI
+ 	 * requests until we set DTR again.  This is similar to a
+ 	 * QMI_CTL SYNC request, clearing a lot of firmware state
+ 	 * including the client ID allocations.
+ 	 *
+ 	 * Our usage model allows a session to span multiple
+ 	 * open/close events, so we must prevent the firmware from
+ 	 * clearing out state the clients might need.
+ 	 *
+ 	 * MDM9x30 is the first QMI chipset with USB3 support. Abuse
+ 	 * this fact to enable the quirk.
+ 	 */
+ 	if (le16_to_cpu(dev->udev->descriptor.bcdUSB) >= 0x0201) {
+ 		qmi_wwan_manage_power(dev, 1);
+ 		qmi_wwan_change_dtr(dev, true);
+ 	}
+ 
+ 	/* Never use the same address on both ends of the link, even if the
+ 	 * buggy firmware told us to. Or, if device is assigned the well-known
+ 	 * buggy firmware MAC address, replace it with a random address,
++>>>>>>> 93725149794d (net: qmi_wwan: MDM9x30 specific power management)
  	 */
 -	if (ether_addr_equal(dev->net->dev_addr, default_modem_addr) ||
 -	    ether_addr_equal(dev->net->dev_addr, buggy_fw_addr))
 +	if (!compare_ether_addr(dev->net->dev_addr, default_modem_addr))
  		eth_hw_addr_random(dev->net);
  
  	/* make MAC addr easily distinguishable from an IP header */
* Unmerged path drivers/net/usb/qmi_wwan.c
