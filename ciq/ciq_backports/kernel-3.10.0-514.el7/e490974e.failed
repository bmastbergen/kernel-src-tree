staging/rdma/hfi1: Add braces on all arms of statement

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Add braces on all arms of statement (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 92.00%
commit-author Jubin John <jubin.john@intel.com>
commit e490974e675e8ddec795137c1db7f38e0308cbcd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e490974e.failed

Add braces on all arms of statements to fix checkpatch check:
CHECK: braces {} should be used on all arms of this statement

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Jubin John <jubin.john@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit e490974e675e8ddec795137c1db7f38e0308cbcd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/mad.c
#	drivers/staging/hfi1/uc.c
#	drivers/staging/hfi1/ud.c
#	drivers/staging/rdma/hfi1/qp.c
diff --cc drivers/staging/hfi1/mad.c
index 4900f79eb54a,305b7ae0daae..000000000000
--- a/drivers/staging/hfi1/mad.c
+++ b/drivers/staging/hfi1/mad.c
@@@ -127,26 -129,27 +127,32 @@@ static void send_trap(struct hfi1_ibpor
  	/* o14-1: smp->mkey = 0; */
  	memcpy(smp->route.lid.data, data, len);
  
 -	spin_lock_irqsave(&ibp->rvp.lock, flags);
 -	if (!ibp->rvp.sm_ah) {
 -		if (ibp->rvp.sm_lid != be16_to_cpu(IB_LID_PERMISSIVE)) {
 +	spin_lock_irqsave(&ibp->lock, flags);
 +	if (!ibp->sm_ah) {
 +		if (ibp->sm_lid != be16_to_cpu(IB_LID_PERMISSIVE)) {
  			struct ib_ah *ah;
  
++<<<<<<< HEAD:drivers/staging/hfi1/mad.c
 +			ah = hfi1_create_qp0_ah(ibp, ibp->sm_lid);
 +			if (IS_ERR(ah))
++=======
+ 			ah = hfi1_create_qp0_ah(ibp, ibp->rvp.sm_lid);
+ 			if (IS_ERR(ah)) {
++>>>>>>> e490974e675e (staging/rdma/hfi1: Add braces on all arms of statement):drivers/staging/rdma/hfi1/mad.c
  				ret = PTR_ERR(ah);
- 			else {
+ 			} else {
  				send_buf->ah = ah;
 -				ibp->rvp.sm_ah = ibah_to_rvtah(ah);
 +				ibp->sm_ah = to_iah(ah);
  				ret = 0;
  			}
- 		} else
+ 		} else {
  			ret = -EINVAL;
+ 		}
  	} else {
 -		send_buf->ah = &ibp->rvp.sm_ah->ibah;
 +		send_buf->ah = &ibp->sm_ah->ibah;
  		ret = 0;
  	}
 -	spin_unlock_irqrestore(&ibp->rvp.lock, flags);
 +	spin_unlock_irqrestore(&ibp->lock, flags);
  
  	if (!ret)
  		ret = ib_post_send_mad(send_buf, NULL);
@@@ -969,16 -978,15 +975,22 @@@ static int set_port_states(struct hfi1_
  			break;
  		/* FALLTHROUGH */
  	case IB_PORT_DOWN:
- 		if (phys_state == IB_PORTPHYSSTATE_NOP)
+ 		if (phys_state == IB_PORTPHYSSTATE_NOP) {
  			link_state = HLS_DN_DOWNDEF;
- 		else if (phys_state == IB_PORTPHYSSTATE_POLLING) {
+ 		} else if (phys_state == IB_PORTPHYSSTATE_POLLING) {
  			link_state = HLS_DN_POLL;
++<<<<<<< HEAD:drivers/staging/hfi1/mad.c
 +			set_link_down_reason(ppd,
 +			     OPA_LINKDOWN_REASON_FM_BOUNCE, 0,
 +			     OPA_LINKDOWN_REASON_FM_BOUNCE);
 +		} else if (phys_state == IB_PORTPHYSSTATE_DISABLED)
++=======
+ 			set_link_down_reason(ppd, OPA_LINKDOWN_REASON_FM_BOUNCE,
+ 					     0, OPA_LINKDOWN_REASON_FM_BOUNCE);
+ 		} else if (phys_state == IB_PORTPHYSSTATE_DISABLED) {
++>>>>>>> e490974e675e (staging/rdma/hfi1: Add braces on all arms of statement):drivers/staging/rdma/hfi1/mad.c
  			link_state = HLS_DN_DISABLE;
- 		else {
+ 		} else {
  			pr_warn("SubnSet(OPA_PortInfo) invalid physical state 0x%x\n",
  				phys_state);
  			smp->status |= IB_SMP_INVALID_FIELD;
diff --cc drivers/staging/hfi1/uc.c
index fc90d4f544e4,81b2dc70d570..000000000000
--- a/drivers/staging/hfi1/uc.c
+++ b/drivers/staging/hfi1/uc.c
@@@ -332,10 -351,11 +332,16 @@@ void hfi1_uc_rcv(struct hfi1_packet *pa
  inv:
  		if (qp->r_state == OP(SEND_FIRST) ||
  		    qp->r_state == OP(SEND_MIDDLE)) {
 -			set_bit(RVT_R_REWIND_SGE, &qp->r_aflags);
 +			set_bit(HFI1_R_REWIND_SGE, &qp->r_aflags);
  			qp->r_sge.num_sge = 0;
++<<<<<<< HEAD:drivers/staging/hfi1/uc.c
 +		} else
 +			hfi1_put_ss(&qp->r_sge);
++=======
+ 		} else {
+ 			rvt_put_ss(&qp->r_sge);
+ 		}
++>>>>>>> e490974e675e (staging/rdma/hfi1: Add braces on all arms of statement):drivers/staging/rdma/hfi1/uc.c
  		qp->r_state = OP(SEND_LAST);
  		switch (opcode) {
  		case OP(SEND_FIRST):
@@@ -391,10 -411,10 +397,17 @@@
  	case OP(SEND_ONLY):
  	case OP(SEND_ONLY_WITH_IMMEDIATE):
  send_first:
++<<<<<<< HEAD:drivers/staging/hfi1/uc.c
 +		if (test_and_clear_bit(HFI1_R_REWIND_SGE, &qp->r_aflags))
 +			qp->r_sge = qp->s_rdma_read_sge;
 +		else {
 +			ret = hfi1_get_rwqe(qp, 0);
++=======
+ 		if (test_and_clear_bit(RVT_R_REWIND_SGE, &qp->r_aflags)) {
+ 			qp->r_sge = qp->s_rdma_read_sge;
+ 		} else {
+ 			ret = hfi1_rvt_get_rwqe(qp, 0);
++>>>>>>> e490974e675e (staging/rdma/hfi1: Add braces on all arms of statement):drivers/staging/rdma/hfi1/uc.c
  			if (ret < 0)
  				goto op_err;
  			if (!ret)
@@@ -536,10 -556,10 +549,17 @@@ rdma_last_imm
  		tlen -= (hdrsize + pad + 4);
  		if (unlikely(tlen + qp->r_rcv_len != qp->r_len))
  			goto drop;
++<<<<<<< HEAD:drivers/staging/hfi1/uc.c
 +		if (test_and_clear_bit(HFI1_R_REWIND_SGE, &qp->r_aflags))
 +			hfi1_put_ss(&qp->s_rdma_read_sge);
 +		else {
 +			ret = hfi1_get_rwqe(qp, 1);
++=======
+ 		if (test_and_clear_bit(RVT_R_REWIND_SGE, &qp->r_aflags)) {
+ 			rvt_put_ss(&qp->s_rdma_read_sge);
+ 		} else {
+ 			ret = hfi1_rvt_get_rwqe(qp, 1);
++>>>>>>> e490974e675e (staging/rdma/hfi1: Add braces on all arms of statement):drivers/staging/rdma/hfi1/uc.c
  			if (ret < 0)
  				goto op_err;
  			if (!ret)
diff --cc drivers/staging/hfi1/ud.c
index a7f67b0111da,65157a4f9f5c..000000000000
--- a/drivers/staging/hfi1/ud.c
+++ b/drivers/staging/hfi1/ud.c
@@@ -161,12 -163,12 +161,18 @@@ static void ud_loopback(struct hfi1_qp 
  	/*
  	 * Get the next work request entry to find where to put the data.
  	 */
++<<<<<<< HEAD:drivers/staging/hfi1/ud.c
 +	if (qp->r_flags & HFI1_R_REUSE_SGE)
 +		qp->r_flags &= ~HFI1_R_REUSE_SGE;
 +	else {
++=======
+ 	if (qp->r_flags & RVT_R_REUSE_SGE) {
+ 		qp->r_flags &= ~RVT_R_REUSE_SGE;
+ 	} else {
++>>>>>>> e490974e675e (staging/rdma/hfi1: Add braces on all arms of statement):drivers/staging/rdma/hfi1/ud.c
  		int ret;
  
 -		ret = hfi1_rvt_get_rwqe(qp, 0);
 +		ret = hfi1_get_rwqe(qp, 0);
  		if (ret < 0) {
  			hfi1_rc_error(qp, IB_WC_LOC_QP_OP_ERR);
  			goto bail_unlock;
@@@ -186,10 -188,11 +192,11 @@@
  
  	if (ah_attr->ah_flags & IB_AH_GRH) {
  		hfi1_copy_sge(&qp->r_sge, &ah_attr->grh,
 -			      sizeof(struct ib_grh), 1, 0);
 +			      sizeof(struct ib_grh), 1);
  		wc.wc_flags |= IB_WC_GRH;
- 	} else
+ 	} else {
  		hfi1_skip_sge(&qp->r_sge, sizeof(struct ib_grh), 1);
+ 	}
  	ssge.sg_list = swqe->sg_list + 1;
  	ssge.sge = *swqe->sg_list;
  	ssge.num_sge = swqe->wr.num_sge;
@@@ -812,12 -835,12 +821,18 @@@ void hfi1_ud_rcv(struct hfi1_packet *pa
  	/*
  	 * Get the next work request entry to find where to put the data.
  	 */
++<<<<<<< HEAD:drivers/staging/hfi1/ud.c
 +	if (qp->r_flags & HFI1_R_REUSE_SGE)
 +		qp->r_flags &= ~HFI1_R_REUSE_SGE;
 +	else {
++=======
+ 	if (qp->r_flags & RVT_R_REUSE_SGE) {
+ 		qp->r_flags &= ~RVT_R_REUSE_SGE;
+ 	} else {
++>>>>>>> e490974e675e (staging/rdma/hfi1: Add braces on all arms of statement):drivers/staging/rdma/hfi1/ud.c
  		int ret;
  
 -		ret = hfi1_rvt_get_rwqe(qp, 0);
 +		ret = hfi1_get_rwqe(qp, 0);
  		if (ret < 0) {
  			hfi1_rc_error(qp, IB_WC_LOC_QP_OP_ERR);
  			return;
@@@ -835,13 -858,15 +850,21 @@@
  	}
  	if (has_grh) {
  		hfi1_copy_sge(&qp->r_sge, &hdr->u.l.grh,
 -			      sizeof(struct ib_grh), 1, 0);
 +			      sizeof(struct ib_grh), 1);
  		wc.wc_flags |= IB_WC_GRH;
- 	} else
+ 	} else {
  		hfi1_skip_sge(&qp->r_sge, sizeof(struct ib_grh), 1);
++<<<<<<< HEAD:drivers/staging/hfi1/ud.c
 +	hfi1_copy_sge(&qp->r_sge, data, wc.byte_len - sizeof(struct ib_grh), 1);
 +	hfi1_put_ss(&qp->r_sge);
 +	if (!test_and_clear_bit(HFI1_R_WRID_VALID, &qp->r_aflags))
++=======
+ 	}
+ 	hfi1_copy_sge(&qp->r_sge, data, wc.byte_len - sizeof(struct ib_grh),
+ 		      1, 0);
+ 	rvt_put_ss(&qp->r_sge);
+ 	if (!test_and_clear_bit(RVT_R_WRID_VALID, &qp->r_aflags))
++>>>>>>> e490974e675e (staging/rdma/hfi1: Add braces on all arms of statement):drivers/staging/rdma/hfi1/ud.c
  		return;
  	wc.wr_id = qp->r_wr_id;
  	wc.status = IB_WC_SUCCESS;
* Unmerged path drivers/staging/rdma/hfi1/qp.c
diff --git a/drivers/staging/hfi1/chip.c b/drivers/staging/hfi1/chip.c
index 5343ebf88f1b..69b477ead66b 100644
--- a/drivers/staging/hfi1/chip.c
+++ b/drivers/staging/hfi1/chip.c
@@ -13911,9 +13911,9 @@ int hfi1_set_ctxt_pkey(struct hfi1_devdata *dd, unsigned ctxt, u16 pkey)
 	int ret = 0;
 	u64 reg;
 
-	if (ctxt < dd->num_rcv_contexts)
+	if (ctxt < dd->num_rcv_contexts) {
 		rcd = dd->rcd[ctxt];
-	else {
+	} else {
 		ret = -EINVAL;
 		goto done;
 	}
@@ -13939,9 +13939,9 @@ int hfi1_clear_ctxt_pkey(struct hfi1_devdata *dd, unsigned ctxt)
 	int ret = 0;
 	u64 reg;
 
-	if (ctxt < dd->num_rcv_contexts)
+	if (ctxt < dd->num_rcv_contexts) {
 		rcd = dd->rcd[ctxt];
-	else {
+	} else {
 		ret = -EINVAL;
 		goto done;
 	}
diff --git a/drivers/staging/hfi1/driver.c b/drivers/staging/hfi1/driver.c
index 31605ee909b6..9db85e2ac1c7 100644
--- a/drivers/staging/hfi1/driver.c
+++ b/drivers/staging/hfi1/driver.c
@@ -283,9 +283,9 @@ static void rcv_hdrerr(struct hfi1_ctxtdata *rcd, struct hfi1_pportdata *ppd,
 			goto drop;
 
 		/* Check for GRH */
-		if (lnh == HFI1_LRH_BTH)
+		if (lnh == HFI1_LRH_BTH) {
 			ohdr = &hdr->u.oth;
-		else if (lnh == HFI1_LRH_GRH) {
+		} else if (lnh == HFI1_LRH_GRH) {
 			u32 vtf;
 
 			ohdr = &hdr->u.l.oth;
@@ -295,9 +295,9 @@ static void rcv_hdrerr(struct hfi1_ctxtdata *rcd, struct hfi1_pportdata *ppd,
 			if ((vtf >> IB_GRH_VERSION_SHIFT) != IB_GRH_VERSION)
 				goto drop;
 			rcv_flags |= HFI1_HAS_GRH;
-		} else
+		} else {
 			goto drop;
-
+		}
 		/* Get the destination QP number. */
 		qp_num = be32_to_cpu(ohdr->bth[1]) & HFI1_QPN_MASK;
 		if (lid < HFI1_MULTICAST_LID_BASE) {
@@ -600,14 +600,14 @@ static void prescan_rxq(struct hfi1_packet *packet)
 			hfi1_get_msgheader(dd, rhf_addr);
 		lnh = be16_to_cpu(hdr->lrh[0]) & 3;
 
-		if (lnh == HFI1_LRH_BTH)
+		if (lnh == HFI1_LRH_BTH) {
 			ohdr = &hdr->u.oth;
-		else if (lnh == HFI1_LRH_GRH) {
+		} else if (lnh == HFI1_LRH_GRH) {
 			ohdr = &hdr->u.l.oth;
 			grh = &hdr->u.l.grh;
-		} else
+		} else {
 			goto next; /* just in case */
-
+		}
 		bth1 = be32_to_cpu(ohdr->bth[1]);
 		is_ecn = !!(bth1 & (HFI1_FECN_SMASK | HFI1_BECN_SMASK));
 
diff --git a/drivers/staging/hfi1/file_ops.c b/drivers/staging/hfi1/file_ops.c
index 5d56ff3d1c23..f307ce7317bb 100644
--- a/drivers/staging/hfi1/file_ops.c
+++ b/drivers/staging/hfi1/file_ops.c
@@ -406,8 +406,9 @@ static ssize_t hfi1_file_write(struct file *fp, const char __user *data,
 			ret = sc_enable(sc);
 			hfi1_rcvctrl(dd, HFI1_RCVCTRL_CTXT_ENB,
 				     uctxt->ctxt);
-		} else
+		} else {
 			ret = sc_restart(sc);
+		}
 		if (!ret)
 			sc_return_credits(sc);
 		break;
@@ -1425,8 +1426,9 @@ static unsigned int poll_next(struct file *fp,
 		set_bit(HFI1_CTXT_WAITING_RCV, &uctxt->event_flags);
 		hfi1_rcvctrl(dd, HFI1_RCVCTRL_INTRAVAIL_ENB, uctxt->ctxt);
 		pollflag = 0;
-	} else
+	} else {
 		pollflag = POLLIN | POLLRDNORM;
+	}
 	spin_unlock_irq(&dd->uctxt_lock);
 
 	return pollflag;
@@ -1504,8 +1506,9 @@ static int manage_rcvq(struct hfi1_ctxtdata *uctxt, unsigned subctxt,
 		if (uctxt->rcvhdrtail_kvaddr)
 			clear_rcvhdrtail(uctxt);
 		rcvctrl_op = HFI1_RCVCTRL_CTXT_ENB;
-	} else
+	} else {
 		rcvctrl_op = HFI1_RCVCTRL_CTXT_DIS;
+	}
 	hfi1_rcvctrl(dd, rcvctrl_op, uctxt->ctxt);
 	/* always; new head should be equal to new tail; see above */
 bail:
diff --git a/drivers/staging/hfi1/init.c b/drivers/staging/hfi1/init.c
index c64c8dd680db..c94195326171 100644
--- a/drivers/staging/hfi1/init.c
+++ b/drivers/staging/hfi1/init.c
@@ -1703,8 +1703,9 @@ int hfi1_setup_eagerbufs(struct hfi1_ctxtdata *rcd)
 				     rcd->egrbufs.buffers[j].len)) {
 					j++;
 					offset = 0;
-				} else
+				} else {
 					offset += new_size;
+				}
 			}
 			rcd->egrbufs.rcvtid_size = new_size;
 		}
* Unmerged path drivers/staging/hfi1/mad.c
diff --git a/drivers/staging/hfi1/pcie.c b/drivers/staging/hfi1/pcie.c
index 986a471703d4..decb83d9c4f7 100644
--- a/drivers/staging/hfi1/pcie.c
+++ b/drivers/staging/hfi1/pcie.c
@@ -122,8 +122,9 @@ int hfi1_pcie_init(struct pci_dev *pdev, const struct pci_device_id *ent)
 			goto bail;
 		}
 		ret = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));
-	} else
+	} else {
 		ret = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));
+	}
 	if (ret) {
 		hfi1_early_err(&pdev->dev,
 			       "Unable to set DMA consistent mask: %d\n", ret);
diff --git a/drivers/staging/hfi1/rc.c b/drivers/staging/hfi1/rc.c
index dd57d65aa9b2..d88a9d6487ba 100644
--- a/drivers/staging/hfi1/rc.c
+++ b/drivers/staging/hfi1/rc.c
@@ -378,9 +378,9 @@ int hfi1_make_rc_req(struct hfi1_qp *qp)
 				len = pmtu;
 				break;
 			}
-			if (wqe->wr.opcode == IB_WR_SEND)
+			if (wqe->wr.opcode == IB_WR_SEND) {
 				qp->s_state = OP(SEND_ONLY);
-			else {
+			} else {
 				qp->s_state = OP(SEND_ONLY_WITH_IMMEDIATE);
 				/* Immediate data comes after the BTH */
 				ohdr->u.imm_data = wqe->wr.ex.imm_data;
@@ -417,9 +417,9 @@ int hfi1_make_rc_req(struct hfi1_qp *qp)
 				len = pmtu;
 				break;
 			}
-			if (wqe->wr.opcode == IB_WR_RDMA_WRITE)
+			if (wqe->wr.opcode == IB_WR_RDMA_WRITE) {
 				qp->s_state = OP(RDMA_WRITE_ONLY);
-			else {
+			} else {
 				qp->s_state =
 					OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE);
 				/* Immediate data comes after RETH */
@@ -560,9 +560,9 @@ int hfi1_make_rc_req(struct hfi1_qp *qp)
 			middle = HFI1_CAP_IS_KSET(SDMA_AHG);
 			break;
 		}
-		if (wqe->wr.opcode == IB_WR_SEND)
+		if (wqe->wr.opcode == IB_WR_SEND) {
 			qp->s_state = OP(SEND_LAST);
-		else {
+		} else {
 			qp->s_state = OP(SEND_LAST_WITH_IMMEDIATE);
 			/* Immediate data comes after the BTH */
 			ohdr->u.imm_data = wqe->wr.ex.imm_data;
@@ -602,9 +602,9 @@ int hfi1_make_rc_req(struct hfi1_qp *qp)
 			middle = HFI1_CAP_IS_KSET(SDMA_AHG);
 			break;
 		}
-		if (wqe->wr.opcode == IB_WR_RDMA_WRITE)
+		if (wqe->wr.opcode == IB_WR_RDMA_WRITE) {
 			qp->s_state = OP(RDMA_WRITE_LAST);
-		else {
+		} else {
 			qp->s_state = OP(RDMA_WRITE_LAST_WITH_IMMEDIATE);
 			/* Immediate data comes after the BTH */
 			ohdr->u.imm_data = wqe->wr.ex.imm_data;
@@ -893,10 +893,12 @@ static void restart_rc(struct hfi1_qp *qp, u32 psn, int wait)
 			hfi1_send_complete(qp, wqe, IB_WC_RETRY_EXC_ERR);
 			hfi1_error_qp(qp, IB_WC_WR_FLUSH_ERR);
 			return;
-		} else /* need to handle delayed completion */
+		} else { /* need to handle delayed completion */
 			return;
-	} else
+		}
+	} else {
 		qp->s_retry--;
+	}
 
 	ibp = to_iport(qp->ibqp.device, qp->port_num);
 	if (wqe->wr.opcode == IB_WR_RDMA_READ)
@@ -1487,8 +1489,9 @@ static void rc_rcv_resp(struct hfi1_ibport *ibp,
 
 			val = ((u64) be32_to_cpu(p[0]) << 32) |
 				be32_to_cpu(p[1]);
-		} else
+		} else {
 			val = 0;
+		}
 		if (!do_rc_ack(qp, aeth, psn, opcode, val, rcd) ||
 		    opcode != OP(RDMA_READ_RESPONSE_FIRST))
 			goto ack_done;
diff --git a/drivers/staging/hfi1/sdma.c b/drivers/staging/hfi1/sdma.c
index 8a57bc183ce2..9e3f53a08a74 100644
--- a/drivers/staging/hfi1/sdma.c
+++ b/drivers/staging/hfi1/sdma.c
@@ -2055,8 +2055,9 @@ static int sdma_check_progress(
 		ret = wait->sleep(sde, wait, tx, seq);
 		if (ret == -EAGAIN)
 			sde->desc_avail = sdma_descq_freecnt(sde);
-	} else
+	} else {
 		ret = -EBUSY;
+	}
 	return ret;
 }
 
diff --git a/drivers/staging/hfi1/twsi.c b/drivers/staging/hfi1/twsi.c
index d7dfdd231669..fff920b97b5c 100644
--- a/drivers/staging/hfi1/twsi.c
+++ b/drivers/staging/hfi1/twsi.c
@@ -119,9 +119,9 @@ static void scl_out(struct hfi1_devdata *dd, u32 target, u8 bit)
 	 * Allow for slow slaves by simple
 	 * delay for falling edge, sampling on rise.
 	 */
-	if (!bit)
+	if (!bit) {
 		udelay(2);
-	else {
+	} else {
 		int rise_usec;
 
 		for (rise_usec = SCL_WAIT_USEC; rise_usec > 0; rise_usec -= 2) {
* Unmerged path drivers/staging/hfi1/uc.c
* Unmerged path drivers/staging/hfi1/ud.c
diff --git a/drivers/staging/hfi1/user_sdma.c b/drivers/staging/hfi1/user_sdma.c
index 512387cf7039..3884cfb920b2 100644
--- a/drivers/staging/hfi1/user_sdma.c
+++ b/drivers/staging/hfi1/user_sdma.c
@@ -757,8 +757,9 @@ static inline u32 compute_data_length(struct user_sdma_request *req,
 		 * are not going to try to send more data that we have
 		 * remaining. */
 		len = min(len, req->data_len - req->sent);
-	} else
+	} else {
 		len = min(req->data_len - req->sent, (u32)req->info.fragsize);
+	}
 	SDMA_DBG(req, "Data Length = %u", len);
 	return len;
 }
@@ -1324,8 +1325,9 @@ static int set_txreq_header_ahg(struct user_sdma_request *req,
 								INTR) >> 16);
 			val &= cpu_to_le16(~(1U << 13));
 			AHG_HEADER_SET(req->ahg, diff, 7, 16, 14, val);
-		} else
+		} else {
 			AHG_HEADER_SET(req->ahg, diff, 7, 16, 12, val);
+		}
 	}
 
 	trace_hfi1_sdma_user_header_ahg(pq->dd, pq->ctxt, pq->subctxt,
diff --git a/drivers/staging/hfi1/verbs.c b/drivers/staging/hfi1/verbs.c
index d228eb7fc4f0..f17551028420 100644
--- a/drivers/staging/hfi1/verbs.c
+++ b/drivers/staging/hfi1/verbs.c
@@ -611,9 +611,9 @@ void hfi1_ib_rcv(struct hfi1_packet *packet)
 
 	/* Check for GRH */
 	lnh = be16_to_cpu(hdr->lrh[0]) & 3;
-	if (lnh == HFI1_LRH_BTH)
+	if (lnh == HFI1_LRH_BTH) {
 		packet->ohdr = &hdr->u.oth;
-	else if (lnh == HFI1_LRH_GRH) {
+	} else if (lnh == HFI1_LRH_GRH) {
 		u32 vtf;
 
 		packet->ohdr = &hdr->u.l.oth;
@@ -623,8 +623,9 @@ void hfi1_ib_rcv(struct hfi1_packet *packet)
 		if ((vtf >> IB_GRH_VERSION_SHIFT) != IB_GRH_VERSION)
 			goto drop;
 		packet->rcv_flags |= HFI1_HAS_GRH;
-	} else
+	} else {
 		goto drop;
+	}
 
 	trace_input_ibhdr(rcd->dd, hdr);
 
@@ -823,9 +824,9 @@ static void verbs_sdma_complete(
 	struct hfi1_qp *qp = tx->qp;
 
 	spin_lock(&qp->s_lock);
-	if (tx->wqe)
+	if (tx->wqe) {
 		hfi1_send_complete(qp, tx->wqe, IB_WC_SUCCESS);
-	else if (qp->ibqp.qp_type == IB_QPT_RC) {
+	} else if (qp->ibqp.qp_type == IB_QPT_RC) {
 		struct hfi1_ib_header *hdr;
 
 		hdr = &tx->phdr.hdr;
* Unmerged path drivers/staging/rdma/hfi1/qp.c
