x86/platform/UV: Update physical address conversions for UV4

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] platform/uv: Update physical address conversions for UV4 (Frank Ramsay) [1276458]
Rebuild_FUZZ: 96.55%
commit-author Mike Travis <travis@sgi.com>
commit c85375cd19966d5dd854cd8b8eada9be8f21fac1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c85375cd.failed

This patch builds support for the new conversions of physical addresses
to and from sockets, pnodes and nodes in UV4.  It is designed to be as
efficient as possible as lookups are done inside an interrupt context
in some cases.  It will be further optimized when physical hardware is
available to measure execution time.

	Tested-by: Dimitri Sivanich <sivanich@sgi.com>
	Tested-by: John Estabrook <estabrook@sgi.com>
	Tested-by: Gary Kroening <gfk@sgi.com>
	Tested-by: Nathan Zimmer <nzimmer@sgi.com>
	Signed-off-by: Mike Travis <travis@sgi.com>
	Cc: Andrew Banman <abanman@sgi.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Len Brown <len.brown@intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Russ Anderson <rja@sgi.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/20160429215405.841051741@asylum.americas.sgi.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit c85375cd19966d5dd854cd8b8eada9be8f21fac1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/uv/uv_hub.h
#	arch/x86/kernel/apic/x2apic_uv_x.c
diff --cc arch/x86/include/asm/uv/uv_hub.h
index 74f8c4a9bc11,ae979f7740f7..000000000000
--- a/arch/x86/include/asm/uv/uv_hub.h
+++ b/arch/x86/include/asm/uv/uv_hub.h
@@@ -146,12 -155,23 +154,24 @@@ struct uv_gam_range_s 
   */
  struct uv_hub_info_s {
  	unsigned long		global_mmr_base;
 -	unsigned long		global_mmr_shift;
  	unsigned long		gpa_mask;
++<<<<<<< HEAD
 +	unsigned int		gnode_extra;
++=======
+ 	unsigned short		*socket_to_node;
+ 	unsigned short		*socket_to_pnode;
+ 	unsigned short		*pnode_to_socket;
+ 	struct uv_gam_range_s	*gr_table;
+ 	unsigned short		min_socket;
+ 	unsigned short		min_pnode;
+ 	unsigned char		m_val;
+ 	unsigned char		n_val;
+ 	unsigned char		gr_table_len;
++>>>>>>> c85375cd1996 (x86/platform/UV: Update physical address conversions for UV4)
  	unsigned char		hub_revision;
  	unsigned char		apic_pnode_shift;
 -	unsigned char		gpa_shift;
  	unsigned char		m_shift;
  	unsigned char		n_lshift;
 -	unsigned int		gnode_extra;
  	unsigned long		gnode_upper;
  	unsigned long		lowmem_remap_top;
  	unsigned long		lowmem_remap_base;
@@@ -159,14 -181,11 +179,20 @@@
  	unsigned short		pnode_mask;
  	unsigned short		coherency_domain_number;
  	unsigned short		numa_blade_id;
++<<<<<<< HEAD
 +	unsigned char		m_val;
 +	unsigned char		n_val;
++=======
+ 	unsigned short		nr_possible_cpus;
+ 	unsigned short		nr_online_cpus;
+ 	short			memory_nid;
++>>>>>>> c85375cd1996 (x86/platform/UV: Update physical address conversions for UV4)
  };
  
 +DECLARE_PER_CPU(struct uv_hub_info_s, __uv_hub_info);
 +#define uv_hub_info		(&__get_cpu_var(__uv_hub_info))
 +#define uv_cpu_hub_info(cpu)	(&per_cpu(__uv_hub_info, cpu))
 +
  /* CPU specific info with a pointer to the hub common info struct */
  struct uv_cpu_info_s {
  	void			*p_uv_hub_info;
@@@ -417,45 -528,77 +502,90 @@@ static inline unsigned long uv_gpa_to_s
  	return paddr;
  }
  
++<<<<<<< HEAD
 +
 +/* gpa -> pnode */
++=======
+ /* gpa -> gnode */
++>>>>>>> c85375cd1996 (x86/platform/UV: Update physical address conversions for UV4)
  static inline unsigned long uv_gpa_to_gnode(unsigned long gpa)
  {
- 	return gpa >> uv_hub_info->n_lshift;
+ 	unsigned int n_lshift = uv_hub_info->n_lshift;
+ 
+ 	if (n_lshift)
+ 		return gpa >> n_lshift;
+ 
+ 	return uv_gam_range(gpa)->nasid >> 1;
  }
  
  /* gpa -> pnode */
  static inline int uv_gpa_to_pnode(unsigned long gpa)
  {
 -	return uv_gpa_to_gnode(gpa) & uv_hub_info->pnode_mask;
 +	unsigned long n_mask = (1UL << uv_hub_info->n_val) - 1;
 +
 +	return uv_gpa_to_gnode(gpa) & n_mask;
  }
  
 -/* gpa -> node offset */
 +/* gpa -> node offset*/
  static inline unsigned long uv_gpa_to_offset(unsigned long gpa)
  {
- 	return (gpa << uv_hub_info->m_shift) >> uv_hub_info->m_shift;
+ 	unsigned int m_shift = uv_hub_info->m_shift;
+ 
+ 	if (m_shift)
+ 		return (gpa << m_shift) >> m_shift;
+ 
+ 	return (gpa & uv_hub_info->gpa_mask) - uv_gam_range_base(gpa);
+ }
+ 
+ /* Convert socket to node */
+ static inline int _uv_socket_to_node(int socket, unsigned short *s2nid)
+ {
+ 	return s2nid ? s2nid[socket - uv_hub_info->min_socket] : socket;
+ }
+ 
+ static inline int uv_socket_to_node(int socket)
+ {
+ 	return _uv_socket_to_node(socket, uv_hub_info->socket_to_node);
  }
  
  /* pnode, offset --> socket virtual */
  static inline void *uv_pnode_offset_to_vaddr(int pnode, unsigned long offset)
  {
- 	return __va(((unsigned long)pnode << uv_hub_info->m_val) | offset);
- }
+ 	unsigned int m_val = uv_hub_info->m_val;
+ 	unsigned long base;
+ 	unsigned short sockid, node, *p2s;
  
++<<<<<<< HEAD
 +
 +/*
 + * Extract a PNODE from an APICID (full apicid, not processor subset)
 + */
++=======
+ 	if (m_val)
+ 		return __va(((unsigned long)pnode << m_val) | offset);
+ 
+ 	p2s = uv_hub_info->pnode_to_socket;
+ 	sockid = p2s ? p2s[pnode - uv_hub_info->min_pnode] : pnode;
+ 	node = uv_socket_to_node(sockid);
+ 
+ 	/* limit address of previous socket is our base, except node 0 is 0 */
+ 	if (!node)
+ 		return __va((unsigned long)offset);
+ 
+ 	base = (unsigned long)(uv_hub_info->gr_table[node - 1].limit);
+ 	return __va(base << UV_GAM_RANGE_SHFT | offset);
+ }
+ 
+ /* Extract/Convert a PNODE from an APICID (full apicid, not processor subset) */
++>>>>>>> c85375cd1996 (x86/platform/UV: Update physical address conversions for UV4)
  static inline int uv_apicid_to_pnode(int apicid)
  {
 -	int pnode = apicid >> uv_hub_info->apic_pnode_shift;
 -	unsigned short *s2pn = uv_hub_info->socket_to_pnode;
 -
 -	return s2pn ? s2pn[pnode - uv_hub_info->min_socket] : pnode;
 +	return (apicid >> uv_hub_info->apic_pnode_shift);
  }
  
 -/* Convert an apicid to the socket number on the blade */
 +/*
 + * Convert an apicid to the socket number on the blade
 + */
  static inline int uv_apicid_to_socket(int apicid)
  {
  	if (is_uv1_hub())
diff --cc arch/x86/kernel/apic/x2apic_uv_x.c
index fd86a4f25c81,65a40d4a95fe..000000000000
--- a/arch/x86/kernel/apic/x2apic_uv_x.c
+++ b/arch/x86/kernel/apic/x2apic_uv_x.c
@@@ -306,9 -301,117 +306,121 @@@ EXPORT_SYMBOL_GPL(uv_possible_blades)
  unsigned long sn_rtc_cycles_per_second;
  EXPORT_SYMBOL(sn_rtc_cycles_per_second);
  
++<<<<<<< HEAD
++=======
+ /* the following values are used for the per node hub info struct */
+ static __initdata unsigned short *_node_to_pnode;
+ static __initdata unsigned short _min_socket, _max_socket;
+ static __initdata unsigned short _min_pnode, _max_pnode, _gr_table_len;
+ static __initdata struct uv_gam_range_entry *uv_gre_table;
+ static __initdata struct uv_gam_parameters *uv_gp_table;
+ static __initdata unsigned short *_socket_to_node;
+ static __initdata unsigned short *_socket_to_pnode;
+ static __initdata unsigned short *_pnode_to_socket;
+ static __initdata struct uv_gam_range_s *_gr_table;
+ #define	SOCK_EMPTY	((unsigned short)~0)
+ 
+ extern int uv_hub_info_version(void)
+ {
+ 	return UV_HUB_INFO_VERSION;
+ }
+ EXPORT_SYMBOL(uv_hub_info_version);
+ 
+ /* Build GAM range lookup table */
+ static __init void build_uv_gr_table(void)
+ {
+ 	struct uv_gam_range_entry *gre = uv_gre_table;
+ 	struct uv_gam_range_s *grt;
+ 	unsigned long last_limit = 0, ram_limit = 0;
+ 	int bytes, i, sid, lsid = -1;
+ 
+ 	if (!gre)
+ 		return;
+ 
+ 	bytes = _gr_table_len * sizeof(struct uv_gam_range_s);
+ 	grt = kzalloc(bytes, GFP_KERNEL);
+ 	BUG_ON(!grt);
+ 	_gr_table = grt;
+ 
+ 	for (; gre->type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {
+ 		if (gre->type == UV_GAM_RANGE_TYPE_HOLE) {
+ 			if (!ram_limit) {   /* mark hole between ram/non-ram */
+ 				ram_limit = last_limit;
+ 				last_limit = gre->limit;
+ 				lsid++;
+ 				continue;
+ 			}
+ 			last_limit = gre->limit;
+ 			pr_info("UV: extra hole in GAM RE table @%d\n",
+ 				(int)(gre - uv_gre_table));
+ 			continue;
+ 		}
+ 		if (_max_socket < gre->sockid) {
+ 			pr_err("UV: GAM table sockid(%d) too large(>%d) @%d\n",
+ 				gre->sockid, _max_socket,
+ 				(int)(gre - uv_gre_table));
+ 			continue;
+ 		}
+ 		sid = gre->sockid - _min_socket;
+ 		if (lsid < sid) {		/* new range */
+ 			grt = &_gr_table[sid];
+ 			grt->base = lsid;
+ 			grt->nasid = gre->nasid;
+ 			grt->limit = last_limit = gre->limit;
+ 			lsid = sid;
+ 			continue;
+ 		}
+ 		if (lsid == sid && !ram_limit) {	/* update range */
+ 			if (grt->limit == last_limit) {	/* .. if contiguous */
+ 				grt->limit = last_limit = gre->limit;
+ 				continue;
+ 			}
+ 		}
+ 		if (!ram_limit) {		/* non-contiguous ram range */
+ 			grt++;
+ 			grt->base = sid - 1;
+ 			grt->nasid = gre->nasid;
+ 			grt->limit = last_limit = gre->limit;
+ 			continue;
+ 		}
+ 		grt++;				/* non-contiguous/non-ram */
+ 		grt->base = grt - _gr_table;	/* base is this entry */
+ 		grt->nasid = gre->nasid;
+ 		grt->limit = last_limit = gre->limit;
+ 		lsid++;
+ 	}
+ 
+ 	/* shorten table if possible */
+ 	grt++;
+ 	i = grt - _gr_table;
+ 	if (i < _gr_table_len) {
+ 		void *ret;
+ 
+ 		bytes = i * sizeof(struct uv_gam_range_s);
+ 		ret = krealloc(_gr_table, bytes, GFP_KERNEL);
+ 		if (ret) {
+ 			_gr_table = ret;
+ 			_gr_table_len = i;
+ 		}
+ 	}
+ 
+ 	/* display resultant gam range table */
+ 	for (i = 0, grt = _gr_table; i < _gr_table_len; i++, grt++) {
+ 		int gb = grt->base;
+ 		unsigned long start = gb < 0 ?  0 :
+ 			(unsigned long)_gr_table[gb].limit << UV_GAM_RANGE_SHFT;
+ 		unsigned long end =
+ 			(unsigned long)grt->limit << UV_GAM_RANGE_SHFT;
+ 
+ 		pr_info("UV: GAM Range %2d %04x 0x%013lx-0x%013lx (%d)\n",
+ 			i, grt->nasid, start, end, gb);
+ 	}
+ }
+ 
++>>>>>>> c85375cd1996 (x86/platform/UV: Update physical address conversions for UV4)
  static int uv_wakeup_secondary(int phys_apicid, unsigned long start_rip)
  {
 +#ifdef CONFIG_SMP
  	unsigned long val;
  	int pnode;
  
@@@ -999,6 -1079,13 +1111,16 @@@ void __init uv_init_hub_info(struct uv_
  
  	hub_info->hub_revision = uv_hub_info->hub_revision;
  	hub_info->pnode_mask = uv_cpuid.pnode_mask;
++<<<<<<< HEAD
++=======
+ 	hub_info->min_pnode = _min_pnode;
+ 	hub_info->min_socket = _min_socket;
+ 	hub_info->pnode_to_socket = _pnode_to_socket;
+ 	hub_info->socket_to_node = _socket_to_node;
+ 	hub_info->socket_to_pnode = _socket_to_pnode;
+ 	hub_info->gr_table_len = _gr_table_len;
+ 	hub_info->gr_table = _gr_table;
++>>>>>>> c85375cd1996 (x86/platform/UV: Update physical address conversions for UV4)
  	hub_info->gpa_mask = mn.m_val ?
  		(1UL << (mn.m_val + mn.n_val)) - 1 :
  		(1UL << uv_cpuid.gpa_shift) - 1;
@@@ -1030,9 -1131,275 +1152,275 @@@
  
  	pr_info("UV: gnode_upper:0x%lx gnode_extra:0x%x\n",
  		hub_info->gnode_upper, hub_info->gnode_extra);
 -}
  
 -static void __init decode_gam_params(unsigned long ptr)
 -{
 -	uv_gp_table = (struct uv_gam_parameters *)ptr;
 +	pr_info("UV: global MMR base 0x%lx\n", hub_info->global_mmr_base);
  
++<<<<<<< HEAD
++=======
+ 	pr_info("UV: GAM Params...\n");
+ 	pr_info("UV: mmr_base/shift:0x%llx/%d gru_base/shift:0x%llx/%d gpa_shift:%d\n",
+ 		uv_gp_table->mmr_base, uv_gp_table->mmr_shift,
+ 		uv_gp_table->gru_base, uv_gp_table->gru_shift,
+ 		uv_gp_table->gpa_shift);
+ }
+ 
+ static void __init decode_gam_rng_tbl(unsigned long ptr)
+ {
+ 	struct uv_gam_range_entry *gre = (struct uv_gam_range_entry *)ptr;
+ 	unsigned long lgre = 0;
+ 	int index = 0;
+ 	int sock_min = 999999, pnode_min = 99999;
+ 	int sock_max = -1, pnode_max = -1;
+ 
+ 	uv_gre_table = gre;
+ 	for (; gre->type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {
+ 		if (!index) {
+ 			pr_info("UV: GAM Range Table...\n");
+ 			pr_info("UV:  # %20s %14s %5s %4s %5s %3s %2s %3s\n",
+ 				"Range", "", "Size", "Type", "NASID",
+ 				"SID", "PN", "PXM");
+ 		}
+ 		pr_info(
+ 		"UV: %2d: 0x%014lx-0x%014lx %5luG %3d   %04x  %02x %02x %3d\n",
+ 			index++,
+ 			(unsigned long)lgre << UV_GAM_RANGE_SHFT,
+ 			(unsigned long)gre->limit << UV_GAM_RANGE_SHFT,
+ 			((unsigned long)(gre->limit - lgre)) >>
+ 				(30 - UV_GAM_RANGE_SHFT), /* 64M -> 1G */
+ 			gre->type, gre->nasid, gre->sockid,
+ 			gre->pnode, gre->pxm);
+ 
+ 		lgre = gre->limit;
+ 		if (sock_min > gre->sockid)
+ 			sock_min = gre->sockid;
+ 		if (sock_max < gre->sockid)
+ 			sock_max = gre->sockid;
+ 		if (pnode_min > gre->pnode)
+ 			pnode_min = gre->pnode;
+ 		if (pnode_max < gre->pnode)
+ 			pnode_max = gre->pnode;
+ 	}
+ 	_min_socket = sock_min;
+ 	_max_socket = sock_max;
+ 	_min_pnode = pnode_min;
+ 	_max_pnode = pnode_max;
+ 	_gr_table_len = index;
+ 	pr_info(
+ 	"UV: GRT: %d entries, sockets(min:%x,max:%x) pnodes(min:%x,max:%x)\n",
+ 		index, _min_socket, _max_socket, _min_pnode, _max_pnode);
+ }
+ 
+ static void __init decode_uv_systab(void)
+ {
+ 	struct uv_systab *st;
+ 	int i;
+ 
+ 	st = uv_systab;
+ 	if ((!st || st->revision < UV_SYSTAB_VERSION_UV4) && !is_uv4_hub())
+ 		return;
+ 	if (st->revision != UV_SYSTAB_VERSION_UV4_LATEST) {
+ 		pr_crit(
+ 		"UV: BIOS UVsystab version(%x) mismatch, expecting(%x)\n",
+ 			st->revision, UV_SYSTAB_VERSION_UV4_LATEST);
+ 		BUG();
+ 	}
+ 
+ 	for (i = 0; st->entry[i].type != UV_SYSTAB_TYPE_UNUSED; i++) {
+ 		unsigned long ptr = st->entry[i].offset;
+ 
+ 		if (!ptr)
+ 			continue;
+ 
+ 		ptr = ptr + (unsigned long)st;
+ 
+ 		switch (st->entry[i].type) {
+ 		case UV_SYSTAB_TYPE_GAM_PARAMS:
+ 			decode_gam_params(ptr);
+ 			break;
+ 
+ 		case UV_SYSTAB_TYPE_GAM_RNG_TBL:
+ 			decode_gam_rng_tbl(ptr);
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ /*
+  * Setup physical blade translations from UVH_NODE_PRESENT_TABLE
+  * .. NB: UVH_NODE_PRESENT_TABLE is going away,
+  * .. being replaced by GAM Range Table
+  */
+ static __init void boot_init_possible_blades(struct uv_hub_info_s *hub_info)
+ {
+ 	size_t bytes;
+ 	int blade, i, j, uv_pb = 0, num_nodes = num_possible_nodes();
+ 
+ 	pr_info("UV: NODE_PRESENT_DEPTH = %d\n", UVH_NODE_PRESENT_TABLE_DEPTH);
+ 	for (i = 0; i < UVH_NODE_PRESENT_TABLE_DEPTH; i++) {
+ 		unsigned long np;
+ 
+ 		np = uv_read_local_mmr(UVH_NODE_PRESENT_TABLE + i * 8);
+ 		if (np)
+ 			pr_info("UV: NODE_PRESENT(%d) = 0x%016lx\n", i, np);
+ 
+ 		uv_pb += hweight64(np);
+ 	}
+ 	if (uv_possible_blades != uv_pb)
+ 		uv_possible_blades = uv_pb;
+ 
+ 	bytes = num_nodes * sizeof(_node_to_pnode[0]);
+ 	_node_to_pnode = kmalloc(bytes, GFP_KERNEL);
+ 	BUG_ON(!_node_to_pnode);
+ 
+ 	for (blade = 0, i = 0; i < UVH_NODE_PRESENT_TABLE_DEPTH; i++) {
+ 		unsigned short pnode;
+ 		unsigned long present =
+ 			uv_read_local_mmr(UVH_NODE_PRESENT_TABLE + i * 8);
+ 
+ 		for (j = 0; j < 64; j++) {
+ 			if (!test_bit(j, &present))
+ 				continue;
+ 			pnode = (i * 64 + j) & hub_info->pnode_mask;
+ 			_node_to_pnode[blade++] = pnode;
+ 		}
+ 		if (blade > num_nodes) {
+ 			pr_err("UV: blade count(%d) exceeds node count(%d)!\n",
+ 				blade, num_nodes);
+ 			BUG();
+ 		}
+ 	}
+ }
+ 
+ static void __init build_socket_tables(void)
+ {
+ 	struct uv_gam_range_entry *gre = uv_gre_table;
+ 	int num, nump;
+ 	int cpu, i, lnid;
+ 	int minsock = _min_socket;
+ 	int maxsock = _max_socket;
+ 	int minpnode = _min_pnode;
+ 	int maxpnode = _max_pnode;
+ 	size_t bytes;
+ 
+ 	if (!gre) {
+ 		if (is_uv1_hub() || is_uv2_hub() || is_uv3_hub()) {
+ 			pr_info("UV: No UVsystab socket table, ignoring\n");
+ 			return;		/* not required */
+ 		}
+ 		pr_crit(
+ 		"UV: Error: UVsystab address translations not available!\n");
+ 		BUG();
+ 	}
+ 
+ 	/* build socket id -> node id, pnode */
+ 	num = maxsock - minsock + 1;
+ 	bytes = num * sizeof(_socket_to_node[0]);
+ 	_socket_to_node = kmalloc(bytes, GFP_KERNEL);
+ 	_socket_to_pnode = kmalloc(bytes, GFP_KERNEL);
+ 
+ 	nump = maxpnode - minpnode + 1;
+ 	bytes = nump * sizeof(_pnode_to_socket[0]);
+ 	_pnode_to_socket = kmalloc(bytes, GFP_KERNEL);
+ 	BUG_ON(!_socket_to_node || !_socket_to_pnode || !_pnode_to_socket);
+ 
+ 	for (i = 0; i < num; i++)
+ 		_socket_to_node[i] = _socket_to_pnode[i] = SOCK_EMPTY;
+ 
+ 	for (i = 0; i < nump; i++)
+ 		_pnode_to_socket[i] = SOCK_EMPTY;
+ 
+ 	/* fill in pnode/node/addr conversion list values */
+ 	pr_info("UV: GAM Building socket/pnode/pxm conversion tables\n");
+ 	for (; gre->type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {
+ 		if (gre->type == UV_GAM_RANGE_TYPE_HOLE)
+ 			continue;
+ 		i = gre->sockid - minsock;
+ 		if (_socket_to_pnode[i] != SOCK_EMPTY)
+ 			continue;	/* duplicate */
+ 		_socket_to_pnode[i] = gre->pnode;
+ 		_socket_to_node[i] = gre->pxm;
+ 
+ 		i = gre->pnode - minpnode;
+ 		_pnode_to_socket[i] = gre->sockid;
+ 
+ 		pr_info(
+ 		"UV: sid:%02x type:%d nasid:%04x pn:%02x pxm:%2d pn2s:%2x\n",
+ 			gre->sockid, gre->type, gre->nasid,
+ 			_socket_to_pnode[gre->sockid - minsock],
+ 			_socket_to_node[gre->sockid - minsock],
+ 			_pnode_to_socket[gre->pnode - minpnode]);
+ 	}
+ 
+ 	/* check socket -> node values */
+ 	lnid = -1;
+ 	for_each_present_cpu(cpu) {
+ 		int nid = cpu_to_node(cpu);
+ 		int apicid, sockid;
+ 
+ 		if (lnid == nid)
+ 			continue;
+ 		lnid = nid;
+ 		apicid = per_cpu(x86_cpu_to_apicid, cpu);
+ 		sockid = apicid >> uv_cpuid.socketid_shift;
+ 		i = sockid - minsock;
+ 
+ 		if (nid != _socket_to_node[i]) {
+ 			pr_warn(
+ 			"UV: %02x: type:%d socket:%02x PXM:%02x != node:%2d\n",
+ 				i, sockid, gre->type, _socket_to_node[i], nid);
+ 			_socket_to_node[i] = nid;
+ 		}
+ 	}
+ 
+ 	/* Setup physical blade to pnode translation from GAM Range Table */
+ 	bytes = num_possible_nodes() * sizeof(_node_to_pnode[0]);
+ 	_node_to_pnode = kmalloc(bytes, GFP_KERNEL);
+ 	BUG_ON(!_node_to_pnode);
+ 
+ 	for (lnid = 0; lnid < num_possible_nodes(); lnid++) {
+ 		unsigned short sockid;
+ 
+ 		for (sockid = minsock; sockid <= maxsock; sockid++) {
+ 			if (lnid == _socket_to_node[sockid - minsock]) {
+ 				_node_to_pnode[lnid] =
+ 					_socket_to_pnode[sockid - minsock];
+ 				break;
+ 			}
+ 		}
+ 		if (sockid > maxsock) {
+ 			pr_err("UV: socket for node %d not found!\n", lnid);
+ 			BUG();
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * If socket id == pnode or socket id == node for all nodes,
+ 	 *   system runs faster by removing corresponding conversion table.
+ 	 */
+ 	pr_info("UV: Checking socket->node/pnode for identity maps\n");
+ 	if (minsock == 0) {
+ 		for (i = 0; i < num; i++)
+ 			if (_socket_to_node[i] == SOCK_EMPTY ||
+ 				i != _socket_to_node[i])
+ 				break;
+ 		if (i >= num) {
+ 			kfree(_socket_to_node);
+ 			_socket_to_node = NULL;
+ 			pr_info("UV: 1:1 socket_to_node table removed\n");
+ 		}
+ 	}
+ 	if (minsock == minpnode) {
+ 		for (i = 0; i < num; i++)
+ 			if (_socket_to_pnode[i] != SOCK_EMPTY &&
+ 				_socket_to_pnode[i] != i + minpnode)
+ 				break;
+ 		if (i >= num) {
+ 			kfree(_socket_to_pnode);
+ 			_socket_to_pnode = NULL;
+ 			pr_info("UV: 1:1 socket_to_pnode table removed\n");
+ 		}
+ 	}
++>>>>>>> c85375cd1996 (x86/platform/UV: Update physical address conversions for UV4)
  }
  
  void __init uv_system_init(void)
@@@ -1050,13 -1417,19 +1438,24 @@@
  		return;
  	}
  	pr_info("UV: Found %s hub\n", hub);
 +	map_low_mmrs();
  
++<<<<<<< HEAD
++=======
+ 	/* We now only need to map the MMRs on UV1 */
+ 	if (is_uv1_hub())
+ 		map_low_mmrs();
+ 
+ 	uv_bios_init();			/* get uv_systab for decoding */
+ 	decode_uv_systab();
+ 	build_socket_tables();
+ 	build_uv_gr_table();
++>>>>>>> c85375cd1996 (x86/platform/UV: Update physical address conversions for UV4)
  	uv_init_hub_info(&hub_info);
 -	uv_possible_blades = num_possible_nodes();
 -	if (!_node_to_pnode)
 -		boot_init_possible_blades(&hub_info);
 +
 +	for(i = 0; i < UVH_NODE_PRESENT_TABLE_DEPTH; i++)
 +		uv_possible_blades +=
 +		  hweight64(uv_read_local_mmr( UVH_NODE_PRESENT_TABLE + i * 8));
  
  	/* uv_num_possible_blades() is really the hub count */
  	pr_info("UV: Found %d hubs, %d nodes, %d cpus\n",
* Unmerged path arch/x86/include/asm/uv/uv_hub.h
* Unmerged path arch/x86/kernel/apic/x2apic_uv_x.c
