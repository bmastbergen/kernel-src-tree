scsi: use host wide tags by default

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 64d513ac31bd02a3c9b69ef04444f36c196f9a9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/64d513ac.failed

This patch changes the !blk-mq path to the same defaults as the blk-mq
I/O path by always enabling block tagging, and always using host wide
tags.  We've had blk-mq available for a few releases so bugs with
this mode should have been ironed out, and this ensures we get better
coverage of over tagging setup over different configs.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Acked-by: Jens Axboe <axboe@kernel.dk>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: James Bottomley <JBottomley@Odin.com>
(cherry picked from commit 64d513ac31bd02a3c9b69ef04444f36c196f9a9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/srp/ib_srp.c
#	drivers/scsi/53c700.c
#	drivers/scsi/advansys.c
#	drivers/scsi/aic94xx/aic94xx_init.c
#	drivers/scsi/bnx2fc/bnx2fc_fcoe.c
#	drivers/scsi/esas2r/esas2r_main.c
#	drivers/scsi/fcoe/fcoe.c
#	drivers/scsi/fnic/fnic_main.c
#	drivers/scsi/hpsa.c
#	drivers/scsi/ibmvscsi/ibmvfc.c
#	drivers/scsi/isci/init.c
#	drivers/scsi/lpfc/lpfc_scsi.c
#	drivers/scsi/megaraid/megaraid_sas_base.c
#	drivers/scsi/mvsas/mv_init.c
#	drivers/scsi/pm8001/pm8001_init.c
#	drivers/scsi/pmcraid.c
#	drivers/scsi/qla2xxx/qla_os.c
#	drivers/scsi/scsi.c
#	drivers/scsi/scsi_scan.c
#	drivers/scsi/snic/snic_main.c
#	drivers/scsi/ufs/ufshcd.c
#	drivers/target/loopback/tcm_loop.c
#	drivers/usb/storage/uas.c
#	include/scsi/scsi_host.h
#	include/scsi/scsi_tcq.h
diff --cc drivers/infiniband/ulp/srp/ib_srp.c
index c2d8da26082d,96014dc4b6dd..000000000000
--- a/drivers/infiniband/ulp/srp/ib_srp.c
+++ b/drivers/infiniband/ulp/srp/ib_srp.c
@@@ -2788,7 -2750,7 +2788,11 @@@ static struct scsi_host_template srp_te
  	.cmd_per_lun			= SRP_DEFAULT_CMD_SQ_SIZE,
  	.use_clustering			= ENABLE_CLUSTERING,
  	.shost_attrs			= srp_host_attrs,
++<<<<<<< HEAD
 +	.use_blk_tags			= 1,
++=======
+ 	.track_queue_depth		= 1,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
  
  static int srp_sdev_count(struct Scsi_Host *host)
diff --cc drivers/scsi/53c700.c
index 1d90a96ad3da,d4c285688ce9..000000000000
--- a/drivers/scsi/53c700.c
+++ b/drivers/scsi/53c700.c
@@@ -326,7 -325,6 +326,10 @@@ NCR_700_detect(struct scsi_host_templat
  	tpnt->slave_destroy = NCR_700_slave_destroy;
  	tpnt->slave_alloc = NCR_700_slave_alloc;
  	tpnt->change_queue_depth = NCR_700_change_queue_depth;
++<<<<<<< HEAD
 +	tpnt->change_queue_type = NCR_700_change_queue_type;
++=======
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  
  	if(tpnt->name == NULL)
  		tpnt->name = "53c700";
diff --cc drivers/scsi/advansys.c
index 0a6ecbd229b8,519f9a4b3dad..000000000000
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@@ -11679,24 -11210,6 +11679,27 @@@ static int advansys_board_found(struct 
  		/* Set maximum number of queues the adapter can handle. */
  		shost->can_queue = adv_dvc_varp->max_host_qng;
  	}
++<<<<<<< HEAD
 +
 +	/*
 +	 * Following v1.3.89, 'cmd_per_lun' is no longer needed
 +	 * and should be set to zero.
 +	 *
 +	 * But because of a bug introduced in v1.3.89 if the driver is
 +	 * compiled as a module and 'cmd_per_lun' is zero, the Mid-Level
 +	 * SCSI function 'allocate_device' will panic. To allow the driver
 +	 * to work as a module in these kernels set 'cmd_per_lun' to 1.
 +	 *
 +	 * Note: This is wrong.  cmd_per_lun should be set to the depth
 +	 * you want on untagged devices always.
 +	 #ifdef MODULE
 +	 */
 +	shost->cmd_per_lun = 1;
 +/* #else
 +            shost->cmd_per_lun = 0;
 +#endif */
++=======
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  
  	/*
  	 * Set the maximum number of scatter-gather elements the
diff --cc drivers/scsi/aic94xx/aic94xx_init.c
index e633d4ca83b9,cd094bf82a77..000000000000
--- a/drivers/scsi/aic94xx/aic94xx_init.c
+++ b/drivers/scsi/aic94xx/aic94xx_init.c
@@@ -75,6 -73,7 +75,10 @@@ static struct scsi_host_template aic94x
  	.eh_bus_reset_handler	= sas_eh_bus_reset_handler,
  	.target_destroy		= sas_target_destroy,
  	.ioctl			= sas_ioctl,
++<<<<<<< HEAD
++=======
+ 	.track_queue_depth	= 1,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
  
  static int asd_map_memio(struct asd_ha_struct *asd_ha)
diff --cc drivers/scsi/bnx2fc/bnx2fc_fcoe.c
index ec669ac17ded,0857d80f2999..000000000000
--- a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
@@@ -2879,6 -2867,7 +2879,10 @@@ static struct scsi_host_template bnx2fc
  	.use_clustering		= ENABLE_CLUSTERING,
  	.sg_tablesize		= BNX2FC_MAX_BDS_PER_CMD,
  	.max_sectors		= 1024,
++<<<<<<< HEAD
++=======
+ 	.track_queue_depth	= 1,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
  
  static struct libfc_function_template bnx2fc_libfc_fcn_templ = {
diff --cc drivers/scsi/fcoe/fcoe.c
index e678ac0b5aac,f4424063b860..000000000000
--- a/drivers/scsi/fcoe/fcoe.c
+++ b/drivers/scsi/fcoe/fcoe.c
@@@ -288,6 -287,7 +288,10 @@@ static struct scsi_host_template fcoe_s
  	.use_clustering = ENABLE_CLUSTERING,
  	.sg_tablesize = SG_ALL,
  	.max_sectors = 0xffff,
++<<<<<<< HEAD
++=======
+ 	.track_queue_depth = 1,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
  
  /**
diff --cc drivers/scsi/fnic/fnic_main.c
index 5ca553c98c20,58ce9020d69c..000000000000
--- a/drivers/scsi/fnic/fnic_main.c
+++ b/drivers/scsi/fnic/fnic_main.c
@@@ -121,6 -118,7 +121,10 @@@ static struct scsi_host_template fnic_h
  	.sg_tablesize = FNIC_MAX_SG_DESC_CNT,
  	.max_sectors = 0xffff,
  	.shost_attrs = fnic_attrs,
++<<<<<<< HEAD
++=======
+ 	.track_queue_depth = 1,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
  
  static void
diff --cc drivers/scsi/hpsa.c
index f29dd938faad,7506b65d8e6c..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -5056,16 -5003,7 +5055,20 @@@ static int hpsa_scsi_host_alloc(struct 
  	sh->hostdata[0] = (unsigned long) h;
  	sh->irq = h->intr[h->intr_mode];
  	sh->unique_id = sh->irq;
++<<<<<<< HEAD
 +	if (!shost_use_blk_mq(sh)) {
 +		error = scsi_init_shared_tag_map(sh, sh->can_queue);
 +		if (error) {
 +			dev_err(&h->pdev->dev,
 +				"%s: scsi_init_shared_tag_map failed for ctlr %d\n",
 +				__func__, h->ctlr);
 +				scsi_host_put(sh);
 +				return error;
 +		}
 +	}
++=======
+ 
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  	h->scsi_host = sh;
  	return 0;
  }
diff --cc drivers/scsi/ibmvscsi/ibmvfc.c
index 6ae5e47dc4e3,6aa317c303e2..000000000000
--- a/drivers/scsi/ibmvscsi/ibmvfc.c
+++ b/drivers/scsi/ibmvscsi/ibmvfc.c
@@@ -3142,6 -3095,7 +3142,10 @@@ static struct scsi_host_template driver
  	.max_sectors = IBMVFC_MAX_SECTORS,
  	.use_clustering = ENABLE_CLUSTERING,
  	.shost_attrs = ibmvfc_attrs,
++<<<<<<< HEAD
++=======
+ 	.track_queue_depth = 1,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
  
  /**
diff --cc drivers/scsi/isci/init.c
index 122172239fc4,2f973df72d9b..000000000000
--- a/drivers/scsi/isci/init.c
+++ b/drivers/scsi/isci/init.c
@@@ -172,6 -170,7 +172,10 @@@ static struct scsi_host_template isci_s
  	.target_destroy			= sas_target_destroy,
  	.ioctl				= sas_ioctl,
  	.shost_attrs			= isci_host_attrs,
++<<<<<<< HEAD
++=======
+ 	.track_queue_depth		= 1,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
  
  static struct sas_domain_function_template isci_transport_ops  = {
diff --cc drivers/scsi/lpfc/lpfc_scsi.c
index 3eb3ea7b0233,4679ed4444a7..000000000000
--- a/drivers/scsi/lpfc/lpfc_scsi.c
+++ b/drivers/scsi/lpfc/lpfc_scsi.c
@@@ -5996,8 -5913,8 +5996,13 @@@ struct scsi_host_template lpfc_template
  	.shost_attrs		= lpfc_hba_attrs,
  	.max_sectors		= 0xFFFF,
  	.vendor_id		= LPFC_NL_VENDOR_ID,
++<<<<<<< HEAD
 +	.change_queue_depth	= lpfc_change_queue_depth,
 +	.change_queue_type	= lpfc_change_queue_type,
++=======
+ 	.change_queue_depth	= scsi_change_queue_depth,
+ 	.track_queue_depth	= 1,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
  
  struct scsi_host_template lpfc_template = {
@@@ -6021,8 -5938,8 +6026,13 @@@
  	.shost_attrs		= lpfc_hba_attrs,
  	.max_sectors		= 0xFFFF,
  	.vendor_id		= LPFC_NL_VENDOR_ID,
++<<<<<<< HEAD
 +	.change_queue_depth	= lpfc_change_queue_depth,
 +	.change_queue_type	= lpfc_change_queue_type,
++=======
+ 	.change_queue_depth	= scsi_change_queue_depth,
+ 	.track_queue_depth	= 1,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
  
  struct scsi_host_template lpfc_vport_template = {
@@@ -6044,6 -5961,6 +6054,11 @@@
  	.use_clustering		= ENABLE_CLUSTERING,
  	.shost_attrs		= lpfc_vport_attrs,
  	.max_sectors		= 0xFFFF,
++<<<<<<< HEAD
 +	.change_queue_depth	= lpfc_change_queue_depth,
 +	.change_queue_type	= lpfc_change_queue_type,
++=======
+ 	.change_queue_depth	= scsi_change_queue_depth,
+ 	.track_queue_depth	= 1,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
diff --cc drivers/scsi/megaraid/megaraid_sas_base.c
index 70e12aa6134e,3b3f4809331b..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@@ -5263,7 -5049,6 +5263,10 @@@ static int megasas_start_aen(struct meg
  static int megasas_io_attach(struct megasas_instance *instance)
  {
  	struct Scsi_Host *host = instance->host;
++<<<<<<< HEAD
 +	u32		error;
++=======
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  
  	/*
  	 * Export parameters required by SCSI mid-layer
diff --cc drivers/scsi/mvsas/mv_init.c
index 02474d41dbc6,221d25e9dc5f..000000000000
--- a/drivers/scsi/mvsas/mv_init.c
+++ b/drivers/scsi/mvsas/mv_init.c
@@@ -67,6 -65,7 +67,10 @@@ static struct scsi_host_template mvs_sh
  	.target_destroy		= sas_target_destroy,
  	.ioctl			= sas_ioctl,
  	.shost_attrs		= mvst_host_attrs,
++<<<<<<< HEAD
++=======
+ 	.track_queue_depth	= 1,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
  
  static struct sas_domain_function_template mvs_transport_ops = {
diff --cc drivers/scsi/pm8001/pm8001_init.c
index bd6a3b0d923d,e64b8bfafd80..000000000000
--- a/drivers/scsi/pm8001/pm8001_init.c
+++ b/drivers/scsi/pm8001/pm8001_init.c
@@@ -89,6 -88,7 +89,10 @@@ static struct scsi_host_template pm8001
  	.target_destroy		= sas_target_destroy,
  	.ioctl			= sas_ioctl,
  	.shost_attrs		= pm8001_host_attrs,
++<<<<<<< HEAD
++=======
+ 	.track_queue_depth	= 1,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
  
  /**
diff --cc drivers/scsi/pmcraid.c
index 16da4df74d03,48d62249c226..000000000000
--- a/drivers/scsi/pmcraid.c
+++ b/drivers/scsi/pmcraid.c
@@@ -4329,7 -4253,7 +4329,11 @@@ static struct scsi_host_template pmcrai
  	.cmd_per_lun = PMCRAID_MAX_CMD_PER_LUN,
  	.use_clustering = ENABLE_CLUSTERING,
  	.shost_attrs = pmcraid_host_attrs,
++<<<<<<< HEAD
 +	.proc_name = PMCRAID_DRIVER_NAME
++=======
+ 	.proc_name = PMCRAID_DRIVER_NAME,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
  
  /*
diff --cc drivers/scsi/qla2xxx/qla_os.c
index fab9f3d4c99d,bfa9a64c316b..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -270,6 -267,7 +270,10 @@@ struct scsi_host_template qla2xxx_drive
  	.shost_attrs		= qla2x00_host_attrs,
  
  	.supported_mode		= MODE_INITIATOR,
++<<<<<<< HEAD
++=======
+ 	.track_queue_depth	= 1,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
  
  static struct scsi_transport_template *qla2xxx_transport_template = NULL;
diff --cc drivers/scsi/scsi.c
index a9080c4f426e,d07fb653f5dc..000000000000
--- a/drivers/scsi/scsi.c
+++ b/drivers/scsi/scsi.c
@@@ -725,78 -606,24 +725,87 @@@ void scsi_finish_command(struct scsi_cm
  	}
  	scsi_io_completion(cmd, good_bytes);
  }
 +EXPORT_SYMBOL(scsi_finish_command);
  
  /**
 - * scsi_change_queue_depth - change a device's queue depth
 + * scsi_adjust_queue_depth - Let low level drivers change a device's queue depth
   * @sdev: SCSI Device in question
 - * @depth: number of commands allowed to be queued to the driver
 + * @tagged: Do we use tagged queueing (non-0) or do we treat
 + *          this device as an untagged device (0)
 + * @tags: Number of tags allowed if tagged queueing enabled,
 + *        or number of commands the low level driver can
 + *        queue up in non-tagged mode (as per cmd_per_lun).
 + *
 + * Returns:	Nothing
 + *
 + * Lock Status:	None held on entry
   *
 - * Sets the device queue depth and returns the new value.
 + * Notes:	Low level drivers may call this at any time and we will do
 + * 		the right thing depending on whether or not the device is
 + * 		currently active and whether or not it even has the
 + * 		command blocks built yet.
   */
 -int scsi_change_queue_depth(struct scsi_device *sdev, int depth)
 +void scsi_adjust_queue_depth(struct scsi_device *sdev, int tagged, int tags)
  {
++<<<<<<< HEAD
 +	unsigned long flags;
 +
 +	/*
 +	 * refuse to set tagged depth to an unworkable size
 +	 */
 +	if (tags <= 0)
 +		return;
 +
 +	spin_lock_irqsave(sdev->request_queue->queue_lock, flags);
 +
 +	/*
 +	 * Check to see if the queue is managed by the block layer.
 +	 * If it is, and we fail to adjust the depth, exit.
 +	 *
 +	 * Do not resize the tag map if it is a host wide share bqt,
 +	 * because the size should be the hosts's can_queue. If there
 +	 * is more IO than the LLD's can_queue (so there are not enuogh
 +	 * tags) request_fn's host queue ready check will handle it.
 +	 */
 +	if (!shost_use_blk_mq(sdev->host) && !sdev->host->bqt) {
 +		if (blk_queue_tagged(sdev->request_queue) &&
 +		    blk_queue_resize_tags(sdev->request_queue, tags) != 0)
 +			goto out;
 +	}
 +
 +	sdev->queue_depth = tags;
 +	switch (tagged) {
 +		case 0:
 +			sdev->ordered_tags = 0;
 +			sdev->simple_tags = 0;
 +			break;
 +		case MSG_ORDERED_TAG:
 +			sdev->ordered_tags = 1;
 +			sdev->simple_tags = 1;
 +			break;
 +		case MSG_SIMPLE_TAG:
 +			sdev->ordered_tags = 0;
 +			sdev->simple_tags = 1;
 +			break;
 +		default:
 +			sdev->ordered_tags = 0;
 +			sdev->simple_tags = 0;
 +			sdev_printk(KERN_WARNING, sdev,
 +				    "scsi_adjust_queue_depth, bad queue type, "
 +				    "disabled\n");
 +	}
 + out:
 +	spin_unlock_irqrestore(sdev->request_queue->queue_lock, flags);
++=======
+ 	if (depth > 0) {
+ 		sdev->queue_depth = depth;
+ 		wmb();
+ 	}
+ 
+ 	return sdev->queue_depth;
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  }
 -EXPORT_SYMBOL(scsi_change_queue_depth);
 +EXPORT_SYMBOL(scsi_adjust_queue_depth);
  
  /**
   * scsi_track_queue_full - track QUEUE_FULL events to adjust queue depth
diff --cc drivers/scsi/scsi_scan.c
index 20209c4d4196,998f3788d8e9..000000000000
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@@ -294,7 -273,14 +294,18 @@@ static struct scsi_device *scsi_alloc_s
  	}
  	WARN_ON_ONCE(!blk_get_queue(sdev->request_queue));
  	sdev->request_queue->queuedata = sdev;
++<<<<<<< HEAD
 +	scsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);
++=======
+ 
+ 	if (!shost_use_blk_mq(sdev->host)) {
+ 		blk_queue_init_tags(sdev->request_queue,
+ 				    sdev->host->cmd_per_lun, shost->bqt,
+ 				    shost->hostt->tag_alloc_policy);
+ 	}
+ 	scsi_change_queue_depth(sdev, sdev->host->cmd_per_lun ?
+ 					sdev->host->cmd_per_lun : 1);
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  
  	scsi_sysfs_device_initialize(sdev);
  
diff --cc drivers/scsi/ufs/ufshcd.c
index c32a478df81b,9065eb451677..000000000000
--- a/drivers/scsi/ufs/ufshcd.c
+++ b/drivers/scsi/ufs/ufshcd.c
@@@ -1446,138 -5201,154 +1446,143 @@@ out
  }
  
  /**
 - * ufshcd_system_suspend - system suspend routine
 - * @hba: per adapter instance
 - * @pm_op: runtime PM or system PM
 - *
 - * Check the description of ufshcd_suspend() function for more details.
 + * ufshcd_host_reset - Main reset function registered with scsi layer
 + * @cmd: SCSI command pointer
   *
 - * Returns 0 for success and non-zero for failure
 + * Returns SUCCESS/FAILED
   */
 -int ufshcd_system_suspend(struct ufs_hba *hba)
 +static int ufshcd_host_reset(struct scsi_cmnd *cmd)
  {
 -	int ret = 0;
 -
 -	if (!hba || !hba->is_powered)
 -		return 0;
 +	struct ufs_hba *hba;
  
 -	if (pm_runtime_suspended(hba->dev)) {
 -		if (hba->rpm_lvl == hba->spm_lvl)
 -			/*
 -			 * There is possibility that device may still be in
 -			 * active state during the runtime suspend.
 -			 */
 -			if ((ufs_get_pm_lvl_to_dev_pwr_mode(hba->spm_lvl) ==
 -			    hba->curr_dev_pwr_mode) && !hba->auto_bkops_enabled)
 -				goto out;
 +	hba = shost_priv(cmd->device->host);
  
 -		/*
 -		 * UFS device and/or UFS link low power states during runtime
 -		 * suspend seems to be different than what is expected during
 -		 * system suspend. Hence runtime resume the devic & link and
 -		 * let the system suspend low power states to take effect.
 -		 * TODO: If resume takes longer time, we might have optimize
 -		 * it in future by not resuming everything if possible.
 -		 */
 -		ret = ufshcd_runtime_resume(hba);
 -		if (ret)
 -			goto out;
 -	}
 +	if (hba->ufshcd_state == UFSHCD_STATE_RESET)
 +		return SUCCESS;
  
 -	ret = ufshcd_suspend(hba, UFS_SYSTEM_PM);
 -out:
 -	if (!ret)
 -		hba->is_sys_suspended = true;
 -	return ret;
 +	return ufshcd_do_reset(hba);
  }
 -EXPORT_SYMBOL(ufshcd_system_suspend);
  
  /**
 - * ufshcd_system_resume - system resume routine
 - * @hba: per adapter instance
 + * ufshcd_abort - abort a specific command
 + * @cmd: SCSI command pointer
   *
 - * Returns 0 for success and non-zero for failure
 + * Returns SUCCESS/FAILED
   */
 -
 -int ufshcd_system_resume(struct ufs_hba *hba)
 +static int ufshcd_abort(struct scsi_cmnd *cmd)
  {
 -	if (!hba || !hba->is_powered || pm_runtime_suspended(hba->dev))
 -		/*
 -		 * Let the runtime resume take care of resuming
 -		 * if runtime suspended.
 -		 */
 -		return 0;
 +	struct Scsi_Host *host;
 +	struct ufs_hba *hba;
 +	unsigned long flags;
 +	unsigned int tag;
 +	int err;
 +
 +	host = cmd->device->host;
 +	hba = shost_priv(host);
 +	tag = cmd->request->tag;
 +
 +	spin_lock_irqsave(host->host_lock, flags);
 +
 +	/* check if command is still pending */
 +	if (!(test_bit(tag, &hba->outstanding_reqs))) {
 +		err = FAILED;
 +		spin_unlock_irqrestore(host->host_lock, flags);
 +		goto out;
 +	}
 +	spin_unlock_irqrestore(host->host_lock, flags);
 +
 +	err = ufshcd_issue_tm_cmd(hba, &hba->lrb[tag], UFS_ABORT_TASK);
 +	if (err == FAILED)
 +		goto out;
 +
 +	scsi_dma_unmap(cmd);
 +
 +	spin_lock_irqsave(host->host_lock, flags);
 +
 +	/* clear the respective UTRLCLR register bit */
 +	ufshcd_utrl_clear(hba, tag);
  
 -	return ufshcd_resume(hba, UFS_SYSTEM_PM);
 +	__clear_bit(tag, &hba->outstanding_reqs);
 +	hba->lrb[tag].cmd = NULL;
 +	spin_unlock_irqrestore(host->host_lock, flags);
 +out:
 +	return err;
  }
 -EXPORT_SYMBOL(ufshcd_system_resume);
 +
 +static struct scsi_host_template ufshcd_driver_template = {
 +	.module			= THIS_MODULE,
 +	.name			= UFSHCD,
 +	.proc_name		= UFSHCD,
 +	.queuecommand		= ufshcd_queuecommand,
 +	.slave_alloc		= ufshcd_slave_alloc,
 +	.slave_destroy		= ufshcd_slave_destroy,
 +	.eh_abort_handler	= ufshcd_abort,
 +	.eh_device_reset_handler = ufshcd_device_reset,
 +	.eh_host_reset_handler	= ufshcd_host_reset,
 +	.this_id		= -1,
 +	.sg_tablesize		= SG_ALL,
 +	.cmd_per_lun		= UFSHCD_CMD_PER_LUN,
 +	.can_queue		= UFSHCD_CAN_QUEUE,
++<<<<<<< HEAD
++=======
++	.max_host_blocked	= 1,
++	.track_queue_depth	= 1,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
 +};
  
  /**
 - * ufshcd_runtime_suspend - runtime suspend routine
 + * ufshcd_suspend - suspend power management function
   * @hba: per adapter instance
 + * @state: power state
   *
 - * Check the description of ufshcd_suspend() function for more details.
 - *
 - * Returns 0 for success and non-zero for failure
 + * Returns -ENOSYS
   */
 -int ufshcd_runtime_suspend(struct ufs_hba *hba)
 +int ufshcd_suspend(struct ufs_hba *hba, pm_message_t state)
  {
 -	if (!hba || !hba->is_powered)
 -		return 0;
 +	/*
 +	 * TODO:
 +	 * 1. Block SCSI requests from SCSI midlayer
 +	 * 2. Change the internal driver state to non operational
 +	 * 3. Set UTRLRSR and UTMRLRSR bits to zero
 +	 * 4. Wait until outstanding commands are completed
 +	 * 5. Set HCE to zero to send the UFS host controller to reset state
 +	 */
  
 -	return ufshcd_suspend(hba, UFS_RUNTIME_PM);
 +	return -ENOSYS;
  }
 -EXPORT_SYMBOL(ufshcd_runtime_suspend);
 +EXPORT_SYMBOL_GPL(ufshcd_suspend);
  
  /**
 - * ufshcd_runtime_resume - runtime resume routine
 + * ufshcd_resume - resume power management function
   * @hba: per adapter instance
   *
 - * This function basically brings the UFS device, UniPro link and controller
 - * to active state. Following operations are done in this function:
 - *
 - * 1. Turn on all the controller related clocks
 - * 2. Bring the UniPro link out of Hibernate state
 - * 3. If UFS device is in sleep state, turn ON VCC rail and bring the UFS device
 - *    to active state.
 - * 4. If auto-bkops is enabled on the device, disable it.
 - *
 - * So following would be the possible power state after this function return
 - * successfully:
 - *	S1: UFS device in Active state with VCC rail ON
 - *	    UniPro link in Active state
 - *	    All the UFS/UniPro controller clocks are ON
 - *
 - * Returns 0 for success and non-zero for failure
 + * Returns -ENOSYS
   */
 -int ufshcd_runtime_resume(struct ufs_hba *hba)
 +int ufshcd_resume(struct ufs_hba *hba)
  {
 -	if (!hba || !hba->is_powered)
 -		return 0;
 -	else
 -		return ufshcd_resume(hba, UFS_RUNTIME_PM);
 -}
 -EXPORT_SYMBOL(ufshcd_runtime_resume);
 +	/*
 +	 * TODO:
 +	 * 1. Set HCE to 1, to start the UFS host controller
 +	 * initialization process
 +	 * 2. Set UTRLRSR and UTMRLRSR bits to 1
 +	 * 3. Change the internal driver state to operational
 +	 * 4. Unblock SCSI requests from SCSI midlayer
 +	 */
  
 -int ufshcd_runtime_idle(struct ufs_hba *hba)
 -{
 -	return 0;
 +	return -ENOSYS;
  }
 -EXPORT_SYMBOL(ufshcd_runtime_idle);
 +EXPORT_SYMBOL_GPL(ufshcd_resume);
  
  /**
 - * ufshcd_shutdown - shutdown routine
 + * ufshcd_hba_free - free allocated memory for
 + *			host memory space data structures
   * @hba: per adapter instance
 - *
 - * This function would power off both UFS device and UFS link.
 - *
 - * Returns 0 always to allow force shutdown even in case of errors.
   */
 -int ufshcd_shutdown(struct ufs_hba *hba)
 +static void ufshcd_hba_free(struct ufs_hba *hba)
  {
 -	int ret = 0;
 -
 -	if (ufshcd_is_ufs_dev_poweroff(hba) && ufshcd_is_link_off(hba))
 -		goto out;
 -
 -	if (pm_runtime_suspended(hba->dev)) {
 -		ret = ufshcd_runtime_resume(hba);
 -		if (ret)
 -			goto out;
 -	}
 -
 -	ret = ufshcd_suspend(hba, UFS_SHUTDOWN_PM);
 -out:
 -	if (ret)
 -		dev_err(hba->dev, "%s failed, err %d\n", __func__, ret);
 -	/* allow force shutdown even in case of errors */
 -	return 0;
 +	iounmap(hba->mmio_base);
 +	ufshcd_free_hba_memory(hba);
  }
 -EXPORT_SYMBOL(ufshcd_shutdown);
  
  /**
   * ufshcd_remove - de-allocate SCSI host and host memory space
@@@ -1663,27 -5589,35 +1668,30 @@@ int ufshcd_init(struct device *dev, str
  	host->unique_id = host->host_no;
  	host->max_cmd_len = MAX_CDB_SIZE;
  
 -	hba->max_pwr_info.is_valid = false;
 -
  	/* Initailize wait queue for task management */
 -	init_waitqueue_head(&hba->tm_wq);
 -	init_waitqueue_head(&hba->tm_tag_wq);
 +	init_waitqueue_head(&hba->ufshcd_tm_wait_queue);
  
  	/* Initialize work queues */
 -	INIT_WORK(&hba->eh_work, ufshcd_err_handler);
 -	INIT_WORK(&hba->eeh_work, ufshcd_exception_event_handler);
 +	INIT_WORK(&hba->uic_workq, ufshcd_uic_cc_handler);
 +	INIT_WORK(&hba->feh_workq, ufshcd_fatal_err_handler);
  
 -	/* Initialize UIC command mutex */
 -	mutex_init(&hba->uic_cmd_mutex);
 -
 -	/* Initialize mutex for device management commands */
 -	mutex_init(&hba->dev_cmd.lock);
 -
 -	/* Initialize device management tag acquire wait queue */
 -	init_waitqueue_head(&hba->dev_cmd.tag_wq);
 -
 -	ufshcd_init_clk_gating(hba);
  	/* IRQ registration */
 -	err = devm_request_irq(dev, irq, ufshcd_intr, IRQF_SHARED, UFSHCD, hba);
 +	err = request_irq(irq, ufshcd_intr, IRQF_SHARED, UFSHCD, hba);
  	if (err) {
  		dev_err(hba->dev, "request irq failed\n");
 -		goto exit_gating;
 -	} else {
 -		hba->is_irq_enabled = true;
 +		goto out_lrb_free;
  	}
  
++<<<<<<< HEAD
 +	/* Enable SCSI tag mapping */
 +	err = scsi_init_shared_tag_map(host, host->can_queue);
 +	if (err) {
 +		dev_err(hba->dev, "init shared queue failed\n");
 +		goto out_free_irq;
 +	}
 +
++=======
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  	err = scsi_add_host(host, hba->dev);
  	if (err) {
  		dev_err(hba->dev, "scsi_add_host failed\n");
diff --cc drivers/target/loopback/tcm_loop.c
index 072063c96590,081f1cfefeb3..000000000000
--- a/drivers/target/loopback/tcm_loop.c
+++ b/drivers/target/loopback/tcm_loop.c
@@@ -419,8 -376,8 +419,12 @@@ static struct scsi_host_template tcm_lo
  	.max_sectors		= 0xFFFF,
  	.use_clustering		= DISABLE_CLUSTERING,
  	.slave_alloc		= tcm_loop_slave_alloc,
 +	.slave_configure	= tcm_loop_slave_configure,
  	.module			= THIS_MODULE,
++<<<<<<< HEAD
++=======
+ 	.track_queue_depth	= 1,
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
  
  static int tcm_loop_driver_probe(struct device *dev)
diff --cc drivers/usb/storage/uas.c
index df7dc8365e91,2850663f5126..000000000000
--- a/drivers/usb/storage/uas.c
+++ b/drivers/usb/storage/uas.c
@@@ -845,12 -808,10 +845,15 @@@ static struct scsi_host_template uas_ho
  	.slave_configure = uas_slave_configure,
  	.eh_abort_handler = uas_eh_abort_handler,
  	.eh_bus_reset_handler = uas_eh_bus_reset_handler,
 -	.can_queue = 65536,	/* Is there a limit on the _host_ ? */
 +	.can_queue = MAX_CMNDS,
  	.this_id = -1,
  	.sg_tablesize = SG_NONE,
 +	.cmd_per_lun = 1,	/* until we override it */
  	.skip_settle_delay = 1,
++<<<<<<< HEAD
 +	.ordered_tag = 1,
++=======
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  };
  
  #define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \
diff --cc include/scsi/scsi_host.h
index 007ac0394801,ed527121031d..000000000000
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@@ -446,6 -402,14 +446,17 @@@ struct scsi_host_template 
  	 */
  	unsigned char present;
  
++<<<<<<< HEAD
++=======
+ 	/* If use block layer to manage tags, this is tag allocation policy */
+ 	int tag_alloc_policy;
+ 
+ 	/*
+ 	 * Track QUEUE_FULL events and reduce queue depth on demand.
+ 	 */
+ 	unsigned track_queue_depth:1;
+ 
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  	/*
  	 * This specifies the mode that a LLD supports.
  	 */
diff --cc include/scsi/scsi_tcq.h
index 6c017b8e848a,4416b1026189..000000000000
--- a/include/scsi/scsi_tcq.h
+++ b/include/scsi/scsi_tcq.h
@@@ -15,182 -10,36 +15,205 @@@
  
  
  #ifdef CONFIG_BLOCK
++<<<<<<< HEAD
 +
 +/**
 + * scsi_get_tag_type - get the type of tag the device supports
 + * @sdev:	the scsi device
 + *
 + * Notes:
 + *	If the drive only supports simple tags, returns MSG_SIMPLE_TAG
 + *	if it supports all tag types, returns MSG_ORDERED_TAG.
 + */
 +static inline int scsi_get_tag_type(struct scsi_device *sdev)
 +{
 +	if (!sdev->tagged_supported)
 +		return 0;
 +	if (sdev->ordered_tags)
 +		return MSG_ORDERED_TAG;
 +	if (sdev->simple_tags)
 +		return MSG_SIMPLE_TAG;
 +	return 0;
 +}
 +
 +static inline void scsi_set_tag_type(struct scsi_device *sdev, int tag)
 +{
 +	switch (tag) {
 +	case MSG_ORDERED_TAG:
 +		sdev->ordered_tags = 1;
 +		/* fall through */
 +	case MSG_SIMPLE_TAG:
 +		sdev->simple_tags = 1;
 +		break;
 +	case 0:
 +		/* fall through */
 +	default:
 +		sdev->ordered_tags = 0;
 +		sdev->simple_tags = 0;
 +		break;
 +	}
 +}
 +/**
 + * scsi_activate_tcq - turn on tag command queueing
 + * @SDpnt:	device to turn on TCQ for
 + * @depth:	queue depth
 + *
 + * Notes:
 + *	Eventually, I hope depth would be the maximum depth
 + *	the device could cope with and the real queue depth
 + *	would be adjustable from 0 to depth.
 + **/
 +static inline void scsi_activate_tcq(struct scsi_device *sdev, int depth)
 +{
 +	if (!sdev->tagged_supported)
 +		return;
 +
 +	if (shost_use_blk_mq(sdev->host))
 +		queue_flag_set_unlocked(QUEUE_FLAG_QUEUED, sdev->request_queue);
 +	else if (!blk_queue_tagged(sdev->request_queue))
 +		blk_queue_init_tags(sdev->request_queue, depth,
 +				    sdev->host->bqt);
 +
 +	scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
 +}
 +
 +/**
 + * scsi_deactivate_tcq - turn off tag command queueing
 + * @SDpnt:	device to turn off TCQ for
 + **/
 +static inline void scsi_deactivate_tcq(struct scsi_device *sdev, int depth)
 +{
 +	if (blk_queue_tagged(sdev->request_queue))
 +		blk_queue_free_tags(sdev->request_queue);
 +	scsi_adjust_queue_depth(sdev, 0, depth);
 +}
 +
 +/**
 + * scsi_populate_tag_msg - place a tag message in a buffer
 + * @SCpnt:	pointer to the Scsi_Cmnd for the tag
 + * @msg:	pointer to the area to place the tag
 + *
 + * Notes:
 + *	designed to create the correct type of tag message for the 
 + *	particular request.  Returns the size of the tag message.
 + *	May return 0 if TCQ is disabled for this device.
 + **/
 +static inline int scsi_populate_tag_msg(struct scsi_cmnd *cmd, char *msg)
 +{
 +        struct request *req = cmd->request;
 +
 +        if (blk_rq_tagged(req)) {
 +		*msg++ = MSG_SIMPLE_TAG;
 +        	*msg++ = req->tag;
 +        	return 2;
 +	}
 +
 +	return 0;
 +}
 +
 +static inline struct scsi_cmnd *scsi_mq_find_tag(struct Scsi_Host *shost,
 +		unsigned int hw_ctx, int tag)
 +{
 +	struct request *req;
 +
 +	req = blk_mq_tag_to_rq(shost->tag_set->tags[hw_ctx], tag);
 +	return req ? (struct scsi_cmnd *)req->special : NULL;
 +}
 +
 +/**
 + * scsi_find_tag - find a tagged command by device
 + * @SDpnt:	pointer to the ScSI device
 + * @tag:	the tag number
 + *
 + * Notes:
 + *	Only works with tags allocated by the generic blk layer.
 + **/
 +static inline struct scsi_cmnd *scsi_find_tag(struct scsi_device *sdev, int tag)
 +{
 +        struct request *req;
 +
 +        if (tag != SCSI_NO_TAG) {
 +		if (shost_use_blk_mq(sdev->host))
 +			return scsi_mq_find_tag(sdev->host, 0, tag);
 +
 +        	req = blk_queue_find_tag(sdev->request_queue, tag);
 +	        return req ? (struct scsi_cmnd *)req->special : NULL;
 +	}
 +
 +	/* single command, look in space */
 +	return sdev->current_cmnd;
 +}
 +
 +
 +/**
 + * scsi_init_shared_tag_map - create a shared tag map
 + * @shost:	the host to share the tag map among all devices
 + * @depth:	the total depth of the map
 + */
 +static inline int scsi_init_shared_tag_map(struct Scsi_Host *shost, int depth)
 +{
 +	/*
 +	 * We always have a shared tag map around when using blk-mq.
 +	 */
 +	if (shost_use_blk_mq(shost))
 +		return 0;
 +
 +	/*
 +	 * If the shared tag map isn't already initialized, do it now.
 +	 * This saves callers from having to check ->bqt when setting up
 +	 * devices on the shared host (for libata)
 +	 */
 +	if (!shost->bqt) {
 +		shost->bqt = blk_init_tags(depth);
 +		if (!shost->bqt)
 +			return -ENOMEM;
 +	}
 +
 +	return 0;
 +}
 +
 +/**
 + * scsi_host_find_tag - find the tagged command by host
 + * @shost:	pointer to scsi_host
 + * @tag:	tag of the scsi_cmnd
++=======
+ /**
+  * scsi_host_find_tag - find the tagged command by host
+  * @shost:	pointer to scsi_host
+  * @tag:	tag
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
   *
-  * Notes:
-  *	Only works with tags allocated by the generic blk layer.
+  * Note: for devices using multiple hardware queues tag must have been
+  * generated by blk_mq_unique_tag().
   **/
  static inline struct scsi_cmnd *scsi_host_find_tag(struct Scsi_Host *shost,
- 						int tag)
+ 		int tag)
  {
- 	struct request *req;
+ 	struct request *req = NULL;
  
++<<<<<<< HEAD
 +	if (tag != SCSI_NO_TAG) {
 +		if (shost_use_blk_mq(shost))
 +			return scsi_mq_find_tag(shost, 0, tag);
++=======
+ 	if (tag == SCSI_NO_TAG)
+ 		return NULL;
+ 
+ 	if (shost_use_blk_mq(shost)) {
+ 		u16 hwq = blk_mq_unique_tag_to_hwq(tag);
+ 
+ 		if (hwq < shost->tag_set.nr_hw_queues) {
+ 			req = blk_mq_tag_to_rq(shost->tag_set.tags[hwq],
+ 				blk_mq_unique_tag_to_tag(tag));
+ 		}
+ 	} else {
++>>>>>>> 64d513ac31bd (scsi: use host wide tags by default)
  		req = blk_map_queue_find_tag(shost->bqt, tag);
- 		return req ? (struct scsi_cmnd *)req->special : NULL;
  	}
- 	return NULL;
+ 
+ 	if (!req)
+ 		return NULL;
+ 	return req->special;
  }
  
  #endif /* CONFIG_BLOCK */
* Unmerged path drivers/scsi/esas2r/esas2r_main.c
* Unmerged path drivers/scsi/snic/snic_main.c
* Unmerged path drivers/infiniband/ulp/srp/ib_srp.c
* Unmerged path drivers/scsi/53c700.c
* Unmerged path drivers/scsi/advansys.c
* Unmerged path drivers/scsi/aic94xx/aic94xx_init.c
* Unmerged path drivers/scsi/bnx2fc/bnx2fc_fcoe.c
* Unmerged path drivers/scsi/esas2r/esas2r_main.c
* Unmerged path drivers/scsi/fcoe/fcoe.c
* Unmerged path drivers/scsi/fnic/fnic_main.c
diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 25f843589b34..8964f7114846 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -217,6 +217,13 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 		error = scsi_mq_setup_tags(shost);
 		if (error)
 			goto fail;
+	} else {
+		shost->bqt = blk_init_tags(shost->can_queue,
+				shost->hostt->tag_alloc_policy);
+		if (!shost->bqt) {
+			error = -ENOMEM;
+			goto fail;
+		}
 	}
 
 	/*
* Unmerged path drivers/scsi/hpsa.c
* Unmerged path drivers/scsi/ibmvscsi/ibmvfc.c
* Unmerged path drivers/scsi/isci/init.c
* Unmerged path drivers/scsi/lpfc/lpfc_scsi.c
* Unmerged path drivers/scsi/megaraid/megaraid_sas_base.c
* Unmerged path drivers/scsi/mvsas/mv_init.c
* Unmerged path drivers/scsi/pm8001/pm8001_init.c
* Unmerged path drivers/scsi/pmcraid.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index 25e77ecb8b9a..de7dc1ef0ac5 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -8705,13 +8705,6 @@ static int qla4xxx_probe_adapter(struct pci_dev *pdev,
 	host->can_queue = MAX_SRBS ;
 	host->transportt = qla4xxx_scsi_transport;
 
-	ret = scsi_init_shared_tag_map(host, MAX_SRBS);
-	if (ret) {
-		ql4_printk(KERN_WARNING, ha,
-			   "%s: scsi_init_shared_tag_map failed\n", __func__);
-		goto probe_failed;
-	}
-
 	pci_set_drvdata(pdev, ha);
 
 	ret = scsi_add_host(host, &pdev->dev);
* Unmerged path drivers/scsi/scsi.c
* Unmerged path drivers/scsi/scsi_scan.c
* Unmerged path drivers/scsi/snic/snic_main.c
diff --git a/drivers/scsi/stex.c b/drivers/scsi/stex.c
index 1f4e62b61b83..3847a6276f08 100644
--- a/drivers/scsi/stex.c
+++ b/drivers/scsi/stex.c
@@ -1678,13 +1678,6 @@ static int stex_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (err)
 		goto out_free_irq;
 
-	err = scsi_init_shared_tag_map(host, host->can_queue);
-	if (err) {
-		printk(KERN_ERR DRV_NAME "(%s): init shared queue failed\n",
-			pci_name(pdev));
-		goto out_free_irq;
-	}
-
 	pci_set_drvdata(pdev, hba);
 
 	err = scsi_add_host(host, &pdev->dev);
* Unmerged path drivers/scsi/ufs/ufshcd.c
* Unmerged path drivers/target/loopback/tcm_loop.c
* Unmerged path drivers/usb/storage/uas.c
* Unmerged path include/scsi/scsi_host.h
* Unmerged path include/scsi/scsi_tcq.h
