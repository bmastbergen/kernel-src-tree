device core: add device_is_bound()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drivers] core: add device_is_bound() (Jeremy McNicoll) [1309527]
Rebuild_FUZZ: 88.52%
commit-author Tomeu Vizoso <tomeu.vizoso@collabora.com>
commit 6b9cb42752dafba3761dde0002ca58ca518b6311
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6b9cb427.failed

Adds a function that tells whether a device is already bound to a
driver.

This is needed to warn when there is an attempt to change the PM domain
of a device that has finished probing already. The reason why we want to
enforce that is because in the general case that can cause problems and
also that we can simplify code quite a bit if we can always assume that.

	Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
	Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
	Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 6b9cb42752dafba3761dde0002ca58ca518b6311)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/dd.c
diff --cc drivers/base/dd.c
index 06051767393f,13a0d66e5782..000000000000
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@@ -395,6 -574,93 +409,88 @@@ static int __device_attach(struct devic
  	return driver_probe_device(drv, dev);
  }
  
++<<<<<<< HEAD
++=======
+ static void __device_attach_async_helper(void *_dev, async_cookie_t cookie)
+ {
+ 	struct device *dev = _dev;
+ 	struct device_attach_data data = {
+ 		.dev		= dev,
+ 		.check_async	= true,
+ 		.want_async	= true,
+ 	};
+ 
+ 	device_lock(dev);
+ 
+ 	if (dev->parent)
+ 		pm_runtime_get_sync(dev->parent);
+ 
+ 	bus_for_each_drv(dev->bus, NULL, &data, __device_attach_driver);
+ 	dev_dbg(dev, "async probe completed\n");
+ 
+ 	pm_request_idle(dev);
+ 
+ 	if (dev->parent)
+ 		pm_runtime_put(dev->parent);
+ 
+ 	device_unlock(dev);
+ 
+ 	put_device(dev);
+ }
+ 
+ static int __device_attach(struct device *dev, bool allow_async)
+ {
+ 	int ret = 0;
+ 
+ 	device_lock(dev);
+ 	if (dev->driver) {
+ 		if (device_is_bound(dev)) {
+ 			ret = 1;
+ 			goto out_unlock;
+ 		}
+ 		ret = device_bind_driver(dev);
+ 		if (ret == 0)
+ 			ret = 1;
+ 		else {
+ 			dev->driver = NULL;
+ 			ret = 0;
+ 		}
+ 	} else {
+ 		struct device_attach_data data = {
+ 			.dev = dev,
+ 			.check_async = allow_async,
+ 			.want_async = false,
+ 		};
+ 
+ 		if (dev->parent)
+ 			pm_runtime_get_sync(dev->parent);
+ 
+ 		ret = bus_for_each_drv(dev->bus, NULL, &data,
+ 					__device_attach_driver);
+ 		if (!ret && allow_async && data.have_async) {
+ 			/*
+ 			 * If we could not find appropriate driver
+ 			 * synchronously and we are allowed to do
+ 			 * async probes and there are drivers that
+ 			 * want to probe asynchronously, we'll
+ 			 * try them.
+ 			 */
+ 			dev_dbg(dev, "scheduling asynchronous probe\n");
+ 			get_device(dev);
+ 			async_schedule(__device_attach_async_helper, dev);
+ 		} else {
+ 			pm_request_idle(dev);
+ 		}
+ 
+ 		if (dev->parent)
+ 			pm_runtime_put(dev->parent);
+ 	}
+ out_unlock:
+ 	device_unlock(dev);
+ 	return ret;
+ }
+ 
++>>>>>>> 6b9cb42752da (device core: add device_is_bound())
  /**
   * device_attach - try to attach device to a driver.
   * @dev: device.
* Unmerged path drivers/base/dd.c
diff --git a/include/linux/device.h b/include/linux/device.h
index 16fec9b06e34..b441dce2152c 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -985,6 +985,8 @@ extern int  __must_check device_attach(struct device *dev);
 extern int __must_check driver_attach(struct device_driver *drv);
 extern int __must_check device_reprobe(struct device *dev);
 
+extern bool device_is_bound(struct device *dev);
+
 /*
  * Easy functions for dynamically creating devices on the fly
  */
