sched: Change cfs_rq load avg to unsigned long

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alex Shi <alex.shi@intel.com>
commit 72a4cf20cb71a327c636c7042fdacc25abffc87c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/72a4cf20.failed

Since the 'u64 runnable_load_avg, blocked_load_avg' in cfs_rq struct are
smaller than 'unsigned long' cfs_rq->load.weight. We don't need u64
vaiables to describe them. unsigned long is more efficient and convenience.

	Signed-off-by: Alex Shi <alex.shi@intel.com>
	Reviewed-by: Paul Turner <pjt@google.com>
	Tested-by: Vincent Guittot <vincent.guittot@linaro.org>
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/1371694737-29336-10-git-send-email-alex.shi@intel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 72a4cf20cb71a327c636c7042fdacc25abffc87c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/fair.c
diff --cc kernel/sched/fair.c
index e3632fb98b67,f19772de1b1c..000000000000
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@@ -5289,11 -4179,11 +5289,16 @@@ static int tg_load_down(struct task_gro
  	long cpu = (long)data;
  
  	if (!tg->parent) {
 -		load = cpu_rq(cpu)->avg.load_avg_contrib;
 +		load = cpu_rq(cpu)->load.weight;
  	} else {
  		load = tg->parent->cfs_rq[cpu]->h_load;
++<<<<<<< HEAD
 +		load *= tg->se[cpu]->load.weight;
 +		load /= tg->parent->cfs_rq[cpu]->load.weight + 1;
++=======
+ 		load = div64_ul(load * tg->se[cpu]->avg.load_avg_contrib,
+ 				tg->parent->cfs_rq[cpu]->runnable_load_avg + 1);
++>>>>>>> 72a4cf20cb71 (sched: Change cfs_rq load avg to unsigned long)
  	}
  
  	tg->cfs_rq[cpu]->h_load = load;
diff --git a/kernel/sched/debug.c b/kernel/sched/debug.c
index 850df63779ac..9e0408908d6d 100644
--- a/kernel/sched/debug.c
+++ b/kernel/sched/debug.c
@@ -217,9 +217,9 @@ void print_cfs_rq(struct seq_file *m, int cpu, struct cfs_rq *cfs_rq)
 	SEQ_printf(m, "  .%-30s: %ld\n", "load", cfs_rq->load.weight);
 #ifdef CONFIG_FAIR_GROUP_SCHED
 #ifdef CONFIG_SMP
-	SEQ_printf(m, "  .%-30s: %lld\n", "runnable_load_avg",
+	SEQ_printf(m, "  .%-30s: %ld\n", "runnable_load_avg",
 			cfs_rq->runnable_load_avg);
-	SEQ_printf(m, "  .%-30s: %lld\n", "blocked_load_avg",
+	SEQ_printf(m, "  .%-30s: %ld\n", "blocked_load_avg",
 			cfs_rq->blocked_load_avg);
 	SEQ_printf(m, "  .%-30s: %lld\n", "tg_load_avg",
 			(unsigned long long)atomic64_read(&cfs_rq->tg->load_avg));
* Unmerged path kernel/sched/fair.c
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index b976abe32e72..9a8584319254 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -276,7 +276,7 @@ struct cfs_rq {
 	 * This allows for the description of both thread and group usage (in
 	 * the FAIR_GROUP_SCHED case).
 	 */
-	u64 runnable_load_avg, blocked_load_avg;
+	unsigned long runnable_load_avg, blocked_load_avg;
 	atomic64_t decay_counter, removed_load;
 	u64 last_decay;
 #endif /* CONFIG_FAIR_GROUP_SCHED */
