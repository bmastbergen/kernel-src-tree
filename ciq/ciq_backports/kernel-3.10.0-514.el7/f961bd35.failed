HID: detect Win 8 multitouch devices in core

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hid] detect Win 8 multitouch devices in core (Benjamin Tissoires) [1311883]
Rebuild_FUZZ: 93.98%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit f961bd3516e4f699bbacff5d7f5247d6d87c59f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f961bd35.failed

Detecting Win 8 multitouch devices in core allows us to set quirks
before the device is parsed through hid_hw_start().
It also simplifies the detection of those devices in hid-multitouch and
makes the handling of those devices cleaner.

As Win 8 multitouch panels are in the group multitouch and rely on a
special feature to be detected, this patch adds a bitfield in the parser.

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Reviewed-by: Henrik Rydberg <rydberg@euromail.se>
	Tested-by: Srinivas Pandruvada<srinivas.pandruvada@linux.intel.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit f961bd3516e4f699bbacff5d7f5247d6d87c59f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/hid-core.c
diff --cc drivers/hid/hid-core.c
index 2e63a5156b67,660dce964162..000000000000
--- a/drivers/hid/hid-core.c
+++ b/drivers/hid/hid-core.c
@@@ -685,6 -685,53 +685,56 @@@ static void hid_scan_usage(struct hid_d
  		hid->group = HID_GROUP_MULTITOUCH;
  }
  
++<<<<<<< HEAD
++=======
+ static void hid_scan_feature_usage(struct hid_parser *parser, u32 usage)
+ {
+ 	if (usage == 0xff0000c5 && parser->global.report_count == 256 &&
+ 	    parser->global.report_size == 8)
+ 		parser->scan_flags |= HID_SCAN_FLAG_MT_WIN_8;
+ }
+ 
+ static void hid_scan_collection(struct hid_parser *parser, unsigned type)
+ {
+ 	struct hid_device *hid = parser->device;
+ 
+ 	if (((parser->global.usage_page << 16) == HID_UP_SENSOR) &&
+ 	    type == HID_COLLECTION_PHYSICAL)
+ 		hid->group = HID_GROUP_SENSOR_HUB;
+ }
+ 
+ static int hid_scan_main(struct hid_parser *parser, struct hid_item *item)
+ {
+ 	__u32 data;
+ 	int i;
+ 
+ 	data = item_udata(item);
+ 
+ 	switch (item->tag) {
+ 	case HID_MAIN_ITEM_TAG_BEGIN_COLLECTION:
+ 		hid_scan_collection(parser, data & 0xff);
+ 		break;
+ 	case HID_MAIN_ITEM_TAG_END_COLLECTION:
+ 		break;
+ 	case HID_MAIN_ITEM_TAG_INPUT:
+ 		for (i = 0; i < parser->local.usage_index; i++)
+ 			hid_scan_input_usage(parser, parser->local.usage[i]);
+ 		break;
+ 	case HID_MAIN_ITEM_TAG_OUTPUT:
+ 		break;
+ 	case HID_MAIN_ITEM_TAG_FEATURE:
+ 		for (i = 0; i < parser->local.usage_index; i++)
+ 			hid_scan_feature_usage(parser, parser->local.usage[i]);
+ 		break;
+ 	}
+ 
+ 	/* Reset the local parser environment */
+ 	memset(&parser->local, 0, sizeof(parser->local));
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> f961bd3516e4 (HID: detect Win 8 multitouch devices in core)
  /*
   * Scan a report descriptor before the device is added to the bus.
   * Sets device groups and other properties that determine what driver
@@@ -692,58 -739,41 +742,69 @@@
   */
  static int hid_scan_report(struct hid_device *hid)
  {
 -	struct hid_parser *parser;
 -	struct hid_item item;
 +	unsigned int page = 0, delim = 0;
  	__u8 *start = hid->dev_rdesc;
  	__u8 *end = start + hid->dev_rsize;
 -	static int (*dispatch_type[])(struct hid_parser *parser,
 -				      struct hid_item *item) = {
 -		hid_scan_main,
 -		hid_parser_global,
 -		hid_parser_local,
 -		hid_parser_reserved
 -	};
 -
 -	parser = vzalloc(sizeof(struct hid_parser));
 -	if (!parser)
 -		return -ENOMEM;
 +	unsigned int u, u_min = 0, u_max = 0;
 +	struct hid_item item;
  
 -	parser->device = hid;
  	hid->group = HID_GROUP_GENERIC;
 +	while ((start = fetch_item(start, end, &item)) != NULL) {
 +		if (item.format != HID_ITEM_FORMAT_SHORT)
 +			return -EINVAL;
 +		if (item.type == HID_ITEM_TYPE_GLOBAL) {
 +			if (item.tag == HID_GLOBAL_ITEM_TAG_USAGE_PAGE)
 +				page = item_udata(&item) << 16;
 +		} else if (item.type == HID_ITEM_TYPE_LOCAL) {
 +			if (delim > 1)
 +				break;
 +			u = item_udata(&item);
 +			if (item.size <= 2)
 +				u += page;
 +			switch (item.tag) {
 +			case HID_LOCAL_ITEM_TAG_DELIMITER:
 +				delim += !!u;
 +				break;
 +			case HID_LOCAL_ITEM_TAG_USAGE:
 +				hid_scan_usage(hid, u);
 +				break;
 +			case HID_LOCAL_ITEM_TAG_USAGE_MINIMUM:
 +				u_min = u;
 +				break;
 +			case HID_LOCAL_ITEM_TAG_USAGE_MAXIMUM:
 +				u_max = u;
 +				for (u = u_min; u <= u_max; u++)
 +					hid_scan_usage(hid, u);
 +				break;
 +			}
 +		} else if (page == HID_UP_SENSOR &&
 +			item.type == HID_ITEM_TYPE_MAIN &&
 +			item.tag == HID_MAIN_ITEM_TAG_BEGIN_COLLECTION &&
 +			(item_udata(&item) & 0xff) == HID_COLLECTION_PHYSICAL)
 +			hid->group = HID_GROUP_SENSOR_HUB;
 +	}
  
  	/*
 -	 * The parsing is simpler than the one in hid_open_report() as we should
 -	 * be robust against hid errors. Those errors will be raised by
 -	 * hid_open_report() anyway.
 -	 */
 -	while ((start = fetch_item(start, end, &item)) != NULL)
 -		dispatch_type[item.type](parser, &item);
 -
 +	* Vendor specific handlings
 +	*/
 +	if ((hid->vendor == USB_VENDOR_ID_SYNAPTICS) &&
 +	    (hid->group == HID_GROUP_GENERIC) &&
 +	    /* only bind to the mouse interface of composite USB devices */
 +	    (hid->bus != BUS_USB || hid->type == HID_TYPE_USBMOUSE))
 +		/* hid-rmi should take care of them, not hid-generic */
 +		hid->group = HID_GROUP_RMI;
 +
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Handle special flags set during scanning.
+ 	 */
+ 	if ((parser->scan_flags & HID_SCAN_FLAG_MT_WIN_8) &&
+ 	    (hid->group == HID_GROUP_MULTITOUCH))
+ 		hid->group = HID_GROUP_MULTITOUCH_WIN_8;
+ 
+ 	vfree(parser);
++>>>>>>> f961bd3516e4 (HID: detect Win 8 multitouch devices in core)
  	return 0;
  }
  
* Unmerged path drivers/hid/hid-core.c
diff --git a/drivers/hid/hid-multitouch.c b/drivers/hid/hid-multitouch.c
index 31b9ee991944..213319605fb6 100644
--- a/drivers/hid/hid-multitouch.c
+++ b/drivers/hid/hid-multitouch.c
@@ -133,6 +133,7 @@ static void mt_post_parse(struct mt_device *td);
 #define MT_CLS_NSMU				0x000a
 #define MT_CLS_DUAL_CONTACT_NUMBER		0x0010
 #define MT_CLS_DUAL_CONTACT_ID			0x0011
+#define MT_CLS_WIN_8				0x0012
 
 /* vendor specific classes */
 #define MT_CLS_3M				0x0101
@@ -205,6 +206,11 @@ static struct mt_class mt_classes[] = {
 			MT_QUIRK_CONTACT_CNT_ACCURATE |
 			MT_QUIRK_SLOT_IS_CONTACTID,
 		.maxcontacts = 2 },
+	{ .name = MT_CLS_WIN_8,
+		.quirks = MT_QUIRK_ALWAYS_VALID |
+			MT_QUIRK_IGNORE_DUPLICATES |
+			MT_QUIRK_HOVERING |
+			MT_QUIRK_CONTACT_CNT_ACCURATE },
 
 	/*
 	 * vendor specific classes
@@ -330,19 +336,6 @@ static void mt_feature_mapping(struct hid_device *hdev,
 			td->maxcontacts = td->mtclass.maxcontacts;
 
 		break;
-	case 0xff0000c5:
-		if (field->report_count == 256 && field->report_size == 8) {
-			/* Win 8 devices need special quirks */
-			__s32 *quirks = &td->mtclass.quirks;
-			*quirks |= MT_QUIRK_ALWAYS_VALID;
-			*quirks |= MT_QUIRK_IGNORE_DUPLICATES;
-			*quirks |= MT_QUIRK_HOVERING;
-			*quirks |= MT_QUIRK_CONTACT_CNT_ACCURATE;
-			*quirks &= ~MT_QUIRK_NOT_SEEN_MEANS_UP;
-			*quirks &= ~MT_QUIRK_VALID_IS_INRANGE;
-			*quirks &= ~MT_QUIRK_VALID_IS_CONFIDENCE;
-		}
-		break;
 	}
 }
 
@@ -1377,6 +1370,11 @@ static const struct hid_device_id mt_devices[] = {
 
 	/* Generic MT device */
 	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_MULTITOUCH, HID_ANY_ID, HID_ANY_ID) },
+
+	/* Generic Win 8 certified MT device */
+	{  .driver_data = MT_CLS_WIN_8,
+		HID_DEVICE(HID_BUS_ANY, HID_GROUP_MULTITOUCH_WIN_8,
+			HID_ANY_ID, HID_ANY_ID) },
 	{ }
 };
 MODULE_DEVICE_TABLE(hid, mt_devices);
diff --git a/include/linux/hid.h b/include/linux/hid.h
index 2705057dad99..29ab04985877 100644
--- a/include/linux/hid.h
+++ b/include/linux/hid.h
@@ -299,6 +299,7 @@ struct hid_item {
 #define HID_GROUP_GENERIC			0x0001
 #define HID_GROUP_MULTITOUCH			0x0002
 #define HID_GROUP_SENSOR_HUB			0x0003
+#define HID_GROUP_MULTITOUCH_WIN_8		0x0004
 
 /*
  * Vendor specific HID device groups
@@ -543,6 +544,8 @@ static inline void hid_set_drvdata(struct hid_device *hdev, void *data)
 #define HID_GLOBAL_STACK_SIZE 4
 #define HID_COLLECTION_STACK_SIZE 4
 
+#define HID_SCAN_FLAG_MT_WIN_8			0x00000001
+
 struct hid_parser {
 	struct hid_global     global;
 	struct hid_global     global_stack[HID_GLOBAL_STACK_SIZE];
@@ -551,6 +554,7 @@ struct hid_parser {
 	unsigned              collection_stack[HID_COLLECTION_STACK_SIZE];
 	unsigned              collection_stack_ptr;
 	struct hid_device    *device;
+	unsigned              scan_flags;
 };
 
 struct hid_class_descriptor {
