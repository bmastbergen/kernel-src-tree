openvswitch: Use dev_queue_xmit for vport send.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] openvswitch: Use dev_queue_xmit for vport send (Lance Richardson) [1283886]
Rebuild_FUZZ: 98.92%
commit-author Pravin B Shelar <pshelar@nicira.com>
commit aec15924740edc9886051593bc7769873be9498b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/aec15924.failed

With use of lwtunnel, we can directly call dev_queue_xmit()
rather than calling netdev vport send operation.
Following change make tunnel vport code bit cleaner.

	Signed-off-by: Pravin B Shelar <pshelar@nicira.com>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Acked-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit aec15924740edc9886051593bc7769873be9498b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/vport-geneve.c
#	net/openvswitch/vport-gre.c
#	net/openvswitch/vport-internal_dev.c
#	net/openvswitch/vport-netdev.c
#	net/openvswitch/vport-netdev.h
#	net/openvswitch/vport-vxlan.c
#	net/openvswitch/vport.h
diff --cc net/openvswitch/vport-geneve.c
index 1da3a14d1010,7a568ca8da54..000000000000
--- a/net/openvswitch/vport-geneve.c
+++ b/net/openvswitch/vport-geneve.c
@@@ -241,11 -125,10 +241,15 @@@ static int geneve_get_egress_tun_info(s
  
  static struct vport_ops ovs_geneve_vport_ops = {
  	.type		= OVS_VPORT_TYPE_GENEVE,
 -	.create		= geneve_create,
 -	.destroy	= ovs_netdev_tunnel_destroy,
 +	.create		= geneve_tnl_create,
 +	.destroy	= geneve_tnl_destroy,
 +	.get_name	= geneve_get_name,
  	.get_options	= geneve_get_options,
++<<<<<<< HEAD
 +	.send		= geneve_tnl_send,
++=======
+ 	.send		= dev_queue_xmit,
++>>>>>>> aec15924740e (openvswitch: Use dev_queue_xmit for vport send.)
  	.owner          = THIS_MODULE,
  	.get_egress_tun_info	= geneve_get_egress_tun_info,
  };
diff --cc net/openvswitch/vport-gre.c
index b87656c66aaf,cdb758ab01cf..000000000000
--- a/net/openvswitch/vport-gre.c
+++ b/net/openvswitch/vport-gre.c
@@@ -288,10 -94,9 +288,14 @@@ static int gre_get_egress_tun_info(stru
  static struct vport_ops ovs_gre_vport_ops = {
  	.type		= OVS_VPORT_TYPE_GRE,
  	.create		= gre_create,
++<<<<<<< HEAD
 +	.destroy	= gre_tnl_destroy,
 +	.get_name	= gre_get_name,
 +	.send		= gre_tnl_send,
++=======
+ 	.send		= dev_queue_xmit,
++>>>>>>> aec15924740e (openvswitch: Use dev_queue_xmit for vport send.)
  	.get_egress_tun_info	= gre_get_egress_tun_info,
 -	.destroy	= ovs_netdev_tunnel_destroy,
  	.owner		= THIS_MODULE,
  };
  
diff --cc net/openvswitch/vport-internal_dev.c
index d6aef25cd7bb,7f0a8bd08857..000000000000
--- a/net/openvswitch/vport-internal_dev.c
+++ b/net/openvswitch/vport-internal_dev.c
@@@ -218,18 -202,17 +218,30 @@@ static void internal_dev_destroy(struc
  	rtnl_unlock();
  }
  
++<<<<<<< HEAD
 +static int internal_dev_recv(struct vport *vport, struct sk_buff *skb)
 +{
 +	struct net_device *netdev = netdev_vport_priv(vport)->dev;
 +	int len;
 +
 +	if (unlikely(!(netdev->flags & IFF_UP))) {
 +		kfree_skb(skb);
 +		return 0;
++=======
+ static netdev_tx_t internal_dev_recv(struct sk_buff *skb)
+ {
+ 	struct net_device *netdev = skb->dev;
+ 	struct pcpu_sw_netstats *stats;
+ 
+ 	if (unlikely(!(netdev->flags & IFF_UP))) {
+ 		kfree_skb(skb);
+ 		netdev->stats.rx_dropped++;
+ 		return NETDEV_TX_OK;
++>>>>>>> aec15924740e (openvswitch: Use dev_queue_xmit for vport send.)
  	}
  
 +	len = skb->len;
 +
  	skb_dst_drop(skb);
  	nf_reset(skb);
  	secpath_reset(skb);
@@@ -239,9 -221,14 +250,13 @@@
  	skb->protocol = eth_type_trans(skb, netdev);
  	skb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);
  
 -	stats = this_cpu_ptr(netdev->tstats);
 -	u64_stats_update_begin(&stats->syncp);
 -	stats->rx_packets++;
 -	stats->rx_bytes += skb->len;
 -	u64_stats_update_end(&stats->syncp);
 -
  	netif_rx(skb);
++<<<<<<< HEAD
 +
 +	return len;
++=======
+ 	return NETDEV_TX_OK;
++>>>>>>> aec15924740e (openvswitch: Use dev_queue_xmit for vport send.)
  }
  
  static struct vport_ops ovs_internal_vport_ops = {
diff --cc net/openvswitch/vport-netdev.c
index 6c7a9d49beb5,b327368a3848..000000000000
--- a/net/openvswitch/vport-netdev.c
+++ b/net/openvswitch/vport-netdev.c
@@@ -174,49 -171,25 +174,52 @@@ static void netdev_destroy(struct vpor
  		ovs_netdev_detach_dev(vport);
  	rtnl_unlock();
  
 -	call_rcu(&vport->rcu, vport_netdev_free);
 +	call_rcu(&netdev_vport->rcu, free_port_rcu);
  }
  
 -void ovs_netdev_tunnel_destroy(struct vport *vport)
 +const char *ovs_netdev_get_name(const struct vport *vport)
  {
 -	rtnl_lock();
 -	if (vport->dev->priv_flags & IFF_OVS_DATAPATH)
 -		ovs_netdev_detach_dev(vport);
 +	const struct netdev_vport *netdev_vport = netdev_vport_priv(vport);
 +	return netdev_vport->dev->name;
 +}
  
 -	/* Early release so we can unregister the device */
 -	dev_put(vport->dev);
 -	rtnl_delete_link(vport->dev);
 -	vport->dev = NULL;
 -	rtnl_unlock();
++<<<<<<< HEAD
 +static unsigned int packet_length(const struct sk_buff *skb)
 +{
 +	unsigned int length = skb->len - ETH_HLEN;
 +
 +	if (skb->protocol == htons(ETH_P_8021Q))
 +		length -= VLAN_HLEN;
 +
 +	return length;
 +}
 +
 +static int netdev_send(struct vport *vport, struct sk_buff *skb)
 +{
 +	struct netdev_vport *netdev_vport = netdev_vport_priv(vport);
 +	int mtu = netdev_vport->dev->mtu;
 +	int len;
 +
 +	if (unlikely(packet_length(skb) > mtu && !skb_is_gso(skb))) {
 +		net_warn_ratelimited("%s: dropped over-mtu packet: %d > %d\n",
 +				     netdev_vport->dev->name,
 +				     packet_length(skb), mtu);
 +		goto drop;
 +	}
 +
 +	skb->dev = netdev_vport->dev;
 +	len = skb->len;
 +	dev_queue_xmit(skb);
  
 -	call_rcu(&vport->rcu, vport_netdev_free);
 +	return len;
 +
 +drop:
 +	kfree_skb(skb);
 +	return 0;
  }
 -EXPORT_SYMBOL_GPL(ovs_netdev_tunnel_destroy);
  
++=======
++>>>>>>> aec15924740e (openvswitch: Use dev_queue_xmit for vport send.)
  /* Returns null if this device is not attached to a datapath. */
  struct vport *ovs_netdev_get_vport(struct net_device *dev)
  {
@@@ -231,8 -204,7 +234,12 @@@ static struct vport_ops ovs_netdev_vpor
  	.type		= OVS_VPORT_TYPE_NETDEV,
  	.create		= netdev_create,
  	.destroy	= netdev_destroy,
++<<<<<<< HEAD
 +	.get_name	= ovs_netdev_get_name,
 +	.send		= netdev_send,
++=======
+ 	.send		= dev_queue_xmit,
++>>>>>>> aec15924740e (openvswitch: Use dev_queue_xmit for vport send.)
  };
  
  int __init ovs_netdev_init(void)
diff --cc net/openvswitch/vport-netdev.h
index 6f7038e79c52,19e29c12adcc..000000000000
--- a/net/openvswitch/vport-netdev.h
+++ b/net/openvswitch/vport-netdev.h
@@@ -26,19 -26,7 +26,23 @@@
  
  struct vport *ovs_netdev_get_vport(struct net_device *dev);
  
++<<<<<<< HEAD
 +struct netdev_vport {
 +	struct rcu_head rcu;
 +
 +	struct net_device *dev;
 +};
 +
 +static inline struct netdev_vport *
 +netdev_vport_priv(const struct vport *vport)
 +{
 +	return vport_priv(vport);
 +}
 +
 +const char *ovs_netdev_get_name(const struct vport *);
++=======
+ struct vport *ovs_netdev_link(struct vport *vport, const char *name);
++>>>>>>> aec15924740e (openvswitch: Use dev_queue_xmit for vport send.)
  void ovs_netdev_detach_dev(struct vport *);
  
  int __init ovs_netdev_init(void);
diff --cc net/openvswitch/vport-vxlan.c
index 6f7986fabb70,6f700710d413..000000000000
--- a/net/openvswitch/vport-vxlan.c
+++ b/net/openvswitch/vport-vxlan.c
@@@ -287,21 -165,13 +287,30 @@@ static int vxlan_get_egress_tun_info(st
  					  src_port, dst_port);
  }
  
++<<<<<<< HEAD
 +static const char *vxlan_get_name(const struct vport *vport)
 +{
 +	struct vxlan_port *vxlan_port = vxlan_vport(vport);
 +	return vxlan_port->name;
 +}
 +
 +static struct vport_ops ovs_vxlan_vport_ops = {
 +	.type		= OVS_VPORT_TYPE_VXLAN,
 +	.create		= vxlan_tnl_create,
 +	.destroy	= vxlan_tnl_destroy,
 +	.get_name	= vxlan_get_name,
 +	.get_options	= vxlan_get_options,
 +	.send		= vxlan_tnl_send,
++=======
+ static struct vport_ops ovs_vxlan_netdev_vport_ops = {
+ 	.type			= OVS_VPORT_TYPE_VXLAN,
+ 	.create			= vxlan_create,
+ 	.destroy		= ovs_netdev_tunnel_destroy,
+ 	.get_options		= vxlan_get_options,
+ 	.send			= dev_queue_xmit,
++>>>>>>> aec15924740e (openvswitch: Use dev_queue_xmit for vport send.)
  	.get_egress_tun_info	= vxlan_get_egress_tun_info,
 +	.owner		= THIS_MODULE,
  };
  
  static int __init ovs_vxlan_tnl_init(void)
diff --cc net/openvswitch/vport.h
index 4750fb673a9f,885607f28d56..000000000000
--- a/net/openvswitch/vport.h
+++ b/net/openvswitch/vport.h
@@@ -171,12 -153,9 +171,16 @@@ struct vport_ops 
  	int (*set_options)(struct vport *, struct nlattr *);
  	int (*get_options)(const struct vport *, struct sk_buff *);
  
++<<<<<<< HEAD
 +	/* Called with rcu_read_lock or ovs_mutex. */
 +	const char *(*get_name)(const struct vport *);
 +
 +	int (*send)(struct vport *, struct sk_buff *);
++=======
+ 	netdev_tx_t (*send) (struct sk_buff *skb);
++>>>>>>> aec15924740e (openvswitch: Use dev_queue_xmit for vport send.)
  	int (*get_egress_tun_info)(struct vport *, struct sk_buff *,
 -				   struct dp_upcall_info *upcall);
 +				   struct ip_tunnel_info *);
  
  	struct module *owner;
  	struct list_head list;
@@@ -256,4 -233,7 +260,10 @@@ static inline struct rtable *ovs_tunnel
  	rt = ip_route_output_key(net, fl);
  	return rt;
  }
++<<<<<<< HEAD
++=======
+ 
+ void ovs_vport_send(struct vport *vport, struct sk_buff *skb);
+ 
++>>>>>>> aec15924740e (openvswitch: Use dev_queue_xmit for vport send.)
  #endif /* vport.h */
* Unmerged path net/openvswitch/vport-geneve.c
* Unmerged path net/openvswitch/vport-gre.c
* Unmerged path net/openvswitch/vport-internal_dev.c
* Unmerged path net/openvswitch/vport-netdev.c
* Unmerged path net/openvswitch/vport-netdev.h
* Unmerged path net/openvswitch/vport-vxlan.c
diff --git a/net/openvswitch/vport.c b/net/openvswitch/vport.c
index af23ba077836..8645ba8e25a7 100644
--- a/net/openvswitch/vport.c
+++ b/net/openvswitch/vport.c
@@ -625,3 +625,33 @@ int ovs_vport_get_egress_tun_info(struct vport *vport, struct sk_buff *skb,
 
 	return vport->ops->get_egress_tun_info(vport, skb, info);
 }
+
+static unsigned int packet_length(const struct sk_buff *skb)
+{
+	unsigned int length = skb->len - ETH_HLEN;
+
+	if (skb->protocol == htons(ETH_P_8021Q))
+		length -= VLAN_HLEN;
+
+	return length;
+}
+
+void ovs_vport_send(struct vport *vport, struct sk_buff *skb)
+{
+	int mtu = vport->dev->mtu;
+
+	if (unlikely(packet_length(skb) > mtu && !skb_is_gso(skb))) {
+		net_warn_ratelimited("%s: dropped over-mtu packet: %d > %d\n",
+				     vport->dev->name,
+				     packet_length(skb), mtu);
+		vport->dev->stats.tx_errors++;
+		goto drop;
+	}
+
+	skb->dev = vport->dev;
+	vport->ops->send(skb);
+	return;
+
+drop:
+	kfree_skb(skb);
+}
* Unmerged path net/openvswitch/vport.h
