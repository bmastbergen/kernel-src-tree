quota: add new quotactl Q_XGETNEXTQUOTA

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Eric Sandeen <sandeen@redhat.com>
commit 8b37524962b9c54423374717786198f5c0820a28
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8b375249.failed

Q_XGETNEXTQUOTA is exactly like Q_XGETQUOTA, except that it
will return quota information for the id equal to or greater
than the id requested.  In other words, if the requested id has
no quota, the command will return quota information for the
next higher id which does have a quota set.  If no higher id
has an active quota, -ESRCH is returned.

This allows filesystems to do efficient iteration in kernelspace,
much like extN filesystems do in userspace when asked to report
all active quotas.

The patch adds a d_id field to struct qc_dqblk so that we can
pass back the id of the quota which was found, and return it
to userspace.

Today, filesystems such as XFS require getpwent-style iterations,
and for systems which have i.e. LDAP backends, this can be very
slow, or even impossible if iteration is not allowed in the
configuration.

	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 8b37524962b9c54423374717786198f5c0820a28)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/quota.h
diff --cc include/linux/quota.h
index 99932a50af2b,fba92f5c1a63..000000000000
--- a/include/linux/quota.h
+++ b/include/linux/quota.h
@@@ -321,17 -328,108 +321,27 @@@ struct path
  /* Operations handling requests from userspace */
  struct quotactl_ops {
  	int (*quota_on)(struct super_block *, int, int, struct path *);
 +	int (*quota_on_meta)(struct super_block *, int, int);
  	int (*quota_off)(struct super_block *, int);
 -	int (*quota_enable)(struct super_block *, unsigned int);
 -	int (*quota_disable)(struct super_block *, unsigned int);
  	int (*quota_sync)(struct super_block *, int);
++<<<<<<< HEAD
 +	int (*get_info)(struct super_block *, int, struct if_dqinfo *);
 +	int (*set_info)(struct super_block *, int, struct if_dqinfo *);
 +	int (*get_dqblk)(struct super_block *, struct kqid, struct fs_disk_quota *);
 +	int (*set_dqblk)(struct super_block *, struct kqid, struct fs_disk_quota *);
 +	int (*get_xstate)(struct super_block *, struct fs_quota_stat *);
 +	int (*set_xstate)(struct super_block *, unsigned int, int);
 +	int (*get_xstatev)(struct super_block *, struct fs_quota_statv *);
 +	RH_KABI_EXTEND(int (*rm_xquota)(struct super_block *, unsigned int))
++=======
+ 	int (*set_info)(struct super_block *, int, struct qc_info *);
+ 	int (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
+ 	int (*get_nextdqblk)(struct super_block *, struct kqid *,
+ 			     struct qc_dqblk *);
+ 	int (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
+ 	int (*get_state)(struct super_block *, struct qc_state *);
+ 	int (*rm_xquota)(struct super_block *, unsigned int);
++>>>>>>> 8b37524962b9 (quota: add new quotactl Q_XGETNEXTQUOTA)
  };
  
  struct quota_format_type {
diff --git a/fs/quota/quota.c b/fs/quota/quota.c
index 8f489c65f2a6..af5431fcb2d3 100644
--- a/fs/quota/quota.c
+++ b/fs/quota/quota.c
@@ -277,6 +277,34 @@ static int quota_getxquota(struct super_block *sb, int type, qid_t id,
 	return ret;
 }
 
+/*
+ * Return quota for next active quota >= this id, if any exists,
+ * otherwise return -ESRCH via ->get_nextdqblk.
+ */
+static int quota_getnextxquota(struct super_block *sb, int type, qid_t id,
+			    void __user *addr)
+{
+	struct fs_disk_quota fdq;
+	struct qc_dqblk qdq;
+	struct kqid qid;
+	qid_t id_out;
+	int ret;
+
+	if (!sb->s_qcop->get_nextdqblk)
+		return -ENOSYS;
+	qid = make_kqid(current_user_ns(), type, id);
+	if (!qid_valid(qid))
+		return -EINVAL;
+	ret = sb->s_qcop->get_nextdqblk(sb, &qid, &qdq);
+	if (ret)
+		return ret;
+	id_out = from_kqid(current_user_ns(), qid);
+	copy_to_xfs_dqblk(&fdq, &qdq, type, id_out);
+	if (copy_to_user(addr, &fdq, sizeof(fdq)))
+		return -EFAULT;
+	return ret;
+}
+
 static int quota_rmxquota(struct super_block *sb, void __user *addr)
 {
 	__u32 flags;
@@ -337,6 +365,8 @@ static int do_quotactl(struct super_block *sb, int type, int cmd, qid_t id,
 		return quota_setxquota(sb, type, id, addr);
 	case Q_XGETQUOTA:
 		return quota_getxquota(sb, type, id, addr);
+	case Q_XGETNEXTQUOTA:
+		return quota_getnextxquota(sb, type, id, addr);
 	case Q_XQUOTASYNC:
 		if (sb->s_flags & MS_RDONLY)
 			return -EROFS;
@@ -359,6 +389,7 @@ static int quotactl_cmd_write(int cmd)
 	case Q_XGETQSTAT:
 	case Q_XGETQSTATV:
 	case Q_XGETQUOTA:
+	case Q_XGETNEXTQUOTA:
 	case Q_XQUOTASYNC:
 		return 0;
 	}
* Unmerged path include/linux/quota.h
diff --git a/include/uapi/linux/dqblk_xfs.h b/include/uapi/linux/dqblk_xfs.h
index dcd75cc26196..11b3b31faf14 100644
--- a/include/uapi/linux/dqblk_xfs.h
+++ b/include/uapi/linux/dqblk_xfs.h
@@ -39,6 +39,7 @@
 #define Q_XQUOTARM	XQM_CMD(6)	/* free disk space used by dquots */
 #define Q_XQUOTASYNC	XQM_CMD(7)	/* delalloc flush, updates dquots */
 #define Q_XGETQSTATV	XQM_CMD(8)	/* newer version of get quota */
+#define Q_XGETNEXTQUOTA	XQM_CMD(9)	/* get disk limits and usage >= ID */
 
 /*
  * fs_disk_quota structure:
