ACPI / scan: Simplify acpi_match_device()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit e1acdeb0e7707f4220aa14ad6739102ba26e07c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e1acdeb0.failed

Redefine acpi_companion_match() to return an ACPI device object
pointer instead of a bool and use it to remove some redundant code
from acpi_match_device().

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit e1acdeb0e7707f4220aa14ad6739102ba26e07c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
diff --cc drivers/acpi/scan.c
index b64d638cf134,b4d5549265ed..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -143,6 -188,99 +143,102 @@@ static int create_modalias(struct acpi_
  	return len;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * acpi_companion_match() - Can we match via ACPI companion device
+  * @dev: Device in question
+  *
+  * Check if the given device has an ACPI companion and if that companion has
+  * a valid list of PNP IDs, and if the device is the first (primary) physical
+  * device associated with it.  Return the companion pointer if that's the case
+  * or NULL otherwise.
+  *
+  * If multiple physical devices are attached to a single ACPI companion, we need
+  * to be careful.  The usage scenario for this kind of relationship is that all
+  * of the physical devices in question use resources provided by the ACPI
+  * companion.  A typical case is an MFD device where all the sub-devices share
+  * the parent's ACPI companion.  In such cases we can only allow the primary
+  * (first) physical device to be matched with the help of the companion's PNP
+  * IDs.
+  *
+  * Additional physical devices sharing the ACPI companion can still use
+  * resources available from it but they will be matched normally using functions
+  * provided by their bus types (and analogously for their modalias).
+  */
+ static struct acpi_device *acpi_companion_match(const struct device *dev)
+ {
+ 	struct acpi_device *adev;
+ 
+ 	adev = ACPI_COMPANION(dev);
+ 	if (!adev)
+ 		return NULL;
+ 
+ 	if (list_empty(&adev->pnp.ids))
+ 		return NULL;
+ 
+ 	mutex_lock(&adev->physical_node_lock);
+ 	if (list_empty(&adev->physical_node_list)) {
+ 		adev = NULL;
+ 	} else {
+ 		const struct acpi_device_physical_node *node;
+ 
+ 		node = list_first_entry(&adev->physical_node_list,
+ 					struct acpi_device_physical_node, node);
+ 		if (node->dev != dev)
+ 			adev = NULL;
+ 	}
+ 	mutex_unlock(&adev->physical_node_lock);
+ 
+ 	return adev;
+ }
+ 
+ /*
+  * Creates uevent modalias field for ACPI enumerated devices.
+  * Because the other buses does not support ACPI HIDs & CIDs.
+  * e.g. for a device with hid:IBM0001 and cid:ACPI0001 you get:
+  * "acpi:IBM0001:ACPI0001"
+  */
+ int acpi_device_uevent_modalias(struct device *dev, struct kobj_uevent_env *env)
+ {
+ 	int len;
+ 
+ 	if (!acpi_companion_match(dev))
+ 		return -ENODEV;
+ 
+ 	if (add_uevent_var(env, "MODALIAS="))
+ 		return -ENOMEM;
+ 	len = create_modalias(ACPI_COMPANION(dev), &env->buf[env->buflen - 1],
+ 				sizeof(env->buf) - env->buflen);
+ 	if (len <= 0)
+ 		return len;
+ 	env->buflen += len;
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(acpi_device_uevent_modalias);
+ 
+ /*
+  * Creates modalias sysfs attribute for ACPI enumerated devices.
+  * Because the other buses does not support ACPI HIDs & CIDs.
+  * e.g. for a device with hid:IBM0001 and cid:ACPI0001 you get:
+  * "acpi:IBM0001:ACPI0001"
+  */
+ int acpi_device_modalias(struct device *dev, char *buf, int size)
+ {
+ 	int len;
+ 
+ 	if (!acpi_companion_match(dev))
+ 		return -ENODEV;
+ 
+ 	len = create_modalias(ACPI_COMPANION(dev), buf, size -1);
+ 	if (len <= 0)
+ 		return len;
+ 	buf[len++] = '\n';
+ 	return len;
+ }
+ EXPORT_SYMBOL_GPL(acpi_device_modalias);
+ 
++>>>>>>> e1acdeb0e770 (ACPI / scan: Simplify acpi_match_device())
  static ssize_t
  acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, char *buf) {
  	struct acpi_device *acpi_dev = to_acpi_device(dev);
@@@ -792,13 -930,7 +888,17 @@@ static const struct acpi_device_id *__a
  const struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,
  					       const struct device *dev)
  {
++<<<<<<< HEAD
 +	struct acpi_device *adev;
 +	acpi_handle handle = ACPI_HANDLE(dev);
 +
 +	if (!ids || !handle || acpi_bus_get_device(handle, &adev))
 +		return NULL;
 +
 +	return __acpi_match_device(adev, ids);
++=======
+ 	return __acpi_match_device(acpi_companion_match(dev), ids);
++>>>>>>> e1acdeb0e770 (ACPI / scan: Simplify acpi_match_device())
  }
  EXPORT_SYMBOL_GPL(acpi_match_device);
  
* Unmerged path drivers/acpi/scan.c
