sched: Add 'flags' argument to sched_{set,get}attr() syscalls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [kernel] sched: Add 'flags' argument to sched_{set, get}attr() syscalls (Lauro Ramos Venancio) [1352969]
Rebuild_FUZZ: 99.19%
commit-author Peter Zijlstra <peterz@infradead.org>
commit 6d35ab48090b10c5ea5604ed5d6e91f302dc6060
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6d35ab48.failed

Because of a recent syscall design debate; its deemed appropriate for
each syscall to have a flags argument for future extension; without
immediately requiring new syscalls.

	Cc: juri.lelli@gmail.com
	Cc: Ingo Molnar <mingo@redhat.com>
	Suggested-by: Michael Kerrisk <mtk.manpages@gmail.com>
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20140214161929.GL27965@twins.programming.kicks-ass.net
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 6d35ab48090b10c5ea5604ed5d6e91f302dc6060)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/syscalls.h
#	kernel/sched/core.c
diff --cc include/linux/syscalls.h
index 8828ea4ca245,a747a77ea584..000000000000
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@@ -278,9 -280,16 +278,22 @@@ asmlinkage long sys_sched_setscheduler(
  					struct sched_param __user *param);
  asmlinkage long sys_sched_setparam(pid_t pid,
  					struct sched_param __user *param);
++<<<<<<< HEAD
 +asmlinkage long sys_sched_getscheduler(pid_t pid);
 +asmlinkage long sys_sched_getparam(pid_t pid,
 +					struct sched_param __user *param);
++=======
+ asmlinkage long sys_sched_setattr(pid_t pid,
+ 					struct sched_attr __user *attr,
+ 					unsigned int flags);
+ asmlinkage long sys_sched_getscheduler(pid_t pid);
+ asmlinkage long sys_sched_getparam(pid_t pid,
+ 					struct sched_param __user *param);
+ asmlinkage long sys_sched_getattr(pid_t pid,
+ 					struct sched_attr __user *attr,
+ 					unsigned int size,
+ 					unsigned int flags);
++>>>>>>> 6d35ab48090b (sched: Add 'flags' argument to sched_{set,get}attr() syscalls)
  asmlinkage long sys_sched_setaffinity(pid_t pid, unsigned int len,
  					unsigned long __user *user_mask_ptr);
  asmlinkage long sys_sched_getaffinity(pid_t pid, unsigned int len,
diff --cc kernel/sched/core.c
index 8f3f375de9d1,6edbef296ece..000000000000
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@@ -4366,6 -3657,34 +4366,37 @@@ SYSCALL_DEFINE2(sched_setparam, pid_t, 
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * sys_sched_setattr - same as above, but with extended sched_attr
+  * @pid: the pid in question.
+  * @uattr: structure containing the extended parameters.
+  */
+ SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr,
+ 			       unsigned int, flags)
+ {
+ 	struct sched_attr attr;
+ 	struct task_struct *p;
+ 	int retval;
+ 
+ 	if (!uattr || pid < 0 || flags)
+ 		return -EINVAL;
+ 
+ 	if (sched_copy_attr(uattr, &attr))
+ 		return -EFAULT;
+ 
+ 	rcu_read_lock();
+ 	retval = -ESRCH;
+ 	p = find_process_by_pid(pid);
+ 	if (p != NULL)
+ 		retval = sched_setattr(p, &attr);
+ 	rcu_read_unlock();
+ 
+ 	return retval;
+ }
+ 
+ /**
++>>>>>>> 6d35ab48090b (sched: Add 'flags' argument to sched_{set,get}attr() syscalls)
   * sys_sched_getscheduler - get the policy (scheduling class) of a thread
   * @pid: the pid in question.
   *
@@@ -4435,6 -3758,96 +4466,99 @@@ out_unlock
  	return retval;
  }
  
++<<<<<<< HEAD
++=======
+ static int sched_read_attr(struct sched_attr __user *uattr,
+ 			   struct sched_attr *attr,
+ 			   unsigned int usize)
+ {
+ 	int ret;
+ 
+ 	if (!access_ok(VERIFY_WRITE, uattr, usize))
+ 		return -EFAULT;
+ 
+ 	/*
+ 	 * If we're handed a smaller struct than we know of,
+ 	 * ensure all the unknown bits are 0 - i.e. old
+ 	 * user-space does not get uncomplete information.
+ 	 */
+ 	if (usize < sizeof(*attr)) {
+ 		unsigned char *addr;
+ 		unsigned char *end;
+ 
+ 		addr = (void *)attr + usize;
+ 		end  = (void *)attr + sizeof(*attr);
+ 
+ 		for (; addr < end; addr++) {
+ 			if (*addr)
+ 				goto err_size;
+ 		}
+ 
+ 		attr->size = usize;
+ 	}
+ 
+ 	ret = copy_to_user(uattr, attr, attr->size);
+ 	if (ret)
+ 		return -EFAULT;
+ 
+ out:
+ 	return ret;
+ 
+ err_size:
+ 	ret = -E2BIG;
+ 	goto out;
+ }
+ 
+ /**
+  * sys_sched_getattr - similar to sched_getparam, but with sched_attr
+  * @pid: the pid in question.
+  * @uattr: structure containing the extended parameters.
+  * @size: sizeof(attr) for fwd/bwd comp.
+  */
+ SYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr,
+ 		unsigned int, size, unsigned int, flags)
+ {
+ 	struct sched_attr attr = {
+ 		.size = sizeof(struct sched_attr),
+ 	};
+ 	struct task_struct *p;
+ 	int retval;
+ 
+ 	if (!uattr || pid < 0 || size > PAGE_SIZE ||
+ 	    size < SCHED_ATTR_SIZE_VER0 || flags)
+ 		return -EINVAL;
+ 
+ 	rcu_read_lock();
+ 	p = find_process_by_pid(pid);
+ 	retval = -ESRCH;
+ 	if (!p)
+ 		goto out_unlock;
+ 
+ 	retval = security_task_getscheduler(p);
+ 	if (retval)
+ 		goto out_unlock;
+ 
+ 	attr.sched_policy = p->policy;
+ 	if (p->sched_reset_on_fork)
+ 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;
+ 	if (task_has_dl_policy(p))
+ 		__getparam_dl(p, &attr);
+ 	else if (task_has_rt_policy(p))
+ 		attr.sched_priority = p->rt_priority;
+ 	else
+ 		attr.sched_nice = TASK_NICE(p);
+ 
+ 	rcu_read_unlock();
+ 
+ 	retval = sched_read_attr(uattr, &attr, size);
+ 	return retval;
+ 
+ out_unlock:
+ 	rcu_read_unlock();
+ 	return retval;
+ }
+ 
++>>>>>>> 6d35ab48090b (sched: Add 'flags' argument to sched_{set,get}attr() syscalls)
  long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)
  {
  	cpumask_var_t cpus_allowed, new_mask;
* Unmerged path include/linux/syscalls.h
* Unmerged path kernel/sched/core.c
