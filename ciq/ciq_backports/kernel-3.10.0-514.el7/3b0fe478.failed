xfs: Don't use reserved blocks for data blocks with DAX

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 3b0fe47805802216087259b07de691ef47ff6fbc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3b0fe478.failed

Commit 1ca1915 ("xfs: Don't use unwritten extents for DAX") enabled
the DAX allocation call to dip into the reserve pool in case it was
converting unwritten extents rather than allocating blocks. This was
a direct copy of the unwritten extent conversion code, but had an
unintended side effect of allowing normal data block allocation to
use the reserve pool. Hence normal block allocation could deplete
the reserve pool and prevent unwritten extent conversion at ENOSPC,
hence violating fallocate guarantees on preallocated space.

Fix it by checking whether the incoming map from __xfs_get_blocks()
spans an unwritten extent and only use the reserve pool if the
allocation covers an unwritten extent.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Tested-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 3b0fe47805802216087259b07de691ef47ff6fbc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_iomap.c
diff --cc fs/xfs/xfs_iomap.c
index 8a10c6211bb4,9ed146b96856..000000000000
--- a/fs/xfs/xfs_iomap.c
+++ b/fs/xfs/xfs_iomap.c
@@@ -195,6 -196,28 +195,31 @@@ xfs_iomap_write_direct
  	 * Allocate and setup the transaction
  	 */
  	tp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * For DAX, we do not allocate unwritten extents, but instead we zero
+ 	 * the block before we commit the transaction.  Ideally we'd like to do
+ 	 * this outside the transaction context, but if we commit and then crash
+ 	 * we may not have zeroed the blocks and this will be exposed on
+ 	 * recovery of the allocation. Hence we must zero before commit.
+ 	 *
+ 	 * Further, if we are mapping unwritten extents here, we need to zero
+ 	 * and convert them to written so that we don't need an unwritten extent
+ 	 * callback for DAX. This also means that we need to be able to dip into
+ 	 * the reserve block pool for bmbt block allocation if there is no space
+ 	 * left but we need to do unwritten extent conversion.
+ 	 */
+ 
+ 	if (IS_DAX(VFS_I(ip))) {
+ 		bmapi_flags = XFS_BMAPI_CONVERT | XFS_BMAPI_ZERO;
+ 		if (ISUNWRITTEN(imap)) {
+ 			tp->t_flags |= XFS_TRANS_RESERVE;
+ 			resblks = XFS_DIOSTRAT_SPACE_RES(mp, 0) << 1;
+ 		}
+ 	}
++>>>>>>> 3b0fe4780580 (xfs: Don't use reserved blocks for data blocks with DAX)
  	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,
  				  resblks, resrtextents);
  	/*
* Unmerged path fs/xfs/xfs_iomap.c
