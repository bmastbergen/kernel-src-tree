mmc: core: Record card drive strength

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 3853a042325e8f497c199020979c4fc824528c6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3853a042.failed

In preparation for adding drive strength support
for eMMC, add drive_strength to struct mmc_card
to record the card drive strength for UHS-I modes
and HS200 / HS400. For eMMC this will be needed
when switching between HS200 and HS400.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 3853a042325e8f497c199020979c4fc824528c6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/sd.c
#	drivers/mmc/core/sdio.c
#	include/linux/mmc/card.h
diff --cc drivers/mmc/core/sd.c
index da5e61e128a5,b99e25b9bcdc..000000000000
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@@ -388,64 -386,31 +388,83 @@@ out
  
  static int sd_select_driver_type(struct mmc_card *card, u8 *status)
  {
 -	int card_drv_type, drive_strength, drv_type;
 +	int host_drv_type = SD_DRIVER_TYPE_B;
 +	int card_drv_type = SD_DRIVER_TYPE_B;
 +	int drive_strength;
  	int err;
  
++<<<<<<< HEAD
 +	/*
 +	 * If the host doesn't support any of the Driver Types A,C or D,
 +	 * or there is no board specific handler then default Driver
 +	 * Type B is used.
 +	 */
 +	if (!(card->host->caps & (MMC_CAP_DRIVER_TYPE_A | MMC_CAP_DRIVER_TYPE_C
 +	    | MMC_CAP_DRIVER_TYPE_D)))
 +		return 0;
++=======
+ 	card->drive_strength = 0;
+ 
+ 	card_drv_type = card->sw_caps.sd3_drv_type | SD_DRIVER_TYPE_B;
++>>>>>>> 3853a042325e (mmc: core: Record card drive strength)
 +
 +	if (!card->host->ops->select_drive_strength)
 +		return 0;
 +
++<<<<<<< HEAD
 +	if (card->host->caps & MMC_CAP_DRIVER_TYPE_A)
 +		host_drv_type |= SD_DRIVER_TYPE_A;
 +
 +	if (card->host->caps & MMC_CAP_DRIVER_TYPE_C)
 +		host_drv_type |= SD_DRIVER_TYPE_C;
  
 -	drive_strength = mmc_select_drive_strength(card,
 -						   card->sw_caps.uhs_max_dtr,
 -						   card_drv_type, &drv_type);
 +	if (card->host->caps & MMC_CAP_DRIVER_TYPE_D)
 +		host_drv_type |= SD_DRIVER_TYPE_D;
  
 +	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_A)
 +		card_drv_type |= SD_DRIVER_TYPE_A;
 +
 +	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
 +		card_drv_type |= SD_DRIVER_TYPE_C;
 +
 +	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_D)
 +		card_drv_type |= SD_DRIVER_TYPE_D;
 +
 +	/*
 +	 * The drive strength that the hardware can support
 +	 * depends on the board design.  Pass the appropriate
 +	 * information and let the hardware specific code
 +	 * return what is possible given the options
 +	 */
 +	mmc_host_clk_hold(card->host);
 +	drive_strength = card->host->ops->select_drive_strength(
 +		card->sw_caps.uhs_max_dtr,
 +		host_drv_type, card_drv_type);
 +	mmc_host_clk_release(card->host);
 +
 +	err = mmc_sd_switch(card, 1, 2, drive_strength, status);
 +	if (err)
 +		return err;
 +
 +	if ((status[15] & 0xF) != drive_strength) {
 +		pr_warning("%s: Problem setting drive strength!\n",
 +			mmc_hostname(card->host));
 +		return 0;
++=======
+ 	if (drive_strength) {
+ 		err = mmc_sd_switch(card, 1, 2, drive_strength, status);
+ 		if (err)
+ 			return err;
+ 		if ((status[15] & 0xF) != drive_strength) {
+ 			pr_warn("%s: Problem setting drive strength!\n",
+ 				mmc_hostname(card->host));
+ 			return 0;
+ 		}
+ 		card->drive_strength = drive_strength;
++>>>>>>> 3853a042325e (mmc: core: Record card drive strength)
  	}
  
 -	if (drv_type)
 -		mmc_set_driver_type(card->host, drv_type);
 +	mmc_set_driver_type(card->host, drive_strength);
  
  	return 0;
  }
diff --cc drivers/mmc/core/sdio.c
index d2f16e27144d,b91abedcfdca..000000000000
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@@ -408,63 -406,34 +408,79 @@@ static void sdio_select_driver_type(str
  	unsigned char card_strength;
  	int err;
  
++<<<<<<< HEAD
 +	/*
 +	 * If the host doesn't support any of the Driver Types A,C or D,
 +	 * or there is no board specific handler then default Driver
 +	 * Type B is used.
 +	 */
 +	if (!(card->host->caps &
 +		(MMC_CAP_DRIVER_TYPE_A |
 +		 MMC_CAP_DRIVER_TYPE_C |
 +		 MMC_CAP_DRIVER_TYPE_D)))
 +		return;
++=======
+ 	card->drive_strength = 0;
+ 
+ 	card_drv_type = card->sw_caps.sd3_drv_type | SD_DRIVER_TYPE_B;
++>>>>>>> 3853a042325e (mmc: core: Record card drive strength)
  
 -	drive_strength = mmc_select_drive_strength(card,
 -						   card->sw_caps.uhs_max_dtr,
 -						   card_drv_type, &drv_type);
 +	if (!card->host->ops->select_drive_strength)
 +		return;
  
 -	if (drive_strength) {
 -		/* if error just use default for drive strength B */
 -		err = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_DRIVE_STRENGTH, 0,
 -				       &card_strength);
 -		if (err)
 -			return;
 +	if (card->host->caps & MMC_CAP_DRIVER_TYPE_A)
 +		host_drv_type |= SD_DRIVER_TYPE_A;
  
 -		card_strength &= ~(SDIO_DRIVE_DTSx_MASK<<SDIO_DRIVE_DTSx_SHIFT);
 -		card_strength |= host_drive_to_sdio_drive(drive_strength);
 +	if (card->host->caps & MMC_CAP_DRIVER_TYPE_C)
 +		host_drv_type |= SD_DRIVER_TYPE_C;
  
++<<<<<<< HEAD
 +	if (card->host->caps & MMC_CAP_DRIVER_TYPE_D)
 +		host_drv_type |= SD_DRIVER_TYPE_D;
++=======
+ 		/* if error default to drive strength B */
+ 		err = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_DRIVE_STRENGTH,
+ 				       card_strength, NULL);
+ 		if (err)
+ 			return;
+ 		card->drive_strength = drive_strength;
+ 	}
++>>>>>>> 3853a042325e (mmc: core: Record card drive strength)
 +
 +	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_A)
 +		card_drv_type |= SD_DRIVER_TYPE_A;
 +
 +	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
 +		card_drv_type |= SD_DRIVER_TYPE_C;
 +
 +	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_D)
 +		card_drv_type |= SD_DRIVER_TYPE_D;
 +
 +	/*
 +	 * The drive strength that the hardware can support
 +	 * depends on the board design.  Pass the appropriate
 +	 * information and let the hardware specific code
 +	 * return what is possible given the options
 +	 */
 +	drive_strength = card->host->ops->select_drive_strength(
 +		card->sw_caps.uhs_max_dtr,
 +		host_drv_type, card_drv_type);
 +
 +	/* if error just use default for drive strength B */
 +	err = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_DRIVE_STRENGTH, 0,
 +		&card_strength);
 +	if (err)
 +		return;
  
 -	if (drv_type)
 -		mmc_set_driver_type(card->host, drv_type);
 +	card_strength &= ~(SDIO_DRIVE_DTSx_MASK<<SDIO_DRIVE_DTSx_SHIFT);
 +	card_strength |= host_drive_to_sdio_drive(drive_strength);
 +
 +	err = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_DRIVE_STRENGTH,
 +		card_strength, NULL);
 +
 +	/* if error default to drive strength B */
 +	if (!err)
 +		mmc_set_driver_type(card->host, drive_strength);
  }
  
  
diff --cc include/linux/mmc/card.h
index e849091ca5d8,2f073d555793..000000000000
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@@ -303,6 -304,8 +303,11 @@@ struct mmc_card 
  	struct sdio_func_tuple	*tuples;	/* unknown common tuples */
  
  	unsigned int		sd_bus_speed;	/* Bus Speed Mode set for the card */
++<<<<<<< HEAD
++=======
+ 	unsigned int		mmc_avail_type;	/* supported device type by both host and card */
+ 	unsigned int		drive_strength;	/* for UHS-I, HS200 or HS400 */
++>>>>>>> 3853a042325e (mmc: core: Record card drive strength)
  
  	struct dentry		*debugfs_root;
  	struct mmc_part	part[MMC_NUM_PHY_PARTITION]; /* physical partitions */
* Unmerged path drivers/mmc/core/sd.c
* Unmerged path drivers/mmc/core/sdio.c
* Unmerged path include/linux/mmc/card.h
