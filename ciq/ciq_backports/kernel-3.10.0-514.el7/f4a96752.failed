drm/i915/gen9: Allow watermark calculation on in-flight atomic state (v3)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matt Roper <matthew.d.roper@intel.com>
commit f4a967523ec7215a3ec867b7ed2e916bd34840e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f4a96752.failed

In an upcoming patch we'll move this calculation to the atomic 'check'
phase so that the display update can be rejected early if no valid
watermark programming is possible.

v2:
 - Drop intel_pstate_for_cstate_plane() helper and add note about how
   the code needs to evolve in the future if we start allowing more than
   one pending commit against a CRTC.  (Maarten)

v3:
 - Only have skl_compute_wm_level calculate watermarks for enabled
   planes; we can just set the other planes on a CRTC to disabled
   without having to look at the plane state.  This is important because
   despite our CRTC lock we can still have racing commits that modify
   a disabled plane's property without turning it on.  (Maarten)

	Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1463061971-19638-13-git-send-email-matthew.d.roper@intel.com
(cherry picked from commit f4a967523ec7215a3ec867b7ed2e916bd34840e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index cca54888a5ac,4d52402a5759..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -2939,18 -3327,56 +2939,71 @@@ static bool skl_compute_plane_wm(const 
  	return true;
  }
  
++<<<<<<< HEAD
 +static void skl_compute_wm_level(const struct drm_i915_private *dev_priv,
 +				 struct skl_ddb_allocation *ddb,
 +				 struct skl_pipe_wm_parameters *p,
 +				 enum pipe pipe,
 +				 int level,
 +				 int num_planes,
 +				 struct skl_wm_level *result)
 +{
++=======
+ static int
+ skl_compute_wm_level(const struct drm_i915_private *dev_priv,
+ 		     struct skl_ddb_allocation *ddb,
+ 		     struct intel_crtc_state *cstate,
+ 		     int level,
+ 		     struct skl_wm_level *result)
+ {
+ 	struct drm_device *dev = dev_priv->dev;
+ 	struct drm_atomic_state *state = cstate->base.state;
+ 	struct intel_crtc *intel_crtc = to_intel_crtc(cstate->base.crtc);
+ 	struct drm_plane *plane;
+ 	struct intel_plane *intel_plane;
+ 	struct intel_plane_state *intel_pstate;
++>>>>>>> f4a967523ec7 (drm/i915/gen9: Allow watermark calculation on in-flight atomic state (v3))
  	uint16_t ddb_blocks;
 -	enum pipe pipe = intel_crtc->pipe;
 +	int i;
  
++<<<<<<< HEAD
 +	for (i = 0; i < num_planes; i++) {
++=======
+ 	/*
+ 	 * We'll only calculate watermarks for planes that are actually
+ 	 * enabled, so make sure all other planes are set as disabled.
+ 	 */
+ 	memset(result, 0, sizeof(*result));
+ 
+ 	for_each_intel_plane_mask(dev, intel_plane, cstate->base.plane_mask) {
+ 		int i = skl_wm_plane_id(intel_plane);
+ 
+ 		plane = &intel_plane->base;
+ 		intel_pstate = NULL;
+ 		if (state)
+ 			intel_pstate =
+ 				intel_atomic_get_existing_plane_state(state,
+ 								      intel_plane);
+ 
+ 		/*
+ 		 * Note: If we start supporting multiple pending atomic commits
+ 		 * against the same planes/CRTC's in the future, plane->state
+ 		 * will no longer be the correct pre-state to use for the
+ 		 * calculations here and we'll need to change where we get the
+ 		 * 'unchanged' plane data from.
+ 		 *
+ 		 * For now this is fine because we only allow one queued commit
+ 		 * against a CRTC.  Even if the plane isn't modified by this
+ 		 * transaction and we don't have a plane lock, we still have
+ 		 * the CRTC's lock, so we know that no other transactions are
+ 		 * racing with us to update it.
+ 		 */
+ 		if (!intel_pstate)
+ 			intel_pstate = to_intel_plane_state(plane->state);
+ 
+ 		WARN_ON(!intel_pstate->base.fb);
+ 
++>>>>>>> f4a967523ec7 (drm/i915/gen9: Allow watermark calculation on in-flight atomic state (v3))
  		ddb_blocks = skl_ddb_entry_size(&ddb->plane[pipe][i]);
  
  		result->plane_en[i] = skl_compute_plane_wm(dev_priv,
@@@ -2961,11 -3388,7 +3014,15 @@@
  						&result->plane_res_l[i]);
  	}
  
++<<<<<<< HEAD
 +	ddb_blocks = skl_ddb_entry_size(&ddb->cursor[pipe]);
 +	result->cursor_en = skl_compute_plane_wm(dev_priv, p, &p->cursor,
 +						 ddb_blocks, level,
 +						 &result->cursor_res_b,
 +						 &result->cursor_res_l);
++=======
+ 	return 0;
++>>>>>>> f4a967523ec7 (drm/i915/gen9: Allow watermark calculation on in-flight atomic state (v3))
  }
  
  static uint32_t
@@@ -3253,22 -3683,20 +3310,33 @@@ static void skl_flush_wm_values(struct 
  	}
  }
  
++<<<<<<< HEAD
 +static bool skl_update_pipe_wm(struct drm_crtc *crtc,
 +			       struct skl_pipe_wm_parameters *params,
 +			       struct intel_wm_config *config,
 +			       struct skl_ddb_allocation *ddb, /* out */
 +			       struct skl_pipe_wm *pipe_wm /* out */)
 +{
 +	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 +
 +	skl_compute_wm_pipe_parameters(crtc, params);
 +	skl_allocate_pipe_ddb(crtc, config, params, ddb);
 +	skl_compute_pipe_wm(crtc, ddb, params, pipe_wm);
++=======
+ static bool skl_update_pipe_wm(struct drm_crtc_state *cstate,
+ 			       struct skl_ddb_allocation *ddb, /* out */
+ 			       struct skl_pipe_wm *pipe_wm /* out */)
+ {
+ 	struct intel_crtc *intel_crtc = to_intel_crtc(cstate->crtc);
+ 	struct intel_crtc_state *intel_cstate = to_intel_crtc_state(cstate);
+ 
+ 	skl_build_pipe_wm(intel_cstate, ddb, pipe_wm);
++>>>>>>> f4a967523ec7 (drm/i915/gen9: Allow watermark calculation on in-flight atomic state (v3))
  
 -	if (!memcmp(&intel_crtc->wm.active.skl, pipe_wm, sizeof(*pipe_wm)))
 +	if (!memcmp(&intel_crtc->wm.skl_active, pipe_wm, sizeof(*pipe_wm)))
  		return false;
  
 -	intel_crtc->wm.active.skl = *pipe_wm;
 -
 +	intel_crtc->wm.skl_active = *pipe_wm;
  	return true;
  }
  
@@@ -3305,8 -3730,7 +3373,12 @@@ static void skl_update_other_pipe_wm(st
  		if (!intel_crtc->active)
  			continue;
  
++<<<<<<< HEAD
 +		wm_changed = skl_update_pipe_wm(&intel_crtc->base,
 +						&params, config,
++=======
+ 		wm_changed = skl_update_pipe_wm(intel_crtc->base.state,
++>>>>>>> f4a967523ec7 (drm/i915/gen9: Allow watermark calculation on in-flight atomic state (v3))
  						&r->ddb, &pipe_wm);
  
  		/*
@@@ -3326,23 -3838,23 +3398,29 @@@ static void skl_update_wm(struct drm_cr
  	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
  	struct drm_device *dev = crtc->dev;
  	struct drm_i915_private *dev_priv = dev->dev_private;
 +	struct skl_pipe_wm_parameters params = {};
  	struct skl_wm_values *results = &dev_priv->wm.skl_results;
 -	struct intel_crtc_state *cstate = to_intel_crtc_state(crtc->state);
 -	struct skl_pipe_wm *pipe_wm = &cstate->wm.skl.optimal;
 +	struct skl_pipe_wm pipe_wm = {};
 +	struct intel_wm_config config = {};
  
 +	memset(results, 0, sizeof(*results));
  
 -	/* Clear all dirty flags */
 -	memset(results->dirty, 0, sizeof(bool) * I915_MAX_PIPES);
 +	skl_compute_wm_global_parameters(dev, &config);
  
++<<<<<<< HEAD
 +	if (!skl_update_pipe_wm(crtc, &params, &config,
 +				&results->ddb, &pipe_wm))
++=======
+ 	skl_clear_wm(results, intel_crtc->pipe);
+ 
+ 	if (!skl_update_pipe_wm(crtc->state, &results->ddb, pipe_wm))
++>>>>>>> f4a967523ec7 (drm/i915/gen9: Allow watermark calculation on in-flight atomic state (v3))
  		return;
  
 -	skl_compute_wm_results(dev, pipe_wm, results, intel_crtc);
 +	skl_compute_wm_results(dev, &params, &pipe_wm, results, intel_crtc);
  	results->dirty[intel_crtc->pipe] = true;
  
 -	skl_update_other_pipe_wm(dev, crtc, results);
 +	skl_update_other_pipe_wm(dev, crtc, &config, results);
  	skl_write_wm_values(dev_priv, results);
  	skl_flush_wm_values(dev_priv, results);
  
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
