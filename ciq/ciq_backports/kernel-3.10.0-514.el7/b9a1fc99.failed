mei: me: d0i3: exit d0i3 on driver start and enter it on stop

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit b9a1fc99588c2861d4dc26d53b0f47b495cc2964
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b9a1fc99.failed

A BIOS may put the device in d0i3 on platform initialization so it wonâ€™t
consume power even if the driver is not present, in turn the driver has
to wake up the devices on load in order to perform the initialization
sequence and move it back to low power state on driver remove.

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit b9a1fc99588c2861d4dc26d53b0f47b495cc2964)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/hw-me.c
diff --cc drivers/misc/mei/hw-me.c
index 1707fa5ea02a,65511d39d89b..000000000000
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@@ -109,12 -205,25 +109,26 @@@ static inline void mei_hcsr_set(struct 
   */
  static void mei_me_hw_config(struct mei_device *dev)
  {
 -	struct pci_dev *pdev = to_pci_dev(dev->dev);
  	struct mei_me_hw *hw = to_me_hw(dev);
 -	u32 hcsr, reg;
 -
 +	u32 hcsr = mei_hcsr_read(to_me_hw(dev));
  	/* Doesn't change in runtime */
 -	hcsr = mei_hcsr_read(dev);
  	dev->hbuf_depth = (hcsr & H_CBD) >> 24;
  
++<<<<<<< HEAD
 +	hw->pg_state = MEI_PG_OFF;
++=======
+ 	reg = 0;
+ 	pci_read_config_dword(pdev, PCI_CFG_HFS_1, &reg);
+ 	hw->d0i3_supported =
+ 		((reg & PCI_CFG_HFS_1_D0I3_MSK) == PCI_CFG_HFS_1_D0I3_MSK);
+ 
+ 	hw->pg_state = MEI_PG_OFF;
+ 	if (hw->d0i3_supported) {
+ 		reg = mei_me_d0i3c_read(dev);
+ 		if (reg & H_D0I3C_I3)
+ 			hw->pg_state = MEI_PG_ON;
+ 	}
++>>>>>>> b9a1fc99588c (mei: me: d0i3: exit d0i3 on driver start and enter it on stop)
  }
  
  /**
@@@ -603,6 -730,380 +617,383 @@@ notsupported
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mei_me_d0i3_set - write d0i3 register bit on mei device.
+  *
+  * @dev: the device structure
+  * @intr: ask for interrupt
+  *
+  * Return: D0I3C register value
+  */
+ static u32 mei_me_d0i3_set(struct mei_device *dev, bool intr)
+ {
+ 	u32 reg = mei_me_d0i3c_read(dev);
+ 
+ 	reg |= H_D0I3C_I3;
+ 	if (intr)
+ 		reg |= H_D0I3C_IR;
+ 	else
+ 		reg &= ~H_D0I3C_IR;
+ 	mei_me_d0i3c_write(dev, reg);
+ 	/* read it to ensure HW consistency */
+ 	reg = mei_me_d0i3c_read(dev);
+ 	return reg;
+ }
+ 
+ /**
+  * mei_me_d0i3_unset - clean d0i3 register bit on mei device.
+  *
+  * @dev: the device structure
+  *
+  * Return: D0I3C register value
+  */
+ static u32 mei_me_d0i3_unset(struct mei_device *dev)
+ {
+ 	u32 reg = mei_me_d0i3c_read(dev);
+ 
+ 	reg &= ~H_D0I3C_I3;
+ 	reg |= H_D0I3C_IR;
+ 	mei_me_d0i3c_write(dev, reg);
+ 	/* read it to ensure HW consistency */
+ 	reg = mei_me_d0i3c_read(dev);
+ 	return reg;
+ }
+ 
+ /**
+  * mei_me_d0i3_enter_sync - perform d0i3 entry procedure
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ static int mei_me_d0i3_enter_sync(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 	unsigned long d0i3_timeout = mei_secs_to_jiffies(MEI_D0I3_TIMEOUT);
+ 	unsigned long pgi_timeout = mei_secs_to_jiffies(MEI_PGI_TIMEOUT);
+ 	int ret;
+ 	u32 reg;
+ 
+ 	reg = mei_me_d0i3c_read(dev);
+ 	if (reg & H_D0I3C_I3) {
+ 		/* we are in d0i3, nothing to do */
+ 		dev_dbg(dev->dev, "d0i3 set not needed\n");
+ 		ret = 0;
+ 		goto on;
+ 	}
+ 
+ 	/* PGI entry procedure */
+ 	dev->pg_event = MEI_PG_EVENT_WAIT;
+ 
+ 	ret = mei_hbm_pg(dev, MEI_PG_ISOLATION_ENTRY_REQ_CMD);
+ 	if (ret)
+ 		/* FIXME: should we reset here? */
+ 		goto out;
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 	wait_event_timeout(dev->wait_pg,
+ 		dev->pg_event == MEI_PG_EVENT_RECEIVED, pgi_timeout);
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (dev->pg_event != MEI_PG_EVENT_RECEIVED) {
+ 		ret = -ETIME;
+ 		goto out;
+ 	}
+ 	/* end PGI entry procedure */
+ 
+ 	dev->pg_event = MEI_PG_EVENT_INTR_WAIT;
+ 
+ 	reg = mei_me_d0i3_set(dev, true);
+ 	if (!(reg & H_D0I3C_CIP)) {
+ 		dev_dbg(dev->dev, "d0i3 enter wait not needed\n");
+ 		ret = 0;
+ 		goto on;
+ 	}
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 	wait_event_timeout(dev->wait_pg,
+ 		dev->pg_event == MEI_PG_EVENT_INTR_RECEIVED, d0i3_timeout);
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (dev->pg_event != MEI_PG_EVENT_INTR_RECEIVED) {
+ 		reg = mei_me_d0i3c_read(dev);
+ 		if (!(reg & H_D0I3C_I3)) {
+ 			ret = -ETIME;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	ret = 0;
+ on:
+ 	hw->pg_state = MEI_PG_ON;
+ out:
+ 	dev->pg_event = MEI_PG_EVENT_IDLE;
+ 	dev_dbg(dev->dev, "d0i3 enter ret = %d\n", ret);
+ 	return ret;
+ }
+ 
+ /**
+  * mei_me_d0i3_enter - perform d0i3 entry procedure
+  *   no hbm PG handshake
+  *   no waiting for confirmation; runs with interrupts
+  *   disabled
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ static int mei_me_d0i3_enter(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 	u32 reg;
+ 
+ 	reg = mei_me_d0i3c_read(dev);
+ 	if (reg & H_D0I3C_I3) {
+ 		/* we are in d0i3, nothing to do */
+ 		dev_dbg(dev->dev, "already d0i3 : set not needed\n");
+ 		goto on;
+ 	}
+ 
+ 	mei_me_d0i3_set(dev, false);
+ on:
+ 	hw->pg_state = MEI_PG_ON;
+ 	dev->pg_event = MEI_PG_EVENT_IDLE;
+ 	dev_dbg(dev->dev, "d0i3 enter\n");
+ 	return 0;
+ }
+ 
+ /**
+  * mei_me_d0i3_exit_sync - perform d0i3 exit procedure
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ static int mei_me_d0i3_exit_sync(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 	unsigned long timeout = mei_secs_to_jiffies(MEI_D0I3_TIMEOUT);
+ 	int ret;
+ 	u32 reg;
+ 
+ 	dev->pg_event = MEI_PG_EVENT_INTR_WAIT;
+ 
+ 	reg = mei_me_d0i3c_read(dev);
+ 	if (!(reg & H_D0I3C_I3)) {
+ 		/* we are not in d0i3, nothing to do */
+ 		dev_dbg(dev->dev, "d0i3 exit not needed\n");
+ 		ret = 0;
+ 		goto off;
+ 	}
+ 
+ 	reg = mei_me_d0i3_unset(dev);
+ 	if (!(reg & H_D0I3C_CIP)) {
+ 		dev_dbg(dev->dev, "d0i3 exit wait not needed\n");
+ 		ret = 0;
+ 		goto off;
+ 	}
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 	wait_event_timeout(dev->wait_pg,
+ 		dev->pg_event == MEI_PG_EVENT_INTR_RECEIVED, timeout);
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (dev->pg_event != MEI_PG_EVENT_INTR_RECEIVED) {
+ 		reg = mei_me_d0i3c_read(dev);
+ 		if (reg & H_D0I3C_I3) {
+ 			ret = -ETIME;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	ret = 0;
+ off:
+ 	hw->pg_state = MEI_PG_OFF;
+ out:
+ 	dev->pg_event = MEI_PG_EVENT_IDLE;
+ 
+ 	dev_dbg(dev->dev, "d0i3 exit ret = %d\n", ret);
+ 	return ret;
+ }
+ 
+ /**
+  * mei_me_pg_legacy_intr - perform legacy pg processing
+  *			   in interrupt thread handler
+  *
+  * @dev: the device structure
+  */
+ static void mei_me_pg_legacy_intr(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 
+ 	if (dev->pg_event != MEI_PG_EVENT_INTR_WAIT)
+ 		return;
+ 
+ 	dev->pg_event = MEI_PG_EVENT_INTR_RECEIVED;
+ 	hw->pg_state = MEI_PG_OFF;
+ 	if (waitqueue_active(&dev->wait_pg))
+ 		wake_up(&dev->wait_pg);
+ }
+ 
+ /**
+  * mei_me_d0i3_intr - perform d0i3 processing in interrupt thread handler
+  *
+  * @dev: the device structure
+  */
+ static void mei_me_d0i3_intr(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 
+ 	if (dev->pg_event == MEI_PG_EVENT_INTR_WAIT &&
+ 	    (hw->intr_source & H_D0I3C_IS)) {
+ 		dev->pg_event = MEI_PG_EVENT_INTR_RECEIVED;
+ 		if (hw->pg_state == MEI_PG_ON) {
+ 			hw->pg_state = MEI_PG_OFF;
+ 			if (dev->hbm_state != MEI_HBM_IDLE) {
+ 				/*
+ 				 * force H_RDY because it could be
+ 				 * wiped off during PG
+ 				 */
+ 				dev_dbg(dev->dev, "d0i3 set host ready\n");
+ 				mei_me_host_set_ready(dev);
+ 			}
+ 		} else {
+ 			hw->pg_state = MEI_PG_ON;
+ 		}
+ 
+ 		wake_up(&dev->wait_pg);
+ 	}
+ 
+ 	if (hw->pg_state == MEI_PG_ON && (hw->intr_source & H_IS)) {
+ 		/*
+ 		 * HW sent some data and we are in D0i3, so
+ 		 * we got here because of HW initiated exit from D0i3.
+ 		 * Start runtime pm resume sequence to exit low power state.
+ 		 */
+ 		dev_dbg(dev->dev, "d0i3 want resume\n");
+ 		mei_hbm_pg_resume(dev);
+ 	}
+ }
+ 
+ /**
+  * mei_me_pg_intr - perform pg processing in interrupt thread handler
+  *
+  * @dev: the device structure
+  */
+ static void mei_me_pg_intr(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 
+ 	if (hw->d0i3_supported)
+ 		mei_me_d0i3_intr(dev);
+ 	else
+ 		mei_me_pg_legacy_intr(dev);
+ }
+ 
+ /**
+  * mei_me_pg_enter_sync - perform runtime pm entry procedure
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ int mei_me_pg_enter_sync(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 
+ 	if (hw->d0i3_supported)
+ 		return mei_me_d0i3_enter_sync(dev);
+ 	else
+ 		return mei_me_pg_legacy_enter_sync(dev);
+ }
+ 
+ /**
+  * mei_me_pg_exit_sync - perform runtime pm exit procedure
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ int mei_me_pg_exit_sync(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 
+ 	if (hw->d0i3_supported)
+ 		return mei_me_d0i3_exit_sync(dev);
+ 	else
+ 		return mei_me_pg_legacy_exit_sync(dev);
+ }
+ 
+ /**
+  * mei_me_hw_reset - resets fw via mei csr register.
+  *
+  * @dev: the device structure
+  * @intr_enable: if interrupt should be enabled after reset.
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ static int mei_me_hw_reset(struct mei_device *dev, bool intr_enable)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 	int ret;
+ 	u32 hcsr;
+ 
+ 	if (intr_enable) {
+ 		mei_me_intr_enable(dev);
+ 		if (hw->d0i3_supported) {
+ 			ret = mei_me_d0i3_exit_sync(dev);
+ 			if (ret)
+ 				return ret;
+ 		}
+ 	}
+ 
+ 	hcsr = mei_hcsr_read(dev);
+ 	/* H_RST may be found lit before reset is started,
+ 	 * for example if preceding reset flow hasn't completed.
+ 	 * In that case asserting H_RST will be ignored, therefore
+ 	 * we need to clean H_RST bit to start a successful reset sequence.
+ 	 */
+ 	if ((hcsr & H_RST) == H_RST) {
+ 		dev_warn(dev->dev, "H_RST is set = 0x%08X", hcsr);
+ 		hcsr &= ~H_RST;
+ 		mei_hcsr_set(dev, hcsr);
+ 		hcsr = mei_hcsr_read(dev);
+ 	}
+ 
+ 	hcsr |= H_RST | H_IG | H_CSR_IS_MASK;
+ 
+ 	if (!intr_enable)
+ 		hcsr &= ~H_CSR_IE_MASK;
+ 
+ 	dev->recvd_hw_ready = false;
+ 	mei_hcsr_write(dev, hcsr);
+ 
+ 	/*
+ 	 * Host reads the H_CSR once to ensure that the
+ 	 * posted write to H_CSR completes.
+ 	 */
+ 	hcsr = mei_hcsr_read(dev);
+ 
+ 	if ((hcsr & H_RST) == 0)
+ 		dev_warn(dev->dev, "H_RST is not set = 0x%08X", hcsr);
+ 
+ 	if ((hcsr & H_RDY) == H_RDY)
+ 		dev_warn(dev->dev, "H_RDY is not cleared 0x%08X", hcsr);
+ 
+ 	if (!intr_enable) {
+ 		mei_me_hw_reset_release(dev);
+ 		if (hw->d0i3_supported) {
+ 			ret = mei_me_d0i3_enter(dev);
+ 			if (ret)
+ 				return ret;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ /**
++>>>>>>> b9a1fc99588c (mei: me: d0i3: exit d0i3 on driver start and enter it on stop)
   * mei_me_irq_quick_handler - The ISR of the MEI device
   *
   * @irq: The irq number
* Unmerged path drivers/misc/mei/hw-me.c
