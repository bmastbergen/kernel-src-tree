perf stat report: Add report command

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit ba6039b6c8fcc24de7d6ab7b0bada4becaf84a2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ba6039b6.failed

Adding 'perf stat report' command support. ATM it only processes attr
events and display nothing.

	Reported-by: Kan Liang <kan.liang@intel.com>
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1446734469-11352-12-git-send-email-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit ba6039b6c8fcc24de7d6ab7b0bada4becaf84a2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Documentation/perf-stat.txt
#	tools/perf/builtin-stat.c
diff --cc tools/perf/Documentation/perf-stat.txt
index 4e074a660826,95f492828657..000000000000
--- a/tools/perf/Documentation/perf-stat.txt
+++ b/tools/perf/Documentation/perf-stat.txt
@@@ -10,6 -10,8 +10,11 @@@ SYNOPSI
  [verse]
  'perf stat' [-e <EVENT> | --event=EVENT] [-a] <command>
  'perf stat' [-e <EVENT> | --event=EVENT] [-a] -- <command> [<options>]
++<<<<<<< HEAD
++=======
+ 'perf stat' [-e <EVENT> | --event=EVENT] [-a] record [-o file] -- <command> [<options>]
+ 'perf stat' report [-i file]
++>>>>>>> ba6039b6c8fc (perf stat report: Add report command)
  
  DESCRIPTION
  -----------
@@@ -22,7 -24,12 +27,10 @@@ OPTION
  <command>...::
  	Any command you can specify in a shell.
  
 -record::
 -	See STAT RECORD.
  
+ report::
+ 	See STAT REPORT.
+ 
  -e::
  --event=::
  	Select the PMU event. Selection can be:
@@@ -159,6 -166,23 +167,26 @@@ filter out the startup phase of the pro
  
  Print statistics of transactional execution if supported.
  
++<<<<<<< HEAD
++=======
+ STAT RECORD
+ -----------
+ Stores stat data into perf data file.
+ 
+ -o file::
+ --output file::
+ Output file name.
+ 
+ STAT REPORT
+ -----------
+ Reads and reports stat data from perf data file.
+ 
+ -i file::
+ --input file::
+ Input file name.
+ 
+ 
++>>>>>>> ba6039b6c8fc (perf stat report: Add report command)
  EXAMPLES
  --------
  
diff --cc tools/perf/builtin-stat.c
index 473fc692d35a,abba49b847d2..000000000000
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@@ -59,6 -59,9 +59,12 @@@
  #include "util/thread.h"
  #include "util/thread_map.h"
  #include "util/counts.h"
++<<<<<<< HEAD
++=======
+ #include "util/session.h"
+ #include "util/tool.h"
+ #include "asm/bug.h"
++>>>>>>> ba6039b6c8fc (perf stat report: Add report command)
  
  #include <stdlib.h>
  #include <sys/prctl.h>
@@@ -119,7 -124,21 +125,25 @@@ static unsigned int		unit_width			= 4; 
  static bool			forever				= false;
  static struct timespec		ref_time;
  static struct cpu_map		*aggr_map;
++<<<<<<< HEAD
 +static int			(*aggr_get_id)(struct cpu_map *m, int cpu);
++=======
+ static aggr_get_id_t		aggr_get_id;
+ static bool			append_file;
+ static const char		*output_name;
+ static int			output_fd;
+ 
+ struct perf_stat {
+ 	bool			 record;
+ 	struct perf_data_file	 file;
+ 	struct perf_session	*session;
+ 	u64			 bytes_written;
+ 	struct perf_tool	 tool;
+ };
+ 
+ static struct perf_stat		perf_stat;
+ #define STAT_RECORD		perf_stat.record
++>>>>>>> ba6039b6c8fc (perf stat report: Add report command)
  
  static volatile int done = 0;
  
@@@ -1136,71 -1482,105 +1160,171 @@@ static int add_default_attributes(void
  	return perf_evlist__add_default_attrs(evsel_list, very_very_detailed_attrs);
  }
  
++<<<<<<< HEAD
++=======
+ static const char * const recort_usage[] = {
+ 	"perf stat record [<options>]",
+ 	NULL,
+ };
+ 
+ static void init_features(struct perf_session *session)
+ {
+ 	int feat;
+ 
+ 	for (feat = HEADER_FIRST_FEATURE; feat < HEADER_LAST_FEATURE; feat++)
+ 		perf_header__set_feat(&session->header, feat);
+ 
+ 	perf_header__clear_feat(&session->header, HEADER_BUILD_ID);
+ 	perf_header__clear_feat(&session->header, HEADER_TRACING_DATA);
+ 	perf_header__clear_feat(&session->header, HEADER_BRANCH_STACK);
+ 	perf_header__clear_feat(&session->header, HEADER_AUXTRACE);
+ }
+ 
+ static int __cmd_record(int argc, const char **argv)
+ {
+ 	struct perf_session *session;
+ 	struct perf_data_file *file = &perf_stat.file;
+ 
+ 	argc = parse_options(argc, argv, stat_options, record_usage,
+ 			     PARSE_OPT_STOP_AT_NON_OPTION);
+ 
+ 	if (output_name)
+ 		file->path = output_name;
+ 
+ 	if (run_count != 1 || forever) {
+ 		pr_err("Cannot use -r option with perf stat record.\n");
+ 		return -1;
+ 	}
+ 
+ 	session = perf_session__new(file, false, NULL);
+ 	if (session == NULL) {
+ 		pr_err("Perf session creation failed.\n");
+ 		return -1;
+ 	}
+ 
+ 	init_features(session);
+ 
+ 	session->evlist   = evsel_list;
+ 	perf_stat.session = session;
+ 	perf_stat.record  = true;
+ 	return argc;
+ }
+ 
+ static const char * const report_usage[] = {
+ 	"perf stat report [<options>]",
+ 	NULL,
+ };
+ 
+ static struct perf_stat perf_stat = {
+ 	.tool = {
+ 		.attr		= perf_event__process_attr,
+ 	},
+ };
+ 
+ static int __cmd_report(int argc, const char **argv)
+ {
+ 	struct perf_session *session;
+ 	const struct option options[] = {
+ 	OPT_STRING('i', "input", &input_name, "file", "input file name"),
+ 	OPT_END()
+ 	};
+ 	struct stat st;
+ 	int ret;
+ 
+ 	argc = parse_options(argc, argv, options, report_usage, 0);
+ 
+ 	if (!input_name || !strlen(input_name)) {
+ 		if (!fstat(STDIN_FILENO, &st) && S_ISFIFO(st.st_mode))
+ 			input_name = "-";
+ 		else
+ 			input_name = "perf.data";
+ 	}
+ 
+ 	perf_stat.file.path = input_name;
+ 	perf_stat.file.mode = PERF_DATA_MODE_READ;
+ 
+ 	session = perf_session__new(&perf_stat.file, false, &perf_stat.tool);
+ 	if (session == NULL)
+ 		return -1;
+ 
+ 	perf_stat.session  = session;
+ 	stat_config.output = stderr;
+ 	evsel_list         = session->evlist;
+ 
+ 	ret = perf_session__process_events(session);
+ 	if (ret)
+ 		return ret;
+ 
+ 	perf_session__delete(session);
+ 	return 0;
+ }
+ 
++>>>>>>> ba6039b6c8fc (perf stat report: Add report command)
  int cmd_stat(int argc, const char **argv, const char *prefix __maybe_unused)
  {
 +	bool append_file = false;
 +	int output_fd = 0;
 +	const char *output_name	= NULL;
 +	const struct option options[] = {
 +	OPT_BOOLEAN('T', "transaction", &transaction_run,
 +		    "hardware transaction statistics"),
 +	OPT_CALLBACK('e', "event", &evsel_list, "event",
 +		     "event selector. use 'perf list' to list available events",
 +		     parse_events_option),
 +	OPT_CALLBACK(0, "filter", &evsel_list, "filter",
 +		     "event filter", parse_filter),
 +	OPT_BOOLEAN('i', "no-inherit", &no_inherit,
 +		    "child tasks do not inherit counters"),
 +	OPT_STRING('p', "pid", &target.pid, "pid",
 +		   "stat events on existing process id"),
 +	OPT_STRING('t', "tid", &target.tid, "tid",
 +		   "stat events on existing thread id"),
 +	OPT_BOOLEAN('a', "all-cpus", &target.system_wide,
 +		    "system-wide collection from all CPUs"),
 +	OPT_BOOLEAN('g', "group", &group,
 +		    "put the counters into a counter group"),
 +	OPT_BOOLEAN('c', "scale", &stat_config.scale, "scale/normalize counters"),
 +	OPT_INCR('v', "verbose", &verbose,
 +		    "be more verbose (show counter open errors, etc)"),
 +	OPT_INTEGER('r', "repeat", &run_count,
 +		    "repeat command and print average + stddev (max: 100, forever: 0)"),
 +	OPT_BOOLEAN('n', "null", &null_run,
 +		    "null run - dont start any counters"),
 +	OPT_INCR('d', "detailed", &detailed_run,
 +		    "detailed run - start a lot of events"),
 +	OPT_BOOLEAN('S', "sync", &sync_run,
 +		    "call sync() before starting a run"),
 +	OPT_CALLBACK_NOOPT('B', "big-num", NULL, NULL,
 +			   "print large numbers with thousands\' separators",
 +			   stat__set_big_num),
 +	OPT_STRING('C', "cpu", &target.cpu_list, "cpu",
 +		    "list of cpus to monitor in system-wide"),
 +	OPT_SET_UINT('A', "no-aggr", &stat_config.aggr_mode,
 +		    "disable CPU count aggregation", AGGR_NONE),
 +	OPT_STRING('x', "field-separator", &csv_sep, "separator",
 +		   "print counts with custom separator"),
 +	OPT_CALLBACK('G', "cgroup", &evsel_list, "name",
 +		     "monitor event in cgroup name only", parse_cgroups),
 +	OPT_STRING('o', "output", &output_name, "file", "output file name"),
 +	OPT_BOOLEAN(0, "append", &append_file, "append to the output file"),
 +	OPT_INTEGER(0, "log-fd", &output_fd,
 +		    "log output to fd, instead of stderr"),
 +	OPT_STRING(0, "pre", &pre_cmd, "command",
 +			"command to run prior to the measured command"),
 +	OPT_STRING(0, "post", &post_cmd, "command",
 +			"command to run after to the measured command"),
 +	OPT_UINTEGER('I', "interval-print", &stat_config.interval,
 +		    "print counts at regular interval in ms (>= 10)"),
 +	OPT_SET_UINT(0, "per-socket", &stat_config.aggr_mode,
 +		     "aggregate counts per processor socket", AGGR_SOCKET),
 +	OPT_SET_UINT(0, "per-core", &stat_config.aggr_mode,
 +		     "aggregate counts per physical processor core", AGGR_CORE),
 +	OPT_SET_UINT(0, "per-thread", &stat_config.aggr_mode,
 +		     "aggregate counts per thread", AGGR_THREAD),
 +	OPT_UINTEGER('D', "delay", &initial_delay,
 +		     "ms to wait before starting measurement after program start"),
 +	OPT_END()
 +	};
  	const char * const stat_usage[] = {
  		"perf stat [<options>] [<command>]",
  		NULL
@@@ -1209,6 -1589,7 +1333,10 @@@
  	const char *mode;
  	FILE *output = stderr;
  	unsigned int interval;
++<<<<<<< HEAD
++=======
+ 	const char * const stat_subcommands[] = { "record", "report" };
++>>>>>>> ba6039b6c8fc (perf stat report: Add report command)
  
  	setlocale(LC_ALL, "");
  
@@@ -1216,8 -1597,16 +1344,21 @@@
  	if (evsel_list == NULL)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	argc = parse_options(argc, argv, options, stat_usage,
 +		PARSE_OPT_STOP_AT_NON_OPTION);
++=======
+ 	argc = parse_options_subcommand(argc, argv, stat_options, stat_subcommands,
+ 					(const char **) stat_usage,
+ 					PARSE_OPT_STOP_AT_NON_OPTION);
+ 
+ 	if (argc && !strncmp(argv[0], "rec", 3)) {
+ 		argc = __cmd_record(argc, argv);
+ 		if (argc < 0)
+ 			return -1;
+ 	} else if (argc && !strncmp(argv[0], "rep", 3))
+ 		return __cmd_report(argc, argv);
++>>>>>>> ba6039b6c8fc (perf stat report: Add report command)
  
  	interval = stat_config.interval;
  
* Unmerged path tools/perf/Documentation/perf-stat.txt
* Unmerged path tools/perf/builtin-stat.c
