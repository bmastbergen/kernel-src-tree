cdc_ncm: do not call usbnet_link_change from cdc_ncm_bind

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bjørn Mork <bjorn@mork.no>
commit 4d06dd537f95683aba3651098ae288b7cbff8274
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4d06dd53.failed

usbnet_link_change will call schedule_work and should be
avoided if bind is failing. Otherwise we will end up with
scheduled work referring to a netdev which has gone away.

Instead of making the call conditional, we can just defer
it to usbnet_probe, using the driver_info flag made for
this purpose.

Fixes: 8a34b0ae8778 ("usbnet: cdc_ncm: apply usbnet_link_change")
	Reported-by: Andrey Konovalov <andreyknvl@gmail.com>
	Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
	Signed-off-by: Bjørn Mork <bjorn@mork.no>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4d06dd537f95683aba3651098ae288b7cbff8274)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/cdc_ncm.c
diff --cc drivers/net/usb/cdc_ncm.c
index 7084b3f7ebac,86ba30ba35e8..000000000000
--- a/drivers/net/usb/cdc_ncm.c
+++ b/drivers/net/usb/cdc_ncm.c
@@@ -600,17 -992,11 +598,25 @@@ static int cdc_ncm_bind(struct usbnet *
  	if (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	/* The NCM data altsetting is fixed */
 +	ret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM);
 +
 +	/*
 +	 * We should get an event when network connection is "connected" or
 +	 * "disconnected". Set network connection in "disconnected" state
 +	 * (carrier is OFF) during attach, so the IP network stack does not
 +	 * start IPv6 negotiation and more.
 +	 */
 +	usbnet_link_change(dev, 0, 0);
 +	return ret;
++=======
+ 	/* The NCM data altsetting is fixed, so we hard-coded it.
+ 	 * Additionally, generic NCM devices are assumed to accept arbitrarily
+ 	 * placed NDP.
+ 	 */
+ 	return cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);
++>>>>>>> 4d06dd537f95 (cdc_ncm: do not call usbnet_link_change from cdc_ncm_bind)
  }
  
  static void cdc_ncm_align_tail(struct sk_buff *skb, size_t modulus, size_t remainder, size_t max)
@@@ -1125,23 -1577,12 +1131,24 @@@ static void cdc_ncm_status(struct usbne
  	}
  }
  
 +static int cdc_ncm_check_connect(struct usbnet *dev)
 +{
 +	struct cdc_ncm_ctx *ctx;
 +
 +	ctx = (struct cdc_ncm_ctx *)dev->data[0];
 +	if (ctx == NULL)
 +		return 1;	/* disconnected */
 +
 +	return !ctx->connected;
 +}
 +
  static const struct driver_info cdc_ncm_info = {
  	.description = "CDC NCM",
- 	.flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET,
+ 	.flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET
+ 			| FLAG_LINK_INTR,
  	.bind = cdc_ncm_bind,
  	.unbind = cdc_ncm_unbind,
 +	.check_connect = cdc_ncm_check_connect,
  	.manage_power = usbnet_manage_power,
  	.status = cdc_ncm_status,
  	.rx_fixup = cdc_ncm_rx_fixup,
@@@ -1152,10 -1593,9 +1159,10 @@@
  static const struct driver_info wwan_info = {
  	.description = "Mobile Broadband Network Device",
  	.flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET
- 			| FLAG_WWAN,
+ 			| FLAG_LINK_INTR | FLAG_WWAN,
  	.bind = cdc_ncm_bind,
  	.unbind = cdc_ncm_unbind,
 +	.check_connect = cdc_ncm_check_connect,
  	.manage_power = usbnet_manage_power,
  	.status = cdc_ncm_status,
  	.rx_fixup = cdc_ncm_rx_fixup,
@@@ -1166,10 -1606,9 +1173,10 @@@
  static const struct driver_info wwan_noarp_info = {
  	.description = "Mobile Broadband Network Device (NO ARP)",
  	.flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET
- 			| FLAG_WWAN | FLAG_NOARP,
+ 			| FLAG_LINK_INTR | FLAG_WWAN | FLAG_NOARP,
  	.bind = cdc_ncm_bind,
  	.unbind = cdc_ncm_unbind,
 +	.check_connect = cdc_ncm_check_connect,
  	.manage_power = usbnet_manage_power,
  	.status = cdc_ncm_status,
  	.rx_fixup = cdc_ncm_rx_fixup,
* Unmerged path drivers/net/usb/cdc_ncm.c
