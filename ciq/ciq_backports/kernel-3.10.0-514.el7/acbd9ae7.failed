ipmi: add of_device_id in MODULE_DEVICE_TABLE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Brijesh Singh <brijeshkumar.singh@amd.com>
commit acbd9ae70a94bdc626508f444879e19ebe1c421f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/acbd9ae7.failed

Fix autoloading ipmi modules when using device tree.

	Signed-off-by: Brijesh Singh <brijeshkumar.singh@amd.com>

Moved this change up into the CONFIG_OF section to account
for changes to the probing code.

	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit acbd9ae70a94bdc626508f444879e19ebe1c421f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_si_intf.c
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 0bbc7250462c,654f6f36a071..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -2752,9 -2644,146 +2752,150 @@@ static int ipmi_probe(struct platform_d
  		kfree(info);
  		return ret;
  	}
 +#endif
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ MODULE_DEVICE_TABLE(of, of_ipmi_match);
+ #else
+ #define of_ipmi_match NULL
+ static int of_ipmi_probe(struct platform_device *dev)
+ {
+ 	return -ENODEV;
+ }
+ #endif
+ 
+ #ifdef CONFIG_ACPI
+ static int acpi_ipmi_probe(struct platform_device *dev)
+ {
+ 	struct smi_info *info;
+ 	struct resource *res, *res_second;
+ 	acpi_handle handle;
+ 	acpi_status status;
+ 	unsigned long long tmp;
+ 	int rv = -EINVAL;
+ 
+ 	handle = ACPI_HANDLE(&dev->dev);
+ 	if (!handle)
+ 		return -ENODEV;
+ 
+ 	info = smi_info_alloc();
+ 	if (!info)
+ 		return -ENOMEM;
+ 
+ 	info->addr_source = SI_ACPI;
+ 	dev_info(&dev->dev, PFX "probing via ACPI\n");
+ 
+ 	info->addr_info.acpi_info.acpi_handle = handle;
+ 
+ 	/* _IFT tells us the interface type: KCS, BT, etc */
+ 	status = acpi_evaluate_integer(handle, "_IFT", NULL, &tmp);
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_err(&dev->dev, "Could not find ACPI IPMI interface type\n");
+ 		goto err_free;
+ 	}
+ 
+ 	switch (tmp) {
+ 	case 1:
+ 		info->si_type = SI_KCS;
+ 		break;
+ 	case 2:
+ 		info->si_type = SI_SMIC;
+ 		break;
+ 	case 3:
+ 		info->si_type = SI_BT;
+ 		break;
+ 	case 4: /* SSIF, just ignore */
+ 		rv = -ENODEV;
+ 		goto err_free;
+ 	default:
+ 		dev_info(&dev->dev, "unknown IPMI type %lld\n", tmp);
+ 		goto err_free;
+ 	}
+ 
+ 	res = platform_get_resource(dev, IORESOURCE_IO, 0);
+ 	if (res) {
+ 		info->io_setup = port_setup;
+ 		info->io.addr_type = IPMI_IO_ADDR_SPACE;
+ 	} else {
+ 		res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+ 		if (res) {
+ 			info->io_setup = mem_setup;
+ 			info->io.addr_type = IPMI_MEM_ADDR_SPACE;
+ 		}
+ 	}
+ 	if (!res) {
+ 		dev_err(&dev->dev, "no I/O or memory address\n");
+ 		goto err_free;
+ 	}
+ 	info->io.addr_data = res->start;
+ 
+ 	info->io.regspacing = DEFAULT_REGSPACING;
+ 	res_second = platform_get_resource(dev,
+ 			       (info->io.addr_type == IPMI_IO_ADDR_SPACE) ?
+ 					IORESOURCE_IO : IORESOURCE_MEM,
+ 			       1);
+ 	if (res_second) {
+ 		if (res_second->start > info->io.addr_data)
+ 			info->io.regspacing =
+ 				res_second->start - info->io.addr_data;
+ 	}
+ 	info->io.regsize = DEFAULT_REGSPACING;
+ 	info->io.regshift = 0;
+ 
+ 	/* If _GPE exists, use it; otherwise use standard interrupts */
+ 	status = acpi_evaluate_integer(handle, "_GPE", NULL, &tmp);
+ 	if (ACPI_SUCCESS(status)) {
+ 		info->irq = tmp;
+ 		info->irq_setup = acpi_gpe_irq_setup;
+ 	} else {
+ 		int irq = platform_get_irq(dev, 0);
+ 
+ 		if (irq > 0) {
+ 			info->irq = irq;
+ 			info->irq_setup = std_irq_setup;
+ 		}
+ 	}
+ 
+ 	info->dev = &dev->dev;
+ 	platform_set_drvdata(dev, info);
+ 
+ 	dev_info(info->dev, "%pR regsize %d spacing %d irq %d\n",
+ 		 res, info->io.regsize, info->io.regspacing,
+ 		 info->irq);
+ 
+ 	rv = add_smi(info);
+ 	if (rv)
+ 		kfree(info);
+ 
+ 	return rv;
+ 
+ err_free:
+ 	kfree(info);
+ 	return rv;
+ }
+ 
+ static const struct acpi_device_id acpi_ipmi_match[] = {
+ 	{ "IPI0001", 0 },
+ 	{ },
+ };
+ MODULE_DEVICE_TABLE(acpi, acpi_ipmi_match);
+ #else
+ static int acpi_ipmi_probe(struct platform_device *dev)
+ {
+ 	return -ENODEV;
+ }
+ #endif
+ 
+ static int ipmi_probe(struct platform_device *dev)
+ {
+ 	if (of_ipmi_probe(dev) == 0)
+ 		return 0;
+ 
+ 	return acpi_ipmi_probe(dev);
+ }
++>>>>>>> acbd9ae70a94 (ipmi: add of_device_id in MODULE_DEVICE_TABLE)
  
  static int ipmi_remove(struct platform_device *dev)
  {
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
