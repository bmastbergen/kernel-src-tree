libceph: change how osd_op_reply message size is calculated

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ilya Dryomov <idryomov@gmail.com>
commit 711da55d36a6f1eddcd340969be7223110d2f6b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/711da55d.failed

For a message pool message, preallocate a page, just like we do for
osd_op.  For a normal message, take ceph_object_id into account and
don't bother subtracting CEPH_OSD_SLAB_OPS ceph_osd_ops.

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 711da55d36a6f1eddcd340969be7223110d2f6b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ceph/osd_client.c
diff --cc net/ceph/osd_client.c
index f75717edb624,75e27bd3d372..000000000000
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@@ -428,30 -420,40 +427,44 @@@ struct ceph_osd_request *ceph_osdc_allo
  	msg_size += 4 + 4 + 4 + 8; /* mtime, reassert_version */
  	msg_size += 2 + 4 + 8 + 4 + 4; /* oloc */
  	msg_size += 1 + 8 + 4 + 4; /* pgid */
 -	msg_size += 4 + req->r_base_oid.name_len; /* oid */
 -	msg_size += 2 + req->r_num_ops * sizeof(struct ceph_osd_op);
 +	msg_size += 4 + CEPH_MAX_OID_NAME_LEN; /* oid */
 +	msg_size += 2 + num_ops * sizeof(struct ceph_osd_op);
  	msg_size += 8; /* snapid */
  	msg_size += 8; /* snap_seq */
 -	msg_size += 4 + 8 * (req->r_snapc ? req->r_snapc->num_snaps : 0);
 +	msg_size += 4 + 8 * (snapc ? snapc->num_snaps : 0); /* snaps */
  	msg_size += 4; /* retry_attempt */
  
 -	if (req->r_mempool)
 +	/* create request message; allow space for oid */
 +	if (use_mempool)
  		msg = ceph_msgpool_get(&osdc->msgpool_op, 0);
  	else
++<<<<<<< HEAD
 +		msg = ceph_msg_new(CEPH_MSG_OSD_OP, msg_size, gfp_flags, true);
 +	if (!msg) {
 +		ceph_osdc_put_request(req);
 +		return NULL;
 +	}
++=======
+ 		msg = ceph_msg_new(CEPH_MSG_OSD_OP, msg_size, gfp, true);
+ 	if (!msg)
+ 		return -ENOMEM;
+ 
+ 	memset(msg->front.iov_base, 0, msg->front.iov_len);
+ 	req->r_request = msg;
+ 
+ 	/* create reply message */
+ 	msg_size = OSD_OPREPLY_FRONT_LEN;
+ 	msg_size += req->r_base_oid.name_len;
+ 	msg_size += req->r_num_ops * sizeof(struct ceph_osd_op);
++>>>>>>> 711da55d36a6 (libceph: change how osd_op_reply message size is calculated)
  
 -	if (req->r_mempool)
 -		msg = ceph_msgpool_get(&osdc->msgpool_op_reply, 0);
 -	else
 -		msg = ceph_msg_new(CEPH_MSG_OSD_OPREPLY, msg_size, gfp, true);
 -	if (!msg)
 -		return -ENOMEM;
 +	memset(msg->front.iov_base, 0, msg->front.iov_len);
  
 -	req->r_reply = msg;
 +	req->r_request = msg;
  
 -	return 0;
 +	return req;
  }
 -EXPORT_SYMBOL(ceph_osdc_alloc_messages);
 +EXPORT_SYMBOL(ceph_osdc_alloc_request);
  
  static bool osd_req_opcode_valid(u16 opcode)
  {
* Unmerged path net/ceph/osd_client.c
