ipv6: tcp: add rcu locking in tcp_v6_send_synack()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 3e4006f0b86a5ae5eb0e8215f9a9e1db24506977
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3e4006f0.failed

When first SYNACK is sent, we already hold rcu_read_lock(), but this
is not true if a SYNACK is retransmitted, as a timer (soft) interrupt
does not hold rcu_read_lock()

Fixes: 45f6fad84cc30 ("ipv6: add complete rcu protection around np->opt")
	Reported-by: Dave Jones <davej@codemonkey.org.uk>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3e4006f0b86a5ae5eb0e8215f9a9e1db24506977)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/tcp_ipv6.c
diff --cc net/ipv6/tcp_ipv6.c
index 2ab7bcc949ac,bd100b47c717..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -496,8 -459,13 +496,18 @@@ static int tcp_v6_send_synack(struct so
  				    &ireq->ir_v6_rmt_addr);
  
  		fl6->daddr = ireq->ir_v6_rmt_addr;
++<<<<<<< HEAD
 +		skb_set_queue_mapping(skb, queue_mapping);
 +		err = ip6_xmit(sk, skb, fl6, np->opt, np->tclass);
++=======
+ 		if (np->repflow && ireq->pktopts)
+ 			fl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));
+ 
+ 		rcu_read_lock();
+ 		err = ip6_xmit(sk, skb, fl6, rcu_dereference(np->opt),
+ 			       np->tclass);
+ 		rcu_read_unlock();
++>>>>>>> 3e4006f0b86a (ipv6: tcp: add rcu locking in tcp_v6_send_synack())
  		err = net_xmit_eval(err);
  	}
  
* Unmerged path net/ipv6/tcp_ipv6.c
