perf mem: Introduce perf_mem_events__name function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 2ba7ac5814a6952aad647ce31696b893772cbe83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2ba7ac58.failed

Wrap perf_mem_events[].name into perf_mem_events__name() so we could alter the
events name if needed.

This will be handy when changing latency settings for loads event in following
patch.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Cc: Stephane Eranian <eranian@google.com>
Link: http://lkml.kernel.org/r/1456303616-26926-3-git-send-email-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 2ba7ac5814a6952aad647ce31696b893772cbe83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-mem.c
#	tools/perf/util/mem-events.c
#	tools/perf/util/mem-events.h
diff --cc tools/perf/builtin-mem.c
index 80170aace5d4,88aeac9aa1da..000000000000
--- a/tools/perf/builtin-mem.c
+++ b/tools/perf/builtin-mem.c
@@@ -21,6 -23,40 +21,43 @@@ struct perf_mem 
  	DECLARE_BITMAP(cpu_bitmap, MAX_NR_CPUS);
  };
  
++<<<<<<< HEAD
++=======
+ static int parse_record_events(const struct option *opt,
+ 			       const char *str, int unset __maybe_unused)
+ {
+ 	struct perf_mem *mem = *(struct perf_mem **)opt->value;
+ 	int j;
+ 
+ 	if (strcmp(str, "list")) {
+ 		if (!perf_mem_events__parse(str)) {
+ 			mem->operation = 0;
+ 			return 0;
+ 		}
+ 		exit(-1);
+ 	}
+ 
+ 	for (j = 0; j < PERF_MEM_EVENTS__MAX; j++) {
+ 		struct perf_mem_event *e = &perf_mem_events[j];
+ 
+ 		fprintf(stderr, "%-13s%-*s%s\n",
+ 			e->tag,
+ 			verbose ? 25 : 0,
+ 			verbose ? perf_mem_events__name(j) : "",
+ 			e->supported ? ": available" : "");
+ 	}
+ 	exit(0);
+ }
+ 
+ static const char * const __usage[] = {
+ 	"perf mem record [<options>] [<command>]",
+ 	"perf mem record [<options>] -- <command> [<options>]",
+ 	NULL
+ };
+ 
+ static const char * const *record_mem_usage = __usage;
+ 
++>>>>>>> 2ba7ac5814a6 (perf mem: Introduce perf_mem_events__name function)
  static int __cmd_record(int argc, const char **argv, struct perf_mem *mem)
  {
  	int rec_argc, i = 0, j;
@@@ -39,19 -89,33 +76,47 @@@
  
  	rec_argv[i++] = "-d";
  
++<<<<<<< HEAD
 +	if (mem->operation & MEM_OPERATION_LOAD) {
 +		rec_argv[i++] = "-e";
 +		rec_argv[i++] = "cpu/mem-loads/pp";
++=======
+ 	for (j = 0; j < PERF_MEM_EVENTS__MAX; j++) {
+ 		if (!perf_mem_events[j].record)
+ 			continue;
+ 
+ 		if (!perf_mem_events[j].supported) {
+ 			pr_err("failed: event '%s' not supported\n",
+ 			       perf_mem_events__name(j));
+ 			return -1;
+ 		}
+ 
+ 		rec_argv[i++] = "-e";
+ 		rec_argv[i++] = perf_mem_events__name(j);
+ 	};
+ 
+ 	for (j = 0; j < argc; j++, i++)
+ 		rec_argv[i] = argv[j];
+ 
+ 	if (verbose > 0) {
+ 		pr_debug("calling: record ");
+ 
+ 		while (rec_argv[j]) {
+ 			pr_debug("%s ", rec_argv[j]);
+ 			j++;
+ 		}
+ 		pr_debug("\n");
++>>>>>>> 2ba7ac5814a6 (perf mem: Introduce perf_mem_events__name function)
  	}
  
 +	if (mem->operation & MEM_OPERATION_STORE) {
 +		rec_argv[i++] = "-e";
 +		rec_argv[i++] = "cpu/mem-stores/pp";
 +	}
 +
 +	for (j = 1; j < argc; j++, i++)
 +		rec_argv[i] = argv[j];
 +
  	ret = cmd_record(i, rec_argv, NULL);
  	free(rec_argv);
  	return ret;
* Unmerged path tools/perf/util/mem-events.c
* Unmerged path tools/perf/util/mem-events.h
* Unmerged path tools/perf/builtin-mem.c
* Unmerged path tools/perf/util/mem-events.c
* Unmerged path tools/perf/util/mem-events.h
