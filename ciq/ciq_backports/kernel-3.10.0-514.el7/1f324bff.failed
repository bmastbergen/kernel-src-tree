net/mlx5_core: Implement modify HCA vport command

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [include] mlx5_core: Implement modify HCA vport command (kamal heib) [1275159 1296272 1296405 1298421 1298422 1298423 1298424 1298425]
Rebuild_FUZZ: 95.74%
commit-author Eli Cohen <eli@mellanox.com>
commit 1f324bff9ba3db276f074169d5b4af9e9c117ba1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1f324bff.failed

Implement the modify HCA vport commands used to modify the parameters of
virtual HCA's ports.

	Signed-off-by: Eli Cohen <eli@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 1f324bff9ba3db276f074169d5b4af9e9c117ba1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/vport.c
#	include/linux/mlx5/vport.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/vport.c
index 076197efea9b,bd518405859e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/vport.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/vport.c
@@@ -750,3 -809,152 +750,155 @@@ int mlx5_modify_nic_vport_promisc(struc
  	return err;
  }
  EXPORT_SYMBOL_GPL(mlx5_modify_nic_vport_promisc);
++<<<<<<< HEAD
++=======
+ 
+ enum mlx5_vport_roce_state {
+ 	MLX5_VPORT_ROCE_DISABLED = 0,
+ 	MLX5_VPORT_ROCE_ENABLED  = 1,
+ };
+ 
+ static int mlx5_nic_vport_update_roce_state(struct mlx5_core_dev *mdev,
+ 					    enum mlx5_vport_roce_state state)
+ {
+ 	void *in;
+ 	int inlen = MLX5_ST_SZ_BYTES(modify_nic_vport_context_in);
+ 	int err;
+ 
+ 	in = mlx5_vzalloc(inlen);
+ 	if (!in) {
+ 		mlx5_core_warn(mdev, "failed to allocate inbox\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	MLX5_SET(modify_nic_vport_context_in, in, field_select.roce_en, 1);
+ 	MLX5_SET(modify_nic_vport_context_in, in, nic_vport_context.roce_en,
+ 		 state);
+ 
+ 	err = mlx5_modify_nic_vport_context(mdev, in, inlen);
+ 
+ 	kvfree(in);
+ 
+ 	return err;
+ }
+ 
+ int mlx5_nic_vport_enable_roce(struct mlx5_core_dev *mdev)
+ {
+ 	return mlx5_nic_vport_update_roce_state(mdev, MLX5_VPORT_ROCE_ENABLED);
+ }
+ EXPORT_SYMBOL_GPL(mlx5_nic_vport_enable_roce);
+ 
+ int mlx5_nic_vport_disable_roce(struct mlx5_core_dev *mdev)
+ {
+ 	return mlx5_nic_vport_update_roce_state(mdev, MLX5_VPORT_ROCE_DISABLED);
+ }
+ EXPORT_SYMBOL_GPL(mlx5_nic_vport_disable_roce);
+ 
+ int mlx5_core_query_vport_counter(struct mlx5_core_dev *dev, u8 other_vport,
+ 				  int vf, u8 port_num, void *out,
+ 				  size_t out_sz)
+ {
+ 	int	in_sz = MLX5_ST_SZ_BYTES(query_vport_counter_in);
+ 	int	is_group_manager;
+ 	void   *in;
+ 	int	err;
+ 
+ 	is_group_manager = MLX5_CAP_GEN(dev, vport_group_manager);
+ 	in = mlx5_vzalloc(in_sz);
+ 	if (!in) {
+ 		err = -ENOMEM;
+ 		return err;
+ 	}
+ 
+ 	MLX5_SET(query_vport_counter_in, in, opcode,
+ 		 MLX5_CMD_OP_QUERY_VPORT_COUNTER);
+ 	if (other_vport) {
+ 		if (is_group_manager) {
+ 			MLX5_SET(query_vport_counter_in, in, other_vport, 1);
+ 			MLX5_SET(query_vport_counter_in, in, vport_number, vf + 1);
+ 		} else {
+ 			err = -EPERM;
+ 			goto free;
+ 		}
+ 	}
+ 	if (MLX5_CAP_GEN(dev, num_ports) == 2)
+ 		MLX5_SET(query_vport_counter_in, in, port_num, port_num);
+ 
+ 	err = mlx5_cmd_exec(dev, in, in_sz, out,  out_sz);
+ 	if (err)
+ 		goto free;
+ 	err = mlx5_cmd_status_to_err_v2(out);
+ 
+ free:
+ 	kvfree(in);
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(mlx5_core_query_vport_counter);
+ 
+ int mlx5_core_modify_hca_vport_context(struct mlx5_core_dev *dev,
+ 				       u8 other_vport, u8 port_num,
+ 				       int vf,
+ 				       struct mlx5_hca_vport_context *req)
+ {
+ 	int in_sz = MLX5_ST_SZ_BYTES(modify_hca_vport_context_in);
+ 	u8 out[MLX5_ST_SZ_BYTES(modify_hca_vport_context_out)];
+ 	int is_group_manager;
+ 	void *in;
+ 	int err;
+ 	void *ctx;
+ 
+ 	mlx5_core_dbg(dev, "vf %d\n", vf);
+ 	is_group_manager = MLX5_CAP_GEN(dev, vport_group_manager);
+ 	in = kzalloc(in_sz, GFP_KERNEL);
+ 	if (!in)
+ 		return -ENOMEM;
+ 
+ 	memset(out, 0, sizeof(out));
+ 	MLX5_SET(modify_hca_vport_context_in, in, opcode, MLX5_CMD_OP_MODIFY_HCA_VPORT_CONTEXT);
+ 	if (other_vport) {
+ 		if (is_group_manager) {
+ 			MLX5_SET(modify_hca_vport_context_in, in, other_vport, 1);
+ 			MLX5_SET(modify_hca_vport_context_in, in, vport_number, vf);
+ 		} else {
+ 			err = -EPERM;
+ 			goto ex;
+ 		}
+ 	}
+ 
+ 	if (MLX5_CAP_GEN(dev, num_ports) > 1)
+ 		MLX5_SET(modify_hca_vport_context_in, in, port_num, port_num);
+ 
+ 	ctx = MLX5_ADDR_OF(modify_hca_vport_context_in, in, hca_vport_context);
+ 	MLX5_SET(hca_vport_context, ctx, field_select, req->field_select);
+ 	MLX5_SET(hca_vport_context, ctx, sm_virt_aware, req->sm_virt_aware);
+ 	MLX5_SET(hca_vport_context, ctx, has_smi, req->has_smi);
+ 	MLX5_SET(hca_vport_context, ctx, has_raw, req->has_raw);
+ 	MLX5_SET(hca_vport_context, ctx, vport_state_policy, req->policy);
+ 	MLX5_SET(hca_vport_context, ctx, port_physical_state, req->phys_state);
+ 	MLX5_SET(hca_vport_context, ctx, vport_state, req->vport_state);
+ 	MLX5_SET64(hca_vport_context, ctx, port_guid, req->port_guid);
+ 	MLX5_SET64(hca_vport_context, ctx, node_guid, req->node_guid);
+ 	MLX5_SET(hca_vport_context, ctx, cap_mask1, req->cap_mask1);
+ 	MLX5_SET(hca_vport_context, ctx, cap_mask1_field_select, req->cap_mask1_perm);
+ 	MLX5_SET(hca_vport_context, ctx, cap_mask2, req->cap_mask2);
+ 	MLX5_SET(hca_vport_context, ctx, cap_mask2_field_select, req->cap_mask2_perm);
+ 	MLX5_SET(hca_vport_context, ctx, lid, req->lid);
+ 	MLX5_SET(hca_vport_context, ctx, init_type_reply, req->init_type_reply);
+ 	MLX5_SET(hca_vport_context, ctx, lmc, req->lmc);
+ 	MLX5_SET(hca_vport_context, ctx, subnet_timeout, req->subnet_timeout);
+ 	MLX5_SET(hca_vport_context, ctx, sm_lid, req->sm_lid);
+ 	MLX5_SET(hca_vport_context, ctx, sm_sl, req->sm_sl);
+ 	MLX5_SET(hca_vport_context, ctx, qkey_violation_counter, req->qkey_violation_counter);
+ 	MLX5_SET(hca_vport_context, ctx, pkey_violation_counter, req->pkey_violation_counter);
+ 	err = mlx5_cmd_exec(dev, in, in_sz, out, sizeof(out));
+ 	if (err)
+ 		goto ex;
+ 
+ 	err = mlx5_cmd_status_to_err_v2(out);
+ 
+ ex:
+ 	kfree(in);
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(mlx5_core_modify_hca_vport_context);
++>>>>>>> 1f324bff9ba3 (net/mlx5_core: Implement modify HCA vport command)
diff --cc include/linux/mlx5/vport.h
index 638f2ca7a527,bd93e6323603..000000000000
--- a/include/linux/mlx5/vport.h
+++ b/include/linux/mlx5/vport.h
@@@ -85,4 -90,14 +85,17 @@@ int mlx5_modify_nic_vport_vlans(struct 
  				u16 vlans[],
  				int list_size);
  
++<<<<<<< HEAD
++=======
+ int mlx5_nic_vport_enable_roce(struct mlx5_core_dev *mdev);
+ int mlx5_nic_vport_disable_roce(struct mlx5_core_dev *mdev);
+ int mlx5_core_query_vport_counter(struct mlx5_core_dev *dev, u8 other_vport,
+ 				  int vf, u8 port_num, void *out,
+ 				  size_t out_sz);
+ int mlx5_core_modify_hca_vport_context(struct mlx5_core_dev *dev,
+ 				       u8 other_vport, u8 port_num,
+ 				       int vf,
+ 				       struct mlx5_hca_vport_context *req);
+ 
++>>>>>>> 1f324bff9ba3 (net/mlx5_core: Implement modify HCA vport command)
  #endif /* __MLX5_VPORT_H__ */
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
index 52741743c8fd..2a3d021a8320 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
@@ -408,6 +408,12 @@ static int mlx5_internal_err_ret_value(struct mlx5_core_dev *dev, u16 op,
 const char *mlx5_command_str(int command)
 {
 	switch (command) {
+	case MLX5_CMD_OP_QUERY_HCA_VPORT_CONTEXT:
+		return "QUERY_HCA_VPORT_CONTEXT";
+
+	case MLX5_CMD_OP_MODIFY_HCA_VPORT_CONTEXT:
+		return "MODIFY_HCA_VPORT_CONTEXT";
+
 	case MLX5_CMD_OP_QUERY_HCA_CAP:
 		return "QUERY_HCA_CAP";
 
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/vport.c
* Unmerged path include/linux/mlx5/vport.h
