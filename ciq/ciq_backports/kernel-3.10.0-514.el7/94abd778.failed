brcmfmac: add fallback for devices that do not report per-chain values

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jaap Jan Meijer <jjmeijer88@gmail.com>
commit 94abd778a7bb00ed5d00f56d9fbfcbf5b7c02a5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/94abd778.failed

If brcmf_cfg80211_get_station fails to determine the RSSI from the
per-chain values get the value individually as a fallback.

Fixes: 1f0dc59a6de9 ("brcmfmac: rework .get_station() callback")
	Signed-off-by: Jaap Jan Meijer <jjmeijer88@gmail.com>
	Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
	Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
(cherry picked from commit 94abd778a7bb00ed5d00f56d9fbfcbf5b7c02a5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c
diff --cc drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c
index 8a15ebbce4a3,62f475e31077..000000000000
--- a/drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c
+++ b/drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c
@@@ -2369,15 -2540,15 +2369,28 @@@ brcmf_cfg80211_get_station(struct wiph
  			   const u8 *mac, struct station_info *sinfo)
  {
  	struct brcmf_if *ifp = netdev_priv(ndev);
++<<<<<<< HEAD:drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c
 +	struct brcmf_cfg80211_profile *profile = &ifp->vif->profile;
 +	struct brcmf_scb_val_le scb_val;
 +	int rssi;
 +	s32 rate;
++=======
+ 	struct brcmf_scb_val_le scb_val;
++>>>>>>> 94abd778a7bb (brcmfmac: add fallback for devices that do not report per-chain values):drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
  	s32 err = 0;
 +	u8 *bssid = profile->bssid;
  	struct brcmf_sta_info_le sta_info_le;
++<<<<<<< HEAD:drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c
 +	u32 beacon_period;
 +	u32 dtim_period;
++=======
+ 	u32 sta_flags;
+ 	u32 is_tdls_peer;
+ 	s32 total_rssi;
+ 	s32 count_rssi;
+ 	int rssi;
+ 	u32 i;
++>>>>>>> 94abd778a7bb (brcmfmac: add fallback for devices that do not report per-chain values):drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
  
  	brcmf_dbg(TRACE, "Enter, MAC %pM\n", mac);
  	if (!check_vif_up(ifp->vif))
@@@ -2392,34 -2571,68 +2405,42 @@@
  			brcmf_err("GET STA INFO failed, %d\n", err);
  			goto done;
  		}
 -	}
 -	brcmf_dbg(TRACE, "version %d\n", le16_to_cpu(sta_info_le.ver));
 -	sinfo->filled = BIT(NL80211_STA_INFO_INACTIVE_TIME);
 -	sinfo->inactive_time = le32_to_cpu(sta_info_le.idle) * 1000;
 -	sta_flags = le32_to_cpu(sta_info_le.flags);
 -	brcmf_convert_sta_flags(sta_flags, sinfo);
 -	sinfo->sta_flags.mask |= BIT(NL80211_STA_FLAG_TDLS_PEER);
 -	if (is_tdls_peer)
 -		sinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_TDLS_PEER);
 -	else
 -		sinfo->sta_flags.set &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);
 -	if (sta_flags & BRCMF_STA_ASSOC) {
 -		sinfo->filled |= BIT(NL80211_STA_INFO_CONNECTED_TIME);
 -		sinfo->connected_time = le32_to_cpu(sta_info_le.in);
 -		brcmf_fill_bss_param(ifp, sinfo);
 -	}
 -	if (sta_flags & BRCMF_STA_SCBSTATS) {
 -		sinfo->filled |= BIT(NL80211_STA_INFO_TX_FAILED);
 -		sinfo->tx_failed = le32_to_cpu(sta_info_le.tx_failures);
 -		sinfo->filled |= BIT(NL80211_STA_INFO_TX_PACKETS);
 -		sinfo->tx_packets = le32_to_cpu(sta_info_le.tx_pkts);
 -		sinfo->tx_packets += le32_to_cpu(sta_info_le.tx_mcast_pkts);
 -		sinfo->filled |= BIT(NL80211_STA_INFO_RX_PACKETS);
 -		sinfo->rx_packets = le32_to_cpu(sta_info_le.rx_ucast_pkts);
 -		sinfo->rx_packets += le32_to_cpu(sta_info_le.rx_mcast_pkts);
 -		if (sinfo->tx_packets) {
 -			sinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);
 -			sinfo->txrate.legacy =
 -				le32_to_cpu(sta_info_le.tx_rate) / 100;
 -		}
 -		if (sinfo->rx_packets) {
 -			sinfo->filled |= BIT(NL80211_STA_INFO_RX_BITRATE);
 -			sinfo->rxrate.legacy =
 -				le32_to_cpu(sta_info_le.rx_rate) / 100;
 +		sinfo->filled = BIT(NL80211_STA_INFO_INACTIVE_TIME);
 +		sinfo->inactive_time = le32_to_cpu(sta_info_le.idle) * 1000;
 +		if (le32_to_cpu(sta_info_le.flags) & BRCMF_STA_ASSOC) {
 +			sinfo->filled |= BIT(NL80211_STA_INFO_CONNECTED_TIME);
 +			sinfo->connected_time = le32_to_cpu(sta_info_le.in);
  		}
 -		if (le16_to_cpu(sta_info_le.ver) >= 4) {
 -			sinfo->filled |= BIT(NL80211_STA_INFO_TX_BYTES);
 -			sinfo->tx_bytes = le64_to_cpu(sta_info_le.tx_tot_bytes);
 -			sinfo->filled |= BIT(NL80211_STA_INFO_RX_BYTES);
 -			sinfo->rx_bytes = le64_to_cpu(sta_info_le.rx_tot_bytes);
 +		brcmf_dbg(TRACE, "STA idle time : %d ms, connected time :%d sec\n",
 +			  sinfo->inactive_time, sinfo->connected_time);
 +	} else if (ifp->vif->wdev.iftype == NL80211_IFTYPE_STATION) {
 +		if (memcmp(mac, bssid, ETH_ALEN)) {
 +			brcmf_err("Wrong Mac address cfg_mac-%pM wl_bssid-%pM\n",
 +				  mac, bssid);
 +			err = -ENOENT;
 +			goto done;
  		}
 -		total_rssi = 0;
 -		count_rssi = 0;
 -		for (i = 0; i < BRCMF_ANT_MAX; i++) {
 -			if (sta_info_le.rssi[i]) {
 -				sinfo->chain_signal_avg[count_rssi] =
 -					sta_info_le.rssi[i];
 -				sinfo->chain_signal[count_rssi] =
 -					sta_info_le.rssi[i];
 -				total_rssi += sta_info_le.rssi[i];
 -				count_rssi++;
 -			}
 +		/* Report the current tx rate */
 +		err = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_RATE, &rate);
 +		if (err) {
 +			brcmf_err("Could not get rate (%d)\n", err);
 +			goto done;
 +		} else {
 +			sinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);
 +			sinfo->txrate.legacy = rate * 5;
 +			brcmf_dbg(CONN, "Rate %d Mbps\n", rate / 2);
  		}
 -		if (count_rssi) {
 -			sinfo->filled |= BIT(NL80211_STA_INFO_CHAIN_SIGNAL);
 -			sinfo->chains = count_rssi;
  
++<<<<<<< HEAD:drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c
 +		if (test_bit(BRCMF_VIF_STATUS_CONNECTED,
 +			     &ifp->vif->sme_state)) {
++=======
+ 			sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);
+ 			total_rssi /= count_rssi;
+ 			sinfo->signal = total_rssi;
+ 		} else if (test_bit(BRCMF_VIF_STATUS_CONNECTED,
+ 			&ifp->vif->sme_state)) {
++>>>>>>> 94abd778a7bb (brcmfmac: add fallback for devices that do not report per-chain values):drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
  			memset(&scb_val, 0, sizeof(scb_val));
  			err = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_RSSI,
  						     &scb_val, sizeof(scb_val));
@@@ -2432,33 -2645,8 +2453,36 @@@
  				sinfo->signal = rssi;
  				brcmf_dbg(CONN, "RSSI %d dBm\n", rssi);
  			}
++<<<<<<< HEAD:drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c
 +			err = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_BCNPRD,
 +						    &beacon_period);
 +			if (err) {
 +				brcmf_err("Could not get beacon period (%d)\n",
 +					  err);
 +				goto done;
 +			} else {
 +				sinfo->bss_param.beacon_interval =
 +					beacon_period;
 +				brcmf_dbg(CONN, "Beacon peroid %d\n",
 +					  beacon_period);
 +			}
 +			err = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_DTIMPRD,
 +						    &dtim_period);
 +			if (err) {
 +				brcmf_err("Could not get DTIM period (%d)\n",
 +					  err);
 +				goto done;
 +			} else {
 +				sinfo->bss_param.dtim_period = dtim_period;
 +				brcmf_dbg(CONN, "DTIM peroid %d\n",
 +					  dtim_period);
 +			}
 +			sinfo->filled |= BIT(NL80211_STA_INFO_BSS_PARAM);
++=======
++>>>>>>> 94abd778a7bb (brcmfmac: add fallback for devices that do not report per-chain values):drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
  		}
 -	}
 +	} else
 +		err = -EPERM;
  done:
  	brcmf_dbg(TRACE, "Exit\n");
  	return err;
* Unmerged path drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c
