ipv6: Add rt6_get_cookie() function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit b197df4f0f3782782e9ea8996e91b65ae33e8dd9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b197df4f.failed

Instead of doing the rt6->rt6i_node check whenever we need
to get the route's cookie.  Refactor it into rt6_get_cookie().
It is a prep work to handle FLOWI_FLAG_KNOWN_NH and also
percpu rt6_info later.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Cc: Steffen Klassert <steffen.klassert@secunet.com>
	Cc: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b197df4f0f3782782e9ea8996e91b65ae33e8dd9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip6_fib.h
#	net/ipv6/xfrm6_policy.c
#	net/sctp/ipv6.c
diff --cc include/net/ip6_fib.h
index d152e230d58f,a4bece6797da..000000000000
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@@ -165,13 -159,9 +165,19 @@@ static inline void rt6_update_expires(s
  	rt0->rt6i_flags |= RTF_EXPIRES;
  }
  
++<<<<<<< HEAD
 +static inline void rt6_set_from(struct rt6_info *rt, struct rt6_info *from)
 +{
 +	struct dst_entry *new = (struct dst_entry *) from;
 +
 +	rt->rt6i_flags &= ~RTF_EXPIRES;
 +	dst_hold(new);
 +	rt->dst.from = new;
++=======
+ static inline u32 rt6_get_cookie(const struct rt6_info *rt)
+ {
+ 	return rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;
++>>>>>>> b197df4f0f37 (ipv6: Add rt6_get_cookie() function)
  }
  
  static inline void ip6_rt_put(struct rt6_info *rt)
diff --cc net/ipv6/xfrm6_policy.c
index 0e59cb802ba9,ed0583c1b9fc..000000000000
--- a/net/ipv6/xfrm6_policy.c
+++ b/net/ipv6/xfrm6_policy.c
@@@ -75,9 -75,8 +75,14 @@@ static int xfrm6_init_path(struct xfrm_
  			   int nfheader_len)
  {
  	if (dst->ops->family == AF_INET6) {
++<<<<<<< HEAD
 +		struct rt6_info *rt = (struct rt6_info*)dst;
 +		if (rt->rt6i_node)
 +			path->path_cookie = rt->rt6i_node->fn_sernum;
++=======
+ 		struct rt6_info *rt = (struct rt6_info *)dst;
+ 		path->path_cookie = rt6_get_cookie(rt);
++>>>>>>> b197df4f0f37 (ipv6: Add rt6_get_cookie() function)
  	}
  
  	path->u.rt6.rt6i_nfheader_len = nfheader_len;
diff --cc net/sctp/ipv6.c
index 09aaba531950,e917d27328ea..000000000000
--- a/net/sctp/ipv6.c
+++ b/net/sctp/ipv6.c
@@@ -339,13 -328,17 +339,20 @@@ static void sctp_v6_get_dst(struct sctp
  out:
  	if (!IS_ERR_OR_NULL(dst)) {
  		struct rt6_info *rt;
 -
  		rt = (struct rt6_info *)dst;
  		t->dst = dst;
++<<<<<<< HEAD
 +		SCTP_DEBUG_PRINTK("rt6_dst:%pI6 rt6_src:%pI6\n",
 +			&rt->rt6i_dst.addr, &fl6->saddr);
++=======
+ 		t->dst_cookie = rt6_get_cookie(rt);
+ 		pr_debug("rt6_dst:%pI6/%d rt6_src:%pI6\n",
+ 			 &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
+ 			 &fl6->saddr);
++>>>>>>> b197df4f0f37 (ipv6: Add rt6_get_cookie() function)
  	} else {
  		t->dst = NULL;
 -
 -		pr_debug("no route\n");
 +		SCTP_DEBUG_PRINTK("NO ROUTE\n");
  	}
  }
  
* Unmerged path include/net/ip6_fib.h
diff --git a/include/net/ip6_route.h b/include/net/ip6_route.h
index c2439795bc4f..facd343e96cf 100644
--- a/include/net/ip6_route.h
+++ b/include/net/ip6_route.h
@@ -166,7 +166,7 @@ static inline void __ip6_dst_store(struct sock *sk, struct dst_entry *dst,
 #ifdef CONFIG_IPV6_SUBTREES
 	np->saddr_cache = saddr;
 #endif
-	np->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;
+	np->dst_cookie = rt6_get_cookie(rt);
 }
 
 static inline void ip6_dst_store(struct sock *sk, struct dst_entry *dst,
diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c
index 8e14859920f1..cc3247b77584 100644
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@ -153,7 +153,7 @@ EXPORT_SYMBOL_GPL(ip6_tnl_dst_reset);
 void ip6_tnl_dst_store(struct ip6_tnl *t, struct dst_entry *dst)
 {
 	struct rt6_info *rt = (struct rt6_info *) dst;
-	t->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;
+	t->dst_cookie = rt6_get_cookie(rt);
 	dst_release(t->dst_cache);
 	t->dst_cache = dst;
 }
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index b1e56e7b4f4f..b700ed8de820 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -98,8 +98,7 @@ static void inet6_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb)
 
 		sk->sk_rx_dst = dst;
 		inet_sk(sk)->rx_dst_ifindex = skb->skb_iif;
-		if (rt->rt6i_node)
-			inet6_sk(sk)->rx_dst_cookie = rt->rt6i_node->fn_sernum;
+		inet6_sk(sk)->rx_dst_cookie = rt6_get_cookie(rt);
 	}
 }
 
* Unmerged path net/ipv6/xfrm6_policy.c
diff --git a/net/netfilter/ipvs/ip_vs_xmit.c b/net/netfilter/ipvs/ip_vs_xmit.c
index 033f02180460..ea04b1b5495e 100644
--- a/net/netfilter/ipvs/ip_vs_xmit.c
+++ b/net/netfilter/ipvs/ip_vs_xmit.c
@@ -374,7 +374,7 @@ __ip_vs_get_out_rt_v6(struct sk_buff *skb, struct ip_vs_dest *dest,
 				goto err_unreach;
 			}
 			rt = (struct rt6_info *) dst;
-			cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;
+			cookie = rt6_get_cookie(rt);
 			__ip_vs_dst_set(dest, dest_dst, &rt->dst, cookie);
 			spin_unlock_bh(&dest->dst_lock);
 			IP_VS_DBG(10, "new dst %pI6, src %pI6, refcnt=%d\n",
* Unmerged path net/sctp/ipv6.c
