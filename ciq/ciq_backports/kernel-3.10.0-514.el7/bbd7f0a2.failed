mmc: sdhci-spear: Simplify by adding build dependency to CONFIG_OF

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] sdhci-spear: Simplify by adding build dependency to CONFIG_OF (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 96.06%
commit-author Ulf Hansson <ulf.hansson@linaro.org>
commit bbd7f0a20f76d079199d6d749cb3da07d345bae3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bbd7f0a2.failed

This driver is used on SoCs which are using CONFIG_OF. By adding a
compile dependency in the Kconfig, it enables us to simplify some code.

	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit bbd7f0a20f76d079199d6d749cb3da07d345bae3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci-spear.c
diff --cc drivers/mmc/host/sdhci-spear.c
index 2151911b43ec,f482f7f677e5..000000000000
--- a/drivers/mmc/host/sdhci-spear.c
+++ b/drivers/mmc/host/sdhci-spear.c
@@@ -37,32 -38,12 +37,35 @@@ struct spear_sdhci 
  
  /* sdhci ops */
  static const struct sdhci_ops sdhci_pltfm_ops = {
 -	.set_clock = sdhci_set_clock,
 -	.set_bus_width = sdhci_set_bus_width,
 -	.reset = sdhci_reset,
 -	.set_uhs_signaling = sdhci_set_uhs_signaling,
 +	/* Nothing to do for now. */
  };
  
++<<<<<<< HEAD
 +/* gpio card detection interrupt handler */
 +static irqreturn_t sdhci_gpio_irq(int irq, void *dev_id)
 +{
 +	struct platform_device *pdev = dev_id;
 +	struct sdhci_host *host = platform_get_drvdata(pdev);
 +	struct spear_sdhci *sdhci = dev_get_platdata(&pdev->dev);
 +	unsigned long gpio_irq_type;
 +	int val;
 +
 +	val = gpio_get_value(sdhci->data->card_int_gpio);
 +
 +	/* val == 1 -> card removed, val == 0 -> card inserted */
 +	/* if card removed - set irq for low level, else vice versa */
 +	gpio_irq_type = val ? IRQF_TRIGGER_LOW : IRQF_TRIGGER_HIGH;
 +	irq_set_irq_type(irq, gpio_irq_type);
 +
 +	/* inform sdhci driver about card insertion/removal */
 +	tasklet_schedule(&host->card_tasklet);
 +
 +	return IRQ_HANDLED;
 +}
 +
 +#ifdef CONFIG_OF
++=======
++>>>>>>> bbd7f0a20f76 (mmc: sdhci-spear: Simplify by adding build dependency to CONFIG_OF)
  static struct sdhci_plat_data *sdhci_probe_config_dt(struct platform_device *pdev)
  {
  	struct device_node *np = pdev->dev.of_node;
@@@ -76,22 -57,14 +79,16 @@@
  	/* If pdata is required */
  	if (cd_gpio != -1) {
  		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 -		if (!pdata)
 +		if (!pdata) {
  			dev_err(&pdev->dev, "DT: kzalloc failed\n");
 -		else
 -			pdata->card_int_gpio = cd_gpio;
 +			return ERR_PTR(-ENOMEM);
 +		}
  	}
  
 +	pdata->card_int_gpio = cd_gpio;
 +
  	return pdata;
  }
- #else
- static struct sdhci_plat_data *sdhci_probe_config_dt(struct platform_device *pdev)
- {
- 	return ERR_PTR(-ENOSYS);
- }
- #endif
  
  static int sdhci_probe(struct platform_device *pdev)
  {
@@@ -141,40 -116,26 +137,47 @@@
  		dev_dbg(&pdev->dev, "Error setting desired clk, clk=%lu\n",
  				clk_get_rate(sdhci->clk));
  
++<<<<<<< HEAD
 +	if (np) {
 +		sdhci->data = sdhci_probe_config_dt(pdev);
 +		if (IS_ERR(sdhci->data)) {
 +			dev_err(&pdev->dev, "DT: Failed to get pdata\n");
 +			return -ENODEV;
 +		}
 +	} else {
 +		sdhci->data = dev_get_platdata(&pdev->dev);
++=======
+ 	sdhci->data = sdhci_probe_config_dt(pdev);
+ 	if (IS_ERR(sdhci->data)) {
+ 		dev_err(&pdev->dev, "DT: Failed to get pdata\n");
+ 		goto disable_clk;
++>>>>>>> bbd7f0a20f76 (mmc: sdhci-spear: Simplify by adding build dependency to CONFIG_OF)
  	}
  
 -	/*
 -	 * It is optional to use GPIOs for sdhci card detection. If
 -	 * sdhci->data is NULL, then use original sdhci lines otherwise
 -	 * GPIO lines. We use the built-in GPIO support for this.
 -	 */
 -	if (sdhci->data && sdhci->data->card_int_gpio >= 0) {
 -		ret = mmc_gpio_request_cd(host->mmc,
 -					  sdhci->data->card_int_gpio, 0);
 -		if (ret < 0) {
 -			dev_dbg(&pdev->dev,
 -				"failed to request card-detect gpio%d\n",
 -				sdhci->data->card_int_gpio);
 -			goto disable_clk;
 -		}
 +	pdev->dev.platform_data = sdhci;
 +
 +	if (pdev->dev.parent)
 +		host = sdhci_alloc_host(pdev->dev.parent, 0);
 +	else
 +		host = sdhci_alloc_host(&pdev->dev, 0);
 +
 +	if (IS_ERR(host)) {
 +		ret = PTR_ERR(host);
 +		dev_dbg(&pdev->dev, "error allocating host\n");
 +		goto disable_clk;
 +	}
 +
 +	host->hw_name = "sdhci";
 +	host->ops = &sdhci_pltfm_ops;
 +	host->irq = platform_get_irq(pdev, 0);
 +	host->quirks = SDHCI_QUIRK_BROKEN_ADMA;
 +
 +	host->ioaddr = devm_ioremap(&pdev->dev, iomem->start,
 +			resource_size(iomem));
 +	if (!host->ioaddr) {
 +		ret = -ENOMEM;
 +		dev_dbg(&pdev->dev, "failed to remap registers\n");
 +		goto free_host;
  	}
  
  	ret = sdhci_add_host(host);
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 17adfe67817a..0a960c2d1c35 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -232,6 +232,7 @@ config MMC_SDHCI_PXAV2
 config MMC_SDHCI_SPEAR
 	tristate "SDHCI support on ST SPEAr platform"
 	depends on MMC_SDHCI && PLAT_SPEAR
+	depends on OF
 	help
 	  This selects the Secure Digital Host Controller Interface (SDHCI)
 	  often referrered to as the HSMMC block in some of the ST SPEAR range
* Unmerged path drivers/mmc/host/sdhci-spear.c
