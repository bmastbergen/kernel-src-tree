hpsa: fix multiple issues in path_info_show

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Rasmus Villemoes <linux@rasmusvillemoes.dk>
commit 1faf072c0e3ab0bc41fc1d343883dac704b82946
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1faf072c.failed

path_info_show() seems to be broken in multiple ways.

First, there's

  817 return snprintf(buf, output_len+1, "%s%s%s%s%s%s%s%s",
  818       path[0], path[1], path[2], path[3],
  819       path[4], path[5], path[6], path[7]);

so hopefully output_len contains the combined length of the eight
strings. Otherwise, snprintf will stop copying to the output
buffer, but still end up reporting that combined length - which
in turn would result in user-space getting a bunch of useless nul
bytes (thankfully the upper sysfs layer seems to clear the output
buffer before passing it to the various ->show routines). But we have

  767      output_len = snprintf(path[i],
  768                       PATH_STRING_LEN, "[%d:%d:%d:%d] %20.20s ",
  769                       h->scsi_host->host_no,
  770                       hdev->bus, hdev->target, hdev->lun,
  771                       scsi_device_type(hdev->devtype));

so output_len at best contains the length of the last string printed.

Inside the loop, we then otherwise add to output_len. By magic,
we still have PATH_STRING_LEN available every time... This
wouldn't really be a problem if the bean-counting has been done
properly and each line actually does fit in 50 bytes, and maybe
it does, but I don't immediately see why. Suppose we end up
taking this branch:

  802                  output_len += snprintf(path[i] + output_len,
  803                          PATH_STRING_LEN,
  804                          "BOX: %hhu BAY: %hhu %s\n",
  805                          box, bay, active);

An optimistic estimate says this uses strlen("BOX: 1 BAY: 2
Active\n") which is 21. Now add the 20 bytes guaranteed by the
%20.20s and then some for the rest of that format string, and
we're easily over 50 bytes. I don't think we can get over 100
bytes even being pessimistic, so this just means we'll scribble
into the next path[i+1] and maybe get that overwritten later,
leading to some garbled output (in fact, since we'd overwrite the
previous string's 0-terminator, we could end up with one very
long string and then print various suffixes of that, leading to
much more than 400 bytes of output). Except of course when we're
filling path[7], where overrunning it means writing random stuff
to the kernel stack, which is usually a lot of fun.

We can fix all of that and get rid of the 400 byte stack buffer by
simply writing directly to the given output buffer, which the upper
layer guarantees is at least PAGE_SIZE. s[c]nprintf doesn't care where
it is writing to, so this doesn't make the spin lock hold time any
longer. Using scnprintf ensures that output_len always represents the
number of bytes actually written to the buffer, so we'll report the
proper amount to the upper layer.

	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Reviewed-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
	Signed-off-by: Don Brace <don.brace@pmcs.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 1faf072c0e3ab0bc41fc1d343883dac704b82946)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.c
diff --cc drivers/scsi/hpsa.c
index 68754355feaa,910b2d1513c0..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -733,6 -733,95 +733,98 @@@ static ssize_t host_show_hp_ssd_smart_p
  	return snprintf(buf, 20, "%d\n", offload_enabled);
  }
  
++<<<<<<< HEAD
++=======
+ #define MAX_PATHS 8
+ 
+ static ssize_t path_info_show(struct device *dev,
+ 	     struct device_attribute *attr, char *buf)
+ {
+ 	struct ctlr_info *h;
+ 	struct scsi_device *sdev;
+ 	struct hpsa_scsi_dev_t *hdev;
+ 	unsigned long flags;
+ 	int i;
+ 	int output_len = 0;
+ 	u8 box;
+ 	u8 bay;
+ 	u8 path_map_index = 0;
+ 	char *active;
+ 	unsigned char phys_connector[2];
+ 
+ 	sdev = to_scsi_device(dev);
+ 	h = sdev_to_hba(sdev);
+ 	spin_lock_irqsave(&h->devlock, flags);
+ 	hdev = sdev->hostdata;
+ 	if (!hdev) {
+ 		spin_unlock_irqrestore(&h->devlock, flags);
+ 		return -ENODEV;
+ 	}
+ 
+ 	bay = hdev->bay;
+ 	for (i = 0; i < MAX_PATHS; i++) {
+ 		path_map_index = 1<<i;
+ 		if (i == hdev->active_path_index)
+ 			active = "Active";
+ 		else if (hdev->path_map & path_map_index)
+ 			active = "Inactive";
+ 		else
+ 			continue;
+ 
+ 		output_len += scnprintf(buf + output_len,
+ 				PAGE_SIZE - output_len,
+ 				"[%d:%d:%d:%d] %20.20s ",
+ 				h->scsi_host->host_no,
+ 				hdev->bus, hdev->target, hdev->lun,
+ 				scsi_device_type(hdev->devtype));
+ 
+ 		if (hdev->external ||
+ 			hdev->devtype == TYPE_RAID ||
+ 			is_logical_device(hdev)) {
+ 			output_len += snprintf(buf + output_len,
+ 						PAGE_SIZE - output_len,
+ 						"%s\n", active);
+ 			continue;
+ 		}
+ 
+ 		box = hdev->box[i];
+ 		memcpy(&phys_connector, &hdev->phys_connector[i],
+ 			sizeof(phys_connector));
+ 		if (phys_connector[0] < '0')
+ 			phys_connector[0] = '0';
+ 		if (phys_connector[1] < '0')
+ 			phys_connector[1] = '0';
+ 		if (hdev->phys_connector[i] > 0)
+ 			output_len += snprintf(buf + output_len,
+ 				PAGE_SIZE - output_len,
+ 				"PORT: %.2s ",
+ 				phys_connector);
+ 		if (hdev->devtype == TYPE_DISK && hdev->expose_device) {
+ 			if (box == 0 || box == 0xFF) {
+ 				output_len += snprintf(buf + output_len,
+ 					PAGE_SIZE - output_len,
+ 					"BAY: %hhu %s\n",
+ 					bay, active);
+ 			} else {
+ 				output_len += snprintf(buf + output_len,
+ 					PAGE_SIZE - output_len,
+ 					"BOX: %hhu BAY: %hhu %s\n",
+ 					box, bay, active);
+ 			}
+ 		} else if (box != 0 && box != 0xFF) {
+ 			output_len += snprintf(buf + output_len,
+ 				PAGE_SIZE - output_len, "BOX: %hhu %s\n",
+ 				box, active);
+ 		} else
+ 			output_len += snprintf(buf + output_len,
+ 				PAGE_SIZE - output_len, "%s\n", active);
+ 	}
+ 
+ 	spin_unlock_irqrestore(&h->devlock, flags);
+ 	return output_len;
+ }
+ 
++>>>>>>> 1faf072c0e3a (hpsa: fix multiple issues in path_info_show)
  static DEVICE_ATTR(raid_level, S_IRUGO, raid_level_show, NULL);
  static DEVICE_ATTR(lunid, S_IRUGO, lunid_show, NULL);
  static DEVICE_ATTR(unique_id, S_IRUGO, unique_id_show, NULL);
* Unmerged path drivers/scsi/hpsa.c
