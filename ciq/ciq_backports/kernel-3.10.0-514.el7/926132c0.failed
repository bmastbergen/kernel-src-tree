quota: add new quotactl Q_GETNEXTQUOTA

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Eric Sandeen <sandeen@redhat.com>
commit 926132c0257a5a8d149a6a395cc3405e55420566
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/926132c0.failed

Q_GETNEXTQUOTA is exactly like Q_GETQUOTA, except that it
will return quota information for the id equal to or greater
than the id requested.  In other words, if the requested id has
no quota, the command will return quota information for the
next higher id which does have a quota set.  If no higher id
has an active quota, -ESRCH is returned.

This allows filesystems to do efficient iteration in kernelspace,
much like extN filesystems do in userspace when asked to report
all active quotas.

This does require a new data structure for userspace, as the
current structure does not include an ID for the returned quota
information.

Today, Ext4 with a hidden quota inode requires getpwent-style
iterations, and for systems which have i.e. LDAP backends,
this can be very slow, or even impossible if iteration is not
allowed in the configuration.

	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 926132c0257a5a8d149a6a395cc3405e55420566)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/quota/quota.c
diff --cc fs/quota/quota.c
index 8f489c65f2a6,0ebc90496525..000000000000
--- a/fs/quota/quota.c
+++ b/fs/quota/quota.c
@@@ -150,16 -222,44 +150,48 @@@ static int quota_getquota(struct super_
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void copy_from_if_dqblk(struct fs_disk_quota *dst, struct if_dqblk *src)
++=======
+ /*
+  * Return quota for next active quota >= this id, if any exists,
+  * otherwise return -ESRCH via ->get_nextdqblk
+  */
+ static int quota_getnextquota(struct super_block *sb, int type, qid_t id,
+ 			  void __user *addr)
+ {
+ 	struct kqid qid;
+ 	struct qc_dqblk fdq;
+ 	struct if_nextdqblk idq;
+ 	int ret;
+ 
+ 	if (!sb->s_qcop->get_nextdqblk)
+ 		return -ENOSYS;
+ 	qid = make_kqid(current_user_ns(), type, id);
+ 	if (!qid_valid(qid))
+ 		return -EINVAL;
+ 	ret = sb->s_qcop->get_nextdqblk(sb, &qid, &fdq);
+ 	if (ret)
+ 		return ret;
+ 	/* struct if_nextdqblk is a superset of struct if_dqblk */
+ 	copy_to_if_dqblk((struct if_dqblk *)&idq, &fdq);
+ 	idq.dqb_id = from_kqid(current_user_ns(), qid);
+ 	if (copy_to_user(addr, &idq, sizeof(idq)))
+ 		return -EFAULT;
+ 	return 0;
+ }
+ 
+ static void copy_from_if_dqblk(struct qc_dqblk *dst, struct if_dqblk *src)
++>>>>>>> 926132c0257a (quota: add new quotactl Q_GETNEXTQUOTA)
  {
 -	dst->d_spc_hardlimit = qbtos(src->dqb_bhardlimit);
 -	dst->d_spc_softlimit = qbtos(src->dqb_bsoftlimit);
 -	dst->d_space = src->dqb_curspace;
 +	dst->d_blk_hardlimit = src->dqb_bhardlimit;
 +	dst->d_blk_softlimit  = src->dqb_bsoftlimit;
 +	dst->d_bcount = src->dqb_curspace;
  	dst->d_ino_hardlimit = src->dqb_ihardlimit;
  	dst->d_ino_softlimit = src->dqb_isoftlimit;
 -	dst->d_ino_count = src->dqb_curinodes;
 -	dst->d_spc_timer = src->dqb_btime;
 -	dst->d_ino_timer = src->dqb_itime;
 +	dst->d_icount = src->dqb_curinodes;
 +	dst->d_btimer = src->dqb_btime;
 +	dst->d_itimer = src->dqb_itime;
  
  	dst->d_fieldmask = 0;
  	if (src->dqb_valid & QIF_BLIMITS)
* Unmerged path fs/quota/quota.c
diff --git a/include/uapi/linux/quota.h b/include/uapi/linux/quota.h
index 3b6cfbeb086d..ff4775a42238 100644
--- a/include/uapi/linux/quota.h
+++ b/include/uapi/linux/quota.h
@@ -69,6 +69,7 @@
 #define Q_SETINFO  0x800006	/* set information about quota files */
 #define Q_GETQUOTA 0x800007	/* get user quota structure */
 #define Q_SETQUOTA 0x800008	/* set user quota structure */
+#define Q_GETNEXTQUOTA 0x800009	/* get disk limits and usage >= ID */
 
 /* Quota format type IDs */
 #define	QFMT_VFS_OLD 1
@@ -117,6 +118,19 @@ struct if_dqblk {
 	__u32 dqb_valid;
 };
 
+struct if_nextdqblk {
+	__u64 dqb_bhardlimit;
+	__u64 dqb_bsoftlimit;
+	__u64 dqb_curspace;
+	__u64 dqb_ihardlimit;
+	__u64 dqb_isoftlimit;
+	__u64 dqb_curinodes;
+	__u64 dqb_btime;
+	__u64 dqb_itime;
+	__u32 dqb_valid;
+	__u32 dqb_id;
+};
+
 /*
  * Structure used for setting quota information about file via quotactl
  * Following flags are used to specify which fields are valid
