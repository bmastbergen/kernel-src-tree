rhashtable: fix for resize events during table walk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Phil Sutter <phil@nwl.cc>
commit 142b942a75cb10ede1b42bf85368d41449ab4e3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/142b942a.failed

If rhashtable_walk_next detects a resize operation in progress, it jumps
to the new table and continues walking that one. But it misses to drop
the reference to it's current item, leading it to continue traversing
the new table's bucket in which the current item is sorted into, and
after reaching that bucket's end continues traversing the new table's
second bucket instead of the first one, thereby potentially missing
items.

This fixes the rhashtable runtime test for me. Bug probably introduced
by Herbert Xu's patch eddee5ba ("rhashtable: Fix walker behaviour during
rehash") although not explicitly tested.

Fixes: eddee5ba ("rhashtable: Fix walker behaviour during rehash")
	Signed-off-by: Phil Sutter <phil@nwl.cc>
	Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 142b942a75cb10ede1b42bf85368d41449ab4e3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/rhashtable.c
diff --cc lib/rhashtable.c
index 15ef938f4f67,cc0c69710dcf..000000000000
--- a/lib/rhashtable.c
+++ b/lib/rhashtable.c
@@@ -286,186 -332,340 +286,247 @@@ int rhashtable_shrink(struct rhashtabl
  
  	ASSERT_RHT_MUTEX(ht);
  
 -	size = roundup_pow_of_two(atomic_read(&ht->nelems) * 3 / 2);
 -	if (size < ht->p.min_size)
 -		size = ht->p.min_size;
 -
 -	if (old_tbl->size <= size)
 +	if (ht->shift <= ht->p.min_shift)
  		return 0;
  
 -	if (rht_dereference(old_tbl->future_tbl, ht))
 -		return -EEXIST;
 -
 -	new_tbl = bucket_table_alloc(ht, size, GFP_KERNEL);
 -	if (new_tbl == NULL)
 +	ntbl = bucket_table_alloc(tbl->size / 2);
 +	if (ntbl == NULL)
  		return -ENOMEM;
  
 -	err = rhashtable_rehash_attach(ht, old_tbl, new_tbl);
 -	if (err)
 -		bucket_table_free(new_tbl);
 -
 -	return err;
 -}
 -
 -static void rht_deferred_worker(struct work_struct *work)
 -{
 -	struct rhashtable *ht;
 -	struct bucket_table *tbl;
 -	int err = 0;
 -
 -	ht = container_of(work, struct rhashtable, run_work);
 -	mutex_lock(&ht->mutex);
 -
 -	tbl = rht_dereference(ht->tbl, ht);
 -	tbl = rhashtable_last_table(ht, tbl);
 +	ht->shift--;
  
 -	if (rht_grow_above_75(ht, tbl))
 -		rhashtable_expand(ht);
 -	else if (ht->p.automatic_shrinking && rht_shrink_below_30(ht, tbl))
 -		rhashtable_shrink(ht);
 -
 -	err = rhashtable_rehash_table(ht);
 +	/* Link each bucket in the new table to the first bucket
 +	 * in the old table that contains entries which will hash
 +	 * to the new bucket.
 +	 */
 +	for (i = 0; i < ntbl->size; i++) {
 +		ntbl->buckets[i] = tbl->buckets[i];
 +		RCU_INIT_POINTER(*bucket_tail(ntbl, i),
 +				 tbl->buckets[i + ntbl->size]);
  
 -	mutex_unlock(&ht->mutex);
 +	}
  
 -	if (err)
 -		schedule_work(&ht->run_work);
 -}
 +	/* Publish the new, valid hash table */
 +	rcu_assign_pointer(ht->tbl, ntbl);
  
 -static bool rhashtable_check_elasticity(struct rhashtable *ht,
 -					struct bucket_table *tbl,
 -					unsigned int hash)
 -{
 -	unsigned int elasticity = ht->elasticity;
 -	struct rhash_head *head;
 +	/* Wait for readers. No new readers will have references to the
 +	 * old hash table.
 +	 */
 +	synchronize_rcu();
  
 -	rht_for_each(head, tbl, hash)
 -		if (!--elasticity)
 -			return true;
 +	bucket_table_free(tbl);
  
 -	return false;
 +	return 0;
  }
 +EXPORT_SYMBOL_GPL(rhashtable_shrink);
  
 -int rhashtable_insert_rehash(struct rhashtable *ht)
 +/**
 + * rhashtable_insert - insert object into hash hash table
 + * @ht:		hash table
 + * @obj:	pointer to hash head inside object
 + *
 + * Will automatically grow the table via rhashtable_expand() if the the
 + * grow_decision function specified at rhashtable_init() returns true.
 + *
 + * The caller must ensure that no concurrent table mutations occur. It is
 + * however valid to have concurrent lookups if they are RCU protected.
 + */
 +void rhashtable_insert(struct rhashtable *ht, struct rhash_head *obj)
  {
 -	struct bucket_table *old_tbl;
 -	struct bucket_table *new_tbl;
 -	struct bucket_table *tbl;
 -	unsigned int size;
 -	int err;
 -
 -	old_tbl = rht_dereference_rcu(ht->tbl, ht);
 -	tbl = rhashtable_last_table(ht, old_tbl);
 -
 -	size = tbl->size;
 -
 -	if (rht_grow_above_75(ht, tbl))
 -		size *= 2;
 -	/* Do not schedule more than one rehash */
 -	else if (old_tbl != tbl)
 -		return -EBUSY;
 -
 -	new_tbl = bucket_table_alloc(ht, size, GFP_ATOMIC);
 -	if (new_tbl == NULL) {
 -		/* Schedule async resize/rehash to try allocation
 -		 * non-atomic context.
 -		 */
 -		schedule_work(&ht->run_work);
 -		return -ENOMEM;
 -	}
 +	struct bucket_table *tbl = rht_dereference(ht->tbl, ht);
 +	u32 hash;
  
 -	err = rhashtable_rehash_attach(ht, tbl, new_tbl);
 -	if (err) {
 -		bucket_table_free(new_tbl);
 -		if (err == -EEXIST)
 -			err = 0;
 -	} else
 -		schedule_work(&ht->run_work);
 -
 -	return err;
 -}
 -EXPORT_SYMBOL_GPL(rhashtable_insert_rehash);
 -
 -int rhashtable_insert_slow(struct rhashtable *ht, const void *key,
 -			   struct rhash_head *obj,
 -			   struct bucket_table *tbl)
 -{
 -	struct rhash_head *head;
 -	unsigned int hash;
 -	int err;
 +	ASSERT_RHT_MUTEX(ht);
  
 -	tbl = rhashtable_last_table(ht, tbl);
  	hash = head_hashfn(ht, tbl, obj);
 -	spin_lock_nested(rht_bucket_lock(tbl, hash), SINGLE_DEPTH_NESTING);
 -
 -	err = -EEXIST;
 -	if (key && rhashtable_lookup_fast(ht, key, ht->p))
 -		goto exit;
 -
 -	err = -E2BIG;
 -	if (unlikely(rht_grow_above_max(ht, tbl)))
 -		goto exit;
 -
 -	err = -EAGAIN;
 -	if (rhashtable_check_elasticity(ht, tbl, hash) ||
 -	    rht_grow_above_100(ht, tbl))
 -		goto exit;
 -
 -	err = 0;
 -
 -	head = rht_dereference_bucket(tbl->buckets[hash], tbl, hash);
 -
 -	RCU_INIT_POINTER(obj->next, head);
 -
 +	RCU_INIT_POINTER(obj->next, tbl->buckets[hash]);
  	rcu_assign_pointer(tbl->buckets[hash], obj);
 +	ht->nelems++;
  
 -	atomic_inc(&ht->nelems);
 -
 -exit:
 -	spin_unlock(rht_bucket_lock(tbl, hash));
 -
 -	return err;
 +	if (ht->p.grow_decision && ht->p.grow_decision(ht, tbl->size))
 +		rhashtable_expand(ht);
  }
 -EXPORT_SYMBOL_GPL(rhashtable_insert_slow);
 +EXPORT_SYMBOL_GPL(rhashtable_insert);
  
  /**
 - * rhashtable_walk_init - Initialise an iterator
 - * @ht:		Table to walk over
 - * @iter:	Hash table Iterator
 - *
 - * This function prepares a hash table walk.
 + * rhashtable_remove - remove object from hash table
 + * @ht:		hash table
 + * @obj:	pointer to hash head inside object
   *
 - * Note that if you restart a walk after rhashtable_walk_stop you
 - * may see the same object twice.  Also, you may miss objects if
 - * there are removals in between rhashtable_walk_stop and the next
 - * call to rhashtable_walk_start.
 + * Since the hash chain is single linked, the removal operation needs to
 + * walk the bucket chain upon removal. The removal operation is thus
 + * considerable slow if the hash table is not correctly sized.
   *
 - * For a completely stable walk you should construct your own data
 - * structure outside the hash table.
 + * Will automatically shrink the table via rhashtable_expand() if the the
 + * shrink_decision function specified at rhashtable_init() returns true.
   *
 - * This function may sleep so you must not call it from interrupt
 - * context or with spin locks held.
 - *
 - * You must call rhashtable_walk_exit if this function returns
 - * successfully.
 + * The caller must ensure that no concurrent table mutations occur. It is
 + * however valid to have concurrent lookups if they are RCU protected.
   */
 -int rhashtable_walk_init(struct rhashtable *ht, struct rhashtable_iter *iter)
 +bool rhashtable_remove(struct rhashtable *ht, struct rhash_head *obj)
  {
 -	iter->ht = ht;
 -	iter->p = NULL;
 -	iter->slot = 0;
 -	iter->skip = 0;
 +	struct bucket_table *tbl = rht_dereference(ht->tbl, ht);
 +	struct rhash_head __rcu **pprev;
 +	struct rhash_head *he;
 +	u32 h;
  
 -	iter->walker = kmalloc(sizeof(*iter->walker), GFP_KERNEL);
 -	if (!iter->walker)
 -		return -ENOMEM;
 +	ASSERT_RHT_MUTEX(ht);
  
 -	mutex_lock(&ht->mutex);
 -	iter->walker->tbl = rht_dereference(ht->tbl, ht);
 -	list_add(&iter->walker->list, &iter->walker->tbl->walkers);
 -	mutex_unlock(&ht->mutex);
 +	h = head_hashfn(ht, tbl, obj);
  
 -	return 0;
 -}
 -EXPORT_SYMBOL_GPL(rhashtable_walk_init);
 +	pprev = &tbl->buckets[h];
 +	rht_for_each(he, tbl, h) {
 +		if (he != obj) {
 +			pprev = &he->next;
 +			continue;
 +		}
  
 -/**
 - * rhashtable_walk_exit - Free an iterator
 - * @iter:	Hash table Iterator
 - *
 - * This function frees resources allocated by rhashtable_walk_init.
 - */
 -void rhashtable_walk_exit(struct rhashtable_iter *iter)
 -{
 -	mutex_lock(&iter->ht->mutex);
 -	if (iter->walker->tbl)
 -		list_del(&iter->walker->list);
 -	mutex_unlock(&iter->ht->mutex);
 -	kfree(iter->walker);
 +		RCU_INIT_POINTER(*pprev, he->next);
 +		ht->nelems--;
 +
 +		if (ht->p.shrink_decision &&
 +		    ht->p.shrink_decision(ht, tbl->size))
 +			rhashtable_shrink(ht);
 +
 +		return true;
 +	}
 +
 +	return false;
  }
 -EXPORT_SYMBOL_GPL(rhashtable_walk_exit);
 +EXPORT_SYMBOL_GPL(rhashtable_remove);
  
  /**
 - * rhashtable_walk_start - Start a hash table walk
 - * @iter:	Hash table iterator
 + * rhashtable_lookup - lookup key in hash table
 + * @ht:		hash table
 + * @key:	pointer to key
   *
 - * Start a hash table walk.  Note that we take the RCU lock in all
 - * cases including when we return an error.  So you must always call
 - * rhashtable_walk_stop to clean up.
 + * Computes the hash value for the key and traverses the bucket chain looking
 + * for a entry with an identical key. The first matching entry is returned.
   *
 - * Returns zero if successful.
 + * This lookup function may only be used for fixed key hash table (key_len
 + * paramter set). It will BUG() if used inappropriately.
   *
 - * Returns -EAGAIN if resize event occured.  Note that the iterator
 - * will rewind back to the beginning and you may use it immediately
 - * by calling rhashtable_walk_next.
 + * Lookups may occur in parallel with hash mutations as long as the lookup is
 + * guarded by rcu_read_lock(). The caller must take care of this.
   */
 -int rhashtable_walk_start(struct rhashtable_iter *iter)
 -	__acquires(RCU)
 +void *rhashtable_lookup(const struct rhashtable *ht, const void *key)
  {
 -	struct rhashtable *ht = iter->ht;
 -
 -	mutex_lock(&ht->mutex);
 -
 -	if (iter->walker->tbl)
 -		list_del(&iter->walker->list);
 -
 -	rcu_read_lock();
 -
 -	mutex_unlock(&ht->mutex);
 -
 -	if (!iter->walker->tbl) {
 -		iter->walker->tbl = rht_dereference_rcu(ht->tbl, ht);
 -		return -EAGAIN;
 +	const struct bucket_table *tbl = rht_dereference_rcu(ht->tbl, ht);
 +	struct rhash_head *he;
 +	u32 h;
 +
 +	BUG_ON(!ht->p.key_len);
 +
 +	h = key_hashfn(ht, key, ht->p.key_len);
 +	rht_for_each_rcu(he, tbl, h) {
 +		if (memcmp(rht_obj(ht, he) + ht->p.key_offset, key,
 +			   ht->p.key_len))
 +			continue;
 +		return rht_obj(ht, he);
  	}
  
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(rhashtable_walk_start);
+ 
+ /**
+  * rhashtable_walk_next - Return the next object and advance the iterator
+  * @iter:	Hash table iterator
+  *
+  * Note that you must call rhashtable_walk_stop when you are finished
+  * with the walk.
+  *
+  * Returns the next object or NULL when the end of the table is reached.
+  *
+  * Returns -EAGAIN if resize event occured.  Note that the iterator
+  * will rewind back to the beginning and you may continue to use it.
+  */
+ void *rhashtable_walk_next(struct rhashtable_iter *iter)
+ {
+ 	struct bucket_table *tbl = iter->walker->tbl;
+ 	struct rhashtable *ht = iter->ht;
+ 	struct rhash_head *p = iter->p;
+ 
+ 	if (p) {
+ 		p = rht_dereference_bucket_rcu(p->next, tbl, iter->slot);
+ 		goto next;
+ 	}
+ 
+ 	for (; iter->slot < tbl->size; iter->slot++) {
+ 		int skip = iter->skip;
+ 
+ 		rht_for_each_rcu(p, tbl, iter->slot) {
+ 			if (!skip)
+ 				break;
+ 			skip--;
+ 		}
+ 
+ next:
+ 		if (!rht_is_a_nulls(p)) {
+ 			iter->skip++;
+ 			iter->p = p;
+ 			return rht_obj(ht, p);
+ 		}
+ 
+ 		iter->skip = 0;
+ 	}
+ 
+ 	iter->p = NULL;
+ 
+ 	/* Ensure we see any new tables. */
+ 	smp_rmb();
+ 
+ 	iter->walker->tbl = rht_dereference_rcu(tbl->future_tbl, ht);
+ 	if (iter->walker->tbl) {
+ 		iter->slot = 0;
+ 		iter->skip = 0;
+ 		return ERR_PTR(-EAGAIN);
+ 	}
+ 
++>>>>>>> 142b942a75cb (rhashtable: fix for resize events during table walk)
  	return NULL;
  }
 -EXPORT_SYMBOL_GPL(rhashtable_walk_next);
 +EXPORT_SYMBOL_GPL(rhashtable_lookup);
  
  /**
 - * rhashtable_walk_stop - Finish a hash table walk
 - * @iter:	Hash table iterator
 + * rhashtable_lookup_compare - search hash table with compare function
 + * @ht:		hash table
 + * @key:	the pointer to the key
 + * @compare:	compare function, must return true on match
 + * @arg:	argument passed on to compare function
 + *
 + * Traverses the bucket chain behind the provided hash value and calls the
 + * specified compare function for each entry.
   *
 - * Finish a hash table walk.
 + * Lookups may occur in parallel with hash mutations as long as the lookup is
 + * guarded by rcu_read_lock(). The caller must take care of this.
 + *
 + * Returns the first entry on which the compare function returned true.
   */
 -void rhashtable_walk_stop(struct rhashtable_iter *iter)
 -	__releases(RCU)
 +void *rhashtable_lookup_compare(const struct rhashtable *ht, const void *key,
 +				bool (*compare)(void *, void *), void *arg)
  {
 -	struct rhashtable *ht;
 -	struct bucket_table *tbl = iter->walker->tbl;
 -
 -	if (!tbl)
 -		goto out;
 -
 -	ht = iter->ht;
 -
 -	spin_lock(&ht->lock);
 -	if (tbl->rehash < tbl->size)
 -		list_add(&iter->walker->list, &tbl->walkers);
 -	else
 -		iter->walker->tbl = NULL;
 -	spin_unlock(&ht->lock);
 -
 -	iter->p = NULL;
 +	const struct bucket_table *tbl = rht_dereference_rcu(ht->tbl, ht);
 +	struct rhash_head *he;
 +	u32 hash;
 +
 +	hash = key_hashfn(ht, key, ht->p.key_len);
 +	rht_for_each_rcu(he, tbl, hash) {
 +		if (!compare(rht_obj(ht, he), arg))
 +			continue;
 +		return rht_obj(ht, he);
 +	}
  
 -out:
 -	rcu_read_unlock();
 +	return NULL;
  }
 -EXPORT_SYMBOL_GPL(rhashtable_walk_stop);
 +EXPORT_SYMBOL_GPL(rhashtable_lookup_compare);
  
 -static size_t rounded_hashtable_size(const struct rhashtable_params *params)
 +static size_t rounded_hashtable_size(struct rhashtable_params *params)
  {
  	return max(roundup_pow_of_two(params->nelem_hint * 4 / 3),
 -		   (unsigned long)params->min_size);
 -}
 -
 -static u32 rhashtable_jhash2(const void *key, u32 length, u32 seed)
 -{
 -	return jhash2(key, length, seed);
 +		   1UL << params->min_shift);
  }
  
  /**
* Unmerged path lib/rhashtable.c
