mmc: dw_mmc: guarantee stop-abort cmd in data errors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Seungwon Jeon <tgih.jun@samsung.com>
commit 90c2143a8f6d0cd1dbae1ea32fcd1befb81e4b0d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/90c2143a.failed

In error cases, DTO interrupt may or may not be generated depending
on remained data. Stop/Abort command ensures DTO generation for that
situation. Currently if 'stop' field of data is empty, there is no
stop/abort command. So, it could hang waiting DTO. This change
reinforces these cases.

	Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
	Tested-by: Alim Akhtar <alim.akhtar@samsung.com>
	Signed-off-by: Chris Ball <cjb@laptop.org>
(cherry picked from commit 90c2143a8f6d0cd1dbae1ea32fcd1befb81e4b0d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/dw_mmc.c
diff --cc drivers/mmc/host/dw_mmc.c
index 53089ade7270,b4328ad59cf0..000000000000
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@@ -1149,6 -1231,13 +1192,16 @@@ static void dw_mci_tasklet_func(unsigne
  				goto unlock;
  			}
  
++<<<<<<< HEAD
++=======
+ 			if (cmd->data && cmd->error) {
+ 				dw_mci_stop_dma(host);
+ 				send_stop_abort(host, data);
+ 				state = STATE_SENDING_STOP;
+ 				break;
+ 			}
+ 
++>>>>>>> 90c2143a8f6d (mmc: dw_mmc: guarantee stop-abort cmd in data errors)
  			if (!host->mrq->data || cmd->error) {
  				dw_mci_request_end(host, host->mrq);
  				goto unlock;
@@@ -1243,8 -1333,23 +1297,18 @@@
  						&host->pending_events))
  				break;
  
 -			/* CMD error in data command */
 -			if (host->mrq->cmd->error && host->mrq->data) {
 -				sg_miter_stop(&host->sg_miter);
 -				host->sg = NULL;
 -				ctrl = mci_readl(host, CTRL);
 -				ctrl |= SDMMC_CTRL_FIFO_RESET;
 -				mci_writel(host, CTRL, ctrl);
 -			}
 -
  			host->cmd = NULL;
++<<<<<<< HEAD
 +			dw_mci_command_complete(host, host->mrq->stop);
++=======
+ 			host->data = NULL;
+ 
+ 			if (host->mrq->stop)
+ 				dw_mci_command_complete(host, host->mrq->stop);
+ 			else
+ 				host->cmd_status = 0;
+ 
++>>>>>>> 90c2143a8f6d (mmc: dw_mmc: guarantee stop-abort cmd in data errors)
  			dw_mci_request_end(host, host->mrq);
  			goto unlock;
  
* Unmerged path drivers/mmc/host/dw_mmc.c
diff --git a/include/linux/mmc/dw_mmc.h b/include/linux/mmc/dw_mmc.h
index a829f7ee28c8..6ce7d2cd3c7a 100644
--- a/include/linux/mmc/dw_mmc.h
+++ b/include/linux/mmc/dw_mmc.h
@@ -15,6 +15,7 @@
 #define LINUX_MMC_DW_MMC_H
 
 #include <linux/scatterlist.h>
+#include <linux/mmc/core.h>
 
 #define MAX_MCI_SLOTS	2
 
@@ -129,6 +130,7 @@ struct dw_mci {
 	struct mmc_request	*mrq;
 	struct mmc_command	*cmd;
 	struct mmc_data		*data;
+	struct mmc_command	stop_abort;
 	unsigned int		prev_blksz;
 	unsigned char		timing;
 	struct workqueue_struct	*card_workqueue;
