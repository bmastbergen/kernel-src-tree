sctp: export some apis or variables for sctp_diag and reuse some for proc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit 626d16f50f39bb9c44f98fd256cae2b864900a01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/626d16f5.failed

For some main variables in sctp.ko, we couldn't export it to other modules,
so we have to define some api to access them.

It will include sctp transport and endpoint's traversal.

There are some transport traversal functions for sctp_diag, we can also
use it for sctp_proc. cause they have the similar situation to traversal
transport.

v2->v3:
- rhashtable_walk_init need the parameter gfp, because of recent upstrem
  update

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 626d16f50f39bb9c44f98fd256cae2b864900a01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/proc.c
diff --cc net/sctp/proc.c
index aaeecb033eeb,dd8492f0037d..000000000000
--- a/net/sctp/proc.c
+++ b/net/sctp/proc.c
@@@ -288,16 -277,47 +288,55 @@@ void sctp_eps_proc_exit(struct net *net
  	remove_proc_entry("eps", net->sctp.proc_net_sctp);
  }
  
 -struct sctp_ht_iter {
 -	struct seq_net_private p;
 -	struct rhashtable_iter hti;
 -};
  
++<<<<<<< HEAD
 +static void * sctp_assocs_seq_start(struct seq_file *seq, loff_t *pos)
 +{
 +	if (*pos >= sctp_assoc_hashsize)
 +		return NULL;
 +
 +	if (*pos < 0)
 +		*pos = 0;
 +
 +	if (*pos == 0)
++=======
+ static void *sctp_assocs_seq_start(struct seq_file *seq, loff_t *pos)
+ {
+ 	struct sctp_ht_iter *iter = seq->private;
+ 	int err = sctp_transport_walk_start(&iter->hti);
+ 
+ 	if (err)
+ 		return ERR_PTR(err);
+ 
+ 	return sctp_transport_get_idx(seq_file_net(seq), &iter->hti, *pos);
+ }
+ 
+ static void sctp_assocs_seq_stop(struct seq_file *seq, void *v)
+ {
+ 	struct sctp_ht_iter *iter = seq->private;
+ 
+ 	sctp_transport_walk_stop(&iter->hti);
+ }
+ 
+ static void *sctp_assocs_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+ {
+ 	struct sctp_ht_iter *iter = seq->private;
+ 
+ 	++*pos;
+ 
+ 	return sctp_transport_get_next(seq_file_net(seq), &iter->hti);
+ }
+ 
+ /* Display sctp associations (/proc/net/sctp/assocs). */
+ static int sctp_assocs_seq_show(struct seq_file *seq, void *v)
+ {
+ 	struct sctp_transport *transport;
+ 	struct sctp_association *assoc;
+ 	struct sctp_ep_common *epb;
+ 	struct sock *sk;
+ 
+ 	if (v == SEQ_START_TOKEN) {
++>>>>>>> 626d16f50f39 (sctp: export some apis or variables for sctp_diag and reuse some for proc)
  		seq_printf(seq, " ASSOC     SOCK   STY SST ST HBKT "
  				"ASSOC-ID TX_QUEUE RX_QUEUE UID INODE LPORT "
  				"RPORT LADDRS <-> RADDRS "
@@@ -416,29 -408,29 +455,52 @@@ void sctp_assocs_proc_exit(struct net *
  
  static void *sctp_remaddr_seq_start(struct seq_file *seq, loff_t *pos)
  {
++<<<<<<< HEAD
 +	if (*pos >= sctp_assoc_hashsize)
 +		return NULL;
++=======
+ 	struct sctp_ht_iter *iter = seq->private;
+ 	int err = sctp_transport_walk_start(&iter->hti);
++>>>>>>> 626d16f50f39 (sctp: export some apis or variables for sctp_diag and reuse some for proc)
  
 -	if (err)
 -		return ERR_PTR(err);
 +	if (*pos < 0)
 +		*pos = 0;
 +
++<<<<<<< HEAD
 +	if (*pos == 0)
 +		seq_printf(seq, "ADDR ASSOC_ID HB_ACT RTO MAX_PATH_RTX "
 +				"REM_ADDR_RTX START STATE\n");
  
 +	return (void *)pos;
++=======
+ 	return sctp_transport_get_idx(seq_file_net(seq), &iter->hti, *pos);
++>>>>>>> 626d16f50f39 (sctp: export some apis or variables for sctp_diag and reuse some for proc)
  }
  
  static void *sctp_remaddr_seq_next(struct seq_file *seq, void *v, loff_t *pos)
  {
++<<<<<<< HEAD
 +	if (++*pos >= sctp_assoc_hashsize)
 +		return NULL;
 +
 +	return pos;
++=======
+ 	struct sctp_ht_iter *iter = seq->private;
+ 
+ 	++*pos;
+ 
+ 	return sctp_transport_get_next(seq_file_net(seq), &iter->hti);
++>>>>>>> 626d16f50f39 (sctp: export some apis or variables for sctp_diag and reuse some for proc)
  }
  
  static void sctp_remaddr_seq_stop(struct seq_file *seq, void *v)
  {
++<<<<<<< HEAD
++=======
+ 	struct sctp_ht_iter *iter = seq->private;
+ 
+ 	sctp_transport_walk_stop(&iter->hti);
++>>>>>>> 626d16f50f39 (sctp: export some apis or variables for sctp_diag and reuse some for proc)
  }
  
  static int sctp_remaddr_seq_show(struct seq_file *seq, void *v)
diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.h
index dc59f95106d2..2d11ab1d4052 100644
--- a/include/net/sctp/sctp.h
+++ b/include/net/sctp/sctp.h
@@ -136,6 +136,19 @@ void sctp_copy_sock(struct sock *newsk, struct sock *sk,
 extern struct percpu_counter sctp_sockets_allocated;
 extern int sctp_asconf_mgmt(struct sctp_sock *, struct sctp_sockaddr_entry *);
 
+int sctp_transport_walk_start(struct rhashtable_iter *iter);
+void sctp_transport_walk_stop(struct rhashtable_iter *iter);
+struct sctp_transport *sctp_transport_get_next(struct net *net,
+			struct rhashtable_iter *iter);
+struct sctp_transport *sctp_transport_get_idx(struct net *net,
+			struct rhashtable_iter *iter, int pos);
+int sctp_transport_lookup_process(int (*cb)(struct sctp_transport *, void *),
+				  struct net *net,
+				  const union sctp_addr *laddr,
+				  const union sctp_addr *paddr, void *p);
+int sctp_for_each_transport(int (*cb)(struct sctp_transport *, void *),
+			    struct net *net, int pos, void *p);
+int sctp_for_each_endpoint(int (*cb)(struct sctp_endpoint *, void *), void *p);
 int sctp_get_sctp_info(struct sock *sk, struct sctp_association *asoc,
 		       struct sctp_info *info);
 
* Unmerged path net/sctp/proc.c
diff --git a/net/sctp/socket.c b/net/sctp/socket.c
index 8d54b357f982..4eb40eed64a5 100644
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@ -4173,6 +4173,131 @@ int sctp_get_sctp_info(struct sock *sk, struct sctp_association *asoc,
 }
 EXPORT_SYMBOL_GPL(sctp_get_sctp_info);
 
+/* use callback to avoid exporting the core structure */
+int sctp_transport_walk_start(struct rhashtable_iter *iter)
+{
+	int err;
+
+	err = rhashtable_walk_init(&sctp_transport_hashtable, iter,
+				   GFP_KERNEL);
+	if (err)
+		return err;
+
+	err = rhashtable_walk_start(iter);
+
+	return err == -EAGAIN ? 0 : err;
+}
+
+void sctp_transport_walk_stop(struct rhashtable_iter *iter)
+{
+	rhashtable_walk_stop(iter);
+	rhashtable_walk_exit(iter);
+}
+
+struct sctp_transport *sctp_transport_get_next(struct net *net,
+					       struct rhashtable_iter *iter)
+{
+	struct sctp_transport *t;
+
+	t = rhashtable_walk_next(iter);
+	for (; t; t = rhashtable_walk_next(iter)) {
+		if (IS_ERR(t)) {
+			if (PTR_ERR(t) == -EAGAIN)
+				continue;
+			break;
+		}
+
+		if (net_eq(sock_net(t->asoc->base.sk), net) &&
+		    t->asoc->peer.primary_path == t)
+			break;
+	}
+
+	return t;
+}
+
+struct sctp_transport *sctp_transport_get_idx(struct net *net,
+					      struct rhashtable_iter *iter,
+					      int pos)
+{
+	void *obj = SEQ_START_TOKEN;
+
+	while (pos && (obj = sctp_transport_get_next(net, iter)) &&
+	       !IS_ERR(obj))
+		pos--;
+
+	return obj;
+}
+
+int sctp_for_each_endpoint(int (*cb)(struct sctp_endpoint *, void *),
+			   void *p) {
+	int err = 0;
+	int hash = 0;
+	struct sctp_ep_common *epb;
+	struct sctp_hashbucket *head;
+
+	for (head = sctp_ep_hashtable; hash < sctp_ep_hashsize;
+	     hash++, head++) {
+		read_lock(&head->lock);
+		sctp_for_each_hentry(epb, &head->chain) {
+			err = cb(sctp_ep(epb), p);
+			if (err)
+				break;
+		}
+		read_unlock(&head->lock);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(sctp_for_each_endpoint);
+
+int sctp_transport_lookup_process(int (*cb)(struct sctp_transport *, void *),
+				  struct net *net,
+				  const union sctp_addr *laddr,
+				  const union sctp_addr *paddr, void *p)
+{
+	struct sctp_transport *transport;
+	int err = 0;
+
+	rcu_read_lock();
+	transport = sctp_addrs_lookup_transport(net, laddr, paddr);
+	if (!transport || !sctp_transport_hold(transport))
+		goto out;
+	err = cb(transport, p);
+	sctp_transport_put(transport);
+
+out:
+	rcu_read_unlock();
+	return err;
+}
+EXPORT_SYMBOL_GPL(sctp_transport_lookup_process);
+
+int sctp_for_each_transport(int (*cb)(struct sctp_transport *, void *),
+			    struct net *net, int pos, void *p) {
+	struct rhashtable_iter hti;
+	int err = 0;
+	void *obj;
+
+	if (sctp_transport_walk_start(&hti))
+		goto out;
+
+	sctp_transport_get_idx(net, &hti, pos);
+	obj = sctp_transport_get_next(net, &hti);
+	for (; obj && !IS_ERR(obj); obj = sctp_transport_get_next(net, &hti)) {
+		struct sctp_transport *transport = obj;
+
+		if (!sctp_transport_hold(transport))
+			continue;
+		err = cb(transport, p);
+		sctp_transport_put(transport);
+		if (err)
+			break;
+	}
+out:
+	sctp_transport_walk_stop(&hti);
+	return err;
+}
+EXPORT_SYMBOL_GPL(sctp_for_each_transport);
+
 /* 7.2.1 Association Status (SCTP_STATUS)
 
  * Applications can retrieve current status information about an
