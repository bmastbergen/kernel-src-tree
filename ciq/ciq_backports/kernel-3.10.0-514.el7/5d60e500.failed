mmc: tmio: add new TMIO_MMC_HAVE_HIGH_REG flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
commit 5d60e500541ed154112809627f12d86056ac5f09
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5d60e500.failed

The accessibility checking method to the higher register was added by
69d1fe18e92afb (mmc: tmio: only access registers above 0xff, if available)
But, it doesn't care 32bit register.  It is impossible to calculate it
from the resource size, since there is 16/32 bit register IP (e.g. VERSION
is located on 0xe2 if 16bit register, but it is located on 0x1c4 if 32bit
register).

This patch adds new TMIO_MMC_HAVE_HIGH_REG flags, tmio_mmc driver has it,
and sh_mobile_sdhi doesn't have it today.

	Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
	Signed-off-by: Chris Ball <cjb@laptop.org>
(cherry picked from commit 5d60e500541ed154112809627f12d86056ac5f09)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/tmio_mmc.c
diff --cc drivers/mmc/host/tmio_mmc.c
index 8860d4d2bc22,8a781e2ac4c3..000000000000
--- a/drivers/mmc/host/tmio_mmc.c
+++ b/drivers/mmc/host/tmio_mmc.c
@@@ -84,6 -85,14 +84,17 @@@ static int tmio_mmc_probe(struct platfo
  			goto out;
  	}
  
++<<<<<<< HEAD
++=======
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	if (!res)
+ 		return -EINVAL;
+ 
+ 	/* SD control register space size is 0x200, 0x400 for bus_shift=1 */
+ 	pdata->bus_shift = resource_size(res_ctl) >> 10;
+ 	pdata->flags |= TMIO_MMC_HAVE_HIGH_REG;
+ 
++>>>>>>> 5d60e500541e (mmc: tmio: add new TMIO_MMC_HAVE_HIGH_REG flags)
  	ret = tmio_mmc_host_probe(&host, pdev, pdata);
  	if (ret)
  		goto cell_disable;
* Unmerged path drivers/mmc/host/tmio_mmc.c
diff --git a/drivers/mmc/host/tmio_mmc_pio.c b/drivers/mmc/host/tmio_mmc_pio.c
index ff722d753e2f..7a438a5a4442 100644
--- a/drivers/mmc/host/tmio_mmc_pio.c
+++ b/drivers/mmc/host/tmio_mmc_pio.c
@@ -161,10 +161,8 @@ static void tmio_mmc_set_clock(struct tmio_mmc_host *host, int new_clock)
 
 static void tmio_mmc_clk_stop(struct tmio_mmc_host *host)
 {
-	struct resource *res = platform_get_resource(host->pdev, IORESOURCE_MEM, 0);
-
 	/* implicit BUG_ON(!res) */
-	if (resource_size(res) > 0x100) {
+	if (host->pdata->flags & TMIO_MMC_HAVE_HIGH_REG) {
 		sd_ctrl_write16(host, CTL_CLK_AND_WAIT_CTL, 0x0000);
 		msleep(10);
 	}
@@ -176,14 +174,12 @@ static void tmio_mmc_clk_stop(struct tmio_mmc_host *host)
 
 static void tmio_mmc_clk_start(struct tmio_mmc_host *host)
 {
-	struct resource *res = platform_get_resource(host->pdev, IORESOURCE_MEM, 0);
-
 	sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, 0x0100 |
 		sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
 	msleep(10);
 
 	/* implicit BUG_ON(!res) */
-	if (resource_size(res) > 0x100) {
+	if (host->pdata->flags & TMIO_MMC_HAVE_HIGH_REG) {
 		sd_ctrl_write16(host, CTL_CLK_AND_WAIT_CTL, 0x0100);
 		msleep(10);
 	}
@@ -191,16 +187,14 @@ static void tmio_mmc_clk_start(struct tmio_mmc_host *host)
 
 static void tmio_mmc_reset(struct tmio_mmc_host *host)
 {
-	struct resource *res = platform_get_resource(host->pdev, IORESOURCE_MEM, 0);
-
 	/* FIXME - should we set stop clock reg here */
 	sd_ctrl_write16(host, CTL_RESET_SD, 0x0000);
 	/* implicit BUG_ON(!res) */
-	if (resource_size(res) > 0x100)
+	if (host->pdata->flags & TMIO_MMC_HAVE_HIGH_REG)
 		sd_ctrl_write16(host, CTL_RESET_SDIO, 0x0000);
 	msleep(10);
 	sd_ctrl_write16(host, CTL_RESET_SD, 0x0001);
-	if (resource_size(res) > 0x100)
+	if (host->pdata->flags & TMIO_MMC_HAVE_HIGH_REG)
 		sd_ctrl_write16(host, CTL_RESET_SDIO, 0x0001);
 	msleep(10);
 }
diff --git a/include/linux/mfd/tmio.h b/include/linux/mfd/tmio.h
index b22883d60500..ac8f90f8819a 100644
--- a/include/linux/mfd/tmio.h
+++ b/include/linux/mfd/tmio.h
@@ -76,6 +76,13 @@
  */
 #define TMIO_MMC_USE_GPIO_CD		(1 << 5)
 
+/*
+ * Some controllers doesn't have over 0x100 register.
+ * it is used to checking accessibility of
+ * CTL_SD_CARD_CLK_CTL / CTL_CLK_AND_WAIT_CTL
+ */
+#define TMIO_MMC_HAVE_HIGH_REG		(1 << 6)
+
 int tmio_core_mmc_enable(void __iomem *cnf, int shift, unsigned long base);
 int tmio_core_mmc_resume(void __iomem *cnf, int shift, unsigned long base);
 void tmio_core_mmc_pwr(void __iomem *cnf, int shift, int state);
