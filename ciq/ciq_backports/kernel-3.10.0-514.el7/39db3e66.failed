staging/rdma/hfi1: Remove srq from hfi1

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Remove srq from hfi1 (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 88.57%
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit 39db3e66fa5f7d489f3eb9b0359d6d7e7bf0cd45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/39db3e66.failed

SRQ data structure has been moved to rdmavt. Make use of it.

	Reviewed-by: Harish Chegondi <harish.chegondi@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 39db3e66fa5f7d489f3eb9b0359d6d7e7bf0cd45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/ruc.c
#	drivers/staging/hfi1/srq.c
#	drivers/staging/hfi1/verbs.h
diff --cc drivers/staging/hfi1/ruc.c
index c4280b6f47d4,3b2f032b9dea..000000000000
--- a/drivers/staging/hfi1/ruc.c
+++ b/drivers/staging/hfi1/ruc.c
@@@ -154,13 -154,13 +154,20 @@@ bail
   *
   * Can be called from interrupt level.
   */
 -int hfi1_get_rwqe(struct rvt_qp *qp, int wr_id_only)
 +int hfi1_get_rwqe(struct hfi1_qp *qp, int wr_id_only)
  {
  	unsigned long flags;
++<<<<<<< HEAD:drivers/staging/hfi1/ruc.c
 +	struct hfi1_rq *rq;
 +	struct hfi1_rwq *wq;
 +	struct hfi1_srq *srq;
 +	struct hfi1_rwqe *wqe;
++=======
+ 	struct rvt_rq *rq;
+ 	struct rvt_rwq *wq;
+ 	struct rvt_srq *srq;
+ 	struct rvt_rwqe *wqe;
++>>>>>>> 39db3e66fa5f (staging/rdma/hfi1: Remove srq from hfi1):drivers/staging/rdma/hfi1/ruc.c
  	void (*handler)(struct ib_event *, void *);
  	u32 tail;
  	int ret;
diff --cc drivers/staging/hfi1/srq.c
index 67786d417493,78f190a266a5..000000000000
--- a/drivers/staging/hfi1/srq.c
+++ b/drivers/staging/hfi1/srq.c
@@@ -65,8 -65,8 +65,13 @@@
  int hfi1_post_srq_receive(struct ib_srq *ibsrq, struct ib_recv_wr *wr,
  			  struct ib_recv_wr **bad_wr)
  {
++<<<<<<< HEAD:drivers/staging/hfi1/srq.c
 +	struct hfi1_srq *srq = to_isrq(ibsrq);
 +	struct hfi1_rwq *wq;
++=======
+ 	struct rvt_srq *srq = ibsrq_to_rvtsrq(ibsrq);
+ 	struct rvt_rwq *wq;
++>>>>>>> 39db3e66fa5f (staging/rdma/hfi1: Remove srq from hfi1):drivers/staging/rdma/hfi1/srq.c
  	unsigned long flags;
  	int ret;
  
@@@ -229,8 -229,8 +234,13 @@@ int hfi1_modify_srq(struct ib_srq *ibsr
  		    enum ib_srq_attr_mask attr_mask,
  		    struct ib_udata *udata)
  {
++<<<<<<< HEAD:drivers/staging/hfi1/srq.c
 +	struct hfi1_srq *srq = to_isrq(ibsrq);
 +	struct hfi1_rwq *wq;
++=======
+ 	struct rvt_srq *srq = ibsrq_to_rvtsrq(ibsrq);
+ 	struct rvt_rwq *wq;
++>>>>>>> 39db3e66fa5f (staging/rdma/hfi1: Remove srq from hfi1):drivers/staging/rdma/hfi1/srq.c
  	int ret = 0;
  
  	if (attr_mask & IB_SRQ_MAX_WR) {
diff --cc drivers/staging/hfi1/verbs.h
index 34fa7beced4f,97df555e62b5..000000000000
--- a/drivers/staging/hfi1/verbs.h
+++ b/drivers/staging/hfi1/verbs.h
@@@ -280,106 -260,9 +280,109 @@@ struct hfi1_cq 
  	u8 notify;
  	u8 triggered;
  	struct hfi1_cq_wc *queue;
 -	struct rvt_mmap_info *ip;
 +	struct hfi1_mmap_info *ip;
 +};
 +
 +/*
 + * These keep track of the copy progress within a memory region.
 + * Used by the verbs layer.
 + */
 +struct hfi1_sge {
 +	struct rvt_mregion *mr;
 +	void *vaddr;            /* kernel virtual address of segment */
 +	u32 sge_length;         /* length of the SGE */
 +	u32 length;             /* remaining length of the segment */
 +	u16 m;                  /* current index: mr->map[m] */
 +	u16 n;                  /* current index: mr->map[m]->segs[n] */
 +};
 +
 +/* Memory region */
 +struct hfi1_mr {
 +	struct ib_mr ibmr;
 +	struct ib_umem *umem;
 +	struct rvt_mregion mr;  /* must be last */
 +};
 +
 +/*
 + * Send work request queue entry.
 + * The size of the sg_list is determined when the QP is created and stored
 + * in qp->s_max_sge.
 + */
 +struct hfi1_swqe {
 +	struct ib_send_wr wr;   /* don't use wr.sg_list */
 +	u32 psn;                /* first packet sequence number */
 +	u32 lpsn;               /* last packet sequence number */
 +	u32 ssn;                /* send sequence number */
 +	u32 length;             /* total length of data in sg_list */
 +	struct hfi1_sge sg_list[0];
 +};
 +
 +/*
 + * Receive work request queue entry.
 + * The size of the sg_list is determined when the QP (or SRQ) is created
 + * and stored in qp->r_rq.max_sge (or srq->rq.max_sge).
 + */
 +struct hfi1_rwqe {
 +	u64 wr_id;
 +	u8 num_sge;
 +	struct ib_sge sg_list[0];
  };
  
 +/*
 + * This structure is used to contain the head pointer, tail pointer,
 + * and receive work queue entries as a single memory allocation so
 + * it can be mmap'ed into user space.
 + * Note that the wq array elements are variable size so you can't
 + * just index into the array to get the N'th element;
 + * use get_rwqe_ptr() instead.
 + */
 +struct hfi1_rwq {
 +	u32 head;               /* new work requests posted to the head */
 +	u32 tail;               /* receives pull requests from here. */
 +	struct hfi1_rwqe wq[0];
 +};
 +
 +struct hfi1_rq {
 +	struct hfi1_rwq *wq;
 +	u32 size;               /* size of RWQE array */
 +	u8 max_sge;
 +	/* protect changes in this struct */
 +	spinlock_t lock ____cacheline_aligned_in_smp;
 +};
 +
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.h
 +struct hfi1_srq {
 +	struct ib_srq ibsrq;
 +	struct hfi1_rq rq;
 +	struct hfi1_mmap_info *ip;
 +	/* send signal when number of RWQEs < limit */
 +	u32 limit;
 +};
 +
 +struct hfi1_sge_state {
 +	struct hfi1_sge *sg_list;      /* next SGE to be used if any */
 +	struct hfi1_sge sge;   /* progress state for the current SGE */
 +	u32 total_len;
 +	u8 num_sge;
 +};
 +
 +/*
 + * This structure holds the information that the send tasklet needs
 + * to send a RDMA read response or atomic operation.
 + */
 +struct hfi1_ack_entry {
 +	u8 opcode;
 +	u8 sent;
 +	u32 psn;
 +	u32 lpsn;
 +	union {
 +		struct hfi1_sge rdma_sge;
 +		u64 atomic_data;
 +	};
 +};
 +
++=======
++>>>>>>> 39db3e66fa5f (staging/rdma/hfi1: Remove srq from hfi1):drivers/staging/rdma/hfi1/verbs.h
  /*
   * hfi1 specific data structures that will be hidden from rvt after the queue
   * pair is made common
@@@ -778,14 -531,9 +781,18 @@@ static inline struct hfi1_cq *to_icq(st
  	return container_of(ibcq, struct hfi1_cq, ibcq);
  }
  
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.h
 +static inline struct hfi1_srq *to_isrq(struct ib_srq *ibsrq)
 +{
 +	return container_of(ibsrq, struct hfi1_srq, ibsrq);
 +}
 +
 +static inline struct hfi1_qp *to_iqp(struct ib_qp *ibqp)
++=======
+ static inline struct rvt_qp *to_iqp(struct ib_qp *ibqp)
++>>>>>>> 39db3e66fa5f (staging/rdma/hfi1: Remove srq from hfi1):drivers/staging/rdma/hfi1/verbs.h
  {
 -	return container_of(ibqp, struct rvt_qp, ibqp);
 +	return container_of(ibqp, struct hfi1_qp, ibqp);
  }
  
  static inline struct hfi1_ibdev *to_idev(struct ib_device *ibdev)
diff --git a/drivers/staging/hfi1/qp.c b/drivers/staging/hfi1/qp.c
index 9ffed6e14d8e..80a9a5a13490 100644
--- a/drivers/staging/hfi1/qp.c
+++ b/drivers/staging/hfi1/qp.c
@@ -1091,7 +1091,7 @@ struct ib_qp *hfi1_create_qp(struct ib_pd *ibpd,
 		sz = sizeof(*qp);
 		sg_list_sz = 0;
 		if (init_attr->srq) {
-			struct hfi1_srq *srq = to_isrq(init_attr->srq);
+			struct rvt_srq *srq = ibsrq_to_rvtsrq(init_attr->srq);
 
 			if (srq->rq.max_sge > 1)
 				sg_list_sz = sizeof(*qp->r_sg_list) *
* Unmerged path drivers/staging/hfi1/ruc.c
* Unmerged path drivers/staging/hfi1/srq.c
* Unmerged path drivers/staging/hfi1/verbs.h
