locks: Use more file_inode and fix a comment

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Benjamin Coddington <bcodding@redhat.com>
commit 6ca7d910121af4dd8c83294b50546f4664b2a932
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6ca7d910.failed

	Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
	Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
(cherry picked from commit 6ca7d910121af4dd8c83294b50546f4664b2a932)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/locks.c
diff --cc fs/locks.c
index 4da168d46db3,c74c9df419bc..000000000000
--- a/fs/locks.c
+++ b/fs/locks.c
@@@ -1623,20 -1717,30 +1623,27 @@@ out_unlink
  static int generic_delete_lease(struct file *filp, void *owner)
  {
  	int error = -EAGAIN;
++<<<<<<< HEAD
 +	struct file_lock *fl, **before;
 +	struct dentry *dentry = filp->f_path.dentry;
 +	struct inode *inode = dentry->d_inode;
++=======
+ 	struct file_lock *fl, *victim = NULL;
+ 	struct inode *inode = file_inode(filp);
+ 	struct file_lock_context *ctx;
+ 	LIST_HEAD(dispose);
++>>>>>>> 6ca7d910121a (locks: Use more file_inode and fix a comment)
  
 -	ctx = smp_load_acquire(&inode->i_flctx);
 -	if (!ctx) {
 -		trace_generic_delete_lease(inode, NULL);
 -		return error;
 -	}
 -
 -	spin_lock(&ctx->flc_lock);
 -	list_for_each_entry(fl, &ctx->flc_lease, fl_list) {
 -		if (fl->fl_file == filp &&
 -		    fl->fl_owner == owner) {
 -			victim = fl;
 +	for (before = &inode->i_flock;
 +			((fl = *before) != NULL) && IS_LEASE(fl);
 +			before = &fl->fl_next) {
 +		if (fl->fl_file == filp && 
 +			fl->fl_owner == owner)
  			break;
 -		}
  	}
 -	trace_generic_delete_lease(inode, victim);
 -	if (victim)
 -		error = fl->fl_lmops->lm_change(victim, F_UNLCK, &dispose);
 -	spin_unlock(&ctx->flc_lock);
 -	locks_dispose_list(&dispose);
 +	trace_generic_delete_lease(inode, fl);
 +	if (fl && IS_LEASE(fl))
 +		error = fl->fl_lmops->lm_change(before, F_UNLCK);
  	return error;
  }
  
@@@ -2028,6 -2113,22 +2034,25 @@@ static int do_lock_file_wait(struct fil
  	return error;
  }
  
++<<<<<<< HEAD
++=======
+ /* Ensure that fl->fl_file has compatible f_mode for F_SETLK calls */
+ static int
+ check_fmode_for_setlk(struct file_lock *fl)
+ {
+ 	switch (fl->fl_type) {
+ 	case F_RDLCK:
+ 		if (!(fl->fl_file->f_mode & FMODE_READ))
+ 			return -EBADF;
+ 		break;
+ 	case F_WRLCK:
+ 		if (!(fl->fl_file->f_mode & FMODE_WRITE))
+ 			return -EBADF;
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 6ca7d910121a (locks: Use more file_inode and fix a comment)
  /* Apply the lock described by l to an open file descriptor.
   * This implements both the F_SETLK and F_SETLKW commands of fcntl().
   */
* Unmerged path fs/locks.c
