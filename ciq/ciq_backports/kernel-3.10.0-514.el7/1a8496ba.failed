vxlan: consolidate output route calculation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 1a8496ba409132afb3b407599061c34847de42d3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1a8496ba.failed

The code for output route lookup is duplicated for ndo_start_xmit and
ndo_fill_metadata_dst. Move it to a common function.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1a8496ba409132afb3b407599061c34847de42d3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index aaa12a1f2042,d0f7723fd776..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1817,11 -1841,60 +1817,63 @@@ int vxlan_xmit_skb(struct rtable *rt, s
  
  	skb_set_inner_protocol(skb, htons(ETH_P_TEB));
  
 -	udp_tunnel_xmit_skb(rt, sk, skb, src, dst, tos, ttl, df,
 -			    src_port, dst_port, xnet,
 -			    !(vxflags & VXLAN_F_UDP_CSUM));
 -	return 0;
 +	return udp_tunnel_xmit_skb(rt, sk, skb, src, dst, tos,
 +				   ttl, df, src_port, dst_port, xnet,
 +				   !(vxflags & VXLAN_F_UDP_CSUM));
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(vxlan_xmit_skb);
++=======
+ 
+ static struct rtable *vxlan_get_route(struct vxlan_dev *vxlan,
+ 				      struct sk_buff *skb, int oif, u8 tos,
+ 				      __be32 daddr, __be32 *saddr)
+ {
+ 	struct rtable *rt = NULL;
+ 	struct flowi4 fl4;
+ 
+ 	memset(&fl4, 0, sizeof(fl4));
+ 	fl4.flowi4_oif = oif;
+ 	fl4.flowi4_tos = RT_TOS(tos);
+ 	fl4.flowi4_mark = skb->mark;
+ 	fl4.flowi4_proto = IPPROTO_UDP;
+ 	fl4.daddr = daddr;
+ 	fl4.saddr = vxlan->cfg.saddr.sin.sin_addr.s_addr;
+ 
+ 	rt = ip_route_output_key(vxlan->net, &fl4);
+ 	if (!IS_ERR(rt))
+ 		*saddr = fl4.saddr;
+ 	return rt;
+ }
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static struct dst_entry *vxlan6_get_route(struct vxlan_dev *vxlan,
+ 					  struct sk_buff *skb, int oif,
+ 					  const struct in6_addr *daddr,
+ 					  struct in6_addr *saddr)
+ {
+ 	struct dst_entry *ndst;
+ 	struct flowi6 fl6;
+ 	int err;
+ 
+ 	memset(&fl6, 0, sizeof(fl6));
+ 	fl6.flowi6_oif = oif;
+ 	fl6.daddr = *daddr;
+ 	fl6.saddr = vxlan->cfg.saddr.sin6.sin6_addr;
+ 	fl6.flowi6_mark = skb->mark;
+ 	fl6.flowi6_proto = IPPROTO_UDP;
+ 
+ 	err = ipv6_stub->ipv6_dst_lookup(vxlan->net,
+ 					 vxlan->vn6_sock->sock->sk,
+ 					 &ndst, &fl6);
+ 	if (err < 0)
+ 		return ERR_PTR(err);
+ 
+ 	*saddr = fl6.saddr;
+ 	return ndst;
+ }
+ #endif
++>>>>>>> 1a8496ba4091 (vxlan: consolidate output route calculation)
  
  /* Bypass encapsulation if the destination is local */
  static void vxlan_encap_bypass(struct sk_buff *skb, struct vxlan_dev *src_vxlan,
@@@ -1871,13 -1944,15 +1923,12 @@@
  static void vxlan_xmit_one(struct sk_buff *skb, struct net_device *dev,
  			   struct vxlan_rdst *rdst, bool did_rsc)
  {
 -	struct ip_tunnel_info *info;
  	struct vxlan_dev *vxlan = netdev_priv(dev);
 -	struct sock *sk;
 +	struct sock *sk = vxlan->vn_sock->sock->sk;
  	struct rtable *rt = NULL;
  	const struct iphdr *old_iph;
- 	struct flowi4 fl4;
  	union vxlan_addr *dst;
 -	union vxlan_addr remote_ip;
 -	struct vxlan_metadata _md;
 -	struct vxlan_metadata *md = &_md;
 +	struct vxlan_metadata md;
  	__be16 src_port = 0, dst_port;
  	u32 vni;
  	__be16 df = 0;
@@@ -1907,19 -2001,39 +1958,41 @@@
  	if (tos == 1)
  		tos = ip_tunnel_get_dsfield(old_iph, skb);
  
 -	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
 -				     vxlan->cfg.port_max, true);
 -
 -	if (info) {
 -		ttl = info->key.ttl;
 -		tos = info->key.tos;
 -
 -		if (info->options_len)
 -			md = ip_tunnel_info_opts(info);
 -	} else {
 -		md->gbp = skb->mark;
 -	}
 +	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->port_min,
 +				     vxlan->port_max, true);
  
  	if (dst->sa.sa_family == AF_INET) {
++<<<<<<< HEAD
 +		memset(&fl4, 0, sizeof(fl4));
 +		fl4.flowi4_oif = rdst->remote_ifindex;
 +		fl4.flowi4_tos = RT_TOS(tos);
 +		fl4.flowi4_mark = skb->mark;
 +		fl4.flowi4_proto = IPPROTO_UDP;
 +		fl4.daddr = dst->sin.sin_addr.s_addr;
 +		fl4.saddr = vxlan->saddr.sin.sin_addr.s_addr;
 +
 +		rt = ip_route_output_key(vxlan->net, &fl4);
++=======
+ 		__be32 saddr;
+ 
+ 		if (!vxlan->vn4_sock)
+ 			goto drop;
+ 		sk = vxlan->vn4_sock->sock->sk;
+ 
+ 		if (info) {
+ 			if (info->key.tun_flags & TUNNEL_DONT_FRAGMENT)
+ 				df = htons(IP_DF);
+ 
+ 			if (info->key.tun_flags & TUNNEL_CSUM)
+ 				flags |= VXLAN_F_UDP_CSUM;
+ 			else
+ 				flags &= ~VXLAN_F_UDP_CSUM;
+ 		}
+ 
+ 		rt = vxlan_get_route(vxlan, skb,
+ 				     rdst ? rdst->remote_ifindex : 0, tos,
+ 				     dst->sin.sin_addr.s_addr, &saddr);
++>>>>>>> 1a8496ba4091 (vxlan: consolidate output route calculation)
  		if (IS_ERR(rt)) {
  			netdev_dbg(dev, "no route to %pI4\n",
  				   &dst->sin.sin_addr.s_addr);
@@@ -1951,14 -2065,11 +2024,18 @@@
  
  		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip4_dst_hoplimit(&rt->dst);
++<<<<<<< HEAD
 +		md.vni = htonl(vni << 8);
 +		md.gbp = skb->mark;
 +
 +		err = vxlan_xmit_skb(rt, sk, skb, fl4.saddr,
++=======
+ 		err = vxlan_xmit_skb(rt, sk, skb, saddr,
++>>>>>>> 1a8496ba4091 (vxlan: consolidate output route calculation)
  				     dst->sin.sin_addr.s_addr, tos, ttl, df,
 -				     src_port, dst_port, htonl(vni << 8), md,
 +				     src_port, dst_port, &md,
  				     !net_eq(vxlan->net, dev_net(vxlan->dev)),
 -				     flags);
 +				     vxlan->flags);
  		if (err < 0) {
  			/* skb is already freed. */
  			skb = NULL;
@@@ -2290,6 -2406,48 +2367,51 @@@ static int vxlan_change_mtu(struct net_
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int vxlan_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
+ {
+ 	struct vxlan_dev *vxlan = netdev_priv(dev);
+ 	struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 	__be16 sport, dport;
+ 
+ 	sport = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
+ 				  vxlan->cfg.port_max, true);
+ 	dport = info->key.tp_dst ? : vxlan->cfg.dst_port;
+ 
+ 	if (ip_tunnel_info_af(info) == AF_INET) {
+ 		struct rtable *rt;
+ 
+ 		if (!vxlan->vn4_sock)
+ 			return -EINVAL;
+ 		rt = vxlan_get_route(vxlan, skb, 0, info->key.tos,
+ 				     info->key.u.ipv4.dst,
+ 				     &info->key.u.ipv4.src);
+ 		if (IS_ERR(rt))
+ 			return PTR_ERR(rt);
+ 		ip_rt_put(rt);
+ 	} else {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		struct dst_entry *ndst;
+ 
+ 		if (!vxlan->vn6_sock)
+ 			return -EINVAL;
+ 		ndst = vxlan6_get_route(vxlan, skb, 0,
+ 					&info->key.u.ipv6.dst,
+ 					&info->key.u.ipv6.src);
+ 		if (IS_ERR(ndst))
+ 			return PTR_ERR(ndst);
+ 		dst_release(ndst);
+ #else /* !CONFIG_IPV6 */
+ 		return -EPFNOSUPPORT;
+ #endif
+ 	}
+ 	info->key.tp_src = sport;
+ 	info->key.tp_dst = dport;
+ 	return 0;
+ }
+ 
++>>>>>>> 1a8496ba4091 (vxlan: consolidate output route calculation)
  static const struct net_device_ops vxlan_netdev_ops = {
  	.ndo_init		= vxlan_init,
  	.ndo_uninit		= vxlan_uninit,
* Unmerged path drivers/net/vxlan.c
