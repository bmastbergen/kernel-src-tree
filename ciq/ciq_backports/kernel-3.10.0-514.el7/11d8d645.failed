IB/core: Use GRH when the path hop-limit > 0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 11d8d645343efba0c975aefe7c2cf3b33c836c75
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/11d8d645.failed

According to IBTA spec v1.3 section 12.7.19, QPs should use GRH when
the path returned by the SA has hop-limit > 0. Currently, we do that
only for the > 1 case, fix that.

Fixes: 6d969a471ba1 ('IB/sa: Add ib_init_ah_from_path()')
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reviewed-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 11d8d645343efba0c975aefe7c2cf3b33c836c75)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/sa_query.c
diff --cc drivers/infiniband/core/sa_query.c
index f94744352956,1e37f3515d98..000000000000
--- a/drivers/infiniband/core/sa_query.c
+++ b/drivers/infiniband/core/sa_query.c
@@@ -1010,9 -1013,65 +1010,69 @@@ int ib_init_ah_from_path(struct ib_devi
  	ah_attr->port_num = port_num;
  	ah_attr->static_rate = rec->rate;
  
 -	use_roce = rdma_cap_eth_ah(device, port_num);
 +	force_grh = rdma_cap_eth_ah(device, port_num);
  
++<<<<<<< HEAD
 +	if (rec->hop_limit > 1 || force_grh) {
++=======
+ 	if (use_roce) {
+ 		struct net_device *idev;
+ 		struct net_device *resolved_dev;
+ 		struct rdma_dev_addr dev_addr = {.bound_dev_if = rec->ifindex,
+ 						 .net = rec->net ? rec->net :
+ 							 &init_net};
+ 		union {
+ 			struct sockaddr     _sockaddr;
+ 			struct sockaddr_in  _sockaddr_in;
+ 			struct sockaddr_in6 _sockaddr_in6;
+ 		} sgid_addr, dgid_addr;
+ 
+ 		if (!device->get_netdev)
+ 			return -EOPNOTSUPP;
+ 
+ 		rdma_gid2ip(&sgid_addr._sockaddr, &rec->sgid);
+ 		rdma_gid2ip(&dgid_addr._sockaddr, &rec->dgid);
+ 
+ 		/* validate the route */
+ 		ret = rdma_resolve_ip_route(&sgid_addr._sockaddr,
+ 					    &dgid_addr._sockaddr, &dev_addr);
+ 		if (ret)
+ 			return ret;
+ 
+ 		if ((dev_addr.network == RDMA_NETWORK_IPV4 ||
+ 		     dev_addr.network == RDMA_NETWORK_IPV6) &&
+ 		    rec->gid_type != IB_GID_TYPE_ROCE_UDP_ENCAP)
+ 			return -EINVAL;
+ 
+ 		idev = device->get_netdev(device, port_num);
+ 		if (!idev)
+ 			return -ENODEV;
+ 
+ 		resolved_dev = dev_get_by_index(dev_addr.net,
+ 						dev_addr.bound_dev_if);
+ 		if (resolved_dev->flags & IFF_LOOPBACK) {
+ 			dev_put(resolved_dev);
+ 			resolved_dev = idev;
+ 			dev_hold(resolved_dev);
+ 		}
+ 		ndev = ib_get_ndev_from_path(rec);
+ 		rcu_read_lock();
+ 		if ((ndev && ndev != resolved_dev) ||
+ 		    (resolved_dev != idev &&
+ 		     !rdma_is_upper_dev_rcu(idev, resolved_dev)))
+ 			ret = -EHOSTUNREACH;
+ 		rcu_read_unlock();
+ 		dev_put(idev);
+ 		dev_put(resolved_dev);
+ 		if (ret) {
+ 			if (ndev)
+ 				dev_put(ndev);
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	if (rec->hop_limit > 0 || use_roce) {
++>>>>>>> 11d8d645343e (IB/core: Use GRH when the path hop-limit > 0)
  		ah_attr->ah_flags = IB_AH_GRH;
  		ah_attr->grh.dgid = rec->dgid;
  
* Unmerged path drivers/infiniband/core/sa_query.c
