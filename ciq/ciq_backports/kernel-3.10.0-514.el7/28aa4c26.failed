sctp: add SCTP_PR_SUPPORTED on sctp sockopt

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit 28aa4c26fce2202db8d42ae76b639ca1d9a23d25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/28aa4c26.failed

According to section 4.5 of rfc7496, prsctp_enable should be per asoc.
We will add prsctp_enable to both asoc and ep, and replace the places
where it used net.sctp->prsctp_enable with asoc->prsctp_enable.

ep->prsctp_enable will be initialized with net.sctp->prsctp_enable, and
asoc->prsctp_enable will be initialized with ep->prsctp_enable. We can
also modify it's value through sockopt SCTP_PR_SUPPORTED.

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 28aa4c26fce2202db8d42ae76b639ca1d9a23d25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/sm_make_chunk.c
#	net/sctp/socket.c
diff --cc net/sctp/sm_make_chunk.c
index 580d58afabf7,0e3045ef57fa..000000000000
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@@ -1986,25 -2023,24 +1986,46 @@@ static void sctp_process_ext_param(stru
  
  	for (i = 0; i < num_ext; i++) {
  		switch (param.ext->chunks[i]) {
++<<<<<<< HEAD
 +		    case SCTP_CID_FWD_TSN:
 +			    if (net->sctp.prsctp_enable &&
 +				!asoc->peer.prsctp_capable)
 +				    asoc->peer.prsctp_capable = 1;
 +			    break;
 +		    case SCTP_CID_AUTH:
 +			    /* if the peer reports AUTH, assume that he
 +			     * supports AUTH.
 +			     */
 +			    if (asoc->ep->auth_enable)
 +				    asoc->peer.auth_capable = 1;
 +			    break;
 +		    case SCTP_CID_ASCONF:
 +		    case SCTP_CID_ASCONF_ACK:
 +			    if (net->sctp.addip_enable)
 +				    asoc->peer.asconf_capable = 1;
 +			    break;
 +		    default:
 +			    break;
++=======
+ 		case SCTP_CID_FWD_TSN:
+ 			if (asoc->prsctp_enable && !asoc->peer.prsctp_capable)
+ 				asoc->peer.prsctp_capable = 1;
+ 			break;
+ 		case SCTP_CID_AUTH:
+ 			/* if the peer reports AUTH, assume that he
+ 			 * supports AUTH.
+ 			 */
+ 			if (asoc->ep->auth_enable)
+ 				asoc->peer.auth_capable = 1;
+ 			break;
+ 		case SCTP_CID_ASCONF:
+ 		case SCTP_CID_ASCONF_ACK:
+ 			if (net->sctp.addip_enable)
+ 				asoc->peer.asconf_capable = 1;
+ 			break;
+ 		default:
+ 			break;
++>>>>>>> 28aa4c26fce2 (sctp: add SCTP_PR_SUPPORTED on sctp sockopt)
  		}
  	}
  }
diff --cc net/sctp/socket.c
index 34a2b15b5d0d,7460ddebd9ce..000000000000
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@@ -3585,6 -3629,71 +3585,74 @@@ static int sctp_setsockopt_paddr_thresh
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int sctp_setsockopt_recvrcvinfo(struct sock *sk,
+ 				       char __user *optval,
+ 				       unsigned int optlen)
+ {
+ 	int val;
+ 
+ 	if (optlen < sizeof(int))
+ 		return -EINVAL;
+ 	if (get_user(val, (int __user *) optval))
+ 		return -EFAULT;
+ 
+ 	sctp_sk(sk)->recvrcvinfo = (val == 0) ? 0 : 1;
+ 
+ 	return 0;
+ }
+ 
+ static int sctp_setsockopt_recvnxtinfo(struct sock *sk,
+ 				       char __user *optval,
+ 				       unsigned int optlen)
+ {
+ 	int val;
+ 
+ 	if (optlen < sizeof(int))
+ 		return -EINVAL;
+ 	if (get_user(val, (int __user *) optval))
+ 		return -EFAULT;
+ 
+ 	sctp_sk(sk)->recvnxtinfo = (val == 0) ? 0 : 1;
+ 
+ 	return 0;
+ }
+ 
+ static int sctp_setsockopt_pr_supported(struct sock *sk,
+ 					char __user *optval,
+ 					unsigned int optlen)
+ {
+ 	struct sctp_assoc_value params;
+ 	struct sctp_association *asoc;
+ 	int retval = -EINVAL;
+ 
+ 	if (optlen != sizeof(params))
+ 		goto out;
+ 
+ 	if (copy_from_user(&params, optval, optlen)) {
+ 		retval = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	asoc = sctp_id2assoc(sk, params.assoc_id);
+ 	if (asoc) {
+ 		asoc->prsctp_enable = !!params.assoc_value;
+ 	} else if (!params.assoc_id) {
+ 		struct sctp_sock *sp = sctp_sk(sk);
+ 
+ 		sp->ep->prsctp_enable = !!params.assoc_value;
+ 	} else {
+ 		goto out;
+ 	}
+ 
+ 	retval = 0;
+ 
+ out:
+ 	return retval;
+ }
+ 
++>>>>>>> 28aa4c26fce2 (sctp: add SCTP_PR_SUPPORTED on sctp sockopt)
  /* API 6.2 setsockopt(), getsockopt()
   *
   * Applications use setsockopt() and getsockopt() to set or retrieve
@@@ -3737,6 -3848,15 +3805,18 @@@ SCTP_STATIC int sctp_setsockopt(struct 
  	case SCTP_PEER_ADDR_THLDS:
  		retval = sctp_setsockopt_paddr_thresholds(sk, optval, optlen);
  		break;
++<<<<<<< HEAD
++=======
+ 	case SCTP_RECVRCVINFO:
+ 		retval = sctp_setsockopt_recvrcvinfo(sk, optval, optlen);
+ 		break;
+ 	case SCTP_RECVNXTINFO:
+ 		retval = sctp_setsockopt_recvnxtinfo(sk, optval, optlen);
+ 		break;
+ 	case SCTP_PR_SUPPORTED:
+ 		retval = sctp_setsockopt_pr_supported(sk, optval, optlen);
+ 		break;
++>>>>>>> 28aa4c26fce2 (sctp: add SCTP_PR_SUPPORTED on sctp sockopt)
  	default:
  		retval = -ENOPROTOOPT;
  		break;
@@@ -5860,8 -6162,89 +5940,94 @@@ static int sctp_getsockopt_assoc_stats(
  	return 0;
  }
  
++<<<<<<< HEAD
 +SCTP_STATIC int sctp_getsockopt(struct sock *sk, int level, int optname,
 +				char __user *optval, int __user *optlen)
++=======
+ static int sctp_getsockopt_recvrcvinfo(struct sock *sk,	int len,
+ 				       char __user *optval,
+ 				       int __user *optlen)
+ {
+ 	int val = 0;
+ 
+ 	if (len < sizeof(int))
+ 		return -EINVAL;
+ 
+ 	len = sizeof(int);
+ 	if (sctp_sk(sk)->recvrcvinfo)
+ 		val = 1;
+ 	if (put_user(len, optlen))
+ 		return -EFAULT;
+ 	if (copy_to_user(optval, &val, len))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
+ static int sctp_getsockopt_recvnxtinfo(struct sock *sk,	int len,
+ 				       char __user *optval,
+ 				       int __user *optlen)
+ {
+ 	int val = 0;
+ 
+ 	if (len < sizeof(int))
+ 		return -EINVAL;
+ 
+ 	len = sizeof(int);
+ 	if (sctp_sk(sk)->recvnxtinfo)
+ 		val = 1;
+ 	if (put_user(len, optlen))
+ 		return -EFAULT;
+ 	if (copy_to_user(optval, &val, len))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
+ static int sctp_getsockopt_pr_supported(struct sock *sk, int len,
+ 					char __user *optval,
+ 					int __user *optlen)
+ {
+ 	struct sctp_assoc_value params;
+ 	struct sctp_association *asoc;
+ 	int retval = -EFAULT;
+ 
+ 	if (len < sizeof(params)) {
+ 		retval = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	len = sizeof(params);
+ 	if (copy_from_user(&params, optval, len))
+ 		goto out;
+ 
+ 	asoc = sctp_id2assoc(sk, params.assoc_id);
+ 	if (asoc) {
+ 		params.assoc_value = asoc->prsctp_enable;
+ 	} else if (!params.assoc_id) {
+ 		struct sctp_sock *sp = sctp_sk(sk);
+ 
+ 		params.assoc_value = sp->ep->prsctp_enable;
+ 	} else {
+ 		retval = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (put_user(len, optlen))
+ 		goto out;
+ 
+ 	if (copy_to_user(optval, &params, len))
+ 		goto out;
+ 
+ 	retval = 0;
+ 
+ out:
+ 	return retval;
+ }
+ 
+ static int sctp_getsockopt(struct sock *sk, int level, int optname,
+ 			   char __user *optval, int __user *optlen)
++>>>>>>> 28aa4c26fce2 (sctp: add SCTP_PR_SUPPORTED on sctp sockopt)
  {
  	int retval = 0;
  	int len;
@@@ -6004,6 -6390,15 +6170,18 @@@
  	case SCTP_GET_ASSOC_STATS:
  		retval = sctp_getsockopt_assoc_stats(sk, len, optval, optlen);
  		break;
++<<<<<<< HEAD
++=======
+ 	case SCTP_RECVRCVINFO:
+ 		retval = sctp_getsockopt_recvrcvinfo(sk, len, optval, optlen);
+ 		break;
+ 	case SCTP_RECVNXTINFO:
+ 		retval = sctp_getsockopt_recvnxtinfo(sk, len, optval, optlen);
+ 		break;
+ 	case SCTP_PR_SUPPORTED:
+ 		retval = sctp_getsockopt_pr_supported(sk, len, optval, optlen);
+ 		break;
++>>>>>>> 28aa4c26fce2 (sctp: add SCTP_PR_SUPPORTED on sctp sockopt)
  	default:
  		retval = -ENOPROTOOPT;
  		break;
diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7fbce55da678..9b2c949f43c5 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1273,7 +1273,8 @@ struct sctp_endpoint {
 	/* SCTP-AUTH: endpoint shared keys */
 	struct list_head endpoint_shared_keys;
 	__u16 active_key_id;
-	__u8  auth_enable;
+	__u8  auth_enable:1,
+	      prsctp_enable:1;
 };
 
 /* Recover the outter endpoint structure. */
@@ -1865,7 +1866,8 @@ struct sctp_association {
 	__u16 active_key_id;
 
 	__u8 need_ecne:1,	/* Need to send an ECNE Chunk? */
-	     temp:1;		/* Is it a temporary association? */
+	     temp:1,		/* Is it a temporary association? */
+	     prsctp_enable:1;
 
 	struct sctp_priv_assoc_stats stats;
 };
diff --git a/include/uapi/linux/sctp.h b/include/uapi/linux/sctp.h
index 66b466e4ca08..e463f921f1d6 100644
--- a/include/uapi/linux/sctp.h
+++ b/include/uapi/linux/sctp.h
@@ -110,6 +110,7 @@ typedef __s32 sctp_assoc_t;
 #define SCTP_SOCKOPT_CONNECTX	110		/* CONNECTX requests. */
 #define SCTP_SOCKOPT_CONNECTX3	111	/* CONNECTX requests (updated) */
 #define SCTP_GET_ASSOC_STATS	112	/* Read only */
+#define SCTP_PR_SUPPORTED	113
 
 /*
  * 5.2.1 SCTP Initiation Structure (SCTP_INIT)
diff --git a/net/sctp/associola.c b/net/sctp/associola.c
index 8b785f1f0beb..41dd9c492548 100644
--- a/net/sctp/associola.c
+++ b/net/sctp/associola.c
@@ -275,6 +275,7 @@ static struct sctp_association *sctp_association_init(struct sctp_association *a
 		goto fail_init;
 
 	asoc->active_key_id = ep->active_key_id;
+	asoc->prsctp_enable = ep->prsctp_enable;
 
 	/* Save the hmacs and chunks list into this association */
 	if (ep->auth_hmacs_list)
diff --git a/net/sctp/endpointola.c b/net/sctp/endpointola.c
index 000d00e3ee2c..d09019d85384 100644
--- a/net/sctp/endpointola.c
+++ b/net/sctp/endpointola.c
@@ -171,6 +171,7 @@ static struct sctp_endpoint *sctp_endpoint_init(struct sctp_endpoint *ep,
 	 */
 	ep->auth_hmacs_list = auth_hmacs;
 	ep->auth_chunk_list = auth_chunks;
+	ep->prsctp_enable = net->sctp.prsctp_enable;
 
 	return ep;
 
* Unmerged path net/sctp/sm_make_chunk.c
* Unmerged path net/sctp/socket.c
