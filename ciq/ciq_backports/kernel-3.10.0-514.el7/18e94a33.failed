PCI: Make a shareable UUID for PCI firmware ACPI _DSM

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [pci] Make a shareable UUID for PCI firmware ACPI _DSM (Rui Wang) [1225272]
Rebuild_FUZZ: 95.05%
commit-author Aaron Lu <aaron.lu@intel.com>
commit 18e94a3384368340d438cf67fcaebd72084f34f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/18e94a33.failed

The PCI Firmware Specification, r3.0, sec 4.6.4.1.3, defines a single UUID
for an ACPI _DSM method to provide device-specific control functions.  This
_DSM method support several functions, including PCI Express Slot
Information, PCI Express Slot Number, PCI Bus Capabilities, etc.

Move the UUID definition from pci/pci-label.c, where it could be used only
for one function, to pci/pci-acpi.c where it can be shared for all these
functions.

[bhelgaas: changelog]
	Signed-off-by: Aaron Lu <aaron.lu@intel.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 18e94a3384368340d438cf67fcaebd72084f34f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci-acpi.c
diff --cc drivers/pci/pci-acpi.c
index b754f13972a0,bea6be4992c3..000000000000
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@@ -20,18 -18,288 +20,291 @@@
  #include <linux/pm_qos.h>
  #include "pci.h"
  
++<<<<<<< HEAD
++=======
+ /*
+  * The UUID is defined in the PCI Firmware Specification available here:
+  * https://www.pcisig.com/members/downloads/pcifw_r3_1_13Dec10.pdf
+  */
+ const u8 pci_acpi_dsm_uuid[] = {
+ 	0xd0, 0x37, 0xc9, 0xe5, 0x53, 0x35, 0x7a, 0x4d,
+ 	0x91, 0x17, 0xea, 0x4d, 0x19, 0xc3, 0x43, 0x4d
+ };
+ 
+ phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)
+ {
+ 	acpi_status status = AE_NOT_EXIST;
+ 	unsigned long long mcfg_addr;
+ 
+ 	if (handle)
+ 		status = acpi_evaluate_integer(handle, METHOD_NAME__CBA,
+ 					       NULL, &mcfg_addr);
+ 	if (ACPI_FAILURE(status))
+ 		return 0;
+ 
+ 	return (phys_addr_t)mcfg_addr;
+ }
+ 
+ static acpi_status decode_type0_hpx_record(union acpi_object *record,
+ 					   struct hotplug_params *hpx)
+ {
+ 	int i;
+ 	union acpi_object *fields = record->package.elements;
+ 	u32 revision = fields[1].integer.value;
+ 
+ 	switch (revision) {
+ 	case 1:
+ 		if (record->package.count != 6)
+ 			return AE_ERROR;
+ 		for (i = 2; i < 6; i++)
+ 			if (fields[i].type != ACPI_TYPE_INTEGER)
+ 				return AE_ERROR;
+ 		hpx->t0 = &hpx->type0_data;
+ 		hpx->t0->revision        = revision;
+ 		hpx->t0->cache_line_size = fields[2].integer.value;
+ 		hpx->t0->latency_timer   = fields[3].integer.value;
+ 		hpx->t0->enable_serr     = fields[4].integer.value;
+ 		hpx->t0->enable_perr     = fields[5].integer.value;
+ 		break;
+ 	default:
+ 		printk(KERN_WARNING
+ 		       "%s: Type 0 Revision %d record not supported\n",
+ 		       __func__, revision);
+ 		return AE_ERROR;
+ 	}
+ 	return AE_OK;
+ }
+ 
+ static acpi_status decode_type1_hpx_record(union acpi_object *record,
+ 					   struct hotplug_params *hpx)
+ {
+ 	int i;
+ 	union acpi_object *fields = record->package.elements;
+ 	u32 revision = fields[1].integer.value;
+ 
+ 	switch (revision) {
+ 	case 1:
+ 		if (record->package.count != 5)
+ 			return AE_ERROR;
+ 		for (i = 2; i < 5; i++)
+ 			if (fields[i].type != ACPI_TYPE_INTEGER)
+ 				return AE_ERROR;
+ 		hpx->t1 = &hpx->type1_data;
+ 		hpx->t1->revision      = revision;
+ 		hpx->t1->max_mem_read  = fields[2].integer.value;
+ 		hpx->t1->avg_max_split = fields[3].integer.value;
+ 		hpx->t1->tot_max_split = fields[4].integer.value;
+ 		break;
+ 	default:
+ 		printk(KERN_WARNING
+ 		       "%s: Type 1 Revision %d record not supported\n",
+ 		       __func__, revision);
+ 		return AE_ERROR;
+ 	}
+ 	return AE_OK;
+ }
+ 
+ static acpi_status decode_type2_hpx_record(union acpi_object *record,
+ 					   struct hotplug_params *hpx)
+ {
+ 	int i;
+ 	union acpi_object *fields = record->package.elements;
+ 	u32 revision = fields[1].integer.value;
+ 
+ 	switch (revision) {
+ 	case 1:
+ 		if (record->package.count != 18)
+ 			return AE_ERROR;
+ 		for (i = 2; i < 18; i++)
+ 			if (fields[i].type != ACPI_TYPE_INTEGER)
+ 				return AE_ERROR;
+ 		hpx->t2 = &hpx->type2_data;
+ 		hpx->t2->revision      = revision;
+ 		hpx->t2->unc_err_mask_and      = fields[2].integer.value;
+ 		hpx->t2->unc_err_mask_or       = fields[3].integer.value;
+ 		hpx->t2->unc_err_sever_and     = fields[4].integer.value;
+ 		hpx->t2->unc_err_sever_or      = fields[5].integer.value;
+ 		hpx->t2->cor_err_mask_and      = fields[6].integer.value;
+ 		hpx->t2->cor_err_mask_or       = fields[7].integer.value;
+ 		hpx->t2->adv_err_cap_and       = fields[8].integer.value;
+ 		hpx->t2->adv_err_cap_or        = fields[9].integer.value;
+ 		hpx->t2->pci_exp_devctl_and    = fields[10].integer.value;
+ 		hpx->t2->pci_exp_devctl_or     = fields[11].integer.value;
+ 		hpx->t2->pci_exp_lnkctl_and    = fields[12].integer.value;
+ 		hpx->t2->pci_exp_lnkctl_or     = fields[13].integer.value;
+ 		hpx->t2->sec_unc_err_sever_and = fields[14].integer.value;
+ 		hpx->t2->sec_unc_err_sever_or  = fields[15].integer.value;
+ 		hpx->t2->sec_unc_err_mask_and  = fields[16].integer.value;
+ 		hpx->t2->sec_unc_err_mask_or   = fields[17].integer.value;
+ 		break;
+ 	default:
+ 		printk(KERN_WARNING
+ 		       "%s: Type 2 Revision %d record not supported\n",
+ 		       __func__, revision);
+ 		return AE_ERROR;
+ 	}
+ 	return AE_OK;
+ }
+ 
+ static acpi_status acpi_run_hpx(acpi_handle handle, struct hotplug_params *hpx)
+ {
+ 	acpi_status status;
+ 	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+ 	union acpi_object *package, *record, *fields;
+ 	u32 type;
+ 	int i;
+ 
+ 	/* Clear the return buffer with zeros */
+ 	memset(hpx, 0, sizeof(struct hotplug_params));
+ 
+ 	status = acpi_evaluate_object(handle, "_HPX", NULL, &buffer);
+ 	if (ACPI_FAILURE(status))
+ 		return status;
+ 
+ 	package = (union acpi_object *)buffer.pointer;
+ 	if (package->type != ACPI_TYPE_PACKAGE) {
+ 		status = AE_ERROR;
+ 		goto exit;
+ 	}
+ 
+ 	for (i = 0; i < package->package.count; i++) {
+ 		record = &package->package.elements[i];
+ 		if (record->type != ACPI_TYPE_PACKAGE) {
+ 			status = AE_ERROR;
+ 			goto exit;
+ 		}
+ 
+ 		fields = record->package.elements;
+ 		if (fields[0].type != ACPI_TYPE_INTEGER ||
+ 		    fields[1].type != ACPI_TYPE_INTEGER) {
+ 			status = AE_ERROR;
+ 			goto exit;
+ 		}
+ 
+ 		type = fields[0].integer.value;
+ 		switch (type) {
+ 		case 0:
+ 			status = decode_type0_hpx_record(record, hpx);
+ 			if (ACPI_FAILURE(status))
+ 				goto exit;
+ 			break;
+ 		case 1:
+ 			status = decode_type1_hpx_record(record, hpx);
+ 			if (ACPI_FAILURE(status))
+ 				goto exit;
+ 			break;
+ 		case 2:
+ 			status = decode_type2_hpx_record(record, hpx);
+ 			if (ACPI_FAILURE(status))
+ 				goto exit;
+ 			break;
+ 		default:
+ 			printk(KERN_ERR "%s: Type %d record not supported\n",
+ 			       __func__, type);
+ 			status = AE_ERROR;
+ 			goto exit;
+ 		}
+ 	}
+  exit:
+ 	kfree(buffer.pointer);
+ 	return status;
+ }
+ 
+ static acpi_status acpi_run_hpp(acpi_handle handle, struct hotplug_params *hpp)
+ {
+ 	acpi_status status;
+ 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+ 	union acpi_object *package, *fields;
+ 	int i;
+ 
+ 	memset(hpp, 0, sizeof(struct hotplug_params));
+ 
+ 	status = acpi_evaluate_object(handle, "_HPP", NULL, &buffer);
+ 	if (ACPI_FAILURE(status))
+ 		return status;
+ 
+ 	package = (union acpi_object *) buffer.pointer;
+ 	if (package->type != ACPI_TYPE_PACKAGE ||
+ 	    package->package.count != 4) {
+ 		status = AE_ERROR;
+ 		goto exit;
+ 	}
+ 
+ 	fields = package->package.elements;
+ 	for (i = 0; i < 4; i++) {
+ 		if (fields[i].type != ACPI_TYPE_INTEGER) {
+ 			status = AE_ERROR;
+ 			goto exit;
+ 		}
+ 	}
+ 
+ 	hpp->t0 = &hpp->type0_data;
+ 	hpp->t0->revision        = 1;
+ 	hpp->t0->cache_line_size = fields[0].integer.value;
+ 	hpp->t0->latency_timer   = fields[1].integer.value;
+ 	hpp->t0->enable_serr     = fields[2].integer.value;
+ 	hpp->t0->enable_perr     = fields[3].integer.value;
+ 
+ exit:
+ 	kfree(buffer.pointer);
+ 	return status;
+ }
+ 
+ /* pci_get_hp_params
+  *
+  * @dev - the pci_dev for which we want parameters
+  * @hpp - allocated by the caller
+  */
+ int pci_get_hp_params(struct pci_dev *dev, struct hotplug_params *hpp)
+ {
+ 	acpi_status status;
+ 	acpi_handle handle, phandle;
+ 	struct pci_bus *pbus;
+ 
+ 	handle = NULL;
+ 	for (pbus = dev->bus; pbus; pbus = pbus->parent) {
+ 		handle = acpi_pci_get_bridge_handle(pbus);
+ 		if (handle)
+ 			break;
+ 	}
+ 
+ 	/*
+ 	 * _HPP settings apply to all child buses, until another _HPP is
+ 	 * encountered. If we don't find an _HPP for the input pci dev,
+ 	 * look for it in the parent device scope since that would apply to
+ 	 * this pci dev.
+ 	 */
+ 	while (handle) {
+ 		status = acpi_run_hpx(handle, hpp);
+ 		if (ACPI_SUCCESS(status))
+ 			return 0;
+ 		status = acpi_run_hpp(handle, hpp);
+ 		if (ACPI_SUCCESS(status))
+ 			return 0;
+ 		if (acpi_is_root_bridge(handle))
+ 			break;
+ 		status = acpi_get_parent(handle, &phandle);
+ 		if (ACPI_FAILURE(status))
+ 			break;
+ 		handle = phandle;
+ 	}
+ 	return -ENODEV;
+ }
+ EXPORT_SYMBOL_GPL(pci_get_hp_params);
+ 
++>>>>>>> 18e94a338436 (PCI: Make a shareable UUID for PCI firmware ACPI _DSM)
  /**
 - * pci_acpi_wake_bus - Root bus wakeup notification fork function.
 - * @work: Work item to handle.
 + * pci_acpi_wake_bus - Wake-up notification handler for root buses.
 + * @handle: ACPI handle of a device the notification is for.
 + * @event: Type of the signaled event.
 + * @context: PCI root bus to wake up devices on.
   */
 -static void pci_acpi_wake_bus(struct work_struct *work)
 +static void pci_acpi_wake_bus(acpi_handle handle, u32 event, void *context)
  {
 -	struct acpi_device *adev;
 -	struct acpi_pci_root *root;
 +	struct pci_bus *pci_bus = context;
  
 -	adev = container_of(work, struct acpi_device, wakeup.context.work);
 -	root = acpi_driver_data(adev);
 -	pci_pme_wakeup_bus(root->bus);
 +	if (event == ACPI_NOTIFY_DEVICE_WAKE && pci_bus)
 +		pci_pme_wakeup_bus(pci_bus);
  }
  
  /**
* Unmerged path drivers/pci/pci-acpi.c
diff --git a/drivers/pci/pci-label.c b/drivers/pci/pci-label.c
index 647f7fc249a3..93884969acf5 100644
--- a/drivers/pci/pci-label.c
+++ b/drivers/pci/pci-label.c
@@ -32,8 +32,6 @@
 #include <acpi/acpi_bus.h>
 #include "pci.h"
 
-#define	DEVICE_LABEL_DSM	0x07
-
 #ifdef CONFIG_DMI
 enum smbios_attr_enum {
 	SMBIOS_ATTR_NONE = 0,
@@ -149,11 +147,6 @@ static inline void pci_remove_smbiosname_file(struct pci_dev *pdev)
 #endif
 
 #ifdef CONFIG_ACPI
-static const char device_label_dsm_uuid[] = {
-	0xD0, 0x37, 0xC9, 0xE5, 0x53, 0x35, 0x7A, 0x4D,
-	0x91, 0x17, 0xEA, 0x4D, 0x19, 0xC3, 0x43, 0x4D
-};
-
 enum acpi_attr_enum {
 	ACPI_ATTR_LABEL_SHOW,
 	ACPI_ATTR_INDEX_SHOW,
@@ -180,7 +173,7 @@ dsm_get_label(struct device *dev, char *buf, enum acpi_attr_enum attr)
 	if (!handle)
 		return -1;
 
-	obj = acpi_evaluate_dsm(handle, device_label_dsm_uuid, 0x2,
+	obj = acpi_evaluate_dsm(handle, pci_acpi_dsm_uuid, 0x2,
 				DEVICE_LABEL_DSM, NULL);
 	if (!obj)
 		return -1;
@@ -221,7 +214,7 @@ device_has_dsm(struct device *dev)
 	if (!handle)
 		return false;
 
-	return !!acpi_check_dsm(handle, device_label_dsm_uuid, 0x2,
+	return !!acpi_check_dsm(handle, pci_acpi_dsm_uuid, 0x2,
 				1 << DEVICE_LABEL_DSM);
 }
 
diff --git a/include/linux/pci-acpi.h b/include/linux/pci-acpi.h
index 637a608ded0b..f3f14cc79c91 100644
--- a/include/linux/pci-acpi.h
+++ b/include/linux/pci-acpi.h
@@ -67,6 +67,9 @@ static inline void acpiphp_remove_slots(struct pci_bus *bus) { }
 static inline void acpiphp_check_host_bridge(struct acpi_device *adev) { }
 #endif
 
+extern const u8 pci_acpi_dsm_uuid[];
+#define DEVICE_LABEL_DSM	0x07
+
 #else	/* CONFIG_ACPI */
 static inline void acpi_pci_add_bus(struct pci_bus *bus) { }
 static inline void acpi_pci_remove_bus(struct pci_bus *bus) { }
