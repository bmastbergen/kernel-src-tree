seq_file: provide an analogue of print_hex_dump()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 37607102c4426cf92aeb5da1b1d9a79ba6d95e3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/37607102.failed

This introduces a new helper and switches current users to use it.  All
patches are compiled tested. kmemleak is tested via its own test suite.

This patch (of 6):

The new seq_hex_dump() is a complete analogue of print_hex_dump().

We have few users of this functionality already. It allows to reduce their
codebase.

	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Cc: Alexander Viro <viro@zeniv.linux.org.uk>
	Cc: Joe Perches <joe@perches.com>
	Cc: Tadeusz Struk <tadeusz.struk@intel.com>
	Cc: Helge Deller <deller@gmx.de>
	Cc: Ingo Tuchscherer <ingo.tuchscherer@de.ibm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Vladimir Kondratiev <qca_vkondrat@qca.qualcomm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 37607102c4426cf92aeb5da1b1d9a79ba6d95e3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/seq_file.c
diff --cc fs/seq_file.c
index 4f9b03f5e715,263b125dbcf4..000000000000
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@@ -11,9 -11,8 +11,13 @@@
  #include <linux/vmalloc.h>
  #include <linux/slab.h>
  #include <linux/cred.h>
 +#ifndef __GENKSYMS__
  #include <linux/mm.h>
++<<<<<<< HEAD
 +#endif
++=======
+ #include <linux/printk.h>
++>>>>>>> 37607102c442 (seq_file: provide an analogue of print_hex_dump())
  
  #include <asm/uaccess.h>
  #include <asm/page.h>
@@@ -779,6 -759,62 +783,65 @@@ int seq_write(struct seq_file *seq, con
  }
  EXPORT_SYMBOL(seq_write);
  
++<<<<<<< HEAD
++=======
+ /**
+  * seq_pad - write padding spaces to buffer
+  * @m: seq_file identifying the buffer to which data should be written
+  * @c: the byte to append after padding if non-zero
+  */
+ void seq_pad(struct seq_file *m, char c)
+ {
+ 	int size = m->pad_until - m->count;
+ 	if (size > 0)
+ 		seq_printf(m, "%*s", size, "");
+ 	if (c)
+ 		seq_putc(m, c);
+ }
+ EXPORT_SYMBOL(seq_pad);
+ 
+ /* A complete analogue of print_hex_dump() */
+ void seq_hex_dump(struct seq_file *m, const char *prefix_str, int prefix_type,
+ 		  int rowsize, int groupsize, const void *buf, size_t len,
+ 		  bool ascii)
+ {
+ 	const u8 *ptr = buf;
+ 	int i, linelen, remaining = len;
+ 	int ret;
+ 
+ 	if (rowsize != 16 && rowsize != 32)
+ 		rowsize = 16;
+ 
+ 	for (i = 0; i < len && !seq_has_overflowed(m); i += rowsize) {
+ 		linelen = min(remaining, rowsize);
+ 		remaining -= rowsize;
+ 
+ 		switch (prefix_type) {
+ 		case DUMP_PREFIX_ADDRESS:
+ 			seq_printf(m, "%s%p: ", prefix_str, ptr + i);
+ 			break;
+ 		case DUMP_PREFIX_OFFSET:
+ 			seq_printf(m, "%s%.8x: ", prefix_str, i);
+ 			break;
+ 		default:
+ 			seq_printf(m, "%s", prefix_str);
+ 			break;
+ 		}
+ 
+ 		ret = hex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,
+ 					 m->buf + m->count, m->size - m->count,
+ 					 ascii);
+ 		if (ret >= m->size - m->count) {
+ 			seq_set_overflow(m);
+ 		} else {
+ 			m->count += ret;
+ 			seq_putc(m, '\n');
+ 		}
+ 	}
+ }
+ EXPORT_SYMBOL(seq_hex_dump);
+ 
++>>>>>>> 37607102c442 (seq_file: provide an analogue of print_hex_dump())
  struct list_head *seq_list_start(struct list_head *head, loff_t pos)
  {
  	struct list_head *lh;
* Unmerged path fs/seq_file.c
diff --git a/include/linux/seq_file.h b/include/linux/seq_file.h
index 81d163a80b66..7001638fa47d 100644
--- a/include/linux/seq_file.h
+++ b/include/linux/seq_file.h
@@ -107,6 +107,10 @@ int seq_write(struct seq_file *seq, const void *data, size_t len);
 __printf(2, 3) int seq_printf(struct seq_file *, const char *, ...);
 __printf(2, 0) int seq_vprintf(struct seq_file *, const char *, va_list args);
 
+void seq_hex_dump(struct seq_file *m, const char *prefix_str, int prefix_type,
+		  int rowsize, int groupsize, const void *buf, size_t len,
+		  bool ascii);
+
 int seq_path(struct seq_file *, const struct path *, const char *);
 int seq_dentry(struct seq_file *, struct dentry *, const char *);
 int seq_path_root(struct seq_file *m, const struct path *path,
