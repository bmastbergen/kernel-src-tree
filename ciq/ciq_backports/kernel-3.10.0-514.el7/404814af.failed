net: cdc_ncm: add "ndp_to_end" sysfs attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [netdrv] cdc_ncm: add "ndp_to_end" sysfs attribute (Torez Smith) [1332712]
Rebuild_FUZZ: 94.25%
commit-author Bjørn Mork <bjorn@mork.no>
commit 404814af69d4732276319b90886b81fb2884ae1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/404814af.failed

Adding a writable sysfs attribute for the "NDP to end"
quirk flag.

This makes it easier for end users to test new devices for
this firmware bug.  We've been lucky so far, but we should
not depend on reporters capable of rebuilding the driver.

	Cc: Enrico Mioso <mrkiko.rs@gmail.com>
	Signed-off-by: Bjørn Mork <bjorn@mork.no>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 404814af69d4732276319b90886b81fb2884ae1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/ABI/testing/sysfs-class-net-cdc_ncm
#	drivers/net/usb/cdc_ncm.c
diff --cc drivers/net/usb/cdc_ncm.c
index c2daf4f807ef,b45e5cae2a6b..000000000000
--- a/drivers/net/usb/cdc_ncm.c
+++ b/drivers/net/usb/cdc_ncm.c
@@@ -68,31 -65,427 +68,262 @@@ static void cdc_ncm_tx_timeout_start(st
  static enum hrtimer_restart cdc_ncm_tx_timer_cb(struct hrtimer *hr_timer);
  static struct usb_driver cdc_ncm_driver;
  
 -struct cdc_ncm_stats {
 -	char stat_string[ETH_GSTRING_LEN];
 -	int sizeof_stat;
 -	int stat_offset;
 -};
 -
 -#define CDC_NCM_STAT(str, m) { \
 -		.stat_string = str, \
 -		.sizeof_stat = sizeof(((struct cdc_ncm_ctx *)0)->m), \
 -		.stat_offset = offsetof(struct cdc_ncm_ctx, m) }
 -#define CDC_NCM_SIMPLE_STAT(m)	CDC_NCM_STAT(__stringify(m), m)
 -
 -static const struct cdc_ncm_stats cdc_ncm_gstrings_stats[] = {
 -	CDC_NCM_SIMPLE_STAT(tx_reason_ntb_full),
 -	CDC_NCM_SIMPLE_STAT(tx_reason_ndp_full),
 -	CDC_NCM_SIMPLE_STAT(tx_reason_timeout),
 -	CDC_NCM_SIMPLE_STAT(tx_reason_max_datagram),
 -	CDC_NCM_SIMPLE_STAT(tx_overhead),
 -	CDC_NCM_SIMPLE_STAT(tx_ntbs),
 -	CDC_NCM_SIMPLE_STAT(rx_overhead),
 -	CDC_NCM_SIMPLE_STAT(rx_ntbs),
 -};
 -
 -static int cdc_ncm_get_sset_count(struct net_device __always_unused *netdev, int sset)
 -{
 -	switch (sset) {
 -	case ETH_SS_STATS:
 -		return ARRAY_SIZE(cdc_ncm_gstrings_stats);
 -	default:
 -		return -EOPNOTSUPP;
 -	}
 -}
 -
 -static void cdc_ncm_get_ethtool_stats(struct net_device *netdev,
 -				    struct ethtool_stats __always_unused *stats,
 -				    u64 *data)
 +static void
 +cdc_ncm_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
  {
 -	struct usbnet *dev = netdev_priv(netdev);
 -	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
 -	int i;
 -	char *p = NULL;
 +	struct usbnet *dev = netdev_priv(net);
  
 -	for (i = 0; i < ARRAY_SIZE(cdc_ncm_gstrings_stats); i++) {
 -		p = (char *)ctx + cdc_ncm_gstrings_stats[i].stat_offset;
 -		data[i] = (cdc_ncm_gstrings_stats[i].sizeof_stat == sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
 -	}
 -}
 -
 -static void cdc_ncm_get_strings(struct net_device __always_unused *netdev, u32 stringset, u8 *data)
 -{
 -	u8 *p = data;
 -	int i;
 -
 -	switch (stringset) {
 -	case ETH_SS_STATS:
 -		for (i = 0; i < ARRAY_SIZE(cdc_ncm_gstrings_stats); i++) {
 -			memcpy(p, cdc_ncm_gstrings_stats[i].stat_string, ETH_GSTRING_LEN);
 -			p += ETH_GSTRING_LEN;
 -		}
 -	}
 +	strlcpy(info->driver, dev->driver_name, sizeof(info->driver));
 +	strlcpy(info->version, DRIVER_VERSION, sizeof(info->version));
 +	strlcpy(info->fw_version, dev->driver_info->description,
 +		sizeof(info->fw_version));
 +	usb_make_path(dev->udev, info->bus_info, sizeof(info->bus_info));
  }
  
 -static void cdc_ncm_update_rxtx_max(struct usbnet *dev, u32 new_rx, u32 new_tx);
 -
 -static const struct ethtool_ops cdc_ncm_ethtool_ops = {
 -	.get_settings      = usbnet_get_settings,
 -	.set_settings      = usbnet_set_settings,
 -	.get_link          = usbnet_get_link,
 -	.nway_reset        = usbnet_nway_reset,
 -	.get_drvinfo       = usbnet_get_drvinfo,
 -	.get_msglevel      = usbnet_get_msglevel,
 -	.set_msglevel      = usbnet_set_msglevel,
 -	.get_ts_info       = ethtool_op_get_ts_info,
 -	.get_sset_count    = cdc_ncm_get_sset_count,
 -	.get_strings       = cdc_ncm_get_strings,
 -	.get_ethtool_stats = cdc_ncm_get_ethtool_stats,
 -};
 -
 -static u32 cdc_ncm_check_rx_max(struct usbnet *dev, u32 new_rx)
 +static u8 cdc_ncm_setup(struct usbnet *dev)
  {
  	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
++<<<<<<< HEAD
++=======
+ 	u32 val, max, min;
+ 
+ 	/* clamp new_rx to sane values */
+ 	min = USB_CDC_NCM_NTB_MIN_IN_SIZE;
+ 	max = min_t(u32, CDC_NCM_NTB_MAX_SIZE_RX, le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize));
+ 
+ 	/* dwNtbInMaxSize spec violation? Use MIN size for both limits */
+ 	if (max < min) {
+ 		dev_warn(&dev->intf->dev, "dwNtbInMaxSize=%u is too small. Using %u\n",
+ 			 le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize), min);
+ 		max = min;
+ 	}
+ 
+ 	val = clamp_t(u32, new_rx, min, max);
+ 	if (val != new_rx)
+ 		dev_dbg(&dev->intf->dev, "rx_max must be in the [%u, %u] range\n", min, max);
+ 
+ 	return val;
+ }
+ 
+ static u32 cdc_ncm_check_tx_max(struct usbnet *dev, u32 new_tx)
+ {
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 	u32 val, max, min;
+ 
+ 	/* clamp new_tx to sane values */
+ 	min = ctx->max_datagram_size + ctx->max_ndp_size + sizeof(struct usb_cdc_ncm_nth16);
+ 	max = min_t(u32, CDC_NCM_NTB_MAX_SIZE_TX, le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize));
+ 
+ 	/* some devices set dwNtbOutMaxSize too low for the above default */
+ 	min = min(min, max);
+ 
+ 	val = clamp_t(u32, new_tx, min, max);
+ 	if (val != new_tx)
+ 		dev_dbg(&dev->intf->dev, "tx_max must be in the [%u, %u] range\n", min, max);
+ 
+ 	return val;
+ }
+ 
+ static ssize_t cdc_ncm_show_min_tx_pkt(struct device *d, struct device_attribute *attr, char *buf)
+ {
+ 	struct usbnet *dev = netdev_priv(to_net_dev(d));
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 
+ 	return sprintf(buf, "%u\n", ctx->min_tx_pkt);
+ }
+ 
+ static ssize_t cdc_ncm_show_rx_max(struct device *d, struct device_attribute *attr, char *buf)
+ {
+ 	struct usbnet *dev = netdev_priv(to_net_dev(d));
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 
+ 	return sprintf(buf, "%u\n", ctx->rx_max);
+ }
+ 
+ static ssize_t cdc_ncm_show_tx_max(struct device *d, struct device_attribute *attr, char *buf)
+ {
+ 	struct usbnet *dev = netdev_priv(to_net_dev(d));
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 
+ 	return sprintf(buf, "%u\n", ctx->tx_max);
+ }
+ 
+ static ssize_t cdc_ncm_show_tx_timer_usecs(struct device *d, struct device_attribute *attr, char *buf)
+ {
+ 	struct usbnet *dev = netdev_priv(to_net_dev(d));
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 
+ 	return sprintf(buf, "%u\n", ctx->timer_interval / (u32)NSEC_PER_USEC);
+ }
+ 
+ static ssize_t cdc_ncm_store_min_tx_pkt(struct device *d,  struct device_attribute *attr, const char *buf, size_t len)
+ {
+ 	struct usbnet *dev = netdev_priv(to_net_dev(d));
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 	unsigned long val;
+ 
+ 	/* no need to restrict values - anything from 0 to infinity is OK */
+ 	if (kstrtoul(buf, 0, &val))
+ 		return -EINVAL;
+ 
+ 	ctx->min_tx_pkt = val;
+ 	return len;
+ }
+ 
+ static ssize_t cdc_ncm_store_rx_max(struct device *d,  struct device_attribute *attr, const char *buf, size_t len)
+ {
+ 	struct usbnet *dev = netdev_priv(to_net_dev(d));
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 	unsigned long val;
+ 
+ 	if (kstrtoul(buf, 0, &val) || cdc_ncm_check_rx_max(dev, val) != val)
+ 		return -EINVAL;
+ 
+ 	cdc_ncm_update_rxtx_max(dev, val, ctx->tx_max);
+ 	return len;
+ }
+ 
+ static ssize_t cdc_ncm_store_tx_max(struct device *d,  struct device_attribute *attr, const char *buf, size_t len)
+ {
+ 	struct usbnet *dev = netdev_priv(to_net_dev(d));
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 	unsigned long val;
+ 
+ 	if (kstrtoul(buf, 0, &val) || cdc_ncm_check_tx_max(dev, val) != val)
+ 		return -EINVAL;
+ 
+ 	cdc_ncm_update_rxtx_max(dev, ctx->rx_max, val);
+ 	return len;
+ }
+ 
+ static ssize_t cdc_ncm_store_tx_timer_usecs(struct device *d,  struct device_attribute *attr, const char *buf, size_t len)
+ {
+ 	struct usbnet *dev = netdev_priv(to_net_dev(d));
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 	ssize_t ret;
+ 	unsigned long val;
+ 
+ 	ret = kstrtoul(buf, 0, &val);
+ 	if (ret)
+ 		return ret;
+ 	if (val && (val < CDC_NCM_TIMER_INTERVAL_MIN || val > CDC_NCM_TIMER_INTERVAL_MAX))
+ 		return -EINVAL;
+ 
+ 	spin_lock_bh(&ctx->mtx);
+ 	ctx->timer_interval = val * NSEC_PER_USEC;
+ 	if (!ctx->timer_interval)
+ 		ctx->tx_timer_pending = 0;
+ 	spin_unlock_bh(&ctx->mtx);
+ 	return len;
+ }
+ 
+ static DEVICE_ATTR(min_tx_pkt, S_IRUGO | S_IWUSR, cdc_ncm_show_min_tx_pkt, cdc_ncm_store_min_tx_pkt);
+ static DEVICE_ATTR(rx_max, S_IRUGO | S_IWUSR, cdc_ncm_show_rx_max, cdc_ncm_store_rx_max);
+ static DEVICE_ATTR(tx_max, S_IRUGO | S_IWUSR, cdc_ncm_show_tx_max, cdc_ncm_store_tx_max);
+ static DEVICE_ATTR(tx_timer_usecs, S_IRUGO | S_IWUSR, cdc_ncm_show_tx_timer_usecs, cdc_ncm_store_tx_timer_usecs);
+ 
+ static ssize_t ndp_to_end_show(struct device *d, struct device_attribute *attr, char *buf)
+ {
+ 	struct usbnet *dev = netdev_priv(to_net_dev(d));
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 
+ 	return sprintf(buf, "%c\n", ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END ? 'Y' : 'N');
+ }
+ 
+ static ssize_t ndp_to_end_store(struct device *d,  struct device_attribute *attr, const char *buf, size_t len)
+ {
+ 	struct usbnet *dev = netdev_priv(to_net_dev(d));
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 	bool enable;
+ 
+ 	if (strtobool(buf, &enable))
+ 		return -EINVAL;
+ 
+ 	/* no change? */
+ 	if (enable == (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END))
+ 		return len;
+ 
+ 	if (enable && !ctx->delayed_ndp16) {
+ 		ctx->delayed_ndp16 = kzalloc(ctx->max_ndp_size, GFP_KERNEL);
+ 		if (!ctx->delayed_ndp16)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	/* flush pending data before changing flag */
+ 	netif_tx_lock_bh(dev->net);
+ 	usbnet_start_xmit(NULL, dev->net);
+ 	spin_lock_bh(&ctx->mtx);
+ 	if (enable)
+ 		ctx->drvflags |= CDC_NCM_FLAG_NDP_TO_END;
+ 	else
+ 		ctx->drvflags &= ~CDC_NCM_FLAG_NDP_TO_END;
+ 	spin_unlock_bh(&ctx->mtx);
+ 	netif_tx_unlock_bh(dev->net);
+ 
+ 	return len;
+ }
+ static DEVICE_ATTR_RW(ndp_to_end);
+ 
+ #define NCM_PARM_ATTR(name, format, tocpu)				\
+ static ssize_t cdc_ncm_show_##name(struct device *d, struct device_attribute *attr, char *buf) \
+ { \
+ 	struct usbnet *dev = netdev_priv(to_net_dev(d)); \
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0]; \
+ 	return sprintf(buf, format "\n", tocpu(ctx->ncm_parm.name));	\
+ } \
+ static DEVICE_ATTR(name, S_IRUGO, cdc_ncm_show_##name, NULL)
+ 
+ NCM_PARM_ATTR(bmNtbFormatsSupported, "0x%04x", le16_to_cpu);
+ NCM_PARM_ATTR(dwNtbInMaxSize, "%u", le32_to_cpu);
+ NCM_PARM_ATTR(wNdpInDivisor, "%u", le16_to_cpu);
+ NCM_PARM_ATTR(wNdpInPayloadRemainder, "%u", le16_to_cpu);
+ NCM_PARM_ATTR(wNdpInAlignment, "%u", le16_to_cpu);
+ NCM_PARM_ATTR(dwNtbOutMaxSize, "%u", le32_to_cpu);
+ NCM_PARM_ATTR(wNdpOutDivisor, "%u", le16_to_cpu);
+ NCM_PARM_ATTR(wNdpOutPayloadRemainder, "%u", le16_to_cpu);
+ NCM_PARM_ATTR(wNdpOutAlignment, "%u", le16_to_cpu);
+ NCM_PARM_ATTR(wNtbOutMaxDatagrams, "%u", le16_to_cpu);
+ 
+ static struct attribute *cdc_ncm_sysfs_attrs[] = {
+ 	&dev_attr_min_tx_pkt.attr,
+ 	&dev_attr_ndp_to_end.attr,
+ 	&dev_attr_rx_max.attr,
+ 	&dev_attr_tx_max.attr,
+ 	&dev_attr_tx_timer_usecs.attr,
+ 	&dev_attr_bmNtbFormatsSupported.attr,
+ 	&dev_attr_dwNtbInMaxSize.attr,
+ 	&dev_attr_wNdpInDivisor.attr,
+ 	&dev_attr_wNdpInPayloadRemainder.attr,
+ 	&dev_attr_wNdpInAlignment.attr,
+ 	&dev_attr_dwNtbOutMaxSize.attr,
+ 	&dev_attr_wNdpOutDivisor.attr,
+ 	&dev_attr_wNdpOutPayloadRemainder.attr,
+ 	&dev_attr_wNdpOutAlignment.attr,
+ 	&dev_attr_wNtbOutMaxDatagrams.attr,
+ 	NULL,
+ };
+ 
+ static struct attribute_group cdc_ncm_sysfs_attr_group = {
+ 	.name = "cdc_ncm",
+ 	.attrs = cdc_ncm_sysfs_attrs,
+ };
+ 
+ /* handle rx_max and tx_max changes */
+ static void cdc_ncm_update_rxtx_max(struct usbnet *dev, u32 new_rx, u32 new_tx)
+ {
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 	u8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;
++>>>>>>> 404814af69d4 (net: cdc_ncm: add "ndp_to_end" sysfs attribute)
  	u32 val;
 -
 -	val = cdc_ncm_check_rx_max(dev, new_rx);
 -
 -	/* inform device about NTB input size changes */
 -	if (val != ctx->rx_max) {
 -		__le32 dwNtbInMaxSize = cpu_to_le32(val);
 -
 -		dev_info(&dev->intf->dev, "setting rx_max = %u\n", val);
 -
 -		/* tell device to use new size */
 -		if (usbnet_write_cmd(dev, USB_CDC_SET_NTB_INPUT_SIZE,
 -				     USB_TYPE_CLASS | USB_DIR_OUT
 -				     | USB_RECIP_INTERFACE,
 -				     0, iface_no, &dwNtbInMaxSize, 4) < 0)
 -			dev_dbg(&dev->intf->dev, "Setting NTB Input Size failed\n");
 -		else
 -			ctx->rx_max = val;
 -	}
 -
 -	/* usbnet use these values for sizing rx queues */
 -	if (dev->rx_urb_size != ctx->rx_max) {
 -		dev->rx_urb_size = ctx->rx_max;
 -		if (netif_running(dev->net))
 -			usbnet_unlink_rx_urbs(dev);
 -	}
 -
 -	val = cdc_ncm_check_tx_max(dev, new_tx);
 -	if (val != ctx->tx_max)
 -		dev_info(&dev->intf->dev, "setting tx_max = %u\n", val);
 -
 -	/* Adding a pad byte here if necessary simplifies the handling
 -	 * in cdc_ncm_fill_tx_frame, making tx_max always represent
 -	 * the real skb max size.
 -	 *
 -	 * We cannot use dev->maxpacket here because this is called from
 -	 * .bind which is called before usbnet sets up dev->maxpacket
 -	 */
 -	if (val != le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize) &&
 -	    val % usb_maxpacket(dev->udev, dev->out, 1) == 0)
 -		val++;
 -
 -	/* we might need to flush any pending tx buffers if running */
 -	if (netif_running(dev->net) && val > ctx->tx_max) {
 -		netif_tx_lock_bh(dev->net);
 -		usbnet_start_xmit(NULL, dev->net);
 -		/* make sure tx_curr_skb is reallocated if it was empty */
 -		if (ctx->tx_curr_skb) {
 -			dev_kfree_skb_any(ctx->tx_curr_skb);
 -			ctx->tx_curr_skb = NULL;
 -		}
 -		ctx->tx_max = val;
 -		netif_tx_unlock_bh(dev->net);
 -	} else {
 -		ctx->tx_max = val;
 -	}
 -
 -	dev->hard_mtu = ctx->tx_max;
 -
 -	/* max qlen depend on hard_mtu and rx_urb_size */
 -	usbnet_update_max_qlen(dev);
 -
 -	/* never pad more than 3 full USB packets per transfer */
 -	ctx->min_tx_pkt = clamp_t(u16, ctx->tx_max - 3 * usb_maxpacket(dev->udev, dev->out, 1),
 -				  CDC_NCM_MIN_TX_PKT, ctx->tx_max);
 -}
 -
 -/* helpers for NCM and MBIM differences */
 -static u8 cdc_ncm_flags(struct usbnet *dev)
 -{
 -	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
 -
 -	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting) && ctx->mbim_desc)
 -		return ctx->mbim_desc->bmNetworkCapabilities;
 -	if (ctx->func_desc)
 -		return ctx->func_desc->bmNetworkCapabilities;
 -	return 0;
 -}
 -
 -static int cdc_ncm_eth_hlen(struct usbnet *dev)
 -{
 -	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting))
 -		return 0;
 -	return ETH_HLEN;
 -}
 -
 -static u32 cdc_ncm_min_dgram_size(struct usbnet *dev)
 -{
 -	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting))
 -		return CDC_MBIM_MIN_DATAGRAM_SIZE;
 -	return CDC_NCM_MIN_DATAGRAM_SIZE;
 -}
 -
 -static u32 cdc_ncm_max_dgram_size(struct usbnet *dev)
 -{
 -	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
 -
 -	if (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting) && ctx->mbim_desc)
 -		return le16_to_cpu(ctx->mbim_desc->wMaxSegmentSize);
 -	if (ctx->ether_desc)
 -		return le16_to_cpu(ctx->ether_desc->wMaxSegmentSize);
 -	return CDC_NCM_MAX_DATAGRAM_SIZE;
 -}
 -
 -/* initial one-time device setup.  MUST be called with the data interface
 - * in altsetting 0
 - */
 -static int cdc_ncm_init(struct usbnet *dev)
 -{
 -	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
 -	u8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;
 +	u8 flags;
 +	u8 iface_no;
  	int err;
 +	int eth_hlen;
 +	u16 mbim_mtu;
 +	u16 ntb_fmt_supported;
 +	__le16 max_datagram_size;
 +
 +	iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;
  
  	err = usbnet_read_cmd(dev, USB_CDC_GET_NTB_PARAMETERS,
  			      USB_TYPE_CLASS | USB_DIR_IN
* Unmerged path Documentation/ABI/testing/sysfs-class-net-cdc_ncm
* Unmerged path Documentation/ABI/testing/sysfs-class-net-cdc_ncm
* Unmerged path drivers/net/usb/cdc_ncm.c
