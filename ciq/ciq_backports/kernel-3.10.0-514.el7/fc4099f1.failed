openvswitch: Fix egress tunnel info.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] openvswitch: Fix egress tunnel info (Lance Richardson) [1283886]
Rebuild_FUZZ: 98.59%
commit-author Pravin B Shelar <pshelar@nicira.com>
commit fc4099f17240767554ff3a73977acb78ef615404
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fc4099f1.failed

While transitioning to netdev based vport we broke OVS
feature which allows user to retrieve tunnel packet egress
information for lwtunnel devices.  Following patch fixes it
by introducing ndo operation to get the tunnel egress info.
Same ndo operation can be used for lwtunnel devices and compat
ovs-tnl-vport devices. So after adding such device operation
we can remove similar operation from ovs-vport.

Fixes: 614732eaa12d ("openvswitch: Use regular VXLAN net_device device").
	Signed-off-by: Pravin B Shelar <pshelar@nicira.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fc4099f17240767554ff3a73977acb78ef615404)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	include/net/dst_metadata.h
#	net/ipv4/ip_gre.c
#	net/openvswitch/actions.c
#	net/openvswitch/datapath.c
#	net/openvswitch/datapath.h
#	net/openvswitch/flow_netlink.c
#	net/openvswitch/flow_netlink.h
#	net/openvswitch/vport-geneve.c
#	net/openvswitch/vport-gre.c
#	net/openvswitch/vport-vxlan.c
#	net/openvswitch/vport.c
#	net/openvswitch/vport.h
diff --cc include/linux/netdevice.h
index f42ad8e42b23,210d11a75e4f..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1006,9 -1043,22 +1006,27 @@@ struct netdev_phys_port_id 
   *	be otherwise expressed by feature flags. The check is called with
   *	the set of features that the stack has calculated and it returns
   *	those the driver believes to be appropriate.
++<<<<<<< HEAD
++=======
+  * int (*ndo_set_tx_maxrate)(struct net_device *dev,
+  *			     int queue_index, u32 maxrate);
+  *	Called when a user wants to set a max-rate limitation of specific
+  *	TX queue.
+  * int (*ndo_get_iflink)(const struct net_device *dev);
+  *	Called to get the iflink value of this device.
+  * void (*ndo_change_proto_down)(struct net_device *dev,
+  *				  bool proto_down);
+  *	This function is used to pass protocol port error state information
+  *	to the switch driver. The switch driver can react to the proto_down
+  *      by doing a phys down on the associated switch port.
+  * int (*ndo_fill_metadata_dst)(struct net_device *dev, struct sk_buff *skb);
+  *	This function is used to get egress tunnel information for given skb.
+  *	This is useful for retrieving outer tunnel header parameters while
+  *	sampling packet.
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
   *
 + * int (*ndo_set_vf_rate)(struct net_device *dev, int vf, int min_tx_rate,
 + *			  int max_tx_rate);
   */
  struct net_device_ops {
  	int			(*ndo_init)(struct net_device *dev);
@@@ -1146,39 -1213,26 +1164,57 @@@
  						      sa_family_t sa_family,
  						      __be16 port);
  
 -	void*			(*ndo_dfwd_add_station)(struct net_device *pdev,
 -							struct net_device *dev);
 -	void			(*ndo_dfwd_del_station)(struct net_device *pdev,
 -							void *priv);
 -
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_USE_P(1, int	(*ndo_get_iflink)(const struct net_device *dev))
 +	RH_KABI_USE_P(2, netdev_features_t
 +				(*ndo_features_check)(struct sk_buff *skb,
 +						      struct net_device *dev,
 +						      netdev_features_t features))
 +	RH_KABI_USE_P(3, int	(*ndo_set_vf_rate)(struct net_device *dev,
 +						   int vf, int min_tx_rate,
 +						   int max_tx_rate))
 +	RH_KABI_USE_P(4, int	(*ndo_get_vf_stats)(struct net_device *dev,
 +						    int vf,
 +						    struct ifla_vf_stats
 +						    *vf_stats))
 +	RH_KABI_USE_P(5, int    (*ndo_set_vf_rss_query_en)(struct net_device *dev,
 +							   int vf, bool setting))
 +
++<<<<<<< HEAD
 +	RH_KABI_RESERVE_P(6)
 +	RH_KABI_RESERVE_P(7)
 +	RH_KABI_RESERVE_P(8)
 +	RH_KABI_RESERVE_P(9)
 +	RH_KABI_RESERVE_P(10)
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_RESERVE_P(16)
++=======
+ 	netdev_tx_t		(*ndo_dfwd_start_xmit) (struct sk_buff *skb,
+ 							struct net_device *dev,
+ 							void *priv);
+ 	int			(*ndo_get_lock_subclass)(struct net_device *dev);
+ 	netdev_features_t	(*ndo_features_check) (struct sk_buff *skb,
+ 						       struct net_device *dev,
+ 						       netdev_features_t features);
+ 	int			(*ndo_set_tx_maxrate)(struct net_device *dev,
+ 						      int queue_index,
+ 						      u32 maxrate);
+ 	int			(*ndo_get_iflink)(const struct net_device *dev);
+ 	int			(*ndo_change_proto_down)(struct net_device *dev,
+ 							 bool proto_down);
+ 	int			(*ndo_fill_metadata_dst)(struct net_device *dev,
+ 						       struct sk_buff *skb);
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
  };
  
  /**
@@@ -2011,9 -2207,9 +2047,10 @@@ void dev_remove_pack(struct packet_typ
  void __dev_remove_pack(struct packet_type *pt);
  void dev_add_offload(struct packet_offload *po);
  void dev_remove_offload(struct packet_offload *po);
 +void __dev_remove_offload(struct packet_offload *po);
  
  int dev_get_iflink(const struct net_device *dev);
+ int dev_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb);
  struct net_device *__dev_get_by_flags(struct net *net, unsigned short flags,
  				      unsigned short mask);
  struct net_device *dev_get_by_name(struct net *net, const char *name);
diff --cc net/ipv4/ip_gre.c
index afc4a83f7ee7,614521437e30..000000000000
--- a/net/ipv4/ip_gre.c
+++ b/net/ipv4/ip_gre.c
@@@ -246,6 -490,109 +246,111 @@@ static void __gre_xmit(struct sk_buff *
  	ip_tunnel_xmit(skb, dev, tnl_params, tnl_params->protocol);
  }
  
++<<<<<<< HEAD
++=======
+ static struct sk_buff *gre_handle_offloads(struct sk_buff *skb,
+ 					   bool csum)
+ {
+ 	return iptunnel_handle_offloads(skb, csum,
+ 					csum ? SKB_GSO_GRE_CSUM : SKB_GSO_GRE);
+ }
+ 
+ static struct rtable *gre_get_rt(struct sk_buff *skb,
+ 				 struct net_device *dev,
+ 				 struct flowi4 *fl,
+ 				 const struct ip_tunnel_key *key)
+ {
+ 	struct net *net = dev_net(dev);
+ 
+ 	memset(fl, 0, sizeof(*fl));
+ 	fl->daddr = key->u.ipv4.dst;
+ 	fl->saddr = key->u.ipv4.src;
+ 	fl->flowi4_tos = RT_TOS(key->tos);
+ 	fl->flowi4_mark = skb->mark;
+ 	fl->flowi4_proto = IPPROTO_GRE;
+ 
+ 	return ip_route_output_key(net, fl);
+ }
+ 
+ static void gre_fb_xmit(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct ip_tunnel_info *tun_info;
+ 	const struct ip_tunnel_key *key;
+ 	struct flowi4 fl;
+ 	struct rtable *rt;
+ 	int min_headroom;
+ 	int tunnel_hlen;
+ 	__be16 df, flags;
+ 	int err;
+ 
+ 	tun_info = skb_tunnel_info(skb);
+ 	if (unlikely(!tun_info || !(tun_info->mode & IP_TUNNEL_INFO_TX) ||
+ 		     ip_tunnel_info_af(tun_info) != AF_INET))
+ 		goto err_free_skb;
+ 
+ 	key = &tun_info->key;
+ 	rt = gre_get_rt(skb, dev, &fl, key);
+ 	if (IS_ERR(rt))
+ 		goto err_free_skb;
+ 
+ 	tunnel_hlen = ip_gre_calc_hlen(key->tun_flags);
+ 
+ 	min_headroom = LL_RESERVED_SPACE(rt->dst.dev) + rt->dst.header_len
+ 			+ tunnel_hlen + sizeof(struct iphdr);
+ 	if (skb_headroom(skb) < min_headroom || skb_header_cloned(skb)) {
+ 		int head_delta = SKB_DATA_ALIGN(min_headroom -
+ 						skb_headroom(skb) +
+ 						16);
+ 		err = pskb_expand_head(skb, max_t(int, head_delta, 0),
+ 				       0, GFP_ATOMIC);
+ 		if (unlikely(err))
+ 			goto err_free_rt;
+ 	}
+ 
+ 	/* Push Tunnel header. */
+ 	skb = gre_handle_offloads(skb, !!(tun_info->key.tun_flags & TUNNEL_CSUM));
+ 	if (IS_ERR(skb)) {
+ 		skb = NULL;
+ 		goto err_free_rt;
+ 	}
+ 
+ 	flags = tun_info->key.tun_flags & (TUNNEL_CSUM | TUNNEL_KEY);
+ 	build_header(skb, tunnel_hlen, flags, htons(ETH_P_TEB),
+ 		     tunnel_id_to_key(tun_info->key.tun_id), 0);
+ 
+ 	df = key->tun_flags & TUNNEL_DONT_FRAGMENT ?  htons(IP_DF) : 0;
+ 	err = iptunnel_xmit(skb->sk, rt, skb, fl.saddr,
+ 			    key->u.ipv4.dst, IPPROTO_GRE,
+ 			    key->tos, key->ttl, df, false);
+ 	iptunnel_xmit_stats(err, &dev->stats, dev->tstats);
+ 	return;
+ 
+ err_free_rt:
+ 	ip_rt_put(rt);
+ err_free_skb:
+ 	kfree_skb(skb);
+ 	dev->stats.tx_dropped++;
+ }
+ 
+ static int gre_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
+ {
+ 	struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 	struct rtable *rt;
+ 	struct flowi4 fl4;
+ 
+ 	if (ip_tunnel_info_af(info) != AF_INET)
+ 		return -EINVAL;
+ 
+ 	rt = gre_get_rt(skb, dev, &fl4, &info->key);
+ 	if (IS_ERR(rt))
+ 		return PTR_ERR(rt);
+ 
+ 	ip_rt_put(rt);
+ 	info->key.u.ipv4.src = fl4.saddr;
+ 	return 0;
+ }
+ 
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
  static netdev_tx_t ipgre_xmit(struct sk_buff *skb,
  			      struct net_device *dev)
  {
diff --cc net/openvswitch/actions.c
index 327766f7c945,0bf0f406de52..000000000000
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@@ -644,11 -795,11 +643,17 @@@ static int output_userspace(struct data
  			if (vport) {
  				int err;
  
++<<<<<<< HEAD
 +				err = ovs_vport_get_egress_tun_info(vport, skb,
 +								    &info);
 +				if (!err)
 +					upcall.egress_tun_info = &info;
++=======
+ 				err = dev_fill_metadata_dst(vport->dev, skb);
+ 				if (!err)
+ 					upcall.egress_tun_info = skb_tunnel_info(skb);
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
  			}
 -
  			break;
  		}
  
diff --cc net/openvswitch/datapath.c
index b447e1242e90,c5d08ee37730..000000000000
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@@ -472,8 -490,8 +472,13 @@@ static int queue_userspace_packet(struc
  
  	if (upcall_info->egress_tun_info) {
  		nla = nla_nest_start(user_skb, OVS_PACKET_ATTR_EGRESS_TUN_KEY);
++<<<<<<< HEAD
 +		err = ovs_nla_put_egress_tunnel_key(user_skb,
 +						    upcall_info->egress_tun_info);
++=======
+ 		err = ovs_nla_put_tunnel_info(user_skb,
+ 					      upcall_info->egress_tun_info);
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
  		BUG_ON(err);
  		nla_nest_end(user_skb, nla);
  	}
diff --cc net/openvswitch/datapath.h
index 487a85f7d967,67bdecd9fdc1..000000000000
--- a/net/openvswitch/datapath.h
+++ b/net/openvswitch/datapath.h
@@@ -113,9 -113,10 +113,13 @@@ struct ovs_skb_cb 
   * then no packet is sent and the packet is accounted in the datapath's @n_lost
   * counter.
   * @egress_tun_info: If nonnull, becomes %OVS_PACKET_ATTR_EGRESS_TUN_KEY.
 - * @mru: If not zero, Maximum received IP fragment size.
   */
  struct dp_upcall_info {
++<<<<<<< HEAD
 +	const struct ip_tunnel_info *egress_tun_info;
++=======
+ 	struct ip_tunnel_info *egress_tun_info;
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
  	const struct nlattr *userdata;
  	const struct nlattr *actions;
  	int actions_len;
diff --cc net/openvswitch/flow_netlink.c
index 7f4707e70b38,38536c137c54..000000000000
--- a/net/openvswitch/flow_netlink.c
+++ b/net/openvswitch/flow_netlink.c
@@@ -707,17 -749,17 +707,26 @@@ static int ipv4_tun_to_nlattr(struct sk
  	return 0;
  }
  
++<<<<<<< HEAD
 +int ovs_nla_put_egress_tunnel_key(struct sk_buff *skb,
 +				  const struct ip_tunnel_info *egress_tun_info)
 +{
 +	return __ipv4_tun_to_nlattr(skb, &egress_tun_info->key,
 +				    egress_tun_info->options,
 +				    egress_tun_info->options_len);
++=======
+ int ovs_nla_put_tunnel_info(struct sk_buff *skb,
+ 			    struct ip_tunnel_info *tun_info)
+ {
+ 	return __ipv4_tun_to_nlattr(skb, &tun_info->key,
+ 				    ip_tunnel_info_opts(tun_info),
+ 				    tun_info->options_len);
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
  }
  
 -static int metadata_from_nlattrs(struct net *net, struct sw_flow_match *match,
 -				 u64 *attrs, const struct nlattr **a,
 -				 bool is_mask, bool log)
 +static int metadata_from_nlattrs(struct sw_flow_match *match,  u64 *attrs,
 +				 const struct nlattr **a, bool is_mask,
 +				 bool log)
  {
  	if (*attrs & (1 << OVS_KEY_ATTR_DP_HASH)) {
  		u32 hash_val = nla_get_u32(a[OVS_KEY_ATTR_DP_HASH]);
@@@ -2285,10 -2382,7 +2294,14 @@@ static int set_action_to_attr(const str
  		if (!start)
  			return -EMSGSIZE;
  
++<<<<<<< HEAD
 +		err = ipv4_tun_to_nlattr(skb, &tun_info->key,
 +					 tun_info->options_len ?
 +						tun_info->options : NULL,
 +					 tun_info->options_len);
++=======
+ 		err = ovs_nla_put_tunnel_info(skb, tun_info);
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
  		if (err)
  			return err;
  		nla_nest_end(skb, start);
diff --cc net/openvswitch/flow_netlink.h
index acd074408f0a,47dd142eca1c..000000000000
--- a/net/openvswitch/flow_netlink.h
+++ b/net/openvswitch/flow_netlink.h
@@@ -52,10 -52,12 +52,19 @@@ int ovs_nla_put_identifier(const struc
  int ovs_nla_put_masked_key(const struct sw_flow *flow, struct sk_buff *skb);
  int ovs_nla_put_mask(const struct sw_flow *flow, struct sk_buff *skb);
  
++<<<<<<< HEAD
 +int ovs_nla_get_match(struct sw_flow_match *, const struct nlattr *key,
 +		      const struct nlattr *mask, bool log);
 +int ovs_nla_put_egress_tunnel_key(struct sk_buff *,
 +				  const struct ip_tunnel_info *);
++=======
+ int ovs_nla_get_match(struct net *, struct sw_flow_match *,
+ 		      const struct nlattr *key, const struct nlattr *mask,
+ 		      bool log);
+ 
+ int ovs_nla_put_tunnel_info(struct sk_buff *skb,
+ 			    struct ip_tunnel_info *tun_info);
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
  
  bool ovs_nla_get_ufid(struct sw_flow_id *, const struct nlattr *, bool log);
  int ovs_nla_get_identifier(struct sw_flow_id *sfid, const struct nlattr *ufid,
diff --cc net/openvswitch/vport-geneve.c
index 1da3a14d1010,5f8aaaaa0785..000000000000
--- a/net/openvswitch/vport-geneve.c
+++ b/net/openvswitch/vport-geneve.c
@@@ -108,15 -52,6 +108,18 @@@ static int geneve_get_options(const str
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void geneve_tnl_destroy(struct vport *vport)
 +{
 +	struct geneve_port *geneve_port = geneve_vport(vport);
 +
 +	geneve_sock_release(geneve_port->gs);
 +
 +	ovs_vport_deferred_free(vport);
 +}
 +
++=======
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
  static struct vport *geneve_tnl_create(const struct vport_parms *parms)
  {
  	struct net *net = ovs_dp_get_net(parms->dp);
@@@ -241,13 -113,11 +244,12 @@@ static int geneve_get_egress_tun_info(s
  
  static struct vport_ops ovs_geneve_vport_ops = {
  	.type		= OVS_VPORT_TYPE_GENEVE,
 -	.create		= geneve_create,
 -	.destroy	= ovs_netdev_tunnel_destroy,
 +	.create		= geneve_tnl_create,
 +	.destroy	= geneve_tnl_destroy,
 +	.get_name	= geneve_get_name,
  	.get_options	= geneve_get_options,
 -	.send		= ovs_netdev_send,
 +	.send		= geneve_tnl_send,
  	.owner          = THIS_MODULE,
- 	.get_egress_tun_info	= geneve_get_egress_tun_info,
  };
  
  static int __init ovs_geneve_tnl_init(void)
diff --cc net/openvswitch/vport-gre.c
index b87656c66aaf,64225bf5eb40..000000000000
--- a/net/openvswitch/vport-gre.c
+++ b/net/openvswitch/vport-gre.c
@@@ -236,62 -75,20 +236,70 @@@ static const char *gre_get_name(const s
  
  static struct vport *gre_create(const struct vport_parms *parms)
  {
 +	struct net *net = ovs_dp_get_net(parms->dp);
 +	struct ovs_net *ovs_net;
  	struct vport *vport;
 +	int err;
 +
 +	err = gre_init();
 +	if (err)
 +		return ERR_PTR(err);
  
 -	vport = gre_tnl_create(parms);
 +	ovs_net = net_generic(net, ovs_net_id);
 +	if (ovsl_dereference(ovs_net->vport_net.gre_vport)) {
 +		vport = ERR_PTR(-EEXIST);
 +		goto error;
 +	}
 +
 +	vport = ovs_vport_alloc(IFNAMSIZ, &ovs_gre_vport_ops, parms);
  	if (IS_ERR(vport))
 -		return vport;
 +		goto error;
 +
 +	strncpy(vport_priv(vport), parms->name, IFNAMSIZ);
 +	rcu_assign_pointer(ovs_net->vport_net.gre_vport, vport);
 +	return vport;
 +
 +error:
 +	gre_exit();
 +	return vport;
 +}
  
 -	return ovs_netdev_link(vport, parms->name);
 +static void gre_tnl_destroy(struct vport *vport)
 +{
 +	struct net *net = ovs_dp_get_net(vport->dp);
 +	struct ovs_net *ovs_net;
 +
 +	ovs_net = net_generic(net, ovs_net_id);
 +
 +	RCU_INIT_POINTER(ovs_net->vport_net.gre_vport, NULL);
 +	ovs_vport_deferred_free(vport);
 +	gre_exit();
  }
  
++<<<<<<< HEAD
 +static int gre_get_egress_tun_info(struct vport *vport, struct sk_buff *skb,
 +				   struct ip_tunnel_info *egress_tun_info)
 +{
 +	return ovs_tunnel_get_egress_info(egress_tun_info,
 +					  ovs_dp_get_net(vport->dp),
 +					  OVS_CB(skb)->egress_tun_info,
 +					  IPPROTO_GRE, skb->mark, 0, 0);
 +}
 +
 +static struct vport_ops ovs_gre_vport_ops = {
 +	.type		= OVS_VPORT_TYPE_GRE,
 +	.create		= gre_create,
 +	.destroy	= gre_tnl_destroy,
 +	.get_name	= gre_get_name,
 +	.send		= gre_tnl_send,
 +	.get_egress_tun_info	= gre_get_egress_tun_info,
++=======
+ static struct vport_ops ovs_gre_vport_ops = {
+ 	.type		= OVS_VPORT_TYPE_GRE,
+ 	.create		= gre_create,
+ 	.send		= ovs_netdev_send,
+ 	.destroy	= ovs_netdev_tunnel_destroy,
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
  	.owner		= THIS_MODULE,
  };
  
diff --cc net/openvswitch/vport-vxlan.c
index 6f7986fabb70,e1c9c0888037..000000000000
--- a/net/openvswitch/vport-vxlan.c
+++ b/net/openvswitch/vport-vxlan.c
@@@ -203,105 -135,23 +203,114 @@@ error
  	return ERR_PTR(err);
  }
  
 -static struct vport *vxlan_create(const struct vport_parms *parms)
 +static int vxlan_ext_gbp(struct sk_buff *skb)
  {
 -	struct vport *vport;
 +	const struct ip_tunnel_info *tun_info;
 +	const struct ovs_vxlan_opts *opts;
  
 -	vport = vxlan_tnl_create(parms);
 -	if (IS_ERR(vport))
 -		return vport;
 +	tun_info = OVS_CB(skb)->egress_tun_info;
 +	opts = tun_info->options;
 +
 +	if (tun_info->key.tun_flags & TUNNEL_VXLAN_OPT &&
 +	    tun_info->options_len >= sizeof(*opts))
 +		return opts->gbp;
 +	else
 +		return 0;
 +}
 +
 +static int vxlan_tnl_send(struct vport *vport, struct sk_buff *skb)
 +{
 +	struct net *net = ovs_dp_get_net(vport->dp);
 +	struct vxlan_port *vxlan_port = vxlan_vport(vport);
 +	struct sock *sk = vxlan_port->vs->sock->sk;
 +	__be16 dst_port = inet_sk(sk)->inet_sport;
 +	const struct ip_tunnel_key *tun_key;
 +	struct vxlan_metadata md = {0};
 +	struct rtable *rt;
 +	struct flowi4 fl;
 +	__be16 src_port;
 +	__be16 df;
 +	int err;
 +	u32 vxflags;
 +
 +	if (unlikely(!OVS_CB(skb)->egress_tun_info)) {
 +		err = -EINVAL;
 +		goto error;
 +	}
 +
 +	tun_key = &OVS_CB(skb)->egress_tun_info->key;
 +	rt = ovs_tunnel_route_lookup(net, tun_key, skb->mark, &fl, IPPROTO_UDP);
 +	if (IS_ERR(rt)) {
 +		err = PTR_ERR(rt);
 +		goto error;
 +	}
  
 -	return ovs_netdev_link(vport, parms->name);
 +	df = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ?
 +		htons(IP_DF) : 0;
 +
 +	skb->ignore_df = 1;
 +
 +	src_port = udp_flow_src_port(net, skb, 0, 0, true);
 +	md.vni = htonl(be64_to_cpu(tun_key->tun_id) << 8);
 +	md.gbp = vxlan_ext_gbp(skb);
 +	vxflags = vxlan_port->exts |
 +		      (tun_key->tun_flags & TUNNEL_CSUM ? VXLAN_F_UDP_CSUM : 0);
 +
 +	err = vxlan_xmit_skb(rt, sk, skb, fl.saddr, tun_key->ipv4_dst,
 +			     tun_key->ipv4_tos, tun_key->ipv4_ttl, df,
 +			     src_port, dst_port,
 +			     &md, false, vxflags);
 +	if (err < 0)
 +		ip_rt_put(rt);
 +	return err;
 +error:
 +	kfree_skb(skb);
 +	return err;
 +}
 +
++<<<<<<< HEAD
 +static int vxlan_get_egress_tun_info(struct vport *vport, struct sk_buff *skb,
 +				     struct ip_tunnel_info *egress_tun_info)
 +{
 +	struct net *net = ovs_dp_get_net(vport->dp);
 +	struct vxlan_port *vxlan_port = vxlan_vport(vport);
 +	__be16 dst_port = inet_sk(vxlan_port->vs->sock->sk)->inet_sport;
 +	__be16 src_port;
 +	int port_min;
 +	int port_max;
 +
 +	inet_get_local_port_range(net, &port_min, &port_max);
 +	src_port = udp_flow_src_port(net, skb, 0, 0, true);
 +
 +	return ovs_tunnel_get_egress_info(egress_tun_info, net,
 +					  OVS_CB(skb)->egress_tun_info,
 +					  IPPROTO_UDP, skb->mark,
 +					  src_port, dst_port);
 +}
 +
 +static const char *vxlan_get_name(const struct vport *vport)
 +{
 +	struct vxlan_port *vxlan_port = vxlan_vport(vport);
 +	return vxlan_port->name;
  }
  
 +static struct vport_ops ovs_vxlan_vport_ops = {
 +	.type		= OVS_VPORT_TYPE_VXLAN,
 +	.create		= vxlan_tnl_create,
 +	.destroy	= vxlan_tnl_destroy,
 +	.get_name	= vxlan_get_name,
 +	.get_options	= vxlan_get_options,
 +	.send		= vxlan_tnl_send,
 +	.get_egress_tun_info	= vxlan_get_egress_tun_info,
 +	.owner		= THIS_MODULE,
++=======
+ static struct vport_ops ovs_vxlan_netdev_vport_ops = {
+ 	.type			= OVS_VPORT_TYPE_VXLAN,
+ 	.create			= vxlan_create,
+ 	.destroy		= ovs_netdev_tunnel_destroy,
+ 	.get_options		= vxlan_get_options,
+ 	.send			= ovs_netdev_send,
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
  };
  
  static int __init ovs_vxlan_tnl_init(void)
diff --cc net/openvswitch/vport.c
index af23ba077836,320c765ce44a..000000000000
--- a/net/openvswitch/vport.c
+++ b/net/openvswitch/vport.c
@@@ -571,57 -479,3 +571,60 @@@ void ovs_vport_deferred_free(struct vpo
  	call_rcu(&vport->rcu, free_vport_rcu);
  }
  EXPORT_SYMBOL_GPL(ovs_vport_deferred_free);
++<<<<<<< HEAD
 +
 +int ovs_tunnel_get_egress_info(struct ip_tunnel_info *egress_tun_info,
 +			       struct net *net,
 +			       const struct ip_tunnel_info *tun_info,
 +			       u8 ipproto,
 +			       u32 skb_mark,
 +			       __be16 tp_src,
 +			       __be16 tp_dst)
 +{
 +	const struct ip_tunnel_key *tun_key;
 +	struct rtable *rt;
 +	struct flowi4 fl;
 +
 +	if (unlikely(!tun_info))
 +		return -EINVAL;
 +
 +	tun_key = &tun_info->key;
 +
 +	/* Route lookup to get srouce IP address.
 +	 * The process may need to be changed if the corresponding process
 +	 * in vports ops changed.
 +	 */
 +	rt = ovs_tunnel_route_lookup(net, tun_key, skb_mark, &fl, ipproto);
 +	if (IS_ERR(rt))
 +		return PTR_ERR(rt);
 +
 +	ip_rt_put(rt);
 +
 +	/* Generate egress_tun_info based on tun_info,
 +	 * saddr, tp_src and tp_dst
 +	 */
 +	__ip_tunnel_info_init(egress_tun_info,
 +			      fl.saddr, tun_key->ipv4_dst,
 +			      tun_key->ipv4_tos,
 +			      tun_key->ipv4_ttl,
 +			      tp_src, tp_dst,
 +			      tun_key->tun_id,
 +			      tun_key->tun_flags,
 +			      tun_info->options,
 +			      tun_info->options_len);
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(ovs_tunnel_get_egress_info);
 +
 +int ovs_vport_get_egress_tun_info(struct vport *vport, struct sk_buff *skb,
 +				  struct ip_tunnel_info *info)
 +{
 +	/* get_egress_tun_info() is only implemented on tunnel ports. */
 +	if (unlikely(!vport->ops->get_egress_tun_info))
 +		return -EINVAL;
 +
 +	return vport->ops->get_egress_tun_info(vport, skb, info);
 +}
++=======
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
diff --cc net/openvswitch/vport.h
index 4750fb673a9f,d341ad6f3afe..000000000000
--- a/net/openvswitch/vport.h
+++ b/net/openvswitch/vport.h
@@@ -56,26 -52,6 +56,29 @@@ int ovs_vport_set_upcall_portids(struc
  int ovs_vport_get_upcall_portids(const struct vport *, struct sk_buff *);
  u32 ovs_vport_find_upcall_portid(const struct vport *, struct sk_buff *);
  
++<<<<<<< HEAD
 +int ovs_vport_send(struct vport *, struct sk_buff *);
 +
 +int ovs_tunnel_get_egress_info(struct ip_tunnel_info *egress_tun_info,
 +			       struct net *net,
 +			       const struct ip_tunnel_info *tun_info,
 +			       u8 ipproto,
 +			       u32 skb_mark,
 +			       __be16 tp_src,
 +			       __be16 tp_dst);
 +int ovs_vport_get_egress_tun_info(struct vport *vport, struct sk_buff *skb,
 +				  struct ip_tunnel_info *info);
 +
 +/* The following definitions are for implementers of vport devices: */
 +
 +struct vport_err_stats {
 +	atomic_long_t rx_dropped;
 +	atomic_long_t rx_errors;
 +	atomic_long_t tx_dropped;
 +	atomic_long_t tx_errors;
 +};
++=======
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
  /**
   * struct vport_portids - array of netlink portids of a vport.
   *                        must be protected by rcu.
@@@ -155,11 -127,8 +158,9 @@@ struct vport_parms 
   * @get_options: Appends vport-specific attributes for the configuration of an
   * existing vport to a &struct sk_buff.  May be %NULL for a vport that does not
   * have any configuration.
 - * @send: Send a packet on the device.
 + * @get_name: Get the device's name.
 + * @send: Send a packet on the device.  Returns the length of the packet sent,
   * zero for dropped packets or negative for error.
-  * @get_egress_tun_info: Get the egress tunnel 5-tuple and other info for
-  * a packet.
   */
  struct vport_ops {
  	enum ovs_vport_type type;
@@@ -171,13 -140,7 +172,17 @@@
  	int (*set_options)(struct vport *, struct nlattr *);
  	int (*get_options)(const struct vport *, struct sk_buff *);
  
++<<<<<<< HEAD
 +	/* Called with rcu_read_lock or ovs_mutex. */
 +	const char *(*get_name)(const struct vport *);
 +
 +	int (*send)(struct vport *, struct sk_buff *);
 +	int (*get_egress_tun_info)(struct vport *, struct sk_buff *,
 +				   struct ip_tunnel_info *);
 +
++=======
+ 	void (*send)(struct vport *, struct sk_buff *);
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
  	struct module *owner;
  	struct list_head list;
  };
@@@ -238,22 -194,14 +243,30 @@@ static inline void ovs_skb_postpush_rcs
  int ovs_vport_ops_register(struct vport_ops *ops);
  void ovs_vport_ops_unregister(struct vport_ops *ops);
  
++<<<<<<< HEAD
 +static inline struct rtable *ovs_tunnel_route_lookup(struct net *net,
 +						     const struct ip_tunnel_key *key,
 +						     u32 mark,
 +						     struct flowi4 *fl,
 +						     u8 protocol)
 +{
 +	struct rtable *rt;
 +
 +	memset(fl, 0, sizeof(*fl));
 +	fl->daddr = key->ipv4_dst;
 +	fl->saddr = key->ipv4_src;
 +	fl->flowi4_tos = RT_TOS(key->ipv4_tos);
 +	fl->flowi4_mark = mark;
 +	fl->flowi4_proto = protocol;
 +
 +	rt = ip_route_output_key(net, fl);
 +	return rt;
 +}
++=======
+ static inline void ovs_vport_send(struct vport *vport, struct sk_buff *skb)
+ {
+ 	vport->ops->send(vport, skb);
+ }
+ 
++>>>>>>> fc4099f17240 (openvswitch: Fix egress tunnel info.)
  #endif /* vport.h */
* Unmerged path include/net/dst_metadata.h
diff --git a/drivers/net/geneve.c b/drivers/net/geneve.c
index 61619a003943..48c886369614 100644
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@ -597,14 +597,12 @@ static struct rtable *geneve_get_rt(struct sk_buff *skb,
 	rt = ip_route_output_key(geneve->net, fl4);
 	if (IS_ERR(rt)) {
 		netdev_dbg(dev, "no route to %pI4\n", &fl4->daddr);
-		dev->stats.tx_carrier_errors++;
-		return rt;
+		return ERR_PTR(-ENETUNREACH);
 	}
 	if (rt->dst.dev == dev) { /* is this necessary? */
 		netdev_dbg(dev, "circular route to %pI4\n", &fl4->daddr);
-		dev->stats.collisions++;
 		ip_rt_put(rt);
-		return ERR_PTR(-EINVAL);
+		return ERR_PTR(-ELOOP);
 	}
 	return rt;
 }
@@ -630,12 +628,12 @@ static netdev_tx_t geneve_xmit(struct sk_buff *skb, struct net_device *dev)
 	struct ip_tunnel_info *info = NULL;
 	struct rtable *rt = NULL;
 	const struct iphdr *iip; /* interior IP header */
+	int err = -EINVAL;
 	struct flowi4 fl4;
 	__u8 tos, ttl;
 	__be16 sport;
 	bool udp_csum;
 	__be16 df;
-	int err;
 
 	if (geneve->collect_md) {
 		info = skb_tunnel_info(skb);
@@ -648,7 +646,7 @@ static netdev_tx_t geneve_xmit(struct sk_buff *skb, struct net_device *dev)
 	rt = geneve_get_rt(skb, dev, &fl4, info);
 	if (IS_ERR(rt)) {
 		netdev_dbg(dev, "no route to %pI4\n", &fl4.daddr);
-		dev->stats.tx_carrier_errors++;
+		err = PTR_ERR(rt);
 		goto tx_error;
 	}
 
@@ -700,10 +698,37 @@ static netdev_tx_t geneve_xmit(struct sk_buff *skb, struct net_device *dev)
 tx_error:
 	dev_kfree_skb(skb);
 err:
-	dev->stats.tx_errors++;
+	if (err == -ELOOP)
+		dev->stats.collisions++;
+	else if (err == -ENETUNREACH)
+		dev->stats.tx_carrier_errors++;
+	else
+		dev->stats.tx_errors++;
 	return NETDEV_TX_OK;
 }
 
+static int geneve_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
+{
+	struct ip_tunnel_info *info = skb_tunnel_info(skb);
+	struct geneve_dev *geneve = netdev_priv(dev);
+	struct rtable *rt;
+	struct flowi4 fl4;
+
+	if (ip_tunnel_info_af(info) != AF_INET)
+		return -EINVAL;
+
+	rt = geneve_get_rt(skb, dev, &fl4, info);
+	if (IS_ERR(rt))
+		return PTR_ERR(rt);
+
+	ip_rt_put(rt);
+	info->key.u.ipv4.src = fl4.saddr;
+	info->key.tp_src = udp_flow_src_port(geneve->net, skb,
+					     1, USHRT_MAX, true);
+	info->key.tp_dst = geneve->dst_port;
+	return 0;
+}
+
 static const struct net_device_ops geneve_netdev_ops = {
 	.ndo_init		= geneve_init,
 	.ndo_uninit		= geneve_uninit,
@@ -714,6 +739,7 @@ static const struct net_device_ops geneve_netdev_ops = {
 	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_validate_addr	= eth_validate_addr,
 	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_fill_metadata_dst	= geneve_fill_metadata_dst,
 };
 
 static void geneve_get_drvinfo(struct net_device *dev,
diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c
index 4e5b7ab9acd0..c9ec218a3972 100644
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@ -2290,6 +2290,46 @@ static int vxlan_change_mtu(struct net_device *dev, int new_mtu)
 	return 0;
 }
 
+static int egress_ipv4_tun_info(struct net_device *dev, struct sk_buff *skb,
+				struct ip_tunnel_info *info,
+				__be16 sport, __be16 dport)
+{
+	struct vxlan_dev *vxlan = netdev_priv(dev);
+	struct rtable *rt;
+	struct flowi4 fl4;
+
+	memset(&fl4, 0, sizeof(fl4));
+	fl4.flowi4_tos = RT_TOS(info->key.tos);
+	fl4.flowi4_mark = skb->mark;
+	fl4.flowi4_proto = IPPROTO_UDP;
+	fl4.daddr = info->key.u.ipv4.dst;
+
+	rt = ip_route_output_key(vxlan->net, &fl4);
+	if (IS_ERR(rt))
+		return PTR_ERR(rt);
+	ip_rt_put(rt);
+
+	info->key.u.ipv4.src = fl4.saddr;
+	info->key.tp_src = sport;
+	info->key.tp_dst = dport;
+	return 0;
+}
+
+static int vxlan_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
+{
+	struct vxlan_dev *vxlan = netdev_priv(dev);
+	struct ip_tunnel_info *info = skb_tunnel_info(skb);
+	__be16 sport, dport;
+
+	sport = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
+				  vxlan->cfg.port_max, true);
+	dport = info->key.tp_dst ? : vxlan->cfg.dst_port;
+
+	if (ip_tunnel_info_af(info) == AF_INET)
+		return egress_ipv4_tun_info(dev, skb, info, sport, dport);
+	return -EINVAL;
+}
+
 static const struct net_device_ops vxlan_netdev_ops = {
 	.ndo_init		= vxlan_init,
 	.ndo_uninit		= vxlan_uninit,
@@ -2304,6 +2344,7 @@ static const struct net_device_ops vxlan_netdev_ops = {
 	.ndo_fdb_add		= vxlan_fdb_add,
 	.ndo_fdb_del		= vxlan_fdb_delete,
 	.ndo_fdb_dump		= vxlan_fdb_dump,
+	.ndo_fill_metadata_dst	= vxlan_fill_metadata_dst,
 };
 
 /* Info for udev, that this is a virtual tunnel endpoint */
* Unmerged path include/linux/netdevice.h
* Unmerged path include/net/dst_metadata.h
diff --git a/net/core/dev.c b/net/core/dev.c
index e416d49ce837..755a33cf34ea 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -100,6 +100,7 @@
 #include <linux/rtnetlink.h>
 #include <linux/stat.h>
 #include <net/dst.h>
+#include <net/dst_metadata.h>
 #include <net/pkt_sched.h>
 #include <net/checksum.h>
 #include <net/xfrm.h>
@@ -674,6 +675,32 @@ int dev_get_iflink(const struct net_device *dev)
 }
 EXPORT_SYMBOL(dev_get_iflink);
 
+/**
+ *	dev_fill_metadata_dst - Retrieve tunnel egress information.
+ *	@dev: targeted interface
+ *	@skb: The packet.
+ *
+ *	For better visibility of tunnel traffic OVS needs to retrieve
+ *	egress tunnel information for a packet. Following API allows
+ *	user to get this info.
+ */
+int dev_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
+{
+	struct ip_tunnel_info *info;
+
+	if (!dev->netdev_ops  || !dev->netdev_ops->ndo_fill_metadata_dst)
+		return -EINVAL;
+
+	info = skb_tunnel_info_unclone(skb);
+	if (!info)
+		return -ENOMEM;
+	if (unlikely(!(info->mode & IP_TUNNEL_INFO_TX)))
+		return -EINVAL;
+
+	return dev->netdev_ops->ndo_fill_metadata_dst(dev, skb);
+}
+EXPORT_SYMBOL_GPL(dev_fill_metadata_dst);
+
 /**
  *	__dev_get_by_name	- find a device by its name
  *	@net: the applicable net namespace
* Unmerged path net/ipv4/ip_gre.c
* Unmerged path net/openvswitch/actions.c
* Unmerged path net/openvswitch/datapath.c
* Unmerged path net/openvswitch/datapath.h
* Unmerged path net/openvswitch/flow_netlink.c
* Unmerged path net/openvswitch/flow_netlink.h
* Unmerged path net/openvswitch/vport-geneve.c
* Unmerged path net/openvswitch/vport-gre.c
* Unmerged path net/openvswitch/vport-vxlan.c
* Unmerged path net/openvswitch/vport.c
* Unmerged path net/openvswitch/vport.h
