cifs: Use file_dentry()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Goldwyn Rodrigues <rgoldwyn@suse.com>
commit 1f1735cb75ab31ed948a7fce65beaaa6c0ed4ed4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1f1735cb.failed

CIFS may be used as lower layer of overlayfs and accessing f_path.dentry can
lead to a crash.

Fix by replacing direct access of file->f_path.dentry with the
file_dentry() accessor, which will always return a native object.

	Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
	Acked-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
	Signed-off-by: Steve French <smfrench@gmail.com>
(cherry picked from commit 1f1735cb75ab31ed948a7fce65beaaa6c0ed4ed4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/file.c
#	fs/cifs/readdir.c
diff --cc fs/cifs/file.c
index de90192d82b9,489ddc797105..000000000000
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@@ -270,8 -271,8 +270,13 @@@ struct cifsFileInfo 
  cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,
  		  struct tcon_link *tlink, __u32 oplock)
  {
++<<<<<<< HEAD
 +	struct dentry *dentry = file->f_path.dentry;
 +	struct inode *inode = dentry->d_inode;
++=======
+ 	struct dentry *dentry = file_dentry(file);
+ 	struct inode *inode = d_inode(dentry);
++>>>>>>> 1f1735cb75ab (cifs: Use file_dentry())
  	struct cifsInodeInfo *cinode = CIFS_I(inode);
  	struct cifsFileInfo *cfile;
  	struct cifs_fid_locks *fdlocks;
diff --cc fs/cifs/readdir.c
index 8e0548dbcdd4,65cf85dcda09..000000000000
--- a/fs/cifs/readdir.c
+++ b/fs/cifs/readdir.c
@@@ -762,12 -762,10 +762,16 @@@ static int cifs_filldir(char *find_entr
  		 */
  		fattr.cf_flags |= CIFS_FATTR_NEED_REVAL;
  
++<<<<<<< HEAD
 +	cifs_prime_dcache(file->f_dentry, &name, &fattr);
++=======
+ 	cifs_prime_dcache(file_dentry(file), &name, &fattr);
++>>>>>>> 1f1735cb75ab (cifs: Use file_dentry())
  
  	ino = cifs_uniqueid_to_ino_t(fattr.cf_uniqueid);
 -	return !dir_emit(ctx, name.name, name.len, ino, fattr.cf_dtype);
 +	rc = filldir(dirent, name.name, name.len, file->f_pos, ino,
 +		     fattr.cf_dtype);
 +	return rc;
  }
  
  
* Unmerged path fs/cifs/file.c
* Unmerged path fs/cifs/readdir.c
