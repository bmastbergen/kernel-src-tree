perf report: Update column width of dynamic entries

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit abab5e7fcec16e526968f8a5448cd81c635705ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/abab5e7f.failed

The column width of dynamic entries is updated when comparing hist
entries.  However some unique entries can miss the chance to update.  So
move the update to output resort stage to make sure every entry will get
called before display.

To do that, abuse ->sort callback to update the width when the third
argument is NULL.  When resorting entries in normal path, it never be
NULL so it should be fine IMHO.

Before:

  #       Overhead  ptr / bytes_req / gfp_flags
  # ..............  ..........................................
  #
      37.50%        0xffff8803f7669400
         37.50%        448
            37.50%        GFP_ATOMIC|GFP_NOWARN|GFP_NOMEMALLOC
      10.42%        0xffff8803f766be00
          8.33%        96
             8.33%        GFP_ATOMIC|GFP_NOWARN|GFP_NOMEMALLOC
          2.08%        512
             2.08%        GFP_KERNEL|GFP_NOWARN|GFP_REPEAT|GFP   <-- here

After:

  #       Overhead  ptr / bytes_req / gfp_flags
  # ..............  .....................................................
  #
      37.50%        0xffff8803f7669400
         37.50%        448
            37.50%        GFP_ATOMIC|GFP_NOWARN|GFP_NOMEMALLOC
      10.42%        0xffff8803f766be00
          8.33%        96
             8.33%        GFP_ATOMIC|GFP_NOWARN|GFP_NOMEMALLOC
          2.08%        512
             2.08%        GFP_KERNEL|GFP_NOWARN|GFP_REPEAT|GFP_NOMEMALLOC

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1456512767-1164-5-git-send-email-namhyung@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit abab5e7fcec16e526968f8a5448cd81c635705ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/sort.c
diff --cc tools/perf/util/sort.c
index 8f36c1d6fd38,5888bfe9a193..000000000000
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@@ -1688,8 -1816,10 +1688,15 @@@ static int64_t __sort__hde_cmp(struct p
  
  	hde = container_of(fmt, struct hpp_dynamic_entry, hpp);
  
++<<<<<<< HEAD
 +	if (hists_to_evsel(a->hists) != hde->evsel)
 +		return 0;
++=======
+ 	if (b == NULL) {
+ 		update_dynamic_len(hde, a);
+ 		return 0;
+ 	}
++>>>>>>> abab5e7fcec1 (perf report: Update column width of dynamic entries)
  
  	field = hde->field;
  	if (field->flags & FIELD_IS_DYNAMIC) {
diff --git a/tools/perf/util/hist.c b/tools/perf/util/hist.c
index 9a525a5b649f..0e1ec127a03a 100644
--- a/tools/perf/util/hist.c
+++ b/tools/perf/util/hist.c
@@ -1211,6 +1211,10 @@ static void hierarchy_insert_output_entry(struct rb_root *root,
 
 	rb_link_node(&he->rb_node, parent, p);
 	rb_insert_color(&he->rb_node, root);
+
+	/* update column width of dynamic entry */
+	if (perf_hpp__is_dynamic_entry(he->fmt))
+		he->fmt->sort(he->fmt, he, NULL);
 }
 
 static void hists__hierarchy_output_resort(struct hists *hists,
@@ -1279,6 +1283,7 @@ static void __hists__insert_output_entry(struct rb_root *entries,
 	struct rb_node **p = &entries->rb_node;
 	struct rb_node *parent = NULL;
 	struct hist_entry *iter;
+	struct perf_hpp_fmt *fmt;
 
 	if (symbol_conf.use_callchain)
 		callchain_param.sort(&he->sorted_chain, he->callchain,
@@ -1296,6 +1301,12 @@ static void __hists__insert_output_entry(struct rb_root *entries,
 
 	rb_link_node(&he->rb_node, parent, p);
 	rb_insert_color(&he->rb_node, entries);
+
+	perf_hpp_list__for_each_sort_list(&perf_hpp_list, fmt) {
+		if (perf_hpp__is_dynamic_entry(fmt) &&
+		    perf_hpp__defined_dynamic_entry(fmt, he->hists))
+			fmt->sort(fmt, he, NULL);  /* update column width */
+	}
 }
 
 void hists__output_resort(struct hists *hists, struct ui_progress *prog)
* Unmerged path tools/perf/util/sort.c
