nvme: use an integer value to Linux errno values

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 1951feae88c5a39105a704188ccf910faf1d0c50
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1951feae.failed

Use a separate integer variable to hold the signed Linux errno
values we pass back to the block layer.  Note that for pass through
commands those might still be NVMe values, but those fit into the
int as well.

Fixes: f4829a9b7a61: ("blk-mq: fix racy updates of rq->errors")
	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 1951feae88c5a39105a704188ccf910faf1d0c50)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index f5099f908371,f73c574d59f5..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -528,25 -621,40 +528,47 @@@ static void req_completion(struct nvme_
  			spin_unlock_irqrestore(req->q->queue_lock, flags);
  			return;
  		}
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +		req->errors = nvme_error_status(status);
 +	} else
 +		req->errors = 0;
++=======
+ 
+ 		if (req->cmd_type == REQ_TYPE_DRV_PRIV) {
+ 			if (cmd_rq->ctx == CMD_CTX_CANCELLED)
+ 				error = -EINTR;
+ 			else
+ 				error = status;
+ 		} else {
+ 			error = nvme_error_status(status);
+ 		}
+ 	}
+ 
+ 	if (req->cmd_type == REQ_TYPE_DRV_PRIV) {
+ 		u32 result = le32_to_cpup(&cqe->result);
+ 		req->special = (void *)(uintptr_t)result;
+ 	}
++>>>>>>> 1951feae88c5 (nvme: use an integer value to Linux errno values):drivers/nvme/host/pci.c
  
  	if (cmd_rq->aborted)
 -		dev_warn(nvmeq->dev->dev,
 +		dev_warn(&nvmeq->dev->pci_dev->dev,
  			"completing aborted command with status:%04x\n",
- 			status);
+ 			error);
  
  	if (iod->nents) {
 -		dma_unmap_sg(nvmeq->dev->dev, iod->sg, iod->nents,
 +		dma_unmap_sg(&nvmeq->dev->pci_dev->dev, iod->sg, iod->nents,
  			rq_data_dir(req) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 -		if (blk_integrity_rq(req)) {
 -			if (!rq_data_dir(req))
 -				nvme_dif_remap(req, nvme_dif_complete);
 -			dma_unmap_sg(nvmeq->dev->dev, iod->meta_sg, 1,
 +		if (blk_integrity_rq(req))
 +			dma_unmap_sg(&nvmeq->dev->pci_dev->dev, iod->meta_sg, 1,
  				rq_data_dir(req) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 -		}
  	}
  	nvme_free_iod(nvmeq->dev, iod);
  
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +	blk_mq_complete_request(req);
++=======
+ 	blk_mq_complete_request(req, error);
++>>>>>>> 1951feae88c5 (nvme: use an integer value to Linux errno values):drivers/nvme/host/pci.c
  }
  
  /* length is in bytes.  gfp flags indicates whether we may sleep. */
* Unmerged path drivers/block/nvme-core.c
