mei: fix the KDoc formating

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit 99c2658f00eafe1b7f7c38aeb487239b014867f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/99c2658f.failed

KDoc function section start with double start:  /** instead of /*

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 99c2658f00eafe1b7f7c38aeb487239b014867f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/hbm.c
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/hbm.c
index 3cb8e1000d69,e7b7aad0999b..000000000000
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@@ -288,6 -314,212 +288,215 @@@ static int mei_hbm_enum_clients_req(str
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * mei_hbm_me_cl_add - add new me client to the list
+  *
+  * @dev: the device structure
+  * @res: hbm property response
+  *
+  * Return: 0 on success and -ENOMEM on allocation failure
+  */
+ 
+ static int mei_hbm_me_cl_add(struct mei_device *dev,
+ 			     struct hbm_props_response *res)
+ {
+ 	struct mei_me_client *me_cl;
+ 	const uuid_le *uuid = &res->client_properties.protocol_name;
+ 
+ 	mei_me_cl_rm_by_uuid(dev, uuid);
+ 
+ 	me_cl = kzalloc(sizeof(struct mei_me_client), GFP_KERNEL);
+ 	if (!me_cl)
+ 		return -ENOMEM;
+ 
+ 	mei_me_cl_init(me_cl);
+ 
+ 	me_cl->props = res->client_properties;
+ 	me_cl->client_id = res->me_addr;
+ 	me_cl->mei_flow_ctrl_creds = 0;
+ 
+ 	mei_me_cl_add(dev, me_cl);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * mei_hbm_add_cl_resp - send response to fw on client add request
+  *
+  * @dev: the device structure
+  * @addr: me address
+  * @status: response status
+  *
+  * Return: 0 on success and < 0 on failure
+  */
+ static int mei_hbm_add_cl_resp(struct mei_device *dev, u8 addr, u8 status)
+ {
+ 	struct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;
+ 	struct hbm_add_client_response *resp;
+ 	const size_t len = sizeof(struct hbm_add_client_response);
+ 	int ret;
+ 
+ 	dev_dbg(dev->dev, "adding client response\n");
+ 
+ 	resp = (struct hbm_add_client_response *)dev->wr_msg.data;
+ 
+ 	mei_hbm_hdr(mei_hdr, len);
+ 	memset(resp, 0, sizeof(struct hbm_add_client_response));
+ 
+ 	resp->hbm_cmd = MEI_HBM_ADD_CLIENT_RES_CMD;
+ 	resp->me_addr = addr;
+ 	resp->status  = status;
+ 
+ 	ret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);
+ 	if (ret)
+ 		dev_err(dev->dev, "add client response write failed: ret = %d\n",
+ 			ret);
+ 	return ret;
+ }
+ 
+ /**
+  * mei_hbm_fw_add_cl_req - request from the fw to add a client
+  *
+  * @dev: the device structure
+  * @req: add client request
+  *
+  * Return: 0 on success and < 0 on failure
+  */
+ static int mei_hbm_fw_add_cl_req(struct mei_device *dev,
+ 			      struct hbm_add_client_request *req)
+ {
+ 	int ret;
+ 	u8 status = MEI_HBMS_SUCCESS;
+ 
+ 	BUILD_BUG_ON(sizeof(struct hbm_add_client_request) !=
+ 			sizeof(struct hbm_props_response));
+ 
+ 	ret = mei_hbm_me_cl_add(dev, (struct hbm_props_response *)req);
+ 	if (ret)
+ 		status = !MEI_HBMS_SUCCESS;
+ 
+ 	return mei_hbm_add_cl_resp(dev, req->me_addr, status);
+ }
+ 
+ /**
+  * mei_hbm_cl_notify_req - send notification request
+  *
+  * @dev: the device structure
+  * @cl: a client to disconnect from
+  * @start: true for start false for stop
+  *
+  * Return: 0 on success and -EIO on write failure
+  */
+ int mei_hbm_cl_notify_req(struct mei_device *dev,
+ 			  struct mei_cl *cl, u8 start)
+ {
+ 
+ 	struct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;
+ 	struct hbm_notification_request *req;
+ 	const size_t len = sizeof(struct hbm_notification_request);
+ 	int ret;
+ 
+ 	mei_hbm_hdr(mei_hdr, len);
+ 	mei_hbm_cl_hdr(cl, MEI_HBM_NOTIFY_REQ_CMD, dev->wr_msg.data, len);
+ 
+ 	req = (struct hbm_notification_request *)dev->wr_msg.data;
+ 	req->start = start;
+ 
+ 	ret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);
+ 	if (ret)
+ 		dev_err(dev->dev, "notify request failed: ret = %d\n", ret);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  *  notify_res_to_fop - convert notification response to the proper
+  *      notification FOP
+  *
+  * @cmd: client notification start response command
+  *
+  * Return:  MEI_FOP_NOTIFY_START or MEI_FOP_NOTIFY_STOP;
+  */
+ static inline enum mei_cb_file_ops notify_res_to_fop(struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct hbm_notification_response *rs =
+ 		(struct hbm_notification_response *)cmd;
+ 
+ 	return mei_cl_notify_req2fop(rs->start);
+ }
+ 
+ /**
+  * mei_hbm_cl_notify_start_res - update the client state according
+  *       notify start response
+  *
+  * @dev: the device structure
+  * @cl: mei host client
+  * @cmd: client notification start response command
+  */
+ static void mei_hbm_cl_notify_start_res(struct mei_device *dev,
+ 					struct mei_cl *cl,
+ 					struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct hbm_notification_response *rs =
+ 		(struct hbm_notification_response *)cmd;
+ 
+ 	cl_dbg(dev, cl, "hbm: notify start response status=%d\n", rs->status);
+ 
+ 	if (rs->status == MEI_HBMS_SUCCESS ||
+ 	    rs->status == MEI_HBMS_ALREADY_STARTED) {
+ 		cl->notify_en = true;
+ 		cl->status = 0;
+ 	} else {
+ 		cl->status = -EINVAL;
+ 	}
+ }
+ 
+ /**
+  * mei_hbm_cl_notify_stop_res - update the client state according
+  *       notify stop response
+  *
+  * @dev: the device structure
+  * @cl: mei host client
+  * @cmd: client notification stop response command
+  */
+ static void mei_hbm_cl_notify_stop_res(struct mei_device *dev,
+ 				       struct mei_cl *cl,
+ 				       struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct hbm_notification_response *rs =
+ 		(struct hbm_notification_response *)cmd;
+ 
+ 	cl_dbg(dev, cl, "hbm: notify stop response status=%d\n", rs->status);
+ 
+ 	if (rs->status == MEI_HBMS_SUCCESS ||
+ 	    rs->status == MEI_HBMS_NOT_STARTED) {
+ 		cl->notify_en = false;
+ 		cl->status = 0;
+ 	} else {
+ 		/* TODO: spec is not clear yet about other possible issues */
+ 		cl->status = -EINVAL;
+ 	}
+ }
+ 
+ /**
+  * mei_hbm_cl_notify - signal notification event
+  *
+  * @dev: the device structure
+  * @cmd: notification client message
+  */
+ static void mei_hbm_cl_notify(struct mei_device *dev,
+ 			      struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct mei_cl *cl;
+ 
+ 	cl = mei_hbm_cl_find_by_cmd(dev, cmd);
+ 	if (cl)
+ 		mei_cl_notify(cl);
+ }
+ 
++>>>>>>> 99c2658f00ea (mei: fix the KDoc formating)
  /**
   * mei_hbm_prop_req - request property for a single client
   *
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,fc7728bb84b1..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -212,49 -258,52 +212,79 @@@ struct mei_cl 
  	wait_queue_head_t tx_wait;
  	wait_queue_head_t rx_wait;
  	wait_queue_head_t wait;
 -	wait_queue_head_t ev_wait;
 -	struct fasync_struct *ev_async;
  	int status;
 -	struct mei_me_client *me_cl;
 +	/* ID of client connected */
  	u8 host_client_id;
 +	u8 me_client_id;
  	u8 mei_flow_ctrl_creds;
  	u8 timer_count;
 -	u8 reserved;
 -	u8 notify_en;
 -	u8 notify_ev;
 +	enum mei_file_transaction_states reading_state;
  	enum mei_file_transaction_states writing_state;
 -	struct list_head rd_pending;
 -	struct list_head rd_completed;
 +	int sm_state;
 +	struct mei_cl_cb *read_cb;
  
 -	struct mei_cl_device *cldev;
 +	/* MEI CL bus data */
 +	struct mei_cl_device *device;
 +	struct list_head device_link;
 +	uuid_le device_uuid;
  };
  
- /** struct mei_hw_ops
+ /**
+  * struct mei_hw_ops - hw specific ops
   *
++<<<<<<< HEAD
 + * @host_is_ready    - query for host readiness
 +
 + * @hw_is_ready      - query if hw is ready
 + * @hw_reset         - reset hw
 + * @hw_start         - start hw after reset
 + * @hw_config        - configure hw
 +
 + * @pg_state         - power gating state of the device
 + * @pg_is_enabled    - is power gating enabled
 +
 + * @intr_clear       - clear pending interrupts
 + * @intr_enable      - enable interrupts
 + * @intr_disable     - disable interrupts
 +
 + * @hbuf_free_slots  - query for write buffer empty slots
 + * @hbuf_is_ready    - query if write buffer is empty
 + * @hbuf_max_len     - query for write buffer max len
 +
 + * @write            - write a message to FW
 +
 + * @rdbuf_full_slots - query how many slots are filled
 +
 + * @read_hdr         - get first 4 bytes (header)
 + * @read             - read a buffer from the FW
++=======
+  * @host_is_ready    : query for host readiness
+  *
+  * @hw_is_ready      : query if hw is ready
+  * @hw_reset         : reset hw
+  * @hw_start         : start hw after reset
+  * @hw_config        : configure hw
+  *
+  * @fw_status        : get fw status registers
+  * @pg_state         : power gating state of the device
+  * @pg_in_transition : is device now in pg transition
+  * @pg_is_enabled    : is power gating enabled
+  *
+  * @intr_clear       : clear pending interrupts
+  * @intr_enable      : enable interrupts
+  * @intr_disable     : disable interrupts
+  *
+  * @hbuf_free_slots  : query for write buffer empty slots
+  * @hbuf_is_ready    : query if write buffer is empty
+  * @hbuf_max_len     : query for write buffer max len
+  *
+  * @write            : write a message to FW
+  *
+  * @rdbuf_full_slots : query how many slots are filled
+  *
+  * @read_hdr         : get first 4 bytes (header)
+  * @read             : read a buffer from the FW
++>>>>>>> 99c2658f00ea (mei: fix the KDoc formating)
   */
  struct mei_hw_ops {
  
* Unmerged path drivers/misc/mei/hbm.c
* Unmerged path drivers/misc/mei/mei_dev.h
