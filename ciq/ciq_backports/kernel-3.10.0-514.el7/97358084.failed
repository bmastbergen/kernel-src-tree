perf hists: Add 'equal' method to perf_hpp_fmt struct

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 97358084b91e94e5f8fcf0379f0430c0ea16bd3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/97358084.failed

To easily compare format entries and make it available for all kinds of
format entries.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1453109064-1026-6-git-send-email-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 97358084b91e94e5f8fcf0379f0430c0ea16bd3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/hist.h
diff --cc tools/perf/util/hist.h
index 699d4a3924c2,9a240d7b8d3b..000000000000
--- a/tools/perf/util/hist.h
+++ b/tools/perf/util/hist.h
@@@ -262,11 -269,20 +263,16 @@@ void perf_hpp__reset_output_field(void)
  void perf_hpp__append_sort_keys(void);
  
  bool perf_hpp__is_sort_entry(struct perf_hpp_fmt *format);
++<<<<<<< HEAD
 +bool perf_hpp__same_sort_entry(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b);
++=======
+ bool perf_hpp__is_dynamic_entry(struct perf_hpp_fmt *format);
+ bool perf_hpp__defined_dynamic_entry(struct perf_hpp_fmt *fmt, struct hists *hists);
++>>>>>>> 97358084b91e (perf hists: Add 'equal' method to perf_hpp_fmt struct)
  
 -static inline bool perf_hpp__should_skip(struct perf_hpp_fmt *format,
 -					 struct hists *hists)
 +static inline bool perf_hpp__should_skip(struct perf_hpp_fmt *format)
  {
 -	if (format->elide)
 -		return true;
 -
 -	if (perf_hpp__is_dynamic_entry(format) &&
 -	    !perf_hpp__defined_dynamic_entry(format, hists))
 -		return true;
 -
 -	return false;
 +	return format->elide;
  }
  
  void perf_hpp__reset_width(struct perf_hpp_fmt *fmt, struct hists *hists);
diff --git a/tools/perf/ui/hist.c b/tools/perf/ui/hist.c
index 26848236e7a8..dbf31210d931 100644
--- a/tools/perf/ui/hist.c
+++ b/tools/perf/ui/hist.c
@@ -524,6 +524,11 @@ void perf_hpp__cancel_cumulate(void)
 	perf_hpp__format[PERF_HPP__OVERHEAD].name = "Overhead";
 }
 
+static bool fmt_equal(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b)
+{
+	return a->equal && a->equal(a, b);
+}
+
 void perf_hpp__setup_output_field(void)
 {
 	struct perf_hpp_fmt *fmt;
@@ -542,7 +547,7 @@ void perf_hpp__setup_output_field(void)
 			struct perf_hpp_fmt *pos;
 
 			perf_hpp__for_each_format(pos) {
-				if (perf_hpp__same_sort_entry(pos, fmt))
+				if (fmt_equal(fmt, pos))
 					goto next;
 			}
 		}
@@ -571,7 +576,7 @@ void perf_hpp__append_sort_keys(void)
 			struct perf_hpp_fmt *pos;
 
 			perf_hpp__for_each_sort_list(pos) {
-				if (perf_hpp__same_sort_entry(pos, fmt))
+				if (fmt_equal(fmt, pos))
 					goto next;
 			}
 		}
* Unmerged path tools/perf/util/hist.h
diff --git a/tools/perf/util/sort.c b/tools/perf/util/sort.c
index cb6856b79208..95cad139a8a0 100644
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@ -1352,20 +1352,6 @@ struct hpp_sort_entry {
 	struct sort_entry *se;
 };
 
-bool perf_hpp__same_sort_entry(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b)
-{
-	struct hpp_sort_entry *hse_a;
-	struct hpp_sort_entry *hse_b;
-
-	if (!perf_hpp__is_sort_entry(a) || !perf_hpp__is_sort_entry(b))
-		return false;
-
-	hse_a = container_of(a, struct hpp_sort_entry, hpp);
-	hse_b = container_of(b, struct hpp_sort_entry, hpp);
-
-	return hse_a->se == hse_b->se;
-}
-
 void perf_hpp__reset_sort_width(struct perf_hpp_fmt *fmt, struct hists *hists)
 {
 	struct hpp_sort_entry *hse;
@@ -1451,6 +1437,25 @@ static int64_t __sort__hpp_sort(struct perf_hpp_fmt *fmt,
 	return sort_fn(a, b);
 }
 
+bool perf_hpp__is_sort_entry(struct perf_hpp_fmt *format)
+{
+	return format->header == __sort__hpp_header;
+}
+
+static bool __sort__hpp_equal(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b)
+{
+	struct hpp_sort_entry *hse_a;
+	struct hpp_sort_entry *hse_b;
+
+	if (!perf_hpp__is_sort_entry(a) || !perf_hpp__is_sort_entry(b))
+		return false;
+
+	hse_a = container_of(a, struct hpp_sort_entry, hpp);
+	hse_b = container_of(b, struct hpp_sort_entry, hpp);
+
+	return hse_a->se == hse_b->se;
+}
+
 static struct hpp_sort_entry *
 __sort_dimension__alloc_hpp(struct sort_dimension *sd)
 {
@@ -1472,6 +1477,7 @@ __sort_dimension__alloc_hpp(struct sort_dimension *sd)
 	hse->hpp.cmp = __sort__hpp_cmp;
 	hse->hpp.collapse = __sort__hpp_collapse;
 	hse->hpp.sort = __sort__hpp_sort;
+	hse->hpp.equal = __sort__hpp_equal;
 
 	INIT_LIST_HEAD(&hse->hpp.list);
 	INIT_LIST_HEAD(&hse->hpp.sort_list);
@@ -1482,11 +1488,6 @@ __sort_dimension__alloc_hpp(struct sort_dimension *sd)
 	return hse;
 }
 
-bool perf_hpp__is_sort_entry(struct perf_hpp_fmt *format)
-{
-	return format->header == __sort__hpp_header;
-}
-
 static int __sort_dimension__add_hpp_sort(struct sort_dimension *sd)
 {
 	struct hpp_sort_entry *hse = __sort_dimension__alloc_hpp(sd);
