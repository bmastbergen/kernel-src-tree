perf hists: Fix indent for multiple hierarchy sort key

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit 2dbbe9f26c082be5aa0e8ba5480e7bac43b2c4f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2dbbe9f2.failed

When multiple sort keys are used in a single hierarchy, it should indent
using number of hierarchy levels instead of number of sort keys.

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1457361308-514-5-git-send-email-namhyung@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 2dbbe9f26c082be5aa0e8ba5480e7bac43b2c4f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/ui/browsers/hists.c
#	tools/perf/ui/hist.c
#	tools/perf/ui/stdio/hist.c
#	tools/perf/util/hist.h
diff --cc tools/perf/ui/browsers/hists.c
index d1445dd5bb7f,2f02ce79bd9d..000000000000
--- a/tools/perf/ui/browsers/hists.c
+++ b/tools/perf/ui/browsers/hists.c
@@@ -1213,6 -1277,233 +1213,236 @@@ static int hist_browser__show_entry(str
  	return printed;
  }
  
++<<<<<<< HEAD
++=======
+ static int hist_browser__show_hierarchy_entry(struct hist_browser *browser,
+ 					      struct hist_entry *entry,
+ 					      unsigned short row,
+ 					      int level)
+ {
+ 	int printed = 0;
+ 	int width = browser->b.width;
+ 	char folded_sign = ' ';
+ 	bool current_entry = ui_browser__is_current_entry(&browser->b, row);
+ 	off_t row_offset = entry->row_offset;
+ 	bool first = true;
+ 	struct perf_hpp_fmt *fmt;
+ 	struct hpp_arg arg = {
+ 		.b		= &browser->b,
+ 		.current_entry	= current_entry,
+ 	};
+ 	int column = 0;
+ 	int hierarchy_indent = (entry->hists->nr_hpp_node - 2) * HIERARCHY_INDENT;
+ 
+ 	if (current_entry) {
+ 		browser->he_selection = entry;
+ 		browser->selection = &entry->ms;
+ 	}
+ 
+ 	hist_entry__init_have_children(entry);
+ 	folded_sign = hist_entry__folded(entry);
+ 	arg.folded_sign = folded_sign;
+ 
+ 	if (entry->leaf && row_offset) {
+ 		row_offset--;
+ 		goto show_callchain;
+ 	}
+ 
+ 	hist_browser__gotorc(browser, row, 0);
+ 
+ 	if (current_entry && browser->b.navkeypressed)
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_SELECTED);
+ 	else
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_NORMAL);
+ 
+ 	ui_browser__write_nstring(&browser->b, "", level * HIERARCHY_INDENT);
+ 	width -= level * HIERARCHY_INDENT;
+ 
+ 	hists__for_each_format(entry->hists, fmt) {
+ 		char s[2048];
+ 		struct perf_hpp hpp = {
+ 			.buf		= s,
+ 			.size		= sizeof(s),
+ 			.ptr		= &arg,
+ 		};
+ 
+ 		if (perf_hpp__should_skip(fmt, entry->hists) ||
+ 		    column++ < browser->b.horiz_scroll)
+ 			continue;
+ 
+ 		if (perf_hpp__is_sort_entry(fmt) ||
+ 		    perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		if (current_entry && browser->b.navkeypressed) {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_SELECTED);
+ 		} else {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_NORMAL);
+ 		}
+ 
+ 		if (first) {
+ 			ui_browser__printf(&browser->b, "%c", folded_sign);
+ 			width--;
+ 			first = false;
+ 		} else {
+ 			ui_browser__printf(&browser->b, "  ");
+ 			width -= 2;
+ 		}
+ 
+ 		if (fmt->color) {
+ 			int ret = fmt->color(fmt, &hpp, entry);
+ 			hist_entry__snprintf_alignment(entry, &hpp, fmt, ret);
+ 			/*
+ 			 * fmt->color() already used ui_browser to
+ 			 * print the non alignment bits, skip it (+ret):
+ 			 */
+ 			ui_browser__printf(&browser->b, "%s", s + ret);
+ 		} else {
+ 			int ret = fmt->entry(fmt, &hpp, entry);
+ 			hist_entry__snprintf_alignment(entry, &hpp, fmt, ret);
+ 			ui_browser__printf(&browser->b, "%s", s);
+ 		}
+ 		width -= hpp.buf - s;
+ 	}
+ 
+ 	ui_browser__write_nstring(&browser->b, "", hierarchy_indent);
+ 	width -= hierarchy_indent;
+ 
+ 	if (column >= browser->b.horiz_scroll) {
+ 		char s[2048];
+ 		struct perf_hpp hpp = {
+ 			.buf		= s,
+ 			.size		= sizeof(s),
+ 			.ptr		= &arg,
+ 		};
+ 
+ 		if (current_entry && browser->b.navkeypressed) {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_SELECTED);
+ 		} else {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_NORMAL);
+ 		}
+ 
+ 		perf_hpp_list__for_each_format(entry->hpp_list, fmt) {
+ 			ui_browser__write_nstring(&browser->b, "", 2);
+ 			width -= 2;
+ 
+ 			/*
+ 			 * No need to call hist_entry__snprintf_alignment()
+ 			 * since this fmt is always the last column in the
+ 			 * hierarchy mode.
+ 			 */
+ 			if (fmt->color) {
+ 				width -= fmt->color(fmt, &hpp, entry);
+ 			} else {
+ 				int i = 0;
+ 
+ 				width -= fmt->entry(fmt, &hpp, entry);
+ 				ui_browser__printf(&browser->b, "%s", ltrim(s));
+ 
+ 				while (isspace(s[i++]))
+ 					width++;
+ 			}
+ 		}
+ 	}
+ 
+ 	/* The scroll bar isn't being used */
+ 	if (!browser->b.navkeypressed)
+ 		width += 1;
+ 
+ 	ui_browser__write_nstring(&browser->b, "", width);
+ 
+ 	++row;
+ 	++printed;
+ 
+ show_callchain:
+ 	if (entry->leaf && folded_sign == '-' && row != browser->b.rows) {
+ 		struct callchain_print_arg carg = {
+ 			.row_offset = row_offset,
+ 		};
+ 
+ 		printed += hist_browser__show_callchain(browser, entry,
+ 					level + 1, row,
+ 					hist_browser__show_callchain_entry, &carg,
+ 					hist_browser__check_output_full);
+ 	}
+ 
+ 	return printed;
+ }
+ 
+ static int hist_browser__show_no_entry(struct hist_browser *browser,
+ 				       unsigned short row, int level)
+ {
+ 	int width = browser->b.width;
+ 	bool current_entry = ui_browser__is_current_entry(&browser->b, row);
+ 	bool first = true;
+ 	int column = 0;
+ 	int ret;
+ 	struct perf_hpp_fmt *fmt;
+ 	int indent = browser->hists->nr_hpp_node - 2;
+ 
+ 	if (current_entry) {
+ 		browser->he_selection = NULL;
+ 		browser->selection = NULL;
+ 	}
+ 
+ 	hist_browser__gotorc(browser, row, 0);
+ 
+ 	if (current_entry && browser->b.navkeypressed)
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_SELECTED);
+ 	else
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_NORMAL);
+ 
+ 	ui_browser__write_nstring(&browser->b, "", level * HIERARCHY_INDENT);
+ 	width -= level * HIERARCHY_INDENT;
+ 
+ 	hists__for_each_format(browser->hists, fmt) {
+ 		if (perf_hpp__should_skip(fmt, browser->hists) ||
+ 		    column++ < browser->b.horiz_scroll)
+ 			continue;
+ 
+ 		if (perf_hpp__is_sort_entry(fmt) ||
+ 		    perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		ret = fmt->width(fmt, NULL, hists_to_evsel(browser->hists));
+ 
+ 		if (first) {
+ 			/* for folded sign */
+ 			first = false;
+ 			ret++;
+ 		} else {
+ 			/* space between columns */
+ 			ret += 2;
+ 		}
+ 
+ 		ui_browser__write_nstring(&browser->b, "", ret);
+ 		width -= ret;
+ 	}
+ 
+ 	ui_browser__write_nstring(&browser->b, "", indent * HIERARCHY_INDENT);
+ 	width -= indent * HIERARCHY_INDENT;
+ 
+ 	if (column >= browser->b.horiz_scroll) {
+ 		char buf[32];
+ 
+ 		ret = snprintf(buf, sizeof(buf), "no entry >= %.2f%%", browser->min_pcnt);
+ 		ui_browser__printf(&browser->b, "  %s", buf);
+ 		width -= ret + 2;
+ 	}
+ 
+ 	/* The scroll bar isn't being used */
+ 	if (!browser->b.navkeypressed)
+ 		width += 1;
+ 
+ 	ui_browser__write_nstring(&browser->b, "", width);
+ 	return 1;
+ }
+ 
++>>>>>>> 2dbbe9f26c08 (perf hists: Fix indent for multiple hierarchy sort key)
  static int advance_hpp_check(struct perf_hpp *hpp, int inc)
  {
  	advance_hpp(hpp, inc);
@@@ -1262,7 -1553,7 +1492,11 @@@ static int hists_browser__scnprintf_hie
  	struct perf_hpp_fmt *fmt;
  	size_t ret = 0;
  	int column = 0;
++<<<<<<< HEAD
 +	int nr_sort_keys = hists->hpp_list->nr_sort_keys;
++=======
+ 	int indent = hists->nr_hpp_node - 2;
++>>>>>>> 2dbbe9f26c08 (perf hists: Fix indent for multiple hierarchy sort key)
  	bool first = true;
  
  	ret = scnprintf(buf, size, " ");
@@@ -1368,7 -1669,20 +1602,24 @@@ static unsigned int hist_browser__refre
  		if (percent < hb->min_pcnt)
  			continue;
  
++<<<<<<< HEAD
 +		row += hist_browser__show_entry(hb, h, row);
++=======
+ 		if (symbol_conf.report_hierarchy) {
+ 			row += hist_browser__show_hierarchy_entry(hb, h, row,
+ 								  h->depth);
+ 			if (row == browser->rows)
+ 				break;
+ 
+ 			if (h->has_no_entry) {
+ 				hist_browser__show_no_entry(hb, row, h->depth);
+ 				row++;
+ 			}
+ 		} else {
+ 			row += hist_browser__show_entry(hb, h, row);
+ 		}
+ 
++>>>>>>> 2dbbe9f26c08 (perf hists: Fix indent for multiple hierarchy sort key)
  		if (row == browser->rows)
  			break;
  	}
diff --cc tools/perf/ui/hist.c
index ad40452da995,f03c4f70438f..000000000000
--- a/tools/perf/ui/hist.c
+++ b/tools/perf/ui/hist.c
@@@ -687,3 -716,71 +687,74 @@@ void perf_hpp__set_user_width(const cha
  			break;
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ static int add_hierarchy_fmt(struct hists *hists, struct perf_hpp_fmt *fmt)
+ {
+ 	struct perf_hpp_list_node *node = NULL;
+ 	struct perf_hpp_fmt *fmt_copy;
+ 	bool found = false;
+ 	bool skip = perf_hpp__should_skip(fmt, hists);
+ 
+ 	list_for_each_entry(node, &hists->hpp_formats, list) {
+ 		if (node->level == fmt->level) {
+ 			found = true;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (!found) {
+ 		node = malloc(sizeof(*node));
+ 		if (node == NULL)
+ 			return -1;
+ 
+ 		node->skip = skip;
+ 		node->level = fmt->level;
+ 		perf_hpp_list__init(&node->hpp);
+ 
+ 		hists->nr_hpp_node++;
+ 		list_add_tail(&node->list, &hists->hpp_formats);
+ 	}
+ 
+ 	fmt_copy = perf_hpp_fmt__dup(fmt);
+ 	if (fmt_copy == NULL)
+ 		return -1;
+ 
+ 	if (!skip)
+ 		node->skip = false;
+ 
+ 	list_add_tail(&fmt_copy->list, &node->hpp.fields);
+ 	list_add_tail(&fmt_copy->sort_list, &node->hpp.sorts);
+ 
+ 	return 0;
+ }
+ 
+ int perf_hpp__setup_hists_formats(struct perf_hpp_list *list,
+ 				  struct perf_evlist *evlist)
+ {
+ 	struct perf_evsel *evsel;
+ 	struct perf_hpp_fmt *fmt;
+ 	struct hists *hists;
+ 	int ret;
+ 
+ 	if (!symbol_conf.report_hierarchy)
+ 		return 0;
+ 
+ 	evlist__for_each(evlist, evsel) {
+ 		hists = evsel__hists(evsel);
+ 
+ 		perf_hpp_list__for_each_sort_list(list, fmt) {
+ 			if (perf_hpp__is_dynamic_entry(fmt) &&
+ 			    !perf_hpp__defined_dynamic_entry(fmt, hists))
+ 				continue;
+ 
+ 			ret = add_hierarchy_fmt(hists, fmt);
+ 			if (ret < 0)
+ 				return ret;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
++>>>>>>> 2dbbe9f26c08 (perf hists: Fix indent for multiple hierarchy sort key)
diff --cc tools/perf/ui/stdio/hist.c
index 28fcb1ee0342,543d7137cc0c..000000000000
--- a/tools/perf/ui/stdio/hist.c
+++ b/tools/perf/ui/stdio/hist.c
@@@ -409,6 -410,86 +409,89 @@@ static int hist_entry__snprintf(struct 
  	return hpp->buf - start;
  }
  
++<<<<<<< HEAD
++=======
+ static int hist_entry__hierarchy_fprintf(struct hist_entry *he,
+ 					 struct perf_hpp *hpp,
+ 					 struct hists *hists,
+ 					 FILE *fp)
+ {
+ 	const char *sep = symbol_conf.field_sep;
+ 	struct perf_hpp_fmt *fmt;
+ 	char *buf = hpp->buf;
+ 	size_t size = hpp->size;
+ 	int ret, printed = 0;
+ 	bool first = true;
+ 
+ 	if (symbol_conf.exclude_other && !he->parent)
+ 		return 0;
+ 
+ 	ret = scnprintf(hpp->buf, hpp->size, "%*s", he->depth * HIERARCHY_INDENT, "");
+ 	advance_hpp(hpp, ret);
+ 
+ 	hists__for_each_format(he->hists, fmt) {
+ 		if (perf_hpp__is_sort_entry(fmt) || perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		/*
+ 		 * If there's no field_sep, we still need
+ 		 * to display initial '  '.
+ 		 */
+ 		if (!sep || !first) {
+ 			ret = scnprintf(hpp->buf, hpp->size, "%s", sep ?: "  ");
+ 			advance_hpp(hpp, ret);
+ 		} else
+ 			first = false;
+ 
+ 		if (perf_hpp__use_color() && fmt->color)
+ 			ret = fmt->color(fmt, hpp, he);
+ 		else
+ 			ret = fmt->entry(fmt, hpp, he);
+ 
+ 		ret = hist_entry__snprintf_alignment(he, hpp, fmt, ret);
+ 		advance_hpp(hpp, ret);
+ 	}
+ 
+ 	if (!sep)
+ 		ret = scnprintf(hpp->buf, hpp->size, "%*s",
+ 				(hists->nr_hpp_node - 2) * HIERARCHY_INDENT, "");
+ 	advance_hpp(hpp, ret);
+ 
+ 	printed += fprintf(fp, "%s", buf);
+ 
+ 	perf_hpp_list__for_each_format(he->hpp_list, fmt) {
+ 		hpp->buf  = buf;
+ 		hpp->size = size;
+ 
+ 		/*
+ 		 * No need to call hist_entry__snprintf_alignment() since this
+ 		 * fmt is always the last column in the hierarchy mode.
+ 		 */
+ 		if (perf_hpp__use_color() && fmt->color)
+ 			fmt->color(fmt, hpp, he);
+ 		else
+ 			fmt->entry(fmt, hpp, he);
+ 
+ 		/*
+ 		 * dynamic entries are right-aligned but we want left-aligned
+ 		 * in the hierarchy mode
+ 		 */
+ 		printed += fprintf(fp, "%s%s", sep ?: "  ", ltrim(buf));
+ 	}
+ 	printed += putc('\n', fp);
+ 
+ 	if (symbol_conf.use_callchain && he->leaf) {
+ 		u64 total = hists__total_period(hists);
+ 
+ 		printed += hist_entry_callchain__fprintf(he, total, 0, fp);
+ 		goto out;
+ 	}
+ 
+ out:
+ 	return printed;
+ }
+ 
++>>>>>>> 2dbbe9f26c08 (perf hists: Fix indent for multiple hierarchy sort key)
  static int hist_entry__fprintf(struct hist_entry *he, size_t size,
  			       struct hists *hists,
  			       char *bf, size_t bfsz, FILE *fp)
@@@ -423,6 -504,9 +506,12 @@@
  	if (size == 0 || size > bfsz)
  		size = hpp.size = bfsz;
  
++<<<<<<< HEAD
++=======
+ 	if (symbol_conf.report_hierarchy)
+ 		return hist_entry__hierarchy_fprintf(he, &hpp, hists, fp);
+ 
++>>>>>>> 2dbbe9f26c08 (perf hists: Fix indent for multiple hierarchy sort key)
  	hist_entry__snprintf(he, &hpp);
  
  	ret = fprintf(fp, "%s\n", bf);
@@@ -433,6 -517,106 +522,109 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int print_hierarchy_indent(const char *sep, int indent,
+ 				  const char *line, FILE *fp)
+ {
+ 	if (sep != NULL || indent < 2)
+ 		return 0;
+ 
+ 	return fprintf(fp, "%-.*s", (indent - 2) * HIERARCHY_INDENT, line);
+ }
+ 
+ static int print_hierarchy_header(struct hists *hists, struct perf_hpp *hpp,
+ 				  const char *sep, FILE *fp)
+ {
+ 	bool first = true;
+ 	int indent;
+ 	int depth;
+ 	unsigned width = 0;
+ 	unsigned header_width = 0;
+ 	struct perf_hpp_fmt *fmt;
+ 
+ 	indent = hists->nr_hpp_node;
+ 
+ 	/* preserve max indent depth for column headers */
+ 	print_hierarchy_indent(sep, indent, spaces, fp);
+ 
+ 	hists__for_each_format(hists, fmt) {
+ 		if (perf_hpp__is_sort_entry(fmt) || perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		if (!first)
+ 			fprintf(fp, "%s", sep ?: "  ");
+ 		else
+ 			first = false;
+ 
+ 		fmt->header(fmt, hpp, hists_to_evsel(hists));
+ 		fprintf(fp, "%s", hpp->buf);
+ 	}
+ 
+ 	/* combine sort headers with ' / ' */
+ 	first = true;
+ 	hists__for_each_format(hists, fmt) {
+ 		if (!perf_hpp__is_sort_entry(fmt) && !perf_hpp__is_dynamic_entry(fmt))
+ 			continue;
+ 		if (perf_hpp__should_skip(fmt, hists))
+ 			continue;
+ 
+ 		if (!first)
+ 			header_width += fprintf(fp, " / ");
+ 		else {
+ 			fprintf(fp, "%s", sep ?: "  ");
+ 			first = false;
+ 		}
+ 
+ 		fmt->header(fmt, hpp, hists_to_evsel(hists));
+ 		rtrim(hpp->buf);
+ 
+ 		header_width += fprintf(fp, "%s", ltrim(hpp->buf));
+ 	}
+ 
+ 	fprintf(fp, "\n# ");
+ 
+ 	/* preserve max indent depth for initial dots */
+ 	print_hierarchy_indent(sep, indent, dots, fp);
+ 
+ 	first = true;
+ 	hists__for_each_format(hists, fmt) {
+ 		if (perf_hpp__is_sort_entry(fmt) || perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		if (!first)
+ 			fprintf(fp, "%s", sep ?: "  ");
+ 		else
+ 			first = false;
+ 
+ 		width = fmt->width(fmt, hpp, hists_to_evsel(hists));
+ 		fprintf(fp, "%.*s", width, dots);
+ 	}
+ 
+ 	depth = 0;
+ 	hists__for_each_format(hists, fmt) {
+ 		if (!perf_hpp__is_sort_entry(fmt) && !perf_hpp__is_dynamic_entry(fmt))
+ 			continue;
+ 		if (perf_hpp__should_skip(fmt, hists))
+ 			continue;
+ 
+ 		width = fmt->width(fmt, hpp, hists_to_evsel(hists));
+ 		width += depth * HIERARCHY_INDENT;
+ 
+ 		if (width > header_width)
+ 			header_width = width;
+ 
+ 		depth++;
+ 	}
+ 
+ 	fprintf(fp, "%s%-.*s", sep ?: "  ", header_width, dots);
+ 
+ 	fprintf(fp, "\n#\n");
+ 
+ 	return 2;
+ }
+ 
++>>>>>>> 2dbbe9f26c08 (perf hists: Fix indent for multiple hierarchy sort key)
  size_t hists__fprintf(struct hists *hists, bool show_header, int max_rows,
  		      int max_cols, float min_pcnt, FILE *fp)
  {
diff --cc tools/perf/util/hist.h
index 1d52912874e9,2cb017f28f9e..000000000000
--- a/tools/perf/util/hist.h
+++ b/tools/perf/util/hist.h
@@@ -71,6 -76,11 +71,14 @@@ struct hists 
  	struct events_stats	stats;
  	u64			event_stream;
  	u16			col_len[HISTC_NR_COLS];
++<<<<<<< HEAD
++=======
+ 	int			socket_filter;
+ 	struct perf_hpp_list	*hpp_list;
+ 	struct list_head	hpp_formats;
+ 	int			nr_sort_keys;
+ 	int			nr_hpp_node;
++>>>>>>> 2dbbe9f26c08 (perf hists: Fix indent for multiple hierarchy sort key)
  };
  
  struct hist_entry_iter;
* Unmerged path tools/perf/ui/browsers/hists.c
* Unmerged path tools/perf/ui/hist.c
* Unmerged path tools/perf/ui/stdio/hist.c
* Unmerged path tools/perf/util/hist.h
