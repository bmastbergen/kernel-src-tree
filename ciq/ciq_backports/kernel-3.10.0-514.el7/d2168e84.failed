netfilter: nft_limit: add per-byte limiting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit d2168e849ebf617b2b7feae44c0c0baf739cb610
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d2168e84.failed

This patch adds a new NFTA_LIMIT_TYPE netlink attribute to indicate the type of
limiting.

Contrary to per-packet limiting, the cost is calculated from the packet path
since this depends on the packet length.

The burst attribute indicates the number of bytes in which the rate can be
exceeded.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit d2168e849ebf617b2b7feae44c0c0baf739cb610)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/netfilter/nf_tables.h
#	net/netfilter/nft_limit.c
diff --cc include/uapi/linux/netfilter/nf_tables.h
index 971d245e7378,d8c8a7c9d88a..000000000000
--- a/include/uapi/linux/netfilter/nf_tables.h
+++ b/include/uapi/linux/netfilter/nf_tables.h
@@@ -688,11 -766,15 +693,21 @@@ enum nft_limit_type 
   *
   * @NFTA_LIMIT_RATE: refill rate (NLA_U64)
   * @NFTA_LIMIT_UNIT: refill unit (NLA_U64)
++<<<<<<< HEAD
++=======
+  * @NFTA_LIMIT_BURST: burst (NLA_U32)
+  * @NFTA_LIMIT_TYPE: type of limit (NLA_U32: enum nft_limit_type)
++>>>>>>> d2168e849ebf (netfilter: nft_limit: add per-byte limiting)
   */
  enum nft_limit_attributes {
  	NFTA_LIMIT_UNSPEC,
  	NFTA_LIMIT_RATE,
  	NFTA_LIMIT_UNIT,
++<<<<<<< HEAD
++=======
+ 	NFTA_LIMIT_BURST,
+ 	NFTA_LIMIT_TYPE,
++>>>>>>> d2168e849ebf (netfilter: nft_limit: add per-byte limiting)
  	__NFTA_LIMIT_MAX
  };
  #define NFTA_LIMIT_MAX		(__NFTA_LIMIT_MAX - 1)
diff --cc net/netfilter/nft_limit.c
index 5301b69b3692,5d67938f8b2f..000000000000
--- a/net/netfilter/nft_limit.c
+++ b/net/netfilter/nft_limit.c
@@@ -80,13 -83,16 +80,25 @@@ static int nft_limit_init(const struct 
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int nft_limit_dump(struct sk_buff *skb, const struct nft_expr *expr)
++=======
+ static int nft_limit_dump(struct sk_buff *skb, const struct nft_limit *limit,
+ 			  enum nft_limit_type type)
++>>>>>>> d2168e849ebf (netfilter: nft_limit: add per-byte limiting)
  {
 -	u64 secs = div_u64(limit->nsecs, NSEC_PER_SEC);
 -	u64 rate = limit->rate - limit->burst;
 +	const struct nft_limit *priv = nft_expr_priv(expr);
 +	u64 secs = div_u64(priv->nsecs, NSEC_PER_SEC);
  
++<<<<<<< HEAD
 +	if (nla_put_be64(skb, NFTA_LIMIT_RATE, cpu_to_be64(priv->rate)) ||
 +	    nla_put_be64(skb, NFTA_LIMIT_UNIT, cpu_to_be64(secs)))
++=======
+ 	if (nla_put_be64(skb, NFTA_LIMIT_RATE, cpu_to_be64(rate)) ||
+ 	    nla_put_be64(skb, NFTA_LIMIT_UNIT, cpu_to_be64(secs)) ||
+ 	    nla_put_be32(skb, NFTA_LIMIT_BURST, htonl(limit->burst)) ||
+ 	    nla_put_be32(skb, NFTA_LIMIT_TYPE, htonl(type)))
++>>>>>>> d2168e849ebf (netfilter: nft_limit: add per-byte limiting)
  		goto nla_put_failure;
  	return 0;
  
@@@ -94,18 -100,114 +106,121 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ struct nft_limit_pkts {
+ 	struct nft_limit	limit;
+ 	u64			cost;
+ };
+ 
+ static void nft_limit_pkts_eval(const struct nft_expr *expr,
+ 				struct nft_regs *regs,
+ 				const struct nft_pktinfo *pkt)
+ {
+ 	struct nft_limit_pkts *priv = nft_expr_priv(expr);
+ 
+ 	if (nft_limit_eval(&priv->limit, priv->cost))
+ 		regs->verdict.code = NFT_BREAK;
+ }
+ 
+ static const struct nla_policy nft_limit_policy[NFTA_LIMIT_MAX + 1] = {
+ 	[NFTA_LIMIT_RATE]	= { .type = NLA_U64 },
+ 	[NFTA_LIMIT_UNIT]	= { .type = NLA_U64 },
+ 	[NFTA_LIMIT_BURST]	= { .type = NLA_U32 },
+ 	[NFTA_LIMIT_TYPE]	= { .type = NLA_U32 },
+ };
+ 
+ static int nft_limit_pkts_init(const struct nft_ctx *ctx,
+ 			       const struct nft_expr *expr,
+ 			       const struct nlattr * const tb[])
+ {
+ 	struct nft_limit_pkts *priv = nft_expr_priv(expr);
+ 	int err;
+ 
+ 	err = nft_limit_init(&priv->limit, tb);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	priv->cost = div_u64(priv->limit.nsecs, priv->limit.rate);
+ 	return 0;
+ }
+ 
+ static int nft_limit_pkts_dump(struct sk_buff *skb, const struct nft_expr *expr)
+ {
+ 	const struct nft_limit_pkts *priv = nft_expr_priv(expr);
+ 
+ 	return nft_limit_dump(skb, &priv->limit, NFT_LIMIT_PKTS);
+ }
+ 
++>>>>>>> d2168e849ebf (netfilter: nft_limit: add per-byte limiting)
  static struct nft_expr_type nft_limit_type;
 -static const struct nft_expr_ops nft_limit_pkts_ops = {
 +static const struct nft_expr_ops nft_limit_ops = {
  	.type		= &nft_limit_type,
 -	.size		= NFT_EXPR_SIZE(sizeof(struct nft_limit_pkts)),
 -	.eval		= nft_limit_pkts_eval,
 -	.init		= nft_limit_pkts_init,
 -	.dump		= nft_limit_pkts_dump,
 +	.size		= NFT_EXPR_SIZE(sizeof(struct nft_limit)),
 +	.eval		= nft_limit_eval,
 +	.init		= nft_limit_init,
 +	.dump		= nft_limit_dump,
  };
  
+ static void nft_limit_pkt_bytes_eval(const struct nft_expr *expr,
+ 				     struct nft_regs *regs,
+ 				     const struct nft_pktinfo *pkt)
+ {
+ 	struct nft_limit *priv = nft_expr_priv(expr);
+ 	u64 cost = div_u64(priv->nsecs * pkt->skb->len, priv->rate);
+ 
+ 	if (nft_limit_eval(priv, cost))
+ 		regs->verdict.code = NFT_BREAK;
+ }
+ 
+ static int nft_limit_pkt_bytes_init(const struct nft_ctx *ctx,
+ 				    const struct nft_expr *expr,
+ 				    const struct nlattr * const tb[])
+ {
+ 	struct nft_limit *priv = nft_expr_priv(expr);
+ 
+ 	return nft_limit_init(priv, tb);
+ }
+ 
+ static int nft_limit_pkt_bytes_dump(struct sk_buff *skb,
+ 				    const struct nft_expr *expr)
+ {
+ 	const struct nft_limit *priv = nft_expr_priv(expr);
+ 
+ 	return nft_limit_dump(skb, priv, NFT_LIMIT_PKT_BYTES);
+ }
+ 
+ static const struct nft_expr_ops nft_limit_pkt_bytes_ops = {
+ 	.type		= &nft_limit_type,
+ 	.size		= NFT_EXPR_SIZE(sizeof(struct nft_limit)),
+ 	.eval		= nft_limit_pkt_bytes_eval,
+ 	.init		= nft_limit_pkt_bytes_init,
+ 	.dump		= nft_limit_pkt_bytes_dump,
+ };
+ 
+ static const struct nft_expr_ops *
+ nft_limit_select_ops(const struct nft_ctx *ctx,
+ 		     const struct nlattr * const tb[])
+ {
+ 	if (tb[NFTA_LIMIT_TYPE] == NULL)
+ 		return &nft_limit_pkts_ops;
+ 
+ 	switch (ntohl(nla_get_be32(tb[NFTA_LIMIT_TYPE]))) {
+ 	case NFT_LIMIT_PKTS:
+ 		return &nft_limit_pkts_ops;
+ 	case NFT_LIMIT_PKT_BYTES:
+ 		return &nft_limit_pkt_bytes_ops;
+ 	}
+ 	return ERR_PTR(-EOPNOTSUPP);
+ }
+ 
  static struct nft_expr_type nft_limit_type __read_mostly = {
  	.name		= "limit",
++<<<<<<< HEAD
 +	.ops		= &nft_limit_ops,
++=======
+ 	.select_ops	= nft_limit_select_ops,
++>>>>>>> d2168e849ebf (netfilter: nft_limit: add per-byte limiting)
  	.policy		= nft_limit_policy,
  	.maxattr	= NFTA_LIMIT_MAX,
  	.flags		= NFT_EXPR_STATEFUL,
* Unmerged path include/uapi/linux/netfilter/nf_tables.h
* Unmerged path net/netfilter/nft_limit.c
