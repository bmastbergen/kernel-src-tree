r8152: rename tx_underun

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author hayeswang <hayeswang@realtek.com>
commit f37119c57ba7591b365b41697f971ca3e1f16ed1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f37119c5.failed

Replace tx_underun with tx_underrun for checkpatch.pl.

	Signed-off-by: Hayes Wang <hayeswang@realtek.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f37119c57ba7591b365b41697f971ca3e1f16ed1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/r8152.c
diff --cc drivers/net/usb/r8152.c
index 0f9c353ad1ea,fdea19412cdb..000000000000
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@@ -458,6 -470,25 +458,28 @@@ enum rtl8152_flags 
  #define MCU_TYPE_PLA			0x0100
  #define MCU_TYPE_USB			0x0000
  
++<<<<<<< HEAD
++=======
+ #define REALTEK_USB_DEVICE(vend, prod)	\
+ 	USB_DEVICE_INTERFACE_CLASS(vend, prod, USB_CLASS_VENDOR_SPEC)
+ 
+ struct tally_counter {
+ 	__le64	tx_packets;
+ 	__le64	rx_packets;
+ 	__le64	tx_errors;
+ 	__le32	rx_errors;
+ 	__le16	rx_missed;
+ 	__le16	align_errors;
+ 	__le32	tx_one_collision;
+ 	__le32	tx_multi_collision;
+ 	__le64	rx_unicast;
+ 	__le64	rx_broadcast;
+ 	__le32	rx_multicast;
+ 	__le16	tx_aborted;
+ 	__le16	tx_underrun;
+ };
+ 
++>>>>>>> f37119c57ba7 (r8152: rename tx_underun)
  struct rx_desc {
  	__le32 opts1;
  #define RX_LEN_MASK			0x7fff
@@@ -3267,8 -3357,201 +3289,202 @@@ static int rtl8152_set_settings(struct 
  	if (ret < 0)
  		goto out;
  
 -	mutex_lock(&tp->control);
 -
  	ret = rtl8152_set_speed(tp, cmd->autoneg, cmd->speed, cmd->duplex);
  
++<<<<<<< HEAD
++=======
+ 	mutex_unlock(&tp->control);
+ 
+ 	usb_autopm_put_interface(tp->intf);
+ 
+ out:
+ 	return ret;
+ }
+ 
+ static const char rtl8152_gstrings[][ETH_GSTRING_LEN] = {
+ 	"tx_packets",
+ 	"rx_packets",
+ 	"tx_errors",
+ 	"rx_errors",
+ 	"rx_missed",
+ 	"align_errors",
+ 	"tx_single_collisions",
+ 	"tx_multi_collisions",
+ 	"rx_unicast",
+ 	"rx_broadcast",
+ 	"rx_multicast",
+ 	"tx_aborted",
+ 	"tx_underrun",
+ };
+ 
+ static int rtl8152_get_sset_count(struct net_device *dev, int sset)
+ {
+ 	switch (sset) {
+ 	case ETH_SS_STATS:
+ 		return ARRAY_SIZE(rtl8152_gstrings);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static void rtl8152_get_ethtool_stats(struct net_device *dev,
+ 				      struct ethtool_stats *stats, u64 *data)
+ {
+ 	struct r8152 *tp = netdev_priv(dev);
+ 	struct tally_counter tally;
+ 
+ 	if (usb_autopm_get_interface(tp->intf) < 0)
+ 		return;
+ 
+ 	generic_ocp_read(tp, PLA_TALLYCNT, sizeof(tally), &tally, MCU_TYPE_PLA);
+ 
+ 	usb_autopm_put_interface(tp->intf);
+ 
+ 	data[0] = le64_to_cpu(tally.tx_packets);
+ 	data[1] = le64_to_cpu(tally.rx_packets);
+ 	data[2] = le64_to_cpu(tally.tx_errors);
+ 	data[3] = le32_to_cpu(tally.rx_errors);
+ 	data[4] = le16_to_cpu(tally.rx_missed);
+ 	data[5] = le16_to_cpu(tally.align_errors);
+ 	data[6] = le32_to_cpu(tally.tx_one_collision);
+ 	data[7] = le32_to_cpu(tally.tx_multi_collision);
+ 	data[8] = le64_to_cpu(tally.rx_unicast);
+ 	data[9] = le64_to_cpu(tally.rx_broadcast);
+ 	data[10] = le32_to_cpu(tally.rx_multicast);
+ 	data[11] = le16_to_cpu(tally.tx_aborted);
+ 	data[12] = le16_to_cpu(tally.tx_underrun);
+ }
+ 
+ static void rtl8152_get_strings(struct net_device *dev, u32 stringset, u8 *data)
+ {
+ 	switch (stringset) {
+ 	case ETH_SS_STATS:
+ 		memcpy(data, *rtl8152_gstrings, sizeof(rtl8152_gstrings));
+ 		break;
+ 	}
+ }
+ 
+ static int r8152_get_eee(struct r8152 *tp, struct ethtool_eee *eee)
+ {
+ 	u32 ocp_data, lp, adv, supported = 0;
+ 	u16 val;
+ 
+ 	val = r8152_mmd_read(tp, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);
+ 	supported = mmd_eee_cap_to_ethtool_sup_t(val);
+ 
+ 	val = r8152_mmd_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV);
+ 	adv = mmd_eee_adv_to_ethtool_adv_t(val);
+ 
+ 	val = r8152_mmd_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_LPABLE);
+ 	lp = mmd_eee_adv_to_ethtool_adv_t(val);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);
+ 	ocp_data &= EEE_RX_EN | EEE_TX_EN;
+ 
+ 	eee->eee_enabled = !!ocp_data;
+ 	eee->eee_active = !!(supported & adv & lp);
+ 	eee->supported = supported;
+ 	eee->advertised = adv;
+ 	eee->lp_advertised = lp;
+ 
+ 	return 0;
+ }
+ 
+ static int r8152_set_eee(struct r8152 *tp, struct ethtool_eee *eee)
+ {
+ 	u16 val = ethtool_adv_to_mmd_eee_adv_t(eee->advertised);
+ 
+ 	r8152_eee_en(tp, eee->eee_enabled);
+ 
+ 	if (!eee->eee_enabled)
+ 		val = 0;
+ 
+ 	r8152_mmd_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV, val);
+ 
+ 	return 0;
+ }
+ 
+ static int r8153_get_eee(struct r8152 *tp, struct ethtool_eee *eee)
+ {
+ 	u32 ocp_data, lp, adv, supported = 0;
+ 	u16 val;
+ 
+ 	val = ocp_reg_read(tp, OCP_EEE_ABLE);
+ 	supported = mmd_eee_cap_to_ethtool_sup_t(val);
+ 
+ 	val = ocp_reg_read(tp, OCP_EEE_ADV);
+ 	adv = mmd_eee_adv_to_ethtool_adv_t(val);
+ 
+ 	val = ocp_reg_read(tp, OCP_EEE_LPABLE);
+ 	lp = mmd_eee_adv_to_ethtool_adv_t(val);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);
+ 	ocp_data &= EEE_RX_EN | EEE_TX_EN;
+ 
+ 	eee->eee_enabled = !!ocp_data;
+ 	eee->eee_active = !!(supported & adv & lp);
+ 	eee->supported = supported;
+ 	eee->advertised = adv;
+ 	eee->lp_advertised = lp;
+ 
+ 	return 0;
+ }
+ 
+ static int r8153_set_eee(struct r8152 *tp, struct ethtool_eee *eee)
+ {
+ 	u16 val = ethtool_adv_to_mmd_eee_adv_t(eee->advertised);
+ 
+ 	r8153_eee_en(tp, eee->eee_enabled);
+ 
+ 	if (!eee->eee_enabled)
+ 		val = 0;
+ 
+ 	ocp_reg_write(tp, OCP_EEE_ADV, val);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ rtl_ethtool_get_eee(struct net_device *net, struct ethtool_eee *edata)
+ {
+ 	struct r8152 *tp = netdev_priv(net);
+ 	int ret;
+ 
+ 	ret = usb_autopm_get_interface(tp->intf);
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	mutex_lock(&tp->control);
+ 
+ 	ret = tp->rtl_ops.eee_get(tp, edata);
+ 
+ 	mutex_unlock(&tp->control);
+ 
+ 	usb_autopm_put_interface(tp->intf);
+ 
+ out:
+ 	return ret;
+ }
+ 
+ static int
+ rtl_ethtool_set_eee(struct net_device *net, struct ethtool_eee *edata)
+ {
+ 	struct r8152 *tp = netdev_priv(net);
+ 	int ret;
+ 
+ 	ret = usb_autopm_get_interface(tp->intf);
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	mutex_lock(&tp->control);
+ 
+ 	ret = tp->rtl_ops.eee_set(tp, edata);
+ 	if (!ret)
+ 		ret = mii_nway_restart(&tp->mii);
+ 
+ 	mutex_unlock(&tp->control);
+ 
++>>>>>>> f37119c57ba7 (r8152: rename tx_underun)
  	usb_autopm_put_interface(tp->intf);
  
  out:
* Unmerged path drivers/net/usb/r8152.c
