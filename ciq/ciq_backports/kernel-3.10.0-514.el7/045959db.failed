IB/cma: Add configfs for rdma_cm

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matan Barak <matanb@mellanox.com>
commit 045959db65c67d7189dc89ecddb5fa10aafa449d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/045959db.failed

Users would like to control the behaviour of rdma_cm.
For example, old applications which don't set the
required RoCE gid type could be executed on RoCE V2
network types. In order to support this configuration,
we implement a configfs for rdma_cm.

In order to use the configfs, one needs to mount it and
mkdir <IB device name> inside rdma_cm directory.

The patch adds support for a single configuration file,
default_roce_mode. The mode can either be "IB/RoCE v1" or
"RoCE v2".

	Signed-off-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 045959db65c67d7189dc89ecddb5fa10aafa449d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cache.c
#	drivers/infiniband/core/cma.c
#	drivers/infiniband/core/core_priv.h
diff --cc drivers/infiniband/core/cache.c
index 77177fb6d68f,92cadbddbe49..000000000000
--- a/drivers/infiniband/core/cache.c
+++ b/drivers/infiniband/core/cache.c
@@@ -125,6 -126,48 +125,51 @@@ static void dispatch_gid_change_event(s
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static const char * const gid_type_str[] = {
+ 	[IB_GID_TYPE_IB]	= "IB/RoCE v1",
+ 	[IB_GID_TYPE_ROCE_UDP_ENCAP]	= "RoCE v2",
+ };
+ 
+ const char *ib_cache_gid_type_str(enum ib_gid_type gid_type)
+ {
+ 	if (gid_type < ARRAY_SIZE(gid_type_str) && gid_type_str[gid_type])
+ 		return gid_type_str[gid_type];
+ 
+ 	return "Invalid GID type";
+ }
+ EXPORT_SYMBOL(ib_cache_gid_type_str);
+ 
+ int ib_cache_gid_parse_type_str(const char *buf)
+ {
+ 	unsigned int i;
+ 	size_t len;
+ 	int err = -EINVAL;
+ 
+ 	len = strlen(buf);
+ 	if (len == 0)
+ 		return -EINVAL;
+ 
+ 	if (buf[len - 1] == '\n')
+ 		len--;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(gid_type_str); ++i)
+ 		if (gid_type_str[i] && !strncmp(buf, gid_type_str[i], len) &&
+ 		    len == strlen(gid_type_str[i])) {
+ 			err = i;
+ 			break;
+ 		}
+ 
+ 	return err;
+ }
+ EXPORT_SYMBOL(ib_cache_gid_parse_type_str);
+ 
+ /* This function expects that rwlock will be write locked in all
+  * scenarios and that lock will be locked in sleep-able (RoCE)
+  * scenarios.
+  */
++>>>>>>> 045959db65c6 (IB/cma: Add configfs for rdma_cm)
  static int write_gid(struct ib_device *ib_dev, u8 port,
  		     struct ib_gid_table *table, int ix,
  		     const union ib_gid *gid,
diff --cc drivers/infiniband/core/cma.c
index 0523e8efcdf1,75987b0c570c..000000000000
--- a/drivers/infiniband/core/cma.c
+++ b/drivers/infiniband/core/cma.c
@@@ -448,10 -516,12 +515,16 @@@ static int cma_translate_addr(struct so
  }
  
  static inline int cma_validate_port(struct ib_device *device, u8 port,
++<<<<<<< HEAD
 +				      union ib_gid *gid, int dev_type)
++=======
+ 				    enum ib_gid_type gid_type,
+ 				      union ib_gid *gid, int dev_type,
+ 				      int bound_if_index)
++>>>>>>> 045959db65c6 (IB/cma: Add configfs for rdma_cm)
  {
 +	u8 found_port;
  	int ret = -ENODEV;
 -	struct net_device *ndev = NULL;
  
  	if ((dev_type == ARPHRD_INFINIBAND) && !rdma_protocol_ib(device, port))
  		return ret;
@@@ -459,9 -529,28 +532,34 @@@
  	if ((dev_type != ARPHRD_INFINIBAND) && rdma_protocol_ib(device, port))
  		return ret;
  
++<<<<<<< HEAD
 +	ret = ib_find_cached_gid(device, gid, &found_port, NULL);
 +	if (port != found_port)
 +		return -ENODEV;
++=======
+ 	if (dev_type == ARPHRD_ETHER) {
+ 		ndev = dev_get_by_index(&init_net, bound_if_index);
+ 		if (ndev && ndev->flags & IFF_LOOPBACK) {
+ 			pr_info("detected loopback device\n");
+ 			dev_put(ndev);
+ 
+ 			if (!device->get_netdev)
+ 				return -EOPNOTSUPP;
+ 
+ 			ndev = device->get_netdev(device, port);
+ 			if (!ndev)
+ 				return -ENODEV;
+ 		}
+ 	} else {
+ 		gid_type = IB_GID_TYPE_IB;
+ 	}
+ 
+ 	ret = ib_find_cached_gid_by_port(device, gid, gid_type, port,
+ 					 ndev, NULL);
+ 
+ 	if (ndev)
+ 		dev_put(ndev);
++>>>>>>> 045959db65c6 (IB/cma: Add configfs for rdma_cm)
  
  	return ret;
  }
@@@ -492,8 -581,12 +590,17 @@@ static int cma_acquire_dev(struct rdma_
  		gidp = rdma_protocol_roce(cma_dev->device, port) ?
  		       &iboe_gid : &gid;
  
++<<<<<<< HEAD
 +		ret = cma_validate_port(cma_dev->device, port, gidp,
 +					dev_addr->dev_type);
++=======
+ 		ret = cma_validate_port(cma_dev->device, port,
+ 					rdma_protocol_ib(cma_dev->device, port) ?
+ 					IB_GID_TYPE_IB :
+ 					listen_id_priv->gid_type, gidp,
+ 					dev_addr->dev_type,
+ 					dev_addr->bound_dev_if);
++>>>>>>> 045959db65c6 (IB/cma: Add configfs for rdma_cm)
  		if (!ret) {
  			id_priv->id.port_num = port;
  			goto out;
@@@ -510,8 -603,12 +617,17 @@@
  			gidp = rdma_protocol_roce(cma_dev->device, port) ?
  			       &iboe_gid : &gid;
  
++<<<<<<< HEAD
 +			ret = cma_validate_port(cma_dev->device, port, gidp,
 +						dev_addr->dev_type);
++=======
+ 			ret = cma_validate_port(cma_dev->device, port,
+ 						rdma_protocol_ib(cma_dev->device, port) ?
+ 						IB_GID_TYPE_IB :
+ 						cma_dev->default_gid_type[port - 1],
+ 						gidp, dev_addr->dev_type,
+ 						dev_addr->bound_dev_if);
++>>>>>>> 045959db65c6 (IB/cma: Add configfs for rdma_cm)
  			if (!ret) {
  				id_priv->id.port_num = port;
  				goto out;
diff --cc drivers/infiniband/core/core_priv.h
index 0d01fb95d944,eab32215756b..000000000000
--- a/drivers/infiniband/core/core_priv.h
+++ b/drivers/infiniband/core/core_priv.h
@@@ -79,8 -96,13 +101,15 @@@ enum ib_cache_gid_default_mode 
  	IB_CACHE_GID_DEFAULT_MODE_DELETE
  };
  
++<<<<<<< HEAD
++=======
+ int ib_cache_gid_parse_type_str(const char *buf);
+ 
+ const char *ib_cache_gid_type_str(enum ib_gid_type gid_type);
+ 
++>>>>>>> 045959db65c6 (IB/cma: Add configfs for rdma_cm)
  void ib_cache_gid_set_default_gid(struct ib_device *ib_dev, u8 port,
  				  struct net_device *ndev,
 -				  unsigned long gid_type_mask,
  				  enum ib_cache_gid_default_mode mode);
  
  int ib_cache_gid_add(struct ib_device *ib_dev, u8 port,
diff --git a/Documentation/ABI/testing/configfs-rdma_cm b/Documentation/ABI/testing/configfs-rdma_cm
new file mode 100644
index 000000000000..5c389aaf5291
--- /dev/null
+++ b/Documentation/ABI/testing/configfs-rdma_cm
@@ -0,0 +1,22 @@
+What: 		/config/rdma_cm
+Date: 		November 29, 2015
+KernelVersion:  4.4.0
+Description: 	Interface is used to configure RDMA-cable HCAs in respect to
+		RDMA-CM attributes.
+
+		Attributes are visible only when configfs is mounted. To mount
+		configfs in /config directory use:
+		# mount -t configfs none /config/
+
+		In order to set parameters related to a specific HCA, a directory
+		for this HCA has to be created:
+		mkdir -p /config/rdma_cm/<hca>
+
+
+What: 		/config/rdma_cm/<hca>/ports/<port-num>/default_roce_mode
+Date: 		November 29, 2015
+KernelVersion:  4.4.0
+Description: 	RDMA-CM based connections from HCA <hca> at port <port-num>
+		will be initiated with this RoCE type as default.
+		The possible RoCE types are either "IB/RoCE v1" or "RoCE v2".
+		This parameter has RW access.
diff --git a/drivers/infiniband/Kconfig b/drivers/infiniband/Kconfig
index a474cfbe0431..a94351a96d27 100644
--- a/drivers/infiniband/Kconfig
+++ b/drivers/infiniband/Kconfig
@@ -55,6 +55,15 @@ config INFINIBAND_ADDR_TRANS
 	depends on INFINIBAND
 	default y
 
+config INFINIBAND_ADDR_TRANS_CONFIGFS
+	bool
+	depends on INFINIBAND_ADDR_TRANS && CONFIGFS_FS && !(INFINIBAND=y && CONFIGFS_FS=m)
+	default y
+	---help---
+	  ConfigFS support for RDMA communication manager (CM).
+	  This allows the user to config the default GID type that the CM
+	  uses for each device, when initiaing new connections.
+
 source "drivers/infiniband/hw/mthca/Kconfig"
 source "drivers/infiniband/hw/ipath/Kconfig"
 source "drivers/infiniband/hw/qib/Kconfig"
diff --git a/drivers/infiniband/core/Makefile b/drivers/infiniband/core/Makefile
index ae48d874012f..f818538a7f4e 100644
--- a/drivers/infiniband/core/Makefile
+++ b/drivers/infiniband/core/Makefile
@@ -24,6 +24,8 @@ iw_cm-y :=			iwcm.o iwpm_util.o iwpm_msg.o
 
 rdma_cm-y :=			cma.o
 
+rdma_cm-$(CONFIG_INFINIBAND_ADDR_TRANS_CONFIGFS) += cma_configfs.o
+
 rdma_ucm-y :=			ucma.o
 
 ib_addr-y :=			addr.o
* Unmerged path drivers/infiniband/core/cache.c
* Unmerged path drivers/infiniband/core/cma.c
diff --git a/drivers/infiniband/core/cma_configfs.c b/drivers/infiniband/core/cma_configfs.c
new file mode 100644
index 000000000000..bd1d6402ebd5
--- /dev/null
+++ b/drivers/infiniband/core/cma_configfs.c
@@ -0,0 +1,322 @@
+/*
+ * Copyright (c) 2015, Mellanox Technologies inc.  All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include <linux/module.h>
+#include <linux/configfs.h>
+#include <rdma/ib_verbs.h>
+#include "core_priv.h"
+
+struct cma_device;
+
+struct cma_dev_group;
+
+struct cma_dev_port_group {
+	unsigned int		port_num;
+	struct cma_dev_group	*cma_dev_group;
+	struct config_group	group;
+};
+
+struct cma_dev_group {
+	char				name[IB_DEVICE_NAME_MAX];
+	struct config_group		device_group;
+	struct config_group		ports_group;
+	struct config_group		*default_dev_group[2];
+	struct config_group		**default_ports_group;
+	struct cma_dev_port_group	*ports;
+};
+
+static struct cma_dev_port_group *to_dev_port_group(struct config_item *item)
+{
+	struct config_group *group;
+
+	if (!item)
+		return NULL;
+
+	group = container_of(item, struct config_group, cg_item);
+	return container_of(group, struct cma_dev_port_group, group);
+}
+
+static bool filter_by_name(struct ib_device *ib_dev, void *cookie)
+{
+	return !strcmp(ib_dev->name, cookie);
+}
+
+static int cma_configfs_params_get(struct config_item *item,
+				   struct cma_device **pcma_dev,
+				   struct cma_dev_port_group **pgroup)
+{
+	struct cma_dev_port_group *group = to_dev_port_group(item);
+	struct cma_device *cma_dev;
+
+	if (!group)
+		return -ENODEV;
+
+	cma_dev = cma_enum_devices_by_ibdev(filter_by_name,
+					    group->cma_dev_group->name);
+	if (!cma_dev)
+		return -ENODEV;
+
+	*pcma_dev = cma_dev;
+	*pgroup = group;
+
+	return 0;
+}
+
+static void cma_configfs_params_put(struct cma_device *cma_dev)
+{
+	cma_deref_dev(cma_dev);
+}
+
+static ssize_t default_roce_mode_show(struct config_item *item,
+				      char *buf)
+{
+	struct cma_device *cma_dev;
+	struct cma_dev_port_group *group;
+	int gid_type;
+	ssize_t ret;
+
+	ret = cma_configfs_params_get(item, &cma_dev, &group);
+	if (ret)
+		return ret;
+
+	gid_type = cma_get_default_gid_type(cma_dev, group->port_num);
+	cma_configfs_params_put(cma_dev);
+
+	if (gid_type < 0)
+		return gid_type;
+
+	return sprintf(buf, "%s\n", ib_cache_gid_type_str(gid_type));
+}
+
+static ssize_t default_roce_mode_store(struct config_item *item,
+				       const char *buf, size_t count)
+{
+	struct cma_device *cma_dev;
+	struct cma_dev_port_group *group;
+	int gid_type = ib_cache_gid_parse_type_str(buf);
+	ssize_t ret;
+
+	if (gid_type < 0)
+		return -EINVAL;
+
+	ret = cma_configfs_params_get(item, &cma_dev, &group);
+	if (ret)
+		return ret;
+
+	ret = cma_set_default_gid_type(cma_dev, group->port_num, gid_type);
+
+	cma_configfs_params_put(cma_dev);
+
+	return !ret ? strnlen(buf, count) : ret;
+}
+
+CONFIGFS_ATTR(, default_roce_mode);
+
+static struct configfs_attribute *cma_configfs_attributes[] = {
+	&attr_default_roce_mode,
+	NULL,
+};
+
+static struct config_item_type cma_port_group_type = {
+	.ct_attrs	= cma_configfs_attributes,
+	.ct_owner	= THIS_MODULE
+};
+
+static int make_cma_ports(struct cma_dev_group *cma_dev_group,
+			  struct cma_device *cma_dev)
+{
+	struct ib_device *ibdev;
+	unsigned int i;
+	unsigned int ports_num;
+	struct cma_dev_port_group *ports;
+	int err;
+
+	ibdev = cma_get_ib_dev(cma_dev);
+
+	if (!ibdev)
+		return -ENODEV;
+
+	ports_num = ibdev->phys_port_cnt;
+	ports = kcalloc(ports_num, sizeof(*cma_dev_group->ports),
+			GFP_KERNEL);
+
+	cma_dev_group->default_ports_group = kcalloc(ports_num + 1,
+						     sizeof(*cma_dev_group->ports),
+						     GFP_KERNEL);
+
+	if (!ports || !cma_dev_group->default_ports_group) {
+		err = -ENOMEM;
+		goto free;
+	}
+
+	for (i = 0; i < ports_num; i++) {
+		char port_str[10];
+
+		ports[i].port_num = i + 1;
+		snprintf(port_str, sizeof(port_str), "%u", i + 1);
+		ports[i].cma_dev_group = cma_dev_group;
+		config_group_init_type_name(&ports[i].group,
+					    port_str,
+					    &cma_port_group_type);
+		cma_dev_group->default_ports_group[i] = &ports[i].group;
+	}
+	cma_dev_group->default_ports_group[i] = NULL;
+	cma_dev_group->ports = ports;
+
+	return 0;
+free:
+	kfree(ports);
+	kfree(cma_dev_group->default_ports_group);
+	cma_dev_group->ports = NULL;
+	cma_dev_group->default_ports_group = NULL;
+	return err;
+}
+
+static void release_cma_dev(struct config_item  *item)
+{
+	struct config_group *group = container_of(item, struct config_group,
+						  cg_item);
+	struct cma_dev_group *cma_dev_group = container_of(group,
+							   struct cma_dev_group,
+							   device_group);
+
+	kfree(cma_dev_group);
+};
+
+static void release_cma_ports_group(struct config_item  *item)
+{
+	struct config_group *group = container_of(item, struct config_group,
+						  cg_item);
+	struct cma_dev_group *cma_dev_group = container_of(group,
+							   struct cma_dev_group,
+							   ports_group);
+
+	kfree(cma_dev_group->ports);
+	kfree(cma_dev_group->default_ports_group);
+	cma_dev_group->ports = NULL;
+	cma_dev_group->default_ports_group = NULL;
+};
+
+static struct configfs_item_operations cma_ports_item_ops = {
+	.release = release_cma_ports_group
+};
+
+static struct config_item_type cma_ports_group_type = {
+	.ct_item_ops	= &cma_ports_item_ops,
+	.ct_owner	= THIS_MODULE
+};
+
+static struct configfs_item_operations cma_device_item_ops = {
+	.release = release_cma_dev
+};
+
+static struct config_item_type cma_device_group_type = {
+	.ct_item_ops	= &cma_device_item_ops,
+	.ct_owner	= THIS_MODULE
+};
+
+static struct config_group *make_cma_dev(struct config_group *group,
+					 const char *name)
+{
+	int err = -ENODEV;
+	struct cma_device *cma_dev = cma_enum_devices_by_ibdev(filter_by_name,
+							       (void *)name);
+	struct cma_dev_group *cma_dev_group = NULL;
+
+	if (!cma_dev)
+		goto fail;
+
+	cma_dev_group = kzalloc(sizeof(*cma_dev_group), GFP_KERNEL);
+
+	if (!cma_dev_group) {
+		err = -ENOMEM;
+		goto fail;
+	}
+
+	strncpy(cma_dev_group->name, name, sizeof(cma_dev_group->name));
+
+	err = make_cma_ports(cma_dev_group, cma_dev);
+	if (err)
+		goto fail;
+
+	cma_dev_group->ports_group.default_groups =
+		cma_dev_group->default_ports_group;
+	config_group_init_type_name(&cma_dev_group->ports_group, "ports",
+				    &cma_ports_group_type);
+
+	cma_dev_group->device_group.default_groups
+		= cma_dev_group->default_dev_group;
+	cma_dev_group->default_dev_group[0] = &cma_dev_group->ports_group;
+	cma_dev_group->default_dev_group[1] = NULL;
+
+	config_group_init_type_name(&cma_dev_group->device_group, name,
+				    &cma_device_group_type);
+
+	cma_deref_dev(cma_dev);
+	return &cma_dev_group->device_group;
+
+fail:
+	if (cma_dev)
+		cma_deref_dev(cma_dev);
+	kfree(cma_dev_group);
+	return ERR_PTR(err);
+}
+
+static struct configfs_group_operations cma_subsys_group_ops = {
+	.make_group	= make_cma_dev,
+};
+
+static struct config_item_type cma_subsys_type = {
+	.ct_group_ops	= &cma_subsys_group_ops,
+	.ct_owner	= THIS_MODULE,
+};
+
+static struct configfs_subsystem cma_subsys = {
+	.su_group	= {
+		.cg_item	= {
+			.ci_namebuf	= "rdma_cm",
+			.ci_type	= &cma_subsys_type,
+		},
+	},
+};
+
+int __init cma_configfs_init(void)
+{
+	config_group_init(&cma_subsys.su_group);
+	mutex_init(&cma_subsys.su_mutex);
+	return configfs_register_subsystem(&cma_subsys);
+}
+
+void __exit cma_configfs_exit(void)
+{
+	configfs_unregister_subsystem(&cma_subsys);
+}
* Unmerged path drivers/infiniband/core/core_priv.h
