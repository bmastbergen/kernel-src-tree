i40e/i40evf: Enable support for SKB_GSO_UDP_TUNNEL_CSUM

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Duyck <aduyck@mirantis.com>
commit 5453205cd0975b845f6f8837f0c2b7c8cb80fcf8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5453205c.failed

The XL722 has support for providing the outer UDP tunnel checksum on
transmits.  Make use of this feature to support segmenting UDP tunnels with
outer checksums enabled.

	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 5453205cd0975b845f6f8837f0c2b7c8cb80fcf8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_txrx.c
#	drivers/net/ethernet/intel/i40evf/i40e_txrx.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 5a3abb58e191,1955c849a452..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@@ -2434,52 -2457,39 +2446,76 @@@ static void i40e_tx_enable_csum(struct 
  			*tx_flags |= I40E_TX_FLAGS_UDP_TUNNEL;
  			break;
  		case IPPROTO_GRE:
 -			tunnel |= I40E_TXD_CTX_GRE_TUNNELING;
 -			*tx_flags |= I40E_TX_FLAGS_UDP_TUNNEL;
 +			l4_tunnel = I40E_TXD_CTX_GRE_TUNNELING;
  			break;
  		default:
 -			if (*tx_flags & I40E_TX_FLAGS_TSO)
 -				return -1;
 +			return;
 +		}
 +		network_hdr_len = skb_inner_network_header_len(skb);
 +		this_ip_hdr = inner_ip_hdr(skb);
 +		this_ipv6_hdr = inner_ipv6_hdr(skb);
 +		this_tcp_hdrlen = inner_tcp_hdrlen(skb);
  
 -			skb_checksum_help(skb);
 -			return 0;
 +		if (*tx_flags & I40E_TX_FLAGS_IPV4) {
 +			if (*tx_flags & I40E_TX_FLAGS_TSO) {
 +				*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV4;
 +			} else {
 +				*cd_tunneling |=
 +					 I40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;
 +			}
 +		} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
 +			*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV6;
  		}
  
++<<<<<<< HEAD
 +		/* Now set the ctx descriptor fields */
 +		*cd_tunneling |= (skb_network_header_len(skb) >> 2) <<
 +				   I40E_TXD_CTX_QW0_EXT_IPLEN_SHIFT      |
 +				   l4_tunnel                             |
 +				   ((skb_inner_network_offset(skb) -
 +					skb_transport_offset(skb)) >> 1) <<
 +				   I40E_TXD_CTX_QW0_NATLEN_SHIFT;
 +		if (this_ip_hdr->version == 6) {
 +			*tx_flags &= ~I40E_TX_FLAGS_IPV4;
++=======
+ 		/* compute tunnel header size */
+ 		tunnel |= ((ip.hdr - l4.hdr) / 2) <<
+ 			  I40E_TXD_CTX_QW0_NATLEN_SHIFT;
+ 
+ 		/* indicate if we need to offload outer UDP header */
+ 		if ((*tx_flags & I40E_TX_FLAGS_TSO) &&
+ 		    (skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL_CSUM))
+ 			tunnel |= I40E_TXD_CTX_QW0_L4T_CS_MASK;
+ 
+ 		/* record tunnel offload values */
+ 		*cd_tunneling |= tunnel;
+ 
+ 		/* switch L4 header pointer from outer to inner */
+ 		l4.hdr = skb_inner_transport_header(skb);
+ 		l4_proto = 0;
+ 
+ 		/* reset type as we transition from outer to inner headers */
+ 		*tx_flags &= ~(I40E_TX_FLAGS_IPV4 | I40E_TX_FLAGS_IPV6);
+ 		if (ip.v4->version == 4)
+ 			*tx_flags |= I40E_TX_FLAGS_IPV4;
+ 		if (ip.v6->version == 6)
++>>>>>>> 5453205cd097 (i40e/i40evf: Enable support for SKB_GSO_UDP_TUNNEL_CSUM)
  			*tx_flags |= I40E_TX_FLAGS_IPV6;
 +		}
 +		if ((tx_ring->flags & I40E_TXR_FLAGS_OUTER_UDP_CSUM) &&
 +		    (l4_tunnel == I40E_TXD_CTX_UDP_TUNNELING)        &&
 +		    (*cd_tunneling & I40E_TXD_CTX_QW0_EXT_IP_MASK)) {
 +			oudph->check = ~csum_tcpudp_magic(oiph->saddr,
 +					oiph->daddr,
 +					(skb->len - skb_transport_offset(skb)),
 +					IPPROTO_UDP, 0);
 +			*cd_tunneling |= I40E_TXD_CTX_QW0_L4T_CS_MASK;
 +		}
 +	} else {
 +		network_hdr_len = skb_network_header_len(skb);
 +		this_ip_hdr = ip_hdr(skb);
 +		this_ipv6_hdr = ipv6_hdr(skb);
 +		this_tcp_hdrlen = tcp_hdrlen(skb);
  	}
  
  	/* Enable IP checksum offloads */
diff --cc drivers/net/ethernet/intel/i40evf/i40e_txrx.c
index f6384b0c8220,6d66fcdc6122..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
@@@ -1642,51 -1679,35 +1654,75 @@@ static void i40e_tx_enable_csum(struct 
  			*tx_flags |= I40E_TX_FLAGS_VXLAN_TUNNEL;
  			break;
  		default:
 -			if (*tx_flags & I40E_TX_FLAGS_TSO)
 -				return -1;
 +			return;
 +		}
 +		network_hdr_len = skb_inner_network_header_len(skb);
 +		this_ip_hdr = inner_ip_hdr(skb);
 +		this_ipv6_hdr = inner_ipv6_hdr(skb);
 +		this_tcp_hdrlen = inner_tcp_hdrlen(skb);
  
 -			skb_checksum_help(skb);
 -			return 0;
 +		if (*tx_flags & I40E_TX_FLAGS_IPV4) {
 +			if (*tx_flags & I40E_TX_FLAGS_TSO) {
 +				*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV4;
 +			} else {
 +				*cd_tunneling |=
 +					 I40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;
 +			}
 +		} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
 +			*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV6;
  		}
  
++<<<<<<< HEAD
 +		/* Now set the ctx descriptor fields */
 +		*cd_tunneling |= (skb_network_header_len(skb) >> 2) <<
 +				   I40E_TXD_CTX_QW0_EXT_IPLEN_SHIFT      |
 +				   l4_tunnel                             |
 +				   ((skb_inner_network_offset(skb) -
 +					skb_transport_offset(skb)) >> 1) <<
 +				   I40E_TXD_CTX_QW0_NATLEN_SHIFT;
 +		if (this_ip_hdr->version == 6) {
 +			*tx_flags &= ~I40E_TX_FLAGS_IPV4;
++=======
+ 		/* compute tunnel header size */
+ 		tunnel |= ((ip.hdr - l4.hdr) / 2) <<
+ 			  I40E_TXD_CTX_QW0_NATLEN_SHIFT;
+ 
+ 		/* indicate if we need to offload outer UDP header */
+ 		if ((*tx_flags & I40E_TX_FLAGS_TSO) &&
+ 		    (skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL_CSUM))
+ 			tunnel |= I40E_TXD_CTX_QW0_L4T_CS_MASK;
+ 
+ 		/* record tunnel offload values */
+ 		*cd_tunneling |= tunnel;
+ 
+ 		/* switch L4 header pointer from outer to inner */
+ 		l4.hdr = skb_inner_transport_header(skb);
+ 		l4_proto = 0;
+ 
+ 		/* reset type as we transition from outer to inner headers */
+ 		*tx_flags &= ~(I40E_TX_FLAGS_IPV4 | I40E_TX_FLAGS_IPV6);
+ 		if (ip.v4->version == 4)
+ 			*tx_flags |= I40E_TX_FLAGS_IPV4;
+ 		if (ip.v6->version == 6)
++>>>>>>> 5453205cd097 (i40e/i40evf: Enable support for SKB_GSO_UDP_TUNNEL_CSUM)
  			*tx_flags |= I40E_TX_FLAGS_IPV6;
 +		}
 +
 +
 +		if ((tx_ring->flags & I40E_TXR_FLAGS_OUTER_UDP_CSUM) &&
 +		    (l4_tunnel == I40E_TXD_CTX_UDP_TUNNELING)        &&
 +		    (*cd_tunneling & I40E_TXD_CTX_QW0_EXT_IP_MASK)) {
 +			oudph->check = ~csum_tcpudp_magic(oiph->saddr,
 +					oiph->daddr,
 +					(skb->len - skb_transport_offset(skb)),
 +					IPPROTO_UDP, 0);
 +			*cd_tunneling |= I40E_TXD_CTX_QW0_L4T_CS_MASK;
 +		}
 +	} else {
 +		network_hdr_len = skb_network_header_len(skb);
 +		this_ip_hdr = ip_hdr(skb);
 +		this_ipv6_hdr = ipv6_hdr(skb);
 +		this_tcp_hdrlen = tcp_hdrlen(skb);
  	}
  
  	/* Enable IP checksum offloads */
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_txrx.c
