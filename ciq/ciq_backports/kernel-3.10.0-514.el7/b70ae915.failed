SUNRPC: Handle connection reset more efficiently.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [fs] sunrpc: Handle connection reset more efficiently (Steve Dickson) [1270038]
Rebuild_FUZZ: 98.97%
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit b70ae915e4282854fb7864519e5ec559ab2de7c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b70ae915.failed

If the connection reset is due to an active call on our side, then
the state change is sometimes not reported. Catch those instances
using xs_error_report() instead.
Also remove the xs_tcp_shutdown() call in xs_tcp_send_request() as
the change in behaviour makes it redundant.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit b70ae915e4282854fb7864519e5ec559ab2de7c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtsock.c
diff --cc net/sunrpc/xprtsock.c
index b0582fdf9149,540d542d85e5..000000000000
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@@ -1467,54 -1429,7 +1484,57 @@@ out
  	read_unlock_bh(&sk->sk_callback_lock);
  }
  
++<<<<<<< HEAD
 +/*
 + * Do the equivalent of linger/linger2 handling for dealing with
 + * broken servers that don't close the socket in a timely
 + * fashion
 + */
 +static void xs_tcp_schedule_linger_timeout(struct rpc_xprt *xprt,
 +		unsigned long timeout)
 +{
 +	struct sock_xprt *transport;
 +
 +	if (xprt_test_and_set_connecting(xprt))
 +		return;
 +	set_bit(XPRT_CONNECTION_ABORT, &xprt->state);
 +	transport = container_of(xprt, struct sock_xprt, xprt);
 +	queue_delayed_work(rpciod_workqueue, &transport->connect_worker,
 +			   timeout);
 +}
 +
 +static void xs_tcp_cancel_linger_timeout(struct rpc_xprt *xprt)
 +{
 +	struct sock_xprt *transport;
 +
 +	transport = container_of(xprt, struct sock_xprt, xprt);
 +
 +	if (!test_bit(XPRT_CONNECTION_ABORT, &xprt->state) ||
 +	    !cancel_delayed_work(&transport->connect_worker))
 +		return;
 +	clear_bit(XPRT_CONNECTION_ABORT, &xprt->state);
 +	xprt_clear_connecting(xprt);
 +}
 +
 +static void xs_sock_reset_connection_flags(struct rpc_xprt *xprt)
 +{
 +	smp_mb__before_clear_bit();
 +	clear_bit(XPRT_CONNECTION_ABORT, &xprt->state);
 +	clear_bit(XPRT_CONNECTION_CLOSE, &xprt->state);
 +	clear_bit(XPRT_CLOSE_WAIT, &xprt->state);
 +	clear_bit(XPRT_CLOSING, &xprt->state);
 +	smp_mb__after_clear_bit();
 +}
 +
 +static void xs_sock_mark_closed(struct rpc_xprt *xprt)
 +{
 +	xs_sock_reset_connection_flags(xprt);
 +	/* Mark transport as closed and wake up all pending tasks */
 +	xprt_disconnect_done(xprt);
 +}
 +
++=======
++>>>>>>> b70ae915e428 (SUNRPC: Handle connection reset more efficiently.)
  /**
   * xs_tcp_state_change - callback to handle TCP socket state changes
   * @sk: socket whose state has changed
* Unmerged path net/sunrpc/xprtsock.c
