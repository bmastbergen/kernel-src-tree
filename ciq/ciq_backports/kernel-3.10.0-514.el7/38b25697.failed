ovl: handle umask and posix_acl_default correctly on creation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 38b256973ea90fc7c2b7e1b734fa0e8b83538d50
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/38b25697.failed

Setting MS_POSIXACL in sb->s_flags has the side effect of passing mode to
create functions without masking against umask.

Another problem when creating over a whiteout is that the default posix acl
is not inherited from the parent dir (because the real parent dir at the
time of creation is the work directory).

Fix these problems by:

 a) If upper fs does not have MS_POSIXACL, then mask mode with umask.

 b) If creating over a whiteout, call posix_acl_create() to get the
 inherited acls.  After creation (but before moving to the final
 destination) set these acls on the created file.  posix_acl_create() also
 updates the file creation mode as appropriate.

Fixes: 39a25b2b3762 ("ovl: define ->get_acl() for overlay inodes")
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 38b256973ea90fc7c2b7e1b734fa0e8b83538d50)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/dir.c
diff --cc fs/overlayfs/dir.c
index 02a117bdec65,f485dd4288e4..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -177,7 -188,10 +179,14 @@@ static int ovl_create_upper(struct dent
  	struct dentry *newdentry;
  	int err;
  
++<<<<<<< HEAD
 +	mutex_lock_nested(&udir->i_mutex, I_MUTEX_PARENT);
++=======
+ 	if (!hardlink && !IS_POSIXACL(udir))
+ 		stat->mode &= ~current_umask();
+ 
+ 	inode_lock_nested(udir, I_MUTEX_PARENT);
++>>>>>>> 38b256973ea9 (ovl: handle umask and posix_acl_default correctly on creation)
  	newdentry = lookup_one_len(dentry->d_name.name, upperdir,
  				   dentry->d_name.len);
  	err = PTR_ERR(newdentry);
@@@ -354,7 -408,34 +397,38 @@@ static int ovl_create_over_whiteout(str
  	if (err)
  		goto out_dput2;
  
++<<<<<<< HEAD
 +	if (S_ISDIR(stat->mode)) {
++=======
+ 	/*
+ 	 * mode could have been mutilated due to umask (e.g. sgid directory)
+ 	 */
+ 	if (!hardlink &&
+ 	    !S_ISLNK(stat->mode) && newdentry->d_inode->i_mode != stat->mode) {
+ 		struct iattr attr = {
+ 			.ia_valid = ATTR_MODE,
+ 			.ia_mode = stat->mode,
+ 		};
+ 		inode_lock(newdentry->d_inode);
+ 		err = notify_change(newdentry, &attr, NULL);
+ 		inode_unlock(newdentry->d_inode);
+ 		if (err)
+ 			goto out_cleanup;
+ 	}
+ 	if (!hardlink) {
+ 		err = ovl_set_upper_acl(newdentry, XATTR_NAME_POSIX_ACL_ACCESS,
+ 					acl);
+ 		if (err)
+ 			goto out_cleanup;
+ 
+ 		err = ovl_set_upper_acl(newdentry, XATTR_NAME_POSIX_ACL_DEFAULT,
+ 					default_acl);
+ 		if (err)
+ 			goto out_cleanup;
+ 	}
+ 
+ 	if (!hardlink && S_ISDIR(stat->mode)) {
++>>>>>>> 38b256973ea9 (ovl: handle umask and posix_acl_default correctly on creation)
  		err = ovl_set_opaque(newdentry);
  		if (err)
  			goto out_cleanup;
* Unmerged path fs/overlayfs/dir.c
