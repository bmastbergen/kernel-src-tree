mei: don't schedule suspend in pm idle

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit d5d83f8abea13d0b50ee762276c6c900d1946264
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d5d83f8a.failed

Calling pm_schedule_suspend from the runtime pm idle callback
may reschedule existing timer, thus in case of frequent runtime
rpm idle call the suspend maybe starved.
Instead we call pm_runtime_autosuspend which is checking if the
timer is already charged.

An example is monitoring device pci config space.
Pci config sysfs handlers calls pci_config_pm_runtime_put/get
helpers which in turns calls to device idle callback

	Cc: stable@vger.kernel.org # 3.15+
	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit d5d83f8abea13d0b50ee762276c6c900d1946264)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/pci-me.c
diff --cc drivers/misc/mei/pci-me.c
index 1eebd0f6a9f0,a0e9422b55a2..000000000000
--- a/drivers/misc/mei/pci-me.c
+++ b/drivers/misc/mei/pci-me.c
@@@ -346,8 -355,116 +346,120 @@@ static int mei_me_pci_resume(struct dev
  
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ #endif /* CONFIG_PM_SLEEP */
+ 
+ #ifdef CONFIG_PM_RUNTIME
+ static int mei_me_pm_runtime_idle(struct device *device)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(device);
+ 	struct mei_device *dev;
+ 
+ 	dev_dbg(&pdev->dev, "rpm: me: runtime_idle\n");
+ 
+ 	dev = pci_get_drvdata(pdev);
+ 	if (!dev)
+ 		return -ENODEV;
+ 	if (mei_write_is_idle(dev))
+ 		pm_runtime_autosuspend(device);
+ 
+ 	return -EBUSY;
+ }
+ 
+ static int mei_me_pm_runtime_suspend(struct device *device)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(device);
+ 	struct mei_device *dev;
+ 	int ret;
+ 
+ 	dev_dbg(&pdev->dev, "rpm: me: runtime suspend\n");
+ 
+ 	dev = pci_get_drvdata(pdev);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (mei_write_is_idle(dev))
+ 		ret = mei_me_pg_set_sync(dev);
+ 	else
+ 		ret = -EAGAIN;
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 
+ 	dev_dbg(&pdev->dev, "rpm: me: runtime suspend ret=%d\n", ret);
+ 
+ 	return ret;
+ }
+ 
+ static int mei_me_pm_runtime_resume(struct device *device)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(device);
+ 	struct mei_device *dev;
+ 	int ret;
+ 
+ 	dev_dbg(&pdev->dev, "rpm: me: runtime resume\n");
+ 
+ 	dev = pci_get_drvdata(pdev);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	ret = mei_me_pg_unset_sync(dev);
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 
+ 	dev_dbg(&pdev->dev, "rpm: me: runtime resume ret = %d\n", ret);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * mei_me_set_pm_domain - fill and set pm domian stucture for device
+  *
+  * @dev: mei_device
+  */
+ static inline void mei_me_set_pm_domain(struct mei_device *dev)
+ {
+ 	struct pci_dev *pdev  = dev->pdev;
+ 
+ 	if (pdev->dev.bus && pdev->dev.bus->pm) {
+ 		dev->pg_domain.ops = *pdev->dev.bus->pm;
+ 
+ 		dev->pg_domain.ops.runtime_suspend = mei_me_pm_runtime_suspend;
+ 		dev->pg_domain.ops.runtime_resume = mei_me_pm_runtime_resume;
+ 		dev->pg_domain.ops.runtime_idle = mei_me_pm_runtime_idle;
+ 
+ 		pdev->dev.pm_domain = &dev->pg_domain;
+ 	}
+ }
+ 
+ /**
+  * mei_me_unset_pm_domain - clean pm domian stucture for device
+  *
+  * @dev: mei_device
+  */
+ static inline void mei_me_unset_pm_domain(struct mei_device *dev)
+ {
+ 	/* stop using pm callbacks if any */
+ 	dev->pdev->dev.pm_domain = NULL;
+ }
+ #endif /* CONFIG_PM_RUNTIME */
+ 
+ #ifdef CONFIG_PM
+ static const struct dev_pm_ops mei_me_pm_ops = {
+ 	SET_SYSTEM_SLEEP_PM_OPS(mei_me_pci_suspend,
+ 				mei_me_pci_resume)
+ 	SET_RUNTIME_PM_OPS(
+ 		mei_me_pm_runtime_suspend,
+ 		mei_me_pm_runtime_resume,
+ 		mei_me_pm_runtime_idle)
+ };
++>>>>>>> d5d83f8abea1 (mei: don't schedule suspend in pm idle)
  
 +static SIMPLE_DEV_PM_OPS(mei_me_pm_ops, mei_me_pci_suspend, mei_me_pci_resume);
  #define MEI_ME_PM_OPS	(&mei_me_pm_ops)
  #else
  #define MEI_ME_PM_OPS	NULL
* Unmerged path drivers/misc/mei/pci-me.c
diff --git a/drivers/misc/mei/pci-txe.c b/drivers/misc/mei/pci-txe.c
index 2343c6236df9..32fef4d5b0b6 100644
--- a/drivers/misc/mei/pci-txe.c
+++ b/drivers/misc/mei/pci-txe.c
@@ -306,7 +306,7 @@ static int mei_txe_pm_runtime_idle(struct device *device)
 	if (!dev)
 		return -ENODEV;
 	if (mei_write_is_idle(dev))
-		pm_schedule_suspend(device, MEI_TXI_RPM_TIMEOUT * 2);
+		pm_runtime_autosuspend(device);
 
 	return -EBUSY;
 }
