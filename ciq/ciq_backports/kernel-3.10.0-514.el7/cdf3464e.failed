ipv6: Fix dst_entry refcnt bugs in ip6_tunnel

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit cdf3464e6c6bd764277cbbe992cd12da735b92fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/cdf3464e.failed

Problems in the current dst_entry cache in the ip6_tunnel:

1. ip6_tnl_dst_set is racy.  There is no lock to protect it:
   - One major problem is that the dst refcnt gets messed up. F.e.
     the same dst_cache can be released multiple times and then
     triggering the infamous dst refcnt < 0 warning message.
   - Another issue is the inconsistency between dst_cache and
     dst_cookie.

   It can be reproduced by adding and removing the ip6gre tunnel
   while running a super_netperf TCP_CRR test.

2. ip6_tnl_dst_get does not take the dst refcnt before returning
   the dst.

This patch:
1. Create a percpu dst_entry cache in ip6_tnl
2. Use a spinlock to protect the dst_cache operations
3. ip6_tnl_dst_get always takes the dst refcnt before returning

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cdf3464e6c6bd764277cbbe992cd12da735b92fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_tunnel.c
diff --cc net/ipv6/ip6_tunnel.c
index da3fa47becb4,851cf6d1eb45..000000000000
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@@ -128,17 -126,45 +128,53 @@@ static struct net_device_stats *ip6_get
   * Locking : hash tables are protected by RCU and RTNL
   */
  
+ static void __ip6_tnl_per_cpu_dst_set(struct ip6_tnl_dst *idst,
+ 				      struct dst_entry *dst)
+ {
+ 	dst_release(idst->dst);
+ 	if (dst) {
+ 		dst_hold(dst);
+ 		idst->cookie = rt6_get_cookie((struct rt6_info *)dst);
+ 	} else {
+ 		idst->cookie = 0;
+ 	}
+ 	idst->dst = dst;
+ }
+ 
+ static void ip6_tnl_per_cpu_dst_set(struct ip6_tnl_dst *idst,
+ 				    struct dst_entry *dst)
+ {
+ 
+ 	spin_lock_bh(&idst->lock);
+ 	__ip6_tnl_per_cpu_dst_set(idst, dst);
+ 	spin_unlock_bh(&idst->lock);
+ }
+ 
  struct dst_entry *ip6_tnl_dst_get(struct ip6_tnl *t)
  {
- 	struct dst_entry *dst = t->dst_cache;
+ 	struct ip6_tnl_dst *idst;
+ 	struct dst_entry *dst;
  
++<<<<<<< HEAD
 +	if (dst && dst->obsolete &&
 +	    dst->ops->check(dst, t->dst_cookie) == NULL) {
 +		t->dst_cache = NULL;
 +		dst_release(dst);
 +		return NULL;
++=======
+ 	idst = raw_cpu_ptr(t->dst_cache);
+ 	spin_lock_bh(&idst->lock);
+ 	dst = idst->dst;
+ 	if (dst) {
+ 		if (!dst->obsolete || dst->ops->check(dst, idst->cookie)) {
+ 			dst_hold(idst->dst);
+ 		} else {
+ 			__ip6_tnl_per_cpu_dst_set(idst, NULL);
+ 			dst = NULL;
+ 		}
++>>>>>>> cdf3464e6c6b (ipv6: Fix dst_entry refcnt bugs in ip6_tunnel)
  	}
- 
+ 	spin_unlock_bh(&idst->lock);
  	return dst;
  }
  EXPORT_SYMBOL_GPL(ip6_tnl_dst_get);
@@@ -152,10 -180,8 +190,15 @@@ EXPORT_SYMBOL_GPL(ip6_tnl_dst_reset)
  
  void ip6_tnl_dst_set(struct ip6_tnl *t, struct dst_entry *dst)
  {
++<<<<<<< HEAD
 +	struct rt6_info *rt = (struct rt6_info *) dst;
 +	t->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;
 +	dst_release(t->dst_cache);
 +	t->dst_cache = dst;
++=======
+ 	ip6_tnl_per_cpu_dst_set(raw_cpu_ptr(t->dst_cache), dst);
+ 
++>>>>>>> cdf3464e6c6b (ipv6: Fix dst_entry refcnt bugs in ip6_tunnel)
  }
  EXPORT_SYMBOL_GPL(ip6_tnl_dst_set);
  
diff --git a/include/net/ip6_tunnel.h b/include/net/ip6_tunnel.h
index ae57d0975630..0dd5b527d624 100644
--- a/include/net/ip6_tunnel.h
+++ b/include/net/ip6_tunnel.h
@@ -32,6 +32,12 @@ struct __ip6_tnl_parm {
 	__be32			o_key;
 };
 
+struct ip6_tnl_dst {
+	spinlock_t lock;
+	struct dst_entry *dst;
+	u32 cookie;
+};
+
 /* IPv6 tunnel */
 struct ip6_tnl {
 	struct ip6_tnl __rcu *next;	/* next tunnel in list */
@@ -39,8 +45,7 @@ struct ip6_tnl {
 	struct net *net;	/* netns for packet i/o */
 	struct __ip6_tnl_parm parms;	/* tunnel configuration parameters */
 	struct flowi fl;	/* flowi template for xmit */
-	struct dst_entry *dst_cache;    /* cached dst */
-	u32 dst_cookie;
+	struct ip6_tnl_dst __percpu *dst_cache;	/* cached dst */
 
 	int err_count;
 	unsigned long err_time;
@@ -61,6 +66,8 @@ struct ipv6_tlv_tnl_enc_lim {
 } __packed;
 
 struct dst_entry *ip6_tnl_dst_get(struct ip6_tnl *t);
+int ip6_tnl_dst_init(struct ip6_tnl *t);
+void ip6_tnl_dst_destroy(struct ip6_tnl *t);
 void ip6_tnl_dst_reset(struct ip6_tnl *t);
 void ip6_tnl_dst_set(struct ip6_tnl *t, struct dst_entry *dst);
 int ip6_tnl_rcv_ctl(struct ip6_tnl *t, const struct in6_addr *laddr,
diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c
index 9376a33fe2bb..603832837ef9 100644
--- a/net/ipv6/ip6_gre.c
+++ b/net/ipv6/ip6_gre.c
@@ -638,17 +638,17 @@ static netdev_tx_t ip6gre_xmit2(struct sk_buff *skb,
 		dst = ip6_tnl_dst_get(tunnel);
 
 	if (!dst) {
-		ndst = ip6_route_output(net, NULL, fl6);
+		dst = ip6_route_output(net, NULL, fl6);
 
-		if (ndst->error)
+		if (dst->error)
 			goto tx_err_link_failure;
-		ndst = xfrm_lookup(net, ndst, flowi6_to_flowi(fl6), NULL, 0);
-		if (IS_ERR(ndst)) {
-			err = PTR_ERR(ndst);
-			ndst = NULL;
+		dst = xfrm_lookup(net, dst, flowi6_to_flowi(fl6), NULL, 0);
+		if (IS_ERR(dst)) {
+			err = PTR_ERR(dst);
+			dst = NULL;
 			goto tx_err_link_failure;
 		}
-		dst = ndst;
+		ndst = dst;
 	}
 
 	tdev = dst->dev;
@@ -703,12 +703,9 @@ static netdev_tx_t ip6gre_xmit2(struct sk_buff *skb,
 		skb = new_skb;
 	}
 
-	if (fl6->flowi6_mark) {
-		skb_dst_set(skb, dst);
-		ndst = NULL;
-	} else {
-		skb_dst_set_noref(skb, dst);
-	}
+	if (!fl6->flowi6_mark && ndst)
+		ip6_tnl_dst_set(tunnel, ndst);
+	skb_dst_set(skb, dst);
 
 	proto = NEXTHDR_GRE;
 	if (encap_limit >= 0) {
@@ -762,14 +759,12 @@ static netdev_tx_t ip6gre_xmit2(struct sk_buff *skb,
 	skb_set_inner_protocol(skb, protocol);
 
 	ip6tunnel_xmit(NULL, skb, dev);
-	if (ndst)
-		ip6_tnl_dst_set(tunnel, ndst);
 	return 0;
 tx_err_link_failure:
 	stats->tx_carrier_errors++;
 	dst_link_failure(skb);
 tx_err_dst_release:
-	dst_release(ndst);
+	dst_release(dst);
 	return err;
 }
 
@@ -1221,6 +1216,9 @@ static const struct net_device_ops ip6gre_netdev_ops = {
 
 static void ip6gre_dev_free(struct net_device *dev)
 {
+	struct ip6_tnl *t = netdev_priv(dev);
+
+	ip6_tnl_dst_destroy(t);
 	free_percpu(dev->tstats);
 	free_netdev(dev);
 }
@@ -1246,6 +1244,7 @@ static void ip6gre_tunnel_setup(struct net_device *dev)
 static int ip6gre_tunnel_init_common(struct net_device *dev)
 {
 	struct ip6_tnl *tunnel;
+	int ret;
 
 	tunnel = netdev_priv(dev);
 
@@ -1257,6 +1256,13 @@ static int ip6gre_tunnel_init_common(struct net_device *dev)
 	if (!dev->tstats)
 		return -ENOMEM;
 
+	ret = ip6_tnl_dst_init(tunnel);
+	if (ret) {
+		free_percpu(dev->tstats);
+		dev->tstats = NULL;
+		return ret;
+	}
+
 	return 0;
 }
 
* Unmerged path net/ipv6/ip6_tunnel.c
