mm: ZONE_DEVICE depends on SPARSEMEM_VMEMMAP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mm] ZONE_DEVICE depends on SPARSEMEM_VMEMMAP (Jeff Moyer) [1271957 1278621 1343736 1349587 1349702 1353614 1355792]
Rebuild_FUZZ: 95.24%
commit-author Dan Williams <dan.j.williams@intel.com>
commit 99490f16f8b287a028306e4092cc85393907075f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/99490f16.failed

The primary use case for devm_memremap_pages() is to allocate an memmap
array from persistent memory.  That capabilty requires vmem_altmap which
requires SPARSEMEM_VMEMMAP.

Also, without SPARSEMEM_VMEMMAP the addition of ZONE_DEVICE expands
ZONES_WIDTH and triggers the:

"Unfortunate NUMA and NUMA Balancing config, growing page-frame for
last_cpupid."

...warning in mm/memory.c.  SPARSEMEM_VMEMMAP=n && ZONE_DEVICE=y is not
a configuration we should worry about supporting.

	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Reported-by: Vlastimil Babka <vbabka@suse.cz>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 99490f16f8b287a028306e4092cc85393907075f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/Kconfig
diff --cc mm/Kconfig
index 88ac087b6ee9,05efa6a5199e..000000000000
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@@ -572,3 -589,81 +572,84 @@@ config PGTABLE_MAPPIN
  
  	  You can check speed with zsmalloc benchmark:
  	  https://github.com/spartacus06/zsmapbench
++<<<<<<< HEAD
++=======
+ 
+ config ZSMALLOC_STAT
+ 	bool "Export zsmalloc statistics"
+ 	depends on ZSMALLOC
+ 	select DEBUG_FS
+ 	help
+ 	  This option enables code in the zsmalloc to collect various
+ 	  statistics about whats happening in zsmalloc and exports that
+ 	  information to userspace via debugfs.
+ 	  If unsure, say N.
+ 
+ config GENERIC_EARLY_IOREMAP
+ 	bool
+ 
+ config MAX_STACK_SIZE_MB
+ 	int "Maximum user stack size for 32-bit processes (MB)"
+ 	default 80
+ 	range 8 256 if METAG
+ 	range 8 2048
+ 	depends on STACK_GROWSUP && (!64BIT || COMPAT)
+ 	help
+ 	  This is the maximum stack size in Megabytes in the VM layout of 32-bit
+ 	  user processes when the stack grows upwards (currently only on parisc
+ 	  and metag arch). The stack will be located at the highest memory
+ 	  address minus the given value, unless the RLIMIT_STACK hard limit is
+ 	  changed to a smaller value in which case that is used.
+ 
+ 	  A sane initial value is 80 MB.
+ 
+ # For architectures that support deferred memory initialisation
+ config ARCH_SUPPORTS_DEFERRED_STRUCT_PAGE_INIT
+ 	bool
+ 
+ config DEFERRED_STRUCT_PAGE_INIT
+ 	bool "Defer initialisation of struct pages to kthreads"
+ 	default n
+ 	depends on ARCH_SUPPORTS_DEFERRED_STRUCT_PAGE_INIT
+ 	depends on MEMORY_HOTPLUG
+ 	help
+ 	  Ordinarily all struct pages are initialised during early boot in a
+ 	  single thread. On very large machines this can take a considerable
+ 	  amount of time. If this option is set, large machines will bring up
+ 	  a subset of memmap at boot and then initialise the rest in parallel
+ 	  by starting one-off "pgdatinitX" kernel thread for each node X. This
+ 	  has a potential performance impact on processes running early in the
+ 	  lifetime of the system until these kthreads finish the
+ 	  initialisation.
+ 
+ config IDLE_PAGE_TRACKING
+ 	bool "Enable idle page tracking"
+ 	depends on SYSFS && MMU
+ 	select PAGE_EXTENSION if !64BIT
+ 	help
+ 	  This feature allows to estimate the amount of user pages that have
+ 	  not been touched during a given period of time. This information can
+ 	  be useful to tune memory cgroup limits and/or for job placement
+ 	  within a compute cluster.
+ 
+ 	  See Documentation/vm/idle_page_tracking.txt for more details.
+ 
+ config ZONE_DEVICE
+ 	bool "Device memory (pmem, etc...) hotplug support" if EXPERT
+ 	depends on MEMORY_HOTPLUG
+ 	depends on MEMORY_HOTREMOVE
+ 	depends on SPARSEMEM_VMEMMAP
+ 	depends on X86_64 #arch_add_memory() comprehends device memory
+ 
+ 	help
+ 	  Device memory hotplug support allows for establishing pmem,
+ 	  or other device driver discovered memory regions, in the
+ 	  memmap. This allows pfn_to_page() lookups of otherwise
+ 	  "device-physical" addresses which is needed for using a DAX
+ 	  mapping in an O_DIRECT operation, among other things.
+ 
+ 	  If FS_DAX is enabled, then say Y.
+ 
+ config FRAME_VECTOR
+ 	bool
++>>>>>>> 99490f16f8b2 (mm: ZONE_DEVICE depends on SPARSEMEM_VMEMMAP)
* Unmerged path mm/Kconfig
