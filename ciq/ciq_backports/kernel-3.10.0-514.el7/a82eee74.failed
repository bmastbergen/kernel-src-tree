x86/uaccess/64: Handle the caching of 4-byte nocache copies properly in __copy_user_nocache()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] uaccess/64: Handle the caching of 4-byte nocache copies properly in __copy_user_nocache() (Jeff Moyer) [1346083 1346084 1346445 1346449 1346472 1347091 1359806]
Rebuild_FUZZ: 97.80%
commit-author Toshi Kani <toshi.kani@hpe.com>
commit a82eee7424525e34e98d821dd059ce14560a1e35
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a82eee74.failed

Data corruption issues were observed in tests which initiated
a system crash/reset while accessing BTT devices.  This problem
is reproducible.

The BTT driver calls pmem_rw_bytes() to update data in pmem
devices.  This interface calls __copy_user_nocache(), which
uses non-temporal stores so that the stores to pmem are
persistent.

__copy_user_nocache() uses non-temporal stores when a request
size is 8 bytes or larger (and is aligned by 8 bytes).  The
BTT driver updates the BTT map table, which entry size is
4 bytes.  Therefore, updates to the map table entries remain
cached, and are not written to pmem after a crash.

Change __copy_user_nocache() to use non-temporal store when
a request size is 4 bytes.  The change extends the current
byte-copy path for a less-than-8-bytes request, and does not
add any overhead to the regular path.

Reported-and-tested-by: Micah Parrish <micah.parrish@hpe.com>
Reported-and-tested-by: Brian Boylston <brian.boylston@hpe.com>
	Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
	Cc: <stable@vger.kernel.org>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Borislav Petkov <bp@suse.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Luis R. Rodriguez <mcgrof@suse.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Toshi Kani <toshi.kani@hp.com>
	Cc: Vishal Verma <vishal.l.verma@intel.com>
	Cc: linux-nvdimm@lists.01.org
Link: http://lkml.kernel.org/r/1455225857-12039-3-git-send-email-toshi.kani@hpe.com
[ Small readability edits. ]
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit a82eee7424525e34e98d821dd059ce14560a1e35)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/lib/copy_user_64.S
diff --cc arch/x86/lib/copy_user_64.S
index a30ca15be21c,27f89c79a44b..000000000000
--- a/arch/x86/lib/copy_user_64.S
+++ b/arch/x86/lib/copy_user_64.S
@@@ -294,5 -228,154 +294,158 @@@ ENTRY(copy_user_enhanced_fast_string
  	.previous
  
  	_ASM_EXTABLE(1b,12b)
 +	CFI_ENDPROC
  ENDPROC(copy_user_enhanced_fast_string)
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * copy_user_nocache - Uncached memory copy with exception handling
+  * This will force destination out of cache for more performance.
+  *
+  * Note: Cached memory copy is used when destination or size is not
+  * naturally aligned. That is:
+  *  - Require 8-byte alignment when size is 8 bytes or larger.
+  *  - Require 4-byte alignment when size is 4 bytes.
+  */
+ ENTRY(__copy_user_nocache)
+ 	ASM_STAC
+ 
+ 	/* If size is less than 8 bytes, go to 4-byte copy */
+ 	cmpl $8,%edx
+ 	jb .L_4b_nocache_copy_entry
+ 
+ 	/* If destination is not 8-byte aligned, "cache" copy to align it */
+ 	ALIGN_DESTINATION
+ 
+ 	/* Set 4x8-byte copy count and remainder */
+ 	movl %edx,%ecx
+ 	andl $63,%edx
+ 	shrl $6,%ecx
+ 	jz .L_8b_nocache_copy_entry	/* jump if count is 0 */
+ 
+ 	/* Perform 4x8-byte nocache loop-copy */
+ .L_4x8b_nocache_copy_loop:
+ 1:	movq (%rsi),%r8
+ 2:	movq 1*8(%rsi),%r9
+ 3:	movq 2*8(%rsi),%r10
+ 4:	movq 3*8(%rsi),%r11
+ 5:	movnti %r8,(%rdi)
+ 6:	movnti %r9,1*8(%rdi)
+ 7:	movnti %r10,2*8(%rdi)
+ 8:	movnti %r11,3*8(%rdi)
+ 9:	movq 4*8(%rsi),%r8
+ 10:	movq 5*8(%rsi),%r9
+ 11:	movq 6*8(%rsi),%r10
+ 12:	movq 7*8(%rsi),%r11
+ 13:	movnti %r8,4*8(%rdi)
+ 14:	movnti %r9,5*8(%rdi)
+ 15:	movnti %r10,6*8(%rdi)
+ 16:	movnti %r11,7*8(%rdi)
+ 	leaq 64(%rsi),%rsi
+ 	leaq 64(%rdi),%rdi
+ 	decl %ecx
+ 	jnz .L_4x8b_nocache_copy_loop
+ 
+ 	/* Set 8-byte copy count and remainder */
+ .L_8b_nocache_copy_entry:
+ 	movl %edx,%ecx
+ 	andl $7,%edx
+ 	shrl $3,%ecx
+ 	jz .L_4b_nocache_copy_entry	/* jump if count is 0 */
+ 
+ 	/* Perform 8-byte nocache loop-copy */
+ .L_8b_nocache_copy_loop:
+ 20:	movq (%rsi),%r8
+ 21:	movnti %r8,(%rdi)
+ 	leaq 8(%rsi),%rsi
+ 	leaq 8(%rdi),%rdi
+ 	decl %ecx
+ 	jnz .L_8b_nocache_copy_loop
+ 
+ 	/* If no byte left, we're done */
+ .L_4b_nocache_copy_entry:
+ 	andl %edx,%edx
+ 	jz .L_finish_copy
+ 
+ 	/* If destination is not 4-byte aligned, go to byte copy: */
+ 	movl %edi,%ecx
+ 	andl $3,%ecx
+ 	jnz .L_1b_cache_copy_entry
+ 
+ 	/* Set 4-byte copy count (1 or 0) and remainder */
+ 	movl %edx,%ecx
+ 	andl $3,%edx
+ 	shrl $2,%ecx
+ 	jz .L_1b_cache_copy_entry	/* jump if count is 0 */
+ 
+ 	/* Perform 4-byte nocache copy: */
+ 30:	movl (%rsi),%r8d
+ 31:	movnti %r8d,(%rdi)
+ 	leaq 4(%rsi),%rsi
+ 	leaq 4(%rdi),%rdi
+ 
+ 	/* If no bytes left, we're done: */
+ 	andl %edx,%edx
+ 	jz .L_finish_copy
+ 
+ 	/* Perform byte "cache" loop-copy for the remainder */
+ .L_1b_cache_copy_entry:
+ 	movl %edx,%ecx
+ .L_1b_cache_copy_loop:
+ 40:	movb (%rsi),%al
+ 41:	movb %al,(%rdi)
+ 	incq %rsi
+ 	incq %rdi
+ 	decl %ecx
+ 	jnz .L_1b_cache_copy_loop
+ 
+ 	/* Finished copying; fence the prior stores */
+ .L_finish_copy:
+ 	xorl %eax,%eax
+ 	ASM_CLAC
+ 	sfence
+ 	ret
+ 
+ 	.section .fixup,"ax"
+ .L_fixup_4x8b_copy:
+ 	shll $6,%ecx
+ 	addl %ecx,%edx
+ 	jmp .L_fixup_handle_tail
+ .L_fixup_8b_copy:
+ 	lea (%rdx,%rcx,8),%rdx
+ 	jmp .L_fixup_handle_tail
+ .L_fixup_4b_copy:
+ 	lea (%rdx,%rcx,4),%rdx
+ 	jmp .L_fixup_handle_tail
+ .L_fixup_1b_copy:
+ 	movl %ecx,%edx
+ .L_fixup_handle_tail:
+ 	sfence
+ 	jmp copy_user_handle_tail
+ 	.previous
+ 
+ 	_ASM_EXTABLE(1b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(2b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(3b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(4b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(5b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(6b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(7b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(8b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(9b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(10b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(11b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(12b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(13b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(14b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(15b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(16b,.L_fixup_4x8b_copy)
+ 	_ASM_EXTABLE(20b,.L_fixup_8b_copy)
+ 	_ASM_EXTABLE(21b,.L_fixup_8b_copy)
+ 	_ASM_EXTABLE(30b,.L_fixup_4b_copy)
+ 	_ASM_EXTABLE(31b,.L_fixup_4b_copy)
+ 	_ASM_EXTABLE(40b,.L_fixup_1b_copy)
+ 	_ASM_EXTABLE(41b,.L_fixup_1b_copy)
+ ENDPROC(__copy_user_nocache)
++>>>>>>> a82eee742452 (x86/uaccess/64: Handle the caching of 4-byte nocache copies properly in __copy_user_nocache())
* Unmerged path arch/x86/lib/copy_user_64.S
