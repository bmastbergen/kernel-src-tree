KVM: VMX: fix build without CONFIG_SMP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit 21bc8dc5b729dbeecb43adff23b74b51321e1897
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/21bc8dc5.failed

'apic' is not defined if !CONFIG_X86_64 && !CONFIG_X86_LOCAL_APIC.
Posted interrupt makes no sense without CONFIG_SMP, and
CONFIG_X86_LOCAL_APIC will be set with it.

	Reported-by: kbuild test robot <fengguang.wu@intel.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 21bc8dc5b729dbeecb43adff23b74b51321e1897)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index f9a5d46f7d5b,f7b20b417a3a..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -4206,6 -4330,74 +4206,77 @@@ static int vmx_vm_has_apicv(struct kvm 
  	return enable_apicv && irqchip_in_kernel(kvm);
  }
  
++<<<<<<< HEAD
++=======
+ static int vmx_complete_nested_posted_interrupt(struct kvm_vcpu *vcpu)
+ {
+ 	struct vcpu_vmx *vmx = to_vmx(vcpu);
+ 	int max_irr;
+ 	void *vapic_page;
+ 	u16 status;
+ 
+ 	if (vmx->nested.pi_desc &&
+ 	    vmx->nested.pi_pending) {
+ 		vmx->nested.pi_pending = false;
+ 		if (!pi_test_and_clear_on(vmx->nested.pi_desc))
+ 			return 0;
+ 
+ 		max_irr = find_last_bit(
+ 			(unsigned long *)vmx->nested.pi_desc->pir, 256);
+ 
+ 		if (max_irr == 256)
+ 			return 0;
+ 
+ 		vapic_page = kmap(vmx->nested.virtual_apic_page);
+ 		if (!vapic_page) {
+ 			WARN_ON(1);
+ 			return -ENOMEM;
+ 		}
+ 		__kvm_apic_update_irr(vmx->nested.pi_desc->pir, vapic_page);
+ 		kunmap(vmx->nested.virtual_apic_page);
+ 
+ 		status = vmcs_read16(GUEST_INTR_STATUS);
+ 		if ((u8)max_irr > ((u8)status & 0xff)) {
+ 			status &= ~0xff;
+ 			status |= (u8)max_irr;
+ 			vmcs_write16(GUEST_INTR_STATUS, status);
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ static inline bool kvm_vcpu_trigger_posted_interrupt(struct kvm_vcpu *vcpu)
+ {
+ #ifdef CONFIG_SMP
+ 	if (vcpu->mode == IN_GUEST_MODE) {
+ 		apic->send_IPI_mask(get_cpu_mask(vcpu->cpu),
+ 				POSTED_INTR_VECTOR);
+ 		return true;
+ 	}
+ #endif
+ 	return false;
+ }
+ 
+ static int vmx_deliver_nested_posted_interrupt(struct kvm_vcpu *vcpu,
+ 						int vector)
+ {
+ 	struct vcpu_vmx *vmx = to_vmx(vcpu);
+ 
+ 	if (is_guest_mode(vcpu) &&
+ 	    vector == vmx->nested.posted_intr_nv) {
+ 		/* the PIR and ON have been set by L1. */
+ 		kvm_vcpu_trigger_posted_interrupt(vcpu);
+ 		/*
+ 		 * If a posted intr is not recognized by hardware,
+ 		 * we will accomplish it in the next vmentry.
+ 		 */
+ 		vmx->nested.pi_pending = true;
+ 		kvm_make_request(KVM_REQ_EVENT, vcpu);
+ 		return 0;
+ 	}
+ 	return -1;
+ }
++>>>>>>> 21bc8dc5b729 (KVM: VMX: fix build without CONFIG_SMP)
  /*
   * Send interrupt to vcpu via posted interrupt way.
   * 1. If target vcpu is running(non-root mode), send posted interrupt
* Unmerged path arch/x86/kvm/vmx.c
