sched: Fix up scheduler syscall LTP fails

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit 39fd8fd22b3224ec6819d33b3e34ae4da6a35f05
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/39fd8fd2.failed

Wu reported LTP failures:

  > ltp.sched_setparam02.1.TFAIL
  > ltp.sched_setparam02.2.TFAIL
  > ltp.sched_setparam02.3.TFAIL
  > ltp.sched_setparam03.1.TFAIL

There were 2 things wrong; firstly __setscheduler() failed on
sched_setparam()'s policy = -1, fix that by reading from p->policy in
that case.

Secondly, getparam() (and getattr()) would still report !0
sched_priority for !FIFO/RR tasks after having been such. So
unconditionally set p->rt_priority.

	Reported-by: Fengguang Wu <fengguang.wu@intel.com>
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
	Cc: Juri Lelli <juri.lelli@gmail.com>
	Cc: Dario Faggioli <raistlin@linux.it>
Fixes: d50dde5a10f3 ("sched: Add new scheduler syscalls to support an extended scheduling parameters ABI")
Link: http://lkml.kernel.org/r/20140115153320.GH31570@twins.programming.kicks-ass.net
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 39fd8fd22b3224ec6819d33b3e34ae4da6a35f05)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/core.c
diff --cc kernel/sched/core.c
index f167fdc57a94,e9212eb354b8..000000000000
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@@ -4083,16 -3143,58 +4083,54 @@@ static struct task_struct *find_process
  	return pid ? find_task_by_vpid(pid) : current;
  }
  
 -/*
 - * This function initializes the sched_dl_entity of a newly becoming
 - * SCHED_DEADLINE task.
 - *
 - * Only the static values are considered here, the actual runtime and the
 - * absolute deadline will be properly calculated when the task is enqueued
 - * for the first time with its new policy.
 - */
 +/* Actually do priority change: must hold rq lock. */
  static void
 -__setparam_dl(struct task_struct *p, const struct sched_attr *attr)
 +__setscheduler(struct rq *rq, struct task_struct *p, int policy, int prio)
  {
++<<<<<<< HEAD
 +	p->policy = policy;
 +	p->rt_priority = prio;
++=======
+ 	struct sched_dl_entity *dl_se = &p->dl;
+ 
+ 	init_dl_task_timer(dl_se);
+ 	dl_se->dl_runtime = attr->sched_runtime;
+ 	dl_se->dl_deadline = attr->sched_deadline;
+ 	dl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline;
+ 	dl_se->flags = attr->sched_flags;
+ 	dl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime);
+ 	dl_se->dl_throttled = 0;
+ 	dl_se->dl_new = 1;
+ }
+ 
+ /* Actually do priority change: must hold pi & rq lock. */
+ static void __setscheduler(struct rq *rq, struct task_struct *p,
+ 			   const struct sched_attr *attr)
+ {
+ 	int policy = attr->sched_policy;
+ 
+ 	if (policy == -1) /* setparam */
+ 		policy = p->policy;
+ 
+ 	p->policy = policy;
+ 
+ 	if (dl_policy(policy))
+ 		__setparam_dl(p, attr);
+ 	else if (fair_policy(policy))
+ 		p->static_prio = NICE_TO_PRIO(attr->sched_nice);
+ 
+ 	/*
+ 	 * __sched_setscheduler() ensures attr->sched_priority == 0 when
+ 	 * !rt_policy. Always setting this ensures that things like
+ 	 * getparam()/getattr() don't report silly values for !rt tasks.
+ 	 */
+ 	p->rt_priority = attr->sched_priority;
+ 
++>>>>>>> 39fd8fd22b32 (sched: Fix up scheduler syscall LTP fails)
  	p->normal_prio = normal_prio(p);
 +	/* we are holding p->pi_lock already */
  	p->prio = rt_mutex_getprio(p);
 -
 -	if (dl_prio(p->prio))
 -		p->sched_class = &dl_sched_class;
 -	else if (rt_prio(p->prio))
 +	if (rt_prio(p->prio))
  		p->sched_class = &rt_sched_class;
  	else
  		p->sched_class = &fair_sched_class;
* Unmerged path kernel/sched/core.c
