x86/mm/mtrr: Clean up mtrr_type_lookup()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] mm/mtrr: Clean up mtrr_type_lookup() (Eric Sandeen) [1274459]
Rebuild_FUZZ: 94.74%
commit-author Toshi Kani <toshi.kani@hp.com>
commit 0cc705f56e400764a171055f727d28a48260bb4b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0cc705f5.failed

MTRRs contain fixed and variable entries. mtrr_type_lookup() may
repeatedly call __mtrr_type_lookup() to handle a request that
overlaps with variable entries.

However, __mtrr_type_lookup() also handles the fixed entries,
which do not have to be repeated. Therefore, this patch creates
separate functions, mtrr_type_lookup_fixed() and
mtrr_type_lookup_variable(), to handle the fixed and variable
ranges respectively.

The patch also updates the function headers to clarify the
return values and output argument. It updates comments to
clarify that the repeating is necessary to handle overlaps with
the default type, since overlaps with multiple entries alone can
be handled without such repeating.

There is no functional change in this patch.

	Signed-off-by: Toshi Kani <toshi.kani@hp.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: Elliott@hp.com
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Luis R. Rodriguez <mcgrof@suse.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: dave.hansen@intel.com
	Cc: linux-mm <linux-mm@kvack.org>
	Cc: pebolle@tiscali.nl
Link: http://lkml.kernel.org/r/1431714237-880-6-git-send-email-toshi.kani@hp.com
Link: http://lkml.kernel.org/r/1432628901-18044-6-git-send-email-bp@alien8.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 0cc705f56e400764a171055f727d28a48260bb4b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/mtrr/generic.c
diff --cc arch/x86/kernel/cpu/mtrr/generic.c
index 199d2e414219,e51100c49eea..000000000000
--- a/arch/x86/kernel/cpu/mtrr/generic.c
+++ b/arch/x86/kernel/cpu/mtrr/generic.c
@@@ -102,56 -102,69 +102,117 @@@ static int check_type_overlap(u8 *prev
  	return 0;
  }
  
++<<<<<<< HEAD
 +/*
 + * Error/Semi-error returns:
 + * 0xFF - when MTRR is not enabled
 + * *repeat == 1 implies [start:end] spanned across MTRR range and type returned
 + *		corresponds only to [start:*partial_end].
 + *		Caller has to lookup again for [*partial_end:end].
++=======
+ /**
+  * mtrr_type_lookup_fixed - look up memory type in MTRR fixed entries
+  *
+  * Return the MTRR fixed memory type of 'start'.
+  *
+  * MTRR fixed entries are divided into the following ways:
+  *  0x00000 - 0x7FFFF : This range is divided into eight 64KB sub-ranges
+  *  0x80000 - 0xBFFFF : This range is divided into sixteen 16KB sub-ranges
+  *  0xC0000 - 0xFFFFF : This range is divided into sixty-four 4KB sub-ranges
+  *
+  * Return Values:
+  * MTRR_TYPE_(type)  - Matched memory type
+  * MTRR_TYPE_INVALID - Unmatched
++>>>>>>> 0cc705f56e40 (x86/mm/mtrr: Clean up mtrr_type_lookup())
   */
- static u8 __mtrr_type_lookup(u64 start, u64 end, u64 *partial_end, int *repeat)
+ static u8 mtrr_type_lookup_fixed(u64 start, u64 end)
+ {
+ 	int idx;
+ 
+ 	if (start >= 0x100000)
+ 		return MTRR_TYPE_INVALID;
+ 
+ 	/* 0x0 - 0x7FFFF */
+ 	if (start < 0x80000) {
+ 		idx = 0;
+ 		idx += (start >> 16);
+ 		return mtrr_state.fixed_ranges[idx];
+ 	/* 0x80000 - 0xBFFFF */
+ 	} else if (start < 0xC0000) {
+ 		idx = 1 * 8;
+ 		idx += ((start - 0x80000) >> 14);
+ 		return mtrr_state.fixed_ranges[idx];
+ 	}
+ 
+ 	/* 0xC0000 - 0xFFFFF */
+ 	idx = 3 * 8;
+ 	idx += ((start - 0xC0000) >> 12);
+ 	return mtrr_state.fixed_ranges[idx];
+ }
+ 
+ /**
+  * mtrr_type_lookup_variable - look up memory type in MTRR variable entries
+  *
+  * Return Value:
+  * MTRR_TYPE_(type) - Matched memory type or default memory type (unmatched)
+  *
+  * Output Argument:
+  * repeat - Set to 1 when [start:end] spanned across MTRR range and type
+  *	    returned corresponds only to [start:*partial_end].  Caller has
+  *	    to lookup again for [*partial_end:end].
+  */
+ static u8 mtrr_type_lookup_variable(u64 start, u64 end, u64 *partial_end,
+ 				    int *repeat)
  {
  	int i;
  	u64 base, mask;
  	u8 prev_match, curr_match;
  
  	*repeat = 0;
++<<<<<<< HEAD
 +	if (!mtrr_state_set)
 +		return 0xFF;
 +
 +	if (!(mtrr_state.enabled & MTRR_STATE_MTRR_ENABLED))
 +		return 0xFF;
 +
 +	/* Make end inclusive end, instead of exclusive */
 +	end--;
 +
 +	/* Look in fixed ranges. Just return the type as per start */
 +	if ((start < 0x100000) &&
 +	    (mtrr_state.have_fixed) &&
 +	    (mtrr_state.enabled & MTRR_STATE_MTRR_FIXED_ENABLED)) {
 +		int idx;
 +
 +		if (start < 0x80000) {
 +			idx = 0;
 +			idx += (start >> 16);
 +			return mtrr_state.fixed_ranges[idx];
 +		} else if (start < 0xC0000) {
 +			idx = 1 * 8;
 +			idx += ((start - 0x80000) >> 14);
 +			return mtrr_state.fixed_ranges[idx];
 +		} else {
 +			idx = 3 * 8;
 +			idx += ((start - 0xC0000) >> 12);
 +			return mtrr_state.fixed_ranges[idx];
 +		}
 +	}
 +
 +	/*
 +	 * Look in variable ranges
 +	 * Look of multiple ranges matching this address and pick type
 +	 * as per MTRR precedence
 +	 */
 +	prev_match = 0xFF;
++=======
+ 
+ 	/* Make end inclusive instead of exclusive */
+ 	end--;
+ 
+ 	prev_match = MTRR_TYPE_INVALID;
++>>>>>>> 0cc705f56e40 (x86/mm/mtrr: Clean up mtrr_type_lookup())
  	for (i = 0; i < num_var_ranges; ++i) {
  		unsigned short start_state, end_state, inclusive;
  
@@@ -215,21 -229,18 +277,34 @@@
  			return curr_match;
  	}
  
++<<<<<<< HEAD
 +	if (mtrr_tom2) {
 +		if (start >= (1ULL<<32) && (end < mtrr_tom2))
 +			return MTRR_TYPE_WRBACK;
 +	}
 +
 +	if (prev_match != 0xFF)
++=======
+ 	if (prev_match != MTRR_TYPE_INVALID)
++>>>>>>> 0cc705f56e40 (x86/mm/mtrr: Clean up mtrr_type_lookup())
  		return prev_match;
  
  	return mtrr_state.def_type;
  }
  
++<<<<<<< HEAD
 +/*
 + * Returns the effective MTRR type for the region
 + * Error return:
 + * 0xFF - when MTRR is not enabled
++=======
+ /**
+  * mtrr_type_lookup - look up memory type in MTRR
+  *
+  * Return Values:
+  * MTRR_TYPE_(type)  - The effective MTRR type for the region
+  * MTRR_TYPE_INVALID - MTRR is disabled
++>>>>>>> 0cc705f56e40 (x86/mm/mtrr: Clean up mtrr_type_lookup())
   */
  u8 mtrr_type_lookup(u64 start, u64 end)
  {
* Unmerged path arch/x86/kernel/cpu/mtrr/generic.c
