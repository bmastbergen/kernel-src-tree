cxl: Separate bare-metal fields in adapter and AFU data structures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christophe Lombard <clombard@linux.vnet.ibm.com>
commit cbffa3a5146a90f46806cef3a98b8be5833727e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/cbffa3a5.failed

Introduce sub-structures containing the bare-metal specific fields in
the structures describing the adapter (struct cxl) and AFU (struct
cxl_afu).
Update all their references.

Co-authored-by: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
	Signed-off-by: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
	Signed-off-by: Christophe Lombard <clombard@linux.vnet.ibm.com>
	Reviewed-by: Manoj Kumar <manoj@linux.vnet.ibm.com>
	Acked-by: Ian Munsie <imunsie@au1.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit cbffa3a5146a90f46806cef3a98b8be5833727e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/cxl/irq.c
#	drivers/misc/cxl/native.c
diff --cc drivers/misc/cxl/irq.c
index 0123d6e2be16,be646dc41a2c..000000000000
--- a/drivers/misc/cxl/irq.c
+++ b/drivers/misc/cxl/irq.c
@@@ -229,12 -264,15 +229,20 @@@ int afu_allocate_irqs(struct cxl_contex
  	/* Initialize the list head to hold irq names */
  	INIT_LIST_HEAD(&ctx->irq_names);
  
 -	if ((rc = cxl_ops->alloc_irq_ranges(&ctx->irqs, ctx->afu->adapter,
 -							alloc_count)))
 +	if ((rc = cxl_alloc_irq_ranges(&ctx->irqs, ctx->afu->adapter, count)))
  		return rc;
  
++<<<<<<< HEAD
 +	/* Multiplexed PSL Interrupt */
 +	ctx->irqs.offset[0] = ctx->afu->psl_hwirq;
 +	ctx->irqs.range[0] = 1;
++=======
+ 	if (cpu_has_feature(CPU_FTR_HVMODE)) {
+ 		/* Multiplexed PSL Interrupt */
+ 		ctx->irqs.offset[0] = ctx->afu->native->psl_hwirq;
+ 		ctx->irqs.range[0] = 1;
+ 	}
++>>>>>>> cbffa3a5146a (cxl: Separate bare-metal fields in adapter and AFU data structures)
  
  	ctx->irq_count = count;
  	ctx->irq_bitmap = kcalloc(BITS_TO_LONGS(count),
diff --cc drivers/misc/cxl/native.c
index 588c4e3aa772,c0bca59a12aa..000000000000
--- a/drivers/misc/cxl/native.c
+++ b/drivers/misc/cxl/native.c
@@@ -848,9 -848,9 +851,15 @@@ int cxl_register_psl_err_irq(struct cx
  	if (!adapter->irq_name)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	if ((rc = cxl_register_one_irq(adapter, cxl_irq_err, adapter,
 +				       &adapter->err_hwirq,
 +				       &adapter->err_virq,
++=======
+ 	if ((rc = cxl_register_one_irq(adapter, native_irq_err, adapter,
+ 				       &adapter->native->err_hwirq,
+ 				       &adapter->native->err_virq,
++>>>>>>> cbffa3a5146a (cxl: Separate bare-metal fields in adapter and AFU data structures)
  				       adapter->irq_name))) {
  		kfree(adapter->irq_name);
  		adapter->irq_name = NULL;
@@@ -862,14 -862,14 +871,19 @@@
  	return 0;
  }
  
 -void cxl_native_release_psl_err_irq(struct cxl *adapter)
 +void cxl_release_psl_err_irq(struct cxl *adapter)
  {
- 	if (adapter->err_virq != irq_find_mapping(NULL, adapter->err_hwirq))
+ 	if (adapter->native->err_virq != irq_find_mapping(NULL, adapter->native->err_hwirq))
  		return;
  
  	cxl_p1_write(adapter, CXL_PSL_ErrIVTE, 0x0000000000000000);
++<<<<<<< HEAD
 +	cxl_unmap_irq(adapter->err_virq, adapter);
 +	cxl_release_one_irq(adapter, adapter->err_hwirq);
++=======
+ 	cxl_unmap_irq(adapter->native->err_virq, adapter);
+ 	cxl_ops->release_one_irq(adapter, adapter->native->err_hwirq);
++>>>>>>> cbffa3a5146a (cxl: Separate bare-metal fields in adapter and AFU data structures)
  	kfree(adapter->irq_name);
  }
  
@@@ -918,8 -918,8 +932,13 @@@ int cxl_register_psl_irq(struct cxl_af
  	if (!afu->psl_irq_name)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	if ((rc = cxl_register_one_irq(afu->adapter, cxl_irq_multiplexed, afu,
 +				    &afu->psl_hwirq, &afu->psl_virq,
++=======
+ 	if ((rc = cxl_register_one_irq(afu->adapter, native_irq_multiplexed,
+ 				    afu, &afu->native->psl_hwirq, &afu->native->psl_virq,
++>>>>>>> cbffa3a5146a (cxl: Separate bare-metal fields in adapter and AFU data structures)
  				    afu->psl_irq_name))) {
  		kfree(afu->psl_irq_name);
  		afu->psl_irq_name = NULL;
@@@ -927,13 -927,13 +946,18 @@@
  	return rc;
  }
  
 -void cxl_native_release_psl_irq(struct cxl_afu *afu)
 +void cxl_release_psl_irq(struct cxl_afu *afu)
  {
- 	if (afu->psl_virq != irq_find_mapping(NULL, afu->psl_hwirq))
+ 	if (afu->native->psl_virq != irq_find_mapping(NULL, afu->native->psl_hwirq))
  		return;
  
++<<<<<<< HEAD
 +	cxl_unmap_irq(afu->psl_virq, afu);
 +	cxl_release_one_irq(afu->adapter, afu->psl_hwirq);
++=======
+ 	cxl_unmap_irq(afu->native->psl_virq, afu);
+ 	cxl_ops->release_one_irq(afu->adapter, afu->native->psl_hwirq);
++>>>>>>> cbffa3a5146a (cxl: Separate bare-metal fields in adapter and AFU data structures)
  	kfree(afu->psl_irq_name);
  }
  
@@@ -967,25 -967,29 +991,45 @@@ int cxl_check_error(struct cxl_afu *afu
  	return (cxl_p1n_read(afu, CXL_PSL_SCNTL_An) == ~0ULL);
  }
  
 -static int native_afu_cr_read64(struct cxl_afu *afu, int cr, u64 off, u64 *out)
 +u64 cxl_afu_cr_read64(struct cxl_afu *afu, int cr, u64 off)
  {
++<<<<<<< HEAD
 +	if (likely(cxl_adapter_link_ok(afu->adapter)))
 +		return in_le64((afu)->afu_desc_mmio + (afu)->crs_offset +
 +			       ((cr) * (afu)->crs_len) + (off));
 +	else
 +		return ~0ULL;
++=======
+ 	if (unlikely(!cxl_ops->link_ok(afu->adapter)))
+ 		return -EIO;
+ 	if (unlikely(off >= afu->crs_len))
+ 		return -ERANGE;
+ 	*out = in_le64(afu->native->afu_desc_mmio + afu->crs_offset +
+ 		(cr * afu->crs_len) + off);
+ 	return 0;
++>>>>>>> cbffa3a5146a (cxl: Separate bare-metal fields in adapter and AFU data structures)
  }
  
 -static int native_afu_cr_read32(struct cxl_afu *afu, int cr, u64 off, u32 *out)
 +u32 cxl_afu_cr_read32(struct cxl_afu *afu, int cr, u64 off)
  {
++<<<<<<< HEAD
 +	if (likely(cxl_adapter_link_ok(afu->adapter)))
 +		return in_le32((afu)->afu_desc_mmio + (afu)->crs_offset +
 +			       ((cr) * (afu)->crs_len) + (off));
 +	else
 +		return 0xffffffff;
++=======
+ 	if (unlikely(!cxl_ops->link_ok(afu->adapter)))
+ 		return -EIO;
+ 	if (unlikely(off >= afu->crs_len))
+ 		return -ERANGE;
+ 	*out = in_le32(afu->native->afu_desc_mmio + afu->crs_offset +
+ 		(cr * afu->crs_len) + off);
+ 	return 0;
++>>>>>>> cbffa3a5146a (cxl: Separate bare-metal fields in adapter and AFU data structures)
  }
  
 -static int native_afu_cr_read16(struct cxl_afu *afu, int cr, u64 off, u16 *out)
 +u16 cxl_afu_cr_read16(struct cxl_afu *afu, int cr, u64 off)
  {
  	u64 aligned_off = off & ~0x3L;
  	u32 val;
diff --git a/drivers/misc/cxl/context.c b/drivers/misc/cxl/context.c
index 7053331db9ff..d35f875201c8 100644
--- a/drivers/misc/cxl/context.c
+++ b/drivers/misc/cxl/context.c
@@ -96,7 +96,7 @@ int cxl_context_init(struct cxl_context *ctx, struct cxl_afu *afu, bool master,
 
 	ctx->pe = i;
 	if (cpu_has_feature(CPU_FTR_HVMODE))
-		ctx->elem = &ctx->afu->spa[i];
+		ctx->elem = &ctx->afu->native->spa[i];
 	ctx->pe_inserted = false;
 
 	/*
diff --git a/drivers/misc/cxl/cxl.h b/drivers/misc/cxl/cxl.h
index ea4888bb5ce4..079e5049453d 100644
--- a/drivers/misc/cxl/cxl.h
+++ b/drivers/misc/cxl/cxl.h
@@ -344,18 +344,44 @@ struct cxl_sste {
 #define to_cxl_adapter(d) container_of(d, struct cxl, dev)
 #define to_cxl_afu(d) container_of(d, struct cxl_afu, dev)
 
-struct cxl_afu {
+struct cxl_afu_native {
+	void __iomem *p1n_mmio;
+	void __iomem *afu_desc_mmio;
 	irq_hw_number_t psl_hwirq;
+	unsigned int psl_virq;
+	struct mutex spa_mutex;
+	/*
+	 * Only the first part of the SPA is used for the process element
+	 * linked list. The only other part that software needs to worry about
+	 * is sw_command_status, which we store a separate pointer to.
+	 * Everything else in the SPA is only used by hardware
+	 */
+	struct cxl_process_element *spa;
+	__be64 *sw_command_status;
+	unsigned int spa_size;
+	int spa_order;
+	int spa_max_procs;
+	u64 pp_offset;
+};
+
+struct cxl_afu_guest {
+	u64 handle;
+	phys_addr_t p2n_phys;
+	u64 p2n_size;
+	int max_ints;
+};
+
+struct cxl_afu {
+	struct cxl_afu_native *native;
+	struct cxl_afu_guest *guest;
 	irq_hw_number_t serr_hwirq;
-	char *err_irq_name;
-	char *psl_irq_name;
 	unsigned int serr_virq;
-	void __iomem *p1n_mmio;
+	char *psl_irq_name;
+	char *err_irq_name;
 	void __iomem *p2n_mmio;
 	phys_addr_t psn_phys;
-	u64 pp_offset;
 	u64 pp_size;
-	void __iomem *afu_desc_mmio;
+
 	struct cxl *adapter;
 	struct device dev;
 	struct cdev afu_cdev_s, afu_cdev_m, afu_cdev_d;
@@ -363,26 +389,12 @@ struct cxl_afu {
 	struct idr contexts_idr;
 	struct dentry *debugfs;
 	struct mutex contexts_lock;
-	struct mutex spa_mutex;
 	spinlock_t afu_cntl_lock;
 
 	/* AFU error buffer fields and bin attribute for sysfs */
 	u64 eb_len, eb_offset;
 	struct bin_attribute attr_eb;
 
-	/*
-	 * Only the first part of the SPA is used for the process element
-	 * linked list. The only other part that software needs to worry about
-	 * is sw_command_status, which we store a separate pointer to.
-	 * Everything else in the SPA is only used by hardware
-	 */
-	struct cxl_process_element *spa;
-	__be64 *sw_command_status;
-	unsigned int spa_size;
-	int spa_order;
-	int spa_max_procs;
-	unsigned int psl_virq;
-
 	/* pointer to the vphb */
 	struct pci_controller *phb;
 
@@ -488,11 +500,34 @@ struct cxl_context {
 	struct rcu_head rcu;
 };
 
-struct cxl {
+struct cxl_native {
+	u64 afu_desc_off;
+	u64 afu_desc_size;
 	void __iomem *p1_mmio;
 	void __iomem *p2_mmio;
 	irq_hw_number_t err_hwirq;
 	unsigned int err_virq;
+	u64 ps_off;
+};
+
+struct cxl_guest {
+	struct platform_device *pdev;
+	int irq_nranges;
+	struct cdev cdev;
+	irq_hw_number_t irq_base_offset;
+	struct irq_avail *irq_avail;
+	spinlock_t irq_alloc_lock;
+	u64 handle;
+	char *status;
+	u16 vendor;
+	u16 device;
+	u16 subsystem_vendor;
+	u16 subsystem;
+};
+
+struct cxl {
+	struct cxl_native *native;
+	struct cxl_guest *guest;
 	spinlock_t afu_list_lock;
 	struct cxl_afu *afu[CXL_MAX_SLICES];
 	struct device dev;
@@ -503,9 +538,6 @@ struct cxl {
 	struct bin_attribute cxl_attr;
 	int adapter_num;
 	int user_irqs;
-	u64 afu_desc_off;
-	u64 afu_desc_size;
-	u64 ps_off;
 	u64 ps_size;
 	u16 psl_rev;
 	u16 base_image;
@@ -570,7 +602,7 @@ static inline bool cxl_adapter_link_ok(struct cxl *cxl)
 static inline void __iomem *_cxl_p1_addr(struct cxl *cxl, cxl_p1_reg_t reg)
 {
 	WARN_ON(!cpu_has_feature(CPU_FTR_HVMODE));
-	return cxl->p1_mmio + cxl_reg_off(reg);
+	return cxl->native->p1_mmio + cxl_reg_off(reg);
 }
 
 static inline void cxl_p1_write(struct cxl *cxl, cxl_p1_reg_t reg, u64 val)
@@ -590,7 +622,7 @@ static inline u64 cxl_p1_read(struct cxl *cxl, cxl_p1_reg_t reg)
 static inline void __iomem *_cxl_p1n_addr(struct cxl_afu *afu, cxl_p1n_reg_t reg)
 {
 	WARN_ON(!cpu_has_feature(CPU_FTR_HVMODE));
-	return afu->p1n_mmio + cxl_reg_off(reg);
+	return afu->native->p1n_mmio + cxl_reg_off(reg);
 }
 
 static inline void cxl_p1n_write(struct cxl_afu *afu, cxl_p1n_reg_t reg, u64 val)
* Unmerged path drivers/misc/cxl/irq.c
diff --git a/drivers/misc/cxl/main.c b/drivers/misc/cxl/main.c
index f58802a37c46..ef690a8a6ec0 100644
--- a/drivers/misc/cxl/main.c
+++ b/drivers/misc/cxl/main.c
@@ -259,7 +259,6 @@ struct cxl_afu *cxl_alloc_afu(struct cxl *adapter, int slice)
 	idr_init(&afu->contexts_idr);
 	mutex_init(&afu->contexts_lock);
 	spin_lock_init(&afu->afu_cntl_lock);
-	mutex_init(&afu->spa_mutex);
 
 	afu->prefault_mode = CXL_PREFAULT_NONE;
 	afu->irqs_max = afu->adapter->user_irqs;
* Unmerged path drivers/misc/cxl/native.c
diff --git a/drivers/misc/cxl/pci.c b/drivers/misc/cxl/pci.c
index c7dc27fa6ee0..7562857a9596 100644
--- a/drivers/misc/cxl/pci.c
+++ b/drivers/misc/cxl/pci.c
@@ -91,8 +91,8 @@
 
 /* This works a little different than the p1/p2 register accesses to make it
  * easier to pull out individual fields */
-#define AFUD_READ(afu, off)		in_be64(afu->afu_desc_mmio + off)
-#define AFUD_READ_LE(afu, off)		in_le64(afu->afu_desc_mmio + off)
+#define AFUD_READ(afu, off)		in_be64(afu->native->afu_desc_mmio + off)
+#define AFUD_READ_LE(afu, off)		in_le64(afu->native->afu_desc_mmio + off)
 #define EXTRACT_PPC_BIT(val, bit)	(!!(val & PPC_BIT(bit)))
 #define EXTRACT_PPC_BITS(val, bs, be)	((val & PPC_BITMASK(bs, be)) >> PPC_BITLSHIFT(be))
 
@@ -589,15 +589,15 @@ static int cxl_map_slice_regs(struct cxl_afu *afu, struct cxl *adapter, struct p
 
 	p1n_base = p1_base(dev) + 0x10000 + (afu->slice * p1n_size);
 	p2n_base = p2_base(dev) + (afu->slice * p2n_size);
-	afu->psn_phys = p2_base(dev) + (adapter->ps_off + (afu->slice * adapter->ps_size));
-	afu_desc = p2_base(dev) + adapter->afu_desc_off + (afu->slice * adapter->afu_desc_size);
+	afu->psn_phys = p2_base(dev) + (adapter->native->ps_off + (afu->slice * adapter->ps_size));
+	afu_desc = p2_base(dev) + adapter->native->afu_desc_off + (afu->slice * adapter->native->afu_desc_size);
 
-	if (!(afu->p1n_mmio = ioremap(p1n_base, p1n_size)))
+	if (!(afu->native->p1n_mmio = ioremap(p1n_base, p1n_size)))
 		goto err;
 	if (!(afu->p2n_mmio = ioremap(p2n_base, p2n_size)))
 		goto err1;
 	if (afu_desc) {
-		if (!(afu->afu_desc_mmio = ioremap(afu_desc, adapter->afu_desc_size)))
+		if (!(afu->native->afu_desc_mmio = ioremap(afu_desc, adapter->native->afu_desc_size)))
 			goto err2;
 	}
 
@@ -605,7 +605,7 @@ static int cxl_map_slice_regs(struct cxl_afu *afu, struct cxl *adapter, struct p
 err2:
 	iounmap(afu->p2n_mmio);
 err1:
-	iounmap(afu->p1n_mmio);
+	iounmap(afu->native->p1n_mmio);
 err:
 	dev_err(&afu->dev, "Error mapping AFU MMIO regions\n");
 	return -ENOMEM;
@@ -617,13 +617,13 @@ static void cxl_unmap_slice_regs(struct cxl_afu *afu)
 		iounmap(afu->p2n_mmio);
 		afu->p2n_mmio = NULL;
 	}
-	if (afu->p1n_mmio) {
-		iounmap(afu->p1n_mmio);
-		afu->p1n_mmio = NULL;
+	if (afu->native->p1n_mmio) {
+		iounmap(afu->native->p1n_mmio);
+		afu->native->p1n_mmio = NULL;
 	}
-	if (afu->afu_desc_mmio) {
-		iounmap(afu->afu_desc_mmio);
-		afu->afu_desc_mmio = NULL;
+	if (afu->native->afu_desc_mmio) {
+		iounmap(afu->native->afu_desc_mmio);
+		afu->native->afu_desc_mmio = NULL;
 	}
 }
 
@@ -636,6 +636,7 @@ void cxl_release_afu(struct device *dev)
 	idr_destroy(&afu->contexts_idr);
 	cxl_release_spa(afu);
 
+	kfree(afu->native);
 	kfree(afu);
 }
 
@@ -660,7 +661,7 @@ static int cxl_read_afu_descriptor(struct cxl_afu *afu)
 	afu->pp_size = AFUD_PPPSA_LEN(val) * 4096;
 	afu->psa = AFUD_PPPSA_PSA(val);
 	if ((afu->pp_psa = AFUD_PPPSA_PP(val)))
-		afu->pp_offset = AFUD_READ_PPPSA_OFF(afu);
+		afu->native->pp_offset = AFUD_READ_PPPSA_OFF(afu);
 
 	val = AFUD_READ_CR(afu);
 	afu->crs_len = AFUD_CR_LEN(val) * 256;
@@ -690,7 +691,7 @@ static int cxl_afu_descriptor_looks_ok(struct cxl_afu *afu)
 	int i;
 
 	if (afu->psa && afu->adapter->ps_size <
-			(afu->pp_offset + afu->pp_size*afu->max_procs_virtualised)) {
+			(afu->native->pp_offset + afu->pp_size*afu->max_procs_virtualised)) {
 		dev_err(&afu->dev, "per-process PSA can't fit inside the PSA!\n");
 		return -ENODEV;
 	}
@@ -774,7 +775,7 @@ ssize_t cxl_afu_read_err_buffer(struct cxl_afu *afu, char *buf,
 	loff_t aligned_start, aligned_end;
 	size_t aligned_length;
 	void *tbuf;
-	const void __iomem *ebuf = afu->afu_desc_mmio + afu->eb_offset;
+	const void __iomem *ebuf = afu->native->afu_desc_mmio + afu->eb_offset;
 
 	if (count == 0 || off < 0 || (size_t)off >= afu->eb_len)
 		return 0;
@@ -856,19 +857,25 @@ static void cxl_deconfigure_afu(struct cxl_afu *afu)
 static int cxl_init_afu(struct cxl *adapter, int slice, struct pci_dev *dev)
 {
 	struct cxl_afu *afu;
-	int rc;
+	int rc = -ENOMEM;
 
 	afu = cxl_alloc_afu(adapter, slice);
 	if (!afu)
 		return -ENOMEM;
 
+	afu->native = kzalloc(sizeof(struct cxl_afu_native), GFP_KERNEL);
+	if (!afu->native)
+		goto err_free_afu;
+
+	mutex_init(&afu->native->spa_mutex);
+
 	rc = dev_set_name(&afu->dev, "afu%i.%i", adapter->adapter_num, slice);
 	if (rc)
-		goto err_free;
+		goto err_free_native;
 
 	rc = cxl_configure_afu(afu, adapter, dev);
 	if (rc)
-		goto err_free;
+		goto err_free_native;
 
 	/* Don't care if this fails */
 	cxl_debugfs_afu_add(afu);
@@ -896,7 +903,9 @@ err_put1:
 	device_unregister(&afu->dev);
 	return rc;
 
-err_free:
+err_free_native:
+	kfree(afu->native);
+err_free_afu:
 	kfree(afu);
 	return rc;
 
@@ -957,17 +966,17 @@ static int cxl_map_adapter_regs(struct cxl *adapter, struct pci_dev *dev)
 	pr_devel("cxl_map_adapter_regs: p1: %#016llx %#llx, p2: %#016llx %#llx",
 			p1_base(dev), p1_size(dev), p2_base(dev), p2_size(dev));
 
-	if (!(adapter->p1_mmio = ioremap(p1_base(dev), p1_size(dev))))
+	if (!(adapter->native->p1_mmio = ioremap(p1_base(dev), p1_size(dev))))
 		goto err3;
 
-	if (!(adapter->p2_mmio = ioremap(p2_base(dev), p2_size(dev))))
+	if (!(adapter->native->p2_mmio = ioremap(p2_base(dev), p2_size(dev))))
 		goto err4;
 
 	return 0;
 
 err4:
-	iounmap(adapter->p1_mmio);
-	adapter->p1_mmio = NULL;
+	iounmap(adapter->native->p1_mmio);
+	adapter->native->p1_mmio = NULL;
 err3:
 	pci_release_region(dev, 0);
 err2:
@@ -978,14 +987,14 @@ err1:
 
 static void cxl_unmap_adapter_regs(struct cxl *adapter)
 {
-	if (adapter->p1_mmio) {
-		iounmap(adapter->p1_mmio);
-		adapter->p1_mmio = NULL;
+	if (adapter->native->p1_mmio) {
+		iounmap(adapter->native->p1_mmio);
+		adapter->native->p1_mmio = NULL;
 		pci_release_region(to_pci_dev(adapter->dev.parent), 2);
 	}
-	if (adapter->p2_mmio) {
-		iounmap(adapter->p2_mmio);
-		adapter->p2_mmio = NULL;
+	if (adapter->native->p2_mmio) {
+		iounmap(adapter->native->p2_mmio);
+		adapter->native->p2_mmio = NULL;
 		pci_release_region(to_pci_dev(adapter->dev.parent), 0);
 	}
 }
@@ -1026,10 +1035,10 @@ static int cxl_read_vsec(struct cxl *adapter, struct pci_dev *dev)
 
 	/* Convert everything to bytes, because there is NO WAY I'd look at the
 	 * code a month later and forget what units these are in ;-) */
-	adapter->ps_off = ps_off * 64 * 1024;
+	adapter->native->ps_off = ps_off * 64 * 1024;
 	adapter->ps_size = ps_size * 64 * 1024;
-	adapter->afu_desc_off = afu_desc_off * 64 * 1024;
-	adapter->afu_desc_size = afu_desc_size *64 * 1024;
+	adapter->native->afu_desc_off = afu_desc_off * 64 * 1024;
+	adapter->native->afu_desc_size = afu_desc_size * 64 * 1024;
 
 	/* Total IRQs - 1 PSL ERROR - #AFU*(1 slice error + 1 DSI) */
 	adapter->user_irqs = pnv_cxl_get_irq_count(dev) - 1 - 2*adapter->slices;
@@ -1080,15 +1089,15 @@ static int cxl_vsec_looks_ok(struct cxl *adapter, struct pci_dev *dev)
 		return -EINVAL;
 	}
 
-	if (!adapter->afu_desc_off || !adapter->afu_desc_size) {
+	if (!adapter->native->afu_desc_off || !adapter->native->afu_desc_size) {
 		dev_err(&dev->dev, "ABORTING: VSEC shows no AFU descriptors\n");
 		return -EINVAL;
 	}
 
-	if (adapter->ps_size > p2_size(dev) - adapter->ps_off) {
+	if (adapter->ps_size > p2_size(dev) - adapter->native->ps_off) {
 		dev_err(&dev->dev, "ABORTING: Problem state size larger than "
 				   "available in BAR2: 0x%llx > 0x%llx\n",
-			 adapter->ps_size, p2_size(dev) - adapter->ps_off);
+			 adapter->ps_size, p2_size(dev) - adapter->native->ps_off);
 		return -EINVAL;
 	}
 
@@ -1103,6 +1112,7 @@ static void cxl_release_adapter(struct device *dev)
 
 	cxl_remove_adapter_nr(adapter);
 
+	kfree(adapter->native);
 	kfree(adapter);
 }
 
@@ -1199,6 +1209,12 @@ static struct cxl *cxl_init_adapter(struct pci_dev *dev)
 	if (!adapter)
 		return ERR_PTR(-ENOMEM);
 
+	adapter->native = kzalloc(sizeof(struct cxl_native), GFP_KERNEL);
+	if (!adapter->native) {
+		rc = -ENOMEM;
+		goto err_release;
+	}
+
 	/* Set defaults for parameters which need to persist over
 	 * configure/reconfigure
 	 */
@@ -1208,8 +1224,7 @@ static struct cxl *cxl_init_adapter(struct pci_dev *dev)
 	rc = cxl_configure_adapter(adapter, dev);
 	if (rc) {
 		pci_disable_device(dev);
-		cxl_release_adapter(&adapter->dev);
-		return ERR_PTR(rc);
+		goto err_release;
 	}
 
 	/* Don't care if this one fails: */
@@ -1235,6 +1250,10 @@ err_put1:
 	cxl_deconfigure_adapter(adapter);
 	device_unregister(&adapter->dev);
 	return ERR_PTR(rc);
+
+err_release:
+	cxl_release_adapter(&adapter->dev);
+	return ERR_PTR(rc);
 }
 
 static void cxl_remove_adapter(struct cxl *adapter)
diff --git a/drivers/misc/cxl/sysfs.c b/drivers/misc/cxl/sysfs.c
index 038af5d45145..454dacfb19ac 100644
--- a/drivers/misc/cxl/sysfs.c
+++ b/drivers/misc/cxl/sysfs.c
@@ -165,7 +165,7 @@ static ssize_t pp_mmio_off_show(struct device *device,
 {
 	struct cxl_afu *afu = to_afu_chardev_m(device);
 
-	return scnprintf(buf, PAGE_SIZE, "%llu\n", afu->pp_offset);
+	return scnprintf(buf, PAGE_SIZE, "%llu\n", afu->native->pp_offset);
 }
 
 static ssize_t pp_mmio_len_show(struct device *device,
diff --git a/drivers/misc/cxl/vphb.c b/drivers/misc/cxl/vphb.c
index cbd4331fb45c..e5f28dcbbda1 100644
--- a/drivers/misc/cxl/vphb.c
+++ b/drivers/misc/cxl/vphb.c
@@ -248,7 +248,7 @@ int cxl_pci_vphb_add(struct cxl_afu *afu)
 
 	/* Setup the PHB using arch provided callback */
 	phb->ops = &cxl_pcie_pci_ops;
-	phb->cfg_addr = afu->afu_desc_mmio + afu->crs_offset;
+	phb->cfg_addr = afu->native->afu_desc_mmio + afu->crs_offset;
 	phb->cfg_data = (void *)(u64)afu->crs_len;
 	phb->private_data = afu;
 	phb->controller_ops = cxl_pci_controller_ops;
@@ -278,7 +278,7 @@ void cxl_pci_vphb_reconfigure(struct cxl_afu *afu)
 	 * and remapped. We need to reflect this in the PHB's view of
 	 * the world.
 	 */
-	afu->phb->cfg_addr = afu->afu_desc_mmio + afu->crs_offset;
+	afu->phb->cfg_addr = afu->native->afu_desc_mmio + afu->crs_offset;
 }
 
 void cxl_pci_vphb_remove(struct cxl_afu *afu)
