ipv6: Remove un-used argument from ip6_dst_alloc()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit ad706862890171e02df1d7391b05599fb676ec18
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ad706862.failed

After 4b32b5ad31a6 ("ipv6: Stop rt6_info from using inet_peer's metrics"),
ip6_dst_alloc() does not need the 'table' argument.  This patch
cleans it up.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
CC: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ad706862890171e02df1d7391b05599fb676ec18)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/route.c
diff --cc net/ipv6/route.c
index e3cf3592b9d2,c95c3197c186..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -265,10 -316,9 +265,16 @@@ static const struct rt6_info ip6_blk_ho
  #endif
  
  /* allocate dst with ip6_dst_ops */
++<<<<<<< HEAD
 +static inline struct rt6_info *ip6_dst_alloc(struct net *net,
 +					     struct net_device *dev,
 +					     int flags,
 +					     struct fib6_table *table)
++=======
+ static struct rt6_info *__ip6_dst_alloc(struct net *net,
+ 					struct net_device *dev,
+ 					int flags)
++>>>>>>> ad7068628901 (ipv6: Remove un-used argument from ip6_dst_alloc())
  {
  	struct rt6_info *rt = dst_alloc(&net->ipv6.ip6_dst_ops, dev,
  					0, DST_OBSOLETE_FORCE_CHK, flags);
@@@ -282,6 -333,33 +288,36 @@@
  	return rt;
  }
  
++<<<<<<< HEAD
++=======
+ static struct rt6_info *ip6_dst_alloc(struct net *net,
+ 				      struct net_device *dev,
+ 				      int flags)
+ {
+ 	struct rt6_info *rt = __ip6_dst_alloc(net, dev, flags);
+ 
+ 	if (rt) {
+ 		rt->rt6i_pcpu = alloc_percpu_gfp(struct rt6_info *, GFP_ATOMIC);
+ 		if (rt->rt6i_pcpu) {
+ 			int cpu;
+ 
+ 			for_each_possible_cpu(cpu) {
+ 				struct rt6_info **p;
+ 
+ 				p = per_cpu_ptr(rt->rt6i_pcpu, cpu);
+ 				/* no one shares rt */
+ 				*p =  NULL;
+ 			}
+ 		} else {
+ 			dst_destroy((struct dst_entry *)rt);
+ 			return NULL;
+ 		}
+ 	}
+ 
+ 	return rt;
+ }
+ 
++>>>>>>> ad7068628901 (ipv6: Remove un-used argument from ip6_dst_alloc())
  static void ip6_dst_destroy(struct dst_entry *dst)
  {
  	struct rt6_info *rt = (struct rt6_info *)dst;
@@@ -887,27 -945,83 +923,81 @@@ static struct rt6_info *ip6_rt_cache_al
  	 *	Clone the route.
  	 */
  
 -	if (ort->rt6i_flags & (RTF_CACHE | RTF_PCPU))
 -		ort = (struct rt6_info *)ort->dst.from;
 +	rt = ip6_rt_copy(ort, daddr);
  
++<<<<<<< HEAD
 +	if (rt) {
 +		rt->rt6i_flags |= RTF_CACHE;
++=======
+ 	rt = __ip6_dst_alloc(dev_net(ort->dst.dev), ort->dst.dev, 0);
++>>>>>>> ad7068628901 (ipv6: Remove un-used argument from ip6_dst_alloc())
  
 -	if (!rt)
 -		return NULL;
 -
 -	ip6_rt_copy_init(rt, ort);
 -	rt->rt6i_flags |= RTF_CACHE;
 -	rt->rt6i_metric = 0;
 -	rt->dst.flags |= DST_HOST;
 -	rt->rt6i_dst.addr = *daddr;
 -	rt->rt6i_dst.plen = 128;
 -
 -	if (!rt6_is_gw_or_nonexthop(ort)) {
 -		if (ort->rt6i_dst.plen != 128 &&
 -		    ipv6_addr_equal(&ort->rt6i_dst.addr, daddr))
 -			rt->rt6i_flags |= RTF_ANYCAST;
 +		if (!rt6_is_gw_or_nonexthop(ort)) {
 +			if (ort->rt6i_dst.plen != 128 &&
 +			    ipv6_addr_equal(&ort->rt6i_dst.addr, daddr))
 +				rt->rt6i_flags |= RTF_ANYCAST;
  #ifdef CONFIG_IPV6_SUBTREES
 -		if (rt->rt6i_src.plen && saddr) {
 -			rt->rt6i_src.addr = *saddr;
 -			rt->rt6i_src.plen = 128;
 -		}
 +			if (rt->rt6i_src.plen && saddr) {
 +				rt->rt6i_src.addr = *saddr;
 +				rt->rt6i_src.plen = 128;
 +			}
  #endif
 +		}
  	}
  
  	return rt;
  }
  
++<<<<<<< HEAD
++=======
+ static struct rt6_info *ip6_rt_pcpu_alloc(struct rt6_info *rt)
+ {
+ 	struct rt6_info *pcpu_rt;
+ 
+ 	pcpu_rt = __ip6_dst_alloc(dev_net(rt->dst.dev),
+ 				  rt->dst.dev, rt->dst.flags);
+ 
+ 	if (!pcpu_rt)
+ 		return NULL;
+ 	ip6_rt_copy_init(pcpu_rt, rt);
+ 	pcpu_rt->rt6i_protocol = rt->rt6i_protocol;
+ 	pcpu_rt->rt6i_flags |= RTF_PCPU;
+ 	return pcpu_rt;
+ }
+ 
+ /* It should be called with read_lock_bh(&tb6_lock) acquired */
+ static struct rt6_info *rt6_get_pcpu_route(struct rt6_info *rt)
+ {
+ 	struct rt6_info *pcpu_rt, *prev, **p;
+ 
+ 	p = this_cpu_ptr(rt->rt6i_pcpu);
+ 	pcpu_rt = *p;
+ 
+ 	if (pcpu_rt)
+ 		goto done;
+ 
+ 	pcpu_rt = ip6_rt_pcpu_alloc(rt);
+ 	if (!pcpu_rt) {
+ 		struct net *net = dev_net(rt->dst.dev);
+ 
+ 		pcpu_rt = net->ipv6.ip6_null_entry;
+ 		goto done;
+ 	}
+ 
+ 	prev = cmpxchg(p, NULL, pcpu_rt);
+ 	if (prev) {
+ 		/* If someone did it before us, return prev instead */
+ 		dst_destroy(&pcpu_rt->dst);
+ 		pcpu_rt = prev;
+ 	}
+ 
+ done:
+ 	dst_hold(&pcpu_rt->dst);
+ 	rt6_dst_from_metrics_check(pcpu_rt);
+ 	return pcpu_rt;
+ }
+ 
++>>>>>>> ad7068628901 (ipv6: Remove un-used argument from ip6_dst_alloc())
  static struct rt6_info *ip6_pol_route(struct net *net, struct fib6_table *table, int oif,
  				      struct flowi6 *fl6, int flags)
  {
* Unmerged path net/ipv6/route.c
