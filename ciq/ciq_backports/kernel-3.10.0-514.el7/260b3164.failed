mmc: dw_mmc: use resource_size_t to store physical address

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Arnd Bergmann <arnd@arndb.de>
commit 260b31643691e8a58683a4ccc3bdf7abfd86f54a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/260b3164.failed

The dw_mmc driver stores the physical address of the MMIO registers
in a pointer, which requires the use of type casts, and is actually
broken if anyone ever has this device on a 32-bit SoC in registers
above 4GB. Gcc warns about this possibility when the driver is built
with ARM LPAE enabled:

mmc/host/dw_mmc.c: In function 'dw_mci_edmac_start_dma':
mmc/host/dw_mmc.c:702:17: warning: cast from pointer to integer of different size
  cfg.dst_addr = (dma_addr_t)(host->phy_regs + fifo_offset);
                 ^
mmc/host/dw_mmc-pltfm.c: In function 'dw_mci_pltfm_register':
mmc/host/dw_mmc-pltfm.c:63:19: warning: cast to pointer from integer of different size
  host->phy_regs = (void *)(regs->start);

This changes the code to use resource_size_t, which gets rid of the
warning, the bug and the useless casts.

	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 260b31643691e8a58683a4ccc3bdf7abfd86f54a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/dw_mmc-pltfm.c
#	drivers/mmc/host/dw_mmc.c
#	include/linux/mmc/dw_mmc.h
diff --cc drivers/mmc/host/dw_mmc-pltfm.c
index 37873f101cdb,81bdeeb05a4d..000000000000
--- a/drivers/mmc/host/dw_mmc-pltfm.c
+++ b/drivers/mmc/host/dw_mmc-pltfm.c
@@@ -47,6 -57,10 +47,13 @@@ int dw_mci_pltfm_register(struct platfo
  	host->dev = &pdev->dev;
  	host->irq_flags = 0;
  	host->pdata = pdev->dev.platform_data;
++<<<<<<< HEAD
++=======
+ 
+ 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	/* Get registers' physical base address */
+ 	host->phy_regs = regs->start;
++>>>>>>> 260b31643691 (mmc: dw_mmc: use resource_size_t to store physical address)
  	host->regs = devm_ioremap_resource(&pdev->dev, regs);
  	if (IS_ERR(host->regs))
  		return PTR_ERR(host->regs);
diff --cc drivers/mmc/host/dw_mmc.c
index bc4f99ee919c,fb204ee6ff89..000000000000
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@@ -445,10 -677,110 +445,115 @@@ static const struct dw_mci_dma_ops dw_m
  	.init = dw_mci_idmac_init,
  	.start = dw_mci_idmac_start_dma,
  	.stop = dw_mci_idmac_stop_dma,
++<<<<<<< HEAD
 +	.complete = dw_mci_idmac_complete_dma,
++=======
+ 	.complete = dw_mci_dmac_complete_dma,
+ 	.cleanup = dw_mci_dma_cleanup,
+ };
+ 
+ static void dw_mci_edmac_stop_dma(struct dw_mci *host)
+ {
+ 	dmaengine_terminate_all(host->dms->ch);
+ }
+ 
+ static int dw_mci_edmac_start_dma(struct dw_mci *host,
+ 					    unsigned int sg_len)
+ {
+ 	struct dma_slave_config cfg;
+ 	struct dma_async_tx_descriptor *desc = NULL;
+ 	struct scatterlist *sgl = host->data->sg;
+ 	const u32 mszs[] = {1, 4, 8, 16, 32, 64, 128, 256};
+ 	u32 sg_elems = host->data->sg_len;
+ 	u32 fifoth_val;
+ 	u32 fifo_offset = host->fifo_reg - host->regs;
+ 	int ret = 0;
+ 
+ 	/* Set external dma config: burst size, burst width */
+ 	cfg.dst_addr = host->phy_regs + fifo_offset;
+ 	cfg.src_addr = cfg.dst_addr;
+ 	cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+ 	cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+ 
+ 	/* Match burst msize with external dma config */
+ 	fifoth_val = mci_readl(host, FIFOTH);
+ 	cfg.dst_maxburst = mszs[(fifoth_val >> 28) & 0x7];
+ 	cfg.src_maxburst = cfg.dst_maxburst;
+ 
+ 	if (host->data->flags & MMC_DATA_WRITE)
+ 		cfg.direction = DMA_MEM_TO_DEV;
+ 	else
+ 		cfg.direction = DMA_DEV_TO_MEM;
+ 
+ 	ret = dmaengine_slave_config(host->dms->ch, &cfg);
+ 	if (ret) {
+ 		dev_err(host->dev, "Failed to config edmac.\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	desc = dmaengine_prep_slave_sg(host->dms->ch, sgl,
+ 				       sg_len, cfg.direction,
+ 				       DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+ 	if (!desc) {
+ 		dev_err(host->dev, "Can't prepare slave sg.\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	/* Set dw_mci_dmac_complete_dma as callback */
+ 	desc->callback = dw_mci_dmac_complete_dma;
+ 	desc->callback_param = (void *)host;
+ 	dmaengine_submit(desc);
+ 
+ 	/* Flush cache before write */
+ 	if (host->data->flags & MMC_DATA_WRITE)
+ 		dma_sync_sg_for_device(mmc_dev(host->cur_slot->mmc), sgl,
+ 				       sg_elems, DMA_TO_DEVICE);
+ 
+ 	dma_async_issue_pending(host->dms->ch);
+ 
+ 	return 0;
+ }
+ 
+ static int dw_mci_edmac_init(struct dw_mci *host)
+ {
+ 	/* Request external dma channel */
+ 	host->dms = kzalloc(sizeof(struct dw_mci_dma_slave), GFP_KERNEL);
+ 	if (!host->dms)
+ 		return -ENOMEM;
+ 
+ 	host->dms->ch = dma_request_slave_channel(host->dev, "rx-tx");
+ 	if (!host->dms->ch) {
+ 		dev_err(host->dev, "Failed to get external DMA channel.\n");
+ 		kfree(host->dms);
+ 		host->dms = NULL;
+ 		return -ENXIO;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void dw_mci_edmac_exit(struct dw_mci *host)
+ {
+ 	if (host->dms) {
+ 		if (host->dms->ch) {
+ 			dma_release_channel(host->dms->ch);
+ 			host->dms->ch = NULL;
+ 		}
+ 		kfree(host->dms);
+ 		host->dms = NULL;
+ 	}
+ }
+ 
+ static const struct dw_mci_dma_ops dw_mci_edmac_ops = {
+ 	.init = dw_mci_edmac_init,
+ 	.exit = dw_mci_edmac_exit,
+ 	.start = dw_mci_edmac_start_dma,
+ 	.stop = dw_mci_edmac_stop_dma,
+ 	.complete = dw_mci_dmac_complete_dma,
++>>>>>>> 260b31643691 (mmc: dw_mmc: use resource_size_t to store physical address)
  	.cleanup = dw_mci_dma_cleanup,
  };
 +#endif /* CONFIG_MMC_DW_IDMAC */
  
  static int dw_mci_pre_dma_transfer(struct dw_mci *host,
  				   struct mmc_data *data,
diff --cc include/linux/mmc/dw_mmc.h
index a2d9a022a8fd,7776afb0ffa5..000000000000
--- a/include/linux/mmc/dw_mmc.h
+++ b/include/linux/mmc/dw_mmc.h
@@@ -141,11 -166,14 +141,20 @@@ struct dw_mci 
  	dma_addr_t		sg_dma;
  	void			*sg_cpu;
  	const struct dw_mci_dma_ops	*dma_ops;
 -	/* For idmac */
 +#ifdef CONFIG_MMC_DW_IDMAC
  	unsigned int		ring_size;
++<<<<<<< HEAD
 +#else
 +	struct dw_mci_dma_data	*dma_data;
 +#endif
++=======
+ 
+ 	/* For edmac */
+ 	struct dw_mci_dma_slave *dms;
+ 	/* Registers's physical base address */
+ 	resource_size_t		phy_regs;
+ 
++>>>>>>> 260b31643691 (mmc: dw_mmc: use resource_size_t to store physical address)
  	u32			cmd_status;
  	u32			data_status;
  	u32			stop_cmdr;
* Unmerged path drivers/mmc/host/dw_mmc-pltfm.c
* Unmerged path drivers/mmc/host/dw_mmc.c
* Unmerged path include/linux/mmc/dw_mmc.h
