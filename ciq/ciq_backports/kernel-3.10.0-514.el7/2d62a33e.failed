hpsa: eliminate fake lun0 enclosures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Scott Teel <scott.teel@pmcs.com>
commit 2d62a33e05d471bef6b2e5478f57d05b9baded85
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2d62a33e.failed

We don't need to create fake enclosure devices at Lun0
in external target array configurations anymore.
This was done to support Pre-SCSI rev 5 controllers
that didn't suppoprt report luns commands, so the
SCSI layer had to scan targets. If there was no
LUN at LUN 0, then the target scan would stop, and
move to the next target.  Lun0 enclosure device
was added to prevent sparsely-numbered LUNs from
being missed.

	Reviewed-by: Scott Teel <scott.teel@pmcs.com>
	Reviewed-by: Justin Lindley <justin.lindley@pmcs.com>
	Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
	Reviewed-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Signed-off-by: Don Brace <don.brace@pmcs.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 2d62a33e05d471bef6b2e5478f57d05b9baded85)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.c
diff --cc drivers/scsi/hpsa.c
index ef01b3ac8b79,c843dd288a4e..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -3483,60 -3571,6 +3483,63 @@@ static void figure_bus_target_lun(struc
  				0, lunid & 0x3fff);
  }
  
++<<<<<<< HEAD
 +/*
 + * If there is no lun 0 on a target, linux won't find any devices.
 + * For the external targets (arrays), we have to manually detect the enclosure
 + * which is at lun zero, as CCISS_REPORT_PHYSICAL_LUNS doesn't report
 + * it for some reason.  *tmpdevice is the target we're adding,
 + * this_device is a pointer into the current element of currentsd[]
 + * that we're building up in update_scsi_devices(), below.
 + * lunzerobits is a bitmap that tracks which targets already have a
 + * lun 0 assigned.
 + * Returns 1 if an enclosure was added, 0 if not.
 + */
 +static int add_ext_target_dev(struct ctlr_info *h,
 +	struct hpsa_scsi_dev_t *tmpdevice,
 +	struct hpsa_scsi_dev_t *this_device, u8 *lunaddrbytes,
 +	unsigned long lunzerobits[], int *n_ext_target_devs)
 +{
 +	unsigned char scsi3addr[8];
 +
 +	if (test_bit(tmpdevice->target, lunzerobits))
 +		return 0; /* There is already a lun 0 on this target. */
 +
 +	if (!is_logical_dev_addr_mode(lunaddrbytes))
 +		return 0; /* It's the logical targets that may lack lun 0. */
 +
 +	if (!is_ext_target(h, tmpdevice))
 +		return 0; /* Only external target devices have this problem. */
 +
 +	if (tmpdevice->lun == 0) /* if lun is 0, then we have a lun 0. */
 +		return 0;
 +
 +	memset(scsi3addr, 0, 8);
 +	scsi3addr[3] = tmpdevice->target;
 +	if (is_hba_lunid(scsi3addr))
 +		return 0; /* Don't add the RAID controller here. */
 +
 +	if (is_scsi_rev_5(h))
 +		return 0; /* p1210m doesn't need to do this. */
 +
 +	if (*n_ext_target_devs >= MAX_EXT_TARGETS) {
 +		dev_warn(&h->pdev->dev, "Maximum number of external "
 +			"target devices exceeded.  Check your hardware "
 +			"configuration.");
 +		return 0;
 +	}
 +
 +	if (hpsa_update_device_info(h, scsi3addr, this_device, NULL))
 +		return 0;
 +	(*n_ext_target_devs)++;
 +	hpsa_set_bus_target_lun(this_device,
 +				tmpdevice->bus, tmpdevice->target, 0);
 +	hpsa_update_device_supports_aborts(h, this_device, scsi3addr);
 +	set_bit(tmpdevice->target, lunzerobits);
 +	return 1;
 +}
++=======
++>>>>>>> 2d62a33e05d4 (hpsa: eliminate fake lun0 enclosures)
  
  /*
   * Get address of physical disk used for an ioaccel2 mode command:
@@@ -3792,33 -3898,17 +3795,19 @@@ static void hpsa_update_scsi_devices(st
  		hpsa_update_device_supports_aborts(h, tmpdevice, lunaddrbytes);
  		this_device = currentsd[ncurrent];
  
- 		/*
- 		 * For external target devices, we have to insert a LUN 0 which
- 		 * doesn't show up in CCISS_REPORT_PHYSICAL data, but there
- 		 * is nonetheless an enclosure device there.  We have to
- 		 * present that otherwise linux won't find anything if
- 		 * there is no lun 0.
- 		 */
- 		if (add_ext_target_dev(h, tmpdevice, this_device,
- 				lunaddrbytes, lunzerobits,
- 				&n_ext_target_devs)) {
- 			ncurrent++;
- 			this_device = currentsd[ncurrent];
- 		}
- 
  		*this_device = *tmpdevice;
 -		this_device->physical_device = physical_device;
  
 -		/*
 -		 * Expose all devices except for physical devices that
 -		 * are masked.
 -		 */
 -		if (MASKED_DEVICE(lunaddrbytes) && this_device->physical_device)
 -			this_device->expose_device = 0;
 -		else
 -			this_device->expose_device = 1;
 +		/* do not expose masked devices */
 +		if (MASKED_DEVICE(lunaddrbytes) &&
 +			i < nphysicals + (raid_ctlr_position == 0)) {
 +			if (h->hba_mode_enabled)
 +				dev_warn(&h->pdev->dev,
 +					"Masked physical device detected\n");
 +			this_device->expose_state = HPSA_DO_NOT_EXPOSE;
 +		} else {
 +			this_device->expose_state =
 +					HPSA_SG_ATTACH | HPSA_ULD_ATTACH;
 +		}
  
  		switch (this_device->devtype) {
  		case TYPE_ROM:
* Unmerged path drivers/scsi/hpsa.c
