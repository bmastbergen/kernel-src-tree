openvswitch: fix hangup on vxlan/gre/geneve device deletion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Paolo Abeni <pabeni@redhat.com>
commit 13175303024c8f4cd09e51079a8fcbbe572111ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/13175303.failed

Each openvswitch tunnel vport (vxlan,gre,geneve) holds a reference
to the underlying tunnel device, but never released it when such
device is deleted.
Deleting the underlying device via the ip tool cause the kernel to
hangup in the netdev_wait_allrefs() loop.
This commit ensure that on device unregistration dp_detach_port_notify()
is called for all vports that hold the device reference, properly
releasing it.

Fixes: 614732eaa12d ("openvswitch: Use regular VXLAN net_device device")
Fixes: b2acd1dc3949 ("openvswitch: Use regular GRE net_device instead of vport")
Fixes: 6b001e682e90 ("openvswitch: Use Geneve device.")
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Acked-by: Flavio Leitner <fbl@sysclose.org>
	Acked-by: Pravin B Shelar <pshelar@nicira.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 13175303024c8f4cd09e51079a8fcbbe572111ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/dp_notify.c
#	net/openvswitch/vport-netdev.c
diff --cc net/openvswitch/dp_notify.c
index aad5eae29198,653d073bae45..000000000000
--- a/net/openvswitch/dp_notify.c
+++ b/net/openvswitch/dp_notify.c
@@@ -58,13 -58,10 +58,17 @@@ void ovs_dp_notify_wq(struct work_struc
  			struct hlist_node *n;
  
  			hlist_for_each_entry_safe(vport, n, &dp->ports[i], dp_hash_node) {
++<<<<<<< HEAD
 +				struct netdev_vport *netdev_vport;
 +
 +				if (vport->ops->type != OVS_VPORT_TYPE_NETDEV)
++=======
+ 				if (vport->ops->type == OVS_VPORT_TYPE_INTERNAL)
++>>>>>>> 13175303024c (openvswitch: fix hangup on vxlan/gre/geneve device deletion)
  					continue;
  
 -				if (!(vport->dev->priv_flags & IFF_OVS_DATAPATH))
 +				netdev_vport = netdev_vport_priv(vport);
 +				if (!(netdev_vport->dev->priv_flags & IFF_OVS_DATAPATH))
  					dp_detach_port_notify(vport);
  			}
  		}
diff --cc net/openvswitch/vport-netdev.c
index 6c7a9d49beb5,6b0190b987ec..000000000000
--- a/net/openvswitch/vport-netdev.c
+++ b/net/openvswitch/vport-netdev.c
@@@ -174,48 -171,28 +174,66 @@@ static void netdev_destroy(struct vpor
  		ovs_netdev_detach_dev(vport);
  	rtnl_unlock();
  
 -	call_rcu(&vport->rcu, vport_netdev_free);
 +	call_rcu(&netdev_vport->rcu, free_port_rcu);
 +}
 +
 +const char *ovs_netdev_get_name(const struct vport *vport)
 +{
++<<<<<<< HEAD
 +	const struct netdev_vport *netdev_vport = netdev_vport_priv(vport);
 +	return netdev_vport->dev->name;
  }
  
 -void ovs_netdev_tunnel_destroy(struct vport *vport)
 +static unsigned int packet_length(const struct sk_buff *skb)
  {
 +	unsigned int length = skb->len - ETH_HLEN;
 +
 +	if (skb->protocol == htons(ETH_P_8021Q))
 +		length -= VLAN_HLEN;
 +
 +	return length;
 +}
 +
 +static int netdev_send(struct vport *vport, struct sk_buff *skb)
 +{
 +	struct netdev_vport *netdev_vport = netdev_vport_priv(vport);
 +	int mtu = netdev_vport->dev->mtu;
 +	int len;
 +
 +	if (unlikely(packet_length(skb) > mtu && !skb_is_gso(skb))) {
 +		net_warn_ratelimited("%s: dropped over-mtu packet: %d > %d\n",
 +				     netdev_vport->dev->name,
 +				     packet_length(skb), mtu);
 +		goto drop;
 +	}
 +
 +	skb->dev = netdev_vport->dev;
 +	len = skb->len;
 +	dev_queue_xmit(skb);
 +
 +	return len;
 +
 +drop:
 +	kfree_skb(skb);
 +	return 0;
++=======
+ 	rtnl_lock();
+ 	if (vport->dev->priv_flags & IFF_OVS_DATAPATH)
+ 		ovs_netdev_detach_dev(vport);
+ 
+ 	/* We can be invoked by both explicit vport deletion and
+ 	 * underlying netdev deregistration; delete the link only
+ 	 * if it's not already shutting down.
+ 	 */
+ 	if (vport->dev->reg_state == NETREG_REGISTERED)
+ 		rtnl_delete_link(vport->dev);
+ 	dev_put(vport->dev);
+ 	vport->dev = NULL;
+ 	rtnl_unlock();
+ 
+ 	call_rcu(&vport->rcu, vport_netdev_free);
++>>>>>>> 13175303024c (openvswitch: fix hangup on vxlan/gre/geneve device deletion)
  }
 -EXPORT_SYMBOL_GPL(ovs_netdev_tunnel_destroy);
  
  /* Returns null if this device is not attached to a datapath. */
  struct vport *ovs_netdev_get_vport(struct net_device *dev)
* Unmerged path net/openvswitch/dp_notify.c
* Unmerged path net/openvswitch/vport-netdev.c
