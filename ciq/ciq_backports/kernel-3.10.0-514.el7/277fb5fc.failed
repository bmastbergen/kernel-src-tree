btrfs: use __GFP_NOFAIL in alloc_btrfs_bio

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Michal Hocko <mhocko@suse.com>
commit 277fb5fc177dc4674ef6151a7697f5396bbdff11
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/277fb5fc.failed

alloc_btrfs_bio relies on GFP_NOFS allocation when committing the
transaction but this allocation context is rather weak wrt. reclaim
capabilities. The page allocator currently tries hard to not fail these
allocations if they are small (<=PAGE_ALLOC_COSTLY_ORDER) but it can
still fail if the _current_ process is the OOM killer victim. Moreover
there is an attempt to move away from the default no-fail behavior and
allow these allocation to fail more eagerly. This would lead to:

[   37.928625] kernel BUG at fs/btrfs/extent_io.c:4045

which is clearly undesirable and the nofail behavior should be explicit
if the allocation failure cannot be tolerated.

	Signed-off-by: Michal Hocko <mhocko@suse.com>
	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit 277fb5fc177dc4674ef6151a7697f5396bbdff11)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/volumes.c
diff --cc fs/btrfs/volumes.c
index 5fef3a18eec2,53a38075911e..000000000000
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@@ -5071,6 -5068,42 +5071,45 @@@ static void sort_parity_stripes(struct 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static struct btrfs_bio *alloc_btrfs_bio(int total_stripes, int real_stripes)
+ {
+ 	struct btrfs_bio *bbio = kzalloc(
+ 		 /* the size of the btrfs_bio */
+ 		sizeof(struct btrfs_bio) +
+ 		/* plus the variable array for the stripes */
+ 		sizeof(struct btrfs_bio_stripe) * (total_stripes) +
+ 		/* plus the variable array for the tgt dev */
+ 		sizeof(int) * (real_stripes) +
+ 		/*
+ 		 * plus the raid_map, which includes both the tgt dev
+ 		 * and the stripes
+ 		 */
+ 		sizeof(u64) * (total_stripes),
+ 		GFP_NOFS|__GFP_NOFAIL);
+ 
+ 	atomic_set(&bbio->error, 0);
+ 	atomic_set(&bbio->refs, 1);
+ 
+ 	return bbio;
+ }
+ 
+ void btrfs_get_bbio(struct btrfs_bio *bbio)
+ {
+ 	WARN_ON(!atomic_read(&bbio->refs));
+ 	atomic_inc(&bbio->refs);
+ }
+ 
+ void btrfs_put_bbio(struct btrfs_bio *bbio)
+ {
+ 	if (!bbio)
+ 		return;
+ 	if (atomic_dec_and_test(&bbio->refs))
+ 		kfree(bbio);
+ }
+ 
++>>>>>>> 277fb5fc177d (btrfs: use __GFP_NOFAIL in alloc_btrfs_bio)
  static int __btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,
  			     u64 logical, u64 *length,
  			     struct btrfs_bio **bbio_ret,
* Unmerged path fs/btrfs/volumes.c
