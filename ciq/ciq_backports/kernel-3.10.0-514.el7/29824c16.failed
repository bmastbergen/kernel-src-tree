USB: host: Rename ehci-s5p to ehci-exynos

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [usb] host: Rename ehci-s5p to ehci-exynos (Don Zickus) [1303209]
Rebuild_FUZZ: 93.51%
commit-author Jingoo Han <jg1.han@samsung.com>
commit 29824c167bead38986d5e8d33008680c62478777
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/29824c16.failed

Currently, Samsung is using 'EXYNOS' as the name of Samsung SoCs.
Thus, ehci-exynos is preferred than ehci-s5p.

	Signed-off-by: Jingoo Han <jg1.han@samsung.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 29824c167bead38986d5e8d33008680c62478777)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/ehci-exynos.c
diff --cc drivers/usb/host/ehci-exynos.c
index c3f02d63c08f,016352e0f5a7..000000000000
--- a/drivers/usb/host/ehci-exynos.c
+++ b/drivers/usb/host/ehci-exynos.c
@@@ -47,12 -46,11 +47,12 @@@ struct exynos_ehci_hcd 
  	struct clk *clk;
  	struct usb_phy *phy;
  	struct usb_otg *otg;
 +	struct s5p_ehci_platdata *pdata;
  };
  
- #define to_s5p_ehci(hcd)      (struct s5p_ehci_hcd *)(hcd_to_ehci(hcd)->priv)
+ #define to_exynos_ehci(hcd) (struct exynos_ehci_hcd *)(hcd_to_ehci(hcd)->priv)
  
- static void s5p_setup_vbus_gpio(struct platform_device *pdev)
+ static void exynos_setup_vbus_gpio(struct platform_device *pdev)
  {
  	struct device *dev = &pdev->dev;
  	int err;
@@@ -71,10 -69,9 +71,14 @@@
  		dev_err(dev, "can't request ehci vbus gpio %d", gpio);
  }
  
- static int s5p_ehci_probe(struct platform_device *pdev)
+ static int exynos_ehci_probe(struct platform_device *pdev)
  {
++<<<<<<< HEAD:drivers/usb/host/ehci-s5p.c
 +	struct s5p_ehci_platdata *pdata = pdev->dev.platform_data;
 +	struct s5p_ehci_hcd *s5p_ehci;
++=======
+ 	struct exynos_ehci_hcd *exynos_ehci;
++>>>>>>> 29824c167bea (USB: host: Rename ehci-s5p to ehci-exynos):drivers/usb/host/ehci-exynos.c
  	struct usb_hcd *hcd;
  	struct ehci_hcd *ehci;
  	struct resource *res;
@@@ -100,27 -97,29 +104,42 @@@
  		dev_err(&pdev->dev, "Unable to create HCD\n");
  		return -ENOMEM;
  	}
++<<<<<<< HEAD:drivers/usb/host/ehci-s5p.c
 +	s5p_ehci = to_s5p_ehci(hcd);
++=======
+ 	exynos_ehci = to_exynos_ehci(hcd);
+ 
+ 	if (of_device_is_compatible(pdev->dev.of_node,
+ 					"samsung,exynos5440-ehci"))
+ 		goto skip_phy;
+ 
++>>>>>>> 29824c167bea (USB: host: Rename ehci-s5p to ehci-exynos):drivers/usb/host/ehci-exynos.c
  	phy = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);
  	if (IS_ERR(phy)) {
 -		usb_put_hcd(hcd);
 -		dev_warn(&pdev->dev, "no platform data or transceiver defined\n");
 -		return -EPROBE_DEFER;
 +		/* Fallback to pdata */
 +		if (!pdata) {
 +			usb_put_hcd(hcd);
 +			dev_warn(&pdev->dev, "no platform data or transceiver defined\n");
 +			return -EPROBE_DEFER;
 +		} else {
 +			s5p_ehci->pdata = pdata;
 +		}
  	} else {
- 		s5p_ehci->phy = phy;
- 		s5p_ehci->otg = phy->otg;
+ 		exynos_ehci->phy = phy;
+ 		exynos_ehci->otg = phy->otg;
  	}
  
++<<<<<<< HEAD:drivers/usb/host/ehci-s5p.c
 +	s5p_ehci->clk = devm_clk_get(&pdev->dev, "usbhost");
++=======
+ skip_phy:
  
- 	if (IS_ERR(s5p_ehci->clk)) {
+ 	exynos_ehci->clk = devm_clk_get(&pdev->dev, "usbhost");
++>>>>>>> 29824c167bea (USB: host: Rename ehci-s5p to ehci-exynos):drivers/usb/host/ehci-exynos.c
+ 
+ 	if (IS_ERR(exynos_ehci->clk)) {
  		dev_err(&pdev->dev, "Failed to get usbhost clock\n");
- 		err = PTR_ERR(s5p_ehci->clk);
+ 		err = PTR_ERR(exynos_ehci->clk);
  		goto fail_clk;
  	}
  
@@@ -151,13 -150,11 +170,18 @@@
  		goto fail_io;
  	}
  
- 	if (s5p_ehci->otg)
- 		s5p_ehci->otg->set_host(s5p_ehci->otg, &hcd->self);
+ 	if (exynos_ehci->otg)
+ 		exynos_ehci->otg->set_host(exynos_ehci->otg, &hcd->self);
  
++<<<<<<< HEAD:drivers/usb/host/ehci-s5p.c
 +	if (s5p_ehci->phy)
 +		usb_phy_init(s5p_ehci->phy);
 +	else if (s5p_ehci->pdata->phy_init)
 +		s5p_ehci->pdata->phy_init(pdev, USB_PHY_TYPE_HOST);
++=======
+ 	if (exynos_ehci->phy)
+ 		usb_phy_init(exynos_ehci->phy);
++>>>>>>> 29824c167bea (USB: host: Rename ehci-s5p to ehci-exynos):drivers/usb/host/ehci-exynos.c
  
  	ehci = hcd_to_ehci(hcd);
  	ehci->caps = hcd->regs;
@@@ -176,12 -173,10 +200,17 @@@
  	return 0;
  
  fail_add_hcd:
++<<<<<<< HEAD:drivers/usb/host/ehci-s5p.c
 +	if (s5p_ehci->phy)
 +		usb_phy_shutdown(s5p_ehci->phy);
 +	else if (s5p_ehci->pdata->phy_exit)
 +		s5p_ehci->pdata->phy_exit(pdev, USB_PHY_TYPE_HOST);
++=======
+ 	if (exynos_ehci->phy)
+ 		usb_phy_shutdown(exynos_ehci->phy);
++>>>>>>> 29824c167bea (USB: host: Rename ehci-s5p to ehci-exynos):drivers/usb/host/ehci-exynos.c
  fail_io:
- 	clk_disable_unprepare(s5p_ehci->clk);
+ 	clk_disable_unprepare(exynos_ehci->clk);
  fail_clk:
  	usb_put_hcd(hcd);
  	return err;
@@@ -194,71 -189,53 +223,94 @@@ static int exynos_ehci_remove(struct pl
  
  	usb_remove_hcd(hcd);
  
- 	if (s5p_ehci->otg)
- 		s5p_ehci->otg->set_host(s5p_ehci->otg, &hcd->self);
+ 	if (exynos_ehci->otg)
+ 		exynos_ehci->otg->set_host(exynos_ehci->otg, &hcd->self);
  
++<<<<<<< HEAD:drivers/usb/host/ehci-s5p.c
 +	if (s5p_ehci->phy)
 +		usb_phy_shutdown(s5p_ehci->phy);
 +	else if (s5p_ehci->pdata->phy_exit)
 +		s5p_ehci->pdata->phy_exit(pdev, USB_PHY_TYPE_HOST);
++=======
+ 	if (exynos_ehci->phy)
+ 		usb_phy_shutdown(exynos_ehci->phy);
++>>>>>>> 29824c167bea (USB: host: Rename ehci-s5p to ehci-exynos):drivers/usb/host/ehci-exynos.c
  
- 	clk_disable_unprepare(s5p_ehci->clk);
+ 	clk_disable_unprepare(exynos_ehci->clk);
  
  	usb_put_hcd(hcd);
  
  	return 0;
  }
  
 +static void s5p_ehci_shutdown(struct platform_device *pdev)
 +{
 +	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 +
 +	if (hcd->driver->shutdown)
 +		hcd->driver->shutdown(hcd);
 +}
 +
  #ifdef CONFIG_PM
- static int s5p_ehci_suspend(struct device *dev)
+ static int exynos_ehci_suspend(struct device *dev)
  {
  	struct usb_hcd *hcd = dev_get_drvdata(dev);
++<<<<<<< HEAD:drivers/usb/host/ehci-s5p.c
 +	struct s5p_ehci_hcd *s5p_ehci = to_s5p_ehci(hcd);
 +	struct platform_device *pdev = to_platform_device(dev);
++=======
+ 	struct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);
++>>>>>>> 29824c167bea (USB: host: Rename ehci-s5p to ehci-exynos):drivers/usb/host/ehci-exynos.c
  
  	bool do_wakeup = device_may_wakeup(dev);
  	int rc;
  
  	rc = ehci_suspend(hcd, do_wakeup);
 +	if (rc)
 +		return rc;
  
- 	if (s5p_ehci->otg)
- 		s5p_ehci->otg->set_host(s5p_ehci->otg, &hcd->self);
+ 	if (exynos_ehci->otg)
+ 		exynos_ehci->otg->set_host(exynos_ehci->otg, &hcd->self);
  
++<<<<<<< HEAD:drivers/usb/host/ehci-s5p.c
 +	if (s5p_ehci->phy)
 +		usb_phy_shutdown(s5p_ehci->phy);
 +	else if (s5p_ehci->pdata->phy_exit)
 +		s5p_ehci->pdata->phy_exit(pdev, USB_PHY_TYPE_HOST);
++=======
+ 	if (exynos_ehci->phy)
+ 		usb_phy_shutdown(exynos_ehci->phy);
++>>>>>>> 29824c167bea (USB: host: Rename ehci-s5p to ehci-exynos):drivers/usb/host/ehci-exynos.c
  
- 	clk_disable_unprepare(s5p_ehci->clk);
+ 	clk_disable_unprepare(exynos_ehci->clk);
  
  	return rc;
  }
  
- static int s5p_ehci_resume(struct device *dev)
+ static int exynos_ehci_resume(struct device *dev)
  {
  	struct usb_hcd *hcd = dev_get_drvdata(dev);
++<<<<<<< HEAD:drivers/usb/host/ehci-s5p.c
 +	struct  s5p_ehci_hcd *s5p_ehci = to_s5p_ehci(hcd);
 +	struct platform_device *pdev = to_platform_device(dev);
++=======
+ 	struct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);
++>>>>>>> 29824c167bea (USB: host: Rename ehci-s5p to ehci-exynos):drivers/usb/host/ehci-exynos.c
  
- 	clk_prepare_enable(s5p_ehci->clk);
+ 	clk_prepare_enable(exynos_ehci->clk);
  
- 	if (s5p_ehci->otg)
- 		s5p_ehci->otg->set_host(s5p_ehci->otg, &hcd->self);
+ 	if (exynos_ehci->otg)
+ 		exynos_ehci->otg->set_host(exynos_ehci->otg, &hcd->self);
  
++<<<<<<< HEAD:drivers/usb/host/ehci-s5p.c
 +	if (s5p_ehci->phy)
 +		usb_phy_init(s5p_ehci->phy);
 +	else if (s5p_ehci->pdata->phy_init)
 +		s5p_ehci->pdata->phy_init(pdev, USB_PHY_TYPE_HOST);
++=======
+ 	if (exynos_ehci->phy)
+ 		usb_phy_init(exynos_ehci->phy);
++>>>>>>> 29824c167bea (USB: host: Rename ehci-s5p to ehci-exynos):drivers/usb/host/ehci-exynos.c
  
  	/* DMA burst Enable */
  	writel(EHCI_INSNREG00_ENABLE_DMA_BURST, EHCI_INSNREG00(hcd->regs));
@@@ -284,14 -262,14 +336,21 @@@ static const struct of_device_id exynos
  MODULE_DEVICE_TABLE(of, exynos_ehci_match);
  #endif
  
++<<<<<<< HEAD:drivers/usb/host/ehci-s5p.c
 +static struct platform_driver s5p_ehci_driver = {
 +	.probe		= s5p_ehci_probe,
 +	.remove		= s5p_ehci_remove,
 +	.shutdown	= s5p_ehci_shutdown,
++=======
+ static struct platform_driver exynos_ehci_driver = {
+ 	.probe		= exynos_ehci_probe,
+ 	.remove		= exynos_ehci_remove,
+ 	.shutdown	= usb_hcd_platform_shutdown,
++>>>>>>> 29824c167bea (USB: host: Rename ehci-s5p to ehci-exynos):drivers/usb/host/ehci-exynos.c
  	.driver = {
- 		.name	= "s5p-ehci",
+ 		.name	= "exynos-ehci",
  		.owner	= THIS_MODULE,
- 		.pm	= &s5p_ehci_pm_ops,
+ 		.pm	= &exynos_ehci_pm_ops,
  		.of_match_table = of_match_ptr(exynos_ehci_match),
  	}
  };
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 14e3c49416bf..b1b0f6691008 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -208,12 +208,11 @@ config USB_EHCI_SH
 	  Enables support for the on-chip EHCI controller on the SuperH.
 	  If you use the PCI EHCI controller, this option is not necessary.
 
-config USB_EHCI_S5P
+config USB_EHCI_EXYNOS
        tristate "EHCI support for Samsung S5P/EXYNOS SoC Series"
        depends on PLAT_S5P
        help
-	Enable support for the Samsung S5Pxxxx and Exynos3/4/5 SOC's
-	on-chip EHCI controller.
+	Enable support for the Samsung Exynos SOC's on-chip EHCI controller.
 
 config USB_EHCI_MV
 	bool "EHCI support for Marvell PXA/MMP USB controller"
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 602b80e40777..e080330ce6c1 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -32,7 +32,7 @@ obj-$(CONFIG_USB_EHCI_MXC)	+= ehci-mxc.o
 obj-$(CONFIG_USB_EHCI_HCD_OMAP)	+= ehci-omap.o
 obj-$(CONFIG_USB_EHCI_HCD_ORION)	+= ehci-orion.o
 obj-$(CONFIG_USB_EHCI_HCD_SPEAR)	+= ehci-spear.o
-obj-$(CONFIG_USB_EHCI_S5P)	+= ehci-s5p.o
+obj-$(CONFIG_USB_EHCI_EXYNOS)	+= ehci-exynos.o
 obj-$(CONFIG_USB_EHCI_HCD_AT91) += ehci-atmel.o
 obj-$(CONFIG_USB_EHCI_MSM)	+= ehci-msm.o
 
* Unmerged path drivers/usb/host/ehci-exynos.c
diff --git a/drivers/usb/host/ehci-s5p.c b/drivers/usb/host/ehci-s5p.c
deleted file mode 100644
index c3f02d63c08f..000000000000
--- a/drivers/usb/host/ehci-s5p.c
+++ /dev/null
@@ -1,323 +0,0 @@
-/*
- * SAMSUNG S5P USB HOST EHCI Controller
- *
- * Copyright (C) 2011 Samsung Electronics Co.Ltd
- * Author: Jingoo Han <jg1.han@samsung.com>
- * Author: Joonyoung Shim <jy0922.shim@samsung.com>
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- *
- */
-
-#include <linux/clk.h>
-#include <linux/dma-mapping.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/of_gpio.h>
-#include <linux/platform_device.h>
-#include <linux/platform_data/usb-ehci-s5p.h>
-#include <linux/usb/phy.h>
-#include <linux/usb/samsung_usb_phy.h>
-#include <linux/usb.h>
-#include <linux/usb/hcd.h>
-#include <linux/usb/otg.h>
-
-#include "ehci.h"
-
-#define DRIVER_DESC "EHCI s5p driver"
-
-#define EHCI_INSNREG00(base)			(base + 0x90)
-#define EHCI_INSNREG00_ENA_INCR16		(0x1 << 25)
-#define EHCI_INSNREG00_ENA_INCR8		(0x1 << 24)
-#define EHCI_INSNREG00_ENA_INCR4		(0x1 << 23)
-#define EHCI_INSNREG00_ENA_INCRX_ALIGN		(0x1 << 22)
-#define EHCI_INSNREG00_ENABLE_DMA_BURST	\
-	(EHCI_INSNREG00_ENA_INCR16 | EHCI_INSNREG00_ENA_INCR8 |	\
-	 EHCI_INSNREG00_ENA_INCR4 | EHCI_INSNREG00_ENA_INCRX_ALIGN)
-
-static const char hcd_name[] = "ehci-s5p";
-static struct hc_driver __read_mostly s5p_ehci_hc_driver;
-
-struct s5p_ehci_hcd {
-	struct clk *clk;
-	struct usb_phy *phy;
-	struct usb_otg *otg;
-	struct s5p_ehci_platdata *pdata;
-};
-
-#define to_s5p_ehci(hcd)      (struct s5p_ehci_hcd *)(hcd_to_ehci(hcd)->priv)
-
-static void s5p_setup_vbus_gpio(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	int err;
-	int gpio;
-
-	if (!dev->of_node)
-		return;
-
-	gpio = of_get_named_gpio(dev->of_node, "samsung,vbus-gpio", 0);
-	if (!gpio_is_valid(gpio))
-		return;
-
-	err = devm_gpio_request_one(dev, gpio, GPIOF_OUT_INIT_HIGH,
-				    "ehci_vbus_gpio");
-	if (err)
-		dev_err(dev, "can't request ehci vbus gpio %d", gpio);
-}
-
-static int s5p_ehci_probe(struct platform_device *pdev)
-{
-	struct s5p_ehci_platdata *pdata = pdev->dev.platform_data;
-	struct s5p_ehci_hcd *s5p_ehci;
-	struct usb_hcd *hcd;
-	struct ehci_hcd *ehci;
-	struct resource *res;
-	struct usb_phy *phy;
-	int irq;
-	int err;
-
-	/*
-	 * Right now device-tree probed devices don't get dma_mask set.
-	 * Since shared usb code relies on it, set it here for now.
-	 * Once we move to full device tree support this will vanish off.
-	 */
-	if (!pdev->dev.dma_mask)
-		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
-	if (!pdev->dev.coherent_dma_mask)
-		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
-
-	s5p_setup_vbus_gpio(pdev);
-
-	hcd = usb_create_hcd(&s5p_ehci_hc_driver,
-			     &pdev->dev, dev_name(&pdev->dev));
-	if (!hcd) {
-		dev_err(&pdev->dev, "Unable to create HCD\n");
-		return -ENOMEM;
-	}
-	s5p_ehci = to_s5p_ehci(hcd);
-	phy = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);
-	if (IS_ERR(phy)) {
-		/* Fallback to pdata */
-		if (!pdata) {
-			usb_put_hcd(hcd);
-			dev_warn(&pdev->dev, "no platform data or transceiver defined\n");
-			return -EPROBE_DEFER;
-		} else {
-			s5p_ehci->pdata = pdata;
-		}
-	} else {
-		s5p_ehci->phy = phy;
-		s5p_ehci->otg = phy->otg;
-	}
-
-	s5p_ehci->clk = devm_clk_get(&pdev->dev, "usbhost");
-
-	if (IS_ERR(s5p_ehci->clk)) {
-		dev_err(&pdev->dev, "Failed to get usbhost clock\n");
-		err = PTR_ERR(s5p_ehci->clk);
-		goto fail_clk;
-	}
-
-	err = clk_prepare_enable(s5p_ehci->clk);
-	if (err)
-		goto fail_clk;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "Failed to get I/O memory\n");
-		err = -ENXIO;
-		goto fail_io;
-	}
-
-	hcd->rsrc_start = res->start;
-	hcd->rsrc_len = resource_size(res);
-	hcd->regs = devm_ioremap(&pdev->dev, res->start, hcd->rsrc_len);
-	if (!hcd->regs) {
-		dev_err(&pdev->dev, "Failed to remap I/O memory\n");
-		err = -ENOMEM;
-		goto fail_io;
-	}
-
-	irq = platform_get_irq(pdev, 0);
-	if (!irq) {
-		dev_err(&pdev->dev, "Failed to get IRQ\n");
-		err = -ENODEV;
-		goto fail_io;
-	}
-
-	if (s5p_ehci->otg)
-		s5p_ehci->otg->set_host(s5p_ehci->otg, &hcd->self);
-
-	if (s5p_ehci->phy)
-		usb_phy_init(s5p_ehci->phy);
-	else if (s5p_ehci->pdata->phy_init)
-		s5p_ehci->pdata->phy_init(pdev, USB_PHY_TYPE_HOST);
-
-	ehci = hcd_to_ehci(hcd);
-	ehci->caps = hcd->regs;
-
-	/* DMA burst Enable */
-	writel(EHCI_INSNREG00_ENABLE_DMA_BURST, EHCI_INSNREG00(hcd->regs));
-
-	err = usb_add_hcd(hcd, irq, IRQF_SHARED);
-	if (err) {
-		dev_err(&pdev->dev, "Failed to add USB HCD\n");
-		goto fail_add_hcd;
-	}
-
-	platform_set_drvdata(pdev, hcd);
-
-	return 0;
-
-fail_add_hcd:
-	if (s5p_ehci->phy)
-		usb_phy_shutdown(s5p_ehci->phy);
-	else if (s5p_ehci->pdata->phy_exit)
-		s5p_ehci->pdata->phy_exit(pdev, USB_PHY_TYPE_HOST);
-fail_io:
-	clk_disable_unprepare(s5p_ehci->clk);
-fail_clk:
-	usb_put_hcd(hcd);
-	return err;
-}
-
-static int s5p_ehci_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-	struct s5p_ehci_hcd *s5p_ehci = to_s5p_ehci(hcd);
-
-	usb_remove_hcd(hcd);
-
-	if (s5p_ehci->otg)
-		s5p_ehci->otg->set_host(s5p_ehci->otg, &hcd->self);
-
-	if (s5p_ehci->phy)
-		usb_phy_shutdown(s5p_ehci->phy);
-	else if (s5p_ehci->pdata->phy_exit)
-		s5p_ehci->pdata->phy_exit(pdev, USB_PHY_TYPE_HOST);
-
-	clk_disable_unprepare(s5p_ehci->clk);
-
-	usb_put_hcd(hcd);
-
-	return 0;
-}
-
-static void s5p_ehci_shutdown(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	if (hcd->driver->shutdown)
-		hcd->driver->shutdown(hcd);
-}
-
-#ifdef CONFIG_PM
-static int s5p_ehci_suspend(struct device *dev)
-{
-	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	struct s5p_ehci_hcd *s5p_ehci = to_s5p_ehci(hcd);
-	struct platform_device *pdev = to_platform_device(dev);
-
-	bool do_wakeup = device_may_wakeup(dev);
-	int rc;
-
-	rc = ehci_suspend(hcd, do_wakeup);
-	if (rc)
-		return rc;
-
-	if (s5p_ehci->otg)
-		s5p_ehci->otg->set_host(s5p_ehci->otg, &hcd->self);
-
-	if (s5p_ehci->phy)
-		usb_phy_shutdown(s5p_ehci->phy);
-	else if (s5p_ehci->pdata->phy_exit)
-		s5p_ehci->pdata->phy_exit(pdev, USB_PHY_TYPE_HOST);
-
-	clk_disable_unprepare(s5p_ehci->clk);
-
-	return rc;
-}
-
-static int s5p_ehci_resume(struct device *dev)
-{
-	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	struct  s5p_ehci_hcd *s5p_ehci = to_s5p_ehci(hcd);
-	struct platform_device *pdev = to_platform_device(dev);
-
-	clk_prepare_enable(s5p_ehci->clk);
-
-	if (s5p_ehci->otg)
-		s5p_ehci->otg->set_host(s5p_ehci->otg, &hcd->self);
-
-	if (s5p_ehci->phy)
-		usb_phy_init(s5p_ehci->phy);
-	else if (s5p_ehci->pdata->phy_init)
-		s5p_ehci->pdata->phy_init(pdev, USB_PHY_TYPE_HOST);
-
-	/* DMA burst Enable */
-	writel(EHCI_INSNREG00_ENABLE_DMA_BURST, EHCI_INSNREG00(hcd->regs));
-
-	ehci_resume(hcd, false);
-	return 0;
-}
-#else
-#define s5p_ehci_suspend	NULL
-#define s5p_ehci_resume		NULL
-#endif
-
-static const struct dev_pm_ops s5p_ehci_pm_ops = {
-	.suspend	= s5p_ehci_suspend,
-	.resume		= s5p_ehci_resume,
-};
-
-#ifdef CONFIG_OF
-static const struct of_device_id exynos_ehci_match[] = {
-	{ .compatible = "samsung,exynos4210-ehci" },
-	{},
-};
-MODULE_DEVICE_TABLE(of, exynos_ehci_match);
-#endif
-
-static struct platform_driver s5p_ehci_driver = {
-	.probe		= s5p_ehci_probe,
-	.remove		= s5p_ehci_remove,
-	.shutdown	= s5p_ehci_shutdown,
-	.driver = {
-		.name	= "s5p-ehci",
-		.owner	= THIS_MODULE,
-		.pm	= &s5p_ehci_pm_ops,
-		.of_match_table = of_match_ptr(exynos_ehci_match),
-	}
-};
-static const struct ehci_driver_overrides s5p_overrides __initdata = {
-	.extra_priv_size = sizeof(struct s5p_ehci_hcd),
-};
-
-static int __init ehci_s5p_init(void)
-{
-	if (usb_disabled())
-		return -ENODEV;
-
-	pr_info("%s: " DRIVER_DESC "\n", hcd_name);
-	ehci_init_driver(&s5p_ehci_hc_driver, &s5p_overrides);
-	return platform_driver_register(&s5p_ehci_driver);
-}
-module_init(ehci_s5p_init);
-
-static void __exit ehci_s5p_cleanup(void)
-{
-	platform_driver_unregister(&s5p_ehci_driver);
-}
-module_exit(ehci_s5p_cleanup);
-
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_ALIAS("platform:s5p-ehci");
-MODULE_AUTHOR("Jingoo Han");
-MODULE_AUTHOR("Joonyoung Shim");
-MODULE_LICENSE("GPL v2");
