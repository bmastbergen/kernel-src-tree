vxlan: consolidate vxlan_xmit_skb and vxlan6_xmit_skb

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit f491e56dba511d318f52efa4c226471bf5943e88
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f491e56d.failed

There's a lot of code duplication. Factor out the duplicate code to a new
function shared between IPv4 and IPv6 xmit path.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f491e56dba511d318f52efa4c226471bf5943e88)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index aaa12a1f2042,65f52472a52c..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1660,18 -1684,14 +1660,28 @@@ static void vxlan_build_gbp_hdr(struct 
  	gbp->policy_id = htons(md->gbp & VXLAN_GBP_ID_MASK);
  }
  
++<<<<<<< HEAD
 +#if IS_ENABLED(CONFIG_IPV6)
 +static int vxlan6_xmit_skb(struct dst_entry *dst, struct sock *sk,
 +			   struct sk_buff *skb,
 +			   struct net_device *dev, struct in6_addr *saddr,
 +			   struct in6_addr *daddr, __u8 prio, __u8 ttl,
 +			   __be16 src_port, __be16 dst_port,
 +			   struct vxlan_metadata *md, bool xnet, u32 vxflags)
++=======
+ static int vxlan_build_skb(struct sk_buff *skb, struct dst_entry *dst,
+ 			   int iphdr_len, __be32 vni,
+ 			   struct vxlan_metadata *md, u32 vxflags,
+ 			   bool udp_sum)
++>>>>>>> f491e56dba51 (vxlan: consolidate vxlan_xmit_skb and vxlan6_xmit_skb)
  {
  	struct vxlanhdr *vxh;
  	int min_headroom;
  	int err;
++<<<<<<< HEAD
 +	bool udp_sum = !(vxflags & VXLAN_F_UDP_ZERO_CSUM6_TX);
++=======
++>>>>>>> f491e56dba51 (vxlan: consolidate vxlan_xmit_skb and vxlan6_xmit_skb)
  	int type = udp_sum ? SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;
  	u16 hdrlen = sizeof(struct vxlanhdr);
  
@@@ -1688,10 -1708,8 +1698,9 @@@
  		}
  	}
  
- 	skb_scrub_packet(skb, xnet);
- 
  	min_headroom = LL_RESERVED_SPACE(dst->dev) + dst->header_len
 -			+ VXLAN_HLEN + iphdr_len
++<<<<<<< HEAD
 +			+ VXLAN_HLEN + sizeof(struct ipv6hdr)
  			+ (skb_vlan_tag_present(skb) ? VLAN_HLEN : 0);
  
  	/* Need space for new headers (invalidates iph ptr) */
@@@ -1737,91 -1751,57 +1746,98 @@@
  		vxlan_build_gbp_hdr(vxh, vxflags, md);
  
  	skb_set_inner_protocol(skb, htons(ETH_P_TEB));
 +
 +	udp_tunnel6_xmit_skb(dst, sk, skb, dev, saddr, daddr, prio,
 +			     ttl, src_port, dst_port,
 +			     !!(vxflags & VXLAN_F_UDP_ZERO_CSUM6_TX));
  	return 0;
 +err:
 +	dst_release(dst);
 +	return err;
  }
 +#endif
  
 -static struct rtable *vxlan_get_route(struct vxlan_dev *vxlan,
 -				      struct sk_buff *skb, int oif, u8 tos,
 -				      __be32 daddr, __be32 *saddr)
 +int vxlan_xmit_skb(struct rtable *rt, struct sock *sk, struct sk_buff *skb,
 +		   __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,
 +		   __be16 src_port, __be16 dst_port,
 +		   struct vxlan_metadata *md, bool xnet, u32 vxflags)
  {
 -	struct rtable *rt = NULL;
 -	struct flowi4 fl4;
 +	struct vxlanhdr *vxh;
 +	int min_headroom;
 +	int err;
 +	bool udp_sum = !!(vxflags & VXLAN_F_UDP_CSUM);
 +	int type = udp_sum ? SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;
 +	u16 hdrlen = sizeof(struct vxlanhdr);
  
 -	memset(&fl4, 0, sizeof(fl4));
 -	fl4.flowi4_oif = oif;
 -	fl4.flowi4_tos = RT_TOS(tos);
 -	fl4.flowi4_mark = skb->mark;
 -	fl4.flowi4_proto = IPPROTO_UDP;
 -	fl4.daddr = daddr;
 -	fl4.saddr = vxlan->cfg.saddr.sin.sin_addr.s_addr;
 +	if ((vxflags & VXLAN_F_REMCSUM_TX) &&
 +	    skb->ip_summed == CHECKSUM_PARTIAL) {
 +		int csum_start = skb_checksum_start_offset(skb);
  
 -	rt = ip_route_output_key(vxlan->net, &fl4);
 -	if (!IS_ERR(rt))
 -		*saddr = fl4.saddr;
 -	return rt;
 -}
 +		if (csum_start <= VXLAN_MAX_REMCSUM_START &&
 +		    !(csum_start & VXLAN_RCO_SHIFT_MASK) &&
 +		    (skb->csum_offset == offsetof(struct udphdr, check) ||
 +		     skb->csum_offset == offsetof(struct tcphdr, check))) {
 +			udp_sum = false;
 +			type |= SKB_GSO_TUNNEL_REMCSUM;
 +		}
 +	}
  
 -#if IS_ENABLED(CONFIG_IPV6)
 -static struct dst_entry *vxlan6_get_route(struct vxlan_dev *vxlan,
 -					  struct sk_buff *skb, int oif,
 -					  const struct in6_addr *daddr,
 -					  struct in6_addr *saddr)
 -{
 -	struct dst_entry *ndst;
 -	struct flowi6 fl6;
 -	int err;
 +	min_headroom = LL_RESERVED_SPACE(rt->dst.dev) + rt->dst.header_len
 +			+ VXLAN_HLEN + sizeof(struct iphdr)
++=======
++			+ VXLAN_HLEN + iphdr_len
++>>>>>>> f491e56dba51 (vxlan: consolidate vxlan_xmit_skb and vxlan6_xmit_skb)
 +			+ (skb_vlan_tag_present(skb) ? VLAN_HLEN : 0);
  
 -	memset(&fl6, 0, sizeof(fl6));
 -	fl6.flowi6_oif = oif;
 -	fl6.daddr = *daddr;
 -	fl6.saddr = vxlan->cfg.saddr.sin6.sin6_addr;
 -	fl6.flowi6_mark = skb->mark;
 -	fl6.flowi6_proto = IPPROTO_UDP;
 +	/* Need space for new headers (invalidates iph ptr) */
 +	err = skb_cow_head(skb, min_headroom);
 +	if (unlikely(err)) {
 +		kfree_skb(skb);
 +		return err;
 +	}
  
 -	err = ipv6_stub->ipv6_dst_lookup(vxlan->net,
 -					 vxlan->vn6_sock->sock->sk,
 -					 &ndst, &fl6);
 -	if (err < 0)
 -		return ERR_PTR(err);
 +	skb = vlan_hwaccel_push_inside(skb);
 +	if (WARN_ON(!skb))
 +		return -ENOMEM;
 +
 +	skb = iptunnel_handle_offloads(skb, udp_sum, type);
 +	if (IS_ERR(skb))
 +		return PTR_ERR(skb);
 +
 +	vxh = (struct vxlanhdr *) __skb_push(skb, sizeof(*vxh));
 +	vxh->vx_flags = htonl(VXLAN_HF_VNI);
 +	vxh->vx_vni = md->vni;
 +
 +	if (type & SKB_GSO_TUNNEL_REMCSUM) {
 +		u32 data = (skb_checksum_start_offset(skb) - hdrlen) >>
 +			   VXLAN_RCO_SHIFT;
 +
 +		if (skb->csum_offset == offsetof(struct udphdr, check))
 +			data |= VXLAN_RCO_UDP;
 +
 +		vxh->vx_vni |= htonl(data);
 +		vxh->vx_flags |= htonl(VXLAN_HF_RCO);
  
 -	*saddr = fl6.saddr;
 -	return ndst;
 +		if (!skb_is_gso(skb)) {
 +			skb->ip_summed = CHECKSUM_NONE;
 +			skb->encapsulation = 0;
 +		}
 +	}
 +
 +	if (vxflags & VXLAN_F_GBP)
 +		vxlan_build_gbp_hdr(vxh, vxflags, md);
 +
 +	skb_set_inner_protocol(skb, htons(ETH_P_TEB));
++<<<<<<< HEAD
 +
 +	return udp_tunnel_xmit_skb(rt, sk, skb, src, dst, tos,
 +				   ttl, df, src_port, dst_port, xnet,
 +				   !(vxflags & VXLAN_F_UDP_CSUM));
++=======
++	return 0;
++>>>>>>> f491e56dba51 (vxlan: consolidate vxlan_xmit_skb and vxlan6_xmit_skb)
  }
 -#endif
 +EXPORT_SYMBOL_GPL(vxlan_xmit_skb);
  
  /* Bypass encapsulation if the destination is local */
  static void vxlan_encap_bypass(struct sk_buff *skb, struct vxlan_dev *src_vxlan,
@@@ -1883,10 -1865,31 +1899,16 @@@ static void vxlan_xmit_one(struct sk_bu
  	__be16 df = 0;
  	__u8 tos, ttl;
  	int err;
++<<<<<<< HEAD
++=======
+ 	u32 flags = vxlan->flags;
+ 	bool udp_sum = false;
+ 	bool xnet = !net_eq(vxlan->net, dev_net(vxlan->dev));
++>>>>>>> f491e56dba51 (vxlan: consolidate vxlan_xmit_skb and vxlan6_xmit_skb)
  
 -	info = skb_tunnel_info(skb);
 -
 -	if (rdst) {
 -		dst_port = rdst->remote_port ? rdst->remote_port : vxlan->cfg.dst_port;
 -		vni = rdst->remote_vni;
 -		dst = &rdst->remote_ip;
 -	} else {
 -		if (!info) {
 -			WARN_ONCE(1, "%s: Missing encapsulation instructions\n",
 -				  dev->name);
 -			goto drop;
 -		}
 -		dst_port = info->key.tp_dst ? : vxlan->cfg.dst_port;
 -		vni = be64_to_cpu(info->key.tun_id);
 -		remote_ip.sa.sa_family = ip_tunnel_info_af(info);
 -		if (remote_ip.sa.sa_family == AF_INET)
 -			remote_ip.sin.sin_addr.s_addr = info->key.u.ipv4.dst;
 -		else
 -			remote_ip.sin6.sin6_addr = info->key.u.ipv6.dst;
 -		dst = &remote_ip;
 -	}
 +	dst_port = rdst->remote_port ? rdst->remote_port : vxlan->dst_port;
 +	vni = rdst->remote_vni;
 +	dst = &rdst->remote_ip;
  
  	if (vxlan_addr_any(dst)) {
  		if (did_rsc) {
@@@ -1951,21 -1972,14 +1973,32 @@@
  
  		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip4_dst_hoplimit(&rt->dst);
++<<<<<<< HEAD
 +		md.vni = htonl(vni << 8);
 +		md.gbp = skb->mark;
 +
 +		err = vxlan_xmit_skb(rt, sk, skb, fl4.saddr,
 +				     dst->sin.sin_addr.s_addr, tos, ttl, df,
 +				     src_port, dst_port, &md,
 +				     !net_eq(vxlan->net, dev_net(vxlan->dev)),
 +				     vxlan->flags);
 +		if (err < 0) {
 +			/* skb is already freed. */
 +			skb = NULL;
 +			goto rt_tx_error;
 +		}
 +
 +		iptunnel_xmit_stats(err, &dev->stats, dev->tstats);
++=======
+ 		err = vxlan_build_skb(skb, &rt->dst, sizeof(struct iphdr),
+ 				      htonl(vni << 8), md, flags, udp_sum);
+ 		if (err < 0)
+ 			goto xmit_tx_error;
+ 
+ 		udp_tunnel_xmit_skb(rt, sk, skb, saddr,
+ 				    dst->sin.sin_addr.s_addr, tos, ttl, df,
+ 				    src_port, dst_port, xnet, !udp_sum);
++>>>>>>> f491e56dba51 (vxlan: consolidate vxlan_xmit_skb and vxlan6_xmit_skb)
  #if IS_ENABLED(CONFIG_IPV6)
  	} else {
  		struct dst_entry *ndst;
@@@ -2010,14 -2024,20 +2043,27 @@@
  			return;
  		}
  
 -		if (!info)
 -			udp_sum = !(flags & VXLAN_F_UDP_ZERO_CSUM6_TX);
 -
  		ttl = ttl ? : ip6_dst_hoplimit(ndst);
++<<<<<<< HEAD
 +		md.vni = htonl(vni << 8);
 +		md.gbp = skb->mark;
 +
 +		err = vxlan6_xmit_skb(ndst, sk, skb, dev, &fl6.saddr, &fl6.daddr,
 +				      0, ttl, src_port, dst_port, &md,
 +				      !net_eq(vxlan->net, dev_net(vxlan->dev)),
 +				      vxlan->flags);
++=======
+ 		skb_scrub_packet(skb, xnet);
+ 		err = vxlan_build_skb(skb, ndst, sizeof(struct ipv6hdr),
+ 				      htonl(vni << 8), md, flags, udp_sum);
+ 		if (err < 0) {
+ 			dst_release(ndst);
+ 			return;
+ 		}
+ 		udp_tunnel6_xmit_skb(ndst, sk, skb, dev,
+ 				     &saddr, &dst->sin6.sin6_addr,
+ 				     0, ttl, src_port, dst_port, !udp_sum);
++>>>>>>> f491e56dba51 (vxlan: consolidate vxlan_xmit_skb and vxlan6_xmit_skb)
  #endif
  	}
  
* Unmerged path drivers/net/vxlan.c
