mm, dax: fix DAX deadlocks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mm] dax: fix DAX deadlocks (Jeff Moyer) [1345801 1348502 1348836 1350149 1350156]
Rebuild_FUZZ: 91.67%
commit-author Ross Zwisler <ross.zwisler@linux.intel.com>
commit 0f90cc6609c72b0bdf2aad0cb0456194dd896e19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0f90cc66.failed

The following two locking commits in the DAX code:

commit 843172978bb9 ("dax: fix race between simultaneous faults")
commit 46c043ede471 ("mm: take i_mmap_lock in unmap_mapping_range() for DAX")

introduced a number of deadlocks and other issues which need to be fixed
for the v4.3 kernel.  The list of issues in DAX after these commits
(some newly introduced by the commits, some preexisting) can be found
here:

  https://lkml.org/lkml/2015/9/25/602 (Subject: "Re: [PATCH] dax: fix deadlock in __dax_fault").

This undoes most of the changes introduced by those two commits,
essentially returning us to the DAX locking scheme that was used in
v4.2.

	Signed-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: Alexander Viro <viro@zeniv.linux.org.uk>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Tested-by: Dave Chinner <dchinner@redhat.com>
	Cc: Jan Kara <jack@suse.com>
	Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
	Cc: Matthew Wilcox <matthew.r.wilcox@intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0f90cc6609c72b0bdf2aad0cb0456194dd896e19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
#	mm/memory.c
diff --cc mm/memory.c
index 66d68efad529,deb679c31f2a..000000000000
--- a/mm/memory.c
+++ b/mm/memory.c
@@@ -3195,12 -2427,11 +3195,17 @@@ void unmap_mapping_range(struct address
  		details.last_index = ULONG_MAX;
  
  
++<<<<<<< HEAD
 +	mutex_lock(&mapping->i_mmap_mutex);
++=======
+ 	/* DAX uses i_mmap_lock to serialise file truncate vs page fault */
+ 	i_mmap_lock_write(mapping);
++>>>>>>> 0f90cc6609c7 (mm, dax: fix DAX deadlocks)
  	if (unlikely(!RB_EMPTY_ROOT(&mapping->i_mmap)))
  		unmap_mapping_range_tree(&mapping->i_mmap, &details);
 -	i_mmap_unlock_write(mapping);
 +	if (unlikely(!list_empty(&mapping->i_mmap_nonlinear)))
 +		unmap_mapping_range_list(&mapping->i_mmap_nonlinear, &details);
 +	mutex_unlock(&mapping->i_mmap_mutex);
  }
  EXPORT_SYMBOL(unmap_mapping_range);
  
* Unmerged path fs/dax.c
* Unmerged path fs/dax.c
* Unmerged path mm/memory.c
