perf record: Add AUX area tracing Snapshot Mode support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 2dd6d8a10a942c5fd8950d1046e172237d009c8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2dd6d8a1.failed

Add a new option and support for Instruction Tracing Snapshot Mode.
When the new option is selected, no AUX area tracing data is captured
until a signal (SIGUSR2) is received.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Namhyung Kim <namhyung@gmail.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
Link: http://lkml.kernel.org/r/1430404667-10593-10-git-send-email-adrian.hunter@intel.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 2dd6d8a10a942c5fd8950d1046e172237d009c8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Documentation/perf-record.txt
#	tools/perf/builtin-record.c
diff --cc tools/perf/Documentation/perf-record.txt
index 355c4f5569b5,57dd57bcef95..000000000000
--- a/tools/perf/Documentation/perf-record.txt
+++ b/tools/perf/Documentation/perf-record.txt
@@@ -250,6 -252,20 +250,23 @@@ is off by default
  --running-time::
  Record running and enabled time for read events (:S)
  
++<<<<<<< HEAD
++=======
+ -k::
+ --clockid::
+ Sets the clock id to use for the various time fields in the perf_event_type
+ records. See clock_gettime(). In particular CLOCK_MONOTONIC and
+ CLOCK_MONOTONIC_RAW are supported, some events might also allow
+ CLOCK_BOOTTIME, CLOCK_REALTIME and CLOCK_TAI.
+ 
+ -S::
+ --snapshot::
+ Select AUX area tracing Snapshot Mode. This option is valid only with an
+ AUX area tracing event. Optionally the number of bytes to capture per
+ snapshot can be specified. In Snapshot Mode, trace data is captured only when
+ signal SIGUSR2 is received.
+ 
++>>>>>>> 2dd6d8a10a94 (perf record: Add AUX area tracing Snapshot Mode support)
  SEE ALSO
  --------
  linkperf:perf-stat[1], linkperf:perf-list[1]
diff --cc tools/perf/builtin-record.c
index 29e56699eee2,5dfe91395617..000000000000
--- a/tools/perf/builtin-record.c
+++ b/tools/perf/builtin-record.c
@@@ -938,6 -1151,11 +1024,14 @@@ struct option __record_options[] = 
  		    "Sample machine registers on interrupt"),
  	OPT_BOOLEAN(0, "running-time", &record.opts.running_time,
  		    "Record running/enabled time of read (:S) events"),
++<<<<<<< HEAD
++=======
+ 	OPT_CALLBACK('k', "clockid", &record.opts,
+ 	"clockid", "clockid to use for events, see clock_gettime()",
+ 	parse_clockid),
+ 	OPT_STRING_OPTARG('S', "snapshot", &record.opts.auxtrace_snapshot_opts,
+ 			  "opts", "AUX area tracing Snapshot Mode", ""),
++>>>>>>> 2dd6d8a10a94 (perf record: Add AUX area tracing Snapshot Mode support)
  	OPT_END()
  };
  
* Unmerged path tools/perf/Documentation/perf-record.txt
* Unmerged path tools/perf/builtin-record.c
diff --git a/tools/perf/util/auxtrace.h b/tools/perf/util/auxtrace.h
index c2c677e62733..a171abbe7301 100644
--- a/tools/perf/util/auxtrace.h
+++ b/tools/perf/util/auxtrace.h
@@ -563,6 +563,17 @@ int itrace_parse_synth_opts(const struct option *opt __maybe_unused,
 	return -EINVAL;
 }
 
+static inline
+int auxtrace_parse_snapshot_options(struct auxtrace_record *itr __maybe_unused,
+				    struct record_opts *opts __maybe_unused,
+				    const char *str)
+{
+	if (!str)
+		return 0;
+	pr_err("AUX area tracing not supported\n");
+	return -EINVAL;
+}
+
 static inline
 int auxtrace__process_event(struct perf_session *session __maybe_unused,
 			    union perf_event *event __maybe_unused,
diff --git a/tools/perf/util/parse-options.h b/tools/perf/util/parse-options.h
index 59561fd86278..367d8b816cc7 100644
--- a/tools/perf/util/parse-options.h
+++ b/tools/perf/util/parse-options.h
@@ -123,6 +123,10 @@ struct option {
 #define OPT_LONG(s, l, v, h)        { .type = OPTION_LONG, .short_name = (s), .long_name = (l), .value = check_vtype(v, long *), .help = (h) }
 #define OPT_U64(s, l, v, h)         { .type = OPTION_U64, .short_name = (s), .long_name = (l), .value = check_vtype(v, u64 *), .help = (h) }
 #define OPT_STRING(s, l, v, a, h)   { .type = OPTION_STRING,  .short_name = (s), .long_name = (l), .value = check_vtype(v, const char **), (a), .help = (h) }
+#define OPT_STRING_OPTARG(s, l, v, a, h, d) \
+	{ .type = OPTION_STRING,  .short_name = (s), .long_name = (l), \
+	  .value = check_vtype(v, const char **), (a), .help = (h), \
+	  .flags = PARSE_OPT_OPTARG, .defval = (intptr_t)(d) }
 #define OPT_STRING_NOEMPTY(s, l, v, a, h)   { .type = OPTION_STRING,  .short_name = (s), .long_name = (l), .value = check_vtype(v, const char **), (a), .help = (h), .flags = PARSE_OPT_NOEMPTY}
 #define OPT_DATE(s, l, v, h) \
 	{ .type = OPTION_CALLBACK, .short_name = (s), .long_name = (l), .value = (v), .argh = "time", .help = (h), .callback = parse_opt_approxidate_cb }
