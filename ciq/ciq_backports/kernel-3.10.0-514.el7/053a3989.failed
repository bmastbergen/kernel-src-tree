perf report/top: Add --raw-trace option

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit 053a3989e12fdf3be45c00ec1cb0ce09fba0ee4a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/053a3989.failed

The --raw-trace option allows disabling pretty printing by the event's
print_fmt or plugin.  Besides that, each dynamic sort key now can
receive a 'raw' suffix separated by '/' to ask for the raw trace of a
specific field.

  $ perf report -s comm,kmem:kmalloc.gfp_flags
  ...
  # Overhead  Command            gfp_flags
  # ........  .......  ...................
  #
      99.89%  perf       GFP_NOFS|GFP_ZERO
       0.06%  sleep             GFP_KERNEL
       0.03%  perf     GFP_KERNEL|GFP_ZERO
       0.01%  perf              GFP_KERNEL

Now

  $ perf report -s comm,kmem:kmalloc.gfp_flags --raw-trace
or
  $ perf report -s comm,kmem:kmalloc.gfp_flags/raw
  ...
  # Overhead  Command   gfp_flags
  # ........  .......  ..........
  #
      99.89%  perf          32848
       0.06%  sleep           208
       0.03%  perf          32976
       0.01%  perf            208

Suggested-and-Acked-by: Jiri Olsa <jolsa@redhat.com>
	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1450804030-29193-9-git-send-email-namhyung@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 053a3989e12fdf3be45c00ec1cb0ce09fba0ee4a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Documentation/perf-report.txt
#	tools/perf/builtin-report.c
#	tools/perf/builtin-top.c
#	tools/perf/util/sort.c
#	tools/perf/util/symbol.h
diff --cc tools/perf/Documentation/perf-report.txt
index cbb133c5c41a,ae7cd91727f6..000000000000
--- a/tools/perf/Documentation/perf-report.txt
+++ b/tools/perf/Documentation/perf-report.txt
@@@ -356,6 -357,23 +356,26 @@@ include::itrace.txt[
  --full-source-path::
  	Show the full path for source files for srcline output.
  
++<<<<<<< HEAD
++=======
+ --show-ref-call-graph::
+ 	When multiple events are sampled, it may not be needed to collect
+ 	callgraphs for all of them. The sample sites are usually nearby,
+ 	and it's enough to collect the callgraphs on a reference event.
+ 	So user can use "call-graph=no" event modifier to disable callgraph
+ 	for other events to reduce the overhead.
+ 	However, perf report cannot show callgraphs for the event which
+ 	disable the callgraph.
+ 	This option extends the perf report to show reference callgraphs,
+ 	which collected by reference event, in no callgraph event.
+ 
+ --socket-filter::
+ 	Only report the samples on the processor socket that match with this filter
+ 
+ --raw-trace::
+ 	When displaying traceevent output, do not use print fmt or plugins.
+ 
++>>>>>>> 053a3989e12f (perf report/top: Add --raw-trace option)
  include::callchain-overhead-calculation.txt[]
  
  SEE ALSO
diff --cc tools/perf/builtin-report.c
index 909df888e8a7,f10c663af996..000000000000
--- a/tools/perf/builtin-report.c
+++ b/tools/perf/builtin-report.c
@@@ -771,6 -784,12 +771,15 @@@ int cmd_report(int argc, const char **a
  			    itrace_parse_synth_opts),
  	OPT_BOOLEAN(0, "full-source-path", &srcline_full_filename,
  			"Show full source file name path for source lines"),
++<<<<<<< HEAD
++=======
+ 	OPT_BOOLEAN(0, "show-ref-call-graph", &symbol_conf.show_ref_callgraph,
+ 		    "Show callgraph from reference event"),
+ 	OPT_INTEGER(0, "socket-filter", &report.socket_filter,
+ 		    "only show processor socket that match with this filter"),
+ 	OPT_BOOLEAN(0, "raw-trace", &symbol_conf.raw_trace,
+ 		    "Show raw trace event output (do not use print fmt or plugins)"),
++>>>>>>> 053a3989e12f (perf report/top: Add --raw-trace option)
  	OPT_END()
  	};
  	struct perf_data_file file = {
diff --cc tools/perf/builtin-top.c
index 646fb54f07d9,bf01cbb0ef23..000000000000
--- a/tools/perf/builtin-top.c
+++ b/tools/perf/builtin-top.c
@@@ -1183,6 -1202,16 +1183,19 @@@ int cmd_top(int argc, const char **argv
  	OPT_STRING('w', "column-widths", &symbol_conf.col_width_list_str,
  		   "width[,width...]",
  		   "don't try to adjust column width, use these fixed values"),
++<<<<<<< HEAD
++=======
+ 	OPT_UINTEGER(0, "proc-map-timeout", &opts->proc_map_timeout,
+ 			"per thread proc mmap processing timeout in ms"),
+ 	OPT_CALLBACK_NOOPT('b', "branch-any", &opts->branch_stack,
+ 		     "branch any", "sample any taken branches",
+ 		     parse_branch_stack),
+ 	OPT_CALLBACK('j', "branch-filter", &opts->branch_stack,
+ 		     "branch filter mask", "branch stack filter modes",
+ 		     parse_branch_stack),
+ 	OPT_BOOLEAN(0, "raw-trace", &symbol_conf.raw_trace,
+ 		    "Show raw trace event output (do not use print fmt or plugins)"),
++>>>>>>> 053a3989e12f (perf report/top: Add --raw-trace option)
  	OPT_END()
  	};
  	const char * const top_usage[] = {
diff --cc tools/perf/util/sort.c
index 7a0efdc373c2,34776854626e..000000000000
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@@ -423,6 -424,91 +423,94 @@@ struct sort_entry sort_cpu = 
  	.se_width_idx	= HISTC_CPU,
  };
  
++<<<<<<< HEAD
++=======
+ /* --sort socket */
+ 
+ static int64_t
+ sort__socket_cmp(struct hist_entry *left, struct hist_entry *right)
+ {
+ 	return right->socket - left->socket;
+ }
+ 
+ static int hist_entry__socket_snprintf(struct hist_entry *he, char *bf,
+ 				    size_t size, unsigned int width)
+ {
+ 	return repsep_snprintf(bf, size, "%*.*d", width, width-3, he->socket);
+ }
+ 
+ struct sort_entry sort_socket = {
+ 	.se_header      = "Socket",
+ 	.se_cmp	        = sort__socket_cmp,
+ 	.se_snprintf    = hist_entry__socket_snprintf,
+ 	.se_width_idx	= HISTC_SOCKET,
+ };
+ 
+ /* --sort trace */
+ 
+ static char *get_trace_output(struct hist_entry *he)
+ {
+ 	struct trace_seq seq;
+ 	struct perf_evsel *evsel;
+ 	struct pevent_record rec = {
+ 		.data = he->raw_data,
+ 		.size = he->raw_size,
+ 	};
+ 
+ 	evsel = hists_to_evsel(he->hists);
+ 
+ 	trace_seq_init(&seq);
+ 	if (symbol_conf.raw_trace) {
+ 		pevent_print_fields(&seq, he->raw_data, he->raw_size,
+ 				    evsel->tp_format);
+ 	} else {
+ 		pevent_event_info(&seq, evsel->tp_format, &rec);
+ 	}
+ 	return seq.buffer;
+ }
+ 
+ static int64_t
+ sort__trace_cmp(struct hist_entry *left, struct hist_entry *right)
+ {
+ 	struct perf_evsel *evsel;
+ 
+ 	evsel = hists_to_evsel(left->hists);
+ 	if (evsel->attr.type != PERF_TYPE_TRACEPOINT)
+ 		return 0;
+ 
+ 	if (left->trace_output == NULL)
+ 		left->trace_output = get_trace_output(left);
+ 	if (right->trace_output == NULL)
+ 		right->trace_output = get_trace_output(right);
+ 
+ 	hists__new_col_len(left->hists, HISTC_TRACE, strlen(left->trace_output));
+ 	hists__new_col_len(right->hists, HISTC_TRACE, strlen(right->trace_output));
+ 
+ 	return strcmp(right->trace_output, left->trace_output);
+ }
+ 
+ static int hist_entry__trace_snprintf(struct hist_entry *he, char *bf,
+ 				    size_t size, unsigned int width)
+ {
+ 	struct perf_evsel *evsel;
+ 
+ 	evsel = hists_to_evsel(he->hists);
+ 	if (evsel->attr.type != PERF_TYPE_TRACEPOINT)
+ 		return scnprintf(bf, size, "%-*.*s", width, width, "N/A");
+ 
+ 	if (he->trace_output == NULL)
+ 		he->trace_output = get_trace_output(he);
+ 	return repsep_snprintf(bf, size, "%-*.*s", width, width, he->trace_output);
+ }
+ 
+ struct sort_entry sort_trace = {
+ 	.se_header      = "Trace output",
+ 	.se_cmp	        = sort__trace_cmp,
+ 	.se_snprintf    = hist_entry__trace_snprintf,
+ 	.se_width_idx	= HISTC_TRACE,
+ };
+ 
++>>>>>>> 053a3989e12f (perf report/top: Add --raw-trace option)
  /* sort keys for branch stacks */
  
  static int64_t
diff --cc tools/perf/util/symbol.h
index 3877753f29ce,ccd1caa40e11..000000000000
--- a/tools/perf/util/symbol.h
+++ b/tools/perf/util/symbol.h
@@@ -107,7 -107,10 +107,14 @@@ struct symbol_conf 
  			filter_relative,
  			show_hist_headers,
  			branch_callstack,
++<<<<<<< HEAD
 +			has_filter;
++=======
+ 			has_filter,
+ 			show_ref_callgraph,
+ 			hide_unresolved,
+ 			raw_trace;
++>>>>>>> 053a3989e12f (perf report/top: Add --raw-trace option)
  	const char	*vmlinux_name,
  			*kallsyms_name,
  			*source_prefix,
* Unmerged path tools/perf/Documentation/perf-report.txt
diff --git a/tools/perf/Documentation/perf-top.txt b/tools/perf/Documentation/perf-top.txt
index 339fa821fabb..617826d9f556 100644
--- a/tools/perf/Documentation/perf-top.txt
+++ b/tools/perf/Documentation/perf-top.txt
@@ -203,6 +203,9 @@ Default is to monitor all CPUS.
 	readability.  0 means no limit (default behavior).
 
 
+--raw-trace::
+	When displaying traceevent output, do not use print fmt or plugins.
+
 INTERACTIVE PROMPTING KEYS
 --------------------------
 
* Unmerged path tools/perf/builtin-report.c
* Unmerged path tools/perf/builtin-top.c
* Unmerged path tools/perf/util/sort.c
* Unmerged path tools/perf/util/symbol.h
