xprtrdma: Pre-allocate Work Requests for backchannel

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 124fa17d3e33060fbb28e995a42c7f5c8b31b345
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/124fa17d.failed

Pre-allocate extra send and receive Work Requests needed to handle
backchannel receives and sends.

The transport doesn't know how many extra WRs to pre-allocate until
the xprt_setup_backchannel() call, but that's long after the WRs are
allocated during forechannel setup.

So, use a fixed value for now.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
Tested-By: Devesh Sharma <devesh.sharma@avagotech.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 124fa17d3e33060fbb28e995a42c7f5c8b31b345)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/backchannel.c
#	net/sunrpc/xprtrdma/verbs.c
diff --cc net/sunrpc/xprtrdma/verbs.c
index 6115ededb593,93883ffb86e0..000000000000
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@@ -691,11 -568,25 +691,28 @@@ rpcrdma_ep_create(struct rpcrdma_ep *ep
  	struct ib_device_attr *devattr = &ia->ri_devattr;
  	struct ib_cq *sendcq, *recvcq;
  	struct ib_cq_init_attr cq_attr = {};
+ 	unsigned int max_qp_wr;
  	int rc, err;
  
++<<<<<<< HEAD
++=======
+ 	if (devattr->max_sge < RPCRDMA_MAX_IOVS) {
+ 		dprintk("RPC:       %s: insufficient sge's available\n",
+ 			__func__);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	if (devattr->max_qp_wr <= RPCRDMA_BACKWARD_WRS) {
+ 		dprintk("RPC:       %s: insufficient wqe's available\n",
+ 			__func__);
+ 		return -ENOMEM;
+ 	}
+ 	max_qp_wr = devattr->max_qp_wr - RPCRDMA_BACKWARD_WRS;
+ 
++>>>>>>> 124fa17d3e33 (xprtrdma: Pre-allocate Work Requests for backchannel)
  	/* check provider's send/recv wr limits */
- 	if (cdata->max_requests > devattr->max_qp_wr)
- 		cdata->max_requests = devattr->max_qp_wr;
+ 	if (cdata->max_requests > max_qp_wr)
+ 		cdata->max_requests = max_qp_wr;
  
  	ep->rep_attr.event_handler = rpcrdma_qp_async_error_upcall;
  	ep->rep_attr.qp_context = ep;
@@@ -705,7 -597,8 +723,12 @@@
  	if (rc)
  		return rc;
  	ep->rep_attr.cap.max_recv_wr = cdata->max_requests;
++<<<<<<< HEAD
 +	ep->rep_attr.cap.max_send_sge = (cdata->padding ? 4 : 2);
++=======
+ 	ep->rep_attr.cap.max_recv_wr += RPCRDMA_BACKWARD_WRS;
+ 	ep->rep_attr.cap.max_send_sge = RPCRDMA_MAX_IOVS;
++>>>>>>> 124fa17d3e33 (xprtrdma: Pre-allocate Work Requests for backchannel)
  	ep->rep_attr.cap.max_recv_sge = 1;
  	ep->rep_attr.cap.max_inline_data = 0;
  	ep->rep_attr.sq_sig_type = IB_SIGNAL_REQ_WR;
* Unmerged path net/sunrpc/xprtrdma/backchannel.c
* Unmerged path net/sunrpc/xprtrdma/backchannel.c
* Unmerged path net/sunrpc/xprtrdma/verbs.c
diff --git a/net/sunrpc/xprtrdma/xprt_rdma.h b/net/sunrpc/xprtrdma/xprt_rdma.h
index b2d2c86a7023..48a87f02c2bf 100644
--- a/net/sunrpc/xprtrdma/xprt_rdma.h
+++ b/net/sunrpc/xprtrdma/xprt_rdma.h
@@ -108,6 +108,16 @@ struct rpcrdma_ep {
  */
 #define RPCRDMA_IGNORE_COMPLETION	(0ULL)
 
+/* Pre-allocate extra Work Requests for handling backward receives
+ * and sends. This is a fixed value because the Work Queues are
+ * allocated when the forward channel is set up.
+ */
+#if defined(CONFIG_SUNRPC_BACKCHANNEL)
+#define RPCRDMA_BACKWARD_WRS		(8)
+#else
+#define RPCRDMA_BACKWARD_WRS		(0)
+#endif
+
 /* Registered buffer -- registered kmalloc'd memory for RDMA SEND/RECV
  *
  * The below structure appears at the front of a large region of kmalloc'd
