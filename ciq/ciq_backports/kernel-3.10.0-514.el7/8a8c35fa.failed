mm: kmemleak_alloc_percpu() should follow the gfp from per_alloc()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mm] kmemleak_alloc_percpu() should follow the gfp from per_alloc() (Jiri Benc) [1323141]
Rebuild_FUZZ: 96.88%
commit-author Larry Finger <Larry.Finger@lwfinger.net>
commit 8a8c35fadfaf55629a37ef1a8ead1b8fb32581d2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8a8c35fa.failed

Beginning at commit d52d3997f843 ("ipv6: Create percpu rt6_info"), the
following INFO splat is logged:

  ===============================
  [ INFO: suspicious RCU usage. ]
  4.1.0-rc7-next-20150612 #1 Not tainted
  -------------------------------
  kernel/sched/core.c:7318 Illegal context switch in RCU-bh read-side critical section!
  other info that might help us debug this:
  rcu_scheduler_active = 1, debug_locks = 0
   3 locks held by systemd/1:
   #0:  (rtnl_mutex){+.+.+.}, at: [<ffffffff815f0c8f>] rtnetlink_rcv+0x1f/0x40
   #1:  (rcu_read_lock_bh){......}, at: [<ffffffff816a34e2>] ipv6_add_addr+0x62/0x540
   #2:  (addrconf_hash_lock){+...+.}, at: [<ffffffff816a3604>] ipv6_add_addr+0x184/0x540
  stack backtrace:
  CPU: 0 PID: 1 Comm: systemd Not tainted 4.1.0-rc7-next-20150612 #1
  Hardware name: TOSHIBA TECRA A50-A/TECRA A50-A, BIOS Version 4.20   04/17/2014
  Call Trace:
    dump_stack+0x4c/0x6e
    lockdep_rcu_suspicious+0xe7/0x120
    ___might_sleep+0x1d5/0x1f0
    __might_sleep+0x4d/0x90
    kmem_cache_alloc+0x47/0x250
    create_object+0x39/0x2e0
    kmemleak_alloc_percpu+0x61/0xe0
    pcpu_alloc+0x370/0x630

Additional backtrace lines are truncated.  In addition, the above splat
is followed by several "BUG: sleeping function called from invalid
context at mm/slub.c:1268" outputs.  As suggested by Martin KaFai Lau,
these are the clue to the fix.  Routine kmemleak_alloc_percpu() always
uses GFP_KERNEL for its allocations, whereas it should follow the gfp
from its callers.

	Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
	Reviewed-by: Kamalesh Babulal <kamalesh@linux.vnet.ibm.com>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
	Cc: Martin KaFai Lau <kafai@fb.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Tejun Heo <tj@kernel.org>
	Cc: Christoph Lameter <cl@linux-foundation.org>
	Cc: <stable@vger.kernel.org>	[3.18+]
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8a8c35fadfaf55629a37ef1a8ead1b8fb32581d2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/kmemleak.c
diff --cc mm/kmemleak.c
index c8d7f3110fd0,cf79f110157c..000000000000
--- a/mm/kmemleak.c
+++ b/mm/kmemleak.c
@@@ -917,11 -946,11 +918,16 @@@ void __ref kmemleak_alloc_percpu(const 
  	 * Percpu allocations are only scanned and not reported as leaks
  	 * (min_count is set to 0).
  	 */
 -	if (kmemleak_enabled && ptr && !IS_ERR(ptr))
 +	if (atomic_read(&kmemleak_enabled) && ptr && !IS_ERR(ptr))
  		for_each_possible_cpu(cpu)
  			create_object((unsigned long)per_cpu_ptr(ptr, cpu),
++<<<<<<< HEAD
 +				      size, 0, GFP_KERNEL);
 +	else if (atomic_read(&kmemleak_early_log))
++=======
+ 				      size, 0, gfp);
+ 	else if (kmemleak_early_log)
++>>>>>>> 8a8c35fadfaf (mm: kmemleak_alloc_percpu() should follow the gfp from per_alloc())
  		log_early(KMEMLEAK_ALLOC_PERCPU, ptr, size, 0);
  }
  EXPORT_SYMBOL_GPL(kmemleak_alloc_percpu);
diff --git a/include/linux/kmemleak.h b/include/linux/kmemleak.h
index 2a5e5548a1d2..c3bcbb6a913b 100644
--- a/include/linux/kmemleak.h
+++ b/include/linux/kmemleak.h
@@ -26,7 +26,8 @@
 extern void kmemleak_init(void) __ref;
 extern void kmemleak_alloc(const void *ptr, size_t size, int min_count,
 			   gfp_t gfp) __ref;
-extern void kmemleak_alloc_percpu(const void __percpu *ptr, size_t size) __ref;
+extern void kmemleak_alloc_percpu(const void __percpu *ptr, size_t size,
+				  gfp_t gfp) __ref;
 extern void kmemleak_free(const void *ptr) __ref;
 extern void kmemleak_free_part(const void *ptr, size_t size) __ref;
 extern void kmemleak_free_percpu(const void __percpu *ptr) __ref;
@@ -70,7 +71,8 @@ static inline void kmemleak_alloc_recursive(const void *ptr, size_t size,
 					    gfp_t gfp)
 {
 }
-static inline void kmemleak_alloc_percpu(const void __percpu *ptr, size_t size)
+static inline void kmemleak_alloc_percpu(const void __percpu *ptr, size_t size,
+					 gfp_t gfp)
 {
 }
 static inline void kmemleak_free(const void *ptr)
* Unmerged path mm/kmemleak.c
diff --git a/mm/percpu.c b/mm/percpu.c
index 29e7e6e746eb..280c1ea8c04b 100644
--- a/mm/percpu.c
+++ b/mm/percpu.c
@@ -1029,7 +1029,7 @@ area_found:
 		memset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);
 
 	ptr = __addr_to_pcpu_ptr(chunk->base_addr + off);
-	kmemleak_alloc_percpu(ptr, size);
+	kmemleak_alloc_percpu(ptr, size, gfp);
 	return ptr;
 
 fail_unlock:
