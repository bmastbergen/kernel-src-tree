ACPI / property: Add routine for extraction of _DSD properties

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit bd8191cc8a74018e255eb3efff5e02dc305a5ed1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bd8191cc.failed

Move the extraction of _DSD properties from acpi_init_properties()
to a separate routine called acpi_extract_properties() to make the
subsequent changes more straightforward.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit bd8191cc8a74018e255eb3efff5e02dc305a5ed1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/property.c
diff --cc drivers/acpi/property.c
index 3d47281953cd,8163b4bd7a61..000000000000
--- a/drivers/acpi/property.c
+++ b/drivers/acpi/property.c
@@@ -76,21 -76,37 +76,53 @@@ static bool acpi_properties_format_vali
  	return true;
  }
  
++<<<<<<< HEAD
 +void acpi_init_properties(struct acpi_device *adev)
 +{
 +	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
 +	const union acpi_object *desc;
 +	acpi_status status;
 +	int i;
 +
 +	status = acpi_evaluate_object_typed(adev->handle, "_DSD", NULL, &buf,
 +					    ACPI_TYPE_PACKAGE);
 +	if (ACPI_FAILURE(status))
 +		return;
 +
 +	desc = buf.pointer;
++=======
+ static void acpi_init_of_compatible(struct acpi_device *adev)
+ {
+ 	const union acpi_object *of_compatible;
+ 	int ret;
+ 
+ 	ret = acpi_dev_get_property_array(adev, "compatible", ACPI_TYPE_STRING,
+ 					  &of_compatible);
+ 	if (ret) {
+ 		ret = acpi_dev_get_property(adev, "compatible",
+ 					    ACPI_TYPE_STRING, &of_compatible);
+ 		if (ret) {
+ 			if (adev->parent
+ 			    && adev->parent->flags.of_compatible_ok)
+ 				goto out;
+ 
+ 			return;
+ 		}
+ 	}
+ 	adev->data.of_compatible = of_compatible;
+ 
+  out:
+ 	adev->flags.of_compatible_ok = 1;
+ }
+ 
+ static bool acpi_extract_properties(const union acpi_object *desc,
+ 				    struct acpi_device_data *data)
+ {
+ 	int i;
+ 
++>>>>>>> bd8191cc8a74 (ACPI / property: Add routine for extraction of _DSD properties)
  	if (desc->package.count % 2)
- 		goto fail;
+ 		return false;
  
  	/* Look for the device properties UUID. */
  	for (i = 0; i < desc->package.count; i += 2) {
@@@ -117,14 -133,49 +149,60 @@@
  		if (!acpi_properties_format_valid(properties))
  			break;
  
++<<<<<<< HEAD
 +		adev->data.pointer = buf.pointer;
 +		adev->data.properties = properties;
 +		return;
 +	}
 +
 + fail:
 +	dev_warn(&adev->dev, "Returned _DSD data is not valid, skipping\n");
 +	ACPI_FREE(buf.pointer);
++=======
+ 		data->properties = properties;
+ 		return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ void acpi_init_properties(struct acpi_device *adev)
+ {
+ 	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
+ 	struct acpi_hardware_id *hwid;
+ 	acpi_status status;
+ 	bool acpi_of = false;
+ 
+ 	/*
+ 	 * Check if ACPI_DT_NAMESPACE_HID is present and inthat case we fill in
+ 	 * Device Tree compatible properties for this device.
+ 	 */
+ 	list_for_each_entry(hwid, &adev->pnp.ids, list) {
+ 		if (!strcmp(hwid->id, ACPI_DT_NAMESPACE_HID)) {
+ 			acpi_of = true;
+ 			break;
+ 		}
+ 	}
+ 
+ 	status = acpi_evaluate_object_typed(adev->handle, "_DSD", NULL, &buf,
+ 					    ACPI_TYPE_PACKAGE);
+ 	if (ACPI_FAILURE(status))
+ 		goto out;
+ 
+ 	if (acpi_extract_properties(buf.pointer, &adev->data)) {
+ 		adev->data.pointer = buf.pointer;
+ 		if (acpi_of)
+ 			acpi_init_of_compatible(adev);
+ 	} else {
+ 		acpi_handle_debug(adev->handle, "Invalid _DSD data, skipping\n");
+ 		ACPI_FREE(buf.pointer);
+ 	}
+ 
+  out:
+ 	if (acpi_of && !adev->flags.of_compatible_ok)
+ 		acpi_handle_info(adev->handle,
+ 			 ACPI_DT_NAMESPACE_HID " requires 'compatible' property\n");
++>>>>>>> bd8191cc8a74 (ACPI / property: Add routine for extraction of _DSD properties)
  }
  
  void acpi_free_properties(struct acpi_device *adev)
* Unmerged path drivers/acpi/property.c
