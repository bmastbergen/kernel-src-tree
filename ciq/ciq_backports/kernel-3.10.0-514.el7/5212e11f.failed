nd_btt: atomic sector updates

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vishal Verma <vishal.l.verma@intel.com>
commit 5212e11fde4d40fa627668b4f2222d20db488f71
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5212e11f.failed

BTT stands for Block Translation Table, and is a way to provide power
fail sector atomicity semantics for block devices that have the ability
to perform byte granularity IO. It relies on the capability of libnvdimm
namespace devices to do byte aligned IO.

The BTT works as a stacked blocked device, and reserves a chunk of space
from the backing device for its accounting metadata. It is a bio-based
driver because all IO is done synchronously, and there is no queuing or
asynchronous completions at either the device or the driver level.

The BTT uses 'lanes' to index into various 'on-disk' data structures,
and lanes also act as a synchronization mechanism in case there are more
CPUs than available lanes. We did a comparison between two lane lock
strategies - first where we kept an atomic counter around that tracked
which was the last lane that was used, and 'our' lane was determined by
atomically incrementing that. That way, for the nr_cpus > nr_lanes case,
theoretically, no CPU would be blocked waiting for a lane. The other
strategy was to use the cpu number we're scheduled on to and hash it to
a lane number. Theoretically, this could block an IO that could've
otherwise run using a different, free lane. But some fio workloads
showed that the direct cpu -> lane hash performed faster than tracking
'last lane' - my reasoning is the cache thrash caused by moving the
atomic variable made that approach slower than simply waiting out the
in-progress IO. This supports the conclusion that the driver can be a
very simple bio-based one that does synchronous IOs instead of queuing.

	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Boaz Harrosh <boaz@plexistor.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Jens Axboe <axboe@fb.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Neil Brown <neilb@suse.de>
	Cc: Jeff Moyer <jmoyer@redhat.com>
	Cc: Dave Chinner <david@fromorbit.com>
	Cc: Greg KH <gregkh@linuxfoundation.org>
[jmoyer: fix nmi watchdog timeout in btt_map_init]
[jmoyer: move btt initialization to module load path]
[jmoyer: fix memory leak in the btt initialization path]
[jmoyer: Don't overwrite corrupted arenas]
	Signed-off-by: Vishal Verma <vishal.l.verma@linux.intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 5212e11fde4d40fa627668b4f2222d20db488f71)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/nfit.c
#	drivers/block/btt.c
#	drivers/block/pmem.c
#	drivers/nvdimm/Kconfig
#	drivers/nvdimm/Makefile
#	drivers/nvdimm/btt.h
#	drivers/nvdimm/btt_devs.c
#	drivers/nvdimm/namespace_devs.c
#	drivers/nvdimm/nd.h
#	drivers/nvdimm/region.c
#	drivers/nvdimm/region_devs.c
#	include/linux/libnvdimm.h
diff --cc drivers/block/pmem.c
index d46975ed9e40,7346054bccbb..000000000000
--- a/drivers/block/pmem.c
+++ b/drivers/block/pmem.c
@@@ -143,10 -140,27 +143,33 @@@ static struct pmem_device *pmem_alloc(s
  	 * Map the memory as non-cachable, as we can't write back the contents
  	 * of the CPU caches in case of a crash.
  	 */
 +	err = -ENOMEM;
  	pmem->virt_addr = ioremap_nocache(pmem->phys_addr, pmem->size);
++<<<<<<< HEAD:drivers/block/pmem.c
 +	if (!pmem->virt_addr)
 +		goto out_release_region;
++=======
+ 	if (!pmem->virt_addr) {
+ 		release_mem_region(pmem->phys_addr, pmem->size);
+ 		kfree(pmem);
+ 		return ERR_PTR(-ENXIO);
+ 	}
+ 
+ 	return pmem;
+ }
+ 
+ static void pmem_detach_disk(struct pmem_device *pmem)
+ {
+ 	del_gendisk(pmem->pmem_disk);
+ 	put_disk(pmem->pmem_disk);
+ 	blk_cleanup_queue(pmem->pmem_queue);
+ }
+ 
+ static int pmem_attach_disk(struct nd_namespace_common *ndns,
+ 		struct pmem_device *pmem)
+ {
+ 	struct gendisk *disk;
++>>>>>>> 5212e11fde4d (nd_btt: atomic sector updates):drivers/nvdimm/pmem.c
  
  	pmem->pmem_queue = blk_alloc_queue(GFP_KERNEL);
  	if (!pmem->pmem_queue)
@@@ -166,25 -182,32 +189,49 @@@
  	disk->private_data	= pmem;
  	disk->queue		= pmem->pmem_queue;
  	disk->flags		= GENHD_FL_EXT_DEVT;
++<<<<<<< HEAD:drivers/block/pmem.c
 +	sprintf(disk->disk_name, "pmem%d", id);
 +	disk->driverfs_dev = dev;
++=======
+ 	nvdimm_namespace_disk_name(ndns, disk->disk_name);
+ 	disk->driverfs_dev = &ndns->dev;
++>>>>>>> 5212e11fde4d (nd_btt: atomic sector updates):drivers/nvdimm/pmem.c
  	set_capacity(disk, pmem->size >> 9);
  	pmem->pmem_disk = disk;
  
  	add_disk(disk);
  
 -	return 0;
 -}
 +	return pmem;
  
++<<<<<<< HEAD:drivers/block/pmem.c
 +out_free_queue:
 +	blk_cleanup_queue(pmem->pmem_queue);
 +out_unmap:
 +	iounmap(pmem->virt_addr);
 +out_release_region:
 +	release_mem_region(pmem->phys_addr, pmem->size);
 +out_free_dev:
 +	kfree(pmem);
 +out:
 +	return ERR_PTR(err);
++=======
+ static int pmem_rw_bytes(struct nd_namespace_common *ndns,
+ 		resource_size_t offset, void *buf, size_t size, int rw)
+ {
+ 	struct pmem_device *pmem = dev_get_drvdata(ndns->claim);
+ 
+ 	if (unlikely(offset + size > pmem->size)) {
+ 		dev_WARN_ONCE(&ndns->dev, 1, "request out of range\n");
+ 		return -EFAULT;
+ 	}
+ 
+ 	if (rw == READ)
+ 		memcpy(buf, pmem->virt_addr + offset, size);
+ 	else
+ 		memcpy(pmem->virt_addr + offset, buf, size);
+ 
+ 	return 0;
++>>>>>>> 5212e11fde4d (nd_btt: atomic sector updates):drivers/nvdimm/pmem.c
  }
  
  static void pmem_free(struct pmem_device *pmem)
* Unmerged path drivers/acpi/nfit.c
* Unmerged path drivers/block/btt.c
* Unmerged path drivers/nvdimm/Kconfig
* Unmerged path drivers/nvdimm/Makefile
* Unmerged path drivers/nvdimm/btt.h
* Unmerged path drivers/nvdimm/btt_devs.c
* Unmerged path drivers/nvdimm/namespace_devs.c
* Unmerged path drivers/nvdimm/nd.h
* Unmerged path drivers/nvdimm/region.c
* Unmerged path drivers/nvdimm/region_devs.c
* Unmerged path include/linux/libnvdimm.h
diff --git a/Documentation/nvdimm/btt.txt b/Documentation/nvdimm/btt.txt
new file mode 100644
index 000000000000..95134d5ec4a0
--- /dev/null
+++ b/Documentation/nvdimm/btt.txt
@@ -0,0 +1,273 @@
+BTT - Block Translation Table
+=============================
+
+
+1. Introduction
+---------------
+
+Persistent memory based storage is able to perform IO at byte (or more
+accurately, cache line) granularity. However, we often want to expose such
+storage as traditional block devices. The block drivers for persistent memory
+will do exactly this. However, they do not provide any atomicity guarantees.
+Traditional SSDs typically provide protection against torn sectors in hardware,
+using stored energy in capacitors to complete in-flight block writes, or perhaps
+in firmware. We don't have this luxury with persistent memory - if a write is in
+progress, and we experience a power failure, the block will contain a mix of old
+and new data. Applications may not be prepared to handle such a scenario.
+
+The Block Translation Table (BTT) provides atomic sector update semantics for
+persistent memory devices, so that applications that rely on sector writes not
+being torn can continue to do so. The BTT manifests itself as a stacked block
+device, and reserves a portion of the underlying storage for its metadata. At
+the heart of it, is an indirection table that re-maps all the blocks on the
+volume. It can be thought of as an extremely simple file system that only
+provides atomic sector updates.
+
+
+2. Static Layout
+----------------
+
+The underlying storage on which a BTT can be laid out is not limited in any way.
+The BTT, however, splits the available space into chunks of up to 512 GiB,
+called "Arenas".
+
+Each arena follows the same layout for its metadata, and all references in an
+arena are internal to it (with the exception of one field that points to the
+next arena). The following depicts the "On-disk" metadata layout:
+
+
+  Backing Store     +------->  Arena
++---------------+   |   +------------------+
+|               |   |   | Arena info block |
+|    Arena 0    +---+   |       4K         |
+|     512G      |       +------------------+
+|               |       |                  |
++---------------+       |                  |
+|               |       |                  |
+|    Arena 1    |       |   Data Blocks    |
+|     512G      |       |                  |
+|               |       |                  |
++---------------+       |                  |
+|       .       |       |                  |
+|       .       |       |                  |
+|       .       |       |                  |
+|               |       |                  |
+|               |       |                  |
++---------------+       +------------------+
+                        |                  |
+                        |     BTT Map      |
+                        |                  |
+                        |                  |
+                        +------------------+
+                        |                  |
+                        |     BTT Flog     |
+                        |                  |
+                        +------------------+
+                        | Info block copy  |
+                        |       4K         |
+                        +------------------+
+
+
+3. Theory of Operation
+----------------------
+
+
+a. The BTT Map
+--------------
+
+The map is a simple lookup/indirection table that maps an LBA to an internal
+block. Each map entry is 32 bits. The two most significant bits are special
+flags, and the remaining form the internal block number.
+
+Bit      Description
+31     : TRIM flag - marks if the block was trimmed or discarded
+30     : ERROR flag - marks an error block. Cleared on write.
+29 - 0 : Mappings to internal 'postmap' blocks
+
+
+Some of the terminology that will be subsequently used:
+
+External LBA  : LBA as made visible to upper layers.
+ABA           : Arena Block Address - Block offset/number within an arena
+Premap ABA    : The block offset into an arena, which was decided upon by range
+		checking the External LBA
+Postmap ABA   : The block number in the "Data Blocks" area obtained after
+		indirection from the map
+nfree	      : The number of free blocks that are maintained at any given time.
+		This is the number of concurrent writes that can happen to the
+		arena.
+
+
+For example, after adding a BTT, we surface a disk of 1024G. We get a read for
+the external LBA at 768G. This falls into the second arena, and of the 512G
+worth of blocks that this arena contributes, this block is at 256G. Thus, the
+premap ABA is 256G. We now refer to the map, and find out the mapping for block
+'X' (256G) points to block 'Y', say '64'. Thus the postmap ABA is 64.
+
+
+b. The BTT Flog
+---------------
+
+The BTT provides sector atomicity by making every write an "allocating write",
+i.e. Every write goes to a "free" block. A running list of free blocks is
+maintained in the form of the BTT flog. 'Flog' is a combination of the words
+"free list" and "log". The flog contains 'nfree' entries, and an entry contains:
+
+lba     : The premap ABA that is being written to
+old_map : The old postmap ABA - after 'this' write completes, this will be a
+	  free block.
+new_map : The new postmap ABA. The map will up updated to reflect this
+	  lba->postmap_aba mapping, but we log it here in case we have to
+	  recover.
+seq	: Sequence number to mark which of the 2 sections of this flog entry is
+	  valid/newest. It cycles between 01->10->11->01 (binary) under normal
+	  operation, with 00 indicating an uninitialized state.
+lba'	: alternate lba entry
+old_map': alternate old postmap entry
+new_map': alternate new postmap entry
+seq'	: alternate sequence number.
+
+Each of the above fields is 32-bit, making one entry 16 bytes. Flog updates are
+done such that for any entry being written, it:
+a. overwrites the 'old' section in the entry based on sequence numbers
+b. writes the new entry such that the sequence number is written last.
+
+
+c. The concept of lanes
+-----------------------
+
+While 'nfree' describes the number of concurrent IOs an arena can process
+concurrently, 'nlanes' is the number of IOs the BTT device as a whole can
+process.
+ nlanes = min(nfree, num_cpus)
+A lane number is obtained at the start of any IO, and is used for indexing into
+all the on-disk and in-memory data structures for the duration of the IO. It is
+protected by a spinlock.
+
+
+d. In-memory data structure: Read Tracking Table (RTT)
+------------------------------------------------------
+
+Consider a case where we have two threads, one doing reads and the other,
+writes. We can hit a condition where the writer thread grabs a free block to do
+a new IO, but the (slow) reader thread is still reading from it. In other words,
+the reader consulted a map entry, and started reading the corresponding block. A
+writer started writing to the same external LBA, and finished the write updating
+the map for that external LBA to point to its new postmap ABA. At this point the
+internal, postmap block that the reader is (still) reading has been inserted
+into the list of free blocks. If another write comes in for the same LBA, it can
+grab this free block, and start writing to it, causing the reader to read
+incorrect data. To prevent this, we introduce the RTT.
+
+The RTT is a simple, per arena table with 'nfree' entries. Every reader inserts
+into rtt[lane_number], the postmap ABA it is reading, and clears it after the
+read is complete. Every writer thread, after grabbing a free block, checks the
+RTT for its presence. If the postmap free block is in the RTT, it waits till the
+reader clears the RTT entry, and only then starts writing to it.
+
+
+e. In-memory data structure: map locks
+--------------------------------------
+
+Consider a case where two writer threads are writing to the same LBA. There can
+be a race in the following sequence of steps:
+
+free[lane] = map[premap_aba]
+map[premap_aba] = postmap_aba
+
+Both threads can update their respective free[lane] with the same old, freed
+postmap_aba. This has made the layout inconsistent by losing a free entry, and
+at the same time, duplicating another free entry for two lanes.
+
+To solve this, we could have a single map lock (per arena) that has to be taken
+before performing the above sequence, but we feel that could be too contentious.
+Instead we use an array of (nfree) map_locks that is indexed by
+(premap_aba modulo nfree).
+
+
+f. Reconstruction from the Flog
+-------------------------------
+
+On startup, we analyze the BTT flog to create our list of free blocks. We walk
+through all the entries, and for each lane, of the set of two possible
+'sections', we always look at the most recent one only (based on the sequence
+number). The reconstruction rules/steps are simple:
+- Read map[log_entry.lba].
+- If log_entry.new matches the map entry, then log_entry.old is free.
+- If log_entry.new does not match the map entry, then log_entry.new is free.
+  (This case can only be caused by power-fails/unsafe shutdowns)
+
+
+g. Summarizing - Read and Write flows
+-------------------------------------
+
+Read:
+
+1.  Convert external LBA to arena number + pre-map ABA
+2.  Get a lane (and take lane_lock)
+3.  Read map to get the entry for this pre-map ABA
+4.  Enter post-map ABA into RTT[lane]
+5.  If TRIM flag set in map, return zeroes, and end IO (go to step 8)
+6.  If ERROR flag set in map, end IO with EIO (go to step 8)
+7.  Read data from this block
+8.  Remove post-map ABA entry from RTT[lane]
+9.  Release lane (and lane_lock)
+
+Write:
+
+1.  Convert external LBA to Arena number + pre-map ABA
+2.  Get a lane (and take lane_lock)
+3.  Use lane to index into in-memory free list and obtain a new block, next flog
+        index, next sequence number
+4.  Scan the RTT to check if free block is present, and spin/wait if it is.
+5.  Write data to this free block
+6.  Read map to get the existing post-map ABA entry for this pre-map ABA
+7.  Write flog entry: [premap_aba / old postmap_aba / new postmap_aba / seq_num]
+8.  Write new post-map ABA into map.
+9.  Write old post-map entry into the free list
+10. Calculate next sequence number and write into the free list entry
+11. Release lane (and lane_lock)
+
+
+4. Error Handling
+=================
+
+An arena would be in an error state if any of the metadata is corrupted
+irrecoverably, either due to a bug or a media error. The following conditions
+indicate an error:
+- Info block checksum does not match (and recovering from the copy also fails)
+- All internal available blocks are not uniquely and entirely addressed by the
+  sum of mapped blocks and free blocks (from the BTT flog).
+- Rebuilding free list from the flog reveals missing/duplicate/impossible
+  entries
+- A map entry is out of bounds
+
+If any of these error conditions are encountered, the arena is put into a read
+only state using a flag in the info block.
+
+
+5. In-kernel usage
+==================
+
+Any block driver that supports byte granularity IO to the storage may register
+with the BTT. It will have to provide the rw_bytes interface in its
+block_device_operations struct:
+
+	int (*rw_bytes)(struct gendisk *, void *, size_t, off_t, int rw);
+
+It may register with the BTT after it adds its own gendisk, using btt_init:
+
+	struct btt *btt_init(struct gendisk *disk, unsigned long long rawsize,
+			u32 lbasize, u8 uuid[], int maxlane);
+
+note that maxlane is the maximum amount of concurrency the driver wishes to
+allow the BTT to use.
+
+The BTT 'disk' appears as a stacked block device that grabs the underlying block
+device in the O_EXCL mode.
+
+When the driver wishes to remove the backing disk, it should similarly call
+btt_fini using the same struct btt* handle that was provided to it by btt_init.
+
+	void btt_fini(struct btt *btt);
+
* Unmerged path drivers/acpi/nfit.c
* Unmerged path drivers/block/btt.c
* Unmerged path drivers/block/pmem.c
* Unmerged path drivers/nvdimm/Kconfig
* Unmerged path drivers/nvdimm/Makefile
* Unmerged path drivers/nvdimm/btt.h
* Unmerged path drivers/nvdimm/btt_devs.c
* Unmerged path drivers/nvdimm/namespace_devs.c
* Unmerged path drivers/nvdimm/nd.h
* Unmerged path drivers/nvdimm/region.c
* Unmerged path drivers/nvdimm/region_devs.c
* Unmerged path include/linux/libnvdimm.h
