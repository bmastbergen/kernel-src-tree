gfs2: Fix extended attribute readahead optimization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 23e5671a79be00b2f1c895aa93ff40fb75a4647e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/23e5671a.failed

Commit 39b0555f didn't check for a failing bio_add_page in
gfs2_submit_bhs. This could cause I/O requests to get lost, and the
affected buffer heads to stay locked forever.  Fix that by submitting
the current bio and allocating another one when bio_add_page fails.  (It
is guaranteed that we can at least add one page to a bio.)

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 23e5671a79be00b2f1c895aa93ff40fb75a4647e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/meta_io.c
diff --cc fs/gfs2/meta_io.c
index 1a80ffddabcd,373639a59782..000000000000
--- a/fs/gfs2/meta_io.c
+++ b/fs/gfs2/meta_io.c
@@@ -197,6 -187,57 +197,60 @@@ struct buffer_head *gfs2_meta_new(struc
  	return bh;
  }
  
++<<<<<<< HEAD
++=======
+ static void gfs2_meta_read_endio(struct bio *bio)
+ {
+ 	struct bio_vec *bvec;
+ 	int i;
+ 
+ 	bio_for_each_segment_all(bvec, bio, i) {
+ 		struct page *page = bvec->bv_page;
+ 		struct buffer_head *bh = page_buffers(page);
+ 		unsigned int len = bvec->bv_len;
+ 
+ 		while (bh_offset(bh) < bvec->bv_offset)
+ 			bh = bh->b_this_page;
+ 		do {
+ 			struct buffer_head *next = bh->b_this_page;
+ 			len -= bh->b_size;
+ 			bh->b_end_io(bh, !bio->bi_error);
+ 			bh = next;
+ 		} while (bh && len);
+ 	}
+ 	bio_put(bio);
+ }
+ 
+ /*
+  * Submit several consecutive buffer head I/O requests as a single bio I/O
+  * request.  (See submit_bh_wbc.)
+  */
+ static void gfs2_submit_bhs(int op, int op_flags, struct buffer_head *bhs[],
+ 			    int num)
+ {
+ 	while (num > 0) {
+ 		struct buffer_head *bh = *bhs;
+ 		struct bio *bio;
+ 
+ 		bio = bio_alloc(GFP_NOIO, num);
+ 		bio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);
+ 		bio->bi_bdev = bh->b_bdev;
+ 		while (num > 0) {
+ 			bh = *bhs;
+ 			if (!bio_add_page(bio, bh->b_page, bh->b_size, bh_offset(bh))) {
+ 				BUG_ON(bio->bi_iter.bi_size == 0);
+ 				break;
+ 			}
+ 			bhs++;
+ 			num--;
+ 		}
+ 		bio->bi_end_io = gfs2_meta_read_endio;
+ 		bio_set_op_attrs(bio, op, op_flags);
+ 		submit_bio(bio);
+ 	}
+ }
+ 
++>>>>>>> 23e5671a79be (gfs2: Fix extended attribute readahead optimization)
  /**
   * gfs2_meta_read - Read a block from disk
   * @gl: The glock covering the block
* Unmerged path fs/gfs2/meta_io.c
