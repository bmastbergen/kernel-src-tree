dax: give DAX clearing code correct bdev

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ross Zwisler <ross.zwisler@linux.intel.com>
commit 20a90f58997245749c2bdfaea9e51f785ec90d0b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/20a90f58.failed

dax_clear_blocks() needs a valid struct block_device and previously it
was using inode->i_sb->s_bdev in all cases.  This is correct for normal
inodes on mounted ext2, ext4 and XFS filesystems, but is incorrect for
DAX raw block devices and for XFS real-time devices.

Instead, rename dax_clear_blocks() to dax_clear_sectors(), and change
its arguments to take a bdev and a sector instead of an inode and a
block.  This better reflects what the function does, and it allows the
filesystem and raw block device code to pass in an appropriate struct
block_device.

	Signed-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Suggested-by: Dan Williams <dan.j.williams@intel.com>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Cc: Theodore Ts'o <tytso@mit.edu>
	Cc: Al Viro <viro@ftp.linux.org.uk>
	Cc: Dave Chinner <david@fromorbit.com>
	Cc: Jens Axboe <axboe@fb.com>
	Cc: Matthew Wilcox <matthew.r.wilcox@intel.com>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: Theodore Ts'o <tytso@mit.edu>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 20a90f58997245749c2bdfaea9e51f785ec90d0b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
#	fs/ext2/inode.c
#	include/linux/dax.h
diff --cc fs/ext2/inode.c
index 115fa58bb9ae,4467cbd75f24..000000000000
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@@ -729,12 -731,16 +729,19 @@@ static int ext2_get_blocks(struct inod
  		goto cleanup;
  	}
  
 -	if (IS_DAX(inode)) {
 +	if (ext2_use_xip(inode->i_sb)) {
  		/*
 -		 * block must be initialised before we put it in the tree
 -		 * so that it's not found by another thread before it's
 -		 * initialised
 +		 * we need to clear the block
  		 */
++<<<<<<< HEAD
 +		err = ext2_clear_xip_target (inode,
 +			le32_to_cpu(chain[depth-1].key));
++=======
+ 		err = dax_clear_sectors(inode->i_sb->s_bdev,
+ 				le32_to_cpu(chain[depth-1].key) <<
+ 				(inode->i_blkbits - 9),
+ 				1 << inode->i_blkbits);
++>>>>>>> 20a90f589972 (dax: give DAX clearing code correct bdev)
  		if (err) {
  			mutex_unlock(&ei->truncate_mutex);
  			goto cleanup;
* Unmerged path fs/dax.c
* Unmerged path include/linux/dax.h
* Unmerged path fs/dax.c
* Unmerged path fs/ext2/inode.c
diff --git a/fs/xfs/xfs_aops.c b/fs/xfs/xfs_aops.c
index 3ffbdb7cbd8f..8cebaf135006 100644
--- a/fs/xfs/xfs_aops.c
+++ b/fs/xfs/xfs_aops.c
@@ -56,7 +56,7 @@ xfs_count_page_state(
 	} while ((bh = bh->b_this_page) != head);
 }
 
-STATIC struct block_device *
+struct block_device *
 xfs_find_bdev_for_inode(
 	struct inode		*inode)
 {
diff --git a/fs/xfs/xfs_aops.h b/fs/xfs/xfs_aops.h
index c325abb8d61a..30245fa6786f 100644
--- a/fs/xfs/xfs_aops.h
+++ b/fs/xfs/xfs_aops.h
@@ -62,5 +62,6 @@ extern const struct address_space_operations xfs_address_space_operations;
 extern int xfs_get_blocks(struct inode *, sector_t, struct buffer_head *, int);
 
 extern void xfs_count_page_state(struct page *, int *, int *);
+extern struct block_device *xfs_find_bdev_for_inode(struct inode *);
 
 #endif /* __XFS_AOPS_H__ */
diff --git a/fs/xfs/xfs_bmap_util.c b/fs/xfs/xfs_bmap_util.c
index 46a10471d0d7..364b5960f53c 100644
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@ -75,7 +75,8 @@ xfs_zero_extent(
 	ssize_t		size = XFS_FSB_TO_B(mp, count_fsb);
 
 	if (IS_DAX(VFS_I(ip)))
-		return dax_clear_blocks(VFS_I(ip), block, size);
+		return dax_clear_sectors(xfs_find_bdev_for_inode(VFS_I(ip)),
+				sector, size);
 
 	/*
 	 * let the block layer decide on the fastest method of
* Unmerged path include/linux/dax.h
