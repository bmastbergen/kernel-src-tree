ipv6: Add rt6_make_pcpu_route()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit a73e4195636c17f310b8530643a576f42b82385f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a73e4195.failed

It is a prep work for fixing a potential deadlock when creating
a pcpu rt.

The current rt6_get_pcpu_route() will also create a pcpu rt if one does not
exist.  This patch moves the pcpu rt creation logic into another function,
rt6_make_pcpu_route().

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
CC: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a73e4195636c17f310b8530643a576f42b82385f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/route.c
diff --cc net/ipv6/route.c
index e3cf3592b9d2,0a82653efc88..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -908,6 -975,62 +908,65 @@@ static struct rt6_info *ip6_rt_cache_al
  	return rt;
  }
  
++<<<<<<< HEAD
++=======
+ static struct rt6_info *ip6_rt_pcpu_alloc(struct rt6_info *rt)
+ {
+ 	struct rt6_info *pcpu_rt;
+ 
+ 	pcpu_rt = __ip6_dst_alloc(dev_net(rt->dst.dev),
+ 				  rt->dst.dev, rt->dst.flags);
+ 
+ 	if (!pcpu_rt)
+ 		return NULL;
+ 	ip6_rt_copy_init(pcpu_rt, rt);
+ 	pcpu_rt->rt6i_protocol = rt->rt6i_protocol;
+ 	pcpu_rt->rt6i_flags |= RTF_PCPU;
+ 	return pcpu_rt;
+ }
+ 
+ /* It should be called with read_lock_bh(&tb6_lock) acquired */
+ static struct rt6_info *rt6_get_pcpu_route(struct rt6_info *rt)
+ {
+ 	struct rt6_info *pcpu_rt, **p;
+ 
+ 	p = this_cpu_ptr(rt->rt6i_pcpu);
+ 	pcpu_rt = *p;
+ 
+ 	if (pcpu_rt) {
+ 		dst_hold(&pcpu_rt->dst);
+ 		rt6_dst_from_metrics_check(pcpu_rt);
+ 	}
+ 	return pcpu_rt;
+ }
+ 
+ static struct rt6_info *rt6_make_pcpu_route(struct rt6_info *rt)
+ {
+ 	struct rt6_info *pcpu_rt, *prev, **p;
+ 
+ 	pcpu_rt = ip6_rt_pcpu_alloc(rt);
+ 	if (!pcpu_rt) {
+ 		struct net *net = dev_net(rt->dst.dev);
+ 
+ 		pcpu_rt = net->ipv6.ip6_null_entry;
+ 		goto done;
+ 	}
+ 
+ 	p = this_cpu_ptr(rt->rt6i_pcpu);
+ 	prev = cmpxchg(p, NULL, pcpu_rt);
+ 	if (prev) {
+ 		/* If someone did it before us, return prev instead */
+ 		dst_destroy(&pcpu_rt->dst);
+ 		pcpu_rt = prev;
+ 	}
+ 
+ done:
+ 	dst_hold(&pcpu_rt->dst);
+ 	rt6_dst_from_metrics_check(pcpu_rt);
+ 	return pcpu_rt;
+ }
+ 
++>>>>>>> a73e4195636c (ipv6: Add rt6_make_pcpu_route())
  static struct rt6_info *ip6_pol_route(struct net *net, struct fib6_table *table, int oif,
  				      struct flowi6 *fl6, int flags)
  {
@@@ -947,43 -1063,52 +1006,74 @@@ redo_rt6_select
  		}
  	}
  
 +	dst_hold(&rt->dst);
 +	read_unlock_bh(&table->tb6_lock);
  
 -	if (rt == net->ipv6.ip6_null_entry || (rt->rt6i_flags & RTF_CACHE)) {
 -		dst_use(&rt->dst, jiffies);
 -		read_unlock_bh(&table->tb6_lock);
 +	if (rt->rt6i_flags & RTF_CACHE)
 +		goto out2;
  
 -		rt6_dst_from_metrics_check(rt);
 -		return rt;
 -	} else if (unlikely((fl6->flowi6_flags & FLOWI_FLAG_KNOWN_NH) &&
 -			    !(rt->rt6i_flags & RTF_GATEWAY))) {
 -		/* Create a RTF_CACHE clone which will not be
 -		 * owned by the fib6 tree.  It is for the special case where
 -		 * the daddr in the skb during the neighbor look-up is different
 -		 * from the fl6->daddr used to look-up route here.
 -		 */
 +	if (!rt6_is_gw_or_nonexthop(rt) ||
 +	    !(rt->dst.flags & DST_HOST) || !(rt->rt6i_flags & RTF_LOCAL))
 +		nrt = ip6_rt_cache_alloc(rt, &fl6->daddr, &fl6->saddr);
 +	else
 +		goto out2;
  
 -		struct rt6_info *uncached_rt;
 +	ip6_rt_put(rt);
 +	rt = nrt ? : net->ipv6.ip6_null_entry;
  
++<<<<<<< HEAD
 +	dst_hold(&rt->dst);
 +	if (nrt) {
 +		err = ip6_ins_rt(nrt);
 +		if (!err)
 +			goto out2;
++=======
+ 		dst_use(&rt->dst, jiffies);
+ 		read_unlock_bh(&table->tb6_lock);
+ 
+ 		uncached_rt = ip6_rt_cache_alloc(rt, &fl6->daddr, NULL);
+ 		dst_release(&rt->dst);
+ 
+ 		if (uncached_rt)
+ 			rt6_uncached_list_add(uncached_rt);
+ 		else
+ 			uncached_rt = net->ipv6.ip6_null_entry;
+ 
+ 		dst_hold(&uncached_rt->dst);
+ 		return uncached_rt;
+ 
+ 	} else {
+ 		/* Get a percpu copy */
+ 
+ 		struct rt6_info *pcpu_rt;
+ 
+ 		rt->dst.lastuse = jiffies;
+ 		rt->dst.__use++;
+ 		pcpu_rt = rt6_get_pcpu_route(rt);
+ 
+ 		if (!pcpu_rt)
+ 			pcpu_rt = rt6_make_pcpu_route(rt);
+ 
+ 		read_unlock_bh(&table->tb6_lock);
+ 		return pcpu_rt;
++>>>>>>> a73e4195636c (ipv6: Add rt6_make_pcpu_route())
  	}
 +
 +	if (--attempts <= 0)
 +		goto out2;
 +
 +	/*
 +	 * Race condition! In the gap, when table->tb6_lock was
 +	 * released someone could insert this route.  Relookup.
 +	 */
 +	ip6_rt_put(rt);
 +	goto redo_fib6_lookup_lock;
 +
 +out2:
 +	rt->dst.lastuse = jiffies;
 +	rt->dst.__use++;
 +
 +	return rt;
  }
  
  static struct rt6_info *ip6_pol_route_input(struct net *net, struct fib6_table *table,
* Unmerged path net/ipv6/route.c
