perf report: Left align dynamic entries in hierarchy

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit cb1fab917206f822d1f905cbc45971eefdef361d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/cb1fab91.failed

The dynamic entries are right-aligned unlike other entries since it
usually has numeric value.  But for the hierarchy mode, left alignment
is more appropriate IMHO.  Also trim spaces on the left so that we can
easily identify the hierarchy.

Before:

  $ perf report --hierarchy -i perf.data.kmem -s gfp_flags,ptr,bytes_req --stdio -g none
  ...
  #
  #       Overhead                                        gfp_flags /                ptr /          bytes_req
  # ..............  .................................................................................................
  #
      91.67%                   GFP_ATOMIC|GFP_NOWARN|GFP_NOMEMALLOC
         37.50%        0xffff8803f7669400
            37.50%                       448
          8.33%        0xffff8803f766be00
             8.33%                        96
          4.17%        0xffff8800d156dc00
             4.17%                       704

After:

  #       Overhead  gfp_flags / ptr / bytes_req
  # ..............  ....................................
  #
      91.67%        GFP_ATOMIC|GFP_NOWARN|GFP_NOMEMALLOC
         37.50%        0xffff8803f7669400
            37.50%        448
          8.33%        0xffff8803f766be00
             8.33%        96
          4.17%        0xffff8800d156dc00
             4.17%        704

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1456512767-1164-3-git-send-email-namhyung@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit cb1fab917206f822d1f905cbc45971eefdef361d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/ui/browsers/hists.c
#	tools/perf/ui/stdio/hist.c
diff --cc tools/perf/ui/browsers/hists.c
index d1445dd5bb7f,5ffffcb1e3c5..000000000000
--- a/tools/perf/ui/browsers/hists.c
+++ b/tools/perf/ui/browsers/hists.c
@@@ -1213,6 -1277,232 +1213,235 @@@ static int hist_browser__show_entry(str
  	return printed;
  }
  
++<<<<<<< HEAD
++=======
+ static int hist_browser__show_hierarchy_entry(struct hist_browser *browser,
+ 					      struct hist_entry *entry,
+ 					      unsigned short row,
+ 					      int level, int nr_sort_keys)
+ {
+ 	int printed = 0;
+ 	int width = browser->b.width;
+ 	char folded_sign = ' ';
+ 	bool current_entry = ui_browser__is_current_entry(&browser->b, row);
+ 	off_t row_offset = entry->row_offset;
+ 	bool first = true;
+ 	struct perf_hpp_fmt *fmt;
+ 	struct hpp_arg arg = {
+ 		.b		= &browser->b,
+ 		.current_entry	= current_entry,
+ 	};
+ 	int column = 0;
+ 	int hierarchy_indent = (nr_sort_keys - 1) * HIERARCHY_INDENT;
+ 
+ 	if (current_entry) {
+ 		browser->he_selection = entry;
+ 		browser->selection = &entry->ms;
+ 	}
+ 
+ 	hist_entry__init_have_children(entry);
+ 	folded_sign = hist_entry__folded(entry);
+ 	arg.folded_sign = folded_sign;
+ 
+ 	if (entry->leaf && row_offset) {
+ 		row_offset--;
+ 		goto show_callchain;
+ 	}
+ 
+ 	hist_browser__gotorc(browser, row, 0);
+ 
+ 	if (current_entry && browser->b.navkeypressed)
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_SELECTED);
+ 	else
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_NORMAL);
+ 
+ 	ui_browser__write_nstring(&browser->b, "", level * HIERARCHY_INDENT);
+ 	width -= level * HIERARCHY_INDENT;
+ 
+ 	hists__for_each_format(entry->hists, fmt) {
+ 		char s[2048];
+ 		struct perf_hpp hpp = {
+ 			.buf		= s,
+ 			.size		= sizeof(s),
+ 			.ptr		= &arg,
+ 		};
+ 
+ 		if (perf_hpp__should_skip(fmt, entry->hists) ||
+ 		    column++ < browser->b.horiz_scroll)
+ 			continue;
+ 
+ 		if (perf_hpp__is_sort_entry(fmt) ||
+ 		    perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		if (current_entry && browser->b.navkeypressed) {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_SELECTED);
+ 		} else {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_NORMAL);
+ 		}
+ 
+ 		if (first) {
+ 			ui_browser__printf(&browser->b, "%c", folded_sign);
+ 			width--;
+ 			first = false;
+ 		} else {
+ 			ui_browser__printf(&browser->b, "  ");
+ 			width -= 2;
+ 		}
+ 
+ 		if (fmt->color) {
+ 			int ret = fmt->color(fmt, &hpp, entry);
+ 			hist_entry__snprintf_alignment(entry, &hpp, fmt, ret);
+ 			/*
+ 			 * fmt->color() already used ui_browser to
+ 			 * print the non alignment bits, skip it (+ret):
+ 			 */
+ 			ui_browser__printf(&browser->b, "%s", s + ret);
+ 		} else {
+ 			int ret = fmt->entry(fmt, &hpp, entry);
+ 			hist_entry__snprintf_alignment(entry, &hpp, fmt, ret);
+ 			ui_browser__printf(&browser->b, "%s", s);
+ 		}
+ 		width -= hpp.buf - s;
+ 	}
+ 
+ 	ui_browser__write_nstring(&browser->b, "", hierarchy_indent);
+ 	width -= hierarchy_indent;
+ 
+ 	if (column >= browser->b.horiz_scroll) {
+ 		char s[2048];
+ 		struct perf_hpp hpp = {
+ 			.buf		= s,
+ 			.size		= sizeof(s),
+ 			.ptr		= &arg,
+ 		};
+ 
+ 		if (current_entry && browser->b.navkeypressed) {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_SELECTED);
+ 		} else {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_NORMAL);
+ 		}
+ 
+ 		ui_browser__write_nstring(&browser->b, "", 2);
+ 		width -= 2;
+ 
+ 		/*
+ 		 * No need to call hist_entry__snprintf_alignment()
+ 		 * since this fmt is always the last column in the
+ 		 * hierarchy mode.
+ 		 */
+ 		fmt = entry->fmt;
+ 		if (fmt->color) {
+ 			width -= fmt->color(fmt, &hpp, entry);
+ 		} else {
+ 			int i = 0;
+ 
+ 			width -= fmt->entry(fmt, &hpp, entry);
+ 			ui_browser__printf(&browser->b, "%s", ltrim(s));
+ 
+ 			while (isspace(s[i++]))
+ 				width++;
+ 		}
+ 	}
+ 
+ 	/* The scroll bar isn't being used */
+ 	if (!browser->b.navkeypressed)
+ 		width += 1;
+ 
+ 	ui_browser__write_nstring(&browser->b, "", width);
+ 
+ 	++row;
+ 	++printed;
+ 
+ show_callchain:
+ 	if (entry->leaf && folded_sign == '-' && row != browser->b.rows) {
+ 		struct callchain_print_arg carg = {
+ 			.row_offset = row_offset,
+ 		};
+ 
+ 		printed += hist_browser__show_callchain(browser, entry,
+ 					level + 1, row,
+ 					hist_browser__show_callchain_entry, &carg,
+ 					hist_browser__check_output_full);
+ 	}
+ 
+ 	return printed;
+ }
+ 
+ static int hist_browser__show_no_entry(struct hist_browser *browser,
+ 				       unsigned short row,
+ 				       int level, int nr_sort_keys)
+ {
+ 	int width = browser->b.width;
+ 	bool current_entry = ui_browser__is_current_entry(&browser->b, row);
+ 	bool first = true;
+ 	int column = 0;
+ 	int ret;
+ 	struct perf_hpp_fmt *fmt;
+ 
+ 	if (current_entry) {
+ 		browser->he_selection = NULL;
+ 		browser->selection = NULL;
+ 	}
+ 
+ 	hist_browser__gotorc(browser, row, 0);
+ 
+ 	if (current_entry && browser->b.navkeypressed)
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_SELECTED);
+ 	else
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_NORMAL);
+ 
+ 	ui_browser__write_nstring(&browser->b, "", level * HIERARCHY_INDENT);
+ 	width -= level * HIERARCHY_INDENT;
+ 
+ 	hists__for_each_format(browser->hists, fmt) {
+ 		if (perf_hpp__should_skip(fmt, browser->hists) ||
+ 		    column++ < browser->b.horiz_scroll)
+ 			continue;
+ 
+ 		if (perf_hpp__is_sort_entry(fmt) ||
+ 		    perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		ret = fmt->width(fmt, NULL, hists_to_evsel(browser->hists));
+ 
+ 		if (first) {
+ 			/* for folded sign */
+ 			first = false;
+ 			ret++;
+ 		} else {
+ 			/* space between columns */
+ 			ret += 2;
+ 		}
+ 
+ 		ui_browser__write_nstring(&browser->b, "", ret);
+ 		width -= ret;
+ 	}
+ 
+ 	ui_browser__write_nstring(&browser->b, "", nr_sort_keys * HIERARCHY_INDENT);
+ 	width -= nr_sort_keys * HIERARCHY_INDENT;
+ 
+ 	if (column >= browser->b.horiz_scroll) {
+ 		char buf[32];
+ 
+ 		ret = snprintf(buf, sizeof(buf), "no entry >= %.2f%%", browser->min_pcnt);
+ 		ui_browser__printf(&browser->b, "  %s", buf);
+ 		width -= ret + 2;
+ 	}
+ 
+ 	/* The scroll bar isn't being used */
+ 	if (!browser->b.navkeypressed)
+ 		width += 1;
+ 
+ 	ui_browser__write_nstring(&browser->b, "", width);
+ 	return 1;
+ }
+ 
++>>>>>>> cb1fab917206 (perf report: Left align dynamic entries in hierarchy)
  static int advance_hpp_check(struct perf_hpp *hpp, int inc)
  {
  	advance_hpp(hpp, inc);
diff --cc tools/perf/ui/stdio/hist.c
index 28fcb1ee0342,6d06fbb365b6..000000000000
--- a/tools/perf/ui/stdio/hist.c
+++ b/tools/perf/ui/stdio/hist.c
@@@ -409,6 -410,86 +409,89 @@@ static int hist_entry__snprintf(struct 
  	return hpp->buf - start;
  }
  
++<<<<<<< HEAD
++=======
+ static int hist_entry__hierarchy_fprintf(struct hist_entry *he,
+ 					 struct perf_hpp *hpp,
+ 					 int nr_sort_key, struct hists *hists,
+ 					 FILE *fp)
+ {
+ 	const char *sep = symbol_conf.field_sep;
+ 	struct perf_hpp_fmt *fmt;
+ 	char *buf = hpp->buf;
+ 	size_t size = hpp->size;
+ 	int ret, printed = 0;
+ 	bool first = true;
+ 
+ 	if (symbol_conf.exclude_other && !he->parent)
+ 		return 0;
+ 
+ 	ret = scnprintf(hpp->buf, hpp->size, "%*s", he->depth * HIERARCHY_INDENT, "");
+ 	advance_hpp(hpp, ret);
+ 
+ 	hists__for_each_format(he->hists, fmt) {
+ 		if (perf_hpp__is_sort_entry(fmt) || perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		/*
+ 		 * If there's no field_sep, we still need
+ 		 * to display initial '  '.
+ 		 */
+ 		if (!sep || !first) {
+ 			ret = scnprintf(hpp->buf, hpp->size, "%s", sep ?: "  ");
+ 			advance_hpp(hpp, ret);
+ 		} else
+ 			first = false;
+ 
+ 		if (perf_hpp__use_color() && fmt->color)
+ 			ret = fmt->color(fmt, hpp, he);
+ 		else
+ 			ret = fmt->entry(fmt, hpp, he);
+ 
+ 		ret = hist_entry__snprintf_alignment(he, hpp, fmt, ret);
+ 		advance_hpp(hpp, ret);
+ 	}
+ 
+ 	if (sep)
+ 		ret = scnprintf(hpp->buf, hpp->size, "%s", sep);
+ 	else
+ 		ret = scnprintf(hpp->buf, hpp->size, "%*s",
+ 				(nr_sort_key - 1) * HIERARCHY_INDENT + 2, "");
+ 	advance_hpp(hpp, ret);
+ 
+ 	printed += fprintf(fp, "%s", buf);
+ 
+ 	hpp->buf  = buf;
+ 	hpp->size = size;
+ 
+ 	/*
+ 	 * No need to call hist_entry__snprintf_alignment() since this
+ 	 * fmt is always the last column in the hierarchy mode.
+ 	 */
+ 	fmt = he->fmt;
+ 	if (perf_hpp__use_color() && fmt->color)
+ 		fmt->color(fmt, hpp, he);
+ 	else
+ 		fmt->entry(fmt, hpp, he);
+ 
+ 	/*
+ 	 * dynamic entries are right-aligned but we want left-aligned
+ 	 * in the hierarchy mode
+ 	 */
+ 	printed += fprintf(fp, "%s\n", ltrim(buf));
+ 
+ 	if (symbol_conf.use_callchain && he->leaf) {
+ 		u64 total = hists__total_period(hists);
+ 
+ 		printed += hist_entry_callchain__fprintf(he, total, 0, fp);
+ 		goto out;
+ 	}
+ 
+ out:
+ 	return printed;
+ }
+ 
++>>>>>>> cb1fab917206 (perf report: Left align dynamic entries in hierarchy)
  static int hist_entry__fprintf(struct hist_entry *he, size_t size,
  			       struct hists *hists,
  			       char *bf, size_t bfsz, FILE *fp)
@@@ -433,6 -521,106 +516,109 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int print_hierarchy_indent(const char *sep, int nr_sort,
+ 				  const char *line, FILE *fp)
+ {
+ 	if (sep != NULL || nr_sort < 1)
+ 		return 0;
+ 
+ 	return fprintf(fp, "%-.*s", (nr_sort - 1) * HIERARCHY_INDENT, line);
+ }
+ 
+ static int print_hierarchy_header(struct hists *hists, struct perf_hpp *hpp,
+ 				  const char *sep, FILE *fp)
+ {
+ 	bool first = true;
+ 	int nr_sort;
+ 	int depth;
+ 	unsigned width = 0;
+ 	unsigned header_width = 0;
+ 	struct perf_hpp_fmt *fmt;
+ 
+ 	nr_sort = hists->nr_sort_keys;
+ 
+ 	/* preserve max indent depth for column headers */
+ 	print_hierarchy_indent(sep, nr_sort, spaces, fp);
+ 
+ 	hists__for_each_format(hists, fmt) {
+ 		if (perf_hpp__is_sort_entry(fmt) || perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		if (!first)
+ 			fprintf(fp, "%s", sep ?: "  ");
+ 		else
+ 			first = false;
+ 
+ 		fmt->header(fmt, hpp, hists_to_evsel(hists));
+ 		fprintf(fp, "%s", hpp->buf);
+ 	}
+ 
+ 	/* combine sort headers with ' / ' */
+ 	first = true;
+ 	hists__for_each_format(hists, fmt) {
+ 		if (!perf_hpp__is_sort_entry(fmt) && !perf_hpp__is_dynamic_entry(fmt))
+ 			continue;
+ 		if (perf_hpp__should_skip(fmt, hists))
+ 			continue;
+ 
+ 		if (!first)
+ 			header_width += fprintf(fp, " / ");
+ 		else {
+ 			fprintf(fp, "%s", sep ?: "  ");
+ 			first = false;
+ 		}
+ 
+ 		fmt->header(fmt, hpp, hists_to_evsel(hists));
+ 		rtrim(hpp->buf);
+ 
+ 		header_width += fprintf(fp, "%s", ltrim(hpp->buf));
+ 	}
+ 
+ 	fprintf(fp, "\n# ");
+ 
+ 	/* preserve max indent depth for initial dots */
+ 	print_hierarchy_indent(sep, nr_sort, dots, fp);
+ 
+ 	first = true;
+ 	hists__for_each_format(hists, fmt) {
+ 		if (perf_hpp__is_sort_entry(fmt) || perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		if (!first)
+ 			fprintf(fp, "%s", sep ?: "  ");
+ 		else
+ 			first = false;
+ 
+ 		width = fmt->width(fmt, hpp, hists_to_evsel(hists));
+ 		fprintf(fp, "%.*s", width, dots);
+ 	}
+ 
+ 	depth = 0;
+ 	hists__for_each_format(hists, fmt) {
+ 		if (!perf_hpp__is_sort_entry(fmt) && !perf_hpp__is_dynamic_entry(fmt))
+ 			continue;
+ 		if (perf_hpp__should_skip(fmt, hists))
+ 			continue;
+ 
+ 		width = fmt->width(fmt, hpp, hists_to_evsel(hists));
+ 		width += depth * HIERARCHY_INDENT;
+ 
+ 		if (width > header_width)
+ 			header_width = width;
+ 
+ 		depth++;
+ 	}
+ 
+ 	fprintf(fp, "%s%-.*s", sep ?: "  ", header_width, dots);
+ 
+ 	fprintf(fp, "\n#\n");
+ 
+ 	return 2;
+ }
+ 
++>>>>>>> cb1fab917206 (perf report: Left align dynamic entries in hierarchy)
  size_t hists__fprintf(struct hists *hists, bool show_header, int max_rows,
  		      int max_cols, float min_pcnt, FILE *fp)
  {
* Unmerged path tools/perf/ui/browsers/hists.c
* Unmerged path tools/perf/ui/stdio/hist.c
