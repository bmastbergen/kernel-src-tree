hv_netvsc: Wait for sub-channels to be processed during probe

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author KY Srinivasan <kys@microsoft.com>
commit b3e6b82a0099dfef038e40c630a554ed1e402504
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b3e6b82a.failed

The current code returns from probe without waiting for the proper handling
of subchannels that may be requested. If the netvsc driver were to be rapidly
loaded/unloaded, we can  trigger a panic as the unload will be tearing
down state that may not have been fully setup yet. We fix this issue by making
sure that we return from the probe call only after ensuring that the
sub-channel offers in flight are properly handled.

Reviewed-and-tested-by: Haiyang Zhang <haiyangz@microsoft.com
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b3e6b82a0099dfef038e40c630a554ed1e402504)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/rndis_filter.c
diff --cc drivers/net/hyperv/rndis_filter.c
index 4f78abd49222,9b8263db49cc..000000000000
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@@ -1020,6 -1021,11 +1027,14 @@@ int rndis_filter_device_add(struct hv_d
  	struct ndis_recv_scale_cap rsscap;
  	u32 rsscap_size = sizeof(struct ndis_recv_scale_cap);
  	u32 mtu, size;
++<<<<<<< HEAD
++=======
+ 	u32 num_rss_qs;
+ 	u32 sc_delta;
+ 	const struct cpumask *node_cpu_mask;
+ 	u32 num_possible_rss_qs;
+ 	unsigned long flags;
++>>>>>>> b3e6b82a0099 (hv_netvsc: Wait for sub-channels to be processed during probe)
  
  	rndis_device = get_rndis_device();
  	if (!rndis_device)
@@@ -1107,9 -1115,21 +1124,24 @@@
  	if (ret || rsscap.num_recv_que < 2)
  		goto out;
  
 -	num_rss_qs = min(device_info->max_num_vrss_chns, rsscap.num_recv_que);
 -
  	net_device->max_chn = rsscap.num_recv_que;
++<<<<<<< HEAD
 +	net_device->num_chn = (num_online_cpus() < rsscap.num_recv_que) ?
 +			       num_online_cpus() : rsscap.num_recv_que;
++=======
+ 
+ 	/*
+ 	 * We will limit the VRSS channels to the number CPUs in the NUMA node
+ 	 * the primary channel is currently bound to.
+ 	 */
+ 	node_cpu_mask = cpumask_of_node(cpu_to_node(dev->channel->target_cpu));
+ 	num_possible_rss_qs = cpumask_weight(node_cpu_mask);
+ 	net_device->num_chn = min(num_possible_rss_qs, num_rss_qs);
+ 
+ 	num_rss_qs = net_device->num_chn - 1;
+ 	net_device->num_sc_offered = num_rss_qs;
+ 
++>>>>>>> b3e6b82a0099 (hv_netvsc: Wait for sub-channels to be processed during probe)
  	if (net_device->num_chn == 1)
  		goto out;
  
diff --git a/drivers/net/hyperv/hyperv_net.h b/drivers/net/hyperv/hyperv_net.h
index cf498664d989..dec9dad365c0 100644
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@ -636,6 +636,8 @@ struct netvsc_device {
 	u32 send_table[VRSS_SEND_TAB_SIZE];
 	u32 max_chn;
 	u32 num_chn;
+	spinlock_t sc_lock; /* Protects num_sc_offered variable */
+	u32 num_sc_offered;
 	atomic_t queue_sends[NR_CPUS];
 
 	/* Holds rndis device info */
* Unmerged path drivers/net/hyperv/rndis_filter.c
