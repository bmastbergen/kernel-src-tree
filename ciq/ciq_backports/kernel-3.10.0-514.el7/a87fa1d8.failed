of: Fix overflow bug in string property parsing functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [sound] alsa: of: Fix overflow bug in string property parsing functions (Jaroslav Kysela) [1220299]
Rebuild_FUZZ: 95.00%
commit-author Grant Likely <grant.likely@linaro.org>
commit a87fa1d81a9fb5e9adca9820e16008c40ad09f33
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a87fa1d8.failed

The string property read helpers will run off the end of the buffer if
it is handed a malformed string property. Rework the parsers to make
sure that doesn't happen. At the same time add new test cases to make
sure the functions behave themselves.

The original implementations of of_property_read_string_index() and
of_property_count_strings() both open-coded the same block of parsing
code, each with it's own subtly different bugs. The fix here merges
functions into a single helper and makes the original functions static
inline wrappers around the helper.

One non-bugfix aspect of this patch is the addition of a new wrapper,
of_property_read_string_array(). The new wrapper is needed by the
device_properties feature that Rafael is working on and planning to
merge for v3.19. The implementation is identical both with and without
the new static inline wrapper, so it just got left in to reduce the
churn on the header file.

	Signed-off-by: Grant Likely <grant.likely@linaro.org>
	Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
	Cc: Rob Herring <robh+dt@kernel.org>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Darren Hart <darren.hart@intel.com>
	Cc: <stable@vger.kernel.org>  # v3.3+: Drop selftest hunks that don't apply
(cherry picked from commit a87fa1d81a9fb5e9adca9820e16008c40ad09f33)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/of/selftest.c
diff --cc drivers/of/selftest.c
index 0eb5c38b4e07,11b873c54a77..000000000000
--- a/drivers/of/selftest.c
+++ b/drivers/of/selftest.c
@@@ -145,15 -358,560 +146,68 @@@ static void __init of_selftest_property
  	rc = of_property_match_string(np, "phandle-list-names", "third");
  	selftest(rc == 2, "third expected:0 got:%i\n", rc);
  	rc = of_property_match_string(np, "phandle-list-names", "fourth");
- 	selftest(rc == -ENODATA, "unmatched string; rc=%i", rc);
+ 	selftest(rc == -ENODATA, "unmatched string; rc=%i\n", rc);
  	rc = of_property_match_string(np, "missing-property", "blah");
- 	selftest(rc == -EINVAL, "missing property; rc=%i", rc);
+ 	selftest(rc == -EINVAL, "missing property; rc=%i\n", rc);
  	rc = of_property_match_string(np, "empty-property", "blah");
- 	selftest(rc == -ENODATA, "empty property; rc=%i", rc);
+ 	selftest(rc == -ENODATA, "empty property; rc=%i\n", rc);
  	rc = of_property_match_string(np, "unterminated-string", "blah");
- 	selftest(rc == -EILSEQ, "unterminated string; rc=%i", rc);
+ 	selftest(rc == -EILSEQ, "unterminated string; rc=%i\n", rc);
+ 
+ 	/* of_property_count_strings() tests */
+ 	rc = of_property_count_strings(np, "string-property");
+ 	selftest(rc == 1, "Incorrect string count; rc=%i\n", rc);
+ 	rc = of_property_count_strings(np, "phandle-list-names");
+ 	selftest(rc == 3, "Incorrect string count; rc=%i\n", rc);
+ 	rc = of_property_count_strings(np, "unterminated-string");
+ 	selftest(rc == -EILSEQ, "unterminated string; rc=%i\n", rc);
+ 	rc = of_property_count_strings(np, "unterminated-string-list");
+ 	selftest(rc == -EILSEQ, "unterminated string array; rc=%i\n", rc);
+ 
+ 	/* of_property_read_string_index() tests */
+ 	rc = of_property_read_string_index(np, "string-property", 0, strings);
+ 	selftest(rc == 0 && !strcmp(strings[0], "foobar"), "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	strings[0] = NULL;
+ 	rc = of_property_read_string_index(np, "string-property", 1, strings);
+ 	selftest(rc == -ENODATA && strings[0] == NULL, "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	rc = of_property_read_string_index(np, "phandle-list-names", 0, strings);
+ 	selftest(rc == 0 && !strcmp(strings[0], "first"), "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	rc = of_property_read_string_index(np, "phandle-list-names", 1, strings);
+ 	selftest(rc == 0 && !strcmp(strings[0], "second"), "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	rc = of_property_read_string_index(np, "phandle-list-names", 2, strings);
+ 	selftest(rc == 0 && !strcmp(strings[0], "third"), "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	strings[0] = NULL;
+ 	rc = of_property_read_string_index(np, "phandle-list-names", 3, strings);
+ 	selftest(rc == -ENODATA && strings[0] == NULL, "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	strings[0] = NULL;
+ 	rc = of_property_read_string_index(np, "unterminated-string", 0, strings);
+ 	selftest(rc == -EILSEQ && strings[0] == NULL, "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	rc = of_property_read_string_index(np, "unterminated-string-list", 0, strings);
+ 	selftest(rc == 0 && !strcmp(strings[0], "first"), "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	strings[0] = NULL;
+ 	rc = of_property_read_string_index(np, "unterminated-string-list", 2, strings); /* should fail */
+ 	selftest(rc == -EILSEQ && strings[0] == NULL, "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	strings[1] = NULL;
+ 
+ 	/* of_property_read_string_array() tests */
+ 	rc = of_property_read_string_array(np, "string-property", strings, 4);
+ 	selftest(rc == 1, "Incorrect string count; rc=%i\n", rc);
+ 	rc = of_property_read_string_array(np, "phandle-list-names", strings, 4);
+ 	selftest(rc == 3, "Incorrect string count; rc=%i\n", rc);
+ 	rc = of_property_read_string_array(np, "unterminated-string", strings, 4);
+ 	selftest(rc == -EILSEQ, "unterminated string; rc=%i\n", rc);
+ 	/* -- An incorrectly formed string should cause a failure */
+ 	rc = of_property_read_string_array(np, "unterminated-string-list", strings, 4);
+ 	selftest(rc == -EILSEQ, "unterminated string array; rc=%i\n", rc);
+ 	/* -- parsing the correctly formed strings should still work: */
+ 	strings[2] = NULL;
+ 	rc = of_property_read_string_array(np, "unterminated-string-list", strings, 2);
+ 	selftest(rc == 2 && strings[2] == NULL, "of_property_read_string_array() failure; rc=%i\n", rc);
+ 	strings[1] = NULL;
+ 	rc = of_property_read_string_array(np, "phandle-list-names", strings, 1);
+ 	selftest(rc == 1 && strings[1] == NULL, "Overwrote end of string array; rc=%i, str='%s'\n", rc, strings[1]);
  }
  
 -#define propcmp(p1, p2) (((p1)->length == (p2)->length) && \
 -			(p1)->value && (p2)->value && \
 -			!memcmp((p1)->value, (p2)->value, (p1)->length) && \
 -			!strcmp((p1)->name, (p2)->name))
 -static void __init of_selftest_property_copy(void)
 -{
 -#ifdef CONFIG_OF_DYNAMIC
 -	struct property p1 = { .name = "p1", .length = 0, .value = "" };
 -	struct property p2 = { .name = "p2", .length = 5, .value = "abcd" };
 -	struct property *new;
 -
 -	new = __of_prop_dup(&p1, GFP_KERNEL);
 -	selftest(new && propcmp(&p1, new), "empty property didn't copy correctly\n");
 -	kfree(new->value);
 -	kfree(new->name);
 -	kfree(new);
 -
 -	new = __of_prop_dup(&p2, GFP_KERNEL);
 -	selftest(new && propcmp(&p2, new), "non-empty property didn't copy correctly\n");
 -	kfree(new->value);
 -	kfree(new->name);
 -	kfree(new);
 -#endif
 -}
 -
 -static void __init of_selftest_changeset(void)
 -{
 -#ifdef CONFIG_OF_DYNAMIC
 -	struct property *ppadd, padd = { .name = "prop-add", .length = 0, .value = "" };
 -	struct property *ppupdate, pupdate = { .name = "prop-update", .length = 5, .value = "abcd" };
 -	struct property *ppremove;
 -	struct device_node *n1, *n2, *n21, *nremove, *parent;
 -	struct of_changeset chgset;
 -
 -	of_changeset_init(&chgset);
 -	n1 = __of_node_alloc("/testcase-data/changeset/n1", GFP_KERNEL);
 -	selftest(n1, "testcase setup failure\n");
 -	n2 = __of_node_alloc("/testcase-data/changeset/n2", GFP_KERNEL);
 -	selftest(n2, "testcase setup failure\n");
 -	n21 = __of_node_alloc("/testcase-data/changeset/n2/n21", GFP_KERNEL);
 -	selftest(n21, "testcase setup failure %p\n", n21);
 -	nremove = of_find_node_by_path("/testcase-data/changeset/node-remove");
 -	selftest(nremove, "testcase setup failure\n");
 -	ppadd = __of_prop_dup(&padd, GFP_KERNEL);
 -	selftest(ppadd, "testcase setup failure\n");
 -	ppupdate = __of_prop_dup(&pupdate, GFP_KERNEL);
 -	selftest(ppupdate, "testcase setup failure\n");
 -	parent = nremove->parent;
 -	n1->parent = parent;
 -	n2->parent = parent;
 -	n21->parent = n2;
 -	n2->child = n21;
 -	ppremove = of_find_property(parent, "prop-remove", NULL);
 -	selftest(ppremove, "failed to find removal prop");
 -
 -	of_changeset_init(&chgset);
 -	selftest(!of_changeset_attach_node(&chgset, n1), "fail attach n1\n");
 -	selftest(!of_changeset_attach_node(&chgset, n2), "fail attach n2\n");
 -	selftest(!of_changeset_detach_node(&chgset, nremove), "fail remove node\n");
 -	selftest(!of_changeset_attach_node(&chgset, n21), "fail attach n21\n");
 -	selftest(!of_changeset_add_property(&chgset, parent, ppadd), "fail add prop\n");
 -	selftest(!of_changeset_update_property(&chgset, parent, ppupdate), "fail update prop\n");
 -	selftest(!of_changeset_remove_property(&chgset, parent, ppremove), "fail remove prop\n");
 -	mutex_lock(&of_mutex);
 -	selftest(!of_changeset_apply(&chgset), "apply failed\n");
 -	mutex_unlock(&of_mutex);
 -
 -	mutex_lock(&of_mutex);
 -	selftest(!of_changeset_revert(&chgset), "revert failed\n");
 -	mutex_unlock(&of_mutex);
 -
 -	of_changeset_destroy(&chgset);
 -#endif
 -}
 -
 -static void __init of_selftest_parse_interrupts(void)
 -{
 -	struct device_node *np;
 -	struct of_phandle_args args;
 -	int i, rc;
 -
 -	np = of_find_node_by_path("/testcase-data/interrupts/interrupts0");
 -	if (!np) {
 -		pr_err("missing testcase data\n");
 -		return;
 -	}
 -
 -	for (i = 0; i < 4; i++) {
 -		bool passed = true;
 -		args.args_count = 0;
 -		rc = of_irq_parse_one(np, i, &args);
 -
 -		passed &= !rc;
 -		passed &= (args.args_count == 1);
 -		passed &= (args.args[0] == (i + 1));
 -
 -		selftest(passed, "index %i - data error on node %s rc=%i\n",
 -			 i, args.np->full_name, rc);
 -	}
 -	of_node_put(np);
 -
 -	np = of_find_node_by_path("/testcase-data/interrupts/interrupts1");
 -	if (!np) {
 -		pr_err("missing testcase data\n");
 -		return;
 -	}
 -
 -	for (i = 0; i < 4; i++) {
 -		bool passed = true;
 -		args.args_count = 0;
 -		rc = of_irq_parse_one(np, i, &args);
 -
 -		/* Test the values from tests-phandle.dtsi */
 -		switch (i) {
 -		case 0:
 -			passed &= !rc;
 -			passed &= (args.args_count == 1);
 -			passed &= (args.args[0] == 9);
 -			break;
 -		case 1:
 -			passed &= !rc;
 -			passed &= (args.args_count == 3);
 -			passed &= (args.args[0] == 10);
 -			passed &= (args.args[1] == 11);
 -			passed &= (args.args[2] == 12);
 -			break;
 -		case 2:
 -			passed &= !rc;
 -			passed &= (args.args_count == 2);
 -			passed &= (args.args[0] == 13);
 -			passed &= (args.args[1] == 14);
 -			break;
 -		case 3:
 -			passed &= !rc;
 -			passed &= (args.args_count == 2);
 -			passed &= (args.args[0] == 15);
 -			passed &= (args.args[1] == 16);
 -			break;
 -		default:
 -			passed = false;
 -		}
 -		selftest(passed, "index %i - data error on node %s rc=%i\n",
 -			 i, args.np->full_name, rc);
 -	}
 -	of_node_put(np);
 -}
 -
 -static void __init of_selftest_parse_interrupts_extended(void)
 -{
 -	struct device_node *np;
 -	struct of_phandle_args args;
 -	int i, rc;
 -
 -	np = of_find_node_by_path("/testcase-data/interrupts/interrupts-extended0");
 -	if (!np) {
 -		pr_err("missing testcase data\n");
 -		return;
 -	}
 -
 -	for (i = 0; i < 7; i++) {
 -		bool passed = true;
 -		rc = of_irq_parse_one(np, i, &args);
 -
 -		/* Test the values from tests-phandle.dtsi */
 -		switch (i) {
 -		case 0:
 -			passed &= !rc;
 -			passed &= (args.args_count == 1);
 -			passed &= (args.args[0] == 1);
 -			break;
 -		case 1:
 -			passed &= !rc;
 -			passed &= (args.args_count == 3);
 -			passed &= (args.args[0] == 2);
 -			passed &= (args.args[1] == 3);
 -			passed &= (args.args[2] == 4);
 -			break;
 -		case 2:
 -			passed &= !rc;
 -			passed &= (args.args_count == 2);
 -			passed &= (args.args[0] == 5);
 -			passed &= (args.args[1] == 6);
 -			break;
 -		case 3:
 -			passed &= !rc;
 -			passed &= (args.args_count == 1);
 -			passed &= (args.args[0] == 9);
 -			break;
 -		case 4:
 -			passed &= !rc;
 -			passed &= (args.args_count == 3);
 -			passed &= (args.args[0] == 10);
 -			passed &= (args.args[1] == 11);
 -			passed &= (args.args[2] == 12);
 -			break;
 -		case 5:
 -			passed &= !rc;
 -			passed &= (args.args_count == 2);
 -			passed &= (args.args[0] == 13);
 -			passed &= (args.args[1] == 14);
 -			break;
 -		case 6:
 -			passed &= !rc;
 -			passed &= (args.args_count == 1);
 -			passed &= (args.args[0] == 15);
 -			break;
 -		default:
 -			passed = false;
 -		}
 -
 -		selftest(passed, "index %i - data error on node %s rc=%i\n",
 -			 i, args.np->full_name, rc);
 -	}
 -	of_node_put(np);
 -}
 -
 -static struct of_device_id match_node_table[] = {
 -	{ .data = "A", .name = "name0", }, /* Name alone is lowest priority */
 -	{ .data = "B", .type = "type1", }, /* followed by type alone */
 -
 -	{ .data = "Ca", .name = "name2", .type = "type1", }, /* followed by both together */
 -	{ .data = "Cb", .name = "name2", }, /* Only match when type doesn't match */
 -	{ .data = "Cc", .name = "name2", .type = "type2", },
 -
 -	{ .data = "E", .compatible = "compat3" },
 -	{ .data = "G", .compatible = "compat2", },
 -	{ .data = "H", .compatible = "compat2", .name = "name5", },
 -	{ .data = "I", .compatible = "compat2", .type = "type1", },
 -	{ .data = "J", .compatible = "compat2", .type = "type1", .name = "name8", },
 -	{ .data = "K", .compatible = "compat2", .name = "name9", },
 -	{}
 -};
 -
 -static struct {
 -	const char *path;
 -	const char *data;
 -} match_node_tests[] = {
 -	{ .path = "/testcase-data/match-node/name0", .data = "A", },
 -	{ .path = "/testcase-data/match-node/name1", .data = "B", },
 -	{ .path = "/testcase-data/match-node/a/name2", .data = "Ca", },
 -	{ .path = "/testcase-data/match-node/b/name2", .data = "Cb", },
 -	{ .path = "/testcase-data/match-node/c/name2", .data = "Cc", },
 -	{ .path = "/testcase-data/match-node/name3", .data = "E", },
 -	{ .path = "/testcase-data/match-node/name4", .data = "G", },
 -	{ .path = "/testcase-data/match-node/name5", .data = "H", },
 -	{ .path = "/testcase-data/match-node/name6", .data = "G", },
 -	{ .path = "/testcase-data/match-node/name7", .data = "I", },
 -	{ .path = "/testcase-data/match-node/name8", .data = "J", },
 -	{ .path = "/testcase-data/match-node/name9", .data = "K", },
 -};
 -
 -static void __init of_selftest_match_node(void)
 -{
 -	struct device_node *np;
 -	const struct of_device_id *match;
 -	int i;
 -
 -	for (i = 0; i < ARRAY_SIZE(match_node_tests); i++) {
 -		np = of_find_node_by_path(match_node_tests[i].path);
 -		if (!np) {
 -			selftest(0, "missing testcase node %s\n",
 -				match_node_tests[i].path);
 -			continue;
 -		}
 -
 -		match = of_match_node(match_node_table, np);
 -		if (!match) {
 -			selftest(0, "%s didn't match anything\n",
 -				match_node_tests[i].path);
 -			continue;
 -		}
 -
 -		if (strcmp(match->data, match_node_tests[i].data) != 0) {
 -			selftest(0, "%s got wrong match. expected %s, got %s\n",
 -				match_node_tests[i].path, match_node_tests[i].data,
 -				(const char *)match->data);
 -			continue;
 -		}
 -		selftest(1, "passed");
 -	}
 -}
 -
 -static void __init of_selftest_platform_populate(void)
 -{
 -	int irq;
 -	struct device_node *np, *child;
 -	struct platform_device *pdev;
 -	struct of_device_id match[] = {
 -		{ .compatible = "test-device", },
 -		{}
 -	};
 -
 -	np = of_find_node_by_path("/testcase-data");
 -	of_platform_populate(np, of_default_bus_match_table, NULL, NULL);
 -
 -	/* Test that a missing irq domain returns -EPROBE_DEFER */
 -	np = of_find_node_by_path("/testcase-data/testcase-device1");
 -	pdev = of_find_device_by_node(np);
 -	selftest(pdev, "device 1 creation failed\n");
 -
 -	irq = platform_get_irq(pdev, 0);
 -	selftest(irq == -EPROBE_DEFER, "device deferred probe failed - %d\n", irq);
 -
 -	/* Test that a parsing failure does not return -EPROBE_DEFER */
 -	np = of_find_node_by_path("/testcase-data/testcase-device2");
 -	pdev = of_find_device_by_node(np);
 -	selftest(pdev, "device 2 creation failed\n");
 -	irq = platform_get_irq(pdev, 0);
 -	selftest(irq < 0 && irq != -EPROBE_DEFER, "device parsing error failed - %d\n", irq);
 -
 -	np = of_find_node_by_path("/testcase-data/platform-tests");
 -	if (!np) {
 -		pr_err("No testcase data in device tree\n");
 -		return;
 -	}
 -
 -	for_each_child_of_node(np, child) {
 -		struct device_node *grandchild;
 -		of_platform_populate(child, match, NULL, NULL);
 -		for_each_child_of_node(child, grandchild)
 -			selftest(of_find_device_by_node(grandchild),
 -				 "Could not create device for node '%s'\n",
 -				 grandchild->name);
 -	}
 -}
 -
 -/**
 - *	update_node_properties - adds the properties
 - *	of np into dup node (present in live tree) and
 - *	updates parent of children of np to dup.
 - *
 - *	@np:	node already present in live tree
 - *	@dup:	node present in live tree to be updated
 - */
 -static void update_node_properties(struct device_node *np,
 -					struct device_node *dup)
 -{
 -	struct property *prop;
 -	struct device_node *child;
 -
 -	for_each_property_of_node(np, prop)
 -		of_add_property(dup, prop);
 -
 -	for_each_child_of_node(np, child)
 -		child->parent = dup;
 -}
 -
 -/**
 - *	attach_node_and_children - attaches nodes
 - *	and its children to live tree
 - *
 - *	@np:	Node to attach to live tree
 - */
 -static int attach_node_and_children(struct device_node *np)
 -{
 -	struct device_node *next, *root = np, *dup;
 -
 -	/* skip root node */
 -	np = np->child;
 -	/* storing a copy in temporary node */
 -	dup = np;
 -
 -	while (dup) {
 -		if (WARN_ON(last_node_index >= NO_OF_NODES))
 -			return -EINVAL;
 -		nodes[last_node_index++] = dup;
 -		dup = dup->sibling;
 -	}
 -	dup = NULL;
 -
 -	while (np) {
 -		next = np->allnext;
 -		dup = of_find_node_by_path(np->full_name);
 -		if (dup)
 -			update_node_properties(np, dup);
 -		else {
 -			np->child = NULL;
 -			if (np->parent == root)
 -				np->parent = of_allnodes;
 -			of_attach_node(np);
 -		}
 -		np = next;
 -	}
 -
 -	return 0;
 -}
 -
 -/**
 - *	selftest_data_add - Reads, copies data from
 - *	linked tree and attaches it to the live tree
 - */
 -static int __init selftest_data_add(void)
 -{
 -	void *selftest_data;
 -	struct device_node *selftest_data_node, *np;
 -	extern uint8_t __dtb_testcases_begin[];
 -	extern uint8_t __dtb_testcases_end[];
 -	const int size = __dtb_testcases_end - __dtb_testcases_begin;
 -	int rc;
 -
 -	if (!size) {
 -		pr_warn("%s: No testcase data to attach; not running tests\n",
 -			__func__);
 -		return -ENODATA;
 -	}
 -
 -	/* creating copy */
 -	selftest_data = kmemdup(__dtb_testcases_begin, size, GFP_KERNEL);
 -
 -	if (!selftest_data) {
 -		pr_warn("%s: Failed to allocate memory for selftest_data; "
 -			"not running tests\n", __func__);
 -		return -ENOMEM;
 -	}
 -	of_fdt_unflatten_tree(selftest_data, &selftest_data_node);
 -	if (!selftest_data_node) {
 -		pr_warn("%s: No tree to attach; not running tests\n", __func__);
 -		return -ENODATA;
 -	}
 -	of_node_set_flag(selftest_data_node, OF_DETACHED);
 -	rc = of_resolve_phandles(selftest_data_node);
 -	if (rc) {
 -		pr_err("%s: Failed to resolve phandles (rc=%i)\n", __func__, rc);
 -		return -EINVAL;
 -	}
 -
 -	if (!of_allnodes) {
 -		/* enabling flag for removing nodes */
 -		selftest_live_tree = true;
 -		of_allnodes = selftest_data_node;
 -
 -		for_each_of_allnodes(np)
 -			__of_attach_node_sysfs(np);
 -		of_aliases = of_find_node_by_path("/aliases");
 -		of_chosen = of_find_node_by_path("/chosen");
 -		return 0;
 -	}
 -
 -	/* attach the sub-tree to live tree */
 -	return attach_node_and_children(selftest_data_node);
 -}
 -
 -/**
 - *	detach_node_and_children - detaches node
 - *	and its children from live tree
 - *
 - *	@np:	Node to detach from live tree
 - */
 -static void detach_node_and_children(struct device_node *np)
 -{
 -	while (np->child)
 -		detach_node_and_children(np->child);
 -	of_detach_node(np);
 -}
 -
 -/**
 - *	selftest_data_remove - removes the selftest data
 - *	nodes from the live tree
 - */
 -static void selftest_data_remove(void)
 -{
 -	struct device_node *np;
 -	struct property *prop;
 -
 -	if (selftest_live_tree) {
 -		of_node_put(of_aliases);
 -		of_node_put(of_chosen);
 -		of_aliases = NULL;
 -		of_chosen = NULL;
 -		for_each_child_of_node(of_allnodes, np)
 -			detach_node_and_children(np);
 -		__of_detach_node_sysfs(of_allnodes);
 -		of_allnodes = NULL;
 -		return;
 -	}
 -
 -	while (last_node_index >= 0) {
 -		if (nodes[last_node_index]) {
 -			np = of_find_node_by_path(nodes[last_node_index]->full_name);
 -			if (strcmp(np->full_name, "/aliases") != 0) {
 -				detach_node_and_children(np);
 -			} else {
 -				for_each_property_of_node(np, prop) {
 -					if (strcmp(prop->name, "testcase-alias") == 0)
 -						of_remove_property(np, prop);
 -				}
 -			}
 -		}
 -		last_node_index--;
 -	}
 -}
 -
  static int __init of_selftest(void)
  {
  	struct device_node *np;
@@@ -166,9 -930,28 +220,29 @@@
  	of_node_put(np);
  
  	pr_info("start of selftest - you will see error messages\n");
 -	of_selftest_check_tree_linkage();
 -	of_selftest_check_phandles();
 -	of_selftest_find_node_by_name();
 -	of_selftest_dynamic();
  	of_selftest_parse_phandle_with_args();
++<<<<<<< HEAD
 +	of_selftest_property_match_string();
 +	pr_info("end of selftest - %s\n", selftest_passed ? "PASS" : "FAIL");
++=======
+ 	of_selftest_property_string();
+ 	of_selftest_property_copy();
+ 	of_selftest_changeset();
+ 	of_selftest_parse_interrupts();
+ 	of_selftest_parse_interrupts_extended();
+ 	of_selftest_match_node();
+ 	of_selftest_platform_populate();
+ 
+ 	/* removing selftest data from live tree */
+ 	selftest_data_remove();
+ 
+ 	/* Double check linkage after removing testcase data */
+ 	of_selftest_check_tree_linkage();
+ 
+ 	pr_info("end of selftest - %i passed, %i failed\n",
+ 		selftest_results.passed, selftest_results.failed);
+ 
++>>>>>>> a87fa1d81a9f (of: Fix overflow bug in string property parsing functions)
  	return 0;
  }
  late_initcall(of_selftest);
diff --git a/arch/arm/boot/dts/testcases/tests-phandle.dtsi b/arch/arm/boot/dts/testcases/tests-phandle.dtsi
index 788a4c24b8f5..ca12de0b9f7f 100644
--- a/arch/arm/boot/dts/testcases/tests-phandle.dtsi
+++ b/arch/arm/boot/dts/testcases/tests-phandle.dtsi
@@ -35,7 +35,9 @@
 				phandle-list-bad-args = <&provider2 1 0>,
 							<&provider3 0>;
 				empty-property;
+				string-property = "foobar";
 				unterminated-string = [40 41 42 43];
+				unterminated-string-list = "first", "second", [40 41 42 43];
 			};
 		};
 	};
diff --git a/drivers/of/base.c b/drivers/of/base.c
index 600ce0fdc357..dfd2179cfbe5 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1181,52 +1181,6 @@ int of_property_read_string(struct device_node *np, const char *propname,
 }
 EXPORT_SYMBOL_GPL(of_property_read_string);
 
-/**
- * of_property_read_string_index - Find and read a string from a multiple
- * strings property.
- * @np:		device node from which the property value is to be read.
- * @propname:	name of the property to be searched.
- * @index:	index of the string in the list of strings
- * @out_string:	pointer to null terminated return string, modified only if
- *		return value is 0.
- *
- * Search for a property in a device tree node and retrieve a null
- * terminated string value (pointer to data, not a copy) in the list of strings
- * contained in that property.
- * Returns 0 on success, -EINVAL if the property does not exist, -ENODATA if
- * property does not have a value, and -EILSEQ if the string is not
- * null-terminated within the length of the property data.
- *
- * The out_string pointer is modified only if a valid string can be decoded.
- */
-int of_property_read_string_index(struct device_node *np, const char *propname,
-				  int index, const char **output)
-{
-	struct property *prop = of_find_property(np, propname, NULL);
-	int i = 0;
-	size_t l = 0, total = 0;
-	const char *p;
-
-	if (!prop)
-		return -EINVAL;
-	if (!prop->value)
-		return -ENODATA;
-	if (strnlen(prop->value, prop->length) >= prop->length)
-		return -EILSEQ;
-
-	p = prop->value;
-
-	for (i = 0; total < prop->length; total += l, p += l) {
-		l = strlen(p) + 1;
-		if (i++ == index) {
-			*output = p;
-			return 0;
-		}
-	}
-	return -ENODATA;
-}
-EXPORT_SYMBOL_GPL(of_property_read_string_index);
-
 /**
  * of_property_match_string() - Find string in a list and return index
  * @np: pointer to node containing string list property
@@ -1253,7 +1207,7 @@ int of_property_match_string(struct device_node *np, const char *propname,
 	end = p + prop->length;
 
 	for (i = 0; p < end; i++, p += l) {
-		l = strlen(p) + 1;
+		l = strnlen(p, end - p) + 1;
 		if (p + l > end)
 			return -EILSEQ;
 		pr_debug("comparing %s with %s\n", string, p);
@@ -1265,39 +1219,41 @@ int of_property_match_string(struct device_node *np, const char *propname,
 EXPORT_SYMBOL_GPL(of_property_match_string);
 
 /**
- * of_property_count_strings - Find and return the number of strings from a
- * multiple strings property.
+ * of_property_read_string_util() - Utility helper for parsing string properties
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
+ * @out_strs:	output array of string pointers.
+ * @sz:		number of array elements to read.
+ * @skip:	Number of strings to skip over at beginning of list.
  *
- * Search for a property in a device tree node and retrieve the number of null
- * terminated string contain in it. Returns the number of strings on
- * success, -EINVAL if the property does not exist, -ENODATA if property
- * does not have a value, and -EILSEQ if the string is not null-terminated
- * within the length of the property data.
+ * Don't call this function directly. It is a utility helper for the
+ * of_property_read_string*() family of functions.
  */
-int of_property_count_strings(struct device_node *np, const char *propname)
+int of_property_read_string_helper(struct device_node *np, const char *propname,
+				   const char **out_strs, size_t sz, int skip)
 {
 	struct property *prop = of_find_property(np, propname, NULL);
-	int i = 0;
-	size_t l = 0, total = 0;
-	const char *p;
+	int l = 0, i = 0;
+	const char *p, *end;
 
 	if (!prop)
 		return -EINVAL;
 	if (!prop->value)
 		return -ENODATA;
-	if (strnlen(prop->value, prop->length) >= prop->length)
-		return -EILSEQ;
-
 	p = prop->value;
+	end = p + prop->length;
 
-	for (i = 0; total < prop->length; total += l, p += l, i++)
-		l = strlen(p) + 1;
-
-	return i;
+	for (i = 0; p < end && (!out_strs || i < skip + sz); i++, p += l) {
+		l = strnlen(p, end - p) + 1;
+		if (p + l > end)
+			return -EILSEQ;
+		if (out_strs && i >= skip)
+			*out_strs++ = p;
+	}
+	i -= skip;
+	return i <= 0 ? -ENODATA : i;
 }
-EXPORT_SYMBOL_GPL(of_property_count_strings);
+EXPORT_SYMBOL_GPL(of_property_read_string_helper);
 
 /**
  * of_parse_phandle - Resolve a phandle property to a device_node pointer
* Unmerged path drivers/of/selftest.c
diff --git a/include/linux/of.h b/include/linux/of.h
index 2ad1f514d03a..2259de6637ad 100644
--- a/include/linux/of.h
+++ b/include/linux/of.h
@@ -297,14 +297,12 @@ extern int of_property_read_u64_array(const struct device_node *np,
 extern int of_property_read_string(struct device_node *np,
 				   const char *propname,
 				   const char **out_string);
-extern int of_property_read_string_index(struct device_node *np,
-					 const char *propname,
-					 int index, const char **output);
 extern int of_property_match_string(struct device_node *np,
 				    const char *propname,
 				    const char *string);
-extern int of_property_count_strings(struct device_node *np,
-				     const char *propname);
+extern int of_property_read_string_helper(struct device_node *np,
+					      const char *propname,
+					      const char **out_strs, size_t sz, int index);
 extern int of_device_is_compatible(const struct device_node *device,
 				   const char *);
 extern int of_device_is_available(const struct device_node *device);
@@ -504,15 +502,9 @@ static inline int of_property_read_string(struct device_node *np,
 	return -ENOSYS;
 }
 
-static inline int of_property_read_string_index(struct device_node *np,
-						const char *propname, int index,
-						const char **out_string)
-{
-	return -ENOSYS;
-}
-
-static inline int of_property_count_strings(struct device_node *np,
-					    const char *propname)
+static inline int of_property_read_string_helper(struct device_node *np,
+						 const char *propname,
+						 const char **out_strs, size_t sz, int index)
 {
 	return -ENOSYS;
 }
@@ -587,6 +579,70 @@ static inline int of_node_to_nid(struct device_node *device)
 }
 #endif
 
+/**
+ * of_property_read_string_array() - Read an array of strings from a multiple
+ * strings property.
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @out_strs:	output array of string pointers.
+ * @sz:		number of array elements to read.
+ *
+ * Search for a property in a device tree node and retrieve a list of
+ * terminated string values (pointer to data, not a copy) in that property.
+ *
+ * If @out_strs is NULL, the number of strings in the property is returned.
+ */
+static inline int of_property_read_string_array(struct device_node *np,
+						const char *propname, const char **out_strs,
+						size_t sz)
+{
+	return of_property_read_string_helper(np, propname, out_strs, sz, 0);
+}
+
+/**
+ * of_property_count_strings() - Find and return the number of strings from a
+ * multiple strings property.
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ *
+ * Search for a property in a device tree node and retrieve the number of null
+ * terminated string contain in it. Returns the number of strings on
+ * success, -EINVAL if the property does not exist, -ENODATA if property
+ * does not have a value, and -EILSEQ if the string is not null-terminated
+ * within the length of the property data.
+ */
+static inline int of_property_count_strings(struct device_node *np,
+					    const char *propname)
+{
+	return of_property_read_string_helper(np, propname, NULL, 0, 0);
+}
+
+/**
+ * of_property_read_string_index() - Find and read a string from a multiple
+ * strings property.
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @index:	index of the string in the list of strings
+ * @out_string:	pointer to null terminated return string, modified only if
+ *		return value is 0.
+ *
+ * Search for a property in a device tree node and retrieve a null
+ * terminated string value (pointer to data, not a copy) in the list of strings
+ * contained in that property.
+ * Returns 0 on success, -EINVAL if the property does not exist, -ENODATA if
+ * property does not have a value, and -EILSEQ if the string is not
+ * null-terminated within the length of the property data.
+ *
+ * The out_string pointer is modified only if a valid string can be decoded.
+ */
+static inline int of_property_read_string_index(struct device_node *np,
+						const char *propname,
+						int index, const char **output)
+{
+	int rc = of_property_read_string_helper(np, propname, output, 1, index);
+	return rc < 0 ? rc : 0;
+}
+
 /**
  * of_property_read_bool - Findfrom a property
  * @np:		device node from which the property value is to be read.
