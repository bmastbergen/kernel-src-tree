xfs: support a crc verification only log record pass

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Brian Foster <bfoster@redhat.com>
commit 6528250b712102a7481c28db535ef251459d1868
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6528250b.failed

Log recovery torn write detection uses CRC verification over a range of
the active log to identify torn writes. Since the generic log recovery
pass code implements a superset of the functionality required for CRC
verification, it can be easily modified to support a CRC verification
only pass.

Create a new CRC pass type and update the log record processing helper
to skip everything beyond CRC verification when in this mode. This pass
will be invoked in subsequent patches to implement torn write detection.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 6528250b712102a7481c28db535ef251459d1868)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_log_recover.c
diff --cc fs/xfs/xfs_log_recover.c
index 5a774879a6c2,1be259044096..000000000000
--- a/fs/xfs/xfs_log_recover.c
+++ b/fs/xfs/xfs_log_recover.c
@@@ -4202,6 -4157,45 +4202,48 @@@ xlog_recover_process
  	int			pass)
  {
  	int			error;
++<<<<<<< HEAD
++=======
+ 	__le32			crc;
+ 
+ 	crc = xlog_cksum(log, rhead, dp, be32_to_cpu(rhead->h_len));
+ 
+ 	/*
+ 	 * Nothing else to do if this is a CRC verification pass. Just return
+ 	 * if this a record with a non-zero crc. Unfortunately, mkfs always
+ 	 * sets h_crc to 0 so we must consider this valid even on v5 supers.
+ 	 * Otherwise, return EFSBADCRC on failure so the callers up the stack
+ 	 * know precisely what failed.
+ 	 */
+ 	if (pass == XLOG_RECOVER_CRCPASS) {
+ 		if (rhead->h_crc && crc != le32_to_cpu(rhead->h_crc))
+ 			return -EFSBADCRC;
+ 		return 0;
+ 	}
+ 
+ 	/*
+ 	 * We're in the normal recovery path. Issue a warning if and only if the
+ 	 * CRC in the header is non-zero. This is an advisory warning and the
+ 	 * zero CRC check prevents warnings from being emitted when upgrading
+ 	 * the kernel from one that does not add CRCs by default.
+ 	 */
+ 	if (crc != le32_to_cpu(rhead->h_crc)) {
+ 		if (rhead->h_crc || xfs_sb_version_hascrc(&log->l_mp->m_sb)) {
+ 			xfs_alert(log->l_mp,
+ 		"log record CRC mismatch: found 0x%x, expected 0x%x.",
+ 					le32_to_cpu(rhead->h_crc),
+ 					le32_to_cpu(crc));
+ 			xfs_hex_dump(dp, 32);
+ 		}
+ 
+ 		/*
+ 		 * If the filesystem is CRC enabled, this mismatch becomes a
+ 		 * fatal log corruption failure.
+ 		 */
+ 		if (xfs_sb_version_hascrc(&log->l_mp->m_sb))
+ 			return -EFSCORRUPTED;
+ 	}
++>>>>>>> 6528250b7121 (xfs: support a crc verification only log record pass)
  
  	error = xlog_unpack_data(rhead, dp, log);
  	if (error)
diff --git a/fs/xfs/libxfs/xfs_log_recover.h b/fs/xfs/libxfs/xfs_log_recover.h
index 1c55ccbb379d..8e385f91d660 100644
--- a/fs/xfs/libxfs/xfs_log_recover.h
+++ b/fs/xfs/libxfs/xfs_log_recover.h
@@ -60,6 +60,7 @@ typedef struct xlog_recover {
  */
 #define	XLOG_BC_TABLE_SIZE	64
 
+#define	XLOG_RECOVER_CRCPASS	0
 #define	XLOG_RECOVER_PASS1	1
 #define	XLOG_RECOVER_PASS2	2
 
* Unmerged path fs/xfs/xfs_log_recover.c
