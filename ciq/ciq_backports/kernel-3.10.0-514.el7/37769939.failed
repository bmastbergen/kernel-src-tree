USB: EHCI: Export the ehci_hub_control function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [usb] ehci: Export the ehci_hub_control function (Don Zickus) [1303209]
Rebuild_FUZZ: 94.38%
commit-author Laurent Pinchart <laurent.pinchart@ideasonboard.com>
commit 37769939082ae0749405133e09eac2c3ccb8fcf0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/37769939.failed

Platform drivers sometimes need to perform specific handling of hub
control requests. Make this possible by exporting the ehci_hub_control()
function which can then be called from a custom hub control handler in
the default case.

	Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Acked-by: Alan Stern <stern@rowland.harvard.edu>
	Acked-by: Stephen Warren <swarren@nvidia.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 37769939082ae0749405133e09eac2c3ccb8fcf0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/ehci-tegra.c
diff --cc drivers/usb/host/ehci-tegra.c
index 614c2089ef38,572634cd95d6..000000000000
--- a/drivers/usb/host/ehci-tegra.c
+++ b/drivers/usb/host/ehci-tegra.c
@@@ -41,12 -42,19 +41,24 @@@
  
  #define TEGRA_USB_DMA_ALIGN 32
  
++<<<<<<< HEAD
++=======
+ #define DRIVER_DESC "Tegra EHCI driver"
+ #define DRV_NAME "tegra-ehci"
+ 
+ static struct hc_driver __read_mostly tegra_ehci_hc_driver;
+ 
+ struct tegra_ehci_soc_config {
+ 	bool has_hostpc;
+ };
+ 
++>>>>>>> 37769939082a (USB: EHCI: Export the ehci_hub_control function)
  struct tegra_ehci_hcd {
 +	struct ehci_hcd *ehci;
  	struct tegra_usb_phy *phy;
  	struct clk *clk;
 -	struct reset_control *rst;
 +	struct usb_phy *transceiver;
 +	int host_resumed;
  	int port_resuming;
  	bool needs_double_reset;
  	enum tegra_usb_phy_port_speed port_speed;
@@@ -243,6 -233,7 +255,10 @@@ static int tegra_ehci_hub_control
  
  	/* Handle the hub control events here */
  	return ehci_hub_control(hcd, typeReq, wValue, wIndex, buf, wLength);
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> 37769939082a (USB: EHCI: Export the ehci_hub_control function)
  done:
  	spin_unlock_irqrestore(&ehci->lock, flags);
  	return retval;
@@@ -850,10 -500,71 +866,77 @@@ static struct platform_driver tegra_ehc
  	.remove		= tegra_ehci_remove,
  	.shutdown	= tegra_ehci_hcd_shutdown,
  	.driver		= {
 -		.name	= DRV_NAME,
 +		.name	= "tegra-ehci",
  		.of_match_table = tegra_ehci_of_match,
 +#ifdef CONFIG_PM
 +		.pm	= &tegra_ehci_pm_ops,
 +#endif
  	}
  };
++<<<<<<< HEAD
++=======
+ 
+ static int tegra_ehci_reset(struct usb_hcd *hcd)
+ {
+ 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+ 	int retval;
+ 	int txfifothresh;
+ 
+ 	retval = ehci_setup(hcd);
+ 	if (retval)
+ 		return retval;
+ 
+ 	/*
+ 	 * We should really pull this value out of tegra_ehci_soc_config, but
+ 	 * to avoid needing access to it, make use of the fact that Tegra20 is
+ 	 * the only one so far that needs a value of 10, and Tegra20 is the
+ 	 * only one which doesn't set has_hostpc.
+ 	 */
+ 	txfifothresh = ehci->has_hostpc ? 0x10 : 10;
+ 	ehci_writel(ehci, txfifothresh << 16, &ehci->regs->txfill_tuning);
+ 
+ 	return 0;
+ }
+ 
+ static const struct ehci_driver_overrides tegra_overrides __initconst = {
+ 	.extra_priv_size	= sizeof(struct tegra_ehci_hcd),
+ 	.reset			= tegra_ehci_reset,
+ };
+ 
+ static int __init ehci_tegra_init(void)
+ {
+ 	if (usb_disabled())
+ 		return -ENODEV;
+ 
+ 	pr_info(DRV_NAME ": " DRIVER_DESC "\n");
+ 
+ 	ehci_init_driver(&tegra_ehci_hc_driver, &tegra_overrides);
+ 
+ 	/*
+ 	 * The Tegra HW has some unusual quirks, which require Tegra-specific
+ 	 * workarounds. We override certain hc_driver functions here to
+ 	 * achieve that. We explicitly do not enhance ehci_driver_overrides to
+ 	 * allow this more easily, since this is an unusual case, and we don't
+ 	 * want to encourage others to override these functions by making it
+ 	 * too easy.
+ 	 */
+ 
+ 	tegra_ehci_hc_driver.map_urb_for_dma = tegra_ehci_map_urb_for_dma;
+ 	tegra_ehci_hc_driver.unmap_urb_for_dma = tegra_ehci_unmap_urb_for_dma;
+ 	tegra_ehci_hc_driver.hub_control = tegra_ehci_hub_control;
+ 
+ 	return platform_driver_register(&tegra_ehci_driver);
+ }
+ module_init(ehci_tegra_init);
+ 
+ static void __exit ehci_tegra_cleanup(void)
+ {
+ 	platform_driver_unregister(&tegra_ehci_driver);
+ }
+ module_exit(ehci_tegra_cleanup);
+ 
+ MODULE_DESCRIPTION(DRIVER_DESC);
+ MODULE_LICENSE("GPL");
+ MODULE_ALIAS("platform:" DRV_NAME);
+ MODULE_DEVICE_TABLE(of, tegra_ehci_of_match);
++>>>>>>> 37769939082a (USB: EHCI: Export the ehci_hub_control function)
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 9290f686ce10..a28c9f7fa85b 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -33,15 +33,6 @@
 
 #ifdef	CONFIG_PM
 
-static int ehci_hub_control(
-	struct usb_hcd	*hcd,
-	u16		typeReq,
-	u16		wValue,
-	u16		wIndex,
-	char		*buf,
-	u16		wLength
-);
-
 static int persist_enabled_on_companion(struct usb_device *udev, void *unused)
 {
 	return !udev->maxchild && udev->persist_enabled &&
@@ -866,7 +857,7 @@ cleanup:
 #endif /* CONFIG_USB_HCD_TEST_MODE */
 /*-------------------------------------------------------------------------*/
 
-static int ehci_hub_control (
+int ehci_hub_control(
 	struct usb_hcd	*hcd,
 	u16		typeReq,
 	u16		wValue,
@@ -1290,6 +1281,7 @@ error_exit:
 	spin_unlock_irqrestore (&ehci->lock, flags);
 	return retval;
 }
+EXPORT_SYMBOL_GPL(ehci_hub_control);
 
 static void ehci_relinquish_port(struct usb_hcd *hcd, int portnum)
 {
* Unmerged path drivers/usb/host/ehci-tegra.c
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 03cb384c961c..d1822a52ee89 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -873,4 +873,7 @@ extern int	ehci_suspend(struct usb_hcd *hcd, bool do_wakeup);
 extern int	ehci_resume(struct usb_hcd *hcd, bool hibernated);
 #endif	/* CONFIG_PM */
 
+extern int	ehci_hub_control(struct usb_hcd	*hcd, u16 typeReq, u16 wValue,
+				 u16 wIndex, char *buf, u16 wLength);
+
 #endif /* __LINUX_EHCI_HCD_H */
