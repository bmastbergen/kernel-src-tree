s390/pci: use pci_rescan_remove_lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [s390] pci: use pci_rescan_remove_lock (Hendrik Brueckner) [1330092]
Rebuild_FUZZ: 92.54%
commit-author Sebastian Ott <sebott@linux.vnet.ibm.com>
commit 2a01bd1bd3d28d1eef26d5509c95d0923f7dc75c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2a01bd1b.failed

Make sure that we use the pci_rescan_remove_lock when we remove
or add functions from/to the bus.

	Reviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
	Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 2a01bd1bd3d28d1eef26d5509c95d0923f7dc75c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci_sysfs.c
diff --cc arch/s390/pci/pci_sysfs.c
index e449bdc72568,f37a5808883d..000000000000
--- a/arch/s390/pci/pci_sysfs.c
+++ b/arch/s390/pci/pci_sysfs.c
@@@ -12,67 -12,75 +12,91 @@@
  #include <linux/stat.h>
  #include <linux/pci.h>
  
 -#define zpci_attr(name, fmt, member)					\
 -static ssize_t name##_show(struct device *dev,				\
 -			   struct device_attribute *attr, char *buf)	\
 -{									\
 -	struct zpci_dev *zdev = to_zpci(to_pci_dev(dev));		\
 -									\
 -	return sprintf(buf, fmt, zdev->member);				\
 -}									\
 -static DEVICE_ATTR_RO(name)
 -
 -zpci_attr(function_id, "0x%08x\n", fid);
 -zpci_attr(function_handle, "0x%08x\n", fh);
 -zpci_attr(pchid, "0x%04x\n", pchid);
 -zpci_attr(pfgid, "0x%02x\n", pfgid);
 -zpci_attr(vfn, "0x%04x\n", vfn);
 -zpci_attr(pft, "0x%02x\n", pft);
 -zpci_attr(uid, "0x%x\n", uid);
 -zpci_attr(segment0, "0x%02x\n", pfip[0]);
 -zpci_attr(segment1, "0x%02x\n", pfip[1]);
 -zpci_attr(segment2, "0x%02x\n", pfip[2]);
 -zpci_attr(segment3, "0x%02x\n", pfip[3]);
 -
 -static ssize_t recover_store(struct device *dev, struct device_attribute *attr,
 -			     const char *buf, size_t count)
 +static ssize_t show_fid(struct device *dev, struct device_attribute *attr,
 +			char *buf)
 +{
 +	struct zpci_dev *zdev = get_zdev(to_pci_dev(dev));
 +
 +	return sprintf(buf, "0x%08x\n", zdev->fid);
 +}
 +static DEVICE_ATTR(function_id, S_IRUGO, show_fid, NULL);
 +
 +static ssize_t show_fh(struct device *dev, struct device_attribute *attr,
 +		       char *buf)
 +{
 +	struct zpci_dev *zdev = get_zdev(to_pci_dev(dev));
 +
 +	return sprintf(buf, "0x%08x\n", zdev->fh);
 +}
 +static DEVICE_ATTR(function_handle, S_IRUGO, show_fh, NULL);
 +
 +static ssize_t show_pchid(struct device *dev, struct device_attribute *attr,
 +			  char *buf)
 +{
 +	struct zpci_dev *zdev = get_zdev(to_pci_dev(dev));
 +
 +	return sprintf(buf, "0x%04x\n", zdev->pchid);
 +}
 +static DEVICE_ATTR(pchid, S_IRUGO, show_pchid, NULL);
 +
 +static ssize_t show_pfgid(struct device *dev, struct device_attribute *attr,
 +			  char *buf)
 +{
 +	struct zpci_dev *zdev = get_zdev(to_pci_dev(dev));
 +
 +	return sprintf(buf, "0x%02x\n", zdev->pfgid);
 +}
 +static DEVICE_ATTR(pfgid, S_IRUGO, show_pfgid, NULL);
 +
 +static void recover_callback(struct device *dev)
  {
  	struct pci_dev *pdev = to_pci_dev(dev);
 -	struct zpci_dev *zdev = to_zpci(pdev);
 +	struct zpci_dev *zdev = get_zdev(pdev);
  	int ret;
  
++<<<<<<< HEAD
 +	pci_stop_and_remove_bus_device(pdev);
 +	ret = zpci_disable_device(zdev);
 +	if (ret)
 +		return;
 +
 +	ret = zpci_enable_device(zdev);
 +	if (ret)
 +		return;
 +
 +	pci_rescan_bus(zdev->bus);
++=======
+ 	if (!device_remove_file_self(dev, attr))
+ 		return count;
+ 
+ 	pci_lock_rescan_remove();
+ 	pci_stop_and_remove_bus_device(pdev);
+ 	ret = zpci_disable_device(zdev);
+ 	if (ret)
+ 		goto error;
+ 
+ 	ret = zpci_enable_device(zdev);
+ 	if (ret)
+ 		goto error;
+ 
+ 	pci_rescan_bus(zdev->bus);
+ 	pci_unlock_rescan_remove();
+ 
+ 	return count;
+ 
+ error:
+ 	pci_unlock_rescan_remove();
+ 	return ret;
++>>>>>>> 2a01bd1bd3d2 (s390/pci: use pci_rescan_remove_lock)
  }
 -static DEVICE_ATTR_WO(recover);
  
 -static ssize_t util_string_read(struct file *filp, struct kobject *kobj,
 -				struct bin_attribute *attr, char *buf,
 -				loff_t off, size_t count)
 +static ssize_t store_recover(struct device *dev, struct device_attribute *attr,
 +			     const char *buf, size_t count)
  {
 -	struct device *dev = kobj_to_dev(kobj);
 -	struct pci_dev *pdev = to_pci_dev(dev);
 -	struct zpci_dev *zdev = to_zpci(pdev);
 -
 -	return memory_read_from_buffer(buf, count, &off, zdev->util_str,
 -				       sizeof(zdev->util_str));
 +	int rc = device_schedule_callback(dev, recover_callback);
 +	return rc ? rc : count;
  }
 -static BIN_ATTR_RO(util_string, CLP_UTIL_STR_LEN);
 -static struct bin_attribute *zpci_bin_attrs[] = {
 -	&bin_attr_util_string,
 -	NULL,
 -};
 +static DEVICE_ATTR(recover, S_IWUSR, NULL, store_recover);
  
  static struct attribute *zpci_dev_attrs[] = {
  	&dev_attr_function_id.attr,
diff --git a/arch/s390/pci/pci_event.c b/arch/s390/pci/pci_event.c
index c34a612201b3..bc869ac0243e 100644
--- a/arch/s390/pci/pci_event.c
+++ b/arch/s390/pci/pci_event.c
@@ -87,7 +87,9 @@ static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
 		ret = zpci_enable_device(zdev);
 		if (ret)
 			break;
+		pci_lock_rescan_remove();
 		pci_rescan_bus(zdev->bus);
+		pci_unlock_rescan_remove();
 		break;
 	case 0x0302: /* Reserved -> Standby */
 		if (!zdev)
@@ -95,7 +97,7 @@ static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
 		break;
 	case 0x0303: /* Deconfiguration requested */
 		if (pdev)
-			pci_stop_and_remove_bus_device(pdev);
+			pci_stop_and_remove_bus_device_locked(pdev);
 
 		ret = zpci_disable_device(zdev);
 		if (ret)
@@ -112,7 +114,7 @@ static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
 			/* Give the driver a hint that the function is
 			 * already unusable. */
 			pdev->error_state = pci_channel_io_perm_failure;
-			pci_stop_and_remove_bus_device(pdev);
+			pci_stop_and_remove_bus_device_locked(pdev);
 		}
 
 		zdev->fh = ccdf->fh;
* Unmerged path arch/s390/pci/pci_sysfs.c
