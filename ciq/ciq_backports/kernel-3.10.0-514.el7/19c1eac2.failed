usb: rename phy to usb_phy in OTG

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Antoine Tenart <antoine.tenart@free-electrons.com>
commit 19c1eac2685b62640ca2386a0a885ac2152668c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/19c1eac2.failed

This patch prepares the introduction of the generic PHY support in the
USB OTG common functions. The USB PHY member of the OTG structure is
renamed to 'usb_phy' and modifications are done in all drivers accessing
it. Renaming this pointer will allow to keep the compatibility for USB
PHY drivers.

	Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
	Signed-off-by: Felipe Balbi <balbi@ti.com>
(cherry picked from commit 19c1eac2685b62640ca2386a0a885ac2152668c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/chipidea/otg_fsm.c
#	drivers/usb/phy/phy-gpio-vbus-usb.c
#	drivers/usb/phy/phy-msm-usb.c
#	drivers/usb/phy/phy-mv-usb.c
#	drivers/usb/phy/phy-nop.c
#	drivers/usb/phy/phy-omap-usb2.c
#	drivers/usb/phy/phy-tahvo.c
diff --cc drivers/usb/phy/phy-gpio-vbus-usb.c
index 8443335c2ea0,9fcf19ba1416..000000000000
--- a/drivers/usb/phy/phy-gpio-vbus-usb.c
+++ b/drivers/usb/phy/phy-gpio-vbus-usb.c
@@@ -180,9 -180,9 +180,9 @@@ static int gpio_vbus_set_peripheral(str
  	struct platform_device *pdev;
  	int gpio;
  
- 	gpio_vbus = container_of(otg->phy, struct gpio_vbus_data, phy);
+ 	gpio_vbus = container_of(otg->usb_phy, struct gpio_vbus_data, phy);
  	pdev = to_platform_device(gpio_vbus->dev);
 -	pdata = dev_get_platdata(gpio_vbus->dev);
 +	pdata = gpio_vbus->dev->platform_data;
  	gpio = pdata->gpio_pullup;
  
  	if (!gadget) {
@@@ -269,12 -269,12 +269,17 @@@ static int __init gpio_vbus_probe(struc
  	gpio_vbus->phy.dev = gpio_vbus->dev;
  	gpio_vbus->phy.set_power = gpio_vbus_set_power;
  	gpio_vbus->phy.set_suspend = gpio_vbus_set_suspend;
 +	gpio_vbus->phy.state = OTG_STATE_UNDEFINED;
  
++<<<<<<< HEAD
 +	gpio_vbus->phy.otg->phy = &gpio_vbus->phy;
++=======
+ 	gpio_vbus->phy.otg->state = OTG_STATE_UNDEFINED;
+ 	gpio_vbus->phy.otg->usb_phy = &gpio_vbus->phy;
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG)
  	gpio_vbus->phy.otg->set_peripheral = gpio_vbus_set_peripheral;
  
 -	err = devm_gpio_request(&pdev->dev, gpio, "vbus_detect");
 +	err = gpio_request(gpio, "vbus_detect");
  	if (err) {
  		dev_err(&pdev->dev, "can't request vbus gpio %d, err: %d\n",
  			gpio, err);
diff --cc drivers/usb/phy/phy-msm-usb.c
index 749fbf41fb6f,e120d87778b2..000000000000
--- a/drivers/usb/phy/phy-msm-usb.c
+++ b/drivers/usb/phy/phy-msm-usb.c
@@@ -692,17 -715,17 +692,28 @@@ static int msm_otg_set_host(struct usb_
  	 * Fail host registration if this board can support
  	 * only peripheral configuration.
  	 */
++<<<<<<< HEAD
 +	if (motg->pdata->mode == USB_PERIPHERAL) {
 +		dev_info(otg->phy->dev, "Host mode is not supported\n");
++=======
+ 	if (motg->pdata->mode == USB_DR_MODE_PERIPHERAL) {
+ 		dev_info(otg->usb_phy->dev, "Host mode is not supported\n");
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG)
  		return -ENODEV;
  	}
  
  	if (!host) {
++<<<<<<< HEAD
 +		if (otg->phy->state == OTG_STATE_A_HOST) {
 +			pm_runtime_get_sync(otg->phy->dev);
 +			msm_otg_start_host(otg->phy, 0);
++=======
+ 		if (otg->state == OTG_STATE_A_HOST) {
+ 			pm_runtime_get_sync(otg->usb_phy->dev);
+ 			msm_otg_start_host(otg->usb_phy, 0);
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG)
  			otg->host = NULL;
 -			otg->state = OTG_STATE_UNDEFINED;
 +			otg->phy->state = OTG_STATE_UNDEFINED;
  			schedule_work(&motg->sm_work);
  		} else {
  			otg->host = NULL;
@@@ -721,8 -744,8 +732,13 @@@
  	 * Kick the state machine work, if peripheral is not supported
  	 * or peripheral is already registered with us.
  	 */
++<<<<<<< HEAD
 +	if (motg->pdata->mode == USB_HOST || otg->gadget) {
 +		pm_runtime_get_sync(otg->phy->dev);
++=======
+ 	if (motg->pdata->mode == USB_DR_MODE_HOST || otg->gadget) {
+ 		pm_runtime_get_sync(otg->usb_phy->dev);
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG)
  		schedule_work(&motg->sm_work);
  	}
  
@@@ -765,17 -788,17 +781,28 @@@ static int msm_otg_set_peripheral(struc
  	 * Fail peripheral registration if this board can support
  	 * only host configuration.
  	 */
++<<<<<<< HEAD
 +	if (motg->pdata->mode == USB_HOST) {
 +		dev_info(otg->phy->dev, "Peripheral mode is not supported\n");
++=======
+ 	if (motg->pdata->mode == USB_DR_MODE_HOST) {
+ 		dev_info(otg->usb_phy->dev, "Peripheral mode is not supported\n");
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG)
  		return -ENODEV;
  	}
  
  	if (!gadget) {
++<<<<<<< HEAD
 +		if (otg->phy->state == OTG_STATE_B_PERIPHERAL) {
 +			pm_runtime_get_sync(otg->phy->dev);
 +			msm_otg_start_peripheral(otg->phy, 0);
++=======
+ 		if (otg->state == OTG_STATE_B_PERIPHERAL) {
+ 			pm_runtime_get_sync(otg->usb_phy->dev);
+ 			msm_otg_start_peripheral(otg->usb_phy, 0);
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG)
  			otg->gadget = NULL;
 -			otg->state = OTG_STATE_UNDEFINED;
 +			otg->phy->state = OTG_STATE_UNDEFINED;
  			schedule_work(&motg->sm_work);
  		} else {
  			otg->gadget = NULL;
@@@ -790,8 -814,8 +818,13 @@@
  	 * Kick the state machine work, if host is not supported
  	 * or host is already registered with us.
  	 */
++<<<<<<< HEAD
 +	if (motg->pdata->mode == USB_PERIPHERAL || otg->host) {
 +		pm_runtime_get_sync(otg->phy->dev);
++=======
+ 	if (motg->pdata->mode == USB_DR_MODE_PERIPHERAL || otg->host) {
+ 		pm_runtime_get_sync(otg->usb_phy->dev);
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG)
  		schedule_work(&motg->sm_work);
  	}
  
@@@ -1154,20 -1171,20 +1187,25 @@@ static void msm_otg_sm_work(struct work
  	struct msm_otg *motg = container_of(w, struct msm_otg, sm_work);
  	struct usb_otg *otg = motg->phy.otg;
  
 -	switch (otg->state) {
 +	switch (otg->phy->state) {
  	case OTG_STATE_UNDEFINED:
- 		dev_dbg(otg->phy->dev, "OTG_STATE_UNDEFINED state\n");
- 		msm_otg_reset(otg->phy);
+ 		dev_dbg(otg->usb_phy->dev, "OTG_STATE_UNDEFINED state\n");
+ 		msm_otg_reset(otg->usb_phy);
  		msm_otg_init_sm(motg);
 -		otg->state = OTG_STATE_B_IDLE;
 +		otg->phy->state = OTG_STATE_B_IDLE;
  		/* FALL THROUGH */
  	case OTG_STATE_B_IDLE:
- 		dev_dbg(otg->phy->dev, "OTG_STATE_B_IDLE state\n");
+ 		dev_dbg(otg->usb_phy->dev, "OTG_STATE_B_IDLE state\n");
  		if (!test_bit(ID, &motg->inputs) && otg->host) {
  			/* disable BSV bit */
  			writel(readl(USB_OTGSC) & ~OTGSC_BSVIE, USB_OTGSC);
++<<<<<<< HEAD
 +			msm_otg_start_host(otg->phy, 1);
 +			otg->phy->state = OTG_STATE_A_HOST;
++=======
+ 			msm_otg_start_host(otg->usb_phy, 1);
+ 			otg->state = OTG_STATE_A_HOST;
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG)
  		} else if (test_bit(B_SESS_VLD, &motg->inputs)) {
  			switch (motg->chg_state) {
  			case USB_CHG_STATE_UNDEFINED:
@@@ -1182,14 -1199,16 +1220,26 @@@
  				case USB_CDP_CHARGER:
  					msm_otg_notify_charger(motg,
  							IDEV_CHG_MAX);
++<<<<<<< HEAD
 +					msm_otg_start_peripheral(otg->phy, 1);
 +					otg->phy->state
++=======
+ 					msm_otg_start_peripheral(otg->usb_phy,
+ 								 1);
+ 					otg->state
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG)
  						= OTG_STATE_B_PERIPHERAL;
  					break;
  				case USB_SDP_CHARGER:
  					msm_otg_notify_charger(motg, IUNIT);
++<<<<<<< HEAD
 +					msm_otg_start_peripheral(otg->phy, 1);
 +					otg->phy->state
++=======
+ 					msm_otg_start_peripheral(otg->usb_phy,
+ 								 1);
+ 					otg->state
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG)
  						= OTG_STATE_B_PERIPHERAL;
  					break;
  				default:
@@@ -1213,27 -1232,29 +1263,44 @@@
  			motg->chg_state = USB_CHG_STATE_UNDEFINED;
  			motg->chg_type = USB_INVALID_CHARGER;
  		}
++<<<<<<< HEAD
 +		pm_runtime_put_sync(otg->phy->dev);
++=======
+ 
+ 		if (otg->state == OTG_STATE_B_IDLE)
+ 			pm_runtime_put_sync(otg->usb_phy->dev);
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG)
  		break;
  	case OTG_STATE_B_PERIPHERAL:
- 		dev_dbg(otg->phy->dev, "OTG_STATE_B_PERIPHERAL state\n");
+ 		dev_dbg(otg->usb_phy->dev, "OTG_STATE_B_PERIPHERAL state\n");
  		if (!test_bit(B_SESS_VLD, &motg->inputs) ||
  				!test_bit(ID, &motg->inputs)) {
  			msm_otg_notify_charger(motg, 0);
- 			msm_otg_start_peripheral(otg->phy, 0);
+ 			msm_otg_start_peripheral(otg->usb_phy, 0);
  			motg->chg_state = USB_CHG_STATE_UNDEFINED;
  			motg->chg_type = USB_INVALID_CHARGER;
++<<<<<<< HEAD
 +			otg->phy->state = OTG_STATE_B_IDLE;
 +			msm_otg_reset(otg->phy);
++=======
+ 			otg->state = OTG_STATE_B_IDLE;
+ 			msm_otg_reset(otg->usb_phy);
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG)
  			schedule_work(w);
  		}
  		break;
  	case OTG_STATE_A_HOST:
- 		dev_dbg(otg->phy->dev, "OTG_STATE_A_HOST state\n");
+ 		dev_dbg(otg->usb_phy->dev, "OTG_STATE_A_HOST state\n");
  		if (test_bit(ID, &motg->inputs)) {
++<<<<<<< HEAD
 +			msm_otg_start_host(otg->phy, 0);
 +			otg->phy->state = OTG_STATE_B_IDLE;
 +			msm_otg_reset(otg->phy);
++=======
+ 			msm_otg_start_host(otg->usb_phy, 0);
+ 			otg->state = OTG_STATE_B_IDLE;
+ 			msm_otg_reset(otg->usb_phy);
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG)
  			schedule_work(w);
  		}
  		break;
diff --cc drivers/usb/phy/phy-mv-usb.c
index d0e23ae9d2e6,81d934fdd0c3..000000000000
--- a/drivers/usb/phy/phy-mv-usb.c
+++ b/drivers/usb/phy/phy-mv-usb.c
@@@ -715,9 -715,9 +715,14 @@@ static int mv_otg_probe(struct platform
  	mvotg->phy.dev = &pdev->dev;
  	mvotg->phy.otg = otg;
  	mvotg->phy.label = driver_name;
 +	mvotg->phy.state = OTG_STATE_UNDEFINED;
  
++<<<<<<< HEAD
 +	otg->phy = &mvotg->phy;
++=======
+ 	otg->state = OTG_STATE_UNDEFINED;
+ 	otg->usb_phy = &mvotg->phy;
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG)
  	otg->set_host = mv_otg_set_host;
  	otg->set_peripheral = mv_otg_set_peripheral;
  	otg->set_vbus = mv_otg_set_vbus;
diff --cc drivers/usb/phy/phy-nop.c
index 638cc5dade35,0c01bd12cabc..000000000000
--- a/drivers/usb/phy/phy-nop.c
+++ b/drivers/usb/phy/phy-nop.c
@@@ -217,12 -225,10 +217,17 @@@ static int nop_usb_xceiv_probe(struct p
  	nop->phy.dev		= nop->dev;
  	nop->phy.label		= "nop-xceiv";
  	nop->phy.set_suspend	= nop_set_suspend;
 +	nop->phy.init		= nop_init;
 +	nop->phy.shutdown	= nop_shutdown;
 +	nop->phy.state		= OTG_STATE_UNDEFINED;
  	nop->phy.type		= type;
  
++<<<<<<< HEAD:drivers/usb/phy/phy-nop.c
 +	nop->phy.otg->phy		= &nop->phy;
++=======
+ 	nop->phy.otg->state		= OTG_STATE_UNDEFINED;
+ 	nop->phy.otg->usb_phy		= &nop->phy;
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG):drivers/usb/phy/phy-generic.c
  	nop->phy.otg->set_host		= nop_set_host;
  	nop->phy.otg->set_peripheral	= nop_set_peripheral;
  
diff --cc drivers/usb/phy/phy-omap-usb2.c
index 844ab68f08d0,32c3e86b4935..000000000000
--- a/drivers/usb/phy/phy-omap-usb2.c
+++ b/drivers/usb/phy/phy-omap-usb2.c
@@@ -155,14 -247,39 +155,22 @@@ static int omap_usb2_probe(struct platf
  
  	otg->set_host		= omap_usb_set_host;
  	otg->set_peripheral	= omap_usb_set_peripheral;
++<<<<<<< HEAD:drivers/usb/phy/phy-omap-usb2.c
 +	otg->set_vbus		= omap_usb_set_vbus;
 +	otg->start_srp		= omap_usb_start_srp;
 +	otg->phy		= &phy->phy;
++=======
+ 	if (phy_data->flags & OMAP_USB2_HAS_SET_VBUS)
+ 		otg->set_vbus		= omap_usb_set_vbus;
+ 	if (phy_data->flags & OMAP_USB2_HAS_START_SRP)
+ 		otg->start_srp		= omap_usb_start_srp;
+ 	otg->usb_phy		= &phy->phy;
++>>>>>>> 19c1eac2685b (usb: rename phy to usb_phy in OTG):drivers/phy/phy-omap-usb2.c
  
 -	platform_set_drvdata(pdev, phy);
 -
 -	generic_phy = devm_phy_create(phy->dev, NULL, &ops, NULL);
 -	if (IS_ERR(generic_phy))
 -		return PTR_ERR(generic_phy);
 -
 -	phy_set_drvdata(generic_phy, phy);
 -
 -	pm_runtime_enable(phy->dev);
 -	phy_provider = devm_of_phy_provider_register(phy->dev,
 -			of_phy_simple_xlate);
 -	if (IS_ERR(phy_provider)) {
 -		pm_runtime_disable(phy->dev);
 -		return PTR_ERR(phy_provider);
 -	}
 -
 -	phy->wkupclk = devm_clk_get(phy->dev, "wkupclk");
 +	phy->wkupclk = devm_clk_get(phy->dev, "usb_phy_cm_clk32k");
  	if (IS_ERR(phy->wkupclk)) {
 -		dev_warn(&pdev->dev, "unable to get wkupclk, trying old name\n");
 -		phy->wkupclk = devm_clk_get(phy->dev, "usb_phy_cm_clk32k");
 -		if (IS_ERR(phy->wkupclk)) {
 -			dev_err(&pdev->dev, "unable to get usb_phy_cm_clk32k\n");
 -			return PTR_ERR(phy->wkupclk);
 -		} else {
 -			dev_warn(&pdev->dev,
 -				 "found usb_phy_cm_clk32k, please fix DTS\n");
 -		}
 +		dev_err(&pdev->dev, "unable to get usb_phy_cm_clk32k\n");
 +		return PTR_ERR(phy->wkupclk);
  	}
  	clk_prepare(phy->wkupclk);
  
* Unmerged path drivers/usb/chipidea/otg_fsm.c
* Unmerged path drivers/usb/phy/phy-tahvo.c
* Unmerged path drivers/usb/chipidea/otg_fsm.c
diff --git a/drivers/usb/phy/phy-ab8500-usb.c b/drivers/usb/phy/phy-ab8500-usb.c
index e5eb1b5a04eb..397d248775e1 100644
--- a/drivers/usb/phy/phy-ab8500-usb.c
+++ b/drivers/usb/phy/phy-ab8500-usb.c
@@ -618,7 +618,7 @@ static int ab8500_usb_set_peripheral(struct usb_otg *otg,
 	if (!otg)
 		return -ENODEV;
 
-	ab = phy_to_ab(otg->phy);
+	ab = phy_to_ab(otg->usb_phy);
 
 	ab->phy.otg->gadget = gadget;
 
@@ -642,7 +642,7 @@ static int ab8500_usb_set_host(struct usb_otg *otg, struct usb_bus *host)
 	if (!otg)
 		return -ENODEV;
 
-	ab = phy_to_ab(otg->phy);
+	ab = phy_to_ab(otg->usb_phy);
 
 	ab->phy.otg->host = host;
 
@@ -768,7 +768,7 @@ static int ab8500_usb_probe(struct platform_device *pdev)
 	ab->phy.set_power	= ab8500_usb_set_power;
 	ab->phy.state		= OTG_STATE_UNDEFINED;
 
-	otg->phy		= &ab->phy;
+	otg->usb_phy		= &ab->phy;
 	otg->set_host		= ab8500_usb_set_host;
 	otg->set_peripheral	= ab8500_usb_set_peripheral;
 
diff --git a/drivers/usb/phy/phy-fsl-usb.c b/drivers/usb/phy/phy-fsl-usb.c
index 9958f7609b9f..d9ad8ac73161 100644
--- a/drivers/usb/phy/phy-fsl-usb.c
+++ b/drivers/usb/phy/phy-fsl-usb.c
@@ -443,7 +443,8 @@ int fsl_otg_start_host(struct otg_fsm *fsm, int on)
 {
 	struct usb_otg *otg = fsm->otg;
 	struct device *dev;
-	struct fsl_otg *otg_dev = container_of(otg->phy, struct fsl_otg, phy);
+	struct fsl_otg *otg_dev =
+		container_of(otg->usb_phy, struct fsl_otg, phy);
 	u32 retval = 0;
 
 	if (!otg->host)
@@ -538,7 +539,7 @@ static int fsl_otg_set_host(struct usb_otg *otg, struct usb_bus *host)
 	if (!otg)
 		return -ENODEV;
 
-	otg_dev = container_of(otg->phy, struct fsl_otg, phy);
+	otg_dev = container_of(otg->usb_phy, struct fsl_otg, phy);
 	if (otg_dev != fsl_otg_dev)
 		return -ENODEV;
 
@@ -588,7 +589,7 @@ static int fsl_otg_set_peripheral(struct usb_otg *otg,
 	if (!otg)
 		return -ENODEV;
 
-	otg_dev = container_of(otg->phy, struct fsl_otg, phy);
+	otg_dev = container_of(otg->usb_phy, struct fsl_otg, phy);
 	VDBG("otg_dev 0x%x\n", (int)otg_dev);
 	VDBG("fsl_otg_dev 0x%x\n", (int)fsl_otg_dev);
 	if (otg_dev != fsl_otg_dev)
@@ -661,7 +662,7 @@ static int fsl_otg_start_srp(struct usb_otg *otg)
 	if (!otg || otg->phy->state != OTG_STATE_B_IDLE)
 		return -ENODEV;
 
-	otg_dev = container_of(otg->phy, struct fsl_otg, phy);
+	otg_dev = container_of(otg->usb_phy, struct fsl_otg, phy);
 	if (otg_dev != fsl_otg_dev)
 		return -ENODEV;
 
@@ -679,7 +680,7 @@ static int fsl_otg_start_hnp(struct usb_otg *otg)
 	if (!otg)
 		return -ENODEV;
 
-	otg_dev = container_of(otg->phy, struct fsl_otg, phy);
+	otg_dev = container_of(otg->usb_phy, struct fsl_otg, phy);
 	if (otg_dev != fsl_otg_dev)
 		return -ENODEV;
 
@@ -801,7 +802,7 @@ static int fsl_otg_conf(struct platform_device *pdev)
 	fsl_otg_tc->phy.dev = &pdev->dev;
 	fsl_otg_tc->phy.set_power = fsl_otg_set_power;
 
-	fsl_otg_tc->phy.otg->phy = &fsl_otg_tc->phy;
+	fsl_otg_tc->phy.otg->usb_phy = &fsl_otg_tc->phy;
 	fsl_otg_tc->phy.otg->set_host = fsl_otg_set_host;
 	fsl_otg_tc->phy.otg->set_peripheral = fsl_otg_set_peripheral;
 	fsl_otg_tc->phy.otg->start_hnp = fsl_otg_start_hnp;
* Unmerged path drivers/usb/phy/phy-gpio-vbus-usb.c
diff --git a/drivers/usb/phy/phy-isp1301-omap.c b/drivers/usb/phy/phy-isp1301-omap.c
index ae481afcb3ec..74ea085d0fb2 100644
--- a/drivers/usb/phy/phy-isp1301-omap.c
+++ b/drivers/usb/phy/phy-isp1301-omap.c
@@ -1279,7 +1279,7 @@ static int isp1301_otg_enable(struct isp1301 *isp)
 static int
 isp1301_set_host(struct usb_otg *otg, struct usb_bus *host)
 {
-	struct isp1301	*isp = container_of(otg->phy, struct isp1301, phy);
+	struct isp1301	*isp = container_of(otg->usb_phy, struct isp1301, phy);
 
 	if (!otg || isp != the_transceiver)
 		return -ENODEV;
@@ -1335,7 +1335,7 @@ isp1301_set_host(struct usb_otg *otg, struct usb_bus *host)
 static int
 isp1301_set_peripheral(struct usb_otg *otg, struct usb_gadget *gadget)
 {
-	struct isp1301	*isp = container_of(otg->phy, struct isp1301, phy);
+	struct isp1301	*isp = container_of(otg->usb_phy, struct isp1301, phy);
 
 	if (!otg || isp != the_transceiver)
 		return -ENODEV;
@@ -1415,7 +1415,7 @@ isp1301_set_power(struct usb_phy *dev, unsigned mA)
 static int
 isp1301_start_srp(struct usb_otg *otg)
 {
-	struct isp1301	*isp = container_of(otg->phy, struct isp1301, phy);
+	struct isp1301	*isp = container_of(otg->usb_phy, struct isp1301, phy);
 	u32		otg_ctrl;
 
 	if (!otg || isp != the_transceiver
@@ -1443,7 +1443,7 @@ static int
 isp1301_start_hnp(struct usb_otg *otg)
 {
 #ifdef	CONFIG_USB_OTG
-	struct isp1301	*isp = container_of(otg->phy, struct isp1301, phy);
+	struct isp1301	*isp = container_of(otg->usb_phy, struct isp1301, phy);
 	u32 l;
 
 	if (!otg || isp != the_transceiver)
@@ -1588,7 +1588,7 @@ isp1301_probe(struct i2c_client *i2c, const struct i2c_device_id *id)
 	isp->phy.label = DRIVER_NAME;
 	isp->phy.set_power = isp1301_set_power,
 
-	isp->phy.otg->phy = &isp->phy;
+	isp->phy.otg->usb_phy = &isp->phy;
 	isp->phy.otg->set_host = isp1301_set_host,
 	isp->phy.otg->set_peripheral = isp1301_set_peripheral,
 	isp->phy.otg->start_srp = isp1301_start_srp,
* Unmerged path drivers/usb/phy/phy-msm-usb.c
* Unmerged path drivers/usb/phy/phy-mv-usb.c
* Unmerged path drivers/usb/phy/phy-nop.c
* Unmerged path drivers/usb/phy/phy-omap-usb2.c
* Unmerged path drivers/usb/phy/phy-tahvo.c
diff --git a/drivers/usb/phy/phy-ulpi.c b/drivers/usb/phy/phy-ulpi.c
index 217339dd7a90..939b3553ab83 100644
--- a/drivers/usb/phy/phy-ulpi.c
+++ b/drivers/usb/phy/phy-ulpi.c
@@ -208,7 +208,7 @@ static int ulpi_init(struct usb_phy *phy)
 
 static int ulpi_set_host(struct usb_otg *otg, struct usb_bus *host)
 {
-	struct usb_phy *phy = otg->phy;
+	struct usb_phy *phy = otg->usb_phy;
 	unsigned int flags = usb_phy_io_read(phy, ULPI_IFC_CTRL);
 
 	if (!host) {
@@ -234,7 +234,7 @@ static int ulpi_set_host(struct usb_otg *otg, struct usb_bus *host)
 
 static int ulpi_set_vbus(struct usb_otg *otg, bool on)
 {
-	struct usb_phy *phy = otg->phy;
+	struct usb_phy *phy = otg->usb_phy;
 	unsigned int flags = usb_phy_io_read(phy, ULPI_OTG_CTRL);
 
 	flags &= ~(ULPI_OTG_CTRL_DRVVBUS | ULPI_OTG_CTRL_DRVVBUS_EXT);
@@ -273,7 +273,7 @@ otg_ulpi_create(struct usb_phy_io_ops *ops,
 	phy->otg	= otg;
 	phy->init	= ulpi_init;
 
-	otg->phy	= phy;
+	otg->usb_phy	= phy;
 	otg->set_host	= ulpi_set_host;
 	otg->set_vbus	= ulpi_set_vbus;
 
diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 154332b7c8c0..71e369f21b1c 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -14,7 +14,7 @@
 struct usb_otg {
 	u8			default_a;
 
-	struct usb_phy		*phy;
+	struct usb_phy		*usb_phy;
 	struct usb_bus		*host;
 	struct usb_gadget	*gadget;
 
