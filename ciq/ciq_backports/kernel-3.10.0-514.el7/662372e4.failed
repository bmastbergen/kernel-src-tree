of: restructure for_each macros to fix compile warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Rob Herring <robh@kernel.org>
commit 662372e42e46d9bbfcb83e1cce81f6b33cebaddd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/662372e4.failed

Commit 00b2c76a6a "include/linux/of.h: make for_each_child_of_node()
reference its args when CONFIG_OF=n" fixed warnings for unused
variables, but introduced variable "used uninitialized" warnings.
Simply initializing the variables would result in "set but not used"
warnings with W=1.

Fix both types of warnings by making all the for_each macros
unconditional and rely on the dummy static inline functions to
initialize and reference any variables.

	Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
	Cc: David Howells <dhowells@redhat.com>
	Signed-off-by: Rob Herring <robh@kernel.org>
	Acked-by: Grant Likely <grant.likely@linaro.org>
(cherry picked from commit 662372e42e46d9bbfcb83e1cce81f6b33cebaddd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/of.h
diff --cc include/linux/of.h
index 3011d7afd2ce,435cb995904d..000000000000
--- a/include/linux/of.h
+++ b/include/linux/of.h
@@@ -191,24 -167,12 +191,15 @@@ static inline const char *of_node_full_
  	return np ? np->full_name : "<no-node>";
  }
  
 +#define for_each_of_allnodes_from(from, dn) \
 +	for (dn = __of_find_all_nodes(from); dn; dn = __of_find_all_nodes(dn))
 +#define for_each_of_allnodes(dn) for_each_of_allnodes_from(NULL, dn)
  extern struct device_node *of_find_node_by_name(struct device_node *from,
  	const char *name);
- #define for_each_node_by_name(dn, name) \
- 	for (dn = of_find_node_by_name(NULL, name); dn; \
- 	     dn = of_find_node_by_name(dn, name))
  extern struct device_node *of_find_node_by_type(struct device_node *from,
  	const char *type);
- #define for_each_node_by_type(dn, type) \
- 	for (dn = of_find_node_by_type(NULL, type); dn; \
- 	     dn = of_find_node_by_type(dn, type))
  extern struct device_node *of_find_compatible_node(struct device_node *from,
  	const char *type, const char *compat);
- #define for_each_compatible_node(dn, type, compatible) \
- 	for (dn = of_find_compatible_node(NULL, type, compatible); dn; \
- 	     dn = of_find_compatible_node(dn, type, compatible))
  extern struct device_node *of_find_matching_node_and_match(
  	struct device_node *from,
  	const struct of_device_id *matches,
@@@ -236,41 -189,11 +216,9 @@@ extern struct device_node *of_get_next_
  
  extern struct device_node *of_get_child_by_name(const struct device_node *node,
  					const char *name);
- #define for_each_child_of_node(parent, child) \
- 	for (child = of_get_next_child(parent, NULL); child != NULL; \
- 	     child = of_get_next_child(parent, child))
- 
- #define for_each_available_child_of_node(parent, child) \
- 	for (child = of_get_next_available_child(parent, NULL); child != NULL; \
- 	     child = of_get_next_available_child(parent, child))
- 
- static inline int of_get_child_count(const struct device_node *np)
- {
- 	struct device_node *child;
- 	int num = 0;
- 
- 	for_each_child_of_node(np, child)
- 		num++;
- 
- 	return num;
- }
- 
- static inline int of_get_available_child_count(const struct device_node *np)
- {
- 	struct device_node *child;
- 	int num = 0;
- 
- 	for_each_available_child_of_node(np, child)
- 		num++;
- 
- 	return num;
- }
  
 -/* cache lookup */
 -extern struct device_node *of_find_next_cache_node(const struct device_node *);
  extern struct device_node *of_find_node_with_property(
  	struct device_node *from, const char *prop_name);
- #define for_each_node_with_property(dn, prop_name) \
- 	for (dn = of_find_node_with_property(NULL, prop_name); dn; \
- 	     dn = of_find_node_with_property(dn, prop_name))
  
  extern struct property *of_find_property(const struct device_node *np,
  					 const char *name,
@@@ -569,12 -525,16 +528,19 @@@ static inline int of_machine_is_compati
  #if defined(CONFIG_OF) && defined(CONFIG_NUMA)
  extern int of_node_to_nid(struct device_node *np);
  #else
 -static inline int of_node_to_nid(struct device_node *device) { return 0; }
 +static inline int of_node_to_nid(struct device_node *device)
 +{
 +	return NUMA_NO_NODE;
 +}
  #endif
  
+ static inline struct device_node *of_find_matching_node(
+ 	struct device_node *from,
+ 	const struct of_device_id *matches)
+ {
+ 	return of_find_matching_node_and_match(from, matches, NULL);
+ }
+ 
  /**
   * of_property_read_bool - Findfrom a property
   * @np:		device node from which the property value is to be read.
@@@ -612,6 -572,67 +578,70 @@@ static inline int of_property_read_u32(
  	return of_property_read_u32_array(np, propname, out_value, 1);
  }
  
++<<<<<<< HEAD
++=======
+ #define of_property_for_each_u32(np, propname, prop, p, u)	\
+ 	for (prop = of_find_property(np, propname, NULL),	\
+ 		p = of_prop_next_u32(prop, NULL, &u);		\
+ 		p;						\
+ 		p = of_prop_next_u32(prop, p, &u))
+ 
+ #define of_property_for_each_string(np, propname, prop, s)	\
+ 	for (prop = of_find_property(np, propname, NULL),	\
+ 		s = of_prop_next_string(prop, NULL);		\
+ 		s;						\
+ 		s = of_prop_next_string(prop, s))
+ 
+ #define for_each_node_by_name(dn, name) \
+ 	for (dn = of_find_node_by_name(NULL, name); dn; \
+ 	     dn = of_find_node_by_name(dn, name))
+ #define for_each_node_by_type(dn, type) \
+ 	for (dn = of_find_node_by_type(NULL, type); dn; \
+ 	     dn = of_find_node_by_type(dn, type))
+ #define for_each_compatible_node(dn, type, compatible) \
+ 	for (dn = of_find_compatible_node(NULL, type, compatible); dn; \
+ 	     dn = of_find_compatible_node(dn, type, compatible))
+ #define for_each_matching_node(dn, matches) \
+ 	for (dn = of_find_matching_node(NULL, matches); dn; \
+ 	     dn = of_find_matching_node(dn, matches))
+ #define for_each_matching_node_and_match(dn, matches, match) \
+ 	for (dn = of_find_matching_node_and_match(NULL, matches, match); \
+ 	     dn; dn = of_find_matching_node_and_match(dn, matches, match))
+ 
+ #define for_each_child_of_node(parent, child) \
+ 	for (child = of_get_next_child(parent, NULL); child != NULL; \
+ 	     child = of_get_next_child(parent, child))
+ #define for_each_available_child_of_node(parent, child) \
+ 	for (child = of_get_next_available_child(parent, NULL); child != NULL; \
+ 	     child = of_get_next_available_child(parent, child))
+ 
+ #define for_each_node_with_property(dn, prop_name) \
+ 	for (dn = of_find_node_with_property(NULL, prop_name); dn; \
+ 	     dn = of_find_node_with_property(dn, prop_name))
+ 
+ static inline int of_get_child_count(const struct device_node *np)
+ {
+ 	struct device_node *child;
+ 	int num = 0;
+ 
+ 	for_each_child_of_node(np, child)
+ 		num++;
+ 
+ 	return num;
+ }
+ 
+ static inline int of_get_available_child_count(const struct device_node *np)
+ {
+ 	struct device_node *child;
+ 	int num = 0;
+ 
+ 	for_each_available_child_of_node(np, child)
+ 		num++;
+ 
+ 	return num;
+ }
+ 
++>>>>>>> 662372e42e46 (of: restructure for_each macros to fix compile warnings)
  #if defined(CONFIG_PROC_FS) && defined(CONFIG_PROC_DEVICETREE)
  extern void proc_device_tree_add_node(struct device_node *, struct proc_dir_entry *);
  extern void proc_device_tree_add_prop(struct proc_dir_entry *pde, struct property *prop);
* Unmerged path include/linux/of.h
