x86/PCI/ACPI: Relax ACPI resource descriptor checks to work around BIOS bugs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiang Liu <jiang.liu@linux.intel.com>
commit aa714d286f2ea5fae3ca8c75acd03d8694fb657e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/aa714d28.failed

Some BIOSes report incorrect length for ACPI address space descriptors,
so relax the checks to avoid regressions. This issue has appeared several
times as:
 3162b6f0c5e1 ("PNPACPI: truncate _CRS windows with _LEN > _MAX - _MIN + 1")
 d558b483d5a7 ("x86/PCI: truncate _CRS windows with _LEN > _MAX - _MIN + 1")
 f238b414a74a ("PNPACPI: compute Address Space length rather than using _LEN")
 48728e077480 ("x86/PCI: compute Address Space length rather than using _LEN")

Please refer to https://bugzilla.kernel.org/show_bug.cgi?id=94221
for more details and example malformed ACPI resource descriptors.

Link: https://bugzilla.kernel.org/show_bug.cgi?id=94221
Fixes: 593669c2ac0f (x86/PCI/ACPI: Use common ACPI resource interfaces ...)
	Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
	Tested-by: Dave Airlie <airlied@redhat.com>
	Tested-by: Prakash Punnoor <prakash@punnoor.de>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit aa714d286f2ea5fae3ca8c75acd03d8694fb657e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/resource.c
diff --cc drivers/acpi/resource.c
index 1203700d74b8,5589a6e2a023..000000000000
--- a/drivers/acpi/resource.c
+++ b/drivers/acpi/resource.c
@@@ -34,21 -34,36 +34,47 @@@
  #define valid_IRQ(i) (true)
  #endif
  
 -static bool acpi_dev_resource_len_valid(u64 start, u64 end, u64 len, bool io)
 +static unsigned long acpi_dev_memresource_flags(u64 len, u8 write_protect,
 +						bool window)
  {
 -	u64 reslen = end - start + 1;
 +	unsigned long flags = IORESOURCE_MEM;
  
++<<<<<<< HEAD
 +	if (len == 0)
 +		flags |= IORESOURCE_DISABLED;
++=======
+ 	/*
+ 	 * CHECKME: len might be required to check versus a minimum
+ 	 * length as well. 1 for io is fine, but for memory it does
+ 	 * not make any sense at all.
+ 	 * Note: some BIOSes report incorrect length for ACPI address space
+ 	 * descriptor, so remove check of 'reslen == len' to avoid regression.
+ 	 */
+ 	if (len && reslen && start <= end)
+ 		return true;
+ 
+ 	pr_debug("ACPI: invalid or unassigned resource %s [%016llx - %016llx] length [%016llx]\n",
+ 		io ? "io" : "mem", start, end, len);
+ 
+ 	return false;
+ }
+ 
+ static void acpi_dev_memresource_flags(struct resource *res, u64 len,
+ 				       u8 write_protect)
+ {
+ 	res->flags = IORESOURCE_MEM;
+ 
+ 	if (!acpi_dev_resource_len_valid(res->start, res->end, len, false))
+ 		res->flags |= IORESOURCE_DISABLED | IORESOURCE_UNSET;
++>>>>>>> aa714d286f2e (x86/PCI/ACPI: Relax ACPI resource descriptor checks to work around BIOS bugs)
  
  	if (write_protect == ACPI_READ_WRITE_MEMORY)
 -		res->flags |= IORESOURCE_MEM_WRITEABLE;
 +		flags |= IORESOURCE_MEM_WRITEABLE;
 +
 +	if (window)
 +		flags |= IORESOURCE_WINDOW;
 +
 +	return flags;
  }
  
  static void acpi_dev_get_memresource(struct resource *res, u64 start, u64 len,
* Unmerged path drivers/acpi/resource.c
