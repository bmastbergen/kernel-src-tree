block: add __blkdev_issue_discard

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [block] add __blkdev_issue_discard (Mike Snitzer) [1356244 1357031]
Rebuild_FUZZ: 88.14%
commit-author Christoph Hellwig <hch@lst.de>
commit 38f252553300ee1d3346a5273e95fe1dd60ca50a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/38f25255.failed

This is a version of blkdev_issue_discard which doesn't wait for
the I/O to complete, but instead allows the caller to submit
the final bio and/or chain it to others.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Ming Lin <ming.l@ssi.samsung.com>
	Signed-off-by: Sagi Grimberg <sagig@grimberg.me>
	Reviewed-by: Ming Lei <tom.leiming@gmail.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 38f252553300ee1d3346a5273e95fe1dd60ca50a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-lib.c
diff --cc block/blk-lib.c
index 35cdebc4817d,ccbce2b2ea05..000000000000
--- a/block/blk-lib.c
+++ b/block/blk-lib.c
@@@ -9,46 -9,26 +9,41 @@@
  
  #include "blk.h"
  
 -static struct bio *next_bio(struct bio *bio, int rw, unsigned int nr_pages,
 -		gfp_t gfp)
 -{
 -	struct bio *new = bio_alloc(gfp, nr_pages);
 +struct bio_batch {
 +	atomic_t		done;
 +	unsigned long		flags;
 +	struct completion	*wait;
 +};
  
 -	if (bio) {
 -		bio_chain(bio, new);
 -		submit_bio(rw, bio);
 -	}
 +static void bio_batch_end_io(struct bio *bio, int err)
 +{
 +	struct bio_batch *bb = bio->bi_private;
  
 -	return new;
 +	if (err && (err != -EOPNOTSUPP))
 +		clear_bit(BIO_UPTODATE, &bb->flags);
 +	if (atomic_dec_and_test(&bb->done))
 +		complete(bb->wait);
 +	bio_put(bio);
  }
  
- /**
-  * blkdev_issue_discard - queue a discard
-  * @bdev:	blockdev to issue discard for
-  * @sector:	start sector
-  * @nr_sects:	number of sectors to discard
-  * @gfp_mask:	memory allocation flags (for bio_alloc)
-  * @flags:	BLKDEV_IFL_* flags to control behaviour
-  *
-  * Description:
-  *    Issue a discard request for the sectors in question.
-  */
- int blkdev_issue_discard(struct block_device *bdev, sector_t sector,
- 		sector_t nr_sects, gfp_t gfp_mask, unsigned long flags)
+ int __blkdev_issue_discard(struct block_device *bdev, sector_t sector,
+ 		sector_t nr_sects, gfp_t gfp_mask, int type, struct bio **biop)
  {
 +	DECLARE_COMPLETION_ONSTACK(wait);
  	struct request_queue *q = bdev_get_queue(bdev);
++<<<<<<< HEAD
 +	int type = REQ_WRITE | REQ_DISCARD;
 +	unsigned int max_discard_sectors, granularity;
 +	int alignment;
 +	struct bio_batch bb;
 +	struct bio *bio;
 +	int ret = 0;
 +	struct blk_plug plug;
++=======
+ 	struct bio *bio = *biop;
+ 	unsigned int granularity;
+ 	int alignment;
++>>>>>>> 38f252553300 (block: add __blkdev_issue_discard)
  
  	if (!q)
  		return -ENXIO;
@@@ -60,28 -41,6 +56,31 @@@
  	granularity = max(q->limits.discard_granularity >> 9, 1U);
  	alignment = (bdev_discard_alignment(bdev) >> 9) % granularity;
  
++<<<<<<< HEAD
 +	/*
 +	 * Ensure that max_discard_sectors is of the proper
 +	 * granularity, so that requests stay aligned after a split.
 +	 */
 +	max_discard_sectors = min(q->limits.max_discard_sectors, UINT_MAX >> 9);
 +	max_discard_sectors -= max_discard_sectors % granularity;
 +	if (unlikely(!max_discard_sectors)) {
 +		/* Avoid infinite loop below. Being cautious never hurts. */
 +		return -EOPNOTSUPP;
 +	}
 +
 +	if (flags & BLKDEV_DISCARD_SECURE) {
 +		if (!blk_queue_secdiscard(q))
 +			return -EOPNOTSUPP;
 +		type |= REQ_SECURE;
 +	}
 +
 +	atomic_set(&bb.done, 1);
 +	bb.flags = 1 << BIO_UPTODATE;
 +	bb.wait = &wait;
 +
 +	blk_start_plug(&plug);
++=======
++>>>>>>> 38f252553300 (block: add __blkdev_issue_discard)
  	while (nr_sects) {
  		unsigned int req_sects;
  		sector_t end_sect, tmp;
@@@ -128,16 -78,42 +127,52 @@@
  		 */
  		cond_resched();
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	*biop = bio;
+ 	return 0;
+ }
+ EXPORT_SYMBOL(__blkdev_issue_discard);
+ 
+ /**
+  * blkdev_issue_discard - queue a discard
+  * @bdev:	blockdev to issue discard for
+  * @sector:	start sector
+  * @nr_sects:	number of sectors to discard
+  * @gfp_mask:	memory allocation flags (for bio_alloc)
+  * @flags:	BLKDEV_IFL_* flags to control behaviour
+  *
+  * Description:
+  *    Issue a discard request for the sectors in question.
+  */
+ int blkdev_issue_discard(struct block_device *bdev, sector_t sector,
+ 		sector_t nr_sects, gfp_t gfp_mask, unsigned long flags)
+ {
+ 	int type = REQ_WRITE | REQ_DISCARD;
+ 	struct bio *bio = NULL;
+ 	struct blk_plug plug;
+ 	int ret;
+ 
+ 	if (flags & BLKDEV_DISCARD_SECURE)
+ 		type |= REQ_SECURE;
+ 
+ 	blk_start_plug(&plug);
+ 	ret = __blkdev_issue_discard(bdev, sector, nr_sects, gfp_mask, type,
+ 			&bio);
+ 	if (!ret && bio)
+ 		ret = submit_bio_wait(type, bio);
++>>>>>>> 38f252553300 (block: add __blkdev_issue_discard)
  	blk_finish_plug(&plug);
  
 -	return ret != -EOPNOTSUPP ? ret : 0;
 +	/* Wait for bios in-flight */
 +	if (!atomic_dec_and_test(&bb.done))
 +		wait_for_completion_io(&wait);
 +
 +	if (!test_bit(BIO_UPTODATE, &bb.flags))
 +		ret = -EIO;
 +
 +	return ret;
  }
  EXPORT_SYMBOL(blkdev_issue_discard);
  
* Unmerged path block/blk-lib.c
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 0e72d45d3caf..4a29dba29d43 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -1201,6 +1201,8 @@ static inline struct request *blk_map_queue_find_tag(struct blk_queue_tag *bqt,
 extern int blkdev_issue_flush(struct block_device *, gfp_t, sector_t *);
 extern int blkdev_issue_discard(struct block_device *bdev, sector_t sector,
 		sector_t nr_sects, gfp_t gfp_mask, unsigned long flags);
+extern int __blkdev_issue_discard(struct block_device *bdev, sector_t sector,
+		sector_t nr_sects, gfp_t gfp_mask, int type, struct bio **biop);
 extern int blkdev_issue_write_same(struct block_device *bdev, sector_t sector,
 		sector_t nr_sects, gfp_t gfp_mask, struct page *page);
 extern int blkdev_issue_zeroout(struct block_device *bdev, sector_t sector,
