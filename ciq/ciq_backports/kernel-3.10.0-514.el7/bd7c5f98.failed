RDS: TCP: Synchronize accept() and connect() paths on t_conn_lock.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] rds: tcp: Synchronize accept() and connect() paths on t_conn_lock (Honggang Li) [1309411 1342604]
Rebuild_FUZZ: 99.24%
commit-author Sowmini Varadhan <sowmini.varadhan@oracle.com>
commit bd7c5f983f3185b75cc23bdd5dbc3a676aef3d1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bd7c5f98.failed

An arbitration scheme for duelling SYNs is implemented as part of
commit 241b271952eb ("RDS-TCP: Reset tcp callbacks if re-using an
outgoing socket in rds_tcp_accept_one()") which ensures that both nodes
involved will arrive at the same arbitration decision. However, this
needs to be synchronized with an outgoing SYN to be generated by
rds_tcp_conn_connect(). This commit achieves the synchronization
through the t_conn_lock mutex in struct rds_tcp_connection.

The rds_conn_state is checked in rds_tcp_conn_connect() after acquiring
the t_conn_lock mutex.  A SYN is sent out only if the RDS connection is
not already UP (an UP would indicate that rds_tcp_accept_one() has
completed 3WH, so no SYN needs to be generated).

Similarly, the rds_conn_state is checked in rds_tcp_accept_one() after
acquiring the t_conn_lock mutex. The only acceptable states (to
allow continuation of the arbitration logic) are UP (i.e., outgoing SYN
was SYN-ACKed by peer after it sent us the SYN) or CONNECTING (we sent
outgoing SYN before we saw incoming SYN).

	Signed-off-by: Sowmini Varadhan <sowmini.varadhan@oracle.com>
	Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bd7c5f983f3185b75cc23bdd5dbc3a676aef3d1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rds/tcp_listen.c
diff --cc net/rds/tcp_listen.c
index a90a6e704153,be263cdf268b..000000000000
--- a/net/rds/tcp_listen.c
+++ b/net/rds/tcp_listen.c
@@@ -124,30 -117,44 +126,64 @@@ static int rds_tcp_accept_one(struct so
  	 * rds_tcp_state_change() will do that cleanup
  	 */
  	rs_tcp = (struct rds_tcp_connection *)conn->c_transport_data;
++<<<<<<< HEAD
 +	WARN_ON(!rs_tcp || rs_tcp->t_sock);
 +
 +	/*
 +	 * see the comment above rds_queue_delayed_reconnect()
 +	 */
 +	if (!rds_conn_transition(conn, RDS_CONN_DOWN, RDS_CONN_CONNECTING)) {
 +		if (rds_conn_state(conn) == RDS_CONN_UP)
 +			rds_tcp_stats_inc(s_tcp_listen_closed_stale);
 +		else
 +			rds_tcp_stats_inc(s_tcp_connect_raced);
 +		rds_conn_drop(conn);
 +		ret = 0;
 +		goto out;
 +	} else if (rs_tcp->t_sock) {
 +		rds_tcp_restore_callbacks(rs_tcp->t_sock, rs_tcp);
 +		conn->c_outgoing = 0;
++=======
+ 	rds_conn_transition(conn, RDS_CONN_DOWN, RDS_CONN_CONNECTING);
+ 	mutex_lock(&rs_tcp->t_conn_lock);
+ 	conn_state = rds_conn_state(conn);
+ 	if (conn_state != RDS_CONN_CONNECTING && conn_state != RDS_CONN_UP)
+ 		goto rst_nsk;
+ 	if (rs_tcp->t_sock) {
+ 		/* Need to resolve a duelling SYN between peers.
+ 		 * We have an outstanding SYN to this peer, which may
+ 		 * potentially have transitioned to the RDS_CONN_UP state,
+ 		 * so we must quiesce any send threads before resetting
+ 		 * c_transport_data.
+ 		 */
+ 		wait_event(conn->c_waitq,
+ 			   !test_bit(RDS_IN_XMIT, &conn->c_flags));
+ 		if (ntohl(inet->inet_saddr) < ntohl(inet->inet_daddr)) {
+ 			goto rst_nsk;
+ 		} else if (rs_tcp->t_sock) {
+ 			rds_tcp_restore_callbacks(rs_tcp->t_sock, rs_tcp);
+ 			conn->c_outgoing = 0;
+ 		}
++>>>>>>> bd7c5f983f31 (RDS: TCP: Synchronize accept() and connect() paths on t_conn_lock.)
  	}
 +
  	rds_tcp_set_callbacks(new_sock, conn);
 -	rds_connect_complete(conn); /* marks RDS_CONN_UP */
 +	rds_connect_complete(conn);
  	new_sock = NULL;
  	ret = 0;
- 
+ 	goto out;
+ rst_nsk:
+ 	/* reset the newly returned accept sock and bail */
+ 	nsk = new_sock->sk;
+ 	rds_tcp_stats_inc(s_tcp_listen_closed_stale);
+ 	nsk->sk_user_data = NULL;
+ 	nsk->sk_prot->disconnect(nsk, 0);
+ 	tcp_done(nsk);
+ 	new_sock = NULL;
+ 	ret = 0;
  out:
+ 	if (rs_tcp)
+ 		mutex_unlock(&rs_tcp->t_conn_lock);
  	if (new_sock)
  		sock_release(new_sock);
  	return ret;
diff --git a/net/rds/tcp.c b/net/rds/tcp.c
index 0f9cb6d5a317..48247b9c6398 100644
--- a/net/rds/tcp.c
+++ b/net/rds/tcp.c
@@ -196,6 +196,7 @@ static int rds_tcp_conn_alloc(struct rds_connection *conn, gfp_t gfp)
 	if (!tc)
 		return -ENOMEM;
 
+	mutex_init(&tc->t_conn_lock);
 	tc->t_sock = NULL;
 	tc->t_tinc = NULL;
 	tc->t_tinc_hdr_rem = sizeof(struct rds_header);
diff --git a/net/rds/tcp.h b/net/rds/tcp.h
index 9cf2927d0021..255a6e71a6ae 100644
--- a/net/rds/tcp.h
+++ b/net/rds/tcp.h
@@ -12,6 +12,10 @@ struct rds_tcp_connection {
 
 	struct list_head	t_tcp_node;
 	struct rds_connection   *conn;
+	/* t_conn_lock synchronizes the connection establishment between
+	 * rds_tcp_accept_one and rds_tcp_conn_connect
+	 */
+	struct mutex		t_conn_lock;
 	struct socket		*t_sock;
 	void			*t_orig_write_space;
 	void			*t_orig_data_ready;
diff --git a/net/rds/tcp_connect.c b/net/rds/tcp_connect.c
index 6473b7b377ae..41fb3edbe296 100644
--- a/net/rds/tcp_connect.c
+++ b/net/rds/tcp_connect.c
@@ -78,7 +78,14 @@ int rds_tcp_conn_connect(struct rds_connection *conn)
 	struct socket *sock = NULL;
 	struct sockaddr_in src, dest;
 	int ret;
+	struct rds_tcp_connection *tc = conn->c_transport_data;
+
+	mutex_lock(&tc->t_conn_lock);
 
+	if (rds_conn_up(conn)) {
+		mutex_unlock(&tc->t_conn_lock);
+		return 0;
+	}
 	ret = sock_create_kern(rds_conn_net(conn), PF_INET,
 			       SOCK_STREAM, IPPROTO_TCP, &sock);
 	if (ret < 0)
@@ -118,6 +125,7 @@ int rds_tcp_conn_connect(struct rds_connection *conn)
 		rds_tcp_restore_callbacks(sock, conn->c_transport_data);
 
 out:
+	mutex_unlock(&tc->t_conn_lock);
 	if (sock)
 		sock_release(sock);
 	return ret;
* Unmerged path net/rds/tcp_listen.c
