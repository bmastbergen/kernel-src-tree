KVM: x86: Use vector-hashing to deliver lowest-priority interrupts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] kvm: Use vector-hashing to deliver lowest-priority interrupts (Paul Lai) [1319021]
Rebuild_FUZZ: 96.06%
commit-author Feng Wu <feng.wu@intel.com>
commit 520040146a0af36f7875ec06b58f44b19a0edf53
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/52004014.failed

Use vector-hashing to deliver lowest-priority interrupts, As an
example, modern Intel CPUs in server platform use this method to
handle lowest-priority interrupts.

	Signed-off-by: Feng Wu <feng.wu@intel.com>
	Reviewed-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 520040146a0af36f7875ec06b58f44b19a0edf53)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/irq_comm.c
#	arch/x86/kvm/lapic.c
#	arch/x86/kvm/x86.h
diff --cc arch/x86/include/asm/kvm_host.h
index d6bcbdeee5fd,7b5459982433..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -653,6 -751,11 +653,14 @@@ struct kvm_arch 
  	u32 bsp_vcpu_id;
  
  	u64 disabled_quirks;
++<<<<<<< HEAD
++=======
+ 
+ 	bool irqchip_split;
+ 	u8 nr_reserved_ioapic_pins;
+ 
+ 	bool disabled_lapic_found;
++>>>>>>> 520040146a0a (KVM: x86: Use vector-hashing to deliver lowest-priority interrupts)
  };
  
  struct kvm_vm_stat {
diff --cc arch/x86/kvm/irq_comm.c
index e3221fcb17b5,37217363887d..000000000000
--- a/arch/x86/kvm/irq_comm.c
+++ b/arch/x86/kvm/irq_comm.c
@@@ -31,6 -31,11 +31,14 @@@
  
  #include "ioapic.h"
  
++<<<<<<< HEAD
++=======
+ #include "lapic.h"
+ 
+ #include "hyperv.h"
+ #include "x86.h"
+ 
++>>>>>>> 520040146a0a (KVM: x86: Use vector-hashing to deliver lowest-priority interrupts)
  static int kvm_set_pic_irq(struct kvm_kernel_irq_routing_entry *e,
  			   struct kvm *kvm, int irq_source_id, int level,
  			   bool line_status)
@@@ -58,9 -58,11 +66,11 @@@ int kvm_irq_delivery_to_apic(struct kv
  {
  	int i, r = -1;
  	struct kvm_vcpu *vcpu, *lowest = NULL;
+ 	unsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];
+ 	unsigned int dest_vcpus = 0;
  
  	if (irq->dest_mode == 0 && irq->dest_id == 0xff &&
 -			kvm_lowest_prio_delivery(irq)) {
 +			kvm_is_dm_lowest_prio(irq)) {
  		printk(KERN_INFO "kvm: apic: phys broadcast and lowest prio\n");
  		irq->delivery_mode = APIC_DM_FIXED;
  	}
diff --cc arch/x86/kvm/lapic.c
index b157994261cd,1a4ca1d05fe9..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -751,9 -743,10 +767,16 @@@ bool kvm_irq_delivery_to_apic_fast(stru
  
  		dst = map->logical_map[cid];
  
++<<<<<<< HEAD
 +		bitmap = apic_logical_id(map, mda);
 +
 +		if (irq->delivery_mode == APIC_DM_LOWEST) {
++=======
+ 		if (!kvm_lowest_prio_delivery(irq))
+ 			goto set_irq;
+ 
+ 		if (!kvm_vector_hashing_enabled()) {
++>>>>>>> 520040146a0a (KVM: x86: Use vector-hashing to deliver lowest-priority interrupts)
  			int l = -1;
  			for_each_set_bit(i, &bitmap, 16) {
  				if (!dst[i])
diff --cc arch/x86/kvm/x86.h
index b831f04de867,007940faa5c6..000000000000
--- a/arch/x86/kvm/x86.h
+++ b/arch/x86/kvm/x86.h
@@@ -164,11 -172,18 +164,19 @@@ int kvm_write_guest_virt_system(struct 
  	gva_t addr, void *val, unsigned int bytes,
  	struct x86_exception *exception);
  
 -void kvm_vcpu_mtrr_init(struct kvm_vcpu *vcpu);
 -u8 kvm_mtrr_get_guest_memory_type(struct kvm_vcpu *vcpu, gfn_t gfn);
  bool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data);
++<<<<<<< HEAD
++=======
+ int kvm_mtrr_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data);
+ int kvm_mtrr_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata);
+ bool kvm_mtrr_check_gfn_range_consistency(struct kvm_vcpu *vcpu, gfn_t gfn,
+ 					  int page_num);
+ bool kvm_vector_hashing_enabled(void);
++>>>>>>> 520040146a0a (KVM: x86: Use vector-hashing to deliver lowest-priority interrupts)
  
 -#define KVM_SUPPORTED_XCR0     (XFEATURE_MASK_FP | XFEATURE_MASK_SSE \
 -				| XFEATURE_MASK_YMM | XFEATURE_MASK_BNDREGS \
 -				| XFEATURE_MASK_BNDCSR | XFEATURE_MASK_AVX512)
 +#define KVM_SUPPORTED_XCR0     (XSTATE_FP | XSTATE_SSE | XSTATE_YMM \
 +				| XSTATE_BNDREGS | XSTATE_BNDCSR \
 +				| XSTATE_AVX512)
  extern u64 host_xcr0;
  
  extern u64 kvm_supported_xcr0(void);
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/irq_comm.c
* Unmerged path arch/x86/kvm/lapic.c
diff --git a/arch/x86/kvm/lapic.h b/arch/x86/kvm/lapic.h
index d52d4720de8c..0bccbc453918 100644
--- a/arch/x86/kvm/lapic.h
+++ b/arch/x86/kvm/lapic.h
@@ -179,4 +179,6 @@ void wait_lapic_expire(struct kvm_vcpu *vcpu);
 
 bool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,
 			struct kvm_vcpu **dest_vcpu);
+int kvm_vector_to_index(u32 vector, u32 dest_vcpus,
+			const unsigned long *bitmap, u32 bitmap_size);
 #endif
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 9891381973d7..c353e80f50d4 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -122,6 +122,9 @@ module_param(tsc_tolerance_ppm, uint, S_IRUGO | S_IWUSR);
 unsigned int __read_mostly lapic_timer_advance_ns = 0;
 module_param(lapic_timer_advance_ns, uint, S_IRUGO | S_IWUSR);
 
+static bool __read_mostly vector_hashing = true;
+module_param(vector_hashing, bool, S_IRUGO);
+
 static bool __read_mostly backwards_tsc_observed = false;
 
 #define KVM_NR_SHARED_MSRS 16
@@ -8558,6 +8561,12 @@ int kvm_arch_update_irqfd_routing(struct kvm *kvm, unsigned int host_irq,
 	return kvm_x86_ops->update_pi_irte(kvm, host_irq, guest_irq, set);
 }
 
+bool kvm_vector_hashing_enabled(void)
+{
+	return vector_hashing;
+}
+EXPORT_SYMBOL_GPL(kvm_vector_hashing_enabled);
+
 EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_exit);
 EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_fast_mmio);
 EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_inj_virq);
* Unmerged path arch/x86/kvm/x86.h
