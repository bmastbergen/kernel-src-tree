tpm_tis: Use devm_ioremap_resource

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
commit 51dd43dff74b0547ad844638f6910ca29c956819
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/51dd43df.failed

This does a request_resource under the covers which means tis holds a
lock on the memory range it is using so other drivers cannot grab it.
When doing probing it is important to ensure that other drivers are
not using the same range before tis starts touching it.

To do this flow the actual struct resource from the device right
through to devm_ioremap_resource. This ensures all the proper resource
meta-data is carried down.

	Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
	Tested-by: Wilck, Martin <martin.wilck@ts.fujitsu.com>
	Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Acked-by: Peter Huewe <peterhuewe@gmx.de>
(cherry picked from commit 51dd43dff74b0547ad844638f6910ca29c956819)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm_tis.c
diff --cc drivers/char/tpm/tpm_tis.c
index b6392eb21cdb,7407835791ef..000000000000
--- a/drivers/char/tpm/tpm_tis.c
+++ b/drivers/char/tpm/tpm_tis.c
@@@ -65,6 -65,23 +65,26 @@@ enum tis_defaults 
  	TIS_LONG_TIMEOUT = 2000,	/* 2 sec */
  };
  
++<<<<<<< HEAD
++=======
+ struct tpm_info {
+ 	struct resource res;
+ 	/* irq > 0 means: use irq $irq;
+ 	 * irq = 0 means: autoprobe for an irq;
+ 	 * irq = -1 means: no irq support
+ 	 */
+ 	int irq;
+ };
+ 
+ static struct tpm_info tis_default_info = {
+ 	.res = {
+ 		.start = TIS_MEM_BASE,
+ 		.end = TIS_MEM_BASE + TIS_MEM_LEN - 1,
+ 		.flags = IORESOURCE_MEM,
+ 	},
+ 	.irq = 0,
+ };
++>>>>>>> 51dd43dff74b (tpm_tis: Use devm_ioremap_resource)
  
  /* Some timeout values are needed before it is known whether the chip is
   * TPM 1.0 or TPM 2.0.
@@@ -605,9 -693,9 +625,15 @@@ static int tpm_tis_init(struct device *
  	chip->acpi_dev_handle = acpi_dev_handle;
  #endif
  
++<<<<<<< HEAD
 +	chip->vendor.iobase = devm_ioremap(dev, start, len);
 +	if (!chip->vendor.iobase)
 +		return -EIO;
++=======
+ 	chip->vendor.iobase = devm_ioremap_resource(dev, &tpm_info->res);
+ 	if (IS_ERR(chip->vendor.iobase))
+ 		return PTR_ERR(chip->vendor.iobase);
++>>>>>>> 51dd43dff74b (tpm_tis: Use devm_ioremap_resource)
  
  	/* Maximum timeouts */
  	chip->vendor.timeout_a = TIS_TIMEOUT_A_MAX;
@@@ -867,29 -872,32 +893,37 @@@ static SIMPLE_DEV_PM_OPS(tpm_tis_pm, tp
  
  #ifdef CONFIG_PNP
  static int tpm_tis_pnp_init(struct pnp_dev *pnp_dev,
 -			    const struct pnp_device_id *pnp_id)
 +				      const struct pnp_device_id *pnp_id)
  {
 -	struct tpm_info tpm_info = {};
 +	resource_size_t start, len;
 +	unsigned int irq = 0;
  	acpi_handle acpi_dev_handle = NULL;
+ 	struct resource *res;
  
++<<<<<<< HEAD
 +	start = pnp_mem_start(pnp_dev, 0);
 +	len = pnp_mem_len(pnp_dev, 0);
++=======
+ 	res = pnp_get_resource(pnp_dev, IORESOURCE_MEM, 0);
+ 	if (!res)
+ 		return -ENODEV;
+ 	tpm_info.res = *res;
++>>>>>>> 51dd43dff74b (tpm_tis: Use devm_ioremap_resource)
  
  	if (pnp_irq_valid(pnp_dev, 0))
 -		tpm_info.irq = pnp_irq(pnp_dev, 0);
 +		irq = pnp_irq(pnp_dev, 0);
  	else
 -		tpm_info.irq = -1;
 +		interrupts = false;
  
 -#ifdef CONFIG_ACPI
 -	if (pnp_acpi_device(pnp_dev)) {
 -		if (is_itpm(pnp_acpi_device(pnp_dev)))
 -			itpm = true;
 +	if (is_itpm(pnp_dev))
 +		itpm = true;
  
 +#ifdef CONFIG_ACPI
 +	if (pnp_acpi_device(pnp_dev))
  		acpi_dev_handle = pnp_acpi_device(pnp_dev)->handle;
 -	}
  #endif
  
 -	return tpm_tis_init(&pnp_dev->dev, &tpm_info, acpi_dev_handle);
 +	return tpm_tis_init(&pnp_dev->dev, acpi_dev_handle, start, len, irq);
  }
  
  static struct pnp_device_id tpm_pnp_tbl[] = {
@@@ -929,6 -938,91 +963,94 @@@ module_param_string(hid, tpm_pnp_tbl[TI
  MODULE_PARM_DESC(hid, "Set additional specific HID for this driver to probe");
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ACPI
+ static int tpm_check_resource(struct acpi_resource *ares, void *data)
+ {
+ 	struct tpm_info *tpm_info = (struct tpm_info *) data;
+ 	struct resource res;
+ 
+ 	if (acpi_dev_resource_interrupt(ares, 0, &res))
+ 		tpm_info->irq = res.start;
+ 	else if (acpi_dev_resource_memory(ares, &res))
+ 		tpm_info->res = res;
+ 
+ 	return 1;
+ }
+ 
+ static int tpm_tis_acpi_init(struct acpi_device *acpi_dev)
+ {
+ 	struct acpi_table_tpm2 *tbl;
+ 	acpi_status st;
+ 	struct list_head resources;
+ 	struct tpm_info tpm_info = {};
+ 	int ret;
+ 
+ 	st = acpi_get_table(ACPI_SIG_TPM2, 1,
+ 			    (struct acpi_table_header **) &tbl);
+ 	if (ACPI_FAILURE(st) || tbl->header.length < sizeof(*tbl)) {
+ 		dev_err(&acpi_dev->dev,
+ 			FW_BUG "failed to get TPM2 ACPI table\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (tbl->start_method != ACPI_TPM2_MEMORY_MAPPED)
+ 		return -ENODEV;
+ 
+ 	INIT_LIST_HEAD(&resources);
+ 	tpm_info.irq = -1;
+ 	ret = acpi_dev_get_resources(acpi_dev, &resources, tpm_check_resource,
+ 				     &tpm_info);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	acpi_dev_free_resource_list(&resources);
+ 
+ 	if (resource_type(&tpm_info.res) != IORESOURCE_MEM) {
+ 		dev_err(&acpi_dev->dev,
+ 			FW_BUG "TPM2 ACPI table does not define a memory resource\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (is_itpm(acpi_dev))
+ 		itpm = true;
+ 
+ 	return tpm_tis_init(&acpi_dev->dev, &tpm_info, acpi_dev->handle);
+ }
+ 
+ static int tpm_tis_acpi_remove(struct acpi_device *dev)
+ {
+ 	struct tpm_chip *chip = dev_get_drvdata(&dev->dev);
+ 
+ 	tpm_chip_unregister(chip);
+ 	tpm_tis_remove(chip);
+ 
+ 	return 0;
+ }
+ 
+ static struct acpi_device_id tpm_acpi_tbl[] = {
+ 	{"MSFT0101", 0},	/* TPM 2.0 */
+ 	/* Add new here */
+ 	{"", 0},		/* User Specified */
+ 	{"", 0}			/* Terminator */
+ };
+ MODULE_DEVICE_TABLE(acpi, tpm_acpi_tbl);
+ 
+ static struct acpi_driver tis_acpi_driver = {
+ 	.name = "tpm_tis",
+ 	.ids = tpm_acpi_tbl,
+ 	.ops = {
+ 		.add = tpm_tis_acpi_init,
+ 		.remove = tpm_tis_acpi_remove,
+ 	},
+ 	.drv = {
+ 		.pm = &tpm_tis_pm,
+ 	},
+ };
+ #endif
+ 
++>>>>>>> 51dd43dff74b (tpm_tis: Use devm_ioremap_resource)
  static struct platform_driver tis_drv = {
  	.driver = {
  		.name		= "tpm_tis",
* Unmerged path drivers/char/tpm/tpm_tis.c
