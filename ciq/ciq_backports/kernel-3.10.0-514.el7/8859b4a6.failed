staging/rdma/hfi1: Use correct rdmavt header files after move.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Use correct rdmavt header files after move (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 92.17%
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit 8859b4a6d08bcbd804459274c6f4134aaf6ace8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8859b4a6.failed

Rdmavt split the header files to be based on ibta object. This patch
makes changes in hfi1 to account for the move.

	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 8859b4a6d08bcbd804459274c6f4134aaf6ace8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/ud.c
diff --cc drivers/staging/hfi1/ud.c
index a7f67b0111da,55a4eec37331..000000000000
--- a/drivers/staging/hfi1/ud.c
+++ b/drivers/staging/hfi1/ud.c
@@@ -309,12 -309,12 +309,18 @@@ int hfi1_make_ud_req(struct hfi1_qp *qp
  	/* Construct the header. */
  	ibp = to_iport(qp->ibqp.device, qp->port_num);
  	ppd = ppd_from_ibp(ibp);
++<<<<<<< HEAD:drivers/staging/hfi1/ud.c
 +	ah_attr = &to_iah(wqe->wr.wr.ud.ah)->attr;
 +	if (ah_attr->dlid < HFI1_MULTICAST_LID_BASE ||
 +	    ah_attr->dlid == HFI1_PERMISSIVE_LID) {
++=======
+ 	ah_attr = &to_iah(wqe->ud_wr.ah)->attr;
+ 	if (ah_attr->dlid < be16_to_cpu(IB_MULTICAST_LID_BASE) ||
+ 	    ah_attr->dlid == be16_to_cpu(IB_LID_PERMISSIVE)) {
++>>>>>>> 8859b4a6d08b (staging/rdma/hfi1: Use correct rdmavt header files after move.):drivers/staging/rdma/hfi1/ud.c
  		lid = ah_attr->dlid & ~((1 << ppd->lmc) - 1);
  		if (unlikely(!loopback && (lid == ppd->lid ||
- 		    (lid == HFI1_PERMISSIVE_LID &&
+ 		    (lid == be16_to_cpu(IB_LID_PERMISSIVE) &&
  		     qp->ibqp.qp_type == IB_QPT_GSI)))) {
  			/*
  			 * If DMAs are in progress, we can't generate
diff --git a/drivers/staging/hfi1/driver.c b/drivers/staging/hfi1/driver.c
index fca20e92c79b..9d3d8d7c34a8 100644
--- a/drivers/staging/hfi1/driver.c
+++ b/drivers/staging/hfi1/driver.c
@@ -56,6 +56,7 @@
 #include <linux/vmalloc.h>
 #include <linux/module.h>
 #include <linux/prefetch.h>
+#include <rdma/ib_verbs.h>
 
 #include "hfi.h"
 #include "trace.h"
@@ -300,7 +301,7 @@ static void rcv_hdrerr(struct hfi1_ctxtdata *rcd, struct hfi1_pportdata *ppd,
 
 		/* Get the destination QP number. */
 		qp_num = be32_to_cpu(ohdr->bth[1]) & HFI1_QPN_MASK;
-		if (lid < HFI1_MULTICAST_LID_BASE) {
+		if (lid < be16_to_cpu(IB_MULTICAST_LID_BASE)) {
 			struct hfi1_qp *qp;
 			unsigned long flags;
 
diff --git a/drivers/staging/hfi1/mad.c b/drivers/staging/hfi1/mad.c
index a26383d2332e..b509e5d52215 100644
--- a/drivers/staging/hfi1/mad.c
+++ b/drivers/staging/hfi1/mad.c
@@ -1097,7 +1097,7 @@ static int __subn_set_opa_portinfo(struct opa_smp *smp, u32 am, u8 *data,
 
 	/* Must be a valid unicast LID address. */
 	if ((lid == 0 && ls_old > IB_PORT_INIT) ||
-	     lid >= HFI1_MULTICAST_LID_BASE) {
+	     lid >= be16_to_cpu(IB_MULTICAST_LID_BASE)) {
 		smp->status |= IB_SMP_INVALID_FIELD;
 		pr_warn("SubnSet(OPA_PortInfo) lid invalid 0x%x\n",
 			lid);
@@ -1130,7 +1130,7 @@ static int __subn_set_opa_portinfo(struct opa_smp *smp, u32 am, u8 *data,
 
 	/* Must be a valid unicast LID address. */
 	if ((smlid == 0 && ls_old > IB_PORT_INIT) ||
-	     smlid >= HFI1_MULTICAST_LID_BASE) {
+	     smlid >= be16_to_cpu(IB_MULTICAST_LID_BASE)) {
 		smp->status |= IB_SMP_INVALID_FIELD;
 		pr_warn("SubnSet(OPA_PortInfo) smlid invalid 0x%x\n", smlid);
 	} else if (smlid != ibp->sm_lid || msl != ibp->sm_sl) {
diff --git a/drivers/staging/hfi1/qp.c b/drivers/staging/hfi1/qp.c
index 9ffed6e14d8e..c1bee134df68 100644
--- a/drivers/staging/hfi1/qp.c
+++ b/drivers/staging/hfi1/qp.c
@@ -640,7 +640,7 @@ int hfi1_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,
 	if (attr_mask & IB_QP_AV) {
 		u8 sc;
 
-		if (attr->ah_attr.dlid >= HFI1_MULTICAST_LID_BASE)
+		if (attr->ah_attr.dlid >= be16_to_cpu(IB_MULTICAST_LID_BASE))
 			goto inval;
 		if (hfi1_check_ah(qp->ibqp.device, &attr->ah_attr))
 			goto inval;
@@ -653,7 +653,8 @@ int hfi1_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,
 	if (attr_mask & IB_QP_ALT_PATH) {
 		u8 sc;
 
-		if (attr->alt_ah_attr.dlid >= HFI1_MULTICAST_LID_BASE)
+		if (attr->alt_ah_attr.dlid >=
+		    be16_to_cpu(IB_MULTICAST_LID_BASE))
 			goto inval;
 		if (hfi1_check_ah(qp->ibqp.device, &attr->alt_ah_attr))
 			goto inval;
* Unmerged path drivers/staging/hfi1/ud.c
diff --git a/drivers/staging/hfi1/verbs.c b/drivers/staging/hfi1/verbs.c
index cfa74cbcf382..db7c200bb9dd 100644
--- a/drivers/staging/hfi1/verbs.c
+++ b/drivers/staging/hfi1/verbs.c
@@ -634,8 +634,8 @@ void hfi1_ib_rcv(struct hfi1_packet *packet)
 	/* Get the destination QP number. */
 	qp_num = be32_to_cpu(packet->ohdr->bth[1]) & HFI1_QPN_MASK;
 	lid = be16_to_cpu(hdr->lrh[1]);
-	if (unlikely((lid >= HFI1_MULTICAST_LID_BASE) &&
-	    (lid != HFI1_PERMISSIVE_LID))) {
+	if (unlikely((lid >= be16_to_cpu(IB_MULTICAST_LID_BASE)) &&
+		     (lid != be16_to_cpu(IB_LID_PERMISSIVE)))) {
 		struct hfi1_mcast *mcast;
 		struct hfi1_mcast_qp *p;
 
