IB/iser,isert: Create and use new shared header

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [include] ib/iser, isert: Create and use new shared header (Don Dutile) [1169955 1259940 1262728 1275187 1275209 1275423 1275425 1289615 1291874 1292284 1292872 1296195 1296269 1296338 1296344 1298707 1302166 1310156]
Rebuild_FUZZ: 98.95%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit d3cf81f9c805d599e91d1dcaebdd82ec17c299a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d3cf81f9.failed

The iser RDMA_CM negotiation protocol is shared by
the initiator and the target, so have a shared header
for the defines and structure. Move relevant items from
the initiator and target headers.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Jenny Derzhavetz <jennyf@mellanox.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit d3cf81f9c805d599e91d1dcaebdd82ec17c299a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iscsi_iser.h
#	drivers/infiniband/ulp/iser/iser_initiator.c
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.h
index dfd5c4290bc2,d3b2a27ee928..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@@ -146,46 -152,10 +147,49 @@@
  					 - ISER_MAX_RX_MISC_PDUS) /	\
  					 (1 + ISER_INFLIGHT_DATAOUTS))
  
 +#define ISER_WC_BATCH_COUNT   16
  #define ISER_SIGNAL_CMD_COUNT 32
  
++<<<<<<< HEAD
 +#define ISER_VER			0x10
 +#define ISER_WSV			0x08
 +#define ISER_RSV			0x04
 +
 +#define ISER_FASTREG_LI_WRID		0xffffffffffffffffULL
 +#define ISER_BEACON_WRID		0xfffffffffffffffeULL
 +
 +/**
 + * struct iser_hdr - iSER header
 + *
 + * @flags:        flags support (zbva, remote_inv)
 + * @rsvd:         reserved
 + * @write_stag:   write rkey
 + * @write_va:     write virtual address
 + * @reaf_stag:    read rkey
 + * @read_va:      read virtual address
 + */
 +struct iser_hdr {
 +	u8      flags;
 +	u8      rsvd[3];
 +	__be32  write_stag;
 +	__be64  write_va;
 +	__be32  read_stag;
 +	__be64  read_va;
 +} __attribute__((packed));
 +
 +
 +#define ISER_ZBVA_NOT_SUPPORTED		0x80
 +#define ISER_SEND_W_INV_NOT_SUPPORTED	0x40
 +
 +struct iser_cm_hdr {
 +	u8      flags;
 +	u8      rsvd[3];
 +} __packed;
 +
++=======
++>>>>>>> d3cf81f9c805 (IB/iser,isert: Create and use new shared header)
  /* Constant PDU lengths calculations */
- #define ISER_HEADERS_LEN  (sizeof(struct iser_hdr) + sizeof(struct iscsi_hdr))
+ #define ISER_HEADERS_LEN	(sizeof(struct iser_ctrl) + sizeof(struct iscsi_hdr))
  
  #define ISER_RECV_DATA_SEG_LEN	128
  #define ISER_RX_PAYLOAD_SIZE	(ISER_HEADERS_LEN + ISER_RECV_DATA_SEG_LEN)
@@@ -271,9 -245,14 +275,9 @@@ enum iser_desc_type 
   *                 unsolicited data-out or control
   * @num_sge:       number sges used on this TX task
   * @mapped:        Is the task header mapped
 - * @wr_idx:        Current WR index
 - * @wrs:           Array of WRs per task
 - * @data_reg:      Data buffer registration details
 - * @prot_reg:      Protection buffer registration details
 - * @sig_attrs:     Signature attributes
   */
  struct iser_tx_desc {
- 	struct iser_hdr              iser_header;
+ 	struct iser_ctrl             iser_header;
  	struct iscsi_hdr             iscsi_header;
  	enum   iser_desc_type        type;
  	u64		             dma_addr;
diff --cc drivers/infiniband/ulp/iser/iser_initiator.c
index 5458fffc8b40,07ca5a94e60e..000000000000
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@@ -49,10 -49,9 +49,10 @@@ static int iser_prepare_read_cmd(struc
  
  {
  	struct iscsi_iser_task *iser_task = task->dd_data;
 +	struct iser_device  *device = iser_task->iser_conn->ib_conn.device;
  	struct iser_mem_reg *mem_reg;
  	int err;
- 	struct iser_hdr *hdr = &iser_task->desc.iser_header;
+ 	struct iser_ctrl *hdr = &iser_task->desc.iser_header;
  	struct iser_data_buf *buf_in = &iser_task->data[ISER_DIR_IN];
  
  	err = iser_dma_map_task_data(iser_task,
@@@ -103,10 -102,9 +103,10 @@@ iser_prepare_write_cmd(struct iscsi_tas
  		       unsigned int edtl)
  {
  	struct iscsi_iser_task *iser_task = task->dd_data;
 +	struct iser_device  *device = iser_task->iser_conn->ib_conn.device;
  	struct iser_mem_reg *mem_reg;
  	int err;
- 	struct iser_hdr *hdr = &iser_task->desc.iser_header;
+ 	struct iser_ctrl *hdr = &iser_task->desc.iser_header;
  	struct iser_data_buf *buf_out = &iser_task->data[ISER_DIR_OUT];
  	struct ib_sge *tx_dsg = &iser_task->desc.tx_sg[1];
  
@@@ -554,45 -556,69 +554,51 @@@ send_control_error
  	return err;
  }
  
 -void iser_login_rsp(struct ib_cq *cq, struct ib_wc *wc)
 +/**
 + * iser_rcv_dto_completion - recv DTO completion
 + */
 +void iser_rcv_completion(struct iser_rx_desc *rx_desc,
 +			 unsigned long rx_xfer_len,
 +			 struct ib_conn *ib_conn)
  {
 -	struct ib_conn *ib_conn = wc->qp->qp_context;
 -	struct iser_conn *iser_conn = to_iser_conn(ib_conn);
 -	struct iser_login_desc *desc = iser_login(wc->wr_cqe);
 +	struct iser_conn *iser_conn = container_of(ib_conn, struct iser_conn,
 +						   ib_conn);
  	struct iscsi_hdr *hdr;
  	char *data;
 -	int length;
 -
 -	if (unlikely(wc->status != IB_WC_SUCCESS)) {
 -		iser_err_comp(wc, "login_rsp");
 -		return;
 +	u64 rx_dma;
 +	int rx_buflen, outstanding, count, err;
 +
 +	/* differentiate between login to all other PDUs */
 +	if (rx_desc == (void *)&iser_conn->login_desc) {
 +		rx_dma = iser_conn->login_desc.rsp_dma;
 +		rx_buflen = ISER_RX_LOGIN_SIZE;
 +		hdr = iser_conn->login_desc.rsp + sizeof(struct iser_hdr);
 +		data = iser_conn->login_desc.rsp + ISER_HEADERS_LEN;
 +	} else {
 +		rx_dma = rx_desc->dma_addr;
 +		rx_buflen = ISER_RX_PAYLOAD_SIZE;
 +		hdr = &rx_desc->iscsi_header;
 +		data = rx_desc->data;
  	}
  
 -	ib_dma_sync_single_for_cpu(ib_conn->device->ib_device,
 -				   desc->rsp_dma, ISER_RX_LOGIN_SIZE,
 -				   DMA_FROM_DEVICE);
 +	ib_dma_sync_single_for_cpu(ib_conn->device->ib_device, rx_dma,
 +				   rx_buflen, DMA_FROM_DEVICE);
  
++<<<<<<< HEAD
++=======
+ 	hdr = desc->rsp + sizeof(struct iser_ctrl);
+ 	data = desc->rsp + ISER_HEADERS_LEN;
+ 	length = wc->byte_len - ISER_HEADERS_LEN;
++>>>>>>> d3cf81f9c805 (IB/iser,isert: Create and use new shared header)
  
  	iser_dbg("op 0x%x itt 0x%x dlen %d\n", hdr->opcode,
 -		 hdr->itt, length);
 -
 -	iscsi_iser_recv(iser_conn->iscsi_conn, hdr, data, length);
 +			hdr->itt, (int)(rx_xfer_len - ISER_HEADERS_LEN));
  
 -	ib_dma_sync_single_for_device(ib_conn->device->ib_device,
 -				      desc->rsp_dma, ISER_RX_LOGIN_SIZE,
 -				      DMA_FROM_DEVICE);
 +	iscsi_iser_recv(iser_conn->iscsi_conn, hdr, data,
 +			rx_xfer_len - ISER_HEADERS_LEN);
  
 -	ib_conn->post_recv_buf_count--;
 -}
 -
 -void iser_task_rsp(struct ib_cq *cq, struct ib_wc *wc)
 -{
 -	struct ib_conn *ib_conn = wc->qp->qp_context;
 -	struct iser_conn *iser_conn = to_iser_conn(ib_conn);
 -	struct iser_rx_desc *desc = iser_rx(wc->wr_cqe);
 -	struct iscsi_hdr *hdr;
 -	int length;
 -	int outstanding, count, err;
 -
 -	if (unlikely(wc->status != IB_WC_SUCCESS)) {
 -		iser_err_comp(wc, "task_rsp");
 -		return;
 -	}
 -
 -	ib_dma_sync_single_for_cpu(ib_conn->device->ib_device,
 -				   desc->dma_addr, ISER_RX_PAYLOAD_SIZE,
 -				   DMA_FROM_DEVICE);
 -
 -	hdr = &desc->iscsi_header;
 -	length = wc->byte_len - ISER_HEADERS_LEN;
 -
 -	iser_dbg("op 0x%x itt 0x%x dlen %d\n", hdr->opcode,
 -		 hdr->itt, length);
 -
 -	iscsi_iser_recv(iser_conn->iscsi_conn, hdr, desc->data, length);
 -
 -	ib_dma_sync_single_for_device(ib_conn->device->ib_device,
 -				      desc->dma_addr, ISER_RX_PAYLOAD_SIZE,
 -				      DMA_FROM_DEVICE);
 +	ib_dma_sync_single_for_device(ib_conn->device->ib_device, rx_dma,
 +				      rx_buflen, DMA_FROM_DEVICE);
  
  	/* decrementing conn->post_recv_buf_count only --after-- freeing the   *
  	 * task eliminates the need to worry on tasks which are completed in   *
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.h
* Unmerged path drivers/infiniband/ulp/iser/iser_initiator.c
diff --git a/drivers/infiniband/ulp/iser/iser_verbs.c b/drivers/infiniband/ulp/iser/iser_verbs.c
index 862a581a4df5..ac5684377b85 100644
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@ -830,10 +830,9 @@ static void iser_route_handler(struct rdma_cm_id *cma_id)
 	conn_param.rnr_retry_count     = 6;
 
 	memset(&req_hdr, 0, sizeof(req_hdr));
-	req_hdr.flags = (ISER_ZBVA_NOT_SUPPORTED |
-			ISER_SEND_W_INV_NOT_SUPPORTED);
-	conn_param.private_data		= (void *)&req_hdr;
-	conn_param.private_data_len	= sizeof(struct iser_cm_hdr);
+	req_hdr.flags = (ISER_ZBVA_NOT_SUP | ISER_SEND_W_INV_NOT_SUP);
+	conn_param.private_data	= (void *)&req_hdr;
+	conn_param.private_data_len = sizeof(struct iser_cm_hdr);
 
 	ret = rdma_connect(cma_id, &conn_param);
 	if (ret) {
diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c
index 2f51693e7c05..973699419a48 100644
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@ -1080,8 +1080,8 @@ isert_create_send_desc(struct isert_conn *isert_conn,
 	ib_dma_sync_single_for_cpu(ib_dev, tx_desc->dma_addr,
 				   ISER_HEADERS_LEN, DMA_TO_DEVICE);
 
-	memset(&tx_desc->iser_header, 0, sizeof(struct iser_hdr));
-	tx_desc->iser_header.flags = ISER_VER;
+	memset(&tx_desc->iser_header, 0, sizeof(struct iser_ctrl));
+	tx_desc->iser_header.flags = ISCSI_CTRL;
 
 	tx_desc->num_sge = 1;
 	tx_desc->isert_cmd = isert_cmd;
@@ -1573,21 +1573,21 @@ isert_rx_opcode(struct isert_conn *isert_conn, struct iser_rx_desc *rx_desc,
 static void
 isert_rx_do_work(struct iser_rx_desc *rx_desc, struct isert_conn *isert_conn)
 {
-	struct iser_hdr *iser_hdr = &rx_desc->iser_header;
+	struct iser_ctrl *iser_ctrl = &rx_desc->iser_header;
 	uint64_t read_va = 0, write_va = 0;
 	uint32_t read_stag = 0, write_stag = 0;
 
-	switch (iser_hdr->flags & 0xF0) {
+	switch (iser_ctrl->flags & 0xF0) {
 	case ISCSI_CTRL:
-		if (iser_hdr->flags & ISER_RSV) {
-			read_stag = be32_to_cpu(iser_hdr->read_stag);
-			read_va = be64_to_cpu(iser_hdr->read_va);
+		if (iser_ctrl->flags & ISER_RSV) {
+			read_stag = be32_to_cpu(iser_ctrl->read_stag);
+			read_va = be64_to_cpu(iser_ctrl->read_va);
 			isert_dbg("ISER_RSV: read_stag: 0x%x read_va: 0x%llx\n",
 				  read_stag, (unsigned long long)read_va);
 		}
-		if (iser_hdr->flags & ISER_WSV) {
-			write_stag = be32_to_cpu(iser_hdr->write_stag);
-			write_va = be64_to_cpu(iser_hdr->write_va);
+		if (iser_ctrl->flags & ISER_WSV) {
+			write_stag = be32_to_cpu(iser_ctrl->write_stag);
+			write_va = be64_to_cpu(iser_ctrl->write_va);
 			isert_dbg("ISER_WSV: write_stag: 0x%x write_va: 0x%llx\n",
 				  write_stag, (unsigned long long)write_va);
 		}
@@ -1598,7 +1598,7 @@ isert_rx_do_work(struct iser_rx_desc *rx_desc, struct isert_conn *isert_conn)
 		isert_err("iSER Hello message\n");
 		break;
 	default:
-		isert_warn("Unknown iSER hdr flags: 0x%02x\n", iser_hdr->flags);
+		isert_warn("Unknown iSER hdr flags: 0x%02x\n", iser_ctrl->flags);
 		break;
 	}
 
diff --git a/drivers/infiniband/ulp/isert/ib_isert.h b/drivers/infiniband/ulp/isert/ib_isert.h
index 6f7db3ebfd35..65e82998508f 100644
--- a/drivers/infiniband/ulp/isert/ib_isert.h
+++ b/drivers/infiniband/ulp/isert/ib_isert.h
@@ -3,6 +3,8 @@
 #include <linux/in6.h>
 #include <rdma/ib_verbs.h>
 #include <rdma/rdma_cm.h>
+#include <scsi/iser.h>
+
 
 #define DRV_NAME	"isert"
 #define PFX		DRV_NAME ": "
@@ -56,7 +58,7 @@ enum iser_conn_state {
 };
 
 struct iser_rx_desc {
-	struct iser_hdr iser_header;
+	struct iser_ctrl iser_header;
 	struct iscsi_hdr iscsi_header;
 	char		data[ISER_RECV_DATA_SEG_LEN];
 	u64		dma_addr;
@@ -65,7 +67,7 @@ struct iser_rx_desc {
 } __packed;
 
 struct iser_tx_desc {
-	struct iser_hdr iser_header;
+	struct iser_ctrl iser_header;
 	struct iscsi_hdr iscsi_header;
 	enum isert_desc_type type;
 	u64		dma_addr;
diff --git a/drivers/infiniband/ulp/isert/isert_proto.h b/drivers/infiniband/ulp/isert/isert_proto.h
index 4dccd313b777..c835b0083fa7 100644
--- a/drivers/infiniband/ulp/isert/isert_proto.h
+++ b/drivers/infiniband/ulp/isert/isert_proto.h
@@ -1,16 +1,7 @@
 /* From iscsi_iser.h */
 
-struct iser_hdr {
-	u8	flags;
-	u8	rsvd[3];
-	__be32	write_stag; /* write rkey */
-	__be64	write_va;
-	__be32	read_stag;  /* read rkey */
-	__be64	read_va;
-} __packed;
-
-/*Constant PDU lengths calculations */
-#define ISER_HEADERS_LEN  (sizeof(struct iser_hdr) + sizeof(struct iscsi_hdr))
+/* Constant PDU lengths calculations */
+#define ISER_HEADERS_LEN  (sizeof(struct iser_ctrl) + sizeof(struct iscsi_hdr))
 
 #define ISER_RECV_DATA_SEG_LEN  8192
 #define ISER_RX_PAYLOAD_SIZE    (ISER_HEADERS_LEN + ISER_RECV_DATA_SEG_LEN)
@@ -38,10 +29,3 @@ struct iser_hdr {
 
 #define ISER_RX_PAD_SIZE	(ISER_RECV_DATA_SEG_LEN + 4096 - \
 		(ISER_RX_PAYLOAD_SIZE + sizeof(u64) + sizeof(struct ib_sge)))
-
-#define ISER_VER	0x10
-#define ISER_WSV	0x08
-#define ISER_RSV	0x04
-#define ISCSI_CTRL	0x10
-#define ISER_HELLO	0x20
-#define ISER_HELLORPLY	0x30
diff --git a/include/scsi/iser.h b/include/scsi/iser.h
new file mode 100644
index 000000000000..2e678fa74eca
--- /dev/null
+++ b/include/scsi/iser.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2015 Mellanox Technologies. All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *	- Redistributions of source code must retain the above
+ *	  copyright notice, this list of conditions and the following
+ *	  disclaimer.
+ *
+ *	- Redistributions in binary form must reproduce the above
+ *	  copyright notice, this list of conditions and the following
+ *	  disclaimer in the documentation and/or other materials
+ *	  provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#ifndef ISCSI_ISER_H
+#define ISCSI_ISER_H
+
+#define ISER_ZBVA_NOT_SUP		0x80
+#define ISER_SEND_W_INV_NOT_SUP		0x40
+#define ISERT_ZBVA_NOT_USED		0x80
+#define ISERT_SEND_W_INV_NOT_USED	0x40
+
+#define ISCSI_CTRL	0x10
+#define ISER_HELLO	0x20
+#define ISER_HELLORPLY	0x30
+
+#define ISER_VER	0x10
+#define ISER_WSV	0x08
+#define ISER_RSV	0x04
+
+/**
+ * struct iser_cm_hdr - iSER CM header (from iSER Annex A12)
+ *
+ * @flags:        flags support (zbva, send_w_inv)
+ * @rsvd:         reserved
+ */
+struct iser_cm_hdr {
+	u8      flags;
+	u8      rsvd[3];
+} __packed;
+
+/**
+ * struct iser_ctrl - iSER header of iSCSI control PDU
+ *
+ * @flags:        opcode and read/write valid bits
+ * @rsvd:         reserved
+ * @write_stag:   write rkey
+ * @write_va:     write virtual address
+ * @reaf_stag:    read rkey
+ * @read_va:      read virtual address
+ */
+struct iser_ctrl {
+	u8      flags;
+	u8      rsvd[3];
+	__be32  write_stag;
+	__be64  write_va;
+	__be32  read_stag;
+	__be64  read_va;
+} __packed;
+
+#endif /* ISCSI_ISER_H */
