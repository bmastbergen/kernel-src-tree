ipv6: Keep track of DST_NOCACHE routes in case of iface down/unregister

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit 8d0b94afdca84598912347e61defa846a0988d04
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8d0b94af.failed

This patch keeps track of the DST_NOCACHE routes in a list and replaces its
dev with loopback during the iface down/unregister event.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Cc: Steffen Klassert <steffen.klassert@secunet.com>
	Cc: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8d0b94afdca84598912347e61defa846a0988d04)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/route.c
diff --cc net/ipv6/route.c
index d52d1361c9f9,94ce1e0b5a33..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -104,35 -105,75 +104,96 @@@ static struct rt6_info *rt6_get_route_i
  					   const struct in6_addr *gwaddr, int ifindex);
  #endif
  
+ struct uncached_list {
+ 	spinlock_t		lock;
+ 	struct list_head	head;
+ };
+ 
+ static DEFINE_PER_CPU_ALIGNED(struct uncached_list, rt6_uncached_list);
+ 
+ static void rt6_uncached_list_add(struct rt6_info *rt)
+ {
+ 	struct uncached_list *ul = raw_cpu_ptr(&rt6_uncached_list);
+ 
+ 	rt->dst.flags |= DST_NOCACHE;
+ 	rt->rt6i_uncached_list = ul;
+ 
+ 	spin_lock_bh(&ul->lock);
+ 	list_add_tail(&rt->rt6i_uncached, &ul->head);
+ 	spin_unlock_bh(&ul->lock);
+ }
+ 
+ static void rt6_uncached_list_del(struct rt6_info *rt)
+ {
+ 	if (!list_empty(&rt->rt6i_uncached)) {
+ 		struct uncached_list *ul = rt->rt6i_uncached_list;
+ 
+ 		spin_lock_bh(&ul->lock);
+ 		list_del(&rt->rt6i_uncached);
+ 		spin_unlock_bh(&ul->lock);
+ 	}
+ }
+ 
+ static void rt6_uncached_list_flush_dev(struct net *net, struct net_device *dev)
+ {
+ 	struct net_device *loopback_dev = net->loopback_dev;
+ 	int cpu;
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		struct uncached_list *ul = per_cpu_ptr(&rt6_uncached_list, cpu);
+ 		struct rt6_info *rt;
+ 
+ 		spin_lock_bh(&ul->lock);
+ 		list_for_each_entry(rt, &ul->head, rt6i_uncached) {
+ 			struct inet6_dev *rt_idev = rt->rt6i_idev;
+ 			struct net_device *rt_dev = rt->dst.dev;
+ 
+ 			if (rt_idev && (rt_idev->dev == dev || !dev) &&
+ 			    rt_idev->dev != loopback_dev) {
+ 				rt->rt6i_idev = in6_dev_get(loopback_dev);
+ 				in6_dev_put(rt_idev);
+ 			}
+ 
+ 			if (rt_dev && (rt_dev == dev || !dev) &&
+ 			    rt_dev != loopback_dev) {
+ 				rt->dst.dev = loopback_dev;
+ 				dev_hold(rt->dst.dev);
+ 				dev_put(rt_dev);
+ 			}
+ 		}
+ 		spin_unlock_bh(&ul->lock);
+ 	}
+ }
+ 
  static u32 *ipv6_cow_metrics(struct dst_entry *dst, unsigned long old)
  {
 -	struct rt6_info *rt = (struct rt6_info *)dst;
 +	struct rt6_info *rt = (struct rt6_info *) dst;
 +	struct inet_peer *peer;
 +	u32 *p = NULL;
  
 -	if (rt->rt6i_flags & RTF_CACHE)
 -		return NULL;
 -	else
 +	if (!(rt->dst.flags & DST_HOST))
  		return dst_cow_metrics_generic(dst, old);
 +
 +	peer = rt6_get_peer_create(rt);
 +	if (peer) {
 +		u32 *old_p = __DST_METRICS_PTR(old);
 +		unsigned long prev, new;
 +
 +		p = peer->metrics;
 +		if (inet_metrics_new(peer) ||
 +		    (old & DST_METRICS_FORCE_OVERWRITE))
 +			memcpy(p, old_p, sizeof(u32) * RTAX_MAX);
 +
 +		new = (unsigned long) p;
 +		prev = cmpxchg(&dst->_metrics, old, new);
 +
 +		if (prev != old) {
 +			p = __DST_METRICS_PTR(prev);
 +			if (prev & DST_METRICS_READ_ONLY)
 +				p = NULL;
 +		}
 +	}
 +	return p;
  }
  
  static inline const void *choose_neigh_daddr(struct rt6_info *rt,
@@@ -291,12 -331,14 +353,15 @@@ static inline struct rt6_info *ip6_dst_
  static void ip6_dst_destroy(struct dst_entry *dst)
  {
  	struct rt6_info *rt = (struct rt6_info *)dst;
- 	struct inet6_dev *idev = rt->rt6i_idev;
  	struct dst_entry *from = dst->from;
+ 	struct inet6_dev *idev;
  
 -	dst_destroy_metrics_generic(dst);
 +	if (!(rt->dst.flags & DST_HOST))
 +		dst_destroy_metrics_generic(dst);
  
+ 	rt6_uncached_list_del(rt);
+ 
+ 	idev = rt->rt6i_idev;
  	if (idev) {
  		rt->rt6i_idev = NULL;
  		in6_dev_put(idev);
@@@ -953,42 -966,34 +1018,51 @@@ redo_rt6_select
  		}
  	}
  
 -	dst_use(&rt->dst, jiffies);
 +	dst_hold(&rt->dst);
  	read_unlock_bh(&table->tb6_lock);
  
 -	if (rt == net->ipv6.ip6_null_entry || (rt->rt6i_flags & RTF_CACHE)) {
 -		goto done;
 -	} else if (unlikely((fl6->flowi6_flags & FLOWI_FLAG_KNOWN_NH) &&
 -			    !(rt->rt6i_flags & RTF_GATEWAY))) {
 -		/* Create a RTF_CACHE clone which will not be
 -		 * owned by the fib6 tree.  It is for the special case where
 -		 * the daddr in the skb during the neighbor look-up is different
 -		 * from the fl6->daddr used to look-up route here.
 -		 */
 +	if (rt->rt6i_flags & RTF_CACHE)
 +		goto out2;
  
 -		struct rt6_info *uncached_rt;
 +	if (!rt6_is_gw_or_nonexthop(rt) ||
 +	    !(rt->dst.flags & DST_HOST) || !(rt->rt6i_flags & RTF_LOCAL))
 +		nrt = ip6_rt_cache_alloc(rt, &fl6->daddr, &fl6->saddr);
 +	else
 +		goto out2;
  
 -		uncached_rt = ip6_rt_cache_alloc(rt, &fl6->daddr, NULL);
 -		dst_release(&rt->dst);
 +	ip6_rt_put(rt);
 +	rt = nrt ? : net->ipv6.ip6_null_entry;
  
++<<<<<<< HEAD
 +	dst_hold(&rt->dst);
 +	if (nrt) {
 +		err = ip6_ins_rt(nrt);
 +		if (!err)
 +			goto out2;
++=======
+ 		if (uncached_rt)
+ 			rt6_uncached_list_add(uncached_rt);
+ 		else
+ 			uncached_rt = net->ipv6.ip6_null_entry;
+ 		dst_hold(&uncached_rt->dst);
+ 		return uncached_rt;
++>>>>>>> 8d0b94afdca8 (ipv6: Keep track of DST_NOCACHE routes in case of iface down/unregister)
  	}
  
 -done:
 -	rt6_dst_from_metrics_check(rt);
 +	if (--attempts <= 0)
 +		goto out2;
 +
 +	/*
 +	 * Race condition! In the gap, when table->tb6_lock was
 +	 * released someone could insert this route.  Relookup.
 +	 */
 +	ip6_rt_put(rt);
 +	goto redo_fib6_lookup_lock;
 +
 +out2:
 +	rt->dst.lastuse = jiffies;
 +	rt->dst.__use++;
 +
  	return rt;
  }
  
diff --git a/include/net/ip6_fib.h b/include/net/ip6_fib.h
index d152e230d58f..ccfeddf4e94e 100644
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@ -121,6 +121,9 @@ struct rt6_info {
 	struct rt6key			rt6i_prefsrc;
 	u32				rt6i_metric;
 
+	struct list_head		rt6i_uncached;
+	struct uncached_list		*rt6i_uncached_list;
+
 	struct inet6_dev		*rt6i_idev;
 
 	/* RHEL specific:
* Unmerged path net/ipv6/route.c
