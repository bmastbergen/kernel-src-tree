x86/nmi/64: Improve nested NMI comments

jira LE-1907
cve CVE-2015-5157
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] nmi: Improve nested NMI comments (Mateusz Guzik) [1259583] {CVE-2015-5157}
Rebuild_FUZZ: 90.14%
commit-author Andy Lutomirski <luto@kernel.org>
commit 0b22930ebad563ae97ff3f8d7b9f12060b4c6e6b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0b22930e.failed

I found the nested NMI documentation to be difficult to follow.
Improve the comments.

	Signed-off-by: Andy Lutomirski <luto@kernel.org>
	Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
	Cc: Borislav Petkov <bp@suse.de>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: stable@vger.kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 0b22930ebad563ae97ff3f8d7b9f12060b4c6e6b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/entry/entry_64.S
#	arch/x86/kernel/nmi.c
diff --cc arch/x86/kernel/nmi.c
index 60308053fdb2,d05bd2e2ee91..000000000000
--- a/arch/x86/kernel/nmi.c
+++ b/arch/x86/kernel/nmi.c
@@@ -357,17 -405,18 +357,29 @@@ static __kprobes void default_do_nmi(st
  	else
  		unknown_nmi_error(reason, regs);
  }
 -NOKPROBE_SYMBOL(default_do_nmi);
  
  /*
++<<<<<<< HEAD
 + * NMIs can hit breakpoints which will cause it to lose its
 + * NMI context with the CPU when the breakpoint does an iret.
 + */
 +#ifdef CONFIG_X86_32
 +/*
 + * For i386, NMIs use the same stack as the kernel, and we can
 + * add a workaround to the iret problem in C (preventing nested
 + * NMIs if an NMI takes a trap). Simply have 3 states the NMI
 + * can be in:
++=======
+  * NMIs can page fault or hit breakpoints which will cause it to lose
+  * its NMI context with the CPU when the breakpoint or page fault does an IRET.
+  *
+  * As a result, NMIs can nest if NMIs get unmasked due an IRET during
+  * NMI processing.  On x86_64, the asm glue protects us from nested NMIs
+  * if the outer NMI came from kernel mode, but we can still nest if the
+  * outer NMI came from user mode.
+  *
+  * To handle these nested NMIs, we have three states:
++>>>>>>> 0b22930ebad5 (x86/nmi/64: Improve nested NMI comments)
   *
   *  1) not running
   *  2) executing
* Unmerged path arch/x86/entry/entry_64.S
* Unmerged path arch/x86/entry/entry_64.S
* Unmerged path arch/x86/kernel/nmi.c
