tracing: Add trace_<tracepoint>_enabled() function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Steven Rostedt (Red Hat) <rostedt@goodmis.org>
commit 7c65bbc7dcface00b295bbd18bce82fe1db3d633
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7c65bbc7.failed

There are some code paths in the kernel that need to do some preparations
before it calls a tracepoint. As that code is worthless overhead when
the tracepoint is not enabled, it would be prudent to have that code
only run when the tracepoint is active. To accomplish this, all tracepoints
now get a static inline function called "trace_<tracepoint-name>_enabled()"
which returns true when the tracepoint is enabled and false otherwise.

As an added bonus, that function uses the static_key of the tracepoint
such that no branch is needed.

  if (trace_mytracepoint_enabled()) {
	arg = process_tp_arg();
	trace_mytracepoint(arg);
  }

Will keep the "process_tp_arg()" (which may be expensive to run) from
being executed when the tracepoint isn't enabled.

It's best to encapsulate the tracepoint itself in the if statement
just to keep races. For example, if you had:

  if (trace_mytracepoint_enabled())
	arg = process_tp_arg();
  trace_mytracepoint(arg);

There's a chance that the tracepoint could be enabled just after the
if statement, and arg will be undefined when calling the tracepoint.

Link: http://lkml.kernel.org/r/20140506094407.507b6435@gandalf.local.home

	Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
	Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
(cherry picked from commit 7c65bbc7dcface00b295bbd18bce82fe1db3d633)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/trace/tracepoints.txt
diff --cc Documentation/trace/tracepoints.txt
index da49437d5aeb,a3efac621c5a..000000000000
--- a/Documentation/trace/tracepoints.txt
+++ b/Documentation/trace/tracepoints.txt
@@@ -99,3 -114,32 +99,35 @@@ core kernel image or in modules
  If the tracepoint has to be used in kernel modules, an
  EXPORT_TRACEPOINT_SYMBOL_GPL() or EXPORT_TRACEPOINT_SYMBOL() can be
  used to export the defined tracepoints.
++<<<<<<< HEAD
++=======
+ 
+ If you need to do a bit of work for a tracepoint parameter, and
+ that work is only used for the tracepoint, that work can be encapsulated
+ within an if statement with the following:
+ 
+ 	if (trace_foo_bar_enabled()) {
+ 		int i;
+ 		int tot = 0;
+ 
+ 		for (i = 0; i < count; i++)
+ 			tot += calculate_nuggets();
+ 
+ 		trace_foo_bar(tot);
+ 	}
+ 
+ All trace_<tracepoint>() calls have a matching trace_<tracepoint>_enabled()
+ function defined that returns true if the tracepoint is enabled and
+ false otherwise. The trace_<tracepoint>() should always be within the
+ block of the if (trace_<tracepoint>_enabled()) to prevent races between
+ the tracepoint being enabled and the check being seen.
+ 
+ The advantage of using the trace_<tracepoint>_enabled() is that it uses
+ the static_key of the tracepoint to allow the if statement to be implemented
+ with jump labels and avoid conditional branches.
+ 
+ Note: The convenience macro TRACE_EVENT provides an alternative way to
+       define tracepoints. Check http://lwn.net/Articles/379903,
+       http://lwn.net/Articles/381064 and http://lwn.net/Articles/383362
+       for a series of articles with more details.
++>>>>>>> 7c65bbc7dcfa (tracing: Add trace_<tracepoint>_enabled() function)
* Unmerged path Documentation/trace/tracepoints.txt
diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index ebeab360d851..0eeec044f8d9 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -184,6 +184,11 @@ static inline void tracepoint_synchronize_unregister(void)
 	static inline void						\
 	check_trace_callback_type_##name(void (*cb)(data_proto))	\
 	{								\
+	}								\
+	static inline bool						\
+	trace_##name##_enabled(void)					\
+	{								\
+		return static_key_false(&__tracepoint_##name.key);	\
 	}
 
 /*
@@ -229,6 +234,11 @@ static inline void tracepoint_synchronize_unregister(void)
 	}								\
 	static inline void check_trace_callback_type_##name(void (*cb)(data_proto)) \
 	{								\
+	}								\
+	static inline bool						\
+	trace_##name##_enabled(void)					\
+	{								\
+		return false;						\
 	}
 
 #define DEFINE_TRACE_FN(name, reg, unreg)
