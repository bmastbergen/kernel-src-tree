device property: Don't overwrite addr when failing in device_get_mac_address

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Julien Grall <julien.grall@citrix.com>
commit 5b902d6f97f573fde911338e5d943e6b07fac7f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5b902d6f.failed

The function device_get_mac_address is trying different property names
in order to get the mac address. To check the return value, the variable
addr (which contain the buffer pass by the caller) will be re-used. This
means that if the previous property is not found, the next property will
be read using a NULL buffer.

Therefore it's only possible to retrieve the mac if node contains a
property "mac-address". Fix it by using a temporary buffer for the
return value.

This has been introduced by commit 4c96b7dc0d393f12c17e0d81db15aa4a820a6ab3
"Add a matching set of device_ functions for determining mac/phy"

	Signed-off-by: Julien Grall <julien.grall@citrix.com>
	Cc: Jeremy Linton <jeremy.linton@arm.com>
	Cc: David S. Miller <davem@davemloft.net>
	Reviewed-by: Jeremy Linton <jeremy.linton@arm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5b902d6f97f573fde911338e5d943e6b07fac7f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/property.c
diff --cc drivers/base/property.c
index 6a94ef6e83c9,2d75366c61e0..000000000000
--- a/drivers/base/property.c
+++ b/drivers/base/property.c
@@@ -177,9 -283,344 +177,350 @@@ EXPORT_SYMBOL_GPL(device_property_read_
  int device_property_read_string(struct device *dev, const char *propname,
  				const char **val)
  {
 -	return fwnode_property_read_string(dev_fwnode(dev), propname, val);
 +	return IS_ENABLED(CONFIG_OF) && dev->of_node ?
 +		of_property_read_string(dev->of_node, propname, val) :
 +		acpi_dev_prop_read(ACPI_COMPANION(dev), propname,
 +				   DEV_PROP_STRING, val, 1);
  }
  EXPORT_SYMBOL_GPL(device_property_read_string);
++<<<<<<< HEAD
++=======
+ 
+ #define OF_DEV_PROP_READ_ARRAY(node, propname, type, val, nval) \
+ 	(val) ? of_property_read_##type##_array((node), (propname), (val), (nval)) \
+ 	      : of_property_count_elems_of_size((node), (propname), sizeof(type))
+ 
+ #define FWNODE_PROP_READ_ARRAY(_fwnode_, _propname_, _type_, _proptype_, _val_, _nval_) \
+ ({ \
+ 	int _ret_; \
+ 	if (is_of_node(_fwnode_)) \
+ 		_ret_ = OF_DEV_PROP_READ_ARRAY(to_of_node(_fwnode_), _propname_, \
+ 					       _type_, _val_, _nval_); \
+ 	else if (is_acpi_node(_fwnode_)) \
+ 		_ret_ = acpi_dev_prop_read(to_acpi_node(_fwnode_), _propname_, \
+ 					   _proptype_, _val_, _nval_); \
+ 	else if (is_pset(_fwnode_)) \
+ 		_ret_ = pset_prop_read_array(to_pset(_fwnode_), _propname_, \
+ 					     _proptype_, _val_, _nval_); \
+ 	else \
+ 		_ret_ = -ENXIO; \
+ 	_ret_; \
+ })
+ 
+ /**
+  * fwnode_property_read_u8_array - return a u8 array property of firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u8 properties with @propname from @fwnode and stores them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u8_array(struct fwnode_handle *fwnode,
+ 				  const char *propname, u8 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u8, DEV_PROP_U8,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u8_array);
+ 
+ /**
+  * fwnode_property_read_u16_array - return a u16 array property of firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u16 properties with @propname from @fwnode and store them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u16_array(struct fwnode_handle *fwnode,
+ 				   const char *propname, u16 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u16, DEV_PROP_U16,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u16_array);
+ 
+ /**
+  * fwnode_property_read_u32_array - return a u32 array property of firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u32 properties with @propname from @fwnode store them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u32_array(struct fwnode_handle *fwnode,
+ 				   const char *propname, u32 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u32, DEV_PROP_U32,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u32_array);
+ 
+ /**
+  * fwnode_property_read_u64_array - return a u64 array property firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u64 properties with @propname from @fwnode and store them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u64_array(struct fwnode_handle *fwnode,
+ 				   const char *propname, u64 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u64, DEV_PROP_U64,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u64_array);
+ 
+ /**
+  * fwnode_property_read_string_array - return string array property of a node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an string list property @propname from the given firmware node and store
+  * them to @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of strings,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_string_array(struct fwnode_handle *fwnode,
+ 				      const char *propname, const char **val,
+ 				      size_t nval)
+ {
+ 	if (is_of_node(fwnode))
+ 		return val ?
+ 			of_property_read_string_array(to_of_node(fwnode),
+ 						      propname, val, nval) :
+ 			of_property_count_strings(to_of_node(fwnode), propname);
+ 	else if (is_acpi_node(fwnode))
+ 		return acpi_dev_prop_read(to_acpi_node(fwnode), propname,
+ 					  DEV_PROP_STRING, val, nval);
+ 	else if (is_pset(fwnode))
+ 		return pset_prop_read_array(to_pset(fwnode), propname,
+ 					    DEV_PROP_STRING, val, nval);
+ 	return -ENXIO;
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_string_array);
+ 
+ /**
+  * fwnode_property_read_string - return a string property of a firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The value is stored here
+  *
+  * Read property @propname from the given firmware node and store the value into
+  * @val if found.  The value is checked to be a string.
+  *
+  * Return: %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO or %-EILSEQ if the property is not a string,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_string(struct fwnode_handle *fwnode,
+ 				const char *propname, const char **val)
+ {
+ 	if (is_of_node(fwnode))
+ 		return of_property_read_string(to_of_node(fwnode), propname, val);
+ 	else if (is_acpi_node(fwnode))
+ 		return acpi_dev_prop_read(to_acpi_node(fwnode), propname,
+ 					  DEV_PROP_STRING, val, 1);
+ 
+ 	return pset_prop_read_array(to_pset(fwnode), propname,
+ 				    DEV_PROP_STRING, val, 1);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_string);
+ 
+ /**
+  * device_get_next_child_node - Return the next child node handle for a device
+  * @dev: Device to find the next child node for.
+  * @child: Handle to one of the device's child nodes or a null handle.
+  */
+ struct fwnode_handle *device_get_next_child_node(struct device *dev,
+ 						 struct fwnode_handle *child)
+ {
+ 	if (IS_ENABLED(CONFIG_OF) && dev->of_node) {
+ 		struct device_node *node;
+ 
+ 		node = of_get_next_available_child(dev->of_node, to_of_node(child));
+ 		if (node)
+ 			return &node->fwnode;
+ 	} else if (IS_ENABLED(CONFIG_ACPI)) {
+ 		struct acpi_device *node;
+ 
+ 		node = acpi_get_next_child(dev, to_acpi_node(child));
+ 		if (node)
+ 			return acpi_fwnode_handle(node);
+ 	}
+ 	return NULL;
+ }
+ EXPORT_SYMBOL_GPL(device_get_next_child_node);
+ 
+ /**
+  * fwnode_handle_put - Drop reference to a device node
+  * @fwnode: Pointer to the device node to drop the reference to.
+  *
+  * This has to be used when terminating device_for_each_child_node() iteration
+  * with break or return to prevent stale device node references from being left
+  * behind.
+  */
+ void fwnode_handle_put(struct fwnode_handle *fwnode)
+ {
+ 	if (is_of_node(fwnode))
+ 		of_node_put(to_of_node(fwnode));
+ }
+ EXPORT_SYMBOL_GPL(fwnode_handle_put);
+ 
+ /**
+  * device_get_child_node_count - return the number of child nodes for device
+  * @dev: Device to cound the child nodes for
+  */
+ unsigned int device_get_child_node_count(struct device *dev)
+ {
+ 	struct fwnode_handle *child;
+ 	unsigned int count = 0;
+ 
+ 	device_for_each_child_node(dev, child)
+ 		count++;
+ 
+ 	return count;
+ }
+ EXPORT_SYMBOL_GPL(device_get_child_node_count);
+ 
+ bool device_dma_is_coherent(struct device *dev)
+ {
+ 	bool coherent = false;
+ 
+ 	if (IS_ENABLED(CONFIG_OF) && dev->of_node)
+ 		coherent = of_dma_is_coherent(dev->of_node);
+ 	else
+ 		acpi_check_dma(ACPI_COMPANION(dev), &coherent);
+ 
+ 	return coherent;
+ }
+ EXPORT_SYMBOL_GPL(device_dma_is_coherent);
+ 
+ /**
+  * device_get_phy_mode - Get phy mode for given device
+  * @dev:	Pointer to the given device
+  *
+  * The function gets phy interface string from property 'phy-mode' or
+  * 'phy-connection-type', and return its index in phy_modes table, or errno in
+  * error case.
+  */
+ int device_get_phy_mode(struct device *dev)
+ {
+ 	const char *pm;
+ 	int err, i;
+ 
+ 	err = device_property_read_string(dev, "phy-mode", &pm);
+ 	if (err < 0)
+ 		err = device_property_read_string(dev,
+ 						  "phy-connection-type", &pm);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	for (i = 0; i < PHY_INTERFACE_MODE_MAX; i++)
+ 		if (!strcasecmp(pm, phy_modes(i)))
+ 			return i;
+ 
+ 	return -ENODEV;
+ }
+ EXPORT_SYMBOL_GPL(device_get_phy_mode);
+ 
+ static void *device_get_mac_addr(struct device *dev,
+ 				 const char *name, char *addr,
+ 				 int alen)
+ {
+ 	int ret = device_property_read_u8_array(dev, name, addr, alen);
+ 
+ 	if (ret == 0 && alen == ETH_ALEN && is_valid_ether_addr(addr))
+ 		return addr;
+ 	return NULL;
+ }
+ 
+ /**
+  * device_get_mac_address - Get the MAC for a given device
+  * @dev:	Pointer to the device
+  * @addr:	Address of buffer to store the MAC in
+  * @alen:	Length of the buffer pointed to by addr, should be ETH_ALEN
+  *
+  * Search the firmware node for the best MAC address to use.  'mac-address' is
+  * checked first, because that is supposed to contain to "most recent" MAC
+  * address. If that isn't set, then 'local-mac-address' is checked next,
+  * because that is the default address.  If that isn't set, then the obsolete
+  * 'address' is checked, just in case we're using an old device tree.
+  *
+  * Note that the 'address' property is supposed to contain a virtual address of
+  * the register set, but some DTS files have redefined that property to be the
+  * MAC address.
+  *
+  * All-zero MAC addresses are rejected, because those could be properties that
+  * exist in the firmware tables, but were not updated by the firmware.  For
+  * example, the DTS could define 'mac-address' and 'local-mac-address', with
+  * zero MAC addresses.  Some older U-Boots only initialized 'local-mac-address'.
+  * In this case, the real MAC is in 'local-mac-address', and 'mac-address'
+  * exists but is all zeros.
+ */
+ void *device_get_mac_address(struct device *dev, char *addr, int alen)
+ {
+ 	char *res;
+ 
+ 	res = device_get_mac_addr(dev, "mac-address", addr, alen);
+ 	if (res)
+ 		return res;
+ 
+ 	res = device_get_mac_addr(dev, "local-mac-address", addr, alen);
+ 	if (res)
+ 		return res;
+ 
+ 	return device_get_mac_addr(dev, "address", addr, alen);
+ }
+ EXPORT_SYMBOL(device_get_mac_address);
++>>>>>>> 5b902d6f97f5 (device property: Don't overwrite addr when failing in device_get_mac_address)
* Unmerged path drivers/base/property.c
