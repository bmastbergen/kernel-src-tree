cxgb4: Add debugfs entry to enable backdoor access

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit 0b2c2a931a051e75f9df429b520bb2c2f2bb056b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0b2c2a93.failed

Add debugfs entry 'use_backdoor' to enable backdoor access to read sge
context. By default, we read sge context's via firmware. In case of FW
issues, one can enable backdoor access via debugfs to dump sge context
for debugging purpose.

	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0b2c2a931a051e75f9df429b520bb2c2f2bb056b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
#	drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
index eb66d912948d,f701a6f20c6a..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
@@@ -2303,11 -2379,17 +2303,18 @@@ int t4_setup_debugfs(struct adapter *ad
  			add_debugfs_mem(adap, "mc1", MEM_MC1,
  					EXT_MEM1_SIZE_G(size));
  		}
 -	} else {
 -		if (i & EXT_MEM_ENABLE_F)
 -			size = t4_read_reg(adap, MA_EXT_MEMORY_BAR_A);
 -			add_debugfs_mem(adap, "mc", MEM_MC,
 -					EXT_MEM_SIZE_G(size));
  	}
  
++<<<<<<< HEAD
 +	de = debugfs_create_file("flash", S_IRUSR, adap->debugfs_root, adap,
 +				 &flash_debugfs_fops);
 +	set_debugfs_file_size(de, adap->params.sf_size);
++=======
+ 	de = debugfs_create_file_size("flash", S_IRUSR, adap->debugfs_root, adap,
+ 				      &flash_debugfs_fops, adap->params.sf_size);
+ 	debugfs_create_bool("use_backdoor", S_IWUSR | S_IRUSR,
+ 			    adap->debugfs_root, &adap->use_bd);
++>>>>>>> 0b2c2a931a05 (cxgb4: Add debugfs entry to enable backdoor access)
  
  	return 0;
  }
diff --cc drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index d5fb4066b888,800bd489dd75..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@@ -3717,6 -3689,45 +3717,11 @@@ int t4_read_rss(struct adapter *adapter
  	return 0;
  }
  
+ static unsigned int t4_use_ldst(struct adapter *adap)
+ {
+ 	return (adap->flags & FW_OK) || !adap->use_bd;
+ }
+ 
 -/**
 - *	t4_fw_tp_pio_rw - Access TP PIO through LDST
 - *	@adap: the adapter
 - *	@vals: where the indirect register values are stored/written
 - *	@nregs: how many indirect registers to read/write
 - *	@start_idx: index of first indirect register to read/write
 - *	@rw: Read (1) or Write (0)
 - *
 - *	Access TP PIO registers through LDST
 - */
 -static void t4_fw_tp_pio_rw(struct adapter *adap, u32 *vals, unsigned int nregs,
 -			    unsigned int start_index, unsigned int rw)
 -{
 -	int ret, i;
 -	int cmd = FW_LDST_ADDRSPC_TP_PIO;
 -	struct fw_ldst_cmd c;
 -
 -	for (i = 0 ; i < nregs; i++) {
 -		memset(&c, 0, sizeof(c));
 -		c.op_to_addrspace = cpu_to_be32(FW_CMD_OP_V(FW_LDST_CMD) |
 -						FW_CMD_REQUEST_F |
 -						(rw ? FW_CMD_READ_F :
 -						      FW_CMD_WRITE_F) |
 -						FW_LDST_CMD_ADDRSPACE_V(cmd));
 -		c.cycles_to_len16 = cpu_to_be32(FW_LEN16(c));
 -
 -		c.u.addrval.addr = cpu_to_be32(start_index + i);
 -		c.u.addrval.val  = rw ? 0 : cpu_to_be32(vals[i]);
 -		ret = t4_wr_mbox(adap, adap->mbox, &c, sizeof(c), &c);
 -		if (!ret && rw)
 -			vals[i] = be32_to_cpu(c.u.addrval.val);
 -	}
 -}
 -
  /**
   *	t4_read_rss_key - read the global RSS key
   *	@adap: the adapter
@@@ -3726,8 -3737,11 +3731,16 @@@
   */
  void t4_read_rss_key(struct adapter *adap, u32 *key)
  {
++<<<<<<< HEAD
 +	t4_read_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A, key, 10,
 +			 TP_RSS_SECRET_KEY0_A);
++=======
+ 	if (t4_use_ldst(adap))
+ 		t4_fw_tp_pio_rw(adap, key, 10, TP_RSS_SECRET_KEY0_A, 1);
+ 	else
+ 		t4_read_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A, key, 10,
+ 				 TP_RSS_SECRET_KEY0_A);
++>>>>>>> 0b2c2a931a05 (cxgb4: Add debugfs entry to enable backdoor access)
  }
  
  /**
@@@ -3742,11 -3756,32 +3755,40 @@@
   */
  void t4_write_rss_key(struct adapter *adap, const u32 *key, int idx)
  {
++<<<<<<< HEAD
 +	t4_write_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A, key, 10,
 +			  TP_RSS_SECRET_KEY0_A);
 +	if (idx >= 0 && idx < 16)
 +		t4_write_reg(adap, TP_RSS_CONFIG_VRT_A,
 +			     KEYWRADDR_V(idx) | KEYWREN_F);
++=======
+ 	u8 rss_key_addr_cnt = 16;
+ 	u32 vrt = t4_read_reg(adap, TP_RSS_CONFIG_VRT_A);
+ 
+ 	/* T6 and later: for KeyMode 3 (per-vf and per-vf scramble),
+ 	 * allows access to key addresses 16-63 by using KeyWrAddrX
+ 	 * as index[5:4](upper 2) into key table
+ 	 */
+ 	if ((CHELSIO_CHIP_VERSION(adap->params.chip) > CHELSIO_T5) &&
+ 	    (vrt & KEYEXTEND_F) && (KEYMODE_G(vrt) == 3))
+ 		rss_key_addr_cnt = 32;
+ 
+ 	if (t4_use_ldst(adap))
+ 		t4_fw_tp_pio_rw(adap, (void *)key, 10, TP_RSS_SECRET_KEY0_A, 0);
+ 	else
+ 		t4_write_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A, key, 10,
+ 				  TP_RSS_SECRET_KEY0_A);
+ 
+ 	if (idx >= 0 && idx < rss_key_addr_cnt) {
+ 		if (rss_key_addr_cnt > 16)
+ 			t4_write_reg(adap, TP_RSS_CONFIG_VRT_A,
+ 				     KEYWRADDRX_V(idx >> 4) |
+ 				     T6_VFWRADDR_V(idx) | KEYWREN_F);
+ 		else
+ 			t4_write_reg(adap, TP_RSS_CONFIG_VRT_A,
+ 				     KEYWRADDR_V(idx) | KEYWREN_F);
+ 	}
++>>>>>>> 0b2c2a931a05 (cxgb4: Add debugfs entry to enable backdoor access)
  }
  
  /**
@@@ -3761,8 -3796,12 +3803,17 @@@
  void t4_read_rss_pf_config(struct adapter *adapter, unsigned int index,
  			   u32 *valp)
  {
++<<<<<<< HEAD
 +	t4_read_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
 +			 valp, 1, TP_RSS_PF0_CONFIG_A + index);
++=======
+ 	if (t4_use_ldst(adapter))
+ 		t4_fw_tp_pio_rw(adapter, valp, 1,
+ 				TP_RSS_PF0_CONFIG_A + index, 1);
+ 	else
+ 		t4_read_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
+ 				 valp, 1, TP_RSS_PF0_CONFIG_A + index);
++>>>>>>> 0b2c2a931a05 (cxgb4: Add debugfs entry to enable backdoor access)
  }
  
  /**
@@@ -3792,10 -3836,15 +3843,22 @@@ void t4_read_rss_vf_config(struct adapt
  
  	/* Grab the VFL/VFH values ...
  	 */
++<<<<<<< HEAD
 +	t4_read_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
 +			 vfl, 1, TP_RSS_VFL_CONFIG_A);
 +	t4_read_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
 +			 vfh, 1, TP_RSS_VFH_CONFIG_A);
++=======
+ 	if (t4_use_ldst(adapter)) {
+ 		t4_fw_tp_pio_rw(adapter, vfl, 1, TP_RSS_VFL_CONFIG_A, 1);
+ 		t4_fw_tp_pio_rw(adapter, vfh, 1, TP_RSS_VFH_CONFIG_A, 1);
+ 	} else {
+ 		t4_read_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
+ 				 vfl, 1, TP_RSS_VFL_CONFIG_A);
+ 		t4_read_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
+ 				 vfh, 1, TP_RSS_VFH_CONFIG_A);
+ 	}
++>>>>>>> 0b2c2a931a05 (cxgb4: Add debugfs entry to enable backdoor access)
  }
  
  /**
@@@ -3808,8 -3857,11 +3871,16 @@@ u32 t4_read_rss_pf_map(struct adapter *
  {
  	u32 pfmap;
  
++<<<<<<< HEAD
 +	t4_read_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
 +			 &pfmap, 1, TP_RSS_PF_MAP_A);
++=======
+ 	if (t4_use_ldst(adapter))
+ 		t4_fw_tp_pio_rw(adapter, &pfmap, 1, TP_RSS_PF_MAP_A, 1);
+ 	else
+ 		t4_read_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
+ 				 &pfmap, 1, TP_RSS_PF_MAP_A);
++>>>>>>> 0b2c2a931a05 (cxgb4: Add debugfs entry to enable backdoor access)
  	return pfmap;
  }
  
@@@ -3823,8 -3875,11 +3894,16 @@@ u32 t4_read_rss_pf_mask(struct adapter 
  {
  	u32 pfmask;
  
++<<<<<<< HEAD
 +	t4_read_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
 +			 &pfmask, 1, TP_RSS_PF_MSK_A);
++=======
+ 	if (t4_use_ldst(adapter))
+ 		t4_fw_tp_pio_rw(adapter, &pfmask, 1, TP_RSS_PF_MSK_A, 1);
+ 	else
+ 		t4_read_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
+ 				 &pfmask, 1, TP_RSS_PF_MSK_A);
++>>>>>>> 0b2c2a931a05 (cxgb4: Add debugfs entry to enable backdoor access)
  	return pfmask;
  }
  
@@@ -6179,12 -6280,19 +6258,28 @@@ int t4_init_tp_params(struct adapter *a
  	/* Cache the adapter's Compressed Filter Mode and global Incress
  	 * Configuration.
  	 */
++<<<<<<< HEAD
 +	t4_read_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A,
 +			 &adap->params.tp.vlan_pri_map, 1,
 +			 TP_VLAN_PRI_MAP_A);
 +	t4_read_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A,
 +			 &adap->params.tp.ingress_config, 1,
 +			 TP_INGRESS_CONFIG_A);
++=======
+ 	if (t4_use_ldst(adap)) {
+ 		t4_fw_tp_pio_rw(adap, &adap->params.tp.vlan_pri_map, 1,
+ 				TP_VLAN_PRI_MAP_A, 1);
+ 		t4_fw_tp_pio_rw(adap, &adap->params.tp.ingress_config, 1,
+ 				TP_INGRESS_CONFIG_A, 1);
+ 	} else {
+ 		t4_read_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A,
+ 				 &adap->params.tp.vlan_pri_map, 1,
+ 				 TP_VLAN_PRI_MAP_A);
+ 		t4_read_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A,
+ 				 &adap->params.tp.ingress_config, 1,
+ 				 TP_INGRESS_CONFIG_A);
+ 	}
++>>>>>>> 0b2c2a931a05 (cxgb4: Add debugfs entry to enable backdoor access)
  
  	/* Now that we have TP_VLAN_PRI_MAP cached, we can calculate the field
  	 * shift positions of several elements of the Compressed Filter Tuple
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index 17d67dc9b0fa..422a2747d4e8 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@ -751,6 +751,7 @@ struct adapter {
 	bool tid_release_task_busy;
 
 	struct dentry *debugfs_root;
+	u32 use_bd;     /* Use SGE Back Door intfc for reading SGE Contexts */
 
 	spinlock_t stats_lock;
 	spinlock_t win0_lock ____cacheline_aligned_in_smp;
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
