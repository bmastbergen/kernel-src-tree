IB/hfi1: Move QOS decision logic into its own function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dean Luick <dean.luick@intel.com>
commit 4a818bedf7b6087f4bbf875847b11f1946775934
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4a818bed.failed

The decision to use QOS affects other resource allocation.
Move the QOS decision logic into its own function so it can
be called by other interested parties.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Dean Luick <dean.luick@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 4a818bedf7b6087f4bbf875847b11f1946775934)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/chip.c
diff --cc drivers/staging/hfi1/chip.c
index 689fb76865d1,b2c037ce451e..000000000000
--- a/drivers/staging/hfi1/chip.c
+++ b/drivers/staging/hfi1/chip.c
@@@ -13532,55 -13424,126 +13532,150 @@@ static void init_qpmap_table(struct hfi
  			| RCV_CTRL_RCV_BYPASS_ENABLE_SMASK);
  }
  
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
++=======
+ struct rsm_map_table {
+ 	u64 map[NUM_MAP_REGS];
+ 	unsigned int used;
+ };
+ 
+ /*
+  * Return an initialized RMT map table for users to fill in.  OK if it
+  * returns NULL, indicating no table.
+  */
+ static struct rsm_map_table *alloc_rsm_map_table(struct hfi1_devdata *dd)
+ {
+ 	struct rsm_map_table *rmt;
+ 	u8 rxcontext = is_ax(dd) ? 0 : 0xff;  /* 0 is default if a0 ver. */
+ 
+ 	rmt = kmalloc(sizeof(*rmt), GFP_KERNEL);
+ 	if (rmt) {
+ 		memset(rmt->map, rxcontext, sizeof(rmt->map));
+ 		rmt->used = 0;
+ 	}
+ 
+ 	return rmt;
+ }
+ 
+ /*
+  * Write the final RMT map table to the chip and free the table.  OK if
+  * table is NULL.
+  */
+ static void complete_rsm_map_table(struct hfi1_devdata *dd,
+ 				   struct rsm_map_table *rmt)
+ {
+ 	int i;
+ 
+ 	if (rmt) {
+ 		/* write table to chip */
+ 		for (i = 0; i < NUM_MAP_REGS; i++)
+ 			write_csr(dd, RCV_RSM_MAP_TABLE + (8 * i), rmt->map[i]);
+ 
+ 		/* enable RSM */
+ 		add_rcvctrl(dd, RCV_CTRL_RCV_RSM_ENABLE_SMASK);
+ 	}
+ }
+ 
+ /* return the number of RSM map table entries that will be used for QOS */
+ static int qos_rmt_entries(struct hfi1_devdata *dd, unsigned int *mp,
+ 			   unsigned int *np)
+ {
+ 	int i;
+ 	unsigned int m, n;
+ 	u8 max_by_vl = 0;
+ 
+ 	/* is QOS active at all? */
+ 	if (dd->n_krcv_queues <= MIN_KERNEL_KCTXTS ||
+ 	    num_vls == 1 ||
+ 	    krcvqsset <= 1)
+ 		goto no_qos;
+ 
+ 	/* determine bits for qpn */
+ 	for (i = 0; i < min_t(unsigned int, num_vls, krcvqsset); i++)
+ 		if (krcvqs[i] > max_by_vl)
+ 			max_by_vl = krcvqs[i];
+ 	if (max_by_vl > 32)
+ 		goto no_qos;
+ 	m = ilog2(__roundup_pow_of_two(max_by_vl));
+ 
+ 	/* determine bits for vl */
+ 	n = ilog2(__roundup_pow_of_two(num_vls));
+ 
+ 	/* reject if too much is used */
+ 	if ((m + n) > 7)
+ 		goto no_qos;
+ 
+ 	if (mp)
+ 		*mp = m;
+ 	if (np)
+ 		*np = n;
+ 
+ 	return 1 << (m + n);
+ 
+ no_qos:
+ 	if (mp)
+ 		*mp = 0;
+ 	if (np)
+ 		*np = 0;
+ 	return 0;
+ }
+ 
++>>>>>>> 4a818bedf7b6 (IB/hfi1: Move QOS decision logic into its own function):drivers/staging/rdma/hfi1/chip.c
  /**
   * init_qos - init RX qos
   * @dd - device data
 - * @rmt - RSM map table
 + * @first_context
 + *
 + * This routine initializes Rule 0 and the
 + * RSM map table to implement qos.
   *
 - * This routine initializes Rule 0 and the RSM map table to implement
 - * quality of service (qos).
 + * If all of the limit tests succeed,
 + * qos is applied based on the array
 + * interpretation of krcvqs where
 + * entry 0 is VL0.
   *
 - * If all of the limit tests succeed, qos is applied based on the array
 - * interpretation of krcvqs where entry 0 is VL0.
 + * The number of vl bits (n) and the number of qpn
 + * bits (m) are computed to feed both the RSM map table
 + * and the single rule.
   *
 - * The number of vl bits (n) and the number of qpn bits (m) are computed to
 - * feed both the RSM map table and the single rule.
   */
 -static void init_qos(struct hfi1_devdata *dd, struct rsm_map_table *rmt)
 +static void init_qos(struct hfi1_devdata *dd, u32 first_ctxt)
  {
- 	u8 max_by_vl = 0;
  	unsigned qpns_per_vl, ctxt, i, qpn, n = 1, m;
 -	unsigned int rmt_entries;
 +	u64 *rsmmap;
  	u64 reg;
 +	u8  rxcontext = is_ax(dd) ? 0 : 0xff;  /* 0 is default if a0 ver. */
  
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +	/* validate */
 +	if (dd->n_krcv_queues <= MIN_KERNEL_KCTXTS ||
 +	    num_vls == 1 ||
 +	    krcvqsset <= 1)
++=======
+ 	if (!rmt)
++>>>>>>> 4a818bedf7b6 (IB/hfi1: Move QOS decision logic into its own function):drivers/staging/rdma/hfi1/chip.c
  		goto bail;
- 	for (i = 0; i < min_t(unsigned, num_vls, krcvqsset); i++)
- 		if (krcvqs[i] > max_by_vl)
- 			max_by_vl = krcvqs[i];
- 	if (max_by_vl > 32)
- 		goto bail;
- 	qpns_per_vl = __roundup_pow_of_two(max_by_vl);
- 	/* determine bits vl */
- 	n = ilog2(__roundup_pow_of_two(num_vls));
- 	/* determine bits for qpn */
- 	m = ilog2(qpns_per_vl);
- 	if ((m + n) > 7)
+ 	rmt_entries = qos_rmt_entries(dd, &m, &n);
+ 	if (rmt_entries == 0)
  		goto bail;
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +	rsmmap = kmalloc_array(NUM_MAP_REGS, sizeof(u64), GFP_KERNEL);
 +	if (!rsmmap)
 +		goto bail;
 +	memset(rsmmap, rxcontext, NUM_MAP_REGS * sizeof(u64));
 +	/* init the local copy of the table */
 +	for (i = 0, ctxt = first_ctxt; i < num_vls; i++) {
++=======
+ 	qpns_per_vl = 1 << m;
+ 
+ 	/* enough room in the map table? */
+ 	rmt_entries = 1 << (m + n);
+ 	if (rmt->used + rmt_entries >= NUM_MAP_ENTRIES)
+ 		goto bail;
+ 
+ 	/* add qos entries to the the RSM map table */
+ 	for (i = 0, ctxt = FIRST_KERNEL_KCTXT; i < num_vls; i++) {
++>>>>>>> 4a818bedf7b6 (IB/hfi1: Move QOS decision logic into its own function):drivers/staging/rdma/hfi1/chip.c
  		unsigned tctxt;
  
  		for (qpn = 0, tctxt = ctxt;
* Unmerged path drivers/staging/hfi1/chip.c
