Drivers: hv: ring_buffer: remove code duplication from hv_ringbuffer_peek/read()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hv] ring_buffer: remove code duplication from hv_ringbuffer_peek/read() (Vitaly Kuznetsov) [1321073]
Rebuild_FUZZ: 91.16%
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit b5f53dde8d8e84a6ee200dbd0bd90a400a8fe1a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b5f53dde.failed

hv_ringbuffer_peek() does the same as hv_ringbuffer_read() without
advancing the read index. The only functional change this patch brings
is moving hv_need_to_signal_on_read() call under the ring_lock but this
function is just a couple of comparisons.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit b5f53dde8d8e84a6ee200dbd0bd90a400a8fe1a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/ring_buffer.c
diff --cc drivers/hv/ring_buffer.c
index 6361d124f67d,07f9408fc59e..000000000000
--- a/drivers/hv/ring_buffer.c
+++ b/drivers/hv/ring_buffer.c
@@@ -458,59 -380,9 +458,65 @@@ int hv_ringbuffer_write(struct hv_ring_
  	return 0;
  }
  
++<<<<<<< HEAD
 +
 +/*
 + *
 + * hv_ringbuffer_peek()
 + *
 + * Read without advancing the read index
 + *
 + */
 +int hv_ringbuffer_peek(struct hv_ring_buffer_info *Inring_info,
 +		   void *Buffer, u32 buflen)
 +{
 +	u32 bytes_avail_towrite;
 +	u32 bytes_avail_toread;
 +	u32 next_read_location = 0;
 +	unsigned long flags;
 +
 +	spin_lock_irqsave(&Inring_info->ring_lock, flags);
 +
 +	hv_get_ringbuffer_availbytes(Inring_info,
 +				&bytes_avail_toread,
 +				&bytes_avail_towrite);
 +
 +	/* Make sure there is something to read */
 +	if (bytes_avail_toread < buflen) {
 +
 +		spin_unlock_irqrestore(&Inring_info->ring_lock, flags);
 +
 +		return -EAGAIN;
 +	}
 +
 +	/* Convert to byte offset */
 +	next_read_location = hv_get_next_read_location(Inring_info);
 +
 +	next_read_location = hv_copyfrom_ringbuffer(Inring_info,
 +						Buffer,
 +						buflen,
 +						next_read_location);
 +
 +	spin_unlock_irqrestore(&Inring_info->ring_lock, flags);
 +
 +	return 0;
 +}
 +
 +
 +/*
 + *
 + * hv_ringbuffer_read()
 + *
 + * Read and advance the read index
 + *
 + */
 +int hv_ringbuffer_read(struct hv_ring_buffer_info *inring_info, void *buffer,
 +		   u32 buflen, u32 offset, bool *signal)
++=======
+ static inline int __hv_ringbuffer_read(struct hv_ring_buffer_info *inring_info,
+ 				       void *buffer, u32 buflen, u32 offset,
+ 				       bool *signal, bool advance)
++>>>>>>> b5f53dde8d8e (Drivers: hv: ring_buffer: remove code duplication from hv_ringbuffer_peek/read())
  {
  	u32 bytes_avail_towrite;
  	u32 bytes_avail_toread;
@@@ -558,9 -432,26 +567,32 @@@
  	/* Update the read index */
  	hv_set_next_read_location(inring_info, next_read_location);
  
++<<<<<<< HEAD
 +	spin_unlock_irqrestore(&inring_info->ring_lock, flags);
 +
 +	*signal = hv_need_to_signal_on_read(old_read, inring_info);
++=======
+ 	*signal = hv_need_to_signal_on_read(bytes_avail_towrite, inring_info);
++>>>>>>> b5f53dde8d8e (Drivers: hv: ring_buffer: remove code duplication from hv_ringbuffer_peek/read())
  
+ out_unlock:
+ 	spin_unlock_irqrestore(&inring_info->ring_lock, flags);
  	return 0;
  }
+ 
+ /* Read from ring buffer without advancing the read index. */
+ int hv_ringbuffer_peek(struct hv_ring_buffer_info *inring_info,
+ 		       void *buffer, u32 buflen)
+ {
+ 	return __hv_ringbuffer_read(inring_info, buffer, buflen,
+ 				    0, NULL, false);
+ }
+ 
+ /* Read from ring buffer and advance the read index. */
+ int hv_ringbuffer_read(struct hv_ring_buffer_info *inring_info,
+ 		       void *buffer, u32 buflen, u32 offset,
+ 		       bool *signal)
+ {
+ 	return __hv_ringbuffer_read(inring_info, buffer, buflen,
+ 				    offset, signal, true);
+ }
* Unmerged path drivers/hv/ring_buffer.c
