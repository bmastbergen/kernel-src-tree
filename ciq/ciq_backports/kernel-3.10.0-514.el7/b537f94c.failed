mmc: sdhci: more efficient interrupt enable register handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Russell King <rmk+kernel@arm.linux.org.uk>
commit b537f94ce19583de1882f539a5cc49aa99260aca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b537f94c.failed

Rather than wasting cycles read-modify-writing the interrupt enable
registers, cache the value locally instead.

	Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
	Tested-by: Markus Pargmann <mpa@pengutronix.de>
	Tested-by: Stephen Warren <swarren@nvidia.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Chris Ball <chris@printf.net>
(cherry picked from commit b537f94ce19583de1882f539a5cc49aa99260aca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci.c
diff --cc drivers/mmc/host/sdhci.c
index 9a66ab1fa866,4a98ee29d136..000000000000
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@@ -1711,12 -1696,14 +1696,15 @@@ static int sdhci_get_ro(struct mmc_hos
  
  static void sdhci_enable_sdio_irq_nolock(struct sdhci_host *host, int enable)
  {
 -	if (!(host->flags & SDHCI_DEVICE_DEAD)) {
 +	/* SDIO IRQ will be enabled as appropriate in runtime resume */
 +	if (!(host->flags & SDHCI_DEVICE_DEAD) || host->runtime_suspended) {
  		if (enable)
- 			sdhci_unmask_irqs(host, SDHCI_INT_CARD_INT);
+ 			host->ier |= SDHCI_INT_CARD_INT;
  		else
- 			sdhci_mask_irqs(host, SDHCI_INT_CARD_INT);
+ 			host->ier &= ~SDHCI_INT_CARD_INT;
+ 
+ 		sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+ 		sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
  		mmiowb();
  	}
  }
@@@ -2692,7 -2683,9 +2684,13 @@@ int sdhci_runtime_suspend_host(struct s
  	}
  
  	spin_lock_irqsave(&host->lock, flags);
++<<<<<<< HEAD
 +	sdhci_mask_irqs(host, SDHCI_INT_ALL_MASK);
++=======
+ 	host->ier &= SDHCI_INT_CARD_INT;
+ 	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+ 	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
++>>>>>>> b537f94ce195 (mmc: sdhci: more efficient interrupt enable register handling)
  	spin_unlock_irqrestore(&host->lock, flags);
  
  	synchronize_hardirq(host->irq);
* Unmerged path drivers/mmc/host/sdhci.c
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index 1f55d4bcbbfb..48b9839e1cc6 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -172,6 +172,9 @@ struct sdhci_host {
 
 	u32			thread_isr;
 
+	/* cached registers */
+	u32			ier;
+
 	wait_queue_head_t	buf_ready_int;	/* Waitqueue for Buffer Read Ready interrupt */
 	unsigned int		tuning_done;	/* Condition flag set when CMD19 succeeds */
 
