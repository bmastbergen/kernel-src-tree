iommu/vt-d: Copy translation tables from old kernel

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [iommu] vt-d: Copy translation tables from old kernel (Myron Stowe) [1050021]
Rebuild_FUZZ: 93.75%
commit-author Joerg Roedel <jroedel@suse.de>
commit 091d42e43d21b6ca7ec39bf5f9e17bc0bd8d4312
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/091d42e4.failed

If we are in a kdump kernel and find translation enabled in
the iommu, try to copy the translation tables from the old
kernel to preserve the mappings until the device driver
takes over.
This supports old and the extended root-entry and
context-table formats.

	Tested-by: ZhenHua Li <zhen-hual@hp.com>
	Tested-by: Baoquan He <bhe@redhat.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 091d42e43d21b6ca7ec39bf5f9e17bc0bd8d4312)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 2dab075cf283,1eb743c700e9..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -39,6 -42,8 +39,11 @@@
  #include <linux/dmi.h>
  #include <linux/pci-ats.h>
  #include <linux/memblock.h>
++<<<<<<< HEAD
++=======
+ #include <linux/dma-contiguous.h>
+ #include <linux/crash_dump.h>
++>>>>>>> 091d42e43d21 (iommu/vt-d: Copy translation tables from old kernel)
  #include <asm/irq_remapping.h>
  #include <asm/cacheflush.h>
  #include <asm/iommu.h>
@@@ -438,7 -464,32 +465,36 @@@ EXPORT_SYMBOL_GPL(intel_iommu_gfx_mappe
  static DEFINE_SPINLOCK(device_domain_lock);
  static LIST_HEAD(device_domain_list);
  
++<<<<<<< HEAD
 +static struct iommu_ops intel_iommu_ops;
++=======
+ static const struct iommu_ops intel_iommu_ops;
+ 
+ static bool translation_pre_enabled(struct intel_iommu *iommu)
+ {
+ 	return (iommu->flags & VTD_FLAG_TRANS_PRE_ENABLED);
+ }
+ 
+ static void clear_translation_pre_enabled(struct intel_iommu *iommu)
+ {
+ 	iommu->flags &= ~VTD_FLAG_TRANS_PRE_ENABLED;
+ }
+ 
+ static void init_translation_status(struct intel_iommu *iommu)
+ {
+ 	u32 gsts;
+ 
+ 	gsts = readl(iommu->reg + DMAR_GSTS_REG);
+ 	if (gsts & DMA_GSTS_TES)
+ 		iommu->flags |= VTD_FLAG_TRANS_PRE_ENABLED;
+ }
+ 
+ /* Convert generic 'struct iommu_domain to private struct dmar_domain */
+ static struct dmar_domain *to_dmar_domain(struct iommu_domain *dom)
+ {
+ 	return container_of(dom, struct dmar_domain, domain);
+ }
++>>>>>>> 091d42e43d21 (iommu/vt-d: Copy translation tables from old kernel)
  
  static int __init intel_iommu_setup(char *str)
  {
@@@ -2814,6 -2998,15 +3017,18 @@@ static int __init init_dmars(void
  		if (ret)
  			goto free_iommu;
  
++<<<<<<< HEAD
++=======
+ 		init_translation_status(iommu);
+ 
+ 		if (translation_pre_enabled(iommu) && !is_kdump_kernel()) {
+ 			iommu_disable_translation(iommu);
+ 			clear_translation_pre_enabled(iommu);
+ 			pr_warn("Translation was enabled for %s but we are not in kdump mode\n",
+ 				iommu->name);
+ 		}
+ 
++>>>>>>> 091d42e43d21 (iommu/vt-d: Copy translation tables from old kernel)
  		/*
  		 * TBD:
  		 * we could share the same root & context tables
* Unmerged path drivers/iommu/intel-iommu.c
