powerpc: Remove shims for pci_controller_ops operations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [powerpc] Remove shims for pci_controller_ops operations (Gustavo Duarte) [1275657]
Rebuild_FUZZ: 91.09%
commit-author Daniel Axtens <dja@axtens.net>
commit 467efc2e4fdc44e6cd4be7dd4adf01c14b3d148e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/467efc2e.failed

Remove shims, patch callsites to use pci_controller_ops
versions instead.

Also move back the probe mode defines, as explained in the patch
for pci_probe_mode.

	Signed-off-by: Daniel Axtens <dja@axtens.net>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 467efc2e4fdc44e6cd4be7dd4adf01c14b3d148e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/machdep.h
diff --cc arch/powerpc/include/asm/machdep.h
index bafb79c3e5aa,5c19ac527a8e..000000000000
--- a/arch/powerpc/include/asm/machdep.h
+++ b/arch/powerpc/include/asm/machdep.h
@@@ -100,9 -122,8 +97,8 @@@ struct machdep_calls 
  	unsigned int	(*get_irq)(void);
  
  	/* PCI stuff */
 -	/* Called after allocating resources */
 +	/* Called after scanning the bus, before allocating resources */
  	void		(*pcibios_fixup)(void);
- 	int		(*pci_probe_mode)(struct pci_bus *);
  	void		(*pci_irq_fixup)(struct pci_dev *dev);
  	int		(*pcibios_root_bridge_prepare)(struct pci_host_bridge
  				*bridge);
@@@ -218,20 -236,6 +214,19 @@@
  	/* Called after scan and before resource survey */
  	void (*pcibios_fixup_phb)(struct pci_controller *hose);
  
++<<<<<<< HEAD
 +	/* Called during PCI resource reassignment */
 +	resource_size_t (*pcibios_window_alignment)(struct pci_bus *, unsigned long type);
 +
 +	/* Reset the secondary bus of bridge */
 +	void  (*pcibios_reset_secondary_bus)(struct pci_dev *dev);
 +
 +#ifdef CONFIG_PCI_IOV
 +	void (*pcibios_fixup_sriov)(struct pci_dev *pdev);
 +#endif /* CONFIG_PCI_IOV */
 +
++=======
++>>>>>>> 467efc2e4fdc (powerpc: Remove shims for pci_controller_ops operations)
  	/* Called to shutdown machine specific hardware not already controlled
  	 * by other drivers.
  	 */
* Unmerged path arch/powerpc/include/asm/machdep.h
diff --git a/arch/powerpc/include/asm/pci-bridge.h b/arch/powerpc/include/asm/pci-bridge.h
index 157251ae4847..e823602b32e5 100644
--- a/arch/powerpc/include/asm/pci-bridge.h
+++ b/arch/powerpc/include/asm/pci-bridge.h
@@ -12,11 +12,6 @@
 #include <linux/ioport.h>
 #include <asm-generic/pci-bridge.h>
 
-/* Return values for pci_controller_ops.probe_mode function */
-#define PCI_PROBE_NONE		-1	/* Don't look at this bus at all */
-#define PCI_PROBE_NORMAL	0	/* Do normal PCI probing */
-#define PCI_PROBE_DEVTREE	1	/* Instantiate from device tree */
-
 struct device_node;
 
 /*
@@ -294,84 +289,5 @@ static inline int pcibios_vaddr_is_ioport(void __iomem *address)
 }
 #endif	/* CONFIG_PCI */
 
-/*
- * Shims to prefer pci_controller version over ppc_md where available.
- */
-static inline void pci_dma_dev_setup(struct pci_dev *dev)
-{
-	struct pci_controller *phb = pci_bus_to_host(dev->bus);
-
-	if (phb->controller_ops.dma_dev_setup)
-		phb->controller_ops.dma_dev_setup(dev);
-	else if (ppc_md.pci_dma_dev_setup)
-		ppc_md.pci_dma_dev_setup(dev);
-}
-
-static inline void pci_dma_bus_setup(struct pci_bus *bus)
-{
-	struct pci_controller *phb = pci_bus_to_host(bus);
-
-	if (phb->controller_ops.dma_bus_setup)
-		phb->controller_ops.dma_bus_setup(bus);
-	else if (ppc_md.pci_dma_bus_setup)
-		ppc_md.pci_dma_bus_setup(bus);
-}
-
-static inline int pci_probe_mode(struct pci_bus *bus)
-{
-	struct pci_controller *phb = pci_bus_to_host(bus);
-
-	if (phb->controller_ops.probe_mode)
-		return phb->controller_ops.probe_mode(bus);
-	if (ppc_md.pci_probe_mode)
-		return ppc_md.pci_probe_mode(bus);
-	return PCI_PROBE_NORMAL;
-}
-
-static inline bool pcibios_enable_device_hook(struct pci_dev *dev)
-{
-	struct pci_controller *phb = pci_bus_to_host(dev->bus);
-
-	if (phb->controller_ops.enable_device_hook)
-		return phb->controller_ops.enable_device_hook(dev);
-	if (ppc_md.pcibios_enable_device_hook)
-		return ppc_md.pcibios_enable_device_hook(dev);
-	return true;
-}
-
-static inline resource_size_t pci_window_alignment(struct pci_bus *bus,
-						   unsigned long type)
-{
-	struct pci_controller *phb = pci_bus_to_host(bus);
-
-	if (phb->controller_ops.window_alignment)
-		return phb->controller_ops.window_alignment(bus, type);
-	if (ppc_md.pcibios_window_alignment)
-		return ppc_md.pcibios_window_alignment(bus, type);
-
-	/*
-	 * PCI core will figure out the default
-	 * alignment: 4KiB for I/O and 1MiB for
-	 * memory window.
-	 */
-	return 1;
-}
-
-static inline void pcibios_reset_secondary_bus_shim(struct pci_dev *dev)
-{
-	struct pci_controller *phb = pci_bus_to_host(dev->bus);
-
-	if (phb->controller_ops.reset_secondary_bus)
-		phb->controller_ops.reset_secondary_bus(dev);
-	else if (ppc_md.pcibios_reset_secondary_bus)
-		ppc_md.pcibios_reset_secondary_bus(dev);
-	else
-		/*
-		 * Fallback to the generic function if no
-		 * platform-specific one is provided
-		 */
-		pci_reset_secondary_bus(dev);
-}
-
 #endif	/* __KERNEL__ */
 #endif	/* _ASM_POWERPC_PCI_BRIDGE_H */
diff --git a/arch/powerpc/include/asm/pci.h b/arch/powerpc/include/asm/pci.h
index 8745067ac702..4aef8d660999 100644
--- a/arch/powerpc/include/asm/pci.h
+++ b/arch/powerpc/include/asm/pci.h
@@ -22,6 +22,11 @@
 
 #include <asm-generic/pci-dma-compat.h>
 
+/* Return values for pci_controller_ops.probe_mode function */
+#define PCI_PROBE_NONE		-1	/* Don't look at this bus at all */
+#define PCI_PROBE_NORMAL	0	/* Do normal PCI probing */
+#define PCI_PROBE_DEVTREE	1	/* Instantiate from device tree */
+
 #define PCIBIOS_MIN_IO		0x1000
 #define PCIBIOS_MIN_MEM		0x10000000
 
diff --git a/arch/powerpc/kernel/pci-common.c b/arch/powerpc/kernel/pci-common.c
index fee004eb5802..2b43b6965227 100644
--- a/arch/powerpc/kernel/pci-common.c
+++ b/arch/powerpc/kernel/pci-common.c
@@ -110,12 +110,29 @@ void pcibios_free_controller(struct pci_controller *phb)
 resource_size_t pcibios_window_alignment(struct pci_bus *bus,
 					 unsigned long type)
 {
-	return pci_window_alignment(bus, type);
+	struct pci_controller *phb = pci_bus_to_host(bus);
+
+	if (phb->controller_ops.window_alignment)
+		return phb->controller_ops.window_alignment(bus, type);
+
+	/*
+	 * PCI core will figure out the default
+	 * alignment: 4KiB for I/O and 1MiB for
+	 * memory window.
+	 */
+	return 1;
 }
 
 void pcibios_reset_secondary_bus(struct pci_dev *dev)
 {
-	pcibios_reset_secondary_bus_shim(dev);
+	struct pci_controller *phb = pci_bus_to_host(dev->bus);
+
+	if (phb->controller_ops.reset_secondary_bus) {
+		phb->controller_ops.reset_secondary_bus(dev);
+		return;
+	}
+
+	pci_reset_secondary_bus(dev);
 }
 
 static resource_size_t pcibios_io_size(const struct pci_controller *hose)
@@ -957,6 +974,8 @@ static void pcibios_fixup_bridge(struct pci_bus *bus)
 
 void pcibios_setup_bus_self(struct pci_bus *bus)
 {
+	struct pci_controller *phb;
+
 	/* Fix up the bus resources for P2P bridges */
 	if (bus->self != NULL)
 		pcibios_fixup_bridge(bus);
@@ -968,11 +987,14 @@ void pcibios_setup_bus_self(struct pci_bus *bus)
 		ppc_md.pcibios_fixup_bus(bus);
 
 	/* Setup bus DMA mappings */
-	pci_dma_bus_setup(bus);
+	phb = pci_bus_to_host(bus);
+	if (phb->controller_ops.dma_bus_setup)
+		phb->controller_ops.dma_bus_setup(bus);
 }
 
 static void pcibios_setup_device(struct pci_dev *dev)
 {
+	struct pci_controller *phb;
 	/* Fixup NUMA node as it may not be setup yet by the generic
 	 * code and is needed by the DMA init
 	 */
@@ -983,7 +1005,9 @@ static void pcibios_setup_device(struct pci_dev *dev)
 	set_dma_offset(&dev->dev, PCI_DRAM_OFFSET);
 
 	/* Additional platform DMA/iommu setup */
-	pci_dma_dev_setup(dev);
+	phb = pci_bus_to_host(dev->bus);
+	if (phb->controller_ops.dma_dev_setup)
+		phb->controller_ops.dma_dev_setup(dev);
 
 	/* Read default IRQs and fixup if necessary */
 	pci_read_irq_line(dev);
@@ -1469,8 +1493,11 @@ EXPORT_SYMBOL_GPL(pcibios_finish_adding_to_bus);
 
 int pcibios_enable_device(struct pci_dev *dev, int mask)
 {
-	if (!pcibios_enable_device_hook(dev))
-		return -EINVAL;
+	struct pci_controller *phb = pci_bus_to_host(dev->bus);
+
+	if (phb->controller_ops.enable_device_hook)
+		if (!phb->controller_ops.enable_device_hook(dev))
+			return -EINVAL;
 
 	return pci_enable_resources(dev, mask);
 }
@@ -1643,8 +1670,8 @@ void pcibios_scan_phb(struct pci_controller *hose)
 
 	/* Get probe mode and perform scan */
 	mode = PCI_PROBE_NORMAL;
-	if (node)
-		mode = pci_probe_mode(bus);
+	if (node && hose->controller_ops.probe_mode)
+		mode = hose->controller_ops.probe_mode(bus);
 	pr_debug("    probe mode: %d\n", mode);
 	if (mode == PCI_PROBE_DEVTREE)
 		of_scan_bus(node, bus);
diff --git a/arch/powerpc/kernel/pci-hotplug.c b/arch/powerpc/kernel/pci-hotplug.c
index 27116b1b2d14..7ed85a69a9c2 100644
--- a/arch/powerpc/kernel/pci-hotplug.c
+++ b/arch/powerpc/kernel/pci-hotplug.c
@@ -73,12 +73,16 @@ void pcibios_add_pci_devices(struct pci_bus * bus)
 {
 	int slotno, mode, pass, max;
 	struct pci_dev *dev;
+	struct pci_controller *phb;
 	struct device_node *dn = pci_bus_to_OF_node(bus);
 
 	eeh_add_device_tree_early(PCI_DN(dn));
 
+	phb = pci_bus_to_host(bus);
+
 	mode = PCI_PROBE_NORMAL;
-	mode = pci_probe_mode(bus);
+	if (phb->controller_ops.probe_mode)
+		mode = phb->controller_ops.probe_mode(bus);
 
 	if (mode == PCI_PROBE_DEVTREE) {
 		/* use ofdt-based probe */
diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index f761dd3fd3c1..a20a7fe675ba 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -207,6 +207,7 @@ void of_scan_pci_bridge(struct pci_dev *dev)
 {
 	struct device_node *node = dev->dev.of_node;
 	struct pci_bus *bus;
+	struct pci_controller *phb;
 	const __be32 *busrange, *ranges;
 	int len, i, mode;
 	struct pci_bus_region region;
@@ -286,8 +287,11 @@ void of_scan_pci_bridge(struct pci_dev *dev)
 		bus->number);
 	pr_debug("    bus name: %s\n", bus->name);
 
+	phb = pci_bus_to_host(bus);
+
 	mode = PCI_PROBE_NORMAL;
-	mode = pci_probe_mode(bus);
+	if (phb->controller_ops.probe_mode)
+		mode = phb->controller_ops.probe_mode(bus);
 	pr_debug("    probe mode: %d\n", mode);
 
 	if (mode == PCI_PROBE_DEVTREE)
diff --git a/arch/powerpc/sysdev/dart_iommu.c b/arch/powerpc/sysdev/dart_iommu.c
index b5816af2dabb..40d2e69451c2 100644
--- a/arch/powerpc/sysdev/dart_iommu.c
+++ b/arch/powerpc/sysdev/dart_iommu.c
@@ -389,9 +389,6 @@ void __init iommu_init_early_dart(struct pci_controller_ops *controller_ops)
 	if (controller_ops) {
 		controller_ops->dma_dev_setup = pci_dma_dev_setup_dart;
 		controller_ops->dma_bus_setup = pci_dma_bus_setup_dart;
-	} else {
-		ppc_md.pci_dma_dev_setup = pci_dma_dev_setup_dart;
-		ppc_md.pci_dma_bus_setup = pci_dma_bus_setup_dart;
 	}
 	/* Setup pci_dma ops */
 	set_pci_dma_ops(&dma_iommu_ops);
@@ -403,8 +400,6 @@ void __init iommu_init_early_dart(struct pci_controller_ops *controller_ops)
 		controller_ops->dma_dev_setup = NULL;
 		controller_ops->dma_bus_setup = NULL;
 	}
-	ppc_md.pci_dma_dev_setup = NULL;
-	ppc_md.pci_dma_bus_setup = NULL;
 
 	/* Setup pci_dma ops */
 	set_pci_dma_ops(&dma_direct_ops);
