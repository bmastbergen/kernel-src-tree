netlink: Kill redundant net argument in netlink_insert

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit 8ea65f4a2dfaaf494ef42a16cbf2fea39b07450f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8ea65f4a.failed

The socket already carries the net namespace with it so there is
no need to be passing another net around.

	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8ea65f4a2dfaaf494ef42a16cbf2fea39b07450f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netlink/af_netlink.c
diff --cc net/netlink/af_netlink.c
index 0a1709dfa494,d77b3467b1d4..000000000000
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@@ -1024,6 -994,18 +1024,21 @@@ static struct sock *__netlink_lookup(st
  					 &netlink_compare, &arg);
  }
  
++<<<<<<< HEAD
++=======
+ static bool __netlink_insert(struct netlink_table *table, struct sock *sk)
+ {
+ 	struct netlink_compare_arg arg = {
+ 		.net = sock_net(sk),
+ 		.portid = nlk_sk(sk)->portid,
+ 	};
+ 
+ 	return rhashtable_lookup_compare_insert(&table->hash,
+ 						&nlk_sk(sk)->node,
+ 						&netlink_compare, &arg);
+ }
+ 
++>>>>>>> 8ea65f4a2dfa (netlink: Kill redundant net argument in netlink_insert)
  static struct sock *netlink_lookup(struct net *net, int protocol, u32 portid)
  {
  	struct netlink_table *table = &nl_table[protocol];
@@@ -1064,14 -1046,12 +1079,14 @@@ netlink_update_listeners(struct sock *s
  	 * makes sure updates are visible before bind or setsockopt return. */
  }
  
- static int netlink_insert(struct sock *sk, struct net *net, u32 portid)
+ static int netlink_insert(struct sock *sk, u32 portid)
  {
  	struct netlink_table *table = &nl_table[sk->sk_protocol];
 -	int err;
 +	int err = -EADDRINUSE;
  
 -	lock_sock(sk);
 +	mutex_lock(&nl_sk_hash_lock);
 +	if (__netlink_lookup(table, portid, net))
 +		goto err;
  
  	err = -EBUSY;
  	if (nlk_sk(sk)->portid)
@@@ -1083,10 -1064,15 +1098,18 @@@
  
  	nlk_sk(sk)->portid = portid;
  	sock_hold(sk);
 -
 +	rhashtable_insert(&table->hash, &nlk_sk(sk)->node);
  	err = 0;
++<<<<<<< HEAD
++=======
+ 	if (!__netlink_insert(table, sk)) {
+ 		err = -EADDRINUSE;
+ 		sock_put(sk);
+ 	}
+ 
++>>>>>>> 8ea65f4a2dfa (netlink: Kill redundant net argument in netlink_insert)
  err:
 -	release_sock(sk);
 +	mutex_unlock(&nl_sk_hash_lock);
  	return err;
  }
  
@@@ -1446,18 -1456,35 +1469,18 @@@ static int netlink_bind(struct socket *
  			return err;
  	}
  
 -	if (nlk->portid)
 +	if (nlk->portid) {
  		if (nladdr->nl_pid != nlk->portid)
  			return -EINVAL;
 -
 -	if (nlk->netlink_bind && groups) {
 -		int group;
 -
 -		for (group = 0; group < nlk->ngroups; group++) {
 -			if (!test_bit(group, &groups))
 -				continue;
 -			err = nlk->netlink_bind(net, group);
 -			if (!err)
 -				continue;
 -			netlink_undo_bind(group, groups, sk);
 -			return err;
 -		}
 -	}
 -
 -	if (!nlk->portid) {
 +	} else {
  		err = nladdr->nl_pid ?
- 			netlink_insert(sk, net, nladdr->nl_pid) :
+ 			netlink_insert(sk, nladdr->nl_pid) :
  			netlink_autobind(sock);
 -		if (err) {
 -			netlink_undo_bind(nlk->ngroups, groups, sk);
 +		if (err)
  			return err;
 -		}
  	}
  
 -	if (!groups && (nlk->groups == NULL || !(u32)nlk->groups[0]))
 +	if (!nladdr->nl_groups && (nlk->groups == NULL || !(u32)nlk->groups[0]))
  		return 0;
  
  	netlink_table_grab();
* Unmerged path net/netlink/af_netlink.c
