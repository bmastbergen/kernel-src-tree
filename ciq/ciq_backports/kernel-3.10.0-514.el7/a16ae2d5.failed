i40e: Do not disable queues in the Legacy/MSI Interrupt handler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Anjali Singhai Jain <anjali.singhai@intel.com>
commit a16ae2d59c290b0c545edb9bf41ac9cf88352ee0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a16ae2d5.failed

The queues should never be enabled/disabled in the interrupt handler,
ICR0 interrupt enable should be the only thing that needs to be
dynamically changed in the handler.

This patch fixes that. Without this patch X722 platforms were
seeing weird ping timings when in Legacy mode since it takes
a whole lot of time for the HW/FW to re-enable queues.

Change-ID: If065afc45d81c5a19d4a94a00cd5b8f61cefc40c
	Signed-off-by: Anjali Singhai Jain <anjali.singhai@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit a16ae2d59c290b0c545edb9bf41ac9cf88352ee0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
#	drivers/net/ethernet/intel/i40e/i40e_txrx.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 9067c108cdd2,7869d74c8820..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -3464,18 -3459,17 +3464,27 @@@ static irqreturn_t i40e_intr(int irq, v
  
  	/* only q0 is used in MSI/Legacy mode, and none are used in MSIX */
  	if (icr0 & I40E_PFINT_ICR0_QUEUE_0_MASK) {
 -		struct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];
 -		struct i40e_q_vector *q_vector = vsi->q_vectors[0];
  
++<<<<<<< HEAD
 +		/* temporarily disable queue cause for NAPI processing */
 +		u32 qval = rd32(hw, I40E_QINT_RQCTL(0));
 +		qval &= ~I40E_QINT_RQCTL_CAUSE_ENA_MASK;
 +		wr32(hw, I40E_QINT_RQCTL(0), qval);
 +
 +		qval = rd32(hw, I40E_QINT_TQCTL(0));
 +		qval &= ~I40E_QINT_TQCTL_CAUSE_ENA_MASK;
 +		wr32(hw, I40E_QINT_TQCTL(0), qval);
 +
++=======
+ 		/* We do not have a way to disarm Queue causes while leaving
+ 		 * interrupt enabled for all other causes, ideally
+ 		 * interrupt should be disabled while we are in NAPI but
+ 		 * this is not a performance path and napi_schedule()
+ 		 * can deal with rescheduling.
+ 		 */
++>>>>>>> a16ae2d59c29 (i40e: Do not disable queues in the Legacy/MSI Interrupt handler)
  		if (!test_bit(__I40E_DOWN, &pf->state))
 -			napi_schedule_irqoff(&q_vector->napi);
 +			napi_schedule(&pf->vsi[pf->lan_vsi]->q_vectors[0]->napi);
  	}
  
  	if (icr0 & I40E_PFINT_ICR0_ADMINQ_MASK) {
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 8e42703a58a9,65f2fd80aa79..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@@ -1877,20 -2051,7 +1877,24 @@@ int i40e_napi_poll(struct napi_struct *
  	if (vsi->back->flags & I40E_FLAG_MSIX_ENABLED) {
  		i40e_update_enable_itr(vsi, q_vector);
  	} else { /* Legacy mode */
++<<<<<<< HEAD
 +		struct i40e_hw *hw = &vsi->back->hw;
 +		/* We re-enable the queue 0 cause, but
 +		 * don't worry about dynamic_enable
 +		 * because we left it on for the other
 +		 * possible interrupts during napi
 +		 */
 +		u32 qval = rd32(hw, I40E_QINT_RQCTL(0)) |
 +			   I40E_QINT_RQCTL_CAUSE_ENA_MASK;
 +
 +		wr32(hw, I40E_QINT_RQCTL(0), qval);
 +		qval = rd32(hw, I40E_QINT_TQCTL(0)) |
 +		       I40E_QINT_TQCTL_CAUSE_ENA_MASK;
 +		wr32(hw, I40E_QINT_TQCTL(0), qval);
 +		i40e_irq_dynamic_enable_icr0(vsi->back);
++=======
+ 		i40e_irq_dynamic_enable_icr0(vsi->back, false);
++>>>>>>> a16ae2d59c29 (i40e: Do not disable queues in the Legacy/MSI Interrupt handler)
  	}
  	return 0;
  }
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.c
