mmc: core: Let's callers of from mmc_get_ext_csd() do error handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] core: Let's callers of from mmc_get_ext_csd() do error handling (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 96.18%
commit-author Ulf Hansson <ulf.hansson@linaro.org>
commit c197787ced5b42bde224d9ee70473d87a824119a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c197787c.failed

The callers of mmc_get_ext_csd() need the flexibility to handle errors
themselves, because they behave differently.

Let's clean up mmc_get_ext_csd() with its friends and adopt the error
handling as stated above.

	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit c197787ced5b42bde224d9ee70473d87a824119a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/mmc.c
diff --cc drivers/mmc/core/mmc.c
index c3e6ecc69da0,fe801e612b1f..000000000000
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@@ -188,10 -188,8 +188,15 @@@ static int mmc_get_ext_csd(struct mmc_c
  	BUG_ON(!card);
  	BUG_ON(!new_ext_csd);
  
++<<<<<<< HEAD
 +	*new_ext_csd = NULL;
 +
 +	if (card->csd.mmca_vsn < CSD_SPEC_VER_4)
 +		return 0;
++=======
+ 	if (!mmc_can_ext_csd(card))
+ 		return -EOPNOTSUPP;
++>>>>>>> c197787ced5b (mmc: core: Let's callers of from mmc_get_ext_csd() do error handling)
  
  	/*
  	 * As the ext_csd is so large and mostly unused, we don't store the
@@@ -202,34 -200,9 +207,38 @@@
  		return -ENOMEM;
  
  	err = mmc_send_ext_csd(card, ext_csd);
- 	if (err) {
+ 	if (err)
  		kfree(ext_csd);
++<<<<<<< HEAD
 +		*new_ext_csd = NULL;
 +
 +		/* If the host or the card can't do the switch,
 +		 * fail more gracefully. */
 +		if ((err != -EINVAL)
 +		 && (err != -ENOSYS)
 +		 && (err != -EFAULT))
 +			return err;
 +
 +		/*
 +		 * High capacity cards should have this "magic" size
 +		 * stored in their CSD.
 +		 */
 +		if (card->csd.capacity == (4096 * 512)) {
 +			pr_err("%s: unable to read EXT_CSD "
 +				"on a possible high capacity card. "
 +				"Card will be ignored.\n",
 +				mmc_hostname(card->host));
 +		} else {
 +			pr_warning("%s: unable to read "
 +				"EXT_CSD, performance might "
 +				"suffer.\n",
 +				mmc_hostname(card->host));
 +			err = 0;
 +		}
 +	} else
++=======
+ 	else
++>>>>>>> c197787ced5b (mmc: core: Let's callers of from mmc_get_ext_csd() do error handling)
  		*new_ext_csd = ext_csd;
  
  	return err;
* Unmerged path drivers/mmc/core/mmc.c
