mmc: mmc: extend the mmc_send_tuning()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Chaotian Jing <chaotian.jing@mediatek.com>
commit 9979dbe5158899b556eb772b7335e29417ac0ddd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9979dbe5.failed

The mmc_execute_tuning() has already prepared the opcode,
there is no need to prepare it again at mmc_send_tuning(),
and, there is a BUG of mmc_send_tuning() to determine the opcode
by bus width, assume eMMC was running at HS200, 4bit mode,
then the mmc_send_tuning() will overwrite the opcode from CMD21
to CMD19, then got error.

in addition, extend an argument of "cmd_error" to allow getting
if there was cmd error when tune response.

	Signed-off-by: Chaotian Jing <chaotian.jing@mediatek.com>
[Ulf: Rebased patch]
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 9979dbe5158899b556eb772b7335e29417ac0ddd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/mmc_ops.c
#	drivers/mmc/host/dw_mmc-exynos.c
#	drivers/mmc/host/dw_mmc-rockchip.c
#	drivers/mmc/host/dw_mmc.c
#	drivers/mmc/host/dw_mmc.h
#	drivers/mmc/host/sdhci-esdhc-imx.c
#	drivers/mmc/host/sdhci-msm.c
#	drivers/mmc/host/sdhci-sirf.c
#	include/linux/mmc/core.h
diff --cc drivers/mmc/core/mmc_ops.c
index 5e2ad7c0c270,1f444269ebbe..000000000000
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@@ -534,6 -588,75 +534,78 @@@ int mmc_switch(struct mmc_card *card, u
  }
  EXPORT_SYMBOL_GPL(mmc_switch);
  
++<<<<<<< HEAD
++=======
+ int mmc_send_tuning(struct mmc_host *host, u32 opcode, int *cmd_error)
+ {
+ 	struct mmc_request mrq = {NULL};
+ 	struct mmc_command cmd = {0};
+ 	struct mmc_data data = {0};
+ 	struct scatterlist sg;
+ 	struct mmc_ios *ios = &host->ios;
+ 	const u8 *tuning_block_pattern;
+ 	int size, err = 0;
+ 	u8 *data_buf;
+ 
+ 	if (ios->bus_width == MMC_BUS_WIDTH_8) {
+ 		tuning_block_pattern = tuning_blk_pattern_8bit;
+ 		size = sizeof(tuning_blk_pattern_8bit);
+ 	} else if (ios->bus_width == MMC_BUS_WIDTH_4) {
+ 		tuning_block_pattern = tuning_blk_pattern_4bit;
+ 		size = sizeof(tuning_blk_pattern_4bit);
+ 	} else
+ 		return -EINVAL;
+ 
+ 	data_buf = kzalloc(size, GFP_KERNEL);
+ 	if (!data_buf)
+ 		return -ENOMEM;
+ 
+ 	mrq.cmd = &cmd;
+ 	mrq.data = &data;
+ 
+ 	cmd.opcode = opcode;
+ 	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+ 
+ 	data.blksz = size;
+ 	data.blocks = 1;
+ 	data.flags = MMC_DATA_READ;
+ 
+ 	/*
+ 	 * According to the tuning specs, Tuning process
+ 	 * is normally shorter 40 executions of CMD19,
+ 	 * and timeout value should be shorter than 150 ms
+ 	 */
+ 	data.timeout_ns = 150 * NSEC_PER_MSEC;
+ 
+ 	data.sg = &sg;
+ 	data.sg_len = 1;
+ 	sg_init_one(&sg, data_buf, size);
+ 
+ 	mmc_wait_for_req(host, &mrq);
+ 
+ 	if (cmd_error)
+ 		*cmd_error = cmd.error;
+ 
+ 	if (cmd.error) {
+ 		err = cmd.error;
+ 		goto out;
+ 	}
+ 
+ 	if (data.error) {
+ 		err = data.error;
+ 		goto out;
+ 	}
+ 
+ 	if (memcmp(data_buf, tuning_block_pattern, size))
+ 		err = -EIO;
+ 
+ out:
+ 	kfree(data_buf);
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(mmc_send_tuning);
+ 
++>>>>>>> 9979dbe51588 (mmc: mmc: extend the mmc_send_tuning())
  static int
  mmc_send_bus_test(struct mmc_card *card, struct mmc_host *host, u8 opcode,
  		  u8 len)
diff --cc drivers/mmc/host/dw_mmc-exynos.c
index 866edef2e820,3a7e835a0033..000000000000
--- a/drivers/mmc/host/dw_mmc-exynos.c
+++ b/drivers/mmc/host/dw_mmc-exynos.c
@@@ -147,6 -353,138 +147,141 @@@ static int dw_mci_exynos_parse_dt(struc
  		return ret;
  
  	priv->ddr_timing = SDMMC_CLKSEL_TIMING(timing[0], timing[1], div);
++<<<<<<< HEAD
++=======
+ 
+ 	ret = of_property_read_u32_array(np,
+ 			"samsung,dw-mshc-hs400-timing", timing, 2);
+ 	if (!ret && of_property_read_u32(np,
+ 				"samsung,read-strobe-delay", &priv->dqs_delay))
+ 		dev_dbg(host->dev,
+ 			"read-strobe-delay is not found, assuming usage of default value\n");
+ 
+ 	priv->hs400_timing = SDMMC_CLKSEL_TIMING(timing[0], timing[1],
+ 						HS400_FIXED_CIU_CLK_DIV);
+ 	host->priv = priv;
+ 	return 0;
+ }
+ 
+ static inline u8 dw_mci_exynos_get_clksmpl(struct dw_mci *host)
+ {
+ 	struct dw_mci_exynos_priv_data *priv = host->priv;
+ 
+ 	if (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||
+ 		priv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU)
+ 		return SDMMC_CLKSEL_CCLK_SAMPLE(mci_readl(host, CLKSEL64));
+ 	else
+ 		return SDMMC_CLKSEL_CCLK_SAMPLE(mci_readl(host, CLKSEL));
+ }
+ 
+ static inline void dw_mci_exynos_set_clksmpl(struct dw_mci *host, u8 sample)
+ {
+ 	u32 clksel;
+ 	struct dw_mci_exynos_priv_data *priv = host->priv;
+ 
+ 	if (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||
+ 		priv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU)
+ 		clksel = mci_readl(host, CLKSEL64);
+ 	else
+ 		clksel = mci_readl(host, CLKSEL);
+ 	clksel = SDMMC_CLKSEL_UP_SAMPLE(clksel, sample);
+ 	if (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||
+ 		priv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU)
+ 		mci_writel(host, CLKSEL64, clksel);
+ 	else
+ 		mci_writel(host, CLKSEL, clksel);
+ }
+ 
+ static inline u8 dw_mci_exynos_move_next_clksmpl(struct dw_mci *host)
+ {
+ 	struct dw_mci_exynos_priv_data *priv = host->priv;
+ 	u32 clksel;
+ 	u8 sample;
+ 
+ 	if (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||
+ 		priv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU)
+ 		clksel = mci_readl(host, CLKSEL64);
+ 	else
+ 		clksel = mci_readl(host, CLKSEL);
+ 
+ 	sample = (clksel + 1) & 0x7;
+ 	clksel = SDMMC_CLKSEL_UP_SAMPLE(clksel, sample);
+ 
+ 	if (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||
+ 		priv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU)
+ 		mci_writel(host, CLKSEL64, clksel);
+ 	else
+ 		mci_writel(host, CLKSEL, clksel);
+ 
+ 	return sample;
+ }
+ 
+ static s8 dw_mci_exynos_get_best_clksmpl(u8 candiates)
+ {
+ 	const u8 iter = 8;
+ 	u8 __c;
+ 	s8 i, loc = -1;
+ 
+ 	for (i = 0; i < iter; i++) {
+ 		__c = ror8(candiates, i);
+ 		if ((__c & 0xc7) == 0xc7) {
+ 			loc = i;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	for (i = 0; i < iter; i++) {
+ 		__c = ror8(candiates, i);
+ 		if ((__c & 0x83) == 0x83) {
+ 			loc = i;
+ 			goto out;
+ 		}
+ 	}
+ 
+ out:
+ 	return loc;
+ }
+ 
+ static int dw_mci_exynos_execute_tuning(struct dw_mci_slot *slot, u32 opcode)
+ {
+ 	struct dw_mci *host = slot->host;
+ 	struct dw_mci_exynos_priv_data *priv = host->priv;
+ 	struct mmc_host *mmc = slot->mmc;
+ 	u8 start_smpl, smpl, candiates = 0;
+ 	s8 found = -1;
+ 	int ret = 0;
+ 
+ 	start_smpl = dw_mci_exynos_get_clksmpl(host);
+ 
+ 	do {
+ 		mci_writel(host, TMOUT, ~0);
+ 		smpl = dw_mci_exynos_move_next_clksmpl(host);
+ 
+ 		if (!mmc_send_tuning(mmc, opcode, NULL))
+ 			candiates |= (1 << smpl);
+ 
+ 	} while (start_smpl != smpl);
+ 
+ 	found = dw_mci_exynos_get_best_clksmpl(candiates);
+ 	if (found >= 0) {
+ 		dw_mci_exynos_set_clksmpl(host, found);
+ 		priv->tuned_sample = found;
+ 	} else {
+ 		ret = -EIO;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int dw_mci_exynos_prepare_hs400_tuning(struct dw_mci *host,
+ 					struct mmc_ios *ios)
+ {
+ 	struct dw_mci_exynos_priv_data *priv = host->priv;
+ 
+ 	dw_mci_exynos_set_clksel_timing(host, priv->hs400_timing);
+ 	dw_mci_exynos_adjust_clock(host, (ios->clock) << 1);
+ 
++>>>>>>> 9979dbe51588 (mmc: mmc: extend the mmc_send_tuning())
  	return 0;
  }
  
diff --cc drivers/mmc/host/dw_mmc.c
index bc4f99ee919c,63eefea9645e..000000000000
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@@ -1011,25 -1516,45 +1011,54 @@@ static void dw_mci_enable_sdio_irq(stru
  {
  	struct dw_mci_slot *slot = mmc_priv(mmc);
  	struct dw_mci *host = slot->host;
 -	unsigned long irqflags;
  	u32 int_mask;
  
 -	spin_lock_irqsave(&host->irq_lock, irqflags);
 -
  	/* Enable/disable Slot Specific SDIO interrupt */
  	int_mask = mci_readl(host, INTMASK);
 -	if (enb)
 -		int_mask |= SDMMC_INT_SDIO(slot->sdio_id);
 -	else
 -		int_mask &= ~SDMMC_INT_SDIO(slot->sdio_id);
 -	mci_writel(host, INTMASK, int_mask);
 +	if (enb) {
 +		/*
 +		 * Turn off low power mode if it was enabled.  This is a bit of
 +		 * a heavy operation and we disable / enable IRQs a lot, so
 +		 * we'll leave low power mode disabled and it will get
 +		 * re-enabled again in dw_mci_setup_bus().
 +		 */
 +		dw_mci_disable_low_power(slot);
  
++<<<<<<< HEAD
 +		mci_writel(host, INTMASK,
 +			   (int_mask | SDMMC_INT_SDIO(slot->id)));
 +	} else {
 +		mci_writel(host, INTMASK,
 +			   (int_mask & ~SDMMC_INT_SDIO(slot->id)));
 +	}
++=======
+ 	spin_unlock_irqrestore(&host->irq_lock, irqflags);
+ }
+ 
+ static int dw_mci_execute_tuning(struct mmc_host *mmc, u32 opcode)
+ {
+ 	struct dw_mci_slot *slot = mmc_priv(mmc);
+ 	struct dw_mci *host = slot->host;
+ 	const struct dw_mci_drv_data *drv_data = host->drv_data;
+ 	int err = -EINVAL;
+ 
+ 	if (drv_data && drv_data->execute_tuning)
+ 		err = drv_data->execute_tuning(slot, opcode);
+ 	return err;
+ }
+ 
+ static int dw_mci_prepare_hs400_tuning(struct mmc_host *mmc,
+ 				       struct mmc_ios *ios)
+ {
+ 	struct dw_mci_slot *slot = mmc_priv(mmc);
+ 	struct dw_mci *host = slot->host;
+ 	const struct dw_mci_drv_data *drv_data = host->drv_data;
+ 
+ 	if (drv_data && drv_data->prepare_hs400_tuning)
+ 		return drv_data->prepare_hs400_tuning(host, ios);
+ 
+ 	return 0;
++>>>>>>> 9979dbe51588 (mmc: mmc: extend the mmc_send_tuning())
  }
  
  static const struct mmc_host_ops dw_mci_ops = {
diff --cc drivers/mmc/host/dw_mmc.h
index 7f05a02a5484,11cc848a40d4..000000000000
--- a/drivers/mmc/host/dw_mmc.h
+++ b/drivers/mmc/host/dw_mmc.h
@@@ -224,5 -290,10 +224,13 @@@ struct dw_mci_drv_data 
  	void		(*prepare_command)(struct dw_mci *host, u32 *cmdr);
  	void		(*set_ios)(struct dw_mci *host, struct mmc_ios *ios);
  	int		(*parse_dt)(struct dw_mci *host);
++<<<<<<< HEAD
++=======
+ 	int		(*execute_tuning)(struct dw_mci_slot *slot, u32 opcode);
+ 	int		(*prepare_hs400_tuning)(struct dw_mci *host,
+ 						struct mmc_ios *ios);
+ 	int		(*switch_voltage)(struct mmc_host *mmc,
+ 					  struct mmc_ios *ios);
++>>>>>>> 9979dbe51588 (mmc: mmc: extend the mmc_send_tuning())
  };
  #endif /* _DW_MMC_H_ */
diff --cc drivers/mmc/host/sdhci-esdhc-imx.c
index 98f46704baa6,1f1582f6cccb..000000000000
--- a/drivers/mmc/host/sdhci-esdhc-imx.c
+++ b/drivers/mmc/host/sdhci-esdhc-imx.c
@@@ -428,11 -723,213 +428,219 @@@ static int esdhc_pltfm_bus_width(struc
  
  	esdhc_clrset_le(host, ESDHC_CTRL_BUSWIDTH_MASK, ctrl,
  			SDHCI_HOST_CONTROL);
 +
 +	return 0;
  }
  
++<<<<<<< HEAD
 +static const struct sdhci_ops sdhci_esdhc_ops = {
++=======
+ static void esdhc_prepare_tuning(struct sdhci_host *host, u32 val)
+ {
+ 	u32 reg;
+ 
+ 	/* FIXME: delay a bit for card to be ready for next tuning due to errors */
+ 	mdelay(1);
+ 
+ 	reg = readl(host->ioaddr + ESDHC_MIX_CTRL);
+ 	reg |= ESDHC_MIX_CTRL_EXE_TUNE | ESDHC_MIX_CTRL_SMPCLK_SEL |
+ 			ESDHC_MIX_CTRL_FBCLK_SEL;
+ 	writel(reg, host->ioaddr + ESDHC_MIX_CTRL);
+ 	writel(val << 8, host->ioaddr + ESDHC_TUNE_CTRL_STATUS);
+ 	dev_dbg(mmc_dev(host->mmc),
+ 		"tunning with delay 0x%x ESDHC_TUNE_CTRL_STATUS 0x%x\n",
+ 			val, readl(host->ioaddr + ESDHC_TUNE_CTRL_STATUS));
+ }
+ 
+ static void esdhc_post_tuning(struct sdhci_host *host)
+ {
+ 	u32 reg;
+ 
+ 	reg = readl(host->ioaddr + ESDHC_MIX_CTRL);
+ 	reg &= ~ESDHC_MIX_CTRL_EXE_TUNE;
+ 	writel(reg, host->ioaddr + ESDHC_MIX_CTRL);
+ }
+ 
+ static int esdhc_executing_tuning(struct sdhci_host *host, u32 opcode)
+ {
+ 	int min, max, avg, ret;
+ 
+ 	/* find the mininum delay first which can pass tuning */
+ 	min = ESDHC_TUNE_CTRL_MIN;
+ 	while (min < ESDHC_TUNE_CTRL_MAX) {
+ 		esdhc_prepare_tuning(host, min);
+ 		if (!mmc_send_tuning(host->mmc, opcode, NULL))
+ 			break;
+ 		min += ESDHC_TUNE_CTRL_STEP;
+ 	}
+ 
+ 	/* find the maxinum delay which can not pass tuning */
+ 	max = min + ESDHC_TUNE_CTRL_STEP;
+ 	while (max < ESDHC_TUNE_CTRL_MAX) {
+ 		esdhc_prepare_tuning(host, max);
+ 		if (mmc_send_tuning(host->mmc, opcode, NULL)) {
+ 			max -= ESDHC_TUNE_CTRL_STEP;
+ 			break;
+ 		}
+ 		max += ESDHC_TUNE_CTRL_STEP;
+ 	}
+ 
+ 	/* use average delay to get the best timing */
+ 	avg = (min + max) / 2;
+ 	esdhc_prepare_tuning(host, avg);
+ 	ret = mmc_send_tuning(host->mmc, opcode, NULL);
+ 	esdhc_post_tuning(host);
+ 
+ 	dev_dbg(mmc_dev(host->mmc), "tunning %s at 0x%x ret %d\n",
+ 		ret ? "failed" : "passed", avg, ret);
+ 
+ 	return ret;
+ }
+ 
+ static int esdhc_change_pinstate(struct sdhci_host *host,
+ 						unsigned int uhs)
+ {
+ 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+ 	struct pltfm_imx_data *imx_data = pltfm_host->priv;
+ 	struct pinctrl_state *pinctrl;
+ 
+ 	dev_dbg(mmc_dev(host->mmc), "change pinctrl state for uhs %d\n", uhs);
+ 
+ 	if (IS_ERR(imx_data->pinctrl) ||
+ 		IS_ERR(imx_data->pins_default) ||
+ 		IS_ERR(imx_data->pins_100mhz) ||
+ 		IS_ERR(imx_data->pins_200mhz))
+ 		return -EINVAL;
+ 
+ 	switch (uhs) {
+ 	case MMC_TIMING_UHS_SDR50:
+ 		pinctrl = imx_data->pins_100mhz;
+ 		break;
+ 	case MMC_TIMING_UHS_SDR104:
+ 	case MMC_TIMING_MMC_HS200:
+ 	case MMC_TIMING_MMC_HS400:
+ 		pinctrl = imx_data->pins_200mhz;
+ 		break;
+ 	default:
+ 		/* back to default state for other legacy timing */
+ 		pinctrl = imx_data->pins_default;
+ 	}
+ 
+ 	return pinctrl_select_state(imx_data->pinctrl, pinctrl);
+ }
+ 
+ /*
+  * For HS400 eMMC, there is a data_strobe line, this signal is generated
+  * by the device and used for data output and CRC status response output
+  * in HS400 mode. The frequency of this signal follows the frequency of
+  * CLK generated by host. Host receive the data which is aligned to the
+  * edge of data_strobe line. Due to the time delay between CLK line and
+  * data_strobe line, if the delay time is larger than one clock cycle,
+  * then CLK and data_strobe line will misaligned, read error shows up.
+  * So when the CLK is higher than 100MHz, each clock cycle is short enough,
+  * host should config the delay target.
+  */
+ static void esdhc_set_strobe_dll(struct sdhci_host *host)
+ {
+ 	u32 v;
+ 
+ 	if (host->mmc->actual_clock > ESDHC_STROBE_DLL_CLK_FREQ) {
+ 		/* force a reset on strobe dll */
+ 		writel(ESDHC_STROBE_DLL_CTRL_RESET,
+ 			host->ioaddr + ESDHC_STROBE_DLL_CTRL);
+ 		/*
+ 		 * enable strobe dll ctrl and adjust the delay target
+ 		 * for the uSDHC loopback read clock
+ 		 */
+ 		v = ESDHC_STROBE_DLL_CTRL_ENABLE |
+ 			(7 << ESDHC_STROBE_DLL_CTRL_SLV_DLY_TARGET_SHIFT);
+ 		writel(v, host->ioaddr + ESDHC_STROBE_DLL_CTRL);
+ 		/* wait 1us to make sure strobe dll status register stable */
+ 		udelay(1);
+ 		v = readl(host->ioaddr + ESDHC_STROBE_DLL_STATUS);
+ 		if (!(v & ESDHC_STROBE_DLL_STS_REF_LOCK))
+ 			dev_warn(mmc_dev(host->mmc),
+ 				"warning! HS400 strobe DLL status REF not lock!\n");
+ 		if (!(v & ESDHC_STROBE_DLL_STS_SLV_LOCK))
+ 			dev_warn(mmc_dev(host->mmc),
+ 				"warning! HS400 strobe DLL status SLV not lock!\n");
+ 	}
+ }
+ 
+ static void esdhc_set_uhs_signaling(struct sdhci_host *host, unsigned timing)
+ {
+ 	u32 m;
+ 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+ 	struct pltfm_imx_data *imx_data = pltfm_host->priv;
+ 	struct esdhc_platform_data *boarddata = &imx_data->boarddata;
+ 
+ 	/* disable ddr mode and disable HS400 mode */
+ 	m = readl(host->ioaddr + ESDHC_MIX_CTRL);
+ 	m &= ~(ESDHC_MIX_CTRL_DDREN | ESDHC_MIX_CTRL_HS400_EN);
+ 	imx_data->is_ddr = 0;
+ 
+ 	switch (timing) {
+ 	case MMC_TIMING_UHS_SDR12:
+ 	case MMC_TIMING_UHS_SDR25:
+ 	case MMC_TIMING_UHS_SDR50:
+ 	case MMC_TIMING_UHS_SDR104:
+ 	case MMC_TIMING_MMC_HS200:
+ 		writel(m, host->ioaddr + ESDHC_MIX_CTRL);
+ 		break;
+ 	case MMC_TIMING_UHS_DDR50:
+ 	case MMC_TIMING_MMC_DDR52:
+ 		m |= ESDHC_MIX_CTRL_DDREN;
+ 		writel(m, host->ioaddr + ESDHC_MIX_CTRL);
+ 		imx_data->is_ddr = 1;
+ 		if (boarddata->delay_line) {
+ 			u32 v;
+ 			v = boarddata->delay_line <<
+ 				ESDHC_DLL_OVERRIDE_VAL_SHIFT |
+ 				(1 << ESDHC_DLL_OVERRIDE_EN_SHIFT);
+ 			if (is_imx53_esdhc(imx_data))
+ 				v <<= 1;
+ 			writel(v, host->ioaddr + ESDHC_DLL_CTRL);
+ 		}
+ 		break;
+ 	case MMC_TIMING_MMC_HS400:
+ 		m |= ESDHC_MIX_CTRL_DDREN | ESDHC_MIX_CTRL_HS400_EN;
+ 		writel(m, host->ioaddr + ESDHC_MIX_CTRL);
+ 		imx_data->is_ddr = 1;
+ 		esdhc_set_strobe_dll(host);
+ 		break;
+ 	}
+ 
+ 	esdhc_change_pinstate(host, timing);
+ }
+ 
+ static void esdhc_reset(struct sdhci_host *host, u8 mask)
+ {
+ 	sdhci_reset(host, mask);
+ 
+ 	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+ 	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
+ }
+ 
+ static unsigned int esdhc_get_max_timeout_count(struct sdhci_host *host)
+ {
+ 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+ 	struct pltfm_imx_data *imx_data = pltfm_host->priv;
+ 
+ 	return esdhc_is_usdhc(imx_data) ? 1 << 28 : 1 << 27;
+ }
+ 
+ static void esdhc_set_timeout(struct sdhci_host *host, struct mmc_command *cmd)
+ {
+ 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+ 	struct pltfm_imx_data *imx_data = pltfm_host->priv;
+ 
+ 	/* use maximum timeout counter */
+ 	sdhci_writeb(host, esdhc_is_usdhc(imx_data) ? 0xF : 0xE,
+ 			SDHCI_TIMEOUT_CONTROL);
+ }
+ 
+ static struct sdhci_ops sdhci_esdhc_ops = {
++>>>>>>> 9979dbe51588 (mmc: mmc: extend the mmc_send_tuning())
  	.read_l = esdhc_readl_le,
  	.read_w = esdhc_readw_le,
  	.write_l = esdhc_writel_le,
diff --cc drivers/mmc/host/sdhci-msm.c
index 3b0606fe6891,4695bee203ea..000000000000
--- a/drivers/mmc/host/sdhci-msm.c
+++ b/drivers/mmc/host/sdhci-msm.c
@@@ -38,15 -64,351 +38,72 @@@ struct sdhci_msm_host 
  };
  
  /* Platform specific tuning */
 -static inline int msm_dll_poll_ck_out_en(struct sdhci_host *host, u8 poll)
 -{
 -	u32 wait_cnt = 50;
 -	u8 ck_out_en;
 -	struct mmc_host *mmc = host->mmc;
 -
 -	/* Poll for CK_OUT_EN bit.  max. poll time = 50us */
 -	ck_out_en = !!(readl_relaxed(host->ioaddr + CORE_DLL_CONFIG) &
 -			CORE_CK_OUT_EN);
 -
 -	while (ck_out_en != poll) {
 -		if (--wait_cnt == 0) {
 -			dev_err(mmc_dev(mmc), "%s: CK_OUT_EN bit is not %d\n",
 -			       mmc_hostname(mmc), poll);
 -			return -ETIMEDOUT;
 -		}
 -		udelay(1);
 -
 -		ck_out_en = !!(readl_relaxed(host->ioaddr + CORE_DLL_CONFIG) &
 -				CORE_CK_OUT_EN);
 -	}
 -
 -	return 0;
 -}
 -
 -static int msm_config_cm_dll_phase(struct sdhci_host *host, u8 phase)
 -{
 -	int rc;
 -	static const u8 grey_coded_phase_table[] = {
 -		0x0, 0x1, 0x3, 0x2, 0x6, 0x7, 0x5, 0x4,
 -		0xc, 0xd, 0xf, 0xe, 0xa, 0xb, 0x9, 0x8
 -	};
 -	unsigned long flags;
 -	u32 config;
 -	struct mmc_host *mmc = host->mmc;
 -
 -	spin_lock_irqsave(&host->lock, flags);
 -
 -	config = readl_relaxed(host->ioaddr + CORE_DLL_CONFIG);
 -	config &= ~(CORE_CDR_EN | CORE_CK_OUT_EN);
 -	config |= (CORE_CDR_EXT_EN | CORE_DLL_EN);
 -	writel_relaxed(config, host->ioaddr + CORE_DLL_CONFIG);
 -
 -	/* Wait until CK_OUT_EN bit of DLL_CONFIG register becomes '0' */
 -	rc = msm_dll_poll_ck_out_en(host, 0);
 -	if (rc)
 -		goto err_out;
 -
 -	/*
 -	 * Write the selected DLL clock output phase (0 ... 15)
 -	 * to CDR_SELEXT bit field of DLL_CONFIG register.
 -	 */
 -	config = readl_relaxed(host->ioaddr + CORE_DLL_CONFIG);
 -	config &= ~CDR_SELEXT_MASK;
 -	config |= grey_coded_phase_table[phase] << CDR_SELEXT_SHIFT;
 -	writel_relaxed(config, host->ioaddr + CORE_DLL_CONFIG);
 -
 -	/* Set CK_OUT_EN bit of DLL_CONFIG register to 1. */
 -	writel_relaxed((readl_relaxed(host->ioaddr + CORE_DLL_CONFIG)
 -			| CORE_CK_OUT_EN), host->ioaddr + CORE_DLL_CONFIG);
 -
 -	/* Wait until CK_OUT_EN bit of DLL_CONFIG register becomes '1' */
 -	rc = msm_dll_poll_ck_out_en(host, 1);
 -	if (rc)
 -		goto err_out;
 -
 -	config = readl_relaxed(host->ioaddr + CORE_DLL_CONFIG);
 -	config |= CORE_CDR_EN;
 -	config &= ~CORE_CDR_EXT_EN;
 -	writel_relaxed(config, host->ioaddr + CORE_DLL_CONFIG);
 -	goto out;
 -
 -err_out:
 -	dev_err(mmc_dev(mmc), "%s: Failed to set DLL phase: %d\n",
 -	       mmc_hostname(mmc), phase);
 -out:
 -	spin_unlock_irqrestore(&host->lock, flags);
 -	return rc;
 -}
 -
 -/*
 - * Find out the greatest range of consecuitive selected
 - * DLL clock output phases that can be used as sampling
 - * setting for SD3.0 UHS-I card read operation (in SDR104
 - * timing mode) or for eMMC4.5 card read operation (in HS200
 - * timing mode).
 - * Select the 3/4 of the range and configure the DLL with the
 - * selected DLL clock output phase.
 - */
 -
 -static int msm_find_most_appropriate_phase(struct sdhci_host *host,
 -					   u8 *phase_table, u8 total_phases)
 -{
 -	int ret;
 -	u8 ranges[MAX_PHASES][MAX_PHASES] = { {0}, {0} };
 -	u8 phases_per_row[MAX_PHASES] = { 0 };
 -	int row_index = 0, col_index = 0, selected_row_index = 0, curr_max = 0;
 -	int i, cnt, phase_0_raw_index = 0, phase_15_raw_index = 0;
 -	bool phase_0_found = false, phase_15_found = false;
 -	struct mmc_host *mmc = host->mmc;
 -
 -	if (!total_phases || (total_phases > MAX_PHASES)) {
 -		dev_err(mmc_dev(mmc), "%s: Invalid argument: total_phases=%d\n",
 -		       mmc_hostname(mmc), total_phases);
 -		return -EINVAL;
 -	}
 -
 -	for (cnt = 0; cnt < total_phases; cnt++) {
 -		ranges[row_index][col_index] = phase_table[cnt];
 -		phases_per_row[row_index] += 1;
 -		col_index++;
 -
 -		if ((cnt + 1) == total_phases) {
 -			continue;
 -		/* check if next phase in phase_table is consecutive or not */
 -		} else if ((phase_table[cnt] + 1) != phase_table[cnt + 1]) {
 -			row_index++;
 -			col_index = 0;
 -		}
 -	}
 -
 -	if (row_index >= MAX_PHASES)
 -		return -EINVAL;
 -
 -	/* Check if phase-0 is present in first valid window? */
 -	if (!ranges[0][0]) {
 -		phase_0_found = true;
 -		phase_0_raw_index = 0;
 -		/* Check if cycle exist between 2 valid windows */
 -		for (cnt = 1; cnt <= row_index; cnt++) {
 -			if (phases_per_row[cnt]) {
 -				for (i = 0; i < phases_per_row[cnt]; i++) {
 -					if (ranges[cnt][i] == 15) {
 -						phase_15_found = true;
 -						phase_15_raw_index = cnt;
 -						break;
 -					}
 -				}
 -			}
 -		}
 -	}
 -
 -	/* If 2 valid windows form cycle then merge them as single window */
 -	if (phase_0_found && phase_15_found) {
 -		/* number of phases in raw where phase 0 is present */
 -		u8 phases_0 = phases_per_row[phase_0_raw_index];
 -		/* number of phases in raw where phase 15 is present */
 -		u8 phases_15 = phases_per_row[phase_15_raw_index];
 -
 -		if (phases_0 + phases_15 >= MAX_PHASES)
 -			/*
 -			 * If there are more than 1 phase windows then total
 -			 * number of phases in both the windows should not be
 -			 * more than or equal to MAX_PHASES.
 -			 */
 -			return -EINVAL;
 -
 -		/* Merge 2 cyclic windows */
 -		i = phases_15;
 -		for (cnt = 0; cnt < phases_0; cnt++) {
 -			ranges[phase_15_raw_index][i] =
 -			    ranges[phase_0_raw_index][cnt];
 -			if (++i >= MAX_PHASES)
 -				break;
 -		}
 -
 -		phases_per_row[phase_0_raw_index] = 0;
 -		phases_per_row[phase_15_raw_index] = phases_15 + phases_0;
 -	}
 -
 -	for (cnt = 0; cnt <= row_index; cnt++) {
 -		if (phases_per_row[cnt] > curr_max) {
 -			curr_max = phases_per_row[cnt];
 -			selected_row_index = cnt;
 -		}
 -	}
 -
 -	i = (curr_max * 3) / 4;
 -	if (i)
 -		i--;
 -
 -	ret = ranges[selected_row_index][i];
 -
 -	if (ret >= MAX_PHASES) {
 -		ret = -EINVAL;
 -		dev_err(mmc_dev(mmc), "%s: Invalid phase selected=%d\n",
 -		       mmc_hostname(mmc), ret);
 -	}
 -
 -	return ret;
 -}
 -
 -static inline void msm_cm_dll_set_freq(struct sdhci_host *host)
 -{
 -	u32 mclk_freq = 0, config;
 -
 -	/* Program the MCLK value to MCLK_FREQ bit field */
 -	if (host->clock <= 112000000)
 -		mclk_freq = 0;
 -	else if (host->clock <= 125000000)
 -		mclk_freq = 1;
 -	else if (host->clock <= 137000000)
 -		mclk_freq = 2;
 -	else if (host->clock <= 150000000)
 -		mclk_freq = 3;
 -	else if (host->clock <= 162000000)
 -		mclk_freq = 4;
 -	else if (host->clock <= 175000000)
 -		mclk_freq = 5;
 -	else if (host->clock <= 187000000)
 -		mclk_freq = 6;
 -	else if (host->clock <= 200000000)
 -		mclk_freq = 7;
 -
 -	config = readl_relaxed(host->ioaddr + CORE_DLL_CONFIG);
 -	config &= ~CMUX_SHIFT_PHASE_MASK;
 -	config |= mclk_freq << CMUX_SHIFT_PHASE_SHIFT;
 -	writel_relaxed(config, host->ioaddr + CORE_DLL_CONFIG);
 -}
 -
 -/* Initialize the DLL (Programmable Delay Line) */
 -static int msm_init_cm_dll(struct sdhci_host *host)
 -{
 -	struct mmc_host *mmc = host->mmc;
 -	int wait_cnt = 50;
 -	unsigned long flags;
 -
 -	spin_lock_irqsave(&host->lock, flags);
 -
 -	/*
 -	 * Make sure that clock is always enabled when DLL
 -	 * tuning is in progress. Keeping PWRSAVE ON may
 -	 * turn off the clock.
 -	 */
 -	writel_relaxed((readl_relaxed(host->ioaddr + CORE_VENDOR_SPEC)
 -			& ~CORE_CLK_PWRSAVE), host->ioaddr + CORE_VENDOR_SPEC);
 -
 -	/* Write 1 to DLL_RST bit of DLL_CONFIG register */
 -	writel_relaxed((readl_relaxed(host->ioaddr + CORE_DLL_CONFIG)
 -			| CORE_DLL_RST), host->ioaddr + CORE_DLL_CONFIG);
 -
 -	/* Write 1 to DLL_PDN bit of DLL_CONFIG register */
 -	writel_relaxed((readl_relaxed(host->ioaddr + CORE_DLL_CONFIG)
 -			| CORE_DLL_PDN), host->ioaddr + CORE_DLL_CONFIG);
 -	msm_cm_dll_set_freq(host);
 -
 -	/* Write 0 to DLL_RST bit of DLL_CONFIG register */
 -	writel_relaxed((readl_relaxed(host->ioaddr + CORE_DLL_CONFIG)
 -			& ~CORE_DLL_RST), host->ioaddr + CORE_DLL_CONFIG);
 -
 -	/* Write 0 to DLL_PDN bit of DLL_CONFIG register */
 -	writel_relaxed((readl_relaxed(host->ioaddr + CORE_DLL_CONFIG)
 -			& ~CORE_DLL_PDN), host->ioaddr + CORE_DLL_CONFIG);
 -
 -	/* Set DLL_EN bit to 1. */
 -	writel_relaxed((readl_relaxed(host->ioaddr + CORE_DLL_CONFIG)
 -			| CORE_DLL_EN), host->ioaddr + CORE_DLL_CONFIG);
 -
 -	/* Set CK_OUT_EN bit to 1. */
 -	writel_relaxed((readl_relaxed(host->ioaddr + CORE_DLL_CONFIG)
 -			| CORE_CK_OUT_EN), host->ioaddr + CORE_DLL_CONFIG);
 -
 -	/* Wait until DLL_LOCK bit of DLL_STATUS register becomes '1' */
 -	while (!(readl_relaxed(host->ioaddr + CORE_DLL_STATUS) &
 -		 CORE_DLL_LOCK)) {
 -		/* max. wait for 50us sec for LOCK bit to be set */
 -		if (--wait_cnt == 0) {
 -			dev_err(mmc_dev(mmc), "%s: DLL failed to LOCK\n",
 -			       mmc_hostname(mmc));
 -			spin_unlock_irqrestore(&host->lock, flags);
 -			return -ETIMEDOUT;
 -		}
 -		udelay(1);
 -	}
 -
 -	spin_unlock_irqrestore(&host->lock, flags);
 -	return 0;
 -}
 -
  static int sdhci_msm_execute_tuning(struct sdhci_host *host, u32 opcode)
  {
 -	int tuning_seq_cnt = 3;
 -	u8 phase, tuned_phases[16], tuned_phase_cnt = 0;
 -	int rc;
 -	struct mmc_host *mmc = host->mmc;
 -	struct mmc_ios ios = host->mmc->ios;
 -
  	/*
 -	 * Tuning is required for SDR104, HS200 and HS400 cards and
 -	 * if clock frequency is greater than 100MHz in these modes.
 +	 * Tuning is required for SDR104, HS200 and HS400 cards and if the clock
 +	 * frequency greater than 100MHz in those modes. The standard tuning
 +	 * procedure should not be executed, but a custom implementation will be
 +	 * added here instead.
  	 */
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	if (host->clock <= 100 * 1000 * 1000 ||
+ 	    !((ios.timing == MMC_TIMING_MMC_HS200) ||
+ 	      (ios.timing == MMC_TIMING_UHS_SDR104)))
+ 		return 0;
+ 
+ retry:
+ 	/* First of all reset the tuning block */
+ 	rc = msm_init_cm_dll(host);
+ 	if (rc)
+ 		return rc;
+ 
+ 	phase = 0;
+ 	do {
+ 		/* Set the phase in delay line hw block */
+ 		rc = msm_config_cm_dll_phase(host, phase);
+ 		if (rc)
+ 			return rc;
+ 
+ 		rc = mmc_send_tuning(mmc, opcode, NULL);
+ 		if (!rc) {
+ 			/* Tuning is successful at this tuning point */
+ 			tuned_phases[tuned_phase_cnt++] = phase;
+ 			dev_dbg(mmc_dev(mmc), "%s: Found good phase = %d\n",
+ 				 mmc_hostname(mmc), phase);
+ 		}
+ 	} while (++phase < ARRAY_SIZE(tuned_phases));
+ 
+ 	if (tuned_phase_cnt) {
+ 		rc = msm_find_most_appropriate_phase(host, tuned_phases,
+ 						     tuned_phase_cnt);
+ 		if (rc < 0)
+ 			return rc;
+ 		else
+ 			phase = rc;
+ 
+ 		/*
+ 		 * Finally set the selected phase in delay
+ 		 * line hw block.
+ 		 */
+ 		rc = msm_config_cm_dll_phase(host, phase);
+ 		if (rc)
+ 			return rc;
+ 		dev_dbg(mmc_dev(mmc), "%s: Setting the tuning phase to %d\n",
+ 			 mmc_hostname(mmc), phase);
+ 	} else {
+ 		if (--tuning_seq_cnt)
+ 			goto retry;
+ 		/* Tuning failed */
+ 		dev_dbg(mmc_dev(mmc), "%s: No tuning point found\n",
+ 		       mmc_hostname(mmc));
+ 		rc = -EIO;
+ 	}
+ 
+ 	return rc;
++>>>>>>> 9979dbe51588 (mmc: mmc: extend the mmc_send_tuning())
  }
  
  static const struct of_device_id sdhci_msm_dt_match[] = {
diff --cc drivers/mmc/host/sdhci-sirf.c
index 09805af0526d,34866f668dd7..000000000000
--- a/drivers/mmc/host/sdhci-sirf.c
+++ b/drivers/mmc/host/sdhci-sirf.c
@@@ -21,11 -23,127 +21,133 @@@ struct sdhci_sirf_priv 
  	int gpio_cd;
  };
  
 -static void sdhci_sirf_set_bus_width(struct sdhci_host *host, int width)
 +static unsigned int sdhci_sirf_get_max_clk(struct sdhci_host *host)
  {
++<<<<<<< HEAD
 +	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 +	struct sdhci_sirf_priv *priv = pltfm_host->priv;
 +	return clk_get_rate(priv->clk);
++=======
+ 	u8 ctrl;
+ 
+ 	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
+ 	ctrl &= ~(SDHCI_CTRL_4BITBUS | SDHCI_SIRF_8BITBUS);
+ 
+ 	/*
+ 	 * CSR atlas7 and prima2 SD host version is not 3.0
+ 	 * 8bit-width enable bit of CSR SD hosts is 3,
+ 	 * while stardard hosts use bit 5
+ 	 */
+ 	if (width == MMC_BUS_WIDTH_8)
+ 		ctrl |= SDHCI_SIRF_8BITBUS;
+ 	else if (width == MMC_BUS_WIDTH_4)
+ 		ctrl |= SDHCI_CTRL_4BITBUS;
+ 
+ 	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+ }
+ 
+ static u32 sdhci_sirf_readl_le(struct sdhci_host *host, int reg)
+ {
+ 	u32 val = readl(host->ioaddr + reg);
+ 
+ 	if (unlikely((reg == SDHCI_CAPABILITIES_1) &&
+ 			(host->mmc->caps & MMC_CAP_UHS_SDR50))) {
+ 		/* fake CAP_1 register */
+ 		val = SDHCI_SUPPORT_DDR50 |
+ 			SDHCI_SUPPORT_SDR50 | SDHCI_USE_SDR50_TUNING;
+ 	}
+ 
+ 	if (unlikely(reg == SDHCI_SLOT_INT_STATUS)) {
+ 		u32 prss = val;
+ 		/* fake chips as V3.0 host conreoller */
+ 		prss &= ~(0xFF << 16);
+ 		val = prss | (SDHCI_SPEC_300 << 16);
+ 	}
+ 	return val;
+ }
+ 
+ static u16 sdhci_sirf_readw_le(struct sdhci_host *host, int reg)
+ {
+ 	u16 ret = 0;
+ 
+ 	ret = readw(host->ioaddr + reg);
+ 
+ 	if (unlikely(reg == SDHCI_HOST_VERSION)) {
+ 		ret = readw(host->ioaddr + SDHCI_HOST_VERSION);
+ 		ret |= SDHCI_SPEC_300;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int sdhci_sirf_execute_tuning(struct sdhci_host *host, u32 opcode)
+ {
+ 	int tuning_seq_cnt = 3;
+ 	int phase;
+ 	u8 tuned_phase_cnt = 0;
+ 	int rc = 0, longest_range = 0;
+ 	int start = -1, end = 0, tuning_value = -1, range = 0;
+ 	u16 clock_setting;
+ 	struct mmc_host *mmc = host->mmc;
+ 
+ 	clock_setting = sdhci_readw(host, SDHCI_CLK_DELAY_SETTING);
+ 	clock_setting &= ~0x3fff;
+ 
+ retry:
+ 	phase = 0;
+ 	tuned_phase_cnt = 0;
+ 	do {
+ 		sdhci_writel(host,
+ 			clock_setting | phase,
+ 			SDHCI_CLK_DELAY_SETTING);
+ 
+ 		if (!mmc_send_tuning(mmc, opcode, NULL)) {
+ 			/* Tuning is successful at this tuning point */
+ 			tuned_phase_cnt++;
+ 			dev_dbg(mmc_dev(mmc), "%s: Found good phase = %d\n",
+ 				 mmc_hostname(mmc), phase);
+ 			if (start == -1)
+ 				start = phase;
+ 			end = phase;
+ 			range++;
+ 			if (phase == (SIRF_TUNING_COUNT - 1)
+ 				&& range > longest_range)
+ 				tuning_value = (start + end) / 2;
+ 		} else {
+ 			dev_dbg(mmc_dev(mmc), "%s: Found bad phase = %d\n",
+ 				 mmc_hostname(mmc), phase);
+ 			if (range > longest_range) {
+ 				tuning_value = (start + end) / 2;
+ 				longest_range = range;
+ 			}
+ 			start = -1;
+ 			end = range = 0;
+ 		}
+ 	} while (++phase < SIRF_TUNING_COUNT);
+ 
+ 	if (tuned_phase_cnt && tuning_value > 0) {
+ 		/*
+ 		 * Finally set the selected phase in delay
+ 		 * line hw block.
+ 		 */
+ 		phase = tuning_value;
+ 		sdhci_writel(host,
+ 			clock_setting | phase,
+ 			SDHCI_CLK_DELAY_SETTING);
+ 
+ 		dev_dbg(mmc_dev(mmc), "%s: Setting the tuning phase to %d\n",
+ 			 mmc_hostname(mmc), phase);
+ 	} else {
+ 		if (--tuning_seq_cnt)
+ 			goto retry;
+ 		/* Tuning failed */
+ 		dev_dbg(mmc_dev(mmc), "%s: No tuning point found\n",
+ 		       mmc_hostname(mmc));
+ 		rc = -EIO;
+ 	}
+ 
+ 	return rc;
++>>>>>>> 9979dbe51588 (mmc: mmc: extend the mmc_send_tuning())
  }
  
  static struct sdhci_ops sdhci_sirf_ops = {
diff --cc include/linux/mmc/core.h
index d349a5938a2f,37967b6da03c..000000000000
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@@ -152,10 -152,9 +152,15 @@@ extern int mmc_app_cmd(struct mmc_host 
  extern int mmc_wait_for_app_cmd(struct mmc_host *, struct mmc_card *,
  	struct mmc_command *, int);
  extern void mmc_start_bkops(struct mmc_card *card, bool from_exception);
 +extern int __mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int, bool,
 +			bool, bool);
  extern int mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int);
++<<<<<<< HEAD
 +extern int mmc_send_ext_csd(struct mmc_card *card, u8 *ext_csd);
++=======
+ extern int mmc_send_tuning(struct mmc_host *host, u32 opcode, int *cmd_error);
+ extern int mmc_get_ext_csd(struct mmc_card *card, u8 **new_ext_csd);
++>>>>>>> 9979dbe51588 (mmc: mmc: extend the mmc_send_tuning())
  
  #define MMC_ERASE_ARG		0x00000000
  #define MMC_SECURE_ERASE_ARG	0x80000000
* Unmerged path drivers/mmc/host/dw_mmc-rockchip.c
* Unmerged path drivers/mmc/core/mmc_ops.c
* Unmerged path drivers/mmc/host/dw_mmc-exynos.c
* Unmerged path drivers/mmc/host/dw_mmc-rockchip.c
* Unmerged path drivers/mmc/host/dw_mmc.c
* Unmerged path drivers/mmc/host/dw_mmc.h
* Unmerged path drivers/mmc/host/sdhci-esdhc-imx.c
* Unmerged path drivers/mmc/host/sdhci-msm.c
* Unmerged path drivers/mmc/host/sdhci-sirf.c
* Unmerged path include/linux/mmc/core.h
