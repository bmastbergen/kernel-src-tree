drm/i915/gen9: Allow skl_allocate_pipe_ddb() to operate on in-flight state (v3)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matt Roper <matthew.d.roper@intel.com>
commit c107acfeb03187873657ccc8af4fc5c704b3626b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c107acfe.failed

We eventually want to calculate watermark values at atomic 'check' time
instead of atomic 'commit' time so that any requested configurations
that result in impossible watermark requirements are properly rejected.
The first step along this path is to allocate the DDB at atomic 'check'
time.  As we perform this transition, allow the main allocation function
to operate successfully on either an in-flight state or an
already-commited state.  Once we complete the transition in a future
patch, we'll come back and remove the unnecessary logic for the
already-committed case.

v2: Rebase/refactor; we should no longer need to grab extra plane states
    while allocating the DDB since we can pull cached data rates and
    minimum block counts from the CRTC state for any planes that aren't
    being modified by this transaction.

v3:
 - Simplify memsets to clear DDB plane entries.  (Maarten)
 - Drop a redundant memset of plane[pipe][PLANE_CURSOR] that was added
   by an earlier Coccinelle patch.  (Maarten)
 - Assign *num_active at the top of skl_ddb_get_pipe_allocation_limits()
   so that no code paths return without setting it.  (kbuild robot)

	Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1463061971-19638-8-git-send-email-matthew.d.roper@intel.com
(cherry picked from commit c107acfeb03187873657ccc8af4fc5c704b3626b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_drv.h
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/i915_drv.h
index b86c23f96df2,fb7fd7de2b76..000000000000
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@@ -238,6 -315,27 +238,26 @@@ enum hpd_pin 
  #define for_each_crtc(dev, crtc) \
  	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
  
++<<<<<<< HEAD
++=======
+ #define for_each_intel_plane(dev, intel_plane) \
+ 	list_for_each_entry(intel_plane,			\
+ 			    &dev->mode_config.plane_list,	\
+ 			    base.head)
+ 
+ #define for_each_intel_plane_mask(dev, intel_plane, plane_mask)		\
+ 	list_for_each_entry(intel_plane, &dev->mode_config.plane_list,	\
+ 			    base.head)					\
+ 		for_each_if ((plane_mask) &				\
+ 			     (1 << drm_plane_index(&intel_plane->base)))
+ 
+ #define for_each_intel_plane_on_crtc(dev, intel_crtc, intel_plane)	\
+ 	list_for_each_entry(intel_plane,				\
+ 			    &(dev)->mode_config.plane_list,		\
+ 			    base.head)					\
+ 		for_each_if ((intel_plane)->pipe == (intel_crtc)->pipe)
+ 
++>>>>>>> c107acfeb031 (drm/i915/gen9: Allow skl_allocate_pipe_ddb() to operate on in-flight state (v3))
  #define for_each_intel_crtc(dev, intel_crtc) \
  	list_for_each_entry(intel_crtc, &dev->mode_config.crtc_list, base.head)
  
diff --cc drivers/gpu/drm/i915/intel_pm.c
index cca54888a5ac,ca38f6c0e3c8..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -2539,16 -2825,51 +2539,36 @@@ static bool ilk_disable_lp_wm(struct dr
  
  static void
  skl_ddb_get_pipe_allocation_limits(struct drm_device *dev,
++<<<<<<< HEAD
 +				   struct drm_crtc *for_crtc,
 +				   const struct intel_wm_config *config,
 +				   const struct skl_pipe_wm_parameters *params,
 +				   struct skl_ddb_entry *alloc /* out */)
 +{
++=======
+ 				   const struct intel_crtc_state *cstate,
+ 				   struct intel_wm_config *config,
+ 				   struct skl_ddb_entry *alloc, /* out */
+ 				   int *num_active /* out */)
+ {
+ 	struct drm_atomic_state *state = cstate->base.state;
+ 	struct intel_atomic_state *intel_state = to_intel_atomic_state(state);
+ 	struct drm_i915_private *dev_priv = to_i915(dev);
+ 	struct drm_crtc *for_crtc = cstate->base.crtc;
++>>>>>>> c107acfeb031 (drm/i915/gen9: Allow skl_allocate_pipe_ddb() to operate on in-flight state (v3))
  	struct drm_crtc *crtc;
  	unsigned int pipe_size, ddb_size;
  	int nth_active_pipe;
+ 	int pipe = to_intel_crtc(for_crtc)->pipe;
+ 
+ 	if (intel_state && intel_state->active_pipe_changes)
+ 		*num_active = hweight32(intel_state->active_crtcs);
+ 	else if (intel_state)
+ 		*num_active = hweight32(dev_priv->active_crtcs);
+ 	else
+ 		*num_active = config->num_pipes_active;
  
 -	if (!cstate->base.active) {
 +	if (!params->active) {
  		alloc->start = 0;
  		alloc->end = 0;
  		return;
@@@ -2640,47 -3095,102 +2691,138 @@@ skl_get_total_relative_data_rate(struc
  	return total_data_rate;
  }
  
++<<<<<<< HEAD
 +static void
 +skl_allocate_pipe_ddb(struct drm_crtc *crtc,
 +		      const struct intel_wm_config *config,
 +		      const struct skl_pipe_wm_parameters *params,
 +		      struct skl_ddb_allocation *ddb /* out */)
 +{
++=======
+ static int
+ skl_allocate_pipe_ddb(struct intel_crtc_state *cstate,
+ 		      struct skl_ddb_allocation *ddb /* out */)
+ {
+ 	struct drm_atomic_state *state = cstate->base.state;
+ 	struct drm_crtc *crtc = cstate->base.crtc;
++>>>>>>> c107acfeb031 (drm/i915/gen9: Allow skl_allocate_pipe_ddb() to operate on in-flight state (v3))
  	struct drm_device *dev = crtc->dev;
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -	struct intel_wm_config *config = &dev_priv->wm.config;
 +	struct drm_i915_private *dev_priv = dev->dev_private;
  	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
++<<<<<<< HEAD
++=======
+ 	struct intel_plane *intel_plane;
+ 	struct drm_plane *plane;
+ 	struct drm_plane_state *pstate;
++>>>>>>> c107acfeb031 (drm/i915/gen9: Allow skl_allocate_pipe_ddb() to operate on in-flight state (v3))
  	enum pipe pipe = intel_crtc->pipe;
  	struct skl_ddb_entry *alloc = &ddb->pipe[pipe];
  	uint16_t alloc_size, start, cursor_blocks;
 -	uint16_t *minimum = cstate->wm.skl.minimum_blocks;
 -	uint16_t *y_minimum = cstate->wm.skl.minimum_y_blocks;
 +	uint16_t minimum[I915_MAX_PLANES];
  	unsigned int total_data_rate;
++<<<<<<< HEAD
 +	int plane;
 +
 +	skl_ddb_get_pipe_allocation_limits(dev, crtc, config, params, alloc);
 +	alloc_size = skl_ddb_entry_size(alloc);
 +	if (alloc_size == 0) {
 +		memset(ddb->plane[pipe], 0, sizeof(ddb->plane[pipe]));
 +		memset(&ddb->cursor[pipe], 0, sizeof(ddb->cursor[pipe]));
 +		return;
 +	}
 +
 +	cursor_blocks = skl_cursor_allocation(config);
 +	ddb->cursor[pipe].start = alloc->end - cursor_blocks;
 +	ddb->cursor[pipe].end = alloc->end;
++=======
+ 	int num_active;
+ 	int id, i;
+ 
+ 	if (!cstate->base.active) {
+ 		ddb->pipe[pipe].start = ddb->pipe[pipe].end = 0;
+ 		memset(ddb->plane[pipe], 0, sizeof(ddb->plane[pipe]));
+ 		memset(ddb->y_plane[pipe], 0, sizeof(ddb->y_plane[pipe]));
+ 		return 0;
+ 	}
+ 
+ 	skl_ddb_get_pipe_allocation_limits(dev, cstate, config, alloc,
+ 					   &num_active);
+ 	alloc_size = skl_ddb_entry_size(alloc);
+ 	if (alloc_size == 0) {
+ 		memset(ddb->plane[pipe], 0, sizeof(ddb->plane[pipe]));
+ 		return 0;
+ 	}
+ 
+ 	cursor_blocks = skl_cursor_allocation(num_active);
+ 	ddb->plane[pipe][PLANE_CURSOR].start = alloc->end - cursor_blocks;
+ 	ddb->plane[pipe][PLANE_CURSOR].end = alloc->end;
++>>>>>>> c107acfeb031 (drm/i915/gen9: Allow skl_allocate_pipe_ddb() to operate on in-flight state (v3))
  
  	alloc_size -= cursor_blocks;
  	alloc->end -= cursor_blocks;
  
  	/* 1. Allocate the mininum required blocks for each active plane */
++<<<<<<< HEAD
 +	for_each_plane(dev_priv, pipe, plane) {
 +		const struct intel_plane_wm_parameters *p;
 +
 +		p = &params->plane[plane];
 +		if (!p->enabled)
 +			continue;
 +
 +		minimum[plane] = 8;
 +		alloc_size -= minimum[plane];
++=======
+ 	/*
+ 	 * TODO: Remove support for already-committed state once we
+ 	 * only allocate DDB on in-flight states.
+ 	 */
+ 	if (state) {
+ 		for_each_plane_in_state(state, plane, pstate, i) {
+ 			intel_plane = to_intel_plane(plane);
+ 			id = skl_wm_plane_id(intel_plane);
+ 
+ 			if (intel_plane->pipe != pipe)
+ 				continue;
+ 
+ 			if (!to_intel_plane_state(pstate)->visible) {
+ 				minimum[id] = 0;
+ 				y_minimum[id] = 0;
+ 				continue;
+ 			}
+ 			if (plane->type == DRM_PLANE_TYPE_CURSOR) {
+ 				minimum[id] = 0;
+ 				y_minimum[id] = 0;
+ 				continue;
+ 			}
+ 
+ 			minimum[id] = 8;
+ 			if (pstate->fb->pixel_format == DRM_FORMAT_NV12)
+ 				y_minimum[id] = 8;
+ 			else
+ 				y_minimum[id] = 0;
+ 		}
+ 	} else {
+ 		for_each_intel_plane_on_crtc(dev, intel_crtc, intel_plane) {
+ 			struct drm_plane *plane = &intel_plane->base;
+ 			struct drm_framebuffer *fb = plane->state->fb;
+ 			int id = skl_wm_plane_id(intel_plane);
+ 
+ 			if (!to_intel_plane_state(plane->state)->visible)
+ 				continue;
+ 
+ 			if (plane->type == DRM_PLANE_TYPE_CURSOR)
+ 				continue;
+ 
+ 			minimum[id] = 8;
+ 			y_minimum[id] = (fb->pixel_format == DRM_FORMAT_NV12) ? 8 : 0;
+ 		}
+ 	}
+ 
+ 	for (i = 0; i < PLANE_CURSOR; i++) {
+ 		alloc_size -= minimum[i];
+ 		alloc_size -= y_minimum[i];
++>>>>>>> c107acfeb031 (drm/i915/gen9: Allow skl_allocate_pipe_ddb() to operate on in-flight state (v3))
  	}
  
  	/*
@@@ -2689,21 -3199,20 +2831,35 @@@
  	 *
  	 * FIXME: we may not allocate every single block here.
  	 */
++<<<<<<< HEAD
 +	total_data_rate = skl_get_total_relative_data_rate(intel_crtc, params);
 +
 +	start = alloc->start;
 +	for (plane = 0; plane < intel_num_planes(intel_crtc); plane++) {
 +		const struct intel_plane_wm_parameters *p;
 +		unsigned int data_rate;
 +		uint16_t plane_blocks;
 +
 +		p = &params->plane[plane];
 +		if (!p->enabled)
 +			continue;
 +
 +		data_rate = skl_plane_relative_data_rate(p);
++=======
+ 	total_data_rate = skl_get_total_relative_data_rate(cstate);
+ 	if (total_data_rate == 0)
+ 		return 0;
+ 
+ 	start = alloc->start;
+ 	for_each_intel_plane_on_crtc(dev, intel_crtc, intel_plane) {
+ 		unsigned int data_rate, y_data_rate;
+ 		uint16_t plane_blocks, y_plane_blocks = 0;
+ 		int id = skl_wm_plane_id(intel_plane);
+ 
+ 		data_rate = cstate->wm.skl.plane_data_rate[id];
++>>>>>>> c107acfeb031 (drm/i915/gen9: Allow skl_allocate_pipe_ddb() to operate on in-flight state (v3))
  
  		/*
 -		 * allocation for (packed formats) or (uv-plane part of planar format):
  		 * promote the expression to 64 bits to avoid overflowing, the
  		 * result is < available as data_rate / total_data_rate < 1
  		 */
@@@ -2711,12 -3220,32 +2867,39 @@@
  		plane_blocks += div_u64((uint64_t)alloc_size * data_rate,
  					total_data_rate);
  
++<<<<<<< HEAD
 +		ddb->plane[pipe][plane].start = start;
 +		ddb->plane[pipe][plane].end = start + plane_blocks;
 +
 +		start += plane_blocks;
++=======
+ 		/* Leave disabled planes at (0,0) */
+ 		if (data_rate) {
+ 			ddb->plane[pipe][id].start = start;
+ 			ddb->plane[pipe][id].end = start + plane_blocks;
+ 		}
+ 
+ 		start += plane_blocks;
+ 
+ 		/*
+ 		 * allocation for y_plane part of planar format:
+ 		 */
+ 		y_data_rate = cstate->wm.skl.plane_y_data_rate[id];
+ 
+ 		y_plane_blocks = y_minimum[id];
+ 		y_plane_blocks += div_u64((uint64_t)alloc_size * y_data_rate,
+ 					total_data_rate);
+ 
+ 		if (y_data_rate) {
+ 			ddb->y_plane[pipe][id].start = start;
+ 			ddb->y_plane[pipe][id].end = start + y_plane_blocks;
+ 		}
+ 
+ 		start += y_plane_blocks;
++>>>>>>> c107acfeb031 (drm/i915/gen9: Allow skl_allocate_pipe_ddb() to operate on in-flight state (v3))
  	}
  
+ 	return 0;
  }
  
  static uint32_t skl_pipe_pixel_rate(const struct intel_crtc_state *config)
@@@ -3260,15 -3734,16 +3443,20 @@@ static bool skl_update_pipe_wm(struct d
  			       struct skl_pipe_wm *pipe_wm /* out */)
  {
  	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 -	struct intel_crtc_state *cstate = to_intel_crtc_state(crtc->state);
  
++<<<<<<< HEAD
 +	skl_compute_wm_pipe_parameters(crtc, params);
 +	skl_allocate_pipe_ddb(crtc, config, params, ddb);
 +	skl_compute_pipe_wm(crtc, ddb, params, pipe_wm);
++=======
+ 	WARN_ON(skl_allocate_pipe_ddb(cstate, ddb) != 0);
+ 	skl_build_pipe_wm(cstate, ddb, pipe_wm);
++>>>>>>> c107acfeb031 (drm/i915/gen9: Allow skl_allocate_pipe_ddb() to operate on in-flight state (v3))
  
 -	if (!memcmp(&intel_crtc->wm.active.skl, pipe_wm, sizeof(*pipe_wm)))
 +	if (!memcmp(&intel_crtc->wm.skl_active, pipe_wm, sizeof(*pipe_wm)))
  		return false;
  
 -	intel_crtc->wm.active.skl = *pipe_wm;
 -
 +	intel_crtc->wm.skl_active = *pipe_wm;
  	return true;
  }
  
* Unmerged path drivers/gpu/drm/i915/i915_drv.h
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
