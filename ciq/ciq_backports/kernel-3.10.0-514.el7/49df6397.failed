KVM: x86: Split the APIC from the rest of IRQCHIP.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [virt] kvm: x86: Split the APIC from the rest of IRQCHIP (Paolo Bonzini) [1347370]
Rebuild_FUZZ: 98.99%
commit-author Steve Rutherford <srutherford@google.com>
commit 49df6397edfc5a8ba8ca813b51fb9729d8e94b40
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/49df6397.failed

First patch in a series which enables the relocation of the
PIC/IOAPIC to userspace.

Adds capability KVM_CAP_SPLIT_IRQCHIP;

KVM_CAP_SPLIT_IRQCHIP enables the construction of LAPICs without the
rest of the irqchip.

Compile tested for x86.

	Signed-off-by: Steve Rutherford <srutherford@google.com>
	Suggested-by: Andrew Honig <ahonig@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 49df6397edfc5a8ba8ca813b51fb9729d8e94b40)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virtual/kvm/api.txt
#	arch/x86/kvm/ioapic.h
#	include/uapi/linux/kvm.h
diff --cc Documentation/virtual/kvm/api.txt
index d54a8098c59b,43e0816d0de1..000000000000
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@@ -3081,3 -3568,95 +3081,98 @@@ userspace from doing that
  If the hcall number specified is not one that has an in-kernel
  implementation, the KVM_ENABLE_CAP ioctl will fail with an EINVAL
  error.
++<<<<<<< HEAD
++=======
+ 
+ 7.2 KVM_CAP_S390_USER_SIGP
+ 
+ Architectures: s390
+ Parameters: none
+ 
+ This capability controls which SIGP orders will be handled completely in user
+ space. With this capability enabled, all fast orders will be handled completely
+ in the kernel:
+ - SENSE
+ - SENSE RUNNING
+ - EXTERNAL CALL
+ - EMERGENCY SIGNAL
+ - CONDITIONAL EMERGENCY SIGNAL
+ 
+ All other orders will be handled completely in user space.
+ 
+ Only privileged operation exceptions will be checked for in the kernel (or even
+ in the hardware prior to interception). If this capability is not enabled, the
+ old way of handling SIGP orders is used (partially in kernel and user space).
+ 
+ 7.3 KVM_CAP_S390_VECTOR_REGISTERS
+ 
+ Architectures: s390
+ Parameters: none
+ Returns: 0 on success, negative value on error
+ 
+ Allows use of the vector registers introduced with z13 processor, and
+ provides for the synchronization between host and user space.  Will
+ return -EINVAL if the machine does not support vectors.
+ 
+ 7.4 KVM_CAP_S390_USER_STSI
+ 
+ Architectures: s390
+ Parameters: none
+ 
+ This capability allows post-handlers for the STSI instruction. After
+ initial handling in the kernel, KVM exits to user space with
+ KVM_EXIT_S390_STSI to allow user space to insert further data.
+ 
+ Before exiting to userspace, kvm handlers should fill in s390_stsi field of
+ vcpu->run:
+ struct {
+ 	__u64 addr;
+ 	__u8 ar;
+ 	__u8 reserved;
+ 	__u8 fc;
+ 	__u8 sel1;
+ 	__u16 sel2;
+ } s390_stsi;
+ 
+ @addr - guest address of STSI SYSIB
+ @fc   - function code
+ @sel1 - selector 1
+ @sel2 - selector 2
+ @ar   - access register number
+ 
+ KVM handlers should exit to userspace with rc = -EREMOTE.
+ 
+ 7.5 KVM_CAP_SPLIT_IRQCHIP
+ 
+ Architectures: x86
+ Parameters: None
+ Returns: 0 on success, -1 on error
+ 
+ Create a local apic for each processor in the kernel. This can be used
+ instead of KVM_CREATE_IRQCHIP if the userspace VMM wishes to emulate the
+ IOAPIC and PIC (and also the PIT, even though this has to be enabled
+ separately).
+ 
+ This supersedes KVM_CREATE_IRQCHIP, creating only local APICs, but no in kernel
+ IOAPIC or PIC. This also enables in kernel routing of interrupt requests.
+ 
+ Fails if VCPU has already been created, or if the irqchip is already in the
+ kernel (i.e. KVM_CREATE_IRQCHIP has already been called).
+ 
+ 
+ 8. Other capabilities.
+ ----------------------
+ 
+ This section lists capabilities that give information about other
+ features of the KVM implementation.
+ 
+ 8.1 KVM_CAP_PPC_HWRNG
+ 
+ Architectures: ppc
+ 
+ This capability, if KVM_CHECK_EXTENSION indicates that it is
+ available, means that that the kernel has an implementation of the
+ H_RANDOM hypercall backed by a hardware random-number generator.
+ If present, the kernel H_RANDOM handler can be enabled for guest use
+ with the KVM_CAP_PPC_ENABLE_HCALL capability.
++>>>>>>> 49df6397edfc (KVM: x86: Split the APIC from the rest of IRQCHIP.)
diff --cc arch/x86/kvm/ioapic.h
index 6e265cfcd86a,a8842c0dee73..000000000000
--- a/arch/x86/kvm/ioapic.h
+++ b/arch/x86/kvm/ioapic.h
@@@ -98,11 -97,12 +98,20 @@@ static inline struct kvm_ioapic *ioapic
  	return kvm->arch.vioapic;
  }
  
++<<<<<<< HEAD
 +static inline bool kvm_ioapic_handles_vector(struct kvm *kvm, int vector)
 +{
 +	struct kvm_ioapic *ioapic = kvm->arch.vioapic;
 +	smp_rmb();
 +	return test_bit(vector, ioapic->handled_vectors);
++=======
+ static inline int ioapic_in_kernel(struct kvm *kvm)
+ {
+ 	int ret;
+ 
+ 	ret = (ioapic_irqchip(kvm) != NULL);
+ 	return ret;
++>>>>>>> 49df6397edfc (KVM: x86: Split the APIC from the rest of IRQCHIP.)
  }
  
  void kvm_rtc_eoi_tracking_restore_one(struct kvm_vcpu *vcpu);
diff --cc include/uapi/linux/kvm.h
index 39df9ac6ee22,ed00f8fc9ea2..000000000000
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@@ -682,6 -822,9 +682,12 @@@ struct kvm_ppc_smmu_info 
  #define KVM_CAP_DISABLE_QUIRKS 116
  #define KVM_CAP_X86_SMM 117
  #define KVM_CAP_MULTI_ADDRESS_SPACE 118
++<<<<<<< HEAD
++=======
+ #define KVM_CAP_GUEST_DEBUG_HW_BPS 119
+ #define KVM_CAP_GUEST_DEBUG_HW_WPS 120
+ #define KVM_CAP_SPLIT_IRQCHIP 121
++>>>>>>> 49df6397edfc (KVM: x86: Split the APIC from the rest of IRQCHIP.)
  
  #ifdef KVM_CAP_IRQ_ROUTING
  
* Unmerged path Documentation/virtual/kvm/api.txt
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 5d383a89c9d4..05925b66c0c4 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -657,6 +657,8 @@ struct kvm_arch {
 	u32 bsp_vcpu_id;
 
 	u64 disabled_quirks;
+
+	bool irqchip_split;
 };
 
 struct kvm_vm_stat {
diff --git a/arch/x86/kvm/i8254.c b/arch/x86/kvm/i8254.c
index b0a706d063cb..0782d2d4468b 100644
--- a/arch/x86/kvm/i8254.c
+++ b/arch/x86/kvm/i8254.c
@@ -35,6 +35,7 @@
 #include <linux/kvm_host.h>
 #include <linux/slab.h>
 
+#include "ioapic.h"
 #include "irq.h"
 #include "i8254.h"
 #include "x86.h"
@@ -335,7 +336,8 @@ static void create_pit_timer(struct kvm *kvm, u32 val, int is_period)
 	struct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;
 	s64 interval;
 
-	if (!irqchip_in_kernel(kvm) || ps->flags & KVM_PIT_FLAGS_HPET_LEGACY)
+	if (!ioapic_in_kernel(kvm) ||
+	    ps->flags & KVM_PIT_FLAGS_HPET_LEGACY)
 		return;
 
 	interval = muldiv64(val, NSEC_PER_SEC, KVM_PIT_FREQ);
* Unmerged path arch/x86/kvm/ioapic.h
diff --git a/arch/x86/kvm/irq.h b/arch/x86/kvm/irq.h
index 363023e205ac..f74faa2af86b 100644
--- a/arch/x86/kvm/irq.h
+++ b/arch/x86/kvm/irq.h
@@ -83,13 +83,22 @@ static inline struct kvm_pic *pic_irqchip(struct kvm *kvm)
 	return kvm->arch.vpic;
 }
 
+static inline int irqchip_split(struct kvm *kvm)
+{
+	return kvm->arch.irqchip_split;
+}
+
 static inline int irqchip_in_kernel(struct kvm *kvm)
 {
 	struct kvm_pic *vpic = pic_irqchip(kvm);
+	bool ret;
+
+	ret = (vpic != NULL);
+	ret |= irqchip_split(kvm);
 
 	/* Read vpic before kvm->irq_routing.  */
 	smp_rmb();
-	return vpic != NULL;
+	return ret;
 }
 
 void kvm_pic_reset(struct kvm_kpic_state *s);
diff --git a/arch/x86/kvm/irq_comm.c b/arch/x86/kvm/irq_comm.c
index c5bb82b0cf6b..71c6dc45650a 100644
--- a/arch/x86/kvm/irq_comm.c
+++ b/arch/x86/kvm/irq_comm.c
@@ -180,7 +180,7 @@ void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)
 		goto unlock;
 	}
 	clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
-	if (!irqchip_in_kernel(kvm))
+	if (!ioapic_in_kernel(kvm))
 		goto unlock;
 
 	kvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);
@@ -327,3 +327,10 @@ int kvm_setup_default_irq_routing(struct kvm *kvm)
 	return kvm_set_irq_routing(kvm, default_routing,
 				   ARRAY_SIZE(default_routing), 0);
 }
+
+static const struct kvm_irq_routing_entry empty_routing[] = {};
+
+int kvm_setup_empty_irq_routing(struct kvm *kvm)
+{
+	return kvm_set_irq_routing(kvm, empty_routing, 0, 0);
+}
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 1ea3691b454e..2802a83d8858 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -209,7 +209,8 @@ out:
 	if (old)
 		kfree_rcu(old, rcu);
 
-	kvm_vcpu_request_scan_ioapic(kvm);
+	if (ioapic_in_kernel(kvm))
+		kvm_vcpu_request_scan_ioapic(kvm);
 }
 
 static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)
@@ -1935,7 +1936,8 @@ void kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,
 		kvm_x86_ops->hwapic_isr_update(vcpu->kvm,
 				apic_find_highest_isr(apic));
 	kvm_make_request(KVM_REQ_EVENT, vcpu);
-	kvm_rtc_eoi_tracking_restore_one(vcpu);
+	if (ioapic_in_kernel(vcpu->kvm))
+		kvm_rtc_eoi_tracking_restore_one(vcpu);
 }
 
 void __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 733894b44f8d..cb7e8294d39a 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -2857,6 +2857,7 @@ int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
 	case KVM_CAP_ENABLE_CAP_VM:
 	case KVM_CAP_DISABLE_QUIRKS:
 	case KVM_CAP_SET_BOOT_CPU_ID:
+ 	case KVM_CAP_SPLIT_IRQCHIP:
 #ifdef CONFIG_KVM_DEVICE_ASSIGNMENT
 	case KVM_CAP_ASSIGN_DEV_IRQ:
 	case KVM_CAP_PCI_2_3:
@@ -3970,6 +3971,24 @@ static int kvm_vm_ioctl_enable_cap(struct kvm *kvm,
 		kvm->arch.disabled_quirks = cap->args[0];
 		r = 0;
 		break;
+	case KVM_CAP_SPLIT_IRQCHIP: {
+		mutex_lock(&kvm->lock);
+		r = -EEXIST;
+		if (irqchip_in_kernel(kvm))
+			goto split_irqchip_unlock;
+		if (atomic_read(&kvm->online_vcpus))
+			goto split_irqchip_unlock;
+		r = kvm_setup_empty_irq_routing(kvm);
+		if (r)
+			goto split_irqchip_unlock;
+		/* Pairs with irqchip_in_kernel. */
+		smp_wmb();
+		kvm->arch.irqchip_split = true;
+		r = 0;
+split_irqchip_unlock:
+		mutex_unlock(&kvm->lock);
+		break;
+	}
 	default:
 		r = -EINVAL;
 		break;
@@ -4083,7 +4102,7 @@ long kvm_arch_vm_ioctl(struct file *filp,
 		}
 
 		r = -ENXIO;
-		if (!irqchip_in_kernel(kvm))
+		if (!irqchip_in_kernel(kvm) || irqchip_split(kvm))
 			goto get_irqchip_out;
 		r = kvm_vm_ioctl_get_irqchip(kvm, chip);
 		if (r)
@@ -4107,7 +4126,7 @@ long kvm_arch_vm_ioctl(struct file *filp,
 		}
 
 		r = -ENXIO;
-		if (!irqchip_in_kernel(kvm))
+		if (!irqchip_in_kernel(kvm) || irqchip_split(kvm))
 			goto set_irqchip_out;
 		r = kvm_vm_ioctl_set_irqchip(kvm, chip);
 		if (r)
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index cf1b632f8991..bf6ef9bc0c08 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -963,6 +963,7 @@ static inline int mmu_notifier_retry(struct kvm *kvm, unsigned long mmu_seq)
 #define KVM_MAX_IRQ_ROUTES 1024
 
 int kvm_setup_default_irq_routing(struct kvm *kvm);
+int kvm_setup_empty_irq_routing(struct kvm *kvm);
 int kvm_set_irq_routing(struct kvm *kvm,
 			const struct kvm_irq_routing_entry *entries,
 			unsigned nr,
* Unmerged path include/uapi/linux/kvm.h
