net: rework setup_tc ndo op to consume general tc operand

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] rework setup_tc ndo op to consume general tc operand (Ivan Vecera) [1268334]
Rebuild_FUZZ: 95.41%
commit-author John Fastabend <john.fastabend@gmail.com>
commit 16e5cc647173a97e33b3e3ba81f73eb455561794
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/16e5cc64.failed

This patch updates setup_tc so we can pass additional parameters into
the ndo op in a generic way. To do this we provide structured union
and type flag.

This lets each classifier and qdisc provide its own set of attributes
without having to add new ndo ops or grow the signature of the
callback.

	Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 16e5cc647173a97e33b3e3ba81f73eb455561794)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/xgbe-drv.c
#	drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
#	drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
#	drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
#	drivers/net/ethernet/intel/i40e/i40e.h
#	drivers/net/ethernet/intel/i40e/i40e_main.c
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
#	drivers/net/ethernet/mellanox/mlx4/en_netdev.c
#	drivers/net/ethernet/sfc/efx.h
#	drivers/net/ethernet/sfc/tx.c
#	drivers/net/ethernet/ti/netcp_core.c
#	include/linux/netdevice.h
#	net/sched/sch_mqprio.c
diff --cc drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
index 9d9661974791,45843d150868..000000000000
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
@@@ -4207,6 -4272,14 +4207,17 @@@ int bnx2x_setup_tc(struct net_device *d
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ int __bnx2x_setup_tc(struct net_device *dev, u32 handle, __be16 proto,
+ 		     struct tc_to_netdev *tc)
+ {
+ 	if (handle != TC_H_ROOT || tc->type != TC_SETUP_MQPRIO)
+ 		return -EINVAL;
+ 	return bnx2x_setup_tc(dev, tc->tc);
+ }
+ 
++>>>>>>> 16e5cc647173 (net: rework setup_tc ndo op to consume general tc operand)
  /* called with rtnl_lock */
  int bnx2x_change_mac_addr(struct net_device *dev, void *p)
  {
diff --cc drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
index 5e3d903b3117,0e68fadecfdb..000000000000
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
@@@ -484,6 -486,8 +484,11 @@@ netdev_tx_t bnx2x_start_xmit(struct sk_
  
  /* setup_tc callback */
  int bnx2x_setup_tc(struct net_device *dev, u8 num_tc);
++<<<<<<< HEAD
++=======
+ int __bnx2x_setup_tc(struct net_device *dev, u32 handle, __be16 proto,
+ 		     struct tc_to_netdev *tc);
++>>>>>>> 16e5cc647173 (net: rework setup_tc ndo op to consume general tc operand)
  
  int bnx2x_get_vf_config(struct net_device *dev, int vf,
  			struct ifla_vf_info *ivi);
diff --cc drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
index f3260934318e,dc1a82148ff0..000000000000
--- a/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
+++ b/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
@@@ -1187,6 -1194,23 +1187,26 @@@ int fm10k_setup_tc(struct net_device *d
  	interface->flags |= FM10K_FLAG_SWPRI_CONFIG;
  
  	return 0;
++<<<<<<< HEAD
++=======
+ err_open:
+ 	fm10k_mbx_free_irq(interface);
+ err_mbx_irq:
+ 	fm10k_clear_queueing_scheme(interface);
+ err_queueing_scheme:
+ 	netif_device_detach(dev);
+ 
+ 	return err;
+ }
+ 
+ static int __fm10k_setup_tc(struct net_device *dev, u32 handle, __be16 proto,
+ 			    struct tc_to_netdev *tc)
+ {
+ 	if (handle != TC_H_ROOT || tc->type != TC_SETUP_MQPRIO)
+ 		return -EINVAL;
+ 
+ 	return fm10k_setup_tc(dev, tc->tc);
++>>>>>>> 16e5cc647173 (net: rework setup_tc ndo op to consume general tc operand)
  }
  
  static int fm10k_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
diff --cc drivers/net/ethernet/intel/i40e/i40e.h
index f6d97ad811bb,933c4b3d92c8..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@@ -732,7 -788,8 +732,12 @@@ struct i40e_mac_filter *i40e_find_mac(s
  				      bool is_vf, bool is_netdev);
  #ifdef I40E_FCOE
  int i40e_close(struct net_device *netdev);
++<<<<<<< HEAD
 +int i40e_setup_tc(struct net_device *netdev, u8 tc);
++=======
+ int __i40e_setup_tc(struct net_device *netdev, u32 handle, __be16 proto,
+ 		    struct tc_to_netdev *tc);
++>>>>>>> 16e5cc647173 (net: rework setup_tc ndo op to consume general tc operand)
  void i40e_netpoll(struct net_device *netdev);
  int i40e_fcoe_enable(struct net_device *netdev);
  int i40e_fcoe_disable(struct net_device *netdev);
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 54e169e93b8c,257d16207976..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -5106,6 -5306,19 +5106,22 @@@ exit
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef I40E_FCOE
+ int __i40e_setup_tc(struct net_device *netdev, u32 handle, __be16 proto,
+ 		    struct tc_to_netdev *tc)
+ #else
+ static int __i40e_setup_tc(struct net_device *netdev, u32 handle, __be16 proto,
+ 			   struct tc_to_netdev *tc)
+ #endif
+ {
+ 	if (handle != TC_H_ROOT || tc->type != TC_SETUP_MQPRIO)
+ 		return -EINVAL;
+ 	return i40e_setup_tc(netdev, tc->tc);
+ }
+ 
++>>>>>>> 16e5cc647173 (net: rework setup_tc ndo op to consume general tc operand)
  /**
   * i40e_open - Called when a network interface is made active
   * @netdev: network interface device structure
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index e464f2e3e2eb,dca2298f4c36..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -7521,6 -8200,16 +7521,19 @@@ int ixgbe_setup_tc(struct net_device *d
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ int __ixgbe_setup_tc(struct net_device *dev, u32 handle, __be16 proto,
+ 		     struct tc_to_netdev *tc)
+ {
+ 	/* Only support egress tc setup for now */
+ 	if (handle != TC_H_ROOT || tc->type != TC_SETUP_MQPRIO)
+ 		return -EINVAL;
+ 
+ 	return ixgbe_setup_tc(dev, tc->tc);
+ }
+ 
++>>>>>>> 16e5cc647173 (net: rework setup_tc ndo op to consume general tc operand)
  #ifdef CONFIG_PCI_IOV
  void ixgbe_sriov_reinit(struct ixgbe_adapter *adapter)
  {
diff --cc drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index e17d408bbaa2,01d6a9695586..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@@ -69,6 -69,15 +69,18 @@@ int mlx4_en_setup_tc(struct net_device 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int __mlx4_en_setup_tc(struct net_device *dev, u32 handle, __be16 proto,
+ 			      struct tc_to_netdev *tc)
+ {
+ 	if (handle != TC_H_ROOT || tc->type != TC_SETUP_MQPRIO)
+ 		return -EINVAL;
+ 
+ 	return mlx4_en_setup_tc(dev, tc->tc);
+ }
+ 
++>>>>>>> 16e5cc647173 (net: rework setup_tc ndo op to consume general tc operand)
  #ifdef CONFIG_RFS_ACCEL
  
  struct mlx4_en_filter {
diff --cc drivers/net/ethernet/sfc/efx.h
index 10827476bc0b,5e3f93f04e62..000000000000
--- a/drivers/net/ethernet/sfc/efx.h
+++ b/drivers/net/ethernet/sfc/efx.h
@@@ -32,7 -32,8 +32,12 @@@ netdev_tx_t efx_hard_start_xmit(struct 
  				struct net_device *net_dev);
  netdev_tx_t efx_enqueue_skb(struct efx_tx_queue *tx_queue, struct sk_buff *skb);
  void efx_xmit_done(struct efx_tx_queue *tx_queue, unsigned int index);
++<<<<<<< HEAD
 +int efx_setup_tc(struct net_device *net_dev, u8 num_tc);
++=======
+ int efx_setup_tc(struct net_device *net_dev, u32 handle, __be16 proto,
+ 		 struct tc_to_netdev *tc);
++>>>>>>> 16e5cc647173 (net: rework setup_tc ndo op to consume general tc operand)
  unsigned int efx_tx_max_skb_descs(struct efx_nic *efx);
  extern unsigned int efx_piobuf_size;
  extern bool efx_separate_tx_channels;
diff --cc drivers/net/ethernet/sfc/tx.c
index f7a0ec1bca97,2cdb5718ed66..000000000000
--- a/drivers/net/ethernet/sfc/tx.c
+++ b/drivers/net/ethernet/sfc/tx.c
@@@ -562,14 -562,20 +562,27 @@@ void efx_init_tx_queue_core_txq(struct 
  				     efx->n_tx_channels : 0));
  }
  
++<<<<<<< HEAD
 +int efx_setup_tc(struct net_device *net_dev, u8 num_tc)
++=======
+ int efx_setup_tc(struct net_device *net_dev, u32 handle, __be16 proto,
+ 		 struct tc_to_netdev *ntc)
++>>>>>>> 16e5cc647173 (net: rework setup_tc ndo op to consume general tc operand)
  {
  	struct efx_nic *efx = netdev_priv(net_dev);
  	struct efx_channel *channel;
  	struct efx_tx_queue *tx_queue;
- 	unsigned tc;
+ 	unsigned tc, num_tc;
  	int rc;
  
++<<<<<<< HEAD
++=======
+ 	if (handle != TC_H_ROOT || ntc->type != TC_SETUP_MQPRIO)
+ 		return -EINVAL;
+ 
+ 	num_tc = ntc->tc;
+ 
++>>>>>>> 16e5cc647173 (net: rework setup_tc ndo op to consume general tc operand)
  	if (efx_nic_rev(efx) < EFX_REV_FALCON_B0 || num_tc > EFX_MAX_TX_TC)
  		return -EINVAL;
  
diff --cc include/linux/netdevice.h
index eb7e9fa3e472,e396060f815f..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -764,6 -769,31 +764,34 @@@ struct netdev_phys_port_id 
  	unsigned char id_len;
  };
  
++<<<<<<< HEAD
++=======
+ static inline bool netdev_phys_item_id_same(struct netdev_phys_item_id *a,
+ 					    struct netdev_phys_item_id *b)
+ {
+ 	return a->id_len == b->id_len &&
+ 	       memcmp(a->id, b->id, a->id_len) == 0;
+ }
+ 
+ typedef u16 (*select_queue_fallback_t)(struct net_device *dev,
+ 				       struct sk_buff *skb);
+ 
+ /* This structure holds attributes of qdisc and classifiers
+  * that are being passed to the netdevice through the setup_tc op.
+  */
+ enum {
+ 	TC_SETUP_MQPRIO,
+ };
+ 
+ struct tc_to_netdev {
+ 	unsigned int type;
+ 	union {
+ 		u8 tc;
+ 	};
+ };
+ 
+ 
++>>>>>>> 16e5cc647173 (net: rework setup_tc ndo op to consume general tc operand)
  /*
   * This structure defines the management hooks for network devices.
   * The following hooks can be defined; unless noted otherwise, they are
@@@ -1070,7 -1163,13 +1098,17 @@@ struct net_device_ops 
  						   struct nlattr *port[]);
  	int			(*ndo_get_vf_port)(struct net_device *dev,
  						   int vf, struct sk_buff *skb);
++<<<<<<< HEAD
 +	int			(*ndo_setup_tc)(struct net_device *dev, u8 tc);
++=======
+ 	int			(*ndo_set_vf_rss_query_en)(
+ 						   struct net_device *dev,
+ 						   int vf, bool setting);
+ 	int			(*ndo_setup_tc)(struct net_device *dev,
+ 						u32 handle,
+ 						__be16 protocol,
+ 						struct tc_to_netdev *tc);
++>>>>>>> 16e5cc647173 (net: rework setup_tc ndo op to consume general tc operand)
  #if IS_ENABLED(CONFIG_FCOE)
  	int			(*ndo_fcoe_enable)(struct net_device *dev);
  	int			(*ndo_fcoe_disable)(struct net_device *dev);
diff --cc net/sched/sch_mqprio.c
index d44c868cb537,f9947d1f4952..000000000000
--- a/net/sched/sch_mqprio.c
+++ b/net/sched/sch_mqprio.c
@@@ -39,7 -40,7 +40,11 @@@ static void mqprio_destroy(struct Qdis
  	}
  
  	if (priv->hw_owned && dev->netdev_ops->ndo_setup_tc)
++<<<<<<< HEAD
 +		dev->netdev_ops->ndo_setup_tc(dev, 0);
++=======
+ 		dev->netdev_ops->ndo_setup_tc(dev, sch->handle, 0, &tc);
++>>>>>>> 16e5cc647173 (net: rework setup_tc ndo op to consume general tc operand)
  	else
  		netdev_set_num_tc(dev, 0);
  }
@@@ -140,8 -141,11 +145,15 @@@ static int mqprio_init(struct Qdisc *sc
  	 * supplied and verified mapping
  	 */
  	if (qopt->hw) {
+ 		struct tc_to_netdev tc = {.type = TC_SETUP_MQPRIO,
+ 					  .tc = qopt->num_tc};
+ 
  		priv->hw_owned = 1;
++<<<<<<< HEAD
 +		err = dev->netdev_ops->ndo_setup_tc(dev, qopt->num_tc);
++=======
+ 		err = dev->netdev_ops->ndo_setup_tc(dev, sch->handle, 0, &tc);
++>>>>>>> 16e5cc647173 (net: rework setup_tc ndo op to consume general tc operand)
  		if (err)
  			goto err;
  	} else {
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-drv.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
* Unmerged path drivers/net/ethernet/ti/netcp_core.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-drv.c
* Unmerged path drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
* Unmerged path drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
* Unmerged path drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e.h
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_netdev.c
* Unmerged path drivers/net/ethernet/sfc/efx.h
* Unmerged path drivers/net/ethernet/sfc/tx.c
* Unmerged path drivers/net/ethernet/ti/netcp_core.c
* Unmerged path include/linux/netdevice.h
* Unmerged path net/sched/sch_mqprio.c
