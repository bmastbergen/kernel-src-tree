sctp: drop the old assoc hashtable of sctp

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit b5eff7128366c4a7a9b502097a968ec9cae2bea2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b5eff712.failed

transport hashtable will replace the association hashtable,
so association hashtable is not used in sctp any more, so
drop the codes about that.

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b5eff7128366c4a7a9b502097a968ec9cae2bea2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/input.c
#	net/sctp/protocol.c
diff --cc net/sctp/input.c
index e6d42da26807,d9a6e66c5c8a..000000000000
--- a/net/sctp/input.c
+++ b/net/sctp/input.c
@@@ -929,67 -913,6 +929,70 @@@ struct sctp_transport *sctp_epaddr_look
  	return sctp_addrs_lookup_transport(net, &addr->a, paddr);
  }
  
++<<<<<<< HEAD
 +/* Insert association into the hash table.  */
 +static void __sctp_hash_established(struct sctp_association *asoc)
 +{
 +	struct net *net = sock_net(asoc->base.sk);
 +	struct sctp_ep_common *epb;
 +	struct sctp_hashbucket *head;
 +
 +	epb = &asoc->base;
 +
 +	/* Calculate which chain this entry will belong to. */
 +	epb->hashent = sctp_assoc_hashfn(net, epb->bind_addr.port,
 +					 asoc->peer.port);
 +
 +	head = &sctp_assoc_hashtable[epb->hashent];
 +
 +	sctp_write_lock(&head->lock);
 +	hlist_add_head(&epb->node, &head->chain);
 +	sctp_write_unlock(&head->lock);
 +}
 +
 +/* Add an association to the hash. Local BH-safe. */
 +void sctp_hash_established(struct sctp_association *asoc)
 +{
 +	if (asoc->temp)
 +		return;
 +
 +	sctp_local_bh_disable();
 +	__sctp_hash_established(asoc);
 +	sctp_local_bh_enable();
 +}
 +
 +/* Remove association from the hash table.  */
 +static void __sctp_unhash_established(struct sctp_association *asoc)
 +{
 +	struct net *net = sock_net(asoc->base.sk);
 +	struct sctp_hashbucket *head;
 +	struct sctp_ep_common *epb;
 +
 +	epb = &asoc->base;
 +
 +	epb->hashent = sctp_assoc_hashfn(net, epb->bind_addr.port,
 +					 asoc->peer.port);
 +
 +	head = &sctp_assoc_hashtable[epb->hashent];
 +
 +	sctp_write_lock(&head->lock);
 +	hlist_del_init(&epb->node);
 +	sctp_write_unlock(&head->lock);
 +}
 +
 +/* Remove association from the hash table.  Local BH-safe. */
 +void sctp_unhash_established(struct sctp_association *asoc)
 +{
 +	if (asoc->temp)
 +		return;
 +
 +	sctp_local_bh_disable();
 +	__sctp_unhash_established(asoc);
 +	sctp_local_bh_enable();
 +}
 +
++=======
++>>>>>>> b5eff7128366 (sctp: drop the old assoc hashtable of sctp)
  /* Look up an association. */
  static struct sctp_association *__sctp_lookup_association(
  					struct net *net,
diff --cc net/sctp/protocol.c
index e22202613c5c,ab0d538a74ed..000000000000
--- a/net/sctp/protocol.c
+++ b/net/sctp/protocol.c
@@@ -1468,8 -1449,10 +1450,15 @@@ SCTP_STATIC __init int sctp_init(void
  		INIT_HLIST_HEAD(&sctp_port_hashtable[i].chain);
  	}
  
++<<<<<<< HEAD
 +	pr_info("Hash tables configured (established %d bind %d)\n",
 +		sctp_assoc_hashsize, sctp_port_hashsize);
++=======
+ 	if (sctp_transport_hashtable_init())
+ 		goto err_thash_alloc;
+ 
+ 	pr_info("Hash tables configured (bind %d)\n", sctp_port_hashsize);
++>>>>>>> b5eff7128366 (sctp: drop the old assoc hashtable of sctp)
  
  	sctp_sysctl_register();
  
@@@ -1523,12 -1505,10 +1512,8 @@@ err_register_defaults
  		   get_order(sctp_port_hashsize *
  			     sizeof(struct sctp_bind_hashbucket)));
  err_bhash_alloc:
 -	sctp_transport_hashtable_destroy();
 -err_thash_alloc:
  	kfree(sctp_ep_hashtable);
  err_ehash_alloc:
- 	free_pages((unsigned long)sctp_assoc_hashtable,
- 		   get_order(sctp_assoc_hashsize *
- 			     sizeof(struct sctp_hashbucket)));
- err_ahash_alloc:
  	percpu_counter_destroy(&sctp_sockets_allocated);
  err_percpu_counter_init:
  	kmem_cache_destroy(sctp_chunk_cachep);
@@@ -1565,10 -1545,8 +1550,11 @@@ SCTP_STATIC __exit void sctp_exit(void
  	free_pages((unsigned long)sctp_port_hashtable,
  		   get_order(sctp_port_hashsize *
  			     sizeof(struct sctp_bind_hashbucket)));
++<<<<<<< HEAD
++=======
+ 	kfree(sctp_ep_hashtable);
+ 	sctp_transport_hashtable_destroy();
++>>>>>>> b5eff7128366 (sctp: drop the old assoc hashtable of sctp)
  
  	percpu_counter_destroy(&sctp_sockets_allocated);
  
diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.h
index 4b35a0af7318..245ef9aee141 100644
--- a/include/net/sctp/sctp.h
+++ b/include/net/sctp/sctp.h
@@ -151,8 +151,6 @@ int sctp_primitive_ASCONF(struct net *, struct sctp_association *, void *arg);
  */
 int sctp_rcv(struct sk_buff *skb);
 void sctp_v4_err(struct sk_buff *skb, u32 info);
-void sctp_hash_established(struct sctp_association *);
-void sctp_unhash_established(struct sctp_association *);
 void sctp_hash_endpoint(struct sctp_endpoint *);
 void sctp_unhash_endpoint(struct sctp_endpoint *);
 struct sock *sctp_err_lookup(struct net *net, int family, struct sk_buff *,
@@ -667,25 +665,6 @@ static inline int sctp_ep_hashfn(struct net *net, __u16 lport)
 	return (net_hash_mix(net) + lport) & (sctp_ep_hashsize - 1);
 }
 
-/* This is the hash function for the association hash table. */
-static inline int sctp_assoc_hashfn(struct net *net, __u16 lport, __u16 rport)
-{
-	int h = (lport << 16) + rport + net_hash_mix(net);
-	h ^= h>>8;
-	return h & (sctp_assoc_hashsize - 1);
-}
-
-/* This is the hash function for the association hash table.  This is
- * not used yet, but could be used as a better hash function when
- * we have a vtag.
- */
-static inline int sctp_vtag_hashfn(__u16 lport, __u16 rport, __u32 vtag)
-{
-	int h = (lport << 16) + rport;
-	h ^= vtag;
-	return h & (sctp_assoc_hashsize - 1);
-}
-
 #define sctp_for_each_hentry(epb, head) \
 	hlist_for_each_entry(epb, head, node)
 
diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7a7c7cb8b173..ec1481078a8c 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -127,8 +127,6 @@ extern struct sctp_globals {
 
 	/* This is the hash of all endpoints. */
 	struct sctp_hashbucket *ep_hashtable;
-	/* This is the hash of all associations. */
-	struct sctp_hashbucket *assoc_hashtable;
 	/* This is the sctp port control hash.	*/
 	struct sctp_bind_hashbucket *port_hashtable;
 	/* This is the hash of all transports. */
@@ -136,7 +134,6 @@ extern struct sctp_globals {
 
 	/* Sizes of above hashtables. */
 	int ep_hashsize;
-	int assoc_hashsize;
 	int port_hashsize;
 
 	/* Default initialization values to be applied to new associations. */
@@ -153,8 +150,6 @@ extern struct sctp_globals {
 #define sctp_address_families		(sctp_globals.address_families)
 #define sctp_ep_hashsize		(sctp_globals.ep_hashsize)
 #define sctp_ep_hashtable		(sctp_globals.ep_hashtable)
-#define sctp_assoc_hashsize		(sctp_globals.assoc_hashsize)
-#define sctp_assoc_hashtable		(sctp_globals.assoc_hashtable)
 #define sctp_port_hashsize		(sctp_globals.port_hashsize)
 #define sctp_port_hashtable		(sctp_globals.port_hashtable)
 #define sctp_transport_hashtable	(sctp_globals.transport_hashtable)
* Unmerged path net/sctp/input.c
* Unmerged path net/sctp/protocol.c
diff --git a/net/sctp/sm_sideeffect.c b/net/sctp/sm_sideeffect.c
index 57238eb66318..da754f856d7c 100644
--- a/net/sctp/sm_sideeffect.c
+++ b/net/sctp/sm_sideeffect.c
@@ -870,7 +870,6 @@ static void sctp_cmd_delete_tcb(sctp_cmd_seq_t *cmds,
 	    (!asoc->temp) && (sk->sk_shutdown != SHUTDOWN_MASK))
 		return;
 
-	sctp_unhash_established(asoc);
 	sctp_association_free(asoc);
 }
 
@@ -1285,7 +1284,6 @@ static int sctp_cmd_interpreter(sctp_event_t event_type,
 			asoc = cmd->obj.asoc;
 			BUG_ON(asoc->peer.primary_path == NULL);
 			sctp_endpoint_add_asoc(ep, asoc);
-			sctp_hash_established(asoc);
 			break;
 
 		case SCTP_CMD_UPDATE_ASSOC:
diff --git a/net/sctp/socket.c b/net/sctp/socket.c
index a6cc37c2bb95..6d71f6a16f8e 100644
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@ -1248,7 +1248,6 @@ out_free:
 		 * To the hash table, try to unhash it, just in case, its a noop
 		 * if it wasn't hashed so we're safe
 		 */
-		sctp_unhash_established(asoc);
 		sctp_association_free(asoc);
 	}
 	return err;
@@ -1521,7 +1520,6 @@ SCTP_STATIC void sctp_close(struct sock *sk, long timeout)
 			 * ABORT or SHUTDOWN based on the linger options.
 			 */
 			if (sctp_state(asoc, CLOSED)) {
-				sctp_unhash_established(asoc);
 				sctp_association_free(asoc);
 				continue;
 			}
@@ -1985,10 +1983,8 @@ SCTP_STATIC int sctp_sendmsg(struct kiocb *iocb, struct sock *sk,
 	goto out_unlock;
 
 out_free:
-	if (new_asoc) {
-		sctp_unhash_established(asoc);
+	if (new_asoc)
 		sctp_association_free(asoc);
-	}
 out_unlock:
 	sctp_release_sock(sk);
 
