mmc: sdhci: make max-frequency property in device tree work

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] sdhci: make max-frequency property in device tree work (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 95.58%
commit-author Dong Aisheng <aisheng.dong@freescale.com>
commit 5924175755a0ed902d91f2f2660e914032fa63e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/59241757.failed

Device tree provides option to specify the max freqency with property
"max-frequency" in dts and common parse function mmc_of_parse() will
parse it and use this value to set host->f_max to tell the MMC core
the maxinum frequency the host works.

However, current sdhci driver will finally overwrite this value with
host->max_clk regardless of the max-frequency property.

This patch makes sure not overwrite the max-frequency set from device
tree and do basic sanity check.

	Signed-off-by: Dong Aisheng <aisheng.dong@freescale.com>
	Reviewed-by: Johan Derycke <johan.derycke@barco.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 5924175755a0ed902d91f2f2660e914032fa63e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci.c
diff --cc drivers/mmc/host/sdhci.c
index 48682666d1e9,1dbe93232030..000000000000
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@@ -2890,6 -2865,8 +2890,11 @@@ int sdhci_add_host(struct sdhci_host *h
  	u32 caps[2] = {0, 0};
  	u32 max_current_caps;
  	unsigned int ocr_avail;
++<<<<<<< HEAD
++=======
+ 	unsigned int override_timeout_clk;
+ 	u32 max_clk;
++>>>>>>> 5924175755a0 (mmc: sdhci: make max-frequency property in device tree work)
  	int ret;
  
  	WARN_ON(host == NULL);
@@@ -3051,25 -3064,33 +3057,43 @@@
  	} else
  		mmc->f_min = host->max_clk / SDHCI_MAX_DIV_SPEC_200;
  
++<<<<<<< HEAD
 +	host->timeout_clk =
 +		(caps[0] & SDHCI_TIMEOUT_CLK_MASK) >> SDHCI_TIMEOUT_CLK_SHIFT;
 +	if (host->timeout_clk == 0) {
 +		if (host->ops->get_timeout_clock) {
 +			host->timeout_clk = host->ops->get_timeout_clock(host);
 +		} else if (!(host->quirks &
 +				SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK)) {
 +			pr_err("%s: Hardware doesn't specify timeout clock "
 +			       "frequency.\n", mmc_hostname(mmc));
 +			return -ENODEV;
++=======
+ 	if (!mmc->f_max || (mmc->f_max && (mmc->f_max > max_clk)))
+ 		mmc->f_max = max_clk;
+ 
+ 	if (!(host->quirks & SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK)) {
+ 		host->timeout_clk = (caps[0] & SDHCI_TIMEOUT_CLK_MASK) >>
+ 					SDHCI_TIMEOUT_CLK_SHIFT;
+ 		if (host->timeout_clk == 0) {
+ 			if (host->ops->get_timeout_clock) {
+ 				host->timeout_clk =
+ 					host->ops->get_timeout_clock(host);
+ 			} else {
+ 				pr_err("%s: Hardware doesn't specify timeout clock frequency.\n",
+ 					mmc_hostname(mmc));
+ 				return -ENODEV;
+ 			}
++>>>>>>> 5924175755a0 (mmc: sdhci: make max-frequency property in device tree work)
  		}
 -
 -		if (caps[0] & SDHCI_TIMEOUT_CLK_UNIT)
 -			host->timeout_clk *= 1000;
 -
 -		mmc->max_busy_timeout = host->ops->get_max_timeout_count ?
 -			host->ops->get_max_timeout_count(host) : 1 << 27;
 -		mmc->max_busy_timeout /= host->timeout_clk;
  	}
 +	if (caps[0] & SDHCI_TIMEOUT_CLK_UNIT)
 +		host->timeout_clk *= 1000;
 +
 +	if (host->quirks & SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK)
 +		host->timeout_clk = mmc->f_max / 1000;
  
 -	if (override_timeout_clk)
 -		host->timeout_clk = override_timeout_clk;
 +	mmc->max_busy_timeout = (1 << 27) / host->timeout_clk;
  
  	mmc->caps |= MMC_CAP_SDIO_IRQ | MMC_CAP_ERASE | MMC_CAP_CMD23;
  	mmc->caps2 |= MMC_CAP2_SDIO_IRQ_NOTHREAD;
* Unmerged path drivers/mmc/host/sdhci.c
