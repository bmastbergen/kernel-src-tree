asix: Tidy-up 32-bit header word synchronisation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dean Jenkins <Dean_Jenkins@mentor.com>
commit 3bfc69abf802f56901ffd83bb66b7dd7644ddcc3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3bfc69ab.failed

Tidy-up the Data header 32-bit word synchronisation logic in
asix_rx_fixup_internal() by removing redundant logic tests.

The code is looking at the following cases of the Data header
32-bit word that is present before each Ethernet frame:

a) all 32 bits of the Data header word are in the URB socket buffer
b) first 16 bits of the Data header word are at the end of the URB
   socket buffer
c) last 16 bits of the Data header word are at the start of the URB
   socket buffer eg. split_head = true

Note that the lifetime of rx->split_head exists outside of the
function call and is accessed per processing of each URB. Therefore,
split_head being true acts on the next URB to be processed.

To check for b) the offset will be 16 bits (2 bytes) from the end of
the buffer then indicate split_head is true.
To check for c) split_head must be true because the first 16 bits
have been found.
To check for a) else c)

Note that the || logic of the old code included the state
(skb->len - offset == sizeof(u16) && rx->split_head) which is not
possible because the split_head cannot be true whilst checking for b).
This is because the split_head indicates that the first 16 bits have
been found and that is not possible whilst checking for the first 16
bits. Therefore simplify the logic.

	Signed-off-by: Dean Jenkins <Dean_Jenkins@mentor.com>
	Signed-off-by: Mark Craske <Mark_Craske@mentor.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3bfc69abf802f56901ffd83bb66b7dd7644ddcc3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/asix_common.c
diff --cc drivers/net/usb/asix_common.c
index 99bf5d9050e8,89efd6ad9644..000000000000
--- a/drivers/net/usb/asix_common.c
+++ b/drivers/net/usb/asix_common.c
@@@ -54,27 -54,26 +54,44 @@@ int asix_rx_fixup_internal(struct usbne
  			   struct asix_rx_fixup_info *rx)
  {
  	int offset = 0;
 -	u16 size;
  
  	while (offset + sizeof(u16) <= skb->len) {
 -		u16 copy_length;
 +		u16 remaining = 0;
  		unsigned char *data;
  
++<<<<<<< HEAD
 +		if (!rx->size) {
 +			if ((skb->len - offset == sizeof(u16)) ||
 +			    rx->split_head) {
 +				if(!rx->split_head) {
 +					rx->header = get_unaligned_le16(
 +							skb->data + offset);
 +					rx->split_head = true;
 +					offset += sizeof(u16);
 +					break;
 +				} else {
 +					rx->header |= (get_unaligned_le16(
 +							skb->data + offset)
 +							<< 16);
 +					rx->split_head = false;
 +					offset += sizeof(u16);
 +				}
++=======
+ 		if (!rx->remaining) {
+ 			if (skb->len - offset == sizeof(u16)) {
+ 				rx->header = get_unaligned_le16(
+ 						skb->data + offset);
+ 				rx->split_head = true;
+ 				offset += sizeof(u16);
+ 				break;
+ 			}
+ 
+ 			if (rx->split_head == true) {
+ 				rx->header |= (get_unaligned_le16(
+ 						skb->data + offset) << 16);
+ 				rx->split_head = false;
+ 				offset += sizeof(u16);
++>>>>>>> 3bfc69abf802 (asix: Tidy-up 32-bit header word synchronisation)
  			} else {
  				rx->header = get_unaligned_le32(skb->data +
  								offset);
* Unmerged path drivers/net/usb/asix_common.c
