sched/deadline: Clear dl_entity params when setscheduling to different class

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Juri Lelli <juri.lelli@arm.com>
commit a5e7be3b28a235108c59561bea55eea1072b23b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a5e7be3b.failed

When a task is using SCHED_DEADLINE and the user setschedules it to a
different class its sched_dl_entity static parameters are not cleaned
up. This causes a bug if the user sets it back to SCHED_DEADLINE with
the same parameters again.  The problem resides in the check we
perform at the very beginning of dl_overflow():

	if (new_bw == p->dl.dl_bw)
		return 0;

This condition is met in the case depicted above, so the function
returns and dl_b->total_bw is not updated (the p->dl.dl_bw is not
added to it). After this, admission control is broken.

This patch fixes the thing, properly clearing static parameters for a
task that ceases to use SCHED_DEADLINE.

	Reported-by: Daniele Alessandrelli <daniele.alessandrelli@gmail.com>
	Reported-by: Daniel Wagner <daniel.wagner@bmw-carit.de>
	Reported-by: Vincent Legout <vincent@legout.info>
	Tested-by: Luca Abeni <luca.abeni@unitn.it>
	Tested-by: Daniel Wagner <daniel.wagner@bmw-carit.de>
	Tested-by: Vincent Legout <vincent@legout.info>
	Signed-off-by: Juri Lelli <juri.lelli@arm.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Fabio Checconi <fchecconi@gmail.com>
	Cc: Dario Faggioli <raistlin@linux.it>
	Cc: Michael Trimarchi <michael@amarulasolutions.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
Link: http://lkml.kernel.org/r/1411118561-26323-2-git-send-email-juri.lelli@arm.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit a5e7be3b28a235108c59561bea55eea1072b23b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/core.c
#	kernel/sched/deadline.c
#	kernel/sched/sched.h
diff --cc kernel/sched/core.c
index f8654b1100de,09bde2ab2a0a..000000000000
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@@ -1827,6 -1844,10 +1841,13 @@@ static void __sched_fork(unsigned long 
  	memset(&p->se.statistics, 0, sizeof(p->se.statistics));
  #endif
  
++<<<<<<< HEAD
++=======
+ 	RB_CLEAR_NODE(&p->dl.rb_node);
+ 	hrtimer_init(&p->dl.dl_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+ 	__dl_clear_params(p);
+ 
++>>>>>>> a5e7be3b28a2 (sched/deadline: Clear dl_entity params when setscheduling to different class)
  	INIT_LIST_HEAD(&p->rt.run_list);
  
  #ifdef CONFIG_PREEMPT_NOTIFIERS
diff --cc kernel/sched/sched.h
index b976abe32e72,76f3a38a401c..000000000000
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@@ -102,6 -130,50 +102,53 @@@ struct rt_bandwidth 
  	u64			rt_runtime;
  	struct hrtimer		rt_period_timer;
  };
++<<<<<<< HEAD
++=======
+ 
+ void __dl_clear_params(struct task_struct *p);
+ 
+ /*
+  * To keep the bandwidth of -deadline tasks and groups under control
+  * we need some place where:
+  *  - store the maximum -deadline bandwidth of the system (the group);
+  *  - cache the fraction of that bandwidth that is currently allocated.
+  *
+  * This is all done in the data structure below. It is similar to the
+  * one used for RT-throttling (rt_bandwidth), with the main difference
+  * that, since here we are only interested in admission control, we
+  * do not decrease any runtime while the group "executes", neither we
+  * need a timer to replenish it.
+  *
+  * With respect to SMP, the bandwidth is given on a per-CPU basis,
+  * meaning that:
+  *  - dl_bw (< 100%) is the bandwidth of the system (group) on each CPU;
+  *  - dl_total_bw array contains, in the i-eth element, the currently
+  *    allocated bandwidth on the i-eth CPU.
+  * Moreover, groups consume bandwidth on each CPU, while tasks only
+  * consume bandwidth on the CPU they're running on.
+  * Finally, dl_total_bw_cpu is used to cache the index of dl_total_bw
+  * that will be shown the next time the proc or cgroup controls will
+  * be red. It on its turn can be changed by writing on its own
+  * control.
+  */
+ struct dl_bandwidth {
+ 	raw_spinlock_t dl_runtime_lock;
+ 	u64 dl_runtime;
+ 	u64 dl_period;
+ };
+ 
+ static inline int dl_bandwidth_enabled(void)
+ {
+ 	return sysctl_sched_rt_runtime >= 0;
+ }
+ 
+ extern struct dl_bw *dl_bw_of(int i);
+ 
+ struct dl_bw {
+ 	raw_spinlock_t lock;
+ 	u64 bw, total_bw;
+ };
++>>>>>>> a5e7be3b28a2 (sched/deadline: Clear dl_entity params when setscheduling to different class)
  
  extern struct mutex sched_domains_mutex;
  
* Unmerged path kernel/sched/deadline.c
* Unmerged path kernel/sched/core.c
* Unmerged path kernel/sched/deadline.c
* Unmerged path kernel/sched/sched.h
