net: cdc_ncm: split out rx_max/tx_max update of setup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bjørn Mork <bjorn@mork.no>
commit 5aa73d5d72bddfcac253d06f84e80e38c5bb430c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5aa73d5d.failed

Split out the part of setup dealing with updating the rx_max
and tx_max buffer sizes so that this code can be reused for
dynamically updating the limits.

	Signed-off-by: Bjørn Mork <bjorn@mork.no>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5aa73d5d72bddfcac253d06f84e80e38c5bb430c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/cdc_ncm.c
diff --cc drivers/net/usb/cdc_ncm.c
index 4bae7ffa5334,e5f5153bf8c6..000000000000
--- a/drivers/net/usb/cdc_ncm.c
+++ b/drivers/net/usb/cdc_ncm.c
@@@ -68,19 -65,62 +68,78 @@@ static void cdc_ncm_tx_timeout_start(st
  static enum hrtimer_restart cdc_ncm_tx_timer_cb(struct hrtimer *hr_timer);
  static struct usb_driver cdc_ncm_driver;
  
++<<<<<<< HEAD
 +static void
 +cdc_ncm_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
 +{
 +	struct usbnet *dev = netdev_priv(net);
 +
 +	strlcpy(info->driver, dev->driver_name, sizeof(info->driver));
 +	strlcpy(info->version, DRIVER_VERSION, sizeof(info->version));
 +	strlcpy(info->fw_version, dev->driver_info->description,
 +		sizeof(info->fw_version));
 +	usb_make_path(dev->udev, info->bus_info, sizeof(info->bus_info));
 +}
 +
 +static u8 cdc_ncm_setup(struct usbnet *dev)
++=======
+ /* handle rx_max and tx_max changes */
+ static void cdc_ncm_update_rxtx_max(struct usbnet *dev, u32 new_rx, u32 new_tx)
+ {
+ 	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
+ 	u8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;
+ 	u32 val, max, min;
+ 
+ 	/* clamp new_rx to sane values */
+ 	min = USB_CDC_NCM_NTB_MIN_IN_SIZE;
+ 	max = min_t(u32, CDC_NCM_NTB_MAX_SIZE_RX, le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize));
+ 
+ 	/* dwNtbInMaxSize spec violation? Use MIN size for both limits */
+ 	if (max < min) {
+ 		dev_warn(&dev->intf->dev, "dwNtbInMaxSize=%u is too small. Using %u\n",
+ 			 le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize), min);
+ 		max = min;
+ 	}
+ 
+ 	val = clamp_t(u32, new_rx, min, max);
+ 	if (val != new_rx) {
+ 		dev_dbg(&dev->intf->dev, "rx_max must be in the [%u, %u] range. Using %u\n",
+ 			min, max, val);
+ 	}
+ 
+ 	/* inform device about NTB input size changes */
+ 	if (val != ctx->rx_max) {
+ 		__le32 dwNtbInMaxSize = cpu_to_le32(val);
+ 
+ 		dev_info(&dev->intf->dev, "setting rx_max = %u\n", val);
+ 		if (usbnet_write_cmd(dev, USB_CDC_SET_NTB_INPUT_SIZE,
+ 				     USB_TYPE_CLASS | USB_DIR_OUT
+ 				     | USB_RECIP_INTERFACE,
+ 				     0, iface_no, &dwNtbInMaxSize, 4) < 0)
+ 			dev_dbg(&dev->intf->dev, "Setting NTB Input Size failed\n");
+ 		else
+ 			ctx->rx_max = val;
+ 	}
+ 
+ 	/* clamp new_tx to sane values */
+ 	min = CDC_NCM_MIN_HDR_SIZE + ctx->max_datagram_size;
+ 	max = min_t(u32, CDC_NCM_NTB_MAX_SIZE_TX, le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize));
+ 
+ 	/* some devices set dwNtbOutMaxSize too low for the above default */
+ 	min = min(min, max);
+ 
+ 	val = clamp_t(u32, new_tx, min, max);
+ 	if (val != new_tx) {
+ 		dev_dbg(&dev->intf->dev, "tx_max must be in the [%u, %u] range. Using %u\n",
+ 			min, max, val);
+ 	}
+ 	if (val != ctx->tx_max)
+ 		dev_info(&dev->intf->dev, "setting tx_max = %u\n", val);
+ 	ctx->tx_max = val;
+ }
+ 
+ static int cdc_ncm_setup(struct usbnet *dev)
++>>>>>>> 5aa73d5d72bd (net: cdc_ncm: split out rx_max/tx_max update of setup)
  {
  	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];
  	u32 val;
* Unmerged path drivers/net/usb/cdc_ncm.c
