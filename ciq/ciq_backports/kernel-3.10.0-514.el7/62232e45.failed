libnvdimm: control (ioctl) messages for nvdimm_bus and nvdimm devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit 62232e45f4a265abb43f0acf16e58f5d0b6e1ec9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/62232e45.failed

Most discovery/configuration of the nvdimm-subsystem is done via sysfs
attributes.  However, some nvdimm_bus instances, particularly the
ACPI.NFIT bus, define a small set of messages that can be passed to the
platform.  For convenience we derive the initial libnvdimm-ioctl command
formats directly from the NFIT DSM Interface Example formats.

    ND_CMD_SMART: media health and diagnostics
    ND_CMD_GET_CONFIG_SIZE: size of the label space
    ND_CMD_GET_CONFIG_DATA: read label space
    ND_CMD_SET_CONFIG_DATA: write label space
    ND_CMD_VENDOR: vendor-specific command passthrough
    ND_CMD_ARS_CAP: report address-range-scrubbing capabilities
    ND_CMD_ARS_START: initiate scrubbing
    ND_CMD_ARS_STATUS: report on scrubbing state
    ND_CMD_SMART_THRESHOLD: configure alarm thresholds for smart events

If a platform later defines different commands than this set it is
straightforward to extend support to those formats.

Most of the commands target a specific dimm.  However, the
address-range-scrubbing commands target the bus.  The 'commands'
attribute in sysfs of an nvdimm_bus, or nvdimm, enumerate the supported
commands for that object.

	Cc: <linux-acpi@vger.kernel.org>
	Cc: Robert Moore <robert.moore@intel.com>
	Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reported-by: Nicholas Moulin <nicholas.w.moulin@linux.intel.com>
	Acked-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 62232e45f4a265abb43f0acf16e58f5d0b6e1ec9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/Kconfig
#	drivers/acpi/nfit.c
#	drivers/acpi/nfit.h
#	drivers/nvdimm/bus.c
#	drivers/nvdimm/core.c
#	drivers/nvdimm/dimm_devs.c
#	drivers/nvdimm/nd-core.h
#	include/linux/libnvdimm.h
diff --cc drivers/acpi/Kconfig
index f8b18847c742,9c43ae301300..000000000000
--- a/drivers/acpi/Kconfig
+++ b/drivers/acpi/Kconfig
@@@ -377,6 -371,44 +377,47 @@@ config ACPI_BGR
  	  data from the firmware boot splash. It will appear under
  	  /sys/firmware/acpi/bgrt/ .
  
++<<<<<<< HEAD
++=======
+ config ACPI_REDUCED_HARDWARE_ONLY
+ 	bool "Hardware-reduced ACPI support only" if EXPERT
+ 	def_bool n
+ 	help
+ 	  This config item changes the way the ACPI code is built.  When this
+ 	  option is selected, the kernel will use a specialized version of
+ 	  ACPICA that ONLY supports the ACPI "reduced hardware" mode.  The
+ 	  resulting kernel will be smaller but it will also be restricted to
+ 	  running in ACPI reduced hardware mode ONLY.
+ 
+ 	  If you are unsure what to do, do not enable this option.
+ 
+ config ACPI_NFIT
+ 	tristate "ACPI NVDIMM Firmware Interface Table (NFIT)"
+ 	depends on PHYS_ADDR_T_64BIT
+ 	depends on BLK_DEV
+ 	select LIBNVDIMM
+ 	help
+ 	  Infrastructure to probe ACPI 6 compliant platforms for
+ 	  NVDIMMs (NFIT) and register a libnvdimm device tree.  In
+ 	  addition to storage devices this also enables libnvdimm to pass
+ 	  ACPI._DSM messages for platform/dimm configuration.
+ 
+ 	  To compile this driver as a module, choose M here:
+ 	  the module will be called nfit.
+ 
+ config ACPI_NFIT_DEBUG
+ 	bool "NFIT DSM debug"
+ 	depends on ACPI_NFIT
+ 	depends on DYNAMIC_DEBUG
+ 	default n
+ 	help
+ 	  Enabling this option causes the nfit driver to dump the
+ 	  input and output buffers of _DSM operations on the ACPI0012
+ 	  device and its children.  This can be very verbose, so leave
+ 	  it disabled unless you are debugging a hardware / firmware
+ 	  issue.
+ 
++>>>>>>> 62232e45f4a2 (libnvdimm: control (ioctl) messages for nvdimm_bus and nvdimm devices)
  source "drivers/acpi/apei/Kconfig"
  
  config ACPI_EXTLOG
* Unmerged path drivers/acpi/nfit.c
* Unmerged path drivers/acpi/nfit.h
* Unmerged path drivers/nvdimm/bus.c
* Unmerged path drivers/nvdimm/core.c
* Unmerged path drivers/nvdimm/dimm_devs.c
* Unmerged path drivers/nvdimm/nd-core.h
* Unmerged path include/linux/libnvdimm.h
* Unmerged path drivers/acpi/Kconfig
* Unmerged path drivers/acpi/nfit.c
* Unmerged path drivers/acpi/nfit.h
* Unmerged path drivers/nvdimm/bus.c
* Unmerged path drivers/nvdimm/core.c
* Unmerged path drivers/nvdimm/dimm_devs.c
* Unmerged path drivers/nvdimm/nd-core.h
* Unmerged path include/linux/libnvdimm.h
diff --git a/include/uapi/linux/Kbuild b/include/uapi/linux/Kbuild
index 354540920321..d5dcfb439e87 100644
--- a/include/uapi/linux/Kbuild
+++ b/include/uapi/linux/Kbuild
@@ -257,6 +257,7 @@ header-y += ncp.h
 header-y += ncp_fs.h
 header-y += ncp_mount.h
 header-y += ncp_no.h
+header-y += ndctl.h
 header-y += neighbour.h
 header-y += net.h
 header-y += net_dropmon.h
diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
new file mode 100644
index 000000000000..ff13c23b26df
--- /dev/null
+++ b/include/uapi/linux/ndctl.h
@@ -0,0 +1,178 @@
+/*
+ * Copyright (c) 2014-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU Lesser General Public License,
+ * version 2.1, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
+ * more details.
+ */
+#ifndef __NDCTL_H__
+#define __NDCTL_H__
+
+#include <linux/types.h>
+
+struct nd_cmd_smart {
+	__u32 status;
+	__u8 data[128];
+} __packed;
+
+struct nd_cmd_smart_threshold {
+	__u32 status;
+	__u8 data[8];
+} __packed;
+
+struct nd_cmd_dimm_flags {
+	__u32 status;
+	__u32 flags;
+} __packed;
+
+struct nd_cmd_get_config_size {
+	__u32 status;
+	__u32 config_size;
+	__u32 max_xfer;
+} __packed;
+
+struct nd_cmd_get_config_data_hdr {
+	__u32 in_offset;
+	__u32 in_length;
+	__u32 status;
+	__u8 out_buf[0];
+} __packed;
+
+struct nd_cmd_set_config_hdr {
+	__u32 in_offset;
+	__u32 in_length;
+	__u8 in_buf[0];
+} __packed;
+
+struct nd_cmd_vendor_hdr {
+	__u32 opcode;
+	__u32 in_length;
+	__u8 in_buf[0];
+} __packed;
+
+struct nd_cmd_vendor_tail {
+	__u32 status;
+	__u32 out_length;
+	__u8 out_buf[0];
+} __packed;
+
+struct nd_cmd_ars_cap {
+	__u64 address;
+	__u64 length;
+	__u32 status;
+	__u32 max_ars_out;
+} __packed;
+
+struct nd_cmd_ars_start {
+	__u64 address;
+	__u64 length;
+	__u16 type;
+	__u8 reserved[6];
+	__u32 status;
+} __packed;
+
+struct nd_cmd_ars_status {
+	__u32 status;
+	__u32 out_length;
+	__u64 address;
+	__u64 length;
+	__u16 type;
+	__u32 num_records;
+	struct nd_ars_record {
+		__u32 handle;
+		__u32 flags;
+		__u64 err_address;
+		__u64 mask;
+	} __packed records[0];
+} __packed;
+
+enum {
+	ND_CMD_IMPLEMENTED = 0,
+
+	/* bus commands */
+	ND_CMD_ARS_CAP = 1,
+	ND_CMD_ARS_START = 2,
+	ND_CMD_ARS_STATUS = 3,
+
+	/* per-dimm commands */
+	ND_CMD_SMART = 1,
+	ND_CMD_SMART_THRESHOLD = 2,
+	ND_CMD_DIMM_FLAGS = 3,
+	ND_CMD_GET_CONFIG_SIZE = 4,
+	ND_CMD_GET_CONFIG_DATA = 5,
+	ND_CMD_SET_CONFIG_DATA = 6,
+	ND_CMD_VENDOR_EFFECT_LOG_SIZE = 7,
+	ND_CMD_VENDOR_EFFECT_LOG = 8,
+	ND_CMD_VENDOR = 9,
+};
+
+static inline const char *nvdimm_bus_cmd_name(unsigned cmd)
+{
+	static const char * const names[] = {
+		[ND_CMD_ARS_CAP] = "ars_cap",
+		[ND_CMD_ARS_START] = "ars_start",
+		[ND_CMD_ARS_STATUS] = "ars_status",
+	};
+
+	if (cmd < ARRAY_SIZE(names) && names[cmd])
+		return names[cmd];
+	return "unknown";
+}
+
+static inline const char *nvdimm_cmd_name(unsigned cmd)
+{
+	static const char * const names[] = {
+		[ND_CMD_SMART] = "smart",
+		[ND_CMD_SMART_THRESHOLD] = "smart_thresh",
+		[ND_CMD_DIMM_FLAGS] = "flags",
+		[ND_CMD_GET_CONFIG_SIZE] = "get_size",
+		[ND_CMD_GET_CONFIG_DATA] = "get_data",
+		[ND_CMD_SET_CONFIG_DATA] = "set_data",
+		[ND_CMD_VENDOR_EFFECT_LOG_SIZE] = "effect_size",
+		[ND_CMD_VENDOR_EFFECT_LOG] = "effect_log",
+		[ND_CMD_VENDOR] = "vendor",
+	};
+
+	if (cmd < ARRAY_SIZE(names) && names[cmd])
+		return names[cmd];
+	return "unknown";
+}
+
+#define ND_IOCTL 'N'
+
+#define ND_IOCTL_SMART			_IOWR(ND_IOCTL, ND_CMD_SMART,\
+					struct nd_cmd_smart)
+
+#define ND_IOCTL_SMART_THRESHOLD	_IOWR(ND_IOCTL, ND_CMD_SMART_THRESHOLD,\
+					struct nd_cmd_smart_threshold)
+
+#define ND_IOCTL_DIMM_FLAGS		_IOWR(ND_IOCTL, ND_CMD_DIMM_FLAGS,\
+					struct nd_cmd_dimm_flags)
+
+#define ND_IOCTL_GET_CONFIG_SIZE	_IOWR(ND_IOCTL, ND_CMD_GET_CONFIG_SIZE,\
+					struct nd_cmd_get_config_size)
+
+#define ND_IOCTL_GET_CONFIG_DATA	_IOWR(ND_IOCTL, ND_CMD_GET_CONFIG_DATA,\
+					struct nd_cmd_get_config_data_hdr)
+
+#define ND_IOCTL_SET_CONFIG_DATA	_IOWR(ND_IOCTL, ND_CMD_SET_CONFIG_DATA,\
+					struct nd_cmd_set_config_hdr)
+
+#define ND_IOCTL_VENDOR			_IOWR(ND_IOCTL, ND_CMD_VENDOR,\
+					struct nd_cmd_vendor_hdr)
+
+#define ND_IOCTL_ARS_CAP		_IOWR(ND_IOCTL, ND_CMD_ARS_CAP,\
+					struct nd_cmd_ars_cap)
+
+#define ND_IOCTL_ARS_START		_IOWR(ND_IOCTL, ND_CMD_ARS_START,\
+					struct nd_cmd_ars_start)
+
+#define ND_IOCTL_ARS_STATUS		_IOWR(ND_IOCTL, ND_CMD_ARS_STATUS,\
+					struct nd_cmd_ars_status)
+
+#endif /* __NDCTL_H__ */
