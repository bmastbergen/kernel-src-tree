IB/core: Introduce new fast registration API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 4c67e2bfc8b7121d51434362fa7c2d012f8bcf1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4c67e2bf.failed

The new fast registration  verb ib_map_mr_sg receives a scatterlist
and converts it to a page list under the verbs API thus hiding
the specific HW mapping details away from the consumer.

The provider drivers are provided with a generic helper ib_sg_to_pages
that converts a scatterlist into a vector of page addresses. The
drivers can still perform any HW specific page address setting
by passing a set_page function pointer which will be invoked for
each page address. This allows drivers to avoid keeping a shadow
page vectors and convert them to HW specific translations by doing
extra copies.

This API will allow ULPs to remove the duplicated code of constructing
a page vector from a given sg list.

The send work request ib_reg_wr also shrinks as it will contain only
mr, key and access flags in addition.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Tested-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 4c67e2bfc8b7121d51434362fa7c2d012f8bcf1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/rdma/ib_verbs.h
diff --cc include/rdma/ib_verbs.h
index 64fb06bbe2fe,065d37c13aa6..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -1096,54 -1098,105 +1098,154 @@@ struct ib_send_wr 
  		__be32		imm_data;
  		u32		invalidate_rkey;
  	} ex;
 +	union {
 +		struct {
 +			u64	remote_addr;
 +			u32	rkey;
 +		} rdma;
 +		struct {
 +			u64	remote_addr;
 +			u64	compare_add;
 +			u64	swap;
 +			u64	compare_add_mask;
 +			u64	swap_mask;
 +			u32	rkey;
 +		} atomic;
 +		struct {
 +			struct ib_ah *ah;
 +			void   *header;
 +			int     hlen;
 +			int     mss;
 +			u32	remote_qpn;
 +			u32	remote_qkey;
 +			u16	pkey_index; /* valid for GSI only */
 +			u8	port_num;   /* valid for DR SMPs on switch only */
 +		} ud;
 +		struct {
 +			u64				iova_start;
 +			struct ib_fast_reg_page_list   *page_list;
 +			unsigned int			page_shift;
 +			unsigned int			page_list_len;
 +			u32				length;
 +			int				access_flags;
 +			u32				rkey;
 +		} fast_reg;
 +		struct {
 +			struct ib_mw            *mw;
 +			/* The new rkey for the memory window. */
 +			u32                      rkey;
 +			struct ib_mw_bind_info   bind_info;
 +		} bind_mw;
 +		struct {
 +			struct ib_sig_attrs    *sig_attrs;
 +			struct ib_mr	       *sig_mr;
 +			int			access_flags;
 +			struct ib_sge	       *prot;
 +		} sig_handover;
 +	} wr;
 +	u32			xrc_remote_srq_num;	/* XRC TGT QPs only */
  };
  
++<<<<<<< HEAD
++=======
+ struct ib_rdma_wr {
+ 	struct ib_send_wr	wr;
+ 	u64			remote_addr;
+ 	u32			rkey;
+ };
+ 
+ static inline struct ib_rdma_wr *rdma_wr(struct ib_send_wr *wr)
+ {
+ 	return container_of(wr, struct ib_rdma_wr, wr);
+ }
+ 
+ struct ib_atomic_wr {
+ 	struct ib_send_wr	wr;
+ 	u64			remote_addr;
+ 	u64			compare_add;
+ 	u64			swap;
+ 	u64			compare_add_mask;
+ 	u64			swap_mask;
+ 	u32			rkey;
+ };
+ 
+ static inline struct ib_atomic_wr *atomic_wr(struct ib_send_wr *wr)
+ {
+ 	return container_of(wr, struct ib_atomic_wr, wr);
+ }
+ 
+ struct ib_ud_wr {
+ 	struct ib_send_wr	wr;
+ 	struct ib_ah		*ah;
+ 	void			*header;
+ 	int			hlen;
+ 	int			mss;
+ 	u32			remote_qpn;
+ 	u32			remote_qkey;
+ 	u16			pkey_index; /* valid for GSI only */
+ 	u8			port_num;   /* valid for DR SMPs on switch only */
+ };
+ 
+ static inline struct ib_ud_wr *ud_wr(struct ib_send_wr *wr)
+ {
+ 	return container_of(wr, struct ib_ud_wr, wr);
+ }
+ 
+ struct ib_fast_reg_wr {
+ 	struct ib_send_wr	wr;
+ 	u64			iova_start;
+ 	struct ib_fast_reg_page_list *page_list;
+ 	unsigned int		page_shift;
+ 	unsigned int		page_list_len;
+ 	u32			length;
+ 	int			access_flags;
+ 	u32			rkey;
+ };
+ 
+ static inline struct ib_fast_reg_wr *fast_reg_wr(struct ib_send_wr *wr)
+ {
+ 	return container_of(wr, struct ib_fast_reg_wr, wr);
+ }
+ 
+ struct ib_reg_wr {
+ 	struct ib_send_wr	wr;
+ 	struct ib_mr		*mr;
+ 	u32			key;
+ 	int			access;
+ };
+ 
+ static inline struct ib_reg_wr *reg_wr(struct ib_send_wr *wr)
+ {
+ 	return container_of(wr, struct ib_reg_wr, wr);
+ }
+ 
+ struct ib_bind_mw_wr {
+ 	struct ib_send_wr	wr;
+ 	struct ib_mw		*mw;
+ 	/* The new rkey for the memory window. */
+ 	u32			rkey;
+ 	struct ib_mw_bind_info	bind_info;
+ };
+ 
+ static inline struct ib_bind_mw_wr *bind_mw_wr(struct ib_send_wr *wr)
+ {
+ 	return container_of(wr, struct ib_bind_mw_wr, wr);
+ }
+ 
+ struct ib_sig_handover_wr {
+ 	struct ib_send_wr	wr;
+ 	struct ib_sig_attrs    *sig_attrs;
+ 	struct ib_mr	       *sig_mr;
+ 	int			access_flags;
+ 	struct ib_sge	       *prot;
+ };
+ 
+ static inline struct ib_sig_handover_wr *sig_handover_wr(struct ib_send_wr *wr)
+ {
+ 	return container_of(wr, struct ib_sig_handover_wr, wr);
+ }
+ 
++>>>>>>> 4c67e2bfc8b7 (IB/core: Introduce new fast registration API)
  struct ib_recv_wr {
  	struct ib_recv_wr      *next;
  	u64			wr_id;
diff --git a/drivers/infiniband/core/verbs.c b/drivers/infiniband/core/verbs.c
index e1f2c9887f3f..9a4e34bc5ff3 100644
--- a/drivers/infiniband/core/verbs.c
+++ b/drivers/infiniband/core/verbs.c
@@ -1469,3 +1469,110 @@ int ib_check_mr_status(struct ib_mr *mr, u32 check_mask,
 		mr->device->check_mr_status(mr, check_mask, mr_status) : -ENOSYS;
 }
 EXPORT_SYMBOL(ib_check_mr_status);
+
+/**
+ * ib_map_mr_sg() - Map the largest prefix of a dma mapped SG list
+ *     and set it the memory region.
+ * @mr:            memory region
+ * @sg:            dma mapped scatterlist
+ * @sg_nents:      number of entries in sg
+ * @page_size:     page vector desired page size
+ *
+ * Constraints:
+ * - The first sg element is allowed to have an offset.
+ * - Each sg element must be aligned to page_size (or physically
+ *   contiguous to the previous element). In case an sg element has a
+ *   non contiguous offset, the mapping prefix will not include it.
+ * - The last sg element is allowed to have length less than page_size.
+ * - If sg_nents total byte length exceeds the mr max_num_sge * page_size
+ *   then only max_num_sg entries will be mapped.
+ *
+ * Returns the number of sg elements that were mapped to the memory region.
+ *
+ * After this completes successfully, the  memory region
+ * is ready for registration.
+ */
+int ib_map_mr_sg(struct ib_mr *mr,
+		 struct scatterlist *sg,
+		 int sg_nents,
+		 unsigned int page_size)
+{
+	if (unlikely(!mr->device->map_mr_sg))
+		return -ENOSYS;
+
+	mr->page_size = page_size;
+
+	return mr->device->map_mr_sg(mr, sg, sg_nents);
+}
+EXPORT_SYMBOL(ib_map_mr_sg);
+
+/**
+ * ib_sg_to_pages() - Convert the largest prefix of a sg list
+ *     to a page vector
+ * @mr:            memory region
+ * @sgl:           dma mapped scatterlist
+ * @sg_nents:      number of entries in sg
+ * @set_page:      driver page assignment function pointer
+ *
+ * Core service helper for drivers to covert the largest
+ * prefix of given sg list to a page vector. The sg list
+ * prefix converted is the prefix that meet the requirements
+ * of ib_map_mr_sg.
+ *
+ * Returns the number of sg elements that were assigned to
+ * a page vector.
+ */
+int ib_sg_to_pages(struct ib_mr *mr,
+		   struct scatterlist *sgl,
+		   int sg_nents,
+		   int (*set_page)(struct ib_mr *, u64))
+{
+	struct scatterlist *sg;
+	u64 last_end_dma_addr = 0, last_page_addr = 0;
+	unsigned int last_page_off = 0;
+	u64 page_mask = ~((u64)mr->page_size - 1);
+	int i;
+
+	mr->iova = sg_dma_address(&sgl[0]);
+	mr->length = 0;
+
+	for_each_sg(sgl, sg, sg_nents, i) {
+		u64 dma_addr = sg_dma_address(sg);
+		unsigned int dma_len = sg_dma_len(sg);
+		u64 end_dma_addr = dma_addr + dma_len;
+		u64 page_addr = dma_addr & page_mask;
+
+		if (i && page_addr != dma_addr) {
+			if (last_end_dma_addr != dma_addr) {
+				/* gap */
+				goto done;
+
+			} else if (last_page_off + dma_len <= mr->page_size) {
+				/* chunk this fragment with the last */
+				mr->length += dma_len;
+				last_end_dma_addr += dma_len;
+				last_page_off += dma_len;
+				continue;
+			} else {
+				/* map starting from the next page */
+				page_addr = last_page_addr + mr->page_size;
+				dma_len -= mr->page_size - last_page_off;
+			}
+		}
+
+		do {
+			if (unlikely(set_page(mr, page_addr)))
+				goto done;
+			page_addr += mr->page_size;
+		} while (page_addr < end_dma_addr);
+
+		mr->length += dma_len;
+		last_end_dma_addr = end_dma_addr;
+		last_page_addr = end_dma_addr & page_mask;
+		last_page_off = end_dma_addr & ~page_mask;
+	}
+
+done:
+	return i;
+}
+EXPORT_SYMBOL(ib_sg_to_pages);
* Unmerged path include/rdma/ib_verbs.h
