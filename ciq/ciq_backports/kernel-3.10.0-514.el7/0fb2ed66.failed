IB/mlx5: Add create and destroy functionality for Raw Packet QP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author majd@mellanox.com <majd@mellanox.com>
commit 0fb2ed66a14c8c34096d6a8cff5112356c5e9ea2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0fb2ed66.failed

This patch adds support for Raw Packet QP for the mlx5 device.

Raw Packet QP, unlike other QP types, has no matching mlx5_core_qp
object but rather it is built of RQ/SQ/TIR/TIS/TD mlx5_core object.

Since the SQ and RQ work-queue (WQ) buffers are not contiguous like
other QPs, we allocate separate buffers in the user-space and pass
the address of each one of them separately to the kernel.

	Signed-off-by: Majd Dibbiny <majd@mellanox.com>
	Reviewed-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 0fb2ed66a14c8c34096d6a8cff5112356c5e9ea2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/mlx5_ib.h
#	drivers/infiniband/hw/mlx5/qp.c
diff --cc drivers/infiniband/hw/mlx5/mlx5_ib.h
index effe0e13bf9e,726e31de59d5..000000000000
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@@ -221,21 -191,55 +221,50 @@@ struct mlx5_ib_pfault 
  	struct mlx5_pagefault	mpfault;
  };
  
 -struct mlx5_ib_ubuffer {
 -	struct ib_umem	       *umem;
 -	int			buf_size;
 -	u64			buf_addr;
 -};
 -
 -struct mlx5_ib_qp_base {
 -	struct mlx5_ib_qp	*container_mibqp;
 -	struct mlx5_core_qp	mqp;
 -	struct mlx5_ib_ubuffer	ubuffer;
 +struct mlx5_ib_rq {
 +	u32			tirn;
  };
  
 -struct mlx5_ib_qp_trans {
 -	struct mlx5_ib_qp_base	base;
 -	u16			xrcdn;
 -	u8			alt_port;
 -	u8			atomic_rd_en;
 -	u8			resp_depth;
 +struct mlx5_ib_raw_packet_qp {
 +	struct mlx5_ib_rq rq;
  };
  
+ struct mlx5_ib_rq {
+ 	struct mlx5_ib_qp_base base;
+ 	struct mlx5_ib_wq	*rq;
+ 	struct mlx5_ib_ubuffer	ubuffer;
+ 	struct mlx5_db		*doorbell;
+ 	u32			tirn;
+ 	u8			state;
+ };
+ 
+ struct mlx5_ib_sq {
+ 	struct mlx5_ib_qp_base base;
+ 	struct mlx5_ib_wq	*sq;
+ 	struct mlx5_ib_ubuffer  ubuffer;
+ 	struct mlx5_db		*doorbell;
+ 	u32			tisn;
+ 	u8			state;
+ };
+ 
+ struct mlx5_ib_raw_packet_qp {
+ 	struct mlx5_ib_sq sq;
+ 	struct mlx5_ib_rq rq;
+ };
+ 
  struct mlx5_ib_qp {
  	struct ib_qp		ibqp;
  	union {
++<<<<<<< HEAD
 +		struct mlx5_core_qp		mqp;
 +		struct mlx5_ib_raw_packet_qp	raw_packet_qp;
 +	};
 +
++=======
+ 		struct mlx5_ib_qp_trans trans_qp;
+ 		struct mlx5_ib_raw_packet_qp raw_packet_qp;
+ 	};
++>>>>>>> 0fb2ed66a14c (IB/mlx5: Add create and destroy functionality for Raw Packet QP)
  	struct mlx5_buf		buf;
  
  	struct mlx5_db		db;
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 7668f22f6661,89f05bff0485..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -369,7 -371,9 +369,13 @@@ static int calc_sq_size(struct mlx5_ib_
  
  static int set_user_buf_size(struct mlx5_ib_dev *dev,
  			    struct mlx5_ib_qp *qp,
++<<<<<<< HEAD
 +			    struct mlx5_ib_create_qp *ucmd)
++=======
+ 			    struct mlx5_ib_create_qp *ucmd,
+ 			    struct mlx5_ib_qp_base *base,
+ 			    struct ib_qp_init_attr *attr)
++>>>>>>> 0fb2ed66a14c (IB/mlx5: Add create and destroy functionality for Raw Packet QP)
  {
  	int desc_sz = 1 << qp->sq.wqe_shift;
  
@@@ -394,8 -398,13 +400,18 @@@
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	qp->buf_size = (qp->rq.wqe_cnt << qp->rq.wqe_shift) +
 +		(qp->sq.wqe_cnt << 6);
++=======
+ 	if (attr->qp_type == IB_QPT_RAW_PACKET) {
+ 		base->ubuffer.buf_size = qp->rq.wqe_cnt << qp->rq.wqe_shift;
+ 		qp->raw_packet_qp.sq.ubuffer.buf_size = qp->sq.wqe_cnt << 6;
+ 	} else {
+ 		base->ubuffer.buf_size = (qp->rq.wqe_cnt << qp->rq.wqe_shift) +
+ 					 (qp->sq.wqe_cnt << 6);
+ 	}
++>>>>>>> 0fb2ed66a14c (IB/mlx5: Add create and destroy functionality for Raw Packet QP)
  
  	return 0;
  }
@@@ -593,10 -602,47 +609,11 @@@ static int uuarn_to_uar_index(struct ml
  	return uuari->uars[uuarn / MLX5_BF_REGS_PER_PAGE].index;
  }
  
 -static int mlx5_ib_umem_get(struct mlx5_ib_dev *dev,
 -			    struct ib_pd *pd,
 -			    unsigned long addr, size_t size,
 -			    struct ib_umem **umem,
 -			    int *npages, int *page_shift, int *ncont,
 -			    u32 *offset)
 -{
 -	int err;
 -
 -	*umem = ib_umem_get(pd->uobject->context, addr, size, 0, 0);
 -	if (IS_ERR(*umem)) {
 -		mlx5_ib_dbg(dev, "umem_get failed\n");
 -		return PTR_ERR(*umem);
 -	}
 -
 -	mlx5_ib_cont_pages(*umem, addr, npages, page_shift, ncont, NULL);
 -
 -	err = mlx5_ib_get_buf_offset(addr, *page_shift, offset);
 -	if (err) {
 -		mlx5_ib_warn(dev, "bad offset\n");
 -		goto err_umem;
 -	}
 -
 -	mlx5_ib_dbg(dev, "addr 0x%lx, size %zu, npages %d, page_shift %d, ncont %d, offset %d\n",
 -		    addr, size, *npages, *page_shift, *ncont, *offset);
 -
 -	return 0;
 -
 -err_umem:
 -	ib_umem_release(*umem);
 -	*umem = NULL;
 -
 -	return err;
 -}
 -
  static int create_user_qp(struct mlx5_ib_dev *dev, struct ib_pd *pd,
  			  struct mlx5_ib_qp *qp, struct ib_udata *udata,
+ 			  struct ib_qp_init_attr *attr,
  			  struct mlx5_create_qp_mbox_in **in,
 -			  struct mlx5_ib_create_qp_resp *resp, int *inlen,
 -			  struct mlx5_ib_qp_base *base)
 +			  struct mlx5_ib_create_qp_resp *resp, int *inlen)
  {
  	struct mlx5_ib_ucontext *context;
  	struct mlx5_ib_create_qp ucmd;
@@@ -646,7 -693,7 +663,11 @@@
  	qp->sq.wqe_shift = ilog2(MLX5_SEND_WQE_BB);
  	qp->sq.offset = qp->rq.wqe_cnt << qp->rq.wqe_shift;
  
++<<<<<<< HEAD
 +	err = set_user_buf_size(dev, qp, &ucmd);
++=======
+ 	err = set_user_buf_size(dev, qp, &ucmd, base, attr);
++>>>>>>> 0fb2ed66a14c (IB/mlx5: Add create and destroy functionality for Raw Packet QP)
  	if (err)
  		goto err_uuar;
  
@@@ -867,6 -1182,7 +1165,10 @@@ static int create_qp_common(struct mlx5
  {
  	struct mlx5_ib_resources *devr = &dev->devr;
  	struct mlx5_core_dev *mdev = dev->mdev;
++<<<<<<< HEAD
++=======
+ 	struct mlx5_ib_qp_base *base;
++>>>>>>> 0fb2ed66a14c (IB/mlx5: Add create and destroy functionality for Raw Packet QP)
  	struct mlx5_ib_create_qp_resp resp;
  	struct mlx5_create_qp_mbox_in *in;
  	struct mlx5_ib_create_qp ucmd;
@@@ -948,7 -1269,8 +1255,12 @@@
  					    ucmd.sq_wqe_count, max_wqes);
  				return -EINVAL;
  			}
++<<<<<<< HEAD
 +			err = create_user_qp(dev, pd, qp, udata, &in, &resp, &inlen);
++=======
+ 			err = create_user_qp(dev, pd, qp, udata, init_attr, &in,
+ 					     &resp, &inlen, base);
++>>>>>>> 0fb2ed66a14c (IB/mlx5: Add create and destroy functionality for Raw Packet QP)
  			if (err)
  				mlx5_ib_dbg(dev, "err %d\n", err);
  		} else {
@@@ -1061,7 -1384,14 +1373,18 @@@
  		MLX5_SET(qpc, qpc, user_index, uidx);
  	}
  
++<<<<<<< HEAD
 +	err = mlx5_core_create_qp(dev->mdev, &qp->mqp, in, inlen);
++=======
+ 	if (init_attr->qp_type == IB_QPT_RAW_PACKET) {
+ 		qp->raw_packet_qp.sq.ubuffer.buf_addr = ucmd.sq_buf_addr;
+ 		raw_packet_qp_copy_info(qp, &qp->raw_packet_qp);
+ 		err = create_raw_packet_qp(dev, qp, in, pd);
+ 	} else {
+ 		err = mlx5_core_create_qp(dev->mdev, &base->mqp, in, inlen);
+ 	}
+ 
++>>>>>>> 0fb2ed66a14c (IB/mlx5: Add create and destroy functionality for Raw Packet QP)
  	if (err) {
  		mlx5_ib_dbg(dev, "create qp failed\n");
  		goto err_create;
@@@ -1188,6 -1514,7 +1511,10 @@@ static void get_cqs(struct mlx5_ib_qp *
  static void destroy_qp_common(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp)
  {
  	struct mlx5_ib_cq *send_cq, *recv_cq;
++<<<<<<< HEAD
++=======
+ 	struct mlx5_ib_qp_base *base = &qp->trans_qp.base;
++>>>>>>> 0fb2ed66a14c (IB/mlx5: Add create and destroy functionality for Raw Packet QP)
  	struct mlx5_modify_qp_mbox_in *in;
  	int err;
  
@@@ -1214,11 -1547,16 +1545,23 @@@
  		mlx5_ib_unlock_cqs(send_cq, recv_cq);
  	}
  
++<<<<<<< HEAD
 +	err = mlx5_core_destroy_qp(dev->mdev, &qp->mqp);
 +	if (err)
 +		mlx5_ib_warn(dev, "failed to destroy QP 0x%x\n", qp->mqp.qpn);
 +	kfree(in);
++=======
+ 	if (qp->ibqp.qp_type == IB_QPT_RAW_PACKET) {
+ 		destroy_raw_packet_qp(dev, qp);
+ 	} else {
+ 		err = mlx5_core_destroy_qp(dev->mdev, &base->mqp);
+ 		if (err)
+ 			mlx5_ib_warn(dev, "failed to destroy QP 0x%x\n",
+ 				     base->mqp.qpn);
+ 	}
++>>>>>>> 0fb2ed66a14c (IB/mlx5: Add create and destroy functionality for Raw Packet QP)
  
+ 	kfree(in);
  
  	if (qp->create_type == MLX5_QP_KERNEL)
  		destroy_qp_kernel(dev, qp);
* Unmerged path drivers/infiniband/hw/mlx5/mlx5_ib.h
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
diff --git a/drivers/infiniband/hw/mlx5/user.h b/drivers/infiniband/hw/mlx5/user.h
index 41f0525e825c..b94a55404a59 100644
--- a/drivers/infiniband/hw/mlx5/user.h
+++ b/drivers/infiniband/hw/mlx5/user.h
@@ -145,6 +145,7 @@ struct mlx5_ib_create_qp {
 	__u32	flags;
 	__u32	uidx;
 	__u32	reserved0;
+	__u64	sq_buf_addr;
 };
 
 struct mlx5_ib_create_qp_resp {
