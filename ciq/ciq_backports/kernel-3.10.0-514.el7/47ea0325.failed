drivers/net: get rid of unnecessary initializations in .get_drvinfo()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [netdrv] e1000e: get rid of unnecessary initializations in .get_drvinfo() (Jarod Wilson) [1274171]
Rebuild_FUZZ: 90.23%
commit-author Ivan Vecera <ivecera@redhat.com>
commit 47ea0325337b166c1c8695119aa6e83cdc035ef5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/47ea0325.failed

Many drivers initialize uselessly n_priv_flags, n_stats, testinfo_len,
eedump_len & regdump_len fields in their .get_drvinfo() ethtool op.
It's not necessary as these fields is filled in ethtool_get_drvinfo().

v2: removed unused variable
v3: removed another unused variable

	Signed-off-by: Ivan Vecera <ivecera@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 47ea0325337b166c1c8695119aa6e83cdc035ef5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
#	drivers/net/ethernet/broadcom/bcm63xx_enet.c
#	drivers/net/ethernet/broadcom/bcmsysport.c
#	drivers/net/ethernet/broadcom/genet/bcmgenet.c
#	drivers/net/ethernet/cavium/liquidio/lio_ethtool.c
#	drivers/net/ethernet/hisilicon/hns/hns_ethtool.c
#	drivers/net/ethernet/ti/tlan.c
diff --cc drivers/net/ethernet/broadcom/bcm63xx_enet.c
index 1f7233bbb0e3,95af75d35bc5..000000000000
--- a/drivers/net/ethernet/broadcom/bcm63xx_enet.c
+++ b/drivers/net/ethernet/broadcom/bcm63xx_enet.c
@@@ -1862,8 -1985,863 +1861,866 @@@ struct platform_driver bcm63xx_enet_dri
  };
  
  /*
 - * switch mii access callbacks
 + * reserve & remap memory space shared between all macs
   */
++<<<<<<< HEAD
++=======
+ static int bcmenet_sw_mdio_read(struct bcm_enet_priv *priv,
+ 				int ext, int phy_id, int location)
+ {
+ 	u32 reg;
+ 	int ret;
+ 
+ 	spin_lock_bh(&priv->enetsw_mdio_lock);
+ 	enetsw_writel(priv, 0, ENETSW_MDIOC_REG);
+ 
+ 	reg = ENETSW_MDIOC_RD_MASK |
+ 		(phy_id << ENETSW_MDIOC_PHYID_SHIFT) |
+ 		(location << ENETSW_MDIOC_REG_SHIFT);
+ 
+ 	if (ext)
+ 		reg |= ENETSW_MDIOC_EXT_MASK;
+ 
+ 	enetsw_writel(priv, reg, ENETSW_MDIOC_REG);
+ 	udelay(50);
+ 	ret = enetsw_readw(priv, ENETSW_MDIOD_REG);
+ 	spin_unlock_bh(&priv->enetsw_mdio_lock);
+ 	return ret;
+ }
+ 
+ static void bcmenet_sw_mdio_write(struct bcm_enet_priv *priv,
+ 				 int ext, int phy_id, int location,
+ 				 uint16_t data)
+ {
+ 	u32 reg;
+ 
+ 	spin_lock_bh(&priv->enetsw_mdio_lock);
+ 	enetsw_writel(priv, 0, ENETSW_MDIOC_REG);
+ 
+ 	reg = ENETSW_MDIOC_WR_MASK |
+ 		(phy_id << ENETSW_MDIOC_PHYID_SHIFT) |
+ 		(location << ENETSW_MDIOC_REG_SHIFT);
+ 
+ 	if (ext)
+ 		reg |= ENETSW_MDIOC_EXT_MASK;
+ 
+ 	reg |= data;
+ 
+ 	enetsw_writel(priv, reg, ENETSW_MDIOC_REG);
+ 	udelay(50);
+ 	spin_unlock_bh(&priv->enetsw_mdio_lock);
+ }
+ 
+ static inline int bcm_enet_port_is_rgmii(int portid)
+ {
+ 	return portid >= ENETSW_RGMII_PORT0;
+ }
+ 
+ /*
+  * enet sw PHY polling
+  */
+ static void swphy_poll_timer(unsigned long data)
+ {
+ 	struct bcm_enet_priv *priv = (struct bcm_enet_priv *)data;
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < priv->num_ports; i++) {
+ 		struct bcm63xx_enetsw_port *port;
+ 		int val, j, up, advertise, lpa, lpa2, speed, duplex, media;
+ 		int external_phy = bcm_enet_port_is_rgmii(i);
+ 		u8 override;
+ 
+ 		port = &priv->used_ports[i];
+ 		if (!port->used)
+ 			continue;
+ 
+ 		if (port->bypass_link)
+ 			continue;
+ 
+ 		/* dummy read to clear */
+ 		for (j = 0; j < 2; j++)
+ 			val = bcmenet_sw_mdio_read(priv, external_phy,
+ 						   port->phy_id, MII_BMSR);
+ 
+ 		if (val == 0xffff)
+ 			continue;
+ 
+ 		up = (val & BMSR_LSTATUS) ? 1 : 0;
+ 		if (!(up ^ priv->sw_port_link[i]))
+ 			continue;
+ 
+ 		priv->sw_port_link[i] = up;
+ 
+ 		/* link changed */
+ 		if (!up) {
+ 			dev_info(&priv->pdev->dev, "link DOWN on %s\n",
+ 				 port->name);
+ 			enetsw_writeb(priv, ENETSW_PORTOV_ENABLE_MASK,
+ 				      ENETSW_PORTOV_REG(i));
+ 			enetsw_writeb(priv, ENETSW_PTCTRL_RXDIS_MASK |
+ 				      ENETSW_PTCTRL_TXDIS_MASK,
+ 				      ENETSW_PTCTRL_REG(i));
+ 			continue;
+ 		}
+ 
+ 		advertise = bcmenet_sw_mdio_read(priv, external_phy,
+ 						 port->phy_id, MII_ADVERTISE);
+ 
+ 		lpa = bcmenet_sw_mdio_read(priv, external_phy, port->phy_id,
+ 					   MII_LPA);
+ 
+ 		lpa2 = bcmenet_sw_mdio_read(priv, external_phy, port->phy_id,
+ 					    MII_STAT1000);
+ 
+ 		/* figure out media and duplex from advertise and LPA values */
+ 		media = mii_nway_result(lpa & advertise);
+ 		duplex = (media & ADVERTISE_FULL) ? 1 : 0;
+ 		if (lpa2 & LPA_1000FULL)
+ 			duplex = 1;
+ 
+ 		if (lpa2 & (LPA_1000FULL | LPA_1000HALF))
+ 			speed = 1000;
+ 		else {
+ 			if (media & (ADVERTISE_100FULL | ADVERTISE_100HALF))
+ 				speed = 100;
+ 			else
+ 				speed = 10;
+ 		}
+ 
+ 		dev_info(&priv->pdev->dev,
+ 			 "link UP on %s, %dMbps, %s-duplex\n",
+ 			 port->name, speed, duplex ? "full" : "half");
+ 
+ 		override = ENETSW_PORTOV_ENABLE_MASK |
+ 			ENETSW_PORTOV_LINKUP_MASK;
+ 
+ 		if (speed == 1000)
+ 			override |= ENETSW_IMPOV_1000_MASK;
+ 		else if (speed == 100)
+ 			override |= ENETSW_IMPOV_100_MASK;
+ 		if (duplex)
+ 			override |= ENETSW_IMPOV_FDX_MASK;
+ 
+ 		enetsw_writeb(priv, override, ENETSW_PORTOV_REG(i));
+ 		enetsw_writeb(priv, 0, ENETSW_PTCTRL_REG(i));
+ 	}
+ 
+ 	priv->swphy_poll.expires = jiffies + HZ;
+ 	add_timer(&priv->swphy_poll);
+ }
+ 
+ /*
+  * open callback, allocate dma rings & buffers and start rx operation
+  */
+ static int bcm_enetsw_open(struct net_device *dev)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	struct device *kdev;
+ 	int i, ret;
+ 	unsigned int size;
+ 	void *p;
+ 	u32 val;
+ 
+ 	priv = netdev_priv(dev);
+ 	kdev = &priv->pdev->dev;
+ 
+ 	/* mask all interrupts and request them */
+ 	enet_dmac_writel(priv, 0, ENETDMAC_IRMASK, priv->rx_chan);
+ 	enet_dmac_writel(priv, 0, ENETDMAC_IRMASK, priv->tx_chan);
+ 
+ 	ret = request_irq(priv->irq_rx, bcm_enet_isr_dma,
+ 			  0, dev->name, dev);
+ 	if (ret)
+ 		goto out_freeirq;
+ 
+ 	if (priv->irq_tx != -1) {
+ 		ret = request_irq(priv->irq_tx, bcm_enet_isr_dma,
+ 				  0, dev->name, dev);
+ 		if (ret)
+ 			goto out_freeirq_rx;
+ 	}
+ 
+ 	/* allocate rx dma ring */
+ 	size = priv->rx_ring_size * sizeof(struct bcm_enet_desc);
+ 	p = dma_alloc_coherent(kdev, size, &priv->rx_desc_dma, GFP_KERNEL);
+ 	if (!p) {
+ 		dev_err(kdev, "cannot allocate rx ring %u\n", size);
+ 		ret = -ENOMEM;
+ 		goto out_freeirq_tx;
+ 	}
+ 
+ 	memset(p, 0, size);
+ 	priv->rx_desc_alloc_size = size;
+ 	priv->rx_desc_cpu = p;
+ 
+ 	/* allocate tx dma ring */
+ 	size = priv->tx_ring_size * sizeof(struct bcm_enet_desc);
+ 	p = dma_alloc_coherent(kdev, size, &priv->tx_desc_dma, GFP_KERNEL);
+ 	if (!p) {
+ 		dev_err(kdev, "cannot allocate tx ring\n");
+ 		ret = -ENOMEM;
+ 		goto out_free_rx_ring;
+ 	}
+ 
+ 	memset(p, 0, size);
+ 	priv->tx_desc_alloc_size = size;
+ 	priv->tx_desc_cpu = p;
+ 
+ 	priv->tx_skb = kzalloc(sizeof(struct sk_buff *) * priv->tx_ring_size,
+ 			       GFP_KERNEL);
+ 	if (!priv->tx_skb) {
+ 		dev_err(kdev, "cannot allocate rx skb queue\n");
+ 		ret = -ENOMEM;
+ 		goto out_free_tx_ring;
+ 	}
+ 
+ 	priv->tx_desc_count = priv->tx_ring_size;
+ 	priv->tx_dirty_desc = 0;
+ 	priv->tx_curr_desc = 0;
+ 	spin_lock_init(&priv->tx_lock);
+ 
+ 	/* init & fill rx ring with skbs */
+ 	priv->rx_skb = kzalloc(sizeof(struct sk_buff *) * priv->rx_ring_size,
+ 			       GFP_KERNEL);
+ 	if (!priv->rx_skb) {
+ 		dev_err(kdev, "cannot allocate rx skb queue\n");
+ 		ret = -ENOMEM;
+ 		goto out_free_tx_skb;
+ 	}
+ 
+ 	priv->rx_desc_count = 0;
+ 	priv->rx_dirty_desc = 0;
+ 	priv->rx_curr_desc = 0;
+ 
+ 	/* disable all ports */
+ 	for (i = 0; i < priv->num_ports; i++) {
+ 		enetsw_writeb(priv, ENETSW_PORTOV_ENABLE_MASK,
+ 			      ENETSW_PORTOV_REG(i));
+ 		enetsw_writeb(priv, ENETSW_PTCTRL_RXDIS_MASK |
+ 			      ENETSW_PTCTRL_TXDIS_MASK,
+ 			      ENETSW_PTCTRL_REG(i));
+ 
+ 		priv->sw_port_link[i] = 0;
+ 	}
+ 
+ 	/* reset mib */
+ 	val = enetsw_readb(priv, ENETSW_GMCR_REG);
+ 	val |= ENETSW_GMCR_RST_MIB_MASK;
+ 	enetsw_writeb(priv, val, ENETSW_GMCR_REG);
+ 	mdelay(1);
+ 	val &= ~ENETSW_GMCR_RST_MIB_MASK;
+ 	enetsw_writeb(priv, val, ENETSW_GMCR_REG);
+ 	mdelay(1);
+ 
+ 	/* force CPU port state */
+ 	val = enetsw_readb(priv, ENETSW_IMPOV_REG);
+ 	val |= ENETSW_IMPOV_FORCE_MASK | ENETSW_IMPOV_LINKUP_MASK;
+ 	enetsw_writeb(priv, val, ENETSW_IMPOV_REG);
+ 
+ 	/* enable switch forward engine */
+ 	val = enetsw_readb(priv, ENETSW_SWMODE_REG);
+ 	val |= ENETSW_SWMODE_FWD_EN_MASK;
+ 	enetsw_writeb(priv, val, ENETSW_SWMODE_REG);
+ 
+ 	/* enable jumbo on all ports */
+ 	enetsw_writel(priv, 0x1ff, ENETSW_JMBCTL_PORT_REG);
+ 	enetsw_writew(priv, 9728, ENETSW_JMBCTL_MAXSIZE_REG);
+ 
+ 	/* initialize flow control buffer allocation */
+ 	enet_dma_writel(priv, ENETDMA_BUFALLOC_FORCE_MASK | 0,
+ 			ENETDMA_BUFALLOC_REG(priv->rx_chan));
+ 
+ 	if (bcm_enet_refill_rx(dev)) {
+ 		dev_err(kdev, "cannot allocate rx skb queue\n");
+ 		ret = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	/* write rx & tx ring addresses */
+ 	enet_dmas_writel(priv, priv->rx_desc_dma,
+ 			 ENETDMAS_RSTART_REG, priv->rx_chan);
+ 	enet_dmas_writel(priv, priv->tx_desc_dma,
+ 			 ENETDMAS_RSTART_REG, priv->tx_chan);
+ 
+ 	/* clear remaining state ram for rx & tx channel */
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM2_REG, priv->rx_chan);
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM2_REG, priv->tx_chan);
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM3_REG, priv->rx_chan);
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM3_REG, priv->tx_chan);
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM4_REG, priv->rx_chan);
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM4_REG, priv->tx_chan);
+ 
+ 	/* set dma maximum burst len */
+ 	enet_dmac_writel(priv, priv->dma_maxburst,
+ 			 ENETDMAC_MAXBURST, priv->rx_chan);
+ 	enet_dmac_writel(priv, priv->dma_maxburst,
+ 			 ENETDMAC_MAXBURST, priv->tx_chan);
+ 
+ 	/* set flow control low/high threshold to 1/3 / 2/3 */
+ 	val = priv->rx_ring_size / 3;
+ 	enet_dma_writel(priv, val, ENETDMA_FLOWCL_REG(priv->rx_chan));
+ 	val = (priv->rx_ring_size * 2) / 3;
+ 	enet_dma_writel(priv, val, ENETDMA_FLOWCH_REG(priv->rx_chan));
+ 
+ 	/* all set, enable mac and interrupts, start dma engine and
+ 	 * kick rx dma channel
+ 	 */
+ 	wmb();
+ 	enet_dma_writel(priv, ENETDMA_CFG_EN_MASK, ENETDMA_CFG_REG);
+ 	enet_dmac_writel(priv, ENETDMAC_CHANCFG_EN_MASK,
+ 			 ENETDMAC_CHANCFG, priv->rx_chan);
+ 
+ 	/* watch "packet transferred" interrupt in rx and tx */
+ 	enet_dmac_writel(priv, ENETDMAC_IR_PKTDONE_MASK,
+ 			 ENETDMAC_IR, priv->rx_chan);
+ 	enet_dmac_writel(priv, ENETDMAC_IR_PKTDONE_MASK,
+ 			 ENETDMAC_IR, priv->tx_chan);
+ 
+ 	/* make sure we enable napi before rx interrupt  */
+ 	napi_enable(&priv->napi);
+ 
+ 	enet_dmac_writel(priv, ENETDMAC_IR_PKTDONE_MASK,
+ 			 ENETDMAC_IRMASK, priv->rx_chan);
+ 	enet_dmac_writel(priv, ENETDMAC_IR_PKTDONE_MASK,
+ 			 ENETDMAC_IRMASK, priv->tx_chan);
+ 
+ 	netif_carrier_on(dev);
+ 	netif_start_queue(dev);
+ 
+ 	/* apply override config for bypass_link ports here. */
+ 	for (i = 0; i < priv->num_ports; i++) {
+ 		struct bcm63xx_enetsw_port *port;
+ 		u8 override;
+ 		port = &priv->used_ports[i];
+ 		if (!port->used)
+ 			continue;
+ 
+ 		if (!port->bypass_link)
+ 			continue;
+ 
+ 		override = ENETSW_PORTOV_ENABLE_MASK |
+ 			ENETSW_PORTOV_LINKUP_MASK;
+ 
+ 		switch (port->force_speed) {
+ 		case 1000:
+ 			override |= ENETSW_IMPOV_1000_MASK;
+ 			break;
+ 		case 100:
+ 			override |= ENETSW_IMPOV_100_MASK;
+ 			break;
+ 		case 10:
+ 			break;
+ 		default:
+ 			pr_warn("invalid forced speed on port %s: assume 10\n",
+ 			       port->name);
+ 			break;
+ 		}
+ 
+ 		if (port->force_duplex_full)
+ 			override |= ENETSW_IMPOV_FDX_MASK;
+ 
+ 
+ 		enetsw_writeb(priv, override, ENETSW_PORTOV_REG(i));
+ 		enetsw_writeb(priv, 0, ENETSW_PTCTRL_REG(i));
+ 	}
+ 
+ 	/* start phy polling timer */
+ 	init_timer(&priv->swphy_poll);
+ 	priv->swphy_poll.function = swphy_poll_timer;
+ 	priv->swphy_poll.data = (unsigned long)priv;
+ 	priv->swphy_poll.expires = jiffies;
+ 	add_timer(&priv->swphy_poll);
+ 	return 0;
+ 
+ out:
+ 	for (i = 0; i < priv->rx_ring_size; i++) {
+ 		struct bcm_enet_desc *desc;
+ 
+ 		if (!priv->rx_skb[i])
+ 			continue;
+ 
+ 		desc = &priv->rx_desc_cpu[i];
+ 		dma_unmap_single(kdev, desc->address, priv->rx_skb_size,
+ 				 DMA_FROM_DEVICE);
+ 		kfree_skb(priv->rx_skb[i]);
+ 	}
+ 	kfree(priv->rx_skb);
+ 
+ out_free_tx_skb:
+ 	kfree(priv->tx_skb);
+ 
+ out_free_tx_ring:
+ 	dma_free_coherent(kdev, priv->tx_desc_alloc_size,
+ 			  priv->tx_desc_cpu, priv->tx_desc_dma);
+ 
+ out_free_rx_ring:
+ 	dma_free_coherent(kdev, priv->rx_desc_alloc_size,
+ 			  priv->rx_desc_cpu, priv->rx_desc_dma);
+ 
+ out_freeirq_tx:
+ 	if (priv->irq_tx != -1)
+ 		free_irq(priv->irq_tx, dev);
+ 
+ out_freeirq_rx:
+ 	free_irq(priv->irq_rx, dev);
+ 
+ out_freeirq:
+ 	return ret;
+ }
+ 
+ /* stop callback */
+ static int bcm_enetsw_stop(struct net_device *dev)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	struct device *kdev;
+ 	int i;
+ 
+ 	priv = netdev_priv(dev);
+ 	kdev = &priv->pdev->dev;
+ 
+ 	del_timer_sync(&priv->swphy_poll);
+ 	netif_stop_queue(dev);
+ 	napi_disable(&priv->napi);
+ 	del_timer_sync(&priv->rx_timeout);
+ 
+ 	/* mask all interrupts */
+ 	enet_dmac_writel(priv, 0, ENETDMAC_IRMASK, priv->rx_chan);
+ 	enet_dmac_writel(priv, 0, ENETDMAC_IRMASK, priv->tx_chan);
+ 
+ 	/* disable dma & mac */
+ 	bcm_enet_disable_dma(priv, priv->tx_chan);
+ 	bcm_enet_disable_dma(priv, priv->rx_chan);
+ 
+ 	/* force reclaim of all tx buffers */
+ 	bcm_enet_tx_reclaim(dev, 1);
+ 
+ 	/* free the rx skb ring */
+ 	for (i = 0; i < priv->rx_ring_size; i++) {
+ 		struct bcm_enet_desc *desc;
+ 
+ 		if (!priv->rx_skb[i])
+ 			continue;
+ 
+ 		desc = &priv->rx_desc_cpu[i];
+ 		dma_unmap_single(kdev, desc->address, priv->rx_skb_size,
+ 				 DMA_FROM_DEVICE);
+ 		kfree_skb(priv->rx_skb[i]);
+ 	}
+ 
+ 	/* free remaining allocated memory */
+ 	kfree(priv->rx_skb);
+ 	kfree(priv->tx_skb);
+ 	dma_free_coherent(kdev, priv->rx_desc_alloc_size,
+ 			  priv->rx_desc_cpu, priv->rx_desc_dma);
+ 	dma_free_coherent(kdev, priv->tx_desc_alloc_size,
+ 			  priv->tx_desc_cpu, priv->tx_desc_dma);
+ 	if (priv->irq_tx != -1)
+ 		free_irq(priv->irq_tx, dev);
+ 	free_irq(priv->irq_rx, dev);
+ 
+ 	return 0;
+ }
+ 
+ /* try to sort out phy external status by walking the used_port field
+  * in the bcm_enet_priv structure. in case the phy address is not
+  * assigned to any physical port on the switch, assume it is external
+  * (and yell at the user).
+  */
+ static int bcm_enetsw_phy_is_external(struct bcm_enet_priv *priv, int phy_id)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < priv->num_ports; ++i) {
+ 		if (!priv->used_ports[i].used)
+ 			continue;
+ 		if (priv->used_ports[i].phy_id == phy_id)
+ 			return bcm_enet_port_is_rgmii(i);
+ 	}
+ 
+ 	printk_once(KERN_WARNING  "bcm63xx_enet: could not find a used port with phy_id %i, assuming phy is external\n",
+ 		    phy_id);
+ 	return 1;
+ }
+ 
+ /* can't use bcmenet_sw_mdio_read directly as we need to sort out
+  * external/internal status of the given phy_id first.
+  */
+ static int bcm_enetsw_mii_mdio_read(struct net_device *dev, int phy_id,
+ 				    int location)
+ {
+ 	struct bcm_enet_priv *priv;
+ 
+ 	priv = netdev_priv(dev);
+ 	return bcmenet_sw_mdio_read(priv,
+ 				    bcm_enetsw_phy_is_external(priv, phy_id),
+ 				    phy_id, location);
+ }
+ 
+ /* can't use bcmenet_sw_mdio_write directly as we need to sort out
+  * external/internal status of the given phy_id first.
+  */
+ static void bcm_enetsw_mii_mdio_write(struct net_device *dev, int phy_id,
+ 				      int location,
+ 				      int val)
+ {
+ 	struct bcm_enet_priv *priv;
+ 
+ 	priv = netdev_priv(dev);
+ 	bcmenet_sw_mdio_write(priv, bcm_enetsw_phy_is_external(priv, phy_id),
+ 			      phy_id, location, val);
+ }
+ 
+ static int bcm_enetsw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+ {
+ 	struct mii_if_info mii;
+ 
+ 	mii.dev = dev;
+ 	mii.mdio_read = bcm_enetsw_mii_mdio_read;
+ 	mii.mdio_write = bcm_enetsw_mii_mdio_write;
+ 	mii.phy_id = 0;
+ 	mii.phy_id_mask = 0x3f;
+ 	mii.reg_num_mask = 0x1f;
+ 	return generic_mii_ioctl(&mii, if_mii(rq), cmd, NULL);
+ 
+ }
+ 
+ static const struct net_device_ops bcm_enetsw_ops = {
+ 	.ndo_open		= bcm_enetsw_open,
+ 	.ndo_stop		= bcm_enetsw_stop,
+ 	.ndo_start_xmit		= bcm_enet_start_xmit,
+ 	.ndo_change_mtu		= bcm_enet_change_mtu,
+ 	.ndo_do_ioctl		= bcm_enetsw_ioctl,
+ };
+ 
+ 
+ static const struct bcm_enet_stats bcm_enetsw_gstrings_stats[] = {
+ 	{ "rx_packets", DEV_STAT(rx_packets), -1 },
+ 	{ "tx_packets",	DEV_STAT(tx_packets), -1 },
+ 	{ "rx_bytes", DEV_STAT(rx_bytes), -1 },
+ 	{ "tx_bytes", DEV_STAT(tx_bytes), -1 },
+ 	{ "rx_errors", DEV_STAT(rx_errors), -1 },
+ 	{ "tx_errors", DEV_STAT(tx_errors), -1 },
+ 	{ "rx_dropped",	DEV_STAT(rx_dropped), -1 },
+ 	{ "tx_dropped",	DEV_STAT(tx_dropped), -1 },
+ 
+ 	{ "tx_good_octets", GEN_STAT(mib.tx_gd_octets), ETHSW_MIB_RX_GD_OCT },
+ 	{ "tx_unicast", GEN_STAT(mib.tx_unicast), ETHSW_MIB_RX_BRDCAST },
+ 	{ "tx_broadcast", GEN_STAT(mib.tx_brdcast), ETHSW_MIB_RX_BRDCAST },
+ 	{ "tx_multicast", GEN_STAT(mib.tx_mult), ETHSW_MIB_RX_MULT },
+ 	{ "tx_64_octets", GEN_STAT(mib.tx_64), ETHSW_MIB_RX_64 },
+ 	{ "tx_65_127_oct", GEN_STAT(mib.tx_65_127), ETHSW_MIB_RX_65_127 },
+ 	{ "tx_128_255_oct", GEN_STAT(mib.tx_128_255), ETHSW_MIB_RX_128_255 },
+ 	{ "tx_256_511_oct", GEN_STAT(mib.tx_256_511), ETHSW_MIB_RX_256_511 },
+ 	{ "tx_512_1023_oct", GEN_STAT(mib.tx_512_1023), ETHSW_MIB_RX_512_1023},
+ 	{ "tx_1024_1522_oct", GEN_STAT(mib.tx_1024_max),
+ 	  ETHSW_MIB_RX_1024_1522 },
+ 	{ "tx_1523_2047_oct", GEN_STAT(mib.tx_1523_2047),
+ 	  ETHSW_MIB_RX_1523_2047 },
+ 	{ "tx_2048_4095_oct", GEN_STAT(mib.tx_2048_4095),
+ 	  ETHSW_MIB_RX_2048_4095 },
+ 	{ "tx_4096_8191_oct", GEN_STAT(mib.tx_4096_8191),
+ 	  ETHSW_MIB_RX_4096_8191 },
+ 	{ "tx_8192_9728_oct", GEN_STAT(mib.tx_8192_9728),
+ 	  ETHSW_MIB_RX_8192_9728 },
+ 	{ "tx_oversize", GEN_STAT(mib.tx_ovr), ETHSW_MIB_RX_OVR },
+ 	{ "tx_oversize_drop", GEN_STAT(mib.tx_ovr), ETHSW_MIB_RX_OVR_DISC },
+ 	{ "tx_dropped",	GEN_STAT(mib.tx_drop), ETHSW_MIB_RX_DROP },
+ 	{ "tx_undersize", GEN_STAT(mib.tx_underrun), ETHSW_MIB_RX_UND },
+ 	{ "tx_pause", GEN_STAT(mib.tx_pause), ETHSW_MIB_RX_PAUSE },
+ 
+ 	{ "rx_good_octets", GEN_STAT(mib.rx_gd_octets), ETHSW_MIB_TX_ALL_OCT },
+ 	{ "rx_broadcast", GEN_STAT(mib.rx_brdcast), ETHSW_MIB_TX_BRDCAST },
+ 	{ "rx_multicast", GEN_STAT(mib.rx_mult), ETHSW_MIB_TX_MULT },
+ 	{ "rx_unicast", GEN_STAT(mib.rx_unicast), ETHSW_MIB_TX_MULT },
+ 	{ "rx_pause", GEN_STAT(mib.rx_pause), ETHSW_MIB_TX_PAUSE },
+ 	{ "rx_dropped", GEN_STAT(mib.rx_drop), ETHSW_MIB_TX_DROP_PKTS },
+ 
+ };
+ 
+ #define BCM_ENETSW_STATS_LEN	\
+ 	(sizeof(bcm_enetsw_gstrings_stats) / sizeof(struct bcm_enet_stats))
+ 
+ static void bcm_enetsw_get_strings(struct net_device *netdev,
+ 				   u32 stringset, u8 *data)
+ {
+ 	int i;
+ 
+ 	switch (stringset) {
+ 	case ETH_SS_STATS:
+ 		for (i = 0; i < BCM_ENETSW_STATS_LEN; i++) {
+ 			memcpy(data + i * ETH_GSTRING_LEN,
+ 			       bcm_enetsw_gstrings_stats[i].stat_string,
+ 			       ETH_GSTRING_LEN);
+ 		}
+ 		break;
+ 	}
+ }
+ 
+ static int bcm_enetsw_get_sset_count(struct net_device *netdev,
+ 				     int string_set)
+ {
+ 	switch (string_set) {
+ 	case ETH_SS_STATS:
+ 		return BCM_ENETSW_STATS_LEN;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
+ static void bcm_enetsw_get_drvinfo(struct net_device *netdev,
+ 				   struct ethtool_drvinfo *drvinfo)
+ {
+ 	strncpy(drvinfo->driver, bcm_enet_driver_name, 32);
+ 	strncpy(drvinfo->version, bcm_enet_driver_version, 32);
+ 	strncpy(drvinfo->fw_version, "N/A", 32);
+ 	strncpy(drvinfo->bus_info, "bcm63xx", 32);
+ }
+ 
+ static void bcm_enetsw_get_ethtool_stats(struct net_device *netdev,
+ 					 struct ethtool_stats *stats,
+ 					 u64 *data)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	int i;
+ 
+ 	priv = netdev_priv(netdev);
+ 
+ 	for (i = 0; i < BCM_ENETSW_STATS_LEN; i++) {
+ 		const struct bcm_enet_stats *s;
+ 		u32 lo, hi;
+ 		char *p;
+ 		int reg;
+ 
+ 		s = &bcm_enetsw_gstrings_stats[i];
+ 
+ 		reg = s->mib_reg;
+ 		if (reg == -1)
+ 			continue;
+ 
+ 		lo = enetsw_readl(priv, ENETSW_MIB_REG(reg));
+ 		p = (char *)priv + s->stat_offset;
+ 
+ 		if (s->sizeof_stat == sizeof(u64)) {
+ 			hi = enetsw_readl(priv, ENETSW_MIB_REG(reg + 1));
+ 			*(u64 *)p = ((u64)hi << 32 | lo);
+ 		} else {
+ 			*(u32 *)p = lo;
+ 		}
+ 	}
+ 
+ 	for (i = 0; i < BCM_ENETSW_STATS_LEN; i++) {
+ 		const struct bcm_enet_stats *s;
+ 		char *p;
+ 
+ 		s = &bcm_enetsw_gstrings_stats[i];
+ 
+ 		if (s->mib_reg == -1)
+ 			p = (char *)&netdev->stats + s->stat_offset;
+ 		else
+ 			p = (char *)priv + s->stat_offset;
+ 
+ 		data[i] = (s->sizeof_stat == sizeof(u64)) ?
+ 			*(u64 *)p : *(u32 *)p;
+ 	}
+ }
+ 
+ static void bcm_enetsw_get_ringparam(struct net_device *dev,
+ 				     struct ethtool_ringparam *ering)
+ {
+ 	struct bcm_enet_priv *priv;
+ 
+ 	priv = netdev_priv(dev);
+ 
+ 	/* rx/tx ring is actually only limited by memory */
+ 	ering->rx_max_pending = 8192;
+ 	ering->tx_max_pending = 8192;
+ 	ering->rx_mini_max_pending = 0;
+ 	ering->rx_jumbo_max_pending = 0;
+ 	ering->rx_pending = priv->rx_ring_size;
+ 	ering->tx_pending = priv->tx_ring_size;
+ }
+ 
+ static int bcm_enetsw_set_ringparam(struct net_device *dev,
+ 				    struct ethtool_ringparam *ering)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	int was_running;
+ 
+ 	priv = netdev_priv(dev);
+ 
+ 	was_running = 0;
+ 	if (netif_running(dev)) {
+ 		bcm_enetsw_stop(dev);
+ 		was_running = 1;
+ 	}
+ 
+ 	priv->rx_ring_size = ering->rx_pending;
+ 	priv->tx_ring_size = ering->tx_pending;
+ 
+ 	if (was_running) {
+ 		int err;
+ 
+ 		err = bcm_enetsw_open(dev);
+ 		if (err)
+ 			dev_close(dev);
+ 	}
+ 	return 0;
+ }
+ 
+ static struct ethtool_ops bcm_enetsw_ethtool_ops = {
+ 	.get_strings		= bcm_enetsw_get_strings,
+ 	.get_sset_count		= bcm_enetsw_get_sset_count,
+ 	.get_ethtool_stats      = bcm_enetsw_get_ethtool_stats,
+ 	.get_drvinfo		= bcm_enetsw_get_drvinfo,
+ 	.get_ringparam		= bcm_enetsw_get_ringparam,
+ 	.set_ringparam		= bcm_enetsw_set_ringparam,
+ };
+ 
+ /* allocate netdevice, request register memory and register device. */
+ static int bcm_enetsw_probe(struct platform_device *pdev)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	struct net_device *dev;
+ 	struct bcm63xx_enetsw_platform_data *pd;
+ 	struct resource *res_mem;
+ 	int ret, irq_rx, irq_tx;
+ 
+ 	/* stop if shared driver failed, assume driver->probe will be
+ 	 * called in the same order we register devices (correct ?)
+ 	 */
+ 	if (!bcm_enet_shared_base[0])
+ 		return -ENODEV;
+ 
+ 	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	irq_rx = platform_get_irq(pdev, 0);
+ 	irq_tx = platform_get_irq(pdev, 1);
+ 	if (!res_mem || irq_rx < 0)
+ 		return -ENODEV;
+ 
+ 	ret = 0;
+ 	dev = alloc_etherdev(sizeof(*priv));
+ 	if (!dev)
+ 		return -ENOMEM;
+ 	priv = netdev_priv(dev);
+ 	memset(priv, 0, sizeof(*priv));
+ 
+ 	/* initialize default and fetch platform data */
+ 	priv->enet_is_sw = true;
+ 	priv->irq_rx = irq_rx;
+ 	priv->irq_tx = irq_tx;
+ 	priv->rx_ring_size = BCMENET_DEF_RX_DESC;
+ 	priv->tx_ring_size = BCMENET_DEF_TX_DESC;
+ 	priv->dma_maxburst = BCMENETSW_DMA_MAXBURST;
+ 
+ 	pd = dev_get_platdata(&pdev->dev);
+ 	if (pd) {
+ 		memcpy(dev->dev_addr, pd->mac_addr, ETH_ALEN);
+ 		memcpy(priv->used_ports, pd->used_ports,
+ 		       sizeof(pd->used_ports));
+ 		priv->num_ports = pd->num_ports;
+ 		priv->dma_has_sram = pd->dma_has_sram;
+ 		priv->dma_chan_en_mask = pd->dma_chan_en_mask;
+ 		priv->dma_chan_int_mask = pd->dma_chan_int_mask;
+ 		priv->dma_chan_width = pd->dma_chan_width;
+ 	}
+ 
+ 	ret = compute_hw_mtu(priv, dev->mtu);
+ 	if (ret)
+ 		goto out;
+ 
+ 	if (!request_mem_region(res_mem->start, resource_size(res_mem),
+ 				"bcm63xx_enetsw")) {
+ 		ret = -EBUSY;
+ 		goto out;
+ 	}
+ 
+ 	priv->base = ioremap(res_mem->start, resource_size(res_mem));
+ 	if (priv->base == NULL) {
+ 		ret = -ENOMEM;
+ 		goto out_release_mem;
+ 	}
+ 
+ 	priv->mac_clk = clk_get(&pdev->dev, "enetsw");
+ 	if (IS_ERR(priv->mac_clk)) {
+ 		ret = PTR_ERR(priv->mac_clk);
+ 		goto out_unmap;
+ 	}
+ 	clk_enable(priv->mac_clk);
+ 
+ 	priv->rx_chan = 0;
+ 	priv->tx_chan = 1;
+ 	spin_lock_init(&priv->rx_lock);
+ 
+ 	/* init rx timeout (used for oom) */
+ 	init_timer(&priv->rx_timeout);
+ 	priv->rx_timeout.function = bcm_enet_refill_rx_timer;
+ 	priv->rx_timeout.data = (unsigned long)dev;
+ 
+ 	/* register netdevice */
+ 	dev->netdev_ops = &bcm_enetsw_ops;
+ 	netif_napi_add(dev, &priv->napi, bcm_enet_poll, 16);
+ 	dev->ethtool_ops = &bcm_enetsw_ethtool_ops;
+ 	SET_NETDEV_DEV(dev, &pdev->dev);
+ 
+ 	spin_lock_init(&priv->enetsw_mdio_lock);
+ 
+ 	ret = register_netdev(dev);
+ 	if (ret)
+ 		goto out_put_clk;
+ 
+ 	netif_carrier_off(dev);
+ 	platform_set_drvdata(pdev, dev);
+ 	priv->pdev = pdev;
+ 	priv->net_dev = dev;
+ 
+ 	return 0;
+ 
+ out_put_clk:
+ 	clk_put(priv->mac_clk);
+ 
+ out_unmap:
+ 	iounmap(priv->base);
+ 
+ out_release_mem:
+ 	release_mem_region(res_mem->start, resource_size(res_mem));
+ out:
+ 	free_netdev(dev);
+ 	return ret;
+ }
+ 
+ 
+ /* exit func, stops hardware and unregisters netdevice */
+ static int bcm_enetsw_remove(struct platform_device *pdev)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	struct net_device *dev;
+ 	struct resource *res;
+ 
+ 	/* stop netdevice */
+ 	dev = platform_get_drvdata(pdev);
+ 	priv = netdev_priv(dev);
+ 	unregister_netdev(dev);
+ 
+ 	/* release device resources */
+ 	iounmap(priv->base);
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	release_mem_region(res->start, resource_size(res));
+ 
+ 	free_netdev(dev);
+ 	return 0;
+ }
+ 
+ struct platform_driver bcm63xx_enetsw_driver = {
+ 	.probe	= bcm_enetsw_probe,
+ 	.remove	= bcm_enetsw_remove,
+ 	.driver	= {
+ 		.name	= "bcm63xx_enetsw",
+ 		.owner  = THIS_MODULE,
+ 	},
+ };
+ 
+ /* reserve & remap memory space shared between all macs */
++>>>>>>> 47ea0325337b (drivers/net: get rid of unnecessary initializations in .get_drvinfo())
  static int bcm_enet_shared_probe(struct platform_device *pdev)
  {
  	struct resource *res;
diff --cc drivers/net/ethernet/ti/tlan.c
index dc5aa3b01970,a274cd49afe9..000000000000
--- a/drivers/net/ethernet/ti/tlan.c
+++ b/drivers/net/ethernet/ti/tlan.c
@@@ -783,7 -780,42 +783,41 @@@ static const struct net_device_ops tlan
  #endif
  };
  
 -static void tlan_get_drvinfo(struct net_device *dev,
 -			     struct ethtool_drvinfo *info)
 -{
 -	struct tlan_priv *priv = netdev_priv(dev);
  
++<<<<<<< HEAD
++=======
+ 	strlcpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));
+ 	if (priv->pci_dev)
+ 		strlcpy(info->bus_info, pci_name(priv->pci_dev),
+ 			sizeof(info->bus_info));
+ 	else
+ 		strlcpy(info->bus_info, "EISA",	sizeof(info->bus_info));
+ }
+ 
+ static int tlan_get_eeprom_len(struct net_device *dev)
+ {
+ 	return TLAN_EEPROM_SIZE;
+ }
+ 
+ static int tlan_get_eeprom(struct net_device *dev,
+ 			   struct ethtool_eeprom *eeprom, u8 *data)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < TLAN_EEPROM_SIZE; i++)
+ 		if (tlan_ee_read_byte(dev, i, &data[i]))
+ 			return -EIO;
+ 
+ 	return 0;
+ }
+ 
+ static const struct ethtool_ops tlan_ethtool_ops = {
+ 	.get_drvinfo	= tlan_get_drvinfo,
+ 	.get_link	= ethtool_op_get_link,
+ 	.get_eeprom_len	= tlan_get_eeprom_len,
+ 	.get_eeprom	= tlan_get_eeprom,
+ };
++>>>>>>> 47ea0325337b (drivers/net: get rid of unnecessary initializations in .get_drvinfo())
  
  /***************************************************************
   *	tlan_init
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
* Unmerged path drivers/net/ethernet/broadcom/bcmsysport.c
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmgenet.c
* Unmerged path drivers/net/ethernet/cavium/liquidio/lio_ethtool.c
* Unmerged path drivers/net/ethernet/hisilicon/hns/hns_ethtool.c
diff --git a/drivers/infiniband/hw/nes/nes_nic.c b/drivers/infiniband/hw/nes/nes_nic.c
index 77e07fee3cef..09137d75abe9 100644
--- a/drivers/infiniband/hw/nes/nes_nic.c
+++ b/drivers/infiniband/hw/nes/nes_nic.c
@@ -1324,9 +1324,6 @@ static void nes_netdev_get_drvinfo(struct net_device *netdev,
 		 "%u.%u", nesadapter->firmware_version >> 16,
 		 nesadapter->firmware_version & 0x000000ff);
 	strlcpy(drvinfo->version, DRV_VERSION, sizeof(drvinfo->version));
-	drvinfo->testinfo_len = 0;
-	drvinfo->eedump_len = 0;
-	drvinfo->regdump_len = 0;
 }
 
 
diff --git a/drivers/net/ethernet/aeroflex/greth.c b/drivers/net/ethernet/aeroflex/greth.c
index 269295403fc4..b0b6d7193ae4 100644
--- a/drivers/net/ethernet/aeroflex/greth.c
+++ b/drivers/net/ethernet/aeroflex/greth.c
@@ -1132,8 +1132,6 @@ static void greth_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *in
 	strlcpy(info->version, "revision: 1.0", sizeof(info->version));
 	strlcpy(info->bus_info, greth->dev->bus->name, sizeof(info->bus_info));
 	strlcpy(info->fw_version, "N/A", sizeof(info->fw_version));
-	info->eedump_len = 0;
-	info->regdump_len = sizeof(struct greth_regs);
 }
 
 static void greth_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *p)
diff --git a/drivers/net/ethernet/amd/au1000_eth.c b/drivers/net/ethernet/amd/au1000_eth.c
index 688aede742c7..e01423a470cb 100644
--- a/drivers/net/ethernet/amd/au1000_eth.c
+++ b/drivers/net/ethernet/amd/au1000_eth.c
@@ -591,7 +591,6 @@ au1000_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
 	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
 	snprintf(info->bus_info, sizeof(info->bus_info), "%s %d", DRV_NAME,
 		 aup->mac_id);
-	info->regdump_len = 0;
 }
 
 static void au1000_set_msglevel(struct net_device *dev, u32 value)
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
diff --git a/drivers/net/ethernet/atheros/atl1c/atl1c_ethtool.c b/drivers/net/ethernet/atheros/atl1c/atl1c_ethtool.c
index 859ea844ba0f..05b280331868 100644
--- a/drivers/net/ethernet/atheros/atl1c/atl1c_ethtool.c
+++ b/drivers/net/ethernet/atheros/atl1c/atl1c_ethtool.c
@@ -233,10 +233,6 @@ static void atl1c_get_drvinfo(struct net_device *netdev,
 		sizeof(drvinfo->version));
 	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->n_stats = 0;
-	drvinfo->testinfo_len = 0;
-	drvinfo->regdump_len = atl1c_get_regs_len(netdev);
-	drvinfo->eedump_len = atl1c_get_eeprom_len(netdev);
 }
 
 static void atl1c_get_wol(struct net_device *netdev,
diff --git a/drivers/net/ethernet/atheros/atl1e/atl1e_ethtool.c b/drivers/net/ethernet/atheros/atl1e/atl1e_ethtool.c
index 82b23861bf55..473c790d421a 100644
--- a/drivers/net/ethernet/atheros/atl1e/atl1e_ethtool.c
+++ b/drivers/net/ethernet/atheros/atl1e/atl1e_ethtool.c
@@ -316,10 +316,6 @@ static void atl1e_get_drvinfo(struct net_device *netdev,
 	strlcpy(drvinfo->fw_version, "L1e", sizeof(drvinfo->fw_version));
 	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->n_stats = 0;
-	drvinfo->testinfo_len = 0;
-	drvinfo->regdump_len = atl1e_get_regs_len(netdev);
-	drvinfo->eedump_len = atl1e_get_eeprom_len(netdev);
 }
 
 static void atl1e_get_wol(struct net_device *netdev,
diff --git a/drivers/net/ethernet/atheros/atlx/atl1.c b/drivers/net/ethernet/atheros/atlx/atl1.c
index 3a2488a18cde..98ce9f5f437d 100644
--- a/drivers/net/ethernet/atheros/atlx/atl1.c
+++ b/drivers/net/ethernet/atheros/atlx/atl1.c
@@ -3407,7 +3407,6 @@ static void atl1_get_drvinfo(struct net_device *netdev,
 		sizeof(drvinfo->version));
 	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->eedump_len = ATL1_EEDUMP_LEN;
 }
 
 static void atl1_get_wol(struct net_device *netdev,
diff --git a/drivers/net/ethernet/atheros/atlx/atl2.c b/drivers/net/ethernet/atheros/atlx/atl2.c
index 0f12004b3545..e487abee6ca3 100644
--- a/drivers/net/ethernet/atheros/atlx/atl2.c
+++ b/drivers/net/ethernet/atheros/atlx/atl2.c
@@ -2033,10 +2033,6 @@ static void atl2_get_drvinfo(struct net_device *netdev,
 	strlcpy(drvinfo->fw_version, "L2", sizeof(drvinfo->fw_version));
 	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->n_stats = 0;
-	drvinfo->testinfo_len = 0;
-	drvinfo->regdump_len = atl2_get_regs_len(netdev);
-	drvinfo->eedump_len = atl2_get_eeprom_len(netdev);
 }
 
 static void atl2_get_wol(struct net_device *netdev,
* Unmerged path drivers/net/ethernet/broadcom/bcm63xx_enet.c
* Unmerged path drivers/net/ethernet/broadcom/bcmsysport.c
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c
index f3e2e005bea5..85a7800bfc12 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c
@@ -1093,10 +1093,6 @@ static void bnx2x_get_drvinfo(struct net_device *dev,
 	bnx2x_fill_fw_str(bp, info->fw_version, sizeof(info->fw_version));
 
 	strlcpy(info->bus_info, pci_name(bp->pdev), sizeof(info->bus_info));
-	info->n_stats = BNX2X_NUM_STATS;
-	info->testinfo_len = BNX2X_NUM_TESTS(bp);
-	info->eedump_len = bp->common.flash_size;
-	info->regdump_len = bnx2x_get_regs_len(dev);
 }
 
 static void bnx2x_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmgenet.c
* Unmerged path drivers/net/ethernet/cavium/liquidio/lio_ethtool.c
diff --git a/drivers/net/ethernet/dec/tulip/de2104x.c b/drivers/net/ethernet/dec/tulip/de2104x.c
index 1aee6b5e89e2..28544e17267e 100644
--- a/drivers/net/ethernet/dec/tulip/de2104x.c
+++ b/drivers/net/ethernet/dec/tulip/de2104x.c
@@ -1597,7 +1597,6 @@ static void de_get_drvinfo (struct net_device *dev,struct ethtool_drvinfo *info)
 	strlcpy(info->driver, DRV_NAME, sizeof(info->driver));
 	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
 	strlcpy(info->bus_info, pci_name(de->pdev), sizeof(info->bus_info));
-	info->eedump_len = DE_EEPROM_SIZE;
 }
 
 static int de_get_regs_len(struct net_device *dev)
diff --git a/drivers/net/ethernet/emulex/benet/be_ethtool.c b/drivers/net/ethernet/emulex/benet/be_ethtool.c
index 70ccb9b174f4..a6e1dd2566bf 100644
--- a/drivers/net/ethernet/emulex/benet/be_ethtool.c
+++ b/drivers/net/ethernet/emulex/benet/be_ethtool.c
@@ -232,9 +232,6 @@ static void be_get_drvinfo(struct net_device *netdev,
 
 	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->testinfo_len = 0;
-	drvinfo->regdump_len = 0;
-	drvinfo->eedump_len = 0;
 }
 
 static u32 lancer_cmd_get_file_len(struct be_adapter *adapter, u8 *file_name)
diff --git a/drivers/net/ethernet/freescale/gianfar_ethtool.c b/drivers/net/ethernet/freescale/gianfar_ethtool.c
index 21cd88124ca9..ad049bc8a774 100644
--- a/drivers/net/ethernet/freescale/gianfar_ethtool.c
+++ b/drivers/net/ethernet/freescale/gianfar_ethtool.c
@@ -185,8 +185,6 @@ static void gfar_gdrvinfo(struct net_device *dev,
 		sizeof(drvinfo->version));
 	strlcpy(drvinfo->fw_version, "N/A", sizeof(drvinfo->fw_version));
 	strlcpy(drvinfo->bus_info, "N/A", sizeof(drvinfo->bus_info));
-	drvinfo->regdump_len = 0;
-	drvinfo->eedump_len = 0;
 }
 
 
diff --git a/drivers/net/ethernet/freescale/ucc_geth_ethtool.c b/drivers/net/ethernet/freescale/ucc_geth_ethtool.c
index e79aaf9ae52a..63b9d2a9ed7f 100644
--- a/drivers/net/ethernet/freescale/ucc_geth_ethtool.c
+++ b/drivers/net/ethernet/freescale/ucc_geth_ethtool.c
@@ -352,8 +352,6 @@ uec_get_drvinfo(struct net_device *netdev,
 	strlcpy(drvinfo->version, DRV_VERSION, sizeof(drvinfo->version));
 	strlcpy(drvinfo->fw_version, "N/A", sizeof(drvinfo->fw_version));
 	strlcpy(drvinfo->bus_info, "QUICC ENGINE", sizeof(drvinfo->bus_info));
-	drvinfo->eedump_len = 0;
-	drvinfo->regdump_len = uec_get_regs_len(netdev);
 }
 
 #ifdef CONFIG_PM
* Unmerged path drivers/net/ethernet/hisilicon/hns/hns_ethtool.c
diff --git a/drivers/net/ethernet/ibm/emac/core.c b/drivers/net/ethernet/ibm/emac/core.c
index d300a0c0eafc..d356826271dd 100644
--- a/drivers/net/ethernet/ibm/emac/core.c
+++ b/drivers/net/ethernet/ibm/emac/core.c
@@ -2214,7 +2214,6 @@ static void emac_ethtool_get_drvinfo(struct net_device *ndev,
 	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
 	snprintf(info->bus_info, sizeof(info->bus_info), "PPC 4xx EMAC-%d %s",
 		 dev->cell_index, dev->ofdev->dev.of_node->full_name);
-	info->regdump_len = emac_ethtool_get_regs_len(ndev);
 }
 
 static const struct ethtool_ops emac_ethtool_ops = {
diff --git a/drivers/net/ethernet/intel/e1000/e1000_ethtool.c b/drivers/net/ethernet/intel/e1000/e1000_ethtool.c
index ca9395819557..430075399d10 100644
--- a/drivers/net/ethernet/intel/e1000/e1000_ethtool.c
+++ b/drivers/net/ethernet/intel/e1000/e1000_ethtool.c
@@ -562,8 +562,6 @@ static void e1000_get_drvinfo(struct net_device *netdev,
 
 	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->regdump_len = e1000_get_regs_len(netdev);
-	drvinfo->eedump_len = e1000_get_eeprom_len(netdev);
 }
 
 static void e1000_get_ringparam(struct net_device *netdev,
diff --git a/drivers/net/ethernet/intel/e1000e/ethtool.c b/drivers/net/ethernet/intel/e1000e/ethtool.c
index a40861642d8e..7d29c962d380 100644
--- a/drivers/net/ethernet/intel/e1000e/ethtool.c
+++ b/drivers/net/ethernet/intel/e1000e/ethtool.c
@@ -647,8 +647,6 @@ static void e1000_get_drvinfo(struct net_device *netdev,
 
 	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->regdump_len = e1000_get_regs_len(netdev);
-	drvinfo->eedump_len = e1000_get_eeprom_len(netdev);
 }
 
 static void e1000_get_ringparam(struct net_device *netdev,
diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c b/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c
index 447a5f8da42f..2ce0eba5e040 100644
--- a/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c
+++ b/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c
@@ -515,10 +515,6 @@ static void fm10k_get_drvinfo(struct net_device *dev,
 		sizeof(info->version) - 1);
 	strncpy(info->bus_info, pci_name(interface->pdev),
 		sizeof(info->bus_info) - 1);
-
-	info->n_stats = fm10k_get_sset_count(dev, ETH_SS_STATS);
-
-	info->regdump_len = fm10k_get_regs_len(dev);
 }
 
 static void fm10k_get_pauseparam(struct net_device *dev,
diff --git a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 28b792a3c68a..e447e18a26c8 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@ -1128,7 +1128,6 @@ static void i40e_get_drvinfo(struct net_device *netdev,
 		sizeof(drvinfo->fw_version));
 	strlcpy(drvinfo->bus_info, pci_name(pf->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->n_priv_flags = I40E_PRIV_FLAGS_STR_LEN;
 }
 
 static void i40e_get_ringparam(struct net_device *netdev,
diff --git a/drivers/net/ethernet/intel/igb/igb_ethtool.c b/drivers/net/ethernet/intel/igb/igb_ethtool.c
index d157d2400e17..bb4d6cdcd0b8 100644
--- a/drivers/net/ethernet/intel/igb/igb_ethtool.c
+++ b/drivers/net/ethernet/intel/igb/igb_ethtool.c
@@ -852,10 +852,6 @@ static void igb_get_drvinfo(struct net_device *netdev,
 		sizeof(drvinfo->fw_version));
 	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->n_stats = IGB_STATS_LEN;
-	drvinfo->testinfo_len = IGB_TEST_LEN;
-	drvinfo->regdump_len = igb_get_regs_len(netdev);
-	drvinfo->eedump_len = igb_get_eeprom_len(netdev);
 }
 
 static void igb_get_ringparam(struct net_device *netdev,
diff --git a/drivers/net/ethernet/intel/igbvf/ethtool.c b/drivers/net/ethernet/intel/igbvf/ethtool.c
index a4ddf5bbc6e2..8dea1b1367ef 100644
--- a/drivers/net/ethernet/intel/igbvf/ethtool.c
+++ b/drivers/net/ethernet/intel/igbvf/ethtool.c
@@ -197,8 +197,6 @@ static void igbvf_get_drvinfo(struct net_device *netdev,
 		sizeof(drvinfo->version));
 	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->regdump_len = igbvf_get_regs_len(netdev);
-	drvinfo->eedump_len = igbvf_get_eeprom_len(netdev);
 }
 
 static void igbvf_get_ringparam(struct net_device *netdev,
diff --git a/drivers/net/ethernet/intel/ixgb/ixgb_ethtool.c b/drivers/net/ethernet/intel/ixgb/ixgb_ethtool.c
index dbb7dd2f8e36..a154ca962e3a 100644
--- a/drivers/net/ethernet/intel/ixgb/ixgb_ethtool.c
+++ b/drivers/net/ethernet/intel/ixgb/ixgb_ethtool.c
@@ -479,9 +479,6 @@ ixgb_get_drvinfo(struct net_device *netdev,
 		sizeof(drvinfo->version));
 	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->n_stats = IXGB_STATS_LEN;
-	drvinfo->regdump_len = ixgb_get_regs_len(netdev);
-	drvinfo->eedump_len = ixgb_get_eeprom_len(netdev);
 }
 
 static void
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
index 1e7db29ca719..2a03f35e2f19 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
@@ -966,9 +966,6 @@ static void ixgbe_get_drvinfo(struct net_device *netdev,
 
 	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->n_stats = IXGBE_STATS_LEN;
-	drvinfo->testinfo_len = IXGBE_TEST_LEN;
-	drvinfo->regdump_len = ixgbe_get_regs_len(netdev);
 }
 
 static void ixgbe_get_ringparam(struct net_device *netdev,
diff --git a/drivers/net/ethernet/marvell/mv643xx_eth.c b/drivers/net/ethernet/marvell/mv643xx_eth.c
index 4be11ff516a0..8cf7b64b7edc 100644
--- a/drivers/net/ethernet/marvell/mv643xx_eth.c
+++ b/drivers/net/ethernet/marvell/mv643xx_eth.c
@@ -1395,7 +1395,6 @@ static void mv643xx_eth_get_drvinfo(struct net_device *dev,
 		sizeof(drvinfo->version));
 	strlcpy(drvinfo->fw_version, "N/A", sizeof(drvinfo->fw_version));
 	strlcpy(drvinfo->bus_info, "platform", sizeof(drvinfo->bus_info));
-	drvinfo->n_stats = ARRAY_SIZE(mv643xx_eth_stats);
 }
 
 static int mv643xx_eth_nway_reset(struct net_device *dev)
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index 2141b5384476..5515b8f78934 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@ -95,9 +95,6 @@ mlx4_en_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *drvinfo)
 		(u16) (mdev->dev->caps.fw_ver & 0xffff));
 	strlcpy(drvinfo->bus_info, pci_name(mdev->dev->persist->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->n_stats = 0;
-	drvinfo->regdump_len = 0;
-	drvinfo->eedump_len = 0;
 }
 
 static const char mlx4_en_priv_flags[][ETH_GSTRING_LEN] = {
diff --git a/drivers/net/ethernet/neterion/s2io.c b/drivers/net/ethernet/neterion/s2io.c
index fc63ba12cf29..79a656569b7c 100644
--- a/drivers/net/ethernet/neterion/s2io.c
+++ b/drivers/net/ethernet/neterion/s2io.c
@@ -5393,8 +5393,6 @@ static void s2io_ethtool_gdrvinfo(struct net_device *dev,
 	strlcpy(info->driver, s2io_driver_name, sizeof(info->driver));
 	strlcpy(info->version, s2io_driver_version, sizeof(info->version));
 	strlcpy(info->bus_info, pci_name(sp->pdev), sizeof(info->bus_info));
-	info->regdump_len = XENA_REG_SPACE;
-	info->eedump_len = XENA_EEPROM_SPACE;
 }
 
 /**
diff --git a/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c b/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c
index f8f073880f84..47a78d38bbea 100644
--- a/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c
+++ b/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c
@@ -86,10 +86,6 @@ static void vxge_ethtool_gdrvinfo(struct net_device *dev,
 	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
 	strlcpy(info->fw_version, vdev->fw_version, sizeof(info->fw_version));
 	strlcpy(info->bus_info, pci_name(vdev->pdev), sizeof(info->bus_info));
-	info->regdump_len = sizeof(struct vxge_hw_vpath_reg)
-				* vdev->no_of_vpath;
-
-	info->n_stats = STAT_LEN;
 }
 
 /**
diff --git a/drivers/net/ethernet/octeon/octeon_mgmt.c b/drivers/net/ethernet/octeon/octeon_mgmt.c
index 91a8a5d28037..93ac07aa1d17 100644
--- a/drivers/net/ethernet/octeon/octeon_mgmt.c
+++ b/drivers/net/ethernet/octeon/octeon_mgmt.c
@@ -1365,10 +1365,6 @@ static void octeon_mgmt_get_drvinfo(struct net_device *netdev,
 	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
 	strlcpy(info->fw_version, "N/A", sizeof(info->fw_version));
 	strlcpy(info->bus_info, "N/A", sizeof(info->bus_info));
-	info->n_stats = 0;
-	info->testinfo_len = 0;
-	info->regdump_len = 0;
-	info->eedump_len = 0;
 }
 
 static int octeon_mgmt_get_settings(struct net_device *netdev,
diff --git a/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_ethtool.c b/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_ethtool.c
index 24b787be6062..f47f4830f786 100644
--- a/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_ethtool.c
+++ b/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_ethtool.c
@@ -164,7 +164,6 @@ static void pch_gbe_get_drvinfo(struct net_device *netdev,
 	strlcpy(drvinfo->version, pch_driver_version, sizeof(drvinfo->version));
 	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->regdump_len = pch_gbe_get_regs_len(netdev);
 }
 
 /**
diff --git a/drivers/net/ethernet/qlogic/netxen/netxen_nic_ethtool.c b/drivers/net/ethernet/qlogic/netxen/netxen_nic_ethtool.c
index 4ca2c196c98a..8a330f459733 100644
--- a/drivers/net/ethernet/qlogic/netxen/netxen_nic_ethtool.c
+++ b/drivers/net/ethernet/qlogic/netxen/netxen_nic_ethtool.c
@@ -95,8 +95,6 @@ netxen_nic_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *drvinfo)
 
 	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->regdump_len = NETXEN_NIC_REGS_LEN;
-	drvinfo->eedump_len = netxen_nic_get_eeprom_len(dev);
 }
 
 static int
diff --git a/drivers/net/ethernet/qlogic/qla3xxx.c b/drivers/net/ethernet/qlogic/qla3xxx.c
index fe84779615df..dc1dc6ff80ea 100644
--- a/drivers/net/ethernet/qlogic/qla3xxx.c
+++ b/drivers/net/ethernet/qlogic/qla3xxx.c
@@ -1739,8 +1739,6 @@ static void ql_get_drvinfo(struct net_device *ndev,
 		sizeof(drvinfo->version));
 	strlcpy(drvinfo->bus_info, pci_name(qdev->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->regdump_len = 0;
-	drvinfo->eedump_len = 0;
 }
 
 static u32 ql_get_msglevel(struct net_device *ndev)
diff --git a/drivers/net/ethernet/qlogic/qlge/qlge_ethtool.c b/drivers/net/ethernet/qlogic/qlge/qlge_ethtool.c
index c3c514e332b5..5dade1fd08b8 100644
--- a/drivers/net/ethernet/qlogic/qlge/qlge_ethtool.c
+++ b/drivers/net/ethernet/qlogic/qlge/qlge_ethtool.c
@@ -415,13 +415,6 @@ static void ql_get_drvinfo(struct net_device *ndev,
 		 (qdev->fw_rev_id & 0x000000ff));
 	strlcpy(drvinfo->bus_info, pci_name(qdev->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->n_stats = 0;
-	drvinfo->testinfo_len = 0;
-	if (!test_bit(QL_FRC_COREDUMP, &qdev->flags))
-		drvinfo->regdump_len = sizeof(struct ql_mpi_coredump);
-	else
-		drvinfo->regdump_len = sizeof(struct ql_reg_dump);
-	drvinfo->eedump_len = 0;
 }
 
 static void ql_get_wol(struct net_device *ndev, struct ethtool_wolinfo *wol)
diff --git a/drivers/net/ethernet/realtek/8139too.c b/drivers/net/ethernet/realtek/8139too.c
index 05a6d6472f03..6119c59bdabc 100644
--- a/drivers/net/ethernet/realtek/8139too.c
+++ b/drivers/net/ethernet/realtek/8139too.c
@@ -2372,7 +2372,6 @@ static void rtl8139_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *
 	strlcpy(info->driver, DRV_NAME, sizeof(info->driver));
 	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
 	strlcpy(info->bus_info, pci_name(tp->pci_dev), sizeof(info->bus_info));
-	info->regdump_len = tp->regs_len;
 }
 
 static int rtl8139_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
diff --git a/drivers/net/ethernet/sun/cassini.c b/drivers/net/ethernet/sun/cassini.c
index 1f6e8ac0e30f..24af8bfef98a 100644
--- a/drivers/net/ethernet/sun/cassini.c
+++ b/drivers/net/ethernet/sun/cassini.c
@@ -4533,9 +4533,6 @@ static void cas_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info
 	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
 	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
 	strlcpy(info->bus_info, pci_name(cp->pdev), sizeof(info->bus_info));
-	info->regdump_len = cp->casreg_len < CAS_MAX_REGS ?
-		cp->casreg_len : CAS_MAX_REGS;
-	info->n_stats = CAS_NUM_STAT_KEYS;
 }
 
 static int cas_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
diff --git a/drivers/net/ethernet/tehuti/tehuti.c b/drivers/net/ethernet/tehuti/tehuti.c
index 0024542bec6e..44c67db22aca 100644
--- a/drivers/net/ethernet/tehuti/tehuti.c
+++ b/drivers/net/ethernet/tehuti/tehuti.c
@@ -2183,11 +2183,6 @@ bdx_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)
 	strlcpy(drvinfo->fw_version, "N/A", sizeof(drvinfo->fw_version));
 	strlcpy(drvinfo->bus_info, pci_name(priv->pdev),
 		sizeof(drvinfo->bus_info));
-
-	drvinfo->n_stats = ((priv->stats_flag) ? ARRAY_SIZE(bdx_stat_names) : 0);
-	drvinfo->testinfo_len = 0;
-	drvinfo->regdump_len = 0;
-	drvinfo->eedump_len = 0;
 }
 
 /*
diff --git a/drivers/net/ethernet/ti/cpmac.c b/drivers/net/ethernet/ti/cpmac.c
index 31bbbca341a7..b168c31cbd64 100644
--- a/drivers/net/ethernet/ti/cpmac.c
+++ b/drivers/net/ethernet/ti/cpmac.c
@@ -907,7 +907,6 @@ static void cpmac_get_drvinfo(struct net_device *dev,
 	strlcpy(info->driver, "cpmac", sizeof(info->driver));
 	strlcpy(info->version, CPMAC_VERSION, sizeof(info->version));
 	snprintf(info->bus_info, sizeof(info->bus_info), "%s", "cpmac");
-	info->regdump_len = 0;
 }
 
 static const struct ethtool_ops cpmac_ethtool_ops = {
* Unmerged path drivers/net/ethernet/ti/tlan.c
diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
index 24748e8367a1..2742d3b92ee3 100644
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
@@ -1115,7 +1115,6 @@ static void axienet_ethtools_get_drvinfo(struct net_device *ndev,
 {
 	strlcpy(ed->driver, DRIVER_NAME, sizeof(ed->driver));
 	strlcpy(ed->version, DRIVER_VERSION, sizeof(ed->version));
-	ed->regdump_len = sizeof(u32) * AXIENET_REGS_N;
 }
 
 /**
diff --git a/drivers/net/fjes/fjes_ethtool.c b/drivers/net/fjes/fjes_ethtool.c
index 0119dd199276..9c218e140c41 100644
--- a/drivers/net/fjes/fjes_ethtool.c
+++ b/drivers/net/fjes/fjes_ethtool.c
@@ -105,8 +105,6 @@ static void fjes_get_drvinfo(struct net_device *netdev,
 	strlcpy(drvinfo->fw_version, "none", sizeof(drvinfo->fw_version));
 	snprintf(drvinfo->bus_info, sizeof(drvinfo->bus_info),
 		 "platform:%s", plat_dev->name);
-	drvinfo->regdump_len = 0;
-	drvinfo->eedump_len = 0;
 }
 
 static int fjes_get_settings(struct net_device *netdev,
diff --git a/drivers/net/usb/asix_common.c b/drivers/net/usb/asix_common.c
index 99bf5d9050e8..7a53bc74152e 100644
--- a/drivers/net/usb/asix_common.c
+++ b/drivers/net/usb/asix_common.c
@@ -556,7 +556,6 @@ void asix_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
 	usbnet_get_drvinfo(net, info);
 	strlcpy(info->driver, DRIVER_NAME, sizeof(info->driver));
 	strlcpy(info->version, DRIVER_VERSION, sizeof(info->version));
-	info->eedump_len = AX_EEPROM_LEN;
 }
 
 int asix_set_mac_address(struct net_device *net, void *p)
diff --git a/drivers/net/usb/dm9601.c b/drivers/net/usb/dm9601.c
index e80219877730..bed413f2a423 100644
--- a/drivers/net/usb/dm9601.c
+++ b/drivers/net/usb/dm9601.c
@@ -259,7 +259,6 @@ static void dm9601_get_drvinfo(struct net_device *net,
 {
 	/* Inherit standard device info */
 	usbnet_get_drvinfo(net, info);
-	info->eedump_len = DM_EEPROM_LEN;
 }
 
 static u32 dm9601_get_link(struct net_device *net)
diff --git a/drivers/net/usb/mcs7830.c b/drivers/net/usb/mcs7830.c
index 5dcaea21ac5f..b5cafde1cc75 100644
--- a/drivers/net/usb/mcs7830.c
+++ b/drivers/net/usb/mcs7830.c
@@ -446,7 +446,6 @@ static int mcs7830_get_regs_len(struct net_device *net)
 static void mcs7830_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *drvinfo)
 {
 	usbnet_get_drvinfo(net, drvinfo);
-	drvinfo->regdump_len = mcs7830_get_regs_len(net);
 }
 
 static void mcs7830_get_regs(struct net_device *net, struct ethtool_regs *regs, void *data)
diff --git a/drivers/net/usb/sr9800.c b/drivers/net/usb/sr9800.c
index 801710883727..1f1b6d17c214 100644
--- a/drivers/net/usb/sr9800.c
+++ b/drivers/net/usb/sr9800.c
@@ -465,14 +465,10 @@ static int sr_get_eeprom(struct net_device *net,
 static void sr_get_drvinfo(struct net_device *net,
 				 struct ethtool_drvinfo *info)
 {
-	struct usbnet *dev = netdev_priv(net);
-	struct sr_data *data = (struct sr_data *)&dev->data;
-
 	/* Inherit standard device info */
 	usbnet_get_drvinfo(net, info);
 	strncpy(info->driver, DRIVER_NAME, sizeof(info->driver));
 	strncpy(info->version, DRIVER_VERSION, sizeof(info->version));
-	info->eedump_len = data->eeprom_len;
 }
 
 static u32 sr_get_link(struct net_device *net)
diff --git a/drivers/net/vmxnet3/vmxnet3_ethtool.c b/drivers/net/vmxnet3/vmxnet3_ethtool.c
index a681569ae0b5..9ba11d737753 100644
--- a/drivers/net/vmxnet3/vmxnet3_ethtool.c
+++ b/drivers/net/vmxnet3/vmxnet3_ethtool.c
@@ -214,10 +214,6 @@ vmxnet3_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)
 
 	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
 		sizeof(drvinfo->bus_info));
-	drvinfo->n_stats = vmxnet3_get_sset_count(netdev, ETH_SS_STATS);
-	drvinfo->testinfo_len = 0;
-	drvinfo->eedump_len   = 0;
-	drvinfo->regdump_len  = vmxnet3_get_regs_len(netdev);
 }
 
 
diff --git a/drivers/net/wireless/ipw2x00/ipw2200.c b/drivers/net/wireless/ipw2x00/ipw2200.c
index 292a0427cd41..bb37b6673fce 100644
--- a/drivers/net/wireless/ipw2x00/ipw2200.c
+++ b/drivers/net/wireless/ipw2x00/ipw2200.c
@@ -10564,7 +10564,6 @@ static void ipw_ethtool_get_drvinfo(struct net_device *dev,
 		 vers, date);
 	strlcpy(info->bus_info, pci_name(p->pci_dev),
 		sizeof(info->bus_info));
-	info->eedump_len = IPW_EEPROM_IMAGE_SIZE;
 }
 
 static u32 ipw_ethtool_get_link(struct net_device *dev)
