xfs: introduce per-inode DAX enablement

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 58f88ca2df7270881de2034c8286233a89efe71c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/58f88ca2.failed

Rather than just being able to turn DAX on and off via a mount
option, some applications may only want to enable DAX for certain
performance critical files in a filesystem.

This patch introduces a new inode flag to enable DAX in the v3 inode
di_flags2 field. It adds support for setting and clearing flags in
the di_flags2 field via the XFS_IOC_FSSETXATTR ioctl, and sets the
S_DAX inode flag appropriately when it is seen.

When this flag is set on a directory, it acts as an "inherit flag".
That is, inodes created in the directory will automatically inherit
the on-disk inode DAX flag, enabling administrators to set up
directory heirarchies that automatically use DAX. Setting this flag
on an empty root directory will make the entire filesystem use DAX
by default.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>

(cherry picked from commit 58f88ca2df7270881de2034c8286233a89efe71c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_inode.c
#	fs/xfs/xfs_iops.c
#	include/uapi/linux/fs.h
diff --cc fs/xfs/xfs_inode.c
index 3cdcf44d219d,89299085450e..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -616,54 -618,61 +618,71 @@@ _xfs_dic2xflags
  
  	if (di_flags & XFS_DIFLAG_ANY) {
  		if (di_flags & XFS_DIFLAG_REALTIME)
 -			flags |= FS_XFLAG_REALTIME;
 +			flags |= XFS_XFLAG_REALTIME;
  		if (di_flags & XFS_DIFLAG_PREALLOC)
 -			flags |= FS_XFLAG_PREALLOC;
 +			flags |= XFS_XFLAG_PREALLOC;
  		if (di_flags & XFS_DIFLAG_IMMUTABLE)
 -			flags |= FS_XFLAG_IMMUTABLE;
 +			flags |= XFS_XFLAG_IMMUTABLE;
  		if (di_flags & XFS_DIFLAG_APPEND)
 -			flags |= FS_XFLAG_APPEND;
 +			flags |= XFS_XFLAG_APPEND;
  		if (di_flags & XFS_DIFLAG_SYNC)
 -			flags |= FS_XFLAG_SYNC;
 +			flags |= XFS_XFLAG_SYNC;
  		if (di_flags & XFS_DIFLAG_NOATIME)
 -			flags |= FS_XFLAG_NOATIME;
 +			flags |= XFS_XFLAG_NOATIME;
  		if (di_flags & XFS_DIFLAG_NODUMP)
 -			flags |= FS_XFLAG_NODUMP;
 +			flags |= XFS_XFLAG_NODUMP;
  		if (di_flags & XFS_DIFLAG_RTINHERIT)
 -			flags |= FS_XFLAG_RTINHERIT;
 +			flags |= XFS_XFLAG_RTINHERIT;
  		if (di_flags & XFS_DIFLAG_PROJINHERIT)
 -			flags |= FS_XFLAG_PROJINHERIT;
 +			flags |= XFS_XFLAG_PROJINHERIT;
  		if (di_flags & XFS_DIFLAG_NOSYMLINKS)
 -			flags |= FS_XFLAG_NOSYMLINKS;
 +			flags |= XFS_XFLAG_NOSYMLINKS;
  		if (di_flags & XFS_DIFLAG_EXTSIZE)
 -			flags |= FS_XFLAG_EXTSIZE;
 +			flags |= XFS_XFLAG_EXTSIZE;
  		if (di_flags & XFS_DIFLAG_EXTSZINHERIT)
 -			flags |= FS_XFLAG_EXTSZINHERIT;
 +			flags |= XFS_XFLAG_EXTSZINHERIT;
  		if (di_flags & XFS_DIFLAG_NODEFRAG)
 -			flags |= FS_XFLAG_NODEFRAG;
 +			flags |= XFS_XFLAG_NODEFRAG;
  		if (di_flags & XFS_DIFLAG_FILESTREAM)
 -			flags |= FS_XFLAG_FILESTREAM;
 +			flags |= XFS_XFLAG_FILESTREAM;
  	}
  
+ 	if (di_flags2 & XFS_DIFLAG2_ANY) {
+ 		if (di_flags2 & XFS_DIFLAG2_DAX)
+ 			flags |= FS_XFLAG_DAX;
+ 	}
+ 
+ 	if (has_attr)
+ 		flags |= FS_XFLAG_HASATTR;
+ 
  	return flags;
  }
  
  uint
  xfs_ip2xflags(
- 	xfs_inode_t		*ip)
+ 	struct xfs_inode	*ip)
  {
- 	xfs_icdinode_t		*dic = &ip->i_d;
+ 	struct xfs_icdinode	*dic = &ip->i_d;
  
++<<<<<<< HEAD
 +	return _xfs_dic2xflags(dic->di_flags) |
 +				(XFS_IFORK_Q(ip) ? XFS_XFLAG_HASATTR : 0);
++=======
+ 	return _xfs_dic2xflags(dic->di_flags, dic->di_flags2, XFS_IFORK_Q(ip));
++>>>>>>> 58f88ca2df72 (xfs: introduce per-inode DAX enablement)
  }
  
  uint
  xfs_dic2xflags(
- 	xfs_dinode_t		*dip)
+ 	struct xfs_dinode	*dip)
  {
++<<<<<<< HEAD
 +	return _xfs_dic2xflags(be16_to_cpu(dip->di_flags)) |
 +				(XFS_DFORK_Q(dip) ? XFS_XFLAG_HASATTR : 0);
++=======
+ 	return _xfs_dic2xflags(be16_to_cpu(dip->di_flags),
+ 				be64_to_cpu(dip->di_flags2), XFS_DFORK_Q(dip));
++>>>>>>> 58f88ca2df72 (xfs: introduce per-inode DAX enablement)
  }
  
  /*
diff --cc fs/xfs/xfs_iops.c
index dad796405688,a1b8af158d05..000000000000
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@@ -1185,22 -1188,22 +1185,28 @@@ xfs_diflags_to_iflags
  	struct inode		*inode,
  	struct xfs_inode	*ip)
  {
 -	uint16_t		flags = ip->i_d.di_flags;
 -
 -	inode->i_flags &= ~(S_IMMUTABLE | S_APPEND | S_SYNC |
 -			    S_NOATIME | S_DAX);
 -
 -	if (flags & XFS_DIFLAG_IMMUTABLE)
 +	if (ip->i_d.di_flags & XFS_DIFLAG_IMMUTABLE)
  		inode->i_flags |= S_IMMUTABLE;
 -	if (flags & XFS_DIFLAG_APPEND)
 +	else
 +		inode->i_flags &= ~S_IMMUTABLE;
 +	if (ip->i_d.di_flags & XFS_DIFLAG_APPEND)
  		inode->i_flags |= S_APPEND;
 -	if (flags & XFS_DIFLAG_SYNC)
 +	else
 +		inode->i_flags &= ~S_APPEND;
 +	if (ip->i_d.di_flags & XFS_DIFLAG_SYNC)
  		inode->i_flags |= S_SYNC;
 -	if (flags & XFS_DIFLAG_NOATIME)
 +	else
 +		inode->i_flags &= ~S_SYNC;
 +	if (ip->i_d.di_flags & XFS_DIFLAG_NOATIME)
  		inode->i_flags |= S_NOATIME;
++<<<<<<< HEAD
 +	else
 +		inode->i_flags &= ~S_NOATIME;
++=======
+ 	if (ip->i_mount->m_flags & XFS_MOUNT_DAX ||
+ 	    ip->i_d.di_flags2 & XFS_DIFLAG2_DAX)
+ 		inode->i_flags |= S_DAX;
++>>>>>>> 58f88ca2df72 (xfs: introduce per-inode DAX enablement)
  }
  
  /*
diff --cc include/uapi/linux/fs.h
index 83d19dfecb76,4cad4c8ab6b2..000000000000
--- a/include/uapi/linux/fs.h
+++ b/include/uapi/linux/fs.h
@@@ -108,6 -110,37 +108,40 @@@ struct inodes_stat_t 
  #define MS_MGC_VAL 0xC0ED0000
  #define MS_MGC_MSK 0xffff0000
  
++<<<<<<< HEAD
++=======
+ /*
+  * Structure for FS_IOC_FSGETXATTR[A] and FS_IOC_FSSETXATTR.
+  */
+ struct fsxattr {
+ 	__u32		fsx_xflags;	/* xflags field value (get/set) */
+ 	__u32		fsx_extsize;	/* extsize field value (get/set)*/
+ 	__u32		fsx_nextents;	/* nextents field value (get)	*/
+ 	__u32		fsx_projid;	/* project identifier (get/set) */
+ 	unsigned char	fsx_pad[12];
+ };
+ 
+ /*
+  * Flags for the fsx_xflags field
+  */
+ #define FS_XFLAG_REALTIME	0x00000001	/* data in realtime volume */
+ #define FS_XFLAG_PREALLOC	0x00000002	/* preallocated file extents */
+ #define FS_XFLAG_IMMUTABLE	0x00000008	/* file cannot be modified */
+ #define FS_XFLAG_APPEND		0x00000010	/* all writes append */
+ #define FS_XFLAG_SYNC		0x00000020	/* all writes synchronous */
+ #define FS_XFLAG_NOATIME	0x00000040	/* do not update access time */
+ #define FS_XFLAG_NODUMP		0x00000080	/* do not include in backups */
+ #define FS_XFLAG_RTINHERIT	0x00000100	/* create with rt bit set */
+ #define FS_XFLAG_PROJINHERIT	0x00000200	/* create with parents projid */
+ #define FS_XFLAG_NOSYMLINKS	0x00000400	/* disallow symlink creation */
+ #define FS_XFLAG_EXTSIZE	0x00000800	/* extent size allocator hint */
+ #define FS_XFLAG_EXTSZINHERIT	0x00001000	/* inherit inode extent size */
+ #define FS_XFLAG_NODEFRAG	0x00002000	/* do not defragment */
+ #define FS_XFLAG_FILESTREAM	0x00004000	/* use filestream allocator */
+ #define FS_XFLAG_DAX		0x00008000	/* use DAX for IO */
+ #define FS_XFLAG_HASATTR	0x80000000	/* no DIFLAG for this	*/
+ 
++>>>>>>> 58f88ca2df72 (xfs: introduce per-inode DAX enablement)
  /* the read-only stuff doesn't really belong here, but any other place is
     probably as bad and I don't want to create yet another include file. */
  
diff --git a/fs/xfs/libxfs/xfs_format.h b/fs/xfs/libxfs/xfs_format.h
index e2536bb1c760..57cea25298df 100644
--- a/fs/xfs/libxfs/xfs_format.h
+++ b/fs/xfs/libxfs/xfs_format.h
@@ -1025,6 +1025,15 @@ static inline void xfs_dinode_put_rdev(struct xfs_dinode *dip, xfs_dev_t rdev)
 	 XFS_DIFLAG_PROJINHERIT | XFS_DIFLAG_NOSYMLINKS | XFS_DIFLAG_EXTSIZE | \
 	 XFS_DIFLAG_EXTSZINHERIT | XFS_DIFLAG_NODEFRAG | XFS_DIFLAG_FILESTREAM)
 
+/*
+ * Values for di_flags2 These start by being exposed to userspace in the upper
+ * 16 bits of the XFS_XFLAG_s range.
+ */
+#define XFS_DIFLAG2_DAX_BIT	0	/* use DAX for this inode */
+#define XFS_DIFLAG2_DAX		(1 << XFS_DIFLAG2_DAX_BIT)
+
+#define XFS_DIFLAG2_ANY		(XFS_DIFLAG2_DAX)
+
 /*
  * Inode number format:
  * low inopblog bits - offset in block
* Unmerged path fs/xfs/xfs_inode.c
diff --git a/fs/xfs/xfs_ioctl.c b/fs/xfs/xfs_ioctl.c
index 0642c762e0aa..584674315653 100644
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@ -963,6 +963,7 @@ xfs_set_diflags(
 	unsigned int		xflags)
 {
 	unsigned int		di_flags;
+	uint64_t		di_flags2;
 
 	/* can't set PREALLOC this way, just preserve it */
 	di_flags = (ip->i_d.di_flags & XFS_DIFLAG_PREALLOC);
@@ -995,8 +996,18 @@ xfs_set_diflags(
 		if (xflags & XFS_XFLAG_EXTSIZE)
 			di_flags |= XFS_DIFLAG_EXTSIZE;
 	}
-
 	ip->i_d.di_flags = di_flags;
+
+	/* diflags2 only valid for v3 inodes. */
+	if (ip->i_d.di_version < 3)
+		return;
+
+	di_flags2 = 0;
+	if (xflags & FS_XFLAG_DAX)
+		di_flags2 |= XFS_DIFLAG2_DAX;
+
+	ip->i_d.di_flags2 = di_flags2;
+
 }
 
 STATIC void
@@ -1022,6 +1033,11 @@ xfs_diflags_to_linux(
 		inode->i_flags |= S_NOATIME;
 	else
 		inode->i_flags &= ~S_NOATIME;
+	if (xflags & FS_XFLAG_DAX)
+		inode->i_flags |= S_DAX;
+	else
+		inode->i_flags &= ~S_DAX;
+
 }
 
 static int
* Unmerged path fs/xfs/xfs_iops.c
* Unmerged path include/uapi/linux/fs.h
