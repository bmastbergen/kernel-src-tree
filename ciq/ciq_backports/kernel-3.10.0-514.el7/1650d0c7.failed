mmc: sdhci: move setting mmc->actual_clock into set_clock handlers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] sdhci: move setting mmc->actual_clock into set_clock handlers (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 96.06%
commit-author Russell King <rmk+kernel@arm.linux.org.uk>
commit 1650d0c71a209c7d6bdddda8a7e187c537ceb71a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1650d0c7.failed

Move the setting of mmc->actual_clock to zero into the set_clock
handlers themselves.  This will allow us to clean up the calling
logic for the set_clock() method, and turn sdhci_set_clock() into
a library function.

	Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
	Tested-by: Markus Pargmann <mpa@pengutronix.de>
	Tested-by: Stephen Warren <swarren@nvidia.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Chris Ball <chris@printf.net>
(cherry picked from commit 1650d0c71a209c7d6bdddda8a7e187c537ceb71a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci-esdhc-imx.c
#	drivers/mmc/host/sdhci-of-esdhc.c
#	drivers/mmc/host/sdhci-s3c.c
diff --cc drivers/mmc/host/sdhci-esdhc-imx.c
index 98f46704baa6,ce8939ff97a4..000000000000
--- a/drivers/mmc/host/sdhci-esdhc-imx.c
+++ b/drivers/mmc/host/sdhci-esdhc-imx.c
@@@ -388,7 -586,67 +388,71 @@@ static unsigned int esdhc_pltfm_get_min
  {
  	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
  
++<<<<<<< HEAD
 +	return clk_get_rate(pltfm_host->clk) / 256 / 16;
++=======
+ 	return pltfm_host->clock / 256 / 16;
+ }
+ 
+ static inline void esdhc_pltfm_set_clock(struct sdhci_host *host,
+ 					 unsigned int clock)
+ {
+ 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+ 	struct pltfm_imx_data *imx_data = pltfm_host->priv;
+ 	unsigned int host_clock = pltfm_host->clock;
+ 	int pre_div = 2;
+ 	int div = 1;
+ 	u32 temp, val;
+ 
+ 	if (clock == 0) {
+ 		host->mmc->actual_clock = 0;
+ 
+ 		if (esdhc_is_usdhc(imx_data)) {
+ 			val = readl(host->ioaddr + ESDHC_VENDOR_SPEC);
+ 			writel(val & ~ESDHC_VENDOR_SPEC_FRC_SDCLK_ON,
+ 					host->ioaddr + ESDHC_VENDOR_SPEC);
+ 		}
+ 		return;
+ 	}
+ 
+ 	if (esdhc_is_usdhc(imx_data) && !imx_data->is_ddr)
+ 		pre_div = 1;
+ 
+ 	temp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);
+ 	temp &= ~(ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN
+ 		| ESDHC_CLOCK_MASK);
+ 	sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
+ 
+ 	while (host_clock / pre_div / 16 > clock && pre_div < 256)
+ 		pre_div *= 2;
+ 
+ 	while (host_clock / pre_div / div > clock && div < 16)
+ 		div++;
+ 
+ 	host->mmc->actual_clock = host_clock / pre_div / div;
+ 	dev_dbg(mmc_dev(host->mmc), "desired SD clock: %d, actual: %d\n",
+ 		clock, host->mmc->actual_clock);
+ 
+ 	if (imx_data->is_ddr)
+ 		pre_div >>= 2;
+ 	else
+ 		pre_div >>= 1;
+ 	div--;
+ 
+ 	temp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);
+ 	temp |= (ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN
+ 		| (div << ESDHC_DIVIDER_SHIFT)
+ 		| (pre_div << ESDHC_PREDIV_SHIFT));
+ 	sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
+ 
+ 	if (esdhc_is_usdhc(imx_data)) {
+ 		val = readl(host->ioaddr + ESDHC_VENDOR_SPEC);
+ 		writel(val | ESDHC_VENDOR_SPEC_FRC_SDCLK_ON,
+ 		host->ioaddr + ESDHC_VENDOR_SPEC);
+ 	}
+ 
+ 	mdelay(1);
++>>>>>>> 1650d0c71a20 (mmc: sdhci: move setting mmc->actual_clock into set_clock handlers)
  }
  
  static unsigned int esdhc_pltfm_get_ro(struct sdhci_host *host)
diff --cc drivers/mmc/host/sdhci-of-esdhc.c
index 37e668f5b992,c4f8cd3f83c8..000000000000
--- a/drivers/mmc/host/sdhci-of-esdhc.c
+++ b/drivers/mmc/host/sdhci-of-esdhc.c
@@@ -191,6 -199,15 +191,18 @@@ static unsigned int esdhc_of_get_min_cl
  
  static void esdhc_of_set_clock(struct sdhci_host *host, unsigned int clock)
  {
++<<<<<<< HEAD
++=======
+ 	int pre_div = 2;
+ 	int div = 1;
+ 	u32 temp;
+ 
+ 	host->mmc->actual_clock = 0;
+ 
+ 	if (clock == 0)
+ 		return;
+ 
++>>>>>>> 1650d0c71a20 (mmc: sdhci: move setting mmc->actual_clock into set_clock handlers)
  	/* Workaround to reduce the clock frequency for p1010 esdhc */
  	if (of_find_compatible_node(NULL, NULL, "fsl,p1010-esdhc")) {
  		if (clock > 20000000)
diff --cc drivers/mmc/host/sdhci-s3c.c
index 926aaf6acc67,9d710b748b9c..000000000000
--- a/drivers/mmc/host/sdhci-s3c.c
+++ b/drivers/mmc/host/sdhci-s3c.c
@@@ -296,9 -294,13 +298,17 @@@ static void sdhci_cmu_set_clock(struct 
  	unsigned long timeout;
  	u16 clk = 0;
  
++<<<<<<< HEAD
 +	/* don't bother if the clock is going off */
 +	if (clock == 0)
++=======
+ 	host->mmc->actual_clock = 0;
+ 
+ 	/* If the clock is going off, set to 0 at clock control register */
+ 	if (clock == 0) {
+ 		sdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);
++>>>>>>> 1650d0c71a20 (mmc: sdhci: move setting mmc->actual_clock into set_clock handlers)
  		return;
 -	}
  
  	sdhci_s3c_set_clock(host, clock);
  
diff --git a/drivers/mmc/host/sdhci-cns3xxx.c b/drivers/mmc/host/sdhci-cns3xxx.c
index 95620e1983a8..67d3acf7ad8e 100644
--- a/drivers/mmc/host/sdhci-cns3xxx.c
+++ b/drivers/mmc/host/sdhci-cns3xxx.c
@@ -30,6 +30,8 @@ static void sdhci_cns3xxx_set_clock(struct sdhci_host *host, unsigned int clock)
 	u16 clk;
 	unsigned long timeout;
 
+	host->mmc->actual_clock = 0;
+
 	sdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);
 
 	if (clock == 0)
* Unmerged path drivers/mmc/host/sdhci-esdhc-imx.c
* Unmerged path drivers/mmc/host/sdhci-of-esdhc.c
* Unmerged path drivers/mmc/host/sdhci-s3c.c
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index e292d602646d..affd0c2e43e0 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -1137,14 +1137,14 @@ static void sdhci_set_clock(struct sdhci_host *host, unsigned int clock)
 	u16 clk = 0;
 	unsigned long timeout;
 
-	host->mmc->actual_clock = 0;
-
 	if (host->ops->set_clock) {
 		host->ops->set_clock(host, clock);
 		if (host->quirks & SDHCI_QUIRK_NONSTANDARD_CLOCK)
 			return;
 	}
 
+	host->mmc->actual_clock = 0;
+
 	sdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);
 
 	if (clock == 0)
