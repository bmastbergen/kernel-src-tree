audit: refactor audit_receive_msg() to clarify AUDIT_*_RULE* cases

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Richard Guy Briggs <rgb@redhat.com>
commit ce0d9f04699706843e8a494d12cf6c7663d478c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ce0d9f04.failed

audit_receive_msg() needlessly contained a fallthrough case that called
audit_receive_filter(), containing no common code between the cases.  Separate
them to make the logic clearer.  Refactor AUDIT_LIST_RULES, AUDIT_ADD_RULE,
AUDIT_DEL_RULE cases to create audit_rule_change(), audit_list_rules_send()
functions.  This should not functionally change the logic.

	Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
	Signed-off-by: Eric Paris <eparis@redhat.com>
(cherry picked from commit ce0d9f04699706843e8a494d12cf6c7663d478c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/auditfilter.c
diff --cc kernel/auditfilter.c
index 814c273352d7,6cc8240b7aaf..000000000000
--- a/kernel/auditfilter.c
+++ b/kernel/auditfilter.c
@@@ -1049,30 -1037,6 +1047,33 @@@ int audit_rule_change(int type, __u32 p
  	struct audit_entry *entry;
  
  	switch (type) {
++<<<<<<< HEAD
 +	case AUDIT_LIST_RULES:
 +		/* We can't just spew out the rules here because we might fill
 +		 * the available socket buffer space and deadlock waiting for
 +		 * auditctl to read from it... which isn't ever going to
 +		 * happen if we're actually running in the context of auditctl
 +		 * trying to _send_ the stuff */
 +
 +		dest = kmalloc(sizeof(struct audit_netlink_list), GFP_KERNEL);
 +		if (!dest)
 +			return -ENOMEM;
 +		dest->portid = portid;
 +		skb_queue_head_init(&dest->q);
 +
 +		mutex_lock(&audit_filter_mutex);
 +		audit_list_rules(portid, seq, &dest->q);
 +		mutex_unlock(&audit_filter_mutex);
 +
 +		tsk = kthread_run(audit_send_list, dest, "audit_send_list");
 +		if (IS_ERR(tsk)) {
 +			skb_queue_purge(&dest->q);
 +			kfree(dest);
 +			err = PTR_ERR(tsk);
 +		}
 +		break;
++=======
++>>>>>>> ce0d9f046997 (audit: refactor audit_receive_msg() to clarify AUDIT_*_RULE* cases)
  	case AUDIT_ADD_RULE:
  		entry = audit_data_to_entry(data, datasz);
  		if (IS_ERR(entry))
diff --git a/include/linux/audit.h b/include/linux/audit.h
index aff73ee583e5..e6f4c0ae7fbf 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -463,8 +463,10 @@ extern int		    audit_update_lsm_rules(void);
 				/* Private API (for audit.c only) */
 extern int audit_filter_user(int type);
 extern int audit_filter_type(int type);
-extern int  audit_receive_filter(int type, __u32 portid, int seq,
+extern int audit_rule_change(int type, __u32 portid, int seq,
 				void *data, size_t datasz);
+extern int audit_list_rules_send(__u32 portid, int seq);
+
 extern int audit_enabled;
 #else /* CONFIG_AUDIT */
 static inline __printf(4, 5)
diff --git a/kernel/audit.c b/kernel/audit.c
index e40b5ab0e278..baba81018a70 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -878,11 +878,12 @@ static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 			audit_log_end(ab);
 			return -EPERM;
 		}
-		/* fallthrough */
-	case AUDIT_LIST_RULES:
-		err = audit_receive_filter(msg_type, NETLINK_CB(skb).portid,
+		err = audit_rule_change(msg_type, NETLINK_CB(skb).portid,
 					   seq, data, nlmsg_len(nlh));
 		break;
+	case AUDIT_LIST_RULES:
+		err = audit_list_rules_send(NETLINK_CB(skb).portid, seq);
+		break;
 	case AUDIT_TRIM:
 		audit_trim_trees();
 		audit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);
* Unmerged path kernel/auditfilter.c
