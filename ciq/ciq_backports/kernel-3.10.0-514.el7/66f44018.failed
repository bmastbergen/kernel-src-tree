char: ipmi: Move MODULE_DEVICE_TABLE() to follow struct

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [char] ipmi: Move MODULE_DEVICE_TABLE() to follow struct (Tony Camuso) [1274306]
Rebuild_FUZZ: 94.23%
commit-author Luis de Bethencourt <luisbg@osg.samsung.com>
commit 66f44018300c5e6f53c9d30d6920332cf0e6a8f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/66f44018.failed

The policy for drivers is to have MODULE_DEVICE_TABLE() just after the
struct used in it. For clarity.

	Suggested-by: Corey Minyard <minyard@acm.org>
	Signed-off-by: Luis de Bethencourt <luisbg@osg.samsung.com>
	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit 66f44018300c5e6f53c9d30d6920332cf0e6a8f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_si_intf.c
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 0aed223f8e3f,55fe9020459f..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -2692,10 -2572,20 +2692,26 @@@ static struct pci_driver ipmi_pci_drive
  };
  #endif /* CONFIG_PCI */
  
++<<<<<<< HEAD
 +static const struct of_device_id ipmi_match[];
 +static int ipmi_probe(struct platform_device *dev)
++=======
+ #ifdef CONFIG_OF
+ static const struct of_device_id of_ipmi_match[] = {
+ 	{ .type = "ipmi", .compatible = "ipmi-kcs",
+ 	  .data = (void *)(unsigned long) SI_KCS },
+ 	{ .type = "ipmi", .compatible = "ipmi-smic",
+ 	  .data = (void *)(unsigned long) SI_SMIC },
+ 	{ .type = "ipmi", .compatible = "ipmi-bt",
+ 	  .data = (void *)(unsigned long) SI_BT },
+ 	{},
+ };
+ MODULE_DEVICE_TABLE(of, of_ipmi_match);
+ 
+ static int of_ipmi_probe(struct platform_device *dev)
++>>>>>>> 66f44018300c (char: ipmi: Move MODULE_DEVICE_TABLE() to follow struct)
  {
 +#ifdef CONFIG_OF
  	const struct of_device_id *match;
  	struct smi_info *info;
  	struct resource resource;
@@@ -2774,9 -2667,145 +2790,149 @@@
  		kfree(info);
  		return ret;
  	}
 +#endif
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ #else
+ #define of_ipmi_match NULL
+ static int of_ipmi_probe(struct platform_device *dev)
+ {
+ 	return -ENODEV;
+ }
+ #endif
+ 
+ #ifdef CONFIG_ACPI
+ static int acpi_ipmi_probe(struct platform_device *dev)
+ {
+ 	struct smi_info *info;
+ 	struct resource *res, *res_second;
+ 	acpi_handle handle;
+ 	acpi_status status;
+ 	unsigned long long tmp;
+ 	int rv = -EINVAL;
+ 
+ 	handle = ACPI_HANDLE(&dev->dev);
+ 	if (!handle)
+ 		return -ENODEV;
+ 
+ 	info = smi_info_alloc();
+ 	if (!info)
+ 		return -ENOMEM;
+ 
+ 	info->addr_source = SI_ACPI;
+ 	dev_info(&dev->dev, PFX "probing via ACPI\n");
+ 
+ 	info->addr_info.acpi_info.acpi_handle = handle;
+ 
+ 	/* _IFT tells us the interface type: KCS, BT, etc */
+ 	status = acpi_evaluate_integer(handle, "_IFT", NULL, &tmp);
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_err(&dev->dev, "Could not find ACPI IPMI interface type\n");
+ 		goto err_free;
+ 	}
+ 
+ 	switch (tmp) {
+ 	case 1:
+ 		info->si_type = SI_KCS;
+ 		break;
+ 	case 2:
+ 		info->si_type = SI_SMIC;
+ 		break;
+ 	case 3:
+ 		info->si_type = SI_BT;
+ 		break;
+ 	case 4: /* SSIF, just ignore */
+ 		rv = -ENODEV;
+ 		goto err_free;
+ 	default:
+ 		dev_info(&dev->dev, "unknown IPMI type %lld\n", tmp);
+ 		goto err_free;
+ 	}
+ 
+ 	res = platform_get_resource(dev, IORESOURCE_IO, 0);
+ 	if (res) {
+ 		info->io_setup = port_setup;
+ 		info->io.addr_type = IPMI_IO_ADDR_SPACE;
+ 	} else {
+ 		res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+ 		if (res) {
+ 			info->io_setup = mem_setup;
+ 			info->io.addr_type = IPMI_MEM_ADDR_SPACE;
+ 		}
+ 	}
+ 	if (!res) {
+ 		dev_err(&dev->dev, "no I/O or memory address\n");
+ 		goto err_free;
+ 	}
+ 	info->io.addr_data = res->start;
+ 
+ 	info->io.regspacing = DEFAULT_REGSPACING;
+ 	res_second = platform_get_resource(dev,
+ 			       (info->io.addr_type == IPMI_IO_ADDR_SPACE) ?
+ 					IORESOURCE_IO : IORESOURCE_MEM,
+ 			       1);
+ 	if (res_second) {
+ 		if (res_second->start > info->io.addr_data)
+ 			info->io.regspacing =
+ 				res_second->start - info->io.addr_data;
+ 	}
+ 	info->io.regsize = DEFAULT_REGSPACING;
+ 	info->io.regshift = 0;
+ 
+ 	/* If _GPE exists, use it; otherwise use standard interrupts */
+ 	status = acpi_evaluate_integer(handle, "_GPE", NULL, &tmp);
+ 	if (ACPI_SUCCESS(status)) {
+ 		info->irq = tmp;
+ 		info->irq_setup = acpi_gpe_irq_setup;
+ 	} else {
+ 		int irq = platform_get_irq(dev, 0);
+ 
+ 		if (irq > 0) {
+ 			info->irq = irq;
+ 			info->irq_setup = std_irq_setup;
+ 		}
+ 	}
+ 
+ 	info->dev = &dev->dev;
+ 	platform_set_drvdata(dev, info);
+ 
+ 	dev_info(info->dev, "%pR regsize %d spacing %d irq %d\n",
+ 		 res, info->io.regsize, info->io.regspacing,
+ 		 info->irq);
+ 
+ 	rv = add_smi(info);
+ 	if (rv)
+ 		kfree(info);
+ 
+ 	return rv;
+ 
+ err_free:
+ 	kfree(info);
+ 	return rv;
+ }
+ 
+ static const struct acpi_device_id acpi_ipmi_match[] = {
+ 	{ "IPI0001", 0 },
+ 	{ },
+ };
+ MODULE_DEVICE_TABLE(acpi, acpi_ipmi_match);
+ #else
+ static int acpi_ipmi_probe(struct platform_device *dev)
+ {
+ 	return -ENODEV;
+ }
+ #endif
+ 
+ static int ipmi_probe(struct platform_device *dev)
+ {
+ 	if (of_ipmi_probe(dev) == 0)
+ 		return 0;
+ 
+ 	return acpi_ipmi_probe(dev);
+ }
++>>>>>>> 66f44018300c (char: ipmi: Move MODULE_DEVICE_TABLE() to follow struct)
  
  static int ipmi_remove(struct platform_device *dev)
  {
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
