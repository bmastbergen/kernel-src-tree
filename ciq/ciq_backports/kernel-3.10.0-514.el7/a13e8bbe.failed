Drivers: hv: vmbus: Use a round-robin algorithm for picking the outgoing channel

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hv] vmbus: Use a round-robin algorithm for picking the outgoing channel (Vitaly Kuznetsov) [1321073]
Rebuild_FUZZ: 91.16%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit a13e8bbe851a96a0e78c2bd599bc34082fa697cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a13e8bbe.failed

The current algorithm for picking an outgoing channel was not distributing
the load well. Implement a simple round-robin scheme to ensure good
distribution of the outgoing traffic.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Reviewed-by: Long Li <longli@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit a13e8bbe851a96a0e78c2bd599bc34082fa697cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/channel_mgmt.c
diff --cc drivers/hv/channel_mgmt.c
index 226cd8906e67,611789139f9b..000000000000
--- a/drivers/hv/channel_mgmt.c
+++ b/drivers/hv/channel_mgmt.c
@@@ -287,8 -350,19 +287,9 @@@ static void vmbus_process_offer(struct 
  			}
  
  			newchannel->state = CHANNEL_OPEN_STATE;
+ 			channel->num_sc++;
  			if (channel->sc_creation_callback != NULL)
 -				/*
 -				 * We need to invoke the sub-channel creation
 -				 * callback; invoke this in a seperate work
 -				 * context since we are currently running on
 -				 * the global work context in which we handle
 -				 * messages from the host.
 -				 */
 -				INIT_WORK(&newchannel->work,
 -					  vmbus_sc_creation_cb);
 -				queue_work(newchannel->controlwq,
 -					   &newchannel->work);
 +				channel->sc_creation_callback(newchannel);
  
  			return;
  		}
@@@ -811,14 -869,24 +811,27 @@@ cleanup
  struct vmbus_channel *vmbus_get_outgoing_channel(struct vmbus_channel *primary)
  {
  	struct list_head *cur, *tmp;
 -	int cur_cpu;
 +	int cur_cpu = hv_context.vp_index[smp_processor_id()];
  	struct vmbus_channel *cur_channel;
  	struct vmbus_channel *outgoing_channel = primary;
- 	int cpu_distance, new_cpu_distance;
+ 	int next_channel;
+ 	int i = 1;
  
  	if (list_empty(&primary->sc_list))
  		return outgoing_channel;
  
++<<<<<<< HEAD
++=======
+ 	next_channel = primary->next_oc++;
+ 
+ 	if (next_channel > (primary->num_sc)) {
+ 		primary->next_oc = 0;
+ 		return outgoing_channel;
+ 	}
+ 
+ 	cur_cpu = hv_context.vp_index[get_cpu()];
+ 	put_cpu();
++>>>>>>> a13e8bbe851a (Drivers: hv: vmbus: Use a round-robin algorithm for picking the outgoing channel)
  	list_for_each_safe(cur, tmp, &primary->sc_list) {
  		cur_channel = list_entry(cur, struct vmbus_channel, sc_list);
  		if (cur_channel->state != CHANNEL_OPENED_STATE)
* Unmerged path drivers/hv/channel_mgmt.c
diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index e4dba9fde881..82cdae377829 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -740,6 +740,9 @@ struct vmbus_channel {
 	 * link up channels based on their CPU affinity.
 	 */
 	struct list_head percpu_list;
+
+	int num_sc;
+	int next_oc;
 };
 
 static inline void set_channel_read_state(struct vmbus_channel *c, bool state)
