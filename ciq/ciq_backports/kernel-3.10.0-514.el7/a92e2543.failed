KVM: x86: use hardware-compatible format for APIC ID register

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] kvm: use hardware-compatible format for APIC ID register (Radim Krcmar) [1273718]
Rebuild_FUZZ: 95.73%
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit a92e2543d6a8653a8ab45cf5df7ef07dafcf3f3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a92e2543.failed

We currently always shift APIC ID as if APIC was in xAPIC mode.
x2APIC mode wants to use more bits and storing a hardware-compabible
value is the the sanest option.

KVM API to set the lapic expects that bottom 8 bits of APIC ID are in
top 8 bits of APIC_ID register, so the register needs to be shifted in
x2APIC mode.

	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit a92e2543d6a8653a8ab45cf5df7ef07dafcf3f3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/lapic.c
#	arch/x86/kvm/lapic.h
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/lapic.c
index 2330983674b9,41089dbeeafc..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -228,9 -227,9 +228,9 @@@ static inline void apic_set_spiv(struc
  	}
  }
  
- static inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)
+ static inline void kvm_apic_set_xapic_id(struct kvm_lapic *apic, u8 id)
  {
 -	kvm_lapic_set_reg(apic, APIC_ID, id << 24);
 +	apic_set_reg(apic, APIC_ID, id << 24);
  	recalculate_apic_map(apic->vcpu->kvm);
  }
  
@@@ -244,8 -243,8 +244,13 @@@ static inline void kvm_apic_set_x2apic_
  {
  	u32 ldr = ((id >> 4) << 16) | (1 << (id & 0xf));
  
++<<<<<<< HEAD
 +	apic_set_reg(apic, APIC_ID, id << 24);
 +	apic_set_reg(apic, APIC_LDR, ldr);
++=======
+ 	kvm_lapic_set_reg(apic, APIC_ID, id);
+ 	kvm_lapic_set_reg(apic, APIC_LDR, ldr);
++>>>>>>> a92e2543d6a8 (KVM: x86: use hardware-compatible format for APIC ID register)
  	recalculate_apic_map(apic->vcpu->kvm);
  }
  
@@@ -1673,34 -1762,35 +1672,39 @@@ void kvm_lapic_reset(struct kvm_vcpu *v
  	/* Stop the timer in case it's a reset to an active apic */
  	hrtimer_cancel(&apic->lapic_timer.timer);
  
++<<<<<<< HEAD
 +	kvm_apic_set_id(apic, vcpu->vcpu_id);
++=======
+ 	if (!init_event)
+ 		kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
++>>>>>>> a92e2543d6a8 (KVM: x86: use hardware-compatible format for APIC ID register)
  	kvm_apic_set_version(apic->vcpu);
  
 -	for (i = 0; i < KVM_APIC_LVT_NUM; i++)
 -		kvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);
 +	for (i = 0; i < APIC_LVT_NUM; i++)
 +		apic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);
  	apic_update_lvtt(apic);
  	if (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_LINT0_REENABLED))
 -		kvm_lapic_set_reg(apic, APIC_LVT0,
 +		apic_set_reg(apic, APIC_LVT0,
  			     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));
 -	apic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));
 +	apic_manage_nmi_watchdog(apic, kvm_apic_get_reg(apic, APIC_LVT0));
  
 -	kvm_lapic_set_reg(apic, APIC_DFR, 0xffffffffU);
 +	apic_set_reg(apic, APIC_DFR, 0xffffffffU);
  	apic_set_spiv(apic, 0xff);
 -	kvm_lapic_set_reg(apic, APIC_TASKPRI, 0);
 +	apic_set_reg(apic, APIC_TASKPRI, 0);
  	if (!apic_x2apic_mode(apic))
  		kvm_apic_set_ldr(apic, 0);
 -	kvm_lapic_set_reg(apic, APIC_ESR, 0);
 -	kvm_lapic_set_reg(apic, APIC_ICR, 0);
 -	kvm_lapic_set_reg(apic, APIC_ICR2, 0);
 -	kvm_lapic_set_reg(apic, APIC_TDCR, 0);
 -	kvm_lapic_set_reg(apic, APIC_TMICT, 0);
 +	apic_set_reg(apic, APIC_ESR, 0);
 +	apic_set_reg(apic, APIC_ICR, 0);
 +	apic_set_reg(apic, APIC_ICR2, 0);
 +	apic_set_reg(apic, APIC_TDCR, 0);
 +	apic_set_reg(apic, APIC_TMICT, 0);
  	for (i = 0; i < 8; i++) {
 -		kvm_lapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);
 -		kvm_lapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);
 -		kvm_lapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);
 +		apic_set_reg(apic, APIC_IRR + 0x10 * i, 0);
 +		apic_set_reg(apic, APIC_ISR + 0x10 * i, 0);
 +		apic_set_reg(apic, APIC_TMR + 0x10 * i, 0);
  	}
 -	apic->irr_pending = vcpu->arch.apicv_active;
 -	apic->isr_count = vcpu->arch.apicv_active ? 1 : 0;
 +	apic->irr_pending = kvm_apic_vid_enabled(vcpu->kvm);
 +	apic->isr_count = kvm_x86_ops->hwapic_isr_update ? 1 : 0;
  	apic->highest_isr_cache = -1;
  	update_divide_count(apic);
  	atomic_set(&apic->lapic_timer.pending, 0);
@@@ -1911,17 -2030,24 +1941,26 @@@ int kvm_apic_set_state(struct kvm_vcpu 
  	update_divide_count(apic);
  	start_apic_timer(apic);
  	apic->irr_pending = true;
 -	apic->isr_count = vcpu->arch.apicv_active ?
 +	apic->isr_count = kvm_x86_ops->hwapic_isr_update ?
  				1 : count_vectors(apic->regs + APIC_ISR);
  	apic->highest_isr_cache = -1;
 -	if (vcpu->arch.apicv_active) {
 -		if (kvm_x86_ops->apicv_post_state_restore)
 -			kvm_x86_ops->apicv_post_state_restore(vcpu);
 +	if (kvm_x86_ops->hwapic_irr_update)
  		kvm_x86_ops->hwapic_irr_update(vcpu,
  				apic_find_highest_irr(apic));
 -		kvm_x86_ops->hwapic_isr_update(vcpu,
 +	if (unlikely(kvm_x86_ops->hwapic_isr_update))
 +		kvm_x86_ops->hwapic_isr_update(vcpu->kvm,
  				apic_find_highest_isr(apic));
 -	}
  	kvm_make_request(KVM_REQ_EVENT, vcpu);
++<<<<<<< HEAD
 +	kvm_rtc_eoi_tracking_restore_one(vcpu);
++=======
+ 	if (ioapic_in_kernel(vcpu->kvm))
+ 		kvm_rtc_eoi_tracking_restore_one(vcpu);
+ 
+ 	vcpu->arch.apic_arb_prio = 0;
+ 
+ 	return 0;
++>>>>>>> a92e2543d6a8 (KVM: x86: use hardware-compatible format for APIC ID register)
  }
  
  void __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)
diff --cc arch/x86/kvm/lapic.h
index 260439170d7f,f60d01c29d51..000000000000
--- a/arch/x86/kvm/lapic.h
+++ b/arch/x86/kvm/lapic.h
@@@ -158,7 -197,18 +158,22 @@@ static inline bool kvm_apic_has_events(
  
  static inline int kvm_lapic_latched_init(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	return kvm_vcpu_has_lapic(vcpu) && test_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);
++=======
+ 	return lapic_in_kernel(vcpu) && test_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);
+ }
+ 
+ static inline u32 kvm_apic_id(struct kvm_lapic *apic)
+ {
+ 	/* To avoid a race between apic_base and following APIC_ID update when
+ 	 * switching to x2apic_mode, the x2apic mode returns initial x2apic id.
+ 	 */
+ 	if (apic_x2apic_mode(apic))
+ 		return apic->vcpu->vcpu_id;
+ 
+ 	return kvm_lapic_get_reg(apic, APIC_ID) >> 24;
++>>>>>>> a92e2543d6a8 (KVM: x86: use hardware-compatible format for APIC ID register)
  }
  
  bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector);
diff --cc arch/x86/kvm/x86.c
index 733894b44f8d,b6e402d16e0c..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -3049,10 -2776,10 +3049,17 @@@ void kvm_arch_vcpu_put(struct kvm_vcpu 
  static int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,
  				    struct kvm_lapic_state *s)
  {
++<<<<<<< HEAD
 +	kvm_x86_ops->sync_pir_to_irr(vcpu);
 +	memcpy(s->regs, vcpu->arch.apic->regs, sizeof *s);
 +
 +	return 0;
++=======
+ 	if (vcpu->arch.apicv_active)
+ 		kvm_x86_ops->sync_pir_to_irr(vcpu);
+ 
+ 	return kvm_apic_get_state(vcpu, s);
++>>>>>>> a92e2543d6a8 (KVM: x86: use hardware-compatible format for APIC ID register)
  }
  
  static int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,
* Unmerged path arch/x86/kvm/lapic.c
* Unmerged path arch/x86/kvm/lapic.h
* Unmerged path arch/x86/kvm/x86.c
