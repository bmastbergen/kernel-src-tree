dax: don't use set_huge_zero_page()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
commit d295e3415a88ae63a37a22652808b20c7fcb970e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d295e341.failed

This is another place where DAX assumed that pgtable_t was a pointer.
Open code the important parts of set_huge_zero_page() in DAX and make
set_huge_zero_page() static again.

	Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit d295e3415a88ae63a37a22652808b20c7fcb970e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
#	include/linux/huge_mm.h
diff --cc include/linux/huge_mm.h
index bc76ace62045,ecb080d6ff42..000000000000
--- a/include/linux/huge_mm.h
+++ b/include/linux/huge_mm.h
@@@ -154,6 -150,20 +154,23 @@@ static inline int hpage_nr_pages(struc
  extern int do_huge_pmd_numa_page(struct mm_struct *mm, struct vm_area_struct *vma,
  				unsigned long addr, pmd_t pmd, pmd_t *pmdp);
  
++<<<<<<< HEAD
++=======
+ extern struct page *huge_zero_page;
+ 
+ static inline bool is_huge_zero_page(struct page *page)
+ {
+ 	return ACCESS_ONCE(huge_zero_page) == page;
+ }
+ 
+ static inline bool is_huge_zero_pmd(pmd_t pmd)
+ {
+ 	return is_huge_zero_page(pmd_page(pmd));
+ }
+ 
+ struct page *get_huge_zero_page(void);
+ 
++>>>>>>> d295e3415a88 (dax: don't use set_huge_zero_page())
  #else /* CONFIG_TRANSPARENT_HUGEPAGE */
  #define HPAGE_PMD_SHIFT ({ BUILD_BUG(); 0; })
  #define HPAGE_PMD_MASK ({ BUILD_BUG(); 0; })
* Unmerged path fs/dax.c
* Unmerged path fs/dax.c
* Unmerged path include/linux/huge_mm.h
