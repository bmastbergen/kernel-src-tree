HID: i2c-hid: use generic .request() implementation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hid] i2c-hid: use generic .request() implementation (Benjamin Tissoires) [1311883]
Rebuild_FUZZ: 94.85%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 649f94790314b502bc4e905e005d89c3b693d60a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/649f9479.failed

Having our own .request() implementation does not give anything,
so use the generic binding.

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 649f94790314b502bc4e905e005d89c3b693d60a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/i2c-hid/i2c-hid.c
diff --cc drivers/hid/i2c-hid/i2c-hid.c
index 73c15796e449,5308656eec2e..000000000000
--- a/drivers/hid/i2c-hid/i2c-hid.c
+++ b/drivers/hid/i2c-hid/i2c-hid.c
@@@ -580,34 -587,40 +580,71 @@@ static int i2c_hid_output_raw_report(st
  	return ret;
  }
  
++<<<<<<< HEAD
 +static void i2c_hid_request(struct hid_device *hid, struct hid_report *rep,
 +		int reqtype)
 +{
 +	struct i2c_client *client = hid->driver_data;
 +	char *buf;
 +	int ret;
 +	int len = i2c_hid_get_report_length(rep) - 2;
 +
 +	buf = hid_alloc_report_buf(rep, GFP_KERNEL);
 +	if (!buf)
 +		return;
 +
 +	switch (reqtype) {
 +	case HID_REQ_GET_REPORT:
 +		ret = i2c_hid_get_raw_report(hid, rep->id, buf, len, rep->type);
 +		if (ret < 0)
 +			dev_err(&client->dev, "%s: unable to get report: %d\n",
 +				__func__, ret);
 +		else
 +			hid_input_report(hid, rep->type, buf, ret, 0);
 +		break;
 +	case HID_REQ_SET_REPORT:
 +		hid_output_report(rep, buf);
 +		i2c_hid_output_raw_report(hid, buf, len, rep->type);
 +		break;
 +	}
 +
 +	kfree(buf);
++=======
+ static int __i2c_hid_output_raw_report(struct hid_device *hid, __u8 *buf,
+ 		size_t count, unsigned char report_type)
+ {
+ 	struct i2c_client *client = hid->driver_data;
+ 	struct i2c_hid *ihid = i2c_get_clientdata(client);
+ 	bool data = true; /* SET_REPORT */
+ 
+ 	if (report_type == HID_OUTPUT_REPORT)
+ 		data = le16_to_cpu(ihid->hdesc.wMaxOutputLength) == 0;
+ 
+ 	return i2c_hid_output_raw_report(hid, buf, count, report_type, data);
+ }
+ 
+ static int i2c_hid_output_report(struct hid_device *hid, __u8 *buf,
+ 		size_t count)
+ {
+ 	return i2c_hid_output_raw_report(hid, buf, count, HID_OUTPUT_REPORT,
+ 			false);
+ }
+ 
+ static int i2c_hid_raw_request(struct hid_device *hid, unsigned char reportnum,
+ 			       __u8 *buf, size_t len, unsigned char rtype,
+ 			       int reqtype)
+ {
+ 	switch (reqtype) {
+ 	case HID_REQ_GET_REPORT:
+ 		return i2c_hid_get_raw_report(hid, reportnum, buf, len, rtype);
+ 	case HID_REQ_SET_REPORT:
+ 		if (buf[0] != reportnum)
+ 			return -EINVAL;
+ 		return i2c_hid_output_raw_report(hid, buf, len, rtype, true);
+ 	default:
+ 		return -EIO;
+ 	}
++>>>>>>> 649f94790314 (HID: i2c-hid: use generic .request() implementation)
  }
  
  static int i2c_hid_parse(struct hid_device *hid)
@@@ -766,7 -779,8 +803,12 @@@ static struct hid_ll_driver i2c_hid_ll_
  	.open = i2c_hid_open,
  	.close = i2c_hid_close,
  	.power = i2c_hid_power,
++<<<<<<< HEAD
 +	.request = i2c_hid_request,
++=======
+ 	.output_report = i2c_hid_output_report,
+ 	.raw_request = i2c_hid_raw_request,
++>>>>>>> 649f94790314 (HID: i2c-hid: use generic .request() implementation)
  };
  
  static int i2c_hid_init_irq(struct i2c_client *client)
* Unmerged path drivers/hid/i2c-hid/i2c-hid.c
