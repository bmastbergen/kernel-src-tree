xprtrdma: Remove last ib_reg_phys_mr() call site

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit e531dcabec8dc2ee141aab01ddf20ca87c52d916
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e531dcab.failed

All HCA providers have an ib_get_dma_mr() verb. Thus
rpcrdma_ia_open() will either grab the device's local_dma_key if one
is available, or it will call ib_get_dma_mr(). If ib_get_dma_mr()
fails, rpcrdma_ia_open() fails and no transport is created.

Therefore execution never reaches the ib_reg_phys_mr() call site in
rpcrdma_register_internal(), so it can be removed.

The remaining logic in rpcrdma_{de}register_internal() is folded
into rpcrdma_{alloc,free}_regbuf().

This is clean up only. No behavior change is expected.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Reviewed-by: Devesh Sharma <devesh.sharma@avagotech.com>
Reviewed-By: Sagi Grimberg <sagig@mellanox.com>
	Tested-by: Devesh Sharma <devesh.sharma@avagotech.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit e531dcabec8dc2ee141aab01ddf20ca87c52d916)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/verbs.c
diff --cc net/sunrpc/xprtrdma/verbs.c
index 93940b99263d,da184f98fdf9..000000000000
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@@ -1465,75 -1229,6 +1465,78 @@@ rpcrdma_mapping_error(struct rpcrdma_mr
  		(unsigned long long)seg->mr_dma, seg->mr_dmalen);
  }
  
++<<<<<<< HEAD
 +static int
 +rpcrdma_register_internal(struct rpcrdma_ia *ia, void *va, int len,
 +				struct ib_mr **mrp, struct ib_sge *iov)
 +{
 +	struct ib_phys_buf ipb;
 +	struct ib_mr *mr;
 +	int rc;
 +
 +	/*
 +	 * All memory passed here was kmalloc'ed, therefore phys-contiguous.
 +	 */
 +	iov->addr = ib_dma_map_single(ia->ri_id->device,
 +			va, len, DMA_BIDIRECTIONAL);
 +	if (ib_dma_mapping_error(ia->ri_id->device, iov->addr))
 +		return -ENOMEM;
 +
 +	iov->length = len;
 +
 +	if (ia->ri_have_dma_lkey) {
 +		*mrp = NULL;
 +		iov->lkey = ia->ri_dma_lkey;
 +		return 0;
 +	} else if (ia->ri_bind_mem != NULL) {
 +		*mrp = NULL;
 +		iov->lkey = ia->ri_bind_mem->lkey;
 +		return 0;
 +	}
 +
 +	ipb.addr = iov->addr;
 +	ipb.size = iov->length;
 +	mr = ib_reg_phys_mr(ia->ri_pd, &ipb, 1,
 +			IB_ACCESS_LOCAL_WRITE, &iov->addr);
 +
 +	dprintk("RPC:       %s: phys convert: 0x%llx "
 +			"registered 0x%llx length %d\n",
 +			__func__, (unsigned long long)ipb.addr,
 +			(unsigned long long)iov->addr, len);
 +
 +	if (IS_ERR(mr)) {
 +		*mrp = NULL;
 +		rc = PTR_ERR(mr);
 +		dprintk("RPC:       %s: failed with %i\n", __func__, rc);
 +	} else {
 +		*mrp = mr;
 +		iov->lkey = mr->lkey;
 +		rc = 0;
 +	}
 +
 +	return rc;
 +}
 +
 +static int
 +rpcrdma_deregister_internal(struct rpcrdma_ia *ia,
 +				struct ib_mr *mr, struct ib_sge *iov)
 +{
 +	int rc;
 +
 +	ib_dma_unmap_single(ia->ri_id->device,
 +			iov->addr, iov->length, DMA_BIDIRECTIONAL);
 +
 +	if (NULL == mr)
 +		return 0;
 +
 +	rc = ib_dereg_mr(mr);
 +	if (rc)
 +		dprintk("RPC:       %s: ib_dereg_mr failed %i\n", __func__, rc);
 +	return rc;
 +}
 +
++=======
++>>>>>>> e531dcabec8d (xprtrdma: Remove last ib_reg_phys_mr() call site)
  /**
   * rpcrdma_alloc_regbuf - kmalloc and register memory for SEND/RECV buffers
   * @ia: controlling rpcrdma_ia
* Unmerged path net/sunrpc/xprtrdma/verbs.c
diff --git a/net/sunrpc/xprtrdma/xprt_rdma.h b/net/sunrpc/xprtrdma/xprt_rdma.h
index 5689008ef62a..d73348438b0a 100644
--- a/net/sunrpc/xprtrdma/xprt_rdma.h
+++ b/net/sunrpc/xprtrdma/xprt_rdma.h
@@ -118,7 +118,6 @@ struct rpcrdma_ep {
 struct rpcrdma_regbuf {
 	size_t			rg_size;
 	struct rpcrdma_req	*rg_owner;
-	struct ib_mr		*rg_mr;
 	struct ib_sge		rg_iov;
 	__be32			rg_base[0] __attribute__ ((aligned(256)));
 };
