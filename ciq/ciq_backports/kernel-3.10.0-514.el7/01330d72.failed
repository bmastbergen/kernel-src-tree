perf/x86: Allow zero PEBS status with only single active event

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Andi Kleen <ak@linux.intel.com>
commit 01330d7288e0050c5aaabc558059ff91589e67cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/01330d72.failed

Normally we drop PEBS events with a zero status field. But when
there is only a single PEBS event active we can assume the
PEBS record is for that event. The PEBS buffer is always flushed
when PEBS events are disabled, so there is no risk of mishandling
state PEBS records this way.

	Signed-off-by: Andi Kleen <ak@linux.intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
Link: http://lkml.kernel.org/r/1449177740-5422-2-git-send-email-andi@firstfloor.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 01330d7288e0050c5aaabc558059ff91589e67cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/perf_event_intel_ds.c
diff --cc arch/x86/kernel/cpu/perf_event_intel_ds.c
index 4f06fbb202c7,cd1993e46d19..000000000000
--- a/arch/x86/kernel/cpu/perf_event_intel_ds.c
+++ b/arch/x86/kernel/cpu/perf_event_intel_ds.c
@@@ -1151,8 -1216,33 +1151,36 @@@ static void intel_pmu_drain_pebs_nhm(st
  
  	for (at = base; at < top; at += x86_pmu.pebs_record_size) {
  		struct pebs_record_nhm *p = at;
 -		u64 pebs_status;
  
++<<<<<<< HEAD
 +		bit = find_first_bit((unsigned long *)&p->status,
++=======
+ 		/* PEBS v3 has accurate status bits */
+ 		if (x86_pmu.intel_cap.pebs_format >= 3) {
+ 			for_each_set_bit(bit, (unsigned long *)&p->status,
+ 					 MAX_PEBS_EVENTS)
+ 				counts[bit]++;
+ 
+ 			continue;
+ 		}
+ 
+ 		pebs_status = p->status & cpuc->pebs_enabled;
+ 		pebs_status &= (1ULL << x86_pmu.max_pebs_events) - 1;
+ 
+ 		/*
+ 		 * On some CPUs the PEBS status can be zero when PEBS is
+ 		 * racing with clearing of GLOBAL_STATUS.
+ 		 *
+ 		 * Normally we would drop that record, but in the
+ 		 * case when there is only a single active PEBS event
+ 		 * we can assume it's for that event.
+ 		 */
+ 		if (!pebs_status && cpuc->pebs_enabled &&
+ 			!(cpuc->pebs_enabled & (cpuc->pebs_enabled-1)))
+ 			pebs_status = cpuc->pebs_enabled;
+ 
+ 		bit = find_first_bit((unsigned long *)&pebs_status,
++>>>>>>> 01330d7288e0 (perf/x86: Allow zero PEBS status with only single active event)
  					x86_pmu.max_pebs_events);
  		if (bit >= x86_pmu.max_pebs_events)
  			continue;
* Unmerged path arch/x86/kernel/cpu/perf_event_intel_ds.c
