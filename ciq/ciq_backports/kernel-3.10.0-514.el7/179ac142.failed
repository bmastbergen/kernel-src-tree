megaraid_sas: Reply Descriptor Post Queue (RDPQ) support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sumit Saxena <sumit.saxena@avagotech.com>
commit 179ac14291a0e1cf8c2b2dfedce7c5af66696cc9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/179ac142.failed

This patch will create a reply queue pool for each MSI-X index and will
provide an array of base addresses instead of the single address of
legacy mode. Using this new interface the driver can support higher
queue depths through scattered DMA pools.

If array mode is not supported driver will fall back to the legacy
method of reply pool allocation. This limits controller queue depth to
1K max. To enable a queue depth of more than 1K driver requires firmware
to support array mode and scratch_pad3 will provide the new queue depth
value.

When RDPQ is used, downgrading to an older firmware release should not
be permitted. This may cause firmware fault and is not supported.

	Signed-off-by: Kashyap Desai <kashyap.desai@avagotech.com>
	Signed-off-by: Sumit Saxena <sumit.saxena@avagotech.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 179ac14291a0e1cf8c2b2dfedce7c5af66696cc9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas_base.c
#	drivers/scsi/megaraid/megaraid_sas_fusion.c
diff --cc drivers/scsi/megaraid/megaraid_sas_base.c
index b60f8ef53c66,8df58c2b08ec..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@@ -4787,32 -5075,30 +4791,59 @@@ static int megasas_init_fw(struct megas
  		scratch_pad_2 = readl
  			(&instance->reg_set->outbound_scratch_pad_2);
  		/* Check max MSI-X vectors */
++<<<<<<< HEAD
 +		if ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||
 +		    (instance->pdev->device == PCI_DEVICE_ID_LSI_PLASMA)) {
 +			instance->msix_vectors = (scratch_pad_2
 +				& MR_MAX_REPLY_QUEUES_OFFSET) + 1;
 +			fw_msix_count = instance->msix_vectors;
 +			if (msix_vectors)
 +				instance->msix_vectors =
 +					min(msix_vectors,
 +					    instance->msix_vectors);
 +		} else if ((instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER)
 +			|| (instance->pdev->device == PCI_DEVICE_ID_LSI_FURY)) {
 +			/* Invader/Fury supports more than 8 MSI-X */
 +			instance->msix_vectors = ((scratch_pad_2
 +				& MR_MAX_REPLY_QUEUES_EXT_OFFSET)
 +				>> MR_MAX_REPLY_QUEUES_EXT_OFFSET_SHIFT) + 1;
 +			fw_msix_count = instance->msix_vectors;
 +			/* Save 1-15 reply post index address to local memory
 +			 * Index 0 is already saved from reg offset
 +			 * MPI2_REPLY_POST_HOST_INDEX_OFFSET
 +			 */
 +			for (loop = 1; loop < MR_MAX_MSIX_REG_ARRAY; loop++) {
 +				instance->reply_post_host_index_addr[loop] =
 +					(u32 __iomem *)
 +					((u8 __iomem *)instance->reg_set +
 +					MPI2_SUP_REPLY_POST_HOST_INDEX_OFFSET
 +					+ (loop * 0x10));
++=======
+ 		if (fusion) {
+ 			if (fusion->adapter_type == THUNDERBOLT_SERIES) { /* Thunderbolt Series*/
+ 				instance->msix_vectors = (scratch_pad_2
+ 					& MR_MAX_REPLY_QUEUES_OFFSET) + 1;
+ 				fw_msix_count = instance->msix_vectors;
+ 			} else { /* Invader series supports more than 8 MSI-x vectors*/
+ 				instance->msix_vectors = ((scratch_pad_2
+ 					& MR_MAX_REPLY_QUEUES_EXT_OFFSET)
+ 					>> MR_MAX_REPLY_QUEUES_EXT_OFFSET_SHIFT) + 1;
+ 				if (rdpq_enable)
+ 					instance->is_rdpq = (scratch_pad_2 & MR_RDPQ_MODE_OFFSET) ?
+ 								1 : 0;
+ 				fw_msix_count = instance->msix_vectors;
+ 				/* Save 1-15 reply post index address to local memory
+ 				 * Index 0 is already saved from reg offset
+ 				 * MPI2_REPLY_POST_HOST_INDEX_OFFSET
+ 				 */
+ 				for (loop = 1; loop < MR_MAX_MSIX_REG_ARRAY; loop++) {
+ 					instance->reply_post_host_index_addr[loop] =
+ 						(u32 __iomem *)
+ 						((u8 __iomem *)instance->reg_set +
+ 						MPI2_SUP_REPLY_POST_HOST_INDEX_OFFSET
+ 						+ (loop * 0x10));
+ 				}
++>>>>>>> 179ac14291a0 (megaraid_sas: Reply Descriptor Post Queue (RDPQ) support)
  			}
  			if (msix_vectors)
  				instance->msix_vectors = min(msix_vectors,
diff --cc drivers/scsi/megaraid/megaraid_sas_fusion.c
index a09ae37a613c,1351cae6acff..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@@ -205,54 -207,6 +207,57 @@@ megasas_fire_cmd_fusion(struct megasas_
  #endif
  }
  
++<<<<<<< HEAD
 +
 +/**
 + * megasas_teardown_frame_pool_fusion -	Destroy the cmd frame DMA pool
 + * @instance:				Adapter soft state
 + */
 +static void megasas_teardown_frame_pool_fusion(
 +	struct megasas_instance *instance)
 +{
 +	int i;
 +	struct fusion_context *fusion = instance->ctrl_context;
 +
 +	u16 max_cmd = instance->max_fw_cmds;
 +
 +	struct megasas_cmd_fusion *cmd;
 +
 +	if (!fusion->sg_dma_pool || !fusion->sense_dma_pool) {
 +		printk(KERN_ERR "megasas: dma pool is null. SG Pool %p, "
 +		       "sense pool : %p\n", fusion->sg_dma_pool,
 +		       fusion->sense_dma_pool);
 +		return;
 +	}
 +
 +	/*
 +	 * Return all frames to pool
 +	 */
 +	for (i = 0; i < max_cmd; i++) {
 +
 +		cmd = fusion->cmd_list[i];
 +
 +		if (cmd->sg_frame)
 +			pci_pool_free(fusion->sg_dma_pool, cmd->sg_frame,
 +				      cmd->sg_frame_phys_addr);
 +
 +		if (cmd->sense)
 +			pci_pool_free(fusion->sense_dma_pool, cmd->sense,
 +				      cmd->sense_phys_addr);
 +	}
 +
 +	/*
 +	 * Now destroy the pool itself
 +	 */
 +	pci_pool_destroy(fusion->sg_dma_pool);
 +	pci_pool_destroy(fusion->sense_dma_pool);
 +
 +	fusion->sg_dma_pool = NULL;
 +	fusion->sense_dma_pool = NULL;
 +}
 +
++=======
++>>>>>>> 179ac14291a0 (megaraid_sas: Reply Descriptor Post Queue (RDPQ) support)
  /**
   * megasas_free_cmds_fusion -	Free all the cmds in the free cmd pool
   * @instance:		Adapter soft state
@@@ -321,27 -285,17 +336,37 @@@ static int megasas_create_sg_sense_fusi
  	max_cmd = instance->max_fw_cmds;
  
  
- 	/*
- 	 * Use DMA pool facility provided by PCI layer
- 	 */
+ 	fusion->sg_dma_pool =
+ 			pci_pool_create("mr_sg", instance->pdev,
+ 				instance->max_chain_frame_sz, 4, 0);
+ 	/* SCSI_SENSE_BUFFERSIZE  = 96 bytes */
+ 	fusion->sense_dma_pool =
+ 			pci_pool_create("mr_sense", instance->pdev,
+ 				SCSI_SENSE_BUFFERSIZE, 64, 0);
  
++<<<<<<< HEAD
 +	fusion->sg_dma_pool = pci_pool_create("sg_pool_fusion", instance->pdev,
 +						instance->max_chain_frame_sz,
 +						4, 0);
 +	if (!fusion->sg_dma_pool) {
 +		printk(KERN_DEBUG "megasas: failed to setup request pool "
 +		       "fusion\n");
 +		return -ENOMEM;
 +	}
 +	fusion->sense_dma_pool = pci_pool_create("sense pool fusion",
 +						 instance->pdev,
 +						 SCSI_SENSE_BUFFERSIZE, 64, 0);
 +
 +	if (!fusion->sense_dma_pool) {
 +		printk(KERN_DEBUG "megasas: failed to setup sense pool "
 +		       "fusion\n");
 +		pci_pool_destroy(fusion->sg_dma_pool);
 +		fusion->sg_dma_pool = NULL;
++=======
+ 	if (!fusion->sense_dma_pool || !fusion->sg_dma_pool) {
+ 		dev_err(&instance->pdev->dev,
+ 			"Failed from %s %d\n",  __func__, __LINE__);
++>>>>>>> 179ac14291a0 (megaraid_sas: Reply Descriptor Post Queue (RDPQ) support)
  		return -ENOMEM;
  	}
  
@@@ -349,22 -303,15 +374,20 @@@
  	 * Allocate and attach a frame to each of the commands in cmd_list
  	 */
  	for (i = 0; i < max_cmd; i++) {
- 
  		cmd = fusion->cmd_list[i];
- 
  		cmd->sg_frame = pci_pool_alloc(fusion->sg_dma_pool,
- 					       GFP_KERNEL,
- 					       &cmd->sg_frame_phys_addr);
+ 					GFP_KERNEL, &cmd->sg_frame_phys_addr);
  
  		cmd->sense = pci_pool_alloc(fusion->sense_dma_pool,
- 					    GFP_KERNEL, &cmd->sense_phys_addr);
- 		/*
- 		 * megasas_teardown_frame_pool_fusion() takes care of freeing
- 		 * whatever has been allocated
- 		 */
+ 					GFP_KERNEL, &cmd->sense_phys_addr);
  		if (!cmd->sg_frame || !cmd->sense) {
++<<<<<<< HEAD
 +			printk(KERN_DEBUG "megasas: pci_pool_alloc failed\n");
 +			megasas_teardown_frame_pool_fusion(instance);
++=======
+ 			dev_err(&instance->pdev->dev,
+ 				"Failed from %s %d\n",  __func__, __LINE__);
++>>>>>>> 179ac14291a0 (megaraid_sas: Reply Descriptor Post Queue (RDPQ) support)
  			return -ENOMEM;
  		}
  	}
@@@ -399,103 -550,26 +626,114 @@@ megasas_alloc_cmds_fusion(struct megasa
  	dma_addr_t io_req_base_phys;
  	u8 *io_req_base;
  
+ 
  	fusion = instance->ctrl_context;
  
- 	max_cmd = instance->max_fw_cmds;
+ 	if (megasas_alloc_cmdlist_fusion(instance))
+ 		goto fail_exit;
  
- 	fusion->req_frames_desc =
- 		dma_alloc_coherent(&instance->pdev->dev,
- 				   fusion->request_alloc_sz,
- 				   &fusion->req_frames_desc_phys, GFP_KERNEL);
+ 	if (megasas_alloc_request_fusion(instance))
+ 		goto fail_exit;
  
++<<<<<<< HEAD
 +	if (!fusion->req_frames_desc) {
 +		printk(KERN_ERR "megasas; Could not allocate memory for "
 +		       "request_frames\n");
 +		goto fail_req_desc;
 +	}
++=======
+ 	if (instance->is_rdpq) {
+ 		if (megasas_alloc_rdpq_fusion(instance))
+ 			goto fail_exit;
+ 	} else
+ 		if (megasas_alloc_reply_fusion(instance))
+ 			goto fail_exit;
++>>>>>>> 179ac14291a0 (megaraid_sas: Reply Descriptor Post Queue (RDPQ) support)
 +
- 	count = instance->msix_vectors > 0 ? instance->msix_vectors : 1;
- 	fusion->reply_frames_desc_pool =
- 		pci_pool_create("reply_frames pool", instance->pdev,
- 				fusion->reply_alloc_sz * count, 16, 0);
  
++<<<<<<< HEAD
 +	if (!fusion->reply_frames_desc_pool) {
 +		printk(KERN_ERR "megasas; Could not allocate memory for "
 +		       "reply_frame pool\n");
 +		goto fail_reply_desc;
 +	}
 +
 +	fusion->reply_frames_desc =
 +		pci_pool_alloc(fusion->reply_frames_desc_pool, GFP_KERNEL,
 +			       &fusion->reply_frames_desc_phys);
 +	if (!fusion->reply_frames_desc) {
 +		printk(KERN_ERR "megasas; Could not allocate memory for "
 +		       "reply_frame pool\n");
 +		pci_pool_destroy(fusion->reply_frames_desc_pool);
 +		goto fail_reply_desc;
 +	}
 +
 +	reply_desc = fusion->reply_frames_desc;
 +	for (i = 0; i < fusion->reply_q_depth * count; i++, reply_desc++)
 +		reply_desc->Words = cpu_to_le64(ULLONG_MAX);
 +
 +	io_frames_sz = fusion->io_frames_alloc_sz;
 +
 +	fusion->io_request_frames_pool =
 +		pci_pool_create("io_request_frames pool", instance->pdev,
 +				fusion->io_frames_alloc_sz, 16, 0);
 +
 +	if (!fusion->io_request_frames_pool) {
 +		printk(KERN_ERR "megasas: Could not allocate memory for "
 +		       "io_request_frame pool\n");
 +		goto fail_io_frames;
 +	}
 +
 +	fusion->io_request_frames =
 +		pci_pool_alloc(fusion->io_request_frames_pool, GFP_KERNEL,
 +			       &fusion->io_request_frames_phys);
 +	if (!fusion->io_request_frames) {
 +		printk(KERN_ERR "megasas: Could not allocate memory for "
 +		       "io_request_frames frames\n");
 +		pci_pool_destroy(fusion->io_request_frames_pool);
 +		goto fail_io_frames;
 +	}
 +
 +	/*
 +	 * fusion->cmd_list is an array of struct megasas_cmd_fusion pointers.
 +	 * Allocate the dynamic array first and then allocate individual
 +	 * commands.
 +	 */
 +	fusion->cmd_list = kzalloc(sizeof(struct megasas_cmd_fusion *)
 +				   * max_cmd, GFP_KERNEL);
 +
 +	if (!fusion->cmd_list) {
 +		printk(KERN_DEBUG "megasas: out of memory. Could not alloc "
 +		       "memory for cmd_list_fusion\n");
 +		goto fail_cmd_list;
 +	}
 +
 +	max_cmd = instance->max_fw_cmds;
 +	for (i = 0; i < max_cmd; i++) {
 +		fusion->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd_fusion),
 +					      GFP_KERNEL);
 +		if (!fusion->cmd_list[i]) {
 +			printk(KERN_ERR "Could not alloc cmd list fusion\n");
 +
 +			for (j = 0; j < i; j++)
 +				kfree(fusion->cmd_list[j]);
 +
 +			kfree(fusion->cmd_list);
 +			fusion->cmd_list = NULL;
 +			goto fail_cmd_list;
 +		}
 +	}
  
 +	/* The first 256 bytes (SMID 0) is not used. Don't add to cmd list */
 +	io_req_base = fusion->io_request_frames +
 +		MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE;
 +	io_req_base_phys = fusion->io_request_frames_phys +
 +		MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE;
++=======
+ 	/* The first 256 bytes (SMID 0) is not used. Don't add to the cmd list */
+ 	io_req_base = fusion->io_request_frames + MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE;
+ 	io_req_base_phys = fusion->io_request_frames_phys + MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE;
++>>>>>>> 179ac14291a0 (megaraid_sas: Reply Descriptor Post Queue (RDPQ) support)
  
  	/*
  	 * Add all the commands to command pool (fusion->cmd_pool)
@@@ -520,14 -594,8 +758,19 @@@
  		cmd->io_request_phys_addr = io_req_base_phys + offset;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * Create a frame pool and assign one frame to each cmd
 +	 */
 +	if (megasas_create_frame_pool_fusion(instance)) {
 +		printk(KERN_DEBUG "megasas: Error creating frame DMA pool\n");
 +		megasas_free_cmds_fusion(instance);
 +		goto fail_req_desc;
 +	}
++=======
+ 	if (megasas_create_sg_sense_fusion(instance))
+ 		goto fail_exit;
++>>>>>>> 179ac14291a0 (megaraid_sas: Reply Descriptor Post Queue (RDPQ) support)
  
  	return 0;
  
diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h
index d4c399b43165..8730ee76ba0b 100644
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@ -152,6 +152,7 @@
 #define MFI_RESET_FLAGS				MFI_INIT_READY| \
 						MFI_INIT_MFIMODE| \
 						MFI_INIT_ABORT
+#define MPI2_IOCINIT_MSGFLAG_RDPQ_ARRAY_MODE    (0x01)
 
 /*
  * MFI frame flags
@@ -1154,6 +1155,7 @@ enum MR_SCSI_CMD_TYPE {
 #define MR_MAX_REPLY_QUEUES_EXT_OFFSET          0X003FC000
 #define MR_MAX_REPLY_QUEUES_EXT_OFFSET_SHIFT    14
 #define MR_MAX_MSIX_REG_ARRAY                   16
+#define MR_RDPQ_MODE_OFFSET			0X00800000
 /*
 * register set for both 1068 and 1078 controllers
 * structure extended for 1078 registers
@@ -1193,8 +1195,9 @@ struct megasas_register_set {
 
 	u32 	outbound_scratch_pad ;		/*00B0h*/
 	u32	outbound_scratch_pad_2;         /*00B4h*/
+	u32	outbound_scratch_pad_3;         /*00B8h*/
 
-	u32	reserved_4[2];			/*00B8h*/
+	u32	reserved_4;			/*00BCh*/
 
 	u32 	inbound_low_queue_port ;	/*00C0h*/
 
@@ -1826,6 +1829,7 @@ struct megasas_instance {
 	u8 mask_interrupts;
 	u16 max_chain_frame_sz;
 	u8 is_imr;
+	u8 is_rdpq;
 	bool dev_handle;
 };
 struct MR_LD_VF_MAP {
* Unmerged path drivers/scsi/megaraid/megaraid_sas_base.c
* Unmerged path drivers/scsi/megaraid/megaraid_sas_fusion.c
diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.h b/drivers/scsi/megaraid/megaraid_sas_fusion.h
index fc524460a8c3..3c276caf89c4 100644
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.h
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.h
@@ -814,6 +814,12 @@ struct MR_PD_CFG_SEQ_NUM_SYNC {
 	struct MR_PD_CFG_SEQ seq[1];
 } __packed;
 
+struct MPI2_IOC_INIT_RDPQ_ARRAY_ENTRY {
+	u64 RDPQBaseAddress;
+	u32 Reserved1;
+	u32 Reserved2;
+};
+
 struct fusion_context {
 	struct megasas_cmd_fusion **cmd_list;
 	dma_addr_t req_frames_desc_phys;
@@ -826,8 +832,8 @@ struct fusion_context {
 	struct dma_pool *sg_dma_pool;
 	struct dma_pool *sense_dma_pool;
 
-	dma_addr_t reply_frames_desc_phys;
-	union MPI2_REPLY_DESCRIPTORS_UNION *reply_frames_desc;
+	dma_addr_t reply_frames_desc_phys[MAX_MSIX_QUEUES_FUSION];
+	union MPI2_REPLY_DESCRIPTORS_UNION *reply_frames_desc[MAX_MSIX_QUEUES_FUSION];
 	struct dma_pool *reply_frames_desc_pool;
 
 	u16 last_reply_idx[MAX_MSIX_QUEUES_FUSION];
@@ -837,6 +843,8 @@ struct fusion_context {
 	u32 reply_alloc_sz;
 	u32 io_frames_alloc_sz;
 
+	struct MPI2_IOC_INIT_RDPQ_ARRAY_ENTRY *rdpq_virt;
+	dma_addr_t rdpq_phys;
 	u16	max_sge_in_main_msg;
 	u16	max_sge_in_chain;
 
