r8152: support ethtool eee

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author hayeswang <hayeswang@realtek.com>
commit df35d283e5a98b654a06301c5668fe85ab538452
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/df35d283.failed

Support get_eee() and set_eee() of ethtool_ops.

	Signed-off-by: Hayes Wang <hayeswang@realtek.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit df35d283e5a98b654a06301c5668fe85ab538452)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/r8152.c
diff --cc drivers/net/usb/r8152.c
index 01be69c439fb,a4d4c4a1354f..000000000000
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@@ -3262,6 -3307,185 +3266,188 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static const char rtl8152_gstrings[][ETH_GSTRING_LEN] = {
+ 	"tx_packets",
+ 	"rx_packets",
+ 	"tx_errors",
+ 	"rx_errors",
+ 	"rx_missed",
+ 	"align_errors",
+ 	"tx_single_collisions",
+ 	"tx_multi_collisions",
+ 	"rx_unicast",
+ 	"rx_broadcast",
+ 	"rx_multicast",
+ 	"tx_aborted",
+ 	"tx_underrun",
+ };
+ 
+ static int rtl8152_get_sset_count(struct net_device *dev, int sset)
+ {
+ 	switch (sset) {
+ 	case ETH_SS_STATS:
+ 		return ARRAY_SIZE(rtl8152_gstrings);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static void rtl8152_get_ethtool_stats(struct net_device *dev,
+ 				      struct ethtool_stats *stats, u64 *data)
+ {
+ 	struct r8152 *tp = netdev_priv(dev);
+ 	struct tally_counter tally;
+ 
+ 	if (usb_autopm_get_interface(tp->intf) < 0)
+ 		return;
+ 
+ 	generic_ocp_read(tp, PLA_TALLYCNT, sizeof(tally), &tally, MCU_TYPE_PLA);
+ 
+ 	usb_autopm_put_interface(tp->intf);
+ 
+ 	data[0] = le64_to_cpu(tally.tx_packets);
+ 	data[1] = le64_to_cpu(tally.rx_packets);
+ 	data[2] = le64_to_cpu(tally.tx_errors);
+ 	data[3] = le32_to_cpu(tally.rx_errors);
+ 	data[4] = le16_to_cpu(tally.rx_missed);
+ 	data[5] = le16_to_cpu(tally.align_errors);
+ 	data[6] = le32_to_cpu(tally.tx_one_collision);
+ 	data[7] = le32_to_cpu(tally.tx_multi_collision);
+ 	data[8] = le64_to_cpu(tally.rx_unicast);
+ 	data[9] = le64_to_cpu(tally.rx_broadcast);
+ 	data[10] = le32_to_cpu(tally.rx_multicast);
+ 	data[11] = le16_to_cpu(tally.tx_aborted);
+ 	data[12] = le16_to_cpu(tally.tx_underun);
+ }
+ 
+ static void rtl8152_get_strings(struct net_device *dev, u32 stringset, u8 *data)
+ {
+ 	switch (stringset) {
+ 	case ETH_SS_STATS:
+ 		memcpy(data, *rtl8152_gstrings, sizeof(rtl8152_gstrings));
+ 		break;
+ 	}
+ }
+ 
+ static int r8152_get_eee(struct r8152 *tp, struct ethtool_eee *eee)
+ {
+ 	u32 ocp_data, lp, adv, supported = 0;
+ 	u16 val;
+ 
+ 	val = r8152_mmd_read(tp, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);
+ 	supported = mmd_eee_cap_to_ethtool_sup_t(val);
+ 
+ 	val = r8152_mmd_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV);
+ 	adv = mmd_eee_adv_to_ethtool_adv_t(val);
+ 
+ 	val = r8152_mmd_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_LPABLE);
+ 	lp = mmd_eee_adv_to_ethtool_adv_t(val);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);
+ 	ocp_data &= EEE_RX_EN | EEE_TX_EN;
+ 
+ 	eee->eee_enabled = !!ocp_data;
+ 	eee->eee_active = !!(supported & adv & lp);
+ 	eee->supported = supported;
+ 	eee->advertised = adv;
+ 	eee->lp_advertised = lp;
+ 
+ 	return 0;
+ }
+ 
+ static int r8152_set_eee(struct r8152 *tp, struct ethtool_eee *eee)
+ {
+ 	u16 val = ethtool_adv_to_mmd_eee_adv_t(eee->advertised);
+ 
+ 	r8152_eee_en(tp, eee->eee_enabled);
+ 
+ 	if (!eee->eee_enabled)
+ 		val = 0;
+ 
+ 	r8152_mmd_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV, val);
+ 
+ 	return 0;
+ }
+ 
+ static int r8153_get_eee(struct r8152 *tp, struct ethtool_eee *eee)
+ {
+ 	u32 ocp_data, lp, adv, supported = 0;
+ 	u16 val;
+ 
+ 	val = ocp_reg_read(tp, OCP_EEE_ABLE);
+ 	supported = mmd_eee_cap_to_ethtool_sup_t(val);
+ 
+ 	val = ocp_reg_read(tp, OCP_EEE_ADV);
+ 	adv = mmd_eee_adv_to_ethtool_adv_t(val);
+ 
+ 	val = ocp_reg_read(tp, OCP_EEE_LPABLE);
+ 	lp = mmd_eee_adv_to_ethtool_adv_t(val);
+ 
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);
+ 	ocp_data &= EEE_RX_EN | EEE_TX_EN;
+ 
+ 	eee->eee_enabled = !!ocp_data;
+ 	eee->eee_active = !!(supported & adv & lp);
+ 	eee->supported = supported;
+ 	eee->advertised = adv;
+ 	eee->lp_advertised = lp;
+ 
+ 	return 0;
+ }
+ 
+ static int r8153_set_eee(struct r8152 *tp, struct ethtool_eee *eee)
+ {
+ 	u16 val = ethtool_adv_to_mmd_eee_adv_t(eee->advertised);
+ 
+ 	r8153_eee_en(tp, eee->eee_enabled);
+ 
+ 	if (!eee->eee_enabled)
+ 		val = 0;
+ 
+ 	ocp_reg_write(tp, OCP_EEE_ADV, val);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ rtl_ethtool_get_eee(struct net_device *net, struct ethtool_eee *edata)
+ {
+ 	struct r8152 *tp = netdev_priv(net);
+ 	int ret;
+ 
+ 	ret = usb_autopm_get_interface(tp->intf);
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	ret = tp->rtl_ops.eee_get(tp, edata);
+ 
+ 	usb_autopm_put_interface(tp->intf);
+ 
+ out:
+ 	return ret;
+ }
+ 
+ static int
+ rtl_ethtool_set_eee(struct net_device *net, struct ethtool_eee *edata)
+ {
+ 	struct r8152 *tp = netdev_priv(net);
+ 	int ret;
+ 
+ 	ret = usb_autopm_get_interface(tp->intf);
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	ret = tp->rtl_ops.eee_set(tp, edata);
+ 
+ 	usb_autopm_put_interface(tp->intf);
+ 
+ out:
+ 	return ret;
+ }
+ 
++>>>>>>> df35d283e5a9 (r8152: support ethtool eee)
  static struct ethtool_ops ops = {
  	.get_drvinfo = rtl8152_get_drvinfo,
  	.get_settings = rtl8152_get_settings,
@@@ -3271,6 -3495,11 +3457,14 @@@
  	.set_msglevel = rtl8152_set_msglevel,
  	.get_wol = rtl8152_get_wol,
  	.set_wol = rtl8152_set_wol,
++<<<<<<< HEAD
++=======
+ 	.get_strings = rtl8152_get_strings,
+ 	.get_sset_count = rtl8152_get_sset_count,
+ 	.get_ethtool_stats = rtl8152_get_ethtool_stats,
+ 	.get_eee = rtl_ethtool_get_eee,
+ 	.set_eee = rtl_ethtool_set_eee,
++>>>>>>> df35d283e5a9 (r8152: support ethtool eee)
  };
  
  static int rtl8152_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
* Unmerged path drivers/net/usb/r8152.c
