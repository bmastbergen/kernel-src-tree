megaraid_sas: Make adprecovery variable atomic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sumit Saxena <sumit.saxena@avagotech.com>
commit 8a01a41d864771fbc3cfc80a9629e06189479cce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8a01a41d.failed

Make instance->adprecovery variable atomic and removes hba_lock spinlock
while accessing instance->adprecovery.

	Signed-off-by: Sumit Saxena <sumit.saxena@avagotech.com>
	Signed-off-by: Kashyap Desai <kashyap.desai@avagotech.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 8a01a41d864771fbc3cfc80a9629e06189479cce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas_base.c
#	drivers/scsi/megaraid/megaraid_sas_fusion.c
diff --cc drivers/scsi/megaraid/megaraid_sas_base.c
index b60f8ef53c66,1bd5da49b897..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@@ -468,8 -483,7 +468,12 @@@ static in
  megasas_check_reset_xscale(struct megasas_instance *instance,
  		struct megasas_register_set __iomem *regs)
  {
++<<<<<<< HEAD
 +
 +	if ((instance->adprecovery != MEGASAS_HBA_OPERATIONAL) &&
++=======
+ 	if ((atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) &&
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  	    (le32_to_cpu(*instance->consumer) ==
  		MEGASAS_ADPRESET_INPROG_SIGN))
  		return 1;
@@@ -969,26 -992,20 +972,35 @@@ extern struct megasas_instance_templat
  int
  megasas_issue_polled(struct megasas_instance *instance, struct megasas_cmd *cmd)
  {
 +	int seconds;
 +
  	struct megasas_header *frame_hdr = &cmd->frame->hdr;
  
 -	frame_hdr->cmd_status = MFI_STAT_INVALID_STATUS;
 +	frame_hdr->cmd_status = MFI_CMD_STATUS_POLL_MODE;
  	frame_hdr->flags |= cpu_to_le16(MFI_FRAME_DONT_POST_IN_REPLY_QUEUE);
  
++<<<<<<< HEAD
 +	/*
 +	 * Issue the frame using inbound queue port
 +	 */
 +	instance->instancet->issue_dcmd(instance, cmd);
++=======
+ 	if ((atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) ||
+ 		(instance->instancet->issue_dcmd(instance, cmd))) {
+ 		dev_err(&instance->pdev->dev, "Failed from %s %d\n",
+ 			__func__, __LINE__);
+ 		return DCMD_NOT_FIRED;
+ 	}
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  
 -	return wait_and_poll(instance, cmd, instance->requestorId ?
 -			MEGASAS_ROUTINE_WAIT_TIME_VF : MFI_IO_TIMEOUT_SECS);
 +	/*
 +	 * Wait for cmd_status to change
 +	 */
 +	if (instance->requestorId)
 +		seconds = MEGASAS_ROUTINE_WAIT_TIME_VF;
 +	else
 +		seconds = MFI_POLL_TIMEOUT_SECS;
 +	return wait_and_poll(instance, cmd, seconds);
  }
  
  /**
@@@ -1008,7 -1025,13 +1020,17 @@@ megasas_issue_blocked_cmd(struct megasa
  	int ret = 0;
  	cmd->cmd_status_drv = MFI_STAT_INVALID_STATUS;
  
++<<<<<<< HEAD
 +	instance->instancet->issue_dcmd(instance, cmd);
++=======
+ 	if ((atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) ||
+ 		(instance->instancet->issue_dcmd(instance, cmd))) {
+ 		dev_err(&instance->pdev->dev, "Failed from %s %d\n",
+ 			__func__, __LINE__);
+ 		return DCMD_NOT_FIRED;
+ 	}
+ 
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  	if (timeout) {
  		ret = wait_event_timeout(instance->int_cmd_wait_q,
  				cmd->cmd_status_drv != MFI_STAT_INVALID_STATUS, timeout * HZ);
@@@ -1063,7 -1089,12 +1085,16 @@@ megasas_issue_blocked_abort_cmd(struct 
  	cmd->sync_cmd = 1;
  	cmd->cmd_status_drv = MFI_STAT_INVALID_STATUS;
  
++<<<<<<< HEAD
 +	instance->instancet->issue_dcmd(instance, cmd);
++=======
+ 	if ((atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) ||
+ 		(instance->instancet->issue_dcmd(instance, cmd))) {
+ 		dev_err(&instance->pdev->dev, "Failed from %s %d\n",
+ 			__func__, __LINE__);
+ 		return DCMD_NOT_FIRED;
+ 	}
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  
  	if (timeout) {
  		ret = wait_event_timeout(instance->abort_cmd_wait_q,
@@@ -1623,7 -1652,7 +1654,11 @@@ static in
  megasas_queue_command(struct Scsi_Host *shost, struct scsi_cmnd *scmd)
  {
  	struct megasas_instance *instance;
++<<<<<<< HEAD
 +	unsigned long flags;
++=======
+ 	struct MR_PRIV_DEVICE *mr_device_priv_data;
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  
  	instance = (struct megasas_instance *)
  	    scmd->device->host->hostdata;
@@@ -1660,12 -1685,19 +1691,28 @@@
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	if (instance->adprecovery != MEGASAS_HBA_OPERATIONAL) {
 +		spin_unlock_irqrestore(&instance->hba_lock, flags);
- 		return SCSI_MLQUEUE_HOST_BUSY;
++=======
+ 	mr_device_priv_data = scmd->device->hostdata;
+ 	if (!mr_device_priv_data) {
+ 		scmd->result = DID_NO_CONNECT << 16;
+ 		scmd->scsi_done(scmd);
+ 		return 0;
  	}
  
+ 	if (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
+ 		return SCSI_MLQUEUE_HOST_BUSY;
+ 
++<<<<<<< HEAD
 +	spin_unlock_irqrestore(&instance->hba_lock, flags);
++=======
+ 	if (mr_device_priv_data->tm_busy)
+ 		return SCSI_MLQUEUE_DEVICE_BUSY;
+ 
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  
  	scmd->result = 0;
  
@@@ -1888,7 -1990,7 +1935,11 @@@ static void megasas_complete_cmd_dpc(un
  	unsigned long flags;
  
  	/* If we have already declared adapter dead, donot complete cmds */
++<<<<<<< HEAD
 +	if (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR )
++=======
+ 	if (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  		return;
  
  	spin_lock_irqsave(&instance->completion_lock, flags);
@@@ -2379,21 -2473,16 +2426,24 @@@ static int megasas_wait_for_outstanding
  				&clist_local);
  		spin_unlock_irqrestore(&instance->hba_lock, flags);
  
 -		dev_notice(&instance->pdev->dev, "HBA reset wait ...\n");
 +		printk(KERN_NOTICE "megasas: HBA reset wait ...\n");
  		for (i = 0; i < wait_time; i++) {
  			msleep(1000);
- 			spin_lock_irqsave(&instance->hba_lock, flags);
- 			adprecovery = instance->adprecovery;
- 			spin_unlock_irqrestore(&instance->hba_lock, flags);
- 			if (adprecovery == MEGASAS_HBA_OPERATIONAL)
+ 			if (atomic_read(&instance->adprecovery) == MEGASAS_HBA_OPERATIONAL)
  				break;
  		}
  
++<<<<<<< HEAD
 +		if (adprecovery != MEGASAS_HBA_OPERATIONAL) {
 +			printk(KERN_NOTICE "megasas: reset: Stopping HBA.\n");
 +			spin_lock_irqsave(&instance->hba_lock, flags);
 +			instance->adprecovery	= MEGASAS_HW_CRITICAL_ERROR;
 +			spin_unlock_irqrestore(&instance->hba_lock, flags);
++=======
+ 		if (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {
+ 			dev_notice(&instance->pdev->dev, "reset: Stopping HBA.\n");
+ 			atomic_set(&instance->adprecovery, MEGASAS_HW_CRITICAL_ERROR);
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  			return FAILED;
  		}
  
@@@ -2505,9 -2591,7 +2555,13 @@@
  				&instance->reg_set->inbound_doorbell);
  		}
  		megasas_dump_pending_frames(instance);
++<<<<<<< HEAD
 +		spin_lock_irqsave(&instance->hba_lock, flags);
 +		instance->adprecovery	= MEGASAS_HW_CRITICAL_ERROR;
 +		spin_unlock_irqrestore(&instance->hba_lock, flags);
++=======
+ 		atomic_set(&instance->adprecovery, MEGASAS_HW_CRITICAL_ERROR);
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  		return FAILED;
  	}
  
@@@ -2534,9 -2618,8 +2588,14 @@@ static int megasas_generic_reset(struc
  	scmd_printk(KERN_NOTICE, scmd, "megasas: RESET cmd=%x retries=%x\n",
  		 scmd->cmnd[0], scmd->retries);
  
++<<<<<<< HEAD
 +	if (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR) {
 +		printk(KERN_ERR "megasas: cannot recover from previous reset "
 +		       "failures\n");
++=======
+ 	if (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {
+ 		dev_err(&instance->pdev->dev, "cannot recover from previous reset failures\n");
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  		return FAILED;
  	}
  
@@@ -3285,14 -3362,14 +3344,25 @@@ process_fw_state_change_wq(struct work_
  	u32 wait;
  	unsigned long flags;
  
++<<<<<<< HEAD
 +	if (instance->adprecovery != MEGASAS_ADPRESET_SM_INFAULT) {
 +		printk(KERN_NOTICE "megaraid_sas: error, recovery st %x \n",
 +				instance->adprecovery);
 +		return ;
 +	}
 +
 +	if (instance->adprecovery == MEGASAS_ADPRESET_SM_INFAULT) {
 +		printk(KERN_NOTICE "megaraid_sas: FW detected to be in fault"
++=======
+     if (atomic_read(&instance->adprecovery) != MEGASAS_ADPRESET_SM_INFAULT) {
+ 		dev_notice(&instance->pdev->dev, "error, recovery st %x\n",
+ 				atomic_read(&instance->adprecovery));
+ 		return ;
+ 	}
+ 
+ 	if (atomic_read(&instance->adprecovery) == MEGASAS_ADPRESET_SM_INFAULT) {
+ 		dev_notice(&instance->pdev->dev, "FW detected to be in fault"
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  					"state, restarting it...\n");
  
  		instance->instancet->disable_intr(instance);
@@@ -3406,8 -3482,8 +3476,13 @@@ megasas_deplete_reply_queue(struct mega
  			atomic_set(&instance->fw_outstanding, 0);
  			megasas_internal_reset_defer_cmds(instance);
  
++<<<<<<< HEAD
 +			printk(KERN_NOTICE "megasas: fwState=%x, stage:%d\n",
 +					fw_state, instance->adprecovery);
++=======
+ 			dev_notice(&instance->pdev->dev, "fwState=%x, stage:%d\n",
+ 					fw_state, atomic_read(&instance->adprecovery));
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  
  			schedule_work(&instance->work_init);
  			return IRQ_HANDLED;
@@@ -6408,8 -6687,8 +6483,13 @@@ static int megasas_mgmt_ioctl_fw(struc
  		goto out_kfree_ioc;
  	}
  
++<<<<<<< HEAD
 +	if (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR) {
 +		printk(KERN_ERR "Controller in crit error\n");
++=======
+ 	if (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {
+ 		dev_err(&instance->pdev->dev, "Controller in crit error\n");
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  		error = -ENODEV;
  		goto out_kfree_ioc;
  	}
@@@ -6442,10 -6721,10 +6522,10 @@@
  	}
  
  	spin_lock_irqsave(&instance->hba_lock, flags);
- 	if (instance->adprecovery != MEGASAS_HBA_OPERATIONAL) {
+ 	if (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {
  		spin_unlock_irqrestore(&instance->hba_lock, flags);
  
 -		dev_err(&instance->pdev->dev, "timed out while"
 +		printk(KERN_ERR "megaraid_sas: timed out while"
  			"waiting for HBA to recover\n");
  		error = -ENODEV;
  		goto out_up;
@@@ -6512,10 -6791,10 +6592,10 @@@ static int megasas_mgmt_ioctl_aen(struc
  	}
  
  	spin_lock_irqsave(&instance->hba_lock, flags);
- 	if (instance->adprecovery != MEGASAS_HBA_OPERATIONAL) {
+ 	if (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {
  		spin_unlock_irqrestore(&instance->hba_lock, flags);
 -		dev_err(&instance->pdev->dev, "timed out while waiting"
 -				"for HBA to recover\n");
 +		printk(KERN_ERR "megaraid_sas: timed out while waiting"
 +				"for HBA to recover.\n");
  		return -ENODEV;
  	}
  	spin_unlock_irqrestore(&instance->hba_lock, flags);
diff --cc drivers/scsi/megaraid/megaraid_sas_fusion.c
index a09ae37a613c,64926f7ef119..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@@ -2111,13 -2244,13 +2111,13 @@@ complete_cmd_fusion(struct megasas_inst
  
  	fusion = instance->ctrl_context;
  
- 	if (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR)
+ 	if (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)
  		return IRQ_HANDLED;
  
 -	desc = fusion->reply_frames_desc[MSIxIndex] +
 -				fusion->last_reply_idx[MSIxIndex];
 +	desc = fusion->reply_frames_desc;
 +	desc += ((MSIxIndex * fusion->reply_alloc_sz)/
 +		 sizeof(union MPI2_REPLY_DESCRIPTORS_UNION)) +
 +		fusion->last_reply_idx[MSIxIndex];
  
  	reply_desc = (struct MPI2_SCSI_IO_SUCCESS_REPLY_DESCRIPTOR *)desc;
  
@@@ -2726,6 -2879,452 +2726,455 @@@ void megasas_refire_mgmt_cmd(struct meg
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * megasas_track_scsiio : Track SCSI IOs outstanding to a SCSI device
+  * @instance: per adapter struct
+  * @channel: the channel assigned by the OS
+  * @id: the id assigned by the OS
+  *
+  * Returns SUCCESS if no IOs pending to SCSI device, else return FAILED
+  */
+ 
+ static int megasas_track_scsiio(struct megasas_instance *instance,
+ 		int id, int channel)
+ {
+ 	int i, found = 0;
+ 	struct megasas_cmd_fusion *cmd_fusion;
+ 	struct fusion_context *fusion;
+ 	fusion = instance->ctrl_context;
+ 
+ 	for (i = 0 ; i < instance->max_scsi_cmds; i++) {
+ 		cmd_fusion = fusion->cmd_list[i];
+ 		if (cmd_fusion->scmd &&
+ 			(cmd_fusion->scmd->device->id == id &&
+ 			cmd_fusion->scmd->device->channel == channel)) {
+ 			dev_info(&instance->pdev->dev,
+ 				"SCSI commands pending to target"
+ 				"channel %d id %d \tSMID: 0x%x\n",
+ 				channel, id, cmd_fusion->index);
+ 			scsi_print_command(cmd_fusion->scmd);
+ 			found = 1;
+ 			break;
+ 		}
+ 	}
+ 
+ 	return found ? FAILED : SUCCESS;
+ }
+ 
+ /**
+  * megasas_tm_response_code - translation of device response code
+  * @ioc: per adapter object
+  * @mpi_reply: MPI reply returned by firmware
+  *
+  * Return nothing.
+  */
+ static void
+ megasas_tm_response_code(struct megasas_instance *instance,
+ 		struct MPI2_SCSI_TASK_MANAGE_REPLY *mpi_reply)
+ {
+ 	char *desc;
+ 
+ 	switch (mpi_reply->ResponseCode) {
+ 	case MPI2_SCSITASKMGMT_RSP_TM_COMPLETE:
+ 		desc = "task management request completed";
+ 		break;
+ 	case MPI2_SCSITASKMGMT_RSP_INVALID_FRAME:
+ 		desc = "invalid frame";
+ 		break;
+ 	case MPI2_SCSITASKMGMT_RSP_TM_NOT_SUPPORTED:
+ 		desc = "task management request not supported";
+ 		break;
+ 	case MPI2_SCSITASKMGMT_RSP_TM_FAILED:
+ 		desc = "task management request failed";
+ 		break;
+ 	case MPI2_SCSITASKMGMT_RSP_TM_SUCCEEDED:
+ 		desc = "task management request succeeded";
+ 		break;
+ 	case MPI2_SCSITASKMGMT_RSP_TM_INVALID_LUN:
+ 		desc = "invalid lun";
+ 		break;
+ 	case 0xA:
+ 		desc = "overlapped tag attempted";
+ 		break;
+ 	case MPI2_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC:
+ 		desc = "task queued, however not sent to target";
+ 		break;
+ 	default:
+ 		desc = "unknown";
+ 		break;
+ 	}
+ 	dev_dbg(&instance->pdev->dev, "response_code(%01x): %s\n",
+ 		mpi_reply->ResponseCode, desc);
+ 	dev_dbg(&instance->pdev->dev,
+ 		"TerminationCount/DevHandle/Function/TaskType/IOCStat/IOCLoginfo"
+ 		" 0x%x/0x%x/0x%x/0x%x/0x%x/0x%x\n",
+ 		mpi_reply->TerminationCount, mpi_reply->DevHandle,
+ 		mpi_reply->Function, mpi_reply->TaskType,
+ 		mpi_reply->IOCStatus, mpi_reply->IOCLogInfo);
+ }
+ 
+ /**
+  * megasas_issue_tm - main routine for sending tm requests
+  * @instance: per adapter struct
+  * @device_handle: device handle
+  * @channel: the channel assigned by the OS
+  * @id: the id assigned by the OS
+  * @type: MPI2_SCSITASKMGMT_TASKTYPE__XXX (defined in megaraid_sas_fusion.c)
+  * @smid_task: smid assigned to the task
+  * @m_type: TM_MUTEX_ON or TM_MUTEX_OFF
+  * Context: user
+  *
+  * MegaRaid use MPT interface for Task Magement request.
+  * A generic API for sending task management requests to firmware.
+  *
+  * Return SUCCESS or FAILED.
+  */
+ static int
+ megasas_issue_tm(struct megasas_instance *instance, u16 device_handle,
+ 	uint channel, uint id, u16 smid_task, u8 type)
+ {
+ 	struct MR_TASK_MANAGE_REQUEST *mr_request;
+ 	struct MPI2_SCSI_TASK_MANAGE_REQUEST *mpi_request;
+ 	unsigned long timeleft;
+ 	struct megasas_cmd_fusion *cmd_fusion;
+ 	struct megasas_cmd *cmd_mfi;
+ 	union MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;
+ 	struct fusion_context *fusion;
+ 	struct megasas_cmd_fusion *scsi_lookup;
+ 	int rc;
+ 	struct MPI2_SCSI_TASK_MANAGE_REPLY *mpi_reply;
+ 
+ 	fusion = instance->ctrl_context;
+ 
+ 	cmd_mfi = megasas_get_cmd(instance);
+ 
+ 	if (!cmd_mfi) {
+ 		dev_err(&instance->pdev->dev, "Failed from %s %d\n",
+ 			__func__, __LINE__);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	cmd_fusion = megasas_get_cmd_fusion(instance,
+ 			instance->max_scsi_cmds + cmd_mfi->index);
+ 
+ 	/*  Save the smid. To be used for returning the cmd */
+ 	cmd_mfi->context.smid = cmd_fusion->index;
+ 
+ 	req_desc = megasas_get_request_descriptor(instance,
+ 			(cmd_fusion->index - 1));
+ 	if (!req_desc) {
+ 		dev_err(&instance->pdev->dev, "Failed from %s %d\n",
+ 			__func__, __LINE__);
+ 		megasas_return_cmd(instance, cmd_mfi);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	cmd_fusion->request_desc = req_desc;
+ 	req_desc->Words = 0;
+ 
+ 	scsi_lookup = fusion->cmd_list[smid_task - 1];
+ 
+ 	mr_request = (struct MR_TASK_MANAGE_REQUEST *) cmd_fusion->io_request;
+ 	memset(mr_request, 0, sizeof(struct MR_TASK_MANAGE_REQUEST));
+ 	mpi_request = (struct MPI2_SCSI_TASK_MANAGE_REQUEST *) &mr_request->TmRequest;
+ 	mpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;
+ 	mpi_request->DevHandle = cpu_to_le16(device_handle);
+ 	mpi_request->TaskType = type;
+ 	mpi_request->TaskMID = cpu_to_le16(smid_task);
+ 	mpi_request->LUN[1] = 0;
+ 
+ 
+ 	req_desc = cmd_fusion->request_desc;
+ 	req_desc->HighPriority.SMID = cpu_to_le16(cmd_fusion->index);
+ 	req_desc->HighPriority.RequestFlags =
+ 		(MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY <<
+ 		MEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);
+ 	req_desc->HighPriority.MSIxIndex =  0;
+ 	req_desc->HighPriority.LMID = 0;
+ 	req_desc->HighPriority.Reserved1 = 0;
+ 
+ 	if (channel < MEGASAS_MAX_PD_CHANNELS)
+ 		mr_request->tmReqFlags.isTMForPD = 1;
+ 	else
+ 		mr_request->tmReqFlags.isTMForLD = 1;
+ 
+ 	init_completion(&cmd_fusion->done);
+ 	megasas_fire_cmd_fusion(instance, req_desc);
+ 
+ 	timeleft = wait_for_completion_timeout(&cmd_fusion->done, 50 * HZ);
+ 
+ 	if (!timeleft) {
+ 		dev_err(&instance->pdev->dev,
+ 			"task mgmt type 0x%x timed out\n", type);
+ 		cmd_mfi->flags |= DRV_DCMD_SKIP_REFIRE;
+ 		mutex_unlock(&instance->reset_mutex);
+ 		rc = megasas_reset_fusion(instance->host, MFI_IO_TIMEOUT_OCR);
+ 		mutex_lock(&instance->reset_mutex);
+ 		return rc;
+ 	}
+ 
+ 	mpi_reply = (struct MPI2_SCSI_TASK_MANAGE_REPLY *) &mr_request->TMReply;
+ 	megasas_tm_response_code(instance, mpi_reply);
+ 
+ 	megasas_return_cmd(instance, cmd_mfi);
+ 	rc = SUCCESS;
+ 	switch (type) {
+ 	case MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK:
+ 		if (scsi_lookup->scmd == NULL)
+ 			break;
+ 		else {
+ 			instance->instancet->disable_intr(instance);
+ 			msleep(1000);
+ 			megasas_complete_cmd_dpc_fusion
+ 					((unsigned long)instance);
+ 			instance->instancet->enable_intr(instance);
+ 			if (scsi_lookup->scmd == NULL)
+ 				break;
+ 		}
+ 		rc = FAILED;
+ 		break;
+ 
+ 	case MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET:
+ 		if ((channel == 0xFFFFFFFF) && (id == 0xFFFFFFFF))
+ 			break;
+ 		instance->instancet->disable_intr(instance);
+ 		msleep(1000);
+ 		megasas_complete_cmd_dpc_fusion
+ 				((unsigned long)instance);
+ 		rc = megasas_track_scsiio(instance, id, channel);
+ 		instance->instancet->enable_intr(instance);
+ 
+ 		break;
+ 	case MPI2_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET:
+ 	case MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK:
+ 		break;
+ 	default:
+ 		rc = FAILED;
+ 		break;
+ 	}
+ 
+ 	return rc;
+ 
+ }
+ 
+ /*
+  * megasas_fusion_smid_lookup : Look for fusion command correpspodning to SCSI
+  * @instance: per adapter struct
+  *
+  * Return Non Zero index, if SMID found in outstanding commands
+  */
+ static u16 megasas_fusion_smid_lookup(struct scsi_cmnd *scmd)
+ {
+ 	int i, ret = 0;
+ 	struct megasas_instance *instance;
+ 	struct megasas_cmd_fusion *cmd_fusion;
+ 	struct fusion_context *fusion;
+ 
+ 	instance = (struct megasas_instance *)scmd->device->host->hostdata;
+ 
+ 	fusion = instance->ctrl_context;
+ 
+ 	for (i = 0; i < instance->max_scsi_cmds; i++) {
+ 		cmd_fusion = fusion->cmd_list[i];
+ 		if (cmd_fusion->scmd && (cmd_fusion->scmd == scmd)) {
+ 			scmd_printk(KERN_NOTICE, scmd, "Abort request is for"
+ 				" SMID: %d\n", cmd_fusion->index);
+ 			ret = cmd_fusion->index;
+ 			break;
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ /*
+ * megasas_get_tm_devhandle - Get devhandle for TM request
+ * @sdev-		     OS provided scsi device
+ *
+ * Returns-		     devhandle/targetID of SCSI device
+ */
+ static u16 megasas_get_tm_devhandle(struct scsi_device *sdev)
+ {
+ 	u16 pd_index = 0;
+ 	u32 device_id;
+ 	struct megasas_instance *instance;
+ 	struct fusion_context *fusion;
+ 	struct MR_PD_CFG_SEQ_NUM_SYNC *pd_sync;
+ 	u16 devhandle = (u16)ULONG_MAX;
+ 
+ 	instance = (struct megasas_instance *)sdev->host->hostdata;
+ 	fusion = instance->ctrl_context;
+ 
+ 	if (sdev->channel < MEGASAS_MAX_PD_CHANNELS) {
+ 		if (instance->use_seqnum_jbod_fp) {
+ 				pd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +
+ 						sdev->id;
+ 				pd_sync = (void *)fusion->pd_seq_sync
+ 						[(instance->pd_seq_map_id - 1) & 1];
+ 				devhandle = pd_sync->seq[pd_index].devHandle;
+ 		} else
+ 			sdev_printk(KERN_ERR, sdev, "Firmware expose tmCapable"
+ 				" without JBOD MAP support from %s %d\n", __func__, __LINE__);
+ 	} else {
+ 		device_id = ((sdev->channel % 2) * MEGASAS_MAX_DEV_PER_CHANNEL)
+ 				+ sdev->id;
+ 		devhandle = device_id;
+ 	}
+ 
+ 	return devhandle;
+ }
+ 
+ /*
+  * megasas_task_abort_fusion : SCSI task abort function for fusion adapters
+  * @scmd : pointer to scsi command object
+  *
+  * Return SUCCESS, if command aborted else FAILED
+  */
+ 
+ int megasas_task_abort_fusion(struct scsi_cmnd *scmd)
+ {
+ 	struct megasas_instance *instance;
+ 	u16 smid, devhandle;
+ 	struct fusion_context *fusion;
+ 	int ret;
+ 	struct MR_PRIV_DEVICE *mr_device_priv_data;
+ 	mr_device_priv_data = scmd->device->hostdata;
+ 
+ 
+ 	instance = (struct megasas_instance *)scmd->device->host->hostdata;
+ 	fusion = instance->ctrl_context;
+ 
+ 	if (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {
+ 		dev_err(&instance->pdev->dev, "Controller is not OPERATIONAL,"
+ 		"SCSI host:%d\n", instance->host->host_no);
+ 		ret = FAILED;
+ 		return ret;
+ 	}
+ 
+ 	if (!mr_device_priv_data) {
+ 		sdev_printk(KERN_INFO, scmd->device, "device been deleted! "
+ 			"scmd(%p)\n", scmd);
+ 		scmd->result = DID_NO_CONNECT << 16;
+ 		ret = SUCCESS;
+ 		goto out;
+ 	}
+ 
+ 
+ 	if (!mr_device_priv_data->is_tm_capable) {
+ 		ret = FAILED;
+ 		goto out;
+ 	}
+ 
+ 	mutex_lock(&instance->reset_mutex);
+ 
+ 	smid = megasas_fusion_smid_lookup(scmd);
+ 
+ 	if (!smid) {
+ 		ret = SUCCESS;
+ 		scmd_printk(KERN_NOTICE, scmd, "Command for which abort is"
+ 			" issued is not found in oustanding commands\n");
+ 		mutex_unlock(&instance->reset_mutex);
+ 		goto out;
+ 	}
+ 
+ 	devhandle = megasas_get_tm_devhandle(scmd->device);
+ 
+ 	if (devhandle == (u16)ULONG_MAX) {
+ 		ret = SUCCESS;
+ 		sdev_printk(KERN_INFO, scmd->device,
+ 			"task abort issued for invalid devhandle\n");
+ 		mutex_unlock(&instance->reset_mutex);
+ 		goto out;
+ 	}
+ 	sdev_printk(KERN_INFO, scmd->device,
+ 		"attempting task abort! scmd(%p) tm_dev_handle 0x%x\n",
+ 		scmd, devhandle);
+ 
+ 	mr_device_priv_data->tm_busy = 1;
+ 	ret = megasas_issue_tm(instance, devhandle,
+ 			scmd->device->channel, scmd->device->id, smid,
+ 			MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK);
+ 	mr_device_priv_data->tm_busy = 0;
+ 
+ 	mutex_unlock(&instance->reset_mutex);
+ out:
+ 	sdev_printk(KERN_INFO, scmd->device, "task abort: %s scmd(%p)\n",
+ 			((ret == SUCCESS) ? "SUCCESS" : "FAILED"), scmd);
+ 
+ 	return ret;
+ }
+ 
+ /*
+  * megasas_reset_target_fusion : target reset function for fusion adapters
+  * scmd: SCSI command pointer
+  *
+  * Returns SUCCESS if all commands associated with target aborted else FAILED
+  */
+ 
+ int megasas_reset_target_fusion(struct scsi_cmnd *scmd)
+ {
+ 
+ 	struct megasas_instance *instance;
+ 	int ret = FAILED;
+ 	u16 devhandle;
+ 	struct fusion_context *fusion;
+ 	struct MR_PRIV_DEVICE *mr_device_priv_data;
+ 	mr_device_priv_data = scmd->device->hostdata;
+ 
+ 	instance = (struct megasas_instance *)scmd->device->host->hostdata;
+ 	fusion = instance->ctrl_context;
+ 
+ 	if (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {
+ 		dev_err(&instance->pdev->dev, "Controller is not OPERATIONAL,"
+ 		"SCSI host:%d\n", instance->host->host_no);
+ 		ret = FAILED;
+ 		return ret;
+ 	}
+ 
+ 	if (!mr_device_priv_data) {
+ 		sdev_printk(KERN_INFO, scmd->device, "device been deleted! "
+ 			"scmd(%p)\n", scmd);
+ 		scmd->result = DID_NO_CONNECT << 16;
+ 		ret = SUCCESS;
+ 		goto out;
+ 	}
+ 
+ 
+ 	if (!mr_device_priv_data->is_tm_capable) {
+ 		ret = FAILED;
+ 		goto out;
+ 	}
+ 
+ 	mutex_lock(&instance->reset_mutex);
+ 	devhandle = megasas_get_tm_devhandle(scmd->device);
+ 
+ 	if (devhandle == (u16)ULONG_MAX) {
+ 		ret = SUCCESS;
+ 		sdev_printk(KERN_INFO, scmd->device,
+ 			"target reset issued for invalid devhandle\n");
+ 		mutex_unlock(&instance->reset_mutex);
+ 		goto out;
+ 	}
+ 
+ 	sdev_printk(KERN_INFO, scmd->device,
+ 		"attempting target reset! scmd(%p) tm_dev_handle 0x%x\n",
+ 		scmd, devhandle);
+ 	mr_device_priv_data->tm_busy = 1;
+ 	ret = megasas_issue_tm(instance, devhandle,
+ 			scmd->device->channel, scmd->device->id, 0,
+ 			MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET);
+ 	mr_device_priv_data->tm_busy = 0;
+ 	mutex_unlock(&instance->reset_mutex);
+ out:
+ 	scmd_printk(KERN_NOTICE, scmd, "megasas: target reset %s!!\n",
+ 		(ret == SUCCESS) ? "SUCCESS" : "FAILED");
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  /* Check for a second path that is currently UP */
  int megasas_check_mpio_paths(struct megasas_instance *instance,
  	struct scsi_cmnd *scmd)
@@@ -2766,8 -3366,8 +3215,13 @@@ int megasas_reset_fusion(struct Scsi_Ho
  
  	mutex_lock(&instance->reset_mutex);
  
++<<<<<<< HEAD
 +	if (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR) {
 +		printk(KERN_WARNING "megaraid_sas: Hardware critical error, "
++=======
+ 	if (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {
+ 		dev_warn(&instance->pdev->dev, "Hardware critical error, "
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  		       "returning FAILED for scsi%d.\n",
  			instance->host->host_no);
  		mutex_unlock(&instance->reset_mutex);
@@@ -2778,10 -3378,10 +3232,10 @@@
  
  	/* IO timeout detected, forcibly put FW in FAULT state */
  	if (abs_state != MFI_STATE_FAULT && instance->crash_dump_buf &&
 -		instance->crash_dump_app_support && reason) {
 -		dev_info(&instance->pdev->dev, "IO/DCMD timeout is detected, "
 +		instance->crash_dump_app_support && iotimeout) {
 +		dev_info(&instance->pdev->dev, "IO timeout is detected, "
  			"forcibly FAULT Firmware\n");
- 		instance->adprecovery = MEGASAS_ADPRESET_SM_INFAULT;
+ 		atomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_INFAULT);
  		status_reg = readl(&instance->reg_set->doorbell);
  		writel(status_reg | MFI_STATE_FORCE_OCR,
  			&instance->reg_set->doorbell);
@@@ -2818,13 -3418,13 +3272,18 @@@
  	msleep(1000);
  
  	/* First try waiting for commands to complete */
 -	if (megasas_wait_for_outstanding_fusion(instance, reason,
 +	if (megasas_wait_for_outstanding_fusion(instance, iotimeout,
  						&convert)) {
++<<<<<<< HEAD
 +		instance->adprecovery = MEGASAS_ADPRESET_SM_INFAULT;
 +		printk(KERN_WARNING "megaraid_sas: resetting fusion "
++=======
+ 		atomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_INFAULT);
+ 		dev_warn(&instance->pdev->dev, "resetting fusion "
++>>>>>>> 8a01a41d8647 (megaraid_sas: Make adprecovery variable atomic)
  		       "adapter scsi%d.\n", instance->host->host_no);
  		if (convert)
 -			reason = 0;
 +			iotimeout = 0;
  
  		/* Now return commands back to the OS */
  		for (i = 0 ; i < instance->max_scsi_cmds; i++) {
diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h
index d4c399b43165..8106b9fff3c1 100644
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@ -1796,7 +1796,7 @@ struct megasas_instance {
 	u16 drv_supported_vd_count;
 	u16 drv_supported_pd_count;
 
-	u8 adprecovery;
+	atomic_t adprecovery;
 	unsigned long last_time;
 	u32 mfiStatus;
 	u32 last_seq_num;
* Unmerged path drivers/scsi/megaraid/megaraid_sas_base.c
* Unmerged path drivers/scsi/megaraid/megaraid_sas_fusion.c
