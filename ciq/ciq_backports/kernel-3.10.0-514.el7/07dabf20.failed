vxlan: tun_id is 64bit, not 32bit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 07dabf20d9867710b90b91108b2adcd448773e25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/07dabf20.failed

The tun_id field in struct ip_tunnel_key is __be64, not __be32. We need to
convert the vni to tun_id correctly.

Fixes: 54bfd872bf16 ("vxlan: keep flags and vni in network byte order")
	Reported-by: Paolo Abeni <pabeni@redhat.com>
	Tested-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Acked-by: Thadeu Lima de Souza Cascardo <cascardo@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 07dabf20d9867710b90b91108b2adcd448773e25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
#	include/net/vxlan.h
diff --cc drivers/net/vxlan.c
index a2751f4f523c,75bccb360599..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1327,6 -1277,85 +1327,88 @@@ drop
  	kfree_skb(skb);
  }
  
++<<<<<<< HEAD
++=======
+ /* Callback from net/ipv4/udp.c to receive packets */
+ static int vxlan_udp_encap_recv(struct sock *sk, struct sk_buff *skb)
+ {
+ 	struct metadata_dst *tun_dst = NULL;
+ 	struct vxlan_sock *vs;
+ 	struct vxlanhdr unparsed;
+ 	struct vxlan_metadata _md;
+ 	struct vxlan_metadata *md = &_md;
+ 
+ 	/* Need Vxlan and inner Ethernet header to be present */
+ 	if (!pskb_may_pull(skb, VXLAN_HLEN))
+ 		return 1;
+ 
+ 	unparsed = *vxlan_hdr(skb);
+ 	/* VNI flag always required to be set */
+ 	if (!(unparsed.vx_flags & VXLAN_HF_VNI)) {
+ 		netdev_dbg(skb->dev, "invalid vxlan flags=%#x vni=%#x\n",
+ 			   ntohl(vxlan_hdr(skb)->vx_flags),
+ 			   ntohl(vxlan_hdr(skb)->vx_vni));
+ 		/* Return non vxlan pkt */
+ 		return 1;
+ 	}
+ 	unparsed.vx_flags &= ~VXLAN_HF_VNI;
+ 	unparsed.vx_vni &= ~VXLAN_VNI_MASK;
+ 
+ 	if (iptunnel_pull_header(skb, VXLAN_HLEN, htons(ETH_P_TEB)))
+ 		goto drop;
+ 
+ 	vs = rcu_dereference_sk_user_data(sk);
+ 	if (!vs)
+ 		goto drop;
+ 
+ 	if (vxlan_collect_metadata(vs)) {
+ 		__be32 vni = vxlan_vni(vxlan_hdr(skb)->vx_vni);
+ 
+ 		tun_dst = udp_tun_rx_dst(skb, vxlan_get_sk_family(vs), TUNNEL_KEY,
+ 					 vxlan_vni_to_tun_id(vni), sizeof(*md));
+ 
+ 		if (!tun_dst)
+ 			goto drop;
+ 
+ 		md = ip_tunnel_info_opts(&tun_dst->u.tun_info);
+ 	} else {
+ 		memset(md, 0, sizeof(*md));
+ 	}
+ 
+ 	/* For backwards compatibility, only allow reserved fields to be
+ 	 * used by VXLAN extensions if explicitly requested.
+ 	 */
+ 	if (vs->flags & VXLAN_F_REMCSUM_RX)
+ 		if (!vxlan_remcsum(&unparsed, skb, vs->flags))
+ 			goto drop;
+ 	if (vs->flags & VXLAN_F_GBP)
+ 		vxlan_parse_gbp_hdr(&unparsed, md, tun_dst);
+ 
+ 	if (unparsed.vx_flags || unparsed.vx_vni) {
+ 		/* If there are any unprocessed flags remaining treat
+ 		 * this as a malformed packet. This behavior diverges from
+ 		 * VXLAN RFC (RFC7348) which stipulates that bits in reserved
+ 		 * in reserved fields are to be ignored. The approach here
+ 		 * maintains compatibility with previous stack code, and also
+ 		 * is more robust and provides a little more security in
+ 		 * adding extensions to VXLAN.
+ 		 */
+ 		goto drop;
+ 	}
+ 
+ 	vxlan_rcv(vs, skb, md, vxlan_vni(vxlan_hdr(skb)->vx_vni), tun_dst);
+ 	return 0;
+ 
+ drop:
+ 	if (tun_dst)
+ 		dst_release((struct dst_entry *)tun_dst);
+ 
+ 	/* Consume bad packet */
+ 	kfree_skb(skb);
+ 	return 0;
+ }
+ 
++>>>>>>> 07dabf20d986 (vxlan: tun_id is 64bit, not 32bit)
  static int arp_reduce(struct net_device *dev, struct sk_buff *skb)
  {
  	struct vxlan_dev *vxlan = netdev_priv(dev);
diff --cc include/net/vxlan.h
index b3828bd87f8a,748083de367a..000000000000
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@@ -181,6 -262,68 +181,71 @@@ static inline netdev_features_t vxlan_f
  /* IPv6 header + UDP + VXLAN + Ethernet header */
  #define VXLAN6_HEADROOM (40 + 8 + 8 + 14)
  
++<<<<<<< HEAD
++=======
+ static inline struct vxlanhdr *vxlan_hdr(struct sk_buff *skb)
+ {
+ 	return (struct vxlanhdr *)(udp_hdr(skb) + 1);
+ }
+ 
+ static inline __be32 vxlan_vni(__be32 vni_field)
+ {
+ #if defined(__BIG_ENDIAN)
+ 	return vni_field >> 8;
+ #else
+ 	return (vni_field & VXLAN_VNI_MASK) << 8;
+ #endif
+ }
+ 
+ static inline __be32 vxlan_vni_field(__be32 vni)
+ {
+ #if defined(__BIG_ENDIAN)
+ 	return vni << 8;
+ #else
+ 	return vni >> 8;
+ #endif
+ }
+ 
+ static inline __be32 vxlan_tun_id_to_vni(__be64 tun_id)
+ {
+ #if defined(__BIG_ENDIAN)
+ 	return tun_id;
+ #else
+ 	return tun_id >> 32;
+ #endif
+ }
+ 
+ static inline __be64 vxlan_vni_to_tun_id(__be32 vni)
+ {
+ #if defined(__BIG_ENDIAN)
+ 	return (__be64)vni;
+ #else
+ 	return (__be64)vni << 32;
+ #endif
+ }
+ 
+ static inline size_t vxlan_rco_start(__be32 vni_field)
+ {
+ 	return be32_to_cpu(vni_field & VXLAN_RCO_MASK) << VXLAN_RCO_SHIFT;
+ }
+ 
+ static inline size_t vxlan_rco_offset(__be32 vni_field)
+ {
+ 	return (vni_field & VXLAN_RCO_UDP) ?
+ 		offsetof(struct udphdr, check) :
+ 		offsetof(struct tcphdr, check);
+ }
+ 
+ static inline __be32 vxlan_compute_rco(unsigned int start, unsigned int offset)
+ {
+ 	__be32 vni_field = cpu_to_be32(start >> VXLAN_RCO_SHIFT);
+ 
+ 	if (offset == offsetof(struct udphdr, check))
+ 		vni_field |= VXLAN_RCO_UDP;
+ 	return vni_field;
+ }
+ 
++>>>>>>> 07dabf20d986 (vxlan: tun_id is 64bit, not 32bit)
  #if IS_ENABLED(CONFIG_VXLAN)
  void vxlan_get_rx_port(struct net_device *netdev);
  #else
* Unmerged path drivers/net/vxlan.c
* Unmerged path include/net/vxlan.h
