KVM: x86: Add EOI exit bitmap inference

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Steve Rutherford <srutherford@google.com>
commit b053b2aef25d00773fa6762dcd4b7f5c9c42d171
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b053b2ae.failed

In order to support a userspace IOAPIC interacting with an in kernel
APIC, the EOI exit bitmaps need to be configurable.

If the IOAPIC is in userspace (i.e. the irqchip has been split), the
EOI exit bitmaps will be set whenever the GSI Routes are configured.
In particular, for the low MSI routes are reservable for userspace
IOAPICs. For these MSI routes, the EOI Exit bit corresponding to the
destination vector of the route will be set for the destination VCPU.

The intention is for the userspace IOAPICs to use the reservable MSI
routes to inject interrupts into the guest.

This is a slight abuse of the notion of an MSI Route, given that MSIs
classically bypass the IOAPIC. It might be worthwhile to add an
additional route type to improve clarity.

Compile tested for Intel x86.

	Signed-off-by: Steve Rutherford <srutherford@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit b053b2aef25d00773fa6762dcd4b7f5c9c42d171)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virtual/kvm/api.txt
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/ioapic.h
#	arch/x86/kvm/irq_comm.c
#	arch/x86/kvm/lapic.c
#	arch/x86/kvm/x86.c
diff --cc Documentation/virtual/kvm/api.txt
index d54a8098c59b,89e71648d748..000000000000
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@@ -3081,3 -3580,98 +3081,101 @@@ userspace from doing that
  If the hcall number specified is not one that has an in-kernel
  implementation, the KVM_ENABLE_CAP ioctl will fail with an EINVAL
  error.
++<<<<<<< HEAD
++=======
+ 
+ 7.2 KVM_CAP_S390_USER_SIGP
+ 
+ Architectures: s390
+ Parameters: none
+ 
+ This capability controls which SIGP orders will be handled completely in user
+ space. With this capability enabled, all fast orders will be handled completely
+ in the kernel:
+ - SENSE
+ - SENSE RUNNING
+ - EXTERNAL CALL
+ - EMERGENCY SIGNAL
+ - CONDITIONAL EMERGENCY SIGNAL
+ 
+ All other orders will be handled completely in user space.
+ 
+ Only privileged operation exceptions will be checked for in the kernel (or even
+ in the hardware prior to interception). If this capability is not enabled, the
+ old way of handling SIGP orders is used (partially in kernel and user space).
+ 
+ 7.3 KVM_CAP_S390_VECTOR_REGISTERS
+ 
+ Architectures: s390
+ Parameters: none
+ Returns: 0 on success, negative value on error
+ 
+ Allows use of the vector registers introduced with z13 processor, and
+ provides for the synchronization between host and user space.  Will
+ return -EINVAL if the machine does not support vectors.
+ 
+ 7.4 KVM_CAP_S390_USER_STSI
+ 
+ Architectures: s390
+ Parameters: none
+ 
+ This capability allows post-handlers for the STSI instruction. After
+ initial handling in the kernel, KVM exits to user space with
+ KVM_EXIT_S390_STSI to allow user space to insert further data.
+ 
+ Before exiting to userspace, kvm handlers should fill in s390_stsi field of
+ vcpu->run:
+ struct {
+ 	__u64 addr;
+ 	__u8 ar;
+ 	__u8 reserved;
+ 	__u8 fc;
+ 	__u8 sel1;
+ 	__u16 sel2;
+ } s390_stsi;
+ 
+ @addr - guest address of STSI SYSIB
+ @fc   - function code
+ @sel1 - selector 1
+ @sel2 - selector 2
+ @ar   - access register number
+ 
+ KVM handlers should exit to userspace with rc = -EREMOTE.
+ 
+ 7.5 KVM_CAP_SPLIT_IRQCHIP
+ 
+ Architectures: x86
+ Parameters: args[0] - number of routes reserved for userspace IOAPICs
+ Returns: 0 on success, -1 on error
+ 
+ Create a local apic for each processor in the kernel. This can be used
+ instead of KVM_CREATE_IRQCHIP if the userspace VMM wishes to emulate the
+ IOAPIC and PIC (and also the PIT, even though this has to be enabled
+ separately).
+ 
+ This capability also enables in kernel routing of interrupt requests;
+ when KVM_CAP_SPLIT_IRQCHIP only routes of KVM_IRQ_ROUTING_MSI type are
+ used in the IRQ routing table.  The first args[0] MSI routes are reserved
+ for the IOAPIC pins.  Whenever the LAPIC receives an EOI for these routes,
+ a KVM_EXIT_IOAPIC_EOI vmexit will be reported to userspace.
+ 
+ Fails if VCPU has already been created, or if the irqchip is already in the
+ kernel (i.e. KVM_CREATE_IRQCHIP has already been called).
+ 
+ 
+ 8. Other capabilities.
+ ----------------------
+ 
+ This section lists capabilities that give information about other
+ features of the KVM implementation.
+ 
+ 8.1 KVM_CAP_PPC_HWRNG
+ 
+ Architectures: ppc
+ 
+ This capability, if KVM_CHECK_EXTENSION indicates that it is
+ available, means that that the kernel has an implementation of the
+ H_RANDOM hypercall backed by a hardware random-number generator.
+ If present, the kernel H_RANDOM handler can be enabled for guest use
+ with the KVM_CAP_PPC_ENABLE_HCALL capability.
++>>>>>>> b053b2aef25d (KVM: x86: Add EOI exit bitmap inference)
diff --cc arch/x86/include/asm/kvm_host.h
index 5d383a89c9d4,7a5f9debbcd8..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -657,6 -686,9 +657,12 @@@ struct kvm_arch 
  	u32 bsp_vcpu_id;
  
  	u64 disabled_quirks;
++<<<<<<< HEAD
++=======
+ 
+ 	bool irqchip_split;
+ 	u8 nr_reserved_ioapic_pins;
++>>>>>>> b053b2aef25d (KVM: x86: Add EOI exit bitmap inference)
  };
  
  struct kvm_vm_stat {
diff --cc arch/x86/kvm/ioapic.h
index 6e265cfcd86a,084617d37c74..000000000000
--- a/arch/x86/kvm/ioapic.h
+++ b/arch/x86/kvm/ioapic.h
@@@ -120,7 -121,7 +121,12 @@@ int kvm_irq_delivery_to_apic(struct kv
  		struct kvm_lapic_irq *irq, unsigned long *dest_map);
  int kvm_get_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state);
  int kvm_set_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state);
++<<<<<<< HEAD
 +void kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap,
 +			u32 *tmr);
++=======
+ void kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap);
+ void kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap);
++>>>>>>> b053b2aef25d (KVM: x86: Add EOI exit bitmap inference)
  
  #endif
diff --cc arch/x86/kvm/irq_comm.c
index c5bb82b0cf6b,177460998bb0..000000000000
--- a/arch/x86/kvm/irq_comm.c
+++ b/arch/x86/kvm/irq_comm.c
@@@ -327,3 -328,52 +327,55 @@@ int kvm_setup_default_irq_routing(struc
  	return kvm_set_irq_routing(kvm, default_routing,
  				   ARRAY_SIZE(default_routing), 0);
  }
++<<<<<<< HEAD
++=======
+ 
+ static const struct kvm_irq_routing_entry empty_routing[] = {};
+ 
+ int kvm_setup_empty_irq_routing(struct kvm *kvm)
+ {
+ 	return kvm_set_irq_routing(kvm, empty_routing, 0, 0);
+ }
+ 
+ void kvm_arch_irq_routing_update(struct kvm *kvm)
+ {
+ 	if (ioapic_in_kernel(kvm) || !irqchip_in_kernel(kvm))
+ 		return;
+ 	kvm_make_scan_ioapic_request(kvm);
+ }
+ 
+ void kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
+ {
+ 	struct kvm *kvm = vcpu->kvm;
+ 	struct kvm_kernel_irq_routing_entry *entry;
+ 	struct kvm_irq_routing_table *table;
+ 	u32 i, nr_ioapic_pins;
+ 	int idx;
+ 
+ 	/* kvm->irq_routing must be read after clearing
+ 	 * KVM_SCAN_IOAPIC. */
+ 	smp_mb();
+ 	idx = srcu_read_lock(&kvm->irq_srcu);
+ 	table = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+ 	nr_ioapic_pins = min_t(u32, table->nr_rt_entries,
+ 			       kvm->arch.nr_reserved_ioapic_pins);
+ 	for (i = 0; i < nr_ioapic_pins; ++i) {
+ 		hlist_for_each_entry(entry, &table->map[i], link) {
+ 			u32 dest_id, dest_mode;
+ 
+ 			if (entry->type != KVM_IRQ_ROUTING_MSI)
+ 				continue;
+ 			dest_id = (entry->msi.address_lo >> 12) & 0xff;
+ 			dest_mode = (entry->msi.address_lo >> 2) & 0x1;
+ 			if (kvm_apic_match_dest(vcpu, NULL, 0, dest_id,
+ 						dest_mode)) {
+ 				u32 vector = entry->msi.data & 0xff;
+ 
+ 				__set_bit(vector,
+ 					  (unsigned long *) eoi_exit_bitmap);
+ 			}
+ 		}
+ 	}
+ 	srcu_read_unlock(&kvm->irq_srcu, idx);
+ }
++>>>>>>> b053b2aef25d (KVM: x86: Add EOI exit bitmap inference)
diff --cc arch/x86/kvm/lapic.c
index 1ea3691b454e,2f4c0d0cbe0a..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -209,7 -209,7 +209,11 @@@ out
  	if (old)
  		kfree_rcu(old, rcu);
  
++<<<<<<< HEAD
 +	kvm_vcpu_request_scan_ioapic(kvm);
++=======
+ 	kvm_make_scan_ioapic_request(kvm);
++>>>>>>> b053b2aef25d (KVM: x86: Add EOI exit bitmap inference)
  }
  
  static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)
diff --cc arch/x86/kvm/x86.c
index 733894b44f8d,4aeed2086c5e..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -3970,6 -3556,28 +3970,31 @@@ static int kvm_vm_ioctl_enable_cap(stru
  		kvm->arch.disabled_quirks = cap->args[0];
  		r = 0;
  		break;
++<<<<<<< HEAD
++=======
+ 	case KVM_CAP_SPLIT_IRQCHIP: {
+ 		mutex_lock(&kvm->lock);
+ 		r = -EINVAL;
+ 		if (cap->args[0] > MAX_NR_RESERVED_IOAPIC_PINS)
+ 			goto split_irqchip_unlock;
+ 		r = -EEXIST;
+ 		if (irqchip_in_kernel(kvm))
+ 			goto split_irqchip_unlock;
+ 		if (atomic_read(&kvm->online_vcpus))
+ 			goto split_irqchip_unlock;
+ 		r = kvm_setup_empty_irq_routing(kvm);
+ 		if (r)
+ 			goto split_irqchip_unlock;
+ 		/* Pairs with irqchip_in_kernel. */
+ 		smp_wmb();
+ 		kvm->arch.irqchip_split = true;
+ 		kvm->arch.nr_reserved_ioapic_pins = cap->args[0];
+ 		r = 0;
+ split_irqchip_unlock:
+ 		mutex_unlock(&kvm->lock);
+ 		break;
+ 	}
++>>>>>>> b053b2aef25d (KVM: x86: Add EOI exit bitmap inference)
  	default:
  		r = -EINVAL;
  		break;
@@@ -6630,13 -6169,19 +6655,27 @@@ static void vcpu_scan_ioapic(struct kvm
  	if (!kvm_apic_hw_enabled(vcpu->arch.apic))
  		return;
  
 -	memset(vcpu->arch.eoi_exit_bitmap, 0, 256 / 8);
 +	memset(eoi_exit_bitmap, 0, 32);
 +	memset(tmr, 0, 32);
  
++<<<<<<< HEAD
 +	kvm_x86_ops->sync_pir_to_irr(vcpu);
 +	kvm_ioapic_scan_entry(vcpu, eoi_exit_bitmap, tmr);
 +	kvm_x86_ops->load_eoi_exitmap(vcpu, eoi_exit_bitmap);
 +	kvm_apic_update_tmr(vcpu, tmr);
++=======
+ 	if (irqchip_split(vcpu->kvm))
+ 		kvm_scan_ioapic_routes(vcpu, vcpu->arch.eoi_exit_bitmap);
+ 	else
+ 		kvm_ioapic_scan_entry(vcpu, vcpu->arch.eoi_exit_bitmap);
+ 	kvm_x86_ops->load_eoi_exitmap(vcpu);
+ }
+ 
+ static void kvm_vcpu_flush_tlb(struct kvm_vcpu *vcpu)
+ {
+ 	++vcpu->stat.tlb_flush;
+ 	kvm_x86_ops->tlb_flush(vcpu);
++>>>>>>> b053b2aef25d (KVM: x86: Add EOI exit bitmap inference)
  }
  
  void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)
* Unmerged path Documentation/virtual/kvm/api.txt
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/ioapic.h
* Unmerged path arch/x86/kvm/irq_comm.c
* Unmerged path arch/x86/kvm/lapic.c
* Unmerged path arch/x86/kvm/x86.c
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index cf1b632f8991..dcf40e21b858 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -321,6 +321,18 @@ struct kvm_kernel_irq_routing_entry {
 	struct hlist_node link;
 };
 
+#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING
+struct kvm_irq_routing_table {
+	int chip[KVM_NR_IRQCHIPS][KVM_IRQCHIP_NUM_PINS];
+	u32 nr_rt_entries;
+	/*
+	 * Array indexed by gsi. Each entry contains list of irq chips
+	 * the gsi is connected to.
+	 */
+	struct hlist_head map[0];
+};
+#endif
+
 #ifndef KVM_PRIVATE_MEM_SLOTS
 #define KVM_PRIVATE_MEM_SLOTS 0
 #endif
@@ -447,10 +459,14 @@ void vcpu_put(struct kvm_vcpu *vcpu);
 
 #ifdef __KVM_HAVE_IOAPIC
 void kvm_vcpu_request_scan_ioapic(struct kvm *kvm);
+void kvm_arch_irq_routing_update(struct kvm *kvm);
 #else
 static inline void kvm_vcpu_request_scan_ioapic(struct kvm *kvm)
 {
 }
+static inline void kvm_arch_irq_routing_update(struct kvm *kvm)
+{
+}
 #endif
 
 #ifdef CONFIG_HAVE_KVM_IRQFD
diff --git a/virt/kvm/irqchip.c b/virt/kvm/irqchip.c
index d8fad563f14a..7d31d8c5b9ea 100644
--- a/virt/kvm/irqchip.c
+++ b/virt/kvm/irqchip.c
@@ -31,16 +31,6 @@
 #include <trace/events/kvm.h>
 #include "irq.h"
 
-struct kvm_irq_routing_table {
-	int chip[KVM_NR_IRQCHIPS][KVM_IRQCHIP_NUM_PINS];
-	u32 nr_rt_entries;
-	/*
-	 * Array indexed by gsi. Each entry contains list of irq chips
-	 * the gsi is connected to.
-	 */
-	struct hlist_head map[0];
-};
-
 int kvm_irq_map_gsi(struct kvm *kvm,
 		    struct kvm_kernel_irq_routing_entry *entries, int gsi)
 {
@@ -231,6 +221,8 @@ int kvm_set_irq_routing(struct kvm *kvm,
 	kvm_irq_routing_update(kvm);
 	mutex_unlock(&kvm->irq_lock);
 
+	kvm_arch_irq_routing_update(kvm);
+
 	synchronize_srcu_expedited(&kvm->irq_srcu);
 
 	new = old;
