btrfs: cleanup 64bit/32bit divs, provably bounded values

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author David Sterba <dsterba@suse.cz>
commit c7abe829c04dc8ce0ecd1c07bf3bc97d2bb9655e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c7abe829.failed

The divisor is derived from nodesize or PAGE_SIZE, fits into 32bit type.
Get rid of a few more do_div instances.

	Signed-off-by: David Sterba <dsterba@suse.cz>
(cherry picked from commit c7abe829c04dc8ce0ecd1c07bf3bc97d2bb9655e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/volumes.c
diff --cc fs/btrfs/volumes.c
index 0455a2c06b77,36c9c1a89232..000000000000
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@@ -5150,18 -5193,13 +5150,18 @@@ static int __btrfs_map_block(struct btr
  			mirror_num = stripe_index - old_stripe_index + 1;
  		}
  
 -	} else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {
 -		if (need_raid_map &&
 +	} else if (map->type & (BTRFS_BLOCK_GROUP_RAID5 |
 +				BTRFS_BLOCK_GROUP_RAID6)) {
 +		u64 tmp;
 +
 +		if (raid_map_ret &&
  		    ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||
  		     mirror_num > 1)) {
 +			int i, rot;
 +
  			/* push stripe_nr back to the start of the full stripe */
- 			stripe_nr = raid56_full_stripe_start;
- 			do_div(stripe_nr, stripe_len * nr_data_stripes(map));
+ 			stripe_nr = div_u64(raid56_full_stripe_start,
+ 					stripe_len * nr_data_stripes(map));
  
  			/* RAID[56] write or recovery. Return all stripes */
  			num_stripes = map->num_stripes;
@@@ -5494,12 -5535,11 +5494,18 @@@ int btrfs_rmap_block(struct btrfs_mappi
  	rmap_len = map->stripe_len;
  
  	if (map->type & BTRFS_BLOCK_GROUP_RAID10)
- 		do_div(length, map->num_stripes / map->sub_stripes);
+ 		length = div_u64(length, map->num_stripes / map->sub_stripes);
  	else if (map->type & BTRFS_BLOCK_GROUP_RAID0)
++<<<<<<< HEAD
 +		do_div(length, map->num_stripes);
 +	else if (map->type & (BTRFS_BLOCK_GROUP_RAID5 |
 +			      BTRFS_BLOCK_GROUP_RAID6)) {
 +		do_div(length, nr_data_stripes(map));
++=======
+ 		length = div_u64(length, map->num_stripes);
+ 	else if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {
+ 		length = div_u64(length, nr_data_stripes(map));
++>>>>>>> c7abe829c04d (btrfs: cleanup 64bit/32bit divs, provably bounded values)
  		rmap_len = map->stripe_len * nr_data_stripes(map);
  	}
  
diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index 73349126f84f..03de3861000e 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -5074,7 +5074,7 @@ static u64 calc_csum_metadata_size(struct inode *inode, u64 num_bytes,
 	    BTRFS_I(inode)->csum_bytes == 0)
 		return 0;
 
-	old_csums = (int)div64_u64(BTRFS_I(inode)->csum_bytes, root->sectorsize);
+	old_csums = (int)div_u64(BTRFS_I(inode)->csum_bytes, root->sectorsize);
 	if (reserve)
 		BTRFS_I(inode)->csum_bytes += num_bytes;
 	else
@@ -5083,7 +5083,7 @@ static u64 calc_csum_metadata_size(struct inode *inode, u64 num_bytes,
 	num_csums_per_leaf = (int)div_u64(csum_size,
 					    sizeof(struct btrfs_csum_item) +
 					    sizeof(struct btrfs_disk_key));
-	num_csums = (int)div64_u64(BTRFS_I(inode)->csum_bytes, root->sectorsize);
+	num_csums = (int)div_u64(BTRFS_I(inode)->csum_bytes, root->sectorsize);
 	num_csums = num_csums + num_csums_per_leaf - 1;
 	num_csums = num_csums / num_csums_per_leaf;
 
diff --git a/fs/btrfs/free-space-cache.c b/fs/btrfs/free-space-cache.c
index 6e5d0abec6f9..13c9b46d4727 100644
--- a/fs/btrfs/free-space-cache.c
+++ b/fs/btrfs/free-space-cache.c
@@ -1298,11 +1298,11 @@ static inline u64 offset_to_bitmap(struct btrfs_free_space_ctl *ctl,
 				   u64 offset)
 {
 	u64 bitmap_start;
-	u64 bytes_per_bitmap;
+	u32 bytes_per_bitmap;
 
 	bytes_per_bitmap = BITS_PER_BITMAP * ctl->unit;
 	bitmap_start = offset - ctl->start;
-	bitmap_start = div64_u64(bitmap_start, bytes_per_bitmap);
+	bitmap_start = div_u64(bitmap_start, bytes_per_bitmap);
 	bitmap_start *= bytes_per_bitmap;
 	bitmap_start += ctl->start;
 
@@ -1521,10 +1521,10 @@ static void recalculate_thresholds(struct btrfs_free_space_ctl *ctl)
 	u64 bitmap_bytes;
 	u64 extent_bytes;
 	u64 size = block_group->key.offset;
-	u64 bytes_per_bg = BITS_PER_BITMAP * ctl->unit;
-	int max_bitmaps = div64_u64(size + bytes_per_bg - 1, bytes_per_bg);
+	u32 bytes_per_bg = BITS_PER_BITMAP * ctl->unit;
+	u32 max_bitmaps = div_u64(size + bytes_per_bg - 1, bytes_per_bg);
 
-	max_bitmaps = max(max_bitmaps, 1);
+	max_bitmaps = max_t(u32, max_bitmaps, 1);
 
 	ASSERT(ctl->total_bitmaps <= max_bitmaps);
 
diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c
index e02bd293dc3c..70128f46105e 100644
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -1561,7 +1561,7 @@ static noinline int btrfs_ioctl_resize(struct file *file,
 		goto out_free;
 	}
 
-	do_div(new_size, root->sectorsize);
+	new_size = div_u64(new_size, root->sectorsize);
 	new_size *= root->sectorsize;
 
 	printk_in_rcu(KERN_INFO "BTRFS: new size for %s is %llu\n",
diff --git a/fs/btrfs/scrub.c b/fs/btrfs/scrub.c
index 5662ab657252..33b3abf154fc 100644
--- a/fs/btrfs/scrub.c
+++ b/fs/btrfs/scrub.c
@@ -2637,9 +2637,8 @@ static int get_raid56_logic_offset(u64 physical, int num,
 	for (i = 0; i < nr_data_stripes(map); i++) {
 		*offset = last_offset + i * map->stripe_len;
 
-		stripe_nr = *offset;
-		do_div(stripe_nr, map->stripe_len);
-		do_div(stripe_nr, nr_data_stripes(map));
+		stripe_nr = div_u64(*offset, map->stripe_len);
+		stripe_nr = div_u64(stripe_nr, nr_data_stripes(map));
 
 		/* Work out the disk rotation on this stripe-set */
 		rot = do_div(stripe_nr, map->num_stripes);
@@ -3011,10 +3010,9 @@ static noinline_for_stack int scrub_stripe(struct scrub_ctx *sctx,
 	int extent_mirror_num;
 	int stop_loop = 0;
 
-	nstripes = length;
 	physical = map->stripes[num].physical;
 	offset = 0;
-	do_div(nstripes, map->stripe_len);
+	nstripes = div_u64(length, map->stripe_len);
 	if (map->type & BTRFS_BLOCK_GROUP_RAID0) {
 		offset = map->stripe_len * num;
 		increment = map->stripe_len * map->num_stripes;
* Unmerged path fs/btrfs/volumes.c
