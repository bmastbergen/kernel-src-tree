sctp: sctp_remaddr_seq_show use the wrong variable to dump transport info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit 3d73e8fac8f84942f15307d6d9cb1dba843d3fb2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3d73e8fa.failed

Now in sctp_remaddr_seq_show(), we use variable *tsp to get the param *v.
but *tsp is also used to traversal transport_addr_list, which will cover
the previous value, and make sctp_transport_put work on the wrong transport.

So fix it by adding a new variable to get the param *v.

Fixes: fba4c330c5b9 ("sctp: hold transport before we access t->asoc in sctp proc")
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3d73e8fac8f84942f15307d6d9cb1dba843d3fb2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/proc.c
diff --cc net/sctp/proc.c
index aaeecb033eeb,963dffcc2618..000000000000
--- a/net/sctp/proc.c
+++ b/net/sctp/proc.c
@@@ -443,85 -481,74 +443,149 @@@ static void sctp_remaddr_seq_stop(struc
  
  static int sctp_remaddr_seq_show(struct seq_file *seq, void *v)
  {
 +	struct sctp_hashbucket *head;
 +	struct sctp_ep_common *epb;
  	struct sctp_association *assoc;
++<<<<<<< HEAD
 +	struct sctp_transport *tsp;
 +	int    hash = *(loff_t *)v;
++=======
+ 	struct sctp_transport *transport, *tsp;
++>>>>>>> 3d73e8fac8f8 (sctp: sctp_remaddr_seq_show use the wrong variable to dump transport info)
  
 -	if (v == SEQ_START_TOKEN) {
 -		seq_printf(seq, "ADDR ASSOC_ID HB_ACT RTO MAX_PATH_RTX "
 -				"REM_ADDR_RTX START STATE\n");
 -		return 0;
 +	if (hash >= sctp_assoc_hashsize)
 +		return -ENOMEM;
 +
 +	head = &sctp_assoc_hashtable[hash];
 +	sctp_local_bh_disable();
 +	read_lock(&head->lock);
 +	rcu_read_lock();
 +	sctp_for_each_hentry(epb, &head->chain) {
 +		if (!net_eq(sock_net(epb->sk), seq_file_net(seq)))
 +			continue;
 +		assoc = sctp_assoc(epb);
 +		list_for_each_entry_rcu(tsp, &assoc->peer.transport_addr_list,
 +					transports) {
 +			if (tsp->dead)
 +				continue;
 +
 +			/*
 +			 * The remote address (ADDR)
 +			 */
 +			tsp->af_specific->seq_dump_addr(seq, &tsp->ipaddr);
 +			seq_printf(seq, " ");
 +
 +			/*
 +			 * The association ID (ASSOC_ID)
 +			 */
 +			seq_printf(seq, "%d ", tsp->asoc->assoc_id);
 +
 +			/*
 +			 * If the Heartbeat is active (HB_ACT)
 +			 * Note: 1 = Active, 0 = Inactive
 +			 */
 +			seq_printf(seq, "%d ", timer_pending(&tsp->hb_timer));
 +
 +			/*
 +			 * Retransmit time out (RTO)
 +			 */
 +			seq_printf(seq, "%lu ", tsp->rto);
 +
 +			/*
 +			 * Maximum path retransmit count (PATH_MAX_RTX)
 +			 */
 +			seq_printf(seq, "%d ", tsp->pathmaxrxt);
 +
 +			/*
 +			 * remote address retransmit count (REM_ADDR_RTX)
 +			 * Note: We don't have a way to tally this at the moment
 +			 * so lets just leave it as zero for the moment
 +			 */
 +			seq_puts(seq, "0 ");
 +
 +			/*
 +			 * remote address start time (START).  This is also not
 +			 * currently implemented, but we can record it with a
 +			 * jiffies marker in a subsequent patch
 +			 */
 +			seq_puts(seq, "0 ");
 +
 +			/*
 +			 * The current state of this destination. I.e.
 +			 * SCTP_ACTIVE, SCTP_INACTIVE, ...
 +			 */
 +			seq_printf(seq, "%d", tsp->state);
 +
 +			seq_printf(seq, "\n");
 +		}
  	}
  
++<<<<<<< HEAD
 +	rcu_read_unlock();
 +	read_unlock(&head->lock);
 +	sctp_local_bh_enable();
++=======
+ 	transport = (struct sctp_transport *)v;
+ 	if (!sctp_transport_hold(transport))
+ 		return 0;
+ 	assoc = transport->asoc;
+ 
+ 	list_for_each_entry_rcu(tsp, &assoc->peer.transport_addr_list,
+ 				transports) {
+ 		/*
+ 		 * The remote address (ADDR)
+ 		 */
+ 		tsp->af_specific->seq_dump_addr(seq, &tsp->ipaddr);
+ 		seq_printf(seq, " ");
+ 		/*
+ 		 * The association ID (ASSOC_ID)
+ 		 */
+ 		seq_printf(seq, "%d ", tsp->asoc->assoc_id);
+ 
+ 		/*
+ 		 * If the Heartbeat is active (HB_ACT)
+ 		 * Note: 1 = Active, 0 = Inactive
+ 		 */
+ 		seq_printf(seq, "%d ", timer_pending(&tsp->hb_timer));
+ 
+ 		/*
+ 		 * Retransmit time out (RTO)
+ 		 */
+ 		seq_printf(seq, "%lu ", tsp->rto);
+ 
+ 		/*
+ 		 * Maximum path retransmit count (PATH_MAX_RTX)
+ 		 */
+ 		seq_printf(seq, "%d ", tsp->pathmaxrxt);
+ 
+ 		/*
+ 		 * remote address retransmit count (REM_ADDR_RTX)
+ 		 * Note: We don't have a way to tally this at the moment
+ 		 * so lets just leave it as zero for the moment
+ 		 */
+ 		seq_puts(seq, "0 ");
+ 
+ 		/*
+ 		 * remote address start time (START).  This is also not
+ 		 * currently implemented, but we can record it with a
+ 		 * jiffies marker in a subsequent patch
+ 		 */
+ 		seq_puts(seq, "0 ");
+ 
+ 		/*
+ 		 * The current state of this destination. I.e.
+ 		 * SCTP_ACTIVE, SCTP_INACTIVE, ...
+ 		 */
+ 		seq_printf(seq, "%d", tsp->state);
+ 
+ 		seq_printf(seq, "\n");
+ 	}
+ 
+ 	sctp_transport_put(transport);
++>>>>>>> 3d73e8fac8f8 (sctp: sctp_remaddr_seq_show use the wrong variable to dump transport info)
  
  	return 0;
 +
  }
  
  static const struct seq_operations sctp_remaddr_ops = {
* Unmerged path net/sctp/proc.c
