mmc: core: Enable tuning according to the actual timing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] core: Enable tuning according to the actual timing (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 95.24%
commit-author Carlo Caione <carlo@endlessm.com>
commit e10c321977091f163eceedec0650e0ef4b3cf4bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e10c3219.failed

While in sdhci_execute_tuning() the choice whether or not to enable the
tuning is done on the actual timing, in the mmc_sdio_init_uhs_card() the
check is done on the capability of the card.

This difference is causing some issues with some SDIO cards in DDR50
mode where the CDM19 is wrongly issued.

With this patch we modify the check in both
mmc_(sd|sdio)_init_uhs_card() functions to take the proper decision
only according to the actual timing specification.

	Cc: stable@vger.kernel.org
	Signed-off-by: Carlo Caione <carlo@endlessm.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit e10c321977091f163eceedec0650e0ef4b3cf4bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/sd.c
#	drivers/mmc/core/sdio.c
diff --cc drivers/mmc/core/sd.c
index 708581a6c201,bb39a29b2db6..000000000000
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@@ -672,13 -637,24 +672,34 @@@ static int mmc_sd_init_uhs_card(struct 
  	 * SPI mode doesn't define CMD19 and tuning is only valid for SDR50 and
  	 * SDR104 mode SD-cards. Note that tuning is mandatory for SDR104.
  	 */
++<<<<<<< HEAD
 +	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning &&
 +			(card->sd_bus_speed == UHS_SDR50_BUS_SPEED ||
 +			 card->sd_bus_speed == UHS_SDR104_BUS_SPEED)) {
 +		mmc_host_clk_hold(card->host);
 +		err = card->host->ops->execute_tuning(card->host,
 +						      MMC_SEND_TUNING_BLOCK);
 +		mmc_host_clk_release(card->host);
++=======
+ 	if (!mmc_host_is_spi(card->host) &&
+ 		(card->host->ios.timing == MMC_TIMING_UHS_SDR50 ||
+ 		 card->host->ios.timing == MMC_TIMING_UHS_DDR50 ||
+ 		 card->host->ios.timing == MMC_TIMING_UHS_SDR104)) {
+ 		err = mmc_execute_tuning(card);
+ 
+ 		/*
+ 		 * As SD Specifications Part1 Physical Layer Specification
+ 		 * Version 3.01 says, CMD19 tuning is available for unlocked
+ 		 * cards in transfer state of 1.8V signaling mode. The small
+ 		 * difference between v3.00 and 3.01 spec means that CMD19
+ 		 * tuning is also available for DDR50 mode.
+ 		 */
+ 		if (err && card->host->ios.timing == MMC_TIMING_UHS_DDR50) {
+ 			pr_warn("%s: ddr50 tuning failed\n",
+ 				mmc_hostname(card->host));
+ 			err = 0;
+ 		}
++>>>>>>> e10c32197709 (mmc: core: Enable tuning according to the actual timing)
  	}
  
  out:
diff --cc drivers/mmc/core/sdio.c
index 4c2d5cf20802,467b3cf80c44..000000000000
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@@ -565,17 -534,11 +565,24 @@@ static int mmc_sdio_init_uhs_card(struc
  	 * SPI mode doesn't define CMD19 and tuning is only valid for SDR50 and
  	 * SDR104 mode SD-cards. Note that tuning is mandatory for SDR104.
  	 */
++<<<<<<< HEAD
 +	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning &&
 +			((card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR50) ||
 +			 (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104))) {
 +		mmc_host_clk_hold(card->host);
 +		err = card->host->ops->execute_tuning(card->host,
 +						      MMC_SEND_TUNING_BLOCK);
 +		mmc_host_clk_release(card->host);
 +	}
 +
++=======
+ 	if (!mmc_host_is_spi(card->host) &&
+ 	    ((card->host->ios.timing == MMC_TIMING_UHS_SDR50) ||
+ 	      (card->host->ios.timing == MMC_TIMING_UHS_SDR104)))
+ 		err = mmc_execute_tuning(card);
++>>>>>>> e10c32197709 (mmc: core: Enable tuning according to the actual timing)
  out:
 +
  	return err;
  }
  
* Unmerged path drivers/mmc/core/sd.c
* Unmerged path drivers/mmc/core/sdio.c
