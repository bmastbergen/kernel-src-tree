sctp: identify chunks that need to be fragmented at IP level

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
commit 7303a1475008bee5c3e82a06a282568415690d72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7303a147.failed

Previously, without GSO, it was easy to identify it: if the chunk didn't
fit and there was no data chunk in the packet yet, we could fragment at
IP level. So if there was an auth chunk and we were bundling a big data
chunk, it would fragment regardless of the size of the auth chunk. This
also works for the context of PMTU reductions.

But with GSO, we cannot distinguish such PMTU events anymore, as the
packet is allowed to exceed PMTU.

So we need another check: to ensure that the chunk that we are adding,
actually fits the current PMTU. If it doesn't, trigger a flush and let
it be fragmented at IP level in the next round.

	Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7303a1475008bee5c3e82a06a282568415690d72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/output.c
diff --cc net/sctp/output.c
index b1ac80d971ea,31b7bc35895d..000000000000
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@@ -763,9 -878,7 +763,13 @@@ static sctp_xmit_t sctp_packet_will_fit
  					struct sctp_chunk *chunk,
  					u16 chunk_len)
  {
++<<<<<<< HEAD
 +	size_t psize;
 +	size_t pmtu;
 +	int too_big;
++=======
+ 	size_t psize, pmtu, maxsize;
++>>>>>>> 7303a1475008 (sctp: identify chunks that need to be fragmented at IP level)
  	sctp_xmit_t retval = SCTP_XMIT_OK;
  
  	psize = packet->size;
@@@ -792,10 -903,49 +796,52 @@@
  			 * actually hit this condition
  			 */
  			packet->ipfragok = 1;
 -			goto out;
 +		} else {
 +			retval = SCTP_XMIT_PMTU_FULL;
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		/* Similarly, if this chunk was built before a PMTU
+ 		 * reduction, we have to fragment it at IP level now. So
+ 		 * if the packet already contains something, we need to
+ 		 * flush.
+ 		 */
+ 		maxsize = pmtu - packet->overhead;
+ 		if (packet->auth)
+ 			maxsize -= WORD_ROUND(packet->auth->skb->len);
+ 		if (chunk_len > maxsize)
+ 			retval = SCTP_XMIT_PMTU_FULL;
+ 
+ 		/* It is also okay to fragment if the chunk we are
+ 		 * adding is a control chunk, but only if current packet
+ 		 * is not a GSO one otherwise it causes fragmentation of
+ 		 * a large frame. So in this case we allow the
+ 		 * fragmentation by forcing it to be in a new packet.
+ 		 */
+ 		if (!sctp_chunk_is_data(chunk) && packet->has_data)
+ 			retval = SCTP_XMIT_PMTU_FULL;
+ 
+ 		if (psize + chunk_len > packet->max_size)
+ 			/* Hit GSO/PMTU limit, gotta flush */
+ 			retval = SCTP_XMIT_PMTU_FULL;
+ 
+ 		if (!packet->transport->burst_limited &&
+ 		    psize + chunk_len > (packet->transport->cwnd >> 1))
+ 			/* Do not allow a single GSO packet to use more
+ 			 * than half of cwnd.
+ 			 */
+ 			retval = SCTP_XMIT_PMTU_FULL;
+ 
+ 		if (packet->transport->burst_limited &&
+ 		    psize + chunk_len > (packet->transport->burst_limited >> 1))
+ 			/* Do not allow a single GSO packet to use more
+ 			 * than half of original cwnd.
+ 			 */
+ 			retval = SCTP_XMIT_PMTU_FULL;
+ 		/* Otherwise it will fit in the GSO packet */
++>>>>>>> 7303a1475008 (sctp: identify chunks that need to be fragmented at IP level)
  	}
  
 -out:
  	return retval;
  }
* Unmerged path net/sctp/output.c
