perf tools: Add event_update event cpus type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 86ebb09f96fe6886e1e5d53b648df5537ba859ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/86ebb09f.failed

Adding the cpumask 'event update' event, that stores/transfer the
cpumask for a event.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Kan Liang <kan.liang@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1445784728-21732-25-git-send-email-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 86ebb09f96fe6886e1e5d53b648df5537ba859ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/tests/event_update.c
#	tools/perf/util/event.h
#	tools/perf/util/header.c
#	tools/perf/util/header.h
diff --cc tools/perf/util/event.h
index 9400ef1c1335,b7ffb7ee9971..000000000000
--- a/tools/perf/util/event.h
+++ b/tools/perf/util/event.h
@@@ -276,6 -308,29 +276,32 @@@ struct attr_event 
  	u64 id[];
  };
  
++<<<<<<< HEAD
++=======
+ enum {
+ 	PERF_EVENT_UPDATE__UNIT  = 0,
+ 	PERF_EVENT_UPDATE__SCALE = 1,
+ 	PERF_EVENT_UPDATE__NAME  = 2,
+ 	PERF_EVENT_UPDATE__CPUS  = 3,
+ };
+ 
+ struct event_update_event_cpus {
+ 	struct cpu_map_data cpus;
+ };
+ 
+ struct event_update_event_scale {
+ 	double scale;
+ };
+ 
+ struct event_update_event {
+ 	struct perf_event_header header;
+ 	u64 type;
+ 	u64 id;
+ 
+ 	char data[];
+ };
+ 
++>>>>>>> 86ebb09f96fe (perf tools: Add event_update event cpus type)
  #define MAX_EVENT_NAME 64
  
  struct perf_trace_event_type {
diff --cc tools/perf/util/header.c
index 5ac7bdb0dff7,79d3eb984db7..000000000000
--- a/tools/perf/util/header.c
+++ b/tools/perf/util/header.c
@@@ -2686,6 -2686,114 +2686,117 @@@ int perf_event__synthesize_attr(struct 
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static struct event_update_event *
+ event_update_event__new(size_t size, u64 type, u64 id)
+ {
+ 	struct event_update_event *ev;
+ 
+ 	size += sizeof(*ev);
+ 	size  = PERF_ALIGN(size, sizeof(u64));
+ 
+ 	ev = zalloc(size);
+ 	if (ev) {
+ 		ev->header.type = PERF_RECORD_EVENT_UPDATE;
+ 		ev->header.size = (u16)size;
+ 		ev->type = type;
+ 		ev->id = id;
+ 	}
+ 	return ev;
+ }
+ 
+ int
+ perf_event__synthesize_event_update_unit(struct perf_tool *tool,
+ 					 struct perf_evsel *evsel,
+ 					 perf_event__handler_t process)
+ {
+ 	struct event_update_event *ev;
+ 	size_t size = strlen(evsel->unit);
+ 	int err;
+ 
+ 	ev = event_update_event__new(size + 1, PERF_EVENT_UPDATE__UNIT, evsel->id[0]);
+ 	if (ev == NULL)
+ 		return -ENOMEM;
+ 
+ 	strncpy(ev->data, evsel->unit, size);
+ 	err = process(tool, (union perf_event *)ev, NULL, NULL);
+ 	free(ev);
+ 	return err;
+ }
+ 
+ int
+ perf_event__synthesize_event_update_scale(struct perf_tool *tool,
+ 					  struct perf_evsel *evsel,
+ 					  perf_event__handler_t process)
+ {
+ 	struct event_update_event *ev;
+ 	struct event_update_event_scale *ev_data;
+ 	int err;
+ 
+ 	ev = event_update_event__new(sizeof(*ev_data), PERF_EVENT_UPDATE__SCALE, evsel->id[0]);
+ 	if (ev == NULL)
+ 		return -ENOMEM;
+ 
+ 	ev_data = (struct event_update_event_scale *) ev->data;
+ 	ev_data->scale = evsel->scale;
+ 	err = process(tool, (union perf_event*) ev, NULL, NULL);
+ 	free(ev);
+ 	return err;
+ }
+ 
+ int
+ perf_event__synthesize_event_update_name(struct perf_tool *tool,
+ 					 struct perf_evsel *evsel,
+ 					 perf_event__handler_t process)
+ {
+ 	struct event_update_event *ev;
+ 	size_t len = strlen(evsel->name);
+ 	int err;
+ 
+ 	ev = event_update_event__new(len + 1, PERF_EVENT_UPDATE__NAME, evsel->id[0]);
+ 	if (ev == NULL)
+ 		return -ENOMEM;
+ 
+ 	strncpy(ev->data, evsel->name, len);
+ 	err = process(tool, (union perf_event*) ev, NULL, NULL);
+ 	free(ev);
+ 	return err;
+ }
+ 
+ int
+ perf_event__synthesize_event_update_cpus(struct perf_tool *tool,
+ 					struct perf_evsel *evsel,
+ 					perf_event__handler_t process)
+ {
+ 	size_t size = sizeof(struct event_update_event);
+ 	struct event_update_event *ev;
+ 	int max, err;
+ 	u16 type;
+ 
+ 	if (!evsel->own_cpus)
+ 		return 0;
+ 
+ 	ev = cpu_map_data__alloc(evsel->own_cpus, &size, &type, &max);
+ 	if (!ev)
+ 		return -ENOMEM;
+ 
+ 	ev->header.type = PERF_RECORD_EVENT_UPDATE;
+ 	ev->header.size = (u16)size;
+ 	ev->type = PERF_EVENT_UPDATE__CPUS;
+ 	ev->id   = evsel->id[0];
+ 
+ 	cpu_map_data__synthesize((struct cpu_map_data *) ev->data,
+ 				 evsel->own_cpus,
+ 				 type, max);
+ 
+ 	err = process(tool, (union perf_event*) ev, NULL, NULL);
+ 	free(ev);
+ 	return err;
+ }
+ 
+ 
++>>>>>>> 86ebb09f96fe (perf tools: Add event_update event cpus type)
  int perf_event__synthesize_attrs(struct perf_tool *tool,
  				   struct perf_session *session,
  				   perf_event__handler_t process)
@@@ -2745,6 -2853,51 +2856,54 @@@ int perf_event__process_attr(struct per
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ int perf_event__process_event_update(struct perf_tool *tool __maybe_unused,
+ 				     union perf_event *event,
+ 				     struct perf_evlist **pevlist)
+ {
+ 	struct event_update_event *ev = &event->event_update;
+ 	struct event_update_event_scale *ev_scale;
+ 	struct event_update_event_cpus *ev_cpus;
+ 	struct perf_evlist *evlist;
+ 	struct perf_evsel *evsel;
+ 	struct cpu_map *map;
+ 
+ 	if (!pevlist || *pevlist == NULL)
+ 		return -EINVAL;
+ 
+ 	evlist = *pevlist;
+ 
+ 	evsel = perf_evlist__id2evsel(evlist, ev->id);
+ 	if (evsel == NULL)
+ 		return -EINVAL;
+ 
+ 	switch (ev->type) {
+ 	case PERF_EVENT_UPDATE__UNIT:
+ 		evsel->unit = strdup(ev->data);
+ 		break;
+ 	case PERF_EVENT_UPDATE__NAME:
+ 		evsel->name = strdup(ev->data);
+ 		break;
+ 	case PERF_EVENT_UPDATE__SCALE:
+ 		ev_scale = (struct event_update_event_scale *) ev->data;
+ 		evsel->scale = ev_scale->scale;
+ 	case PERF_EVENT_UPDATE__CPUS:
+ 		ev_cpus = (struct event_update_event_cpus *) ev->data;
+ 
+ 		map = cpu_map__new_data(&ev_cpus->cpus);
+ 		if (map)
+ 			evsel->own_cpus = map;
+ 		else
+ 			pr_err("failed to get event_update cpus\n");
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 86ebb09f96fe (perf tools: Add event_update event cpus type)
  int perf_event__synthesize_tracing_data(struct perf_tool *tool, int fd,
  					struct perf_evlist *evlist,
  					perf_event__handler_t process)
diff --cc tools/perf/util/header.h
index 05f27cb6b7e3,a1bc0c5706a3..000000000000
--- a/tools/perf/util/header.h
+++ b/tools/perf/util/header.h
@@@ -105,8 -105,23 +105,23 @@@ int perf_event__synthesize_attr(struct 
  int perf_event__synthesize_attrs(struct perf_tool *tool,
  				 struct perf_session *session,
  				 perf_event__handler_t process);
++<<<<<<< HEAD
++=======
+ int perf_event__synthesize_event_update_unit(struct perf_tool *tool,
+ 					     struct perf_evsel *evsel,
+ 					     perf_event__handler_t process);
+ int perf_event__synthesize_event_update_scale(struct perf_tool *tool,
+ 					      struct perf_evsel *evsel,
+ 					      perf_event__handler_t process);
+ int perf_event__synthesize_event_update_name(struct perf_tool *tool,
+ 					     struct perf_evsel *evsel,
+ 					     perf_event__handler_t process);
+ int perf_event__synthesize_event_update_cpus(struct perf_tool *tool,
+ 					     struct perf_evsel *evsel,
+ 					     perf_event__handler_t process);
++>>>>>>> 86ebb09f96fe (perf tools: Add event_update event cpus type)
  int perf_event__process_attr(struct perf_tool *tool, union perf_event *event,
  			     struct perf_evlist **pevlist);
 -int perf_event__process_event_update(struct perf_tool *tool __maybe_unused,
 -				     union perf_event *event,
 -				     struct perf_evlist **pevlist);
  
  int perf_event__synthesize_tracing_data(struct perf_tool *tool,
  					int fd, struct perf_evlist *evlist,
* Unmerged path tools/perf/tests/event_update.c
* Unmerged path tools/perf/tests/event_update.c
* Unmerged path tools/perf/util/event.h
* Unmerged path tools/perf/util/header.c
* Unmerged path tools/perf/util/header.h
