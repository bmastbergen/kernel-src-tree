watchdog: introduce the hardlockup_detector_disable() function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ulrich Obergfell <uobergfe@redhat.com>
commit 692297d8f96887f836d9049a653ed05a71cf48fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/692297d8.failed

Have kvm_guest_init() use hardlockup_detector_disable() instead of
watchdog_enable_hardlockup_detector(false).

Remove the watchdog_hardlockup_detector_is_enabled() and the
watchdog_enable_hardlockup_detector() function which are no longer needed.

	Signed-off-by: Ulrich Obergfell <uobergfe@redhat.com>
	Signed-off-by: Don Zickus <dzickus@redhat.com>
	Cc: Ingo Molnar <mingo@elte.hu>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 692297d8f96887f836d9049a653ed05a71cf48fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/watchdog.c
diff --cc kernel/watchdog.c
index 7204a1c34a5a,f2be11ab7e08..000000000000
--- a/kernel/watchdog.c
+++ b/kernel/watchdog.c
@@@ -528,14 -519,9 +521,20 @@@ static int watchdog_nmi_enable(unsigne
  	struct perf_event_attr *wd_attr;
  	struct perf_event *event = per_cpu(watchdog_ev, cpu);
  
++<<<<<<< HEAD
 +	/*
 +	 * Some kernels need to default hard lockup detection to
 +	 * 'disabled', for example a guest on a hypervisor.
 +	 */
 +	if (!watchdog_hardlockup_detector_is_enabled()) {
 +		event = ERR_PTR(-ENOENT);
 +		goto handle_err;
 +	}
++=======
+ 	/* nothing to do if the hard lockup detector is disabled */
+ 	if (!(watchdog_enabled & NMI_WATCHDOG_ENABLED))
+ 		goto out;
++>>>>>>> 692297d8f968 (watchdog: introduce the hardlockup_detector_disable() function)
  
  	/* is it already setup and enabled? */
  	if (event && event->state > PERF_EVENT_STATE_OFF)
diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.c
index dbe595635904..a739e90ea7b2 100644
--- a/arch/x86/kernel/kvm.c
+++ b/arch/x86/kernel/kvm.c
@@ -504,7 +504,7 @@ void __init kvm_guest_init(void)
 	 * can get false positives too easily, for example if the host is
 	 * overcommitted.
 	 */
-	watchdog_enable_hardlockup_detector(false);
+	hardlockup_detector_disable();
 }
 
 static noinline uint32_t __kvm_cpuid_base(void)
diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 6fe7c9ae7224..aeb8f35101f8 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -25,16 +25,11 @@ static inline void touch_nmi_watchdog(void)
 #endif
 
 #if defined(CONFIG_HARDLOCKUP_DETECTOR)
-extern void watchdog_enable_hardlockup_detector(bool val);
-extern bool watchdog_hardlockup_detector_is_enabled(void);
+extern void hardlockup_detector_disable(void);
 #else
-static inline void watchdog_enable_hardlockup_detector(bool val)
+static inline void hardlockup_detector_disable(void)
 {
 }
-static inline bool watchdog_hardlockup_detector_is_enabled(void)
-{
-	return true;
-}
 #endif
 
 /*
* Unmerged path kernel/watchdog.c
