netlink: Replace rhash_portid with bound

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit da314c9923fed553a007785a901fd395b7eb6c19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/da314c99.failed

On Mon, Sep 21, 2015 at 02:20:22PM -0400, Tejun Heo wrote:
>
> store_release and load_acquire are different from the usual memory
> barriers and can't be paired this way.  You have to pair store_release
> and load_acquire.  Besides, it isn't a particularly good idea to

OK I've decided to drop the acquire/release helpers as they don't
help us at all and simply pessimises the code by using full memory
barriers (on some architectures) where only a write or read barrier
is needed.

> depend on memory barriers embedded in other data structures like the
> above.  Here, especially, rhashtable_insert() would have write barrier
> *before* the entry is hashed not necessarily *after*, which means that
> in the above case, a socket which appears to have set bound to a
> reader might not visible when the reader tries to look up the socket
> on the hashtable.

But you are right we do need an explicit write barrier here to
ensure that the hashing is visible.

> There's no reason to be overly smart here.  This isn't a crazy hot
> path, write barriers tend to be very cheap, store_release more so.
> Please just do smp_store_release() and note what it's paired with.

It's not about being overly smart.  It's about actually understanding
what's going on with the code.  I've seen too many instances of
people simply sprinkling synchronisation primitives around without
any knowledge of what is happening underneath, which is just a recipe
for creating hard-to-debug races.

> > @@ -1539,7 +1546,7 @@ static int netlink_bind(struct socket *sock, struct sockaddr *addr,
> >  		}
> >  	}
> >
> > -	if (!nlk->portid) {
> > +	if (!nlk->bound) {
>
> I don't think you can skip load_acquire here just because this is the
> second deref of the variable.  That doesn't change anything.  Race
> condition could still happen between the first and second tests and
> skipping the second would lead to the same kind of bug.

The reason this one is OK is because we do not use nlk->portid or
try to get nlk from the hash table before we return to user-space.

However, there is a real bug here that none of these acquire/release
helpers discovered.  The two bound tests here used to be a single
one.  Now that they are separate it is entirely possible for another
thread to come in the middle and bind the socket.  So we need to
repeat the portid check in order to maintain consistency.

> > @@ -1587,7 +1594,7 @@ static int netlink_connect(struct socket *sock, struct sockaddr *addr,
> >  	    !netlink_allowed(sock, NL_CFG_F_NONROOT_SEND))
> >  		return -EPERM;
> >
> > -	if (!nlk->portid)
> > +	if (!nlk->bound)
>
> Don't we need load_acquire here too?  Is this path holding a lock
> which makes that unnecessary?

Ditto.

---8<---
The commit 1f770c0a09da855a2b51af6d19de97fb955eca85 ("netlink:
Fix autobind race condition that leads to zero port ID") created
some new races that can occur due to inconcsistencies between the
two port IDs.

Tejun is right that a barrier is unavoidable.  Therefore I am
reverting to the original patch that used a boolean to indicate
that a user netlink socket has been bound.

Barriers have been added where necessary to ensure that a valid
portid and the hashed socket is visible.

I have also changed netlink_insert to only return EBUSY if the
socket is bound to a portid different to the requested one.  This
combined with only reading nlk->bound once in netlink_bind fixes
a race where two threads that bind the socket at the same time
with different port IDs may both succeed.

Fixes: 1f770c0a09da ("netlink: Fix autobind race condition that leads to zero port ID")
	Reported-by: Tejun Heo <tj@kernel.org>
	Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Nacked-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit da314c9923fed553a007785a901fd395b7eb6c19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netlink/af_netlink.c
diff --cc net/netlink/af_netlink.c
index 8c03375d5550,8f060d7f9a0e..000000000000
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@@ -1018,25 -1021,46 +1018,54 @@@ struct netlink_compare_ar
  	u32 portid;
  };
  
 -/* Doing sizeof directly may yield 4 extra bytes on 64-bit. */
 -#define netlink_compare_arg_len \
 -	(offsetof(struct netlink_compare_arg, portid) + sizeof(u32))
 -
 -static inline int netlink_compare(struct rhashtable_compare_arg *arg,
 -				  const void *ptr)
 +static bool netlink_compare(void *ptr, void *arg)
  {
 -	const struct netlink_compare_arg *x = arg->key;
 -	const struct netlink_sock *nlk = ptr;
 +	struct netlink_compare_arg *x = arg;
 +	struct sock *sk = ptr;
  
++<<<<<<< HEAD
 +	return nlk_sk(sk)->portid == x->portid &&
 +	       net_eq(sock_net(sk), x->net);
++=======
+ 	return nlk->portid != x->portid ||
+ 	       !net_eq(sock_net(&nlk->sk), read_pnet(&x->pnet));
+ }
+ 
+ static void netlink_compare_arg_init(struct netlink_compare_arg *arg,
+ 				     struct net *net, u32 portid)
+ {
+ 	memset(arg, 0, sizeof(*arg));
+ 	write_pnet(&arg->pnet, net);
+ 	arg->portid = portid;
++>>>>>>> da314c9923fe (netlink: Replace rhash_portid with bound)
  }
  
  static struct sock *__netlink_lookup(struct netlink_table *table, u32 portid,
  				     struct net *net)
  {
 -	struct netlink_compare_arg arg;
 +	struct netlink_compare_arg arg = {
 +		.net = net,
 +		.portid = portid,
 +	};
  
++<<<<<<< HEAD
 +	return rhashtable_lookup_compare(&table->hash, &portid,
 +					 &netlink_compare, &arg);
++=======
+ 	netlink_compare_arg_init(&arg, net, portid);
+ 	return rhashtable_lookup_fast(&table->hash, &arg,
+ 				      netlink_rhashtable_params);
+ }
+ 
+ static int __netlink_insert(struct netlink_table *table, struct sock *sk)
+ {
+ 	struct netlink_compare_arg arg;
+ 
+ 	netlink_compare_arg_init(&arg, sock_net(sk), nlk_sk(sk)->portid);
+ 	return rhashtable_lookup_insert_key(&table->hash, &arg,
+ 					    &nlk_sk(sk)->node,
+ 					    netlink_rhashtable_params);
++>>>>>>> da314c9923fe (netlink: Replace rhash_portid with bound)
  }
  
  static struct sock *netlink_lookup(struct net *net, int protocol, u32 portid)
@@@ -1079,17 -1103,15 +1108,17 @@@ netlink_update_listeners(struct sock *s
  	 * makes sure updates are visible before bind or setsockopt return. */
  }
  
 -static int netlink_insert(struct sock *sk, u32 portid)
 +static int netlink_insert(struct sock *sk, struct net *net, u32 portid)
  {
  	struct netlink_table *table = &nl_table[sk->sk_protocol];
 -	int err;
 +	int err = -EADDRINUSE;
  
 -	lock_sock(sk);
 +	mutex_lock(&nl_sk_hash_lock);
 +	if (__netlink_lookup(table, portid, net))
 +		goto err;
  
- 	err = -EBUSY;
- 	if (nlk_sk(sk)->portid)
+ 	err = nlk_sk(sk)->portid == portid ? 0 : -EBUSY;
+ 	if (nlk_sk(sk)->bound)
  		goto err;
  
  	err = -ENOMEM;
@@@ -1098,10 -1121,26 +1127,31 @@@
  
  	nlk_sk(sk)->portid = portid;
  	sock_hold(sk);
++<<<<<<< HEAD
 +	rhashtable_insert(&table->hash, &nlk_sk(sk)->node);
 +	err = 0;
++=======
+ 
+ 	err = __netlink_insert(table, sk);
+ 	if (err) {
+ 		/* In case the hashtable backend returns with -EBUSY
+ 		 * from here, it must not escape to the caller.
+ 		 */
+ 		if (unlikely(err == -EBUSY))
+ 			err = -EOVERFLOW;
+ 		if (err == -EEXIST)
+ 			err = -EADDRINUSE;
+ 		sock_put(sk);
+ 		goto err;
+ 	}
+ 
+ 	/* We need to ensure that the socket is hashed and visible. */
+ 	smp_wmb();
+ 	nlk_sk(sk)->bound = portid;
+ 
++>>>>>>> da314c9923fe (netlink: Replace rhash_portid with bound)
  err:
 -	release_sock(sk);
 +	mutex_unlock(&nl_sk_hash_lock);
  	return err;
  }
  
@@@ -1445,6 -1522,8 +1495,11 @@@ static int netlink_bind(struct socket *
  	struct netlink_sock *nlk = nlk_sk(sk);
  	struct sockaddr_nl *nladdr = (struct sockaddr_nl *)addr;
  	int err;
++<<<<<<< HEAD
++=======
+ 	long unsigned int groups = nladdr->nl_groups;
+ 	bool bound;
++>>>>>>> da314c9923fe (netlink: Replace rhash_portid with bound)
  
  	if (addr_len < sizeof(struct sockaddr_nl))
  		return -EINVAL;
@@@ -1461,18 -1540,43 +1516,48 @@@
  			return err;
  	}
  
++<<<<<<< HEAD
 +	if (nlk->portid) {
 +		if (nladdr->nl_pid != nlk->portid)
 +			return -EINVAL;
 +	} else {
++=======
+ 	bound = nlk->bound;
+ 	if (bound) {
+ 		/* Ensure nlk->portid is up-to-date. */
+ 		smp_rmb();
+ 
+ 		if (nladdr->nl_pid != nlk->portid)
+ 			return -EINVAL;
+ 	}
+ 
+ 	if (nlk->netlink_bind && groups) {
+ 		int group;
+ 
+ 		for (group = 0; group < nlk->ngroups; group++) {
+ 			if (!test_bit(group, &groups))
+ 				continue;
+ 			err = nlk->netlink_bind(net, group + 1);
+ 			if (!err)
+ 				continue;
+ 			netlink_undo_bind(group, groups, sk);
+ 			return err;
+ 		}
+ 	}
+ 
+ 	/* No need for barriers here as we return to user-space without
+ 	 * using any of the bound attributes.
+ 	 */
+ 	if (!bound) {
++>>>>>>> da314c9923fe (netlink: Replace rhash_portid with bound)
  		err = nladdr->nl_pid ?
 -			netlink_insert(sk, nladdr->nl_pid) :
 +			netlink_insert(sk, net, nladdr->nl_pid) :
  			netlink_autobind(sock);
 -		if (err) {
 -			netlink_undo_bind(nlk->ngroups, groups, sk);
 +		if (err)
  			return err;
 -		}
  	}
  
 -	if (!groups && (nlk->groups == NULL || !(u32)nlk->groups[0]))
 +	if (!nladdr->nl_groups && (nlk->groups == NULL || !(u32)nlk->groups[0]))
  		return 0;
  
  	netlink_table_grab();
@@@ -2326,12 -2462,20 +2414,15 @@@ static int netlink_sendmsg(struct kioc
  		err = netlink_autobind(sock);
  		if (err)
  			goto out;
+ 	} else {
+ 		/* Ensure nlk is hashed and visible. */
+ 		smp_rmb();
  	}
  
 -	/* It's a really convoluted way for userland to ask for mmaped
 -	 * sendmsg(), but that's what we've got...
 -	 */
  	if (netlink_tx_is_mmaped(sk) &&
 -	    iter_is_iovec(&msg->msg_iter) &&
 -	    msg->msg_iter.nr_segs == 1 &&
 -	    msg->msg_iter.iov->iov_base == NULL) {
 +	    msg->msg_iov->iov_base == NULL) {
  		err = netlink_mmap_sendmsg(sk, msg, dst_portid, dst_group,
 -					   &scm);
 +					   siocb);
  		goto out;
  	}
  
@@@ -3161,6 -3285,23 +3252,26 @@@ static struct pernet_operations __net_i
  	.exit = netlink_net_exit,
  };
  
++<<<<<<< HEAD
++=======
+ static inline u32 netlink_hash(const void *data, u32 len, u32 seed)
+ {
+ 	const struct netlink_sock *nlk = data;
+ 	struct netlink_compare_arg arg;
+ 
+ 	netlink_compare_arg_init(&arg, sock_net(&nlk->sk), nlk->portid);
+ 	return jhash2((u32 *)&arg, netlink_compare_arg_len / sizeof(u32), seed);
+ }
+ 
+ static const struct rhashtable_params netlink_rhashtable_params = {
+ 	.head_offset = offsetof(struct netlink_sock, node),
+ 	.key_len = netlink_compare_arg_len,
+ 	.obj_hashfn = netlink_hash,
+ 	.obj_cmpfn = netlink_compare,
+ 	.automatic_shrinking = true,
+ };
+ 
++>>>>>>> da314c9923fe (netlink: Replace rhash_portid with bound)
  static int __init netlink_proto_init(void)
  {
  	int i;
* Unmerged path net/netlink/af_netlink.c
diff --git a/net/netlink/af_netlink.h b/net/netlink/af_netlink.h
index 5b5d85a60dfc..f003ac2b4dfa 100644
--- a/net/netlink/af_netlink.h
+++ b/net/netlink/af_netlink.h
@@ -34,6 +34,7 @@ struct netlink_sock {
 	unsigned long		state;
 	size_t			max_recvmsg_len;
 	wait_queue_head_t	wait;
+	bool			bound;
 	bool			cb_running;
 	struct netlink_callback	cb;
 	struct mutex		*cb_mutex;
