sctp: fix checkpatch errors with indent

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author wangweidong <wangweidong1@huawei.com>
commit f7010e61442c80333b38aa026a551043a341fb8d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f7010e61.failed

fix checkpatch errors below:
ERROR: switch and case should be at the same inden
ERROR: code indent should use tabs where possible

	Acked-by: Neil Horman <nhorman@tuxdriver.com>
	Signed-off-by: Wang Weidong <wangweidong1@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f7010e61442c80333b38aa026a551043a341fb8d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/sm_make_chunk.c
#	net/sctp/sm_statefuns.c
diff --cc net/sctp/sm_make_chunk.c
index 580d58afabf7,e5f7cdb42a85..000000000000
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@@ -1986,25 -2000,24 +1986,42 @@@ static void sctp_process_ext_param(stru
  
  	for (i = 0; i < num_ext; i++) {
  		switch (param.ext->chunks[i]) {
- 		    case SCTP_CID_FWD_TSN:
- 			    if (net->sctp.prsctp_enable &&
- 				!asoc->peer.prsctp_capable)
+ 		case SCTP_CID_FWD_TSN:
+ 			if (net->sctp.prsctp_enable && !asoc->peer.prsctp_capable)
  				    asoc->peer.prsctp_capable = 1;
++<<<<<<< HEAD
 +			    break;
 +		    case SCTP_CID_AUTH:
 +			    /* if the peer reports AUTH, assume that he
 +			     * supports AUTH.
 +			     */
 +			    if (asoc->ep->auth_enable)
 +				    asoc->peer.auth_capable = 1;
 +			    break;
 +		    case SCTP_CID_ASCONF:
 +		    case SCTP_CID_ASCONF_ACK:
 +			    if (net->sctp.addip_enable)
 +				    asoc->peer.asconf_capable = 1;
 +			    break;
 +		    default:
 +			    break;
++=======
+ 			break;
+ 		case SCTP_CID_AUTH:
+ 			/* if the peer reports AUTH, assume that he
+ 			 * supports AUTH.
+ 			 */
+ 			if (net->sctp.auth_enable)
+ 				asoc->peer.auth_capable = 1;
+ 			break;
+ 		case SCTP_CID_ASCONF:
+ 		case SCTP_CID_ASCONF_ACK:
+ 			if (net->sctp.addip_enable)
+ 				asoc->peer.asconf_capable = 1;
+ 			break;
+ 		default:
+ 			break;
++>>>>>>> f7010e61442c (sctp: fix checkpatch errors with indent)
  		}
  	}
  }
@@@ -2250,17 -2262,17 +2267,17 @@@ int sctp_verify_init(struct net *net, c
  
  	/* Verify all the variable length parameters */
  	sctp_walk_params(param, peer_init, init_hdr.params) {
 -
 -		result = sctp_verify_param(net, asoc, param, cid, chunk, errp);
 +		result = sctp_verify_param(net, ep, asoc, param, cid,
 +					   chunk, errp);
  		switch (result) {
- 		    case SCTP_IERROR_ABORT:
- 		    case SCTP_IERROR_NOMEM:
- 				return 0;
- 		    case SCTP_IERROR_ERROR:
- 				return 1;
- 		    case SCTP_IERROR_NO_ERROR:
- 		    default:
- 				break;
+ 		case SCTP_IERROR_ABORT:
+ 		case SCTP_IERROR_NOMEM:
+ 			return 0;
+ 		case SCTP_IERROR_ERROR:
+ 			return 1;
+ 		case SCTP_IERROR_NO_ERROR:
+ 		default:
+ 			break;
  		}
  
  	} /* for (loop through all parameters) */
diff --cc net/sctp/sm_statefuns.c
index 8f36c1df3b6f,483dcd71b3c5..000000000000
--- a/net/sctp/sm_statefuns.c
+++ b/net/sctp/sm_statefuns.c
@@@ -6195,8 -6206,9 +6194,14 @@@ static int sctp_eat_data(const struct s
  	 */
  	if (*sk->sk_prot_creator->memory_pressure) {
  		if (sctp_tsnmap_has_gap(map) &&
++<<<<<<< HEAD
 +	           (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {
 +			SCTP_DEBUG_PRINTK("Under Pressure! Reneging for tsn:%u\n", tsn);
++=======
+ 		    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {
+ 			pr_debug("%s: under pressure, reneging for tsn:%u\n",
+ 				 __func__, tsn);
++>>>>>>> f7010e61442c (sctp: fix checkpatch errors with indent)
  			deliver = SCTP_CMD_RENEGE;
  		 }
  	}
diff --git a/net/sctp/auth.c b/net/sctp/auth.c
index df8e0aad426f..2bf17560dc9d 100644
--- a/net/sctp/auth.c
+++ b/net/sctp/auth.c
@@ -665,15 +665,15 @@ static int __sctp_auth_cid(sctp_cid_t chunk, struct sctp_chunks_param *param)
 	 */
 	for (i = 0; !found && i < len; i++) {
 		switch (param->chunks[i]) {
-		    case SCTP_CID_INIT:
-		    case SCTP_CID_INIT_ACK:
-		    case SCTP_CID_SHUTDOWN_COMPLETE:
-		    case SCTP_CID_AUTH:
+		case SCTP_CID_INIT:
+		case SCTP_CID_INIT_ACK:
+		case SCTP_CID_SHUTDOWN_COMPLETE:
+		case SCTP_CID_AUTH:
 			break;
 
-		    default:
+		default:
 			if (param->chunks[i] == chunk)
-			    found = 1;
+				found = 1;
 			break;
 		}
 	}
diff --git a/net/sctp/input.c b/net/sctp/input.c
index 91b674c1e672..7b05e5413f9c 100644
--- a/net/sctp/input.c
+++ b/net/sctp/input.c
@@ -1190,30 +1190,30 @@ static struct sctp_association *__sctp_rcv_walk_lookup(struct net *net,
 			break;
 
 		switch (ch->type) {
-		    case SCTP_CID_AUTH:
-			    have_auth = chunk_num;
-			    break;
-
-		    case SCTP_CID_COOKIE_ECHO:
-			    /* If a packet arrives containing an AUTH chunk as
-			     * a first chunk, a COOKIE-ECHO chunk as the second
-			     * chunk, and possibly more chunks after them, and
-			     * the receiver does not have an STCB for that
-			     * packet, then authentication is based on
-			     * the contents of the COOKIE- ECHO chunk.
-			     */
-			    if (have_auth == 1 && chunk_num == 2)
-				    return NULL;
-			    break;
-
-		    case SCTP_CID_ASCONF:
-			    if (have_auth || net->sctp.addip_noauth)
-				    asoc = __sctp_rcv_asconf_lookup(
-							net, ch, laddr,
-							sctp_hdr(skb)->source,
-							transportp);
-		    default:
-			    break;
+		case SCTP_CID_AUTH:
+			have_auth = chunk_num;
+			break;
+
+		case SCTP_CID_COOKIE_ECHO:
+			/* If a packet arrives containing an AUTH chunk as
+			 * a first chunk, a COOKIE-ECHO chunk as the second
+			 * chunk, and possibly more chunks after them, and
+			 * the receiver does not have an STCB for that
+			 * packet, then authentication is based on
+			 * the contents of the COOKIE- ECHO chunk.
+			 */
+			if (have_auth == 1 && chunk_num == 2)
+				return NULL;
+			break;
+
+		case SCTP_CID_ASCONF:
+			if (have_auth || net->sctp.addip_noauth)
+				asoc = __sctp_rcv_asconf_lookup(
+						net, ch, laddr,
+						sctp_hdr(skb)->source,
+						transportp);
+		default:
+			break;
 		}
 
 		if (asoc)
diff --git a/net/sctp/output.c b/net/sctp/output.c
index b1ac80d971ea..0d391d41b654 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -290,7 +290,7 @@ static sctp_xmit_t __sctp_packet_append_chunk(struct sctp_packet *packet,
 
 	/* We believe that this chunk is OK to add to the packet */
 	switch (chunk->chunk_hdr->type) {
-	    case SCTP_CID_DATA:
+	case SCTP_CID_DATA:
 		/* Account for the data being in the packet */
 		sctp_packet_append_data(packet, chunk);
 		/* Disallow SACK bundling after DATA. */
@@ -302,17 +302,17 @@ static sctp_xmit_t __sctp_packet_append_chunk(struct sctp_packet *packet,
 		/* timestamp the chunk for rtx purposes */
 		chunk->sent_at = jiffies;
 		break;
-	    case SCTP_CID_COOKIE_ECHO:
+	case SCTP_CID_COOKIE_ECHO:
 		packet->has_cookie_echo = 1;
 		break;
 
-	    case SCTP_CID_SACK:
+	case SCTP_CID_SACK:
 		packet->has_sack = 1;
 		if (chunk->asoc)
 			chunk->asoc->stats.osacks++;
 		break;
 
-	    case SCTP_CID_AUTH:
+	case SCTP_CID_AUTH:
 		packet->has_auth = 1;
 		packet->auth = chunk;
 		break;
@@ -552,8 +552,7 @@ int sctp_packet_transmit(struct sctp_packet *packet)
 		} else {
 			/* no need to seed pseudo checksum for SCTP */
 			nskb->ip_summed = CHECKSUM_PARTIAL;
-			nskb->csum_start = (skb_transport_header(nskb) -
-			                    nskb->head);
+			nskb->csum_start = skb_transport_header(nskb) - nskb->head;
 			nskb->csum_offset = offsetof(struct sctphdr, checksum);
 		}
 	}
* Unmerged path net/sctp/sm_make_chunk.c
* Unmerged path net/sctp/sm_statefuns.c
diff --git a/net/sctp/sm_statetable.c b/net/sctp/sm_statetable.c
index 84d98d8a5a74..5b21a8733110 100644
--- a/net/sctp/sm_statetable.c
+++ b/net/sctp/sm_statetable.c
@@ -76,7 +76,7 @@ static const sctp_sm_table_entry_t bug = {
 	if ((event_subtype._type > (_max))) {				\
 		pr_warn("table %p possible attack: event %d exceeds max %d\n", \
 			_table, event_subtype._type, _max);		\
-	        rtn = &bug;						\
+		rtn = &bug;						\
 	} else								\
 		rtn = &_table[event_subtype._type][(int)state];		\
 									\
