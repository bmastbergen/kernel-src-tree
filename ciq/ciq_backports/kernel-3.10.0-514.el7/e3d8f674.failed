x86/microcode/intel: Move mc arg last in get_matching_{microcode|sig}

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] microcode/intel: Move mc arg last in get_matching_{microcode|sig} (Prarit Bhargava) [1253762]
Rebuild_FUZZ: 97.01%
commit-author Borislav Petkov <bp@suse.de>
commit e3d8f6747663b468ccedb8af0f38f2be82874c63
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e3d8f674.failed

... arguments list so that it comes more natural for those functions to
have the signature, processor flags and revision together, before the
rest of the args.

No functionality change.

	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit e3d8f6747663b468ccedb8af0f38f2be82874c63)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/microcode/intel_early.c
diff --cc arch/x86/kernel/cpu/microcode/intel_early.c
index e82c44063360,844c75895160..000000000000
--- a/arch/x86/kernel/cpu/microcode/intel_early.c
+++ b/arch/x86/kernel/cpu/microcode/intel_early.c
@@@ -35,38 -35,35 +35,54 @@@ static struct mc_saved_data 
  } mc_saved_data;
  
  static enum ucode_state
 -load_microcode_early(struct microcode_intel **saved,
 -		     unsigned int num_saved, struct ucode_cpu_info *uci)
 +generic_load_microcode_early(struct microcode_intel **mc_saved_p,
 +			     unsigned int mc_saved_count,
 +			     struct ucode_cpu_info *uci)
  {
  	struct microcode_intel *ucode_ptr, *new_mc = NULL;
 -	struct microcode_header_intel *mc_hdr;
 -	int new_rev, ret, i;
 +	int new_rev = uci->cpu_sig.rev;
 +	enum ucode_state state = UCODE_OK;
 +	unsigned int mc_size;
 +	struct microcode_header_intel *mc_header;
 +	unsigned int csig = uci->cpu_sig.sig;
 +	unsigned int cpf = uci->cpu_sig.pf;
 +	int i;
  
 -	new_rev = uci->cpu_sig.rev;
 +	for (i = 0; i < mc_saved_count; i++) {
 +		ucode_ptr = mc_saved_p[i];
  
++<<<<<<< HEAD
 +		mc_header = (struct microcode_header_intel *)ucode_ptr;
 +		mc_size = get_totalsize(mc_header);
 +		if (get_matching_microcode(csig, cpf, ucode_ptr, new_rev)) {
 +			new_rev = mc_header->rev;
 +			new_mc  = ucode_ptr;
 +		}
++=======
+ 	for (i = 0; i < num_saved; i++) {
+ 		ucode_ptr = saved[i];
+ 		mc_hdr	  = (struct microcode_header_intel *)ucode_ptr;
+ 
+ 		ret = get_matching_microcode(uci->cpu_sig.sig,
+ 					     uci->cpu_sig.pf,
+ 					     new_rev,
+ 					     ucode_ptr);
+ 		if (!ret)
+ 			continue;
+ 
+ 		new_rev = mc_hdr->rev;
+ 		new_mc  = ucode_ptr;
++>>>>>>> e3d8f6747663 (x86/microcode/intel: Move mc arg last in get_matching_{microcode|sig})
  	}
  
 -	if (!new_mc)
 -		return UCODE_NFOUND;
 +	if (!new_mc) {
 +		state = UCODE_NFOUND;
 +		goto out;
 +	}
  
  	uci->mc = (struct microcode_intel *)new_mc;
 -	return UCODE_OK;
 +out:
 +	return state;
  }
  
  static void
diff --git a/arch/x86/include/asm/microcode_intel.h b/arch/x86/include/asm/microcode_intel.h
index e2c7404deded..41dc8a8798da 100644
--- a/arch/x86/include/asm/microcode_intel.h
+++ b/arch/x86/include/asm/microcode_intel.h
@@ -56,10 +56,9 @@ struct extended_sigtable {
 
 #define exttable_size(et) ((et)->count * EXT_SIGNATURE_SIZE + EXT_HEADER_SIZE)
 
-extern int
-get_matching_microcode(unsigned int csig, int cpf, void *mc, int rev);
+extern int get_matching_microcode(unsigned int csig, int cpf, int rev, void *mc);
 extern int microcode_sanity_check(void *mc, int print_err);
-extern int get_matching_sig(unsigned int csig, int cpf, void *mc, int rev);
+extern int get_matching_sig(unsigned int csig, int cpf, int rev, void *mc);
 
 static inline int
 revision_is_newer(struct microcode_header_intel *mc_header, int rev)
diff --git a/arch/x86/kernel/cpu/microcode/intel.c b/arch/x86/kernel/cpu/microcode/intel.c
index 9017c3f41edb..52250d36e77e 100644
--- a/arch/x86/kernel/cpu/microcode/intel.c
+++ b/arch/x86/kernel/cpu/microcode/intel.c
@@ -124,7 +124,7 @@ static int get_matching_mc(struct microcode_intel *mc_intel, int cpu)
 	cpf = cpu_sig.pf;
 	crev = cpu_sig.rev;
 
-	return get_matching_microcode(csig, cpf, mc_intel, crev);
+	return get_matching_microcode(csig, cpf, crev, mc_intel);
 }
 
 static int apply_microcode_intel(int cpu)
@@ -226,7 +226,7 @@ static enum ucode_state generic_load_microcode(int cpu, void *data, size_t size,
 
 		csig = uci->cpu_sig.sig;
 		cpf = uci->cpu_sig.pf;
-		if (get_matching_microcode(csig, cpf, mc, new_rev)) {
+		if (get_matching_microcode(csig, cpf, new_rev, mc)) {
 			vfree(new_mc);
 			new_rev = mc_header.rev;
 			new_mc  = mc;
* Unmerged path arch/x86/kernel/cpu/microcode/intel_early.c
diff --git a/arch/x86/kernel/cpu/microcode/intel_lib.c b/arch/x86/kernel/cpu/microcode/intel_lib.c
index 7e259d99b0aa..cd47a510a3f1 100644
--- a/arch/x86/kernel/cpu/microcode/intel_lib.c
+++ b/arch/x86/kernel/cpu/microcode/intel_lib.c
@@ -122,10 +122,9 @@ int microcode_sanity_check(void *mc, int print_err)
 EXPORT_SYMBOL_GPL(microcode_sanity_check);
 
 /*
- * return 0 - no update found
- * return 1 - found update
+ * Returns 1 if update has been found, 0 otherwise.
  */
-int get_matching_sig(unsigned int csig, int cpf, void *mc, int rev)
+int get_matching_sig(unsigned int csig, int cpf, int rev, void *mc)
 {
 	struct microcode_header_intel *mc_header = mc;
 	struct extended_sigtable *ext_header;
@@ -153,16 +152,15 @@ int get_matching_sig(unsigned int csig, int cpf, void *mc, int rev)
 }
 
 /*
- * return 0 - no update found
- * return 1 - found update
+ * Returns 1 if update has been found, 0 otherwise.
  */
-int get_matching_microcode(unsigned int csig, int cpf, void *mc, int rev)
+int get_matching_microcode(unsigned int csig, int cpf, int rev, void *mc)
 {
-	struct microcode_header_intel *mc_header = mc;
+	struct microcode_header_intel *mc_hdr = mc;
 
-	if (!revision_is_newer(mc_header, rev))
+	if (!revision_is_newer(mc_hdr, rev))
 		return 0;
 
-	return get_matching_sig(csig, cpf, mc, rev);
+	return get_matching_sig(csig, cpf, rev, mc);
 }
 EXPORT_SYMBOL_GPL(get_matching_microcode);
