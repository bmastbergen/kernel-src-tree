perf record: Extend -m option for AUX area tracing mmap pages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit e9db1310d95c9d02763643108d51e47d9eb79ac9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e9db1310.failed

Extend the -m option so that the number of mmap pages for AUX area
tracing can be specified by adding a comma followed by the number of
pages.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Namhyung Kim <namhyung@gmail.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
Link: http://lkml.kernel.org/r/1428594864-29309-7-git-send-email-adrian.hunter@intel.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit e9db1310d95c9d02763643108d51e47d9eb79ac9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-record.c
diff --cc tools/perf/builtin-record.c
index c21e2055c06e,4c9aaa1f688a..000000000000
--- a/tools/perf/builtin-record.c
+++ b/tools/perf/builtin-record.c
@@@ -771,6 -771,133 +771,136 @@@ static int perf_record_config(const cha
  	return perf_default_config(var, value, cb);
  }
  
++<<<<<<< HEAD
++=======
+ struct clockid_map {
+ 	const char *name;
+ 	int clockid;
+ };
+ 
+ #define CLOCKID_MAP(n, c)	\
+ 	{ .name = n, .clockid = (c), }
+ 
+ #define CLOCKID_END	{ .name = NULL, }
+ 
+ 
+ /*
+  * Add the missing ones, we need to build on many distros...
+  */
+ #ifndef CLOCK_MONOTONIC_RAW
+ #define CLOCK_MONOTONIC_RAW 4
+ #endif
+ #ifndef CLOCK_BOOTTIME
+ #define CLOCK_BOOTTIME 7
+ #endif
+ #ifndef CLOCK_TAI
+ #define CLOCK_TAI 11
+ #endif
+ 
+ static const struct clockid_map clockids[] = {
+ 	/* available for all events, NMI safe */
+ 	CLOCKID_MAP("monotonic", CLOCK_MONOTONIC),
+ 	CLOCKID_MAP("monotonic_raw", CLOCK_MONOTONIC_RAW),
+ 
+ 	/* available for some events */
+ 	CLOCKID_MAP("realtime", CLOCK_REALTIME),
+ 	CLOCKID_MAP("boottime", CLOCK_BOOTTIME),
+ 	CLOCKID_MAP("tai", CLOCK_TAI),
+ 
+ 	/* available for the lazy */
+ 	CLOCKID_MAP("mono", CLOCK_MONOTONIC),
+ 	CLOCKID_MAP("raw", CLOCK_MONOTONIC_RAW),
+ 	CLOCKID_MAP("real", CLOCK_REALTIME),
+ 	CLOCKID_MAP("boot", CLOCK_BOOTTIME),
+ 
+ 	CLOCKID_END,
+ };
+ 
+ static int parse_clockid(const struct option *opt, const char *str, int unset)
+ {
+ 	struct record_opts *opts = (struct record_opts *)opt->value;
+ 	const struct clockid_map *cm;
+ 	const char *ostr = str;
+ 
+ 	if (unset) {
+ 		opts->use_clockid = 0;
+ 		return 0;
+ 	}
+ 
+ 	/* no arg passed */
+ 	if (!str)
+ 		return 0;
+ 
+ 	/* no setting it twice */
+ 	if (opts->use_clockid)
+ 		return -1;
+ 
+ 	opts->use_clockid = true;
+ 
+ 	/* if its a number, we're done */
+ 	if (sscanf(str, "%d", &opts->clockid) == 1)
+ 		return 0;
+ 
+ 	/* allow a "CLOCK_" prefix to the name */
+ 	if (!strncasecmp(str, "CLOCK_", 6))
+ 		str += 6;
+ 
+ 	for (cm = clockids; cm->name; cm++) {
+ 		if (!strcasecmp(str, cm->name)) {
+ 			opts->clockid = cm->clockid;
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	opts->use_clockid = false;
+ 	ui__warning("unknown clockid %s, check man page\n", ostr);
+ 	return -1;
+ }
+ 
+ static int record__parse_mmap_pages(const struct option *opt,
+ 				    const char *str,
+ 				    int unset __maybe_unused)
+ {
+ 	struct record_opts *opts = opt->value;
+ 	char *s, *p;
+ 	unsigned int mmap_pages;
+ 	int ret;
+ 
+ 	if (!str)
+ 		return -EINVAL;
+ 
+ 	s = strdup(str);
+ 	if (!s)
+ 		return -ENOMEM;
+ 
+ 	p = strchr(s, ',');
+ 	if (p)
+ 		*p = '\0';
+ 
+ 	if (*s) {
+ 		ret = __perf_evlist__parse_mmap_pages(&mmap_pages, s);
+ 		if (ret)
+ 			goto out_free;
+ 		opts->mmap_pages = mmap_pages;
+ 	}
+ 
+ 	if (!p) {
+ 		ret = 0;
+ 		goto out_free;
+ 	}
+ 
+ 	ret = __perf_evlist__parse_mmap_pages(&mmap_pages, p + 1);
+ 	if (ret)
+ 		goto out_free;
+ 
+ 	opts->auxtrace_mmap_pages = mmap_pages;
+ 
+ out_free:
+ 	free(s);
+ 	return ret;
+ }
+ 
++>>>>>>> e9db1310d95c (perf record: Extend -m option for AUX area tracing mmap pages)
  static const char * const __record_usage[] = {
  	"perf record [<options>] [<command>]",
  	"perf record [<options>] -- <command> [<options>]",
diff --git a/tools/perf/Documentation/perf-record.txt b/tools/perf/Documentation/perf-record.txt
index 355c4f5569b5..e78dd80f3eaf 100644
--- a/tools/perf/Documentation/perf-record.txt
+++ b/tools/perf/Documentation/perf-record.txt
@@ -108,6 +108,8 @@ OPTIONS
 	Number of mmap data pages (must be a power of two) or size
 	specification with appended unit character - B/K/M/G. The
 	size is rounded up to have nearest pages power of two value.
+	Also, by adding a comma, the number of mmap pages for AUX
+	area tracing can be specified.
 
 --group::
 	Put all events in a single event group.  This precedes the --event
* Unmerged path tools/perf/builtin-record.c
diff --git a/tools/perf/util/evlist.c b/tools/perf/util/evlist.c
index a5305282213a..256005eecdf2 100644
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@ -1007,10 +1007,8 @@ static long parse_pages_arg(const char *str, unsigned long min,
 	return pages;
 }
 
-int perf_evlist__parse_mmap_pages(const struct option *opt, const char *str,
-				  int unset __maybe_unused)
+int __perf_evlist__parse_mmap_pages(unsigned int *mmap_pages, const char *str)
 {
-	unsigned int *mmap_pages = opt->value;
 	unsigned long max = UINT_MAX;
 	long pages;
 
@@ -1027,6 +1025,12 @@ int perf_evlist__parse_mmap_pages(const struct option *opt, const char *str,
 	return 0;
 }
 
+int perf_evlist__parse_mmap_pages(const struct option *opt, const char *str,
+				  int unset __maybe_unused)
+{
+	return __perf_evlist__parse_mmap_pages(opt->value, str);
+}
+
 /**
  * perf_evlist__mmap_ex - Create mmaps to receive events.
  * @evlist: list of events
diff --git a/tools/perf/util/evlist.h b/tools/perf/util/evlist.h
index 8dc986ddaa01..c07b1a94a724 100644
--- a/tools/perf/util/evlist.h
+++ b/tools/perf/util/evlist.h
@@ -124,6 +124,7 @@ int perf_evlist__start_workload(struct perf_evlist *evlist);
 
 struct option;
 
+int __perf_evlist__parse_mmap_pages(unsigned int *mmap_pages, const char *str);
 int perf_evlist__parse_mmap_pages(const struct option *opt,
 				  const char *str,
 				  int unset);
