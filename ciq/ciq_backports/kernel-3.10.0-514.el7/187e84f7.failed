iscsi-target: add void (*iscsit_get_rx_pdu)()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Varun Prakash <varun@chelsio.com>
commit 187e84f7c2e4fa0028241c253c24658ef658e5d3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/187e84f7.failed

Add void (*iscsit_get_rx_pdu)() to
struct iscsit_transport, iscsi-target
uses this callback to receive and
process Rx iSCSI PDUs.

cxgbit.ko needs this callback to
reuse iscsi-target Rx thread.

	Signed-off-by: Varun Prakash <varun@chelsio.com>
	Acked-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 187e84f7c2e4fa0028241c253c24658ef658e5d3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/iscsi/iscsi_target.c
#	include/target/iscsi/iscsi_transport.h
diff --cc drivers/target/iscsi/iscsi_target.c
index c4fef98585d3,9fa9f0b3a0f4..000000000000
--- a/drivers/target/iscsi/iscsi_target.c
+++ b/drivers/target/iscsi/iscsi_target.c
@@@ -4087,16 -3943,16 +4087,21 @@@ int iscsi_target_rx_thread(void *arg
  	 * connection recovery / failure event can be triggered externally.
  	 */
  	allow_signal(SIGINT);
 -	/*
 -	 * Wait for iscsi_post_login_handler() to complete before allowing
 -	 * incoming iscsi/tcp socket I/O, and/or failing the connection.
 -	 */
 -	rc = wait_for_completion_interruptible(&conn->rx_login_comp);
 -	if (rc < 0 || iscsi_target_check_conn_state(conn))
 -		return 0;
  
++<<<<<<< HEAD
 +	if (conn->conn_transport->transport_type == ISCSI_INFINIBAND) {
 +		struct completion comp;
 +		int rc;
 +
 +		init_completion(&comp);
 +		rc = wait_for_completion_interruptible(&comp);
 +		if (rc < 0)
 +			goto transport_err;
 +
++=======
+ 	if (conn->conn_transport->iscsit_get_rx_pdu) {
+ 		conn->conn_transport->iscsit_get_rx_pdu(conn);
++>>>>>>> 187e84f7c2e4 (iscsi-target: add void (*iscsit_get_rx_pdu)())
  		goto transport_err;
  	}
  
diff --cc include/target/iscsi/iscsi_transport.h
index e6bb166f12c2,ccc68a0334c2..000000000000
--- a/include/target/iscsi/iscsi_transport.h
+++ b/include/target/iscsi/iscsi_transport.h
@@@ -22,6 -22,10 +22,13 @@@ struct iscsit_transport 
  	int (*iscsit_queue_data_in)(struct iscsi_conn *, struct iscsi_cmd *);
  	int (*iscsit_queue_status)(struct iscsi_conn *, struct iscsi_cmd *);
  	void (*iscsit_aborted_task)(struct iscsi_conn *, struct iscsi_cmd *);
++<<<<<<< HEAD
++=======
+ 	int (*iscsit_xmit_pdu)(struct iscsi_conn *, struct iscsi_cmd *,
+ 			       struct iscsi_datain_req *, const void *, u32);
+ 	void (*iscsit_release_cmd)(struct iscsi_conn *, struct iscsi_cmd *);
+ 	void (*iscsit_get_rx_pdu)(struct iscsi_conn *);
++>>>>>>> 187e84f7c2e4 (iscsi-target: add void (*iscsit_get_rx_pdu)())
  	enum target_prot_op (*iscsit_get_sup_prot_ops)(struct iscsi_conn *);
  };
  
diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c
index 3f01dfb53c99..3dfe93fa1ee0 100644
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@ -3467,6 +3467,15 @@ static void isert_free_conn(struct iscsi_conn *conn)
 	isert_put_conn(isert_conn);
 }
 
+static void isert_get_rx_pdu(struct iscsi_conn *conn)
+{
+	struct completion comp;
+
+	init_completion(&comp);
+
+	wait_for_completion_interruptible(&comp);
+}
+
 static struct iscsit_transport iser_target_transport = {
 	.name			= "IB/iSER",
 	.transport_type		= ISCSI_INFINIBAND,
@@ -3485,6 +3494,7 @@ static struct iscsit_transport iser_target_transport = {
 	.iscsit_queue_data_in	= isert_put_datain,
 	.iscsit_queue_status	= isert_put_response,
 	.iscsit_aborted_task	= isert_aborted_task,
+	.iscsit_get_rx_pdu	= isert_get_rx_pdu,
 	.iscsit_get_sup_prot_ops = isert_get_sup_prot_ops,
 };
 
* Unmerged path drivers/target/iscsi/iscsi_target.c
* Unmerged path include/target/iscsi/iscsi_transport.h
