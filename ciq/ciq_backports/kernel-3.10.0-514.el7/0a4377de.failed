genirq: Introduce irq_set_vcpu_affinity() to target an interrupt to a VCPU

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiang Liu <jiang.liu@linux.intel.com>
commit 0a4377de305684c883bf90ad21e3cbdeead70f5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0a4377de.failed

With Posted-Interrupts support in Intel CPU and IOMMU, an external
interrupt from assigned-devices could be directly delivered to a
virtual CPU in a virtual machine. Instead of hacking KVM and Intel
IOMMU drivers, we propose a platform independent interface to target
an interrupt to a specific virtual CPU in a virtual machine, or set
virtual CPU affinity for an interrupt.

By adopting this new interface and the hierarchy irqdomain, we could
easily support posted-interrupts on Intel platforms, and also provide
flexible enough interfaces for other platforms to support similar
features.

Here is the usage scenario for this interface:
Guest update MSI/MSI-X interrupt configuration
        -->QEMU and KVM handle this
        -->KVM call this interface (passing posted interrupts descriptor
           and guest vector)
        -->irq core will transfer the control to IOMMU
        -->IOMMU will do the real work of updating IRTE (IRTE has new
           format for VT-d Posted-Interrupts)

	Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
	Signed-off-by: Feng Wu <feng.wu@intel.com>
Link: http://lkml.kernel.org/r/1432026437-16560-2-git-send-email-feng.wu@intel.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 0a4377de305684c883bf90ad21e3cbdeead70f5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/irq.h
#	kernel/irq/chip.c
diff --cc include/linux/irq.h
index 3d1e3b7714dc,48cb7d1aa58f..000000000000
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@@ -294,7 -317,17 +294,19 @@@ static inline irq_hw_number_t irqd_to_h
   * @irq_suspend:	function called from core code on suspend once per chip
   * @irq_resume:		function called from core code on resume once per chip
   * @irq_pm_shutdown:	function called from core code on shutdown once per chip
 - * @irq_calc_mask:	Optional function to set irq_data.mask for special cases
   * @irq_print_chip:	optional to print special chip info in show_interrupts
++<<<<<<< HEAD
++=======
+  * @irq_request_resources:	optional to request resources before calling
+  *				any other callback related to this irq
+  * @irq_release_resources:	optional to release resources acquired with
+  *				irq_request_resources
+  * @irq_compose_msi_msg:	optional to compose message content for MSI
+  * @irq_write_msi_msg:	optional to write message content for MSI
+  * @irq_get_irqchip_state:	return the internal state of an interrupt
+  * @irq_set_irqchip_state:	set the internal state of a interrupt
+  * @irq_set_vcpu_affinity:	optional to target a vCPU in a virtual machine
++>>>>>>> 0a4377de3056 (genirq: Introduce irq_set_vcpu_affinity() to target an interrupt to a VCPU)
   * @flags:		chip specific flags
   */
  struct irq_chip {
@@@ -325,8 -358,20 +337,10 @@@
  	void		(*irq_resume)(struct irq_data *data);
  	void		(*irq_pm_shutdown)(struct irq_data *data);
  
 -	void		(*irq_calc_mask)(struct irq_data *data);
 -
  	void		(*irq_print_chip)(struct irq_data *data, struct seq_file *p);
 -	int		(*irq_request_resources)(struct irq_data *data);
 -	void		(*irq_release_resources)(struct irq_data *data);
 -
 -	void		(*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg);
 -	void		(*irq_write_msi_msg)(struct irq_data *data, struct msi_msg *msg);
 -
 -	int		(*irq_get_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool *state);
 -	int		(*irq_set_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool state);
  
+ 	int		(*irq_set_vcpu_affinity)(struct irq_data *data, void *vcpu_info);
+ 
  	unsigned long	flags;
  };
  
@@@ -377,9 -425,8 +391,10 @@@ extern void irq_cpu_online(void)
  extern void irq_cpu_offline(void);
  extern int irq_set_affinity_locked(struct irq_data *data,
  				   const struct cpumask *cpumask, bool force);
+ extern int irq_set_vcpu_affinity(unsigned int irq, void *vcpu_info);
  
 +#ifdef CONFIG_GENERIC_HARDIRQS
 +
  #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_PENDING_IRQ)
  void irq_move_irq(struct irq_data *data);
  void irq_move_masked_irq(struct irq_data *data);
@@@ -413,6 -460,21 +428,24 @@@ extern void handle_percpu_devid_irq(uns
  extern void handle_bad_irq(unsigned int irq, struct irq_desc *desc);
  extern void handle_nested_irq(unsigned int irq);
  
++<<<<<<< HEAD
++=======
+ extern int irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg);
+ #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
+ extern void irq_chip_ack_parent(struct irq_data *data);
+ extern int irq_chip_retrigger_hierarchy(struct irq_data *data);
+ extern void irq_chip_mask_parent(struct irq_data *data);
+ extern void irq_chip_unmask_parent(struct irq_data *data);
+ extern void irq_chip_eoi_parent(struct irq_data *data);
+ extern int irq_chip_set_affinity_parent(struct irq_data *data,
+ 					const struct cpumask *dest,
+ 					bool force);
+ extern int irq_chip_set_wake_parent(struct irq_data *data, unsigned int on);
+ extern int irq_chip_set_vcpu_affinity_parent(struct irq_data *data,
+ 					     void *vcpu_info);
+ #endif
+ 
++>>>>>>> 0a4377de3056 (genirq: Introduce irq_set_vcpu_affinity() to target an interrupt to a VCPU)
  /* Handling of unhandled and spurious interrupts: */
  extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
  			   irqreturn_t action_ret);
diff --cc kernel/irq/chip.c
index cbd97ce0b000,55016b2151f3..000000000000
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@@ -773,3 -873,135 +773,138 @@@ void irq_cpu_offline(void
  		raw_spin_unlock_irqrestore(&desc->lock, flags);
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
+ /**
+  * irq_chip_ack_parent - Acknowledge the parent interrupt
+  * @data:	Pointer to interrupt specific data
+  */
+ void irq_chip_ack_parent(struct irq_data *data)
+ {
+ 	data = data->parent_data;
+ 	data->chip->irq_ack(data);
+ }
+ 
+ /**
+  * irq_chip_mask_parent - Mask the parent interrupt
+  * @data:	Pointer to interrupt specific data
+  */
+ void irq_chip_mask_parent(struct irq_data *data)
+ {
+ 	data = data->parent_data;
+ 	data->chip->irq_mask(data);
+ }
+ 
+ /**
+  * irq_chip_unmask_parent - Unmask the parent interrupt
+  * @data:	Pointer to interrupt specific data
+  */
+ void irq_chip_unmask_parent(struct irq_data *data)
+ {
+ 	data = data->parent_data;
+ 	data->chip->irq_unmask(data);
+ }
+ 
+ /**
+  * irq_chip_eoi_parent - Invoke EOI on the parent interrupt
+  * @data:	Pointer to interrupt specific data
+  */
+ void irq_chip_eoi_parent(struct irq_data *data)
+ {
+ 	data = data->parent_data;
+ 	data->chip->irq_eoi(data);
+ }
+ 
+ /**
+  * irq_chip_set_affinity_parent - Set affinity on the parent interrupt
+  * @data:	Pointer to interrupt specific data
+  * @dest:	The affinity mask to set
+  * @force:	Flag to enforce setting (disable online checks)
+  *
+  * Conditinal, as the underlying parent chip might not implement it.
+  */
+ int irq_chip_set_affinity_parent(struct irq_data *data,
+ 				 const struct cpumask *dest, bool force)
+ {
+ 	data = data->parent_data;
+ 	if (data->chip->irq_set_affinity)
+ 		return data->chip->irq_set_affinity(data, dest, force);
+ 
+ 	return -ENOSYS;
+ }
+ 
+ /**
+  * irq_chip_retrigger_hierarchy - Retrigger an interrupt in hardware
+  * @data:	Pointer to interrupt specific data
+  *
+  * Iterate through the domain hierarchy of the interrupt and check
+  * whether a hw retrigger function exists. If yes, invoke it.
+  */
+ int irq_chip_retrigger_hierarchy(struct irq_data *data)
+ {
+ 	for (data = data->parent_data; data; data = data->parent_data)
+ 		if (data->chip && data->chip->irq_retrigger)
+ 			return data->chip->irq_retrigger(data);
+ 
+ 	return -ENOSYS;
+ }
+ 
+ /**
+  * irq_chip_set_vcpu_affinity_parent - Set vcpu affinity on the parent interrupt
+  * @data:	Pointer to interrupt specific data
+  * @dest:	The vcpu affinity information
+  */
+ int irq_chip_set_vcpu_affinity_parent(struct irq_data *data, void *vcpu_info)
+ {
+ 	data = data->parent_data;
+ 	if (data->chip->irq_set_vcpu_affinity)
+ 		return data->chip->irq_set_vcpu_affinity(data, vcpu_info);
+ 
+ 	return -ENOSYS;
+ }
+ 
+ /**
+  * irq_chip_set_wake_parent - Set/reset wake-up on the parent interrupt
+  * @data:	Pointer to interrupt specific data
+  * @on:		Whether to set or reset the wake-up capability of this irq
+  *
+  * Conditional, as the underlying parent chip might not implement it.
+  */
+ int irq_chip_set_wake_parent(struct irq_data *data, unsigned int on)
+ {
+ 	data = data->parent_data;
+ 	if (data->chip->irq_set_wake)
+ 		return data->chip->irq_set_wake(data, on);
+ 
+ 	return -ENOSYS;
+ }
+ #endif
+ 
+ /**
+  * irq_chip_compose_msi_msg - Componse msi message for a irq chip
+  * @data:	Pointer to interrupt specific data
+  * @msg:	Pointer to the MSI message
+  *
+  * For hierarchical domains we find the first chip in the hierarchy
+  * which implements the irq_compose_msi_msg callback. For non
+  * hierarchical we use the top level chip.
+  */
+ int irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)
+ {
+ 	struct irq_data *pos = NULL;
+ 
+ #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
+ 	for (; data; data = data->parent_data)
+ #endif
+ 		if (data->chip && data->chip->irq_compose_msi_msg)
+ 			pos = data;
+ 	if (!pos)
+ 		return -ENOSYS;
+ 
+ 	pos->chip->irq_compose_msi_msg(pos, msg);
+ 
+ 	return 0;
+ }
++>>>>>>> 0a4377de3056 (genirq: Introduce irq_set_vcpu_affinity() to target an interrupt to a VCPU)
* Unmerged path include/linux/irq.h
* Unmerged path kernel/irq/chip.c
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 380467a69758..e11d392c7c0c 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -216,6 +216,37 @@ int irq_set_affinity_hint(unsigned int irq, const struct cpumask *m)
 }
 EXPORT_SYMBOL_GPL(irq_set_affinity_hint);
 
+/**
+ *	irq_set_vcpu_affinity - Set vcpu affinity for the interrupt
+ *	@irq: interrupt number to set affinity
+ *	@vcpu_info: vCPU specific data
+ *
+ *	This function uses the vCPU specific data to set the vCPU
+ *	affinity for an irq. The vCPU specific data is passed from
+ *	outside, such as KVM. One example code path is as below:
+ *	KVM -> IOMMU -> irq_set_vcpu_affinity().
+ */
+int irq_set_vcpu_affinity(unsigned int irq, void *vcpu_info)
+{
+	unsigned long flags;
+	struct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);
+	struct irq_data *data;
+	struct irq_chip *chip;
+	int ret = -ENOSYS;
+
+	if (!desc)
+		return -EINVAL;
+
+	data = irq_desc_get_irq_data(desc);
+	chip = irq_data_get_irq_chip(data);
+	if (chip && chip->irq_set_vcpu_affinity)
+		ret = chip->irq_set_vcpu_affinity(data, vcpu_info);
+	irq_put_desc_unlock(desc, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(irq_set_vcpu_affinity);
+
 static void irq_affinity_notify(struct work_struct *work)
 {
 	struct irq_affinity_notify *notify =
