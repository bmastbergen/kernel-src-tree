cdc-ncm: use common parser

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Oliver Neukum <oneukum@suse.com>
commit 77b0a099674ac1c43b631445d8d50453e4805b29
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/77b0a099.failed

This moves cdc-ncm to the common parser for CDC user
to reduce code duplication.

	Signed-off-by: Oliver Neukum <oneukum@suse.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 77b0a099674ac1c43b631445d8d50453e4805b29)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/cdc_ncm.c
diff --cc drivers/net/usb/cdc_ncm.c
index e977104210f9,a187f08113ec..000000000000
--- a/drivers/net/usb/cdc_ncm.c
+++ b/drivers/net/usb/cdc_ncm.c
@@@ -381,64 -723,14 +382,73 @@@ int cdc_ncm_bind_common(struct usbnet *
  	len = intf->cur_altsetting->extralen;
  
  	/* parse through descriptors associated with control interface */
- 	while ((len > 0) && (buf[0] > 2) && (buf[0] <= len)) {
+ 	cdc_parse_cdc_header(&hdr, intf, buf, len);
  
++<<<<<<< HEAD
 +		if (buf[1] != USB_DT_CS_INTERFACE)
 +			goto advance;
 +
 +		switch (buf[2]) {
 +		case USB_CDC_UNION_TYPE:
 +			if (buf[0] < sizeof(*union_desc))
 +				break;
 +
 +			union_desc = (const struct usb_cdc_union_desc *)buf;
 +			/* the master must be the interface we are probing */
 +			if (intf->cur_altsetting->desc.bInterfaceNumber !=
 +			    union_desc->bMasterInterface0)
 +				goto error;
 +			ctx->data = usb_ifnum_to_if(dev->udev,
 +						    union_desc->bSlaveInterface0);
 +			break;
 +
 +		case USB_CDC_ETHERNET_TYPE:
 +			if (buf[0] < sizeof(*(ctx->ether_desc)))
 +				break;
 +
 +			ctx->ether_desc =
 +					(const struct usb_cdc_ether_desc *)buf;
 +			break;
 +
 +		case USB_CDC_NCM_TYPE:
 +			if (buf[0] < sizeof(*(ctx->func_desc)))
 +				break;
 +
 +			ctx->func_desc = (const struct usb_cdc_ncm_desc *)buf;
 +			break;
 +
 +		case USB_CDC_MBIM_TYPE:
 +			if (buf[0] < sizeof(*(ctx->mbim_desc)))
 +				break;
 +
 +			ctx->mbim_desc = (const struct usb_cdc_mbim_desc *)buf;
 +			break;
 +
 +		case USB_CDC_MBIM_EXTENDED_TYPE:
 +			if (buf[0] < sizeof(*(ctx->mbim_extended_desc)))
 +				break;
 +
 +			ctx->mbim_extended_desc =
 +				(const struct usb_cdc_mbim_extended_desc *)buf;
 +			break;
 +
 +		default:
 +			break;
 +		}
 +advance:
 +		/* advance to next descriptor */
 +		temp = buf[0];
 +		buf += temp;
 +		len -= temp;
 +	}
++=======
+ 	ctx->data = usb_ifnum_to_if(dev->udev,
+ 				    hdr.usb_cdc_union_desc->bSlaveInterface0);
+ 	ctx->ether_desc = hdr.usb_cdc_ether_desc;
+ 	ctx->func_desc = hdr.usb_cdc_ncm_desc;
+ 	ctx->mbim_desc = hdr.usb_cdc_mbim_desc;
+ 	ctx->mbim_extended_desc = hdr.usb_cdc_mbim_extended_desc;
++>>>>>>> 77b0a099674a (cdc-ncm: use common parser)
  
  	/* some buggy devices have an IAD but no CDC Union */
  	if (!union_desc && intf->intf_assoc && intf->intf_assoc->bInterfaceCount == 2) {
* Unmerged path drivers/net/usb/cdc_ncm.c
