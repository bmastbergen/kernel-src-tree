nfsd: use short read as well as i_size to set eof

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Benjamin Coddington <bcodding@redhat.com>
commit ac503e4a309a3993a069750f95c2815ee5db5aa5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ac503e4a.failed

Use the result of a local read to determine when to set the eof flag.  This
allows us to return the location of the end of the file atomically at the
time of the read.

	Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
[bfields: add some documentation]
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit ac503e4a309a3993a069750f95c2815ee5db5aa5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs3proc.c
#	fs/nfsd/nfs4xdr.c
#	fs/nfsd/vfs.h
diff --cc fs/nfsd/nfs3proc.c
index 12f2aab4f614,51c3b06e8036..000000000000
--- a/fs/nfsd/nfs3proc.c
+++ b/fs/nfsd/nfs3proc.c
@@@ -166,9 -167,9 +167,15 @@@ nfsd3_proc_read(struct svc_rqst *rqstp
  			   	  rqstp->rq_vec, argp->vlen,
  				  &resp->count);
  	if (nfserr == 0) {
++<<<<<<< HEAD
 +		struct inode	*inode = resp->fh.fh_dentry->d_inode;
 +
 +		resp->eof = (argp->offset + resp->count) >= inode->i_size;
++=======
+ 		struct inode	*inode = d_inode(resp->fh.fh_dentry);
+ 		resp->eof = nfsd_eof_on_read(cnt, resp->count, argp->offset,
+ 							inode->i_size);
++>>>>>>> ac503e4a309a (nfsd: use short read as well as i_size to set eof)
  	}
  
  	RETURN_STATUS(nfserr);
diff --cc fs/nfsd/nfs4xdr.c
index 7f583d8e4f4c,9df898ba648f..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -3310,8 -3387,8 +3312,13 @@@ static __be32 nfsd4_encode_splice_read
  		return nfserr;
  	}
  
++<<<<<<< HEAD
 +	eof = (read->rd_offset + maxcount >=
 +	       read->rd_fhp->fh_dentry->d_inode->i_size);
++=======
+ 	eof = nfsd_eof_on_read(len, maxcount, read->rd_offset,
+ 				d_inode(read->rd_fhp->fh_dentry)->i_size);
++>>>>>>> ac503e4a309a (nfsd: use short read as well as i_size to set eof)
  
  	*(p++) = htonl(eof);
  	*(p++) = htonl(maxcount);
@@@ -3387,8 -3465,8 +3395,13 @@@ static __be32 nfsd4_encode_readv(struc
  		return nfserr;
  	xdr_truncate_encode(xdr, starting_len + 8 + ((maxcount+3)&~3));
  
++<<<<<<< HEAD
 +	eof = (read->rd_offset + maxcount >=
 +	       read->rd_fhp->fh_dentry->d_inode->i_size);
++=======
+ 	eof = nfsd_eof_on_read(len, maxcount, read->rd_offset,
+ 				d_inode(read->rd_fhp->fh_dentry)->i_size);
++>>>>>>> ac503e4a309a (nfsd: use short read as well as i_size to set eof)
  
  	tmp = htonl(eof);
  	write_bytes_to_xdr_buf(xdr->buf, starting_len    , &tmp, 4);
diff --cc fs/nfsd/vfs.h
index 93472a51ef3a,2d573ec057f8..000000000000
--- a/fs/nfsd/vfs.h
+++ b/fs/nfsd/vfs.h
@@@ -136,4 -133,29 +136,32 @@@ static inline __be32 fh_getattr(struct 
  	return nfserrno(vfs_getattr(&p, stat));
  }
  
++<<<<<<< HEAD
++=======
+ static inline int nfsd_create_is_exclusive(int createmode)
+ {
+ 	return createmode == NFS3_CREATE_EXCLUSIVE
+ 	       || createmode == NFS4_CREATE_EXCLUSIVE4_1;
+ }
+ 
+ static inline bool nfsd_eof_on_read(long requested, long read,
+ 				loff_t offset, loff_t size)
+ {
+ 	/* We assume a short read means eof: */
+ 	if (requested > read)
+ 		return true;
+ 	/*
+ 	 * A non-short read might also reach end of file.  The spec
+ 	 * still requires us to set eof in that case.
+ 	 *
+ 	 * Further operations may have modified the file size since
+ 	 * the read, so the following check is not atomic with the read.
+ 	 * We've only seen that cause a problem for a client in the case
+ 	 * where the read returned a count of 0 without setting eof.
+ 	 * That case was fixed by the addition of the above check.
+ 	 */
+ 	return (offset + read >= size);
+ }
+ 
++>>>>>>> ac503e4a309a (nfsd: use short read as well as i_size to set eof)
  #endif /* LINUX_NFSD_VFS_H */
* Unmerged path fs/nfsd/nfs3proc.c
* Unmerged path fs/nfsd/nfs4xdr.c
* Unmerged path fs/nfsd/vfs.h
