mm/balloon_compaction: fix deflation when compaction is disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mm] balloon_compaction: fix deflation when compaction is disabled (Luiz Capitulino) [1263649]
Rebuild_FUZZ: 97.60%
commit-author Konstantin Khlebnikov <k.khlebnikov@samsung.com>
commit 4d88e6f7d5ffc84e6094a47925870f4a130555c2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4d88e6f7.failed

If CONFIG_BALLOON_COMPACTION=n balloon_page_insert() does not link pages
with balloon and doesn't set PagePrivate flag, as a result
balloon_page_dequeue() cannot get any pages because it thinks that all
of them are isolated.  Without balloon compaction nobody can isolate
ballooned pages.  It's safe to remove this check.

Fixes: d6d86c0a7f8d ("mm/balloon_compaction: redesign ballooned pages management").
	Signed-off-by: Konstantin Khlebnikov <k.khlebnikov@samsung.com>
	Reported-by: Matt Mullins <mmullins@mmlx.us>
	Cc: <stable@vger.kernel.org>	[3.17]
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 4d88e6f7d5ffc84e6094a47925870f4a130555c2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/balloon_compaction.c
diff --cc mm/balloon_compaction.c
index 6e45a5074bf0,fcad8322ef36..000000000000
--- a/mm/balloon_compaction.c
+++ b/mm/balloon_compaction.c
@@@ -93,18 -68,16 +93,28 @@@ struct page *balloon_page_dequeue(struc
  		 * to be released by the balloon driver.
  		 */
  		if (trylock_page(page)) {
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BALLOON_COMPACTION
+ 			if (!PagePrivate(page)) {
+ 				/* raced with isolation */
+ 				unlock_page(page);
+ 				continue;
+ 			}
+ #endif
++>>>>>>> 4d88e6f7d5ff (mm/balloon_compaction: fix deflation when compaction is disabled)
  			spin_lock_irqsave(&b_dev_info->pages_lock, flags);
 +			/*
 +			 * Raise the page refcount here to prevent any wrong
 +			 * attempt to isolate this page, in case of coliding
 +			 * with balloon_page_isolate() just after we release
 +			 * the page lock.
 +			 *
 +			 * balloon_page_free() will take care of dropping
 +			 * this extra refcount later.
 +			 */
 +			get_page(page);
  			balloon_page_delete(page);
 -			__count_vm_event(BALLOON_DEFLATE);
  			spin_unlock_irqrestore(&b_dev_info->pages_lock, flags);
  			unlock_page(page);
  			dequeued_page = true;
* Unmerged path mm/balloon_compaction.c
