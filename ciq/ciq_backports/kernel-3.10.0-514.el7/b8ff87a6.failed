x86/efi: Firmware agnostic handover entry points

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] efi: Firmware agnostic handover entry points (Lenny Szubowicz) [1310154]
Rebuild_FUZZ: 95.65%
commit-author Matt Fleming <matt.fleming@intel.com>
commit b8ff87a6158886771677e6dc8139bac6e3cba717
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b8ff87a6.failed

The EFI handover code only works if the "bitness" of the firmware and
the kernel match, i.e. 64-bit firmware and 64-bit kernel - it is not
possible to mix the two. This goes against the tradition that a 32-bit
kernel can be loaded on a 64-bit BIOS platform without having to do
anything special in the boot loader. Linux distributions, for one thing,
regularly run only 32-bit kernels on their live media.

Despite having only one 'handover_offset' field in the kernel header,
EFI boot loaders use two separate entry points to enter the kernel based
on the architecture the boot loader was compiled for,

    (1) 32-bit loader: handover_offset
    (2) 64-bit loader: handover_offset + 512

Since we already have two entry points, we can leverage them to infer
the bitness of the firmware we're running on, without requiring any boot
loader modifications, by making (1) and (2) valid entry points for both
CONFIG_X86_32 and CONFIG_X86_64 kernels.

To be clear, a 32-bit boot loader will always use (1) and a 64-bit boot
loader will always use (2). It's just that, if a single kernel image
supports (1) and (2) that image can be used with both 32-bit and 64-bit
boot loaders, and hence both 32-bit and 64-bit EFI.

(1) and (2) must be 512 bytes apart at all times, but that is already
part of the boot ABI and we could never change that delta without
breaking existing boot loaders anyhow.

	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit b8ff87a6158886771677e6dc8139bac6e3cba717)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/Makefile
#	arch/x86/boot/compressed/head_64.S
diff --cc arch/x86/boot/Makefile
index 46ed0841d7d9,abb9eba61b50..000000000000
--- a/arch/x86/boot/Makefile
+++ b/arch/x86/boot/Makefile
@@@ -93,7 -80,7 +93,11 @@@ targets += voffset.
  $(obj)/voffset.h: vmlinux FORCE
  	$(call if_changed,voffset)
  
++<<<<<<< HEAD
 +sed-zoffset := -e 's/^\([0-9a-fA-F]*\) [ABCDGRSTVW] \(startup_32\|startup_64\|efi32_stub_entry\|efi64_stub_entry\|efi_pe_entry\|input_data\|_end\|z_.*\)$$/\#define ZO_\2 0x\1/p'
++=======
+ sed-zoffset := -e 's/^\([0-9a-fA-F]*\) . \(startup_32\|startup_64\|efi32_stub_entry\|efi64_stub_entry\|efi_pe_entry\|input_data\|_end\|z_.*\)$$/\#define ZO_\2 0x\1/p'
++>>>>>>> b8ff87a61588 (x86/efi: Firmware agnostic handover entry points)
  
  quiet_cmd_zoffset = ZOFFSET $@
        cmd_zoffset = $(NM) $< | sed -n $(sed-zoffset) > $@
diff --cc arch/x86/boot/compressed/head_64.S
index 16f24e6dad79,37c741b0d2ac..000000000000
--- a/arch/x86/boot/compressed/head_64.S
+++ b/arch/x86/boot/compressed/head_64.S
@@@ -209,18 -240,40 +240,33 @@@ ENTRY(startup_64
  	jmp	preferred_addr
  
  ENTRY(efi_pe_entry)
 -	movq	%rcx, efi64_config(%rip)	/* Handle */
 -	movq	%rdx, efi64_config+8(%rip) /* EFI System table pointer */
 -
 -	leaq	efi64_config(%rip), %rax
 -	movq	%rax, efi_config(%rip)
 -
 -	call	1f
 -1:	popq	%rbp
 -	subq	$1b, %rbp
 -
 -	/*
 -	 * Relocate efi_config->call().
 -	 */
 -	addq	%rbp, efi64_config+88(%rip)
 -
 -	movq	%rax, %rdi
 +	mov	%rcx, %rdi
 +	mov	%rdx, %rsi
 +	pushq	%rdi
 +	pushq	%rsi
  	call	make_boot_params
  	cmpq	$0,%rax
 -	je	fail
 -	mov	%rax, %rsi
 -	jmp	2f		/* Skip the relocation */
 +	je	1f
 +	mov	%rax, %rdx
 +	popq	%rsi
 +	popq	%rdi
  
++<<<<<<< HEAD
 +ENTRY(efi_stub_entry)
++=======
+ handover_entry:
+ 	call	1f
+ 1:	popq	%rbp
+ 	subq	$1b, %rbp
+ 
+ 	/*
+ 	 * Relocate efi_config->call().
+ 	 */
+ 	movq	efi_config(%rip), %rax
+ 	addq	%rbp, 88(%rax)
+ 2:
+ 	movq	efi_config(%rip), %rdi
++>>>>>>> b8ff87a61588 (x86/efi: Firmware agnostic handover entry points)
  	call	efi_main
  	movq	%rax,%rsi
  	cmpq	$0,%rax
@@@ -369,6 -439,22 +429,25 @@@ gdt
  	.quad   0x0000000000000000	/* TS continued */
  gdt_end:
  
++<<<<<<< HEAD
++=======
+ efi_config:
+ 	.quad	0
+ 
+ #ifdef CONFIG_EFI_MIXED
+ 	.global efi32_config
+ efi32_config:
+ 	.fill	11,8,0
+ 	.quad	efi64_thunk
+ 	.byte	0
+ #endif
+ 
+ 	.global efi64_config
+ efi64_config:
+ 	.fill	11,8,0
+ 	.quad	efi_call6
+ 	.byte	1
++>>>>>>> b8ff87a61588 (x86/efi: Firmware agnostic handover entry points)
  /*
   * Stack and heap for uncompression
   */
* Unmerged path arch/x86/boot/Makefile
diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c
index a1ae20b40077..7a6880a4236e 100644
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@ -703,12 +703,13 @@ static efi_status_t alloc_e820ext(u32 nr_desc, struct setup_data **e820ext,
 }
 
 static efi_status_t exit_boot(struct boot_params *boot_params,
-			      void *handle)
+			      void *handle, bool is64)
 {
 	struct efi_info *efi = &boot_params->efi_info;
 	unsigned long map_sz, key, desc_size;
 	efi_memory_desc_t *mem_map;
 	struct setup_data *e820ext;
+	const char *signature;
 	__u32 e820ext_size;
 	__u32 nr_desc, prev_nr_desc;
 	efi_status_t status;
@@ -742,7 +743,9 @@ get_map:
 		goto get_map; /* Allocated memory, get map again */
 	}
 
-	memcpy(&efi->efi_loader_signature, EFI_LOADER_SIGNATURE, sizeof(__u32));
+	signature = is64 ? EFI64_LOADER_SIGNATURE : EFI32_LOADER_SIGNATURE;
+	memcpy(&efi->efi_loader_signature, signature, sizeof(__u32));
+
 	efi->efi_systab = (unsigned long)sys_table;
 	efi->efi_memdesc_size = desc_size;
 	efi->efi_memdesc_version = desc_version;
@@ -842,7 +845,7 @@ struct boot_params *efi_main(void *handle, efi_system_table_t *_table,
 			goto fail;
 	}
 
-	status = exit_boot(boot_params, handle);
+	status = exit_boot(boot_params, handle, is64);
 	if (status != EFI_SUCCESS)
 		goto fail;
 
diff --git a/arch/x86/boot/compressed/head_32.S b/arch/x86/boot/compressed/head_32.S
index 1e3184f6072f..5290f83d3285 100644
--- a/arch/x86/boot/compressed/head_32.S
+++ b/arch/x86/boot/compressed/head_32.S
@@ -52,7 +52,7 @@ ENTRY(efi_pe_entry)
 	pushl	%ecx
 	sub	$0x4, %esp
 
-ENTRY(efi_stub_entry)
+ENTRY(efi32_stub_entry)
 	add	$0x4, %esp
 	call	efi_main
 	cmpl	$0, %eax
* Unmerged path arch/x86/boot/compressed/head_64.S
diff --git a/arch/x86/boot/tools/build.c b/arch/x86/boot/tools/build.c
index bf262077ec92..4f07df5ac5d9 100644
--- a/arch/x86/boot/tools/build.c
+++ b/arch/x86/boot/tools/build.c
@@ -53,7 +53,8 @@ int is_big_kernel;
 
 #define PECOFF_RELOC_RESERVE 0x20
 
-unsigned long efi_stub_entry;
+unsigned long efi32_stub_entry;
+unsigned long efi64_stub_entry;
 unsigned long efi_pe_entry;
 unsigned long startup_64;
 
@@ -231,20 +232,26 @@ static void efi_stub_defaults(void)
 	/* Defaults for old kernel */
 #ifdef CONFIG_X86_32
 	efi_pe_entry = 0x10;
-	efi_stub_entry = 0x30;
 #else
 	efi_pe_entry = 0x210;
-	efi_stub_entry = 0x230;
 	startup_64 = 0x200;
 #endif
 }
 
 static void efi_stub_entry_update(void)
 {
-#ifdef CONFIG_X86_64 /* Yes, this is really how we defined it :( */
-	efi_stub_entry -= 0x200;
+	unsigned long addr = efi32_stub_entry;
+
+#ifdef CONFIG_X86_64
+	/* Yes, this is really how we defined it :( */
+	addr = efi64_stub_entry - 0x200;
+#endif
+
+#ifdef CONFIG_EFI_MIXED
+	if (efi32_stub_entry != addr)
+		die("32-bit and 64-bit EFI entry points do not match\n");
 #endif
-	put_unaligned_le32(efi_stub_entry, &buf[0x264]);
+	put_unaligned_le32(addr, &buf[0x264]);
 }
 
 #else
@@ -289,7 +296,8 @@ static void parse_zoffset(char *fname)
 	p = (char *)buf;
 
 	while (p && *p) {
-		PARSE_ZOFS(p, efi_stub_entry);
+		PARSE_ZOFS(p, efi32_stub_entry);
+		PARSE_ZOFS(p, efi64_stub_entry);
 		PARSE_ZOFS(p, efi_pe_entry);
 		PARSE_ZOFS(p, startup_64);
 
diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 46e39ba1f72c..66b8e1e68cd5 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -19,9 +19,11 @@
  */
 #define EFI_OLD_MEMMAP		EFI_ARCH_1
 
+#define EFI32_LOADER_SIGNATURE	"EL32"
+#define EFI64_LOADER_SIGNATURE	"EL64"
+
 #ifdef CONFIG_X86_32
 
-#define EFI_LOADER_SIGNATURE	"EL32"
 
 extern unsigned long asmlinkage efi_call_phys(void *, ...);
 
@@ -57,8 +59,6 @@ extern unsigned long asmlinkage efi_call_phys(void *, ...);
 
 #else /* !CONFIG_X86_32 */
 
-#define EFI_LOADER_SIGNATURE	"EL64"
-
 extern u64 efi_call0(void *fp);
 extern u64 efi_call1(void *fp, u64 arg1);
 extern u64 efi_call2(void *fp, u64 arg1, u64 arg2);
