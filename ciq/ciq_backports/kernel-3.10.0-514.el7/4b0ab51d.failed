SUNRPC: xs_sock_mark_closed() does not need to trigger socket autoclose

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 4b0ab51db32eba0f48b7618254742f143364a28d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4b0ab51d.failed

Under all conditions, it should be quite sufficient just to mark
the socket as disconnected. It will then be closed by the
transport shutdown or reconnect code.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 4b0ab51db32eba0f48b7618254742f143364a28d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtsock.c
diff --cc net/sunrpc/xprtsock.c
index 357bc10926b1,1a85e0ed0b48..000000000000
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@@ -844,6 -764,21 +844,24 @@@ static void xs_restore_old_callbacks(st
  	sk->sk_error_report = transport->old_error_report;
  }
  
++<<<<<<< HEAD
++=======
+ static void xs_sock_reset_connection_flags(struct rpc_xprt *xprt)
+ {
+ 	smp_mb__before_atomic();
+ 	clear_bit(XPRT_CLOSE_WAIT, &xprt->state);
+ 	clear_bit(XPRT_CLOSING, &xprt->state);
+ 	smp_mb__after_atomic();
+ }
+ 
+ static void xs_sock_mark_closed(struct rpc_xprt *xprt)
+ {
+ 	xs_sock_reset_connection_flags(xprt);
+ 	/* Mark transport as closed and wake up all pending tasks */
+ 	xprt_disconnect_done(xprt);
+ }
+ 
++>>>>>>> 4b0ab51db32e (SUNRPC: xs_sock_mark_closed() does not need to trigger socket autoclose)
  /**
   * xs_error_report - callback to handle TCP socket state errors
   * @sk: socket
* Unmerged path net/sunrpc/xprtsock.c
