rhashtable: future table needs to be traversed when remove an object

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ying Xue <ying.xue@windriver.com>
commit bd6d4db552ceb52fb19890a454836dcda59743ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bd6d4db5.failed

When remove an object from hash table, we currently only traverse old
bucket table to check whether the object exists. If the object is not
found in it, we will try again. But in the second search loop, we still
search the object from the old table instead of future table. As a
result, the object may be not removed from hash table especially when
resizing is currently in progress and the object is just saved in the
future table.

	Signed-off-by: Ying Xue <ying.xue@windriver.com>
	Cc: Thomas Graf <tgraf@suug.ch>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bd6d4db552ceb52fb19890a454836dcda59743ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/rhashtable.c
diff --cc lib/rhashtable.c
index be20e9720492,1aef942976fe..000000000000
--- a/lib/rhashtable.c
+++ b/lib/rhashtable.c
@@@ -387,6 -608,20 +387,23 @@@ bool rhashtable_remove(struct rhashtabl
  		return true;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (tbl != rht_dereference_rcu(ht->future_tbl, ht)) {
+ 		spin_unlock_bh(lock);
+ 
+ 		tbl = rht_dereference_rcu(ht->future_tbl, ht);
+ 		hash = head_hashfn(ht, tbl, obj);
+ 
+ 		lock = bucket_lock(tbl, hash);
+ 		spin_lock_bh(lock);
+ 		goto restart;
+ 	}
+ 
+ 	spin_unlock_bh(lock);
+ 	rcu_read_unlock();
+ 
++>>>>>>> bd6d4db552ce (rhashtable: future table needs to be traversed when remove an object)
  	return false;
  }
  EXPORT_SYMBOL_GPL(rhashtable_remove);
* Unmerged path lib/rhashtable.c
