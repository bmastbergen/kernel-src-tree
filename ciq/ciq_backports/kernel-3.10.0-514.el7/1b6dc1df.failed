nfsd/sunrpc: factor svc_rqst allocation and freeing from sv_nrthreads refcounting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jeff Layton <jlayton@primarydata.com>
commit 1b6dc1dffbb142de60eb65f6155276ac31ff5474
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1b6dc1df.failed

In later patches, we'll want to be able to allocate and free svc_rqst
structures without monkeying with the serv->sv_nrthreads refcount.

Factor those pieces out of their respective functions.

	Signed-off-by: Shirley Ma <shirley.ma@oracle.com>
	Acked-by: Jeff Layton <jlayton@primarydata.com>
	Tested-by: Shirley Ma <shirley.ma@oracle.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 1b6dc1dffbb142de60eb65f6155276ac31ff5474)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/sunrpc/svc.h
#	net/sunrpc/svc.c
diff --cc include/linux/sunrpc/svc.h
index e83dc094a3ae,cc0fc712bb82..000000000000
--- a/include/linux/sunrpc/svc.h
+++ b/include/linux/sunrpc/svc.h
@@@ -450,9 -457,12 +450,16 @@@ int svc_rpcb_setup(struct svc_serv *ser
  void svc_rpcb_cleanup(struct svc_serv *serv, struct net *net);
  int svc_bind(struct svc_serv *serv, struct net *net);
  struct svc_serv *svc_create(struct svc_program *, unsigned int,
++<<<<<<< HEAD
 +			    void (*shutdown)(struct svc_serv *, struct net *net));
++=======
+ 			    struct svc_serv_ops *);
+ struct svc_rqst *svc_rqst_alloc(struct svc_serv *serv,
+ 					struct svc_pool *pool, int node);
++>>>>>>> 1b6dc1dffbb1 (nfsd/sunrpc: factor svc_rqst allocation and freeing from sv_nrthreads refcounting)
  struct svc_rqst *svc_prepare_thread(struct svc_serv *serv,
  					struct svc_pool *pool, int node);
+ void		   svc_rqst_free(struct svc_rqst *);
  void		   svc_exit_thread(struct svc_rqst *);
  unsigned int	   svc_pool_map_get(void);
  void		   svc_pool_map_put(void);
diff --cc net/sunrpc/svc.c
index 3c06b4460d6a,a8f579df14d8..000000000000
--- a/net/sunrpc/svc.c
+++ b/net/sunrpc/svc.c
@@@ -597,32 -589,46 +597,66 @@@ svc_rqst_alloc(struct svc_serv *serv, s
  
  	rqstp = kzalloc_node(sizeof(*rqstp), GFP_KERNEL, node);
  	if (!rqstp)
+ 		return rqstp;
+ 
++<<<<<<< HEAD
++=======
+ 	__set_bit(RQ_BUSY, &rqstp->rq_flags);
+ 	spin_lock_init(&rqstp->rq_lock);
+ 	rqstp->rq_server = serv;
+ 	rqstp->rq_pool = pool;
+ 
+ 	rqstp->rq_argp = kmalloc_node(serv->sv_xdrsize, GFP_KERNEL, node);
+ 	if (!rqstp->rq_argp)
  		goto out_enomem;
  
+ 	rqstp->rq_resp = kmalloc_node(serv->sv_xdrsize, GFP_KERNEL, node);
+ 	if (!rqstp->rq_resp)
+ 		goto out_enomem;
+ 
+ 	if (!svc_init_buffer(rqstp, serv->sv_max_mesg, node))
+ 		goto out_enomem;
+ 
+ 	return rqstp;
+ out_enomem:
+ 	svc_rqst_free(rqstp);
+ 	return NULL;
+ }
+ EXPORT_SYMBOL_GPL(svc_rqst_alloc);
+ 
+ struct svc_rqst *
+ svc_prepare_thread(struct svc_serv *serv, struct svc_pool *pool, int node)
+ {
+ 	struct svc_rqst	*rqstp;
+ 
+ 	rqstp = svc_rqst_alloc(serv, pool, node);
+ 	if (!rqstp)
+ 		return ERR_PTR(-ENOMEM);
+ 
++>>>>>>> 1b6dc1dffbb1 (nfsd/sunrpc: factor svc_rqst allocation and freeing from sv_nrthreads refcounting)
  	serv->sv_nrthreads++;
  	spin_lock_bh(&pool->sp_lock);
  	pool->sp_nrthreads++;
 -	list_add_rcu(&rqstp->rq_all, &pool->sp_all_threads);
 +	list_add(&rqstp->rq_all, &pool->sp_all_threads);
  	spin_unlock_bh(&pool->sp_lock);
++<<<<<<< HEAD
 +	rqstp->rq_server = serv;
 +	rqstp->rq_pool = pool;
 +
 +	rqstp->rq_argp = kmalloc_node(serv->sv_xdrsize, GFP_KERNEL, node);
 +	if (!rqstp->rq_argp)
 +		goto out_thread;
 +
 +	rqstp->rq_resp = kmalloc_node(serv->sv_xdrsize, GFP_KERNEL, node);
 +	if (!rqstp->rq_resp)
 +		goto out_thread;
 +
 +	if (!svc_init_buffer(rqstp, serv->sv_max_mesg, node))
 +		goto out_thread;
 +
++=======
++>>>>>>> 1b6dc1dffbb1 (nfsd/sunrpc: factor svc_rqst allocation and freeing from sv_nrthreads refcounting)
  	return rqstp;
- out_thread:
- 	svc_exit_thread(rqstp);
- out_enomem:
- 	return ERR_PTR(-ENOMEM);
  }
  EXPORT_SYMBOL_GPL(svc_prepare_thread);
  
@@@ -768,10 -781,11 +808,14 @@@ svc_exit_thread(struct svc_rqst *rqstp
  
  	spin_lock_bh(&pool->sp_lock);
  	pool->sp_nrthreads--;
 -	if (!test_and_set_bit(RQ_VICTIM, &rqstp->rq_flags))
 -		list_del_rcu(&rqstp->rq_all);
 +	list_del(&rqstp->rq_all);
  	spin_unlock_bh(&pool->sp_lock);
  
++<<<<<<< HEAD
 +	kfree(rqstp);
++=======
+ 	svc_rqst_free(rqstp);
++>>>>>>> 1b6dc1dffbb1 (nfsd/sunrpc: factor svc_rqst allocation and freeing from sv_nrthreads refcounting)
  
  	/* Release the server */
  	if (serv)
* Unmerged path include/linux/sunrpc/svc.h
* Unmerged path net/sunrpc/svc.c
