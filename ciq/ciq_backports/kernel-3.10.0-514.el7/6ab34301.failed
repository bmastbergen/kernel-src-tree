mfd: Add ACPI support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 6ab3430129e258ea31dd214adf1c760dfafde67a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6ab34301.failed

If an MFD device is backed by ACPI namespace, we should allow subdevice
drivers to access their corresponding ACPI companion devices through normal
means (e.g using ACPI_COMPANION()).

This patch adds such support to the MFD core. If the MFD parent device
does not specify any ACPI _HID/_CID for the child device, the child
device will share the parent ACPI companion device. Otherwise the child
device will be assigned with the corresponding ACPI companion, if found
in the namespace below the parent.

	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Reviewed-by: Darren Hart <dvhart@linux.intel.com>
	Signed-off-by: Lee Jones <lee.jones@linaro.org>
(cherry picked from commit 6ab3430129e258ea31dd214adf1c760dfafde67a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/acpi/enumeration.txt
diff --cc Documentation/acpi/enumeration.txt
index d977778b5e67,b60d2ab69497..000000000000
--- a/Documentation/acpi/enumeration.txt
+++ b/Documentation/acpi/enumeration.txt
@@@ -293,32 -287,55 +293,64 @@@ the device to the driver. For example
  
  These GPIO numbers are controller relative and path "\\_SB.PCI0.GPI0"
  specifies the path to the controller. In order to use these GPIOs in Linux
 -we need to translate them to the corresponding Linux GPIO descriptors.
 -
 -There is a standard GPIO API for that and is documented in
 -Documentation/gpio/.
 +we need to translate them to the Linux GPIO numbers.
  
 -In the above example we can get the corresponding two GPIO descriptors with
 -a code like this:
 +The driver can do this by including <linux/acpi_gpio.h> and then calling
 +acpi_get_gpio(path, gpio). This will return the Linux GPIO number or
 +negative errno if there was no translation found.
  
 -	#include <linux/gpio/consumer.h>
 -	...
 +In a simple case of just getting the Linux GPIO number from device
 +resources one can use acpi_get_gpio_by_index() helper function. It takes
 +pointer to the device and index of the GpioIo/GpioInt descriptor in the
 +device resources list. For example:
  
 -	struct gpio_desc *irq_desc, *power_desc;
 +	int gpio_irq, gpio_power;
 +	int ret;
  
 -	irq_desc = gpiod_get_index(dev, NULL, 1);
 -	if (IS_ERR(irq_desc))
 +	gpio_irq = acpi_get_gpio_by_index(dev, 1, NULL);
 +	if (gpio_irq < 0)
  		/* handle error */
  
 -	power_desc = gpiod_get_index(dev, NULL, 0);
 -	if (IS_ERR(power_desc))
 +	gpio_power = acpi_get_gpio_by_index(dev, 0, NULL);
 +	if (gpio_power < 0)
  		/* handle error */
  
 -	/* Now we can use the GPIO descriptors */
 +	/* Now we can use the GPIO numbers */
 +
++<<<<<<< HEAD
 +Other GpioIo parameters must be converted first by the driver to be
 +suitable to the gpiolib before passing them.
  
 +In case of GpioInt resource an additional call to gpio_to_irq() must be
 +done before calling request_irq().
++=======
+ There are also devm_* versions of these functions which release the
+ descriptors once the device is released.
+ 
+ MFD devices
+ ~~~~~~~~~~~
+ The MFD devices register their children as platform devices. For the child
+ devices there needs to be an ACPI handle that they can use to reference
+ parts of the ACPI namespace that relate to them. In the Linux MFD subsystem
+ we provide two ways:
+ 
+ 	o The children share the parent ACPI handle.
+ 	o The MFD cell can specify the ACPI id of the device.
+ 
+ For the first case, the MFD drivers do not need to do anything. The
+ resulting child platform device will have its ACPI_COMPANION() set to point
+ to the parent device.
+ 
+ If the ACPI namespace has a device that we can match using an ACPI id,
+ the id should be set like:
+ 
+ 	static struct mfd_cell my_subdevice_cell = {
+ 		.name = "my_subdevice",
+ 		/* set the resources relative to the parent */
+ 		.acpi_pnpid = "XYZ0001",
+ 	};
+ 
+ The ACPI id "XYZ0001" is then used to lookup an ACPI device directly under
+ the MFD device and if found, that ACPI companion device is bound to the
+ resulting child platform device.
++>>>>>>> 6ab3430129e2 (mfd: Add ACPI support)
* Unmerged path Documentation/acpi/enumeration.txt
diff --git a/drivers/mfd/mfd-core.c b/drivers/mfd/mfd-core.c
index f3d7d85412c5..8217534c57c0 100644
--- a/drivers/mfd/mfd-core.c
+++ b/drivers/mfd/mfd-core.c
@@ -78,6 +78,44 @@ static int mfd_platform_add_cell(struct platform_device *pdev,
 	return 0;
 }
 
+#if IS_ENABLED(CONFIG_ACPI)
+static void mfd_acpi_add_device(const struct mfd_cell *cell,
+				struct platform_device *pdev)
+{
+	struct acpi_device *parent_adev;
+	struct acpi_device *adev;
+
+	parent_adev = ACPI_COMPANION(pdev->dev.parent);
+	if (!parent_adev)
+		return;
+
+	/*
+	 * MFD child device gets its ACPI handle either from the ACPI
+	 * device directly under the parent that matches the acpi_pnpid or
+	 * it will use the parent handle if is no acpi_pnpid is given.
+	 */
+	adev = parent_adev;
+	if (cell->acpi_pnpid) {
+		struct acpi_device_id ids[2] = {};
+		struct acpi_device *child_adev;
+
+		strlcpy(ids[0].id, cell->acpi_pnpid, sizeof(ids[0].id));
+		list_for_each_entry(child_adev, &parent_adev->children, node)
+			if (acpi_match_device_ids(child_adev, ids)) {
+				adev = child_adev;
+				break;
+			}
+	}
+
+	ACPI_COMPANION_SET(&pdev->dev, adev);
+}
+#else
+static inline void mfd_acpi_add_device(const struct mfd_cell *cell,
+				       struct platform_device *pdev)
+{
+}
+#endif
+
 static int mfd_add_device(struct device *parent, int id,
 			  const struct mfd_cell *cell, atomic_t *usage_count,
 			  struct resource *mem_base,
@@ -109,6 +147,8 @@ static int mfd_add_device(struct device *parent, int id,
 		}
 	}
 
+	mfd_acpi_add_device(cell, pdev);
+
 	if (cell->pdata_size) {
 		ret = platform_device_add_data(pdev,
 					cell->platform_data, cell->pdata_size);
diff --git a/include/linux/mfd/core.h b/include/linux/mfd/core.h
index 331041c7ae6d..d021dc440b83 100644
--- a/include/linux/mfd/core.h
+++ b/include/linux/mfd/core.h
@@ -49,6 +49,9 @@ struct mfd_cell {
 	 */
 	const char		*of_compatible;
 
+	/* Matches ACPI PNP id, either _HID or _CID */
+	const char		*acpi_pnpid;
+
 	/*
 	 * These resources can be specified relative to the parent device.
 	 * For accessing hardware you should use resources from the platform dev
