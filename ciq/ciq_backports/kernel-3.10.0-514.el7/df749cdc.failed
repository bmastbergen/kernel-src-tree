IB/iser: Support up to 8MB data transfer in a single command

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sagi Grimberg <sagig@mellanox.com>
commit df749cdc45d9f97cb0a5e6ceab80e2e00ee9bf85
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/df749cdc.failed

iser support up to 512KB data transfer in a single scsi command.
This means that larger IOs will split to different request. While
iser can easily saturate FDR/EDR wires, some arrays are fine tuned
for 1MB (or larger) IO sizes, hence add an option to support larger
transfers (up to 8MB) if the device allows it.

Given that a few target implementations don't support data transfers
of more than 512KB by default and the fact that larger IO sizes require
more resources, we introduce a module parameter to determine the
maximum number of 512B sectors in a single scsi command.
Users that are interested in larger transfers can change this value given
that the target supports larger transfers.

At the moment, iser works in 4K pages granularity, In a later stage
we will get it to work with system page size instead.

IO operations that consists of N pages will need a page vector
of size N+1 in case the first SG element contains an offset. Given
that some devices allocates memory regions in powers of 2, this
means that allocating a region with N+1 pages, will result in
region resources allocation of the next power of 2. Since we don't
want that to happen, in case we are in the limit of IO size supported
and the first SG element has an offset, we align the SG list using a
bounce buffer (which is OK given that this is not likely to happen a lot).

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit df749cdc45d9f97cb0a5e6ceab80e2e00ee9bf85)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iscsi_iser.c
#	drivers/infiniband/ulp/iser/iser_memory.c
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.c
index 0bfb7fbb2197,0720bb46589f..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@@ -77,30 -77,33 +77,43 @@@
  static struct scsi_host_template iscsi_iser_sht;
  static struct iscsi_transport iscsi_iser_transport;
  static struct scsi_transport_template *iscsi_iser_scsi_transport;
 -static struct workqueue_struct *release_wq;
 -struct iser_global ig;
 +
 +static unsigned int iscsi_max_lun = 512;
 +module_param_named(max_lun, iscsi_max_lun, uint, S_IRUGO);
  
  int iser_debug_level = 0;
 -module_param_named(debug_level, iser_debug_level, int, S_IRUGO | S_IWUSR);
 +bool iser_pi_enable = false;
 +int iser_pi_guard = 0;
 +
 +MODULE_DESCRIPTION("iSER (iSCSI Extensions for RDMA) Datamover");
 +MODULE_LICENSE("Dual BSD/GPL");
 +MODULE_AUTHOR("Alex Nezhinsky, Dan Bar Dov, Or Gerlitz");
 +MODULE_VERSION(DRV_VER);
 +
 +module_param_named(debug_level, iser_debug_level, int, 0644);
  MODULE_PARM_DESC(debug_level, "Enable debug tracing if > 0 (default:disabled)");
  
++<<<<<<< HEAD
 +module_param_named(pi_enable, iser_pi_enable, bool, 0644);
++=======
+ static unsigned int iscsi_max_lun = 512;
+ module_param_named(max_lun, iscsi_max_lun, uint, S_IRUGO);
+ MODULE_PARM_DESC(max_lun, "Max LUNs to allow per session (default:512");
+ 
+ unsigned int iser_max_sectors = ISER_DEF_MAX_SECTORS;
+ module_param_named(max_sectors, iser_max_sectors, uint, S_IRUGO | S_IWUSR);
+ MODULE_PARM_DESC(max_sectors, "Max number of sectors in a single scsi command (default:1024");
+ 
+ bool iser_pi_enable = false;
+ module_param_named(pi_enable, iser_pi_enable, bool, S_IRUGO);
++>>>>>>> df749cdc45d9 (IB/iser: Support up to 8MB data transfer in a single command)
  MODULE_PARM_DESC(pi_enable, "Enable T10-PI offload support (default:disabled)");
  
 -int iser_pi_guard;
 -module_param_named(pi_guard, iser_pi_guard, int, S_IRUGO);
 -MODULE_PARM_DESC(pi_guard, "T10-PI guard_type [deprecated]");
 +module_param_named(pi_guard, iser_pi_guard, int, 0644);
 +MODULE_PARM_DESC(pi_guard, "T10-PI guard_type, 0:CRC|1:IP_CSUM (default:CRC)");
 +
 +static struct workqueue_struct *release_wq;
 +struct iser_global ig;
  
  /*
   * iscsi_iser_recv() - Process a successfull recv completion
@@@ -967,9 -971,9 +982,15 @@@ static struct scsi_host_template iscsi_
  	.module                 = THIS_MODULE,
  	.name                   = "iSCSI Initiator over iSER",
  	.queuecommand           = iscsi_queuecommand,
++<<<<<<< HEAD
 +	.change_queue_depth	= iscsi_change_queue_depth,
 +	.sg_tablesize           = ISCSI_ISER_SG_TABLESIZE,
 +	.max_sectors		= 1024,
++=======
+ 	.change_queue_depth	= scsi_change_queue_depth,
+ 	.sg_tablesize           = ISCSI_ISER_DEF_SG_TABLESIZE,
+ 	.max_sectors            = ISER_DEF_MAX_SECTORS,
++>>>>>>> df749cdc45d9 (IB/iser: Support up to 8MB data transfer in a single command)
  	.cmd_per_lun            = ISER_DEF_CMD_PER_LUN,
  	.eh_abort_handler       = iscsi_eh_abort,
  	.eh_device_reset_handler= iscsi_eh_device_reset,
diff --cc drivers/infiniband/ulp/iser/iser_memory.c
index 51f03be2c790,384fd0a49cca..000000000000
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@@ -860,44 -790,79 +869,49 @@@ static int iser_fast_reg_mr(struct iscs
  	return ret;
  }
  
 -static int
 -iser_handle_unaligned_buf(struct iscsi_iser_task *task,
 -			  struct iser_data_buf *mem,
 -			  enum iser_data_dir dir)
 +/**
 + * iser_reg_rdma_mem_fastreg - Registers memory intended for RDMA,
 + * using Fast Registration WR (if possible) obtaining rkey and va
 + *
 + * returns 0 on success, errno code on failure
 + */
 +int iser_reg_rdma_mem_fastreg(struct iscsi_iser_task *iser_task,
 +			      enum iser_data_dir cmd_dir)
  {
 -	struct iser_conn *iser_conn = task->iser_conn;
 -	struct iser_device *device = iser_conn->ib_conn.device;
 +	struct ib_conn *ib_conn = &iser_task->iser_conn->ib_conn;
 +	struct iser_device *device = ib_conn->device;
 +	struct ib_device *ibdev = device->ib_device;
 +	struct iser_data_buf *mem = &iser_task->data[cmd_dir];
 +	struct iser_mem_reg *mem_reg = &iser_task->rdma_reg[cmd_dir];
 +	struct iser_fr_desc *desc = NULL;
  	int err, aligned_len;
  
++<<<<<<< HEAD
 +	aligned_len = iser_data_buf_aligned_len(mem, ibdev);
++=======
+ 	aligned_len = iser_data_buf_aligned_len(mem, device->ib_device,
+ 						iser_conn->scsi_sg_tablesize);
++>>>>>>> df749cdc45d9 (IB/iser: Support up to 8MB data transfer in a single command)
  	if (aligned_len != mem->dma_nents) {
 -		err = fall_to_bounce_buf(task, mem, dir);
 -		if (err)
 +		err = fall_to_bounce_buf(iser_task, mem, cmd_dir);
 +		if (err) {
 +			iser_err("failed to allocate bounce buffer\n");
  			return err;
 +		}
  	}
  
 -	return 0;
 -}
 -
 -static int
 -iser_reg_prot_sg(struct iscsi_iser_task *task,
 -		 struct iser_data_buf *mem,
 -		 struct iser_fr_desc *desc,
 -		 struct iser_mem_reg *reg)
 -{
 -	struct iser_device *device = task->iser_conn->ib_conn.device;
 -
 -	if (mem->dma_nents == 1)
 -		return iser_reg_dma(device, mem, reg);
 -
 -	return device->reg_ops->reg_mem(task, mem, &desc->pi_ctx->rsc, reg);
 -}
 -
 -static int
 -iser_reg_data_sg(struct iscsi_iser_task *task,
 -		 struct iser_data_buf *mem,
 -		 struct iser_fr_desc *desc,
 -		 struct iser_mem_reg *reg)
 -{
 -	struct iser_device *device = task->iser_conn->ib_conn.device;
 -
 -	if (mem->dma_nents == 1)
 -		return iser_reg_dma(device, mem, reg);
 -
 -	return device->reg_ops->reg_mem(task, mem, &desc->rsc, reg);
 -}
 -
 -int iser_reg_rdma_mem(struct iscsi_iser_task *task,
 -		      enum iser_data_dir dir)
 -{
 -	struct ib_conn *ib_conn = &task->iser_conn->ib_conn;
 -	struct iser_device *device = ib_conn->device;
 -	struct iser_data_buf *mem = &task->data[dir];
 -	struct iser_mem_reg *reg = &task->rdma_reg[dir];
 -	struct iser_fr_desc *desc = NULL;
 -	int err;
 -
 -	err = iser_handle_unaligned_buf(task, mem, dir);
 -	if (unlikely(err))
 -		return err;
 -
  	if (mem->dma_nents != 1 ||
 -	    scsi_get_prot_op(task->sc) != SCSI_PROT_NORMAL) {
 +	    scsi_get_prot_op(iser_task->sc) != SCSI_PROT_NORMAL) {
  		desc = device->reg_ops->reg_desc_get(ib_conn);
 -		reg->mem_h = desc;
 +		mem_reg->mem_h = desc;
  	}
  
 -	err = iser_reg_data_sg(task, mem, desc, reg);
 -	if (unlikely(err))
 +	err = iser_fast_reg_mr(iser_task, mem,
 +			       desc ? &desc->rsc : NULL, mem_reg);
 +	if (err)
  		goto err_reg;
  
 -	if (scsi_get_prot_op(task->sc) != SCSI_PROT_NORMAL) {
 +	if (scsi_get_prot_op(iser_task->sc) != SCSI_PROT_NORMAL) {
  		struct iser_mem_reg prot_reg;
  
  		memset(&prot_reg, 0, sizeof(prot_reg));
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.c
diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.h b/drivers/infiniband/ulp/iser/iscsi_iser.h
index b9dc02d4dd14..e1c9484b2db7 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@ -98,8 +98,13 @@
 #define SHIFT_4K	12
 #define SIZE_4K	(1ULL << SHIFT_4K)
 #define MASK_4K	(~(SIZE_4K-1))
-					/* support up to 512KB in one RDMA */
-#define ISCSI_ISER_SG_TABLESIZE         (0x80000 >> SHIFT_4K)
+
+/* Default support is 512KB I/O size */
+#define ISER_DEF_MAX_SECTORS		1024
+#define ISCSI_ISER_DEF_SG_TABLESIZE	((ISER_DEF_MAX_SECTORS * 512) >> SHIFT_4K)
+/* Maximum support is 8MB I/O size */
+#define ISCSI_ISER_MAX_SG_TABLESIZE	((16384 * 512) >> SHIFT_4K)
+
 #define ISER_DEF_XMIT_CMDS_DEFAULT		512
 #if ISCSI_DEF_XMIT_CMDS_MAX > ISER_DEF_XMIT_CMDS_DEFAULT
 	#define ISER_DEF_XMIT_CMDS_MAX		ISCSI_DEF_XMIT_CMDS_MAX
@@ -501,6 +506,8 @@ struct ib_conn {
  * @rx_desc_head:     head of rx_descs cyclic buffer
  * @rx_descs:         rx buffers array (cyclic buffer)
  * @num_rx_descs:     number of rx descriptors
+ * @scsi_sg_tablesize: scsi host sg_tablesize
+ * @scsi_max_sectors: scsi host max sectors
  */
 struct iser_conn {
 	struct ib_conn		     ib_conn;
@@ -525,6 +532,8 @@ struct iser_conn {
 	unsigned int 		     rx_desc_head;
 	struct iser_rx_desc	     *rx_descs;
 	u32                          num_rx_descs;
+	unsigned short               scsi_sg_tablesize;
+	unsigned int                 scsi_max_sectors;
 };
 
 /**
@@ -580,6 +589,7 @@ extern struct iser_global ig;
 extern int iser_debug_level;
 extern bool iser_pi_enable;
 extern int iser_pi_guard;
+extern unsigned int iser_max_sectors;
 
 int iser_assign_reg_ops(struct iser_device *device);
 
diff --git a/drivers/infiniband/ulp/iser/iser_initiator.c b/drivers/infiniband/ulp/iser/iser_initiator.c
index b4fc12cb9eaa..b4bf966a811b 100644
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@ -261,7 +261,7 @@ int iser_alloc_rx_descriptors(struct iser_conn *iser_conn,
 	iser_conn->min_posted_rx = iser_conn->qp_max_recv_dtos >> 2;
 
 	if (device->reg_ops->alloc_reg_res(ib_conn, session->scsi_cmds_max,
-					   ISCSI_ISER_SG_TABLESIZE + 1))
+					   iser_conn->scsi_sg_tablesize))
 		goto create_rdma_reg_res_failed;
 
 	if (iser_alloc_login_buf(iser_conn))
* Unmerged path drivers/infiniband/ulp/iser/iser_memory.c
diff --git a/drivers/infiniband/ulp/iser/iser_verbs.c b/drivers/infiniband/ulp/iser/iser_verbs.c
index 3c2e44e4edb0..45fd566c27b1 100644
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@ -757,6 +757,31 @@ static void iser_connect_error(struct rdma_cm_id *cma_id)
 	iser_conn->state = ISER_CONN_TERMINATING;
 }
 
+static void
+iser_calc_scsi_params(struct iser_conn *iser_conn,
+		      unsigned int max_sectors)
+{
+	struct iser_device *device = iser_conn->ib_conn.device;
+	unsigned short sg_tablesize, sup_sg_tablesize;
+
+	sg_tablesize = DIV_ROUND_UP(max_sectors * 512, SIZE_4K);
+	sup_sg_tablesize = min_t(unsigned, ISCSI_ISER_MAX_SG_TABLESIZE,
+				 device->dev_attr.max_fast_reg_page_list_len);
+
+	if (sg_tablesize > sup_sg_tablesize) {
+		sg_tablesize = sup_sg_tablesize;
+		iser_conn->scsi_max_sectors = sg_tablesize * SIZE_4K / 512;
+	} else {
+		iser_conn->scsi_max_sectors = max_sectors;
+	}
+
+	iser_conn->scsi_sg_tablesize = sg_tablesize;
+
+	iser_dbg("iser_conn %p, sg_tablesize %u, max_sectors %u\n",
+		 iser_conn, iser_conn->scsi_sg_tablesize,
+		 iser_conn->scsi_max_sectors);
+}
+
 /**
  * Called with state mutex held
  **/
@@ -795,6 +820,8 @@ static void iser_addr_handler(struct rdma_cm_id *cma_id)
 		}
 	}
 
+	iser_calc_scsi_params(iser_conn, iser_max_sectors);
+
 	ret = rdma_resolve_route(cma_id, 1000);
 	if (ret) {
 		iser_err("resolve route failed: %d\n", ret);
