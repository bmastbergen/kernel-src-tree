sd: Fix rw_max for devices that report an optimal xfer size

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Martin K. Petersen <martin.petersen@oracle.com>
commit 6b7e9cde49691e04314342b7dce90c67ad567fcc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6b7e9cde.failed

For historic reasons, io_opt is in bytes and max_sectors in block layer
sectors. This interface inconsistency is error prone and should be
fixed. But for 4.4--4.7 let's make the unit difference explicit via a
wrapper function.

Fixes: d0eb20a863ba ("sd: Optimal I/O size is in bytes, not sectors")
	Cc: stable@vger.kernel.org # 4.4+
	Reported-by: Fam Zheng <famz@redhat.com>
	Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Tested-by: Andrew Patterson <andrew.patterson@hpe.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 6b7e9cde49691e04314342b7dce90c67ad567fcc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/sd.c
#	drivers/scsi/sd.h
diff --cc drivers/scsi/sd.c
index e75d112f871d,60bff78e9ead..000000000000
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@@ -2898,13 -2852,31 +2898,34 @@@ static int sd_revalidate_disk(struct ge
  	 */
  	sd_set_flush_flag(sdkp);
  
 -	/* Initial block count limit based on CDB TRANSFER LENGTH field size. */
 -	dev_max = sdp->use_16_for_rw ? SD_MAX_XFER_BLOCKS : SD_DEF_XFER_BLOCKS;
 +	max_xfer = sdkp->max_xfer_blocks;
 +	max_xfer <<= ilog2(sdp->sector_size) - 9;
  
 -	/* Some devices report a maximum block count for READ/WRITE requests. */
 -	dev_max = min_not_zero(dev_max, sdkp->max_xfer_blocks);
 -	q->limits.max_dev_sectors = logical_to_sectors(sdp, dev_max);
 +	sdkp->disk->queue->limits.max_sectors =
 +		min_not_zero(queue_max_hw_sectors(sdkp->disk->queue), max_xfer);
  
++<<<<<<< HEAD
 +	set_capacity(disk, sdkp->capacity);
++=======
+ 	/*
+ 	 * Use the device's preferred I/O size for reads and writes
+ 	 * unless the reported value is unreasonably small, large, or
+ 	 * garbage.
+ 	 */
+ 	if (sdkp->opt_xfer_blocks &&
+ 	    sdkp->opt_xfer_blocks <= dev_max &&
+ 	    sdkp->opt_xfer_blocks <= SD_DEF_XFER_BLOCKS &&
+ 	    logical_to_bytes(sdp, sdkp->opt_xfer_blocks) >= PAGE_SIZE) {
+ 		q->limits.io_opt = logical_to_bytes(sdp, sdkp->opt_xfer_blocks);
+ 		rw_max = logical_to_sectors(sdp, sdkp->opt_xfer_blocks);
+ 	} else
+ 		rw_max = BLK_DEF_MAX_SECTORS;
+ 
+ 	/* Combine with controller limits */
+ 	q->limits.max_sectors = min(rw_max, queue_max_hw_sectors(q));
+ 
+ 	set_capacity(disk, logical_to_sectors(sdp, sdkp->capacity));
++>>>>>>> 6b7e9cde4969 (sd: Fix rw_max for devices that report an optimal xfer size)
  	sd_config_write_same(sdkp);
  	kfree(buffer);
  
diff --cc drivers/scsi/sd.h
index ec5c656025d2,765a6f1ac1b7..000000000000
--- a/drivers/scsi/sd.h
+++ b/drivers/scsi/sd.h
@@@ -157,6 -146,16 +157,19 @@@ static inline int scsi_medium_access_co
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static inline sector_t logical_to_sectors(struct scsi_device *sdev, sector_t blocks)
+ {
+ 	return blocks << (ilog2(sdev->sector_size) - 9);
+ }
+ 
+ static inline unsigned int logical_to_bytes(struct scsi_device *sdev, sector_t blocks)
+ {
+ 	return blocks * sdev->sector_size;
+ }
+ 
++>>>>>>> 6b7e9cde4969 (sd: Fix rw_max for devices that report an optimal xfer size)
  /*
   * A DIF-capable target device can be formatted with different
   * protection schemes.  Currently 0 through 3 are defined:
* Unmerged path drivers/scsi/sd.c
* Unmerged path drivers/scsi/sd.h
