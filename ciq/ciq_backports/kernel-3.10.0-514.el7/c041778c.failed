cfg80211: fix proto in ieee80211_data_to_8023 for frames without LLC header

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Felix Fietkau <nbd@nbd.name>
commit c041778c966c92c964033f1cdfee60a9f2b5e465
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c041778c.failed

The PDU length of incoming LLC frames is set to the total skb payload size
in __ieee80211_data_to_8023() of net/wireless/util.c which incorrectly
includes the length of the IEEE 802.11 header.

The resulting LLC frame header has a too large PDU length, causing the
llc_fixup_skb() function of net/llc/llc_input.c to reject the incoming
skb, effectively breaking STP.

Solve the problem by properly substracting the IEEE 802.11 frame header size
from the PDU length, allowing the LLC processor to pick up the incoming
control messages.

Special thanks to Gerry Rozema for tracking down the regression and proposing
a suitable patch.

Fixes: 2d1c304cb2d5 ("cfg80211: add function for 802.3 conversion with separate output buffer")
	Cc: stable@vger.kernel.org
	Reported-by: Gerry Rozema <gerryr@rozeware.com>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
	Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
(cherry picked from commit c041778c966c92c964033f1cdfee60a9f2b5e465)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/wireless/util.c
diff --cc net/wireless/util.c
index 7e4e3fffe7ce,2443ee30ba5b..000000000000
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@@ -498,33 -498,33 +498,39 @@@ int ieee80211_data_to_8023(struct sk_bu
  		break;
  	}
  
 -	skb_copy_bits(skb, hdrlen, &payload, sizeof(payload));
 -	tmp.h_proto = payload.proto;
 +	if (!pskb_may_pull(skb, hdrlen + 8))
 +		return -1;
 +
 +	payload = skb->data + hdrlen;
 +	ethertype = (payload[6] << 8) | payload[7];
  
 -	if (likely((ether_addr_equal(payload.hdr, rfc1042_header) &&
 -		    tmp.h_proto != htons(ETH_P_AARP) &&
 -		    tmp.h_proto != htons(ETH_P_IPX)) ||
 -		   ether_addr_equal(payload.hdr, bridge_tunnel_header)))
 +	if (likely((ether_addr_equal(payload, rfc1042_header) &&
 +		    ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
 +		   ether_addr_equal(payload, bridge_tunnel_header))) {
  		/* remove RFC1042 or Bridge-Tunnel encapsulation and
  		 * replace EtherType */
++<<<<<<< HEAD
 +		skb_pull(skb, hdrlen + 6);
 +		memcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);
 +		memcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);
 +	} else {
 +		struct ethhdr *ehdr;
 +		__be16 len;
++=======
+ 		hdrlen += ETH_ALEN + 2;
+ 	else
+ 		tmp.h_proto = htons(skb->len - hdrlen);
++>>>>>>> c041778c966c (cfg80211: fix proto in ieee80211_data_to_8023 for frames without LLC header)
  
 -	pskb_pull(skb, hdrlen);
 -
 -	if (!ehdr)
 +		skb_pull(skb, hdrlen);
 +		len = htons(skb->len);
  		ehdr = (struct ethhdr *) skb_push(skb, sizeof(struct ethhdr));
 -	memcpy(ehdr, &tmp, sizeof(tmp));
 -
 +		memcpy(ehdr->h_dest, dst, ETH_ALEN);
 +		memcpy(ehdr->h_source, src, ETH_ALEN);
 +		ehdr->h_proto = len;
 +	}
  	return 0;
  }
 -
 -int ieee80211_data_to_8023(struct sk_buff *skb, const u8 *addr,
 -			   enum nl80211_iftype iftype)
 -{
 -	return __ieee80211_data_to_8023(skb, NULL, addr, iftype);
 -}
  EXPORT_SYMBOL(ieee80211_data_to_8023);
  
  int ieee80211_data_from_8023(struct sk_buff *skb, const u8 *addr,
* Unmerged path net/wireless/util.c
