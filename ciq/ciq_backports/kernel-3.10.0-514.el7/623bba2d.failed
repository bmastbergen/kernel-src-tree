IB/hfi1: Remove module presence check outside pre-LNI checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Easwar Hariharan <easwar.hariharan@intel.com>
commit 623bba2d92a32572e21758a17718eeec65594f7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/623bba2d.failed

The pre-LNI SerDes and channel tuning algorithm already checks for
module presence assertion for the relevant port types. The extraneous
check removed in this patch blocks link up for port types for which
the module presence assertion is not relevant.

	Reviewed-by: Dean Luick <dean.luick@intel.com>
	Signed-off-by: Easwar Hariharan <easwar.hariharan@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 623bba2d92a32572e21758a17718eeec65594f7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/chip.c
#	drivers/staging/rdma/hfi1/platform.c
diff --cc drivers/staging/hfi1/chip.c
index 689fb76865d1,38c0e9726cee..000000000000
--- a/drivers/staging/hfi1/chip.c
+++ b/drivers/staging/hfi1/chip.c
@@@ -6857,12 -6845,16 +6857,20 @@@ void handle_link_down(struct work_struc
  	/* disable the port */
  	clear_rcvctrl(ppd->dd, RCV_CTRL_RCV_PORT_ENABLE_SMASK);
  
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +	/* If there is no cable attached, turn the DC off. Otherwise,
 +	 * start the link bring up. */
 +	if (!qsfp_mod_present(ppd))
++=======
+ 	/*
+ 	 * If there is no cable attached, turn the DC off. Otherwise,
+ 	 * start the link bring up.
+ 	 */
+ 	if (ppd->port_type == PORT_TYPE_QSFP && !qsfp_mod_present(ppd)) {
++>>>>>>> 623bba2d92a3 (IB/hfi1: Remove module presence check outside pre-LNI checks):drivers/staging/rdma/hfi1/chip.c
  		dc_shutdown(ppd->dd);
 -	} else {
 -		tune_serdes(ppd);
 +	else
  		start_link(ppd);
 -	}
  }
  
  void handle_link_bounce(struct work_struct *work)
@@@ -9035,18 -9027,50 +9043,22 @@@ int start_link(struct hfi1_pportdata *p
  		return 0;
  	}
  
 -	return set_link_state(ppd, HLS_DN_POLL);
 -}
 -
 -static void wait_for_qsfp_init(struct hfi1_pportdata *ppd)
 -{
 -	struct hfi1_devdata *dd = ppd->dd;
 -	u64 mask;
 -	unsigned long timeout;
 -
 -	/*
 -	 * Check for QSFP interrupt for t_init (SFF 8679)
 -	 */
 -	timeout = jiffies + msecs_to_jiffies(2000);
 -	while (1) {
 -		mask = read_csr(dd, dd->hfi1_id ?
 -				ASIC_QSFP2_IN : ASIC_QSFP1_IN);
 -		if (!(mask & QSFP_HFI0_INT_N)) {
 -			write_csr(dd, dd->hfi1_id ? ASIC_QSFP2_CLEAR :
 -				  ASIC_QSFP1_CLEAR, QSFP_HFI0_INT_N);
 -			break;
 -		}
 -		if (time_after(jiffies, timeout)) {
 -			dd_dev_info(dd, "%s: No IntN detected, reset complete\n",
 -				    __func__);
 -			break;
 -		}
 -		udelay(2);
 -	}
 -}
 -
 -static void set_qsfp_int_n(struct hfi1_pportdata *ppd, u8 enable)
 -{
 -	struct hfi1_devdata *dd = ppd->dd;
 -	u64 mask;
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +	if (qsfp_mod_present(ppd) || loopback == LOOPBACK_SERDES ||
 +			loopback == LOOPBACK_LCB ||
 +			ppd->dd->icode == ICODE_FUNCTIONAL_SIMULATOR)
 +		return set_link_state(ppd, HLS_DN_POLL);
  
 -	mask = read_csr(dd, dd->hfi1_id ? ASIC_QSFP2_MASK : ASIC_QSFP1_MASK);
 -	if (enable)
 -		mask |= (u64)QSFP_HFI0_INT_N;
 -	else
 -		mask &= ~(u64)QSFP_HFI0_INT_N;
 -	write_csr(dd, dd->hfi1_id ? ASIC_QSFP2_MASK : ASIC_QSFP1_MASK, mask);
 +	dd_dev_info(ppd->dd,
 +		"%s: stopping link start because no cable is present\n",
 +		__func__);
 +	return -EAGAIN;
++=======
++	return set_link_state(ppd, HLS_DN_POLL);
++>>>>>>> 623bba2d92a3 (IB/hfi1: Remove module presence check outside pre-LNI checks):drivers/staging/rdma/hfi1/chip.c
  }
  
 -void reset_qsfp(struct hfi1_pportdata *ppd)
 +static void reset_qsfp(struct hfi1_pportdata *ppd)
  {
  	struct hfi1_devdata *dd = ppd->dd;
  	u64 mask, qsfp_mask;
@@@ -9183,35 -9198,8 +9195,40 @@@ static int handle_qsfp_error_conditions
  	return 0;
  }
  
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +static int do_pre_lni_host_behaviors(struct hfi1_pportdata *ppd)
 +{
 +	refresh_qsfp_cache(ppd, &ppd->qsfp_info);
 +
 +	return 0;
 +}
 +
 +static int do_qsfp_intr_fallback(struct hfi1_pportdata *ppd)
 +{
 +	struct hfi1_devdata *dd = ppd->dd;
 +	u8 qsfp_interrupt_status = 0;
 +
 +	if (qsfp_read(ppd, dd->hfi1_id, 2, &qsfp_interrupt_status, 1)
 +		!= 1) {
 +		dd_dev_info(dd,
 +			"%s: Failed to read status of QSFP module\n",
 +			__func__);
 +		return -EIO;
 +	}
 +
 +	/* We don't care about alarms & warnings with a non-functional INT_N */
 +	if (!(qsfp_interrupt_status & QSFP_DATA_NOT_READY))
 +		do_pre_lni_host_behaviors(ppd);
 +
 +	return 0;
 +}
 +
 +/* This routine will only be scheduled if the QSFP module is present */
 +static void qsfp_event(struct work_struct *work)
++=======
+ /* This routine will only be scheduled if the QSFP module present is asserted */
+ void qsfp_event(struct work_struct *work)
++>>>>>>> 623bba2d92a3 (IB/hfi1: Remove module presence check outside pre-LNI checks):drivers/staging/rdma/hfi1/chip.c
  {
  	struct qsfp_data *qd;
  	struct hfi1_pportdata *ppd;
* Unmerged path drivers/staging/rdma/hfi1/platform.c
* Unmerged path drivers/staging/hfi1/chip.c
* Unmerged path drivers/staging/rdma/hfi1/platform.c
