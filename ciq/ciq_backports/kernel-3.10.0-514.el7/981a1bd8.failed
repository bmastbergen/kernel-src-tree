hv_netvsc: use single existing drop path in netvsc_start_xmit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 981a1bd85a959bb3b44e07c212ebc61c62ad7cf9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/981a1bd8.failed

... which validly uses dev_kfree_skb_any() instead of dev_kfree_skb().

Setting ret to -EFAULT and -ENOMEM have no real meaning here (we need to set
it to anything but -EAGAIN) as we drop the packet and return NETDEV_TX_OK
anyway.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 981a1bd85a959bb3b44e07c212ebc61c62ad7cf9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index f6bc78f79972,9e4230d81ac0..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -393,27 -396,32 +393,42 @@@ static int netvsc_start_xmit(struct sk_
  	num_data_pgs = netvsc_get_slots(skb) + 2;
  	if (num_data_pgs > MAX_PAGE_BUFFER_COUNT) {
  		netdev_err(net, "Packet too big: %u\n", skb->len);
- 		dev_kfree_skb(skb);
- 		net->stats.tx_dropped++;
- 		return NETDEV_TX_OK;
+ 		ret = -EFAULT;
+ 		goto drop;
  	}
  
 -	pkt_sz = sizeof(struct hv_netvsc_packet) + RNDIS_AND_PPI_SIZE;
 -
 +	/* Allocate a netvsc packet based on # of frags. */
 +	packet = kzalloc(sizeof(struct hv_netvsc_packet) +
 +			 (num_data_pgs * sizeof(struct hv_page_buffer)) +
 +			 sizeof(struct rndis_message) +
 +			 NDIS_VLAN_PPI_SIZE + NDIS_CSUM_PPI_SIZE +
 +			 NDIS_LSO_PPI_SIZE + NDIS_HASH_PPI_SIZE, GFP_ATOMIC);
 +	if (!packet) {
 +		/* out of memory, drop packet */
 +		netdev_err(net, "unable to allocate hv_netvsc_packet\n");
 +
++<<<<<<< HEAD
 +		dev_kfree_skb(skb);
 +		net->stats.tx_dropped++;
 +		return NETDEV_TX_OK;
++=======
+ 	if (head_room < pkt_sz) {
+ 		packet = kmalloc(pkt_sz, GFP_ATOMIC);
+ 		if (!packet) {
+ 			/* out of memory, drop packet */
+ 			netdev_err(net, "unable to alloc hv_netvsc_packet\n");
+ 			ret = -ENOMEM;
+ 			goto drop;
+ 		}
+ 		packet->part_of_skb = false;
+ 	} else {
+ 		/* Use the headroom for building up the packet */
+ 		packet = (struct hv_netvsc_packet *)skb->head;
+ 		packet->part_of_skb = true;
++>>>>>>> 981a1bd85a95 (hv_netvsc: use single existing drop path in netvsc_start_xmit)
  	}
  
 -	packet->status = 0;
 -	packet->xmit_more = skb->xmit_more;
 -
  	packet->vlan_tci = skb->vlan_tci;
 -	packet->page_buf = page_buf;
  
  	packet->q_idx = skb_get_queue_mapping(skb);
  
@@@ -563,7 -572,8 +578,12 @@@ drop
  		net->stats.tx_bytes += skb_length;
  		net->stats.tx_packets++;
  	} else {
++<<<<<<< HEAD
 +		kfree(packet);
++=======
+ 		if (packet && !packet->part_of_skb)
+ 			kfree(packet);
++>>>>>>> 981a1bd85a95 (hv_netvsc: use single existing drop path in netvsc_start_xmit)
  		if (ret != -EAGAIN) {
  			dev_kfree_skb_any(skb);
  			net->stats.tx_dropped++;
* Unmerged path drivers/net/hyperv/netvsc_drv.c
