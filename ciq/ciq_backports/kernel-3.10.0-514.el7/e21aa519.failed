mmc: core: Export mmc_get_ext_csd()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ulf Hansson <ulf.hansson@linaro.org>
commit e21aa519ee3667d0fabda5d806cc68826e9899e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e21aa519.failed

Callers of mmc_send_ext_csd() will be able to decrease code duplication
by using mmc_get_ext_csd() instead. Let's make it available.

	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit e21aa519ee3667d0fabda5d806cc68826e9899e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/mmc.c
diff --cc drivers/mmc/core/mmc.c
index c3e6ecc69da0,02ad79229f65..000000000000
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@@ -177,64 -177,6 +177,67 @@@ static int mmc_decode_csd(struct mmc_ca
  	return 0;
  }
  
++<<<<<<< HEAD
 +/*
 + * Read extended CSD.
 + */
 +static int mmc_get_ext_csd(struct mmc_card *card, u8 **new_ext_csd)
 +{
 +	int err;
 +	u8 *ext_csd;
 +
 +	BUG_ON(!card);
 +	BUG_ON(!new_ext_csd);
 +
 +	*new_ext_csd = NULL;
 +
 +	if (card->csd.mmca_vsn < CSD_SPEC_VER_4)
 +		return 0;
 +
 +	/*
 +	 * As the ext_csd is so large and mostly unused, we don't store the
 +	 * raw block in mmc_card.
 +	 */
 +	ext_csd = kmalloc(512, GFP_KERNEL);
 +	if (!ext_csd)
 +		return -ENOMEM;
 +
 +	err = mmc_send_ext_csd(card, ext_csd);
 +	if (err) {
 +		kfree(ext_csd);
 +		*new_ext_csd = NULL;
 +
 +		/* If the host or the card can't do the switch,
 +		 * fail more gracefully. */
 +		if ((err != -EINVAL)
 +		 && (err != -ENOSYS)
 +		 && (err != -EFAULT))
 +			return err;
 +
 +		/*
 +		 * High capacity cards should have this "magic" size
 +		 * stored in their CSD.
 +		 */
 +		if (card->csd.capacity == (4096 * 512)) {
 +			pr_err("%s: unable to read EXT_CSD "
 +				"on a possible high capacity card. "
 +				"Card will be ignored.\n",
 +				mmc_hostname(card->host));
 +		} else {
 +			pr_warning("%s: unable to read "
 +				"EXT_CSD, performance might "
 +				"suffer.\n",
 +				mmc_hostname(card->host));
 +			err = 0;
 +		}
 +	} else
 +		*new_ext_csd = ext_csd;
 +
 +	return err;
 +}
 +
++=======
++>>>>>>> e21aa519ee36 (mmc: core: Export mmc_get_ext_csd())
  static void mmc_select_card_type(struct mmc_card *card)
  {
  	struct mmc_host *host = card->host;
* Unmerged path drivers/mmc/core/mmc.c
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index ba0275e90617..4c75605850e1 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -385,6 +385,35 @@ int mmc_send_ext_csd(struct mmc_card *card, u8 *ext_csd)
 }
 EXPORT_SYMBOL_GPL(mmc_send_ext_csd);
 
+int mmc_get_ext_csd(struct mmc_card *card, u8 **new_ext_csd)
+{
+	int err;
+	u8 *ext_csd;
+
+	if (!card || !new_ext_csd)
+		return -EINVAL;
+
+	if (!mmc_can_ext_csd(card))
+		return -EOPNOTSUPP;
+
+	/*
+	 * As the ext_csd is so large and mostly unused, we don't store the
+	 * raw block in mmc_card.
+	 */
+	ext_csd = kmalloc(512, GFP_KERNEL);
+	if (!ext_csd)
+		return -ENOMEM;
+
+	err = mmc_send_ext_csd(card, ext_csd);
+	if (err)
+		kfree(ext_csd);
+	else
+		*new_ext_csd = ext_csd;
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(mmc_get_ext_csd);
+
 int mmc_spi_read_ocr(struct mmc_host *host, int highcap, u32 *ocrp)
 {
 	struct mmc_command cmd = {0};
diff --git a/include/linux/mmc/core.h b/include/linux/mmc/core.h
index f206e29f94d7..0a77d3567c27 100644
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@ -155,6 +155,7 @@ extern int __mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int, bool,
 			bool, bool);
 extern int mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int);
 extern int mmc_send_ext_csd(struct mmc_card *card, u8 *ext_csd);
+extern int mmc_get_ext_csd(struct mmc_card *card, u8 **new_ext_csd);
 
 #define MMC_ERASE_ARG		0x00000000
 #define MMC_SECURE_ERASE_ARG	0x80000000
