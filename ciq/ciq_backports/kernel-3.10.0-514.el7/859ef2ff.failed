mei: me: d0i3: add d0i3 enter/exit state machine

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit 859ef2ffbfa785d273567467088cc8743f80b5bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/859ef2ff.failed

Rework mei power gating state machine to support entry and exit to and
from D0i3 power state.
The choice between legacy and D0i3 routines is conditioned on
d0i3_supported flag.

The patch introduces warning:
drivers/misc/mei/hw-me.c:901:12: warning: ‘mei_me_d0i3_enter’ defined but not used [-Wunused-function]
it will go away in consequent patch

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 859ef2ffbfa785d273567467088cc8743f80b5bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/hbm.c
#	drivers/misc/mei/hbm.h
#	drivers/misc/mei/hw-me.c
diff --cc drivers/misc/mei/hbm.c
index 3cb8e1000d69,8eec887c8f70..000000000000
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@@ -658,7 -880,80 +658,84 @@@ static int mei_hbm_fw_disconnect_req(st
  }
  
  /**
++<<<<<<< HEAD
 + * mei_hbm_config_features: check what hbm features and commands
++=======
+  * mei_hbm_pg_enter_res - PG enter response received
+  *
+  * @dev: the device structure.
+  *
+  * Return: 0 on success, -EPROTO on state mismatch
+  */
+ static int mei_hbm_pg_enter_res(struct mei_device *dev)
+ {
+ 	if (mei_pg_state(dev) != MEI_PG_OFF ||
+ 	    dev->pg_event != MEI_PG_EVENT_WAIT) {
+ 		dev_err(dev->dev, "hbm: pg entry response: state mismatch [%s, %d]\n",
+ 			mei_pg_state_str(mei_pg_state(dev)), dev->pg_event);
+ 		return -EPROTO;
+ 	}
+ 
+ 	dev->pg_event = MEI_PG_EVENT_RECEIVED;
+ 	wake_up(&dev->wait_pg);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * mei_hbm_pg_resume - process with PG resume
+  *
+  * @dev: the device structure.
+  */
+ void mei_hbm_pg_resume(struct mei_device *dev)
+ {
+ 	pm_request_resume(dev->dev);
+ }
+ EXPORT_SYMBOL_GPL(mei_hbm_pg_resume);
+ 
+ /**
+  * mei_hbm_pg_exit_res - PG exit response received
+  *
+  * @dev: the device structure.
+  *
+  * Return: 0 on success, -EPROTO on state mismatch
+  */
+ static int mei_hbm_pg_exit_res(struct mei_device *dev)
+ {
+ 	if (mei_pg_state(dev) != MEI_PG_ON ||
+ 	    (dev->pg_event != MEI_PG_EVENT_WAIT &&
+ 	     dev->pg_event != MEI_PG_EVENT_IDLE)) {
+ 		dev_err(dev->dev, "hbm: pg exit response: state mismatch [%s, %d]\n",
+ 			mei_pg_state_str(mei_pg_state(dev)), dev->pg_event);
+ 		return -EPROTO;
+ 	}
+ 
+ 	switch (dev->pg_event) {
+ 	case MEI_PG_EVENT_WAIT:
+ 		dev->pg_event = MEI_PG_EVENT_RECEIVED;
+ 		wake_up(&dev->wait_pg);
+ 		break;
+ 	case MEI_PG_EVENT_IDLE:
+ 		/*
+ 		* If the driver is not waiting on this then
+ 		* this is HW initiated exit from PG.
+ 		* Start runtime pm resume sequence to exit from PG.
+ 		*/
+ 		dev->pg_event = MEI_PG_EVENT_RECEIVED;
+ 		mei_hbm_pg_resume(dev);
+ 		break;
+ 	default:
+ 		WARN(1, "hbm: pg exit response: unexpected pg event = %d\n",
+ 		     dev->pg_event);
+ 		return -EPROTO;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * mei_hbm_config_features - check what hbm features and commands
++>>>>>>> 859ef2ffbfa7 (mei: me: d0i3: add d0i3 enter/exit state machine)
   *        are supported by the fw
   *
   * @dev: the device structure
diff --cc drivers/misc/mei/hbm.h
index 09d8e7e9a365,a2025a5083a3..000000000000
--- a/drivers/misc/mei/hbm.h
+++ b/drivers/misc/mei/hbm.h
@@@ -63,6 -54,9 +63,12 @@@ int mei_hbm_cl_disconnect_rsp(struct me
  int mei_hbm_cl_connect_req(struct mei_device *dev, struct mei_cl *cl);
  bool mei_hbm_version_is_supported(struct mei_device *dev);
  int mei_hbm_pg(struct mei_device *dev, u8 pg_cmd);
++<<<<<<< HEAD
++=======
+ void mei_hbm_pg_resume(struct mei_device *dev);
+ int mei_hbm_cl_notify_req(struct mei_device *dev,
+ 			  struct mei_cl *cl, u8 request);
++>>>>>>> 859ef2ffbfa7 (mei: me: d0i3: add d0i3 enter/exit state machine)
  
  #endif /* _MEI_HBM_H_ */
  
diff --cc drivers/misc/mei/hw-me.c
index 1707fa5ea02a,bce465546158..000000000000
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@@ -94,13 -130,73 +94,75 @@@ static inline u32 mei_hcsr_read(const s
   * and ignores the H_IS bit for it is write-one-to-zero.
   *
   * @dev: the device structure
 - * @reg: new register value
   */
 -static inline void mei_hcsr_set(struct mei_device *dev, u32 reg)
 +static inline void mei_hcsr_set(struct mei_me_hw *hw, u32 hcsr)
  {
 -	reg &= ~H_CSR_IS_MASK;
 -	mei_hcsr_write(dev, reg);
 +	hcsr &= ~H_IS;
 +	mei_me_reg_write(hw, H_CSR, hcsr);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * mei_me_d0i3c_read - Reads 32bit data from the D0I3C register
+  *
+  * @dev: the device structure
+  *
+  * Return: H_D0I3C register value (u32)
+  */
+ static inline u32 mei_me_d0i3c_read(const struct mei_device *dev)
+ {
+ 	u32 reg;
+ 
+ 	reg = mei_me_reg_read(to_me_hw(dev), H_D0I3C);
+ 	trace_mei_reg_read(dev->dev, "H_D0I3C", H_CSR, reg);
+ 
+ 	return reg;
+ }
+ 
+ /**
+  * mei_me_d0i3c_write - writes H_D0I3C register to device
+  *
+  * @dev: the device structure
+  * @reg: new register value
+  */
+ static inline void mei_me_d0i3c_write(struct mei_device *dev, u32 reg)
+ {
+ 	trace_mei_reg_write(dev->dev, "H_D0I3C", H_CSR, reg);
+ 	mei_me_reg_write(to_me_hw(dev), H_D0I3C, reg);
+ }
+ 
+ /**
+  * mei_me_fw_status - read fw status register from pci config space
+  *
+  * @dev: mei device
+  * @fw_status: fw status register values
+  *
+  * Return: 0 on success, error otherwise
+  */
+ static int mei_me_fw_status(struct mei_device *dev,
+ 			    struct mei_fw_status *fw_status)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev->dev);
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 	const struct mei_fw_status *fw_src = &hw->cfg->fw_status;
+ 	int ret;
+ 	int i;
+ 
+ 	if (!fw_status)
+ 		return -EINVAL;
+ 
+ 	fw_status->count = fw_src->count;
+ 	for (i = 0; i < fw_src->count && i < MEI_FW_STATUS_MAX; i++) {
+ 		ret = pci_read_config_dword(pdev,
+ 			fw_src->status[i], &fw_status->status[i]);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
++>>>>>>> 859ef2ffbfa7 (mei: me: d0i3: add d0i3 enter/exit state machine)
  
  /**
   * mei_me_hw_config - configure hw dependent settings
@@@ -498,13 -638,13 +560,21 @@@ static void mei_me_pg_exit(struct mei_d
  }
  
  /**
++<<<<<<< HEAD
 + * mei_me_pg_set_sync - perform pg entry procedure
++=======
+  * mei_me_pg_legacy_enter_sync - perform legacy pg entry procedure
++>>>>>>> 859ef2ffbfa7 (mei: me: d0i3: add d0i3 enter/exit state machine)
   *
   * @dev: the device structure
   *
 - * Return: 0 on success an error code otherwise
 + * returns 0 on success an error code otherwise
   */
++<<<<<<< HEAD
 +int mei_me_pg_set_sync(struct mei_device *dev)
++=======
+ static int mei_me_pg_legacy_enter_sync(struct mei_device *dev)
++>>>>>>> 859ef2ffbfa7 (mei: me: d0i3: add d0i3 enter/exit state machine)
  {
  	struct mei_me_hw *hw = to_me_hw(dev);
  	unsigned long timeout = mei_secs_to_jiffies(MEI_PGI_TIMEOUT);
@@@ -535,13 -675,13 +605,21 @@@
  }
  
  /**
++<<<<<<< HEAD
 + * mei_me_pg_unset_sync - perform pg exit procedure
++=======
+  * mei_me_pg_legacy_exit_sync - perform legacy pg exit procedure
++>>>>>>> 859ef2ffbfa7 (mei: me: d0i3: add d0i3 enter/exit state machine)
   *
   * @dev: the device structure
   *
 - * Return: 0 on success an error code otherwise
 + * returns 0 on success an error code otherwise
   */
++<<<<<<< HEAD
 +int mei_me_pg_unset_sync(struct mei_device *dev)
++=======
+ static int mei_me_pg_legacy_exit_sync(struct mei_device *dev)
++>>>>>>> 859ef2ffbfa7 (mei: me: d0i3: add d0i3 enter/exit state machine)
  {
  	struct mei_me_hw *hw = to_me_hw(dev);
  	unsigned long timeout = mei_secs_to_jiffies(MEI_PGI_TIMEOUT);
@@@ -581,7 -750,10 +659,14 @@@ reply
  static bool mei_me_pg_is_enabled(struct mei_device *dev)
  {
  	struct mei_me_hw *hw = to_me_hw(dev);
++<<<<<<< HEAD
 +	u32 reg = mei_me_reg_read(hw, ME_CSR_HA);
++=======
+ 	u32 reg = mei_me_mecsr_read(dev);
++>>>>>>> 859ef2ffbfa7 (mei: me: d0i3: add d0i3 enter/exit state machine)
+ 
+ 	if (hw->d0i3_supported)
+ 		return true;
  
  	if ((reg & ME_PGIC_HRA) == 0)
  		goto notsupported;
@@@ -592,7 -764,8 +677,12 @@@
  	return true;
  
  notsupported:
++<<<<<<< HEAD
 +	dev_dbg(&dev->pdev->dev, "pg: not supported: HGP = %d hbm version %d.%d ?= %d.%d\n",
++=======
+ 	dev_dbg(dev->dev, "pg: not supported: d0i3 = %d HGP = %d hbm version %d.%d ?= %d.%d\n",
+ 		hw->d0i3_supported,
++>>>>>>> 859ef2ffbfa7 (mei: me: d0i3: add d0i3 enter/exit state machine)
  		!!(reg & ME_PGIC_HRA),
  		dev->version.major_version,
  		dev->version.minor_version,
@@@ -603,6 -776,313 +693,316 @@@
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mei_me_d0i3_set - write d0i3 register bit on mei device.
+  *
+  * @dev: the device structure
+  * @intr: ask for interrupt
+  *
+  * Return: D0I3C register value
+  */
+ static u32 mei_me_d0i3_set(struct mei_device *dev, bool intr)
+ {
+ 	u32 reg = mei_me_d0i3c_read(dev);
+ 
+ 	reg |= H_D0I3C_I3;
+ 	if (intr)
+ 		reg |= H_D0I3C_IR;
+ 	else
+ 		reg &= ~H_D0I3C_IR;
+ 	mei_me_d0i3c_write(dev, reg);
+ 	/* read it to ensure HW consistency */
+ 	reg = mei_me_d0i3c_read(dev);
+ 	return reg;
+ }
+ 
+ /**
+  * mei_me_d0i3_unset - clean d0i3 register bit on mei device.
+  *
+  * @dev: the device structure
+  *
+  * Return: D0I3C register value
+  */
+ static u32 mei_me_d0i3_unset(struct mei_device *dev)
+ {
+ 	u32 reg = mei_me_d0i3c_read(dev);
+ 
+ 	reg &= ~H_D0I3C_I3;
+ 	reg |= H_D0I3C_IR;
+ 	mei_me_d0i3c_write(dev, reg);
+ 	/* read it to ensure HW consistency */
+ 	reg = mei_me_d0i3c_read(dev);
+ 	return reg;
+ }
+ 
+ /**
+  * mei_me_d0i3_enter_sync - perform d0i3 entry procedure
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ static int mei_me_d0i3_enter_sync(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 	unsigned long d0i3_timeout = mei_secs_to_jiffies(MEI_D0I3_TIMEOUT);
+ 	unsigned long pgi_timeout = mei_secs_to_jiffies(MEI_PGI_TIMEOUT);
+ 	int ret;
+ 	u32 reg;
+ 
+ 	reg = mei_me_d0i3c_read(dev);
+ 	if (reg & H_D0I3C_I3) {
+ 		/* we are in d0i3, nothing to do */
+ 		dev_dbg(dev->dev, "d0i3 set not needed\n");
+ 		ret = 0;
+ 		goto on;
+ 	}
+ 
+ 	/* PGI entry procedure */
+ 	dev->pg_event = MEI_PG_EVENT_WAIT;
+ 
+ 	ret = mei_hbm_pg(dev, MEI_PG_ISOLATION_ENTRY_REQ_CMD);
+ 	if (ret)
+ 		/* FIXME: should we reset here? */
+ 		goto out;
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 	wait_event_timeout(dev->wait_pg,
+ 		dev->pg_event == MEI_PG_EVENT_RECEIVED, pgi_timeout);
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (dev->pg_event != MEI_PG_EVENT_RECEIVED) {
+ 		ret = -ETIME;
+ 		goto out;
+ 	}
+ 	/* end PGI entry procedure */
+ 
+ 	dev->pg_event = MEI_PG_EVENT_INTR_WAIT;
+ 
+ 	reg = mei_me_d0i3_set(dev, true);
+ 	if (!(reg & H_D0I3C_CIP)) {
+ 		dev_dbg(dev->dev, "d0i3 enter wait not needed\n");
+ 		ret = 0;
+ 		goto on;
+ 	}
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 	wait_event_timeout(dev->wait_pg,
+ 		dev->pg_event == MEI_PG_EVENT_INTR_RECEIVED, d0i3_timeout);
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (dev->pg_event != MEI_PG_EVENT_INTR_RECEIVED) {
+ 		reg = mei_me_d0i3c_read(dev);
+ 		if (!(reg & H_D0I3C_I3)) {
+ 			ret = -ETIME;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	ret = 0;
+ on:
+ 	hw->pg_state = MEI_PG_ON;
+ out:
+ 	dev->pg_event = MEI_PG_EVENT_IDLE;
+ 	dev_dbg(dev->dev, "d0i3 enter ret = %d\n", ret);
+ 	return ret;
+ }
+ 
+ /**
+  * mei_me_d0i3_enter - perform d0i3 entry procedure
+  *   no hbm PG handshake
+  *   no waiting for confirmation; runs with interrupts
+  *   disabled
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ static int mei_me_d0i3_enter(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 	u32 reg;
+ 
+ 	reg = mei_me_d0i3c_read(dev);
+ 	if (reg & H_D0I3C_I3) {
+ 		/* we are in d0i3, nothing to do */
+ 		dev_dbg(dev->dev, "already d0i3 : set not needed\n");
+ 		goto on;
+ 	}
+ 
+ 	mei_me_d0i3_set(dev, false);
+ on:
+ 	hw->pg_state = MEI_PG_ON;
+ 	dev->pg_event = MEI_PG_EVENT_IDLE;
+ 	dev_dbg(dev->dev, "d0i3 enter\n");
+ 	return 0;
+ }
+ 
+ /**
+  * mei_me_d0i3_exit_sync - perform d0i3 exit procedure
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ static int mei_me_d0i3_exit_sync(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 	unsigned long timeout = mei_secs_to_jiffies(MEI_D0I3_TIMEOUT);
+ 	int ret;
+ 	u32 reg;
+ 
+ 	dev->pg_event = MEI_PG_EVENT_INTR_WAIT;
+ 
+ 	reg = mei_me_d0i3c_read(dev);
+ 	if (!(reg & H_D0I3C_I3)) {
+ 		/* we are not in d0i3, nothing to do */
+ 		dev_dbg(dev->dev, "d0i3 exit not needed\n");
+ 		ret = 0;
+ 		goto off;
+ 	}
+ 
+ 	reg = mei_me_d0i3_unset(dev);
+ 	if (!(reg & H_D0I3C_CIP)) {
+ 		dev_dbg(dev->dev, "d0i3 exit wait not needed\n");
+ 		ret = 0;
+ 		goto off;
+ 	}
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 	wait_event_timeout(dev->wait_pg,
+ 		dev->pg_event == MEI_PG_EVENT_INTR_RECEIVED, timeout);
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (dev->pg_event != MEI_PG_EVENT_INTR_RECEIVED) {
+ 		reg = mei_me_d0i3c_read(dev);
+ 		if (reg & H_D0I3C_I3) {
+ 			ret = -ETIME;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	ret = 0;
+ off:
+ 	hw->pg_state = MEI_PG_OFF;
+ out:
+ 	dev->pg_event = MEI_PG_EVENT_IDLE;
+ 
+ 	dev_dbg(dev->dev, "d0i3 exit ret = %d\n", ret);
+ 	return ret;
+ }
+ 
+ /**
+  * mei_me_pg_legacy_intr - perform legacy pg processing
+  *			   in interrupt thread handler
+  *
+  * @dev: the device structure
+  */
+ static void mei_me_pg_legacy_intr(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 
+ 	if (dev->pg_event != MEI_PG_EVENT_INTR_WAIT)
+ 		return;
+ 
+ 	dev->pg_event = MEI_PG_EVENT_INTR_RECEIVED;
+ 	hw->pg_state = MEI_PG_OFF;
+ 	if (waitqueue_active(&dev->wait_pg))
+ 		wake_up(&dev->wait_pg);
+ }
+ 
+ /**
+  * mei_me_d0i3_intr - perform d0i3 processing in interrupt thread handler
+  *
+  * @dev: the device structure
+  */
+ static void mei_me_d0i3_intr(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 
+ 	if (dev->pg_event == MEI_PG_EVENT_INTR_WAIT &&
+ 	    (hw->intr_source & H_D0I3C_IS)) {
+ 		dev->pg_event = MEI_PG_EVENT_INTR_RECEIVED;
+ 		if (hw->pg_state == MEI_PG_ON) {
+ 			hw->pg_state = MEI_PG_OFF;
+ 			if (dev->hbm_state != MEI_HBM_IDLE) {
+ 				/*
+ 				 * force H_RDY because it could be
+ 				 * wiped off during PG
+ 				 */
+ 				dev_dbg(dev->dev, "d0i3 set host ready\n");
+ 				mei_me_host_set_ready(dev);
+ 			}
+ 		} else {
+ 			hw->pg_state = MEI_PG_ON;
+ 		}
+ 
+ 		wake_up(&dev->wait_pg);
+ 	}
+ 
+ 	if (hw->pg_state == MEI_PG_ON && (hw->intr_source & H_IS)) {
+ 		/*
+ 		 * HW sent some data and we are in D0i3, so
+ 		 * we got here because of HW initiated exit from D0i3.
+ 		 * Start runtime pm resume sequence to exit low power state.
+ 		 */
+ 		dev_dbg(dev->dev, "d0i3 want resume\n");
+ 		mei_hbm_pg_resume(dev);
+ 	}
+ }
+ 
+ /**
+  * mei_me_pg_intr - perform pg processing in interrupt thread handler
+  *
+  * @dev: the device structure
+  */
+ static void mei_me_pg_intr(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 
+ 	if (hw->d0i3_supported)
+ 		mei_me_d0i3_intr(dev);
+ 	else
+ 		mei_me_pg_legacy_intr(dev);
+ }
+ 
+ /**
+  * mei_me_pg_enter_sync - perform runtime pm entry procedure
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ int mei_me_pg_enter_sync(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 
+ 	if (hw->d0i3_supported)
+ 		return mei_me_d0i3_enter_sync(dev);
+ 	else
+ 		return mei_me_pg_legacy_enter_sync(dev);
+ }
+ 
+ /**
+  * mei_me_pg_exit_sync - perform runtime pm exit procedure
+  *
+  * @dev: the device structure
+  *
+  * Return: 0 on success an error code otherwise
+  */
+ int mei_me_pg_exit_sync(struct mei_device *dev)
+ {
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 
+ 	if (hw->d0i3_supported)
+ 		return mei_me_d0i3_exit_sync(dev);
+ 	else
+ 		return mei_me_pg_legacy_exit_sync(dev);
+ }
+ 
+ /**
++>>>>>>> 859ef2ffbfa7 (mei: me: d0i3: add d0i3 enter/exit state machine)
   * mei_me_irq_quick_handler - The ISR of the MEI device
   *
   * @irq: The irq number
* Unmerged path drivers/misc/mei/hbm.c
* Unmerged path drivers/misc/mei/hbm.h
* Unmerged path drivers/misc/mei/hw-me.c
diff --git a/drivers/misc/mei/hw.h b/drivers/misc/mei/hw.h
index 50526f92f092..4ecadd20a2e1 100644
--- a/drivers/misc/mei/hw.h
+++ b/drivers/misc/mei/hw.h
@@ -31,8 +31,9 @@
 #define MEI_IAMTHIF_STALL_TIMER    12  /* HPS */
 #define MEI_IAMTHIF_READ_TIMER     10  /* HPS */
 
-#define MEI_PGI_TIMEOUT            1  /* PG Isolation time response 1 sec */
-#define MEI_HBM_TIMEOUT            1   /* 1 second */
+#define MEI_PGI_TIMEOUT             1  /* PG Isolation time response 1 sec */
+#define MEI_D0I3_TIMEOUT            5  /* D0i3 set/unset max response time */
+#define MEI_HBM_TIMEOUT             1  /* 1 second */
 
 /*
  * MEI Version
