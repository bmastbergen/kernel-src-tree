netdev: remove potentially harmful checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Veaceslav Falico <vfalico@redhat.com>
commit 6859e7df6d9045a461412777e63bd8cef12f9705
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6859e7df.failed

Currently we're checking a variable for != NULL after actually
dereferencing it, in netdev_lower_get_next_private*().

It's counter-intuitive at best, and can lead to faulty usage (as it implies
that the variable can be NULL), so fix it by removing the useless checks.

	Reported-by: Daniel Borkmann <dborkman@redhat.com>
CC: "David S. Miller" <davem@davemloft.net>
CC: Eric Dumazet <edumazet@google.com>
CC: Nicolas Dichtel <nicolas.dichtel@6wind.com>
CC: Jiri Pirko <jiri@resnulli.us>
CC: stephen hemminger <stephen@networkplumber.org>
CC: Jerry Chu <hkchu@google.com>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6859e7df6d9045a461412777e63bd8cef12f9705)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/dev.c
diff --cc net/core/dev.c
index ce5758e98847,14dac0654f28..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -4690,7 -4566,83 +4690,87 @@@ struct net_device *netdev_upper_get_nex
  
  	return upper->dev;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(netdev_upper_get_next_dev_rcu);
++=======
+ EXPORT_SYMBOL(netdev_all_upper_get_next_dev_rcu);
+ 
+ /**
+  * netdev_lower_get_next_private - Get the next ->private from the
+  *				   lower neighbour list
+  * @dev: device
+  * @iter: list_head ** of the current position
+  *
+  * Gets the next netdev_adjacent->private from the dev's lower neighbour
+  * list, starting from iter position. The caller must hold either hold the
+  * RTNL lock or its own locking that guarantees that the neighbour lower
+  * list will remain unchainged.
+  */
+ void *netdev_lower_get_next_private(struct net_device *dev,
+ 				    struct list_head **iter)
+ {
+ 	struct netdev_adjacent *lower;
+ 
+ 	lower = list_entry(*iter, struct netdev_adjacent, list);
+ 
+ 	if (&lower->list == &dev->adj_list.lower)
+ 		return NULL;
+ 
+ 	*iter = lower->list.next;
+ 
+ 	return lower->private;
+ }
+ EXPORT_SYMBOL(netdev_lower_get_next_private);
+ 
+ /**
+  * netdev_lower_get_next_private_rcu - Get the next ->private from the
+  *				       lower neighbour list, RCU
+  *				       variant
+  * @dev: device
+  * @iter: list_head ** of the current position
+  *
+  * Gets the next netdev_adjacent->private from the dev's lower neighbour
+  * list, starting from iter position. The caller must hold RCU read lock.
+  */
+ void *netdev_lower_get_next_private_rcu(struct net_device *dev,
+ 					struct list_head **iter)
+ {
+ 	struct netdev_adjacent *lower;
+ 
+ 	WARN_ON_ONCE(!rcu_read_lock_held());
+ 
+ 	lower = list_entry_rcu((*iter)->next, struct netdev_adjacent, list);
+ 
+ 	if (&lower->list == &dev->adj_list.lower)
+ 		return NULL;
+ 
+ 	*iter = &lower->list;
+ 
+ 	return lower->private;
+ }
+ EXPORT_SYMBOL(netdev_lower_get_next_private_rcu);
+ 
+ /**
+  * netdev_lower_get_first_private_rcu - Get the first ->private from the
+  *				       lower neighbour list, RCU
+  *				       variant
+  * @dev: device
+  *
+  * Gets the first netdev_adjacent->private from the dev's lower neighbour
+  * list. The caller must hold RCU read lock.
+  */
+ void *netdev_lower_get_first_private_rcu(struct net_device *dev)
+ {
+ 	struct netdev_adjacent *lower;
+ 
+ 	lower = list_first_or_null_rcu(&dev->adj_list.lower,
+ 			struct netdev_adjacent, list);
+ 	if (lower)
+ 		return lower->private;
+ 	return NULL;
+ }
+ EXPORT_SYMBOL(netdev_lower_get_first_private_rcu);
++>>>>>>> 6859e7df6d90 (netdev: remove potentially harmful checks)
  
  /**
   * netdev_master_upper_dev_get_rcu - Get master upper device
* Unmerged path net/core/dev.c
