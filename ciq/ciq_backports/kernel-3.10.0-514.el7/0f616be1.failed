mm: change __get_vm_area_node() to use fls_long()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mm] change __get_vm_area_node() to use fls_long() (Eric Sandeen) [1274459]
Rebuild_FUZZ: 95.74%
commit-author Toshi Kani <toshi.kani@hp.com>
commit 0f616be120c632c818faaea9adcb8f05a7a8601f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0f616be1.failed

ioremap() and its related interfaces are used to create I/O mappings to
memory-mapped I/O devices.  The mapping sizes of the traditional I/O
devices are relatively small.  Non-volatile memory (NVM), however, has
many GB and is going to have TB soon.  It is not very efficient to create
large I/O mappings with 4KB.

This patchset extends the ioremap() interfaces to transparently create I/O
mappings with huge pages whenever possible.  ioremap() continues to use
4KB mappings when a huge page does not fit into a requested range.  There
is no change necessary to the drivers using ioremap().  A requested
physical address must be aligned by a huge page size (1GB or 2MB on x86)
for using huge page mapping, though.  The kernel huge I/O mapping will
improve performance of NVM and other devices with large memory, and reduce
the time to create their mappings as well.

On x86, MTRRs can override PAT memory types with a 4KB granularity.  When
using a huge page, MTRRs can override the memory type of the huge page,
which may lead a performance penalty.  The processor can also behave in an
undefined manner if a huge page is mapped to a memory range that MTRRs
have mapped with multiple different memory types.  Therefore, the mapping
code falls back to use a smaller page size toward 4KB when a mapping range
is covered by non-WB type of MTRRs.  The WB type of MTRRs has no affect on
the PAT memory types.

The patchset introduces HAVE_ARCH_HUGE_VMAP, which indicates that the arch
supports huge KVA mappings for ioremap().  User may specify a new kernel
option "nohugeiomap" to disable the huge I/O mapping capability of
ioremap() when necessary.

Patch 1-4 change common files to support huge I/O mappings.  There is no
change in the functinalities unless HAVE_ARCH_HUGE_VMAP is defined on the
architecture of the system.

Patch 5-6 implement the HAVE_ARCH_HUGE_VMAP funcs on x86, and set
HAVE_ARCH_HUGE_VMAP on x86.

This patch (of 6):

__get_vm_area_node() takes unsigned long size, which is a 64-bit value on
a 64-bit kernel.  However, fls(size) simply ignores the upper 32-bit.
Change to use fls_long() to handle the size properly.

	Signed-off-by: Toshi Kani <toshi.kani@hp.com>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Dave Hansen <dave.hansen@intel.com>
	Cc: Robert Elliott <Elliott@hp.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0f616be120c632c818faaea9adcb8f05a7a8601f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/vmalloc.c
diff --cc mm/vmalloc.c
index 4381d46d9226,a48cd061f16f..000000000000
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@@ -27,7 -27,10 +27,12 @@@
  #include <linux/pfn.h>
  #include <linux/kmemleak.h>
  #include <linux/atomic.h>
 -#include <linux/compiler.h>
  #include <linux/llist.h>
++<<<<<<< HEAD
++=======
+ #include <linux/bitops.h>
+ 
++>>>>>>> 0f616be120c6 (mm: change __get_vm_area_node() to use fls_long())
  #include <asm/uaccess.h>
  #include <asm/tlbflush.h>
  #include <asm/shmparam.h>
@@@ -1337,16 -1314,9 +1342,22 @@@ static struct vm_struct *__get_vm_area_
  	struct vm_struct *area;
  
  	BUG_ON(in_interrupt());
++<<<<<<< HEAD
 +	if (flags & VM_IOREMAP) {
 +		int bit = fls(size);
 +
 +		if (bit > IOREMAP_MAX_ORDER)
 +			bit = IOREMAP_MAX_ORDER;
 +		else if (bit < PAGE_SHIFT)
 +			bit = PAGE_SHIFT;
 +
 +		align = 1ul << bit;
 +	}
++=======
+ 	if (flags & VM_IOREMAP)
+ 		align = 1ul << clamp_t(int, fls_long(size),
+ 				       PAGE_SHIFT, IOREMAP_MAX_ORDER);
++>>>>>>> 0f616be120c6 (mm: change __get_vm_area_node() to use fls_long())
  
  	size = PAGE_ALIGN(size);
  	if (unlikely(!size))
* Unmerged path mm/vmalloc.c
