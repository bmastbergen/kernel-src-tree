iwlwifi: pcie: enable interrupts before releasing the NIC's CPU

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Emmanuel Grumbach <emmanuel.grumbach@intel.com>
commit 2aabdbdc17b7c53490337bfc58de3409c84d85d2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2aabdbdc.failed

The NIC's CPU gets started after the firmware has been
written to its memory. The first thing it does is to
send an interrupt to let the driver know that it is
running. In order to get that interrupt, the driver needs
to make sure it is not masked. Of course, the interrupt
needs to be enabled in the driver before the CPU starts to
run.
I mistakenly inversed those two steps leading to races
which prevented the driver from getting the alive interrupt
from the firmware.
Fix that.

	Cc: <stable@vger.kernel.org> [4.5+]
Fixes: a6bd005fe92 ("iwlwifi: pcie: fix RF-Kill vs. firmware load race")
	Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
(cherry picked from commit 2aabdbdc17b7c53490337bfc58de3409c84d85d2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/iwlwifi/pcie/trans.c
diff --cc drivers/net/wireless/iwlwifi/pcie/trans.c
index 699a4802835f,ac623c3e3f24..000000000000
--- a/drivers/net/wireless/iwlwifi/pcie/trans.c
+++ b/drivers/net/wireless/iwlwifi/pcie/trans.c
@@@ -1131,14 -1123,154 +1135,145 @@@ static void iwl_trans_pcie_stop_device(
  	iwl_pcie_prepare_card_hw(trans);
  }
  
++<<<<<<< HEAD:drivers/net/wireless/iwlwifi/pcie/trans.c
++=======
+ static void iwl_pcie_synchronize_irqs(struct iwl_trans *trans)
+ {
+ 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
+ 
+ 	if (trans_pcie->msix_enabled) {
+ 		int i;
+ 
+ 		for (i = 0; i < trans_pcie->allocated_vector; i++)
+ 			synchronize_irq(trans_pcie->msix_entries[i].vector);
+ 	} else {
+ 		synchronize_irq(trans_pcie->pci_dev->irq);
+ 	}
+ }
+ 
+ static int iwl_trans_pcie_start_fw(struct iwl_trans *trans,
+ 				   const struct fw_img *fw, bool run_in_rfkill)
+ {
+ 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
+ 	bool hw_rfkill;
+ 	int ret;
+ 
+ 	/* This may fail if AMT took ownership of the device */
+ 	if (iwl_pcie_prepare_card_hw(trans)) {
+ 		IWL_WARN(trans, "Exit HW not ready\n");
+ 		ret = -EIO;
+ 		goto out;
+ 	}
+ 
+ 	iwl_enable_rfkill_int(trans);
+ 
+ 	iwl_write32(trans, CSR_INT, 0xFFFFFFFF);
+ 
+ 	/*
+ 	 * We enabled the RF-Kill interrupt and the handler may very
+ 	 * well be running. Disable the interrupts to make sure no other
+ 	 * interrupt can be fired.
+ 	 */
+ 	iwl_disable_interrupts(trans);
+ 
+ 	/* Make sure it finished running */
+ 	iwl_pcie_synchronize_irqs(trans);
+ 
+ 	mutex_lock(&trans_pcie->mutex);
+ 
+ 	/* If platform's RF_KILL switch is NOT set to KILL */
+ 	hw_rfkill = iwl_is_rfkill_set(trans);
+ 	if (hw_rfkill)
+ 		set_bit(STATUS_RFKILL, &trans->status);
+ 	else
+ 		clear_bit(STATUS_RFKILL, &trans->status);
+ 	iwl_trans_pcie_rf_kill(trans, hw_rfkill);
+ 	if (hw_rfkill && !run_in_rfkill) {
+ 		ret = -ERFKILL;
+ 		goto out;
+ 	}
+ 
+ 	/* Someone called stop_device, don't try to start_fw */
+ 	if (trans_pcie->is_down) {
+ 		IWL_WARN(trans,
+ 			 "Can't start_fw since the HW hasn't been started\n");
+ 		ret = -EIO;
+ 		goto out;
+ 	}
+ 
+ 	/* make sure rfkill handshake bits are cleared */
+ 	iwl_write32(trans, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);
+ 	iwl_write32(trans, CSR_UCODE_DRV_GP1_CLR,
+ 		    CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);
+ 
+ 	/* clear (again), then enable host interrupts */
+ 	iwl_write32(trans, CSR_INT, 0xFFFFFFFF);
+ 
+ 	ret = iwl_pcie_nic_init(trans);
+ 	if (ret) {
+ 		IWL_ERR(trans, "Unable to init nic\n");
+ 		goto out;
+ 	}
+ 
+ 	/*
+ 	 * Now, we load the firmware and don't want to be interrupted, even
+ 	 * by the RF-Kill interrupt (hence mask all the interrupt besides the
+ 	 * FH_TX interrupt which is needed to load the firmware). If the
+ 	 * RF-Kill switch is toggled, we will find out after having loaded
+ 	 * the firmware and return the proper value to the caller.
+ 	 */
+ 	iwl_enable_fw_load_int(trans);
+ 
+ 	/* really make sure rfkill handshake bits are cleared */
+ 	iwl_write32(trans, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);
+ 	iwl_write32(trans, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);
+ 
+ 	/* Load the given image to the HW */
+ 	if (trans->cfg->device_family == IWL_DEVICE_FAMILY_8000)
+ 		ret = iwl_pcie_load_given_ucode_8000(trans, fw);
+ 	else
+ 		ret = iwl_pcie_load_given_ucode(trans, fw);
+ 
+ 	/* re-check RF-Kill state since we may have missed the interrupt */
+ 	hw_rfkill = iwl_is_rfkill_set(trans);
+ 	if (hw_rfkill)
+ 		set_bit(STATUS_RFKILL, &trans->status);
+ 	else
+ 		clear_bit(STATUS_RFKILL, &trans->status);
+ 
+ 	iwl_trans_pcie_rf_kill(trans, hw_rfkill);
+ 	if (hw_rfkill && !run_in_rfkill)
+ 		ret = -ERFKILL;
+ 
+ out:
+ 	mutex_unlock(&trans_pcie->mutex);
+ 	return ret;
+ }
+ 
+ static void iwl_trans_pcie_fw_alive(struct iwl_trans *trans, u32 scd_addr)
+ {
+ 	iwl_pcie_reset_ict(trans);
+ 	iwl_pcie_tx_start(trans, scd_addr);
+ }
+ 
+ static void iwl_trans_pcie_stop_device(struct iwl_trans *trans, bool low_power)
+ {
+ 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
+ 
+ 	mutex_lock(&trans_pcie->mutex);
+ 	_iwl_trans_pcie_stop_device(trans, low_power);
+ 	mutex_unlock(&trans_pcie->mutex);
+ }
+ 
++>>>>>>> 2aabdbdc17b7 (iwlwifi: pcie: enable interrupts before releasing the NIC's CPU):drivers/net/wireless/intel/iwlwifi/pcie/trans.c
  void iwl_trans_pcie_rf_kill(struct iwl_trans *trans, bool state)
  {
 -	struct iwl_trans_pcie __maybe_unused *trans_pcie =
 -		IWL_TRANS_GET_PCIE_TRANS(trans);
 -
 -	lockdep_assert_held(&trans_pcie->mutex);
 -
  	if (iwl_op_mode_hw_rf_kill(trans->op_mode, state))
 -		_iwl_trans_pcie_stop_device(trans, true);
 +		iwl_trans_pcie_stop_device(trans, true);
  }
  
 -static void iwl_trans_pcie_d3_suspend(struct iwl_trans *trans, bool test,
 -				      bool reset)
 +static void iwl_trans_pcie_d3_suspend(struct iwl_trans *trans, bool test)
  {
 -	if (!reset) {
 -		/* Enable persistence mode to avoid reset */
 -		iwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,
 -			    CSR_HW_IF_CONFIG_REG_PERSIST_MODE);
 -	}
 -
  	iwl_disable_interrupts(trans);
  
  	/*
* Unmerged path drivers/net/wireless/iwlwifi/pcie/trans.c
