net: Find the nesting level of a given device by type.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] Find the nesting level of a given device by type. (Ivan Vecera) [1268334]
Rebuild_FUZZ: 95.15%
commit-author Vlad Yasevich <vyasevic@redhat.com>
commit 4085ebe8c31face855fd01ee40372cb4aab1df3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4085ebe8.failed

Multiple devices in the kernel can be stacked/nested and they
need to know their nesting level for the purposes of lockdep.
This patch provides a generic function that determines a nesting
level of a particular device by its type (ex: vlan, macvlan, etc).
We only care about nesting of the same type of devices.

For example:
  eth0 <- vlan0.10 <- macvlan0 <- vlan1.20

The nesting level of vlan1.20 would be 1, since there is another vlan
in the stack under it.

	Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4085ebe8c31face855fd01ee40372cb4aab1df3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/core/dev.c
diff --cc include/linux/netdevice.h
index 7b10147de03d,fb912e8e5c7f..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -3274,24 -3050,58 +3274,69 @@@ extern int		weight_p
  extern int		bpf_jit_enable;
  
  bool netdev_has_upper_dev(struct net_device *dev, struct net_device *upper_dev);
++<<<<<<< HEAD
 +bool netdev_has_any_upper_dev(struct net_device *dev);
++=======
+ struct net_device *netdev_all_upper_get_next_dev_rcu(struct net_device *dev,
+ 						     struct list_head **iter);
+ 
+ /* iterate through upper list, must be called under RCU read lock */
+ #define netdev_for_each_all_upper_dev_rcu(dev, updev, iter) \
+ 	for (iter = &(dev)->all_adj_list.upper, \
+ 	     updev = netdev_all_upper_get_next_dev_rcu(dev, &(iter)); \
+ 	     updev; \
+ 	     updev = netdev_all_upper_get_next_dev_rcu(dev, &(iter)))
+ 
+ void *netdev_lower_get_next_private(struct net_device *dev,
+ 				    struct list_head **iter);
+ void *netdev_lower_get_next_private_rcu(struct net_device *dev,
+ 					struct list_head **iter);
+ 
+ #define netdev_for_each_lower_private(dev, priv, iter) \
+ 	for (iter = (dev)->adj_list.lower.next, \
+ 	     priv = netdev_lower_get_next_private(dev, &(iter)); \
+ 	     priv; \
+ 	     priv = netdev_lower_get_next_private(dev, &(iter)))
+ 
+ #define netdev_for_each_lower_private_rcu(dev, priv, iter) \
+ 	for (iter = &(dev)->adj_list.lower, \
+ 	     priv = netdev_lower_get_next_private_rcu(dev, &(iter)); \
+ 	     priv; \
+ 	     priv = netdev_lower_get_next_private_rcu(dev, &(iter)))
+ 
+ void *netdev_lower_get_next(struct net_device *dev,
+ 				struct list_head **iter);
+ #define netdev_for_each_lower_dev(dev, ldev, iter) \
+ 	for (iter = &(dev)->adj_list.lower, \
+ 	     ldev = netdev_lower_get_next(dev, &(iter)); \
+ 	     ldev; \
+ 	     ldev = netdev_lower_get_next(dev, &(iter)))
+ 
+ void *netdev_adjacent_get_private(struct list_head *adj_list);
+ void *netdev_lower_get_first_private_rcu(struct net_device *dev);
++>>>>>>> 4085ebe8c31f (net: Find the nesting level of a given device by type.)
  struct net_device *netdev_master_upper_dev_get(struct net_device *dev);
  struct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev);
  int netdev_upper_dev_link(struct net_device *dev, struct net_device *upper_dev);
  int netdev_master_upper_dev_link(struct net_device *dev,
  				 struct net_device *upper_dev);
 -int netdev_master_upper_dev_link_private(struct net_device *dev,
 -					 struct net_device *upper_dev,
 -					 void *private);
  void netdev_upper_dev_unlink(struct net_device *dev,
  			     struct net_device *upper_dev);
 -void netdev_adjacent_rename_links(struct net_device *dev, char *oldname);
 +void *netdev_lower_dev_get_private_rcu(struct net_device *dev,
 +				       struct net_device *lower_dev);
  void *netdev_lower_dev_get_private(struct net_device *dev,
  				   struct net_device *lower_dev);
++<<<<<<< HEAD
 +
 +/* RSS keys are 40 or 52 bytes long */
 +#define NETDEV_RSS_KEY_LEN 52
 +extern u8 netdev_rss_key[NETDEV_RSS_KEY_LEN];
 +void netdev_rss_key_fill(void *buffer, size_t len);
 +
++=======
+ int dev_get_nest_level(struct net_device *dev,
+ 		       bool (*type_check)(struct net_device *dev));
++>>>>>>> 4085ebe8c31f (net: Find the nesting level of a given device by type.)
  int skb_checksum_help(struct sk_buff *skb);
  struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
  				  netdev_features_t features, bool tx_path);
diff --cc net/core/dev.c
index 004e3f31d664,6ee3ac25ed72..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -4629,7 -4565,109 +4629,113 @@@ struct net_device *netdev_upper_get_nex
  
  	return upper->dev;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(netdev_upper_get_next_dev_rcu);
++=======
+ EXPORT_SYMBOL(netdev_all_upper_get_next_dev_rcu);
+ 
+ /**
+  * netdev_lower_get_next_private - Get the next ->private from the
+  *				   lower neighbour list
+  * @dev: device
+  * @iter: list_head ** of the current position
+  *
+  * Gets the next netdev_adjacent->private from the dev's lower neighbour
+  * list, starting from iter position. The caller must hold either hold the
+  * RTNL lock or its own locking that guarantees that the neighbour lower
+  * list will remain unchainged.
+  */
+ void *netdev_lower_get_next_private(struct net_device *dev,
+ 				    struct list_head **iter)
+ {
+ 	struct netdev_adjacent *lower;
+ 
+ 	lower = list_entry(*iter, struct netdev_adjacent, list);
+ 
+ 	if (&lower->list == &dev->adj_list.lower)
+ 		return NULL;
+ 
+ 	*iter = lower->list.next;
+ 
+ 	return lower->private;
+ }
+ EXPORT_SYMBOL(netdev_lower_get_next_private);
+ 
+ /**
+  * netdev_lower_get_next_private_rcu - Get the next ->private from the
+  *				       lower neighbour list, RCU
+  *				       variant
+  * @dev: device
+  * @iter: list_head ** of the current position
+  *
+  * Gets the next netdev_adjacent->private from the dev's lower neighbour
+  * list, starting from iter position. The caller must hold RCU read lock.
+  */
+ void *netdev_lower_get_next_private_rcu(struct net_device *dev,
+ 					struct list_head **iter)
+ {
+ 	struct netdev_adjacent *lower;
+ 
+ 	WARN_ON_ONCE(!rcu_read_lock_held());
+ 
+ 	lower = list_entry_rcu((*iter)->next, struct netdev_adjacent, list);
+ 
+ 	if (&lower->list == &dev->adj_list.lower)
+ 		return NULL;
+ 
+ 	*iter = &lower->list;
+ 
+ 	return lower->private;
+ }
+ EXPORT_SYMBOL(netdev_lower_get_next_private_rcu);
+ 
+ /**
+  * netdev_lower_get_next - Get the next device from the lower neighbour
+  *                         list
+  * @dev: device
+  * @iter: list_head ** of the current position
+  *
+  * Gets the next netdev_adjacent from the dev's lower neighbour
+  * list, starting from iter position. The caller must hold RTNL lock or
+  * its own locking that guarantees that the neighbour lower
+  * list will remain unchainged.
+  */
+ void *netdev_lower_get_next(struct net_device *dev, struct list_head **iter)
+ {
+ 	struct netdev_adjacent *lower;
+ 
+ 	lower = list_entry((*iter)->next, struct netdev_adjacent, list);
+ 
+ 	if (&lower->list == &dev->adj_list.lower)
+ 		return NULL;
+ 
+ 	*iter = &lower->list;
+ 
+ 	return lower->dev;
+ }
+ EXPORT_SYMBOL(netdev_lower_get_next);
+ 
+ /**
+  * netdev_lower_get_first_private_rcu - Get the first ->private from the
+  *				       lower neighbour list, RCU
+  *				       variant
+  * @dev: device
+  *
+  * Gets the first netdev_adjacent->private from the dev's lower neighbour
+  * list. The caller must hold RCU read lock.
+  */
+ void *netdev_lower_get_first_private_rcu(struct net_device *dev)
+ {
+ 	struct netdev_adjacent *lower;
+ 
+ 	lower = list_first_or_null_rcu(&dev->adj_list.lower,
+ 			struct netdev_adjacent, list);
+ 	if (lower)
+ 		return lower->private;
+ 	return NULL;
+ }
+ EXPORT_SYMBOL(netdev_lower_get_first_private_rcu);
++>>>>>>> 4085ebe8c31f (net: Find the nesting level of a given device by type.)
  
  /**
   * netdev_master_upper_dev_get_rcu - Get master upper device
@@@ -4747,6 -5064,64 +4853,67 @@@ void netdev_upper_dev_unlink(struct net
  }
  EXPORT_SYMBOL(netdev_upper_dev_unlink);
  
++<<<<<<< HEAD
++=======
+ void netdev_adjacent_rename_links(struct net_device *dev, char *oldname)
+ {
+ 	struct netdev_adjacent *iter;
+ 
+ 	list_for_each_entry(iter, &dev->adj_list.upper, list) {
+ 		netdev_adjacent_sysfs_del(iter->dev, oldname,
+ 					  &iter->dev->adj_list.lower);
+ 		netdev_adjacent_sysfs_add(iter->dev, dev,
+ 					  &iter->dev->adj_list.lower);
+ 	}
+ 
+ 	list_for_each_entry(iter, &dev->adj_list.lower, list) {
+ 		netdev_adjacent_sysfs_del(iter->dev, oldname,
+ 					  &iter->dev->adj_list.upper);
+ 		netdev_adjacent_sysfs_add(iter->dev, dev,
+ 					  &iter->dev->adj_list.upper);
+ 	}
+ }
+ 
+ void *netdev_lower_dev_get_private(struct net_device *dev,
+ 				   struct net_device *lower_dev)
+ {
+ 	struct netdev_adjacent *lower;
+ 
+ 	if (!lower_dev)
+ 		return NULL;
+ 	lower = __netdev_find_adj(dev, lower_dev, &dev->adj_list.lower);
+ 	if (!lower)
+ 		return NULL;
+ 
+ 	return lower->private;
+ }
+ EXPORT_SYMBOL(netdev_lower_dev_get_private);
+ 
+ 
+ int dev_get_nest_level(struct net_device *dev,
+ 		       bool (*type_check)(struct net_device *dev))
+ {
+ 	struct net_device *lower = NULL;
+ 	struct list_head *iter;
+ 	int max_nest = -1;
+ 	int nest;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	netdev_for_each_lower_dev(dev, lower, iter) {
+ 		nest = dev_get_nest_level(lower, type_check);
+ 		if (max_nest < nest)
+ 			max_nest = nest;
+ 	}
+ 
+ 	if (type_check(dev))
+ 		max_nest++;
+ 
+ 	return max_nest;
+ }
+ EXPORT_SYMBOL(dev_get_nest_level);
+ 
++>>>>>>> 4085ebe8c31f (net: Find the nesting level of a given device by type.)
  static void dev_change_rx_flags(struct net_device *dev, int flags)
  {
  	const struct net_device_ops *ops = dev->netdev_ops;
* Unmerged path include/linux/netdevice.h
* Unmerged path net/core/dev.c
