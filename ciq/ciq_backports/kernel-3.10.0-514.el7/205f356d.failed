vxlan: make vxlan_sock_add and vxlan_sock_release complementary

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 205f356d165033443793a97a668a203a79a8723a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/205f356d.failed

Make vxlan_sock_add both alloc the socket and attach it to vxlan_dev. Let
vxlan_sock_release accept vxlan_dev as its parameter instead of vxlan_sock.

This makes vxlan_sock_add and vxlan_sock release complementary. It reduces
code duplication in the next patch.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 205f356d165033443793a97a668a203a79a8723a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 4e5b7ab9acd0,a86613011977..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -77,6 -74,9 +77,11 @@@ static int vxlan_net_id
  
  static const u8 all_zeros_mac[ETH_ALEN];
  
++<<<<<<< HEAD
++=======
+ static int vxlan_sock_add(struct vxlan_dev *vxlan);
+ 
++>>>>>>> 205f356d1650 (vxlan: make vxlan_sock_add and vxlan_sock_release complementary)
  /* per-network namespace private data for this module */
  struct vxlan_net {
  	struct list_head  vxlan_list;
@@@ -1052,8 -1021,9 +1057,13 @@@ static bool vxlan_group_used(struct vxl
  	return false;
  }
  
++<<<<<<< HEAD
 +void vxlan_sock_release(struct vxlan_sock *vs)
++=======
+ static void vxlan_sock_release(struct vxlan_dev *vxlan)
++>>>>>>> 205f356d1650 (vxlan: make vxlan_sock_add and vxlan_sock_release complementary)
  {
+ 	struct vxlan_sock *vs = vxlan->vn_sock;
  	struct sock *sk = vs->sock->sk;
  	struct net *net = sock_net(sk);
  	struct vxlan_net *vn = net_generic(net, vxlan_net_id);
@@@ -2197,15 -2244,11 +2207,20 @@@ static void vxlan_uninit(struct net_dev
  static int vxlan_open(struct net_device *dev)
  {
  	struct vxlan_dev *vxlan = netdev_priv(dev);
- 	struct vxlan_sock *vs;
- 	int ret = 0;
+ 	int ret;
  
++<<<<<<< HEAD
 +	vs = vxlan_sock_add(vxlan->net, vxlan->dst_port, vxlan_rcv, NULL,
 +			    false, vxlan->flags);
 +	if (IS_ERR(vs))
 +		return PTR_ERR(vs);
 +
 +	vxlan_vs_add_dev(vs, vxlan);
++=======
+ 	ret = vxlan_sock_add(vxlan);
+ 	if (ret < 0)
+ 		return ret;
++>>>>>>> 205f356d1650 (vxlan: make vxlan_sock_add and vxlan_sock_release complementary)
  
  	if (vxlan_addr_multicast(&vxlan->default_dst.remote_ip)) {
  		ret = vxlan_igmp_join(vxlan);
@@@ -2544,33 -2587,33 +2558,53 @@@ static struct vxlan_sock *vxlan_socket_
  	return vs;
  }
  
++<<<<<<< HEAD
 +struct vxlan_sock *vxlan_sock_add(struct net *net, __be16 port,
 +				  vxlan_rcv_t *rcv, void *data,
 +				  bool no_share, u32 flags)
++=======
+ static int vxlan_sock_add(struct vxlan_dev *vxlan)
++>>>>>>> 205f356d1650 (vxlan: make vxlan_sock_add and vxlan_sock_release complementary)
  {
- 	struct vxlan_net *vn = net_generic(net, vxlan_net_id);
- 	struct vxlan_sock *vs;
- 	bool ipv6 = flags & VXLAN_F_IPV6;
+ 	struct vxlan_net *vn = net_generic(vxlan->net, vxlan_net_id);
+ 	struct vxlan_sock *vs = NULL;
+ 	bool ipv6 = vxlan->flags & VXLAN_F_IPV6;
  
- 	if (!no_share) {
+ 	if (!vxlan->cfg.no_share) {
  		spin_lock(&vn->sock_lock);
++<<<<<<< HEAD
 +		vs = vxlan_find_sock(net, ipv6 ? AF_INET6 : AF_INET, port,
 +				     flags);
 +		if (vs && vs->rcv == rcv) {
 +			if (!atomic_add_unless(&vs->refcnt, 1, 0))
 +				vs = ERR_PTR(-EBUSY);
++=======
+ 		vs = vxlan_find_sock(vxlan->net, ipv6 ? AF_INET6 : AF_INET,
+ 				     vxlan->cfg.dst_port, vxlan->flags);
+ 		if (vs && !atomic_add_unless(&vs->refcnt, 1, 0)) {
++>>>>>>> 205f356d1650 (vxlan: make vxlan_sock_add and vxlan_sock_release complementary)
  			spin_unlock(&vn->sock_lock);
- 			return vs;
+ 			return -EBUSY;
  		}
  		spin_unlock(&vn->sock_lock);
  	}
++<<<<<<< HEAD
 +
 +	return vxlan_socket_create(net, port, rcv, data, flags);
++=======
+ 	if (!vs)
+ 		vs = vxlan_socket_create(vxlan->net, vxlan->cfg.dst_port,
+ 					 vxlan->flags);
+ 	if (IS_ERR(vs))
+ 		return PTR_ERR(vs);
+ 	vxlan_vs_add_dev(vs, vxlan);
+ 	return 0;
++>>>>>>> 205f356d1650 (vxlan: make vxlan_sock_add and vxlan_sock_release complementary)
  }
 +EXPORT_SYMBOL_GPL(vxlan_sock_add);
  
 -static int vxlan_dev_configure(struct net *src_net, struct net_device *dev,
 -			       struct vxlan_config *conf)
 +static int vxlan_newlink(struct net *src_net, struct net_device *dev,
 +			 struct nlattr *tb[], struct nlattr *data[])
  {
  	struct vxlan_net *vn = net_generic(src_net, vxlan_net_id);
  	struct vxlan_dev *vxlan = netdev_priv(dev);
* Unmerged path drivers/net/vxlan.c
