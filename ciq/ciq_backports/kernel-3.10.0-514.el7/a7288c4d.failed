net: sctp: improve sctp_select_active_and_retran_path selection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] sctp: improve sctp_select_active_and_retran_path selection (Xin Long) [1333696]
Rebuild_FUZZ: 95.87%
commit-author Daniel Borkmann <dborkman@redhat.com>
commit a7288c4dd5094b3878b7ad817b0cd130a6f8e916
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a7288c4d.failed

In function sctp_select_active_and_retran_path(), we walk the
transport list in order to look for the two most recently used
ACTIVE transports (trans_pri, trans_sec). In case we didn't find
anything ACTIVE, we currently just camp on a possibly PF or
INACTIVE transport that is primary path; this behavior actually
dates back to linux-history tree of the very early days of
lksctp, and can yield a behavior that chooses suboptimal
transport paths.

Instead, be a bit more clever by reusing and extending the
recently introduced sctp_trans_elect_best() handler. In case
both transports are evaluated to have the same score resulting
from their states, break the tie by looking at: 1) transport
patch error count 2) last_time_heard value from each transport.

This is analogous to Nishida's Quick Failover draft [1],
section 5.1, 3:

  The sender SHOULD avoid data transmission to PF destinations.
  When all destinations are in either PF or Inactive state,
  the sender MAY either move the destination from PF to active
  state (and transmit data to the active destination) or the
  sender MAY transmit data to a PF destination. In the former
  scenario, (i) the sender MUST NOT notify the ULP about the
  state transition, and (ii) MUST NOT clear the destination's
  error counter. It is recommended that the sender picks the
  PF destination with least error count (fewest consecutive
  timeouts) for data transmission. In case of a tie (multiple PF
  destinations with same error count), the sender MAY choose the
  last active destination.

Thus for sctp_select_active_and_retran_path(), we keep track of
the best, if any, transport that is in PF state and in case no
ACTIVE transport has been found (hence trans_{pri,sec} is NULL),
we select the best out of the three: current primary_path and
retran_path as well as a possible PF transport.

The secondary may still camp on the original primary_path as
before. The change in sctp_trans_elect_best() with a more fine
grained tie selection also improves at the same time path selection
for sctp_assoc_update_retran_path() in case of non-ACTIVE states.

  [1] http://tools.ietf.org/html/draft-nishida-tsvwg-sctp-failover-05

	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a7288c4dd5094b3878b7ad817b0cd130a6f8e916)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/associola.c
diff --cc net/sctp/associola.c
index 95613ef42a0c,58bbb731fd26..000000000000
--- a/net/sctp/associola.c
+++ b/net/sctp/associola.c
@@@ -1295,72 -1185,193 +1295,188 @@@ void sctp_assoc_update(struct sctp_asso
  }
  
  /* Update the retran path for sending a retransmitted packet.
 - * See also RFC4960, 6.4. Multi-Homed SCTP Endpoints:
 - *
 - *   When there is outbound data to send and the primary path
 - *   becomes inactive (e.g., due to failures), or where the
 - *   SCTP user explicitly requests to send data to an
 - *   inactive destination transport address, before reporting
 - *   an error to its ULP, the SCTP endpoint should try to send
 - *   the data to an alternate active destination transport
 - *   address if one exists.
 - *
 - *   When retransmitting data that timed out, if the endpoint
 - *   is multihomed, it should consider each source-destination
 - *   address pair in its retransmission selection policy.
 - *   When retransmitting timed-out data, the endpoint should
 - *   attempt to pick the most divergent source-destination
 - *   pair from the original source-destination pair to which
 - *   the packet was transmitted.
 - *
 - *   Note: Rules for picking the most divergent source-destination
 - *   pair are an implementation decision and are not specified
 - *   within this document.
 - *
 - * Our basic strategy is to round-robin transports in priorities
 - * according to sctp_state_prio_map[] e.g., if no such
 - * transport with state SCTP_ACTIVE exists, round-robin through
 - * SCTP_UNKNOWN, etc. You get the picture.
 + * Round-robin through the active transports, else round-robin
 + * through the inactive transports as this is the next best thing
 + * we can try.
   */
++<<<<<<< HEAD
++=======
+ static const u8 sctp_trans_state_to_prio_map[] = {
+ 	[SCTP_ACTIVE]	= 3,	/* best case */
+ 	[SCTP_UNKNOWN]	= 2,
+ 	[SCTP_PF]	= 1,
+ 	[SCTP_INACTIVE] = 0,	/* worst case */
+ };
+ 
+ static u8 sctp_trans_score(const struct sctp_transport *trans)
+ {
+ 	return sctp_trans_state_to_prio_map[trans->state];
+ }
+ 
+ static struct sctp_transport *sctp_trans_elect_tie(struct sctp_transport *trans1,
+ 						   struct sctp_transport *trans2)
+ {
+ 	if (trans1->error_count > trans2->error_count) {
+ 		return trans2;
+ 	} else if (trans1->error_count == trans2->error_count &&
+ 		   ktime_after(trans2->last_time_heard,
+ 			       trans1->last_time_heard)) {
+ 		return trans2;
+ 	} else {
+ 		return trans1;
+ 	}
+ }
+ 
+ static struct sctp_transport *sctp_trans_elect_best(struct sctp_transport *curr,
+ 						    struct sctp_transport *best)
+ {
+ 	u8 score_curr, score_best;
+ 
+ 	if (best == NULL)
+ 		return curr;
+ 
+ 	score_curr = sctp_trans_score(curr);
+ 	score_best = sctp_trans_score(best);
+ 
+ 	/* First, try a score-based selection if both transport states
+ 	 * differ. If we're in a tie, lets try to make a more clever
+ 	 * decision here based on error counts and last time heard.
+ 	 */
+ 	if (score_curr > score_best)
+ 		return curr;
+ 	else if (score_curr == score_best)
+ 		return sctp_trans_elect_tie(curr, best);
+ 	else
+ 		return best;
+ }
+ 
++>>>>>>> a7288c4dd509 (net: sctp: improve sctp_select_active_and_retran_path selection)
  void sctp_assoc_update_retran_path(struct sctp_association *asoc)
  {
 -	struct sctp_transport *trans = asoc->peer.retran_path;
 -	struct sctp_transport *trans_next = NULL;
 +	struct sctp_transport *t, *next;
 +	struct list_head *head = &asoc->peer.transport_addr_list;
 +	struct list_head *pos;
  
 -	/* We're done as we only have the one and only path. */
  	if (asoc->peer.transport_count == 1)
  		return;
 -	/* If active_path and retran_path are the same and active,
 -	 * then this is the only active path. Use it.
 -	 */
 -	if (asoc->peer.active_path == asoc->peer.retran_path &&
 -	    asoc->peer.active_path->state == SCTP_ACTIVE)
 -		return;
  
 -	/* Iterate from retran_path's successor back to retran_path. */
 -	for (trans = list_next_entry(trans, transports); 1;
 -	     trans = list_next_entry(trans, transports)) {
 -		/* Manually skip the head element. */
 -		if (&trans->transports == &asoc->peer.transport_addr_list)
 -			continue;
 -		if (trans->state == SCTP_UNCONFIRMED)
 -			continue;
 -		trans_next = sctp_trans_elect_best(trans, trans_next);
 -		/* Active is good enough for immediate return. */
 -		if (trans_next->state == SCTP_ACTIVE)
 +	/* Find the next transport in a round-robin fashion. */
 +	t = asoc->peer.retran_path;
 +	pos = &t->transports;
 +	next = NULL;
 +
 +	while (1) {
 +		/* Skip the head. */
 +		if (pos->next == head)
 +			pos = head->next;
 +		else
 +			pos = pos->next;
 +
 +		t = list_entry(pos, struct sctp_transport, transports);
 +
 +		/* We have exhausted the list, but didn't find any
 +		 * other active transports.  If so, use the next
 +		 * transport.
 +		 */
 +		if (t == asoc->peer.retran_path) {
 +			t = next;
  			break;
 -		/* We've reached the end, time to update path. */
 -		if (trans == asoc->peer.retran_path)
 +		}
 +
 +		/* Try to find an active transport. */
 +
 +		if ((t->state == SCTP_ACTIVE) ||
 +		    (t->state == SCTP_UNKNOWN)) {
  			break;
++<<<<<<< HEAD
 +		} else {
 +			/* Keep track of the next transport in case
 +			 * we don't find any active transport.
 +			 */
 +			if (t->state != SCTP_UNCONFIRMED && !next)
 +				next = t;
++=======
+ 	}
+ 
+ 	asoc->peer.retran_path = trans_next;
+ 
+ 	pr_debug("%s: association:%p updated new path to addr:%pISpc\n",
+ 		 __func__, asoc, &asoc->peer.retran_path->ipaddr.sa);
+ }
+ 
+ static void sctp_select_active_and_retran_path(struct sctp_association *asoc)
+ {
+ 	struct sctp_transport *trans, *trans_pri = NULL, *trans_sec = NULL;
+ 	struct sctp_transport *trans_pf = NULL;
+ 
+ 	/* Look for the two most recently used active transports. */
+ 	list_for_each_entry(trans, &asoc->peer.transport_addr_list,
+ 			    transports) {
+ 		/* Skip uninteresting transports. */
+ 		if (trans->state == SCTP_INACTIVE ||
+ 		    trans->state == SCTP_UNCONFIRMED)
+ 			continue;
+ 		/* Keep track of the best PF transport from our
+ 		 * list in case we don't find an active one.
+ 		 */
+ 		if (trans->state == SCTP_PF) {
+ 			trans_pf = sctp_trans_elect_best(trans, trans_pf);
+ 			continue;
+ 		}
+ 		/* For active transports, pick the most recent ones. */
+ 		if (trans_pri == NULL ||
+ 		    ktime_after(trans->last_time_heard,
+ 				trans_pri->last_time_heard)) {
+ 			trans_sec = trans_pri;
+ 			trans_pri = trans;
+ 		} else if (trans_sec == NULL ||
+ 			   ktime_after(trans->last_time_heard,
+ 				       trans_sec->last_time_heard)) {
+ 			trans_sec = trans;
++>>>>>>> a7288c4dd509 (net: sctp: improve sctp_select_active_and_retran_path selection)
  		}
  	}
  
 -	/* RFC 2960 6.4 Multi-Homed SCTP Endpoints
 -	 *
 -	 * By default, an endpoint should always transmit to the primary
 -	 * path, unless the SCTP user explicitly specifies the
 -	 * destination transport address (and possibly source transport
 -	 * address) to use. [If the primary is active but not most recent,
 -	 * bump the most recently used transport.]
 -	 */
 -	if ((asoc->peer.primary_path->state == SCTP_ACTIVE ||
 -	     asoc->peer.primary_path->state == SCTP_UNKNOWN) &&
 -	     asoc->peer.primary_path != trans_pri) {
 -		trans_sec = trans_pri;
 -		trans_pri = asoc->peer.primary_path;
 -	}
 -
 +	if (t)
 +		asoc->peer.retran_path = t;
 +	else
 +		t = asoc->peer.retran_path;
 +
++<<<<<<< HEAD
 +	SCTP_DEBUG_PRINTK_IPADDR("sctp_assoc_update_retran_path:association"
 +				 " %p addr: ",
 +				 " port: %d\n",
 +				 asoc,
 +				 (&t->ipaddr),
 +				 ntohs(t->ipaddr.v4.sin_port));
++=======
+ 	/* We did not find anything useful for a possible retransmission
+ 	 * path; either primary path that we found is the the same as
+ 	 * the current one, or we didn't generally find an active one.
+ 	 */
+ 	if (trans_sec == NULL)
+ 		trans_sec = trans_pri;
+ 
+ 	/* If we failed to find a usable transport, just camp on the
+ 	 * primary or retran, even if they are inactive, if possible
+ 	 * pick a PF iff it's the better choice.
+ 	 */
+ 	if (trans_pri == NULL) {
+ 		trans_pri = sctp_trans_elect_best(asoc->peer.primary_path,
+ 						  asoc->peer.retran_path);
+ 		trans_pri = sctp_trans_elect_best(trans_pri, trans_pf);
+ 		trans_sec = asoc->peer.primary_path;
+ 	}
+ 
+ 	/* Set the active and retran transports. */
+ 	asoc->peer.active_path = trans_pri;
+ 	asoc->peer.retran_path = trans_sec;
++>>>>>>> a7288c4dd509 (net: sctp: improve sctp_select_active_and_retran_path selection)
  }
  
 -struct sctp_transport *
 -sctp_assoc_choose_alter_transport(struct sctp_association *asoc,
 -				  struct sctp_transport *last_sent_to)
 +/* Choose the transport for sending retransmit packet.  */
 +struct sctp_transport *sctp_assoc_choose_alter_transport(
 +	struct sctp_association *asoc, struct sctp_transport *last_sent_to)
  {
  	/* If this is the first time packet is sent, use the active path,
  	 * else use the retran path. If the last packet was sent over the
* Unmerged path net/sctp/associola.c
