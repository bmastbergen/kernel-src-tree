mmc: dw_mmc: use mmc_regulator_get_supply to handle regulators

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Yuvaraj CD <yuvaraj.cd@gmail.com>
commit 51da2240906cb94e8f6ba55e403b6206df6fb2dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/51da2240.failed

This patch makes use of mmc_regulator_get_supply() to handle
the vmmc and vqmmc regulators.Also it moves the code handling
the these regulators to dw_mci_set_ios().It turned on the vmmc
and vqmmc during MMC_POWER_UP and MMC_POWER_ON,and turned off
during MMC_POWER_OFF.

	Signed-off-by: Yuvaraj Kumar C D <yuvaraj.cd@samsung.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 51da2240906cb94e8f6ba55e403b6206df6fb2dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/dw_mmc.c
diff --cc drivers/mmc/host/dw_mmc.c
index 1add727a3cc5,aadb0d6aa63f..000000000000
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@@ -915,18 -975,38 +916,47 @@@ static void dw_mci_set_ios(struct mmc_h
  
  	switch (ios->power_mode) {
  	case MMC_POWER_UP:
+ 		if (!IS_ERR(mmc->supply.vmmc)) {
+ 			ret = mmc_regulator_set_ocr(mmc, mmc->supply.vmmc,
+ 					ios->vdd);
+ 			if (ret) {
+ 				dev_err(slot->host->dev,
+ 					"failed to enable vmmc regulator\n");
+ 				/*return, if failed turn on vmmc*/
+ 				return;
+ 			}
+ 		}
+ 		if (!IS_ERR(mmc->supply.vqmmc) && !slot->host->vqmmc_enabled) {
+ 			ret = regulator_enable(mmc->supply.vqmmc);
+ 			if (ret < 0)
+ 				dev_err(slot->host->dev,
+ 					"failed to enable vqmmc regulator\n");
+ 			else
+ 				slot->host->vqmmc_enabled = true;
+ 		}
  		set_bit(DW_MMC_CARD_NEED_INIT, &slot->flags);
 +		/* Power up slot */
 +		if (slot->host->pdata->setpower)
 +			slot->host->pdata->setpower(slot->id, mmc->ocr_avail);
  		regs = mci_readl(slot->host, PWREN);
  		regs |= (1 << slot->id);
  		mci_writel(slot->host, PWREN, regs);
  		break;
  	case MMC_POWER_OFF:
++<<<<<<< HEAD
 +		/* Power down slot */
 +		if (slot->host->pdata->setpower)
 +			slot->host->pdata->setpower(slot->id, 0);
++=======
+ 		if (!IS_ERR(mmc->supply.vmmc))
+ 			mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);
+ 
+ 		if (!IS_ERR(mmc->supply.vqmmc) && slot->host->vqmmc_enabled) {
+ 			regulator_disable(mmc->supply.vqmmc);
+ 			slot->host->vqmmc_enabled = false;
+ 		}
+ 
++>>>>>>> 51da2240906c (mmc: dw_mmc: use mmc_regulator_get_supply to handle regulators)
  		regs = mci_readl(slot->host, PWREN);
  		regs &= ~(1 << slot->id);
  		mci_writel(slot->host, PWREN, regs);
@@@ -2013,20 -2128,22 +2043,30 @@@ static int dw_mci_init_slot(struct dw_m
  	slot->quirks = dw_mci_of_get_slot_quirks(host->dev, slot->id);
  
  	mmc->ops = &dw_mci_ops;
 -	if (of_property_read_u32_array(host->dev->of_node,
 -				       "clock-freq-min-max", freq, 2)) {
 -		mmc->f_min = DW_MCI_FREQ_MIN;
 -		mmc->f_max = DW_MCI_FREQ_MAX;
 -	} else {
 -		mmc->f_min = freq[0];
 -		mmc->f_max = freq[1];
 -	}
 +	mmc->f_min = DIV_ROUND_UP(host->bus_hz, 510);
 +	mmc->f_max = host->bus_hz;
 +
++<<<<<<< HEAD
 +	if (host->pdata->get_ocr)
 +		mmc->ocr_avail = host->pdata->get_ocr(id);
 +	else
 +		mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
  
 +	/*
 +	 * Start with slot power disabled, it will be enabled when a card
 +	 * is detected.
 +	 */
 +	if (host->pdata->setpower)
 +		host->pdata->setpower(id, 0);
++=======
+ 	/*if there are external regulators, get them*/
+ 	ret = mmc_regulator_get_supply(mmc);
+ 	if (ret == -EPROBE_DEFER)
+ 		goto err_setup_bus;
+ 
+ 	if (!mmc->ocr_avail)
+ 		mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
++>>>>>>> 51da2240906c (mmc: dw_mmc: use mmc_regulator_get_supply to handle regulators)
  
  	if (host->pdata->caps)
  		mmc->caps = host->pdata->caps;
@@@ -2330,31 -2493,15 +2370,34 @@@ int dw_mci_probe(struct dw_mci *host
  		}
  	}
  
 -	if (drv_data && drv_data->setup_clock) {
 -		ret = drv_data->setup_clock(host);
++<<<<<<< HEAD
 +	host->vmmc = devm_regulator_get(host->dev, "vmmc");
 +	if (IS_ERR(host->vmmc)) {
 +		ret = PTR_ERR(host->vmmc);
 +		if (ret == -EPROBE_DEFER)
 +			goto err_clk_ciu;
 +
 +		dev_info(host->dev, "no vmmc regulator found: %d\n", ret);
 +		host->vmmc = NULL;
 +	} else {
 +		ret = regulator_enable(host->vmmc);
  		if (ret) {
 -			dev_err(host->dev,
 -				"implementation specific clock setup failed\n");
 +			if (ret != -EPROBE_DEFER)
 +				dev_err(host->dev,
 +					"regulator_enable fail: %d\n", ret);
  			goto err_clk_ciu;
  		}
  	}
  
 +	if (!host->bus_hz) {
 +		dev_err(host->dev,
 +			"Platform data must supply bus speed\n");
 +		ret = -ENODEV;
 +		goto err_regulator;
 +	}
 +
++=======
++>>>>>>> 51da2240906c (mmc: dw_mmc: use mmc_regulator_get_supply to handle regulators)
  	host->quirks = host->pdata->quirks;
  
  	spin_lock_init(&host->lock);
@@@ -2496,10 -2645,6 +2539,13 @@@ err_workqueue
  err_dmaunmap:
  	if (host->use_dma && host->dma_ops->exit)
  		host->dma_ops->exit(host);
++<<<<<<< HEAD
 +
 +err_regulator:
 +	if (host->vmmc)
 +		regulator_disable(host->vmmc);
++=======
++>>>>>>> 51da2240906c (mmc: dw_mmc: use mmc_regulator_get_supply to handle regulators)
  
  err_clk_ciu:
  	if (!IS_ERR(host->ciu_clk))
@@@ -2554,26 -2696,6 +2597,29 @@@ EXPORT_SYMBOL(dw_mci_remove)
   */
  int dw_mci_suspend(struct dw_mci *host)
  {
++<<<<<<< HEAD
 +	int i, ret = 0;
 +
 +	for (i = 0; i < host->num_slots; i++) {
 +		struct dw_mci_slot *slot = host->slot[i];
 +		if (!slot)
 +			continue;
 +		ret = mmc_suspend_host(slot->mmc);
 +		if (ret < 0) {
 +			while (--i >= 0) {
 +				slot = host->slot[i];
 +				if (slot)
 +					mmc_resume_host(host->slot[i]->mmc);
 +			}
 +			return ret;
 +		}
 +	}
 +
 +	if (host->vmmc)
 +		regulator_disable(host->vmmc);
 +
++=======
++>>>>>>> 51da2240906c (mmc: dw_mmc: use mmc_regulator_get_supply to handle regulators)
  	return 0;
  }
  EXPORT_SYMBOL(dw_mci_suspend);
@@@ -2582,16 -2704,7 +2628,20 @@@ int dw_mci_resume(struct dw_mci *host
  {
  	int i, ret;
  
++<<<<<<< HEAD
 +	if (host->vmmc) {
 +		ret = regulator_enable(host->vmmc);
 +		if (ret) {
 +			dev_err(host->dev,
 +				"failed to enable regulator: %d\n", ret);
 +			return ret;
 +		}
 +	}
 +
 +	if (!mci_wait_reset(host->dev, host)) {
++=======
+ 	if (!dw_mci_ctrl_reset(host, SDMMC_CTRL_ALL_RESET_FLAGS)) {
++>>>>>>> 51da2240906c (mmc: dw_mmc: use mmc_regulator_get_supply to handle regulators)
  		ret = -ENODEV;
  		return ret;
  	}
* Unmerged path drivers/mmc/host/dw_mmc.c
diff --git a/include/linux/mmc/dw_mmc.h b/include/linux/mmc/dw_mmc.h
index a578603b514c..0fc8898d3f40 100644
--- a/include/linux/mmc/dw_mmc.h
+++ b/include/linux/mmc/dw_mmc.h
@@ -186,7 +186,7 @@ struct dw_mci {
 	/* Workaround flags */
 	u32			quirks;
 
-	struct regulator	*vmmc;	/* Power regulator */
+	bool			vqmmc_enabled;
 	unsigned long		irq_flags; /* IRQ flags */
 	int			irq;
 };
