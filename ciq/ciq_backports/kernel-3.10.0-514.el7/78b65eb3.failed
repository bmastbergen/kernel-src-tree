sunrpc: move rq_dropme flag into rq_flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jeff Layton <jlayton@primarydata.com>
commit 78b65eb3fda95c6d131c4bbb0536e21f0bd7a7d4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/78b65eb3.failed

	Signed-off-by: Jeff Layton <jlayton@primarydata.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 78b65eb3fda95c6d131c4bbb0536e21f0bd7a7d4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/sunrpc/svc.h
#	include/trace/events/sunrpc.h
#	net/sunrpc/svc.c
diff --cc include/linux/sunrpc/svc.h
index 21678464883a,d4ea3e5246b0..000000000000
--- a/include/linux/sunrpc/svc.h
+++ b/include/linux/sunrpc/svc.h
@@@ -253,9 -252,11 +253,17 @@@ struct svc_rqst 
  	u32			rq_vers;	/* program version */
  	u32			rq_proc;	/* procedure number */
  	u32			rq_prot;	/* IP protocol */
++<<<<<<< HEAD
 +	unsigned short
 +				rq_secure  : 1;	/* secure port */
 +	unsigned short		rq_local   : 1;	/* local request */
++=======
+ #define	RQ_SECURE	(0)			/* secure port */
+ #define	RQ_LOCAL	(1)			/* local request */
+ #define	RQ_USEDEFERRAL	(2)			/* use deferral */
+ #define	RQ_DROPME	(3)			/* drop current reply */
+ 	unsigned long		rq_flags;	/* flags field */
++>>>>>>> 78b65eb3fda9 (sunrpc: move rq_dropme flag into rq_flags)
  
  	void *			rq_argp;	/* decoded arguments */
  	void *			rq_resp;	/* xdr'd results */
diff --cc include/trace/events/sunrpc.h
index 6260f5134212,355671f19a9f..000000000000
--- a/include/trace/events/sunrpc.h
+++ b/include/trace/events/sunrpc.h
@@@ -307,6 -308,117 +307,120 @@@ DEFINE_RPC_SOCKET_EVENT_DONE(rpc_socket
  DEFINE_RPC_SOCKET_EVENT(rpc_socket_close);
  DEFINE_RPC_SOCKET_EVENT(rpc_socket_shutdown);
  
++<<<<<<< HEAD
++=======
+ DECLARE_EVENT_CLASS(rpc_xprt_event,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 
+ 	TP_ARGS(xprt, xid, status),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(__be32, xid)
+ 		__field(int, status)
+ 		__string(addr, xprt->address_strings[RPC_DISPLAY_ADDR])
+ 		__string(port, xprt->address_strings[RPC_DISPLAY_PORT])
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->xid = xid;
+ 		__entry->status = status;
+ 		__assign_str(addr, xprt->address_strings[RPC_DISPLAY_ADDR]);
+ 		__assign_str(port, xprt->address_strings[RPC_DISPLAY_PORT]);
+ 	),
+ 
+ 	TP_printk("peer=[%s]:%s xid=0x%x status=%d", __get_str(addr),
+ 			__get_str(port), be32_to_cpu(__entry->xid),
+ 			__entry->status)
+ );
+ 
+ DEFINE_EVENT(rpc_xprt_event, xprt_lookup_rqst,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 	TP_ARGS(xprt, xid, status));
+ 
+ DEFINE_EVENT(rpc_xprt_event, xprt_transmit,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 	TP_ARGS(xprt, xid, status));
+ 
+ DEFINE_EVENT(rpc_xprt_event, xprt_complete_rqst,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 	TP_ARGS(xprt, xid, status));
+ 
+ TRACE_EVENT(xs_tcp_data_ready,
+ 	TP_PROTO(struct rpc_xprt *xprt, int err, unsigned int total),
+ 
+ 	TP_ARGS(xprt, err, total),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, err)
+ 		__field(unsigned int, total)
+ 		__string(addr, xprt ? xprt->address_strings[RPC_DISPLAY_ADDR] :
+ 				"(null)")
+ 		__string(port, xprt ? xprt->address_strings[RPC_DISPLAY_PORT] :
+ 				"(null)")
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->err = err;
+ 		__entry->total = total;
+ 		__assign_str(addr, xprt ?
+ 			xprt->address_strings[RPC_DISPLAY_ADDR] : "(null)");
+ 		__assign_str(port, xprt ?
+ 			xprt->address_strings[RPC_DISPLAY_PORT] : "(null)");
+ 	),
+ 
+ 	TP_printk("peer=[%s]:%s err=%d total=%u", __get_str(addr),
+ 			__get_str(port), __entry->err, __entry->total)
+ );
+ 
+ #define rpc_show_sock_xprt_flags(flags) \
+ 	__print_flags(flags, "|", \
+ 		{ TCP_RCV_LAST_FRAG, "TCP_RCV_LAST_FRAG" }, \
+ 		{ TCP_RCV_COPY_FRAGHDR, "TCP_RCV_COPY_FRAGHDR" }, \
+ 		{ TCP_RCV_COPY_XID, "TCP_RCV_COPY_XID" }, \
+ 		{ TCP_RCV_COPY_DATA, "TCP_RCV_COPY_DATA" }, \
+ 		{ TCP_RCV_READ_CALLDIR, "TCP_RCV_READ_CALLDIR" }, \
+ 		{ TCP_RCV_COPY_CALLDIR, "TCP_RCV_COPY_CALLDIR" }, \
+ 		{ TCP_RPC_REPLY, "TCP_RPC_REPLY" })
+ 
+ TRACE_EVENT(xs_tcp_data_recv,
+ 	TP_PROTO(struct sock_xprt *xs),
+ 
+ 	TP_ARGS(xs),
+ 
+ 	TP_STRUCT__entry(
+ 		__string(addr, xs->xprt.address_strings[RPC_DISPLAY_ADDR])
+ 		__string(port, xs->xprt.address_strings[RPC_DISPLAY_PORT])
+ 		__field(__be32, xid)
+ 		__field(unsigned long, flags)
+ 		__field(unsigned long, copied)
+ 		__field(unsigned int, reclen)
+ 		__field(unsigned long, offset)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__assign_str(addr, xs->xprt.address_strings[RPC_DISPLAY_ADDR]);
+ 		__assign_str(port, xs->xprt.address_strings[RPC_DISPLAY_PORT]);
+ 		__entry->xid = xs->tcp_xid;
+ 		__entry->flags = xs->tcp_flags;
+ 		__entry->copied = xs->tcp_copied;
+ 		__entry->reclen = xs->tcp_reclen;
+ 		__entry->offset = xs->tcp_offset;
+ 	),
+ 
+ 	TP_printk("peer=[%s]:%s xid=0x%x flags=%s copied=%lu reclen=%u offset=%lu",
+ 			__get_str(addr), __get_str(port), be32_to_cpu(__entry->xid),
+ 			rpc_show_sock_xprt_flags(__entry->flags),
+ 			__entry->copied, __entry->reclen, __entry->offset)
+ );
+ 
+ #define show_rqstp_flags(flags)						\
+ 	__print_flags(flags, "|",					\
+ 		{ (1UL << RQ_SECURE),		"RQ_SECURE"},		\
+ 		{ (1UL << RQ_LOCAL),		"RQ_LOCAL"},		\
+ 		{ (1UL << RQ_USEDEFERRAL),	"RQ_USEDEFERRAL"},	\
+ 		{ (1UL << RQ_DROPME),		"RQ_DROPME"})
+ 
++>>>>>>> 78b65eb3fda9 (sunrpc: move rq_dropme flag into rq_flags)
  TRACE_EVENT(svc_recv,
  	TP_PROTO(struct svc_rqst *rqst, int status),
  
@@@ -344,13 -460,13 +458,18 @@@ DECLARE_EVENT_CLASS(svc_rqst_status
  	TP_fast_assign(
  		__entry->addr = (struct sockaddr *)&rqst->rq_addr;
  		__entry->xid = rqst->rq_xid;
- 		__entry->dropme = (int)rqst->rq_dropme;
  		__entry->status = status;
 -		__entry->flags = rqst->rq_flags;
  	),
  
++<<<<<<< HEAD
 +	TP_printk("addr=%pIScp rq_xid=0x%x dropme=%d status=%d",
 +		__entry->addr, be32_to_cpu(__entry->xid), __entry->dropme,
 +		__entry->status)
++=======
+ 	TP_printk("addr=%pIScp rq_xid=0x%x status=%d flags=%s",
+ 		__entry->addr, be32_to_cpu(__entry->xid),
+ 		__entry->status, show_rqstp_flags(__entry->flags))
++>>>>>>> 78b65eb3fda9 (sunrpc: move rq_dropme flag into rq_flags)
  );
  
  DEFINE_EVENT(svc_rqst_status, svc_process,
diff --cc net/sunrpc/svc.c
index 942c67131e18,d8a9d603b786..000000000000
--- a/net/sunrpc/svc.c
+++ b/net/sunrpc/svc.c
@@@ -1090,8 -1090,8 +1090,13 @@@ svc_process_common(struct svc_rqst *rqs
  	/* Will be turned off only in gss privacy case: */
  	rqstp->rq_splice_ok = true;
  	/* Will be turned off only when NFSv4 Sessions are used */
++<<<<<<< HEAD
 +	rqstp->rq_usedeferral = true;
 +	rqstp->rq_dropme = false;
++=======
+ 	set_bit(RQ_USEDEFERRAL, &rqstp->rq_flags);
+ 	clear_bit(RQ_DROPME, &rqstp->rq_flags);
++>>>>>>> 78b65eb3fda9 (sunrpc: move rq_dropme flag into rq_flags)
  
  	/* Setup reply header */
  	rqstp->rq_xprt->xpt_ops->xpo_prep_reply_hdr(rqstp);
diff --git a/fs/nfsd/nfssvc.c b/fs/nfsd/nfssvc.c
index 5ba2659eb9e1..9277cc91c21b 100644
--- a/fs/nfsd/nfssvc.c
+++ b/fs/nfsd/nfssvc.c
@@ -693,7 +693,7 @@ nfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)
 	/* Now call the procedure handler, and encode NFS status. */
 	nfserr = proc->pc_func(rqstp, rqstp->rq_argp, rqstp->rq_resp);
 	nfserr = map_new_errors(rqstp->rq_vers, nfserr);
-	if (nfserr == nfserr_dropit || rqstp->rq_dropme) {
+	if (nfserr == nfserr_dropit || test_bit(RQ_DROPME, &rqstp->rq_flags)) {
 		dprintk("nfsd: Dropping request; may be revisited later\n");
 		nfsd_cache_update(rqstp, RC_NOCACHE, NULL);
 		return 0;
* Unmerged path include/linux/sunrpc/svc.h
* Unmerged path include/trace/events/sunrpc.h
* Unmerged path net/sunrpc/svc.c
diff --git a/net/sunrpc/svc_xprt.c b/net/sunrpc/svc_xprt.c
index eaa3d57f667e..1b73f7a73920 100644
--- a/net/sunrpc/svc_xprt.c
+++ b/net/sunrpc/svc_xprt.c
@@ -1122,7 +1122,7 @@ static struct cache_deferred_req *svc_defer(struct cache_req *req)
 	}
 	svc_xprt_get(rqstp->rq_xprt);
 	dr->xprt = rqstp->rq_xprt;
-	rqstp->rq_dropme = true;
+	set_bit(RQ_DROPME, &rqstp->rq_flags);
 
 	dr->handle.revisit = svc_revisit;
 	return &dr->handle;
