nfs: use file_dentry()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit be62a1a8fd116f5cd9e53726601f970e16e17558
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/be62a1a8.failed

NFS may be used as lower layer of overlayfs and accessing f_path.dentry can
lead to a crash.

Fix by replacing direct access of file->f_path.dentry with the
file_dentry() accessor, which will always return a native object.

Fixes: 4bacc9c9234c ("overlayfs: Make f_path always point to the overlay and f_inode to the underlay")
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
	Tested-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
	Acked-by: Trond Myklebust <trond.myklebust@primarydata.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: <stable@vger.kernel.org> # v4.2
	Cc: David Howells <dhowells@redhat.com>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit be62a1a8fd116f5cd9e53726601f970e16e17558)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/dir.c
diff --cc fs/nfs/dir.c
index 85847da65697,a89d32a38e88..000000000000
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@@ -866,13 -862,13 +866,18 @@@ static bool nfs_dir_mapping_need_revali
     last cookie cache takes care of the common case of reading the
     whole directory.
   */
 -static int nfs_readdir(struct file *file, struct dir_context *ctx)
 +static int nfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
  {
++<<<<<<< HEAD
 +	struct dentry	*dentry = filp->f_path.dentry;
 +	struct inode	*inode = dentry->d_inode;
++=======
+ 	struct dentry	*dentry = file_dentry(file);
+ 	struct inode	*inode = d_inode(dentry);
++>>>>>>> be62a1a8fd11 (nfs: use file_dentry())
  	nfs_readdir_descriptor_t my_desc,
  			*desc = &my_desc;
 -	struct nfs_open_dir_context *dir_ctx = file->private_data;
 +	struct nfs_open_dir_context *dir_ctx = filp->private_data;
  	int res = 0;
  
  	dfprintk(FILE, "NFS: readdir(%pD2) starting at cookie %llu\n",
* Unmerged path fs/nfs/dir.c
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index e94dde09e25e..0cd8faefd8aa 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -921,7 +921,7 @@ int nfs_open(struct inode *inode, struct file *filp)
 {
 	struct nfs_open_context *ctx;
 
-	ctx = alloc_nfs_open_context(filp->f_path.dentry, filp->f_mode);
+	ctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode);
 	if (IS_ERR(ctx))
 		return PTR_ERR(ctx);
 	nfs_file_set_open_context(filp, ctx);
diff --git a/fs/nfs/nfs4file.c b/fs/nfs/nfs4file.c
index 75f15320a424..3b0cf46091ff 100644
--- a/fs/nfs/nfs4file.c
+++ b/fs/nfs/nfs4file.c
@@ -22,7 +22,7 @@ static int
 nfs4_file_open(struct inode *inode, struct file *filp)
 {
 	struct nfs_open_context *ctx;
-	struct dentry *dentry = filp->f_path.dentry;
+	struct dentry *dentry = file_dentry(filp);
 	struct dentry *parent = NULL;
 	struct inode *dir;
 	unsigned openflags = filp->f_flags;
@@ -53,7 +53,7 @@ nfs4_file_open(struct inode *inode, struct file *filp)
 	parent = dget_parent(dentry);
 	dir = parent->d_inode;
 
-	ctx = alloc_nfs_open_context(filp->f_path.dentry, filp->f_mode);
+	ctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode);
 	err = PTR_ERR(ctx);
 	if (IS_ERR(ctx))
 		goto out;
