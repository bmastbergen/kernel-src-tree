net/mlx5e: Add ethtool support for rxvlan-offload (vlan stripping)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [include] mlx5e: Add ethtool support for rxvlan-offload (vlan stripping) (kamal heib) [1275159 1296272 1296405 1298421 1298422 1298423 1298424 1298425]
Rebuild_FUZZ: 96.88%
commit-author Gal Pressman <galp@mellanox.com>
commit 363501145e3faa650193722fe7047b767ed87172
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/36350114.failed

Use ethtool -K <interface> rxvlan <on/off> to enable/disable
C-TAG vlan stripping by hardware.

	Signed-off-by: Gal Pressman <galp@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 363501145e3faa650193722fe7047b767ed87172)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index a33b9e6fa485,8abc289ac1fb..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -285,6 -166,23 +285,26 @@@ struct mlx5e_params 
  	u8  rss_hfunc;
  	u8  toeplitz_hash_key[40];
  	u32 indirection_rqt[MLX5E_INDIR_RQT_SIZE];
++<<<<<<< HEAD
++=======
+ 	bool vlan_strip_disable;
+ #ifdef CONFIG_MLX5_CORE_EN_DCB
+ 	struct ieee_ets ets;
+ #endif
+ };
+ 
+ struct mlx5e_tstamp {
+ 	rwlock_t                   lock;
+ 	struct cyclecounter        cycles;
+ 	struct timecounter         clock;
+ 	struct hwtstamp_config     hwtstamp_config;
+ 	u32                        nominal_c_mult;
+ 	unsigned long              overflow_period;
+ 	struct delayed_work        overflow_work;
+ 	struct mlx5_core_dev      *mdev;
+ 	struct ptp_clock          *ptp;
+ 	struct ptp_clock_info      ptp_info;
++>>>>>>> 363501145e3f (net/mlx5e: Add ethtool support for rxvlan-offload (vlan stripping))
  };
  
  enum {
@@@ -590,7 -576,10 +610,9 @@@ int mlx5e_vlan_rx_kill_vid(struct net_d
  void mlx5e_enable_vlan_filter(struct mlx5e_priv *priv);
  void mlx5e_disable_vlan_filter(struct mlx5e_priv *priv);
  
+ int mlx5e_modify_rqs_vsd(struct mlx5e_priv *priv, bool vsd);
+ 
  int mlx5e_redirect_rqt(struct mlx5e_priv *priv, enum mlx5e_rqt_ix rqt_ix);
 -void mlx5e_build_tir_ctx_hash(void *tirc, struct mlx5e_priv *priv);
  
  int mlx5e_open_locked(struct net_device *netdev);
  int mlx5e_close_locked(struct net_device *netdev);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index b70e3293db0b,6c9c10c131a0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -1908,6 -1995,75 +1940,78 @@@ static void mlx5e_destroy_tirs(struct m
  		mlx5e_destroy_tir(priv, i);
  }
  
++<<<<<<< HEAD
++=======
+ int mlx5e_modify_rqs_vsd(struct mlx5e_priv *priv, bool vsd)
+ {
+ 	int err = 0;
+ 	int i;
+ 
+ 	if (!test_bit(MLX5E_STATE_OPENED, &priv->state))
+ 		return 0;
+ 
+ 	for (i = 0; i < priv->params.num_channels; i++) {
+ 		err = mlx5e_modify_rq_vsd(&priv->channel[i]->rq, vsd);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5e_setup_tc(struct net_device *netdev, u8 tc)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	bool was_opened;
+ 	int err = 0;
+ 
+ 	if (tc && tc != MLX5E_MAX_NUM_TC)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&priv->state_lock);
+ 
+ 	was_opened = test_bit(MLX5E_STATE_OPENED, &priv->state);
+ 	if (was_opened)
+ 		mlx5e_close_locked(priv->netdev);
+ 
+ 	priv->params.num_tc = tc ? tc : 1;
+ 
+ 	if (was_opened)
+ 		err = mlx5e_open_locked(priv->netdev);
+ 
+ 	mutex_unlock(&priv->state_lock);
+ 
+ 	return err;
+ }
+ 
+ static int mlx5e_ndo_setup_tc(struct net_device *dev, u32 handle,
+ 			      __be16 proto, struct tc_to_netdev *tc)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 
+ 	if (TC_H_MAJ(handle) != TC_H_MAJ(TC_H_INGRESS))
+ 		goto mqprio;
+ 
+ 	switch (tc->type) {
+ 	case TC_SETUP_CLSFLOWER:
+ 		switch (tc->cls_flower->command) {
+ 		case TC_CLSFLOWER_REPLACE:
+ 			return mlx5e_configure_flower(priv, proto, tc->cls_flower);
+ 		case TC_CLSFLOWER_DESTROY:
+ 			return mlx5e_delete_flower(priv, tc->cls_flower);
+ 		}
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ mqprio:
+ 	if (tc->type != TC_SETUP_MQPRIO)
+ 		return -EINVAL;
+ 
+ 	return mlx5e_setup_tc(dev, tc->tc);
+ }
+ 
++>>>>>>> 363501145e3f (net/mlx5e: Add ethtool support for rxvlan-offload (vlan stripping))
  static struct rtnl_link_stats64 *
  mlx5e_get_stats(struct net_device *dev, struct rtnl_link_stats64 *stats)
  {
@@@ -2017,8 -2163,98 +2121,103 @@@ static int mlx5e_set_features(struct ne
  	return err;
  }
  
++<<<<<<< HEAD
 +#define MXL5_HW_MIN_MTU 64
 +#define MXL5E_MIN_MTU (MXL5_HW_MIN_MTU + ETH_FCS_LEN)
++=======
+ static int set_feature_vlan_filter(struct net_device *netdev, bool enable)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	if (enable)
+ 		mlx5e_enable_vlan_filter(priv);
+ 	else
+ 		mlx5e_disable_vlan_filter(priv);
+ 
+ 	return 0;
+ }
+ 
+ static int set_feature_tc_num_filters(struct net_device *netdev, bool enable)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	if (!enable && mlx5e_tc_num_filters(priv)) {
+ 		netdev_err(netdev,
+ 			   "Active offloaded tc filters, can't turn hw_tc_offload off\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int set_feature_rx_all(struct net_device *netdev, bool enable)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 
+ 	return mlx5_set_port_fcs(mdev, !enable);
+ }
+ 
+ static int set_feature_rx_vlan(struct net_device *netdev, bool enable)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	int err;
+ 
+ 	mutex_lock(&priv->state_lock);
+ 
+ 	priv->params.vlan_strip_disable = !enable;
+ 	err = mlx5e_modify_rqs_vsd(priv, !enable);
+ 	if (err)
+ 		priv->params.vlan_strip_disable = enable;
+ 
+ 	mutex_unlock(&priv->state_lock);
+ 
+ 	return err;
+ }
+ 
+ static int mlx5e_handle_feature(struct net_device *netdev,
+ 				netdev_features_t wanted_features,
+ 				netdev_features_t feature,
+ 				mlx5e_feature_handler feature_handler)
+ {
+ 	netdev_features_t changes = wanted_features ^ netdev->features;
+ 	bool enable = !!(wanted_features & feature);
+ 	int err;
+ 
+ 	if (!(changes & feature))
+ 		return 0;
+ 
+ 	err = feature_handler(netdev, enable);
+ 	if (err) {
+ 		netdev_err(netdev, "%s feature 0x%llx failed err %d\n",
+ 			   enable ? "Enable" : "Disable", feature, err);
+ 		return err;
+ 	}
+ 
+ 	MLX5E_SET_FEATURE(netdev, feature, enable);
+ 	return 0;
+ }
+ 
+ static int mlx5e_set_features(struct net_device *netdev,
+ 			      netdev_features_t features)
+ {
+ 	int err;
+ 
+ 	err  = mlx5e_handle_feature(netdev, features, NETIF_F_LRO,
+ 				    set_feature_lro);
+ 	err |= mlx5e_handle_feature(netdev, features,
+ 				    NETIF_F_HW_VLAN_CTAG_FILTER,
+ 				    set_feature_vlan_filter);
+ 	err |= mlx5e_handle_feature(netdev, features, NETIF_F_HW_TC,
+ 				    set_feature_tc_num_filters);
+ 	err |= mlx5e_handle_feature(netdev, features, NETIF_F_RXALL,
+ 				    set_feature_rx_all);
+ 	err |= mlx5e_handle_feature(netdev, features, NETIF_F_HW_VLAN_CTAG_RX,
+ 				    set_feature_rx_vlan);
+ 
+ 	return err ? -EINVAL : 0;
+ }
++>>>>>>> 363501145e3f (net/mlx5e: Add ethtool support for rxvlan-offload (vlan stripping))
  
  static int mlx5e_change_mtu(struct net_device *netdev, int new_mtu)
  {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index d4e17c4128c4..30fa2d444d45 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -45,6 +45,10 @@
 #include <linux/mlx5/device.h>
 #include <linux/mlx5/doorbell.h>
 
+enum {
+	MLX5_RQ_BITMASK_VSD = 1 << 1,
+};
+
 enum {
 	MLX5_BOARD_ID_LEN = 64,
 	MLX5_MAX_NAME_LEN = 16,
