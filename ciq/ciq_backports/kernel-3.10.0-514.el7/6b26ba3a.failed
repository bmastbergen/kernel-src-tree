openvswitch: netlink attributes for IPv6 tunneling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 6b26ba3a7d952e611dcde1f3f77ce63bcc70540a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6b26ba3a.failed

Add netlink attributes for IPv6 tunnel addresses. This enables IPv6 support
for tunnels.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Acked-by: Pravin B Shelar <pshelar@nicira.com>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6b26ba3a7d952e611dcde1f3f77ce63bcc70540a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/flow_netlink.c
diff --cc net/openvswitch/flow_netlink.c
index 7f4707e70b38,77850f177a47..000000000000
--- a/net/openvswitch/flow_netlink.c
+++ b/net/openvswitch/flow_netlink.c
@@@ -311,8 -320,11 +311,16 @@@ static const struct ovs_len_tbl ovs_tun
  	[OVS_TUNNEL_KEY_ATTR_TP_SRC]	    = { .len = sizeof(u16) },
  	[OVS_TUNNEL_KEY_ATTR_TP_DST]	    = { .len = sizeof(u16) },
  	[OVS_TUNNEL_KEY_ATTR_OAM]	    = { .len = 0 },
++<<<<<<< HEAD
 +	[OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS]   = { .len = OVS_ATTR_NESTED },
 +	[OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS]    = { .len = OVS_ATTR_NESTED },
++=======
+ 	[OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS]   = { .len = OVS_ATTR_VARIABLE },
+ 	[OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS]    = { .len = OVS_ATTR_NESTED,
+ 						.next = ovs_vxlan_ext_key_lens },
+ 	[OVS_TUNNEL_KEY_ATTR_IPV6_SRC]      = { .len = sizeof(struct in6_addr) },
+ 	[OVS_TUNNEL_KEY_ATTR_IPV6_DST]      = { .len = sizeof(struct in6_addr) },
++>>>>>>> 6b26ba3a7d95 (openvswitch: netlink attributes for IPv6 tunneling)
  };
  
  /* The size of the argument for each %OVS_KEY_ATTR_* Netlink attribute.  */
@@@ -534,15 -578,27 +542,27 @@@ static int ip_tun_from_nlattr(const str
  			tun_flags |= TUNNEL_KEY;
  			break;
  		case OVS_TUNNEL_KEY_ATTR_IPV4_SRC:
 -			SW_FLOW_KEY_PUT(match, tun_key.u.ipv4.src,
 +			SW_FLOW_KEY_PUT(match, tun_key.ipv4_src,
  					nla_get_in_addr(a), is_mask);
+ 			ipv4 = true;
  			break;
  		case OVS_TUNNEL_KEY_ATTR_IPV4_DST:
 -			SW_FLOW_KEY_PUT(match, tun_key.u.ipv4.dst,
 +			SW_FLOW_KEY_PUT(match, tun_key.ipv4_dst,
  					nla_get_in_addr(a), is_mask);
+ 			ipv4 = true;
+ 			break;
+ 		case OVS_TUNNEL_KEY_ATTR_IPV6_SRC:
+ 			SW_FLOW_KEY_PUT(match, tun_key.u.ipv6.dst,
+ 					nla_get_in6_addr(a), is_mask);
+ 			ipv6 = true;
+ 			break;
+ 		case OVS_TUNNEL_KEY_ATTR_IPV6_DST:
+ 			SW_FLOW_KEY_PUT(match, tun_key.u.ipv6.dst,
+ 					nla_get_in6_addr(a), is_mask);
+ 			ipv6 = true;
  			break;
  		case OVS_TUNNEL_KEY_ATTR_TOS:
 -			SW_FLOW_KEY_PUT(match, tun_key.tos,
 +			SW_FLOW_KEY_PUT(match, tun_key.ipv4_tos,
  					nla_get_u8(a), is_mask);
  			break;
  		case OVS_TUNNEL_KEY_ATTR_TTL:
@@@ -601,15 -657,29 +621,36 @@@
  	}
  
  	SW_FLOW_KEY_PUT(match, tun_key.tun_flags, tun_flags, is_mask);
++<<<<<<< HEAD
++=======
+ 	if (is_mask)
+ 		SW_FLOW_KEY_MEMSET_FIELD(match, tun_proto, 0xff, true);
+ 	else
+ 		SW_FLOW_KEY_PUT(match, tun_proto, ipv6 ? AF_INET6 : AF_INET,
+ 				false);
++>>>>>>> 6b26ba3a7d95 (openvswitch: netlink attributes for IPv6 tunneling)
  
  	if (rem > 0) {
- 		OVS_NLERR(log, "IPv4 tunnel attribute has %d unknown bytes.",
+ 		OVS_NLERR(log, "IP tunnel attribute has %d unknown bytes.",
  			  rem);
  		return -EINVAL;
  	}
  
+ 	if (ipv4 && ipv6) {
+ 		OVS_NLERR(log, "Mixed IPv4 and IPv6 tunnel attributes");
+ 		return -EINVAL;
+ 	}
+ 
  	if (!is_mask) {
++<<<<<<< HEAD
 +		if (!match->key->tun_key.ipv4_dst) {
++=======
+ 		if (!ipv4 && !ipv6) {
+ 			OVS_NLERR(log, "IP tunnel dst address not specified");
+ 			return -EINVAL;
+ 		}
+ 		if (ipv4 && !match->key->tun_key.u.ipv4.dst) {
++>>>>>>> 6b26ba3a7d95 (openvswitch: netlink attributes for IPv6 tunneling)
  			OVS_NLERR(log, "IPv4 tunnel dst address is zero");
  			return -EINVAL;
  		}
@@@ -647,18 -722,32 +693,45 @@@ static int __ip_tun_to_nlattr(struct sk
  	if (output->tun_flags & TUNNEL_KEY &&
  	    nla_put_be64(skb, OVS_TUNNEL_KEY_ATTR_ID, output->tun_id))
  		return -EMSGSIZE;
++<<<<<<< HEAD
 +	if (output->ipv4_src &&
 +	    nla_put_in_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV4_SRC,
 +			    output->ipv4_src))
 +		return -EMSGSIZE;
 +	if (output->ipv4_dst &&
 +	    nla_put_in_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV4_DST,
 +			    output->ipv4_dst))
 +		return -EMSGSIZE;
 +	if (output->ipv4_tos &&
 +	    nla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TOS, output->ipv4_tos))
++=======
+ 	switch (tun_proto) {
+ 	case AF_INET:
+ 		if (output->u.ipv4.src &&
+ 		    nla_put_in_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV4_SRC,
+ 				    output->u.ipv4.src))
+ 			return -EMSGSIZE;
+ 		if (output->u.ipv4.dst &&
+ 		    nla_put_in_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV4_DST,
+ 				    output->u.ipv4.dst))
+ 			return -EMSGSIZE;
+ 		break;
+ 	case AF_INET6:
+ 		if (!ipv6_addr_any(&output->u.ipv6.src) &&
+ 		    nla_put_in6_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV6_SRC,
+ 				     &output->u.ipv6.src))
+ 			return -EMSGSIZE;
+ 		if (!ipv6_addr_any(&output->u.ipv6.dst) &&
+ 		    nla_put_in6_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV6_DST,
+ 				     &output->u.ipv6.dst))
+ 			return -EMSGSIZE;
+ 		break;
+ 	}
+ 	if (output->tos &&
+ 	    nla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TOS, output->tos))
++>>>>>>> 6b26ba3a7d95 (openvswitch: netlink attributes for IPv6 tunneling)
  		return -EMSGSIZE;
 -	if (nla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TTL, output->ttl))
 +	if (nla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TTL, output->ipv4_ttl))
  		return -EMSGSIZE;
  	if ((output->tun_flags & TUNNEL_DONT_FRAGMENT) &&
  	    nla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT))
@@@ -708,16 -799,18 +783,23 @@@ static int ip_tun_to_nlattr(struct sk_b
  }
  
  int ovs_nla_put_egress_tunnel_key(struct sk_buff *skb,
 -				  const struct ip_tunnel_info *egress_tun_info,
 -				  const void *egress_tun_opts)
 +				  const struct ip_tunnel_info *egress_tun_info)
  {
++<<<<<<< HEAD
 +	return __ipv4_tun_to_nlattr(skb, &egress_tun_info->key,
 +				    egress_tun_info->options,
 +				    egress_tun_info->options_len);
++=======
+ 	return __ip_tun_to_nlattr(skb, &egress_tun_info->key,
+ 				  egress_tun_opts,
+ 				  egress_tun_info->options_len,
+ 				  ip_tunnel_info_af(egress_tun_info));
++>>>>>>> 6b26ba3a7d95 (openvswitch: netlink attributes for IPv6 tunneling)
  }
  
 -static int metadata_from_nlattrs(struct net *net, struct sw_flow_match *match,
 -				 u64 *attrs, const struct nlattr **a,
 -				 bool is_mask, bool log)
 +static int metadata_from_nlattrs(struct sw_flow_match *match,  u64 *attrs,
 +				 const struct nlattr **a, bool is_mask,
 +				 bool log)
  {
  	if (*attrs & (1 << OVS_KEY_ATTR_DP_HASH)) {
  		u32 hash_val = nla_get_u32(a[OVS_KEY_ATTR_DP_HASH]);
@@@ -2285,10 -2426,11 +2367,18 @@@ static int set_action_to_attr(const str
  		if (!start)
  			return -EMSGSIZE;
  
++<<<<<<< HEAD
 +		err = ipv4_tun_to_nlattr(skb, &tun_info->key,
 +					 tun_info->options_len ?
 +						tun_info->options : NULL,
 +					 tun_info->options_len);
++=======
+ 		err = ip_tun_to_nlattr(skb, &tun_info->key,
+ 				       tun_info->options_len ?
+ 					     ip_tunnel_info_opts(tun_info) : NULL,
+ 				       tun_info->options_len,
+ 				       ip_tunnel_info_af(tun_info));
++>>>>>>> 6b26ba3a7d95 (openvswitch: netlink attributes for IPv6 tunneling)
  		if (err)
  			return err;
  		nla_nest_end(skb, start);
diff --git a/include/uapi/linux/openvswitch.h b/include/uapi/linux/openvswitch.h
index d6b885460187..c594cab258fc 100644
--- a/include/uapi/linux/openvswitch.h
+++ b/include/uapi/linux/openvswitch.h
@@ -341,6 +341,8 @@ enum ovs_tunnel_key_attr {
 	OVS_TUNNEL_KEY_ATTR_TP_SRC,		/* be16 src Transport Port. */
 	OVS_TUNNEL_KEY_ATTR_TP_DST,		/* be16 dst Transport Port. */
 	OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS,		/* Nested OVS_VXLAN_EXT_* */
+	OVS_TUNNEL_KEY_ATTR_IPV6_SRC,		/* struct in6_addr src IPv6 address. */
+	OVS_TUNNEL_KEY_ATTR_IPV6_DST,		/* struct in6_addr dst IPv6 address. */
 	__OVS_TUNNEL_KEY_ATTR_MAX
 };
 
* Unmerged path net/openvswitch/flow_netlink.c
