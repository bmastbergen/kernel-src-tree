hv_netvsc: Fix the array sizes to be max supported channels

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Haiyang Zhang <haiyangz@microsoft.com>
commit 9efc2f7dcd06e04d7b6a3032ae65bfd628b1aebe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9efc2f7d.failed

The VRSS_CHANNEL_MAX is the max number of channels supported by Hyper-V
hosts. We use it for the related array sizes instead of using NR_CPUS,
which may be set to several thousands.
This patch reduces possible memory allocation failures.

	Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
	Reviewed-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9efc2f7dcd06e04d7b6a3032ae65bfd628b1aebe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/rndis_filter.c
diff --cc drivers/net/hyperv/hyperv_net.h
index cf498664d989,8b3bd8ecd1c4..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -595,8 -619,53 +595,9 @@@ struct nvsp_message 
  #define NETVSC_PACKET_SIZE                      4096
  
  #define VRSS_SEND_TAB_SIZE 16
+ #define VRSS_CHANNEL_MAX 64
  
 -#define RNDIS_MAX_PKT_DEFAULT 8
 -#define RNDIS_PKT_ALIGN_DEFAULT 8
 -
 -struct multi_send_data {
 -	struct sk_buff *skb; /* skb containing the pkt */
 -	struct hv_netvsc_packet *pkt; /* netvsc pkt pending */
 -	u32 count; /* counter of batched packets */
 -};
 -
 -struct netvsc_stats {
 -	u64 packets;
 -	u64 bytes;
 -	struct u64_stats_sync syncp;
 -};
 -
 -struct netvsc_reconfig {
 -	struct list_head list;
 -	u32 event;
 -};
 -
 -/* The context of the netvsc device  */
 -struct net_device_context {
 -	/* point back to our device context */
 -	struct hv_device *device_ctx;
 -	/* reconfigure work */
 -	struct delayed_work dwork;
 -	/* last reconfig time */
 -	unsigned long last_reconfig;
 -	/* reconfig events */
 -	struct list_head reconfig_events;
 -	/* list protection */
 -	spinlock_t lock;
 -
 -	struct work_struct work;
 -	u32 msg_enable; /* debug level */
 -
 -	struct netvsc_stats __percpu *tx_stats;
 -	struct netvsc_stats __percpu *rx_stats;
 -
 -	/* Ethtool settings */
 -	u8 duplex;
 -	u32 speed;
 -};
 -
 -/* Per netvsc device */
 +/* Per netvsc channel-specific */
  struct netvsc_device {
  	struct hv_device *dev;
  
@@@ -636,7 -705,9 +637,13 @@@
  	u32 send_table[VRSS_SEND_TAB_SIZE];
  	u32 max_chn;
  	u32 num_chn;
++<<<<<<< HEAD
 +	atomic_t queue_sends[NR_CPUS];
++=======
+ 	spinlock_t sc_lock; /* Protects num_sc_offered variable */
+ 	u32 num_sc_offered;
+ 	atomic_t queue_sends[VRSS_CHANNEL_MAX];
++>>>>>>> 9efc2f7dcd06 (hv_netvsc: Fix the array sizes to be max supported channels)
  
  	/* Holds rndis device info */
  	void *extension;
@@@ -647,6 -718,18 +654,21 @@@
  	unsigned char *cb_buffer;
  	/* The sub channel callback buffer */
  	unsigned char *sub_cb_buf;
++<<<<<<< HEAD
++=======
+ 
+ 	struct multi_send_data msd[VRSS_CHANNEL_MAX];
+ 	u32 max_pkt; /* max number of pkt in one send, e.g. 8 */
+ 	u32 pkt_align; /* alignment bytes, e.g. 8 */
+ 
+ 	/* The net device context */
+ 	struct net_device_context *nd_ctx;
+ 
+ 	/* 1: allocated, serial number is valid. 0: not allocated */
+ 	u32 vf_alloc;
+ 	/* Serial number of the VF to team with */
+ 	u32 vf_serial;
++>>>>>>> 9efc2f7dcd06 (hv_netvsc: Fix the array sizes to be max supported channels)
  };
  
  /* NdisInitialize message */
diff --cc drivers/net/hyperv/rndis_filter.c
index 4f78abd49222,d5a54da5d9c8..000000000000
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@@ -1107,9 -1113,26 +1107,32 @@@ int rndis_filter_device_add(struct hv_d
  	if (ret || rsscap.num_recv_que < 2)
  		goto out;
  
++<<<<<<< HEAD
 +	net_device->max_chn = rsscap.num_recv_que;
 +	net_device->num_chn = (num_online_cpus() < rsscap.num_recv_que) ?
 +			       num_online_cpus() : rsscap.num_recv_que;
++=======
+ 	net_device->max_chn = min_t(u32, VRSS_CHANNEL_MAX, rsscap.num_recv_que);
+ 
+ 	num_rss_qs = min(device_info->max_num_vrss_chns, net_device->max_chn);
+ 
+ 	/*
+ 	 * We will limit the VRSS channels to the number CPUs in the NUMA node
+ 	 * the primary channel is currently bound to.
+ 	 */
+ 	node_cpu_mask = cpumask_of_node(cpu_to_node(dev->channel->target_cpu));
+ 	num_possible_rss_qs = cpumask_weight(node_cpu_mask);
+ 
+ 	/* We will use the given number of channels if available. */
+ 	if (device_info->num_chn && device_info->num_chn < net_device->max_chn)
+ 		net_device->num_chn = device_info->num_chn;
+ 	else
+ 		net_device->num_chn = min(num_possible_rss_qs, num_rss_qs);
+ 
+ 	num_rss_qs = net_device->num_chn - 1;
+ 	net_device->num_sc_offered = num_rss_qs;
+ 
++>>>>>>> 9efc2f7dcd06 (hv_netvsc: Fix the array sizes to be max supported channels)
  	if (net_device->num_chn == 1)
  		goto out;
  
* Unmerged path drivers/net/hyperv/hyperv_net.h
* Unmerged path drivers/net/hyperv/rndis_filter.c
