add devm_memremap_pages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 41e94a851304f7acac840adec4004f8aeee53ad4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/41e94a85.failed

This behaves like devm_memremap except that it ensures we have page
structures available that can back the region.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
[djbw: catch attempts to remap RAM, drop flags]
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 41e94a851304f7acac840adec4004f8aeee53ad4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/io.h
diff --cc include/linux/io.h
index a2dc5d13311b,de64c1e53612..000000000000
--- a/include/linux/io.h
+++ b/include/linux/io.h
@@@ -19,12 -19,16 +19,19 @@@
  #define _LINUX_IO_H
  
  #include <linux/types.h>
++<<<<<<< HEAD
++=======
+ #include <linux/init.h>
+ #include <linux/bug.h>
+ #include <linux/err.h>
++>>>>>>> 41e94a851304 (add devm_memremap_pages)
  #include <asm/io.h>
  #include <asm/page.h>
  
  struct device;
+ struct resource;
  
 -__visible void __iowrite32_copy(void __iomem *to, const void *from, size_t count);
 +void __iowrite32_copy(void __iomem *to, const void *from, size_t count);
  void __iowrite64_copy(void __iomem *to, const void *from, size_t count);
  
  #ifdef CONFIG_MMU
* Unmerged path include/linux/io.h
diff --git a/kernel/memremap.c b/kernel/memremap.c
index 5c9b55eaf121..72b0c66628b6 100644
--- a/kernel/memremap.c
+++ b/kernel/memremap.c
@@ -14,6 +14,7 @@
 #include <linux/types.h>
 #include <linux/io.h>
 #include <linux/mm.h>
+#include <linux/memory_hotplug.h>
 
 #ifndef ioremap_cache
 /* temporary while we convert existing ioremap_cache users to memremap */
@@ -135,3 +136,55 @@ void devm_memunmap(struct device *dev, void *addr)
 	memunmap(addr);
 }
 EXPORT_SYMBOL(devm_memunmap);
+
+#ifdef CONFIG_ZONE_DEVICE
+struct page_map {
+	struct resource res;
+};
+
+static void devm_memremap_pages_release(struct device *dev, void *res)
+{
+	struct page_map *page_map = res;
+
+	/* pages are dead and unused, undo the arch mapping */
+	arch_remove_memory(page_map->res.start, resource_size(&page_map->res));
+}
+
+void *devm_memremap_pages(struct device *dev, struct resource *res)
+{
+	int is_ram = region_intersects(res->start, resource_size(res),
+			"System RAM");
+	struct page_map *page_map;
+	int error, nid;
+
+	if (is_ram == REGION_MIXED) {
+		WARN_ONCE(1, "%s attempted on mixed region %pr\n",
+				__func__, res);
+		return ERR_PTR(-ENXIO);
+	}
+
+	if (is_ram == REGION_INTERSECTS)
+		return __va(res->start);
+
+	page_map = devres_alloc(devm_memremap_pages_release,
+			sizeof(*page_map), GFP_KERNEL);
+	if (!page_map)
+		return ERR_PTR(-ENOMEM);
+
+	memcpy(&page_map->res, res, sizeof(*res));
+
+	nid = dev_to_node(dev);
+	if (nid < 0)
+		nid = 0;
+
+	error = arch_add_memory(nid, res->start, resource_size(res), true);
+	if (error) {
+		devres_free(page_map);
+		return ERR_PTR(error);
+	}
+
+	devres_add(dev, page_map);
+	return __va(res->start);
+}
+EXPORT_SYMBOL(devm_memremap_pages);
+#endif /* CONFIG_ZONE_DEVICE */
