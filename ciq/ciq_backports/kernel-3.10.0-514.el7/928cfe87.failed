net/mlx5e: Wake On LAN support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [include] mlx5e: Wake On LAN support (kamal heib) [1275159 1296272 1296405 1298421 1298422 1298423 1298424 1298425]
Rebuild_FUZZ: 92.86%
commit-author Tariq Toukan <tariqt@mellanox.com>
commit 928cfe8745a62e60c1e8e06676a74724e7786024
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/928cfe87.failed

Implement set/get WOL by ethtool and added the needed
device commands and structures to mlx5_ifc.

	Signed-off-by: Tariq Toukan <tariqt@mellanox.com>
	Signed-off-by: Rana Shahout <ranas@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 928cfe8745a62e60c1e8e06676a74724e7786024)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/port.c
#	include/linux/mlx5/mlx5_ifc.h
#	include/linux/mlx5/port.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index ccc09bfe0889,e9760f895744..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -857,6 -855,158 +857,161 @@@ static int mlx5e_set_pauseparam(struct 
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int mlx5e_get_ts_info(struct net_device *dev,
+ 			     struct ethtool_ts_info *info)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 	int ret;
+ 
+ 	ret = ethtool_op_get_ts_info(dev, info);
+ 	if (ret)
+ 		return ret;
+ 
+ 	info->phc_index = priv->tstamp.ptp ?
+ 			  ptp_clock_index(priv->tstamp.ptp) : -1;
+ 
+ 	if (!MLX5_CAP_GEN(priv->mdev, device_frequency_khz))
+ 		return 0;
+ 
+ 	info->so_timestamping |= SOF_TIMESTAMPING_TX_HARDWARE |
+ 				 SOF_TIMESTAMPING_RX_HARDWARE |
+ 				 SOF_TIMESTAMPING_RAW_HARDWARE;
+ 
+ 	info->tx_types = (BIT(1) << HWTSTAMP_TX_OFF) |
+ 			 (BIT(1) << HWTSTAMP_TX_ON);
+ 
+ 	info->rx_filters = (BIT(1) << HWTSTAMP_FILTER_NONE) |
+ 			   (BIT(1) << HWTSTAMP_FILTER_ALL);
+ 
+ 	return 0;
+ }
+ 
+ static __u32 mlx5e_get_wol_supported(struct mlx5_core_dev *mdev)
+ {
+ 	__u32 ret = 0;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_g))
+ 		ret |= WAKE_MAGIC;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_s))
+ 		ret |= WAKE_MAGICSECURE;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_a))
+ 		ret |= WAKE_ARP;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_b))
+ 		ret |= WAKE_BCAST;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_m))
+ 		ret |= WAKE_MCAST;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_u))
+ 		ret |= WAKE_UCAST;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_p))
+ 		ret |= WAKE_PHY;
+ 
+ 	return ret;
+ }
+ 
+ static __u32 mlx5e_refomrat_wol_mode_mlx5_to_linux(u8 mode)
+ {
+ 	__u32 ret = 0;
+ 
+ 	if (mode & MLX5_WOL_MAGIC)
+ 		ret |= WAKE_MAGIC;
+ 
+ 	if (mode & MLX5_WOL_SECURED_MAGIC)
+ 		ret |= WAKE_MAGICSECURE;
+ 
+ 	if (mode & MLX5_WOL_ARP)
+ 		ret |= WAKE_ARP;
+ 
+ 	if (mode & MLX5_WOL_BROADCAST)
+ 		ret |= WAKE_BCAST;
+ 
+ 	if (mode & MLX5_WOL_MULTICAST)
+ 		ret |= WAKE_MCAST;
+ 
+ 	if (mode & MLX5_WOL_UNICAST)
+ 		ret |= WAKE_UCAST;
+ 
+ 	if (mode & MLX5_WOL_PHY_ACTIVITY)
+ 		ret |= WAKE_PHY;
+ 
+ 	return ret;
+ }
+ 
+ static u8 mlx5e_refomrat_wol_mode_linux_to_mlx5(__u32 mode)
+ {
+ 	u8 ret = 0;
+ 
+ 	if (mode & WAKE_MAGIC)
+ 		ret |= MLX5_WOL_MAGIC;
+ 
+ 	if (mode & WAKE_MAGICSECURE)
+ 		ret |= MLX5_WOL_SECURED_MAGIC;
+ 
+ 	if (mode & WAKE_ARP)
+ 		ret |= MLX5_WOL_ARP;
+ 
+ 	if (mode & WAKE_BCAST)
+ 		ret |= MLX5_WOL_BROADCAST;
+ 
+ 	if (mode & WAKE_MCAST)
+ 		ret |= MLX5_WOL_MULTICAST;
+ 
+ 	if (mode & WAKE_UCAST)
+ 		ret |= MLX5_WOL_UNICAST;
+ 
+ 	if (mode & WAKE_PHY)
+ 		ret |= MLX5_WOL_PHY_ACTIVITY;
+ 
+ 	return ret;
+ }
+ 
+ static void mlx5e_get_wol(struct net_device *netdev,
+ 			  struct ethtool_wolinfo *wol)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	u8 mlx5_wol_mode;
+ 	int err;
+ 
+ 	memset(wol, 0, sizeof(*wol));
+ 
+ 	wol->supported = mlx5e_get_wol_supported(mdev);
+ 	if (!wol->supported)
+ 		return;
+ 
+ 	err = mlx5_query_port_wol(mdev, &mlx5_wol_mode);
+ 	if (err)
+ 		return;
+ 
+ 	wol->wolopts = mlx5e_refomrat_wol_mode_mlx5_to_linux(mlx5_wol_mode);
+ }
+ 
+ static int mlx5e_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	__u32 wol_supported = mlx5e_get_wol_supported(mdev);
+ 	u32 mlx5_wol_mode;
+ 
+ 	if (!wol_supported)
+ 		return -ENOTSUPP;
+ 
+ 	if (wol->wolopts & ~wol_supported)
+ 		return -EINVAL;
+ 
+ 	mlx5_wol_mode = mlx5e_refomrat_wol_mode_linux_to_mlx5(wol->wolopts);
+ 
+ 	return mlx5_set_port_wol(mdev, mlx5_wol_mode);
+ }
+ 
++>>>>>>> 928cfe8745a6 (net/mlx5e: Wake On LAN support)
  const struct ethtool_ops mlx5e_ethtool_ops = {
  	.get_drvinfo       = mlx5e_get_drvinfo,
  	.get_link          = ethtool_op_get_link,
@@@ -880,4 -1030,7 +1035,10 @@@
  	.set_tunable       = mlx5e_set_tunable,
  	.get_pauseparam    = mlx5e_get_pauseparam,
  	.set_pauseparam    = mlx5e_set_pauseparam,
++<<<<<<< HEAD
++=======
+ 	.get_ts_info       = mlx5e_get_ts_info,
+ 	.get_wol	   = mlx5e_get_wol,
+ 	.set_wol	   = mlx5e_set_wol,
++>>>>>>> 928cfe8745a6 (net/mlx5e: Wake On LAN support)
  };
diff --cc drivers/net/ethernet/mellanox/mlx5/core/port.c
index dae70500b6a9,e1f2e1059cfd..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/port.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/port.c
@@@ -405,3 -405,182 +405,185 @@@ int mlx5_query_port_pfc(struct mlx5_cor
  	return 0;
  }
  EXPORT_SYMBOL_GPL(mlx5_query_port_pfc);
++<<<<<<< HEAD
++=======
+ 
+ int mlx5_max_tc(struct mlx5_core_dev *mdev)
+ {
+ 	u8 num_tc = MLX5_CAP_GEN(mdev, max_tc) ? : 8;
+ 
+ 	return num_tc - 1;
+ }
+ 
+ int mlx5_set_port_prio_tc(struct mlx5_core_dev *mdev, u8 *prio_tc)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(qtct_reg)];
+ 	u32 out[MLX5_ST_SZ_DW(qtct_reg)];
+ 	int err;
+ 	int i;
+ 
+ 	memset(in, 0, sizeof(in));
+ 	for (i = 0; i < 8; i++) {
+ 		if (prio_tc[i] > mlx5_max_tc(mdev))
+ 			return -EINVAL;
+ 
+ 		MLX5_SET(qtct_reg, in, prio, i);
+ 		MLX5_SET(qtct_reg, in, tclass, prio_tc[i]);
+ 
+ 		err = mlx5_core_access_reg(mdev, in, sizeof(in), out,
+ 					   sizeof(out), MLX5_REG_QTCT, 0, 1);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(mlx5_set_port_prio_tc);
+ 
+ static int mlx5_set_port_qetcr_reg(struct mlx5_core_dev *mdev, u32 *in,
+ 				   int inlen)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(qtct_reg)];
+ 
+ 	if (!MLX5_CAP_GEN(mdev, ets))
+ 		return -ENOTSUPP;
+ 
+ 	return mlx5_core_access_reg(mdev, in, inlen, out, sizeof(out),
+ 				    MLX5_REG_QETCR, 0, 1);
+ }
+ 
+ static int mlx5_query_port_qetcr_reg(struct mlx5_core_dev *mdev, u32 *out,
+ 				     int outlen)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(qtct_reg)];
+ 
+ 	if (!MLX5_CAP_GEN(mdev, ets))
+ 		return -ENOTSUPP;
+ 
+ 	memset(in, 0, sizeof(in));
+ 	return mlx5_core_access_reg(mdev, in, sizeof(in), out, outlen,
+ 				    MLX5_REG_QETCR, 0, 0);
+ }
+ 
+ int mlx5_set_port_tc_group(struct mlx5_core_dev *mdev, u8 *tc_group)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(qetc_reg)];
+ 	int i;
+ 
+ 	memset(in, 0, sizeof(in));
+ 
+ 	for (i = 0; i <= mlx5_max_tc(mdev); i++) {
+ 		MLX5_SET(qetc_reg, in, tc_configuration[i].g, 1);
+ 		MLX5_SET(qetc_reg, in, tc_configuration[i].group, tc_group[i]);
+ 	}
+ 
+ 	return mlx5_set_port_qetcr_reg(mdev, in, sizeof(in));
+ }
+ EXPORT_SYMBOL_GPL(mlx5_set_port_tc_group);
+ 
+ int mlx5_set_port_tc_bw_alloc(struct mlx5_core_dev *mdev, u8 *tc_bw)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(qetc_reg)];
+ 	int i;
+ 
+ 	memset(in, 0, sizeof(in));
+ 
+ 	for (i = 0; i <= mlx5_max_tc(mdev); i++) {
+ 		MLX5_SET(qetc_reg, in, tc_configuration[i].b, 1);
+ 		MLX5_SET(qetc_reg, in, tc_configuration[i].bw_allocation, tc_bw[i]);
+ 	}
+ 
+ 	return mlx5_set_port_qetcr_reg(mdev, in, sizeof(in));
+ }
+ EXPORT_SYMBOL_GPL(mlx5_set_port_tc_bw_alloc);
+ 
+ int mlx5_modify_port_ets_rate_limit(struct mlx5_core_dev *mdev,
+ 				    u8 *max_bw_value,
+ 				    u8 *max_bw_units)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(qetc_reg)];
+ 	void *ets_tcn_conf;
+ 	int i;
+ 
+ 	memset(in, 0, sizeof(in));
+ 
+ 	MLX5_SET(qetc_reg, in, port_number, 1);
+ 
+ 	for (i = 0; i <= mlx5_max_tc(mdev); i++) {
+ 		ets_tcn_conf = MLX5_ADDR_OF(qetc_reg, in, tc_configuration[i]);
+ 
+ 		MLX5_SET(ets_tcn_config_reg, ets_tcn_conf, r, 1);
+ 		MLX5_SET(ets_tcn_config_reg, ets_tcn_conf, max_bw_units,
+ 			 max_bw_units[i]);
+ 		MLX5_SET(ets_tcn_config_reg, ets_tcn_conf, max_bw_value,
+ 			 max_bw_value[i]);
+ 	}
+ 
+ 	return mlx5_set_port_qetcr_reg(mdev, in, sizeof(in));
+ }
+ EXPORT_SYMBOL_GPL(mlx5_modify_port_ets_rate_limit);
+ 
+ int mlx5_query_port_ets_rate_limit(struct mlx5_core_dev *mdev,
+ 				   u8 *max_bw_value,
+ 				   u8 *max_bw_units)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(qetc_reg)];
+ 	void *ets_tcn_conf;
+ 	int err;
+ 	int i;
+ 
+ 	err = mlx5_query_port_qetcr_reg(mdev, out, sizeof(out));
+ 	if (err)
+ 		return err;
+ 
+ 	for (i = 0; i <= mlx5_max_tc(mdev); i++) {
+ 		ets_tcn_conf = MLX5_ADDR_OF(qetc_reg, out, tc_configuration[i]);
+ 
+ 		max_bw_value[i] = MLX5_GET(ets_tcn_config_reg, ets_tcn_conf,
+ 					   max_bw_value);
+ 		max_bw_units[i] = MLX5_GET(ets_tcn_config_reg, ets_tcn_conf,
+ 					   max_bw_units);
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(mlx5_query_port_ets_rate_limit);
+ 
+ int mlx5_set_port_wol(struct mlx5_core_dev *mdev, u8 wol_mode)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(set_wol_rol_in)];
+ 	u32 out[MLX5_ST_SZ_DW(set_wol_rol_out)];
+ 
+ 	memset(in, 0, sizeof(in));
+ 	memset(out, 0, sizeof(out));
+ 
+ 	MLX5_SET(set_wol_rol_in, in, opcode, MLX5_CMD_OP_SET_WOL_ROL);
+ 	MLX5_SET(set_wol_rol_in, in, wol_mode_valid, 1);
+ 	MLX5_SET(set_wol_rol_in, in, wol_mode, wol_mode);
+ 
+ 	return mlx5_cmd_exec_check_status(mdev, in, sizeof(in),
+ 					  out, sizeof(out));
+ }
+ EXPORT_SYMBOL_GPL(mlx5_set_port_wol);
+ 
+ int mlx5_query_port_wol(struct mlx5_core_dev *mdev, u8 *wol_mode)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(query_wol_rol_in)];
+ 	u32 out[MLX5_ST_SZ_DW(query_wol_rol_out)];
+ 	int err;
+ 
+ 	memset(in, 0, sizeof(in));
+ 	memset(out, 0, sizeof(out));
+ 
+ 	MLX5_SET(query_wol_rol_in, in, opcode, MLX5_CMD_OP_QUERY_WOL_ROL);
+ 
+ 	err = mlx5_cmd_exec_check_status(mdev, in, sizeof(in),
+ 					 out, sizeof(out));
+ 
+ 	if (!err)
+ 		*wol_mode = MLX5_GET(query_wol_rol_out, out, wol_mode);
+ 
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(mlx5_query_port_wol);
++>>>>>>> 928cfe8745a6 (net/mlx5e: Wake On LAN support)
diff --cc include/linux/mlx5/mlx5_ifc.h
index 3446b357315b,03ffe9530365..000000000000
--- a/include/linux/mlx5/mlx5_ifc.h
+++ b/include/linux/mlx5/mlx5_ifc.h
@@@ -727,12 -729,24 +729,28 @@@ struct mlx5_ifc_cmd_hca_cap_bits 
  	u8         port_type[0x2];
  	u8         num_ports[0x8];
  
 -	u8         reserved_at_1bf[0x3];
 +	u8         reserved_20[0x3];
  	u8         log_max_msg[0x5];
++<<<<<<< HEAD
 +	u8         reserved_21[0x18];
++=======
+ 	u8         reserved_at_1c7[0x4];
+ 	u8         max_tc[0x4];
+ 	u8         reserved_at_1cf[0x6];
+ 	u8         rol_s[0x1];
+ 	u8         rol_g[0x1];
+ 	u8         reserved_at_1d7[0x1];
+ 	u8         wol_s[0x1];
+ 	u8         wol_g[0x1];
+ 	u8         wol_a[0x1];
+ 	u8         wol_b[0x1];
+ 	u8         wol_m[0x1];
+ 	u8         wol_u[0x1];
+ 	u8         wol_p[0x1];
++>>>>>>> 928cfe8745a6 (net/mlx5e: Wake On LAN support)
  
  	u8         stat_rate_support[0x10];
 -	u8         reserved_at_1ef[0xc];
 +	u8         reserved_22[0xc];
  	u8         cqe_version[0x4];
  
  	u8         compact_address_vector[0x1];
diff --cc include/linux/mlx5/port.h
index 4b3644caa936,a1d145abd4eb..000000000000
--- a/include/linux/mlx5/port.h
+++ b/include/linux/mlx5/port.h
@@@ -70,4 -70,18 +70,21 @@@ int mlx5_set_port_pfc(struct mlx5_core_
  int mlx5_query_port_pfc(struct mlx5_core_dev *dev, u8 *pfc_en_tx,
  			u8 *pfc_en_rx);
  
++<<<<<<< HEAD
++=======
+ int mlx5_max_tc(struct mlx5_core_dev *mdev);
+ 
+ int mlx5_set_port_prio_tc(struct mlx5_core_dev *mdev, u8 *prio_tc);
+ int mlx5_set_port_tc_group(struct mlx5_core_dev *mdev, u8 *tc_group);
+ int mlx5_set_port_tc_bw_alloc(struct mlx5_core_dev *mdev, u8 *tc_bw);
+ int mlx5_modify_port_ets_rate_limit(struct mlx5_core_dev *mdev,
+ 				    u8 *max_bw_value,
+ 				    u8 *max_bw_unit);
+ int mlx5_query_port_ets_rate_limit(struct mlx5_core_dev *mdev,
+ 				   u8 *max_bw_value,
+ 				   u8 *max_bw_unit);
+ int mlx5_set_port_wol(struct mlx5_core_dev *mdev, u8 wol_mode);
+ int mlx5_query_port_wol(struct mlx5_core_dev *mdev, u8 *wol_mode);
+ 
++>>>>>>> 928cfe8745a6 (net/mlx5e: Wake On LAN support)
  #endif /* __MLX5_PORT_H__ */
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
index 52741743c8fd..33e1024b948f 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
@@ -561,6 +561,12 @@ const char *mlx5_command_str(int command)
 	case MLX5_CMD_OP_ACCESS_REG:
 		return "MLX5_CMD_OP_ACCESS_REG";
 
+	case MLX5_CMD_OP_SET_WOL_ROL:
+		return "SET_WOL_ROL";
+
+	case MLX5_CMD_OP_QUERY_WOL_ROL:
+		return "QUERY_WOL_ROL";
+
 	default: return "unknown command opcode";
 	}
 }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/port.c
diff --git a/include/linux/mlx5/device.h b/include/linux/mlx5/device.h
index 399e8ec7a944..70ca64b5feee 100644
--- a/include/linux/mlx5/device.h
+++ b/include/linux/mlx5/device.h
@@ -1166,6 +1166,17 @@ enum {
 	MLX5_RQC_RQ_TYPE_MEMORY_RQ_RPM    = 0x1,
 };
 
+enum mlx5_wol_mode {
+	MLX5_WOL_DISABLE        = 0,
+	MLX5_WOL_SECURED_MAGIC  = 1 << 1,
+	MLX5_WOL_MAGIC          = 1 << 2,
+	MLX5_WOL_ARP            = 1 << 3,
+	MLX5_WOL_BROADCAST      = 1 << 4,
+	MLX5_WOL_MULTICAST      = 1 << 5,
+	MLX5_WOL_UNICAST        = 1 << 6,
+	MLX5_WOL_PHY_ACTIVITY   = 1 << 7,
+};
+
 /* MLX5 DEV CAPs */
 
 /* TODO: EAT.ME */
* Unmerged path include/linux/mlx5/mlx5_ifc.h
* Unmerged path include/linux/mlx5/port.h
