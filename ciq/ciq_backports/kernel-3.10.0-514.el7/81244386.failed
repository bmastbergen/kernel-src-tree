sunrpc: add a rcu_head to svc_rqst and use kfree_rcu to free it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jeff Layton <jlayton@primarydata.com>
commit 812443865c5fc255363d4a684a62c086af1addca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/81244386.failed

...also make the manipulation of sp_all_threads list use RCU-friendly
functions.

	Signed-off-by: Jeff Layton <jlayton@primarydata.com>
	Tested-by: Chris Worley <chris.worley@primarydata.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 812443865c5fc255363d4a684a62c086af1addca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/sunrpc/svc.h
#	include/trace/events/sunrpc.h
diff --cc include/linux/sunrpc/svc.h
index c8f40334cdab,7f80a99c59e4..000000000000
--- a/include/linux/sunrpc/svc.h
+++ b/include/linux/sunrpc/svc.h
@@@ -255,9 -255,16 +256,22 @@@ struct svc_rqst 
  	u32			rq_vers;	/* program version */
  	u32			rq_proc;	/* procedure number */
  	u32			rq_prot;	/* IP protocol */
++<<<<<<< HEAD
 +	unsigned short
 +				rq_secure  : 1;	/* secure port */
 +	unsigned short		rq_local   : 1;	/* local request */
++=======
+ 	int			rq_cachetype;	/* catering to nfsd */
+ #define	RQ_SECURE	(0)			/* secure port */
+ #define	RQ_LOCAL	(1)			/* local request */
+ #define	RQ_USEDEFERRAL	(2)			/* use deferral */
+ #define	RQ_DROPME	(3)			/* drop current reply */
+ #define	RQ_SPLICE_OK	(4)			/* turned off in gss privacy
+ 						 * to prevent encrypting page
+ 						 * cache pages */
+ #define	RQ_VICTIM	(5)			/* about to be shut down */
+ 	unsigned long		rq_flags;	/* flags field */
++>>>>>>> 812443865c5f (sunrpc: add a rcu_head to svc_rqst and use kfree_rcu to free it)
  
  	void *			rq_argp;	/* decoded arguments */
  	void *			rq_resp;	/* xdr'd results */
diff --cc include/trace/events/sunrpc.h
index 6260f5134212,08a5fed50f34..000000000000
--- a/include/trace/events/sunrpc.h
+++ b/include/trace/events/sunrpc.h
@@@ -307,6 -308,119 +307,122 @@@ DEFINE_RPC_SOCKET_EVENT_DONE(rpc_socket
  DEFINE_RPC_SOCKET_EVENT(rpc_socket_close);
  DEFINE_RPC_SOCKET_EVENT(rpc_socket_shutdown);
  
++<<<<<<< HEAD
++=======
+ DECLARE_EVENT_CLASS(rpc_xprt_event,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 
+ 	TP_ARGS(xprt, xid, status),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(__be32, xid)
+ 		__field(int, status)
+ 		__string(addr, xprt->address_strings[RPC_DISPLAY_ADDR])
+ 		__string(port, xprt->address_strings[RPC_DISPLAY_PORT])
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->xid = xid;
+ 		__entry->status = status;
+ 		__assign_str(addr, xprt->address_strings[RPC_DISPLAY_ADDR]);
+ 		__assign_str(port, xprt->address_strings[RPC_DISPLAY_PORT]);
+ 	),
+ 
+ 	TP_printk("peer=[%s]:%s xid=0x%x status=%d", __get_str(addr),
+ 			__get_str(port), be32_to_cpu(__entry->xid),
+ 			__entry->status)
+ );
+ 
+ DEFINE_EVENT(rpc_xprt_event, xprt_lookup_rqst,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 	TP_ARGS(xprt, xid, status));
+ 
+ DEFINE_EVENT(rpc_xprt_event, xprt_transmit,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 	TP_ARGS(xprt, xid, status));
+ 
+ DEFINE_EVENT(rpc_xprt_event, xprt_complete_rqst,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 	TP_ARGS(xprt, xid, status));
+ 
+ TRACE_EVENT(xs_tcp_data_ready,
+ 	TP_PROTO(struct rpc_xprt *xprt, int err, unsigned int total),
+ 
+ 	TP_ARGS(xprt, err, total),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, err)
+ 		__field(unsigned int, total)
+ 		__string(addr, xprt ? xprt->address_strings[RPC_DISPLAY_ADDR] :
+ 				"(null)")
+ 		__string(port, xprt ? xprt->address_strings[RPC_DISPLAY_PORT] :
+ 				"(null)")
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->err = err;
+ 		__entry->total = total;
+ 		__assign_str(addr, xprt ?
+ 			xprt->address_strings[RPC_DISPLAY_ADDR] : "(null)");
+ 		__assign_str(port, xprt ?
+ 			xprt->address_strings[RPC_DISPLAY_PORT] : "(null)");
+ 	),
+ 
+ 	TP_printk("peer=[%s]:%s err=%d total=%u", __get_str(addr),
+ 			__get_str(port), __entry->err, __entry->total)
+ );
+ 
+ #define rpc_show_sock_xprt_flags(flags) \
+ 	__print_flags(flags, "|", \
+ 		{ TCP_RCV_LAST_FRAG, "TCP_RCV_LAST_FRAG" }, \
+ 		{ TCP_RCV_COPY_FRAGHDR, "TCP_RCV_COPY_FRAGHDR" }, \
+ 		{ TCP_RCV_COPY_XID, "TCP_RCV_COPY_XID" }, \
+ 		{ TCP_RCV_COPY_DATA, "TCP_RCV_COPY_DATA" }, \
+ 		{ TCP_RCV_READ_CALLDIR, "TCP_RCV_READ_CALLDIR" }, \
+ 		{ TCP_RCV_COPY_CALLDIR, "TCP_RCV_COPY_CALLDIR" }, \
+ 		{ TCP_RPC_REPLY, "TCP_RPC_REPLY" })
+ 
+ TRACE_EVENT(xs_tcp_data_recv,
+ 	TP_PROTO(struct sock_xprt *xs),
+ 
+ 	TP_ARGS(xs),
+ 
+ 	TP_STRUCT__entry(
+ 		__string(addr, xs->xprt.address_strings[RPC_DISPLAY_ADDR])
+ 		__string(port, xs->xprt.address_strings[RPC_DISPLAY_PORT])
+ 		__field(__be32, xid)
+ 		__field(unsigned long, flags)
+ 		__field(unsigned long, copied)
+ 		__field(unsigned int, reclen)
+ 		__field(unsigned long, offset)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__assign_str(addr, xs->xprt.address_strings[RPC_DISPLAY_ADDR]);
+ 		__assign_str(port, xs->xprt.address_strings[RPC_DISPLAY_PORT]);
+ 		__entry->xid = xs->tcp_xid;
+ 		__entry->flags = xs->tcp_flags;
+ 		__entry->copied = xs->tcp_copied;
+ 		__entry->reclen = xs->tcp_reclen;
+ 		__entry->offset = xs->tcp_offset;
+ 	),
+ 
+ 	TP_printk("peer=[%s]:%s xid=0x%x flags=%s copied=%lu reclen=%u offset=%lu",
+ 			__get_str(addr), __get_str(port), be32_to_cpu(__entry->xid),
+ 			rpc_show_sock_xprt_flags(__entry->flags),
+ 			__entry->copied, __entry->reclen, __entry->offset)
+ );
+ 
+ #define show_rqstp_flags(flags)						\
+ 	__print_flags(flags, "|",					\
+ 		{ (1UL << RQ_SECURE),		"RQ_SECURE"},		\
+ 		{ (1UL << RQ_LOCAL),		"RQ_LOCAL"},		\
+ 		{ (1UL << RQ_USEDEFERRAL),	"RQ_USEDEFERRAL"},	\
+ 		{ (1UL << RQ_DROPME),		"RQ_DROPME"},		\
+ 		{ (1UL << RQ_SPLICE_OK),	"RQ_SPLICE_OK"},	\
+ 		{ (1UL << RQ_VICTIM),		"RQ_VICTIM"})
+ 
++>>>>>>> 812443865c5f (sunrpc: add a rcu_head to svc_rqst and use kfree_rcu to free it)
  TRACE_EVENT(svc_recv,
  	TP_PROTO(struct svc_rqst *rqst, int status),
  
* Unmerged path include/linux/sunrpc/svc.h
* Unmerged path include/trace/events/sunrpc.h
diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c
index 942c67131e18..0d7d8a4750d4 100644
--- a/net/sunrpc/svc.c
+++ b/net/sunrpc/svc.c
@@ -619,7 +619,7 @@ svc_prepare_thread(struct svc_serv *serv, struct svc_pool *pool, int node)
 	serv->sv_nrthreads++;
 	spin_lock_bh(&pool->sp_lock);
 	pool->sp_nrthreads++;
-	list_add(&rqstp->rq_all, &pool->sp_all_threads);
+	list_add_rcu(&rqstp->rq_all, &pool->sp_all_threads);
 	spin_unlock_bh(&pool->sp_lock);
 	rqstp->rq_server = serv;
 	rqstp->rq_pool = pool;
@@ -687,7 +687,8 @@ found_pool:
 		 * so we don't try to kill it again.
 		 */
 		rqstp = list_entry(pool->sp_all_threads.next, struct svc_rqst, rq_all);
-		list_del_init(&rqstp->rq_all);
+		set_bit(RQ_VICTIM, &rqstp->rq_flags);
+		list_del_rcu(&rqstp->rq_all);
 		task = rqstp->rq_task;
 	}
 	spin_unlock_bh(&pool->sp_lock);
@@ -785,10 +786,11 @@ svc_exit_thread(struct svc_rqst *rqstp)
 
 	spin_lock_bh(&pool->sp_lock);
 	pool->sp_nrthreads--;
-	list_del(&rqstp->rq_all);
+	if (!test_and_set_bit(RQ_VICTIM, &rqstp->rq_flags))
+		list_del_rcu(&rqstp->rq_all);
 	spin_unlock_bh(&pool->sp_lock);
 
-	kfree(rqstp);
+	kfree_rcu(rqstp, rq_rcu_head);
 
 	/* Release the server */
 	if (serv)
