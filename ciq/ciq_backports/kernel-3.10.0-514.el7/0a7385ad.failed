NVMe: Simplify device resume on io queue failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Keith Busch <keith.busch@intel.com>
commit 0a7385ad69f0f210c5cfbfd334b42423a6e05e5a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0a7385ad.failed

Releasing IO queues and disks was done in a work queue outside the
controller resume context to delete namespaces if the controller failed
after a resume from suspend. This is unnecessary since we can resume
a device asynchronously.

This patch makes resume use probe_work so it can directly remove
namespaces if the device is manageable but not IO capable. Since the
deleting disks was the only reason we had the convoluted "reset_workfn",
this patch removes that unnecessary indirection.

	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 0a7385ad69f0f210c5cfbfd334b42423a6e05e5a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index f5099f908371,bf35846558c8..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -1100,10 -1283,8 +1100,13 @@@ static void nvme_abort_req(struct reque
  		if (work_busy(&dev->reset_work))
  			goto out;
  		list_del_init(&dev->node);
 -		dev_warn(dev->dev, "I/O %d QID %d timeout, reset controller\n",
 +		dev_warn(&dev->pci_dev->dev,
 +			"I/O %d QID %d timeout, reset controller\n",
  							req->tag, nvmeq->qid);
++<<<<<<< HEAD
 +		PREPARE_WORK(&dev->reset_work, nvme_reset_failed_dev);
++=======
++>>>>>>> 0a7385ad69f0 (NVMe: Simplify device resume on io queue failure)
  		queue_work(nvme_workq, &dev->reset_work);
   out:
  		spin_unlock_irqrestore(&dev_list_lock, flags);
@@@ -1980,11 -2085,9 +1983,14 @@@ static int nvme_kthread(void *data
  				if (work_busy(&dev->reset_work))
  					continue;
  				list_del_init(&dev->node);
 -				dev_warn(dev->dev,
 +				dev_warn(&dev->pci_dev->dev,
  					"Failed status: %x, reset controller\n",
  					readl(&dev->bar->csts));
++<<<<<<< HEAD
 +				PREPARE_WORK(&dev->reset_work,
 +							nvme_reset_failed_dev);
++=======
++>>>>>>> 0a7385ad69f0 (NVMe: Simplify device resume on io queue failure)
  				queue_work(nvme_workq, &dev->reset_work);
  				continue;
  			}
@@@ -2908,10 -3031,9 +2906,16 @@@ static int nvme_dev_resume(struct nvme_
  	if (ret)
  		return ret;
  	if (dev->online_queues < 2) {
++<<<<<<< HEAD
 +		spin_lock(&dev_list_lock);
 +		PREPARE_WORK(&dev->reset_work, nvme_remove_disks);
 +		queue_work(nvme_workq, &dev->reset_work);
 +		spin_unlock(&dev_list_lock);
++=======
+ 		dev_warn(dev->dev, "IO queues not created\n");
+ 		nvme_free_queues(dev, 1);
+ 		nvme_dev_remove(dev);
++>>>>>>> 0a7385ad69f0 (NVMe: Simplify device resume on io queue failure)
  	} else {
  		nvme_unfreeze_queues(dev);
  		nvme_dev_add(dev);
@@@ -2968,7 -3089,6 +2972,10 @@@ static int nvme_reset(struct nvme_dev *
  
  	spin_lock(&dev_list_lock);
  	if (!work_pending(&dev->reset_work)) {
++<<<<<<< HEAD
 +		PREPARE_WORK(&dev->reset_work, nvme_reset_failed_dev);
++=======
++>>>>>>> 0a7385ad69f0 (NVMe: Simplify device resume on io queue failure)
  		queue_work(nvme_workq, &dev->reset_work);
  		ret = 0;
  	}
@@@ -3022,7 -3142,7 +3029,11 @@@ static int nvme_probe(struct pci_dev *p
  
  	INIT_LIST_HEAD(&dev->namespaces);
  	INIT_WORK(&dev->reset_work, nvme_reset_failed_dev);
++<<<<<<< HEAD
 +	dev->pci_dev = pci_dev_get(pdev);
++=======
+ 	dev->dev = get_device(&pdev->dev);
++>>>>>>> 0a7385ad69f0 (NVMe: Simplify device resume on io queue failure)
  	pci_set_drvdata(pdev, dev);
  	result = nvme_set_instance(dev);
  	if (result)
@@@ -3136,12 -3258,10 +3147,16 @@@ static int nvme_resume(struct device *d
  	struct pci_dev *pdev = to_pci_dev(dev);
  	struct nvme_dev *ndev = pci_get_drvdata(pdev);
  
++<<<<<<< HEAD
 +	if (nvme_dev_resume(ndev) && !work_busy(&ndev->reset_work)) {
 +		PREPARE_WORK(&ndev->reset_work, nvme_reset_failed_dev);
 +		queue_work(nvme_workq, &ndev->reset_work);
 +	}
++=======
+ 	schedule_work(&ndev->probe_work);
++>>>>>>> 0a7385ad69f0 (NVMe: Simplify device resume on io queue failure)
  	return 0;
  }
 -#endif
  
  static SIMPLE_DEV_PM_OPS(nvme_dev_pm_ops, nvme_suspend, nvme_resume);
  
* Unmerged path drivers/block/nvme-core.c
