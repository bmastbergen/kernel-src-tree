nfs: provide pnfs_report_layoutstat when NFS42 is disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peng Tao <tao.peng@primarydata.com>
commit 865a7ecb2131a3ba26cc1d49daf18275375109f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/865a7ecb.failed

kbuild test robot reported:
   fs/built-in.o: In function `pnfs_report_layoutstat':
>> (.text+0x151a1c): undefined reference to `nfs42_proc_layoutstats_generic'

	Reported-by: kbuild test robot <fengguang.wu@intel.com>
	Signed-off-by: Peng Tao <tao.peng@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 865a7ecb2131a3ba26cc1d49daf18275375109f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pnfs.c
#	fs/nfs/pnfs.h
diff --cc fs/nfs/pnfs.c
index e661b8a0925b,40bacebb5b97..000000000000
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@@ -2236,3 -2251,60 +2236,63 @@@ struct nfs4_threshold *pnfs_mdsthreshol
  	}
  	return thp;
  }
++<<<<<<< HEAD
++=======
+ 
+ #if IS_ENABLED(CONFIG_NFS_V4_2)
+ int
+ pnfs_report_layoutstat(struct inode *inode)
+ {
+ 	struct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;
+ 	struct nfs_server *server = NFS_SERVER(inode);
+ 	struct nfs_inode *nfsi = NFS_I(inode);
+ 	struct nfs42_layoutstat_data *data;
+ 	struct pnfs_layout_hdr *hdr;
+ 	int status = 0;
+ 
+ 	if (!pnfs_enabled_sb(server) || !ld->prepare_layoutstats)
+ 		goto out;
+ 
+ 	if (test_and_set_bit(NFS_INO_LAYOUTSTATS, &nfsi->flags))
+ 		goto out;
+ 
+ 	spin_lock(&inode->i_lock);
+ 	if (!NFS_I(inode)->layout) {
+ 		spin_unlock(&inode->i_lock);
+ 		goto out;
+ 	}
+ 	hdr = NFS_I(inode)->layout;
+ 	pnfs_get_layout_hdr(hdr);
+ 	spin_unlock(&inode->i_lock);
+ 
+ 	data = kzalloc(sizeof(*data), GFP_KERNEL);
+ 	if (!data) {
+ 		status = -ENOMEM;
+ 		goto out_put;
+ 	}
+ 
+ 	data->args.fh = NFS_FH(inode);
+ 	data->args.inode = inode;
+ 	nfs4_stateid_copy(&data->args.stateid, &hdr->plh_stateid);
+ 	status = ld->prepare_layoutstats(&data->args);
+ 	if (status)
+ 		goto out_free;
+ 
+ 	status = nfs42_proc_layoutstats_generic(NFS_SERVER(inode), data);
+ 
+ out:
+ 	dprintk("%s returns %d\n", __func__, status);
+ 	return status;
+ 
+ out_free:
+ 	kfree(data);
+ out_put:
+ 	pnfs_put_layout_hdr(hdr);
+ 	smp_mb__before_atomic();
+ 	clear_bit(NFS_INO_LAYOUTSTATS, &nfsi->flags);
+ 	smp_mb__after_atomic();
+ 	goto out;
+ }
+ EXPORT_SYMBOL_GPL(pnfs_report_layoutstat);
+ #endif
++>>>>>>> 865a7ecb2131 (nfs: provide pnfs_report_layoutstat when NFS42 is disabled)
diff --cc fs/nfs/pnfs.h
index e9fec461d335,3e6ab7bfbabd..000000000000
--- a/fs/nfs/pnfs.h
+++ b/fs/nfs/pnfs.h
@@@ -290,7 -292,6 +290,10 @@@ int pnfs_write_done_resend_to_mds(struc
  struct nfs4_threshold *pnfs_mdsthreshold_alloc(void);
  void pnfs_error_mark_layout_for_return(struct inode *inode,
  				       struct pnfs_layout_segment *lseg);
++<<<<<<< HEAD
 +
++=======
++>>>>>>> 865a7ecb2131 (nfs: provide pnfs_report_layoutstat when NFS42 is disabled)
  /* nfs4_deviceid_flags */
  enum {
  	NFS_DEVICEID_INVALID = 0,       /* set when MDS clientid recalled */
* Unmerged path fs/nfs/pnfs.c
* Unmerged path fs/nfs/pnfs.h
