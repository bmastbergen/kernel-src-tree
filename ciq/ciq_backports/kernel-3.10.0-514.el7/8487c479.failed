NFSv4: Allow retry of operations that used a returned delegation stateid

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 8487c479e2668dd1231e9c3c77a203d744aec081
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8487c479.failed

Fix up nfs4_do_handle_exception() so that it can check if the operation
that received the NFS4ERR_BAD_STATEID was using a defunct delegation.
Apply that to the case of SETATTR, which will currently return EIO
in some cases where this happens.

	Reported-by: Olga Kornievskaia <kolga@netapp.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 8487c479e2668dd1231e9c3c77a203d744aec081)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/nfs4proc.c
index 305aca6ed864,519368b98762..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -2680,51 -2759,8 +2736,56 @@@ static int nfs4_do_setattr(struct inod
  	if (ilabel)
  		arg.bitmask = nfs4_bitmask(server, olabel);
  
++<<<<<<< HEAD
 +	nfs_fattr_init(fattr);
 +
 +	/* Servers should only apply open mode checks for file size changes */
 +	truncate = (sattr->ia_valid & ATTR_SIZE) ? true : false;
 +	fmode = truncate ? FMODE_WRITE : FMODE_READ;
 +
 +	if (nfs4_copy_delegation_stateid(inode, fmode, &arg.stateid, &delegation_cred)) {
 +		/* Use that stateid */
 +	} else if (truncate && state != NULL) {
 +		struct nfs_lockowner lockowner = {
 +			.l_owner = current->files,
 +			.l_pid = current->tgid,
 +		};
 +		if (!nfs4_valid_open_stateid(state))
 +			return -EBADF;
 +		if (nfs4_select_rw_stateid(state, FMODE_WRITE, &lockowner,
 +				&arg.stateid, &delegation_cred) == -EIO)
 +			return -EBADF;
 +	} else
 +		nfs4_stateid_copy(&arg.stateid, &zero_stateid);
 +	if (delegation_cred)
 +		msg.rpc_cred = delegation_cred;
 +
 +	status = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);
 +
 +	put_rpccred(delegation_cred);
 +	if (status == 0 && state != NULL)
 +		renew_lease(server, timestamp);
 +	return status;
 +}
 +
 +static int nfs4_do_setattr(struct inode *inode, struct rpc_cred *cred,
 +			   struct nfs_fattr *fattr, struct iattr *sattr,
 +			   struct nfs4_state *state, struct nfs4_label *ilabel,
 +			   struct nfs4_label *olabel)
 +{
 +	struct nfs_server *server = NFS_SERVER(inode);
 +	struct nfs4_exception exception = {
 +		.state = state,
 +		.inode = inode,
 +	};
 +	int err;
 +	do {
 +		err = _nfs4_do_setattr(inode, cred, fattr, sattr, state, ilabel, olabel);
 +		trace_nfs4_setattr(inode, err);
++=======
+ 	do {
+ 		err = _nfs4_do_setattr(inode, &arg, &res, cred, state);
++>>>>>>> 8487c479e266 (NFSv4: Allow retry of operations that used a returned delegation stateid)
  		switch (err) {
  		case -NFS4ERR_OPENMODE:
  			if (!(sattr->ia_valid & ATTR_SIZE)) {
diff --git a/fs/nfs/nfs4_fs.h b/fs/nfs/nfs4_fs.h
index 9fb7e26349b1..f0706cab555a 100644
--- a/fs/nfs/nfs4_fs.h
+++ b/fs/nfs/nfs4_fs.h
@@ -185,6 +185,7 @@ struct nfs4_state {
 struct nfs4_exception {
 	struct nfs4_state *state;
 	struct inode *inode;
+	nfs4_stateid *stateid;
 	long timeout;
 	unsigned char delay : 1,
 		      recovering : 1,
* Unmerged path fs/nfs/nfs4proc.c
