netfilter: nft_hash: add support for timeouts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Patrick McHardy <kaber@trash.net>
commit 9d0982927e79049675cb6c6c04a0ebb3dad5a434
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9d098292.failed

Add support for element timeouts to nft_hash. The lookup and walking
functions are changed to ignore timed out elements, a periodic garbage
collection task cleans out expired entries.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 9d0982927e79049675cb6c6c04a0ebb3dad5a434)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_hash.c
diff --cc net/netfilter/nft_hash.c
index f14a5e14123a,5923ec547268..000000000000
--- a/net/netfilter/nft_hash.c
+++ b/net/netfilter/nft_hash.c
@@@ -23,22 -24,68 +24,70 @@@
  /* We target a hash table size of 4, element hint is 75% of final size */
  #define NFT_HASH_ELEMENT_HINT 3
  
++<<<<<<< HEAD
++=======
+ struct nft_hash {
+ 	struct rhashtable		ht;
+ 	struct delayed_work		gc_work;
+ };
+ 
++>>>>>>> 9d0982927e79 (netfilter: nft_hash: add support for timeouts)
  struct nft_hash_elem {
  	struct rhash_head		node;
 -	struct nft_set_ext		ext;
 +	struct nft_data			key;
 +	struct nft_data			data[];
  };
  
++<<<<<<< HEAD
++=======
+ struct nft_hash_cmp_arg {
+ 	const struct nft_set		*set;
+ 	const struct nft_data		*key;
+ 	u8				genmask;
+ };
+ 
+ static const struct rhashtable_params nft_hash_params;
+ 
+ static inline u32 nft_hash_key(const void *data, u32 len, u32 seed)
+ {
+ 	const struct nft_hash_cmp_arg *arg = data;
+ 
+ 	return jhash(arg->key, len, seed);
+ }
+ 
+ static inline u32 nft_hash_obj(const void *data, u32 len, u32 seed)
+ {
+ 	const struct nft_hash_elem *he = data;
+ 
+ 	return jhash(nft_set_ext_key(&he->ext), len, seed);
+ }
+ 
+ static inline int nft_hash_cmp(struct rhashtable_compare_arg *arg,
+ 			       const void *ptr)
+ {
+ 	const struct nft_hash_cmp_arg *x = arg->key;
+ 	const struct nft_hash_elem *he = ptr;
+ 
+ 	if (nft_data_cmp(nft_set_ext_key(&he->ext), x->key, x->set->klen))
+ 		return 1;
+ 	if (nft_set_elem_expired(&he->ext))
+ 		return 1;
+ 	if (!nft_set_elem_active(&he->ext, x->genmask))
+ 		return 1;
+ 	return 0;
+ }
+ 
++>>>>>>> 9d0982927e79 (netfilter: nft_hash: add support for timeouts)
  static bool nft_hash_lookup(const struct nft_set *set,
  			    const struct nft_data *key,
 -			    const struct nft_set_ext **ext)
 +			    struct nft_data *data)
  {
 -	struct nft_hash *priv = nft_set_priv(set);
 +	const struct rhashtable *priv = nft_set_priv(set);
  	const struct nft_hash_elem *he;
 -	struct nft_hash_cmp_arg arg = {
 -		.genmask = nft_genmask_cur(read_pnet(&set->pnet)),
 -		.set	 = set,
 -		.key	 = key,
 -	};
  
 -	he = rhashtable_lookup_fast(&priv->ht, &arg, nft_hash_params);
 -	if (he != NULL)
 -		*ext = &he->ext;
 +	he = rhashtable_lookup(priv, key);
 +	if (he && set->flags & NFT_SET_MAP)
 +		nft_data_copy(data, he->data);
  
  	return !!he;
  }
@@@ -46,159 -93,209 +95,303 @@@
  static int nft_hash_insert(const struct nft_set *set,
  			   const struct nft_set_elem *elem)
  {
++<<<<<<< HEAD
 +	struct rhashtable *priv = nft_set_priv(set);
++=======
+ 	struct nft_hash *priv = nft_set_priv(set);
+ 	struct nft_hash_elem *he = elem->priv;
+ 	struct nft_hash_cmp_arg arg = {
+ 		.genmask = nft_genmask_next(read_pnet(&set->pnet)),
+ 		.set	 = set,
+ 		.key	 = &elem->key,
+ 	};
+ 
+ 	return rhashtable_lookup_insert_key(&priv->ht, &arg, &he->node,
+ 					    nft_hash_params);
+ }
+ 
+ static void nft_hash_activate(const struct nft_set *set,
+ 			      const struct nft_set_elem *elem)
+ {
+ 	struct nft_hash_elem *he = elem->priv;
+ 
+ 	nft_set_elem_change_active(set, &he->ext);
+ 	nft_set_elem_clear_busy(&he->ext);
+ }
+ 
+ static void *nft_hash_deactivate(const struct nft_set *set,
+ 				 const struct nft_set_elem *elem)
+ {
+ 	struct nft_hash *priv = nft_set_priv(set);
++>>>>>>> 9d0982927e79 (netfilter: nft_hash: add support for timeouts)
  	struct nft_hash_elem *he;
 -	struct nft_hash_cmp_arg arg = {
 -		.genmask = nft_genmask_next(read_pnet(&set->pnet)),
 -		.set	 = set,
 -		.key	 = &elem->key,
 -	};
 +	unsigned int size;
  
++<<<<<<< HEAD
 +	if (elem->flags != 0)
 +		return -EINVAL;
++=======
+ 	rcu_read_lock();
+ 	he = rhashtable_lookup_fast(&priv->ht, &arg, nft_hash_params);
+ 	if (he != NULL) {
+ 		if (!nft_set_elem_mark_busy(&he->ext))
+ 			nft_set_elem_change_active(set, &he->ext);
+ 		else
+ 			he = NULL;
+ 	}
+ 	rcu_read_unlock();
++>>>>>>> 9d0982927e79 (netfilter: nft_hash: add support for timeouts)
 +
 +	size = sizeof(*he);
 +	if (set->flags & NFT_SET_MAP)
 +		size += sizeof(he->data[0]);
 +
 +	he = kzalloc(size, GFP_KERNEL);
 +	if (he == NULL)
 +		return -ENOMEM;
  
 -	return he;
 +	nft_data_copy(&he->key, &elem->key);
 +	if (set->flags & NFT_SET_MAP)
 +		nft_data_copy(he->data, &elem->data);
 +
 +	rhashtable_insert(priv, &he->node);
 +
 +	return 0;
 +}
 +
 +static void nft_hash_elem_destroy(const struct nft_set *set,
 +				  struct nft_hash_elem *he)
 +{
 +	nft_data_uninit(&he->key, NFT_DATA_VALUE);
 +	if (set->flags & NFT_SET_MAP)
 +		nft_data_uninit(he->data, set->dtype);
 +	kfree(he);
  }
  
  static void nft_hash_remove(const struct nft_set *set,
  			    const struct nft_set_elem *elem)
  {
 -	struct nft_hash *priv = nft_set_priv(set);
 -	struct nft_hash_elem *he = elem->priv;
 +	struct rhashtable *priv = nft_set_priv(set);
  
 -	rhashtable_remove_fast(&priv->ht, &he->node, nft_hash_params);
 +	rhashtable_remove(priv, elem->cookie);
 +	synchronize_rcu();
 +	kfree(elem->cookie);
  }
  
 -static void nft_hash_walk(const struct nft_ctx *ctx, const struct nft_set *set,
 -			  struct nft_set_iter *iter)
 +struct nft_compare_arg {
 +	const struct nft_set *set;
 +	struct nft_set_elem *elem;
 +};
 +
 +static bool nft_hash_compare(void *ptr, void *arg)
  {
 -	struct nft_hash *priv = nft_set_priv(set);
 -	struct nft_hash_elem *he;
 -	struct rhashtable_iter hti;
 -	struct nft_set_elem elem;
 -	u8 genmask = nft_genmask_cur(read_pnet(&set->pnet));
 -	int err;
 +	struct nft_hash_elem *he = ptr;
 +	struct nft_compare_arg *x = arg;
  
 -	err = rhashtable_walk_init(&priv->ht, &hti);
 -	iter->err = err;
 -	if (err)
 -		return;
 +	if (!nft_data_cmp(&he->key, &x->elem->key, x->set->klen)) {
 +		x->elem->cookie = he;
 +		x->elem->flags = 0;
 +		if (x->set->flags & NFT_SET_MAP)
 +			nft_data_copy(&x->elem->data, he->data);
  
 -	err = rhashtable_walk_start(&hti);
 -	if (err && err != -EAGAIN) {
 -		iter->err = err;
 -		goto out;
 +		return true;
  	}
  
 +	return false;
 +}
 +
 +static int nft_hash_get(const struct nft_set *set, struct nft_set_elem *elem)
 +{
 +	const struct rhashtable *priv = nft_set_priv(set);
 +	struct nft_compare_arg arg = {
 +		.set = set,
 +		.elem = elem,
 +	};
 +
 +	if (rhashtable_lookup_compare(priv, &elem->key,
 +				      &nft_hash_compare, &arg))
 +		return 0;
 +
 +	return -ENOENT;
 +}
 +
 +static void nft_hash_walk(const struct nft_ctx *ctx, const struct nft_set *set,
 +			  struct nft_set_iter *iter)
 +{
 +	const struct rhashtable *priv = nft_set_priv(set);
 +	const struct bucket_table *tbl;
 +	const struct nft_hash_elem *he;
 +	struct nft_set_elem elem;
 +	unsigned int i;
 +
 +	tbl = rht_dereference_rcu(priv->tbl, priv);
 +	for (i = 0; i < tbl->size; i++) {
 +		struct rhash_head *pos;
 +
 +		rht_for_each_entry_rcu(he, pos, tbl, i, node) {
 +			if (iter->count < iter->skip)
 +				goto cont;
 +
++<<<<<<< HEAD
 +			memcpy(&elem.key, &he->key, sizeof(elem.key));
 +			if (set->flags & NFT_SET_MAP)
 +				memcpy(&elem.data, he->data, sizeof(elem.data));
 +			elem.flags = 0;
++=======
+ 	while ((he = rhashtable_walk_next(&hti))) {
+ 		if (IS_ERR(he)) {
+ 			err = PTR_ERR(he);
+ 			if (err != -EAGAIN) {
+ 				iter->err = err;
+ 				goto out;
+ 			}
+ 
+ 			continue;
+ 		}
+ 
+ 		if (iter->count < iter->skip)
+ 			goto cont;
+ 		if (nft_set_elem_expired(&he->ext))
+ 			goto cont;
+ 		if (!nft_set_elem_active(&he->ext, genmask))
+ 			goto cont;
+ 
+ 		elem.priv = he;
+ 
+ 		iter->err = iter->fn(ctx, set, iter, &elem);
+ 		if (iter->err < 0)
+ 			goto out;
++>>>>>>> 9d0982927e79 (netfilter: nft_hash: add support for timeouts)
  
 +			iter->err = iter->fn(ctx, set, iter, &elem);
 +			if (iter->err < 0)
 +				return;
  cont:
 -		iter->count++;
 +			iter->count++;
 +		}
  	}
 -
 -out:
 -	rhashtable_walk_stop(&hti);
 -	rhashtable_walk_exit(&hti);
  }
  
+ static void nft_hash_gc(struct work_struct *work)
+ {
+ 	const struct nft_set *set;
+ 	struct nft_hash_elem *he;
+ 	struct nft_hash *priv;
+ 	struct nft_set_gc_batch *gcb = NULL;
+ 	struct rhashtable_iter hti;
+ 	int err;
+ 
+ 	priv = container_of(work, struct nft_hash, gc_work.work);
+ 	set  = nft_set_container_of(priv);
+ 
+ 	err = rhashtable_walk_init(&priv->ht, &hti);
+ 	if (err)
+ 		goto schedule;
+ 
+ 	err = rhashtable_walk_start(&hti);
+ 	if (err && err != -EAGAIN)
+ 		goto out;
+ 
+ 	while ((he = rhashtable_walk_next(&hti))) {
+ 		if (IS_ERR(he)) {
+ 			if (PTR_ERR(he) != -EAGAIN)
+ 				goto out;
+ 			continue;
+ 		}
+ 
+ 		if (!nft_set_elem_expired(&he->ext))
+ 			continue;
+ 		if (nft_set_elem_mark_busy(&he->ext))
+ 			continue;
+ 
+ 		gcb = nft_set_gc_batch_check(set, gcb, GFP_ATOMIC);
+ 		if (gcb == NULL)
+ 			goto out;
+ 		rhashtable_remove_fast(&priv->ht, &he->node, nft_hash_params);
+ 		nft_set_gc_batch_add(gcb, he);
+ 	}
+ out:
+ 	rhashtable_walk_stop(&hti);
+ 	rhashtable_walk_exit(&hti);
+ 
+ 	nft_set_gc_batch_complete(gcb);
+ schedule:
+ 	queue_delayed_work(system_power_efficient_wq, &priv->gc_work,
+ 			   nft_set_gc_interval(set));
+ }
+ 
  static unsigned int nft_hash_privsize(const struct nlattr * const nla[])
  {
 -	return sizeof(struct nft_hash);
 +	return sizeof(struct rhashtable);
  }
  
 -static const struct rhashtable_params nft_hash_params = {
 -	.head_offset		= offsetof(struct nft_hash_elem, node),
 -	.hashfn			= nft_hash_key,
 -	.obj_hashfn		= nft_hash_obj,
 -	.obj_cmpfn		= nft_hash_cmp,
 -	.automatic_shrinking	= true,
 -};
 +static int lockdep_nfnl_lock_is_held(void)
 +{
 +	return lockdep_nfnl_is_held(NFNL_SUBSYS_NFTABLES);
 +}
  
  static int nft_hash_init(const struct nft_set *set,
  			 const struct nft_set_desc *desc,
  			 const struct nlattr * const tb[])
  {
++<<<<<<< HEAD
 +	struct rhashtable *priv = nft_set_priv(set);
 +	struct rhashtable_params params = {
 +		.nelem_hint = desc->size ? : NFT_HASH_ELEMENT_HINT,
 +		.head_offset = offsetof(struct nft_hash_elem, node),
 +		.key_offset = offsetof(struct nft_hash_elem, key),
 +		.key_len = set->klen,
 +		.hashfn = jhash,
 +		.grow_decision = rht_grow_above_75,
 +		.shrink_decision = rht_shrink_below_30,
 +		.mutex_is_held = lockdep_nfnl_lock_is_held,
 +	};
 +
 +	return rhashtable_init(priv, &params);
++=======
+ 	struct nft_hash *priv = nft_set_priv(set);
+ 	struct rhashtable_params params = nft_hash_params;
+ 	int err;
+ 
+ 	params.nelem_hint = desc->size ?: NFT_HASH_ELEMENT_HINT;
+ 	params.key_len	  = set->klen;
+ 
+ 	err = rhashtable_init(&priv->ht, &params);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	INIT_DEFERRABLE_WORK(&priv->gc_work, nft_hash_gc);
+ 	if (set->flags & NFT_SET_TIMEOUT)
+ 		queue_delayed_work(system_power_efficient_wq, &priv->gc_work,
+ 				   nft_set_gc_interval(set));
+ 	return 0;
+ }
+ 
+ static void nft_hash_elem_destroy(void *ptr, void *arg)
+ {
+ 	nft_set_elem_destroy((const struct nft_set *)arg, ptr);
++>>>>>>> 9d0982927e79 (netfilter: nft_hash: add support for timeouts)
  }
  
  static void nft_hash_destroy(const struct nft_set *set)
  {
 -	struct nft_hash *priv = nft_set_priv(set);
 +	const struct rhashtable *priv = nft_set_priv(set);
 +	const struct bucket_table *tbl = priv->tbl;
 +	struct nft_hash_elem *he;
 +	struct rhash_head *pos, *next;
 +	unsigned int i;
  
++<<<<<<< HEAD
 +	for (i = 0; i < tbl->size; i++) {
 +		rht_for_each_entry_safe(he, pos, next, tbl, i, node)
 +			nft_hash_elem_destroy(set, he);
 +	}
 +	rhashtable_destroy(priv);
++=======
+ 	cancel_delayed_work_sync(&priv->gc_work);
+ 	rhashtable_free_and_destroy(&priv->ht, nft_hash_elem_destroy,
+ 				    (void *)set);
++>>>>>>> 9d0982927e79 (netfilter: nft_hash: add support for timeouts)
  }
  
  static bool nft_hash_estimate(const struct nft_set_desc *desc, u32 features,
diff --git a/include/net/netfilter/nf_tables.h b/include/net/netfilter/nf_tables.h
index e78033d80cd2..bdfd7437ada3 100644
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -290,6 +290,11 @@ static inline void *nft_set_priv(const struct nft_set *set)
 	return (void *)set->data;
 }
 
+static inline struct nft_set *nft_set_container_of(const void *priv)
+{
+	return (void *)priv - offsetof(struct nft_set, data);
+}
+
 struct nft_set *nf_tables_set_lookup(const struct nft_table *table,
 				     const struct nlattr *nla);
 struct nft_set *nf_tables_set_lookup_byid(const struct net *net,
* Unmerged path net/netfilter/nft_hash.c
