netfilter: nft_limit: allow to invert matching criteria

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit c7862a5f0de5f521c545f3436f0aa190964342dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c7862a5f.failed

This patch allows you to invert the ratelimit matching criteria, so you
can match packets over the ratelimit. This is required to support what
hashlimit does.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit c7862a5f0de5f521c545f3436f0aa190964342dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/netfilter/nf_tables.h
#	net/netfilter/nft_limit.c
diff --cc include/uapi/linux/netfilter/nf_tables.h
index 4926d9e6ba9a,22043ce95ae6..000000000000
--- a/include/uapi/linux/netfilter/nf_tables.h
+++ b/include/uapi/linux/netfilter/nf_tables.h
@@@ -700,16 -775,31 +700,40 @@@ enum nft_ct_attributes 
  };
  #define NFTA_CT_MAX		(__NFTA_CT_MAX - 1)
  
++<<<<<<< HEAD
++=======
+ enum nft_limit_type {
+ 	NFT_LIMIT_PKTS,
+ 	NFT_LIMIT_PKT_BYTES
+ };
+ 
+ enum nft_limit_flags {
+ 	NFT_LIMIT_F_INV	= (1 << 0),
+ };
+ 
++>>>>>>> c7862a5f0de5 (netfilter: nft_limit: allow to invert matching criteria)
  /**
   * enum nft_limit_attributes - nf_tables limit expression netlink attributes
   *
   * @NFTA_LIMIT_RATE: refill rate (NLA_U64)
   * @NFTA_LIMIT_UNIT: refill unit (NLA_U64)
++<<<<<<< HEAD
++=======
+  * @NFTA_LIMIT_BURST: burst (NLA_U32)
+  * @NFTA_LIMIT_TYPE: type of limit (NLA_U32: enum nft_limit_type)
+  * @NFTA_LIMIT_FLAGS: flags (NLA_U32: enum nft_limit_flags)
++>>>>>>> c7862a5f0de5 (netfilter: nft_limit: allow to invert matching criteria)
   */
  enum nft_limit_attributes {
  	NFTA_LIMIT_UNSPEC,
  	NFTA_LIMIT_RATE,
  	NFTA_LIMIT_UNIT,
++<<<<<<< HEAD
++=======
+ 	NFTA_LIMIT_BURST,
+ 	NFTA_LIMIT_TYPE,
+ 	NFTA_LIMIT_FLAGS,
++>>>>>>> c7862a5f0de5 (netfilter: nft_limit: allow to invert matching criteria)
  	__NFTA_LIMIT_MAX
  };
  #define NFTA_LIMIT_MAX		(__NFTA_LIMIT_MAX - 1)
diff --cc net/netfilter/nft_limit.c
index 5301b69b3692,99d18578afc6..000000000000
--- a/net/netfilter/nft_limit.c
+++ b/net/netfilter/nft_limit.c
@@@ -25,68 -25,83 +25,117 @@@ struct nft_limit 
  	u64		tokens_max;
  	u64		rate;
  	u64		nsecs;
++<<<<<<< HEAD
++=======
+ 	u32		burst;
+ 	bool		invert;
++>>>>>>> c7862a5f0de5 (netfilter: nft_limit: allow to invert matching criteria)
  };
  
 -static inline bool nft_limit_eval(struct nft_limit *limit, u64 cost)
 +static void nft_limit_eval(const struct nft_expr *expr,
 +			   struct nft_data data[NFT_REG_MAX + 1],
 +			   const struct nft_pktinfo *pkt)
  {
 -	u64 now, tokens;
 +	struct nft_limit *priv = nft_expr_priv(expr);
 +	u64 now, tokens, cost = div_u64(priv->nsecs, priv->rate);
  	s64 delta;
  
  	spin_lock_bh(&limit_lock);
  	now = ktime_get_ns();
 -	tokens = limit->tokens + now - limit->last;
 -	if (tokens > limit->tokens_max)
 -		tokens = limit->tokens_max;
 +	tokens = priv->tokens + now - priv->last;
 +	if (tokens > priv->tokens_max)
 +		tokens = priv->tokens_max;
  
 -	limit->last = now;
 +	priv->last = now;
  	delta = tokens - cost;
  	if (delta >= 0) {
 -		limit->tokens = delta;
 +		priv->tokens = delta;
  		spin_unlock_bh(&limit_lock);
++<<<<<<< HEAD
 +		return;
++=======
+ 		return limit->invert;
++>>>>>>> c7862a5f0de5 (netfilter: nft_limit: allow to invert matching criteria)
  	}
 -	limit->tokens = tokens;
 +	priv->tokens = tokens;
  	spin_unlock_bh(&limit_lock);
++<<<<<<< HEAD
 +
 +	data[NFT_REG_VERDICT].verdict = NFT_BREAK;
++=======
+ 	return !limit->invert;
++>>>>>>> c7862a5f0de5 (netfilter: nft_limit: allow to invert matching criteria)
  }
  
 -static int nft_limit_init(struct nft_limit *limit,
 +static const struct nla_policy nft_limit_policy[NFTA_LIMIT_MAX + 1] = {
 +	[NFTA_LIMIT_RATE]	= { .type = NLA_U64 },
 +	[NFTA_LIMIT_UNIT]	= { .type = NLA_U64 },
 +};
 +
 +static int nft_limit_init(const struct nft_ctx *ctx,
 +			  const struct nft_expr *expr,
  			  const struct nlattr * const tb[])
  {
 +	struct nft_limit *priv = nft_expr_priv(expr);
  	u64 unit;
  
  	if (tb[NFTA_LIMIT_RATE] == NULL ||
  	    tb[NFTA_LIMIT_UNIT] == NULL)
  		return -EINVAL;
  
 -	limit->rate = be64_to_cpu(nla_get_be64(tb[NFTA_LIMIT_RATE]));
 +	priv->rate = be64_to_cpu(nla_get_be64(tb[NFTA_LIMIT_RATE]));
  	unit = be64_to_cpu(nla_get_be64(tb[NFTA_LIMIT_UNIT]));
 -	limit->nsecs = unit * NSEC_PER_SEC;
 -	if (limit->rate == 0 || limit->nsecs < unit)
 +	priv->nsecs = unit * NSEC_PER_SEC;
 +	if (priv->rate == 0 || priv->nsecs < unit)
  		return -EOVERFLOW;
++<<<<<<< HEAD
 +	priv->tokens = priv->tokens_max = priv->nsecs;
 +	priv->last = ktime_get_ns();
++=======
+ 	limit->tokens = limit->tokens_max = limit->nsecs;
+ 
+ 	if (tb[NFTA_LIMIT_BURST]) {
+ 		u64 rate;
+ 
+ 		limit->burst = ntohl(nla_get_be32(tb[NFTA_LIMIT_BURST]));
+ 
+ 		rate = limit->rate + limit->burst;
+ 		if (rate < limit->rate)
+ 			return -EOVERFLOW;
+ 
+ 		limit->rate = rate;
+ 	}
+ 	if (tb[NFTA_LIMIT_FLAGS]) {
+ 		u32 flags = ntohl(nla_get_be32(tb[NFTA_LIMIT_FLAGS]));
+ 
+ 		if (flags & NFT_LIMIT_F_INV)
+ 			limit->invert = true;
+ 	}
+ 	limit->last = ktime_get_ns();
+ 
++>>>>>>> c7862a5f0de5 (netfilter: nft_limit: allow to invert matching criteria)
  	return 0;
  }
  
 -static int nft_limit_dump(struct sk_buff *skb, const struct nft_limit *limit,
 -			  enum nft_limit_type type)
 +static int nft_limit_dump(struct sk_buff *skb, const struct nft_expr *expr)
  {
++<<<<<<< HEAD
 +	const struct nft_limit *priv = nft_expr_priv(expr);
 +	u64 secs = div_u64(priv->nsecs, NSEC_PER_SEC);
 +
 +	if (nla_put_be64(skb, NFTA_LIMIT_RATE, cpu_to_be64(priv->rate)) ||
 +	    nla_put_be64(skb, NFTA_LIMIT_UNIT, cpu_to_be64(secs)))
++=======
+ 	u32 flags = limit->invert ? NFT_LIMIT_F_INV : 0;
+ 	u64 secs = div_u64(limit->nsecs, NSEC_PER_SEC);
+ 	u64 rate = limit->rate - limit->burst;
+ 
+ 	if (nla_put_be64(skb, NFTA_LIMIT_RATE, cpu_to_be64(rate)) ||
+ 	    nla_put_be64(skb, NFTA_LIMIT_UNIT, cpu_to_be64(secs)) ||
+ 	    nla_put_be32(skb, NFTA_LIMIT_BURST, htonl(limit->burst)) ||
+ 	    nla_put_be32(skb, NFTA_LIMIT_TYPE, htonl(type)) ||
+ 	    nla_put_be32(skb, NFTA_LIMIT_FLAGS, htonl(flags)))
++>>>>>>> c7862a5f0de5 (netfilter: nft_limit: allow to invert matching criteria)
  		goto nla_put_failure;
  	return 0;
  
@@@ -94,18 -109,115 +143,66 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ struct nft_limit_pkts {
+ 	struct nft_limit	limit;
+ 	u64			cost;
+ };
+ 
+ static void nft_limit_pkts_eval(const struct nft_expr *expr,
+ 				struct nft_regs *regs,
+ 				const struct nft_pktinfo *pkt)
+ {
+ 	struct nft_limit_pkts *priv = nft_expr_priv(expr);
+ 
+ 	if (nft_limit_eval(&priv->limit, priv->cost))
+ 		regs->verdict.code = NFT_BREAK;
+ }
+ 
+ static const struct nla_policy nft_limit_policy[NFTA_LIMIT_MAX + 1] = {
+ 	[NFTA_LIMIT_RATE]	= { .type = NLA_U64 },
+ 	[NFTA_LIMIT_UNIT]	= { .type = NLA_U64 },
+ 	[NFTA_LIMIT_BURST]	= { .type = NLA_U32 },
+ 	[NFTA_LIMIT_TYPE]	= { .type = NLA_U32 },
+ 	[NFTA_LIMIT_FLAGS]	= { .type = NLA_U32 },
+ };
+ 
+ static int nft_limit_pkts_init(const struct nft_ctx *ctx,
+ 			       const struct nft_expr *expr,
+ 			       const struct nlattr * const tb[])
+ {
+ 	struct nft_limit_pkts *priv = nft_expr_priv(expr);
+ 	int err;
+ 
+ 	err = nft_limit_init(&priv->limit, tb);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	priv->cost = div_u64(priv->limit.nsecs, priv->limit.rate);
+ 	return 0;
+ }
+ 
+ static int nft_limit_pkts_dump(struct sk_buff *skb, const struct nft_expr *expr)
+ {
+ 	const struct nft_limit_pkts *priv = nft_expr_priv(expr);
+ 
+ 	return nft_limit_dump(skb, &priv->limit, NFT_LIMIT_PKTS);
+ }
+ 
++>>>>>>> c7862a5f0de5 (netfilter: nft_limit: allow to invert matching criteria)
  static struct nft_expr_type nft_limit_type;
 -static const struct nft_expr_ops nft_limit_pkts_ops = {
 -	.type		= &nft_limit_type,
 -	.size		= NFT_EXPR_SIZE(sizeof(struct nft_limit_pkts)),
 -	.eval		= nft_limit_pkts_eval,
 -	.init		= nft_limit_pkts_init,
 -	.dump		= nft_limit_pkts_dump,
 -};
 -
 -static void nft_limit_pkt_bytes_eval(const struct nft_expr *expr,
 -				     struct nft_regs *regs,
 -				     const struct nft_pktinfo *pkt)
 -{
 -	struct nft_limit *priv = nft_expr_priv(expr);
 -	u64 cost = div_u64(priv->nsecs * pkt->skb->len, priv->rate);
 -
 -	if (nft_limit_eval(priv, cost))
 -		regs->verdict.code = NFT_BREAK;
 -}
 -
 -static int nft_limit_pkt_bytes_init(const struct nft_ctx *ctx,
 -				    const struct nft_expr *expr,
 -				    const struct nlattr * const tb[])
 -{
 -	struct nft_limit *priv = nft_expr_priv(expr);
 -
 -	return nft_limit_init(priv, tb);
 -}
 -
 -static int nft_limit_pkt_bytes_dump(struct sk_buff *skb,
 -				    const struct nft_expr *expr)
 -{
 -	const struct nft_limit *priv = nft_expr_priv(expr);
 -
 -	return nft_limit_dump(skb, priv, NFT_LIMIT_PKT_BYTES);
 -}
 -
 -static const struct nft_expr_ops nft_limit_pkt_bytes_ops = {
 +static const struct nft_expr_ops nft_limit_ops = {
  	.type		= &nft_limit_type,
  	.size		= NFT_EXPR_SIZE(sizeof(struct nft_limit)),
 -	.eval		= nft_limit_pkt_bytes_eval,
 -	.init		= nft_limit_pkt_bytes_init,
 -	.dump		= nft_limit_pkt_bytes_dump,
 +	.eval		= nft_limit_eval,
 +	.init		= nft_limit_init,
 +	.dump		= nft_limit_dump,
  };
  
 -static const struct nft_expr_ops *
 -nft_limit_select_ops(const struct nft_ctx *ctx,
 -		     const struct nlattr * const tb[])
 -{
 -	if (tb[NFTA_LIMIT_TYPE] == NULL)
 -		return &nft_limit_pkts_ops;
 -
 -	switch (ntohl(nla_get_be32(tb[NFTA_LIMIT_TYPE]))) {
 -	case NFT_LIMIT_PKTS:
 -		return &nft_limit_pkts_ops;
 -	case NFT_LIMIT_PKT_BYTES:
 -		return &nft_limit_pkt_bytes_ops;
 -	}
 -	return ERR_PTR(-EOPNOTSUPP);
 -}
 -
  static struct nft_expr_type nft_limit_type __read_mostly = {
  	.name		= "limit",
 -	.select_ops	= nft_limit_select_ops,
 +	.ops		= &nft_limit_ops,
  	.policy		= nft_limit_policy,
  	.maxattr	= NFTA_LIMIT_MAX,
  	.flags		= NFT_EXPR_STATEFUL,
* Unmerged path include/uapi/linux/netfilter/nf_tables.h
* Unmerged path net/netfilter/nft_limit.c
