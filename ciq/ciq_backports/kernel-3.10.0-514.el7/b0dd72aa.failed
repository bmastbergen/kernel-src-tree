HID: replace hid_output_raw_report with hid_hw_raw_request for feature requests

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hid] replace hid_output_raw_report with hid_hw_raw_request for feature requests (Benjamin Tissoires) [1311883]
Rebuild_FUZZ: 96.73%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit b0dd72aafd785785bedbb6db932955807e454a65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b0dd72aa.failed

  ret = hid_output_raw_report(A, B, C, HID_FEATURE_REPORT);
is equivalent to
  ret = hid_hw_raw_request(A, B[0], B, C, HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
whatever the transport layer is.

So use the new API where available

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit b0dd72aafd785785bedbb6db932955807e454a65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/hid-lg.c
#	drivers/hid/hid-magicmouse.c
#	drivers/hid/hid-sony.c
#	drivers/hid/hid-thingm.c
#	drivers/hid/hid-wacom.c
diff --cc drivers/hid/hid-lg.c
index 12fc48c968e6,a976f48263f6..000000000000
--- a/drivers/hid/hid-lg.c
+++ b/drivers/hid/hid-lg.c
@@@ -692,7 -692,8 +692,12 @@@ static int lg_probe(struct hid_device *
  	if (hdev->product == USB_DEVICE_ID_LOGITECH_WII_WHEEL) {
  		unsigned char buf[] = { 0x00, 0xAF,  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
  
++<<<<<<< HEAD
 +		ret = hdev->hid_output_raw_report(hdev, buf, sizeof(buf), HID_FEATURE_REPORT);
++=======
+ 		ret = hid_hw_raw_request(hdev, buf[0], buf, sizeof(buf),
+ 					HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
++>>>>>>> b0dd72aafd78 (HID: replace hid_output_raw_report with hid_hw_raw_request for feature requests)
  
  		if (ret >= 0) {
  			/* insert a little delay of 10 jiffies ~ 40ms */
@@@ -704,7 -705,8 +709,12 @@@
  			buf[1] = 0xB2;
  			get_random_bytes(&buf[2], 2);
  
++<<<<<<< HEAD
 +			ret = hdev->hid_output_raw_report(hdev, buf, sizeof(buf), HID_FEATURE_REPORT);
++=======
+ 			ret = hid_hw_raw_request(hdev, buf[0], buf, sizeof(buf),
+ 					HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
++>>>>>>> b0dd72aafd78 (HID: replace hid_output_raw_report with hid_hw_raw_request for feature requests)
  		}
  	}
  
diff --cc drivers/hid/hid-magicmouse.c
index c24f3dfd9367,ecc2cbf300cc..000000000000
--- a/drivers/hid/hid-magicmouse.c
+++ b/drivers/hid/hid-magicmouse.c
@@@ -548,8 -538,8 +548,13 @@@ static int magicmouse_probe(struct hid_
  	 * but there seems to be no other way of switching the mode.
  	 * Thus the super-ugly hacky success check below.
  	 */
++<<<<<<< HEAD
 +	ret = hdev->hid_output_raw_report(hdev, feature, sizeof(feature),
 +			HID_FEATURE_REPORT);
++=======
+ 	ret = hid_hw_raw_request(hdev, feature[0], feature, sizeof(feature),
+ 				HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
++>>>>>>> b0dd72aafd78 (HID: replace hid_output_raw_report with hid_hw_raw_request for feature requests)
  	if (ret != -EIO && ret != sizeof(feature)) {
  		hid_err(hdev, "unable to request touch data (%d)\n", ret);
  		goto err_stop_hw;
diff --cc drivers/hid/hid-sony.c
index 312098e4af4f,e3e89b6a41c2..000000000000
--- a/drivers/hid/hid-sony.c
+++ b/drivers/hid/hid-sony.c
@@@ -189,7 -720,323 +189,327 @@@ static int sixaxis_set_operational_usb(
  static int sixaxis_set_operational_bt(struct hid_device *hdev)
  {
  	unsigned char buf[] = { 0xf4,  0x42, 0x03, 0x00, 0x00 };
++<<<<<<< HEAD
 +	return hdev->hid_output_raw_report(hdev, buf, sizeof(buf), HID_FEATURE_REPORT);
++=======
+ 	return hid_hw_raw_request(hdev, buf[0], buf, sizeof(buf),
+ 				  HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
+ }
+ 
+ static void buzz_set_leds(struct hid_device *hdev, const __u8 *leds)
+ {
+ 	struct list_head *report_list =
+ 		&hdev->report_enum[HID_OUTPUT_REPORT].report_list;
+ 	struct hid_report *report = list_entry(report_list->next,
+ 		struct hid_report, list);
+ 	__s32 *value = report->field[0]->value;
+ 
+ 	value[0] = 0x00;
+ 	value[1] = leds[0] ? 0xff : 0x00;
+ 	value[2] = leds[1] ? 0xff : 0x00;
+ 	value[3] = leds[2] ? 0xff : 0x00;
+ 	value[4] = leds[3] ? 0xff : 0x00;
+ 	value[5] = 0x00;
+ 	value[6] = 0x00;
+ 	hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
+ }
+ 
+ static void sony_set_leds(struct hid_device *hdev, const __u8 *leds, int count)
+ {
+ 	struct sony_sc *drv_data = hid_get_drvdata(hdev);
+ 	int n;
+ 
+ 	BUG_ON(count > MAX_LEDS);
+ 
+ 	if (drv_data->quirks & BUZZ_CONTROLLER && count == 4) {
+ 		buzz_set_leds(hdev, leds);
+ 	} else if ((drv_data->quirks & SIXAXIS_CONTROLLER_USB) ||
+ 		   (drv_data->quirks & DUALSHOCK4_CONTROLLER_USB)) {
+ 		for (n = 0; n < count; n++)
+ 			drv_data->led_state[n] = leds[n];
+ 		schedule_work(&drv_data->state_worker);
+ 	}
+ }
+ 
+ static void sony_led_set_brightness(struct led_classdev *led,
+ 				    enum led_brightness value)
+ {
+ 	struct device *dev = led->dev->parent;
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct sony_sc *drv_data;
+ 
+ 	int n;
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	if (!drv_data) {
+ 		hid_err(hdev, "No device data\n");
+ 		return;
+ 	}
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		if (led == drv_data->leds[n]) {
+ 			if (value != drv_data->led_state[n]) {
+ 				drv_data->led_state[n] = value;
+ 				sony_set_leds(hdev, drv_data->led_state, drv_data->led_count);
+ 			}
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ static enum led_brightness sony_led_get_brightness(struct led_classdev *led)
+ {
+ 	struct device *dev = led->dev->parent;
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct sony_sc *drv_data;
+ 
+ 	int n;
+ 	int on = 0;
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	if (!drv_data) {
+ 		hid_err(hdev, "No device data\n");
+ 		return LED_OFF;
+ 	}
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		if (led == drv_data->leds[n]) {
+ 			on = !!(drv_data->led_state[n]);
+ 			break;
+ 		}
+ 	}
+ 
+ 	return on ? LED_FULL : LED_OFF;
+ }
+ 
+ static void sony_leds_remove(struct hid_device *hdev)
+ {
+ 	struct sony_sc *drv_data;
+ 	struct led_classdev *led;
+ 	int n;
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	BUG_ON(!(drv_data->quirks & SONY_LED_SUPPORT));
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		led = drv_data->leds[n];
+ 		drv_data->leds[n] = NULL;
+ 		if (!led)
+ 			continue;
+ 		led_classdev_unregister(led);
+ 		kfree(led);
+ 	}
+ 
+ 	drv_data->led_count = 0;
+ }
+ 
+ static int sony_leds_init(struct hid_device *hdev)
+ {
+ 	struct sony_sc *drv_data;
+ 	int n, ret = 0;
+ 	int max_brightness;
+ 	int use_colors;
+ 	struct led_classdev *led;
+ 	size_t name_sz;
+ 	char *name;
+ 	size_t name_len;
+ 	const char *name_fmt;
+ 	static const char * const color_str[] = { "red", "green", "blue" };
+ 	static const __u8 initial_values[MAX_LEDS] = { 0x00, 0x00, 0x00, 0x00 };
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	BUG_ON(!(drv_data->quirks & SONY_LED_SUPPORT));
+ 
+ 	if (drv_data->quirks & BUZZ_CONTROLLER) {
+ 		drv_data->led_count = 4;
+ 		max_brightness = 1;
+ 		use_colors = 0;
+ 		name_len = strlen("::buzz#");
+ 		name_fmt = "%s::buzz%d";
+ 		/* Validate expected report characteristics. */
+ 		if (!hid_validate_values(hdev, HID_OUTPUT_REPORT, 0, 0, 7))
+ 			return -ENODEV;
+ 	} else if (drv_data->quirks & DUALSHOCK4_CONTROLLER_USB) {
+ 		drv_data->led_count = 3;
+ 		max_brightness = 255;
+ 		use_colors = 1;
+ 		name_len = 0;
+ 		name_fmt = "%s:%s";
+ 	} else {
+ 		drv_data->led_count = 4;
+ 		max_brightness = 1;
+ 		use_colors = 0;
+ 		name_len = strlen("::sony#");
+ 		name_fmt = "%s::sony%d";
+ 	}
+ 
+ 	/* Clear LEDs as we have no way of reading their initial state. This is
+ 	 * only relevant if the driver is loaded after somebody actively set the
+ 	 * LEDs to on */
+ 	sony_set_leds(hdev, initial_values, drv_data->led_count);
+ 
+ 	name_sz = strlen(dev_name(&hdev->dev)) + name_len + 1;
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 
+ 		if (use_colors)
+ 			name_sz = strlen(dev_name(&hdev->dev)) + strlen(color_str[n]) + 2;
+ 
+ 		led = kzalloc(sizeof(struct led_classdev) + name_sz, GFP_KERNEL);
+ 		if (!led) {
+ 			hid_err(hdev, "Couldn't allocate memory for LED %d\n", n);
+ 			ret = -ENOMEM;
+ 			goto error_leds;
+ 		}
+ 
+ 		name = (void *)(&led[1]);
+ 		if (use_colors)
+ 			snprintf(name, name_sz, name_fmt, dev_name(&hdev->dev), color_str[n]);
+ 		else
+ 			snprintf(name, name_sz, name_fmt, dev_name(&hdev->dev), n + 1);
+ 		led->name = name;
+ 		led->brightness = 0;
+ 		led->max_brightness = max_brightness;
+ 		led->brightness_get = sony_led_get_brightness;
+ 		led->brightness_set = sony_led_set_brightness;
+ 
+ 		ret = led_classdev_register(&hdev->dev, led);
+ 		if (ret) {
+ 			hid_err(hdev, "Failed to register LED %d\n", n);
+ 			kfree(led);
+ 			goto error_leds;
+ 		}
+ 
+ 		drv_data->leds[n] = led;
+ 	}
+ 
+ 	return ret;
+ 
+ error_leds:
+ 	sony_leds_remove(hdev);
+ 
+ 	return ret;
+ }
+ 
+ static void sixaxis_state_worker(struct work_struct *work)
+ {
+ 	struct sony_sc *sc = container_of(work, struct sony_sc, state_worker);
+ 	unsigned char buf[] = {
+ 		0x01,
+ 		0x00, 0xff, 0x00, 0xff, 0x00,
+ 		0x00, 0x00, 0x00, 0x00, 0x00,
+ 		0xff, 0x27, 0x10, 0x00, 0x32,
+ 		0xff, 0x27, 0x10, 0x00, 0x32,
+ 		0xff, 0x27, 0x10, 0x00, 0x32,
+ 		0xff, 0x27, 0x10, 0x00, 0x32,
+ 		0x00, 0x00, 0x00, 0x00, 0x00
+ 	};
+ 
+ #ifdef CONFIG_SONY_FF
+ 	buf[3] = sc->right ? 1 : 0;
+ 	buf[5] = sc->left;
+ #endif
+ 
+ 	buf[10] |= sc->led_state[0] << 1;
+ 	buf[10] |= sc->led_state[1] << 2;
+ 	buf[10] |= sc->led_state[2] << 3;
+ 	buf[10] |= sc->led_state[3] << 4;
+ 
+ 	hid_output_raw_report(sc->hdev, buf, sizeof(buf), HID_OUTPUT_REPORT);
+ }
+ 
+ static void dualshock4_state_worker(struct work_struct *work)
+ {
+ 	struct sony_sc *sc = container_of(work, struct sony_sc, state_worker);
+ 	struct hid_device *hdev = sc->hdev;
+ 	struct hid_report *report = sc->output_report;
+ 	__s32 *value = report->field[0]->value;
+ 
+ 	value[0] = 0x03;
+ 
+ #ifdef CONFIG_SONY_FF
+ 	value[3] = sc->right;
+ 	value[4] = sc->left;
+ #endif
+ 
+ 	value[5] = sc->led_state[0];
+ 	value[6] = sc->led_state[1];
+ 	value[7] = sc->led_state[2];
+ 
+ 	hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
+ }
+ 
+ #ifdef CONFIG_SONY_FF
+ static int sony_play_effect(struct input_dev *dev, void *data,
+ 			    struct ff_effect *effect)
+ {
+ 	struct hid_device *hid = input_get_drvdata(dev);
+ 	struct sony_sc *sc = hid_get_drvdata(hid);
+ 
+ 	if (effect->type != FF_RUMBLE)
+ 		return 0;
+ 
+ 	sc->left = effect->u.rumble.strong_magnitude / 256;
+ 	sc->right = effect->u.rumble.weak_magnitude / 256;
+ 
+ 	schedule_work(&sc->state_worker);
+ 	return 0;
+ }
+ 
+ static int sony_init_ff(struct hid_device *hdev)
+ {
+ 	struct hid_input *hidinput = list_entry(hdev->inputs.next,
+ 						struct hid_input, list);
+ 	struct input_dev *input_dev = hidinput->input;
+ 
+ 	input_set_capability(input_dev, EV_FF, FF_RUMBLE);
+ 	return input_ff_create_memless(input_dev, NULL, sony_play_effect);
+ }
+ 
+ static void sony_destroy_ff(struct hid_device *hdev)
+ {
+ 	struct sony_sc *sc = hid_get_drvdata(hdev);
+ 
+ 	cancel_work_sync(&sc->state_worker);
+ }
+ 
+ #else
+ static int sony_init_ff(struct hid_device *hdev)
+ {
+ 	return 0;
+ }
+ 
+ static void sony_destroy_ff(struct hid_device *hdev)
+ {
+ }
+ #endif
+ 
+ static int sony_set_output_report(struct sony_sc *sc, int req_id, int req_size)
+ {
+ 	struct list_head *head, *list;
+ 	struct hid_report *report;
+ 	struct hid_device *hdev = sc->hdev;
+ 
+ 	list = &hdev->report_enum[HID_OUTPUT_REPORT].report_list;
+ 
+ 	list_for_each(head, list) {
+ 		report = list_entry(head, struct hid_report, list);
+ 
+ 		if (report->id == req_id) {
+ 			if (report->size < req_size) {
+ 				hid_err(hdev, "Output report 0x%02x (%i bits) is smaller than requested size (%i bits)\n",
+ 					req_id, report->size, req_size);
+ 				return -EINVAL;
+ 			}
+ 			sc->output_report = report;
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	hid_err(hdev, "Unable to locate output report 0x%02x\n", req_id);
+ 
+ 	return -EINVAL;
++>>>>>>> b0dd72aafd78 (HID: replace hid_output_raw_report with hid_hw_raw_request for feature requests)
  }
  
  static int sony_probe(struct hid_device *hdev, const struct hid_device_id *id)
diff --cc drivers/hid/hid-thingm.c
index 99342cfa0ea2,a97c78845f7b..000000000000
--- a/drivers/hid/hid-thingm.c
+++ b/drivers/hid/hid-thingm.c
@@@ -48,8 -48,8 +48,13 @@@ static int blink1_send_command(struct b
  			buf[0], buf[1], buf[2], buf[3], buf[4],
  			buf[5], buf[6], buf[7], buf[8]);
  
++<<<<<<< HEAD
 +	ret = data->hdev->hid_output_raw_report(data->hdev, buf,
 +			BLINK1_CMD_SIZE, HID_FEATURE_REPORT);
++=======
+ 	ret = hid_hw_raw_request(data->hdev, buf[0], buf, BLINK1_CMD_SIZE,
+ 				 HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
++>>>>>>> b0dd72aafd78 (HID: replace hid_output_raw_report with hid_hw_raw_request for feature requests)
  
  	return ret < 0 ? ret : 0;
  }
diff --cc drivers/hid/hid-wacom.c
index a4a8bb0da688,902013ec041b..000000000000
--- a/drivers/hid/hid-wacom.c
+++ b/drivers/hid/hid-wacom.c
@@@ -126,8 -128,8 +126,13 @@@ static void wacom_set_image(struct hid_
  
  	rep_data[0] = WAC_CMD_ICON_START_STOP;
  	rep_data[1] = 0;
++<<<<<<< HEAD
 +	ret = hdev->hid_output_raw_report(hdev, rep_data, 2,
 +				HID_FEATURE_REPORT);
++=======
+ 	ret = hid_hw_raw_request(hdev, rep_data[0], rep_data, 2,
+ 				 HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
++>>>>>>> b0dd72aafd78 (HID: replace hid_output_raw_report with hid_hw_raw_request for feature requests)
  	if (ret < 0)
  		goto err;
  
@@@ -141,15 -143,15 +146,25 @@@
  			rep_data[j + 3] = p[(i << 6) + j];
  
  		rep_data[2] = i;
++<<<<<<< HEAD
 +		ret = hdev->hid_output_raw_report(hdev, rep_data, 67,
 +					HID_FEATURE_REPORT);
++=======
+ 		ret = hid_hw_raw_request(hdev, rep_data[0], rep_data, 67,
+ 					HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
++>>>>>>> b0dd72aafd78 (HID: replace hid_output_raw_report with hid_hw_raw_request for feature requests)
  	}
  
  	rep_data[0] = WAC_CMD_ICON_START_STOP;
  	rep_data[1] = 0;
  
++<<<<<<< HEAD
 +	ret = hdev->hid_output_raw_report(hdev, rep_data, 2,
 +				HID_FEATURE_REPORT);
++=======
+ 	ret = hid_hw_raw_request(hdev, rep_data[0], rep_data, 2,
+ 				 HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
++>>>>>>> b0dd72aafd78 (HID: replace hid_output_raw_report with hid_hw_raw_request for feature requests)
  
  err:
  	return;
@@@ -181,7 -183,8 +196,12 @@@ static void wacom_leds_set_brightness(s
  		buf[3] = value;
  		/* use fixed brightness for OLEDs */
  		buf[4] = 0x08;
++<<<<<<< HEAD
 +		hdev->hid_output_raw_report(hdev, buf, 9, HID_FEATURE_REPORT);
++=======
+ 		hid_hw_raw_request(hdev, buf[0], buf, 9, HID_FEATURE_REPORT,
+ 				   HID_REQ_SET_REPORT);
++>>>>>>> b0dd72aafd78 (HID: replace hid_output_raw_report with hid_hw_raw_request for feature requests)
  		kfree(buf);
  	}
  
@@@ -328,8 -340,8 +348,13 @@@ static void wacom_set_features(struct h
  		rep_data[0] = 0x03 ; rep_data[1] = 0x00;
  		limit = 3;
  		do {
++<<<<<<< HEAD
 +			ret = hdev->hid_output_raw_report(hdev, rep_data, 2,
 +					HID_FEATURE_REPORT);
++=======
+ 			ret = hid_hw_raw_request(hdev, rep_data[0], rep_data, 2,
+ 					HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
++>>>>>>> b0dd72aafd78 (HID: replace hid_output_raw_report with hid_hw_raw_request for feature requests)
  		} while (ret < 0 && limit-- > 0);
  
  		if (ret >= 0) {
@@@ -341,8 -353,9 +366,14 @@@
  			rep_data[1] = 0x00;
  			limit = 3;
  			do {
++<<<<<<< HEAD
 +				ret = hdev->hid_output_raw_report(hdev,
 +					rep_data, 2, HID_FEATURE_REPORT);
++=======
+ 				ret = hid_hw_raw_request(hdev, rep_data[0],
+ 					rep_data, 2, HID_FEATURE_REPORT,
+ 					HID_REQ_SET_REPORT);
++>>>>>>> b0dd72aafd78 (HID: replace hid_output_raw_report with hid_hw_raw_request for feature requests)
  			} while (ret < 0 && limit-- > 0);
  
  			if (ret >= 0) {
@@@ -367,8 -380,8 +398,13 @@@
  		rep_data[0] = 0x03;
  		rep_data[1] = wdata->features;
  
++<<<<<<< HEAD
 +		ret = hdev->hid_output_raw_report(hdev, rep_data, 2,
 +					HID_FEATURE_REPORT);
++=======
+ 		ret = hid_hw_raw_request(hdev, rep_data[0], rep_data, 2,
+ 				HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
++>>>>>>> b0dd72aafd78 (HID: replace hid_output_raw_report with hid_hw_raw_request for feature requests)
  		if (ret >= 0)
  			wdata->high_speed = speed;
  		break;
* Unmerged path drivers/hid/hid-lg.c
* Unmerged path drivers/hid/hid-magicmouse.c
* Unmerged path drivers/hid/hid-sony.c
* Unmerged path drivers/hid/hid-thingm.c
* Unmerged path drivers/hid/hid-wacom.c
