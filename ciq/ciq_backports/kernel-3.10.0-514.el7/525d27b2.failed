VFS: Add owner-filesystem positive/negative dentry checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author David Howells <dhowells@redhat.com>
commit 525d27b23555419e0e7b73fb6e78d4d678cb4f32
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/525d27b2.failed

Supply two functions to test whether a filesystem's own dentries are positive
or negative (d_really_is_positive() and d_really_is_negative()).

The problem is that the DCACHE_ENTRY_TYPE field of dentry->d_flags may be
overridden by the union part of a layered filesystem and isn't thus
necessarily indicative of the type of dentry.

Normally, this would involve a negative dentry (ie. ->d_inode == NULL) having
->d_layer.lower pointed to a lower layer dentry, DCACHE_PINNING_LOWER set and
the DCACHE_ENTRY_TYPE field set to something other than DCACHE_MISS_TYPE - but
it could also involve, say, a DCACHE_SPECIAL_TYPE being overridden to
DCACHE_WHITEOUT_TYPE if a 0,0 chardev is detected in the top layer.

However, inside a filesystem, when that fs is looking at its own dentries, it
probably wants to know if they are really negative or not - and doesn't care
about the fallthrough bits used by the union.

To this end, a filesystem should normally use d_really_is_positive/negative()
when looking at its own dentries rather than d_is_positive/negative() and
should use d_inode() to get at the inode.

Anyone looking at someone else's dentries (this includes pathwalk) should use
d_is_xxx() and d_backing_inode().

	Signed-off-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 525d27b23555419e0e7b73fb6e78d4d678cb4f32)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/dcache.h
diff --cc include/linux/dcache.h
index 5888528c0fa0,e83768ee38fc..000000000000
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@@ -459,6 -482,113 +459,55 @@@ static inline bool d_is_positive(const 
  	return !d_is_negative(dentry);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * d_really_is_negative - Determine if a dentry is really negative (ignoring fallthroughs)
+  * @dentry: The dentry in question
+  *
+  * Returns true if the dentry represents either an absent name or a name that
+  * doesn't map to an inode (ie. ->d_inode is NULL).  The dentry could represent
+  * a true miss, a whiteout that isn't represented by a 0,0 chardev or a
+  * fallthrough marker in an opaque directory.
+  *
+  * Note!  (1) This should be used *only* by a filesystem to examine its own
+  * dentries.  It should not be used to look at some other filesystem's
+  * dentries.  (2) It should also be used in combination with d_inode() to get
+  * the inode.  (3) The dentry may have something attached to ->d_lower and the
+  * type field of the flags may be set to something other than miss or whiteout.
+  */
+ static inline bool d_really_is_negative(const struct dentry *dentry)
+ {
+ 	return dentry->d_inode == NULL;
+ }
+ 
+ /**
+  * d_really_is_positive - Determine if a dentry is really positive (ignoring fallthroughs)
+  * @dentry: The dentry in question
+  *
+  * Returns true if the dentry represents a name that maps to an inode
+  * (ie. ->d_inode is not NULL).  The dentry might still represent a whiteout if
+  * that is represented on medium as a 0,0 chardev.
+  *
+  * Note!  (1) This should be used *only* by a filesystem to examine its own
+  * dentries.  It should not be used to look at some other filesystem's
+  * dentries.  (2) It should also be used in combination with d_inode() to get
+  * the inode.
+  */
+ static inline bool d_really_is_positive(const struct dentry *dentry)
+ {
+ 	return dentry->d_inode != NULL;
+ }
+ 
+ extern void d_set_fallthru(struct dentry *dentry);
+ 
+ static inline bool d_is_fallthru(const struct dentry *dentry)
+ {
+ 	return dentry->d_flags & DCACHE_FALLTHRU;
+ }
+ 
+ 
++>>>>>>> 525d27b23555 (VFS: Add owner-filesystem positive/negative dentry checks)
  extern int sysctl_vfs_cache_pressure;
  
 -static inline unsigned long vfs_pressure_ratio(unsigned long val)
 -{
 -	return mult_frac(val, sysctl_vfs_cache_pressure, 100);
 -}
 -
 -/**
 - * d_inode - Get the actual inode of this dentry
 - * @dentry: The dentry to query
 - *
 - * This is the helper normal filesystems should use to get at their own inodes
 - * in their own dentries and ignore the layering superimposed upon them.
 - */
 -static inline struct inode *d_inode(const struct dentry *dentry)
 -{
 -	return dentry->d_inode;
 -}
 -
 -/**
 - * d_inode_rcu - Get the actual inode of this dentry with ACCESS_ONCE()
 - * @dentry: The dentry to query
 - *
 - * This is the helper normal filesystems should use to get at their own inodes
 - * in their own dentries and ignore the layering superimposed upon them.
 - */
 -static inline struct inode *d_inode_rcu(const struct dentry *dentry)
 -{
 -	return ACCESS_ONCE(dentry->d_inode);
 -}
 -
 -/**
 - * d_backing_inode - Get upper or lower inode we should be using
 - * @upper: The upper layer
 - *
 - * This is the helper that should be used to get at the inode that will be used
 - * if this dentry were to be opened as a file.  The inode may be on the upper
 - * dentry or it may be on a lower dentry pinned by the upper.
 - *
 - * Normal filesystems should not use this to access their own inodes.
 - */
 -static inline struct inode *d_backing_inode(const struct dentry *upper)
 -{
 -	struct inode *inode = upper->d_inode;
 -
 -	return inode;
 -}
 -
 -/**
 - * d_backing_dentry - Get upper or lower dentry we should be using
 - * @upper: The upper layer
 - *
 - * This is the helper that should be used to get the dentry of the inode that
 - * will be used if this dentry were opened as a file.  It may be the upper
 - * dentry or it may be a lower dentry pinned by the upper.
 - *
 - * Normal filesystems should not use this to access their own dentries.
 - */
 -static inline struct dentry *d_backing_dentry(struct dentry *upper)
 -{
 -	return upper;
 -}
 -
  #endif	/* __LINUX_DCACHE_H */
* Unmerged path include/linux/dcache.h
