SUNRPC: Move TCP receive data path into a workqueue context

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit edc1b01cd3b20a5fff049e98f82a2b0d24a34c89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/edc1b01c.failed

Stream protocols such as TCP can often build up a backlog of data to be
read due to ordering. Combine this with the fact that some workloads such
as NFS read()-intensive workloads need to receive a lot of data per RPC
call, and it turns out that receiving the data from inside a softirq
context can cause starvation.

The following patch moves the TCP data receive into a workqueue context.
We still end up calling tcp_read_sock(), but we do so from a process
context, meaning that softirqs are enabled for most of the time.

With this patch, I see a doubling of read bandwidth when running a
multi-threaded iozone workload between a virtual client and server setup.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit edc1b01cd3b20a5fff049e98f82a2b0d24a34c89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/sunrpc/xprtsock.h
#	net/sunrpc/xprtsock.c
diff --cc include/linux/sunrpc/xprtsock.h
index 1ad36cc25b2e,0ece4ba06f06..000000000000
--- a/include/linux/sunrpc/xprtsock.h
+++ b/include/linux/sunrpc/xprtsock.h
@@@ -17,6 -17,70 +17,73 @@@ void		cleanup_socket_xprt(void)
  #define RPC_DEF_MIN_RESVPORT	(665U)
  #define RPC_DEF_MAX_RESVPORT	(1023U)
  
++<<<<<<< HEAD
++=======
+ struct sock_xprt {
+ 	struct rpc_xprt		xprt;
+ 
+ 	/*
+ 	 * Network layer
+ 	 */
+ 	struct socket *		sock;
+ 	struct sock *		inet;
+ 
+ 	/*
+ 	 * State of TCP reply receive
+ 	 */
+ 	__be32			tcp_fraghdr,
+ 				tcp_xid,
+ 				tcp_calldir;
+ 
+ 	u32			tcp_offset,
+ 				tcp_reclen;
+ 
+ 	unsigned long		tcp_copied,
+ 				tcp_flags;
+ 
+ 	/*
+ 	 * Connection of transports
+ 	 */
+ 	unsigned long		sock_state;
+ 	struct delayed_work	connect_worker;
+ 	struct work_struct	recv_worker;
+ 	struct mutex		recv_mutex;
+ 	struct sockaddr_storage	srcaddr;
+ 	unsigned short		srcport;
+ 
+ 	/*
+ 	 * UDP socket buffer size parameters
+ 	 */
+ 	size_t			rcvsize,
+ 				sndsize;
+ 
+ 	/*
+ 	 * Saved socket callback addresses
+ 	 */
+ 	void			(*old_data_ready)(struct sock *);
+ 	void			(*old_state_change)(struct sock *);
+ 	void			(*old_write_space)(struct sock *);
+ 	void			(*old_error_report)(struct sock *);
+ };
+ 
+ /*
+  * TCP receive state flags
+  */
+ #define TCP_RCV_LAST_FRAG	(1UL << 0)
+ #define TCP_RCV_COPY_FRAGHDR	(1UL << 1)
+ #define TCP_RCV_COPY_XID	(1UL << 2)
+ #define TCP_RCV_COPY_DATA	(1UL << 3)
+ #define TCP_RCV_READ_CALLDIR	(1UL << 4)
+ #define TCP_RCV_COPY_CALLDIR	(1UL << 5)
+ 
+ /*
+  * TCP RPC flags
+  */
+ #define TCP_RPC_REPLY		(1UL << 6)
+ 
+ #define XPRT_SOCK_CONNECTING	1U
+ 
++>>>>>>> edc1b01cd3b2 (SUNRPC: Move TCP receive data path into a workqueue context)
  #endif /* __KERNEL__ */
  
  #endif /* _LINUX_SUNRPC_XPRTSOCK_H */
diff --cc net/sunrpc/xprtsock.c
index 5fc1f18c23a8,58dc90ccebb6..000000000000
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@@ -868,6 -818,12 +868,15 @@@ static void xs_reset_transport(struct s
  	if (sk == NULL)
  		return;
  
++<<<<<<< HEAD
++=======
+ 	if (atomic_read(&transport->xprt.swapper))
+ 		sk_clear_memalloc(sk);
+ 
+ 	kernel_sock_shutdown(sock, SHUT_RDWR);
+ 
+ 	mutex_lock(&transport->recv_mutex);
++>>>>>>> edc1b01cd3b2 (SUNRPC: Move TCP receive data path into a workqueue context)
  	write_lock_bh(&sk->sk_callback_lock);
  	transport->inet = NULL;
  	transport->sock = NULL;
@@@ -875,9 -831,12 +884,14 @@@
  	sk->sk_user_data = NULL;
  
  	xs_restore_old_callbacks(transport, sk);
 -	xprt_clear_connected(xprt);
  	write_unlock_bh(&sk->sk_callback_lock);
++<<<<<<< HEAD
++=======
+ 	xs_sock_reset_connection_flags(xprt);
+ 	mutex_unlock(&transport->recv_mutex);
++>>>>>>> edc1b01cd3b2 (SUNRPC: Move TCP receive data path into a workqueue context)
  
 -	trace_rpc_socket_close(xprt, sock);
 +	trace_rpc_socket_close(&transport->xprt, sock);
  	sock_release(sock);
  }
  
@@@ -1437,6 -1394,44 +1452,47 @@@ static int xs_tcp_data_recv(read_descri
  	return len - desc.count;
  }
  
++<<<<<<< HEAD
++=======
+ static void xs_tcp_data_receive(struct sock_xprt *transport)
+ {
+ 	struct rpc_xprt *xprt = &transport->xprt;
+ 	struct sock *sk;
+ 	read_descriptor_t rd_desc = {
+ 		.count = 2*1024*1024,
+ 		.arg.data = xprt,
+ 	};
+ 	unsigned long total = 0;
+ 	int read = 0;
+ 
+ 	mutex_lock(&transport->recv_mutex);
+ 	sk = transport->inet;
+ 	if (sk == NULL)
+ 		goto out;
+ 
+ 	/* We use rd_desc to pass struct xprt to xs_tcp_data_recv */
+ 	for (;;) {
+ 		lock_sock(sk);
+ 		read = tcp_read_sock(sk, &rd_desc, xs_tcp_data_recv);
+ 		release_sock(sk);
+ 		if (read <= 0)
+ 			break;
+ 		total += read;
+ 		rd_desc.count = 65536;
+ 	}
+ out:
+ 	mutex_unlock(&transport->recv_mutex);
+ 	trace_xs_tcp_data_ready(xprt, read, total);
+ }
+ 
+ static void xs_tcp_data_receive_workfn(struct work_struct *work)
+ {
+ 	struct sock_xprt *transport =
+ 		container_of(work, struct sock_xprt, recv_worker);
+ 	xs_tcp_data_receive(transport);
+ }
+ 
++>>>>>>> edc1b01cd3b2 (SUNRPC: Move TCP receive data path into a workqueue context)
  /**
   * xs_tcp_data_ready - "data ready" callback for TCP sockets
   * @sk: socket with data to read
@@@ -1459,13 -1454,8 +1515,17 @@@ static void xs_tcp_data_ready(struct so
  	 */
  	if (xprt->reestablish_timeout)
  		xprt->reestablish_timeout = 0;
+ 	queue_work(rpciod_workqueue, &transport->recv_worker);
  
++<<<<<<< HEAD
 +	/* We use rd_desc to pass struct xprt to xs_tcp_data_recv */
 +	rd_desc.arg.data = xprt;
 +	do {
 +		rd_desc.count = 65536;
 +		read = tcp_read_sock(sk, &rd_desc, xs_tcp_data_recv);
 +	} while (read > 0);
++=======
++>>>>>>> edc1b01cd3b2 (SUNRPC: Move TCP receive data path into a workqueue context)
  out:
  	read_unlock_bh(&sk->sk_callback_lock);
  }
* Unmerged path include/linux/sunrpc/xprtsock.h
* Unmerged path net/sunrpc/xprtsock.c
