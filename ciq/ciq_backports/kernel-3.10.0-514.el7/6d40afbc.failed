megaraid_sas: MFI IO timeout handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sumit Saxena <sumit.saxena@avagotech.com>
commit 6d40afbc7d13359b30a5cd783e3db6ebefa5f40a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6d40afbc.failed

This patch will do proper error handling for DCMD timeout failure cases
for Fusion adapters:

1. For MFI adapters, in case of DCMD timeout (DCMD which must return
SUCCESS) driver will call kill adapter.

2. What action needs to be taken in case of DCMD timeout is decided by
function dcmd_timeout_ocr_possible().  DCMD timeout causing OCR is
applicable to the following commands:

	MR_DCMD_PD_LIST_QUERY
	MR_DCMD_LD_GET_LIST
	MR_DCMD_LD_LIST_QUERY
	MR_DCMD_CTRL_SET_CRASH_DUMP_PARAMS
	MR_DCMD_SYSTEM_PD_MAP_GET_INFO
	MR_DCMD_LD_MAP_GET_INFO

3. If DCMD fails from driver init path there are certain DCMDs which
must return SUCCESS. If those DCMDs fail, driver bails out. For optional
DCMDs like pd_info etc., driver continues without executing certain
functionality.

	Signed-off-by: Sumit Saxena <sumit.saxena@avagotech.com>
	Signed-off-by: Kashyap Desai <kashyap.desai@avagotech.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 6d40afbc7d13359b30a5cd783e3db6ebefa5f40a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas_base.c
#	drivers/scsi/megaraid/megaraid_sas_fusion.c
diff --cc drivers/scsi/megaraid/megaraid_sas_base.c
index b60f8ef53c66,380c627080c5..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@@ -969,26 -984,20 +970,25 @@@ extern struct megasas_instance_templat
  int
  megasas_issue_polled(struct megasas_instance *instance, struct megasas_cmd *cmd)
  {
++<<<<<<< HEAD
 +	int seconds;
 +
++=======
++>>>>>>> 6d40afbc7d13 (megaraid_sas: MFI IO timeout handling)
  	struct megasas_header *frame_hdr = &cmd->frame->hdr;
  
- 	frame_hdr->cmd_status = MFI_CMD_STATUS_POLL_MODE;
+ 	frame_hdr->cmd_status = MFI_STAT_INVALID_STATUS;
  	frame_hdr->flags |= cpu_to_le16(MFI_FRAME_DONT_POST_IN_REPLY_QUEUE);
  
- 	/*
- 	 * Issue the frame using inbound queue port
- 	 */
- 	instance->instancet->issue_dcmd(instance, cmd);
+ 	if ((instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR) ||
+ 		(instance->instancet->issue_dcmd(instance, cmd))) {
+ 		dev_err(&instance->pdev->dev, "Failed from %s %d\n",
+ 			__func__, __LINE__);
+ 		return DCMD_NOT_FIRED;
+ 	}
  
- 	/*
- 	 * Wait for cmd_status to change
- 	 */
- 	if (instance->requestorId)
- 		seconds = MEGASAS_ROUTINE_WAIT_TIME_VF;
- 	else
- 		seconds = MFI_POLL_TIMEOUT_SECS;
- 	return wait_and_poll(instance, cmd, seconds);
+ 	return wait_and_poll(instance, cmd, instance->requestorId ?
+ 			MEGASAS_ROUTINE_WAIT_TIME_VF : MFI_IO_TIMEOUT_SECS);
  }
  
  /**
@@@ -2034,14 -2061,12 +2049,20 @@@ static int megasas_get_ld_vf_affiliatio
  	dcmd->sgl.sge32[0].length = cpu_to_le32(
  		sizeof(struct MR_LD_VF_AFFILIATION_111));
  
 -	dev_warn(&instance->pdev->dev, "SR-IOV: Getting LD/VF affiliation for "
 +	printk(KERN_WARNING "megasas: SR-IOV: Getting LD/VF affiliation for "
  	       "scsi%d\n", instance->host->host_no);
  
++<<<<<<< HEAD
 +	megasas_issue_blocked_cmd(instance, cmd, 0);
 +
 +	if (dcmd->cmd_status) {
 +		printk(KERN_WARNING "megasas: SR-IOV: LD/VF affiliation DCMD"
 +		       " failed with status 0x%x for scsi%d.\n",
++=======
+ 	if (megasas_issue_blocked_cmd(instance, cmd, 0) != DCMD_SUCCESS) {
+ 		dev_warn(&instance->pdev->dev, "SR-IOV: LD/VF affiliation DCMD"
+ 		       " failed with status 0x%x for scsi%d\n",
++>>>>>>> 6d40afbc7d13 (megaraid_sas: MFI IO timeout handling)
  		       dcmd->cmd_status, instance->host->host_no);
  		retval = 1; /* Do a scan if we couldn't get affiliation */
  		goto out;
@@@ -2147,14 -2171,13 +2168,19 @@@ static int megasas_get_ld_vf_affiliatio
  	dcmd->sgl.sge32[0].length = cpu_to_le32((MAX_LOGICAL_DRIVES + 1) *
  		sizeof(struct MR_LD_VF_AFFILIATION));
  
 -	dev_warn(&instance->pdev->dev, "SR-IOV: Getting LD/VF affiliation for "
 +	printk(KERN_WARNING "megasas: SR-IOV: Getting LD/VF affiliation for "
  	       "scsi%d\n", instance->host->host_no);
  
- 	megasas_issue_blocked_cmd(instance, cmd, 0);
  
++<<<<<<< HEAD
 +	if (dcmd->cmd_status) {
 +		printk(KERN_WARNING "megasas: SR-IOV: LD/VF affiliation DCMD"
 +		       " failed with status 0x%x for scsi%d.\n",
++=======
+ 	if (megasas_issue_blocked_cmd(instance, cmd, 0) != DCMD_SUCCESS) {
+ 		dev_warn(&instance->pdev->dev, "SR-IOV: LD/VF affiliation DCMD"
+ 		       " failed with status 0x%x for scsi%d\n",
++>>>>>>> 6d40afbc7d13 (megaraid_sas: MFI IO timeout handling)
  		       dcmd->cmd_status, instance->host->host_no);
  		retval = 1; /* Do a scan if we couldn't get affiliation */
  		goto out;
@@@ -3951,31 -3936,60 +3996,72 @@@ megasas_get_pd_list(struct megasas_inst
  	else
  		ret = megasas_issue_polled(instance, cmd);
  
++<<<<<<< HEAD
 +	/*
 +	* the following function will get the instance PD LIST.
 +	*/
++=======
+ 	switch (ret) {
+ 	case DCMD_FAILED:
+ 		megaraid_sas_kill_hba(instance);
+ 		break;
+ 	case DCMD_TIMEOUT:
++>>>>>>> 6d40afbc7d13 (megaraid_sas: MFI IO timeout handling)
  
- 	pd_addr = ci->addr;
+ 		switch (dcmd_timeout_ocr_possible(instance)) {
+ 		case INITIATE_OCR:
+ 			cmd->flags |= DRV_DCMD_SKIP_REFIRE;
+ 			/*
+ 			 * DCMD failed from AEN path.
+ 			 * AEN path already hold reset_mutex to avoid PCI access
+ 			 * while OCR is in progress.
+ 			 */
+ 			mutex_unlock(&instance->reset_mutex);
+ 			megasas_reset_fusion(instance->host,
+ 						MFI_IO_TIMEOUT_OCR);
+ 			mutex_lock(&instance->reset_mutex);
+ 			break;
+ 		case KILL_ADAPTER:
+ 			megaraid_sas_kill_hba(instance);
+ 			break;
+ 		case IGNORE_TIMEOUT:
+ 			dev_info(&instance->pdev->dev, "Ignore DCMD timeout: %s %d \n",
+ 				__func__, __LINE__);
+ 			break;
+ 		}
  
++<<<<<<< HEAD
 +	if ( ret == 0 &&
 +	     (le32_to_cpu(ci->count) <
 +		  (MEGASAS_MAX_PD_CHANNELS * MEGASAS_MAX_DEV_PER_CHANNEL))) {
++=======
+ 		break;
+ 
+ 	case DCMD_SUCCESS:
+ 		pd_addr = ci->addr;
+ 
+ 		if ((le32_to_cpu(ci->count) >
+ 			(MEGASAS_MAX_PD_CHANNELS * MEGASAS_MAX_DEV_PER_CHANNEL)))
+ 			break;
++>>>>>>> 6d40afbc7d13 (megaraid_sas: MFI IO timeout handling)
  
  		memset(instance->local_pd_list, 0,
- 			MEGASAS_MAX_PD * sizeof(struct megasas_pd_list));
+ 				MEGASAS_MAX_PD * sizeof(struct megasas_pd_list));
  
  		for (pd_index = 0; pd_index < le32_to_cpu(ci->count); pd_index++) {
- 
  			instance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].tid	=
- 				le16_to_cpu(pd_addr->deviceId);
+ 					le16_to_cpu(pd_addr->deviceId);
  			instance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].driveType	=
- 							pd_addr->scsiDevType;
+ 					pd_addr->scsiDevType;
  			instance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].driveState	=
- 							MR_PD_STATE_SYSTEM;
+ 					MR_PD_STATE_SYSTEM;
  			pd_addr++;
  		}
+ 
  		memcpy(instance->pd_list, instance->local_pd_list,
  			sizeof(instance->pd_list));
+ 		break;
+ 
  	}
  
  	pci_free_consistent(instance->pdev,
@@@ -5695,13 -5809,14 +5898,16 @@@ static void megasas_flush_cache(struct 
  	dcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_CACHE_FLUSH);
  	dcmd->mbox.b[0] = MR_FLUSH_CTRL_CACHE | MR_FLUSH_DISK_CACHE;
  
- 	if (megasas_issue_blocked_cmd(instance, cmd, 30))
- 		dev_err(&instance->pdev->dev, "Command timedout"
- 			" from %s\n", __func__);
+ 	if (megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS)
+ 			!= DCMD_SUCCESS) {
+ 		dev_err(&instance->pdev->dev,
+ 			"return from %s %d\n", __func__, __LINE__);
+ 		return;
+ 	}
  
  	megasas_return_cmd(instance, cmd);
 +
 +	return;
  }
  
  /**
@@@ -5746,13 -5861,14 +5952,16 @@@ static void megasas_shutdown_controller
  	dcmd->data_xfer_len = 0;
  	dcmd->opcode = cpu_to_le32(opcode);
  
- 	if (megasas_issue_blocked_cmd(instance, cmd, 30))
- 		dev_err(&instance->pdev->dev, "Command timedout"
- 			"from %s\n", __func__);
+ 	if (megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS)
+ 			!= DCMD_SUCCESS) {
+ 		dev_err(&instance->pdev->dev,
+ 			"return from %s %d\n", __func__, __LINE__);
+ 		return;
+ 	}
  
  	megasas_return_cmd(instance, cmd);
 +
 +	return;
  }
  
  #ifdef CONFIG_PM
@@@ -6724,6 -6832,7 +6941,10 @@@ megasas_aen_polling(struct work_struct 
  	int     i, j, doscan = 0;
  	u32 seq_num, wait_time = MEGASAS_RESET_WAIT_TIME;
  	int error;
++<<<<<<< HEAD
++=======
+ 	u8  dcmd_ret = DCMD_SUCCESS;
++>>>>>>> 6d40afbc7d13 (megaraid_sas: MFI IO timeout handling)
  
  	if (!instance) {
  		printk(KERN_ERR "invalid instance!\n");
@@@ -6753,132 -6853,50 +6974,161 @@@
  		megasas_decode_evt(instance);
  
  		switch (le32_to_cpu(instance->evt_detail->code)) {
 -
  		case MR_EVT_PD_INSERTED:
 +			if (megasas_get_pd_list(instance) == 0) {
 +			for (i = 0; i < MEGASAS_MAX_PD_CHANNELS; i++) {
 +				for (j = 0;
 +				j < MEGASAS_MAX_DEV_PER_CHANNEL;
 +				j++) {
 +
 +				pd_index =
 +				(i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;
 +
 +				sdev1 =
 +				scsi_device_lookup(host, i, j, 0);
 +
 +				if (instance->pd_list[pd_index].driveState
 +						== MR_PD_STATE_SYSTEM) {
 +						if (!sdev1) {
 +						scsi_add_device(host, i, j, 0);
 +						}
 +
 +					if (sdev1)
 +						scsi_device_put(sdev1);
 +					}
 +				}
 +			}
 +			}
 +			doscan = 0;
 +			break;
 +
  		case MR_EVT_PD_REMOVED:
++<<<<<<< HEAD
 +			if (megasas_get_pd_list(instance) == 0) {
 +			for (i = 0; i < MEGASAS_MAX_PD_CHANNELS; i++) {
 +				for (j = 0;
 +				j < MEGASAS_MAX_DEV_PER_CHANNEL;
 +				j++) {
 +
 +				pd_index =
 +				(i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;
 +
 +				sdev1 =
 +				scsi_device_lookup(host, i, j, 0);
 +
 +				if (instance->pd_list[pd_index].driveState
 +					== MR_PD_STATE_SYSTEM) {
 +					if (sdev1) {
 +						scsi_device_put(sdev1);
 +					}
 +				} else {
 +					if (sdev1) {
 +						scsi_remove_device(sdev1);
 +						scsi_device_put(sdev1);
 +					}
 +				}
 +				}
 +			}
 +			}
 +			doscan = 0;
++=======
+ 			dcmd_ret = megasas_get_pd_list(instance);
+ 			if (dcmd_ret == DCMD_SUCCESS)
+ 				doscan = SCAN_PD_CHANNEL;
++>>>>>>> 6d40afbc7d13 (megaraid_sas: MFI IO timeout handling)
  			break;
  
  		case MR_EVT_LD_OFFLINE:
  		case MR_EVT_CFG_CLEARED:
  		case MR_EVT_LD_DELETED:
 +			if (!instance->requestorId ||
 +			    megasas_get_ld_vf_affiliation(instance, 0)) {
 +				if (megasas_ld_list_query(instance,
 +							  MR_LD_QUERY_TYPE_EXPOSED_TO_HOST))
 +					megasas_get_ld_list(instance);
 +				for (i = 0; i < MEGASAS_MAX_LD_CHANNELS; i++) {
 +					for (j = 0;
 +					     j < MEGASAS_MAX_DEV_PER_CHANNEL;
 +					     j++) {
 +
 +						ld_index =
 +							(i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;
 +
 +						sdev1 = scsi_device_lookup(host, MEGASAS_MAX_PD_CHANNELS + i, j, 0);
 +
 +						if (instance->ld_ids[ld_index]
 +						    != 0xff) {
 +							if (sdev1)
 +								scsi_device_put(sdev1);
 +						} else {
 +							if (sdev1) {
 +								scsi_remove_device(sdev1);
 +								scsi_device_put(sdev1);
 +							}
 +						}
 +					}
 +				}
 +				doscan = 0;
 +			}
 +			break;
  		case MR_EVT_LD_CREATED:
  			if (!instance->requestorId ||
 -				(instance->requestorId && megasas_get_ld_vf_affiliation(instance, 0)))
 -				dcmd_ret = megasas_ld_list_query(instance, MR_LD_QUERY_TYPE_EXPOSED_TO_HOST);
 -
 +			    megasas_get_ld_vf_affiliation(instance, 0)) {
 +				if (megasas_ld_list_query(instance,
 +							  MR_LD_QUERY_TYPE_EXPOSED_TO_HOST))
 +					megasas_get_ld_list(instance);
 +				for (i = 0; i < MEGASAS_MAX_LD_CHANNELS; i++) {
 +					for (j = 0;
 +					     j < MEGASAS_MAX_DEV_PER_CHANNEL;
 +					     j++) {
 +						ld_index =
 +							(i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;
 +
++<<<<<<< HEAD
 +						sdev1 = scsi_device_lookup(host, MEGASAS_MAX_PD_CHANNELS + i, j, 0);
++=======
+ 			if (dcmd_ret == DCMD_SUCCESS)
+ 				doscan = SCAN_VD_CHANNEL;
 -
++>>>>>>> 6d40afbc7d13 (megaraid_sas: MFI IO timeout handling)
 +
 +						if (instance->ld_ids[ld_index]
 +						    != 0xff) {
 +							if (!sdev1)
 +								scsi_add_device(host, MEGASAS_MAX_PD_CHANNELS + i, j, 0);
 +						}
 +						if (sdev1)
 +							scsi_device_put(sdev1);
 +					}
 +				}
 +				doscan = 0;
 +			}
  			break;
 -
  		case MR_EVT_CTRL_HOST_BUS_SCAN_REQUESTED:
  		case MR_EVT_FOREIGN_CFG_IMPORTED:
  		case MR_EVT_LD_STATE_CHANGE:
++<<<<<<< HEAD
 +			doscan = 1;
++=======
+ 			dcmd_ret = megasas_get_pd_list(instance);
+ 
+ 			if (dcmd_ret != DCMD_SUCCESS)
+ 				break;
+ 
+ 			if (!instance->requestorId ||
+ 				(instance->requestorId && megasas_get_ld_vf_affiliation(instance, 0)))
+ 				dcmd_ret = megasas_ld_list_query(instance, MR_LD_QUERY_TYPE_EXPOSED_TO_HOST);
+ 
+ 			if (dcmd_ret != DCMD_SUCCESS)
+ 				break;
+ 
+ 			doscan = SCAN_VD_CHANNEL | SCAN_PD_CHANNEL;
+ 			dev_info(&instance->pdev->dev, "scanning for scsi%d...\n",
+ 				instance->host->host_no);
++>>>>>>> 6d40afbc7d13 (megaraid_sas: MFI IO timeout handling)
  			break;
 -
  		case MR_EVT_CTRL_PROP_CHANGED:
 -				dcmd_ret = megasas_get_ctrl_info(instance);
 -				break;
 +			megasas_get_ctrl_info(instance);
 +			break;
  		default:
  			doscan = 0;
  			break;
@@@ -6944,12 -6951,10 +7194,19 @@@
  		}
  	}
  
 +	if ( instance->aen_cmd != NULL ) {
 +		kfree(ev);
 +		return ;
 +	}
 +
++<<<<<<< HEAD
 +	seq_num = le32_to_cpu(instance->evt_detail->seq_num) + 1;
++=======
+ 	if (dcmd_ret == DCMD_SUCCESS)
+ 		seq_num = le32_to_cpu(instance->evt_detail->seq_num) + 1;
+ 	else
+ 		seq_num = instance->last_seq_num;
++>>>>>>> 6d40afbc7d13 (megaraid_sas: MFI IO timeout handling)
  
  	/* Register AEN with FW for latest sequence number plus 1 */
  	class_locale.members.reserved = 0;
diff --cc drivers/scsi/megaraid/megaraid_sas_fusion.c
index 804cabf780a6,6e48707509f2..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@@ -2440,10 -2427,13 +2448,18 @@@ megasas_issue_dcmd_fusion(struct megasa
  
  	req_desc = build_mpt_cmd(instance, cmd);
  	if (!req_desc) {
++<<<<<<< HEAD
 +		printk(KERN_ERR "Couldn't issue MFI pass thru cmd\n");
 +		return;
++=======
+ 		dev_info(&instance->pdev->dev, "Failed from %s %d\n",
+ 					__func__, __LINE__);
+ 		return DCMD_NOT_FIRED;
++>>>>>>> 6d40afbc7d13 (megaraid_sas: MFI IO timeout handling)
  	}
+ 
  	megasas_fire_cmd_fusion(instance, req_desc);
+ 	return DCMD_SUCCESS;
  }
  
  /**
diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h
index d4c399b43165..91dc51e8ff2c 100644
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@ -170,6 +170,7 @@
 
 /* Driver internal */
 #define DRV_DCMD_POLLED_MODE		0x1
+#define DRV_DCMD_SKIP_REFIRE		0x2
 
 /*
  * Definition for cmd_status
@@ -1091,6 +1092,11 @@ enum MR_SCSI_CMD_TYPE {
 	NON_READ_WRITE_SYSPDIO = 3,
 };
 
+enum DCMD_TIMEOUT_ACTION {
+	INITIATE_OCR = 0,
+	KILL_ADAPTER = 1,
+	IGNORE_TIMEOUT = 2,
+};
 /* Frame Type */
 #define IO_FRAME				0
 #define PTHRU_FRAME				1
@@ -1137,6 +1143,7 @@ enum MR_SCSI_CMD_TYPE {
 
 #define MFI_OB_INTR_STATUS_MASK			0x00000002
 #define MFI_POLL_TIMEOUT_SECS			60
+#define MFI_IO_TIMEOUT_SECS			180
 #define MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF	(5 * HZ)
 #define MEGASAS_OCR_SETTLE_TIME_VF		(1000 * 30)
 #define MEGASAS_ROUTINE_WAIT_TIME_VF		300
@@ -1915,7 +1922,7 @@ struct megasas_instance_template {
 	u32 (*init_adapter)(struct megasas_instance *);
 	u32 (*build_and_issue_cmd) (struct megasas_instance *,
 				    struct scsi_cmnd *);
-	void (*issue_dcmd) (struct megasas_instance *instance,
+	int (*issue_dcmd)(struct megasas_instance *instance,
 			    struct megasas_cmd *cmd);
 };
 
@@ -2013,6 +2020,19 @@ struct megasas_mgmt_info {
 	int max_index;
 };
 
+enum MEGASAS_OCR_CAUSE {
+	FW_FAULT_OCR			= 0,
+	SCSIIO_TIMEOUT_OCR		= 1,
+	MFI_IO_TIMEOUT_OCR		= 2,
+};
+
+enum DCMD_RETURN_STATUS {
+	DCMD_SUCCESS		= 0,
+	DCMD_TIMEOUT		= 1,
+	DCMD_FAILED		= 2,
+	DCMD_NOT_FIRED		= 3,
+};
+
 u8
 MR_BuildRaidContext(struct megasas_instance *instance,
 		    struct IO_REQUEST_INFO *io_info,
* Unmerged path drivers/scsi/megaraid/megaraid_sas_base.c
* Unmerged path drivers/scsi/megaraid/megaraid_sas_fusion.c
