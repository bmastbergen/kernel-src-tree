USB: ehci-platform: Support ehci reset after resume quirk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Wu Liang feng <wulf@rock-chips.com>
commit 314b41b16a71ee824f55e2791fcb92997672da37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/314b41b1.failed

The Rockchip rk3288 EHCI controller doesn't properly detect
the case when a device is removed during suspend. Specifically,
when usb resume from suspend, the EHCI controller maintaining
the USB state (FLAG_CF is 1, Current Connect Status is 1),
but a USB device (like a USB camera on rk3288) may have been
disconnected actually.

Let's add a quirk to force ehci to go into the
usb_root_hub_lost_power() path and reset after resume.
This should generally reset the whole controller and all
ports and initialize everything cleanly again, and bring
the devices back up.

As part of this, rename the "hibernation" paramter of
ehci_resume() to force_reset since hibernation is simply
another case where we can't trust the autodetected status
and need to force a reset of devices.

	Signed-off-by: Wu Liang feng <wulf@rock-chips.com>
	Reviewed-by: Julius Werner <jwerner@google.com>
	Reviewed-by: Doug Anderson <dianders@google.com>
	Reviewed-by: Tomasz Figa <tfiga@google.com>
	Reviewed-by: Pawel Osciak <posciak@google.com>
	Reviewed-by: Sonny Rao <sonnyrao@google.com>
	Acked-by: Alan Stern <stern@rowland.harvard.edu>
	Tested-by: Doug Anderson <dianders@google.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 314b41b16a71ee824f55e2791fcb92997672da37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/ehci-platform.c
diff --cc drivers/usb/host/ehci-platform.c
index 79f7e9051be3,db5c29edf6db..000000000000
--- a/drivers/usb/host/ehci-platform.c
+++ b/drivers/usb/host/ehci-platform.c
@@@ -101,12 -164,85 +101,58 @@@ static int ehci_platform_probe(struct p
  		dev_err(&dev->dev, "no irq provided");
  		return irq;
  	}
++<<<<<<< HEAD
 +	res_mem = platform_get_resource(dev, IORESOURCE_MEM, 0);
 +	if (!res_mem) {
 +		dev_err(&dev->dev, "no memory resource provided");
 +		return -ENXIO;
++=======
+ 
+ 	hcd = usb_create_hcd(&ehci_platform_hc_driver, &dev->dev,
+ 			     dev_name(&dev->dev));
+ 	if (!hcd)
+ 		return -ENOMEM;
+ 
+ 	platform_set_drvdata(dev, hcd);
+ 	dev->dev.platform_data = pdata;
+ 	priv = hcd_to_ehci_priv(hcd);
+ 	ehci = hcd_to_ehci(hcd);
+ 
+ 	if (pdata == &ehci_platform_defaults && dev->dev.of_node) {
+ 		if (of_property_read_bool(dev->dev.of_node, "big-endian-regs"))
+ 			ehci->big_endian_mmio = 1;
+ 
+ 		if (of_property_read_bool(dev->dev.of_node, "big-endian-desc"))
+ 			ehci->big_endian_desc = 1;
+ 
+ 		if (of_property_read_bool(dev->dev.of_node, "big-endian"))
+ 			ehci->big_endian_mmio = ehci->big_endian_desc = 1;
+ 
+ 		if (of_property_read_bool(dev->dev.of_node,
+ 					  "needs-reset-on-resume"))
+ 			pdata->reset_on_resume = 1;
+ 
+ 		priv->phy = devm_phy_get(&dev->dev, "usb");
+ 		if (IS_ERR(priv->phy)) {
+ 			err = PTR_ERR(priv->phy);
+ 			if (err == -EPROBE_DEFER)
+ 				goto err_put_hcd;
+ 			priv->phy = NULL;
+ 		}
+ 
+ 		for (clk = 0; clk < EHCI_MAX_CLKS; clk++) {
+ 			priv->clks[clk] = of_clk_get(dev->dev.of_node, clk);
+ 			if (IS_ERR(priv->clks[clk])) {
+ 				err = PTR_ERR(priv->clks[clk]);
+ 				if (err == -EPROBE_DEFER)
+ 					goto err_put_clks;
+ 				priv->clks[clk] = NULL;
+ 				break;
+ 			}
+ 		}
++>>>>>>> 314b41b16a71 (USB: ehci-platform: Support ehci reset after resume quirk)
  	}
  
 -	priv->rst = devm_reset_control_get_optional(&dev->dev, NULL);
 -	if (IS_ERR(priv->rst)) {
 -		err = PTR_ERR(priv->rst);
 -		if (err == -EPROBE_DEFER)
 -			goto err_put_clks;
 -		priv->rst = NULL;
 -	} else {
 -		err = reset_control_deassert(priv->rst);
 -		if (err)
 -			goto err_put_clks;
 -	}
 -
 -	if (pdata->big_endian_desc)
 -		ehci->big_endian_desc = 1;
 -	if (pdata->big_endian_mmio)
 -		ehci->big_endian_mmio = 1;
 -
 -#ifndef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
 -	if (ehci->big_endian_mmio) {
 -		dev_err(&dev->dev,
 -			"Error: CONFIG_USB_EHCI_BIG_ENDIAN_MMIO not set\n");
 -		err = -EINVAL;
 -		goto err_reset;
 -	}
 -#endif
 -#ifndef CONFIG_USB_EHCI_BIG_ENDIAN_DESC
 -	if (ehci->big_endian_desc) {
 -		dev_err(&dev->dev,
 -			"Error: CONFIG_USB_EHCI_BIG_ENDIAN_DESC not set\n");
 -		err = -EINVAL;
 -		goto err_reset;
 -	}
 -#endif
 -
  	if (pdata->power_on) {
  		err = pdata->power_on(dev);
  		if (err < 0)
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e18f0a4a08c4..c26c697fd1f1 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1110,7 +1110,7 @@ int ehci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 EXPORT_SYMBOL_GPL(ehci_suspend);
 
 /* Returns 0 if power was preserved, 1 if power was lost */
-int ehci_resume(struct usb_hcd *hcd, bool hibernated)
+int ehci_resume(struct usb_hcd *hcd, bool force_reset)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 
@@ -1124,12 +1124,12 @@ int ehci_resume(struct usb_hcd *hcd, bool hibernated)
 		return 0;		/* Controller is dead */
 
 	/*
-	 * If CF is still set and we aren't resuming from hibernation
+	 * If CF is still set and reset isn't forced
 	 * then we maintained suspend power.
 	 * Just undo the effect of ehci_suspend().
 	 */
 	if (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF &&
-			!hibernated) {
+			!force_reset) {
 		int	mask = INTR_MASK;
 
 		ehci_prepare_ports_for_controller_resume(ehci);
* Unmerged path drivers/usb/host/ehci-platform.c
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 03cb384c961c..b1ccd4dcce88 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -870,7 +870,7 @@ extern int	ehci_handshake(struct ehci_hcd *ehci, void __iomem *ptr,
 
 #ifdef CONFIG_PM
 extern int	ehci_suspend(struct usb_hcd *hcd, bool do_wakeup);
-extern int	ehci_resume(struct usb_hcd *hcd, bool hibernated);
+extern int	ehci_resume(struct usb_hcd *hcd, bool force_reset);
 #endif	/* CONFIG_PM */
 
 #endif /* __LINUX_EHCI_HCD_H */
diff --git a/include/linux/usb/ehci_pdriver.h b/include/linux/usb/ehci_pdriver.h
index 7eb4dcd0d386..6287b398abd9 100644
--- a/include/linux/usb/ehci_pdriver.h
+++ b/include/linux/usb/ehci_pdriver.h
@@ -34,6 +34,8 @@ struct usb_hcd;
  *			after initialization.
  * @no_io_watchdog:	set to 1 if the controller does not need the I/O
  *			watchdog to run.
+ * @reset_on_resume:	set to 1 if the controller needs to be reset after
+ * 			a suspend / resume cycle (but can't detect that itself).
  *
  * These are general configuration options for the EHCI controller. All of
  * these options are activating more or less workarounds for some hardware.
@@ -45,6 +47,7 @@ struct usb_ehci_pdata {
 	unsigned	big_endian_desc:1;
 	unsigned	big_endian_mmio:1;
 	unsigned	no_io_watchdog:1;
+	unsigned	reset_on_resume:1;
 
 	/* Turn on all power and clocks */
 	int (*power_on)(struct platform_device *pdev);
