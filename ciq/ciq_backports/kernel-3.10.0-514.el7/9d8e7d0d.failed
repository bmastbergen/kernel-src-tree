IB/srp: Fix a memory descriptor leak in an error path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit 9d8e7d0dacf09ddac7e617d17dbeec6af56e81e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9d8e7d0d.failed

If an error occurs after srp_fr_pool_get() succeeded and before the
descriptor is stored in srp_map_state (*state->fr.next++ = desc)
then srp_unmap_data() won't free the newly allocated memory
descriptor. Hence free the descriptor explicitly.

Fixes: f7f7aab1a5c0 ("IB/srp: Convert to new registration API")
	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Tested-by: Laurence Oberman <loberman@redhat.com>
	Cc: Sagi Grimberg <sai@grimberg.me>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: <stable@vger.kernel.org> # v4.4+
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 9d8e7d0dacf09ddac7e617d17dbeec6af56e81e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/srp/ib_srp.c
diff --cc drivers/infiniband/ulp/srp/ib_srp.c
index eb57f69536ed,527503d06952..000000000000
--- a/drivers/infiniband/ulp/srp/ib_srp.c
+++ b/drivers/infiniband/ulp/srp/ib_srp.c
@@@ -1326,21 -1329,27 +1326,32 @@@ static int srp_map_finish_fr(struct srp
  	rkey = ib_inc_rkey(desc->mr->rkey);
  	ib_update_fast_reg_key(desc->mr, rkey);
  
++<<<<<<< HEAD
 +	memcpy(desc->frpl->page_list, state->pages,
 +	       sizeof(state->pages[0]) * state->npages);
++=======
+ 	n = ib_map_mr_sg(desc->mr, state->sg, sg_nents, 0, dev->mr_page_size);
+ 	if (unlikely(n < 0)) {
+ 		srp_fr_pool_put(ch->fr_pool, &desc, 1);
+ 		pr_debug("%s: ib_map_mr_sg(%d) returned %d.\n",
+ 			 dev_name(&req->scmnd->device->sdev_gendev), sg_nents,
+ 			 n);
+ 		return n;
+ 	}
 -
 -	req->reg_cqe.done = srp_reg_mr_err_done;
 -
 -	wr.wr.next = NULL;
 -	wr.wr.opcode = IB_WR_REG_MR;
 -	wr.wr.wr_cqe = &req->reg_cqe;
 -	wr.wr.num_sge = 0;
 -	wr.wr.send_flags = 0;
 -	wr.mr = desc->mr;
 -	wr.key = desc->mr->rkey;
 -	wr.access = (IB_ACCESS_LOCAL_WRITE |
 -		     IB_ACCESS_REMOTE_READ |
 -		     IB_ACCESS_REMOTE_WRITE);
++>>>>>>> 9d8e7d0dacf0 (IB/srp: Fix a memory descriptor leak in an error path)
 +
 +	memset(&wr, 0, sizeof(wr));
 +	wr.opcode = IB_WR_FAST_REG_MR;
 +	wr.wr_id = FAST_REG_WR_ID_MASK;
 +	wr.wr.fast_reg.iova_start = state->base_dma_addr;
 +	wr.wr.fast_reg.page_list = desc->frpl;
 +	wr.wr.fast_reg.page_list_len = state->npages;
 +	wr.wr.fast_reg.page_shift = ilog2(dev->mr_page_size);
 +	wr.wr.fast_reg.length = state->dma_len;
 +	wr.wr.fast_reg.access_flags = (IB_ACCESS_LOCAL_WRITE |
 +				       IB_ACCESS_REMOTE_READ |
 +				       IB_ACCESS_REMOTE_WRITE);
 +	wr.wr.fast_reg.rkey = desc->mr->lkey;
  
  	*state->fr.next++ = desc;
  	state->nmdesc++;
* Unmerged path drivers/infiniband/ulp/srp/ib_srp.c
