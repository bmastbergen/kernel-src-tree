mmc: sdhci: Parameterize ADMA sizes and alignment

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 76fe379acaeb857f91705f3bd5c6f69ec13872a9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/76fe379a.failed

In preparation for 64-bit ADMA, parameterize ADMA sizes
and alignment.  64-bit ADMA has a larger descriptor
because it contains a 64-bit address instead of a 32-bit
address.  Also data must be 8-byte aligned instead
of 4-byte aligned.  Consequently, sdhci_host members
are added for descriptor, table, and buffer sizes
and alignment.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 76fe379acaeb857f91705f3bd5c6f69ec13872a9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci.c
diff --cc drivers/mmc/host/sdhci.c
index e2d27069abbd,053b55df9df1..000000000000
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@@ -2871,30 -2872,35 +2865,42 @@@ int sdhci_add_host(struct sdhci_host *h
  
  	if (host->flags & SDHCI_USE_ADMA) {
  		/*
- 		 * We need to allocate descriptors for all sg entries
- 		 * (128) and potentially one alignment transfer for
- 		 * each of those entries.
+ 		 * The DMA descriptor table size is calculated as the maximum
+ 		 * number of segments times 2, to allow for an alignment
+ 		 * descriptor for each segment, plus 1 for a nop end descriptor,
+ 		 * all multipled by the descriptor size.
  		 */
+ 		host->adma_table_sz = (128 * 2 + 1) * 8;
+ 		host->align_buffer_sz = 128 * 4;
+ 		host->desc_sz = 8;
+ 		host->align_sz = 4;
+ 		host->align_mask = 3;
  		host->adma_table = dma_alloc_coherent(mmc_dev(mmc),
- 						      ADMA_SIZE,
+ 						      host->adma_table_sz,
  						      &host->adma_addr,
  						      GFP_KERNEL);
- 		host->align_buffer = kmalloc(128 * 4, GFP_KERNEL);
+ 		host->align_buffer = kmalloc(host->align_buffer_sz, GFP_KERNEL);
  		if (!host->adma_table || !host->align_buffer) {
- 			dma_free_coherent(mmc_dev(mmc), ADMA_SIZE,
+ 			dma_free_coherent(mmc_dev(mmc), host->adma_table_sz,
  					  host->adma_table, host->adma_addr);
  			kfree(host->align_buffer);
 -			pr_warn("%s: Unable to allocate ADMA buffers - falling back to standard DMA\n",
 +			pr_warning("%s: Unable to allocate ADMA "
 +				"buffers. Falling back to standard DMA.\n",
  				mmc_hostname(mmc));
  			host->flags &= ~SDHCI_USE_ADMA;
  			host->adma_table = NULL;
  			host->align_buffer = NULL;
++<<<<<<< HEAD
 +		} else if (host->adma_addr & 3) {
 +			pr_warning("%s: unable to allocate aligned ADMA descriptor\n",
 +				   mmc_hostname(mmc));
++=======
+ 		} else if (host->adma_addr & host->align_mask) {
+ 			pr_warn("%s: unable to allocate aligned ADMA descriptor\n",
+ 				mmc_hostname(mmc));
++>>>>>>> 76fe379acaeb (mmc: sdhci: Parameterize ADMA sizes and alignment)
  			host->flags &= ~SDHCI_USE_ADMA;
- 			dma_free_coherent(mmc_dev(mmc), ADMA_SIZE,
+ 			dma_free_coherent(mmc_dev(mmc), host->adma_table_sz,
  					  host->adma_table, host->adma_addr);
  			kfree(host->align_buffer);
  			host->adma_table = NULL;
* Unmerged path drivers/mmc/host/sdhci.c
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index 7c176e5d3cf5..298122644410 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -154,9 +154,16 @@ struct sdhci_host {
 	void *adma_table;	/* ADMA descriptor table */
 	void *align_buffer;	/* Bounce buffer */
 
+	size_t adma_table_sz;	/* ADMA descriptor table size */
+	size_t align_buffer_sz;	/* Bounce buffer size */
+
 	dma_addr_t adma_addr;	/* Mapped ADMA descr. table */
 	dma_addr_t align_addr;	/* Mapped bounce buffer */
 
+	unsigned int desc_sz;	/* ADMA descriptor size */
+	unsigned int align_sz;	/* ADMA alignment */
+	unsigned int align_mask;	/* ADMA alignment mask */
+
 	struct tasklet_struct finish_tasklet;	/* Tasklet structures */
 
 	struct timer_list timer;	/* Timer for timeouts */
