xprtrdma: Stack relief in fmr_op_map()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit acb9da7a57d7905c46d0b69d30fcf944eae261de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/acb9da7a.failed

fmr_op_map() declares a 64 element array of u64 in automatic
storage. This is 512 bytes (8 * 64) on the stack.

Instead, when FMR memory registration is in use, pre-allocate a
physaddr array for each rpcrdma_mw.

This is a pre-requisite for increasing the r/wsize maximum for
FMR on platforms with 4KB pages.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Reviewed-by: Steve Wise <swise@opengridcomputing.com>
	Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
	Reviewed-by: Devesh Sharma <devesh.sharma@avagotech.com>
Tested-By: Devesh Sharma <devesh.sharma@avagotech.com>
	Reviewed-by: Doug Ledford <dledford@redhat.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit acb9da7a57d7905c46d0b69d30fcf944eae261de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/fmr_ops.c
diff --cc net/sunrpc/xprtrdma/fmr_ops.c
index e0da9f8f1686,4a53ad5ab4b3..000000000000
--- a/net/sunrpc/xprtrdma/fmr_ops.c
+++ b/net/sunrpc/xprtrdma/fmr_ops.c
@@@ -55,8 -70,9 +55,9 @@@ fmr_op_init(struct rpcrdma_xprt *r_xprt
  	INIT_LIST_HEAD(&buf->rb_all);
  
  	i = (buf->rb_max_requests + 1) * RPCRDMA_MAX_SEGS;
 -	dprintk("RPC:       %s: initializing %d FMRs\n", __func__, i);
 +	dprintk("RPC:       %s: initalizing %d FMRs\n", __func__, i);
  
+ 	rc = -ENOMEM;
  	while (i--) {
  		r = kzalloc(sizeof(*r), GFP_KERNEL);
  		if (!r)
@@@ -78,6 -102,15 +87,18 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ __fmr_unmap(struct rpcrdma_mw *r)
+ {
+ 	LIST_HEAD(l);
+ 
+ 	list_add(&r->r.fmr.fmr->list, &l);
+ 	return ib_unmap_fmr(&l);
+ }
+ 
++>>>>>>> acb9da7a57d7 (xprtrdma: Stack relief in fmr_op_map())
  /* Use the ib_map_phys_fmr() verb to register a memory region
   * for remote access via RDMA READ or RDMA WRITE.
   */
@@@ -86,12 -119,24 +107,15 @@@ fmr_op_map(struct rpcrdma_xprt *r_xprt
  	   int nsegs, bool writing)
  {
  	struct rpcrdma_ia *ia = &r_xprt->rx_ia;
 -	struct ib_device *device = ia->ri_device;
 +	struct ib_device *device = ia->ri_id->device;
  	enum dma_data_direction direction = rpcrdma_data_dir(writing);
  	struct rpcrdma_mr_seg *seg1 = seg;
++<<<<<<< HEAD
 +	struct rpcrdma_mw *mw = seg1->rl_mw;
 +	u64 physaddrs[RPCRDMA_MAX_DATA_SEGS];
++=======
++>>>>>>> acb9da7a57d7 (xprtrdma: Stack relief in fmr_op_map())
  	int len, pageoff, i, rc;
 -	struct rpcrdma_mw *mw;
 -
 -	mw = seg1->rl_mw;
 -	seg1->rl_mw = NULL;
 -	if (!mw) {
 -		mw = rpcrdma_get_mw(r_xprt);
 -		if (!mw)
 -			return -ENOMEM;
 -	} else {
 -		/* this is a retransmit; generate a fresh rkey */
 -		rc = __fmr_unmap(mw);
 -		if (rc)
 -			return rc;
 -	}
  
  	pageoff = offset_in_page(seg1->mr_offset);
  	seg1->mr_offset -= pageoff;	/* start of page */
@@@ -115,7 -161,8 +140,12 @@@
  	if (rc)
  		goto out_maperr;
  
++<<<<<<< HEAD
 +	seg1->mr_rkey = mw->r.fmr->rkey;
++=======
+ 	seg1->rl_mw = mw;
+ 	seg1->mr_rkey = mw->r.fmr.fmr->rkey;
++>>>>>>> acb9da7a57d7 (xprtrdma: Stack relief in fmr_op_map())
  	seg1->mr_base = seg1->mr_dma + pageoff;
  	seg1->mr_nsegs = i;
  	seg1->mr_len = len;
* Unmerged path net/sunrpc/xprtrdma/fmr_ops.c
diff --git a/net/sunrpc/xprtrdma/xprt_rdma.h b/net/sunrpc/xprtrdma/xprt_rdma.h
index f254b5f275b4..0c93d46234a7 100644
--- a/net/sunrpc/xprtrdma/xprt_rdma.h
+++ b/net/sunrpc/xprtrdma/xprt_rdma.h
@@ -204,9 +204,14 @@ struct rpcrdma_frmr {
 	struct rpcrdma_xprt		*fr_xprt;
 };
 
+struct rpcrdma_fmr {
+	struct ib_fmr		*fmr;
+	u64			*physaddrs;
+};
+
 struct rpcrdma_mw {
 	union {
-		struct ib_fmr		*fmr;
+		struct rpcrdma_fmr	fmr;
 		struct rpcrdma_frmr	frmr;
 	} r;
 	void			(*mw_sendcompletion)(struct ib_wc *);
