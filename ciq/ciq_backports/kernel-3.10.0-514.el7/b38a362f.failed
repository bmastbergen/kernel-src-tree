mei: add a handler that waits for notification on event

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit b38a362fad6686dd580a50590053a76ded601a0b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b38a362f.failed

mei_cl_notify_get is to be called by a host client
to wait, receive, and ack the event notification.

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit b38a362fad6686dd580a50590053a76ded601a0b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/client.c
#	drivers/misc/mei/client.h
#	drivers/misc/mei/hbm.c
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/client.c
index 3c539de435ba,d9396838774c..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -262,10 -555,12 +262,16 @@@ void mei_cl_init(struct mei_cl *cl, str
  	init_waitqueue_head(&cl->wait);
  	init_waitqueue_head(&cl->rx_wait);
  	init_waitqueue_head(&cl->tx_wait);
++<<<<<<< HEAD
++=======
+ 	init_waitqueue_head(&cl->ev_wait);
+ 	INIT_LIST_HEAD(&cl->rd_completed);
+ 	INIT_LIST_HEAD(&cl->rd_pending);
++>>>>>>> b38a362fad66 (mei: add a handler that waits for notification on event)
  	INIT_LIST_HEAD(&cl->link);
 +	INIT_LIST_HEAD(&cl->device_link);
 +	cl->reading_state = MEI_IDLE;
  	cl->writing_state = MEI_IDLE;
 -	cl->state = MEI_FILE_INITIALIZING;
  	cl->dev = dev;
  }
  
@@@ -717,6 -1210,192 +723,195 @@@ int mei_cl_flow_ctrl_reduce(struct mei_
  }
  
  /**
++<<<<<<< HEAD
++=======
+  *  mei_cl_notify_fop2req - convert fop to proper request
+  *
+  * @fop: client notification start response command
+  *
+  * Return:  MEI_HBM_NOTIFICATION_START/STOP
+  */
+ u8 mei_cl_notify_fop2req(enum mei_cb_file_ops fop)
+ {
+ 	if (fop == MEI_FOP_NOTIFY_START)
+ 		return MEI_HBM_NOTIFICATION_START;
+ 	else
+ 		return MEI_HBM_NOTIFICATION_STOP;
+ }
+ 
+ /**
+  *  mei_cl_notify_req2fop - convert notification request top file operation type
+  *
+  * @req: hbm notification request type
+  *
+  * Return:  MEI_FOP_NOTIFY_START/STOP
+  */
+ enum mei_cb_file_ops mei_cl_notify_req2fop(u8 req)
+ {
+ 	if (req == MEI_HBM_NOTIFICATION_START)
+ 		return MEI_FOP_NOTIFY_START;
+ 	else
+ 		return MEI_FOP_NOTIFY_STOP;
+ }
+ 
+ /**
+  * mei_cl_irq_notify - send notification request in irq_thread context
+  *
+  * @cl: client
+  * @cb: callback block.
+  * @cmpl_list: complete list.
+  *
+  * Return: 0 on such and error otherwise.
+  */
+ int mei_cl_irq_notify(struct mei_cl *cl, struct mei_cl_cb *cb,
+ 		      struct mei_cl_cb *cmpl_list)
+ {
+ 	struct mei_device *dev = cl->dev;
+ 	u32 msg_slots;
+ 	int slots;
+ 	int ret;
+ 	bool request;
+ 
+ 	msg_slots = mei_data2slots(sizeof(struct hbm_client_connect_request));
+ 	slots = mei_hbuf_empty_slots(dev);
+ 
+ 	if (slots < msg_slots)
+ 		return -EMSGSIZE;
+ 
+ 	request = mei_cl_notify_fop2req(cb->fop_type);
+ 	ret = mei_hbm_cl_notify_req(dev, cl, request);
+ 	if (ret) {
+ 		cl->status = ret;
+ 		list_move_tail(&cb->list, &cmpl_list->list);
+ 		return ret;
+ 	}
+ 
+ 	list_move_tail(&cb->list, &dev->ctrl_rd_list.list);
+ 	return 0;
+ }
+ 
+ /**
+  * mei_cl_notify_request - send notification stop/start request
+  *
+  * @cl: host client
+  * @file: associate request with file
+  * @request: 1 for start or 0 for stop
+  *
+  * Locking: called under "dev->device_lock" lock
+  *
+  * Return: 0 on such and error otherwise.
+  */
+ int mei_cl_notify_request(struct mei_cl *cl, struct file *file, u8 request)
+ {
+ 	struct mei_device *dev;
+ 	struct mei_cl_cb *cb;
+ 	enum mei_cb_file_ops fop_type;
+ 	int rets;
+ 
+ 	if (WARN_ON(!cl || !cl->dev))
+ 		return -ENODEV;
+ 
+ 	dev = cl->dev;
+ 
+ 	if (!dev->hbm_f_ev_supported) {
+ 		cl_dbg(dev, cl, "notifications not supported\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	rets = pm_runtime_get(dev->dev);
+ 	if (rets < 0 && rets != -EINPROGRESS) {
+ 		pm_runtime_put_noidle(dev->dev);
+ 		cl_err(dev, cl, "rpm: get failed %d\n", rets);
+ 		return rets;
+ 	}
+ 
+ 	fop_type = mei_cl_notify_req2fop(request);
+ 	cb = mei_io_cb_init(cl, fop_type, file);
+ 	if (!cb) {
+ 		rets = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	if (mei_hbuf_acquire(dev)) {
+ 		if (mei_hbm_cl_notify_req(dev, cl, request)) {
+ 			rets = -ENODEV;
+ 			goto out;
+ 		}
+ 		list_add_tail(&cb->list, &dev->ctrl_rd_list.list);
+ 	} else {
+ 		list_add_tail(&cb->list, &dev->ctrl_wr_list.list);
+ 	}
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 	wait_event_timeout(cl->wait, cl->notify_en == request,
+ 			mei_secs_to_jiffies(MEI_CL_CONNECT_TIMEOUT));
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (cl->notify_en != request) {
+ 		mei_io_list_flush(&dev->ctrl_rd_list, cl);
+ 		mei_io_list_flush(&dev->ctrl_wr_list, cl);
+ 		if (!cl->status)
+ 			cl->status = -EFAULT;
+ 	}
+ 
+ 	rets = cl->status;
+ 
+ out:
+ 	cl_dbg(dev, cl, "rpm: autosuspend\n");
+ 	pm_runtime_mark_last_busy(dev->dev);
+ 	pm_runtime_put_autosuspend(dev->dev);
+ 
+ 	mei_io_cb_free(cb);
+ 	return rets;
+ }
+ 
+ /**
+  * mei_cl_notify_get - get or wait for notification event
+  *
+  * @cl: host client
+  * @block: this request is blocking
+  * @notify_ev: true if notification event was received
+  *
+  * Locking: called under "dev->device_lock" lock
+  *
+  * Return: 0 on such and error otherwise.
+  */
+ int mei_cl_notify_get(struct mei_cl *cl, bool block, bool *notify_ev)
+ {
+ 	struct mei_device *dev;
+ 	int rets;
+ 
+ 	*notify_ev = false;
+ 
+ 	if (WARN_ON(!cl || !cl->dev))
+ 		return -ENODEV;
+ 
+ 	dev = cl->dev;
+ 
+ 	if (!mei_cl_is_connected(cl))
+ 		return -ENODEV;
+ 
+ 	if (cl->notify_ev)
+ 		goto out;
+ 
+ 	if (!block)
+ 		return -EAGAIN;
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 	rets = wait_event_interruptible(cl->ev_wait, cl->notify_ev);
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (rets < 0)
+ 		return rets;
+ 
+ out:
+ 	*notify_ev = cl->notify_ev;
+ 	cl->notify_ev = false;
+ 	return 0;
+ }
+ 
+ /**
++>>>>>>> b38a362fad66 (mei: add a handler that waits for notification on event)
   * mei_cl_read_start - the start read client message function.
   *
   * @cl: host client
diff --cc drivers/misc/mei/client.h
index f2a130967f1e,58a4b49701fe..000000000000
--- a/drivers/misc/mei/client.h
+++ b/drivers/misc/mei/client.h
@@@ -91,7 -219,12 +91,16 @@@ void mei_cl_complete(struct mei_cl *cl
  
  void mei_host_client_init(struct work_struct *work);
  
- 
++<<<<<<< HEAD
++
++=======
+ u8 mei_cl_notify_fop2req(enum mei_cb_file_ops fop);
+ enum mei_cb_file_ops mei_cl_notify_req2fop(u8 request);
+ int mei_cl_notify_request(struct mei_cl *cl, struct file *file, u8 request);
+ int mei_cl_irq_notify(struct mei_cl *cl, struct mei_cl_cb *cb,
+ 		      struct mei_cl_cb *cmpl_list);
+ int mei_cl_notify_get(struct mei_cl *cl, bool block, bool *notify_ev);
++>>>>>>> b38a362fad66 (mei: add a handler that waits for notification on event)
  
  void mei_cl_all_disconnect(struct mei_device *dev);
  void mei_cl_all_wakeup(struct mei_device *dev);
diff --cc drivers/misc/mei/hbm.c
index 3cb8e1000d69,70c94a9cd905..000000000000
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@@ -288,6 -312,214 +288,217 @@@ static int mei_hbm_enum_clients_req(str
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * mei_hbm_me_cl_add - add new me client to the list
+  *
+  * @dev: the device structure
+  * @res: hbm property response
+  *
+  * Return: 0 on success and -ENOMEM on allocation failure
+  */
+ 
+ static int mei_hbm_me_cl_add(struct mei_device *dev,
+ 			     struct hbm_props_response *res)
+ {
+ 	struct mei_me_client *me_cl;
+ 	const uuid_le *uuid = &res->client_properties.protocol_name;
+ 
+ 	mei_me_cl_rm_by_uuid(dev, uuid);
+ 
+ 	me_cl = kzalloc(sizeof(struct mei_me_client), GFP_KERNEL);
+ 	if (!me_cl)
+ 		return -ENOMEM;
+ 
+ 	mei_me_cl_init(me_cl);
+ 
+ 	me_cl->props = res->client_properties;
+ 	me_cl->client_id = res->me_addr;
+ 	me_cl->mei_flow_ctrl_creds = 0;
+ 
+ 	mei_me_cl_add(dev, me_cl);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * mei_hbm_add_cl_resp - send response to fw on client add request
+  *
+  * @dev: the device structure
+  * @addr: me address
+  * @status: response status
+  *
+  * Return: 0 on success and < 0 on failure
+  */
+ static int mei_hbm_add_cl_resp(struct mei_device *dev, u8 addr, u8 status)
+ {
+ 	struct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;
+ 	struct hbm_add_client_response *resp;
+ 	const size_t len = sizeof(struct hbm_add_client_response);
+ 	int ret;
+ 
+ 	dev_dbg(dev->dev, "adding client response\n");
+ 
+ 	resp = (struct hbm_add_client_response *)dev->wr_msg.data;
+ 
+ 	mei_hbm_hdr(mei_hdr, len);
+ 	memset(resp, 0, sizeof(struct hbm_add_client_response));
+ 
+ 	resp->hbm_cmd = MEI_HBM_ADD_CLIENT_RES_CMD;
+ 	resp->me_addr = addr;
+ 	resp->status  = status;
+ 
+ 	ret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);
+ 	if (ret)
+ 		dev_err(dev->dev, "add client response write failed: ret = %d\n",
+ 			ret);
+ 	return ret;
+ }
+ 
+ /**
+  * mei_hbm_fw_add_cl_req - request from the fw to add a client
+  *
+  * @dev: the device structure
+  * @req: add client request
+  *
+  * Return: 0 on success and < 0 on failure
+  */
+ static int mei_hbm_fw_add_cl_req(struct mei_device *dev,
+ 			      struct hbm_add_client_request *req)
+ {
+ 	int ret;
+ 	u8 status = MEI_HBMS_SUCCESS;
+ 
+ 	BUILD_BUG_ON(sizeof(struct hbm_add_client_request) !=
+ 			sizeof(struct hbm_props_response));
+ 
+ 	ret = mei_hbm_me_cl_add(dev, (struct hbm_props_response *)req);
+ 	if (ret)
+ 		status = !MEI_HBMS_SUCCESS;
+ 
+ 	return mei_hbm_add_cl_resp(dev, req->me_addr, status);
+ }
+ 
+ /**
+  * mei_hbm_cl_notify_req - send notification request
+  *
+  * @dev: the device structure
+  * @cl: a client to disconnect from
+  * @start: true for start false for stop
+  *
+  * Return: 0 on success and -EIO on write failure
+  */
+ int mei_hbm_cl_notify_req(struct mei_device *dev,
+ 			  struct mei_cl *cl, u8 start)
+ {
+ 
+ 	struct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;
+ 	struct hbm_notification_request *req;
+ 	const size_t len = sizeof(struct hbm_notification_request);
+ 	int ret;
+ 
+ 	mei_hbm_hdr(mei_hdr, len);
+ 	mei_hbm_cl_hdr(cl, MEI_HBM_NOTIFY_REQ_CMD, dev->wr_msg.data, len);
+ 
+ 	req = (struct hbm_notification_request *)dev->wr_msg.data;
+ 	req->start = start;
+ 
+ 	ret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);
+ 	if (ret)
+ 		dev_err(dev->dev, "notify request failed: ret = %d\n", ret);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  *  notify_res_to_fop - convert notification response to the proper
+  *      notification FOP
+  *
+  * @cmd: client notification start response command
+  *
+  * Return:  MEI_FOP_NOTIFY_START or MEI_FOP_NOTIFY_STOP;
+  */
+ static inline enum mei_cb_file_ops notify_res_to_fop(struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct hbm_notification_response *rs =
+ 		(struct hbm_notification_response *)cmd;
+ 
+ 	return mei_cl_notify_req2fop(rs->start);
+ }
+ 
+ /**
+  * mei_hbm_cl_notify_start_res - update the client state according
+  *       notify start response
+  *
+  * @dev: the device structure
+  * @cl: mei host client
+  * @cmd: client notification start response command
+  */
+ static void mei_hbm_cl_notify_start_res(struct mei_device *dev,
+ 					struct mei_cl *cl,
+ 					struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct hbm_notification_response *rs =
+ 		(struct hbm_notification_response *)cmd;
+ 
+ 	cl_dbg(dev, cl, "hbm: notify start response status=%d\n", rs->status);
+ 
+ 	if (rs->status == MEI_HBMS_SUCCESS ||
+ 	    rs->status == MEI_HBMS_ALREADY_STARTED) {
+ 		cl->notify_en = true;
+ 		cl->status = 0;
+ 	} else {
+ 		cl->status = -EINVAL;
+ 	}
+ }
+ 
+ /**
+  * mei_hbm_cl_notify_stop_res - update the client state according
+  *       notify stop response
+  *
+  * @dev: the device structure
+  * @cl: mei host client
+  * @cmd: client notification stop response command
+  */
+ static void mei_hbm_cl_notify_stop_res(struct mei_device *dev,
+ 				       struct mei_cl *cl,
+ 				       struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct hbm_notification_response *rs =
+ 		(struct hbm_notification_response *)cmd;
+ 
+ 	cl_dbg(dev, cl, "hbm: notify stop response status=%d\n", rs->status);
+ 
+ 	if (rs->status == MEI_HBMS_SUCCESS ||
+ 	    rs->status == MEI_HBMS_NOT_STARTED) {
+ 		cl->notify_en = false;
+ 		cl->status = 0;
+ 	} else {
+ 		/* TODO: spec is not clear yet about other possible issues */
+ 		cl->status = -EINVAL;
+ 	}
+ }
+ 
+ /**
+  * mei_hbm_cl_notify - signal notification event
+  *
+  * @dev: the device structure
+  * @cmd: notification client message
+  */
+ static void mei_hbm_cl_notify(struct mei_device *dev,
+ 			      struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct mei_cl *cl;
+ 
+ 	cl = mei_hbm_cl_find_by_cmd(dev, cmd);
+ 	if (cl && cl->notify_en) {
+ 		cl->notify_ev = true;
+ 		wake_up_interruptible(&cl->ev_wait);
+ 	}
+ }
+ 
++>>>>>>> b38a362fad66 (mei: add a handler that waits for notification on event)
  /**
   * mei_hbm_prop_req - request property for a single client
   *
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,6f8f5e1e909e..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -201,10 -220,36 +201,38 @@@ struct mei_cl_cb 
  	unsigned long buf_idx;
  	unsigned long read_time;
  	struct file *file_object;
 -	int status;
  	u32 internal:1;
 -	u32 completed:1;
  };
  
++<<<<<<< HEAD
 +/* MEI client instance carried as file->private_data*/
++=======
+ /**
+  * struct mei_cl - me client host representation
+  *    carried in file->private_data
+  *
+  * @link: link in the clients list
+  * @dev: mei parent device
+  * @state: file operation state
+  * @tx_wait: wait queue for tx completion
+  * @rx_wait: wait queue for rx completion
+  * @wait:  wait queue for management operation
+  * @ev_wait: notification wait queue
+  * @status: connection status
+  * @me_cl: fw client connected
+  * @host_client_id: host id
+  * @mei_flow_ctrl_creds: transmit flow credentials
+  * @timer_count:  watchdog timer for operation completion
+  * @reserved: reserved for alignment
+  * @notify_en: notification - enabled/disabled
+  * @notify_ev: pending notification event
+  * @writing_state: state of the tx
+  * @rd_pending: pending read credits
+  * @rd_completed: completed read
+  *
+  * @cldev: device on the mei client bus
+  */
++>>>>>>> b38a362fad66 (mei: add a handler that waits for notification on event)
  struct mei_cl {
  	struct list_head link;
  	struct mei_device *dev;
@@@ -212,21 -257,20 +240,22 @@@
  	wait_queue_head_t tx_wait;
  	wait_queue_head_t rx_wait;
  	wait_queue_head_t wait;
+ 	wait_queue_head_t ev_wait;
  	int status;
 -	struct mei_me_client *me_cl;
 +	/* ID of client connected */
  	u8 host_client_id;
 +	u8 me_client_id;
  	u8 mei_flow_ctrl_creds;
  	u8 timer_count;
 -	u8 reserved;
 -	u8 notify_en;
 -	u8 notify_ev;
 +	enum mei_file_transaction_states reading_state;
  	enum mei_file_transaction_states writing_state;
 -	struct list_head rd_pending;
 -	struct list_head rd_completed;
 +	int sm_state;
 +	struct mei_cl_cb *read_cb;
  
 -	struct mei_cl_device *cldev;
 +	/* MEI CL bus data */
 +	struct mei_cl_device *device;
 +	struct list_head device_link;
 +	uuid_le device_uuid;
  };
  
  /** struct mei_hw_ops
* Unmerged path drivers/misc/mei/client.c
* Unmerged path drivers/misc/mei/client.h
* Unmerged path drivers/misc/mei/hbm.c
* Unmerged path drivers/misc/mei/mei_dev.h
