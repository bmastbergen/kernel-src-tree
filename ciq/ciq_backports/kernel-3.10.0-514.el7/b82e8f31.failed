net: sctp: refactor active path selection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] sctp: refactor active path selection (Xin Long) [1333696]
Rebuild_FUZZ: 93.51%
commit-author Daniel Borkmann <dborkman@redhat.com>
commit b82e8f31acc7d799638692e65ff017f3e1b6a43d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b82e8f31.failed

This patch just refactors and moves the code for the active
path selection into its own helper function outside of
sctp_assoc_control_transport() which is already big enough.
No functional changes here.

	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b82e8f31acc7d799638692e65ff017f3e1b6a43d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/associola.c
diff --cc net/sctp/associola.c
index 95613ef42a0c,9f1cc6f1535d..000000000000
--- a/net/sctp/associola.c
+++ b/net/sctp/associola.c
@@@ -897,58 -842,7 +896,62 @@@ void sctp_assoc_control_transport(struc
  	}
  
  	/* Select new active and retran paths. */
++<<<<<<< HEAD
 +
 +	/* Look for the two most recently used active transports.
 +	 *
 +	 * This code produces the wrong ordering whenever jiffies
 +	 * rolls over, but we still get usable transports, so we don't
 +	 * worry about it.
 +	 */
 +	first = NULL; second = NULL;
 +
 +	list_for_each_entry(t, &asoc->peer.transport_addr_list,
 +			transports) {
 +
 +		if ((t->state == SCTP_INACTIVE) ||
 +		    (t->state == SCTP_UNCONFIRMED) ||
 +		    (t->state == SCTP_PF))
 +			continue;
 +		if (!first || t->last_time_heard > first->last_time_heard) {
 +			second = first;
 +			first = t;
 +		}
 +		if (!second || t->last_time_heard > second->last_time_heard)
 +			second = t;
 +	}
 +
 +	/* RFC 2960 6.4 Multi-Homed SCTP Endpoints
 +	 *
 +	 * By default, an endpoint should always transmit to the
 +	 * primary path, unless the SCTP user explicitly specifies the
 +	 * destination transport address (and possibly source
 +	 * transport address) to use.
 +	 *
 +	 * [If the primary is active but not most recent, bump the most
 +	 * recently used transport.]
 +	 */
 +	if (((asoc->peer.primary_path->state == SCTP_ACTIVE) ||
 +	     (asoc->peer.primary_path->state == SCTP_UNKNOWN)) &&
 +	    first != asoc->peer.primary_path) {
 +		second = first;
 +		first = asoc->peer.primary_path;
 +	}
 +
 +	/* If we failed to find a usable transport, just camp on the
 +	 * primary, even if it is inactive.
 +	 */
 +	if (!first) {
 +		first = asoc->peer.primary_path;
 +		second = asoc->peer.primary_path;
 +	}
 +
 +	/* Set the active and retran transports.  */
 +	asoc->peer.active_path = first;
 +	asoc->peer.retran_path = second;
++=======
+ 	sctp_select_active_and_retran_path(asoc);
++>>>>>>> b82e8f31acc7 (net: sctp: refactor active path selection)
  }
  
  /* Hold a reference to an association. */
@@@ -1295,72 -1185,151 +1298,134 @@@ void sctp_assoc_update(struct sctp_asso
  }
  
  /* Update the retran path for sending a retransmitted packet.
 - * See also RFC4960, 6.4. Multi-Homed SCTP Endpoints:
 - *
 - *   When there is outbound data to send and the primary path
 - *   becomes inactive (e.g., due to failures), or where the
 - *   SCTP user explicitly requests to send data to an
 - *   inactive destination transport address, before reporting
 - *   an error to its ULP, the SCTP endpoint should try to send
 - *   the data to an alternate active destination transport
 - *   address if one exists.
 - *
 - *   When retransmitting data that timed out, if the endpoint
 - *   is multihomed, it should consider each source-destination
 - *   address pair in its retransmission selection policy.
 - *   When retransmitting timed-out data, the endpoint should
 - *   attempt to pick the most divergent source-destination
 - *   pair from the original source-destination pair to which
 - *   the packet was transmitted.
 - *
 - *   Note: Rules for picking the most divergent source-destination
 - *   pair are an implementation decision and are not specified
 - *   within this document.
 - *
 - * Our basic strategy is to round-robin transports in priorities
 - * according to sctp_state_prio_map[] e.g., if no such
 - * transport with state SCTP_ACTIVE exists, round-robin through
 - * SCTP_UNKNOWN, etc. You get the picture.
 + * Round-robin through the active transports, else round-robin
 + * through the inactive transports as this is the next best thing
 + * we can try.
   */
 -static const u8 sctp_trans_state_to_prio_map[] = {
 -	[SCTP_ACTIVE]	= 3,	/* best case */
 -	[SCTP_UNKNOWN]	= 2,
 -	[SCTP_PF]	= 1,
 -	[SCTP_INACTIVE] = 0,	/* worst case */
 -};
 -
 -static u8 sctp_trans_score(const struct sctp_transport *trans)
 -{
 -	return sctp_trans_state_to_prio_map[trans->state];
 -}
 -
 -static struct sctp_transport *sctp_trans_elect_best(struct sctp_transport *curr,
 -						    struct sctp_transport *best)
 -{
 -	if (best == NULL)
 -		return curr;
 -
 -	return sctp_trans_score(curr) > sctp_trans_score(best) ? curr : best;
 -}
 -
  void sctp_assoc_update_retran_path(struct sctp_association *asoc)
  {
 -	struct sctp_transport *trans = asoc->peer.retran_path;
 -	struct sctp_transport *trans_next = NULL;
 +	struct sctp_transport *t, *next;
 +	struct list_head *head = &asoc->peer.transport_addr_list;
 +	struct list_head *pos;
  
 -	/* We're done as we only have the one and only path. */
  	if (asoc->peer.transport_count == 1)
  		return;
 -	/* If active_path and retran_path are the same and active,
 -	 * then this is the only active path. Use it.
 -	 */
 -	if (asoc->peer.active_path == asoc->peer.retran_path &&
 -	    asoc->peer.active_path->state == SCTP_ACTIVE)
 -		return;
  
 -	/* Iterate from retran_path's successor back to retran_path. */
 -	for (trans = list_next_entry(trans, transports); 1;
 -	     trans = list_next_entry(trans, transports)) {
 -		/* Manually skip the head element. */
 -		if (&trans->transports == &asoc->peer.transport_addr_list)
 -			continue;
 -		if (trans->state == SCTP_UNCONFIRMED)
 -			continue;
 -		trans_next = sctp_trans_elect_best(trans, trans_next);
 -		/* Active is good enough for immediate return. */
 -		if (trans_next->state == SCTP_ACTIVE)
 +	/* Find the next transport in a round-robin fashion. */
 +	t = asoc->peer.retran_path;
 +	pos = &t->transports;
 +	next = NULL;
 +
 +	while (1) {
 +		/* Skip the head. */
 +		if (pos->next == head)
 +			pos = head->next;
 +		else
 +			pos = pos->next;
 +
 +		t = list_entry(pos, struct sctp_transport, transports);
 +
 +		/* We have exhausted the list, but didn't find any
 +		 * other active transports.  If so, use the next
 +		 * transport.
 +		 */
 +		if (t == asoc->peer.retran_path) {
 +			t = next;
  			break;
 -		/* We've reached the end, time to update path. */
 -		if (trans == asoc->peer.retran_path)
 +		}
 +
 +		/* Try to find an active transport. */
 +
 +		if ((t->state == SCTP_ACTIVE) ||
 +		    (t->state == SCTP_UNKNOWN)) {
  			break;
 +		} else {
 +			/* Keep track of the next transport in case
 +			 * we don't find any active transport.
 +			 */
 +			if (t->state != SCTP_UNCONFIRMED && !next)
 +				next = t;
 +		}
  	}
  
 -	asoc->peer.retran_path = trans_next;
 -
 -	pr_debug("%s: association:%p updated new path to addr:%pISpc\n",
 -		 __func__, asoc, &asoc->peer.retran_path->ipaddr.sa);
 +	if (t)
 +		asoc->peer.retran_path = t;
 +	else
 +		t = asoc->peer.retran_path;
 +
 +	SCTP_DEBUG_PRINTK_IPADDR("sctp_assoc_update_retran_path:association"
 +				 " %p addr: ",
 +				 " port: %d\n",
 +				 asoc,
 +				 (&t->ipaddr),
 +				 ntohs(t->ipaddr.v4.sin_port));
  }
  
++<<<<<<< HEAD
 +/* Choose the transport for sending retransmit packet.  */
 +struct sctp_transport *sctp_assoc_choose_alter_transport(
 +	struct sctp_association *asoc, struct sctp_transport *last_sent_to)
++=======
+ static void sctp_select_active_and_retran_path(struct sctp_association *asoc)
+ {
+ 	struct sctp_transport *trans, *trans_pri = NULL, *trans_sec = NULL;
+ 
+ 	/* Look for the two most recently used active transports. */
+ 	list_for_each_entry(trans, &asoc->peer.transport_addr_list,
+ 			    transports) {
+ 		if (trans->state == SCTP_INACTIVE ||
+ 		    trans->state == SCTP_UNCONFIRMED ||
+ 		    trans->state == SCTP_PF)
+ 			continue;
+ 		if (trans_pri == NULL ||
+ 		    trans->last_time_heard > trans_pri->last_time_heard) {
+ 			trans_sec = trans_pri;
+ 			trans_pri = trans;
+ 		} else if (trans_sec == NULL ||
+ 			   trans->last_time_heard > trans_sec->last_time_heard) {
+ 			trans_sec = trans;
+ 		}
+ 	}
+ 
+ 	/* RFC 2960 6.4 Multi-Homed SCTP Endpoints
+ 	 *
+ 	 * By default, an endpoint should always transmit to the primary
+ 	 * path, unless the SCTP user explicitly specifies the
+ 	 * destination transport address (and possibly source transport
+ 	 * address) to use. [If the primary is active but not most recent,
+ 	 * bump the most recently used transport.]
+ 	 */
+ 	if ((asoc->peer.primary_path->state == SCTP_ACTIVE ||
+ 	     asoc->peer.primary_path->state == SCTP_UNKNOWN) &&
+ 	     asoc->peer.primary_path != trans_pri) {
+ 		trans_sec = trans_pri;
+ 		trans_pri = asoc->peer.primary_path;
+ 	}
+ 
+ 	/* We did not find anything useful for a possible retransmission
+ 	 * path; either primary path that we found is the the same as
+ 	 * the current one, or we didn't generally find an active one.
+ 	 */
+ 	if (trans_sec == NULL)
+ 		trans_sec = trans_pri;
+ 
+ 	/* If we failed to find a usable transport, just camp on the
+ 	 * primary, even if they are inactive.
+ 	 */
+ 	if (trans_pri == NULL) {
+ 		trans_pri = asoc->peer.primary_path;
+ 		trans_sec = asoc->peer.primary_path;
+ 	}
+ 
+ 	/* Set the active and retran transports. */
+ 	asoc->peer.active_path = trans_pri;
+ 	asoc->peer.retran_path = trans_sec;
+ }
+ 
+ struct sctp_transport *
+ sctp_assoc_choose_alter_transport(struct sctp_association *asoc,
+ 				  struct sctp_transport *last_sent_to)
++>>>>>>> b82e8f31acc7 (net: sctp: refactor active path selection)
  {
  	/* If this is the first time packet is sent, use the active path,
  	 * else use the retran path. If the last packet was sent over the
* Unmerged path net/sctp/associola.c
