KVM: nVMX: Make nested control MSRs per-cpu

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Wincy Van <fanwenyi0529@gmail.com>
commit b9c237bb1db61f107b5d7cee5008e4a6b96ff800
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b9c237bb.failed

To enable nested apicv support, we need per-cpu vmx
control MSRs:
  1. If in-kernel irqchip is enabled, we can enable nested
     posted interrupt, we should set posted intr bit in
     the nested_vmx_pinbased_ctls_high.
  2. If in-kernel irqchip is disabled, we can not enable
     nested posted interrupt, the posted intr bit
     in the nested_vmx_pinbased_ctls_high will be cleared.

Since there would be different settings about in-kernel
irqchip between VMs, different nested control MSRs
are needed.

	Signed-off-by: Wincy Van <fanwenyi0529@gmail.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit b9c237bb1db61f107b5d7cee5008e4a6b96ff800)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 8ebb2b95d0d8,a17bbb862f91..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -2389,38 -2424,42 +2410,49 @@@ static void nested_vmx_setup_ctls_msrs(
  
  	/* secondary cpu-based controls */
  	rdmsr(MSR_IA32_VMX_PROCBASED_CTLS2,
- 		nested_vmx_secondary_ctls_low, nested_vmx_secondary_ctls_high);
- 	nested_vmx_secondary_ctls_low = 0;
- 	nested_vmx_secondary_ctls_high &=
+ 		vmx->nested.nested_vmx_secondary_ctls_low,
+ 		vmx->nested.nested_vmx_secondary_ctls_high);
+ 	vmx->nested.nested_vmx_secondary_ctls_low = 0;
+ 	vmx->nested.nested_vmx_secondary_ctls_high &=
  		SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
 -		SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |
 -		SECONDARY_EXEC_WBINVD_EXITING |
 -		SECONDARY_EXEC_XSAVES;
 +		SECONDARY_EXEC_WBINVD_EXITING;
  
  	if (enable_ept) {
  		/* nested EPT: emulate EPT also to L1 */
++<<<<<<< HEAD
 +		nested_vmx_secondary_ctls_high |= SECONDARY_EXEC_ENABLE_EPT;
 +		nested_vmx_ept_caps = VMX_EPT_PAGE_WALK_4_BIT |
++=======
+ 		vmx->nested.nested_vmx_secondary_ctls_high |=
+ 			SECONDARY_EXEC_ENABLE_EPT |
+ 			SECONDARY_EXEC_UNRESTRICTED_GUEST;
+ 		vmx->nested.nested_vmx_ept_caps = VMX_EPT_PAGE_WALK_4_BIT |
++>>>>>>> b9c237bb1db6 (KVM: nVMX: Make nested control MSRs per-cpu)
  			 VMX_EPTP_WB_BIT | VMX_EPT_2MB_PAGE_BIT |
  			 VMX_EPT_INVEPT_BIT;
- 		nested_vmx_ept_caps &= vmx_capability.ept;
+ 		vmx->nested.nested_vmx_ept_caps &= vmx_capability.ept;
  		/*
  		 * For nested guests, we don't do anything specific
  		 * for single context invalidation. Hence, only advertise
  		 * support for global context invalidation.
  		 */
- 		nested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT;
+ 		vmx->nested.nested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT;
  	} else
- 		nested_vmx_ept_caps = 0;
+ 		vmx->nested.nested_vmx_ept_caps = 0;
  
 +	if (enable_unrestricted_guest)
 +		nested_vmx_secondary_ctls_high |=
 +			SECONDARY_EXEC_UNRESTRICTED_GUEST;
 +
  	/* miscellaneous data */
- 	rdmsr(MSR_IA32_VMX_MISC, nested_vmx_misc_low, nested_vmx_misc_high);
- 	nested_vmx_misc_low &= VMX_MISC_SAVE_EFER_LMA;
- 	nested_vmx_misc_low |= VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE |
+ 	rdmsr(MSR_IA32_VMX_MISC,
+ 		vmx->nested.nested_vmx_misc_low,
+ 		vmx->nested.nested_vmx_misc_high);
+ 	vmx->nested.nested_vmx_misc_low &= VMX_MISC_SAVE_EFER_LMA;
+ 	vmx->nested.nested_vmx_misc_low |=
+ 		VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE |
  		VMX_MISC_ACTIVITY_HLT;
- 	nested_vmx_misc_high = 0;
+ 	vmx->nested.nested_vmx_misc_high = 0;
  }
  
  static inline bool vmx_control_verify(u32 control, u32 low, u32 high)
* Unmerged path arch/x86/kvm/vmx.c
