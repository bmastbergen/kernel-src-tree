mpt3sas: Move Gen3 HBA's device registration to a separate file

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sreekanth Reddy <sreekanth.reddy@avagotech.com>
commit 7497392a1193ea5b32d8a8a2b8d77888e7fe8221
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7497392a.failed

Created a mpt3sas_module.c file for mpt3sas driver where it can register
SAS3 HBA devices with PCI, SML, IOCTL subsystems. Also removed the
corresponding interfaces from mpt3sas_scsih.c file.

	Signed-off-by: Sreekanth Reddy <Sreekanth.Reddy@avagotech.com>
	Acked-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 7497392a1193ea5b32d8a8a2b8d77888e7fe8221)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpt3sas/mpt3sas_base.h
#	drivers/scsi/mpt3sas/mpt3sas_ctl.c
#	drivers/scsi/mpt3sas/mpt3sas_scsih.c
diff --cc drivers/scsi/mpt3sas/mpt3sas_base.h
index 4a187ecbb856,0f86729fcf25..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_base.h
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.h
@@@ -1098,6 -1107,39 +1099,42 @@@ struct _sas_device *mpt3sas_scsih_sas_d
  
  void mpt3sas_port_enable_complete(struct MPT3SAS_ADAPTER *ioc);
  
++<<<<<<< HEAD
++=======
+ void scsih_exit(void);
+ int scsih_init(void);
+ int scsih_probe(struct pci_dev *pdev, struct Scsi_Host *shost);
+ void scsih_remove(struct pci_dev *pdev);
+ void scsih_shutdown(struct pci_dev *pdev);
+ pci_ers_result_t scsih_pci_error_detected(struct pci_dev *pdev,
+ 	pci_channel_state_t state);
+ pci_ers_result_t scsih_pci_mmio_enabled(struct pci_dev *pdev);
+ pci_ers_result_t scsih_pci_slot_reset(struct pci_dev *pdev);
+ void scsih_pci_resume(struct pci_dev *pdev);
+ int scsih_suspend(struct pci_dev *pdev, pm_message_t state);
+ int scsih_resume(struct pci_dev *pdev);
+ 
+ int scsih_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *scmd);
+ int scsih_target_alloc(struct scsi_target *starget);
+ int scsih_slave_alloc(struct scsi_device *sdev);
+ int scsih_slave_configure(struct scsi_device *sdev);
+ void scsih_target_destroy(struct scsi_target *starget);
+ void scsih_slave_destroy(struct scsi_device *sdev);
+ int scsih_scan_finished(struct Scsi_Host *shost, unsigned long time);
+ void scsih_scan_start(struct Scsi_Host *shost);
+ int scsih_change_queue_depth(struct scsi_device *sdev, int qdepth);
+ int scsih_abort(struct scsi_cmnd *scmd);
+ int scsih_dev_reset(struct scsi_cmnd *scmd);
+ int scsih_target_reset(struct scsi_cmnd *scmd);
+ int scsih_host_reset(struct scsi_cmnd *scmd);
+ int scsih_bios_param(struct scsi_device *sdev, struct block_device *bdev,
+ 	sector_t capacity, int params[]);
+ 
+ int scsih_is_raid(struct device *dev);
+ void scsih_get_resync(struct device *dev);
+ void scsih_get_state(struct device *dev);
+ 
++>>>>>>> 7497392a1193 (mpt3sas: Move Gen3 HBA's device registration to a separate file)
  /* config shared API */
  u8 mpt3sas_config_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
  	u32 reply);
diff --cc drivers/scsi/mpt3sas/mpt3sas_ctl.c
index 704bdf20b4dc,ffe79829de30..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_ctl.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_ctl.c
@@@ -3218,34 -3218,14 +3218,33 @@@ struct device_attribute *mpt3sas_dev_at
  	NULL,
  };
  
++<<<<<<< HEAD
 +static const struct file_operations ctl_fops = {
 +	.owner = THIS_MODULE,
 +	.unlocked_ioctl = _ctl_ioctl,
 +	.poll = _ctl_poll,
 +	.fasync = _ctl_fasync,
 +#ifdef CONFIG_COMPAT
 +	.compat_ioctl = _ctl_ioctl_compat,
 +#endif
 +};
 +
 +static struct miscdevice ctl_dev = {
 +	.minor  = MPT3SAS_MINOR,
 +	.name   = MPT3SAS_DEV_NAME,
 +	.fops   = &ctl_fops,
 +};
 +
++=======
++>>>>>>> 7497392a1193 (mpt3sas: Move Gen3 HBA's device registration to a separate file)
  /**
 - * ctl_init - main entry point for ctl.
 + * mpt3sas_ctl_init - main entry point for ctl.
   *
   */
  void
 -ctl_init(void)
 +mpt3sas_ctl_init(void)
  {
  	async_queue = NULL;
- 	if (misc_register(&ctl_dev) < 0)
- 		pr_err("%s can't register misc device [minor=%d]\n",
- 		    MPT3SAS_DRIVER_NAME, MPT3SAS_MINOR);
- 
  	init_waitqueue_head(&ctl_poll_wait);
  }
  
diff --cc drivers/scsi/mpt3sas/mpt3sas_scsih.c
index d94b7501c72c,56726a0b37fb..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
@@@ -7549,36 -7455,6 +7518,39 @@@ mpt3sas_scsih_event_callback(struct MPT
  	return 1;
  }
  
++<<<<<<< HEAD
 +/* shost template */
 +static struct scsi_host_template scsih_driver_template = {
 +	.module				= THIS_MODULE,
 +	.name				= "Fusion MPT SAS Host",
 +	.proc_name			= MPT3SAS_DRIVER_NAME,
 +	.queuecommand			= _scsih_qcmd,
 +	.target_alloc			= _scsih_target_alloc,
 +	.slave_alloc			= _scsih_slave_alloc,
 +	.slave_configure		= _scsih_slave_configure,
 +	.target_destroy			= _scsih_target_destroy,
 +	.slave_destroy			= _scsih_slave_destroy,
 +	.scan_finished			= _scsih_scan_finished,
 +	.scan_start			= _scsih_scan_start,
 +	.change_queue_depth		= _scsih_change_queue_depth,
 +	.change_queue_type		= _scsih_change_queue_type,
 +	.eh_abort_handler		= _scsih_abort,
 +	.eh_device_reset_handler	= _scsih_dev_reset,
 +	.eh_target_reset_handler	= _scsih_target_reset,
 +	.eh_host_reset_handler		= _scsih_host_reset,
 +	.bios_param			= _scsih_bios_param,
 +	.can_queue			= 1,
 +	.this_id			= -1,
 +	.sg_tablesize			= MPT3SAS_SG_DEPTH,
 +	.max_sectors			= 32767,
 +	.cmd_per_lun			= 7,
 +	.use_clustering			= ENABLE_CLUSTERING,
 +	.shost_attrs			= mpt3sas_host_attrs,
 +	.sdev_attrs			= mpt3sas_dev_attrs,
 +};
 +
++=======
++>>>>>>> 7497392a1193 (mpt3sas: Move Gen3 HBA's device registration to a separate file)
  /**
   * _scsih_expander_node_remove - removing expander device from list.
   * @ioc: per adapter object
@@@ -8055,18 -7931,12 +8027,17 @@@ _scsih_scan_finished(struct Scsi_Host *
   *
   * Returns 0 success, anything else error.
   */
++<<<<<<< HEAD
 +static int
 +_scsih_probe(struct pci_dev *pdev, const struct pci_device_id *id)
++=======
+ int
+ scsih_probe(struct pci_dev *pdev, struct Scsi_Host *shost)
++>>>>>>> 7497392a1193 (mpt3sas: Move Gen3 HBA's device registration to a separate file)
  {
  	struct MPT3SAS_ADAPTER *ioc;
- 	struct Scsi_Host *shost;
  	int rv;
  
- 	shost = scsi_host_alloc(&scsih_driver_template,
- 	    sizeof(struct MPT3SAS_ADAPTER));
- 	if (!shost)
- 		return -ENODEV;
- 
  	/* init local params */
  	ioc = shost_priv(shost);
  	memset(ioc, 0, sizeof(struct MPT3SAS_ADAPTER));
@@@ -8361,62 -8231,16 +8332,48 @@@ _scsih_pci_mmio_enabled(struct pci_dev 
  	return PCI_ERS_RESULT_NEED_RESET;
  }
  
++<<<<<<< HEAD
 +/* raid transport support */
 +static struct raid_function_template mpt3sas_raid_functions = {
 +	.cookie		= &scsih_driver_template,
 +	.is_raid	= _scsih_is_raid,
 +	.get_resync	= _scsih_get_resync,
 +	.get_state	= _scsih_get_state,
 +};
 +
 +static struct pci_error_handlers _scsih_err_handler = {
 +	.error_detected = _scsih_pci_error_detected,
 +	.mmio_enabled = _scsih_pci_mmio_enabled,
 +	.slot_reset =	_scsih_pci_slot_reset,
 +	.resume =	_scsih_pci_resume,
 +};
 +
 +static struct pci_driver scsih_driver = {
 +	.name		= MPT3SAS_DRIVER_NAME,
 +	.id_table	= scsih_pci_table,
 +	.probe		= _scsih_probe,
 +	.remove		= _scsih_remove,
 +	.shutdown	= _scsih_shutdown,
 +	.err_handler	= &_scsih_err_handler,
 +#ifdef CONFIG_PM
 +	.suspend	= _scsih_suspend,
 +	.resume		= _scsih_resume,
 +#endif
 +};
 +
 +
++=======
++>>>>>>> 7497392a1193 (mpt3sas: Move Gen3 HBA's device registration to a separate file)
  /**
 - * scsih_init - main entry point for this driver.
 + * _scsih_init - main entry point for this driver.
   *
   * Returns 0 success, anything else error.
   */
 -int
 -scsih_init(void)
 +static int __init
 +_scsih_init(void)
  {
- 	int error;
- 
  	mpt_ids = 0;
  
- 	pr_info("%s version %s loaded\n", MPT3SAS_DRIVER_NAME,
- 	    MPT3SAS_DRIVER_VERSION);
- 
- 	mpt3sas_transport_template =
- 	    sas_attach_transport(&mpt3sas_transport_functions);
- 	if (!mpt3sas_transport_template)
- 		return -ENODEV;
- 
- /* raid transport support */
- 	mpt3sas_raid_template = raid_class_attach(&mpt3sas_raid_functions);
- 	if (!mpt3sas_raid_template) {
- 		sas_release_transport(mpt3sas_transport_template);
- 		return -ENODEV;
- 	}
- 
  	mpt3sas_base_initialize_callback_handler();
  
  	 /* queuecommand callback hander */
@@@ -8453,16 -8277,7 +8410,20 @@@
  	tm_sas_control_cb_idx = mpt3sas_base_register_callback_handler(
  	    _scsih_sas_control_complete);
  
++<<<<<<< HEAD
 +	mpt3sas_ctl_init();
 +
 +	error = pci_register_driver(&scsih_driver);
 +	if (error) {
 +		/* raid transport support */
 +		raid_class_release(mpt3sas_raid_template);
 +		sas_release_transport(mpt3sas_transport_template);
 +	}
 +
 +	return error;
++=======
+ 	return 0;
++>>>>>>> 7497392a1193 (mpt3sas: Move Gen3 HBA's device registration to a separate file)
  }
  
  /**
@@@ -8470,16 -8285,9 +8431,19 @@@
   *
   * Returns 0 success, anything else error.
   */
 -void
 -scsih_exit(void)
 +static void __exit
 +_scsih_exit(void)
  {
++<<<<<<< HEAD
 +	pr_info("mpt3sas version %s unloading\n",
 +	    MPT3SAS_DRIVER_VERSION);
 +
 +	mpt3sas_ctl_exit();
 +
 +	pci_unregister_driver(&scsih_driver);
 +
++=======
++>>>>>>> 7497392a1193 (mpt3sas: Move Gen3 HBA's device registration to a separate file)
  
  	mpt3sas_base_release_callback_handler(scsi_io_cb_idx);
  	mpt3sas_base_release_callback_handler(tm_cb_idx);
@@@ -8498,6 -8306,3 +8462,9 @@@
  	raid_class_release(mpt3sas_raid_template);
  	sas_release_transport(mpt3sas_transport_template);
  }
++<<<<<<< HEAD
 +
 +module_init(_scsih_init);
 +module_exit(_scsih_exit);
++=======
++>>>>>>> 7497392a1193 (mpt3sas: Move Gen3 HBA's device registration to a separate file)
diff --git a/drivers/scsi/mpt3sas/Makefile b/drivers/scsi/mpt3sas/Makefile
index efb0c4c2e310..188057f69a92 100644
--- a/drivers/scsi/mpt3sas/Makefile
+++ b/drivers/scsi/mpt3sas/Makefile
@@ -5,4 +5,5 @@ mpt3sas-y +=  mpt3sas_base.o     \
 		mpt3sas_scsih.o      \
 		mpt3sas_transport.o     \
 		mpt3sas_ctl.o	\
-		mpt3sas_trigger_diag.o
+		mpt3sas_trigger_diag.o \
+		mpt3sas_module.o
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_base.h
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_ctl.c
diff --git a/drivers/scsi/mpt3sas/mpt3sas_module.c b/drivers/scsi/mpt3sas/mpt3sas_module.c
new file mode 100644
index 000000000000..e5f43ba04c4b
--- /dev/null
+++ b/drivers/scsi/mpt3sas/mpt3sas_module.c
@@ -0,0 +1,252 @@
+/*
+ * Scsi Host Layer for MPT (Message Passing Technology) based controllers
+ *
+ * Copyright (C) 2012-2014  LSI Corporation
+ * Copyright (C) 2013-2015 Avago Technologies
+ *  (mailto: MPT-FusionLinux.pdl@avagotech.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * NO WARRANTY
+ * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
+ * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
+ * solely responsible for determining the appropriateness of using and
+ * distributing the Program and assumes all risks associated with its
+ * exercise of rights under this Agreement, including but not limited to
+ * the risks and costs of program errors, damage to or loss of data,
+ * programs or equipment, and unavailability or interruption of operations.
+
+ * DISCLAIMER OF LIABILITY
+ * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
+ * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program.
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/raid_class.h>
+
+#include "mpt3sas_base.h"
+#include "mpt3sas_ctl.h"
+
+MODULE_AUTHOR(MPT3SAS_AUTHOR);
+MODULE_DESCRIPTION(MPT3SAS_DESCRIPTION);
+MODULE_LICENSE("GPL");
+MODULE_VERSION(MPT3SAS_DRIVER_VERSION);
+
+/* shost template */
+static struct scsi_host_template mpt3sas_driver_template = {
+	.module				= THIS_MODULE,
+	.name				= "Fusion MPT SAS Host",
+	.proc_name			= MPT3SAS_DRIVER_NAME,
+	.queuecommand			= scsih_qcmd,
+	.target_alloc			= scsih_target_alloc,
+	.slave_alloc			= scsih_slave_alloc,
+	.slave_configure		= scsih_slave_configure,
+	.target_destroy			= scsih_target_destroy,
+	.slave_destroy			= scsih_slave_destroy,
+	.scan_finished			= scsih_scan_finished,
+	.scan_start			= scsih_scan_start,
+	.change_queue_depth		= scsih_change_queue_depth,
+	.eh_abort_handler		= scsih_abort,
+	.eh_device_reset_handler	= scsih_dev_reset,
+	.eh_target_reset_handler	= scsih_target_reset,
+	.eh_host_reset_handler		= scsih_host_reset,
+	.bios_param			= scsih_bios_param,
+	.can_queue			= 1,
+	.this_id			= -1,
+	.sg_tablesize			= MPT3SAS_SG_DEPTH,
+	.max_sectors			= 32767,
+	.cmd_per_lun			= 7,
+	.use_clustering			= ENABLE_CLUSTERING,
+	.shost_attrs			= mpt3sas_host_attrs,
+	.sdev_attrs			= mpt3sas_dev_attrs,
+	.track_queue_depth		= 1,
+};
+
+/* raid transport support */
+static struct raid_function_template mpt3sas_raid_functions = {
+	.cookie		= &mpt3sas_driver_template,
+	.is_raid	= scsih_is_raid,
+	.get_resync	= scsih_get_resync,
+	.get_state	= scsih_get_state,
+};
+
+/*
+ * The pci device ids are defined in mpi/mpi2_cnfg.h.
+ */
+static const struct pci_device_id mpt3sas_pci_table[] = {
+	{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3004,
+		PCI_ANY_ID, PCI_ANY_ID },
+	{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3008,
+		PCI_ANY_ID, PCI_ANY_ID },
+	/* Invader ~ 3108 */
+	{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_1,
+		PCI_ANY_ID, PCI_ANY_ID },
+	{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_2,
+		PCI_ANY_ID, PCI_ANY_ID },
+	{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_5,
+		PCI_ANY_ID, PCI_ANY_ID },
+	{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_6,
+		PCI_ANY_ID, PCI_ANY_ID },
+	{0}     /* Terminating entry */
+};
+MODULE_DEVICE_TABLE(pci, mpt3sas_pci_table);
+
+static const struct file_operations mpt3sas_ctl_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = ctl_ioctl,
+	.poll = ctl_poll,
+	.fasync = ctl_fasync,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = ctl_ioctl_compat,
+#endif
+};
+
+static struct miscdevice mpt3sas_ctl_dev = {
+	.minor  = MPT3SAS_MINOR,
+	.name   = MPT3SAS_DEV_NAME,
+	.fops   = &mpt3sas_ctl_fops,
+};
+
+/**
+ * mpt3sas_ctl_init - main entry point for ctl.
+ *
+ */
+void
+mpt3sas_ctl_init(void)
+{
+	ctl_init();
+	if (misc_register(&mpt3sas_ctl_dev) < 0)
+		pr_err("%s can't register misc device [minor=%d]\n",
+		    MPT3SAS_DRIVER_NAME, MPT3SAS_MINOR);
+}
+
+/**
+ * mpt3sas_ctl_exit - exit point for ctl
+ *
+ */
+void
+mpt3sas_ctl_exit(void)
+{
+	ctl_exit();
+	misc_deregister(&mpt3sas_ctl_dev);
+}
+
+/**
+ * _mpt3sas_probe - attach and add scsi host
+ * @pdev: PCI device struct
+ * @id: pci device id
+ *
+ * Returns 0 success, anything else error.
+ */
+static int
+_mpt3sas_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	struct Scsi_Host *shost;
+	int rv;
+
+	shost = scsi_host_alloc(&mpt3sas_driver_template,
+				sizeof(struct MPT3SAS_ADAPTER));
+	if (!shost)
+		return -ENODEV;
+
+	rv = scsih_probe(pdev, shost);
+	return rv;
+}
+
+static struct pci_error_handlers _mpt3sas_err_handler = {
+	.error_detected	= scsih_pci_error_detected,
+	.mmio_enabled	= scsih_pci_mmio_enabled,
+	.slot_reset	= scsih_pci_slot_reset,
+	.resume		= scsih_pci_resume,
+};
+
+static struct pci_driver mpt3sas_driver = {
+	.name		= MPT3SAS_DRIVER_NAME,
+	.id_table	= mpt3sas_pci_table,
+	.probe		= _mpt3sas_probe,
+	.remove		= scsih_remove,
+	.shutdown	= scsih_shutdown,
+	.err_handler	= &_mpt3sas_err_handler,
+#ifdef CONFIG_PM
+	.suspend	= scsih_suspend,
+	.resume		= scsih_resume,
+#endif
+};
+
+/**
+ * _mpt3sas_init - main entry point for this driver.
+ *
+ * Returns 0 success, anything else error.
+ */
+static int __init
+_mpt3sas_init(void)
+{
+	int error;
+
+	pr_info("%s version %s loaded\n", MPT3SAS_DRIVER_NAME,
+					MPT3SAS_DRIVER_VERSION);
+
+	mpt3sas_transport_template =
+	    sas_attach_transport(&mpt3sas_transport_functions);
+	if (!mpt3sas_transport_template)
+		return -ENODEV;
+
+	mpt3sas_raid_template = raid_class_attach(&mpt3sas_raid_functions);
+	if (!mpt3sas_raid_template) {
+		sas_release_transport(mpt3sas_transport_template);
+		return -ENODEV;
+	}
+
+	error = scsih_init();
+	if (error) {
+		scsih_exit();
+		return error;
+	}
+
+	mpt3sas_ctl_init();
+
+	error = pci_register_driver(&mpt3sas_driver);
+	if (error)
+		scsih_exit();
+
+	return error;
+}
+
+/**
+ * _mpt3sas_exit - exit point for this driver (when it is a module).
+ *
+ */
+static void __exit
+_mpt3sas_exit(void)
+{
+	pr_info("mpt3sas version %s unloading\n",
+				MPT3SAS_DRIVER_VERSION);
+
+	pci_unregister_driver(&mpt3sas_driver);
+
+	mpt3sas_ctl_exit();
+
+	scsih_exit();
+}
+
+module_init(_mpt3sas_init);
+module_exit(_mpt3sas_exit);
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_scsih.c
