net/core: Add event for a change in slave state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] Add event for a change in slave state (Ivan Vecera) [1268334]
Rebuild_FUZZ: 88.10%
commit-author Moni Shoua <monis@mellanox.com>
commit 61bd3857ff2c7daf756d49b41e6277bbdaa8f789
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/61bd3857.failed

Add event which provides an indication on a change in the state
of a bonding slave. The event handler should cast the pointer to the
appropriate type (struct netdev_bonding_info) in order to get the
full info about the slave.

	Signed-off-by: Moni Shoua <monis@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 61bd3857ff2c7daf756d49b41e6277bbdaa8f789)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/dev.c
diff --cc net/core/dev.c
index e416d49ce837,ede0b161b115..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -4808,6 -5355,140 +4808,143 @@@ void netdev_upper_dev_unlink(struct net
  }
  EXPORT_SYMBOL(netdev_upper_dev_unlink);
  
++<<<<<<< HEAD
++=======
+ /**
+  * netdev_bonding_info_change - Dispatch event about slave change
+  * @dev: device
+  * @netdev_bonding_info: info to dispatch
+  *
+  * Send NETDEV_BONDING_INFO to netdev notifiers with info.
+  * The caller must hold the RTNL lock.
+  */
+ void netdev_bonding_info_change(struct net_device *dev,
+ 				struct netdev_bonding_info *bonding_info)
+ {
+ 	struct netdev_notifier_bonding_info	info;
+ 
+ 	memcpy(&info.bonding_info, bonding_info,
+ 	       sizeof(struct netdev_bonding_info));
+ 	call_netdevice_notifiers_info(NETDEV_BONDING_INFO, dev,
+ 				      &info.info);
+ }
+ EXPORT_SYMBOL(netdev_bonding_info_change);
+ 
+ void netdev_adjacent_add_links(struct net_device *dev)
+ {
+ 	struct netdev_adjacent *iter;
+ 
+ 	struct net *net = dev_net(dev);
+ 
+ 	list_for_each_entry(iter, &dev->adj_list.upper, list) {
+ 		if (!net_eq(net,dev_net(iter->dev)))
+ 			continue;
+ 		netdev_adjacent_sysfs_add(iter->dev, dev,
+ 					  &iter->dev->adj_list.lower);
+ 		netdev_adjacent_sysfs_add(dev, iter->dev,
+ 					  &dev->adj_list.upper);
+ 	}
+ 
+ 	list_for_each_entry(iter, &dev->adj_list.lower, list) {
+ 		if (!net_eq(net,dev_net(iter->dev)))
+ 			continue;
+ 		netdev_adjacent_sysfs_add(iter->dev, dev,
+ 					  &iter->dev->adj_list.upper);
+ 		netdev_adjacent_sysfs_add(dev, iter->dev,
+ 					  &dev->adj_list.lower);
+ 	}
+ }
+ 
+ void netdev_adjacent_del_links(struct net_device *dev)
+ {
+ 	struct netdev_adjacent *iter;
+ 
+ 	struct net *net = dev_net(dev);
+ 
+ 	list_for_each_entry(iter, &dev->adj_list.upper, list) {
+ 		if (!net_eq(net,dev_net(iter->dev)))
+ 			continue;
+ 		netdev_adjacent_sysfs_del(iter->dev, dev->name,
+ 					  &iter->dev->adj_list.lower);
+ 		netdev_adjacent_sysfs_del(dev, iter->dev->name,
+ 					  &dev->adj_list.upper);
+ 	}
+ 
+ 	list_for_each_entry(iter, &dev->adj_list.lower, list) {
+ 		if (!net_eq(net,dev_net(iter->dev)))
+ 			continue;
+ 		netdev_adjacent_sysfs_del(iter->dev, dev->name,
+ 					  &iter->dev->adj_list.upper);
+ 		netdev_adjacent_sysfs_del(dev, iter->dev->name,
+ 					  &dev->adj_list.lower);
+ 	}
+ }
+ 
+ void netdev_adjacent_rename_links(struct net_device *dev, char *oldname)
+ {
+ 	struct netdev_adjacent *iter;
+ 
+ 	struct net *net = dev_net(dev);
+ 
+ 	list_for_each_entry(iter, &dev->adj_list.upper, list) {
+ 		if (!net_eq(net,dev_net(iter->dev)))
+ 			continue;
+ 		netdev_adjacent_sysfs_del(iter->dev, oldname,
+ 					  &iter->dev->adj_list.lower);
+ 		netdev_adjacent_sysfs_add(iter->dev, dev,
+ 					  &iter->dev->adj_list.lower);
+ 	}
+ 
+ 	list_for_each_entry(iter, &dev->adj_list.lower, list) {
+ 		if (!net_eq(net,dev_net(iter->dev)))
+ 			continue;
+ 		netdev_adjacent_sysfs_del(iter->dev, oldname,
+ 					  &iter->dev->adj_list.upper);
+ 		netdev_adjacent_sysfs_add(iter->dev, dev,
+ 					  &iter->dev->adj_list.upper);
+ 	}
+ }
+ 
+ void *netdev_lower_dev_get_private(struct net_device *dev,
+ 				   struct net_device *lower_dev)
+ {
+ 	struct netdev_adjacent *lower;
+ 
+ 	if (!lower_dev)
+ 		return NULL;
+ 	lower = __netdev_find_adj(dev, lower_dev, &dev->adj_list.lower);
+ 	if (!lower)
+ 		return NULL;
+ 
+ 	return lower->private;
+ }
+ EXPORT_SYMBOL(netdev_lower_dev_get_private);
+ 
+ 
+ int dev_get_nest_level(struct net_device *dev,
+ 		       bool (*type_check)(struct net_device *dev))
+ {
+ 	struct net_device *lower = NULL;
+ 	struct list_head *iter;
+ 	int max_nest = -1;
+ 	int nest;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	netdev_for_each_lower_dev(dev, lower, iter) {
+ 		nest = dev_get_nest_level(lower, type_check);
+ 		if (max_nest < nest)
+ 			max_nest = nest;
+ 	}
+ 
+ 	if (type_check(dev))
+ 		max_nest++;
+ 
+ 	return max_nest;
+ }
+ EXPORT_SYMBOL(dev_get_nest_level);
+ 
++>>>>>>> 61bd3857ff2c (net/core: Add event for a change in slave state)
  static void dev_change_rx_flags(struct net_device *dev, int flags)
  {
  	const struct net_device_ops *ops = dev->netdev_ops;
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index f42ad8e42b23..180e13a5d08c 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -51,6 +51,7 @@
 #include <linux/netdev_features.h>
 #include <linux/neighbour.h>
 #include <uapi/linux/netdevice.h>
+#include <uapi/linux/if_bonding.h>
 
 #include <linux/rh_kabi.h>
 
@@ -1939,6 +1940,7 @@ struct pcpu_sw_netstats {
 #define NETDEV_JOIN		0x0014
 #define NETDEV_RESEND_IGMP	0x0016
 #define NETDEV_CHANGEINFODATA	0x0018
+#define NETDEV_BONDING_INFO	0x0019
 
 int register_netdevice_notifier(struct notifier_block *nb);
 int unregister_netdevice_notifier(struct notifier_block *nb);
@@ -3339,6 +3341,19 @@ struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
 struct sk_buff *skb_mac_gso_segment(struct sk_buff *skb,
 				    netdev_features_t features);
 
+struct netdev_bonding_info {
+	ifslave	slave;
+	ifbond	master;
+};
+
+struct netdev_notifier_bonding_info {
+	struct netdev_notifier_info info; /* must be first */
+	struct netdev_bonding_info  bonding_info;
+};
+
+void netdev_bonding_info_change(struct net_device *dev,
+				struct netdev_bonding_info *bonding_info);
+
 static inline
 struct sk_buff *skb_gso_segment(struct sk_buff *skb, netdev_features_t features)
 {
* Unmerged path net/core/dev.c
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index bca0c57300c0..4497603fb7a2 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -3124,6 +3124,7 @@ static int rtnetlink_event(struct notifier_block *this, unsigned long event, voi
 	case NETDEV_UNREGISTER_FINAL:
 	case NETDEV_RELEASE:
 	case NETDEV_JOIN:
+	case NETDEV_BONDING_INFO:
 		break;
 	default:
 		rtmsg_ifinfo(RTM_NEWLINK, dev, 0, GFP_KERNEL);
