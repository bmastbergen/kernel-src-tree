mei: kill cached host and me csr values

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 18caeb70f3aa694a3147709e6425f749bfd04ea7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/18caeb70.failed

Kill host_hw_status and me_hw_state from me hw structure that used
to cache host and me csr values.
We do not use the cached values across the function calls anymore

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 18caeb70f3aa694a3147709e6425f749bfd04ea7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/hw-me.c
#	drivers/misc/mei/hw-me.h
diff --cc drivers/misc/mei/hw-me.c
index 241eae550b0c,7ce7cf4b6092..000000000000
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@@ -234,10 -270,12 +234,17 @@@ static int mei_me_hw_reset(struct mei_d
  static void mei_me_host_set_ready(struct mei_device *dev)
  {
  	struct mei_me_hw *hw = to_me_hw(dev);
++<<<<<<< HEAD
 +	hw->host_hw_state = mei_hcsr_read(hw);
 +	hw->host_hw_state |= H_IE | H_IG | H_RDY;
 +	mei_hcsr_set(hw, hw->host_hw_state);
++=======
+ 	u32 hcsr = mei_hcsr_read(hw);
+ 
+ 	hcsr |= H_IE | H_IG | H_RDY;
+ 	mei_hcsr_set(hw, hcsr);
++>>>>>>> 18caeb70f3aa (mei: kill cached host and me csr values)
  }
 -
  /**
   * mei_me_host_is_ready - check whether the host has turned ready
   *
@@@ -247,8 -285,9 +254,14 @@@
  static bool mei_me_host_is_ready(struct mei_device *dev)
  {
  	struct mei_me_hw *hw = to_me_hw(dev);
++<<<<<<< HEAD
 +	hw->host_hw_state = mei_hcsr_read(hw);
 +	return (hw->host_hw_state & H_RDY) == H_RDY;
++=======
+ 	u32 hcsr = mei_hcsr_read(hw);
+ 
+ 	return (hcsr & H_RDY) == H_RDY;
++>>>>>>> 18caeb70f3aa (mei: kill cached host and me csr values)
  }
  
  /**
@@@ -260,10 -299,18 +273,16 @@@
  static bool mei_me_hw_is_ready(struct mei_device *dev)
  {
  	struct mei_me_hw *hw = to_me_hw(dev);
++<<<<<<< HEAD
 +	hw->me_hw_state = mei_me_mecsr_read(hw);
 +	return (hw->me_hw_state & ME_RDY_HRA) == ME_RDY_HRA;
++=======
+ 	u32 mecsr = mei_me_mecsr_read(hw);
+ 
+ 	return (mecsr & ME_RDY_HRA) == ME_RDY_HRA;
++>>>>>>> 18caeb70f3aa (mei: kill cached host and me csr values)
  }
  
 -/**
 - * mei_me_hw_ready_wait - wait until the me(hw) has turned ready
 - *  or timeout is reached
 - *
 - * @dev: mei device
 - * Return: 0 on success, error otherwise
 - */
  static int mei_me_hw_ready_wait(struct mei_device *dev)
  {
  	mutex_unlock(&dev->device_lock);
diff --cc drivers/misc/mei/hw-me.h
index 98ceac2cee68,e44ed1d03911..000000000000
--- a/drivers/misc/mei/hw-me.h
+++ b/drivers/misc/mei/hw-me.h
@@@ -24,13 -26,36 +24,38 @@@
  #include "mei_dev.h"
  #include "client.h"
  
++<<<<<<< HEAD
++=======
+ /*
+  * mei_cfg - mei device configuration
+  *
+  * @fw_status: FW status
+  * @quirk_probe: device exclusion quirk
+  */
+ struct mei_cfg {
+ 	const struct mei_fw_status fw_status;
+ 	bool (*quirk_probe)(struct pci_dev *pdev);
+ };
+ 
+ 
+ #define MEI_PCI_DEVICE(dev, cfg) \
+ 	.vendor = PCI_VENDOR_ID_INTEL, .device = (dev), \
+ 	.subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID, \
+ 	.driver_data = (kernel_ulong_t)&(cfg)
+ 
+ 
+ #define MEI_ME_RPM_TIMEOUT    500 /* ms */
+ 
+ /**
+  * struct mei_me_hw - me hw specific data
+  *
+  * @cfg: per device generation config and ops
+  * @mem_addr:  io memory address
+  * @pg_state:      power gating state
+  */
++>>>>>>> 18caeb70f3aa (mei: kill cached host and me csr values)
  struct mei_me_hw {
 -	const struct mei_cfg *cfg;
  	void __iomem *mem_addr;
- 	/*
- 	 * hw states of host and fw(ME)
- 	 */
- 	u32 host_hw_state;
- 	u32 me_hw_state;
  	enum mei_pg_state pg_state;
  };
  
* Unmerged path drivers/misc/mei/hw-me.c
* Unmerged path drivers/misc/mei/hw-me.h
