mmc: core: Remove redundant check of max_dtr while selecting timings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] core: Remove redundant check of max_dtr while selecting timings (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 96.18%
commit-author Ulf Hansson <ulf.hansson@linaro.org>
commit 9e304d67ad4768585e4c7002341aac81272799ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9e304d67.failed

If the MMC spec version is < CSD_SPEC_VER_4, there aren't support for
the EXT_CSD register. Since max_dtr is fetched from there, it will
default to zero, which thus isn't needed to verify.

	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 9e304d67ad4768585e4c7002341aac81272799ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/mmc.c
diff --cc drivers/mmc/core/mmc.c
index 482826a651ad,cc9f4599f3e1..000000000000
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@@ -896,6 -1151,105 +896,108 @@@ err
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Activate High Speed or HS200 mode if supported.
+  */
+ static int mmc_select_timing(struct mmc_card *card)
+ {
+ 	int err = 0;
+ 
+ 	if (card->csd.mmca_vsn < CSD_SPEC_VER_4)
+ 		goto bus_speed;
+ 
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200)
+ 		err = mmc_select_hs200(card);
+ 	else if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS)
+ 		err = mmc_select_hs(card);
+ 
+ 	if (err && err != -EBADMSG)
+ 		return err;
+ 
+ 	if (err) {
+ 		pr_warn("%s: switch to %s failed\n",
+ 			mmc_card_hs(card) ? "high-speed" :
+ 			(mmc_card_hs200(card) ? "hs200" : ""),
+ 			mmc_hostname(card->host));
+ 		err = 0;
+ 	}
+ 
+ bus_speed:
+ 	/*
+ 	 * Set the bus speed to the selected bus timing.
+ 	 * If timing is not selected, backward compatible is the default.
+ 	 */
+ 	mmc_set_bus_speed(card);
+ 	return err;
+ }
+ 
+ const u8 tuning_blk_pattern_4bit[MMC_TUNING_BLK_PATTERN_4BIT_SIZE] = {
+ 	0xff, 0x0f, 0xff, 0x00, 0xff, 0xcc, 0xc3, 0xcc,
+ 	0xc3, 0x3c, 0xcc, 0xff, 0xfe, 0xff, 0xfe, 0xef,
+ 	0xff, 0xdf, 0xff, 0xdd, 0xff, 0xfb, 0xff, 0xfb,
+ 	0xbf, 0xff, 0x7f, 0xff, 0x77, 0xf7, 0xbd, 0xef,
+ 	0xff, 0xf0, 0xff, 0xf0, 0x0f, 0xfc, 0xcc, 0x3c,
+ 	0xcc, 0x33, 0xcc, 0xcf, 0xff, 0xef, 0xff, 0xee,
+ 	0xff, 0xfd, 0xff, 0xfd, 0xdf, 0xff, 0xbf, 0xff,
+ 	0xbb, 0xff, 0xf7, 0xff, 0xf7, 0x7f, 0x7b, 0xde,
+ };
+ EXPORT_SYMBOL(tuning_blk_pattern_4bit);
+ 
+ const u8 tuning_blk_pattern_8bit[MMC_TUNING_BLK_PATTERN_8BIT_SIZE] = {
+ 	0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
+ 	0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,
+ 	0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
+ 	0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
+ 	0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
+ 	0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
+ 	0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
+ 	0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
+ 	0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
+ 	0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,
+ 	0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,
+ 	0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
+ 	0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
+ 	0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
+ 	0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
+ 	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
+ };
+ EXPORT_SYMBOL(tuning_blk_pattern_8bit);
+ 
+ /*
+  * Execute tuning sequence to seek the proper bus operating
+  * conditions for HS200 and HS400, which sends CMD21 to the device.
+  */
+ static int mmc_hs200_tuning(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	int err = 0;
+ 
+ 	/*
+ 	 * Timing should be adjusted to the HS400 target
+ 	 * operation frequency for tuning process
+ 	 */
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400 &&
+ 	    host->ios.bus_width == MMC_BUS_WIDTH_8)
+ 		if (host->ops->prepare_hs400_tuning)
+ 			host->ops->prepare_hs400_tuning(host, &host->ios);
+ 
+ 	if (host->ops->execute_tuning) {
+ 		mmc_host_clk_hold(host);
+ 		err = host->ops->execute_tuning(host,
+ 				MMC_SEND_TUNING_BLOCK_HS200);
+ 		mmc_host_clk_release(host);
+ 
+ 		if (err)
+ 			pr_err("%s: tuning execution failed\n",
+ 				mmc_hostname(host));
+ 	}
+ 
+ 	return err;
+ }
+ 
+ /*
++>>>>>>> 9e304d67ad47 (mmc: core: Remove redundant check of max_dtr while selecting timings)
   * Handle the detection and initialisation of a card.
   *
   * In the case of a resume, "oldcard" will contain the card
* Unmerged path drivers/mmc/core/mmc.c
