mm/memblock: use WARN_ONCE when MAX_NUMNODES passed as input parameter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mm] memblock: use WARN_ONCE when MAX_NUMNODES passed as input parameter (Yasuaki Ishimatsu) [1270209]
Rebuild_FUZZ: 97.81%
commit-author Grygorii Strashko <grygorii.strashko@ti.com>
commit 560dca27a6b36015e4f69a4ceba0ee5be0707c17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/560dca27.failed

Check nid parameter and produce warning if it has deprecated
MAX_NUMNODES value.  Also re-assign NUMA_NO_NODE value to the nid
parameter in this case.

These will help to identify the wrong API usage (the caller) and make
code simpler.

	Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
	Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
	Cc: Yinghai Lu <yinghai@kernel.org>
	Cc: Tejun Heo <tj@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 560dca27a6b36015e4f69a4ceba0ee5be0707c17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memblock.c
diff --cc mm/memblock.c
index 9ed67f4de3ab,1c2ef2c7edab..000000000000
--- a/mm/memblock.c
+++ b/mm/memblock.c
@@@ -769,11 -785,9 +769,15 @@@ void __init_memblock __next_free_mem_ra
  	struct memblock_type *rsv = &memblock.reserved;
  	int mi = *idx & 0xffffffff;
  	int ri = *idx >> 32;
- 	bool check_node = (nid != NUMA_NO_NODE) && (nid != MAX_NUMNODES);
  
++<<<<<<< HEAD
 +	if (nid == MAX_NUMNODES)
 +		pr_warn_once("%s: Usage of MAX_NUMNODES is depricated. Use NUMA_NO_NODE instead\n",
 +			     __func__);
++=======
+ 	if (WARN_ONCE(nid == MAX_NUMNODES, "Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\n"))
+ 		nid = NUMA_NO_NODE;
++>>>>>>> 560dca27a6b3 (mm/memblock: use WARN_ONCE when MAX_NUMNODES passed as input parameter)
  
  	for ( ; mi < mem->cnt; mi++) {
  		struct memblock_region *m = &mem->regions[mi];
@@@ -842,11 -856,9 +846,15 @@@ void __init_memblock __next_free_mem_ra
  	struct memblock_type *rsv = &memblock.reserved;
  	int mi = *idx & 0xffffffff;
  	int ri = *idx >> 32;
- 	bool check_node = (nid != NUMA_NO_NODE) && (nid != MAX_NUMNODES);
  
++<<<<<<< HEAD
 +	if (nid == MAX_NUMNODES)
 +		pr_warn_once("%s: Usage of MAX_NUMNODES is depricated. Use NUMA_NO_NODE instead\n",
 +			     __func__);
++=======
+ 	if (WARN_ONCE(nid == MAX_NUMNODES, "Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\n"))
+ 		nid = NUMA_NO_NODE;
++>>>>>>> 560dca27a6b3 (mm/memblock: use WARN_ONCE when MAX_NUMNODES passed as input parameter)
  
  	if (*idx == (u64)ULLONG_MAX) {
  		mi = mem->cnt - 1;
@@@ -1016,6 -1028,207 +1024,210 @@@ phys_addr_t __init memblock_alloc_try_n
  	return memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * memblock_virt_alloc_internal - allocate boot memory block
+  * @size: size of memory block to be allocated in bytes
+  * @align: alignment of the region and block's size
+  * @min_addr: the lower bound of the memory region to allocate (phys address)
+  * @max_addr: the upper bound of the memory region to allocate (phys address)
+  * @nid: nid of the free area to find, %NUMA_NO_NODE for any node
+  *
+  * The @min_addr limit is dropped if it can not be satisfied and the allocation
+  * will fall back to memory below @min_addr. Also, allocation may fall back
+  * to any node in the system if the specified node can not
+  * hold the requested memory.
+  *
+  * The allocation is performed from memory region limited by
+  * memblock.current_limit if @max_addr == %BOOTMEM_ALLOC_ACCESSIBLE.
+  *
+  * The memory block is aligned on SMP_CACHE_BYTES if @align == 0.
+  *
+  * The phys address of allocated boot memory block is converted to virtual and
+  * allocated memory is reset to 0.
+  *
+  * In addition, function sets the min_count to 0 using kmemleak_alloc for
+  * allocated boot memory block, so that it is never reported as leaks.
+  *
+  * RETURNS:
+  * Virtual address of allocated memory block on success, NULL on failure.
+  */
+ static void * __init memblock_virt_alloc_internal(
+ 				phys_addr_t size, phys_addr_t align,
+ 				phys_addr_t min_addr, phys_addr_t max_addr,
+ 				int nid)
+ {
+ 	phys_addr_t alloc;
+ 	void *ptr;
+ 
+ 	if (WARN_ONCE(nid == MAX_NUMNODES, "Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\n"))
+ 		nid = NUMA_NO_NODE;
+ 
+ 	/*
+ 	 * Detect any accidental use of these APIs after slab is ready, as at
+ 	 * this moment memblock may be deinitialized already and its
+ 	 * internal data may be destroyed (after execution of free_all_bootmem)
+ 	 */
+ 	if (WARN_ON_ONCE(slab_is_available()))
+ 		return kzalloc_node(size, GFP_NOWAIT, nid);
+ 
+ 	if (!align)
+ 		align = SMP_CACHE_BYTES;
+ 
+ 	/* align @size to avoid excessive fragmentation on reserved array */
+ 	size = round_up(size, align);
+ 
+ again:
+ 	alloc = memblock_find_in_range_node(size, align, min_addr, max_addr,
+ 					    nid);
+ 	if (alloc)
+ 		goto done;
+ 
+ 	if (nid != NUMA_NO_NODE) {
+ 		alloc = memblock_find_in_range_node(size, align, min_addr,
+ 						    max_addr,  NUMA_NO_NODE);
+ 		if (alloc)
+ 			goto done;
+ 	}
+ 
+ 	if (min_addr) {
+ 		min_addr = 0;
+ 		goto again;
+ 	} else {
+ 		goto error;
+ 	}
+ 
+ done:
+ 	memblock_reserve(alloc, size);
+ 	ptr = phys_to_virt(alloc);
+ 	memset(ptr, 0, size);
+ 
+ 	/*
+ 	 * The min_count is set to 0 so that bootmem allocated blocks
+ 	 * are never reported as leaks. This is because many of these blocks
+ 	 * are only referred via the physical address which is not
+ 	 * looked up by kmemleak.
+ 	 */
+ 	kmemleak_alloc(ptr, size, 0, 0);
+ 
+ 	return ptr;
+ 
+ error:
+ 	return NULL;
+ }
+ 
+ /**
+  * memblock_virt_alloc_try_nid_nopanic - allocate boot memory block
+  * @size: size of memory block to be allocated in bytes
+  * @align: alignment of the region and block's size
+  * @min_addr: the lower bound of the memory region from where the allocation
+  *	  is preferred (phys address)
+  * @max_addr: the upper bound of the memory region from where the allocation
+  *	      is preferred (phys address), or %BOOTMEM_ALLOC_ACCESSIBLE to
+  *	      allocate only from memory limited by memblock.current_limit value
+  * @nid: nid of the free area to find, %NUMA_NO_NODE for any node
+  *
+  * Public version of _memblock_virt_alloc_try_nid_nopanic() which provides
+  * additional debug information (including caller info), if enabled.
+  *
+  * RETURNS:
+  * Virtual address of allocated memory block on success, NULL on failure.
+  */
+ void * __init memblock_virt_alloc_try_nid_nopanic(
+ 				phys_addr_t size, phys_addr_t align,
+ 				phys_addr_t min_addr, phys_addr_t max_addr,
+ 				int nid)
+ {
+ 	memblock_dbg("%s: %llu bytes align=0x%llx nid=%d from=0x%llx max_addr=0x%llx %pF\n",
+ 		     __func__, (u64)size, (u64)align, nid, (u64)min_addr,
+ 		     (u64)max_addr, (void *)_RET_IP_);
+ 	return memblock_virt_alloc_internal(size, align, min_addr,
+ 					     max_addr, nid);
+ }
+ 
+ /**
+  * memblock_virt_alloc_try_nid - allocate boot memory block with panicking
+  * @size: size of memory block to be allocated in bytes
+  * @align: alignment of the region and block's size
+  * @min_addr: the lower bound of the memory region from where the allocation
+  *	  is preferred (phys address)
+  * @max_addr: the upper bound of the memory region from where the allocation
+  *	      is preferred (phys address), or %BOOTMEM_ALLOC_ACCESSIBLE to
+  *	      allocate only from memory limited by memblock.current_limit value
+  * @nid: nid of the free area to find, %NUMA_NO_NODE for any node
+  *
+  * Public panicking version of _memblock_virt_alloc_try_nid_nopanic()
+  * which provides debug information (including caller info), if enabled,
+  * and panics if the request can not be satisfied.
+  *
+  * RETURNS:
+  * Virtual address of allocated memory block on success, NULL on failure.
+  */
+ void * __init memblock_virt_alloc_try_nid(
+ 			phys_addr_t size, phys_addr_t align,
+ 			phys_addr_t min_addr, phys_addr_t max_addr,
+ 			int nid)
+ {
+ 	void *ptr;
+ 
+ 	memblock_dbg("%s: %llu bytes align=0x%llx nid=%d from=0x%llx max_addr=0x%llx %pF\n",
+ 		     __func__, (u64)size, (u64)align, nid, (u64)min_addr,
+ 		     (u64)max_addr, (void *)_RET_IP_);
+ 	ptr = memblock_virt_alloc_internal(size, align,
+ 					   min_addr, max_addr, nid);
+ 	if (ptr)
+ 		return ptr;
+ 
+ 	panic("%s: Failed to allocate %llu bytes align=0x%llx nid=%d from=0x%llx max_addr=0x%llx\n",
+ 	      __func__, (u64)size, (u64)align, nid, (u64)min_addr,
+ 	      (u64)max_addr);
+ 	return NULL;
+ }
+ 
+ /**
+  * __memblock_free_early - free boot memory block
+  * @base: phys starting address of the  boot memory block
+  * @size: size of the boot memory block in bytes
+  *
+  * Free boot memory block previously allocated by memblock_virt_alloc_xx() API.
+  * The freeing memory will not be released to the buddy allocator.
+  */
+ void __init __memblock_free_early(phys_addr_t base, phys_addr_t size)
+ {
+ 	memblock_dbg("%s: [%#016llx-%#016llx] %pF\n",
+ 		     __func__, (u64)base, (u64)base + size - 1,
+ 		     (void *)_RET_IP_);
+ 	kmemleak_free_part(__va(base), size);
+ 	__memblock_remove(&memblock.reserved, base, size);
+ }
+ 
+ /*
+  * __memblock_free_late - free bootmem block pages directly to buddy allocator
+  * @addr: phys starting address of the  boot memory block
+  * @size: size of the boot memory block in bytes
+  *
+  * This is only useful when the bootmem allocator has already been torn
+  * down, but we are still initializing the system.  Pages are released directly
+  * to the buddy allocator, no bootmem metadata is updated because it is gone.
+  */
+ void __init __memblock_free_late(phys_addr_t base, phys_addr_t size)
+ {
+ 	u64 cursor, end;
+ 
+ 	memblock_dbg("%s: [%#016llx-%#016llx] %pF\n",
+ 		     __func__, (u64)base, (u64)base + size - 1,
+ 		     (void *)_RET_IP_);
+ 	kmemleak_free_part(__va(base), size);
+ 	cursor = PFN_UP(base);
+ 	end = PFN_DOWN(base + size);
+ 
+ 	for (; cursor < end; cursor++) {
+ 		__free_pages_bootmem(pfn_to_page(cursor), 0);
+ 		totalram_pages++;
+ 	}
+ }
++>>>>>>> 560dca27a6b3 (mm/memblock: use WARN_ONCE when MAX_NUMNODES passed as input parameter)
  
  /*
   * Remaining API functions
* Unmerged path mm/memblock.c
