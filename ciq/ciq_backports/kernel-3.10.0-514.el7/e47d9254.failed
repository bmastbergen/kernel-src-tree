usb: move the OTG state from the USB PHY to the OTG structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Antoine Tenart <antoine.tenart@free-electrons.com>
commit e47d92545c2972bcf3711e7db80f481e402163c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e47d9254.failed

Before using the PHY framework instead of the USB PHY one, we need to
move the OTG state into another place, since it won't be available when
USB PHY isn't used. This patch moves the OTG state into the OTG
structure, and makes all the needed modifications in the drivers
using the OTG state.

[ balbi@ti.com : fix build regressions with phy-tahvo.c, musb_dsps.c,
		phy-isp1301-omap, and chipidea's debug.c ]

	Acked-by: Kishon Vijay Abraham I <kishon@ti.com>
	Acked-by: Peter Chen <peter.chen@freescale.com>
	Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
	Signed-off-by: Felipe Balbi <balbi@ti.com>
(cherry picked from commit e47d92545c2972bcf3711e7db80f481e402163c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/chipidea/debug.c
#	drivers/usb/chipidea/otg_fsm.c
#	drivers/usb/host/ohci-omap.c
#	drivers/usb/musb/musb_core.c
#	drivers/usb/musb/musb_dsps.c
#	drivers/usb/musb/musb_gadget.c
#	drivers/usb/musb/musb_host.c
#	drivers/usb/musb/musb_virthub.c
#	drivers/usb/phy/phy-ab8500-usb.c
#	drivers/usb/phy/phy-isp1301-omap.c
#	drivers/usb/phy/phy-msm-usb.c
#	drivers/usb/phy/phy-nop.c
#	drivers/usb/phy/phy-tahvo.c
diff --cc drivers/usb/chipidea/debug.c
index 36a7063a6cba,f038804d13dd..000000000000
--- a/drivers/usb/chipidea/debug.c
+++ b/drivers/usb/chipidea/debug.c
@@@ -199,9 -208,83 +199,86 @@@ static const struct file_operations ci_
  	.release	= single_release,
  };
  
++<<<<<<< HEAD
++=======
+ static int ci_otg_show(struct seq_file *s, void *unused)
+ {
+ 	struct ci_hdrc *ci = s->private;
+ 	struct otg_fsm *fsm;
+ 
+ 	if (!ci || !ci_otg_is_fsm_mode(ci))
+ 		return 0;
+ 
+ 	fsm = &ci->fsm;
+ 
+ 	/* ------ State ----- */
+ 	seq_printf(s, "OTG state: %s\n\n",
+ 		usb_otg_state_string(ci->transceiver->otg->state));
+ 
+ 	/* ------ State Machine Variables ----- */
+ 	seq_printf(s, "a_bus_drop: %d\n", fsm->a_bus_drop);
+ 
+ 	seq_printf(s, "a_bus_req: %d\n", fsm->a_bus_req);
+ 
+ 	seq_printf(s, "a_srp_det: %d\n", fsm->a_srp_det);
+ 
+ 	seq_printf(s, "a_vbus_vld: %d\n", fsm->a_vbus_vld);
+ 
+ 	seq_printf(s, "b_conn: %d\n", fsm->b_conn);
+ 
+ 	seq_printf(s, "adp_change: %d\n", fsm->adp_change);
+ 
+ 	seq_printf(s, "power_up: %d\n", fsm->power_up);
+ 
+ 	seq_printf(s, "a_bus_resume: %d\n", fsm->a_bus_resume);
+ 
+ 	seq_printf(s, "a_bus_suspend: %d\n", fsm->a_bus_suspend);
+ 
+ 	seq_printf(s, "a_conn: %d\n", fsm->a_conn);
+ 
+ 	seq_printf(s, "b_bus_req: %d\n", fsm->b_bus_req);
+ 
+ 	seq_printf(s, "b_bus_suspend: %d\n", fsm->b_bus_suspend);
+ 
+ 	seq_printf(s, "b_se0_srp: %d\n", fsm->b_se0_srp);
+ 
+ 	seq_printf(s, "b_ssend_srp: %d\n", fsm->b_ssend_srp);
+ 
+ 	seq_printf(s, "b_sess_vld: %d\n", fsm->b_sess_vld);
+ 
+ 	seq_printf(s, "b_srp_done: %d\n", fsm->b_srp_done);
+ 
+ 	seq_printf(s, "drv_vbus: %d\n", fsm->drv_vbus);
+ 
+ 	seq_printf(s, "loc_conn: %d\n", fsm->loc_conn);
+ 
+ 	seq_printf(s, "loc_sof: %d\n", fsm->loc_sof);
+ 
+ 	seq_printf(s, "adp_prb: %d\n", fsm->adp_prb);
+ 
+ 	seq_printf(s, "id: %d\n", fsm->id);
+ 
+ 	seq_printf(s, "protocol: %d\n", fsm->protocol);
+ 
+ 	return 0;
+ }
+ 
+ static int ci_otg_open(struct inode *inode, struct file *file)
+ {
+ 	return single_open(file, ci_otg_show, inode->i_private);
+ }
+ 
+ static const struct file_operations ci_otg_fops = {
+ 	.open			= ci_otg_open,
+ 	.read			= seq_read,
+ 	.llseek			= seq_lseek,
+ 	.release		= single_release,
+ };
+ 
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  static int ci_role_show(struct seq_file *s, void *data)
  {
 -	struct ci_hdrc *ci = s->private;
 +	struct ci13xxx *ci = s->private;
  
  	seq_printf(s, "%s\n", ci_role(ci)->name);
  
diff --cc drivers/usb/host/ohci-omap.c
index b1d32fb4a7ae,cf89b4b17f14..000000000000
--- a/drivers/usb/host/ohci-omap.c
+++ b/drivers/usb/host/ohci-omap.c
@@@ -173,10 -180,10 +173,14 @@@ static void start_hnp(struct ohci_hcd *
  	unsigned long	flags;
  	u32 l;
  
 -	otg_start_hnp(hcd->usb_phy->otg);
 +	otg_start_hnp(hcd->phy->otg);
  
  	local_irq_save(flags);
++<<<<<<< HEAD
 +	hcd->phy->state = OTG_STATE_A_SUSPEND;
++=======
+ 	hcd->usb_phy->otg.state = OTG_STATE_A_SUSPEND;
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  	writel (RH_PS_PSS, &ohci->regs->roothub.portstatus [port]);
  	l = omap_readl(OTG_CTRL);
  	l &= ~OTG_A_BUSREQ;
diff --cc drivers/usb/musb/musb_core.c
index 5e488ace94f1,df9c5fa2772e..000000000000
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@@ -376,9 -376,8 +376,9 @@@ static void musb_otg_timer_func(unsigne
  		break;
  	default:
  		dev_dbg(musb->controller, "HNP: Unhandled mode %s\n",
- 			usb_otg_state_string(musb->xceiv->state));
+ 			usb_otg_state_string(musb->xceiv->otg->state));
  	}
 +	musb->ignore_disconnect = 0;
  	spin_unlock_irqrestore(&musb->lock, flags);
  }
  
@@@ -402,8 -401,9 +402,14 @@@ void musb_hnp_stop(struct musb *musb
  		break;
  	case OTG_STATE_B_HOST:
  		dev_dbg(musb->controller, "HNP: Disabling HR\n");
++<<<<<<< HEAD
 +		hcd->self.is_b_host = 0;
 +		musb->xceiv->state = OTG_STATE_B_PERIPHERAL;
++=======
+ 		if (hcd)
+ 			hcd->self.is_b_host = 0;
+ 		musb->xceiv->otg->state = OTG_STATE_B_PERIPHERAL;
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  		MUSB_DEV_MODE(musb);
  		reg = musb_readb(mbase, MUSB_POWER);
  		reg |= MUSB_POWER_SUSPENDM;
@@@ -478,28 -477,31 +484,33 @@@ static irqreturn_t musb_stage0_irq(stru
  						(USB_PORT_STAT_C_SUSPEND << 16)
  						| MUSB_PORT_STAT_RESUME;
  				musb->rh_timer = jiffies
 -						 + msecs_to_jiffies(20);
 -				schedule_delayed_work(
 -					&musb->finish_resume_work,
 -					msecs_to_jiffies(20));
 +						+ msecs_to_jiffies(20);
  
- 				musb->xceiv->state = OTG_STATE_A_HOST;
+ 				musb->xceiv->otg->state = OTG_STATE_A_HOST;
  				musb->is_active = 1;
 -				musb_host_resume_root_hub(musb);
 +				usb_hcd_resume_root_hub(musb_to_hcd(musb));
  				break;
  			case OTG_STATE_B_WAIT_ACON:
- 				musb->xceiv->state = OTG_STATE_B_PERIPHERAL;
+ 				musb->xceiv->otg->state = OTG_STATE_B_PERIPHERAL;
  				musb->is_active = 1;
  				MUSB_DEV_MODE(musb);
  				break;
  			default:
  				WARNING("bogus %s RESUME (%s)\n",
  					"host",
- 					usb_otg_state_string(musb->xceiv->state));
+ 					usb_otg_state_string(musb->xceiv->otg->state));
  			}
  		} else {
- 			switch (musb->xceiv->state) {
+ 			switch (musb->xceiv->otg->state) {
  			case OTG_STATE_A_SUSPEND:
  				/* possibly DISCONNECT is upcoming */
++<<<<<<< HEAD
 +				musb->xceiv->state = OTG_STATE_A_HOST;
 +				usb_hcd_resume_root_hub(musb_to_hcd(musb));
++=======
+ 				musb->xceiv->otg->state = OTG_STATE_A_HOST;
+ 				musb_host_resume_root_hub(musb);
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  				break;
  			case OTG_STATE_B_WAIT_ACON:
  			case OTG_STATE_B_PERIPHERAL:
@@@ -653,9 -655,9 +664,9 @@@
  				break;
  		case OTG_STATE_B_PERIPHERAL:
  			musb_g_suspend(musb);
 -			musb->is_active = musb->g.b_hnp_enable;
 +			musb->is_active = otg->gadget->b_hnp_enable;
  			if (musb->is_active) {
- 				musb->xceiv->state = OTG_STATE_B_WAIT_ACON;
+ 				musb->xceiv->otg->state = OTG_STATE_B_WAIT_ACON;
  				dev_dbg(musb->controller, "HNP: Setting timer for b_ase0_brst\n");
  				mod_timer(&musb->otg_timer, jiffies
  					+ msecs_to_jiffies(
@@@ -668,8 -670,8 +679,13 @@@
  					+ msecs_to_jiffies(musb->a_wait_bcon));
  			break;
  		case OTG_STATE_A_HOST:
++<<<<<<< HEAD
 +			musb->xceiv->state = OTG_STATE_A_SUSPEND;
 +			musb->is_active = otg->host->b_hnp_enable;
++=======
+ 			musb->xceiv->otg->state = OTG_STATE_A_SUSPEND;
+ 			musb->is_active = musb->hcd->self.b_hnp_enable;
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  			break;
  		case OTG_STATE_B_HOST:
  			/* Transition to B_PERIPHERAL, see 6.8.2.6 p 44 */
@@@ -723,41 -725,37 +739,53 @@@
  		case OTG_STATE_B_WAIT_ACON:
  			dev_dbg(musb->controller, "HNP: CONNECT, now b_host\n");
  b_host:
++<<<<<<< HEAD
 +			musb->xceiv->state = OTG_STATE_B_HOST;
 +			hcd->self.is_b_host = 1;
 +			musb->ignore_disconnect = 0;
++=======
+ 			musb->xceiv->otg->state = OTG_STATE_B_HOST;
+ 			if (musb->hcd)
+ 				musb->hcd->self.is_b_host = 1;
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  			del_timer(&musb->otg_timer);
  			break;
  		default:
  			if ((devctl & MUSB_DEVCTL_VBUS)
  					== (3 << MUSB_DEVCTL_VBUS_SHIFT)) {
++<<<<<<< HEAD
 +				musb->xceiv->state = OTG_STATE_A_HOST;
 +				hcd->self.is_b_host = 0;
++=======
+ 				musb->xceiv->otg->state = OTG_STATE_A_HOST;
+ 				if (hcd)
+ 					hcd->self.is_b_host = 0;
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  			}
  			break;
  		}
  
 -		musb_host_poke_root_hub(musb);
 +		/* poke the root hub */
 +		MUSB_HST_MODE(musb);
 +		if (hcd->status_urb)
 +			usb_hcd_poll_rh_status(hcd);
 +		else
 +			usb_hcd_resume_root_hub(hcd);
  
  		dev_dbg(musb->controller, "CONNECT (%s) devctl %02x\n",
- 				usb_otg_state_string(musb->xceiv->state), devctl);
+ 				usb_otg_state_string(musb->xceiv->otg->state), devctl);
  	}
  
 -	if (int_usb & MUSB_INTR_DISCONNECT) {
 +	if ((int_usb & MUSB_INTR_DISCONNECT) && !musb->ignore_disconnect) {
  		dev_dbg(musb->controller, "DISCONNECT (%s) as %s, devctl %02x\n",
- 				usb_otg_state_string(musb->xceiv->state),
+ 				usb_otg_state_string(musb->xceiv->otg->state),
  				MUSB_MODE(musb), devctl);
  		handled = IRQ_HANDLED;
  
- 		switch (musb->xceiv->state) {
+ 		switch (musb->xceiv->otg->state) {
  		case OTG_STATE_A_HOST:
  		case OTG_STATE_A_SUSPEND:
 -			musb_host_resume_root_hub(musb);
 +			usb_hcd_resume_root_hub(musb_to_hcd(musb));
  			musb_root_disconnect(musb);
  			if (musb->a_wait_bcon != 0)
  				musb_platform_try_idle(musb, jiffies
@@@ -770,8 -768,9 +798,14 @@@
  			 * in hnp_stop() is currently not used...
  			 */
  			musb_root_disconnect(musb);
++<<<<<<< HEAD
 +			musb_to_hcd(musb)->self.is_b_host = 0;
 +			musb->xceiv->state = OTG_STATE_B_PERIPHERAL;
++=======
+ 			if (musb->hcd)
+ 				musb->hcd->self.is_b_host = 0;
+ 			musb->xceiv->otg->state = OTG_STATE_B_PERIPHERAL;
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  			MUSB_DEV_MODE(musb);
  			musb_g_disconnect(musb);
  			break;
@@@ -813,14 -812,9 +847,14 @@@
  			}
  		} else {
  			dev_dbg(musb->controller, "BUS RESET as %s\n",
- 				usb_otg_state_string(musb->xceiv->state));
- 			switch (musb->xceiv->state) {
+ 				usb_otg_state_string(musb->xceiv->otg->state));
+ 			switch (musb->xceiv->otg->state) {
  			case OTG_STATE_A_SUSPEND:
 +				/* We need to ignore disconnect on suspend
 +				 * otherwise tusb 2.0 won't reconnect after a
 +				 * power cycle, which breaks otg compliance.
 +				 */
 +				musb->ignore_disconnect = 1;
  				musb_g_reset(musb);
  				/* FALLTHROUGH */
  			case OTG_STATE_A_WAIT_BCON:	/* OPT TD.4.7-900ms */
@@@ -1953,13 -1983,40 +1987,13 @@@ musb_init_controller(struct device *dev
  
  	if (musb->xceiv->otg->default_a) {
  		MUSB_HST_MODE(musb);
- 		musb->xceiv->state = OTG_STATE_A_IDLE;
+ 		musb->xceiv->otg->state = OTG_STATE_A_IDLE;
  	} else {
  		MUSB_DEV_MODE(musb);
- 		musb->xceiv->state = OTG_STATE_B_IDLE;
+ 		musb->xceiv->otg->state = OTG_STATE_B_IDLE;
  	}
  
 -	switch (musb->port_mode) {
 -	case MUSB_PORT_MODE_HOST:
 -		status = musb_host_setup(musb, plat->power);
 -		if (status < 0)
 -			goto fail3;
 -		status = musb_platform_set_mode(musb, MUSB_HOST);
 -		break;
 -	case MUSB_PORT_MODE_GADGET:
 -		status = musb_gadget_setup(musb);
 -		if (status < 0)
 -			goto fail3;
 -		status = musb_platform_set_mode(musb, MUSB_PERIPHERAL);
 -		break;
 -	case MUSB_PORT_MODE_DUAL_ROLE:
 -		status = musb_host_setup(musb, plat->power);
 -		if (status < 0)
 -			goto fail3;
 -		status = musb_gadget_setup(musb);
 -		if (status) {
 -			musb_host_cleanup(musb);
 -			goto fail3;
 -		}
 -		status = musb_platform_set_mode(musb, MUSB_OTG);
 -		break;
 -	default:
 -		dev_err(dev, "unsupported port mode %d\n", musb->port_mode);
 -		break;
 -	}
 +	status = musb_gadget_setup(musb);
  
  	if (status < 0)
  		goto fail3;
diff --cc drivers/usb/musb/musb_dsps.c
index ed5fab9c8c57,440333fcf3a7..000000000000
--- a/drivers/usb/musb/musb_dsps.c
+++ b/drivers/usb/musb/musb_dsps.c
@@@ -118,53 -140,72 +118,82 @@@ struct dsps_musb_wrapper 
   */
  struct dsps_glue {
  	struct device *dev;
 -	struct platform_device *musb;	/* child musb pdev */
 +	struct platform_device *musb[2];	/* child musb pdev */
  	const struct dsps_musb_wrapper *wrp; /* wrapper register offsets */
 -	struct timer_list timer;	/* otg_workaround timer */
 -	unsigned long last_timer;    /* last timer data for each instance */
 -	bool sw_babble_enabled;
 -
 -	struct dsps_context context;
 -	struct debugfs_regset32 regset;
 -	struct dentry *dbgfs_root;
 +	struct timer_list timer[2];	/* otg_workaround timer */
 +	unsigned long last_timer[2];    /* last timer data for each instance */
 +	u32 __iomem *usb_ctrl[2];
  };
  
 -static const struct debugfs_reg32 dsps_musb_regs[] = {
 -	{ "revision",		0x00 },
 -	{ "control",		0x14 },
 -	{ "status",		0x18 },
 -	{ "eoi",		0x24 },
 -	{ "intr0_stat",		0x30 },
 -	{ "intr1_stat",		0x34 },
 -	{ "intr0_set",		0x38 },
 -	{ "intr1_set",		0x3c },
 -	{ "txmode",		0x70 },
 -	{ "rxmode",		0x74 },
 -	{ "autoreq",		0xd0 },
 -	{ "srpfixtime",		0xd4 },
 -	{ "tdown",		0xd8 },
 -	{ "phy_utmi",		0xe0 },
 -	{ "mode",		0xe8 },
 +#define	DSPS_AM33XX_CONTROL_MODULE_PHYS_0	0x44e10620
 +#define	DSPS_AM33XX_CONTROL_MODULE_PHYS_1	0x44e10628
 +
 +static const resource_size_t dsps_control_module_phys[] = {
 +	DSPS_AM33XX_CONTROL_MODULE_PHYS_0,
 +	DSPS_AM33XX_CONTROL_MODULE_PHYS_1,
  };
  
 -static void dsps_musb_try_idle(struct musb *musb, unsigned long timeout)
 +#define USBPHY_CM_PWRDN		(1 << 0)
 +#define USBPHY_OTG_PWRDN	(1 << 1)
 +#define USBPHY_OTGVDET_EN	(1 << 19)
 +#define USBPHY_OTGSESSEND_EN	(1 << 20)
 +
 +/**
 + * musb_dsps_phy_control - phy on/off
 + * @glue: struct dsps_glue *
 + * @id: musb instance
 + * @on: flag for phy to be switched on or off
 + *
 + * This is to enable the PHY using usb_ctrl register in system control
 + * module space.
 + *
 + * XXX: This function will be removed once we have a seperate driver for
 + * control module
 + */
 +static void musb_dsps_phy_control(struct dsps_glue *glue, u8 id, u8 on)
  {
 -	struct device *dev = musb->controller;
 -	struct dsps_glue *glue = dev_get_drvdata(dev->parent);
 +	u32 usbphycfg;
  
 -	if (timeout == 0)
 -		timeout = jiffies + msecs_to_jiffies(3);
 +	usbphycfg = readl(glue->usb_ctrl[id]);
  
++<<<<<<< HEAD
 +	if (on) {
 +		usbphycfg &= ~(USBPHY_CM_PWRDN | USBPHY_OTG_PWRDN);
 +		usbphycfg |= USBPHY_OTGVDET_EN | USBPHY_OTGSESSEND_EN;
 +	} else {
 +		usbphycfg |= USBPHY_CM_PWRDN | USBPHY_OTG_PWRDN;
++=======
+ 	/* Never idle if active, or when VBUS timeout is not set as host */
+ 	if (musb->is_active || (musb->a_wait_bcon == 0 &&
+ 			musb->xceiv->otg->state == OTG_STATE_A_WAIT_BCON)) {
+ 		dev_dbg(musb->controller, "%s active, deleting timer\n",
+ 				usb_otg_state_string(musb->xceiv->otg->state));
+ 		del_timer(&glue->timer);
+ 		glue->last_timer = jiffies;
+ 		return;
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  	}
 -	if (musb->port_mode != MUSB_PORT_MODE_DUAL_ROLE)
 -		return;
  
++<<<<<<< HEAD
 +	writel(usbphycfg, glue->usb_ctrl[id]);
++=======
+ 	if (!musb->g.dev.driver)
+ 		return;
+ 
+ 	if (time_after(glue->last_timer, timeout) &&
+ 				timer_pending(&glue->timer)) {
+ 		dev_dbg(musb->controller,
+ 			"Longer idle timer already pending, ignoring...\n");
+ 		return;
+ 	}
+ 	glue->last_timer = timeout;
+ 
+ 	dev_dbg(musb->controller, "%s inactive, starting idle timer for %u ms\n",
+ 		usb_otg_state_string(musb->xceiv->otg->state),
+ 			jiffies_to_msecs(timeout - jiffies));
+ 	mod_timer(&glue->timer, timeout);
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  }
 -
  /**
   * dsps_musb_enable - enable interrupts
   */
@@@ -224,25 -265,30 +253,25 @@@ static void otg_timer(unsigned long _mu
  	 */
  	devctl = dsps_readb(mregs, MUSB_DEVCTL);
  	dev_dbg(musb->controller, "Poll devctl %02x (%s)\n", devctl,
- 				usb_otg_state_string(musb->xceiv->state));
+ 				usb_otg_state_string(musb->xceiv->otg->state));
  
  	spin_lock_irqsave(&musb->lock, flags);
- 	switch (musb->xceiv->state) {
+ 	switch (musb->xceiv->otg->state) {
  	case OTG_STATE_A_WAIT_BCON:
 -		dsps_writeb(musb->mregs, MUSB_DEVCTL, 0);
 -		skip_session = 1;
 -		/* fall */
 +		devctl &= ~MUSB_DEVCTL_SESSION;
 +		dsps_writeb(musb->mregs, MUSB_DEVCTL, devctl);
  
 -	case OTG_STATE_A_IDLE:
 -	case OTG_STATE_B_IDLE:
 +		devctl = dsps_readb(musb->mregs, MUSB_DEVCTL);
  		if (devctl & MUSB_DEVCTL_BDEVICE) {
- 			musb->xceiv->state = OTG_STATE_B_IDLE;
+ 			musb->xceiv->otg->state = OTG_STATE_B_IDLE;
  			MUSB_DEV_MODE(musb);
  		} else {
- 			musb->xceiv->state = OTG_STATE_A_IDLE;
+ 			musb->xceiv->otg->state = OTG_STATE_A_IDLE;
  			MUSB_HST_MODE(musb);
  		}
 -		if (!(devctl & MUSB_DEVCTL_SESSION) && !skip_session)
 -			dsps_writeb(mregs, MUSB_DEVCTL, MUSB_DEVCTL_SESSION);
 -		mod_timer(&glue->timer, jiffies + wrp->poll_seconds * HZ);
  		break;
  	case OTG_STATE_A_WAIT_VFALL:
- 		musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
+ 		musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
  		dsps_writel(musb->ctrl_base, wrp->coreintr_set,
  			    MUSB_INTR_VBUSERROR << wrp->usb_shift);
  		break;
@@@ -357,16 -373,15 +386,26 @@@ static irqreturn_t dsps_interrupt(int i
  			 * devctl.
  			 */
  			musb->int_usb &= ~MUSB_INTR_VBUSERROR;
++<<<<<<< HEAD
 +			musb->xceiv->state = OTG_STATE_A_WAIT_VFALL;
 +			mod_timer(&glue->timer[pdev->id],
++=======
+ 			musb->xceiv->otg->state = OTG_STATE_A_WAIT_VFALL;
+ 			mod_timer(&glue->timer,
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  					jiffies + wrp->poll_seconds * HZ);
  			WARNING("VBUS error workaround (delay coming)\n");
  		} else if (drvvbus) {
 +			musb->is_active = 1;
  			MUSB_HST_MODE(musb);
  			musb->xceiv->otg->default_a = 1;
++<<<<<<< HEAD
 +			musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
 +			del_timer(&glue->timer[pdev->id]);
++=======
+ 			musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
+ 			del_timer(&glue->timer);
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  		} else {
  			musb->is_active = 0;
  			MUSB_DEV_MODE(musb);
@@@ -386,16 -401,11 +425,24 @@@
  	if (musb->int_tx || musb->int_rx || musb->int_usb)
  		ret |= musb_interrupt(musb);
  
++<<<<<<< HEAD
 + eoi:
 +	/* EOI needs to be written for the IRQ to be re-asserted. */
 +	if (ret == IRQ_HANDLED || epintr || usbintr)
 +		dsps_writel(reg_base, wrp->eoi, 1);
 +
 +	/* Poll for ID change */
 +	if (musb->xceiv->state == OTG_STATE_B_IDLE)
 +		mod_timer(&glue->timer[pdev->id],
 +			 jiffies + wrp->poll_seconds * HZ);
 +
++=======
+ 	/* Poll for ID change in OTG port mode */
+ 	if (musb->xceiv->otg->state == OTG_STATE_B_IDLE &&
+ 			musb->port_mode == MUSB_PORT_MODE_DUAL_ROLE)
+ 		mod_timer(&glue->timer, jiffies + wrp->poll_seconds * HZ);
+ out:
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  	spin_unlock_irqrestore(&musb->lock, flags);
  
  	return ret;
@@@ -765,8 -855,61 +812,62 @@@ static const struct of_device_id musb_d
  	{  },
  };
  MODULE_DEVICE_TABLE(of, musb_dsps_of_match);
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_PM_SLEEP
+ static int dsps_suspend(struct device *dev)
+ {
+ 	struct dsps_glue *glue = dev_get_drvdata(dev);
+ 	const struct dsps_musb_wrapper *wrp = glue->wrp;
+ 	struct musb *musb = platform_get_drvdata(glue->musb);
+ 	void __iomem *mbase;
+ 
+ 	del_timer_sync(&glue->timer);
+ 
+ 	if (!musb)
+ 		/* This can happen if the musb device is in -EPROBE_DEFER */
+ 		return 0;
+ 
+ 	mbase = musb->ctrl_base;
+ 	glue->context.control = dsps_readl(mbase, wrp->control);
+ 	glue->context.epintr = dsps_readl(mbase, wrp->epintr_set);
+ 	glue->context.coreintr = dsps_readl(mbase, wrp->coreintr_set);
+ 	glue->context.phy_utmi = dsps_readl(mbase, wrp->phy_utmi);
+ 	glue->context.mode = dsps_readl(mbase, wrp->mode);
+ 	glue->context.tx_mode = dsps_readl(mbase, wrp->tx_mode);
+ 	glue->context.rx_mode = dsps_readl(mbase, wrp->rx_mode);
+ 
+ 	return 0;
+ }
+ 
+ static int dsps_resume(struct device *dev)
+ {
+ 	struct dsps_glue *glue = dev_get_drvdata(dev);
+ 	const struct dsps_musb_wrapper *wrp = glue->wrp;
+ 	struct musb *musb = platform_get_drvdata(glue->musb);
+ 	void __iomem *mbase;
+ 
+ 	if (!musb)
+ 		return 0;
+ 
+ 	mbase = musb->ctrl_base;
+ 	dsps_writel(mbase, wrp->control, glue->context.control);
+ 	dsps_writel(mbase, wrp->epintr_set, glue->context.epintr);
+ 	dsps_writel(mbase, wrp->coreintr_set, glue->context.coreintr);
+ 	dsps_writel(mbase, wrp->phy_utmi, glue->context.phy_utmi);
+ 	dsps_writel(mbase, wrp->mode, glue->context.mode);
+ 	dsps_writel(mbase, wrp->tx_mode, glue->context.tx_mode);
+ 	dsps_writel(mbase, wrp->rx_mode, glue->context.rx_mode);
+ 	if (musb->xceiv->otg->state == OTG_STATE_B_IDLE &&
+ 	    musb->port_mode == MUSB_PORT_MODE_DUAL_ROLE)
+ 		mod_timer(&glue->timer, jiffies + wrp->poll_seconds * HZ);
+ 
+ 	return 0;
+ }
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  #endif
  
 -static SIMPLE_DEV_PM_OPS(dsps_pm_ops, dsps_suspend, dsps_resume);
 -
  static struct platform_driver dsps_usbss_driver = {
  	.probe		= dsps_probe,
  	.remove         = dsps_remove,
diff --cc drivers/usb/musb/musb_gadget.c
index ba7092349fa9,56c31b769a54..000000000000
--- a/drivers/usb/musb/musb_gadget.c
+++ b/drivers/usb/musb/musb_gadget.c
@@@ -1779,9 -1789,17 +1779,16 @@@ int musb_gadget_setup(struct musb *musb
  	musb->g.max_speed = USB_SPEED_HIGH;
  	musb->g.speed = USB_SPEED_UNKNOWN;
  
++<<<<<<< HEAD
++=======
+ 	MUSB_DEV_MODE(musb);
+ 	musb->xceiv->otg->default_a = 0;
+ 	musb->xceiv->otg->state = OTG_STATE_B_IDLE;
+ 
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  	/* this "gadget" abstracts/virtualizes the controller */
  	musb->g.name = musb_driver_name;
 -#if IS_ENABLED(CONFIG_USB_MUSB_DUAL_ROLE)
  	musb->g.is_otg = 1;
 -#elif IS_ENABLED(CONFIG_USB_MUSB_GADGET)
 -	musb->g.is_otg = 0;
 -#endif
  
  	musb_g_init_endpoints(musb);
  
@@@ -1840,9 -1857,11 +1847,9 @@@ static int musb_gadget_start(struct usb
  	musb->is_active = 1;
  
  	otg_set_peripheral(otg, &musb->g);
- 	musb->xceiv->state = OTG_STATE_B_IDLE;
+ 	musb->xceiv->otg->state = OTG_STATE_B_IDLE;
  	spin_unlock_irqrestore(&musb->lock, flags);
  
 -	musb_start(musb);
 -
  	/* REVISIT:  funcall to other code, which also
  	 * handles power budgeting ... this way also
  	 * ensures HdrcStart is indirectly called.
@@@ -1931,12 -1941,10 +1938,17 @@@ static int musb_gadget_stop(struct usb_
  
  	(void) musb_gadget_vbus_draw(&musb->g, 0);
  
++<<<<<<< HEAD
 +	musb->xceiv->state = OTG_STATE_UNDEFINED;
 +	stop_activity(musb, driver);
++=======
+ 	musb->xceiv->otg->state = OTG_STATE_UNDEFINED;
+ 	stop_activity(musb, NULL);
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  	otg_set_peripheral(musb->xceiv->otg, NULL);
  
 +	dev_dbg(musb->controller, "unregistering driver %s\n", driver->function);
 +
  	musb->is_active = 0;
  	musb->gadget_driver = NULL;
  	musb_platform_try_idle(musb, 0);
@@@ -2105,11 -2112,19 +2117,24 @@@ __acquires(musb->lock
  	/* Normal reset, as B-Device;
  	 * or else after HNP, as A-Device
  	 */
++<<<<<<< HEAD
 +	if (devctl & MUSB_DEVCTL_BDEVICE) {
 +		musb->xceiv->state = OTG_STATE_B_PERIPHERAL;
++=======
+ 	if (!musb->g.is_otg) {
+ 		/* USB device controllers that are not OTG compatible
+ 		 * may not have DEVCTL register in silicon.
+ 		 * In that case, do not rely on devctl for setting
+ 		 * peripheral mode.
+ 		 */
+ 		musb->xceiv->otg->state = OTG_STATE_B_PERIPHERAL;
+ 		musb->g.is_a_peripheral = 0;
+ 	} else if (devctl & MUSB_DEVCTL_BDEVICE) {
+ 		musb->xceiv->otg->state = OTG_STATE_B_PERIPHERAL;
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  		musb->g.is_a_peripheral = 0;
  	} else {
- 		musb->xceiv->state = OTG_STATE_A_PERIPHERAL;
+ 		musb->xceiv->otg->state = OTG_STATE_A_PERIPHERAL;
  		musb->g.is_a_peripheral = 1;
  	}
  
diff --cc drivers/usb/musb/musb_host.c
index 9c5ed0aa45a4,23d474d3d7f4..000000000000
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@@ -2605,3 -2640,69 +2605,72 @@@ const struct hc_driver musb_hc_driver 
  	/* .start_port_reset	= NULL, */
  	/* .hub_irq_enable	= NULL, */
  };
++<<<<<<< HEAD
++=======
+ 
+ int musb_host_alloc(struct musb *musb)
+ {
+ 	struct device	*dev = musb->controller;
+ 
+ 	/* usbcore sets dev->driver_data to hcd, and sometimes uses that... */
+ 	musb->hcd = usb_create_hcd(&musb_hc_driver, dev, dev_name(dev));
+ 	if (!musb->hcd)
+ 		return -EINVAL;
+ 
+ 	*musb->hcd->hcd_priv = (unsigned long) musb;
+ 	musb->hcd->self.uses_pio_for_control = 1;
+ 	musb->hcd->uses_new_polling = 1;
+ 	musb->hcd->has_tt = 1;
+ 
+ 	return 0;
+ }
+ 
+ void musb_host_cleanup(struct musb *musb)
+ {
+ 	if (musb->port_mode == MUSB_PORT_MODE_GADGET)
+ 		return;
+ 	usb_remove_hcd(musb->hcd);
+ 	musb->hcd = NULL;
+ }
+ 
+ void musb_host_free(struct musb *musb)
+ {
+ 	usb_put_hcd(musb->hcd);
+ }
+ 
+ int musb_host_setup(struct musb *musb, int power_budget)
+ {
+ 	int ret;
+ 	struct usb_hcd *hcd = musb->hcd;
+ 
+ 	MUSB_HST_MODE(musb);
+ 	musb->xceiv->otg->default_a = 1;
+ 	musb->xceiv->otg->state = OTG_STATE_A_IDLE;
+ 
+ 	otg_set_host(musb->xceiv->otg, &hcd->self);
+ 	hcd->self.otg_port = 1;
+ 	musb->xceiv->otg->host = &hcd->self;
+ 	hcd->power_budget = 2 * (power_budget ? : 250);
+ 
+ 	ret = usb_add_hcd(hcd, 0, 0);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	device_wakeup_enable(hcd->self.controller);
+ 	return 0;
+ }
+ 
+ void musb_host_resume_root_hub(struct musb *musb)
+ {
+ 	usb_hcd_resume_root_hub(musb->hcd);
+ }
+ 
+ void musb_host_poke_root_hub(struct musb *musb)
+ {
+ 	MUSB_HST_MODE(musb);
+ 	if (musb->hcd->status_urb)
+ 		usb_hcd_poll_rh_status(musb->hcd);
+ 	else
+ 		usb_hcd_resume_root_hub(musb->hcd);
+ }
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
diff --cc drivers/usb/musb/musb_virthub.c
index 259192d8b11a,a133bd8c5dc7..000000000000
--- a/drivers/usb/musb/musb_virthub.c
+++ b/drivers/usb/musb/musb_virthub.c
@@@ -43,8 -43,38 +43,37 @@@
  
  #include "musb_core.h"
  
 -void musb_host_finish_resume(struct work_struct *work)
 -{
 -	struct musb *musb;
 -	unsigned long flags;
 -	u8 power;
  
++<<<<<<< HEAD
 +static void musb_port_suspend(struct musb *musb, bool do_suspend)
++=======
+ 	musb = container_of(work, struct musb, finish_resume_work.work);
+ 
+ 	spin_lock_irqsave(&musb->lock, flags);
+ 
+ 	power = musb_readb(musb->mregs, MUSB_POWER);
+ 	power &= ~MUSB_POWER_RESUME;
+ 	dev_dbg(musb->controller, "root port resume stopped, power %02x\n",
+ 		power);
+ 	musb_writeb(musb->mregs, MUSB_POWER, power);
+ 
+ 	/*
+ 	 * ISSUE:  DaVinci (RTL 1.300) disconnects after
+ 	 * resume of high speed peripherals (but not full
+ 	 * speed ones).
+ 	 */
+ 	musb->is_active = 1;
+ 	musb->port1_status &= ~(USB_PORT_STAT_SUSPEND | MUSB_PORT_STAT_RESUME);
+ 	musb->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;
+ 	usb_hcd_poll_rh_status(musb->hcd);
+ 	/* NOTE: it might really be A_WAIT_BCON ... */
+ 	musb->xceiv->otg->state = OTG_STATE_A_HOST;
+ 
+ 	spin_unlock_irqrestore(&musb->lock, flags);
+ }
+ 
+ void musb_port_suspend(struct musb *musb, bool do_suspend)
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  {
  	struct usb_otg	*otg = musb->xceiv->otg;
  	u8		power;
@@@ -182,13 -221,13 +211,13 @@@ void musb_root_disconnect(struct musb *
  	musb->port1_status = USB_PORT_STAT_POWER
  			| (USB_PORT_STAT_C_CONNECTION << 16);
  
 -	usb_hcd_poll_rh_status(musb->hcd);
 +	usb_hcd_poll_rh_status(musb_to_hcd(musb));
  	musb->is_active = 0;
  
- 	switch (musb->xceiv->state) {
+ 	switch (musb->xceiv->otg->state) {
  	case OTG_STATE_A_SUSPEND:
  		if (otg->host->b_hnp_enable) {
- 			musb->xceiv->state = OTG_STATE_A_PERIPHERAL;
+ 			musb->xceiv->otg->state = OTG_STATE_A_PERIPHERAL;
  			musb->g.is_a_peripheral = 1;
  			break;
  		}
diff --cc drivers/usb/phy/phy-ab8500-usb.c
index e5eb1b5a04eb,2d5250143ce1..000000000000
--- a/drivers/usb/phy/phy-ab8500-usb.c
+++ b/drivers/usb/phy/phy-ab8500-usb.c
@@@ -298,6 -411,254 +298,257 @@@ static void ab8500_usb_phy_disable(stru
  #define ab8500_usb_peri_phy_en(ab)	ab8500_usb_phy_enable(ab, false)
  #define ab8500_usb_peri_phy_dis(ab)	ab8500_usb_phy_disable(ab, false)
  
++<<<<<<< HEAD
++=======
+ static int ab9540_usb_link_status_update(struct ab8500_usb *ab,
+ 		enum ab9540_usb_link_status lsts)
+ {
+ 	enum ux500_musb_vbus_id_status event = 0;
+ 
+ 	dev_dbg(ab->dev, "ab9540_usb_link_status_update %d\n", lsts);
+ 
+ 	if (ab->previous_link_status_state == USB_LINK_HM_IDGND_9540 &&
+ 			(lsts == USB_LINK_STD_HOST_C_NS_9540 ||
+ 			 lsts == USB_LINK_STD_HOST_NC_9540))
+ 		return 0;
+ 
+ 	if (ab->previous_link_status_state == USB_LINK_ACA_RID_A_9540 &&
+ 			(lsts == USB_LINK_STD_HOST_NC_9540))
+ 		return 0;
+ 
+ 	ab->previous_link_status_state = lsts;
+ 
+ 	switch (lsts) {
+ 	case USB_LINK_ACA_RID_B_9540:
+ 		event = UX500_MUSB_RIDB;
+ 	case USB_LINK_NOT_CONFIGURED_9540:
+ 	case USB_LINK_RESERVED0_9540:
+ 	case USB_LINK_RESERVED1_9540:
+ 	case USB_LINK_RESERVED2_9540:
+ 	case USB_LINK_RESERVED3_9540:
+ 		if (ab->mode == USB_PERIPHERAL)
+ 			atomic_notifier_call_chain(&ab->phy.notifier,
+ 					UX500_MUSB_CLEAN, &ab->vbus_draw);
+ 		ab->mode = USB_IDLE;
+ 		ab->phy.otg->default_a = false;
+ 		ab->vbus_draw = 0;
+ 		if (event != UX500_MUSB_RIDB)
+ 			event = UX500_MUSB_NONE;
+ 		/* Fallback to default B_IDLE as nothing is connected. */
+ 		ab->phy.otg->state = OTG_STATE_B_IDLE;
+ 		break;
+ 
+ 	case USB_LINK_ACA_RID_C_NM_9540:
+ 		event = UX500_MUSB_RIDC;
+ 	case USB_LINK_STD_HOST_NC_9540:
+ 	case USB_LINK_STD_HOST_C_NS_9540:
+ 	case USB_LINK_STD_HOST_C_S_9540:
+ 	case USB_LINK_CDP_9540:
+ 		if (ab->mode == USB_HOST) {
+ 			ab->mode = USB_PERIPHERAL;
+ 			ab8500_usb_host_phy_dis(ab);
+ 			ab8500_usb_peri_phy_en(ab);
+ 			atomic_notifier_call_chain(&ab->phy.notifier,
+ 					UX500_MUSB_PREPARE, &ab->vbus_draw);
+ 		}
+ 		if (ab->mode == USB_IDLE) {
+ 			ab->mode = USB_PERIPHERAL;
+ 			ab8500_usb_peri_phy_en(ab);
+ 			atomic_notifier_call_chain(&ab->phy.notifier,
+ 					UX500_MUSB_PREPARE, &ab->vbus_draw);
+ 		}
+ 		if (event != UX500_MUSB_RIDC)
+ 			event = UX500_MUSB_VBUS;
+ 		break;
+ 
+ 	case USB_LINK_ACA_RID_A_9540:
+ 		event = UX500_MUSB_RIDA;
+ 	case USB_LINK_HM_IDGND_9540:
+ 	case USB_LINK_STD_UPSTREAM_9540:
+ 		if (ab->mode == USB_PERIPHERAL) {
+ 			ab->mode = USB_HOST;
+ 			ab8500_usb_peri_phy_dis(ab);
+ 			ab8500_usb_host_phy_en(ab);
+ 			atomic_notifier_call_chain(&ab->phy.notifier,
+ 					UX500_MUSB_PREPARE, &ab->vbus_draw);
+ 		}
+ 		if (ab->mode == USB_IDLE) {
+ 			ab->mode = USB_HOST;
+ 			ab8500_usb_host_phy_en(ab);
+ 			atomic_notifier_call_chain(&ab->phy.notifier,
+ 					UX500_MUSB_PREPARE, &ab->vbus_draw);
+ 		}
+ 		ab->phy.otg->default_a = true;
+ 		if (event != UX500_MUSB_RIDA)
+ 			event = UX500_MUSB_ID;
+ 
+ 		atomic_notifier_call_chain(&ab->phy.notifier,
+ 				event, &ab->vbus_draw);
+ 		break;
+ 
+ 	case USB_LINK_DEDICATED_CHG_9540:
+ 		ab->mode = USB_DEDICATED_CHG;
+ 		event = UX500_MUSB_CHARGER;
+ 		atomic_notifier_call_chain(&ab->phy.notifier,
+ 				event, &ab->vbus_draw);
+ 		break;
+ 
+ 	case USB_LINK_PHYEN_NO_VBUS_NO_IDGND_9540:
+ 	case USB_LINK_STD_UPSTREAM_NO_IDGNG_VBUS_9540:
+ 		if (!(is_ab9540_2p0_or_earlier(ab->ab8500))) {
+ 			event = UX500_MUSB_NONE;
+ 			if (ab->mode == USB_HOST) {
+ 				ab->phy.otg->default_a = false;
+ 				ab->vbus_draw = 0;
+ 				atomic_notifier_call_chain(&ab->phy.notifier,
+ 						event, &ab->vbus_draw);
+ 				ab8500_usb_host_phy_dis(ab);
+ 				ab->mode = USB_IDLE;
+ 			}
+ 			if (ab->mode == USB_PERIPHERAL) {
+ 				atomic_notifier_call_chain(&ab->phy.notifier,
+ 						event, &ab->vbus_draw);
+ 				ab8500_usb_peri_phy_dis(ab);
+ 				atomic_notifier_call_chain(&ab->phy.notifier,
+ 						UX500_MUSB_CLEAN,
+ 						&ab->vbus_draw);
+ 				ab->mode = USB_IDLE;
+ 				ab->phy.otg->default_a = false;
+ 				ab->vbus_draw = 0;
+ 			}
+ 		}
+ 		break;
+ 
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int ab8540_usb_link_status_update(struct ab8500_usb *ab,
+ 		enum ab8540_usb_link_status lsts)
+ {
+ 	enum ux500_musb_vbus_id_status event = 0;
+ 
+ 	dev_dbg(ab->dev, "ab8540_usb_link_status_update %d\n", lsts);
+ 
+ 	if (ab->enabled_charging_detection) {
+ 		/* Disable USB Charger detection */
+ 		abx500_mask_and_set_register_interruptible(ab->dev,
+ 				AB8500_USB, AB8540_VBUS_CTRL_REG,
+ 				AB8540_BIT_VBUS_CTRL_CHARG_DET_ENA, 0x00);
+ 		ab->enabled_charging_detection = false;
+ 	}
+ 
+ 	/*
+ 	 * Spurious link_status interrupts are seen in case of a
+ 	 * disconnection of a device in IDGND and RIDA stage
+ 	 */
+ 	if (ab->previous_link_status_state == USB_LINK_HM_IDGND_8540 &&
+ 			(lsts == USB_LINK_STD_HOST_C_NS_8540 ||
+ 			 lsts == USB_LINK_STD_HOST_NC_8540))
+ 		return 0;
+ 
+ 	if (ab->previous_link_status_state == USB_LINK_ACA_RID_A_8540 &&
+ 			(lsts == USB_LINK_STD_HOST_NC_8540))
+ 		return 0;
+ 
+ 	ab->previous_link_status_state = lsts;
+ 
+ 	switch (lsts) {
+ 	case USB_LINK_ACA_RID_B_8540:
+ 		event = UX500_MUSB_RIDB;
+ 	case USB_LINK_NOT_CONFIGURED_8540:
+ 	case USB_LINK_RESERVED0_8540:
+ 	case USB_LINK_RESERVED1_8540:
+ 	case USB_LINK_RESERVED2_8540:
+ 	case USB_LINK_RESERVED3_8540:
+ 		ab->mode = USB_IDLE;
+ 		ab->phy.otg->default_a = false;
+ 		ab->vbus_draw = 0;
+ 		if (event != UX500_MUSB_RIDB)
+ 			event = UX500_MUSB_NONE;
+ 		/*
+ 		 * Fallback to default B_IDLE as nothing
+ 		 * is connected
+ 		 */
+ 		ab->phy.otg->state = OTG_STATE_B_IDLE;
+ 		break;
+ 
+ 	case USB_LINK_ACA_RID_C_NM_8540:
+ 		event = UX500_MUSB_RIDC;
+ 	case USB_LINK_STD_HOST_NC_8540:
+ 	case USB_LINK_STD_HOST_C_NS_8540:
+ 	case USB_LINK_STD_HOST_C_S_8540:
+ 	case USB_LINK_CDP_8540:
+ 		if (ab->mode == USB_IDLE) {
+ 			ab->mode = USB_PERIPHERAL;
+ 			ab8500_usb_peri_phy_en(ab);
+ 			atomic_notifier_call_chain(&ab->phy.notifier,
+ 					UX500_MUSB_PREPARE, &ab->vbus_draw);
+ 		}
+ 		if (event != UX500_MUSB_RIDC)
+ 			event = UX500_MUSB_VBUS;
+ 		break;
+ 
+ 	case USB_LINK_ACA_RID_A_8540:
+ 	case USB_LINK_ACA_DOCK_CHGR_8540:
+ 		event = UX500_MUSB_RIDA;
+ 	case USB_LINK_HM_IDGND_8540:
+ 	case USB_LINK_STD_UPSTREAM_8540:
+ 		if (ab->mode == USB_IDLE) {
+ 			ab->mode = USB_HOST;
+ 			ab8500_usb_host_phy_en(ab);
+ 			atomic_notifier_call_chain(&ab->phy.notifier,
+ 					UX500_MUSB_PREPARE, &ab->vbus_draw);
+ 		}
+ 		ab->phy.otg->default_a = true;
+ 		if (event != UX500_MUSB_RIDA)
+ 			event = UX500_MUSB_ID;
+ 		atomic_notifier_call_chain(&ab->phy.notifier,
+ 				event, &ab->vbus_draw);
+ 		break;
+ 
+ 	case USB_LINK_DEDICATED_CHG_8540:
+ 		ab->mode = USB_DEDICATED_CHG;
+ 		event = UX500_MUSB_CHARGER;
+ 		atomic_notifier_call_chain(&ab->phy.notifier,
+ 				event, &ab->vbus_draw);
+ 		break;
+ 
+ 	case USB_LINK_PHYEN_NO_VBUS_NO_IDGND_8540:
+ 	case USB_LINK_STD_UPSTREAM_NO_IDGNG_VBUS_8540:
+ 		event = UX500_MUSB_NONE;
+ 		if (ab->mode == USB_HOST) {
+ 			ab->phy.otg->default_a = false;
+ 			ab->vbus_draw = 0;
+ 			atomic_notifier_call_chain(&ab->phy.notifier,
+ 					event, &ab->vbus_draw);
+ 			ab8500_usb_host_phy_dis(ab);
+ 			ab->mode = USB_IDLE;
+ 		}
+ 		if (ab->mode == USB_PERIPHERAL) {
+ 			atomic_notifier_call_chain(&ab->phy.notifier,
+ 					event, &ab->vbus_draw);
+ 			ab8500_usb_peri_phy_dis(ab);
+ 			atomic_notifier_call_chain(&ab->phy.notifier,
+ 					UX500_MUSB_CLEAN, &ab->vbus_draw);
+ 			ab->mode = USB_IDLE;
+ 			ab->phy.otg->default_a = false;
+ 			ab->vbus_draw = 0;
+ 		}
+ 		break;
+ 
+ 	default:
+ 		event = UX500_MUSB_NONE;
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  static int ab8505_usb_link_status_update(struct ab8500_usb *ab,
  		enum ab8505_usb_link_status lsts)
  {
diff --cc drivers/usb/phy/phy-isp1301-omap.c
index ae481afcb3ec,24f84cbbed57..000000000000
--- a/drivers/usb/phy/phy-isp1301-omap.c
+++ b/drivers/usb/phy/phy-isp1301-omap.c
@@@ -1418,8 -1414,7 +1418,12 @@@ isp1301_start_srp(struct usb_otg *otg
  	struct isp1301	*isp = container_of(otg->phy, struct isp1301, phy);
  	u32		otg_ctrl;
  
++<<<<<<< HEAD
 +	if (!otg || isp != the_transceiver
 +			|| isp->phy.state != OTG_STATE_B_IDLE)
++=======
+ 	if (isp != the_transceiver || isp->phy.otg->state != OTG_STATE_B_IDLE)
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  		return -ENODEV;
  
  	otg_ctrl = omap_readl(OTG_CTRL);
diff --cc drivers/usb/phy/phy-msm-usb.c
index 749fbf41fb6f,18015b7c8afc..000000000000
--- a/drivers/usb/phy/phy-msm-usb.c
+++ b/drivers/usb/phy/phy-msm-usb.c
@@@ -1213,7 -1229,9 +1213,13 @@@ static void msm_otg_sm_work(struct work
  			motg->chg_state = USB_CHG_STATE_UNDEFINED;
  			motg->chg_type = USB_INVALID_CHARGER;
  		}
++<<<<<<< HEAD
 +		pm_runtime_put_sync(otg->phy->dev);
++=======
+ 
+ 		if (otg->state == OTG_STATE_B_IDLE)
+ 			pm_runtime_put_sync(otg->phy->dev);
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  		break;
  	case OTG_STATE_B_PERIPHERAL:
  		dev_dbg(otg->phy->dev, "OTG_STATE_B_PERIPHERAL state\n");
@@@ -1285,15 -1303,15 +1291,15 @@@ static int msm_otg_mode_show(struct seq
  	struct msm_otg *motg = s->private;
  	struct usb_otg *otg = motg->phy.otg;
  
- 	switch (otg->phy->state) {
+ 	switch (otg->state) {
  	case OTG_STATE_A_HOST:
 -		seq_puts(s, "host\n");
 +		seq_printf(s, "host\n");
  		break;
  	case OTG_STATE_B_PERIPHERAL:
 -		seq_puts(s, "peripheral\n");
 +		seq_printf(s, "peripheral\n");
  		break;
  	default:
 -		seq_puts(s, "none\n");
 +		seq_printf(s, "none\n");
  		break;
  	}
  
@@@ -1334,8 -1352,8 +1340,13 @@@ static ssize_t msm_otg_mode_write(struc
  	}
  
  	switch (req_mode) {
++<<<<<<< HEAD
 +	case USB_NONE:
 +		switch (otg->phy->state) {
++=======
+ 	case USB_DR_MODE_UNKNOWN:
+ 		switch (otg->state) {
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  		case OTG_STATE_A_HOST:
  		case OTG_STATE_B_PERIPHERAL:
  			set_bit(ID, &motg->inputs);
@@@ -1345,8 -1363,8 +1356,13 @@@
  			goto out;
  		}
  		break;
++<<<<<<< HEAD
 +	case USB_PERIPHERAL:
 +		switch (otg->phy->state) {
++=======
+ 	case USB_DR_MODE_PERIPHERAL:
+ 		switch (otg->state) {
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  		case OTG_STATE_B_IDLE:
  		case OTG_STATE_A_HOST:
  			set_bit(ID, &motg->inputs);
@@@ -1356,8 -1374,8 +1372,13 @@@
  			goto out;
  		}
  		break;
++<<<<<<< HEAD
 +	case USB_HOST:
 +		switch (otg->phy->state) {
++=======
+ 	case USB_DR_MODE_HOST:
+ 		switch (otg->state) {
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure)
  		case OTG_STATE_B_IDLE:
  		case OTG_STATE_B_PERIPHERAL:
  			clear_bit(ID, &motg->inputs);
diff --cc drivers/usb/phy/phy-nop.c
index 638cc5dade35,280a3458ff6b..000000000000
--- a/drivers/usb/phy/phy-nop.c
+++ b/drivers/usb/phy/phy-nop.c
@@@ -217,11 -225,9 +217,15 @@@ static int nop_usb_xceiv_probe(struct p
  	nop->phy.dev		= nop->dev;
  	nop->phy.label		= "nop-xceiv";
  	nop->phy.set_suspend	= nop_set_suspend;
++<<<<<<< HEAD:drivers/usb/phy/phy-nop.c
 +	nop->phy.init		= nop_init;
 +	nop->phy.shutdown	= nop_shutdown;
 +	nop->phy.state		= OTG_STATE_UNDEFINED;
++=======
++>>>>>>> e47d92545c29 (usb: move the OTG state from the USB PHY to the OTG structure):drivers/usb/phy/phy-generic.c
  	nop->phy.type		= type;
  
+ 	nop->phy.otg->state		= OTG_STATE_UNDEFINED;
  	nop->phy.otg->phy		= &nop->phy;
  	nop->phy.otg->set_host		= nop_set_host;
  	nop->phy.otg->set_peripheral	= nop_set_peripheral;
* Unmerged path drivers/usb/chipidea/otg_fsm.c
* Unmerged path drivers/usb/phy/phy-tahvo.c
* Unmerged path drivers/usb/chipidea/debug.c
* Unmerged path drivers/usb/chipidea/otg_fsm.c
* Unmerged path drivers/usb/host/ohci-omap.c
diff --git a/drivers/usb/musb/am35x.c b/drivers/usb/musb/am35x.c
index dbe6007a6386..27f1bb16eaaa 100644
--- a/drivers/usb/musb/am35x.c
+++ b/drivers/usb/musb/am35x.c
@@ -148,25 +148,25 @@ static void otg_timer(unsigned long _musb)
 	 */
 	devctl = musb_readb(mregs, MUSB_DEVCTL);
 	dev_dbg(musb->controller, "Poll devctl %02x (%s)\n", devctl,
-		usb_otg_state_string(musb->xceiv->state));
+		usb_otg_state_string(musb->xceiv->otg->state));
 
 	spin_lock_irqsave(&musb->lock, flags);
-	switch (musb->xceiv->state) {
+	switch (musb->xceiv->otg->state) {
 	case OTG_STATE_A_WAIT_BCON:
 		devctl &= ~MUSB_DEVCTL_SESSION;
 		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
 
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 		if (devctl & MUSB_DEVCTL_BDEVICE) {
-			musb->xceiv->state = OTG_STATE_B_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 			MUSB_DEV_MODE(musb);
 		} else {
-			musb->xceiv->state = OTG_STATE_A_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_A_IDLE;
 			MUSB_HST_MODE(musb);
 		}
 		break;
 	case OTG_STATE_A_WAIT_VFALL:
-		musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
+		musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
 		musb_writel(musb->ctrl_base, CORE_INTR_SRC_SET_REG,
 			    MUSB_INTR_VBUSERROR << AM35X_INTR_USB_SHIFT);
 		break;
@@ -175,7 +175,7 @@ static void otg_timer(unsigned long _musb)
 		if (devctl & MUSB_DEVCTL_BDEVICE)
 			mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 		else
-			musb->xceiv->state = OTG_STATE_A_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_A_IDLE;
 		break;
 	default:
 		break;
@@ -192,9 +192,9 @@ static void am35x_musb_try_idle(struct musb *musb, unsigned long timeout)
 
 	/* Never idle if active, or when VBUS timeout is not set as host */
 	if (musb->is_active || (musb->a_wait_bcon == 0 &&
-				musb->xceiv->state == OTG_STATE_A_WAIT_BCON)) {
+				musb->xceiv->otg->state == OTG_STATE_A_WAIT_BCON)) {
 		dev_dbg(musb->controller, "%s active, deleting timer\n",
-			usb_otg_state_string(musb->xceiv->state));
+			usb_otg_state_string(musb->xceiv->otg->state));
 		del_timer(&otg_workaround);
 		last_timer = jiffies;
 		return;
@@ -207,7 +207,7 @@ static void am35x_musb_try_idle(struct musb *musb, unsigned long timeout)
 	last_timer = timeout;
 
 	dev_dbg(musb->controller, "%s inactive, starting idle timer for %u ms\n",
-		usb_otg_state_string(musb->xceiv->state),
+		usb_otg_state_string(musb->xceiv->otg->state),
 		jiffies_to_msecs(timeout - jiffies));
 	mod_timer(&otg_workaround, timeout);
 }
@@ -277,27 +277,27 @@ static irqreturn_t am35x_musb_interrupt(int irq, void *hci)
 			 * devctl.
 			 */
 			musb->int_usb &= ~MUSB_INTR_VBUSERROR;
-			musb->xceiv->state = OTG_STATE_A_WAIT_VFALL;
+			musb->xceiv->otg->state = OTG_STATE_A_WAIT_VFALL;
 			mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 			WARNING("VBUS error workaround (delay coming)\n");
 		} else if (drvvbus) {
 			MUSB_HST_MODE(musb);
 			otg->default_a = 1;
-			musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
+			musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
 			portstate(musb->port1_status |= USB_PORT_STAT_POWER);
 			del_timer(&otg_workaround);
 		} else {
 			musb->is_active = 0;
 			MUSB_DEV_MODE(musb);
 			otg->default_a = 0;
-			musb->xceiv->state = OTG_STATE_B_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 			portstate(musb->port1_status &= ~USB_PORT_STAT_POWER);
 		}
 
 		/* NOTE: this must complete power-on within 100 ms. */
 		dev_dbg(musb->controller, "VBUS %s (%s)%s, devctl %02x\n",
 				drvvbus ? "on" : "off",
-				usb_otg_state_string(musb->xceiv->state),
+				usb_otg_state_string(musb->xceiv->otg->state),
 				err ? " ERROR" : "",
 				devctl);
 		ret = IRQ_HANDLED;
@@ -323,7 +323,7 @@ eoi:
 	}
 
 	/* Poll for ID change */
-	if (musb->xceiv->state == OTG_STATE_B_IDLE)
+	if (musb->xceiv->otg->state == OTG_STATE_B_IDLE)
 		mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 
 	spin_unlock_irqrestore(&musb->lock, flags);
diff --git a/drivers/usb/musb/blackfin.c b/drivers/usb/musb/blackfin.c
index 72743225a0ef..41e20b7fc203 100644
--- a/drivers/usb/musb/blackfin.c
+++ b/drivers/usb/musb/blackfin.c
@@ -184,8 +184,8 @@ static irqreturn_t blackfin_interrupt(int irq, void *__hci)
 	}
 
 	/* Start sampling ID pin, when plug is removed from MUSB */
-	if ((musb->xceiv->state == OTG_STATE_B_IDLE
-		|| musb->xceiv->state == OTG_STATE_A_WAIT_BCON) ||
+	if ((musb->xceiv->otg->state == OTG_STATE_B_IDLE
+		|| musb->xceiv->otg->state == OTG_STATE_A_WAIT_BCON) ||
 		(musb->int_usb & MUSB_INTR_DISCONNECT && is_host_active(musb))) {
 		mod_timer(&musb_conn_timer, jiffies + TIMER_DELAY);
 		musb->a_wait_bcon = TIMER_DELAY;
@@ -204,7 +204,7 @@ static void musb_conn_timer_handler(unsigned long _musb)
 	static u8 toggle;
 
 	spin_lock_irqsave(&musb->lock, flags);
-	switch (musb->xceiv->state) {
+	switch (musb->xceiv->otg->state) {
 	case OTG_STATE_A_IDLE:
 	case OTG_STATE_A_WAIT_BCON:
 		/* Start a new session */
@@ -218,7 +218,7 @@ static void musb_conn_timer_handler(unsigned long _musb)
 
 		if (!(val & MUSB_DEVCTL_BDEVICE)) {
 			gpio_set_value(musb->config->gpio_vrsel, 1);
-			musb->xceiv->state = OTG_STATE_A_WAIT_BCON;
+			musb->xceiv->otg->state = OTG_STATE_A_WAIT_BCON;
 		} else {
 			gpio_set_value(musb->config->gpio_vrsel, 0);
 			/* Ignore VBUSERROR and SUSPEND IRQ */
@@ -228,7 +228,7 @@ static void musb_conn_timer_handler(unsigned long _musb)
 
 			val = MUSB_INTR_SUSPEND | MUSB_INTR_VBUSERROR;
 			musb_writeb(musb->mregs, MUSB_INTRUSB, val);
-			musb->xceiv->state = OTG_STATE_B_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 		}
 		mod_timer(&musb_conn_timer, jiffies + TIMER_DELAY);
 		break;
@@ -244,7 +244,7 @@ static void musb_conn_timer_handler(unsigned long _musb)
 
 		if (!(val & MUSB_DEVCTL_BDEVICE)) {
 			gpio_set_value(musb->config->gpio_vrsel, 1);
-			musb->xceiv->state = OTG_STATE_A_WAIT_BCON;
+			musb->xceiv->otg->state = OTG_STATE_A_WAIT_BCON;
 		} else {
 			gpio_set_value(musb->config->gpio_vrsel, 0);
 
@@ -279,13 +279,13 @@ static void musb_conn_timer_handler(unsigned long _musb)
 		break;
 	default:
 		dev_dbg(musb->controller, "%s state not handled\n",
-			usb_otg_state_string(musb->xceiv->state));
+			usb_otg_state_string(musb->xceiv->otg->state));
 		break;
 	}
 	spin_unlock_irqrestore(&musb->lock, flags);
 
 	dev_dbg(musb->controller, "state is %s\n",
-		usb_otg_state_string(musb->xceiv->state));
+		usb_otg_state_string(musb->xceiv->otg->state));
 }
 
 static void bfin_musb_enable(struct musb *musb)
@@ -306,7 +306,7 @@ static void bfin_musb_set_vbus(struct musb *musb, int is_on)
 
 	dev_dbg(musb->controller, "VBUS %s, devctl %02x "
 		/* otg %3x conf %08x prcm %08x */ "\n",
-		usb_otg_state_string(musb->xceiv->state),
+		usb_otg_state_string(musb->xceiv->otg->state),
 		musb_readb(musb->mregs, MUSB_DEVCTL));
 }
 
diff --git a/drivers/usb/musb/da8xx.c b/drivers/usb/musb/da8xx.c
index 17d600a46123..8b002968f8c5 100644
--- a/drivers/usb/musb/da8xx.c
+++ b/drivers/usb/musb/da8xx.c
@@ -197,20 +197,20 @@ static void otg_timer(unsigned long _musb)
 	 */
 	devctl = musb_readb(mregs, MUSB_DEVCTL);
 	dev_dbg(musb->controller, "Poll devctl %02x (%s)\n", devctl,
-		usb_otg_state_string(musb->xceiv->state));
+		usb_otg_state_string(musb->xceiv->otg->state));
 
 	spin_lock_irqsave(&musb->lock, flags);
-	switch (musb->xceiv->state) {
+	switch (musb->xceiv->otg->state) {
 	case OTG_STATE_A_WAIT_BCON:
 		devctl &= ~MUSB_DEVCTL_SESSION;
 		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
 
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 		if (devctl & MUSB_DEVCTL_BDEVICE) {
-			musb->xceiv->state = OTG_STATE_B_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 			MUSB_DEV_MODE(musb);
 		} else {
-			musb->xceiv->state = OTG_STATE_A_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_A_IDLE;
 			MUSB_HST_MODE(musb);
 		}
 		break;
@@ -225,7 +225,7 @@ static void otg_timer(unsigned long _musb)
 			mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 			break;
 		}
-		musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
+		musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
 		musb_writel(musb->ctrl_base, DA8XX_USB_INTR_SRC_SET_REG,
 			    MUSB_INTR_VBUSERROR << DA8XX_INTR_USB_SHIFT);
 		break;
@@ -247,7 +247,7 @@ static void otg_timer(unsigned long _musb)
 		if (devctl & MUSB_DEVCTL_BDEVICE)
 			mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 		else
-			musb->xceiv->state = OTG_STATE_A_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_A_IDLE;
 		break;
 	default:
 		break;
@@ -264,9 +264,9 @@ static void da8xx_musb_try_idle(struct musb *musb, unsigned long timeout)
 
 	/* Never idle if active, or when VBUS timeout is not set as host */
 	if (musb->is_active || (musb->a_wait_bcon == 0 &&
-				musb->xceiv->state == OTG_STATE_A_WAIT_BCON)) {
+				musb->xceiv->otg->state == OTG_STATE_A_WAIT_BCON)) {
 		dev_dbg(musb->controller, "%s active, deleting timer\n",
-			usb_otg_state_string(musb->xceiv->state));
+			usb_otg_state_string(musb->xceiv->otg->state));
 		del_timer(&otg_workaround);
 		last_timer = jiffies;
 		return;
@@ -279,7 +279,7 @@ static void da8xx_musb_try_idle(struct musb *musb, unsigned long timeout)
 	last_timer = timeout;
 
 	dev_dbg(musb->controller, "%s inactive, starting idle timer for %u ms\n",
-		usb_otg_state_string(musb->xceiv->state),
+		usb_otg_state_string(musb->xceiv->otg->state),
 		jiffies_to_msecs(timeout - jiffies));
 	mod_timer(&otg_workaround, timeout);
 }
@@ -340,26 +340,26 @@ static irqreturn_t da8xx_musb_interrupt(int irq, void *hci)
 			 * devctl.
 			 */
 			musb->int_usb &= ~MUSB_INTR_VBUSERROR;
-			musb->xceiv->state = OTG_STATE_A_WAIT_VFALL;
+			musb->xceiv->otg->state = OTG_STATE_A_WAIT_VFALL;
 			mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 			WARNING("VBUS error workaround (delay coming)\n");
 		} else if (drvvbus) {
 			MUSB_HST_MODE(musb);
 			otg->default_a = 1;
-			musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
+			musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
 			portstate(musb->port1_status |= USB_PORT_STAT_POWER);
 			del_timer(&otg_workaround);
 		} else {
 			musb->is_active = 0;
 			MUSB_DEV_MODE(musb);
 			otg->default_a = 0;
-			musb->xceiv->state = OTG_STATE_B_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 			portstate(musb->port1_status &= ~USB_PORT_STAT_POWER);
 		}
 
 		dev_dbg(musb->controller, "VBUS %s (%s)%s, devctl %02x\n",
 				drvvbus ? "on" : "off",
-				usb_otg_state_string(musb->xceiv->state),
+				usb_otg_state_string(musb->xceiv->otg->state),
 				err ? " ERROR" : "",
 				devctl);
 		ret = IRQ_HANDLED;
@@ -374,7 +374,7 @@ static irqreturn_t da8xx_musb_interrupt(int irq, void *hci)
 		musb_writel(reg_base, DA8XX_USB_END_OF_INTR_REG, 0);
 
 	/* Poll for ID change */
-	if (musb->xceiv->state == OTG_STATE_B_IDLE)
+	if (musb->xceiv->otg->state == OTG_STATE_B_IDLE)
 		mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 
 	spin_unlock_irqrestore(&musb->lock, flags);
diff --git a/drivers/usb/musb/davinci.c b/drivers/usb/musb/davinci.c
index e1a3d0272c11..36225c3297f5 100644
--- a/drivers/usb/musb/davinci.c
+++ b/drivers/usb/musb/davinci.c
@@ -214,10 +214,10 @@ static void otg_timer(unsigned long _musb)
 	 */
 	devctl = musb_readb(mregs, MUSB_DEVCTL);
 	dev_dbg(musb->controller, "poll devctl %02x (%s)\n", devctl,
-		usb_otg_state_string(musb->xceiv->state));
+		usb_otg_state_string(musb->xceiv->otg->state));
 
 	spin_lock_irqsave(&musb->lock, flags);
-	switch (musb->xceiv->state) {
+	switch (musb->xceiv->otg->state) {
 	case OTG_STATE_A_WAIT_VFALL:
 		/* Wait till VBUS falls below SessionEnd (~0.2V); the 1.3 RTL
 		 * seems to mis-handle session "start" otherwise (or in our
@@ -228,7 +228,7 @@ static void otg_timer(unsigned long _musb)
 			mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 			break;
 		}
-		musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
+		musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
 		musb_writel(musb->ctrl_base, DAVINCI_USB_INT_SET_REG,
 			MUSB_INTR_VBUSERROR << DAVINCI_USB_USBINT_SHIFT);
 		break;
@@ -251,7 +251,7 @@ static void otg_timer(unsigned long _musb)
 		if (devctl & MUSB_DEVCTL_BDEVICE)
 			mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 		else
-			musb->xceiv->state = OTG_STATE_A_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_A_IDLE;
 		break;
 	default:
 		break;
@@ -325,20 +325,20 @@ static irqreturn_t davinci_musb_interrupt(int irq, void *__hci)
 			 * to stop registering in devctl.
 			 */
 			musb->int_usb &= ~MUSB_INTR_VBUSERROR;
-			musb->xceiv->state = OTG_STATE_A_WAIT_VFALL;
+			musb->xceiv->otg->state = OTG_STATE_A_WAIT_VFALL;
 			mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 			WARNING("VBUS error workaround (delay coming)\n");
 		} else if (drvvbus) {
 			MUSB_HST_MODE(musb);
 			otg->default_a = 1;
-			musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
+			musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
 			portstate(musb->port1_status |= USB_PORT_STAT_POWER);
 			del_timer(&otg_workaround);
 		} else {
 			musb->is_active = 0;
 			MUSB_DEV_MODE(musb);
 			otg->default_a = 0;
-			musb->xceiv->state = OTG_STATE_B_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 			portstate(musb->port1_status &= ~USB_PORT_STAT_POWER);
 		}
 
@@ -348,7 +348,7 @@ static irqreturn_t davinci_musb_interrupt(int irq, void *__hci)
 		davinci_musb_source_power(musb, drvvbus, 0);
 		dev_dbg(musb->controller, "VBUS %s (%s)%s, devctl %02x\n",
 				drvvbus ? "on" : "off",
-				usb_otg_state_string(musb->xceiv->state),
+				usb_otg_state_string(musb->xceiv->otg->state),
 				err ? " ERROR" : "",
 				devctl);
 		retval = IRQ_HANDLED;
@@ -361,7 +361,7 @@ static irqreturn_t davinci_musb_interrupt(int irq, void *__hci)
 	musb_writel(tibase, DAVINCI_USB_EOI_REG, 0);
 
 	/* poll for ID change */
-	if (musb->xceiv->state == OTG_STATE_B_IDLE)
+	if (musb->xceiv->otg->state == OTG_STATE_B_IDLE)
 		mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 
 	spin_unlock_irqrestore(&musb->lock, flags);
* Unmerged path drivers/usb/musb/musb_core.c
* Unmerged path drivers/usb/musb/musb_dsps.c
* Unmerged path drivers/usb/musb/musb_gadget.c
* Unmerged path drivers/usb/musb/musb_host.c
* Unmerged path drivers/usb/musb/musb_virthub.c
diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 628b93fe5ccc..66b36bfa4d9d 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -64,15 +64,15 @@ static void musb_do_idle(unsigned long _musb)
 
 	spin_lock_irqsave(&musb->lock, flags);
 
-	switch (musb->xceiv->state) {
+	switch (musb->xceiv->otg->state) {
 	case OTG_STATE_A_WAIT_BCON:
 
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 		if (devctl & MUSB_DEVCTL_BDEVICE) {
-			musb->xceiv->state = OTG_STATE_B_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 			MUSB_DEV_MODE(musb);
 		} else {
-			musb->xceiv->state = OTG_STATE_A_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_A_IDLE;
 			MUSB_HST_MODE(musb);
 		}
 		break;
@@ -89,15 +89,15 @@ static void musb_do_idle(unsigned long _musb)
 			musb->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;
 			usb_hcd_poll_rh_status(musb_to_hcd(musb));
 			/* NOTE: it might really be A_WAIT_BCON ... */
-			musb->xceiv->state = OTG_STATE_A_HOST;
+			musb->xceiv->otg->state = OTG_STATE_A_HOST;
 		}
 		break;
 	case OTG_STATE_A_HOST:
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 		if (devctl &  MUSB_DEVCTL_BDEVICE)
-			musb->xceiv->state = OTG_STATE_B_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 		else
-			musb->xceiv->state = OTG_STATE_A_WAIT_BCON;
+			musb->xceiv->otg->state = OTG_STATE_A_WAIT_BCON;
 	default:
 		break;
 	}
@@ -115,9 +115,9 @@ static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
 
 	/* Never idle if active, or when VBUS timeout is not set as host */
 	if (musb->is_active || ((musb->a_wait_bcon == 0)
-			&& (musb->xceiv->state == OTG_STATE_A_WAIT_BCON))) {
+			&& (musb->xceiv->otg->state == OTG_STATE_A_WAIT_BCON))) {
 		dev_dbg(musb->controller, "%s active, deleting timer\n",
-			usb_otg_state_string(musb->xceiv->state));
+			usb_otg_state_string(musb->xceiv->otg->state));
 		del_timer(&musb_idle_timer);
 		last_timer = jiffies;
 		return;
@@ -134,7 +134,7 @@ static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
 	last_timer = timeout;
 
 	dev_dbg(musb->controller, "%s inactive, for idle timer for %lu ms\n",
-		usb_otg_state_string(musb->xceiv->state),
+		usb_otg_state_string(musb->xceiv->otg->state),
 		(unsigned long)jiffies_to_msecs(timeout - jiffies));
 	mod_timer(&musb_idle_timer, timeout);
 }
@@ -152,7 +152,7 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 
 	if (is_on) {
-		if (musb->xceiv->state == OTG_STATE_A_IDLE) {
+		if (musb->xceiv->otg->state == OTG_STATE_A_IDLE) {
 			int loops = 100;
 			/* start the session */
 			devctl |= MUSB_DEVCTL_SESSION;
@@ -178,7 +178,7 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 		} else {
 			musb->is_active = 1;
 			otg->default_a = 1;
-			musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
+			musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
 			devctl |= MUSB_DEVCTL_SESSION;
 			MUSB_HST_MODE(musb);
 		}
@@ -190,7 +190,7 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 		 */
 
 		otg->default_a = 0;
-		musb->xceiv->state = OTG_STATE_B_IDLE;
+		musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 		devctl &= ~MUSB_DEVCTL_SESSION;
 
 		MUSB_DEV_MODE(musb);
@@ -199,7 +199,7 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 
 	dev_dbg(musb->controller, "VBUS %s, devctl %02x "
 		/* otg %3x conf %08x prcm %08x */ "\n",
-		usb_otg_state_string(musb->xceiv->state),
+		usb_otg_state_string(musb->xceiv->otg->state),
 		musb_readb(musb->mregs, MUSB_DEVCTL));
 }
 
@@ -264,7 +264,7 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		dev_dbg(dev, "ID GND\n");
 
 		otg->default_a = true;
-		musb->xceiv->state = OTG_STATE_A_IDLE;
+		musb->xceiv->otg->state = OTG_STATE_A_IDLE;
 		musb->xceiv->last_event = USB_EVENT_ID;
 		if (musb->gadget_driver) {
 			pm_runtime_get_sync(dev);
@@ -278,7 +278,7 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		dev_dbg(dev, "VBUS Connect\n");
 
 		otg->default_a = false;
-		musb->xceiv->state = OTG_STATE_B_IDLE;
+		musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 		musb->xceiv->last_event = USB_EVENT_VBUS;
 		if (musb->gadget_driver)
 			pm_runtime_get_sync(dev);
diff --git a/drivers/usb/musb/tusb6010.c b/drivers/usb/musb/tusb6010.c
index 709d4364825f..f8b454ff8cac 100644
--- a/drivers/usb/musb/tusb6010.c
+++ b/drivers/usb/musb/tusb6010.c
@@ -416,13 +416,13 @@ static void musb_do_idle(unsigned long _musb)
 
 	spin_lock_irqsave(&musb->lock, flags);
 
-	switch (musb->xceiv->state) {
+	switch (musb->xceiv->otg->state) {
 	case OTG_STATE_A_WAIT_BCON:
 		if ((musb->a_wait_bcon != 0)
 			&& (musb->idle_timeout == 0
 				|| time_after(jiffies, musb->idle_timeout))) {
 			dev_dbg(musb->controller, "Nothing connected %s, turning off VBUS\n",
-					usb_otg_state_string(musb->xceiv->state));
+					usb_otg_state_string(musb->xceiv->otg->state));
 		}
 		/* FALLTHROUGH */
 	case OTG_STATE_A_IDLE:
@@ -475,9 +475,9 @@ static void tusb_musb_try_idle(struct musb *musb, unsigned long timeout)
 
 	/* Never idle if active, or when VBUS timeout is not set as host */
 	if (musb->is_active || ((musb->a_wait_bcon == 0)
-			&& (musb->xceiv->state == OTG_STATE_A_WAIT_BCON))) {
+			&& (musb->xceiv->otg->state == OTG_STATE_A_WAIT_BCON))) {
 		dev_dbg(musb->controller, "%s active, deleting timer\n",
-			usb_otg_state_string(musb->xceiv->state));
+			usb_otg_state_string(musb->xceiv->otg->state));
 		del_timer(&musb_idle_timer);
 		last_timer = jiffies;
 		return;
@@ -494,7 +494,7 @@ static void tusb_musb_try_idle(struct musb *musb, unsigned long timeout)
 	last_timer = timeout;
 
 	dev_dbg(musb->controller, "%s inactive, for idle timer for %lu ms\n",
-		usb_otg_state_string(musb->xceiv->state),
+		usb_otg_state_string(musb->xceiv->otg->state),
 		(unsigned long)jiffies_to_msecs(timeout - jiffies));
 	mod_timer(&musb_idle_timer, timeout);
 }
@@ -525,7 +525,7 @@ static void tusb_musb_set_vbus(struct musb *musb, int is_on)
 	if (is_on) {
 		timer = OTG_TIMER_MS(OTG_TIME_A_WAIT_VRISE);
 		otg->default_a = 1;
-		musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
+		musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
 		devctl |= MUSB_DEVCTL_SESSION;
 
 		conf |= TUSB_DEV_CONF_USB_HOST_MODE;
@@ -538,16 +538,16 @@ static void tusb_musb_set_vbus(struct musb *musb, int is_on)
 		/* If ID pin is grounded, we want to be a_idle */
 		otg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);
 		if (!(otg_stat & TUSB_DEV_OTG_STAT_ID_STATUS)) {
-			switch (musb->xceiv->state) {
+			switch (musb->xceiv->otg->state) {
 			case OTG_STATE_A_WAIT_VRISE:
 			case OTG_STATE_A_WAIT_BCON:
-				musb->xceiv->state = OTG_STATE_A_WAIT_VFALL;
+				musb->xceiv->otg->state = OTG_STATE_A_WAIT_VFALL;
 				break;
 			case OTG_STATE_A_WAIT_VFALL:
-				musb->xceiv->state = OTG_STATE_A_IDLE;
+				musb->xceiv->otg->state = OTG_STATE_A_IDLE;
 				break;
 			default:
-				musb->xceiv->state = OTG_STATE_A_IDLE;
+				musb->xceiv->otg->state = OTG_STATE_A_IDLE;
 			}
 			musb->is_active = 0;
 			otg->default_a = 1;
@@ -555,7 +555,7 @@ static void tusb_musb_set_vbus(struct musb *musb, int is_on)
 		} else {
 			musb->is_active = 0;
 			otg->default_a = 0;
-			musb->xceiv->state = OTG_STATE_B_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 			MUSB_DEV_MODE(musb);
 		}
 
@@ -570,7 +570,7 @@ static void tusb_musb_set_vbus(struct musb *musb, int is_on)
 	musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
 
 	dev_dbg(musb->controller, "VBUS %s, devctl %02x otg %3x conf %08x prcm %08x\n",
-		usb_otg_state_string(musb->xceiv->state),
+		usb_otg_state_string(musb->xceiv->otg->state),
 		musb_readb(musb->mregs, MUSB_DEVCTL),
 		musb_readl(tbase, TUSB_DEV_OTG_STAT),
 		conf, prcm);
@@ -669,23 +669,23 @@ tusb_otg_ints(struct musb *musb, u32 int_src, void __iomem *tbase)
 
 			if (otg_stat & TUSB_DEV_OTG_STAT_SESS_END) {
 				dev_dbg(musb->controller, "Forcing disconnect (no interrupt)\n");
-				if (musb->xceiv->state != OTG_STATE_B_IDLE) {
+				if (musb->xceiv->otg->state != OTG_STATE_B_IDLE) {
 					/* INTR_DISCONNECT can hide... */
-					musb->xceiv->state = OTG_STATE_B_IDLE;
+					musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 					musb->int_usb |= MUSB_INTR_DISCONNECT;
 				}
 				musb->is_active = 0;
 			}
 			dev_dbg(musb->controller, "vbus change, %s, otg %03x\n",
-				usb_otg_state_string(musb->xceiv->state), otg_stat);
+				usb_otg_state_string(musb->xceiv->otg->state), otg_stat);
 			idle_timeout = jiffies + (1 * HZ);
 			schedule_work(&musb->irq_work);
 
 		} else /* A-dev state machine */ {
 			dev_dbg(musb->controller, "vbus change, %s, otg %03x\n",
-				usb_otg_state_string(musb->xceiv->state), otg_stat);
+				usb_otg_state_string(musb->xceiv->otg->state), otg_stat);
 
-			switch (musb->xceiv->state) {
+			switch (musb->xceiv->otg->state) {
 			case OTG_STATE_A_IDLE:
 				dev_dbg(musb->controller, "Got SRP, turning on VBUS\n");
 				musb_platform_set_vbus(musb, 1);
@@ -732,9 +732,9 @@ tusb_otg_ints(struct musb *musb, u32 int_src, void __iomem *tbase)
 		u8	devctl;
 
 		dev_dbg(musb->controller, "%s timer, %03x\n",
-			usb_otg_state_string(musb->xceiv->state), otg_stat);
+			usb_otg_state_string(musb->xceiv->otg->state), otg_stat);
 
-		switch (musb->xceiv->state) {
+		switch (musb->xceiv->otg->state) {
 		case OTG_STATE_A_WAIT_VRISE:
 			/* VBUS has probably been valid for a while now,
 			 * but may well have bounced out of range a bit
@@ -746,7 +746,7 @@ tusb_otg_ints(struct musb *musb, u32 int_src, void __iomem *tbase)
 					dev_dbg(musb->controller, "devctl %02x\n", devctl);
 					break;
 				}
-				musb->xceiv->state = OTG_STATE_A_WAIT_BCON;
+				musb->xceiv->otg->state = OTG_STATE_A_WAIT_BCON;
 				musb->is_active = 0;
 				idle_timeout = jiffies
 					+ msecs_to_jiffies(musb->a_wait_bcon);
diff --git a/drivers/usb/musb/ux500.c b/drivers/usb/musb/ux500.c
index f98d13e8f7af..11620c57d8fe 100644
--- a/drivers/usb/musb/ux500.c
+++ b/drivers/usb/musb/ux500.c
@@ -48,7 +48,7 @@ static void ux500_musb_set_vbus(struct musb *musb, int is_on)
 	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 
 	if (is_on) {
-		if (musb->xceiv->state == OTG_STATE_A_IDLE) {
+		if (musb->xceiv->otg->state == OTG_STATE_A_IDLE) {
 			/* start the session */
 			devctl |= MUSB_DEVCTL_SESSION;
 			musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
@@ -68,7 +68,7 @@ static void ux500_musb_set_vbus(struct musb *musb, int is_on)
 		} else {
 			musb->is_active = 1;
 			musb->xceiv->otg->default_a = 1;
-			musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
+			musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
 			devctl |= MUSB_DEVCTL_SESSION;
 			MUSB_HST_MODE(musb);
 		}
@@ -94,7 +94,7 @@ static void ux500_musb_set_vbus(struct musb *musb, int is_on)
 		mdelay(200);
 
 	dev_dbg(musb->controller, "VBUS %s, devctl %02x\n",
-		usb_otg_state_string(musb->xceiv->state),
+		usb_otg_state_string(musb->xceiv->otg->state),
 		musb_readb(musb->mregs, MUSB_DEVCTL));
 }
 
@@ -104,7 +104,7 @@ static int musb_otg_notifications(struct notifier_block *nb,
 	struct musb *musb = container_of(nb, struct musb, nb);
 
 	dev_dbg(musb->controller, "musb_otg_notifications %ld %s\n",
-			event, usb_otg_state_string(musb->xceiv->state));
+			event, usb_otg_state_string(musb->xceiv->otg->state));
 
 	switch (event) {
 	case UX500_MUSB_ID:
@@ -119,7 +119,7 @@ static int musb_otg_notifications(struct notifier_block *nb,
 		if (is_host_active(musb))
 			ux500_musb_set_vbus(musb, 0);
 		else
-			musb->xceiv->state = OTG_STATE_B_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 		break;
 	default:
 		dev_dbg(musb->controller, "ID float\n");
* Unmerged path drivers/usb/phy/phy-ab8500-usb.c
diff --git a/drivers/usb/phy/phy-fsl-usb.c b/drivers/usb/phy/phy-fsl-usb.c
index 9958f7609b9f..24cac66748d9 100644
--- a/drivers/usb/phy/phy-fsl-usb.c
+++ b/drivers/usb/phy/phy-fsl-usb.c
@@ -567,7 +567,7 @@ static int fsl_otg_set_host(struct usb_otg *otg, struct usb_bus *host)
 			/* Mini-A cable connected */
 			struct otg_fsm *fsm = &otg_dev->fsm;
 
-			otg->phy->state = OTG_STATE_UNDEFINED;
+			otg.state = OTG_STATE_UNDEFINED;
 			fsm->protocol = PROTO_UNDEF;
 		}
 	}
@@ -625,7 +625,7 @@ static int fsl_otg_set_power(struct usb_phy *phy, unsigned mA)
 {
 	if (!fsl_otg_dev)
 		return -ENODEV;
-	if (phy->state == OTG_STATE_B_PERIPHERAL)
+	if (phy->otg.state == OTG_STATE_B_PERIPHERAL)
 		pr_info("FSL OTG: Draw %d mA\n", mA);
 
 	return 0;
@@ -658,7 +658,7 @@ static int fsl_otg_start_srp(struct usb_otg *otg)
 {
 	struct fsl_otg *otg_dev;
 
-	if (!otg || otg->phy->state != OTG_STATE_B_IDLE)
+	if (!otg || otg.state != OTG_STATE_B_IDLE)
 		return -ENODEV;
 
 	otg_dev = container_of(otg->phy, struct fsl_otg, phy);
@@ -933,10 +933,10 @@ int usb_otg_start(struct platform_device *pdev)
 	 * Also: record initial state of ID pin
 	 */
 	if (fsl_readl(&p_otg->dr_mem_map->otgsc) & OTGSC_STS_USB_ID) {
-		p_otg->phy.state = OTG_STATE_UNDEFINED;
+		p_otg->phy->otg.state = OTG_STATE_UNDEFINED;
 		p_otg->fsm.id = 1;
 	} else {
-		p_otg->phy.state = OTG_STATE_A_IDLE;
+		p_otg->phy->otg.state = OTG_STATE_A_IDLE;
 		p_otg->fsm.id = 0;
 	}
 
diff --git a/drivers/usb/phy/phy-fsm-usb.c b/drivers/usb/phy/phy-fsm-usb.c
index 62aa5e160867..44147dc21800 100644
--- a/drivers/usb/phy/phy-fsm-usb.c
+++ b/drivers/usb/phy/phy-fsm-usb.c
@@ -116,10 +116,10 @@ void otg_leave_state(struct otg_fsm *fsm, enum usb_otg_state old_state)
 int otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)
 {
 	state_changed = 1;
-	if (fsm->otg->phy->state == new_state)
+	if (fsm->otg->state == new_state)
 		return 0;
 	VDBG("Set state: %s\n", usb_otg_state_string(new_state));
-	otg_leave_state(fsm, fsm->otg->phy->state);
+	otg_leave_state(fsm, fsm->otg->state);
 	switch (new_state) {
 	case OTG_STATE_B_IDLE:
 		otg_drv_vbus(fsm, 0);
@@ -220,7 +220,7 @@ int otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)
 		break;
 	}
 
-	fsm->otg->phy->state = new_state;
+	fsm->otg->state = new_state;
 	return 0;
 }
 
@@ -232,7 +232,7 @@ int otg_statemachine(struct otg_fsm *fsm)
 
 	spin_lock_irqsave(&fsm->lock, flags);
 
-	state = fsm->otg->phy->state;
+	state = fsm->otg->state;
 	state_changed = 0;
 	/* State machine state change judgement */
 
diff --git a/drivers/usb/phy/phy-gpio-vbus-usb.c b/drivers/usb/phy/phy-gpio-vbus-usb.c
index 8443335c2ea0..07f6e5bb8b34 100644
--- a/drivers/usb/phy/phy-gpio-vbus-usb.c
+++ b/drivers/usb/phy/phy-gpio-vbus-usb.c
@@ -121,7 +121,7 @@ static void gpio_vbus_work(struct work_struct *work)
 
 	if (vbus) {
 		status = USB_EVENT_VBUS;
-		gpio_vbus->phy.state = OTG_STATE_B_PERIPHERAL;
+		gpio_vbus->phy.otg->state = OTG_STATE_B_PERIPHERAL;
 		gpio_vbus->phy.last_event = status;
 		usb_gadget_vbus_connect(gpio_vbus->phy.otg->gadget);
 
@@ -143,7 +143,7 @@ static void gpio_vbus_work(struct work_struct *work)
 
 		usb_gadget_vbus_disconnect(gpio_vbus->phy.otg->gadget);
 		status = USB_EVENT_NONE;
-		gpio_vbus->phy.state = OTG_STATE_B_IDLE;
+		gpio_vbus->phy.otg->state = OTG_STATE_B_IDLE;
 		gpio_vbus->phy.last_event = status;
 
 		atomic_notifier_call_chain(&gpio_vbus->phy.notifier,
@@ -196,7 +196,7 @@ static int gpio_vbus_set_peripheral(struct usb_otg *otg,
 		set_vbus_draw(gpio_vbus, 0);
 
 		usb_gadget_vbus_disconnect(otg->gadget);
-		otg->phy->state = OTG_STATE_UNDEFINED;
+		otg->state = OTG_STATE_UNDEFINED;
 
 		otg->gadget = NULL;
 		return 0;
@@ -218,7 +218,7 @@ static int gpio_vbus_set_power(struct usb_phy *phy, unsigned mA)
 
 	gpio_vbus = container_of(phy, struct gpio_vbus_data, phy);
 
-	if (phy->state == OTG_STATE_B_PERIPHERAL)
+	if (phy->otg->state == OTG_STATE_B_PERIPHERAL)
 		set_vbus_draw(gpio_vbus, mA);
 	return 0;
 }
@@ -269,8 +269,8 @@ static int __init gpio_vbus_probe(struct platform_device *pdev)
 	gpio_vbus->phy.dev = gpio_vbus->dev;
 	gpio_vbus->phy.set_power = gpio_vbus_set_power;
 	gpio_vbus->phy.set_suspend = gpio_vbus_set_suspend;
-	gpio_vbus->phy.state = OTG_STATE_UNDEFINED;
 
+	gpio_vbus->phy.otg->state = OTG_STATE_UNDEFINED;
 	gpio_vbus->phy.otg->phy = &gpio_vbus->phy;
 	gpio_vbus->phy.otg->set_peripheral = gpio_vbus_set_peripheral;
 
* Unmerged path drivers/usb/phy/phy-isp1301-omap.c
* Unmerged path drivers/usb/phy/phy-msm-usb.c
diff --git a/drivers/usb/phy/phy-mv-usb.c b/drivers/usb/phy/phy-mv-usb.c
index d0e23ae9d2e6..f9d79b0ce9d3 100644
--- a/drivers/usb/phy/phy-mv-usb.c
+++ b/drivers/usb/phy/phy-mv-usb.c
@@ -337,68 +337,68 @@ static void mv_otg_update_state(struct mv_otg *mvotg)
 {
 	struct mv_otg_ctrl *otg_ctrl = &mvotg->otg_ctrl;
 	struct usb_phy *phy = &mvotg->phy;
-	int old_state = phy->state;
+	int old_state = mvotg->phy.otg->state;
 
 	switch (old_state) {
 	case OTG_STATE_UNDEFINED:
-		phy->state = OTG_STATE_B_IDLE;
+		mvotg->phy.otg->state = OTG_STATE_B_IDLE;
 		/* FALL THROUGH */
 	case OTG_STATE_B_IDLE:
 		if (otg_ctrl->id == 0)
-			phy->state = OTG_STATE_A_IDLE;
+			mvotg->phy.otg->state = OTG_STATE_A_IDLE;
 		else if (otg_ctrl->b_sess_vld)
-			phy->state = OTG_STATE_B_PERIPHERAL;
+			mvotg->phy.otg->state = OTG_STATE_B_PERIPHERAL;
 		break;
 	case OTG_STATE_B_PERIPHERAL:
 		if (!otg_ctrl->b_sess_vld || otg_ctrl->id == 0)
-			phy->state = OTG_STATE_B_IDLE;
+			mvotg->phy.otg->state = OTG_STATE_B_IDLE;
 		break;
 	case OTG_STATE_A_IDLE:
 		if (otg_ctrl->id)
-			phy->state = OTG_STATE_B_IDLE;
+			mvotg->phy.otg->state = OTG_STATE_B_IDLE;
 		else if (!(otg_ctrl->a_bus_drop) &&
 			 (otg_ctrl->a_bus_req || otg_ctrl->a_srp_det))
-			phy->state = OTG_STATE_A_WAIT_VRISE;
+			mvotg->phy.otg->state = OTG_STATE_A_WAIT_VRISE;
 		break;
 	case OTG_STATE_A_WAIT_VRISE:
 		if (otg_ctrl->a_vbus_vld)
-			phy->state = OTG_STATE_A_WAIT_BCON;
+			mvotg->phy.otg->state = OTG_STATE_A_WAIT_BCON;
 		break;
 	case OTG_STATE_A_WAIT_BCON:
 		if (otg_ctrl->id || otg_ctrl->a_bus_drop
 		    || otg_ctrl->a_wait_bcon_timeout) {
 			mv_otg_cancel_timer(mvotg, A_WAIT_BCON_TIMER);
 			mvotg->otg_ctrl.a_wait_bcon_timeout = 0;
-			phy->state = OTG_STATE_A_WAIT_VFALL;
+			mvotg->phy.otg->state = OTG_STATE_A_WAIT_VFALL;
 			otg_ctrl->a_bus_req = 0;
 		} else if (!otg_ctrl->a_vbus_vld) {
 			mv_otg_cancel_timer(mvotg, A_WAIT_BCON_TIMER);
 			mvotg->otg_ctrl.a_wait_bcon_timeout = 0;
-			phy->state = OTG_STATE_A_VBUS_ERR;
+			mvotg->phy.otg->state = OTG_STATE_A_VBUS_ERR;
 		} else if (otg_ctrl->b_conn) {
 			mv_otg_cancel_timer(mvotg, A_WAIT_BCON_TIMER);
 			mvotg->otg_ctrl.a_wait_bcon_timeout = 0;
-			phy->state = OTG_STATE_A_HOST;
+			mvotg->phy.otg->state = OTG_STATE_A_HOST;
 		}
 		break;
 	case OTG_STATE_A_HOST:
 		if (otg_ctrl->id || !otg_ctrl->b_conn
 		    || otg_ctrl->a_bus_drop)
-			phy->state = OTG_STATE_A_WAIT_BCON;
+			mvotg->phy.otg->state = OTG_STATE_A_WAIT_BCON;
 		else if (!otg_ctrl->a_vbus_vld)
-			phy->state = OTG_STATE_A_VBUS_ERR;
+			mvotg->phy.otg->state = OTG_STATE_A_VBUS_ERR;
 		break;
 	case OTG_STATE_A_WAIT_VFALL:
 		if (otg_ctrl->id
 		    || (!otg_ctrl->b_conn && otg_ctrl->a_sess_vld)
 		    || otg_ctrl->a_bus_req)
-			phy->state = OTG_STATE_A_IDLE;
+			mvotg->phy.otg->state = OTG_STATE_A_IDLE;
 		break;
 	case OTG_STATE_A_VBUS_ERR:
 		if (otg_ctrl->id || otg_ctrl->a_clr_err
 		    || otg_ctrl->a_bus_drop) {
 			otg_ctrl->a_clr_err = 0;
-			phy->state = OTG_STATE_A_WAIT_VFALL;
+			mvotg->phy.otg->state = OTG_STATE_A_WAIT_VFALL;
 		}
 		break;
 	default:
@@ -418,8 +418,8 @@ static void mv_otg_work(struct work_struct *work)
 run:
 	/* work queue is single thread, or we need spin_lock to protect */
 	phy = &mvotg->phy;
-	otg = phy->otg;
-	old_state = phy->state;
+	otg = mvotg->phy.otg;
+	old_state = otg->state;
 
 	if (!mvotg->active)
 		return;
@@ -427,12 +427,12 @@ run:
 	mv_otg_update_inputs(mvotg);
 	mv_otg_update_state(mvotg);
 
-	if (old_state != phy->state) {
+	if (old_state != mvotg->phy.otg->state) {
 		dev_info(&mvotg->pdev->dev, "change from state %s to %s\n",
 			 state_string[old_state],
-			 state_string[phy->state]);
+			 state_string[mvotg->phy.otg->state]);
 
-		switch (phy->state) {
+		switch (mvotg->phy.otg->state) {
 		case OTG_STATE_B_IDLE:
 			otg->default_a = 0;
 			if (old_state == OTG_STATE_B_PERIPHERAL)
@@ -543,8 +543,8 @@ set_a_bus_req(struct device *dev, struct device_attribute *attr,
 		return -1;
 
 	/* We will use this interface to change to A device */
-	if (mvotg->phy.state != OTG_STATE_B_IDLE
-	    && mvotg->phy.state != OTG_STATE_A_IDLE)
+	if (mvotg->phy.otg->state != OTG_STATE_B_IDLE
+	    && mvotg->phy.otg->state != OTG_STATE_A_IDLE)
 		return -1;
 
 	/* The clock may disabled and we need to set irq for ID detected */
@@ -715,9 +715,9 @@ static int mv_otg_probe(struct platform_device *pdev)
 	mvotg->phy.dev = &pdev->dev;
 	mvotg->phy.otg = otg;
 	mvotg->phy.label = driver_name;
-	mvotg->phy.state = OTG_STATE_UNDEFINED;
 
 	otg->phy = &mvotg->phy;
+	otg->state = OTG_STATE_UNDEFINED;
 	otg->set_host = mv_otg_set_host;
 	otg->set_peripheral = mv_otg_set_peripheral;
 	otg->set_vbus = mv_otg_set_vbus;
* Unmerged path drivers/usb/phy/phy-nop.c
diff --git a/drivers/usb/phy/phy-omap-usb2.c b/drivers/usb/phy/phy-omap-usb2.c
index 844ab68f08d0..da4d985bc454 100644
--- a/drivers/usb/phy/phy-omap-usb2.c
+++ b/drivers/usb/phy/phy-omap-usb2.c
@@ -75,11 +75,9 @@ static int omap_usb_start_srp(struct usb_otg *otg)
 
 static int omap_usb_set_host(struct usb_otg *otg, struct usb_bus *host)
 {
-	struct usb_phy	*phy = otg->phy;
-
 	otg->host = host;
 	if (!host)
-		phy->state = OTG_STATE_UNDEFINED;
+		otg->state = OTG_STATE_UNDEFINED;
 
 	return 0;
 }
@@ -87,11 +85,9 @@ static int omap_usb_set_host(struct usb_otg *otg, struct usb_bus *host)
 static int omap_usb_set_peripheral(struct usb_otg *otg,
 		struct usb_gadget *gadget)
 {
-	struct usb_phy	*phy = otg->phy;
-
 	otg->gadget = gadget;
 	if (!gadget)
-		phy->state = OTG_STATE_UNDEFINED;
+		otg->state = OTG_STATE_UNDEFINED;
 
 	return 0;
 }
* Unmerged path drivers/usb/phy/phy-tahvo.c
diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 154332b7c8c0..33d3480c9cda 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -18,6 +18,8 @@ struct usb_otg {
 	struct usb_bus		*host;
 	struct usb_gadget	*gadget;
 
+	enum usb_otg_state	state;
+
 	/* bind/unbind the host controller */
 	int	(*set_host)(struct usb_otg *otg, struct usb_bus *host);
 
diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index 353053a33f21..ac7d7913694f 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -77,7 +77,6 @@ struct usb_phy {
 	unsigned int		 flags;
 
 	enum usb_phy_type	type;
-	enum usb_otg_state	state;
 	enum usb_phy_events	last_event;
 
 	struct usb_otg		*otg;
