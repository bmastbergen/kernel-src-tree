nfs42: add CLONE xdr functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peng Tao <tao.peng@primarydata.com>
commit 36022770de6cf9a403c40a68712ed2d2ea2746be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/36022770.failed

xdr definitions per draft-ietf-nfsv4-minorversion2-38.txt

	Signed-off-by: Peng Tao <tao.peng@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 36022770de6cf9a403c40a68712ed2d2ea2746be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs42xdr.c
#	fs/nfs/nfs4xdr.c
#	include/linux/nfs4.h
#	include/linux/nfs_xdr.h
diff --cc fs/nfs/nfs42xdr.c
index 1a25b27248f2,0ca482a51e53..000000000000
--- a/fs/nfs/nfs42xdr.c
+++ b/fs/nfs/nfs42xdr.c
@@@ -22,6 -24,22 +22,25 @@@
  					 1 /* whence */ + \
  					 2 /* offset */ + \
  					 2 /* length */)
++<<<<<<< HEAD
++=======
+ #define encode_io_info_maxsz		4
+ #define encode_layoutstats_maxsz	(op_decode_hdr_maxsz + \
+ 					2 /* offset */ + \
+ 					2 /* length */ + \
+ 					encode_stateid_maxsz + \
+ 					encode_io_info_maxsz + \
+ 					encode_io_info_maxsz + \
+ 					1 /* opaque devaddr4 length */ + \
+ 					XDR_QUADLEN(PNFS_LAYOUTSTATS_MAXSIZE))
+ #define decode_layoutstats_maxsz	(op_decode_hdr_maxsz)
+ #define encode_clone_maxsz		(encode_stateid_maxsz + \
+ 					encode_stateid_maxsz + \
+ 					2 /* src offset */ + \
+ 					2 /* dst offset */ + \
+ 					2 /* count */)
+ #define decode_clone_maxsz		(op_decode_hdr_maxsz)
++>>>>>>> 36022770de6c (nfs42: add CLONE xdr functions)
  
  #define NFS4_enc_allocate_sz		(compound_encode_hdr_maxsz + \
  					 encode_putfh_maxsz + \
@@@ -45,7 -63,28 +64,32 @@@
  #define NFS4_dec_seek_sz		(compound_decode_hdr_maxsz + \
  					 decode_putfh_maxsz + \
  					 decode_seek_maxsz)
++<<<<<<< HEAD
 +
++=======
+ #define NFS4_enc_layoutstats_sz		(compound_encode_hdr_maxsz + \
+ 					 encode_sequence_maxsz + \
+ 					 encode_putfh_maxsz + \
+ 					 PNFS_LAYOUTSTATS_MAXDEV * encode_layoutstats_maxsz)
+ #define NFS4_dec_layoutstats_sz		(compound_decode_hdr_maxsz + \
+ 					 decode_sequence_maxsz + \
+ 					 decode_putfh_maxsz + \
+ 					 PNFS_LAYOUTSTATS_MAXDEV * decode_layoutstats_maxsz)
+ #define NFS4_enc_clone_sz		(compound_encode_hdr_maxsz + \
+ 					 encode_sequence_maxsz + \
+ 					 encode_putfh_maxsz + \
+ 					 encode_savefh_maxsz + \
+ 					 encode_putfh_maxsz + \
+ 					 encode_clone_maxsz + \
+ 					 encode_getattr_maxsz)
+ #define NFS4_dec_clone_sz		(compound_decode_hdr_maxsz + \
+ 					 decode_sequence_maxsz + \
+ 					 decode_putfh_maxsz + \
+ 					 decode_savefh_maxsz + \
+ 					 decode_putfh_maxsz + \
+ 					 decode_clone_maxsz + \
+ 					 decode_getattr_maxsz)
++>>>>>>> 36022770de6c (nfs42: add CLONE xdr functions)
  
  static void encode_fallocate(struct xdr_stream *xdr,
  			     struct nfs42_falloc_args *args)
@@@ -81,6 -120,48 +125,51 @@@ static void encode_seek(struct xdr_stre
  	encode_uint32(xdr, args->sa_what);
  }
  
++<<<<<<< HEAD
++=======
+ static void encode_layoutstats(struct xdr_stream *xdr,
+ 			       struct nfs42_layoutstat_args *args,
+ 			       struct nfs42_layoutstat_devinfo *devinfo,
+ 			       struct compound_hdr *hdr)
+ {
+ 	__be32 *p;
+ 
+ 	encode_op_hdr(xdr, OP_LAYOUTSTATS, decode_layoutstats_maxsz, hdr);
+ 	p = reserve_space(xdr, 8 + 8);
+ 	p = xdr_encode_hyper(p, devinfo->offset);
+ 	p = xdr_encode_hyper(p, devinfo->length);
+ 	encode_nfs4_stateid(xdr, &args->stateid);
+ 	p = reserve_space(xdr, 4*8 + NFS4_DEVICEID4_SIZE + 4);
+ 	p = xdr_encode_hyper(p, devinfo->read_count);
+ 	p = xdr_encode_hyper(p, devinfo->read_bytes);
+ 	p = xdr_encode_hyper(p, devinfo->write_count);
+ 	p = xdr_encode_hyper(p, devinfo->write_bytes);
+ 	p = xdr_encode_opaque_fixed(p, devinfo->dev_id.data,
+ 			NFS4_DEVICEID4_SIZE);
+ 	/* Encode layoutupdate4 */
+ 	*p++ = cpu_to_be32(devinfo->layout_type);
+ 	if (devinfo->layoutstats_encode != NULL)
+ 		devinfo->layoutstats_encode(xdr, args, devinfo);
+ 	else
+ 		encode_uint32(xdr, 0);
+ }
+ 
+ static void encode_clone(struct xdr_stream *xdr,
+ 			 struct nfs42_clone_args *args,
+ 			 struct compound_hdr *hdr)
+ {
+ 	__be32 *p;
+ 
+ 	encode_op_hdr(xdr, OP_CLONE, decode_clone_maxsz, hdr);
+ 	encode_nfs4_stateid(xdr, &args->src_stateid);
+ 	encode_nfs4_stateid(xdr, &args->dst_stateid);
+ 	p = reserve_space(xdr, 3*8);
+ 	p = xdr_encode_hyper(p, args->src_offset);
+ 	p = xdr_encode_hyper(p, args->dst_offset);
+ 	xdr_encode_hyper(p, args->count);
+ }
+ 
++>>>>>>> 36022770de6c (nfs42: add CLONE xdr functions)
  /*
   * Encode ALLOCATE request
   */
@@@ -137,6 -218,49 +226,52 @@@ static void nfs4_xdr_enc_seek(struct rp
  	encode_nops(&hdr);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Encode LAYOUTSTATS request
+  */
+ static void nfs4_xdr_enc_layoutstats(struct rpc_rqst *req,
+ 				     struct xdr_stream *xdr,
+ 				     struct nfs42_layoutstat_args *args)
+ {
+ 	int i;
+ 
+ 	struct compound_hdr hdr = {
+ 		.minorversion = nfs4_xdr_minorversion(&args->seq_args),
+ 	};
+ 
+ 	encode_compound_hdr(xdr, req, &hdr);
+ 	encode_sequence(xdr, &args->seq_args, &hdr);
+ 	encode_putfh(xdr, args->fh, &hdr);
+ 	WARN_ON(args->num_dev > PNFS_LAYOUTSTATS_MAXDEV);
+ 	for (i = 0; i < args->num_dev; i++)
+ 		encode_layoutstats(xdr, args, &args->devinfo[i], &hdr);
+ 	encode_nops(&hdr);
+ }
+ 
+ /*
+  * Encode CLONE request
+  */
+ static void nfs4_xdr_enc_clone(struct rpc_rqst *req,
+ 			       struct xdr_stream *xdr,
+ 			       struct nfs42_clone_args *args)
+ {
+ 	struct compound_hdr hdr = {
+ 		.minorversion = nfs4_xdr_minorversion(&args->seq_args),
+ 	};
+ 
+ 	encode_compound_hdr(xdr, req, &hdr);
+ 	encode_sequence(xdr, &args->seq_args, &hdr);
+ 	encode_putfh(xdr, args->src_fh, &hdr);
+ 	encode_savefh(xdr, &hdr);
+ 	encode_putfh(xdr, args->dst_fh, &hdr);
+ 	encode_clone(xdr, args, &hdr);
+ 	encode_getfattr(xdr, args->dst_bitmask, &hdr);
+ 	encode_nops(&hdr);
+ }
+ 
++>>>>>>> 36022770de6c (nfs42: add CLONE xdr functions)
  static int decode_allocate(struct xdr_stream *xdr, struct nfs42_falloc_res *res)
  {
  	return decode_op_hdr(xdr, OP_ALLOCATE);
@@@ -169,6 -293,16 +304,19 @@@ out_overflow
  	return -EIO;
  }
  
++<<<<<<< HEAD
++=======
+ static int decode_layoutstats(struct xdr_stream *xdr)
+ {
+ 	return decode_op_hdr(xdr, OP_LAYOUTSTATS);
+ }
+ 
+ static int decode_clone(struct xdr_stream *xdr)
+ {
+ 	return decode_op_hdr(xdr, OP_CLONE);
+ }
+ 
++>>>>>>> 36022770de6c (nfs42: add CLONE xdr functions)
  /*
   * Decode ALLOCATE request
   */
@@@ -246,4 -380,70 +394,73 @@@ static int nfs4_xdr_dec_seek(struct rpc
  out:
  	return status;
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Decode LAYOUTSTATS request
+  */
+ static int nfs4_xdr_dec_layoutstats(struct rpc_rqst *rqstp,
+ 				    struct xdr_stream *xdr,
+ 				    struct nfs42_layoutstat_res *res)
+ {
+ 	struct compound_hdr hdr;
+ 	int status, i;
+ 
+ 	status = decode_compound_hdr(xdr, &hdr);
+ 	if (status)
+ 		goto out;
+ 	status = decode_sequence(xdr, &res->seq_res, rqstp);
+ 	if (status)
+ 		goto out;
+ 	status = decode_putfh(xdr);
+ 	if (status)
+ 		goto out;
+ 	WARN_ON(res->num_dev > PNFS_LAYOUTSTATS_MAXDEV);
+ 	for (i = 0; i < res->num_dev; i++) {
+ 		status = decode_layoutstats(xdr);
+ 		if (status)
+ 			goto out;
+ 	}
+ out:
+ 	res->rpc_status = status;
+ 	return status;
+ }
+ 
+ /*
+  * Decode CLONE request
+  */
+ static int nfs4_xdr_dec_clone(struct rpc_rqst *rqstp,
+ 			      struct xdr_stream *xdr,
+ 			      struct nfs42_clone_res *res)
+ {
+ 	struct compound_hdr hdr;
+ 	int status;
+ 
+ 	status = decode_compound_hdr(xdr, &hdr);
+ 	if (status)
+ 		goto out;
+ 	status = decode_sequence(xdr, &res->seq_res, rqstp);
+ 	if (status)
+ 		goto out;
+ 	status = decode_putfh(xdr);
+ 	if (status)
+ 		goto out;
+ 	status = decode_savefh(xdr);
+ 	if (status)
+ 		goto out;
+ 	status = decode_putfh(xdr);
+ 	if (status)
+ 		goto out;
+ 	status = decode_clone(xdr);
+ 	if (status)
+ 		goto out;
+ 	status = decode_getfattr(xdr, res->dst_fattr, res->server);
+ 
+ out:
+ 	res->rpc_status = status;
+ 	return status;
+ }
+ 
++>>>>>>> 36022770de6c (nfs42: add CLONE xdr functions)
  #endif /* __LINUX_FS_NFS_NFS4_2XDR_H */
diff --cc fs/nfs/nfs4xdr.c
index ffa00b3bb5f7,868472b6b303..000000000000
--- a/fs/nfs/nfs4xdr.c
+++ b/fs/nfs/nfs4xdr.c
@@@ -7462,6 -7464,8 +7462,11 @@@ struct rpc_procinfo	nfs4_procedures[] 
  	PROC(SEEK,		enc_seek,		dec_seek),
  	PROC(ALLOCATE,		enc_allocate,		dec_allocate),
  	PROC(DEALLOCATE,	enc_deallocate,		dec_deallocate),
++<<<<<<< HEAD
++=======
+ 	PROC(LAYOUTSTATS,	enc_layoutstats,	dec_layoutstats),
+ 	PROC(CLONE,		enc_clone,		dec_clone),
++>>>>>>> 36022770de6c (nfs42: add CLONE xdr functions)
  #endif /* CONFIG_NFS_V4_2 */
  };
  
diff --cc include/linux/nfs4.h
index 045b229d6943,c0c695b634d0..000000000000
--- a/include/linux/nfs4.h
+++ b/include/linux/nfs4.h
@@@ -495,6 -501,8 +496,11 @@@ enum 
  	NFSPROC4_CLNT_SEEK,
  	NFSPROC4_CLNT_ALLOCATE,
  	NFSPROC4_CLNT_DEALLOCATE,
++<<<<<<< HEAD
++=======
+ 	NFSPROC4_CLNT_LAYOUTSTATS,
+ 	NFSPROC4_CLNT_CLONE,
++>>>>>>> 36022770de6c (nfs42: add CLONE xdr functions)
  };
  
  /* nfs41 types */
diff --cc include/linux/nfs_xdr.h
index 7f0b503cd19d,ac678b7a65ed..000000000000
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@@ -316,6 -316,68 +316,71 @@@ struct nfs4_layoutreturn 
  	int rpc_status;
  };
  
++<<<<<<< HEAD
++=======
+ #define PNFS_LAYOUTSTATS_MAXSIZE 256
+ 
+ struct nfs42_layoutstat_args;
+ struct nfs42_layoutstat_devinfo;
+ typedef	void (*layoutstats_encode_t)(struct xdr_stream *,
+ 		struct nfs42_layoutstat_args *,
+ 		struct nfs42_layoutstat_devinfo *);
+ 
+ /* Per file per deviceid layoutstats */
+ struct nfs42_layoutstat_devinfo {
+ 	struct nfs4_deviceid dev_id;
+ 	__u64 offset;
+ 	__u64 length;
+ 	__u64 read_count;
+ 	__u64 read_bytes;
+ 	__u64 write_count;
+ 	__u64 write_bytes;
+ 	__u32 layout_type;
+ 	layoutstats_encode_t layoutstats_encode;
+ 	void *layout_private;
+ };
+ 
+ struct nfs42_layoutstat_args {
+ 	struct nfs4_sequence_args seq_args;
+ 	struct nfs_fh *fh;
+ 	struct inode *inode;
+ 	nfs4_stateid stateid;
+ 	int num_dev;
+ 	struct nfs42_layoutstat_devinfo *devinfo;
+ };
+ 
+ struct nfs42_layoutstat_res {
+ 	struct nfs4_sequence_res seq_res;
+ 	int num_dev;
+ 	int rpc_status;
+ };
+ 
+ struct nfs42_layoutstat_data {
+ 	struct inode *inode;
+ 	struct nfs42_layoutstat_args args;
+ 	struct nfs42_layoutstat_res res;
+ };
+ 
+ struct nfs42_clone_args {
+ 	struct nfs4_sequence_args	seq_args;
+ 	struct nfs_fh			*src_fh;
+ 	struct nfs_fh			*dst_fh;
+ 	nfs4_stateid			src_stateid;
+ 	nfs4_stateid			dst_stateid;
+ 	__u64				src_offset;
+ 	__u64				dst_offset;
+ 	__u64				count;
+ 	const u32			*dst_bitmask;
+ };
+ 
+ struct nfs42_clone_res {
+ 	struct nfs4_sequence_res	seq_res;
+ 	unsigned int			rpc_status;
+ 	struct nfs_fattr		*dst_fattr;
+ 	const struct nfs_server		*server;
+ };
+ 
++>>>>>>> 36022770de6c (nfs42: add CLONE xdr functions)
  struct stateowner_id {
  	__u64	create_time;
  	__u32	uniquifier;
* Unmerged path fs/nfs/nfs42xdr.c
* Unmerged path fs/nfs/nfs4xdr.c
* Unmerged path include/linux/nfs4.h
* Unmerged path include/linux/nfs_xdr.h
