devm_memremap_pages: fix vmem_altmap lifetime + alignment handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit eb7d78c9e7f6418932bd5fbee45eb46d5ab05002
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/eb7d78c9.failed

to_vmem_altmap() needs to return valid results until
arch_remove_memory() completes.  It also needs to be valid for any pfn
in a section regardless of whether that pfn maps to data.  This escape
was a result of a bug in the unit test.

The signature of this bug is that free_pagetable() fails to retrieve a
vmem_altmap and goes off into the weeds:

 BUG: unable to handle kernel NULL pointer dereference at           (null)
 IP: [<ffffffff811d2629>] get_pfnblock_flags_mask+0x49/0x60
 [..]
 Call Trace:
  [<ffffffff811d3477>] free_hot_cold_page+0x97/0x1d0
  [<ffffffff811d367a>] __free_pages+0x2a/0x40
  [<ffffffff8191e669>] free_pagetable+0x8c/0xd4
  [<ffffffff8191ef4e>] remove_pagetable+0x37a/0x808
  [<ffffffff8191b210>] vmemmap_free+0x10/0x20

Fixes: 4b94ffdc4163 ("x86, mm: introduce vmem_altmap to augment vmemmap_populate()")
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Reported-by: Jeff Moyer <jmoyer@redhat.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit eb7d78c9e7f6418932bd5fbee45eb46d5ab05002)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/memremap.c
diff --cc kernel/memremap.c
index 26717809cbd2,cbc3e97e2bb4..000000000000
--- a/kernel/memremap.c
+++ b/kernel/memremap.c
@@@ -144,3 -149,257 +144,260 @@@ void devm_memunmap(struct device *dev, 
  				devm_memremap_match, addr));
  }
  EXPORT_SYMBOL(devm_memunmap);
++<<<<<<< HEAD
++=======
+ 
+ pfn_t phys_to_pfn_t(dma_addr_t addr, unsigned long flags)
+ {
+ 	return __pfn_to_pfn_t(addr >> PAGE_SHIFT, flags);
+ }
+ EXPORT_SYMBOL(phys_to_pfn_t);
+ 
+ #ifdef CONFIG_ZONE_DEVICE
+ static DEFINE_MUTEX(pgmap_lock);
+ static RADIX_TREE(pgmap_radix, GFP_KERNEL);
+ #define SECTION_MASK ~((1UL << PA_SECTION_SHIFT) - 1)
+ #define SECTION_SIZE (1UL << PA_SECTION_SHIFT)
+ 
+ struct page_map {
+ 	struct resource res;
+ 	struct percpu_ref *ref;
+ 	struct dev_pagemap pgmap;
+ 	struct vmem_altmap altmap;
+ };
+ 
+ void get_zone_device_page(struct page *page)
+ {
+ 	percpu_ref_get(page->pgmap->ref);
+ }
+ EXPORT_SYMBOL(get_zone_device_page);
+ 
+ void put_zone_device_page(struct page *page)
+ {
+ 	put_dev_pagemap(page->pgmap);
+ }
+ EXPORT_SYMBOL(put_zone_device_page);
+ 
+ static void pgmap_radix_release(struct resource *res)
+ {
+ 	resource_size_t key, align_start, align_size, align_end;
+ 
+ 	align_start = res->start & ~(SECTION_SIZE - 1);
+ 	align_size = ALIGN(resource_size(res), SECTION_SIZE);
+ 	align_end = align_start + align_size - 1;
+ 
+ 	mutex_lock(&pgmap_lock);
+ 	for (key = res->start; key <= res->end; key += SECTION_SIZE)
+ 		radix_tree_delete(&pgmap_radix, key >> PA_SECTION_SHIFT);
+ 	mutex_unlock(&pgmap_lock);
+ }
+ 
+ static unsigned long pfn_first(struct page_map *page_map)
+ {
+ 	struct dev_pagemap *pgmap = &page_map->pgmap;
+ 	const struct resource *res = &page_map->res;
+ 	struct vmem_altmap *altmap = pgmap->altmap;
+ 	unsigned long pfn;
+ 
+ 	pfn = res->start >> PAGE_SHIFT;
+ 	if (altmap)
+ 		pfn += vmem_altmap_offset(altmap);
+ 	return pfn;
+ }
+ 
+ static unsigned long pfn_end(struct page_map *page_map)
+ {
+ 	const struct resource *res = &page_map->res;
+ 
+ 	return (res->start + resource_size(res)) >> PAGE_SHIFT;
+ }
+ 
+ #define for_each_device_pfn(pfn, map) \
+ 	for (pfn = pfn_first(map); pfn < pfn_end(map); pfn++)
+ 
+ static void devm_memremap_pages_release(struct device *dev, void *data)
+ {
+ 	struct page_map *page_map = data;
+ 	struct resource *res = &page_map->res;
+ 	resource_size_t align_start, align_size;
+ 	struct dev_pagemap *pgmap = &page_map->pgmap;
+ 
+ 	if (percpu_ref_tryget_live(pgmap->ref)) {
+ 		dev_WARN(dev, "%s: page mapping is still live!\n", __func__);
+ 		percpu_ref_put(pgmap->ref);
+ 	}
+ 
+ 	/* pages are dead and unused, undo the arch mapping */
+ 	align_start = res->start & ~(SECTION_SIZE - 1);
+ 	align_size = ALIGN(resource_size(res), SECTION_SIZE);
+ 	arch_remove_memory(align_start, align_size);
+ 	pgmap_radix_release(res);
+ 	dev_WARN_ONCE(dev, pgmap->altmap && pgmap->altmap->alloc,
+ 			"%s: failed to free all reserved pages\n", __func__);
+ }
+ 
+ /* assumes rcu_read_lock() held at entry */
+ struct dev_pagemap *find_dev_pagemap(resource_size_t phys)
+ {
+ 	struct page_map *page_map;
+ 
+ 	WARN_ON_ONCE(!rcu_read_lock_held());
+ 
+ 	page_map = radix_tree_lookup(&pgmap_radix, phys >> PA_SECTION_SHIFT);
+ 	return page_map ? &page_map->pgmap : NULL;
+ }
+ 
+ /**
+  * devm_memremap_pages - remap and provide memmap backing for the given resource
+  * @dev: hosting device for @res
+  * @res: "host memory" address range
+  * @ref: a live per-cpu reference count
+  * @altmap: optional descriptor for allocating the memmap from @res
+  *
+  * Notes:
+  * 1/ @ref must be 'live' on entry and 'dead' before devm_memunmap_pages() time
+  *    (or devm release event).
+  *
+  * 2/ @res is expected to be a host memory range that could feasibly be
+  *    treated as a "System RAM" range, i.e. not a device mmio range, but
+  *    this is not enforced.
+  */
+ void *devm_memremap_pages(struct device *dev, struct resource *res,
+ 		struct percpu_ref *ref, struct vmem_altmap *altmap)
+ {
+ 	int is_ram = region_intersects(res->start, resource_size(res),
+ 			"System RAM");
+ 	resource_size_t key, align_start, align_size, align_end;
+ 	struct dev_pagemap *pgmap;
+ 	struct page_map *page_map;
+ 	unsigned long pfn;
+ 	int error, nid;
+ 
+ 	if (is_ram == REGION_MIXED) {
+ 		WARN_ONCE(1, "%s attempted on mixed region %pr\n",
+ 				__func__, res);
+ 		return ERR_PTR(-ENXIO);
+ 	}
+ 
+ 	if (is_ram == REGION_INTERSECTS)
+ 		return __va(res->start);
+ 
+ 	if (altmap && !IS_ENABLED(CONFIG_SPARSEMEM_VMEMMAP)) {
+ 		dev_err(dev, "%s: altmap requires CONFIG_SPARSEMEM_VMEMMAP=y\n",
+ 				__func__);
+ 		return ERR_PTR(-ENXIO);
+ 	}
+ 
+ 	if (!ref)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	page_map = devres_alloc_node(devm_memremap_pages_release,
+ 			sizeof(*page_map), GFP_KERNEL, dev_to_node(dev));
+ 	if (!page_map)
+ 		return ERR_PTR(-ENOMEM);
+ 	pgmap = &page_map->pgmap;
+ 
+ 	memcpy(&page_map->res, res, sizeof(*res));
+ 
+ 	pgmap->dev = dev;
+ 	if (altmap) {
+ 		memcpy(&page_map->altmap, altmap, sizeof(*altmap));
+ 		pgmap->altmap = &page_map->altmap;
+ 	}
+ 	pgmap->ref = ref;
+ 	pgmap->res = &page_map->res;
+ 
+ 	mutex_lock(&pgmap_lock);
+ 	error = 0;
+ 	align_start = res->start & ~(SECTION_SIZE - 1);
+ 	align_size = ALIGN(resource_size(res), SECTION_SIZE);
+ 	align_end = align_start + align_size - 1;
+ 	for (key = align_start; key <= align_end; key += SECTION_SIZE) {
+ 		struct dev_pagemap *dup;
+ 
+ 		rcu_read_lock();
+ 		dup = find_dev_pagemap(key);
+ 		rcu_read_unlock();
+ 		if (dup) {
+ 			dev_err(dev, "%s: %pr collides with mapping for %s\n",
+ 					__func__, res, dev_name(dup->dev));
+ 			error = -EBUSY;
+ 			break;
+ 		}
+ 		error = radix_tree_insert(&pgmap_radix, key >> PA_SECTION_SHIFT,
+ 				page_map);
+ 		if (error) {
+ 			dev_err(dev, "%s: failed: %d\n", __func__, error);
+ 			break;
+ 		}
+ 	}
+ 	mutex_unlock(&pgmap_lock);
+ 	if (error)
+ 		goto err_radix;
+ 
+ 	nid = dev_to_node(dev);
+ 	if (nid < 0)
+ 		nid = numa_mem_id();
+ 
+ 	error = arch_add_memory(nid, align_start, align_size, true);
+ 	if (error)
+ 		goto err_add_memory;
+ 
+ 	for_each_device_pfn(pfn, page_map) {
+ 		struct page *page = pfn_to_page(pfn);
+ 
+ 		/* ZONE_DEVICE pages must never appear on a slab lru */
+ 		list_force_poison(&page->lru);
+ 		page->pgmap = pgmap;
+ 	}
+ 	devres_add(dev, page_map);
+ 	return __va(res->start);
+ 
+  err_add_memory:
+  err_radix:
+ 	pgmap_radix_release(res);
+ 	devres_free(page_map);
+ 	return ERR_PTR(error);
+ }
+ EXPORT_SYMBOL(devm_memremap_pages);
+ 
+ unsigned long vmem_altmap_offset(struct vmem_altmap *altmap)
+ {
+ 	/* number of pfns from base where pfn_to_page() is valid */
+ 	return altmap->reserve + altmap->free;
+ }
+ 
+ void vmem_altmap_free(struct vmem_altmap *altmap, unsigned long nr_pfns)
+ {
+ 	altmap->alloc -= nr_pfns;
+ }
+ 
+ #ifdef CONFIG_SPARSEMEM_VMEMMAP
+ struct vmem_altmap *to_vmem_altmap(unsigned long memmap_start)
+ {
+ 	/*
+ 	 * 'memmap_start' is the virtual address for the first "struct
+ 	 * page" in this range of the vmemmap array.  In the case of
+ 	 * CONFIG_SPARSE_VMEMMAP a page_to_pfn conversion is simple
+ 	 * pointer arithmetic, so we can perform this to_vmem_altmap()
+ 	 * conversion without concern for the initialization state of
+ 	 * the struct page fields.
+ 	 */
+ 	struct page *page = (struct page *) memmap_start;
+ 	struct dev_pagemap *pgmap;
+ 
+ 	/*
+ 	 * Uncoditionally retrieve a dev_pagemap associated with the
+ 	 * given physical address, this is only for use in the
+ 	 * arch_{add|remove}_memory() for setting up and tearing down
+ 	 * the memmap.
+ 	 */
+ 	rcu_read_lock();
+ 	pgmap = find_dev_pagemap(__pfn_to_phys(page_to_pfn(page)));
+ 	rcu_read_unlock();
+ 
+ 	return pgmap ? pgmap->altmap : NULL;
+ }
+ #endif /* CONFIG_SPARSEMEM_VMEMMAP */
+ #endif /* CONFIG_ZONE_DEVICE */
++>>>>>>> eb7d78c9e7f6 (devm_memremap_pages: fix vmem_altmap lifetime + alignment handling)
* Unmerged path kernel/memremap.c
