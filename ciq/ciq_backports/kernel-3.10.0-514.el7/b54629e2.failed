alx: Reset phy speed after resume

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author hahnjo <hahnjo@hahnjo.de>
commit b54629e226d196e802abdd30c5e34f2a47cddcf2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b54629e2.failed

This fixes bug 62491 (https://bugzilla.kernel.org/show_bug.cgi?id=62491).
After resuming some users got the following error flooding the kernel log:
alx 0000:02:00.0: invalid PHY speed/duplex: 0xffff

	Signed-off-by: Jonas Hahnfeld <linux@hahnjo.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b54629e226d196e802abdd30c5e34f2a47cddcf2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/atheros/alx/main.c
diff --cc drivers/net/ethernet/atheros/alx/main.c
index 67d8c3f44bb3,c3c4c266b846..000000000000
--- a/drivers/net/ethernet/atheros/alx/main.c
+++ b/drivers/net/ethernet/atheros/alx/main.c
@@@ -1462,48 -1388,22 +1462,54 @@@ static int alx_resume(struct device *de
  {
  	struct pci_dev *pdev = to_pci_dev(dev);
  	struct alx_priv *alx = pci_get_drvdata(pdev);
++<<<<<<< HEAD
 +	struct net_device *netdev = alx->dev;
 +	struct alx_hw *hw = &alx->hw;
 +	int err;
++=======
+ 	struct alx_hw *hw = &alx->hw;
+ 
+ 	alx_reset_phy(hw);
++>>>>>>> b54629e226d1 (alx: Reset phy speed after resume)
  
 -	if (!netif_running(alx->dev))
 -		return 0;
 -	netif_device_attach(alx->dev);
 -	return __alx_open(alx, true);
 -}
 +	pci_set_power_state(pdev, PCI_D0);
 +	pci_restore_state(pdev);
 +	pci_save_state(pdev);
  
 -static SIMPLE_DEV_PM_OPS(alx_pm_ops, alx_suspend, alx_resume);
 -#define ALX_PM_OPS      (&alx_pm_ops)
 -#else
 -#define ALX_PM_OPS      NULL
 -#endif
 +	pci_enable_wake(pdev, PCI_D3hot, 0);
 +	pci_enable_wake(pdev, PCI_D3cold, 0);
 +
 +	hw->link_speed = SPEED_UNKNOWN;
 +	alx->int_mask = ALX_ISR_MISC;
 +
 +	alx_reset_pcie(hw);
 +	alx_reset_phy(hw);
 +
 +	err = alx_reset_mac(hw);
 +	if (err) {
 +		netif_err(alx, hw, alx->dev,
 +			  "resume:reset_mac fail %d\n", err);
 +		return -EIO;
 +	}
  
 +	err = alx_setup_speed_duplex(hw, hw->adv_cfg, hw->flowctrl);
 +	if (err) {
 +		netif_err(alx, hw, alx->dev,
 +			  "resume:setup_speed_duplex fail %d\n", err);
 +		return -EIO;
 +	}
 +
 +	if (netif_running(netdev)) {
 +		err = __alx_open(alx, true);
 +		if (err)
 +			return err;
 +	}
 +
 +	netif_device_attach(netdev);
 +
 +	return err;
 +}
 +#endif
  
  static pci_ers_result_t alx_pci_error_detected(struct pci_dev *pdev,
  					       pci_channel_state_t state)
* Unmerged path drivers/net/ethernet/atheros/alx/main.c
