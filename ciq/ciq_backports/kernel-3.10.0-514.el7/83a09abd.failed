ipv6: Break up ip6_rt_copy()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit 83a09abd1a8badbbb715f928d07c65ac47709c47
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/83a09abd.failed

This patch breaks up ip6_rt_copy() into ip6_rt_copy_init() and
ip6_rt_cache_alloc().

In the later patch, we need to create a percpu rt6_info copy. Hence,
refactor the common rt6_info init codes to ip6_rt_copy_init().

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Cc: Steffen Klassert <steffen.klassert@secunet.com>
	Cc: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 83a09abd1a8badbbb715f928d07c65ac47709c47)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/route.c
diff --cc net/ipv6/route.c
index 1b3524b3978c,90c8eaa24565..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -1961,42 -2021,35 +1970,67 @@@ out
   *	Misc support functions
   */
  
++<<<<<<< HEAD
 +static struct rt6_info *ip6_rt_copy(struct rt6_info *ort,
 +				    const struct in6_addr *dest)
 +{
 +	struct net *net = dev_net(ort->dst.dev);
 +	struct rt6_info *rt = ip6_dst_alloc(net, ort->dst.dev, 0,
 +					    ort->rt6i_table);
 +
 +	if (rt) {
 +		rt->dst.input = ort->dst.input;
 +		rt->dst.output = ort->dst.output;
 +		rt->dst.flags |= DST_HOST;
 +
 +		rt->rt6i_dst.addr = *dest;
 +		rt->rt6i_dst.plen = 128;
 +		dst_copy_metrics(&rt->dst, &ort->dst);
 +		rt->dst.error = ort->dst.error;
 +		rt->rt6i_idev = ort->rt6i_idev;
 +		if (rt->rt6i_idev)
 +			in6_dev_hold(rt->rt6i_idev);
 +		rt->dst.lastuse = jiffies;
 +
 +		if (ort->rt6i_flags & RTF_GATEWAY)
 +			rt->rt6i_gateway = ort->rt6i_gateway;
 +		else
 +			rt->rt6i_gateway = *dest;
 +		rt->rt6i_flags = ort->rt6i_flags;
 +		rt6_set_from(rt, ort);
 +		rt->rt6i_metric = 0;
 +
++=======
+ static void rt6_set_from(struct rt6_info *rt, struct rt6_info *from)
+ {
+ 	BUG_ON(from->dst.from);
+ 
+ 	rt->rt6i_flags &= ~RTF_EXPIRES;
+ 	dst_hold(&from->dst);
+ 	rt->dst.from = &from->dst;
+ 	dst_init_metrics(&rt->dst, dst_metrics_ptr(&from->dst), true);
+ }
+ 
+ static void ip6_rt_copy_init(struct rt6_info *rt, struct rt6_info *ort)
+ {
+ 	rt->dst.input = ort->dst.input;
+ 	rt->dst.output = ort->dst.output;
+ 	rt->rt6i_dst = ort->rt6i_dst;
+ 	rt->dst.error = ort->dst.error;
+ 	rt->rt6i_idev = ort->rt6i_idev;
+ 	if (rt->rt6i_idev)
+ 		in6_dev_hold(rt->rt6i_idev);
+ 	rt->dst.lastuse = jiffies;
+ 	rt->rt6i_gateway = ort->rt6i_gateway;
+ 	rt->rt6i_flags = ort->rt6i_flags;
+ 	rt6_set_from(rt, ort);
+ 	rt->rt6i_metric = ort->rt6i_metric;
++>>>>>>> 83a09abd1a8b (ipv6: Break up ip6_rt_copy())
  #ifdef CONFIG_IPV6_SUBTREES
- 		memcpy(&rt->rt6i_src, &ort->rt6i_src, sizeof(struct rt6key));
+ 	rt->rt6i_src = ort->rt6i_src;
  #endif
- 		memcpy(&rt->rt6i_prefsrc, &ort->rt6i_prefsrc, sizeof(struct rt6key));
- 		rt->rt6i_table = ort->rt6i_table;
- 	}
- 	return rt;
+ 	rt->rt6i_prefsrc = ort->rt6i_prefsrc;
+ 	rt->rt6i_table = ort->rt6i_table;
  }
  
  #ifdef CONFIG_IPV6_ROUTE_INFO
* Unmerged path net/ipv6/route.c
