device property: Introduce firmware node type for platform data

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 16ba08d5c9ec44f89ec03c67ecf7a9c5e2d204fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/16ba08d5.failed

Introduce data structures and code allowing "built-in" properties
to be associated with devices in such a way that they will be used
by the device_property_* API if no proper firmware node (neither DT
nor ACPI) is present for the given device.

Each property is to be represented by a property_entry structure.
An array of property_entry structures (terminated with a null
entry) can be pointed to by the properties field of struct
property_set that can be added as a firmware node to a struct
device using device_add_property_set().  That will cause the
device_property_* API to use that property_set as the source
of properties if the given device does not have a DT node or
an ACPI companion device object associated with it.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 16ba08d5c9ec44f89ec03c67ecf7a9c5e2d204fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/property.c
#	include/linux/fwnode.h
#	include/linux/property.h
diff --cc drivers/base/property.c
index 6a94ef6e83c9,6a3f7d8af341..000000000000
--- a/drivers/base/property.c
+++ b/drivers/base/property.c
@@@ -10,11 -10,103 +10,97 @@@
   * published by the Free Software Foundation.
   */
  
- #include <linux/property.h>
- #include <linux/export.h>
  #include <linux/acpi.h>
+ #include <linux/export.h>
+ #include <linux/kernel.h>
  #include <linux/of.h>
+ #include <linux/property.h>
+ 
+ /**
+  * device_add_property_set - Add a collection of properties to a device object.
+  * @dev: Device to add properties to.
+  * @pset: Collection of properties to add.
+  *
+  * Associate a collection of device properties represented by @pset with @dev
+  * as its secondary firmware node.
+  */
+ void device_add_property_set(struct device *dev, struct property_set *pset)
+ {
+ 	if (pset)
+ 		pset->fwnode.type = FWNODE_PDATA;
+ 
+ 	set_secondary_fwnode(dev, &pset->fwnode);
+ }
+ EXPORT_SYMBOL_GPL(device_add_property_set);
+ 
+ static inline bool is_pset(struct fwnode_handle *fwnode)
+ {
+ 	return fwnode && fwnode->type == FWNODE_PDATA;
+ }
+ 
+ static inline struct property_set *to_pset(struct fwnode_handle *fwnode)
+ {
+ 	return is_pset(fwnode) ?
+ 		container_of(fwnode, struct property_set, fwnode) : NULL;
+ }
+ 
+ static struct property_entry *pset_prop_get(struct property_set *pset,
+ 					    const char *name)
+ {
+ 	struct property_entry *prop;
+ 
+ 	if (!pset || !pset->properties)
+ 		return NULL;
+ 
+ 	for (prop = pset->properties; prop->name; prop++)
+ 		if (!strcmp(name, prop->name))
+ 			return prop;
+ 
+ 	return NULL;
+ }
+ 
+ static int pset_prop_read_array(struct property_set *pset, const char *name,
+ 				enum dev_prop_type type, void *val, size_t nval)
+ {
+ 	struct property_entry *prop;
+ 	unsigned int item_size;
+ 
+ 	prop = pset_prop_get(pset, name);
+ 	if (!prop)
+ 		return -ENODATA;
+ 
+ 	if (prop->type != type)
+ 		return -EPROTO;
+ 
+ 	if (!val)
+ 		return prop->nval;
+ 
+ 	if (prop->nval < nval)
+ 		return -EOVERFLOW;
+ 
+ 	switch (type) {
+ 	case DEV_PROP_U8:
+ 		item_size = sizeof(u8);
+ 		break;
+ 	case DEV_PROP_U16:
+ 		item_size = sizeof(u16);
+ 		break;
+ 	case DEV_PROP_U32:
+ 		item_size = sizeof(u32);
+ 		break;
+ 	case DEV_PROP_U64:
+ 		item_size = sizeof(u64);
+ 		break;
+ 	case DEV_PROP_STRING:
+ 		item_size = sizeof(const char *);
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 	memcpy(val, prop->value.raw_data, nval * item_size);
+ 	return 0;
+ }
  
 -static inline struct fwnode_handle *dev_fwnode(struct device *dev)
 -{
 -	return IS_ENABLED(CONFIG_OF) && dev->of_node ?
 -		&dev->of_node->fwnode : dev->fwnode;
 -}
 -
  /**
   * device_property_present - check if a property of a device is present
   * @dev: Device whose property is being checked
@@@ -31,16 -120,21 +117,22 @@@ bool device_property_present(struct dev
  }
  EXPORT_SYMBOL_GPL(device_property_present);
  
 -/**
 - * fwnode_property_present - check if a property of a firmware node is present
 - * @fwnode: Firmware node whose property to check
 - * @propname: Name of the property
 - */
 -bool fwnode_property_present(struct fwnode_handle *fwnode, const char *propname)
 -{
 -	if (is_of_node(fwnode))
 -		return of_property_read_bool(of_node(fwnode), propname);
 -	else if (is_acpi_node(fwnode))
 -		return !acpi_dev_prop_get(acpi_node(fwnode), propname, NULL);
 +#define OF_DEV_PROP_READ_ARRAY(node, propname, type, val, nval) \
 +	(val) ? of_property_read_##type##_array((node), (propname), (val), (nval)) \
 +	      : of_property_count_elems_of_size((node), (propname), sizeof(type))
  
++<<<<<<< HEAD
 +#define DEV_PROP_READ_ARRAY(_dev_, _propname_, _type_, _proptype_, _val_, _nval_) \
 +	IS_ENABLED(CONFIG_OF) && _dev_->of_node ? \
 +		(OF_DEV_PROP_READ_ARRAY(_dev_->of_node, _propname_, _type_, \
 +					_val_, _nval_)) : \
 +		acpi_dev_prop_read(ACPI_COMPANION(_dev_), _propname_, \
 +				   _proptype_, _val_, _nval_)
++=======
+ 	return !!pset_prop_get(to_pset(fwnode), propname);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_present);
++>>>>>>> 16ba08d5c9ec (device property: Introduce firmware node type for platform data)
  
  /**
   * device_property_read_u8_array - return a u8 array property of a device
@@@ -177,9 -273,249 +269,255 @@@ EXPORT_SYMBOL_GPL(device_property_read_
  int device_property_read_string(struct device *dev, const char *propname,
  				const char **val)
  {
 -	return fwnode_property_read_string(dev_fwnode(dev), propname, val);
 +	return IS_ENABLED(CONFIG_OF) && dev->of_node ?
 +		of_property_read_string(dev->of_node, propname, val) :
 +		acpi_dev_prop_read(ACPI_COMPANION(dev), propname,
 +				   DEV_PROP_STRING, val, 1);
  }
  EXPORT_SYMBOL_GPL(device_property_read_string);
++<<<<<<< HEAD
++=======
+ 
+ #define OF_DEV_PROP_READ_ARRAY(node, propname, type, val, nval) \
+ 	(val) ? of_property_read_##type##_array((node), (propname), (val), (nval)) \
+ 	      : of_property_count_elems_of_size((node), (propname), sizeof(type))
+ 
+ #define FWNODE_PROP_READ_ARRAY(_fwnode_, _propname_, _type_, _proptype_, _val_, _nval_) \
+ ({ \
+ 	int _ret_; \
+ 	if (is_of_node(_fwnode_)) \
+ 		_ret_ = OF_DEV_PROP_READ_ARRAY(of_node(_fwnode_), _propname_, \
+ 					       _type_, _val_, _nval_); \
+ 	else if (is_acpi_node(_fwnode_)) \
+ 		_ret_ = acpi_dev_prop_read(acpi_node(_fwnode_), _propname_, \
+ 					   _proptype_, _val_, _nval_); \
+ 	else \
+ 		_ret_ = pset_prop_read_array(to_pset(_fwnode_), _propname_, \
+ 					     _proptype_, _val_, _nval_); \
+ 	_ret_; \
+ })
+ 
+ /**
+  * fwnode_property_read_u8_array - return a u8 array property of firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u8 properties with @propname from @fwnode and stores them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u8_array(struct fwnode_handle *fwnode,
+ 				  const char *propname, u8 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u8, DEV_PROP_U8,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u8_array);
+ 
+ /**
+  * fwnode_property_read_u16_array - return a u16 array property of firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u16 properties with @propname from @fwnode and store them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u16_array(struct fwnode_handle *fwnode,
+ 				   const char *propname, u16 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u16, DEV_PROP_U16,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u16_array);
+ 
+ /**
+  * fwnode_property_read_u32_array - return a u32 array property of firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u32 properties with @propname from @fwnode store them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u32_array(struct fwnode_handle *fwnode,
+ 				   const char *propname, u32 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u32, DEV_PROP_U32,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u32_array);
+ 
+ /**
+  * fwnode_property_read_u64_array - return a u64 array property firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u64 properties with @propname from @fwnode and store them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u64_array(struct fwnode_handle *fwnode,
+ 				   const char *propname, u64 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u64, DEV_PROP_U64,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u64_array);
+ 
+ /**
+  * fwnode_property_read_string_array - return string array property of a node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an string list property @propname from the given firmware node and store
+  * them to @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of strings,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_string_array(struct fwnode_handle *fwnode,
+ 				      const char *propname, const char **val,
+ 				      size_t nval)
+ {
+ 	if (is_of_node(fwnode))
+ 		return val ?
+ 			of_property_read_string_array(of_node(fwnode), propname,
+ 						      val, nval) :
+ 			of_property_count_strings(of_node(fwnode), propname);
+ 	else if (is_acpi_node(fwnode))
+ 		return acpi_dev_prop_read(acpi_node(fwnode), propname,
+ 					  DEV_PROP_STRING, val, nval);
+ 
+ 	return pset_prop_read_array(to_pset(fwnode), propname,
+ 				    DEV_PROP_STRING, val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_string_array);
+ 
+ /**
+  * fwnode_property_read_string - return a string property of a firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The value is stored here
+  *
+  * Read property @propname from the given firmware node and store the value into
+  * @val if found.  The value is checked to be a string.
+  *
+  * Return: %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO or %-EILSEQ if the property is not a string,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_string(struct fwnode_handle *fwnode,
+ 				const char *propname, const char **val)
+ {
+ 	if (is_of_node(fwnode))
+ 		return of_property_read_string(of_node(fwnode),propname, val);
+ 	else if (is_acpi_node(fwnode))
+ 		return acpi_dev_prop_read(acpi_node(fwnode), propname,
+ 					  DEV_PROP_STRING, val, 1);
+ 
+ 	return -ENXIO;
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_string);
+ 
+ /**
+  * device_get_next_child_node - Return the next child node handle for a device
+  * @dev: Device to find the next child node for.
+  * @child: Handle to one of the device's child nodes or a null handle.
+  */
+ struct fwnode_handle *device_get_next_child_node(struct device *dev,
+ 						 struct fwnode_handle *child)
+ {
+ 	if (IS_ENABLED(CONFIG_OF) && dev->of_node) {
+ 		struct device_node *node;
+ 
+ 		node = of_get_next_available_child(dev->of_node, of_node(child));
+ 		if (node)
+ 			return &node->fwnode;
+ 	} else if (IS_ENABLED(CONFIG_ACPI)) {
+ 		struct acpi_device *node;
+ 
+ 		node = acpi_get_next_child(dev, acpi_node(child));
+ 		if (node)
+ 			return acpi_fwnode_handle(node);
+ 	}
+ 	return NULL;
+ }
+ EXPORT_SYMBOL_GPL(device_get_next_child_node);
+ 
+ /**
+  * fwnode_handle_put - Drop reference to a device node
+  * @fwnode: Pointer to the device node to drop the reference to.
+  *
+  * This has to be used when terminating device_for_each_child_node() iteration
+  * with break or return to prevent stale device node references from being left
+  * behind.
+  */
+ void fwnode_handle_put(struct fwnode_handle *fwnode)
+ {
+ 	if (is_of_node(fwnode))
+ 		of_node_put(of_node(fwnode));
+ }
+ EXPORT_SYMBOL_GPL(fwnode_handle_put);
+ 
+ /**
+  * device_get_child_node_count - return the number of child nodes for device
+  * @dev: Device to cound the child nodes for
+  */
+ unsigned int device_get_child_node_count(struct device *dev)
+ {
+ 	struct fwnode_handle *child;
+ 	unsigned int count = 0;
+ 
+ 	device_for_each_child_node(dev, child)
+ 		count++;
+ 
+ 	return count;
+ }
+ EXPORT_SYMBOL_GPL(device_get_child_node_count);
++>>>>>>> 16ba08d5c9ec (device property: Introduce firmware node type for platform data)
diff --cc include/linux/property.h
index 9242fb0221ba,de8bdf417a35..000000000000
--- a/include/linux/property.h
+++ b/include/linux/property.h
@@@ -70,4 -101,67 +70,70 @@@ static inline int device_property_read_
  	return device_property_read_u64_array(dev, propname, val, 1);
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool fwnode_property_read_bool(struct fwnode_handle *fwnode,
+ 					     const char *propname)
+ {
+ 	return fwnode_property_present(fwnode, propname);
+ }
+ 
+ static inline int fwnode_property_read_u8(struct fwnode_handle *fwnode,
+ 					  const char *propname, u8 *val)
+ {
+ 	return fwnode_property_read_u8_array(fwnode, propname, val, 1);
+ }
+ 
+ static inline int fwnode_property_read_u16(struct fwnode_handle *fwnode,
+ 					   const char *propname, u16 *val)
+ {
+ 	return fwnode_property_read_u16_array(fwnode, propname, val, 1);
+ }
+ 
+ static inline int fwnode_property_read_u32(struct fwnode_handle *fwnode,
+ 					   const char *propname, u32 *val)
+ {
+ 	return fwnode_property_read_u32_array(fwnode, propname, val, 1);
+ }
+ 
+ static inline int fwnode_property_read_u64(struct fwnode_handle *fwnode,
+ 					   const char *propname, u64 *val)
+ {
+ 	return fwnode_property_read_u64_array(fwnode, propname, val, 1);
+ }
+ 
+ /**
+  * struct property_entry - "Built-in" device property representation.
+  * @name: Name of the property.
+  * @type: Type of the property.
+  * @nval: Number of items of type @type making up the value.
+  * @value: Value of the property (an array of @nval items of type @type).
+  */
+ struct property_entry {
+ 	const char *name;
+ 	enum dev_prop_type type;
+ 	size_t nval;
+ 	union {
+ 		void *raw_data;
+ 		u8 *u8_data;
+ 		u16 *u16_data;
+ 		u32 *u32_data;
+ 		u64 *u64_data;
+ 		const char **str;
+ 	} value;
+ };
+ 
+ /**
+  * struct property_set - Collection of "built-in" device properties.
+  * @fwnode: Handle to be pointed to by the fwnode field of struct device.
+  * @properties: Array of properties terminated with a null entry.
+  */
+ struct property_set {
+ 	struct fwnode_handle fwnode;
+ 	struct property_entry *properties;
+ };
+ 
+ void device_add_property_set(struct device *dev, struct property_set *pset);
+ 
++>>>>>>> 16ba08d5c9ec (device property: Introduce firmware node type for platform data)
  #endif /* _LINUX_PROPERTY_H_ */
* Unmerged path include/linux/fwnode.h
* Unmerged path drivers/base/property.c
* Unmerged path include/linux/fwnode.h
* Unmerged path include/linux/property.h
