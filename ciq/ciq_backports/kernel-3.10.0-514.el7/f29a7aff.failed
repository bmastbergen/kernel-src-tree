x86/mce: Avoid potential deadlock due to printk() in MCE context

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] mce: Avoid potential deadlock due to printk() in MCE context (Prarit Bhargava) [1301710]
Rebuild_FUZZ: 96.77%
commit-author Chen, Gong <gong.chen@linux.intel.com>
commit f29a7aff4bd60ebc3da4982f80144a4158c4c74a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f29a7aff.failed

Printing in MCE context is a no-no, currently, as printk() is
not NMI-safe. If some of the notifiers on the MCE chain call do
so, we may deadlock. In order to avoid that, delay printk() to
process context where it is safe.

	Reported-by: Xie XiuQi <xiexiuqi@huawei.com>
	Signed-off-by: Chen, Gong <gong.chen@linux.intel.com>
[ Fold in subsequent patch from Boris for early boot logging. ]
	Signed-off-by: Tony Luck <tony.luck@intel.com>
[ Kick irq_work in mce_log() directly. ]
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/1439396985-12812-6-git-send-email-bp@alien8.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit f29a7aff4bd60ebc3da4982f80144a4158c4c74a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/mcheck/mce.c
#	arch/x86/kernel/cpu/mcheck/mce_intel.c
diff --cc arch/x86/kernel/cpu/mcheck/mce.c
index 53f7039f68c9,9568bb55bfe2..000000000000
--- a/arch/x86/kernel/cpu/mcheck/mce.c
+++ b/arch/x86/kernel/cpu/mcheck/mce.c
@@@ -1138,15 -1120,9 +1139,21 @@@ void do_machine_check(struct pt_regs *r
  
  		mce_read_aux(&m, i);
  
++<<<<<<< HEAD
 +		/*
 +		 * Action optional error. Queue address for later processing.
 +		 * When the ring overflows we just ignore the AO error.
 +		 * RED-PEN add some logging mechanism when
 +		 * usable_address or mce_add_ring fails.
 +		 * RED-PEN don't ignore overflow for mca_cfg.tolerant == 0
 +		 */
 +		if (severity == MCE_AO_SEVERITY && mce_usable_address(&m))
 +			mce_ring_add(m.addr >> PAGE_SHIFT);
++=======
+ 		/* assuming valid severity level != 0 */
+ 		m.severity = severity;
+ 		m.usable_addr = mce_usable_address(&m);
++>>>>>>> f29a7aff4bd6 (x86/mce: Avoid potential deadlock due to printk() in MCE context)
  
  		mce_log(&m);
  
diff --cc arch/x86/kernel/cpu/mcheck/mce_intel.c
index 22cb89b9b3b6,70f567f774ed..000000000000
--- a/arch/x86/kernel/cpu/mcheck/mce_intel.c
+++ b/arch/x86/kernel/cpu/mcheck/mce_intel.c
@@@ -245,8 -245,7 +245,12 @@@ static void intel_threshold_interrupt(v
  	if (cmci_storm_detect())
  		return;
  
++<<<<<<< HEAD
 +	machine_check_poll(MCP_TIMESTAMP, &__get_cpu_var(mce_banks_owned));
 +	mce_notify_irq();
++=======
+ 	machine_check_poll(MCP_TIMESTAMP, this_cpu_ptr(&mce_banks_owned));
++>>>>>>> f29a7aff4bd6 (x86/mce: Avoid potential deadlock due to printk() in MCE context)
  }
  
  /*
diff --git a/arch/x86/kernel/cpu/mcheck/mce-apei.c b/arch/x86/kernel/cpu/mcheck/mce-apei.c
index a1aef9533154..34c89a3e8260 100644
--- a/arch/x86/kernel/cpu/mcheck/mce-apei.c
+++ b/arch/x86/kernel/cpu/mcheck/mce-apei.c
@@ -57,7 +57,6 @@ void apei_mce_report_mem_error(int severity, struct cper_sec_mem_err *mem_err)
 
 	m.addr = mem_err->physical_addr;
 	mce_log(&m);
-	mce_notify_irq();
 }
 EXPORT_SYMBOL_GPL(apei_mce_report_mem_error);
 
* Unmerged path arch/x86/kernel/cpu/mcheck/mce.c
* Unmerged path arch/x86/kernel/cpu/mcheck/mce_intel.c
