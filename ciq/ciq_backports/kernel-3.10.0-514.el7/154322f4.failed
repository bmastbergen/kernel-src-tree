mei: prevent unloading mei hw modules while the device is opened.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [misc] mei: prevent unloading mei hw modules while the device is opened (Jeremy McNicoll) [1273503]
Rebuild_FUZZ: 99.22%
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 154322f47376fed6ab1e4b350aa45fffa15a61aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/154322f4.failed

chrdev_open() increases reference counter on cdev->owner. Instead of
assigning the owner to mei subsystem, the owner has to be set to the
underlaying HW module (mei_me or mei_txe), so once the device is opened
the HW module cannot be unloaded.

	Cc: <stable@vger.kernel.org> #3.17+
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 154322f47376fed6ab1e4b350aa45fffa15a61aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/main.c
diff --cc drivers/misc/mei/main.c
index b23f9eba9e3a,e9513d651cd3..000000000000
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@@ -683,28 -630,94 +683,60 @@@ static const struct file_operations mei
  	.llseek = no_llseek
  };
  
 -static struct class *mei_class;
 -static dev_t mei_devt;
 -#define MEI_MAX_DEVS  MINORMASK
 -static DEFINE_MUTEX(mei_minor_lock);
 -static DEFINE_IDR(mei_idr);
 -
 -/**
 - * mei_minor_get - obtain next free device minor number
 - *
 - * @dev:  device pointer
 - *
 - * Return: allocated minor, or -ENOSPC if no free minor left
 +/*
 + * Misc Device Struct
   */
 -static int mei_minor_get(struct mei_device *dev)
 -{
 -	int ret;
 -
 -	mutex_lock(&mei_minor_lock);
 -	ret = idr_alloc(&mei_idr, dev, 0, MEI_MAX_DEVS, GFP_KERNEL);
 -	if (ret >= 0)
 -		dev->minor = ret;
 -	else if (ret == -ENOSPC)
 -		dev_err(dev->dev, "too many mei devices\n");
 -
 -	mutex_unlock(&mei_minor_lock);
 -	return ret;
 -}
 +static struct miscdevice  mei_misc_device = {
 +		.name = "mei",
 +		.fops = &mei_fops,
 +		.minor = MISC_DYNAMIC_MINOR,
 +};
  
 -/**
 - * mei_minor_free - mark device minor number as free
 - *
 - * @dev:  device pointer
 - */
 -static void mei_minor_free(struct mei_device *dev)
 -{
 -	mutex_lock(&mei_minor_lock);
 -	idr_remove(&mei_idr, dev->minor);
 -	mutex_unlock(&mei_minor_lock);
 -}
  
 -int mei_register(struct mei_device *dev, struct device *parent)
 +int mei_register(struct mei_device *dev)
  {
 -	struct device *clsdev; /* class device */
 -	int ret, devno;
 -
 -	ret = mei_minor_get(dev);
 -	if (ret < 0)
 +	int ret;
 +	mei_misc_device.parent = &dev->pdev->dev;
 +	ret = misc_register(&mei_misc_device);
 +	if (ret)
  		return ret;
  
++<<<<<<< HEAD
 +	if (mei_dbgfs_register(dev, mei_misc_device.name))
 +		dev_err(&dev->pdev->dev, "cannot register debugfs\n");
++=======
+ 	/* Fill in the data structures */
+ 	devno = MKDEV(MAJOR(mei_devt), dev->minor);
+ 	cdev_init(&dev->cdev, &mei_fops);
+ 	dev->cdev.owner = parent->driver->owner;
+ 
+ 	/* Add the device */
+ 	ret = cdev_add(&dev->cdev, devno, 1);
+ 	if (ret) {
+ 		dev_err(parent, "unable to add device %d:%d\n",
+ 			MAJOR(mei_devt), dev->minor);
+ 		goto err_dev_add;
+ 	}
+ 
+ 	clsdev = device_create_with_groups(mei_class, parent, devno,
+ 					   dev, mei_groups,
+ 					   "mei%d", dev->minor);
+ 
+ 	if (IS_ERR(clsdev)) {
+ 		dev_err(parent, "unable to create device %d:%d\n",
+ 			MAJOR(mei_devt), dev->minor);
+ 		ret = PTR_ERR(clsdev);
+ 		goto err_dev_create;
+ 	}
+ 
+ 	ret = mei_dbgfs_register(dev, dev_name(clsdev));
+ 	if (ret) {
+ 		dev_err(clsdev, "cannot register debugfs ret = %d\n", ret);
+ 		goto err_dev_dbgfs;
+ 	}
++>>>>>>> 154322f47376 (mei: prevent unloading mei hw modules while the device is opened.)
  
  	return 0;
 -
 -err_dev_dbgfs:
 -	device_destroy(mei_class, devno);
 -err_dev_create:
 -	cdev_del(&dev->cdev);
 -err_dev_add:
 -	mei_minor_free(dev);
 -	return ret;
  }
  EXPORT_SYMBOL_GPL(mei_register);
  
* Unmerged path drivers/misc/mei/main.c
