KVM: VMX: unify SECONDARY_VM_EXEC_CONTROL update

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xiao Guangrong <guangrong.xiao@linux.intel.com>
commit feda805fe7c4ed9cf78158e73b1218752e3b4314
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/feda805f.failed

Unify the update in vmx_cpuid_update()

	Signed-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
[Rewrite to use vmcs_set_secondary_exec_control. - Paolo]
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit feda805fe7c4ed9cf78158e73b1218752e3b4314)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index d1ae1d645663,a7a0ed6906fe..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -8378,16 -8695,19 +8397,32 @@@ static void vmx_cpuid_update(struct kvm
  
  	vmx->rdtscp_enabled = false;
  	if (vmx_rdtscp_supported()) {
++<<<<<<< HEAD
 +		exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);
 +		if (exec_control & SECONDARY_EXEC_RDTSCP) {
 +			best = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);
 +			if (best && (best->edx & bit(X86_FEATURE_RDTSCP)))
 +				vmx->rdtscp_enabled = true;
 +			else {
 +				exec_control &= ~SECONDARY_EXEC_RDTSCP;
 +				vmcs_write32(SECONDARY_VM_EXEC_CONTROL,
 +						exec_control);
 +			}
++=======
+ 		best = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);
+ 		if (best && (best->edx & bit(X86_FEATURE_RDTSCP)))
+ 			vmx->rdtscp_enabled = true;
+ 		else
+ 			secondary_exec_ctl &= ~SECONDARY_EXEC_RDTSCP;
+ 
+ 		if (nested) {
+ 			if (vmx->rdtscp_enabled)
+ 				vmx->nested.nested_vmx_secondary_ctls_high |=
+ 					SECONDARY_EXEC_RDTSCP;
+ 			else
+ 				vmx->nested.nested_vmx_secondary_ctls_high &=
+ 					~SECONDARY_EXEC_RDTSCP;
++>>>>>>> feda805fe7c4 (KVM: VMX: unify SECONDARY_VM_EXEC_CONTROL update)
  		}
  	}
  
@@@ -8403,6 -8721,17 +8436,20 @@@
  		if (best)
  			best->ebx &= ~bit(X86_FEATURE_INVPCID);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	vmcs_set_secondary_exec_control(secondary_exec_ctl);
+ 
+ 	if (static_cpu_has(X86_FEATURE_PCOMMIT) && nested) {
+ 		if (guest_cpuid_has_pcommit(vcpu))
+ 			vmx->nested.nested_vmx_secondary_ctls_high |=
+ 				SECONDARY_EXEC_PCOMMIT;
+ 		else
+ 			vmx->nested.nested_vmx_secondary_ctls_high &=
+ 				~SECONDARY_EXEC_PCOMMIT;
+ 	}
++>>>>>>> feda805fe7c4 (KVM: VMX: unify SECONDARY_VM_EXEC_CONTROL update)
  }
  
  static void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)
* Unmerged path arch/x86/kvm/vmx.c
