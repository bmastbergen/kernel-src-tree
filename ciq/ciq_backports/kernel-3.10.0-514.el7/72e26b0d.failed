ACPI: Move the window flag logic to the combined parser

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [acpi] Move the window flag logic to the combined parser (Myron Stowe) [1344513]
Rebuild_FUZZ: 94.23%
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 72e26b0d487fc494f40aa61e10a0757791e62e36
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/72e26b0d.failed

Normal memory and io resources have window always set to false. Move
the flag logic to the unified address space parser.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 72e26b0d487fc494f40aa61e10a0757791e62e36)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/resource.c
diff --cc drivers/acpi/resource.c
index 75d12a1b01ad,15d17937c431..000000000000
--- a/drivers/acpi/resource.c
+++ b/drivers/acpi/resource.c
@@@ -34,21 -34,34 +34,48 @@@
  #define valid_IRQ(i) (true)
  #endif
  
 -static bool acpi_dev_resource_len_valid(u64 start, u64 end, u64 len, bool io)
 +static unsigned long acpi_dev_memresource_flags(u64 len, u8 write_protect,
 +						bool window)
  {
 -	u64 reslen = end - start + 1;
 +	unsigned long flags = IORESOURCE_MEM;
  
++<<<<<<< HEAD
 +	if (len == 0)
 +		flags |= IORESOURCE_DISABLED;
 +
 +	if (write_protect == ACPI_READ_WRITE_MEMORY)
 +		flags |= IORESOURCE_MEM_WRITEABLE;
 +
 +	if (window)
 +		flags |= IORESOURCE_WINDOW;
 +
 +	return flags;
++=======
+ 	/*
+ 	 * CHECKME: len might be required to check versus a minimum
+ 	 * length as well. 1 for io is fine, but for memory it does
+ 	 * not make any sense at all.
+ 	 */
+ 	if (len && reslen && reslen == len && start <= end)
+ 		return true;
+ 
+ 	pr_info("ACPI: invalid or unassigned resource %s [%016llx - %016llx] length [%016llx]\n",
+ 		io ? "io" : "mem", start, end, len);
+ 
+ 	return false;
+ }
+ 
+ static void acpi_dev_memresource_flags(struct resource *res, u64 len,
+ 				       u8 write_protect)
+ {
+ 	res->flags = IORESOURCE_MEM;
+ 
+ 	if (!acpi_dev_resource_len_valid(res->start, res->end, len, false))
+ 		res->flags |= IORESOURCE_DISABLED;
+ 
+ 	if (write_protect == ACPI_READ_WRITE_MEMORY)
+ 		res->flags |= IORESOURCE_MEM_WRITEABLE;
++>>>>>>> 72e26b0d487f (ACPI: Move the window flag logic to the combined parser)
  }
  
  static void acpi_dev_get_memresource(struct resource *res, u64 start, u64 len,
@@@ -56,7 -69,7 +83,11 @@@
  {
  	res->start = start;
  	res->end = start + len - 1;
++<<<<<<< HEAD
 +	res->flags = acpi_dev_memresource_flags(len, write_protect, false);
++=======
+ 	acpi_dev_memresource_flags(res, len, write_protect);
++>>>>>>> 72e26b0d487f (ACPI: Move the window flag logic to the combined parser)
  }
  
  /**
@@@ -106,31 -114,27 +137,45 @@@ bool acpi_dev_resource_memory(struct ac
  }
  EXPORT_SYMBOL_GPL(acpi_dev_resource_memory);
  
++<<<<<<< HEAD
 +static unsigned int acpi_dev_ioresource_flags(u64 start, u64 end, u8 io_decode,
 +					      bool window)
++=======
+ static void acpi_dev_ioresource_flags(struct resource *res, u64 len,
+ 				      u8 io_decode)
++>>>>>>> 72e26b0d487f (ACPI: Move the window flag logic to the combined parser)
  {
 -	res->flags = IORESOURCE_IO;
 +	int flags = IORESOURCE_IO;
  
 -	if (!acpi_dev_resource_len_valid(res->start, res->end, len, true))
 -		res->flags |= IORESOURCE_DISABLED;
 +	if (io_decode == ACPI_DECODE_16)
++<<<<<<< HEAD
 +		flags |= IORESOURCE_IO_16BIT_ADDR;
  
 -	if (res->end >= 0x10003)
 -		res->flags |= IORESOURCE_DISABLED;
 +	if (start > end || end >= 0x10003)
 +		flags |= IORESOURCE_DISABLED;
  
 -	if (io_decode == ACPI_DECODE_16)
 +	if (window)
 +		flags |= IORESOURCE_WINDOW;
 +
 +	return flags;
++=======
+ 		res->flags |= IORESOURCE_IO_16BIT_ADDR;
++>>>>>>> 72e26b0d487f (ACPI: Move the window flag logic to the combined parser)
  }
  
  static void acpi_dev_get_ioresource(struct resource *res, u64 start, u64 len,
  				    u8 io_decode)
  {
 +	u64 end = start + len - 1;
 +
  	res->start = start;
++<<<<<<< HEAD
 +	res->end = end;
 +	res->flags = acpi_dev_ioresource_flags(start, end, io_decode, false);
++=======
+ 	res->end = start + len - 1;
+ 	acpi_dev_ioresource_flags(res, len, io_decode);
++>>>>>>> 72e26b0d487f (ACPI: Move the window flag logic to the combined parser)
  }
  
  /**
@@@ -171,6 -172,37 +216,40 @@@ bool acpi_dev_resource_io(struct acpi_r
  }
  EXPORT_SYMBOL_GPL(acpi_dev_resource_io);
  
++<<<<<<< HEAD
++=======
+ static bool acpi_decode_space(struct resource *res,
+ 			      struct acpi_resource_address *addr,
+ 			      struct acpi_address64_attribute *attr)
+ {
+ 	u8 iodec = attr->granularity == 0xfff ? ACPI_DECODE_10 : ACPI_DECODE_16;
+ 	bool wp = addr->info.mem.write_protect;
+ 	u64 len = attr->address_length;
+ 
+ 	res->start = attr->minimum;
+ 	res->end = attr->maximum;
+ 
+ 	switch (addr->resource_type) {
+ 	case ACPI_MEMORY_RANGE:
+ 		acpi_dev_memresource_flags(res, len, wp);
+ 		break;
+ 	case ACPI_IO_RANGE:
+ 		acpi_dev_ioresource_flags(res, len, iodec);
+ 		break;
+ 	case ACPI_BUS_NUMBER_RANGE:
+ 		res->flags = IORESOURCE_BUS;
+ 		break;
+ 	default:
+ 		return false;
+ 	}
+ 
+ 	if (addr->producer_consumer == ACPI_PRODUCER)
+ 		res->flags |= IORESOURCE_WINDOW;
+ 
+ 	return !(res->flags & IORESOURCE_DISABLED);
+ }
+ 
++>>>>>>> 72e26b0d487f (ACPI: Move the window flag logic to the combined parser)
  /**
   * acpi_dev_resource_address_space - Extract ACPI address space information.
   * @ares: Input ACPI resource object.
* Unmerged path drivers/acpi/resource.c
