dm: refactor ioctl handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit e56f81e0b01ef4e45292d8c1e19edd4d09724e14
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e56f81e0.failed

This moves the call to blkdev_ioctl and the argument checking to DM core
code, and only leaves a callout to find the block device to operate on
in the targets.  This simplifies the code and allows us to pass through
ioctl-like command using other methods in the next patch.

Also split out a helper around calling the prepare_ioctl method that
will be reused for persistent reservation handling.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit e56f81e0b01ef4e45292d8c1e19edd4d09724e14)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-flakey.c
#	drivers/md/dm-linear.c
#	drivers/md/dm-log-writes.c
#	drivers/md/dm-verity-target.c
#	include/linux/device-mapper.h
diff --cc drivers/md/dm-flakey.c
index c80a0ec5f126,09e2afcafd2d..000000000000
--- a/drivers/md/dm-flakey.c
+++ b/drivers/md/dm-flakey.c
@@@ -380,27 -384,11 +381,26 @@@ static int flakey_prepare_ioctl(struct 
  	 * Only pass ioctls through if the device sizes match exactly.
  	 */
  	if (fc->start ||
- 	    ti->len != i_size_read(dev->bdev->bd_inode) >> SECTOR_SHIFT)
- 		r = scsi_verify_blk_ioctl(NULL, cmd);
- 
- 	return r ? : __blkdev_driver_ioctl(dev->bdev, dev->mode, cmd, arg);
+ 	    ti->len != i_size_read((*bdev)->bd_inode) >> SECTOR_SHIFT)
+ 		return 1;
+ 	return 0;
  }
  
 +static int flakey_merge(struct dm_target *ti, struct bvec_merge_data *bvm,
 +			struct bio_vec *biovec, int max_size)
 +{
 +	struct flakey_c *fc = ti->private;
 +	struct request_queue *q = bdev_get_queue(fc->dev->bdev);
 +
 +	if (!q->merge_bvec_fn)
 +		return max_size;
 +
 +	bvm->bi_bdev = fc->dev->bdev;
 +	bvm->bi_sector = flakey_map_sector(ti, bvm->bi_sector);
 +
 +	return min(max_size, q->merge_bvec_fn(q, bvm, biovec));
 +}
 +
  static int flakey_iterate_devices(struct dm_target *ti, iterate_devices_callout_fn fn, void *data)
  {
  	struct flakey_c *fc = ti->private;
@@@ -417,8 -405,7 +417,12 @@@ static struct target_type flakey_targe
  	.map    = flakey_map,
  	.end_io = flakey_end_io,
  	.status = flakey_status,
++<<<<<<< HEAD
 +	.ioctl	= flakey_ioctl,
 +	.merge	= flakey_merge,
++=======
+ 	.prepare_ioctl = flakey_prepare_ioctl,
++>>>>>>> e56f81e0b01e (dm: refactor ioctl handling)
  	.iterate_devices = flakey_iterate_devices,
  };
  
diff --cc drivers/md/dm-linear.c
index 4f99d267340c,de52864d60fa..000000000000
--- a/drivers/md/dm-linear.c
+++ b/drivers/md/dm-linear.c
@@@ -124,26 -129,10 +125,25 @@@ static int linear_prepare_ioctl(struct 
  	 */
  	if (lc->start ||
  	    ti->len != i_size_read(dev->bdev->bd_inode) >> SECTOR_SHIFT)
- 		r = scsi_verify_blk_ioctl(NULL, cmd);
- 
- 	return r ? : __blkdev_driver_ioctl(dev->bdev, dev->mode, cmd, arg);
+ 		return 1;
+ 	return 0;
  }
  
 +static int linear_merge(struct dm_target *ti, struct bvec_merge_data *bvm,
 +			struct bio_vec *biovec, int max_size)
 +{
 +	struct linear_c *lc = ti->private;
 +	struct request_queue *q = bdev_get_queue(lc->dev->bdev);
 +
 +	if (!q->merge_bvec_fn)
 +		return max_size;
 +
 +	bvm->bi_bdev = lc->dev->bdev;
 +	bvm->bi_sector = linear_map_sector(ti, bvm->bi_sector);
 +
 +	return min(max_size, q->merge_bvec_fn(q, bvm, biovec));
 +}
 +
  static int linear_iterate_devices(struct dm_target *ti,
  				  iterate_devices_callout_fn fn, void *data)
  {
@@@ -160,8 -149,7 +160,12 @@@ static struct target_type linear_targe
  	.dtr    = linear_dtr,
  	.map    = linear_map,
  	.status = linear_status,
++<<<<<<< HEAD
 +	.ioctl  = linear_ioctl,
 +	.merge  = linear_merge,
++=======
+ 	.prepare_ioctl = linear_prepare_ioctl,
++>>>>>>> e56f81e0b01e (dm: refactor ioctl handling)
  	.iterate_devices = linear_iterate_devices,
  };
  
diff --cc drivers/md/dm-verity-target.c
index 0ec8b641792b,ccf41886ebcf..000000000000
--- a/drivers/md/dm-verity-target.c
+++ b/drivers/md/dm-verity-target.c
@@@ -665,27 -640,10 +666,25 @@@ static int verity_prepare_ioctl(struct 
  
  	if (v->data_start ||
  	    ti->len != i_size_read(v->data_dev->bdev->bd_inode) >> SECTOR_SHIFT)
- 		r = scsi_verify_blk_ioctl(NULL, cmd);
- 
- 	return r ? : __blkdev_driver_ioctl(v->data_dev->bdev, v->data_dev->mode,
- 				     cmd, arg);
+ 		return 1;
+ 	return 0;
  }
  
 +static int verity_merge(struct dm_target *ti, struct bvec_merge_data *bvm,
 +			struct bio_vec *biovec, int max_size)
 +{
 +	struct dm_verity *v = ti->private;
 +	struct request_queue *q = bdev_get_queue(v->data_dev->bdev);
 +
 +	if (!q->merge_bvec_fn)
 +		return max_size;
 +
 +	bvm->bi_bdev = v->data_dev->bdev;
 +	bvm->bi_sector = verity_map_sector(v, bvm->bi_sector);
 +
 +	return min(max_size, q->merge_bvec_fn(q, bvm, biovec));
 +}
 +
  static int verity_iterate_devices(struct dm_target *ti,
  				  iterate_devices_callout_fn fn, void *data)
  {
@@@ -1030,8 -964,7 +1029,12 @@@ static struct target_type verity_targe
  	.dtr		= verity_dtr,
  	.map		= verity_map,
  	.status		= verity_status,
++<<<<<<< HEAD:drivers/md/dm-verity-target.c
 +	.ioctl		= verity_ioctl,
 +	.merge		= verity_merge,
++=======
+ 	.prepare_ioctl	= verity_prepare_ioctl,
++>>>>>>> e56f81e0b01e (dm: refactor ioctl handling):drivers/md/dm-verity.c
  	.iterate_devices = verity_iterate_devices,
  	.io_hints	= verity_io_hints,
  };
diff --cc include/linux/device-mapper.h
index 0e7360cb97aa,ec1c61c87d89..000000000000
--- a/include/linux/device-mapper.h
+++ b/include/linux/device-mapper.h
@@@ -79,12 -79,9 +79,12 @@@ typedef void (*dm_status_fn) (struct dm
  
  typedef int (*dm_message_fn) (struct dm_target *ti, unsigned argc, char **argv);
  
- typedef int (*dm_ioctl_fn) (struct dm_target *ti, unsigned int cmd,
- 			    unsigned long arg);
+ typedef int (*dm_prepare_ioctl_fn) (struct dm_target *ti,
+ 			    struct block_device **bdev, fmode_t *mode);
  
 +typedef int (*dm_merge_fn) (struct dm_target *ti, struct bvec_merge_data *bvm,
 +			    struct bio_vec *biovec, int max_size);
 +
  /*
   * These iteration functions are typically used to check (and combine)
   * properties of underlying devices.
@@@ -159,8 -156,7 +159,12 @@@ struct target_type 
  	dm_resume_fn resume;
  	dm_status_fn status;
  	dm_message_fn message;
++<<<<<<< HEAD
 +	dm_ioctl_fn ioctl;
 +	dm_merge_fn merge;
++=======
+ 	dm_prepare_ioctl_fn prepare_ioctl;
++>>>>>>> e56f81e0b01e (dm: refactor ioctl handling)
  	dm_busy_fn busy;
  	dm_iterate_devices_fn iterate_devices;
  	dm_io_hints_fn io_hints;
* Unmerged path drivers/md/dm-log-writes.c
* Unmerged path drivers/md/dm-flakey.c
* Unmerged path drivers/md/dm-linear.c
* Unmerged path drivers/md/dm-log-writes.c
diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c
index 171cc541fd7a..97cf835cbb87 100644
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@ -1548,18 +1548,14 @@ out:
 	return r;
 }
 
-static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,
-			   unsigned long arg)
+static int multipath_prepare_ioctl(struct dm_target *ti,
+		struct block_device **bdev, fmode_t *mode)
 {
 	struct multipath *m = ti->private;
 	struct pgpath *pgpath;
-	struct block_device *bdev;
-	fmode_t mode;
 	unsigned long flags;
 	int r;
 
-	bdev = NULL;
-	mode = 0;
 	r = 0;
 
 	spin_lock_irqsave(&m->lock, flags);
@@ -1570,23 +1566,17 @@ static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,
 	pgpath = m->current_pgpath;
 
 	if (pgpath) {
-		bdev = pgpath->path.dev->bdev;
-		mode = pgpath->path.dev->mode;
+		*bdev = pgpath->path.dev->bdev;
+		*mode = pgpath->path.dev->mode;
 	}
 
 	if ((pgpath && m->queue_io) || (!pgpath && m->queue_if_no_path))
 		r = -ENOTCONN;
-	else if (!bdev)
+	else if (!*bdev)
 		r = -EIO;
 
 	spin_unlock_irqrestore(&m->lock, flags);
 
-	/*
-	 * Only pass ioctls through if the device sizes match exactly.
-	 */
-	if (!r && ti->len != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)
-		r = scsi_verify_blk_ioctl(NULL, cmd);
-
 	if (r == -ENOTCONN && !fatal_signal_pending(current)) {
 		spin_lock_irqsave(&m->lock, flags);
 		if (!m->current_pg) {
@@ -1599,7 +1589,12 @@ static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,
 		dm_table_run_md_queue_async(m->ti->table);
 	}
 
-	return r ? : __blkdev_driver_ioctl(bdev, mode, cmd, arg);
+	/*
+	 * Only pass ioctls through if the device sizes match exactly.
+	 */
+	if (!r && ti->len != i_size_read((*bdev)->bd_inode) >> SECTOR_SHIFT)
+		return 1;
+	return r;
 }
 
 static int multipath_iterate_devices(struct dm_target *ti,
@@ -1715,7 +1710,7 @@ static struct target_type multipath_target = {
 	.resume = multipath_resume,
 	.status = multipath_status,
 	.message = multipath_message,
-	.ioctl  = multipath_ioctl,
+	.prepare_ioctl = multipath_prepare_ioctl,
 	.iterate_devices = multipath_iterate_devices,
 	.busy = multipath_busy,
 };
diff --git a/drivers/md/dm-switch.c b/drivers/md/dm-switch.c
index 8af893bc7d78..c8952c871fe6 100644
--- a/drivers/md/dm-switch.c
+++ b/drivers/md/dm-switch.c
@@ -511,27 +511,24 @@ static void switch_status(struct dm_target *ti, status_type_t type,
  *
  * Passthrough all ioctls to the path for sector 0
  */
-static int switch_ioctl(struct dm_target *ti, unsigned cmd,
-			unsigned long arg)
+static int switch_prepare_ioctl(struct dm_target *ti,
+		struct block_device **bdev, fmode_t *mode)
 {
 	struct switch_ctx *sctx = ti->private;
-	struct block_device *bdev;
-	fmode_t mode;
 	unsigned path_nr;
-	int r = 0;
 
 	path_nr = switch_get_path_nr(sctx, 0);
 
-	bdev = sctx->path_list[path_nr].dmdev->bdev;
-	mode = sctx->path_list[path_nr].dmdev->mode;
+	*bdev = sctx->path_list[path_nr].dmdev->bdev;
+	*mode = sctx->path_list[path_nr].dmdev->mode;
 
 	/*
 	 * Only pass ioctls through if the device sizes match exactly.
 	 */
-	if (ti->len + sctx->path_list[path_nr].start != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)
-		r = scsi_verify_blk_ioctl(NULL, cmd);
-
-	return r ? : __blkdev_driver_ioctl(bdev, mode, cmd, arg);
+	if (ti->len + sctx->path_list[path_nr].start !=
+	    i_size_read((*bdev)->bd_inode) >> SECTOR_SHIFT)
+		return 1;
+	return 0;
 }
 
 static int switch_iterate_devices(struct dm_target *ti,
@@ -560,7 +557,7 @@ static struct target_type switch_target = {
 	.map = switch_map,
 	.message = switch_message,
 	.status = switch_status,
-	.ioctl = switch_ioctl,
+	.prepare_ioctl = switch_prepare_ioctl,
 	.iterate_devices = switch_iterate_devices,
 };
 
* Unmerged path drivers/md/dm-verity-target.c
diff --git a/drivers/md/dm.c b/drivers/md/dm.c
index 1ae4c46ecb57..937ed552df7e 100644
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@ -556,18 +556,16 @@ static int dm_blk_getgeo(struct block_device *bdev, struct hd_geometry *geo)
 	return dm_get_geometry(md, geo);
 }
 
-static int dm_blk_ioctl(struct block_device *bdev, fmode_t mode,
-			unsigned int cmd, unsigned long arg)
+static int dm_get_live_table_for_ioctl(struct mapped_device *md,
+		struct dm_target **tgt, struct block_device **bdev,
+		fmode_t *mode, int *srcu_idx)
 {
-	struct mapped_device *md = bdev->bd_disk->private_data;
-	int srcu_idx;
 	struct dm_table *map;
-	struct dm_target *tgt;
-	int r = -ENOTTY;
+	int r;
 
 retry:
-	map = dm_get_live_table(md, &srcu_idx);
-
+	r = -ENOTTY;
+	map = dm_get_live_table(md, srcu_idx);
 	if (!map || !dm_table_get_size(map))
 		goto out;
 
@@ -575,8 +573,9 @@ retry:
 	if (dm_table_get_num_targets(map) != 1)
 		goto out;
 
-	tgt = dm_table_get_target(map, 0);
-	if (!tgt->type->ioctl)
+	*tgt = dm_table_get_target(map, 0);
+
+	if (!(*tgt)->type->prepare_ioctl)
 		goto out;
 
 	if (dm_suspended_md(md)) {
@@ -584,16 +583,46 @@ retry:
 		goto out;
 	}
 
-	r = tgt->type->ioctl(tgt, cmd, arg);
+	r = (*tgt)->type->prepare_ioctl(*tgt, bdev, mode);
+	if (r < 0)
+		goto out;
 
-out:
-	dm_put_live_table(md, srcu_idx);
+	return r;
 
+out:
+	dm_put_live_table(md, *srcu_idx);
 	if (r == -ENOTCONN) {
 		msleep(10);
 		goto retry;
 	}
+	return r;
+}
+
+static int dm_blk_ioctl(struct block_device *bdev, fmode_t mode,
+			unsigned int cmd, unsigned long arg)
+{
+	struct mapped_device *md = bdev->bd_disk->private_data;
+	struct dm_target *tgt;
+	int srcu_idx, r;
+
+	r = dm_get_live_table_for_ioctl(md, &tgt, &bdev, &mode, &srcu_idx);
+	if (r < 0)
+		return r;
+
+	if (r > 0) {
+		/*
+		 * Target determined this ioctl is being issued against
+		 * a logical partition of the parent bdev; so extra
+		 * validation is needed.
+		 */
+		r = scsi_verify_blk_ioctl(NULL, cmd);
+		if (r)
+			goto out;
+	}
 
+	r =  __blkdev_driver_ioctl(bdev, mode, cmd, arg);
+out:
+	dm_put_live_table(md, srcu_idx);
 	return r;
 }
 
* Unmerged path include/linux/device-mapper.h
