dm: fix ioctl retry termination with signal

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Junichi Nomura <j-nomura@ce.jp.nec.com>
commit 5bbbfdf685657771fda05b926b28ca0f79163a28
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5bbbfdf6.failed

dm-mpath retries ioctl, when no path is readily available and the device
is configured to queue I/O in such a case. If you want to stop the retry
before multipathd decides to turn off queueing mode, you could send
signal for the process to exit from the loop.

However the check of fatal signal has not carried along when commit
6c182cd88d17 ("dm mpath: fix ioctl deadlock when no paths") moved the
loop from dm-mpath to dm core. As a result, we can't terminate such
a process in the retry loop.

Easy reproducer of the situation is:

  # dmsetup create mp --table '0 1024 multipath 0 0 0 0'
  # dmsetup message mp 0 'queue_if_no_path'
  # sg_inq /dev/mapper/mp

then you should be able to terminate sg_inq by pressing Ctrl+C.

Fixes: 6c182cd88d17 ("dm mpath: fix ioctl deadlock when no paths")
	Signed-off-by: Jun'ichi Nomura <j-nomura@ce.jp.nec.com>
	Cc: Hannes Reinecke <hare@suse.de>
	Cc: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
	Cc: stable@vger.kernel.org
(cherry picked from commit 5bbbfdf685657771fda05b926b28ca0f79163a28)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-mpath.c
#	drivers/md/dm.c
diff --cc drivers/md/dm-mpath.c
index 84de222f462c,3d1829237678..000000000000
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@@ -1581,13 -1562,7 +1581,17 @@@ static int multipath_ioctl(struct dm_ta
  
  	spin_unlock_irqrestore(&m->lock, flags);
  
++<<<<<<< HEAD
 +	/*
 +	 * Only pass ioctls through if the device sizes match exactly.
 +	 */
 +	if (!r && ti->len != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)
 +		r = scsi_verify_blk_ioctl(NULL, cmd);
 +
 +	if (r == -ENOTCONN && !fatal_signal_pending(current)) {
++=======
+ 	if (r == -ENOTCONN) {
++>>>>>>> 5bbbfdf68565 (dm: fix ioctl retry termination with signal)
  		spin_lock_irqsave(&m->lock, flags);
  		if (!m->current_pg) {
  			/* Path status changed, redo selection */
diff --cc drivers/md/dm.c
index 66c19dce3920,fabd5d8fd559..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -585,12 -583,15 +585,17 @@@ retry
  		goto out;
  	}
  
 -	r = (*tgt)->type->prepare_ioctl(*tgt, bdev, mode);
 -	if (r < 0)
 -		goto out;
 -
 -	return r;
 +	r = tgt->type->ioctl(tgt, cmd, arg);
  
  out:
++<<<<<<< HEAD
 +	dm_put_live_table(md, srcu_idx);
 +
 +	if (r == -ENOTCONN) {
++=======
+ 	dm_put_live_table(md, *srcu_idx);
+ 	if (r == -ENOTCONN && !fatal_signal_pending(current)) {
++>>>>>>> 5bbbfdf68565 (dm: fix ioctl retry termination with signal)
  		msleep(10);
  		goto retry;
  	}
* Unmerged path drivers/md/dm-mpath.c
* Unmerged path drivers/md/dm.c
