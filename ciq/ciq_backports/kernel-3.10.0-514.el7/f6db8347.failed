sched/stat: Simplify the sched_info accounting dependency

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
commit f6db8347993256b58bd4746b0c4c5b935c32210d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f6db8347.failed

Both CONFIG_SCHEDSTATS=y and CONFIG_TASK_DELAY_ACCT=y track task
sched_info, which results in ugly #if clauses.

Simplify the code by introducing a synthethic CONFIG_SCHED_INFO
switch, selected by both.

	Signed-off-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
	Cc: Balbir Singh <bsingharora@gmail.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: a.p.zijlstra@chello.nl
	Cc: ricklind@us.ibm.com
Link: http://lkml.kernel.org/r/8d19eef800811a94b0f91bcbeb27430a884d7433.1435255405.git.naveen.n.rao@linux.vnet.ibm.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit f6db8347993256b58bd4746b0c4c5b935c32210d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/stats.h
#	lib/Kconfig.debug
diff --cc kernel/sched/stats.h
index 17d7065c3872,b0fbc7632de5..000000000000
--- a/kernel/sched/stats.h
+++ b/kernel/sched/stats.h
@@@ -137,23 -137,26 +137,31 @@@ __sched_info_switch(struct task_struct 
  	 * process, however.
  	 */
  	if (prev != rq->idle)
 -		sched_info_depart(rq, prev);
 +		sched_info_depart(prev);
  
  	if (next != rq->idle)
 -		sched_info_arrive(rq, next);
 +		sched_info_arrive(next);
  }
  static inline void
 -sched_info_switch(struct rq *rq,
 -		  struct task_struct *prev, struct task_struct *next)
 +sched_info_switch(struct task_struct *prev, struct task_struct *next)
  {
  	if (unlikely(sched_info_on()))
 -		__sched_info_switch(rq, prev, next);
 +		__sched_info_switch(prev, next);
  }
  #else
 -#define sched_info_queued(rq, t)		do { } while (0)
 +#define sched_info_queued(t)			do { } while (0)
  #define sched_info_reset_dequeued(t)	do { } while (0)
++<<<<<<< HEAD
 +#define sched_info_dequeued(t)			do { } while (0)
 +#define sched_info_switch(t, next)		do { } while (0)
 +#endif /* CONFIG_SCHEDSTATS || CONFIG_TASK_DELAY_ACCT */
++=======
+ #define sched_info_dequeued(rq, t)		do { } while (0)
+ #define sched_info_depart(rq, t)		do { } while (0)
+ #define sched_info_arrive(rq, next)		do { } while (0)
+ #define sched_info_switch(rq, t, next)		do { } while (0)
+ #endif /* CONFIG_SCHED_INFO */
++>>>>>>> f6db83479932 (sched/stat: Simplify the sched_info accounting dependency)
  
  /*
   * The following are functions that support scheduler-internal time accounting.
diff --cc lib/Kconfig.debug
index b42d9b05227b,e2894b23efb6..000000000000
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@@ -511,6 -534,369 +511,372 @@@ config DEBUG_KMEMLEAK_DEFAULT_OF
  	  Say Y here to disable kmemleak by default. It can then be enabled
  	  on the command line via kmemleak=on.
  
++<<<<<<< HEAD
++=======
+ config DEBUG_STACK_USAGE
+ 	bool "Stack utilization instrumentation"
+ 	depends on DEBUG_KERNEL && !IA64 && !PARISC && !METAG
+ 	help
+ 	  Enables the display of the minimum amount of free stack which each
+ 	  task has ever had available in the sysrq-T and sysrq-P debug output.
+ 
+ 	  This option will slow down process creation somewhat.
+ 
+ config DEBUG_VM
+ 	bool "Debug VM"
+ 	depends on DEBUG_KERNEL
+ 	help
+ 	  Enable this to turn on extended checks in the virtual-memory system
+           that may impact performance.
+ 
+ 	  If unsure, say N.
+ 
+ config DEBUG_VM_VMACACHE
+ 	bool "Debug VMA caching"
+ 	depends on DEBUG_VM
+ 	help
+ 	  Enable this to turn on VMA caching debug information. Doing so
+ 	  can cause significant overhead, so only enable it in non-production
+ 	  environments.
+ 
+ 	  If unsure, say N.
+ 
+ config DEBUG_VM_RB
+ 	bool "Debug VM red-black trees"
+ 	depends on DEBUG_VM
+ 	help
+ 	  Enable VM red-black tree debugging information and extra validations.
+ 
+ 	  If unsure, say N.
+ 
+ config DEBUG_VIRTUAL
+ 	bool "Debug VM translations"
+ 	depends on DEBUG_KERNEL && X86
+ 	help
+ 	  Enable some costly sanity checks in virtual to page code. This can
+ 	  catch mistakes with virt_to_page() and friends.
+ 
+ 	  If unsure, say N.
+ 
+ config DEBUG_NOMMU_REGIONS
+ 	bool "Debug the global anon/private NOMMU mapping region tree"
+ 	depends on DEBUG_KERNEL && !MMU
+ 	help
+ 	  This option causes the global tree of anonymous and private mapping
+ 	  regions to be regularly checked for invalid topology.
+ 
+ config DEBUG_MEMORY_INIT
+ 	bool "Debug memory initialisation" if EXPERT
+ 	default !EXPERT
+ 	help
+ 	  Enable this for additional checks during memory initialisation.
+ 	  The sanity checks verify aspects of the VM such as the memory model
+ 	  and other information provided by the architecture. Verbose
+ 	  information will be printed at KERN_DEBUG loglevel depending
+ 	  on the mminit_loglevel= command-line option.
+ 
+ 	  If unsure, say Y
+ 
+ config MEMORY_NOTIFIER_ERROR_INJECT
+ 	tristate "Memory hotplug notifier error injection module"
+ 	depends on MEMORY_HOTPLUG_SPARSE && NOTIFIER_ERROR_INJECTION
+ 	help
+ 	  This option provides the ability to inject artificial errors to
+ 	  memory hotplug notifier chain callbacks.  It is controlled through
+ 	  debugfs interface under /sys/kernel/debug/notifier-error-inject/memory
+ 
+ 	  If the notifier call chain should be failed with some events
+ 	  notified, write the error code to "actions/<notifier event>/error".
+ 
+ 	  Example: Inject memory hotplug offline error (-12 == -ENOMEM)
+ 
+ 	  # cd /sys/kernel/debug/notifier-error-inject/memory
+ 	  # echo -12 > actions/MEM_GOING_OFFLINE/error
+ 	  # echo offline > /sys/devices/system/memory/memoryXXX/state
+ 	  bash: echo: write error: Cannot allocate memory
+ 
+ 	  To compile this code as a module, choose M here: the module will
+ 	  be called memory-notifier-error-inject.
+ 
+ 	  If unsure, say N.
+ 
+ config DEBUG_PER_CPU_MAPS
+ 	bool "Debug access to per_cpu maps"
+ 	depends on DEBUG_KERNEL
+ 	depends on SMP
+ 	help
+ 	  Say Y to verify that the per_cpu map being accessed has
+ 	  been set up. This adds a fair amount of code to kernel memory
+ 	  and decreases performance.
+ 
+ 	  Say N if unsure.
+ 
+ config DEBUG_HIGHMEM
+ 	bool "Highmem debugging"
+ 	depends on DEBUG_KERNEL && HIGHMEM
+ 	help
+ 	  This option enables additional error checking for high memory
+ 	  systems.  Disable for production systems.
+ 
+ config HAVE_DEBUG_STACKOVERFLOW
+ 	bool
+ 
+ config DEBUG_STACKOVERFLOW
+ 	bool "Check for stack overflows"
+ 	depends on DEBUG_KERNEL && HAVE_DEBUG_STACKOVERFLOW
+ 	---help---
+ 	  Say Y here if you want to check for overflows of kernel, IRQ
+ 	  and exception stacks (if your architecture uses them). This
+ 	  option will show detailed messages if free stack space drops
+ 	  below a certain limit.
+ 
+ 	  These kinds of bugs usually occur when call-chains in the
+ 	  kernel get too deep, especially when interrupts are
+ 	  involved.
+ 
+ 	  Use this in cases where you see apparently random memory
+ 	  corruption, especially if it appears in 'struct thread_info'
+ 
+ 	  If in doubt, say "N".
+ 
+ source "lib/Kconfig.kmemcheck"
+ 
+ source "lib/Kconfig.kasan"
+ 
+ endmenu # "Memory Debugging"
+ 
+ config DEBUG_SHIRQ
+ 	bool "Debug shared IRQ handlers"
+ 	depends on DEBUG_KERNEL
+ 	help
+ 	  Enable this to generate a spurious interrupt as soon as a shared
+ 	  interrupt handler is registered, and just before one is deregistered.
+ 	  Drivers ought to be able to handle interrupts coming in at those
+ 	  points; some don't and need to be caught.
+ 
+ menu "Debug Lockups and Hangs"
+ 
+ config LOCKUP_DETECTOR
+ 	bool "Detect Hard and Soft Lockups"
+ 	depends on DEBUG_KERNEL && !S390
+ 	help
+ 	  Say Y here to enable the kernel to act as a watchdog to detect
+ 	  hard and soft lockups.
+ 
+ 	  Softlockups are bugs that cause the kernel to loop in kernel
+ 	  mode for more than 20 seconds, without giving other tasks a
+ 	  chance to run.  The current stack trace is displayed upon
+ 	  detection and the system will stay locked up.
+ 
+ 	  Hardlockups are bugs that cause the CPU to loop in kernel mode
+ 	  for more than 10 seconds, without letting other interrupts have a
+ 	  chance to run.  The current stack trace is displayed upon detection
+ 	  and the system will stay locked up.
+ 
+ 	  The overhead should be minimal.  A periodic hrtimer runs to
+ 	  generate interrupts and kick the watchdog task every 4 seconds.
+ 	  An NMI is generated every 10 seconds or so to check for hardlockups.
+ 
+ 	  The frequency of hrtimer and NMI events and the soft and hard lockup
+ 	  thresholds can be controlled through the sysctl watchdog_thresh.
+ 
+ config HARDLOCKUP_DETECTOR
+ 	def_bool y
+ 	depends on LOCKUP_DETECTOR && !HAVE_NMI_WATCHDOG
+ 	depends on PERF_EVENTS && HAVE_PERF_EVENTS_NMI
+ 
+ config BOOTPARAM_HARDLOCKUP_PANIC
+ 	bool "Panic (Reboot) On Hard Lockups"
+ 	depends on HARDLOCKUP_DETECTOR
+ 	help
+ 	  Say Y here to enable the kernel to panic on "hard lockups",
+ 	  which are bugs that cause the kernel to loop in kernel
+ 	  mode with interrupts disabled for more than 10 seconds (configurable
+ 	  using the watchdog_thresh sysctl).
+ 
+ 	  Say N if unsure.
+ 
+ config BOOTPARAM_HARDLOCKUP_PANIC_VALUE
+ 	int
+ 	depends on HARDLOCKUP_DETECTOR
+ 	range 0 1
+ 	default 0 if !BOOTPARAM_HARDLOCKUP_PANIC
+ 	default 1 if BOOTPARAM_HARDLOCKUP_PANIC
+ 
+ config BOOTPARAM_SOFTLOCKUP_PANIC
+ 	bool "Panic (Reboot) On Soft Lockups"
+ 	depends on LOCKUP_DETECTOR
+ 	help
+ 	  Say Y here to enable the kernel to panic on "soft lockups",
+ 	  which are bugs that cause the kernel to loop in kernel
+ 	  mode for more than 20 seconds (configurable using the watchdog_thresh
+ 	  sysctl), without giving other tasks a chance to run.
+ 
+ 	  The panic can be used in combination with panic_timeout,
+ 	  to cause the system to reboot automatically after a
+ 	  lockup has been detected. This feature is useful for
+ 	  high-availability systems that have uptime guarantees and
+ 	  where a lockup must be resolved ASAP.
+ 
+ 	  Say N if unsure.
+ 
+ config BOOTPARAM_SOFTLOCKUP_PANIC_VALUE
+ 	int
+ 	depends on LOCKUP_DETECTOR
+ 	range 0 1
+ 	default 0 if !BOOTPARAM_SOFTLOCKUP_PANIC
+ 	default 1 if BOOTPARAM_SOFTLOCKUP_PANIC
+ 
+ config DETECT_HUNG_TASK
+ 	bool "Detect Hung Tasks"
+ 	depends on DEBUG_KERNEL
+ 	default LOCKUP_DETECTOR
+ 	help
+ 	  Say Y here to enable the kernel to detect "hung tasks",
+ 	  which are bugs that cause the task to be stuck in
+ 	  uninterruptible "D" state indefinitiley.
+ 
+ 	  When a hung task is detected, the kernel will print the
+ 	  current stack trace (which you should report), but the
+ 	  task will stay in uninterruptible state. If lockdep is
+ 	  enabled then all held locks will also be reported. This
+ 	  feature has negligible overhead.
+ 
+ config DEFAULT_HUNG_TASK_TIMEOUT
+ 	int "Default timeout for hung task detection (in seconds)"
+ 	depends on DETECT_HUNG_TASK
+ 	default 120
+ 	help
+ 	  This option controls the default timeout (in seconds) used
+ 	  to determine when a task has become non-responsive and should
+ 	  be considered hung.
+ 
+ 	  It can be adjusted at runtime via the kernel.hung_task_timeout_secs
+ 	  sysctl or by writing a value to
+ 	  /proc/sys/kernel/hung_task_timeout_secs.
+ 
+ 	  A timeout of 0 disables the check.  The default is two minutes.
+ 	  Keeping the default should be fine in most cases.
+ 
+ config BOOTPARAM_HUNG_TASK_PANIC
+ 	bool "Panic (Reboot) On Hung Tasks"
+ 	depends on DETECT_HUNG_TASK
+ 	help
+ 	  Say Y here to enable the kernel to panic on "hung tasks",
+ 	  which are bugs that cause the kernel to leave a task stuck
+ 	  in uninterruptible "D" state.
+ 
+ 	  The panic can be used in combination with panic_timeout,
+ 	  to cause the system to reboot automatically after a
+ 	  hung task has been detected. This feature is useful for
+ 	  high-availability systems that have uptime guarantees and
+ 	  where a hung tasks must be resolved ASAP.
+ 
+ 	  Say N if unsure.
+ 
+ config BOOTPARAM_HUNG_TASK_PANIC_VALUE
+ 	int
+ 	depends on DETECT_HUNG_TASK
+ 	range 0 1
+ 	default 0 if !BOOTPARAM_HUNG_TASK_PANIC
+ 	default 1 if BOOTPARAM_HUNG_TASK_PANIC
+ 
+ endmenu # "Debug lockups and hangs"
+ 
+ config PANIC_ON_OOPS
+ 	bool "Panic on Oops"
+ 	help
+ 	  Say Y here to enable the kernel to panic when it oopses. This
+ 	  has the same effect as setting oops=panic on the kernel command
+ 	  line.
+ 
+ 	  This feature is useful to ensure that the kernel does not do
+ 	  anything erroneous after an oops which could result in data
+ 	  corruption or other issues.
+ 
+ 	  Say N if unsure.
+ 
+ config PANIC_ON_OOPS_VALUE
+ 	int
+ 	range 0 1
+ 	default 0 if !PANIC_ON_OOPS
+ 	default 1 if PANIC_ON_OOPS
+ 
+ config PANIC_TIMEOUT
+ 	int "panic timeout"
+ 	default 0
+ 	help
+ 	  Set the timeout value (in seconds) until a reboot occurs when the
+ 	  the kernel panics. If n = 0, then we wait forever. A timeout
+ 	  value n > 0 will wait n seconds before rebooting, while a timeout
+ 	  value n < 0 will reboot immediately.
+ 
+ config SCHED_DEBUG
+ 	bool "Collect scheduler debugging info"
+ 	depends on DEBUG_KERNEL && PROC_FS
+ 	default y
+ 	help
+ 	  If you say Y here, the /proc/sched_debug file will be provided
+ 	  that can help debug the scheduler. The runtime overhead of this
+ 	  option is minimal.
+ 
+ config SCHED_INFO
+ 	bool
+ 	default n
+ 
+ config SCHEDSTATS
+ 	bool "Collect scheduler statistics"
+ 	depends on DEBUG_KERNEL && PROC_FS
+ 	select SCHED_INFO
+ 	help
+ 	  If you say Y here, additional code will be inserted into the
+ 	  scheduler and related routines to collect statistics about
+ 	  scheduler behavior and provide them in /proc/schedstat.  These
+ 	  stats may be useful for both tuning and debugging the scheduler
+ 	  If you aren't debugging the scheduler or trying to tune a specific
+ 	  application, you can say N to avoid the very slight overhead
+ 	  this adds.
+ 
+ config SCHED_STACK_END_CHECK
+ 	bool "Detect stack corruption on calls to schedule()"
+ 	depends on DEBUG_KERNEL
+ 	default n
+ 	help
+ 	  This option checks for a stack overrun on calls to schedule().
+ 	  If the stack end location is found to be over written always panic as
+ 	  the content of the corrupted region can no longer be trusted.
+ 	  This is to ensure no erroneous behaviour occurs which could result in
+ 	  data corruption or a sporadic crash at a later stage once the region
+ 	  is examined. The runtime overhead introduced is minimal.
+ 
+ config DEBUG_TIMEKEEPING
+ 	bool "Enable extra timekeeping sanity checking"
+ 	help
+ 	  This option will enable additional timekeeping sanity checks
+ 	  which may be helpful when diagnosing issues where timekeeping
+ 	  problems are suspected.
+ 
+ 	  This may include checks in the timekeeping hotpaths, so this
+ 	  option may have a (very small) performance impact to some
+ 	  workloads.
+ 
+ 	  If unsure, say N.
+ 
+ config TIMER_STATS
+ 	bool "Collect kernel timers statistics"
+ 	depends on DEBUG_KERNEL && PROC_FS
+ 	help
+ 	  If you say Y here, additional code will be inserted into the
+ 	  timer routines to collect statistics about kernel timers being
+ 	  reprogrammed. The statistics can be read from /proc/timer_stats.
+ 	  The statistics collection is started by writing 1 to /proc/timer_stats,
+ 	  writing 0 stops it. This feature is useful to collect information
+ 	  about timer usage patterns in kernel and userspace. This feature
+ 	  is lightweight if enabled in the kernel config but not activated
+ 	  (it defaults to deactivated on bootup and will only be activated
+ 	  if some application like powertop activates it explicitly).
+ 
++>>>>>>> f6db83479932 (sched/stat: Simplify the sched_info accounting dependency)
  config DEBUG_PREEMPT
  	bool "Debug preemptible kernel"
  	depends on DEBUG_KERNEL && PREEMPT && TRACE_IRQFLAGS_SUPPORT
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 8fc9db5893d3..dcd55ceb3a00 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -706,7 +706,7 @@ extern struct user_struct root_user;
 struct backing_dev_info;
 struct reclaim_state;
 
-#if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)
+#ifdef CONFIG_SCHED_INFO
 struct sched_info {
 	/* cumulative counters */
 	unsigned long pcount;	      /* # of times run on this cpu */
@@ -716,7 +716,7 @@ struct sched_info {
 	unsigned long long last_arrival,/* when we last ran on a cpu */
 			   last_queued;	/* when we were last queued to run */
 };
-#endif /* defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT) */
+#endif /* CONFIG_SCHED_INFO */
 
 #ifdef CONFIG_TASK_DELAY_ACCT
 struct task_delay_info {
@@ -1172,7 +1172,7 @@ struct task_struct {
 	struct rt_mutex *rcu_boost_mutex;
 #endif /* #ifdef CONFIG_RCU_BOOST */
 
-#if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)
+#ifdef CONFIG_SCHED_INFO
 	struct sched_info sched_info;
 #endif
 
diff --git a/init/Kconfig b/init/Kconfig
index 9c03541a6bec..1e9c52634f73 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -380,6 +380,7 @@ config TASKSTATS
 config TASK_DELAY_ACCT
 	bool "Enable per-task delay accounting"
 	depends on TASKSTATS
+	select SCHED_INFO
 	help
 	  Collect information on time spent by a task waiting for system
 	  resources like cpu, synchronous block I/O completion and swapping
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 123c3306c598..a37edf4e017f 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -1958,7 +1958,7 @@ void sched_fork(unsigned long clone_flags, struct task_struct *p)
 	set_task_cpu(p, cpu);
 	raw_spin_unlock_irqrestore(&p->pi_lock, flags);
 
-#if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)
+#ifdef CONFIG_SCHED_INFO
 	if (likely(sched_info_on()))
 		memset(&p->sched_info, 0, sizeof(p->sched_info));
 #endif
* Unmerged path kernel/sched/stats.h
* Unmerged path lib/Kconfig.debug
