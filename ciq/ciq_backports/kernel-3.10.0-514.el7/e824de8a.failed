net/qlcnic: fix mac address restore in bond mode 5/6

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [netdrv] qlcnic: fix mac address restore in bond mode 5/6 (Jarod Wilson) [1265058]
Rebuild_FUZZ: 96.00%
commit-author Jarod Wilson <jarod@redhat.com>
commit e824de8ae2a00ee71c5bfbadd004d12c6dd85561
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e824de8a.failed

The bonding driver saves a copy of slaves' original mac address and then
assigns whatever mac as needed to the slave, depending on mode. In at
least modes 5 and 6 (balance-tlb, balance-alb), it often ends up being the
mac address of another slave. On release from the bond, the original mac
address is supposed to get restored via a dev_set_mac_address() call in
the bonding driver's __bond_release_one() function, which calls the
slave's ndo_set_mac_address function, which for qlcnic, is
qlcnic_set_mac().

Now, this function tries to be somewhat intelligent and exit early if
you're trying to set the mac address to the same thing that is already
set. The problem here is that adapter->mac_addr isn't in sync with
netdev->dev_addr. The qlcnic driver still has the original mac stored in
adapter->mac_addr, while the bonding driver has updated netdev->dev_addr,
so qlcnic thinks we're trying to set the same address it already has.

I think the way to go here, since the function updates both netdev and
adapter's stored mac addresses, is to check if either of them doesn't
match the newly requested mac. Simply checking netdev's value only could
result in a similar mismatch and non-update, so look at both.

CC: Dept-GELinuxNICDev@qlogic.com
CC: netdev@vger.kernel.org
CC: Manish Chopra <manish.chopra@qlogic.com>
	Signed-off-by: Jarod Wilson <jarod@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e824de8ae2a00ee71c5bfbadd004d12c6dd85561)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index 294ddd6b27dd,1205f6f9c941..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@@ -354,7 -353,8 +354,12 @@@ static int qlcnic_set_mac(struct net_de
  	if (!is_valid_ether_addr(addr->sa_data))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (!memcmp(adapter->mac_addr, addr->sa_data, ETH_ALEN))
++=======
+ 	if (ether_addr_equal_unaligned(adapter->mac_addr, addr->sa_data) &&
+ 	    ether_addr_equal_unaligned(netdev->dev_addr, addr->sa_data))
++>>>>>>> e824de8ae2a0 (net/qlcnic: fix mac address restore in bond mode 5/6)
  		return 0;
  
  	if (test_bit(__QLCNIC_DEV_UP, &adapter->state)) {
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
