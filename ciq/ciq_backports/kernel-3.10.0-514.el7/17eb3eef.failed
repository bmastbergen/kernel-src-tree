cxl: Ignore probes for virtual afu pci devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vaibhav Jain <vaibhav@linux.vnet.ibm.com>
commit 17eb3eef19f2c0541a7f04ad37c4a7fec89f0822
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/17eb3eef.failed

Add a check at the beginning of cxl_probe function to ignore virtual pci
devices created for each afu registered. This fixes the the errors
messages logged about missing CXL vsec, when cxl probe is unable to
find necessary vsec entries in device pci config space. The error
message logged are of the form :

cxl-pci 0004:00:00.0: ABORTING: CXL VSEC not found!
cxl-pci 0004:00:00.0: cxl_init_adapter failed: -19

	Cc: Ian Munsie <imunsie@au1.ibm.com>
	Cc: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
	Signed-off-by: Vaibhav Jain <vaibhav@linux.vnet.ibm.com>
	Reviewed-by: fbarrat@linux.vnet.ibm.com
	Reviewed-by: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
	Acked-by: Ian Munsie <imunsie@au1.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 17eb3eef19f2c0541a7f04ad37c4a7fec89f0822)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/cxl/cxl.h
diff --cc drivers/misc/cxl/cxl.h
index ea4888bb5ce4,38e21cf7806e..000000000000
--- a/drivers/misc/cxl/cxl.h
+++ b/drivers/misc/cxl/cxl.h
@@@ -769,6 -814,72 +769,74 @@@ void cxl_pci_vphb_reconfigure(struct cx
  void cxl_pci_vphb_remove(struct cxl_afu *afu);
  
  extern struct pci_driver cxl_pci_driver;
 -extern struct platform_driver cxl_of_driver;
  int afu_allocate_irqs(struct cxl_context *ctx, u32 count);
  
++<<<<<<< HEAD
++=======
+ int afu_open(struct inode *inode, struct file *file);
+ int afu_release(struct inode *inode, struct file *file);
+ long afu_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+ int afu_mmap(struct file *file, struct vm_area_struct *vm);
+ unsigned int afu_poll(struct file *file, struct poll_table_struct *poll);
+ ssize_t afu_read(struct file *file, char __user *buf, size_t count, loff_t *off);
+ extern const struct file_operations afu_fops;
+ 
+ struct cxl *cxl_guest_init_adapter(struct device_node *np, struct platform_device *dev);
+ void cxl_guest_remove_adapter(struct cxl *adapter);
+ int cxl_of_read_adapter_handle(struct cxl *adapter, struct device_node *np);
+ int cxl_of_read_adapter_properties(struct cxl *adapter, struct device_node *np);
+ ssize_t cxl_guest_read_adapter_vpd(struct cxl *adapter, void *buf, size_t len);
+ ssize_t cxl_guest_read_afu_vpd(struct cxl_afu *afu, void *buf, size_t len);
+ int cxl_guest_init_afu(struct cxl *adapter, int slice, struct device_node *afu_np);
+ void cxl_guest_remove_afu(struct cxl_afu *afu);
+ int cxl_of_read_afu_handle(struct cxl_afu *afu, struct device_node *afu_np);
+ int cxl_of_read_afu_properties(struct cxl_afu *afu, struct device_node *afu_np);
+ int cxl_guest_add_chardev(struct cxl *adapter);
+ void cxl_guest_remove_chardev(struct cxl *adapter);
+ void cxl_guest_reload_module(struct cxl *adapter);
+ int cxl_of_probe(struct platform_device *pdev);
+ 
+ struct cxl_backend_ops {
+ 	struct module *module;
+ 	int (*adapter_reset)(struct cxl *adapter);
+ 	int (*alloc_one_irq)(struct cxl *adapter);
+ 	void (*release_one_irq)(struct cxl *adapter, int hwirq);
+ 	int (*alloc_irq_ranges)(struct cxl_irq_ranges *irqs,
+ 				struct cxl *adapter, unsigned int num);
+ 	void (*release_irq_ranges)(struct cxl_irq_ranges *irqs,
+ 				struct cxl *adapter);
+ 	int (*setup_irq)(struct cxl *adapter, unsigned int hwirq,
+ 			unsigned int virq);
+ 	irqreturn_t (*handle_psl_slice_error)(struct cxl_context *ctx,
+ 					u64 dsisr, u64 errstat);
+ 	irqreturn_t (*psl_interrupt)(int irq, void *data);
+ 	int (*ack_irq)(struct cxl_context *ctx, u64 tfc, u64 psl_reset_mask);
+ 	int (*attach_process)(struct cxl_context *ctx, bool kernel,
+ 			u64 wed, u64 amr);
+ 	int (*detach_process)(struct cxl_context *ctx);
+ 	bool (*support_attributes)(const char *attr_name, enum cxl_attrs type);
+ 	bool (*link_ok)(struct cxl *cxl, struct cxl_afu *afu);
+ 	void (*release_afu)(struct device *dev);
+ 	ssize_t (*afu_read_err_buffer)(struct cxl_afu *afu, char *buf,
+ 				loff_t off, size_t count);
+ 	int (*afu_check_and_enable)(struct cxl_afu *afu);
+ 	int (*afu_activate_mode)(struct cxl_afu *afu, int mode);
+ 	int (*afu_deactivate_mode)(struct cxl_afu *afu, int mode);
+ 	int (*afu_reset)(struct cxl_afu *afu);
+ 	int (*afu_cr_read8)(struct cxl_afu *afu, int cr_idx, u64 offset, u8 *val);
+ 	int (*afu_cr_read16)(struct cxl_afu *afu, int cr_idx, u64 offset, u16 *val);
+ 	int (*afu_cr_read32)(struct cxl_afu *afu, int cr_idx, u64 offset, u32 *val);
+ 	int (*afu_cr_read64)(struct cxl_afu *afu, int cr_idx, u64 offset, u64 *val);
+ 	int (*afu_cr_write8)(struct cxl_afu *afu, int cr_idx, u64 offset, u8 val);
+ 	int (*afu_cr_write16)(struct cxl_afu *afu, int cr_idx, u64 offset, u16 val);
+ 	int (*afu_cr_write32)(struct cxl_afu *afu, int cr_idx, u64 offset, u32 val);
+ 	ssize_t (*read_adapter_vpd)(struct cxl *adapter, void *buf, size_t count);
+ };
+ extern const struct cxl_backend_ops cxl_native_ops;
+ extern const struct cxl_backend_ops cxl_guest_ops;
+ extern const struct cxl_backend_ops *cxl_ops;
+ 
+ /* check if the given pci_dev is on the the cxl vphb bus */
+ bool cxl_pci_is_vphb_device(struct pci_dev *dev);
++>>>>>>> 17eb3eef19f2 (cxl: Ignore probes for virtual afu pci devices)
  #endif
* Unmerged path drivers/misc/cxl/cxl.h
diff --git a/drivers/misc/cxl/pci.c b/drivers/misc/cxl/pci.c
index c7dc27fa6ee0..93755d06bfc1 100644
--- a/drivers/misc/cxl/pci.c
+++ b/drivers/misc/cxl/pci.c
@@ -1255,6 +1255,11 @@ static int cxl_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	int slice;
 	int rc;
 
+	if (cxl_pci_is_vphb_device(dev)) {
+		dev_dbg(&dev->dev, "cxl_init_adapter: Ignoring cxl vphb device\n");
+		return -ENODEV;
+	}
+
 	if (cxl_verbose)
 		dump_cxl_config_space(dev);
 
diff --git a/drivers/misc/cxl/vphb.c b/drivers/misc/cxl/vphb.c
index cbd4331fb45c..e76a42aa7678 100644
--- a/drivers/misc/cxl/vphb.c
+++ b/drivers/misc/cxl/vphb.c
@@ -296,6 +296,15 @@ void cxl_pci_vphb_remove(struct cxl_afu *afu)
 	pcibios_free_controller(phb);
 }
 
+bool cxl_pci_is_vphb_device(struct pci_dev *dev)
+{
+	struct pci_controller *phb;
+
+	phb = pci_bus_to_host(dev->bus);
+
+	return (phb->ops == &cxl_pcie_pci_ops);
+}
+
 struct cxl_afu *cxl_pci_to_afu(struct pci_dev *dev)
 {
 	struct pci_controller *phb;
