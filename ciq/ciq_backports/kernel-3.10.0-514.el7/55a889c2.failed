tpm_crb: Use the common ACPI definition of struct acpi_tpm2

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
commit 55a889c2cb138f8f10164539c6d290a1cefaa863
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/55a889c2.failed

include/acpi/actbl2.h is the proper place for these definitions
and the needed TPM2 ones have been there since
commit 413d4a6defe0 ("ACPICA: Update TPM2 ACPI table")

This also drops a couple of le32_to_cpu's for members of this table,
the existing swapping was not done consistently, and the standard
used by other Linux callers of acpi_get_table is unswapped.

	Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
	Tested-by: Wilck, Martin <martin.wilck@ts.fujitsu.com>
	Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Acked-by: Peter Huewe <peterhuewe@gmx.de>
(cherry picked from commit 55a889c2cb138f8f10164539c6d290a1cefaa863)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm_crb.c
#	drivers/char/tpm/tpm_tis.c
diff --cc drivers/char/tpm/tpm_crb.c
index 262fc5d88644,8dd70696ebe8..000000000000
--- a/drivers/char/tpm/tpm_crb.c
+++ b/drivers/char/tpm/tpm_crb.c
@@@ -34,20 -34,6 +34,23 @@@ enum crb_defaults 
  	CRB_ACPI_START_INDEX = 1,
  };
  
++<<<<<<< HEAD
 +enum crb_start_method {
 +	CRB_SM_ACPI_START = 2,
 +	CRB_SM_CRB = 7,
 +	CRB_SM_CRB_WITH_ACPI_START = 8,
 +};
 +
 +struct acpi_tpm2 {
 +	struct acpi_table_header hdr;
 +	u16 platform_class;
 +	u16 reserved;
 +	u64 control_area_pa;
 +	u32 start_method;
 +} __packed;
 +
++=======
++>>>>>>> 55a889c2cb13 (tpm_crb: Use the common ACPI definition of struct acpi_tpm2)
  enum crb_ca_request {
  	CRB_CA_REQ_GO_IDLE	= BIT(0),
  	CRB_CA_REQ_CMD_READY	= BIT(1),
@@@ -221,23 -207,23 +224,36 @@@ static int crb_acpi_add(struct acpi_dev
  	u64 pa;
  	int rc;
  
 +	chip = tpmm_chip_alloc(dev, &tpm_crb);
 +	if (IS_ERR(chip))
 +		return PTR_ERR(chip);
 +
 +	chip->flags = TPM_CHIP_FLAG_TPM2;
 +
  	status = acpi_get_table(ACPI_SIG_TPM2, 1,
  				(struct acpi_table_header **) &buf);
- 	if (ACPI_FAILURE(status)) {
- 		dev_err(dev, "failed to get TPM2 ACPI table\n");
+ 	if (ACPI_FAILURE(status) || buf->header.length < sizeof(*buf)) {
+ 		dev_err(dev, FW_BUG "failed to get TPM2 ACPI table\n");
  		return -ENODEV;
  	}
  
++<<<<<<< HEAD
 +	if (buf->hdr.length < sizeof(struct acpi_tpm2)) {
 +		dev_err(dev, "TPM2 ACPI table has wrong size");
 +		return -EINVAL;
 +	}
++=======
+ 	/* Should the FIFO driver handle this? */
+ 	sm = buf->start_method;
+ 	if (sm == ACPI_TPM2_MEMORY_MAPPED)
+ 		return -ENODEV;
+ 
+ 	chip = tpmm_chip_alloc(dev, &tpm_crb);
+ 	if (IS_ERR(chip))
+ 		return PTR_ERR(chip);
+ 
+ 	chip->flags = TPM_CHIP_FLAG_TPM2;
++>>>>>>> 55a889c2cb13 (tpm_crb: Use the common ACPI definition of struct acpi_tpm2)
  
  	priv = (struct crb_priv *) devm_kzalloc(dev, sizeof(struct crb_priv),
  						GFP_KERNEL);
@@@ -252,11 -236,12 +266,20 @@@
  	 * report only ACPI start but in practice seems to require both
  	 * ACPI start and CRB start.
  	 */
++<<<<<<< HEAD
 +	if (sm == CRB_SM_CRB || sm == CRB_SM_CRB_WITH_ACPI_START ||
 +	    !strcmp(acpi_device_hid(device), "MSFT0101"))
 +		priv->flags |= CRB_FL_CRB_START;
 +
 +	if (sm == CRB_SM_ACPI_START || sm == CRB_SM_CRB_WITH_ACPI_START)
++=======
+ 	if (sm == ACPI_TPM2_COMMAND_BUFFER || sm == ACPI_TPM2_MEMORY_MAPPED ||
+ 	    !strcmp(acpi_device_hid(device), "MSFT0101"))
+ 		priv->flags |= CRB_FL_CRB_START;
+ 
+ 	if (sm == ACPI_TPM2_START_METHOD ||
+ 	    sm == ACPI_TPM2_COMMAND_BUFFER_WITH_START_METHOD)
++>>>>>>> 55a889c2cb13 (tpm_crb: Use the common ACPI definition of struct acpi_tpm2)
  		priv->flags |= CRB_FL_ACPI_START;
  
  	priv->cca = (struct crb_control_area __iomem *)
diff --cc drivers/char/tpm/tpm_tis.c
index b6392eb21cdb,eb31644111a6..000000000000
--- a/drivers/char/tpm/tpm_tis.c
+++ b/drivers/char/tpm/tpm_tis.c
@@@ -92,25 -102,53 +92,37 @@@ struct priv_data 
  };
  
  #if defined(CONFIG_PNP) && defined(CONFIG_ACPI)
 -static int has_hid(struct acpi_device *dev, const char *hid)
 +static int is_itpm(struct pnp_dev *dev)
  {
 +	struct acpi_device *acpi = pnp_acpi_device(dev);
  	struct acpi_hardware_id *id;
  
 -	list_for_each_entry(id, &dev->pnp.ids, list)
 -		if (!strcmp(hid, id->id))
 -			return 1;
 -
 -	return 0;
 -}
 -
 -static inline int is_itpm(struct acpi_device *dev)
 -{
 -	return has_hid(dev, "INTC0102");
 -}
 -
 -static inline int is_fifo(struct acpi_device *dev)
 -{
 -	struct acpi_table_tpm2 *tbl;
 -	acpi_status st;
 -
 -	/* TPM 1.2 FIFO */
 -	if (!has_hid(dev, "MSFT0101"))
 -		return 1;
 -
 -	st = acpi_get_table(ACPI_SIG_TPM2, 1,
 -			    (struct acpi_table_header **) &tbl);
 -	if (ACPI_FAILURE(st)) {
 -		dev_err(&dev->dev, "failed to get TPM2 ACPI table\n");
 +	if (!acpi)
  		return 0;
 +
 +	list_for_each_entry(id, &acpi->pnp.ids, list) {
 +		if (!strcmp("INTC0102", id->id))
 +			return 1;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (tbl->start_method != ACPI_TPM2_MEMORY_MAPPED)
+ 		return 0;
+ 
+ 	/* TPM 2.0 FIFO */
+ 	return 1;
+ }
+ #else
+ static inline int is_itpm(struct acpi_device *dev)
+ {
++>>>>>>> 55a889c2cb13 (tpm_crb: Use the common ACPI definition of struct acpi_tpm2)
  	return 0;
  }
 -
 -static inline int is_fifo(struct acpi_device *dev)
 +#else
 +static inline int is_itpm(struct pnp_dev *dev)
  {
 -	return 1;
 +	return 0;
  }
  #endif
  
* Unmerged path drivers/char/tpm/tpm_crb.c
* Unmerged path drivers/char/tpm/tpm_tis.c
