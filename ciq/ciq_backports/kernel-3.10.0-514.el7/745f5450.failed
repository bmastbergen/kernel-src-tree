netfilter: nft_hash: restore struct nft_hash

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Patrick McHardy <kaber@trash.net>
commit 745f5450d5190e8bd02301b8d42f06999af3f5f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/745f5450.failed

Following patches will add new private members, restore struct nft_hash
as preparation.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 745f5450d5190e8bd02301b8d42f06999af3f5f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_hash.c
diff --cc net/netfilter/nft_hash.c
index f14a5e14123a,a517f84e9a21..000000000000
--- a/net/netfilter/nft_hash.c
+++ b/net/netfilter/nft_hash.c
@@@ -33,10 -39,10 +37,17 @@@ static bool nft_hash_lookup(const struc
  			    const struct nft_data *key,
  			    struct nft_data *data)
  {
++<<<<<<< HEAD
 +	const struct rhashtable *priv = nft_set_priv(set);
 +	const struct nft_hash_elem *he;
 +
 +	he = rhashtable_lookup(priv, key);
++=======
+ 	struct nft_hash *priv = nft_set_priv(set);
+ 	const struct nft_hash_elem *he;
+ 
+ 	he = rhashtable_lookup_fast(&priv->ht, key, nft_hash_params);
++>>>>>>> 745f5450d519 (netfilter: nft_hash: restore struct nft_hash)
  	if (he && set->flags & NFT_SET_MAP)
  		nft_data_copy(data, he->data);
  
@@@ -46,9 -52,10 +57,9 @@@
  static int nft_hash_insert(const struct nft_set *set,
  			   const struct nft_set_elem *elem)
  {
- 	struct rhashtable *priv = nft_set_priv(set);
+ 	struct nft_hash *priv = nft_set_priv(set);
  	struct nft_hash_elem *he;
  	unsigned int size;
 -	int err;
  
  	if (elem->flags != 0)
  		return -EINVAL;
@@@ -65,9 -72,11 +76,15 @@@
  	if (set->flags & NFT_SET_MAP)
  		nft_data_copy(he->data, &elem->data);
  
++<<<<<<< HEAD
 +	rhashtable_insert(priv, &he->node);
++=======
+ 	err = rhashtable_insert_fast(&priv->ht, &he->node, nft_hash_params);
+ 	if (err)
+ 		kfree(he);
++>>>>>>> 745f5450d519 (netfilter: nft_hash: restore struct nft_hash)
  
 -	return err;
 +	return 0;
  }
  
  static void nft_hash_elem_destroy(const struct nft_set *set,
@@@ -82,123 -91,117 +99,161 @@@
  static void nft_hash_remove(const struct nft_set *set,
  			    const struct nft_set_elem *elem)
  {
- 	struct rhashtable *priv = nft_set_priv(set);
+ 	struct nft_hash *priv = nft_set_priv(set);
  
++<<<<<<< HEAD
 +	rhashtable_remove(priv, elem->cookie);
++=======
+ 	rhashtable_remove_fast(&priv->ht, elem->cookie, nft_hash_params);
++>>>>>>> 745f5450d519 (netfilter: nft_hash: restore struct nft_hash)
  	synchronize_rcu();
  	kfree(elem->cookie);
  }
  
 +struct nft_compare_arg {
 +	const struct nft_set *set;
 +	struct nft_set_elem *elem;
 +};
 +
 +static bool nft_hash_compare(void *ptr, void *arg)
 +{
 +	struct nft_hash_elem *he = ptr;
 +	struct nft_compare_arg *x = arg;
 +
 +	if (!nft_data_cmp(&he->key, &x->elem->key, x->set->klen)) {
 +		x->elem->cookie = he;
 +		x->elem->flags = 0;
 +		if (x->set->flags & NFT_SET_MAP)
 +			nft_data_copy(&x->elem->data, he->data);
 +
 +		return true;
 +	}
 +
 +	return false;
 +}
 +
  static int nft_hash_get(const struct nft_set *set, struct nft_set_elem *elem)
  {
++<<<<<<< HEAD
 +	const struct rhashtable *priv = nft_set_priv(set);
 +	struct nft_compare_arg arg = {
 +		.set = set,
 +		.elem = elem,
 +	};
 +
 +	if (rhashtable_lookup_compare(priv, &elem->key,
 +				      &nft_hash_compare, &arg))
 +		return 0;
++=======
+ 	struct nft_hash *priv = nft_set_priv(set);
+ 	struct nft_hash_elem *he;
+ 
+ 	he = rhashtable_lookup_fast(&priv->ht, &elem->key, nft_hash_params);
+ 	if (!he)
+ 		return -ENOENT;
++>>>>>>> 745f5450d519 (netfilter: nft_hash: restore struct nft_hash)
  
 -	elem->cookie = he;
 -	elem->flags = 0;
 -	if (set->flags & NFT_SET_MAP)
 -		nft_data_copy(&elem->data, he->data);
 -
 -	return 0;
 +	return -ENOENT;
  }
  
  static void nft_hash_walk(const struct nft_ctx *ctx, const struct nft_set *set,
  			  struct nft_set_iter *iter)
  {
++<<<<<<< HEAD
 +	const struct rhashtable *priv = nft_set_priv(set);
 +	const struct bucket_table *tbl;
++=======
+ 	struct nft_hash *priv = nft_set_priv(set);
++>>>>>>> 745f5450d519 (netfilter: nft_hash: restore struct nft_hash)
  	const struct nft_hash_elem *he;
 -	struct rhashtable_iter hti;
  	struct nft_set_elem elem;
 -	int err;
 +	unsigned int i;
  
++<<<<<<< HEAD
 +	tbl = rht_dereference_rcu(priv->tbl, priv);
 +	for (i = 0; i < tbl->size; i++) {
 +		struct rhash_head *pos;
++=======
+ 	err = rhashtable_walk_init(&priv->ht, &hti);
+ 	iter->err = err;
+ 	if (err)
+ 		return;
++>>>>>>> 745f5450d519 (netfilter: nft_hash: restore struct nft_hash)
  
 -	err = rhashtable_walk_start(&hti);
 -	if (err && err != -EAGAIN) {
 -		iter->err = err;
 -		goto out;
 -	}
 +		rht_for_each_entry_rcu(he, pos, tbl, i, node) {
 +			if (iter->count < iter->skip)
 +				goto cont;
  
 -	while ((he = rhashtable_walk_next(&hti))) {
 -		if (IS_ERR(he)) {
 -			err = PTR_ERR(he);
 -			if (err != -EAGAIN) {
 -				iter->err = err;
 -				goto out;
 -			}
 -
 -			continue;
 -		}
 -
 -		if (iter->count < iter->skip)
 -			goto cont;
 -
 -		memcpy(&elem.key, &he->key, sizeof(elem.key));
 -		if (set->flags & NFT_SET_MAP)
 -			memcpy(&elem.data, he->data, sizeof(elem.data));
 -		elem.flags = 0;
 -
 -		iter->err = iter->fn(ctx, set, iter, &elem);
 -		if (iter->err < 0)
 -			goto out;
 +			memcpy(&elem.key, &he->key, sizeof(elem.key));
 +			if (set->flags & NFT_SET_MAP)
 +				memcpy(&elem.data, he->data, sizeof(elem.data));
 +			elem.flags = 0;
  
 +			iter->err = iter->fn(ctx, set, iter, &elem);
 +			if (iter->err < 0)
 +				return;
  cont:
 -		iter->count++;
 +			iter->count++;
 +		}
  	}
 -
 -out:
 -	rhashtable_walk_stop(&hti);
 -	rhashtable_walk_exit(&hti);
  }
  
  static unsigned int nft_hash_privsize(const struct nlattr * const nla[])
  {
- 	return sizeof(struct rhashtable);
+ 	return sizeof(struct nft_hash);
  }
  
 -static const struct rhashtable_params nft_hash_params = {
 -	.head_offset = offsetof(struct nft_hash_elem, node),
 -	.key_offset = offsetof(struct nft_hash_elem, key),
 -	.hashfn = jhash,
 -	.automatic_shrinking = true,
 -};
 +static int lockdep_nfnl_lock_is_held(void)
 +{
 +	return lockdep_nfnl_is_held(NFNL_SUBSYS_NFTABLES);
 +}
  
  static int nft_hash_init(const struct nft_set *set,
  			 const struct nft_set_desc *desc,
  			 const struct nlattr * const tb[])
  {
++<<<<<<< HEAD
 +	struct rhashtable *priv = nft_set_priv(set);
 +	struct rhashtable_params params = {
 +		.nelem_hint = desc->size ? : NFT_HASH_ELEMENT_HINT,
 +		.head_offset = offsetof(struct nft_hash_elem, node),
 +		.key_offset = offsetof(struct nft_hash_elem, key),
 +		.key_len = set->klen,
 +		.hashfn = jhash,
 +		.grow_decision = rht_grow_above_75,
 +		.shrink_decision = rht_shrink_below_30,
 +		.mutex_is_held = lockdep_nfnl_lock_is_held,
 +	};
++=======
+ 	struct nft_hash *priv = nft_set_priv(set);
+ 	struct rhashtable_params params = nft_hash_params;
  
- 	return rhashtable_init(priv, &params);
+ 	params.nelem_hint = desc->size ?: NFT_HASH_ELEMENT_HINT;
+ 	params.key_len = set->klen;
++>>>>>>> 745f5450d519 (netfilter: nft_hash: restore struct nft_hash)
+ 
+ 	return rhashtable_init(&priv->ht, &params);
  }
  
 -static void nft_free_element(void *ptr, void *arg)
 -{
 -	nft_hash_elem_destroy((const struct nft_set *)arg, ptr);
 -}
 -
  static void nft_hash_destroy(const struct nft_set *set)
  {
++<<<<<<< HEAD
 +	const struct rhashtable *priv = nft_set_priv(set);
 +	const struct bucket_table *tbl = priv->tbl;
 +	struct nft_hash_elem *he;
 +	struct rhash_head *pos, *next;
 +	unsigned int i;
 +
 +	for (i = 0; i < tbl->size; i++) {
 +		rht_for_each_entry_safe(he, pos, next, tbl, i, node)
 +			nft_hash_elem_destroy(set, he);
 +	}
 +	rhashtable_destroy(priv);
++=======
+ 	struct nft_hash *priv = nft_set_priv(set);
+ 
+ 	rhashtable_free_and_destroy(&priv->ht, nft_free_element, (void *)set);
++>>>>>>> 745f5450d519 (netfilter: nft_hash: restore struct nft_hash)
  }
  
  static bool nft_hash_estimate(const struct nft_set_desc *desc, u32 features,
* Unmerged path net/netfilter/nft_hash.c
