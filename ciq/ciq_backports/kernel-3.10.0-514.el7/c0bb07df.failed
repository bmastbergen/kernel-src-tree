netlink: Reset portid after netlink_insert failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit c0bb07df7d981e4091432754e30c9c720e2c0c78
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c0bb07df.failed

The commit c5adde9468b0714a051eac7f9666f23eb10b61f7 ("netlink:
eliminate nl_sk_hash_lock") breaks the autobind retry mechanism
because it doesn't reset portid after a failed netlink_insert.

This means that should autobind fail the first time around, then
the socket will be stuck in limbo as it can never be bound again
since it already has a non-zero portid.

Fixes: c5adde9468b0 ("netlink: eliminate nl_sk_hash_lock")
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c0bb07df7d981e4091432754e30c9c720e2c0c78)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netlink/af_netlink.c
diff --cc net/netlink/af_netlink.c
index 9d53ffe3d114,bf6e76643f78..000000000000
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@@ -1083,10 -1076,17 +1083,22 @@@ static int netlink_insert(struct sock *
  
  	nlk_sk(sk)->portid = portid;
  	sock_hold(sk);
++<<<<<<< HEAD
 +	rhashtable_insert(&table->hash, &nlk_sk(sk)->node);
 +	err = 0;
++=======
+ 
+ 	err = __netlink_insert(table, sk);
+ 	if (err) {
+ 		if (err == -EEXIST)
+ 			err = -EADDRINUSE;
+ 		nlk_sk(sk)->portid = 0;
+ 		sock_put(sk);
+ 	}
+ 
++>>>>>>> c0bb07df7d98 (netlink: Reset portid after netlink_insert failure)
  err:
 -	release_sock(sk);
 +	mutex_unlock(&nl_sk_hash_lock);
  	return err;
  }
  
* Unmerged path net/netlink/af_netlink.c
