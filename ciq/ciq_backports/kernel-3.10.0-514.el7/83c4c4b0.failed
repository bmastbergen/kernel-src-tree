fsnotify: remove .should_send_event callback

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jan Kara <jack@suse.cz>
commit 83c4c4b0a3aadc1ce7b5b2870ce1fc1f65498da0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/83c4c4b0.failed

After removing event structure creation from the generic layer there is
no reason for separate .should_send_event and .handle_event callbacks.
So just remove the first one.

	Signed-off-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Cc: Eric Paris <eparis@parisplace.org>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 83c4c4b0a3aadc1ce7b5b2870ce1fc1f65498da0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/fanotify/fanotify.c
#	fs/notify/fsnotify.c
#	fs/notify/inotify/inotify_fsnotify.c
diff --cc fs/notify/fanotify/fanotify.c
index 0c2f9122b262,1f8f05220f8d..000000000000
--- a/fs/notify/fanotify/fanotify.c
+++ b/fs/notify/fanotify/fanotify.c
@@@ -125,58 -88,17 +125,69 @@@ static int fanotify_get_response_from_a
  }
  #endif
  
++<<<<<<< HEAD
 +static int fanotify_handle_event(struct fsnotify_group *group,
 +				 struct fsnotify_mark *inode_mark,
 +				 struct fsnotify_mark *fanotify_mark,
 +				 struct fsnotify_event *event)
 +{
 +	int ret = 0;
 +	struct fsnotify_event *notify_event = NULL;
 +
 +	BUILD_BUG_ON(FAN_ACCESS != FS_ACCESS);
 +	BUILD_BUG_ON(FAN_MODIFY != FS_MODIFY);
 +	BUILD_BUG_ON(FAN_CLOSE_NOWRITE != FS_CLOSE_NOWRITE);
 +	BUILD_BUG_ON(FAN_CLOSE_WRITE != FS_CLOSE_WRITE);
 +	BUILD_BUG_ON(FAN_OPEN != FS_OPEN);
 +	BUILD_BUG_ON(FAN_EVENT_ON_CHILD != FS_EVENT_ON_CHILD);
 +	BUILD_BUG_ON(FAN_Q_OVERFLOW != FS_Q_OVERFLOW);
 +	BUILD_BUG_ON(FAN_OPEN_PERM != FS_OPEN_PERM);
 +	BUILD_BUG_ON(FAN_ACCESS_PERM != FS_ACCESS_PERM);
 +	BUILD_BUG_ON(FAN_ONDIR != FS_ISDIR);
 +
 +	pr_debug("%s: group=%p event=%p\n", __func__, group, event);
 +
 +	notify_event = fsnotify_add_notify_event(group, event, NULL, fanotify_merge);
 +	if (IS_ERR(notify_event))
 +		return PTR_ERR(notify_event);
 +
 +#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
 +	if (event->mask & FAN_ALL_PERM_EVENTS) {
 +		/* if we merged we need to wait on the new event */
 +		if (notify_event)
 +			event = notify_event;
 +		ret = fanotify_get_response_from_access(group, event);
 +	}
 +#endif
 +
 +	if (notify_event)
 +		fsnotify_put_event(notify_event);
 +
 +	return ret;
 +}
 +
 +static bool fanotify_should_send_event(struct fsnotify_group *group,
 +				       struct inode *to_tell,
 +				       struct fsnotify_mark *inode_mark,
++=======
+ static bool fanotify_should_send_event(struct fsnotify_mark *inode_mark,
++>>>>>>> 83c4c4b0a3aa (fsnotify: remove .should_send_event callback)
  				       struct fsnotify_mark *vfsmnt_mark,
- 				       __u32 event_mask, void *data, int data_type)
+ 				       u32 event_mask,
+ 				       void *data, int data_type)
  {
  	__u32 marks_mask, marks_ignored_mask;
  	struct path *path = data;
  
++<<<<<<< HEAD
 +	pr_debug("%s: group=%p to_tell=%p inode_mark=%p vfsmnt_mark=%p "
 +		 "mask=%x data=%p data_type=%d\n", __func__, group, to_tell,
 +		 inode_mark, vfsmnt_mark, event_mask, data, data_type);
++=======
+ 	pr_debug("%s: inode_mark=%p vfsmnt_mark=%p mask=%x data=%p"
+ 		 " data_type=%d\n", __func__, inode_mark, vfsmnt_mark,
+ 		 event_mask, data, data_type);
++>>>>>>> 83c4c4b0a3aa (fsnotify: remove .should_send_event callback)
  
  	/* if we don't have enough info to send an event to userspace say no */
  	if (data_type != FSNOTIFY_EVENT_PATH)
@@@ -217,6 -139,74 +228,77 @@@
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ static int fanotify_handle_event(struct fsnotify_group *group,
+ 				 struct inode *inode,
+ 				 struct fsnotify_mark *inode_mark,
+ 				 struct fsnotify_mark *fanotify_mark,
+ 				 u32 mask, void *data, int data_type,
+ 				 const unsigned char *file_name)
+ {
+ 	int ret = 0;
+ 	struct fanotify_event_info *event;
+ 	struct fsnotify_event *fsn_event;
+ 	struct fsnotify_event *notify_fsn_event;
+ 
+ 	BUILD_BUG_ON(FAN_ACCESS != FS_ACCESS);
+ 	BUILD_BUG_ON(FAN_MODIFY != FS_MODIFY);
+ 	BUILD_BUG_ON(FAN_CLOSE_NOWRITE != FS_CLOSE_NOWRITE);
+ 	BUILD_BUG_ON(FAN_CLOSE_WRITE != FS_CLOSE_WRITE);
+ 	BUILD_BUG_ON(FAN_OPEN != FS_OPEN);
+ 	BUILD_BUG_ON(FAN_EVENT_ON_CHILD != FS_EVENT_ON_CHILD);
+ 	BUILD_BUG_ON(FAN_Q_OVERFLOW != FS_Q_OVERFLOW);
+ 	BUILD_BUG_ON(FAN_OPEN_PERM != FS_OPEN_PERM);
+ 	BUILD_BUG_ON(FAN_ACCESS_PERM != FS_ACCESS_PERM);
+ 	BUILD_BUG_ON(FAN_ONDIR != FS_ISDIR);
+ 
+ 	if (!fanotify_should_send_event(inode_mark, fanotify_mark, mask, data,
+ 					data_type))
+ 		return 0;
+ 
+ 	pr_debug("%s: group=%p inode=%p mask=%x\n", __func__, group, inode,
+ 		 mask);
+ 
+ 	event = kmem_cache_alloc(fanotify_event_cachep, GFP_KERNEL);
+ 	if (unlikely(!event))
+ 		return -ENOMEM;
+ 
+ 	fsn_event = &event->fse;
+ 	fsnotify_init_event(fsn_event, inode, mask);
+ 	event->tgid = get_pid(task_tgid(current));
+ 	if (data_type == FSNOTIFY_EVENT_PATH) {
+ 		struct path *path = data;
+ 		event->path = *path;
+ 		path_get(&event->path);
+ 	} else {
+ 		event->path.mnt = NULL;
+ 		event->path.dentry = NULL;
+ 	}
+ #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
+ 	event->response = 0;
+ #endif
+ 
+ 	notify_fsn_event = fsnotify_add_notify_event(group, fsn_event,
+ 						     fanotify_merge);
+ 	if (notify_fsn_event) {
+ 		/* Our event wasn't used in the end. Free it. */
+ 		fsnotify_destroy_event(group, fsn_event);
+ 		if (IS_ERR(notify_fsn_event))
+ 			return PTR_ERR(notify_fsn_event);
+ 		/* We need to ask about a different events after a merge... */
+ 		event = FANOTIFY_E(notify_fsn_event);
+ 		fsn_event = notify_fsn_event;
+ 	}
+ 
+ #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
+ 	if (fsn_event->mask & FAN_ALL_PERM_EVENTS)
+ 		ret = fanotify_get_response_from_access(group, event);
+ #endif
+ 	return ret;
+ }
+ 
++>>>>>>> 83c4c4b0a3aa (fsnotify: remove .should_send_event callback)
  static void fanotify_free_group_priv(struct fsnotify_group *group)
  {
  	struct user_struct *user;
@@@ -226,10 -216,19 +308,9 @@@
  	free_uid(user);
  }
  
 -static void fanotify_free_event(struct fsnotify_event *fsn_event)
 -{
 -	struct fanotify_event_info *event;
 -
 -	event = FANOTIFY_E(fsn_event);
 -	path_put(&event->path);
 -	put_pid(event->tgid);
 -	kmem_cache_free(fanotify_event_cachep, event);
 -}
 -
  const struct fsnotify_ops fanotify_fsnotify_ops = {
  	.handle_event = fanotify_handle_event,
- 	.should_send_event = fanotify_should_send_event,
  	.free_group_priv = fanotify_free_group_priv,
 -	.free_event = fanotify_free_event,
 +	.free_event_priv = NULL,
  	.freeing_mark = NULL,
  };
diff --cc fs/notify/fsnotify.c
index 4bb21d67d9b1,1d4e1ea2f37c..000000000000
--- a/fs/notify/fsnotify.c
+++ b/fs/notify/fsnotify.c
@@@ -178,19 -177,9 +178,25 @@@ static int send_to_group(struct inode *
  	if (!inode_test_mask && !vfsmount_test_mask)
  		return 0;
  
++<<<<<<< HEAD
 +	if (group->ops->should_send_event(group, to_tell, inode_mark,
 +					  vfsmount_mark, mask, data,
 +					  data_is) == false)
 +		return 0;
 +
 +	if (!*event) {
 +		*event = fsnotify_create_event(to_tell, mask, data,
 +						data_is, file_name,
 +						cookie, GFP_KERNEL);
 +		if (!*event)
 +			return -ENOMEM;
 +	}
 +	return group->ops->handle_event(group, inode_mark, vfsmount_mark, *event);
++=======
+ 	return group->ops->handle_event(group, to_tell, inode_mark,
+ 					vfsmount_mark, mask, data, data_is,
+ 					file_name);
++>>>>>>> 83c4c4b0a3aa (fsnotify: remove .should_send_event callback)
  }
  
  /*
diff --cc fs/notify/inotify/inotify_fsnotify.c
index 4216308b81b4,aad1a35e9af1..000000000000
--- a/fs/notify/inotify/inotify_fsnotify.c
+++ b/fs/notify/inotify/inotify_fsnotify.c
@@@ -103,10 -81,20 +103,24 @@@ static int inotify_handle_event(struct 
  
  	BUG_ON(vfsmount_mark);
  
++<<<<<<< HEAD
 +	pr_debug("%s: group=%p event=%p to_tell=%p mask=%x\n", __func__, group,
 +		 event, event->to_tell, event->mask);
++=======
+ 	if ((inode_mark->mask & FS_EXCL_UNLINK) &&
+ 	    (data_type == FSNOTIFY_EVENT_PATH)) {
+ 		struct path *path = data;
+ 
+ 		if (d_unlinked(path->dentry))
+ 			return 0;
+ 	}
+ 	if (file_name) {
+ 		len = strlen(file_name);
+ 		alloc_len += len + 1;
+ 	}
++>>>>>>> 83c4c4b0a3aa (fsnotify: remove .should_send_event callback)
  
 -	pr_debug("%s: group=%p inode=%p mask=%x\n", __func__, group, inode,
 -		 mask);
 +	to_tell = event->to_tell;
  
  	i_mark = container_of(inode_mark, struct inotify_inode_mark,
  			      fsn_mark);
@@@ -216,8 -180,7 +214,7 @@@ void inotify_free_event_priv(struct fsn
  
  const struct fsnotify_ops inotify_fsnotify_ops = {
  	.handle_event = inotify_handle_event,
- 	.should_send_event = inotify_should_send_event,
  	.free_group_priv = inotify_free_group_priv,
 -	.free_event = inotify_free_event,
 +	.free_event_priv = inotify_free_event_priv,
  	.freeing_mark = inotify_freeing_mark,
  };
diff --git a/fs/notify/dnotify/dnotify.c b/fs/notify/dnotify/dnotify.c
index 2bfe6dc413a0..3b00783905e6 100644
--- a/fs/notify/dnotify/dnotify.c
+++ b/fs/notify/dnotify/dnotify.c
@@ -94,6 +94,10 @@ static int dnotify_handle_event(struct fsnotify_group *group,
 	struct fown_struct *fown;
 	__u32 test_mask = event->mask & ~FS_EVENT_ON_CHILD;
 
+	/* not a dir, dnotify doesn't care */
+	if (!S_ISDIR(inode->i_mode))
+		return 0;
+
 	BUG_ON(vfsmount_mark);
 
 	to_tell = event->to_tell;
@@ -123,23 +127,6 @@ static int dnotify_handle_event(struct fsnotify_group *group,
 	return 0;
 }
 
-/*
- * Given an inode and mask determine if dnotify would be interested in sending
- * userspace notification for that pair.
- */
-static bool dnotify_should_send_event(struct fsnotify_group *group,
-				      struct inode *inode,
-				      struct fsnotify_mark *inode_mark,
-				      struct fsnotify_mark *vfsmount_mark,
-				      __u32 mask, void *data, int data_type)
-{
-	/* not a dir, dnotify doesn't care */
-	if (!S_ISDIR(inode->i_mode))
-		return false;
-
-	return true;
-}
-
 static void dnotify_free_mark(struct fsnotify_mark *fsn_mark)
 {
 	struct dnotify_mark *dn_mark = container_of(fsn_mark,
@@ -153,7 +140,6 @@ static void dnotify_free_mark(struct fsnotify_mark *fsn_mark)
 
 static struct fsnotify_ops dnotify_fsnotify_ops = {
 	.handle_event = dnotify_handle_event,
-	.should_send_event = dnotify_should_send_event,
 	.free_group_priv = NULL,
 	.freeing_mark = NULL,
 	.free_event_priv = NULL,
* Unmerged path fs/notify/fanotify/fanotify.c
* Unmerged path fs/notify/fsnotify.c
* Unmerged path fs/notify/inotify/inotify_fsnotify.c
diff --git a/include/linux/fsnotify_backend.h b/include/linux/fsnotify_backend.h
index 4b2ee8d12f5e..6d66a6053ec3 100644
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@ -94,10 +94,6 @@ struct fsnotify_event_private_data;
  * 		userspace messages that marks have been removed.
  */
 struct fsnotify_ops {
-	bool (*should_send_event)(struct fsnotify_group *group, struct inode *inode,
-				  struct fsnotify_mark *inode_mark,
-				  struct fsnotify_mark *vfsmount_mark,
-				  __u32 mask, void *data, int data_type);
 	int (*handle_event)(struct fsnotify_group *group,
 			    struct fsnotify_mark *inode_mark,
 			    struct fsnotify_mark *vfsmount_mark,
diff --git a/kernel/audit_tree.c b/kernel/audit_tree.c
index ea4c1d0e95c8..46c77c2c563b 100644
--- a/kernel/audit_tree.c
+++ b/kernel/audit_tree.c
@@ -917,8 +917,7 @@ static int audit_tree_handle_event(struct fsnotify_group *group,
 				   struct fsnotify_mark *vfsmonut_mark,
 				   struct fsnotify_event *event)
 {
-	BUG();
-	return -EOPNOTSUPP;
+	return 0;
 }
 
 static void audit_tree_freeing_mark(struct fsnotify_mark *entry, struct fsnotify_group *group)
@@ -934,17 +933,8 @@ static void audit_tree_freeing_mark(struct fsnotify_mark *entry, struct fsnotify
 	BUG_ON(atomic_read(&entry->refcnt) < 1);
 }
 
-static bool audit_tree_send_event(struct fsnotify_group *group, struct inode *inode,
-				  struct fsnotify_mark *inode_mark,
-				  struct fsnotify_mark *vfsmount_mark,
-				  __u32 mask, void *data, int data_type)
-{
-	return false;
-}
-
 static const struct fsnotify_ops audit_tree_ops = {
 	.handle_event = audit_tree_handle_event,
-	.should_send_event = audit_tree_send_event,
 	.free_group_priv = NULL,
 	.free_event_priv = NULL,
 	.freeing_mark = audit_tree_freeing_mark,
diff --git a/kernel/audit_watch.c b/kernel/audit_watch.c
index c7d454ea3ffd..c0f90e26248d 100644
--- a/kernel/audit_watch.c
+++ b/kernel/audit_watch.c
@@ -465,14 +465,6 @@ void audit_remove_watch_rule(struct audit_krule *krule)
 	}
 }
 
-static bool audit_watch_should_send_event(struct fsnotify_group *group, struct inode *inode,
-					  struct fsnotify_mark *inode_mark,
-					  struct fsnotify_mark *vfsmount_mark,
-					  __u32 mask, void *data, int data_type)
-{
-       return true;
-}
-
 /* Update watch data in audit rules based on fsnotify events. */
 static int audit_watch_handle_event(struct fsnotify_group *group,
 				    struct fsnotify_mark *inode_mark,
@@ -512,7 +504,6 @@ static int audit_watch_handle_event(struct fsnotify_group *group,
 }
 
 static const struct fsnotify_ops audit_watch_fsnotify_ops = {
-	.should_send_event = 	audit_watch_should_send_event,
 	.handle_event = 	audit_watch_handle_event,
 	.free_group_priv = 	NULL,
 	.freeing_mark = 	NULL,
