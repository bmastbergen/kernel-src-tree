IB/srp: Use ib_drain_rq()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Steve Wise <swise@opengridcomputing.com>
commit 561392d42d42c0fefad179a07b6dd1e6e261a572
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/561392d4.failed

	Signed-off-by: Steve Wise <swise@opengridcomputing.com>
	Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 561392d42d42c0fefad179a07b6dd1e6e261a572)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/srp/ib_srp.c
diff --cc drivers/infiniband/ulp/srp/ib_srp.c
index 207f50dbdbb8,b6bf20496021..000000000000
--- a/drivers/infiniband/ulp/srp/ib_srp.c
+++ b/drivers/infiniband/ulp/srp/ib_srp.c
@@@ -465,27 -456,7 +464,31 @@@ static struct srp_fr_pool *srp_alloc_fr
   */
  static void srp_destroy_qp(struct srp_rdma_ch *ch)
  {
++<<<<<<< HEAD
 +	static struct ib_qp_attr attr = { .qp_state = IB_QPS_ERR };
 +	static struct ib_recv_wr wr = { 0 };
 +	struct ib_recv_wr *bad_wr;
 +	int ret;
 +
 +	wr.wr_id = SRP_LAST_WR_ID;
 +	/* Destroying a QP and reusing ch->done is only safe if not connected */
 +	WARN_ON_ONCE(ch->connected);
 +
 +	ret = ib_modify_qp(ch->qp, &attr, IB_QP_STATE);
 +	WARN_ONCE(ret, "ib_cm_init_qp_attr() returned %d\n", ret);
 +	if (ret)
 +		goto out;
 +
 +	init_completion(&ch->done);
 +	ret = ib_post_recv(ch->qp, &wr, &bad_wr);
 +	WARN_ONCE(ret, "ib_post_recv() returned %d\n", ret);
 +	if (ret == 0)
 +		wait_for_completion(&ch->done);
 +
 +out:
++=======
+ 	ib_drain_rq(ch->qp);
++>>>>>>> 561392d42d42 (IB/srp: Use ib_drain_rq())
  	ib_destroy_qp(ch->qp);
  }
  
@@@ -506,11 -476,9 +509,17 @@@ static int srp_create_ch_ib(struct srp_
  	if (!init_attr)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	/* + 1 for SRP_LAST_WR_ID */
 +	cq_attr.cqe = target->queue_size + 1;
 +	cq_attr.comp_vector = ch->comp_vector;
 +	recv_cq = ib_create_cq(dev->dev, srp_recv_completion, NULL, ch,
 +			       &cq_attr);
++=======
+ 	/* queue_size + 1 for ib_drain_rq() */
+ 	recv_cq = ib_alloc_cq(dev->dev, ch, target->queue_size + 1,
+ 				ch->comp_vector, IB_POLL_SOFTIRQ);
++>>>>>>> 561392d42d42 (IB/srp: Use ib_drain_rq())
  	if (IS_ERR(recv_cq)) {
  		ret = PTR_ERR(recv_cq);
  		goto err;
* Unmerged path drivers/infiniband/ulp/srp/ib_srp.c
