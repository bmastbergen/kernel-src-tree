mei: bus: enable running fixup routines before device registration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 71ce789115f878a07e4a6c43d6006cea6aee1078
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/71ce7891.failed

Split the device registration into allocation and device struct
initialization, device setup, and the final device registration.
This why it is possible to run fixups and quirks during the setup stage
on an initialized device. Each fixup routine effects do_match flag.
If the flag is set to false at the end the device won't be
registered on the bus.

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 71ce789115f878a07e4a6c43d6006cea6aee1078)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/bus-fixup.c
#	drivers/misc/mei/bus.c
#	drivers/misc/mei/mei_dev.h
#	include/linux/mei_cl_bus.h
diff --cc drivers/misc/mei/bus-fixup.c
index 2b65e8021f0d,865e33bcd226..000000000000
--- a/drivers/misc/mei/bus-fixup.c
+++ b/drivers/misc/mei/bus-fixup.c
@@@ -19,7 -19,9 +19,13 @@@
  #include <linux/module.h>
  #include <linux/moduleparam.h>
  #include <linux/device.h>
++<<<<<<< HEAD
 +#include <linux/pci.h>
++=======
+ #include <linux/slab.h>
+ #include <linux/uuid.h>
+ 
++>>>>>>> 71ce789115f8 (mei: bus: enable running fixup routines before device registration)
  #include <linux/mei_cl_bus.h>
  
  #include "mei_dev.h"
@@@ -548,10 -385,61 +556,37 @@@ err
  	return ret;
  }
  
 -void mei_nfc_host_exit(struct mei_device *bus)
 +void mei_nfc_host_exit(struct mei_device *dev)
  {
 -	struct mei_nfc_dev *ndev;
 -	struct mei_cl *cl;
 -	struct mei_cl_device *cldev;
 -
 -	cl = mei_cl_bus_find_cl_by_uuid(bus, mei_nfc_guid);
 -	if (!cl)
 -		return;
 -
 -	cldev = cl->cldev;
 -	if (!cldev)
 -		return;
 -
 -	ndev = (struct mei_nfc_dev *)cldev->priv_data;
 -	if (ndev)
 -		cancel_work_sync(&ndev->init_work);
 -
 -	cldev->priv_data = NULL;
 -
 -	/* Need to remove the device here
 -	 * since mei_nfc_free will unlink the clients
 -	 */
 -	mei_cl_remove_device(cldev);
 -
 -	mutex_lock(&bus->device_lock);
 -	mei_nfc_free(ndev);
 -	mutex_unlock(&bus->device_lock);
 +	struct mei_nfc_dev *ndev = &nfc_dev;
 +	cancel_work_sync(&ndev->init_work);
  }
  
+ #define MEI_FIXUP(_uuid, _hook) { _uuid, _hook }
+ 
+ static struct mei_fixup {
+ 
+ 	const uuid_le uuid;
+ 	void (*hook)(struct mei_cl_device *cldev);
+ } mei_fixups[] = {};
+ 
+ /**
+  * mei_cl_dev_fixup - run fixup handlers
+  *
+  * @cldev: me client device
+  */
+ void mei_cl_dev_fixup(struct mei_cl_device *cldev)
+ {
+ 	struct mei_fixup *f;
+ 	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(mei_fixups); i++) {
+ 
+ 		f = &mei_fixups[i];
+ 		if (uuid_le_cmp(f->uuid, MEI_UUID_ANY) == 0 ||
+ 		    uuid_le_cmp(f->uuid, *uuid) == 0)
+ 			f->hook(cldev);
+ 	}
+ }
  
diff --cc drivers/misc/mei/bus.c
index 3365981198e7,68b7756bf384..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -52,6 -416,36 +52,39 @@@ static int mei_cl_device_match(struct d
  		id++;
  	}
  
++<<<<<<< HEAD
++=======
+ 	return NULL;
+ }
+ 
+ /**
+  * mei_cl_device_match  - device match function
+  *
+  * @dev: device
+  * @drv: driver
+  *
+  * Return:  1 if matching device was found 0 otherwise
+  */
+ static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
+ {
+ 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+ 	struct mei_cl_driver *cldrv = to_mei_cl_driver(drv);
+ 	const struct mei_cl_device_id *found_id;
+ 
+ 	if (!cldev)
+ 		return 0;
+ 
+ 	if (!cldev->do_match)
+ 		return 0;
+ 
+ 	if (!cldrv || !cldrv->id_table)
+ 		return 0;
+ 
+ 	found_id = mei_cl_device_find(cldev, cldrv);
+ 	if (found_id)
+ 		return 1;
+ 
++>>>>>>> 71ce789115f8 (mei: bus: enable running fixup routines before device registration)
  	return 0;
  }
  
@@@ -161,35 -636,100 +194,126 @@@ static struct mei_cl *mei_bus_find_mei_
  
  	return NULL;
  }
++<<<<<<< HEAD
 +struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops)
++=======
+ 
+ /**
+  * mei_cl_dev_alloc - initialize and allocate mei client device
+  *
+  * @bus: mei device
+  * @me_cl: me client
+  *
+  * Return: allocated device structur or NULL on allocation failure
+  */
+ static struct mei_cl_device *mei_cl_dev_alloc(struct mei_device *bus,
+ 					      struct mei_me_client *me_cl)
+ {
+ 	struct mei_cl_device *cldev;
+ 
+ 	cldev = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
+ 	if (!cldev)
+ 		return NULL;
+ 
+ 	device_initialize(&cldev->dev);
+ 	cldev->dev.parent = bus->dev;
+ 	cldev->dev.bus    = &mei_cl_bus_type;
+ 	cldev->dev.type   = &mei_cl_device_type;
+ 	cldev->bus        = mei_dev_bus_get(bus);
+ 	cldev->me_cl      = mei_me_cl_get(me_cl);
+ 	cldev->is_added   = 0;
+ 	INIT_LIST_HEAD(&cldev->bus_list);
+ 
+ 	return cldev;
+ }
+ 
+ /**
+  * mei_cl_dev_setup - setup me client device
+  *    run fix up routines and set the device name
+  *
+  * @bus: mei device
+  * @cldev: me client device
+  *
+  * Return: true if the device is eligible for enumeration
+  */
+ static bool mei_cl_dev_setup(struct mei_device *bus,
+ 			     struct mei_cl_device *cldev)
+ {
+ 	cldev->do_match = 1;
+ 	mei_cl_dev_fixup(cldev);
+ 
+ 	if (cldev->do_match)
+ 		dev_set_name(&cldev->dev, "mei:%s:%pUl",
+ 			     cldev->name, mei_me_cl_uuid(cldev->me_cl));
+ 
+ 	return cldev->do_match == 1;
+ }
+ 
+ /**
+  * mei_cl_bus_dev_add - add me client devices
+  *
+  * @cldev: me client device
+  *
+  * Return: 0 on success; < 0 on failre
+  */
+ static int mei_cl_bus_dev_add(struct mei_cl_device *cldev)
+ {
+ 	int ret;
+ 
+ 	dev_dbg(cldev->bus->dev, "adding %pUL\n", mei_me_cl_uuid(cldev->me_cl));
+ 	ret = device_add(&cldev->dev);
+ 	if (!ret)
+ 		cldev->is_added = 1;
+ 
+ 	return ret;
+ }
+ 
+ struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
+ 					struct mei_me_client *me_cl,
+ 					struct mei_cl *cl,
+ 					char *name)
++>>>>>>> 71ce789115f8 (mei: bus: enable running fixup routines before device registration)
  {
 -	struct mei_cl_device *cldev;
 +	struct mei_cl_device *device;
 +	struct mei_cl *cl;
  	int status;
  
++<<<<<<< HEAD
 +	cl = mei_bus_find_mei_cl_by_uuid(dev, uuid);
 +	if (cl == NULL)
 +		return NULL;
 +
 +	device = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
 +	if (!device)
 +		return NULL;
 +
 +	device->cl = cl;
 +	device->ops = ops;
 +
 +	device->dev.parent = &dev->pdev->dev;
 +	device->dev.bus = &mei_cl_bus_type;
 +	device->dev.type = &mei_cl_device_type;
 +
 +	dev_set_name(&device->dev, "%s", name);
 +
 +	status = device_register(&device->dev);
++=======
+ 	cldev = mei_cl_dev_alloc(bus, me_cl);
+ 	if (!cldev)
+ 		return NULL;
+ 
+ 	cldev->cl = cl;
+ 	strlcpy(cldev->name, name, sizeof(cldev->name));
+ 
+ 	mei_cl_dev_setup(bus, cldev);
+ 
+ 	status = mei_cl_bus_dev_add(cldev);
++>>>>>>> 71ce789115f8 (mei: bus: enable running fixup routines before device registration)
  	if (status) {
 -		dev_err(bus->dev, "Failed to register MEI device\n");
 -		mei_me_cl_put(cldev->me_cl);
 -		mei_dev_bus_put(bus);
 -		kfree(cldev);
 +		dev_err(&dev->pdev->dev, "Failed to register MEI device\n");
 +		kfree(device);
  		return NULL;
  	}
  
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,ad59ab776f2d..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -289,74 -330,22 +289,86 @@@ struct mei_hw_ops 
  
  /* MEI bus API*/
  
++<<<<<<< HEAD
 +/**
 + * struct mei_cl_ops - MEI CL device ops
 + * This structure allows ME host clients to implement technology
 + * specific operations.
 + *
 + * @enable: Enable an MEI CL device. Some devices require specific
 + *	HECI commands to initialize completely.
 + * @disable: Disable an MEI CL device.
 + * @send: Tx hook for the device. This allows ME host clients to trap
 + *	the device driver buffers before actually physically
 + *	pushing it to the ME.
 + * @recv: Rx hook for the device. This allows ME host clients to trap the
 + *	ME buffers before forwarding them to the device driver.
 + */
 +struct mei_cl_ops {
 +	int (*enable)(struct mei_cl_device *device);
 +	int (*disable)(struct mei_cl_device *device);
 +	int (*send)(struct mei_cl_device *device, u8 *buf, size_t length);
 +	int (*recv)(struct mei_cl_device *device, u8 *buf, size_t length);
 +};
 +
 +struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops);
 +void mei_cl_remove_device(struct mei_cl_device *device);
 +
 +int __mei_cl_async_send(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
++=======
+ struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
+ 					struct mei_me_client *me_cl,
+ 					struct mei_cl *cl,
+ 					char *name);
+ void mei_cl_remove_device(struct mei_cl_device *cldev);
+ void mei_cl_dev_fixup(struct mei_cl_device *dev);
+ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
+ 			bool blocking);
+ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
++>>>>>>> 71ce789115f8 (mei: bus: enable running fixup routines before device registration)
  void mei_cl_bus_rx_event(struct mei_cl *cl);
 -void mei_cl_bus_remove_devices(struct mei_device *bus);
 +void mei_cl_bus_remove_devices(struct mei_device *dev);
  int mei_cl_bus_init(void);
  void mei_cl_bus_exit(void);
 -struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *bus, uuid_le uuid);
 +
  
  /**
 + * struct mei_cl_device - MEI device handle
 + * An mei_cl_device pointer is returned from mei_add_device()
 + * and links MEI bus clients to their actual ME host client pointer.
 + * Drivers for MEI devices will get an mei_cl_device pointer
 + * when being probed and shall use it for doing ME bus I/O.
 + *
 + * @dev: linux driver model device pointer
 + * @uuid: me client uuid
 + * @cl: mei client
 + * @ops: ME transport ops
 + * @event_cb: Drivers register this callback to get asynchronous ME
 + *	events (e.g. Rx buffer pending) notifications.
 + * @events: Events bitmask sent to the driver.
 + * @priv_data: client private data
 + */
 +struct mei_cl_device {
 +	struct device dev;
 +
 +	struct mei_cl *cl;
 +
 +	const struct mei_cl_ops *ops;
 +
 +	struct work_struct event_work;
 +	mei_cl_event_cb_t event_cb;
 +	void *event_context;
 +	unsigned long events;
 +
 +	void *priv_data;
 +};
 +
 +
 + /**
   * enum mei_pg_event - power gating transition events
   *
   * @MEI_PG_EVENT_IDLE: the driver is not in power gating transition
diff --cc include/linux/mei_cl_bus.h
index d14af7b722ef,81ab56dd0ae0..000000000000
--- a/include/linux/mei_cl_bus.h
+++ b/include/linux/mei_cl_bus.h
@@@ -3,8 -3,56 +3,58 @@@
  
  #include <linux/device.h>
  #include <linux/uuid.h>
 -#include <linux/mod_devicetable.h>
  
  struct mei_cl_device;
++<<<<<<< HEAD
++=======
+ struct mei_device;
+ 
+ typedef void (*mei_cl_event_cb_t)(struct mei_cl_device *device,
+ 			       u32 events, void *context);
+ 
+ /**
+  * struct mei_cl_device - MEI device handle
+  * An mei_cl_device pointer is returned from mei_add_device()
+  * and links MEI bus clients to their actual ME host client pointer.
+  * Drivers for MEI devices will get an mei_cl_device pointer
+  * when being probed and shall use it for doing ME bus I/O.
+  *
+  * @bus_list: device on the bus list
+  * @bus: parent mei device
+  * @dev: linux driver model device pointer
+  * @me_cl: me client
+  * @cl: mei client
+  * @name: device name
+  * @event_work: async work to execute event callback
+  * @event_cb: Drivers register this callback to get asynchronous ME
+  *	events (e.g. Rx buffer pending) notifications.
+  * @event_context: event callback run context
+  * @events: Events bitmask sent to the driver.
+  *
+  * @do_match: wheather device can be matched with a driver
+  * @is_added: device is already scanned
+  * @priv_data: client private data
+  */
+ struct mei_cl_device {
+ 	struct list_head bus_list;
+ 	struct mei_device *bus;
+ 	struct device dev;
+ 
+ 	struct mei_me_client *me_cl;
+ 	struct mei_cl *cl;
+ 	char name[MEI_CL_NAME_SIZE];
+ 
+ 	struct work_struct event_work;
+ 	mei_cl_event_cb_t event_cb;
+ 	void *event_context;
+ 	unsigned long events;
+ 
+ 	unsigned int do_match:1;
+ 	unsigned int is_added:1;
+ 
+ 	void *priv_data;
+ };
++>>>>>>> 71ce789115f8 (mei: bus: enable running fixup routines before device registration)
  
  struct mei_cl_driver {
  	struct device_driver driver;
* Unmerged path drivers/misc/mei/bus-fixup.c
* Unmerged path drivers/misc/mei/bus.c
* Unmerged path drivers/misc/mei/mei_dev.h
* Unmerged path include/linux/mei_cl_bus.h
