staging/rdma/hfi1: Remove qpdev and qpn table from hfi1

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Remove qpdev and qpn table from hfi1 (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 92.16%
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit 1c4b7d971d6679277844cefc0f5c191c800bf955
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1c4b7d97.failed

Another change on the way to removing queue pair functionality from
hfi1. This patch removes the private queue pair structure and the table
which holds the queue pair numbers in favor of using what is provided
by rdmavt.

	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Reviewed-by: Harish Chegondi <harish.chegondi@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 1c4b7d971d6679277844cefc0f5c191c800bf955)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/qp.c
#	drivers/staging/hfi1/qp.h
#	drivers/staging/rdma/hfi1/verbs.h
diff --cc drivers/staging/hfi1/qp.c
index 9ffed6e14d8e,1bf8083fcef2..000000000000
--- a/drivers/staging/hfi1/qp.c
+++ b/drivers/staging/hfi1/qp.c
@@@ -235,15 -233,15 +233,15 @@@ static void insert_qp(struct hfi1_ibde
  	unsigned long flags;
  
  	atomic_inc(&qp->refcount);
- 	spin_lock_irqsave(&dev->qp_dev->qpt_lock, flags);
+ 	spin_lock_irqsave(&dev->rdi.qp_dev->qpt_lock, flags);
  
  	if (qp->ibqp.qp_num <= 1) {
 -		rcu_assign_pointer(ibp->rvp.qp[qp->ibqp.qp_num], qp);
 +		rcu_assign_pointer(ibp->qp[qp->ibqp.qp_num], qp);
  	} else {
- 		u32 n = qpn_hash(dev->qp_dev, qp->ibqp.qp_num);
+ 		u32 n = qpn_hash(dev->rdi.qp_dev, qp->ibqp.qp_num);
  
- 		qp->next = dev->qp_dev->qp_table[n];
- 		rcu_assign_pointer(dev->qp_dev->qp_table[n], qp);
+ 		qp->next = dev->rdi.qp_dev->qp_table[n];
+ 		rcu_assign_pointer(dev->rdi.qp_dev->qp_table[n], qp);
  		trace_hfi1_qpinsert(qp, n);
  	}
  
@@@ -254,29 -252,30 +252,39 @@@
   * Remove the QP from the table so it can't be found asynchronously by
   * the receive interrupt routine.
   */
 -static void remove_qp(struct hfi1_ibdev *dev, struct rvt_qp *qp)
 +static void remove_qp(struct hfi1_ibdev *dev, struct hfi1_qp *qp)
  {
  	struct hfi1_ibport *ibp = to_iport(qp->ibqp.device, qp->port_num);
- 	u32 n = qpn_hash(dev->qp_dev, qp->ibqp.qp_num);
+ 	u32 n = qpn_hash(dev->rdi.qp_dev, qp->ibqp.qp_num);
  	unsigned long flags;
  	int removed = 1;
  
- 	spin_lock_irqsave(&dev->qp_dev->qpt_lock, flags);
+ 	spin_lock_irqsave(&dev->rdi.qp_dev->qpt_lock, flags);
  
++<<<<<<< HEAD:drivers/staging/hfi1/qp.c
 +	if (rcu_dereference_protected(ibp->qp[0],
 +			lockdep_is_held(&dev->qp_dev->qpt_lock)) == qp) {
 +		RCU_INIT_POINTER(ibp->qp[0], NULL);
 +	} else if (rcu_dereference_protected(ibp->qp[1],
 +			lockdep_is_held(&dev->qp_dev->qpt_lock)) == qp) {
 +		RCU_INIT_POINTER(ibp->qp[1], NULL);
++=======
+ 	if (rcu_dereference_protected(ibp->rvp.qp[0],
+ 				      lockdep_is_held(
+ 				      &dev->rdi.qp_dev->qpt_lock)) == qp) {
+ 		RCU_INIT_POINTER(ibp->rvp.qp[0], NULL);
+ 	} else if (rcu_dereference_protected(ibp->rvp.qp[1],
+ 			lockdep_is_held(&dev->rdi.qp_dev->qpt_lock)) == qp) {
+ 		RCU_INIT_POINTER(ibp->rvp.qp[1], NULL);
++>>>>>>> 1c4b7d971d66 (staging/rdma/hfi1: Remove qpdev and qpn table from hfi1):drivers/staging/rdma/hfi1/qp.c
  	} else {
 -		struct rvt_qp *q;
 -		struct rvt_qp __rcu **qpp;
 +		struct hfi1_qp *q;
 +		struct hfi1_qp __rcu **qpp;
  
  		removed = 0;
- 		qpp = &dev->qp_dev->qp_table[n];
+ 		qpp = &dev->rdi.qp_dev->qp_table[n];
  		for (; (q = rcu_dereference_protected(*qpp,
- 				lockdep_is_held(&dev->qp_dev->qpt_lock)))
+ 				lockdep_is_held(&dev->rdi.qp_dev->qpt_lock)))
  					!= NULL;
  				qpp = &q->next)
  			if (q == qp) {
@@@ -308,8 -307,9 +316,9 @@@ static unsigned free_all_qps(struct hfi
  {
  	struct hfi1_ibdev *dev = &dd->verbs_dev;
  	unsigned long flags;
 -	struct rvt_qp *qp;
 +	struct hfi1_qp *qp;
  	unsigned n, qp_inuse = 0;
+ 	spinlock_t *l; /* useless pointer to shutup checkpatch */
  
  	for (n = 0; n < dd->num_pports; n++) {
  		struct hfi1_ibport *ibp = &dd->pport[n].ibport_data;
@@@ -1152,10 -1154,11 +1162,11 @@@ struct ib_qp *hfi1_create_qp(struct ib_
  		qp->s_size = init_attr->cap.max_send_wr + 1;
  		qp->s_max_sge = init_attr->cap.max_send_sge;
  		if (init_attr->sq_sig_type == IB_SIGNAL_REQ_WR)
 -			qp->s_flags = RVT_S_SIGNAL_REQ_WR;
 +			qp->s_flags = HFI1_S_SIGNAL_REQ_WR;
  		dev = to_idev(ibpd->device);
  		dd = dd_from_dev(dev);
- 		err = alloc_qpn(dd, &dev->qp_dev->qpn_table, init_attr->qp_type,
+ 		err = alloc_qpn(dd, &dev->rdi.qp_dev->qpn_table,
+ 				init_attr->qp_type,
  				init_attr->port_num);
  		if (err < 0) {
  			ret = ERR_PTR(err);
@@@ -1254,10 -1257,10 +1265,10 @@@
  
  bail_ip:
  	if (qp->ip)
 -		kref_put(&qp->ip->ref, rvt_release_mmap_info);
 +		kref_put(&qp->ip->ref, hfi1_release_mmap_info);
  	else
  		vfree(qp->r_rq.wq);
- 	free_qpn(&dev->qp_dev->qpn_table, qp->ibqp.qp_num);
+ 	free_qpn(&dev->rdi.qp_dev->qpn_table, qp->ibqp.qp_num);
  bail_qp:
  	kfree(priv->s_hdr);
  	kfree(priv);
@@@ -1635,12 -1638,12 +1646,12 @@@ int qp_iter_next(struct qp_iter *iter
  				ibp = &ppd->ibport_data;
  
  				if (!(n & 1))
 -					qp = rcu_dereference(ibp->rvp.qp[0]);
 +					qp = rcu_dereference(ibp->qp[0]);
  				else
 -					qp = rcu_dereference(ibp->rvp.qp[1]);
 +					qp = rcu_dereference(ibp->qp[1]);
  			} else {
  				qp = rcu_dereference(
- 					dev->qp_dev->qp_table[
+ 					dev->rdi.qp_dev->qp_table[
  						(n - iter->specials)]);
  			}
  		}
diff --cc drivers/staging/hfi1/qp.h
index 1144470a6bc0,18b0f0ed6ee3..000000000000
--- a/drivers/staging/hfi1/qp.h
+++ b/drivers/staging/hfi1/qp.h
@@@ -54,38 -55,7 +55,42 @@@
  #include "verbs.h"
  #include "sdma.h"
  
++<<<<<<< HEAD:drivers/staging/hfi1/qp.h
 +#define QPN_MAX                 (1 << 24)
 +#define QPNMAP_ENTRIES          (QPN_MAX / PAGE_SIZE / BITS_PER_BYTE)
 +
 +/*
 + * QPN-map pages start out as NULL, they get allocated upon
 + * first use and are never deallocated. This way,
 + * large bitmaps are not allocated unless large numbers of QPs are used.
 + */
 +struct qpn_map {
 +	void *page;
 +};
 +
 +struct hfi1_qpn_table {
 +	spinlock_t lock; /* protect changes in this struct */
 +	unsigned flags;         /* flags for QP0/1 allocated for each port */
 +	u32 last;               /* last QP number allocated */
 +	u32 nmaps;              /* size of the map table */
 +	u16 limit;
 +	u8  incr;
 +	/* bit map of free QP numbers other than 0/1 */
 +	struct qpn_map map[QPNMAP_ENTRIES];
 +};
 +
 +struct hfi1_qp_ibdev {
 +	u32 qp_table_size;
 +	u32 qp_table_bits;
 +	struct hfi1_qp __rcu **qp_table;
 +	spinlock_t qpt_lock;
 +	struct hfi1_qpn_table qpn_table;
 +};
 +
 +static inline u32 qpn_hash(struct hfi1_qp_ibdev *dev, u32 qpn)
++=======
+ static inline u32 qpn_hash(struct rvt_qp_ibdev *dev, u32 qpn)
++>>>>>>> 1c4b7d971d66 (staging/rdma/hfi1: Remove qpdev and qpn table from hfi1):drivers/staging/rdma/hfi1/qp.h
  {
  	return hash_32(qpn, dev->qp_table_bits);
  }
@@@ -98,18 -68,18 +103,18 @@@
   * The caller must hold the rcu_read_lock(), and keep the lock until
   * the returned qp is no longer in use.
   */
 -static inline struct rvt_qp *hfi1_lookup_qpn(struct hfi1_ibport *ibp,
 -					     u32 qpn) __must_hold(RCU)
 +static inline struct hfi1_qp *hfi1_lookup_qpn(struct hfi1_ibport *ibp,
 +				u32 qpn) __must_hold(RCU)
  {
 -	struct rvt_qp *qp = NULL;
 +	struct hfi1_qp *qp = NULL;
  
  	if (unlikely(qpn <= 1)) {
 -		qp = rcu_dereference(ibp->rvp.qp[qpn]);
 +		qp = rcu_dereference(ibp->qp[qpn]);
  	} else {
  		struct hfi1_ibdev *dev = &ppd_from_ibp(ibp)->dd->verbs_dev;
- 		u32 n = qpn_hash(dev->qp_dev, qpn);
+ 		u32 n = qpn_hash(dev->rdi.qp_dev, qpn);
  
- 		for (qp = rcu_dereference(dev->qp_dev->qp_table[n]); qp;
+ 		for (qp = rcu_dereference(dev->rdi.qp_dev->qp_table[n]); qp;
  			qp = rcu_dereference(qp->next))
  			if (qp->ibqp.qp_num == qpn)
  				break;
* Unmerged path drivers/staging/rdma/hfi1/verbs.h
* Unmerged path drivers/staging/hfi1/qp.c
* Unmerged path drivers/staging/hfi1/qp.h
* Unmerged path drivers/staging/rdma/hfi1/verbs.h
