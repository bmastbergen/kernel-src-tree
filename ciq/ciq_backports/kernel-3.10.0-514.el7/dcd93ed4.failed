netfilter: nf_conntrack: remove dead code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author stephen hemminger <stephen@networkplumber.org>
commit dcd93ed4cd1669b2c1510e801fe5f1132390761c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/dcd93ed4.failed

The following code is not used in current upstream code.
Some of this seems to be old hooks, other might be used by some
out of tree module (which I don't care about breaking), and
the need_ipv4_conntrack was used by old NAT code but no longer
called.

	Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit dcd93ed4cd1669b2c1510e801fe5f1132390761c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_core.c
diff --cc net/netfilter/nf_conntrack_core.c
index fe40958970b4,8824ed0ccc9c..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -60,65 -60,8 +60,70 @@@ int (*nfnetlink_parse_nat_setup_hook)(s
  				      const struct nlattr *attr) __read_mostly;
  EXPORT_SYMBOL_GPL(nfnetlink_parse_nat_setup_hook);
  
++<<<<<<< HEAD
 +int (*nf_nat_seq_adjust_hook)(struct sk_buff *skb,
 +			      struct nf_conn *ct,
 +			      enum ip_conntrack_info ctinfo,
 +			      unsigned int protoff);
 +EXPORT_SYMBOL_GPL(nf_nat_seq_adjust_hook);
 +
 +__cacheline_aligned_in_smp spinlock_t nf_conntrack_locks[CONNTRACK_LOCKS];
 +EXPORT_SYMBOL_GPL(nf_conntrack_locks);
 +
 +__cacheline_aligned_in_smp DEFINE_SPINLOCK(nf_conntrack_expect_lock);
 +EXPORT_SYMBOL_GPL(nf_conntrack_expect_lock);
 +
 +static void nf_conntrack_double_unlock(unsigned int h1, unsigned int h2)
 +{
 +	h1 %= CONNTRACK_LOCKS;
 +	h2 %= CONNTRACK_LOCKS;
 +	spin_unlock(&nf_conntrack_locks[h1]);
 +	if (h1 != h2)
 +		spin_unlock(&nf_conntrack_locks[h2]);
 +}
 +
 +/* return true if we need to recompute hashes (in case hash table was resized) */
 +static bool nf_conntrack_double_lock(struct net *net, unsigned int h1,
 +				     unsigned int h2, unsigned int sequence)
 +{
 +	h1 %= CONNTRACK_LOCKS;
 +	h2 %= CONNTRACK_LOCKS;
 +	if (h1 <= h2) {
 +		spin_lock(&nf_conntrack_locks[h1]);
 +		if (h1 != h2)
 +			spin_lock_nested(&nf_conntrack_locks[h2],
 +					 SINGLE_DEPTH_NESTING);
 +	} else {
 +		spin_lock(&nf_conntrack_locks[h2]);
 +		spin_lock_nested(&nf_conntrack_locks[h1],
 +				 SINGLE_DEPTH_NESTING);
 +	}
 +	if (read_seqcount_retry(&net->ct.generation, sequence)) {
 +		nf_conntrack_double_unlock(h1, h2);
 +		return true;
 +	}
 +	return false;
 +}
 +
 +static void nf_conntrack_all_lock(void)
 +{
 +	int i;
 +
 +	for (i = 0; i < CONNTRACK_LOCKS; i++)
 +		spin_lock_nested(&nf_conntrack_locks[i], i);
 +}
 +
 +static void nf_conntrack_all_unlock(void)
 +{
 +	int i;
 +
 +	for (i = 0; i < CONNTRACK_LOCKS; i++)
 +		spin_unlock(&nf_conntrack_locks[i]);
 +}
++=======
+ DEFINE_SPINLOCK(nf_conntrack_lock);
+ EXPORT_SYMBOL_GPL(nf_conntrack_lock);
++>>>>>>> dcd93ed4cd16 (netfilter: nf_conntrack: remove dead code)
  
  unsigned int nf_conntrack_htable_size __read_mostly;
  EXPORT_SYMBOL_GPL(nf_conntrack_htable_size);
diff --git a/include/net/netfilter/ipv4/nf_conntrack_ipv4.h b/include/net/netfilter/ipv4/nf_conntrack_ipv4.h
index 6c3d12e2949f..981c327374da 100644
--- a/include/net/netfilter/ipv4/nf_conntrack_ipv4.h
+++ b/include/net/netfilter/ipv4/nf_conntrack_ipv4.h
@@ -19,6 +19,4 @@ extern struct nf_conntrack_l4proto nf_conntrack_l4proto_icmp;
 int nf_conntrack_ipv4_compat_init(void);
 void nf_conntrack_ipv4_compat_fini(void);
 
-void need_ipv4_conntrack(void);
-
 #endif /*_NF_CONNTRACK_IPV4_H*/
diff --git a/include/net/netfilter/nf_conntrack_l3proto.h b/include/net/netfilter/nf_conntrack_l3proto.h
index 3efab704b7eb..adc1fa3dd7ab 100644
--- a/include/net/netfilter/nf_conntrack_l3proto.h
+++ b/include/net/netfilter/nf_conntrack_l3proto.h
@@ -87,7 +87,6 @@ int nf_ct_l3proto_register(struct nf_conntrack_l3proto *proto);
 void nf_ct_l3proto_unregister(struct nf_conntrack_l3proto *proto);
 
 struct nf_conntrack_l3proto *nf_ct_l3proto_find_get(u_int16_t l3proto);
-void nf_ct_l3proto_put(struct nf_conntrack_l3proto *p);
 
 /* Existing built-in protocols */
 extern struct nf_conntrack_l3proto nf_conntrack_l3proto_generic;
diff --git a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
index a4a843dcd385..96958be151ec 100644
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
@@ -548,9 +548,3 @@ static void __exit nf_conntrack_l3proto_ipv4_fini(void)
 
 module_init(nf_conntrack_l3proto_ipv4_init);
 module_exit(nf_conntrack_l3proto_ipv4_fini);
-
-void need_ipv4_conntrack(void)
-{
-	return;
-}
-EXPORT_SYMBOL_GPL(need_ipv4_conntrack);
* Unmerged path net/netfilter/nf_conntrack_core.c
diff --git a/net/netfilter/nf_conntrack_proto.c b/net/netfilter/nf_conntrack_proto.c
index ce3004156eeb..b65d5864b6d9 100644
--- a/net/netfilter/nf_conntrack_proto.c
+++ b/net/netfilter/nf_conntrack_proto.c
@@ -92,12 +92,6 @@ nf_ct_l3proto_find_get(u_int16_t l3proto)
 }
 EXPORT_SYMBOL_GPL(nf_ct_l3proto_find_get);
 
-void nf_ct_l3proto_put(struct nf_conntrack_l3proto *p)
-{
-	module_put(p->me);
-}
-EXPORT_SYMBOL_GPL(nf_ct_l3proto_put);
-
 int
 nf_ct_l3proto_try_module_get(unsigned short l3proto)
 {
