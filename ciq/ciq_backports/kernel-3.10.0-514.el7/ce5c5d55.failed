dax: expose __dax_fault for filesystems with locking constraints

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit ce5c5d554dc47a4fb4360c84b72231fea081e7a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ce5c5d55.failed

Some filesystems cannot call dax_fault() directly because they have
different locking and/or allocation constraints in the page fault IO
path. To handle this, we need to follow the same model as the
generic block_page_mkwrite code, where the internals are exposed via
__block_page_mkwrite() so that filesystems can wrap the correct
locking and operations around the outside. 

This is loosely based on a patch originally from Matthew Willcox.
Unlike the original patch, it does not change ext4 code, error
returns or unwritten extent conversion handling.  It also adds a
__dax_mkwrite() wrapper for .page_mkwrite implementations to do the
right thing, too.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit ce5c5d554dc47a4fb4360c84b72231fea081e7a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
#	include/linux/fs.h
diff --cc include/linux/fs.h
index 37d4ac39152e,5784377e7c56..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -2706,19 -2623,18 +2706,34 @@@ extern loff_t fixed_size_llseek(struct 
  extern int generic_file_open(struct inode * inode, struct file * filp);
  extern int nonseekable_open(struct inode * inode, struct file * filp);
  
++<<<<<<< HEAD
 +#ifdef CONFIG_FS_XIP
 +extern ssize_t xip_file_read(struct file *filp, char __user *buf, size_t len,
 +			     loff_t *ppos);
 +extern int xip_file_mmap(struct file * file, struct vm_area_struct * vma);
 +extern ssize_t xip_file_write(struct file *filp, const char __user *buf,
 +			      size_t len, loff_t *ppos);
 +extern int xip_truncate_page(struct address_space *mapping, loff_t from);
 +#else
 +static inline int xip_truncate_page(struct address_space *mapping, loff_t from)
 +{
 +	return 0;
 +}
 +#endif
++=======
+ ssize_t dax_do_io(struct kiocb *, struct inode *, struct iov_iter *, loff_t,
+ 		  get_block_t, dio_iodone_t, int flags);
+ int dax_clear_blocks(struct inode *, sector_t block, long size);
+ int dax_zero_page_range(struct inode *, loff_t from, unsigned len, get_block_t);
+ int dax_truncate_page(struct inode *, loff_t from, get_block_t);
+ int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t,
+ 		dax_iodone_t);
+ int __dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t,
+ 		dax_iodone_t);
+ int dax_pfn_mkwrite(struct vm_area_struct *, struct vm_fault *);
+ #define dax_mkwrite(vma, vmf, gb, iod)		dax_fault(vma, vmf, gb, iod)
+ #define __dax_mkwrite(vma, vmf, gb, iod)	__dax_fault(vma, vmf, gb, iod)
++>>>>>>> ce5c5d554dc4 (dax: expose __dax_fault for filesystems with locking constraints)
  
  #ifdef CONFIG_BLOCK
  typedef void (dio_submit_t)(int rw, struct bio *bio, struct inode *inode,
* Unmerged path fs/dax.c
* Unmerged path fs/dax.c
* Unmerged path include/linux/fs.h
