IB/mlx4: Enable send of RoCE QP1 packets with IP/UDP headers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Moni Shoua <monis@mellanox.com>
commit 3ef967a4affeef7bb3b7713dcfed6518b99737c6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3ef967a4.failed

RoCEv2 packets are sent over IP/UDP protocols.
The mlx4 driver uses a type of RAW QP to send packets for QP1 and
therefore needs to build the network headers below BTH in software.

This patch adds option to build QP1 packets with IP and UDP headers if
RoCEv2 is requested.

	Signed-off-by: Moni Shoua <monis@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 3ef967a4affeef7bb3b7713dcfed6518b99737c6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/ud_header.c
#	drivers/infiniband/hw/mlx4/qp.c
#	include/rdma/ib_pack.h
diff --cc drivers/infiniband/core/ud_header.c
index 72feee620ebf,19837d270278..000000000000
--- a/drivers/infiniband/core/ud_header.c
+++ b/drivers/infiniband/core/ud_header.c
@@@ -213,6 -280,26 +213,29 @@@ static const struct ib_field deth_table
  	  .size_bits    = 24 }
  };
  
++<<<<<<< HEAD
++=======
+ __sum16 ib_ud_ip4_csum(struct ib_ud_header *header)
+ {
+ 	struct iphdr iph;
+ 
+ 	iph.ihl		= 5;
+ 	iph.version	= 4;
+ 	iph.tos		= header->ip4.tos;
+ 	iph.tot_len	= header->ip4.tot_len;
+ 	iph.id		= header->ip4.id;
+ 	iph.frag_off	= header->ip4.frag_off;
+ 	iph.ttl		= header->ip4.ttl;
+ 	iph.protocol	= header->ip4.protocol;
+ 	iph.check	= 0;
+ 	iph.saddr	= header->ip4.saddr;
+ 	iph.daddr	= header->ip4.daddr;
+ 
+ 	return ip_fast_csum((u8 *)&iph, iph.ihl);
+ }
+ EXPORT_SYMBOL(ib_ud_ip4_csum);
+ 
++>>>>>>> 3ef967a4affe (IB/mlx4: Enable send of RoCE QP1 packets with IP/UDP headers)
  /**
   * ib_ud_header_init - Initialize UD header structure
   * @payload_bytes:Length of packet payload
diff --cc drivers/infiniband/hw/mlx4/qp.c
index 13bb6bffd98e,7d1024655305..000000000000
--- a/drivers/infiniband/hw/mlx4/qp.c
+++ b/drivers/infiniband/hw/mlx4/qp.c
@@@ -32,6 -32,8 +32,11 @@@
   */
  
  #include <linux/log2.h>
++<<<<<<< HEAD
++=======
+ #include <linux/etherdevice.h>
+ #include <net/ip.h>
++>>>>>>> 3ef967a4affe (IB/mlx4: Enable send of RoCE QP1 packets with IP/UDP headers)
  #include <linux/slab.h>
  #include <linux/netdevice.h>
  #include <linux/vmalloc.h>
@@@ -2225,17 -2286,8 +2230,22 @@@ static int build_sriov_qp0_header(struc
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void mlx4_u64_to_smac(u8 *dst_mac, u64 src_mac)
 +{
 +	int i;
 +
 +	for (i = ETH_ALEN; i; i--) {
 +		dst_mac[i - 1] = src_mac & 0xff;
 +		src_mac >>= 8;
 +	}
 +}
 +
 +static int build_mlx_header(struct mlx4_ib_sqp *sqp, struct ib_send_wr *wr,
++=======
+ #define MLX4_ROCEV2_QP1_SPORT 0xC000
+ static int build_mlx_header(struct mlx4_ib_sqp *sqp, struct ib_ud_wr *wr,
++>>>>>>> 3ef967a4affe (IB/mlx4: Enable send of RoCE QP1 packets with IP/UDP headers)
  			    void *wqe, unsigned *mlx_seg_len)
  {
  	struct ib_device *ib_dev = sqp->qp.ibqp.device;
@@@ -2254,10 -2306,12 +2264,12 @@@
  	bool is_eth;
  	bool is_vlan = false;
  	bool is_grh;
+ 	bool is_udp = false;
+ 	int ip_version = 0;
  
  	send_size = 0;
 -	for (i = 0; i < wr->wr.num_sge; ++i)
 -		send_size += wr->wr.sg_list[i].length;
 +	for (i = 0; i < wr->num_sge; ++i)
 +		send_size += wr->sg_list[i].length;
  
  	is_eth = rdma_port_get_link_layer(sqp->qp.ibqp.device, sqp->qp.port) == IB_LINK_LAYER_ETHERNET;
  	is_grh = mlx4_ib_ah_grh_present(ah);
@@@ -2274,17 -2330,36 +2288,45 @@@
  		} else  {
  			err = ib_get_cached_gid(ib_dev,
  						be32_to_cpu(ah->av.ib.port_pd) >> 24,
++<<<<<<< HEAD
 +						ah->av.ib.gid_index, &sgid);
 +			if (err)
++=======
+ 						ah->av.ib.gid_index, &sgid,
+ 						&gid_attr);
+ 			if (!err) {
+ 				if (gid_attr.ndev)
+ 					dev_put(gid_attr.ndev);
+ 				if (!memcmp(&sgid, &zgid, sizeof(sgid)))
+ 					err = -ENOENT;
+ 			}
+ 			if (!err) {
+ 				is_udp = gid_attr.gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP;
+ 				if (is_udp) {
+ 					if (ipv6_addr_v4mapped((struct in6_addr *)&sgid))
+ 						ip_version = 4;
+ 					else
+ 						ip_version = 6;
+ 					is_grh = false;
+ 				}
+ 			} else {
++>>>>>>> 3ef967a4affe (IB/mlx4: Enable send of RoCE QP1 packets with IP/UDP headers)
  				return err;
+ 			}
  		}
- 
  		if (ah->av.eth.vlan != cpu_to_be16(0xffff)) {
  			vlan = be16_to_cpu(ah->av.eth.vlan) & 0x0fff;
  			is_vlan = 1;
  		}
  	}
++<<<<<<< HEAD
 +	ib_ud_header_init(send_size, !is_eth, is_eth, is_vlan, is_grh, 0, &sqp->ud_header);
++=======
+ 	err = ib_ud_header_init(send_size, !is_eth, is_eth, is_vlan, is_grh,
+ 			  ip_version, is_udp, 0, &sqp->ud_header);
+ 	if (err)
+ 		return err;
++>>>>>>> 3ef967a4affe (IB/mlx4: Enable send of RoCE QP1 packets with IP/UDP headers)
  
  	if (!is_eth) {
  		sqp->ud_header.lrh.service_level =
@@@ -2350,13 -2444,16 +2411,20 @@@
  
  	if (is_eth) {
  		struct in6_addr in6;
++<<<<<<< HEAD
 +
++=======
+ 		u16 ether_type;
++>>>>>>> 3ef967a4affe (IB/mlx4: Enable send of RoCE QP1 packets with IP/UDP headers)
  		u16 pcp = (be32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 29) << 13;
  
+ 		ether_type = (!is_udp) ? MLX4_IB_IBOE_ETHERTYPE :
+ 			(ip_version == 4 ? ETH_P_IP : ETH_P_IPV6);
+ 
  		mlx->sched_prio = cpu_to_be16(pcp);
  
 -		ether_addr_copy(sqp->ud_header.eth.smac_h, ah->av.eth.s_mac);
  		memcpy(sqp->ud_header.eth.dmac_h, ah->av.eth.mac, 6);
 +		/* FIXME: cache smac value? */
  		memcpy(&ctrl->srcrb_flags16[0], ah->av.eth.mac, 2);
  		memcpy(&ctrl->imm, ah->av.eth.mac + 2, 4);
  		memcpy(&in6, sgid.raw, sizeof(in6));
diff --cc include/rdma/ib_pack.h
index 03f52176b1ae,0f3daae44bf9..000000000000
--- a/include/rdma/ib_pack.h
+++ b/include/rdma/ib_pack.h
@@@ -222,6 -225,27 +222,30 @@@ struct ib_unpacked_eth 
  	__be16	type;
  };
  
++<<<<<<< HEAD
++=======
+ struct ib_unpacked_ip4 {
+ 	u8	ver;
+ 	u8	hdr_len;
+ 	u8	tos;
+ 	__be16	tot_len;
+ 	__be16	id;
+ 	__be16	frag_off;
+ 	u8	ttl;
+ 	u8	protocol;
+ 	__sum16	check;
+ 	__be32	saddr;
+ 	__be32	daddr;
+ };
+ 
+ struct ib_unpacked_udp {
+ 	__be16	sport;
+ 	__be16	dport;
+ 	__be16	length;
+ 	__be16	csum;
+ };
+ 
++>>>>>>> 3ef967a4affe (IB/mlx4: Enable send of RoCE QP1 packets with IP/UDP headers)
  struct ib_unpacked_vlan {
  	__be16  tag;
  	__be16  type;
@@@ -252,13 -280,17 +276,27 @@@ void ib_unpack(const struct ib_fiel
  	       void                         *buf,
  	       void                         *structure);
  
++<<<<<<< HEAD
 +void ib_ud_header_init(int		    payload_bytes,
 +		       int		    lrh_present,
 +		       int		    eth_present,
 +		       int		    vlan_present,
 +		       int		    grh_present,
 +		       int		    immediate_present,
 +		       struct ib_ud_header *header);
++=======
+ __sum16 ib_ud_ip4_csum(struct ib_ud_header *header);
+ 
+ int ib_ud_header_init(int		    payload_bytes,
+ 		      int		    lrh_present,
+ 		      int		    eth_present,
+ 		      int		    vlan_present,
+ 		      int		    grh_present,
+ 		      int		    ip_version,
+ 		      int		    udp_present,
+ 		      int		    immediate_present,
+ 		      struct ib_ud_header *header);
++>>>>>>> 3ef967a4affe (IB/mlx4: Enable send of RoCE QP1 packets with IP/UDP headers)
  
  int ib_ud_header_pack(struct ib_ud_header *header,
  		      void                *buf);
* Unmerged path drivers/infiniband/core/ud_header.c
* Unmerged path drivers/infiniband/hw/mlx4/qp.c
* Unmerged path include/rdma/ib_pack.h
