Drivers: hv: vmbus: fix rescind-offer handling for device without a driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hv] vmbus: fix rescind-offer handling for device without a driver (Vitaly Kuznetsov) [1321073]
Rebuild_FUZZ: 90.37%
commit-author Dexuan Cui <decui@microsoft.com>
commit 34c6801e3310ad286c7bb42bc88d42926b8f99bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/34c6801e.failed

In the path vmbus_onoffer_rescind() -> vmbus_device_unregister()  ->
device_unregister() -> ... -> __device_release_driver(), we can see for a
device without a driver loaded: dev->driver is NULL, so
dev->bus->remove(dev), namely vmbus_remove(), isn't invoked.

As a result, vmbus_remove() -> hv_process_channel_removal() isn't invoked
and some cleanups(like sending a CHANNELMSG_RELID_RELEASED message to the
host) aren't done.

We can demo the issue this way:
1. rmmod hv_utils;
2. disable the Heartbeat Integration Service in Hyper-V Manager and lsvmbus
shows the device disappears.
3. re-enable the Heartbeat in Hyper-V Manager and modprobe hv_utils, but
lsvmbus shows the device can't appear again.
This is because, the host thinks the VM hasn't released the relid, so can't
re-offer the device to the VM.

We can fix the issue by moving hv_process_channel_removal()
from vmbus_close_internal() to vmbus_device_release(), since the latter is
always invoked on device_unregister(), whether or not the dev has a driver
loaded.

	Signed-off-by: Dexuan Cui <decui@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 34c6801e3310ad286c7bb42bc88d42926b8f99bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/channel_mgmt.c
diff --cc drivers/hv/channel_mgmt.c
index 19b6510e7e18,7903acc3403e..000000000000
--- a/drivers/hv/channel_mgmt.c
+++ b/drivers/hv/channel_mgmt.c
@@@ -212,11 -228,14 +214,20 @@@ void hv_process_channel_removal(struct 
  
  void vmbus_free_channels(void)
  {
++<<<<<<< HEAD
 +	struct vmbus_channel *channel;
++=======
+ 	struct vmbus_channel *channel, *tmp;
+ 
+ 	list_for_each_entry_safe(channel, tmp, &vmbus_connection.chn_list,
+ 		listentry) {
+ 		/* hv_process_channel_removal() needs this */
+ 		channel->rescind = true;
++>>>>>>> 34c6801e3310 (Drivers: hv: vmbus: fix rescind-offer handling for device without a driver)
  
 +	list_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {
  		vmbus_device_unregister(channel->device_obj);
 +		free_channel(channel);
  	}
  }
  
diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c
index e44e592da06b..051571402e2b 100644
--- a/drivers/hv/channel.c
+++ b/drivers/hv/channel.c
@@ -576,12 +576,6 @@ static int vmbus_close_internal(struct vmbus_channel *channel)
 	free_pages((unsigned long)channel->ringbuffer_pages,
 		get_order(channel->ringbuffer_pagecount * PAGE_SIZE));
 
-	/*
-	 * If the channel has been rescinded; process device removal.
-	 */
-	if (channel->rescind)
-		hv_process_channel_removal(channel,
-					   channel->offermsg.child_relid);
 out:
 	tasklet_enable(tasklet);
 
* Unmerged path drivers/hv/channel_mgmt.c
diff --git a/drivers/hv/vmbus_drv.c b/drivers/hv/vmbus_drv.c
index 305d2da27594..80709aca872c 100644
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@ -611,23 +611,11 @@ static int vmbus_remove(struct device *child_device)
 {
 	struct hv_driver *drv;
 	struct hv_device *dev = device_to_hv_device(child_device);
-	u32 relid = dev->channel->offermsg.child_relid;
 
 	if (child_device->driver) {
 		drv = drv_to_hv_drv(child_device->driver);
 		if (drv->remove)
 			drv->remove(dev);
-		else {
-			hv_process_channel_removal(dev->channel, relid);
-			pr_err("remove not set for driver %s\n",
-				dev_name(child_device));
-		}
-	} else {
-		/*
-		 * We don't have a driver for this device; deal with the
-		 * rescind message by removing the channel.
-		 */
-		hv_process_channel_removal(dev->channel, relid);
 	}
 
 	return 0;
@@ -662,7 +650,10 @@ static void vmbus_shutdown(struct device *child_device)
 static void vmbus_device_release(struct device *device)
 {
 	struct hv_device *hv_dev = device_to_hv_device(device);
+	struct vmbus_channel *channel = hv_dev->channel;
 
+	hv_process_channel_removal(channel,
+				   channel->offermsg.child_relid);
 	kfree(hv_dev);
 
 }
