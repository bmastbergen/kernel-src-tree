net/mlx5_core: Introduce access functions to enable/disable RoCE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Achiad Shochat <achiad@mellanox.com>
commit 0de60af649533ad8d9aaeab1df710e6a728d45ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0de60af6.failed

A mlx5 Ethernet port must be explicitly enabled for RoCE.
When RoCE is not enabled on the port, the NIC will refuse to create
QPs attached to it and incoming RoCE packets will be considered by the
NIC as plain Ethernet packets.

	Signed-off-by: Achiad Shochat <achiad@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 0de60af649533ad8d9aaeab1df710e6a728d45ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/vport.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/vport.c
index 076197efea9b,245ff4a03dd6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/vport.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/vport.c
@@@ -131,12 -78,10 +131,19 @@@ static int mlx5_modify_nic_vport_contex
  	MLX5_SET(modify_nic_vport_context_in, in, opcode,
  		 MLX5_CMD_OP_MODIFY_NIC_VPORT_CONTEXT);
  
++<<<<<<< HEAD
 +	memset(out, 0, sizeof(out));
 +	return mlx5_cmd_exec_check_status(mdev, in, inlen, out, sizeof(out));
 +}
 +
 +int mlx5_query_nic_vport_mac_address(struct mlx5_core_dev *mdev,
 +				     u16 vport, u8 *addr)
++=======
+ 	return mlx5_cmd_exec_check_status(mdev, in, inlen, out, sizeof(out));
+ }
+ 
+ void mlx5_query_nic_vport_mac_address(struct mlx5_core_dev *mdev, u8 *addr)
++>>>>>>> 0de60af64953 (net/mlx5_core: Introduce access functions to enable/disable RoCE)
  {
  	u32 *out;
  	int outlen = MLX5_ST_SZ_BYTES(query_nic_vport_context_out);
@@@ -689,41 -362,13 +696,51 @@@ int mlx5_query_hca_vport_node_guid(stru
  }
  EXPORT_SYMBOL_GPL(mlx5_query_hca_vport_node_guid);
  
++<<<<<<< HEAD
 +int mlx5_query_nic_vport_promisc(struct mlx5_core_dev *mdev,
 +				 u32 vport,
 +				 int *promisc_uc,
 +				 int *promisc_mc,
 +				 int *promisc_all)
 +{
 +	u32 *out;
 +	int outlen = MLX5_ST_SZ_BYTES(query_nic_vport_context_out);
 +	int err;
 +
 +	out = kzalloc(outlen, GFP_KERNEL);
 +	if (!out)
 +		return -ENOMEM;
 +
 +	err = mlx5_query_nic_vport_context(mdev, vport, out, outlen);
 +	if (err)
 +		goto out;
 +
 +	*promisc_uc = MLX5_GET(query_nic_vport_context_out, out,
 +			       nic_vport_context.promisc_uc);
 +	*promisc_mc = MLX5_GET(query_nic_vport_context_out, out,
 +			       nic_vport_context.promisc_mc);
 +	*promisc_all = MLX5_GET(query_nic_vport_context_out, out,
 +				nic_vport_context.promisc_all);
 +
 +out:
 +	kfree(out);
 +	return err;
 +}
 +EXPORT_SYMBOL_GPL(mlx5_query_nic_vport_promisc);
 +
 +int mlx5_modify_nic_vport_promisc(struct mlx5_core_dev *mdev,
 +				  int promisc_uc,
 +				  int promisc_mc,
 +				  int promisc_all)
++=======
+ enum mlx5_vport_roce_state {
+ 	MLX5_VPORT_ROCE_DISABLED = 0,
+ 	MLX5_VPORT_ROCE_ENABLED  = 1,
+ };
+ 
+ static int mlx5_nic_vport_update_roce_state(struct mlx5_core_dev *mdev,
+ 					    enum mlx5_vport_roce_state state)
++>>>>>>> 0de60af64953 (net/mlx5_core: Introduce access functions to enable/disable RoCE)
  {
  	void *in;
  	int inlen = MLX5_ST_SZ_BYTES(modify_nic_vport_context_in);
@@@ -731,17 -376,13 +748,27 @@@
  
  	in = mlx5_vzalloc(inlen);
  	if (!in) {
++<<<<<<< HEAD
 +		mlx5_core_err(mdev, "failed to allocate inbox\n");
 +		return -ENOMEM;
 +	}
 +
 +	MLX5_SET(modify_nic_vport_context_in, in, field_select.promisc, 1);
 +	MLX5_SET(modify_nic_vport_context_in, in,
 +		 nic_vport_context.promisc_uc, promisc_uc);
 +	MLX5_SET(modify_nic_vport_context_in, in,
 +		 nic_vport_context.promisc_mc, promisc_mc);
 +	MLX5_SET(modify_nic_vport_context_in, in,
 +		 nic_vport_context.promisc_all, promisc_all);
++=======
+ 		mlx5_core_warn(mdev, "failed to allocate inbox\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	MLX5_SET(modify_nic_vport_context_in, in, field_select.roce_en, 1);
+ 	MLX5_SET(modify_nic_vport_context_in, in, nic_vport_context.roce_en,
+ 		 state);
++>>>>>>> 0de60af64953 (net/mlx5_core: Introduce access functions to enable/disable RoCE)
  
  	err = mlx5_modify_nic_vport_context(mdev, in, inlen);
  
@@@ -749,4 -390,15 +776,19 @@@
  
  	return err;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(mlx5_modify_nic_vport_promisc);
++=======
+ 
+ int mlx5_nic_vport_enable_roce(struct mlx5_core_dev *mdev)
+ {
+ 	return mlx5_nic_vport_update_roce_state(mdev, MLX5_VPORT_ROCE_ENABLED);
+ }
+ EXPORT_SYMBOL_GPL(mlx5_nic_vport_enable_roce);
+ 
+ int mlx5_nic_vport_disable_roce(struct mlx5_core_dev *mdev)
+ {
+ 	return mlx5_nic_vport_update_roce_state(mdev, MLX5_VPORT_ROCE_DISABLED);
+ }
+ EXPORT_SYMBOL_GPL(mlx5_nic_vport_disable_roce);
++>>>>>>> 0de60af64953 (net/mlx5_core: Introduce access functions to enable/disable RoCE)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/vport.c
diff --git a/include/linux/mlx5/vport.h b/include/linux/mlx5/vport.h
index 638f2ca7a527..6290fd347fa7 100644
--- a/include/linux/mlx5/vport.h
+++ b/include/linux/mlx5/vport.h
@@ -85,4 +85,7 @@ int mlx5_modify_nic_vport_vlans(struct mlx5_core_dev *dev,
 				u16 vlans[],
 				int list_size);
 
+int mlx5_nic_vport_enable_roce(struct mlx5_core_dev *mdev);
+int mlx5_nic_vport_disable_roce(struct mlx5_core_dev *mdev);
+
 #endif /* __MLX5_VPORT_H__ */
