ftrace: Make ftrace_hash_rec_enable return update bool

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 84b6d3e6149c5280bc18b42e2f12efdaf354e49c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/84b6d3e6.failed

Change __ftrace_hash_rec_update to return true in case
we need to update dynamic ftrace call records. It return
false in case no update is needed.

Link: http://lkml.kernel.org/r/1458138873-1553-5-git-send-email-jolsa@kernel.org

	Acked-by: Namhyung Kim <namhyung@kernel.org>
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
(cherry picked from commit 84b6d3e6149c5280bc18b42e2f12efdaf354e49c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/ftrace.c
diff --cc kernel/trace/ftrace.c
index 71cd8eb49200,11ffcfd3804e..000000000000
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@@ -1521,7 -1590,27 +1521,31 @@@ int ftrace_text_reserved(void *start, v
  	return (int)!!ret;
  }
  
++<<<<<<< HEAD
 +static void __ftrace_hash_rec_update(struct ftrace_ops *ops,
++=======
+ /* Test if ops registered to this rec needs regs */
+ static bool test_rec_ops_needs_regs(struct dyn_ftrace *rec)
+ {
+ 	struct ftrace_ops *ops;
+ 	bool keep_regs = false;
+ 
+ 	for (ops = ftrace_ops_list;
+ 	     ops != &ftrace_list_end; ops = ops->next) {
+ 		/* pass rec in as regs to have non-NULL val */
+ 		if (ftrace_ops_test(ops, rec->ip, rec)) {
+ 			if (ops->flags & FTRACE_OPS_FL_SAVE_REGS) {
+ 				keep_regs = true;
+ 				break;
+ 			}
+ 		}
+ 	}
+ 
+ 	return  keep_regs;
+ }
+ 
+ static bool __ftrace_hash_rec_update(struct ftrace_ops *ops,
++>>>>>>> 84b6d3e6149c (ftrace: Make ftrace_hash_rec_enable return update bool)
  				     int filter_hash,
  				     bool inc)
  {
@@@ -1594,8 -1694,25 +1619,30 @@@
  
  		if (inc) {
  			rec->flags++;
++<<<<<<< HEAD
 +			if (FTRACE_WARN_ON((rec->flags & ~FTRACE_FL_MASK) == FTRACE_REF_MAX))
 +				return;
++=======
+ 			if (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))
+ 				return false;
+ 
+ 			/*
+ 			 * If there's only a single callback registered to a
+ 			 * function, and the ops has a trampoline registered
+ 			 * for it, then we can call it directly.
+ 			 */
+ 			if (ftrace_rec_count(rec) == 1 && ops->trampoline)
+ 				rec->flags |= FTRACE_FL_TRAMP;
+ 			else
+ 				/*
+ 				 * If we are adding another function callback
+ 				 * to this function, and the previous had a
+ 				 * custom trampoline in use, then we need to go
+ 				 * back to the default trampoline.
+ 				 */
+ 				rec->flags &= ~FTRACE_FL_TRAMP;
+ 
++>>>>>>> 84b6d3e6149c (ftrace: Make ftrace_hash_rec_enable return update bool)
  			/*
  			 * If any ops wants regs saved for this function
  			 * then all ops will get saved regs.
@@@ -1603,81 -1720,321 +1650,92 @@@
  			if (ops->flags & FTRACE_OPS_FL_SAVE_REGS)
  				rec->flags |= FTRACE_FL_REGS;
  		} else {
++<<<<<<< HEAD
 +			if (FTRACE_WARN_ON((rec->flags & ~FTRACE_FL_MASK) == 0))
 +				return;
++=======
+ 			if (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))
+ 				return false;
++>>>>>>> 84b6d3e6149c (ftrace: Make ftrace_hash_rec_enable return update bool)
  			rec->flags--;
 -
 -			/*
 -			 * If the rec had REGS enabled and the ops that is
 -			 * being removed had REGS set, then see if there is
 -			 * still any ops for this record that wants regs.
 -			 * If not, we can stop recording them.
 -			 */
 -			if (ftrace_rec_count(rec) > 0 &&
 -			    rec->flags & FTRACE_FL_REGS &&
 -			    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {
 -				if (!test_rec_ops_needs_regs(rec))
 -					rec->flags &= ~FTRACE_FL_REGS;
 -			}
 -
 -			/*
 -			 * If the rec had TRAMP enabled, then it needs to
 -			 * be cleared. As TRAMP can only be enabled iff
 -			 * there is only a single ops attached to it.
 -			 * In otherwords, always disable it on decrementing.
 -			 * In the future, we may set it if rec count is
 -			 * decremented to one, and the ops that is left
 -			 * has a trampoline.
 -			 */
 -			rec->flags &= ~FTRACE_FL_TRAMP;
 -
 -			/*
 -			 * flags will be cleared in ftrace_check_record()
 -			 * if rec count is zero.
 -			 */
  		}
  		count++;
+ 
+ 		/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */
+ 		update |= ftrace_test_record(rec, 1) != FTRACE_UPDATE_IGNORE;
+ 
  		/* Shortcut, if we handled all records, we are done. */
  		if (!all && count == hash->count)
- 			return;
+ 			return update;
  	} while_for_each_ftrace_rec();
+ 
+ 	return update;
  }
  
- static void ftrace_hash_rec_disable(struct ftrace_ops *ops,
+ static bool ftrace_hash_rec_disable(struct ftrace_ops *ops,
  				    int filter_hash)
  {
- 	__ftrace_hash_rec_update(ops, filter_hash, 0);
+ 	return __ftrace_hash_rec_update(ops, filter_hash, 0);
  }
  
- static void ftrace_hash_rec_enable(struct ftrace_ops *ops,
+ static bool ftrace_hash_rec_enable(struct ftrace_ops *ops,
  				   int filter_hash)
  {
- 	__ftrace_hash_rec_update(ops, filter_hash, 1);
+ 	return __ftrace_hash_rec_update(ops, filter_hash, 1);
  }
  
 -static void ftrace_hash_rec_update_modify(struct ftrace_ops *ops,
 -					  int filter_hash, int inc)
 +static void print_ip_ins(const char *fmt, unsigned char *p)
  {
 -	struct ftrace_ops *op;
 -
 -	__ftrace_hash_rec_update(ops, filter_hash, inc);
 -
 -	if (ops->func_hash != &global_ops.local_hash)
 -		return;
 +	int i;
  
 -	/*
 -	 * If the ops shares the global_ops hash, then we need to update
 -	 * all ops that are enabled and use this hash.
 -	 */
 -	do_for_each_ftrace_op(op, ftrace_ops_list) {
 -		/* Already done */
 -		if (op == ops)
 -			continue;
 -		if (op->func_hash == &global_ops.local_hash)
 -			__ftrace_hash_rec_update(op, filter_hash, inc);
 -	} while_for_each_ftrace_op(op);
 -}
 +	printk(KERN_CONT "%s", fmt);
  
 -static void ftrace_hash_rec_disable_modify(struct ftrace_ops *ops,
 -					   int filter_hash)
 -{
 -	ftrace_hash_rec_update_modify(ops, filter_hash, 0);
 +	for (i = 0; i < MCOUNT_INSN_SIZE; i++)
 +		printk(KERN_CONT "%s%02x", i ? ":" : "", p[i]);
  }
  
 -static void ftrace_hash_rec_enable_modify(struct ftrace_ops *ops,
 -					  int filter_hash)
 +/**
 + * ftrace_bug - report and shutdown function tracer
 + * @failed: The failed type (EFAULT, EINVAL, EPERM)
 + * @ip: The address that failed
 + *
 + * The arch code that enables or disables the function tracing
 + * can call ftrace_bug() when it has detected a problem in
 + * modifying the code. @failed should be one of either:
 + * EFAULT - if the problem happens on reading the @ip address
 + * EINVAL - if what is read at @ip is not what was expected
 + * EPERM - if the problem happens on writting to the @ip address
 + */
 +void ftrace_bug(int failed, unsigned long ip)
  {
 -	ftrace_hash_rec_update_modify(ops, filter_hash, 1);
 +	switch (failed) {
 +	case -EFAULT:
 +		FTRACE_WARN_ON_ONCE(1);
 +		pr_info("ftrace faulted on modifying ");
 +		print_ip_sym(ip);
 +		break;
 +	case -EINVAL:
 +		FTRACE_WARN_ON_ONCE(1);
 +		pr_info("ftrace failed to modify ");
 +		print_ip_sym(ip);
 +		print_ip_ins(" actual: ", (unsigned char *)ip);
 +		printk(KERN_CONT "\n");
 +		break;
 +	case -EPERM:
 +		FTRACE_WARN_ON_ONCE(1);
 +		pr_info("ftrace faulted on writing ");
 +		print_ip_sym(ip);
 +		break;
 +	default:
 +		FTRACE_WARN_ON_ONCE(1);
 +		pr_info("ftrace faulted on unknown error ");
 +		print_ip_sym(ip);
 +	}
  }
  
 -/*
 - * Try to update IPMODIFY flag on each ftrace_rec. Return 0 if it is OK
 - * or no-needed to update, -EBUSY if it detects a conflict of the flag
 - * on a ftrace_rec, and -EINVAL if the new_hash tries to trace all recs.
 - * Note that old_hash and new_hash has below meanings
 - *  - If the hash is NULL, it hits all recs (if IPMODIFY is set, this is rejected)
 - *  - If the hash is EMPTY_HASH, it hits nothing
 - *  - Anything else hits the recs which match the hash entries.
 - */
 -static int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,
 -					 struct ftrace_hash *old_hash,
 -					 struct ftrace_hash *new_hash)
 +static int ftrace_check_record(struct dyn_ftrace *rec, int enable, int update)
  {
 -	struct ftrace_page *pg;
 -	struct dyn_ftrace *rec, *end = NULL;
 -	int in_old, in_new;
 -
 -	/* Only update if the ops has been registered */
 -	if (!(ops->flags & FTRACE_OPS_FL_ENABLED))
 -		return 0;
 -
 -	if (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))
 -		return 0;
 -
 -	/*
 -	 * Since the IPMODIFY is a very address sensitive action, we do not
 -	 * allow ftrace_ops to set all functions to new hash.
 -	 */
 -	if (!new_hash || !old_hash)
 -		return -EINVAL;
 -
 -	/* Update rec->flags */
 -	do_for_each_ftrace_rec(pg, rec) {
 -		/* We need to update only differences of filter_hash */
 -		in_old = !!ftrace_lookup_ip(old_hash, rec->ip);
 -		in_new = !!ftrace_lookup_ip(new_hash, rec->ip);
 -		if (in_old == in_new)
 -			continue;
 -
 -		if (in_new) {
 -			/* New entries must ensure no others are using it */
 -			if (rec->flags & FTRACE_FL_IPMODIFY)
 -				goto rollback;
 -			rec->flags |= FTRACE_FL_IPMODIFY;
 -		} else /* Removed entry */
 -			rec->flags &= ~FTRACE_FL_IPMODIFY;
 -	} while_for_each_ftrace_rec();
 -
 -	return 0;
 -
 -rollback:
 -	end = rec;
 -
 -	/* Roll back what we did above */
 -	do_for_each_ftrace_rec(pg, rec) {
 -		if (rec == end)
 -			goto err_out;
 -
 -		in_old = !!ftrace_lookup_ip(old_hash, rec->ip);
 -		in_new = !!ftrace_lookup_ip(new_hash, rec->ip);
 -		if (in_old == in_new)
 -			continue;
 -
 -		if (in_new)
 -			rec->flags &= ~FTRACE_FL_IPMODIFY;
 -		else
 -			rec->flags |= FTRACE_FL_IPMODIFY;
 -	} while_for_each_ftrace_rec();
 -
 -err_out:
 -	return -EBUSY;
 -}
 -
 -static int ftrace_hash_ipmodify_enable(struct ftrace_ops *ops)
 -{
 -	struct ftrace_hash *hash = ops->func_hash->filter_hash;
 -
 -	if (ftrace_hash_empty(hash))
 -		hash = NULL;
 -
 -	return __ftrace_hash_update_ipmodify(ops, EMPTY_HASH, hash);
 -}
 -
 -/* Disabling always succeeds */
 -static void ftrace_hash_ipmodify_disable(struct ftrace_ops *ops)
 -{
 -	struct ftrace_hash *hash = ops->func_hash->filter_hash;
 -
 -	if (ftrace_hash_empty(hash))
 -		hash = NULL;
 -
 -	__ftrace_hash_update_ipmodify(ops, hash, EMPTY_HASH);
 -}
 -
 -static int ftrace_hash_ipmodify_update(struct ftrace_ops *ops,
 -				       struct ftrace_hash *new_hash)
 -{
 -	struct ftrace_hash *old_hash = ops->func_hash->filter_hash;
 -
 -	if (ftrace_hash_empty(old_hash))
 -		old_hash = NULL;
 -
 -	if (ftrace_hash_empty(new_hash))
 -		new_hash = NULL;
 -
 -	return __ftrace_hash_update_ipmodify(ops, old_hash, new_hash);
 -}
 -
 -static void print_ip_ins(const char *fmt, const unsigned char *p)
 -{
 -	int i;
 -
 -	printk(KERN_CONT "%s", fmt);
 -
 -	for (i = 0; i < MCOUNT_INSN_SIZE; i++)
 -		printk(KERN_CONT "%s%02x", i ? ":" : "", p[i]);
 -}
 -
 -static struct ftrace_ops *
 -ftrace_find_tramp_ops_any(struct dyn_ftrace *rec);
 -static struct ftrace_ops *
 -ftrace_find_tramp_ops_next(struct dyn_ftrace *rec, struct ftrace_ops *ops);
 -
 -enum ftrace_bug_type ftrace_bug_type;
 -const void *ftrace_expected;
 -
 -static void print_bug_type(void)
 -{
 -	switch (ftrace_bug_type) {
 -	case FTRACE_BUG_UNKNOWN:
 -		break;
 -	case FTRACE_BUG_INIT:
 -		pr_info("Initializing ftrace call sites\n");
 -		break;
 -	case FTRACE_BUG_NOP:
 -		pr_info("Setting ftrace call site to NOP\n");
 -		break;
 -	case FTRACE_BUG_CALL:
 -		pr_info("Setting ftrace call site to call ftrace function\n");
 -		break;
 -	case FTRACE_BUG_UPDATE:
 -		pr_info("Updating ftrace call site to call a different ftrace function\n");
 -		break;
 -	}
 -}
 -
 -/**
 - * ftrace_bug - report and shutdown function tracer
 - * @failed: The failed type (EFAULT, EINVAL, EPERM)
 - * @rec: The record that failed
 - *
 - * The arch code that enables or disables the function tracing
 - * can call ftrace_bug() when it has detected a problem in
 - * modifying the code. @failed should be one of either:
 - * EFAULT - if the problem happens on reading the @ip address
 - * EINVAL - if what is read at @ip is not what was expected
 - * EPERM - if the problem happens on writting to the @ip address
 - */
 -void ftrace_bug(int failed, struct dyn_ftrace *rec)
 -{
 -	unsigned long ip = rec ? rec->ip : 0;
 -
 -	switch (failed) {
 -	case -EFAULT:
 -		FTRACE_WARN_ON_ONCE(1);
 -		pr_info("ftrace faulted on modifying ");
 -		print_ip_sym(ip);
 -		break;
 -	case -EINVAL:
 -		FTRACE_WARN_ON_ONCE(1);
 -		pr_info("ftrace failed to modify ");
 -		print_ip_sym(ip);
 -		print_ip_ins(" actual:   ", (unsigned char *)ip);
 -		pr_cont("\n");
 -		if (ftrace_expected) {
 -			print_ip_ins(" expected: ", ftrace_expected);
 -			pr_cont("\n");
 -		}
 -		break;
 -	case -EPERM:
 -		FTRACE_WARN_ON_ONCE(1);
 -		pr_info("ftrace faulted on writing ");
 -		print_ip_sym(ip);
 -		break;
 -	default:
 -		FTRACE_WARN_ON_ONCE(1);
 -		pr_info("ftrace faulted on unknown error ");
 -		print_ip_sym(ip);
 -	}
 -	print_bug_type();
 -	if (rec) {
 -		struct ftrace_ops *ops = NULL;
 -
 -		pr_info("ftrace record flags: %lx\n", rec->flags);
 -		pr_cont(" (%ld)%s", ftrace_rec_count(rec),
 -			rec->flags & FTRACE_FL_REGS ? " R" : "  ");
 -		if (rec->flags & FTRACE_FL_TRAMP_EN) {
 -			ops = ftrace_find_tramp_ops_any(rec);
 -			if (ops) {
 -				do {
 -					pr_cont("\ttramp: %pS (%pS)",
 -						(void *)ops->trampoline,
 -						(void *)ops->func);
 -					ops = ftrace_find_tramp_ops_next(rec, ops);
 -				} while (ops);
 -			} else
 -				pr_cont("\ttramp: ERROR!");
 -
 -		}
 -		ip = ftrace_get_addr_curr(rec);
 -		pr_cont("\n expected tramp: %lx\n", ip);
 -	}
 -}
 -
 -static int ftrace_check_record(struct dyn_ftrace *rec, int enable, int update)
 -{
 -	unsigned long flag = 0UL;
 -
 -	ftrace_bug_type = FTRACE_BUG_UNKNOWN;
 -
 -	if (rec->flags & FTRACE_FL_DISABLED)
 -		return FTRACE_UPDATE_IGNORE;
 +	unsigned long flag = 0UL;
  
  	/*
  	 * If we are updating calls:
* Unmerged path kernel/trace/ftrace.c
