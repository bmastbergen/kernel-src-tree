xfs: fix endianness error when checking log block crc on big endian platforms

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 8e0bd4925bf693520295de403483efad4dc5cc16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8e0bd492.failed

Since the checksum function and the field are both __le32, don't
perform endian conversion when comparing the two.  This fixes mount
failures on ppc64.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 8e0bd4925bf693520295de403483efad4dc5cc16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_log_recover.c
diff --cc fs/xfs/xfs_log_recover.c
index 062d4bef067d,594f7e63b432..000000000000
--- a/fs/xfs/xfs_log_recover.c
+++ b/fs/xfs/xfs_log_recover.c
@@@ -4519,6 -4479,45 +4519,48 @@@ xlog_recover_process
  	int			pass)
  {
  	int			error;
++<<<<<<< HEAD
++=======
+ 	__le32			crc;
+ 
+ 	crc = xlog_cksum(log, rhead, dp, be32_to_cpu(rhead->h_len));
+ 
+ 	/*
+ 	 * Nothing else to do if this is a CRC verification pass. Just return
+ 	 * if this a record with a non-zero crc. Unfortunately, mkfs always
+ 	 * sets h_crc to 0 so we must consider this valid even on v5 supers.
+ 	 * Otherwise, return EFSBADCRC on failure so the callers up the stack
+ 	 * know precisely what failed.
+ 	 */
+ 	if (pass == XLOG_RECOVER_CRCPASS) {
+ 		if (rhead->h_crc && crc != rhead->h_crc)
+ 			return -EFSBADCRC;
+ 		return 0;
+ 	}
+ 
+ 	/*
+ 	 * We're in the normal recovery path. Issue a warning if and only if the
+ 	 * CRC in the header is non-zero. This is an advisory warning and the
+ 	 * zero CRC check prevents warnings from being emitted when upgrading
+ 	 * the kernel from one that does not add CRCs by default.
+ 	 */
+ 	if (crc != rhead->h_crc) {
+ 		if (rhead->h_crc || xfs_sb_version_hascrc(&log->l_mp->m_sb)) {
+ 			xfs_alert(log->l_mp,
+ 		"log record CRC mismatch: found 0x%x, expected 0x%x.",
+ 					le32_to_cpu(rhead->h_crc),
+ 					le32_to_cpu(crc));
+ 			xfs_hex_dump(dp, 32);
+ 		}
+ 
+ 		/*
+ 		 * If the filesystem is CRC enabled, this mismatch becomes a
+ 		 * fatal log corruption failure.
+ 		 */
+ 		if (xfs_sb_version_hascrc(&log->l_mp->m_sb))
+ 			return -EFSCORRUPTED;
+ 	}
++>>>>>>> 8e0bd4925bf6 (xfs: fix endianness error when checking log block crc on big endian platforms)
  
  	error = xlog_unpack_data(rhead, dp, log);
  	if (error)
* Unmerged path fs/xfs/xfs_log_recover.c
