perf: Only update context time when active

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit 6f932e5be1503ab0783699e843db325d44c2fabb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6f932e5b.failed

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: dvyukov@google.com
	Cc: eranian@google.com
	Cc: oleg@redhat.com
	Cc: panand@redhat.com
	Cc: sasha.levin@oracle.com
	Cc: vince@deater.net
Link: http://lkml.kernel.org/r/20160224174947.860690919@infradead.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 6f932e5be1503ab0783699e843db325d44c2fabb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/core.c
diff --cc kernel/events/core.c
index 0e60facd7da7,64698fbfad9f..000000000000
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@@ -2118,8 -2147,42 +2118,47 @@@ perf_install_in_context(struct perf_eve
  	if (event->cpu != -1)
  		event->cpu = cpu;
  
++<<<<<<< HEAD
 +	event_function_call(event, __perf_install_in_context,
 +			    ___perf_install_in_context, event);
++=======
+ 	/*
+ 	 * Installing events is tricky because we cannot rely on ctx->is_active
+ 	 * to be set in case this is the nr_events 0 -> 1 transition.
+ 	 *
+ 	 * So what we do is we add the event to the list here, which will allow
+ 	 * a future context switch to DTRT and then send a racy IPI. If the IPI
+ 	 * fails to hit the right task, this means a context switch must have
+ 	 * happened and that will have taken care of business.
+ 	 */
+ 	raw_spin_lock_irq(&ctx->lock);
+ 	task = ctx->task;
+ 
+ 	/*
+ 	 * If between ctx = find_get_context() and mutex_lock(&ctx->mutex) the
+ 	 * ctx gets destroyed, we must not install an event into it.
+ 	 *
+ 	 * This is normally tested for after we acquire the mutex, so this is
+ 	 * a sanity check.
+ 	 */
+ 	if (WARN_ON_ONCE(task == TASK_TOMBSTONE)) {
+ 		raw_spin_unlock_irq(&ctx->lock);
+ 		return;
+ 	}
+ 
+ 	if (ctx->is_active) {
+ 		update_context_time(ctx);
+ 		update_cgrp_time_from_event(event);
+ 	}
+ 
+ 	add_event_to_ctx(event, ctx);
+ 	raw_spin_unlock_irq(&ctx->lock);
+ 
+ 	if (task)
+ 		task_function_call(task, __perf_install_in_context, ctx);
+ 	else
+ 		cpu_function_call(cpu, __perf_install_in_context, ctx);
++>>>>>>> 6f932e5be150 (perf: Only update context time when active)
  }
  
  /*
* Unmerged path kernel/events/core.c
