Btrfs: add ref_count and free function for btrfs_bio

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Zhao Lei <zhaolei@cn.fujitsu.com>
commit 6e9606d2a2dce098c1739fb3cd82a1c34fd73d3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6e9606d2.failed

1: ref_count is simple than current RBIO_HOLD_BBIO_MAP_BIT flag
   to keep btrfs_bio's memory in raid56 recovery implement.
2: free function for bbio will make code clean and flexible, plus
   forced data type checking in compile.

Changelog v1->v2:
 Rename following by David Sterba's suggestion:
 put_btrfs_bio() -> btrfs_put_bio()
 get_btrfs_bio() -> btrfs_get_bio()
 bbio->ref_count -> bbio->refs

	Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
	Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit 6e9606d2a2dce098c1739fb3cd82a1c34fd73d3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/raid56.c
#	fs/btrfs/scrub.c
#	fs/btrfs/volumes.c
#	fs/btrfs/volumes.h
diff --cc fs/btrfs/raid56.c
index 7f7e258d9628,cbc416204452..000000000000
--- a/fs/btrfs/raid56.c
+++ b/fs/btrfs/raid56.c
@@@ -841,21 -825,6 +832,24 @@@ done_nolock
  		remove_rbio_from_cache(rbio);
  }
  
++<<<<<<< HEAD
 +static inline void
 +__free_bbio_and_raid_map(struct btrfs_bio *bbio, u64 *raid_map, int need)
 +{
 +	if (need) {
 +		kfree(raid_map);
 +		kfree(bbio);
 +	}
 +}
 +
 +static inline void free_bbio_and_raid_map(struct btrfs_raid_bio *rbio)
 +{
 +	__free_bbio_and_raid_map(rbio->bbio, rbio->raid_map,
 +			!test_bit(RBIO_HOLD_BBIO_MAP_BIT, &rbio->flags));
 +}
 +
++=======
++>>>>>>> 6e9606d2a2dc (Btrfs: add ref_count and free function for btrfs_bio)
  static void __free_raid_bio(struct btrfs_raid_bio *rbio)
  {
  	int i;
@@@ -875,8 -844,7 +869,12 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	free_bbio_and_raid_map(rbio);
 +
++=======
+ 	btrfs_put_bbio(rbio->bbio);
++>>>>>>> 6e9606d2a2dc (Btrfs: add ref_count and free function for btrfs_bio)
  	kfree(rbio);
  }
  
@@@ -1784,9 -1749,9 +1782,13 @@@ int raid56_parity_write(struct btrfs_ro
  	struct blk_plug_cb *cb;
  	int ret;
  
 -	rbio = alloc_rbio(root, bbio, stripe_len);
 +	rbio = alloc_rbio(root, bbio, raid_map, stripe_len);
  	if (IS_ERR(rbio)) {
++<<<<<<< HEAD
 +		__free_bbio_and_raid_map(bbio, raid_map, 1);
++=======
+ 		btrfs_put_bbio(bbio);
++>>>>>>> 6e9606d2a2dc (Btrfs: add ref_count and free function for btrfs_bio)
  		return PTR_ERR(rbio);
  	}
  	bio_list_add(&rbio->bio_list, bio);
@@@ -2162,9 -2127,10 +2163,14 @@@ int raid56_parity_recover(struct btrfs_
  	struct btrfs_raid_bio *rbio;
  	int ret;
  
 -	rbio = alloc_rbio(root, bbio, stripe_len);
 +	rbio = alloc_rbio(root, bbio, raid_map, stripe_len);
  	if (IS_ERR(rbio)) {
++<<<<<<< HEAD
 +		__free_bbio_and_raid_map(bbio, raid_map, generic_io);
++=======
+ 		if (generic_io)
+ 			btrfs_put_bbio(bbio);
++>>>>>>> 6e9606d2a2dc (Btrfs: add ref_count and free function for btrfs_bio)
  		return PTR_ERR(rbio);
  	}
  
@@@ -2175,7 -2141,8 +2181,12 @@@
  	rbio->faila = find_logical_bio_stripe(rbio, bio);
  	if (rbio->faila == -1) {
  		BUG();
++<<<<<<< HEAD
 +		__free_bbio_and_raid_map(bbio, raid_map, generic_io);
++=======
+ 		if (generic_io)
+ 			btrfs_put_bbio(bbio);
++>>>>>>> 6e9606d2a2dc (Btrfs: add ref_count and free function for btrfs_bio)
  		kfree(rbio);
  		return -EIO;
  	}
diff --cc fs/btrfs/scrub.c
index 078d367d6177,1388e7127eea..000000000000
--- a/fs/btrfs/scrub.c
+++ b/fs/btrfs/scrub.c
@@@ -856,8 -855,7 +856,12 @@@ static inline void scrub_get_recover(st
  static inline void scrub_put_recover(struct scrub_recover *recover)
  {
  	if (atomic_dec_and_test(&recover->refs)) {
++<<<<<<< HEAD
 +		kfree(recover->bbio);
 +		kfree(recover->raid_map);
++=======
+ 		btrfs_put_bbio(recover->bbio);
++>>>>>>> 6e9606d2a2dc (Btrfs: add ref_count and free function for btrfs_bio)
  		kfree(recover);
  	}
  }
@@@ -1375,17 -1371,15 +1379,25 @@@ static int scrub_setup_recheck_block(st
  		 * represents one mirror
  		 */
  		ret = btrfs_map_sblock(fs_info, REQ_GET_READ_MIRRORS, logical,
 -				       &mapped_length, &bbio, 0, 1);
 +				       &mapped_length, &bbio, 0, &raid_map);
  		if (ret || !bbio || mapped_length < sublen) {
++<<<<<<< HEAD
 +			kfree(bbio);
 +			kfree(raid_map);
++=======
+ 			btrfs_put_bbio(bbio);
++>>>>>>> 6e9606d2a2dc (Btrfs: add ref_count and free function for btrfs_bio)
  			return -EIO;
  		}
  
  		recover = kzalloc(sizeof(struct scrub_recover), GFP_NOFS);
  		if (!recover) {
++<<<<<<< HEAD
 +			kfree(bbio);
 +			kfree(raid_map);
++=======
+ 			btrfs_put_bbio(bbio);
++>>>>>>> 6e9606d2a2dc (Btrfs: add ref_count and free function for btrfs_bio)
  			return -ENOMEM;
  		}
  
@@@ -2758,8 -2748,7 +2770,12 @@@ static void scrub_parity_check_and_repa
  rbio_out:
  	bio_put(bio);
  bbio_out:
++<<<<<<< HEAD
 +	kfree(bbio);
 +	kfree(raid_map);
++=======
+ 	btrfs_put_bbio(bbio);
++>>>>>>> 6e9606d2a2dc (Btrfs: add ref_count and free function for btrfs_bio)
  	bitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,
  		  sparity->nsectors);
  	spin_lock(&sctx->stat_lock);
diff --cc fs/btrfs/volumes.c
index 6efc272f0e6d,0843bcd6304c..000000000000
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@@ -5238,10 -5244,8 +5269,9 @@@ static int __btrfs_map_block(struct btr
  		tgtdev_indexes = num_stripes;
  	}
  
- 	bbio = kzalloc(btrfs_bio_size(num_alloc_stripes, tgtdev_indexes),
- 		       GFP_NOFS);
+ 	bbio = alloc_btrfs_bio(num_alloc_stripes, tgtdev_indexes);
  	if (!bbio) {
 +		kfree(raid_map);
  		ret = -ENOMEM;
  		goto out;
  	}
@@@ -5555,11 -5583,11 +5584,19 @@@ int btrfs_rmap_block(struct btrfs_mappi
  
  static inline void btrfs_end_bbio(struct btrfs_bio *bbio, struct bio *bio, int err)
  {
++<<<<<<< HEAD
 +	bio->bi_private = bbio->private;
 +	bio->bi_end_io = bbio->end_io;
 +	bio_endio(bio, err);
 +
 +	kfree(bbio);
++=======
+ 	if (likely(bbio->flags & BTRFS_BIO_ORIG_BIO_SUBMITTED))
+ 		bio_endio_nodec(bio, err);
+ 	else
+ 		bio_endio(bio, err);
+ 	btrfs_put_bbio(bbio);
++>>>>>>> 6e9606d2a2dc (Btrfs: add ref_count and free function for btrfs_bio)
  }
  
  static void btrfs_end_bio(struct bio *bio, int err)
diff --cc fs/btrfs/volumes.h
index bc4a84130854,4313e8ff91e5..000000000000
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@@ -292,7 -292,10 +292,8 @@@ struct btrfs_bio_stripe 
  struct btrfs_bio;
  typedef void (btrfs_bio_end_io_t) (struct btrfs_bio *bio, int err);
  
 -#define BTRFS_BIO_ORIG_BIO_SUBMITTED	(1 << 0)
 -
  struct btrfs_bio {
+ 	atomic_t refs;
  	atomic_t stripes_pending;
  	struct btrfs_fs_info *fs_info;
  	bio_end_io_t *end_io;
@@@ -386,12 -395,8 +387,17 @@@ struct btrfs_balance_control 
  
  int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,
  				   u64 end, u64 *length);
++<<<<<<< HEAD
 +
 +#define btrfs_bio_size(total_stripes, real_stripes)		\
 +	(sizeof(struct btrfs_bio) +				\
 +	 (sizeof(struct btrfs_bio_stripe) * (total_stripes)) +	\
 +	 (sizeof(int) * (real_stripes)))
 +
++=======
+ void btrfs_get_bbio(struct btrfs_bio *bbio);
+ void btrfs_put_bbio(struct btrfs_bio *bbio);
++>>>>>>> 6e9606d2a2dc (Btrfs: add ref_count and free function for btrfs_bio)
  int btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,
  		    u64 logical, u64 *length,
  		    struct btrfs_bio **bbio_ret, int mirror_num);
diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index 5f5e598a30c6..bf1c2e6e82ab 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -1926,7 +1926,7 @@ int btrfs_discard_extent(struct btrfs_root *root, u64 bytenr,
 			 */
 			ret = 0;
 		}
-		kfree(bbio);
+		btrfs_put_bbio(bbio);
 	}
 
 	if (actual_bytes)
diff --git a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c
index d1c04982de95..3f27c38f7988 100644
--- a/fs/btrfs/extent_io.c
+++ b/fs/btrfs/extent_io.c
@@ -2058,7 +2058,7 @@ int repair_io_failure(struct inode *inode, u64 start, u64 length, u64 logical,
 	sector = bbio->stripes[mirror_num-1].physical >> 9;
 	bio->bi_sector = sector;
 	dev = bbio->stripes[mirror_num-1].dev;
-	kfree(bbio);
+	btrfs_put_bbio(bbio);
 	if (!dev || !dev->bdev || !dev->writeable) {
 		bio_put(bio);
 		return -EIO;
* Unmerged path fs/btrfs/raid56.c
diff --git a/fs/btrfs/reada.c b/fs/btrfs/reada.c
index 4d3d4e5287c5..0e7beea92b4c 100644
--- a/fs/btrfs/reada.c
+++ b/fs/btrfs/reada.c
@@ -461,7 +461,7 @@ static struct reada_extent *reada_find_extent(struct btrfs_root *root,
 	spin_unlock(&fs_info->reada_lock);
 	btrfs_dev_replace_unlock(&fs_info->dev_replace);
 
-	kfree(bbio);
+	btrfs_put_bbio(bbio);
 	return re;
 
 error:
@@ -486,7 +486,7 @@ error:
 		kref_put(&zone->refcnt, reada_zone_release);
 		spin_unlock(&fs_info->reada_lock);
 	}
-	kfree(bbio);
+	btrfs_put_bbio(bbio);
 	kfree(re);
 	return re_exist;
 }
* Unmerged path fs/btrfs/scrub.c
* Unmerged path fs/btrfs/volumes.c
* Unmerged path fs/btrfs/volumes.h
