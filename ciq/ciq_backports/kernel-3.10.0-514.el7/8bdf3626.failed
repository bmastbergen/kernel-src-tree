netfilter: nft_limit: constant token cost per packet

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 8bdf3626425520e9bc55996d5d46f60e12dd3ad7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8bdf3626.failed

The cost per packet can be calculated from the control plane path since this
doesn't ever change.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 8bdf3626425520e9bc55996d5d46f60e12dd3ad7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_limit.c
diff --cc net/netfilter/nft_limit.c
index 5301b69b3692,b418698e26b0..000000000000
--- a/net/netfilter/nft_limit.c
+++ b/net/netfilter/nft_limit.c
@@@ -94,13 -98,56 +94,66 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ struct nft_limit_pkts {
+ 	struct nft_limit	limit;
+ 	u64			cost;
+ };
+ 
+ static void nft_limit_pkts_eval(const struct nft_expr *expr,
+ 				struct nft_regs *regs,
+ 				const struct nft_pktinfo *pkt)
+ {
+ 	struct nft_limit_pkts *priv = nft_expr_priv(expr);
+ 
+ 	if (nft_limit_eval(&priv->limit, priv->cost))
+ 		regs->verdict.code = NFT_BREAK;
+ }
+ 
+ static const struct nla_policy nft_limit_policy[NFTA_LIMIT_MAX + 1] = {
+ 	[NFTA_LIMIT_RATE]	= { .type = NLA_U64 },
+ 	[NFTA_LIMIT_UNIT]	= { .type = NLA_U64 },
+ 	[NFTA_LIMIT_BURST]	= { .type = NLA_U32 },
+ };
+ 
+ static int nft_limit_pkts_init(const struct nft_ctx *ctx,
+ 			       const struct nft_expr *expr,
+ 			       const struct nlattr * const tb[])
+ {
+ 	struct nft_limit_pkts *priv = nft_expr_priv(expr);
+ 	int err;
+ 
+ 	err = nft_limit_init(&priv->limit, tb);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	priv->cost = div_u64(priv->limit.nsecs, priv->limit.rate);
+ 	return 0;
+ }
+ 
+ static int nft_limit_pkts_dump(struct sk_buff *skb, const struct nft_expr *expr)
+ {
+ 	const struct nft_limit_pkts *priv = nft_expr_priv(expr);
+ 
+ 	return nft_limit_dump(skb, &priv->limit);
+ }
+ 
++>>>>>>> 8bdf36264255 (netfilter: nft_limit: constant token cost per packet)
  static struct nft_expr_type nft_limit_type;
 -static const struct nft_expr_ops nft_limit_pkts_ops = {
 +static const struct nft_expr_ops nft_limit_ops = {
  	.type		= &nft_limit_type,
++<<<<<<< HEAD
 +	.size		= NFT_EXPR_SIZE(sizeof(struct nft_limit)),
 +	.eval		= nft_limit_eval,
 +	.init		= nft_limit_init,
 +	.dump		= nft_limit_dump,
++=======
+ 	.size		= NFT_EXPR_SIZE(sizeof(struct nft_limit_pkts)),
+ 	.eval		= nft_limit_pkts_eval,
+ 	.init		= nft_limit_pkts_init,
+ 	.dump		= nft_limit_pkts_dump,
++>>>>>>> 8bdf36264255 (netfilter: nft_limit: constant token cost per packet)
  };
  
  static struct nft_expr_type nft_limit_type __read_mostly = {
* Unmerged path net/netfilter/nft_limit.c
