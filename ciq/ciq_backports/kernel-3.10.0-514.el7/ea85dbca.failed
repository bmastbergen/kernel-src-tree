powercap / RAPL: mark rapl_ids array as __initconst

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [powercap] rapl: mark rapl_ids array as __initconst (Steve Best) [1274035]
Rebuild_FUZZ: 87.91%
commit-author Mathias Krause <minipli@googlemail.com>
commit ea85dbcaec0ff29f2c3f84be4c8a01a94e8bd449
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ea85dbca.failed

The RAPL ids are only tested in rapl_init() which is itself an __init
function. For the MODULE_DEVICE_TABLE() file2alias doesn't care about
the section, just about the symbol name. Therefore it's safe to mark the
rapl_ids[] array as __initconst so its memory can be released after
initialization is done.

	Signed-off-by: Mathias Krause <minipli@googlemail.com>
	Acked-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit ea85dbcaec0ff29f2c3f84be4c8a01a94e8bd449)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/powercap/intel_rapl.c
diff --cc drivers/powercap/intel_rapl.c
index 0fe8b75d996c,e03877c4b195..000000000000
--- a/drivers/powercap/intel_rapl.c
+++ b/drivers/powercap/intel_rapl.c
@@@ -946,22 -958,116 +946,135 @@@ static void package_power_limit_irq_res
  	wrmsr_on_cpu(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);
  }
  
++<<<<<<< HEAD
 +static const struct x86_cpu_id rapl_ids[] = {
 +	{ X86_VENDOR_INTEL, 6, 0x2a},/* Sandy Bridge */
 +	{ X86_VENDOR_INTEL, 6, 0x2d},/* Sandy Bridge EP */
 +	{ X86_VENDOR_INTEL, 6, 0x37},/* Valleyview */
 +	{ X86_VENDOR_INTEL, 6, 0x3a},/* Ivy Bridge */
 +	{ X86_VENDOR_INTEL, 6, 0x3c},/* Haswell */
 +	{ X86_VENDOR_INTEL, 6, 0x3d},/* Broadwell */
 +	{ X86_VENDOR_INTEL, 6, 0x3f},/* Haswell */
 +	{ X86_VENDOR_INTEL, 6, 0x4f},/* Broadwell servers */
 +	{ X86_VENDOR_INTEL, 6, 0x45},/* Haswell ULT */
 +	{ X86_VENDOR_INTEL, 6, 0x47},/* Broadwell-H */
 +	{ X86_VENDOR_INTEL, 6, 0x4E},/* Skylake */
 +	{ X86_VENDOR_INTEL, 6, 0x56},/* Future Xeon */
 +	{ X86_VENDOR_INTEL, 6, 0x57},/* Knights Landing */
 +	{ X86_VENDOR_INTEL, 6, 0x5E},/* Skylake-H/S */
 +	/* TODO: Add more CPU IDs after testing */
++=======
+ static void set_floor_freq_default(struct rapl_domain *rd, bool mode)
+ {
+ 	int nr_powerlimit = find_nr_power_limit(rd);
+ 
+ 	/* always enable clamp such that p-state can go below OS requested
+ 	 * range. power capping priority over guranteed frequency.
+ 	 */
+ 	rapl_write_data_raw(rd, PL1_CLAMP, mode);
+ 
+ 	/* some domains have pl2 */
+ 	if (nr_powerlimit > 1) {
+ 		rapl_write_data_raw(rd, PL2_ENABLE, mode);
+ 		rapl_write_data_raw(rd, PL2_CLAMP, mode);
+ 	}
+ }
+ 
+ static void set_floor_freq_atom(struct rapl_domain *rd, bool enable)
+ {
+ 	static u32 power_ctrl_orig_val;
+ 	u32 mdata;
+ 
+ 	if (!power_ctrl_orig_val)
+ 		iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_PMC_READ,
+ 			IOSF_CPU_POWER_BUDGET_CTL, &power_ctrl_orig_val);
+ 	mdata = power_ctrl_orig_val;
+ 	if (enable) {
+ 		mdata &= ~(0x7f << 8);
+ 		mdata |= 1 << 8;
+ 	}
+ 	iosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_PMC_WRITE,
+ 		IOSF_CPU_POWER_BUDGET_CTL, mdata);
+ }
+ 
+ static u64 rapl_compute_time_window_core(struct rapl_package *rp, u64 value,
+ 					bool to_raw)
+ {
+ 	u64 f, y; /* fraction and exp. used for time unit */
+ 
+ 	/*
+ 	 * Special processing based on 2^Y*(1+F/4), refer
+ 	 * to Intel Software Developer's manual Vol.3B: CH 14.9.3.
+ 	 */
+ 	if (!to_raw) {
+ 		f = (value & 0x60) >> 5;
+ 		y = value & 0x1f;
+ 		value = (1 << y) * (4 + f) * rp->time_unit / 4;
+ 	} else {
+ 		do_div(value, rp->time_unit);
+ 		y = ilog2(value);
+ 		f = div64_u64(4 * (value - (1 << y)), 1 << y);
+ 		value = (y & 0x1f) | ((f & 0x3) << 5);
+ 	}
+ 	return value;
+ }
+ 
+ static u64 rapl_compute_time_window_atom(struct rapl_package *rp, u64 value,
+ 					bool to_raw)
+ {
+ 	/*
+ 	 * Atom time unit encoding is straight forward val * time_unit,
+ 	 * where time_unit is default to 1 sec. Never 0.
+ 	 */
+ 	if (!to_raw)
+ 		return (value) ? value *= rp->time_unit : rp->time_unit;
+ 	else
+ 		value = div64_u64(value, rp->time_unit);
+ 
+ 	return value;
+ }
+ 
+ static const struct rapl_defaults rapl_defaults_core = {
+ 	.check_unit = rapl_check_unit_core,
+ 	.set_floor_freq = set_floor_freq_default,
+ 	.compute_time_window = rapl_compute_time_window_core,
+ };
+ 
+ static const struct rapl_defaults rapl_defaults_hsw_server = {
+ 	.check_unit = rapl_check_unit_core,
+ 	.set_floor_freq = set_floor_freq_default,
+ 	.compute_time_window = rapl_compute_time_window_core,
+ 	.dram_domain_energy_unit = 15300,
+ };
+ 
+ static const struct rapl_defaults rapl_defaults_atom = {
+ 	.check_unit = rapl_check_unit_atom,
+ 	.set_floor_freq = set_floor_freq_atom,
+ 	.compute_time_window = rapl_compute_time_window_atom,
+ };
+ 
+ #define RAPL_CPU(_model, _ops) {			\
+ 		.vendor = X86_VENDOR_INTEL,		\
+ 		.family = 6,				\
+ 		.model = _model,			\
+ 		.driver_data = (kernel_ulong_t)&_ops,	\
+ 		}
+ 
+ static const struct x86_cpu_id rapl_ids[] __initconst = {
+ 	RAPL_CPU(0x2a, rapl_defaults_core),/* Sandy Bridge */
+ 	RAPL_CPU(0x2d, rapl_defaults_core),/* Sandy Bridge EP */
+ 	RAPL_CPU(0x37, rapl_defaults_atom),/* Valleyview */
+ 	RAPL_CPU(0x3a, rapl_defaults_core),/* Ivy Bridge */
+ 	RAPL_CPU(0x3c, rapl_defaults_core),/* Haswell */
+ 	RAPL_CPU(0x3d, rapl_defaults_core),/* Broadwell */
+ 	RAPL_CPU(0x3f, rapl_defaults_hsw_server),/* Haswell servers */
+ 	RAPL_CPU(0x4f, rapl_defaults_hsw_server),/* Broadwell servers */
+ 	RAPL_CPU(0x45, rapl_defaults_core),/* Haswell ULT */
+ 	RAPL_CPU(0x4C, rapl_defaults_atom),/* Braswell */
+ 	RAPL_CPU(0x4A, rapl_defaults_atom),/* Tangier */
+ 	RAPL_CPU(0x56, rapl_defaults_core),/* Future Xeon */
+ 	RAPL_CPU(0x5A, rapl_defaults_atom),/* Annidale */
++>>>>>>> ea85dbcaec0f (powercap / RAPL: mark rapl_ids array as __initconst)
  	{}
  };
  MODULE_DEVICE_TABLE(x86cpu, rapl_ids);
* Unmerged path drivers/powercap/intel_rapl.c
