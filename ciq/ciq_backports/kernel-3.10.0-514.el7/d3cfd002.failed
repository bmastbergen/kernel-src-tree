iw_cxgb4: Remove old FRWR API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sagi Grimberg <sagig@mellanox.com>
commit d3cfd002e6586d715515c2f293cf04cf72b33002
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d3cfd002.failed

No ULP uses it anymore, go ahead and remove it.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Acked-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit d3cfd002e6586d715515c2f293cf04cf72b33002)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/cxgb4/mem.c
#	drivers/infiniband/hw/cxgb4/provider.c
#	drivers/infiniband/hw/cxgb4/qp.c
diff --cc drivers/infiniband/hw/cxgb4/mem.c
index 574f3065888c,e1629ab58db7..000000000000
--- a/drivers/infiniband/hw/cxgb4/mem.c
+++ b/drivers/infiniband/hw/cxgb4/mem.c
@@@ -886,49 -922,27 +886,73 @@@ err
  	return ERR_PTR(ret);
  }
  
++<<<<<<< HEAD
 +struct ib_fast_reg_page_list *c4iw_alloc_fastreg_pbl(struct ib_device *device,
 +						     int page_list_len)
 +{
 +	struct c4iw_fr_page_list *c4pl;
 +	struct c4iw_dev *dev = to_c4iw_dev(device);
 +	dma_addr_t dma_addr;
 +	int pll_len = roundup(page_list_len * sizeof(u64), 32);
 +
 +	c4pl = kmalloc(sizeof(*c4pl), GFP_KERNEL);
 +	if (!c4pl)
 +		return ERR_PTR(-ENOMEM);
 +
 +	c4pl->ibpl.page_list = dma_alloc_coherent(&dev->rdev.lldi.pdev->dev,
 +						  pll_len, &dma_addr,
 +						  GFP_KERNEL);
 +	if (!c4pl->ibpl.page_list) {
 +		kfree(c4pl);
 +		return ERR_PTR(-ENOMEM);
 +	}
 +	dma_unmap_addr_set(c4pl, mapping, dma_addr);
 +	c4pl->dma_addr = dma_addr;
 +	c4pl->dev = dev;
 +	c4pl->pll_len = pll_len;
 +
 +	PDBG("%s c4pl %p pll_len %u page_list %p dma_addr %pad\n",
 +	     __func__, c4pl, c4pl->pll_len, c4pl->ibpl.page_list,
 +	     &c4pl->dma_addr);
 +
 +	return &c4pl->ibpl;
 +}
 +
 +void c4iw_free_fastreg_pbl(struct ib_fast_reg_page_list *ibpl)
 +{
 +	struct c4iw_fr_page_list *c4pl = to_c4iw_fr_page_list(ibpl);
 +
 +	PDBG("%s c4pl %p pll_len %u page_list %p dma_addr %pad\n",
 +	     __func__, c4pl, c4pl->pll_len, c4pl->ibpl.page_list,
 +	     &c4pl->dma_addr);
 +
 +	dma_free_coherent(&c4pl->dev->rdev.lldi.pdev->dev,
 +			  c4pl->pll_len,
 +			  c4pl->ibpl.page_list, dma_unmap_addr(c4pl, mapping));
 +	kfree(c4pl);
++=======
+ static int c4iw_set_page(struct ib_mr *ibmr, u64 addr)
+ {
+ 	struct c4iw_mr *mhp = to_c4iw_mr(ibmr);
+ 
+ 	if (unlikely(mhp->mpl_len == mhp->max_mpl_len))
+ 		return -ENOMEM;
+ 
+ 	mhp->mpl[mhp->mpl_len++] = addr;
+ 
+ 	return 0;
+ }
+ 
+ int c4iw_map_mr_sg(struct ib_mr *ibmr,
+ 		   struct scatterlist *sg,
+ 		   int sg_nents)
+ {
+ 	struct c4iw_mr *mhp = to_c4iw_mr(ibmr);
+ 
+ 	mhp->mpl_len = 0;
+ 
+ 	return ib_sg_to_pages(ibmr, sg, sg_nents, c4iw_set_page);
++>>>>>>> d3cfd002e658 (iw_cxgb4: Remove old FRWR API)
  }
  
  int c4iw_dereg_mr(struct ib_mr *ib_mr)
diff --cc drivers/infiniband/hw/cxgb4/provider.c
index 7746113552e7,0a7d99818b17..000000000000
--- a/drivers/infiniband/hw/cxgb4/provider.c
+++ b/drivers/infiniband/hw/cxgb4/provider.c
@@@ -557,8 -557,7 +557,12 @@@ int c4iw_register_device(struct c4iw_de
  	dev->ibdev.bind_mw = c4iw_bind_mw;
  	dev->ibdev.dealloc_mw = c4iw_dealloc_mw;
  	dev->ibdev.alloc_mr = c4iw_alloc_mr;
++<<<<<<< HEAD
 +	dev->ibdev.alloc_fast_reg_page_list = c4iw_alloc_fastreg_pbl;
 +	dev->ibdev.free_fast_reg_page_list = c4iw_free_fastreg_pbl;
++=======
+ 	dev->ibdev.map_mr_sg = c4iw_map_mr_sg;
++>>>>>>> d3cfd002e658 (iw_cxgb4: Remove old FRWR API)
  	dev->ibdev.attach_mcast = c4iw_multicast_attach;
  	dev->ibdev.detach_mcast = c4iw_multicast_detach;
  	dev->ibdev.process_mad = c4iw_process_mad;
diff --cc drivers/infiniband/hw/cxgb4/qp.c
index 323fa1d872d6,aa515afee724..000000000000
--- a/drivers/infiniband/hw/cxgb4/qp.c
+++ b/drivers/infiniband/hw/cxgb4/qp.c
@@@ -631,21 -630,16 +631,32 @@@ static int build_fastreg(struct t4_sq *
  					0xffffffff);
  
  	if (t5dev && use_dsgl && (pbllen > max_fr_immd)) {
++<<<<<<< HEAD
 +		struct c4iw_fr_page_list *c4pl =
 +			to_c4iw_fr_page_list(wr->wr.fast_reg.page_list);
 +		struct fw_ri_dsgl *sglp;
 +
 +		for (i = 0; i < wr->wr.fast_reg.page_list_len; i++) {
 +			wr->wr.fast_reg.page_list->page_list[i] = (__force u64)
 +				cpu_to_be64((u64)
 +				wr->wr.fast_reg.page_list->page_list[i]);
 +		}
++=======
+ 		struct fw_ri_dsgl *sglp;
+ 
+ 		for (i = 0; i < mhp->mpl_len; i++)
+ 			mhp->mpl[i] = (__force u64)cpu_to_be64((u64)mhp->mpl[i]);
++>>>>>>> d3cfd002e658 (iw_cxgb4: Remove old FRWR API)
  
  		sglp = (struct fw_ri_dsgl *)(&wqe->fr + 1);
  		sglp->op = FW_RI_DATA_DSGL;
  		sglp->r1 = 0;
  		sglp->nsge = cpu_to_be16(1);
++<<<<<<< HEAD
 +		sglp->addr0 = cpu_to_be64(c4pl->dma_addr);
++=======
+ 		sglp->addr0 = cpu_to_be64(mhp->mpl_addr);
++>>>>>>> d3cfd002e658 (iw_cxgb4: Remove old FRWR API)
  		sglp->len0 = cpu_to_be32(pbllen);
  
  		*len16 = DIV_ROUND_UP(sizeof(wqe->fr) + sizeof(*sglp), 16);
@@@ -657,9 -651,8 +668,14 @@@
  		imdp->immdlen = cpu_to_be32(pbllen);
  		p = (__be64 *)(imdp + 1);
  		rem = pbllen;
++<<<<<<< HEAD
 +		for (i = 0; i < wr->wr.fast_reg.page_list_len; i++) {
 +			*p = cpu_to_be64(
 +				(u64)wr->wr.fast_reg.page_list->page_list[i]);
++=======
+ 		for (i = 0; i < mhp->mpl_len; i++) {
+ 			*p = cpu_to_be64((u64)mhp->mpl[i]);
++>>>>>>> d3cfd002e658 (iw_cxgb4: Remove old FRWR API)
  			rem -= sizeof(*p);
  			if (++p == (__be64 *)&sq->queue[sq->size])
  				p = (__be64 *)sq->queue;
@@@ -813,13 -804,13 +829,23 @@@ int c4iw_post_send(struct ib_qp *ibqp, 
  			if (!qhp->wq.sq.oldest_read)
  				qhp->wq.sq.oldest_read = swsqe;
  			break;
++<<<<<<< HEAD
 +		case IB_WR_FAST_REG_MR:
 +			fw_opcode = FW_RI_FR_NSMR_WR;
 +			swsqe->opcode = FW_RI_FAST_REGISTER;
 +			err = build_fastreg(&qhp->wq.sq, wqe, wr, &len16,
 +					    is_t5(
 +					    qhp->rhp->rdev.lldi.adapter_type) ?
 +					    1 : 0);
++=======
+ 		case IB_WR_REG_MR:
+ 			fw_opcode = FW_RI_FR_NSMR_WR;
+ 			swsqe->opcode = FW_RI_FAST_REGISTER;
+ 			err = build_memreg(&qhp->wq.sq, wqe, reg_wr(wr), &len16,
+ 					   is_t5(
+ 					   qhp->rhp->rdev.lldi.adapter_type) ?
+ 					   1 : 0);
++>>>>>>> d3cfd002e658 (iw_cxgb4: Remove old FRWR API)
  			break;
  		case IB_WR_LOCAL_INV:
  			if (wr->send_flags & IB_SEND_FENCE)
diff --git a/drivers/infiniband/hw/cxgb4/cq.c b/drivers/infiniband/hw/cxgb4/cq.c
index 33c24f0bc645..4934b42e74e5 100644
--- a/drivers/infiniband/hw/cxgb4/cq.c
+++ b/drivers/infiniband/hw/cxgb4/cq.c
@@ -752,7 +752,7 @@ static int c4iw_poll_cq_one(struct c4iw_cq *chp, struct ib_wc *wc)
 			wc->opcode = IB_WC_LOCAL_INV;
 			break;
 		case FW_RI_FAST_REGISTER:
-			wc->opcode = IB_WC_FAST_REG_MR;
+			wc->opcode = IB_WC_REG_MR;
 			break;
 		default:
 			printk(KERN_ERR MOD "Unexpected opcode %d "
diff --git a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
index c7bb38c931a5..0136fa767d0a 100644
--- a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
+++ b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
@@ -405,20 +405,6 @@ static inline struct c4iw_mw *to_c4iw_mw(struct ib_mw *ibmw)
 	return container_of(ibmw, struct c4iw_mw, ibmw);
 }
 
-struct c4iw_fr_page_list {
-	struct ib_fast_reg_page_list ibpl;
-	DEFINE_DMA_UNMAP_ADDR(mapping);
-	dma_addr_t dma_addr;
-	struct c4iw_dev *dev;
-	int pll_len;
-};
-
-static inline struct c4iw_fr_page_list *to_c4iw_fr_page_list(
-					struct ib_fast_reg_page_list *ibpl)
-{
-	return container_of(ibpl, struct c4iw_fr_page_list, ibpl);
-}
-
 struct c4iw_cq {
 	struct ib_cq ibcq;
 	struct c4iw_dev *rhp;
@@ -966,10 +952,6 @@ int c4iw_accept_cr(struct iw_cm_id *cm_id, struct iw_cm_conn_param *conn_param);
 int c4iw_reject_cr(struct iw_cm_id *cm_id, const void *pdata, u8 pdata_len);
 void c4iw_qp_add_ref(struct ib_qp *qp);
 void c4iw_qp_rem_ref(struct ib_qp *qp);
-void c4iw_free_fastreg_pbl(struct ib_fast_reg_page_list *page_list);
-struct ib_fast_reg_page_list *c4iw_alloc_fastreg_pbl(
-					struct ib_device *device,
-					int page_list_len);
 struct ib_mr *c4iw_alloc_mr(struct ib_pd *pd,
 			    enum ib_mr_type mr_type,
 			    u32 max_num_sg);
* Unmerged path drivers/infiniband/hw/cxgb4/mem.c
* Unmerged path drivers/infiniband/hw/cxgb4/provider.c
* Unmerged path drivers/infiniband/hw/cxgb4/qp.c
