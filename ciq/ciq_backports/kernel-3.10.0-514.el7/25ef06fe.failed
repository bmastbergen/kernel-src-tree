Drivers: hv: fcopy: dynamically allocate smsg_out in fcopy_send_data()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hv] fcopy: dynamically allocate smsg_out in fcopy_send_data() (Vitaly Kuznetsov) [1074407 1309368]
Rebuild_FUZZ: 89.76%
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 25ef06fe27a292ad33155045ef7a123be4c0b6ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/25ef06fe.failed

struct hv_start_fcopy is too big to be on stack on i386, the following
warning is reported:

>> drivers/hv/hv_fcopy.c:159:1: warning: the frame size of 1088 bytes is larger than 1024 bytes [-Wframe-larger-than=]

	Reported-by: kbuild test robot <fengguang.wu@intel.com>
	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 25ef06fe27a292ad33155045ef7a123be4c0b6ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/hv_fcopy.c
diff --cc drivers/hv/hv_fcopy.c
index d1475e6aa9ac,db4b887b889d..000000000000
--- a/drivers/hv/hv_fcopy.c
+++ b/drivers/hv/hv_fcopy.c
@@@ -115,11 -114,13 +115,15 @@@ static int fcopy_handle_handshake(u32 v
  	return 0;
  }
  
 -static void fcopy_send_data(struct work_struct *dummy)
 +static void fcopy_send_data(void)
  {
++<<<<<<< HEAD
 +	struct hv_start_fcopy *smsg_out = &fcopy_transaction.message;
++=======
+ 	struct hv_start_fcopy *smsg_out = NULL;
++>>>>>>> 25ef06fe27a2 (Drivers: hv: fcopy: dynamically allocate smsg_out in fcopy_send_data())
  	int operation = fcopy_transaction.fcopy_msg->operation;
  	struct hv_start_fcopy *smsg_in;
 -	void *out_src;
 -	int rc, out_len;
  
  	/*
  	 * The  strings sent from the host are encoded in
@@@ -134,26 -135,44 +138,61 @@@
  
  	switch (operation) {
  	case START_FILE_COPY:
++<<<<<<< HEAD
 +		memset(smsg_out, 0, sizeof(struct hv_start_fcopy));
++=======
+ 		out_len = sizeof(struct hv_start_fcopy);
+ 		smsg_out = kzalloc(sizeof(*smsg_out), GFP_KERNEL);
+ 		if (!smsg_out)
+ 			return;
+ 
++>>>>>>> 25ef06fe27a2 (Drivers: hv: fcopy: dynamically allocate smsg_out in fcopy_send_data())
  		smsg_out->hdr.operation = operation;
  		smsg_in = (struct hv_start_fcopy *)fcopy_transaction.fcopy_msg;
  
  		utf16s_to_utf8s((wchar_t *)smsg_in->file_name, W_MAX_PATH,
  				UTF16_LITTLE_ENDIAN,
++<<<<<<< HEAD
 +				(__u8 *)smsg_out->file_name, W_MAX_PATH - 1);
 +
 +		utf16s_to_utf8s((wchar_t *)smsg_in->path_name, W_MAX_PATH,
 +				UTF16_LITTLE_ENDIAN,
 +				(__u8 *)smsg_out->path_name, W_MAX_PATH - 1);
 +
 +		smsg_out->copy_flags = smsg_in->copy_flags;
 +		smsg_out->file_size = smsg_in->file_size;
++=======
+ 				(__u8 *)&smsg_out->file_name, W_MAX_PATH - 1);
+ 
+ 		utf16s_to_utf8s((wchar_t *)smsg_in->path_name, W_MAX_PATH,
+ 				UTF16_LITTLE_ENDIAN,
+ 				(__u8 *)&smsg_out->path_name, W_MAX_PATH - 1);
+ 
+ 		smsg_out->copy_flags = smsg_in->copy_flags;
+ 		smsg_out->file_size = smsg_in->file_size;
+ 		out_src = smsg_out;
++>>>>>>> 25ef06fe27a2 (Drivers: hv: fcopy: dynamically allocate smsg_out in fcopy_send_data())
  		break;
  
  	default:
 -		out_src = fcopy_transaction.fcopy_msg;
 -		out_len = fcopy_transaction.recv_len;
  		break;
  	}
++<<<<<<< HEAD
 +	up(&fcopy_transaction.read_sema);
++=======
+ 
+ 	fcopy_transaction.state = HVUTIL_USERSPACE_REQ;
+ 	rc = hvutil_transport_send(hvt, out_src, out_len);
+ 	if (rc) {
+ 		pr_debug("FCP: failed to communicate to the daemon: %d\n", rc);
+ 		if (cancel_delayed_work_sync(&fcopy_timeout_work)) {
+ 			fcopy_respond_to_host(HV_E_FAIL);
+ 			fcopy_transaction.state = HVUTIL_READY;
+ 		}
+ 	}
+ 	kfree(smsg_out);
+ 
++>>>>>>> 25ef06fe27a2 (Drivers: hv: fcopy: dynamically allocate smsg_out in fcopy_send_data())
  	return;
  }
  
* Unmerged path drivers/hv/hv_fcopy.c
