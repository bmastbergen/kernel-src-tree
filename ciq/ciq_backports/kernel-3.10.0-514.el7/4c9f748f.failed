nvme: don't take the I/O queue q_lock in nvme_timeout

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 4c9f748f0ee88447b28546991f60f43a7319aafd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4c9f748f.failed

There is nothing it protects, but it makes lockdep unhappy in many different
ways.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 4c9f748f0ee88447b28546991f60f43a7319aafd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index 2a6eb55ad96c,d4fef8190093..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -1097,19 -1094,13 +1097,29 @@@ static void nvme_abort_req(struct reque
  	struct nvme_command cmd;
  
  	if (!nvmeq->qid || cmd_rq->aborted) {
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +		unsigned long flags;
 +
 +		spin_lock_irqsave(&dev_list_lock, flags);
 +		if (work_busy(&dev->reset_work))
 +			goto out;
 +		list_del_init(&dev->node);
 +		dev_warn(&dev->pci_dev->dev,
 +			"I/O %d QID %d timeout, reset controller\n",
 +							req->tag, nvmeq->qid);
 +		PREPARE_WORK(&dev->reset_work, nvme_reset_failed_dev);
 +		queue_work(nvme_workq, &dev->reset_work);
 + out:
 +		spin_unlock_irqrestore(&dev_list_lock, flags);
++=======
+ 		spin_lock_irq(&dev_list_lock);
+ 		if (!__nvme_reset(dev)) {
+ 			dev_warn(dev->dev,
+ 				 "I/O %d QID %d timeout, reset controller\n",
+ 				 req->tag, nvmeq->qid);
+ 		}
+ 		spin_unlock_irq(&dev_list_lock);
++>>>>>>> 4c9f748f0ee8 (nvme: don't take the I/O queue q_lock in nvme_timeout):drivers/nvme/host/pci.c
  		return;
  	}
  
* Unmerged path drivers/block/nvme-core.c
