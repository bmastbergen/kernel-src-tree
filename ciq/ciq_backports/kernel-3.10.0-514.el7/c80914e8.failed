dm: return error if bio_integrity_clone() fails in clone_bio()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mike Snitzer <snitzer@redhat.com>
commit c80914e81ec5b08fec0bae531e3445268c8820f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c80914e8.failed

clone_bio() now checks if bio_integrity_clone() returned an error rather
than just drop it on the floor.

	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit c80914e81ec5b08fec0bae531e3445268c8820f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index b809eea744af,70d5b82a353a..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -1518,20 -1567,26 +1518,41 @@@ static void clone_split_bio(struct dm_t
  /*
   * Creates a bio that consists of range of complete bvecs.
   */
++<<<<<<< HEAD
 +static void clone_bio(struct dm_target_io *tio, struct bio *bio,
 +		      sector_t sector, unsigned short idx,
 +		      unsigned short bv_count, unsigned len)
++=======
+ static int clone_bio(struct dm_target_io *tio, struct bio *bio,
+ 		     sector_t sector, unsigned len)
++>>>>>>> c80914e81ec5 (dm: return error if bio_integrity_clone() fails in clone_bio())
  {
  	struct bio *clone = &tio->clone;
 +	unsigned trim = 0;
  
 -	__bio_clone_fast(clone, bio);
 +	__bio_clone(clone, bio);
 +	bio_setup_sector(clone, sector, len);
 +	bio_setup_bv(clone, idx, bv_count);
  
++<<<<<<< HEAD
 +	if (idx != bio->bi_idx || clone->bi_size < bio->bi_size)
 +		trim = 1;
 +	clone_bio_integrity(bio, clone, idx, len, 0, trim);
++=======
+ 	if (bio_integrity(bio)) {
+ 		int r = bio_integrity_clone(clone, bio, GFP_NOIO);
+ 		if (r < 0)
+ 			return r;
+ 	}
+ 
+ 	bio_advance(clone, to_bytes(sector - clone->bi_iter.bi_sector));
+ 	clone->bi_iter.bi_size = to_bytes(len);
+ 
+ 	if (bio_integrity(bio))
+ 		bio_integrity_trim(clone, 0, len);
+ 
+ 	return 0;
++>>>>>>> c80914e81ec5 (dm: return error if bio_integrity_clone() fails in clone_bio())
  }
  
  static struct dm_target_io *alloc_tio(struct clone_info *ci,
@@@ -1591,11 -1643,8 +1612,16 @@@ static int __send_empty_flush(struct cl
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void __clone_and_map_data_bio(struct clone_info *ci, struct dm_target *ti,
 +				     sector_t sector, int nr_iovecs,
 +				     unsigned short idx, unsigned short bv_count,
 +				     unsigned offset, unsigned len,
 +				     unsigned split_bvec)
++=======
+ static int __clone_and_map_data_bio(struct clone_info *ci, struct dm_target *ti,
+ 				     sector_t sector, unsigned *len)
++>>>>>>> c80914e81ec5 (dm: return error if bio_integrity_clone() fails in clone_bio())
  {
  	struct bio *bio = ci->bio;
  	struct dm_target_io *tio;
@@@ -1609,13 -1659,15 +1636,23 @@@
  		num_target_bios = ti->num_write_bios(ti, bio);
  
  	for (target_bio_nr = 0; target_bio_nr < num_target_bios; target_bio_nr++) {
++<<<<<<< HEAD
 +		tio = alloc_tio(ci, ti, nr_iovecs, target_bio_nr);
 +		if (split_bvec)
 +			clone_split_bio(tio, bio, sector, idx, offset, len);
 +		else
 +			clone_bio(tio, bio, sector, idx, bv_count, len);
++=======
+ 		tio = alloc_tio(ci, ti, target_bio_nr);
+ 		tio->len_ptr = len;
+ 		r = clone_bio(tio, bio, sector, *len);
+ 		if (r < 0)
+ 			break;
++>>>>>>> c80914e81ec5 (dm: return error if bio_integrity_clone() fails in clone_bio())
  		__map_bio(tio);
  	}
+ 
+ 	return r;
  }
  
  typedef unsigned (*get_num_bios_fn)(struct dm_target *ti);
@@@ -1745,8 -1743,8 +1782,13 @@@ static int __split_and_process_non_flus
  {
  	struct bio *bio = ci->bio;
  	struct dm_target *ti;
++<<<<<<< HEAD
 +	sector_t len, max;
 +	int idx;
++=======
+ 	unsigned len;
+ 	int r;
++>>>>>>> c80914e81ec5 (dm: return error if bio_integrity_clone() fails in clone_bio())
  
  	if (unlikely(bio->bi_rw & REQ_DISCARD))
  		return __send_discard(ci);
@@@ -1757,41 -1755,16 +1799,47 @@@
  	if (!dm_target_is_valid(ti))
  		return -EIO;
  
 -	len = min_t(sector_t, max_io_len(ci->sector, ti), ci->sector_count);
 +	max = max_io_len(ci->sector, ti);
  
++<<<<<<< HEAD
 +	/*
 +	 * Optimise for the simple case where we can do all of
 +	 * the remaining io with a single clone.
 +	 */
 +	if (ci->sector_count <= max) {
 +		__clone_and_map_data_bio(ci, ti, ci->sector, bio->bi_max_vecs,
 +					 ci->idx, bio->bi_vcnt - ci->idx, 0,
 +					 ci->sector_count, 0);
 +		ci->sector_count = 0;
 +		return 0;
 +	}
++=======
+ 	r = __clone_and_map_data_bio(ci, ti, ci->sector, &len);
+ 	if (r < 0)
+ 		return r;
++>>>>>>> c80914e81ec5 (dm: return error if bio_integrity_clone() fails in clone_bio())
  
 -	ci->sector += len;
 -	ci->sector_count -= len;
 +	/*
 +	 * There are some bvecs that don't span targets.
 +	 * Do as many of these as possible.
 +	 */
 +	if (to_sector(bio->bi_io_vec[ci->idx].bv_len) <= max) {
 +		len = __len_within_target(ci, max, &idx);
  
 -	return 0;
 +		__clone_and_map_data_bio(ci, ti, ci->sector, bio->bi_max_vecs,
 +					 ci->idx, idx - ci->idx, 0, len, 0);
 +
 +		ci->sector += len;
 +		ci->sector_count -= len;
 +		ci->idx = idx;
 +
 +		return 0;
 +	}
 +
 +	/*
 +	 * Handle a bvec that must be split between two or more targets.
 +	 */
 +	return __split_bvec_across_targets(ci, ti, max);
  }
  
  /*
* Unmerged path drivers/md/dm.c
