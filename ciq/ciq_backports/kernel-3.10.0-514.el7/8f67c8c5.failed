megaraid_sas: Fix for IO failing post OCR in SRIOV environment

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sumit Saxena <sumit.saxena@avagotech.com>
commit 8f67c8c518f324874e8caf93d1f4468d25754333
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8f67c8c5.failed

Driver assumes that VFs always have peers present whenever they have
same LD IDs. But this is not the case.  This patch handles the above
mentioned by explicitly checking for a peer before making HA/non-HA path
decision.

	Signed-off-by: Uday Lingala <uday.lingala@avagotech.com>
	Signed-off-by: Sumit Saxena <sumit.saxena@avagotech.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 8f67c8c518f324874e8caf93d1f4468d25754333)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas_fusion.c
diff --cc drivers/scsi/megaraid/megaraid_sas_fusion.c
index a09ae37a613c,d9d0029fb1b0..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@@ -2726,6 -2879,469 +2726,472 @@@ void megasas_refire_mgmt_cmd(struct meg
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * megasas_track_scsiio : Track SCSI IOs outstanding to a SCSI device
+  * @instance: per adapter struct
+  * @channel: the channel assigned by the OS
+  * @id: the id assigned by the OS
+  *
+  * Returns SUCCESS if no IOs pending to SCSI device, else return FAILED
+  */
+ 
+ static int megasas_track_scsiio(struct megasas_instance *instance,
+ 		int id, int channel)
+ {
+ 	int i, found = 0;
+ 	struct megasas_cmd_fusion *cmd_fusion;
+ 	struct fusion_context *fusion;
+ 	fusion = instance->ctrl_context;
+ 
+ 	for (i = 0 ; i < instance->max_scsi_cmds; i++) {
+ 		cmd_fusion = fusion->cmd_list[i];
+ 		if (cmd_fusion->scmd &&
+ 			(cmd_fusion->scmd->device->id == id &&
+ 			cmd_fusion->scmd->device->channel == channel)) {
+ 			dev_info(&instance->pdev->dev,
+ 				"SCSI commands pending to target"
+ 				"channel %d id %d \tSMID: 0x%x\n",
+ 				channel, id, cmd_fusion->index);
+ 			scsi_print_command(cmd_fusion->scmd);
+ 			found = 1;
+ 			break;
+ 		}
+ 	}
+ 
+ 	return found ? FAILED : SUCCESS;
+ }
+ 
+ /**
+  * megasas_tm_response_code - translation of device response code
+  * @ioc: per adapter object
+  * @mpi_reply: MPI reply returned by firmware
+  *
+  * Return nothing.
+  */
+ static void
+ megasas_tm_response_code(struct megasas_instance *instance,
+ 		struct MPI2_SCSI_TASK_MANAGE_REPLY *mpi_reply)
+ {
+ 	char *desc;
+ 
+ 	switch (mpi_reply->ResponseCode) {
+ 	case MPI2_SCSITASKMGMT_RSP_TM_COMPLETE:
+ 		desc = "task management request completed";
+ 		break;
+ 	case MPI2_SCSITASKMGMT_RSP_INVALID_FRAME:
+ 		desc = "invalid frame";
+ 		break;
+ 	case MPI2_SCSITASKMGMT_RSP_TM_NOT_SUPPORTED:
+ 		desc = "task management request not supported";
+ 		break;
+ 	case MPI2_SCSITASKMGMT_RSP_TM_FAILED:
+ 		desc = "task management request failed";
+ 		break;
+ 	case MPI2_SCSITASKMGMT_RSP_TM_SUCCEEDED:
+ 		desc = "task management request succeeded";
+ 		break;
+ 	case MPI2_SCSITASKMGMT_RSP_TM_INVALID_LUN:
+ 		desc = "invalid lun";
+ 		break;
+ 	case 0xA:
+ 		desc = "overlapped tag attempted";
+ 		break;
+ 	case MPI2_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC:
+ 		desc = "task queued, however not sent to target";
+ 		break;
+ 	default:
+ 		desc = "unknown";
+ 		break;
+ 	}
+ 	dev_dbg(&instance->pdev->dev, "response_code(%01x): %s\n",
+ 		mpi_reply->ResponseCode, desc);
+ 	dev_dbg(&instance->pdev->dev,
+ 		"TerminationCount/DevHandle/Function/TaskType/IOCStat/IOCLoginfo"
+ 		" 0x%x/0x%x/0x%x/0x%x/0x%x/0x%x\n",
+ 		mpi_reply->TerminationCount, mpi_reply->DevHandle,
+ 		mpi_reply->Function, mpi_reply->TaskType,
+ 		mpi_reply->IOCStatus, mpi_reply->IOCLogInfo);
+ }
+ 
+ /**
+  * megasas_issue_tm - main routine for sending tm requests
+  * @instance: per adapter struct
+  * @device_handle: device handle
+  * @channel: the channel assigned by the OS
+  * @id: the id assigned by the OS
+  * @type: MPI2_SCSITASKMGMT_TASKTYPE__XXX (defined in megaraid_sas_fusion.c)
+  * @smid_task: smid assigned to the task
+  * @m_type: TM_MUTEX_ON or TM_MUTEX_OFF
+  * Context: user
+  *
+  * MegaRaid use MPT interface for Task Magement request.
+  * A generic API for sending task management requests to firmware.
+  *
+  * Return SUCCESS or FAILED.
+  */
+ static int
+ megasas_issue_tm(struct megasas_instance *instance, u16 device_handle,
+ 	uint channel, uint id, u16 smid_task, u8 type)
+ {
+ 	struct MR_TASK_MANAGE_REQUEST *mr_request;
+ 	struct MPI2_SCSI_TASK_MANAGE_REQUEST *mpi_request;
+ 	unsigned long timeleft;
+ 	struct megasas_cmd_fusion *cmd_fusion;
+ 	struct megasas_cmd *cmd_mfi;
+ 	union MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;
+ 	struct fusion_context *fusion;
+ 	struct megasas_cmd_fusion *scsi_lookup;
+ 	int rc;
+ 	struct MPI2_SCSI_TASK_MANAGE_REPLY *mpi_reply;
+ 
+ 	fusion = instance->ctrl_context;
+ 
+ 	cmd_mfi = megasas_get_cmd(instance);
+ 
+ 	if (!cmd_mfi) {
+ 		dev_err(&instance->pdev->dev, "Failed from %s %d\n",
+ 			__func__, __LINE__);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	cmd_fusion = megasas_get_cmd_fusion(instance,
+ 			instance->max_scsi_cmds + cmd_mfi->index);
+ 
+ 	/*  Save the smid. To be used for returning the cmd */
+ 	cmd_mfi->context.smid = cmd_fusion->index;
+ 
+ 	req_desc = megasas_get_request_descriptor(instance,
+ 			(cmd_fusion->index - 1));
+ 	if (!req_desc) {
+ 		dev_err(&instance->pdev->dev, "Failed from %s %d\n",
+ 			__func__, __LINE__);
+ 		megasas_return_cmd(instance, cmd_mfi);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	cmd_fusion->request_desc = req_desc;
+ 	req_desc->Words = 0;
+ 
+ 	scsi_lookup = fusion->cmd_list[smid_task - 1];
+ 
+ 	mr_request = (struct MR_TASK_MANAGE_REQUEST *) cmd_fusion->io_request;
+ 	memset(mr_request, 0, sizeof(struct MR_TASK_MANAGE_REQUEST));
+ 	mpi_request = (struct MPI2_SCSI_TASK_MANAGE_REQUEST *) &mr_request->TmRequest;
+ 	mpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;
+ 	mpi_request->DevHandle = cpu_to_le16(device_handle);
+ 	mpi_request->TaskType = type;
+ 	mpi_request->TaskMID = cpu_to_le16(smid_task);
+ 	mpi_request->LUN[1] = 0;
+ 
+ 
+ 	req_desc = cmd_fusion->request_desc;
+ 	req_desc->HighPriority.SMID = cpu_to_le16(cmd_fusion->index);
+ 	req_desc->HighPriority.RequestFlags =
+ 		(MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY <<
+ 		MEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);
+ 	req_desc->HighPriority.MSIxIndex =  0;
+ 	req_desc->HighPriority.LMID = 0;
+ 	req_desc->HighPriority.Reserved1 = 0;
+ 
+ 	if (channel < MEGASAS_MAX_PD_CHANNELS)
+ 		mr_request->tmReqFlags.isTMForPD = 1;
+ 	else
+ 		mr_request->tmReqFlags.isTMForLD = 1;
+ 
+ 	init_completion(&cmd_fusion->done);
+ 	megasas_fire_cmd_fusion(instance, req_desc);
+ 
+ 	timeleft = wait_for_completion_timeout(&cmd_fusion->done, 50 * HZ);
+ 
+ 	if (!timeleft) {
+ 		dev_err(&instance->pdev->dev,
+ 			"task mgmt type 0x%x timed out\n", type);
+ 		cmd_mfi->flags |= DRV_DCMD_SKIP_REFIRE;
+ 		mutex_unlock(&instance->reset_mutex);
+ 		rc = megasas_reset_fusion(instance->host, MFI_IO_TIMEOUT_OCR);
+ 		mutex_lock(&instance->reset_mutex);
+ 		return rc;
+ 	}
+ 
+ 	mpi_reply = (struct MPI2_SCSI_TASK_MANAGE_REPLY *) &mr_request->TMReply;
+ 	megasas_tm_response_code(instance, mpi_reply);
+ 
+ 	megasas_return_cmd(instance, cmd_mfi);
+ 	rc = SUCCESS;
+ 	switch (type) {
+ 	case MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK:
+ 		if (scsi_lookup->scmd == NULL)
+ 			break;
+ 		else {
+ 			instance->instancet->disable_intr(instance);
+ 			msleep(1000);
+ 			megasas_complete_cmd_dpc_fusion
+ 					((unsigned long)instance);
+ 			instance->instancet->enable_intr(instance);
+ 			if (scsi_lookup->scmd == NULL)
+ 				break;
+ 		}
+ 		rc = FAILED;
+ 		break;
+ 
+ 	case MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET:
+ 		if ((channel == 0xFFFFFFFF) && (id == 0xFFFFFFFF))
+ 			break;
+ 		instance->instancet->disable_intr(instance);
+ 		msleep(1000);
+ 		megasas_complete_cmd_dpc_fusion
+ 				((unsigned long)instance);
+ 		rc = megasas_track_scsiio(instance, id, channel);
+ 		instance->instancet->enable_intr(instance);
+ 
+ 		break;
+ 	case MPI2_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET:
+ 	case MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK:
+ 		break;
+ 	default:
+ 		rc = FAILED;
+ 		break;
+ 	}
+ 
+ 	return rc;
+ 
+ }
+ 
+ /*
+  * megasas_fusion_smid_lookup : Look for fusion command correpspodning to SCSI
+  * @instance: per adapter struct
+  *
+  * Return Non Zero index, if SMID found in outstanding commands
+  */
+ static u16 megasas_fusion_smid_lookup(struct scsi_cmnd *scmd)
+ {
+ 	int i, ret = 0;
+ 	struct megasas_instance *instance;
+ 	struct megasas_cmd_fusion *cmd_fusion;
+ 	struct fusion_context *fusion;
+ 
+ 	instance = (struct megasas_instance *)scmd->device->host->hostdata;
+ 
+ 	fusion = instance->ctrl_context;
+ 
+ 	for (i = 0; i < instance->max_scsi_cmds; i++) {
+ 		cmd_fusion = fusion->cmd_list[i];
+ 		if (cmd_fusion->scmd && (cmd_fusion->scmd == scmd)) {
+ 			scmd_printk(KERN_NOTICE, scmd, "Abort request is for"
+ 				" SMID: %d\n", cmd_fusion->index);
+ 			ret = cmd_fusion->index;
+ 			break;
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ /*
+ * megasas_get_tm_devhandle - Get devhandle for TM request
+ * @sdev-		     OS provided scsi device
+ *
+ * Returns-		     devhandle/targetID of SCSI device
+ */
+ static u16 megasas_get_tm_devhandle(struct scsi_device *sdev)
+ {
+ 	u16 pd_index = 0;
+ 	u32 device_id;
+ 	struct megasas_instance *instance;
+ 	struct fusion_context *fusion;
+ 	struct MR_PD_CFG_SEQ_NUM_SYNC *pd_sync;
+ 	u16 devhandle = (u16)ULONG_MAX;
+ 
+ 	instance = (struct megasas_instance *)sdev->host->hostdata;
+ 	fusion = instance->ctrl_context;
+ 
+ 	if (sdev->channel < MEGASAS_MAX_PD_CHANNELS) {
+ 		if (instance->use_seqnum_jbod_fp) {
+ 				pd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +
+ 						sdev->id;
+ 				pd_sync = (void *)fusion->pd_seq_sync
+ 						[(instance->pd_seq_map_id - 1) & 1];
+ 				devhandle = pd_sync->seq[pd_index].devHandle;
+ 		} else
+ 			sdev_printk(KERN_ERR, sdev, "Firmware expose tmCapable"
+ 				" without JBOD MAP support from %s %d\n", __func__, __LINE__);
+ 	} else {
+ 		device_id = ((sdev->channel % 2) * MEGASAS_MAX_DEV_PER_CHANNEL)
+ 				+ sdev->id;
+ 		devhandle = device_id;
+ 	}
+ 
+ 	return devhandle;
+ }
+ 
+ /*
+  * megasas_task_abort_fusion : SCSI task abort function for fusion adapters
+  * @scmd : pointer to scsi command object
+  *
+  * Return SUCCESS, if command aborted else FAILED
+  */
+ 
+ int megasas_task_abort_fusion(struct scsi_cmnd *scmd)
+ {
+ 	struct megasas_instance *instance;
+ 	u16 smid, devhandle;
+ 	struct fusion_context *fusion;
+ 	int ret;
+ 	struct MR_PRIV_DEVICE *mr_device_priv_data;
+ 	mr_device_priv_data = scmd->device->hostdata;
+ 
+ 
+ 	instance = (struct megasas_instance *)scmd->device->host->hostdata;
+ 	fusion = instance->ctrl_context;
+ 
+ 	if (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {
+ 		dev_err(&instance->pdev->dev, "Controller is not OPERATIONAL,"
+ 		"SCSI host:%d\n", instance->host->host_no);
+ 		ret = FAILED;
+ 		return ret;
+ 	}
+ 
+ 	if (!mr_device_priv_data) {
+ 		sdev_printk(KERN_INFO, scmd->device, "device been deleted! "
+ 			"scmd(%p)\n", scmd);
+ 		scmd->result = DID_NO_CONNECT << 16;
+ 		ret = SUCCESS;
+ 		goto out;
+ 	}
+ 
+ 
+ 	if (!mr_device_priv_data->is_tm_capable) {
+ 		ret = FAILED;
+ 		goto out;
+ 	}
+ 
+ 	mutex_lock(&instance->reset_mutex);
+ 
+ 	smid = megasas_fusion_smid_lookup(scmd);
+ 
+ 	if (!smid) {
+ 		ret = SUCCESS;
+ 		scmd_printk(KERN_NOTICE, scmd, "Command for which abort is"
+ 			" issued is not found in oustanding commands\n");
+ 		mutex_unlock(&instance->reset_mutex);
+ 		goto out;
+ 	}
+ 
+ 	devhandle = megasas_get_tm_devhandle(scmd->device);
+ 
+ 	if (devhandle == (u16)ULONG_MAX) {
+ 		ret = SUCCESS;
+ 		sdev_printk(KERN_INFO, scmd->device,
+ 			"task abort issued for invalid devhandle\n");
+ 		mutex_unlock(&instance->reset_mutex);
+ 		goto out;
+ 	}
+ 	sdev_printk(KERN_INFO, scmd->device,
+ 		"attempting task abort! scmd(%p) tm_dev_handle 0x%x\n",
+ 		scmd, devhandle);
+ 
+ 	mr_device_priv_data->tm_busy = 1;
+ 	ret = megasas_issue_tm(instance, devhandle,
+ 			scmd->device->channel, scmd->device->id, smid,
+ 			MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK);
+ 	mr_device_priv_data->tm_busy = 0;
+ 
+ 	mutex_unlock(&instance->reset_mutex);
+ out:
+ 	sdev_printk(KERN_INFO, scmd->device, "task abort: %s scmd(%p)\n",
+ 			((ret == SUCCESS) ? "SUCCESS" : "FAILED"), scmd);
+ 
+ 	return ret;
+ }
+ 
+ /*
+  * megasas_reset_target_fusion : target reset function for fusion adapters
+  * scmd: SCSI command pointer
+  *
+  * Returns SUCCESS if all commands associated with target aborted else FAILED
+  */
+ 
+ int megasas_reset_target_fusion(struct scsi_cmnd *scmd)
+ {
+ 
+ 	struct megasas_instance *instance;
+ 	int ret = FAILED;
+ 	u16 devhandle;
+ 	struct fusion_context *fusion;
+ 	struct MR_PRIV_DEVICE *mr_device_priv_data;
+ 	mr_device_priv_data = scmd->device->hostdata;
+ 
+ 	instance = (struct megasas_instance *)scmd->device->host->hostdata;
+ 	fusion = instance->ctrl_context;
+ 
+ 	if (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {
+ 		dev_err(&instance->pdev->dev, "Controller is not OPERATIONAL,"
+ 		"SCSI host:%d\n", instance->host->host_no);
+ 		ret = FAILED;
+ 		return ret;
+ 	}
+ 
+ 	if (!mr_device_priv_data) {
+ 		sdev_printk(KERN_INFO, scmd->device, "device been deleted! "
+ 			"scmd(%p)\n", scmd);
+ 		scmd->result = DID_NO_CONNECT << 16;
+ 		ret = SUCCESS;
+ 		goto out;
+ 	}
+ 
+ 
+ 	if (!mr_device_priv_data->is_tm_capable) {
+ 		ret = FAILED;
+ 		goto out;
+ 	}
+ 
+ 	mutex_lock(&instance->reset_mutex);
+ 	devhandle = megasas_get_tm_devhandle(scmd->device);
+ 
+ 	if (devhandle == (u16)ULONG_MAX) {
+ 		ret = SUCCESS;
+ 		sdev_printk(KERN_INFO, scmd->device,
+ 			"target reset issued for invalid devhandle\n");
+ 		mutex_unlock(&instance->reset_mutex);
+ 		goto out;
+ 	}
+ 
+ 	sdev_printk(KERN_INFO, scmd->device,
+ 		"attempting target reset! scmd(%p) tm_dev_handle 0x%x\n",
+ 		scmd, devhandle);
+ 	mr_device_priv_data->tm_busy = 1;
+ 	ret = megasas_issue_tm(instance, devhandle,
+ 			scmd->device->channel, scmd->device->id, 0,
+ 			MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET);
+ 	mr_device_priv_data->tm_busy = 0;
+ 	mutex_unlock(&instance->reset_mutex);
+ out:
+ 	scmd_printk(KERN_NOTICE, scmd, "megasas: target reset %s!!\n",
+ 		(ret == SUCCESS) ? "SUCCESS" : "FAILED");
+ 
+ 	return ret;
+ }
+ 
+ /*SRIOV get other instance in cluster if any*/
+ struct megasas_instance *megasas_get_peer_instance(struct megasas_instance *instance)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < MAX_MGMT_ADAPTERS; i++) {
+ 		if (megasas_mgmt_info.instance[i] &&
+ 			(megasas_mgmt_info.instance[i] != instance) &&
+ 			 megasas_mgmt_info.instance[i]->requestorId &&
+ 			 megasas_mgmt_info.instance[i]->peerIsPresent &&
+ 			(memcmp((megasas_mgmt_info.instance[i]->clusterId),
+ 			instance->clusterId, MEGASAS_CLUSTER_ID_SIZE) == 0))
+ 			return megasas_mgmt_info.instance[i];
+ 	}
+ 	return NULL;
+ }
+ 
++>>>>>>> 8f67c8c518f3 (megaraid_sas: Fix for IO failing post OCR in SRIOV environment)
  /* Check for a second path that is currently UP */
  int megasas_check_mpio_paths(struct megasas_instance *instance,
  	struct scsi_cmnd *scmd)
diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h
index d4c399b43165..6ca4c7df6f15 100644
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@ -390,6 +390,7 @@ enum MR_EVT_ARGS {
 
 
 #define SGE_BUFFER_SIZE	4096
+#define MEGASAS_CLUSTER_ID_SIZE	16
 /*
  * define constants for device list query options
  */
@@ -972,7 +973,8 @@ struct megasas_ctrl_info {
 	*/
 	struct {
 #if defined(__BIG_ENDIAN_BITFIELD)
-		u32     reserved:26;
+		u32     reserved:25;
+		u32     passive:1;
 		u32     premiumFeatureMismatch:1;
 		u32     ctrlPropIncompatible:1;
 		u32     fwVersionMismatch:1;
@@ -986,11 +988,12 @@ struct megasas_ctrl_info {
 		u32     fwVersionMismatch:1;
 		u32     ctrlPropIncompatible:1;
 		u32     premiumFeatureMismatch:1;
-		u32     reserved:26;
+		u32     passive:1;
+		u32     reserved:25;
 #endif
 	} cluster;
 
-	char clusterId[16];                     /*7D4h */
+	char clusterId[MEGASAS_CLUSTER_ID_SIZE]; /*0x7D4 */
 	struct {
 		u8  maxVFsSupported;            /*0x7E4*/
 		u8  numVFsEnabled;              /*0x7E5*/
@@ -1821,7 +1824,9 @@ struct megasas_instance {
 	char skip_heartbeat_timer_del;
 	u8 requestorId;
 	char PlasmaFW111;
-	char mpio;
+	char clusterId[MEGASAS_CLUSTER_ID_SIZE];
+	u8 peerIsPresent;
+	u8 passive;
 	u16 throttlequeuedepth;
 	u8 mask_interrupts;
 	u16 max_chain_frame_sz;
diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c
index d2f05cd0bdf3..8512bd04334e 100644
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@ -1837,7 +1837,7 @@ void megaraid_sas_kill_hba(struct megasas_instance *instance)
 			&instance->reg_set->doorbell);
 		/* Flush */
 		readl(&instance->reg_set->doorbell);
-		if (instance->mpio && instance->requestorId)
+		if (instance->requestorId && instance->peerIsPresent)
 			memset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);
 	} else {
 		writel(MFI_STOP_ADP,
@@ -4901,7 +4901,9 @@ static int megasas_init_fw(struct megasas_instance *instance)
 
 	tmp_sectors = min_t(u32, max_sectors_1 , max_sectors_2);
 
-	instance->mpio = ctrl_info->adapterOperations2.mpio;
+	instance->peerIsPresent = ctrl_info->cluster.peerIsPresent;
+	instance->passive = ctrl_info->cluster.passive;
+	memcpy(instance->clusterId, ctrl_info->clusterId, sizeof(instance->clusterId));
 	instance->UnevenSpanSupport =
 		ctrl_info->adapterOperations2.supportUnevenSpans;
 	if (instance->UnevenSpanSupport) {
* Unmerged path drivers/scsi/megaraid/megaraid_sas_fusion.c
