perf tools: Finalize subcmd independence

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Josh Poimboeuf <jpoimboe@redhat.com>
commit 2f4ce5ec1d447beb42143a9653716a2ab025161e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2f4ce5ec.failed

For the files that will be moved to the subcmd library, remove all their
perf-specific includes and duplicate any needed functionality.

	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/6e12946f0f26ce4d543d34db68d9dae3c8551cb9.1450193761.git.jpoimboe@redhat.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 2f4ce5ec1d447beb42143a9653716a2ab025161e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/exec_cmd.c
#	tools/perf/util/help.c
#	tools/perf/util/parse-options.c
#	tools/perf/util/subcmd-util.h
diff --cc tools/perf/util/exec_cmd.c
index b935e4ce62a2,e7f9ed7943e3..000000000000
--- a/tools/perf/util/exec_cmd.c
+++ b/tools/perf/util/exec_cmd.c
@@@ -1,11 -1,17 +1,22 @@@
- #include "cache.h"
+ #include <linux/compiler.h>
+ #include <linux/string.h>
+ #include <sys/types.h>
+ #include <sys/stat.h>
+ #include <unistd.h>
+ #include <string.h>
+ #include <stdlib.h>
+ #include <stdio.h>
+ #include "subcmd-util.h"
  #include "exec_cmd.h"
- #include "quote.h"
  #include "subcmd-config.h"
  
++<<<<<<< HEAD
 +#include <string.h>
 +
++=======
++>>>>>>> 2f4ce5ec1d44 (perf tools: Finalize subcmd independence)
  #define MAX_ARGS	32
+ #define PATH_MAX	4096
  
  static const char *argv_exec_path;
  static const char *argv0_path;
@@@ -19,9 -25,52 +30,52 @@@ void exec_cmd_init(const char *exec_nam
  	subcmd_config.exec_path_env	= exec_path_env;
  }
  
+ #define is_dir_sep(c) ((c) == '/')
+ 
+ static int is_absolute_path(const char *path)
+ {
+ 	return path[0] == '/';
+ }
+ 
+ static const char *get_pwd_cwd(void)
+ {
+ 	static char cwd[PATH_MAX + 1];
+ 	char *pwd;
+ 	struct stat cwd_stat, pwd_stat;
+ 	if (getcwd(cwd, PATH_MAX) == NULL)
+ 		return NULL;
+ 	pwd = getenv("PWD");
+ 	if (pwd && strcmp(pwd, cwd)) {
+ 		stat(cwd, &cwd_stat);
+ 		if (!stat(pwd, &pwd_stat) &&
+ 		    pwd_stat.st_dev == cwd_stat.st_dev &&
+ 		    pwd_stat.st_ino == cwd_stat.st_ino) {
+ 			strlcpy(cwd, pwd, PATH_MAX);
+ 		}
+ 	}
+ 	return cwd;
+ }
+ 
+ static const char *make_nonrelative_path(const char *path)
+ {
+ 	static char buf[PATH_MAX + 1];
+ 
+ 	if (is_absolute_path(path)) {
+ 		if (strlcpy(buf, path, PATH_MAX) >= PATH_MAX)
+ 			die("Too long path: %.*s", 60, path);
+ 	} else {
+ 		const char *cwd = get_pwd_cwd();
+ 		if (!cwd)
+ 			die("Cannot determine the current working directory");
+ 		if (snprintf(buf, PATH_MAX, "%s/%s", cwd, path) >= PATH_MAX)
+ 			die("Too long path: %.*s", 60, path);
+ 	}
+ 	return buf;
+ }
+ 
  char *system_path(const char *path)
  {
 -	char *buf = NULL;
 +	struct strbuf d = STRBUF_INIT;
  
  	if (is_absolute_path(path))
  		return strdup(path);
@@@ -150,9 -199,11 +204,11 @@@ int execl_perf_cmd(const char *cmd,...
  			break;
  	}
  	va_end(param);
- 	if (MAX_ARGS <= argc)
- 		return error("too many args to run %s", cmd);
+ 	if (MAX_ARGS <= argc) {
+ 		fprintf(stderr, " Error: too many args to run %s\n", cmd);
+ 		return -1;
+ 	}
  
  	argv[argc] = NULL;
 -	return execv_cmd(argv);
 +	return execv_perf_cmd(argv);
  }
diff --cc tools/perf/util/help.c
index 8d74f7d05674,8169480066c6..000000000000
--- a/tools/perf/util/help.c
+++ b/tools/perf/util/help.c
@@@ -1,7 -1,15 +1,22 @@@
++<<<<<<< HEAD
 +#include "cache.h"
 +#include "../builtin.h"
 +#include "exec_cmd.h"
 +#include "help.h"
++=======
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
+ #include <termios.h>
+ #include <sys/ioctl.h>
+ #include <sys/types.h>
+ #include <sys/stat.h>
+ #include <unistd.h>
+ #include <dirent.h>
+ #include "subcmd-util.h"
+ #include "help.h"
+ #include "exec_cmd.h"
++>>>>>>> 2f4ce5ec1d44 (perf tools: Finalize subcmd independence)
  
  void add_cmdname(struct cmdnames *cmds, const char *name, size_t len)
  {
diff --cc tools/perf/util/parse-options.c
index 19b422d0d57f,981bb4481fd5..000000000000
--- a/tools/perf/util/parse-options.c
+++ b/tools/perf/util/parse-options.c
@@@ -1,9 -1,14 +1,18 @@@
++<<<<<<< HEAD
 +#include "util.h"
++=======
+ #include <linux/compiler.h>
+ #include <linux/types.h>
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <stdint.h>
+ #include <string.h>
+ #include <ctype.h>
+ #include "subcmd-util.h"
++>>>>>>> 2f4ce5ec1d44 (perf tools: Finalize subcmd independence)
  #include "parse-options.h"
- #include "cache.h"
- #include "header.h"
  #include "subcmd-config.h"
- #include <linux/string.h>
+ #include "pager.h"
  
  #define OPT_SHORT 1
  #define OPT_UNSET 2
@@@ -13,12 -18,31 +22,34 @@@ static struct strbuf error_buf = STRBUF
  static int opterror(const struct option *opt, const char *reason, int flags)
  {
  	if (flags & OPT_SHORT)
- 		return error("switch `%c' %s", opt->short_name, reason);
- 	if (flags & OPT_UNSET)
- 		return error("option `no-%s' %s", opt->long_name, reason);
- 	return error("option `%s' %s", opt->long_name, reason);
+ 		fprintf(stderr, " Error: switch `%c' %s", opt->short_name, reason);
+ 	else if (flags & OPT_UNSET)
+ 		fprintf(stderr, " Error: option `no-%s' %s", opt->long_name, reason);
+ 	else
+ 		fprintf(stderr, " Error: option `%s' %s", opt->long_name, reason);
+ 
+ 	return -1;
+ }
+ 
+ static const char *skip_prefix(const char *str, const char *prefix)
+ {
+ 	size_t len = strlen(prefix);
+ 	return strncmp(str, prefix, len) ? NULL : str + len;
  }
  
++<<<<<<< HEAD
++=======
+ static void optwarning(const struct option *opt, const char *reason, int flags)
+ {
+ 	if (flags & OPT_SHORT)
+ 		fprintf(stderr, " Warning: switch `%c' %s", opt->short_name, reason);
+ 	else if (flags & OPT_UNSET)
+ 		fprintf(stderr, " Warning: option `no-%s' %s", opt->long_name, reason);
+ 	else
+ 		fprintf(stderr, " Warning: option `%s' %s", opt->long_name, reason);
+ }
+ 
++>>>>>>> 2f4ce5ec1d44 (perf tools: Finalize subcmd independence)
  static int get_arg(struct parse_opt_ctx_t *p, const struct option *opt,
  		   int flags, const char **arg)
  {
* Unmerged path tools/perf/util/subcmd-util.h
* Unmerged path tools/perf/util/exec_cmd.c
* Unmerged path tools/perf/util/help.c
diff --git a/tools/perf/util/help.h b/tools/perf/util/help.h
index 14851b0e44f5..096c8bc45cd7 100644
--- a/tools/perf/util/help.h
+++ b/tools/perf/util/help.h
@@ -1,12 +1,14 @@
 #ifndef __PERF_HELP_H
 #define __PERF_HELP_H
 
+#include <sys/types.h>
+
 struct cmdnames {
 	size_t alloc;
 	size_t cnt;
 	struct cmdname {
 		size_t len; /* also used for similarity index in help.c */
-		char name[FLEX_ARRAY];
+		char name[];
 	} **names;
 };
 
diff --git a/tools/perf/util/pager.c b/tools/perf/util/pager.c
index d5ef62eaa413..d50f3b58606b 100644
--- a/tools/perf/util/pager.c
+++ b/tools/perf/util/pager.c
@@ -1,4 +1,9 @@
-#include "cache.h"
+#include <sys/select.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <signal.h>
+#include "pager.h"
 #include "run-command.h"
 #include "sigchain.h"
 #include "subcmd-config.h"
* Unmerged path tools/perf/util/parse-options.c
diff --git a/tools/perf/util/parse-options.h b/tools/perf/util/parse-options.h
index e967f11034f3..d13036ca7553 100644
--- a/tools/perf/util/parse-options.h
+++ b/tools/perf/util/parse-options.h
@@ -1,8 +1,8 @@
 #ifndef __PERF_PARSE_OPTIONS_H
 #define __PERF_PARSE_OPTIONS_H
 
-#include <linux/kernel.h>
 #include <stdbool.h>
+#include <stdint.h>
 
 enum parse_opt_type {
 	/* special types */
diff --git a/tools/perf/util/run-command.c b/tools/perf/util/run-command.c
index 34622b53e733..0c51fec80745 100644
--- a/tools/perf/util/run-command.c
+++ b/tools/perf/util/run-command.c
@@ -1,7 +1,15 @@
-#include "cache.h"
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/wait.h>
+#include "subcmd-util.h"
 #include "run-command.h"
 #include "exec_cmd.h"
-#include "debug.h"
+
+#define STRERR_BUFSIZE 128
 
 static inline void close_pair(int fd[2])
 {
@@ -164,8 +172,8 @@ static int wait_or_whine(pid_t pid)
 		if (waiting < 0) {
 			if (errno == EINTR)
 				continue;
-			error("waitpid failed (%s)",
-			      strerror_r(errno, sbuf, sizeof(sbuf)));
+			fprintf(stderr, " Error: waitpid failed (%s)",
+				strerror_r(errno, sbuf, sizeof(sbuf)));
 			return -ERR_RUN_COMMAND_WAITPID;
 		}
 		if (waiting != pid)
diff --git a/tools/perf/util/run-command.h b/tools/perf/util/run-command.h
index 1ef264d5069c..a216cc63a54f 100644
--- a/tools/perf/util/run-command.h
+++ b/tools/perf/util/run-command.h
@@ -1,6 +1,8 @@
 #ifndef __PERF_RUN_COMMAND_H
 #define __PERF_RUN_COMMAND_H
 
+#include <unistd.h>
+
 enum {
 	ERR_RUN_COMMAND_FORK = 10000,
 	ERR_RUN_COMMAND_EXEC,
diff --git a/tools/perf/util/sigchain.c b/tools/perf/util/sigchain.c
index ba785e9b1841..3537c348a18e 100644
--- a/tools/perf/util/sigchain.c
+++ b/tools/perf/util/sigchain.c
@@ -1,5 +1,6 @@
+#include <signal.h>
+#include "subcmd-util.h"
 #include "sigchain.h"
-#include "cache.h"
 
 #define SIGCHAIN_MAX_SIGNALS 32
 
* Unmerged path tools/perf/util/subcmd-util.h
diff --git a/tools/perf/util/util.h b/tools/perf/util/util.h
index 4e5c6ce20b5a..a9b6ca143216 100644
--- a/tools/perf/util/util.h
+++ b/tools/perf/util/util.h
@@ -151,12 +151,6 @@ extern void set_warning_routine(void (*routine)(const char *err, va_list params)
 extern int prefixcmp(const char *str, const char *prefix);
 extern void set_buildid_dir(const char *dir);
 
-static inline const char *skip_prefix(const char *str, const char *prefix)
-{
-	size_t len = strlen(prefix);
-	return strncmp(str, prefix, len) ? NULL : str + len;
-}
-
 #ifdef __GLIBC_PREREQ
 #if __GLIBC_PREREQ(2, 1)
 #define HAVE_STRCHRNUL
@@ -187,14 +181,6 @@ static inline void *zalloc(size_t size)
 
 #define zfree(ptr) ({ free(*ptr); *ptr = NULL; })
 
-static inline int has_extension(const char *filename, const char *ext)
-{
-	size_t len = strlen(filename);
-	size_t extlen = strlen(ext);
-
-	return len > extlen && !memcmp(filename + len - extlen, ext, extlen);
-}
-
 /* Sane ctype - no locale, and works with signed chars */
 #undef isascii
 #undef isspace
