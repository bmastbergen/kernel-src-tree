xfs: eliminate committed arg from xfs_bmap_finish

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Eric Sandeen <sandeen@sandeen.net>
commit f6106efae5f4144b32f6c10de0dc3e7efc9181e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f6106efa.failed

Calls to xfs_bmap_finish() and xfs_trans_ijoin(), and the
associated comments were replicated several times across
the attribute code, all dealing with what to do if the
transaction was or wasn't committed.

And in that replicated code, an ASSERT() test of an
uninitialized variable occurs in several locations:

	error = xfs_attr_thing(&args);
	if (!error) {
		error = xfs_bmap_finish(&args.trans, args.flist,
					&committed);
	}
	if (error) {
		ASSERT(committed);

If the first xfs_attr_thing() failed, we'd skip the xfs_bmap_finish,
never set "committed", and then test it in the ASSERT.

Fix this up by moving the committed state internal to xfs_bmap_finish,
and add a new inode argument.  If an inode is passed in, it is passed
through to __xfs_trans_roll() and joined to the transaction there if
the transaction was committed.

xfs_qm_dqalloc() was a little unique in that it called bjoin rather
than ijoin, but as Dave points out we can detect the committed state
but checking whether (*tpp != tp).

Addresses-Coverity-Id: 102360
Addresses-Coverity-Id: 102361
Addresses-Coverity-Id: 102363
Addresses-Coverity-Id: 102364
	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dave Chinner <david@fromorbit.com>
(cherry picked from commit f6106efae5f4144b32f6c10de0dc3e7efc9181e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/xfs_bmap_util.c
#	fs/xfs/xfs_inode.c
#	fs/xfs/xfs_rtalloc.c
#	fs/xfs/xfs_symlink.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index becfa61a17d9,ef00156f4f96..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -1117,10 -1117,8 +1117,9 @@@ xfs_bmap_add_attrfork
  	xfs_trans_t		*tp;		/* transaction pointer */
  	int			blks;		/* space reservation */
  	int			version = 1;	/* superblock attr version */
- 	int			committed;	/* xaction was committed */
  	int			logflags;	/* logging flags */
  	int			error;		/* error return value */
 +	int			cancel_flags = 0;
  
  	ASSERT(XFS_IFORK_Q(ip) == 0);
  
@@@ -1223,10 -1219,10 +1222,10 @@@
  			xfs_log_sb(tp);
  	}
  
- 	error = xfs_bmap_finish(&tp, &flist, &committed);
+ 	error = xfs_bmap_finish(&tp, &flist, NULL);
  	if (error)
  		goto bmap_cancel;
 -	error = xfs_trans_commit(tp);
 +	error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
  	xfs_iunlock(ip, XFS_ILOCK_EXCL);
  	return error;
  
@@@ -5687,3 -5802,188 +5686,191 @@@ del_cursor
  
  	return error;
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Splits an extent into two extents at split_fsb block such that it is
+  * the first block of the current_ext. @current_ext is a target extent
+  * to be split. @split_fsb is a block where the extents is split.
+  * If split_fsb lies in a hole or the first block of extents, just return 0.
+  */
+ STATIC int
+ xfs_bmap_split_extent_at(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	xfs_fileoff_t		split_fsb,
+ 	xfs_fsblock_t		*firstfsb,
+ 	struct xfs_bmap_free	*free_list)
+ {
+ 	int				whichfork = XFS_DATA_FORK;
+ 	struct xfs_btree_cur		*cur = NULL;
+ 	struct xfs_bmbt_rec_host	*gotp;
+ 	struct xfs_bmbt_irec		got;
+ 	struct xfs_bmbt_irec		new; /* split extent */
+ 	struct xfs_mount		*mp = ip->i_mount;
+ 	struct xfs_ifork		*ifp;
+ 	xfs_fsblock_t			gotblkcnt; /* new block count for got */
+ 	xfs_extnum_t			current_ext;
+ 	int				error = 0;
+ 	int				logflags = 0;
+ 	int				i = 0;
+ 
+ 	if (unlikely(XFS_TEST_ERROR(
+ 	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
+ 	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
+ 	     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {
+ 		XFS_ERROR_REPORT("xfs_bmap_split_extent_at",
+ 				 XFS_ERRLEVEL_LOW, mp);
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
+ 
+ 	ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	if (!(ifp->if_flags & XFS_IFEXTENTS)) {
+ 		/* Read in all the extents */
+ 		error = xfs_iread_extents(tp, ip, whichfork);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	/*
+ 	 * gotp can be null in 2 cases: 1) if there are no extents
+ 	 * or 2) split_fsb lies in a hole beyond which there are
+ 	 * no extents. Either way, we are done.
+ 	 */
+ 	gotp = xfs_iext_bno_to_ext(ifp, split_fsb, &current_ext);
+ 	if (!gotp)
+ 		return 0;
+ 
+ 	xfs_bmbt_get_all(gotp, &got);
+ 
+ 	/*
+ 	 * Check split_fsb lies in a hole or the start boundary offset
+ 	 * of the extent.
+ 	 */
+ 	if (got.br_startoff >= split_fsb)
+ 		return 0;
+ 
+ 	gotblkcnt = split_fsb - got.br_startoff;
+ 	new.br_startoff = split_fsb;
+ 	new.br_startblock = got.br_startblock + gotblkcnt;
+ 	new.br_blockcount = got.br_blockcount - gotblkcnt;
+ 	new.br_state = got.br_state;
+ 
+ 	if (ifp->if_flags & XFS_IFBROOT) {
+ 		cur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);
+ 		cur->bc_private.b.firstblock = *firstfsb;
+ 		cur->bc_private.b.flist = free_list;
+ 		cur->bc_private.b.flags = 0;
+ 		error = xfs_bmbt_lookup_eq(cur, got.br_startoff,
+ 				got.br_startblock,
+ 				got.br_blockcount,
+ 				&i);
+ 		if (error)
+ 			goto del_cursor;
+ 		XFS_WANT_CORRUPTED_GOTO(mp, i == 1, del_cursor);
+ 	}
+ 
+ 	xfs_bmbt_set_blockcount(gotp, gotblkcnt);
+ 	got.br_blockcount = gotblkcnt;
+ 
+ 	logflags = XFS_ILOG_CORE;
+ 	if (cur) {
+ 		error = xfs_bmbt_update(cur, got.br_startoff,
+ 				got.br_startblock,
+ 				got.br_blockcount,
+ 				got.br_state);
+ 		if (error)
+ 			goto del_cursor;
+ 	} else
+ 		logflags |= XFS_ILOG_DEXT;
+ 
+ 	/* Add new extent */
+ 	current_ext++;
+ 	xfs_iext_insert(ip, current_ext, 1, &new, 0);
+ 	XFS_IFORK_NEXT_SET(ip, whichfork,
+ 			   XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
+ 
+ 	if (cur) {
+ 		error = xfs_bmbt_lookup_eq(cur, new.br_startoff,
+ 				new.br_startblock, new.br_blockcount,
+ 				&i);
+ 		if (error)
+ 			goto del_cursor;
+ 		XFS_WANT_CORRUPTED_GOTO(mp, i == 0, del_cursor);
+ 		cur->bc_rec.b.br_state = new.br_state;
+ 
+ 		error = xfs_btree_insert(cur, &i);
+ 		if (error)
+ 			goto del_cursor;
+ 		XFS_WANT_CORRUPTED_GOTO(mp, i == 1, del_cursor);
+ 	}
+ 
+ 	/*
+ 	 * Convert to a btree if necessary.
+ 	 */
+ 	if (xfs_bmap_needs_btree(ip, whichfork)) {
+ 		int tmp_logflags; /* partial log flag return val */
+ 
+ 		ASSERT(cur == NULL);
+ 		error = xfs_bmap_extents_to_btree(tp, ip, firstfsb, free_list,
+ 				&cur, 0, &tmp_logflags, whichfork);
+ 		logflags |= tmp_logflags;
+ 	}
+ 
+ del_cursor:
+ 	if (cur) {
+ 		cur->bc_private.b.allocated = 0;
+ 		xfs_btree_del_cursor(cur,
+ 				error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);
+ 	}
+ 
+ 	if (logflags)
+ 		xfs_trans_log_inode(tp, ip, logflags);
+ 	return error;
+ }
+ 
+ int
+ xfs_bmap_split_extent(
+ 	struct xfs_inode        *ip,
+ 	xfs_fileoff_t           split_fsb)
+ {
+ 	struct xfs_mount        *mp = ip->i_mount;
+ 	struct xfs_trans        *tp;
+ 	struct xfs_bmap_free    free_list;
+ 	xfs_fsblock_t           firstfsb;
+ 	int                     error;
+ 
+ 	tp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);
+ 	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,
+ 			XFS_DIOSTRAT_SPACE_RES(mp, 0), 0);
+ 	if (error) {
+ 		xfs_trans_cancel(tp);
+ 		return error;
+ 	}
+ 
+ 	xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
+ 
+ 	xfs_bmap_init(&free_list, &firstfsb);
+ 
+ 	error = xfs_bmap_split_extent_at(tp, ip, split_fsb,
+ 			&firstfsb, &free_list);
+ 	if (error)
+ 		goto out;
+ 
+ 	error = xfs_bmap_finish(&tp, &free_list, NULL);
+ 	if (error)
+ 		goto out;
+ 
+ 	return xfs_trans_commit(tp);
+ 
+ out:
+ 	xfs_bmap_cancel(&free_list);
+ 	xfs_trans_cancel(tp);
+ 	return error;
+ }
++>>>>>>> f6106efae5f4 (xfs: eliminate committed arg from xfs_bmap_finish)
diff --cc fs/xfs/xfs_bmap_util.c
index 95008128b091,45ec9e40150c..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -1045,16 -1066,14 +1040,14 @@@ xfs_alloc_file_space
  		/*
  		 * Complete the transaction
  		 */
- 		error = xfs_bmap_finish(&tp, &free_list, &committed);
- 		if (error) {
+ 		error = xfs_bmap_finish(&tp, &free_list, NULL);
+ 		if (error)
  			goto error0;
- 		}
  
 -		error = xfs_trans_commit(tp);
 +		error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
  		xfs_iunlock(ip, XFS_ILOCK_EXCL);
- 		if (error) {
+ 		if (error)
  			break;
- 		}
  
  		allocated_fsb = imapp->br_blockcount;
  
@@@ -1328,12 -1344,11 +1319,11 @@@ xfs_free_file_space
  		/*
  		 * complete the transaction
  		 */
- 		error = xfs_bmap_finish(&tp, &free_list, &committed);
- 		if (error) {
+ 		error = xfs_bmap_finish(&tp, &free_list, NULL);
+ 		if (error)
  			goto error0;
- 		}
  
 -		error = xfs_trans_commit(tp);
 +		error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
  		xfs_iunlock(ip, XFS_ILOCK_EXCL);
  	}
  
@@@ -1389,6 -1404,134 +1379,137 @@@ out
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * @next_fsb will keep track of the extent currently undergoing shift.
+  * @stop_fsb will keep track of the extent at which we have to stop.
+  * If we are shifting left, we will start with block (offset + len) and
+  * shift each extent till last extent.
+  * If we are shifting right, we will start with last extent inside file space
+  * and continue until we reach the block corresponding to offset.
+  */
+ static int
+ xfs_shift_file_space(
+ 	struct xfs_inode        *ip,
+ 	xfs_off_t               offset,
+ 	xfs_off_t               len,
+ 	enum shift_direction	direction)
+ {
+ 	int			done = 0;
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_trans	*tp;
+ 	int			error;
+ 	struct xfs_bmap_free	free_list;
+ 	xfs_fsblock_t		first_block;
+ 	xfs_fileoff_t		stop_fsb;
+ 	xfs_fileoff_t		next_fsb;
+ 	xfs_fileoff_t		shift_fsb;
+ 
+ 	ASSERT(direction == SHIFT_LEFT || direction == SHIFT_RIGHT);
+ 
+ 	if (direction == SHIFT_LEFT) {
+ 		next_fsb = XFS_B_TO_FSB(mp, offset + len);
+ 		stop_fsb = XFS_B_TO_FSB(mp, VFS_I(ip)->i_size);
+ 	} else {
+ 		/*
+ 		 * If right shift, delegate the work of initialization of
+ 		 * next_fsb to xfs_bmap_shift_extent as it has ilock held.
+ 		 */
+ 		next_fsb = NULLFSBLOCK;
+ 		stop_fsb = XFS_B_TO_FSB(mp, offset);
+ 	}
+ 
+ 	shift_fsb = XFS_B_TO_FSB(mp, len);
+ 
+ 	/*
+ 	 * Trim eofblocks to avoid shifting uninitialized post-eof preallocation
+ 	 * into the accessible region of the file.
+ 	 */
+ 	if (xfs_can_free_eofblocks(ip, true)) {
+ 		error = xfs_free_eofblocks(mp, ip, false);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	/*
+ 	 * Writeback and invalidate cache for the remainder of the file as we're
+ 	 * about to shift down every extent from offset to EOF.
+ 	 */
+ 	error = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,
+ 					     offset, -1);
+ 	if (error)
+ 		return error;
+ 	error = invalidate_inode_pages2_range(VFS_I(ip)->i_mapping,
+ 					offset >> PAGE_CACHE_SHIFT, -1);
+ 	if (error)
+ 		return error;
+ 
+ 	/*
+ 	 * The extent shiting code works on extent granularity. So, if
+ 	 * stop_fsb is not the starting block of extent, we need to split
+ 	 * the extent at stop_fsb.
+ 	 */
+ 	if (direction == SHIFT_RIGHT) {
+ 		error = xfs_bmap_split_extent(ip, stop_fsb);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	while (!error && !done) {
+ 		tp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);
+ 		/*
+ 		 * We would need to reserve permanent block for transaction.
+ 		 * This will come into picture when after shifting extent into
+ 		 * hole we found that adjacent extents can be merged which
+ 		 * may lead to freeing of a block during record update.
+ 		 */
+ 		error = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,
+ 				XFS_DIOSTRAT_SPACE_RES(mp, 0), 0);
+ 		if (error) {
+ 			xfs_trans_cancel(tp);
+ 			break;
+ 		}
+ 
+ 		xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 		error = xfs_trans_reserve_quota(tp, mp, ip->i_udquot,
+ 				ip->i_gdquot, ip->i_pdquot,
+ 				XFS_DIOSTRAT_SPACE_RES(mp, 0), 0,
+ 				XFS_QMOPT_RES_REGBLKS);
+ 		if (error)
+ 			goto out_trans_cancel;
+ 
+ 		xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
+ 
+ 		xfs_bmap_init(&free_list, &first_block);
+ 
+ 		/*
+ 		 * We are using the write transaction in which max 2 bmbt
+ 		 * updates are allowed
+ 		 */
+ 		error = xfs_bmap_shift_extents(tp, ip, &next_fsb, shift_fsb,
+ 				&done, stop_fsb, &first_block, &free_list,
+ 				direction, XFS_BMAP_MAX_SHIFT_EXTENTS);
+ 		if (error)
+ 			goto out_bmap_cancel;
+ 
+ 		error = xfs_bmap_finish(&tp, &free_list, NULL);
+ 		if (error)
+ 			goto out_bmap_cancel;
+ 
+ 		error = xfs_trans_commit(tp);
+ 	}
+ 
+ 	return error;
+ 
+ out_bmap_cancel:
+ 	xfs_bmap_cancel(&free_list);
+ out_trans_cancel:
+ 	xfs_trans_cancel(tp);
+ 	return error;
+ }
+ 
+ /*
++>>>>>>> f6106efae5f4 (xfs: eliminate committed arg from xfs_bmap_finish)
   * xfs_collapse_file_space()
   *	This routine frees disk space and shift extent for the given file.
   *	The first thing we do is to free data blocks in the specified range
diff --cc fs/xfs/xfs_inode.c
index 3cdcf44d219d,ae3758a90ed6..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -1144,8 -1143,6 +1144,11 @@@ xfs_create
  	xfs_bmap_free_t		free_list;
  	xfs_fsblock_t		first_block;
  	bool                    unlock_dp_on_error = false;
++<<<<<<< HEAD
 +	uint			cancel_flags;
 +	int			committed;
++=======
++>>>>>>> f6106efae5f4 (xfs: eliminate committed arg from xfs_bmap_finish)
  	prid_t			prid;
  	struct xfs_dquot	*udqp = NULL;
  	struct xfs_dquot	*gdqp = NULL;
@@@ -1231,12 -1225,9 +1234,18 @@@
  	 * pointing to itself.
  	 */
  	error = xfs_dir_ialloc(&tp, dp, mode, is_dir ? 2 : 1, rdev,
++<<<<<<< HEAD
 +			       prid, resblks > 0, &ip, &committed);
 +	if (error) {
 +		if (error == -ENOSPC)
 +			goto out_trans_cancel;
 +		goto out_trans_abort;
 +	}
++=======
+ 			       prid, resblks > 0, &ip, NULL);
+ 	if (error)
+ 		goto out_trans_cancel;
++>>>>>>> f6106efae5f4 (xfs: eliminate committed arg from xfs_bmap_finish)
  
  	/*
  	 * Now we join the directory inode to the transaction.  We do not do it
@@@ -1445,8 -1426,6 +1454,11 @@@ xfs_link
  	int			error;
  	xfs_bmap_free_t         free_list;
  	xfs_fsblock_t           first_block;
++<<<<<<< HEAD
 +	int			cancel_flags;
 +	int			committed;
++=======
++>>>>>>> f6106efae5f4 (xfs: eliminate committed arg from xfs_bmap_finish)
  	int			resblks;
  
  	trace_xfs_link(tdp, target_name);
@@@ -1523,22 -1500,19 +1535,21 @@@
  	 * link transaction goes to disk before returning to
  	 * the user.
  	 */
- 	if (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {
+ 	if (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))
  		xfs_trans_set_sync(tp);
- 	}
  
- 	error = xfs_bmap_finish (&tp, &free_list, &committed);
+ 	error = xfs_bmap_finish(&tp, &free_list, NULL);
  	if (error) {
  		xfs_bmap_cancel(&free_list);
 -		goto error_return;
 +		goto abort_return;
  	}
  
 -	return xfs_trans_commit(tp);
 +	return xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
  
 + abort_return:
 +	cancel_flags |= XFS_TRANS_ABORT;
   error_return:
 -	xfs_trans_cancel(tp);
 +	xfs_trans_cancel(tp, cancel_flags);
   std_return:
  	return error;
  }
@@@ -1861,15 -1831,16 +1868,20 @@@ xfs_inactive_ifree
  	xfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_ICOUNT, -1);
  
  	/*
 -	 * Just ignore errors at this point.  There is nothing we can do except
 -	 * to try to keep going. Make sure it's not a silent error.
 +	 * Just ignore errors at this point.  There is nothing we can
 +	 * do except to try to keep going. Make sure it's not a silent
 +	 * error.
  	 */
++<<<<<<< HEAD
 +	error = xfs_bmap_finish(&tp,  &free_list, &committed);
 +	if (error)
++=======
+ 	error = xfs_bmap_finish(&tp, &free_list, NULL);
+ 	if (error) {
++>>>>>>> f6106efae5f4 (xfs: eliminate committed arg from xfs_bmap_finish)
  		xfs_notice(mp, "%s: xfs_bmap_finish returned error %d",
  			__func__, error);
 -		xfs_bmap_cancel(&free_list);
 -	}
 -	error = xfs_trans_commit(tp);
 +	error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
  	if (error)
  		xfs_notice(mp, "%s: xfs_trans_commit returned error %d",
  			__func__, error);
@@@ -2545,8 -2516,6 +2557,11 @@@ xfs_remove
  	int                     error = 0;
  	xfs_bmap_free_t         free_list;
  	xfs_fsblock_t           first_block;
++<<<<<<< HEAD
 +	int			cancel_flags;
 +	int			committed;
++=======
++>>>>>>> f6106efae5f4 (xfs: eliminate committed arg from xfs_bmap_finish)
  	uint			resblks;
  
  	trace_xfs_remove(dp, name);
@@@ -2736,10 -2702,10 +2750,10 @@@ xfs_finish_rename
  	if (tp->t_mountp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))
  		xfs_trans_set_sync(tp);
  
- 	error = xfs_bmap_finish(&tp, free_list, &committed);
+ 	error = xfs_bmap_finish(&tp, free_list, NULL);
  	if (error) {
  		xfs_bmap_cancel(free_list);
 -		xfs_trans_cancel(tp);
 +		xfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);
  		return error;
  	}
  
diff --cc fs/xfs/xfs_rtalloc.c
index f2079b6911cc,be02a68b2fe2..000000000000
--- a/fs/xfs/xfs_rtalloc.c
+++ b/fs/xfs/xfs_rtalloc.c
@@@ -757,24 -757,24 +757,38 @@@ xfs_rtallocate_extent_size
  /*
   * Allocate space to the bitmap or summary file, and zero it, for growfs.
   */
 -STATIC int
 +STATIC int				/* error */
  xfs_growfs_rt_alloc(
 -	struct xfs_mount	*mp,		/* file system mount point */
 -	xfs_extlen_t		oblocks,	/* old count of blocks */
 -	xfs_extlen_t		nblocks,	/* new count of blocks */
 -	struct xfs_inode	*ip)		/* inode (bitmap/summary) */
 +	xfs_mount_t	*mp,		/* file system mount point */
 +	xfs_extlen_t	oblocks,	/* old count of blocks */
 +	xfs_extlen_t	nblocks,	/* new count of blocks */
 +	xfs_inode_t	*ip)		/* inode (bitmap/summary) */
  {
++<<<<<<< HEAD
 +	xfs_fileoff_t	bno;		/* block number in file */
 +	xfs_buf_t	*bp;		/* temporary buffer for zeroing */
 +	int		committed;	/* transaction committed flag */
 +	xfs_daddr_t	d;		/* disk block address */
 +	int		error;		/* error return value */
 +	xfs_fsblock_t	firstblock;	/* first block allocated in xaction */
 +	xfs_bmap_free_t	flist;		/* list of freed blocks */
 +	xfs_fsblock_t	fsbno;		/* filesystem block for bno */
 +	xfs_bmbt_irec_t	map;		/* block map output */
 +	int		nmap;		/* number of block maps */
 +	int		resblks;	/* space reservation */
++=======
+ 	xfs_fileoff_t		bno;		/* block number in file */
+ 	struct xfs_buf		*bp;	/* temporary buffer for zeroing */
+ 	xfs_daddr_t		d;		/* disk block address */
+ 	int			error;		/* error return value */
+ 	xfs_fsblock_t		firstblock;/* first block allocated in xaction */
+ 	struct xfs_bmap_free	flist;		/* list of freed blocks */
+ 	xfs_fsblock_t		fsbno;		/* filesystem block for bno */
+ 	struct xfs_bmbt_irec	map;		/* block map output */
+ 	int			nmap;		/* number of block maps */
+ 	int			resblks;	/* space reservation */
+ 	struct xfs_trans	*tp;
++>>>>>>> f6106efae5f4 (xfs: eliminate committed arg from xfs_bmap_finish)
  
  	/*
  	 * Allocate space to the file, as necessary.
@@@ -815,12 -810,12 +829,12 @@@
  		/*
  		 * Free any blocks freed up in the transaction, then commit.
  		 */
- 		error = xfs_bmap_finish(&tp, &flist, &committed);
+ 		error = xfs_bmap_finish(&tp, &flist, NULL);
  		if (error)
 -			goto out_bmap_cancel;
 -		error = xfs_trans_commit(tp);
 +			goto error_cancel;
 +		error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
  		if (error)
 -			return error;
 +			goto error;
  		/*
  		 * Now we need to clear the allocated blocks.
  		 * Do this one block per transaction, to keep it simple.
diff --cc fs/xfs/xfs_symlink.c
index f45254315763,b44284c1adda..000000000000
--- a/fs/xfs/xfs_symlink.c
+++ b/fs/xfs/xfs_symlink.c
@@@ -178,8 -178,6 +178,11 @@@ xfs_symlink
  	struct xfs_bmap_free	free_list;
  	xfs_fsblock_t		first_block;
  	bool                    unlock_dp_on_error = false;
++<<<<<<< HEAD
 +	uint			cancel_flags;
 +	int			committed;
++=======
++>>>>>>> f6106efae5f4 (xfs: eliminate committed arg from xfs_bmap_finish)
  	xfs_fileoff_t		first_fsb;
  	xfs_filblks_t		fs_blocks;
  	int			nmaps;
diff --git a/fs/xfs/libxfs/xfs_attr.c b/fs/xfs/libxfs/xfs_attr.c
index cce6316e9dd0..374ee5681db4 100644
--- a/fs/xfs/libxfs/xfs_attr.c
+++ b/fs/xfs/libxfs/xfs_attr.c
@@ -207,7 +207,7 @@ xfs_attr_set(
 	struct xfs_trans_res	tres;
 	xfs_fsblock_t		firstblock;
 	int			rsvd = (flags & ATTR_ROOT) != 0;
-	int			error, err2, committed, local;
+	int			error, err2, local;
 
 	XFS_STATS_INC(xs_attr_set);
 
@@ -335,24 +335,14 @@ xfs_attr_set(
 		 */
 		xfs_bmap_init(args.flist, args.firstblock);
 		error = xfs_attr_shortform_to_leaf(&args);
-		if (!error) {
-			error = xfs_bmap_finish(&args.trans, args.flist,
-						&committed);
-		}
+		if (!error)
+			error = xfs_bmap_finish(&args.trans, args.flist, dp);
 		if (error) {
-			ASSERT(committed);
 			args.trans = NULL;
 			xfs_bmap_cancel(&flist);
 			goto out;
 		}
 
-		/*
-		 * bmap_finish() may have committed the last trans and started
-		 * a new one.  We need the inode to be in all transactions.
-		 */
-		if (committed)
-			xfs_trans_ijoin(args.trans, dp, 0);
-
 		/*
 		 * Commit the leaf transformation.  We'll need another (linked)
 		 * transaction to add the new attribute to the leaf.
@@ -573,7 +563,7 @@ xfs_attr_leaf_addname(xfs_da_args_t *args)
 {
 	xfs_inode_t *dp;
 	struct xfs_buf *bp;
-	int retval, error, committed, forkoff;
+	int retval, error, forkoff;
 
 	trace_xfs_attr_leaf_addname(args);
 
@@ -633,24 +623,14 @@ xfs_attr_leaf_addname(xfs_da_args_t *args)
 		 */
 		xfs_bmap_init(args->flist, args->firstblock);
 		error = xfs_attr3_leaf_to_node(args);
-		if (!error) {
-			error = xfs_bmap_finish(&args->trans, args->flist,
-						&committed);
-		}
+		if (!error)
+			error = xfs_bmap_finish(&args->trans, args->flist, dp);
 		if (error) {
-			ASSERT(committed);
 			args->trans = NULL;
 			xfs_bmap_cancel(args->flist);
 			return error;
 		}
 
-		/*
-		 * bmap_finish() may have committed the last trans and started
-		 * a new one.  We need the inode to be in all transactions.
-		 */
-		if (committed)
-			xfs_trans_ijoin(args->trans, dp, 0);
-
 		/*
 		 * Commit the current trans (including the inode) and start
 		 * a new one.
@@ -734,25 +714,14 @@ xfs_attr_leaf_addname(xfs_da_args_t *args)
 			xfs_bmap_init(args->flist, args->firstblock);
 			error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
 			/* bp is gone due to xfs_da_shrink_inode */
-			if (!error) {
+			if (!error)
 				error = xfs_bmap_finish(&args->trans,
-							args->flist,
-							&committed);
-			}
+							args->flist, dp);
 			if (error) {
-				ASSERT(committed);
 				args->trans = NULL;
 				xfs_bmap_cancel(args->flist);
 				return error;
 			}
-
-			/*
-			 * bmap_finish() may have committed the last trans
-			 * and started a new one.  We need the inode to be
-			 * in all transactions.
-			 */
-			if (committed)
-				xfs_trans_ijoin(args->trans, dp, 0);
 		}
 
 		/*
@@ -780,7 +749,7 @@ xfs_attr_leaf_removename(xfs_da_args_t *args)
 {
 	xfs_inode_t *dp;
 	struct xfs_buf *bp;
-	int error, committed, forkoff;
+	int error, forkoff;
 
 	trace_xfs_attr_leaf_removename(args);
 
@@ -808,23 +777,13 @@ xfs_attr_leaf_removename(xfs_da_args_t *args)
 		xfs_bmap_init(args->flist, args->firstblock);
 		error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
 		/* bp is gone due to xfs_da_shrink_inode */
-		if (!error) {
-			error = xfs_bmap_finish(&args->trans, args->flist,
-						&committed);
-		}
+		if (!error)
+			error = xfs_bmap_finish(&args->trans, args->flist, dp);
 		if (error) {
-			ASSERT(committed);
 			args->trans = NULL;
 			xfs_bmap_cancel(args->flist);
 			return error;
 		}
-
-		/*
-		 * bmap_finish() may have committed the last trans and started
-		 * a new one.  We need the inode to be in all transactions.
-		 */
-		if (committed)
-			xfs_trans_ijoin(args->trans, dp, 0);
 	}
 	return 0;
 }
@@ -882,7 +841,7 @@ xfs_attr_node_addname(xfs_da_args_t *args)
 	xfs_da_state_blk_t *blk;
 	xfs_inode_t *dp;
 	xfs_mount_t *mp;
-	int committed, retval, error;
+	int retval, error;
 
 	trace_xfs_attr_node_addname(args);
 
@@ -943,26 +902,15 @@ restart:
 			state = NULL;
 			xfs_bmap_init(args->flist, args->firstblock);
 			error = xfs_attr3_leaf_to_node(args);
-			if (!error) {
+			if (!error)
 				error = xfs_bmap_finish(&args->trans,
-							args->flist,
-							&committed);
-			}
+							args->flist, dp);
 			if (error) {
-				ASSERT(committed);
 				args->trans = NULL;
 				xfs_bmap_cancel(args->flist);
 				goto out;
 			}
 
-			/*
-			 * bmap_finish() may have committed the last trans
-			 * and started a new one.  We need the inode to be
-			 * in all transactions.
-			 */
-			if (committed)
-				xfs_trans_ijoin(args->trans, dp, 0);
-
 			/*
 			 * Commit the node conversion and start the next
 			 * trans in the chain.
@@ -982,23 +930,13 @@ restart:
 		 */
 		xfs_bmap_init(args->flist, args->firstblock);
 		error = xfs_da3_split(state);
-		if (!error) {
-			error = xfs_bmap_finish(&args->trans, args->flist,
-						&committed);
-		}
+		if (!error)
+			error = xfs_bmap_finish(&args->trans, args->flist, dp);
 		if (error) {
-			ASSERT(committed);
 			args->trans = NULL;
 			xfs_bmap_cancel(args->flist);
 			goto out;
 		}
-
-		/*
-		 * bmap_finish() may have committed the last trans and started
-		 * a new one.  We need the inode to be in all transactions.
-		 */
-		if (committed)
-			xfs_trans_ijoin(args->trans, dp, 0);
 	} else {
 		/*
 		 * Addition succeeded, update Btree hashvals.
@@ -1091,25 +1029,14 @@ restart:
 		if (retval && (state->path.active > 1)) {
 			xfs_bmap_init(args->flist, args->firstblock);
 			error = xfs_da3_join(state);
-			if (!error) {
+			if (!error)
 				error = xfs_bmap_finish(&args->trans,
-							args->flist,
-							&committed);
-			}
+							args->flist, dp);
 			if (error) {
-				ASSERT(committed);
 				args->trans = NULL;
 				xfs_bmap_cancel(args->flist);
 				goto out;
 			}
-
-			/*
-			 * bmap_finish() may have committed the last trans
-			 * and started a new one.  We need the inode to be
-			 * in all transactions.
-			 */
-			if (committed)
-				xfs_trans_ijoin(args->trans, dp, 0);
 		}
 
 		/*
@@ -1151,7 +1078,7 @@ xfs_attr_node_removename(xfs_da_args_t *args)
 	xfs_da_state_blk_t *blk;
 	xfs_inode_t *dp;
 	struct xfs_buf *bp;
-	int retval, error, committed, forkoff;
+	int retval, error, forkoff;
 
 	trace_xfs_attr_node_removename(args);
 
@@ -1225,24 +1152,13 @@ xfs_attr_node_removename(xfs_da_args_t *args)
 	if (retval && (state->path.active > 1)) {
 		xfs_bmap_init(args->flist, args->firstblock);
 		error = xfs_da3_join(state);
-		if (!error) {
-			error = xfs_bmap_finish(&args->trans, args->flist,
-						&committed);
-		}
+		if (!error)
+			error = xfs_bmap_finish(&args->trans, args->flist, dp);
 		if (error) {
-			ASSERT(committed);
 			args->trans = NULL;
 			xfs_bmap_cancel(args->flist);
 			goto out;
 		}
-
-		/*
-		 * bmap_finish() may have committed the last trans and started
-		 * a new one.  We need the inode to be in all transactions.
-		 */
-		if (committed)
-			xfs_trans_ijoin(args->trans, dp, 0);
-
 		/*
 		 * Commit the Btree join operation and start a new trans.
 		 */
@@ -1270,25 +1186,14 @@ xfs_attr_node_removename(xfs_da_args_t *args)
 			xfs_bmap_init(args->flist, args->firstblock);
 			error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
 			/* bp is gone due to xfs_da_shrink_inode */
-			if (!error) {
+			if (!error)
 				error = xfs_bmap_finish(&args->trans,
-							args->flist,
-							&committed);
-			}
+							args->flist, dp);
 			if (error) {
-				ASSERT(committed);
 				args->trans = NULL;
 				xfs_bmap_cancel(args->flist);
 				goto out;
 			}
-
-			/*
-			 * bmap_finish() may have committed the last trans
-			 * and started a new one.  We need the inode to be
-			 * in all transactions.
-			 */
-			if (committed)
-				xfs_trans_ijoin(args->trans, dp, 0);
 		} else
 			xfs_trans_brelse(args->trans, bp);
 	}
diff --git a/fs/xfs/libxfs/xfs_attr_remote.c b/fs/xfs/libxfs/xfs_attr_remote.c
index f3ed9bf0b065..a572532a55cd 100644
--- a/fs/xfs/libxfs/xfs_attr_remote.c
+++ b/fs/xfs/libxfs/xfs_attr_remote.c
@@ -448,8 +448,6 @@ xfs_attr_rmtval_set(
 	 * Roll through the "value", allocating blocks on disk as required.
 	 */
 	while (blkcnt > 0) {
-		int	committed;
-
 		/*
 		 * Allocate a single extent, up to the size of the value.
 		 *
@@ -467,24 +465,14 @@ xfs_attr_rmtval_set(
 		error = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,
 				  blkcnt, XFS_BMAPI_ATTRFORK, args->firstblock,
 				  args->total, &map, &nmap, args->flist);
-		if (!error) {
-			error = xfs_bmap_finish(&args->trans, args->flist,
-						&committed);
-		}
+		if (!error)
+			error = xfs_bmap_finish(&args->trans, args->flist, dp);
 		if (error) {
-			ASSERT(committed);
 			args->trans = NULL;
 			xfs_bmap_cancel(args->flist);
 			return error;
 		}
 
-		/*
-		 * bmap_finish() may have committed the last trans and started
-		 * a new one.  We need the inode to be in all transactions.
-		 */
-		if (committed)
-			xfs_trans_ijoin(args->trans, dp, 0);
-
 		ASSERT(nmap == 1);
 		ASSERT((map.br_startblock != DELAYSTARTBLOCK) &&
 		       (map.br_startblock != HOLESTARTBLOCK));
@@ -615,30 +603,19 @@ xfs_attr_rmtval_remove(
 	blkcnt = args->rmtblkcnt;
 	done = 0;
 	while (!done) {
-		int committed;
-
 		xfs_bmap_init(args->flist, args->firstblock);
 		error = xfs_bunmapi(args->trans, args->dp, lblkno, blkcnt,
 				    XFS_BMAPI_ATTRFORK, 1, args->firstblock,
 				    args->flist, &done);
-		if (!error) {
+		if (!error)
 			error = xfs_bmap_finish(&args->trans, args->flist,
-						&committed);
-		}
+						args->dp);
 		if (error) {
-			ASSERT(committed);
 			args->trans = NULL;
 			xfs_bmap_cancel(args->flist);
 			return error;
 		}
 
-		/*
-		 * bmap_finish() may have committed the last trans and started
-		 * a new one.  We need the inode to be in all transactions.
-		 */
-		if (committed)
-			xfs_trans_ijoin(args->trans, args->dp, 0);
-
 		/*
 		 * Close out trans and start the next one in the chain.
 		 */
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
diff --git a/fs/xfs/libxfs/xfs_bmap.h b/fs/xfs/libxfs/xfs_bmap.h
index b9d8a499d2c4..8a418b731f2c 100644
--- a/fs/xfs/libxfs/xfs_bmap.h
+++ b/fs/xfs/libxfs/xfs_bmap.h
@@ -181,7 +181,7 @@ void	xfs_bmap_add_free(xfs_fsblock_t bno, xfs_filblks_t len,
 		struct xfs_bmap_free *flist, struct xfs_mount *mp);
 void	xfs_bmap_cancel(struct xfs_bmap_free *flist);
 int	xfs_bmap_finish(struct xfs_trans **tp, struct xfs_bmap_free *flist,
-			int *committed);
+			struct xfs_inode *ip);
 void	xfs_bmap_compute_maxlevels(struct xfs_mount *mp, int whichfork);
 int	xfs_bmap_first_unused(struct xfs_trans *tp, struct xfs_inode *ip,
 		xfs_extlen_t len, xfs_fileoff_t *unused, int whichfork);
* Unmerged path fs/xfs/xfs_bmap_util.c
diff --git a/fs/xfs/xfs_dquot.c b/fs/xfs/xfs_dquot.c
index f85db97369ce..832ee310df97 100644
--- a/fs/xfs/xfs_dquot.c
+++ b/fs/xfs/xfs_dquot.c
@@ -306,7 +306,7 @@ xfs_qm_dqalloc(
 	xfs_fsblock_t	firstblock;
 	xfs_bmap_free_t flist;
 	xfs_bmbt_irec_t map;
-	int		nmaps, error, committed;
+	int		nmaps, error;
 	xfs_buf_t	*bp;
 	xfs_trans_t	*tp = *tpp;
 
@@ -379,11 +379,12 @@ xfs_qm_dqalloc(
 
 	xfs_trans_bhold(tp, bp);
 
-	if ((error = xfs_bmap_finish(tpp, &flist, &committed))) {
+	error = xfs_bmap_finish(tpp, &flist, NULL);
+	if (error)
 		goto error1;
-	}
 
-	if (committed) {
+	/* Transaction was committed? */
+	if (*tpp != tp) {
 		tp = *tpp;
 		xfs_trans_bjoin(tp, bp);
 	} else {
@@ -393,9 +394,9 @@ xfs_qm_dqalloc(
 	*O_bpp = bp;
 	return 0;
 
-      error1:
+error1:
 	xfs_bmap_cancel(&flist);
-      error0:
+error0:
 	xfs_iunlock(quotip, XFS_ILOCK_EXCL);
 
 	return error;
* Unmerged path fs/xfs/xfs_inode.c
diff --git a/fs/xfs/xfs_iomap.c b/fs/xfs/xfs_iomap.c
index 8a10c6211bb4..ae5cefa25365 100644
--- a/fs/xfs/xfs_iomap.c
+++ b/fs/xfs/xfs_iomap.c
@@ -129,7 +129,6 @@ xfs_iomap_write_direct(
 	xfs_trans_t	*tp;
 	xfs_bmap_free_t free_list;
 	uint		qblocks, resblks, resrtextents;
-	int		committed;
 	int		error;
 	int		lockmode;
 
@@ -229,7 +228,7 @@ xfs_iomap_write_direct(
 	/*
 	 * Complete the transaction
 	 */
-	error = xfs_bmap_finish(&tp, &free_list, &committed);
+	error = xfs_bmap_finish(&tp, &free_list, NULL);
 	if (error)
 		goto out_bmap_cancel;
 	error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
@@ -674,7 +673,7 @@ xfs_iomap_write_allocate(
 	xfs_bmap_free_t	free_list;
 	xfs_filblks_t	count_fsb;
 	xfs_trans_t	*tp;
-	int		nimaps, committed;
+	int		nimaps;
 	int		error = 0;
 	int		nres;
 
@@ -775,7 +774,7 @@ xfs_iomap_write_allocate(
 			if (error)
 				goto trans_cancel;
 
-			error = xfs_bmap_finish(&tp, &free_list, &committed);
+			error = xfs_bmap_finish(&tp, &free_list, NULL);
 			if (error)
 				goto trans_cancel;
 
@@ -833,7 +832,6 @@ xfs_iomap_write_unwritten(
 	xfs_bmap_free_t free_list;
 	xfs_fsize_t	i_size;
 	uint		resblks;
-	int		committed;
 	int		error;
 
 	trace_xfs_unwritten_convert(ip, offset, count);
@@ -905,7 +903,7 @@ xfs_iomap_write_unwritten(
 			xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
 		}
 
-		error = xfs_bmap_finish(&tp, &free_list, &committed);
+		error = xfs_bmap_finish(&tp, &free_list, NULL);
 		if (error)
 			goto error_on_bmapi_transaction;
 
* Unmerged path fs/xfs/xfs_rtalloc.c
* Unmerged path fs/xfs/xfs_symlink.c
