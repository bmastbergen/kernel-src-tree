tunnels: Don't apply GRO to multiple layers of encapsulation.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] tunnels: Don't apply GRO to multiple layers of encapsulation (Jiri Benc) [1297504]
Rebuild_FUZZ: 99.17%
commit-author Jesse Gross <jesse@kernel.org>
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fac8e0f5.failed

When drivers express support for TSO of encapsulated packets, they
only mean that they can do it for one layer of encapsulation.
Supporting additional levels would mean updating, at a minimum,
more IP length fields and they are unaware of this.

No encapsulation device expresses support for handling offloaded
encapsulated packets, so we won't generate these types of frames
in the transmit path. However, GRO doesn't have a check for
multiple levels of encapsulation and will attempt to build them.

UDP tunnel GRO actually does prevent this situation but it only
handles multiple UDP tunnels stacked on top of each other. This
generalizes that solution to prevent any kind of tunnel stacking
that would cause problems.

Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
	Signed-off-by: Jesse Gross <jesse@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fac8e0f579695a3ecbc4d3cac369139d7f819971)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/ipv4/af_inet.c
#	net/ipv6/ip6_offload.c
diff --cc include/linux/netdevice.h
index 95e53059b81a,f9eebd518545..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1812,8 -2093,11 +1812,16 @@@ struct napi_gro_cb 
  	/* Used in ipv6_gro_receive() and foo-over-udp */
  	u16	proto;
  
++<<<<<<< HEAD
 +	/* Used in udp_gro_receive */
 +	u8	udp_mark:1;
++=======
+ 	/* This is non-zero if the packet may be of the same flow. */
+ 	u8	same_flow:1;
+ 
+ 	/* Used in tunnel GRO receive */
+ 	u8	encap_mark:1;
++>>>>>>> fac8e0f57969 (tunnels: Don't apply GRO to multiple layers of encapsulation.)
  
  	/* GRO checksum is valid */
  	u8	csum_valid:1;
diff --cc net/ipv4/af_inet.c
index 96cfb62894e8,0fefba64ee79..000000000000
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@@ -1390,6 -1380,56 +1390,59 @@@ out
  	return pp;
  }
  
++<<<<<<< HEAD
++=======
+ static struct sk_buff **ipip_gro_receive(struct sk_buff **head,
+ 					 struct sk_buff *skb)
+ {
+ 	if (NAPI_GRO_CB(skb)->encap_mark) {
+ 		NAPI_GRO_CB(skb)->flush = 1;
+ 		return NULL;
+ 	}
+ 
+ 	NAPI_GRO_CB(skb)->encap_mark = 1;
+ 
+ 	return inet_gro_receive(head, skb);
+ }
+ 
+ #define SECONDS_PER_DAY	86400
+ 
+ /* inet_current_timestamp - Return IP network timestamp
+  *
+  * Return milliseconds since midnight in network byte order.
+  */
+ __be32 inet_current_timestamp(void)
+ {
+ 	u32 secs;
+ 	u32 msecs;
+ 	struct timespec64 ts;
+ 
+ 	ktime_get_real_ts64(&ts);
+ 
+ 	/* Get secs since midnight. */
+ 	(void)div_u64_rem(ts.tv_sec, SECONDS_PER_DAY, &secs);
+ 	/* Convert to msecs. */
+ 	msecs = secs * MSEC_PER_SEC;
+ 	/* Convert nsec to msec. */
+ 	msecs += (u32)ts.tv_nsec / NSEC_PER_MSEC;
+ 
+ 	/* Convert to network byte order. */
+ 	return htons(msecs);
+ }
+ EXPORT_SYMBOL(inet_current_timestamp);
+ 
+ int inet_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)
+ {
+ 	if (sk->sk_family == AF_INET)
+ 		return ip_recv_error(sk, msg, len, addr_len);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (sk->sk_family == AF_INET6)
+ 		return pingv6_ops.ipv6_recv_error(sk, msg, len, addr_len);
+ #endif
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> fac8e0f57969 (tunnels: Don't apply GRO to multiple layers of encapsulation.)
  static int inet_gro_complete(struct sk_buff *skb, int nhoff)
  {
  	__be16 newlen = htons(skb->len - nhoff);
@@@ -1619,6 -1695,8 +1672,11 @@@ static struct packet_offload ip_packet_
  static const struct net_offload ipip_offload = {
  	.callbacks = {
  		.gso_segment	= inet_gso_segment,
++<<<<<<< HEAD
++=======
+ 		.gro_receive	= ipip_gro_receive,
+ 		.gro_complete	= ipip_gro_complete,
++>>>>>>> fac8e0f57969 (tunnels: Don't apply GRO to multiple layers of encapsulation.)
  	},
  };
  
diff --cc net/ipv6/ip6_offload.c
index b2a15198951d,82e9f3076028..000000000000
--- a/net/ipv6/ip6_offload.c
+++ b/net/ipv6/ip6_offload.c
@@@ -289,6 -315,8 +302,11 @@@ static struct packet_offload ipv6_packe
  static const struct net_offload sit_offload = {
  	.callbacks = {
  		.gso_segment	= ipv6_gso_segment,
++<<<<<<< HEAD
++=======
+ 		.gro_receive    = sit_gro_receive,
+ 		.gro_complete   = sit_gro_complete,
++>>>>>>> fac8e0f57969 (tunnels: Don't apply GRO to multiple layers of encapsulation.)
  	},
  };
  
* Unmerged path include/linux/netdevice.h
diff --git a/net/core/dev.c b/net/core/dev.c
index 2ce9ccdd4029..e895b8d2df95 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -3846,7 +3846,7 @@ static enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff
 		NAPI_GRO_CB(skb)->same_flow = 0;
 		NAPI_GRO_CB(skb)->flush = 0;
 		NAPI_GRO_CB(skb)->free = 0;
-		NAPI_GRO_CB(skb)->udp_mark = 0;
+		NAPI_GRO_CB(skb)->encap_mark = 0;
 		NAPI_GRO_CB(skb)->gro_remcsum_start = 0;
 
 		/* Setup for GRO checksum validation */
* Unmerged path net/ipv4/af_inet.c
diff --git a/net/ipv4/gre_offload.c b/net/ipv4/gre_offload.c
index bbd163adf449..2aa07db85375 100644
--- a/net/ipv4/gre_offload.c
+++ b/net/ipv4/gre_offload.c
@@ -127,6 +127,11 @@ static struct sk_buff **gre_gro_receive(struct sk_buff **head,
 	struct packet_offload *ptype;
 	__be16 type;
 
+	if (NAPI_GRO_CB(skb)->encap_mark)
+		goto out;
+
+	NAPI_GRO_CB(skb)->encap_mark = 1;
+
 	off = skb_gro_offset(skb);
 	hlen = off + sizeof(*greh);
 	greh = skb_gro_header_fast(skb, off);
diff --git a/net/ipv4/udp_offload.c b/net/ipv4/udp_offload.c
index 2c896776f9f5..63b1239af030 100644
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@ -302,14 +302,14 @@ struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,
 	unsigned int off = skb_gro_offset(skb);
 	int flush = 1;
 
-	if (NAPI_GRO_CB(skb)->udp_mark ||
+	if (NAPI_GRO_CB(skb)->encap_mark ||
 	    (skb->ip_summed != CHECKSUM_PARTIAL &&
 	     NAPI_GRO_CB(skb)->csum_cnt == 0 &&
 	     !NAPI_GRO_CB(skb)->csum_valid))
 		goto out;
 
-	/* mark that this skb passed once through the udp gro layer */
-	NAPI_GRO_CB(skb)->udp_mark = 1;
+	/* mark that this skb passed once through the tunnel gro layer */
+	NAPI_GRO_CB(skb)->encap_mark = 1;
 
 	rcu_read_lock();
 	uo_priv = rcu_dereference(udp_offload_base);
* Unmerged path net/ipv6/ip6_offload.c
