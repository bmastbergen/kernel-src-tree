Bluetooth: Replace constant hw_variant from Intel Bluetooth firmware filename

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [bluetooth] Replace constant hw_variant from Intel Bluetooth firmware filename (Don Zickus) [1353256]
Rebuild_FUZZ: 92.31%
commit-author Tedd Ho-Jeong An <tedd.an@intel.com>
commit 230b04ac8f439d0797ab85fb356f069f0472306f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/230b04ac.failed

The format of Intel Bluetooth firmware filename for bootloader product
is ibt-<hw_variant>-<device_revision_id>.sfi

Currently the driver uses a constant value 11 (0x0b) for hw_variant
to support LnP/SfP product. But new product like WsP product has
a different value such as 12 (0x0c).

To support the multiple products, this patch replaces the constant
value of hw_variant to the actual hw_variant value read from
the device.

	Signed-off-by: Tedd Ho-Jeong An <tedd.an@intel.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 230b04ac8f439d0797ab85fb356f069f0472306f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btusb.c
diff --cc drivers/bluetooth/btusb.c
index 58491f1b2799,f8f0288e679a..000000000000
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@@ -1326,8 -1793,937 +1326,933 @@@ exit_mfg_deactivate
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int inject_cmd_complete(struct hci_dev *hdev, __u16 opcode)
+ {
+ 	struct sk_buff *skb;
+ 	struct hci_event_hdr *hdr;
+ 	struct hci_ev_cmd_complete *evt;
+ 
+ 	skb = bt_skb_alloc(sizeof(*hdr) + sizeof(*evt) + 1, GFP_ATOMIC);
+ 	if (!skb)
+ 		return -ENOMEM;
+ 
+ 	hdr = (struct hci_event_hdr *)skb_put(skb, sizeof(*hdr));
+ 	hdr->evt = HCI_EV_CMD_COMPLETE;
+ 	hdr->plen = sizeof(*evt) + 1;
+ 
+ 	evt = (struct hci_ev_cmd_complete *)skb_put(skb, sizeof(*evt));
+ 	evt->ncmd = 0x01;
+ 	evt->opcode = cpu_to_le16(opcode);
+ 
+ 	*skb_put(skb, 1) = 0x00;
+ 
+ 	hci_skb_pkt_type(skb) = HCI_EVENT_PKT;
+ 
+ 	return hci_recv_frame(hdev, skb);
+ }
+ 
+ static int btusb_recv_bulk_intel(struct btusb_data *data, void *buffer,
+ 				 int count)
+ {
+ 	/* When the device is in bootloader mode, then it can send
+ 	 * events via the bulk endpoint. These events are treated the
+ 	 * same way as the ones received from the interrupt endpoint.
+ 	 */
+ 	if (test_bit(BTUSB_BOOTLOADER, &data->flags))
+ 		return btusb_recv_intr(data, buffer, count);
+ 
+ 	return btusb_recv_bulk(data, buffer, count);
+ }
+ 
+ static void btusb_intel_bootup(struct btusb_data *data, const void *ptr,
+ 			       unsigned int len)
+ {
+ 	const struct intel_bootup *evt = ptr;
+ 
+ 	if (len != sizeof(*evt))
+ 		return;
+ 
+ 	if (test_and_clear_bit(BTUSB_BOOTING, &data->flags)) {
+ 		smp_mb__after_atomic();
+ 		wake_up_bit(&data->flags, BTUSB_BOOTING);
+ 	}
+ }
+ 
+ static void btusb_intel_secure_send_result(struct btusb_data *data,
+ 					   const void *ptr, unsigned int len)
+ {
+ 	const struct intel_secure_send_result *evt = ptr;
+ 
+ 	if (len != sizeof(*evt))
+ 		return;
+ 
+ 	if (evt->result)
+ 		set_bit(BTUSB_FIRMWARE_FAILED, &data->flags);
+ 
+ 	if (test_and_clear_bit(BTUSB_DOWNLOADING, &data->flags) &&
+ 	    test_bit(BTUSB_FIRMWARE_LOADED, &data->flags)) {
+ 		smp_mb__after_atomic();
+ 		wake_up_bit(&data->flags, BTUSB_DOWNLOADING);
+ 	}
+ }
+ 
+ static int btusb_recv_event_intel(struct hci_dev *hdev, struct sk_buff *skb)
+ {
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 
+ 	if (test_bit(BTUSB_BOOTLOADER, &data->flags)) {
+ 		struct hci_event_hdr *hdr = (void *)skb->data;
+ 
+ 		if (skb->len > HCI_EVENT_HDR_SIZE && hdr->evt == 0xff &&
+ 		    hdr->plen > 0) {
+ 			const void *ptr = skb->data + HCI_EVENT_HDR_SIZE + 1;
+ 			unsigned int len = skb->len - HCI_EVENT_HDR_SIZE - 1;
+ 
+ 			switch (skb->data[2]) {
+ 			case 0x02:
+ 				/* When switching to the operational firmware
+ 				 * the device sends a vendor specific event
+ 				 * indicating that the bootup completed.
+ 				 */
+ 				btusb_intel_bootup(data, ptr, len);
+ 				break;
+ 			case 0x06:
+ 				/* When the firmware loading completes the
+ 				 * device sends out a vendor specific event
+ 				 * indicating the result of the firmware
+ 				 * loading.
+ 				 */
+ 				btusb_intel_secure_send_result(data, ptr, len);
+ 				break;
+ 			}
+ 		}
+ 	}
+ 
+ 	return hci_recv_frame(hdev, skb);
+ }
+ 
+ static int btusb_send_frame_intel(struct hci_dev *hdev, struct sk_buff *skb)
+ {
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 	struct urb *urb;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	switch (hci_skb_pkt_type(skb)) {
+ 	case HCI_COMMAND_PKT:
+ 		if (test_bit(BTUSB_BOOTLOADER, &data->flags)) {
+ 			struct hci_command_hdr *cmd = (void *)skb->data;
+ 			__u16 opcode = le16_to_cpu(cmd->opcode);
+ 
+ 			/* When in bootloader mode and the command 0xfc09
+ 			 * is received, it needs to be send down the
+ 			 * bulk endpoint. So allocate a bulk URB instead.
+ 			 */
+ 			if (opcode == 0xfc09)
+ 				urb = alloc_bulk_urb(hdev, skb);
+ 			else
+ 				urb = alloc_ctrl_urb(hdev, skb);
+ 
+ 			/* When the 0xfc01 command is issued to boot into
+ 			 * the operational firmware, it will actually not
+ 			 * send a command complete event. To keep the flow
+ 			 * control working inject that event here.
+ 			 */
+ 			if (opcode == 0xfc01)
+ 				inject_cmd_complete(hdev, opcode);
+ 		} else {
+ 			urb = alloc_ctrl_urb(hdev, skb);
+ 		}
+ 		if (IS_ERR(urb))
+ 			return PTR_ERR(urb);
+ 
+ 		hdev->stat.cmd_tx++;
+ 		return submit_or_queue_tx_urb(hdev, urb);
+ 
+ 	case HCI_ACLDATA_PKT:
+ 		urb = alloc_bulk_urb(hdev, skb);
+ 		if (IS_ERR(urb))
+ 			return PTR_ERR(urb);
+ 
+ 		hdev->stat.acl_tx++;
+ 		return submit_or_queue_tx_urb(hdev, urb);
+ 
+ 	case HCI_SCODATA_PKT:
+ 		if (hci_conn_num(hdev, SCO_LINK) < 1)
+ 			return -ENODEV;
+ 
+ 		urb = alloc_isoc_urb(hdev, skb);
+ 		if (IS_ERR(urb))
+ 			return PTR_ERR(urb);
+ 
+ 		hdev->stat.sco_tx++;
+ 		return submit_tx_urb(hdev, urb);
+ 	}
+ 
+ 	return -EILSEQ;
+ }
+ 
+ static int btusb_setup_intel_new(struct hci_dev *hdev)
+ {
+ 	static const u8 reset_param[] = { 0x00, 0x01, 0x00, 0x01,
+ 					  0x00, 0x08, 0x04, 0x00 };
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 	struct sk_buff *skb;
+ 	struct intel_version ver;
+ 	struct intel_boot_params *params;
+ 	const struct firmware *fw;
+ 	const u8 *fw_ptr;
+ 	u32 frag_len;
+ 	char fwname[64];
+ 	ktime_t calltime, delta, rettime;
+ 	unsigned long long duration;
+ 	int err;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	calltime = ktime_get();
+ 
+ 	/* Read the Intel version information to determine if the device
+ 	 * is in bootloader mode or if it already has operational firmware
+ 	 * loaded.
+ 	 */
+ 	err = btintel_read_version(hdev, &ver);
+ 	if (err)
+ 		return err;
+ 
+ 	/* The hardware platform number has a fixed value of 0x37 and
+ 	 * for now only accept this single value.
+ 	 */
+ 	if (ver.hw_platform != 0x37) {
+ 		BT_ERR("%s: Unsupported Intel hardware platform (%u)",
+ 		       hdev->name, ver.hw_platform);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* At the moment the iBT 3.0 hardware variants 0x0b (LnP/SfP)
+ 	 * and 0x0c (WsP) are supported by this firmware loading method.
+ 	 *
+ 	 * This check has been put in place to ensure correct forward
+ 	 * compatibility options when newer hardware variants come along.
+ 	 */
+ 	if (ver.hw_variant != 0x0b && ver.hw_variant != 0x0c) {
+ 		BT_ERR("%s: Unsupported Intel hardware variant (%u)",
+ 		       hdev->name, ver.hw_variant);
+ 		return -EINVAL;
+ 	}
+ 
+ 	btintel_version_info(hdev, &ver);
+ 
+ 	/* The firmware variant determines if the device is in bootloader
+ 	 * mode or is running operational firmware. The value 0x06 identifies
+ 	 * the bootloader and the value 0x23 identifies the operational
+ 	 * firmware.
+ 	 *
+ 	 * When the operational firmware is already present, then only
+ 	 * the check for valid Bluetooth device address is needed. This
+ 	 * determines if the device will be added as configured or
+ 	 * unconfigured controller.
+ 	 *
+ 	 * It is not possible to use the Secure Boot Parameters in this
+ 	 * case since that command is only available in bootloader mode.
+ 	 */
+ 	if (ver.fw_variant == 0x23) {
+ 		clear_bit(BTUSB_BOOTLOADER, &data->flags);
+ 		btintel_check_bdaddr(hdev);
+ 		return 0;
+ 	}
+ 
+ 	/* If the device is not in bootloader mode, then the only possible
+ 	 * choice is to return an error and abort the device initialization.
+ 	 */
+ 	if (ver.fw_variant != 0x06) {
+ 		BT_ERR("%s: Unsupported Intel firmware variant (%u)",
+ 		       hdev->name, ver.fw_variant);
+ 		return -ENODEV;
+ 	}
+ 
+ 	/* Read the secure boot parameters to identify the operating
+ 	 * details of the bootloader.
+ 	 */
+ 	skb = __hci_cmd_sync(hdev, 0xfc0d, 0, NULL, HCI_INIT_TIMEOUT);
+ 	if (IS_ERR(skb)) {
+ 		BT_ERR("%s: Reading Intel boot parameters failed (%ld)",
+ 		       hdev->name, PTR_ERR(skb));
+ 		return PTR_ERR(skb);
+ 	}
+ 
+ 	if (skb->len != sizeof(*params)) {
+ 		BT_ERR("%s: Intel boot parameters size mismatch", hdev->name);
+ 		kfree_skb(skb);
+ 		return -EILSEQ;
+ 	}
+ 
+ 	params = (struct intel_boot_params *)skb->data;
+ 
+ 	BT_INFO("%s: Device revision is %u", hdev->name,
+ 		le16_to_cpu(params->dev_revid));
+ 
+ 	BT_INFO("%s: Secure boot is %s", hdev->name,
+ 		params->secure_boot ? "enabled" : "disabled");
+ 
+ 	BT_INFO("%s: OTP lock is %s", hdev->name,
+ 		params->otp_lock ? "enabled" : "disabled");
+ 
+ 	BT_INFO("%s: API lock is %s", hdev->name,
+ 		params->api_lock ? "enabled" : "disabled");
+ 
+ 	BT_INFO("%s: Debug lock is %s", hdev->name,
+ 		params->debug_lock ? "enabled" : "disabled");
+ 
+ 	BT_INFO("%s: Minimum firmware build %u week %u %u", hdev->name,
+ 		params->min_fw_build_nn, params->min_fw_build_cw,
+ 		2000 + params->min_fw_build_yy);
+ 
+ 	/* It is required that every single firmware fragment is acknowledged
+ 	 * with a command complete event. If the boot parameters indicate
+ 	 * that this bootloader does not send them, then abort the setup.
+ 	 */
+ 	if (params->limited_cce != 0x00) {
+ 		BT_ERR("%s: Unsupported Intel firmware loading method (%u)",
+ 		       hdev->name, params->limited_cce);
+ 		kfree_skb(skb);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* If the OTP has no valid Bluetooth device address, then there will
+ 	 * also be no valid address for the operational firmware.
+ 	 */
+ 	if (!bacmp(&params->otp_bdaddr, BDADDR_ANY)) {
+ 		BT_INFO("%s: No device address configured", hdev->name);
+ 		set_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks);
+ 	}
+ 
+ 	/* With this Intel bootloader only the hardware variant and device
+ 	 * revision information are used to select the right firmware.
+ 	 *
+ 	 * The firmware filename is ibt-<hw_variant>-<dev_revid>.sfi.
+ 	 *
+ 	 * Currently the supported hardware variants are:
+ 	 *   11 (0x0b) for iBT3.0 (LnP/SfP)
+ 	 *   12 (0x0c) for iBT3.5 (WsP)
+ 	 */
+ 	snprintf(fwname, sizeof(fwname), "intel/ibt-%u-%u.sfi",
+ 		 le16_to_cpu(ver.hw_variant),
+ 		 le16_to_cpu(params->dev_revid));
+ 
+ 	err = request_firmware(&fw, fwname, &hdev->dev);
+ 	if (err < 0) {
+ 		BT_ERR("%s: Failed to load Intel firmware file (%d)",
+ 		       hdev->name, err);
+ 		kfree_skb(skb);
+ 		return err;
+ 	}
+ 
+ 	BT_INFO("%s: Found device firmware: %s", hdev->name, fwname);
+ 
+ 	/* Save the DDC file name for later use to apply once the firmware
+ 	 * downloading is done.
+ 	 */
+ 	snprintf(fwname, sizeof(fwname), "intel/ibt-%u-%u.ddc",
+ 		 le16_to_cpu(ver.hw_variant),
+ 		 le16_to_cpu(params->dev_revid));
+ 
+ 	kfree_skb(skb);
+ 
+ 	if (fw->size < 644) {
+ 		BT_ERR("%s: Invalid size of firmware file (%zu)",
+ 		       hdev->name, fw->size);
+ 		err = -EBADF;
+ 		goto done;
+ 	}
+ 
+ 	set_bit(BTUSB_DOWNLOADING, &data->flags);
+ 
+ 	/* Start the firmware download transaction with the Init fragment
+ 	 * represented by the 128 bytes of CSS header.
+ 	 */
+ 	err = btintel_secure_send(hdev, 0x00, 128, fw->data);
+ 	if (err < 0) {
+ 		BT_ERR("%s: Failed to send firmware header (%d)",
+ 		       hdev->name, err);
+ 		goto done;
+ 	}
+ 
+ 	/* Send the 256 bytes of public key information from the firmware
+ 	 * as the PKey fragment.
+ 	 */
+ 	err = btintel_secure_send(hdev, 0x03, 256, fw->data + 128);
+ 	if (err < 0) {
+ 		BT_ERR("%s: Failed to send firmware public key (%d)",
+ 		       hdev->name, err);
+ 		goto done;
+ 	}
+ 
+ 	/* Send the 256 bytes of signature information from the firmware
+ 	 * as the Sign fragment.
+ 	 */
+ 	err = btintel_secure_send(hdev, 0x02, 256, fw->data + 388);
+ 	if (err < 0) {
+ 		BT_ERR("%s: Failed to send firmware signature (%d)",
+ 		       hdev->name, err);
+ 		goto done;
+ 	}
+ 
+ 	fw_ptr = fw->data + 644;
+ 	frag_len = 0;
+ 
+ 	while (fw_ptr - fw->data < fw->size) {
+ 		struct hci_command_hdr *cmd = (void *)(fw_ptr + frag_len);
+ 
+ 		frag_len += sizeof(*cmd) + cmd->plen;
+ 
+ 		/* The parameter length of the secure send command requires
+ 		 * a 4 byte alignment. It happens so that the firmware file
+ 		 * contains proper Intel_NOP commands to align the fragments
+ 		 * as needed.
+ 		 *
+ 		 * Send set of commands with 4 byte alignment from the
+ 		 * firmware data buffer as a single Data fragement.
+ 		 */
+ 		if (!(frag_len % 4)) {
+ 			err = btintel_secure_send(hdev, 0x01, frag_len, fw_ptr);
+ 			if (err < 0) {
+ 				BT_ERR("%s: Failed to send firmware data (%d)",
+ 				       hdev->name, err);
+ 				goto done;
+ 			}
+ 
+ 			fw_ptr += frag_len;
+ 			frag_len = 0;
+ 		}
+ 	}
+ 
+ 	set_bit(BTUSB_FIRMWARE_LOADED, &data->flags);
+ 
+ 	BT_INFO("%s: Waiting for firmware download to complete", hdev->name);
+ 
+ 	/* Before switching the device into operational mode and with that
+ 	 * booting the loaded firmware, wait for the bootloader notification
+ 	 * that all fragments have been successfully received.
+ 	 *
+ 	 * When the event processing receives the notification, then the
+ 	 * BTUSB_DOWNLOADING flag will be cleared.
+ 	 *
+ 	 * The firmware loading should not take longer than 5 seconds
+ 	 * and thus just timeout if that happens and fail the setup
+ 	 * of this device.
+ 	 */
+ 	err = wait_on_bit_timeout(&data->flags, BTUSB_DOWNLOADING,
+ 				  TASK_INTERRUPTIBLE,
+ 				  msecs_to_jiffies(5000));
+ 	if (err == 1) {
+ 		BT_ERR("%s: Firmware loading interrupted", hdev->name);
+ 		err = -EINTR;
+ 		goto done;
+ 	}
+ 
+ 	if (err) {
+ 		BT_ERR("%s: Firmware loading timeout", hdev->name);
+ 		err = -ETIMEDOUT;
+ 		goto done;
+ 	}
+ 
+ 	if (test_bit(BTUSB_FIRMWARE_FAILED, &data->flags)) {
+ 		BT_ERR("%s: Firmware loading failed", hdev->name);
+ 		err = -ENOEXEC;
+ 		goto done;
+ 	}
+ 
+ 	rettime = ktime_get();
+ 	delta = ktime_sub(rettime, calltime);
+ 	duration = (unsigned long long) ktime_to_ns(delta) >> 10;
+ 
+ 	BT_INFO("%s: Firmware loaded in %llu usecs", hdev->name, duration);
+ 
+ done:
+ 	release_firmware(fw);
+ 
+ 	if (err < 0)
+ 		return err;
+ 
+ 	calltime = ktime_get();
+ 
+ 	set_bit(BTUSB_BOOTING, &data->flags);
+ 
+ 	skb = __hci_cmd_sync(hdev, 0xfc01, sizeof(reset_param), reset_param,
+ 			     HCI_INIT_TIMEOUT);
+ 	if (IS_ERR(skb))
+ 		return PTR_ERR(skb);
+ 
+ 	kfree_skb(skb);
+ 
+ 	/* The bootloader will not indicate when the device is ready. This
+ 	 * is done by the operational firmware sending bootup notification.
+ 	 *
+ 	 * Booting into operational firmware should not take longer than
+ 	 * 1 second. However if that happens, then just fail the setup
+ 	 * since something went wrong.
+ 	 */
+ 	BT_INFO("%s: Waiting for device to boot", hdev->name);
+ 
+ 	err = wait_on_bit_timeout(&data->flags, BTUSB_BOOTING,
+ 				  TASK_INTERRUPTIBLE,
+ 				  msecs_to_jiffies(1000));
+ 
+ 	if (err == 1) {
+ 		BT_ERR("%s: Device boot interrupted", hdev->name);
+ 		return -EINTR;
+ 	}
+ 
+ 	if (err) {
+ 		BT_ERR("%s: Device boot timeout", hdev->name);
+ 		return -ETIMEDOUT;
+ 	}
+ 
+ 	rettime = ktime_get();
+ 	delta = ktime_sub(rettime, calltime);
+ 	duration = (unsigned long long) ktime_to_ns(delta) >> 10;
+ 
+ 	BT_INFO("%s: Device booted in %llu usecs", hdev->name, duration);
+ 
+ 	clear_bit(BTUSB_BOOTLOADER, &data->flags);
+ 
+ 	/* Once the device is running in operational mode, it needs to apply
+ 	 * the device configuration (DDC) parameters.
+ 	 *
+ 	 * The device can work without DDC parameters, so even if it fails
+ 	 * to load the file, no need to fail the setup.
+ 	 */
+ 	btintel_load_ddc_config(hdev, fwname);
+ 
+ 	/* Set the event mask for Intel specific vendor events. This enables
+ 	 * a few extra events that are useful during general operation. It
+ 	 * does not enable any debugging related events.
+ 	 *
+ 	 * The device will function correctly without these events enabled
+ 	 * and thus no need to fail the setup.
+ 	 */
+ 	btintel_set_event_mask(hdev, false);
+ 
+ 	return 0;
+ }
+ 
+ static int btusb_shutdown_intel(struct hci_dev *hdev)
+ {
+ 	struct sk_buff *skb;
+ 	long ret;
+ 
+ 	/* Some platforms have an issue with BT LED when the interface is
+ 	 * down or BT radio is turned off, which takes 5 seconds to BT LED
+ 	 * goes off. This command turns off the BT LED immediately.
+ 	 */
+ 	skb = __hci_cmd_sync(hdev, 0xfc3f, 0, NULL, HCI_INIT_TIMEOUT);
+ 	if (IS_ERR(skb)) {
+ 		ret = PTR_ERR(skb);
+ 		BT_ERR("%s: turning off Intel device LED failed (%ld)",
+ 		       hdev->name, ret);
+ 		return ret;
+ 	}
+ 	kfree_skb(skb);
+ 
+ 	return 0;
+ }
+ 
+ static int btusb_set_bdaddr_marvell(struct hci_dev *hdev,
+ 				    const bdaddr_t *bdaddr)
+ {
+ 	struct sk_buff *skb;
+ 	u8 buf[8];
+ 	long ret;
+ 
+ 	buf[0] = 0xfe;
+ 	buf[1] = sizeof(bdaddr_t);
+ 	memcpy(buf + 2, bdaddr, sizeof(bdaddr_t));
+ 
+ 	skb = __hci_cmd_sync(hdev, 0xfc22, sizeof(buf), buf, HCI_INIT_TIMEOUT);
+ 	if (IS_ERR(skb)) {
+ 		ret = PTR_ERR(skb);
+ 		BT_ERR("%s: changing Marvell device address failed (%ld)",
+ 		       hdev->name, ret);
+ 		return ret;
+ 	}
+ 	kfree_skb(skb);
+ 
+ 	return 0;
+ }
+ 
+ static int btusb_set_bdaddr_ath3012(struct hci_dev *hdev,
+ 				    const bdaddr_t *bdaddr)
+ {
+ 	struct sk_buff *skb;
+ 	u8 buf[10];
+ 	long ret;
+ 
+ 	buf[0] = 0x01;
+ 	buf[1] = 0x01;
+ 	buf[2] = 0x00;
+ 	buf[3] = sizeof(bdaddr_t);
+ 	memcpy(buf + 4, bdaddr, sizeof(bdaddr_t));
+ 
+ 	skb = __hci_cmd_sync(hdev, 0xfc0b, sizeof(buf), buf, HCI_INIT_TIMEOUT);
+ 	if (IS_ERR(skb)) {
+ 		ret = PTR_ERR(skb);
+ 		BT_ERR("%s: Change address command failed (%ld)",
+ 		       hdev->name, ret);
+ 		return ret;
+ 	}
+ 	kfree_skb(skb);
+ 
+ 	return 0;
+ }
+ 
+ #define QCA_DFU_PACKET_LEN	4096
+ 
+ #define QCA_GET_TARGET_VERSION	0x09
+ #define QCA_CHECK_STATUS	0x05
+ #define QCA_DFU_DOWNLOAD	0x01
+ 
+ #define QCA_SYSCFG_UPDATED	0x40
+ #define QCA_PATCH_UPDATED	0x80
+ #define QCA_DFU_TIMEOUT		3000
+ 
+ struct qca_version {
+ 	__le32	rom_version;
+ 	__le32	patch_version;
+ 	__le32	ram_version;
+ 	__le32	ref_clock;
+ 	__u8	reserved[4];
+ } __packed;
+ 
+ struct qca_rampatch_version {
+ 	__le16	rom_version;
+ 	__le16	patch_version;
+ } __packed;
+ 
+ struct qca_device_info {
+ 	u32	rom_version;
+ 	u8	rampatch_hdr;	/* length of header in rampatch */
+ 	u8	nvm_hdr;	/* length of header in NVM */
+ 	u8	ver_offset;	/* offset of version structure in rampatch */
+ };
+ 
+ static const struct qca_device_info qca_devices_table[] = {
+ 	{ 0x00000100, 20, 4, 10 }, /* Rome 1.0 */
+ 	{ 0x00000101, 20, 4, 10 }, /* Rome 1.1 */
+ 	{ 0x00000200, 28, 4, 18 }, /* Rome 2.0 */
+ 	{ 0x00000201, 28, 4, 18 }, /* Rome 2.1 */
+ 	{ 0x00000300, 28, 4, 18 }, /* Rome 3.0 */
+ 	{ 0x00000302, 28, 4, 18 }, /* Rome 3.2 */
+ };
+ 
+ static int btusb_qca_send_vendor_req(struct hci_dev *hdev, u8 request,
+ 				     void *data, u16 size)
+ {
+ 	struct btusb_data *btdata = hci_get_drvdata(hdev);
+ 	struct usb_device *udev = btdata->udev;
+ 	int pipe, err;
+ 	u8 *buf;
+ 
+ 	buf = kmalloc(size, GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	/* Found some of USB hosts have IOT issues with ours so that we should
+ 	 * not wait until HCI layer is ready.
+ 	 */
+ 	pipe = usb_rcvctrlpipe(udev, 0);
+ 	err = usb_control_msg(udev, pipe, request, USB_TYPE_VENDOR | USB_DIR_IN,
+ 			      0, 0, buf, size, USB_CTRL_SET_TIMEOUT);
+ 	if (err < 0) {
+ 		BT_ERR("%s: Failed to access otp area (%d)", hdev->name, err);
+ 		goto done;
+ 	}
+ 
+ 	memcpy(data, buf, size);
+ 
+ done:
+ 	kfree(buf);
+ 
+ 	return err;
+ }
+ 
+ static int btusb_setup_qca_download_fw(struct hci_dev *hdev,
+ 				       const struct firmware *firmware,
+ 				       size_t hdr_size)
+ {
+ 	struct btusb_data *btdata = hci_get_drvdata(hdev);
+ 	struct usb_device *udev = btdata->udev;
+ 	size_t count, size, sent = 0;
+ 	int pipe, len, err;
+ 	u8 *buf;
+ 
+ 	buf = kmalloc(QCA_DFU_PACKET_LEN, GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	count = firmware->size;
+ 
+ 	size = min_t(size_t, count, hdr_size);
+ 	memcpy(buf, firmware->data, size);
+ 
+ 	/* USB patches should go down to controller through USB path
+ 	 * because binary format fits to go down through USB channel.
+ 	 * USB control path is for patching headers and USB bulk is for
+ 	 * patch body.
+ 	 */
+ 	pipe = usb_sndctrlpipe(udev, 0);
+ 	err = usb_control_msg(udev, pipe, QCA_DFU_DOWNLOAD, USB_TYPE_VENDOR,
+ 			      0, 0, buf, size, USB_CTRL_SET_TIMEOUT);
+ 	if (err < 0) {
+ 		BT_ERR("%s: Failed to send headers (%d)", hdev->name, err);
+ 		goto done;
+ 	}
+ 
+ 	sent += size;
+ 	count -= size;
+ 
+ 	while (count) {
+ 		size = min_t(size_t, count, QCA_DFU_PACKET_LEN);
+ 
+ 		memcpy(buf, firmware->data + sent, size);
+ 
+ 		pipe = usb_sndbulkpipe(udev, 0x02);
+ 		err = usb_bulk_msg(udev, pipe, buf, size, &len,
+ 				   QCA_DFU_TIMEOUT);
+ 		if (err < 0) {
+ 			BT_ERR("%s: Failed to send body at %zd of %zd (%d)",
+ 			       hdev->name, sent, firmware->size, err);
+ 			break;
+ 		}
+ 
+ 		if (size != len) {
+ 			BT_ERR("%s: Failed to get bulk buffer", hdev->name);
+ 			err = -EILSEQ;
+ 			break;
+ 		}
+ 
+ 		sent  += size;
+ 		count -= size;
+ 	}
+ 
+ done:
+ 	kfree(buf);
+ 	return err;
+ }
+ 
+ static int btusb_setup_qca_load_rampatch(struct hci_dev *hdev,
+ 					 struct qca_version *ver,
+ 					 const struct qca_device_info *info)
+ {
+ 	struct qca_rampatch_version *rver;
+ 	const struct firmware *fw;
+ 	u32 ver_rom, ver_patch;
+ 	u16 rver_rom, rver_patch;
+ 	char fwname[64];
+ 	int err;
+ 
+ 	ver_rom = le32_to_cpu(ver->rom_version);
+ 	ver_patch = le32_to_cpu(ver->patch_version);
+ 
+ 	snprintf(fwname, sizeof(fwname), "qca/rampatch_usb_%08x.bin", ver_rom);
+ 
+ 	err = request_firmware(&fw, fwname, &hdev->dev);
+ 	if (err) {
+ 		BT_ERR("%s: failed to request rampatch file: %s (%d)",
+ 		       hdev->name, fwname, err);
+ 		return err;
+ 	}
+ 
+ 	BT_INFO("%s: using rampatch file: %s", hdev->name, fwname);
+ 
+ 	rver = (struct qca_rampatch_version *)(fw->data + info->ver_offset);
+ 	rver_rom = le16_to_cpu(rver->rom_version);
+ 	rver_patch = le16_to_cpu(rver->patch_version);
+ 
+ 	BT_INFO("%s: QCA: patch rome 0x%x build 0x%x, firmware rome 0x%x "
+ 		"build 0x%x", hdev->name, rver_rom, rver_patch, ver_rom,
+ 		ver_patch);
+ 
+ 	if (rver_rom != ver_rom || rver_patch <= ver_patch) {
+ 		BT_ERR("%s: rampatch file version did not match with firmware",
+ 		       hdev->name);
+ 		err = -EINVAL;
+ 		goto done;
+ 	}
+ 
+ 	err = btusb_setup_qca_download_fw(hdev, fw, info->rampatch_hdr);
+ 
+ done:
+ 	release_firmware(fw);
+ 
+ 	return err;
+ }
+ 
+ static int btusb_setup_qca_load_nvm(struct hci_dev *hdev,
+ 				    struct qca_version *ver,
+ 				    const struct qca_device_info *info)
+ {
+ 	const struct firmware *fw;
+ 	char fwname[64];
+ 	int err;
+ 
+ 	snprintf(fwname, sizeof(fwname), "qca/nvm_usb_%08x.bin",
+ 		 le32_to_cpu(ver->rom_version));
+ 
+ 	err = request_firmware(&fw, fwname, &hdev->dev);
+ 	if (err) {
+ 		BT_ERR("%s: failed to request NVM file: %s (%d)",
+ 		       hdev->name, fwname, err);
+ 		return err;
+ 	}
+ 
+ 	BT_INFO("%s: using NVM file: %s", hdev->name, fwname);
+ 
+ 	err = btusb_setup_qca_download_fw(hdev, fw, info->nvm_hdr);
+ 
+ 	release_firmware(fw);
+ 
+ 	return err;
+ }
+ 
+ static int btusb_setup_qca(struct hci_dev *hdev)
+ {
+ 	const struct qca_device_info *info = NULL;
+ 	struct qca_version ver;
+ 	u32 ver_rom;
+ 	u8 status;
+ 	int i, err;
+ 
+ 	err = btusb_qca_send_vendor_req(hdev, QCA_GET_TARGET_VERSION, &ver,
+ 					sizeof(ver));
+ 	if (err < 0)
+ 		return err;
+ 
+ 	ver_rom = le32_to_cpu(ver.rom_version);
+ 	for (i = 0; i < ARRAY_SIZE(qca_devices_table); i++) {
+ 		if (ver_rom == qca_devices_table[i].rom_version)
+ 			info = &qca_devices_table[i];
+ 	}
+ 	if (!info) {
+ 		BT_ERR("%s: don't support firmware rome 0x%x", hdev->name,
+ 		       ver_rom);
+ 		return -ENODEV;
+ 	}
+ 
+ 	err = btusb_qca_send_vendor_req(hdev, QCA_CHECK_STATUS, &status,
+ 					sizeof(status));
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (!(status & QCA_PATCH_UPDATED)) {
+ 		err = btusb_setup_qca_load_rampatch(hdev, &ver, info);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (!(status & QCA_SYSCFG_UPDATED)) {
+ 		err = btusb_setup_qca_load_nvm(hdev, &ver, info);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_BT_HCIBTUSB_BCM
+ static inline int __set_diag_interface(struct hci_dev *hdev)
+ {
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 	struct usb_interface *intf = data->diag;
+ 	int i;
+ 
+ 	if (!data->diag)
+ 		return -ENODEV;
+ 
+ 	data->diag_tx_ep = NULL;
+ 	data->diag_rx_ep = NULL;
+ 
+ 	for (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {
+ 		struct usb_endpoint_descriptor *ep_desc;
+ 
+ 		ep_desc = &intf->cur_altsetting->endpoint[i].desc;
+ 
+ 		if (!data->diag_tx_ep && usb_endpoint_is_bulk_out(ep_desc)) {
+ 			data->diag_tx_ep = ep_desc;
+ 			continue;
+ 		}
+ 
+ 		if (!data->diag_rx_ep && usb_endpoint_is_bulk_in(ep_desc)) {
+ 			data->diag_rx_ep = ep_desc;
+ 			continue;
+ 		}
+ 	}
+ 
+ 	if (!data->diag_tx_ep || !data->diag_rx_ep) {
+ 		BT_ERR("%s invalid diagnostic descriptors", hdev->name);
+ 		return -ENODEV;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static struct urb *alloc_diag_urb(struct hci_dev *hdev, bool enable)
+ {
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 	struct sk_buff *skb;
+ 	struct urb *urb;
+ 	unsigned int pipe;
+ 
+ 	if (!data->diag_tx_ep)
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	urb = usb_alloc_urb(0, GFP_KERNEL);
+ 	if (!urb)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	skb = bt_skb_alloc(2, GFP_KERNEL);
+ 	if (!skb) {
+ 		usb_free_urb(urb);
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 
+ 	*skb_put(skb, 1) = 0xf0;
+ 	*skb_put(skb, 1) = enable;
+ 
+ 	pipe = usb_sndbulkpipe(data->udev, data->diag_tx_ep->bEndpointAddress);
+ 
+ 	usb_fill_bulk_urb(urb, data->udev, pipe,
+ 			  skb->data, skb->len, btusb_tx_complete, skb);
+ 
+ 	skb->dev = (void *)hdev;
+ 
+ 	return urb;
+ }
+ 
+ static int btusb_bcm_set_diag(struct hci_dev *hdev, bool enable)
+ {
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 	struct urb *urb;
+ 
+ 	if (!data->diag)
+ 		return -ENODEV;
+ 
+ 	if (!test_bit(HCI_RUNNING, &hdev->flags))
+ 		return -ENETDOWN;
+ 
+ 	urb = alloc_diag_urb(hdev, enable);
+ 	if (IS_ERR(urb))
+ 		return PTR_ERR(urb);
+ 
+ 	return submit_or_queue_tx_urb(hdev, urb);
+ }
+ #endif
+ 
++>>>>>>> 230b04ac8f43 (Bluetooth: Replace constant hw_variant from Intel Bluetooth firmware filename)
  static int btusb_probe(struct usb_interface *intf,
 -		       const struct usb_device_id *id)
 +				const struct usb_device_id *id)
  {
  	struct usb_endpoint_descriptor *ep_desc;
  	struct btusb_data *data;
* Unmerged path drivers/bluetooth/btusb.c
