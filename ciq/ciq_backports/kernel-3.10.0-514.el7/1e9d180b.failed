ext2, ext4: fix issue with missing journal entry in ext4_dax_mkwrite()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ross Zwisler <ross.zwisler@linux.intel.com>
commit 1e9d180ba39f42e8ca4a808baef3a3ef034b1c2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1e9d180b.failed

As it is currently written ext4_dax_mkwrite() assumes that the call into
__dax_mkwrite() will not have to do a block allocation so it doesn't create
a journal entry.  For a read that creates a zero page to cover a hole
followed by a write that actually allocates storage this is incorrect.  The
ext4_dax_mkwrite() -> __dax_mkwrite() -> __dax_fault() path calls
get_blocks() to allocate storage.

Fix this by having the ->page_mkwrite fault handler call ext4_dax_fault()
as this function already has all the logic needed to allocate a journal
entry and call __dax_fault().

Also update the ext2 fault handlers in this same way to remove duplicate
code and keep the logic between ext2 and ext4 the same.

	Reviewed-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit 1e9d180ba39f42e8ca4a808baef3a3ef034b1c2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext2/file.c
#	fs/ext4/file.c
diff --cc fs/ext2/file.c
index a5b3a5db3120,c1400b109805..000000000000
--- a/fs/ext2/file.c
+++ b/fs/ext2/file.c
@@@ -25,6 -26,105 +25,108 @@@
  #include "xattr.h"
  #include "acl.h"
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_FS_DAX
+ /*
+  * The lock ordering for ext2 DAX fault paths is:
+  *
+  * mmap_sem (MM)
+  *   sb_start_pagefault (vfs, freeze)
+  *     ext2_inode_info->dax_sem
+  *       address_space->i_mmap_rwsem or page_lock (mutually exclusive in DAX)
+  *         ext2_inode_info->truncate_mutex
+  *
+  * The default page_lock and i_size verification done by non-DAX fault paths
+  * is sufficient because ext2 doesn't support hole punching.
+  */
+ static int ext2_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+ {
+ 	struct inode *inode = file_inode(vma->vm_file);
+ 	struct ext2_inode_info *ei = EXT2_I(inode);
+ 	int ret;
+ 
+ 	if (vmf->flags & FAULT_FLAG_WRITE) {
+ 		sb_start_pagefault(inode->i_sb);
+ 		file_update_time(vma->vm_file);
+ 	}
+ 	down_read(&ei->dax_sem);
+ 
+ 	ret = __dax_fault(vma, vmf, ext2_get_block, NULL);
+ 
+ 	up_read(&ei->dax_sem);
+ 	if (vmf->flags & FAULT_FLAG_WRITE)
+ 		sb_end_pagefault(inode->i_sb);
+ 	return ret;
+ }
+ 
+ static int ext2_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,
+ 						pmd_t *pmd, unsigned int flags)
+ {
+ 	struct inode *inode = file_inode(vma->vm_file);
+ 	struct ext2_inode_info *ei = EXT2_I(inode);
+ 	int ret;
+ 
+ 	if (flags & FAULT_FLAG_WRITE) {
+ 		sb_start_pagefault(inode->i_sb);
+ 		file_update_time(vma->vm_file);
+ 	}
+ 	down_read(&ei->dax_sem);
+ 
+ 	ret = __dax_pmd_fault(vma, addr, pmd, flags, ext2_get_block, NULL);
+ 
+ 	up_read(&ei->dax_sem);
+ 	if (flags & FAULT_FLAG_WRITE)
+ 		sb_end_pagefault(inode->i_sb);
+ 	return ret;
+ }
+ 
+ static int ext2_dax_pfn_mkwrite(struct vm_area_struct *vma,
+ 		struct vm_fault *vmf)
+ {
+ 	struct inode *inode = file_inode(vma->vm_file);
+ 	struct ext2_inode_info *ei = EXT2_I(inode);
+ 	loff_t size;
+ 	int ret;
+ 
+ 	sb_start_pagefault(inode->i_sb);
+ 	file_update_time(vma->vm_file);
+ 	down_read(&ei->dax_sem);
+ 
+ 	/* check that the faulting page hasn't raced with truncate */
+ 	size = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;
+ 	if (vmf->pgoff >= size)
+ 		ret = VM_FAULT_SIGBUS;
+ 	else
+ 		ret = dax_pfn_mkwrite(vma, vmf);
+ 
+ 	up_read(&ei->dax_sem);
+ 	sb_end_pagefault(inode->i_sb);
+ 	return ret;
+ }
+ 
+ static const struct vm_operations_struct ext2_dax_vm_ops = {
+ 	.fault		= ext2_dax_fault,
+ 	.pmd_fault	= ext2_dax_pmd_fault,
+ 	.page_mkwrite	= ext2_dax_fault,
+ 	.pfn_mkwrite	= ext2_dax_pfn_mkwrite,
+ };
+ 
+ static int ext2_file_mmap(struct file *file, struct vm_area_struct *vma)
+ {
+ 	if (!IS_DAX(file_inode(file)))
+ 		return generic_file_mmap(file, vma);
+ 
+ 	file_accessed(file);
+ 	vma->vm_ops = &ext2_dax_vm_ops;
+ 	vma->vm_flags |= VM_MIXEDMAP | VM_HUGEPAGE;
+ 	return 0;
+ }
+ #else
+ #define ext2_file_mmap	generic_file_mmap
+ #endif
+ 
++>>>>>>> 1e9d180ba39f (ext2, ext4: fix issue with missing journal entry in ext4_dax_mkwrite())
  /*
   * Called when filp is released. This happens when all file descriptors
   * for a single struct file are closed. Note that different open() calls
diff --cc fs/ext4/file.c
index 3034d6b4eaee,4cd318f31cbe..000000000000
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@@ -164,46 -188,125 +164,138 @@@ ext4_file_dio_write(struct kiocb *iocb
  	return ret;
  }
  
 -#ifdef CONFIG_FS_DAX
 -static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 +static ssize_t
 +ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 +		unsigned long nr_segs, loff_t pos)
  {
 -	int result;
 -	handle_t *handle = NULL;
 -	struct inode *inode = file_inode(vma->vm_file);
 -	struct super_block *sb = inode->i_sb;
 -	bool write = vmf->flags & FAULT_FLAG_WRITE;
 +	struct inode *inode = file_inode(iocb->ki_filp);
 +	ssize_t ret;
 +	int overwrite = 0;
  
 -	if (write) {
 -		sb_start_pagefault(sb);
 -		file_update_time(vma->vm_file);
 -		down_read(&EXT4_I(inode)->i_mmap_sem);
 -		handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,
 -						EXT4_DATA_TRANS_BLOCKS(sb));
 -	} else
 -		down_read(&EXT4_I(inode)->i_mmap_sem);
 +	/*
 +	 * If we have encountered a bitmap-format file, the size limit
 +	 * is smaller than s_maxbytes, which is for extent-mapped files.
 +	 */
  
 -	if (IS_ERR(handle))
 -		result = VM_FAULT_SIGBUS;
 +	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {
 +		struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
 +		size_t length = iov_length(iov, nr_segs);
 +
 +		if ((pos > sbi->s_bitmap_maxbytes ||
 +		    (pos == sbi->s_bitmap_maxbytes && length > 0)))
 +			return -EFBIG;
 +
 +		if (pos + length > sbi->s_bitmap_maxbytes) {
 +			nr_segs = iov_shorten((struct iovec *)iov, nr_segs,
 +					      sbi->s_bitmap_maxbytes - pos);
 +		}
 +	}
 +
 +	iocb->private = &overwrite; /* RHEL7 only - prevent DIO race */
 +	if (unlikely(iocb->ki_filp->f_flags & O_DIRECT))
 +		ret = ext4_file_dio_write(iocb, iov, nr_segs, pos);
  	else
++<<<<<<< HEAD
 +		ret = generic_file_aio_write(iocb, iov, nr_segs, pos);
++=======
+ 		result = __dax_fault(vma, vmf, ext4_dax_mmap_get_block, NULL);
+ 
+ 	if (write) {
+ 		if (!IS_ERR(handle))
+ 			ext4_journal_stop(handle);
+ 		up_read(&EXT4_I(inode)->i_mmap_sem);
+ 		sb_end_pagefault(sb);
+ 	} else
+ 		up_read(&EXT4_I(inode)->i_mmap_sem);
+ 
+ 	return result;
+ }
+ 
+ static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,
+ 						pmd_t *pmd, unsigned int flags)
+ {
+ 	int result;
+ 	handle_t *handle = NULL;
+ 	struct inode *inode = file_inode(vma->vm_file);
+ 	struct super_block *sb = inode->i_sb;
+ 	bool write = flags & FAULT_FLAG_WRITE;
+ 
+ 	if (write) {
+ 		sb_start_pagefault(sb);
+ 		file_update_time(vma->vm_file);
+ 		down_read(&EXT4_I(inode)->i_mmap_sem);
+ 		handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,
+ 				ext4_chunk_trans_blocks(inode,
+ 							PMD_SIZE / PAGE_SIZE));
+ 	} else
+ 		down_read(&EXT4_I(inode)->i_mmap_sem);
+ 
+ 	if (IS_ERR(handle))
+ 		result = VM_FAULT_SIGBUS;
+ 	else
+ 		result = __dax_pmd_fault(vma, addr, pmd, flags,
+ 				ext4_dax_mmap_get_block, NULL);
+ 
+ 	if (write) {
+ 		if (!IS_ERR(handle))
+ 			ext4_journal_stop(handle);
+ 		up_read(&EXT4_I(inode)->i_mmap_sem);
+ 		sb_end_pagefault(sb);
+ 	} else
+ 		up_read(&EXT4_I(inode)->i_mmap_sem);
+ 
+ 	return result;
+ }
+ 
+ /*
+  * Handle write fault for VM_MIXEDMAP mappings. Similarly to ext4_dax_fault()
+  * handler we check for races agaist truncate. Note that since we cycle through
+  * i_mmap_sem, we are sure that also any hole punching that began before we
+  * were called is finished by now and so if it included part of the file we
+  * are working on, our pte will get unmapped and the check for pte_same() in
+  * wp_pfn_shared() fails. Thus fault gets retried and things work out as
+  * desired.
+  */
+ static int ext4_dax_pfn_mkwrite(struct vm_area_struct *vma,
+ 				struct vm_fault *vmf)
+ {
+ 	struct inode *inode = file_inode(vma->vm_file);
+ 	struct super_block *sb = inode->i_sb;
+ 	loff_t size;
+ 	int ret;
+ 
+ 	sb_start_pagefault(sb);
+ 	file_update_time(vma->vm_file);
+ 	down_read(&EXT4_I(inode)->i_mmap_sem);
+ 	size = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;
+ 	if (vmf->pgoff >= size)
+ 		ret = VM_FAULT_SIGBUS;
+ 	else
+ 		ret = dax_pfn_mkwrite(vma, vmf);
+ 	up_read(&EXT4_I(inode)->i_mmap_sem);
+ 	sb_end_pagefault(sb);
++>>>>>>> 1e9d180ba39f (ext2, ext4: fix issue with missing journal entry in ext4_dax_mkwrite())
  
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static const struct vm_operations_struct ext4_dax_vm_ops = {
+ 	.fault		= ext4_dax_fault,
+ 	.pmd_fault	= ext4_dax_pmd_fault,
+ 	.page_mkwrite	= ext4_dax_fault,
+ 	.pfn_mkwrite	= ext4_dax_pfn_mkwrite,
+ };
+ #else
+ #define ext4_dax_vm_ops	ext4_file_vm_ops
+ #endif
+ 
++>>>>>>> 1e9d180ba39f (ext2, ext4: fix issue with missing journal entry in ext4_dax_mkwrite())
  static const struct vm_operations_struct ext4_file_vm_ops = {
 -	.fault		= ext4_filemap_fault,
 -	.map_pages	= filemap_map_pages,
 +	.fault		= filemap_fault,
  	.page_mkwrite   = ext4_page_mkwrite,
 +	.remap_pages	= generic_file_remap_pages,
  };
  
  static int ext4_file_mmap(struct file *file, struct vm_area_struct *vma)
* Unmerged path fs/ext2/file.c
* Unmerged path fs/ext4/file.c
