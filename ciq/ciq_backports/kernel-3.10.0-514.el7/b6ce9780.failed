KVM/VMX: Add host irq information in trace event when updating IRTE for posted interrupts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] vmx: Add host irq information in trace event when updating IRTE for posted interrupts (Paul Lai) [1319021]
Rebuild_FUZZ: 97.70%
commit-author Feng Wu <feng.wu@intel.com>
commit b6ce978067e75187d3c30f59b60d390a29374fab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b6ce9780.failed

Add host irq information in trace event, so we can better understand
which irq is in posted mode.

	Signed-off-by: Feng Wu <feng.wu@intel.com>
	Reviewed-by: Radim Krcmar <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit b6ce978067e75187d3c30f59b60d390a29374fab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/trace.h
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/trace.h
index ce4abe333c39,2f1ea2f61e1f..000000000000
--- a/arch/x86/kvm/trace.h
+++ b/arch/x86/kvm/trace.h
@@@ -992,6 -992,306 +992,309 @@@ TRACE_EVENT(kvm_enter_smm
  		  __entry->smbase)
  );
  
++<<<<<<< HEAD
++=======
+ /*
+  * Tracepoint for VT-d posted-interrupts.
+  */
+ TRACE_EVENT(kvm_pi_irte_update,
+ 	TP_PROTO(unsigned int host_irq, unsigned int vcpu_id,
+ 		 unsigned int gsi, unsigned int gvec,
+ 		 u64 pi_desc_addr, bool set),
+ 	TP_ARGS(host_irq, vcpu_id, gsi, gvec, pi_desc_addr, set),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(	unsigned int,	host_irq	)
+ 		__field(	unsigned int,	vcpu_id		)
+ 		__field(	unsigned int,	gsi		)
+ 		__field(	unsigned int,	gvec		)
+ 		__field(	u64,		pi_desc_addr	)
+ 		__field(	bool,		set		)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->host_irq	= host_irq;
+ 		__entry->vcpu_id	= vcpu_id;
+ 		__entry->gsi		= gsi;
+ 		__entry->gvec		= gvec;
+ 		__entry->pi_desc_addr	= pi_desc_addr;
+ 		__entry->set		= set;
+ 	),
+ 
+ 	TP_printk("VT-d PI is %s for irq %u, vcpu %u, gsi: 0x%x, "
+ 		  "gvec: 0x%x, pi_desc_addr: 0x%llx",
+ 		  __entry->set ? "enabled and being updated" : "disabled",
+ 		  __entry->host_irq,
+ 		  __entry->vcpu_id,
+ 		  __entry->gsi,
+ 		  __entry->gvec,
+ 		  __entry->pi_desc_addr)
+ );
+ 
+ /*
+  * Tracepoint for kvm_hv_notify_acked_sint.
+  */
+ TRACE_EVENT(kvm_hv_notify_acked_sint,
+ 	TP_PROTO(int vcpu_id, u32 sint),
+ 	TP_ARGS(vcpu_id, sint),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, vcpu_id)
+ 		__field(u32, sint)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->vcpu_id = vcpu_id;
+ 		__entry->sint = sint;
+ 	),
+ 
+ 	TP_printk("vcpu_id %d sint %u", __entry->vcpu_id, __entry->sint)
+ );
+ 
+ /*
+  * Tracepoint for synic_set_irq.
+  */
+ TRACE_EVENT(kvm_hv_synic_set_irq,
+ 	TP_PROTO(int vcpu_id, u32 sint, int vector, int ret),
+ 	TP_ARGS(vcpu_id, sint, vector, ret),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, vcpu_id)
+ 		__field(u32, sint)
+ 		__field(int, vector)
+ 		__field(int, ret)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->vcpu_id = vcpu_id;
+ 		__entry->sint = sint;
+ 		__entry->vector = vector;
+ 		__entry->ret = ret;
+ 	),
+ 
+ 	TP_printk("vcpu_id %d sint %u vector %d ret %d",
+ 		  __entry->vcpu_id, __entry->sint, __entry->vector,
+ 		  __entry->ret)
+ );
+ 
+ /*
+  * Tracepoint for kvm_hv_synic_send_eoi.
+  */
+ TRACE_EVENT(kvm_hv_synic_send_eoi,
+ 	TP_PROTO(int vcpu_id, int vector),
+ 	TP_ARGS(vcpu_id, vector),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, vcpu_id)
+ 		__field(u32, sint)
+ 		__field(int, vector)
+ 		__field(int, ret)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->vcpu_id = vcpu_id;
+ 		__entry->vector	= vector;
+ 	),
+ 
+ 	TP_printk("vcpu_id %d vector %d", __entry->vcpu_id, __entry->vector)
+ );
+ 
+ /*
+  * Tracepoint for synic_set_msr.
+  */
+ TRACE_EVENT(kvm_hv_synic_set_msr,
+ 	TP_PROTO(int vcpu_id, u32 msr, u64 data, bool host),
+ 	TP_ARGS(vcpu_id, msr, data, host),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, vcpu_id)
+ 		__field(u32, msr)
+ 		__field(u64, data)
+ 		__field(bool, host)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->vcpu_id = vcpu_id;
+ 		__entry->msr = msr;
+ 		__entry->data = data;
+ 		__entry->host = host
+ 	),
+ 
+ 	TP_printk("vcpu_id %d msr 0x%x data 0x%llx host %d",
+ 		  __entry->vcpu_id, __entry->msr, __entry->data, __entry->host)
+ );
+ 
+ /*
+  * Tracepoint for stimer_set_config.
+  */
+ TRACE_EVENT(kvm_hv_stimer_set_config,
+ 	TP_PROTO(int vcpu_id, int timer_index, u64 config, bool host),
+ 	TP_ARGS(vcpu_id, timer_index, config, host),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, vcpu_id)
+ 		__field(int, timer_index)
+ 		__field(u64, config)
+ 		__field(bool, host)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->vcpu_id = vcpu_id;
+ 		__entry->timer_index = timer_index;
+ 		__entry->config = config;
+ 		__entry->host = host;
+ 	),
+ 
+ 	TP_printk("vcpu_id %d timer %d config 0x%llx host %d",
+ 		  __entry->vcpu_id, __entry->timer_index, __entry->config,
+ 		  __entry->host)
+ );
+ 
+ /*
+  * Tracepoint for stimer_set_count.
+  */
+ TRACE_EVENT(kvm_hv_stimer_set_count,
+ 	TP_PROTO(int vcpu_id, int timer_index, u64 count, bool host),
+ 	TP_ARGS(vcpu_id, timer_index, count, host),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, vcpu_id)
+ 		__field(int, timer_index)
+ 		__field(u64, count)
+ 		__field(bool, host)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->vcpu_id = vcpu_id;
+ 		__entry->timer_index = timer_index;
+ 		__entry->count = count;
+ 		__entry->host = host;
+ 	),
+ 
+ 	TP_printk("vcpu_id %d timer %d count %llu host %d",
+ 		  __entry->vcpu_id, __entry->timer_index, __entry->count,
+ 		  __entry->host)
+ );
+ 
+ /*
+  * Tracepoint for stimer_start(periodic timer case).
+  */
+ TRACE_EVENT(kvm_hv_stimer_start_periodic,
+ 	TP_PROTO(int vcpu_id, int timer_index, u64 time_now, u64 exp_time),
+ 	TP_ARGS(vcpu_id, timer_index, time_now, exp_time),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, vcpu_id)
+ 		__field(int, timer_index)
+ 		__field(u64, time_now)
+ 		__field(u64, exp_time)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->vcpu_id = vcpu_id;
+ 		__entry->timer_index = timer_index;
+ 		__entry->time_now = time_now;
+ 		__entry->exp_time = exp_time;
+ 	),
+ 
+ 	TP_printk("vcpu_id %d timer %d time_now %llu exp_time %llu",
+ 		  __entry->vcpu_id, __entry->timer_index, __entry->time_now,
+ 		  __entry->exp_time)
+ );
+ 
+ /*
+  * Tracepoint for stimer_start(one-shot timer case).
+  */
+ TRACE_EVENT(kvm_hv_stimer_start_one_shot,
+ 	TP_PROTO(int vcpu_id, int timer_index, u64 time_now, u64 count),
+ 	TP_ARGS(vcpu_id, timer_index, time_now, count),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, vcpu_id)
+ 		__field(int, timer_index)
+ 		__field(u64, time_now)
+ 		__field(u64, count)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->vcpu_id = vcpu_id;
+ 		__entry->timer_index = timer_index;
+ 		__entry->time_now = time_now;
+ 		__entry->count = count;
+ 	),
+ 
+ 	TP_printk("vcpu_id %d timer %d time_now %llu count %llu",
+ 		  __entry->vcpu_id, __entry->timer_index, __entry->time_now,
+ 		  __entry->count)
+ );
+ 
+ /*
+  * Tracepoint for stimer_timer_callback.
+  */
+ TRACE_EVENT(kvm_hv_stimer_callback,
+ 	TP_PROTO(int vcpu_id, int timer_index),
+ 	TP_ARGS(vcpu_id, timer_index),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, vcpu_id)
+ 		__field(int, timer_index)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->vcpu_id = vcpu_id;
+ 		__entry->timer_index = timer_index;
+ 	),
+ 
+ 	TP_printk("vcpu_id %d timer %d",
+ 		  __entry->vcpu_id, __entry->timer_index)
+ );
+ 
+ /*
+  * Tracepoint for stimer_expiration.
+  */
+ TRACE_EVENT(kvm_hv_stimer_expiration,
+ 	TP_PROTO(int vcpu_id, int timer_index, int msg_send_result),
+ 	TP_ARGS(vcpu_id, timer_index, msg_send_result),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, vcpu_id)
+ 		__field(int, timer_index)
+ 		__field(int, msg_send_result)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->vcpu_id = vcpu_id;
+ 		__entry->timer_index = timer_index;
+ 		__entry->msg_send_result = msg_send_result;
+ 	),
+ 
+ 	TP_printk("vcpu_id %d timer %d msg send result %d",
+ 		  __entry->vcpu_id, __entry->timer_index,
+ 		  __entry->msg_send_result)
+ );
+ 
+ /*
+  * Tracepoint for stimer_cleanup.
+  */
+ TRACE_EVENT(kvm_hv_stimer_cleanup,
+ 	TP_PROTO(int vcpu_id, int timer_index),
+ 	TP_ARGS(vcpu_id, timer_index),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, vcpu_id)
+ 		__field(int, timer_index)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->vcpu_id = vcpu_id;
+ 		__entry->timer_index = timer_index;
+ 	),
+ 
+ 	TP_printk("vcpu_id %d timer %d",
+ 		  __entry->vcpu_id, __entry->timer_index)
+ );
+ 
++>>>>>>> b6ce978067e7 (KVM/VMX: Add host irq information in trace event when updating IRTE for posted interrupts)
  #endif /* _TRACE_KVM_H */
  
  #undef TRACE_INCLUDE_PATH
diff --cc arch/x86/kvm/vmx.c
index a7d76dce5145,164eb9e1678b..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -9849,6 -10600,214 +9849,217 @@@ static void vmx_enable_log_dirty_pt_mas
  	kvm_mmu_clear_dirty_pt_masked(kvm, memslot, offset, mask);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * This routine does the following things for vCPU which is going
+  * to be blocked if VT-d PI is enabled.
+  * - Store the vCPU to the wakeup list, so when interrupts happen
+  *   we can find the right vCPU to wake up.
+  * - Change the Posted-interrupt descriptor as below:
+  *      'NDST' <-- vcpu->pre_pcpu
+  *      'NV' <-- POSTED_INTR_WAKEUP_VECTOR
+  * - If 'ON' is set during this process, which means at least one
+  *   interrupt is posted for this vCPU, we cannot block it, in
+  *   this case, return 1, otherwise, return 0.
+  *
+  */
+ static int vmx_pre_block(struct kvm_vcpu *vcpu)
+ {
+ 	unsigned long flags;
+ 	unsigned int dest;
+ 	struct pi_desc old, new;
+ 	struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+ 
+ 	if (!kvm_arch_has_assigned_device(vcpu->kvm) ||
+ 		!irq_remapping_cap(IRQ_POSTING_CAP))
+ 		return 0;
+ 
+ 	vcpu->pre_pcpu = vcpu->cpu;
+ 	spin_lock_irqsave(&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			  vcpu->pre_pcpu), flags);
+ 	list_add_tail(&vcpu->blocked_vcpu_list,
+ 		      &per_cpu(blocked_vcpu_on_cpu,
+ 		      vcpu->pre_pcpu));
+ 	spin_unlock_irqrestore(&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			       vcpu->pre_pcpu), flags);
+ 
+ 	do {
+ 		old.control = new.control = pi_desc->control;
+ 
+ 		/*
+ 		 * We should not block the vCPU if
+ 		 * an interrupt is posted for it.
+ 		 */
+ 		if (pi_test_on(pi_desc) == 1) {
+ 			spin_lock_irqsave(&per_cpu(blocked_vcpu_on_cpu_lock,
+ 					  vcpu->pre_pcpu), flags);
+ 			list_del(&vcpu->blocked_vcpu_list);
+ 			spin_unlock_irqrestore(
+ 					&per_cpu(blocked_vcpu_on_cpu_lock,
+ 					vcpu->pre_pcpu), flags);
+ 			vcpu->pre_pcpu = -1;
+ 
+ 			return 1;
+ 		}
+ 
+ 		WARN((pi_desc->sn == 1),
+ 		     "Warning: SN field of posted-interrupts "
+ 		     "is set before blocking\n");
+ 
+ 		/*
+ 		 * Since vCPU can be preempted during this process,
+ 		 * vcpu->cpu could be different with pre_pcpu, we
+ 		 * need to set pre_pcpu as the destination of wakeup
+ 		 * notification event, then we can find the right vCPU
+ 		 * to wakeup in wakeup handler if interrupts happen
+ 		 * when the vCPU is in blocked state.
+ 		 */
+ 		dest = cpu_physical_id(vcpu->pre_pcpu);
+ 
+ 		if (x2apic_enabled())
+ 			new.ndst = dest;
+ 		else
+ 			new.ndst = (dest << 8) & 0xFF00;
+ 
+ 		/* set 'NV' to 'wakeup vector' */
+ 		new.nv = POSTED_INTR_WAKEUP_VECTOR;
+ 	} while (cmpxchg(&pi_desc->control, old.control,
+ 			new.control) != old.control);
+ 
+ 	return 0;
+ }
+ 
+ static void vmx_post_block(struct kvm_vcpu *vcpu)
+ {
+ 	struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+ 	struct pi_desc old, new;
+ 	unsigned int dest;
+ 	unsigned long flags;
+ 
+ 	if (!kvm_arch_has_assigned_device(vcpu->kvm) ||
+ 		!irq_remapping_cap(IRQ_POSTING_CAP))
+ 		return;
+ 
+ 	do {
+ 		old.control = new.control = pi_desc->control;
+ 
+ 		dest = cpu_physical_id(vcpu->cpu);
+ 
+ 		if (x2apic_enabled())
+ 			new.ndst = dest;
+ 		else
+ 			new.ndst = (dest << 8) & 0xFF00;
+ 
+ 		/* Allow posting non-urgent interrupts */
+ 		new.sn = 0;
+ 
+ 		/* set 'NV' to 'notification vector' */
+ 		new.nv = POSTED_INTR_VECTOR;
+ 	} while (cmpxchg(&pi_desc->control, old.control,
+ 			new.control) != old.control);
+ 
+ 	if(vcpu->pre_pcpu != -1) {
+ 		spin_lock_irqsave(
+ 			&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			vcpu->pre_pcpu), flags);
+ 		list_del(&vcpu->blocked_vcpu_list);
+ 		spin_unlock_irqrestore(
+ 			&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			vcpu->pre_pcpu), flags);
+ 		vcpu->pre_pcpu = -1;
+ 	}
+ }
+ 
+ /*
+  * vmx_update_pi_irte - set IRTE for Posted-Interrupts
+  *
+  * @kvm: kvm
+  * @host_irq: host irq of the interrupt
+  * @guest_irq: gsi of the interrupt
+  * @set: set or unset PI
+  * returns 0 on success, < 0 on failure
+  */
+ static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,
+ 			      uint32_t guest_irq, bool set)
+ {
+ 	struct kvm_kernel_irq_routing_entry *e;
+ 	struct kvm_irq_routing_table *irq_rt;
+ 	struct kvm_lapic_irq irq;
+ 	struct kvm_vcpu *vcpu;
+ 	struct vcpu_data vcpu_info;
+ 	int idx, ret = -EINVAL;
+ 
+ 	if (!kvm_arch_has_assigned_device(kvm) ||
+ 		!irq_remapping_cap(IRQ_POSTING_CAP))
+ 		return 0;
+ 
+ 	idx = srcu_read_lock(&kvm->irq_srcu);
+ 	irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+ 	BUG_ON(guest_irq >= irq_rt->nr_rt_entries);
+ 
+ 	hlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {
+ 		if (e->type != KVM_IRQ_ROUTING_MSI)
+ 			continue;
+ 		/*
+ 		 * VT-d PI cannot support posting multicast/broadcast
+ 		 * interrupts to a vCPU, we still use interrupt remapping
+ 		 * for these kind of interrupts.
+ 		 *
+ 		 * For lowest-priority interrupts, we only support
+ 		 * those with single CPU as the destination, e.g. user
+ 		 * configures the interrupts via /proc/irq or uses
+ 		 * irqbalance to make the interrupts single-CPU.
+ 		 *
+ 		 * We will support full lowest-priority interrupt later.
+ 		 */
+ 
+ 		kvm_set_msi_irq(e, &irq);
+ 		if (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu)) {
+ 			/*
+ 			 * Make sure the IRTE is in remapped mode if
+ 			 * we don't handle it in posted mode.
+ 			 */
+ 			ret = irq_set_vcpu_affinity(host_irq, NULL);
+ 			if (ret < 0) {
+ 				printk(KERN_INFO
+ 				   "failed to back to remapped mode, irq: %u\n",
+ 				   host_irq);
+ 				goto out;
+ 			}
+ 
+ 			continue;
+ 		}
+ 
+ 		vcpu_info.pi_desc_addr = __pa(vcpu_to_pi_desc(vcpu));
+ 		vcpu_info.vector = irq.vector;
+ 
+ 		trace_kvm_pi_irte_update(vcpu->vcpu_id, host_irq, e->gsi,
+ 				vcpu_info.vector, vcpu_info.pi_desc_addr, set);
+ 
+ 		if (set)
+ 			ret = irq_set_vcpu_affinity(host_irq, &vcpu_info);
+ 		else {
+ 			/* suppress notification event before unposting */
+ 			pi_set_sn(vcpu_to_pi_desc(vcpu));
+ 			ret = irq_set_vcpu_affinity(host_irq, NULL);
+ 			pi_clear_sn(vcpu_to_pi_desc(vcpu));
+ 		}
+ 
+ 		if (ret < 0) {
+ 			printk(KERN_INFO "%s: failed to update PI IRTE\n",
+ 					__func__);
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	ret = 0;
+ out:
+ 	srcu_read_unlock(&kvm->irq_srcu, idx);
+ 	return ret;
+ }
+ 
++>>>>>>> b6ce978067e7 (KVM/VMX: Add host irq information in trace event when updating IRTE for posted interrupts)
  static struct kvm_x86_ops vmx_x86_ops = {
  	.cpu_has_kvm_support = cpu_has_kvm_support,
  	.disabled_by_bios = vmx_disabled_by_bios,
* Unmerged path arch/x86/kvm/trace.h
* Unmerged path arch/x86/kvm/vmx.c
