qla2xxx: Add support for buffer to buffer credit value for ISP27XX.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Add support for buffer to buffer credit value for ISP27XX (Chad Dupuis) [1273080]
Rebuild_FUZZ: 99.25%
commit-author Sawan Chandak <sawan.chandak@qlogic.com>
commit 969a619966d84ec0d2b8392df83cd2693411e46e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/969a6199.failed

	Signed-off-by: Sawan Chandak <sawan.chandak@qlogic.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 969a619966d84ec0d2b8392df83cd2693411e46e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_bsg.c
#	drivers/scsi/qla2xxx/qla_bsg.h
#	drivers/scsi/qla2xxx/qla_def.h
diff --cc drivers/scsi/qla2xxx/qla_bsg.c
index e1c2a57a882f,d135d6a4ccac..000000000000
--- a/drivers/scsi/qla2xxx/qla_bsg.c
+++ b/drivers/scsi/qla2xxx/qla_bsg.c
@@@ -2110,6 -2107,132 +2110,135 @@@ qla8044_serdes_op(struct fc_bsg_job *bs
  }
  
  static int
++<<<<<<< HEAD
++=======
+ qla27xx_get_flash_upd_cap(struct fc_bsg_job *bsg_job)
+ {
+ 	struct Scsi_Host *host = bsg_job->shost;
+ 	scsi_qla_host_t *vha = shost_priv(host);
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct qla_flash_update_caps cap;
+ 
+ 	if (!(IS_QLA27XX(ha)))
+ 		return -EPERM;
+ 
+ 	memset(&cap, 0, sizeof(cap));
+ 	cap.capabilities = (uint64_t)ha->fw_attributes_ext[1] << 48 |
+ 			   (uint64_t)ha->fw_attributes_ext[0] << 32 |
+ 			   (uint64_t)ha->fw_attributes_h << 16 |
+ 			   (uint64_t)ha->fw_attributes;
+ 
+ 	sg_copy_from_buffer(bsg_job->reply_payload.sg_list,
+ 	    bsg_job->reply_payload.sg_cnt, &cap, sizeof(cap));
+ 	bsg_job->reply->reply_payload_rcv_len = sizeof(cap);
+ 
+ 	bsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] =
+ 	    EXT_STATUS_OK;
+ 
+ 	bsg_job->reply_len = sizeof(struct fc_bsg_reply);
+ 	bsg_job->reply->result = DID_OK << 16;
+ 	bsg_job->job_done(bsg_job);
+ 	return 0;
+ }
+ 
+ static int
+ qla27xx_set_flash_upd_cap(struct fc_bsg_job *bsg_job)
+ {
+ 	struct Scsi_Host *host = bsg_job->shost;
+ 	scsi_qla_host_t *vha = shost_priv(host);
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint64_t online_fw_attr = 0;
+ 	struct qla_flash_update_caps cap;
+ 
+ 	if (!(IS_QLA27XX(ha)))
+ 		return -EPERM;
+ 
+ 	memset(&cap, 0, sizeof(cap));
+ 	sg_copy_to_buffer(bsg_job->request_payload.sg_list,
+ 	    bsg_job->request_payload.sg_cnt, &cap, sizeof(cap));
+ 
+ 	online_fw_attr = (uint64_t)ha->fw_attributes_ext[1] << 48 |
+ 			 (uint64_t)ha->fw_attributes_ext[0] << 32 |
+ 			 (uint64_t)ha->fw_attributes_h << 16 |
+ 			 (uint64_t)ha->fw_attributes;
+ 
+ 	if (online_fw_attr != cap.capabilities) {
+ 		bsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] =
+ 		    EXT_STATUS_INVALID_PARAM;
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (cap.outage_duration < MAX_LOOP_TIMEOUT)  {
+ 		bsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] =
+ 		    EXT_STATUS_INVALID_PARAM;
+ 		return -EINVAL;
+ 	}
+ 
+ 	bsg_job->reply->reply_payload_rcv_len = 0;
+ 
+ 	bsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] =
+ 	    EXT_STATUS_OK;
+ 
+ 	bsg_job->reply_len = sizeof(struct fc_bsg_reply);
+ 	bsg_job->reply->result = DID_OK << 16;
+ 	bsg_job->job_done(bsg_job);
+ 	return 0;
+ }
+ 
+ static int
+ qla27xx_get_bbcr_data(struct fc_bsg_job *bsg_job)
+ {
+ 	struct Scsi_Host *host = bsg_job->shost;
+ 	scsi_qla_host_t *vha = shost_priv(host);
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct qla_bbcr_data bbcr;
+ 	uint16_t loop_id, topo, sw_cap;
+ 	uint8_t domain, area, al_pa, state;
+ 	int rval;
+ 
+ 	if (!(IS_QLA27XX(ha)))
+ 		return -EPERM;
+ 
+ 	memset(&bbcr, 0, sizeof(bbcr));
+ 
+ 	if (vha->flags.bbcr_enable)
+ 		bbcr.status = QLA_BBCR_STATUS_ENABLED;
+ 	else
+ 		bbcr.status = QLA_BBCR_STATUS_DISABLED;
+ 
+ 	if (bbcr.status == QLA_BBCR_STATUS_ENABLED) {
+ 		rval = qla2x00_get_adapter_id(vha, &loop_id, &al_pa,
+ 			&area, &domain, &topo, &sw_cap);
+ 		if (rval != QLA_SUCCESS)
+ 			return -EIO;
+ 
+ 		state = (vha->bbcr >> 12) & 0x1;
+ 
+ 		if (state) {
+ 			bbcr.state = QLA_BBCR_STATE_OFFLINE;
+ 			bbcr.offline_reason_code = QLA_BBCR_REASON_LOGIN_REJECT;
+ 		} else {
+ 			bbcr.state = QLA_BBCR_STATE_ONLINE;
+ 			bbcr.negotiated_bbscn = (vha->bbcr >> 8) & 0xf;
+ 		}
+ 
+ 		bbcr.configured_bbscn = vha->bbcr & 0xf;
+ 	}
+ 
+ 	sg_copy_from_buffer(bsg_job->reply_payload.sg_list,
+ 		bsg_job->reply_payload.sg_cnt, &bbcr, sizeof(bbcr));
+ 	bsg_job->reply->reply_payload_rcv_len = sizeof(bbcr);
+ 
+ 	bsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] = EXT_STATUS_OK;
+ 
+ 	bsg_job->reply_len = sizeof(struct fc_bsg_reply);
+ 	bsg_job->reply->result = DID_OK << 16;
+ 	bsg_job->job_done(bsg_job);
+ 	return 0;
+ }
+ 
+ static int
++>>>>>>> 969a619966d8 (qla2xxx: Add support for buffer to buffer credit value for ISP27XX.)
  qla2x00_process_vendor_specific(struct fc_bsg_job *bsg_job)
  {
  	switch (bsg_job->request->rqst_data.h_vendor.vendor_cmd[0]) {
@@@ -2164,6 -2287,15 +2293,18 @@@
  	case QL_VND_SERDES_OP_EX:
  		return qla8044_serdes_op(bsg_job);
  
++<<<<<<< HEAD
++=======
+ 	case QL_VND_GET_FLASH_UPDATE_CAPS:
+ 		return qla27xx_get_flash_upd_cap(bsg_job);
+ 
+ 	case QL_VND_SET_FLASH_UPDATE_CAPS:
+ 		return qla27xx_set_flash_upd_cap(bsg_job);
+ 
+ 	case QL_VND_GET_BBCR_DATA:
+ 		return qla27xx_get_bbcr_data(bsg_job);
+ 
++>>>>>>> 969a619966d8 (qla2xxx: Add support for buffer to buffer credit value for ISP27XX.)
  	default:
  		return -ENOSYS;
  	}
diff --cc drivers/scsi/qla2xxx/qla_bsg.h
index d38f9efa56fa,42751776f363..000000000000
--- a/drivers/scsi/qla2xxx/qla_bsg.h
+++ b/drivers/scsi/qla2xxx/qla_bsg.h
@@@ -25,6 -25,9 +25,12 @@@
  #define QL_VND_FX00_MGMT_CMD	0x12
  #define QL_VND_SERDES_OP	0x13
  #define	QL_VND_SERDES_OP_EX	0x14
++<<<<<<< HEAD
++=======
+ #define QL_VND_GET_FLASH_UPDATE_CAPS    0x15
+ #define QL_VND_SET_FLASH_UPDATE_CAPS    0x16
+ #define QL_VND_GET_BBCR_DATA    0x17
++>>>>>>> 969a619966d8 (qla2xxx: Add support for buffer to buffer credit value for ISP27XX.)
  
  /* BSG Vendor specific subcode returns */
  #define EXT_STATUS_OK			0
@@@ -232,4 -235,32 +238,35 @@@ struct qla_serdes_reg_ex 
  	uint32_t val;
  } __packed;
  
++<<<<<<< HEAD
++=======
+ struct qla_flash_update_caps {
+ 	uint64_t  capabilities;
+ 	uint32_t  outage_duration;
+ 	uint8_t   reserved[20];
+ } __packed;
+ 
+ /* BB_CR Status */
+ #define QLA_BBCR_STATUS_DISABLED       0
+ #define QLA_BBCR_STATUS_ENABLED        1
+ 
+ /* BB_CR State */
+ #define QLA_BBCR_STATE_OFFLINE         0
+ #define QLA_BBCR_STATE_ONLINE          1
+ 
+ /* BB_CR Offline Reason Code */
+ #define QLA_BBCR_REASON_PORT_SPEED     1
+ #define QLA_BBCR_REASON_PEER_PORT      2
+ #define QLA_BBCR_REASON_SWITCH         3
+ #define QLA_BBCR_REASON_LOGIN_REJECT   4
+ 
+ struct  qla_bbcr_data {
+ 	uint8_t   status;         /* 1 - enabled, 0 - Disabled */
+ 	uint8_t   state;          /* 1 - online, 0 - offline */
+ 	uint8_t   configured_bbscn;       /* 0-15 */
+ 	uint8_t   negotiated_bbscn;       /* 0-15 */
+ 	uint8_t   offline_reason_code;
+ 	uint8_t   reserved[11];
+ } __packed;
++>>>>>>> 969a619966d8 (qla2xxx: Add support for buffer to buffer credit value for ISP27XX.)
  #endif
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 03748dc366c8,c4bd62ade713..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -3581,8 -3715,20 +3582,13 @@@ typedef struct scsi_qla_host 
  
  	atomic_t	vref_count;
  	struct qla8044_reset_template reset_tmplt;
++<<<<<<< HEAD
++=======
+ 	struct qla_tgt_counters tgt_counters;
+ 	uint16_t	bbcr;
++>>>>>>> 969a619966d8 (qla2xxx: Add support for buffer to buffer credit value for ISP27XX.)
  } scsi_qla_host_t;
  
 -struct qla27xx_image_status {
 -	uint8_t image_status_mask;
 -	uint16_t generation_number;
 -	uint8_t reserved[3];
 -	uint8_t ver_minor;
 -	uint8_t ver_major;
 -	uint32_t checksum;
 -	uint32_t signature;
 -} __packed;
 -
  #define SET_VP_IDX	1
  #define SET_AL_PA	2
  #define RESET_VP_IDX	3
* Unmerged path drivers/scsi/qla2xxx/qla_bsg.c
* Unmerged path drivers/scsi/qla2xxx/qla_bsg.h
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
diff --git a/drivers/scsi/qla2xxx/qla_fw.h b/drivers/scsi/qla2xxx/qla_fw.h
index 42bb357bf56b..6fc15ab1fde5 100644
--- a/drivers/scsi/qla2xxx/qla_fw.h
+++ b/drivers/scsi/qla2xxx/qla_fw.h
@@ -1288,7 +1288,9 @@ struct vp_rpt_id_entry_24xx {
 
 	uint8_t vp_idx_map[16];
 
-	uint8_t reserved_4[32];
+	uint8_t reserved_4[28];
+	uint16_t bbcr;
+	uint8_t reserved_5[6];
 };
 
 #define VF_EVFP_IOCB_TYPE       0x26    /* Exchange Virtual Fabric Parameters entry. */
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index 8b15a8c6f98d..5334c3ed3acb 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -1112,6 +1112,8 @@ qla2x00_get_adapter_id(scsi_qla_host_t *vha, uint16_t *id, uint8_t *al_pa,
 		mcp->in_mb |= MBX_13|MBX_12|MBX_11|MBX_10;
 	if (IS_FWI2_CAPABLE(vha->hw))
 		mcp->in_mb |= MBX_19|MBX_18|MBX_17|MBX_16;
+	if (IS_QLA27XX(vha->hw))
+		mcp->in_mb |= MBX_15;
 	mcp->tov = MBX_TOV_SECONDS;
 	mcp->flags = 0;
 	rval = qla2x00_mailbox_command(vha, mcp);
@@ -1163,6 +1165,9 @@ qla2x00_get_adapter_id(scsi_qla_host_t *vha, uint16_t *id, uint8_t *al_pa,
 				    wwn_to_u64(vha->port_name));
 			}
 		}
+
+		if (IS_QLA27XX(vha->hw))
+			vha->bbcr = mcp->mb[15];
 	}
 
 	return rval;
@@ -3383,6 +3388,9 @@ qla24xx_report_id_acquisition(scsi_qla_host_t *vha,
 		    rptid_entry->port_id[2], rptid_entry->port_id[1],
 		    rptid_entry->port_id[0]);
 
+		/* buffer to buffer credit flag */
+		vha->flags.bbcr_enable = (rptid_entry->bbcr & 0xf) != 0;
+
 		/* FA-WWN is only for physical port */
 		if (!vp_idx) {
 			void *wwpn = ha->init_cb->port_name;
