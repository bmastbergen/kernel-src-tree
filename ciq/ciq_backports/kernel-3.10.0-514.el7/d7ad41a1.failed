zram: clear disk io accounting when reset zram device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Weijie Yang <weijie.yang@samsung.com>
commit d7ad41a1c498729b7584c257710b1b437a0c1470
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d7ad41a1.failed

Clear zram disk io accounting when resetting the zram device.  Otherwise
the residual io accounting stat will affect the diskstat in the next
zram active cycle.

	Signed-off-by: Weijie Yang <weijie.yang@samsung.com>
	Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
	Acked-by: Minchan Kim <minchan@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit d7ad41a1c498729b7584c257710b1b437a0c1470)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/zram/zram_drv.c
diff --cc drivers/block/zram/zram_drv.c
index 54a954327e19,6e134f4759c0..000000000000
--- a/drivers/block/zram/zram_drv.c
+++ b/drivers/block/zram/zram_drv.c
@@@ -681,26 -786,33 +681,33 @@@ static void zram_reset_device(struct zr
  		return;
  	}
  
 -	meta = zram->meta;
 -	comp = zram->comp;
 -	disksize = zram->disksize;
 -	/*
 -	 * Refcount will go down to 0 eventually and r/w handler
 -	 * cannot handle further I/O so it will bail out by
 -	 * check zram_meta_get.
 -	 */
 -	zram_meta_put(zram);
 -	/*
 -	 * We want to free zram_meta in process context to avoid
 -	 * deadlock between reclaim path and any other locks.
 -	 */
 -	wait_event(zram->io_done, atomic_read(&zram->refcount) == 0);
 -
 +	zcomp_destroy(zram->comp);
 +	zram->max_comp_streams = 1;
 +	zram_meta_free(zram->meta, zram->disksize);
 +	zram->meta = NULL;
  	/* Reset stats */
  	memset(&zram->stats, 0, sizeof(zram->stats));
 +
  	zram->disksize = 0;
++<<<<<<< HEAD
 +	if (reset_capacity)
 +		set_capacity(zram->disk, 0);
++=======
+ 	zram->max_comp_streams = 1;
+ 
+ 	set_capacity(zram->disk, 0);
+ 	part_stat_set_all(&zram->disk->part0, 0);
++>>>>>>> d7ad41a1c498 (zram: clear disk io accounting when reset zram device)
  
  	up_write(&zram->init_lock);
 -	/* I/O operation under all of CPU are done so let's free */
 -	zram_meta_free(meta, disksize);
 -	zcomp_destroy(comp);
 +
 +	/*
 +	 * Revalidate disk out of the init_lock to avoid lockdep splat.
 +	 * It's okay because disk's capacity is protected by init_lock
 +	 * so that revalidate_disk always sees up-to-date capacity.
 +	 */
 +	if (reset_capacity)
 +		revalidate_disk(zram->disk);
  }
  
  static ssize_t disksize_store(struct device *dev,
* Unmerged path drivers/block/zram/zram_drv.c
