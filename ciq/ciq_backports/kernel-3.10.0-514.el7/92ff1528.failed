zram: return zram device_id from zram_add()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
commit 92ff15288747b80730f0132e9c98403370c27b34
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/92ff1528.failed

This patch prepares zram to enable on-demand device creation.
zram_add() performs automatic device_id assignment and returns
new device id (>= 0) or error code (< 0).

	Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
	Acked-by: Minchan Kim <minchan@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 92ff15288747b80730f0132e9c98403370c27b34)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/zram/zram_drv.c
diff --cc drivers/block/zram/zram_drv.c
index f4772ab5159f,a52a8191bb91..000000000000
--- a/drivers/block/zram/zram_drv.c
+++ b/drivers/block/zram/zram_drv.c
@@@ -945,9 -1153,24 +945,30 @@@ static struct attribute_group zram_disk
  	.attrs = zram_disk_attrs,
  };
  
++<<<<<<< HEAD
 +static int create_device(struct zram *zram, int device_id)
 +{
 +	int ret = -ENOMEM;
++=======
+ /*
+  * Allocate and initialize new zram device. the function returns
+  * '>= 0' device_id upon success, and negative value otherwise.
+  */
+ static int zram_add(void)
+ {
+ 	struct zram *zram;
+ 	struct request_queue *queue;
+ 	int ret, device_id;
+ 
+ 	zram = kzalloc(sizeof(struct zram), GFP_KERNEL);
+ 	if (!zram)
+ 		return -ENOMEM;
+ 
+ 	ret = idr_alloc(&zram_index_idr, zram, 0, 0, GFP_KERNEL);
+ 	if (ret < 0)
+ 		goto out_free_dev;
+ 	device_id = ret;
++>>>>>>> 92ff15288747 (zram: return zram device_id from zram_add())
  
  	init_rwsem(&zram->init_lock);
  
@@@ -1002,7 -1242,9 +1023,13 @@@
  	strlcpy(zram->compressor, default_compressor, sizeof(zram->compressor));
  	zram->meta = NULL;
  	zram->max_comp_streams = 1;
++<<<<<<< HEAD
 +	return 0;
++=======
+ 
+ 	pr_info("Added device: %s\n", zram->disk->disk_name);
+ 	return device_id;
++>>>>>>> 92ff15288747 (zram: return zram device_id from zram_add())
  
  out_free_disk:
  	del_gendisk(zram->disk);
@@@ -1026,46 -1291,25 +1053,54 @@@ static void destroy_device(struct zram 
  
  static int __init zram_init(void)
  {
- 	int ret, dev_id;
+ 	int ret;
  
 +	if (num_devices > max_num_devices) {
 +		pr_warn("Invalid value for num_devices: %u\n",
 +				num_devices);
 +		ret = -EINVAL;
 +		goto out;
 +	}
 +
  	zram_major = register_blkdev(0, "zram");
  	if (zram_major <= 0) {
  		pr_warn("Unable to get major number\n");
 -		return -EBUSY;
 +		ret = -EBUSY;
 +		goto out;
  	}
  
 +	/* Allocate the device array and initialize each one */
 +	zram_devices = kzalloc(num_devices * sizeof(struct zram), GFP_KERNEL);
 +	if (!zram_devices) {
 +		ret = -ENOMEM;
 +		goto unregister;
 +	}
 +
++<<<<<<< HEAD
 +	for (dev_id = 0; dev_id < num_devices; dev_id++) {
 +		ret = create_device(&zram_devices[dev_id], dev_id);
 +		if (ret)
 +			goto free_devices;
++=======
+ 	while (num_devices != 0) {
+ 		ret = zram_add();
+ 		if (ret < 0)
+ 			goto out_error;
+ 		num_devices--;
++>>>>>>> 92ff15288747 (zram: return zram device_id from zram_add())
  	}
  
 +	pr_info("Created %u device(s) ...\n", num_devices);
 +
  	return 0;
  
 -out_error:
 -	destroy_devices();
 +free_devices:
 +	while (dev_id)
 +		destroy_device(&zram_devices[--dev_id]);
 +	kfree(zram_devices);
 +unregister:
 +	unregister_blkdev(zram_major, "zram");
 +out:
  	return ret;
  }
  
* Unmerged path drivers/block/zram/zram_drv.c
