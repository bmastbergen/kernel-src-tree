KVM: x86: don't notify userspace IOAPIC on edge EOI

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit 13db77347db175a68edd58a79963cdf5cb3a9607
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/13db7734.failed

On real hardware, edge-triggered interrupts don't set a bit in TMR,
which means that IOAPIC isn't notified on EOI.  Do the same here.

Staying in guest/kernel mode after edge EOI is what we want for most
devices.  If some bugs could be nicely worked around with edge EOI
notifications, we should invest in a better interface.

	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 13db77347db175a68edd58a79963cdf5cb3a9607)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/irq_comm.c
diff --cc arch/x86/kvm/irq_comm.c
index c5bb82b0cf6b,8f4499c7ffc1..000000000000
--- a/arch/x86/kvm/irq_comm.c
+++ b/arch/x86/kvm/irq_comm.c
@@@ -327,3 -356,54 +327,57 @@@ int kvm_setup_default_irq_routing(struc
  	return kvm_set_irq_routing(kvm, default_routing,
  				   ARRAY_SIZE(default_routing), 0);
  }
++<<<<<<< HEAD
++=======
+ 
+ static const struct kvm_irq_routing_entry empty_routing[] = {};
+ 
+ int kvm_setup_empty_irq_routing(struct kvm *kvm)
+ {
+ 	return kvm_set_irq_routing(kvm, empty_routing, 0, 0);
+ }
+ 
+ void kvm_arch_irq_routing_update(struct kvm *kvm)
+ {
+ 	if (ioapic_in_kernel(kvm) || !irqchip_in_kernel(kvm))
+ 		return;
+ 	kvm_make_scan_ioapic_request(kvm);
+ }
+ 
+ void kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
+ {
+ 	struct kvm *kvm = vcpu->kvm;
+ 	struct kvm_kernel_irq_routing_entry *entry;
+ 	struct kvm_irq_routing_table *table;
+ 	u32 i, nr_ioapic_pins;
+ 	int idx;
+ 
+ 	/* kvm->irq_routing must be read after clearing
+ 	 * KVM_SCAN_IOAPIC. */
+ 	smp_mb();
+ 	idx = srcu_read_lock(&kvm->irq_srcu);
+ 	table = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+ 	nr_ioapic_pins = min_t(u32, table->nr_rt_entries,
+ 			       kvm->arch.nr_reserved_ioapic_pins);
+ 	for (i = 0; i < nr_ioapic_pins; ++i) {
+ 		hlist_for_each_entry(entry, &table->map[i], link) {
+ 			u32 dest_id, dest_mode;
+ 			bool level;
+ 
+ 			if (entry->type != KVM_IRQ_ROUTING_MSI)
+ 				continue;
+ 			dest_id = (entry->msi.address_lo >> 12) & 0xff;
+ 			dest_mode = (entry->msi.address_lo >> 2) & 0x1;
+ 			level = entry->msi.data & MSI_DATA_TRIGGER_LEVEL;
+ 			if (level && kvm_apic_match_dest(vcpu, NULL, 0,
+ 						dest_id, dest_mode)) {
+ 				u32 vector = entry->msi.data & 0xff;
+ 
+ 				__set_bit(vector,
+ 					  (unsigned long *) eoi_exit_bitmap);
+ 			}
+ 		}
+ 	}
+ 	srcu_read_unlock(&kvm->irq_srcu, idx);
+ }
++>>>>>>> 13db77347db1 (KVM: x86: don't notify userspace IOAPIC on edge EOI)
* Unmerged path arch/x86/kvm/irq_comm.c
