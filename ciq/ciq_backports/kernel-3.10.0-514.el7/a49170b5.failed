ACPI: Return translation offset when parsing ACPI address space resources

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiang Liu <jiang.liu@linux.intel.com>
commit a49170b552423a3e85fc4f0d778c707402ee4863
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a49170b5.failed

Change function acpi_dev_resource_address_space() and
acpi_dev_resource_ext_address_space() to return address space
translation offset.

It's based on a patch from Yinghai Lu <yinghai@kernel.org>.

	Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit a49170b552423a3e85fc4f0d778c707402ee4863)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/resource.c
diff --cc drivers/acpi/resource.c
index 75d12a1b01ad,c902c8eece81..000000000000
--- a/drivers/acpi/resource.c
+++ b/drivers/acpi/resource.c
@@@ -171,6 -184,52 +171,55 @@@ bool acpi_dev_resource_io(struct acpi_r
  }
  EXPORT_SYMBOL_GPL(acpi_dev_resource_io);
  
++<<<<<<< HEAD
++=======
+ static bool acpi_decode_space(struct resource_win *win,
+ 			      struct acpi_resource_address *addr,
+ 			      struct acpi_address64_attribute *attr)
+ {
+ 	u8 iodec = attr->granularity == 0xfff ? ACPI_DECODE_10 : ACPI_DECODE_16;
+ 	bool wp = addr->info.mem.write_protect;
+ 	u64 len = attr->address_length;
+ 	struct resource *res = &win->res;
+ 
+ 	/*
+ 	 * Filter out invalid descriptor according to ACPI Spec 5.0, section
+ 	 * 6.4.3.5 Address Space Resource Descriptors.
+ 	 */
+ 	if ((addr->min_address_fixed != addr->max_address_fixed && len) ||
+ 	    (addr->min_address_fixed && addr->max_address_fixed && !len))
+ 		pr_debug("ACPI: Invalid address space min_addr_fix %d, max_addr_fix %d, len %llx\n",
+ 			 addr->min_address_fixed, addr->max_address_fixed, len);
+ 
+ 	res->start = attr->minimum;
+ 	res->end = attr->maximum;
+ 
+ 	switch (addr->resource_type) {
+ 	case ACPI_MEMORY_RANGE:
+ 		acpi_dev_memresource_flags(res, len, wp);
+ 		break;
+ 	case ACPI_IO_RANGE:
+ 		acpi_dev_ioresource_flags(res, len, iodec);
+ 		break;
+ 	case ACPI_BUS_NUMBER_RANGE:
+ 		res->flags = IORESOURCE_BUS;
+ 		break;
+ 	default:
+ 		return false;
+ 	}
+ 
+ 	win->offset = attr->translation_offset;
+ 
+ 	if (addr->producer_consumer == ACPI_PRODUCER)
+ 		res->flags |= IORESOURCE_WINDOW;
+ 
+ 	if (addr->info.mem.caching == ACPI_PREFETCHABLE_MEMORY)
+ 		res->flags |= IORESOURCE_PREFETCH;
+ 
+ 	return !(res->flags & IORESOURCE_DISABLED);
+ }
+ 
++>>>>>>> a49170b55242 (ACPI: Return translation offset when parsing ACPI address space resources)
  /**
   * acpi_dev_resource_address_space - Extract ACPI address space information.
   * @ares: Input ACPI resource object.
@@@ -178,47 -237,25 +227,66 @@@
   *
   * Check if the given ACPI resource object represents an address space resource
   * and if that's the case, use the information in it to populate the generic
++<<<<<<< HEAD
 + * resource object pointed to by @res.
++=======
+  * resource object pointed to by @win.
+  *
+  * Return:
+  * 1) false with win->res.flags setting to zero: not the expected resource type
+  * 2) false with IORESOURCE_DISABLED in win->res.flags: valid unassigned
+  *    resource
+  * 3) true: valid assigned resource
++>>>>>>> a49170b55242 (ACPI: Return translation offset when parsing ACPI address space resources)
   */
  bool acpi_dev_resource_address_space(struct acpi_resource *ares,
- 				     struct resource *res)
+ 				     struct resource_win *win)
  {
 +	acpi_status status;
  	struct acpi_resource_address64 addr;
 +	bool window;
 +	u64 len;
 +	u8 io_decode;
  
++<<<<<<< HEAD
 +	status = acpi_resource_to_address64(ares, &addr);
 +	if (ACPI_FAILURE(status))
 +		return false;
 +
 +	res->start = addr.minimum;
 +	res->end = addr.maximum;
 +	window = addr.producer_consumer == ACPI_PRODUCER;
 +
 +	switch(addr.resource_type) {
 +	case ACPI_MEMORY_RANGE:
 +		len = addr.maximum - addr.minimum + 1;
 +		res->flags = acpi_dev_memresource_flags(len,
 +						addr.info.mem.write_protect,
 +						window);
 +		break;
 +	case ACPI_IO_RANGE:
 +		io_decode = addr.granularity == 0xfff ?
 +				ACPI_DECODE_10 : ACPI_DECODE_16;
 +		res->flags = acpi_dev_ioresource_flags(addr.minimum,
 +						       addr.maximum,
 +						       io_decode, window);
 +		break;
 +	case ACPI_BUS_NUMBER_RANGE:
 +		res->flags = IORESOURCE_BUS;
 +		break;
 +	default:
 +		return false;
 +	}
 +
 +	return !(res->flags & IORESOURCE_DISABLED);
++=======
+ 	win->res.flags = 0;
+ 	if (ACPI_FAILURE(acpi_resource_to_address64(ares, &addr)))
+ 		return false;
+ 
+ 	return acpi_decode_space(win, (struct acpi_resource_address *)&addr,
+ 				 &addr.address);
++>>>>>>> a49170b55242 (ACPI: Return translation offset when parsing ACPI address space resources)
  }
  EXPORT_SYMBOL_GPL(acpi_dev_resource_address_space);
  
@@@ -229,47 -266,27 +297,66 @@@
   *
   * Check if the given ACPI resource object represents an extended address space
   * resource and if that's the case, use the information in it to populate the
++<<<<<<< HEAD
 + * generic resource object pointed to by @res.
++=======
+  * generic resource object pointed to by @win.
+  *
+  * Return:
+  * 1) false with win->res.flags setting to zero: not the expected resource type
+  * 2) false with IORESOURCE_DISABLED in win->res.flags: valid unassigned
+  *    resource
+  * 3) true: valid assigned resource
++>>>>>>> a49170b55242 (ACPI: Return translation offset when parsing ACPI address space resources)
   */
  bool acpi_dev_resource_ext_address_space(struct acpi_resource *ares,
- 					 struct resource *res)
+ 					 struct resource_win *win)
  {
  	struct acpi_resource_extended_address64 *ext_addr;
 +	bool window;
 +	u64 len;
 +	u8 io_decode;
  
++<<<<<<< HEAD
++=======
+ 	win->res.flags = 0;
++>>>>>>> a49170b55242 (ACPI: Return translation offset when parsing ACPI address space resources)
  	if (ares->type != ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64)
  		return false;
  
  	ext_addr = &ares->data.ext_address64;
  
++<<<<<<< HEAD
 +	res->start = ext_addr->minimum;
 +	res->end = ext_addr->maximum;
 +	window = ext_addr->producer_consumer == ACPI_PRODUCER;
 +
 +	switch(ext_addr->resource_type) {
 +	case ACPI_MEMORY_RANGE:
 +		len = ext_addr->maximum - ext_addr->minimum + 1;
 +		res->flags = acpi_dev_memresource_flags(len,
 +					ext_addr->info.mem.write_protect,
 +					window);
 +		break;
 +	case ACPI_IO_RANGE:
 +		io_decode = ext_addr->granularity == 0xfff ?
 +				ACPI_DECODE_10 : ACPI_DECODE_16;
 +		res->flags = acpi_dev_ioresource_flags(ext_addr->minimum,
 +						       ext_addr->maximum,
 +						       io_decode, window);
 +		break;
 +	case ACPI_BUS_NUMBER_RANGE:
 +		res->flags = IORESOURCE_BUS;
 +		break;
 +	default:
 +		return false;
 +	}
 +
 +	return !(res->flags & IORESOURCE_DISABLED);
++=======
+ 	return acpi_decode_space(win, (struct acpi_resource_address *)ext_addr,
+ 				 &ext_addr->address);
++>>>>>>> a49170b55242 (ACPI: Return translation offset when parsing ACPI address space resources)
  }
  EXPORT_SYMBOL_GPL(acpi_dev_resource_ext_address_space);
  
* Unmerged path drivers/acpi/resource.c
diff --git a/drivers/pnp/pnpacpi/rsparser.c b/drivers/pnp/pnpacpi/rsparser.c
index 66977ebf13b3..fadc7eb3bac9 100644
--- a/drivers/pnp/pnpacpi/rsparser.c
+++ b/drivers/pnp/pnpacpi/rsparser.c
@@ -180,20 +180,21 @@ static acpi_status pnpacpi_allocated_resource(struct acpi_resource *res,
 	struct pnp_dev *dev = data;
 	struct acpi_resource_dma *dma;
 	struct acpi_resource_vendor_typed *vendor_typed;
-	struct resource r = {0};
+	struct resource_win win = {{0}, 0};
+	struct resource *r = &win.res;
 	int i, flags;
 
-	if (acpi_dev_resource_address_space(res, &r)
-	    || acpi_dev_resource_ext_address_space(res, &r)) {
-		pnp_add_resource(dev, &r);
+	if (acpi_dev_resource_address_space(res, &win)
+	    || acpi_dev_resource_ext_address_space(res, &win)) {
+		pnp_add_resource(dev, &win.res);
 		return AE_OK;
 	}
 
-	r.flags = 0;
-	if (acpi_dev_resource_interrupt(res, 0, &r)) {
-		pnpacpi_add_irqresource(dev, &r);
-		for (i = 1; acpi_dev_resource_interrupt(res, i, &r); i++)
-			pnpacpi_add_irqresource(dev, &r);
+	r->flags = 0;
+	if (acpi_dev_resource_interrupt(res, 0, r)) {
+		pnpacpi_add_irqresource(dev, r);
+		for (i = 1; acpi_dev_resource_interrupt(res, i, r); i++)
+			pnpacpi_add_irqresource(dev, r);
 
 		if (i > 1) {
 			/*
@@ -209,7 +210,7 @@ static acpi_status pnpacpi_allocated_resource(struct acpi_resource *res,
 			}
 		}
 		return AE_OK;
-	} else if (r.flags & IORESOURCE_DISABLED) {
+	} else if (r->flags & IORESOURCE_DISABLED) {
 		pnp_add_irq_resource(dev, 0, IORESOURCE_DISABLED);
 		return AE_OK;
 	}
@@ -218,13 +219,13 @@ static acpi_status pnpacpi_allocated_resource(struct acpi_resource *res,
 	case ACPI_RESOURCE_TYPE_MEMORY24:
 	case ACPI_RESOURCE_TYPE_MEMORY32:
 	case ACPI_RESOURCE_TYPE_FIXED_MEMORY32:
-		if (acpi_dev_resource_memory(res, &r))
-			pnp_add_resource(dev, &r);
+		if (acpi_dev_resource_memory(res, r))
+			pnp_add_resource(dev, r);
 		break;
 	case ACPI_RESOURCE_TYPE_IO:
 	case ACPI_RESOURCE_TYPE_FIXED_IO:
-		if (acpi_dev_resource_io(res, &r))
-			pnp_add_resource(dev, &r);
+		if (acpi_dev_resource_io(res, r))
+			pnp_add_resource(dev, r);
 		break;
 	case ACPI_RESOURCE_TYPE_DMA:
 		dma = &res->data.dma;
diff --git a/include/linux/acpi.h b/include/linux/acpi.h
index b96328fc524b..d3a84e02b86f 100644
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@ -268,12 +268,17 @@ extern int pnpacpi_disabled;
 
 #define PXM_INVAL	(-1)
 
+struct resource_win {
+	struct resource res;
+	resource_size_t offset;
+};
+
 bool acpi_dev_resource_memory(struct acpi_resource *ares, struct resource *res);
 bool acpi_dev_resource_io(struct acpi_resource *ares, struct resource *res);
 bool acpi_dev_resource_address_space(struct acpi_resource *ares,
-				     struct resource *res);
+				     struct resource_win *win);
 bool acpi_dev_resource_ext_address_space(struct acpi_resource *ares,
-					 struct resource *res);
+					 struct resource_win *win);
 unsigned long acpi_dev_irq_flags(u8 triggering, u8 polarity, u8 shareable);
 bool acpi_dev_resource_interrupt(struct acpi_resource *ares, int index,
 				 struct resource *res);
