timekeeping: Use tk_read_base as argument for timekeeping_get_ns()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 0e5ac3a8b100469ea154f87dd57b685fbdd356f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0e5ac3a8.failed

All the function needs is in the tk_read_base struct. No functional
change for the current code, just a preparatory patch for the NMI safe
accessor to clock monotonic which will use struct tk_read_base as well.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
	Signed-off-by: John Stultz <john.stultz@linaro.org>
(cherry picked from commit 0e5ac3a8b100469ea154f87dd57b685fbdd356f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/timekeeping.c
diff --cc kernel/time/timekeeping.c
index 7251ed9665bf,dee23c9d6c21..000000000000
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@@ -153,36 -167,28 +153,46 @@@ static void tk_setup_internals(struct t
  /* Timekeeper helper functions. */
  
  #ifdef CONFIG_ARCH_USES_GETTIMEOFFSET
 -static u32 default_arch_gettimeoffset(void) { return 0; }
 -u32 (*arch_gettimeoffset)(void) = default_arch_gettimeoffset;
 +u32 (*arch_gettimeoffset)(void);
 +
 +u32 get_arch_timeoffset(void)
 +{
 +	if (likely(arch_gettimeoffset))
 +		return arch_gettimeoffset();
 +	return 0;
 +}
  #else
 -static inline u32 arch_gettimeoffset(void) { return 0; }
 +static inline u32 get_arch_timeoffset(void) { return 0; }
  #endif
  
- static inline s64 timekeeping_get_ns(struct timekeeper *tk)
+ static inline s64 timekeeping_get_ns(struct tk_read_base *tkr)
  {
  	cycle_t cycle_now, delta;
 +	struct clocksource *clock;
  	s64 nsec;
  
  	/* read clocksource: */
++<<<<<<< HEAD
 +	clock = tk->clock;
 +	cycle_now = clock->read(clock);
 +
 +	/* calculate the delta since the last update_wall_time: */
 +	delta = clocksource_delta(cycle_now, clock->cycle_last, clock->mask);
 +
 +	nsec = delta * tk->mult + tk->xtime_nsec;
 +	nsec >>= tk->shift;
++=======
+ 	cycle_now = tkr->read(tkr->clock);
+ 
+ 	/* calculate the delta since the last update_wall_time: */
+ 	delta = clocksource_delta(cycle_now, tkr->cycle_last, tkr->mask);
+ 
+ 	nsec = delta * tkr->mult + tkr->xtime_nsec;
+ 	nsec >>= tkr->shift;
++>>>>>>> 0e5ac3a8b100 (timekeeping: Use tk_read_base as argument for timekeeping_get_ns())
  
  	/* If arch requires, add in get_arch_timeoffset() */
 -	return nsec + arch_gettimeoffset();
 +	return nsec + get_arch_timeoffset();
  }
  
  static inline s64 timekeeping_get_ns_raw(struct timekeeper *tk)
@@@ -342,12 -369,12 +352,12 @@@ int __getnstimeofday64(struct timespec6
  	s64 nsecs = 0;
  
  	do {
 -		seq = read_seqcount_begin(&tk_core.seq);
 +		seq = read_seqcount_begin(&timekeeper_seq);
  
  		ts->tv_sec = tk->xtime_sec;
- 		nsecs = timekeeping_get_ns(tk);
+ 		nsecs = timekeeping_get_ns(&tk->tkr);
  
 -	} while (read_seqcount_retry(&tk_core.seq, seq));
 +	} while (read_seqcount_retry(&timekeeper_seq, seq));
  
  	ts->tv_nsec = 0;
  	timespec64_add_ns(ts, nsecs);
@@@ -383,19 -411,84 +393,96 @@@ ktime_t ktime_get(void
  	WARN_ON(timekeeping_suspended);
  
  	do {
++<<<<<<< HEAD
 +		seq = read_seqcount_begin(&timekeeper_seq);
 +		secs = tk->xtime_sec + tk->wall_to_monotonic.tv_sec;
 +		nsecs = timekeeping_get_ns(tk) + tk->wall_to_monotonic.tv_nsec;
++=======
+ 		seq = read_seqcount_begin(&tk_core.seq);
+ 		base = tk->tkr.base_mono;
+ 		nsecs = timekeeping_get_ns(&tk->tkr);
++>>>>>>> 0e5ac3a8b100 (timekeeping: Use tk_read_base as argument for timekeeping_get_ns())
  
 -	} while (read_seqcount_retry(&tk_core.seq, seq));
 -
 -	return ktime_add_ns(base, nsecs);
 +	} while (read_seqcount_retry(&timekeeper_seq, seq));
 +	/*
 +	 * Use ktime_set/ktime_add_ns to create a proper ktime on
 +	 * 32-bit architectures without CONFIG_KTIME_SCALAR.
 +	 */
 +	return ktime_add_ns(ktime_set(secs, 0), nsecs);
  }
  EXPORT_SYMBOL_GPL(ktime_get);
  
++<<<<<<< HEAD
++=======
+ static ktime_t *offsets[TK_OFFS_MAX] = {
+ 	[TK_OFFS_REAL]	= &tk_core.timekeeper.offs_real,
+ 	[TK_OFFS_BOOT]	= &tk_core.timekeeper.offs_boot,
+ 	[TK_OFFS_TAI]	= &tk_core.timekeeper.offs_tai,
+ };
+ 
+ ktime_t ktime_get_with_offset(enum tk_offsets offs)
+ {
+ 	struct timekeeper *tk = &tk_core.timekeeper;
+ 	unsigned int seq;
+ 	ktime_t base, *offset = offsets[offs];
+ 	s64 nsecs;
+ 
+ 	WARN_ON(timekeeping_suspended);
+ 
+ 	do {
+ 		seq = read_seqcount_begin(&tk_core.seq);
+ 		base = ktime_add(tk->tkr.base_mono, *offset);
+ 		nsecs = timekeeping_get_ns(&tk->tkr);
+ 
+ 	} while (read_seqcount_retry(&tk_core.seq, seq));
+ 
+ 	return ktime_add_ns(base, nsecs);
+ 
+ }
+ EXPORT_SYMBOL_GPL(ktime_get_with_offset);
+ 
+ /**
+  * ktime_mono_to_any() - convert mononotic time to any other time
+  * @tmono:	time to convert.
+  * @offs:	which offset to use
+  */
+ ktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs)
+ {
+ 	ktime_t *offset = offsets[offs];
+ 	unsigned long seq;
+ 	ktime_t tconv;
+ 
+ 	do {
+ 		seq = read_seqcount_begin(&tk_core.seq);
+ 		tconv = ktime_add(tmono, *offset);
+ 	} while (read_seqcount_retry(&tk_core.seq, seq));
+ 
+ 	return tconv;
+ }
+ EXPORT_SYMBOL_GPL(ktime_mono_to_any);
+ 
+ /**
+  * ktime_get_raw - Returns the raw monotonic time in ktime_t format
+  */
+ ktime_t ktime_get_raw(void)
+ {
+ 	struct timekeeper *tk = &tk_core.timekeeper;
+ 	unsigned int seq;
+ 	ktime_t base;
+ 	s64 nsecs;
+ 
+ 	do {
+ 		seq = read_seqcount_begin(&tk_core.seq);
+ 		base = tk->base_raw;
+ 		nsecs = timekeeping_get_ns_raw(tk);
+ 
+ 	} while (read_seqcount_retry(&tk_core.seq, seq));
+ 
+ 	return ktime_add_ns(base, nsecs);
+ }
+ EXPORT_SYMBOL_GPL(ktime_get_raw);
+ 
++>>>>>>> 0e5ac3a8b100 (timekeeping: Use tk_read_base as argument for timekeeping_get_ns())
  /**
   * ktime_get_ts64 - get the monotonic clock in timespec64 format
   * @ts:		pointer to timespec variable
@@@ -414,12 -507,12 +501,12 @@@ void ktime_get_ts64(struct timespec64 *
  	WARN_ON(timekeeping_suspended);
  
  	do {
 -		seq = read_seqcount_begin(&tk_core.seq);
 +		seq = read_seqcount_begin(&timekeeper_seq);
  		ts->tv_sec = tk->xtime_sec;
- 		nsec = timekeeping_get_ns(tk);
+ 		nsec = timekeeping_get_ns(&tk->tkr);
  		tomono = tk->wall_to_monotonic;
  
 -	} while (read_seqcount_retry(&tk_core.seq, seq));
 +	} while (read_seqcount_retry(&timekeeper_seq, seq));
  
  	ts->tv_sec += tomono.tv_sec;
  	ts->tv_nsec = 0;
@@@ -500,9 -547,9 +587,9 @@@ void getnstime_raw_and_real(struct time
  		ts_real->tv_nsec = 0;
  
  		nsecs_raw = timekeeping_get_ns_raw(tk);
- 		nsecs_real = timekeeping_get_ns(tk);
+ 		nsecs_real = timekeeping_get_ns(&tk->tkr);
  
 -	} while (read_seqcount_retry(&tk_core.seq, seq));
 +	} while (read_seqcount_retry(&timekeeper_seq, seq));
  
  	timespec_add_ns(ts_raw, nsecs_raw);
  	timespec_add_ns(ts_real, nsecs_real);
@@@ -1637,45 -1589,51 +1724,50 @@@ ktime_t ktime_get_update_offsets_now(un
  	u64 nsecs;
  
  	do {
 -		seq = read_seqcount_begin(&tk_core.seq);
 +		seq = read_seqcount_begin(&timekeeper_seq);
  
++<<<<<<< HEAD
 +		base = tk->base_mono;
 +		nsecs = timekeeping_get_ns(tk);
 +		base = ktime_add_ns(base, nsecs);
++=======
+ 		base = tk->tkr.base_mono;
 -		nsecs = tk->tkr.xtime_nsec >> tk->tkr.shift;
++		nsecs = timekeeping_get_ns(&tk->tkr);
++>>>>>>> 0e5ac3a8b100 (timekeeping: Use tk_read_base as argument for timekeeping_get_ns())
  
 -		*offs_real = tk->offs_real;
 -		*offs_boot = tk->offs_boot;
 -		*offs_tai = tk->offs_tai;
 -	} while (read_seqcount_retry(&tk_core.seq, seq));
 +		if (*cwsseq != tk->clock_was_set_seq) {
 +			*cwsseq = tk->clock_was_set_seq;
 +			*offs_real = tk->offs_real;
 +			*offs_boot = tk->offs_boot;
 +			*offs_tai = tk->offs_tai;
 +		}
  
 -	return ktime_add_ns(base, nsecs);
 +		/* Handle leapsecond insertion adjustments */
 +		if (unlikely(base.tv64 >= tk->next_leap_ktime.tv64))
 +			*offs_real = ktime_sub(tk->offs_real, ktime_set(1, 0));
 +
 +	} while (read_seqcount_retry(&timekeeper_seq, seq));
 +
 +	return base;
  }
  
 -#ifdef CONFIG_HIGH_RES_TIMERS
  /**
 - * ktime_get_update_offsets_now - hrtimer helper
 - * @offs_real:	pointer to storage for monotonic -> realtime offset
 - * @offs_boot:	pointer to storage for monotonic -> boottime offset
 - * @offs_tai:	pointer to storage for monotonic -> clock tai offset
 - *
 - * Returns current monotonic time and updates the offsets
 - * Called from hrtimer_interrupt() or retrigger_next_event()
 + * ktime_get_monotonic_offset() - get wall_to_monotonic in ktime_t format
   */
 -ktime_t ktime_get_update_offsets_now(ktime_t *offs_real, ktime_t *offs_boot,
 -							ktime_t *offs_tai)
 +ktime_t ktime_get_monotonic_offset(void)
  {
 -	struct timekeeper *tk = &tk_core.timekeeper;
 -	unsigned int seq;
 -	ktime_t base;
 -	u64 nsecs;
 +	struct timekeeper *tk = &timekeeper;
 +	unsigned long seq;
 +	struct timespec64 wtom;
  
  	do {
 -		seq = read_seqcount_begin(&tk_core.seq);
 +		seq = read_seqcount_begin(&timekeeper_seq);
 +		wtom = tk->wall_to_monotonic;
 +	} while (read_seqcount_retry(&timekeeper_seq, seq));
  
 -		base = tk->tkr.base_mono;
 -		nsecs = timekeeping_get_ns(&tk->tkr);
 -
 -		*offs_real = tk->offs_real;
 -		*offs_boot = tk->offs_boot;
 -		*offs_tai = tk->offs_tai;
 -	} while (read_seqcount_retry(&tk_core.seq, seq));
 -
 -	return ktime_add_ns(base, nsecs);
 +	return timespec64_to_ktime(wtom);
  }
 -#endif
 +EXPORT_SYMBOL_GPL(ktime_get_monotonic_offset);
  
  /**
   * do_adjtimex() - Accessor function to NTP __do_adjtimex function
* Unmerged path kernel/time/timekeeping.c
