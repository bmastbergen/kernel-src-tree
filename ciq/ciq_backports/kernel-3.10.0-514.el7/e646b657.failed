ipv6: udp: Do a route lookup and update during release_cb

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit e646b657f6983017783914a951039e323120dc55
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e646b657.failed

This patch adds a release_cb for UDPv6.  It does a route lookup
and updates sk->sk_dst_cache if it is needed.  It picks up the
left-over job from ip6_sk_update_pmtu() if the sk was owned
by user during the pmtu update.

It takes a rcu_read_lock to protect the __sk_dst_get() operations
because another thread may do ip6_dst_store() without taking the
sk lock (e.g. sendmsg).

Fixes: 45e4fd26683c ("ipv6: Only create RTF_CACHE routes after encountering pmtu exception")
	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Reported-by: Wei Wang <weiwan@google.com>
	Cc: Cong Wang <xiyou.wangcong@gmail.com>
	Cc: Eric Dumazet <edumazet@google.com>
	Cc: Wei Wang <weiwan@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e646b657f6983017783914a951039e323120dc55)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ipv6.h
#	net/ipv6/datagram.c
diff --cc include/net/ipv6.h
index 5dca98c3fc9f,1be050ada8c5..000000000000
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@@ -828,11 -957,15 +828,18 @@@ int compat_ipv6_getsockopt(struct sock 
  			   char __user *optval, int __user *optlen);
  
  int ip6_datagram_connect(struct sock *sk, struct sockaddr *addr, int addr_len);
++<<<<<<< HEAD
++=======
+ int ip6_datagram_connect_v6_only(struct sock *sk, struct sockaddr *addr,
+ 				 int addr_len);
+ int ip6_datagram_dst_update(struct sock *sk, bool fix_sk_saddr);
+ void ip6_datagram_release_cb(struct sock *sk);
++>>>>>>> e646b657f698 (ipv6: udp: Do a route lookup and update during release_cb)
  
  int ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len,
 -		    int *addr_len);
 +		   int *addr_len);
  int ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len,
 -		     int *addr_len);
 +		    int *addr_len);
  void ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err, __be16 port,
  		     u32 info, u8 *payload);
  void ipv6_local_error(struct sock *sk, int err, struct flowi6 *fl6, u32 info);
diff --cc net/ipv6/datagram.c
index 88fda1924015,9dd3882fe6bf..000000000000
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@@ -40,18 -40,114 +40,121 @@@ static bool ipv6_mapped_addr_any(const 
  	return ipv6_addr_v4mapped(a) && (a->s6_addr32[3] == 0);
  }
  
++<<<<<<< HEAD
 +int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
++=======
+ static void ip6_datagram_flow_key_init(struct flowi6 *fl6, struct sock *sk)
+ {
+ 	struct inet_sock *inet = inet_sk(sk);
+ 	struct ipv6_pinfo *np = inet6_sk(sk);
+ 
+ 	memset(fl6, 0, sizeof(*fl6));
+ 	fl6->flowi6_proto = sk->sk_protocol;
+ 	fl6->daddr = sk->sk_v6_daddr;
+ 	fl6->saddr = np->saddr;
+ 	fl6->flowi6_oif = sk->sk_bound_dev_if;
+ 	fl6->flowi6_mark = sk->sk_mark;
+ 	fl6->fl6_dport = inet->inet_dport;
+ 	fl6->fl6_sport = inet->inet_sport;
+ 	fl6->flowlabel = np->flow_label;
+ 
+ 	if (!fl6->flowi6_oif)
+ 		fl6->flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;
+ 
+ 	if (!fl6->flowi6_oif && ipv6_addr_is_multicast(&fl6->daddr))
+ 		fl6->flowi6_oif = np->mcast_oif;
+ 
+ 	security_sk_classify_flow(sk, flowi6_to_flowi(fl6));
+ }
+ 
+ int ip6_datagram_dst_update(struct sock *sk, bool fix_sk_saddr)
+ {
+ 	struct ip6_flowlabel *flowlabel = NULL;
+ 	struct in6_addr *final_p, final;
+ 	struct ipv6_txoptions *opt;
+ 	struct dst_entry *dst;
+ 	struct inet_sock *inet = inet_sk(sk);
+ 	struct ipv6_pinfo *np = inet6_sk(sk);
+ 	struct flowi6 fl6;
+ 	int err = 0;
+ 
+ 	if (np->sndflow && (np->flow_label & IPV6_FLOWLABEL_MASK)) {
+ 		flowlabel = fl6_sock_lookup(sk, np->flow_label);
+ 		if (!flowlabel)
+ 			return -EINVAL;
+ 	}
+ 	ip6_datagram_flow_key_init(&fl6, sk);
+ 
+ 	rcu_read_lock();
+ 	opt = flowlabel ? flowlabel->opt : rcu_dereference(np->opt);
+ 	final_p = fl6_update_dst(&fl6, opt, &final);
+ 	rcu_read_unlock();
+ 
+ 	dst = ip6_dst_lookup_flow(sk, &fl6, final_p);
+ 	if (IS_ERR(dst)) {
+ 		err = PTR_ERR(dst);
+ 		goto out;
+ 	}
+ 
+ 	if (fix_sk_saddr) {
+ 		if (ipv6_addr_any(&np->saddr))
+ 			np->saddr = fl6.saddr;
+ 
+ 		if (ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {
+ 			sk->sk_v6_rcv_saddr = fl6.saddr;
+ 			inet->inet_rcv_saddr = LOOPBACK4_IPV6;
+ 			if (sk->sk_prot->rehash)
+ 				sk->sk_prot->rehash(sk);
+ 		}
+ 	}
+ 
+ 	ip6_dst_store(sk, dst,
+ 		      ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr) ?
+ 		      &sk->sk_v6_daddr : NULL,
+ #ifdef CONFIG_IPV6_SUBTREES
+ 		      ipv6_addr_equal(&fl6.saddr, &np->saddr) ?
+ 		      &np->saddr :
+ #endif
+ 		      NULL);
+ 
+ out:
+ 	fl6_sock_release(flowlabel);
+ 	return err;
+ }
+ 
+ void ip6_datagram_release_cb(struct sock *sk)
+ {
+ 	struct dst_entry *dst;
+ 
+ 	if (ipv6_addr_v4mapped(&sk->sk_v6_daddr))
+ 		return;
+ 
+ 	rcu_read_lock();
+ 	dst = __sk_dst_get(sk);
+ 	if (!dst || !dst->obsolete ||
+ 	    dst->ops->check(dst, inet6_sk(sk)->dst_cookie)) {
+ 		rcu_read_unlock();
+ 		return;
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	ip6_datagram_dst_update(sk, false);
+ }
+ EXPORT_SYMBOL_GPL(ip6_datagram_release_cb);
+ 
+ static int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
++>>>>>>> e646b657f698 (ipv6: udp: Do a route lookup and update during release_cb)
  {
  	struct sockaddr_in6	*usin = (struct sockaddr_in6 *) uaddr;
 -	struct inet_sock	*inet = inet_sk(sk);
 -	struct ipv6_pinfo	*np = inet6_sk(sk);
 -	struct in6_addr		*daddr;
 +	struct inet_sock      	*inet = inet_sk(sk);
 +	struct ipv6_pinfo      	*np = inet6_sk(sk);
 +	struct in6_addr		*daddr, *final_p, final;
 +	struct dst_entry	*dst;
 +	struct flowi6		fl6;
 +	struct ip6_flowlabel	*flowlabel = NULL;
 +	struct ipv6_txoptions   *opt;
  	int			addr_type;
  	int			err;
 -	__be32			fl6_flowlabel = 0;
  
  	if (usin->sin6_family == AF_INET) {
  		if (__ipv6_only_sock(sk))
* Unmerged path include/net/ipv6.h
* Unmerged path net/ipv6/datagram.c
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index b85b471dc1ce..b7ed98452e07 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -1521,6 +1521,7 @@ struct proto udpv6_prot = {
 	.sendmsg	   = udpv6_sendmsg,
 	.recvmsg	   = udpv6_recvmsg,
 	.backlog_rcv	   = __udpv6_queue_rcv_skb,
+	.release_cb	   = ip6_datagram_release_cb,
 	.hash		   = udp_lib_hash,
 	.unhash		   = udp_lib_unhash,
 	.rehash		   = udp_v6_rehash,
