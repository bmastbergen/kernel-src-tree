sfc: update MCDI protocol headers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bert Kenward <bkenward@solarflare.com>
commit d29e33d6d087ef66a70f94791504579366cf3d09
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d29e33d6.failed

	Signed-off-by: Bert Kenward <bkenward@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d29e33d6d087ef66a70f94791504579366cf3d09)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/mcdi_pcol.h
diff --cc drivers/net/ethernet/sfc/mcdi_pcol.h
index 45fca9fc66b7,ccceafc15896..000000000000
--- a/drivers/net/ethernet/sfc/mcdi_pcol.h
+++ b/drivers/net/ethernet/sfc/mcdi_pcol.h
@@@ -3877,6 -4379,27 +3883,30 @@@
  #define          MC_CMD_WORKAROUND_BUG35388 0x2
  /* enum: Bug35017 workaround (A64 tables must be identity map) */
  #define          MC_CMD_WORKAROUND_BUG35017 0x3
++<<<<<<< HEAD
++=======
+ /* enum: Bug 41750 present (MC_CMD_TRIGGER_INTERRUPT won't work) */
+ #define          MC_CMD_WORKAROUND_BUG41750 0x4
+ /* enum: Bug 42008 present (Interrupts can overtake associated events). Caution
+  * - before adding code that queries this workaround, remember that there's
+  * released Monza firmware that doesn't understand MC_CMD_WORKAROUND_BUG42008,
+  * and will hence (incorrectly) report that the bug doesn't exist.
+  */
+ #define          MC_CMD_WORKAROUND_BUG42008 0x5
+ /* enum: Bug 26807 features present in firmware (multicast filter chaining)
+  * This feature cannot be turned on/off while there are any filters already
+  * present. The behaviour in such case depends on the acting client's privilege
+  * level. If the client has the admin privilege, then all functions that have
+  * filters installed will be FLRed and the FLR_DONE flag will be set. Otherwise
+  * the command will fail with MC_CMD_ERR_FILTERS_PRESENT.
+  */
+ #define          MC_CMD_WORKAROUND_BUG26807 0x6
+ /* enum: Bug 61265 work around (broken EVQ TMR writes). */
+ #define          MC_CMD_WORKAROUND_BUG61265 0x7
+ /* 0 = disable the workaround indicated by TYPE; any non-zero value = enable
+  * the workaround
+  */
++>>>>>>> d29e33d6d087 (sfc: update MCDI protocol headers)
  #define       MC_CMD_WORKAROUND_IN_ENABLED_OFST 4
  
  /* MC_CMD_WORKAROUND_OUT msgresponse */
@@@ -4226,58 -5405,137 +4255,125 @@@
  #define       LICENSED_APP_ID_ID_LBN 0
  #define       LICENSED_APP_ID_ID_WIDTH 32
  
 -/* LICENSED_FEATURES structuredef */
 -#define    LICENSED_FEATURES_LEN 8
 -/* Bitmask of licensed firmware features */
 -#define       LICENSED_FEATURES_MASK_OFST 0
 -#define       LICENSED_FEATURES_MASK_LEN 8
 -#define       LICENSED_FEATURES_MASK_LO_OFST 0
 -#define       LICENSED_FEATURES_MASK_HI_OFST 4
 -#define        LICENSED_FEATURES_RX_CUT_THROUGH_LBN 0
 -#define        LICENSED_FEATURES_RX_CUT_THROUGH_WIDTH 1
 -#define        LICENSED_FEATURES_PIO_LBN 1
 -#define        LICENSED_FEATURES_PIO_WIDTH 1
 -#define        LICENSED_FEATURES_EVQ_TIMER_LBN 2
 -#define        LICENSED_FEATURES_EVQ_TIMER_WIDTH 1
 -#define        LICENSED_FEATURES_CLOCK_LBN 3
 -#define        LICENSED_FEATURES_CLOCK_WIDTH 1
 -#define        LICENSED_FEATURES_RX_TIMESTAMPS_LBN 4
 -#define        LICENSED_FEATURES_RX_TIMESTAMPS_WIDTH 1
 -#define        LICENSED_FEATURES_TX_TIMESTAMPS_LBN 5
 -#define        LICENSED_FEATURES_TX_TIMESTAMPS_WIDTH 1
 -#define        LICENSED_FEATURES_RX_SNIFF_LBN 6
 -#define        LICENSED_FEATURES_RX_SNIFF_WIDTH 1
 -#define        LICENSED_FEATURES_TX_SNIFF_LBN 7
 -#define        LICENSED_FEATURES_TX_SNIFF_WIDTH 1
 -#define        LICENSED_FEATURES_PROXY_FILTER_OPS_LBN 8
 -#define        LICENSED_FEATURES_PROXY_FILTER_OPS_WIDTH 1
 -#define        LICENSED_FEATURES_EVENT_CUT_THROUGH_LBN 9
 -#define        LICENSED_FEATURES_EVENT_CUT_THROUGH_WIDTH 1
 -#define       LICENSED_FEATURES_MASK_LBN 0
 -#define       LICENSED_FEATURES_MASK_WIDTH 64
  
++<<<<<<< HEAD
 +/***********************************/
 +/* MC_CMD_GET_WORKAROUNDS
 + * Read the list of all implemented and all currently enabled workarounds. The
 + * enums here must correspond with those in MC_CMD_WORKAROUND.
++=======
+ /* LICENSED_V3_APPS structuredef */
+ #define    LICENSED_V3_APPS_LEN 8
+ /* Bitmask of licensed applications */
+ #define       LICENSED_V3_APPS_MASK_OFST 0
+ #define       LICENSED_V3_APPS_MASK_LEN 8
+ #define       LICENSED_V3_APPS_MASK_LO_OFST 0
+ #define       LICENSED_V3_APPS_MASK_HI_OFST 4
+ #define        LICENSED_V3_APPS_ONLOAD_LBN 0
+ #define        LICENSED_V3_APPS_ONLOAD_WIDTH 1
+ #define        LICENSED_V3_APPS_PTP_LBN 1
+ #define        LICENSED_V3_APPS_PTP_WIDTH 1
+ #define        LICENSED_V3_APPS_SOLARCAPTURE_PRO_LBN 2
+ #define        LICENSED_V3_APPS_SOLARCAPTURE_PRO_WIDTH 1
+ #define        LICENSED_V3_APPS_SOLARSECURE_LBN 3
+ #define        LICENSED_V3_APPS_SOLARSECURE_WIDTH 1
+ #define        LICENSED_V3_APPS_PERF_MONITOR_LBN 4
+ #define        LICENSED_V3_APPS_PERF_MONITOR_WIDTH 1
+ #define        LICENSED_V3_APPS_SOLARCAPTURE_LIVE_LBN 5
+ #define        LICENSED_V3_APPS_SOLARCAPTURE_LIVE_WIDTH 1
+ #define        LICENSED_V3_APPS_CAPTURE_SOLARSYSTEM_LBN 6
+ #define        LICENSED_V3_APPS_CAPTURE_SOLARSYSTEM_WIDTH 1
+ #define        LICENSED_V3_APPS_NETWORK_ACCESS_CONTROL_LBN 7
+ #define        LICENSED_V3_APPS_NETWORK_ACCESS_CONTROL_WIDTH 1
+ #define       LICENSED_V3_APPS_MASK_LBN 0
+ #define       LICENSED_V3_APPS_MASK_WIDTH 64
+ 
+ /* LICENSED_V3_FEATURES structuredef */
+ #define    LICENSED_V3_FEATURES_LEN 8
+ /* Bitmask of licensed firmware features */
+ #define       LICENSED_V3_FEATURES_MASK_OFST 0
+ #define       LICENSED_V3_FEATURES_MASK_LEN 8
+ #define       LICENSED_V3_FEATURES_MASK_LO_OFST 0
+ #define       LICENSED_V3_FEATURES_MASK_HI_OFST 4
+ #define        LICENSED_V3_FEATURES_RX_CUT_THROUGH_LBN 0
+ #define        LICENSED_V3_FEATURES_RX_CUT_THROUGH_WIDTH 1
+ #define        LICENSED_V3_FEATURES_PIO_LBN 1
+ #define        LICENSED_V3_FEATURES_PIO_WIDTH 1
+ #define        LICENSED_V3_FEATURES_EVQ_TIMER_LBN 2
+ #define        LICENSED_V3_FEATURES_EVQ_TIMER_WIDTH 1
+ #define        LICENSED_V3_FEATURES_CLOCK_LBN 3
+ #define        LICENSED_V3_FEATURES_CLOCK_WIDTH 1
+ #define        LICENSED_V3_FEATURES_RX_TIMESTAMPS_LBN 4
+ #define        LICENSED_V3_FEATURES_RX_TIMESTAMPS_WIDTH 1
+ #define        LICENSED_V3_FEATURES_TX_TIMESTAMPS_LBN 5
+ #define        LICENSED_V3_FEATURES_TX_TIMESTAMPS_WIDTH 1
+ #define        LICENSED_V3_FEATURES_RX_SNIFF_LBN 6
+ #define        LICENSED_V3_FEATURES_RX_SNIFF_WIDTH 1
+ #define        LICENSED_V3_FEATURES_TX_SNIFF_LBN 7
+ #define        LICENSED_V3_FEATURES_TX_SNIFF_WIDTH 1
+ #define        LICENSED_V3_FEATURES_PROXY_FILTER_OPS_LBN 8
+ #define        LICENSED_V3_FEATURES_PROXY_FILTER_OPS_WIDTH 1
+ #define        LICENSED_V3_FEATURES_EVENT_CUT_THROUGH_LBN 9
+ #define        LICENSED_V3_FEATURES_EVENT_CUT_THROUGH_WIDTH 1
+ #define       LICENSED_V3_FEATURES_MASK_LBN 0
+ #define       LICENSED_V3_FEATURES_MASK_WIDTH 64
+ 
+ /* TX_TIMESTAMP_EVENT structuredef */
+ #define    TX_TIMESTAMP_EVENT_LEN 6
+ /* lower 16 bits of timestamp data */
+ #define       TX_TIMESTAMP_EVENT_TSTAMP_DATA_LO_OFST 0
+ #define       TX_TIMESTAMP_EVENT_TSTAMP_DATA_LO_LEN 2
+ #define       TX_TIMESTAMP_EVENT_TSTAMP_DATA_LO_LBN 0
+ #define       TX_TIMESTAMP_EVENT_TSTAMP_DATA_LO_WIDTH 16
+ /* Type of TX event, ordinary TX completion, low or high part of TX timestamp
++>>>>>>> d29e33d6d087 (sfc: update MCDI protocol headers)
 + */
 +#define MC_CMD_GET_WORKAROUNDS 0x59
 +
 +/* MC_CMD_GET_WORKAROUNDS_OUT msgresponse */
 +#define    MC_CMD_GET_WORKAROUNDS_OUT_LEN 8
 +/* Each workaround is represented by a single bit according to the enums below.
 + */
 +#define       MC_CMD_GET_WORKAROUNDS_OUT_IMPLEMENTED_OFST 0
 +#define       MC_CMD_GET_WORKAROUNDS_OUT_ENABLED_OFST 4
 +/* enum: Bug 17230 work around. */
 +#define          MC_CMD_GET_WORKAROUNDS_OUT_BUG17230 0x2
 +/* enum: Bug 35388 work around (unsafe EVQ writes). */
 +#define          MC_CMD_GET_WORKAROUNDS_OUT_BUG35388 0x4
 +/* enum: Bug35017 workaround (A64 tables must be identity map) */
 +#define          MC_CMD_GET_WORKAROUNDS_OUT_BUG35017 0x8
 +
 +
 +/***********************************/
 +/* MC_CMD_LINK_STATE_MODE
 + * Read/set link state mode of a VF
 + */
 +#define MC_CMD_LINK_STATE_MODE 0x5c
 +
 +#define MC_CMD_0x5c_PRIVILEGE_CTG SRIOV_CTG_GENERAL
 +
 +/* MC_CMD_LINK_STATE_MODE_IN msgrequest */
 +#define    MC_CMD_LINK_STATE_MODE_IN_LEN 8
 +/* The target function to have its link state mode read or set, must be a VF
 + * e.g. VF 1,3 = 0x00030001
 + */
 +#define       MC_CMD_LINK_STATE_MODE_IN_FUNCTION_OFST 0
 +#define        MC_CMD_LINK_STATE_MODE_IN_FUNCTION_PF_LBN 0
 +#define        MC_CMD_LINK_STATE_MODE_IN_FUNCTION_PF_WIDTH 16
 +#define        MC_CMD_LINK_STATE_MODE_IN_FUNCTION_VF_LBN 16
 +#define        MC_CMD_LINK_STATE_MODE_IN_FUNCTION_VF_WIDTH 16
 +/* New link state mode to be set */
 +#define       MC_CMD_LINK_STATE_MODE_IN_NEW_MODE_OFST 4
 +#define          MC_CMD_LINK_STATE_MODE_IN_LINK_STATE_AUTO       0x0 /* enum */
 +#define          MC_CMD_LINK_STATE_MODE_IN_LINK_STATE_UP         0x1 /* enum */
 +#define          MC_CMD_LINK_STATE_MODE_IN_LINK_STATE_DOWN       0x2 /* enum */
 +/* enum: Use this value to just read the existing setting without modifying it.
   */
 -#define       TX_TIMESTAMP_EVENT_TX_EV_TYPE_OFST 3
 -#define       TX_TIMESTAMP_EVENT_TX_EV_TYPE_LEN 1
 -/* enum: This is a TX completion event, not a timestamp */
 -#define          TX_TIMESTAMP_EVENT_TX_EV_COMPLETION  0x0
 -/* enum: This is the low part of a TX timestamp event */
 -#define          TX_TIMESTAMP_EVENT_TX_EV_TSTAMP_LO  0x51
 -/* enum: This is the high part of a TX timestamp event */
 -#define          TX_TIMESTAMP_EVENT_TX_EV_TSTAMP_HI  0x52
 -#define       TX_TIMESTAMP_EVENT_TX_EV_TYPE_LBN 24
 -#define       TX_TIMESTAMP_EVENT_TX_EV_TYPE_WIDTH 8
 -/* upper 16 bits of timestamp data */
 -#define       TX_TIMESTAMP_EVENT_TSTAMP_DATA_HI_OFST 4
 -#define       TX_TIMESTAMP_EVENT_TSTAMP_DATA_HI_LEN 2
 -#define       TX_TIMESTAMP_EVENT_TSTAMP_DATA_HI_LBN 32
 -#define       TX_TIMESTAMP_EVENT_TSTAMP_DATA_HI_WIDTH 16
 -
 -/* RSS_MODE structuredef */
 -#define    RSS_MODE_LEN 1
 -/* The RSS mode for a particular packet type is a value from 0 - 15 which can
 - * be considered as 4 bits selecting which fields are included in the hash. (A
 - * value 0 effectively disables RSS spreading for the packet type.) The YAML
 - * generation tools require this structure to be a whole number of bytes wide,
 - * but only 4 bits are relevant.
 - */
 -#define       RSS_MODE_HASH_SELECTOR_OFST 0
 -#define       RSS_MODE_HASH_SELECTOR_LEN 1
 -#define        RSS_MODE_HASH_SRC_ADDR_LBN 0
 -#define        RSS_MODE_HASH_SRC_ADDR_WIDTH 1
 -#define        RSS_MODE_HASH_DST_ADDR_LBN 1
 -#define        RSS_MODE_HASH_DST_ADDR_WIDTH 1
 -#define        RSS_MODE_HASH_SRC_PORT_LBN 2
 -#define        RSS_MODE_HASH_SRC_PORT_WIDTH 1
 -#define        RSS_MODE_HASH_DST_PORT_LBN 3
 -#define        RSS_MODE_HASH_DST_PORT_WIDTH 1
 -#define       RSS_MODE_HASH_SELECTOR_LBN 0
 -#define       RSS_MODE_HASH_SELECTOR_WIDTH 8
 +#define          MC_CMD_LINK_STATE_MODE_IN_DO_NOT_CHANGE         0xffffffff
 +
 +/* MC_CMD_LINK_STATE_MODE_OUT msgresponse */
 +#define    MC_CMD_LINK_STATE_MODE_OUT_LEN 4
 +#define       MC_CMD_LINK_STATE_MODE_OUT_OLD_MODE_OFST 0
  
  
  /***********************************/
@@@ -4444,6 -5809,8 +4643,11 @@@
  #define        MC_CMD_INIT_RXQ_IN_FLAG_PREFIX_WIDTH 1
  #define        MC_CMD_INIT_RXQ_IN_FLAG_DISABLE_SCATTER_LBN 9
  #define        MC_CMD_INIT_RXQ_IN_FLAG_DISABLE_SCATTER_WIDTH 1
++<<<<<<< HEAD
++=======
+ #define        MC_CMD_INIT_RXQ_IN_UNUSED_LBN 10
+ #define        MC_CMD_INIT_RXQ_IN_UNUSED_WIDTH 1
++>>>>>>> d29e33d6d087 (sfc: update MCDI protocol headers)
  /* Owner ID to use if in buffer mode (zero if physical) */
  #define       MC_CMD_INIT_RXQ_IN_OWNER_ID_OFST 20
  /* The port ID associated with the v-adaptor which should contain this DMAQ. */
@@@ -5663,6 -7770,554 +5867,557 @@@
  /* Licensed capabilities */
  #define       MC_CMD_GET_CAPABILITIES_OUT_LICENSE_CAPABILITIES_OFST 16
  
++<<<<<<< HEAD
++=======
+ /* MC_CMD_GET_CAPABILITIES_V2_IN msgrequest */
+ #define    MC_CMD_GET_CAPABILITIES_V2_IN_LEN 0
+ 
+ /* MC_CMD_GET_CAPABILITIES_V2_OUT msgresponse */
+ #define    MC_CMD_GET_CAPABILITIES_V2_OUT_LEN 72
+ /* First word of flags. */
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_FLAGS1_OFST 0
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_VPORT_RECONFIGURE_LBN 3
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_VPORT_RECONFIGURE_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_STRIPING_LBN 4
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_STRIPING_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_VADAPTOR_QUERY_LBN 5
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_VADAPTOR_QUERY_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_EVB_PORT_VLAN_RESTRICT_LBN 6
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_EVB_PORT_VLAN_RESTRICT_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_DRV_ATTACH_PREBOOT_LBN 7
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_DRV_ATTACH_PREBOOT_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_FORCE_EVENT_MERGING_LBN 8
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_FORCE_EVENT_MERGING_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_SET_MAC_ENHANCED_LBN 9
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_SET_MAC_ENHANCED_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_UNKNOWN_UCAST_DST_FILTER_ALWAYS_MULTI_RECIPIENT_LBN 10
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_UNKNOWN_UCAST_DST_FILTER_ALWAYS_MULTI_RECIPIENT_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_VADAPTOR_PERMIT_SET_MAC_WHEN_FILTERS_INSTALLED_LBN 11
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_VADAPTOR_PERMIT_SET_MAC_WHEN_FILTERS_INSTALLED_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_MAC_SECURITY_FILTERING_LBN 12
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_MAC_SECURITY_FILTERING_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_ADDITIONAL_RSS_MODES_LBN 13
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_ADDITIONAL_RSS_MODES_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_QBB_LBN 14
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_QBB_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_PACKED_STREAM_VAR_BUFFERS_LBN 15
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_PACKED_STREAM_VAR_BUFFERS_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_RSS_LIMITED_LBN 16
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_RSS_LIMITED_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_PACKED_STREAM_LBN 17
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_PACKED_STREAM_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_INCLUDE_FCS_LBN 18
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_INCLUDE_FCS_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_VLAN_INSERTION_LBN 19
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_VLAN_INSERTION_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_VLAN_STRIPPING_LBN 20
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_VLAN_STRIPPING_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_TSO_LBN 21
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_TSO_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_PREFIX_LEN_0_LBN 22
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_PREFIX_LEN_0_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_PREFIX_LEN_14_LBN 23
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_PREFIX_LEN_14_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_TIMESTAMP_LBN 24
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_TIMESTAMP_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_BATCHING_LBN 25
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_BATCHING_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_MCAST_FILTER_CHAINING_LBN 26
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_MCAST_FILTER_CHAINING_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_PM_AND_RXDP_COUNTERS_LBN 27
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_PM_AND_RXDP_COUNTERS_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_DISABLE_SCATTER_LBN 28
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_DISABLE_SCATTER_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_MCAST_UDP_LOOPBACK_LBN 29
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_MCAST_UDP_LOOPBACK_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_EVB_LBN 30
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_EVB_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_VXLAN_NVGRE_LBN 31
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_VXLAN_NVGRE_WIDTH 1
+ /* RxDPCPU firmware id. */
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_RX_DPCPU_FW_ID_OFST 4
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_RX_DPCPU_FW_ID_LEN 2
+ /* enum: Standard RXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXDP  0x0
+ /* enum: Low latency RXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXDP_LOW_LATENCY  0x1
+ /* enum: Packed stream RXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXDP_PACKED_STREAM  0x2
+ /* enum: BIST RXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXDP_BIST  0x10a
+ /* enum: RXDP Test firmware image 1 */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXDP_TEST_FW_TO_MC_CUT_THROUGH  0x101
+ /* enum: RXDP Test firmware image 2 */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXDP_TEST_FW_TO_MC_STORE_FORWARD  0x102
+ /* enum: RXDP Test firmware image 3 */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXDP_TEST_FW_TO_MC_STORE_FORWARD_FIRST  0x103
+ /* enum: RXDP Test firmware image 4 */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXDP_TEST_EVERY_EVENT_BATCHABLE  0x104
+ /* enum: RXDP Test firmware image 5 */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXDP_TEST_BACKPRESSURE  0x105
+ /* enum: RXDP Test firmware image 6 */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXDP_TEST_FW_PACKET_EDITS  0x106
+ /* enum: RXDP Test firmware image 7 */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXDP_TEST_FW_RX_HDR_SPLIT  0x107
+ /* enum: RXDP Test firmware image 8 */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXDP_TEST_FW_DISABLE_DL  0x108
+ /* enum: RXDP Test firmware image 9 */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXDP_TEST_FW_DOORBELL_DELAY  0x10b
+ /* TxDPCPU firmware id. */
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_TX_DPCPU_FW_ID_OFST 6
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_TX_DPCPU_FW_ID_LEN 2
+ /* enum: Standard TXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_TXDP  0x0
+ /* enum: Low latency TXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_TXDP_LOW_LATENCY  0x1
+ /* enum: High packet rate TXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_TXDP_HIGH_PACKET_RATE  0x3
+ /* enum: BIST TXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_TXDP_BIST  0x12d
+ /* enum: TXDP Test firmware image 1 */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_TXDP_TEST_FW_TSO_EDIT  0x101
+ /* enum: TXDP Test firmware image 2 */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_TXDP_TEST_FW_PACKET_EDITS  0x102
+ /* enum: TXDP CSR bus test firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_TXDP_TEST_FW_CSR  0x103
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_VERSION_OFST 8
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_VERSION_LEN 2
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_VERSION_REV_LBN 0
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_VERSION_REV_WIDTH 12
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_VERSION_TYPE_LBN 12
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_VERSION_TYPE_WIDTH 4
+ /* enum: reserved value - do not use (may indicate alternative interpretation
+  * of REV field in future)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_TYPE_RESERVED  0x0
+ /* enum: Trivial RX PD firmware for early Huntington development (Huntington
+  * development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_TYPE_FIRST_PKT  0x1
+ /* enum: RX PD firmware with approximately Siena-compatible behaviour
+  * (Huntington development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_TYPE_SIENA_COMPAT  0x2
+ /* enum: Virtual switching (full feature) RX PD production firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_TYPE_VSWITCH  0x3
+ /* enum: siena_compat variant RX PD firmware using PM rather than MAC
+  * (Huntington development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_TYPE_SIENA_COMPAT_PM  0x4
+ /* enum: Low latency RX PD production firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_TYPE_LOW_LATENCY  0x5
+ /* enum: Packed stream RX PD production firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_TYPE_PACKED_STREAM  0x6
+ /* enum: RX PD firmware handling layer 2 only for high packet rate performance
+  * tests (Medford development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_TYPE_LAYER2_PERF  0x7
+ /* enum: RX PD firmware for GUE parsing prototype (Medford development only) */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_TYPE_TESTFW_GUE_PROTOTYPE  0xe
+ /* enum: RX PD firmware parsing but not filtering network overlay tunnel
+  * encapsulations (Medford development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_RXPD_FW_TYPE_TESTFW_ENCAP_PARSING_ONLY  0xf
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_TXPD_FW_VERSION_OFST 10
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_TXPD_FW_VERSION_LEN 2
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TXPD_FW_VERSION_REV_LBN 0
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TXPD_FW_VERSION_REV_WIDTH 12
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TXPD_FW_VERSION_TYPE_LBN 12
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TXPD_FW_VERSION_TYPE_WIDTH 4
+ /* enum: reserved value - do not use (may indicate alternative interpretation
+  * of REV field in future)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_TXPD_FW_TYPE_RESERVED  0x0
+ /* enum: Trivial TX PD firmware for early Huntington development (Huntington
+  * development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_TXPD_FW_TYPE_FIRST_PKT  0x1
+ /* enum: TX PD firmware with approximately Siena-compatible behaviour
+  * (Huntington development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_TXPD_FW_TYPE_SIENA_COMPAT  0x2
+ /* enum: Virtual switching (full feature) TX PD production firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_TXPD_FW_TYPE_VSWITCH  0x3
+ /* enum: siena_compat variant TX PD firmware using PM rather than MAC
+  * (Huntington development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_TXPD_FW_TYPE_SIENA_COMPAT_PM  0x4
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_TXPD_FW_TYPE_LOW_LATENCY  0x5 /* enum */
+ /* enum: TX PD firmware handling layer 2 only for high packet rate performance
+  * tests (Medford development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_TXPD_FW_TYPE_LAYER2_PERF  0x7
+ /* enum: RX PD firmware for GUE parsing prototype (Medford development only) */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_TXPD_FW_TYPE_TESTFW_GUE_PROTOTYPE  0xe
+ /* Hardware capabilities of NIC */
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_HW_CAPABILITIES_OFST 12
+ /* Licensed capabilities */
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_LICENSE_CAPABILITIES_OFST 16
+ /* Second word of flags. Not present on older firmware (check the length). */
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_FLAGS2_OFST 20
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_TSO_V2_LBN 0
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_TSO_V2_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_TSO_V2_ENCAP_LBN 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_TSO_V2_ENCAP_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_EVQ_TIMER_CTRL_LBN 2
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_EVQ_TIMER_CTRL_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_EVENT_CUT_THROUGH_LBN 3
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_EVENT_CUT_THROUGH_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_CUT_THROUGH_LBN 4
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_CUT_THROUGH_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_VFIFO_ULL_MODE_LBN 5
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_VFIFO_ULL_MODE_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_MAC_STATS_40G_TX_SIZE_BINS_LBN 6
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_MAC_STATS_40G_TX_SIZE_BINS_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_INIT_EVQ_V2_LBN 7
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_INIT_EVQ_V2_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_MAC_TIMESTAMPING_LBN 8
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_MAC_TIMESTAMPING_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_TIMESTAMP_LBN 9
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_TIMESTAMP_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_SNIFF_LBN 10
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_RX_SNIFF_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_SNIFF_LBN 11
+ #define        MC_CMD_GET_CAPABILITIES_V2_OUT_TX_SNIFF_WIDTH 1
+ /* Number of FATSOv2 contexts per datapath supported by this NIC. Not present
+  * on older firmware (check the length).
+  */
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_TX_TSO_V2_N_CONTEXTS_OFST 24
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_TX_TSO_V2_N_CONTEXTS_LEN 2
+ /* One byte per PF containing the number of the external port assigned to this
+  * PF, indexed by PF number. Special values indicate that a PF is either not
+  * present or not assigned.
+  */
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_PFS_TO_PORTS_ASSIGNMENT_OFST 26
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_PFS_TO_PORTS_ASSIGNMENT_LEN 1
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_PFS_TO_PORTS_ASSIGNMENT_NUM 16
+ /* enum: The caller is not permitted to access information on this PF. */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_ACCESS_NOT_PERMITTED  0xff
+ /* enum: PF does not exist. */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_PF_NOT_PRESENT  0xfe
+ /* enum: PF does exist but is not assigned to any external port. */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_PF_NOT_ASSIGNED  0xfd
+ /* enum: This value indicates that PF is assigned, but it cannot be expressed
+  * in this field. It is intended for a possible future situation where a more
+  * complex scheme of PFs to ports mapping is being used. The future driver
+  * should look for a new field supporting the new scheme. The current/old
+  * driver should treat this value as PF_NOT_ASSIGNED.
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V2_OUT_INCOMPATIBLE_ASSIGNMENT  0xfc
+ /* One byte per PF containing the number of its VFs, indexed by PF number. A
+  * special value indicates that a PF is not present.
+  */
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_NUM_VFS_PER_PF_OFST 42
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_NUM_VFS_PER_PF_LEN 1
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_NUM_VFS_PER_PF_NUM 16
+ /* enum: The caller is not permitted to access information on this PF. */
+ /*               MC_CMD_GET_CAPABILITIES_V2_OUT_ACCESS_NOT_PERMITTED  0xff */
+ /* enum: PF does not exist. */
+ /*               MC_CMD_GET_CAPABILITIES_V2_OUT_PF_NOT_PRESENT  0xfe */
+ /* Number of VIs available for each external port */
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_NUM_VIS_PER_PORT_OFST 58
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_NUM_VIS_PER_PORT_LEN 2
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_NUM_VIS_PER_PORT_NUM 4
+ /* Size of RX descriptor cache expressed as binary logarithm The actual size
+  * equals (2 ^ RX_DESC_CACHE_SIZE)
+  */
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_RX_DESC_CACHE_SIZE_OFST 66
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_RX_DESC_CACHE_SIZE_LEN 1
+ /* Size of TX descriptor cache expressed as binary logarithm The actual size
+  * equals (2 ^ TX_DESC_CACHE_SIZE)
+  */
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_TX_DESC_CACHE_SIZE_OFST 67
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_TX_DESC_CACHE_SIZE_LEN 1
+ /* Total number of available PIO buffers */
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_NUM_PIO_BUFFS_OFST 68
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_NUM_PIO_BUFFS_LEN 2
+ /* Size of a single PIO buffer */
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_SIZE_PIO_BUFF_OFST 70
+ #define       MC_CMD_GET_CAPABILITIES_V2_OUT_SIZE_PIO_BUFF_LEN 2
+ 
+ /* MC_CMD_GET_CAPABILITIES_V3_OUT msgresponse */
+ #define    MC_CMD_GET_CAPABILITIES_V3_OUT_LEN 73
+ /* First word of flags. */
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_FLAGS1_OFST 0
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_VPORT_RECONFIGURE_LBN 3
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_VPORT_RECONFIGURE_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_STRIPING_LBN 4
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_STRIPING_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_VADAPTOR_QUERY_LBN 5
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_VADAPTOR_QUERY_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_EVB_PORT_VLAN_RESTRICT_LBN 6
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_EVB_PORT_VLAN_RESTRICT_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_DRV_ATTACH_PREBOOT_LBN 7
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_DRV_ATTACH_PREBOOT_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_FORCE_EVENT_MERGING_LBN 8
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_FORCE_EVENT_MERGING_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_SET_MAC_ENHANCED_LBN 9
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_SET_MAC_ENHANCED_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_UNKNOWN_UCAST_DST_FILTER_ALWAYS_MULTI_RECIPIENT_LBN 10
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_UNKNOWN_UCAST_DST_FILTER_ALWAYS_MULTI_RECIPIENT_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_VADAPTOR_PERMIT_SET_MAC_WHEN_FILTERS_INSTALLED_LBN 11
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_VADAPTOR_PERMIT_SET_MAC_WHEN_FILTERS_INSTALLED_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_MAC_SECURITY_FILTERING_LBN 12
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_MAC_SECURITY_FILTERING_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_ADDITIONAL_RSS_MODES_LBN 13
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_ADDITIONAL_RSS_MODES_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_QBB_LBN 14
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_QBB_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_PACKED_STREAM_VAR_BUFFERS_LBN 15
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_PACKED_STREAM_VAR_BUFFERS_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_RSS_LIMITED_LBN 16
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_RSS_LIMITED_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_PACKED_STREAM_LBN 17
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_PACKED_STREAM_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_INCLUDE_FCS_LBN 18
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_INCLUDE_FCS_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_VLAN_INSERTION_LBN 19
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_VLAN_INSERTION_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_VLAN_STRIPPING_LBN 20
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_VLAN_STRIPPING_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_TSO_LBN 21
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_TSO_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_PREFIX_LEN_0_LBN 22
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_PREFIX_LEN_0_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_PREFIX_LEN_14_LBN 23
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_PREFIX_LEN_14_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_TIMESTAMP_LBN 24
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_TIMESTAMP_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_BATCHING_LBN 25
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_BATCHING_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_MCAST_FILTER_CHAINING_LBN 26
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_MCAST_FILTER_CHAINING_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_PM_AND_RXDP_COUNTERS_LBN 27
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_PM_AND_RXDP_COUNTERS_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_DISABLE_SCATTER_LBN 28
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_DISABLE_SCATTER_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_MCAST_UDP_LOOPBACK_LBN 29
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_MCAST_UDP_LOOPBACK_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_EVB_LBN 30
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_EVB_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_VXLAN_NVGRE_LBN 31
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_VXLAN_NVGRE_WIDTH 1
+ /* RxDPCPU firmware id. */
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_RX_DPCPU_FW_ID_OFST 4
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_RX_DPCPU_FW_ID_LEN 2
+ /* enum: Standard RXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXDP  0x0
+ /* enum: Low latency RXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXDP_LOW_LATENCY  0x1
+ /* enum: Packed stream RXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXDP_PACKED_STREAM  0x2
+ /* enum: BIST RXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXDP_BIST  0x10a
+ /* enum: RXDP Test firmware image 1 */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXDP_TEST_FW_TO_MC_CUT_THROUGH  0x101
+ /* enum: RXDP Test firmware image 2 */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXDP_TEST_FW_TO_MC_STORE_FORWARD  0x102
+ /* enum: RXDP Test firmware image 3 */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXDP_TEST_FW_TO_MC_STORE_FORWARD_FIRST  0x103
+ /* enum: RXDP Test firmware image 4 */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXDP_TEST_EVERY_EVENT_BATCHABLE  0x104
+ /* enum: RXDP Test firmware image 5 */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXDP_TEST_BACKPRESSURE  0x105
+ /* enum: RXDP Test firmware image 6 */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXDP_TEST_FW_PACKET_EDITS  0x106
+ /* enum: RXDP Test firmware image 7 */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXDP_TEST_FW_RX_HDR_SPLIT  0x107
+ /* enum: RXDP Test firmware image 8 */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXDP_TEST_FW_DISABLE_DL  0x108
+ /* enum: RXDP Test firmware image 9 */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXDP_TEST_FW_DOORBELL_DELAY  0x10b
+ /* TxDPCPU firmware id. */
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_TX_DPCPU_FW_ID_OFST 6
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_TX_DPCPU_FW_ID_LEN 2
+ /* enum: Standard TXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXDP  0x0
+ /* enum: Low latency TXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXDP_LOW_LATENCY  0x1
+ /* enum: High packet rate TXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXDP_HIGH_PACKET_RATE  0x3
+ /* enum: BIST TXDP firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXDP_BIST  0x12d
+ /* enum: TXDP Test firmware image 1 */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXDP_TEST_FW_TSO_EDIT  0x101
+ /* enum: TXDP Test firmware image 2 */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXDP_TEST_FW_PACKET_EDITS  0x102
+ /* enum: TXDP CSR bus test firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXDP_TEST_FW_CSR  0x103
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_VERSION_OFST 8
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_VERSION_LEN 2
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_VERSION_REV_LBN 0
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_VERSION_REV_WIDTH 12
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_VERSION_TYPE_LBN 12
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_VERSION_TYPE_WIDTH 4
+ /* enum: reserved value - do not use (may indicate alternative interpretation
+  * of REV field in future)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_TYPE_RESERVED  0x0
+ /* enum: Trivial RX PD firmware for early Huntington development (Huntington
+  * development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_TYPE_FIRST_PKT  0x1
+ /* enum: RX PD firmware with approximately Siena-compatible behaviour
+  * (Huntington development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_TYPE_SIENA_COMPAT  0x2
+ /* enum: Virtual switching (full feature) RX PD production firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_TYPE_VSWITCH  0x3
+ /* enum: siena_compat variant RX PD firmware using PM rather than MAC
+  * (Huntington development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_TYPE_SIENA_COMPAT_PM  0x4
+ /* enum: Low latency RX PD production firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_TYPE_LOW_LATENCY  0x5
+ /* enum: Packed stream RX PD production firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_TYPE_PACKED_STREAM  0x6
+ /* enum: RX PD firmware handling layer 2 only for high packet rate performance
+  * tests (Medford development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_TYPE_LAYER2_PERF  0x7
+ /* enum: Rules engine RX PD production firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_TYPE_RULES_ENGINE  0x8
+ /* enum: RX PD firmware for GUE parsing prototype (Medford development only) */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_TYPE_TESTFW_GUE_PROTOTYPE  0xe
+ /* enum: RX PD firmware parsing but not filtering network overlay tunnel
+  * encapsulations (Medford development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_RXPD_FW_TYPE_TESTFW_ENCAP_PARSING_ONLY  0xf
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_TXPD_FW_VERSION_OFST 10
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_TXPD_FW_VERSION_LEN 2
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TXPD_FW_VERSION_REV_LBN 0
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TXPD_FW_VERSION_REV_WIDTH 12
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TXPD_FW_VERSION_TYPE_LBN 12
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TXPD_FW_VERSION_TYPE_WIDTH 4
+ /* enum: reserved value - do not use (may indicate alternative interpretation
+  * of REV field in future)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXPD_FW_TYPE_RESERVED  0x0
+ /* enum: Trivial TX PD firmware for early Huntington development (Huntington
+  * development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXPD_FW_TYPE_FIRST_PKT  0x1
+ /* enum: TX PD firmware with approximately Siena-compatible behaviour
+  * (Huntington development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXPD_FW_TYPE_SIENA_COMPAT  0x2
+ /* enum: Virtual switching (full feature) TX PD production firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXPD_FW_TYPE_VSWITCH  0x3
+ /* enum: siena_compat variant TX PD firmware using PM rather than MAC
+  * (Huntington development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXPD_FW_TYPE_SIENA_COMPAT_PM  0x4
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXPD_FW_TYPE_LOW_LATENCY  0x5 /* enum */
+ /* enum: TX PD firmware handling layer 2 only for high packet rate performance
+  * tests (Medford development only)
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXPD_FW_TYPE_LAYER2_PERF  0x7
+ /* enum: Rules engine TX PD production firmware */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXPD_FW_TYPE_RULES_ENGINE  0x8
+ /* enum: RX PD firmware for GUE parsing prototype (Medford development only) */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_TXPD_FW_TYPE_TESTFW_GUE_PROTOTYPE  0xe
+ /* Hardware capabilities of NIC */
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_HW_CAPABILITIES_OFST 12
+ /* Licensed capabilities */
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_LICENSE_CAPABILITIES_OFST 16
+ /* Second word of flags. Not present on older firmware (check the length). */
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_FLAGS2_OFST 20
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_TSO_V2_LBN 0
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_TSO_V2_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_TSO_V2_ENCAP_LBN 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_TSO_V2_ENCAP_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_EVQ_TIMER_CTRL_LBN 2
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_EVQ_TIMER_CTRL_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_EVENT_CUT_THROUGH_LBN 3
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_EVENT_CUT_THROUGH_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_CUT_THROUGH_LBN 4
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_CUT_THROUGH_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_VFIFO_ULL_MODE_LBN 5
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_VFIFO_ULL_MODE_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_MAC_STATS_40G_TX_SIZE_BINS_LBN 6
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_MAC_STATS_40G_TX_SIZE_BINS_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_INIT_EVQ_V2_LBN 7
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_INIT_EVQ_V2_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_MAC_TIMESTAMPING_LBN 8
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_MAC_TIMESTAMPING_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_TIMESTAMP_LBN 9
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_TIMESTAMP_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_SNIFF_LBN 10
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_RX_SNIFF_WIDTH 1
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_SNIFF_LBN 11
+ #define        MC_CMD_GET_CAPABILITIES_V3_OUT_TX_SNIFF_WIDTH 1
+ /* Number of FATSOv2 contexts per datapath supported by this NIC. Not present
+  * on older firmware (check the length).
+  */
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_TX_TSO_V2_N_CONTEXTS_OFST 24
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_TX_TSO_V2_N_CONTEXTS_LEN 2
+ /* One byte per PF containing the number of the external port assigned to this
+  * PF, indexed by PF number. Special values indicate that a PF is either not
+  * present or not assigned.
+  */
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_PFS_TO_PORTS_ASSIGNMENT_OFST 26
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_PFS_TO_PORTS_ASSIGNMENT_LEN 1
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_PFS_TO_PORTS_ASSIGNMENT_NUM 16
+ /* enum: The caller is not permitted to access information on this PF. */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_ACCESS_NOT_PERMITTED  0xff
+ /* enum: PF does not exist. */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_PF_NOT_PRESENT  0xfe
+ /* enum: PF does exist but is not assigned to any external port. */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_PF_NOT_ASSIGNED  0xfd
+ /* enum: This value indicates that PF is assigned, but it cannot be expressed
+  * in this field. It is intended for a possible future situation where a more
+  * complex scheme of PFs to ports mapping is being used. The future driver
+  * should look for a new field supporting the new scheme. The current/old
+  * driver should treat this value as PF_NOT_ASSIGNED.
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_INCOMPATIBLE_ASSIGNMENT  0xfc
+ /* One byte per PF containing the number of its VFs, indexed by PF number. A
+  * special value indicates that a PF is not present.
+  */
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_NUM_VFS_PER_PF_OFST 42
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_NUM_VFS_PER_PF_LEN 1
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_NUM_VFS_PER_PF_NUM 16
+ /* enum: The caller is not permitted to access information on this PF. */
+ /*               MC_CMD_GET_CAPABILITIES_V3_OUT_ACCESS_NOT_PERMITTED  0xff */
+ /* enum: PF does not exist. */
+ /*               MC_CMD_GET_CAPABILITIES_V3_OUT_PF_NOT_PRESENT  0xfe */
+ /* Number of VIs available for each external port */
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_NUM_VIS_PER_PORT_OFST 58
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_NUM_VIS_PER_PORT_LEN 2
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_NUM_VIS_PER_PORT_NUM 4
+ /* Size of RX descriptor cache expressed as binary logarithm The actual size
+  * equals (2 ^ RX_DESC_CACHE_SIZE)
+  */
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_RX_DESC_CACHE_SIZE_OFST 66
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_RX_DESC_CACHE_SIZE_LEN 1
+ /* Size of TX descriptor cache expressed as binary logarithm The actual size
+  * equals (2 ^ TX_DESC_CACHE_SIZE)
+  */
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_TX_DESC_CACHE_SIZE_OFST 67
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_TX_DESC_CACHE_SIZE_LEN 1
+ /* Total number of available PIO buffers */
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_NUM_PIO_BUFFS_OFST 68
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_NUM_PIO_BUFFS_LEN 2
+ /* Size of a single PIO buffer */
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_SIZE_PIO_BUFF_OFST 70
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_SIZE_PIO_BUFF_LEN 2
+ /* On chips later than Medford the amount of address space assigned to each VI
+  * is configurable. This is a global setting that the driver must query to
+  * discover the VI to address mapping. Cut-through PIO (CTPIO) in not available
+  * with 8k VI windows.
+  */
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_VI_WINDOW_MODE_OFST 72
+ #define       MC_CMD_GET_CAPABILITIES_V3_OUT_VI_WINDOW_MODE_LEN 1
+ /* enum: Each VI occupies 8k as on Huntington and Medford. PIO is at offset 4k.
+  * CTPIO is not mapped.
+  */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_VI_WINDOW_MODE_8K   0x0
+ /* enum: Each VI occupies 16k. PIO is at offset 4k. CTPIO is at offset 12k. */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_VI_WINDOW_MODE_16K  0x1
+ /* enum: Each VI occupies 64k. PIO is at offset 4k. CTPIO is at offset 12k. */
+ #define          MC_CMD_GET_CAPABILITIES_V3_OUT_VI_WINDOW_MODE_64K  0x2
+ 
++>>>>>>> d29e33d6d087 (sfc: update MCDI protocol headers)
  
  /***********************************/
  /* MC_CMD_V2_EXTN
@@@ -8166,6 -10517,95 +8921,98 @@@
  
  
  /***********************************/
++<<<<<<< HEAD
++=======
+ /* MC_CMD_LICENSING_V3
+  * Operations on the NVRAM_PARTITION_TYPE_LICENSE application license partition
+  * - V3 licensing (Medford)
+  */
+ #define MC_CMD_LICENSING_V3 0xd0
+ 
+ #define MC_CMD_0xd0_PRIVILEGE_CTG SRIOV_CTG_GENERAL
+ 
+ /* MC_CMD_LICENSING_V3_IN msgrequest */
+ #define    MC_CMD_LICENSING_V3_IN_LEN 4
+ /* identifies the type of operation requested */
+ #define       MC_CMD_LICENSING_V3_IN_OP_OFST 0
+ /* enum: re-read and apply licenses after a license key partition update; note
+  * that this operation returns a zero-length response
+  */
+ #define          MC_CMD_LICENSING_V3_IN_OP_UPDATE_LICENSE  0x0
+ /* enum: report counts of installed licenses Returns EAGAIN if license
+  * processing (updating) has been started but not yet completed.
+  */
+ #define          MC_CMD_LICENSING_V3_IN_OP_REPORT_LICENSE  0x1
+ 
+ /* MC_CMD_LICENSING_V3_OUT msgresponse */
+ #define    MC_CMD_LICENSING_V3_OUT_LEN 88
+ /* count of keys which are valid */
+ #define       MC_CMD_LICENSING_V3_OUT_VALID_KEYS_OFST 0
+ /* sum of UNVERIFIABLE_KEYS + WRONG_NODE_KEYS (for compatibility with
+  * MC_CMD_FC_OP_LICENSE)
+  */
+ #define       MC_CMD_LICENSING_V3_OUT_INVALID_KEYS_OFST 4
+ /* count of keys which are invalid due to being unverifiable */
+ #define       MC_CMD_LICENSING_V3_OUT_UNVERIFIABLE_KEYS_OFST 8
+ /* count of keys which are invalid due to being for the wrong node */
+ #define       MC_CMD_LICENSING_V3_OUT_WRONG_NODE_KEYS_OFST 12
+ /* licensing state (for diagnostics; the exact meaning of the bits in this
+  * field are private to the firmware)
+  */
+ #define       MC_CMD_LICENSING_V3_OUT_LICENSING_STATE_OFST 16
+ /* licensing subsystem self-test report (for manftest) */
+ #define       MC_CMD_LICENSING_V3_OUT_LICENSING_SELF_TEST_OFST 20
+ /* enum: licensing subsystem self-test failed */
+ #define          MC_CMD_LICENSING_V3_OUT_SELF_TEST_FAIL  0x0
+ /* enum: licensing subsystem self-test passed */
+ #define          MC_CMD_LICENSING_V3_OUT_SELF_TEST_PASS  0x1
+ /* bitmask of licensed applications */
+ #define       MC_CMD_LICENSING_V3_OUT_LICENSED_APPS_OFST 24
+ #define       MC_CMD_LICENSING_V3_OUT_LICENSED_APPS_LEN 8
+ #define       MC_CMD_LICENSING_V3_OUT_LICENSED_APPS_LO_OFST 24
+ #define       MC_CMD_LICENSING_V3_OUT_LICENSED_APPS_HI_OFST 28
+ /* reserved for future use */
+ #define       MC_CMD_LICENSING_V3_OUT_RESERVED_0_OFST 32
+ #define       MC_CMD_LICENSING_V3_OUT_RESERVED_0_LEN 24
+ /* bitmask of licensed features */
+ #define       MC_CMD_LICENSING_V3_OUT_LICENSED_FEATURES_OFST 56
+ #define       MC_CMD_LICENSING_V3_OUT_LICENSED_FEATURES_LEN 8
+ #define       MC_CMD_LICENSING_V3_OUT_LICENSED_FEATURES_LO_OFST 56
+ #define       MC_CMD_LICENSING_V3_OUT_LICENSED_FEATURES_HI_OFST 60
+ /* reserved for future use */
+ #define       MC_CMD_LICENSING_V3_OUT_RESERVED_1_OFST 64
+ #define       MC_CMD_LICENSING_V3_OUT_RESERVED_1_LEN 24
+ 
+ 
+ /***********************************/
+ /* MC_CMD_LICENSING_GET_ID_V3
+  * Get ID and type from the NVRAM_PARTITION_TYPE_LICENSE application license
+  * partition - V3 licensing (Medford)
+  */
+ #define MC_CMD_LICENSING_GET_ID_V3 0xd1
+ 
+ #define MC_CMD_0xd1_PRIVILEGE_CTG SRIOV_CTG_GENERAL
+ 
+ /* MC_CMD_LICENSING_GET_ID_V3_IN msgrequest */
+ #define    MC_CMD_LICENSING_GET_ID_V3_IN_LEN 0
+ 
+ /* MC_CMD_LICENSING_GET_ID_V3_OUT msgresponse */
+ #define    MC_CMD_LICENSING_GET_ID_V3_OUT_LENMIN 8
+ #define    MC_CMD_LICENSING_GET_ID_V3_OUT_LENMAX 252
+ #define    MC_CMD_LICENSING_GET_ID_V3_OUT_LEN(num) (8+1*(num))
+ /* type of license (eg 3) */
+ #define       MC_CMD_LICENSING_GET_ID_V3_OUT_LICENSE_TYPE_OFST 0
+ /* length of the license ID (in bytes) */
+ #define       MC_CMD_LICENSING_GET_ID_V3_OUT_LICENSE_ID_LENGTH_OFST 4
+ /* the unique license ID of the adapter */
+ #define       MC_CMD_LICENSING_GET_ID_V3_OUT_LICENSE_ID_OFST 8
+ #define       MC_CMD_LICENSING_GET_ID_V3_OUT_LICENSE_ID_LEN 1
+ #define       MC_CMD_LICENSING_GET_ID_V3_OUT_LICENSE_ID_MINNUM 0
+ #define       MC_CMD_LICENSING_GET_ID_V3_OUT_LICENSE_ID_MAXNUM 244
+ 
+ 
+ /***********************************/
++>>>>>>> d29e33d6d087 (sfc: update MCDI protocol headers)
  /* MC_CMD_MC2MC_PROXY
   * Execute an arbitrary MCDI command on the slave MC of a dual-core device.
   * This will fail on a single-core system.
@@@ -8330,4 -10905,897 +9177,900 @@@
  #define       MC_CMD_GET_PORT_SNIFF_CONFIG_OUT_RX_CONTEXT_OFST 12
  
  
++<<<<<<< HEAD
++=======
+ /***********************************/
+ /* MC_CMD_SET_PARSER_DISP_CONFIG
+  * Change configuration related to the parser-dispatcher subsystem.
+  */
+ #define MC_CMD_SET_PARSER_DISP_CONFIG 0xf9
+ 
+ #define MC_CMD_0xf9_PRIVILEGE_CTG SRIOV_CTG_GENERAL
+ 
+ /* MC_CMD_SET_PARSER_DISP_CONFIG_IN msgrequest */
+ #define    MC_CMD_SET_PARSER_DISP_CONFIG_IN_LENMIN 12
+ #define    MC_CMD_SET_PARSER_DISP_CONFIG_IN_LENMAX 252
+ #define    MC_CMD_SET_PARSER_DISP_CONFIG_IN_LEN(num) (8+4*(num))
+ /* the type of configuration setting to change */
+ #define       MC_CMD_SET_PARSER_DISP_CONFIG_IN_TYPE_OFST 0
+ /* enum: Per-TXQ enable for multicast UDP destination lookup for possible
+  * internal loopback. (ENTITY is a queue handle, VALUE is a single boolean.)
+  */
+ #define          MC_CMD_SET_PARSER_DISP_CONFIG_IN_TXQ_MCAST_UDP_DST_LOOKUP_EN  0x0
+ /* enum: Per-v-adaptor enable for suppression of self-transmissions on the
+  * internal loopback path. (ENTITY is an EVB_PORT_ID, VALUE is a single
+  * boolean.)
+  */
+ #define          MC_CMD_SET_PARSER_DISP_CONFIG_IN_VADAPTOR_SUPPRESS_SELF_TX  0x1
+ /* handle for the entity to update: queue handle, EVB port ID, etc. depending
+  * on the type of configuration setting being changed
+  */
+ #define       MC_CMD_SET_PARSER_DISP_CONFIG_IN_ENTITY_OFST 4
+ /* new value: the details depend on the type of configuration setting being
+  * changed
+  */
+ #define       MC_CMD_SET_PARSER_DISP_CONFIG_IN_VALUE_OFST 8
+ #define       MC_CMD_SET_PARSER_DISP_CONFIG_IN_VALUE_LEN 4
+ #define       MC_CMD_SET_PARSER_DISP_CONFIG_IN_VALUE_MINNUM 1
+ #define       MC_CMD_SET_PARSER_DISP_CONFIG_IN_VALUE_MAXNUM 61
+ 
+ /* MC_CMD_SET_PARSER_DISP_CONFIG_OUT msgresponse */
+ #define    MC_CMD_SET_PARSER_DISP_CONFIG_OUT_LEN 0
+ 
+ 
+ /***********************************/
+ /* MC_CMD_GET_PARSER_DISP_CONFIG
+  * Read configuration related to the parser-dispatcher subsystem.
+  */
+ #define MC_CMD_GET_PARSER_DISP_CONFIG 0xfa
+ 
+ #define MC_CMD_0xfa_PRIVILEGE_CTG SRIOV_CTG_GENERAL
+ 
+ /* MC_CMD_GET_PARSER_DISP_CONFIG_IN msgrequest */
+ #define    MC_CMD_GET_PARSER_DISP_CONFIG_IN_LEN 8
+ /* the type of configuration setting to read */
+ #define       MC_CMD_GET_PARSER_DISP_CONFIG_IN_TYPE_OFST 0
+ /*            Enum values, see field(s): */
+ /*               MC_CMD_SET_PARSER_DISP_CONFIG/MC_CMD_SET_PARSER_DISP_CONFIG_IN/TYPE */
+ /* handle for the entity to query: queue handle, EVB port ID, etc. depending on
+  * the type of configuration setting being read
+  */
+ #define       MC_CMD_GET_PARSER_DISP_CONFIG_IN_ENTITY_OFST 4
+ 
+ /* MC_CMD_GET_PARSER_DISP_CONFIG_OUT msgresponse */
+ #define    MC_CMD_GET_PARSER_DISP_CONFIG_OUT_LENMIN 4
+ #define    MC_CMD_GET_PARSER_DISP_CONFIG_OUT_LENMAX 252
+ #define    MC_CMD_GET_PARSER_DISP_CONFIG_OUT_LEN(num) (0+4*(num))
+ /* current value: the details depend on the type of configuration setting being
+  * read
+  */
+ #define       MC_CMD_GET_PARSER_DISP_CONFIG_OUT_VALUE_OFST 0
+ #define       MC_CMD_GET_PARSER_DISP_CONFIG_OUT_VALUE_LEN 4
+ #define       MC_CMD_GET_PARSER_DISP_CONFIG_OUT_VALUE_MINNUM 1
+ #define       MC_CMD_GET_PARSER_DISP_CONFIG_OUT_VALUE_MAXNUM 63
+ 
+ 
+ /***********************************/
+ /* MC_CMD_SET_TX_PORT_SNIFF_CONFIG
+  * Configure TX port sniffing for the physical port associated with the calling
+  * function. Only a privileged function may change the port sniffing
+  * configuration. A copy of all traffic transmitted through the port may be
+  * delivered to a specific queue, or a set of queues with RSS. Note that these
+  * packets are delivered with transmit timestamps in the packet prefix, not
+  * receive timestamps, so it is likely that the queue(s) will need to be
+  * dedicated as TX sniff receivers.
+  */
+ #define MC_CMD_SET_TX_PORT_SNIFF_CONFIG 0xfb
+ 
+ #define MC_CMD_0xfb_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_SET_TX_PORT_SNIFF_CONFIG_IN msgrequest */
+ #define    MC_CMD_SET_TX_PORT_SNIFF_CONFIG_IN_LEN 16
+ /* configuration flags */
+ #define       MC_CMD_SET_TX_PORT_SNIFF_CONFIG_IN_FLAGS_OFST 0
+ #define        MC_CMD_SET_TX_PORT_SNIFF_CONFIG_IN_ENABLE_LBN 0
+ #define        MC_CMD_SET_TX_PORT_SNIFF_CONFIG_IN_ENABLE_WIDTH 1
+ /* receive queue handle (for RSS mode, this is the base queue) */
+ #define       MC_CMD_SET_TX_PORT_SNIFF_CONFIG_IN_RX_QUEUE_OFST 4
+ /* receive mode */
+ #define       MC_CMD_SET_TX_PORT_SNIFF_CONFIG_IN_RX_MODE_OFST 8
+ /* enum: receive to just the specified queue */
+ #define          MC_CMD_SET_TX_PORT_SNIFF_CONFIG_IN_RX_MODE_SIMPLE  0x0
+ /* enum: receive to multiple queues using RSS context */
+ #define          MC_CMD_SET_TX_PORT_SNIFF_CONFIG_IN_RX_MODE_RSS  0x1
+ /* RSS context (for RX_MODE_RSS) as returned by MC_CMD_RSS_CONTEXT_ALLOC. Note
+  * that these handles should be considered opaque to the host, although a value
+  * of 0xFFFFFFFF is guaranteed never to be a valid handle.
+  */
+ #define       MC_CMD_SET_TX_PORT_SNIFF_CONFIG_IN_RX_CONTEXT_OFST 12
+ 
+ /* MC_CMD_SET_TX_PORT_SNIFF_CONFIG_OUT msgresponse */
+ #define    MC_CMD_SET_TX_PORT_SNIFF_CONFIG_OUT_LEN 0
+ 
+ 
+ /***********************************/
+ /* MC_CMD_GET_TX_PORT_SNIFF_CONFIG
+  * Obtain the current TX port sniffing configuration for the physical port
+  * associated with the calling function. Only a privileged function may read
+  * the configuration.
+  */
+ #define MC_CMD_GET_TX_PORT_SNIFF_CONFIG 0xfc
+ 
+ #define MC_CMD_0xfc_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_GET_TX_PORT_SNIFF_CONFIG_IN msgrequest */
+ #define    MC_CMD_GET_TX_PORT_SNIFF_CONFIG_IN_LEN 0
+ 
+ /* MC_CMD_GET_TX_PORT_SNIFF_CONFIG_OUT msgresponse */
+ #define    MC_CMD_GET_TX_PORT_SNIFF_CONFIG_OUT_LEN 16
+ /* configuration flags */
+ #define       MC_CMD_GET_TX_PORT_SNIFF_CONFIG_OUT_FLAGS_OFST 0
+ #define        MC_CMD_GET_TX_PORT_SNIFF_CONFIG_OUT_ENABLE_LBN 0
+ #define        MC_CMD_GET_TX_PORT_SNIFF_CONFIG_OUT_ENABLE_WIDTH 1
+ /* receiving queue handle (for RSS mode, this is the base queue) */
+ #define       MC_CMD_GET_TX_PORT_SNIFF_CONFIG_OUT_RX_QUEUE_OFST 4
+ /* receive mode */
+ #define       MC_CMD_GET_TX_PORT_SNIFF_CONFIG_OUT_RX_MODE_OFST 8
+ /* enum: receiving to just the specified queue */
+ #define          MC_CMD_GET_TX_PORT_SNIFF_CONFIG_OUT_RX_MODE_SIMPLE  0x0
+ /* enum: receiving to multiple queues using RSS context */
+ #define          MC_CMD_GET_TX_PORT_SNIFF_CONFIG_OUT_RX_MODE_RSS  0x1
+ /* RSS context (for RX_MODE_RSS) */
+ #define       MC_CMD_GET_TX_PORT_SNIFF_CONFIG_OUT_RX_CONTEXT_OFST 12
+ 
+ 
+ /***********************************/
+ /* MC_CMD_RMON_STATS_RX_ERRORS
+  * Per queue rx error stats.
+  */
+ #define MC_CMD_RMON_STATS_RX_ERRORS 0xfe
+ 
+ #define MC_CMD_0xfe_PRIVILEGE_CTG SRIOV_CTG_GENERAL
+ 
+ /* MC_CMD_RMON_STATS_RX_ERRORS_IN msgrequest */
+ #define    MC_CMD_RMON_STATS_RX_ERRORS_IN_LEN 8
+ /* The rx queue to get stats for. */
+ #define       MC_CMD_RMON_STATS_RX_ERRORS_IN_RX_QUEUE_OFST 0
+ #define       MC_CMD_RMON_STATS_RX_ERRORS_IN_FLAGS_OFST 4
+ #define        MC_CMD_RMON_STATS_RX_ERRORS_IN_RST_LBN 0
+ #define        MC_CMD_RMON_STATS_RX_ERRORS_IN_RST_WIDTH 1
+ 
+ /* MC_CMD_RMON_STATS_RX_ERRORS_OUT msgresponse */
+ #define    MC_CMD_RMON_STATS_RX_ERRORS_OUT_LEN 16
+ #define       MC_CMD_RMON_STATS_RX_ERRORS_OUT_CRC_ERRORS_OFST 0
+ #define       MC_CMD_RMON_STATS_RX_ERRORS_OUT_TRUNC_ERRORS_OFST 4
+ #define       MC_CMD_RMON_STATS_RX_ERRORS_OUT_RX_NO_DESC_DROPS_OFST 8
+ #define       MC_CMD_RMON_STATS_RX_ERRORS_OUT_RX_ABORT_OFST 12
+ 
+ 
+ /***********************************/
+ /* MC_CMD_GET_PCIE_RESOURCE_INFO
+  * Find out about available PCIE resources
+  */
+ #define MC_CMD_GET_PCIE_RESOURCE_INFO 0xfd
+ 
+ /* MC_CMD_GET_PCIE_RESOURCE_INFO_IN msgrequest */
+ #define    MC_CMD_GET_PCIE_RESOURCE_INFO_IN_LEN 0
+ 
+ /* MC_CMD_GET_PCIE_RESOURCE_INFO_OUT msgresponse */
+ #define    MC_CMD_GET_PCIE_RESOURCE_INFO_OUT_LEN 28
+ /* The maximum number of PFs the device can expose */
+ #define       MC_CMD_GET_PCIE_RESOURCE_INFO_OUT_MAX_PFS_OFST 0
+ /* The maximum number of VFs the device can expose in total */
+ #define       MC_CMD_GET_PCIE_RESOURCE_INFO_OUT_MAX_VFS_OFST 4
+ /* The maximum number of MSI-X vectors the device can provide in total */
+ #define       MC_CMD_GET_PCIE_RESOURCE_INFO_OUT_MAX_VECTORS_OFST 8
+ /* the number of MSI-X vectors the device will allocate by default to each PF
+  */
+ #define       MC_CMD_GET_PCIE_RESOURCE_INFO_OUT_DEFAULT_PF_VECTORS_OFST 12
+ /* the number of MSI-X vectors the device will allocate by default to each VF
+  */
+ #define       MC_CMD_GET_PCIE_RESOURCE_INFO_OUT_DEFAULT_VF_VECTORS_OFST 16
+ /* the maximum number of MSI-X vectors the device can allocate to any one PF */
+ #define       MC_CMD_GET_PCIE_RESOURCE_INFO_OUT_MAX_PF_VECTORS_OFST 20
+ /* the maximum number of MSI-X vectors the device can allocate to any one VF */
+ #define       MC_CMD_GET_PCIE_RESOURCE_INFO_OUT_MAX_VF_VECTORS_OFST 24
+ 
+ 
+ /***********************************/
+ /* MC_CMD_GET_PORT_MODES
+  * Find out about available port modes
+  */
+ #define MC_CMD_GET_PORT_MODES 0xff
+ 
+ #define MC_CMD_0xff_PRIVILEGE_CTG SRIOV_CTG_GENERAL
+ 
+ /* MC_CMD_GET_PORT_MODES_IN msgrequest */
+ #define    MC_CMD_GET_PORT_MODES_IN_LEN 0
+ 
+ /* MC_CMD_GET_PORT_MODES_OUT msgresponse */
+ #define    MC_CMD_GET_PORT_MODES_OUT_LEN 12
+ /* Bitmask of port modes available on the board (indexed by TLV_PORT_MODE_*) */
+ #define       MC_CMD_GET_PORT_MODES_OUT_MODES_OFST 0
+ /* Default (canonical) board mode */
+ #define       MC_CMD_GET_PORT_MODES_OUT_DEFAULT_MODE_OFST 4
+ /* Current board mode */
+ #define       MC_CMD_GET_PORT_MODES_OUT_CURRENT_MODE_OFST 8
+ 
+ 
+ /***********************************/
+ /* MC_CMD_READ_ATB
+  * Sample voltages on the ATB
+  */
+ #define MC_CMD_READ_ATB 0x100
+ 
+ #define MC_CMD_0x100_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_READ_ATB_IN msgrequest */
+ #define    MC_CMD_READ_ATB_IN_LEN 16
+ #define       MC_CMD_READ_ATB_IN_SIGNAL_BUS_OFST 0
+ #define          MC_CMD_READ_ATB_IN_BUS_CCOM  0x0 /* enum */
+ #define          MC_CMD_READ_ATB_IN_BUS_CKR  0x1 /* enum */
+ #define          MC_CMD_READ_ATB_IN_BUS_CPCIE  0x8 /* enum */
+ #define       MC_CMD_READ_ATB_IN_SIGNAL_EN_BITNO_OFST 4
+ #define       MC_CMD_READ_ATB_IN_SIGNAL_SEL_OFST 8
+ #define       MC_CMD_READ_ATB_IN_SETTLING_TIME_US_OFST 12
+ 
+ /* MC_CMD_READ_ATB_OUT msgresponse */
+ #define    MC_CMD_READ_ATB_OUT_LEN 4
+ #define       MC_CMD_READ_ATB_OUT_SAMPLE_MV_OFST 0
+ 
+ 
+ /***********************************/
+ /* MC_CMD_GET_WORKAROUNDS
+  * Read the list of all implemented and all currently enabled workarounds. The
+  * enums here must correspond with those in MC_CMD_WORKAROUND.
+  */
+ #define MC_CMD_GET_WORKAROUNDS 0x59
+ 
+ #define MC_CMD_0x59_PRIVILEGE_CTG SRIOV_CTG_GENERAL
+ 
+ /* MC_CMD_GET_WORKAROUNDS_OUT msgresponse */
+ #define    MC_CMD_GET_WORKAROUNDS_OUT_LEN 8
+ /* Each workaround is represented by a single bit according to the enums below.
+  */
+ #define       MC_CMD_GET_WORKAROUNDS_OUT_IMPLEMENTED_OFST 0
+ #define       MC_CMD_GET_WORKAROUNDS_OUT_ENABLED_OFST 4
+ /* enum: Bug 17230 work around. */
+ #define          MC_CMD_GET_WORKAROUNDS_OUT_BUG17230 0x2
+ /* enum: Bug 35388 work around (unsafe EVQ writes). */
+ #define          MC_CMD_GET_WORKAROUNDS_OUT_BUG35388 0x4
+ /* enum: Bug35017 workaround (A64 tables must be identity map) */
+ #define          MC_CMD_GET_WORKAROUNDS_OUT_BUG35017 0x8
+ /* enum: Bug 41750 present (MC_CMD_TRIGGER_INTERRUPT won't work) */
+ #define          MC_CMD_GET_WORKAROUNDS_OUT_BUG41750 0x10
+ /* enum: Bug 42008 present (Interrupts can overtake associated events). Caution
+  * - before adding code that queries this workaround, remember that there's
+  * released Monza firmware that doesn't understand MC_CMD_WORKAROUND_BUG42008,
+  * and will hence (incorrectly) report that the bug doesn't exist.
+  */
+ #define          MC_CMD_GET_WORKAROUNDS_OUT_BUG42008 0x20
+ /* enum: Bug 26807 features present in firmware (multicast filter chaining) */
+ #define          MC_CMD_GET_WORKAROUNDS_OUT_BUG26807 0x40
+ /* enum: Bug 61265 work around (broken EVQ TMR writes). */
+ #define          MC_CMD_GET_WORKAROUNDS_OUT_BUG61265 0x80
+ 
+ 
+ /***********************************/
+ /* MC_CMD_PRIVILEGE_MASK
+  * Read/set privileges of an arbitrary PCIe function
+  */
+ #define MC_CMD_PRIVILEGE_MASK 0x5a
+ 
+ #define MC_CMD_0x5a_PRIVILEGE_CTG SRIOV_CTG_GENERAL
+ 
+ /* MC_CMD_PRIVILEGE_MASK_IN msgrequest */
+ #define    MC_CMD_PRIVILEGE_MASK_IN_LEN 8
+ /* The target function to have its mask read or set e.g. PF 0 = 0xFFFF0000, VF
+  * 1,3 = 0x00030001
+  */
+ #define       MC_CMD_PRIVILEGE_MASK_IN_FUNCTION_OFST 0
+ #define        MC_CMD_PRIVILEGE_MASK_IN_FUNCTION_PF_LBN 0
+ #define        MC_CMD_PRIVILEGE_MASK_IN_FUNCTION_PF_WIDTH 16
+ #define        MC_CMD_PRIVILEGE_MASK_IN_FUNCTION_VF_LBN 16
+ #define        MC_CMD_PRIVILEGE_MASK_IN_FUNCTION_VF_WIDTH 16
+ #define          MC_CMD_PRIVILEGE_MASK_IN_VF_NULL  0xffff /* enum */
+ /* New privilege mask to be set. The mask will only be changed if the MSB is
+  * set to 1.
+  */
+ #define       MC_CMD_PRIVILEGE_MASK_IN_NEW_MASK_OFST 4
+ #define          MC_CMD_PRIVILEGE_MASK_IN_GRP_ADMIN             0x1 /* enum */
+ #define          MC_CMD_PRIVILEGE_MASK_IN_GRP_LINK              0x2 /* enum */
+ #define          MC_CMD_PRIVILEGE_MASK_IN_GRP_ONLOAD            0x4 /* enum */
+ #define          MC_CMD_PRIVILEGE_MASK_IN_GRP_PTP               0x8 /* enum */
+ #define          MC_CMD_PRIVILEGE_MASK_IN_GRP_INSECURE_FILTERS  0x10 /* enum */
+ /* enum: Deprecated. Equivalent to MAC_SPOOFING_TX combined with CHANGE_MAC. */
+ #define          MC_CMD_PRIVILEGE_MASK_IN_GRP_MAC_SPOOFING      0x20
+ #define          MC_CMD_PRIVILEGE_MASK_IN_GRP_UNICAST           0x40 /* enum */
+ #define          MC_CMD_PRIVILEGE_MASK_IN_GRP_MULTICAST         0x80 /* enum */
+ #define          MC_CMD_PRIVILEGE_MASK_IN_GRP_BROADCAST         0x100 /* enum */
+ #define          MC_CMD_PRIVILEGE_MASK_IN_GRP_ALL_MULTICAST     0x200 /* enum */
+ #define          MC_CMD_PRIVILEGE_MASK_IN_GRP_PROMISCUOUS       0x400 /* enum */
+ /* enum: Allows to set the TX packets' source MAC address to any arbitrary MAC
+  * adress.
+  */
+ #define          MC_CMD_PRIVILEGE_MASK_IN_GRP_MAC_SPOOFING_TX   0x800
+ /* enum: Privilege that allows a Function to change the MAC address configured
+  * in its associated vAdapter/vPort.
+  */
+ #define          MC_CMD_PRIVILEGE_MASK_IN_GRP_CHANGE_MAC        0x1000
+ /* enum: Privilege that allows a Function to install filters that specify VLANs
+  * that are not in the permit list for the associated vPort. This privilege is
+  * primarily to support ESX where vPorts are created that restrict traffic to
+  * only a set of permitted VLANs. See the vPort flag FLAG_VLAN_RESTRICT.
+  */
+ #define          MC_CMD_PRIVILEGE_MASK_IN_GRP_UNRESTRICTED_VLAN  0x2000
+ /* enum: Set this bit to indicate that a new privilege mask is to be set,
+  * otherwise the command will only read the existing mask.
+  */
+ #define          MC_CMD_PRIVILEGE_MASK_IN_DO_CHANGE             0x80000000
+ 
+ /* MC_CMD_PRIVILEGE_MASK_OUT msgresponse */
+ #define    MC_CMD_PRIVILEGE_MASK_OUT_LEN 4
+ /* For an admin function, always all the privileges are reported. */
+ #define       MC_CMD_PRIVILEGE_MASK_OUT_OLD_MASK_OFST 0
+ 
+ 
+ /***********************************/
+ /* MC_CMD_LINK_STATE_MODE
+  * Read/set link state mode of a VF
+  */
+ #define MC_CMD_LINK_STATE_MODE 0x5c
+ 
+ #define MC_CMD_0x5c_PRIVILEGE_CTG SRIOV_CTG_GENERAL
+ 
+ /* MC_CMD_LINK_STATE_MODE_IN msgrequest */
+ #define    MC_CMD_LINK_STATE_MODE_IN_LEN 8
+ /* The target function to have its link state mode read or set, must be a VF
+  * e.g. VF 1,3 = 0x00030001
+  */
+ #define       MC_CMD_LINK_STATE_MODE_IN_FUNCTION_OFST 0
+ #define        MC_CMD_LINK_STATE_MODE_IN_FUNCTION_PF_LBN 0
+ #define        MC_CMD_LINK_STATE_MODE_IN_FUNCTION_PF_WIDTH 16
+ #define        MC_CMD_LINK_STATE_MODE_IN_FUNCTION_VF_LBN 16
+ #define        MC_CMD_LINK_STATE_MODE_IN_FUNCTION_VF_WIDTH 16
+ /* New link state mode to be set */
+ #define       MC_CMD_LINK_STATE_MODE_IN_NEW_MODE_OFST 4
+ #define          MC_CMD_LINK_STATE_MODE_IN_LINK_STATE_AUTO       0x0 /* enum */
+ #define          MC_CMD_LINK_STATE_MODE_IN_LINK_STATE_UP         0x1 /* enum */
+ #define          MC_CMD_LINK_STATE_MODE_IN_LINK_STATE_DOWN       0x2 /* enum */
+ /* enum: Use this value to just read the existing setting without modifying it.
+  */
+ #define          MC_CMD_LINK_STATE_MODE_IN_DO_NOT_CHANGE         0xffffffff
+ 
+ /* MC_CMD_LINK_STATE_MODE_OUT msgresponse */
+ #define    MC_CMD_LINK_STATE_MODE_OUT_LEN 4
+ #define       MC_CMD_LINK_STATE_MODE_OUT_OLD_MODE_OFST 0
+ 
+ 
+ /***********************************/
+ /* MC_CMD_GET_SNAPSHOT_LENGTH
+  * Obtain the curent range of allowable values for the SNAPSHOT_LENGTH
+  * parameter to MC_CMD_INIT_RXQ.
+  */
+ #define MC_CMD_GET_SNAPSHOT_LENGTH 0x101
+ 
+ #define MC_CMD_0x101_PRIVILEGE_CTG SRIOV_CTG_GENERAL
+ 
+ /* MC_CMD_GET_SNAPSHOT_LENGTH_IN msgrequest */
+ #define    MC_CMD_GET_SNAPSHOT_LENGTH_IN_LEN 0
+ 
+ /* MC_CMD_GET_SNAPSHOT_LENGTH_OUT msgresponse */
+ #define    MC_CMD_GET_SNAPSHOT_LENGTH_OUT_LEN 8
+ /* Minimum acceptable snapshot length. */
+ #define       MC_CMD_GET_SNAPSHOT_LENGTH_OUT_RX_SNAPLEN_MIN_OFST 0
+ /* Maximum acceptable snapshot length. */
+ #define       MC_CMD_GET_SNAPSHOT_LENGTH_OUT_RX_SNAPLEN_MAX_OFST 4
+ 
+ 
+ /***********************************/
+ /* MC_CMD_FUSE_DIAGS
+  * Additional fuse diagnostics
+  */
+ #define MC_CMD_FUSE_DIAGS 0x102
+ 
+ #define MC_CMD_0x102_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_FUSE_DIAGS_IN msgrequest */
+ #define    MC_CMD_FUSE_DIAGS_IN_LEN 0
+ 
+ /* MC_CMD_FUSE_DIAGS_OUT msgresponse */
+ #define    MC_CMD_FUSE_DIAGS_OUT_LEN 48
+ /* Total number of mismatched bits between pairs in area 0 */
+ #define       MC_CMD_FUSE_DIAGS_OUT_AREA0_MISMATCH_BITS_OFST 0
+ /* Total number of unexpectedly clear (set in B but not A) bits in area 0 */
+ #define       MC_CMD_FUSE_DIAGS_OUT_AREA0_PAIR_A_BAD_BITS_OFST 4
+ /* Total number of unexpectedly clear (set in A but not B) bits in area 0 */
+ #define       MC_CMD_FUSE_DIAGS_OUT_AREA0_PAIR_B_BAD_BITS_OFST 8
+ /* Checksum of data after logical OR of pairs in area 0 */
+ #define       MC_CMD_FUSE_DIAGS_OUT_AREA0_CHECKSUM_OFST 12
+ /* Total number of mismatched bits between pairs in area 1 */
+ #define       MC_CMD_FUSE_DIAGS_OUT_AREA1_MISMATCH_BITS_OFST 16
+ /* Total number of unexpectedly clear (set in B but not A) bits in area 1 */
+ #define       MC_CMD_FUSE_DIAGS_OUT_AREA1_PAIR_A_BAD_BITS_OFST 20
+ /* Total number of unexpectedly clear (set in A but not B) bits in area 1 */
+ #define       MC_CMD_FUSE_DIAGS_OUT_AREA1_PAIR_B_BAD_BITS_OFST 24
+ /* Checksum of data after logical OR of pairs in area 1 */
+ #define       MC_CMD_FUSE_DIAGS_OUT_AREA1_CHECKSUM_OFST 28
+ /* Total number of mismatched bits between pairs in area 2 */
+ #define       MC_CMD_FUSE_DIAGS_OUT_AREA2_MISMATCH_BITS_OFST 32
+ /* Total number of unexpectedly clear (set in B but not A) bits in area 2 */
+ #define       MC_CMD_FUSE_DIAGS_OUT_AREA2_PAIR_A_BAD_BITS_OFST 36
+ /* Total number of unexpectedly clear (set in A but not B) bits in area 2 */
+ #define       MC_CMD_FUSE_DIAGS_OUT_AREA2_PAIR_B_BAD_BITS_OFST 40
+ /* Checksum of data after logical OR of pairs in area 2 */
+ #define       MC_CMD_FUSE_DIAGS_OUT_AREA2_CHECKSUM_OFST 44
+ 
+ 
+ /***********************************/
+ /* MC_CMD_PRIVILEGE_MODIFY
+  * Modify the privileges of a set of PCIe functions. Note that this operation
+  * only effects non-admin functions unless the admin privilege itself is
+  * included in one of the masks provided.
+  */
+ #define MC_CMD_PRIVILEGE_MODIFY 0x60
+ 
+ #define MC_CMD_0x60_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_PRIVILEGE_MODIFY_IN msgrequest */
+ #define    MC_CMD_PRIVILEGE_MODIFY_IN_LEN 16
+ /* The groups of functions to have their privilege masks modified. */
+ #define       MC_CMD_PRIVILEGE_MODIFY_IN_FN_GROUP_OFST 0
+ #define          MC_CMD_PRIVILEGE_MODIFY_IN_NONE       0x0 /* enum */
+ #define          MC_CMD_PRIVILEGE_MODIFY_IN_ALL        0x1 /* enum */
+ #define          MC_CMD_PRIVILEGE_MODIFY_IN_PFS_ONLY   0x2 /* enum */
+ #define          MC_CMD_PRIVILEGE_MODIFY_IN_VFS_ONLY   0x3 /* enum */
+ #define          MC_CMD_PRIVILEGE_MODIFY_IN_VFS_OF_PF  0x4 /* enum */
+ #define          MC_CMD_PRIVILEGE_MODIFY_IN_ONE        0x5 /* enum */
+ /* For VFS_OF_PF specify the PF, for ONE specify the target function */
+ #define       MC_CMD_PRIVILEGE_MODIFY_IN_FUNCTION_OFST 4
+ #define        MC_CMD_PRIVILEGE_MODIFY_IN_FUNCTION_PF_LBN 0
+ #define        MC_CMD_PRIVILEGE_MODIFY_IN_FUNCTION_PF_WIDTH 16
+ #define        MC_CMD_PRIVILEGE_MODIFY_IN_FUNCTION_VF_LBN 16
+ #define        MC_CMD_PRIVILEGE_MODIFY_IN_FUNCTION_VF_WIDTH 16
+ /* Privileges to be added to the target functions. For privilege definitions
+  * refer to the command MC_CMD_PRIVILEGE_MASK
+  */
+ #define       MC_CMD_PRIVILEGE_MODIFY_IN_ADD_MASK_OFST 8
+ /* Privileges to be removed from the target functions. For privilege
+  * definitions refer to the command MC_CMD_PRIVILEGE_MASK
+  */
+ #define       MC_CMD_PRIVILEGE_MODIFY_IN_REMOVE_MASK_OFST 12
+ 
+ /* MC_CMD_PRIVILEGE_MODIFY_OUT msgresponse */
+ #define    MC_CMD_PRIVILEGE_MODIFY_OUT_LEN 0
+ 
+ 
+ /***********************************/
+ /* MC_CMD_XPM_READ_BYTES
+  * Read XPM memory
+  */
+ #define MC_CMD_XPM_READ_BYTES 0x103
+ 
+ #define MC_CMD_0x103_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_XPM_READ_BYTES_IN msgrequest */
+ #define    MC_CMD_XPM_READ_BYTES_IN_LEN 8
+ /* Start address (byte) */
+ #define       MC_CMD_XPM_READ_BYTES_IN_ADDR_OFST 0
+ /* Count (bytes) */
+ #define       MC_CMD_XPM_READ_BYTES_IN_COUNT_OFST 4
+ 
+ /* MC_CMD_XPM_READ_BYTES_OUT msgresponse */
+ #define    MC_CMD_XPM_READ_BYTES_OUT_LENMIN 0
+ #define    MC_CMD_XPM_READ_BYTES_OUT_LENMAX 252
+ #define    MC_CMD_XPM_READ_BYTES_OUT_LEN(num) (0+1*(num))
+ /* Data */
+ #define       MC_CMD_XPM_READ_BYTES_OUT_DATA_OFST 0
+ #define       MC_CMD_XPM_READ_BYTES_OUT_DATA_LEN 1
+ #define       MC_CMD_XPM_READ_BYTES_OUT_DATA_MINNUM 0
+ #define       MC_CMD_XPM_READ_BYTES_OUT_DATA_MAXNUM 252
+ 
+ 
+ /***********************************/
+ /* MC_CMD_XPM_WRITE_BYTES
+  * Write XPM memory
+  */
+ #define MC_CMD_XPM_WRITE_BYTES 0x104
+ 
+ #define MC_CMD_0x104_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_XPM_WRITE_BYTES_IN msgrequest */
+ #define    MC_CMD_XPM_WRITE_BYTES_IN_LENMIN 8
+ #define    MC_CMD_XPM_WRITE_BYTES_IN_LENMAX 252
+ #define    MC_CMD_XPM_WRITE_BYTES_IN_LEN(num) (8+1*(num))
+ /* Start address (byte) */
+ #define       MC_CMD_XPM_WRITE_BYTES_IN_ADDR_OFST 0
+ /* Count (bytes) */
+ #define       MC_CMD_XPM_WRITE_BYTES_IN_COUNT_OFST 4
+ /* Data */
+ #define       MC_CMD_XPM_WRITE_BYTES_IN_DATA_OFST 8
+ #define       MC_CMD_XPM_WRITE_BYTES_IN_DATA_LEN 1
+ #define       MC_CMD_XPM_WRITE_BYTES_IN_DATA_MINNUM 0
+ #define       MC_CMD_XPM_WRITE_BYTES_IN_DATA_MAXNUM 244
+ 
+ /* MC_CMD_XPM_WRITE_BYTES_OUT msgresponse */
+ #define    MC_CMD_XPM_WRITE_BYTES_OUT_LEN 0
+ 
+ 
+ /***********************************/
+ /* MC_CMD_XPM_READ_SECTOR
+  * Read XPM sector
+  */
+ #define MC_CMD_XPM_READ_SECTOR 0x105
+ 
+ #define MC_CMD_0x105_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_XPM_READ_SECTOR_IN msgrequest */
+ #define    MC_CMD_XPM_READ_SECTOR_IN_LEN 8
+ /* Sector index */
+ #define       MC_CMD_XPM_READ_SECTOR_IN_INDEX_OFST 0
+ /* Sector size */
+ #define       MC_CMD_XPM_READ_SECTOR_IN_SIZE_OFST 4
+ 
+ /* MC_CMD_XPM_READ_SECTOR_OUT msgresponse */
+ #define    MC_CMD_XPM_READ_SECTOR_OUT_LENMIN 4
+ #define    MC_CMD_XPM_READ_SECTOR_OUT_LENMAX 36
+ #define    MC_CMD_XPM_READ_SECTOR_OUT_LEN(num) (4+1*(num))
+ /* Sector type */
+ #define       MC_CMD_XPM_READ_SECTOR_OUT_TYPE_OFST 0
+ #define          MC_CMD_XPM_READ_SECTOR_OUT_BLANK            0x0 /* enum */
+ #define          MC_CMD_XPM_READ_SECTOR_OUT_CRYPTO_KEY_128   0x1 /* enum */
+ #define          MC_CMD_XPM_READ_SECTOR_OUT_CRYPTO_KEY_256   0x2 /* enum */
+ #define          MC_CMD_XPM_READ_SECTOR_OUT_INVALID          0xff /* enum */
+ /* Sector data */
+ #define       MC_CMD_XPM_READ_SECTOR_OUT_DATA_OFST 4
+ #define       MC_CMD_XPM_READ_SECTOR_OUT_DATA_LEN 1
+ #define       MC_CMD_XPM_READ_SECTOR_OUT_DATA_MINNUM 0
+ #define       MC_CMD_XPM_READ_SECTOR_OUT_DATA_MAXNUM 32
+ 
+ 
+ /***********************************/
+ /* MC_CMD_XPM_WRITE_SECTOR
+  * Write XPM sector
+  */
+ #define MC_CMD_XPM_WRITE_SECTOR 0x106
+ 
+ #define MC_CMD_0x106_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_XPM_WRITE_SECTOR_IN msgrequest */
+ #define    MC_CMD_XPM_WRITE_SECTOR_IN_LENMIN 12
+ #define    MC_CMD_XPM_WRITE_SECTOR_IN_LENMAX 44
+ #define    MC_CMD_XPM_WRITE_SECTOR_IN_LEN(num) (12+1*(num))
+ /* If writing fails due to an uncorrectable error, try up to RETRIES following
+  * sectors (or until no more space available). If 0, only one write attempt is
+  * made. Note that uncorrectable errors are unlikely, thanks to XPM self-repair
+  * mechanism.
+  */
+ #define       MC_CMD_XPM_WRITE_SECTOR_IN_RETRIES_OFST 0
+ #define       MC_CMD_XPM_WRITE_SECTOR_IN_RETRIES_LEN 1
+ #define       MC_CMD_XPM_WRITE_SECTOR_IN_RESERVED_OFST 1
+ #define       MC_CMD_XPM_WRITE_SECTOR_IN_RESERVED_LEN 3
+ /* Sector type */
+ #define       MC_CMD_XPM_WRITE_SECTOR_IN_TYPE_OFST 4
+ /*            Enum values, see field(s): */
+ /*               MC_CMD_XPM_READ_SECTOR/MC_CMD_XPM_READ_SECTOR_OUT/TYPE */
+ /* Sector size */
+ #define       MC_CMD_XPM_WRITE_SECTOR_IN_SIZE_OFST 8
+ /* Sector data */
+ #define       MC_CMD_XPM_WRITE_SECTOR_IN_DATA_OFST 12
+ #define       MC_CMD_XPM_WRITE_SECTOR_IN_DATA_LEN 1
+ #define       MC_CMD_XPM_WRITE_SECTOR_IN_DATA_MINNUM 0
+ #define       MC_CMD_XPM_WRITE_SECTOR_IN_DATA_MAXNUM 32
+ 
+ /* MC_CMD_XPM_WRITE_SECTOR_OUT msgresponse */
+ #define    MC_CMD_XPM_WRITE_SECTOR_OUT_LEN 4
+ /* New sector index */
+ #define       MC_CMD_XPM_WRITE_SECTOR_OUT_INDEX_OFST 0
+ 
+ 
+ /***********************************/
+ /* MC_CMD_XPM_INVALIDATE_SECTOR
+  * Invalidate XPM sector
+  */
+ #define MC_CMD_XPM_INVALIDATE_SECTOR 0x107
+ 
+ #define MC_CMD_0x107_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_XPM_INVALIDATE_SECTOR_IN msgrequest */
+ #define    MC_CMD_XPM_INVALIDATE_SECTOR_IN_LEN 4
+ /* Sector index */
+ #define       MC_CMD_XPM_INVALIDATE_SECTOR_IN_INDEX_OFST 0
+ 
+ /* MC_CMD_XPM_INVALIDATE_SECTOR_OUT msgresponse */
+ #define    MC_CMD_XPM_INVALIDATE_SECTOR_OUT_LEN 0
+ 
+ 
+ /***********************************/
+ /* MC_CMD_XPM_BLANK_CHECK
+  * Blank-check XPM memory and report bad locations
+  */
+ #define MC_CMD_XPM_BLANK_CHECK 0x108
+ 
+ #define MC_CMD_0x108_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_XPM_BLANK_CHECK_IN msgrequest */
+ #define    MC_CMD_XPM_BLANK_CHECK_IN_LEN 8
+ /* Start address (byte) */
+ #define       MC_CMD_XPM_BLANK_CHECK_IN_ADDR_OFST 0
+ /* Count (bytes) */
+ #define       MC_CMD_XPM_BLANK_CHECK_IN_COUNT_OFST 4
+ 
+ /* MC_CMD_XPM_BLANK_CHECK_OUT msgresponse */
+ #define    MC_CMD_XPM_BLANK_CHECK_OUT_LENMIN 4
+ #define    MC_CMD_XPM_BLANK_CHECK_OUT_LENMAX 252
+ #define    MC_CMD_XPM_BLANK_CHECK_OUT_LEN(num) (4+2*(num))
+ /* Total number of bad (non-blank) locations */
+ #define       MC_CMD_XPM_BLANK_CHECK_OUT_BAD_COUNT_OFST 0
+ /* Addresses of bad locations (may be less than BAD_COUNT, if all cannot fit
+  * into MCDI response)
+  */
+ #define       MC_CMD_XPM_BLANK_CHECK_OUT_BAD_ADDR_OFST 4
+ #define       MC_CMD_XPM_BLANK_CHECK_OUT_BAD_ADDR_LEN 2
+ #define       MC_CMD_XPM_BLANK_CHECK_OUT_BAD_ADDR_MINNUM 0
+ #define       MC_CMD_XPM_BLANK_CHECK_OUT_BAD_ADDR_MAXNUM 124
+ 
+ 
+ /***********************************/
+ /* MC_CMD_XPM_REPAIR
+  * Blank-check and repair XPM memory
+  */
+ #define MC_CMD_XPM_REPAIR 0x109
+ 
+ #define MC_CMD_0x109_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_XPM_REPAIR_IN msgrequest */
+ #define    MC_CMD_XPM_REPAIR_IN_LEN 8
+ /* Start address (byte) */
+ #define       MC_CMD_XPM_REPAIR_IN_ADDR_OFST 0
+ /* Count (bytes) */
+ #define       MC_CMD_XPM_REPAIR_IN_COUNT_OFST 4
+ 
+ /* MC_CMD_XPM_REPAIR_OUT msgresponse */
+ #define    MC_CMD_XPM_REPAIR_OUT_LEN 0
+ 
+ 
+ /***********************************/
+ /* MC_CMD_XPM_DECODER_TEST
+  * Test XPM memory address decoders for gross manufacturing defects. Can only
+  * be performed on an unprogrammed part.
+  */
+ #define MC_CMD_XPM_DECODER_TEST 0x10a
+ 
+ #define MC_CMD_0x10a_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_XPM_DECODER_TEST_IN msgrequest */
+ #define    MC_CMD_XPM_DECODER_TEST_IN_LEN 0
+ 
+ /* MC_CMD_XPM_DECODER_TEST_OUT msgresponse */
+ #define    MC_CMD_XPM_DECODER_TEST_OUT_LEN 0
+ 
+ 
+ /***********************************/
+ /* MC_CMD_XPM_WRITE_TEST
+  * XPM memory write test. Test XPM write logic for gross manufacturing defects
+  * by writing to a dedicated test row. There are 16 locations in the test row
+  * and the test can only be performed on locations that have not been
+  * previously used (i.e. can be run at most 16 times). The test will pick the
+  * first available location to use, or fail with ENOSPC if none left.
+  */
+ #define MC_CMD_XPM_WRITE_TEST 0x10b
+ 
+ #define MC_CMD_0x10b_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_XPM_WRITE_TEST_IN msgrequest */
+ #define    MC_CMD_XPM_WRITE_TEST_IN_LEN 0
+ 
+ /* MC_CMD_XPM_WRITE_TEST_OUT msgresponse */
+ #define    MC_CMD_XPM_WRITE_TEST_OUT_LEN 0
+ 
+ 
+ /***********************************/
+ /* MC_CMD_EXEC_SIGNED
+  * Check the CMAC of the contents of IMEM and DMEM against the value supplied
+  * and if correct begin execution from the start of IMEM. The caller supplies a
+  * key ID, the length of IMEM and DMEM to validate and the expected CMAC. CMAC
+  * computation runs from the start of IMEM, and from the start of DMEM + 16k,
+  * to match flash booting. The command will respond with EINVAL if the CMAC
+  * does match, otherwise it will respond with success before it jumps to IMEM.
+  */
+ #define MC_CMD_EXEC_SIGNED 0x10c
+ 
+ #define MC_CMD_0x10c_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_EXEC_SIGNED_IN msgrequest */
+ #define    MC_CMD_EXEC_SIGNED_IN_LEN 28
+ /* the length of code to include in the CMAC */
+ #define       MC_CMD_EXEC_SIGNED_IN_CODELEN_OFST 0
+ /* the length of date to include in the CMAC */
+ #define       MC_CMD_EXEC_SIGNED_IN_DATALEN_OFST 4
+ /* the XPM sector containing the key to use */
+ #define       MC_CMD_EXEC_SIGNED_IN_KEYSECTOR_OFST 8
+ /* the expected CMAC value */
+ #define       MC_CMD_EXEC_SIGNED_IN_CMAC_OFST 12
+ #define       MC_CMD_EXEC_SIGNED_IN_CMAC_LEN 16
+ 
+ /* MC_CMD_EXEC_SIGNED_OUT msgresponse */
+ #define    MC_CMD_EXEC_SIGNED_OUT_LEN 0
+ 
+ 
+ /***********************************/
+ /* MC_CMD_PREPARE_SIGNED
+  * Prepare to upload a signed image. This will scrub the specified length of
+  * the data region, which must be at least as large as the DATALEN supplied to
+  * MC_CMD_EXEC_SIGNED.
+  */
+ #define MC_CMD_PREPARE_SIGNED 0x10d
+ 
+ #define MC_CMD_0x10d_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_PREPARE_SIGNED_IN msgrequest */
+ #define    MC_CMD_PREPARE_SIGNED_IN_LEN 4
+ /* the length of data area to clear */
+ #define       MC_CMD_PREPARE_SIGNED_IN_DATALEN_OFST 0
+ 
+ /* MC_CMD_PREPARE_SIGNED_OUT msgresponse */
+ #define    MC_CMD_PREPARE_SIGNED_OUT_LEN 0
+ 
+ 
+ /***********************************/
+ /* MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS
+  * Configure UDP ports for tunnel encapsulation hardware acceleration. The
+  * parser-dispatcher will attempt to parse traffic on these ports as tunnel
+  * encapsulation PDUs and filter them using the tunnel encapsulation filter
+  * chain rather than the standard filter chain. Note that this command can
+  * cause all functions to see a reset. (Available on Medford only.)
+  */
+ #define MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS 0x117
+ 
+ #define MC_CMD_0x117_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN msgrequest */
+ #define    MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_LENMIN 4
+ #define    MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_LENMAX 68
+ #define    MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_LEN(num) (4+4*(num))
+ /* Flags */
+ #define       MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_FLAGS_OFST 0
+ #define       MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_FLAGS_LEN 2
+ #define        MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_UNLOADING_LBN 0
+ #define        MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_UNLOADING_WIDTH 1
+ /* The number of entries in the ENTRIES array */
+ #define       MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_NUM_ENTRIES_OFST 2
+ #define       MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_NUM_ENTRIES_LEN 2
+ /* Entries defining the UDP port to protocol mapping, each laid out as a
+  * TUNNEL_ENCAP_UDP_PORT_ENTRY
+  */
+ #define       MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_ENTRIES_OFST 4
+ #define       MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_ENTRIES_LEN 4
+ #define       MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_ENTRIES_MINNUM 0
+ #define       MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_IN_ENTRIES_MAXNUM 16
+ 
+ /* MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_OUT msgresponse */
+ #define    MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_OUT_LEN 2
+ /* Flags */
+ #define       MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_OUT_FLAGS_OFST 0
+ #define       MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_OUT_FLAGS_LEN 2
+ #define        MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_OUT_RESETTING_LBN 0
+ #define        MC_CMD_SET_TUNNEL_ENCAP_UDP_PORTS_OUT_RESETTING_WIDTH 1
+ 
+ 
+ /***********************************/
+ /* MC_CMD_RX_BALANCING
+  * Configure a port upconverter to distribute the packets on both RX engines.
+  * Packets are distributed based on a table with the destination vFIFO. The
+  * index of the table is a hash of source and destination of IPV4 and VLAN
+  * priority.
+  */
+ #define MC_CMD_RX_BALANCING 0x118
+ 
+ #define MC_CMD_0x118_PRIVILEGE_CTG SRIOV_CTG_ADMIN
+ 
+ /* MC_CMD_RX_BALANCING_IN msgrequest */
+ #define    MC_CMD_RX_BALANCING_IN_LEN 16
+ /* The RX port whose upconverter table will be modified */
+ #define       MC_CMD_RX_BALANCING_IN_PORT_OFST 0
+ /* The VLAN priority associated to the table index and vFIFO */
+ #define       MC_CMD_RX_BALANCING_IN_PRIORITY_OFST 4
+ /* The resulting bit of SRC^DST for indexing the table */
+ #define       MC_CMD_RX_BALANCING_IN_SRC_DST_OFST 8
+ /* The RX engine to which the vFIFO in the table entry will point to */
+ #define       MC_CMD_RX_BALANCING_IN_ENG_OFST 12
+ 
+ /* MC_CMD_RX_BALANCING_OUT msgresponse */
+ #define    MC_CMD_RX_BALANCING_OUT_LEN 0
+ 
+ /***********************************/
+ /* MC_CMD_SET_EVQ_TMR
+  * Update the timer load, timer reload and timer mode values for a given EVQ.
+  * The requested timer values (in TMR_LOAD_REQ_NS and TMR_RELOAD_REQ_NS) will
+  * be rounded up to the granularity supported by the hardware, then truncated
+  * to the range supported by the hardware. The resulting value after the
+  * rounding and truncation will be returned to the caller (in TMR_LOAD_ACT_NS
+  * and TMR_RELOAD_ACT_NS).
+  */
+ #define MC_CMD_SET_EVQ_TMR 0x120
+ 
+ #define MC_CMD_0x120_PRIVILEGE_CTG SRIOV_CTG_GENERAL
+ 
+ /* MC_CMD_SET_EVQ_TMR_IN msgrequest */
+ #define    MC_CMD_SET_EVQ_TMR_IN_LEN 16
+ /* Function-relative queue instance */
+ #define       MC_CMD_SET_EVQ_TMR_IN_INSTANCE_OFST 0
+ /* Requested value for timer load (in nanoseconds) */
+ #define       MC_CMD_SET_EVQ_TMR_IN_TMR_LOAD_REQ_NS_OFST 4
+ /* Requested value for timer reload (in nanoseconds) */
+ #define       MC_CMD_SET_EVQ_TMR_IN_TMR_RELOAD_REQ_NS_OFST 8
+ /* Timer mode. Meanings as per EVQ_TMR_REG.TC_TIMER_VAL */
+ #define       MC_CMD_SET_EVQ_TMR_IN_TMR_MODE_OFST 12
+ #define          MC_CMD_SET_EVQ_TMR_IN_TIMER_MODE_DIS  0x0 /* enum */
+ #define          MC_CMD_SET_EVQ_TMR_IN_TIMER_MODE_IMMED_START  0x1 /* enum */
+ #define          MC_CMD_SET_EVQ_TMR_IN_TIMER_MODE_TRIG_START  0x2 /* enum */
+ #define          MC_CMD_SET_EVQ_TMR_IN_TIMER_MODE_INT_HLDOFF  0x3 /* enum */
+ 
+ /* MC_CMD_SET_EVQ_TMR_OUT msgresponse */
+ #define    MC_CMD_SET_EVQ_TMR_OUT_LEN 8
+ /* Actual value for timer load (in nanoseconds) */
+ #define       MC_CMD_SET_EVQ_TMR_OUT_TMR_LOAD_ACT_NS_OFST 0
+ /* Actual value for timer reload (in nanoseconds) */
+ #define       MC_CMD_SET_EVQ_TMR_OUT_TMR_RELOAD_ACT_NS_OFST 4
+ 
+ 
+ /***********************************/
+ /* MC_CMD_GET_EVQ_TMR_PROPERTIES
+  * Query properties about the event queue timers.
+  */
+ #define MC_CMD_GET_EVQ_TMR_PROPERTIES 0x122
+ 
+ #define MC_CMD_0x122_PRIVILEGE_CTG SRIOV_CTG_GENERAL
+ 
+ /* MC_CMD_GET_EVQ_TMR_PROPERTIES_IN msgrequest */
+ #define    MC_CMD_GET_EVQ_TMR_PROPERTIES_IN_LEN 0
+ 
+ /* MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT msgresponse */
+ #define    MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_LEN 36
+ /* Reserved for future use. */
+ #define       MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_FLAGS_OFST 0
+ /* For timers updated via writes to EVQ_TMR_REG, this is the time interval (in
+  * nanoseconds) for each increment of the timer load/reload count. The
+  * requested duration of a timer is this value multiplied by the timer
+  * load/reload count.
+  */
+ #define       MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_TMR_REG_NS_PER_COUNT_OFST 4
+ /* For timers updated via writes to EVQ_TMR_REG, this is the maximum value
+  * allowed for timer load/reload counts.
+  */
+ #define       MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_TMR_REG_MAX_COUNT_OFST 8
+ /* For timers updated via writes to EVQ_TMR_REG, timer load/reload counts not a
+  * multiple of this step size will be rounded in an implementation defined
+  * manner.
+  */
+ #define       MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_TMR_REG_STEP_OFST 12
+ /* Maximum timer duration (in nanoseconds) for timers updated via MCDI. Only
+  * meaningful if MC_CMD_SET_EVQ_TMR is implemented.
+  */
+ #define       MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_MCDI_TMR_MAX_NS_OFST 16
+ /* Timer durations requested via MCDI that are not a multiple of this step size
+  * will be rounded up. Only meaningful if MC_CMD_SET_EVQ_TMR is implemented.
+  */
+ #define       MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_MCDI_TMR_STEP_NS_OFST 20
+ /* For timers updated using the bug35388 workaround, this is the time interval
+  * (in nanoseconds) for each increment of the timer load/reload count. The
+  * requested duration of a timer is this value multiplied by the timer
+  * load/reload count. This field is only meaningful if the bug35388 workaround
+  * is enabled.
+  */
+ #define       MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_BUG35388_TMR_NS_PER_COUNT_OFST 24
+ /* For timers updated using the bug35388 workaround, this is the maximum value
+  * allowed for timer load/reload counts. This field is only meaningful if the
+  * bug35388 workaround is enabled.
+  */
+ #define       MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_BUG35388_TMR_MAX_COUNT_OFST 28
+ /* For timers updated using the bug35388 workaround, timer load/reload counts
+  * not a multiple of this step size will be rounded in an implementation
+  * defined manner. This field is only meaningful if the bug35388 workaround is
+  * enabled.
+  */
+ #define       MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_BUG35388_TMR_STEP_OFST 32
+ 
++>>>>>>> d29e33d6d087 (sfc: update MCDI protocol headers)
  #endif /* MCDI_PCOL_H */
* Unmerged path drivers/net/ethernet/sfc/mcdi_pcol.h
