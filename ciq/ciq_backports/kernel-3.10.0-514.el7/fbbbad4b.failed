vfs,ext2: introduce IS_DAX(inode)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matthew Wilcox <matthew.r.wilcox@intel.com>
commit fbbbad4bc2101e452b24e6e65d3d5e11314a0b5f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fbbbad4b.failed

Use an inode flag to tag inodes which should avoid using the page cache.
Convert ext2 to use it instead of mapping_is_xip().  Prevent I/Os to files
tagged with the DAX flag from falling back to buffered I/O.

	Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
	Cc: Andreas Dilger <andreas.dilger@intel.com>
	Cc: Boaz Harrosh <boaz@plexistor.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Dave Chinner <david@fromorbit.com>
	Cc: Jens Axboe <axboe@kernel.dk>
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: Theodore Ts'o <tytso@mit.edu>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit fbbbad4bc2101e452b24e6e65d3d5e11314a0b5f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/fs.h
#	mm/filemap.c
diff --cc include/linux/fs.h
index 37d4ac39152e,fb373bb5cf03..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -1797,7 -1677,11 +1797,15 @@@ struct super_operations 
  #define S_IMA		1024	/* Inode has an associated IMA struct */
  #define S_AUTOMOUNT	2048	/* Automount/referral quasi-directory */
  #define S_NOSEC		4096	/* no suid or xattr security attributes */
++<<<<<<< HEAD
 +#define S_IOPS_WRAPPER	8192	/* i_op points to struct inode_operations_wrapper */
++=======
+ #ifdef CONFIG_FS_XIP
+ #define S_DAX		8192	/* Direct Access, avoiding the page cache */
+ #else
+ #define S_DAX		0	/* Make all the DAX code disappear */
+ #endif
++>>>>>>> fbbbad4bc210 (vfs,ext2: introduce IS_DAX(inode))
  
  /*
   * Note that nosuid etc flags are inode-specific: setting some file-system
@@@ -1835,7 -1719,7 +1843,11 @@@
  #define IS_IMA(inode)		((inode)->i_flags & S_IMA)
  #define IS_AUTOMOUNT(inode)	((inode)->i_flags & S_AUTOMOUNT)
  #define IS_NOSEC(inode)		((inode)->i_flags & S_NOSEC)
++<<<<<<< HEAD
 +#define IS_IOPS_WRAPPER(inode)	((inode)->i_flags & S_IOPS_WRAPPER)
++=======
+ #define IS_DAX(inode)		((inode)->i_flags & S_DAX)
++>>>>>>> fbbbad4bc210 (vfs,ext2: introduce IS_DAX(inode))
  
  #define IS_WHITEOUT(inode)	(S_ISCHR(inode->i_mode) && \
  				 (inode)->i_rdev == WHITEOUT_DEV)
diff --cc mm/filemap.c
index 813fbe54f73b,1578c224285e..000000000000
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@@ -1919,30 -1705,31 +1919,51 @@@ generic_file_aio_read(struct kiocb *ioc
  		if (!count)
  			goto out; /* skip atime */
  		size = i_size_read(inode);
 -		retval = filemap_write_and_wait_range(mapping, pos,
 -					pos + count - 1);
 -		if (!retval) {
 -			struct iov_iter data = *iter;
 -			retval = mapping->a_ops->direct_IO(READ, iocb, &data, pos);
 -		}
 +		if (pos < size) {
 +			retval = filemap_write_and_wait_range(mapping, pos,
 +					pos + iov_length(iov, nr_segs) - 1);
 +			if (!retval) {
 +				retval = mapping->a_ops->direct_IO(READ, iocb,
 +							iov, pos, nr_segs);
 +			}
 +			if (retval > 0) {
 +				*ppos = pos + retval;
 +				count -= retval;
 +			}
  
++<<<<<<< HEAD
 +			/*
 +			 * Btrfs can have a short DIO read if we encounter
 +			 * compressed extents, so if there was an error, or if
 +			 * we've already read everything we wanted to, or if
 +			 * there was a short read because we hit EOF, go ahead
 +			 * and return.  Otherwise fallthrough to buffered io for
 +			 * the rest of the read.
 +			 */
 +			if (retval < 0 || !count || *ppos >= size) {
 +				file_accessed(filp);
 +				goto out;
 +			}
++=======
+ 		if (retval > 0) {
+ 			*ppos = pos + retval;
+ 			iov_iter_advance(iter, retval);
+ 		}
+ 
+ 		/*
+ 		 * Btrfs can have a short DIO read if we encounter
+ 		 * compressed extents, so if there was an error, or if
+ 		 * we've already read everything we wanted to, or if
+ 		 * there was a short read because we hit EOF, go ahead
+ 		 * and return.  Otherwise fallthrough to buffered io for
+ 		 * the rest of the read.  Buffered reads will not work for
+ 		 * DAX files, so don't bother trying.
+ 		 */
+ 		if (retval < 0 || !iov_iter_count(iter) || *ppos >= size ||
+ 		    IS_DAX(inode)) {
+ 			file_accessed(file);
+ 			goto out;
++>>>>>>> fbbbad4bc210 (vfs,ext2: introduce IS_DAX(inode))
  		}
  	}
  
@@@ -2964,23 -2587,24 +2985,37 @@@ ssize_t __generic_file_aio_write(struc
  	/* coalesce the iovecs and go direct-to-BIO for O_DIRECT */
  	if (unlikely(file->f_flags & O_DIRECT)) {
  		loff_t endbyte;
 +		ssize_t written_buffered;
  
++<<<<<<< HEAD
 +		written = generic_file_direct_write(iocb, iov, &nr_segs, pos,
 +							ppos, count, ocount);
 +		if (written < 0 || written == count)
 +			goto out;
 +		/*
 +		 * direct-io write to a hole: fall through to buffered I/O
 +		 * for completing the rest of the request.
 +		 */
++=======
+ 		written = generic_file_direct_write(iocb, from, pos);
+ 		/*
+ 		 * If the write stopped short of completing, fall back to
+ 		 * buffered writes.  Some filesystems do this for writes to
+ 		 * holes, for example.  For DAX files, a buffered write will
+ 		 * not succeed (even if it did, DAX does not handle dirty
+ 		 * page-cache pages correctly).
+ 		 */
+ 		if (written < 0 || written == count || IS_DAX(inode))
+ 			goto out;
+ 
++>>>>>>> fbbbad4bc210 (vfs,ext2: introduce IS_DAX(inode))
  		pos += written;
  		count -= written;
 -
 -		status = generic_perform_write(file, from, pos);
 +		written_buffered = generic_file_buffered_write(iocb, iov,
 +						nr_segs, pos, ppos, count,
 +						written);
  		/*
 -		 * If generic_perform_write() returned a synchronous error
 +		 * If generic_file_buffered_write() retuned a synchronous error
  		 * then we want to return the number of bytes which were
  		 * direct-written, or the error code if that was zero.  Note
  		 * that this differs from normal direct-io semantics, which
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index 115fa58bb9ae..48391ace8c94 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -729,7 +729,7 @@ static int ext2_get_blocks(struct inode *inode,
 		goto cleanup;
 	}
 
-	if (ext2_use_xip(inode->i_sb)) {
+	if (IS_DAX(inode)) {
 		/*
 		 * we need to clear the block
 		 */
@@ -1199,7 +1199,7 @@ static int ext2_setsize(struct inode *inode, loff_t newsize)
 
 	inode_dio_wait(inode);
 
-	if (mapping_is_xip(inode->i_mapping))
+	if (IS_DAX(inode))
 		error = xip_truncate_page(inode->i_mapping, newsize);
 	else if (test_opt(inode->i_sb, NOBH))
 		error = nobh_truncate_page(inode->i_mapping,
@@ -1271,7 +1271,8 @@ void ext2_set_inode_flags(struct inode *inode)
 {
 	unsigned int flags = EXT2_I(inode)->i_flags;
 
-	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);
+	inode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |
+				S_DIRSYNC | S_DAX);
 	if (flags & EXT2_SYNC_FL)
 		inode->i_flags |= S_SYNC;
 	if (flags & EXT2_APPEND_FL)
@@ -1282,6 +1283,8 @@ void ext2_set_inode_flags(struct inode *inode)
 		inode->i_flags |= S_NOATIME;
 	if (flags & EXT2_DIRSYNC_FL)
 		inode->i_flags |= S_DIRSYNC;
+	if (test_opt(inode->i_sb, XIP))
+		inode->i_flags |= S_DAX;
 }
 
 /* Propagate flags from i_flags to EXT2_I(inode)->i_flags */
diff --git a/fs/ext2/xip.h b/fs/ext2/xip.h
index 18b34d2f31b3..29be73781419 100644
--- a/fs/ext2/xip.h
+++ b/fs/ext2/xip.h
@@ -16,9 +16,7 @@ static inline int ext2_use_xip (struct super_block *sb)
 }
 int ext2_get_xip_mem(struct address_space *, pgoff_t, int,
 				void **, unsigned long *);
-#define mapping_is_xip(map) unlikely(map->a_ops->get_xip_mem)
 #else
-#define mapping_is_xip(map)			0
 #define ext2_xip_verify_sb(sb)			do { } while (0)
 #define ext2_use_xip(sb)			0
 #define ext2_clear_xip_target(inode, chain)	0
* Unmerged path include/linux/fs.h
* Unmerged path mm/filemap.c
