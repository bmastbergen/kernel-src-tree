ceph: combine as many iovec as possile into one OSD request

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Zhu, Caifeng <zhucaifeng@unissoft-nj.com>
commit b5b98989dc7ed2093aeb76f2d0db79888582b0a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b5b98989.failed

Both ceph_sync_direct_write and ceph_sync_read iterate iovec elements
one by one, send one OSD request for each iovec. This is sub-optimal,
We can combine serveral iovec into one page vector, and send an OSD
request for the whole page vector.

	Signed-off-by: Zhu, Caifeng <zhucaifeng@unissoft-nj.com>
	Signed-off-by: Yan, Zheng <zyan@redhat.com>
(cherry picked from commit b5b98989dc7ed2093aeb76f2d0db79888582b0a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/file.c
diff --cc fs/ceph/file.c
index 0c3070bb755c,3c68e6aee2f0..000000000000
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@@ -425,20 -521,20 +493,29 @@@ static ssize_t ceph_sync_read(struct ki
  	if (ret < 0)
  		return ret;
  
 -	if (iocb->ki_flags & IOCB_DIRECT) {
 +	if (file->f_flags & O_DIRECT) {
  		while (iov_iter_count(i)) {
 -			size_t start;
 -			ssize_t n;
 +			void __user *data = i->iov[0].iov_base + i->iov_offset;
 +			size_t len = i->iov[0].iov_len - i->iov_offset;
 +
++<<<<<<< HEAD
 +			num_pages = calc_pages_for((unsigned long)data, len);
 +			pages = ceph_get_direct_page_vector(data,
 +							    num_pages, true);
 +			if (IS_ERR(pages))
 +				return PTR_ERR(pages);
  
 +			ret = striped_read(inode, off, len,
++=======
+ 			n = dio_get_pagev_size(i);
+ 			pages = dio_get_pages_alloc(i, n, &start, &num_pages);
+ 			if (IS_ERR(pages))
+ 				return PTR_ERR(pages);
+ 
+ 			ret = striped_read(inode, off, n,
++>>>>>>> b5b98989dc7e (ceph: combine as many iovec as possile into one OSD request)
  					   pages, num_pages, checkeof,
 -					   1, start);
 -
 +					   1, (unsigned long)data & ~PAGE_MASK);
  			ceph_put_page_vector(pages, num_pages, true);
  
  			if (ret <= 0)
@@@ -573,15 -658,11 +650,22 @@@ ceph_sync_direct_write(struct kiocb *io
  		CEPH_OSD_FLAG_ONDISK |
  		CEPH_OSD_FLAG_WRITE;
  
++<<<<<<< HEAD
 +	iov_iter_init(&i, iov, nr_segs, count, 0);
++=======
+ 	while (iov_iter_count(from) > 0) {
+ 		u64 len = dio_get_pagev_size(from);
+ 		size_t start;
+ 		ssize_t n;
++>>>>>>> b5b98989dc7e (ceph: combine as many iovec as possile into one OSD request)
 +
 +	while (iov_iter_count(&i) > 0) {
 +		void __user *data = i.iov->iov_base + i.iov_offset;
 +		u64 len = i.iov->iov_len - i.iov_offset;
  
 +		page_align = (unsigned long)data & ~PAGE_MASK;
 +
 +		snapc = ci->i_snap_realm->cached_context;
  		vino = ceph_vino(inode);
  		req = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,
  					    vino, pos, &len, 0,
@@@ -597,11 -678,12 +681,20 @@@
  
  		osd_req_op_init(req, 1, CEPH_OSD_OP_STARTSYNC, 0);
  
++<<<<<<< HEAD
 +		num_pages = calc_pages_for(page_align, len);
 +		pages = ceph_get_direct_page_vector(data, num_pages, false);
 +		if (IS_ERR(pages)) {
 +			ret = PTR_ERR(pages);
 +			goto out;
++=======
+ 		n = len;
+ 		pages = dio_get_pages_alloc(from, len, &start, &num_pages);
+ 		if (IS_ERR(pages)) {
+ 			ceph_osdc_put_request(req);
+ 			ret = PTR_ERR(pages);
+ 			break;
++>>>>>>> b5b98989dc7e (ceph: combine as many iovec as possile into one OSD request)
  		}
  
  		/*
* Unmerged path fs/ceph/file.c
