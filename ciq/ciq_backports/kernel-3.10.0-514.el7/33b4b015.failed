net/ipv6/udp: Fix ipv6 multicast socket filter regression

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] udp: Fix ipv6 multicast socket filter regression (Jiri Benc) [1297504]
Rebuild_FUZZ: 91.43%
commit-author Henning Rogge <hrogge@gmail.com>
commit 33b4b015e1a1ca7a8fdce40af5e71642a8ea355c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/33b4b015.failed

Commit <5cf3d46192fc> ("udp: Simplify__udp*_lib_mcast_deliver")
simplified the filter for incoming IPv6 multicast but removed
the check of the local socket address and the UDP destination
address.

This patch restores the filter to prevent sockets bound to a IPv6
multicast IP to receive other UDP traffic link unicast.

	Signed-off-by: Henning Rogge <hrogge@gmail.com>
Fixes: 5cf3d46192fc ("udp: Simplify__udp*_lib_mcast_deliver")
	Cc: "David S. Miller" <davem@davemloft.net>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 33b4b015e1a1ca7a8fdce40af5e71642a8ea355c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/udp.c
diff --cc net/ipv6/udp.c
index 2c9dae38dffd,c2ec41617a35..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -700,44 -716,28 +700,59 @@@ drop
  	return -1;
  }
  
 -static bool __udp_v6_is_mcast_sock(struct net *net, struct sock *sk,
 -				   __be16 loc_port, const struct in6_addr *loc_addr,
 -				   __be16 rmt_port, const struct in6_addr *rmt_addr,
 -				   int dif, unsigned short hnum)
 +static struct sock *udp_v6_mcast_next(struct net *net, struct sock *sk,
 +				      __be16 loc_port, const struct in6_addr *loc_addr,
 +				      __be16 rmt_port, const struct in6_addr *rmt_addr,
 +				      int dif)
  {
 -	struct inet_sock *inet = inet_sk(sk);
 +	struct hlist_nulls_node *node;
 +	struct sock *s = sk;
 +	unsigned short num = ntohs(loc_port);
  
 -	if (!net_eq(sock_net(sk), net))
 -		return false;
 +	sk_nulls_for_each_from(s, node) {
 +		struct inet_sock *inet = inet_sk(s);
 +
++<<<<<<< HEAD
 +		if (!net_eq(sock_net(s), net))
 +			continue;
  
 +		if (udp_sk(s)->udp_port_hash == num &&
 +		    s->sk_family == PF_INET6) {
 +			if (inet->inet_dport) {
 +				if (inet->inet_dport != rmt_port)
 +					continue;
 +			}
 +			if (!ipv6_addr_any(&sk->sk_v6_daddr) &&
 +			    !ipv6_addr_equal(&sk->sk_v6_daddr, rmt_addr))
 +				continue;
 +
 +			if (s->sk_bound_dev_if && s->sk_bound_dev_if != dif)
 +				continue;
 +
 +			if (!ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {
 +				if (!ipv6_addr_equal(&sk->sk_v6_rcv_saddr, loc_addr))
 +					continue;
 +			}
 +			if (!inet6_mc_check(s, loc_addr, rmt_addr))
 +				continue;
 +			return s;
 +		}
 +	}
 +	return NULL;
++=======
+ 	if (udp_sk(sk)->udp_port_hash != hnum ||
+ 	    sk->sk_family != PF_INET6 ||
+ 	    (inet->inet_dport && inet->inet_dport != rmt_port) ||
+ 	    (!ipv6_addr_any(&sk->sk_v6_daddr) &&
+ 		    !ipv6_addr_equal(&sk->sk_v6_daddr, rmt_addr)) ||
+ 	    (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif) ||
+ 	    (!ipv6_addr_any(&sk->sk_v6_rcv_saddr) &&
+ 		    !ipv6_addr_equal(&sk->sk_v6_rcv_saddr, loc_addr)))
+ 		return false;
+ 	if (!inet6_mc_check(sk, loc_addr, rmt_addr))
+ 		return false;
+ 	return true;
++>>>>>>> 33b4b015e1a1 (net/ipv6/udp: Fix ipv6 multicast socket filter regression)
  }
  
  static void flush_stack(struct sock **stack, unsigned int count,
* Unmerged path net/ipv6/udp.c
