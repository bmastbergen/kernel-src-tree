KVM: x86: unify handling of interrupt window

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 4ca7dd8ce4b24e18f94eed90e80c6eb80fb48c9a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4ca7dd8c.failed

The interrupt window is currently checked twice, once in vmx.c/svm.c and
once in dm_request_for_irq_injection.  The only difference is the extra
check for kvm_arch_interrupt_allowed in dm_request_for_irq_injection,
and the different return value (EINTR/KVM_EXIT_INTR for vmx.c/svm.c vs.
0/KVM_EXIT_IRQ_WINDOW_OPEN for dm_request_for_irq_injection).

However, dm_request_for_irq_injection is basically dead code!  Revive it
by removing the checks in vmx.c and svm.c's vmexit handlers, and
fixing the returned values for the dm_request_for_irq_injection case.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 4ca7dd8ce4b24e18f94eed90e80c6eb80fb48c9a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm.c
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/svm.c
index f4d872b9eba6,54a86183e5d3..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -3292,17 -3299,6 +3290,20 @@@ static int interrupt_window_interceptio
  	svm->vmcb->control.int_ctl &= ~V_IRQ_MASK;
  	mark_dirty(svm->vmcb, VMCB_INTR);
  	++svm->vcpu.stat.irq_window_exits;
++<<<<<<< HEAD
 +	/*
 +	 * If the user space waits to inject interrupts, exit as soon as
 +	 * possible
 +	 */
 +	if (!irqchip_in_kernel(svm->vcpu.kvm) &&
 +	    kvm_run->request_interrupt_window &&
 +	    !kvm_cpu_has_interrupt(&svm->vcpu)) {
 +		kvm_run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;
 +		return 0;
 +	}
 +
++=======
++>>>>>>> 4ca7dd8ce4b2 (KVM: x86: unify handling of interrupt window)
  	return 1;
  }
  
diff --cc arch/x86/kvm/vmx.c
index 843549a0fe2a,6ee0dc69675b..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -5339,17 -5524,6 +5339,20 @@@ static int handle_interrupt_window(stru
  	kvm_make_request(KVM_REQ_EVENT, vcpu);
  
  	++vcpu->stat.irq_window_exits;
++<<<<<<< HEAD
 +
 +	/*
 +	 * If the user space waits to inject interrupts, exit as soon as
 +	 * possible
 +	 */
 +	if (!irqchip_in_kernel(vcpu->kvm) &&
 +	    vcpu->run->request_interrupt_window &&
 +	    !kvm_cpu_has_interrupt(vcpu)) {
 +		vcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;
 +		return 0;
 +	}
++=======
++>>>>>>> 4ca7dd8ce4b2 (KVM: x86: unify handling of interrupt window)
  	return 1;
  }
  
* Unmerged path arch/x86/kvm/svm.c
* Unmerged path arch/x86/kvm/vmx.c
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 733894b44f8d..6a6c4a48b8ee 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -6959,8 +6959,8 @@ static int vcpu_run(struct kvm_vcpu *vcpu)
 			kvm_inject_pending_timer_irqs(vcpu);
 
 		if (dm_request_for_irq_injection(vcpu)) {
-			r = -EINTR;
-			vcpu->run->exit_reason = KVM_EXIT_INTR;
+			r = 0;
+			vcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;
 			++vcpu->stat.request_irq_exits;
 			break;
 		}
