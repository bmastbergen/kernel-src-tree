perf: Add flags argument to perf_remove_from_context()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit 45a0e07abf4933490a2d2f81b1a31fe267bd3561
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/45a0e07a.failed

In preparation to adding more options, convert the boolean argument
into a flags word.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 45a0e07abf4933490a2d2f81b1a31fe267bd3561)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/core.c
diff --cc kernel/events/core.c
index e086d60d319b,4291a4d27664..000000000000
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@@ -1631,21 -1770,7 +1631,25 @@@ group_sched_out(struct perf_event *grou
  		cpuctx->exclusive = 0;
  }
  
++<<<<<<< HEAD
 +struct remove_event {
 +	struct perf_event *event;
 +	bool detach_group;
 +};
 +
 +static void ___perf_remove_from_context(void *info)
 +{
 +	struct remove_event *re = info;
 +	struct perf_event *event = re->event;
 +	struct perf_event_context *ctx = event->ctx;
 +
 +	if (re->detach_group)
 +		perf_group_detach(event);
 +	list_del_event(event, ctx);
 +}
++=======
+ #define DETACH_GROUP	0x01UL
++>>>>>>> 45a0e07abf49 (perf: Add flags argument to perf_remove_from_context())
  
  /*
   * Cross CPU call to remove a performance event
@@@ -1653,25 -1778,26 +1657,33 @@@
   * We disable the event on the hardware level first. After that we
   * remove it from the context list.
   */
 -static void
 -__perf_remove_from_context(struct perf_event *event,
 -			   struct perf_cpu_context *cpuctx,
 -			   struct perf_event_context *ctx,
 -			   void *info)
 +static int __perf_remove_from_context(void *info)
  {
++<<<<<<< HEAD
 +	struct remove_event *re = info;
 +	struct perf_event *event = re->event;
 +	struct perf_event_context *ctx = event->ctx;
 +	struct perf_cpu_context *cpuctx = __get_cpu_context(ctx);
++=======
+ 	unsigned long flags = (unsigned long)info;
++>>>>>>> 45a0e07abf49 (perf: Add flags argument to perf_remove_from_context())
  
 +	raw_spin_lock(&ctx->lock);
  	event_sched_out(event, cpuctx, ctx);
++<<<<<<< HEAD
 +	if (re->detach_group)
++=======
+ 	if (flags & DETACH_GROUP)
++>>>>>>> 45a0e07abf49 (perf: Add flags argument to perf_remove_from_context())
  		perf_group_detach(event);
  	list_del_event(event, ctx);
 -
 -	if (!ctx->nr_events && ctx->is_active) {
 +	if (!ctx->nr_events && cpuctx->task_ctx == ctx) {
  		ctx->is_active = 0;
 -		if (ctx->task) {
 -			WARN_ON_ONCE(cpuctx->task_ctx != ctx);
 -			cpuctx->task_ctx = NULL;
 -		}
 +		cpuctx->task_ctx = NULL;
  	}
 +	raw_spin_unlock(&ctx->lock);
 +
 +	return 0;
  }
  
  /*
@@@ -1687,18 -1810,11 +1699,22 @@@
   * When called from perf_event_exit_task, it's OK because the
   * context has been detached from its task.
   */
- static void perf_remove_from_context(struct perf_event *event, bool detach_group)
+ static void perf_remove_from_context(struct perf_event *event, unsigned long flags)
  {
 -	lockdep_assert_held(&event->ctx->mutex);
 +	struct perf_event_context *ctx = event->ctx;
 +	struct remove_event re = {
 +		.event = event,
 +		.detach_group = detach_group,
 +	};
  
 +	lockdep_assert_held(&ctx->mutex);
 +
++<<<<<<< HEAD
 +	event_function_call(event, __perf_remove_from_context,
 +			    ___perf_remove_from_context, &re);
++=======
+ 	event_function_call(event, __perf_remove_from_context, (void *)flags);
++>>>>>>> 45a0e07abf49 (perf: Add flags argument to perf_remove_from_context())
  }
  
  /*
@@@ -7829,22 -8431,14 +7845,26 @@@ SYSCALL_DEFINE5(perf_event_open
  		 * See perf_event_ctx_lock() for comments on the details
  		 * of swizzling perf_event::ctx.
  		 */
++<<<<<<< HEAD
 +		mutex_lock_double(&gctx->mutex, &ctx->mutex);
 +
 +		perf_remove_from_context(group_leader, false);
++=======
+ 		perf_remove_from_context(group_leader, 0);
++>>>>>>> 45a0e07abf49 (perf: Add flags argument to perf_remove_from_context())
  
  		list_for_each_entry(sibling, &group_leader->sibling_list,
  				    group_entry) {
- 			perf_remove_from_context(sibling, false);
+ 			perf_remove_from_context(sibling, 0);
  			put_ctx(gctx);
  		}
 +	} else {
 +		mutex_lock(&ctx->mutex);
 +	}
  
 +	WARN_ON_ONCE(ctx->parent_ctx);
 +
 +	if (move_group) {
  		/*
  		 * Wait for everybody to stop referencing the events through
  		 * the old lists, before installing it on new lists.
@@@ -8616,16 -9232,17 +8636,23 @@@ static void perf_event_init_cpu(int cpu
  	mutex_unlock(&swhash->hlist_mutex);
  }
  
 -#if defined CONFIG_HOTPLUG_CPU || defined CONFIG_KEXEC_CORE
 +#if defined CONFIG_HOTPLUG_CPU || defined CONFIG_KEXEC
  static void __perf_event_exit_context(void *__info)
  {
 +	struct remove_event re = { .detach_group = true };
  	struct perf_event_context *ctx = __info;
 -	struct perf_cpu_context *cpuctx = __get_cpu_context(ctx);
 -	struct perf_event *event;
  
++<<<<<<< HEAD
 +	rcu_read_lock();
 +	list_for_each_entry_rcu(re.event, &ctx->event_list, event_entry)
 +		__perf_remove_from_context(&re);
 +	rcu_read_unlock();
++=======
+ 	raw_spin_lock(&ctx->lock);
+ 	list_for_each_entry(event, &ctx->event_list, event_entry)
+ 		__perf_remove_from_context(event, cpuctx, ctx, (void *)DETACH_GROUP);
+ 	raw_spin_unlock(&ctx->lock);
++>>>>>>> 45a0e07abf49 (perf: Add flags argument to perf_remove_from_context())
  }
  
  static void perf_event_exit_cpu_context(int cpu)
* Unmerged path kernel/events/core.c
