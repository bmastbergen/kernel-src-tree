ipv4: hash net ptr into fragmentation bucket selection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit b6a7719aedd7e5c0f2df7641aa47386111682df4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b6a7719a.failed

As namespaces are sometimes used with overlapping ip address ranges,
we should also use the namespace as input to the hash to select the ip
fragmentation counter bucket.

	Cc: Eric Dumazet <edumazet@google.com>
	Cc: Flavio Leitner <fbl@redhat.com>
	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b6a7719aedd7e5c0f2df7641aa47386111682df4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ppp/pptp.c
#	include/net/ip.h
#	net/ipv4/igmp.c
#	net/ipv4/ip_output.c
#	net/ipv4/ip_tunnel_core.c
#	net/ipv4/ipmr.c
#	net/ipv4/raw.c
#	net/ipv4/route.c
#	net/ipv4/xfrm4_mode_tunnel.c
#	net/netfilter/ipvs/ip_vs_xmit.c
diff --cc drivers/net/ppp/pptp.c
index 7f10588fe668,e3bfbd4d0136..000000000000
--- a/drivers/net/ppp/pptp.c
+++ b/drivers/net/ppp/pptp.c
@@@ -281,7 -281,7 +281,11 @@@ static int pptp_xmit(struct ppp_channe
  	nf_reset(skb);
  
  	skb->ip_summed = CHECKSUM_NONE;
++<<<<<<< HEAD
 +	ip_select_ident(skb, &rt->dst, NULL);
++=======
+ 	ip_select_ident(sock_net(sk), skb, NULL);
++>>>>>>> b6a7719aedd7 (ipv4: hash net ptr into fragmentation bucket selection)
  	ip_send_check(iph);
  
  	ip_local_out(skb);
diff --cc include/net/ip.h
index ac68d6939a5b,d0808a323763..000000000000
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@@ -314,9 -317,11 +314,17 @@@ static inline unsigned int ip_skb_dst_m
  	}
  }
  
++<<<<<<< HEAD
 +void __ip_select_ident(struct iphdr *iph, struct dst_entry *dst, int more);
 +
 +static inline void ip_select_ident(struct sk_buff *skb, struct dst_entry *dst, struct sock *sk)
++=======
+ u32 ip_idents_reserve(u32 hash, int segs);
+ void __ip_select_ident(struct net *net, struct iphdr *iph, int segs);
+ 
+ static inline void ip_select_ident_segs(struct net *net, struct sk_buff *skb,
+ 					struct sock *sk, int segs)
++>>>>>>> b6a7719aedd7 (ipv4: hash net ptr into fragmentation bucket selection)
  {
  	struct iphdr *iph = ip_hdr(skb);
  
@@@ -326,24 -331,21 +334,42 @@@
  		 * does not change, they drop every other packet in
  		 * a TCP stream using header compression.
  		 */
++<<<<<<< HEAD
 +		iph->id = (sk && inet_sk(sk)->inet_daddr) ?
 +					htons(inet_sk(sk)->inet_id++) : 0;
 +	} else
 +		__ip_select_ident(iph, dst, 0);
 +}
 +
 +static inline void ip_select_ident_more(struct sk_buff *skb, struct dst_entry *dst, struct sock *sk, int more)
 +{
 +	struct iphdr *iph = ip_hdr(skb);
 +
 +	if ((iph->frag_off & htons(IP_DF)) && !skb->ignore_df) {
 +		if (sk && inet_sk(sk)->inet_daddr) {
 +			iph->id = htons(inet_sk(sk)->inet_id);
 +			inet_sk(sk)->inet_id += 1 + more;
 +		} else
 +			iph->id = 0;
 +	} else
 +		__ip_select_ident(iph, dst, more);
++=======
+ 		if (sk && inet_sk(sk)->inet_daddr) {
+ 			iph->id = htons(inet_sk(sk)->inet_id);
+ 			inet_sk(sk)->inet_id += segs;
+ 		} else {
+ 			iph->id = 0;
+ 		}
+ 	} else {
+ 		__ip_select_ident(net, iph, segs);
+ 	}
+ }
+ 
+ static inline void ip_select_ident(struct net *net, struct sk_buff *skb,
+ 				   struct sock *sk)
+ {
+ 	ip_select_ident_segs(net, skb, sk, 1);
++>>>>>>> b6a7719aedd7 (ipv4: hash net ptr into fragmentation bucket selection)
  }
  
  static inline __wsum inet_compute_pseudo(struct sk_buff *skb, int proto)
diff --cc net/ipv4/igmp.c
index 09680343bac5,ad09213ac5b2..000000000000
--- a/net/ipv4/igmp.c
+++ b/net/ipv4/igmp.c
@@@ -345,7 -370,7 +345,11 @@@ static struct sk_buff *igmpv3_newpack(s
  	pip->saddr    = fl4.saddr;
  	pip->protocol = IPPROTO_IGMP;
  	pip->tot_len  = 0;	/* filled in later */
++<<<<<<< HEAD
 +	ip_select_ident(skb, &rt->dst, NULL);
++=======
+ 	ip_select_ident(net, skb, NULL);
++>>>>>>> b6a7719aedd7 (ipv4: hash net ptr into fragmentation bucket selection)
  	((u8 *)&pip[1])[0] = IPOPT_RA;
  	((u8 *)&pip[1])[1] = 4;
  	((u8 *)&pip[1])[2] = 0;
@@@ -689,7 -714,7 +693,11 @@@ static int igmp_send_report(struct in_d
  	iph->daddr    = dst;
  	iph->saddr    = fl4.saddr;
  	iph->protocol = IPPROTO_IGMP;
++<<<<<<< HEAD
 +	ip_select_ident(skb, &rt->dst, NULL);
++=======
+ 	ip_select_ident(net, skb, NULL);
++>>>>>>> b6a7719aedd7 (ipv4: hash net ptr into fragmentation bucket selection)
  	((u8 *)&iph[1])[0] = IPOPT_RA;
  	((u8 *)&iph[1])[1] = 4;
  	((u8 *)&iph[1])[2] = 0;
diff --cc net/ipv4/ip_output.c
index 21b11ebed76f,8259e777b249..000000000000
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@@ -153,7 -148,7 +153,11 @@@ int ip_build_and_send_pkt(struct sk_buf
  	iph->daddr    = (opt && opt->opt.srr ? opt->opt.faddr : daddr);
  	iph->saddr    = saddr;
  	iph->protocol = sk->sk_protocol;
++<<<<<<< HEAD
 +	ip_select_ident(skb, &rt->dst, sk);
++=======
+ 	ip_select_ident(sock_net(sk), skb, sk);
++>>>>>>> b6a7719aedd7 (ipv4: hash net ptr into fragmentation bucket selection)
  
  	if (opt && opt->opt.optlen) {
  		iph->ihl += opt->opt.optlen>>2;
@@@ -435,9 -430,10 +439,14 @@@ packet_routed
  		ip_options_build(skb, &inet_opt->opt, inet->inet_daddr, rt, 0);
  	}
  
++<<<<<<< HEAD
 +	ip_select_ident_more(skb, &rt->dst, sk,
 +			     (skb_shinfo(skb)->gso_segs ?: 1) - 1);
++=======
+ 	ip_select_ident_segs(sock_net(sk), skb, sk,
+ 			     skb_shinfo(skb)->gso_segs ?: 1);
++>>>>>>> b6a7719aedd7 (ipv4: hash net ptr into fragmentation bucket selection)
  
 -	/* TODO : should we use skb->sk here instead of sk ? */
  	skb->priority = sk->sk_priority;
  	skb->mark = sk->sk_mark;
  
@@@ -1385,7 -1380,7 +1394,11 @@@ struct sk_buff *__ip_make_skb(struct so
  	iph->ttl = ttl;
  	iph->protocol = sk->sk_protocol;
  	ip_copy_addrs(iph, fl4);
++<<<<<<< HEAD
 +	ip_select_ident(skb, &rt->dst, sk);
++=======
+ 	ip_select_ident(net, skb, sk);
++>>>>>>> b6a7719aedd7 (ipv4: hash net ptr into fragmentation bucket selection)
  
  	if (opt) {
  		iph->ihl += opt->optlen>>2;
diff --cc net/ipv4/ip_tunnel_core.c
index c969294e6abb,8c4dcc46acd2..000000000000
--- a/net/ipv4/ip_tunnel_core.c
+++ b/net/ipv4/ip_tunnel_core.c
@@@ -74,7 -74,7 +74,11 @@@ int iptunnel_xmit(struct sock *sk, stru
  	iph->daddr	=	dst;
  	iph->saddr	=	src;
  	iph->ttl	=	ttl;
++<<<<<<< HEAD
 +	__ip_select_ident(iph, &rt->dst, (skb_shinfo(skb)->gso_segs ?: 1) - 1);
++=======
+ 	__ip_select_ident(sock_net(sk), iph, skb_shinfo(skb)->gso_segs ?: 1);
++>>>>>>> b6a7719aedd7 (ipv4: hash net ptr into fragmentation bucket selection)
  
  	err = ip_local_out_sk(sk, skb);
  	if (unlikely(net_xmit_eval(err)))
diff --cc net/ipv4/ipmr.c
index 2a227e82ab08,c688cd1b2110..000000000000
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@@ -1671,7 -1662,7 +1672,11 @@@ static void ip_encap(struct net *net, s
  	iph->protocol	=	IPPROTO_IPIP;
  	iph->ihl	=	5;
  	iph->tot_len	=	htons(skb->len);
++<<<<<<< HEAD
 +	ip_select_ident(skb, skb_dst(skb), NULL);
++=======
+ 	ip_select_ident(net, skb, NULL);
++>>>>>>> b6a7719aedd7 (ipv4: hash net ptr into fragmentation bucket selection)
  	ip_send_check(iph);
  
  	memset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));
diff --cc net/ipv4/raw.c
index df439188a599,56946f47d446..000000000000
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@@ -387,7 -404,7 +387,11 @@@ static int raw_send_hdrinc(struct sock 
  		iph->check   = 0;
  		iph->tot_len = htons(length);
  		if (!iph->id)
++<<<<<<< HEAD
 +			ip_select_ident(skb, &rt->dst, NULL);
++=======
+ 			ip_select_ident(net, skb, NULL);
++>>>>>>> b6a7719aedd7 (ipv4: hash net ptr into fragmentation bucket selection)
  
  		iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
  	}
diff --cc net/ipv4/route.c
index 31700d4dc025,be8703d02ef0..000000000000
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@@ -462,39 -456,45 +462,52 @@@ static struct neighbour *ipv4_neigh_loo
  	return neigh_create(&arp_tbl, pkey, dev);
  }
  
 -#define IP_IDENTS_SZ 2048u
 -struct ip_ident_bucket {
 -	atomic_t	id;
 -	u32		stamp32;
 -};
 -
 -static struct ip_ident_bucket *ip_idents __read_mostly;
 -
 -/* In order to protect privacy, we add a perturbation to identifiers
 - * if one generator is seldom used. This makes hard for an attacker
 - * to infer how many packets were sent between two points in time.
 +/*
 + * Peer allocation may fail only in serious out-of-memory conditions.  However
 + * we still can generate some output.
 + * Random ID selection looks a bit dangerous because we have no chances to
 + * select ID being unique in a reasonable period of time.
 + * But broken packet identifier may be better than no packet at all.
   */
 -u32 ip_idents_reserve(u32 hash, int segs)
 +static void ip_select_fb_ident(struct iphdr *iph)
  {
 -	struct ip_ident_bucket *bucket = ip_idents + hash % IP_IDENTS_SZ;
 -	u32 old = ACCESS_ONCE(bucket->stamp32);
 -	u32 now = (u32)jiffies;
 -	u32 delta = 0;
 +	static DEFINE_SPINLOCK(ip_fb_id_lock);
 +	static u32 ip_fallback_id;
 +	u32 salt;
  
 -	if (old != now && cmpxchg(&bucket->stamp32, old, now) == old)
 -		delta = prandom_u32_max(now - old);
 -
 -	return atomic_add_return(segs + delta, &bucket->id) - segs;
 +	spin_lock_bh(&ip_fb_id_lock);
 +	salt = secure_ip_id((__force __be32)ip_fallback_id ^ iph->daddr);
 +	iph->id = htons(salt & 0xFFFF);
 +	ip_fallback_id = salt;
 +	spin_unlock_bh(&ip_fb_id_lock);
  }
 -EXPORT_SYMBOL(ip_idents_reserve);
  
++<<<<<<< HEAD
 +void __ip_select_ident(struct iphdr *iph, struct dst_entry *dst, int more)
++=======
+ void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)
++>>>>>>> b6a7719aedd7 (ipv4: hash net ptr into fragmentation bucket selection)
  {
 -	static u32 ip_idents_hashrnd __read_mostly;
 -	u32 hash, id;
 +	struct net *net = dev_net(dst->dev);
 +	struct inet_peer *peer;
  
 -	net_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));
 +	peer = inet_getpeer_v4(net->ipv4.peers, iph->daddr, 1);
 +	if (peer) {
 +		iph->id = htons(inet_getid(peer, more));
 +		inet_putpeer(peer);
 +		return;
 +	}
  
++<<<<<<< HEAD
 +	ip_select_fb_ident(iph);
++=======
+ 	hash = jhash_3words((__force u32)iph->daddr,
+ 			    (__force u32)iph->saddr,
+ 			    iph->protocol ^ net_hash_mix(net),
+ 			    ip_idents_hashrnd);
+ 	id = ip_idents_reserve(hash, segs);
+ 	iph->id = htons(id);
++>>>>>>> b6a7719aedd7 (ipv4: hash net ptr into fragmentation bucket selection)
  }
  EXPORT_SYMBOL(__ip_select_ident);
  
diff --cc net/ipv4/xfrm4_mode_tunnel.c
index 31b18152528f,35feda676464..000000000000
--- a/net/ipv4/xfrm4_mode_tunnel.c
+++ b/net/ipv4/xfrm4_mode_tunnel.c
@@@ -123,6 -63,7 +123,10 @@@ static int xfrm4_mode_tunnel_output(str
  
  	top_iph->saddr = x->props.saddr.a4;
  	top_iph->daddr = x->id.daddr.a4;
++<<<<<<< HEAD
++=======
+ 	ip_select_ident(dev_net(dst->dev), skb, NULL);
++>>>>>>> b6a7719aedd7 (ipv4: hash net ptr into fragmentation bucket selection)
  
  	return 0;
  }
diff --cc net/netfilter/ipvs/ip_vs_xmit.c
index 033f02180460,bf02932b7188..000000000000
--- a/net/netfilter/ipvs/ip_vs_xmit.c
+++ b/net/netfilter/ipvs/ip_vs_xmit.c
@@@ -878,12 -987,12 +879,17 @@@ ip_vs_tunnel_xmit(struct sk_buff *skb, 
  	iph->version		=	4;
  	iph->ihl		=	sizeof(struct iphdr)>>2;
  	iph->frag_off		=	df;
 -	iph->protocol		=	next_protocol;
 -	iph->tos		=	dsfield;
 +	iph->protocol		=	IPPROTO_IPIP;
 +	iph->tos		=	tos;
  	iph->daddr		=	cp->daddr.ip;
  	iph->saddr		=	saddr;
++<<<<<<< HEAD
 +	iph->ttl		=	old_iph->ttl;
 +	ip_select_ident(skb, &rt->dst, NULL);
++=======
+ 	iph->ttl		=	ttl;
+ 	ip_select_ident(net, skb, NULL);
++>>>>>>> b6a7719aedd7 (ipv4: hash net ptr into fragmentation bucket selection)
  
  	/* Another hack: avoid icmp_send in ip_fragment */
  	skb->ignore_df = 1;
* Unmerged path drivers/net/ppp/pptp.c
* Unmerged path include/net/ip.h
* Unmerged path net/ipv4/igmp.c
* Unmerged path net/ipv4/ip_output.c
* Unmerged path net/ipv4/ip_tunnel_core.c
* Unmerged path net/ipv4/ipmr.c
* Unmerged path net/ipv4/raw.c
* Unmerged path net/ipv4/route.c
* Unmerged path net/ipv4/xfrm4_mode_tunnel.c
* Unmerged path net/netfilter/ipvs/ip_vs_xmit.c
