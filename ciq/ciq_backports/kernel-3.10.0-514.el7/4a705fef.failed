hugetlb: fix copy_hugetlb_page_range() to handle migration/hwpoisoned entry

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
commit 4a705fef986231a3e7a6b1a6d3c37025f021f49f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4a705fef.failed

There's a race between fork() and hugepage migration, as a result we try
to "dereference" a swap entry as a normal pte, causing kernel panic.
The cause of the problem is that copy_hugetlb_page_range() can't handle
"swap entry" family (migration entry and hwpoisoned entry) so let's fix
it.

[akpm@linux-foundation.org: coding-style fixes]
	Signed-off-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Acked-by: Hugh Dickins <hughd@google.com>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: <stable@vger.kernel.org>	[2.6.37+]
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 4a705fef986231a3e7a6b1a6d3c37025f021f49f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/hugetlb.c
diff --cc mm/hugetlb.c
index 4a192c9e708d,2024bbd573d2..000000000000
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@@ -2566,13 -2584,26 +2591,36 @@@ int copy_hugetlb_page_range(struct mm_s
  		dst_ptl = huge_pte_lock(h, dst, dst_pte);
  		src_ptl = huge_pte_lockptr(h, src, src_pte);
  		spin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);
++<<<<<<< HEAD
 +		if (!huge_pte_none(huge_ptep_get(src_pte))) {
 +			if (cow) {
 +				huge_ptep_set_wrprotect(src, addr, src_pte);
 +				mmu_notifier_invalidate_range(src, mmun_start,
 +							      mmun_end);
 +			}
 +			entry = huge_ptep_get(src_pte);
++=======
+ 		entry = huge_ptep_get(src_pte);
+ 		if (huge_pte_none(entry)) { /* skip none entry */
+ 			;
+ 		} else if (unlikely(is_hugetlb_entry_migration(entry) ||
+ 				    is_hugetlb_entry_hwpoisoned(entry))) {
+ 			swp_entry_t swp_entry = pte_to_swp_entry(entry);
+ 
+ 			if (is_write_migration_entry(swp_entry) && cow) {
+ 				/*
+ 				 * COW mappings require pages in both
+ 				 * parent and child to be set to read.
+ 				 */
+ 				make_migration_entry_read(&swp_entry);
+ 				entry = swp_entry_to_pte(swp_entry);
+ 				set_huge_pte_at(src, addr, src_pte, entry);
+ 			}
+ 			set_huge_pte_at(dst, addr, dst_pte, entry);
+ 		} else {
+ 			if (cow)
+ 				huge_ptep_set_wrprotect(src, addr, src_pte);
++>>>>>>> 4a705fef9862 (hugetlb: fix copy_hugetlb_page_range() to handle migration/hwpoisoned entry)
  			ptepage = pte_page(entry);
  			get_page(ptepage);
  			page_dup_rmap(ptepage);
* Unmerged path mm/hugetlb.c
