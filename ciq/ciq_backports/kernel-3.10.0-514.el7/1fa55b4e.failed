mei: me: d0i3: enable d0i3 interrupts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit 1fa55b4e0e161b3d16b52f5bab1b39b39607bc27
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1fa55b4e.failed

D0i3 adds additional interrupt reason bit, therefore we add a variable
intr_source to save the interrupt causes for further dispatching.
The interrupt cause is saved in the irq quick handler to achieve
unified behavior for both MSI enabled and shared interrupt platforms.

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 1fa55b4e0e161b3d16b52f5bab1b39b39607bc27)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/hw-me.c
#	drivers/misc/mei/hw-me.h
diff --cc drivers/misc/mei/hw-me.c
index 1707fa5ea02a,910af88b3214..000000000000
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@@ -94,13 -130,44 +94,18 @@@ static inline u32 mei_hcsr_read(const s
   * and ignores the H_IS bit for it is write-one-to-zero.
   *
   * @dev: the device structure
 - * @reg: new register value
   */
 -static inline void mei_hcsr_set(struct mei_device *dev, u32 reg)
 +static inline void mei_hcsr_set(struct mei_me_hw *hw, u32 hcsr)
  {
++<<<<<<< HEAD
 +	hcsr &= ~H_IS;
 +	mei_me_reg_write(hw, H_CSR, hcsr);
++=======
+ 	reg &= ~H_CSR_IS_MASK;
+ 	mei_hcsr_write(dev, reg);
++>>>>>>> 1fa55b4e0e16 (mei: me: d0i3: enable d0i3 interrupts)
  }
  
 -/**
 - * mei_me_fw_status - read fw status register from pci config space
 - *
 - * @dev: mei device
 - * @fw_status: fw status register values
 - *
 - * Return: 0 on success, error otherwise
 - */
 -static int mei_me_fw_status(struct mei_device *dev,
 -			    struct mei_fw_status *fw_status)
 -{
 -	struct pci_dev *pdev = to_pci_dev(dev->dev);
 -	struct mei_me_hw *hw = to_me_hw(dev);
 -	const struct mei_fw_status *fw_src = &hw->cfg->fw_status;
 -	int ret;
 -	int i;
 -
 -	if (!fw_status)
 -		return -EINVAL;
 -
 -	fw_status->count = fw_src->count;
 -	for (i = 0; i < fw_src->count && i < MEI_FW_STATUS_MAX; i++) {
 -		ret = pci_read_config_dword(pdev,
 -			fw_src->status[i], &fw_status->status[i]);
 -		if (ret)
 -			return ret;
 -	}
 -
 -	return 0;
 -}
  
  /**
   * mei_me_hw_config - configure hw dependent settings
@@@ -137,10 -214,10 +142,17 @@@ static inline enum mei_pg_state mei_me_
   */
  static void mei_me_intr_clear(struct mei_device *dev)
  {
++<<<<<<< HEAD
 +	struct mei_me_hw *hw = to_me_hw(dev);
 +	u32 hcsr = mei_hcsr_read(hw);
 +	if ((hcsr & H_IS) == H_IS)
 +		mei_me_reg_write(hw, H_CSR, hcsr);
++=======
+ 	u32 hcsr = mei_hcsr_read(dev);
+ 
+ 	if (hcsr & H_CSR_IS_MASK)
+ 		mei_hcsr_write(dev, hcsr);
++>>>>>>> 1fa55b4e0e16 (mei: me: d0i3: enable d0i3 interrupts)
  }
  /**
   * mei_me_intr_enable - enables mei device interrupts
@@@ -149,10 -226,10 +161,17 @@@
   */
  static void mei_me_intr_enable(struct mei_device *dev)
  {
++<<<<<<< HEAD
 +	struct mei_me_hw *hw = to_me_hw(dev);
 +	u32 hcsr = mei_hcsr_read(hw);
 +	hcsr |= H_IE;
 +	mei_hcsr_set(hw, hcsr);
++=======
+ 	u32 hcsr = mei_hcsr_read(dev);
+ 
+ 	hcsr |= H_CSR_IE_MASK;
+ 	mei_hcsr_set(dev, hcsr);
++>>>>>>> 1fa55b4e0e16 (mei: me: d0i3: enable d0i3 interrupts)
  }
  
  /**
@@@ -162,10 -239,10 +181,17 @@@
   */
  static void mei_me_intr_disable(struct mei_device *dev)
  {
++<<<<<<< HEAD
 +	struct mei_me_hw *hw = to_me_hw(dev);
 +	u32 hcsr = mei_hcsr_read(hw);
 +	hcsr  &= ~H_IE;
 +	mei_hcsr_set(hw, hcsr);
++=======
+ 	u32 hcsr = mei_hcsr_read(dev);
+ 
+ 	hcsr  &= ~H_CSR_IE_MASK;
+ 	mei_hcsr_set(dev, hcsr);
++>>>>>>> 1fa55b4e0e16 (mei: me: d0i3: enable d0i3 interrupts)
  }
  
  /**
@@@ -204,19 -281,19 +230,19 @@@ static int mei_me_hw_reset(struct mei_d
  	if ((hcsr & H_RST) == H_RST) {
  		dev_warn(dev->dev, "H_RST is set = 0x%08X", hcsr);
  		hcsr &= ~H_RST;
 -		mei_hcsr_set(dev, hcsr);
 -		hcsr = mei_hcsr_read(dev);
 +		mei_hcsr_set(hw, hcsr);
 +		hcsr = mei_hcsr_read(hw);
  	}
  
- 	hcsr |= H_RST | H_IG | H_IS;
+ 	hcsr |= H_RST | H_IG | H_CSR_IS_MASK;
  
  	if (intr_enable)
- 		hcsr |= H_IE;
+ 		hcsr |= H_CSR_IE_MASK;
  	else
- 		hcsr &= ~H_IE;
+ 		hcsr &= ~H_CSR_IE_MASK;
  
  	dev->recvd_hw_ready = false;
 -	mei_hcsr_write(dev, hcsr);
 +	mei_me_reg_write(hw, H_CSR, hcsr);
  
  	/*
  	 * Host reads the H_CSR once to ensure that the
@@@ -239,17 -316,16 +265,24 @@@
  /**
   * mei_me_host_set_ready - enable device
   *
 - * @dev: mei device
 + * @dev - mei device
 + * returns bool
   */
 +
  static void mei_me_host_set_ready(struct mei_device *dev)
  {
++<<<<<<< HEAD
 +	struct mei_me_hw *hw = to_me_hw(dev);
 +	hw->host_hw_state = mei_hcsr_read(hw);
 +	hw->host_hw_state |= H_IE | H_IG | H_RDY;
 +	mei_hcsr_set(hw, hw->host_hw_state);
++=======
+ 	u32 hcsr = mei_hcsr_read(dev);
+ 
+ 	hcsr |= H_CSR_IE_MASK | H_IG | H_RDY;
+ 	mei_hcsr_set(dev, hcsr);
++>>>>>>> 1fa55b4e0e16 (mei: me: d0i3: enable d0i3 interrupts)
  }
 -
  /**
   * mei_me_host_is_ready - check whether the host has turned ready
   *
@@@ -608,20 -765,23 +641,35 @@@ notsupported
   * @irq: The irq number
   * @dev_id: pointer to the device structure
   *
 - * Return: irqreturn_t
 + * returns irqreturn_t
   */
- 
  irqreturn_t mei_me_irq_quick_handler(int irq, void *dev_id)
  {
++<<<<<<< HEAD
 +	struct mei_device *dev = (struct mei_device *) dev_id;
 +	struct mei_me_hw *hw = to_me_hw(dev);
 +	u32 csr_reg = mei_hcsr_read(hw);
 +
 +	if ((csr_reg & H_IS) != H_IS)
 +		return IRQ_NONE;
 +
 +	/* clear H_IS bit in H_CSR */
 +	mei_me_reg_write(hw, H_CSR, csr_reg);
++=======
+ 	struct mei_device *dev = (struct mei_device *)dev_id;
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 	u32 hcsr;
+ 
+ 	hcsr = mei_hcsr_read(dev);
+ 	if (!(hcsr & H_CSR_IS_MASK))
+ 		return IRQ_NONE;
+ 
+ 	hw->intr_source = hcsr & H_CSR_IS_MASK;
+ 	dev_dbg(dev->dev, "interrupt source 0x%08X.\n", hw->intr_source);
+ 
+ 	/* clear H_IS and H_D0I3C_IS bits in H_CSR to clear the interrupts */
+ 	mei_hcsr_write(dev, hcsr);
++>>>>>>> 1fa55b4e0e16 (mei: me: d0i3: enable d0i3 interrupts)
  
  	return IRQ_WAKE_THREAD;
  }
@@@ -648,14 -808,9 +696,17 @@@ irqreturn_t mei_me_irq_thread_handler(i
  	mutex_lock(&dev->device_lock);
  	mei_io_list_init(&complete_list);
  
++<<<<<<< HEAD
 +	/* Ack the interrupt here
 +	 * In case of MSI we don't go through the quick handler */
 +	if (pci_dev_msi_enabled(dev->pdev))
 +		mei_clear_interrupts(dev);
 +
++=======
++>>>>>>> 1fa55b4e0e16 (mei: me: d0i3: enable d0i3 interrupts)
  	/* check if ME wants a reset */
  	if (!mei_hw_is_ready(dev) && dev->dev_state != MEI_DEV_RESETTING) {
 -		dev_warn(dev->dev, "FW not ready: resetting.\n");
 +		dev_warn(&dev->pdev->dev, "FW not ready: resetting.\n");
  		schedule_work(&dev->reset_work);
  		goto end;
  	}
diff --cc drivers/misc/mei/hw-me.h
index 98ceac2cee68,2ee14dc1b2ea..000000000000
--- a/drivers/misc/mei/hw-me.h
+++ b/drivers/misc/mei/hw-me.h
@@@ -24,14 -26,41 +24,50 @@@
  #include "mei_dev.h"
  #include "client.h"
  
++<<<<<<< HEAD
++=======
+ /*
+  * mei_cfg - mei device configuration
+  *
+  * @fw_status: FW status
+  * @quirk_probe: device exclusion quirk
+  */
+ struct mei_cfg {
+ 	const struct mei_fw_status fw_status;
+ 	bool (*quirk_probe)(struct pci_dev *pdev);
+ };
+ 
+ 
+ #define MEI_PCI_DEVICE(dev, cfg) \
+ 	.vendor = PCI_VENDOR_ID_INTEL, .device = (dev), \
+ 	.subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID, \
+ 	.driver_data = (kernel_ulong_t)&(cfg)
+ 
+ 
+ #define MEI_ME_RPM_TIMEOUT    500 /* ms */
+ 
+ /**
+  * struct mei_me_hw - me hw specific data
+  *
+  * @cfg: per device generation config and ops
+  * @mem_addr: io memory address
+  * @intr_source: interrupt source
+  * @pg_state: power gating state
+  * @d0i3_supported: di03 support
+  */
++>>>>>>> 1fa55b4e0e16 (mei: me: d0i3: enable d0i3 interrupts)
  struct mei_me_hw {
 -	const struct mei_cfg *cfg;
  	void __iomem *mem_addr;
++<<<<<<< HEAD
 +	/*
 +	 * hw states of host and fw(ME)
 +	 */
 +	u32 host_hw_state;
 +	u32 me_hw_state;
++=======
+ 	u32 intr_source;
++>>>>>>> 1fa55b4e0e16 (mei: me: d0i3: enable d0i3 interrupts)
  	enum mei_pg_state pg_state;
 -	bool d0i3_supported;
  };
  
  #define to_me_hw(dev) (struct mei_me_hw *)((dev)->hw)
diff --git a/drivers/misc/mei/hw-me-regs.h b/drivers/misc/mei/hw-me-regs.h
index 2adc2ee3edc5..d9d5f7d6dc55 100644
--- a/drivers/misc/mei/hw-me-regs.h
+++ b/drivers/misc/mei/hw-me-regs.h
@@ -161,6 +161,10 @@
 /* Host D0I3 Interrupt Status */
 #define H_D0I3C_IS        0x00000040
 
+/* H_CSR masks */
+#define H_CSR_IE_MASK     (H_IE | H_D0I3C_IE)
+#define H_CSR_IS_MASK     (H_IS | H_D0I3C_IS)
+
 /* register bits of ME_CSR_HA (ME Control Status Host Access register) */
 /* ME CB (Circular Buffer) Depth HRA (Host Read Access) - host read only
 access to ME_CBD */
* Unmerged path drivers/misc/mei/hw-me.c
* Unmerged path drivers/misc/mei/hw-me.h
diff --git a/drivers/misc/mei/pci-me.c b/drivers/misc/mei/pci-me.c
index 1eebd0f6a9f0..bdf87dc05581 100644
--- a/drivers/misc/mei/pci-me.c
+++ b/drivers/misc/mei/pci-me.c
@@ -126,6 +126,7 @@ static int mei_me_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	const struct mei_cfg *cfg = (struct mei_cfg *)(ent->driver_data);
 	struct mei_device *dev;
 	struct mei_me_hw *hw;
+	unsigned int irqflags;
 	int err;
 
 	mutex_lock(&mei_mutex);
@@ -183,17 +184,12 @@ static int mei_me_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	pci_enable_msi(pdev);
 
 	 /* request and enable interrupt */
-	if (pci_dev_msi_enabled(pdev))
-		err = request_threaded_irq(pdev->irq,
-			NULL,
-			mei_me_irq_thread_handler,
-			IRQF_ONESHOT, KBUILD_MODNAME, dev);
-	else
-		err = request_threaded_irq(pdev->irq,
+	irqflags = pci_dev_msi_enabled(pdev) ? IRQF_ONESHOT : IRQF_SHARED;
+
+	err = request_threaded_irq(pdev->irq,
 			mei_me_irq_quick_handler,
 			mei_me_irq_thread_handler,
-			IRQF_SHARED, KBUILD_MODNAME, dev);
-
+			irqflags, KBUILD_MODNAME, dev);
 	if (err) {
 		dev_err(&pdev->dev, "request_threaded_irq failure. irq = %d\n",
 		       pdev->irq);
@@ -311,6 +307,7 @@ static int mei_me_pci_resume(struct device *device)
 {
 	struct pci_dev *pdev = to_pci_dev(device);
 	struct mei_device *dev;
+	unsigned int irqflags;
 	int err;
 
 	dev = pci_get_drvdata(pdev);
@@ -319,17 +316,13 @@ static int mei_me_pci_resume(struct device *device)
 
 	pci_enable_msi(pdev);
 
+	irqflags = pci_dev_msi_enabled(pdev) ? IRQF_ONESHOT : IRQF_SHARED;
+
 	/* request and enable interrupt */
-	if (pci_dev_msi_enabled(pdev))
-		err = request_threaded_irq(pdev->irq,
-			NULL,
-			mei_me_irq_thread_handler,
-			IRQF_ONESHOT, KBUILD_MODNAME, dev);
-	else
-		err = request_threaded_irq(pdev->irq,
+	err = request_threaded_irq(pdev->irq,
 			mei_me_irq_quick_handler,
 			mei_me_irq_thread_handler,
-			IRQF_SHARED, KBUILD_MODNAME, dev);
+			irqflags, KBUILD_MODNAME, dev);
 
 	if (err) {
 		dev_err(&pdev->dev, "request_threaded_irq failed: irq = %d.\n",
