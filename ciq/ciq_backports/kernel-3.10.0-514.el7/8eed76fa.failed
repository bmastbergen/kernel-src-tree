i40e: Cleanup the code with respect to restarting autoneg

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Anjali Singhai Jain <anjali.singhai@intel.com>
commit 8eed76fa4885f1ed9f19f4d3a16dd24cebf09c19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8eed76fa.failed

The restart-autoneg work around does not apply to X722.
Added a flag to set it only for the right MAC and right FW version
where the work around should be applied.

	Signed-off-by: Anjali Singhai Jain <anjali.singhai@intel.com>
Change-ID: I942c3ff40cccd1e56f424b1da776b020fe3c9d2a
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 8eed76fa4885f1ed9f19f4d3a16dd24cebf09c19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e.h
diff --cc drivers/net/ethernet/intel/i40e/i40e.h
index bdb06dd3067e,53ed3bdd8363..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@@ -341,6 -339,8 +341,11 @@@ struct i40e_pf 
  #define I40E_FLAG_VEB_MODE_ENABLED		BIT_ULL(40)
  #define I40E_FLAG_GENEVE_OFFLOAD_CAPABLE	BIT_ULL(41)
  #define I40E_FLAG_NO_PCI_LINK_CHECK		BIT_ULL(42)
++<<<<<<< HEAD
++=======
+ #define I40E_FLAG_100M_SGMII_CAPABLE		BIT_ULL(43)
+ #define I40E_FLAG_RESTART_AUTONEG		BIT_ULL(44)
++>>>>>>> 8eed76fa4885 (i40e: Cleanup the code with respect to restarting autoneg)
  #define I40E_FLAG_PF_MAC			BIT_ULL(50)
  
  	/* tracks features that get auto disabled by errors */
* Unmerged path drivers/net/ethernet/intel/i40e/i40e.h
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index dd5ee68c09e9..263f8356512b 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -6905,8 +6905,7 @@ static void i40e_reset_and_rebuild(struct i40e_pf *pf, bool reinit)
 		wr32(hw, I40E_REG_MSS, val);
 	}
 
-	if (((pf->hw.aq.fw_maj_ver == 4) && (pf->hw.aq.fw_min_ver < 33)) ||
-	    (pf->hw.aq.fw_maj_ver < 4)) {
+	if (pf->flags & I40E_FLAG_RESTART_AUTONEG) {
 		msleep(75);
 		ret = i40e_aq_set_link_restart_an(&pf->hw, true, NULL);
 		if (ret)
@@ -8369,6 +8368,12 @@ static int i40e_sw_init(struct i40e_pf *pf)
 				 pf->hw.func_caps.fd_filters_best_effort;
 	}
 
+	if (((pf->hw.mac.type == I40E_MAC_X710) ||
+	     (pf->hw.mac.type == I40E_MAC_XL710)) &&
+	    (((pf->hw.aq.fw_maj_ver == 4) && (pf->hw.aq.fw_min_ver < 33)) ||
+	    (pf->hw.aq.fw_maj_ver < 4)))
+		pf->flags |= I40E_FLAG_RESTART_AUTONEG;
+
 	if (pf->hw.func_caps.vmdq) {
 		pf->num_vmdq_vsis = I40E_DEFAULT_NUM_VMDQ_VSI;
 		pf->flags |= I40E_FLAG_VMDQ_ENABLED;
@@ -10896,8 +10901,7 @@ static int i40e_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		wr32(hw, I40E_REG_MSS, val);
 	}
 
-	if (((pf->hw.aq.fw_maj_ver == 4) && (pf->hw.aq.fw_min_ver < 33)) ||
-	    (pf->hw.aq.fw_maj_ver < 4)) {
+	if (pf->flags & I40E_FLAG_RESTART_AUTONEG) {
 		msleep(75);
 		err = i40e_aq_set_link_restart_an(&pf->hw, true, NULL);
 		if (err)
