cpufreq: powernv: del_timer_sync when global and local pstate are equal

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [cpufreq] powernv: del_timer_sync when global and local pstate are equal (Gustavo Duarte) [1346255]
Rebuild_FUZZ: 93.23%
commit-author Akshay Adiga <akshay.adiga@linux.vnet.ibm.com>
commit 0bc10b93f2d9c6089ce968681ef9febecdc9b8e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0bc10b93.failed

When global and local pstate are equal in a powernv_target_index() call,
we don't queue a timer. But we may have timer already queued for future.
This could cause the timer to fire one additional time for no use.

	Signed-off-by: Akshay Adiga <akshay.adiga@linux.vnet.ibm.com>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 0bc10b93f2d9c6089ce968681ef9febecdc9b8e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/powernv-cpufreq.c
diff --cc drivers/cpufreq/powernv-cpufreq.c
index f171dd3496cc,54c45368e3f1..000000000000
--- a/drivers/cpufreq/powernv-cpufreq.c
+++ b/drivers/cpufreq/powernv-cpufreq.c
@@@ -379,8 -605,59 +379,59 @@@ static int powernv_cpufreq_target_index
  	if (!throttled)
  		powernv_cpufreq_throttle_check(NULL);
  
 -	cur_msec = jiffies_to_msecs(get_jiffies_64());
 -
 -	spin_lock(&gpstates->gpstate_lock);
  	freq_data.pstate_id = powernv_freqs[new_index].driver_data;
  
++<<<<<<< HEAD
++=======
+ 	if (!gpstates->last_sampled_time) {
+ 		gpstate_id = freq_data.pstate_id;
+ 		gpstates->highest_lpstate = freq_data.pstate_id;
+ 		goto gpstates_done;
+ 	}
+ 
+ 	if (gpstates->last_gpstate > freq_data.pstate_id) {
+ 		gpstates->elapsed_time += cur_msec -
+ 						 gpstates->last_sampled_time;
+ 
+ 		/*
+ 		 * If its has been ramping down for more than MAX_RAMP_DOWN_TIME
+ 		 * we should be resetting all global pstate related data. Set it
+ 		 * equal to local pstate to start fresh.
+ 		 */
+ 		if (gpstates->elapsed_time > MAX_RAMP_DOWN_TIME) {
+ 			reset_gpstates(policy);
+ 			gpstates->highest_lpstate = freq_data.pstate_id;
+ 			gpstate_id = freq_data.pstate_id;
+ 		} else {
+ 		/* Elaspsed_time is less than 5 seconds, continue to rampdown */
+ 			gpstate_id = calc_global_pstate(gpstates->elapsed_time,
+ 							gpstates->highest_lpstate,
+ 							freq_data.pstate_id);
+ 		}
+ 	} else {
+ 		reset_gpstates(policy);
+ 		gpstates->highest_lpstate = freq_data.pstate_id;
+ 		gpstate_id = freq_data.pstate_id;
+ 	}
+ 
+ 	/*
+ 	 * If local pstate is equal to global pstate, rampdown is over
+ 	 * So timer is not required to be queued.
+ 	 */
+ 	if (gpstate_id != freq_data.pstate_id)
+ 		queue_gpstate_timer(gpstates);
+ 	else
+ 		del_timer_sync(&gpstates->timer);
+ 
+ gpstates_done:
+ 	freq_data.gpstate_id = gpstate_id;
+ 	gpstates->last_sampled_time = cur_msec;
+ 	gpstates->last_gpstate = freq_data.gpstate_id;
+ 	gpstates->last_lpstate = freq_data.pstate_id;
+ 
+ 	spin_unlock(&gpstates->gpstate_lock);
+ 
++>>>>>>> 0bc10b93f2d9 (cpufreq: powernv: del_timer_sync when global and local pstate are equal)
  	/*
  	 * Use smp_call_function to send IPI and execute the
  	 * mtspr on target CPU.  We could do that without IPI
* Unmerged path drivers/cpufreq/powernv-cpufreq.c
