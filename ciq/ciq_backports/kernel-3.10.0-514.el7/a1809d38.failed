mei: request autosuspend at the end of write

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit a1809d38900cff016b2bac9d82766f7420f8eb5d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a1809d38.failed

On longer non-blocking write might not complete at the end of
autosuspend expiration, therefore we request autosuspend
again on the write completion.

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit a1809d38900cff016b2bac9d82766f7420f8eb5d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/client.c
diff --cc drivers/misc/mei/client.c
index 3c539de435ba,7a5a6636f0fd..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -997,21 -1459,36 +997,36 @@@ err
   */
  void mei_cl_complete(struct mei_cl *cl, struct mei_cl_cb *cb)
  {
++<<<<<<< HEAD
 +	if (cb->fop_type == MEI_FOP_WRITE) {
++=======
+ 	struct mei_device *dev = cl->dev;
+ 
+ 	switch (cb->fop_type) {
+ 	case MEI_FOP_WRITE:
++>>>>>>> a1809d38900c (mei: request autosuspend at the end of write)
  		mei_io_cb_free(cb);
 +		cb = NULL;
  		cl->writing_state = MEI_WRITE_COMPLETE;
- 		if (waitqueue_active(&cl->tx_wait))
+ 		if (waitqueue_active(&cl->tx_wait)) {
  			wake_up_interruptible(&cl->tx_wait);
++<<<<<<< HEAD
++=======
+ 		} else {
+ 			pm_runtime_mark_last_busy(dev->dev);
+ 			pm_request_autosuspend(dev->dev);
+ 		}
+ 		break;
++>>>>>>> a1809d38900c (mei: request autosuspend at the end of write)
  
 -	case MEI_FOP_READ:
 -		list_add_tail(&cb->list, &cl->rd_completed);
 +	} else if (cb->fop_type == MEI_FOP_READ &&
 +			MEI_READING == cl->reading_state) {
 +		cl->reading_state = MEI_READ_COMPLETE;
  		if (waitqueue_active(&cl->rx_wait))
 -			wake_up_interruptible_all(&cl->rx_wait);
 +			wake_up_interruptible(&cl->rx_wait);
  		else
  			mei_cl_bus_rx_event(cl);
 -		break;
  
 -	case MEI_FOP_CONNECT:
 -	case MEI_FOP_DISCONNECT:
 -		if (waitqueue_active(&cl->wait))
 -			wake_up(&cl->wait);
 -
 -		break;
 -	default:
 -		BUG_ON(0);
  	}
  }
  
* Unmerged path drivers/misc/mei/client.c
