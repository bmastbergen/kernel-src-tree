IB/hfi1: Add trace message in user IOCTL handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit 8a1882ebd4b593df0e36ba0b72e4e2f632573274
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8a1882eb.failed

Add a trace message to HFI1s user IOCTL handling. This allows debugging
of which IOCTLs are being handled by the driver.

	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 8a1882ebd4b593df0e36ba0b72e4e2f632573274)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/file_ops.c
#	drivers/staging/hfi1/trace.c
#	drivers/staging/rdma/hfi1/trace.h
diff --cc drivers/staging/hfi1/file_ops.c
index 89c4fc4847ca,113917021af8..000000000000
--- a/drivers/staging/hfi1/file_ops.c
+++ b/drivers/staging/hfi1/file_ops.c
@@@ -201,115 -175,49 +201,123 @@@ static int hfi1_file_open(struct inode 
  	return fp->private_data ? 0 : -ENOMEM;
  }
  
 -static long hfi1_file_ioctl(struct file *fp, unsigned int cmd,
 -			    unsigned long arg)
 +static ssize_t hfi1_file_write(struct file *fp, const char __user *data,
 +			       size_t count, loff_t *offset)
  {
 +	const struct hfi1_cmd __user *ucmd;
  	struct hfi1_filedata *fd = fp->private_data;
  	struct hfi1_ctxtdata *uctxt = fd->uctxt;
 +	struct hfi1_cmd cmd;
  	struct hfi1_user_info uinfo;
  	struct hfi1_tid_info tinfo;
 -	int ret = 0;
 -	unsigned long addr;
 -	int uval = 0;
 -	unsigned long ul_uval = 0;
 -	u16 uval16 = 0;
 -
 +	ssize_t consumed = 0, copy = 0, ret = 0;
 +	void *dest = NULL;
 +	__u64 user_val = 0;
 +	int uctxt_required = 1;
 +	int must_be_root = 0;
 +
++<<<<<<< HEAD:drivers/staging/hfi1/file_ops.c
 +	if (count < sizeof(cmd)) {
 +		ret = -EINVAL;
 +		goto bail;
 +	}
++=======
+ 	hfi1_cdbg(IOCTL, "IOCTL recv: 0x%x", cmd);
+ 	if (cmd != HFI1_IOCTL_ASSIGN_CTXT &&
+ 	    cmd != HFI1_IOCTL_GET_VERS &&
+ 	    !uctxt)
+ 		return -EINVAL;
++>>>>>>> 8a1882ebd4b5 (IB/hfi1: Add trace message in user IOCTL handling):drivers/staging/rdma/hfi1/file_ops.c
 +
 +	ucmd = (const struct hfi1_cmd __user *)data;
 +	if (copy_from_user(&cmd, ucmd, sizeof(cmd))) {
 +		ret = -EFAULT;
 +		goto bail;
 +	}
  
 -	switch (cmd) {
 -	case HFI1_IOCTL_ASSIGN_CTXT:
 -		if (copy_from_user(&uinfo,
 -				   (struct hfi1_user_info __user *)arg,
 -				   sizeof(uinfo)))
 -			return -EFAULT;
 +	consumed = sizeof(cmd);
  
 +	switch (cmd.type) {
 +	case HFI1_CMD_ASSIGN_CTXT:
 +		uctxt_required = 0;	/* assigned user context not required */
 +		copy = sizeof(uinfo);
 +		dest = &uinfo;
 +		break;
 +	case HFI1_CMD_CREDIT_UPD:
 +		copy = 0;
 +		break;
 +	case HFI1_CMD_TID_UPDATE:
 +	case HFI1_CMD_TID_FREE:
 +		copy = sizeof(tinfo);
 +		dest = &tinfo;
 +		break;
 +	case HFI1_CMD_USER_INFO:
 +	case HFI1_CMD_RECV_CTRL:
 +	case HFI1_CMD_POLL_TYPE:
 +	case HFI1_CMD_ACK_EVENT:
 +	case HFI1_CMD_CTXT_INFO:
 +	case HFI1_CMD_SET_PKEY:
 +	case HFI1_CMD_CTXT_RESET:
 +		copy = 0;
 +		user_val = cmd.addr;
 +		break;
 +	case HFI1_CMD_EP_INFO:
 +	case HFI1_CMD_EP_ERASE_CHIP:
 +	case HFI1_CMD_EP_ERASE_RANGE:
 +	case HFI1_CMD_EP_READ_RANGE:
 +	case HFI1_CMD_EP_WRITE_RANGE:
 +		uctxt_required = 0;	/* assigned user context not required */
 +		must_be_root = 1;	/* validate user */
 +		copy = 0;
 +		break;
 +	case HFI1_CMD_TID_INVAL_READ:
 +	default:
 +		ret = -EINVAL;
 +		goto bail;
 +	}
 +
 +	/* If the command comes with user data, copy it. */
 +	if (copy) {
 +		if (copy_from_user(dest, (void __user *)cmd.addr, copy)) {
 +			ret = -EFAULT;
 +			goto bail;
 +		}
 +		consumed += copy;
 +	}
 +
 +	/*
 +	 * Make sure there is a uctxt when needed.
 +	 */
 +	if (uctxt_required && !uctxt) {
 +		ret = -EINVAL;
 +		goto bail;
 +	}
 +
 +	/* only root can do these operations */
 +	if (must_be_root && !capable(CAP_SYS_ADMIN)) {
 +		ret = -EPERM;
 +		goto bail;
 +	}
 +
 +	switch (cmd.type) {
 +	case HFI1_CMD_ASSIGN_CTXT:
  		ret = assign_ctxt(fp, &uinfo);
  		if (ret < 0)
 -			return ret;
 -		setup_ctxt(fp);
 +			goto bail;
 +		ret = setup_ctxt(fp);
  		if (ret)
 -			return ret;
 +			goto bail;
  		ret = user_init(fp);
  		break;
 -	case HFI1_IOCTL_CTXT_INFO:
 -		ret = get_ctxt_info(fp, (void __user *)(unsigned long)arg,
 -				    sizeof(struct hfi1_ctxt_info));
 +	case HFI1_CMD_CTXT_INFO:
 +		ret = get_ctxt_info(fp, (void __user *)(unsigned long)
 +				    user_val, cmd.len);
  		break;
 -	case HFI1_IOCTL_USER_INFO:
 -		ret = get_base_info(fp, (void __user *)(unsigned long)arg,
 -				    sizeof(struct hfi1_base_info));
 +	case HFI1_CMD_USER_INFO:
 +		ret = get_base_info(fp, (void __user *)(unsigned long)
 +				    user_val, cmd.len);
  		break;
 -	case HFI1_IOCTL_CREDIT_UPD:
 +	case HFI1_CMD_CREDIT_UPD:
  		if (uctxt && uctxt->sc)
  			sc_return_credits(uctxt->sc);
  		break;
diff --cc drivers/staging/hfi1/trace.c
index 10122e84cb2f,caddb2ac3cfc..000000000000
--- a/drivers/staging/hfi1/trace.c
+++ b/drivers/staging/hfi1/trace.c
@@@ -234,3 -232,5 +234,8 @@@ __hfi1_trace_fn(DC8051)
  __hfi1_trace_fn(FIRMWARE);
  __hfi1_trace_fn(RCVCTRL);
  __hfi1_trace_fn(TID);
++<<<<<<< HEAD:drivers/staging/hfi1/trace.c
++=======
+ __hfi1_trace_fn(MMU);
+ __hfi1_trace_fn(IOCTL);
++>>>>>>> 8a1882ebd4b5 (IB/hfi1: Add trace message in user IOCTL handling):drivers/staging/rdma/hfi1/trace.c
* Unmerged path drivers/staging/rdma/hfi1/trace.h
* Unmerged path drivers/staging/hfi1/file_ops.c
* Unmerged path drivers/staging/hfi1/trace.c
* Unmerged path drivers/staging/rdma/hfi1/trace.h
