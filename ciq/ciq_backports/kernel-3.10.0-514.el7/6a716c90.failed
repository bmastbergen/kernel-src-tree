hung_task debugging: Add tracepoint to report the hang

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Oleg Nesterov <oleg@redhat.com>
commit 6a716c90a51338009c3bc1f460829afaed8f922d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6a716c90.failed

Currently check_hung_task() prints a warning if it detects the
problem, but it is not convenient to watch the system logs if
user-space wants to be notified about the hang.

Add the new trace_sched_process_hang() into check_hung_task(),
this way a user-space monitor can easily wait for the hang and
potentially resolve a problem.

	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Cc: Dave Sullivan <dsulliva@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Steven Rostedt <rostedt@goodmis.org>
Link: http://lkml.kernel.org/r/20131019161828.GA7439@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 6a716c90a51338009c3bc1f460829afaed8f922d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/trace/events/sched.h
#	kernel/hung_task.c
diff --cc include/trace/events/sched.h
index b74757610677,2a652d124fbb..000000000000
--- a/include/trace/events/sched.h
+++ b/include/trace/events/sched.h
@@@ -430,113 -424,25 +430,135 @@@ TRACE_EVENT(sched_pi_setprio
  			__entry->oldprio, __entry->newprio)
  );
  
++<<<<<<< HEAD
 +DECLARE_EVENT_CLASS(sched_move_task_template,
 +
 +	TP_PROTO(struct task_struct *tsk, int src_cpu, int dst_cpu),
 +
 +	TP_ARGS(tsk, src_cpu, dst_cpu),
 +
 +	TP_STRUCT__entry(
 +		__field( pid_t,	pid			)
 +		__field( pid_t,	tgid			)
 +		__field( pid_t,	ngid			)
 +		__field( int,	src_cpu			)
 +		__field( int,	src_nid			)
 +		__field( int,	dst_cpu			)
 +		__field( int,	dst_nid			)
 +	),
 +
 +	TP_fast_assign(
 +		__entry->pid		= task_pid_nr(tsk);
 +		__entry->tgid		= task_tgid_nr(tsk);
 +		__entry->ngid		= task_numa_group_id(tsk);
 +		__entry->src_cpu	= src_cpu;
 +		__entry->src_nid	= cpu_to_node(src_cpu);
 +		__entry->dst_cpu	= dst_cpu;
 +		__entry->dst_nid	= cpu_to_node(dst_cpu);
 +	),
 +
 +	TP_printk("pid=%d tgid=%d ngid=%d src_cpu=%d src_nid=%d dst_cpu=%d dst_nid=%d",
 +			__entry->pid, __entry->tgid, __entry->ngid,
 +			__entry->src_cpu, __entry->src_nid,
 +			__entry->dst_cpu, __entry->dst_nid)
 +);
 +
 +/*
 + * Tracks migration of tasks from one runqueue to another. Can be used to
 + * detect if automatic NUMA balancing is bouncing between nodes
 + */
 +DEFINE_EVENT(sched_move_task_template, sched_move_numa,
 +	TP_PROTO(struct task_struct *tsk, int src_cpu, int dst_cpu),
 +
 +	TP_ARGS(tsk, src_cpu, dst_cpu)
 +);
 +
 +DEFINE_EVENT(sched_move_task_template, sched_stick_numa,
 +	TP_PROTO(struct task_struct *tsk, int src_cpu, int dst_cpu),
 +
 +	TP_ARGS(tsk, src_cpu, dst_cpu)
 +);
 +
 +TRACE_EVENT(sched_swap_numa,
 +
 +	TP_PROTO(struct task_struct *src_tsk, int src_cpu,
 +		 struct task_struct *dst_tsk, int dst_cpu),
 +
 +	TP_ARGS(src_tsk, src_cpu, dst_tsk, dst_cpu),
 +
 +	TP_STRUCT__entry(
 +		__field( pid_t,	src_pid			)
 +		__field( pid_t,	src_tgid		)
 +		__field( pid_t,	src_ngid		)
 +		__field( int,	src_cpu			)
 +		__field( int,	src_nid			)
 +		__field( pid_t,	dst_pid			)
 +		__field( pid_t,	dst_tgid		)
 +		__field( pid_t,	dst_ngid		)
 +		__field( int,	dst_cpu			)
 +		__field( int,	dst_nid			)
 +	),
 +
 +	TP_fast_assign(
 +		__entry->src_pid	= task_pid_nr(src_tsk);
 +		__entry->src_tgid	= task_tgid_nr(src_tsk);
 +		__entry->src_ngid	= task_numa_group_id(src_tsk);
 +		__entry->src_cpu	= src_cpu;
 +		__entry->src_nid	= cpu_to_node(src_cpu);
 +		__entry->dst_pid	= task_pid_nr(dst_tsk);
 +		__entry->dst_tgid	= task_tgid_nr(dst_tsk);
 +		__entry->dst_ngid	= task_numa_group_id(dst_tsk);
 +		__entry->dst_cpu	= dst_cpu;
 +		__entry->dst_nid	= cpu_to_node(dst_cpu);
 +	),
 +
 +	TP_printk("src_pid=%d src_tgid=%d src_ngid=%d src_cpu=%d src_nid=%d dst_pid=%d dst_tgid=%d dst_ngid=%d dst_cpu=%d dst_nid=%d",
 +			__entry->src_pid, __entry->src_tgid, __entry->src_ngid,
 +			__entry->src_cpu, __entry->src_nid,
 +			__entry->dst_pid, __entry->dst_tgid, __entry->dst_ngid,
 +			__entry->dst_cpu, __entry->dst_nid)
 +);
 +
 +/*
 + * Tracepoint for waking a polling cpu without an IPI.
 + */
 +TRACE_EVENT(sched_wake_idle_without_ipi,
 +
 +	TP_PROTO(int cpu),
 +
 +	TP_ARGS(cpu),
 +
 +	TP_STRUCT__entry(
 +		__field(	int,	cpu	)
 +	),
 +
 +	TP_fast_assign(
 +		__entry->cpu	= cpu;
 +	),
 +
 +	TP_printk("cpu=%d", __entry->cpu)
 +);
++=======
+ #ifdef CONFIG_DETECT_HUNG_TASK
+ TRACE_EVENT(sched_process_hang,
+ 	TP_PROTO(struct task_struct *tsk),
+ 	TP_ARGS(tsk),
+ 
+ 	TP_STRUCT__entry(
+ 		__array( char,	comm,	TASK_COMM_LEN	)
+ 		__field( pid_t,	pid			)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		memcpy(__entry->comm, tsk->comm, TASK_COMM_LEN);
+ 		__entry->pid = tsk->pid;
+ 	),
+ 
+ 	TP_printk("comm=%s pid=%d", __entry->comm, __entry->pid)
+ );
+ #endif /* CONFIG_DETECT_HUNG_TASK */
+ 
++>>>>>>> 6a716c90a513 (hung_task debugging: Add tracepoint to report the hang)
  #endif /* _TRACE_SCHED_H */
  
  /* This part must be outside protection */
diff --cc kernel/hung_task.c
index 1e66fb34e48f,8807061ca004..000000000000
--- a/kernel/hung_task.c
+++ b/kernel/hung_task.c
@@@ -15,6 -15,8 +15,11 @@@
  #include <linux/lockdep.h>
  #include <linux/export.h>
  #include <linux/sysctl.h>
++<<<<<<< HEAD
++=======
+ #include <linux/utsname.h>
+ #include <trace/events/sched.h>
++>>>>>>> 6a716c90a513 (hung_task debugging: Add tracepoint to report the hang)
  
  /*
   * The number of tasks checked:
* Unmerged path include/trace/events/sched.h
* Unmerged path kernel/hung_task.c
