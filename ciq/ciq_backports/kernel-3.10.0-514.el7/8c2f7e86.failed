libnvdimm: infrastructure for btt devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit 8c2f7e8658df1d3b7cbfa62706941d14c715823a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8c2f7e86.failed

NVDIMM namespaces, in addition to accepting "struct bio" based requests,
also have the capability to perform byte-aligned accesses.  By default
only the bio/block interface is used.  However, if another driver can
make effective use of the byte-aligned capability it can claim namespace
interface and use the byte-aligned ->rw_bytes() interface.

The BTT driver is the initial first consumer of this mechanism to allow
adding atomic sector update semantics to a pmem or blk namespace.  This
patch is the sysfs infrastructure to allow configuring a BTT instance
for a namespace.  Enabling that BTT and performing i/o is in a
subsequent patch.

	Cc: Greg KH <gregkh@linuxfoundation.org>
	Cc: Neil Brown <neilb@suse.de>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 8c2f7e8658df1d3b7cbfa62706941d14c715823a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/btt.h
#	drivers/block/btt_devs.c
#	drivers/block/pmem.c
#	drivers/nvdimm/Kconfig
#	drivers/nvdimm/Makefile
#	drivers/nvdimm/bus.c
#	drivers/nvdimm/label.c
#	drivers/nvdimm/namespace_devs.c
#	drivers/nvdimm/nd-core.h
#	drivers/nvdimm/nd.h
#	drivers/nvdimm/region.c
#	drivers/nvdimm/region_devs.c
#	include/linux/nd.h
diff --cc drivers/block/pmem.c
index d46975ed9e40,d0c6b4bdba69..000000000000
--- a/drivers/block/pmem.c
+++ b/drivers/block/pmem.c
@@@ -200,9 -232,16 +232,19 @@@ static void pmem_free(struct pmem_devic
  static int nd_pmem_probe(struct device *dev)
  {
  	struct nd_region *nd_region = to_nd_region(dev->parent);
- 	struct nd_namespace_io *nsio = to_nd_namespace_io(dev);
+ 	struct nd_namespace_common *ndns;
+ 	struct nd_namespace_io *nsio;
  	struct pmem_device *pmem;
+ 	int rc;
+ 
++<<<<<<< HEAD:drivers/block/pmem.c
++=======
+ 	ndns = nvdimm_namespace_common_probe(dev);
+ 	if (IS_ERR(ndns))
+ 		return PTR_ERR(ndns);
  
+ 	nsio = to_nd_namespace_io(&ndns->dev);
++>>>>>>> 8c2f7e8658df (libnvdimm: infrastructure for btt devices):drivers/nvdimm/pmem.c
  	pmem = pmem_alloc(dev, &nsio->res, nd_region->id);
  	if (IS_ERR(pmem))
  		return PTR_ERR(pmem);
* Unmerged path drivers/block/btt.h
* Unmerged path drivers/block/btt_devs.c
* Unmerged path drivers/nvdimm/Kconfig
* Unmerged path drivers/nvdimm/Makefile
* Unmerged path drivers/nvdimm/bus.c
* Unmerged path drivers/nvdimm/label.c
* Unmerged path drivers/nvdimm/namespace_devs.c
* Unmerged path drivers/nvdimm/nd-core.h
* Unmerged path drivers/nvdimm/nd.h
* Unmerged path drivers/nvdimm/region.c
* Unmerged path drivers/nvdimm/region_devs.c
* Unmerged path include/linux/nd.h
* Unmerged path drivers/block/btt.h
* Unmerged path drivers/block/btt_devs.c
* Unmerged path drivers/block/pmem.c
* Unmerged path drivers/nvdimm/Kconfig
* Unmerged path drivers/nvdimm/Makefile
* Unmerged path drivers/nvdimm/bus.c
* Unmerged path drivers/nvdimm/label.c
* Unmerged path drivers/nvdimm/namespace_devs.c
* Unmerged path drivers/nvdimm/nd-core.h
* Unmerged path drivers/nvdimm/nd.h
* Unmerged path drivers/nvdimm/region.c
* Unmerged path drivers/nvdimm/region_devs.c
* Unmerged path include/linux/nd.h
