netfilter: nf_tables: add register parsing/dumping helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Patrick McHardy <kaber@trash.net>
commit b1c96ed37ceeef5573402d4af202897edaf1e4b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b1c96ed3.failed

Add helper functions to parse and dump register values in netlink attributes.
These helpers will later be changed to take care of translation between the
old 128 bit and the new 32 bit register numbers.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit b1c96ed37ceeef5573402d4af202897edaf1e4b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables.h
#	net/bridge/netfilter/nft_meta_bridge.c
#	net/netfilter/nft_bitwise.c
#	net/netfilter/nft_byteorder.c
#	net/netfilter/nft_cmp.c
#	net/netfilter/nft_ct.c
#	net/netfilter/nft_dynset.c
#	net/netfilter/nft_exthdr.c
#	net/netfilter/nft_immediate.c
#	net/netfilter/nft_lookup.c
#	net/netfilter/nft_meta.c
#	net/netfilter/nft_nat.c
#	net/netfilter/nft_payload.c
diff --cc include/net/netfilter/nf_tables.h
index 4ab50d820db0,f8f27a48bbe9..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -112,12 -128,14 +112,23 @@@ static inline enum nft_registers nft_ty
  	return type == NFT_DATA_VERDICT ? NFT_REG_VERDICT : NFT_REG_1;
  }
  
++<<<<<<< HEAD
 +int nft_validate_input_register(enum nft_registers reg);
 +int nft_validate_output_register(enum nft_registers reg);
 +int nft_validate_data_load(const struct nft_ctx *ctx, enum nft_registers reg,
 +			   const struct nft_data *data,
 +			   enum nft_data_types type);
 +
++=======
+ unsigned int nft_parse_register(const struct nlattr *attr);
+ int nft_dump_register(struct sk_buff *skb, unsigned int attr, unsigned int reg);
+ 
+ int nft_validate_register_load(enum nft_registers reg, unsigned int len);
+ int nft_validate_register_store(const struct nft_ctx *ctx,
+ 				enum nft_registers reg,
+ 				const struct nft_data *data,
+ 				enum nft_data_types type, unsigned int len);
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  
  /**
   *	struct nft_userdata - user defined data associated with an object
diff --cc net/bridge/netfilter/nft_meta_bridge.c
index 4f02109d708f,99dab70ecae0..000000000000
--- a/net/bridge/netfilter/nft_meta_bridge.c
+++ b/net/bridge/netfilter/nft_meta_bridge.c
@@@ -64,16 -65,9 +64,22 @@@ static int nft_meta_bridge_get_init(con
  		return nft_meta_get_init(ctx, expr, tb);
  	}
  
++<<<<<<< HEAD
 +	priv->dreg = ntohl(nla_get_be32(tb[NFTA_META_DREG]));
 +	err = nft_validate_output_register(priv->dreg);
 +	if (err < 0)
 +		return err;
 +
 +	err = nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
 +	if (err < 0)
 +		return err;
 +
 +	return 0;
++=======
+ 	priv->dreg = nft_parse_register(tb[NFTA_META_DREG]);
+ 	return nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					   NFT_DATA_VALUE, len);
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  }
  
  static struct nft_expr_type nft_meta_bridge_type;
diff --cc net/netfilter/nft_bitwise.c
index 4fb6ee2c1106,aa1147032ace..000000000000
--- a/net/netfilter/nft_bitwise.c
+++ b/net/netfilter/nft_bitwise.c
@@@ -63,20 -61,17 +63,32 @@@ static int nft_bitwise_init(const struc
  	    tb[NFTA_BITWISE_XOR] == NULL)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	priv->sreg = ntohl(nla_get_be32(tb[NFTA_BITWISE_SREG]));
 +	err = nft_validate_input_register(priv->sreg);
 +	if (err < 0)
 +		return err;
 +
 +	priv->dreg = ntohl(nla_get_be32(tb[NFTA_BITWISE_DREG]));
 +	err = nft_validate_output_register(priv->dreg);
++=======
+ 	priv->len  = ntohl(nla_get_be32(tb[NFTA_BITWISE_LEN]));
+ 	priv->sreg = nft_parse_register(tb[NFTA_BITWISE_SREG]);
+ 	err = nft_validate_register_load(priv->sreg, priv->len);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	priv->dreg = nft_parse_register(tb[NFTA_BITWISE_DREG]);
+ 	err = nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					  NFT_DATA_VALUE, priv->len);
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  	if (err < 0)
  		return err;
 +	err = nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
 +	if (err < 0)
 +		return err;
 +
 +	priv->len = ntohl(nla_get_be32(tb[NFTA_BITWISE_LEN]));
  
  	err = nft_data_init(NULL, &priv->mask, &d1, tb[NFTA_BITWISE_MASK]);
  	if (err < 0)
diff --cc net/netfilter/nft_byteorder.c
index c39ed8d29df1,2ee3e57ad814..000000000000
--- a/net/netfilter/nft_byteorder.c
+++ b/net/netfilter/nft_byteorder.c
@@@ -122,7 -106,15 +122,19 @@@ static int nft_byteorder_init(const str
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	priv->sreg = nft_parse_register(tb[NFTA_BYTEORDER_SREG]);
+ 	priv->len  = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_LEN]));
+ 	err = nft_validate_register_load(priv->sreg, priv->len);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	priv->dreg = nft_parse_register(tb[NFTA_BYTEORDER_DREG]);
+ 	return nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					   NFT_DATA_VALUE, priv->len);
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  }
  
  static int nft_byteorder_dump(struct sk_buff *skb, const struct nft_expr *expr)
diff --cc net/netfilter/nft_cmp.c
index e2b3f51c81f1,ffaf214dd256..000000000000
--- a/net/netfilter/nft_cmp.c
+++ b/net/netfilter/nft_cmp.c
@@@ -81,6 -78,12 +81,15 @@@ static int nft_cmp_init(const struct nf
  	err = nft_data_init(NULL, &priv->data, &desc, tb[NFTA_CMP_DATA]);
  	BUG_ON(err < 0);
  
++<<<<<<< HEAD
++=======
+ 	priv->sreg = nft_parse_register(tb[NFTA_CMP_SREG]);
+ 	err = nft_validate_register_load(priv->sreg, desc.len);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	priv->op  = ntohl(nla_get_be32(tb[NFTA_CMP_OP]));
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  	priv->len = desc.len;
  	return 0;
  }
@@@ -122,13 -125,17 +131,22 @@@ static int nft_cmp_fast_init(const stru
  	u32 mask;
  	int err;
  
 +	priv->sreg = ntohl(nla_get_be32(tb[NFTA_CMP_SREG]));
 +
  	err = nft_data_init(NULL, &data, &desc, tb[NFTA_CMP_DATA]);
  	BUG_ON(err < 0);
++<<<<<<< HEAD
++=======
+ 
+ 	priv->sreg = nft_parse_register(tb[NFTA_CMP_SREG]);
+ 	err = nft_validate_register_load(priv->sreg, desc.len);
+ 	if (err < 0)
+ 		return err;
+ 
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  	desc.len *= BITS_PER_BYTE;
 -	mask = nft_cmp_fast_mask(desc.len);
  
 +	mask = nft_cmp_fast_mask(desc.len);
  	priv->data = data.data[0] & mask;
  	priv->len  = desc.len;
  	return 0;
diff --cc net/netfilter/nft_ct.c
index 18d520e0ca0a,fab8e754b18a..000000000000
--- a/net/netfilter/nft_ct.c
+++ b/net/netfilter/nft_ct.c
@@@ -273,12 -306,9 +273,18 @@@ static int nft_ct_get_init(const struc
  		}
  	}
  
++<<<<<<< HEAD
 +	priv->dreg = ntohl(nla_get_be32(tb[NFTA_CT_DREG]));
 +	err = nft_validate_output_register(priv->dreg);
 +	if (err < 0)
 +		return err;
 +
 +	err = nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
++=======
+ 	priv->dreg = nft_parse_register(tb[NFTA_CT_DREG]);
+ 	err = nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					  NFT_DATA_VALUE, len);
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  	if (err < 0)
  		return err;
  
@@@ -306,8 -338,8 +312,13 @@@ static int nft_ct_set_init(const struc
  		return -EOPNOTSUPP;
  	}
  
++<<<<<<< HEAD
 +	priv->sreg = ntohl(nla_get_be32(tb[NFTA_CT_SREG]));
 +	err = nft_validate_input_register(priv->sreg);
++=======
+ 	priv->sreg = nft_parse_register(tb[NFTA_CT_SREG]);
+ 	err = nft_validate_register_load(priv->sreg, len);
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  	if (err < 0)
  		return err;
  
diff --cc net/netfilter/nft_exthdr.c
index 55c939f5371f,098ffee793d7..000000000000
--- a/net/netfilter/nft_exthdr.c
+++ b/net/netfilter/nft_exthdr.c
@@@ -69,15 -68,10 +69,19 @@@ static int nft_exthdr_init(const struc
  	priv->type   = nla_get_u8(tb[NFTA_EXTHDR_TYPE]);
  	priv->offset = ntohl(nla_get_be32(tb[NFTA_EXTHDR_OFFSET]));
  	priv->len    = ntohl(nla_get_be32(tb[NFTA_EXTHDR_LEN]));
++<<<<<<< HEAD
 +	if (priv->len == 0 ||
 +	    priv->len > FIELD_SIZEOF(struct nft_data, data))
 +		return -EINVAL;
++=======
+ 	priv->dreg   = nft_parse_register(tb[NFTA_EXTHDR_DREG]);
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  
 -	return nft_validate_register_store(ctx, priv->dreg, NULL,
 -					   NFT_DATA_VALUE, priv->len);
 +	priv->dreg = ntohl(nla_get_be32(tb[NFTA_EXTHDR_DREG]));
 +	err = nft_validate_output_register(priv->dreg);
 +	if (err < 0)
 +		return err;
 +	return nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
  }
  
  static int nft_exthdr_dump(struct sk_buff *skb, const struct nft_expr *expr)
diff --cc net/netfilter/nft_immediate.c
index 810385eb7249,0682f600c7a5..000000000000
--- a/net/netfilter/nft_immediate.c
+++ b/net/netfilter/nft_immediate.c
@@@ -59,7 -54,9 +59,13 @@@ static int nft_immediate_init(const str
  		return err;
  	priv->dlen = desc.len;
  
++<<<<<<< HEAD
 +	err = nft_validate_data_load(ctx, priv->dreg, &priv->data, desc.type);
++=======
+ 	priv->dreg = nft_parse_register(tb[NFTA_IMMEDIATE_DREG]);
+ 	err = nft_validate_register_store(ctx, priv->dreg, &priv->data,
+ 					  desc.type, desc.len);
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  	if (err < 0)
  		goto err1;
  
diff --cc net/netfilter/nft_lookup.c
index f8e400a6b239,fc7afff81566..000000000000
--- a/net/netfilter/nft_lookup.c
+++ b/net/netfilter/nft_lookup.c
@@@ -66,8 -71,8 +66,13 @@@ static int nft_lookup_init(const struc
  			return PTR_ERR(set);
  	}
  
++<<<<<<< HEAD
 +	priv->sreg = ntohl(nla_get_be32(tb[NFTA_LOOKUP_SREG]));
 +	err = nft_validate_input_register(priv->sreg);
++=======
+ 	priv->sreg = nft_parse_register(tb[NFTA_LOOKUP_SREG]);
+ 	err = nft_validate_register_load(priv->sreg, set->klen);
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  	if (err < 0)
  		return err;
  
@@@ -75,16 -80,11 +80,22 @@@
  		if (!(set->flags & NFT_SET_MAP))
  			return -EINVAL;
  
++<<<<<<< HEAD
 +		priv->dreg = ntohl(nla_get_be32(tb[NFTA_LOOKUP_DREG]));
 +		err = nft_validate_output_register(priv->dreg);
++=======
+ 		priv->dreg = nft_parse_register(tb[NFTA_LOOKUP_DREG]);
+ 		err = nft_validate_register_store(ctx, priv->dreg, NULL,
+ 						  set->dtype, set->dlen);
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  		if (err < 0)
  			return err;
 +
 +		if (priv->dreg == NFT_REG_VERDICT) {
 +			if (set->dtype != NFT_DATA_VERDICT)
 +				return -EINVAL;
 +		} else if (set->dtype == NFT_DATA_VERDICT)
 +			return -EINVAL;
  	} else if (set->flags & NFT_SET_MAP)
  		return -EINVAL;
  
diff --cc net/netfilter/nft_meta.c
index a4cdc254de57,5f744eb61de5..000000000000
--- a/net/netfilter/nft_meta.c
+++ b/net/netfilter/nft_meta.c
@@@ -251,16 -254,9 +251,22 @@@ int nft_meta_get_init(const struct nft_
  		return -EOPNOTSUPP;
  	}
  
++<<<<<<< HEAD
 +	priv->dreg = ntohl(nla_get_be32(tb[NFTA_META_DREG]));
 +	err = nft_validate_output_register(priv->dreg);
 +	if (err < 0)
 +		return err;
 +
 +	err = nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
 +	if (err < 0)
 +		return err;
 +
 +	return 0;
++=======
+ 	priv->dreg = nft_parse_register(tb[NFTA_META_DREG]);
+ 	return nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					   NFT_DATA_VALUE, len);
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  }
  EXPORT_SYMBOL_GPL(nft_meta_get_init);
  
@@@ -281,8 -281,8 +287,13 @@@ int nft_meta_set_init(const struct nft_
  		return -EOPNOTSUPP;
  	}
  
++<<<<<<< HEAD
 +	priv->sreg = ntohl(nla_get_be32(tb[NFTA_META_SREG]));
 +	err = nft_validate_input_register(priv->sreg);
++=======
+ 	priv->sreg = nft_parse_register(tb[NFTA_META_SREG]);
+ 	err = nft_validate_register_load(priv->sreg, len);
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  	if (err < 0)
  		return err;
  
diff --cc net/netfilter/nft_nat.c
index a0837c6c9283,065cbda63b0a..000000000000
--- a/net/netfilter/nft_nat.c
+++ b/net/netfilter/nft_nat.c
@@@ -154,17 -163,17 +154,22 @@@ static int nft_nat_init(const struct nf
  
  	if (tb[NFTA_NAT_REG_ADDR_MIN]) {
  		priv->sreg_addr_min =
++<<<<<<< HEAD
 +			ntohl(nla_get_be32(tb[NFTA_NAT_REG_ADDR_MIN]));
 +
 +		err = nft_validate_input_register(priv->sreg_addr_min);
++=======
+ 			nft_parse_register(tb[NFTA_NAT_REG_ADDR_MIN]);
+ 		err = nft_validate_register_load(priv->sreg_addr_min, alen);
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  		if (err < 0)
  			return err;
  
  		if (tb[NFTA_NAT_REG_ADDR_MAX]) {
  			priv->sreg_addr_max =
- 				ntohl(nla_get_be32(tb[NFTA_NAT_REG_ADDR_MAX]));
+ 				nft_parse_register(tb[NFTA_NAT_REG_ADDR_MAX]);
  
 -			err = nft_validate_register_load(priv->sreg_addr_max,
 -							 alen);
 +			err = nft_validate_input_register(priv->sreg_addr_max);
  			if (err < 0)
  				return err;
  		} else {
@@@ -172,19 -181,21 +177,19 @@@
  		}
  	}
  
 -	plen = FIELD_SIZEOF(struct nf_nat_range, min_addr.all);
  	if (tb[NFTA_NAT_REG_PROTO_MIN]) {
  		priv->sreg_proto_min =
- 			ntohl(nla_get_be32(tb[NFTA_NAT_REG_PROTO_MIN]));
+ 			nft_parse_register(tb[NFTA_NAT_REG_PROTO_MIN]);
  
 -		err = nft_validate_register_load(priv->sreg_proto_min, plen);
 +		err = nft_validate_input_register(priv->sreg_proto_min);
  		if (err < 0)
  			return err;
  
  		if (tb[NFTA_NAT_REG_PROTO_MAX]) {
  			priv->sreg_proto_max =
- 				ntohl(nla_get_be32(tb[NFTA_NAT_REG_PROTO_MAX]));
+ 				nft_parse_register(tb[NFTA_NAT_REG_PROTO_MAX]);
  
 -			err = nft_validate_register_load(priv->sreg_proto_max,
 -							 plen);
 +			err = nft_validate_input_register(priv->sreg_proto_max);
  			if (err < 0)
  				return err;
  		} else {
diff --cc net/netfilter/nft_payload.c
index 85daa84bfdfe,5fa997346a23..000000000000
--- a/net/netfilter/nft_payload.c
+++ b/net/netfilter/nft_payload.c
@@@ -67,12 -66,10 +67,16 @@@ static int nft_payload_init(const struc
  	priv->base   = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE]));
  	priv->offset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET]));
  	priv->len    = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN]));
++<<<<<<< HEAD
++=======
+ 	priv->dreg   = nft_parse_register(tb[NFTA_PAYLOAD_DREG]);
++>>>>>>> b1c96ed37cee (netfilter: nf_tables: add register parsing/dumping helpers)
  
 -	return nft_validate_register_store(ctx, priv->dreg, NULL,
 -					   NFT_DATA_VALUE, priv->len);
 +	priv->dreg = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_DREG]));
 +	err = nft_validate_output_register(priv->dreg);
 +	if (err < 0)
 +		return err;
 +	return nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
  }
  
  static int nft_payload_dump(struct sk_buff *skb, const struct nft_expr *expr)
* Unmerged path net/netfilter/nft_dynset.c
* Unmerged path include/net/netfilter/nf_tables.h
* Unmerged path net/bridge/netfilter/nft_meta_bridge.c
diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index 399ca83793bb..dd32c2c9b8be 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -3956,6 +3956,18 @@ static int nf_tables_check_loops(const struct nft_ctx *ctx,
 	return 0;
 }
 
+unsigned int nft_parse_register(const struct nlattr *attr)
+{
+	return ntohl(nla_get_be32(attr));
+}
+EXPORT_SYMBOL_GPL(nft_parse_register);
+
+int nft_dump_register(struct sk_buff *skb, unsigned int attr, unsigned int reg)
+{
+	return nla_put_be32(skb, attr, htonl(reg));
+}
+EXPORT_SYMBOL_GPL(nft_dump_register);
+
 /**
  *	nft_validate_input_register - validate an expressions' input register
  *
* Unmerged path net/netfilter/nft_bitwise.c
* Unmerged path net/netfilter/nft_byteorder.c
* Unmerged path net/netfilter/nft_cmp.c
* Unmerged path net/netfilter/nft_ct.c
* Unmerged path net/netfilter/nft_dynset.c
* Unmerged path net/netfilter/nft_exthdr.c
* Unmerged path net/netfilter/nft_immediate.c
* Unmerged path net/netfilter/nft_lookup.c
* Unmerged path net/netfilter/nft_meta.c
* Unmerged path net/netfilter/nft_nat.c
* Unmerged path net/netfilter/nft_payload.c
diff --git a/net/netfilter/nft_redir.c b/net/netfilter/nft_redir.c
index d7e9e93a4e90..1aecb0b1d197 100644
--- a/net/netfilter/nft_redir.c
+++ b/net/netfilter/nft_redir.c
@@ -52,7 +52,7 @@ int nft_redir_init(const struct nft_ctx *ctx,
 
 	if (tb[NFTA_REDIR_REG_PROTO_MIN]) {
 		priv->sreg_proto_min =
-			ntohl(nla_get_be32(tb[NFTA_REDIR_REG_PROTO_MIN]));
+			nft_parse_register(tb[NFTA_REDIR_REG_PROTO_MIN]);
 
 		err = nft_validate_input_register(priv->sreg_proto_min);
 		if (err < 0)
@@ -60,7 +60,7 @@ int nft_redir_init(const struct nft_ctx *ctx,
 
 		if (tb[NFTA_REDIR_REG_PROTO_MAX]) {
 			priv->sreg_proto_max =
-				ntohl(nla_get_be32(tb[NFTA_REDIR_REG_PROTO_MAX]));
+				nft_parse_register(tb[NFTA_REDIR_REG_PROTO_MAX]);
 
 			err = nft_validate_input_register(priv->sreg_proto_max);
 			if (err < 0)
@@ -85,11 +85,11 @@ int nft_redir_dump(struct sk_buff *skb, const struct nft_expr *expr)
 	const struct nft_redir *priv = nft_expr_priv(expr);
 
 	if (priv->sreg_proto_min) {
-		if (nla_put_be32(skb, NFTA_REDIR_REG_PROTO_MIN,
-				 htonl(priv->sreg_proto_min)))
+		if (nft_dump_register(skb, NFTA_REDIR_REG_PROTO_MIN,
+				      priv->sreg_proto_min))
 			goto nla_put_failure;
-		if (nla_put_be32(skb, NFTA_REDIR_REG_PROTO_MAX,
-				 htonl(priv->sreg_proto_max)))
+		if (nft_dump_register(skb, NFTA_REDIR_REG_PROTO_MAX,
+				      priv->sreg_proto_max))
 			goto nla_put_failure;
 	}
 
