i40e: Fix led blink capability for 10GBaseT PHY

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Carolyn Wyborny <carolyn.wyborny@intel.com>
commit 31b606d0c40a1435c54bff18e4d3d3c33af1c3cf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/31b606d0.failed

This patch fixes a problem where the ethtool identify adapter
functionality did not work for some copper PHY's.  Without this
patch, the blink led functionality fails on some parts.  This
patch adds PHY write code to blink led's on parts where this
functionality is contained in the PHY rather than the MAC.

Change-ID: Iee7b3453f61d5ffd0b3d03f720ee4f17f919fcc2
	Signed-off-by: Carolyn Wyborny <carolyn.wyborny@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 31b606d0c40a1435c54bff18e4d3d3c33af1c3cf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e.h
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e.h
index 93e17a9fb144,e99be9f696c3..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@@ -338,6 -351,12 +339,15 @@@ struct i40e_pf 
  #define I40E_FLAG_VEB_MODE_ENABLED		BIT_ULL(40)
  #define I40E_FLAG_GENEVE_OFFLOAD_CAPABLE	BIT_ULL(41)
  #define I40E_FLAG_NO_PCI_LINK_CHECK		BIT_ULL(42)
++<<<<<<< HEAD
++=======
+ #define I40E_FLAG_100M_SGMII_CAPABLE		BIT_ULL(43)
+ #define I40E_FLAG_RESTART_AUTONEG		BIT_ULL(44)
+ #define I40E_FLAG_NO_DCB_SUPPORT		BIT_ULL(45)
+ #define I40E_FLAG_USE_SET_LLDP_MIB		BIT_ULL(46)
+ #define I40E_FLAG_STOP_FW_LLDP			BIT_ULL(47)
+ #define I40E_FLAG_HAVE_10GBASET_PHY		BIT_ULL(48)
++>>>>>>> 31b606d0c40a (i40e: Fix led blink capability for 10GBaseT PHY)
  #define I40E_FLAG_PF_MAC			BIT_ULL(50)
  
  	/* tracks features that get auto disabled by errors */
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 7d5aabc7f676,b29b13154d9f..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -11041,12 -11108,32 +11041,36 @@@ static int i40e_probe(struct pci_dev *p
  	/* get the requested speeds from the fw */
  	err = i40e_aq_get_phy_capabilities(hw, false, false, &abilities, NULL);
  	if (err)
 -		dev_dbg(&pf->pdev->dev, "get requested speeds ret =  %s last_status =  %s\n",
 -			i40e_stat_str(&pf->hw, err),
 -			i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));
 +		dev_info(&pf->pdev->dev,
 +			 "get phy capabilities failed, err %s aq_err %s, advertised speed settings may not be correct\n",
 +			 i40e_stat_str(&pf->hw, err),
 +			 i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));
  	pf->hw.phy.link_info.requested_speeds = abilities.link_speed;
  
++<<<<<<< HEAD
++=======
+ 	/* get the supported phy types from the fw */
+ 	err = i40e_aq_get_phy_capabilities(hw, false, true, &abilities, NULL);
+ 	if (err)
+ 		dev_dbg(&pf->pdev->dev, "get supported phy types ret =  %s last_status =  %s\n",
+ 			i40e_stat_str(&pf->hw, err),
+ 			i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));
+ 	pf->hw.phy.phy_types = le32_to_cpu(abilities.phy_type);
+ 
+ 	/* Add a filter to drop all Flow control frames from any VSI from being
+ 	 * transmitted. By doing so we stop a malicious VF from sending out
+ 	 * PAUSE or PFC frames and potentially controlling traffic for other
+ 	 * PF/VF VSIs.
+ 	 * The FW can still send Flow control frames if enabled.
+ 	 */
+ 	i40e_add_filter_to_drop_tx_flow_control_frames(&pf->hw,
+ 						       pf->main_vsi_seid);
+ 
+ 	if ((pf->hw.device_id == I40E_DEV_ID_10G_BASE_T) ||
+ 	    (pf->hw.device_id == I40E_DEV_ID_10G_BASE_T4))
+ 		pf->flags |= I40E_FLAG_HAVE_10GBASET_PHY;
+ 
++>>>>>>> 31b606d0c40a (i40e: Fix led blink capability for 10GBaseT PHY)
  	/* print a string summarizing features */
  	i40e_print_features(pf);
  
* Unmerged path drivers/net/ethernet/intel/i40e/i40e.h
diff --git a/drivers/net/ethernet/intel/i40e/i40e_common.c b/drivers/net/ethernet/intel/i40e/i40e_common.c
index 15084ba06105..b149a0441c8f 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_common.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_common.c
@@ -1907,6 +1907,32 @@ i40e_status i40e_aq_set_phy_int_mask(struct i40e_hw *hw,
 	return status;
 }
 
+/**
+ * i40e_aq_set_phy_debug
+ * @hw: pointer to the hw struct
+ * @cmd_flags: debug command flags
+ * @cmd_details: pointer to command details structure or NULL
+ *
+ * Reset the external PHY.
+ **/
+enum i40e_status_code i40e_aq_set_phy_debug(struct i40e_hw *hw, u8 cmd_flags,
+					struct i40e_asq_cmd_details *cmd_details)
+{
+	struct i40e_aq_desc desc;
+	struct i40e_aqc_set_phy_debug *cmd =
+		(struct i40e_aqc_set_phy_debug *)&desc.params.raw;
+	enum i40e_status_code status;
+
+	i40e_fill_default_direct_cmd_desc(&desc,
+					  i40e_aqc_opc_set_phy_debug);
+
+	cmd->command_flags = cmd_flags;
+
+	status = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);
+
+	return status;
+}
+
 /**
  * i40e_aq_add_vsi
  * @hw: pointer to the hw struct
diff --git a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 4c100ad4016f..0b8bd9b29a89 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@ -1774,28 +1774,52 @@ static int i40e_set_phys_id(struct net_device *netdev,
 			    enum ethtool_phys_id_state state)
 {
 	struct i40e_netdev_priv *np = netdev_priv(netdev);
+	i40e_status ret = 0;
 	struct i40e_pf *pf = np->vsi->back;
 	struct i40e_hw *hw = &pf->hw;
 	int blink_freq = 2;
+	u16 temp_status;
 
 	switch (state) {
 	case ETHTOOL_ID_ACTIVE:
-		pf->led_status = i40e_led_get(hw);
+		if (!(pf->flags & I40E_FLAG_HAVE_10GBASET_PHY)) {
+			pf->led_status = i40e_led_get(hw);
+		} else {
+			i40e_aq_set_phy_debug(hw, I40E_PHY_DEBUG_PORT, NULL);
+			ret = i40e_led_get_phy(hw, &temp_status,
+					       &pf->phy_led_val);
+			pf->led_status = temp_status;
+		}
 		return blink_freq;
 	case ETHTOOL_ID_ON:
-		i40e_led_set(hw, 0xF, false);
+		if (!(pf->flags & I40E_FLAG_HAVE_10GBASET_PHY))
+			i40e_led_set(hw, 0xf, false);
+		else
+			ret = i40e_led_set_phy(hw, true, pf->led_status, 0);
 		break;
 	case ETHTOOL_ID_OFF:
-		i40e_led_set(hw, 0x0, false);
+		if (!(pf->flags & I40E_FLAG_HAVE_10GBASET_PHY))
+			i40e_led_set(hw, 0x0, false);
+		else
+			ret = i40e_led_set_phy(hw, false, pf->led_status, 0);
 		break;
 	case ETHTOOL_ID_INACTIVE:
-		i40e_led_set(hw, pf->led_status, false);
+		if (!(pf->flags & I40E_FLAG_HAVE_10GBASET_PHY)) {
+			i40e_led_set(hw, false, pf->led_status);
+		} else {
+			ret = i40e_led_set_phy(hw, false, pf->led_status,
+					       (pf->phy_led_val |
+					       I40E_PHY_LED_MODE_ORIG));
+			i40e_aq_set_phy_debug(hw, 0, NULL);
+		}
 		break;
 	default:
 		break;
 	}
-
-	return 0;
+		if (ret)
+			return -ENOENT;
+		else
+			return 0;
 }
 
 /* NOTE: i40e hardware uses a conversion factor of 2 for Interrupt
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
