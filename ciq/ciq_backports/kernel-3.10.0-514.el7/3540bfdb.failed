libceph: request_init() and request_release_checks()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ilya Dryomov <idryomov@gmail.com>
commit 3540bfdb30fcb423a92cc959708e71bc39eb18c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3540bfdb.failed

These are going to be used by request_reinit() code.

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 3540bfdb30fcb423a92cc959708e71bc39eb18c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ceph/osd_client.c
diff --cc net/ceph/osd_client.c
index b1bd089d52f0,46e6fb5a1299..000000000000
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@@ -310,12 -371,7 +319,16 @@@ static void ceph_osdc_release_request(s
  
  	dout("%s %p (r_request %p r_reply %p)\n", __func__, req,
  	     req->r_request, req->r_reply);
++<<<<<<< HEAD
 +	WARN_ON(!RB_EMPTY_NODE(&req->r_node));
 +	WARN_ON(!list_empty(&req->r_req_lru_item));
 +	WARN_ON(!list_empty(&req->r_osd_item));
 +	WARN_ON(!list_empty(&req->r_linger_item));
 +	WARN_ON(!list_empty(&req->r_linger_osd_item));
 +	WARN_ON(req->r_osd);
++=======
+ 	request_release_checks(req);
++>>>>>>> 3540bfdb30fc (libceph: request_init() and request_release_checks())
  
  	if (req->r_request)
  		ceph_msg_put(req->r_request);
@@@ -384,38 -454,20 +411,45 @@@ struct ceph_osd_request *ceph_osdc_allo
  	req->r_snapid = CEPH_NOSNAP;
  	req->r_snapc = ceph_get_snap_context(snapc);
  
++<<<<<<< HEAD
 +	kref_init(&req->r_kref);
 +	init_completion(&req->r_completion);
 +	init_completion(&req->r_safe_completion);
 +	RB_CLEAR_NODE(&req->r_node);
 +	INIT_LIST_HEAD(&req->r_unsafe_item);
 +	INIT_LIST_HEAD(&req->r_linger_item);
 +	INIT_LIST_HEAD(&req->r_linger_osd_item);
 +	INIT_LIST_HEAD(&req->r_req_lru_item);
 +	INIT_LIST_HEAD(&req->r_osd_item);
 +
 +	req->r_base_oloc.pool = -1;
 +	req->r_target_oloc.pool = -1;
 +
 +	msg_size = OSD_OPREPLY_FRONT_LEN;
 +	if (num_ops > CEPH_OSD_SLAB_OPS) {
 +		/* ceph_osd_op and rval */
 +		msg_size += (num_ops - CEPH_OSD_SLAB_OPS) *
 +			    (sizeof(struct ceph_osd_op) + 4);
 +	}
++=======
+ 	dout("%s req %p\n", __func__, req);
+ 	return req;
+ }
+ EXPORT_SYMBOL(ceph_osdc_alloc_request);
++>>>>>>> 3540bfdb30fc (libceph: request_init() and request_release_checks())
  
 -int ceph_osdc_alloc_messages(struct ceph_osd_request *req, gfp_t gfp)
 -{
 -	struct ceph_osd_client *osdc = req->r_osdc;
 -	struct ceph_msg *msg;
 -	int msg_size;
 -
 -	WARN_ON(ceph_oid_empty(&req->r_base_oid));
 +	/* create reply message */
 +	if (use_mempool)
 +		msg = ceph_msgpool_get(&osdc->msgpool_op_reply, 0);
 +	else
 +		msg = ceph_msg_new(CEPH_MSG_OSD_OPREPLY, msg_size,
 +				   gfp_flags, true);
 +	if (!msg) {
 +		ceph_osdc_put_request(req);
 +		return NULL;
 +	}
 +	req->r_reply = msg;
  
 -	/* create request message */
  	msg_size = 4 + 4 + 4; /* client_inc, osdmap_epoch, flags */
  	msg_size += 4 + 4 + 4 + 8; /* mtime, reassert_version */
  	msg_size += 2 + 4 + 8 + 4 + 4; /* oloc */
* Unmerged path net/ceph/osd_client.c
