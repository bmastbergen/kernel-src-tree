openvswitch: Remove vport stats.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] openvswitch: Remove vport stats (Lance Richardson) [1283886]
Rebuild_FUZZ: 98.41%
commit-author Pravin B Shelar <pshelar@nicira.com>
commit 8c876639c98501b049269b554bf4ecbb8f9c012f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8c876639.failed

Since all vport types are now backed by netdev, we can directly
use netdev stats. Following patch removes redundant stat
from vport.

	Signed-off-by: Pravin B Shelar <pshelar@nicira.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8c876639c98501b049269b554bf4ecbb8f9c012f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/vport-internal_dev.c
#	net/openvswitch/vport-netdev.c
#	net/openvswitch/vport-netdev.h
#	net/openvswitch/vport.h
diff --cc net/openvswitch/vport-internal_dev.c
index d6aef25cd7bb,388b8a6bf112..000000000000
--- a/net/openvswitch/vport-internal_dev.c
+++ b/net/openvswitch/vport-internal_dev.c
@@@ -218,10 -202,10 +208,15 @@@ static void internal_dev_destroy(struc
  	rtnl_unlock();
  }
  
- static int internal_dev_recv(struct vport *vport, struct sk_buff *skb)
+ static void internal_dev_recv(struct vport *vport, struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	struct net_device *netdev = netdev_vport_priv(vport)->dev;
 +	int len;
++=======
+ 	struct net_device *netdev = vport->dev;
+ 	struct pcpu_sw_netstats *stats;
++>>>>>>> 8c876639c985 (openvswitch: Remove vport stats.)
  
  	if (unlikely(!(netdev->flags & IFF_UP))) {
  		kfree_skb(skb);
diff --cc net/openvswitch/vport-netdev.c
index 6c7a9d49beb5,f7e8dcce7ada..000000000000
--- a/net/openvswitch/vport-netdev.c
+++ b/net/openvswitch/vport-netdev.c
@@@ -53,10 -59,8 +56,13 @@@ static void netdev_port_receive(struct 
  
  	skb_push(skb, ETH_HLEN);
  	ovs_skb_postpush_rcsum(skb, skb->data, ETH_HLEN);
++<<<<<<< HEAD
 +
 +	ovs_vport_receive(vport, skb, skb_tunnel_info(skb, AF_INET));
++=======
+ 	ovs_vport_receive(vport, skb, skb_tunnel_info(skb));
++>>>>>>> 8c876639c985 (openvswitch: Remove vport stats.)
  	return;
- 
  error:
  	kfree_skb(skb);
  }
@@@ -193,29 -200,26 +195,38 @@@ static unsigned int packet_length(cons
  	return length;
  }
  
++<<<<<<< HEAD
 +static int netdev_send(struct vport *vport, struct sk_buff *skb)
 +{
 +	struct netdev_vport *netdev_vport = netdev_vport_priv(vport);
 +	int mtu = netdev_vport->dev->mtu;
 +	int len;
++=======
+ void ovs_netdev_send(struct vport *vport, struct sk_buff *skb)
+ {
+ 	int mtu = vport->dev->mtu;
++>>>>>>> 8c876639c985 (openvswitch: Remove vport stats.)
  
  	if (unlikely(packet_length(skb) > mtu && !skb_is_gso(skb))) {
  		net_warn_ratelimited("%s: dropped over-mtu packet: %d > %d\n",
 -				     vport->dev->name,
 +				     netdev_vport->dev->name,
  				     packet_length(skb), mtu);
+ 		vport->dev->stats.tx_errors++;
  		goto drop;
  	}
  
++<<<<<<< HEAD
 +	skb->dev = netdev_vport->dev;
 +	len = skb->len;
++=======
+ 	skb->dev = vport->dev;
++>>>>>>> 8c876639c985 (openvswitch: Remove vport stats.)
  	dev_queue_xmit(skb);
- 
- 	return len;
+ 	return;
  
  drop:
  	kfree_skb(skb);
- 	return 0;
  }
 -EXPORT_SYMBOL_GPL(ovs_netdev_send);
  
  /* Returns null if this device is not attached to a datapath. */
  struct vport *ovs_netdev_get_vport(struct net_device *dev)
diff --cc net/openvswitch/vport-netdev.h
index 6f7038e79c52,bf22fcedbc69..000000000000
--- a/net/openvswitch/vport-netdev.h
+++ b/net/openvswitch/vport-netdev.h
@@@ -26,19 -26,8 +26,24 @@@
  
  struct vport *ovs_netdev_get_vport(struct net_device *dev);
  
++<<<<<<< HEAD
 +struct netdev_vport {
 +	struct rcu_head rcu;
 +
 +	struct net_device *dev;
 +};
 +
 +static inline struct netdev_vport *
 +netdev_vport_priv(const struct vport *vport)
 +{
 +	return vport_priv(vport);
 +}
 +
 +const char *ovs_netdev_get_name(const struct vport *);
++=======
+ struct vport *ovs_netdev_link(struct vport *vport, const char *name);
+ void ovs_netdev_send(struct vport *vport, struct sk_buff *skb);
++>>>>>>> 8c876639c985 (openvswitch: Remove vport stats.)
  void ovs_netdev_detach_dev(struct vport *);
  
  int __init ovs_netdev_init(void);
diff --cc net/openvswitch/vport.h
index 4750fb673a9f,30615edc084b..000000000000
--- a/net/openvswitch/vport.h
+++ b/net/openvswitch/vport.h
@@@ -56,13 -57,10 +56,11 @@@ int ovs_vport_set_upcall_portids(struc
  int ovs_vport_get_upcall_portids(const struct vport *, struct sk_buff *);
  u32 ovs_vport_find_upcall_portid(const struct vport *, struct sk_buff *);
  
- int ovs_vport_send(struct vport *, struct sk_buff *);
- 
  int ovs_tunnel_get_egress_info(struct ip_tunnel_info *egress_tun_info,
  			       struct net *net,
 -			       struct sk_buff *,
 +			       const struct ip_tunnel_info *tun_info,
  			       u8 ipproto,
 +			       u32 skb_mark,
  			       __be16 tp_src,
  			       __be16 tp_dst);
  int ovs_vport_get_egress_tun_info(struct vport *vport, struct sk_buff *skb,
@@@ -115,10 -103,8 +103,7 @@@ struct vport 
  	struct hlist_node dp_hash_node;
  	const struct vport_ops *ops;
  
- 	struct pcpu_sw_netstats __percpu *percpu_stats;
- 
- 	struct vport_err_stats err_stats;
  	struct list_head detach_list;
 -	struct rcu_head rcu;
  };
  
  /**
@@@ -155,8 -141,7 +140,12 @@@ struct vport_parms 
   * @get_options: Appends vport-specific attributes for the configuration of an
   * existing vport to a &struct sk_buff.  May be %NULL for a vport that does not
   * have any configuration.
++<<<<<<< HEAD
 + * @get_name: Get the device's name.
 + * @send: Send a packet on the device.  Returns the length of the packet sent,
++=======
+  * @send: Send a packet on the device.
++>>>>>>> 8c876639c985 (openvswitch: Remove vport stats.)
   * zero for dropped packets or negative for error.
   * @get_egress_tun_info: Get the egress tunnel 5-tuple and other info for
   * a packet.
@@@ -171,10 -156,7 +160,14 @@@ struct vport_ops 
  	int (*set_options)(struct vport *, struct nlattr *);
  	int (*get_options)(const struct vport *, struct sk_buff *);
  
++<<<<<<< HEAD
 +	/* Called with rcu_read_lock or ovs_mutex. */
 +	const char *(*get_name)(const struct vport *);
 +
 +	int (*send)(struct vport *, struct sk_buff *);
++=======
+ 	void (*send)(struct vport *, struct sk_buff *);
++>>>>>>> 8c876639c985 (openvswitch: Remove vport stats.)
  	int (*get_egress_tun_info)(struct vport *, struct sk_buff *,
  				   struct ip_tunnel_info *);
  
* Unmerged path net/openvswitch/vport-internal_dev.c
* Unmerged path net/openvswitch/vport-netdev.c
* Unmerged path net/openvswitch/vport-netdev.h
diff --git a/net/openvswitch/vport.c b/net/openvswitch/vport.c
index af23ba077836..477affa688d2 100644
--- a/net/openvswitch/vport.c
+++ b/net/openvswitch/vport.c
@@ -34,9 +34,6 @@
 #include "vport.h"
 #include "vport-internal_dev.h"
 
-static void ovs_vport_record_error(struct vport *,
-				   enum vport_err_type err_type);
-
 static LIST_HEAD(vport_ops_list);
 
 /* Protected by RCU read lock for reading, ovs_mutex for writing. */
@@ -157,12 +154,6 @@ struct vport *ovs_vport_alloc(int priv_size, const struct vport_ops *ops,
 		return ERR_PTR(-EINVAL);
 	}
 
-	vport->percpu_stats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);
-	if (!vport->percpu_stats) {
-		kfree(vport);
-		return ERR_PTR(-ENOMEM);
-	}
-
 	return vport;
 }
 EXPORT_SYMBOL_GPL(ovs_vport_alloc);
@@ -183,7 +174,6 @@ void ovs_vport_free(struct vport *vport)
 	 * it is safe to use raw dereference.
 	 */
 	kfree(rcu_dereference_raw(vport->upcall_portids));
-	free_percpu(vport->percpu_stats);
 	kfree(vport);
 }
 EXPORT_SYMBOL_GPL(ovs_vport_free);
@@ -290,30 +280,24 @@ void ovs_vport_del(struct vport *vport)
  */
 void ovs_vport_get_stats(struct vport *vport, struct ovs_vport_stats *stats)
 {
+	struct net_device *dev = vport->dev;
 	int i;
 
 	memset(stats, 0, sizeof(*stats));
+	stats->rx_errors  = dev->stats.rx_errors;
+	stats->tx_errors  = dev->stats.tx_errors;
+	stats->tx_dropped = dev->stats.tx_dropped;
+	stats->rx_dropped = dev->stats.rx_dropped;
 
-	/* We potentially have 2 sources of stats that need to be combined:
-	 * those we have collected (split into err_stats and percpu_stats) from
-	 * set_stats() and device error stats from netdev->get_stats() (for
-	 * errors that happen  downstream and therefore aren't reported through
-	 * our vport_record_error() function).
-	 * Stats from first source are reported by ovs (OVS_VPORT_ATTR_STATS).
-	 * netdev-stats can be directly read over netlink-ioctl.
-	 */
-
-	stats->rx_errors  = atomic_long_read(&vport->err_stats.rx_errors);
-	stats->tx_errors  = atomic_long_read(&vport->err_stats.tx_errors);
-	stats->tx_dropped = atomic_long_read(&vport->err_stats.tx_dropped);
-	stats->rx_dropped = atomic_long_read(&vport->err_stats.rx_dropped);
+	stats->rx_dropped += atomic_long_read(&dev->rx_dropped);
+	stats->tx_dropped += atomic_long_read(&dev->tx_dropped);
 
 	for_each_possible_cpu(i) {
 		const struct pcpu_sw_netstats *percpu_stats;
 		struct pcpu_sw_netstats local_stats;
 		unsigned int start;
 
-		percpu_stats = per_cpu_ptr(vport->percpu_stats, i);
+		percpu_stats = per_cpu_ptr(dev->tstats, i);
 
 		do {
 			start = u64_stats_fetch_begin_irq(&percpu_stats->syncp);
@@ -468,94 +452,25 @@ u32 ovs_vport_find_upcall_portid(const struct vport *vport, struct sk_buff *skb)
  * Must be called with rcu_read_lock.  The packet cannot be shared and
  * skb->data should point to the Ethernet header.
  */
-void ovs_vport_receive(struct vport *vport, struct sk_buff *skb,
-		       const struct ip_tunnel_info *tun_info)
+int ovs_vport_receive(struct vport *vport, struct sk_buff *skb,
+		      const struct ip_tunnel_info *tun_info)
 {
-	struct pcpu_sw_netstats *stats;
 	struct sw_flow_key key;
 	int error;
 
-	stats = this_cpu_ptr(vport->percpu_stats);
-	u64_stats_update_begin(&stats->syncp);
-	stats->rx_packets++;
-	stats->rx_bytes += skb->len +
-			   (skb_vlan_tag_present(skb) ? VLAN_HLEN : 0);
-	u64_stats_update_end(&stats->syncp);
-
 	OVS_CB(skb)->input_vport = vport;
 	OVS_CB(skb)->egress_tun_info = NULL;
 	/* Extract flow from 'skb' into 'key'. */
 	error = ovs_flow_key_extract(tun_info, skb, &key);
 	if (unlikely(error)) {
 		kfree_skb(skb);
-		return;
+		return error;
 	}
 	ovs_dp_process_packet(skb, &key);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(ovs_vport_receive);
 
-/**
- *	ovs_vport_send - send a packet on a device
- *
- * @vport: vport on which to send the packet
- * @skb: skb to send
- *
- * Sends the given packet and returns the length of data sent.  Either ovs
- * lock or rcu_read_lock must be held.
- */
-int ovs_vport_send(struct vport *vport, struct sk_buff *skb)
-{
-	int sent = vport->ops->send(vport, skb);
-
-	if (likely(sent > 0)) {
-		struct pcpu_sw_netstats *stats;
-
-		stats = this_cpu_ptr(vport->percpu_stats);
-
-		u64_stats_update_begin(&stats->syncp);
-		stats->tx_packets++;
-		stats->tx_bytes += sent;
-		u64_stats_update_end(&stats->syncp);
-	} else if (sent < 0) {
-		ovs_vport_record_error(vport, VPORT_E_TX_ERROR);
-	} else {
-		ovs_vport_record_error(vport, VPORT_E_TX_DROPPED);
-	}
-	return sent;
-}
-
-/**
- *	ovs_vport_record_error - indicate device error to generic stats layer
- *
- * @vport: vport that encountered the error
- * @err_type: one of enum vport_err_type types to indicate the error type
- *
- * If using the vport generic stats layer indicate that an error of the given
- * type has occurred.
- */
-static void ovs_vport_record_error(struct vport *vport,
-				   enum vport_err_type err_type)
-{
-	switch (err_type) {
-	case VPORT_E_RX_DROPPED:
-		atomic_long_inc(&vport->err_stats.rx_dropped);
-		break;
-
-	case VPORT_E_RX_ERROR:
-		atomic_long_inc(&vport->err_stats.rx_errors);
-		break;
-
-	case VPORT_E_TX_DROPPED:
-		atomic_long_inc(&vport->err_stats.tx_dropped);
-		break;
-
-	case VPORT_E_TX_ERROR:
-		atomic_long_inc(&vport->err_stats.tx_errors);
-		break;
-	}
-
-}
-
 static void free_vport_rcu(struct rcu_head *rcu)
 {
 	struct vport *vport = container_of(rcu, struct vport, rcu);
* Unmerged path net/openvswitch/vport.h
