ovl: setattr: check permissions before copy-up

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Miklos Szeredi <miklos@szeredi.hu>
commit cf9a6784f7c1b5ee2b9159a1246e327c331c5697
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/cf9a6784.failed

Without this copy-up of a file can be forced, even without actually being
allowed to do anything on the file.

[Arnd Bergmann] include <linux/pagemap.h> for PAGE_CACHE_SIZE (used by
MAX_LFS_FILESIZE definition).

	Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
	Cc: <stable@vger.kernel.org>
(cherry picked from commit cf9a6784f7c1b5ee2b9159a1246e327c331c5697)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index 4fcfcff99f75,b08bf4d3a405..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -944,14 -936,8 +945,19 @@@ static int ovl_fill_super(struct super_
  		goto out_free_config;
  	}
  
++<<<<<<< HEAD
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_free_config;
 +	}
 +	*overlay_stack_depth = 0;
 +
++=======
+ 	sb->s_stack_depth = 0;
+ 	sb->s_maxbytes = MAX_LFS_FILESIZE;
++>>>>>>> cf9a6784f7c1 (ovl: setattr: check permissions before copy-up)
  	if (ufs->config.upperdir) {
  		if (!ufs->config.workdir) {
  			pr_err("overlayfs: missing 'workdir'\n");
diff --git a/fs/overlayfs/inode.c b/fs/overlayfs/inode.c
index 5c77b4f87340..adb194c359b9 100644
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@ -45,6 +45,19 @@ int ovl_setattr(struct dentry *dentry, struct iattr *attr)
 	int err;
 	struct dentry *upperdentry;
 
+	/*
+	 * Check for permissions before trying to copy-up.  This is redundant
+	 * since it will be rechecked later by ->setattr() on upper dentry.  But
+	 * without this, copy-up can be triggered by just about anybody.
+	 *
+	 * We don't initialize inode->size, which just means that
+	 * inode_newsize_ok() will always check against MAX_LFS_FILESIZE and not
+	 * check for a swapfile (which this won't be anyway).
+	 */
+	err = inode_change_ok(dentry->d_inode, attr);
+	if (err)
+		return err;
+
 	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
* Unmerged path fs/overlayfs/super.c
