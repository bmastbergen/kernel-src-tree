mei: fix KDoc documentation formatting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit a8605ea2c20c2b97a54d7746c16ebef5ba29632a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a8605ea2.failed

Fix Kdoc documentation formatting warnings
genertaed by ./scripts/kernel-doc

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit a8605ea2c20c2b97a54d7746c16ebef5ba29632a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/client.c
#	drivers/misc/mei/hbm.c
#	drivers/misc/mei/hw.h
#	drivers/misc/mei/main.c
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/client.c
index 22a9268f24eb,1f91c55f7af5..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -33,41 -34,83 +34,102 @@@
   *
   * Locking: called under "dev->device_lock" lock
   *
++<<<<<<< HEAD
 + * returns me client index or -ENOENT if not found
++=======
+  * Return: me client or NULL if not found
++>>>>>>> a8605ea2c20c (mei: fix KDoc documentation formatting)
   */
 -struct mei_me_client *mei_me_cl_by_uuid(const struct mei_device *dev,
 -					const uuid_le *uuid)
 +int mei_me_cl_by_uuid(const struct mei_device *dev, const uuid_le *uuid)
  {
 -	struct mei_me_client *me_cl;
 +	int i;
  
 -	list_for_each_entry(me_cl, &dev->me_clients, list)
 -		if (uuid_le_cmp(*uuid, me_cl->props.protocol_name) == 0)
 -			return me_cl;
 +	for (i = 0; i < dev->me_clients_num; ++i)
 +		if (uuid_le_cmp(*uuid,
 +				dev->me_clients[i].props.protocol_name) == 0)
 +			return i;
  
 -	return NULL;
 +	return -ENOENT;
  }
  
 +
  /**
-  * mei_me_cl_by_id return index to me_clients for client_id
+  * mei_me_cl_by_id - locate me client by client id
   *
   * @dev: the device structure
   * @client_id: me client id
   *
   * Locking: called under "dev->device_lock" lock
   *
++<<<<<<< HEAD
 + * returns index on success, -ENOENT on failure.
 + */
 +
 +int mei_me_cl_by_id(struct mei_device *dev, u8 client_id)
++=======
+  * Return: me client or NULL if not found
+  */
+ struct mei_me_client *mei_me_cl_by_id(struct mei_device *dev, u8 client_id)
++>>>>>>> a8605ea2c20c (mei: fix KDoc documentation formatting)
  {
 +	int i;
  
 -	struct mei_me_client *me_cl;
 +	for (i = 0; i < dev->me_clients_num; i++)
 +		if (dev->me_clients[i].client_id == client_id)
 +			return i;
  
++<<<<<<< HEAD
 +	return -ENOENT;
++=======
+ 	list_for_each_entry(me_cl, &dev->me_clients, list)
+ 		if (me_cl->client_id == client_id)
+ 			return me_cl;
+ 	return NULL;
+ }
+ 
+ /**
+  * mei_me_cl_by_uuid_id - locate me client by client id and uuid
+  *
+  * @dev: the device structure
+  * @uuid: me client uuid
+  * @client_id: me client id
+  *
+  * Locking: called under "dev->device_lock" lock
+  *
+  * Return: me client or NULL if not found
+  */
+ struct mei_me_client *mei_me_cl_by_uuid_id(struct mei_device *dev,
+ 					   const uuid_le *uuid, u8 client_id)
+ {
+ 	struct mei_me_client *me_cl;
+ 
+ 	list_for_each_entry(me_cl, &dev->me_clients, list)
+ 		if (uuid_le_cmp(*uuid, me_cl->props.protocol_name) == 0 &&
+ 		    me_cl->client_id == client_id)
+ 			return me_cl;
+ 	return NULL;
+ }
+ 
+ /**
+  * mei_me_cl_remove - remove me client matching uuid and client_id
+  *
+  * @dev: the device structure
+  * @uuid: me client uuid
+  * @client_id: me client address
+  */
+ void mei_me_cl_remove(struct mei_device *dev, const uuid_le *uuid, u8 client_id)
+ {
+ 	struct mei_me_client *me_cl, *next;
+ 
+ 	list_for_each_entry_safe(me_cl, next, &dev->me_clients, list) {
+ 		if (uuid_le_cmp(*uuid, me_cl->props.protocol_name) == 0 &&
+ 		    me_cl->client_id == client_id) {
+ 			list_del(&me_cl->list);
+ 			kfree(me_cl);
+ 			break;
+ 		}
+ 	}
++>>>>>>> a8605ea2c20c (mei: fix KDoc documentation formatting)
  }
  
  
diff --cc drivers/misc/mei/hbm.c
index e04f10ba9aa2,da476e8cac84..000000000000
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@@ -177,22 -190,43 +177,46 @@@ int mei_hbm_cl_write(struct mei_device 
  }
  
  /**
 - * mei_hbm_cl_addr_equal - check if the client's and
 - *	the message address match
 + * mei_hbm_cl_addr_equal - tells if they have the same address
   *
 - * @cl: client
 - * @cmd: hbm client message
 + * @cl: - client
 + * @buf: buffer with cl header
   *
-  * returns true if addresses are the same
+  * Return: true if addresses are the same
   */
  static inline
 -bool mei_hbm_cl_addr_equal(struct mei_cl *cl, struct mei_hbm_cl_cmd *cmd)
 +bool mei_hbm_cl_addr_equal(struct mei_cl *cl, void *buf)
  {
 +	struct mei_hbm_cl_cmd *cmd = buf;
  	return cl->host_client_id == cmd->host_addr &&
  		cl->me_client_id == cmd->me_addr;
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mei_hbm_cl_find_by_cmd - find recipient client
+  *
+  * @dev: the device structure
+  * @buf: a buffer with hbm cl command
+  *
+  * Return: the recipient client or NULL if not found
+  */
+ static inline
+ struct mei_cl *mei_hbm_cl_find_by_cmd(struct mei_device *dev, void *buf)
+ {
+ 	struct mei_hbm_cl_cmd *cmd = (struct mei_hbm_cl_cmd *)buf;
+ 	struct mei_cl *cl;
+ 
+ 	list_for_each_entry(cl, &dev->file_list, link)
+ 		if (mei_hbm_cl_addr_equal(cl, cmd))
+ 			return cl;
+ 	return NULL;
+ }
+ 
+ 
+ /**
++>>>>>>> a8605ea2c20c (mei: fix KDoc documentation formatting)
   * mei_hbm_start_wait - wait for start response message.
   *
   * @dev: the device structure
@@@ -288,6 -324,32 +312,35 @@@ static int mei_hbm_enum_clients_req(str
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * mei_hbm_me_cl_add - add new me client to the list
+  *
+  * @dev: the device structure
+  * @res: hbm property response
+  *
+  * Return: 0 on success and -ENOMEM on allocation failure
+  */
+ 
+ static int mei_hbm_me_cl_add(struct mei_device *dev,
+ 			     struct hbm_props_response *res)
+ {
+ 	struct mei_me_client *me_cl;
+ 
+ 	me_cl = kzalloc(sizeof(struct mei_me_client), GFP_KERNEL);
+ 	if (!me_cl)
+ 		return -ENOMEM;
+ 
+ 	me_cl->props = res->client_properties;
+ 	me_cl->client_id = res->me_addr;
+ 	me_cl->mei_flow_ctrl_creds = 0;
+ 
+ 	list_add(&me_cl->list, &dev->me_clients);
+ 	return 0;
+ }
+ 
++>>>>>>> a8605ea2c20c (mei: fix KDoc documentation formatting)
  /**
   * mei_hbm_prop_req - request property for a single client
   *
diff --cc drivers/misc/mei/hw.h
index 50526f92f092,ea8de2a88b31..000000000000
--- a/drivers/misc/mei/hw.h
+++ b/drivers/misc/mei/hw.h
@@@ -97,6 -97,33 +97,36 @@@ enum mei_stop_reason_types 
  	SYSTEM_S5_ENTRY = 0x08
  };
  
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * enum mei_hbm_status  - mei host bus messages return values
+  *
+  * @MEI_HBMS_SUCCESS           : status success
+  * @MEI_HBMS_CLIENT_NOT_FOUND  : client not found
+  * @MEI_HBMS_ALREADY_EXISTS    : connection already established
+  * @MEI_HBMS_REJECTED          : connection is rejected
+  * @MEI_HBMS_INVALID_PARAMETER : invalid parameter
+  * @MEI_HBMS_NOT_ALLOWED       : operation not allowed
+  * @MEI_HBMS_ALREADY_STARTED   : system is already started
+  * @MEI_HBMS_NOT_STARTED       : system not started
+  */
+ enum mei_hbm_status {
+ 	MEI_HBMS_SUCCESS           = 0,
+ 	MEI_HBMS_CLIENT_NOT_FOUND  = 1,
+ 	MEI_HBMS_ALREADY_EXISTS    = 2,
+ 	MEI_HBMS_REJECTED          = 3,
+ 	MEI_HBMS_INVALID_PARAMETER = 4,
+ 	MEI_HBMS_NOT_ALLOWED       = 5,
+ 	MEI_HBMS_ALREADY_STARTED   = 6,
+ 	MEI_HBMS_NOT_STARTED       = 7,
+ 
+ 	MEI_HBMS_MAX
+ };
+ 
+ 
++>>>>>>> a8605ea2c20c (mei: fix KDoc documentation formatting)
  /*
   * Client Connect Status
   * used by hbm_client_connect_response.status
diff --cc drivers/misc/mei/main.c
index b23f9eba9e3a,beedc91f03a6..000000000000
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@@ -683,28 -648,93 +682,43 @@@ static const struct file_operations mei
  	.llseek = no_llseek
  };
  
++<<<<<<< HEAD
 +/*
 + * Misc Device Struct
++=======
+ static struct class *mei_class;
+ static dev_t mei_devt;
+ #define MEI_MAX_DEVS  MINORMASK
+ static DEFINE_MUTEX(mei_minor_lock);
+ static DEFINE_IDR(mei_idr);
+ 
+ /**
+  * mei_minor_get - obtain next free device minor number
+  *
+  * @dev:  device pointer
+  *
+  * Return: allocated minor, or -ENOSPC if no free minor left
++>>>>>>> a8605ea2c20c (mei: fix KDoc documentation formatting)
   */
 -static int mei_minor_get(struct mei_device *dev)
 -{
 -	int ret;
 -
 -	mutex_lock(&mei_minor_lock);
 -	ret = idr_alloc(&mei_idr, dev, 0, MEI_MAX_DEVS, GFP_KERNEL);
 -	if (ret >= 0)
 -		dev->minor = ret;
 -	else if (ret == -ENOSPC)
 -		dev_err(dev->dev, "too many mei devices\n");
 -
 -	mutex_unlock(&mei_minor_lock);
 -	return ret;
 -}
 +static struct miscdevice  mei_misc_device = {
 +		.name = "mei",
 +		.fops = &mei_fops,
 +		.minor = MISC_DYNAMIC_MINOR,
 +};
  
 -/**
 - * mei_minor_free - mark device minor number as free
 - *
 - * @dev:  device pointer
 - */
 -static void mei_minor_free(struct mei_device *dev)
 -{
 -	mutex_lock(&mei_minor_lock);
 -	idr_remove(&mei_idr, dev->minor);
 -	mutex_unlock(&mei_minor_lock);
 -}
  
 -int mei_register(struct mei_device *dev, struct device *parent)
 +int mei_register(struct mei_device *dev)
  {
 -	struct device *clsdev; /* class device */
 -	int ret, devno;
 -
 -	ret = mei_minor_get(dev);
 -	if (ret < 0)
 +	int ret;
 +	mei_misc_device.parent = &dev->pdev->dev;
 +	ret = misc_register(&mei_misc_device);
 +	if (ret)
  		return ret;
  
 -	/* Fill in the data structures */
 -	devno = MKDEV(MAJOR(mei_devt), dev->minor);
 -	cdev_init(&dev->cdev, &mei_fops);
 -	dev->cdev.owner = mei_fops.owner;
 -
 -	/* Add the device */
 -	ret = cdev_add(&dev->cdev, devno, 1);
 -	if (ret) {
 -		dev_err(parent, "unable to add device %d:%d\n",
 -			MAJOR(mei_devt), dev->minor);
 -		goto err_dev_add;
 -	}
 -
 -	clsdev = device_create(mei_class, parent, devno,
 -			 NULL, "mei%d", dev->minor);
 -
 -	if (IS_ERR(clsdev)) {
 -		dev_err(parent, "unable to create device %d:%d\n",
 -			MAJOR(mei_devt), dev->minor);
 -		ret = PTR_ERR(clsdev);
 -		goto err_dev_create;
 -	}
 -
 -	ret = mei_dbgfs_register(dev, dev_name(clsdev));
 -	if (ret) {
 -		dev_err(clsdev, "cannot register debugfs ret = %d\n", ret);
 -		goto err_dev_dbgfs;
 -	}
 +	if (mei_dbgfs_register(dev, mei_misc_device.name))
 +		dev_err(&dev->pdev->dev, "cannot register debugfs\n");
  
  	return 0;
 -
 -err_dev_dbgfs:
 -	device_destroy(mei_class, devno);
 -err_dev_create:
 -	cdev_del(&dev->cdev);
 -err_dev_add:
 -	mei_minor_free(dev);
 -	return ret;
  }
  EXPORT_SYMBOL_GPL(mei_register);
  
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,563eebb62827..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -173,11 -168,13 +173,12 @@@ struct mei_fw_status 
  /**
   * struct mei_me_client - representation of me (fw) client
   *
-  * @props  - client properties
-  * @client_id - me client id
-  * @mei_flow_ctrl_creds - flow control credits
+  * @list: link in me client list
+  * @props: client properties
+  * @client_id: me client id
+  * @mei_flow_ctrl_creds: flow control credits
   */
  struct mei_me_client {
 -	struct list_head list;
  	struct mei_client_properties props;
  	u8 client_id;
  	u8 mei_flow_ctrl_creds;
@@@ -231,30 -228,31 +233,36 @@@ struct mei_cl 
  
  /** struct mei_hw_ops
   *
-  * @host_is_ready    - query for host readiness
+  * @host_is_ready    : query for host readiness
  
-  * @hw_is_ready      - query if hw is ready
-  * @hw_reset         - reset hw
-  * @hw_start         - start hw after reset
-  * @hw_config        - configure hw
+  * @hw_is_ready      : query if hw is ready
+  * @hw_reset         : reset hw
+  * @hw_start         : start hw after reset
+  * @hw_config        : configure hw
  
++<<<<<<< HEAD
 + * @pg_state         - power gating state of the device
 + * @pg_is_enabled    - is power gating enabled
++=======
+  * @fw_status        : get fw status registers
+  * @pg_state         : power gating state of the device
+  * @pg_is_enabled    : is power gating enabled
++>>>>>>> a8605ea2c20c (mei: fix KDoc documentation formatting)
  
-  * @intr_clear       - clear pending interrupts
-  * @intr_enable      - enable interrupts
-  * @intr_disable     - disable interrupts
+  * @intr_clear       : clear pending interrupts
+  * @intr_enable      : enable interrupts
+  * @intr_disable     : disable interrupts
  
-  * @hbuf_free_slots  - query for write buffer empty slots
-  * @hbuf_is_ready    - query if write buffer is empty
-  * @hbuf_max_len     - query for write buffer max len
+  * @hbuf_free_slots  : query for write buffer empty slots
+  * @hbuf_is_ready    : query if write buffer is empty
+  * @hbuf_max_len     : query for write buffer max len
  
-  * @write            - write a message to FW
+  * @write            : write a message to FW
  
-  * @rdbuf_full_slots - query how many slots are filled
+  * @rdbuf_full_slots : query how many slots are filled
  
-  * @read_hdr         - get first 4 bytes (header)
-  * @read             - read a buffer from the FW
+  * @read_hdr         : get first 4 bytes (header)
+  * @read             : read a buffer from the FW
   */
  struct mei_hw_ops {
  
@@@ -403,21 -384,27 +410,36 @@@ struct mei_cfg 
  /**
   * struct mei_device -  MEI private device struct
  
++<<<<<<< HEAD
 + * @reset_count - limits the number of consecutive resets
 + * @hbm_state - state of host bus message protocol
++=======
+  * @dev         : device on a bus
+  * @cdev        : character device
+  * @minor       : minor number allocated for device
   *
-  * @hbm_f_pg_supported - hbm feature pgi protocol
+  * @reset_count : limits the number of consecutive resets
+  * @hbm_state   : state of host bus message protocol
++>>>>>>> a8605ea2c20c (mei: fix KDoc documentation formatting)
   *
-  * @pg_event - power gating event
-  * @mem_addr - mem mapped base register address
+  * @hbm_f_pg_supported : hbm feature pgi protocol
+  *
+  * @pg_event    : power gating event
+  * @mem_addr    : mem mapped base register address
  
++<<<<<<< HEAD
 + * @hbuf_depth - depth of hardware host/write buffer is slots
 + * @hbuf_is_ready - query if the host host/write buffer is ready
 + * @wr_msg - the buffer for hbm control messages
 + * @cfg - per device generation config and ops
++=======
+  * @hbuf_depth  : depth of hardware host/write buffer is slots
+  * @hbuf_is_ready : query if the host host/write buffer is ready
+  * @wr_msg      : the buffer for hbm control messages
++>>>>>>> a8605ea2c20c (mei: fix KDoc documentation formatting)
   */
  struct mei_device {
 -	struct device *dev;
 -	struct cdev cdev;
 -	int minor;
 -
 +	struct pci_dev *pdev;	/* pointer to pci device struct */
  	/*
  	 * lists of queues
  	 */
diff --git a/drivers/misc/mei/amthif.c b/drivers/misc/mei/amthif.c
index a11128c1997f..5487235d7873 100644
--- a/drivers/misc/mei/amthif.c
+++ b/drivers/misc/mei/amthif.c
@@ -123,7 +123,7 @@ int mei_amthif_host_init(struct mei_device *dev)
  * @dev: the device structure
  * @file: pointer to file object
  *
- * returns   returned a list entry on success, NULL on failure.
+ * Return:   returned a list entry on success, NULL on failure.
  */
 struct mei_cl_cb *mei_amthif_find_read_list_entry(struct mei_device *dev,
 						struct file *file)
@@ -140,15 +140,14 @@ struct mei_cl_cb *mei_amthif_find_read_list_entry(struct mei_device *dev,
  * mei_amthif_read - read data from AMTHIF client
  *
  * @dev: the device structure
- * @if_num:  minor number
  * @file: pointer to file object
- * @*ubuf: pointer to user data in user space
+ * @ubuf: pointer to user data in user space
  * @length: data length to read
  * @offset: data read offset
  *
  * Locking: called under "dev->device_lock" lock
  *
- * returns
+ * Return:
  *  returned data length on success,
  *  zero if no data to read,
  *  negative on failure.
@@ -262,7 +261,7 @@ out:
  * @dev: the device structure
  * @cb: mei call back struct
  *
- * returns 0 on success, <0 on failure.
+ * Return: 0 on success, <0 on failure.
  *
  */
 static int mei_amthif_send_cmd(struct mei_device *dev, struct mei_cl_cb *cb)
@@ -332,7 +331,7 @@ static int mei_amthif_send_cmd(struct mei_device *dev, struct mei_cl_cb *cb)
  * @dev: the device structure
  * @cb: mei call back struct
  *
- * returns 0 on success, <0 on failure.
+ * Return: 0 on success, <0 on failure.
  *
  */
 int mei_amthif_write(struct mei_device *dev, struct mei_cl_cb *cb)
@@ -362,8 +361,6 @@ int mei_amthif_write(struct mei_device *dev, struct mei_cl_cb *cb)
  * mei_amthif_run_next_cmd
  *
  * @dev: the device structure
- *
- * returns 0 on success, <0 on failure.
  */
 void mei_amthif_run_next_cmd(struct mei_device *dev)
 {
@@ -426,12 +423,11 @@ unsigned int mei_amthif_poll(struct mei_device *dev,
 /**
  * mei_amthif_irq_write - write iamthif command in irq thread context.
  *
- * @dev: the device structure.
- * @cb_pos: callback block.
  * @cl: private data of the file object.
+ * @cb: callback block.
  * @cmpl_list: complete list.
  *
- * returns 0, OK; otherwise, error.
+ * Return: 0, OK; otherwise, error.
  */
 int mei_amthif_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,
 			 struct mei_cl_cb *cmpl_list)
@@ -513,7 +509,7 @@ int mei_amthif_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,
  * @mei_hdr: header of amthif message
  * @complete_list: An instance of our list structure
  *
- * returns 0 on success, <0 on failure.
+ * Return: 0 on success, <0 on failure.
  */
 int mei_amthif_irq_read_msg(struct mei_device *dev,
 			    struct mei_msg_hdr *mei_hdr,
@@ -566,7 +562,7 @@ int mei_amthif_irq_read_msg(struct mei_device *dev,
  * @dev: the device structure.
  * @slots: free slots.
  *
- * returns 0, OK; otherwise, error.
+ * Return: 0, OK; otherwise, error.
  */
 int mei_amthif_irq_read(struct mei_device *dev, s32 *slots)
 {
@@ -596,7 +592,7 @@ int mei_amthif_irq_read(struct mei_device *dev, s32 *slots)
  * mei_amthif_complete - complete amthif callback.
  *
  * @dev: the device structure.
- * @cb_pos: callback block.
+ * @cb: callback block.
  */
 void mei_amthif_complete(struct mei_device *dev, struct mei_cl_cb *cb)
 {
@@ -630,7 +626,7 @@ void mei_amthif_complete(struct mei_device *dev, struct mei_cl_cb *cb)
  * mei_clear_list is called to clear resources associated with file
  * when application calls close function or Ctrl-C was pressed
  *
- * returns true if callback removed from the list, false otherwise
+ * Return: true if callback removed from the list, false otherwise
  */
 static bool mei_clear_list(struct mei_device *dev,
 		const struct file *file, struct list_head *mei_cb_list)
@@ -670,7 +666,7 @@ static bool mei_clear_list(struct mei_device *dev,
  * mei_clear_lists is called to clear resources associated with file
  * when application calls close function or Ctrl-C was pressed
  *
- * returns true if callback removed from the list, false otherwise
+ * Return: true if callback removed from the list, false otherwise
  */
 static bool mei_clear_lists(struct mei_device *dev, struct file *file)
 {
@@ -711,7 +707,7 @@ static bool mei_clear_lists(struct mei_device *dev, struct file *file)
 *  @dev: device structure
 *  @file: pointer to file structure
 *
-*  returns 0 on success, <0 on error
+*  Return: 0 on success, <0 on error
 */
 int mei_amthif_release(struct mei_device *dev, struct file *file)
 {
* Unmerged path drivers/misc/mei/client.c
diff --git a/drivers/misc/mei/debugfs.c b/drivers/misc/mei/debugfs.c
index 85d1d2217fb8..40e6229627e7 100644
--- a/drivers/misc/mei/debugfs.c
+++ b/drivers/misc/mei/debugfs.c
@@ -154,7 +154,8 @@ static const struct file_operations mei_dbgfs_fops_devstate = {
 
 /**
  * mei_dbgfs_deregister - Remove the debugfs files and directories
- * @mei - pointer to mei device private data
+ *
+ * @dev: the mei device structure
  */
 void mei_dbgfs_deregister(struct mei_device *dev)
 {
@@ -165,8 +166,10 @@ void mei_dbgfs_deregister(struct mei_device *dev)
 }
 
 /**
- * Add the debugfs files
+ * mei_dbgfs_register - Add the debugfs files
  *
+ * @dev: the mei device structure
+ * @name: the mei device name
  */
 int mei_dbgfs_register(struct mei_device *dev, const char *name)
 {
* Unmerged path drivers/misc/mei/hbm.c
diff --git a/drivers/misc/mei/hw-me.c b/drivers/misc/mei/hw-me.c
index 241eae550b0c..9bae39ea252c 100644
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@ -28,10 +28,10 @@
 /**
  * mei_me_reg_read - Reads 32bit data from the mei device
  *
- * @dev: the device structure
+ * @hw: the me hardware structure
  * @offset: offset from which to read the data
  *
- * returns register value (u32)
+ * Return: register value (u32)
  */
 static inline u32 mei_me_reg_read(const struct mei_me_hw *hw,
 			       unsigned long offset)
@@ -43,7 +43,7 @@ static inline u32 mei_me_reg_read(const struct mei_me_hw *hw,
 /**
  * mei_me_reg_write - Writes 32bit data to the mei device
  *
- * @dev: the device structure
+ * @hw: the me hardware structure
  * @offset: offset from which to write the data
  * @value: register value to write (u32)
  */
@@ -59,7 +59,7 @@ static inline void mei_me_reg_write(const struct mei_me_hw *hw,
  *
  * @dev: the device structure
  *
- * returns ME_CB_RW register value (u32)
+ * Return: ME_CB_RW register value (u32)
  */
 static u32 mei_me_mecbrw_read(const struct mei_device *dev)
 {
@@ -68,9 +68,9 @@ static u32 mei_me_mecbrw_read(const struct mei_device *dev)
 /**
  * mei_me_mecsr_read - Reads 32bit data from the ME CSR
  *
- * @dev: the device structure
+ * @hw: the me hardware structure
  *
- * returns ME_CSR_HA register value (u32)
+ * Return: ME_CSR_HA register value (u32)
  */
 static inline u32 mei_me_mecsr_read(const struct mei_me_hw *hw)
 {
@@ -80,9 +80,9 @@ static inline u32 mei_me_mecsr_read(const struct mei_me_hw *hw)
 /**
  * mei_hcsr_read - Reads 32bit data from the host CSR
  *
- * @dev: the device structure
+ * @hw: the me hardware structure
  *
- * returns H_CSR register value (u32)
+ * Return: H_CSR register value (u32)
  */
 static inline u32 mei_hcsr_read(const struct mei_me_hw *hw)
 {
@@ -93,7 +93,7 @@ static inline u32 mei_hcsr_read(const struct mei_me_hw *hw)
  * mei_hcsr_set - writes H_CSR register to the mei device,
  * and ignores the H_IS bit for it is write-one-to-zero.
  *
- * @dev: the device structure
+ * @hw: the me hardware structure
  */
 static inline void mei_hcsr_set(struct mei_me_hw *hw, u32 hcsr)
 {
@@ -241,8 +241,8 @@ static void mei_me_host_set_ready(struct mei_device *dev)
 /**
  * mei_me_host_is_ready - check whether the host has turned ready
  *
- * @dev - mei device
- * returns bool
+ * @dev: mei device
+ * Return: bool
  */
 static bool mei_me_host_is_ready(struct mei_device *dev)
 {
@@ -254,8 +254,8 @@ static bool mei_me_host_is_ready(struct mei_device *dev)
 /**
  * mei_me_hw_is_ready - check whether the me(hw) has turned ready
  *
- * @dev - mei device
- * returns bool
+ * @dev: mei device
+ * Return: bool
  */
 static bool mei_me_hw_is_ready(struct mei_device *dev)
 {
@@ -297,7 +297,7 @@ static int mei_me_hw_start(struct mei_device *dev)
  *
  * @dev: the device structure
  *
- * returns number of filled slots
+ * Return: number of filled slots
  */
 static unsigned char mei_hbuf_filled_slots(struct mei_device *dev)
 {
@@ -317,7 +317,7 @@ static unsigned char mei_hbuf_filled_slots(struct mei_device *dev)
  *
  * @dev: the device structure
  *
- * returns true if empty, false - otherwise.
+ * Return: true if empty, false - otherwise.
  */
 static bool mei_me_hbuf_is_empty(struct mei_device *dev)
 {
@@ -329,7 +329,7 @@ static bool mei_me_hbuf_is_empty(struct mei_device *dev)
  *
  * @dev: the device structure
  *
- * returns -EOVERFLOW if overflow, otherwise empty slots count
+ * Return: -EOVERFLOW if overflow, otherwise empty slots count
  */
 static int mei_me_hbuf_empty_slots(struct mei_device *dev)
 {
@@ -358,7 +358,7 @@ static size_t mei_me_hbuf_max_len(const struct mei_device *dev)
  * @header: mei HECI header of message
  * @buf: message payload will be written
  *
- * This function returns -EIO if write has failed
+ * Return: -EIO if write has failed
  */
 static int mei_me_write_message(struct mei_device *dev,
 			struct mei_msg_hdr *header,
@@ -407,7 +407,7 @@ static int mei_me_write_message(struct mei_device *dev,
  *
  * @dev: the device structure
  *
- * returns -EOVERFLOW if overflow, otherwise filled slots count
+ * Return: -EOVERFLOW if overflow, otherwise filled slots count
  */
 static int mei_me_count_full_read_slots(struct mei_device *dev)
 {
@@ -490,7 +490,7 @@ static void mei_me_pg_exit(struct mei_device *dev)
  *
  * @dev: the device structure
  *
- * returns 0 on success an error code otherwise
+ * Return: 0 on success an error code otherwise
  */
 int mei_me_pg_set_sync(struct mei_device *dev)
 {
@@ -527,7 +527,7 @@ int mei_me_pg_set_sync(struct mei_device *dev)
  *
  * @dev: the device structure
  *
- * returns 0 on success an error code otherwise
+ * Return: 0 on success an error code otherwise
  */
 int mei_me_pg_unset_sync(struct mei_device *dev)
 {
@@ -564,7 +564,7 @@ reply:
  *
  * @dev: the device structure
  *
- * returns: true is pg supported, false otherwise
+ * Return: true is pg supported, false otherwise
  */
 static bool mei_me_pg_is_enabled(struct mei_device *dev)
 {
@@ -596,7 +596,7 @@ notsupported:
  * @irq: The irq number
  * @dev_id: pointer to the device structure
  *
- * returns irqreturn_t
+ * Return: irqreturn_t
  */
 
 irqreturn_t mei_me_irq_quick_handler(int irq, void *dev_id)
@@ -621,7 +621,7 @@ irqreturn_t mei_me_irq_quick_handler(int irq, void *dev_id)
  * @irq: The irq number
  * @dev_id: pointer to the device structure
  *
- * returns irqreturn_t
+ * Return: irqreturn_t
  *
  */
 irqreturn_t mei_me_irq_thread_handler(int irq, void *dev_id)
@@ -800,7 +800,7 @@ const struct mei_cfg mei_me_lpt_cfg = {
  * @pdev: The pci device structure
  * @cfg: per device generation config
  *
- * returns The mei_device_device pointer on success, NULL on failure.
+ * Return: The mei_device_device pointer on success, NULL on failure.
  */
 struct mei_device *mei_me_dev_init(struct pci_dev *pdev,
 				   const struct mei_cfg *cfg)
diff --git a/drivers/misc/mei/hw-txe.c b/drivers/misc/mei/hw-txe.c
index f1cd166094f2..6321b5704813 100644
--- a/drivers/misc/mei/hw-txe.c
+++ b/drivers/misc/mei/hw-txe.c
@@ -85,7 +85,7 @@ static inline u32 mei_txe_sec_reg_read(struct mei_txe_hw *hw,
  * mei_txe_sec_reg_write_silent - Writes 32bit data to the SeC BAR
  *   doesn't check for aliveness
  *
- * @dev: the device structure
+ * @hw: the txe hardware structure
  * @offset: register offset
  * @value: value to write
  *
@@ -100,7 +100,7 @@ static inline void mei_txe_sec_reg_write_silent(struct mei_txe_hw *hw,
 /**
  * mei_txe_sec_reg_write - Writes 32bit data to the SeC BAR
  *
- * @dev: the device structure
+ * @hw: the txe hardware structure
  * @offset: register offset
  * @value: value to write
  *
@@ -128,7 +128,7 @@ static inline u32 mei_txe_br_reg_read(struct mei_txe_hw *hw,
 /**
  * mei_txe_br_reg_write - Writes 32bit data to the Bridge BAR
  *
- * @hw: the device structure
+ * @hw: the txe hardware structure
  * @offset: offset from which to write the data
  * @value: the byte to write
  */
@@ -203,7 +203,8 @@ static u32 mei_txe_aliveness_get(struct mei_device *dev)
  * @expected: expected aliveness value
  *
  * Polls for HICR_HOST_ALIVENESS_RESP.ALIVENESS_RESP to be set
- * returns > 0 if the expected value was received, -ETIME otherwise
+ *
+ * Return: > 0 if the expected value was received, -ETIME otherwise
  */
 static int mei_txe_aliveness_poll(struct mei_device *dev, u32 expected)
 {
@@ -236,7 +237,8 @@ static int mei_txe_aliveness_poll(struct mei_device *dev, u32 expected)
  * @expected: expected aliveness value
  *
  * Waits for HICR_HOST_ALIVENESS_RESP.ALIVENESS_RESP to be set
- * returns returns 0 on success and < 0 otherwise
+ *
+ * Return: 0 on success and < 0 otherwise
  */
 static int mei_txe_aliveness_wait(struct mei_device *dev, u32 expected)
 {
@@ -275,7 +277,7 @@ static int mei_txe_aliveness_wait(struct mei_device *dev, u32 expected)
  *
  * @dev: the device structure
  *
- * returns returns 0 on success and < 0 otherwise
+ * Return: 0 on success and < 0 otherwise
  */
 int mei_txe_aliveness_set_sync(struct mei_device *dev, u32 req)
 {
@@ -289,7 +291,7 @@ int mei_txe_aliveness_set_sync(struct mei_device *dev, u32 req)
  *
  * @dev: the device structure
  *
- * returns: true is pg supported, false otherwise
+ * Return: true is pg supported, false otherwise
  */
 static bool mei_txe_pg_is_enabled(struct mei_device *dev)
 {
@@ -302,7 +304,7 @@ static bool mei_txe_pg_is_enabled(struct mei_device *dev)
  *
  * @dev: the device structure
  *
- * returns: MEI_PG_OFF if aliveness is on and MEI_PG_ON otherwise
+ * Return: MEI_PG_OFF if aliveness is on and MEI_PG_ON otherwise
  */
 static inline enum mei_pg_state mei_txe_pg_state(struct mei_device *dev)
 {
@@ -326,9 +328,10 @@ static void mei_txe_input_ready_interrupt_enable(struct mei_device *dev)
 }
 
 /**
- * mei_txe_input_doorbell_set
- *   - Sets bit 0 in SEC_IPC_INPUT_DOORBELL.IPC_INPUT_DOORBELL.
- * @dev: the device structure
+ * mei_txe_input_doorbell_set - sets bit 0 in
+ *    SEC_IPC_INPUT_DOORBELL.IPC_INPUT_DOORBELL.
+ *
+ * @hw: the txe hardware structure
  */
 static void mei_txe_input_doorbell_set(struct mei_txe_hw *hw)
 {
@@ -340,7 +343,7 @@ static void mei_txe_input_doorbell_set(struct mei_txe_hw *hw)
 /**
  * mei_txe_output_ready_set - Sets the SICR_SEC_IPC_OUTPUT_STATUS bit to 1
  *
- * @dev: the device structure
+ * @hw: the txe hardware structure
  */
 static void mei_txe_output_ready_set(struct mei_txe_hw *hw)
 {
@@ -451,7 +454,7 @@ static void mei_txe_input_payload_write(struct mei_device *dev,
  * @dev: the device structure
  * @idx: index in the device buffer
  *
- * returns register value at index
+ * Return: register value at index
  */
 static u32 mei_txe_out_data_read(const struct mei_device *dev,
 					unsigned long idx)
@@ -492,6 +495,8 @@ static void mei_txe_readiness_clear(struct mei_device *dev)
  *	the HICR_SEC_IPC_READINESS register value
  *
  * @dev: the device structure
+ *
+ * Return: the HICR_SEC_IPC_READINESS register value
  */
 static u32 mei_txe_readiness_get(struct mei_device *dev)
 {
@@ -539,7 +544,7 @@ static inline bool mei_txe_host_is_ready(struct mei_device *dev)
  *
  * @dev: the device structure
  *
- * returns 0 on success and -ETIME on timeout
+ * Return: 0 on success and -ETIME on timeout
  */
 static int mei_txe_readiness_wait(struct mei_device *dev)
 {
@@ -588,7 +593,8 @@ static void mei_txe_hw_config(struct mei_device *dev)
  * @dev: the device structure
  * @header: header of message
  * @buf: message buffer will be written
- * returns 1 if success, 0 - otherwise.
+ *
+ * Return: if success, 0 - otherwise.
  */
 
 static int mei_txe_write(struct mei_device *dev,
@@ -653,7 +659,7 @@ static int mei_txe_write(struct mei_device *dev,
  *
  * @dev: the device structure
  *
- * returns the PAYLOAD_SIZE - 4
+ * Return: PAYLOAD_SIZE - 4
  */
 static size_t mei_txe_hbuf_max_len(const struct mei_device *dev)
 {
@@ -665,7 +671,7 @@ static size_t mei_txe_hbuf_max_len(const struct mei_device *dev)
  *
  * @dev: the device structure
  *
- * returns always hbuf_depth
+ * Return: always hbuf_depth
  */
 static int mei_txe_hbuf_empty_slots(struct mei_device *dev)
 {
@@ -678,7 +684,7 @@ static int mei_txe_hbuf_empty_slots(struct mei_device *dev)
  *
  * @dev: the device structure
  *
- * returns always buffer size in dwords count
+ * Return: always buffer size in dwords count
  */
 static int mei_txe_count_full_read_slots(struct mei_device *dev)
 {
@@ -691,7 +697,7 @@ static int mei_txe_count_full_read_slots(struct mei_device *dev)
  *
  * @dev: the device structure
  *
- * returns mei message header
+ * Return: mei message header
  */
 
 static u32 mei_txe_read_hdr(const struct mei_device *dev)
@@ -705,7 +711,7 @@ static u32 mei_txe_read_hdr(const struct mei_device *dev)
  * @buf: message buffer will be written
  * @len: message size will be read
  *
- * returns -EINVAL on error wrong argument and 0 on success
+ * Return: -EINVAL on error wrong argument and 0 on success
  */
 static int mei_txe_read(struct mei_device *dev,
 		unsigned char *buf, unsigned long len)
@@ -745,7 +751,7 @@ static int mei_txe_read(struct mei_device *dev,
  * @dev: the device structure
  * @intr_enable: if interrupt should be enabled after reset.
  *
- * returns 0 on success and < 0 in case of error
+ * Return: 0 on success and < 0 in case of error
  */
 static int mei_txe_hw_reset(struct mei_device *dev, bool intr_enable)
 {
@@ -801,7 +807,7 @@ static int mei_txe_hw_reset(struct mei_device *dev, bool intr_enable)
  *
  * @dev: the device structure
  *
- * returns 0 on success and < 0 in case of error
+ * Return: 0 on success and < 0 in case of error
  */
 static int mei_txe_hw_start(struct mei_device *dev)
 {
@@ -912,7 +918,8 @@ out:
  * @irq: The irq number
  * @dev_id: pointer to the device structure
  *
- * returns irqreturn_t
+ * Return: IRQ_WAKE_THREAD if interrupt is designed for the device
+ *         IRQ_NONE otherwise
  */
 irqreturn_t mei_txe_irq_quick_handler(int irq, void *dev_id)
 {
@@ -930,7 +937,7 @@ irqreturn_t mei_txe_irq_quick_handler(int irq, void *dev_id)
  * @irq: The irq number
  * @dev_id: pointer to the device structure
  *
- * returns irqreturn_t
+ * Return: IRQ_HANDLED
  *
  */
 irqreturn_t mei_txe_irq_thread_handler(int irq, void *dev_id)
@@ -1088,7 +1095,7 @@ const struct mei_cfg mei_txe_cfg = {
  * @pdev - pci device
  * @cfg - per device generation config
  *
- * returns struct mei_device * on success or NULL;
+ * Return: struct mei_device * on success or NULL;
  *
  */
 struct mei_device *mei_txe_dev_init(struct pci_dev *pdev,
* Unmerged path drivers/misc/mei/hw.h
diff --git a/drivers/misc/mei/init.c b/drivers/misc/mei/init.c
index 08331e745faf..3f6bbc84939f 100644
--- a/drivers/misc/mei/init.c
+++ b/drivers/misc/mei/init.c
@@ -57,11 +57,11 @@ const char *mei_pg_state_str(enum mei_pg_state state)
 
 
 /**
- * mei_cancel_work. Cancel mei background jobs
+ * mei_cancel_work - Cancel mei background jobs
  *
  * @dev: the device structure
  *
- * returns 0 on success or < 0 if the reset hasn't succeeded
+ * Return: 0 on success or < 0 if the reset hasn't succeeded
  */
 void mei_cancel_work(struct mei_device *dev)
 {
@@ -175,7 +175,7 @@ EXPORT_SYMBOL_GPL(mei_reset);
  *
  * @dev: the device structure
  *
- * returns 0 on success, <0 on failure.
+ * Return: 0 on success, <0 on failure.
  */
 int mei_start(struct mei_device *dev)
 {
@@ -243,7 +243,7 @@ EXPORT_SYMBOL_GPL(mei_start);
  *
  * @dev: the device structure
  *
- * returns 0 on success or -ENODEV if the restart hasn't succeeded
+ * Return: 0 on success or -ENODEV if the restart hasn't succeeded
  */
 int mei_restart(struct mei_device *dev)
 {
@@ -324,7 +324,7 @@ EXPORT_SYMBOL_GPL(mei_stop);
  *
  * @dev: the device structure
  *
- * returns true of there is no pending write
+ * Return: true of there is no pending write
  */
 bool mei_write_is_idle(struct mei_device *dev)
 {
diff --git a/drivers/misc/mei/interrupt.c b/drivers/misc/mei/interrupt.c
index b8d9cfee3e87..98a3adfe6a76 100644
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@ -33,8 +33,8 @@
  * mei_irq_compl_handler - dispatch complete handlers
  *	for the completed callbacks
  *
- * @dev - mei device
- * @compl_list - list of completed cbs
+ * @dev: mei device
+ * @compl_list: list of completed cbs
  */
 void mei_irq_compl_handler(struct mei_device *dev, struct mei_cl_cb *compl_list)
 {
@@ -62,7 +62,7 @@ EXPORT_SYMBOL_GPL(mei_irq_compl_handler);
  * @cl: host client
  * @mei_hdr: header of mei client message
  *
- * returns true if matches, false otherwise
+ * Return: true if matches, false otherwise
  */
 static inline int mei_cl_hbm_equal(struct mei_cl *cl,
 			struct mei_msg_hdr *mei_hdr)
@@ -72,12 +72,12 @@ static inline int mei_cl_hbm_equal(struct mei_cl *cl,
 }
 /**
  * mei_cl_is_reading - checks if the client
-		is the one to read this message
+ *		is the one to read this message
  *
  * @cl: mei client
  * @mei_hdr: header of mei message
  *
- * returns true on match and false otherwise
+ * Return: true on match and false otherwise
  */
 static bool mei_cl_is_reading(struct mei_cl *cl, struct mei_msg_hdr *mei_hdr)
 {
@@ -93,7 +93,7 @@ static bool mei_cl_is_reading(struct mei_cl *cl, struct mei_msg_hdr *mei_hdr)
  * @mei_hdr: header of mei client message
  * @complete_list: An instance of our list structure
  *
- * returns 0 on success, <0 on failure.
+ * Return: 0 on success, <0 on failure.
  */
 static int mei_cl_irq_read_msg(struct mei_device *dev,
 			       struct mei_msg_hdr *mei_hdr,
@@ -165,7 +165,7 @@ static int mei_cl_irq_read_msg(struct mei_device *dev,
  * @cb: callback block.
  * @cmpl_list: complete list.
  *
- * returns 0, OK; otherwise, error.
+ * Return: 0, OK; otherwise, error.
  */
 static int mei_cl_irq_disconnect_rsp(struct mei_cl *cl, struct mei_cl_cb *cb,
 				     struct mei_cl_cb *cmpl_list)
@@ -201,7 +201,7 @@ static int mei_cl_irq_disconnect_rsp(struct mei_cl *cl, struct mei_cl_cb *cb,
  * @cb: callback block.
  * @cmpl_list: complete list.
  *
- * returns 0, OK; otherwise, error.
+ * Return: 0, OK; otherwise, error.
  */
 static int mei_cl_irq_disconnect(struct mei_cl *cl, struct mei_cl_cb *cb,
 			    struct mei_cl_cb *cmpl_list)
@@ -241,7 +241,7 @@ static int mei_cl_irq_disconnect(struct mei_cl *cl, struct mei_cl_cb *cb,
  * @cb: callback block.
  * @cmpl_list: complete list.
  *
- * returns 0, OK; otherwise, error.
+ * Return: 0, OK; otherwise, error.
  */
 static int mei_cl_irq_read(struct mei_cl *cl, struct mei_cl_cb *cb,
 			   struct mei_cl_cb *cmpl_list)
@@ -278,7 +278,7 @@ static int mei_cl_irq_read(struct mei_cl *cl, struct mei_cl_cb *cb,
  * @cb: callback block.
  * @cmpl_list: complete list.
  *
- * returns 0, OK; otherwise, error.
+ * Return: 0, OK; otherwise, error.
  */
 static int mei_cl_irq_connect(struct mei_cl *cl, struct mei_cl_cb *cb,
 			      struct mei_cl_cb *cmpl_list)
@@ -321,7 +321,7 @@ static int mei_cl_irq_connect(struct mei_cl *cl, struct mei_cl_cb *cb,
  * @cmpl_list: An instance of our list structure
  * @slots: slots to read.
  *
- * returns 0 on success, <0 on failure.
+ * Return: 0 on success, <0 on failure.
  */
 int mei_irq_read_handler(struct mei_device *dev,
 		struct mei_cl_cb *cmpl_list, s32 *slots)
@@ -424,7 +424,7 @@ EXPORT_SYMBOL_GPL(mei_irq_read_handler);
  * @dev: the device structure
  * @cmpl_list: An instance of our list structure
  *
- * returns 0 on success, <0 on failure.
+ * Return: 0 on success, <0 on failure.
  */
 int mei_irq_write_handler(struct mei_device *dev, struct mei_cl_cb *cmpl_list)
 {
* Unmerged path drivers/misc/mei/main.c
* Unmerged path drivers/misc/mei/mei_dev.h
diff --git a/drivers/misc/mei/nfc.c b/drivers/misc/mei/nfc.c
index 2b65e8021f0d..3e46e5673d0d 100644
--- a/drivers/misc/mei/nfc.c
+++ b/drivers/misc/mei/nfc.c
@@ -87,7 +87,8 @@ struct mei_nfc_hci_hdr {
 
 #define MEI_NFC_HEADER_SIZE 10
 
-/** mei_nfc_dev - NFC mei device
+/**
+ * struct mei_nfc_dev - NFC mei device
  *
  * @cl: NFC host client
  * @cl_info: NFC info host client
diff --git a/drivers/misc/mei/pci-me.c b/drivers/misc/mei/pci-me.c
index 1eebd0f6a9f0..373516d8c6db 100644
--- a/drivers/misc/mei/pci-me.c
+++ b/drivers/misc/mei/pci-me.c
@@ -100,7 +100,7 @@ static DEFINE_MUTEX(mei_mutex);
  * @pdev: PCI device structure
  * @cfg: per generation config
  *
- * returns true if ME Interface is valid, false otherwise
+ * Return: true if ME Interface is valid, false otherwise
  */
 static bool mei_me_quirk_probe(struct pci_dev *pdev,
 				const struct mei_cfg *cfg)
@@ -119,7 +119,7 @@ static bool mei_me_quirk_probe(struct pci_dev *pdev,
  * @pdev: PCI device structure
  * @ent: entry in kcs_pci_tbl
  *
- * returns 0 on success, <0 on failure.
+ * Return: 0 on success, <0 on failure.
  */
 static int mei_me_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
diff --git a/drivers/misc/mei/pci-txe.c b/drivers/misc/mei/pci-txe.c
index 2343c6236df9..d61856d22b75 100644
--- a/drivers/misc/mei/pci-txe.c
+++ b/drivers/misc/mei/pci-txe.c
@@ -65,7 +65,7 @@ static void mei_txe_pci_iounmap(struct pci_dev *pdev, struct mei_txe_hw *hw)
  * @pdev: PCI device structure
  * @ent: entry in mei_txe_pci_tbl
  *
- * returns 0 on success, <0 on failure.
+ * Return: 0 on success, <0 on failure.
  */
 static int mei_txe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
diff --git a/drivers/misc/mei/wd.c b/drivers/misc/mei/wd.c
index 1e4f4283f10e..8d0383edeaa1 100644
--- a/drivers/misc/mei/wd.c
+++ b/drivers/misc/mei/wd.c
@@ -58,7 +58,7 @@ static void mei_wd_set_start_timeout(struct mei_device *dev, u16 timeout)
  *
  * @dev: the device structure
  *
- * returns -ENOTTY if wd client cannot be found
+ * Return: -ENOTTY if wd client cannot be found
  *         -EIO if write has failed
  *         0 on success
  */
@@ -111,7 +111,7 @@ int mei_wd_host_init(struct mei_device *dev)
  *
  * @dev: the device structure
  *
- * returns 0 if success,
+ * Return: 0 if success,
  *	-EIO when message send fails
  *	-EINVAL when invalid message is to be sent
  *	-ENODEV on flow control failure
@@ -156,9 +156,8 @@ int mei_wd_send(struct mei_device *dev)
  * mei_wd_stop - sends watchdog stop message to fw.
  *
  * @dev: the device structure
- * @preserve: indicate if to keep the timeout value
  *
- * returns 0 if success
+ * Return: 0 if success
  * on error:
  *	-EIO    when message send fails
  *	-EINVAL when invalid message is to be sent
@@ -214,7 +213,7 @@ err:
  *
  * @wd_dev - watchdog device struct
  *
- * returns 0 if success, negative errno code for failure
+ * Return: 0 if success, negative errno code for failure
  */
 static int mei_wd_ops_start(struct watchdog_device *wd_dev)
 {
@@ -253,7 +252,7 @@ end_unlock:
  *
  * @wd_dev - watchdog device struct
  *
- * returns 0 if success, negative errno code for failure
+ * Return: 0 if success, negative errno code for failure
  */
 static int mei_wd_ops_stop(struct watchdog_device *wd_dev)
 {
@@ -275,7 +274,7 @@ static int mei_wd_ops_stop(struct watchdog_device *wd_dev)
  *
  * @wd_dev - watchdog device struct
  *
- * returns 0 if success, negative errno code for failure
+ * Return: 0 if success, negative errno code for failure
  */
 static int mei_wd_ops_ping(struct watchdog_device *wd_dev)
 {
@@ -323,7 +322,7 @@ end:
  * @wd_dev - watchdog device struct
  * @timeout - timeout value to set
  *
- * returns 0 if success, negative errno code for failure
+ * Return: 0 if success, negative errno code for failure
  */
 static int mei_wd_ops_set_timeout(struct watchdog_device *wd_dev,
 		unsigned int timeout)
