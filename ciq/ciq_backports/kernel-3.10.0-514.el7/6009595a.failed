mei: bus: link client devices instead of host clients

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 6009595a66e460af0b170d736398c49395cb4499
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6009595a.failed

MEI bus was designed around nfc and was hard to extend.
Instead of the hard coded way of adding the devices on the mei bus
we scan the whole me client list and create a device for each
eligible me client (mei_cl_bus_rescan); currently we support
only clients with single connection and fixed address clients.
NFC radio name detection is run as a fixup routine

The patch replaces handling the device list based on struct me_cl
to device list based on me_cl_devices. The creating a connection
is pushed from the device creation time to device enablement.

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 6009595a66e460af0b170d736398c49395cb4499)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/bus-fixup.c
#	drivers/misc/mei/bus.c
#	drivers/misc/mei/client.c
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/bus-fixup.c
index 2b65e8021f0d,3e536ca85f7d..000000000000
--- a/drivers/misc/mei/bus-fixup.c
+++ b/drivers/misc/mei/bus-fixup.c
@@@ -25,6 -27,46 +25,49 @@@
  #include "mei_dev.h"
  #include "client.h"
  
++<<<<<<< HEAD
++=======
+ #define MEI_UUID_NFC_INFO UUID_LE(0xd2de1625, 0x382d, 0x417d, \
+ 			0x48, 0xa4, 0xef, 0xab, 0xba, 0x8a, 0x12, 0x06)
+ 
+ static const uuid_le mei_nfc_info_guid = MEI_UUID_NFC_INFO;
+ 
+ #define MEI_UUID_NFC_HCI UUID_LE(0x0bb17a78, 0x2a8e, 0x4c50, \
+ 			0x94, 0xd4, 0x50, 0x26, 0x67, 0x23, 0x77, 0x5c)
+ 
+ #define MEI_UUID_ANY NULL_UUID_LE
+ 
+ /**
+  * number_of_connections - determine whether an client be on the bus
+  *    according number of connections
+  *    We support only clients:
+  *       1. with single connection
+  *       2. and fixed clients (max_number_of_connections == 0)
+  *
+  * @cldev: me clients device
+  */
+ static void number_of_connections(struct mei_cl_device *cldev)
+ {
+ 	dev_dbg(&cldev->dev, "running hook %s on %pUl\n",
+ 			__func__, mei_me_cl_uuid(cldev->me_cl));
+ 
+ 	if (cldev->me_cl->props.max_number_of_connections > 1)
+ 		cldev->do_match = 0;
+ }
+ 
+ /**
+  * blacklist - blacklist a client from the bus
+  *
+  * @cldev: me clients device
+  */
+ static void blacklist(struct mei_cl_device *cldev)
+ {
+ 	dev_dbg(&cldev->dev, "running hook %s on %pUl\n",
+ 			__func__, mei_me_cl_uuid(cldev->me_cl));
+ 	cldev->do_match = 0;
+ }
+ 
++>>>>>>> 6009595a66e4 (mei: bus: link client devices instead of host clients)
  struct mei_nfc_cmd {
  	u8 command;
  	u8 status;
@@@ -56,71 -98,10 +99,49 @@@ struct mei_nfc_if_version 
  	u8 radio_type;
  } __packed;
  
- struct mei_nfc_connect {
- 	u8 fw_ivn;
- 	u8 vendor_id;
- } __packed;
- 
- struct mei_nfc_connect_resp {
- 	u8 fw_ivn;
- 	u8 vendor_id;
- 	u16 me_major;
- 	u16 me_minor;
- 	u16 me_hotfix;
- 	u16 me_build;
- } __packed;
- 
- struct mei_nfc_hci_hdr {
- 	u8 cmd;
- 	u8 status;
- 	u16 req_id;
- 	u32 reserved;
- 	u16 data_size;
- } __packed;
  
  #define MEI_NFC_CMD_MAINTENANCE 0x00
- #define MEI_NFC_CMD_HCI_SEND 0x01
- #define MEI_NFC_CMD_HCI_RECV 0x02
- 
- #define MEI_NFC_SUBCMD_CONNECT    0x00
  #define MEI_NFC_SUBCMD_IF_VERSION 0x01
  
++<<<<<<< HEAD
 +#define MEI_NFC_HEADER_SIZE 10
 +
 +/** mei_nfc_dev - NFC mei device
 + *
 + * @cl: NFC host client
 + * @cl_info: NFC info host client
 + * @init_work: perform connection to the info client
 + * @fw_ivn: NFC Interface Version Number
 + * @vendor_id: NFC manufacturer ID
 + * @radio_type: NFC radio type
 + */
 +struct mei_nfc_dev {
 +	struct mei_cl *cl;
 +	struct mei_cl *cl_info;
 +	struct work_struct init_work;
 +	wait_queue_head_t send_wq;
 +	u8 fw_ivn;
 +	u8 vendor_id;
 +	u8 radio_type;
 +	char *bus_name;
 +
 +	u16 req_id;
 +	u16 recv_req_id;
 +};
 +
 +static struct mei_nfc_dev nfc_dev;
 +
 +/* UUIDs for NFC F/W clients */
 +const uuid_le mei_nfc_guid = UUID_LE(0x0bb17a78, 0x2a8e, 0x4c50,
 +				     0x94, 0xd4, 0x50, 0x26,
 +				     0x67, 0x23, 0x77, 0x5c);
 +
 +static const uuid_le mei_nfc_info_guid = UUID_LE(0xd2de1625, 0x382d, 0x417d,
 +					0x48, 0xa4, 0xef, 0xab,
 +					0xba, 0x8a, 0x12, 0x06);
 +
++=======
++>>>>>>> 6009595a66e4 (mei: bus: link client devices instead of host clients)
  /* Vendors */
  #define MEI_NFC_VENDOR_INSIDE 0x00
  #define MEI_NFC_VENDOR_NXP    0x01
@@@ -129,143 -110,24 +150,156 @@@
  #define MEI_NFC_VENDOR_INSIDE_UREAD 0x00
  #define MEI_NFC_VENDOR_NXP_PN544    0x01
  
++<<<<<<< HEAD
 +static void mei_nfc_free(struct mei_nfc_dev *ndev)
 +{
 +	if (ndev->cl) {
 +		list_del(&ndev->cl->device_link);
 +		mei_cl_unlink(ndev->cl);
 +		kfree(ndev->cl);
 +	}
 +
 +	if (ndev->cl_info) {
 +		list_del(&ndev->cl_info->device_link);
 +		mei_cl_unlink(ndev->cl_info);
 +		kfree(ndev->cl_info);
 +	}
 +
 +	memset(ndev, 0, sizeof(struct mei_nfc_dev));
 +}
 +
 +static int mei_nfc_build_bus_name(struct mei_nfc_dev *ndev)
++=======
+ /**
+  * mei_nfc_if_version - get NFC interface version
+  *
+  * @cl: host client (nfc info)
+  * @ver: NFC interface version to be filled in
+  *
+  * Return: 0 on success; < 0 otherwise
+  */
+ static int mei_nfc_if_version(struct mei_cl *cl,
+ 			      struct mei_nfc_if_version *ver)
++>>>>>>> 6009595a66e4 (mei: bus: link client devices instead of host clients)
  {
 -	struct mei_device *bus;
 -	struct mei_nfc_cmd cmd = {
 -		.command = MEI_NFC_CMD_MAINTENANCE,
 -		.data_size = 1,
 -		.sub_command = MEI_NFC_SUBCMD_IF_VERSION,
 -	};
 +	struct mei_device *dev;
 +
 +	if (!ndev->cl)
 +		return -ENODEV;
 +
 +	dev = ndev->cl->dev;
 +
 +	switch (ndev->vendor_id) {
 +	case MEI_NFC_VENDOR_INSIDE:
 +		switch (ndev->radio_type) {
 +		case MEI_NFC_VENDOR_INSIDE_UREAD:
 +			ndev->bus_name = "microread";
 +			return 0;
 +
 +		default:
 +			dev_err(&dev->pdev->dev, "Unknown radio type 0x%x\n",
 +				ndev->radio_type);
 +
 +			return -EINVAL;
 +		}
 +
 +	case MEI_NFC_VENDOR_NXP:
 +		switch (ndev->radio_type) {
 +		case MEI_NFC_VENDOR_NXP_PN544:
 +			ndev->bus_name = "pn544";
 +			return 0;
 +		default:
 +			dev_err(&dev->pdev->dev, "Unknown radio type 0x%x\n",
 +				ndev->radio_type);
 +
 +			return -EINVAL;
 +		}
 +
 +	default:
 +		dev_err(&dev->pdev->dev, "Unknown vendor ID 0x%x\n",
 +			ndev->vendor_id);
 +
 +		return -EINVAL;
 +	}
 +
 +	return 0;
 +}
 +
 +static int mei_nfc_connect(struct mei_nfc_dev *ndev)
 +{
 +	struct mei_device *dev;
 +	struct mei_cl *cl;
 +	struct mei_nfc_cmd *cmd, *reply;
 +	struct mei_nfc_connect *connect;
 +	struct mei_nfc_connect_resp *connect_resp;
 +	size_t connect_length, connect_resp_length;
 +	int bytes_recv, ret;
 +
 +	cl = ndev->cl;
 +	dev = cl->dev;
 +
 +	connect_length = sizeof(struct mei_nfc_cmd) +
 +			sizeof(struct mei_nfc_connect);
 +
 +	connect_resp_length = sizeof(struct mei_nfc_cmd) +
 +			sizeof(struct mei_nfc_connect_resp);
 +
 +	cmd = kzalloc(connect_length, GFP_KERNEL);
 +	if (!cmd)
 +		return -ENOMEM;
 +	connect = (struct mei_nfc_connect *)cmd->data;
 +
 +	reply = kzalloc(connect_resp_length, GFP_KERNEL);
 +	if (!reply) {
 +		kfree(cmd);
 +		return -ENOMEM;
 +	}
 +
 +	connect_resp = (struct mei_nfc_connect_resp *)reply->data;
 +
 +	cmd->command = MEI_NFC_CMD_MAINTENANCE;
 +	cmd->data_size = 3;
 +	cmd->sub_command = MEI_NFC_SUBCMD_CONNECT;
 +	connect->fw_ivn = ndev->fw_ivn;
 +	connect->vendor_id = ndev->vendor_id;
 +
 +	ret = __mei_cl_send(cl, (u8 *)cmd, connect_length);
 +	if (ret < 0) {
 +		dev_err(&dev->pdev->dev, "Could not send connect cmd\n");
 +		goto err;
 +	}
 +
 +	bytes_recv = __mei_cl_recv(cl, (u8 *)reply, connect_resp_length);
 +	if (bytes_recv < 0) {
 +		dev_err(&dev->pdev->dev, "Could not read connect response\n");
 +		ret = bytes_recv;
 +		goto err;
 +	}
 +
 +	dev_info(&dev->pdev->dev, "IVN 0x%x Vendor ID 0x%x\n",
 +		 connect_resp->fw_ivn, connect_resp->vendor_id);
 +
 +	dev_info(&dev->pdev->dev, "ME FW %d.%d.%d.%d\n",
 +		connect_resp->me_major, connect_resp->me_minor,
 +		connect_resp->me_hotfix, connect_resp->me_build);
 +
 +	ret = 0;
 +
 +err:
 +	kfree(reply);
 +	kfree(cmd);
 +
 +	return ret;
 +}
 +
 +static int mei_nfc_if_version(struct mei_nfc_dev *ndev)
 +{
 +	struct mei_device *dev;
 +	struct mei_cl *cl;
 +
 +	struct mei_nfc_cmd cmd;
  	struct mei_nfc_reply *reply = NULL;
 +	struct mei_nfc_if_version *version;
  	size_t if_version_length;
  	int bytes_recv, ret;
  
@@@ -309,249 -167,140 +343,365 @@@ err
  	return ret;
  }
  
 -/**
 - * mei_nfc_radio_name - derive nfc radio name from the interface version
 - *
 - * @ver: NFC radio version
 - *
 - * Return: radio name string
 - */
 -static const char *mei_nfc_radio_name(struct mei_nfc_if_version *ver)
 +static int mei_nfc_enable(struct mei_cl_device *cldev)
 +{
 +	struct mei_device *dev;
 +	struct mei_nfc_dev *ndev = &nfc_dev;
 +	int ret;
 +
 +	dev = ndev->cl->dev;
 +
 +	ret = mei_nfc_connect(ndev);
 +	if (ret < 0) {
 +		dev_err(&dev->pdev->dev, "Could not connect to NFC");
 +		return ret;
 +	}
 +
 +	return 0;
 +}
 +
++<<<<<<< HEAD
 +static int mei_nfc_disable(struct mei_cl_device *cldev)
 +{
 +	return 0;
 +}
 +
 +static int mei_nfc_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
 +{
 +	struct mei_device *dev;
 +	struct mei_nfc_dev *ndev;
 +	struct mei_nfc_hci_hdr *hdr;
 +	u8 *mei_buf;
 +	int err;
 +
 +	ndev = (struct mei_nfc_dev *) cldev->priv_data;
 +	dev = ndev->cl->dev;
 +
 +	mei_buf = kzalloc(length + MEI_NFC_HEADER_SIZE, GFP_KERNEL);
 +	if (!mei_buf)
 +		return -ENOMEM;
 +
 +	hdr = (struct mei_nfc_hci_hdr *) mei_buf;
 +	hdr->cmd = MEI_NFC_CMD_HCI_SEND;
 +	hdr->status = 0;
 +	hdr->req_id = ndev->req_id;
 +	hdr->reserved = 0;
 +	hdr->data_size = length;
 +
 +	memcpy(mei_buf + MEI_NFC_HEADER_SIZE, buf, length);
 +
 +	err = __mei_cl_send(ndev->cl, mei_buf, length + MEI_NFC_HEADER_SIZE);
 +	if (err < 0)
 +		return err;
 +
 +	kfree(mei_buf);
 +
 +	if (!wait_event_interruptible_timeout(ndev->send_wq,
 +				ndev->recv_req_id == ndev->req_id, HZ)) {
 +		dev_err(&dev->pdev->dev, "NFC MEI command timeout\n");
 +		err = -ETIME;
 +	} else {
 +		ndev->req_id++;
 +	}
 +
 +	return err;
 +}
 +
 +static int mei_nfc_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
 +{
 +	struct mei_nfc_dev *ndev;
 +	struct mei_nfc_hci_hdr *hci_hdr;
 +	int received_length;
 +
 +	ndev = (struct mei_nfc_dev *)cldev->priv_data;
 +
 +	received_length = __mei_cl_recv(ndev->cl, buf, length);
 +	if (received_length < 0)
 +		return received_length;
 +
 +	hci_hdr = (struct mei_nfc_hci_hdr *) buf;
 +
 +	if (hci_hdr->cmd == MEI_NFC_CMD_HCI_SEND) {
 +		ndev->recv_req_id = hci_hdr->req_id;
 +		wake_up(&ndev->send_wq);
 +
 +		return 0;
 +	}
 +
 +	return received_length;
 +}
 +
 +static struct mei_cl_ops nfc_ops = {
 +	.enable = mei_nfc_enable,
 +	.disable = mei_nfc_disable,
 +	.send = mei_nfc_send,
 +	.recv = mei_nfc_recv,
 +};
 +
 +static void mei_nfc_init(struct work_struct *work)
 +{
 +	struct mei_device *dev;
 +	struct mei_cl_device *cldev;
 +	struct mei_nfc_dev *ndev;
 +	struct mei_cl *cl_info;
 +
 +	ndev = container_of(work, struct mei_nfc_dev, init_work);
 +
 +	cl_info = ndev->cl_info;
 +	dev = cl_info->dev;
 +
 +	mutex_lock(&dev->device_lock);
 +
 +	if (mei_cl_connect(cl_info, NULL) < 0) {
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev,
 +			"Could not connect to the NFC INFO ME client");
 +
 +		goto err;
 +	}
 +
 +	mutex_unlock(&dev->device_lock);
 +
 +	if (mei_nfc_if_version(ndev) < 0) {
 +		dev_err(&dev->pdev->dev, "Could not get the NFC interface version");
 +
 +		goto err;
 +	}
 +
 +	dev_info(&dev->pdev->dev,
 +		"NFC MEI VERSION: IVN 0x%x Vendor ID 0x%x Type 0x%x\n",
 +		ndev->fw_ivn, ndev->vendor_id, ndev->radio_type);
 +
 +	mutex_lock(&dev->device_lock);
 +
 +	if (mei_cl_disconnect(cl_info) < 0) {
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev,
 +			"Could not disconnect the NFC INFO ME client");
 +
 +		goto err;
 +	}
 +
 +	mutex_unlock(&dev->device_lock);
 +
 +	if (mei_nfc_build_bus_name(ndev) < 0) {
 +		dev_err(&dev->pdev->dev,
 +			"Could not build the bus ID name\n");
 +		return;
 +	}
 +
 +	cldev = mei_cl_add_device(dev, mei_nfc_guid, ndev->bus_name, &nfc_ops);
 +	if (!cldev) {
 +		dev_err(&dev->pdev->dev,
 +			"Could not add the NFC device to the MEI bus\n");
 +
 +		goto err;
 +	}
 +
 +	cldev->priv_data = ndev;
 +
 +
 +	return;
 +
 +err:
 +	mutex_lock(&dev->device_lock);
 +	mei_nfc_free(ndev);
 +	mutex_unlock(&dev->device_lock);
 +
 +}
 +
 +
 +int mei_nfc_host_init(struct mei_device *dev)
  {
 +	struct mei_nfc_dev *ndev = &nfc_dev;
 +	struct mei_cl *cl_info, *cl = NULL;
 +	int i, ret;
 +
 +	/* already initialized */
 +	if (ndev->cl_info)
 +		return 0;
 +
 +	ndev->cl_info = mei_cl_allocate(dev);
 +	ndev->cl = mei_cl_allocate(dev);
  
 -	if (ver->vendor_id == MEI_NFC_VENDOR_INSIDE) {
 -		if (ver->radio_type == MEI_NFC_VENDOR_INSIDE_UREAD)
 -			return "microread";
 +	cl = ndev->cl;
 +	cl_info = ndev->cl_info;
 +
 +	if (!cl || !cl_info) {
 +		ret = -ENOMEM;
 +		goto err;
  	}
  
 -	if (ver->vendor_id == MEI_NFC_VENDOR_NXP) {
 -		if (ver->radio_type == MEI_NFC_VENDOR_NXP_PN544)
 -			return "pn544";
 +	/* check for valid client id */
 +	i = mei_me_cl_by_uuid(dev, &mei_nfc_info_guid);
 +	if (i < 0) {
 +		dev_info(&dev->pdev->dev, "nfc: failed to find the client\n");
 +		ret = -ENOTTY;
 +		goto err;
  	}
  
 -	return NULL;
 +	cl_info->me_client_id = dev->me_clients[i].client_id;
 +
 +	ret = mei_cl_link(cl_info, MEI_HOST_CLIENT_ID_ANY);
 +	if (ret)
 +		goto err;
 +
 +	cl_info->device_uuid = mei_nfc_info_guid;
 +
 +	list_add_tail(&cl_info->device_link, &dev->device_list);
 +
 +	/* check for valid client id */
 +	i = mei_me_cl_by_uuid(dev, &mei_nfc_guid);
 +	if (i < 0) {
 +		dev_info(&dev->pdev->dev, "nfc: failed to find the client\n");
 +		ret = -ENOTTY;
 +		goto err;
 +	}
 +
 +	cl->me_client_id = dev->me_clients[i].client_id;
 +
 +	ret = mei_cl_link(cl, MEI_HOST_CLIENT_ID_ANY);
 +	if (ret)
 +		goto err;
 +
 +	cl->device_uuid = mei_nfc_guid;
 +
 +
 +	list_add_tail(&cl->device_link, &dev->device_list);
 +
 +	ndev->req_id = 1;
 +
 +	INIT_WORK(&ndev->init_work, mei_nfc_init);
 +	init_waitqueue_head(&ndev->send_wq);
 +	schedule_work(&ndev->init_work);
 +
 +	return 0;
 +
 +err:
 +	mei_nfc_free(ndev);
 +
 +	return ret;
 +}
 +
 +void mei_nfc_host_exit(struct mei_device *dev)
 +{
 +	struct mei_nfc_dev *ndev = &nfc_dev;
 +	cancel_work_sync(&ndev->init_work);
  }
  
++=======
+ /**
+  * mei_nfc - The nfc fixup function. The function retrieves nfc radio
+  *    name and set is as device attribute so we can load
+  *    the proper device driver for it
+  *
+  * @cldev: me client device (nfc)
+  */
+ static void mei_nfc(struct mei_cl_device *cldev)
+ {
+ 	struct mei_device *bus;
+ 	struct mei_cl *cl;
+ 	struct mei_me_client *me_cl = NULL;
+ 	struct mei_nfc_if_version ver;
+ 	const char *radio_name = NULL;
+ 	int ret;
+ 
+ 	bus = cldev->bus;
+ 
+ 	dev_dbg(bus->dev, "running hook %s: %pUl match=%d\n",
+ 		__func__, mei_me_cl_uuid(cldev->me_cl), cldev->do_match);
+ 
+ 	mutex_lock(&bus->device_lock);
+ 	/* we need to connect to INFO GUID */
+ 	cl = mei_cl_alloc_linked(bus, MEI_HOST_CLIENT_ID_ANY);
+ 	if (IS_ERR(cl)) {
+ 		ret = PTR_ERR(cl);
+ 		cl = NULL;
+ 		dev_err(bus->dev, "nfc hook alloc failed %d\n", ret);
+ 		goto out;
+ 	}
+ 
+ 	me_cl = mei_me_cl_by_uuid(bus, &mei_nfc_info_guid);
+ 	if (!me_cl) {
+ 		ret = -ENOTTY;
+ 		dev_err(bus->dev, "Cannot find nfc info %d\n", ret);
+ 		goto out;
+ 	}
+ 
+ 	ret = mei_cl_connect(cl, me_cl, NULL);
+ 	if (ret < 0) {
+ 		dev_err(&cldev->dev, "Can't connect to the NFC INFO ME ret = %d\n",
+ 			ret);
+ 		goto out;
+ 	}
+ 
+ 	mutex_unlock(&bus->device_lock);
+ 
+ 	ret = mei_nfc_if_version(cl, &ver);
+ 	if (ret)
+ 		goto disconnect;
+ 
+ 	radio_name = mei_nfc_radio_name(&ver);
+ 
+ 	if (!radio_name) {
+ 		ret = -ENOENT;
+ 		dev_err(&cldev->dev, "Can't get the NFC interface version ret = %d\n",
+ 			ret);
+ 		goto disconnect;
+ 	}
+ 
+ 	dev_dbg(bus->dev, "nfc radio %s\n", radio_name);
+ 	strlcpy(cldev->name, radio_name, sizeof(cldev->name));
+ 
+ disconnect:
+ 	mutex_lock(&bus->device_lock);
+ 	if (mei_cl_disconnect(cl) < 0)
+ 		dev_err(bus->dev, "Can't disconnect the NFC INFO ME\n");
+ 
+ 	mei_cl_flush_queues(cl, NULL);
+ 
+ out:
+ 	mei_cl_unlink(cl);
+ 	mutex_unlock(&bus->device_lock);
+ 	mei_me_cl_put(me_cl);
+ 	kfree(cl);
+ 
+ 	if (ret)
+ 		cldev->do_match = 0;
+ 
+ 	dev_dbg(bus->dev, "end of fixup match = %d\n", cldev->do_match);
+ }
+ 
+ #define MEI_FIXUP(_uuid, _hook) { _uuid, _hook }
+ 
+ static struct mei_fixup {
+ 
+ 	const uuid_le uuid;
+ 	void (*hook)(struct mei_cl_device *cldev);
+ } mei_fixups[] = {
+ 	MEI_FIXUP(MEI_UUID_ANY, number_of_connections),
+ 	MEI_FIXUP(MEI_UUID_NFC_INFO, blacklist),
+ 	MEI_FIXUP(MEI_UUID_NFC_HCI, mei_nfc),
+ };
+ 
+ /**
+  * mei_cl_dev_fixup - run fixup handlers
+  *
+  * @cldev: me client device
+  */
+ void mei_cl_dev_fixup(struct mei_cl_device *cldev)
+ {
+ 	struct mei_fixup *f;
+ 	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(mei_fixups); i++) {
+ 
+ 		f = &mei_fixups[i];
+ 		if (uuid_le_cmp(f->uuid, MEI_UUID_ANY) == 0 ||
+ 		    uuid_le_cmp(f->uuid, *uuid) == 0)
+ 			f->hook(cldev);
+ 	}
+ }
++>>>>>>> 6009595a66e4 (mei: bus: link client devices instead of host clients)
  
diff --cc drivers/misc/mei/bus.c
index 3365981198e7,3ab08e522fb8..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -31,23 -30,400 +31,404 @@@
  #define to_mei_cl_driver(d) container_of(d, struct mei_cl_driver, driver)
  #define to_mei_cl_device(d) container_of(d, struct mei_cl_device, dev)
  
++<<<<<<< HEAD
 +static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
++=======
+ /**
+  * __mei_cl_send - internal client send (write)
+  *
+  * @cl: host client
+  * @buf: buffer to send
+  * @length: buffer length
+  * @blocking: wait for write completion
+  *
+  * Return: written size bytes or < 0 on error
+  */
+ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
+ 			bool blocking)
+ {
+ 	struct mei_device *bus;
+ 	struct mei_cl_cb *cb = NULL;
+ 	ssize_t rets;
+ 
+ 	if (WARN_ON(!cl || !cl->dev))
+ 		return -ENODEV;
+ 
+ 	bus = cl->dev;
+ 
+ 	mutex_lock(&bus->device_lock);
+ 	if (!mei_cl_is_connected(cl)) {
+ 		rets = -ENODEV;
+ 		goto out;
+ 	}
+ 
+ 	/* Check if we have an ME client device */
+ 	if (!mei_me_cl_is_active(cl->me_cl)) {
+ 		rets = -ENOTTY;
+ 		goto out;
+ 	}
+ 
+ 	if (length > mei_cl_mtu(cl)) {
+ 		rets = -EFBIG;
+ 		goto out;
+ 	}
+ 
+ 	cb = mei_cl_alloc_cb(cl, length, MEI_FOP_WRITE, NULL);
+ 	if (!cb) {
+ 		rets = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	memcpy(cb->buf.data, buf, length);
+ 
+ 	rets = mei_cl_write(cl, cb, blocking);
+ 
+ out:
+ 	mutex_unlock(&bus->device_lock);
+ 	if (rets < 0)
+ 		mei_io_cb_free(cb);
+ 
+ 	return rets;
+ }
+ 
+ /**
+  * __mei_cl_recv - internal client receive (read)
+  *
+  * @cl: host client
+  * @buf: buffer to send
+  * @length: buffer length
+  *
+  * Return: read size in bytes of < 0 on error
+  */
+ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
+ {
+ 	struct mei_device *bus;
+ 	struct mei_cl_cb *cb;
+ 	size_t r_length;
+ 	ssize_t rets;
+ 
+ 	if (WARN_ON(!cl || !cl->dev))
+ 		return -ENODEV;
+ 
+ 	bus = cl->dev;
+ 
+ 	mutex_lock(&bus->device_lock);
+ 
+ 	cb = mei_cl_read_cb(cl, NULL);
+ 	if (cb)
+ 		goto copy;
+ 
+ 	rets = mei_cl_read_start(cl, length, NULL);
+ 	if (rets && rets != -EBUSY)
+ 		goto out;
+ 
+ 	/* wait on event only if there is no other waiter */
+ 	if (list_empty(&cl->rd_completed) && !waitqueue_active(&cl->rx_wait)) {
+ 
+ 		mutex_unlock(&bus->device_lock);
+ 
+ 		if (wait_event_interruptible(cl->rx_wait,
+ 				(!list_empty(&cl->rd_completed)) ||
+ 				(!mei_cl_is_connected(cl)))) {
+ 
+ 			if (signal_pending(current))
+ 				return -EINTR;
+ 			return -ERESTARTSYS;
+ 		}
+ 
+ 		mutex_lock(&bus->device_lock);
+ 
+ 		if (!mei_cl_is_connected(cl)) {
+ 			rets = -EBUSY;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	cb = mei_cl_read_cb(cl, NULL);
+ 	if (!cb) {
+ 		rets = 0;
+ 		goto out;
+ 	}
+ 
+ copy:
+ 	if (cb->status) {
+ 		rets = cb->status;
+ 		goto free;
+ 	}
+ 
+ 	r_length = min_t(size_t, length, cb->buf_idx);
+ 	memcpy(buf, cb->buf.data, r_length);
+ 	rets = r_length;
+ 
+ free:
+ 	mei_io_cb_free(cb);
+ out:
+ 	mutex_unlock(&bus->device_lock);
+ 
+ 	return rets;
+ }
+ 
+ /**
+  * mei_cl_send - me device send  (write)
+  *
+  * @cldev: me client device
+  * @buf: buffer to send
+  * @length: buffer length
+  *
+  * Return: written size in bytes or < 0 on error
+  */
+ ssize_t mei_cl_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
+ {
+ 	struct mei_cl *cl = cldev->cl;
+ 
+ 	if (cl == NULL)
+ 		return -ENODEV;
+ 
+ 	return __mei_cl_send(cl, buf, length, 1);
+ }
+ EXPORT_SYMBOL_GPL(mei_cl_send);
+ 
+ /**
+  * mei_cl_recv - client receive (read)
+  *
+  * @cldev: me client device
+  * @buf: buffer to send
+  * @length: buffer length
+  *
+  * Return: read size in bytes of < 0 on error
+  */
+ ssize_t mei_cl_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
+ {
+ 	struct mei_cl *cl = cldev->cl;
+ 
+ 	if (cl == NULL)
+ 		return -ENODEV;
+ 
+ 	return __mei_cl_recv(cl, buf, length);
+ }
+ EXPORT_SYMBOL_GPL(mei_cl_recv);
+ 
+ /**
+  * mei_bus_event_work  - dispatch rx event for a bus device
+  *    and schedule new work
+  *
+  * @work: work
+  */
+ static void mei_bus_event_work(struct work_struct *work)
+ {
+ 	struct mei_cl_device *cldev;
+ 
+ 	cldev = container_of(work, struct mei_cl_device, event_work);
+ 
+ 	if (cldev->event_cb)
+ 		cldev->event_cb(cldev, cldev->events, cldev->event_context);
+ 
+ 	cldev->events = 0;
+ 
+ 	/* Prepare for the next read */
+ 	mei_cl_read_start(cldev->cl, 0, NULL);
+ }
+ 
+ /**
+  * mei_cl_bus_rx_event  - schedule rx evenet
+  *
+  * @cl: host client
+  */
+ void mei_cl_bus_rx_event(struct mei_cl *cl)
+ {
+ 	struct mei_cl_device *cldev = cl->cldev;
+ 
+ 	if (!cldev || !cldev->event_cb)
+ 		return;
+ 
+ 	set_bit(MEI_CL_EVENT_RX, &cldev->events);
+ 
+ 	schedule_work(&cldev->event_work);
+ }
+ 
+ /**
+  * mei_cl_register_event_cb - register event callback
+  *
+  * @cldev: me client devices
+  * @event_cb: callback function
+  * @context: driver context data
+  *
+  * Return: 0 on success
+  *         -EALREADY if an callback is already registered
+  *         <0 on other errors
+  */
+ int mei_cl_register_event_cb(struct mei_cl_device *cldev,
+ 			  mei_cl_event_cb_t event_cb, void *context)
+ {
+ 	int ret;
+ 
+ 	if (cldev->event_cb)
+ 		return -EALREADY;
+ 
+ 	cldev->events = 0;
+ 	cldev->event_cb = event_cb;
+ 	cldev->event_context = context;
+ 	INIT_WORK(&cldev->event_work, mei_bus_event_work);
+ 
+ 	ret = mei_cl_read_start(cldev->cl, 0, NULL);
+ 	if (ret && ret != -EBUSY)
+ 		return ret;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(mei_cl_register_event_cb);
+ 
+ /**
+  * mei_cl_get_drvdata - driver data getter
+  *
+  * @cldev: mei client device
+  *
+  * Return: driver private data
+  */
+ void *mei_cl_get_drvdata(const struct mei_cl_device *cldev)
+ {
+ 	return dev_get_drvdata(&cldev->dev);
+ }
+ EXPORT_SYMBOL_GPL(mei_cl_get_drvdata);
+ 
+ /**
+  * mei_cl_set_drvdata - driver data setter
+  *
+  * @cldev: mei client device
+  * @data: data to store
+  */
+ void mei_cl_set_drvdata(struct mei_cl_device *cldev, void *data)
+ {
+ 	dev_set_drvdata(&cldev->dev, data);
+ }
+ EXPORT_SYMBOL_GPL(mei_cl_set_drvdata);
+ 
+ /**
+  * mei_cl_enable_device - enable me client device
+  *     create connection with me client
+  *
+  * @cldev: me client device
+  *
+  * Return: 0 on success and < 0 on error
+  */
+ int mei_cl_enable_device(struct mei_cl_device *cldev)
+ {
+ 	struct mei_device *bus = cldev->bus;
+ 	struct mei_cl *cl;
+ 	int ret;
+ 
+ 	cl = cldev->cl;
+ 
+ 	if (!cl) {
+ 		mutex_lock(&bus->device_lock);
+ 		cl = mei_cl_alloc_linked(bus, MEI_HOST_CLIENT_ID_ANY);
+ 		mutex_unlock(&bus->device_lock);
+ 		if (IS_ERR(cl))
+ 			return PTR_ERR(cl);
+ 		/* update pointers */
+ 		cldev->cl = cl;
+ 		cl->cldev = cldev;
+ 	}
+ 
+ 	mutex_lock(&bus->device_lock);
+ 	if (mei_cl_is_connected(cl)) {
+ 		ret = 0;
+ 		goto out;
+ 	}
+ 
+ 	if (!mei_me_cl_is_active(cldev->me_cl)) {
+ 		dev_err(&cldev->dev, "me client is not active\n");
+ 		ret = -ENOTTY;
+ 		goto out;
+ 	}
+ 
+ 	ret = mei_cl_connect(cl, cldev->me_cl, NULL);
+ 	if (ret < 0)
+ 		dev_err(&cldev->dev, "cannot connect\n");
+ 
+ out:
+ 	mutex_unlock(&bus->device_lock);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(mei_cl_enable_device);
+ 
+ /**
+  * mei_cl_disable_device - disable me client device
+  *     disconnect form the me client
+  *
+  * @cldev: me client device
+  *
+  * Return: 0 on success and < 0 on error
+  */
+ int mei_cl_disable_device(struct mei_cl_device *cldev)
+ {
+ 	struct mei_device *bus;
+ 	struct mei_cl *cl;
+ 	int err;
+ 
+ 	if (!cldev || !cldev->cl)
+ 		return -ENODEV;
+ 
+ 	cl = cldev->cl;
+ 
+ 	bus = cldev->bus;
+ 
+ 	cldev->event_cb = NULL;
+ 
+ 	mutex_lock(&bus->device_lock);
+ 
+ 	if (!mei_cl_is_connected(cl)) {
+ 		dev_err(bus->dev, "Already disconnected");
+ 		err = 0;
+ 		goto out;
+ 	}
+ 
+ 	err = mei_cl_disconnect(cl);
+ 	if (err < 0)
+ 		dev_err(bus->dev, "Could not disconnect from the ME client");
+ 
+ out:
+ 	/* Flush queues and remove any pending read */
+ 	mei_cl_flush_queues(cl, NULL);
+ 	mei_cl_unlink(cl);
+ 
+ 	kfree(cl);
+ 	cldev->cl = NULL;
+ 
+ 	mutex_unlock(&bus->device_lock);
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(mei_cl_disable_device);
+ 
+ /**
+  * mei_cl_device_find - find matching entry in the driver id table
+  *
+  * @cldev: me client device
+  * @cldrv: me client driver
+  *
+  * Return: id on success; NULL if no id is matching
+  */
+ static const
+ struct mei_cl_device_id *mei_cl_device_find(struct mei_cl_device *cldev,
+ 					    struct mei_cl_driver *cldrv)
++>>>>>>> 6009595a66e4 (mei: bus: link client devices instead of host clients)
  {
 +	struct mei_cl_device *device = to_mei_cl_device(dev);
 +	struct mei_cl_driver *driver = to_mei_cl_driver(drv);
  	const struct mei_cl_device_id *id;
 -	const uuid_le *uuid;
  
 -	uuid = mei_me_cl_uuid(cldev->me_cl);
 +	if (!device)
 +		return 0;
  
 -	id = cldrv->id_table;
 -	while (uuid_le_cmp(NULL_UUID_LE, id->uuid)) {
 -		if (!uuid_le_cmp(*uuid, id->uuid)) {
 +	if (!driver || !driver->id_table)
 +		return 0;
  
 -			if (!cldev->name[0])
 -				return id;
 +	id = driver->id_table;
  
 -			if (!strncmp(cldev->name, id->name, sizeof(id->name)))
 -				return id;
 -		}
 +	while (id->name[0]) {
 +		if (!strncmp(dev_name(dev), id->name, sizeof(id->name)))
 +			return 1;
  
  		id++;
  	}
@@@ -140,74 -605,229 +521,266 @@@ static struct bus_type mei_cl_bus_type 
  	.uevent		= mei_cl_device_uevent,
  };
  
 -static struct mei_device *mei_dev_bus_get(struct mei_device *bus)
 +static void mei_cl_dev_release(struct device *dev)
  {
 -	if (bus)
 -		get_device(bus->dev);
 -
 -	return bus;
 +	kfree(to_mei_cl_device(dev));
  }
  
 -static void mei_dev_bus_put(struct mei_device *bus)
 -{
 -	if (bus)
 -		put_device(bus->dev);
 -}
 +static struct device_type mei_cl_device_type = {
 +	.release	= mei_cl_dev_release,
 +};
  
 -static void mei_cl_dev_release(struct device *dev)
++<<<<<<< HEAD
 +static struct mei_cl *mei_bus_find_mei_cl_by_uuid(struct mei_device *dev,
 +						uuid_le uuid)
  {
 -	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 +	struct mei_cl *cl;
  
 -	if (!cldev)
 -		return;
 +	list_for_each_entry(cl, &dev->device_list, device_link) {
 +		if (!uuid_le_cmp(uuid, cl->device_uuid))
 +			return cl;
 +	}
  
 -	mei_me_cl_put(cldev->me_cl);
 -	mei_dev_bus_put(cldev->bus);
 -	kfree(cldev);
 +	return NULL;
  }
 +struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops)
 +{
 +	struct mei_cl_device *device;
 +	struct mei_cl *cl;
 +	int status;
  
 -static struct device_type mei_cl_device_type = {
 -	.release	= mei_cl_dev_release,
 -};
 +	cl = mei_bus_find_mei_cl_by_uuid(dev, uuid);
 +	if (cl == NULL)
 +		return NULL;
 +
 +	device = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
 +	if (!device)
 +		return NULL;
 +
 +	device->cl = cl;
 +	device->ops = ops;
 +
 +	device->dev.parent = &dev->pdev->dev;
 +	device->dev.bus = &mei_cl_bus_type;
 +	device->dev.type = &mei_cl_device_type;
 +
 +	dev_set_name(&device->dev, "%s", name);
 +
 +	status = device_register(&device->dev);
 +	if (status) {
 +		dev_err(&dev->pdev->dev, "Failed to register MEI device\n");
 +		kfree(device);
 +		return NULL;
 +	}
 +
 +	cl->device = device;
  
 +	dev_dbg(&device->dev, "client %s registered\n", name);
 +
 +	return device;
++=======
+ /**
+  * mei_cl_dev_alloc - initialize and allocate mei client device
+  *
+  * @bus: mei device
+  * @me_cl: me client
+  *
+  * Return: allocated device structur or NULL on allocation failure
+  */
+ static struct mei_cl_device *mei_cl_dev_alloc(struct mei_device *bus,
+ 					      struct mei_me_client *me_cl)
+ {
+ 	struct mei_cl_device *cldev;
+ 
+ 	cldev = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
+ 	if (!cldev)
+ 		return NULL;
+ 
+ 	device_initialize(&cldev->dev);
+ 	cldev->dev.parent = bus->dev;
+ 	cldev->dev.bus    = &mei_cl_bus_type;
+ 	cldev->dev.type   = &mei_cl_device_type;
+ 	cldev->bus        = mei_dev_bus_get(bus);
+ 	cldev->me_cl      = mei_me_cl_get(me_cl);
+ 	cldev->is_added   = 0;
+ 	INIT_LIST_HEAD(&cldev->bus_list);
+ 
+ 	return cldev;
  }
- EXPORT_SYMBOL_GPL(mei_cl_add_device);
  
+ /**
+  * mei_cl_dev_setup - setup me client device
+  *    run fix up routines and set the device name
+  *
+  * @bus: mei device
+  * @cldev: me client device
+  *
+  * Return: true if the device is eligible for enumeration
+  */
+ static bool mei_cl_dev_setup(struct mei_device *bus,
+ 			     struct mei_cl_device *cldev)
+ {
+ 	cldev->do_match = 1;
+ 	mei_cl_dev_fixup(cldev);
+ 
+ 	if (cldev->do_match)
+ 		dev_set_name(&cldev->dev, "mei:%s:%pUl",
+ 			     cldev->name, mei_me_cl_uuid(cldev->me_cl));
+ 
+ 	return cldev->do_match == 1;
+ }
+ 
+ /**
+  * mei_cl_bus_dev_add - add me client devices
+  *
+  * @cldev: me client device
+  *
+  * Return: 0 on success; < 0 on failre
+  */
+ static int mei_cl_bus_dev_add(struct mei_cl_device *cldev)
+ {
+ 	int ret;
+ 
+ 	dev_dbg(cldev->bus->dev, "adding %pUL\n", mei_me_cl_uuid(cldev->me_cl));
+ 	ret = device_add(&cldev->dev);
+ 	if (!ret)
+ 		cldev->is_added = 1;
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * mei_cl_bus_dev_stop - stop the driver
+  *
+  * @cldev: me client device
+  */
+ static void mei_cl_bus_dev_stop(struct mei_cl_device *cldev)
+ {
+ 	if (cldev->is_added)
+ 		device_release_driver(&cldev->dev);
+ }
+ 
+ /**
+  * mei_cl_bus_dev_destroy - destroy me client devices object
+  *
+  * @cldev: me client device
+  */
+ static void mei_cl_bus_dev_destroy(struct mei_cl_device *cldev)
+ {
+ 	if (!cldev->is_added)
+ 		return;
+ 
+ 	device_del(&cldev->dev);
+ 
+ 	mutex_lock(&cldev->bus->cl_bus_lock);
+ 	list_del_init(&cldev->bus_list);
+ 	mutex_unlock(&cldev->bus->cl_bus_lock);
+ 
+ 	cldev->is_added = 0;
+ 	put_device(&cldev->dev);
+ }
+ 
+ /**
+  * mei_cl_bus_remove_device - remove a devices form the bus
+  *
+  * @cldev: me client device
+  */
+ static void mei_cl_bus_remove_device(struct mei_cl_device *cldev)
+ {
+ 	mei_cl_bus_dev_stop(cldev);
+ 	mei_cl_bus_dev_destroy(cldev);
+ }
+ 
+ /**
+  * mei_cl_bus_remove_devices - remove all devices form the bus
+  *
+  * @bus: mei device
+  */
+ void mei_cl_bus_remove_devices(struct mei_device *bus)
+ {
+ 	struct mei_cl_device *cldev, *next;
+ 
+ 	list_for_each_entry_safe(cldev, next, &bus->device_list, bus_list)
+ 		mei_cl_bus_remove_device(cldev);
+ }
+ 
+ 
+ /**
+  * mei_cl_dev_init - allocate and initializes an mei client devices
+  *     based on me client
+  *
+  * @bus: mei device
+  * @me_cl: me client
+  */
+ static void mei_cl_dev_init(struct mei_device *bus, struct mei_me_client *me_cl)
+ {
+ 	struct mei_cl_device *cldev;
+ 
+ 	dev_dbg(bus->dev, "initializing %pUl", mei_me_cl_uuid(me_cl));
+ 
+ 	if (me_cl->bus_added)
+ 		return;
+ 
+ 	cldev = mei_cl_dev_alloc(bus, me_cl);
+ 	if (!cldev)
+ 		return;
+ 
+ 	mutex_lock(&cldev->bus->cl_bus_lock);
+ 	me_cl->bus_added = true;
+ 	list_add_tail(&cldev->bus_list, &bus->device_list);
+ 	mutex_unlock(&cldev->bus->cl_bus_lock);
+ 
++>>>>>>> 6009595a66e4 (mei: bus: link client devices instead of host clients)
+ }
+ 
++<<<<<<< HEAD
 +void mei_cl_remove_device(struct mei_cl_device *device)
 +{
 +	device_unregister(&device->dev);
++=======
+ /**
+  * mei_cl_bus_rescan - scan me clients list and add create
+  *    devices for eligible clients
+  *
+  * @bus: mei device
+  */
+ void mei_cl_bus_rescan(struct mei_device *bus)
+ {
+ 	struct mei_cl_device *cldev, *n;
+ 	struct mei_me_client *me_cl;
+ 
+ 	down_read(&bus->me_clients_rwsem);
+ 	list_for_each_entry(me_cl, &bus->me_clients, list)
+ 		mei_cl_dev_init(bus, me_cl);
+ 	up_read(&bus->me_clients_rwsem);
+ 
+ 	mutex_lock(&bus->cl_bus_lock);
+ 	list_for_each_entry_safe(cldev, n, &bus->device_list, bus_list) {
+ 
+ 		if (!mei_me_cl_is_active(cldev->me_cl)) {
+ 			mei_cl_bus_remove_device(cldev);
+ 			continue;
+ 		}
+ 
+ 		if (cldev->is_added)
+ 			continue;
+ 
+ 		if (mei_cl_dev_setup(bus, cldev))
+ 			mei_cl_bus_dev_add(cldev);
+ 		else {
+ 			list_del_init(&cldev->bus_list);
+ 			put_device(&cldev->dev);
+ 		}
+ 	}
+ 	mutex_unlock(&bus->cl_bus_lock);
+ 
+ 	dev_dbg(bus->dev, "rescan end");
++>>>>>>> 6009595a66e4 (mei: bus: link client devices instead of host clients)
  }
- EXPORT_SYMBOL_GPL(mei_cl_remove_device);
  
 -int __mei_cl_driver_register(struct mei_cl_driver *cldrv, struct module *owner)
 +int __mei_cl_driver_register(struct mei_cl_driver *driver, struct module *owner)
  {
  	int err;
  
@@@ -233,317 -853,6 +806,320 @@@ void mei_cl_driver_unregister(struct me
  }
  EXPORT_SYMBOL_GPL(mei_cl_driver_unregister);
  
++<<<<<<< HEAD
 +static int ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 +			bool blocking)
 +{
 +	struct mei_device *dev;
 +	struct mei_cl_cb *cb;
 +	int id;
 +	int rets;
 +
 +	if (WARN_ON(!cl || !cl->dev))
 +		return -ENODEV;
 +
 +	dev = cl->dev;
 +
 +	if (cl->state != MEI_FILE_CONNECTED)
 +		return -ENODEV;
 +
 +	/* Check if we have an ME client device */
 +	id = mei_me_cl_by_id(dev, cl->me_client_id);
 +	if (id < 0)
 +		return id;
 +
 +	if (length > dev->me_clients[id].props.max_msg_length)
 +		return -EINVAL;
 +
 +	cb = mei_io_cb_init(cl, NULL);
 +	if (!cb)
 +		return -ENOMEM;
 +
 +	rets = mei_io_cb_alloc_req_buf(cb, length);
 +	if (rets < 0) {
 +		mei_io_cb_free(cb);
 +		return rets;
 +	}
 +
 +	memcpy(cb->request_buffer.data, buf, length);
 +
 +	mutex_lock(&dev->device_lock);
 +
 +	rets = mei_cl_write(cl, cb, blocking);
 +
 +	mutex_unlock(&dev->device_lock);
 +	if (rets < 0)
 +		mei_io_cb_free(cb);
 +
 +	return rets;
 +}
 +
 +int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 +{
 +	struct mei_device *dev;
 +	struct mei_cl_cb *cb;
 +	size_t r_length;
 +	int err;
 +
 +	if (WARN_ON(!cl || !cl->dev))
 +		return -ENODEV;
 +
 +	dev = cl->dev;
 +
 +	mutex_lock(&dev->device_lock);
 +
 +	if (!cl->read_cb) {
 +		err = mei_cl_read_start(cl, length);
 +		if (err < 0) {
 +			mutex_unlock(&dev->device_lock);
 +			return err;
 +		}
 +	}
 +
 +	if (cl->reading_state != MEI_READ_COMPLETE &&
 +	    !waitqueue_active(&cl->rx_wait)) {
 +
 +		mutex_unlock(&dev->device_lock);
 +
 +		if (wait_event_interruptible(cl->rx_wait,
 +				cl->reading_state == MEI_READ_COMPLETE  ||
 +				mei_cl_is_transitioning(cl))) {
 +
 +			if (signal_pending(current))
 +				return -EINTR;
 +			return -ERESTARTSYS;
 +		}
 +
 +		mutex_lock(&dev->device_lock);
 +	}
 +
 +	cb = cl->read_cb;
 +
 +	if (cl->reading_state != MEI_READ_COMPLETE) {
 +		r_length = 0;
 +		goto out;
 +	}
 +
 +	r_length = min_t(size_t, length, cb->buf_idx);
 +
 +	memcpy(buf, cb->response_buffer.data, r_length);
 +
 +	mei_io_cb_free(cb);
 +	cl->reading_state = MEI_IDLE;
 +	cl->read_cb = NULL;
 +
 +out:
 +	mutex_unlock(&dev->device_lock);
 +
 +	return r_length;
 +}
 +
 +inline int __mei_cl_async_send(struct mei_cl *cl, u8 *buf, size_t length)
 +{
 +	return ___mei_cl_send(cl, buf, length, 0);
 +}
 +
 +inline int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length)
 +{
 +	return ___mei_cl_send(cl, buf, length, 1);
 +}
 +
 +int mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
 +{
 +	struct mei_cl *cl = device->cl;
 +
 +	if (cl == NULL)
 +		return -ENODEV;
 +
 +	if (device->ops && device->ops->send)
 +		return device->ops->send(device, buf, length);
 +
 +	return __mei_cl_send(cl, buf, length);
 +}
 +EXPORT_SYMBOL_GPL(mei_cl_send);
 +
 +int mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length)
 +{
 +	struct mei_cl *cl =  device->cl;
 +
 +	if (cl == NULL)
 +		return -ENODEV;
 +
 +	if (device->ops && device->ops->recv)
 +		return device->ops->recv(device, buf, length);
 +
 +	return __mei_cl_recv(cl, buf, length);
 +}
 +EXPORT_SYMBOL_GPL(mei_cl_recv);
 +
 +static void mei_bus_event_work(struct work_struct *work)
 +{
 +	struct mei_cl_device *device;
 +
 +	device = container_of(work, struct mei_cl_device, event_work);
 +
 +	if (device->event_cb)
 +		device->event_cb(device, device->events, device->event_context);
 +
 +	device->events = 0;
 +
 +	/* Prepare for the next read */
 +	mei_cl_read_start(device->cl, 0);
 +}
 +
 +int mei_cl_register_event_cb(struct mei_cl_device *device,
 +			  mei_cl_event_cb_t event_cb, void *context)
 +{
 +	if (device->event_cb)
 +		return -EALREADY;
 +
 +	device->events = 0;
 +	device->event_cb = event_cb;
 +	device->event_context = context;
 +	INIT_WORK(&device->event_work, mei_bus_event_work);
 +
 +	mei_cl_read_start(device->cl, 0);
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(mei_cl_register_event_cb);
 +
 +void *mei_cl_get_drvdata(const struct mei_cl_device *device)
 +{
 +	return dev_get_drvdata(&device->dev);
 +}
 +EXPORT_SYMBOL_GPL(mei_cl_get_drvdata);
 +
 +void mei_cl_set_drvdata(struct mei_cl_device *device, void *data)
 +{
 +	dev_set_drvdata(&device->dev, data);
 +}
 +EXPORT_SYMBOL_GPL(mei_cl_set_drvdata);
 +
 +int mei_cl_enable_device(struct mei_cl_device *device)
 +{
 +	int err;
 +	struct mei_device *dev;
 +	struct mei_cl *cl = device->cl;
 +
 +	if (cl == NULL)
 +		return -ENODEV;
 +
 +	dev = cl->dev;
 +
 +	mutex_lock(&dev->device_lock);
 +
 +	err = mei_cl_connect(cl, NULL);
 +	if (err < 0) {
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev, "Could not connect to the ME client");
 +
 +		return err;
 +	}
 +
 +	mutex_unlock(&dev->device_lock);
 +
 +	if (device->event_cb && !cl->read_cb)
 +		mei_cl_read_start(device->cl, 0);
 +
 +	if (!device->ops || !device->ops->enable)
 +		return 0;
 +
 +	return device->ops->enable(device);
 +}
 +EXPORT_SYMBOL_GPL(mei_cl_enable_device);
 +
 +int mei_cl_disable_device(struct mei_cl_device *device)
 +{
 +	int err;
 +	struct mei_device *dev;
 +	struct mei_cl *cl = device->cl;
 +
 +	if (cl == NULL)
 +		return -ENODEV;
 +
 +	dev = cl->dev;
 +
 +	mutex_lock(&dev->device_lock);
 +
 +	if (cl->state != MEI_FILE_CONNECTED) {
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev, "Already disconnected");
 +
 +		return 0;
 +	}
 +
 +	cl->state = MEI_FILE_DISCONNECTING;
 +
 +	err = mei_cl_disconnect(cl);
 +	if (err < 0) {
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev,
 +			"Could not disconnect from the ME client");
 +
 +		return err;
 +	}
 +
 +	/* Flush queues and remove any pending read */
 +	mei_cl_flush_queues(cl);
 +
 +	if (cl->read_cb) {
 +		struct mei_cl_cb *cb = NULL;
 +
 +		cb = mei_cl_find_read_cb(cl);
 +		/* Remove entry from read list */
 +		if (cb)
 +			list_del(&cb->list);
 +
 +		cb = cl->read_cb;
 +		cl->read_cb = NULL;
 +
 +		if (cb) {
 +			mei_io_cb_free(cb);
 +			cb = NULL;
 +		}
 +	}
 +
 +	device->event_cb = NULL;
 +
 +	mutex_unlock(&dev->device_lock);
 +
 +	if (!device->ops || !device->ops->disable)
 +		return 0;
 +
 +	return device->ops->disable(device);
 +}
 +EXPORT_SYMBOL_GPL(mei_cl_disable_device);
 +
 +void mei_cl_bus_rx_event(struct mei_cl *cl)
 +{
 +	struct mei_cl_device *device = cl->device;
 +
 +	if (!device || !device->event_cb)
 +		return;
 +
 +	set_bit(MEI_CL_EVENT_RX, &device->events);
 +
 +	schedule_work(&device->event_work);
 +}
 +
 +void mei_cl_bus_remove_devices(struct mei_device *dev)
 +{
 +	struct mei_cl *cl, *next;
 +
 +	mutex_lock(&dev->device_lock);
 +	list_for_each_entry_safe(cl, next, &dev->device_list, device_link) {
 +		if (cl->device)
 +			mei_cl_remove_device(cl->device);
 +
 +		list_del(&cl->device_link);
 +		mei_cl_unlink(cl);
 +		kfree(cl);
 +	}
 +	mutex_unlock(&dev->device_lock);
 +}
++=======
++>>>>>>> 6009595a66e4 (mei: bus: link client devices instead of host clients)
  
  int __init mei_cl_bus_init(void)
  {
diff --cc drivers/misc/mei/client.c
index 3c539de435ba,9dacea7a9a60..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -262,10 -555,11 +262,13 @@@ void mei_cl_init(struct mei_cl *cl, str
  	init_waitqueue_head(&cl->wait);
  	init_waitqueue_head(&cl->rx_wait);
  	init_waitqueue_head(&cl->tx_wait);
 -	INIT_LIST_HEAD(&cl->rd_completed);
 -	INIT_LIST_HEAD(&cl->rd_pending);
  	INIT_LIST_HEAD(&cl->link);
++<<<<<<< HEAD
 +	INIT_LIST_HEAD(&cl->device_link);
 +	cl->reading_state = MEI_IDLE;
++=======
++>>>>>>> 6009595a66e4 (mei: bus: link client devices instead of host clients)
  	cl->writing_state = MEI_IDLE;
 -	cl->state = MEI_FILE_INITIALIZING;
  	cl->dev = dev;
  }
  
@@@ -401,26 -678,26 +404,46 @@@ void mei_host_client_init(struct work_s
  
  	mutex_lock(&dev->device_lock);
  
 +	for (i = 0; i < dev->me_clients_num; i++) {
 +		client_props = &dev->me_clients[i].props;
  
++<<<<<<< HEAD
 +		if (!uuid_le_cmp(client_props->protocol_name, mei_amthif_guid))
 +			mei_amthif_host_init(dev);
 +		else if (!uuid_le_cmp(client_props->protocol_name, mei_wd_guid))
 +			mei_wd_host_init(dev);
 +		else if (!uuid_le_cmp(client_props->protocol_name, mei_nfc_guid))
 +			mei_nfc_host_init(dev);
 +
 +	}
++=======
+ 	me_cl = mei_me_cl_by_uuid(dev, &mei_amthif_guid);
+ 	if (me_cl)
+ 		mei_amthif_host_init(dev, me_cl);
+ 	mei_me_cl_put(me_cl);
+ 
+ 	me_cl = mei_me_cl_by_uuid(dev, &mei_wd_guid);
+ 	if (me_cl)
+ 		mei_wd_host_init(dev, me_cl);
+ 	mei_me_cl_put(me_cl);
++>>>>>>> 6009595a66e4 (mei: bus: link client devices instead of host clients)
  
  	dev->dev_state = MEI_DEV_ENABLED;
  	dev->reset_count = 0;
 +
  	mutex_unlock(&dev->device_lock);
  
++<<<<<<< HEAD
 +	pm_runtime_mark_last_busy(&dev->pdev->dev);
 +	dev_dbg(&dev->pdev->dev, "rpm: autosuspend\n");
 +	pm_runtime_autosuspend(&dev->pdev->dev);
++=======
+ 	mei_cl_bus_rescan(dev);
+ 
+ 	pm_runtime_mark_last_busy(dev->dev);
+ 	dev_dbg(dev->dev, "rpm: autosuspend\n");
+ 	pm_runtime_autosuspend(dev->dev);
++>>>>>>> 6009595a66e4 (mei: bus: link client devices instead of host clients)
  }
  
  /**
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,71c55f4cabb4..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -201,10 -215,33 +201,35 @@@ struct mei_cl_cb 
  	unsigned long buf_idx;
  	unsigned long read_time;
  	struct file *file_object;
 -	int status;
  	u32 internal:1;
 -	u32 completed:1;
  };
  
++<<<<<<< HEAD
 +/* MEI client instance carried as file->private_data*/
++=======
+ /**
+  * struct mei_cl - me client host representation
+  *    carried in file->private_data
+  *
+  * @link: link in the clients list
+  * @dev: mei parent device
+  * @state: file operation state
+  * @tx_wait: wait queue for tx completion
+  * @rx_wait: wait queue for rx completion
+  * @wait:  wait queue for management operation
+  * @status: connection status
+  * @me_cl: fw client connected
+  * @host_client_id: host id
+  * @mei_flow_ctrl_creds: transmit flow credentials
+  * @timer_count:  watchdog timer for operation completion
+  * @reserved: reserved for alignment
+  * @writing_state: state of the tx
+  * @rd_pending: pending read credits
+  * @rd_completed: completed read
+  *
+  * @cldev: device on the mei client bus
+  */
++>>>>>>> 6009595a66e4 (mei: bus: link client devices instead of host clients)
  struct mei_cl {
  	struct list_head link;
  	struct mei_device *dev;
@@@ -213,20 -250,16 +238,24 @@@
  	wait_queue_head_t rx_wait;
  	wait_queue_head_t wait;
  	int status;
 -	struct mei_me_client *me_cl;
 +	/* ID of client connected */
  	u8 host_client_id;
 +	u8 me_client_id;
  	u8 mei_flow_ctrl_creds;
  	u8 timer_count;
 -	u8 reserved;
 +	enum mei_file_transaction_states reading_state;
  	enum mei_file_transaction_states writing_state;
 -	struct list_head rd_pending;
 -	struct list_head rd_completed;
 -
 +	int sm_state;
 +	struct mei_cl_cb *read_cb;
 +
++<<<<<<< HEAD
 +	/* MEI CL bus data */
 +	struct mei_cl_device *device;
 +	struct list_head device_link;
 +	uuid_le device_uuid;
++=======
+ 	struct mei_cl_device *cldev;
++>>>>>>> 6009595a66e4 (mei: bus: link client devices instead of host clients)
  };
  
  /** struct mei_hw_ops
@@@ -288,75 -326,17 +317,86 @@@ struct mei_hw_ops 
  };
  
  /* MEI bus API*/
++<<<<<<< HEAD
 +
 +/**
 + * struct mei_cl_ops - MEI CL device ops
 + * This structure allows ME host clients to implement technology
 + * specific operations.
 + *
 + * @enable: Enable an MEI CL device. Some devices require specific
 + *	HECI commands to initialize completely.
 + * @disable: Disable an MEI CL device.
 + * @send: Tx hook for the device. This allows ME host clients to trap
 + *	the device driver buffers before actually physically
 + *	pushing it to the ME.
 + * @recv: Rx hook for the device. This allows ME host clients to trap the
 + *	ME buffers before forwarding them to the device driver.
 + */
 +struct mei_cl_ops {
 +	int (*enable)(struct mei_cl_device *device);
 +	int (*disable)(struct mei_cl_device *device);
 +	int (*send)(struct mei_cl_device *device, u8 *buf, size_t length);
 +	int (*recv)(struct mei_cl_device *device, u8 *buf, size_t length);
 +};
 +
 +struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops);
 +void mei_cl_remove_device(struct mei_cl_device *device);
 +
 +int __mei_cl_async_send(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
++=======
+ void mei_cl_bus_rescan(struct mei_device *bus);
+ void mei_cl_dev_fixup(struct mei_cl_device *dev);
+ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
+ 			bool blocking);
+ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
++>>>>>>> 6009595a66e4 (mei: bus: link client devices instead of host clients)
  void mei_cl_bus_rx_event(struct mei_cl *cl);
 -void mei_cl_bus_remove_devices(struct mei_device *bus);
 +void mei_cl_bus_remove_devices(struct mei_device *dev);
  int mei_cl_bus_init(void);
  void mei_cl_bus_exit(void);
++<<<<<<< HEAD
 +
++=======
++>>>>>>> 6009595a66e4 (mei: bus: link client devices instead of host clients)
  
  /**
 + * struct mei_cl_device - MEI device handle
 + * An mei_cl_device pointer is returned from mei_add_device()
 + * and links MEI bus clients to their actual ME host client pointer.
 + * Drivers for MEI devices will get an mei_cl_device pointer
 + * when being probed and shall use it for doing ME bus I/O.
 + *
 + * @dev: linux driver model device pointer
 + * @uuid: me client uuid
 + * @cl: mei client
 + * @ops: ME transport ops
 + * @event_cb: Drivers register this callback to get asynchronous ME
 + *	events (e.g. Rx buffer pending) notifications.
 + * @events: Events bitmask sent to the driver.
 + * @priv_data: client private data
 + */
 +struct mei_cl_device {
 +	struct device dev;
 +
 +	struct mei_cl *cl;
 +
 +	const struct mei_cl_ops *ops;
 +
 +	struct work_struct event_work;
 +	mei_cl_event_cb_t event_cb;
 +	void *event_context;
 +	unsigned long events;
 +
 +	void *priv_data;
 +};
 +
 +
 + /**
   * enum mei_pg_event - power gating transition events
   *
   * @MEI_PG_EVENT_IDLE: the driver is not in power gating transition
* Unmerged path drivers/misc/mei/bus-fixup.c
* Unmerged path drivers/misc/mei/bus.c
* Unmerged path drivers/misc/mei/client.c
diff --git a/drivers/misc/mei/init.c b/drivers/misc/mei/init.c
index 08331e745faf..95225392c590 100644
--- a/drivers/misc/mei/init.c
+++ b/drivers/misc/mei/init.c
@@ -302,7 +302,7 @@ void mei_stop(struct mei_device *dev)
 
 	mei_cancel_work(dev);
 
-	mei_nfc_host_exit(dev);
+	mei_cl_bus_remove_devices(dev);
 
 	mei_cl_bus_remove_devices(dev);
 
* Unmerged path drivers/misc/mei/mei_dev.h
