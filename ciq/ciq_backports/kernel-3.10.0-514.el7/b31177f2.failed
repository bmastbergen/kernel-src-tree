zram: trivial: correct flag operations comment

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
commit b31177f2a9d5b2cfb1da7a06a4a98273b40975a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b31177f2.failed

We don't have meta->tb_lock anymore and use meta table entry bit_spin_lock
instead. update corresponding comment.

	Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
	Acked-by: Minchan Kim <minchan@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit b31177f2a9d5b2cfb1da7a06a4a98273b40975a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/zram/zram_drv.c
diff --cc drivers/block/zram/zram_drv.c
index f4772ab5159f,4f76cf3e26a1..000000000000
--- a/drivers/block/zram/zram_drv.c
+++ b/drivers/block/zram/zram_drv.c
@@@ -74,12 -70,117 +74,18 @@@ static inline struct zram *dev_to_zram(
  	return (struct zram *)dev_to_disk(dev)->private_data;
  }
  
++<<<<<<< HEAD
 +static ssize_t disksize_show(struct device *dev,
 +		struct device_attribute *attr, char *buf)
++=======
+ /* flag operations require table entry bit_spin_lock() being held */
+ static int zram_test_flag(struct zram_meta *meta, u32 index,
+ 			enum zram_pageflags flag)
++>>>>>>> b31177f2a9d5 (zram: trivial: correct flag operations comment)
  {
 -	return meta->table[index].value & BIT(flag);
 -}
 -
 -static void zram_set_flag(struct zram_meta *meta, u32 index,
 -			enum zram_pageflags flag)
 -{
 -	meta->table[index].value |= BIT(flag);
 -}
 -
 -static void zram_clear_flag(struct zram_meta *meta, u32 index,
 -			enum zram_pageflags flag)
 -{
 -	meta->table[index].value &= ~BIT(flag);
 -}
 -
 -static size_t zram_get_obj_size(struct zram_meta *meta, u32 index)
 -{
 -	return meta->table[index].value & (BIT(ZRAM_FLAG_SHIFT) - 1);
 -}
 -
 -static void zram_set_obj_size(struct zram_meta *meta,
 -					u32 index, size_t size)
 -{
 -	unsigned long flags = meta->table[index].value >> ZRAM_FLAG_SHIFT;
 -
 -	meta->table[index].value = (flags << ZRAM_FLAG_SHIFT) | size;
 -}
 -
 -static inline int is_partial_io(struct bio_vec *bvec)
 -{
 -	return bvec->bv_len != PAGE_SIZE;
 -}
 -
 -/*
 - * Check if request is within bounds and aligned on zram logical blocks.
 - */
 -static inline int valid_io_request(struct zram *zram,
 -		sector_t start, unsigned int size)
 -{
 -	u64 end, bound;
 -
 -	/* unaligned request */
 -	if (unlikely(start & (ZRAM_SECTOR_PER_LOGICAL_BLOCK - 1)))
 -		return 0;
 -	if (unlikely(size & (ZRAM_LOGICAL_BLOCK_SIZE - 1)))
 -		return 0;
 -
 -	end = start + (size >> SECTOR_SHIFT);
 -	bound = zram->disksize >> SECTOR_SHIFT;
 -	/* out of range range */
 -	if (unlikely(start >= bound || end > bound || start > end))
 -		return 0;
 -
 -	/* I/O request is valid */
 -	return 1;
 -}
 -
 -static void update_position(u32 *index, int *offset, struct bio_vec *bvec)
 -{
 -	if (*offset + bvec->bv_len >= PAGE_SIZE)
 -		(*index)++;
 -	*offset = (*offset + bvec->bv_len) % PAGE_SIZE;
 -}
 -
 -static inline void update_used_max(struct zram *zram,
 -					const unsigned long pages)
 -{
 -	unsigned long old_max, cur_max;
 -
 -	old_max = atomic_long_read(&zram->stats.max_used_pages);
 -
 -	do {
 -		cur_max = old_max;
 -		if (pages > cur_max)
 -			old_max = atomic_long_cmpxchg(
 -				&zram->stats.max_used_pages, cur_max, pages);
 -	} while (old_max != cur_max);
 -}
 -
 -static int page_zero_filled(void *ptr)
 -{
 -	unsigned int pos;
 -	unsigned long *page;
 -
 -	page = (unsigned long *)ptr;
 -
 -	for (pos = 0; pos != PAGE_SIZE / sizeof(*page); pos++) {
 -		if (page[pos])
 -			return 0;
 -	}
 -
 -	return 1;
 -}
 -
 -static void handle_zero_page(struct bio_vec *bvec)
 -{
 -	struct page *page = bvec->bv_page;
 -	void *user_mem;
 -
 -	user_mem = kmap_atomic(page);
 -	if (is_partial_io(bvec))
 -		memset(user_mem + bvec->bv_offset, 0, bvec->bv_len);
 -	else
 -		clear_page(user_mem);
 -	kunmap_atomic(user_mem);
 +	struct zram *zram = dev_to_zram(dev);
  
 -	flush_dcache_page(page);
 +	return scnprintf(buf, PAGE_SIZE, "%llu\n", zram->disksize);
  }
  
  static ssize_t initstate_show(struct device *dev,
* Unmerged path drivers/block/zram/zram_drv.c
