nvme: Fixes u64 division which breaks i386 builds

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jon Derrick <jonathan.derrick@intel.com>
commit c45f5c9943ce0b16b299b543c2aae12408039027
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c45f5c99.failed

Uses div_u64 for u64 division and round_down, a bitwise operation,
instead of rounddown, which uses a modulus.

	Signed-off-by: Jon Derrick <jonathan.derrick@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit c45f5c9943ce0b16b299b543c2aae12408039027)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index 8da4158c74d9,666e994fd622..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -1265,6 -1447,47 +1265,50 @@@ static void nvme_disable_queue(struct n
  	spin_unlock_irq(&nvmeq->q_lock);
  }
  
++<<<<<<< HEAD
++=======
+ static int nvme_cmb_qdepth(struct nvme_dev *dev, int nr_io_queues,
+ 				int entry_size)
+ {
+ 	int q_depth = dev->q_depth;
+ 	unsigned q_size_aligned = roundup(q_depth * entry_size, dev->page_size);
+ 
+ 	if (q_size_aligned * nr_io_queues > dev->cmb_size) {
+ 		u64 mem_per_q = div_u64(dev->cmb_size, nr_io_queues);
+ 		mem_per_q = round_down(mem_per_q, dev->page_size);
+ 		q_depth = div_u64(mem_per_q, entry_size);
+ 
+ 		/*
+ 		 * Ensure the reduced q_depth is above some threshold where it
+ 		 * would be better to map queues in system memory with the
+ 		 * original depth
+ 		 */
+ 		if (q_depth < 64)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	return q_depth;
+ }
+ 
+ static int nvme_alloc_sq_cmds(struct nvme_dev *dev, struct nvme_queue *nvmeq,
+ 				int qid, int depth)
+ {
+ 	if (qid && dev->cmb && use_cmb_sqes && NVME_CMB_SQS(dev->cmbsz)) {
+ 		unsigned offset = (qid - 1) *
+ 					roundup(SQ_SIZE(depth), dev->page_size);
+ 		nvmeq->sq_dma_addr = dev->cmb_dma_addr + offset;
+ 		nvmeq->sq_cmds_io = dev->cmb + offset;
+ 	} else {
+ 		nvmeq->sq_cmds = dma_alloc_coherent(dev->dev, SQ_SIZE(depth),
+ 					&nvmeq->sq_dma_addr, GFP_KERNEL);
+ 		if (!nvmeq->sq_cmds)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> c45f5c9943ce (nvme: Fixes u64 division which breaks i386 builds)
  static struct nvme_queue *nvme_alloc_queue(struct nvme_dev *dev, int qid,
  							int depth)
  {
* Unmerged path drivers/block/nvme-core.c
