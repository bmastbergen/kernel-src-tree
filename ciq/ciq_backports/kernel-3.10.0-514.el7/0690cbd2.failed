powerpc/iommu: Rename iommu_[un]map_sg functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [iommu] powerpc: Rename iommu_[un]map_sg functions (Myron Stowe) [1287300]
Rebuild_FUZZ: 93.33%
commit-author Joerg Roedel <jroedel@suse.de>
commit 0690cbd2e55a72a8eae557c389d1a136ed9fa142
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0690cbd2.failed

The IOMMU-API gained support for a new iommu_map_sg
function. This causes compile failures on powerpc because
the function name is already globally used there.
This patch renames adds a ppc_ prefix to these functions to
solve the compile problem.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 0690cbd2e55a72a8eae557c389d1a136ed9fa142)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/iommu.h
diff --cc arch/powerpc/include/asm/iommu.h
index f0c8ea4c998a,9cfa3706a1b8..000000000000
--- a/arch/powerpc/include/asm/iommu.h
+++ b/arch/powerpc/include/asm/iommu.h
@@@ -222,34 -128,25 +222,47 @@@ static inline int iommu_add_device(stru
  static inline void iommu_del_device(struct device *dev)
  {
  }
 +
 +static inline int __init tce_iommu_bus_notifier_init(void)
 +{
 +        return 0;
 +}
  #endif /* !CONFIG_IOMMU_API */
  
 -static inline void set_iommu_table_base_and_group(struct device *dev,
 -						  void *base)
 +#else
 +
 +static inline void *get_iommu_table_base(struct device *dev)
  {
 -	set_iommu_table_base(dev, base);
 -	iommu_add_device(dev);
 +	return NULL;
  }
  
++<<<<<<< HEAD
 +static inline int dma_iommu_dma_supported(struct device *dev, u64 mask)
 +{
 +	return 0;
 +}
 +
 +#endif /* CONFIG_PPC64 */
 +
 +extern int iommu_map_sg(struct device *dev, struct iommu_table *tbl,
 +			struct scatterlist *sglist, int nelems,
 +			unsigned long mask, enum dma_data_direction direction,
 +			struct dma_attrs *attrs);
 +extern void iommu_unmap_sg(struct iommu_table *tbl, struct scatterlist *sglist,
 +			   int nelems, enum dma_data_direction direction,
 +			   struct dma_attrs *attrs);
++=======
+ extern int ppc_iommu_map_sg(struct device *dev, struct iommu_table *tbl,
+ 			    struct scatterlist *sglist, int nelems,
+ 			    unsigned long mask,
+ 			    enum dma_data_direction direction,
+ 			    struct dma_attrs *attrs);
+ extern void ppc_iommu_unmap_sg(struct iommu_table *tbl,
+ 			       struct scatterlist *sglist,
+ 			       int nelems,
+ 			       enum dma_data_direction direction,
+ 			       struct dma_attrs *attrs);
++>>>>>>> 0690cbd2e55a (powerpc/iommu: Rename iommu_[un]map_sg functions)
  
  extern void *iommu_alloc_coherent(struct device *dev, struct iommu_table *tbl,
  				  size_t size, dma_addr_t *dma_handle,
* Unmerged path arch/powerpc/include/asm/iommu.h
diff --git a/arch/powerpc/kernel/dma-iommu.c b/arch/powerpc/kernel/dma-iommu.c
index a550b67b8f4b..41a7d9d49a5a 100644
--- a/arch/powerpc/kernel/dma-iommu.c
+++ b/arch/powerpc/kernel/dma-iommu.c
@@ -60,16 +60,16 @@ static int dma_iommu_map_sg(struct device *dev, struct scatterlist *sglist,
 			    int nelems, enum dma_data_direction direction,
 			    struct dma_attrs *attrs)
 {
-	return iommu_map_sg(dev, get_iommu_table_base(dev), sglist, nelems,
-			    device_to_mask(dev), direction, attrs);
+	return ppc_iommu_map_sg(dev, get_iommu_table_base(dev), sglist, nelems,
+				device_to_mask(dev), direction, attrs);
 }
 
 static void dma_iommu_unmap_sg(struct device *dev, struct scatterlist *sglist,
 		int nelems, enum dma_data_direction direction,
 		struct dma_attrs *attrs)
 {
-	iommu_unmap_sg(get_iommu_table_base(dev), sglist, nelems, direction,
-		       attrs);
+	ppc_iommu_unmap_sg(get_iommu_table_base(dev), sglist, nelems,
+			   direction, attrs);
 }
 
 /* We support DMA to/from any memory page via the iommu */
diff --git a/arch/powerpc/kernel/iommu.c b/arch/powerpc/kernel/iommu.c
index 1a82bce1dd71..49a8f331e177 100644
--- a/arch/powerpc/kernel/iommu.c
+++ b/arch/powerpc/kernel/iommu.c
@@ -428,10 +428,10 @@ static void iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,
 		tbl->it_ops->flush(tbl);
 }
 
-int iommu_map_sg(struct device *dev, struct iommu_table *tbl,
-		 struct scatterlist *sglist, int nelems,
-		 unsigned long mask, enum dma_data_direction direction,
-		 struct dma_attrs *attrs)
+int ppc_iommu_map_sg(struct device *dev, struct iommu_table *tbl,
+		     struct scatterlist *sglist, int nelems,
+		     unsigned long mask, enum dma_data_direction direction,
+		     struct dma_attrs *attrs)
 {
 	dma_addr_t dma_next = 0, dma_addr;
 	struct scatterlist *s, *outs, *segstart;
@@ -539,7 +539,7 @@ int iommu_map_sg(struct device *dev, struct iommu_table *tbl,
 
 	DBG("mapped %d elements:\n", outcount);
 
-	/* For the sake of iommu_unmap_sg, we clear out the length in the
+	/* For the sake of ppc_iommu_unmap_sg, we clear out the length in the
 	 * next entry of the sglist if we didn't fill the list completely
 	 */
 	if (outcount < incount) {
@@ -572,9 +572,9 @@ int iommu_map_sg(struct device *dev, struct iommu_table *tbl,
 }
 
 
-void iommu_unmap_sg(struct iommu_table *tbl, struct scatterlist *sglist,
-		int nelems, enum dma_data_direction direction,
-		struct dma_attrs *attrs)
+void ppc_iommu_unmap_sg(struct iommu_table *tbl, struct scatterlist *sglist,
+			int nelems, enum dma_data_direction direction,
+			struct dma_attrs *attrs)
 {
 	struct scatterlist *sg;
 
diff --git a/arch/powerpc/platforms/cell/iommu.c b/arch/powerpc/platforms/cell/iommu.c
index c24cd6d84d28..72763a854271 100644
--- a/arch/powerpc/platforms/cell/iommu.c
+++ b/arch/powerpc/platforms/cell/iommu.c
@@ -627,8 +627,9 @@ static int dma_fixed_map_sg(struct device *dev, struct scatterlist *sg,
 	if (iommu_fixed_is_weak == dma_get_attr(DMA_ATTR_WEAK_ORDERING, attrs))
 		return dma_direct_ops.map_sg(dev, sg, nents, direction, attrs);
 	else
-		return iommu_map_sg(dev, cell_get_iommu_table(dev), sg, nents,
-				    device_to_mask(dev), direction, attrs);
+		return ppc_iommu_map_sg(dev, cell_get_iommu_table(dev), sg,
+					nents, device_to_mask(dev),
+					direction, attrs);
 }
 
 static void dma_fixed_unmap_sg(struct device *dev, struct scatterlist *sg,
@@ -638,8 +639,8 @@ static void dma_fixed_unmap_sg(struct device *dev, struct scatterlist *sg,
 	if (iommu_fixed_is_weak == dma_get_attr(DMA_ATTR_WEAK_ORDERING, attrs))
 		dma_direct_ops.unmap_sg(dev, sg, nents, direction, attrs);
 	else
-		iommu_unmap_sg(cell_get_iommu_table(dev), sg, nents, direction,
-			       attrs);
+		ppc_iommu_unmap_sg(cell_get_iommu_table(dev), sg, nents,
+				   direction, attrs);
 }
 
 static int dma_fixed_dma_supported(struct device *dev, u64 mask)
