staging/rdma/hfi1: Make EPROM check per device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Make EPROM check per device (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 90.48%
commit-author Dean Luick <dean.luick@intel.com>
commit e154f12716ffbbd7bab52b48b8e78142a22a59c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e154f127.failed

Add a variable eprom_available to each device, replacing the
global of the same name.  This is to allow multiple HFI devices
with different EPROM availability to operate correctly on the
the same system.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Dean Luick <dean.luick@intel.com>
	Signed-off-by: Jubin John <jubin.john@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit e154f12716ffbbd7bab52b48b8e78142a22a59c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/hfi.h
diff --cc drivers/staging/hfi1/hfi.h
index 5b1e71911aff,585485bb6e77..000000000000
--- a/drivers/staging/hfi1/hfi.h
+++ b/drivers/staging/hfi1/hfi.h
@@@ -1135,6 -1144,16 +1135,19 @@@ struct hfi1_devdata 
  	/* receive context tail dummy address */
  	__le64 *rcvhdrtail_dummy_kvaddr;
  	dma_addr_t rcvhdrtail_dummy_physaddr;
++<<<<<<< HEAD:drivers/staging/hfi1/hfi.h
++=======
+ 
+ 	bool eprom_available;	/* true if EPROM is available for this device */
+ 	bool aspm_supported;	/* Does HW support ASPM */
+ 	bool aspm_enabled;	/* ASPM state: enabled/disabled */
+ 	/* Serialize ASPM enable/disable between multiple verbs contexts */
+ 	spinlock_t aspm_lock;
+ 	/* Number of verbs contexts which have disabled ASPM */
+ 	atomic_t aspm_disabled_cnt;
+ 
+ 	struct hfi1_affinity *affinity;
++>>>>>>> e154f12716ff (staging/rdma/hfi1: Make EPROM check per device):drivers/staging/rdma/hfi1/hfi.h
  };
  
  /* 8051 firmware version helper */
diff --git a/drivers/staging/hfi1/eprom.c b/drivers/staging/hfi1/eprom.c
index 8104a1121bf2..29958aa4e4fd 100644
--- a/drivers/staging/hfi1/eprom.c
+++ b/drivers/staging/hfi1/eprom.c
@@ -106,10 +106,8 @@
 
 /*
  * Use the EP mutex to guard against other callers from within the driver.
- * Also covers usage of eprom_available.
  */
 static DEFINE_MUTEX(eprom_mutex);
-static int eprom_available;	/* default: not available */
 
 /*
  * Turn on external enable line that allows writing on the flash.
@@ -376,15 +374,13 @@ int handle_eprom_command(struct file *fp, const struct hfi1_cmd *cmd)
 		return -EINVAL;
 	}
 
+	/* some devices do not have an EPROM */
+	if (!dd->eprom_available)
+		return -EOPNOTSUPP;
+
 	/* lock against other callers touching the ASIC block */
 	mutex_lock(&eprom_mutex);
 
-	/* some platforms do not have an EPROM */
-	if (!eprom_available) {
-		ret = -ENOSYS;
-		goto done_asic;
-	}
-
 	/* lock against the other HFI on another OS */
 	ret = acquire_hw_mutex(dd);
 	if (ret) {
@@ -458,8 +454,6 @@ int eprom_init(struct hfi1_devdata *dd)
 
 	/* lock against other callers */
 	mutex_lock(&eprom_mutex);
-	if (eprom_available)	/* already initialized */
-		goto done_asic;
 
 	/*
 	 * Lock against the other HFI on another OS - the mutex above
@@ -487,7 +481,7 @@ int eprom_init(struct hfi1_devdata *dd)
 	/* wake the device with command "release powerdown NoID" */
 	write_csr(dd, ASIC_EEP_ADDR_CMD, CMD_RELEASE_POWERDOWN_NOID);
 
-	eprom_available = 1;
+	dd->eprom_available = true;
 	release_hw_mutex(dd);
 done_asic:
 	mutex_unlock(&eprom_mutex);
* Unmerged path drivers/staging/hfi1/hfi.h
