net: Eliminate NETIF_F_GEN_CSUM and NETIF_F_V[46]_CSUM

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] Eliminate NETIF_F_GEN_CSUM and NETIF_F_V[46]_CSUM (Lance Richardson) [1297465]
Rebuild_FUZZ: 95.15%
commit-author Tom Herbert <tom@herbertland.com>
commit c8cd0989bd151fda87bbf10887b3df18021284bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c8cd0989.failed

These netif flags are unnecessary convolutions. It is more
straightforward to just use NETIF_F_HW_CSUM, NETIF_F_IP_CSUM,
and NETIF_F_IPV6_CSUM directly.

This patch also:
    - Cleans up can_checksum_protocol
    - Simplifies netdev_intersect_features

	Signed-off-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c8cd0989bd151fda87bbf10887b3df18021284bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/macvlan.c
#	include/linux/netdev_features.h
#	include/linux/netdevice.h
#	net/core/dev.c
#	net/core/pktgen.c
#	net/ipv6/ip6_output.c
diff --cc drivers/net/macvlan.c
index 69af51e20961,6a57a005e0ca..000000000000
--- a/drivers/net/macvlan.c
+++ b/drivers/net/macvlan.c
@@@ -542,11 -758,12 +542,16 @@@ static struct lock_class_key macvlan_ne
  static struct lock_class_key macvlan_netdev_addr_lock_key;
  
  #define ALWAYS_ON_FEATURES \
++<<<<<<< HEAD
 +	(NETIF_F_SG | NETIF_F_GEN_CSUM | NETIF_F_GSO_SOFTWARE | NETIF_F_LLTX)
++=======
+ 	(NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_GSO_SOFTWARE | NETIF_F_LLTX | \
+ 	 NETIF_F_GSO_ROBUST)
++>>>>>>> c8cd0989bd15 (net: Eliminate NETIF_F_GEN_CSUM and NETIF_F_V[46]_CSUM)
  
  #define MACVLAN_FEATURES \
 -	(NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_HIGHDMA | NETIF_F_FRAGLIST | \
 -	 NETIF_F_GSO | NETIF_F_TSO | NETIF_F_UFO | NETIF_F_LRO | \
 +	(NETIF_F_SG | NETIF_F_ALL_CSUM | NETIF_F_HIGHDMA | NETIF_F_FRAGLIST | \
 +	 NETIF_F_GSO | NETIF_F_TSO | NETIF_F_UFO | NETIF_F_GSO_ROBUST | \
  	 NETIF_F_TSO_ECN | NETIF_F_TSO6 | NETIF_F_GRO | NETIF_F_RXCSUM | \
  	 NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_HW_VLAN_STAG_FILTER)
  
diff --cc include/linux/netdev_features.h
index 83724df4f707,d9654f0eecb3..000000000000
--- a/include/linux/netdev_features.h
+++ b/include/linux/netdev_features.h
@@@ -158,10 -146,12 +158,19 @@@ enum 
  #define NETIF_F_GSO_SOFTWARE	(NETIF_F_TSO | NETIF_F_TSO_ECN | \
  				 NETIF_F_TSO6 | NETIF_F_UFO)
  
++<<<<<<< HEAD
 +#define NETIF_F_GEN_CSUM	NETIF_F_HW_CSUM
 +#define NETIF_F_V4_CSUM		(NETIF_F_GEN_CSUM | NETIF_F_IP_CSUM)
 +#define NETIF_F_V6_CSUM		(NETIF_F_GEN_CSUM | NETIF_F_IPV6_CSUM)
 +#define NETIF_F_ALL_CSUM	(NETIF_F_V4_CSUM | NETIF_F_V6_CSUM)
++=======
+ /* List of IP checksum features. Note that NETIF_F_ HW_CSUM should not be
+  * set in features when NETIF_F_IP_CSUM or NETIF_F_IPV6_CSUM are set--
+  * this would be contradictory
+  */
+ #define NETIF_F_CSUM_MASK	(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | \
+ 				 NETIF_F_HW_CSUM)
++>>>>>>> c8cd0989bd15 (net: Eliminate NETIF_F_GEN_CSUM and NETIF_F_V[46]_CSUM)
  
  #define NETIF_F_ALL_TSO 	(NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_TSO_ECN)
  
diff --cc include/linux/netdevice.h
index f42ad8e42b23,283984b67cd9..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -3408,15 -3773,14 +3419,24 @@@ void linkwatch_run_queue(void)
  static inline netdev_features_t netdev_intersect_features(netdev_features_t f1,
  							  netdev_features_t f2)
  {
++<<<<<<< HEAD
 +	if (f1 & NETIF_F_GEN_CSUM)
 +		f1 |= (NETIF_F_ALL_CSUM & ~NETIF_F_GEN_CSUM);
 +	if (f2 & NETIF_F_GEN_CSUM)
 +		f2 |= (NETIF_F_ALL_CSUM & ~NETIF_F_GEN_CSUM);
 +	f1 &= f2;
 +	if (f1 & NETIF_F_GEN_CSUM)
 +		f1 &= ~(NETIF_F_ALL_CSUM & ~NETIF_F_GEN_CSUM);
++=======
+ 	if ((f1 ^ f2) & NETIF_F_HW_CSUM) {
+ 		if (f1 & NETIF_F_HW_CSUM)
+ 			f1 |= (NETIF_F_IP_CSUM|NETIF_F_IP_CSUM);
+ 		else
+ 			f2 |= (NETIF_F_IP_CSUM|NETIF_F_IP_CSUM);
+ 	}
++>>>>>>> c8cd0989bd15 (net: Eliminate NETIF_F_GEN_CSUM and NETIF_F_V[46]_CSUM)
  
- 	return f1;
+ 	return f1 & f2;
  }
  
  static inline netdev_features_t netdev_get_wanted_features(
diff --cc net/core/dev.c
index e416d49ce837,45b013f27625..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -6543,16 -7571,16 +6543,26 @@@ static int dev_cpu_callback(struct noti
  netdev_features_t netdev_increment_features(netdev_features_t all,
  	netdev_features_t one, netdev_features_t mask)
  {
++<<<<<<< HEAD
 +	if (mask & NETIF_F_GEN_CSUM)
 +		mask |= NETIF_F_ALL_CSUM;
++=======
+ 	if (mask & NETIF_F_HW_CSUM)
+ 		mask |= NETIF_F_CSUM_MASK;
++>>>>>>> c8cd0989bd15 (net: Eliminate NETIF_F_GEN_CSUM and NETIF_F_V[46]_CSUM)
  	mask |= NETIF_F_VLAN_CHALLENGED;
  
 -	all |= one & (NETIF_F_ONE_FOR_ALL | NETIF_F_CSUM_MASK) & mask;
 +	all |= one & (NETIF_F_ONE_FOR_ALL|NETIF_F_ALL_CSUM) & mask;
  	all &= one | ~NETIF_F_ALL_FOR_ALL;
  
  	/* If one device supports hw checksumming, set for all. */
++<<<<<<< HEAD
 +	if (all & NETIF_F_GEN_CSUM)
 +		all &= ~(NETIF_F_ALL_CSUM & ~NETIF_F_GEN_CSUM);
++=======
+ 	if (all & NETIF_F_HW_CSUM)
+ 		all &= ~(NETIF_F_CSUM_MASK & ~NETIF_F_HW_CSUM);
++>>>>>>> c8cd0989bd15 (net: Eliminate NETIF_F_GEN_CSUM and NETIF_F_V[46]_CSUM)
  
  	return all;
  }
diff --cc net/core/pktgen.c
index bb26b23a6a90,2be144498bcf..000000000000
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@@ -2788,8 -2893,26 +2788,28 @@@ static struct sk_buff *fill_packet_ipv4
  	skb->protocol = protocol;
  	skb->dev = odev;
  	skb->pkt_type = PACKET_HOST;
 -
  	pktgen_finalize_skb(pkt_dev, skb, datalen);
  
++<<<<<<< HEAD
++=======
+ 	if (!(pkt_dev->flags & F_UDPCSUM)) {
+ 		skb->ip_summed = CHECKSUM_NONE;
+ 	} else if (odev->features & (NETIF_F_HW_CSUM | NETIF_F_IP_CSUM)) {
+ 		skb->ip_summed = CHECKSUM_PARTIAL;
+ 		skb->csum = 0;
+ 		udp4_hwcsum(skb, iph->saddr, iph->daddr);
+ 	} else {
+ 		__wsum csum = skb_checksum(skb, skb_transport_offset(skb), datalen + 8, 0);
+ 
+ 		/* add protocol-dependent pseudo-header */
+ 		udph->check = csum_tcpudp_magic(iph->saddr, iph->daddr,
+ 						datalen + 8, IPPROTO_UDP, csum);
+ 
+ 		if (udph->check == 0)
+ 			udph->check = CSUM_MANGLED_0;
+ 	}
+ 
++>>>>>>> c8cd0989bd15 (net: Eliminate NETIF_F_GEN_CSUM and NETIF_F_V[46]_CSUM)
  #ifdef CONFIG_XFRM
  	if (!process_ipsec(pkt_dev, skb, protocol))
  		return NULL;
@@@ -2908,6 -3030,23 +2928,26 @@@ static struct sk_buff *fill_packet_ipv6
  
  	pktgen_finalize_skb(pkt_dev, skb, datalen);
  
++<<<<<<< HEAD
++=======
+ 	if (!(pkt_dev->flags & F_UDPCSUM)) {
+ 		skb->ip_summed = CHECKSUM_NONE;
+ 	} else if (odev->features & (NETIF_F_HW_CSUM | NETIF_F_IPV6_CSUM)) {
+ 		skb->ip_summed = CHECKSUM_PARTIAL;
+ 		skb->csum_start = skb_transport_header(skb) - skb->head;
+ 		skb->csum_offset = offsetof(struct udphdr, check);
+ 		udph->check = ~csum_ipv6_magic(&iph->saddr, &iph->daddr, udplen, IPPROTO_UDP, 0);
+ 	} else {
+ 		__wsum csum = skb_checksum(skb, skb_transport_offset(skb), udplen, 0);
+ 
+ 		/* add protocol-dependent pseudo-header */
+ 		udph->check = csum_ipv6_magic(&iph->saddr, &iph->daddr, udplen, IPPROTO_UDP, csum);
+ 
+ 		if (udph->check == 0)
+ 			udph->check = CSUM_MANGLED_0;
+ 	}
+ 
++>>>>>>> c8cd0989bd15 (net: Eliminate NETIF_F_GEN_CSUM and NETIF_F_V[46]_CSUM)
  	return skb;
  }
  
diff --cc net/ipv6/ip6_output.c
index 6e24dc6ba803,2f748452b4aa..000000000000
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@@ -1220,53 -1288,50 +1220,57 @@@ static int __ip6_append_data(struct soc
  	maxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen -
  		     sizeof(struct frag_hdr);
  
 -	headersize = sizeof(struct ipv6hdr) +
 -		     (opt ? opt->opt_flen + opt->opt_nflen : 0) +
 -		     (dst_allfrag(&rt->dst) ?
 -		      sizeof(struct frag_hdr) : 0) +
 -		     rt->rt6i_nfheader_len;
 -
 -	if (cork->length + length > mtu - headersize && dontfrag &&
 -	    (sk->sk_protocol == IPPROTO_UDP ||
 -	     sk->sk_protocol == IPPROTO_RAW)) {
 -		ipv6_local_rxpmtu(sk, fl6, mtu - headersize +
 -				sizeof(struct ipv6hdr));
 -		goto emsgsize;
 -	}
 +	if (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {
 +		unsigned int maxnonfragsize, headersize;
  
 -	if (ip6_sk_ignore_df(sk))
 -		maxnonfragsize = sizeof(struct ipv6hdr) + IPV6_MAXPLEN;
 -	else
 -		maxnonfragsize = mtu;
 +		headersize = sizeof(struct ipv6hdr) +
 +			     (opt ? opt->opt_flen + opt->opt_nflen : 0) +
 +			     (dst_allfrag(&rt->dst) ?
 +			      sizeof(struct frag_hdr) : 0) +
 +			     rt->rt6i_nfheader_len;
 +
 +		if (ip6_sk_ignore_df(sk))
 +			maxnonfragsize = sizeof(struct ipv6hdr) + IPV6_MAXPLEN;
 +		else
 +			maxnonfragsize = mtu;
  
 -	if (cork->length + length > maxnonfragsize - headersize) {
 +		/* dontfrag active */
 +		if ((cork->length + length > mtu - headersize) && dontfrag &&
 +		    (sk->sk_protocol == IPPROTO_UDP ||
 +		     sk->sk_protocol == IPPROTO_RAW)) {
 +			ipv6_local_rxpmtu(sk, fl6, mtu - headersize +
 +						   sizeof(struct ipv6hdr));
 +			goto emsgsize;
 +		}
 +
 +		if (cork->length + length > maxnonfragsize - headersize) {
  emsgsize:
 -		ipv6_local_error(sk, EMSGSIZE, fl6,
 -				 mtu - headersize +
 -				 sizeof(struct ipv6hdr));
 -		return -EMSGSIZE;
 +			ipv6_local_error(sk, EMSGSIZE, fl6,
 +					 mtu - headersize +
 +					 sizeof(struct ipv6hdr));
 +			return -EMSGSIZE;
 +		}
  	}
  
 -	/* CHECKSUM_PARTIAL only with no extension headers and when
 -	 * we are not going to fragment
 +	/* For UDP, check if TX timestamp is enabled */
 +	if (sk->sk_type == SOCK_DGRAM)
 +		sock_tx_timestamp(sk, &tx_flags);
 +
 +	/* If this is the first and only packet and device
 +	 * supports checksum offloading, let's use it.
 +	 * Use transhdrlen, same as IPv4, because partial
 +	 * sums only work when transhdrlen is set.
  	 */
  	if (transhdrlen && sk->sk_protocol == IPPROTO_UDP &&
 -	    headersize == sizeof(struct ipv6hdr) &&
 -	    length < mtu - headersize &&
  	    !(flags & MSG_MORE) &&
++<<<<<<< HEAD
 +	    length + fragheaderlen < mtu &&
 +	    rt->dst.dev->features & NETIF_F_V6_CSUM &&
 +	    !exthdrlen)
++=======
+ 	    rt->dst.dev->features & (NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM))
++>>>>>>> c8cd0989bd15 (net: Eliminate NETIF_F_GEN_CSUM and NETIF_F_V[46]_CSUM)
  		csummode = CHECKSUM_PARTIAL;
 -
 -	if (sk->sk_type == SOCK_DGRAM || sk->sk_type == SOCK_RAW) {
 -		sock_tx_timestamp(sk, &tx_flags);
 -		if (tx_flags & SKBTX_ANY_SW_TSTAMP &&
 -		    sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)
 -			tskey = sk->sk_tskey++;
 -	}
 -
  	/*
  	 * Let's try using as much space as possible.
  	 * Use MTU if total length of the message fits into the MTU.
diff --git a/drivers/net/ethernet/sfc/efx.c b/drivers/net/ethernet/sfc/efx.c
index 273bd5c7bbec..f98331288446 100644
--- a/drivers/net/ethernet/sfc/efx.c
+++ b/drivers/net/ethernet/sfc/efx.c
@@ -3129,7 +3129,7 @@ static int efx_pci_probe(struct pci_dev *pci_dev,
 	net_dev->features |= (efx->type->offload_features | NETIF_F_SG |
 			      NETIF_F_HIGHDMA | NETIF_F_TSO |
 			      NETIF_F_RXCSUM);
-	if (efx->type->offload_features & NETIF_F_V6_CSUM)
+	if (efx->type->offload_features & (NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM))
 		net_dev->features |= NETIF_F_TSO6;
 	/* Mask for features that also apply to VLAN devices */
 	net_dev->vlan_features |= (NETIF_F_ALL_CSUM | NETIF_F_SG |
* Unmerged path drivers/net/macvlan.c
diff --git a/include/linux/if_vlan.h b/include/linux/if_vlan.h
index 089213ca80b7..9494f2b12fcc 100644
--- a/include/linux/if_vlan.h
+++ b/include/linux/if_vlan.h
@@ -615,7 +615,7 @@ static inline netdev_features_t vlan_features_check(const struct sk_buff *skb,
 						     NETIF_F_SG |
 						     NETIF_F_HIGHDMA |
 						     NETIF_F_FRAGLIST |
-						     NETIF_F_GEN_CSUM |
+						     NETIF_F_HW_CSUM |
 						     NETIF_F_HW_VLAN_CTAG_TX |
 						     NETIF_F_HW_VLAN_STAG_TX);
 
* Unmerged path include/linux/netdev_features.h
* Unmerged path include/linux/netdevice.h
* Unmerged path net/core/dev.c
* Unmerged path net/core/pktgen.c
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 21b11ebed76f..860ceaee5c15 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -890,7 +890,7 @@ static int __ip_append_data(struct sock *sk,
 	 */
 	if (transhdrlen &&
 	    length + fragheaderlen <= mtu &&
-	    rt->dst.dev->features & NETIF_F_V4_CSUM &&
+	    rt->dst.dev->features & (NETIF_F_HW_CSUM | NETIF_F_IP_CSUM) &&
 	    !(flags & MSG_MORE) &&
 	    !exthdrlen)
 		csummode = CHECKSUM_PARTIAL;
diff --git a/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c b/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
index b550885b5986..edd1da416097 100644
--- a/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
@@ -132,7 +132,8 @@ static void nf_nat_ipv4_csum_recalc(struct sk_buff *skb,
 
 	if (skb->ip_summed != CHECKSUM_PARTIAL) {
 		if (!(rt->rt_flags & RTCF_LOCAL) &&
-		    (!skb->dev || skb->dev->features & NETIF_F_V4_CSUM)) {
+		    (!skb->dev || skb->dev->features &
+		     (NETIF_F_IP_CSUM | NETIF_F_HW_CSUM))) {
 			skb->ip_summed = CHECKSUM_PARTIAL;
 			skb->csum_start = skb_headroom(skb) +
 					  skb_network_offset(skb) +
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 7c7368a4440c..b4c2820e14f9 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -767,7 +767,8 @@ void udp_set_csum(bool nocheck, struct sk_buff *skb,
 	else if (skb_is_gso(skb))
 		uh->check = ~udp_v4_check(len, saddr, daddr, 0);
 	else if (skb_dst(skb) && skb_dst(skb)->dev &&
-		 (skb_dst(skb)->dev->features & NETIF_F_V4_CSUM)) {
+		 (skb_dst(skb)->dev->features &
+		  (NETIF_F_IP_CSUM | NETIF_F_HW_CSUM))) {
 
 		BUG_ON(skb->ip_summed == CHECKSUM_PARTIAL);
 
diff --git a/net/ipv4/udp_offload.c b/net/ipv4/udp_offload.c
index 2c896776f9f5..90d47be357d7 100644
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@ -61,8 +61,9 @@ static struct sk_buff *__skb_udp_tunnel_segment(struct sk_buff *skb,
 
 	/* Try to offload checksum if possible */
 	offload_csum = !!(need_csum &&
-			  (skb->dev->features &
-			   (is_ipv6 ? NETIF_F_V6_CSUM : NETIF_F_V4_CSUM)));
+			  ((skb->dev->features & NETIF_F_HW_CSUM) ||
+			   (skb->dev->features & (is_ipv6 ?
+			    NETIF_F_IPV6_CSUM : NETIF_F_IP_CSUM))));
 
 	/* segment inner packet. */
 	enc_features = skb->dev->hw_enc_features & features;
* Unmerged path net/ipv6/ip6_output.c
diff --git a/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c b/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
index 807f34dfe7f5..fadffa1dab85 100644
--- a/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
+++ b/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
@@ -136,7 +136,8 @@ static void nf_nat_ipv6_csum_recalc(struct sk_buff *skb,
 
 	if (skb->ip_summed != CHECKSUM_PARTIAL) {
 		if (!(rt->rt6i_flags & RTF_LOCAL) &&
-		    (!skb->dev || skb->dev->features & NETIF_F_V6_CSUM)) {
+		    (!skb->dev || skb->dev->features &
+		     (NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM))) {
 			skb->ip_summed = CHECKSUM_PARTIAL;
 			skb->csum_start = skb_headroom(skb) +
 					  skb_network_offset(skb) +
