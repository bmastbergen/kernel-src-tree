IB/core: Validate route when we init ah

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matan Barak <matanb@mellanox.com>
commit 200298326b276d8dbeff204f7d407432100d9963
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/20029832.failed

In order to make sure API users don't try to use SGIDs which don't
conform to the routing table, validate the route before searching
the RoCE GID table.

	Signed-off-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 200298326b276d8dbeff204f7d407432100d9963)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/addr.c
#	drivers/infiniband/core/cm.c
#	drivers/infiniband/core/cma.c
#	drivers/infiniband/core/sa_query.c
#	drivers/infiniband/core/verbs.c
#	drivers/infiniband/hw/ocrdma/ocrdma_ah.c
#	include/rdma/ib_addr.h
diff --cc drivers/infiniband/core/addr.c
index 746cdf56bc76,0b5f24533ac1..000000000000
--- a/drivers/infiniband/core/addr.c
+++ b/drivers/infiniband/core/addr.c
@@@ -138,8 -139,8 +139,13 @@@ int rdma_translate_ip(const struct sock
  
  	switch (addr->sa_family) {
  	case AF_INET:
++<<<<<<< HEAD
 +		dev = ip_dev_find(&init_net,
 +			((struct sockaddr_in *) addr)->sin_addr.s_addr);
++=======
+ 		dev = ip_dev_find(dev_addr->net,
+ 			((const struct sockaddr_in *)addr)->sin_addr.s_addr);
++>>>>>>> 200298326b27 (IB/core: Validate route when we init ah)
  
  		if (!dev)
  			return ret;
@@@ -153,9 -153,9 +159,15 @@@
  #if IS_ENABLED(CONFIG_IPV6)
  	case AF_INET6:
  		rcu_read_lock();
++<<<<<<< HEAD
 +		for_each_netdev_rcu(&init_net, dev) {
 +			if (ipv6_chk_addr(&init_net,
 +					  &((struct sockaddr_in6 *) addr)->sin6_addr,
++=======
+ 		for_each_netdev_rcu(dev_addr->net, dev) {
+ 			if (ipv6_chk_addr(dev_addr->net,
+ 					  &((const struct sockaddr_in6 *)addr)->sin6_addr,
++>>>>>>> 200298326b27 (IB/core: Validate route when we init ah)
  					  dev, 1)) {
  				ret = rdma_copy_addr(dev_addr, dev, NULL);
  				if (vlan_id)
@@@ -244,22 -246,14 +258,33 @@@ static int addr4_resolve(struct sockadd
  	src_in->sin_family = AF_INET;
  	src_in->sin_addr.s_addr = fl4.saddr;
  
++<<<<<<< HEAD
 +	if (rt->dst.dev->flags & IFF_LOOPBACK) {
 +		ret = rdma_translate_ip((struct sockaddr *)dst_in, addr, NULL);
 +		if (!ret)
 +			memcpy(addr->dst_dev_addr, addr->src_dev_addr, MAX_ADDR_LEN);
 +		goto put;
 +	}
 +
 +	/* If the device does ARP internally, return 'done' */
 +	if (rt->dst.dev->flags & IFF_NOARP) {
 +		ret = rdma_copy_addr(addr, rt->dst.dev, NULL);
 +		goto put;
 +	}
 +
 +	ret = dst_fetch_ha(&rt->dst, addr, &fl4.daddr);
 +put:
 +	ip_rt_put(rt);
++=======
+ 	/* If there's a gateway, we're definitely in RoCE v2 (as RoCE v1 isn't
+ 	 * routable) and we could set the network type accordingly.
+ 	 */
+ 	if (rt->rt_uses_gateway)
+ 		addr->network = RDMA_NETWORK_IPV4;
+ 
+ 	*prt = rt;
+ 	return 0;
++>>>>>>> 200298326b27 (IB/core: Validate route when we init ah)
  out:
  	return ret;
  }
@@@ -292,20 -289,14 +318,31 @@@ static int addr6_resolve(struct sockadd
  		src_in->sin6_addr = fl6.saddr;
  	}
  
++<<<<<<< HEAD
 +	if (dst->dev->flags & IFF_LOOPBACK) {
 +		ret = rdma_translate_ip((struct sockaddr *)dst_in, addr, NULL);
 +		if (!ret)
 +			memcpy(addr->dst_dev_addr, addr->src_dev_addr, MAX_ADDR_LEN);
 +		goto put;
 +	}
 +
 +	/* If the device does ARP internally, return 'done' */
 +	if (dst->dev->flags & IFF_NOARP) {
 +		ret = rdma_copy_addr(addr, dst->dev, NULL);
 +		goto put;
 +	}
 +
 +	ret = dst_fetch_ha(dst, addr, &fl6.daddr);
++=======
+ 	/* If there's a gateway, we're definitely in RoCE v2 (as RoCE v1 isn't
+ 	 * routable) and we could set the network type accordingly.
+ 	 */
+ 	if (rt->rt6i_flags & RTF_GATEWAY)
+ 		addr->network = RDMA_NETWORK_IPV6;
+ 
+ 	*pdst = dst;
+ 	return 0;
++>>>>>>> 200298326b27 (IB/core: Validate route when we init ah)
  put:
  	dst_release(dst);
  	return ret;
@@@ -458,7 -541,7 +587,11 @@@ static void resolve_cb(int status, stru
  }
  
  int rdma_addr_find_dmac_by_grh(const union ib_gid *sgid, const union ib_gid *dgid,
++<<<<<<< HEAD
 +			       u8 *dmac, u16 *vlan_id)
++=======
+ 			       u8 *dmac, u16 *vlan_id, int *if_index)
++>>>>>>> 200298326b27 (IB/core: Validate route when we init ah)
  {
  	int ret = 0;
  	struct rdma_dev_addr dev_addr;
@@@ -476,6 -559,9 +609,12 @@@
  	rdma_gid2ip(&dgid_addr._sockaddr, dgid);
  
  	memset(&dev_addr, 0, sizeof(dev_addr));
++<<<<<<< HEAD
++=======
+ 	if (if_index)
+ 		dev_addr.bound_dev_if = *if_index;
+ 	dev_addr.net = &init_net;
++>>>>>>> 200298326b27 (IB/core: Validate route when we init ah)
  
  	ctx.addr = &dev_addr;
  	init_completion(&ctx.comp);
diff --cc drivers/infiniband/core/cm.c
index d070930aadb5,e3a95d1dae57..000000000000
--- a/drivers/infiniband/core/cm.c
+++ b/drivers/infiniband/core/cm.c
@@@ -1636,10 -1641,30 +1636,37 @@@ static int cm_req_handler(struct cm_wor
  	cm_format_paths_from_req(req_msg, &work->path[0], &work->path[1]);
  
  	memcpy(work->path[0].dmac, cm_id_priv->av.ah_attr.dmac, ETH_ALEN);
++<<<<<<< HEAD
 +	ret = cm_init_av_by_path(&work->path[0], &cm_id_priv->av);
 +	if (ret) {
 +		ib_get_cached_gid(work->port->cm_dev->ib_device,
 +				  work->port->port_num, 0, &work->path[0].sgid);
++=======
+ 	ret = ib_get_cached_gid(work->port->cm_dev->ib_device,
+ 				work->port->port_num,
+ 				cm_id_priv->av.ah_attr.grh.sgid_index,
+ 				&gid, &gid_attr);
+ 	if (!ret) {
+ 		if (gid_attr.ndev) {
+ 			work->path[0].ifindex = gid_attr.ndev->ifindex;
+ 			work->path[0].net = dev_net(gid_attr.ndev);
+ 			dev_put(gid_attr.ndev);
+ 		}
+ 		work->path[0].gid_type = gid_attr.gid_type;
+ 		ret = cm_init_av_by_path(&work->path[0], &cm_id_priv->av);
+ 	}
+ 	if (ret) {
+ 		int err = ib_get_cached_gid(work->port->cm_dev->ib_device,
+ 					    work->port->port_num, 0,
+ 					    &work->path[0].sgid,
+ 					    &gid_attr);
+ 		if (!err && gid_attr.ndev) {
+ 			work->path[0].ifindex = gid_attr.ndev->ifindex;
+ 			work->path[0].net = dev_net(gid_attr.ndev);
+ 			dev_put(gid_attr.ndev);
+ 		}
+ 		work->path[0].gid_type = gid_attr.gid_type;
++>>>>>>> 200298326b27 (IB/core: Validate route when we init ah)
  		ib_send_cm_rej(cm_id, IB_CM_REJ_INVALID_GID,
  			       &work->path[0].sgid, sizeof work->path[0].sgid,
  			       NULL, 0);
diff --cc drivers/infiniband/core/cma.c
index 1487f99e0916,fce11dfd0c69..000000000000
--- a/drivers/infiniband/core/cma.c
+++ b/drivers/infiniband/core/cma.c
@@@ -452,9 -454,26 +452,32 @@@ static inline int cma_validate_port(str
  	if ((dev_type != ARPHRD_INFINIBAND) && rdma_protocol_ib(device, port))
  		return ret;
  
++<<<<<<< HEAD
 +	ret = ib_find_cached_gid(device, gid, &found_port, NULL);
 +	if (port != found_port)
 +		return -ENODEV;
++=======
+ 	if (dev_type == ARPHRD_ETHER) {
+ 		ndev = dev_get_by_index(&init_net, bound_if_index);
+ 		if (ndev && ndev->flags & IFF_LOOPBACK) {
+ 			pr_info("detected loopback device\n");
+ 			dev_put(ndev);
+ 
+ 			if (!device->get_netdev)
+ 				return -EOPNOTSUPP;
+ 
+ 			ndev = device->get_netdev(device, port);
+ 			if (!ndev)
+ 				return -ENODEV;
+ 		}
+ 	}
+ 
+ 	ret = ib_find_cached_gid_by_port(device, gid, IB_GID_TYPE_IB, port,
+ 					 ndev, NULL);
+ 
+ 	if (ndev)
+ 		dev_put(ndev);
++>>>>>>> 200298326b27 (IB/core: Validate route when we init ah)
  
  	return ret;
  }
@@@ -2294,8 -2324,26 +2317,29 @@@ static int cma_resolve_iboe_route(struc
  
  	route->num_paths = 1;
  
 -	if (addr->dev_addr.bound_dev_if) {
 +	if (addr->dev_addr.bound_dev_if)
  		ndev = dev_get_by_index(&init_net, addr->dev_addr.bound_dev_if);
++<<<<<<< HEAD
++=======
+ 		if (!ndev)
+ 			return -ENODEV;
+ 
+ 		if (ndev->flags & IFF_LOOPBACK) {
+ 			dev_put(ndev);
+ 			if (!id_priv->id.device->get_netdev)
+ 				return -EOPNOTSUPP;
+ 
+ 			ndev = id_priv->id.device->get_netdev(id_priv->id.device,
+ 							      id_priv->id.port_num);
+ 			if (!ndev)
+ 				return -ENODEV;
+ 		}
+ 
+ 		route->path_rec->net = &init_net;
+ 		route->path_rec->ifindex = ndev->ifindex;
+ 		route->path_rec->gid_type = id_priv->gid_type;
+ 	}
++>>>>>>> 200298326b27 (IB/core: Validate route when we init ah)
  	if (!ndev) {
  		ret = -ENODEV;
  		goto err2;
diff --cc drivers/infiniband/core/sa_query.c
index 6ecb693c496b,e364a42db14d..000000000000
--- a/drivers/infiniband/core/sa_query.c
+++ b/drivers/infiniband/core/sa_query.c
@@@ -1006,25 -1009,88 +1009,95 @@@ int ib_init_ah_from_path(struct ib_devi
  	ah_attr->port_num = port_num;
  	ah_attr->static_rate = rec->rate;
  
- 	force_grh = rdma_cap_eth_ah(device, port_num);
+ 	use_roce = rdma_cap_eth_ah(device, port_num);
  
++<<<<<<< HEAD
 +	if (rec->hop_limit > 1 || force_grh) {
 +		ah_attr->ah_flags = IB_AH_GRH;
 +		ah_attr->grh.dgid = rec->dgid;
 +
 +		ret = ib_find_cached_gid(device, &rec->sgid, &port_num,
 +					 &gid_index);
 +		if (ret)
++=======
+ 	if (use_roce) {
+ 		struct net_device *idev;
+ 		struct net_device *resolved_dev;
+ 		struct rdma_dev_addr dev_addr = {.bound_dev_if = rec->ifindex,
+ 						 .net = rec->net ? rec->net :
+ 							 &init_net};
+ 		union {
+ 			struct sockaddr     _sockaddr;
+ 			struct sockaddr_in  _sockaddr_in;
+ 			struct sockaddr_in6 _sockaddr_in6;
+ 		} sgid_addr, dgid_addr;
+ 
+ 		if (!device->get_netdev)
+ 			return -EOPNOTSUPP;
+ 
+ 		rdma_gid2ip(&sgid_addr._sockaddr, &rec->sgid);
+ 		rdma_gid2ip(&dgid_addr._sockaddr, &rec->dgid);
+ 
+ 		/* validate the route */
+ 		ret = rdma_resolve_ip_route(&sgid_addr._sockaddr,
+ 					    &dgid_addr._sockaddr, &dev_addr);
+ 		if (ret)
+ 			return ret;
+ 
+ 		if ((dev_addr.network == RDMA_NETWORK_IPV4 ||
+ 		     dev_addr.network == RDMA_NETWORK_IPV6) &&
+ 		    rec->gid_type != IB_GID_TYPE_ROCE_UDP_ENCAP)
+ 			return -EINVAL;
+ 
+ 		idev = device->get_netdev(device, port_num);
+ 		if (!idev)
+ 			return -ENODEV;
+ 
+ 		resolved_dev = dev_get_by_index(dev_addr.net,
+ 						dev_addr.bound_dev_if);
+ 		if (resolved_dev->flags & IFF_LOOPBACK) {
+ 			dev_put(resolved_dev);
+ 			resolved_dev = idev;
+ 			dev_hold(resolved_dev);
+ 		}
+ 		ndev = ib_get_ndev_from_path(rec);
+ 		rcu_read_lock();
+ 		if ((ndev && ndev != resolved_dev) ||
+ 		    (resolved_dev != idev &&
+ 		     !rdma_is_upper_dev_rcu(idev, resolved_dev)))
+ 			ret = -EHOSTUNREACH;
+ 		rcu_read_unlock();
+ 		dev_put(idev);
+ 		dev_put(resolved_dev);
+ 		if (ret) {
+ 			if (ndev)
+ 				dev_put(ndev);
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	if (rec->hop_limit > 1 || use_roce) {
+ 		ah_attr->ah_flags = IB_AH_GRH;
+ 		ah_attr->grh.dgid = rec->dgid;
+ 
+ 		ret = ib_find_cached_gid_by_port(device, &rec->sgid,
+ 						 rec->gid_type, port_num, ndev,
+ 						 &gid_index);
+ 		if (ret) {
+ 			if (ndev)
+ 				dev_put(ndev);
++>>>>>>> 200298326b27 (IB/core: Validate route when we init ah)
  			return ret;
 -		}
  
  		ah_attr->grh.sgid_index    = gid_index;
  		ah_attr->grh.flow_label    = be32_to_cpu(rec->flow_label);
  		ah_attr->grh.hop_limit     = rec->hop_limit;
  		ah_attr->grh.traffic_class = rec->traffic_class;
 -		if (ndev)
 -			dev_put(ndev);
  	}
- 	if (force_grh) {
+ 
+ 	if (use_roce)
  		memcpy(ah_attr->dmac, rec->dmac, ETH_ALEN);
- 	}
+ 
  	return 0;
  }
  EXPORT_SYMBOL(ib_init_ah_from_path);
diff --cc drivers/infiniband/core/verbs.c
index 5fbf767fb963,063210be26ed..000000000000
--- a/drivers/infiniband/core/verbs.c
+++ b/drivers/infiniband/core/verbs.c
@@@ -312,21 -435,68 +312,82 @@@ int ib_init_ah_from_wc(struct ib_devic
  
  	memset(ah_attr, 0, sizeof *ah_attr);
  	if (rdma_cap_eth_ah(device, port_num)) {
++<<<<<<< HEAD
 +		if (!(wc->wc_flags & IB_WC_GRH))
 +			return -EPROTOTYPE;
 +
 +		if (wc->wc_flags & IB_WC_WITH_SMAC &&
 +		    wc->wc_flags & IB_WC_WITH_VLAN) {
 +			memcpy(ah_attr->dmac, wc->smac, ETH_ALEN);
 +			ah_attr->vlan_id = wc->vlan_id;
 +		} else {
 +			ret = rdma_addr_find_dmac_by_grh(&grh->dgid, &grh->sgid,
 +					ah_attr->dmac, &ah_attr->vlan_id);
 +			if (ret)
 +				return ret;
 +		}
 +	} else {
 +		ah_attr->vlan_id = 0xffff;
++=======
+ 		if (wc->wc_flags & IB_WC_WITH_NETWORK_HDR_TYPE)
+ 			net_type = wc->network_hdr_type;
+ 		else
+ 			net_type = ib_get_net_type_by_grh(device, port_num, grh);
+ 		gid_type = ib_network_to_gid_type(net_type);
+ 	}
+ 	ret = get_gids_from_rdma_hdr((union rdma_network_hdr *)grh, net_type,
+ 				     &sgid, &dgid);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (rdma_protocol_roce(device, port_num)) {
+ 		int if_index = 0;
+ 		u16 vlan_id = wc->wc_flags & IB_WC_WITH_VLAN ?
+ 				wc->vlan_id : 0xffff;
+ 		struct net_device *idev;
+ 		struct net_device *resolved_dev;
+ 
+ 		if (!(wc->wc_flags & IB_WC_GRH))
+ 			return -EPROTOTYPE;
+ 
+ 		if (!device->get_netdev)
+ 			return -EOPNOTSUPP;
+ 
+ 		idev = device->get_netdev(device, port_num);
+ 		if (!idev)
+ 			return -ENODEV;
+ 
+ 		ret = rdma_addr_find_dmac_by_grh(&dgid, &sgid,
+ 						 ah_attr->dmac,
+ 						 wc->wc_flags & IB_WC_WITH_VLAN ?
+ 						 NULL : &vlan_id,
+ 						 &if_index);
+ 		if (ret) {
+ 			dev_put(idev);
+ 			return ret;
+ 		}
+ 
+ 		resolved_dev = dev_get_by_index(&init_net, if_index);
+ 		if (resolved_dev->flags & IFF_LOOPBACK) {
+ 			dev_put(resolved_dev);
+ 			resolved_dev = idev;
+ 			dev_hold(resolved_dev);
+ 		}
+ 		rcu_read_lock();
+ 		if (resolved_dev != idev && !rdma_is_upper_dev_rcu(idev,
+ 								   resolved_dev))
+ 			ret = -EHOSTUNREACH;
+ 		rcu_read_unlock();
+ 		dev_put(idev);
+ 		dev_put(resolved_dev);
+ 		if (ret)
+ 			return ret;
+ 
+ 		ret = get_sgid_index_from_eth(device, port_num, vlan_id,
+ 					      &dgid, gid_type, &gid_index);
+ 		if (ret)
+ 			return ret;
++>>>>>>> 200298326b27 (IB/core: Validate route when we init ah)
  	}
  
  	ah_attr->dlid = wc->slid;
@@@ -973,35 -1118,53 +1034,54 @@@ int ib_modify_qp_is_ok(enum ib_qp_stat
  }
  EXPORT_SYMBOL(ib_modify_qp_is_ok);
  
 -int ib_resolve_eth_dmac(struct ib_qp *qp,
 -			struct ib_qp_attr *qp_attr, int *qp_attr_mask)
 +int ib_resolve_eth_l2_attrs(struct ib_qp *qp,
 +			    struct ib_qp_attr *qp_attr, int *qp_attr_mask)
  {
  	int           ret = 0;
 +	union ib_gid  sgid;
  
 -	if (*qp_attr_mask & IB_QP_AV) {
 -		if (qp_attr->ah_attr.port_num < rdma_start_port(qp->device) ||
 -		    qp_attr->ah_attr.port_num > rdma_end_port(qp->device))
 -			return -EINVAL;
 -
 -		if (!rdma_cap_eth_ah(qp->device, qp_attr->ah_attr.port_num))
 -			return 0;
 -
 +	if ((*qp_attr_mask & IB_QP_AV)  &&
 +	    (rdma_cap_eth_ah(qp->device, qp_attr->ah_attr.port_num))) {
 +		ret = ib_query_gid(qp->device, qp_attr->ah_attr.port_num,
 +				   qp_attr->ah_attr.grh.sgid_index, &sgid);
 +		if (ret)
 +			goto out;
  		if (rdma_link_local_addr((struct in6_addr *)qp_attr->ah_attr.grh.dgid.raw)) {
 -			rdma_get_ll_mac((struct in6_addr *)qp_attr->ah_attr.grh.dgid.raw,
 -					qp_attr->ah_attr.dmac);
 +			rdma_get_ll_mac((struct in6_addr *)qp_attr->ah_attr.grh.dgid.raw, qp_attr->ah_attr.dmac);
 +			rdma_get_ll_mac((struct in6_addr *)sgid.raw, qp_attr->smac);
 +			if (!(*qp_attr_mask & IB_QP_VID))
 +				qp_attr->vlan_id = rdma_get_vlan_id(&sgid);
  		} else {
 -			union ib_gid		sgid;
 -			struct ib_gid_attr	sgid_attr;
 -			int			ifindex;
 -
 -			ret = ib_query_gid(qp->device,
 -					   qp_attr->ah_attr.port_num,
 -					   qp_attr->ah_attr.grh.sgid_index,
 -					   &sgid, &sgid_attr);
 -
 -			if (ret || !sgid_attr.ndev) {
 -				if (!ret)
 -					ret = -ENXIO;
 +			ret = rdma_addr_find_dmac_by_grh(&sgid, &qp_attr->ah_attr.grh.dgid,
 +					qp_attr->ah_attr.dmac, &qp_attr->vlan_id);
 +			if (ret)
 +				goto out;
 +			ret = rdma_addr_find_smac_by_sgid(&sgid, qp_attr->smac, NULL);
 +			if (ret)
  				goto out;
++<<<<<<< HEAD
++=======
+ 			}
+ 			if (sgid_attr.gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP)
+ 				/* TODO: get the hoplimit from the inet/inet6
+ 				 * device
+ 				 */
+ 				qp_attr->ah_attr.grh.hop_limit =
+ 							IPV6_DEFAULT_HOPLIMIT;
+ 
+ 			ifindex = sgid_attr.ndev->ifindex;
+ 
+ 			ret = rdma_addr_find_dmac_by_grh(&sgid,
+ 							 &qp_attr->ah_attr.grh.dgid,
+ 							 qp_attr->ah_attr.dmac,
+ 							 NULL, &ifindex);
+ 
+ 			dev_put(sgid_attr.ndev);
++>>>>>>> 200298326b27 (IB/core: Validate route when we init ah)
  		}
 +		*qp_attr_mask |= IB_QP_SMAC;
 +		if (qp_attr->vlan_id < 0xFFFF)
 +			*qp_attr_mask |= IB_QP_VID;
  	}
  out:
  	return ret;
diff --cc drivers/infiniband/hw/ocrdma/ocrdma_ah.c
index 6836aea6a876,a343e0377bf6..000000000000
--- a/drivers/infiniband/hw/ocrdma/ocrdma_ah.c
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_ah.c
@@@ -146,10 -153,11 +146,15 @@@ struct ib_ah *ocrdma_create_ah(struct i
  	    (!rdma_is_multicast_addr((struct in6_addr *)attr->grh.dgid.raw)) &&
  	    (!rdma_link_local_addr((struct in6_addr *)attr->grh.dgid.raw))) {
  		status = rdma_addr_find_dmac_by_grh(&sgid, &attr->grh.dgid,
++<<<<<<< HEAD
 +						    attr->dmac, &attr->vlan_id);
++=======
+ 						    attr->dmac, &vlan_tag,
+ 						    &sgid_attr.ndev->ifindex);
++>>>>>>> 200298326b27 (IB/core: Validate route when we init ah)
  		if (status) {
 -			pr_err("%s(): Failed to resolve dmac from gid." 
 -				"status = %d\n", __func__, status);
 +			pr_err("%s(): Failed to resolve dmac from gid. status = %d\n",
 +			       __func__, status);
  			goto av_conf_err;
  		}
  	}
diff --cc include/rdma/ib_addr.h
index fde33ac6b58a,87156dcb73bb..000000000000
--- a/include/rdma/ib_addr.h
+++ b/include/rdma/ib_addr.h
@@@ -76,9 -89,11 +76,9 @@@ struct rdma_dev_addr 
  /**
   * rdma_translate_ip - Translate a local IP address to an RDMA hardware
   *   address.
 - *
 - * The dev_addr->net field must be initialized.
   */
- int rdma_translate_ip(struct sockaddr *addr, struct rdma_dev_addr *dev_addr,
- 		      u16 *vlan_id);
+ int rdma_translate_ip(const struct sockaddr *addr,
+ 		      struct rdma_dev_addr *dev_addr, u16 *vlan_id);
  
  /**
   * rdma_resolve_ip - Resolve source and destination IP addresses to
@@@ -112,7 -131,7 +116,11 @@@ int rdma_addr_size(struct sockaddr *add
  
  int rdma_addr_find_smac_by_sgid(union ib_gid *sgid, u8 *smac, u16 *vlan_id);
  int rdma_addr_find_dmac_by_grh(const union ib_gid *sgid, const union ib_gid *dgid,
++<<<<<<< HEAD
 +			       u8 *smac, u16 *vlan_id);
++=======
+ 			       u8 *smac, u16 *vlan_id, int *if_index);
++>>>>>>> 200298326b27 (IB/core: Validate route when we init ah)
  
  static inline u16 ib_addr_get_pkey(struct rdma_dev_addr *dev_addr)
  {
* Unmerged path drivers/infiniband/core/addr.c
* Unmerged path drivers/infiniband/core/cm.c
* Unmerged path drivers/infiniband/core/cma.c
* Unmerged path drivers/infiniband/core/sa_query.c
* Unmerged path drivers/infiniband/core/verbs.c
* Unmerged path drivers/infiniband/hw/ocrdma/ocrdma_ah.c
* Unmerged path include/rdma/ib_addr.h
