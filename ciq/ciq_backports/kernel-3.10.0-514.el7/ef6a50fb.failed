xfs: introduce table-based init for error behaviors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Carlos Maiolino <cmaiolino@redhat.com>
commit ef6a50fbb1bba7951aa23adcfb40e99ca72dc51c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ef6a50fb.failed

Before we start expanding the number of error classes and errors we
can configure behaviour for, we need a simple and clear way to
define the default behaviour that we initialized each mount with.
Introduce a table based method for keeping the initial configuration
in, and apply that to the existing initialization code.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Carlos Maiolino <cmaiolino@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit ef6a50fbb1bba7951aa23adcfb40e99ca72dc51c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_sysfs.c
diff --cc fs/xfs/xfs_sysfs.c
index 641d625eb334,71046d904985..000000000000
--- a/fs/xfs/xfs_sysfs.c
+++ b/fs/xfs/xfs_sysfs.c
@@@ -304,3 -363,152 +304,155 @@@ struct kobj_type xfs_log_ktype = 
  	.sysfs_ops = &xfs_sysfs_ops,
  	.default_attrs = xfs_log_attrs,
  };
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Metadata IO error configuration
+  *
+  * The sysfs structure here is:
+  *	...xfs/<dev>/error/<class>/<errno>/<error_attrs>
+  *
+  * where <class> allows us to discriminate between data IO and metadata IO,
+  * and any other future type of IO (e.g. special inode or directory error
+  * handling) we care to support.
+  */
+ static struct attribute *xfs_error_attrs[] = {
+ 	NULL,
+ };
+ 
+ static inline struct xfs_error_cfg *
+ to_error_cfg(struct kobject *kobject)
+ {
+ 	struct xfs_kobj *kobj = to_kobj(kobject);
+ 	return container_of(kobj, struct xfs_error_cfg, kobj);
+ }
+ 
+ struct kobj_type xfs_error_cfg_ktype = {
+ 	.release = xfs_sysfs_release,
+ 	.sysfs_ops = &xfs_sysfs_ops,
+ 	.default_attrs = xfs_error_attrs,
+ };
+ 
+ struct kobj_type xfs_error_ktype = {
+ 	.release = xfs_sysfs_release,
+ };
+ 
+ /*
+  * Error initialization tables. These need to be ordered in the same
+  * order as the enums used to index the array. All class init tables need to
+  * define a "default" behaviour as the first entry, all other entries can be
+  * empty.
+  */
+ struct xfs_error_init {
+ 	char		*name;
+ 	int		max_retries;
+ };
+ 
+ static const struct xfs_error_init xfs_error_meta_init[XFS_ERR_ERRNO_MAX] = {
+ 	{ .name = "default",
+ 	  .max_retries = -1,
+ 	},
+ };
+ 
+ static int
+ xfs_error_sysfs_init_class(
+ 	struct xfs_mount	*mp,
+ 	int			class,
+ 	const char		*parent_name,
+ 	struct xfs_kobj		*parent_kobj,
+ 	const struct xfs_error_init init[])
+ {
+ 	struct xfs_error_cfg	*cfg;
+ 	int			error;
+ 	int			i;
+ 
+ 	ASSERT(class < XFS_ERR_CLASS_MAX);
+ 
+ 	error = xfs_sysfs_init(parent_kobj, &xfs_error_ktype,
+ 				&mp->m_error_kobj, parent_name);
+ 	if (error)
+ 		return error;
+ 
+ 	for (i = 0; i < XFS_ERR_ERRNO_MAX; i++) {
+ 		cfg = &mp->m_error_cfg[class][i];
+ 		error = xfs_sysfs_init(&cfg->kobj, &xfs_error_cfg_ktype,
+ 					parent_kobj, init[i].name);
+ 		if (error)
+ 			goto out_error;
+ 
+ 		cfg->max_retries = init[i].max_retries;
+ 	}
+ 	return 0;
+ 
+ out_error:
+ 	/* unwind the entries that succeeded */
+ 	for (i--; i >= 0; i--) {
+ 		cfg = &mp->m_error_cfg[class][i];
+ 		xfs_sysfs_del(&cfg->kobj);
+ 	}
+ 	xfs_sysfs_del(parent_kobj);
+ 	return error;
+ }
+ 
+ int
+ xfs_error_sysfs_init(
+ 	struct xfs_mount	*mp)
+ {
+ 	int			error;
+ 
+ 	/* .../xfs/<dev>/error/ */
+ 	error = xfs_sysfs_init(&mp->m_error_kobj, &xfs_error_ktype,
+ 				&mp->m_kobj, "error");
+ 	if (error)
+ 		return error;
+ 
+ 	/* .../xfs/<dev>/error/metadata/ */
+ 	error = xfs_error_sysfs_init_class(mp, XFS_ERR_METADATA,
+ 				"metadata", &mp->m_error_meta_kobj,
+ 				xfs_error_meta_init);
+ 	if (error)
+ 		goto out_error;
+ 
+ 	return 0;
+ 
+ out_error:
+ 	xfs_sysfs_del(&mp->m_error_kobj);
+ 	return error;
+ }
+ 
+ void
+ xfs_error_sysfs_del(
+ 	struct xfs_mount	*mp)
+ {
+ 	struct xfs_error_cfg	*cfg;
+ 	int			i, j;
+ 
+ 	for (i = 0; i < XFS_ERR_CLASS_MAX; i++) {
+ 		for (j = 0; j < XFS_ERR_ERRNO_MAX; j++) {
+ 			cfg = &mp->m_error_cfg[i][j];
+ 
+ 			xfs_sysfs_del(&cfg->kobj);
+ 		}
+ 	}
+ 	xfs_sysfs_del(&mp->m_error_meta_kobj);
+ 	xfs_sysfs_del(&mp->m_error_kobj);
+ }
+ 
+ struct xfs_error_cfg *
+ xfs_error_get_cfg(
+ 	struct xfs_mount	*mp,
+ 	int			error_class,
+ 	int			error)
+ {
+ 	struct xfs_error_cfg	*cfg;
+ 
+ 	switch (error) {
+ 	default:
+ 		cfg = &mp->m_error_cfg[error_class][XFS_ERR_DEFAULT];
+ 		break;
+ 	}
+ 
+ 	return cfg;
+ }
++>>>>>>> ef6a50fbb1bb (xfs: introduce table-based init for error behaviors)
* Unmerged path fs/xfs/xfs_sysfs.c
