tunnels: Don't require remote endpoint or ID during creation.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] tunnels: Don't require remote endpoint or ID during creation (Lance Richardson) [1283886]
Rebuild_FUZZ: 99.17%
commit-author Jesse Gross <jesse@nicira.com>
commit e277de5f3f7d6eed2a41920983c44c4df386b871
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e277de5f.failed

Before lightweight tunnels existed, it really didn't make sense to
create a tunnel that was not fully specified, such as without a
destination IP address - the resulting packets would go nowhere.
However, with lightweight tunnels, the opposite is true - it doesn't
make sense to require this information when it will be provided later
on by the route. This loosens the requirements for this information.

An alternative would be to allow the relaxed version only when
COLLECT_METADATA is enabled. However, since there are several
variations on this theme (such as NBMA tunnels in GRE), just dropping
the restrictions seems the most consistent across tunnels and with
the existing configuration.

CC: John Linville <linville@tuxdriver.com>
	Signed-off-by: Jesse Gross <jesse@nicira.com>
	Signed-off-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e277de5f3f7d6eed2a41920983c44c4df386b871)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 4e5b7ab9acd0,afdc65fd5bc5..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -2743,6 -2715,150 +2743,153 @@@ static int vxlan_newlink(struct net *sr
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ struct net_device *vxlan_dev_create(struct net *net, const char *name,
+ 				    u8 name_assign_type, struct vxlan_config *conf)
+ {
+ 	struct nlattr *tb[IFLA_MAX+1];
+ 	struct net_device *dev;
+ 	int err;
+ 
+ 	memset(&tb, 0, sizeof(tb));
+ 
+ 	dev = rtnl_create_link(net, name, name_assign_type,
+ 			       &vxlan_link_ops, tb);
+ 	if (IS_ERR(dev))
+ 		return dev;
+ 
+ 	err = vxlan_dev_configure(net, dev, conf);
+ 	if (err < 0) {
+ 		free_netdev(dev);
+ 		return ERR_PTR(err);
+ 	}
+ 
+ 	return dev;
+ }
+ EXPORT_SYMBOL_GPL(vxlan_dev_create);
+ 
+ static int vxlan_newlink(struct net *src_net, struct net_device *dev,
+ 			 struct nlattr *tb[], struct nlattr *data[])
+ {
+ 	struct vxlan_config conf;
+ 	int err;
+ 
+ 	memset(&conf, 0, sizeof(conf));
+ 
+ 	if (data[IFLA_VXLAN_ID])
+ 		conf.vni = nla_get_u32(data[IFLA_VXLAN_ID]);
+ 
+ 	if (data[IFLA_VXLAN_GROUP]) {
+ 		conf.remote_ip.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_GROUP]);
+ 	} else if (data[IFLA_VXLAN_GROUP6]) {
+ 		if (!IS_ENABLED(CONFIG_IPV6))
+ 			return -EPFNOSUPPORT;
+ 
+ 		conf.remote_ip.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_GROUP6]);
+ 		conf.remote_ip.sa.sa_family = AF_INET6;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_LOCAL]) {
+ 		conf.saddr.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_LOCAL]);
+ 		conf.saddr.sa.sa_family = AF_INET;
+ 	} else if (data[IFLA_VXLAN_LOCAL6]) {
+ 		if (!IS_ENABLED(CONFIG_IPV6))
+ 			return -EPFNOSUPPORT;
+ 
+ 		/* TODO: respect scope id */
+ 		conf.saddr.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_LOCAL6]);
+ 		conf.saddr.sa.sa_family = AF_INET6;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_LINK])
+ 		conf.remote_ifindex = nla_get_u32(data[IFLA_VXLAN_LINK]);
+ 
+ 	if (data[IFLA_VXLAN_TOS])
+ 		conf.tos  = nla_get_u8(data[IFLA_VXLAN_TOS]);
+ 
+ 	if (data[IFLA_VXLAN_TTL])
+ 		conf.ttl = nla_get_u8(data[IFLA_VXLAN_TTL]);
+ 
+ 	if (!data[IFLA_VXLAN_LEARNING] || nla_get_u8(data[IFLA_VXLAN_LEARNING]))
+ 		conf.flags |= VXLAN_F_LEARN;
+ 
+ 	if (data[IFLA_VXLAN_AGEING])
+ 		conf.age_interval = nla_get_u32(data[IFLA_VXLAN_AGEING]);
+ 
+ 	if (data[IFLA_VXLAN_PROXY] && nla_get_u8(data[IFLA_VXLAN_PROXY]))
+ 		conf.flags |= VXLAN_F_PROXY;
+ 
+ 	if (data[IFLA_VXLAN_RSC] && nla_get_u8(data[IFLA_VXLAN_RSC]))
+ 		conf.flags |= VXLAN_F_RSC;
+ 
+ 	if (data[IFLA_VXLAN_L2MISS] && nla_get_u8(data[IFLA_VXLAN_L2MISS]))
+ 		conf.flags |= VXLAN_F_L2MISS;
+ 
+ 	if (data[IFLA_VXLAN_L3MISS] && nla_get_u8(data[IFLA_VXLAN_L3MISS]))
+ 		conf.flags |= VXLAN_F_L3MISS;
+ 
+ 	if (data[IFLA_VXLAN_LIMIT])
+ 		conf.addrmax = nla_get_u32(data[IFLA_VXLAN_LIMIT]);
+ 
+ 	if (data[IFLA_VXLAN_COLLECT_METADATA] &&
+ 	    nla_get_u8(data[IFLA_VXLAN_COLLECT_METADATA]))
+ 		conf.flags |= VXLAN_F_COLLECT_METADATA;
+ 
+ 	if (data[IFLA_VXLAN_PORT_RANGE]) {
+ 		const struct ifla_vxlan_port_range *p
+ 			= nla_data(data[IFLA_VXLAN_PORT_RANGE]);
+ 		conf.port_min = ntohs(p->low);
+ 		conf.port_max = ntohs(p->high);
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_PORT])
+ 		conf.dst_port = nla_get_be16(data[IFLA_VXLAN_PORT]);
+ 
+ 	if (data[IFLA_VXLAN_UDP_CSUM] && nla_get_u8(data[IFLA_VXLAN_UDP_CSUM]))
+ 		conf.flags |= VXLAN_F_UDP_CSUM;
+ 
+ 	if (data[IFLA_VXLAN_UDP_ZERO_CSUM6_TX] &&
+ 	    nla_get_u8(data[IFLA_VXLAN_UDP_ZERO_CSUM6_TX]))
+ 		conf.flags |= VXLAN_F_UDP_ZERO_CSUM6_TX;
+ 
+ 	if (data[IFLA_VXLAN_UDP_ZERO_CSUM6_RX] &&
+ 	    nla_get_u8(data[IFLA_VXLAN_UDP_ZERO_CSUM6_RX]))
+ 		conf.flags |= VXLAN_F_UDP_ZERO_CSUM6_RX;
+ 
+ 	if (data[IFLA_VXLAN_REMCSUM_TX] &&
+ 	    nla_get_u8(data[IFLA_VXLAN_REMCSUM_TX]))
+ 		conf.flags |= VXLAN_F_REMCSUM_TX;
+ 
+ 	if (data[IFLA_VXLAN_REMCSUM_RX] &&
+ 	    nla_get_u8(data[IFLA_VXLAN_REMCSUM_RX]))
+ 		conf.flags |= VXLAN_F_REMCSUM_RX;
+ 
+ 	if (data[IFLA_VXLAN_GBP])
+ 		conf.flags |= VXLAN_F_GBP;
+ 
+ 	if (data[IFLA_VXLAN_REMCSUM_NOPARTIAL])
+ 		conf.flags |= VXLAN_F_REMCSUM_NOPARTIAL;
+ 
+ 	err = vxlan_dev_configure(src_net, dev, &conf);
+ 	switch (err) {
+ 	case -ENODEV:
+ 		pr_info("ifindex %d does not exist\n", conf.remote_ifindex);
+ 		break;
+ 
+ 	case -EPERM:
+ 		pr_info("IPv6 is disabled via sysctl\n");
+ 		break;
+ 
+ 	case -EEXIST:
+ 		pr_info("duplicate VNI %u\n", conf.vni);
+ 		break;
+ 	}
+ 
+ 	return err;
+ }
+ 
++>>>>>>> e277de5f3f7d (tunnels: Don't require remote endpoint or ID during creation.)
  static void vxlan_dellink(struct net_device *dev, struct list_head *head)
  {
  	struct vxlan_dev *vxlan = netdev_priv(dev);
diff --git a/drivers/net/geneve.c b/drivers/net/geneve.c
index 61619a003943..5ff2fbc76ad0 100644
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@ -871,14 +871,14 @@ static int geneve_newlink(struct net *net, struct net_device *dev,
 	__be16 dst_port = htons(GENEVE_UDP_PORT);
 	__u8 ttl = 0, tos = 0;
 	bool metadata = false;
-	__be32 rem_addr;
-	__u32 vni;
+	__be32 rem_addr = 0;
+	__u32 vni = 0;
 
-	if (!data[IFLA_GENEVE_ID] || !data[IFLA_GENEVE_REMOTE])
-		return -EINVAL;
+	if (data[IFLA_GENEVE_ID])
+		vni = nla_get_u32(data[IFLA_GENEVE_ID]);
 
-	vni = nla_get_u32(data[IFLA_GENEVE_ID]);
-	rem_addr = nla_get_in_addr(data[IFLA_GENEVE_REMOTE]);
+	if (data[IFLA_GENEVE_REMOTE])
+		rem_addr = nla_get_in_addr(data[IFLA_GENEVE_REMOTE]);
 
 	if (data[IFLA_GENEVE_TTL])
 		ttl = nla_get_u8(data[IFLA_GENEVE_TTL]);
* Unmerged path drivers/net/vxlan.c
