KVM: arm/mips/x86/power use __kvm_guest_{enter|exit}

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christian Borntraeger <borntraeger@de.ibm.com>
commit ccf73aaf5adfa37f45be12459c17f534e8f2c2c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ccf73aaf.failed

Use __kvm_guest_{enter|exit} instead of kvm_guest_{enter|exit}
where interrupts are disabled.

	Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit ccf73aaf5adfa37f45be12459c17f534e8f2c2c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/kvm/arm.c
#	arch/mips/kvm/kvm_mips.c
diff --cc arch/arm/kvm/arm.c
index 66df4c62bc78,e41cb11f71b2..000000000000
--- a/arch/arm/kvm/arm.c
+++ b/arch/arm/kvm/arm.c
@@@ -577,9 -559,8 +577,14 @@@ int kvm_arch_vcpu_ioctl_run(struct kvm_
  		ret = kvm_call_hyp(__kvm_vcpu_run, vcpu);
  
  		vcpu->mode = OUTSIDE_GUEST_MODE;
++<<<<<<< HEAD
 +		vcpu->arch.last_pcpu = smp_processor_id();
 +		kvm_guest_exit();
 +		trace_kvm_exit(*vcpu_pc(vcpu));
++=======
+ 		__kvm_guest_exit();
+ 		trace_kvm_exit(kvm_vcpu_trap_get_class(vcpu), *vcpu_pc(vcpu));
++>>>>>>> ccf73aaf5adf (KVM: arm/mips/x86/power use __kvm_guest_{enter|exit})
  		/*
  		 * We may have taken a host interrupt in HYP mode (ie
  		 * while executing the guest). This interrupt is still
diff --cc arch/mips/kvm/kvm_mips.c
index 7ff0f3faa905,71f345b499c8..000000000000
--- a/arch/mips/kvm/kvm_mips.c
+++ b/arch/mips/kvm/kvm_mips.c
@@@ -427,12 -393,17 +427,23 @@@ int kvm_arch_vcpu_ioctl_run(struct kvm_
  	kvm_mips_deliver_interrupts(vcpu,
  				    kvm_read_c0_guest_cause(vcpu->arch.cop0));
  
++<<<<<<< HEAD:arch/mips/kvm/kvm_mips.c
 +	local_irq_disable();
 +	kvm_guest_enter();
++=======
+ 	__kvm_guest_enter();
 -
 -	/* Disable hardware page table walking while in guest */
 -	htw_stop();
++>>>>>>> ccf73aaf5adf (KVM: arm/mips/x86/power use __kvm_guest_{enter|exit}):arch/mips/kvm/mips.c
  
  	r = __kvm_mips_vcpu_run(run, vcpu);
  
++<<<<<<< HEAD:arch/mips/kvm/kvm_mips.c
 +	kvm_guest_exit();
++=======
+ 	/* Re-enable HTW before enabling interrupts */
+ 	htw_start();
+ 
+ 	__kvm_guest_exit();
++>>>>>>> ccf73aaf5adf (KVM: arm/mips/x86/power use __kvm_guest_{enter|exit}):arch/mips/kvm/mips.c
  	local_irq_enable();
  
  	if (vcpu->sigset_active)
* Unmerged path arch/arm/kvm/arm.c
* Unmerged path arch/mips/kvm/kvm_mips.c
diff --git a/arch/powerpc/kvm/powerpc.c b/arch/powerpc/kvm/powerpc.c
index 3cb4118fa519..fada1d12648c 100644
--- a/arch/powerpc/kvm/powerpc.c
+++ b/arch/powerpc/kvm/powerpc.c
@@ -115,7 +115,7 @@ int kvmppc_prepare_to_enter(struct kvm_vcpu *vcpu)
 			continue;
 		}
 
-		kvm_guest_enter();
+		__kvm_guest_enter();
 		return 1;
 	}
 
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index de608714ef13..eb5ed1229e58 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -6752,7 +6752,7 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 	if (req_immediate_exit)
 		smp_send_reschedule(vcpu->cpu);
 
-	kvm_guest_enter();
+	__kvm_guest_enter();
 
 	if (unlikely(vcpu->arch.switch_db_regs)) {
 		set_debugreg(0, 7);
