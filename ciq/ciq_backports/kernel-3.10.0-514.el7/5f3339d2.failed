perf thread_map: Add thread_map user level event

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 5f3339d2e83ca587c2e13c3e37e1b5fb7c68ebe5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5f3339d2.failed

Adding the thread_map event to pass/store thread maps as data in
the pipe/perf.data.

Storing the thread ID along with the standard comm[16] thread name string.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Kan Liang <kan.liang@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1445784728-21732-4-git-send-email-jolsa@kernel.org
[ Renamed thread_map_data_event to thread_map_event_entry ]
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 5f3339d2e83ca587c2e13c3e37e1b5fb7c68ebe5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/event.h
diff --cc tools/perf/util/event.h
index 9400ef1c1335,66f303e69c4d..000000000000
--- a/tools/perf/util/event.h
+++ b/tools/perf/util/event.h
@@@ -350,6 -351,23 +351,26 @@@ struct itrace_start_event 
  	u32 pid, tid;
  };
  
++<<<<<<< HEAD
++=======
+ struct context_switch_event {
+ 	struct perf_event_header header;
+ 	u32 next_prev_pid;
+ 	u32 next_prev_tid;
+ };
+ 
+ struct thread_map_event_entry {
+ 	u64	pid;
+ 	char	comm[16];
+ };
+ 
+ struct thread_map_event {
+ 	struct perf_event_header	header;
+ 	u64				nr;
+ 	struct thread_map_event_entry	entries[];
+ };
+ 
++>>>>>>> 5f3339d2e83c (perf thread_map: Add thread_map user level event)
  union perf_event {
  	struct perf_event_header	header;
  	struct mmap_event		mmap;
@@@ -371,6 -389,8 +392,11 @@@
  	struct auxtrace_error_event	auxtrace_error;
  	struct aux_event		aux;
  	struct itrace_start_event	itrace_start;
++<<<<<<< HEAD
++=======
+ 	struct context_switch_event	context_switch;
+ 	struct thread_map_event		thread_map;
++>>>>>>> 5f3339d2e83c (perf thread_map: Add thread_map user level event)
  };
  
  void perf_event__print_totals(void);
diff --git a/tools/perf/util/event.c b/tools/perf/util/event.c
index 763fbcde76fc..4ade38a1edfd 100644
--- a/tools/perf/util/event.c
+++ b/tools/perf/util/event.c
@@ -35,6 +35,7 @@ static const char *perf_event__names[] = {
 	[PERF_RECORD_AUXTRACE_INFO]		= "AUXTRACE_INFO",
 	[PERF_RECORD_AUXTRACE]			= "AUXTRACE",
 	[PERF_RECORD_AUXTRACE_ERROR]		= "AUXTRACE_ERROR",
+	[PERF_RECORD_THREAD_MAP]		= "THREAD_MAP",
 };
 
 const char *perf_event__name(unsigned int id)
* Unmerged path tools/perf/util/event.h
diff --git a/tools/perf/util/session.c b/tools/perf/util/session.c
index 5c19125e63db..0c0651b9c3de 100644
--- a/tools/perf/util/session.c
+++ b/tools/perf/util/session.c
@@ -296,6 +296,16 @@ int process_event_auxtrace_error_stub(struct perf_tool *tool __maybe_unused,
 	return 0;
 }
 
+
+static
+int process_event_thread_map_stub(struct perf_tool *tool __maybe_unused,
+				  union perf_event *event __maybe_unused,
+				  struct perf_session *session __maybe_unused)
+{
+	dump_printf(": unhandled!\n");
+	return 0;
+}
+
 void perf_tool__fill_defaults(struct perf_tool *tool)
 {
 	if (tool->sample == NULL)
@@ -344,6 +354,8 @@ void perf_tool__fill_defaults(struct perf_tool *tool)
 		tool->auxtrace = process_event_auxtrace_stub;
 	if (tool->auxtrace_error == NULL)
 		tool->auxtrace_error = process_event_auxtrace_error_stub;
+	if (tool->thread_map == NULL)
+		tool->thread_map = process_event_thread_map_stub;
 }
 
 static void swap_sample_id_all(union perf_event *event, void *data)
@@ -601,6 +613,17 @@ static void perf_event__auxtrace_error_swap(union perf_event *event,
 	event->auxtrace_error.ip   = bswap_64(event->auxtrace_error.ip);
 }
 
+static void perf_event__thread_map_swap(union perf_event *event,
+					bool sample_id_all __maybe_unused)
+{
+	unsigned i;
+
+	event->thread_map.nr = bswap_64(event->thread_map.nr);
+
+	for (i = 0; i < event->thread_map.nr; i++)
+		event->thread_map.entries[i].pid = bswap_64(event->thread_map.entries[i].pid);
+}
+
 typedef void (*perf_event__swap_op)(union perf_event *event,
 				    bool sample_id_all);
 
@@ -626,6 +649,7 @@ static perf_event__swap_op perf_event__swap_ops[] = {
 	[PERF_RECORD_AUXTRACE_INFO]	  = perf_event__auxtrace_info_swap,
 	[PERF_RECORD_AUXTRACE]		  = perf_event__auxtrace_swap,
 	[PERF_RECORD_AUXTRACE_ERROR]	  = perf_event__auxtrace_error_swap,
+	[PERF_RECORD_THREAD_MAP]	  = perf_event__thread_map_swap,
 	[PERF_RECORD_HEADER_MAX]	  = NULL,
 };
 
@@ -1159,6 +1183,8 @@ static s64 perf_session__process_user_event(struct perf_session *session,
 	case PERF_RECORD_AUXTRACE_ERROR:
 		perf_session__auxtrace_error_inc(session, event);
 		return tool->auxtrace_error(tool, event, session);
+	case PERF_RECORD_THREAD_MAP:
+		return tool->thread_map(tool, event, session);
 	default:
 		return -EINVAL;
 	}
diff --git a/tools/perf/util/tool.h b/tools/perf/util/tool.h
index c307dd438286..cbaffbeb5b18 100644
--- a/tools/perf/util/tool.h
+++ b/tools/perf/util/tool.h
@@ -54,7 +54,8 @@ struct perf_tool {
 	event_op2	build_id,
 			id_index,
 			auxtrace_info,
-			auxtrace_error;
+			auxtrace_error,
+			thread_map;
 	event_op3	auxtrace;
 	bool		ordered_events;
 	bool		ordering_requires_timestamps;
