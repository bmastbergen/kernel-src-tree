mei: bus: simplify how we build nfc bus name

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit b39910c2e0ac7c3d0e2f1999b04308c771b1d8fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b39910c2.failed

Remove the dependency on struct ndev from the nfc device
name creation function so it is possible to use it
in a fixup routine

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit b39910c2e0ac7c3d0e2f1999b04308c771b1d8fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/bus-fixup.c
#	drivers/misc/mei/bus.c
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/bus-fixup.c
index 2b65e8021f0d,a4c6719d36b4..000000000000
--- a/drivers/misc/mei/bus-fixup.c
+++ b/drivers/misc/mei/bus-fixup.c
@@@ -104,14 -145,9 +104,18 @@@ struct mei_nfc_dev 
  	u8 fw_ivn;
  	u8 vendor_id;
  	u8 radio_type;
++<<<<<<< HEAD
 +	char *bus_name;
 +
 +	u16 req_id;
 +	u16 recv_req_id;
++=======
+ 	const char *bus_name;
++>>>>>>> b39910c2e0ac (mei: bus: simplify how we build nfc bus name)
  };
  
 +static struct mei_nfc_dev nfc_dev;
 +
  /* UUIDs for NFC F/W clients */
  const uuid_le mei_nfc_guid = UUID_LE(0x0bb17a78, 0x2a8e, 0x4c50,
  				     0x94, 0xd4, 0x50, 0x26,
@@@ -143,143 -180,38 +147,161 @@@ static void mei_nfc_free(struct mei_nfc
  		kfree(ndev->cl_info);
  	}
  
 -	mei_me_cl_put(ndev->me_cl);
 -	kfree(ndev);
 +	memset(ndev, 0, sizeof(struct mei_nfc_dev));
  }
  
- static int mei_nfc_build_bus_name(struct mei_nfc_dev *ndev)
+ /**
+  * mei_nfc_if_version - get NFC interface version
+  *
+  * @cl: host client (nfc info)
+  * @ver: NFC interface version to be filled in
+  *
+  * Return: 0 on success; < 0 otherwise
+  */
+ static int mei_nfc_if_version(struct mei_cl *cl,
+ 			      struct mei_nfc_if_version *ver)
  {
++<<<<<<< HEAD
 +	struct mei_device *dev;
 +
 +	if (!ndev->cl)
 +		return -ENODEV;
 +
 +	dev = ndev->cl->dev;
 +
 +	switch (ndev->vendor_id) {
 +	case MEI_NFC_VENDOR_INSIDE:
 +		switch (ndev->radio_type) {
 +		case MEI_NFC_VENDOR_INSIDE_UREAD:
 +			ndev->bus_name = "microread";
 +			return 0;
 +
 +		default:
 +			dev_err(&dev->pdev->dev, "Unknown radio type 0x%x\n",
 +				ndev->radio_type);
 +
 +			return -EINVAL;
 +		}
 +
 +	case MEI_NFC_VENDOR_NXP:
 +		switch (ndev->radio_type) {
 +		case MEI_NFC_VENDOR_NXP_PN544:
 +			ndev->bus_name = "pn544";
 +			return 0;
 +		default:
 +			dev_err(&dev->pdev->dev, "Unknown radio type 0x%x\n",
 +				ndev->radio_type);
 +
 +			return -EINVAL;
 +		}
 +
 +	default:
 +		dev_err(&dev->pdev->dev, "Unknown vendor ID 0x%x\n",
 +			ndev->vendor_id);
 +
 +		return -EINVAL;
 +	}
 +
 +	return 0;
 +}
 +
 +static int mei_nfc_connect(struct mei_nfc_dev *ndev)
 +{
 +	struct mei_device *dev;
 +	struct mei_cl *cl;
 +	struct mei_nfc_cmd *cmd, *reply;
 +	struct mei_nfc_connect *connect;
 +	struct mei_nfc_connect_resp *connect_resp;
 +	size_t connect_length, connect_resp_length;
 +	int bytes_recv, ret;
 +
 +	cl = ndev->cl;
 +	dev = cl->dev;
 +
 +	connect_length = sizeof(struct mei_nfc_cmd) +
 +			sizeof(struct mei_nfc_connect);
 +
 +	connect_resp_length = sizeof(struct mei_nfc_cmd) +
 +			sizeof(struct mei_nfc_connect_resp);
 +
 +	cmd = kzalloc(connect_length, GFP_KERNEL);
 +	if (!cmd)
 +		return -ENOMEM;
 +	connect = (struct mei_nfc_connect *)cmd->data;
 +
 +	reply = kzalloc(connect_resp_length, GFP_KERNEL);
 +	if (!reply) {
 +		kfree(cmd);
 +		return -ENOMEM;
 +	}
 +
 +	connect_resp = (struct mei_nfc_connect_resp *)reply->data;
 +
 +	cmd->command = MEI_NFC_CMD_MAINTENANCE;
 +	cmd->data_size = 3;
 +	cmd->sub_command = MEI_NFC_SUBCMD_CONNECT;
 +	connect->fw_ivn = ndev->fw_ivn;
 +	connect->vendor_id = ndev->vendor_id;
 +
 +	ret = __mei_cl_send(cl, (u8 *)cmd, connect_length);
 +	if (ret < 0) {
 +		dev_err(&dev->pdev->dev, "Could not send connect cmd\n");
 +		goto err;
 +	}
 +
 +	bytes_recv = __mei_cl_recv(cl, (u8 *)reply, connect_resp_length);
 +	if (bytes_recv < 0) {
 +		dev_err(&dev->pdev->dev, "Could not read connect response\n");
 +		ret = bytes_recv;
 +		goto err;
 +	}
 +
 +	dev_info(&dev->pdev->dev, "IVN 0x%x Vendor ID 0x%x\n",
 +		 connect_resp->fw_ivn, connect_resp->vendor_id);
 +
 +	dev_info(&dev->pdev->dev, "ME FW %d.%d.%d.%d\n",
 +		connect_resp->me_major, connect_resp->me_minor,
 +		connect_resp->me_hotfix, connect_resp->me_build);
 +
 +	ret = 0;
 +
 +err:
 +	kfree(reply);
 +	kfree(cmd);
 +
 +	return ret;
 +}
 +
 +static int mei_nfc_if_version(struct mei_nfc_dev *ndev)
 +{
 +	struct mei_device *dev;
 +	struct mei_cl *cl;
 +
 +	struct mei_nfc_cmd cmd;
++=======
+ 	struct mei_device *bus;
+ 	struct mei_nfc_cmd cmd = {
+ 		.command = MEI_NFC_CMD_MAINTENANCE,
+ 		.data_size = 1,
+ 		.sub_command = MEI_NFC_SUBCMD_IF_VERSION,
+ 	};
++>>>>>>> b39910c2e0ac (mei: bus: simplify how we build nfc bus name)
  	struct mei_nfc_reply *reply = NULL;
- 	struct mei_nfc_if_version *version;
  	size_t if_version_length;
  	int bytes_recv, ret;
  
++<<<<<<< HEAD
 +	cl = ndev->cl_info;
 +	dev = cl->dev;
++=======
+ 	bus = cl->dev;
++>>>>>>> b39910c2e0ac (mei: bus: simplify how we build nfc bus name)
  
- 	memset(&cmd, 0, sizeof(struct mei_nfc_cmd));
- 	cmd.command = MEI_NFC_CMD_MAINTENANCE;
- 	cmd.data_size = 1;
- 	cmd.sub_command = MEI_NFC_SUBCMD_IF_VERSION;
+ 	WARN_ON(mutex_is_locked(&bus->device_lock));
  
 -	ret = __mei_cl_send(cl, (u8 *)&cmd, sizeof(struct mei_nfc_cmd), 1);
 +	ret = __mei_cl_send(cl, (u8 *)&cmd, sizeof(struct mei_nfc_cmd));
  	if (ret < 0) {
 -		dev_err(bus->dev, "Could not send IF version cmd\n");
 +		dev_err(&dev->pdev->dev, "Could not send IF version cmd\n");
  		return ret;
  	}
  
@@@ -291,9 -223,10 +313,10 @@@
  	if (!reply)
  		return -ENOMEM;
  
+ 	ret = 0;
  	bytes_recv = __mei_cl_recv(cl, (u8 *)reply, if_version_length);
  	if (bytes_recv < 0 || bytes_recv < sizeof(struct mei_nfc_reply)) {
 -		dev_err(bus->dev, "Could not read IF version\n");
 +		dev_err(&dev->pdev->dev, "Could not read IF version\n");
  		ret = -EIO;
  		goto err;
  	}
@@@ -309,106 -241,37 +331,137 @@@ err
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int mei_nfc_enable(struct mei_cl_device *cldev)
 +{
 +	struct mei_device *dev;
 +	struct mei_nfc_dev *ndev = &nfc_dev;
 +	int ret;
 +
 +	dev = ndev->cl->dev;
 +
 +	ret = mei_nfc_connect(ndev);
 +	if (ret < 0) {
 +		dev_err(&dev->pdev->dev, "Could not connect to NFC");
 +		return ret;
 +	}
 +
 +	return 0;
 +}
 +
 +static int mei_nfc_disable(struct mei_cl_device *cldev)
 +{
 +	return 0;
 +}
 +
 +static int mei_nfc_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
 +{
 +	struct mei_device *dev;
 +	struct mei_nfc_dev *ndev;
 +	struct mei_nfc_hci_hdr *hdr;
 +	u8 *mei_buf;
 +	int err;
 +
 +	ndev = (struct mei_nfc_dev *) cldev->priv_data;
 +	dev = ndev->cl->dev;
 +
 +	mei_buf = kzalloc(length + MEI_NFC_HEADER_SIZE, GFP_KERNEL);
 +	if (!mei_buf)
 +		return -ENOMEM;
 +
 +	hdr = (struct mei_nfc_hci_hdr *) mei_buf;
 +	hdr->cmd = MEI_NFC_CMD_HCI_SEND;
 +	hdr->status = 0;
 +	hdr->req_id = ndev->req_id;
 +	hdr->reserved = 0;
 +	hdr->data_size = length;
 +
 +	memcpy(mei_buf + MEI_NFC_HEADER_SIZE, buf, length);
 +
 +	err = __mei_cl_send(ndev->cl, mei_buf, length + MEI_NFC_HEADER_SIZE);
 +	if (err < 0)
 +		return err;
 +
 +	kfree(mei_buf);
 +
 +	if (!wait_event_interruptible_timeout(ndev->send_wq,
 +				ndev->recv_req_id == ndev->req_id, HZ)) {
 +		dev_err(&dev->pdev->dev, "NFC MEI command timeout\n");
 +		err = -ETIME;
 +	} else {
 +		ndev->req_id++;
 +	}
 +
 +	return err;
 +}
 +
 +static int mei_nfc_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
 +{
 +	struct mei_nfc_dev *ndev;
 +	struct mei_nfc_hci_hdr *hci_hdr;
 +	int received_length;
 +
 +	ndev = (struct mei_nfc_dev *)cldev->priv_data;
 +
 +	received_length = __mei_cl_recv(ndev->cl, buf, length);
 +	if (received_length < 0)
 +		return received_length;
 +
 +	hci_hdr = (struct mei_nfc_hci_hdr *) buf;
 +
 +	if (hci_hdr->cmd == MEI_NFC_CMD_HCI_SEND) {
 +		ndev->recv_req_id = hci_hdr->req_id;
 +		wake_up(&ndev->send_wq);
 +
 +		return 0;
 +	}
 +
 +	return received_length;
 +}
 +
 +static struct mei_cl_ops nfc_ops = {
 +	.enable = mei_nfc_enable,
 +	.disable = mei_nfc_disable,
 +	.send = mei_nfc_send,
 +	.recv = mei_nfc_recv,
 +};
 +
++=======
+ /**
+  * mei_nfc_radio_name - derive nfc radio name from the interface version
+  *
+  * @ver: NFC radio version
+  *
+  * Return: radio name string
+  */
+ static const char *mei_nfc_radio_name(struct mei_nfc_if_version *ver)
+ {
+ 
+ 	if (ver->vendor_id == MEI_NFC_VENDOR_INSIDE) {
+ 		if (ver->radio_type == MEI_NFC_VENDOR_INSIDE_UREAD)
+ 			return "microread";
+ 	}
+ 
+ 	if (ver->vendor_id == MEI_NFC_VENDOR_NXP) {
+ 		if (ver->radio_type == MEI_NFC_VENDOR_NXP_PN544)
+ 			return "pn544";
+ 	}
+ 
+ 	return NULL;
+ }
+ 
++>>>>>>> b39910c2e0ac (mei: bus: simplify how we build nfc bus name)
  static void mei_nfc_init(struct work_struct *work)
  {
 -	struct mei_device *bus;
 +	struct mei_device *dev;
  	struct mei_cl_device *cldev;
  	struct mei_nfc_dev *ndev;
  	struct mei_cl *cl_info;
++<<<<<<< HEAD
++=======
+ 	struct mei_me_client *me_cl_info;
+ 	struct mei_nfc_if_version version;
++>>>>>>> b39910c2e0ac (mei: bus: simplify how we build nfc bus name)
  
  	ndev = container_of(work, struct mei_nfc_dev, init_work);
  
@@@ -424,34 -295,37 +477,54 @@@
  
  		goto err;
  	}
 -	mei_me_cl_put(me_cl_info);
 -	mutex_unlock(&bus->device_lock);
  
 +	mutex_unlock(&dev->device_lock);
 +
++<<<<<<< HEAD
 +	if (mei_nfc_if_version(ndev) < 0) {
 +		dev_err(&dev->pdev->dev, "Could not get the NFC interface version");
++=======
+ 	if (mei_nfc_if_version(cl_info, &version) < 0) {
+ 		dev_err(bus->dev, "Could not get the NFC interface version");
++>>>>>>> b39910c2e0ac (mei: bus: simplify how we build nfc bus name)
  
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	dev_info(&dev->pdev->dev,
 +		"NFC MEI VERSION: IVN 0x%x Vendor ID 0x%x Type 0x%x\n",
++=======
+ 	ndev->fw_ivn = version.fw_ivn;
+ 	ndev->vendor_id = version.vendor_id;
+ 	ndev->radio_type = version.radio_type;
+ 
+ 	dev_info(bus->dev, "NFC MEI VERSION: IVN 0x%x Vendor ID 0x%x Type 0x%x\n",
++>>>>>>> b39910c2e0ac (mei: bus: simplify how we build nfc bus name)
  		ndev->fw_ivn, ndev->vendor_id, ndev->radio_type);
  
 -	mutex_lock(&bus->device_lock);
 +	mutex_lock(&dev->device_lock);
  
  	if (mei_cl_disconnect(cl_info) < 0) {
 -		mutex_unlock(&bus->device_lock);
 -		dev_err(bus->dev, "Could not disconnect the NFC INFO ME client");
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev,
 +			"Could not disconnect the NFC INFO ME client");
  
  		goto err;
  	}
  
 -	mutex_unlock(&bus->device_lock);
 +	mutex_unlock(&dev->device_lock);
  
++<<<<<<< HEAD
 +	if (mei_nfc_build_bus_name(ndev) < 0) {
 +		dev_err(&dev->pdev->dev,
 +			"Could not build the bus ID name\n");
++=======
+ 	ndev->bus_name = mei_nfc_radio_name(&version);
+ 
+ 	if (!ndev->bus_name) {
+ 		dev_err(bus->dev, "Could not build the bus ID name\n");
++>>>>>>> b39910c2e0ac (mei: bus: simplify how we build nfc bus name)
  		return;
  	}
  
diff --cc drivers/misc/mei/bus.c
index 3365981198e7,7e51700515f4..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -161,35 -636,100 +161,103 @@@ static struct mei_cl *mei_bus_find_mei_
  
  	return NULL;
  }
 -
 -/**
 - * mei_cl_dev_alloc - initialize and allocate mei client device
 - *
 - * @bus: mei device
 - * @me_cl: me client
 - *
 - * Return: allocated device structur or NULL on allocation failure
 - */
 -static struct mei_cl_device *mei_cl_dev_alloc(struct mei_device *bus,
 -					      struct mei_me_client *me_cl)
 +struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops)
  {
++<<<<<<< HEAD
 +	struct mei_cl_device *device;
 +	struct mei_cl *cl;
++=======
+ 	struct mei_cl_device *cldev;
+ 
+ 	cldev = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
+ 	if (!cldev)
+ 		return NULL;
+ 
+ 	device_initialize(&cldev->dev);
+ 	cldev->dev.parent = bus->dev;
+ 	cldev->dev.bus    = &mei_cl_bus_type;
+ 	cldev->dev.type   = &mei_cl_device_type;
+ 	cldev->bus        = mei_dev_bus_get(bus);
+ 	cldev->me_cl      = mei_me_cl_get(me_cl);
+ 	cldev->is_added   = 0;
+ 	INIT_LIST_HEAD(&cldev->bus_list);
+ 
+ 	return cldev;
+ }
+ 
+ /**
+  * mei_cl_dev_setup - setup me client device
+  *    run fix up routines and set the device name
+  *
+  * @bus: mei device
+  * @cldev: me client device
+  *
+  * Return: true if the device is eligible for enumeration
+  */
+ static bool mei_cl_dev_setup(struct mei_device *bus,
+ 			     struct mei_cl_device *cldev)
+ {
+ 	cldev->do_match = 1;
+ 	mei_cl_dev_fixup(cldev);
+ 
+ 	if (cldev->do_match)
+ 		dev_set_name(&cldev->dev, "mei:%s:%pUl",
+ 			     cldev->name, mei_me_cl_uuid(cldev->me_cl));
+ 
+ 	return cldev->do_match == 1;
+ }
+ 
+ /**
+  * mei_cl_bus_dev_add - add me client devices
+  *
+  * @cldev: me client device
+  *
+  * Return: 0 on success; < 0 on failre
+  */
+ static int mei_cl_bus_dev_add(struct mei_cl_device *cldev)
+ {
+ 	int ret;
+ 
+ 	dev_dbg(cldev->bus->dev, "adding %pUL\n", mei_me_cl_uuid(cldev->me_cl));
+ 	ret = device_add(&cldev->dev);
+ 	if (!ret)
+ 		cldev->is_added = 1;
+ 
+ 	return ret;
+ }
+ 
+ struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
+ 					struct mei_me_client *me_cl,
+ 					struct mei_cl *cl,
+ 					const char *name)
+ {
+ 	struct mei_cl_device *cldev;
++>>>>>>> b39910c2e0ac (mei: bus: simplify how we build nfc bus name)
  	int status;
  
 -	cldev = mei_cl_dev_alloc(bus, me_cl);
 -	if (!cldev)
 +	cl = mei_bus_find_mei_cl_by_uuid(dev, uuid);
 +	if (cl == NULL)
  		return NULL;
  
 -	cldev->cl = cl;
 -	strlcpy(cldev->name, name, sizeof(cldev->name));
 +	device = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
 +	if (!device)
 +		return NULL;
 +
 +	device->cl = cl;
 +	device->ops = ops;
  
 -	mei_cl_dev_setup(bus, cldev);
 +	device->dev.parent = &dev->pdev->dev;
 +	device->dev.bus = &mei_cl_bus_type;
 +	device->dev.type = &mei_cl_device_type;
  
 -	status = mei_cl_bus_dev_add(cldev);
 +	dev_set_name(&device->dev, "%s", name);
 +
 +	status = device_register(&device->dev);
  	if (status) {
 -		dev_err(bus->dev, "Failed to register MEI device\n");
 -		mei_me_cl_put(cldev->me_cl);
 -		mei_dev_bus_put(bus);
 -		kfree(cldev);
 +		dev_err(&dev->pdev->dev, "Failed to register MEI device\n");
 +		kfree(device);
  		return NULL;
  	}
  
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,7098dcaccc96..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -289,74 -330,22 +289,86 @@@ struct mei_hw_ops 
  
  /* MEI bus API*/
  
++<<<<<<< HEAD
 +/**
 + * struct mei_cl_ops - MEI CL device ops
 + * This structure allows ME host clients to implement technology
 + * specific operations.
 + *
 + * @enable: Enable an MEI CL device. Some devices require specific
 + *	HECI commands to initialize completely.
 + * @disable: Disable an MEI CL device.
 + * @send: Tx hook for the device. This allows ME host clients to trap
 + *	the device driver buffers before actually physically
 + *	pushing it to the ME.
 + * @recv: Rx hook for the device. This allows ME host clients to trap the
 + *	ME buffers before forwarding them to the device driver.
 + */
 +struct mei_cl_ops {
 +	int (*enable)(struct mei_cl_device *device);
 +	int (*disable)(struct mei_cl_device *device);
 +	int (*send)(struct mei_cl_device *device, u8 *buf, size_t length);
 +	int (*recv)(struct mei_cl_device *device, u8 *buf, size_t length);
 +};
 +
 +struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops);
 +void mei_cl_remove_device(struct mei_cl_device *device);
 +
 +int __mei_cl_async_send(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
++=======
+ struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
+ 					struct mei_me_client *me_cl,
+ 					struct mei_cl *cl,
+ 					const char *name);
+ void mei_cl_remove_device(struct mei_cl_device *cldev);
+ void mei_cl_dev_fixup(struct mei_cl_device *dev);
+ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
+ 			bool blocking);
+ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
++>>>>>>> b39910c2e0ac (mei: bus: simplify how we build nfc bus name)
  void mei_cl_bus_rx_event(struct mei_cl *cl);
 -void mei_cl_bus_remove_devices(struct mei_device *bus);
 +void mei_cl_bus_remove_devices(struct mei_device *dev);
  int mei_cl_bus_init(void);
  void mei_cl_bus_exit(void);
 -struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *bus, uuid_le uuid);
 +
  
  /**
 + * struct mei_cl_device - MEI device handle
 + * An mei_cl_device pointer is returned from mei_add_device()
 + * and links MEI bus clients to their actual ME host client pointer.
 + * Drivers for MEI devices will get an mei_cl_device pointer
 + * when being probed and shall use it for doing ME bus I/O.
 + *
 + * @dev: linux driver model device pointer
 + * @uuid: me client uuid
 + * @cl: mei client
 + * @ops: ME transport ops
 + * @event_cb: Drivers register this callback to get asynchronous ME
 + *	events (e.g. Rx buffer pending) notifications.
 + * @events: Events bitmask sent to the driver.
 + * @priv_data: client private data
 + */
 +struct mei_cl_device {
 +	struct device dev;
 +
 +	struct mei_cl *cl;
 +
 +	const struct mei_cl_ops *ops;
 +
 +	struct work_struct event_work;
 +	mei_cl_event_cb_t event_cb;
 +	void *event_context;
 +	unsigned long events;
 +
 +	void *priv_data;
 +};
 +
 +
 + /**
   * enum mei_pg_event - power gating transition events
   *
   * @MEI_PG_EVENT_IDLE: the driver is not in power gating transition
* Unmerged path drivers/misc/mei/bus-fixup.c
* Unmerged path drivers/misc/mei/bus.c
* Unmerged path drivers/misc/mei/mei_dev.h
