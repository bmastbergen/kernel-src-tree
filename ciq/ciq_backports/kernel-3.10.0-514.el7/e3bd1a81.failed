r8152: check WORK_ENABLE in suspend function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author hayeswang <hayeswang@realtek.com>
commit e3bd1a81cd1e3f8ed961e642e97206d715db06c4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e3bd1a81.failed

Avoid unnecessary behavior when autosuspend occurs during open().
The relative processes should only be run after finishing open().

	Signed-off-by: Hayes Wang <hayeswang@realtek.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e3bd1a81cd1e3f8ed961e642e97206d715db06c4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/r8152.c
diff --cc drivers/net/usb/r8152.c
index c712487b1a4c,ca3c5d5f93eb..000000000000
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@@ -3131,26 -3191,39 +3131,30 @@@ static void r8153_init(struct r8152 *tp
  static int rtl8152_suspend(struct usb_interface *intf, pm_message_t message)
  {
  	struct r8152 *tp = usb_get_intfdata(intf);
 -	struct net_device *netdev = tp->netdev;
 -	int ret = 0;
 -
 -	mutex_lock(&tp->control);
 -
 -	if (PMSG_IS_AUTO(message)) {
 -		if (netif_running(netdev) && work_busy(&tp->schedule.work)) {
 -			ret = -EBUSY;
 -			goto out1;
 -		}
  
 +	if (PMSG_IS_AUTO(message))
  		set_bit(SELECTIVE_SUSPEND, &tp->flags);
 -	} else {
 -		netif_device_detach(netdev);
 -	}
 +	else
 +		netif_device_detach(tp->netdev);
  
++<<<<<<< HEAD
 +	if (netif_running(tp->netdev)) {
++=======
+ 	if (netif_running(netdev) && test_bit(WORK_ENABLE, &tp->flags)) {
++>>>>>>> e3bd1a81cd1e (r8152: check WORK_ENABLE in suspend function)
  		clear_bit(WORK_ENABLE, &tp->flags);
  		usb_kill_urb(tp->intr_urb);
 -		tasklet_disable(&tp->tl);
 +		cancel_delayed_work_sync(&tp->schedule);
  		if (test_bit(SELECTIVE_SUSPEND, &tp->flags)) {
 -			rtl_stop_rx(tp);
  			rtl_runtime_suspend_enable(tp, true);
  		} else {
 -			cancel_delayed_work_sync(&tp->schedule);
 +			tasklet_disable(&tp->tl);
  			tp->rtl_ops.down(tp);
 +			tasklet_enable(&tp->tl);
  		}
 -		tasklet_enable(&tp->tl);
  	}
 -out1:
 -	mutex_unlock(&tp->control);
  
 -	return ret;
 +	return 0;
  }
  
  static int rtl8152_resume(struct usb_interface *intf)
* Unmerged path drivers/net/usb/r8152.c
