IB/mlx5: Create GSI transmission QPs when P_Key table is changed

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Haggai Eran <haggaie@mellanox.com>
commit 7722f47e71e58592a2ba4437d27c802ba1c64e08
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7722f47e.failed

Whenever the P_Key table is changed, we create the required GSI
transmission QPs on-demand.

	Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Haggai Eran <haggaie@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 7722f47e71e58592a2ba4437d27c802ba1c64e08)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/gsi.c
#	drivers/infiniband/hw/mlx5/mlx5_ib.h
diff --cc drivers/infiniband/hw/mlx5/mlx5_ib.h
index 34dc68c37d1b,a8fc345c088a..000000000000
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@@ -465,6 -507,14 +465,17 @@@ struct mlx5_mr_cache 
  	unsigned long		last_add;
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx5_ib_gsi_qp;
+ 
+ struct mlx5_ib_port_resources {
+ 	struct mlx5_ib_resources *devr;
+ 	struct mlx5_ib_gsi_qp *gsi;
+ 	struct work_struct pkey_change_work;
+ };
+ 
++>>>>>>> 7722f47e71e5 (IB/mlx5: Create GSI transmission QPs when P_Key table is changed)
  struct mlx5_ib_resources {
  	struct ib_cq	*c0;
  	struct ib_xrcd	*x0;
@@@ -724,6 -770,21 +735,24 @@@ static inline void mlx5_ib_qp_enable_pa
  __be16 mlx5_get_roce_udp_sport(struct mlx5_ib_dev *dev, u8 port_num,
  			       int index);
  
++<<<<<<< HEAD
++=======
+ /* GSI QP helper functions */
+ struct ib_qp *mlx5_ib_gsi_create_qp(struct ib_pd *pd,
+ 				    struct ib_qp_init_attr *init_attr);
+ int mlx5_ib_gsi_destroy_qp(struct ib_qp *qp);
+ int mlx5_ib_gsi_modify_qp(struct ib_qp *qp, struct ib_qp_attr *attr,
+ 			  int attr_mask);
+ int mlx5_ib_gsi_query_qp(struct ib_qp *qp, struct ib_qp_attr *qp_attr,
+ 			 int qp_attr_mask,
+ 			 struct ib_qp_init_attr *qp_init_attr);
+ int mlx5_ib_gsi_post_send(struct ib_qp *qp, struct ib_send_wr *wr,
+ 			  struct ib_send_wr **bad_wr);
+ int mlx5_ib_gsi_post_recv(struct ib_qp *qp, struct ib_recv_wr *wr,
+ 			  struct ib_recv_wr **bad_wr);
+ void mlx5_ib_gsi_pkey_change(struct mlx5_ib_gsi_qp *gsi);
+ 
++>>>>>>> 7722f47e71e5 (IB/mlx5: Create GSI transmission QPs when P_Key table is changed)
  static inline void init_query_mad(struct ib_smp *mad)
  {
  	mad->base_version  = 1;
* Unmerged path drivers/infiniband/hw/mlx5/gsi.c
* Unmerged path drivers/infiniband/hw/mlx5/gsi.c
diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c
index 3a8b8f2e8dd9..baf807b84140 100644
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@ -1720,6 +1720,17 @@ static struct device_attribute *mlx5_class_attributes[] = {
 	&dev_attr_reg_pages,
 };
 
+static void pkey_change_handler(struct work_struct *work)
+{
+	struct mlx5_ib_port_resources *ports =
+		container_of(work, struct mlx5_ib_port_resources,
+			     pkey_change_work);
+
+	mutex_lock(&ports->devr->mutex);
+	mlx5_ib_gsi_pkey_change(ports->gsi);
+	mutex_unlock(&ports->devr->mutex);
+}
+
 static void mlx5_ib_event(struct mlx5_core_dev *dev, void *context,
 			  enum mlx5_dev_event event, unsigned long param)
 {
@@ -1756,6 +1767,8 @@ static void mlx5_ib_event(struct mlx5_core_dev *dev, void *context,
 	case MLX5_DEV_EVENT_PKEY_CHANGE:
 		ibev.event = IB_EVENT_PKEY_CHANGE;
 		port = (u8)param;
+
+		schedule_work(&ibdev->devr.ports[port - 1].pkey_change_work);
 		break;
 
 	case MLX5_DEV_EVENT_GUID_CHANGE:
@@ -1965,6 +1978,7 @@ static int create_dev_resources(struct mlx5_ib_resources *devr)
 	struct ib_srq_init_attr attr;
 	struct mlx5_ib_dev *dev;
 	struct ib_cq_init_attr cq_attr = {.cqe = 1};
+	int port;
 	int ret = 0;
 
 	dev = container_of(devr, struct mlx5_ib_dev, devr);
@@ -2056,6 +2070,12 @@ static int create_dev_resources(struct mlx5_ib_resources *devr)
 	atomic_inc(&devr->p0->usecnt);
 	atomic_set(&devr->s0->usecnt, 0);
 
+	for (port = 0; port < ARRAY_SIZE(devr->ports); ++port) {
+		INIT_WORK(&devr->ports[port].pkey_change_work,
+			  pkey_change_handler);
+		devr->ports[port].devr = devr;
+	}
+
 	return 0;
 
 error5:
@@ -2074,12 +2094,20 @@ error0:
 
 static void destroy_dev_resources(struct mlx5_ib_resources *devr)
 {
+	struct mlx5_ib_dev *dev =
+		container_of(devr, struct mlx5_ib_dev, devr);
+	int port;
+
 	mlx5_ib_destroy_srq(devr->s1);
 	mlx5_ib_destroy_srq(devr->s0);
 	mlx5_ib_dealloc_xrcd(devr->x0);
 	mlx5_ib_dealloc_xrcd(devr->x1);
 	mlx5_ib_destroy_cq(devr->c0);
 	mlx5_ib_dealloc_pd(devr->p0);
+
+	/* Make sure no change P_Key work items are still executing */
+	for (port = 0; port < dev->num_ports; ++port)
+		cancel_work_sync(&devr->ports[port].pkey_change_work);
 }
 
 static u32 get_core_cap_flags(struct ib_device *ibdev)
* Unmerged path drivers/infiniband/hw/mlx5/mlx5_ib.h
