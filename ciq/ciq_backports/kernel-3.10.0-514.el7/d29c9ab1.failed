IB/core: Fix oops in ib_cache_gid_set_default_gid

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Doug Ledford <dledford@redhat.com>
commit d29c9ab1a2c81ce404883baba91e15ae35411900
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d29c9ab1.failed

When we fail to find the default gid index, we can't continue
processing in this routine or else we will pass a negative
index to later routines resulting in invalid memory access
attempts and a kernel oops.

Fixes: 03db3a2d81e6 (IB/core: Add RoCE GID table management)
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit d29c9ab1a2c81ce404883baba91e15ae35411900)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cache.c
diff --cc drivers/infiniband/core/cache.c
index 6fa1f5fbfcef,c2e257d97eff..000000000000
--- a/drivers/infiniband/core/cache.c
+++ b/drivers/infiniband/core/cache.c
@@@ -516,37 -673,62 +516,85 @@@ void ib_cache_gid_set_default_gid(struc
  	memset(&gid_attr, 0, sizeof(gid_attr));
  	gid_attr.ndev = ndev;
  
 -	for (gid_type = 0; gid_type < IB_GID_TYPE_SIZE; ++gid_type) {
 -		int ix;
 -		union ib_gid current_gid;
 -		struct ib_gid_attr current_gid_attr = {};
 -
 -		if (1UL << gid_type & ~gid_type_mask)
 -			continue;
 -
 -		gid_attr.gid_type = gid_type;
 -
 +	mutex_lock(&table->lock);
 +	ix = find_gid(table, NULL, NULL, true, GID_ATTR_FIND_MASK_DEFAULT);
 +
 +	/* Coudn't find default GID location */
 +	WARN_ON(ix < 0);
 +
 +	if (!__ib_cache_gid_get(ib_dev, port, ix,
 +				&current_gid, &current_gid_attr) &&
 +	    mode == IB_CACHE_GID_DEFAULT_MODE_SET &&
 +	    !memcmp(&gid, &current_gid, sizeof(gid)) &&
 +	    !memcmp(&gid_attr, &current_gid_attr, sizeof(gid_attr)))
 +		goto unlock;
 +
++<<<<<<< HEAD
 +	if ((memcmp(&current_gid, &zgid, sizeof(current_gid)) ||
 +	     memcmp(&current_gid_attr, &zattr,
 +		    sizeof(current_gid_attr))) &&
 +	    del_gid(ib_dev, port, table, ix, true)) {
 +		pr_warn("ib_cache_gid: can't delete index %d for default gid %pI6\n",
 +			ix, gid.raw);
 +		goto unlock;
++=======
+ 		mutex_lock(&table->lock);
+ 		write_lock_irq(&table->rwlock);
+ 		ix = find_gid(table, NULL, &gid_attr, true,
+ 			      GID_ATTR_FIND_MASK_GID_TYPE |
+ 			      GID_ATTR_FIND_MASK_DEFAULT,
+ 			      NULL);
+ 
+ 		/* Coudn't find default GID location */
+ 		if (WARN_ON(ix < 0))
+ 			goto release;
+ 
+ 		zattr_type.gid_type = gid_type;
+ 
+ 		if (!__ib_cache_gid_get(ib_dev, port, ix,
+ 					&current_gid, &current_gid_attr) &&
+ 		    mode == IB_CACHE_GID_DEFAULT_MODE_SET &&
+ 		    !memcmp(&gid, &current_gid, sizeof(gid)) &&
+ 		    !memcmp(&gid_attr, &current_gid_attr, sizeof(gid_attr)))
+ 			goto release;
+ 
+ 		if (memcmp(&current_gid, &zgid, sizeof(current_gid)) ||
+ 		    memcmp(&current_gid_attr, &zattr_type,
+ 			   sizeof(current_gid_attr))) {
+ 			if (del_gid(ib_dev, port, table, ix, true)) {
+ 				pr_warn("ib_cache_gid: can't delete index %d for default gid %pI6\n",
+ 					ix, gid.raw);
+ 				goto release;
+ 			} else {
+ 				dispatch_gid_change_event(ib_dev, port);
+ 			}
+ 		}
+ 
+ 		if (mode == IB_CACHE_GID_DEFAULT_MODE_SET) {
+ 			if (add_gid(ib_dev, port, table, ix, &gid, &gid_attr, true))
+ 				pr_warn("ib_cache_gid: unable to add default gid %pI6\n",
+ 					gid.raw);
+ 			else
+ 				dispatch_gid_change_event(ib_dev, port);
+ 		}
+ 
+ release:
+ 		if (current_gid_attr.ndev)
+ 			dev_put(current_gid_attr.ndev);
+ 		write_unlock_irq(&table->rwlock);
+ 		mutex_unlock(&table->lock);
++>>>>>>> d29c9ab1a2c8 (IB/core: Fix oops in ib_cache_gid_set_default_gid)
  	}
 +
 +	if (mode == IB_CACHE_GID_DEFAULT_MODE_SET)
 +		if (add_gid(ib_dev, port, table, ix, &gid, &gid_attr, true))
 +			pr_warn("ib_cache_gid: unable to add default gid %pI6\n",
 +				gid.raw);
 +
 +unlock:
 +	if (current_gid_attr.ndev)
 +		dev_put(current_gid_attr.ndev);
 +	mutex_unlock(&table->lock);
  }
  
  static int gid_table_reserve_default(struct ib_device *ib_dev, u8 port,
* Unmerged path drivers/infiniband/core/cache.c
