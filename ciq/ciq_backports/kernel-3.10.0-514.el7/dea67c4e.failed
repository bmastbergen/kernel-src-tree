mmc: core: sdio: Fix unconditional wake_up_process() on sdio thread

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] core: sdio: Fix unconditional wake_up_process() on sdio thread (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 96.12%
commit-author Fu Zhonghui <zhonghui.fu@linux.intel.com>
commit dea67c4ec8218b301d7cac7ee6e63dac0bc566cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/dea67c4e.failed

781e989cf59 ("mmc: sdhci: convert to new SDIO IRQ handling") and
bf3b5ec66bd ("mmc: sdio_irq: rework sdio irq handling") disabled
the use of our own custom threaded IRQ handler, but left in an
unconditional wake_up_process() on that handler at resume-time.
Link: https://bugzilla.kernel.org/show_bug.cgi?id=80151

In addition, the check for MMC_CAP_SDIO_IRQ capability is added
before enable sdio IRQ.

	Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
	Signed-off-by: Chris Ball <chris@printf.net>
	Signed-off-by: Fu Zhonghui <zhonghui.fu@linux.intel.com>
	Cc: <stable@vger.kernel.org> # v3.16+
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit dea67c4ec8218b301d7cac7ee6e63dac0bc566cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/sdio_irq.c
diff --cc drivers/mmc/core/sdio_irq.c
index aaa90460ed23,696eca493844..000000000000
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@@ -189,14 -198,20 +189,31 @@@ static int sdio_card_irq_get(struct mmc
  	WARN_ON(!host->claimed);
  
  	if (!host->sdio_irqs++) {
++<<<<<<< HEAD
 +		atomic_set(&host->sdio_irq_thread_abort, 0);
 +		host->sdio_irq_thread =
 +			kthread_run(sdio_irq_thread, host, "ksdioirqd/%s",
 +				mmc_hostname(host));
 +		if (IS_ERR(host->sdio_irq_thread)) {
 +			int err = PTR_ERR(host->sdio_irq_thread);
 +			host->sdio_irqs--;
 +			return err;
++=======
+ 		if (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD)) {
+ 			atomic_set(&host->sdio_irq_thread_abort, 0);
+ 			host->sdio_irq_thread =
+ 				kthread_run(sdio_irq_thread, host,
+ 					    "ksdioirqd/%s", mmc_hostname(host));
+ 			if (IS_ERR(host->sdio_irq_thread)) {
+ 				int err = PTR_ERR(host->sdio_irq_thread);
+ 				host->sdio_irqs--;
+ 				return err;
+ 			}
+ 		} else if (host->caps & MMC_CAP_SDIO_IRQ) {
+ 			mmc_host_clk_hold(host);
+ 			host->ops->enable_sdio_irq(host, 1);
+ 			mmc_host_clk_release(host);
++>>>>>>> dea67c4ec821 (mmc: core: sdio: Fix unconditional wake_up_process() on sdio thread)
  		}
  	}
  
@@@ -211,8 -226,14 +228,19 @@@ static int sdio_card_irq_put(struct mmc
  	BUG_ON(host->sdio_irqs < 1);
  
  	if (!--host->sdio_irqs) {
++<<<<<<< HEAD
 +		atomic_set(&host->sdio_irq_thread_abort, 1);
 +		kthread_stop(host->sdio_irq_thread);
++=======
+ 		if (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD)) {
+ 			atomic_set(&host->sdio_irq_thread_abort, 1);
+ 			kthread_stop(host->sdio_irq_thread);
+ 		} else if (host->caps & MMC_CAP_SDIO_IRQ) {
+ 			mmc_host_clk_hold(host);
+ 			host->ops->enable_sdio_irq(host, 0);
+ 			mmc_host_clk_release(host);
+ 		}
++>>>>>>> dea67c4ec821 (mmc: core: sdio: Fix unconditional wake_up_process() on sdio thread)
  	}
  
  	return 0;
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 9933e426bc36..335ab4b7e4b7 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -996,8 +996,16 @@ static int mmc_sdio_resume(struct mmc_host *host)
 		}
 	}
 
-	if (!err && host->sdio_irqs)
-		wake_up_process(host->sdio_irq_thread);
+	if (!err && host->sdio_irqs) {
+		if (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD)) {
+			wake_up_process(host->sdio_irq_thread);
+		} else if (host->caps & MMC_CAP_SDIO_IRQ) {
+			mmc_host_clk_hold(host);
+			host->ops->enable_sdio_irq(host, 1);
+			mmc_host_clk_release(host);
+		}
+	}
+
 	mmc_release_host(host);
 
 	host->pm_flags &= ~MMC_PM_KEEP_POWER;
* Unmerged path drivers/mmc/core/sdio_irq.c
