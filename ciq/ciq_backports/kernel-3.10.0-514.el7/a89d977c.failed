usb: dwc3: pci: add quirk for Baytrails

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [usb] dwc3: pci: add quirk for Baytrails (Prarit Bhargava) [1339663]
Rebuild_FUZZ: 93.15%
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit a89d977cc04c77d9aa45d426dbf8de9dd1326c77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a89d977c.failed

On some BYT platforms the USB2 PHY needs to be put into
operational mode by the controller driver with GPIOs
controlling the PHYs reset and cs signals.

	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Signed-off-by: Felipe Balbi <balbi@ti.com>
(cherry picked from commit a89d977cc04c77d9aa45d426dbf8de9dd1326c77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/dwc3/dwc3-pci.c
diff --cc drivers/usb/dwc3/dwc3-pci.c
index fc404193b22e,27e4fc896e9d..000000000000
--- a/drivers/usb/dwc3/dwc3-pci.c
+++ b/drivers/usb/dwc3/dwc3-pci.c
@@@ -41,75 -21,86 +41,116 @@@
  #include <linux/slab.h>
  #include <linux/pci.h>
  #include <linux/platform_device.h>
+ #include <linux/gpio/consumer.h>
+ #include <linux/acpi.h>
  
 -#include "platform_data.h"
 +#include <linux/usb/otg.h>
 +#include <linux/usb/nop-usb-xceiv.h>
  
 +/* FIXME define these in <linux/pci_ids.h> */
 +#define PCI_VENDOR_ID_SYNOPSYS		0x16c3
  #define PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3	0xabcd
  #define PCI_DEVICE_ID_INTEL_BYT		0x0f37
  #define PCI_DEVICE_ID_INTEL_MRFLD	0x119e
 -#define PCI_DEVICE_ID_INTEL_BSW		0x22B7
 -#define PCI_DEVICE_ID_INTEL_SPTLP	0x9d30
 -#define PCI_DEVICE_ID_INTEL_SPTH	0xa130
  
++<<<<<<< HEAD
 +struct dwc3_pci {
 +	struct device		*dev;
 +	struct platform_device	*dwc3;
 +	struct platform_device	*usb2_phy;
 +	struct platform_device	*usb3_phy;
 +};
 +
 +static int dwc3_pci_register_phys(struct dwc3_pci *glue)
++=======
+ static const struct acpi_gpio_params reset_gpios = { 0, 0, false };
+ static const struct acpi_gpio_params cs_gpios = { 1, 0, false };
+ 
+ static const struct acpi_gpio_mapping acpi_dwc3_byt_gpios[] = {
+ 	{ "reset-gpios", &reset_gpios, 1 },
+ 	{ "cs-gpios", &cs_gpios, 1 },
+ 	{ },
+ };
+ 
+ static int dwc3_pci_quirks(struct pci_dev *pdev)
++>>>>>>> a89d977cc04c (usb: dwc3: pci: add quirk for Baytrails)
  {
 -	if (pdev->vendor == PCI_VENDOR_ID_AMD &&
 -	    pdev->device == PCI_DEVICE_ID_AMD_NL_USB) {
 -		struct dwc3_platform_data pdata;
 -
 -		memset(&pdata, 0, sizeof(pdata));
 -
 -		pdata.has_lpm_erratum = true;
 -		pdata.lpm_nyet_threshold = 0xf;
 -
 -		pdata.u2exit_lfps_quirk = true;
 -		pdata.u2ss_inp3_quirk = true;
 -		pdata.req_p1p2p3_quirk = true;
 -		pdata.del_p1p2p3_quirk = true;
 -		pdata.del_phy_power_chg_quirk = true;
 -		pdata.lfps_filter_quirk = true;
 -		pdata.rx_detect_poll_quirk = true;
 -
 -		pdata.tx_de_emphasis_quirk = true;
 -		pdata.tx_de_emphasis = 1;
 -
 -		/*
 -		 * FIXME these quirks should be removed when AMD NL
 -		 * taps out
 -		 */
 -		pdata.disable_scramble_quirk = true;
 -		pdata.dis_u3_susphy_quirk = true;
 -		pdata.dis_u2_susphy_quirk = true;
 -
 -		return platform_device_add_data(pci_get_drvdata(pdev), &pdata,
 -						sizeof(pdata));
 +	struct nop_usb_xceiv_platform_data pdata;
 +	struct platform_device	*pdev;
 +	int			ret;
 +
 +	memset(&pdata, 0x00, sizeof(pdata));
 +
 +	pdev = platform_device_alloc("nop_usb_xceiv", 0);
 +	if (!pdev)
 +		return -ENOMEM;
 +
 +	glue->usb2_phy = pdev;
 +	pdata.type = USB_PHY_TYPE_USB2;
 +
 +	ret = platform_device_add_data(glue->usb2_phy, &pdata, sizeof(pdata));
 +	if (ret)
 +		goto err1;
 +
 +	pdev = platform_device_alloc("nop_usb_xceiv", 1);
 +	if (!pdev) {
 +		ret = -ENOMEM;
 +		goto err1;
  	}
  
++<<<<<<< HEAD
 +	glue->usb3_phy = pdev;
 +	pdata.type = USB_PHY_TYPE_USB3;
 +
 +	ret = platform_device_add_data(glue->usb3_phy, &pdata, sizeof(pdata));
 +	if (ret)
 +		goto err2;
 +
 +	ret = platform_device_add(glue->usb2_phy);
 +	if (ret)
 +		goto err2;
 +
 +	ret = platform_device_add(glue->usb3_phy);
 +	if (ret)
 +		goto err3;
++=======
+ 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
+ 	    pdev->device == PCI_DEVICE_ID_INTEL_BYT) {
+ 		struct gpio_desc *gpio;
+ 
+ 		acpi_dev_add_driver_gpios(ACPI_COMPANION(&pdev->dev),
+ 					  acpi_dwc3_byt_gpios);
+ 
+ 		/* These GPIOs will turn on the USB2 PHY */
+ 		gpio = gpiod_get(&pdev->dev, "cs");
+ 		if (!IS_ERR(gpio)) {
+ 			gpiod_direction_output(gpio, 0);
+ 			gpiod_set_value_cansleep(gpio, 1);
+ 			gpiod_put(gpio);
+ 		}
+ 
+ 		gpio = gpiod_get(&pdev->dev, "reset");
+ 		if (!IS_ERR(gpio)) {
+ 			gpiod_direction_output(gpio, 0);
+ 			gpiod_set_value_cansleep(gpio, 1);
+ 			gpiod_put(gpio);
+ 			usleep_range(10000, 11000);
+ 		}
+ 	}
++>>>>>>> a89d977cc04c (usb: dwc3: pci: add quirk for Baytrails)
  
  	return 0;
 +
 +err3:
 +	platform_device_del(glue->usb2_phy);
 +
 +err2:
 +	platform_device_put(glue->usb3_phy);
 +
 +err1:
 +	platform_device_put(glue->usb2_phy);
 +
 +	return ret;
  }
  
  static int dwc3_pci_probe(struct pci_dev *pci,
@@@ -196,13 -163,8 +237,18 @@@ err1
  
  static void dwc3_pci_remove(struct pci_dev *pci)
  {
++<<<<<<< HEAD
 +	struct dwc3_pci	*glue = pci_get_drvdata(pci);
 +
 +	platform_device_unregister(glue->dwc3);
 +	platform_device_unregister(glue->usb2_phy);
 +	platform_device_unregister(glue->usb3_phy);
 +	pci_set_drvdata(pci, NULL);
 +	pci_disable_device(pci);
++=======
+ 	acpi_dev_remove_driver_gpios(ACPI_COMPANION(&pci->dev));
+ 	platform_device_unregister(pci_get_drvdata(pci));
++>>>>>>> a89d977cc04c (usb: dwc3: pci: add quirk for Baytrails)
  }
  
  static const struct pci_device_id dwc3_pci_id_table[] = {
* Unmerged path drivers/usb/dwc3/dwc3-pci.c
