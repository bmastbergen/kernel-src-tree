mei: bus: revamp probe and remove functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit feb8cd0fe7d63fd259c28f8a52fc88745717c9ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/feb8cd0f.failed

Instead of generating device id on the fly during probing we
find the matching id entry on the device id table.
Get bus the module reference counter so it cannot
be unloaded after the driver has bounded to the client
device

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit feb8cd0fe7d63fd259c28f8a52fc88745717c9ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/bus.c
diff --cc drivers/misc/mei/bus.c
index 3365981198e7,1d9ce9c491cf..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -31,195 -30,245 +31,246 @@@
  #define to_mei_cl_driver(d) container_of(d, struct mei_cl_driver, driver)
  #define to_mei_cl_device(d) container_of(d, struct mei_cl_device, dev)
  
 -/**
 - * __mei_cl_send - internal client send (write)
 - *
 - * @cl: host client
 - * @buf: buffer to send
 - * @length: buffer length
 - * @blocking: wait for write completion
 - *
 - * Return: written size bytes or < 0 on error
 - */
 -ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 -			bool blocking)
 +static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
  {
 -	struct mei_device *bus;
 -	struct mei_cl_cb *cb = NULL;
 -	ssize_t rets;
 +	struct mei_cl_device *device = to_mei_cl_device(dev);
 +	struct mei_cl_driver *driver = to_mei_cl_driver(drv);
 +	const struct mei_cl_device_id *id;
  
 -	if (WARN_ON(!cl || !cl->dev))
 -		return -ENODEV;
 +	if (!device)
 +		return 0;
  
 -	bus = cl->dev;
 +	if (!driver || !driver->id_table)
 +		return 0;
  
 -	mutex_lock(&bus->device_lock);
 -	if (!mei_cl_is_connected(cl)) {
 -		rets = -ENODEV;
 -		goto out;
 -	}
 +	id = driver->id_table;
  
 -	/* Check if we have an ME client device */
 -	if (!mei_me_cl_is_active(cl->me_cl)) {
 -		rets = -ENOTTY;
 -		goto out;
 -	}
 +	while (id->name[0]) {
 +		if (!strncmp(dev_name(dev), id->name, sizeof(id->name)))
 +			return 1;
  
 -	if (length > mei_cl_mtu(cl)) {
 -		rets = -EFBIG;
 -		goto out;
 -	}
 -
 -	cb = mei_cl_alloc_cb(cl, length, MEI_FOP_WRITE, NULL);
 -	if (!cb) {
 -		rets = -ENOMEM;
 -		goto out;
 +		id++;
  	}
  
 -	memcpy(cb->buf.data, buf, length);
 -
 -	rets = mei_cl_write(cl, cb, blocking);
 -
 -out:
 -	mutex_unlock(&bus->device_lock);
 -	if (rets < 0)
 -		mei_io_cb_free(cb);
 -
 -	return rets;
 +	return 0;
  }
  
+ /**
 - * __mei_cl_recv - internal client receive (read)
++ * mei_cl_device_probe - bus probe function
+  *
 - * @cl: host client
 - * @buf: buffer to send
 - * @length: buffer length
++ * @dev: device
+  *
 - * Return: read size in bytes of < 0 on error
++ * Return:  0 on success; < 0 otherwise
+  */
 -ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 +static int mei_cl_device_probe(struct device *dev)
  {
 -	struct mei_device *bus;
 -	struct mei_cl_cb *cb;
 -	size_t r_length;
 -	ssize_t rets;
 -
 -	if (WARN_ON(!cl || !cl->dev))
 -		return -ENODEV;
++<<<<<<< HEAD
 +	struct mei_cl_device *device = to_mei_cl_device(dev);
 +	struct mei_cl_driver *driver;
 +	struct mei_cl_device_id id;
++=======
++	struct mei_cl_device *cldev;
++	struct mei_cl_driver *cldrv;
++	const struct mei_cl_device_id *id;
+ 
 -	bus = cl->dev;
++	cldev = to_mei_cl_device(dev);
++	cldrv = to_mei_cl_driver(dev->driver);
++>>>>>>> feb8cd0fe7d6 (mei: bus: revamp probe and remove functions)
  
 -	mutex_lock(&bus->device_lock);
 +	if (!device)
 +		return 0;
  
 -	cb = mei_cl_read_cb(cl, NULL);
 -	if (cb)
 -		goto copy;
++<<<<<<< HEAD
 +	driver = to_mei_cl_driver(dev->driver);
 +	if (!driver || !driver->probe)
++=======
++	if (!cldrv || !cldrv->probe)
++>>>>>>> feb8cd0fe7d6 (mei: bus: revamp probe and remove functions)
 +		return -ENODEV;
  
- 	dev_dbg(dev, "Device probe\n");
 -	rets = mei_cl_read_start(cl, length, NULL);
 -	if (rets && rets != -EBUSY)
 -		goto out;
++	id = mei_cl_device_find(cldev, cldrv);
++	if (!id)
++		return -ENODEV;
  
 -	/* wait on event only if there is no other waiter */
 -	if (list_empty(&cl->rd_completed) && !waitqueue_active(&cl->rx_wait)) {
++<<<<<<< HEAD
 +	strlcpy(id.name, dev_name(dev), sizeof(id.name));
  
 -		mutex_unlock(&bus->device_lock);
 +	return driver->probe(device, &id);
++=======
++	__module_get(THIS_MODULE);
+ 
 -		if (wait_event_interruptible(cl->rx_wait,
 -				(!list_empty(&cl->rd_completed)) ||
 -				(!mei_cl_is_connected(cl)))) {
++	return cldrv->probe(cldev, id);
++>>>>>>> feb8cd0fe7d6 (mei: bus: revamp probe and remove functions)
 +}
  
 -			if (signal_pending(current))
 -				return -EINTR;
 -			return -ERESTARTSYS;
 -		}
++/**
++ * mei_cl_device_remove - remove device from the bus
++ *
++ * @dev: device
++ *
++ * Return:  0 on success; < 0 otherwise
++ */
 +static int mei_cl_device_remove(struct device *dev)
 +{
++<<<<<<< HEAD
 +	struct mei_cl_device *device = to_mei_cl_device(dev);
 +	struct mei_cl_driver *driver;
++=======
++	struct mei_cl_device *cldev = to_mei_cl_device(dev);
++	struct mei_cl_driver *cldrv;
++	int ret = 0;
++>>>>>>> feb8cd0fe7d6 (mei: bus: revamp probe and remove functions)
  
 -		mutex_lock(&bus->device_lock);
 +	if (!device || !dev->driver)
 +		return 0;
  
 -		if (!mei_cl_is_connected(cl)) {
 -			rets = -EBUSY;
 -			goto out;
 -		}
 +	if (device->event_cb) {
 +		device->event_cb = NULL;
 +		cancel_work_sync(&device->event_work);
  	}
  
 -	cb = mei_cl_read_cb(cl, NULL);
 -	if (!cb) {
 -		rets = 0;
 -		goto out;
 -	}
++<<<<<<< HEAD
 +	driver = to_mei_cl_driver(dev->driver);
 +	if (!driver->remove) {
 +		dev->driver = NULL;
++=======
++	cldrv = to_mei_cl_driver(dev->driver);
++	if (cldrv->remove)
++		ret = cldrv->remove(cldev);
++>>>>>>> feb8cd0fe7d6 (mei: bus: revamp probe and remove functions)
  
- 		return 0;
 -copy:
 -	if (cb->status) {
 -		rets = cb->status;
 -		goto free;
--	}
++	module_put(THIS_MODULE);
++	dev->driver = NULL;
++	return ret;
  
 -	r_length = min_t(size_t, length, cb->buf_idx);
 -	memcpy(buf, cb->buf.data, r_length);
 -	rets = r_length;
++<<<<<<< HEAD
 +	return driver->remove(device);
++=======
++>>>>>>> feb8cd0fe7d6 (mei: bus: revamp probe and remove functions)
 +}
  
 -free:
 -	mei_io_cb_free(cb);
 -out:
 -	mutex_unlock(&bus->device_lock);
 +static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 +			     char *buf)
 +{
 +	int len;
  
 -	return rets;
 +	len = snprintf(buf, PAGE_SIZE, "mei:%s\n", dev_name(dev));
 +
 +	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
  }
 +static DEVICE_ATTR_RO(modalias);
 +
 +static struct attribute *mei_cl_dev_attrs[] = {
 +	&dev_attr_modalias.attr,
 +	NULL,
 +};
 +ATTRIBUTE_GROUPS(mei_cl_dev);
  
  /**
 - * mei_cl_send - me device send  (write)
 + * mei_cl_device_uevent - me client bus uevent handler
   *
 - * @cldev: me client device
 - * @buf: buffer to send
 - * @length: buffer length
 + * @dev: device
 + * @env: uevent kobject
   *
 - * Return: written size in bytes or < 0 on error
 + * Return: 0 on success -ENOMEM on when add_uevent_var fails
   */
 -ssize_t mei_cl_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
 +static int mei_cl_device_uevent(struct device *dev, struct kobj_uevent_env *env)
  {
 -	struct mei_cl *cl = cldev->cl;
 +	if (add_uevent_var(env, "MODALIAS=mei:%s", dev_name(dev)))
 +		return -ENOMEM;
  
 -	if (cl == NULL)
 -		return -ENODEV;
 +	return 0;
 +}
 +
 +static struct bus_type mei_cl_bus_type = {
 +	.name		= "mei",
 +	.dev_groups	= mei_cl_dev_groups,
 +	.match		= mei_cl_device_match,
 +	.probe		= mei_cl_device_probe,
 +	.remove		= mei_cl_device_remove,
 +	.uevent		= mei_cl_device_uevent,
 +};
  
 -	return __mei_cl_send(cl, buf, length, 1);
 +static void mei_cl_dev_release(struct device *dev)
 +{
 +	kfree(to_mei_cl_device(dev));
  }
 -EXPORT_SYMBOL_GPL(mei_cl_send);
  
 -/**
 - * mei_cl_recv - client receive (read)
 - *
 - * @cldev: me client device
 - * @buf: buffer to send
 - * @length: buffer length
 - *
 - * Return: read size in bytes of < 0 on error
 - */
 -ssize_t mei_cl_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
 +static struct device_type mei_cl_device_type = {
 +	.release	= mei_cl_dev_release,
 +};
 +
 +static struct mei_cl *mei_bus_find_mei_cl_by_uuid(struct mei_device *dev,
 +						uuid_le uuid)
  {
 -	struct mei_cl *cl = cldev->cl;
 +	struct mei_cl *cl;
  
 -	if (cl == NULL)
 -		return -ENODEV;
 +	list_for_each_entry(cl, &dev->device_list, device_link) {
 +		if (!uuid_le_cmp(uuid, cl->device_uuid))
 +			return cl;
 +	}
  
 -	return __mei_cl_recv(cl, buf, length);
 +	return NULL;
  }
 -EXPORT_SYMBOL_GPL(mei_cl_recv);
 -
 -/**
 - * mei_bus_event_work  - dispatch rx event for a bus device
 - *    and schedule new work
 - *
 - * @work: work
 - */
 -static void mei_bus_event_work(struct work_struct *work)
 +struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops)
  {
 -	struct mei_cl_device *cldev;
 +	struct mei_cl_device *device;
 +	struct mei_cl *cl;
 +	int status;
  
 -	cldev = container_of(work, struct mei_cl_device, event_work);
 +	cl = mei_bus_find_mei_cl_by_uuid(dev, uuid);
 +	if (cl == NULL)
 +		return NULL;
  
 -	if (cldev->event_cb)
 -		cldev->event_cb(cldev, cldev->events, cldev->event_context);
 +	device = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
 +	if (!device)
 +		return NULL;
  
 -	cldev->events = 0;
 +	device->cl = cl;
 +	device->ops = ops;
  
 -	/* Prepare for the next read */
 -	mei_cl_read_start(cldev->cl, 0, NULL);
 -}
 +	device->dev.parent = &dev->pdev->dev;
 +	device->dev.bus = &mei_cl_bus_type;
 +	device->dev.type = &mei_cl_device_type;
  
 -/**
 - * mei_cl_bus_rx_event  - schedule rx evenet
 - *
 - * @cl: host client
 - */
 -void mei_cl_bus_rx_event(struct mei_cl *cl)
 -{
 -	struct mei_cl_device *cldev = cl->cldev;
 +	dev_set_name(&device->dev, "%s", name);
  
 -	if (!cldev || !cldev->event_cb)
 -		return;
 +	status = device_register(&device->dev);
 +	if (status) {
 +		dev_err(&dev->pdev->dev, "Failed to register MEI device\n");
 +		kfree(device);
 +		return NULL;
 +	}
 +
 +	cl->device = device;
  
 -	set_bit(MEI_CL_EVENT_RX, &cldev->events);
 +	dev_dbg(&device->dev, "client %s registered\n", name);
  
 -	schedule_work(&cldev->event_work);
 +	return device;
  }
 +EXPORT_SYMBOL_GPL(mei_cl_add_device);
  
 -/**
 - * mei_cl_register_event_cb - register event callback
 - *
 - * @cldev: me client devices
 - * @event_cb: callback function
 - * @context: driver context data
 - *
 - * Return: 0 on success
 - *         -EALREADY if an callback is already registered
 - *         <0 on other errors
 - */
 -int mei_cl_register_event_cb(struct mei_cl_device *cldev,
 -			  mei_cl_event_cb_t event_cb, void *context)
 +void mei_cl_remove_device(struct mei_cl_device *device)
 +{
 +	device_unregister(&device->dev);
 +}
 +EXPORT_SYMBOL_GPL(mei_cl_remove_device);
 +
 +int __mei_cl_driver_register(struct mei_cl_driver *driver, struct module *owner)
  {
 -	int ret;
 +	int err;
  
 -	if (cldev->event_cb)
 -		return -EALREADY;
 +	driver->driver.name = driver->name;
 +	driver->driver.owner = owner;
 +	driver->driver.bus = &mei_cl_bus_type;
  
 -	cldev->events = 0;
 -	cldev->event_cb = event_cb;
 -	cldev->event_context = context;
 -	INIT_WORK(&cldev->event_work, mei_bus_event_work);
 +	err = driver_register(&driver->driver);
 +	if (err)
 +		return err;
  
 -	ret = mei_cl_read_start(cldev->cl, 0, NULL);
 -	if (ret && ret != -EBUSY)
 -		return ret;
 +	pr_debug("mei: driver [%s] registered\n", driver->driver.name);
  
  	return 0;
  }
* Unmerged path drivers/misc/mei/bus.c
