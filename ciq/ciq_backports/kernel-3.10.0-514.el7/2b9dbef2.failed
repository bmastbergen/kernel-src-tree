Btrfs: keep dropped roots in cache until transaction commit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Josef Bacik <jbacik@fb.com>
commit 2b9dbef272b63c561aab0a5be34fd428f7b710f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2b9dbef2.failed

When dropping a snapshot we need to account for the qgroup changes.  If we drop
the snapshot in all one go then the backref code will fail to find blocks from
the snapshot we dropped since it won't be able to find the root in the fs root
cache.  This can lead to us failing to find refs from other roots that pointed
at blocks in the now deleted root.  To handle this we need to not remove the fs
roots from the cache until after we process the qgroup operations.  Do this by
adding dropped roots to a list on the transaction, and letting the transaction
remove the roots at the same time it drops the commit roots.  This will keep all
of the backref searching code in sync properly, and fixes a problem Mark was
seeing with snapshot delete and qgroups.  Thanks,

	Signed-off-by: Josef Bacik <jbacik@fb.com>
	Tested-by: Holger Hoffst√§tte <holger.hoffstaette@googlemail.com>
	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit 2b9dbef272b63c561aab0a5be34fd428f7b710f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/transaction.c
#	fs/btrfs/transaction.h
diff --cc fs/btrfs/transaction.c
index ccf5d09b46b6,a2d6f7bcef6c..000000000000
--- a/fs/btrfs/transaction.c
+++ b/fs/btrfs/transaction.c
@@@ -249,6 -266,10 +261,13 @@@ loop
  	INIT_LIST_HEAD(&cur_trans->switch_commits);
  	INIT_LIST_HEAD(&cur_trans->pending_ordered);
  	INIT_LIST_HEAD(&cur_trans->dirty_bgs);
++<<<<<<< HEAD
++=======
+ 	INIT_LIST_HEAD(&cur_trans->io_bgs);
+ 	INIT_LIST_HEAD(&cur_trans->dropped_roots);
+ 	mutex_init(&cur_trans->cache_write_mutex);
+ 	cur_trans->num_dirty_bgs = 0;
++>>>>>>> 2b9dbef272b6 (Btrfs: keep dropped roots in cache until transaction commit)
  	spin_lock_init(&cur_trans->dirty_bgs_lock);
  	INIT_LIST_HEAD(&cur_trans->deleted_bgs);
  	spin_lock_init(&cur_trans->deleted_bgs_lock);
diff --cc fs/btrfs/transaction.h
index 1c494dc98bec,87964bf8892d..000000000000
--- a/fs/btrfs/transaction.h
+++ b/fs/btrfs/transaction.h
@@@ -64,11 -64,23 +64,25 @@@ struct btrfs_transaction 
  	struct list_head pending_ordered;
  	struct list_head switch_commits;
  	struct list_head dirty_bgs;
++<<<<<<< HEAD
++=======
+ 	struct list_head io_bgs;
+ 	struct list_head dropped_roots;
+ 	u64 num_dirty_bgs;
+ 
+ 	/*
+ 	 * we need to make sure block group deletion doesn't race with
+ 	 * free space cache writeout.  This mutex keeps them from stomping
+ 	 * on each other
+ 	 */
+ 	struct mutex cache_write_mutex;
++>>>>>>> 2b9dbef272b6 (Btrfs: keep dropped roots in cache until transaction commit)
  	spinlock_t dirty_bgs_lock;
  	struct list_head deleted_bgs;
  	spinlock_t deleted_bgs_lock;
+ 	spinlock_t dropped_roots_lock;
  	struct btrfs_delayed_ref_root delayed_refs;
  	int aborted;
 -	int dirty_bg_run;
  };
  
  #define __TRANS_FREEZABLE	(1U << 0)
diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index e9de0bb5cee3..6f14f091cf24 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -8473,7 +8473,7 @@ int btrfs_drop_snapshot(struct btrfs_root *root,
 	}
 
 	if (test_bit(BTRFS_ROOT_IN_RADIX, &root->state)) {
-		btrfs_drop_and_free_fs_root(tree_root->fs_info, root);
+		btrfs_add_dropped_root(trans, root);
 	} else {
 		free_extent_buffer(root->node);
 		free_extent_buffer(root->commit_root);
* Unmerged path fs/btrfs/transaction.c
* Unmerged path fs/btrfs/transaction.h
