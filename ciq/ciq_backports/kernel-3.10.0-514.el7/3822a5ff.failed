sctp: align MTU to a word

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
commit 3822a5ff4bc32043fa9c7b6d6f125bcdca6da39c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3822a5ff.failed

SCTP is a protocol that is aligned to a word (4 bytes). Thus using bare
MTU can sometimes return values that are not aligned, like for loopback,
which is 65536 but ipv4_mtu() limits that to 65535. This mis-alignment
will cause the last non-aligned bytes to never be used and can cause
issues with congestion control.

So it's better to just consider a lower MTU and keep congestion control
calcs saner as they are based on PMTU.

Same applies to icmp frag needed messages, which is also fixed by this
patch.

One other effect of this is the inability to send MTU-sized packet
without queueing or fragmentation and without hitting Nagle. As the
check performed at sctp_packet_can_append_data():

if (chunk->skb->len + q->out_qlen >= transport->pathmtu - packet->overhead)
	/* Enough data queued to fill a packet */
	return SCTP_XMIT_OK;

with the above example of MTU, if there are no other messages queued,
one cannot send a packet that just fits one packet (65532 bytes) and
without causing DATA chunk fragmentation or a delay.

v2:
 - Added WORD_TRUNC macro

	Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3822a5ff4bc32043fa9c7b6d6f125bcdca6da39c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sctp/sctp.h
diff --cc include/net/sctp/sctp.h
index dc59f95106d2,ad2136caa7d6..000000000000
--- a/include/net/sctp/sctp.h
+++ b/include/net/sctp/sctp.h
@@@ -99,13 -82,10 +99,20 @@@
  #define SCTP_PROTOSW_FLAG INET_PROTOSW_PERMANENT
  #endif
  
++<<<<<<< HEAD
 +
 +/* Certain internal static functions need to be exported when
 + * compiled into the test frame.
 + */
 +#ifndef SCTP_STATIC
 +#define SCTP_STATIC static
 +#endif
++=======
+ /* Round an int up to the next multiple of 4.  */
+ #define WORD_ROUND(s) (((s)+3)&~3)
+ /* Truncate to the previous multiple of 4.  */
+ #define WORD_TRUNC(s) ((s)&~3)
++>>>>>>> 3822a5ff4bc3 (sctp: align MTU to a word)
  
  /*
   * Function declarations.
@@@ -604,12 -480,6 +611,15 @@@ for (pos = chunk->subh.fwdtsn_hdr->skip
       (void *)pos <= (void *)chunk->subh.fwdtsn_hdr->skip + end - sizeof(struct sctp_fwdtsn_skip);\
       pos++)
  
++<<<<<<< HEAD
 +/* Round an int up to the next multiple of 4.  */
 +#define WORD_ROUND(s) (((s)+3)&~3)
 +
 +/* Make a new instance of type.  */
 +#define t_new(type, flags)	kzalloc(sizeof(type), flags)
 +
++=======
++>>>>>>> 3822a5ff4bc3 (sctp: align MTU to a word)
  /* External references. */
  
  extern struct proto sctp_prot;
* Unmerged path include/net/sctp/sctp.h
diff --git a/net/sctp/associola.c b/net/sctp/associola.c
index 95613ef42a0c..3e21778f7486 100644
--- a/net/sctp/associola.c
+++ b/net/sctp/associola.c
@@ -1390,7 +1390,8 @@ void sctp_assoc_sync_pmtu(struct sock *sk, struct sctp_association *asoc)
 	list_for_each_entry(t, &asoc->peer.transport_addr_list,
 				transports) {
 		if (t->pmtu_pending && t->dst) {
-			sctp_transport_update_pmtu(sk, t, dst_mtu(t->dst));
+			sctp_transport_update_pmtu(sk, t,
+						   WORD_TRUNC(dst_mtu(t->dst)));
 			t->pmtu_pending = 0;
 		}
 		if (!pmtu || (t->pathmtu < pmtu))
diff --git a/net/sctp/input.c b/net/sctp/input.c
index 336fe69bc6d8..4e11c1b19b7a 100644
--- a/net/sctp/input.c
+++ b/net/sctp/input.c
@@ -621,7 +621,8 @@ void sctp_v4_err(struct sk_buff *skb, __u32 info)
 
 		/* PMTU discovery (RFC1191) */
 		if (ICMP_FRAG_NEEDED == code) {
-			sctp_icmp_frag_needed(sk, asoc, transport, info);
+			sctp_icmp_frag_needed(sk, asoc, transport,
+					      WORD_TRUNC(info));
 			goto out_unlock;
 		}
 		else {
diff --git a/net/sctp/transport.c b/net/sctp/transport.c
index 098f1d5f769e..c58bc4f62c9e 100644
--- a/net/sctp/transport.c
+++ b/net/sctp/transport.c
@@ -232,7 +232,7 @@ void sctp_transport_pmtu(struct sctp_transport *transport, struct sock *sk)
 	}
 
 	if (transport->dst) {
-		transport->pathmtu = dst_mtu(transport->dst);
+		transport->pathmtu = WORD_TRUNC(dst_mtu(transport->dst));
 	} else
 		transport->pathmtu = SCTP_DEFAULT_MAXSEGMENT;
 }
@@ -286,7 +286,7 @@ void sctp_transport_route(struct sctp_transport *transport,
 		return;
 	}
 	if (transport->dst) {
-		transport->pathmtu = dst_mtu(transport->dst);
+		transport->pathmtu = WORD_TRUNC(dst_mtu(transport->dst));
 
 		/* Initialize sk->sk_rcv_saddr, if the transport is the
 		 * association's active path for getsockname().
