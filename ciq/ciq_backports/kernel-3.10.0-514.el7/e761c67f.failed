IB/mlx4: Remove old FRWR API support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sagi Grimberg <sagig@mellanox.com>
commit e761c67fbf20d60175750ce2994822f30f2edf6a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e761c67f.failed

No ULP uses it anymore, go ahead and remove it.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Acked-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit e761c67fbf20d60175750ce2994822f30f2edf6a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx4/cq.c
#	drivers/infiniband/hw/mlx4/main.c
#	drivers/infiniband/hw/mlx4/mlx4_ib.h
#	drivers/infiniband/hw/mlx4/qp.c
diff --cc drivers/infiniband/hw/mlx4/cq.c
index 5fd49f9435f9,b88fc8f5ab18..000000000000
--- a/drivers/infiniband/hw/mlx4/cq.c
+++ b/drivers/infiniband/hw/mlx4/cq.c
@@@ -818,7 -818,7 +818,11 @@@ repoll
  			wc->opcode    = IB_WC_LSO;
  			break;
  		case MLX4_OPCODE_FMR:
++<<<<<<< HEAD
 +			wc->opcode    = IB_WC_FAST_REG_MR;
++=======
+ 			wc->opcode    = IB_WC_REG_MR;
++>>>>>>> e761c67fbf20 (IB/mlx4: Remove old FRWR API support)
  			break;
  		case MLX4_OPCODE_LOCAL_INVAL:
  			wc->opcode    = IB_WC_LOCAL_INV;
diff --cc drivers/infiniband/hw/mlx4/main.c
index 6c176c7cae81,f567160a4a56..000000000000
--- a/drivers/infiniband/hw/mlx4/main.c
+++ b/drivers/infiniband/hw/mlx4/main.c
@@@ -2681,8 -2266,7 +2681,12 @@@ static void *mlx4_ib_add(struct mlx4_de
  	ibdev->ib_dev.rereg_user_mr	= mlx4_ib_rereg_user_mr;
  	ibdev->ib_dev.dereg_mr		= mlx4_ib_dereg_mr;
  	ibdev->ib_dev.alloc_mr		= mlx4_ib_alloc_mr;
++<<<<<<< HEAD
 +	ibdev->ib_dev.alloc_fast_reg_page_list = mlx4_ib_alloc_fast_reg_page_list;
 +	ibdev->ib_dev.free_fast_reg_page_list  = mlx4_ib_free_fast_reg_page_list;
++=======
+ 	ibdev->ib_dev.map_mr_sg		= mlx4_ib_map_mr_sg;
++>>>>>>> e761c67fbf20 (IB/mlx4: Remove old FRWR API support)
  	ibdev->ib_dev.attach_mcast	= mlx4_ib_mcg_attach;
  	ibdev->ib_dev.detach_mcast	= mlx4_ib_mcg_detach;
  	ibdev->ib_dev.process_mad	= mlx4_ib_process_mad;
diff --cc drivers/infiniband/hw/mlx4/mlx4_ib.h
index 8009e0b53f2d,1caa11edac03..000000000000
--- a/drivers/infiniband/hw/mlx4/mlx4_ib.h
+++ b/drivers/infiniband/hw/mlx4/mlx4_ib.h
@@@ -718,10 -710,9 +707,16 @@@ int mlx4_ib_dealloc_mw(struct ib_mw *mw
  struct ib_mr *mlx4_ib_alloc_mr(struct ib_pd *pd,
  			       enum ib_mr_type mr_type,
  			       u32 max_num_sg);
++<<<<<<< HEAD
 +struct ib_fast_reg_page_list *mlx4_ib_alloc_fast_reg_page_list(struct ib_device *ibdev,
 +							       int page_list_len);
 +void mlx4_ib_free_fast_reg_page_list(struct ib_fast_reg_page_list *page_list);
 +
++=======
+ int mlx4_ib_map_mr_sg(struct ib_mr *ibmr,
+ 		      struct scatterlist *sg,
+ 		      int sg_nents);
++>>>>>>> e761c67fbf20 (IB/mlx4: Remove old FRWR API support)
  int mlx4_ib_modify_cq(struct ib_cq *cq, u16 cq_count, u16 cq_period);
  int mlx4_ib_resize_cq(struct ib_cq *ibcq, int entries, struct ib_udata *udata);
  struct ib_cq *mlx4_ib_create_cq(struct ib_device *ibdev,
diff --cc drivers/infiniband/hw/mlx4/qp.c
index c12d726340f5,a2e4ca56da44..000000000000
--- a/drivers/infiniband/hw/mlx4/qp.c
+++ b/drivers/infiniband/hw/mlx4/qp.c
@@@ -111,7 -111,7 +111,11 @@@ static const __be32 mlx4_ib_opcode[] = 
  	[IB_WR_ATOMIC_FETCH_AND_ADD]		= cpu_to_be32(MLX4_OPCODE_ATOMIC_FA),
  	[IB_WR_SEND_WITH_INV]			= cpu_to_be32(MLX4_OPCODE_SEND_INVAL),
  	[IB_WR_LOCAL_INV]			= cpu_to_be32(MLX4_OPCODE_LOCAL_INVAL),
++<<<<<<< HEAD
 +	[IB_WR_FAST_REG_MR]			= cpu_to_be32(MLX4_OPCODE_FMR),
++=======
+ 	[IB_WR_REG_MR]				= cpu_to_be32(MLX4_OPCODE_FMR),
++>>>>>>> e761c67fbf20 (IB/mlx4: Remove old FRWR API support)
  	[IB_WR_MASKED_ATOMIC_CMP_AND_SWP]	= cpu_to_be32(MLX4_OPCODE_MASKED_ATOMIC_CS),
  	[IB_WR_MASKED_ATOMIC_FETCH_AND_ADD]	= cpu_to_be32(MLX4_OPCODE_MASKED_ATOMIC_FA),
  	[IB_WR_BIND_MW]				= cpu_to_be32(MLX4_OPCODE_BIND_MW),
@@@ -2473,31 -2505,27 +2477,48 @@@ static __be32 convert_access(int acc
  		cpu_to_be32(MLX4_WQE_FMR_PERM_LOCAL_READ);
  }
  
 -static void set_reg_seg(struct mlx4_wqe_fmr_seg *fseg,
 -			struct ib_reg_wr *wr)
 +static void set_fmr_seg(struct mlx4_wqe_fmr_seg *fseg, struct ib_send_wr *wr)
  {
++<<<<<<< HEAD
 +	struct mlx4_ib_fast_reg_page_list *mfrpl = to_mfrpl(wr->wr.fast_reg.page_list);
 +	int i;
 +
 +	for (i = 0; i < wr->wr.fast_reg.page_list_len; ++i)
 +		mfrpl->mapped_page_list[i] =
 +			cpu_to_be64(wr->wr.fast_reg.page_list->page_list[i] |
 +				    MLX4_MTT_FLAG_PRESENT);
 +
 +	fseg->flags		= convert_access(wr->wr.fast_reg.access_flags);
 +	fseg->mem_key		= cpu_to_be32(wr->wr.fast_reg.rkey);
 +	fseg->buf_list		= cpu_to_be64(mfrpl->map);
 +	fseg->start_addr	= cpu_to_be64(wr->wr.fast_reg.iova_start);
 +	fseg->reg_len		= cpu_to_be64(wr->wr.fast_reg.length);
 +	fseg->offset		= 0; /* XXX -- is this just for ZBVA? */
 +	fseg->page_size		= cpu_to_be32(wr->wr.fast_reg.page_shift);
++=======
+ 	struct mlx4_ib_mr *mr = to_mmr(wr->mr);
+ 
+ 	fseg->flags		= convert_access(wr->access);
+ 	fseg->mem_key		= cpu_to_be32(wr->key);
+ 	fseg->buf_list		= cpu_to_be64(mr->page_map);
+ 	fseg->start_addr	= cpu_to_be64(mr->ibmr.iova);
+ 	fseg->reg_len		= cpu_to_be64(mr->ibmr.length);
+ 	fseg->offset		= 0; /* XXX -- is this just for ZBVA? */
+ 	fseg->page_size		= cpu_to_be32(ilog2(mr->ibmr.page_size));
++>>>>>>> e761c67fbf20 (IB/mlx4: Remove old FRWR API support)
  	fseg->reserved[0]	= 0;
  	fseg->reserved[1]	= 0;
  }
  
++<<<<<<< HEAD
 +static void set_bind_seg(struct mlx4_wqe_bind_seg *bseg, struct ib_send_wr *wr)
++=======
+ static void set_bind_seg(struct mlx4_wqe_bind_seg *bseg,
+ 		struct ib_bind_mw_wr *wr)
++>>>>>>> e761c67fbf20 (IB/mlx4: Remove old FRWR API support)
  {
  	bseg->flags1 =
 -		convert_access(wr->bind_info.mw_access_flags) &
 +		convert_access(wr->wr.bind_mw.bind_info.mw_access_flags) &
  		cpu_to_be32(MLX4_WQE_FMR_AND_BIND_PERM_REMOTE_READ  |
  			    MLX4_WQE_FMR_AND_BIND_PERM_REMOTE_WRITE |
  			    MLX4_WQE_FMR_AND_BIND_PERM_ATOMIC);
@@@ -2823,12 -2852,12 +2844,21 @@@ int mlx4_ib_post_send(struct ib_qp *ibq
  				size += sizeof (struct mlx4_wqe_local_inval_seg) / 16;
  				break;
  
++<<<<<<< HEAD
 +			case IB_WR_FAST_REG_MR:
 +				ctrl->srcrb_flags |=
 +					cpu_to_be32(MLX4_WQE_CTRL_STRONG_ORDER);
 +				set_fmr_seg(wqe, wr);
 +				wqe  += sizeof (struct mlx4_wqe_fmr_seg);
 +				size += sizeof (struct mlx4_wqe_fmr_seg) / 16;
++=======
+ 			case IB_WR_REG_MR:
+ 				ctrl->srcrb_flags |=
+ 					cpu_to_be32(MLX4_WQE_CTRL_STRONG_ORDER);
+ 				set_reg_seg(wqe, reg_wr(wr));
+ 				wqe  += sizeof(struct mlx4_wqe_fmr_seg);
+ 				size += sizeof(struct mlx4_wqe_fmr_seg) / 16;
++>>>>>>> e761c67fbf20 (IB/mlx4: Remove old FRWR API support)
  				break;
  
  			case IB_WR_BIND_MW:
* Unmerged path drivers/infiniband/hw/mlx4/cq.c
* Unmerged path drivers/infiniband/hw/mlx4/main.c
* Unmerged path drivers/infiniband/hw/mlx4/mlx4_ib.h
diff --git a/drivers/infiniband/hw/mlx4/mr.c b/drivers/infiniband/hw/mlx4/mr.c
index 2542fd3c1a49..c8346edcc607 100644
--- a/drivers/infiniband/hw/mlx4/mr.c
+++ b/drivers/infiniband/hw/mlx4/mr.c
@@ -388,54 +388,6 @@ err_free:
 	return ERR_PTR(err);
 }
 
-struct ib_fast_reg_page_list *mlx4_ib_alloc_fast_reg_page_list(struct ib_device *ibdev,
-							       int page_list_len)
-{
-	struct mlx4_ib_dev *dev = to_mdev(ibdev);
-	struct mlx4_ib_fast_reg_page_list *mfrpl;
-	int size = page_list_len * sizeof (u64);
-
-	if (page_list_len > MLX4_MAX_FAST_REG_PAGES)
-		return ERR_PTR(-EINVAL);
-
-	mfrpl = kmalloc(sizeof *mfrpl, GFP_KERNEL);
-	if (!mfrpl)
-		return ERR_PTR(-ENOMEM);
-
-	mfrpl->ibfrpl.page_list = kmalloc(size, GFP_KERNEL);
-	if (!mfrpl->ibfrpl.page_list)
-		goto err_free;
-
-	mfrpl->mapped_page_list = dma_alloc_coherent(&dev->dev->persist->
-						     pdev->dev,
-						     size, &mfrpl->map,
-						     GFP_KERNEL);
-	if (!mfrpl->mapped_page_list)
-		goto err_free;
-
-	WARN_ON(mfrpl->map & 0x3f);
-
-	return &mfrpl->ibfrpl;
-
-err_free:
-	kfree(mfrpl->ibfrpl.page_list);
-	kfree(mfrpl);
-	return ERR_PTR(-ENOMEM);
-}
-
-void mlx4_ib_free_fast_reg_page_list(struct ib_fast_reg_page_list *page_list)
-{
-	struct mlx4_ib_dev *dev = to_mdev(page_list->device);
-	struct mlx4_ib_fast_reg_page_list *mfrpl = to_mfrpl(page_list);
-	int size = page_list->max_page_list_len * sizeof (u64);
-
-	dma_free_coherent(&dev->dev->persist->pdev->dev, size,
-			  mfrpl->mapped_page_list,
-			  mfrpl->map);
-	kfree(mfrpl->ibfrpl.page_list);
-	kfree(mfrpl);
-}
-
 struct ib_fmr *mlx4_ib_fmr_alloc(struct ib_pd *pd, int acc,
 				 struct ib_fmr_attr *fmr_attr)
 {
* Unmerged path drivers/infiniband/hw/mlx4/qp.c
