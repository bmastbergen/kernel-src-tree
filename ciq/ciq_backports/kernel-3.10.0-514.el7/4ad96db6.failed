mei: push pci cfg structure me hw

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 4ad96db6ccdd8b777cff5fd4aa74ec1e86f1afce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4ad96db6.failed

Device specific configurations are currently only needed by me hw
so we can remove it from txe

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 4ad96db6ccdd8b777cff5fd4aa74ec1e86f1afce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/hw-me.c
#	drivers/misc/mei/hw-me.h
#	drivers/misc/mei/hw-txe.c
diff --cc drivers/misc/mei/hw-me.c
index 241eae550b0c,77166ea30a4d..000000000000
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@@ -101,6 -101,34 +101,37 @@@ static inline void mei_hcsr_set(struct 
  	mei_me_reg_write(hw, H_CSR, hcsr);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * mei_me_fw_status - read fw status register from pci config space
+  *
+  * @dev: mei device
+  * @fw_status: fw status register values
+  */
+ static int mei_me_fw_status(struct mei_device *dev,
+ 			    struct mei_fw_status *fw_status)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev->dev);
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 	const struct mei_fw_status *fw_src = &hw->cfg->fw_status;
+ 	int ret;
+ 	int i;
+ 
+ 	if (!fw_status)
+ 		return -EINVAL;
+ 
+ 	fw_status->count = fw_src->count;
+ 	for (i = 0; i < fw_src->count && i < MEI_FW_STATUS_MAX; i++) {
+ 		ret = pci_read_config_dword(pdev,
+ 			fw_src->status[i], &fw_status->status[i]);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
++>>>>>>> 4ad96db6ccdd (mei: push pci cfg structure me hw)
  
  /**
   * mei_me_hw_config - configure hw dependent settings
@@@ -811,12 -853,10 +843,18 @@@ struct mei_device *mei_me_dev_init(stru
  			 sizeof(struct mei_me_hw), GFP_KERNEL);
  	if (!dev)
  		return NULL;
+ 	hw = to_me_hw(dev);
  
++<<<<<<< HEAD
 +	mei_device_init(dev, cfg);
 +
 +	dev->ops = &mei_me_hw_ops;
 +
 +	dev->pdev = pdev;
++=======
+ 	mei_device_init(dev, &pdev->dev, &mei_me_hw_ops);
+ 	hw->cfg = cfg;
++>>>>>>> 4ad96db6ccdd (mei: push pci cfg structure me hw)
  	return dev;
  }
  
diff --cc drivers/misc/mei/hw-me.h
index 98ceac2cee68,b0001b3a0fb5..000000000000
--- a/drivers/misc/mei/hw-me.h
+++ b/drivers/misc/mei/hw-me.h
@@@ -24,7 -26,31 +26,34 @@@
  #include "mei_dev.h"
  #include "client.h"
  
++<<<<<<< HEAD
++=======
+ /*
+  * mei_cfg - mei device configuration
+  *
+  * @fw_status: FW status
+  * @quirk_probe: device exclusion quirk
+  */
+ struct mei_cfg {
+ 	const struct mei_fw_status fw_status;
+ 	bool (*quirk_probe)(struct pci_dev *pdev);
+ };
+ 
+ 
+ #define MEI_PCI_DEVICE(dev, cfg) \
+ 	.vendor = PCI_VENDOR_ID_INTEL, .device = (dev), \
+ 	.subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID, \
+ 	.driver_data = (kernel_ulong_t)&(cfg)
+ 
+ 
+ #define MEI_ME_RPM_TIMEOUT    500 /* ms */
+ 
+ /**
+  * @cfg: per device generation config and ops
+  */
++>>>>>>> 4ad96db6ccdd (mei: push pci cfg structure me hw)
  struct mei_me_hw {
+ 	const struct mei_cfg *cfg;
  	void __iomem *mem_addr;
  	/*
  	 * hw states of host and fw(ME)
diff --cc drivers/misc/mei/hw-txe.c
index f1cd166094f2,f33fbcbcdf63..000000000000
--- a/drivers/misc/mei/hw-txe.c
+++ b/drivers/misc/mei/hw-txe.c
@@@ -559,6 -573,40 +559,43 @@@ static int mei_txe_readiness_wait(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ const struct mei_fw_status mei_txe_fw_sts = {
+ 	.count = 2,
+ 	.status[0] = PCI_CFG_TXE_FW_STS0,
+ 	.status[1] = PCI_CFG_TXE_FW_STS1
+ };
+ 
+ /**
+  * mei_txe_fw_status - read fw status register from pci config space
+  *
+  * @dev: mei device
+  * @fw_status: fw status register values
+  */
+ static int mei_txe_fw_status(struct mei_device *dev,
+ 			     struct mei_fw_status *fw_status)
+ {
+ 	const struct mei_fw_status *fw_src = &mei_txe_fw_sts;
+ 	struct pci_dev *pdev = to_pci_dev(dev->dev);
+ 	int ret;
+ 	int i;
+ 
+ 	if (!fw_status)
+ 		return -EINVAL;
+ 
+ 	fw_status->count = fw_src->count;
+ 	for (i = 0; i < fw_src->count && i < MEI_FW_STATUS_MAX; i++) {
+ 		ret = pci_read_config_dword(pdev,
+ 			fw_src->status[i], &fw_status->status[i]);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 4ad96db6ccdd (mei: push pci cfg structure me hw)
  /**
   *  mei_txe_hw_config - configure hardware at the start of the devices
   *
@@@ -1108,9 -1149,6 +1133,12 @@@ struct mei_device *mei_txe_dev_init(str
  
  	init_waitqueue_head(&hw->wait_aliveness_resp);
  
++<<<<<<< HEAD
 +	dev->ops = &mei_txe_hw_ops;
 +
 +	dev->pdev = pdev;
++=======
++>>>>>>> 4ad96db6ccdd (mei: push pci cfg structure me hw)
  	return dev;
  }
  
* Unmerged path drivers/misc/mei/hw-me.c
* Unmerged path drivers/misc/mei/hw-me.h
* Unmerged path drivers/misc/mei/hw-txe.c
diff --git a/drivers/misc/mei/hw-txe.h b/drivers/misc/mei/hw-txe.h
index e244af79167f..e8dd2d165c25 100644
--- a/drivers/misc/mei/hw-txe.h
+++ b/drivers/misc/mei/hw-txe.h
@@ -61,10 +61,7 @@ static inline struct mei_device *hw_txe_to_mei(struct mei_txe_hw *hw)
 	return container_of((void *)hw, struct mei_device, hw);
 }
 
-extern const struct mei_cfg mei_txe_cfg;
-
-struct mei_device *mei_txe_dev_init(struct pci_dev *pdev,
-	const struct mei_cfg *cfg);
+struct mei_device *mei_txe_dev_init(struct pci_dev *pdev);
 
 irqreturn_t mei_txe_irq_quick_handler(int irq, void *dev_id);
 irqreturn_t mei_txe_irq_thread_handler(int irq, void *dev_id);
diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h
index 1b981b70f5aa..c8e8b5019103 100644
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -382,24 +382,6 @@ enum mei_pg_state {
 
 const char *mei_pg_state_str(enum mei_pg_state state);
 
-/*
- * mei_cfg
- *
- * @fw_status - FW status
- * @quirk_probe - device exclusion quirk
- */
-struct mei_cfg {
-	const struct mei_fw_status fw_status;
-	bool (*quirk_probe)(struct pci_dev *pdev);
-};
-
-
-#define MEI_PCI_DEVICE(dev, cfg) \
-	.vendor = PCI_VENDOR_ID_INTEL, .device = (dev), \
-	.subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID, \
-	.driver_data = (kernel_ulong_t)&(cfg)
-
-
 /**
  * struct mei_device -  MEI private device struct
 
@@ -414,7 +396,6 @@ struct mei_cfg {
  * @hbuf_depth - depth of hardware host/write buffer is slots
  * @hbuf_is_ready - query if the host host/write buffer is ready
  * @wr_msg - the buffer for hbm control messages
- * @cfg - per device generation config and ops
  */
 struct mei_device {
 	struct pci_dev *pdev;	/* pointer to pci device struct */
@@ -523,7 +504,6 @@ struct mei_device {
 
 
 	const struct mei_hw_ops *ops;
-	const struct mei_cfg *cfg;
 	char hw[0] __aligned(sizeof(void *));
 };
 
diff --git a/drivers/misc/mei/pci-txe.c b/drivers/misc/mei/pci-txe.c
index 2343c6236df9..86d13ea19817 100644
--- a/drivers/misc/mei/pci-txe.c
+++ b/drivers/misc/mei/pci-txe.c
@@ -36,7 +36,8 @@
 #include "hw-txe.h"
 
 static const struct pci_device_id mei_txe_pci_tbl[] = {
-	{MEI_PCI_DEVICE(0x0F18, mei_txe_cfg)}, /* Baytrail */
+	{PCI_VDEVICE(INTEL, 0x0F18)}, /* Baytrail */
+
 	{0, }
 };
 MODULE_DEVICE_TABLE(pci, mei_txe_pci_tbl);
@@ -69,7 +70,6 @@ static void mei_txe_pci_iounmap(struct pci_dev *pdev, struct mei_txe_hw *hw)
  */
 static int mei_txe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
-	const struct mei_cfg *cfg = (struct mei_cfg *)(ent->driver_data);
 	struct mei_device *dev;
 	struct mei_txe_hw *hw;
 	int err;
@@ -100,7 +100,7 @@ static int mei_txe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	}
 
 	/* allocates and initializes the mei dev structure */
-	dev = mei_txe_dev_init(pdev, cfg);
+	dev = mei_txe_dev_init(pdev);
 	if (!dev) {
 		err = -ENOMEM;
 		goto release_regions;
