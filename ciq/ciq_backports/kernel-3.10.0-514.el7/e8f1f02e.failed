drm/i915: Reorganize WM structs/unions in CRTC state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matt Roper <matthew.d.roper@intel.com>
commit e8f1f02e7125220b99af8047703b63c11a7081d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e8f1f02e.failed

Reorganize the nested structures and unions we have for pipe watermark
data in intel_crtc_state so that platform-specific data can be added in
a more sensible manner (and save a bit of memory at the same time).

The change basically changes the organization from:

        union {
                struct intel_pipe_wm ilk;
                struct intel_pipe_wm skl;
        } optimal;

        struct intel_pipe_wm intermediate /* ILK-only */

to

        union {
                struct {
                        struct intel_pipe_wm intermediate;
                        struct intel_pipe_wm optimal;
                } ilk;

                struct {
                        struct intel_pipe_wm optimal;
                } skl;
        }

There should be no functional change here, but it will allow us to add
more platform-specific fields going forward (and more easily extend to
other platform types like VLV).

While we're at it, let's move the entire watermark substructure out to
its own structure definition to make the code slightly more readable.

	Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1463061971-19638-2-git-send-email-matthew.d.roper@intel.com
(cherry picked from commit e8f1f02e7125220b99af8047703b63c11a7081d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_drv.h
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_drv.h
index 640e923ced09,0ec4159c920e..000000000000
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@@ -262,6 -344,101 +262,104 @@@ struct intel_initial_plane_config 
  	u32 base;
  };
  
++<<<<<<< HEAD
++=======
+ #define SKL_MIN_SRC_W 8
+ #define SKL_MAX_SRC_W 4096
+ #define SKL_MIN_SRC_H 8
+ #define SKL_MAX_SRC_H 4096
+ #define SKL_MIN_DST_W 8
+ #define SKL_MAX_DST_W 4096
+ #define SKL_MIN_DST_H 8
+ #define SKL_MAX_DST_H 4096
+ 
+ struct intel_scaler {
+ 	int in_use;
+ 	uint32_t mode;
+ };
+ 
+ struct intel_crtc_scaler_state {
+ #define SKL_NUM_SCALERS 2
+ 	struct intel_scaler scalers[SKL_NUM_SCALERS];
+ 
+ 	/*
+ 	 * scaler_users: keeps track of users requesting scalers on this crtc.
+ 	 *
+ 	 *     If a bit is set, a user is using a scaler.
+ 	 *     Here user can be a plane or crtc as defined below:
+ 	 *       bits 0-30 - plane (bit position is index from drm_plane_index)
+ 	 *       bit 31    - crtc
+ 	 *
+ 	 * Instead of creating a new index to cover planes and crtc, using
+ 	 * existing drm_plane_index for planes which is well less than 31
+ 	 * planes and bit 31 for crtc. This should be fine to cover all
+ 	 * our platforms.
+ 	 *
+ 	 * intel_atomic_setup_scalers will setup available scalers to users
+ 	 * requesting scalers. It will gracefully fail if request exceeds
+ 	 * avilability.
+ 	 */
+ #define SKL_CRTC_INDEX 31
+ 	unsigned scaler_users;
+ 
+ 	/* scaler used by crtc for panel fitting purpose */
+ 	int scaler_id;
+ };
+ 
+ /* drm_mode->private_flags */
+ #define I915_MODE_FLAG_INHERITED 1
+ 
+ struct intel_pipe_wm {
+ 	struct intel_wm_level wm[5];
+ 	struct intel_wm_level raw_wm[5];
+ 	uint32_t linetime;
+ 	bool fbc_wm_enabled;
+ 	bool pipe_enabled;
+ 	bool sprites_enabled;
+ 	bool sprites_scaled;
+ };
+ 
+ struct skl_pipe_wm {
+ 	struct skl_wm_level wm[8];
+ 	struct skl_wm_level trans_wm;
+ 	uint32_t linetime;
+ };
+ 
+ struct intel_crtc_wm_state {
+ 	union {
+ 		struct {
+ 			/*
+ 			 * Intermediate watermarks; these can be
+ 			 * programmed immediately since they satisfy
+ 			 * both the current configuration we're
+ 			 * switching away from and the new
+ 			 * configuration we're switching to.
+ 			 */
+ 			struct intel_pipe_wm intermediate;
+ 
+ 			/*
+ 			 * Optimal watermarks, programmed post-vblank
+ 			 * when this state is committed.
+ 			 */
+ 			struct intel_pipe_wm optimal;
+ 		} ilk;
+ 
+ 		struct {
+ 			/* gen9+ only needs 1-step wm programming */
+ 			struct skl_pipe_wm optimal;
+ 		} skl;
+ 	};
+ 
+ 	/*
+ 	 * Platforms with two-step watermark programming will need to
+ 	 * update watermark programming post-vblank to switch from the
+ 	 * safe intermediate watermarks to the optimal final
+ 	 * watermarks.
+ 	 */
+ 	bool need_postvbl_update;
+ };
+ 
++>>>>>>> e8f1f02e7125 (drm/i915: Reorganize WM structs/unions in CRTC state)
  struct intel_crtc_state {
  	struct drm_crtc_state base;
  
@@@ -388,15 -583,28 +486,31 @@@
  
  	bool dp_encoder_is_mst;
  	int pbn;
++<<<<<<< HEAD
++=======
+ 
+ 	struct intel_crtc_scaler_state scaler_state;
+ 
+ 	/* w/a for waiting 2 vblanks during crtc enable */
+ 	enum pipe hsw_workaround_pipe;
+ 
+ 	/* IVB sprite scaling w/a (WaCxSRDisabledForSpriteScaling:ivb) */
+ 	bool disable_lp_wm;
+ 
+ 	struct intel_crtc_wm_state wm;
+ 
+ 	/* Gamma mode programmed on the pipe */
+ 	uint32_t gamma_mode;
++>>>>>>> e8f1f02e7125 (drm/i915: Reorganize WM structs/unions in CRTC state)
  };
  
 -struct vlv_wm_state {
 -	struct vlv_pipe_wm wm[3];
 -	struct vlv_sr_wm sr[3];
 -	uint8_t num_active_planes;
 -	uint8_t num_levels;
 -	uint8_t level;
 -	bool cxsr;
 +struct intel_pipe_wm {
 +	struct intel_wm_level wm[5];
 +	uint32_t linetime;
 +	bool fbc_wm_enabled;
 +	bool pipe_enabled;
 +	bool sprites_enabled;
 +	bool sprites_scaled;
  };
  
  struct intel_mmio_flip {
diff --cc drivers/gpu/drm/i915/intel_pm.c
index cca54888a5ac,540c6518b052..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -2127,8 -2286,76 +2127,78 @@@ static bool intel_compute_pipe_wm(struc
  	ilk_compute_wm_maximums(dev, 0, &config, INTEL_DDB_PART_1_2, &max);
  
  	/* At least LP0 must be valid */
 -	if (!ilk_validate_wm_level(0, &max, &pipe_wm->wm[0])) {
 -		DRM_DEBUG_KMS("LP0 watermark invalid\n");
 +	if (!ilk_validate_wm_level(0, &max, &pipe_wm->wm[0]))
  		return false;
++<<<<<<< HEAD
++=======
+ 	}
+ 
+ 	return true;
+ }
+ 
+ /* Compute new watermarks for the pipe */
+ static int ilk_compute_pipe_wm(struct intel_crtc_state *cstate)
+ {
+ 	struct drm_atomic_state *state = cstate->base.state;
+ 	struct intel_crtc *intel_crtc = to_intel_crtc(cstate->base.crtc);
+ 	struct intel_pipe_wm *pipe_wm;
+ 	struct drm_device *dev = state->dev;
+ 	const struct drm_i915_private *dev_priv = dev->dev_private;
+ 	struct intel_plane *intel_plane;
+ 	struct intel_plane_state *pristate = NULL;
+ 	struct intel_plane_state *sprstate = NULL;
+ 	struct intel_plane_state *curstate = NULL;
+ 	int level, max_level = ilk_wm_max_level(dev), usable_level;
+ 	struct ilk_wm_maximums max;
+ 
+ 	pipe_wm = &cstate->wm.ilk.optimal;
+ 
+ 	for_each_intel_plane_on_crtc(dev, intel_crtc, intel_plane) {
+ 		struct intel_plane_state *ps;
+ 
+ 		ps = intel_atomic_get_existing_plane_state(state,
+ 							   intel_plane);
+ 		if (!ps)
+ 			continue;
+ 
+ 		if (intel_plane->base.type == DRM_PLANE_TYPE_PRIMARY)
+ 			pristate = ps;
+ 		else if (intel_plane->base.type == DRM_PLANE_TYPE_OVERLAY)
+ 			sprstate = ps;
+ 		else if (intel_plane->base.type == DRM_PLANE_TYPE_CURSOR)
+ 			curstate = ps;
+ 	}
+ 
+ 	pipe_wm->pipe_enabled = cstate->base.active;
+ 	if (sprstate) {
+ 		pipe_wm->sprites_enabled = sprstate->visible;
+ 		pipe_wm->sprites_scaled = sprstate->visible &&
+ 			(drm_rect_width(&sprstate->dst) != drm_rect_width(&sprstate->src) >> 16 ||
+ 			 drm_rect_height(&sprstate->dst) != drm_rect_height(&sprstate->src) >> 16);
+ 	}
+ 
+ 	usable_level = max_level;
+ 
+ 	/* ILK/SNB: LP2+ watermarks only w/o sprites */
+ 	if (INTEL_INFO(dev)->gen <= 6 && pipe_wm->sprites_enabled)
+ 		usable_level = 1;
+ 
+ 	/* ILK/SNB/IVB: LP1+ watermarks only w/o scaling */
+ 	if (pipe_wm->sprites_scaled)
+ 		usable_level = 0;
+ 
+ 	ilk_compute_wm_level(dev_priv, intel_crtc, 0, cstate,
+ 			     pristate, sprstate, curstate, &pipe_wm->raw_wm[0]);
+ 
+ 	memset(&pipe_wm->wm, 0, sizeof(pipe_wm->wm));
+ 	pipe_wm->wm[0] = pipe_wm->raw_wm[0];
+ 
+ 	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
+ 		pipe_wm->linetime = hsw_compute_linetime_wm(cstate);
+ 
+ 	if (!ilk_validate_pipe_wm(dev, pipe_wm))
+ 		return -EINVAL;
++>>>>>>> e8f1f02e7125 (drm/i915: Reorganize WM structs/unions in CRTC state)
  
  	ilk_compute_wm_reg_maximums(dev, 1, &max);
  
@@@ -2142,13 -2370,69 +2212,70 @@@
  		 * register maximums since such watermarks are
  		 * always invalid.
  		 */
 -		if (level > usable_level)
 -			continue;
 +		if (!ilk_validate_wm_level(level, &max, &wm))
 +			break;
  
 -		if (ilk_validate_wm_level(level, &max, wm))
 -			pipe_wm->wm[level] = *wm;
 -		else
 -			usable_level = level;
 +		pipe_wm->wm[level] = wm;
  	}
  
++<<<<<<< HEAD
 +	return true;
++=======
+ 	return 0;
+ }
+ 
+ /*
+  * Build a set of 'intermediate' watermark values that satisfy both the old
+  * state and the new state.  These can be programmed to the hardware
+  * immediately.
+  */
+ static int ilk_compute_intermediate_wm(struct drm_device *dev,
+ 				       struct intel_crtc *intel_crtc,
+ 				       struct intel_crtc_state *newstate)
+ {
+ 	struct intel_pipe_wm *a = &newstate->wm.ilk.intermediate;
+ 	struct intel_pipe_wm *b = &intel_crtc->wm.active.ilk;
+ 	int level, max_level = ilk_wm_max_level(dev);
+ 
+ 	/*
+ 	 * Start with the final, target watermarks, then combine with the
+ 	 * currently active watermarks to get values that are safe both before
+ 	 * and after the vblank.
+ 	 */
+ 	*a = newstate->wm.ilk.optimal;
+ 	a->pipe_enabled |= b->pipe_enabled;
+ 	a->sprites_enabled |= b->sprites_enabled;
+ 	a->sprites_scaled |= b->sprites_scaled;
+ 
+ 	for (level = 0; level <= max_level; level++) {
+ 		struct intel_wm_level *a_wm = &a->wm[level];
+ 		const struct intel_wm_level *b_wm = &b->wm[level];
+ 
+ 		a_wm->enable &= b_wm->enable;
+ 		a_wm->pri_val = max(a_wm->pri_val, b_wm->pri_val);
+ 		a_wm->spr_val = max(a_wm->spr_val, b_wm->spr_val);
+ 		a_wm->cur_val = max(a_wm->cur_val, b_wm->cur_val);
+ 		a_wm->fbc_val = max(a_wm->fbc_val, b_wm->fbc_val);
+ 	}
+ 
+ 	/*
+ 	 * We need to make sure that these merged watermark values are
+ 	 * actually a valid configuration themselves.  If they're not,
+ 	 * there's no safe way to transition from the old state to
+ 	 * the new state, so we need to fail the atomic transaction.
+ 	 */
+ 	if (!ilk_validate_pipe_wm(dev, a))
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * If our intermediate WM are identical to the final WM, then we can
+ 	 * omit the post-vblank programming; only update if it's different.
+ 	 */
+ 	if (memcmp(a, &newstate->wm.ilk.optimal, sizeof(*a)) == 0)
+ 		newstate->wm.need_postvbl_update = false;
+ 
+ 	return 0;
++>>>>>>> e8f1f02e7125 (drm/i915: Reorganize WM structs/unions in CRTC state)
  }
  
  /*
@@@ -3326,23 -3676,23 +3453,28 @@@ static void skl_update_wm(struct drm_cr
  	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
  	struct drm_device *dev = crtc->dev;
  	struct drm_i915_private *dev_priv = dev->dev_private;
 +	struct skl_pipe_wm_parameters params = {};
  	struct skl_wm_values *results = &dev_priv->wm.skl_results;
++<<<<<<< HEAD
 +	struct skl_pipe_wm pipe_wm = {};
 +	struct intel_wm_config config = {};
++=======
+ 	struct intel_crtc_state *cstate = to_intel_crtc_state(crtc->state);
+ 	struct skl_pipe_wm *pipe_wm = &cstate->wm.skl.optimal;
++>>>>>>> e8f1f02e7125 (drm/i915: Reorganize WM structs/unions in CRTC state)
  
 +	memset(results, 0, sizeof(*results));
  
 -	/* Clear all dirty flags */
 -	memset(results->dirty, 0, sizeof(bool) * I915_MAX_PIPES);
 -
 -	skl_clear_wm(results, intel_crtc->pipe);
 +	skl_compute_wm_global_parameters(dev, &config);
  
 -	if (!skl_update_pipe_wm(crtc, &results->ddb, pipe_wm))
 +	if (!skl_update_pipe_wm(crtc, &params, &config,
 +				&results->ddb, &pipe_wm))
  		return;
  
 -	skl_compute_wm_results(dev, pipe_wm, results, intel_crtc);
 +	skl_compute_wm_results(dev, &params, &pipe_wm, results, intel_crtc);
  	results->dirty[intel_crtc->pipe] = true;
  
 -	skl_update_other_pipe_wm(dev, crtc, results);
 +	skl_update_other_pipe_wm(dev, crtc, &config, results);
  	skl_write_wm_values(dev_priv, results);
  	skl_flush_wm_values(dev_priv, results);
  
@@@ -3421,32 -3751,28 +3553,49 @@@ static void ilk_update_wm(struct drm_cr
  	ilk_write_wm_values(dev_priv, &results);
  }
  
 -static void ilk_initial_watermarks(struct intel_crtc_state *cstate)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(cstate->base.crtc->dev);
 -	struct intel_crtc *intel_crtc = to_intel_crtc(cstate->base.crtc);
 -
 +static void
 +ilk_update_sprite_wm(struct drm_plane *plane,
 +		     struct drm_crtc *crtc,
 +		     uint32_t sprite_width, uint32_t sprite_height,
 +		     int pixel_size, bool enabled, bool scaled)
 +{
 +	struct drm_device *dev = plane->dev;
 +	struct intel_plane *intel_plane = to_intel_plane(plane);
 +
++<<<<<<< HEAD
 +	intel_plane->wm.enabled = enabled;
 +	intel_plane->wm.scaled = scaled;
 +	intel_plane->wm.horiz_pixels = sprite_width;
 +	intel_plane->wm.vert_pixels = sprite_width;
 +	intel_plane->wm.bytes_per_pixel = pixel_size;
++=======
+ 	mutex_lock(&dev_priv->wm.wm_mutex);
+ 	intel_crtc->wm.active.ilk = cstate->wm.ilk.intermediate;
+ 	ilk_program_watermarks(dev_priv);
+ 	mutex_unlock(&dev_priv->wm.wm_mutex);
+ }
++>>>>>>> e8f1f02e7125 (drm/i915: Reorganize WM structs/unions in CRTC state)
  
 -static void ilk_optimize_watermarks(struct intel_crtc_state *cstate)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(cstate->base.crtc->dev);
 -	struct intel_crtc *intel_crtc = to_intel_crtc(cstate->base.crtc);
 +	/*
 +	 * IVB workaround: must disable low power watermarks for at least
 +	 * one frame before enabling scaling.  LP watermarks can be re-enabled
 +	 * when scaling is disabled.
 +	 *
 +	 * WaCxSRDisabledForSpriteScaling:ivb
 +	 */
 +	if (IS_IVYBRIDGE(dev) && scaled && ilk_disable_lp_wm(dev))
 +		intel_wait_for_vblank(dev, intel_plane->pipe);
  
++<<<<<<< HEAD
 +	ilk_update_wm(crtc);
++=======
+ 	mutex_lock(&dev_priv->wm.wm_mutex);
+ 	if (cstate->wm.need_postvbl_update) {
+ 		intel_crtc->wm.active.ilk = cstate->wm.ilk.optimal;
+ 		ilk_program_watermarks(dev_priv);
+ 	}
+ 	mutex_unlock(&dev_priv->wm.wm_mutex);
++>>>>>>> e8f1f02e7125 (drm/i915: Reorganize WM structs/unions in CRTC state)
  }
  
  static void skl_pipe_wm_active_state(uint32_t val,
@@@ -3499,7 -3825,8 +3648,12 @@@ static void skl_pipe_wm_get_hw_state(st
  	struct drm_i915_private *dev_priv = dev->dev_private;
  	struct skl_wm_values *hw = &dev_priv->wm.skl_hw;
  	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
++<<<<<<< HEAD
 +	struct skl_pipe_wm *active = &intel_crtc->wm.skl_active;
++=======
+ 	struct intel_crtc_state *cstate = to_intel_crtc_state(crtc->state);
+ 	struct skl_pipe_wm *active = &cstate->wm.skl.optimal;
++>>>>>>> e8f1f02e7125 (drm/i915: Reorganize WM structs/unions in CRTC state)
  	enum pipe pipe = intel_crtc->pipe;
  	int level, i, max_level;
  	uint32_t temp;
@@@ -3562,9 -3891,10 +3716,14 @@@ static void ilk_pipe_wm_get_hw_state(st
  	struct drm_i915_private *dev_priv = dev->dev_private;
  	struct ilk_wm_values *hw = &dev_priv->wm.hw;
  	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
++<<<<<<< HEAD
 +	struct intel_pipe_wm *active = &intel_crtc->wm.active;
++=======
+ 	struct intel_crtc_state *cstate = to_intel_crtc_state(crtc->state);
+ 	struct intel_pipe_wm *active = &cstate->wm.ilk.optimal;
++>>>>>>> e8f1f02e7125 (drm/i915: Reorganize WM structs/unions in CRTC state)
  	enum pipe pipe = intel_crtc->pipe;
 -	static const i915_reg_t wm0_pipe_reg[] = {
 +	static const unsigned int wm0_pipe_reg[] = {
  		[PIPE_A] = WM0_PIPEA_ILK,
  		[PIPE_B] = WM0_PIPEB_ILK,
  		[PIPE_C] = WM0_PIPEC_IVB,
* Unmerged path drivers/gpu/drm/i915/intel_drv.h
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
