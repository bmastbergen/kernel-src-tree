drm/i915: Respect DP++ adaptor TMDS clock limit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drm] i915: Respect DP++ adaptor TMDS clock limit (Rob Clark) [1348329 1349064]
Rebuild_FUZZ: 95.56%
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit b1ba124d8e95cca48d33502a4a76b1ed09d213ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b1ba124d.failed

Try to detect the max TMDS clock limit for the DP++ adaptor (if any)
and take it into account when checking the port clock.

Note that as with the sink (HDMI vs. DVI) TMDS clock limit we'll ignore
the adaptor TMDS clock limit in the modeset path, in case users are
already "overclocking" their TMDS links. One subtle change here is that
we'll have to respect the adaptor TMDS clock limit when we decide whether
to do 12bpc or 8bpc, otherwise we might end up picking 12bpc and
accidentally driving the TMDS link out of spec even when the user chose
a mode that fits wihting the limits at 8bpc. This means you can't
"overclock" your DP++ dongle at 12bpc anymore, but you can continue to
do so at 8bpc.

Note that for simplicity we'll use the I2C access method for all dual
mode adaptors including type 2. Otherwise we'd have to start mixing
DP AUX and HDMI together. In the future we may need to do that if we
come across any board designs that don't hook up the DDC pins to the
DP++ connectors. Such boards would obviously only work with type 2
dual mode adaptors, and not type 1.

v2: Store adaptor type under indel_hdmi->dp_dual_mode
    Deal with DRM_DP_DUAL_MODE_UNKNOWN
    Pass adaptor type to drm_dp_dual_mode_max_tmds_clock(),
    and use it for type1 adaptors as well

	Cc: stable@vger.kernel.org
	Reported-by: Tore Anderson <tore@fud.no>
Fixes: 7a0baa623446 ("Revert "drm/i915: Disable 12bpc hdmi for now"")
	Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
	Cc: Shashank Sharma <shashank.sharma@intel.com>
	Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1462216105-20881-3-git-send-email-ville.syrjala@linux.intel.com
	Reviewed-by: Shashank Sharma <shashank.sharma@intel.com>
(cherry picked from commit b1ba124d8e95cca48d33502a4a76b1ed09d213ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_drv.h
#	drivers/gpu/drm/i915/intel_hdmi.c
diff --cc drivers/gpu/drm/i915/intel_drv.h
index 640e923ced09,b552a967e2ed..000000000000
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@@ -570,9 -752,13 +571,17 @@@ struct cxsr_latency 
  #define intel_fb_obj(x) (x ? to_intel_framebuffer(x)->obj : NULL)
  
  struct intel_hdmi {
 -	i915_reg_t hdmi_reg;
 +	u32 hdmi_reg;
  	int ddc_bus;
++<<<<<<< HEAD
 +	uint32_t color_range;
++=======
+ 	struct {
+ 		enum drm_dp_dual_mode_type type;
+ 		int max_tmds_clock;
+ 	} dp_dual_mode;
+ 	bool limited_color_range;
++>>>>>>> b1ba124d8e95 (drm/i915: Respect DP++ adaptor TMDS clock limit)
  	bool color_range_auto;
  	bool has_hdmi_sink;
  	bool has_audio;
diff --cc drivers/gpu/drm/i915/intel_hdmi.c
index bfbe07b6ddce,31ca11134294..000000000000
--- a/drivers/gpu/drm/i915/intel_hdmi.c
+++ b/drivers/gpu/drm/i915/intel_hdmi.c
@@@ -872,65 -1104,119 +872,132 @@@ static void intel_disable_hdmi(struct i
  
  	temp = I915_READ(intel_hdmi->hdmi_reg);
  
 -	temp &= ~(SDVO_ENABLE | SDVO_AUDIO_ENABLE);
 -	I915_WRITE(intel_hdmi->hdmi_reg, temp);
 -	POSTING_READ(intel_hdmi->hdmi_reg);
 +	/* HW workaround for IBX, we need to move the port to transcoder A
 +	 * before disabling it. */
 +	if (HAS_PCH_IBX(dev)) {
 +		struct drm_crtc *crtc = encoder->base.crtc;
 +		int pipe = crtc ? to_intel_crtc(crtc)->pipe : -1;
 +
 +		if (temp & SDVO_PIPE_B_SELECT) {
 +			temp &= ~SDVO_PIPE_B_SELECT;
 +			I915_WRITE(intel_hdmi->hdmi_reg, temp);
 +			POSTING_READ(intel_hdmi->hdmi_reg);
 +
 +			/* Again we need to write this twice. */
 +			I915_WRITE(intel_hdmi->hdmi_reg, temp);
 +			POSTING_READ(intel_hdmi->hdmi_reg);
 +
 +			/* Transcoder selection bits only update
 +			 * effectively on vblank. */
 +			if (crtc)
 +				intel_wait_for_vblank(dev, pipe);
 +			else
 +				msleep(50);
 +		}
 +	}
  
 -	/*
 -	 * HW workaround for IBX, we need to move the port
 -	 * to transcoder A after disabling it to allow the
 -	 * matching DP port to be enabled on transcoder A.
 +	/* HW workaround, need to toggle enable bit off and on for 12bpc, but
 +	 * we do this anyway which shows more stable in testing.
  	 */
 -	if (HAS_PCH_IBX(dev) && crtc->pipe == PIPE_B) {
 -		/*
 -		 * We get CPU/PCH FIFO underruns on the other pipe when
 -		 * doing the workaround. Sweep them under the rug.
 -		 */
 -		intel_set_cpu_fifo_underrun_reporting(dev_priv, PIPE_A, false);
 -		intel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, false);
 -
 -		temp &= ~SDVO_PIPE_B_SELECT;
 -		temp |= SDVO_ENABLE;
 -		/*
 -		 * HW workaround, need to write this twice for issue
 -		 * that may result in first write getting masked.
 -		 */
 -		I915_WRITE(intel_hdmi->hdmi_reg, temp);
 -		POSTING_READ(intel_hdmi->hdmi_reg);
 -		I915_WRITE(intel_hdmi->hdmi_reg, temp);
 +	if (HAS_PCH_SPLIT(dev)) {
 +		I915_WRITE(intel_hdmi->hdmi_reg, temp & ~SDVO_ENABLE);
  		POSTING_READ(intel_hdmi->hdmi_reg);
 +	}
 +
 +	temp &= ~enable_bits;
 +
 +	I915_WRITE(intel_hdmi->hdmi_reg, temp);
 +	POSTING_READ(intel_hdmi->hdmi_reg);
  
 -		temp &= ~SDVO_ENABLE;
 +	/* HW workaround, need to write this twice for issue that may result
 +	 * in first write getting masked.
 +	 */
 +	if (HAS_PCH_SPLIT(dev)) {
  		I915_WRITE(intel_hdmi->hdmi_reg, temp);
  		POSTING_READ(intel_hdmi->hdmi_reg);
 -
 -		intel_wait_for_vblank_if_active(dev_priv->dev, PIPE_A);
 -		intel_set_cpu_fifo_underrun_reporting(dev_priv, PIPE_A, true);
 -		intel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, true);
  	}
 -
 -	intel_hdmi->set_infoframes(&encoder->base, false, NULL);
  }
  
++<<<<<<< HEAD
 +static int hdmi_portclock_limit(struct intel_hdmi *hdmi, bool respect_dvi_limit)
++=======
+ static void g4x_disable_hdmi(struct intel_encoder *encoder)
  {
- 	struct drm_device *dev = intel_hdmi_to_dev(hdmi);
+ 	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);
+ 
+ 	if (crtc->config->has_audio)
+ 		intel_audio_codec_disable(encoder);
+ 
+ 	intel_disable_hdmi(encoder);
+ }
+ 
+ static void pch_disable_hdmi(struct intel_encoder *encoder)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);
+ 
+ 	if (crtc->config->has_audio)
+ 		intel_audio_codec_disable(encoder);
+ }
+ 
+ static void pch_post_disable_hdmi(struct intel_encoder *encoder)
+ {
+ 	intel_disable_hdmi(encoder);
+ }
  
- 	if ((respect_dvi_limit && !hdmi->has_hdmi_sink) || IS_G4X(dev))
+ static int intel_hdmi_source_max_tmds_clock(struct drm_i915_private *dev_priv)
++>>>>>>> b1ba124d8e95 (drm/i915: Respect DP++ adaptor TMDS clock limit)
+ {
+ 	if (IS_G4X(dev_priv))
  		return 165000;
- 	else if (IS_HASWELL(dev) || INTEL_INFO(dev)->gen >= 8)
+ 	else if (IS_HASWELL(dev_priv) || INTEL_INFO(dev_priv)->gen >= 8)
  		return 300000;
  	else
  		return 225000;
  }
  
+ static int hdmi_port_clock_limit(struct intel_hdmi *hdmi,
+ 				 bool respect_downstream_limits)
+ {
+ 	struct drm_device *dev = intel_hdmi_to_dev(hdmi);
+ 	int max_tmds_clock = intel_hdmi_source_max_tmds_clock(to_i915(dev));
+ 
+ 	if (respect_downstream_limits) {
+ 		if (hdmi->dp_dual_mode.max_tmds_clock)
+ 			max_tmds_clock = min(max_tmds_clock,
+ 					     hdmi->dp_dual_mode.max_tmds_clock);
+ 		if (!hdmi->has_hdmi_sink)
+ 			max_tmds_clock = min(max_tmds_clock, 165000);
+ 	}
+ 
+ 	return max_tmds_clock;
+ }
+ 
  static enum drm_mode_status
++<<<<<<< HEAD
++=======
+ hdmi_port_clock_valid(struct intel_hdmi *hdmi,
+ 		      int clock, bool respect_downstream_limits)
+ {
+ 	struct drm_device *dev = intel_hdmi_to_dev(hdmi);
+ 
+ 	if (clock < 25000)
+ 		return MODE_CLOCK_LOW;
+ 	if (clock > hdmi_port_clock_limit(hdmi, respect_downstream_limits))
+ 		return MODE_CLOCK_HIGH;
+ 
+ 	/* BXT DPLL can't generate 223-240 MHz */
+ 	if (IS_BROXTON(dev) && clock > 223333 && clock < 240000)
+ 		return MODE_CLOCK_RANGE;
+ 
+ 	/* CHV DPLL can't generate 216-240 MHz */
+ 	if (IS_CHERRYVIEW(dev) && clock > 216000 && clock < 240000)
+ 		return MODE_CLOCK_RANGE;
+ 
+ 	return MODE_OK;
+ }
+ 
+ static enum drm_mode_status
++>>>>>>> b1ba124d8e95 (drm/i915: Respect DP++ adaptor TMDS clock limit)
  intel_hdmi_mode_valid(struct drm_connector *connector,
  		      struct drm_display_mode *mode)
  {
@@@ -1030,7 -1326,7 +1097,11 @@@ bool intel_hdmi_compute_config(struct i
  	 * within limits.
  	 */
  	if (pipe_config->pipe_bpp > 8*3 && pipe_config->has_hdmi_sink &&
++<<<<<<< HEAD
 +	    clock_12bpc <= portclock_limit &&
++=======
+ 	    hdmi_port_clock_valid(intel_hdmi, clock_12bpc, true) == MODE_OK &&
++>>>>>>> b1ba124d8e95 (drm/i915: Respect DP++ adaptor TMDS clock limit)
  	    hdmi_12bpc_possible(pipe_config)) {
  		DRM_DEBUG_KMS("picking bpc to 12 for HDMI output\n");
  		desired_bpp = 12*3;
@@@ -1068,25 -1375,47 +1142,54 @@@ intel_hdmi_unset_edid(struct drm_connec
  	to_intel_connector(connector)->detect_edid = NULL;
  }
  
+ static void
+ intel_hdmi_dp_dual_mode_detect(struct drm_connector *connector)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(connector->dev);
+ 	struct intel_hdmi *hdmi = intel_attached_hdmi(connector);
+ 	struct i2c_adapter *adapter =
+ 		intel_gmbus_get_adapter(dev_priv, hdmi->ddc_bus);
+ 	enum drm_dp_dual_mode_type type = drm_dp_dual_mode_detect(adapter);
+ 
+ 	if (type == DRM_DP_DUAL_MODE_NONE ||
+ 	    type == DRM_DP_DUAL_MODE_UNKNOWN)
+ 		return;
+ 
+ 	hdmi->dp_dual_mode.type = type;
+ 	hdmi->dp_dual_mode.max_tmds_clock =
+ 		drm_dp_dual_mode_max_tmds_clock(type, adapter);
+ 
+ 	DRM_DEBUG_KMS("DP dual mode adaptor (%s) detected (max TMDS clock: %d kHz)\n",
+ 		      drm_dp_get_dual_mode_type_name(type),
+ 		      hdmi->dp_dual_mode.max_tmds_clock);
+ }
+ 
  static bool
 -intel_hdmi_set_edid(struct drm_connector *connector, bool force)
 +intel_hdmi_set_edid(struct drm_connector *connector)
  {
  	struct drm_i915_private *dev_priv = to_i915(connector->dev);
  	struct intel_hdmi *intel_hdmi = intel_attached_hdmi(connector);
 -	struct edid *edid = NULL;
 +	struct intel_encoder *intel_encoder =
 +		&hdmi_to_dig_port(intel_hdmi)->base;
 +	enum intel_display_power_domain power_domain;
 +	struct edid *edid;
  	bool connected = false;
  
 -	if (force) {
 -		intel_display_power_get(dev_priv, POWER_DOMAIN_GMBUS);
 +	power_domain = intel_display_port_power_domain(intel_encoder);
 +	intel_display_power_get(dev_priv, power_domain);
  
 -		edid = drm_get_edid(connector,
 -				    intel_gmbus_get_adapter(dev_priv,
 -				    intel_hdmi->ddc_bus));
 +	edid = drm_get_edid(connector,
 +			    intel_gmbus_get_adapter(dev_priv,
 +						    intel_hdmi->ddc_bus));
  
++<<<<<<< HEAD
 +	intel_display_power_put(dev_priv, power_domain);
++=======
+ 		intel_hdmi_dp_dual_mode_detect(connector);
+ 
+ 		intel_display_power_put(dev_priv, POWER_DOMAIN_GMBUS);
+ 	}
++>>>>>>> b1ba124d8e95 (drm/i915: Respect DP++ adaptor TMDS clock limit)
  
  	to_intel_connector(connector)->detect_edid = edid;
  	if (edid && edid->input & DRM_EDID_INPUT_DIGITAL) {
* Unmerged path drivers/gpu/drm/i915/intel_drv.h
* Unmerged path drivers/gpu/drm/i915/intel_hdmi.c
