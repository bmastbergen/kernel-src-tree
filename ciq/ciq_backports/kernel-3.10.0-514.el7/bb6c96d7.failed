xprtrdma: Replace global lkey with lkey local to PD

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit bb6c96d72879fe1f674a804eb95b891def4ace61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bb6c96d7.failed

The core API has changed so that devices that do not have a global
DMA lkey automatically create an mr, per-PD, and make that lkey
available. The global DMA lkey interface is going away in favor of
the per-PD DMA lkey.

The per-PD DMA lkey is always available. Convert xprtrdma to use the
device's per-PD DMA lkey for regbufs, no matter which memory
registration scheme is in use.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Cc: linux-nfs <linux-nfs@vger.kernel.org>
	Acked-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit bb6c96d72879fe1f674a804eb95b891def4ace61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/physical_ops.c
#	net/sunrpc/xprtrdma/verbs.c
#	net/sunrpc/xprtrdma/xprt_rdma.h
diff --cc net/sunrpc/xprtrdma/physical_ops.c
index ba518af16787,617b76f22154..000000000000
--- a/net/sunrpc/xprtrdma/physical_ops.c
+++ b/net/sunrpc/xprtrdma/physical_ops.c
@@@ -23,6 -23,21 +23,24 @@@ static in
  physical_op_open(struct rpcrdma_ia *ia, struct rpcrdma_ep *ep,
  		 struct rpcrdma_create_data_internal *cdata)
  {
++<<<<<<< HEAD
++=======
+ 	struct ib_mr *mr;
+ 
+ 	/* Obtain an rkey to use for RPC data payloads.
+ 	 */
+ 	mr = ib_get_dma_mr(ia->ri_pd,
+ 			   IB_ACCESS_LOCAL_WRITE |
+ 			   IB_ACCESS_REMOTE_WRITE |
+ 			   IB_ACCESS_REMOTE_READ);
+ 	if (IS_ERR(mr)) {
+ 		pr_err("%s: ib_get_dma_mr for failed with %lX\n",
+ 		       __func__, PTR_ERR(mr));
+ 		return -ENOMEM;
+ 	}
+ 
+ 	ia->ri_dma_mr = mr;
++>>>>>>> bb6c96d72879 (xprtrdma: Replace global lkey with lkey local to PD)
  	return 0;
  }
  
diff --cc net/sunrpc/xprtrdma/verbs.c
index 1eb8854086d0,eb081ad05e33..000000000000
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@@ -1581,13 -1244,17 +1581,25 @@@ rpcrdma_alloc_regbuf(struct rpcrdma_ia 
  	if (rb == NULL)
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	iov = &rb->rg_iov;
+ 	iov->addr = ib_dma_map_single(ia->ri_device,
+ 				      (void *)rb->rg_base, size,
+ 				      DMA_BIDIRECTIONAL);
+ 	if (ib_dma_mapping_error(ia->ri_device, iov->addr))
+ 		goto out_free;
+ 
+ 	iov->length = size;
+ 	iov->lkey = ia->ri_pd->local_dma_lkey;
++>>>>>>> bb6c96d72879 (xprtrdma: Replace global lkey with lkey local to PD)
  	rb->rg_size = size;
  	rb->rg_owner = NULL;
 +	rc = rpcrdma_register_internal(ia, rb->rg_base, size,
 +				       &rb->rg_mr, &rb->rg_iov);
 +	if (rc)
 +		goto out_free;
 +
  	return rb;
  
  out_free:
diff --cc net/sunrpc/xprtrdma/xprt_rdma.h
index b2d2c86a7023,c09414e6f91b..000000000000
--- a/net/sunrpc/xprtrdma/xprt_rdma.h
+++ b/net/sunrpc/xprtrdma/xprt_rdma.h
@@@ -61,11 -61,10 +61,15 @@@
  struct rpcrdma_ia {
  	const struct rpcrdma_memreg_ops	*ri_ops;
  	rwlock_t		ri_qplock;
 -	struct ib_device	*ri_device;
  	struct rdma_cm_id 	*ri_id;
  	struct ib_pd		*ri_pd;
++<<<<<<< HEAD
 +	struct ib_mr		*ri_bind_mem;
 +	u32			ri_dma_lkey;
 +	int			ri_have_dma_lkey;
++=======
+ 	struct ib_mr		*ri_dma_mr;
++>>>>>>> bb6c96d72879 (xprtrdma: Replace global lkey with lkey local to PD)
  	struct completion	ri_done;
  	int			ri_async_rc;
  	unsigned int		ri_max_frmr_depth;
* Unmerged path net/sunrpc/xprtrdma/physical_ops.c
* Unmerged path net/sunrpc/xprtrdma/verbs.c
* Unmerged path net/sunrpc/xprtrdma/xprt_rdma.h
