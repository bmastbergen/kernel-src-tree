netfilter: nf_tables: kill nft_pktinfo.ops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 6aa187f21ca2d8ade791f01fd8fab908b1f27673
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6aa187f2.failed

- Add nft_pktinfo.pf to replace ops->pf
- Add nft_pktinfo.hook to replace ops->hooknum

This simplifies the code, makes it more readable, and likely reduces
cache line misses.  Maintainability is enhanced as the details of
nft_hook_ops are of no concern to the recpients of nft_pktinfo.

	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 6aa187f21ca2d8ade791f01fd8fab908b1f27673)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/netfilter/nf_tables_bridge.c
#	net/ipv4/netfilter/nft_dup_ipv4.c
#	net/ipv4/netfilter/nft_masq_ipv4.c
#	net/ipv4/netfilter/nft_redir_ipv4.c
#	net/ipv4/netfilter/nft_reject_ipv4.c
#	net/ipv6/netfilter/nft_dup_ipv6.c
#	net/ipv6/netfilter/nft_redir_ipv6.c
#	net/netfilter/nf_tables_core.c
#	net/netfilter/nf_tables_netdev.c
#	net/netfilter/nft_meta.c
#	net/netfilter/nft_reject_inet.c
diff --cc net/bridge/netfilter/nf_tables_bridge.c
index 41af71fca396,318d825e4207..000000000000
--- a/net/bridge/netfilter/nf_tables_bridge.c
+++ b/net/bridge/netfilter/nf_tables_bridge.c
@@@ -62,6 -64,28 +62,31 @@@ int nft_bridge_ip6hdr_validate(struct s
  }
  EXPORT_SYMBOL_GPL(nft_bridge_ip6hdr_validate);
  
++<<<<<<< HEAD
++=======
+ static inline void nft_bridge_set_pktinfo_ipv4(struct nft_pktinfo *pkt,
+ 					       struct sk_buff *skb,
+ 					       const struct nf_hook_state *state)
+ {
+ 	if (nft_bridge_iphdr_validate(skb))
+ 		nft_set_pktinfo_ipv4(pkt, skb, state);
+ 	else
+ 		nft_set_pktinfo(pkt, skb, state);
+ }
+ 
+ static inline void nft_bridge_set_pktinfo_ipv6(struct nft_pktinfo *pkt,
+ 					       struct sk_buff *skb,
+ 					       const struct nf_hook_state *state)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (nft_bridge_ip6hdr_validate(skb) &&
+ 	    nft_set_pktinfo_ipv6(pkt, skb, state) == 0)
+ 		return;
+ #endif
+ 	nft_set_pktinfo(pkt, skb, state);
+ }
+ 
++>>>>>>> 6aa187f21ca2 (netfilter: nf_tables: kill nft_pktinfo.ops)
  static unsigned int
  nft_do_chain_bridge(const struct nf_hook_ops *ops,
  		    struct sk_buff *skb,
@@@ -71,7 -93,17 +96,21 @@@
  {
  	struct nft_pktinfo pkt;
  
++<<<<<<< HEAD
 +	nft_set_pktinfo(&pkt, ops, skb, state);
++=======
+ 	switch (eth_hdr(skb)->h_proto) {
+ 	case htons(ETH_P_IP):
+ 		nft_bridge_set_pktinfo_ipv4(&pkt, skb, state);
+ 		break;
+ 	case htons(ETH_P_IPV6):
+ 		nft_bridge_set_pktinfo_ipv6(&pkt, skb, state);
+ 		break;
+ 	default:
+ 		nft_set_pktinfo(&pkt, skb, state);
+ 		break;
+ 	}
++>>>>>>> 6aa187f21ca2 (netfilter: nf_tables: kill nft_pktinfo.ops)
  
  	return nft_do_chain(&pkt, ops);
  }
diff --cc net/ipv4/netfilter/nft_masq_ipv4.c
index 665de06561cd,b72ffc58e255..000000000000
--- a/net/ipv4/netfilter/nft_masq_ipv4.c
+++ b/net/ipv4/netfilter/nft_masq_ipv4.c
@@@ -27,10 -26,8 +27,15 @@@ static void nft_masq_ipv4_eval(const st
  	memset(&range, 0, sizeof(range));
  	range.flags = priv->flags;
  
++<<<<<<< HEAD
 +	verdict = nf_nat_masquerade_ipv4(pkt->skb, pkt->ops->hooknum,
 +					 &range, pkt->out);
 +
 +	data[NFT_REG_VERDICT].verdict = verdict;
++=======
+ 	regs->verdict.code = nf_nat_masquerade_ipv4(pkt->skb, pkt->hook,
+ 						    &range, pkt->out);
++>>>>>>> 6aa187f21ca2 (netfilter: nf_tables: kill nft_pktinfo.ops)
  }
  
  static struct nft_expr_type nft_masq_ipv4_type;
diff --cc net/ipv4/netfilter/nft_redir_ipv4.c
index 6ecfce63201a,c09d4381427e..000000000000
--- a/net/ipv4/netfilter/nft_redir_ipv4.c
+++ b/net/ipv4/netfilter/nft_redir_ipv4.c
@@@ -36,8 -35,8 +36,13 @@@ static void nft_redir_ipv4_eval(const s
  
  	mr.range[0].flags |= priv->flags;
  
++<<<<<<< HEAD
 +	verdict = nf_nat_redirect_ipv4(pkt->skb, &mr, pkt->ops->hooknum);
 +	data[NFT_REG_VERDICT].verdict = verdict;
++=======
+ 	regs->verdict.code = nf_nat_redirect_ipv4(pkt->skb, &mr,
+ 						  pkt->hook);
++>>>>>>> 6aa187f21ca2 (netfilter: nf_tables: kill nft_pktinfo.ops)
  }
  
  static struct nft_expr_type nft_redir_ipv4_type;
diff --cc net/ipv4/netfilter/nft_reject_ipv4.c
index 95fe37c72b32,c1582e03b628..000000000000
--- a/net/ipv4/netfilter/nft_reject_ipv4.c
+++ b/net/ipv4/netfilter/nft_reject_ipv4.c
@@@ -27,10 -27,10 +27,14 @@@ void nft_reject_ipv4_eval(const struct 
  
  	switch (priv->type) {
  	case NFT_REJECT_ICMP_UNREACH:
++<<<<<<< HEAD
 +		nf_send_unreach(pkt->skb, priv->icmp_code);
++=======
+ 		nf_send_unreach(pkt->skb, priv->icmp_code, pkt->hook);
++>>>>>>> 6aa187f21ca2 (netfilter: nf_tables: kill nft_pktinfo.ops)
  		break;
  	case NFT_REJECT_TCP_RST:
- 		nf_send_reset(pkt->skb, pkt->ops->hooknum);
+ 		nf_send_reset(pkt->skb, pkt->hook);
  		break;
  	default:
  		break;
diff --cc net/ipv6/netfilter/nft_redir_ipv6.c
index 11820b6b3613,aca44e89a881..000000000000
--- a/net/ipv6/netfilter/nft_redir_ipv6.c
+++ b/net/ipv6/netfilter/nft_redir_ipv6.c
@@@ -36,8 -35,7 +36,12 @@@ static void nft_redir_ipv6_eval(const s
  
  	range.flags |= priv->flags;
  
++<<<<<<< HEAD
 +	verdict = nf_nat_redirect_ipv6(pkt->skb, &range, pkt->ops->hooknum);
 +	data[NFT_REG_VERDICT].verdict = verdict;
++=======
+ 	regs->verdict.code = nf_nat_redirect_ipv6(pkt->skb, &range, pkt->hook);
++>>>>>>> 6aa187f21ca2 (netfilter: nf_tables: kill nft_pktinfo.ops)
  }
  
  static struct nft_expr_type nft_redir_ipv6_type;
diff --cc net/netfilter/nf_tables_core.c
index ff886b43c625,539083099c0d..000000000000
--- a/net/netfilter/nf_tables_core.c
+++ b/net/netfilter/nf_tables_core.c
@@@ -49,10 -50,10 +49,17 @@@ static void __nft_trace_packet(const st
  {
  	struct net *net = dev_net(pkt->in ? pkt->in : pkt->out);
  
++<<<<<<< HEAD
 +	nf_log_packet(net, pkt->xt.family, pkt->ops->hooknum, pkt->skb, pkt->in,
 +		      pkt->out, &trace_loginfo, "TRACE: %s:%s:%s:%u ",
 +		      chain->table->name, chain->name, comments[type],
 +		      rulenum);
++=======
+ 	nf_log_trace(net, pkt->pf, pkt->hook, pkt->skb, pkt->in,
+ 		     pkt->out, &trace_loginfo, "TRACE: %s:%s:%s:%u ",
+ 		     chain->table->name, chain->name, comments[type],
+ 		     rulenum);
++>>>>>>> 6aa187f21ca2 (netfilter: nf_tables: kill nft_pktinfo.ops)
  }
  
  static inline void nft_trace_packet(const struct nft_pktinfo *pkt,
diff --cc net/netfilter/nft_meta.c
index a4cdc254de57,e4ad2c24bc41..000000000000
--- a/net/netfilter/nft_meta.c
+++ b/net/netfilter/nft_meta.c
@@@ -35,22 -35,23 +35,26 @@@ void nft_meta_get_eval(const struct nft
  
  	switch (priv->key) {
  	case NFT_META_LEN:
 -		*dest = skb->len;
 +		dest->data[0] = skb->len;
  		break;
  	case NFT_META_PROTOCOL:
 -		*dest = 0;
 -		*(__be16 *)dest = skb->protocol;
 +		*(__be16 *)dest->data = skb->protocol;
  		break;
  	case NFT_META_NFPROTO:
++<<<<<<< HEAD
 +		dest->data[0] = pkt->ops->pf;
++=======
+ 		*dest = pkt->pf;
++>>>>>>> 6aa187f21ca2 (netfilter: nf_tables: kill nft_pktinfo.ops)
  		break;
  	case NFT_META_L4PROTO:
 -		*dest = pkt->tprot;
 +		dest->data[0] = pkt->tprot;
  		break;
  	case NFT_META_PRIORITY:
 -		*dest = skb->priority;
 +		dest->data[0] = skb->priority;
  		break;
  	case NFT_META_MARK:
 -		*dest = skb->mark;
 +		dest->data[0] = skb->mark;
  		break;
  	case NFT_META_IIF:
  		if (in == NULL)
@@@ -134,12 -135,12 +138,12 @@@
  			break;
  		}
  
- 		switch (pkt->ops->pf) {
+ 		switch (pkt->pf) {
  		case NFPROTO_IPV4:
  			if (ipv4_is_multicast(ip_hdr(skb)->daddr))
 -				*dest = PACKET_MULTICAST;
 +				dest->data[0] = PACKET_MULTICAST;
  			else
 -				*dest = PACKET_BROADCAST;
 +				dest->data[0] = PACKET_BROADCAST;
  			break;
  		case NFPROTO_IPV6:
  			if (ipv6_hdr(skb)->daddr.s6_addr[0] == 0xFF)
diff --cc net/netfilter/nft_reject_inet.c
index 1fb065a77474,dea6750af6ff..000000000000
--- a/net/netfilter/nft_reject_inet.c
+++ b/net/netfilter/nft_reject_inet.c
@@@ -28,14 -28,16 +28,24 @@@ static void nft_reject_inet_eval(const 
  	case NFPROTO_IPV4:
  		switch (priv->type) {
  		case NFT_REJECT_ICMP_UNREACH:
++<<<<<<< HEAD
 +			nf_send_unreach(pkt->skb, priv->icmp_code);
++=======
+ 			nf_send_unreach(pkt->skb, priv->icmp_code,
+ 					pkt->hook);
++>>>>>>> 6aa187f21ca2 (netfilter: nf_tables: kill nft_pktinfo.ops)
  			break;
  		case NFT_REJECT_TCP_RST:
- 			nf_send_reset(pkt->skb, pkt->ops->hooknum);
+ 			nf_send_reset(pkt->skb, pkt->hook);
  			break;
  		case NFT_REJECT_ICMPX_UNREACH:
  			nf_send_unreach(pkt->skb,
++<<<<<<< HEAD
 +					nft_reject_icmp_code(priv->icmp_code));
++=======
+ 					nft_reject_icmp_code(priv->icmp_code),
+ 					pkt->hook);
++>>>>>>> 6aa187f21ca2 (netfilter: nf_tables: kill nft_pktinfo.ops)
  			break;
  		}
  		break;
* Unmerged path net/ipv4/netfilter/nft_dup_ipv4.c
* Unmerged path net/ipv6/netfilter/nft_dup_ipv6.c
* Unmerged path net/netfilter/nf_tables_netdev.c
diff --git a/include/net/netfilter/nf_tables.h b/include/net/netfilter/nf_tables.h
index 1975a40d5905..21280e042faf 100644
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -16,7 +16,8 @@ struct nft_pktinfo {
 	struct sk_buff			*skb;
 	const struct net_device		*in;
 	const struct net_device		*out;
-	const struct nf_hook_ops	*ops;
+	u8				pf;
+	u8				hook;
 	u8				nhoff;
 	u8				thoff;
 	u8				tprot;
@@ -25,16 +26,14 @@ struct nft_pktinfo {
 };
 
 static inline void nft_set_pktinfo(struct nft_pktinfo *pkt,
-				   const struct nf_hook_ops *ops,
 				   struct sk_buff *skb,
 				   const struct nf_hook_state *state)
 {
 	pkt->skb = skb;
 	pkt->in = pkt->xt.in = state->in;
 	pkt->out = pkt->xt.out = state->out;
-	pkt->ops = ops;
-	pkt->xt.hooknum = ops->hooknum;
-	pkt->xt.family = ops->pf;
+	pkt->hook = pkt->xt.hooknum = state->hook;
+	pkt->pf = pkt->xt.family = state->pf;
 }
 
 struct nft_data {
diff --git a/include/net/netfilter/nf_tables_ipv4.h b/include/net/netfilter/nf_tables_ipv4.h
index 2df7f96902ee..ca6ef6bf775e 100644
--- a/include/net/netfilter/nf_tables_ipv4.h
+++ b/include/net/netfilter/nf_tables_ipv4.h
@@ -6,13 +6,12 @@
 
 static inline void
 nft_set_pktinfo_ipv4(struct nft_pktinfo *pkt,
-		     const struct nf_hook_ops *ops,
 		     struct sk_buff *skb,
 		     const struct nf_hook_state *state)
 {
 	struct iphdr *ip;
 
-	nft_set_pktinfo(pkt, ops, skb, state);
+	nft_set_pktinfo(pkt, skb, state);
 
 	ip = ip_hdr(pkt->skb);
 	pkt->tprot = ip->protocol;
diff --git a/include/net/netfilter/nf_tables_ipv6.h b/include/net/netfilter/nf_tables_ipv6.h
index 97db2e3a5e65..8ad39a6a5fe1 100644
--- a/include/net/netfilter/nf_tables_ipv6.h
+++ b/include/net/netfilter/nf_tables_ipv6.h
@@ -6,14 +6,13 @@
 
 static inline int
 nft_set_pktinfo_ipv6(struct nft_pktinfo *pkt,
-		     const struct nf_hook_ops *ops,
 		     struct sk_buff *skb,
 		     const struct nf_hook_state *state)
 {
 	int protohdr, thoff = 0;
 	unsigned short frag_off;
 
-	nft_set_pktinfo(pkt, ops, skb, state);
+	nft_set_pktinfo(pkt, skb, state);
 
 	protohdr = ipv6_find_hdr(pkt->skb, &thoff, -1, &frag_off, NULL);
 	/* If malformed, drop it */
* Unmerged path net/bridge/netfilter/nf_tables_bridge.c
diff --git a/net/bridge/netfilter/nft_reject_bridge.c b/net/bridge/netfilter/nft_reject_bridge.c
index 004c429c7195..9625678853e5 100644
--- a/net/bridge/netfilter/nft_reject_bridge.c
+++ b/net/bridge/netfilter/nft_reject_bridge.c
@@ -272,16 +272,16 @@ static void nft_reject_bridge_eval(const struct nft_expr *expr,
 		switch (priv->type) {
 		case NFT_REJECT_ICMP_UNREACH:
 			nft_reject_br_send_v4_unreach(pkt->skb, pkt->in,
-						      pkt->ops->hooknum,
+						      pkt->hook,
 						      priv->icmp_code);
 			break;
 		case NFT_REJECT_TCP_RST:
 			nft_reject_br_send_v4_tcp_reset(pkt->skb, pkt->in,
-							pkt->ops->hooknum);
+							pkt->hook);
 			break;
 		case NFT_REJECT_ICMPX_UNREACH:
 			nft_reject_br_send_v4_unreach(pkt->skb, pkt->in,
-						      pkt->ops->hooknum,
+						      pkt->hook,
 						      nft_reject_icmp_code(priv->icmp_code));
 			break;
 		}
@@ -290,16 +290,16 @@ static void nft_reject_bridge_eval(const struct nft_expr *expr,
 		switch (priv->type) {
 		case NFT_REJECT_ICMP_UNREACH:
 			nft_reject_br_send_v6_unreach(net, pkt->skb, pkt->in,
-						      pkt->ops->hooknum,
+						      pkt->hook,
 						      priv->icmp_code);
 			break;
 		case NFT_REJECT_TCP_RST:
 			nft_reject_br_send_v6_tcp_reset(net, pkt->skb, pkt->in,
-							pkt->ops->hooknum);
+							pkt->hook);
 			break;
 		case NFT_REJECT_ICMPX_UNREACH:
 			nft_reject_br_send_v6_unreach(net, pkt->skb, pkt->in,
-						      pkt->ops->hooknum,
+						      pkt->hook,
 						      nft_reject_icmpv6_code(priv->icmp_code));
 			break;
 		}
diff --git a/net/ipv4/netfilter/nf_tables_arp.c b/net/ipv4/netfilter/nf_tables_arp.c
index 7d10dc40d9ce..2b4d4954e42f 100644
--- a/net/ipv4/netfilter/nf_tables_arp.c
+++ b/net/ipv4/netfilter/nf_tables_arp.c
@@ -23,7 +23,7 @@ nft_do_chain_arp(const struct nf_hook_ops *ops,
 {
 	struct nft_pktinfo pkt;
 
-	nft_set_pktinfo(&pkt, ops, skb, state);
+	nft_set_pktinfo(&pkt, skb, state);
 
 	return nft_do_chain(&pkt, ops);
 }
diff --git a/net/ipv4/netfilter/nf_tables_ipv4.c b/net/ipv4/netfilter/nf_tables_ipv4.c
index f55f41cc8fe2..b6efcf40e019 100644
--- a/net/ipv4/netfilter/nf_tables_ipv4.c
+++ b/net/ipv4/netfilter/nf_tables_ipv4.c
@@ -26,7 +26,7 @@ static unsigned int nft_do_chain_ipv4(const struct nf_hook_ops *ops,
 {
 	struct nft_pktinfo pkt;
 
-	nft_set_pktinfo_ipv4(&pkt, ops, skb, state);
+	nft_set_pktinfo_ipv4(&pkt, skb, state);
 
 	return nft_do_chain(&pkt, ops);
 }
diff --git a/net/ipv4/netfilter/nft_chain_nat_ipv4.c b/net/ipv4/netfilter/nft_chain_nat_ipv4.c
index b115428d8e94..340dbadd2e3e 100644
--- a/net/ipv4/netfilter/nft_chain_nat_ipv4.c
+++ b/net/ipv4/netfilter/nft_chain_nat_ipv4.c
@@ -33,7 +33,7 @@ static unsigned int nft_nat_do_chain(const struct nf_hook_ops *ops,
 {
 	struct nft_pktinfo pkt;
 
-	nft_set_pktinfo_ipv4(&pkt, ops, skb, state);
+	nft_set_pktinfo_ipv4(&pkt, skb, state);
 
 	return nft_do_chain(&pkt, ops);
 }
diff --git a/net/ipv4/netfilter/nft_chain_route_ipv4.c b/net/ipv4/netfilter/nft_chain_route_ipv4.c
index 19206ea87d91..4017bb2bc08b 100644
--- a/net/ipv4/netfilter/nft_chain_route_ipv4.c
+++ b/net/ipv4/netfilter/nft_chain_route_ipv4.c
@@ -39,7 +39,7 @@ static unsigned int nf_route_table_hook(const struct nf_hook_ops *ops,
 	    ip_hdrlen(skb) < sizeof(struct iphdr))
 		return NF_ACCEPT;
 
-	nft_set_pktinfo_ipv4(&pkt, ops, skb, state);
+	nft_set_pktinfo_ipv4(&pkt, skb, state);
 
 	mark = skb->mark;
 	iph = ip_hdr(skb);
* Unmerged path net/ipv4/netfilter/nft_dup_ipv4.c
* Unmerged path net/ipv4/netfilter/nft_masq_ipv4.c
* Unmerged path net/ipv4/netfilter/nft_redir_ipv4.c
* Unmerged path net/ipv4/netfilter/nft_reject_ipv4.c
diff --git a/net/ipv6/netfilter/nf_tables_ipv6.c b/net/ipv6/netfilter/nf_tables_ipv6.c
index 4ca37bd62a97..53e962a31e79 100644
--- a/net/ipv6/netfilter/nf_tables_ipv6.c
+++ b/net/ipv6/netfilter/nf_tables_ipv6.c
@@ -25,7 +25,7 @@ static unsigned int nft_do_chain_ipv6(const struct nf_hook_ops *ops,
 	struct nft_pktinfo pkt;
 
 	/* malformed packet, drop it */
-	if (nft_set_pktinfo_ipv6(&pkt, ops, skb, state) < 0)
+	if (nft_set_pktinfo_ipv6(&pkt, skb, state) < 0)
 		return NF_DROP;
 
 	return nft_do_chain(&pkt, ops);
diff --git a/net/ipv6/netfilter/nft_chain_nat_ipv6.c b/net/ipv6/netfilter/nft_chain_nat_ipv6.c
index c8762744020c..e28f21e89387 100644
--- a/net/ipv6/netfilter/nft_chain_nat_ipv6.c
+++ b/net/ipv6/netfilter/nft_chain_nat_ipv6.c
@@ -31,7 +31,7 @@ static unsigned int nft_nat_do_chain(const struct nf_hook_ops *ops,
 {
 	struct nft_pktinfo pkt;
 
-	nft_set_pktinfo_ipv6(&pkt, ops, skb, state);
+	nft_set_pktinfo_ipv6(&pkt, skb, state);
 
 	return nft_do_chain(&pkt, ops);
 }
diff --git a/net/ipv6/netfilter/nft_chain_route_ipv6.c b/net/ipv6/netfilter/nft_chain_route_ipv6.c
index ffe36f8cc8ea..e4945e3b3ff7 100644
--- a/net/ipv6/netfilter/nft_chain_route_ipv6.c
+++ b/net/ipv6/netfilter/nft_chain_route_ipv6.c
@@ -35,7 +35,7 @@ static unsigned int nf_route_table_hook(const struct nf_hook_ops *ops,
 	u32 mark, flowlabel;
 
 	/* malformed packet, drop it */
-	if (nft_set_pktinfo_ipv6(&pkt, ops, skb, state) < 0)
+	if (nft_set_pktinfo_ipv6(&pkt, skb, state) < 0)
 		return NF_DROP;
 
 	/* save source/dest address, mark, hoplimit, flowlabel, priority */
* Unmerged path net/ipv6/netfilter/nft_dup_ipv6.c
* Unmerged path net/ipv6/netfilter/nft_redir_ipv6.c
diff --git a/net/ipv6/netfilter/nft_reject_ipv6.c b/net/ipv6/netfilter/nft_reject_ipv6.c
index 367bd4841a0c..9ecc4f252207 100644
--- a/net/ipv6/netfilter/nft_reject_ipv6.c
+++ b/net/ipv6/netfilter/nft_reject_ipv6.c
@@ -28,11 +28,10 @@ void nft_reject_ipv6_eval(const struct nft_expr *expr,
 
 	switch (priv->type) {
 	case NFT_REJECT_ICMP_UNREACH:
-		nf_send_unreach6(net, pkt->skb, priv->icmp_code,
-				 pkt->ops->hooknum);
+		nf_send_unreach6(net, pkt->skb, priv->icmp_code, pkt->hook);
 		break;
 	case NFT_REJECT_TCP_RST:
-		nf_send_reset6(net, pkt->skb, pkt->ops->hooknum);
+		nf_send_reset6(net, pkt->skb, pkt->hook);
 		break;
 	default:
 		break;
* Unmerged path net/netfilter/nf_tables_core.c
* Unmerged path net/netfilter/nf_tables_netdev.c
diff --git a/net/netfilter/nft_log.c b/net/netfilter/nft_log.c
index bde05f28cf14..328490bd65ed 100644
--- a/net/netfilter/nft_log.c
+++ b/net/netfilter/nft_log.c
@@ -33,7 +33,7 @@ static void nft_log_eval(const struct nft_expr *expr,
 	const struct nft_log *priv = nft_expr_priv(expr);
 	struct net *net = dev_net(pkt->in ? pkt->in : pkt->out);
 
-	nf_log_packet(net, pkt->ops->pf, pkt->ops->hooknum, pkt->skb, pkt->in,
+	nf_log_packet(net, pkt->pf, pkt->hook, pkt->skb, pkt->in,
 		      pkt->out, &priv->loginfo, "%s", priv->prefix);
 }
 
* Unmerged path net/netfilter/nft_meta.c
diff --git a/net/netfilter/nft_queue.c b/net/netfilter/nft_queue.c
index e8ae2f6bf232..5e30c61ff238 100644
--- a/net/netfilter/nft_queue.c
+++ b/net/netfilter/nft_queue.c
@@ -42,7 +42,7 @@ static void nft_queue_eval(const struct nft_expr *expr,
 			queue = priv->queuenum + cpu % priv->queues_total;
 		} else {
 			queue = nfqueue_hash(pkt->skb, queue,
-					     priv->queues_total, pkt->ops->pf,
+					     priv->queues_total, pkt->pf,
 					     jhash_initval);
 		}
 	}
* Unmerged path net/netfilter/nft_reject_inet.c
