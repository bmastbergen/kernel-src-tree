mmc: slot-gpio: Allow host driver to provide isr for card-detect interrupts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author NeilBrown <neilb@suse.de>
commit c7ea834d81904b71505093f7ec50d036132cf628
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c7ea834d.failed

One of the reasons omap_hsmmc doesn't use the slot-gpio library
is that it has some non-standard functionality in the card-detect
interrupt service routine.

To make it possible for omap_hsmmc (and maybe others) to be converted
to use slot-gpio, add 'mmc_gpio_request_cd_isr' which provide an
alternate isr to be register by the slot-gpio code.

	Signed-off-by: NeilBrown <neilb@suse.de>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit c7ea834d81904b71505093f7ec50d036132cf628)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/slot-gpio.c
#	include/linux/mmc/slot-gpio.h
diff --cc drivers/mmc/core/slot-gpio.c
index 09ee347e6449,27117ba47073..000000000000
--- a/drivers/mmc/core/slot-gpio.c
+++ b/drivers/mmc/core/slot-gpio.c
@@@ -184,8 -137,10 +185,15 @@@ int mmc_gpio_request_cd(struct mmc_hos
  		irq = -EINVAL;
  
  	if (irq >= 0) {
++<<<<<<< HEAD
 +		ret = devm_request_threaded_irq(&host->class_dev, irq,
 +			NULL, mmc_gpio_cd_irqt,
++=======
+ 		if (!ctx->cd_gpio_isr)
+ 			ctx->cd_gpio_isr = mmc_gpio_cd_irqt;
+ 		ret = devm_request_threaded_irq(host->parent, irq,
+ 			NULL, ctx->cd_gpio_isr,
++>>>>>>> c7ea834d8190 (mmc: slot-gpio: Allow host driver to provide isr for card-detect interrupts)
  			IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
  			ctx->cd_label, host);
  		if (ret < 0)
@@@ -196,6 -151,58 +204,61 @@@
  
  	if (irq < 0)
  		host->caps |= MMC_CAP_NEEDS_POLL;
++<<<<<<< HEAD
++=======
+ }
+ EXPORT_SYMBOL(mmc_gpiod_request_cd_irq);
+ 
+ /* Register an alternate interrupt service routine for
+  * the card-detect GPIO.
+  */
+ void mmc_gpio_set_cd_isr(struct mmc_host *host,
+ 			 irqreturn_t (*isr)(int irq, void *dev_id))
+ {
+ 	struct mmc_gpio *ctx = host->slot.handler_priv;
+ 
+ 	WARN_ON(ctx->cd_gpio_isr);
+ 	ctx->cd_gpio_isr = isr;
+ }
+ EXPORT_SYMBOL(mmc_gpio_set_cd_isr);
+ 
+ /**
+  * mmc_gpio_request_cd - request a gpio for card-detection
+  * @host: mmc host
+  * @gpio: gpio number requested
+  * @debounce: debounce time in microseconds
+  *
+  * As devm_* managed functions are used in mmc_gpio_request_cd(), client
+  * drivers do not need to worry about freeing up memory.
+  *
+  * If GPIO debouncing is desired, set the debounce parameter to a non-zero
+  * value. The caller is responsible for ensuring that the GPIO driver associated
+  * with the GPIO supports debouncing, otherwise an error will be returned.
+  *
+  * Returns zero on success, else an error.
+  */
+ int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio,
+ 			unsigned int debounce)
+ {
+ 	struct mmc_gpio *ctx = host->slot.handler_priv;
+ 	int ret;
+ 
+ 	ret = devm_gpio_request_one(host->parent, gpio, GPIOF_DIR_IN,
+ 				    ctx->cd_label);
+ 	if (ret < 0)
+ 		/*
+ 		 * don't bother freeing memory. It might still get used by other
+ 		 * slot functions, in any case it will be freed, when the device
+ 		 * is destroyed.
+ 		 */
+ 		return ret;
+ 
+ 	if (debounce) {
+ 		ret = gpio_set_debounce(gpio, debounce);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
++>>>>>>> c7ea834d8190 (mmc: slot-gpio: Allow host driver to provide isr for card-detect interrupts)
  
  	ctx->override_cd_active_level = true;
  	ctx->cd_gpio = gpio_to_desc(gpio);
diff --cc include/linux/mmc/slot-gpio.h
index 7d88d27bfafa,3945a8c9d3cb..000000000000
--- a/include/linux/mmc/slot-gpio.h
+++ b/include/linux/mmc/slot-gpio.h
@@@ -15,10 -15,19 +15,25 @@@ struct mmc_host
  
  int mmc_gpio_get_ro(struct mmc_host *host);
  int mmc_gpio_request_ro(struct mmc_host *host, unsigned int gpio);
 +void mmc_gpio_free_ro(struct mmc_host *host);
  
  int mmc_gpio_get_cd(struct mmc_host *host);
++<<<<<<< HEAD
 +int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio);
 +void mmc_gpio_free_cd(struct mmc_host *host);
++=======
+ int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio,
+ 			unsigned int debounce);
+ 
+ int mmc_gpiod_request_cd(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce, bool *gpio_invert);
+ int mmc_gpiod_request_ro(struct mmc_host *host, const char *con_id,
+ 			 unsigned int idx, bool override_active_level,
+ 			 unsigned int debounce, bool *gpio_invert);
+ void mmc_gpio_set_cd_isr(struct mmc_host *host,
+ 			 irqreturn_t (*isr)(int irq, void *dev_id));
+ void mmc_gpiod_request_cd_irq(struct mmc_host *host);
++>>>>>>> c7ea834d8190 (mmc: slot-gpio: Allow host driver to provide isr for card-detect interrupts)
  
  #endif
* Unmerged path drivers/mmc/core/slot-gpio.c
* Unmerged path include/linux/mmc/slot-gpio.h
