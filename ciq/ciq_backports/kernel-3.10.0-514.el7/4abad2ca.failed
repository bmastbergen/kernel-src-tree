mm: new arch_remap() hook

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mm] new arch_remap() hook (Adrian Reber) [1274399]
Rebuild_FUZZ: 91.30%
commit-author Laurent Dufour <ldufour@linux.vnet.ibm.com>
commit 4abad2ca4a4dbdd4a218c12451231ab628f2e60c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4abad2ca.failed

Some architectures would like to be triggered when a memory area is moved
through the mremap system call.

This patch introduces a new arch_remap() mm hook which is placed in the
path of mremap, and is called before the old area is unmapped (and the
arch_unmap() hook is called).

	Signed-off-by: Laurent Dufour <ldufour@linux.vnet.ibm.com>
	Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: Pavel Emelyanov <xemul@parallels.com>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Ingo Molnar <mingo@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 4abad2ca4a4dbdd4a218c12451231ab628f2e60c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mm-arch-hooks.h
#	mm/mremap.c
diff --cc mm/mremap.c
index ee435797a2ae,a7c93eceb1c8..000000000000
--- a/mm/mremap.c
+++ b/mm/mremap.c
@@@ -20,8 -21,9 +20,13 @@@
  #include <linux/syscalls.h>
  #include <linux/mmu_notifier.h>
  #include <linux/sched/sysctl.h>
++<<<<<<< HEAD
++=======
+ #include <linux/uaccess.h>
+ #include <linux/mm-arch-hooks.h>
++>>>>>>> 4abad2ca4a4d (mm: new arch_remap() hook)
  
 +#include <asm/uaccess.h>
  #include <asm/cacheflush.h>
  #include <asm/tlbflush.h>
  
@@@ -268,10 -287,17 +273,24 @@@ static unsigned long move_vma(struct vm
  		old_len = new_len;
  		old_addr = new_addr;
  		new_addr = -ENOMEM;
++<<<<<<< HEAD
 +	} else if (vm_flags & VM_FOP_EXTEND) {
 +		struct file_operations_extend *fop = to_fop_extend(vma->vm_file->f_op);
 +		if (fop->mremap)
 +			fop->mremap(vma->vm_file, new_vma);
++=======
+ 	} else {
+ 		if (vma->vm_file && vma->vm_file->f_op->mremap) {
+ 			err = vma->vm_file->f_op->mremap(vma->vm_file, new_vma);
+ 			if (err < 0) {
+ 				move_page_tables(new_vma, new_addr, vma,
+ 						 old_addr, moved_len, true);
+ 				return err;
+ 			}
+ 		}
+ 		arch_remap(mm, old_addr, old_addr + old_len,
+ 			   new_addr, new_addr + new_len);
++>>>>>>> 4abad2ca4a4d (mm: new arch_remap() hook)
  	}
  
  	/* Conceal VM_ACCOUNT so old reservation is not undone */
* Unmerged path include/linux/mm-arch-hooks.h
* Unmerged path include/linux/mm-arch-hooks.h
* Unmerged path mm/mremap.c
