mmc: sdio_irq: rework sdio irq handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Russell King <rmk+kernel@arm.linux.org.uk>
commit bf3b5ec66bd03d66e9ea729aaca013ea1047a797
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bf3b5ec6.failed

Rather than the SDIO support spawning it's own thread for handling card
interrupts, use the generic IRQ infrastructure for this, triggering it
from the host interface's interrupt handling directly.

This avoids a race between the parent thread waiting to receive an
interrupt response from the card, and the slow startup from the sdio
irq thread, which can occur as a result of high system load (eg, while
udev is running.)

	Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
	Tested-by: Markus Pargmann <mpa@pengutronix.de>
	Tested-by: Stephen Warren <swarren@nvidia.com>
[Ulf Hansson] Resolved conflict
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Chris Ball <chris@printf.net>
(cherry picked from commit bf3b5ec66bd03d66e9ea729aaca013ea1047a797)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mmc/host.h
diff --cc include/linux/mmc/host.h
index 82005d14114c,7960424d0bc0..000000000000
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@@ -279,6 -278,11 +279,14 @@@ struct mmc_host 
  #define MMC_CAP2_PACKED_CMD	(MMC_CAP2_PACKED_RD | \
  				 MMC_CAP2_PACKED_WR)
  #define MMC_CAP2_NO_PRESCAN_POWERUP (1 << 14)	/* Don't power up before scan */
++<<<<<<< HEAD
++=======
+ #define MMC_CAP2_HS400_1_8V	(1 << 15)	/* Can support HS400 1.8V */
+ #define MMC_CAP2_HS400_1_2V	(1 << 16)	/* Can support HS400 1.2V */
+ #define MMC_CAP2_HS400		(MMC_CAP2_HS400_1_8V | \
+ 				 MMC_CAP2_HS400_1_2V)
+ #define MMC_CAP2_SDIO_IRQ_NOTHREAD (1 << 17)
++>>>>>>> bf3b5ec66bd0 (mmc: sdio_irq: rework sdio irq handling)
  
  	mmc_pm_flag_t		pm_caps;	/* supported pm features */
  
diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index aaa90460ed23..5cc13c8d35bb 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -90,6 +90,15 @@ static int process_sdio_pending_irqs(struct mmc_host *host)
 	return ret;
 }
 
+void sdio_run_irqs(struct mmc_host *host)
+{
+	mmc_claim_host(host);
+	host->sdio_irq_pending = true;
+	process_sdio_pending_irqs(host);
+	mmc_release_host(host);
+}
+EXPORT_SYMBOL_GPL(sdio_run_irqs);
+
 static int sdio_irq_thread(void *_host)
 {
 	struct mmc_host *host = _host;
@@ -189,14 +198,20 @@ static int sdio_card_irq_get(struct mmc_card *card)
 	WARN_ON(!host->claimed);
 
 	if (!host->sdio_irqs++) {
-		atomic_set(&host->sdio_irq_thread_abort, 0);
-		host->sdio_irq_thread =
-			kthread_run(sdio_irq_thread, host, "ksdioirqd/%s",
-				mmc_hostname(host));
-		if (IS_ERR(host->sdio_irq_thread)) {
-			int err = PTR_ERR(host->sdio_irq_thread);
-			host->sdio_irqs--;
-			return err;
+		if (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD)) {
+			atomic_set(&host->sdio_irq_thread_abort, 0);
+			host->sdio_irq_thread =
+				kthread_run(sdio_irq_thread, host,
+					    "ksdioirqd/%s", mmc_hostname(host));
+			if (IS_ERR(host->sdio_irq_thread)) {
+				int err = PTR_ERR(host->sdio_irq_thread);
+				host->sdio_irqs--;
+				return err;
+			}
+		} else {
+			mmc_host_clk_hold(host);
+			host->ops->enable_sdio_irq(host, 1);
+			mmc_host_clk_release(host);
 		}
 	}
 
@@ -211,8 +226,14 @@ static int sdio_card_irq_put(struct mmc_card *card)
 	BUG_ON(host->sdio_irqs < 1);
 
 	if (!--host->sdio_irqs) {
-		atomic_set(&host->sdio_irq_thread_abort, 1);
-		kthread_stop(host->sdio_irq_thread);
+		if (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD)) {
+			atomic_set(&host->sdio_irq_thread_abort, 1);
+			kthread_stop(host->sdio_irq_thread);
+		} else {
+			mmc_host_clk_hold(host);
+			host->ops->enable_sdio_irq(host, 0);
+			mmc_host_clk_release(host);
+		}
 	}
 
 	return 0;
* Unmerged path include/linux/mmc/host.h
