crypto: sha - replace memset by memzero_explicit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [crypto] sha - replace memset by memzero_explicit (Herbert Xu) [1267049]
Rebuild_FUZZ: 90.91%
commit-author Julia Lawall <Julia.Lawall@lip6.fr>
commit a6326ba025a4bc025c8c9a15ea2f307936a93843
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a6326ba0.failed

Memset on a local variable may be removed when it is called just before the
variable goes out of scope.  Using memzero_explicit defeats this
optimization.  A simplified version of the semantic patch that makes this
change is as follows: (http://coccinelle.lip6.fr/)

// <smpl>
@@
identifier x;
type T;
@@

{
... when any
T x[...];
... when any
    when exists
- memset
+ memzero_explicit
  (x,
-0,
  ...)
... when != x
    when strict
}
// </smpl>

This change was suggested by Daniel Borkmann <dborkman@redhat.com>

	Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit a6326ba025a4bc025c8c9a15ea2f307936a93843)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/crypto/sha256_ssse3_glue.c
#	arch/x86/crypto/sha512_ssse3_glue.c
diff --cc arch/x86/crypto/sha256_ssse3_glue.c
index 38d835b71fbb,8fad72f4dfd2..000000000000
--- a/arch/x86/crypto/sha256_ssse3_glue.c
+++ b/arch/x86/crypto/sha256_ssse3_glue.c
@@@ -187,7 -187,36 +187,40 @@@ static int sha256_ssse3_import(struct s
  	return 0;
  }
  
++<<<<<<< HEAD
 +static struct shash_alg alg = {
++=======
+ static int sha224_ssse3_init(struct shash_desc *desc)
+ {
+ 	struct sha256_state *sctx = shash_desc_ctx(desc);
+ 
+ 	sctx->state[0] = SHA224_H0;
+ 	sctx->state[1] = SHA224_H1;
+ 	sctx->state[2] = SHA224_H2;
+ 	sctx->state[3] = SHA224_H3;
+ 	sctx->state[4] = SHA224_H4;
+ 	sctx->state[5] = SHA224_H5;
+ 	sctx->state[6] = SHA224_H6;
+ 	sctx->state[7] = SHA224_H7;
+ 	sctx->count = 0;
+ 
+ 	return 0;
+ }
+ 
+ static int sha224_ssse3_final(struct shash_desc *desc, u8 *hash)
+ {
+ 	u8 D[SHA256_DIGEST_SIZE];
+ 
+ 	sha256_ssse3_final(desc, D);
+ 
+ 	memcpy(hash, D, SHA224_DIGEST_SIZE);
+ 	memzero_explicit(D, SHA256_DIGEST_SIZE);
+ 
+ 	return 0;
+ }
+ 
+ static struct shash_alg algs[] = { {
++>>>>>>> a6326ba025a4 (crypto: sha - replace memset by memzero_explicit)
  	.digestsize	=	SHA256_DIGEST_SIZE,
  	.init		=	sha256_ssse3_init,
  	.update		=	sha256_ssse3_update,
diff --cc arch/x86/crypto/sha512_ssse3_glue.c
index d1ee9f638d1c,0b6af26832bf..000000000000
--- a/arch/x86/crypto/sha512_ssse3_glue.c
+++ b/arch/x86/crypto/sha512_ssse3_glue.c
@@@ -194,7 -194,37 +194,41 @@@ static int sha512_ssse3_import(struct s
  	return 0;
  }
  
++<<<<<<< HEAD
 +static struct shash_alg alg = {
++=======
+ static int sha384_ssse3_init(struct shash_desc *desc)
+ {
+ 	struct sha512_state *sctx = shash_desc_ctx(desc);
+ 
+ 	sctx->state[0] = SHA384_H0;
+ 	sctx->state[1] = SHA384_H1;
+ 	sctx->state[2] = SHA384_H2;
+ 	sctx->state[3] = SHA384_H3;
+ 	sctx->state[4] = SHA384_H4;
+ 	sctx->state[5] = SHA384_H5;
+ 	sctx->state[6] = SHA384_H6;
+ 	sctx->state[7] = SHA384_H7;
+ 
+ 	sctx->count[0] = sctx->count[1] = 0;
+ 
+ 	return 0;
+ }
+ 
+ static int sha384_ssse3_final(struct shash_desc *desc, u8 *hash)
+ {
+ 	u8 D[SHA512_DIGEST_SIZE];
+ 
+ 	sha512_ssse3_final(desc, D);
+ 
+ 	memcpy(hash, D, SHA384_DIGEST_SIZE);
+ 	memzero_explicit(D, SHA512_DIGEST_SIZE);
+ 
+ 	return 0;
+ }
+ 
+ static struct shash_alg algs[] = { {
++>>>>>>> a6326ba025a4 (crypto: sha - replace memset by memzero_explicit)
  	.digestsize	=	SHA512_DIGEST_SIZE,
  	.init		=	sha512_ssse3_init,
  	.update		=	sha512_ssse3_update,
* Unmerged path arch/x86/crypto/sha256_ssse3_glue.c
* Unmerged path arch/x86/crypto/sha512_ssse3_glue.c
