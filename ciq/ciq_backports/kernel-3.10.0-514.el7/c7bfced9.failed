md: suspend i/o during runtime blk_integrity_unregister

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [md] suspend i/o during runtime blk_integrity_unregister (Jes Sorensen) [1250578 1265947 1273343 1299140 1307091 1312828 1320563 1340839]
Rebuild_FUZZ: 96.23%
commit-author Dan Williams <dan.j.williams@intel.com>
commit c7bfced9a6716ff66c9d61f934bb60af08d4688c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c7bfced9.failed

Synchronize pending i/o against a change in the integrity profile to
avoid the possibility of spurious integrity errors.  Given linear_add()
is suspending the mddev before manipulating the mddev, do the same for
the other personalities.

	Acked-by: NeilBrown <neilb@suse.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit c7bfced9a6716ff66c9d61f934bb60af08d4688c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid1.c
#	drivers/md/raid10.c
diff --cc drivers/md/raid1.c
index 52d460453f3d,a881b111fa35..000000000000
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@@ -1647,20 -1621,9 +1647,25 @@@ static int raid1_add_disk(struct mddev 
  			break;
  		}
  	}
++<<<<<<< HEAD
 +	if (err == 0 && test_bit(Unmerged, &rdev->flags)) {
 +		/* Some requests might not have seen this new
 +		 * merge_bvec_fn.  We must wait for them to complete
 +		 * before merging the device fully.
 +		 * First we make sure any code which has tested
 +		 * our function has submitted the request, then
 +		 * we wait for all outstanding requests to complete.
 +		 */
 +		synchronize_sched();
 +		freeze_array(conf, 0);
 +		unfreeze_array(conf);
 +		clear_bit(Unmerged, &rdev->flags);
 +	}
++=======
+ 	mddev_suspend(mddev);
++>>>>>>> c7bfced9a671 (md: suspend i/o during runtime blk_integrity_unregister)
  	md_integrity_add_rdev(rdev, mddev);
+ 	mddev_resume(mddev);
  	if (mddev->queue && blk_queue_discard(bdev_get_queue(rdev->bdev)))
  		queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, mddev->queue);
  	print_conf(conf);
diff --cc drivers/md/raid10.c
index 672c6733cc95,6f0ec107996a..000000000000
--- a/drivers/md/raid10.c
+++ b/drivers/md/raid10.c
@@@ -1849,20 -1736,9 +1849,25 @@@ static int raid10_add_disk(struct mdde
  		rcu_assign_pointer(p->rdev, rdev);
  		break;
  	}
++<<<<<<< HEAD
 +	if (err == 0 && test_bit(Unmerged, &rdev->flags)) {
 +		/* Some requests might not have seen this new
 +		 * merge_bvec_fn.  We must wait for them to complete
 +		 * before merging the device fully.
 +		 * First we make sure any code which has tested
 +		 * our function has submitted the request, then
 +		 * we wait for all outstanding requests to complete.
 +		 */
 +		synchronize_sched();
 +		freeze_array(conf, 0);
 +		unfreeze_array(conf);
 +		clear_bit(Unmerged, &rdev->flags);
 +	}
++=======
+ 	mddev_suspend(mddev);
++>>>>>>> c7bfced9a671 (md: suspend i/o during runtime blk_integrity_unregister)
  	md_integrity_add_rdev(rdev, mddev);
+ 	mddev_resume(mddev);
  	if (mddev->queue && blk_queue_discard(bdev_get_queue(rdev->bdev)))
  		queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, mddev->queue);
  
diff --git a/drivers/md/md.c b/drivers/md/md.c
index 6e3ac85f2952..936b673848a8 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -2015,6 +2015,7 @@ void md_integrity_add_rdev(struct md_rdev *rdev, struct mddev *mddev)
 	if (bi_rdev && blk_integrity_compare(mddev->gendisk,
 					     rdev->bdev->bd_disk) >= 0)
 		return;
+	WARN_ON_ONCE(!mddev->suspended);
 	printk(KERN_NOTICE "disabling data integrity on %s\n", mdname(mddev));
 	blk_integrity_unregister(mddev->gendisk);
 }
diff --git a/drivers/md/multipath.c b/drivers/md/multipath.c
index f3a25e1ac3ee..d739bcd54f73 100644
--- a/drivers/md/multipath.c
+++ b/drivers/md/multipath.c
@@ -276,7 +276,9 @@ static int multipath_add_disk(struct mddev *mddev, struct md_rdev *rdev)
 			spin_unlock_irq(&conf->device_lock);
 			rcu_assign_pointer(p->rdev, rdev);
 			err = 0;
+			mddev_suspend(mddev);
 			md_integrity_add_rdev(rdev, mddev);
+			mddev_resume(mddev);
 			break;
 		}
 
* Unmerged path drivers/md/raid1.c
* Unmerged path drivers/md/raid10.c
