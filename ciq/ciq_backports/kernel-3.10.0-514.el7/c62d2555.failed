mm, fs: introduce mapping_gfp_constraint()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mm] introduce mapping_gfp_constraint() (Rob Clark) [1072036 1115530 1202702 1211398 1272159 1310228 1310229 1310230 1310231]
Rebuild_FUZZ: 89.47%
commit-author Michal Hocko <mhocko@suse.com>
commit c62d25556be6c965dc14288e796a576e8e39a7e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c62d2555.failed

There are many places which use mapping_gfp_mask to restrict a more
generic gfp mask which would be used for allocations which are not
directly related to the page cache but they are performed in the same
context.

Let's introduce a helper function which makes the restriction explicit and
easier to track.  This patch doesn't introduce any functional changes.

[akpm@linux-foundation.org: coding-style fixes]
	Signed-off-by: Michal Hocko <mhocko@suse.com>
	Suggested-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit c62d25556be6c965dc14288e796a576e8e39a7e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_gem.c
#	fs/buffer.c
#	fs/cifs/file.c
#	fs/ext4/readpage.c
#	fs/mpage.c
#	fs/nilfs2/inode.c
#	fs/ntfs/file.c
#	fs/splice.c
#	mm/filemap.c
#	mm/readahead.c
diff --cc drivers/gpu/drm/i915/i915_gem.c
index 596bce56e379,399aab265db3..000000000000
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@@ -2067,9 -2214,8 +2067,14 @@@ i915_gem_object_get_pages_gtt(struct dr
  	 * Fail silently without starting the shrinker
  	 */
  	mapping = file_inode(obj->base.filp)->i_mapping;
++<<<<<<< HEAD
 +	gfp = mapping_gfp_mask(mapping);
 +	gfp |= __GFP_NORETRY | __GFP_NOWARN | __GFP_NO_KSWAPD;
 +	gfp &= ~(__GFP_IO | __GFP_WAIT);
++=======
+ 	gfp = mapping_gfp_constraint(mapping, ~(__GFP_IO | __GFP_RECLAIM));
+ 	gfp |= __GFP_NORETRY | __GFP_NOWARN;
++>>>>>>> c62d25556be6 (mm, fs: introduce mapping_gfp_constraint())
  	sg = st->sgl;
  	st->nents = 0;
  	for (i = 0; i < page_count; i++) {
diff --cc fs/buffer.c
index 58d670e9b7cf,51aff0296ce2..000000000000
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@@ -989,8 -999,8 +989,13 @@@ grow_dev_page(struct block_device *bdev
  	int ret = 0;		/* Will call free_more_memory() */
  	gfp_t gfp_mask;
  
++<<<<<<< HEAD
 +	gfp_mask = mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS;
 +	gfp_mask |= __GFP_MOVABLE;
++=======
+ 	gfp_mask = mapping_gfp_constraint(inode->i_mapping, ~__GFP_FS) | gfp;
+ 
++>>>>>>> c62d25556be6 (mm, fs: introduce mapping_gfp_constraint())
  	/*
  	 * XXX: __getblk_slow() can not really deal with failure and
  	 * will endlessly loop on improvised global reclaim.  Prefer
diff --cc fs/cifs/file.c
index d8c52b4862c1,0068e82217c3..000000000000
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@@ -3426,6 -3380,7 +3426,10 @@@ readpages_get_pages(struct address_spac
  	struct page *page, *tpage;
  	unsigned int expected_index;
  	int rc;
++<<<<<<< HEAD
++=======
+ 	gfp_t gfp = mapping_gfp_constraint(mapping, GFP_KERNEL);
++>>>>>>> c62d25556be6 (mm, fs: introduce mapping_gfp_constraint())
  
  	INIT_LIST_HEAD(tmplist);
  
diff --cc fs/mpage.c
index 0face1c4d4c6,1480d3a18037..000000000000
--- a/fs/mpage.c
+++ b/fs/mpage.c
@@@ -371,6 -361,7 +371,10 @@@ mpage_readpages(struct address_space *m
  	sector_t last_block_in_bio = 0;
  	struct buffer_head map_bh;
  	unsigned long first_logical_block = 0;
++<<<<<<< HEAD
++=======
+ 	gfp_t gfp = mapping_gfp_constraint(mapping, GFP_KERNEL);
++>>>>>>> c62d25556be6 (mm, fs: introduce mapping_gfp_constraint())
  
  	map_bh.b_state = 0;
  	map_bh.b_size = 0;
@@@ -405,6 -397,7 +409,10 @@@ int mpage_readpage(struct page *page, g
  	sector_t last_block_in_bio = 0;
  	struct buffer_head map_bh;
  	unsigned long first_logical_block = 0;
++<<<<<<< HEAD
++=======
+ 	gfp_t gfp = mapping_gfp_constraint(page->mapping, GFP_KERNEL);
++>>>>>>> c62d25556be6 (mm, fs: introduce mapping_gfp_constraint())
  
  	map_bh.b_state = 0;
  	map_bh.b_size = 0;
diff --cc fs/nilfs2/inode.c
index 4fcb0d232962,ac2f64943ff4..000000000000
--- a/fs/nilfs2/inode.c
+++ b/fs/nilfs2/inode.c
@@@ -520,6 -521,8 +520,11 @@@ static int __nilfs_read_inode(struct su
  	brelse(bh);
  	up_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);
  	nilfs_set_inode_flags(inode);
++<<<<<<< HEAD
++=======
+ 	mapping_set_gfp_mask(inode->i_mapping,
+ 			   mapping_gfp_constraint(inode->i_mapping, ~__GFP_FS));
++>>>>>>> c62d25556be6 (mm, fs: introduce mapping_gfp_constraint())
  	return 0;
  
   failed_unmap:
diff --cc fs/ntfs/file.c
index ea4ba9daeb47,9d383e5eff0e..000000000000
--- a/fs/ntfs/file.c
+++ b/fs/ntfs/file.c
@@@ -422,8 -524,9 +422,14 @@@ static inline int __ntfs_grab_cache_pag
  					goto err_out;
  				}
  			}
++<<<<<<< HEAD
 +			err = add_to_page_cache_lru(*cached_page, mapping, index,
 +					GFP_KERNEL);
++=======
+ 			err = add_to_page_cache_lru(*cached_page, mapping,
+ 				   index,
+ 				   mapping_gfp_constraint(mapping, GFP_KERNEL));
++>>>>>>> c62d25556be6 (mm, fs: introduce mapping_gfp_constraint())
  			if (unlikely(err)) {
  				if (err == -EEXIST)
  					continue;
diff --cc fs/splice.c
index 883d55b93ddb,801c21cd77fe..000000000000
--- a/fs/splice.c
+++ b/fs/splice.c
@@@ -364,7 -360,7 +364,11 @@@ __generic_file_splice_read(struct file 
  				break;
  
  			error = add_to_page_cache_lru(page, mapping, index,
++<<<<<<< HEAD
 +						GFP_KERNEL);
++=======
+ 				   mapping_gfp_constraint(mapping, GFP_KERNEL));
++>>>>>>> c62d25556be6 (mm, fs: introduce mapping_gfp_constraint())
  			if (unlikely(error)) {
  				page_cache_release(page);
  				if (error == -EEXIST)
diff --cc mm/filemap.c
index 813fbe54f73b,1bb007624b53..000000000000
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@@ -1782,16 -1718,17 +1782,21 @@@ no_cached_page
  		 */
  		page = page_cache_alloc_cold(mapping);
  		if (!page) {
 -			error = -ENOMEM;
 +			desc->error = -ENOMEM;
  			goto out;
  		}
++<<<<<<< HEAD
 +		error = add_to_page_cache_lru(page, mapping,
 +						index, GFP_KERNEL);
++=======
+ 		error = add_to_page_cache_lru(page, mapping, index,
+ 				mapping_gfp_constraint(mapping, GFP_KERNEL));
++>>>>>>> c62d25556be6 (mm, fs: introduce mapping_gfp_constraint())
  		if (error) {
  			page_cache_release(page);
 -			if (error == -EEXIST) {
 -				error = 0;
 +			if (error == -EEXIST)
  				goto find_page;
 -			}
 +			desc->error = error;
  			goto out;
  		}
  		goto readpage;
@@@ -2004,7 -1823,8 +2009,12 @@@ static int page_cache_read(struct file 
  		if (!page)
  			return -ENOMEM;
  
++<<<<<<< HEAD
 +		ret = add_to_page_cache_lru(page, mapping, offset, GFP_KERNEL);
++=======
+ 		ret = add_to_page_cache_lru(page, mapping, offset,
+ 				mapping_gfp_constraint(mapping, GFP_KERNEL));
++>>>>>>> c62d25556be6 (mm, fs: introduce mapping_gfp_constraint())
  		if (ret == 0)
  			ret = mapping->a_ops->readpage(file, page);
  		else if (ret == -EEXIST)
diff --cc mm/readahead.c
index 6c167419ad04,ba22d7fe0afb..000000000000
--- a/mm/readahead.c
+++ b/mm/readahead.c
@@@ -89,8 -89,8 +89,13 @@@ int read_cache_pages(struct address_spa
  	while (!list_empty(pages)) {
  		page = list_to_page(pages);
  		list_del(&page->lru);
++<<<<<<< HEAD
 +		if (add_to_page_cache_lru(page, mapping,
 +					page->index, GFP_KERNEL)) {
++=======
+ 		if (add_to_page_cache_lru(page, mapping, page->index,
+ 				mapping_gfp_constraint(mapping, GFP_KERNEL))) {
++>>>>>>> c62d25556be6 (mm, fs: introduce mapping_gfp_constraint())
  			read_cache_pages_invalidate_page(mapping, page);
  			continue;
  		}
@@@ -127,8 -127,8 +132,13 @@@ static int read_pages(struct address_sp
  	for (page_idx = 0; page_idx < nr_pages; page_idx++) {
  		struct page *page = list_to_page(pages);
  		list_del(&page->lru);
++<<<<<<< HEAD
 +		if (!add_to_page_cache_lru(page, mapping,
 +					page->index, GFP_KERNEL)) {
++=======
+ 		if (!add_to_page_cache_lru(page, mapping, page->index,
+ 				mapping_gfp_constraint(mapping, GFP_KERNEL))) {
++>>>>>>> c62d25556be6 (mm, fs: introduce mapping_gfp_constraint())
  			mapping->a_ops->readpage(filp, page);
  		}
  		page_cache_release(page);
* Unmerged path fs/ext4/readpage.c
diff --git a/drivers/gpu/drm/drm_gem.c b/drivers/gpu/drm/drm_gem.c
index 16a164770713..af9e23a80ccd 100644
--- a/drivers/gpu/drm/drm_gem.c
+++ b/drivers/gpu/drm/drm_gem.c
@@ -491,7 +491,7 @@ struct page **drm_gem_get_pages(struct drm_gem_object *obj)
 		 * __GFP_DMA32 to be set in mapping_gfp_mask(inode->i_mapping)
 		 * so shmem can relocate pages during swapin if required.
 		 */
-		BUG_ON((mapping_gfp_mask(mapping) & __GFP_DMA32) &&
+		BUG_ON(mapping_gfp_constraint(mapping, __GFP_DMA32) &&
 				(page_to_pfn(p) >= 0x00100000UL));
 	}
 
* Unmerged path drivers/gpu/drm/i915/i915_gem.c
diff --git a/fs/btrfs/compression.c b/fs/btrfs/compression.c
index 1fc638941e9d..c5c0dbe778f5 100644
--- a/fs/btrfs/compression.c
+++ b/fs/btrfs/compression.c
@@ -486,13 +486,12 @@ static noinline int add_ra_bio_pages(struct inode *inode,
 			goto next;
 		}
 
-		page = __page_cache_alloc(mapping_gfp_mask(mapping) &
-								~__GFP_FS);
+		page = __page_cache_alloc(mapping_gfp_constraint(mapping,
+								 ~__GFP_FS));
 		if (!page)
 			break;
 
-		if (add_to_page_cache_lru(page, mapping, pg_index,
-								GFP_NOFS)) {
+		if (add_to_page_cache_lru(page, mapping, pg_index, GFP_NOFS)) {
 			page_cache_release(page);
 			goto next;
 		}
diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h
index ea8016f4553c..a5d2fcd375d5 100644
--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@ -3357,7 +3357,7 @@ static inline bool btrfs_mixed_space_info(struct btrfs_space_info *space_info)
 
 static inline gfp_t btrfs_alloc_write_mask(struct address_space *mapping)
 {
-	return mapping_gfp_mask(mapping) & ~__GFP_FS;
+	return mapping_gfp_constraint(mapping, ~__GFP_FS);
 }
 
 /* extent-tree.c */
diff --git a/fs/btrfs/free-space-cache.c b/fs/btrfs/free-space-cache.c
index d5a09d2aef4f..e7d8799dfd22 100644
--- a/fs/btrfs/free-space-cache.c
+++ b/fs/btrfs/free-space-cache.c
@@ -85,8 +85,8 @@ static struct inode *__lookup_free_space_inode(struct btrfs_root *root,
 	}
 
 	mapping_set_gfp_mask(inode->i_mapping,
-			mapping_gfp_mask(inode->i_mapping) &
-			~(__GFP_FS | __GFP_HIGHMEM));
+			mapping_gfp_constraint(inode->i_mapping,
+			~(__GFP_FS | __GFP_HIGHMEM)));
 
 	return inode;
 }
* Unmerged path fs/buffer.c
diff --git a/fs/ceph/addr.c b/fs/ceph/addr.c
index 31c7d014621d..b9937ff8cbfe 100644
--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@ -1264,8 +1264,8 @@ static int ceph_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 		int ret1;
 		struct address_space *mapping = inode->i_mapping;
 		struct page *page = find_or_create_page(mapping, 0,
-						mapping_gfp_mask(mapping) &
-						~__GFP_FS);
+						mapping_gfp_constraint(mapping,
+						~__GFP_FS));
 		if (!page) {
 			ret = VM_FAULT_OOM;
 			goto out;
@@ -1400,7 +1400,8 @@ void ceph_fill_inline_data(struct inode *inode, struct page *locked_page,
 		if (i_size_read(inode) == 0)
 			return;
 		page = find_or_create_page(mapping, 0,
-					   mapping_gfp_mask(mapping) & ~__GFP_FS);
+					   mapping_gfp_constraint(mapping,
+					   ~__GFP_FS));
 		if (!page)
 			return;
 		if (PageUptodate(page)) {
* Unmerged path fs/cifs/file.c
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 7e00e3fcc247..1aaf14c3d38f 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -3254,7 +3254,7 @@ static int ext4_block_zero_page_range(handle_t *handle,
 	int err = 0;
 
 	page = find_or_create_page(mapping, from >> PAGE_CACHE_SHIFT,
-				   mapping_gfp_mask(mapping) & ~__GFP_FS);
+				   mapping_gfp_constraint(mapping, ~__GFP_FS));
 	if (!page)
 		return -ENOMEM;
 
* Unmerged path fs/ext4/readpage.c
diff --git a/fs/logfs/segment.c b/fs/logfs/segment.c
index 038da0991794..05c01b3bc450 100644
--- a/fs/logfs/segment.c
+++ b/fs/logfs/segment.c
@@ -57,7 +57,7 @@ static struct page *get_mapping_page(struct super_block *sb, pgoff_t index,
 	filler_t *filler = super->s_devops->readpage;
 	struct page *page;
 
-	BUG_ON(mapping_gfp_mask(mapping) & __GFP_FS);
+	BUG_ON(mapping_gfp_constraint(mapping, __GFP_FS));
 	if (use_filler)
 		page = read_cache_page(mapping, index, filler, sb);
 	else {
* Unmerged path fs/mpage.c
diff --git a/fs/namei.c b/fs/namei.c
index aff3e3ec968b..8b1437bbf168 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -4513,7 +4513,7 @@ fail:
 int page_symlink(struct inode *inode, const char *symname, int len)
 {
 	return __page_symlink(inode, symname, len,
-			!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));
+			!mapping_gfp_constraint(inode->i_mapping, __GFP_FS));
 }
 
 const struct inode_operations page_symlink_inode_operations = {
* Unmerged path fs/nilfs2/inode.c
* Unmerged path fs/ntfs/file.c
* Unmerged path fs/splice.c
diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h
index 64c42592c528..960f8152094e 100644
--- a/include/linux/pagemap.h
+++ b/include/linux/pagemap.h
@@ -85,6 +85,13 @@ static inline gfp_t mapping_gfp_mask(struct address_space * mapping)
 	return (__force gfp_t)mapping->flags & __GFP_BITS_MASK;
 }
 
+/* Restricts the given gfp_mask to what the mapping allows. */
+static inline gfp_t mapping_gfp_constraint(struct address_space *mapping,
+		gfp_t gfp_mask)
+{
+	return mapping_gfp_mask(mapping) & gfp_mask;
+}
+
 /*
  * This is non-atomic.  Only to be used before the mapping is activated.
  * Probably needs a barrier...
* Unmerged path mm/filemap.c
* Unmerged path mm/readahead.c
