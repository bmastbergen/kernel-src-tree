ixgbe: Use new methods for PHY access

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mark Rustad <mark.d.rustad@intel.com>
commit d31afc8f5ca11249a3b15dafa5972fc76e4099cf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d31afc8f.failed

Now x550em_a devices will use a new method for PHY access that will
get the firmware token for each access.

	Signed-off-by: Mark Rustad <mark.d.rustad@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit d31afc8f5ca11249a3b15dafa5972fc76e4099cf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
index 87208b133171,ef1dc3b5b4ed..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
@@@ -2375,6 -2495,110 +2375,113 @@@ static void ixgbe_release_swfw_sync_X55
  	ixgbe_release_swfw_sync_X540(hw, mask);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * ixgbe_acquire_swfw_sync_x550em_a - Acquire SWFW semaphore
+  * @hw: pointer to hardware structure
+  * @mask: Mask to specify which semaphore to acquire
+  *
+  * Acquires the SWFW semaphore and get the shared PHY token as needed
+  */
+ static s32 ixgbe_acquire_swfw_sync_x550em_a(struct ixgbe_hw *hw, u32 mask)
+ {
+ 	u32 hmask = mask & ~IXGBE_GSSR_TOKEN_SM;
+ 	int retries = FW_PHY_TOKEN_RETRIES;
+ 	s32 status;
+ 
+ 	while (--retries) {
+ 		status = 0;
+ 		if (hmask)
+ 			status = ixgbe_acquire_swfw_sync_X540(hw, hmask);
+ 		if (status)
+ 			return status;
+ 		if (!(mask & IXGBE_GSSR_TOKEN_SM))
+ 			return 0;
+ 
+ 		status = ixgbe_get_phy_token(hw);
+ 		if (!status)
+ 			return 0;
+ 		if (hmask)
+ 			ixgbe_release_swfw_sync_X540(hw, hmask);
+ 		if (status != IXGBE_ERR_TOKEN_RETRY)
+ 			return status;
+ 		udelay(FW_PHY_TOKEN_DELAY * 1000);
+ 	}
+ 
+ 	return status;
+ }
+ 
+ /**
+  * ixgbe_release_swfw_sync_x550em_a - Release SWFW semaphore
+  * @hw: pointer to hardware structure
+  * @mask: Mask to specify which semaphore to release
+  *
+  * Release the SWFW semaphore and puts the shared PHY token as needed
+  */
+ static void ixgbe_release_swfw_sync_x550em_a(struct ixgbe_hw *hw, u32 mask)
+ {
+ 	u32 hmask = mask & ~IXGBE_GSSR_TOKEN_SM;
+ 
+ 	if (mask & IXGBE_GSSR_TOKEN_SM)
+ 		ixgbe_put_phy_token(hw);
+ 
+ 	if (hmask)
+ 		ixgbe_release_swfw_sync_X540(hw, hmask);
+ }
+ 
+ /**
+  * ixgbe_read_phy_reg_x550a - Reads specified PHY register
+  * @hw: pointer to hardware structure
+  * @reg_addr: 32 bit address of PHY register to read
+  * @phy_data: Pointer to read data from PHY register
+  *
+  * Reads a value from a specified PHY register using the SWFW lock and PHY
+  * Token. The PHY Token is needed since the MDIO is shared between to MAC
+  * instances.
+  */
+ static s32 ixgbe_read_phy_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
+ 				    u32 device_type, u16 *phy_data)
+ {
+ 	u32 mask = hw->phy.phy_semaphore_mask | IXGBE_GSSR_TOKEN_SM;
+ 	s32 status;
+ 
+ 	if (hw->mac.ops.acquire_swfw_sync(hw, mask))
+ 		return IXGBE_ERR_SWFW_SYNC;
+ 
+ 	status = hw->phy.ops.read_reg_mdi(hw, reg_addr, device_type, phy_data);
+ 
+ 	hw->mac.ops.release_swfw_sync(hw, mask);
+ 
+ 	return status;
+ }
+ 
+ /**
+  * ixgbe_write_phy_reg_x550a - Writes specified PHY register
+  * @hw: pointer to hardware structure
+  * @reg_addr: 32 bit PHY register to write
+  * @device_type: 5 bit device type
+  * @phy_data: Data to write to the PHY register
+  *
+  * Writes a value to specified PHY register using the SWFW lock and PHY Token.
+  * The PHY Token is needed since the MDIO is shared between to MAC instances.
+  */
+ static s32 ixgbe_write_phy_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
+ 				     u32 device_type, u16 phy_data)
+ {
+ 	u32 mask = hw->phy.phy_semaphore_mask | IXGBE_GSSR_TOKEN_SM;
+ 	s32 status;
+ 
+ 	if (hw->mac.ops.acquire_swfw_sync(hw, mask))
+ 		return IXGBE_ERR_SWFW_SYNC;
+ 
+ 	status = ixgbe_write_phy_reg_mdi(hw, reg_addr, device_type, phy_data);
+ 	hw->mac.ops.release_swfw_sync(hw, mask);
+ 
+ 	return status;
+ }
+ 
++>>>>>>> d31afc8f5ca1 (ixgbe: Use new methods for PHY access)
  #define X550_COMMON_MAC \
  	.init_hw			= &ixgbe_init_hw_generic, \
  	.start_hw			= &ixgbe_start_hw_X540, \
@@@ -2494,9 -2733,11 +2599,11 @@@ static struct ixgbe_phy_operations phy_
  	X550_COMMON_PHY
  	.init			= NULL,
  	.identify		= &ixgbe_identify_phy_generic,
+ 	.read_reg		= &ixgbe_read_phy_reg_generic,
+ 	.write_reg		= &ixgbe_write_phy_reg_generic,
  };
  
 -static const struct ixgbe_phy_operations phy_ops_X550EM_x = {
 +static struct ixgbe_phy_operations phy_ops_X550EM_x = {
  	X550_COMMON_PHY
  	.init			= &ixgbe_init_phy_ops_X550em,
  	.identify		= &ixgbe_identify_phy_x550em,
@@@ -2534,3 -2789,13 +2651,16 @@@ struct ixgbe_info ixgbe_X550EM_x_info 
  	.mbx_ops		= &mbx_ops_generic,
  	.mvals			= ixgbe_mvals_X550EM_x,
  };
++<<<<<<< HEAD
++=======
+ 
+ const struct ixgbe_info ixgbe_x550em_a_info = {
+ 	.mac			= ixgbe_mac_x550em_a,
+ 	.get_invariants		= &ixgbe_get_invariants_X550_x,
+ 	.mac_ops		= &mac_ops_x550em_a,
+ 	.eeprom_ops		= &eeprom_ops_X550EM_x,
+ 	.phy_ops		= &phy_ops_x550em_a,
+ 	.mbx_ops		= &mbx_ops_generic,
+ 	.mvals			= ixgbe_mvals_x550em_a,
+ };
++>>>>>>> d31afc8f5ca1 (ixgbe: Use new methods for PHY access)
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
