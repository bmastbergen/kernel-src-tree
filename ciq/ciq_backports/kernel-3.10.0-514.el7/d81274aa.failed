Drivers: hv: vmbus: Support handling messages on multiple CPUs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hv] vmbus: Support handling messages on multiple CPUs (Vitaly Kuznetsov) [1321073]
Rebuild_FUZZ: 88.29%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit d81274aae61c0a045cd0f34191c51fa64ba58bc4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d81274aa.failed

Starting with Windows 2012 R2, message inteerupts can be delivered
on any VCPU in the guest. Support this functionality.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit d81274aae61c0a045cd0f34191c51fa64ba58bc4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/hv.c
#	drivers/hv/vmbus_drv.c
diff --cc drivers/hv/hv.c
index ecc62fc8d7b1,a1c086ba3b9a..000000000000
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@@ -199,6 -204,10 +199,13 @@@ int hv_init(void
  	       sizeof(int) * NR_CPUS);
  	memset(hv_context.event_dpc, 0,
  	       sizeof(void *) * NR_CPUS);
++<<<<<<< HEAD
++=======
+ 	memset(hv_context.msg_dpc, 0,
+ 	       sizeof(void *) * NR_CPUS);
+ 	memset(hv_context.clk_evt, 0,
+ 	       sizeof(void *) * NR_CPUS);
++>>>>>>> d81274aae61c (Drivers: hv: vmbus: Support handling messages on multiple CPUs)
  
  	max_leaf = query_hypervisor_info();
  
@@@ -358,6 -417,21 +365,24 @@@ int hv_synic_alloc(void
  		}
  		tasklet_init(hv_context.event_dpc[cpu], vmbus_on_event, cpu);
  
++<<<<<<< HEAD
++=======
+ 		hv_context.msg_dpc[cpu] = kmalloc(size, GFP_ATOMIC);
+ 		if (hv_context.msg_dpc[cpu] == NULL) {
+ 			pr_err("Unable to allocate event dpc\n");
+ 			goto err;
+ 		}
+ 		tasklet_init(hv_context.msg_dpc[cpu], vmbus_on_msg_dpc, cpu);
+ 
+ 		hv_context.clk_evt[cpu] = kzalloc(ced_size, GFP_ATOMIC);
+ 		if (hv_context.clk_evt[cpu] == NULL) {
+ 			pr_err("Unable to allocate clock event device\n");
+ 			goto err;
+ 		}
+ 
+ 		hv_init_clockevent_device(hv_context.clk_evt[cpu], cpu);
+ 
++>>>>>>> d81274aae61c (Drivers: hv: vmbus: Support handling messages on multiple CPUs)
  		hv_context.synic_message_page[cpu] =
  			(void *)get_zeroed_page(GFP_ATOMIC);
  
@@@ -388,9 -462,11 +413,14 @@@ err
  	return -ENOMEM;
  }
  
 -static void hv_synic_free_cpu(int cpu)
 +void hv_synic_free_cpu(int cpu)
  {
  	kfree(hv_context.event_dpc[cpu]);
++<<<<<<< HEAD
++=======
+ 	kfree(hv_context.msg_dpc[cpu]);
+ 	kfree(hv_context.clk_evt[cpu]);
++>>>>>>> d81274aae61c (Drivers: hv: vmbus: Support handling messages on multiple CPUs)
  	if (hv_context.synic_event_page[cpu])
  		free_page((unsigned long)hv_context.synic_event_page[cpu]);
  	if (hv_context.synic_message_page[cpu])
diff --cc drivers/hv/vmbus_drv.c
index 7882a259dbd0,64713ff47e36..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -42,12 -42,10 +42,11 @@@
  #include <linux/kdebug.h>
  #include "hyperv_vmbus.h"
  
 +
  static struct acpi_device  *hv_acpi_dev;
  
- static struct tasklet_struct msg_dpc;
  static struct completion probe_event;
 +static int irq;
  
  
  static void hyperv_report_panic(struct pt_regs *regs)
@@@ -697,7 -701,17 +696,21 @@@ static void vmbus_onmessage_work(struc
  	kfree(ctx);
  }
  
++<<<<<<< HEAD
 +static void vmbus_on_msg_dpc(unsigned long data)
++=======
+ static void hv_process_timer_expiration(struct hv_message *msg, int cpu)
+ {
+ 	struct clock_event_device *dev = hv_context.clk_evt[cpu];
+ 
+ 	if (dev->event_handler)
+ 		dev->event_handler(dev);
+ 
+ 	vmbus_signal_eom(msg);
+ }
+ 
+ void vmbus_on_msg_dpc(unsigned long data)
++>>>>>>> d81274aae61c (Drivers: hv: vmbus: Support handling messages on multiple CPUs)
  {
  	int cpu = smp_processor_id();
  	void *page_addr = hv_context.synic_message_page[cpu];
@@@ -799,42 -795,14 +812,51 @@@ static void vmbus_isr(void
  	msg = (struct hv_message *)page_addr + VMBUS_MESSAGE_SINT;
  
  	/* Check if there are actual msgs to be processed */
++<<<<<<< HEAD
 +	if (msg->header.message_type != HVMSG_NONE)
 +		tasklet_schedule(&msg_dpc);
++=======
+ 	if (msg->header.message_type != HVMSG_NONE) {
+ 		if (msg->header.message_type == HVMSG_TIMER_EXPIRED)
+ 			hv_process_timer_expiration(msg, cpu);
+ 		else
+ 			tasklet_schedule(hv_context.msg_dpc[cpu]);
+ 	}
++>>>>>>> d81274aae61c (Drivers: hv: vmbus: Support handling messages on multiple CPUs)
  }
  
 +#ifdef CONFIG_HOTPLUG_CPU
 +static int hyperv_cpu_disable(void)
 +{
 +	return -ENOSYS;
 +}
 +
 +static void hv_cpu_hotplug_quirk(bool vmbus_loaded)
 +{
 +	static void *previous_cpu_disable;
 +
 +	/*
 +	 * Offlining a CPU when running on newer hypervisors (WS2012R2, Win8,
 +	 * ...) is not supported at this moment as channel interrupts are
 +	 * distributed across all of them.
 +	 */
 +
 +	if ((vmbus_proto_version == VERSION_WS2008) ||
 +	    (vmbus_proto_version == VERSION_WIN7))
 +		return;
 +
 +	if (vmbus_loaded) {
 +		previous_cpu_disable = smp_ops.cpu_disable;
 +		smp_ops.cpu_disable = hyperv_cpu_disable;
 +		pr_notice("CPU offlining is not supported by hypervisor\n");
 +	} else if (previous_cpu_disable)
 +		smp_ops.cpu_disable = previous_cpu_disable;
 +}
 +#else
 +static void hv_cpu_hotplug_quirk(bool vmbus_loaded)
 +{
 +}
 +#endif
  
  /*
   * vmbus_bus_init -Main vmbus driver initialization routine.
@@@ -1175,9 -1315,11 +1195,10 @@@ static void __exit vmbus_exit(void
  	hv_remove_kexec_handler();
  	hv_remove_crash_handler();
  	vmbus_connection.conn_state = DISCONNECTED;
 -	hv_synic_clockevents_cleanup();
  	vmbus_disconnect();
  	hv_remove_vmbus_irq();
- 	tasklet_kill(&msg_dpc);
+ 	for_each_online_cpu(cpu)
+ 		tasklet_kill(hv_context.msg_dpc[cpu]);
  	vmbus_free_channels();
  	if (ms_hyperv.misc_features & HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE) {
  		unregister_die_notifier(&hyperv_die_block);
* Unmerged path drivers/hv/hv.c
diff --git a/drivers/hv/hyperv_vmbus.h b/drivers/hv/hyperv_vmbus.h
index 0420c9441ddc..076b484ffb6a 100644
--- a/drivers/hv/hyperv_vmbus.h
+++ b/drivers/hv/hyperv_vmbus.h
@@ -513,10 +513,11 @@ struct hv_context {
 	u32 vp_index[NR_CPUS];
 	/*
 	 * Starting with win8, we can take channel interrupts on any CPU;
-	 * we will manage the tasklet that handles events on a per CPU
+	 * we will manage the tasklet that handles events messages on a per CPU
 	 * basis.
 	 */
 	struct tasklet_struct *event_dpc[NR_CPUS];
+	struct tasklet_struct *msg_dpc[NR_CPUS];
 	/*
 	 * To optimize the mapping of relid to channel, maintain
 	 * per-cpu list of the channels based on their CPU affinity.
@@ -711,6 +712,7 @@ int vmbus_post_msg(void *buffer, size_t buflen);
 int vmbus_set_event(struct vmbus_channel *channel);
 
 void vmbus_on_event(unsigned long data);
+void vmbus_on_msg_dpc(unsigned long data);
 
 int hv_fcopy_init(struct hv_util_service *);
 void hv_fcopy_deinit(void);
* Unmerged path drivers/hv/vmbus_drv.c
