netfilter: Fix potential crash in nft_hash walker

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit d8bdff59cea141d2e5f7e98c1b11d3e0271640bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d8bdff59.failed

When we get back an EAGAIN from rhashtable_walk_next we were
treating it as a valid object which obviously doesn't work too
well.

Luckily this is hard to trigger so it seems nobody has run into
it yet.

This patch fixes it by redoing the next call when we get an EAGAIN.

	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit d8bdff59cea141d2e5f7e98c1b11d3e0271640bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_hash.c
diff --cc net/netfilter/nft_hash.c
index f14a5e14123a,37c15e674884..000000000000
--- a/net/netfilter/nft_hash.c
+++ b/net/netfilter/nft_hash.c
@@@ -129,32 -129,53 +129,57 @@@ static int nft_hash_get(const struct nf
  static void nft_hash_walk(const struct nft_ctx *ctx, const struct nft_set *set,
  			  struct nft_set_iter *iter)
  {
 -	struct rhashtable *priv = nft_set_priv(set);
 +	const struct rhashtable *priv = nft_set_priv(set);
 +	const struct bucket_table *tbl;
  	const struct nft_hash_elem *he;
 -	struct rhashtable_iter hti;
  	struct nft_set_elem elem;
 -	int err;
 -
 -	err = rhashtable_walk_init(priv, &hti);
 -	iter->err = err;
 -	if (err)
 -		return;
 -
 -	err = rhashtable_walk_start(&hti);
 -	if (err && err != -EAGAIN) {
 -		iter->err = err;
 -		goto out;
 -	}
 +	unsigned int i;
  
 +	tbl = rht_dereference_rcu(priv->tbl, priv);
 +	for (i = 0; i < tbl->size; i++) {
 +		struct rhash_head *pos;
 +
 +		rht_for_each_entry_rcu(he, pos, tbl, i, node) {
 +			if (iter->count < iter->skip)
 +				goto cont;
 +
++<<<<<<< HEAD
 +			memcpy(&elem.key, &he->key, sizeof(elem.key));
 +			if (set->flags & NFT_SET_MAP)
 +				memcpy(&elem.data, he->data, sizeof(elem.data));
 +			elem.flags = 0;
++=======
+ 	while ((he = rhashtable_walk_next(&hti))) {
+ 		if (IS_ERR(he)) {
+ 			err = PTR_ERR(he);
+ 			if (err != -EAGAIN) {
+ 				iter->err = err;
+ 				goto out;
+ 			}
+ 
+ 			continue;
+ 		}
+ 
+ 		if (iter->count < iter->skip)
+ 			goto cont;
+ 
+ 		memcpy(&elem.key, &he->key, sizeof(elem.key));
+ 		if (set->flags & NFT_SET_MAP)
+ 			memcpy(&elem.data, he->data, sizeof(elem.data));
+ 		elem.flags = 0;
+ 
+ 		iter->err = iter->fn(ctx, set, iter, &elem);
+ 		if (iter->err < 0)
+ 			goto out;
++>>>>>>> d8bdff59cea1 (netfilter: Fix potential crash in nft_hash walker)
  
 +			iter->err = iter->fn(ctx, set, iter, &elem);
 +			if (iter->err < 0)
 +				return;
  cont:
 -		iter->count++;
 +			iter->count++;
 +		}
  	}
 -
 -out:
 -	rhashtable_walk_stop(&hti);
 -	rhashtable_walk_exit(&hti);
  }
  
  static unsigned int nft_hash_privsize(const struct nlattr * const nla[])
* Unmerged path net/netfilter/nft_hash.c
