ACPI / property: fix data node parsing in acpi_get_next_subnode()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Irina Tirdea <irina.tirdea@intel.com>
commit bf4703fdd166fffd5b2e4c42d2ebbf708b94748e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bf4703fd.failed

When an ACPI node has both ACPI device nodes and ACPI data nodes,
acpi_get_next_subnode() will return the ACPI data nodes of its last
parsed child.

To avoid that, make acpi_get_next_subnode() go back to the original
ACPI device object when all of the device node children of it have
been found already.

	Signed-off-by: Irina Tirdea <irina.tirdea@intel.com>
[ rjw: Changelog ]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit bf4703fdd166fffd5b2e4c42d2ebbf708b94748e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/property.c
diff --cc drivers/acpi/property.c
index 3d47281953cd,f2fd3fee588a..000000000000
--- a/drivers/acpi/property.c
+++ b/drivers/acpi/property.c
@@@ -541,3 -766,85 +541,88 @@@ int acpi_dev_prop_read(struct acpi_devi
  	}
  	return ret;
  }
++<<<<<<< HEAD
++=======
+ 
+ int acpi_dev_prop_read(struct acpi_device *adev, const char *propname,
+ 		       enum dev_prop_type proptype, void *val, size_t nval)
+ {
+ 	return adev ? acpi_data_prop_read(&adev->data, propname, proptype, val, nval) : -EINVAL;
+ }
+ 
+ /**
+  * acpi_node_prop_read - retrieve the value of an ACPI property with given name.
+  * @fwnode: Firmware node to get the property from.
+  * @propname: Name of the property.
+  * @proptype: Expected property type.
+  * @val: Location to store the property value (if not %NULL).
+  * @nval: Size of the array pointed to by @val.
+  *
+  * If @val is %NULL, return the number of array elements comprising the value
+  * of the property.  Otherwise, read at most @nval values to the array at the
+  * location pointed to by @val.
+  */
+ int acpi_node_prop_read(struct fwnode_handle *fwnode,  const char *propname,
+ 		        enum dev_prop_type proptype, void *val, size_t nval)
+ {
+ 	return acpi_data_prop_read(acpi_device_data_of_node(fwnode),
+ 				   propname, proptype, val, nval);
+ }
+ 
+ /**
+  * acpi_get_next_subnode - Return the next child node handle for a device.
+  * @dev: Device to find the next child node for.
+  * @child: Handle to one of the device's child nodes or a null handle.
+  */
+ struct fwnode_handle *acpi_get_next_subnode(struct device *dev,
+ 					    struct fwnode_handle *child)
+ {
+ 	struct acpi_device *adev = ACPI_COMPANION(dev);
+ 	struct list_head *head, *next;
+ 
+ 	if (!adev)
+ 		return NULL;
+ 
+ 	if (!child || child->type == FWNODE_ACPI) {
+ 		head = &adev->children;
+ 		if (list_empty(head))
+ 			goto nondev;
+ 
+ 		if (child) {
+ 			adev = to_acpi_device_node(child);
+ 			next = adev->node.next;
+ 			if (next == head) {
+ 				child = NULL;
+ 				adev = ACPI_COMPANION(dev);
+ 				goto nondev;
+ 			}
+ 			adev = list_entry(next, struct acpi_device, node);
+ 		} else {
+ 			adev = list_first_entry(head, struct acpi_device, node);
+ 		}
+ 		return acpi_fwnode_handle(adev);
+ 	}
+ 
+  nondev:
+ 	if (!child || child->type == FWNODE_ACPI_DATA) {
+ 		struct acpi_data_node *dn;
+ 
+ 		head = &adev->data.subnodes;
+ 		if (list_empty(head))
+ 			return NULL;
+ 
+ 		if (child) {
+ 			dn = to_acpi_data_node(child);
+ 			next = dn->sibling.next;
+ 			if (next == head)
+ 				return NULL;
+ 
+ 			dn = list_entry(next, struct acpi_data_node, sibling);
+ 		} else {
+ 			dn = list_first_entry(head, struct acpi_data_node, sibling);
+ 		}
+ 		return &dn->fwnode;
+ 	}
+ 	return NULL;
+ }
++>>>>>>> bf4703fdd166 (ACPI / property: fix data node parsing in acpi_get_next_subnode())
* Unmerged path drivers/acpi/property.c
