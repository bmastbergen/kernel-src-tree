slub: create new ___slab_alloc function that can be called with irqs disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Lameter <cl@linux.com>
commit a380a3c75529a5c42b78c0d64a46404f8cb0c0d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a380a3c7.failed

Bulk alloc needs a function like that because it enables interrupts before
calling __slab_alloc which promptly disables them again using the expensive
local_irq_save().

	Signed-off-by: Christoph Lameter <cl@linux.com>
	Cc: Jesper Dangaard Brouer <brouer@redhat.com>
	Cc: Pekka Enberg <penberg@kernel.org>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit a380a3c75529a5c42b78c0d64a46404f8cb0c0d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/slub.c
diff --cc mm/slub.c
index 9bb60eec298f,2a952751bb50..000000000000
--- a/mm/slub.c
+++ b/mm/slub.c
@@@ -2313,10 -2376,7 +2304,14 @@@ new_slab
  	freelist = new_slab_objects(s, gfpflags, node, &c);
  
  	if (unlikely(!freelist)) {
++<<<<<<< HEAD
 +		if (!(gfpflags & __GFP_NOWARN) && printk_ratelimit())
 +			slab_out_of_memory(s, gfpflags, node);
 +
 +		local_irq_restore(flags);
++=======
+ 		slab_out_of_memory(s, gfpflags, node);
++>>>>>>> a380a3c75529 (slub: create new ___slab_alloc function that can be called with irqs disabled)
  		return NULL;
  	}
  
* Unmerged path mm/slub.c
