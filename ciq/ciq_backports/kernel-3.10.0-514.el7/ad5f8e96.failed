IB/mlx5: Expose Raw Packet QP to user space consumers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author majd@mellanox.com <majd@mellanox.com>
commit ad5f8e964cd0a88c746577aab2c6ea26e3b26673
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ad5f8e96.failed

Added Raw Packet QP modify functionality which will enable user
space consumers to use it.

Since Raw Packet QP is built of SQ and RQ sub-objects, therefore
Raw Packet QP state changes are implemented by changing the state
of the sub-objects.

	Signed-off-by: Majd Dibbiny <majd@mellanox.com>
	Reviewed-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit ad5f8e964cd0a88c746577aab2c6ea26e3b26673)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/qp.c
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 607cf202ca0b,8fb9c27485e1..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -1196,11 -1530,18 +1199,26 @@@ static void destroy_qp_common(struct ml
  		return;
  
  	if (qp->state != IB_QPS_RESET) {
++<<<<<<< HEAD
 +		mlx5_ib_qp_disable_pagefaults(qp);
 +		if (mlx5_core_qp_modify(dev->mdev, to_mlx5_state(qp->state),
 +					MLX5_QP_STATE_RST, in, 0, &qp->mqp))
 +			mlx5_ib_warn(dev, "mlx5_ib: modify QP %06x to RESET failed\n",
 +				     qp->mqp.qpn);
++=======
+ 		if (qp->ibqp.qp_type != IB_QPT_RAW_PACKET) {
+ 			mlx5_ib_qp_disable_pagefaults(qp);
+ 			err = mlx5_core_qp_modify(dev->mdev,
+ 						  MLX5_CMD_OP_2RST_QP, in, 0,
+ 						  &base->mqp);
+ 		} else {
+ 			err = modify_raw_packet_qp(dev, qp,
+ 						   MLX5_CMD_OP_2RST_QP);
+ 		}
+ 		if (err)
+ 			mlx5_ib_warn(dev, "mlx5_ib: modify QP 0x%06x to RESET failed\n",
+ 				     base->mqp.qpn);
++>>>>>>> ad5f8e964cd0 (IB/mlx5: Expose Raw Packet QP to user space consumers)
  	}
  
  	get_cqs(qp, &send_cq, &recv_cq);
@@@ -1794,15 -2295,24 +1916,25 @@@ static int __mlx5_ib_modify_qp(struct i
  	 * again to RTS, and may cause the driver and the device to get out of
  	 * sync. */
  	if (cur_state != IB_QPS_RESET && cur_state != IB_QPS_ERR &&
- 	    (new_state == IB_QPS_RESET || new_state == IB_QPS_ERR))
+ 	    (new_state == IB_QPS_RESET || new_state == IB_QPS_ERR) &&
+ 	    (qp->ibqp.qp_type != IB_QPT_RAW_PACKET))
  		mlx5_ib_qp_disable_pagefaults(qp);
  
 -	if (mlx5_cur >= MLX5_QP_NUM_STATE || mlx5_new >= MLX5_QP_NUM_STATE ||
 -	    !optab[mlx5_cur][mlx5_new])
 -		goto out;
 -
 -	op = optab[mlx5_cur][mlx5_new];
  	optpar = ib_mask_to_mlx5_opt(attr_mask);
  	optpar &= opt_mask[mlx5_cur][mlx5_new][mlx5_st];
  	in->optparam = cpu_to_be32(optpar);
++<<<<<<< HEAD
 +	err = mlx5_core_qp_modify(dev->mdev, to_mlx5_state(cur_state),
 +				  to_mlx5_state(new_state), in, sqd_event,
 +				  &qp->mqp);
++=======
+ 
+ 	if (qp->ibqp.qp_type == IB_QPT_RAW_PACKET)
+ 		err = modify_raw_packet_qp(dev, qp, op);
+ 	else
+ 		err = mlx5_core_qp_modify(dev->mdev, op, in, sqd_event,
+ 					  &base->mqp);
++>>>>>>> ad5f8e964cd0 (IB/mlx5: Expose Raw Packet QP to user space consumers)
  	if (err)
  		goto out;
  
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
