ext4: provide ext4_issue_zeroout()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jan Kara <jack@suse.com>
commit 53085fac02d12fcd29a9cb074ec480ff0f77ae5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/53085fac.failed

Create new function ext4_issue_zeroout() to zeroout contiguous (both
logically and physically) part of inode data. We will need to issue
zeroout when extent structure is not readily available and this function
will allow us to do it without making up fake extent structures.

	Signed-off-by: Jan Kara <jack@suse.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit 53085fac02d12fcd29a9cb074ec480ff0f77ae5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/crypto.c
#	fs/ext4/ext4.h
#	fs/ext4/extents.c
diff --cc fs/ext4/ext4.h
index 5dda1d21c88f,ffc6ab000c78..000000000000
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@@ -1986,6 -2220,130 +1986,133 @@@ extern unsigned ext4_free_clusters_afte
  					      struct ext4_group_desc *gdp);
  ext4_fsblk_t ext4_inode_to_goal_block(struct inode *);
  
++<<<<<<< HEAD
++=======
+ /* crypto_policy.c */
+ int ext4_is_child_context_consistent_with_parent(struct inode *parent,
+ 						 struct inode *child);
+ int ext4_inherit_context(struct inode *parent, struct inode *child);
+ void ext4_to_hex(char *dst, char *src, size_t src_size);
+ int ext4_process_policy(const struct ext4_encryption_policy *policy,
+ 			struct inode *inode);
+ int ext4_get_policy(struct inode *inode,
+ 		    struct ext4_encryption_policy *policy);
+ 
+ /* crypto.c */
+ extern struct kmem_cache *ext4_crypt_info_cachep;
+ bool ext4_valid_contents_enc_mode(uint32_t mode);
+ uint32_t ext4_validate_encryption_key_size(uint32_t mode, uint32_t size);
+ extern struct workqueue_struct *ext4_read_workqueue;
+ struct ext4_crypto_ctx *ext4_get_crypto_ctx(struct inode *inode);
+ void ext4_release_crypto_ctx(struct ext4_crypto_ctx *ctx);
+ void ext4_restore_control_page(struct page *data_page);
+ struct page *ext4_encrypt(struct inode *inode,
+ 			  struct page *plaintext_page);
+ int ext4_decrypt(struct page *page);
+ int ext4_encrypted_zeroout(struct inode *inode, ext4_lblk_t lblk,
+ 			   ext4_fsblk_t pblk, ext4_lblk_t len);
+ 
+ #ifdef CONFIG_EXT4_FS_ENCRYPTION
+ int ext4_init_crypto(void);
+ void ext4_exit_crypto(void);
+ static inline int ext4_sb_has_crypto(struct super_block *sb)
+ {
+ 	return ext4_has_feature_encrypt(sb);
+ }
+ #else
+ static inline int ext4_init_crypto(void) { return 0; }
+ static inline void ext4_exit_crypto(void) { }
+ static inline int ext4_sb_has_crypto(struct super_block *sb)
+ {
+ 	return 0;
+ }
+ #endif
+ 
+ /* crypto_fname.c */
+ bool ext4_valid_filenames_enc_mode(uint32_t mode);
+ u32 ext4_fname_crypto_round_up(u32 size, u32 blksize);
+ unsigned ext4_fname_encrypted_size(struct inode *inode, u32 ilen);
+ int ext4_fname_crypto_alloc_buffer(struct inode *inode,
+ 				   u32 ilen, struct ext4_str *crypto_str);
+ int _ext4_fname_disk_to_usr(struct inode *inode,
+ 			    struct dx_hash_info *hinfo,
+ 			    const struct ext4_str *iname,
+ 			    struct ext4_str *oname);
+ int ext4_fname_disk_to_usr(struct inode *inode,
+ 			   struct dx_hash_info *hinfo,
+ 			   const struct ext4_dir_entry_2 *de,
+ 			   struct ext4_str *oname);
+ int ext4_fname_usr_to_disk(struct inode *inode,
+ 			   const struct qstr *iname,
+ 			   struct ext4_str *oname);
+ #ifdef CONFIG_EXT4_FS_ENCRYPTION
+ void ext4_fname_crypto_free_buffer(struct ext4_str *crypto_str);
+ int ext4_fname_setup_filename(struct inode *dir, const struct qstr *iname,
+ 			      int lookup, struct ext4_filename *fname);
+ void ext4_fname_free_filename(struct ext4_filename *fname);
+ #else
+ static inline
+ int ext4_setup_fname_crypto(struct inode *inode)
+ {
+ 	return 0;
+ }
+ static inline void ext4_fname_crypto_free_buffer(struct ext4_str *p) { }
+ static inline int ext4_fname_setup_filename(struct inode *dir,
+ 				     const struct qstr *iname,
+ 				     int lookup, struct ext4_filename *fname)
+ {
+ 	fname->usr_fname = iname;
+ 	fname->disk_name.name = (unsigned char *) iname->name;
+ 	fname->disk_name.len = iname->len;
+ 	return 0;
+ }
+ static inline void ext4_fname_free_filename(struct ext4_filename *fname) { }
+ #endif
+ 
+ 
+ /* crypto_key.c */
+ void ext4_free_crypt_info(struct ext4_crypt_info *ci);
+ void ext4_free_encryption_info(struct inode *inode, struct ext4_crypt_info *ci);
+ int _ext4_get_encryption_info(struct inode *inode);
+ 
+ #ifdef CONFIG_EXT4_FS_ENCRYPTION
+ int ext4_has_encryption_key(struct inode *inode);
+ 
+ static inline int ext4_get_encryption_info(struct inode *inode)
+ {
+ 	struct ext4_crypt_info *ci = EXT4_I(inode)->i_crypt_info;
+ 
+ 	if (!ci ||
+ 	    (ci->ci_keyring_key &&
+ 	     (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |
+ 					   (1 << KEY_FLAG_REVOKED) |
+ 					   (1 << KEY_FLAG_DEAD)))))
+ 		return _ext4_get_encryption_info(inode);
+ 	return 0;
+ }
+ 
+ static inline struct ext4_crypt_info *ext4_encryption_info(struct inode *inode)
+ {
+ 	return EXT4_I(inode)->i_crypt_info;
+ }
+ 
+ #else
+ static inline int ext4_has_encryption_key(struct inode *inode)
+ {
+ 	return 0;
+ }
+ static inline int ext4_get_encryption_info(struct inode *inode)
+ {
+ 	return 0;
+ }
+ static inline struct ext4_crypt_info *ext4_encryption_info(struct inode *inode)
+ {
+ 	return NULL;
+ }
+ #endif
+ 
+ 
++>>>>>>> 53085fac02d1 (ext4: provide ext4_issue_zeroout())
  /* dir.c */
  extern int __ext4_check_dir_entry(const char *, unsigned int, struct inode *,
  				  struct file *,
diff --cc fs/ext4/extents.c
index d936da6a075b,867e98b6bc6c..000000000000
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@@ -3106,13 -3122,8 +3106,17 @@@ static int ext4_ext_zeroout(struct inod
  
  	ee_len    = ext4_ext_get_actual_len(ex);
  	ee_pblock = ext4_ext_pblock(ex);
++<<<<<<< HEAD
 +
 +	ret = sb_issue_zeroout(inode->i_sb, ee_pblock, ee_len, GFP_NOFS);
 +	if (ret > 0)
 +		ret = 0;
 +
 +	return ret;
++=======
+ 	return ext4_issue_zeroout(inode, le32_to_cpu(ex->ee_block), ee_pblock,
+ 				  ee_len);
++>>>>>>> 53085fac02d1 (ext4: provide ext4_issue_zeroout())
  }
  
  /*
* Unmerged path fs/ext4/crypto.c
* Unmerged path fs/ext4/crypto.c
* Unmerged path fs/ext4/ext4.h
* Unmerged path fs/ext4/extents.c
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 235a73f02c8d..53b5a20659b7 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -384,6 +384,21 @@ static int __check_block_validity(struct inode *inode, const char *func,
 	return 0;
 }
 
+int ext4_issue_zeroout(struct inode *inode, ext4_lblk_t lblk, ext4_fsblk_t pblk,
+		       ext4_lblk_t len)
+{
+	int ret;
+
+	if (ext4_encrypted_inode(inode))
+		return ext4_encrypted_zeroout(inode, lblk, pblk, len);
+
+	ret = sb_issue_zeroout(inode->i_sb, pblk, len, GFP_NOFS);
+	if (ret > 0)
+		ret = 0;
+
+	return ret;
+}
+
 #define check_block_validity(inode, map)	\
 	__check_block_validity((inode), __func__, __LINE__, (map))
 
