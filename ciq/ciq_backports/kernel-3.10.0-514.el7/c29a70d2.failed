tunnel: introduce udp_tun_rx_dst()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Pravin B Shelar <pshelar@nicira.com>
commit c29a70d2cadfea443c027d23481f820530b70057
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c29a70d2.failed

Introduce function udp_tun_rx_dst() to initialize tunnel dst on
receive path.

	Signed-off-by: Pravin B Shelar <pshelar@nicira.com>
	Reviewed-by: Jesse Gross <jesse@nicira.com>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c29a70d2cadfea443c027d23481f820530b70057)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
#	include/net/dst_metadata.h
#	net/ipv4/ip_gre.c
diff --cc drivers/net/vxlan.c
index 9d79e4f0a7b6,5b4cf66e632e..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1195,6 -1263,19 +1195,22 @@@ static int vxlan_udp_encap_recv(struct 
  		vni &= VXLAN_VNI_MASK;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (vxlan_collect_metadata(vs)) {
+ 		tun_dst = udp_tun_rx_dst(skb, vxlan_get_sk_family(vs), TUNNEL_KEY,
+ 					 cpu_to_be64(vni >> 8), sizeof(*md));
+ 
+ 		if (!tun_dst)
+ 			goto drop;
+ 
+ 		info = &tun_dst->u.tun_info;
+ 		md = ip_tunnel_info_opts(info, sizeof(*md));
+ 	} else {
+ 		memset(md, 0, sizeof(*md));
+ 	}
+ 
++>>>>>>> c29a70d2cadf (tunnel: introduce udp_tun_rx_dst())
  	/* For backwards compatibility, only allow reserved fields to be
  	 * used by VXLAN extensions if explicitly requested.
  	 */
diff --cc net/ipv4/ip_gre.c
index afc4a83f7ee7,faf1cde6f8da..000000000000
--- a/net/ipv4/ip_gre.c
+++ b/net/ipv4/ip_gre.c
@@@ -218,7 -399,18 +218,22 @@@ static int ipgre_rcv(struct sk_buff *sk
  
  	if (tunnel) {
  		skb_pop_mac_header(skb);
++<<<<<<< HEAD
 +		ip_tunnel_rcv(tunnel, skb, tpi, log_ecn_error);
++=======
+ 		if (tunnel->collect_md) {
+ 			__be16 flags;
+ 			__be64 tun_id;
+ 
+ 			flags = tpi->flags & (TUNNEL_CSUM | TUNNEL_KEY);
+ 			tun_id = key_to_tunnel_id(tpi->key);
+ 			tun_dst = ip_tun_rx_dst(skb, flags, tun_id, 0);
+ 			if (!tun_dst)
+ 				return PACKET_REJECT;
+ 		}
+ 
+ 		ip_tunnel_rcv(tunnel, skb, tpi, tun_dst, log_ecn_error);
++>>>>>>> c29a70d2cadf (tunnel: introduce udp_tun_rx_dst())
  		return PACKET_RCVD;
  	}
  	return PACKET_REJECT;
* Unmerged path include/net/dst_metadata.h
* Unmerged path drivers/net/vxlan.c
* Unmerged path include/net/dst_metadata.h
diff --git a/include/net/udp_tunnel.h b/include/net/udp_tunnel.h
index c491c1221606..35041d0fc21e 100644
--- a/include/net/udp_tunnel.h
+++ b/include/net/udp_tunnel.h
@@ -93,6 +93,10 @@ int udp_tunnel6_xmit_skb(struct dst_entry *dst, struct sock *sk,
 
 void udp_tunnel_sock_release(struct socket *sock);
 
+struct metadata_dst *udp_tun_rx_dst(struct sk_buff *skb, unsigned short family,
+				    __be16 flags, __be64 tunnel_id,
+				    int md_size);
+
 static inline struct sk_buff *udp_tunnel_handle_offloads(struct sk_buff *skb,
 							 bool udp_csum)
 {
* Unmerged path net/ipv4/ip_gre.c
diff --git a/net/ipv4/udp_tunnel.c b/net/ipv4/udp_tunnel.c
index 6bb98cc193c9..20480f2ae18e 100644
--- a/net/ipv4/udp_tunnel.c
+++ b/net/ipv4/udp_tunnel.c
@@ -4,9 +4,10 @@
 #include <linux/udp.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
+#include <net/dst_metadata.h>
+#include <net/net_namespace.h>
 #include <net/udp.h>
 #include <net/udp_tunnel.h>
-#include <net/net_namespace.h>
 
 int udp_sock_create4(struct net *net, struct udp_port_cfg *cfg,
 		     struct socket **sockp)
@@ -105,4 +106,26 @@ void udp_tunnel_sock_release(struct socket *sock)
 }
 EXPORT_SYMBOL_GPL(udp_tunnel_sock_release);
 
+struct metadata_dst *udp_tun_rx_dst(struct sk_buff *skb,  unsigned short family,
+				    __be16 flags, __be64 tunnel_id, int md_size)
+{
+	struct metadata_dst *tun_dst;
+	struct ip_tunnel_info *info;
+
+	if (family == AF_INET)
+		tun_dst = ip_tun_rx_dst(skb, flags, tunnel_id, md_size);
+	else
+		tun_dst = ipv6_tun_rx_dst(skb, flags, tunnel_id, md_size);
+	if (!tun_dst)
+		return NULL;
+
+	info = &tun_dst->u.tun_info;
+	info->key.tp_src = udp_hdr(skb)->source;
+	info->key.tp_dst = udp_hdr(skb)->dest;
+	if (udp_hdr(skb)->check)
+		info->key.tun_flags |= TUNNEL_CSUM;
+	return tun_dst;
+}
+EXPORT_SYMBOL_GPL(udp_tun_rx_dst);
+
 MODULE_LICENSE("GPL");
