perf report: Use hierarchy hpp list on stdio

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit f58c95e344c26223c6503e6ecb0c1e11806d91e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f58c95e3.failed

Now hpp formats are linked using perf_hpp_list_node when hierarchy is
enabled.  Use this info to print entries with multiple sort keys in a
single hierarchy properly.

For example, the below example shows using 4 sort keys with 2 levels.

  $ perf report --hierarchy -s '{prev_pid,prev_comm},{next_pid,next_comm}' \
   --percent-limit 1 -i perf.data.sched
  ...
  #    Overhead  prev_pid+prev_comm / next_pid+next_comm
  # ...........  .......................................
  #
      22.36%     0  swapper/0
          9.48%     17773  transmission-gt
          5.25%     109  kworker/0:1H
          1.53%     6524  Xephyr
      21.39%     17773  transmission-gt
          9.52%     0  swapper/0
          9.04%     0  swapper/2
          1.78%     0  swapper/3

	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1457361308-514-6-git-send-email-namhyung@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit f58c95e344c26223c6503e6ecb0c1e11806d91e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/ui/stdio/hist.c
diff --cc tools/perf/ui/stdio/hist.c
index 28fcb1ee0342,7aff5acf3265..000000000000
--- a/tools/perf/ui/stdio/hist.c
+++ b/tools/perf/ui/stdio/hist.c
@@@ -409,6 -410,87 +409,90 @@@ static int hist_entry__snprintf(struct 
  	return hpp->buf - start;
  }
  
++<<<<<<< HEAD
++=======
+ static int hist_entry__hierarchy_fprintf(struct hist_entry *he,
+ 					 struct perf_hpp *hpp,
+ 					 struct hists *hists,
+ 					 FILE *fp)
+ {
+ 	const char *sep = symbol_conf.field_sep;
+ 	struct perf_hpp_fmt *fmt;
+ 	struct perf_hpp_list_node *fmt_node;
+ 	char *buf = hpp->buf;
+ 	size_t size = hpp->size;
+ 	int ret, printed = 0;
+ 	bool first = true;
+ 
+ 	if (symbol_conf.exclude_other && !he->parent)
+ 		return 0;
+ 
+ 	ret = scnprintf(hpp->buf, hpp->size, "%*s", he->depth * HIERARCHY_INDENT, "");
+ 	advance_hpp(hpp, ret);
+ 
+ 	/* the first hpp_list_node is for overhead columns */
+ 	fmt_node = list_first_entry(&hists->hpp_formats,
+ 				    struct perf_hpp_list_node, list);
+ 	perf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {
+ 		/*
+ 		 * If there's no field_sep, we still need
+ 		 * to display initial '  '.
+ 		 */
+ 		if (!sep || !first) {
+ 			ret = scnprintf(hpp->buf, hpp->size, "%s", sep ?: "  ");
+ 			advance_hpp(hpp, ret);
+ 		} else
+ 			first = false;
+ 
+ 		if (perf_hpp__use_color() && fmt->color)
+ 			ret = fmt->color(fmt, hpp, he);
+ 		else
+ 			ret = fmt->entry(fmt, hpp, he);
+ 
+ 		ret = hist_entry__snprintf_alignment(he, hpp, fmt, ret);
+ 		advance_hpp(hpp, ret);
+ 	}
+ 
+ 	if (!sep)
+ 		ret = scnprintf(hpp->buf, hpp->size, "%*s",
+ 				(hists->nr_hpp_node - 2) * HIERARCHY_INDENT, "");
+ 	advance_hpp(hpp, ret);
+ 
+ 	printed += fprintf(fp, "%s", buf);
+ 
+ 	perf_hpp_list__for_each_format(he->hpp_list, fmt) {
+ 		hpp->buf  = buf;
+ 		hpp->size = size;
+ 
+ 		/*
+ 		 * No need to call hist_entry__snprintf_alignment() since this
+ 		 * fmt is always the last column in the hierarchy mode.
+ 		 */
+ 		if (perf_hpp__use_color() && fmt->color)
+ 			fmt->color(fmt, hpp, he);
+ 		else
+ 			fmt->entry(fmt, hpp, he);
+ 
+ 		/*
+ 		 * dynamic entries are right-aligned but we want left-aligned
+ 		 * in the hierarchy mode
+ 		 */
+ 		printed += fprintf(fp, "%s%s", sep ?: "  ", ltrim(buf));
+ 	}
+ 	printed += putc('\n', fp);
+ 
+ 	if (symbol_conf.use_callchain && he->leaf) {
+ 		u64 total = hists__total_period(hists);
+ 
+ 		printed += hist_entry_callchain__fprintf(he, total, 0, fp);
+ 		goto out;
+ 	}
+ 
+ out:
+ 	return printed;
+ }
+ 
++>>>>>>> f58c95e344c2 (perf report: Use hierarchy hpp list on stdio)
  static int hist_entry__fprintf(struct hist_entry *he, size_t size,
  			       struct hists *hists,
  			       char *bf, size_t bfsz, FILE *fp)
@@@ -433,6 -518,111 +517,114 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int print_hierarchy_indent(const char *sep, int indent,
+ 				  const char *line, FILE *fp)
+ {
+ 	if (sep != NULL || indent < 2)
+ 		return 0;
+ 
+ 	return fprintf(fp, "%-.*s", (indent - 2) * HIERARCHY_INDENT, line);
+ }
+ 
+ static int print_hierarchy_header(struct hists *hists, struct perf_hpp *hpp,
+ 				  const char *sep, FILE *fp)
+ {
+ 	bool first_node, first_col;
+ 	int indent;
+ 	int depth;
+ 	unsigned width = 0;
+ 	unsigned header_width = 0;
+ 	struct perf_hpp_fmt *fmt;
+ 	struct perf_hpp_list_node *fmt_node;
+ 
+ 	indent = hists->nr_hpp_node;
+ 
+ 	/* preserve max indent depth for column headers */
+ 	print_hierarchy_indent(sep, indent, spaces, fp);
+ 
+ 	/* the first hpp_list_node is for overhead columns */
+ 	fmt_node = list_first_entry(&hists->hpp_formats,
+ 				    struct perf_hpp_list_node, list);
+ 
+ 	perf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {
+ 		fmt->header(fmt, hpp, hists_to_evsel(hists));
+ 		fprintf(fp, "%s%s", hpp->buf, sep ?: "  ");
+ 	}
+ 
+ 	/* combine sort headers with ' / ' */
+ 	first_node = true;
+ 	list_for_each_entry_continue(fmt_node, &hists->hpp_formats, list) {
+ 		if (!first_node)
+ 			header_width += fprintf(fp, " / ");
+ 		first_node = false;
+ 
+ 		first_col = true;
+ 		perf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {
+ 			if (perf_hpp__should_skip(fmt, hists))
+ 				continue;
+ 
+ 			if (!first_col)
+ 				header_width += fprintf(fp, "+");
+ 			first_col = false;
+ 
+ 			fmt->header(fmt, hpp, hists_to_evsel(hists));
+ 			rtrim(hpp->buf);
+ 
+ 			header_width += fprintf(fp, "%s", ltrim(hpp->buf));
+ 		}
+ 	}
+ 
+ 	fprintf(fp, "\n# ");
+ 
+ 	/* preserve max indent depth for initial dots */
+ 	print_hierarchy_indent(sep, indent, dots, fp);
+ 
+ 	/* the first hpp_list_node is for overhead columns */
+ 	fmt_node = list_first_entry(&hists->hpp_formats,
+ 				    struct perf_hpp_list_node, list);
+ 
+ 	first_col = true;
+ 	perf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {
+ 		if (!first_col)
+ 			fprintf(fp, "%s", sep ?: "..");
+ 		first_col = false;
+ 
+ 		width = fmt->width(fmt, hpp, hists_to_evsel(hists));
+ 		fprintf(fp, "%.*s", width, dots);
+ 	}
+ 
+ 	depth = 0;
+ 	list_for_each_entry_continue(fmt_node, &hists->hpp_formats, list) {
+ 		first_col = true;
+ 		width = depth * HIERARCHY_INDENT;
+ 
+ 		perf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {
+ 			if (perf_hpp__should_skip(fmt, hists))
+ 				continue;
+ 
+ 			if (!first_col)
+ 				width++;  /* for '+' sign between column header */
+ 			first_col = false;
+ 
+ 			width += fmt->width(fmt, hpp, hists_to_evsel(hists));
+ 		}
+ 
+ 		if (width > header_width)
+ 			header_width = width;
+ 
+ 		depth++;
+ 	}
+ 
+ 	fprintf(fp, "%s%-.*s", sep ?: "  ", header_width, dots);
+ 
+ 	fprintf(fp, "\n#\n");
+ 
+ 	return 2;
+ }
+ 
++>>>>>>> f58c95e344c2 (perf report: Use hierarchy hpp list on stdio)
  size_t hists__fprintf(struct hists *hists, bool show_header, int max_rows,
  		      int max_cols, float min_pcnt, FILE *fp)
  {
@@@ -464,8 -656,17 +657,22 @@@
  
  	fprintf(fp, "# ");
  
++<<<<<<< HEAD
 +	perf_hpp__for_each_format(fmt) {
 +		if (perf_hpp__should_skip(fmt))
++=======
+ 	if (symbol_conf.report_hierarchy) {
+ 		list_for_each_entry(fmt_node, &hists->hpp_formats, list) {
+ 			perf_hpp_list__for_each_format(&fmt_node->hpp, fmt)
+ 				perf_hpp__reset_width(fmt, hists);
+ 		}
+ 		nr_rows += print_hierarchy_header(hists, &dummy_hpp, sep, fp);
+ 		goto print_entries;
+ 	}
+ 
+ 	hists__for_each_format(hists, fmt) {
+ 		if (perf_hpp__should_skip(fmt, hists))
++>>>>>>> f58c95e344c2 (perf report: Use hierarchy hpp list on stdio)
  			continue;
  
  		if (!first)
@@@ -537,6 -740,20 +744,23 @@@ print_entries
  		if (max_rows && ++nr_rows >= max_rows)
  			break;
  
++<<<<<<< HEAD
++=======
+ 		/*
+ 		 * If all children are filtered out or percent-limited,
+ 		 * display "no entry >= x.xx%" message.
+ 		 */
+ 		if (!h->leaf && !hist_entry__has_hierarchy_children(h, min_pcnt)) {
+ 			int depth = hists->nr_hpp_node + h->depth + 1;
+ 
+ 			print_hierarchy_indent(sep, depth, spaces, fp);
+ 			fprintf(fp, "%*sno entry >= %.2f%%\n", indent, "", min_pcnt);
+ 
+ 			if (max_rows && ++nr_rows >= max_rows)
+ 				break;
+ 		}
+ 
++>>>>>>> f58c95e344c2 (perf report: Use hierarchy hpp list on stdio)
  		if (h->ms.map == NULL && verbose > 1) {
  			__map_groups__fprintf_maps(h->thread->mg,
  						   MAP__FUNCTION, fp);
* Unmerged path tools/perf/ui/stdio/hist.c
