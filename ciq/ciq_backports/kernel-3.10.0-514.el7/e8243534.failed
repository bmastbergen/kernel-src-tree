ipv6: namespace cleanups

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author stephen hemminger <stephen@networkplumber.org>
commit e82435341ff08769b70400b72a7a8efda83c5014
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e8243534.failed

Running 'make namespacecheck' shows:
  net/ipv6/route.o
    ipv6_route_table_template
    rt6_bind_peer
  net/ipv6/icmp.o
    icmpv6_route_lookup
    ipv6_icmp_table_template

This addresses some of those warnings by:
 * make icmpv6_route_lookup static
 * move inline's out of ip6_route.h since only used into route.c
 * move rt6_bind_peer into route.c

	Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e82435341ff08769b70400b72a7a8efda83c5014)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip6_route.h
#	include/net/ipv6.h
#	net/ipv6/icmp.c
diff --cc include/net/ip6_route.h
index c2439795bc4f,1fb6cddbd448..000000000000
--- a/include/net/ip6_route.h
+++ b/include/net/ip6_route.h
@@@ -56,32 -51,6 +56,35 @@@ static inline unsigned int rt6_flags2sr
  	return (flags >> 3) & 7;
  }
  
++<<<<<<< HEAD
 +static inline bool rt6_need_strict(const struct in6_addr *daddr)
 +{
 +	return ipv6_addr_type(daddr) &
 +		(IPV6_ADDR_MULTICAST | IPV6_ADDR_LINKLOCAL | IPV6_ADDR_LOOPBACK);
 +}
 +
 +void rt6_bind_peer(struct rt6_info *rt, int create);
 +
 +static inline struct inet_peer *__rt6_get_peer(struct rt6_info *rt, int create)
 +{
 +	if (rt6_has_peer(rt))
 +		return rt6_peer_ptr(rt);
 +
 +	rt6_bind_peer(rt, create);
 +	return (rt6_has_peer(rt) ? rt6_peer_ptr(rt) : NULL);
 +}
 +
 +static inline struct inet_peer *rt6_get_peer(struct rt6_info *rt)
 +{
 +	return __rt6_get_peer(rt, 0);
 +}
 +
 +static inline struct inet_peer *rt6_get_peer_create(struct rt6_info *rt)
 +{
 +	return __rt6_get_peer(rt, 1);
 +}
++=======
++>>>>>>> e82435341ff0 (ipv6: namespace cleanups)
  
  void ip6_route_input(struct sk_buff *skb);
  
diff --cc include/net/ipv6.h
index 5dca98c3fc9f,12079c65ea3e..000000000000
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@@ -264,6 -264,9 +264,12 @@@ static inline void fl6_sock_release(str
  
  void icmpv6_notify(struct sk_buff *skb, u8 type, u8 code, __be32 info);
  
++<<<<<<< HEAD
++=======
+ int icmpv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,
+ 			       struct icmp6hdr *thdr, int len);
+ 
++>>>>>>> e82435341ff0 (ipv6: namespace cleanups)
  int ip6_ra_control(struct sock *sk, int sel);
  
  int ipv6_parse_hopopts(struct sk_buff *skb);
@@@ -886,8 -835,7 +892,12 @@@ static inline int snmp6_unregister_dev(
  #endif
  
  #ifdef CONFIG_SYSCTL
++<<<<<<< HEAD
 +extern ctl_table ipv6_route_table_template[];
 +extern ctl_table ipv6_icmp_table_template[];
++=======
+ extern struct ctl_table ipv6_route_table_template[];
++>>>>>>> e82435341ff0 (ipv6: namespace cleanups)
  
  struct ctl_table *ipv6_icmp_sysctl_init(struct net *net);
  struct ctl_table *ipv6_route_sysctl_init(struct net *net);
diff --cc net/ipv6/icmp.c
index 8a66e2366f49,5d420095190f..000000000000
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@@ -307,8 -315,10 +307,15 @@@ static void mip6_addr_swap(struct sk_bu
  static inline void mip6_addr_swap(struct sk_buff *skb) {}
  #endif
  
++<<<<<<< HEAD
 +static struct dst_entry *icmpv6_route_lookup(struct net *net, struct sk_buff *skb,
 +					     struct sock *sk, struct flowi6 *fl6)
++=======
+ static struct dst_entry *icmpv6_route_lookup(struct net *net,
+ 					     struct sk_buff *skb,
+ 					     struct sock *sk,
+ 					     struct flowi6 *fl6)
++>>>>>>> e82435341ff0 (ipv6: namespace cleanups)
  {
  	struct dst_entry *dst, *dst2;
  	struct flowi6 fl2;
* Unmerged path include/net/ip6_route.h
* Unmerged path include/net/ipv6.h
* Unmerged path net/ipv6/icmp.c
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index 96de72f4a693..a4aba7aee94b 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -104,6 +104,36 @@ static struct rt6_info *rt6_get_route_info(struct net *net,
 					   const struct in6_addr *gwaddr, int ifindex);
 #endif
 
+static void rt6_bind_peer(struct rt6_info *rt, int create)
+{
+	struct inet_peer_base *base;
+	struct inet_peer *peer;
+
+	base = inetpeer_base_ptr(rt->_rt6i_peer);
+	if (!base)
+		return;
+
+	peer = inet_getpeer_v6(base, &rt->rt6i_dst.addr, create);
+	if (peer) {
+		if (!rt6_set_peer(rt, peer))
+			inet_putpeer(peer);
+	}
+}
+
+static struct inet_peer *__rt6_get_peer(struct rt6_info *rt, int create)
+{
+	if (rt6_has_peer(rt))
+		return rt6_peer_ptr(rt);
+
+	rt6_bind_peer(rt, create);
+	return (rt6_has_peer(rt) ? rt6_peer_ptr(rt) : NULL);
+}
+
+static struct inet_peer *rt6_get_peer_create(struct rt6_info *rt)
+{
+	return __rt6_get_peer(rt, 1);
+}
+
 static u32 *ipv6_cow_metrics(struct dst_entry *dst, unsigned long old)
 {
 	struct rt6_info *rt = (struct rt6_info *) dst;
@@ -312,22 +342,6 @@ static void ip6_dst_destroy(struct dst_entry *dst)
 	}
 }
 
-void rt6_bind_peer(struct rt6_info *rt, int create)
-{
-	struct inet_peer_base *base;
-	struct inet_peer *peer;
-
-	base = inetpeer_base_ptr(rt->_rt6i_peer);
-	if (!base)
-		return;
-
-	peer = inet_getpeer_v6(base, &rt->rt6i_dst.addr, create);
-	if (peer) {
-		if (!rt6_set_peer(rt, peer))
-			inet_putpeer(peer);
-	}
-}
-
 static void ip6_dst_ifdown(struct dst_entry *dst, struct net_device *dev,
 			   int how)
 {
