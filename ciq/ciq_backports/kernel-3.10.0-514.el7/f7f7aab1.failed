IB/srp: Convert to new registration API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sagi Grimberg <sagig@mellanox.com>
commit f7f7aab1a5c0a495ae9a2d604badd1e3f9f20795
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f7f7aab1.failed

Instead of constructing a page list, call ib_map_mr_sg
and post a new ib_reg_wr. srp_map_finish_fr now returns
the number of sg elements registered.

Remove srp_finish_mapping since no one is calling it.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Tested-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit f7f7aab1a5c0a495ae9a2d604badd1e3f9f20795)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/srp/ib_srp.c
diff --cc drivers/infiniband/ulp/srp/ib_srp.c
index feb0c8ea0788,f2c8dcaf96a7..000000000000
--- a/drivers/infiniband/ulp/srp/ib_srp.c
+++ b/drivers/infiniband/ulp/srp/ib_srp.c
@@@ -1305,13 -1312,26 +1296,35 @@@ static int srp_map_finish_fr(struct srp
  	struct srp_target_port *target = ch->target;
  	struct srp_device *dev = target->srp_host->srp_dev;
  	struct ib_send_wr *bad_wr;
++<<<<<<< HEAD
 +	struct ib_send_wr wr;
 +	struct srp_fr_desc *desc;
 +	u32 rkey;
++=======
+ 	struct ib_reg_wr wr;
+ 	struct srp_fr_desc *desc;
+ 	u32 rkey;
+ 	int n, err;
++>>>>>>> f7f7aab1a5c0 (IB/srp: Convert to new registration API)
  
  	if (state->fr.next >= state->fr.end)
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	WARN_ON_ONCE(!dev->use_fast_reg);
+ 
+ 	if (state->sg_nents == 0)
+ 		return 0;
+ 
+ 	if (state->sg_nents == 1 && target->global_mr) {
+ 		srp_map_desc(state, sg_dma_address(state->sg),
+ 			     sg_dma_len(state->sg),
+ 			     target->global_mr->rkey);
+ 		return 1;
+ 	}
+ 
++>>>>>>> f7f7aab1a5c0 (IB/srp: Convert to new registration API)
  	desc = srp_fr_pool_get(ch->fr_pool);
  	if (!desc)
  		return -ENOMEM;
@@@ -1319,29 -1339,33 +1332,52 @@@
  	rkey = ib_inc_rkey(desc->mr->rkey);
  	ib_update_fast_reg_key(desc->mr, rkey);
  
- 	memcpy(desc->frpl->page_list, state->pages,
- 	       sizeof(state->pages[0]) * state->npages);
+ 	n = ib_map_mr_sg(desc->mr, state->sg, state->sg_nents,
+ 			 dev->mr_page_size);
+ 	if (unlikely(n < 0))
+ 		return n;
  
++<<<<<<< HEAD
 +	memset(&wr, 0, sizeof(wr));
 +	wr.opcode = IB_WR_FAST_REG_MR;
 +	wr.wr_id = FAST_REG_WR_ID_MASK;
 +	wr.wr.fast_reg.iova_start = state->base_dma_addr;
 +	wr.wr.fast_reg.page_list = desc->frpl;
 +	wr.wr.fast_reg.page_list_len = state->npages;
 +	wr.wr.fast_reg.page_shift = ilog2(dev->mr_page_size);
 +	wr.wr.fast_reg.length = state->dma_len;
 +	wr.wr.fast_reg.access_flags = (IB_ACCESS_LOCAL_WRITE |
 +				       IB_ACCESS_REMOTE_READ |
 +				       IB_ACCESS_REMOTE_WRITE);
 +	wr.wr.fast_reg.rkey = desc->mr->lkey;
++=======
+ 	wr.wr.next = NULL;
+ 	wr.wr.opcode = IB_WR_REG_MR;
+ 	wr.wr.wr_id = FAST_REG_WR_ID_MASK;
+ 	wr.wr.num_sge = 0;
+ 	wr.wr.send_flags = 0;
+ 	wr.mr = desc->mr;
+ 	wr.key = desc->mr->rkey;
+ 	wr.access = (IB_ACCESS_LOCAL_WRITE |
+ 		     IB_ACCESS_REMOTE_READ |
+ 		     IB_ACCESS_REMOTE_WRITE);
++>>>>>>> f7f7aab1a5c0 (IB/srp: Convert to new registration API)
  
  	*state->fr.next++ = desc;
  	state->nmdesc++;
  
- 	srp_map_desc(state, state->base_dma_addr, state->dma_len,
- 		     desc->mr->rkey);
+ 	srp_map_desc(state, desc->mr->iova,
+ 		     desc->mr->length, desc->mr->rkey);
  
++<<<<<<< HEAD
 +	return ib_post_send(ch->qp, &wr, &bad_wr);
++=======
+ 	err = ib_post_send(ch->qp, &wr.wr, &bad_wr);
+ 	if (unlikely(err))
+ 		return err;
+ 
+ 	return n;
++>>>>>>> f7f7aab1a5c0 (IB/srp: Convert to new registration API)
  }
  
  static int srp_finish_mapping(struct srp_map_state *state,
@@@ -1414,9 -1421,63 +1450,69 @@@ static int srp_map_sg_entry(struct srp_
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int srp_map_sg(struct srp_map_state *state, struct srp_rdma_ch *ch,
 +		      struct srp_request *req, struct scatterlist *scat,
 +		      int count)
++=======
+ static int srp_map_sg_fmr(struct srp_map_state *state, struct srp_rdma_ch *ch,
+ 			  struct srp_request *req, struct scatterlist *scat,
+ 			  int count)
+ {
+ 	struct scatterlist *sg;
+ 	int i, ret;
+ 
+ 	state->desc = req->indirect_desc;
+ 	state->pages = req->map_page;
+ 	state->fmr.next = req->fmr_list;
+ 	state->fmr.end = req->fmr_list + ch->target->cmd_sg_cnt;
+ 
+ 	for_each_sg(scat, sg, count, i) {
+ 		ret = srp_map_sg_entry(state, ch, sg, i);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	ret = srp_map_finish_fmr(state, ch);
+ 	if (ret)
+ 		return ret;
+ 
+ 	req->nmdesc = state->nmdesc;
+ 
+ 	return 0;
+ }
+ 
+ static int srp_map_sg_fr(struct srp_map_state *state, struct srp_rdma_ch *ch,
+ 			 struct srp_request *req, struct scatterlist *scat,
+ 			 int count)
+ {
+ 	state->desc = req->indirect_desc;
+ 	state->fr.next = req->fr_list;
+ 	state->fr.end = req->fr_list + ch->target->cmd_sg_cnt;
+ 	state->sg = scat;
+ 	state->sg_nents = scsi_sg_count(req->scmnd);
+ 
+ 	while (state->sg_nents) {
+ 		int i, n;
+ 
+ 		n = srp_map_finish_fr(state, ch);
+ 		if (unlikely(n < 0))
+ 			return n;
+ 
+ 		state->sg_nents -= n;
+ 		for (i = 0; i < n; i++)
+ 			state->sg = sg_next(state->sg);
+ 	}
+ 
+ 	req->nmdesc = state->nmdesc;
+ 
+ 	return 0;
+ }
+ 
+ static int srp_map_sg_dma(struct srp_map_state *state, struct srp_rdma_ch *ch,
+ 			  struct srp_request *req, struct scatterlist *scat,
+ 			  int count)
++>>>>>>> f7f7aab1a5c0 (IB/srp: Convert to new registration API)
  {
  	struct srp_target_port *target = ch->target;
  	struct srp_device *dev = target->srp_host->srp_dev;
* Unmerged path drivers/infiniband/ulp/srp/ib_srp.c
diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 3608f2e4819c..87a2a919dc43 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -242,7 +242,6 @@ struct srp_iu {
 struct srp_fr_desc {
 	struct list_head		entry;
 	struct ib_mr			*mr;
-	struct ib_fast_reg_page_list	*frpl;
 };
 
 /**
@@ -294,11 +293,17 @@ struct srp_map_state {
 		} gen;
 	};
 	struct srp_direct_buf  *desc;
-	u64		       *pages;
+	union {
+		u64			*pages;
+		struct scatterlist	*sg;
+	};
 	dma_addr_t		base_dma_addr;
 	u32			dma_len;
 	u32			total_len;
-	unsigned int		npages;
+	union {
+		unsigned int	npages;
+		int		sg_nents;
+	};
 	unsigned int		nmdesc;
 	unsigned int		ndesc;
 };
