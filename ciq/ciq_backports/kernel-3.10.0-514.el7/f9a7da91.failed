hv_netvsc: don't lose VF information

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit f9a7da9130ef0143eb900794c7863dc5c9051fbc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f9a7da91.failed

struct netvsc_device is not suitable for storing VF information as this
structure is being destroyed on MTU change / set channel operation (see
rndis_filter_device_remove()). Move all VF related stuff to struct
net_device_context which is persistent.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Acked-by: Haiyang Zhang <haiyangz@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f9a7da9130ef0143eb900794c7863dc5c9051fbc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/netvsc.c
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/hyperv_net.h
index cf498664d989,3b3ecf237a12..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -595,11 -622,75 +595,80 @@@ struct nvsp_message 
  #define NETVSC_PACKET_SIZE                      4096
  
  #define VRSS_SEND_TAB_SIZE 16
 -#define VRSS_CHANNEL_MAX 64
  
++<<<<<<< HEAD
 +/* Per netvsc channel-specific */
++=======
+ #define RNDIS_MAX_PKT_DEFAULT 8
+ #define RNDIS_PKT_ALIGN_DEFAULT 8
+ 
+ struct multi_send_data {
+ 	struct sk_buff *skb; /* skb containing the pkt */
+ 	struct hv_netvsc_packet *pkt; /* netvsc pkt pending */
+ 	u32 count; /* counter of batched packets */
+ };
+ 
+ struct netvsc_stats {
+ 	u64 packets;
+ 	u64 bytes;
+ 	struct u64_stats_sync syncp;
+ };
+ 
+ struct netvsc_reconfig {
+ 	struct list_head list;
+ 	u32 event;
+ };
+ 
+ struct garp_wrk {
+ 	struct work_struct dwrk;
+ 	struct net_device *netdev;
+ 	struct net_device_context *net_device_ctx;
+ };
+ 
+ /* The context of the netvsc device  */
+ struct net_device_context {
+ 	/* point back to our device context */
+ 	struct hv_device *device_ctx;
+ 	/* netvsc_device */
+ 	struct netvsc_device *nvdev;
+ 	/* reconfigure work */
+ 	struct delayed_work dwork;
+ 	/* last reconfig time */
+ 	unsigned long last_reconfig;
+ 	/* reconfig events */
+ 	struct list_head reconfig_events;
+ 	/* list protection */
+ 	spinlock_t lock;
+ 
+ 	struct work_struct work;
+ 	u32 msg_enable; /* debug level */
+ 	struct garp_wrk gwrk;
+ 
+ 	struct netvsc_stats __percpu *tx_stats;
+ 	struct netvsc_stats __percpu *rx_stats;
+ 
+ 	/* Ethtool settings */
+ 	u8 duplex;
+ 	u32 speed;
+ 
+ 	/* the device is going away */
+ 	bool start_remove;
+ 
+ 	/* State to manage the associated VF interface. */
+ 	struct net_device *vf_netdev;
+ 	bool vf_inject;
+ 	atomic_t vf_use_cnt;
+ 	/* 1: allocated, serial number is valid. 0: not allocated */
+ 	u32 vf_alloc;
+ 	/* Serial number of the VF to team with */
+ 	u32 vf_serial;
+ };
+ 
+ /* Per netvsc device */
++>>>>>>> f9a7da9130ef (hv_netvsc: don't lose VF information)
  struct netvsc_device {
 +	struct hv_device *dev;
 +
  	u32 nvsp_version;
  
  	atomic_t num_outstanding_sends;
@@@ -647,8 -737,26 +716,17 @@@
  	unsigned char *cb_buffer;
  	/* The sub channel callback buffer */
  	unsigned char *sub_cb_buf;
++<<<<<<< HEAD
++=======
+ 
+ 	struct multi_send_data msd[VRSS_CHANNEL_MAX];
+ 	u32 max_pkt; /* max number of pkt in one send, e.g. 8 */
+ 	u32 pkt_align; /* alignment bytes, e.g. 8 */
+ 
+ 	atomic_t open_cnt;
++>>>>>>> f9a7da9130ef (hv_netvsc: don't lose VF information)
  };
  
 -static inline struct netvsc_device *
 -net_device_to_netvsc_device(struct net_device *ndev)
 -{
 -	return ((struct net_device_context *)netdev_priv(ndev))->nvdev;
 -}
 -
 -static inline struct netvsc_device *
 -hv_device_to_netvsc_device(struct hv_device *device)
 -{
 -	return net_device_to_netvsc_device(hv_get_drvdata(device));
 -}
 -
  /* NdisInitialize message */
  struct rndis_initialize_request {
  	u32 req_id;
diff --cc drivers/net/hyperv/netvsc.c
index 74ee1b57e623,410fb8e81376..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -50,12 -75,11 +50,19 @@@ static struct netvsc_device *alloc_net_
  	}
  
  	init_waitqueue_head(&net_device->wait_drain);
 +	net_device->start_remove = false;
  	net_device->destroy = false;
++<<<<<<< HEAD
 +	net_device->dev = device;
 +	net_device->ndev = ndev;
 +
 +	hv_set_drvdata(device, net_device);
++=======
+ 	atomic_set(&net_device->open_cnt, 0);
+ 	net_device->max_pkt = RNDIS_MAX_PKT_DEFAULT;
+ 	net_device->pkt_align = RNDIS_PKT_ALIGN_DEFAULT;
+ 
++>>>>>>> f9a7da9130ef (hv_netvsc: don't lose VF information)
  	return net_device;
  }
  
@@@ -975,6 -1102,62 +982,65 @@@ static void netvsc_send_table(struct hv
  		nvscdev->send_table[i] = tab[i];
  }
  
++<<<<<<< HEAD
++=======
+ static void netvsc_send_vf(struct net_device_context *net_device_ctx,
+ 			   struct nvsp_message *nvmsg)
+ {
+ 	net_device_ctx->vf_alloc = nvmsg->msg.v4_msg.vf_assoc.allocated;
+ 	net_device_ctx->vf_serial = nvmsg->msg.v4_msg.vf_assoc.serial;
+ }
+ 
+ static inline void netvsc_receive_inband(struct hv_device *hdev,
+ 				 struct net_device_context *net_device_ctx,
+ 				 struct nvsp_message *nvmsg)
+ {
+ 	switch (nvmsg->hdr.msg_type) {
+ 	case NVSP_MSG5_TYPE_SEND_INDIRECTION_TABLE:
+ 		netvsc_send_table(hdev, nvmsg);
+ 		break;
+ 
+ 	case NVSP_MSG4_TYPE_SEND_VF_ASSOCIATION:
+ 		netvsc_send_vf(net_device_ctx, nvmsg);
+ 		break;
+ 	}
+ }
+ 
+ static void netvsc_process_raw_pkt(struct hv_device *device,
+ 				   struct vmbus_channel *channel,
+ 				   struct netvsc_device *net_device,
+ 				   struct net_device *ndev,
+ 				   u64 request_id,
+ 				   struct vmpacket_descriptor *desc)
+ {
+ 	struct nvsp_message *nvmsg;
+ 	struct net_device_context *net_device_ctx = netdev_priv(ndev);
+ 
+ 	nvmsg = (struct nvsp_message *)((unsigned long)
+ 		desc + (desc->offset8 << 3));
+ 
+ 	switch (desc->type) {
+ 	case VM_PKT_COMP:
+ 		netvsc_send_completion(net_device, channel, device, desc);
+ 		break;
+ 
+ 	case VM_PKT_DATA_USING_XFER_PAGES:
+ 		netvsc_receive(net_device, channel, device, desc);
+ 		break;
+ 
+ 	case VM_PKT_DATA_INBAND:
+ 		netvsc_receive_inband(device, net_device_ctx, nvmsg);
+ 		break;
+ 
+ 	default:
+ 		netdev_err(ndev, "unhandled packet type %d, tid %llx\n",
+ 			   desc->type, request_id);
+ 		break;
+ 	}
+ }
+ 
+ 
++>>>>>>> f9a7da9130ef (hv_netvsc: don't lose VF information)
  void netvsc_channel_cb(void *context)
  {
  	int ret;
diff --cc drivers/net/hyperv/netvsc_drv.c
index 822e657fcee7,794139ba31ab..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -688,15 -635,85 +688,87 @@@ int netvsc_recv_callback(struct hv_devi
  			skb->ip_summed = CHECKSUM_NONE;
  	}
  
 -	if (vlan_tci & VLAN_TAG_PRESENT)
 +	if (packet->vlan_tci & VLAN_TAG_PRESENT)
  		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
 -				       vlan_tci);
 +				       packet->vlan_tci);
  
++<<<<<<< HEAD
 +	skb_record_rx_queue(skb, packet->channel->
++=======
+ 	return skb;
+ }
+ 
+ /*
+  * netvsc_recv_callback -  Callback when we receive a packet from the
+  * "wire" on the specified device.
+  */
+ int netvsc_recv_callback(struct hv_device *device_obj,
+ 				struct hv_netvsc_packet *packet,
+ 				void **data,
+ 				struct ndis_tcp_ip_checksum_info *csum_info,
+ 				struct vmbus_channel *channel,
+ 				u16 vlan_tci)
+ {
+ 	struct net_device *net = hv_get_drvdata(device_obj);
+ 	struct net_device_context *net_device_ctx = netdev_priv(net);
+ 	struct sk_buff *skb;
+ 	struct sk_buff *vf_skb;
+ 	struct netvsc_stats *rx_stats;
+ 	u32 bytes_recvd = packet->total_data_buflen;
+ 	int ret = 0;
+ 
+ 	if (!net || net->reg_state != NETREG_REGISTERED)
+ 		return NVSP_STAT_FAIL;
+ 
+ 	if (READ_ONCE(net_device_ctx->vf_inject)) {
+ 		atomic_inc(&net_device_ctx->vf_use_cnt);
+ 		if (!READ_ONCE(net_device_ctx->vf_inject)) {
+ 			/*
+ 			 * We raced; just move on.
+ 			 */
+ 			atomic_dec(&net_device_ctx->vf_use_cnt);
+ 			goto vf_injection_done;
+ 		}
+ 
+ 		/*
+ 		 * Inject this packet into the VF inerface.
+ 		 * On Hyper-V, multicast and brodcast packets
+ 		 * are only delivered on the synthetic interface
+ 		 * (after subjecting these to policy filters on
+ 		 * the host). Deliver these via the VF interface
+ 		 * in the guest.
+ 		 */
+ 		vf_skb = netvsc_alloc_recv_skb(net_device_ctx->vf_netdev,
+ 					       packet, csum_info, *data,
+ 					       vlan_tci);
+ 		if (vf_skb != NULL) {
+ 			++net_device_ctx->vf_netdev->stats.rx_packets;
+ 			net_device_ctx->vf_netdev->stats.rx_bytes +=
+ 				bytes_recvd;
+ 			netif_receive_skb(vf_skb);
+ 		} else {
+ 			++net->stats.rx_dropped;
+ 			ret = NVSP_STAT_FAIL;
+ 		}
+ 		atomic_dec(&net_device_ctx->vf_use_cnt);
+ 		return ret;
+ 	}
+ 
+ vf_injection_done:
+ 	rx_stats = this_cpu_ptr(net_device_ctx->rx_stats);
+ 
+ 	/* Allocate a skb - TODO direct I/O to pages? */
+ 	skb = netvsc_alloc_recv_skb(net, packet, csum_info, *data, vlan_tci);
+ 	if (unlikely(!skb)) {
+ 		++net->stats.rx_dropped;
+ 		return NVSP_STAT_FAIL;
+ 	}
+ 	skb_record_rx_queue(skb, channel->
++>>>>>>> f9a7da9130ef (hv_netvsc: don't lose VF information)
  			    offermsg.offer.sub_channel_index);
  
 -	u64_stats_update_begin(&rx_stats->syncp);
 -	rx_stats->packets++;
 -	rx_stats->bytes += packet->total_data_buflen;
 -	u64_stats_update_end(&rx_stats->syncp);
 +	net->stats.rx_packets++;
 +	net->stats.rx_bytes += packet->total_data_buflen;
  
  	/*
  	 * Pass the skb back up. Network stack will deallocate the skb when it
@@@ -857,8 -1129,213 +929,205 @@@ static void netvsc_link_change(struct w
  
  	if (notify)
  		netdev_notify_peers(net);
 -
 -	/* link_watch only sends one notification with current state per
 -	 * second, handle next reconfig event in 2 seconds.
 -	 */
 -	if (reschedule)
 -		schedule_delayed_work(&ndev_ctx->dwork, LINKCHANGE_INT);
 -
 -	return;
 -
 -out_unlock:
 -	rtnl_unlock();
  }
  
++<<<<<<< HEAD
++=======
+ static void netvsc_free_netdev(struct net_device *netdev)
+ {
+ 	struct net_device_context *net_device_ctx = netdev_priv(netdev);
+ 
+ 	free_percpu(net_device_ctx->tx_stats);
+ 	free_percpu(net_device_ctx->rx_stats);
+ 	free_netdev(netdev);
+ }
+ 
+ static void netvsc_notify_peers(struct work_struct *wrk)
+ {
+ 	struct garp_wrk *gwrk;
+ 
+ 	gwrk = container_of(wrk, struct garp_wrk, dwrk);
+ 
+ 	netdev_notify_peers(gwrk->netdev);
+ 
+ 	atomic_dec(&gwrk->net_device_ctx->vf_use_cnt);
+ }
+ 
+ static struct net_device *get_netvsc_net_device(char *mac)
+ {
+ 	struct net_device *dev, *found = NULL;
+ 	int rtnl_locked;
+ 
+ 	rtnl_locked = rtnl_trylock();
+ 
+ 	for_each_netdev(&init_net, dev) {
+ 		if (memcmp(dev->dev_addr, mac, ETH_ALEN) == 0) {
+ 			if (dev->netdev_ops != &device_ops)
+ 				continue;
+ 			found = dev;
+ 			break;
+ 		}
+ 	}
+ 	if (rtnl_locked)
+ 		rtnl_unlock();
+ 
+ 	return found;
+ }
+ 
+ static int netvsc_register_vf(struct net_device *vf_netdev)
+ {
+ 	struct net_device *ndev;
+ 	struct net_device_context *net_device_ctx;
+ 	struct netvsc_device *netvsc_dev;
+ 	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
+ 
+ 	if (eth_ops == NULL || eth_ops == &ethtool_ops)
+ 		return NOTIFY_DONE;
+ 
+ 	/*
+ 	 * We will use the MAC address to locate the synthetic interface to
+ 	 * associate with the VF interface. If we don't find a matching
+ 	 * synthetic interface, move on.
+ 	 */
+ 	ndev = get_netvsc_net_device(vf_netdev->dev_addr);
+ 	if (!ndev)
+ 		return NOTIFY_DONE;
+ 
+ 	net_device_ctx = netdev_priv(ndev);
+ 	netvsc_dev = net_device_ctx->nvdev;
+ 	if (netvsc_dev == NULL)
+ 		return NOTIFY_DONE;
+ 
+ 	netdev_info(ndev, "VF registering: %s\n", vf_netdev->name);
+ 	/*
+ 	 * Take a reference on the module.
+ 	 */
+ 	try_module_get(THIS_MODULE);
+ 	net_device_ctx->vf_netdev = vf_netdev;
+ 	return NOTIFY_OK;
+ }
+ 
+ 
+ static int netvsc_vf_up(struct net_device *vf_netdev)
+ {
+ 	struct net_device *ndev;
+ 	struct netvsc_device *netvsc_dev;
+ 	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
+ 	struct net_device_context *net_device_ctx;
+ 
+ 	if (eth_ops == &ethtool_ops)
+ 		return NOTIFY_DONE;
+ 
+ 	ndev = get_netvsc_net_device(vf_netdev->dev_addr);
+ 	if (!ndev)
+ 		return NOTIFY_DONE;
+ 
+ 	net_device_ctx = netdev_priv(ndev);
+ 	netvsc_dev = net_device_ctx->nvdev;
+ 
+ 	if (!netvsc_dev || !net_device_ctx->vf_netdev)
+ 		return NOTIFY_DONE;
+ 
+ 	netdev_info(ndev, "VF up: %s\n", vf_netdev->name);
+ 	net_device_ctx->vf_inject = true;
+ 
+ 	/*
+ 	 * Open the device before switching data path.
+ 	 */
+ 	rndis_filter_open(netvsc_dev);
+ 
+ 	/*
+ 	 * notify the host to switch the data path.
+ 	 */
+ 	netvsc_switch_datapath(ndev, true);
+ 	netdev_info(ndev, "Data path switched to VF: %s\n", vf_netdev->name);
+ 
+ 	netif_carrier_off(ndev);
+ 
+ 	/*
+ 	 * Now notify peers. We are scheduling work to
+ 	 * notify peers; take a reference to prevent
+ 	 * the VF interface from vanishing.
+ 	 */
+ 	atomic_inc(&net_device_ctx->vf_use_cnt);
+ 	net_device_ctx->gwrk.netdev = vf_netdev;
+ 	net_device_ctx->gwrk.net_device_ctx = net_device_ctx;
+ 	schedule_work(&net_device_ctx->gwrk.dwrk);
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ 
+ static int netvsc_vf_down(struct net_device *vf_netdev)
+ {
+ 	struct net_device *ndev;
+ 	struct netvsc_device *netvsc_dev;
+ 	struct net_device_context *net_device_ctx;
+ 	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
+ 
+ 	if (eth_ops == &ethtool_ops)
+ 		return NOTIFY_DONE;
+ 
+ 	ndev = get_netvsc_net_device(vf_netdev->dev_addr);
+ 	if (!ndev)
+ 		return NOTIFY_DONE;
+ 
+ 	net_device_ctx = netdev_priv(ndev);
+ 	netvsc_dev = net_device_ctx->nvdev;
+ 
+ 	if (!netvsc_dev || !net_device_ctx->vf_netdev)
+ 		return NOTIFY_DONE;
+ 
+ 	netdev_info(ndev, "VF down: %s\n", vf_netdev->name);
+ 	net_device_ctx->vf_inject = false;
+ 	/*
+ 	 * Wait for currently active users to
+ 	 * drain out.
+ 	 */
+ 
+ 	while (atomic_read(&net_device_ctx->vf_use_cnt) != 0)
+ 		udelay(50);
+ 	netvsc_switch_datapath(ndev, false);
+ 	netdev_info(ndev, "Data path switched from VF: %s\n", vf_netdev->name);
+ 	rndis_filter_close(netvsc_dev);
+ 	netif_carrier_on(ndev);
+ 	/*
+ 	 * Notify peers.
+ 	 */
+ 	atomic_inc(&net_device_ctx->vf_use_cnt);
+ 	net_device_ctx->gwrk.netdev = ndev;
+ 	net_device_ctx->gwrk.net_device_ctx = net_device_ctx;
+ 	schedule_work(&net_device_ctx->gwrk.dwrk);
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ 
+ static int netvsc_unregister_vf(struct net_device *vf_netdev)
+ {
+ 	struct net_device *ndev;
+ 	struct netvsc_device *netvsc_dev;
+ 	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
+ 	struct net_device_context *net_device_ctx;
+ 
+ 	if (eth_ops == &ethtool_ops)
+ 		return NOTIFY_DONE;
+ 
+ 	ndev = get_netvsc_net_device(vf_netdev->dev_addr);
+ 	if (!ndev)
+ 		return NOTIFY_DONE;
+ 
+ 	net_device_ctx = netdev_priv(ndev);
+ 	netvsc_dev = net_device_ctx->nvdev;
+ 	if (netvsc_dev == NULL)
+ 		return NOTIFY_DONE;
+ 	netdev_info(ndev, "VF unregistering: %s\n", vf_netdev->name);
+ 
+ 	net_device_ctx->vf_netdev = NULL;
+ 	module_put(THIS_MODULE);
+ 	return NOTIFY_OK;
+ }
++>>>>>>> f9a7da9130ef (hv_netvsc: don't lose VF information)
  
  static int netvsc_probe(struct hv_device *dev,
  			const struct hv_vmbus_device_id *dev_id)
@@@ -878,18 -1355,44 +1147,22 @@@
  
  	net_device_ctx = netdev_priv(net);
  	net_device_ctx->device_ctx = dev;
 -	net_device_ctx->msg_enable = netif_msg_init(debug, default_msg);
 -	if (netif_msg_probe(net_device_ctx))
 -		netdev_dbg(net, "netvsc msg_enable: %d\n",
 -			   net_device_ctx->msg_enable);
 -
 -	net_device_ctx->tx_stats = netdev_alloc_pcpu_stats(struct netvsc_stats);
 -	if (!net_device_ctx->tx_stats) {
 -		free_netdev(net);
 -		return -ENOMEM;
 -	}
 -	net_device_ctx->rx_stats = netdev_alloc_pcpu_stats(struct netvsc_stats);
 -	if (!net_device_ctx->rx_stats) {
 -		free_percpu(net_device_ctx->tx_stats);
 -		free_netdev(net);
 -		return -ENOMEM;
 -	}
 -
  	hv_set_drvdata(dev, net);
 -
 -	net_device_ctx->start_remove = false;
 -
  	INIT_DELAYED_WORK(&net_device_ctx->dwork, netvsc_link_change);
  	INIT_WORK(&net_device_ctx->work, do_set_multicast);
 -	INIT_WORK(&net_device_ctx->gwrk.dwrk, netvsc_notify_peers);
 -
 -	spin_lock_init(&net_device_ctx->lock);
 -	INIT_LIST_HEAD(&net_device_ctx->reconfig_events);
  
+ 	atomic_set(&net_device_ctx->vf_use_cnt, 0);
+ 	net_device_ctx->vf_netdev = NULL;
+ 	net_device_ctx->vf_inject = false;
+ 
  	net->netdev_ops = &device_ops;
  
 -	net->hw_features = NETVSC_HW_FEATURES;
 -	net->features = NETVSC_HW_FEATURES | NETIF_F_HW_VLAN_CTAG_TX;
 +	net->hw_features = NETIF_F_RXCSUM | NETIF_F_SG | NETIF_F_IP_CSUM |
 +				NETIF_F_TSO;
 +	net->features = NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_SG | NETIF_F_RXCSUM |
 +			NETIF_F_IP_CSUM | NETIF_F_TSO;
  
 -	net->ethtool_ops = &ethtool_ops;
 +	SET_ETHTOOL_OPS(net, &ethtool_ops);
  	SET_NETDEV_DEV(net, &dev->device);
  
  	/* We always need headroom for rndis header */
* Unmerged path drivers/net/hyperv/hyperv_net.h
* Unmerged path drivers/net/hyperv/netvsc.c
* Unmerged path drivers/net/hyperv/netvsc_drv.c
