ACPI / OF: Rename of_node() and acpi_node() to to_of_node() and to_acpi_node()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Sverdlin <alexander.sverdlin@gmail.com>
commit c181fb3e723351e2f7a1f76b6c0627a4b8ad1723
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c181fb3e.failed

Commit 8a0662d9 introduced of_node and acpi_node symbols in global namespace
but there were already ~63 of_node local variables or function parameters
(no single acpi_node though, but anyway).

After debugging undefined but used of_node local varible (which turned out
to reference static function of_node() instead) it became clear that the names
for the functions are too short and too generic for global scope.

	Signed-off-by: Alexander Sverdlin <alexander.sverdlin@gmail.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit c181fb3e723351e2f7a1f76b6c0627a4b8ad1723)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/property.c
#	drivers/gpio/gpiolib.c
#	drivers/leds/leds-gpio.c
#	include/acpi/acpi_bus.h
#	include/linux/acpi.h
#	include/linux/of.h
diff --cc drivers/base/property.c
index 6a94ef6e83c9,dfd4de69b67b..000000000000
--- a/drivers/base/property.c
+++ b/drivers/base/property.c
@@@ -31,16 -120,21 +31,30 @@@ bool device_property_present(struct dev
  }
  EXPORT_SYMBOL_GPL(device_property_present);
  
++<<<<<<< HEAD
 +#define OF_DEV_PROP_READ_ARRAY(node, propname, type, val, nval) \
 +	(val) ? of_property_read_##type##_array((node), (propname), (val), (nval)) \
 +	      : of_property_count_elems_of_size((node), (propname), sizeof(type))
++=======
+ /**
+  * fwnode_property_present - check if a property of a firmware node is present
+  * @fwnode: Firmware node whose property to check
+  * @propname: Name of the property
+  */
+ bool fwnode_property_present(struct fwnode_handle *fwnode, const char *propname)
+ {
+ 	if (is_of_node(fwnode))
+ 		return of_property_read_bool(to_of_node(fwnode), propname);
+ 	else if (is_acpi_node(fwnode))
+ 		return !acpi_dev_prop_get(to_acpi_node(fwnode), propname, NULL);
++>>>>>>> c181fb3e7233 (ACPI / OF: Rename of_node() and acpi_node() to to_of_node() and to_acpi_node())
  
 -	return !!pset_prop_get(to_pset(fwnode), propname);
 -}
 -EXPORT_SYMBOL_GPL(fwnode_property_present);
 +#define DEV_PROP_READ_ARRAY(_dev_, _propname_, _type_, _proptype_, _val_, _nval_) \
 +	IS_ENABLED(CONFIG_OF) && _dev_->of_node ? \
 +		(OF_DEV_PROP_READ_ARRAY(_dev_->of_node, _propname_, _type_, \
 +					_val_, _nval_)) : \
 +		acpi_dev_prop_read(ACPI_COMPANION(_dev_), _propname_, \
 +				   _proptype_, _val_, _nval_)
  
  /**
   * device_property_read_u8_array - return a u8 array property of a device
@@@ -177,9 -273,249 +191,255 @@@ EXPORT_SYMBOL_GPL(device_property_read_
  int device_property_read_string(struct device *dev, const char *propname,
  				const char **val)
  {
 -	return fwnode_property_read_string(dev_fwnode(dev), propname, val);
 +	return IS_ENABLED(CONFIG_OF) && dev->of_node ?
 +		of_property_read_string(dev->of_node, propname, val) :
 +		acpi_dev_prop_read(ACPI_COMPANION(dev), propname,
 +				   DEV_PROP_STRING, val, 1);
  }
  EXPORT_SYMBOL_GPL(device_property_read_string);
++<<<<<<< HEAD
++=======
+ 
+ #define OF_DEV_PROP_READ_ARRAY(node, propname, type, val, nval) \
+ 	(val) ? of_property_read_##type##_array((node), (propname), (val), (nval)) \
+ 	      : of_property_count_elems_of_size((node), (propname), sizeof(type))
+ 
+ #define FWNODE_PROP_READ_ARRAY(_fwnode_, _propname_, _type_, _proptype_, _val_, _nval_) \
+ ({ \
+ 	int _ret_; \
+ 	if (is_of_node(_fwnode_)) \
+ 		_ret_ = OF_DEV_PROP_READ_ARRAY(to_of_node(_fwnode_), _propname_, \
+ 					       _type_, _val_, _nval_); \
+ 	else if (is_acpi_node(_fwnode_)) \
+ 		_ret_ = acpi_dev_prop_read(to_acpi_node(_fwnode_), _propname_, \
+ 					   _proptype_, _val_, _nval_); \
+ 	else \
+ 		_ret_ = pset_prop_read_array(to_pset(_fwnode_), _propname_, \
+ 					     _proptype_, _val_, _nval_); \
+ 	_ret_; \
+ })
+ 
+ /**
+  * fwnode_property_read_u8_array - return a u8 array property of firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u8 properties with @propname from @fwnode and stores them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u8_array(struct fwnode_handle *fwnode,
+ 				  const char *propname, u8 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u8, DEV_PROP_U8,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u8_array);
+ 
+ /**
+  * fwnode_property_read_u16_array - return a u16 array property of firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u16 properties with @propname from @fwnode and store them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u16_array(struct fwnode_handle *fwnode,
+ 				   const char *propname, u16 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u16, DEV_PROP_U16,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u16_array);
+ 
+ /**
+  * fwnode_property_read_u32_array - return a u32 array property of firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u32 properties with @propname from @fwnode store them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u32_array(struct fwnode_handle *fwnode,
+ 				   const char *propname, u32 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u32, DEV_PROP_U32,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u32_array);
+ 
+ /**
+  * fwnode_property_read_u64_array - return a u64 array property firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u64 properties with @propname from @fwnode and store them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u64_array(struct fwnode_handle *fwnode,
+ 				   const char *propname, u64 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u64, DEV_PROP_U64,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u64_array);
+ 
+ /**
+  * fwnode_property_read_string_array - return string array property of a node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an string list property @propname from the given firmware node and store
+  * them to @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of strings,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_string_array(struct fwnode_handle *fwnode,
+ 				      const char *propname, const char **val,
+ 				      size_t nval)
+ {
+ 	if (is_of_node(fwnode))
+ 		return val ?
+ 			of_property_read_string_array(to_of_node(fwnode),
+ 						      propname, val, nval) :
+ 			of_property_count_strings(to_of_node(fwnode), propname);
+ 	else if (is_acpi_node(fwnode))
+ 		return acpi_dev_prop_read(to_acpi_node(fwnode), propname,
+ 					  DEV_PROP_STRING, val, nval);
+ 
+ 	return pset_prop_read_array(to_pset(fwnode), propname,
+ 				    DEV_PROP_STRING, val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_string_array);
+ 
+ /**
+  * fwnode_property_read_string - return a string property of a firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The value is stored here
+  *
+  * Read property @propname from the given firmware node and store the value into
+  * @val if found.  The value is checked to be a string.
+  *
+  * Return: %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO or %-EILSEQ if the property is not a string,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_string(struct fwnode_handle *fwnode,
+ 				const char *propname, const char **val)
+ {
+ 	if (is_of_node(fwnode))
+ 		return of_property_read_string(to_of_node(fwnode), propname, val);
+ 	else if (is_acpi_node(fwnode))
+ 		return acpi_dev_prop_read(to_acpi_node(fwnode), propname,
+ 					  DEV_PROP_STRING, val, 1);
+ 
+ 	return -ENXIO;
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_string);
+ 
+ /**
+  * device_get_next_child_node - Return the next child node handle for a device
+  * @dev: Device to find the next child node for.
+  * @child: Handle to one of the device's child nodes or a null handle.
+  */
+ struct fwnode_handle *device_get_next_child_node(struct device *dev,
+ 						 struct fwnode_handle *child)
+ {
+ 	if (IS_ENABLED(CONFIG_OF) && dev->of_node) {
+ 		struct device_node *node;
+ 
+ 		node = of_get_next_available_child(dev->of_node, to_of_node(child));
+ 		if (node)
+ 			return &node->fwnode;
+ 	} else if (IS_ENABLED(CONFIG_ACPI)) {
+ 		struct acpi_device *node;
+ 
+ 		node = acpi_get_next_child(dev, to_acpi_node(child));
+ 		if (node)
+ 			return acpi_fwnode_handle(node);
+ 	}
+ 	return NULL;
+ }
+ EXPORT_SYMBOL_GPL(device_get_next_child_node);
+ 
+ /**
+  * fwnode_handle_put - Drop reference to a device node
+  * @fwnode: Pointer to the device node to drop the reference to.
+  *
+  * This has to be used when terminating device_for_each_child_node() iteration
+  * with break or return to prevent stale device node references from being left
+  * behind.
+  */
+ void fwnode_handle_put(struct fwnode_handle *fwnode)
+ {
+ 	if (is_of_node(fwnode))
+ 		of_node_put(to_of_node(fwnode));
+ }
+ EXPORT_SYMBOL_GPL(fwnode_handle_put);
+ 
+ /**
+  * device_get_child_node_count - return the number of child nodes for device
+  * @dev: Device to cound the child nodes for
+  */
+ unsigned int device_get_child_node_count(struct device *dev)
+ {
+ 	struct fwnode_handle *child;
+ 	unsigned int count = 0;
+ 
+ 	device_for_each_child_node(dev, child)
+ 		count++;
+ 
+ 	return count;
+ }
+ EXPORT_SYMBOL_GPL(device_get_child_node_count);
++>>>>>>> c181fb3e7233 (ACPI / OF: Rename of_node() and acpi_node() to to_of_node() and to_acpi_node())
diff --cc drivers/gpio/gpiolib.c
index 9b50ed619d38,5d8b2b35e2a2..000000000000
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@@ -2460,7 -2002,66 +2460,70 @@@ struct gpio_desc *__must_check gpiod_ge
  	if (status < 0)
  		return ERR_PTR(status);
  
++<<<<<<< HEAD
 +	if (flags & GPIOF_ACTIVE_LOW)
++=======
+ 	status = gpiod_configure_flags(desc, con_id, lookupflags, flags);
+ 	if (status < 0) {
+ 		dev_dbg(dev, "setup of GPIO %s failed\n", con_id);
+ 		gpiod_put(desc);
+ 		return ERR_PTR(status);
+ 	}
+ 
+ 	return desc;
+ }
+ EXPORT_SYMBOL_GPL(__gpiod_get_index);
+ 
+ /**
+  * fwnode_get_named_gpiod - obtain a GPIO from firmware node
+  * @fwnode:	handle of the firmware node
+  * @propname:	name of the firmware property representing the GPIO
+  *
+  * This function can be used for drivers that get their configuration
+  * from firmware.
+  *
+  * Function properly finds the corresponding GPIO using whatever is the
+  * underlying firmware interface and then makes sure that the GPIO
+  * descriptor is requested before it is returned to the caller.
+  *
+  * In case of error an ERR_PTR() is returned.
+  */
+ struct gpio_desc *fwnode_get_named_gpiod(struct fwnode_handle *fwnode,
+ 					 const char *propname)
+ {
+ 	struct gpio_desc *desc = ERR_PTR(-ENODEV);
+ 	bool active_low = false;
+ 	int ret;
+ 
+ 	if (!fwnode)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	if (is_of_node(fwnode)) {
+ 		enum of_gpio_flags flags;
+ 
+ 		desc = of_get_named_gpiod_flags(to_of_node(fwnode), propname, 0,
+ 						&flags);
+ 		if (!IS_ERR(desc))
+ 			active_low = flags & OF_GPIO_ACTIVE_LOW;
+ 	} else if (is_acpi_node(fwnode)) {
+ 		struct acpi_gpio_info info;
+ 
+ 		desc = acpi_get_gpiod_by_index(to_acpi_node(fwnode), propname, 0,
+ 					       &info);
+ 		if (!IS_ERR(desc))
+ 			active_low = info.active_low;
+ 	}
+ 
+ 	if (IS_ERR(desc))
+ 		return desc;
+ 
+ 	ret = gpiod_request(desc, NULL);
+ 	if (ret)
+ 		return ERR_PTR(ret);
+ 
+ 	/* Only value flag can be set from both DT and ACPI is active_low */
+ 	if (active_low)
++>>>>>>> c181fb3e7233 (ACPI / OF: Rename of_node() and acpi_node() to to_of_node() and to_acpi_node())
  		set_bit(FLAG_ACTIVE_LOW, &desc->flags);
  
  	return desc;
diff --cc drivers/leds/leds-gpio.c
index b02b679abf31,d2d54d62afee..000000000000
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@@ -184,18 -180,32 +184,43 @@@ static struct gpio_leds_priv *gpio_leds
  	if (!priv)
  		return ERR_PTR(-ENOMEM);
  
 -	device_for_each_child_node(dev, child) {
 +	for_each_child_of_node(np, child) {
  		struct gpio_led led = {};
 -		const char *state = NULL;
 -
 +		enum of_gpio_flags flags;
 +		const char *state;
 +
++<<<<<<< HEAD
 +		led.gpio = of_get_gpio_flags(child, 0, &flags);
 +		led.active_low = flags & OF_GPIO_ACTIVE_LOW;
 +		led.name = of_get_property(child, "label", NULL) ? : child->name;
 +		led.default_trigger =
 +			of_get_property(child, "linux,default-trigger", NULL);
 +		state = of_get_property(child, "default-state", NULL);
 +		if (state) {
++=======
+ 		led.gpiod = devm_get_gpiod_from_child(dev, NULL, child);
+ 		if (IS_ERR(led.gpiod)) {
+ 			fwnode_handle_put(child);
+ 			ret = PTR_ERR(led.gpiod);
+ 			goto err;
+ 		}
+ 
+ 		np = to_of_node(child);
+ 
+ 		if (fwnode_property_present(child, "label")) {
+ 			fwnode_property_read_string(child, "label", &led.name);
+ 		} else {
+ 			if (IS_ENABLED(CONFIG_OF) && !led.name && np)
+ 				led.name = np->name;
+ 			if (!led.name)
+ 				return ERR_PTR(-EINVAL);
+ 		}
+ 		fwnode_property_read_string(child, "linux,default-trigger",
+ 					    &led.default_trigger);
+ 
+ 		if (!fwnode_property_read_string(child, "default-state",
+ 						 &state)) {
++>>>>>>> c181fb3e7233 (ACPI / OF: Rename of_node() and acpi_node() to to_of_node() and to_acpi_node())
  			if (!strcmp(state, "keep"))
  				led.default_state = LEDS_GPIO_DEFSTATE_KEEP;
  			else if (!strcmp(state, "on"))
diff --cc include/acpi/acpi_bus.h
index 8bcd3caab412,1224be8184fc..000000000000
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@@ -363,6 -380,22 +363,25 @@@ struct acpi_device 
  	void (*remove)(struct acpi_device *);
  };
  
++<<<<<<< HEAD
++=======
+ static inline bool is_acpi_node(struct fwnode_handle *fwnode)
+ {
+ 	return fwnode && fwnode->type == FWNODE_ACPI;
+ }
+ 
+ static inline struct acpi_device *to_acpi_node(struct fwnode_handle *fwnode)
+ {
+ 	return is_acpi_node(fwnode) ?
+ 		container_of(fwnode, struct acpi_device, fwnode) : NULL;
+ }
+ 
+ static inline struct fwnode_handle *acpi_fwnode_handle(struct acpi_device *adev)
+ {
+ 	return &adev->fwnode;
+ }
+ 
++>>>>>>> c181fb3e7233 (ACPI / OF: Rename of_node() and acpi_node() to to_of_node() and to_acpi_node())
  static inline void *acpi_driver_data(struct acpi_device *d)
  {
  	return d->driver_data;
diff --cc include/linux/acpi.h
index 364918faf44f,ec3c98ed9dca..000000000000
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@@ -50,10 -53,16 +50,16 @@@ static inline acpi_handle acpi_device_h
  	return adev ? adev->handle : NULL;
  }
  
++<<<<<<< HEAD
 +#define ACPI_COMPANION(dev)		((dev)->acpi_node.companion)
 +#define ACPI_COMPANION_SET(dev, adev)	ACPI_COMPANION(dev) = (adev)
++=======
+ #define ACPI_COMPANION(dev)		to_acpi_node((dev)->fwnode)
+ #define ACPI_COMPANION_SET(dev, adev)	set_primary_fwnode(dev, (adev) ? \
+ 	acpi_fwnode_handle(adev) : NULL)
++>>>>>>> c181fb3e7233 (ACPI / OF: Rename of_node() and acpi_node() to to_of_node() and to_acpi_node())
  #define ACPI_HANDLE(dev)		acpi_device_handle(ACPI_COMPANION(dev))
  
 -static inline bool has_acpi_companion(struct device *dev)
 -{
 -	return is_acpi_node(dev->fwnode);
 -}
 -
  static inline void acpi_preset_companion(struct device *dev,
  					 struct acpi_device *parent, u64 addr)
  {
@@@ -426,6 -466,33 +432,36 @@@ static inline bool acpi_driver_match_de
  #define ACPI_COMPANION_SET(dev, adev)	do { } while (0)
  #define ACPI_HANDLE(dev)		(NULL)
  
++<<<<<<< HEAD
++=======
+ struct fwnode_handle;
+ 
+ static inline bool is_acpi_node(struct fwnode_handle *fwnode)
+ {
+ 	return false;
+ }
+ 
+ static inline struct acpi_device *to_acpi_node(struct fwnode_handle *fwnode)
+ {
+ 	return NULL;
+ }
+ 
+ static inline struct fwnode_handle *acpi_fwnode_handle(struct acpi_device *adev)
+ {
+ 	return NULL;
+ }
+ 
+ static inline bool has_acpi_companion(struct device *dev)
+ {
+ 	return false;
+ }
+ 
+ static inline const char *acpi_dev_name(struct acpi_device *adev)
+ {
+ 	return NULL;
+ }
+ 
++>>>>>>> c181fb3e7233 (ACPI / OF: Rename of_node() and acpi_node() to to_of_node() and to_acpi_node())
  static inline void acpi_early_init(void) { }
  
  static inline int early_acpi_boot_init(void)
diff --cc include/linux/of.h
index 74d849e00248,f05fdcea4e66..000000000000
--- a/include/linux/of.h
+++ b/include/linux/of.h
@@@ -112,17 -113,29 +112,33 @@@ static inline struct device_node *of_no
  static inline void of_node_put(struct device_node *node) { }
  #endif /* !CONFIG_OF_DYNAMIC */
  
 +#ifdef CONFIG_OF
 +
  /* Pointer for first entry in chain of all nodes. */
 -extern struct device_node *of_root;
 +extern struct device_node *of_allnodes;
  extern struct device_node *of_chosen;
  extern struct device_node *of_aliases;
 -extern struct device_node *of_stdout;
  extern raw_spinlock_t devtree_lock;
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_OF
+ void of_core_init(void);
+ 
+ static inline bool is_of_node(struct fwnode_handle *fwnode)
+ {
+ 	return fwnode && fwnode->type == FWNODE_OF;
+ }
+ 
+ static inline struct device_node *to_of_node(struct fwnode_handle *fwnode)
+ {
+ 	return fwnode ? container_of(fwnode, struct device_node, fwnode) : NULL;
+ }
+ 
++>>>>>>> c181fb3e7233 (ACPI / OF: Rename of_node() and acpi_node() to to_of_node() and to_acpi_node())
  static inline bool of_have_populated_dt(void)
  {
 -	return of_root != NULL;
 +	return of_allnodes != NULL;
  }
  
  static inline bool of_node_is_root(const struct device_node *node)
@@@ -392,7 -378,21 +408,25 @@@ const char *of_prop_next_string(struct 
  
  #else /* CONFIG_OF */
  
++<<<<<<< HEAD
 +static inline const char* of_node_full_name(struct device_node *np)
++=======
+ static inline void of_core_init(void)
+ {
+ }
+ 
+ static inline bool is_of_node(struct fwnode_handle *fwnode)
+ {
+ 	return false;
+ }
+ 
+ static inline struct device_node *to_of_node(struct fwnode_handle *fwnode)
+ {
+ 	return NULL;
+ }
+ 
+ static inline const char* of_node_full_name(const struct device_node *np)
++>>>>>>> c181fb3e7233 (ACPI / OF: Rename of_node() and acpi_node() to to_of_node() and to_acpi_node())
  {
  	return "<no-node>";
  }
* Unmerged path drivers/base/property.c
* Unmerged path drivers/gpio/gpiolib.c
* Unmerged path drivers/leds/leds-gpio.c
* Unmerged path include/acpi/acpi_bus.h
* Unmerged path include/linux/acpi.h
* Unmerged path include/linux/of.h
