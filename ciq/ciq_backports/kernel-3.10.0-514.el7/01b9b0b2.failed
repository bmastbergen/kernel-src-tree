cifs_dbg() outputs an uninitialized buffer in cifs_readdir()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vasily Averin <vvs@virtuozzo.com>
commit 01b9b0b28626db4a47d7f48744d70abca9914ef1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/01b9b0b2.failed

In some cases tmp_bug can be not filled in cifs_filldir and stay uninitialized,
therefore its printk with "%s" modifier can leak content of kernelspace memory.
If old content of this buffer does not contain '\0' access bejond end of
allocated object can crash the host.

	Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
	Signed-off-by: Steve French <sfrench@localhost.localdomain>
CC: Stable <stable@vger.kernel.org>
(cherry picked from commit 01b9b0b28626db4a47d7f48744d70abca9914ef1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/readdir.c
diff --cc fs/cifs/readdir.c
index 8e0548dbcdd4,b30a4a6d98a0..000000000000
--- a/fs/cifs/readdir.c
+++ b/fs/cifs/readdir.c
@@@ -797,103 -792,83 +797,115 @@@ int cifs_readdir(struct file *file, voi
  			goto rddir2_exit;
  	}
  
 -	if (!dir_emit_dots(file, ctx))
 -		goto rddir2_exit;
 -
 -	/* 1) If search is active,
 -		is in current search buffer?
 -		if it before then restart search
 -		if after then keep searching till find it */
 +	switch ((int) file->f_pos) {
 +	case 0:
 +		if (filldir(direntry, ".", 1, file->f_pos,
 +		     file_inode(file)->i_ino, DT_DIR) < 0) {
 +			cifs_dbg(VFS, "Filldir for current dir failed\n");
 +			rc = -ENOMEM;
 +			break;
 +		}
 +		file->f_pos++;
 +	case 1:
 +		if (filldir(direntry, "..", 2, file->f_pos,
 +		     parent_ino(file->f_path.dentry), DT_DIR) < 0) {
 +			cifs_dbg(VFS, "Filldir for parent dir failed\n");
 +			rc = -ENOMEM;
 +			break;
 +		}
 +		file->f_pos++;
 +	default:
 +		/* 1) If search is active,
 +			is in current search buffer?
 +			if it before then restart search
 +			if after then keep searching till find it */
 +
 +		if (file->private_data == NULL) {
 +			rc = -EINVAL;
 +			free_xid(xid);
 +			return rc;
 +		}
 +		cifsFile = file->private_data;
 +		if (cifsFile->srch_inf.endOfSearch) {
 +			if (cifsFile->srch_inf.emptyDir) {
 +				cifs_dbg(FYI, "End of search, empty dir\n");
 +				rc = 0;
 +				break;
 +			}
 +		} /* else {
 +			cifsFile->invalidHandle = true;
 +			tcon->ses->server->close(xid, tcon, &cifsFile->fid);
 +		} */
  
 -	cifsFile = file->private_data;
 -	if (cifsFile->srch_inf.endOfSearch) {
 -		if (cifsFile->srch_inf.emptyDir) {
 -			cifs_dbg(FYI, "End of search, empty dir\n");
 -			rc = 0;
 +		tcon = tlink_tcon(cifsFile->tlink);
 +		rc = find_cifs_entry(xid, tcon, file, &current_entry,
 +				     &num_to_fill);
 +		if (rc) {
 +			cifs_dbg(FYI, "fce error %d\n", rc);
 +			goto rddir2_exit;
 +		} else if (current_entry != NULL) {
 +			cifs_dbg(FYI, "entry %lld found\n", file->f_pos);
 +		} else {
 +			cifs_dbg(FYI, "could not find entry\n");
  			goto rddir2_exit;
  		}
 -	} /* else {
 -		cifsFile->invalidHandle = true;
 -		tcon->ses->server->close(xid, tcon, &cifsFile->fid);
 -	} */
 -
 -	tcon = tlink_tcon(cifsFile->tlink);
 -	rc = find_cifs_entry(xid, tcon, ctx->pos, file, &current_entry,
 -			     &num_to_fill);
 -	if (rc) {
 -		cifs_dbg(FYI, "fce error %d\n", rc);
 -		goto rddir2_exit;
 -	} else if (current_entry != NULL) {
 -		cifs_dbg(FYI, "entry %lld found\n", ctx->pos);
 -	} else {
 -		cifs_dbg(FYI, "could not find entry\n");
 -		goto rddir2_exit;
 -	}
 -	cifs_dbg(FYI, "loop through %d times filling dir for net buf %p\n",
 -		 num_to_fill, cifsFile->srch_inf.ntwrk_buf_start);
 -	max_len = tcon->ses->server->ops->calc_smb_size(
 -			cifsFile->srch_inf.ntwrk_buf_start);
 -	end_of_smb = cifsFile->srch_inf.ntwrk_buf_start + max_len;
 -
 -	tmp_buf = kmalloc(UNICODE_NAME_MAX, GFP_KERNEL);
 -	if (tmp_buf == NULL) {
 -		rc = -ENOMEM;
 -		goto rddir2_exit;
 -	}
 -
 -	for (i = 0; i < num_to_fill; i++) {
 -		if (current_entry == NULL) {
 -			/* evaluate whether this case is an error */
 -			cifs_dbg(VFS, "past SMB end,  num to fill %d i %d\n",
 -				 num_to_fill, i);
 +		cifs_dbg(FYI, "loop through %d times filling dir for net buf %p\n",
 +			 num_to_fill, cifsFile->srch_inf.ntwrk_buf_start);
 +		max_len = tcon->ses->server->ops->calc_smb_size(
 +				cifsFile->srch_inf.ntwrk_buf_start);
 +		end_of_smb = cifsFile->srch_inf.ntwrk_buf_start + max_len;
 +
 +		tmp_buf = kmalloc(UNICODE_NAME_MAX, GFP_KERNEL);
 +		if (tmp_buf == NULL) {
 +			rc = -ENOMEM;
  			break;
  		}
++<<<<<<< HEAD
 +
 +		for (i = 0; (i < num_to_fill) && (rc == 0); i++) {
 +			if (current_entry == NULL) {
 +				/* evaluate whether this case is an error */
 +				cifs_dbg(VFS, "past SMB end,  num to fill %d i %d\n",
 +					 num_to_fill, i);
 +				break;
 +			}
 +			/*
 +			 * if buggy server returns . and .. late do we want to
 +			 * check for that here?
 +			 */
 +			rc = cifs_filldir(current_entry, file, filldir,
 +					  direntry, tmp_buf, max_len);
 +			if (rc == -EOVERFLOW) {
++=======
+ 		/*
+ 		 * if buggy server returns . and .. late do we want to
+ 		 * check for that here?
+ 		 */
+ 		*tmp_buf = 0;
+ 		rc = cifs_filldir(current_entry, file, ctx,
+ 				  tmp_buf, max_len);
+ 		if (rc) {
+ 			if (rc > 0)
++>>>>>>> 01b9b0b28626 (cifs_dbg() outputs an uninitialized buffer in cifs_readdir())
  				rc = 0;
 -			break;
 -		}
 +				break;
 +			}
  
 -		ctx->pos++;
 -		if (ctx->pos ==
 -			cifsFile->srch_inf.index_of_last_entry) {
 -			cifs_dbg(FYI, "last entry in buf at pos %lld %s\n",
 -				 ctx->pos, tmp_buf);
 -			cifs_save_resume_key(current_entry, cifsFile);
 -			break;
 -		} else
 -			current_entry =
 -				nxt_dir_entry(current_entry, end_of_smb,
 -					cifsFile->srch_inf.info_level);
 -	}
 -	kfree(tmp_buf);
 +			file->f_pos++;
 +			if (file->f_pos ==
 +				cifsFile->srch_inf.index_of_last_entry) {
 +				cifs_dbg(FYI, "last entry in buf at pos %lld %s\n",
 +					 file->f_pos, tmp_buf);
 +				cifs_save_resume_key(current_entry, cifsFile);
 +				break;
 +			} else
 +				current_entry =
 +					nxt_dir_entry(current_entry, end_of_smb,
 +						cifsFile->srch_inf.info_level);
 +		}
 +		kfree(tmp_buf);
 +		break;
 +	} /* end switch */
  
  rddir2_exit:
  	free_xid(xid);
* Unmerged path fs/cifs/readdir.c
