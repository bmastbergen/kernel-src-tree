net/mlx5e: Add ethtool support for dump module EEPROM

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [include] mlx5e: Add ethtool support for dump module EEPROM (kamal heib) [1275159 1296272 1296405 1298421 1298422 1298423 1298424 1298425]
Rebuild_FUZZ: 96.08%
commit-author Gal Pressman <galp@mellanox.com>
commit bb64143eee8c036a89b31daa4e9bf8360a8bded1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bb64143e.failed

Add query MCIA, PMLP registers infrastructure and commands.
Add ethtool support for get_module_info() and get_module_eeprom()
callbacks.

	Signed-off-by: Gal Pressman <galp@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bb64143eee8c036a89b31daa4e9bf8360a8bded1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	include/linux/mlx5/driver.h
#	include/linux/mlx5/port.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index 72a2892f3570,0518c8658507..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -858,6 -983,260 +858,263 @@@ static int mlx5e_set_pauseparam(struct 
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int mlx5e_get_ts_info(struct net_device *dev,
+ 			     struct ethtool_ts_info *info)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 	int ret;
+ 
+ 	ret = ethtool_op_get_ts_info(dev, info);
+ 	if (ret)
+ 		return ret;
+ 
+ 	info->phc_index = priv->tstamp.ptp ?
+ 			  ptp_clock_index(priv->tstamp.ptp) : -1;
+ 
+ 	if (!MLX5_CAP_GEN(priv->mdev, device_frequency_khz))
+ 		return 0;
+ 
+ 	info->so_timestamping |= SOF_TIMESTAMPING_TX_HARDWARE |
+ 				 SOF_TIMESTAMPING_RX_HARDWARE |
+ 				 SOF_TIMESTAMPING_RAW_HARDWARE;
+ 
+ 	info->tx_types = (BIT(1) << HWTSTAMP_TX_OFF) |
+ 			 (BIT(1) << HWTSTAMP_TX_ON);
+ 
+ 	info->rx_filters = (BIT(1) << HWTSTAMP_FILTER_NONE) |
+ 			   (BIT(1) << HWTSTAMP_FILTER_ALL);
+ 
+ 	return 0;
+ }
+ 
+ static __u32 mlx5e_get_wol_supported(struct mlx5_core_dev *mdev)
+ {
+ 	__u32 ret = 0;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_g))
+ 		ret |= WAKE_MAGIC;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_s))
+ 		ret |= WAKE_MAGICSECURE;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_a))
+ 		ret |= WAKE_ARP;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_b))
+ 		ret |= WAKE_BCAST;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_m))
+ 		ret |= WAKE_MCAST;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_u))
+ 		ret |= WAKE_UCAST;
+ 
+ 	if (MLX5_CAP_GEN(mdev, wol_p))
+ 		ret |= WAKE_PHY;
+ 
+ 	return ret;
+ }
+ 
+ static __u32 mlx5e_refomrat_wol_mode_mlx5_to_linux(u8 mode)
+ {
+ 	__u32 ret = 0;
+ 
+ 	if (mode & MLX5_WOL_MAGIC)
+ 		ret |= WAKE_MAGIC;
+ 
+ 	if (mode & MLX5_WOL_SECURED_MAGIC)
+ 		ret |= WAKE_MAGICSECURE;
+ 
+ 	if (mode & MLX5_WOL_ARP)
+ 		ret |= WAKE_ARP;
+ 
+ 	if (mode & MLX5_WOL_BROADCAST)
+ 		ret |= WAKE_BCAST;
+ 
+ 	if (mode & MLX5_WOL_MULTICAST)
+ 		ret |= WAKE_MCAST;
+ 
+ 	if (mode & MLX5_WOL_UNICAST)
+ 		ret |= WAKE_UCAST;
+ 
+ 	if (mode & MLX5_WOL_PHY_ACTIVITY)
+ 		ret |= WAKE_PHY;
+ 
+ 	return ret;
+ }
+ 
+ static u8 mlx5e_refomrat_wol_mode_linux_to_mlx5(__u32 mode)
+ {
+ 	u8 ret = 0;
+ 
+ 	if (mode & WAKE_MAGIC)
+ 		ret |= MLX5_WOL_MAGIC;
+ 
+ 	if (mode & WAKE_MAGICSECURE)
+ 		ret |= MLX5_WOL_SECURED_MAGIC;
+ 
+ 	if (mode & WAKE_ARP)
+ 		ret |= MLX5_WOL_ARP;
+ 
+ 	if (mode & WAKE_BCAST)
+ 		ret |= MLX5_WOL_BROADCAST;
+ 
+ 	if (mode & WAKE_MCAST)
+ 		ret |= MLX5_WOL_MULTICAST;
+ 
+ 	if (mode & WAKE_UCAST)
+ 		ret |= MLX5_WOL_UNICAST;
+ 
+ 	if (mode & WAKE_PHY)
+ 		ret |= MLX5_WOL_PHY_ACTIVITY;
+ 
+ 	return ret;
+ }
+ 
+ static void mlx5e_get_wol(struct net_device *netdev,
+ 			  struct ethtool_wolinfo *wol)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	u8 mlx5_wol_mode;
+ 	int err;
+ 
+ 	memset(wol, 0, sizeof(*wol));
+ 
+ 	wol->supported = mlx5e_get_wol_supported(mdev);
+ 	if (!wol->supported)
+ 		return;
+ 
+ 	err = mlx5_query_port_wol(mdev, &mlx5_wol_mode);
+ 	if (err)
+ 		return;
+ 
+ 	wol->wolopts = mlx5e_refomrat_wol_mode_mlx5_to_linux(mlx5_wol_mode);
+ }
+ 
+ static int mlx5e_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	__u32 wol_supported = mlx5e_get_wol_supported(mdev);
+ 	u32 mlx5_wol_mode;
+ 
+ 	if (!wol_supported)
+ 		return -ENOTSUPP;
+ 
+ 	if (wol->wolopts & ~wol_supported)
+ 		return -EINVAL;
+ 
+ 	mlx5_wol_mode = mlx5e_refomrat_wol_mode_linux_to_mlx5(wol->wolopts);
+ 
+ 	return mlx5_set_port_wol(mdev, mlx5_wol_mode);
+ }
+ 
+ static int mlx5e_set_phys_id(struct net_device *dev,
+ 			     enum ethtool_phys_id_state state)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	u16 beacon_duration;
+ 
+ 	if (!MLX5_CAP_GEN(mdev, beacon_led))
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (state) {
+ 	case ETHTOOL_ID_ACTIVE:
+ 		beacon_duration = MLX5_BEACON_DURATION_INF;
+ 		break;
+ 	case ETHTOOL_ID_INACTIVE:
+ 		beacon_duration = MLX5_BEACON_DURATION_OFF;
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return mlx5_set_port_beacon(mdev, beacon_duration);
+ }
+ 
+ static int mlx5e_get_module_info(struct net_device *netdev,
+ 				 struct ethtool_modinfo *modinfo)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *dev = priv->mdev;
+ 	int size_read = 0;
+ 	u8 data[4];
+ 
+ 	size_read = mlx5_query_module_eeprom(dev, 0, 2, data);
+ 	if (size_read < 2)
+ 		return -EIO;
+ 
+ 	/* data[0] = identifier byte */
+ 	switch (data[0]) {
+ 	case MLX5_MODULE_ID_QSFP:
+ 		modinfo->type       = ETH_MODULE_SFF_8436;
+ 		modinfo->eeprom_len = ETH_MODULE_SFF_8436_LEN;
+ 		break;
+ 	case MLX5_MODULE_ID_QSFP_PLUS:
+ 	case MLX5_MODULE_ID_QSFP28:
+ 		/* data[1] = revision id */
+ 		if (data[0] == MLX5_MODULE_ID_QSFP28 || data[1] >= 0x3) {
+ 			modinfo->type       = ETH_MODULE_SFF_8636;
+ 			modinfo->eeprom_len = ETH_MODULE_SFF_8636_LEN;
+ 		} else {
+ 			modinfo->type       = ETH_MODULE_SFF_8436;
+ 			modinfo->eeprom_len = ETH_MODULE_SFF_8436_LEN;
+ 		}
+ 		break;
+ 	case MLX5_MODULE_ID_SFP:
+ 		modinfo->type       = ETH_MODULE_SFF_8472;
+ 		modinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;
+ 		break;
+ 	default:
+ 		netdev_err(priv->netdev, "%s: cable type not recognized:0x%x\n",
+ 			   __func__, data[0]);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5e_get_module_eeprom(struct net_device *netdev,
+ 				   struct ethtool_eeprom *ee,
+ 				   u8 *data)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	int offset = ee->offset;
+ 	int size_read;
+ 	int i = 0;
+ 
+ 	if (!ee->len)
+ 		return -EINVAL;
+ 
+ 	memset(data, 0, ee->len);
+ 
+ 	while (i < ee->len) {
+ 		size_read = mlx5_query_module_eeprom(mdev, offset, ee->len - i,
+ 						     data + i);
+ 
+ 		if (!size_read)
+ 			/* Done reading */
+ 			return 0;
+ 
+ 		if (size_read < 0) {
+ 			netdev_err(priv->netdev, "%s: mlx5_query_eeprom failed:0x%x\n",
+ 				   __func__, size_read);
+ 			return 0;
+ 		}
+ 
+ 		i += size_read;
+ 		offset += size_read;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> bb64143eee8c (net/mlx5e: Add ethtool support for dump module EEPROM)
  const struct ethtool_ops mlx5e_ethtool_ops = {
  	.get_drvinfo       = mlx5e_get_drvinfo,
  	.get_link          = ethtool_op_get_link,
@@@ -881,4 -1260,10 +1138,13 @@@
  	.set_tunable       = mlx5e_set_tunable,
  	.get_pauseparam    = mlx5e_get_pauseparam,
  	.set_pauseparam    = mlx5e_set_pauseparam,
++<<<<<<< HEAD
++=======
+ 	.get_ts_info       = mlx5e_get_ts_info,
+ 	.set_phys_id       = mlx5e_set_phys_id,
+ 	.get_wol	   = mlx5e_get_wol,
+ 	.set_wol	   = mlx5e_set_wol,
+ 	.get_module_info   = mlx5e_get_module_info,
+ 	.get_module_eeprom = mlx5e_get_module_eeprom,
++>>>>>>> bb64143eee8c (net/mlx5e: Add ethtool support for dump module EEPROM)
  };
diff --cc include/linux/mlx5/driver.h
index d4e17c4128c4,1a170672c656..000000000000
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@@ -110,9 -112,12 +110,18 @@@ enum 
  	MLX5_REG_PMPE		 = 0x5010,
  	MLX5_REG_PELC		 = 0x500e,
  	MLX5_REG_PVLC		 = 0x500f,
++<<<<<<< HEAD
 +	MLX5_REG_PMLP		 = 0, /* TBD */
 +	MLX5_REG_NODE_DESC	 = 0x6001,
 +	MLX5_REG_HOST_ENDIANNESS = 0x7004,
++=======
+ 	MLX5_REG_PCMR		 = 0x5041,
+ 	MLX5_REG_PMLP		 = 0x5002,
+ 	MLX5_REG_NODE_DESC	 = 0x6001,
+ 	MLX5_REG_HOST_ENDIANNESS = 0x7004,
+ 	MLX5_REG_MCIA		 = 0x9014,
+ 	MLX5_REG_MLCR		 = 0x902b,
++>>>>>>> bb64143eee8c (net/mlx5e: Add ethtool support for dump module EEPROM)
  };
  
  enum {
diff --cc include/linux/mlx5/port.h
index 66ed80185fae,7391eb833253..000000000000
--- a/include/linux/mlx5/port.h
+++ b/include/linux/mlx5/port.h
@@@ -35,6 -35,24 +35,27 @@@
  
  #include <linux/mlx5/driver.h>
  
++<<<<<<< HEAD
++=======
+ enum mlx5_beacon_duration {
+ 	MLX5_BEACON_DURATION_OFF = 0x0,
+ 	MLX5_BEACON_DURATION_INF = 0xffff,
+ };
+ 
+ enum mlx5_module_id {
+ 	MLX5_MODULE_ID_SFP              = 0x3,
+ 	MLX5_MODULE_ID_QSFP             = 0xC,
+ 	MLX5_MODULE_ID_QSFP_PLUS        = 0xD,
+ 	MLX5_MODULE_ID_QSFP28           = 0x11,
+ };
+ 
+ #define MLX5_EEPROM_MAX_BYTES			32
+ #define MLX5_EEPROM_IDENTIFIER_BYTE_MASK	0x000000ff
+ #define MLX5_I2C_ADDR_LOW		0x50
+ #define MLX5_I2C_ADDR_HIGH		0x51
+ #define MLX5_EEPROM_PAGE_LENGTH		256
+ 
++>>>>>>> bb64143eee8c (net/mlx5e: Add ethtool support for dump module EEPROM)
  int mlx5_set_port_caps(struct mlx5_core_dev *dev, u8 port_num, u32 caps);
  int mlx5_query_port_ptys(struct mlx5_core_dev *dev, u32 *ptys,
  			 int ptys_size, int proto_mask, u8 local_port);
@@@ -70,4 -89,24 +91,27 @@@ int mlx5_set_port_pfc(struct mlx5_core_
  int mlx5_query_port_pfc(struct mlx5_core_dev *dev, u8 *pfc_en_tx,
  			u8 *pfc_en_rx);
  
++<<<<<<< HEAD
++=======
+ int mlx5_max_tc(struct mlx5_core_dev *mdev);
+ 
+ int mlx5_set_port_prio_tc(struct mlx5_core_dev *mdev, u8 *prio_tc);
+ int mlx5_set_port_tc_group(struct mlx5_core_dev *mdev, u8 *tc_group);
+ int mlx5_set_port_tc_bw_alloc(struct mlx5_core_dev *mdev, u8 *tc_bw);
+ int mlx5_modify_port_ets_rate_limit(struct mlx5_core_dev *mdev,
+ 				    u8 *max_bw_value,
+ 				    u8 *max_bw_unit);
+ int mlx5_query_port_ets_rate_limit(struct mlx5_core_dev *mdev,
+ 				   u8 *max_bw_value,
+ 				   u8 *max_bw_unit);
+ int mlx5_set_port_wol(struct mlx5_core_dev *mdev, u8 wol_mode);
+ int mlx5_query_port_wol(struct mlx5_core_dev *mdev, u8 *wol_mode);
+ 
+ int mlx5_set_port_fcs(struct mlx5_core_dev *mdev, u8 enable);
+ void mlx5_query_port_fcs(struct mlx5_core_dev *mdev, bool *supported,
+ 			 bool *enabled);
+ int mlx5_query_module_eeprom(struct mlx5_core_dev *dev,
+ 			     u16 offset, u16 size, u8 *data);
+ 
++>>>>>>> bb64143eee8c (net/mlx5e: Add ethtool support for dump module EEPROM)
  #endif /* __MLX5_PORT_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/port.c b/drivers/net/ethernet/mellanox/mlx5/core/port.c
index ed339867cddb..1ac00208dbc6 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/port.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/port.c
@@ -297,6 +297,82 @@ void mlx5_query_port_oper_mtu(struct mlx5_core_dev *dev, u16 *oper_mtu,
 }
 EXPORT_SYMBOL_GPL(mlx5_query_port_oper_mtu);
 
+static int mlx5_query_module_num(struct mlx5_core_dev *dev, int *module_num)
+{
+	u32 out[MLX5_ST_SZ_DW(pmlp_reg)];
+	u32 in[MLX5_ST_SZ_DW(pmlp_reg)];
+	int module_mapping;
+	int err;
+
+	memset(in, 0, sizeof(in));
+
+	MLX5_SET(pmlp_reg, in, local_port, 1);
+
+	err = mlx5_core_access_reg(dev, in, sizeof(in), out, sizeof(out),
+				   MLX5_REG_PMLP, 0, 0);
+	if (err)
+		return err;
+
+	module_mapping = MLX5_GET(pmlp_reg, out, lane0_module_mapping);
+	*module_num = module_mapping & MLX5_EEPROM_IDENTIFIER_BYTE_MASK;
+
+	return 0;
+}
+
+int mlx5_query_module_eeprom(struct mlx5_core_dev *dev,
+			     u16 offset, u16 size, u8 *data)
+{
+	u32 out[MLX5_ST_SZ_DW(mcia_reg)];
+	u32 in[MLX5_ST_SZ_DW(mcia_reg)];
+	int module_num;
+	u16 i2c_addr;
+	int status;
+	int err;
+	void *ptr = MLX5_ADDR_OF(mcia_reg, out, dword_0);
+
+	err = mlx5_query_module_num(dev, &module_num);
+	if (err)
+		return err;
+
+	memset(in, 0, sizeof(in));
+	size = min_t(int, size, MLX5_EEPROM_MAX_BYTES);
+
+	if (offset < MLX5_EEPROM_PAGE_LENGTH &&
+	    offset + size > MLX5_EEPROM_PAGE_LENGTH)
+		/* Cross pages read, read until offset 256 in low page */
+		size -= offset + size - MLX5_EEPROM_PAGE_LENGTH;
+
+	i2c_addr = MLX5_I2C_ADDR_LOW;
+	if (offset >= MLX5_EEPROM_PAGE_LENGTH) {
+		i2c_addr = MLX5_I2C_ADDR_HIGH;
+		offset -= MLX5_EEPROM_PAGE_LENGTH;
+	}
+
+	MLX5_SET(mcia_reg, in, l, 0);
+	MLX5_SET(mcia_reg, in, module, module_num);
+	MLX5_SET(mcia_reg, in, i2c_device_address, i2c_addr);
+	MLX5_SET(mcia_reg, in, page_number, 0);
+	MLX5_SET(mcia_reg, in, device_address, offset);
+	MLX5_SET(mcia_reg, in, size, size);
+
+	err = mlx5_core_access_reg(dev, in, sizeof(in), out,
+				   sizeof(out), MLX5_REG_MCIA, 0, 0);
+	if (err)
+		return err;
+
+	status = MLX5_GET(mcia_reg, out, status);
+	if (status) {
+		mlx5_core_err(dev, "query_mcia_reg failed: status: 0x%x\n",
+			      status);
+		return -EIO;
+	}
+
+	memcpy(data, ptr, size);
+
+	return size;
+}
+EXPORT_SYMBOL_GPL(mlx5_query_module_eeprom);
+
 static int mlx5_query_port_pvlc(struct mlx5_core_dev *dev, u32 *pvlc,
 				int pvlc_size,  u8 local_port)
 {
* Unmerged path include/linux/mlx5/driver.h
* Unmerged path include/linux/mlx5/port.h
