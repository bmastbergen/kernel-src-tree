ip-tunnel: Use API to access tunnel metadata options.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] ip_tunnel: Use API to access tunnel metadata options (Lance Richardson) [1283886]
Rebuild_FUZZ: 97.14%
commit-author Pravin B Shelar <pshelar@nicira.com>
commit 4c22279848c531fc7f555d463daf3d0df963bd41
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4c222798.failed

Currently tun-info options pointer is used in few cases to
pass options around. But tunnel options can be accessed using
ip_tunnel_info_opts() API without using the pointer. Following
patch removes the redundant pointer and consistently make use
of API.

	Signed-off-by: Pravin B Shelar <pshelar@nicira.com>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Reviewed-by: Jesse Gross <jesse@nicira.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4c22279848c531fc7f555d463daf3d0df963bd41)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
#	include/net/dst_metadata.h
#	include/net/ip_tunnels.h
#	net/ipv4/ip_tunnel_core.c
#	net/openvswitch/vport-geneve.c
#	net/openvswitch/vport-gre.c
#	net/openvswitch/vport-vxlan.c
#	net/openvswitch/vport.c
#	net/openvswitch/vport.h
diff --cc drivers/net/vxlan.c
index 9d79e4f0a7b6,ce988fd01b34..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1195,6 -1263,19 +1195,22 @@@ static int vxlan_udp_encap_recv(struct 
  		vni &= VXLAN_VNI_MASK;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (vxlan_collect_metadata(vs)) {
+ 		tun_dst = udp_tun_rx_dst(skb, vxlan_get_sk_family(vs), TUNNEL_KEY,
+ 					 cpu_to_be64(vni >> 8), sizeof(*md));
+ 
+ 		if (!tun_dst)
+ 			goto drop;
+ 
+ 		info = &tun_dst->u.tun_info;
+ 		md = ip_tunnel_info_opts(info);
+ 	} else {
+ 		memset(md, 0, sizeof(*md));
+ 	}
+ 
++>>>>>>> 4c22279848c5 (ip-tunnel: Use API to access tunnel metadata options.)
  	/* For backwards compatibility, only allow reserved fields to be
  	 * used by VXLAN extensions if explicitly requested.
  	 */
@@@ -1907,12 -1935,30 +1923,32 @@@ static void vxlan_xmit_one(struct sk_bu
  	if (tos == 1)
  		tos = ip_tunnel_get_dsfield(old_iph, skb);
  
++<<<<<<< HEAD
 +	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->port_min,
 +				     vxlan->port_max, true);
++=======
+ 	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
+ 				     vxlan->cfg.port_max, true);
+ 
+ 	if (info) {
+ 		if (info->key.tun_flags & TUNNEL_CSUM)
+ 			flags |= VXLAN_F_UDP_CSUM;
+ 		else
+ 			flags &= ~VXLAN_F_UDP_CSUM;
+ 
+ 		ttl = info->key.ttl;
+ 		tos = info->key.tos;
+ 
+ 		if (info->options_len)
+ 			md = ip_tunnel_info_opts(info);
+ 	} else {
+ 		md->gbp = skb->mark;
+ 	}
++>>>>>>> 4c22279848c5 (ip-tunnel: Use API to access tunnel metadata options.)
  
  	if (dst->sa.sa_family == AF_INET) {
 -		if (info && (info->key.tun_flags & TUNNEL_DONT_FRAGMENT))
 -			df = htons(IP_DF);
 -
  		memset(&fl4, 0, sizeof(fl4));
 -		fl4.flowi4_oif = rdst ? rdst->remote_ifindex : 0;
 +		fl4.flowi4_oif = rdst->remote_ifindex;
  		fl4.flowi4_tos = RT_TOS(tos);
  		fl4.flowi4_mark = skb->mark;
  		fl4.flowi4_proto = IPPROTO_UDP;
diff --cc include/net/ip_tunnels.h
index 8a38d811a07c,9a6a3ba888e8..000000000000
--- a/include/net/ip_tunnels.h
+++ b/include/net/ip_tunnels.h
@@@ -38,10 -51,14 +38,9 @@@ struct ip_tunnel_key 
  	__be16			tp_dst;
  };
  
 -/* Flags for ip_tunnel_info mode. */
 -#define IP_TUNNEL_INFO_TX	0x01	/* represents tx tunnel parameters */
 -#define IP_TUNNEL_INFO_IPV6	0x02	/* key contains IPv6 addresses */
 -
  struct ip_tunnel_info {
  	struct ip_tunnel_key	key;
- 	const void		*options;
  	u8			options_len;
 -	u8			mode;
  };
  
  /* 6rd prefix/relay information */
@@@ -168,45 -179,38 +167,61 @@@ int ip_tunnel_encap_add_ops(const struc
  int ip_tunnel_encap_del_ops(const struct ip_tunnel_encap_ops *op,
  			    unsigned int num);
  
- static inline void __ip_tunnel_info_init(struct ip_tunnel_info *tun_info,
- 					 __be32 saddr, __be32 daddr,
- 					 u8 tos, u8 ttl,
- 					 __be16 tp_src, __be16 tp_dst,
- 					 __be64 tun_id, __be16 tun_flags,
- 					 const void *opts, u8 opts_len)
+ static inline void ip_tunnel_key_init(struct ip_tunnel_key *key,
+ 				      __be32 saddr, __be32 daddr,
+ 				      u8 tos, u8 ttl,
+ 				      __be16 tp_src, __be16 tp_dst,
+ 				      __be64 tun_id, __be16 tun_flags)
  {
++<<<<<<< HEAD
 +	tun_info->key.tun_id = tun_id;
 +	tun_info->key.ipv4_src = saddr;
 +	tun_info->key.ipv4_dst = daddr;
 +	tun_info->key.ipv4_tos = tos;
 +	tun_info->key.ipv4_ttl = ttl;
 +	tun_info->key.tun_flags = tun_flags;
++=======
+ 	key->tun_id = tun_id;
+ 	key->u.ipv4.src = saddr;
+ 	key->u.ipv4.dst = daddr;
+ 	memset((unsigned char *)key + IP_TUNNEL_KEY_IPV4_PAD,
+ 	       0, IP_TUNNEL_KEY_IPV4_PAD_LEN);
+ 	key->tos = tos;
+ 	key->ttl = ttl;
+ 	key->tun_flags = tun_flags;
++>>>>>>> 4c22279848c5 (ip-tunnel: Use API to access tunnel metadata options.)
  
  	/* For the tunnel types on the top of IPsec, the tp_src and tp_dst of
  	 * the upper tunnel are used.
  	 * E.g: GRE over IPSEC, the tp_src and tp_port are zero.
  	 */
- 	tun_info->key.tp_src = tp_src;
- 	tun_info->key.tp_dst = tp_dst;
+ 	key->tp_src = tp_src;
+ 	key->tp_dst = tp_dst;
  
  	/* Clear struct padding. */
 -	if (sizeof(*key) != IP_TUNNEL_KEY_SIZE)
 -		memset((unsigned char *)key + IP_TUNNEL_KEY_SIZE,
 -		       0, sizeof(*key) - IP_TUNNEL_KEY_SIZE);
++<<<<<<< HEAD
 +	if (sizeof(tun_info->key) != IP_TUNNEL_KEY_SIZE)
 +		memset((unsigned char *)&tun_info->key + IP_TUNNEL_KEY_SIZE,
 +		       0, sizeof(tun_info->key) - IP_TUNNEL_KEY_SIZE);
 +
 +	tun_info->options = opts;
 +	tun_info->options_len = opts_len;
  }
  
 -static inline unsigned short ip_tunnel_info_af(const struct ip_tunnel_info
 -					       *tun_info)
 +static inline void ip_tunnel_info_init(struct ip_tunnel_info *tun_info,
 +				       const struct iphdr *iph,
 +				       __be16 tp_src, __be16 tp_dst,
 +				       __be64 tun_id, __be16 tun_flags,
 +				       const void *opts, u8 opts_len)
  {
 -	return tun_info->mode & IP_TUNNEL_INFO_IPV6 ? AF_INET6 : AF_INET;
 +	__ip_tunnel_info_init(tun_info, iph->saddr, iph->daddr,
 +			      iph->tos, iph->ttl, tp_src, tp_dst,
 +			      tun_id, tun_flags, opts, opts_len);
++=======
++	if (sizeof(*key) != IP_TUNNEL_KEY_SIZE)
++		memset((unsigned char *)key + IP_TUNNEL_KEY_SIZE,
++		       0, sizeof(*key) - IP_TUNNEL_KEY_SIZE);
++>>>>>>> 4c22279848c5 (ip-tunnel: Use API to access tunnel metadata options.)
  }
  
  #ifdef CONFIG_INET
@@@ -294,6 -299,57 +309,60 @@@ static inline void iptunnel_xmit_stats(
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static inline void *ip_tunnel_info_opts(struct ip_tunnel_info *info)
+ {
+ 	return info + 1;
+ }
+ 
+ static inline void ip_tunnel_info_opts_get(void *to,
+ 					   const struct ip_tunnel_info *info)
+ {
+ 	memcpy(to, info + 1, info->options_len);
+ }
+ 
+ static inline void ip_tunnel_info_opts_set(struct ip_tunnel_info *info,
+ 					   const void *from, int len)
+ {
+ 	memcpy(ip_tunnel_info_opts(info), from, len);
+ 	info->options_len = len;
+ }
+ 
+ static inline struct ip_tunnel_info *lwt_tun_info(struct lwtunnel_state *lwtstate)
+ {
+ 	return (struct ip_tunnel_info *)lwtstate->data;
+ }
+ 
+ extern struct static_key ip_tunnel_metadata_cnt;
+ 
+ /* Returns > 0 if metadata should be collected */
+ static inline int ip_tunnel_collect_metadata(void)
+ {
+ 	return static_key_false(&ip_tunnel_metadata_cnt);
+ }
+ 
+ void __init ip_tunnel_core_init(void);
+ 
+ void ip_tunnel_need_metadata(void);
+ void ip_tunnel_unneed_metadata(void);
+ 
+ #else /* CONFIG_INET */
+ 
+ static inline struct ip_tunnel_info *lwt_tun_info(struct lwtunnel_state *lwtstate)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void ip_tunnel_need_metadata(void)
+ {
+ }
+ 
+ static inline void ip_tunnel_unneed_metadata(void)
+ {
+ }
+ 
++>>>>>>> 4c22279848c5 (ip-tunnel: Use API to access tunnel metadata options.)
  #endif /* CONFIG_INET */
  
  #endif /* __NET_IP_TUNNELS_H */
diff --cc net/ipv4/ip_tunnel_core.c
index 010b54caceed,29ed6c5a5185..000000000000
--- a/net/ipv4/ip_tunnel_core.c
+++ b/net/ipv4/ip_tunnel_core.c
@@@ -188,3 -191,232 +188,235 @@@ struct rtnl_link_stats64 *ip_tunnel_get
  	return tot;
  }
  EXPORT_SYMBOL_GPL(ip_tunnel_get_stats64);
++<<<<<<< HEAD
++=======
+ 
+ static const struct nla_policy ip_tun_policy[LWTUNNEL_IP_MAX + 1] = {
+ 	[LWTUNNEL_IP_ID]	= { .type = NLA_U64 },
+ 	[LWTUNNEL_IP_DST]	= { .type = NLA_U32 },
+ 	[LWTUNNEL_IP_SRC]	= { .type = NLA_U32 },
+ 	[LWTUNNEL_IP_TTL]	= { .type = NLA_U8 },
+ 	[LWTUNNEL_IP_TOS]	= { .type = NLA_U8 },
+ 	[LWTUNNEL_IP_SPORT]	= { .type = NLA_U16 },
+ 	[LWTUNNEL_IP_DPORT]	= { .type = NLA_U16 },
+ 	[LWTUNNEL_IP_FLAGS]	= { .type = NLA_U16 },
+ };
+ 
+ static int ip_tun_build_state(struct net_device *dev, struct nlattr *attr,
+ 			      unsigned int family, const void *cfg,
+ 			      struct lwtunnel_state **ts)
+ {
+ 	struct ip_tunnel_info *tun_info;
+ 	struct lwtunnel_state *new_state;
+ 	struct nlattr *tb[LWTUNNEL_IP_MAX + 1];
+ 	int err;
+ 
+ 	err = nla_parse_nested(tb, LWTUNNEL_IP_MAX, attr, ip_tun_policy);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	new_state = lwtunnel_state_alloc(sizeof(*tun_info));
+ 	if (!new_state)
+ 		return -ENOMEM;
+ 
+ 	new_state->type = LWTUNNEL_ENCAP_IP;
+ 
+ 	tun_info = lwt_tun_info(new_state);
+ 
+ 	if (tb[LWTUNNEL_IP_ID])
+ 		tun_info->key.tun_id = nla_get_u64(tb[LWTUNNEL_IP_ID]);
+ 
+ 	if (tb[LWTUNNEL_IP_DST])
+ 		tun_info->key.u.ipv4.dst = nla_get_be32(tb[LWTUNNEL_IP_DST]);
+ 
+ 	if (tb[LWTUNNEL_IP_SRC])
+ 		tun_info->key.u.ipv4.src = nla_get_be32(tb[LWTUNNEL_IP_SRC]);
+ 
+ 	if (tb[LWTUNNEL_IP_TTL])
+ 		tun_info->key.ttl = nla_get_u8(tb[LWTUNNEL_IP_TTL]);
+ 
+ 	if (tb[LWTUNNEL_IP_TOS])
+ 		tun_info->key.tos = nla_get_u8(tb[LWTUNNEL_IP_TOS]);
+ 
+ 	if (tb[LWTUNNEL_IP_SPORT])
+ 		tun_info->key.tp_src = nla_get_be16(tb[LWTUNNEL_IP_SPORT]);
+ 
+ 	if (tb[LWTUNNEL_IP_DPORT])
+ 		tun_info->key.tp_dst = nla_get_be16(tb[LWTUNNEL_IP_DPORT]);
+ 
+ 	if (tb[LWTUNNEL_IP_FLAGS])
+ 		tun_info->key.tun_flags = nla_get_u16(tb[LWTUNNEL_IP_FLAGS]);
+ 
+ 	tun_info->mode = IP_TUNNEL_INFO_TX;
+ 	tun_info->options_len = 0;
+ 
+ 	*ts = new_state;
+ 
+ 	return 0;
+ }
+ 
+ static int ip_tun_fill_encap_info(struct sk_buff *skb,
+ 				  struct lwtunnel_state *lwtstate)
+ {
+ 	struct ip_tunnel_info *tun_info = lwt_tun_info(lwtstate);
+ 
+ 	if (nla_put_u64(skb, LWTUNNEL_IP_ID, tun_info->key.tun_id) ||
+ 	    nla_put_be32(skb, LWTUNNEL_IP_DST, tun_info->key.u.ipv4.dst) ||
+ 	    nla_put_be32(skb, LWTUNNEL_IP_SRC, tun_info->key.u.ipv4.src) ||
+ 	    nla_put_u8(skb, LWTUNNEL_IP_TOS, tun_info->key.tos) ||
+ 	    nla_put_u8(skb, LWTUNNEL_IP_TTL, tun_info->key.ttl) ||
+ 	    nla_put_u16(skb, LWTUNNEL_IP_SPORT, tun_info->key.tp_src) ||
+ 	    nla_put_u16(skb, LWTUNNEL_IP_DPORT, tun_info->key.tp_dst) ||
+ 	    nla_put_u16(skb, LWTUNNEL_IP_FLAGS, tun_info->key.tun_flags))
+ 		return -ENOMEM;
+ 
+ 	return 0;
+ }
+ 
+ static int ip_tun_encap_nlsize(struct lwtunnel_state *lwtstate)
+ {
+ 	return nla_total_size(8)	/* LWTUNNEL_IP_ID */
+ 		+ nla_total_size(4)	/* LWTUNNEL_IP_DST */
+ 		+ nla_total_size(4)	/* LWTUNNEL_IP_SRC */
+ 		+ nla_total_size(1)	/* LWTUNNEL_IP_TOS */
+ 		+ nla_total_size(1)	/* LWTUNNEL_IP_TTL */
+ 		+ nla_total_size(2)	/* LWTUNNEL_IP_SPORT */
+ 		+ nla_total_size(2)	/* LWTUNNEL_IP_DPORT */
+ 		+ nla_total_size(2);	/* LWTUNNEL_IP_FLAGS */
+ }
+ 
+ static int ip_tun_cmp_encap(struct lwtunnel_state *a, struct lwtunnel_state *b)
+ {
+ 	return memcmp(lwt_tun_info(a), lwt_tun_info(b),
+ 		      sizeof(struct ip_tunnel_info));
+ }
+ 
+ static const struct lwtunnel_encap_ops ip_tun_lwt_ops = {
+ 	.build_state = ip_tun_build_state,
+ 	.fill_encap = ip_tun_fill_encap_info,
+ 	.get_encap_size = ip_tun_encap_nlsize,
+ 	.cmp_encap = ip_tun_cmp_encap,
+ };
+ 
+ static const struct nla_policy ip6_tun_policy[LWTUNNEL_IP6_MAX + 1] = {
+ 	[LWTUNNEL_IP6_ID]		= { .type = NLA_U64 },
+ 	[LWTUNNEL_IP6_DST]		= { .len = sizeof(struct in6_addr) },
+ 	[LWTUNNEL_IP6_SRC]		= { .len = sizeof(struct in6_addr) },
+ 	[LWTUNNEL_IP6_HOPLIMIT]		= { .type = NLA_U8 },
+ 	[LWTUNNEL_IP6_TC]		= { .type = NLA_U8 },
+ 	[LWTUNNEL_IP6_SPORT]		= { .type = NLA_U16 },
+ 	[LWTUNNEL_IP6_DPORT]		= { .type = NLA_U16 },
+ 	[LWTUNNEL_IP6_FLAGS]		= { .type = NLA_U16 },
+ };
+ 
+ static int ip6_tun_build_state(struct net_device *dev, struct nlattr *attr,
+ 			       unsigned int family, const void *cfg,
+ 			       struct lwtunnel_state **ts)
+ {
+ 	struct ip_tunnel_info *tun_info;
+ 	struct lwtunnel_state *new_state;
+ 	struct nlattr *tb[LWTUNNEL_IP6_MAX + 1];
+ 	int err;
+ 
+ 	err = nla_parse_nested(tb, LWTUNNEL_IP6_MAX, attr, ip6_tun_policy);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	new_state = lwtunnel_state_alloc(sizeof(*tun_info));
+ 	if (!new_state)
+ 		return -ENOMEM;
+ 
+ 	new_state->type = LWTUNNEL_ENCAP_IP6;
+ 
+ 	tun_info = lwt_tun_info(new_state);
+ 
+ 	if (tb[LWTUNNEL_IP6_ID])
+ 		tun_info->key.tun_id = nla_get_u64(tb[LWTUNNEL_IP6_ID]);
+ 
+ 	if (tb[LWTUNNEL_IP6_DST])
+ 		tun_info->key.u.ipv6.dst = nla_get_in6_addr(tb[LWTUNNEL_IP6_DST]);
+ 
+ 	if (tb[LWTUNNEL_IP6_SRC])
+ 		tun_info->key.u.ipv6.src = nla_get_in6_addr(tb[LWTUNNEL_IP6_SRC]);
+ 
+ 	if (tb[LWTUNNEL_IP6_HOPLIMIT])
+ 		tun_info->key.ttl = nla_get_u8(tb[LWTUNNEL_IP6_HOPLIMIT]);
+ 
+ 	if (tb[LWTUNNEL_IP6_TC])
+ 		tun_info->key.tos = nla_get_u8(tb[LWTUNNEL_IP6_TC]);
+ 
+ 	if (tb[LWTUNNEL_IP6_SPORT])
+ 		tun_info->key.tp_src = nla_get_be16(tb[LWTUNNEL_IP6_SPORT]);
+ 
+ 	if (tb[LWTUNNEL_IP6_DPORT])
+ 		tun_info->key.tp_dst = nla_get_be16(tb[LWTUNNEL_IP6_DPORT]);
+ 
+ 	if (tb[LWTUNNEL_IP6_FLAGS])
+ 		tun_info->key.tun_flags = nla_get_u16(tb[LWTUNNEL_IP6_FLAGS]);
+ 
+ 	tun_info->mode = IP_TUNNEL_INFO_TX | IP_TUNNEL_INFO_IPV6;
+ 	tun_info->options_len = 0;
+ 
+ 	*ts = new_state;
+ 
+ 	return 0;
+ }
+ 
+ static int ip6_tun_fill_encap_info(struct sk_buff *skb,
+ 				   struct lwtunnel_state *lwtstate)
+ {
+ 	struct ip_tunnel_info *tun_info = lwt_tun_info(lwtstate);
+ 
+ 	if (nla_put_u64(skb, LWTUNNEL_IP6_ID, tun_info->key.tun_id) ||
+ 	    nla_put_in6_addr(skb, LWTUNNEL_IP6_DST, &tun_info->key.u.ipv6.dst) ||
+ 	    nla_put_in6_addr(skb, LWTUNNEL_IP6_SRC, &tun_info->key.u.ipv6.src) ||
+ 	    nla_put_u8(skb, LWTUNNEL_IP6_HOPLIMIT, tun_info->key.tos) ||
+ 	    nla_put_u8(skb, LWTUNNEL_IP6_TC, tun_info->key.ttl) ||
+ 	    nla_put_u16(skb, LWTUNNEL_IP6_SPORT, tun_info->key.tp_src) ||
+ 	    nla_put_u16(skb, LWTUNNEL_IP6_DPORT, tun_info->key.tp_dst) ||
+ 	    nla_put_u16(skb, LWTUNNEL_IP6_FLAGS, tun_info->key.tun_flags))
+ 		return -ENOMEM;
+ 
+ 	return 0;
+ }
+ 
+ static int ip6_tun_encap_nlsize(struct lwtunnel_state *lwtstate)
+ {
+ 	return nla_total_size(8)	/* LWTUNNEL_IP6_ID */
+ 		+ nla_total_size(16)	/* LWTUNNEL_IP6_DST */
+ 		+ nla_total_size(16)	/* LWTUNNEL_IP6_SRC */
+ 		+ nla_total_size(1)	/* LWTUNNEL_IP6_HOPLIMIT */
+ 		+ nla_total_size(1)	/* LWTUNNEL_IP6_TC */
+ 		+ nla_total_size(2)	/* LWTUNNEL_IP6_SPORT */
+ 		+ nla_total_size(2)	/* LWTUNNEL_IP6_DPORT */
+ 		+ nla_total_size(2);	/* LWTUNNEL_IP6_FLAGS */
+ }
+ 
+ static const struct lwtunnel_encap_ops ip6_tun_lwt_ops = {
+ 	.build_state = ip6_tun_build_state,
+ 	.fill_encap = ip6_tun_fill_encap_info,
+ 	.get_encap_size = ip6_tun_encap_nlsize,
+ 	.cmp_encap = ip_tun_cmp_encap,
+ };
+ 
+ void __init ip_tunnel_core_init(void)
+ {
+ 	lwtunnel_encap_add_ops(&ip_tun_lwt_ops, LWTUNNEL_ENCAP_IP);
+ 	lwtunnel_encap_add_ops(&ip6_tun_lwt_ops, LWTUNNEL_ENCAP_IP6);
+ }
+ 
+ struct static_key ip_tunnel_metadata_cnt = STATIC_KEY_INIT_FALSE;
+ EXPORT_SYMBOL(ip_tunnel_metadata_cnt);
+ 
+ void ip_tunnel_need_metadata(void)
+ {
+ 	static_key_slow_inc(&ip_tunnel_metadata_cnt);
+ }
+ EXPORT_SYMBOL_GPL(ip_tunnel_need_metadata);
+ 
+ void ip_tunnel_unneed_metadata(void)
+ {
+ 	static_key_slow_dec(&ip_tunnel_metadata_cnt);
+ }
+ EXPORT_SYMBOL_GPL(ip_tunnel_unneed_metadata);
++>>>>>>> 4c22279848c5 (ip-tunnel: Use API to access tunnel metadata options.)
diff --cc net/openvswitch/vport-geneve.c
index 1da3a14d1010,2735e9c4a3b8..000000000000
--- a/net/openvswitch/vport-geneve.c
+++ b/net/openvswitch/vport-geneve.c
@@@ -108,13 -52,16 +108,23 @@@ static int geneve_get_options(const str
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void geneve_tnl_destroy(struct vport *vport)
++=======
+ static int geneve_get_egress_tun_info(struct vport *vport, struct sk_buff *skb,
+ 				      struct dp_upcall_info *upcall)
++>>>>>>> 4c22279848c5 (ip-tunnel: Use API to access tunnel metadata options.)
  {
  	struct geneve_port *geneve_port = geneve_vport(vport);
 -	struct net *net = ovs_dp_get_net(vport->dp);
 -	__be16 dport = htons(geneve_port->port_no);
 -	__be16 sport = udp_flow_src_port(net, skb, 1, USHRT_MAX, true);
  
++<<<<<<< HEAD
 +	geneve_sock_release(geneve_port->gs);
 +
 +	ovs_vport_deferred_free(vport);
++=======
+ 	return ovs_tunnel_get_egress_info(upcall, ovs_dp_get_net(vport->dp),
+ 					  skb, IPPROTO_UDP, sport, dport);
++>>>>>>> 4c22279848c5 (ip-tunnel: Use API to access tunnel metadata options.)
  }
  
  static struct vport *geneve_tnl_create(const struct vport_parms *parms)
diff --cc net/openvswitch/vport-gre.c
index b87656c66aaf,4d24481669c9..000000000000
--- a/net/openvswitch/vport-gre.c
+++ b/net/openvswitch/vport-gre.c
@@@ -277,12 -85,10 +277,17 @@@ static void gre_tnl_destroy(struct vpor
  }
  
  static int gre_get_egress_tun_info(struct vport *vport, struct sk_buff *skb,
- 				   struct ip_tunnel_info *egress_tun_info)
+ 				   struct dp_upcall_info *upcall)
  {
++<<<<<<< HEAD
 +	return ovs_tunnel_get_egress_info(egress_tun_info,
 +					  ovs_dp_get_net(vport->dp),
 +					  OVS_CB(skb)->egress_tun_info,
 +					  IPPROTO_GRE, skb->mark, 0, 0);
++=======
+ 	return ovs_tunnel_get_egress_info(upcall, ovs_dp_get_net(vport->dp),
+ 					  skb, IPPROTO_GRE, 0, 0);
++>>>>>>> 4c22279848c5 (ip-tunnel: Use API to access tunnel metadata options.)
  }
  
  static struct vport_ops ovs_gre_vport_ops = {
diff --cc net/openvswitch/vport-vxlan.c
index 6f7986fabb70,c11413d5075f..000000000000
--- a/net/openvswitch/vport-vxlan.c
+++ b/net/openvswitch/vport-vxlan.c
@@@ -269,11 -147,11 +269,11 @@@ error
  }
  
  static int vxlan_get_egress_tun_info(struct vport *vport, struct sk_buff *skb,
- 				     struct ip_tunnel_info *egress_tun_info)
+ 				     struct dp_upcall_info *upcall)
  {
 -	struct vxlan_dev *vxlan = netdev_priv(vport->dev);
  	struct net *net = ovs_dp_get_net(vport->dp);
 -	__be16 dst_port = vxlan_dev_dst_port(vxlan);
 +	struct vxlan_port *vxlan_port = vxlan_vport(vport);
 +	__be16 dst_port = inet_sk(vxlan_port->vs->sock->sk)->inet_sport;
  	__be16 src_port;
  	int port_min;
  	int port_max;
@@@ -281,9 -159,8 +281,14 @@@
  	inet_get_local_port_range(net, &port_min, &port_max);
  	src_port = udp_flow_src_port(net, skb, 0, 0, true);
  
++<<<<<<< HEAD
 +	return ovs_tunnel_get_egress_info(egress_tun_info, net,
 +					  OVS_CB(skb)->egress_tun_info,
 +					  IPPROTO_UDP, skb->mark,
++=======
+ 	return ovs_tunnel_get_egress_info(upcall, net,
+ 					  skb, IPPROTO_UDP,
++>>>>>>> 4c22279848c5 (ip-tunnel: Use API to access tunnel metadata options.)
  					  src_port, dst_port);
  }
  
diff --cc net/openvswitch/vport.c
index af23ba077836,dc81dc619aa2..000000000000
--- a/net/openvswitch/vport.c
+++ b/net/openvswitch/vport.c
@@@ -572,15 -487,17 +572,20 @@@ void ovs_vport_deferred_free(struct vpo
  }
  EXPORT_SYMBOL_GPL(ovs_vport_deferred_free);
  
- int ovs_tunnel_get_egress_info(struct ip_tunnel_info *egress_tun_info,
+ int ovs_tunnel_get_egress_info(struct dp_upcall_info *upcall,
  			       struct net *net,
 -			       struct sk_buff *skb,
 +			       const struct ip_tunnel_info *tun_info,
  			       u8 ipproto,
 +			       u32 skb_mark,
  			       __be16 tp_src,
  			       __be16 tp_dst)
  {
++<<<<<<< HEAD
++=======
+ 	struct ip_tunnel_info *egress_tun_info = upcall->egress_tun_info;
+ 	const struct ip_tunnel_info *tun_info = skb_tunnel_info(skb);
++>>>>>>> 4c22279848c5 (ip-tunnel: Use API to access tunnel metadata options.)
  	const struct ip_tunnel_key *tun_key;
 -	u32 skb_mark = skb->mark;
  	struct rtable *rt;
  	struct flowi4 fl;
  
@@@ -602,16 -521,16 +607,29 @@@
  	/* Generate egress_tun_info based on tun_info,
  	 * saddr, tp_src and tp_dst
  	 */
++<<<<<<< HEAD
 +	__ip_tunnel_info_init(egress_tun_info,
 +			      fl.saddr, tun_key->ipv4_dst,
 +			      tun_key->ipv4_tos,
 +			      tun_key->ipv4_ttl,
 +			      tp_src, tp_dst,
 +			      tun_key->tun_id,
 +			      tun_key->tun_flags,
 +			      tun_info->options,
 +			      tun_info->options_len);
 +
++=======
+ 	ip_tunnel_key_init(&egress_tun_info->key,
+ 			   fl.saddr, tun_key->u.ipv4.dst,
+ 			   tun_key->tos,
+ 			   tun_key->ttl,
+ 			   tp_src, tp_dst,
+ 			   tun_key->tun_id,
+ 			   tun_key->tun_flags);
+ 	egress_tun_info->options_len = tun_info->options_len;
+ 	egress_tun_info->mode = tun_info->mode;
+ 	upcall->egress_tun_opts = ip_tunnel_info_opts(egress_tun_info);
++>>>>>>> 4c22279848c5 (ip-tunnel: Use API to access tunnel metadata options.)
  	return 0;
  }
  EXPORT_SYMBOL_GPL(ovs_tunnel_get_egress_info);
diff --cc net/openvswitch/vport.h
index 4750fb673a9f,a413f3ae6a7b..000000000000
--- a/net/openvswitch/vport.h
+++ b/net/openvswitch/vport.h
@@@ -56,26 -53,16 +56,31 @@@ int ovs_vport_set_upcall_portids(struc
  int ovs_vport_get_upcall_portids(const struct vport *, struct sk_buff *);
  u32 ovs_vport_find_upcall_portid(const struct vport *, struct sk_buff *);
  
++<<<<<<< HEAD
 +int ovs_vport_send(struct vport *, struct sk_buff *);
 +
 +int ovs_tunnel_get_egress_info(struct ip_tunnel_info *egress_tun_info,
++=======
+ int ovs_tunnel_get_egress_info(struct dp_upcall_info *upcall,
++>>>>>>> 4c22279848c5 (ip-tunnel: Use API to access tunnel metadata options.)
  			       struct net *net,
 -			       struct sk_buff *,
 +			       const struct ip_tunnel_info *tun_info,
  			       u8 ipproto,
 +			       u32 skb_mark,
  			       __be16 tp_src,
  			       __be16 tp_dst);
+ 
  int ovs_vport_get_egress_tun_info(struct vport *vport, struct sk_buff *skb,
- 				  struct ip_tunnel_info *info);
+ 				  struct dp_upcall_info *upcall);
  
 +/* The following definitions are for implementers of vport devices: */
 +
 +struct vport_err_stats {
 +	atomic_long_t rx_dropped;
 +	atomic_long_t rx_errors;
 +	atomic_long_t tx_dropped;
 +	atomic_long_t tx_errors;
 +};
  /**
   * struct vport_portids - array of netlink portids of a vport.
   *                        must be protected by rcu.
@@@ -171,12 -153,9 +176,12 @@@ struct vport_ops 
  	int (*set_options)(struct vport *, struct nlattr *);
  	int (*get_options)(const struct vport *, struct sk_buff *);
  
 -	void (*send)(struct vport *, struct sk_buff *);
 +	/* Called with rcu_read_lock or ovs_mutex. */
 +	const char *(*get_name)(const struct vport *);
 +
 +	int (*send)(struct vport *, struct sk_buff *);
  	int (*get_egress_tun_info)(struct vport *, struct sk_buff *,
- 				   struct ip_tunnel_info *);
+ 				   struct dp_upcall_info *upcall);
  
  	struct module *owner;
  	struct list_head list;
* Unmerged path include/net/dst_metadata.h
diff --git a/drivers/net/geneve.c b/drivers/net/geneve.c
index cbb30fc8770f..20cb8935c7c0 100644
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@ -143,7 +143,6 @@ static void geneve_rx(struct geneve_sock *gs, struct sk_buff *skb)
 
 	if (ip_tunnel_collect_metadata() || gs->collect_md) {
 		__be16 flags;
-		void *opts;
 
 		flags = TUNNEL_KEY | TUNNEL_GENEVE_OPT |
 			(gnvh->oam ? TUNNEL_OAM : 0) |
@@ -154,11 +153,9 @@ static void geneve_rx(struct geneve_sock *gs, struct sk_buff *skb)
 					 gnvh->opt_len * 4);
 		if (!tun_dst)
 			goto drop;
-
 		/* Update tunnel dst according to Geneve options. */
-		opts = ip_tunnel_info_opts(&tun_dst->u.tun_info,
-					   gnvh->opt_len * 4);
-		memcpy(opts, gnvh->options, gnvh->opt_len * 4);
+		ip_tunnel_info_opts_set(&tun_dst->u.tun_info,
+					gnvh->options, gnvh->opt_len * 4);
 	} else {
 		/* Drop packets w/ critical options,
 		 * since we don't support any...
@@ -661,7 +658,7 @@ static netdev_tx_t geneve_xmit(struct sk_buff *skb, struct net_device *dev)
 
 		tunnel_id_to_vni(key->tun_id, vni);
 		if (key->tun_flags & TUNNEL_GENEVE_OPT)
-			opts = ip_tunnel_info_opts(info, info->options_len);
+			opts = ip_tunnel_info_opts(info);
 
 		udp_csum = !!(key->tun_flags & TUNNEL_CSUM);
 		err = geneve_build_skb(rt, skb, key->tun_flags, vni,
* Unmerged path drivers/net/vxlan.c
* Unmerged path include/net/dst_metadata.h
* Unmerged path include/net/ip_tunnels.h
* Unmerged path net/ipv4/ip_tunnel_core.c
diff --git a/net/openvswitch/actions.c b/net/openvswitch/actions.c
index 327766f7c945..758a50b05ff1 100644
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@ -644,11 +644,13 @@ static int output_userspace(struct datapath *dp, struct sk_buff *skb,
 			if (vport) {
 				int err;
 
+				upcall.egress_tun_info = &info;
 				err = ovs_vport_get_egress_tun_info(vport, skb,
-								    &info);
-				if (!err)
-					upcall.egress_tun_info = &info;
+								    &upcall);
+				if (err)
+					upcall.egress_tun_info = NULL;
 			}
+
 			break;
 		}
 
diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c
index b447e1242e90..be2df8d44aae 100644
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@ -473,7 +473,8 @@ static int queue_userspace_packet(struct datapath *dp, struct sk_buff *skb,
 	if (upcall_info->egress_tun_info) {
 		nla = nla_nest_start(user_skb, OVS_PACKET_ATTR_EGRESS_TUN_KEY);
 		err = ovs_nla_put_egress_tunnel_key(user_skb,
-						    upcall_info->egress_tun_info);
+						    upcall_info->egress_tun_info,
+						    upcall_info->egress_tun_opts);
 		BUG_ON(err);
 		nla_nest_end(user_skb, nla);
 	}
diff --git a/net/openvswitch/datapath.h b/net/openvswitch/datapath.h
index 487a85f7d967..33f75ba12ec7 100644
--- a/net/openvswitch/datapath.h
+++ b/net/openvswitch/datapath.h
@@ -115,7 +115,8 @@ struct ovs_skb_cb {
  * @egress_tun_info: If nonnull, becomes %OVS_PACKET_ATTR_EGRESS_TUN_KEY.
  */
 struct dp_upcall_info {
-	const struct ip_tunnel_info *egress_tun_info;
+	struct ip_tunnel_info *egress_tun_info;
+	const void *egress_tun_opts;
 	const struct nlattr *userdata;
 	const struct nlattr *actions;
 	int actions_len;
diff --git a/net/openvswitch/flow.c b/net/openvswitch/flow.c
index 8673468c1276..b2c80925caaf 100644
--- a/net/openvswitch/flow.c
+++ b/net/openvswitch/flow.c
@@ -687,12 +687,13 @@ int ovs_flow_key_extract(const struct ip_tunnel_info *tun_info,
 	if (tun_info) {
 		memcpy(&key->tun_key, &tun_info->key, sizeof(key->tun_key));
 
-		if (tun_info->options) {
+		if (tun_info->options_len) {
 			BUILD_BUG_ON((1 << (sizeof(tun_info->options_len) *
 						   8)) - 1
 					> sizeof(key->tun_opts));
-			memcpy(TUN_METADATA_OPTS(key, tun_info->options_len),
-			       tun_info->options, tun_info->options_len);
+
+			ip_tunnel_info_opts_get(TUN_METADATA_OPTS(key, tun_info->options_len),
+						tun_info);
 			key->tun_opts_len = tun_info->options_len;
 		} else {
 			key->tun_opts_len = 0;
diff --git a/net/openvswitch/flow_netlink.c b/net/openvswitch/flow_netlink.c
index 7f4707e70b38..a5129788dfc3 100644
--- a/net/openvswitch/flow_netlink.c
+++ b/net/openvswitch/flow_netlink.c
@@ -708,10 +708,11 @@ static int ipv4_tun_to_nlattr(struct sk_buff *skb,
 }
 
 int ovs_nla_put_egress_tunnel_key(struct sk_buff *skb,
-				  const struct ip_tunnel_info *egress_tun_info)
+				  const struct ip_tunnel_info *egress_tun_info,
+				  const void *egress_tun_opts)
 {
 	return __ipv4_tun_to_nlattr(skb, &egress_tun_info->key,
-				    egress_tun_info->options,
+				    egress_tun_opts,
 				    egress_tun_info->options_len);
 }
 
@@ -1828,20 +1829,14 @@ static int validate_and_copy_set_tun(const struct nlattr *attr,
 	tun_info = &tun_dst->u.tun_info;
 	tun_info->mode = IP_TUNNEL_INFO_TX;
 	tun_info->key = key.tun_key;
-	tun_info->options_len = key.tun_opts_len;
-
-	if (tun_info->options_len) {
-		/* We need to store the options in the action itself since
-		 * everything else will go away after flow setup. We can append
-		 * it to tun_info and then point there.
-		 */
-		memcpy((tun_info + 1),
-		       TUN_METADATA_OPTS(&key, key.tun_opts_len), key.tun_opts_len);
-		tun_info->options = (tun_info + 1);
-	} else {
-		tun_info->options = NULL;
-	}
 
+	/* We need to store the options in the action itself since
+	 * everything else will go away after flow setup. We can append
+	 * it to tun_info and then point there.
+	 */
+	ip_tunnel_info_opts_set(tun_info,
+				TUN_METADATA_OPTS(&key, key.tun_opts_len),
+				key.tun_opts_len);
 	add_nested_action_end(*sfa, start);
 
 	return err;
@@ -2287,7 +2282,7 @@ static int set_action_to_attr(const struct nlattr *a, struct sk_buff *skb)
 
 		err = ipv4_tun_to_nlattr(skb, &tun_info->key,
 					 tun_info->options_len ?
-						tun_info->options : NULL,
+					     ip_tunnel_info_opts(tun_info) : NULL,
 					 tun_info->options_len);
 		if (err)
 			return err;
diff --git a/net/openvswitch/flow_netlink.h b/net/openvswitch/flow_netlink.h
index acd074408f0a..7be16087b8af 100644
--- a/net/openvswitch/flow_netlink.h
+++ b/net/openvswitch/flow_netlink.h
@@ -55,7 +55,8 @@ int ovs_nla_put_mask(const struct sw_flow *flow, struct sk_buff *skb);
 int ovs_nla_get_match(struct sw_flow_match *, const struct nlattr *key,
 		      const struct nlattr *mask, bool log);
 int ovs_nla_put_egress_tunnel_key(struct sk_buff *,
-				  const struct ip_tunnel_info *);
+				  const struct ip_tunnel_info *,
+				  const void *egress_tun_opts);
 
 bool ovs_nla_get_ufid(struct sw_flow_id *, const struct nlattr *, bool log);
 int ovs_nla_get_identifier(struct sw_flow_id *sfid, const struct nlattr *ufid,
* Unmerged path net/openvswitch/vport-geneve.c
* Unmerged path net/openvswitch/vport-gre.c
* Unmerged path net/openvswitch/vport-vxlan.c
* Unmerged path net/openvswitch/vport.c
* Unmerged path net/openvswitch/vport.h
