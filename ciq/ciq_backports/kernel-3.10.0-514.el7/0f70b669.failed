Drivers: hv: vmbus: remove code duplication in message handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hv] vmbus: remove code duplication in message handling (Vitaly Kuznetsov) [1298093]
Rebuild_FUZZ: 88.50%
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 0f70b66975ce4331e9002b792d5aa6787a110181
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0f70b669.failed

We have 3 functions dealing with messages and they all implement
the same logic to finalize reads, move it to vmbus_signal_eom().

	Suggested-by: Radim Krcmar <rkrcmar@redhat.com>
	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Reviewed-by: Radim Kr.m√°<rkrcmar@redhat.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 0f70b66975ce4331e9002b792d5aa6787a110181)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/vmbus_drv.c
diff --cc drivers/hv/vmbus_drv.c
index 7882a259dbd0,6cd12f108a32..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -697,6 -702,16 +697,19 @@@ static void vmbus_onmessage_work(struc
  	kfree(ctx);
  }
  
++<<<<<<< HEAD
++=======
+ static void hv_process_timer_expiration(struct hv_message *msg, int cpu)
+ {
+ 	struct clock_event_device *dev = hv_context.clk_evt[cpu];
+ 
+ 	if (dev->event_handler)
+ 		dev->event_handler(dev);
+ 
+ 	vmbus_signal_eom(msg);
+ }
+ 
++>>>>>>> 0f70b66975ce (Drivers: hv: vmbus: remove code duplication in message handling)
  static void vmbus_on_msg_dpc(unsigned long data)
  {
  	int cpu = smp_processor_id();
diff --git a/drivers/hv/channel_mgmt.c b/drivers/hv/channel_mgmt.c
index b25210b45127..446599e48599 100644
--- a/drivers/hv/channel_mgmt.c
+++ b/drivers/hv/channel_mgmt.c
@@ -442,15 +442,7 @@ static void vmbus_wait_for_unload(void)
 		if (hdr->msgtype == CHANNELMSG_UNLOAD_RESPONSE)
 			unloaded = true;
 
-		msg->header.message_type = HVMSG_NONE;
-		/*
-		 * header.message_type needs to be written before we do
-		 * wrmsrl() below.
-		 */
-		mb();
-
-		if (msg->header.message_flags.msg_pending)
-			wrmsrl(HV_X64_MSR_EOM, 0);
+		vmbus_signal_eom(msg);
 
 		if (unloaded)
 			break;
diff --git a/drivers/hv/hyperv_vmbus.h b/drivers/hv/hyperv_vmbus.h
index ef1ffc73684b..919def556ccc 100644
--- a/drivers/hv/hyperv_vmbus.h
+++ b/drivers/hv/hyperv_vmbus.h
@@ -684,6 +684,30 @@ struct vmbus_channel_message_table_entry {
 extern struct vmbus_channel_message_table_entry
 	channel_message_table[CHANNELMSG_COUNT];
 
+/* Free the message slot and signal end-of-message if required */
+static inline void vmbus_signal_eom(struct hv_message *msg)
+{
+	msg->header.message_type = HVMSG_NONE;
+
+	/*
+	 * Make sure the write to MessageType (ie set to
+	 * HVMSG_NONE) happens before we read the
+	 * MessagePending and EOMing. Otherwise, the EOMing
+	 * will not deliver any more messages since there is
+	 * no empty slot
+	 */
+	mb();
+
+	if (msg->header.message_flags.msg_pending) {
+		/*
+		 * This will cause message queue rescan to
+		 * possibly deliver another msg from the
+		 * hypervisor
+		 */
+		wrmsrl(HV_X64_MSR_EOM, 0);
+	}
+}
+
 /* General vmbus interface */
 
 struct hv_device *vmbus_device_create(uuid_le *type,
* Unmerged path drivers/hv/vmbus_drv.c
