IB/qib: Use address handle in rdmavt and remove from qib

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit 96ab1ac13f444e72d353fdd94b2cfacaaaef9de9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/96ab1ac1.failed

Original patch from Kamal Heib <kamalh@mellanox.com>, split
apart from original.

Remove AH from qib and use rdmavt version.

	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Kamal Heib <kamalh@mellanox.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 96ab1ac13f444e72d353fdd94b2cfacaaaef9de9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/qib/qib_qp.c
#	drivers/infiniband/hw/qib/qib_ruc.c
#	drivers/infiniband/hw/qib/qib_ud.c
#	drivers/infiniband/hw/qib/qib_verbs.c
#	drivers/infiniband/hw/qib/qib_verbs.h
diff --cc drivers/infiniband/hw/qib/qib_qp.c
index cf1dd6e9d434,6c023f7ee3ed..000000000000
--- a/drivers/infiniband/hw/qib/qib_qp.c
+++ b/drivers/infiniband/hw/qib/qib_qp.c
@@@ -439,7 -439,8 +439,12 @@@ static void clear_mr_refs(struct qib_q
  			if (qp->ibqp.qp_type == IB_QPT_UD ||
  			    qp->ibqp.qp_type == IB_QPT_SMI ||
  			    qp->ibqp.qp_type == IB_QPT_GSI)
++<<<<<<< HEAD
 +				atomic_dec(&to_iah(wqe->wr.wr.ud.ah)->refcount);
++=======
+ 				atomic_dec(
+ 				 &ibah_to_rvtah(wqe->ud_wr.ah)->refcount);
++>>>>>>> 96ab1ac13f44 (IB/qib: Use address handle in rdmavt and remove from qib)
  			if (++qp->s_last >= qp->s_size)
  				qp->s_last = 0;
  		}
@@@ -594,16 -595,17 +599,16 @@@ int qib_modify_qp(struct ib_qp *ibqp, s
  		goto inval;
  
  	if (attr_mask & IB_QP_AV) {
 -		if (attr->ah_attr.dlid >= be16_to_cpu(IB_MULTICAST_LID_BASE))
 +		if (attr->ah_attr.dlid >= QIB_MULTICAST_LID_BASE)
  			goto inval;
- 		if (qib_check_ah(qp->ibqp.device, &attr->ah_attr))
+ 		if (rvt_check_ah(qp->ibqp.device, &attr->ah_attr))
  			goto inval;
  	}
  
  	if (attr_mask & IB_QP_ALT_PATH) {
 -		if (attr->alt_ah_attr.dlid >=
 -		    be16_to_cpu(IB_MULTICAST_LID_BASE))
 +		if (attr->alt_ah_attr.dlid >= QIB_MULTICAST_LID_BASE)
  			goto inval;
- 		if (qib_check_ah(qp->ibqp.device, &attr->alt_ah_attr))
+ 		if (rvt_check_ah(qp->ibqp.device, &attr->alt_ah_attr))
  			goto inval;
  		if (attr->alt_pkey_index >= qib_get_npkeys(dd_from_dev(dev)))
  			goto inval;
diff --cc drivers/infiniband/hw/qib/qib_ruc.c
index e9132f7a68b0,39004594e15b..000000000000
--- a/drivers/infiniband/hw/qib/qib_ruc.c
+++ b/drivers/infiniband/hw/qib/qib_ruc.c
@@@ -789,7 -789,7 +789,11 @@@ void qib_send_complete(struct qib_qp *q
  	if (qp->ibqp.qp_type == IB_QPT_UD ||
  	    qp->ibqp.qp_type == IB_QPT_SMI ||
  	    qp->ibqp.qp_type == IB_QPT_GSI)
++<<<<<<< HEAD
 +		atomic_dec(&to_iah(wqe->wr.wr.ud.ah)->refcount);
++=======
+ 		atomic_dec(&ibah_to_rvtah(wqe->ud_wr.ah)->refcount);
++>>>>>>> 96ab1ac13f44 (IB/qib: Use address handle in rdmavt and remove from qib)
  
  	/* See ch. 11.2.4.1 and 10.7.3.1 */
  	if (!(qp->s_flags & QIB_S_SIGNAL_REQ_WR) ||
diff --cc drivers/infiniband/hw/qib/qib_ud.c
index 75faa5bd8dd6,6dc20cabab66..000000000000
--- a/drivers/infiniband/hw/qib/qib_ud.c
+++ b/drivers/infiniband/hw/qib/qib_ud.c
@@@ -76,7 -77,7 +76,11 @@@ static void qib_ud_loopback(struct qib_
  		goto drop;
  	}
  
++<<<<<<< HEAD
 +	ah_attr = &to_iah(swqe->wr.wr.ud.ah)->attr;
++=======
+ 	ah_attr = &ibah_to_rvtah(swqe->ud_wr.ah)->attr;
++>>>>>>> 96ab1ac13f44 (IB/qib: Use address handle in rdmavt and remove from qib)
  	ppd = ppd_from_ibp(ibp);
  
  	if (qp->ibqp.qp_num > 1) {
@@@ -278,9 -279,9 +282,15 @@@ int qib_make_ud_req(struct qib_qp *qp
  	/* Construct the header. */
  	ibp = to_iport(qp->ibqp.device, qp->port_num);
  	ppd = ppd_from_ibp(ibp);
++<<<<<<< HEAD
 +	ah_attr = &to_iah(wqe->wr.wr.ud.ah)->attr;
 +	if (ah_attr->dlid >= QIB_MULTICAST_LID_BASE) {
 +		if (ah_attr->dlid != QIB_PERMISSIVE_LID)
++=======
+ 	ah_attr = &ibah_to_rvtah(wqe->ud_wr.ah)->attr;
+ 	if (ah_attr->dlid >= be16_to_cpu(IB_MULTICAST_LID_BASE)) {
+ 		if (ah_attr->dlid != be16_to_cpu(IB_LID_PERMISSIVE))
++>>>>>>> 96ab1ac13f44 (IB/qib: Use address handle in rdmavt and remove from qib)
  			this_cpu_inc(ibp->pmastats->n_multicast_xmit);
  		else
  			this_cpu_inc(ibp->pmastats->n_unicast_xmit);
diff --cc drivers/infiniband/hw/qib/qib_verbs.c
index c4417a1f33be,89fe514a4981..000000000000
--- a/drivers/infiniband/hw/qib/qib_verbs.c
+++ b/drivers/infiniband/hw/qib/qib_verbs.c
@@@ -423,11 -437,15 +423,18 @@@ static int qib_post_one_send(struct qib
  	    qp->ibqp.qp_type == IB_QPT_RC) {
  		if (wqe->length > 0x80000000U)
  			goto bail_inval_free;
 -		if (wqe->length <= qp->pmtu)
 -			avoid_schedule = 1;
  	} else if (wqe->length > (dd_from_ibdev(qp->ibqp.device)->pport +
 -				  qp->port_num - 1)->ibmtu) {
 +				  qp->port_num - 1)->ibmtu)
  		goto bail_inval_free;
++<<<<<<< HEAD
 +	else
 +		atomic_inc(&to_iah(wr->wr.ud.ah)->refcount);
++=======
+ 	} else {
+ 		atomic_inc(&ibah_to_rvtah(ud_wr(wr)->ah)->refcount);
+ 		avoid_schedule = 1;
+ 	}
++>>>>>>> 96ab1ac13f44 (IB/qib: Use address handle in rdmavt and remove from qib)
  	wqe->ssn = qp->s_ssn++;
  	qp->s_head = next;
  
@@@ -1751,131 -1769,12 +1758,67 @@@ static int qib_query_gid(struct ib_devi
  	return ret;
  }
  
 +static struct ib_pd *qib_alloc_pd(struct ib_device *ibdev,
 +				  struct ib_ucontext *context,
 +				  struct ib_udata *udata)
 +{
 +	struct qib_ibdev *dev = to_idev(ibdev);
 +	struct qib_pd *pd;
 +	struct ib_pd *ret;
 +
 +	/*
 +	 * This is actually totally arbitrary.  Some correctness tests
 +	 * assume there's a maximum number of PDs that can be allocated.
 +	 * We don't actually have this limit, but we fail the test if
 +	 * we allow allocations of more than we report for this value.
 +	 */
 +
 +	pd = kmalloc(sizeof(*pd), GFP_KERNEL);
 +	if (!pd) {
 +		ret = ERR_PTR(-ENOMEM);
 +		goto bail;
 +	}
 +
 +	spin_lock(&dev->n_pds_lock);
 +	if (dev->n_pds_allocated == ib_qib_max_pds) {
 +		spin_unlock(&dev->n_pds_lock);
 +		kfree(pd);
 +		ret = ERR_PTR(-ENOMEM);
 +		goto bail;
 +	}
 +
 +	dev->n_pds_allocated++;
 +	spin_unlock(&dev->n_pds_lock);
 +
 +	/* ib_alloc_pd() will initialize pd->ibpd. */
 +	pd->user = udata != NULL;
 +
 +	ret = &pd->ibpd;
 +
 +bail:
 +	return ret;
 +}
 +
 +static int qib_dealloc_pd(struct ib_pd *ibpd)
 +{
 +	struct qib_pd *pd = to_ipd(ibpd);
 +	struct qib_ibdev *dev = to_idev(ibpd->device);
 +
 +	spin_lock(&dev->n_pds_lock);
 +	dev->n_pds_allocated--;
 +	spin_unlock(&dev->n_pds_lock);
 +
 +	kfree(pd);
 +
 +	return 0;
 +}
 +
  int qib_check_ah(struct ib_device *ibdev, struct ib_ah_attr *ah_attr)
  {
- 	/* A multicast address requires a GRH (see ch. 8.4.1). */
- 	if (ah_attr->dlid >= be16_to_cpu(IB_MULTICAST_LID_BASE) &&
- 	    ah_attr->dlid != be16_to_cpu(IB_LID_PERMISSIVE) &&
- 	    !(ah_attr->ah_flags & IB_AH_GRH))
- 		goto bail;
- 	if ((ah_attr->ah_flags & IB_AH_GRH) &&
- 	    ah_attr->grh.sgid_index >= QIB_GUIDS_PER_PORT)
- 		goto bail;
- 	if (ah_attr->dlid == 0)
- 		goto bail;
- 	if (ah_attr->port_num < 1 ||
- 	    ah_attr->port_num > ibdev->phys_port_cnt)
- 		goto bail;
- 	if (ah_attr->static_rate != IB_RATE_PORT_CURRENT &&
- 	    ib_rate_to_mult(ah_attr->static_rate) < 0)
- 		goto bail;
  	if (ah_attr->sl > 15)
- 		goto bail;
- 	return 0;
- bail:
- 	return -EINVAL;
- }
- 
- /**
-  * qib_create_ah - create an address handle
-  * @pd: the protection domain
-  * @ah_attr: the attributes of the AH
-  *
-  * This may be called from interrupt context.
-  */
- static struct ib_ah *qib_create_ah(struct ib_pd *pd,
- 				   struct ib_ah_attr *ah_attr)
- {
- 	struct qib_ah *ah;
- 	struct ib_ah *ret;
- 	struct qib_ibdev *dev = to_idev(pd->device);
- 	unsigned long flags;
- 
- 	if (qib_check_ah(pd->device, ah_attr)) {
- 		ret = ERR_PTR(-EINVAL);
- 		goto bail;
- 	}
- 
- 	ah = kmalloc(sizeof(*ah), GFP_ATOMIC);
- 	if (!ah) {
- 		ret = ERR_PTR(-ENOMEM);
- 		goto bail;
- 	}
- 
- 	spin_lock_irqsave(&dev->n_ahs_lock, flags);
- 	if (dev->n_ahs_allocated == ib_qib_max_ahs) {
- 		spin_unlock_irqrestore(&dev->n_ahs_lock, flags);
- 		kfree(ah);
- 		ret = ERR_PTR(-ENOMEM);
- 		goto bail;
- 	}
- 
- 	dev->n_ahs_allocated++;
- 	spin_unlock_irqrestore(&dev->n_ahs_lock, flags);
- 
- 	/* ib_create_ah() will initialize ah->ibah. */
- 	ah->attr = *ah_attr;
- 	atomic_set(&ah->refcount, 0);
- 
- 	ret = &ah->ibah;
+ 		return -EINVAL;
  
- bail:
- 	return ret;
+ 	return 0;
  }
  
  struct ib_ah *qib_create_qp0_ah(struct qib_ibport *ibp, u16 dlid)
@@@ -2110,8 -1964,6 +2008,11 @@@ int qib_register_ib_device(struct qib_d
  
  	/* Only need to initialize non-zero fields. */
  	spin_lock_init(&dev->qpt_lock);
++<<<<<<< HEAD
 +	spin_lock_init(&dev->n_pds_lock);
 +	spin_lock_init(&dev->n_ahs_lock);
++=======
++>>>>>>> 96ab1ac13f44 (IB/qib: Use address handle in rdmavt and remove from qib)
  	spin_lock_init(&dev->n_cqs_lock);
  	spin_lock_init(&dev->n_qps_lock);
  	spin_lock_init(&dev->n_srqs_lock);
@@@ -2234,12 -2063,12 +2135,21 @@@
  	ibdev->query_gid = qib_query_gid;
  	ibdev->alloc_ucontext = qib_alloc_ucontext;
  	ibdev->dealloc_ucontext = qib_dealloc_ucontext;
++<<<<<<< HEAD
 +	ibdev->alloc_pd = qib_alloc_pd;
 +	ibdev->dealloc_pd = qib_dealloc_pd;
 +	ibdev->create_ah = qib_create_ah;
 +	ibdev->destroy_ah = qib_destroy_ah;
 +	ibdev->modify_ah = qib_modify_ah;
 +	ibdev->query_ah = qib_query_ah;
++=======
+ 	ibdev->alloc_pd = NULL;
+ 	ibdev->dealloc_pd = NULL;
+ 	ibdev->create_ah = NULL;
+ 	ibdev->destroy_ah = NULL;
+ 	ibdev->modify_ah = NULL;
+ 	ibdev->query_ah = NULL;
++>>>>>>> 96ab1ac13f44 (IB/qib: Use address handle in rdmavt and remove from qib)
  	ibdev->create_srq = qib_create_srq;
  	ibdev->modify_srq = qib_modify_srq;
  	ibdev->query_srq = qib_query_srq;
@@@ -2283,11 -2110,12 +2193,17 @@@
  	dd->verbs_dev.rdi.driver_f.port_callback = qib_create_port_files;
  	dd->verbs_dev.rdi.driver_f.get_card_name = qib_get_card_name;
  	dd->verbs_dev.rdi.driver_f.get_pci_dev = qib_get_pci_dev;
+ 	dd->verbs_dev.rdi.driver_f.check_ah = qib_check_ah;
  	dd->verbs_dev.rdi.dparms.props.max_pd = ib_qib_max_pds;
++<<<<<<< HEAD
 +	dd->verbs_dev.rdi.flags = (RVT_FLAG_MR_INIT_DRIVER |
 +				   RVT_FLAG_QP_INIT_DRIVER |
++=======
+ 	dd->verbs_dev.rdi.dparms.props.max_ah = ib_qib_max_ahs;
+ 	dd->verbs_dev.rdi.flags = (RVT_FLAG_QP_INIT_DRIVER |
++>>>>>>> 96ab1ac13f44 (IB/qib: Use address handle in rdmavt and remove from qib)
  				   RVT_FLAG_CQ_INIT_DRIVER);
 -	dd->verbs_dev.rdi.dparms.lkey_table_size = qib_lkey_table_size;
 +
  
  	ret = rvt_register_device(&dd->verbs_dev.rdi);
  	if (ret)
diff --cc drivers/infiniband/hw/qib/qib_verbs.h
index ca366073af4f,a9d7f0a8cd02..000000000000
--- a/drivers/infiniband/hw/qib/qib_verbs.h
+++ b/drivers/infiniband/hw/qib/qib_verbs.h
@@@ -222,33 -222,6 +222,36 @@@ struct qib_mcast 
  	int n_attached;
  };
  
++<<<<<<< HEAD
 +/* Protection domain */
 +struct qib_pd {
 +	struct ib_pd ibpd;
 +	int user;               /* non-zero if created from user space */
 +};
 +
 +/* Address Handle */
 +struct qib_ah {
 +	struct ib_ah ibah;
 +	struct ib_ah_attr attr;
 +	atomic_t refcount;
 +};
 +
++=======
++>>>>>>> 96ab1ac13f44 (IB/qib: Use address handle in rdmavt and remove from qib)
 +/*
 + * This structure is used by qib_mmap() to validate an offset
 + * when an mmap() request is made.  The vm_area_struct then uses
 + * this as its vm_private_data.
 + */
 +struct qib_mmap_info {
 +	struct list_head pending_mmaps;
 +	struct ib_ucontext *context;
 +	void *obj;
 +	__u64 offset;
 +	struct kref ref;
 +	unsigned size;
 +};
 +
  /*
   * This structure is used to contain the head pointer, tail pointer,
   * and completion queue entries as a single memory allocation so
@@@ -685,11 -409,11 +688,11 @@@ struct qib_pma_counters 
  };
  
  struct qib_ibport {
 -	struct rvt_qp __rcu *qp0;
 -	struct rvt_qp __rcu *qp1;
 +	struct qib_qp __rcu *qp0;
 +	struct qib_qp __rcu *qp1;
  	struct ib_mad_agent *send_agent;	/* agent for SMI (traps) */
- 	struct qib_ah *sm_ah;
- 	struct qib_ah *smi_ah;
+ 	struct rvt_ah *sm_ah;
+ 	struct rvt_ah *smi_ah;
  	struct rb_root mcast_tree;
  	spinlock_t lock;		/* protect changes in this struct */
  
@@@ -816,21 -534,6 +815,24 @@@ struct qib_verbs_counters 
  	u32 vl15_dropped;
  };
  
++<<<<<<< HEAD
 +static inline struct qib_mr *to_imr(struct ib_mr *ibmr)
 +{
 +	return container_of(ibmr, struct qib_mr, ibmr);
 +}
 +
 +static inline struct qib_pd *to_ipd(struct ib_pd *ibpd)
 +{
 +	return container_of(ibpd, struct qib_pd, ibpd);
 +}
 +
 +static inline struct qib_ah *to_iah(struct ib_ah *ibah)
 +{
 +	return container_of(ibah, struct qib_ah, ibah);
 +}
 +
++=======
++>>>>>>> 96ab1ac13f44 (IB/qib: Use address handle in rdmavt and remove from qib)
  static inline struct qib_cq *to_icq(struct ib_cq *ibcq)
  {
  	return container_of(ibcq, struct qib_cq, ibcq);
diff --git a/drivers/infiniband/hw/qib/qib_iba7322.c b/drivers/infiniband/hw/qib/qib_iba7322.c
index 181e226c8045..aa876bb7a060 100644
--- a/drivers/infiniband/hw/qib/qib_iba7322.c
+++ b/drivers/infiniband/hw/qib/qib_iba7322.c
@@ -5515,7 +5515,7 @@ static void try_7322_ipg(struct qib_pportdata *ppd)
 			ret = PTR_ERR(ah);
 		else {
 			send_buf->ah = ah;
-			ibp->smi_ah = to_iah(ah);
+			ibp->smi_ah = ibah_to_rvtah(ah);
 			ret = 0;
 		}
 	} else {
diff --git a/drivers/infiniband/hw/qib/qib_mad.c b/drivers/infiniband/hw/qib/qib_mad.c
index c65d3aac236c..bd5fa8799cc3 100644
--- a/drivers/infiniband/hw/qib/qib_mad.c
+++ b/drivers/infiniband/hw/qib/qib_mad.c
@@ -109,7 +109,7 @@ static void qib_send_trap(struct qib_ibport *ibp, void *data, unsigned len)
 				ret = PTR_ERR(ah);
 			else {
 				send_buf->ah = ah;
-				ibp->sm_ah = to_iah(ah);
+				ibp->sm_ah = ibah_to_rvtah(ah);
 				ret = 0;
 			}
 		} else
* Unmerged path drivers/infiniband/hw/qib/qib_qp.c
* Unmerged path drivers/infiniband/hw/qib/qib_ruc.c
* Unmerged path drivers/infiniband/hw/qib/qib_ud.c
* Unmerged path drivers/infiniband/hw/qib/qib_verbs.c
* Unmerged path drivers/infiniband/hw/qib/qib_verbs.h
