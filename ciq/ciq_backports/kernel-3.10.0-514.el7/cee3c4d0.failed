IB/core: don't search the GID table twice

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matan Barak <matanb@mellanox.com>
commit cee3c4d0c56876f46f4584385603adb30a7cacf7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/cee3c4d0.failed

Previously, we've searched the GID table twice: first when we searched
the table for a GID matching the proposed new one, and second when we
didn't find a match, we searched again for an empty GID slot in the
table.  Instead, search the table once noting the first empty slot as
we search for our target GID.

	Signed-off-by: Matan Barak <matanb@mellanox.com>
	Reviewed-by: Haggai Eran <haggaie@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit cee3c4d0c56876f46f4584385603adb30a7cacf7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cache.c
diff --cc drivers/infiniband/core/cache.c
index 77177fb6d68f,bfd0a659fdc0..000000000000
--- a/drivers/infiniband/core/cache.c
+++ b/drivers/infiniband/core/cache.c
@@@ -208,41 -205,54 +208,78 @@@ static int del_gid(struct ib_device *ib
  			 GID_TABLE_WRITE_ACTION_DEL, default_gid);
  }
  
 -/* rwlock should be read locked */
  static int find_gid(struct ib_gid_table *table, const union ib_gid *gid,
  		    const struct ib_gid_attr *val, bool default_gid,
- 		    unsigned long mask)
+ 		    unsigned long mask, int *pempty)
  {
- 	int i;
+ 	int i = 0;
+ 	int found = -1;
+ 	int empty = pempty ? -1 : 0;
  
++<<<<<<< HEAD
 +	for (i = 0; i < table->sz; i++) {
 +		unsigned long flags;
 +		struct ib_gid_attr *attr = &table->data_vec[i].attr;
 +
 +		read_lock_irqsave(&table->data_vec[i].lock, flags);
 +
 +		if (table->data_vec[i].props & GID_TABLE_ENTRY_INVALID)
 +			goto next;
 +
 +		if (mask & GID_ATTR_FIND_MASK_GID &&
 +		    memcmp(gid, &table->data_vec[i].gid, sizeof(*gid)))
 +			goto next;
++=======
+ 	while (i < table->sz && (found < 0 || empty < 0)) {
+ 		struct ib_gid_table_entry *data = &table->data_vec[i];
+ 		struct ib_gid_attr *attr = &data->attr;
+ 		int curr_index = i;
+ 
+ 		i++;
+ 
+ 		if (data->props & GID_TABLE_ENTRY_INVALID)
+ 			continue;
+ 
+ 		if (empty < 0)
+ 			if (!memcmp(&data->gid, &zgid, sizeof(*gid)) &&
+ 			    !memcmp(attr, &zattr, sizeof(*attr)) &&
+ 			    !data->props)
+ 				empty = curr_index;
+ 
+ 		if (found >= 0)
+ 			continue;
+ 
+ 		if (mask & GID_ATTR_FIND_MASK_GID &&
+ 		    memcmp(gid, &data->gid, sizeof(*gid)))
+ 			continue;
++>>>>>>> cee3c4d0c568 (IB/core: don't search the GID table twice)
  
  		if (mask & GID_ATTR_FIND_MASK_NETDEV &&
  		    attr->ndev != val->ndev)
 -			continue;
 +			goto next;
  
  		if (mask & GID_ATTR_FIND_MASK_DEFAULT &&
- 		    !!(table->data_vec[i].props & GID_TABLE_ENTRY_DEFAULT) !=
+ 		    !!(data->props & GID_TABLE_ENTRY_DEFAULT) !=
  		    default_gid)
 -			continue;
 +			goto next;
  
++<<<<<<< HEAD
 +		read_unlock_irqrestore(&table->data_vec[i].lock, flags);
 +		return i;
 +next:
 +		read_unlock_irqrestore(&table->data_vec[i].lock, flags);
 +	}
 +
 +	return -1;
++=======
+ 		found = curr_index;
+ 	}
+ 
+ 	if (pempty)
+ 		*pempty = empty;
+ 
+ 	return found;
++>>>>>>> cee3c4d0c568 (IB/core: don't search the GID table twice)
  }
  
  static void make_default_gid(struct  net_device *dev, union ib_gid *gid)
@@@ -282,9 -293,10 +320,9 @@@ int ib_cache_gid_add(struct ib_device *
  	}
  
  	mutex_lock(&table->lock);
 -	write_lock_irq(&table->rwlock);
  
  	ix = find_gid(table, gid, attr, false, GID_ATTR_FIND_MASK_GID |
- 		      GID_ATTR_FIND_MASK_NETDEV);
+ 		      GID_ATTR_FIND_MASK_NETDEV, &empty);
  	if (ix >= 0)
  		goto out_unlock;
  
@@@ -295,9 -305,12 +331,15 @@@
  		goto out_unlock;
  	}
  
++<<<<<<< HEAD
 +	add_gid(ib_dev, port, table, ix, gid, attr, false);
++=======
+ 	ret = add_gid(ib_dev, port, table, empty, gid, attr, false);
+ 	if (!ret)
+ 		dispatch_gid_change_event(ib_dev, port);
++>>>>>>> cee3c4d0c568 (IB/core: don't search the GID table twice)
  
  out_unlock:
 -	write_unlock_irq(&table->rwlock);
  	mutex_unlock(&table->lock);
  	return ret;
  }
@@@ -388,7 -408,9 +431,12 @@@ static int _ib_cache_gid_table_find(str
  
  	for (p = 0; p < ib_dev->phys_port_cnt; p++) {
  		table = ports_table[p];
++<<<<<<< HEAD
 +		local_index = find_gid(table, gid, val, false, mask);
++=======
+ 		read_lock_irqsave(&table->rwlock, flags);
+ 		local_index = find_gid(table, gid, val, false, mask, NULL);
++>>>>>>> cee3c4d0c568 (IB/core: don't search the GID table twice)
  		if (local_index >= 0) {
  			if (index)
  				*index = local_index;
@@@ -436,7 -461,8 +484,12 @@@ int ib_cache_gid_find_by_port(struct ib
  	if (ndev)
  		mask |= GID_ATTR_FIND_MASK_NETDEV;
  
++<<<<<<< HEAD
 +	local_index = find_gid(table, gid, &val, false, mask);
++=======
+ 	read_lock_irqsave(&table->rwlock, flags);
+ 	local_index = find_gid(table, gid, &val, false, mask, NULL);
++>>>>>>> cee3c4d0c568 (IB/core: don't search the GID table twice)
  	if (local_index >= 0) {
  		if (index)
  			*index = local_index;
@@@ -516,7 -624,8 +569,12 @@@ void ib_cache_gid_set_default_gid(struc
  	gid_attr.ndev = ndev;
  
  	mutex_lock(&table->lock);
++<<<<<<< HEAD
 +	ix = find_gid(table, NULL, NULL, true, GID_ATTR_FIND_MASK_DEFAULT);
++=======
+ 	write_lock_irq(&table->rwlock);
+ 	ix = find_gid(table, NULL, NULL, true, GID_ATTR_FIND_MASK_DEFAULT, NULL);
++>>>>>>> cee3c4d0c568 (IB/core: don't search the GID table twice)
  
  	/* Coudn't find default GID location */
  	WARN_ON(ix < 0);
* Unmerged path drivers/infiniband/core/cache.c
