IB/srp: Fix srp_map_sg_fr()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit 57b0be9c0fb0ba3a35683c6ce21db7162d6758c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/57b0be9c.failed

After dma_map_sg() has been called the return value of that function
must be used as the number of elements in the scatterlist instead of
scsi_sg_count().

Fixes: commit f7f7aab1a5c0 ("IB/srp: Convert to new registration API")
	Reported-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Cc: stable <stable@vger.kernel.org> # v4.4+
	Cc: Sagi Grimberg <sagig@mellanox.com>
	Cc: Sebastian Parschauer <sebastian.riemer@profitbricks.com>
	Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 57b0be9c0fb0ba3a35683c6ce21db7162d6758c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/srp/ib_srp.c
diff --cc drivers/infiniband/ulp/srp/ib_srp.c
index a027d8cfc569,3db9a659719b..000000000000
--- a/drivers/infiniband/ulp/srp/ib_srp.c
+++ b/drivers/infiniband/ulp/srp/ib_srp.c
@@@ -1318,6 -1326,18 +1318,21 @@@ static int srp_map_finish_fr(struct srp
  	if (state->fr.next >= state->fr.end)
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	WARN_ON_ONCE(!dev->use_fast_reg);
+ 
+ 	if (sg_nents == 0)
+ 		return 0;
+ 
+ 	if (sg_nents == 1 && target->global_mr) {
+ 		srp_map_desc(state, sg_dma_address(state->sg),
+ 			     sg_dma_len(state->sg),
+ 			     target->global_mr->rkey);
+ 		return 1;
+ 	}
+ 
++>>>>>>> 57b0be9c0fb0 (IB/srp: Fix srp_map_sg_fr())
  	desc = srp_fr_pool_get(ch->fr_pool);
  	if (!desc)
  		return -ENOMEM;
@@@ -1325,21 -1345,20 +1340,27 @@@
  	rkey = ib_inc_rkey(desc->mr->rkey);
  	ib_update_fast_reg_key(desc->mr, rkey);
  
++<<<<<<< HEAD
 +	memcpy(desc->frpl->page_list, state->pages,
 +	       sizeof(state->pages[0]) * state->npages);
++=======
+ 	n = ib_map_mr_sg(desc->mr, state->sg, sg_nents, dev->mr_page_size);
+ 	if (unlikely(n < 0))
+ 		return n;
 -
 -	wr.wr.next = NULL;
 -	wr.wr.opcode = IB_WR_REG_MR;
 -	wr.wr.wr_id = FAST_REG_WR_ID_MASK;
 -	wr.wr.num_sge = 0;
 -	wr.wr.send_flags = 0;
 -	wr.mr = desc->mr;
 -	wr.key = desc->mr->rkey;
 -	wr.access = (IB_ACCESS_LOCAL_WRITE |
 -		     IB_ACCESS_REMOTE_READ |
 -		     IB_ACCESS_REMOTE_WRITE);
++>>>>>>> 57b0be9c0fb0 (IB/srp: Fix srp_map_sg_fr())
 +
 +	memset(&wr, 0, sizeof(wr));
 +	wr.opcode = IB_WR_FAST_REG_MR;
 +	wr.wr_id = FAST_REG_WR_ID_MASK;
 +	wr.wr.fast_reg.iova_start = state->base_dma_addr;
 +	wr.wr.fast_reg.page_list = desc->frpl;
 +	wr.wr.fast_reg.page_list_len = state->npages;
 +	wr.wr.fast_reg.page_shift = ilog2(dev->mr_page_size);
 +	wr.wr.fast_reg.length = state->dma_len;
 +	wr.wr.fast_reg.access_flags = (IB_ACCESS_LOCAL_WRITE |
 +				       IB_ACCESS_REMOTE_READ |
 +				       IB_ACCESS_REMOTE_WRITE);
 +	wr.wr.fast_reg.rkey = desc->mr->lkey;
  
  	*state->fr.next++ = desc;
  	state->nmdesc++;
@@@ -1420,9 -1416,62 +1441,68 @@@ static int srp_map_sg_entry(struct srp_
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int srp_map_sg(struct srp_map_state *state, struct srp_rdma_ch *ch,
 +		      struct srp_request *req, struct scatterlist *scat,
 +		      int count)
++=======
+ static int srp_map_sg_fmr(struct srp_map_state *state, struct srp_rdma_ch *ch,
+ 			  struct srp_request *req, struct scatterlist *scat,
+ 			  int count)
+ {
+ 	struct scatterlist *sg;
+ 	int i, ret;
+ 
+ 	state->desc = req->indirect_desc;
+ 	state->pages = req->map_page;
+ 	state->fmr.next = req->fmr_list;
+ 	state->fmr.end = req->fmr_list + ch->target->cmd_sg_cnt;
+ 
+ 	for_each_sg(scat, sg, count, i) {
+ 		ret = srp_map_sg_entry(state, ch, sg, i);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	ret = srp_map_finish_fmr(state, ch);
+ 	if (ret)
+ 		return ret;
+ 
+ 	req->nmdesc = state->nmdesc;
+ 
+ 	return 0;
+ }
+ 
+ static int srp_map_sg_fr(struct srp_map_state *state, struct srp_rdma_ch *ch,
+ 			 struct srp_request *req, struct scatterlist *scat,
+ 			 int count)
+ {
+ 	state->desc = req->indirect_desc;
+ 	state->fr.next = req->fr_list;
+ 	state->fr.end = req->fr_list + ch->target->cmd_sg_cnt;
+ 	state->sg = scat;
+ 
+ 	while (count) {
+ 		int i, n;
+ 
+ 		n = srp_map_finish_fr(state, ch, count);
+ 		if (unlikely(n < 0))
+ 			return n;
+ 
+ 		count -= n;
+ 		for (i = 0; i < n; i++)
+ 			state->sg = sg_next(state->sg);
+ 	}
+ 
+ 	req->nmdesc = state->nmdesc;
+ 
+ 	return 0;
+ }
+ 
+ static int srp_map_sg_dma(struct srp_map_state *state, struct srp_rdma_ch *ch,
+ 			  struct srp_request *req, struct scatterlist *scat,
+ 			  int count)
++>>>>>>> 57b0be9c0fb0 (IB/srp: Fix srp_map_sg_fr())
  {
  	struct srp_target_port *target = ch->target;
  	struct srp_device *dev = target->srp_host->srp_dev;
@@@ -1486,15 -1514,30 +1566,40 @@@ static int srp_map_idb(struct srp_rdma_
  	state.gen.next = next_mr;
  	state.gen.end = end_mr;
  	state.desc = &idb_desc;
 +	state.pages = idb_pages;
 +	state.pages[0] = (req->indirect_dma_addr &
 +			  dev->mr_page_mask);
 +	state.npages = 1;
  	state.base_dma_addr = req->indirect_dma_addr;
  	state.dma_len = idb_len;
++<<<<<<< HEAD
 +	ret = srp_finish_mapping(&state, ch);
 +	if (ret < 0)
 +		goto out;
++=======
+ 
+ 	if (dev->use_fast_reg) {
+ 		state.sg = idb_sg;
+ 		sg_set_buf(idb_sg, req->indirect_desc, idb_len);
+ 		idb_sg->dma_address = req->indirect_dma_addr; /* hack! */
+ #ifdef CONFIG_NEED_SG_DMA_LENGTH
+ 		idb_sg->dma_length = idb_sg->length;	      /* hack^2 */
+ #endif
+ 		ret = srp_map_finish_fr(&state, ch, 1);
+ 		if (ret < 0)
+ 			return ret;
+ 	} else if (dev->use_fmr) {
+ 		state.pages = idb_pages;
+ 		state.pages[0] = (req->indirect_dma_addr &
+ 				  dev->mr_page_mask);
+ 		state.npages = 1;
+ 		ret = srp_map_finish_fmr(&state, ch);
+ 		if (ret < 0)
+ 			return ret;
+ 	} else {
+ 		return -EINVAL;
+ 	}
++>>>>>>> 57b0be9c0fb0 (IB/srp: Fix srp_map_sg_fr())
  
  	*idb_rkey = idb_desc.key;
  
* Unmerged path drivers/infiniband/ulp/srp/ib_srp.c
