mei: bus: add and call callback on notify event

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit bb2ef9c39db2e3c2562b4e439b2b00dc42e2c026
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bb2ef9c3.failed

Enable drivers on mei client bus to subscribe
to asynchronous event notifications.
Introduce events_mask to the existing callback infrastructure
so it is possible to handle both RX and event notification.

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit bb2ef9c39db2e3c2562b4e439b2b00dc42e2c026)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/bus.c
#	drivers/misc/mei/client.c
#	drivers/misc/mei/mei_dev.h
#	drivers/nfc/mei_phy.c
#	include/linux/mei_cl_bus.h
diff --cc drivers/misc/mei/bus.c
index 3365981198e7,eef1c6b46ad8..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -31,23 -30,442 +31,446 @@@
  #define to_mei_cl_driver(d) container_of(d, struct mei_cl_driver, driver)
  #define to_mei_cl_device(d) container_of(d, struct mei_cl_device, dev)
  
++<<<<<<< HEAD
 +static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
++=======
+ /**
+  * __mei_cl_send - internal client send (write)
+  *
+  * @cl: host client
+  * @buf: buffer to send
+  * @length: buffer length
+  * @blocking: wait for write completion
+  *
+  * Return: written size bytes or < 0 on error
+  */
+ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
+ 			bool blocking)
+ {
+ 	struct mei_device *bus;
+ 	struct mei_cl_cb *cb = NULL;
+ 	ssize_t rets;
+ 
+ 	if (WARN_ON(!cl || !cl->dev))
+ 		return -ENODEV;
+ 
+ 	bus = cl->dev;
+ 
+ 	mutex_lock(&bus->device_lock);
+ 	if (!mei_cl_is_connected(cl)) {
+ 		rets = -ENODEV;
+ 		goto out;
+ 	}
+ 
+ 	/* Check if we have an ME client device */
+ 	if (!mei_me_cl_is_active(cl->me_cl)) {
+ 		rets = -ENOTTY;
+ 		goto out;
+ 	}
+ 
+ 	if (length > mei_cl_mtu(cl)) {
+ 		rets = -EFBIG;
+ 		goto out;
+ 	}
+ 
+ 	cb = mei_cl_alloc_cb(cl, length, MEI_FOP_WRITE, NULL);
+ 	if (!cb) {
+ 		rets = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	memcpy(cb->buf.data, buf, length);
+ 
+ 	rets = mei_cl_write(cl, cb, blocking);
+ 
+ out:
+ 	mutex_unlock(&bus->device_lock);
+ 	if (rets < 0)
+ 		mei_io_cb_free(cb);
+ 
+ 	return rets;
+ }
+ 
+ /**
+  * __mei_cl_recv - internal client receive (read)
+  *
+  * @cl: host client
+  * @buf: buffer to send
+  * @length: buffer length
+  *
+  * Return: read size in bytes of < 0 on error
+  */
+ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
+ {
+ 	struct mei_device *bus;
+ 	struct mei_cl_cb *cb;
+ 	size_t r_length;
+ 	ssize_t rets;
+ 
+ 	if (WARN_ON(!cl || !cl->dev))
+ 		return -ENODEV;
+ 
+ 	bus = cl->dev;
+ 
+ 	mutex_lock(&bus->device_lock);
+ 
+ 	cb = mei_cl_read_cb(cl, NULL);
+ 	if (cb)
+ 		goto copy;
+ 
+ 	rets = mei_cl_read_start(cl, length, NULL);
+ 	if (rets && rets != -EBUSY)
+ 		goto out;
+ 
+ 	/* wait on event only if there is no other waiter */
+ 	if (list_empty(&cl->rd_completed) && !waitqueue_active(&cl->rx_wait)) {
+ 
+ 		mutex_unlock(&bus->device_lock);
+ 
+ 		if (wait_event_interruptible(cl->rx_wait,
+ 				(!list_empty(&cl->rd_completed)) ||
+ 				(!mei_cl_is_connected(cl)))) {
+ 
+ 			if (signal_pending(current))
+ 				return -EINTR;
+ 			return -ERESTARTSYS;
+ 		}
+ 
+ 		mutex_lock(&bus->device_lock);
+ 
+ 		if (!mei_cl_is_connected(cl)) {
+ 			rets = -EBUSY;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	cb = mei_cl_read_cb(cl, NULL);
+ 	if (!cb) {
+ 		rets = 0;
+ 		goto out;
+ 	}
+ 
+ copy:
+ 	if (cb->status) {
+ 		rets = cb->status;
+ 		goto free;
+ 	}
+ 
+ 	r_length = min_t(size_t, length, cb->buf_idx);
+ 	memcpy(buf, cb->buf.data, r_length);
+ 	rets = r_length;
+ 
+ free:
+ 	mei_io_cb_free(cb);
+ out:
+ 	mutex_unlock(&bus->device_lock);
+ 
+ 	return rets;
+ }
+ 
+ /**
+  * mei_cl_send - me device send  (write)
+  *
+  * @cldev: me client device
+  * @buf: buffer to send
+  * @length: buffer length
+  *
+  * Return: written size in bytes or < 0 on error
+  */
+ ssize_t mei_cl_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
+ {
+ 	struct mei_cl *cl = cldev->cl;
+ 
+ 	if (cl == NULL)
+ 		return -ENODEV;
+ 
+ 	return __mei_cl_send(cl, buf, length, 1);
+ }
+ EXPORT_SYMBOL_GPL(mei_cl_send);
+ 
+ /**
+  * mei_cl_recv - client receive (read)
+  *
+  * @cldev: me client device
+  * @buf: buffer to send
+  * @length: buffer length
+  *
+  * Return: read size in bytes of < 0 on error
+  */
+ ssize_t mei_cl_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
+ {
+ 	struct mei_cl *cl = cldev->cl;
+ 
+ 	if (cl == NULL)
+ 		return -ENODEV;
+ 
+ 	return __mei_cl_recv(cl, buf, length);
+ }
+ EXPORT_SYMBOL_GPL(mei_cl_recv);
+ 
+ /**
+  * mei_bus_event_work  - dispatch rx event for a bus device
+  *    and schedule new work
+  *
+  * @work: work
+  */
+ static void mei_bus_event_work(struct work_struct *work)
+ {
+ 	struct mei_cl_device *cldev;
+ 
+ 	cldev = container_of(work, struct mei_cl_device, event_work);
+ 
+ 	if (cldev->event_cb)
+ 		cldev->event_cb(cldev, cldev->events, cldev->event_context);
+ 
+ 	cldev->events = 0;
+ 
+ 	/* Prepare for the next read */
+ 	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX))
+ 		mei_cl_read_start(cldev->cl, 0, NULL);
+ }
+ 
+ /**
+  * mei_cl_bus_notify_event - schedule notify cb on bus client
+  *
+  * @cl: host client
+  */
+ void mei_cl_bus_notify_event(struct mei_cl *cl)
+ {
+ 	struct mei_cl_device *cldev = cl->cldev;
+ 
+ 	if (!cldev || !cldev->event_cb)
+ 		return;
+ 
+ 	if (!(cldev->events_mask & BIT(MEI_CL_EVENT_NOTIF)))
+ 		return;
+ 
+ 	if (!cl->notify_ev)
+ 		return;
+ 
+ 	set_bit(MEI_CL_EVENT_NOTIF, &cldev->events);
+ 
+ 	schedule_work(&cldev->event_work);
+ 
+ 	cl->notify_ev = false;
+ }
+ 
+ /**
+  * mei_cl_bus_rx_event  - schedule rx evenet
+  *
+  * @cl: host client
+  */
+ void mei_cl_bus_rx_event(struct mei_cl *cl)
+ {
+ 	struct mei_cl_device *cldev = cl->cldev;
+ 
+ 	if (!cldev || !cldev->event_cb)
+ 		return;
+ 
+ 	if (!(cldev->events_mask & BIT(MEI_CL_EVENT_RX)))
+ 		return;
+ 
+ 	set_bit(MEI_CL_EVENT_RX, &cldev->events);
+ 
+ 	schedule_work(&cldev->event_work);
+ }
+ 
+ /**
+  * mei_cl_register_event_cb - register event callback
+  *
+  * @cldev: me client devices
+  * @event_cb: callback function
+  * @events_mask: requested events bitmask
+  * @context: driver context data
+  *
+  * Return: 0 on success
+  *         -EALREADY if an callback is already registered
+  *         <0 on other errors
+  */
+ int mei_cl_register_event_cb(struct mei_cl_device *cldev,
+ 			  unsigned long events_mask,
+ 			  mei_cl_event_cb_t event_cb, void *context)
+ {
+ 	int ret;
+ 
+ 	if (cldev->event_cb)
+ 		return -EALREADY;
+ 
+ 	cldev->events = 0;
+ 	cldev->events_mask = events_mask;
+ 	cldev->event_cb = event_cb;
+ 	cldev->event_context = context;
+ 	INIT_WORK(&cldev->event_work, mei_bus_event_work);
+ 
+ 	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX)) {
+ 		ret = mei_cl_read_start(cldev->cl, 0, NULL);
+ 		if (ret && ret != -EBUSY)
+ 			return ret;
+ 	}
+ 
+ 	if (cldev->events_mask & BIT(MEI_CL_EVENT_NOTIF)) {
+ 		mutex_lock(&cldev->cl->dev->device_lock);
+ 		ret = mei_cl_notify_request(cldev->cl, NULL, event_cb ? 1 : 0);
+ 		mutex_unlock(&cldev->cl->dev->device_lock);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(mei_cl_register_event_cb);
+ 
+ /**
+  * mei_cl_get_drvdata - driver data getter
+  *
+  * @cldev: mei client device
+  *
+  * Return: driver private data
+  */
+ void *mei_cl_get_drvdata(const struct mei_cl_device *cldev)
+ {
+ 	return dev_get_drvdata(&cldev->dev);
+ }
+ EXPORT_SYMBOL_GPL(mei_cl_get_drvdata);
+ 
+ /**
+  * mei_cl_set_drvdata - driver data setter
+  *
+  * @cldev: mei client device
+  * @data: data to store
+  */
+ void mei_cl_set_drvdata(struct mei_cl_device *cldev, void *data)
+ {
+ 	dev_set_drvdata(&cldev->dev, data);
+ }
+ EXPORT_SYMBOL_GPL(mei_cl_set_drvdata);
+ 
+ /**
+  * mei_cl_enable_device - enable me client device
+  *     create connection with me client
+  *
+  * @cldev: me client device
+  *
+  * Return: 0 on success and < 0 on error
+  */
+ int mei_cl_enable_device(struct mei_cl_device *cldev)
+ {
+ 	struct mei_device *bus = cldev->bus;
+ 	struct mei_cl *cl;
+ 	int ret;
+ 
+ 	cl = cldev->cl;
+ 
+ 	if (!cl) {
+ 		mutex_lock(&bus->device_lock);
+ 		cl = mei_cl_alloc_linked(bus, MEI_HOST_CLIENT_ID_ANY);
+ 		mutex_unlock(&bus->device_lock);
+ 		if (IS_ERR(cl))
+ 			return PTR_ERR(cl);
+ 		/* update pointers */
+ 		cldev->cl = cl;
+ 		cl->cldev = cldev;
+ 	}
+ 
+ 	mutex_lock(&bus->device_lock);
+ 	if (mei_cl_is_connected(cl)) {
+ 		ret = 0;
+ 		goto out;
+ 	}
+ 
+ 	if (!mei_me_cl_is_active(cldev->me_cl)) {
+ 		dev_err(&cldev->dev, "me client is not active\n");
+ 		ret = -ENOTTY;
+ 		goto out;
+ 	}
+ 
+ 	ret = mei_cl_connect(cl, cldev->me_cl, NULL);
+ 	if (ret < 0)
+ 		dev_err(&cldev->dev, "cannot connect\n");
+ 
+ out:
+ 	mutex_unlock(&bus->device_lock);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(mei_cl_enable_device);
+ 
+ /**
+  * mei_cl_disable_device - disable me client device
+  *     disconnect form the me client
+  *
+  * @cldev: me client device
+  *
+  * Return: 0 on success and < 0 on error
+  */
+ int mei_cl_disable_device(struct mei_cl_device *cldev)
+ {
+ 	struct mei_device *bus;
+ 	struct mei_cl *cl;
+ 	int err;
+ 
+ 	if (!cldev || !cldev->cl)
+ 		return -ENODEV;
+ 
+ 	cl = cldev->cl;
+ 
+ 	bus = cldev->bus;
+ 
+ 	cldev->event_cb = NULL;
+ 
+ 	mutex_lock(&bus->device_lock);
+ 
+ 	if (!mei_cl_is_connected(cl)) {
+ 		dev_err(bus->dev, "Already disconnected");
+ 		err = 0;
+ 		goto out;
+ 	}
+ 
+ 	err = mei_cl_disconnect(cl);
+ 	if (err < 0)
+ 		dev_err(bus->dev, "Could not disconnect from the ME client");
+ 
+ out:
+ 	/* Flush queues and remove any pending read */
+ 	mei_cl_flush_queues(cl, NULL);
+ 	mei_cl_unlink(cl);
+ 
+ 	kfree(cl);
+ 	cldev->cl = NULL;
+ 
+ 	mutex_unlock(&bus->device_lock);
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(mei_cl_disable_device);
+ 
+ /**
+  * mei_cl_device_find - find matching entry in the driver id table
+  *
+  * @cldev: me client device
+  * @cldrv: me client driver
+  *
+  * Return: id on success; NULL if no id is matching
+  */
+ static const
+ struct mei_cl_device_id *mei_cl_device_find(struct mei_cl_device *cldev,
+ 					    struct mei_cl_driver *cldrv)
++>>>>>>> bb2ef9c39db2 (mei: bus: add and call callback on notify event)
  {
 +	struct mei_cl_device *device = to_mei_cl_device(dev);
 +	struct mei_cl_driver *driver = to_mei_cl_driver(drv);
  	const struct mei_cl_device_id *id;
 -	const uuid_le *uuid;
  
 -	uuid = mei_me_cl_uuid(cldev->me_cl);
 +	if (!device)
 +		return 0;
  
 -	id = cldrv->id_table;
 -	while (uuid_le_cmp(NULL_UUID_LE, id->uuid)) {
 -		if (!uuid_le_cmp(*uuid, id->uuid)) {
 +	if (!driver || !driver->id_table)
 +		return 0;
  
 -			if (!cldev->name[0])
 -				return id;
 +	id = driver->id_table;
  
 -			if (!strncmp(cldev->name, id->name, sizeof(id->name)))
 -				return id;
 -		}
 +	while (id->name[0]) {
 +		if (!strncmp(dev_name(dev), id->name, sizeof(id->name)))
 +			return 1;
  
  		id++;
  	}
diff --cc drivers/misc/mei/client.c
index 3c539de435ba,5fcd70bcdf96..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -783,9 -1343,153 +783,156 @@@ int mei_cl_read_start(struct mei_cl *cl
  
  out:
  	cl_dbg(dev, cl, "rpm: autosuspend\n");
 -	pm_runtime_mark_last_busy(dev->dev);
 -	pm_runtime_put_autosuspend(dev->dev);
 +	pm_runtime_mark_last_busy(&dev->pdev->dev);
 +	pm_runtime_put_autosuspend(&dev->pdev->dev);
  
++<<<<<<< HEAD
++=======
+ 	mei_io_cb_free(cb);
+ 	return rets;
+ }
+ 
+ /**
+  * mei_cl_notify - raise notification
+  *
+  * @cl: host client
+  *
+  * Locking: called under "dev->device_lock" lock
+  */
+ void mei_cl_notify(struct mei_cl *cl)
+ {
+ 	struct mei_device *dev;
+ 
+ 	if (!cl || !cl->dev)
+ 		return;
+ 
+ 	dev = cl->dev;
+ 
+ 	if (!cl->notify_en)
+ 		return;
+ 
+ 	cl_dbg(dev, cl, "notify event");
+ 	cl->notify_ev = true;
+ 	wake_up_interruptible_all(&cl->ev_wait);
+ 
+ 	if (cl->ev_async)
+ 		kill_fasync(&cl->ev_async, SIGIO, POLL_PRI);
+ 
+ 	mei_cl_bus_notify_event(cl);
+ }
+ 
+ /**
+  * mei_cl_notify_get - get or wait for notification event
+  *
+  * @cl: host client
+  * @block: this request is blocking
+  * @notify_ev: true if notification event was received
+  *
+  * Locking: called under "dev->device_lock" lock
+  *
+  * Return: 0 on such and error otherwise.
+  */
+ int mei_cl_notify_get(struct mei_cl *cl, bool block, bool *notify_ev)
+ {
+ 	struct mei_device *dev;
+ 	int rets;
+ 
+ 	*notify_ev = false;
+ 
+ 	if (WARN_ON(!cl || !cl->dev))
+ 		return -ENODEV;
+ 
+ 	dev = cl->dev;
+ 
+ 	if (!mei_cl_is_connected(cl))
+ 		return -ENODEV;
+ 
+ 	if (cl->notify_ev)
+ 		goto out;
+ 
+ 	if (!block)
+ 		return -EAGAIN;
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 	rets = wait_event_interruptible(cl->ev_wait, cl->notify_ev);
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (rets < 0)
+ 		return rets;
+ 
+ out:
+ 	*notify_ev = cl->notify_ev;
+ 	cl->notify_ev = false;
+ 	return 0;
+ }
+ 
+ /**
+  * mei_cl_read_start - the start read client message function.
+  *
+  * @cl: host client
+  * @length: number of bytes to read
+  * @fp: pointer to file structure
+  *
+  * Return: 0 on success, <0 on failure.
+  */
+ int mei_cl_read_start(struct mei_cl *cl, size_t length, struct file *fp)
+ {
+ 	struct mei_device *dev;
+ 	struct mei_cl_cb *cb;
+ 	int rets;
+ 
+ 	if (WARN_ON(!cl || !cl->dev))
+ 		return -ENODEV;
+ 
+ 	dev = cl->dev;
+ 
+ 	if (!mei_cl_is_connected(cl))
+ 		return -ENODEV;
+ 
+ 	/* HW currently supports only one pending read */
+ 	if (!list_empty(&cl->rd_pending))
+ 		return -EBUSY;
+ 
+ 	if (!mei_me_cl_is_active(cl->me_cl)) {
+ 		cl_err(dev, cl, "no such me client\n");
+ 		return  -ENOTTY;
+ 	}
+ 
+ 	/* always allocate at least client max message */
+ 	length = max_t(size_t, length, mei_cl_mtu(cl));
+ 	cb = mei_cl_alloc_cb(cl, length, MEI_FOP_READ, fp);
+ 	if (!cb)
+ 		return -ENOMEM;
+ 
+ 	if (mei_cl_is_fixed_address(cl)) {
+ 		list_add_tail(&cb->list, &cl->rd_pending);
+ 		return 0;
+ 	}
+ 
+ 	rets = pm_runtime_get(dev->dev);
+ 	if (rets < 0 && rets != -EINPROGRESS) {
+ 		pm_runtime_put_noidle(dev->dev);
+ 		cl_err(dev, cl, "rpm: get failed %d\n", rets);
+ 		goto nortpm;
+ 	}
+ 
+ 	if (mei_hbuf_acquire(dev)) {
+ 		rets = mei_hbm_cl_flow_control_req(dev, cl);
+ 		if (rets < 0)
+ 			goto out;
+ 
+ 		list_add_tail(&cb->list, &cl->rd_pending);
+ 	} else {
+ 		rets = 0;
+ 		list_add_tail(&cb->list, &dev->ctrl_wr_list.list);
+ 	}
+ 
+ out:
+ 	cl_dbg(dev, cl, "rpm: autosuspend\n");
+ 	pm_runtime_mark_last_busy(dev->dev);
+ 	pm_runtime_put_autosuspend(dev->dev);
+ nortpm:
++>>>>>>> bb2ef9c39db2 (mei: bus: add and call callback on notify event)
  	if (rets)
  		mei_io_cb_free(cb);
  
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,e25ee16c658e..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -288,38 -339,14 +288,43 @@@ struct mei_hw_ops 
  };
  
  /* MEI bus API*/
 -void mei_cl_bus_rescan(struct mei_device *bus);
 -void mei_cl_dev_fixup(struct mei_cl_device *dev);
 -ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 -			bool blocking);
 -ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
 +
 +/**
 + * struct mei_cl_ops - MEI CL device ops
 + * This structure allows ME host clients to implement technology
 + * specific operations.
 + *
 + * @enable: Enable an MEI CL device. Some devices require specific
 + *	HECI commands to initialize completely.
 + * @disable: Disable an MEI CL device.
 + * @send: Tx hook for the device. This allows ME host clients to trap
 + *	the device driver buffers before actually physically
 + *	pushing it to the ME.
 + * @recv: Rx hook for the device. This allows ME host clients to trap the
 + *	ME buffers before forwarding them to the device driver.
 + */
 +struct mei_cl_ops {
 +	int (*enable)(struct mei_cl_device *device);
 +	int (*disable)(struct mei_cl_device *device);
 +	int (*send)(struct mei_cl_device *device, u8 *buf, size_t length);
 +	int (*recv)(struct mei_cl_device *device, u8 *buf, size_t length);
 +};
 +
 +struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops);
 +void mei_cl_remove_device(struct mei_cl_device *device);
 +
 +int __mei_cl_async_send(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length);
 +int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
  void mei_cl_bus_rx_event(struct mei_cl *cl);
++<<<<<<< HEAD
 +void mei_cl_bus_remove_devices(struct mei_device *dev);
++=======
+ void mei_cl_bus_notify_event(struct mei_cl *cl);
+ void mei_cl_bus_remove_devices(struct mei_device *bus);
++>>>>>>> bb2ef9c39db2 (mei: bus: add and call callback on notify event)
  int mei_cl_bus_init(void);
  void mei_cl_bus_exit(void);
  
diff --cc drivers/nfc/mei_phy.c
index 606bf55e76ec,754a9bb0f58d..000000000000
--- a/drivers/nfc/mei_phy.c
+++ b/drivers/nfc/mei_phy.c
@@@ -139,7 -326,62 +139,66 @@@ void nfc_mei_event_cb(struct mei_cl_dev
  		nfc_hci_recv_frame(phy->hdev, skb);
  	}
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(nfc_mei_event_cb);
++=======
+ 
+ static int nfc_mei_phy_enable(void *phy_id)
+ {
+ 	int r;
+ 	struct nfc_mei_phy *phy = phy_id;
+ 
+ 	pr_info("%s\n", __func__);
+ 
+ 	if (phy->powered == 1)
+ 		return 0;
+ 
+ 	r = mei_cl_enable_device(phy->device);
+ 	if (r < 0) {
+ 		pr_err("Could not enable device %d\n", r);
+ 		return r;
+ 	}
+ 
+ 	r = mei_nfc_if_version(phy);
+ 	if (r < 0) {
+ 		pr_err("Could not enable device %d\n", r);
+ 		goto err;
+ 	}
+ 
+ 	r = mei_nfc_connect(phy);
+ 	if (r < 0) {
+ 		pr_err("Could not connect to device %d\n", r);
+ 		goto err;
+ 	}
+ 
+ 	r = mei_cl_register_event_cb(phy->device, BIT(MEI_CL_EVENT_RX),
+ 				     nfc_mei_event_cb, phy);
+ 	if (r) {
+ 		pr_err("Event cb registration failed %d\n", r);
+ 		goto err;
+ 	}
+ 
+ 	phy->powered = 1;
+ 
+ 	return 0;
+ 
+ err:
+ 	phy->powered = 0;
+ 	mei_cl_disable_device(phy->device);
+ 	return r;
+ }
+ 
+ static void nfc_mei_phy_disable(void *phy_id)
+ {
+ 	struct nfc_mei_phy *phy = phy_id;
+ 
+ 	pr_info("%s\n", __func__);
+ 
+ 	mei_cl_disable_device(phy->device);
+ 
+ 	phy->powered = 0;
+ }
++>>>>>>> bb2ef9c39db2 (mei: bus: add and call callback on notify event)
  
  struct nfc_phy_ops mei_phy_ops = {
  	.write = nfc_mei_phy_write,
diff --cc include/linux/mei_cl_bus.h
index d14af7b722ef,0962b2ca628a..000000000000
--- a/include/linux/mei_cl_bus.h
+++ b/include/linux/mei_cl_bus.h
@@@ -3,8 -3,58 +3,60 @@@
  
  #include <linux/device.h>
  #include <linux/uuid.h>
 -#include <linux/mod_devicetable.h>
  
  struct mei_cl_device;
++<<<<<<< HEAD
++=======
+ struct mei_device;
+ 
+ typedef void (*mei_cl_event_cb_t)(struct mei_cl_device *device,
+ 			       u32 events, void *context);
+ 
+ /**
+  * struct mei_cl_device - MEI device handle
+  * An mei_cl_device pointer is returned from mei_add_device()
+  * and links MEI bus clients to their actual ME host client pointer.
+  * Drivers for MEI devices will get an mei_cl_device pointer
+  * when being probed and shall use it for doing ME bus I/O.
+  *
+  * @bus_list: device on the bus list
+  * @bus: parent mei device
+  * @dev: linux driver model device pointer
+  * @me_cl: me client
+  * @cl: mei client
+  * @name: device name
+  * @event_work: async work to execute event callback
+  * @event_cb: Drivers register this callback to get asynchronous ME
+  *	events (e.g. Rx buffer pending) notifications.
+  * @event_context: event callback run context
+  * @events_mask: Events bit mask requested by driver.
+  * @events: Events bitmask sent to the driver.
+  *
+  * @do_match: wheather device can be matched with a driver
+  * @is_added: device is already scanned
+  * @priv_data: client private data
+  */
+ struct mei_cl_device {
+ 	struct list_head bus_list;
+ 	struct mei_device *bus;
+ 	struct device dev;
+ 
+ 	struct mei_me_client *me_cl;
+ 	struct mei_cl *cl;
+ 	char name[MEI_CL_NAME_SIZE];
+ 
+ 	struct work_struct event_work;
+ 	mei_cl_event_cb_t event_cb;
+ 	void *event_context;
+ 	unsigned long events_mask;
+ 	unsigned long events;
+ 
+ 	unsigned int do_match:1;
+ 	unsigned int is_added:1;
+ 
+ 	void *priv_data;
+ };
++>>>>>>> bb2ef9c39db2 (mei: bus: add and call callback on notify event)
  
  struct mei_cl_driver {
  	struct device_driver driver;
@@@ -24,12 -74,11 +76,13 @@@ int __mei_cl_driver_register(struct mei
  
  void mei_cl_driver_unregister(struct mei_cl_driver *driver);
  
 -ssize_t mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length);
 -ssize_t  mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length);
 +int mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length);
 +int mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length);
  
 +typedef void (*mei_cl_event_cb_t)(struct mei_cl_device *device,
 +			       u32 events, void *context);
  int mei_cl_register_event_cb(struct mei_cl_device *device,
+ 			  unsigned long event_mask,
  			  mei_cl_event_cb_t read_cb, void *context);
  
  #define MEI_CL_EVENT_RX 0
* Unmerged path drivers/misc/mei/bus.c
* Unmerged path drivers/misc/mei/client.c
* Unmerged path drivers/misc/mei/mei_dev.h
* Unmerged path drivers/nfc/mei_phy.c
* Unmerged path include/linux/mei_cl_bus.h
