e1000e: factor out systim sanitization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jarod Wilson <jarod@redhat.com>
commit 0be5b96cd8400aeb4bf3f8c5e7f5efaa38ae5055
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0be5b96c.failed

This is prepatory work for an expanding list of adapter families that have
occasional ~10 hour clock jumps when being used for PTP. Factor out the
sanitization function and convert to using a feature (bug) flag, per
suggestion from Jesse Brandeburg.

Littering functional code with device-specific checks is much messier than
simply checking a flag, and having device-specific init set flags as needed.
There are probably a number of other cases in the e1000e code that
could/should be converted similarly.

	Suggested-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Signed-off-by: Jarod Wilson <jarod@redhat.com>
	Tested-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 0be5b96cd8400aeb4bf3f8c5e7f5efaa38ae5055)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/e1000e/e1000.h
#	drivers/net/ethernet/intel/e1000e/netdev.c
diff --cc drivers/net/ethernet/intel/e1000e/e1000.h
index 4b24b685562d,879cca47b021..000000000000
--- a/drivers/net/ethernet/intel/e1000e/e1000.h
+++ b/drivers/net/ethernet/intel/e1000e/e1000.h
@@@ -403,53 -405,54 +403,71 @@@ s32 e1000e_get_base_timinca(struct e100
  #define E1000_82574_SYSTIM_EPSILON	(1ULL << 35ULL)
  
  /* hardware capability, feature, and workaround flags */
 -#define FLAG_HAS_AMT                      BIT(0)
 -#define FLAG_HAS_FLASH                    BIT(1)
 -#define FLAG_HAS_HW_VLAN_FILTER           BIT(2)
 -#define FLAG_HAS_WOL                      BIT(3)
 -/* reserved BIT(4) */
 -#define FLAG_HAS_CTRLEXT_ON_LOAD          BIT(5)
 -#define FLAG_HAS_SWSM_ON_LOAD             BIT(6)
 -#define FLAG_HAS_JUMBO_FRAMES             BIT(7)
 -#define FLAG_READ_ONLY_NVM                BIT(8)
 -#define FLAG_IS_ICH                       BIT(9)
 -#define FLAG_HAS_MSIX                     BIT(10)
 -#define FLAG_HAS_SMART_POWER_DOWN         BIT(11)
 -#define FLAG_IS_QUAD_PORT_A               BIT(12)
 -#define FLAG_IS_QUAD_PORT                 BIT(13)
 -#define FLAG_HAS_HW_TIMESTAMP             BIT(14)
 -#define FLAG_APME_IN_WUC                  BIT(15)
 -#define FLAG_APME_IN_CTRL3                BIT(16)
 -#define FLAG_APME_CHECK_PORT_B            BIT(17)
 -#define FLAG_DISABLE_FC_PAUSE_TIME        BIT(18)
 -#define FLAG_NO_WAKE_UCAST                BIT(19)
 -#define FLAG_MNG_PT_ENABLED               BIT(20)
 -#define FLAG_RESET_OVERWRITES_LAA         BIT(21)
 -#define FLAG_TARC_SPEED_MODE_BIT          BIT(22)
 -#define FLAG_TARC_SET_BIT_ZERO            BIT(23)
 -#define FLAG_RX_NEEDS_RESTART             BIT(24)
 -#define FLAG_LSC_GIG_SPEED_DROP           BIT(25)
 -#define FLAG_SMART_POWER_DOWN             BIT(26)
 -#define FLAG_MSI_ENABLED                  BIT(27)
 -/* reserved BIT(28) */
 -#define FLAG_TSO_FORCE                    BIT(29)
 -#define FLAG_RESTART_NOW                  BIT(30)
 -#define FLAG_MSI_TEST_FAILED              BIT(31)
 -
 +#define FLAG_HAS_AMT                      (1 << 0)
 +#define FLAG_HAS_FLASH                    (1 << 1)
 +#define FLAG_HAS_HW_VLAN_FILTER           (1 << 2)
 +#define FLAG_HAS_WOL                      (1 << 3)
 +/* reserved bit4 */
 +#define FLAG_HAS_CTRLEXT_ON_LOAD          (1 << 5)
 +#define FLAG_HAS_SWSM_ON_LOAD             (1 << 6)
 +#define FLAG_HAS_JUMBO_FRAMES             (1 << 7)
 +#define FLAG_READ_ONLY_NVM                (1 << 8)
 +#define FLAG_IS_ICH                       (1 << 9)
 +#define FLAG_HAS_MSIX                     (1 << 10)
 +#define FLAG_HAS_SMART_POWER_DOWN         (1 << 11)
 +#define FLAG_IS_QUAD_PORT_A               (1 << 12)
 +#define FLAG_IS_QUAD_PORT                 (1 << 13)
 +#define FLAG_HAS_HW_TIMESTAMP             (1 << 14)
 +#define FLAG_APME_IN_WUC                  (1 << 15)
 +#define FLAG_APME_IN_CTRL3                (1 << 16)
 +#define FLAG_APME_CHECK_PORT_B            (1 << 17)
 +#define FLAG_DISABLE_FC_PAUSE_TIME        (1 << 18)
 +#define FLAG_NO_WAKE_UCAST                (1 << 19)
 +#define FLAG_MNG_PT_ENABLED               (1 << 20)
 +#define FLAG_RESET_OVERWRITES_LAA         (1 << 21)
 +#define FLAG_TARC_SPEED_MODE_BIT          (1 << 22)
 +#define FLAG_TARC_SET_BIT_ZERO            (1 << 23)
 +#define FLAG_RX_NEEDS_RESTART             (1 << 24)
 +#define FLAG_LSC_GIG_SPEED_DROP           (1 << 25)
 +#define FLAG_SMART_POWER_DOWN             (1 << 26)
 +#define FLAG_MSI_ENABLED                  (1 << 27)
 +/* reserved (1 << 28) */
 +#define FLAG_TSO_FORCE                    (1 << 29)
 +#define FLAG_RESTART_NOW                  (1 << 30)
 +#define FLAG_MSI_TEST_FAILED              (1 << 31)
 +
++<<<<<<< HEAD
 +#define FLAG2_CRC_STRIPPING               (1 << 0)
 +#define FLAG2_HAS_PHY_WAKEUP              (1 << 1)
 +#define FLAG2_IS_DISCARDING               (1 << 2)
 +#define FLAG2_DISABLE_ASPM_L1             (1 << 3)
 +#define FLAG2_HAS_PHY_STATS               (1 << 4)
 +#define FLAG2_HAS_EEE                     (1 << 5)
 +#define FLAG2_DMA_BURST                   (1 << 6)
 +#define FLAG2_DISABLE_ASPM_L0S            (1 << 7)
 +#define FLAG2_DISABLE_AIM                 (1 << 8)
 +#define FLAG2_CHECK_PHY_HANG              (1 << 9)
 +#define FLAG2_NO_DISABLE_RX               (1 << 10)
 +#define FLAG2_PCIM2PCI_ARBITER_WA         (1 << 11)
 +#define FLAG2_DFLT_CRC_STRIPPING          (1 << 12)
 +#define FLAG2_CHECK_RX_HWTSTAMP           (1 << 13)
++=======
+ #define FLAG2_CRC_STRIPPING               BIT(0)
+ #define FLAG2_HAS_PHY_WAKEUP              BIT(1)
+ #define FLAG2_IS_DISCARDING               BIT(2)
+ #define FLAG2_DISABLE_ASPM_L1             BIT(3)
+ #define FLAG2_HAS_PHY_STATS               BIT(4)
+ #define FLAG2_HAS_EEE                     BIT(5)
+ #define FLAG2_DMA_BURST                   BIT(6)
+ #define FLAG2_DISABLE_ASPM_L0S            BIT(7)
+ #define FLAG2_DISABLE_AIM                 BIT(8)
+ #define FLAG2_CHECK_PHY_HANG              BIT(9)
+ #define FLAG2_NO_DISABLE_RX               BIT(10)
+ #define FLAG2_PCIM2PCI_ARBITER_WA         BIT(11)
+ #define FLAG2_DFLT_CRC_STRIPPING          BIT(12)
+ #define FLAG2_CHECK_RX_HWTSTAMP           BIT(13)
+ #define FLAG2_CHECK_SYSTIM_OVERFLOW       BIT(14)
++>>>>>>> 0be5b96cd840 (e1000e: factor out systim sanitization)
  
  #define E1000_RX_DESC_PS(R, i)	    \
  	(&(((union e1000_rx_desc_packet_split *)((R).desc))[i]))
diff --cc drivers/net/ethernet/intel/e1000e/netdev.c
index f9a15cc3bf2c,7017281ba2dc..000000000000
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@@ -4270,57 -4347,33 +4306,38 @@@ static cycle_t e1000e_cyclecounter_read
  	struct e1000_adapter *adapter = container_of(cc, struct e1000_adapter,
  						     cc);
  	struct e1000_hw *hw = &adapter->hw;
++<<<<<<< HEAD
 +	u32 systimel_1, systimel_2, systimeh;
 +	cycle_t systim, systim_next;
++=======
+ 	u32 systimel, systimeh;
+ 	cycle_t systim;
++>>>>>>> 0be5b96cd840 (e1000e: factor out systim sanitization)
  	/* SYSTIMH latching upon SYSTIML read does not work well.
  	 * This means that if SYSTIML overflows after we read it but before
  	 * we read SYSTIMH, the value of SYSTIMH has been incremented and we
  	 * will experience a huge non linear increment in the systime value
  	 * to fix that we test for overflow and if true, we re-read systime.
  	 */
 -	systimel = er32(SYSTIML);
 +	systimel_1 = er32(SYSTIML);
  	systimeh = er32(SYSTIMH);
 -	/* Is systimel is so large that overflow is possible? */
 -	if (systimel >= (u32)0xffffffff - E1000_TIMINCA_INCVALUE_MASK) {
 -		u32 systimel_2 = er32(SYSTIML);
 -		if (systimel > systimel_2) {
 -			/* There was an overflow, read again SYSTIMH, and use
 -			 * systimel_2
 -			 */
 -			systimeh = er32(SYSTIMH);
 -			systimel = systimel_2;
 -		}
 +	systimel_2 = er32(SYSTIML);
 +	/* Check for overflow. If there was no overflow, use the values */
 +	if (systimel_1 < systimel_2) {
 +		systim = (cycle_t)systimel_1;
 +		systim |= (cycle_t)systimeh << 32;
 +	} else {
 +		/* There was an overflow, read again SYSTIMH, and use
 +		 * systimel_2
 +		 */
 +		systimeh = er32(SYSTIMH);
 +		systim = (cycle_t)systimel_2;
 +		systim |= (cycle_t)systimeh << 32;
  	}
 -	systim = (cycle_t)systimel;
 -	systim |= (cycle_t)systimeh << 32;
  
- 	if ((hw->mac.type == e1000_82574) || (hw->mac.type == e1000_82583)) {
- 		u64 time_delta, rem, temp;
- 		u32 incvalue;
- 		int i;
- 
- 		/* errata for 82574/82583 possible bad bits read from SYSTIMH/L
- 		 * check to see that the time is incrementing at a reasonable
- 		 * rate and is a multiple of incvalue
- 		 */
- 		incvalue = er32(TIMINCA) & E1000_TIMINCA_INCVALUE_MASK;
- 		for (i = 0; i < E1000_MAX_82574_SYSTIM_REREADS; i++) {
- 			/* latch SYSTIMH on read of SYSTIML */
- 			systim_next = (cycle_t)er32(SYSTIML);
- 			systim_next |= (cycle_t)er32(SYSTIMH) << 32;
- 
- 			time_delta = systim_next - systim;
- 			temp = time_delta;
- 			/* VMWare users have seen incvalue of zero, don't div / 0 */
- 			rem = incvalue ? do_div(temp, incvalue) : (time_delta != 0);
- 
- 			systim = systim_next;
+ 	if (adapter->flags2 & FLAG2_CHECK_SYSTIM_OVERFLOW)
+ 		systim = e1000e_sanitize_systim(hw, systim);
  
- 			if ((time_delta < E1000_82574_SYSTIM_EPSILON) &&
- 			    (rem == 0))
- 				break;
- 		}
- 	}
  	return systim;
  }
  
diff --git a/drivers/net/ethernet/intel/e1000e/82571.c b/drivers/net/ethernet/intel/e1000e/82571.c
index 5f7016442ec4..48a171da25aa 100644
--- a/drivers/net/ethernet/intel/e1000e/82571.c
+++ b/drivers/net/ethernet/intel/e1000e/82571.c
@@ -2032,7 +2032,8 @@ const struct e1000_info e1000_82574_info = {
 				  | FLAG2_DISABLE_ASPM_L0S
 				  | FLAG2_DISABLE_ASPM_L1
 				  | FLAG2_NO_DISABLE_RX
-				  | FLAG2_DMA_BURST,
+				  | FLAG2_DMA_BURST
+				  | FLAG2_CHECK_SYSTIM_OVERFLOW,
 	.pba			= 32,
 	.max_hw_frame_size	= DEFAULT_JUMBO,
 	.get_variants		= e1000_get_variants_82571,
@@ -2053,7 +2054,8 @@ const struct e1000_info e1000_82583_info = {
 				  | FLAG_HAS_CTRLEXT_ON_LOAD,
 	.flags2			= FLAG2_DISABLE_ASPM_L0S
 				  | FLAG2_DISABLE_ASPM_L1
-				  | FLAG2_NO_DISABLE_RX,
+				  | FLAG2_NO_DISABLE_RX
+				  | FLAG2_CHECK_SYSTIM_OVERFLOW,
 	.pba			= 32,
 	.max_hw_frame_size	= DEFAULT_JUMBO,
 	.get_variants		= e1000_get_variants_82571,
* Unmerged path drivers/net/ethernet/intel/e1000e/e1000.h
* Unmerged path drivers/net/ethernet/intel/e1000e/netdev.c
