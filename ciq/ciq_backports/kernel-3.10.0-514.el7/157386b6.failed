cpufreq: intel_pstate: Configurable algorithm to get target pstate

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [cpufreq] intel_pstate: Configurable algorithm to get target pstate (Prarit Bhargava) [1283337]
Rebuild_FUZZ: 92.68%
commit-author Philippe Longepe <philippe.longepe@intel.com>
commit 157386b6fc1465f292b66c4133409033650ad335
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/157386b6.failed

Target systems using different cpus have different power and performance
requirements. They may use different algorithms to get the next P-state
based on their power or performance preference.

For example, power-constrained systems may not want to use
high-performance P-states as aggressively as a full-size desktop or a
server platform. A server platform may want to run close to the max to
achieve better performance, while laptop-like systems may prefer
sacrificing performance for longer battery lifes.

For the above reasons, modify intel_pstate to allow the target P-state
selection algorithm to be depend on the CPU ID.

	Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Signed-off-by: Philippe Longepe <philippe.longepe@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 157386b6fc1465f292b66c4133409033650ad335)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 07d88cb77cb6,ff58029a56e2..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -669,13 -756,35 +674,45 @@@ static struct cpu_defaults byt_params 
  		.i_gain_pct = 4,
  	},
  	.funcs = {
++<<<<<<< HEAD
 +		.get_max = byt_get_max_pstate,
 +		.get_max_physical = byt_get_max_pstate,
 +		.get_min = byt_get_min_pstate,
 +		.get_turbo = byt_get_turbo_pstate,
 +		.set = byt_set_pstate,
 +		.get_scaling = byt_get_scaling,
 +		.get_vid = byt_get_vid,
++=======
+ 		.get_max = atom_get_max_pstate,
+ 		.get_max_physical = atom_get_max_pstate,
+ 		.get_min = atom_get_min_pstate,
+ 		.get_turbo = atom_get_turbo_pstate,
+ 		.set = atom_set_pstate,
+ 		.get_scaling = silvermont_get_scaling,
+ 		.get_vid = atom_get_vid,
+ 		.get_target_pstate = get_target_pstate_use_performance,
+ 	},
+ };
+ 
+ static struct cpu_defaults airmont_params = {
+ 	.pid_policy = {
+ 		.sample_rate_ms = 10,
+ 		.deadband = 0,
+ 		.setpoint = 60,
+ 		.p_gain_pct = 14,
+ 		.d_gain_pct = 0,
+ 		.i_gain_pct = 4,
+ 	},
+ 	.funcs = {
+ 		.get_max = atom_get_max_pstate,
+ 		.get_max_physical = atom_get_max_pstate,
+ 		.get_min = atom_get_min_pstate,
+ 		.get_turbo = atom_get_turbo_pstate,
+ 		.set = atom_set_pstate,
+ 		.get_scaling = airmont_get_scaling,
+ 		.get_vid = atom_get_vid,
+ 		.get_target_pstate = get_target_pstate_use_performance,
++>>>>>>> 157386b6fc14 (cpufreq: intel_pstate: Configurable algorithm to get target pstate)
  	},
  };
  
@@@ -865,13 -979,9 +901,16 @@@ static inline void intel_pstate_adjust_
  
  	from = cpu->pstate.current_pstate;
  
- 	pid = &cpu->pid;
- 	busy_scaled = intel_pstate_get_scaled_busy(cpu);
+ 	target_pstate = pstate_funcs.get_target_pstate(cpu);
  
++<<<<<<< HEAD
 +	ctl = pid_calc(pid, busy_scaled);
 +
 +	/* Negative values of ctl increase the pstate and vice versa */
 +	intel_pstate_set_pstate(cpu, cpu->pstate.current_pstate - ctl);
++=======
+ 	intel_pstate_set_pstate(cpu, target_pstate, true);
++>>>>>>> 157386b6fc14 (cpufreq: intel_pstate: Configurable algorithm to get target pstate)
  
  	sample = &cpu->sample;
  	trace_pstate_sample(fp_toint(sample->core_pct_busy),
* Unmerged path drivers/cpufreq/intel_pstate.c
