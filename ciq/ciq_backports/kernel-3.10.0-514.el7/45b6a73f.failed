usb-gadget: use per-attribute show and store methods

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 45b6a73f62ebcf3ff067895fb8030e67f4c7b67f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/45b6a73f.failed

To simplify the configfs interface and remove boilerplate code that also
causes binary bloat.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
	Acked-by: Felipe Balbi <balbi@ti.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 45b6a73f62ebcf3ff067895fb8030e67f4c7b67f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/gadget/configfs.c
diff --cc drivers/usb/gadget/configfs.c
index 49100e27e948,163d305e1200..000000000000
--- a/drivers/usb/gadget/configfs.c
+++ b/drivers/usb/gadget/configfs.c
@@@ -50,13 -57,18 +50,18 @@@ struct gadget_info 
  	struct list_head available_func;
  
  	const char *udc_name;
 +#ifdef CONFIG_USB_OTG
 +	struct usb_otg_descriptor otg;
 +#endif
  	struct usb_composite_driver composite;
  	struct usb_composite_dev cdev;
 -	bool use_os_desc;
 -	char b_vendor_code;
 -	char qw_sign[OS_STRING_QW_SIGN_LEN];
  };
  
+ static inline struct gadget_info *to_gadget_info(struct config_item *item)
+ {
+ 	 return container_of(to_config_group(item), struct gadget_info, group);
+ }
+ 
  struct config_usb_cfg {
  	struct config_group group;
  	struct config_group strings_group;
@@@ -728,6 -725,474 +707,477 @@@ static void gadget_strings_attr_release
  USB_CONFIG_STRING_RW_OPS(gadget_strings);
  USB_CONFIG_STRINGS_LANG(gadget_strings, gadget_info);
  
++<<<<<<< HEAD
++=======
+ static inline struct os_desc *to_os_desc(struct config_item *item)
+ {
+ 	return container_of(to_config_group(item), struct os_desc, group);
+ }
+ 
+ static inline struct gadget_info *os_desc_item_to_gadget_info(
+ 		struct config_item *item)
+ {
+ 	return to_gadget_info(to_os_desc(item)->group.cg_item.ci_parent);
+ }
+ 
+ static ssize_t os_desc_use_show(struct config_item *item, char *page)
+ {
+ 	return sprintf(page, "%d",
+ 			os_desc_item_to_gadget_info(item)->use_os_desc);
+ }
+ 
+ static ssize_t os_desc_use_store(struct config_item *item, const char *page,
+ 				 size_t len)
+ {
+ 	struct gadget_info *gi = os_desc_item_to_gadget_info(item);
+ 	int ret;
+ 	bool use;
+ 
+ 	mutex_lock(&gi->lock);
+ 	ret = strtobool(page, &use);
+ 	if (!ret) {
+ 		gi->use_os_desc = use;
+ 		ret = len;
+ 	}
+ 	mutex_unlock(&gi->lock);
+ 
+ 	return ret;
+ }
+ 
+ static ssize_t os_desc_b_vendor_code_show(struct config_item *item, char *page)
+ {
+ 	return sprintf(page, "%d",
+ 			os_desc_item_to_gadget_info(item)->b_vendor_code);
+ }
+ 
+ static ssize_t os_desc_b_vendor_code_store(struct config_item *item,
+ 					   const char *page, size_t len)
+ {
+ 	struct gadget_info *gi = os_desc_item_to_gadget_info(item);
+ 	int ret;
+ 	u8 b_vendor_code;
+ 
+ 	mutex_lock(&gi->lock);
+ 	ret = kstrtou8(page, 0, &b_vendor_code);
+ 	if (!ret) {
+ 		gi->b_vendor_code = b_vendor_code;
+ 		ret = len;
+ 	}
+ 	mutex_unlock(&gi->lock);
+ 
+ 	return ret;
+ }
+ 
+ static ssize_t os_desc_qw_sign_show(struct config_item *item, char *page)
+ {
+ 	struct gadget_info *gi = os_desc_item_to_gadget_info(item);
+ 
+ 	memcpy(page, gi->qw_sign, OS_STRING_QW_SIGN_LEN);
+ 	return OS_STRING_QW_SIGN_LEN;
+ }
+ 
+ static ssize_t os_desc_qw_sign_store(struct config_item *item, const char *page,
+ 				     size_t len)
+ {
+ 	struct gadget_info *gi = os_desc_item_to_gadget_info(item);
+ 	int res, l;
+ 
+ 	l = min((int)len, OS_STRING_QW_SIGN_LEN >> 1);
+ 	if (page[l - 1] == '\n')
+ 		--l;
+ 
+ 	mutex_lock(&gi->lock);
+ 	res = utf8s_to_utf16s(page, l,
+ 			      UTF16_LITTLE_ENDIAN, (wchar_t *) gi->qw_sign,
+ 			      OS_STRING_QW_SIGN_LEN);
+ 	if (res > 0)
+ 		res = len;
+ 	mutex_unlock(&gi->lock);
+ 
+ 	return res;
+ }
+ 
+ CONFIGFS_ATTR(os_desc_, use);
+ CONFIGFS_ATTR(os_desc_, b_vendor_code);
+ CONFIGFS_ATTR(os_desc_, qw_sign);
+ 
+ static struct configfs_attribute *os_desc_attrs[] = {
+ 	&os_desc_attr_use,
+ 	&os_desc_attr_b_vendor_code,
+ 	&os_desc_attr_qw_sign,
+ 	NULL,
+ };
+ 
+ static void os_desc_attr_release(struct config_item *item)
+ {
+ 	struct os_desc *os_desc = to_os_desc(item);
+ 	kfree(os_desc);
+ }
+ 
+ static int os_desc_link(struct config_item *os_desc_ci,
+ 			struct config_item *usb_cfg_ci)
+ {
+ 	struct gadget_info *gi = container_of(to_config_group(os_desc_ci),
+ 					struct gadget_info, os_desc_group);
+ 	struct usb_composite_dev *cdev = &gi->cdev;
+ 	struct config_usb_cfg *c_target =
+ 		container_of(to_config_group(usb_cfg_ci),
+ 			     struct config_usb_cfg, group);
+ 	struct usb_configuration *c;
+ 	int ret;
+ 
+ 	mutex_lock(&gi->lock);
+ 	list_for_each_entry(c, &cdev->configs, list) {
+ 		if (c == &c_target->c)
+ 			break;
+ 	}
+ 	if (c != &c_target->c) {
+ 		ret = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (cdev->os_desc_config) {
+ 		ret = -EBUSY;
+ 		goto out;
+ 	}
+ 
+ 	cdev->os_desc_config = &c_target->c;
+ 	ret = 0;
+ 
+ out:
+ 	mutex_unlock(&gi->lock);
+ 	return ret;
+ }
+ 
+ static int os_desc_unlink(struct config_item *os_desc_ci,
+ 			  struct config_item *usb_cfg_ci)
+ {
+ 	struct gadget_info *gi = container_of(to_config_group(os_desc_ci),
+ 					struct gadget_info, os_desc_group);
+ 	struct usb_composite_dev *cdev = &gi->cdev;
+ 
+ 	mutex_lock(&gi->lock);
+ 	if (gi->udc_name)
+ 		unregister_gadget(gi);
+ 	cdev->os_desc_config = NULL;
+ 	WARN_ON(gi->udc_name);
+ 	mutex_unlock(&gi->lock);
+ 	return 0;
+ }
+ 
+ static struct configfs_item_operations os_desc_ops = {
+ 	.release                = os_desc_attr_release,
+ 	.allow_link		= os_desc_link,
+ 	.drop_link		= os_desc_unlink,
+ };
+ 
+ static struct config_item_type os_desc_type = {
+ 	.ct_item_ops	= &os_desc_ops,
+ 	.ct_attrs	= os_desc_attrs,
+ 	.ct_owner	= THIS_MODULE,
+ };
+ 
+ static inline struct usb_os_desc_ext_prop
+ *to_usb_os_desc_ext_prop(struct config_item *item)
+ {
+ 	return container_of(item, struct usb_os_desc_ext_prop, item);
+ }
+ 
+ static ssize_t ext_prop_type_show(struct config_item *item, char *page)
+ {
+ 	return sprintf(page, "%d", to_usb_os_desc_ext_prop(item)->type);
+ }
+ 
+ static ssize_t ext_prop_type_store(struct config_item *item,
+ 				   const char *page, size_t len)
+ {
+ 	struct usb_os_desc_ext_prop *ext_prop = to_usb_os_desc_ext_prop(item);
+ 	struct usb_os_desc *desc = to_usb_os_desc(ext_prop->item.ci_parent);
+ 	u8 type;
+ 	int ret;
+ 
+ 	if (desc->opts_mutex)
+ 		mutex_lock(desc->opts_mutex);
+ 	ret = kstrtou8(page, 0, &type);
+ 	if (ret)
+ 		goto end;
+ 	if (type < USB_EXT_PROP_UNICODE || type > USB_EXT_PROP_UNICODE_MULTI) {
+ 		ret = -EINVAL;
+ 		goto end;
+ 	}
+ 
+ 	if ((ext_prop->type == USB_EXT_PROP_BINARY ||
+ 	    ext_prop->type == USB_EXT_PROP_LE32 ||
+ 	    ext_prop->type == USB_EXT_PROP_BE32) &&
+ 	    (type == USB_EXT_PROP_UNICODE ||
+ 	    type == USB_EXT_PROP_UNICODE_ENV ||
+ 	    type == USB_EXT_PROP_UNICODE_LINK))
+ 		ext_prop->data_len <<= 1;
+ 	else if ((ext_prop->type == USB_EXT_PROP_UNICODE ||
+ 		   ext_prop->type == USB_EXT_PROP_UNICODE_ENV ||
+ 		   ext_prop->type == USB_EXT_PROP_UNICODE_LINK) &&
+ 		   (type == USB_EXT_PROP_BINARY ||
+ 		   type == USB_EXT_PROP_LE32 ||
+ 		   type == USB_EXT_PROP_BE32))
+ 		ext_prop->data_len >>= 1;
+ 	ext_prop->type = type;
+ 	ret = len;
+ 
+ end:
+ 	if (desc->opts_mutex)
+ 		mutex_unlock(desc->opts_mutex);
+ 	return ret;
+ }
+ 
+ static ssize_t ext_prop_data_show(struct config_item *item, char *page)
+ {
+ 	struct usb_os_desc_ext_prop *ext_prop = to_usb_os_desc_ext_prop(item);
+ 	int len = ext_prop->data_len;
+ 
+ 	if (ext_prop->type == USB_EXT_PROP_UNICODE ||
+ 	    ext_prop->type == USB_EXT_PROP_UNICODE_ENV ||
+ 	    ext_prop->type == USB_EXT_PROP_UNICODE_LINK)
+ 		len >>= 1;
+ 	memcpy(page, ext_prop->data, len);
+ 
+ 	return len;
+ }
+ 
+ static ssize_t ext_prop_data_store(struct config_item *item,
+ 				   const char *page, size_t len)
+ {
+ 	struct usb_os_desc_ext_prop *ext_prop = to_usb_os_desc_ext_prop(item);
+ 	struct usb_os_desc *desc = to_usb_os_desc(ext_prop->item.ci_parent);
+ 	char *new_data;
+ 	size_t ret_len = len;
+ 
+ 	if (page[len - 1] == '\n' || page[len - 1] == '\0')
+ 		--len;
+ 	new_data = kmemdup(page, len, GFP_KERNEL);
+ 	if (!new_data)
+ 		return -ENOMEM;
+ 
+ 	if (desc->opts_mutex)
+ 		mutex_lock(desc->opts_mutex);
+ 	kfree(ext_prop->data);
+ 	ext_prop->data = new_data;
+ 	desc->ext_prop_len -= ext_prop->data_len;
+ 	ext_prop->data_len = len;
+ 	desc->ext_prop_len += ext_prop->data_len;
+ 	if (ext_prop->type == USB_EXT_PROP_UNICODE ||
+ 	    ext_prop->type == USB_EXT_PROP_UNICODE_ENV ||
+ 	    ext_prop->type == USB_EXT_PROP_UNICODE_LINK) {
+ 		desc->ext_prop_len -= ext_prop->data_len;
+ 		ext_prop->data_len <<= 1;
+ 		ext_prop->data_len += 2;
+ 		desc->ext_prop_len += ext_prop->data_len;
+ 	}
+ 	if (desc->opts_mutex)
+ 		mutex_unlock(desc->opts_mutex);
+ 	return ret_len;
+ }
+ 
+ CONFIGFS_ATTR(ext_prop_, type);
+ CONFIGFS_ATTR(ext_prop_, data);
+ 
+ static struct configfs_attribute *ext_prop_attrs[] = {
+ 	&ext_prop_attr_type,
+ 	&ext_prop_attr_data,
+ 	NULL,
+ };
+ 
+ static void usb_os_desc_ext_prop_release(struct config_item *item)
+ {
+ 	struct usb_os_desc_ext_prop *ext_prop = to_usb_os_desc_ext_prop(item);
+ 
+ 	kfree(ext_prop); /* frees a whole chunk */
+ }
+ 
+ static struct configfs_item_operations ext_prop_ops = {
+ 	.release		= usb_os_desc_ext_prop_release,
+ };
+ 
+ static struct config_item *ext_prop_make(
+ 		struct config_group *group,
+ 		const char *name)
+ {
+ 	struct usb_os_desc_ext_prop *ext_prop;
+ 	struct config_item_type *ext_prop_type;
+ 	struct usb_os_desc *desc;
+ 	char *vlabuf;
+ 
+ 	vla_group(data_chunk);
+ 	vla_item(data_chunk, struct usb_os_desc_ext_prop, ext_prop, 1);
+ 	vla_item(data_chunk, struct config_item_type, ext_prop_type, 1);
+ 
+ 	vlabuf = kzalloc(vla_group_size(data_chunk), GFP_KERNEL);
+ 	if (!vlabuf)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	ext_prop = vla_ptr(vlabuf, data_chunk, ext_prop);
+ 	ext_prop_type = vla_ptr(vlabuf, data_chunk, ext_prop_type);
+ 
+ 	desc = container_of(group, struct usb_os_desc, group);
+ 	ext_prop_type->ct_item_ops = &ext_prop_ops;
+ 	ext_prop_type->ct_attrs = ext_prop_attrs;
+ 	ext_prop_type->ct_owner = desc->owner;
+ 
+ 	config_item_init_type_name(&ext_prop->item, name, ext_prop_type);
+ 
+ 	ext_prop->name = kstrdup(name, GFP_KERNEL);
+ 	if (!ext_prop->name) {
+ 		kfree(vlabuf);
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 	desc->ext_prop_len += 14;
+ 	ext_prop->name_len = 2 * strlen(ext_prop->name) + 2;
+ 	if (desc->opts_mutex)
+ 		mutex_lock(desc->opts_mutex);
+ 	desc->ext_prop_len += ext_prop->name_len;
+ 	list_add_tail(&ext_prop->entry, &desc->ext_prop);
+ 	++desc->ext_prop_count;
+ 	if (desc->opts_mutex)
+ 		mutex_unlock(desc->opts_mutex);
+ 
+ 	return &ext_prop->item;
+ }
+ 
+ static void ext_prop_drop(struct config_group *group, struct config_item *item)
+ {
+ 	struct usb_os_desc_ext_prop *ext_prop = to_usb_os_desc_ext_prop(item);
+ 	struct usb_os_desc *desc = to_usb_os_desc(&group->cg_item);
+ 
+ 	if (desc->opts_mutex)
+ 		mutex_lock(desc->opts_mutex);
+ 	list_del(&ext_prop->entry);
+ 	--desc->ext_prop_count;
+ 	kfree(ext_prop->name);
+ 	desc->ext_prop_len -= (ext_prop->name_len + ext_prop->data_len + 14);
+ 	if (desc->opts_mutex)
+ 		mutex_unlock(desc->opts_mutex);
+ 	config_item_put(item);
+ }
+ 
+ static struct configfs_group_operations interf_grp_ops = {
+ 	.make_item	= &ext_prop_make,
+ 	.drop_item	= &ext_prop_drop,
+ };
+ 
+ static ssize_t interf_grp_compatible_id_show(struct config_item *item,
+ 					     char *page)
+ {
+ 	memcpy(page, to_usb_os_desc(item)->ext_compat_id, 8);
+ 	return 8;
+ }
+ 
+ static ssize_t interf_grp_compatible_id_store(struct config_item *item,
+ 					      const char *page, size_t len)
+ {
+ 	struct usb_os_desc *desc = to_usb_os_desc(item);
+ 	int l;
+ 
+ 	l = min_t(int, 8, len);
+ 	if (page[l - 1] == '\n')
+ 		--l;
+ 	if (desc->opts_mutex)
+ 		mutex_lock(desc->opts_mutex);
+ 	memcpy(desc->ext_compat_id, page, l);
+ 
+ 	if (desc->opts_mutex)
+ 		mutex_unlock(desc->opts_mutex);
+ 
+ 	return len;
+ }
+ 
+ static ssize_t interf_grp_sub_compatible_id_show(struct config_item *item,
+ 						 char *page)
+ {
+ 	memcpy(page, to_usb_os_desc(item)->ext_compat_id + 8, 8);
+ 	return 8;
+ }
+ 
+ static ssize_t interf_grp_sub_compatible_id_store(struct config_item *item,
+ 						  const char *page, size_t len)
+ {
+ 	struct usb_os_desc *desc = to_usb_os_desc(item);
+ 	int l;
+ 
+ 	l = min_t(int, 8, len);
+ 	if (page[l - 1] == '\n')
+ 		--l;
+ 	if (desc->opts_mutex)
+ 		mutex_lock(desc->opts_mutex);
+ 	memcpy(desc->ext_compat_id + 8, page, l);
+ 
+ 	if (desc->opts_mutex)
+ 		mutex_unlock(desc->opts_mutex);
+ 
+ 	return len;
+ }
+ 
+ CONFIGFS_ATTR(interf_grp_, compatible_id);
+ CONFIGFS_ATTR(interf_grp_, sub_compatible_id);
+ 
+ static struct configfs_attribute *interf_grp_attrs[] = {
+ 	&interf_grp_attr_compatible_id,
+ 	&interf_grp_attr_sub_compatible_id,
+ 	NULL
+ };
+ 
+ int usb_os_desc_prepare_interf_dir(struct config_group *parent,
+ 				   int n_interf,
+ 				   struct usb_os_desc **desc,
+ 				   char **names,
+ 				   struct module *owner)
+ {
+ 	struct config_group **f_default_groups, *os_desc_group,
+ 				**interface_groups;
+ 	struct config_item_type *os_desc_type, *interface_type;
+ 
+ 	vla_group(data_chunk);
+ 	vla_item(data_chunk, struct config_group *, f_default_groups, 2);
+ 	vla_item(data_chunk, struct config_group, os_desc_group, 1);
+ 	vla_item(data_chunk, struct config_group *, interface_groups,
+ 		 n_interf + 1);
+ 	vla_item(data_chunk, struct config_item_type, os_desc_type, 1);
+ 	vla_item(data_chunk, struct config_item_type, interface_type, 1);
+ 
+ 	char *vlabuf = kzalloc(vla_group_size(data_chunk), GFP_KERNEL);
+ 	if (!vlabuf)
+ 		return -ENOMEM;
+ 
+ 	f_default_groups = vla_ptr(vlabuf, data_chunk, f_default_groups);
+ 	os_desc_group = vla_ptr(vlabuf, data_chunk, os_desc_group);
+ 	os_desc_type = vla_ptr(vlabuf, data_chunk, os_desc_type);
+ 	interface_groups = vla_ptr(vlabuf, data_chunk, interface_groups);
+ 	interface_type = vla_ptr(vlabuf, data_chunk, interface_type);
+ 
+ 	parent->default_groups = f_default_groups;
+ 	os_desc_type->ct_owner = owner;
+ 	config_group_init_type_name(os_desc_group, "os_desc", os_desc_type);
+ 	f_default_groups[0] = os_desc_group;
+ 
+ 	os_desc_group->default_groups = interface_groups;
+ 	interface_type->ct_group_ops = &interf_grp_ops;
+ 	interface_type->ct_attrs = interf_grp_attrs;
+ 	interface_type->ct_owner = owner;
+ 
+ 	while (n_interf--) {
+ 		struct usb_os_desc *d;
+ 
+ 		d = desc[n_interf];
+ 		d->owner = owner;
+ 		config_group_init_type_name(&d->group, "", interface_type);
+ 		config_item_set_name(&d->group.cg_item, "interface.%s",
+ 				     names[n_interf]);
+ 		interface_groups[n_interf] = &d->group;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(usb_os_desc_prepare_interf_dir);
+ 
++>>>>>>> 45b6a73f62eb (usb-gadget: use per-attribute show and store methods)
  static int configfs_do_nothing(struct usb_composite_dev *cdev)
  {
  	WARN_ON(1);
* Unmerged path drivers/usb/gadget/configfs.c
diff --git a/include/linux/usb/gadget_configfs.h b/include/linux/usb/gadget_configfs.h
index d74c0ae989d5..c36e95730de1 100644
--- a/include/linux/usb/gadget_configfs.h
+++ b/include/linux/usb/gadget_configfs.h
@@ -7,9 +7,10 @@ int check_user_usb_string(const char *name,
 		struct usb_gadget_strings *stringtab_dev);
 
 #define GS_STRINGS_W(__struct, __name)	\
-	static ssize_t __struct##_##__name##_store(struct __struct *gs, \
+static ssize_t __struct##_##__name##_store(struct config_item *item, \
 		const char *page, size_t len)		\
 {							\
+	struct __struct *gs = to_##__struct(item);	\
 	int ret;					\
 							\
 	ret = usb_string_copy(page, &gs->__name);	\
@@ -19,30 +20,20 @@ int check_user_usb_string(const char *name,
 }
 
 #define GS_STRINGS_R(__struct, __name)	\
-	static ssize_t __struct##_##__name##_show(struct __struct *gs, \
-			char *page)	\
+static ssize_t __struct##_##__name##_show(struct config_item *item, char *page) \
 {	\
+	struct __struct *gs = to_##__struct(item);	\
 	return sprintf(page, "%s\n", gs->__name ?: "");	\
 }
 
-#define GS_STRING_ITEM_ATTR(struct_name, name)	\
-	static struct struct_name##_attribute struct_name##_##name = \
-		__CONFIGFS_ATTR(name,  S_IRUGO | S_IWUSR,		\
-				struct_name##_##name##_show,		\
-				struct_name##_##name##_store)
-
 #define GS_STRINGS_RW(struct_name, _name)	\
 	GS_STRINGS_R(struct_name, _name)	\
 	GS_STRINGS_W(struct_name, _name)	\
-	GS_STRING_ITEM_ATTR(struct_name, _name)
+	CONFIGFS_ATTR(struct_name##_, _name)
 
 #define USB_CONFIG_STRING_RW_OPS(struct_in)				\
-	CONFIGFS_ATTR_OPS(struct_in);					\
-									\
 static struct configfs_item_operations struct_in##_langid_item_ops = {	\
 	.release                = struct_in##_attr_release,		\
-	.show_attribute         = struct_in##_attr_show,		\
-	.store_attribute        = struct_in##_attr_store,		\
 };									\
 									\
 static struct config_item_type struct_in##_langid_type = {		\
