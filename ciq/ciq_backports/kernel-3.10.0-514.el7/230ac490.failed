netfilter: bridge: split ipv6 code into separated file

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 230ac490f7fba2aea52914c69d14b15dd515e49c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/230ac490.failed

Resolve compilation breakage when CONFIG_IPV6 is not set by moving the IPv6
code into a separated br_netfilter_ipv6.c file.

Fixes: efb6de9b4ba0 ("netfilter: bridge: forward IPv6 fragmented packets")
	Reported-by: kbuild test robot <fengguang.wu@intel.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 230ac490f7fba2aea52914c69d14b15dd515e49c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/Makefile
#	net/bridge/br_netfilter.c
diff --cc net/bridge/Makefile
index be68796fdffd,a1cda5d4718d..000000000000
--- a/net/bridge/Makefile
+++ b/net/bridge/Makefile
@@@ -10,7 -10,11 +10,15 @@@ bridge-y	:= br.o br_device.o br_fdb.o b
  
  bridge-$(CONFIG_SYSFS) += br_sysfs_if.o br_sysfs_br.o
  
++<<<<<<< HEAD
 +bridge-$(CONFIG_BRIDGE_NETFILTER) += br_netfilter.o
++=======
+ bridge-$(subst m,y,$(CONFIG_BRIDGE_NETFILTER)) += br_nf_core.o
+ 
+ br_netfilter-y := br_netfilter_hooks.o
+ br_netfilter-$(subst m,y,$(CONFIG_IPV6)) += br_netfilter_ipv6.o
+ obj-$(CONFIG_BRIDGE_NETFILTER) += br_netfilter.o
++>>>>>>> 230ac490f7fb (netfilter: bridge: split ipv6 code into separated file)
  
  bridge-$(CONFIG_BRIDGE_IGMP_SNOOPING) += br_multicast.o br_mdb.o
  
diff --cc net/bridge/br_netfilter.c
index bfa28cea8c79,d89f4fac0bc5..000000000000
--- a/net/bridge/br_netfilter.c
+++ b/net/bridge/br_netfilter.c
@@@ -110,74 -108,29 +110,85 @@@ static inline __be16 pppoe_proto(const 
  	 pppoe_proto(skb) == htons(PPP_IPV6) && \
  	 brnf_filter_pppoe_tagged)
  
++<<<<<<< HEAD:net/bridge/br_netfilter.c
 +static void fake_update_pmtu(struct dst_entry *dst, struct sock *sk,
 +			     struct sk_buff *skb, u32 mtu)
 +{
 +}
 +
 +static void fake_redirect(struct dst_entry *dst, struct sock *sk,
 +			  struct sk_buff *skb)
++=======
+ /* largest possible L2 header, see br_nf_dev_queue_xmit() */
+ #define NF_BRIDGE_MAX_MAC_HEADER_LENGTH (PPPOE_SES_HLEN + ETH_HLEN)
+ 
+ #if IS_ENABLED(CONFIG_NF_DEFRAG_IPV4)
+ struct brnf_frag_data {
+ 	char mac[NF_BRIDGE_MAX_MAC_HEADER_LENGTH];
+ 	u8 encap_size;
+ 	u8 size;
+ 	u16 vlan_tci;
+ 	__be16 vlan_proto;
+ };
+ 
+ static DEFINE_PER_CPU(struct brnf_frag_data, brnf_frag_data_storage);
+ #endif
+ 
+ static void nf_bridge_info_free(struct sk_buff *skb)
++>>>>>>> 230ac490f7fb (netfilter: bridge: split ipv6 code into separated file):net/bridge/br_netfilter_hooks.c
  {
 -	if (skb->nf_bridge) {
 -		nf_bridge_put(skb->nf_bridge);
 -		skb->nf_bridge = NULL;
 -	}
 +}
 +
 +static u32 *fake_cow_metrics(struct dst_entry *dst, unsigned long old)
 +{
 +	return NULL;
 +}
 +
 +static struct neighbour *fake_neigh_lookup(const struct dst_entry *dst,
 +					   struct sk_buff *skb,
 +					   const void *daddr)
 +{
 +	return NULL;
 +}
 +
 +static unsigned int fake_mtu(const struct dst_entry *dst)
 +{
 +	return dst->dev->mtu;
 +}
 +
 +static struct dst_ops fake_dst_ops = {
 +	.family =		AF_INET,
 +	.protocol =		cpu_to_be16(ETH_P_IP),
 +	.update_pmtu =		fake_update_pmtu,
 +	.redirect =		fake_redirect,
 +	.cow_metrics =		fake_cow_metrics,
 +	.neigh_lookup =		fake_neigh_lookup,
 +	.mtu =			fake_mtu,
 +};
 +
 +/*
 + * Initialize bogus route table used to keep netfilter happy.
 + * Currently, we fill in the PMTU entry because netfilter
 + * refragmentation needs it, and the rt_flags entry because
 + * ipt_REJECT needs it.  Future netfilter modules might
 + * require us to fill additional fields.
 + */
 +static const u32 br_dst_default_metrics[RTAX_MAX] = {
 +	[RTAX_MTU - 1] = 1500,
 +};
 +
 +void br_netfilter_rtable_init(struct net_bridge *br)
 +{
 +	struct rtable *rt = &br->fake_rtable;
 +
 +	atomic_set(&rt->dst.__refcnt, 1);
 +	rt->dst.dev = br->dev;
 +	rt->dst.path = &rt->dst;
 +	dst_init_metrics(&rt->dst, br_dst_default_metrics, true);
 +	rt->dst.flags	= DST_NOXFRM | DST_NOPEER | DST_FAKE_RTABLE;
 +	rt->dst.ops = &fake_dst_ops;
  }
  
- static inline struct rtable *bridge_parent_rtable(const struct net_device *dev)
- {
- 	struct net_bridge_port *port;
- 
- 	port = br_port_get_rcu(dev);
- 	return port ? &port->br->fake_rtable : NULL;
- }
- 
  static inline struct net_device *bridge_parent(const struct net_device *dev)
  {
  	struct net_bridge_port *port;
@@@ -212,12 -156,16 +214,25 @@@ static inline struct nf_bridge_info *nf
  	return nf_bridge;
  }
  
++<<<<<<< HEAD:net/bridge/br_netfilter.c
 +static inline void nf_bridge_push_encap_header(struct sk_buff *skb)
 +{
 +	unsigned int len = nf_bridge_encap_header_len(skb);
 +
 +	skb_push(skb, len);
 +	skb->network_header -= len;
++=======
+ unsigned int nf_bridge_encap_header_len(const struct sk_buff *skb)
+ {
+ 	switch (skb->protocol) {
+ 	case __cpu_to_be16(ETH_P_8021Q):
+ 		return VLAN_HLEN;
+ 	case __cpu_to_be16(ETH_P_PPP_SES):
+ 		return PPPOE_SES_HLEN;
+ 	default:
+ 		return 0;
+ 	}
++>>>>>>> 230ac490f7fb (netfilter: bridge: split ipv6 code into separated file):net/bridge/br_netfilter_hooks.c
  }
  
  static inline void nf_bridge_pull_encap_header(struct sk_buff *skb)
@@@ -297,35 -237,18 +312,50 @@@ drop
  	return -1;
  }
  
++<<<<<<< HEAD:net/bridge/br_netfilter.c
 +/* PF_BRIDGE/PRE_ROUTING *********************************************/
 +/* Undo the changes made for ip6tables PREROUTING and continue the
 + * bridge PRE_ROUTING hook. */
 +static int br_nf_pre_routing_finish_ipv6(struct sock *sk, struct sk_buff *skb)
 +{
 +	struct nf_bridge_info *nf_bridge = skb->nf_bridge;
 +	struct rtable *rt;
 +
 +	if (nf_bridge->mask & BRNF_PKT_TYPE) {
 +		skb->pkt_type = PACKET_OTHERHOST;
 +		nf_bridge->mask ^= BRNF_PKT_TYPE;
 +	}
 +	nf_bridge->mask ^= BRNF_NF_BRIDGE_PREROUTING;
 +
 +	rt = bridge_parent_rtable(nf_bridge->physindev);
 +	if (!rt) {
 +		kfree_skb(skb);
 +		return 0;
 +	}
 +	skb_dst_set_noref(skb, &rt->dst);
 +
 +	skb->dev = nf_bridge->physindev;
 +	nf_bridge_update_protocol(skb);
 +	nf_bridge_push_encap_header(skb);
 +	NF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, sk, skb,
 +		       skb->dev, NULL,
 +		       br_handle_frame_finish, 1);
 +
 +	return 0;
++=======
+ void nf_bridge_update_protocol(struct sk_buff *skb)
+ {
+ 	switch (skb->nf_bridge->orig_proto) {
+ 	case BRNF_PROTO_8021Q:
+ 		skb->protocol = htons(ETH_P_8021Q);
+ 		break;
+ 	case BRNF_PROTO_PPPOE:
+ 		skb->protocol = htons(ETH_P_PPP_SES);
+ 		break;
+ 	case BRNF_PROTO_UNCHANGED:
+ 		break;
+ 	}
++>>>>>>> 230ac490f7fb (netfilter: bridge: split ipv6 code into separated file):net/bridge/br_netfilter_hooks.c
  }
  
  /* Obtain the correct destination MAC address, while preserving the original
@@@ -333,9 -256,8 +363,9 @@@
   * don't, we use the neighbour framework to find out. In both cases, we make
   * sure that br_handle_frame_finish() is called afterwards.
   */
- static int br_nf_pre_routing_finish_bridge(struct sock *sk, struct sk_buff *skb)
+ int br_nf_pre_routing_finish_bridge(struct sock *sk, struct sk_buff *skb)
  {
 +	struct nf_bridge_info *nf_bridge = skb->nf_bridge;
  	struct neighbour *neigh;
  	struct dst_entry *dst;
  
@@@ -372,20 -296,11 +402,28 @@@ free_skb
  	return 0;
  }
  
++<<<<<<< HEAD:net/bridge/br_netfilter.c
 +static bool dnat_took_place(const struct sk_buff *skb)
 +{
 +#if IS_ENABLED(CONFIG_NF_CONNTRACK)
 +	enum ip_conntrack_info ctinfo;
 +	struct nf_conn *ct;
 +
 +	ct = nf_ct_get(skb, &ctinfo);
 +	if (!ct || nf_ct_is_untracked(ct))
 +		return false;
 +
 +	return test_bit(IPS_DST_NAT_BIT, &ct->status);
 +#else
 +	return false;
 +#endif
++=======
+ static inline bool
+ br_nf_ipv4_daddr_was_changed(const struct sk_buff *skb,
+ 			     const struct nf_bridge_info *nf_bridge)
+ {
+ 	return ip_hdr(skb)->daddr != nf_bridge->ipv4_daddr;
++>>>>>>> 230ac490f7fb (netfilter: bridge: split ipv6 code into separated file):net/bridge/br_netfilter_hooks.c
  }
  
  /* This requires some explaining. If DNAT has taken place,
@@@ -434,12 -350,14 +472,17 @@@ static int br_nf_pre_routing_finish(str
  	struct rtable *rt;
  	int err;
  
 -	nf_bridge->frag_max_size = IPCB(skb)->frag_max_size;
 -
 -	if (nf_bridge->pkt_otherhost) {
 +	if (nf_bridge->mask & BRNF_PKT_TYPE) {
  		skb->pkt_type = PACKET_OTHERHOST;
 -		nf_bridge->pkt_otherhost = false;
 +		nf_bridge->mask ^= BRNF_PKT_TYPE;
  	}
++<<<<<<< HEAD:net/bridge/br_netfilter.c
 +	nf_bridge->mask ^= BRNF_NF_BRIDGE_PREROUTING;
 +	if (dnat_took_place(skb)) {
++=======
+ 	nf_bridge->mask &= ~BRNF_NF_BRIDGE_PREROUTING;
+ 	if (br_nf_ipv4_daddr_was_changed(skb, nf_bridge)) {
++>>>>>>> 230ac490f7fb (netfilter: bridge: split ipv6 code into separated file):net/bridge/br_netfilter_hooks.c
  		if ((err = ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, dev))) {
  			struct in_device *in_dev = __in_dev_get_rcu(dev);
  
@@@ -517,9 -435,9 +560,9 @@@ static struct net_device *brnf_get_logi
  }
  
  /* Some common code for IPv4/IPv6 */
- static struct net_device *setup_pre_routing(struct sk_buff *skb)
+ struct net_device *setup_pre_routing(struct sk_buff *skb)
  {
 -	struct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);
 +	struct nf_bridge_info *nf_bridge = skb->nf_bridge;
  
  	if (skb->pkt_type == PACKET_OTHERHOST) {
  		skb->pkt_type = PACKET_HOST;
@@@ -539,108 -458,6 +582,111 @@@
  	return skb->dev;
  }
  
++<<<<<<< HEAD:net/bridge/br_netfilter.c
 +/* We only check the length. A bridge shouldn't do any hop-by-hop stuff anyway */
 +static int check_hbh_len(struct sk_buff *skb)
 +{
 +	unsigned char *raw = (u8 *)(ipv6_hdr(skb) + 1);
 +	u32 pkt_len;
 +	const unsigned char *nh = skb_network_header(skb);
 +	int off = raw - nh;
 +	int len = (raw[1] + 1) << 3;
 +
 +	if ((raw + len) - skb->data > skb_headlen(skb))
 +		goto bad;
 +
 +	off += 2;
 +	len -= 2;
 +
 +	while (len > 0) {
 +		int optlen = nh[off + 1] + 2;
 +
 +		switch (nh[off]) {
 +		case IPV6_TLV_PAD1:
 +			optlen = 1;
 +			break;
 +
 +		case IPV6_TLV_PADN:
 +			break;
 +
 +		case IPV6_TLV_JUMBO:
 +			if (nh[off + 1] != 4 || (off & 3) != 2)
 +				goto bad;
 +			pkt_len = ntohl(*(__be32 *) (nh + off + 2));
 +			if (pkt_len <= IPV6_MAXPLEN ||
 +			    ipv6_hdr(skb)->payload_len)
 +				goto bad;
 +			if (pkt_len > skb->len - sizeof(struct ipv6hdr))
 +				goto bad;
 +			if (pskb_trim_rcsum(skb,
 +					    pkt_len + sizeof(struct ipv6hdr)))
 +				goto bad;
 +			nh = skb_network_header(skb);
 +			break;
 +		default:
 +			if (optlen > len)
 +				goto bad;
 +			break;
 +		}
 +		off += optlen;
 +		len -= optlen;
 +	}
 +	if (len == 0)
 +		return 0;
 +bad:
 +	return -1;
 +
 +}
 +
 +/* Replicate the checks that IPv6 does on packet reception and pass the packet
 + * to ip6tables, which doesn't support NAT, so things are fairly simple. */
 +static unsigned int br_nf_pre_routing_ipv6(const struct nf_hook_ops *ops,
 +					   struct sk_buff *skb,
 +					   const struct net_device *in,
 +					   const struct net_device *out,
 +					   const struct nf_hook_state *state)
 +{
 +	const struct ipv6hdr *hdr;
 +	u32 pkt_len;
 +
 +	if (skb->len < sizeof(struct ipv6hdr))
 +		return NF_DROP;
 +
 +	if (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))
 +		return NF_DROP;
 +
 +	hdr = ipv6_hdr(skb);
 +
 +	if (hdr->version != 6)
 +		return NF_DROP;
 +
 +	pkt_len = ntohs(hdr->payload_len);
 +
 +	if (pkt_len || hdr->nexthdr != NEXTHDR_HOP) {
 +		if (pkt_len + sizeof(struct ipv6hdr) > skb->len)
 +			return NF_DROP;
 +		if (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr)))
 +			return NF_DROP;
 +	}
 +	if (hdr->nexthdr == NEXTHDR_HOP && check_hbh_len(skb))
 +		return NF_DROP;
 +
 +	nf_bridge_put(skb->nf_bridge);
 +	if (!nf_bridge_alloc(skb))
 +		return NF_DROP;
 +	if (!setup_pre_routing(skb))
 +		return NF_DROP;
 +
 +	skb->protocol = htons(ETH_P_IPV6);
 +	NF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING, state->sk, skb,
 +		skb->dev, NULL,
 +		br_nf_pre_routing_finish_ipv6);
 +
 +	return NF_STOLEN;
 +}
 +
++=======
++>>>>>>> 230ac490f7fb (netfilter: bridge: split ipv6 code into separated file):net/bridge/br_netfilter_hooks.c
  /* Direct IPv6 traffic to br_nf_pre_routing_ipv6.
   * Replicate the checks that IPv4 does on packet reception.
   * Set skb->dev to the bridge device (i.e. parent of the
diff --git a/include/net/netfilter/br_netfilter.h b/include/net/netfilter/br_netfilter.h
index 2aa6048a55c1..bab824bde92c 100644
--- a/include/net/netfilter/br_netfilter.h
+++ b/include/net/netfilter/br_netfilter.h
@@ -1,6 +1,66 @@
 #ifndef _BR_NETFILTER_H_
 #define _BR_NETFILTER_H_
 
+#include "../../../net/bridge/br_private.h"
+
+static inline struct nf_bridge_info *nf_bridge_alloc(struct sk_buff *skb)
+{
+	skb->nf_bridge = kzalloc(sizeof(struct nf_bridge_info), GFP_ATOMIC);
+
+	if (likely(skb->nf_bridge))
+		atomic_set(&(skb->nf_bridge->use), 1);
+
+	return skb->nf_bridge;
+}
+
+void nf_bridge_update_protocol(struct sk_buff *skb);
+
+static inline struct nf_bridge_info *
+nf_bridge_info_get(const struct sk_buff *skb)
+{
+	return skb->nf_bridge;
+}
+
+unsigned int nf_bridge_encap_header_len(const struct sk_buff *skb);
+
+static inline void nf_bridge_push_encap_header(struct sk_buff *skb)
+{
+	unsigned int len = nf_bridge_encap_header_len(skb);
+
+	skb_push(skb, len);
+	skb->network_header -= len;
+}
+
+int br_nf_pre_routing_finish_bridge(struct sock *sk, struct sk_buff *skb);
+
+static inline struct rtable *bridge_parent_rtable(const struct net_device *dev)
+{
+	struct net_bridge_port *port;
+
+	port = br_port_get_rcu(dev);
+	return port ? &port->br->fake_rtable : NULL;
+}
+
+struct net_device *setup_pre_routing(struct sk_buff *skb);
 void br_netfilter_enable(void);
 
+#if IS_ENABLED(CONFIG_IPV6)
+int br_validate_ipv6(struct sk_buff *skb);
+unsigned int br_nf_pre_routing_ipv6(const struct nf_hook_ops *ops,
+				    struct sk_buff *skb,
+				    const struct nf_hook_state *state);
+#else
+static inline int br_validate_ipv6(struct sk_buff *skb)
+{
+	return -1;
+}
+
+static inline unsigned int
+br_nf_pre_routing_ipv6(const struct nf_hook_ops *ops, struct sk_buff *skb,
+		       const struct nf_hook_state *state)
+{
+	return NF_DROP;
+}
+#endif
+
 #endif /* _BR_NETFILTER_H_ */
* Unmerged path net/bridge/Makefile
* Unmerged path net/bridge/br_netfilter.c
diff --git a/net/bridge/br_netfilter_ipv6.c b/net/bridge/br_netfilter_ipv6.c
new file mode 100644
index 000000000000..6d12d2675c80
--- /dev/null
+++ b/net/bridge/br_netfilter_ipv6.c
@@ -0,0 +1,245 @@
+/*
+ *	Handle firewalling
+ *	Linux ethernet bridge
+ *
+ *	Authors:
+ *	Lennert Buytenhek		<buytenh@gnu.org>
+ *	Bart De Schuymer		<bdschuym@pandora.be>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *	Lennert dedicates this file to Kerstin Wurdinger.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/ip.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/if_vlan.h>
+#include <linux/if_pppox.h>
+#include <linux/ppp_defs.h>
+#include <linux/netfilter_bridge.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_ipv6.h>
+#include <linux/netfilter_arp.h>
+#include <linux/in_route.h>
+#include <linux/inetdevice.h>
+
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <net/addrconf.h>
+#include <net/route.h>
+#include <net/netfilter/br_netfilter.h>
+
+#include <asm/uaccess.h>
+#include "br_private.h"
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+#endif
+
+/* We only check the length. A bridge shouldn't do any hop-by-hop stuff
+ * anyway
+ */
+static int br_nf_check_hbh_len(struct sk_buff *skb)
+{
+	unsigned char *raw = (u8 *)(ipv6_hdr(skb) + 1);
+	u32 pkt_len;
+	const unsigned char *nh = skb_network_header(skb);
+	int off = raw - nh;
+	int len = (raw[1] + 1) << 3;
+
+	if ((raw + len) - skb->data > skb_headlen(skb))
+		goto bad;
+
+	off += 2;
+	len -= 2;
+
+	while (len > 0) {
+		int optlen = nh[off + 1] + 2;
+
+		switch (nh[off]) {
+		case IPV6_TLV_PAD1:
+			optlen = 1;
+			break;
+
+		case IPV6_TLV_PADN:
+			break;
+
+		case IPV6_TLV_JUMBO:
+			if (nh[off + 1] != 4 || (off & 3) != 2)
+				goto bad;
+			pkt_len = ntohl(*(__be32 *)(nh + off + 2));
+			if (pkt_len <= IPV6_MAXPLEN ||
+			    ipv6_hdr(skb)->payload_len)
+				goto bad;
+			if (pkt_len > skb->len - sizeof(struct ipv6hdr))
+				goto bad;
+			if (pskb_trim_rcsum(skb,
+					    pkt_len + sizeof(struct ipv6hdr)))
+				goto bad;
+			nh = skb_network_header(skb);
+			break;
+		default:
+			if (optlen > len)
+				goto bad;
+			break;
+		}
+		off += optlen;
+		len -= optlen;
+	}
+	if (len == 0)
+		return 0;
+bad:
+	return -1;
+}
+
+int br_validate_ipv6(struct sk_buff *skb)
+{
+	const struct ipv6hdr *hdr;
+	struct net_device *dev = skb->dev;
+	struct inet6_dev *idev = in6_dev_get(skb->dev);
+	u32 pkt_len;
+	u8 ip6h_len = sizeof(struct ipv6hdr);
+
+	if (!pskb_may_pull(skb, ip6h_len))
+		goto inhdr_error;
+
+	if (skb->len < ip6h_len)
+		goto drop;
+
+	hdr = ipv6_hdr(skb);
+
+	if (hdr->version != 6)
+		goto inhdr_error;
+
+	pkt_len = ntohs(hdr->payload_len);
+
+	if (pkt_len || hdr->nexthdr != NEXTHDR_HOP) {
+		if (pkt_len + ip6h_len > skb->len) {
+			IP6_INC_STATS_BH(dev_net(dev), idev,
+					 IPSTATS_MIB_INTRUNCATEDPKTS);
+			goto drop;
+		}
+		if (pskb_trim_rcsum(skb, pkt_len + ip6h_len)) {
+			IP6_INC_STATS_BH(dev_net(dev), idev,
+					 IPSTATS_MIB_INDISCARDS);
+			goto drop;
+		}
+	}
+	if (hdr->nexthdr == NEXTHDR_HOP && br_nf_check_hbh_len(skb))
+		goto drop;
+
+	memset(IP6CB(skb), 0, sizeof(struct inet6_skb_parm));
+	/* No IP options in IPv6 header; however it should be
+	 * checked if some next headers need special treatment
+	 */
+	return 0;
+
+inhdr_error:
+	IP6_INC_STATS_BH(dev_net(dev), idev, IPSTATS_MIB_INHDRERRORS);
+drop:
+	return -1;
+}
+
+static inline bool
+br_nf_ipv6_daddr_was_changed(const struct sk_buff *skb,
+			     const struct nf_bridge_info *nf_bridge)
+{
+	return memcmp(&nf_bridge->ipv6_daddr, &ipv6_hdr(skb)->daddr,
+		      sizeof(ipv6_hdr(skb)->daddr)) != 0;
+}
+
+/* PF_BRIDGE/PRE_ROUTING: Undo the changes made for ip6tables
+ * PREROUTING and continue the bridge PRE_ROUTING hook. See comment
+ * for br_nf_pre_routing_finish(), same logic is used here but
+ * equivalent IPv6 function ip6_route_input() called indirectly.
+ */
+static int br_nf_pre_routing_finish_ipv6(struct sock *sk, struct sk_buff *skb)
+{
+	struct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);
+	struct rtable *rt;
+	struct net_device *dev = skb->dev;
+	const struct nf_ipv6_ops *v6ops = nf_get_ipv6_ops();
+
+	nf_bridge->frag_max_size = IP6CB(skb)->frag_max_size;
+
+	if (nf_bridge->pkt_otherhost) {
+		skb->pkt_type = PACKET_OTHERHOST;
+		nf_bridge->pkt_otherhost = false;
+	}
+	nf_bridge->mask &= ~BRNF_NF_BRIDGE_PREROUTING;
+	if (br_nf_ipv6_daddr_was_changed(skb, nf_bridge)) {
+		skb_dst_drop(skb);
+		v6ops->route_input(skb);
+
+		if (skb_dst(skb)->error) {
+			kfree_skb(skb);
+			return 0;
+		}
+
+		if (skb_dst(skb)->dev == dev) {
+			skb->dev = nf_bridge->physindev;
+			nf_bridge_update_protocol(skb);
+			nf_bridge_push_encap_header(skb);
+			NF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,
+				       sk, skb, skb->dev, NULL,
+				       br_nf_pre_routing_finish_bridge,
+				       1);
+			return 0;
+		}
+		ether_addr_copy(eth_hdr(skb)->h_dest, dev->dev_addr);
+		skb->pkt_type = PACKET_HOST;
+	} else {
+		rt = bridge_parent_rtable(nf_bridge->physindev);
+		if (!rt) {
+			kfree_skb(skb);
+			return 0;
+		}
+		skb_dst_set_noref(skb, &rt->dst);
+	}
+
+	skb->dev = nf_bridge->physindev;
+	nf_bridge_update_protocol(skb);
+	nf_bridge_push_encap_header(skb);
+	NF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, sk, skb,
+		       skb->dev, NULL,
+		       br_handle_frame_finish, 1);
+
+	return 0;
+}
+
+/* Replicate the checks that IPv6 does on packet reception and pass the packet
+ * to ip6tables.
+ */
+unsigned int br_nf_pre_routing_ipv6(const struct nf_hook_ops *ops,
+				    struct sk_buff *skb,
+				    const struct nf_hook_state *state)
+{
+	struct nf_bridge_info *nf_bridge;
+
+	if (br_validate_ipv6(skb))
+		return NF_DROP;
+
+	nf_bridge_put(skb->nf_bridge);
+	if (!nf_bridge_alloc(skb))
+		return NF_DROP;
+	if (!setup_pre_routing(skb))
+		return NF_DROP;
+
+	nf_bridge = nf_bridge_info_get(skb);
+	nf_bridge->ipv6_daddr = ipv6_hdr(skb)->daddr;
+
+	skb->protocol = htons(ETH_P_IPV6);
+	NF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING, state->sk, skb,
+		skb->dev, NULL,
+		br_nf_pre_routing_finish_ipv6);
+
+	return NF_STOLEN;
+}
