perf hists browser: Use hierarchy hpp list

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit a61a22f6845f9e86e0ca60d1d256a35ca12312ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a61a22f6.failed

Now hpp formats are linked using perf_hpp_list_node when hierarchy is
enabled.  Like in stdio, use this info to print entries with multiple
sort keys in a single hierarchy properly.

	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1457361308-514-7-git-send-email-namhyung@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit a61a22f6845f9e86e0ca60d1d256a35ca12312ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/ui/browsers/hists.c
diff --cc tools/perf/ui/browsers/hists.c
index d1445dd5bb7f,e0e217ec856b..000000000000
--- a/tools/perf/ui/browsers/hists.c
+++ b/tools/perf/ui/browsers/hists.c
@@@ -1213,6 -1277,233 +1213,236 @@@ static int hist_browser__show_entry(str
  	return printed;
  }
  
++<<<<<<< HEAD
++=======
+ static int hist_browser__show_hierarchy_entry(struct hist_browser *browser,
+ 					      struct hist_entry *entry,
+ 					      unsigned short row,
+ 					      int level)
+ {
+ 	int printed = 0;
+ 	int width = browser->b.width;
+ 	char folded_sign = ' ';
+ 	bool current_entry = ui_browser__is_current_entry(&browser->b, row);
+ 	off_t row_offset = entry->row_offset;
+ 	bool first = true;
+ 	struct perf_hpp_fmt *fmt;
+ 	struct perf_hpp_list_node *fmt_node;
+ 	struct hpp_arg arg = {
+ 		.b		= &browser->b,
+ 		.current_entry	= current_entry,
+ 	};
+ 	int column = 0;
+ 	int hierarchy_indent = (entry->hists->nr_hpp_node - 2) * HIERARCHY_INDENT;
+ 
+ 	if (current_entry) {
+ 		browser->he_selection = entry;
+ 		browser->selection = &entry->ms;
+ 	}
+ 
+ 	hist_entry__init_have_children(entry);
+ 	folded_sign = hist_entry__folded(entry);
+ 	arg.folded_sign = folded_sign;
+ 
+ 	if (entry->leaf && row_offset) {
+ 		row_offset--;
+ 		goto show_callchain;
+ 	}
+ 
+ 	hist_browser__gotorc(browser, row, 0);
+ 
+ 	if (current_entry && browser->b.navkeypressed)
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_SELECTED);
+ 	else
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_NORMAL);
+ 
+ 	ui_browser__write_nstring(&browser->b, "", level * HIERARCHY_INDENT);
+ 	width -= level * HIERARCHY_INDENT;
+ 
+ 	/* the first hpp_list_node is for overhead columns */
+ 	fmt_node = list_first_entry(&entry->hists->hpp_formats,
+ 				    struct perf_hpp_list_node, list);
+ 	perf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {
+ 		char s[2048];
+ 		struct perf_hpp hpp = {
+ 			.buf		= s,
+ 			.size		= sizeof(s),
+ 			.ptr		= &arg,
+ 		};
+ 
+ 		if (perf_hpp__should_skip(fmt, entry->hists) ||
+ 		    column++ < browser->b.horiz_scroll)
+ 			continue;
+ 
+ 		if (current_entry && browser->b.navkeypressed) {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_SELECTED);
+ 		} else {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_NORMAL);
+ 		}
+ 
+ 		if (first) {
+ 			ui_browser__printf(&browser->b, "%c", folded_sign);
+ 			width--;
+ 			first = false;
+ 		} else {
+ 			ui_browser__printf(&browser->b, "  ");
+ 			width -= 2;
+ 		}
+ 
+ 		if (fmt->color) {
+ 			int ret = fmt->color(fmt, &hpp, entry);
+ 			hist_entry__snprintf_alignment(entry, &hpp, fmt, ret);
+ 			/*
+ 			 * fmt->color() already used ui_browser to
+ 			 * print the non alignment bits, skip it (+ret):
+ 			 */
+ 			ui_browser__printf(&browser->b, "%s", s + ret);
+ 		} else {
+ 			int ret = fmt->entry(fmt, &hpp, entry);
+ 			hist_entry__snprintf_alignment(entry, &hpp, fmt, ret);
+ 			ui_browser__printf(&browser->b, "%s", s);
+ 		}
+ 		width -= hpp.buf - s;
+ 	}
+ 
+ 	ui_browser__write_nstring(&browser->b, "", hierarchy_indent);
+ 	width -= hierarchy_indent;
+ 
+ 	if (column >= browser->b.horiz_scroll) {
+ 		char s[2048];
+ 		struct perf_hpp hpp = {
+ 			.buf		= s,
+ 			.size		= sizeof(s),
+ 			.ptr		= &arg,
+ 		};
+ 
+ 		if (current_entry && browser->b.navkeypressed) {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_SELECTED);
+ 		} else {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_NORMAL);
+ 		}
+ 
+ 		perf_hpp_list__for_each_format(entry->hpp_list, fmt) {
+ 			ui_browser__write_nstring(&browser->b, "", 2);
+ 			width -= 2;
+ 
+ 			/*
+ 			 * No need to call hist_entry__snprintf_alignment()
+ 			 * since this fmt is always the last column in the
+ 			 * hierarchy mode.
+ 			 */
+ 			if (fmt->color) {
+ 				width -= fmt->color(fmt, &hpp, entry);
+ 			} else {
+ 				int i = 0;
+ 
+ 				width -= fmt->entry(fmt, &hpp, entry);
+ 				ui_browser__printf(&browser->b, "%s", ltrim(s));
+ 
+ 				while (isspace(s[i++]))
+ 					width++;
+ 			}
+ 		}
+ 	}
+ 
+ 	/* The scroll bar isn't being used */
+ 	if (!browser->b.navkeypressed)
+ 		width += 1;
+ 
+ 	ui_browser__write_nstring(&browser->b, "", width);
+ 
+ 	++row;
+ 	++printed;
+ 
+ show_callchain:
+ 	if (entry->leaf && folded_sign == '-' && row != browser->b.rows) {
+ 		struct callchain_print_arg carg = {
+ 			.row_offset = row_offset,
+ 		};
+ 
+ 		printed += hist_browser__show_callchain(browser, entry,
+ 					level + 1, row,
+ 					hist_browser__show_callchain_entry, &carg,
+ 					hist_browser__check_output_full);
+ 	}
+ 
+ 	return printed;
+ }
+ 
+ static int hist_browser__show_no_entry(struct hist_browser *browser,
+ 				       unsigned short row, int level)
+ {
+ 	int width = browser->b.width;
+ 	bool current_entry = ui_browser__is_current_entry(&browser->b, row);
+ 	bool first = true;
+ 	int column = 0;
+ 	int ret;
+ 	struct perf_hpp_fmt *fmt;
+ 	struct perf_hpp_list_node *fmt_node;
+ 	int indent = browser->hists->nr_hpp_node - 2;
+ 
+ 	if (current_entry) {
+ 		browser->he_selection = NULL;
+ 		browser->selection = NULL;
+ 	}
+ 
+ 	hist_browser__gotorc(browser, row, 0);
+ 
+ 	if (current_entry && browser->b.navkeypressed)
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_SELECTED);
+ 	else
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_NORMAL);
+ 
+ 	ui_browser__write_nstring(&browser->b, "", level * HIERARCHY_INDENT);
+ 	width -= level * HIERARCHY_INDENT;
+ 
+ 	/* the first hpp_list_node is for overhead columns */
+ 	fmt_node = list_first_entry(&browser->hists->hpp_formats,
+ 				    struct perf_hpp_list_node, list);
+ 	perf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {
+ 		if (perf_hpp__should_skip(fmt, browser->hists) ||
+ 		    column++ < browser->b.horiz_scroll)
+ 			continue;
+ 
+ 		ret = fmt->width(fmt, NULL, hists_to_evsel(browser->hists));
+ 
+ 		if (first) {
+ 			/* for folded sign */
+ 			first = false;
+ 			ret++;
+ 		} else {
+ 			/* space between columns */
+ 			ret += 2;
+ 		}
+ 
+ 		ui_browser__write_nstring(&browser->b, "", ret);
+ 		width -= ret;
+ 	}
+ 
+ 	ui_browser__write_nstring(&browser->b, "", indent * HIERARCHY_INDENT);
+ 	width -= indent * HIERARCHY_INDENT;
+ 
+ 	if (column >= browser->b.horiz_scroll) {
+ 		char buf[32];
+ 
+ 		ret = snprintf(buf, sizeof(buf), "no entry >= %.2f%%", browser->min_pcnt);
+ 		ui_browser__printf(&browser->b, "  %s", buf);
+ 		width -= ret + 2;
+ 	}
+ 
+ 	/* The scroll bar isn't being used */
+ 	if (!browser->b.navkeypressed)
+ 		width += 1;
+ 
+ 	ui_browser__write_nstring(&browser->b, "", width);
+ 	return 1;
+ }
+ 
++>>>>>>> a61a22f6845f (perf hists browser: Use hierarchy hpp list)
  static int advance_hpp_check(struct perf_hpp *hpp, int inc)
  {
  	advance_hpp(hpp, inc);
@@@ -1260,10 -1551,11 +1490,16 @@@ static int hists_browser__scnprintf_hie
  		.size   = size,
  	};
  	struct perf_hpp_fmt *fmt;
+ 	struct perf_hpp_list_node *fmt_node;
  	size_t ret = 0;
  	int column = 0;
++<<<<<<< HEAD
 +	int nr_sort_keys = hists->hpp_list->nr_sort_keys;
 +	bool first = true;
++=======
+ 	int indent = hists->nr_hpp_node - 2;
+ 	bool first_node, first_col;
++>>>>>>> a61a22f6845f (perf hists browser: Use hierarchy hpp list)
  
  	ret = scnprintf(buf, size, " ");
  	if (advance_hpp_check(&dummy_hpp, ret))
@@@ -1290,27 -1582,42 +1526,60 @@@
  	if (advance_hpp_check(&dummy_hpp, ret))
  		return ret;
  
++<<<<<<< HEAD
 +	hists__for_each_format(hists, fmt) {
 +		if (!perf_hpp__is_sort_entry(fmt) && !perf_hpp__is_dynamic_entry(fmt))
 +			continue;
 +		if (perf_hpp__should_skip(fmt, hists))
 +			continue;
 +
 +		if (first) {
 +			first = false;
 +		} else {
++=======
+ 	first_node = true;
+ 	list_for_each_entry_continue(fmt_node, &hists->hpp_formats, list) {
+ 		if (!first_node) {
++>>>>>>> a61a22f6845f (perf hists browser: Use hierarchy hpp list)
  			ret = scnprintf(dummy_hpp.buf, dummy_hpp.size, " / ");
  			if (advance_hpp_check(&dummy_hpp, ret))
  				break;
  		}
+ 		first_node = false;
  
- 		ret = fmt->header(fmt, &dummy_hpp, hists_to_evsel(hists));
- 		dummy_hpp.buf[ret] = '\0';
- 		rtrim(dummy_hpp.buf);
+ 		first_col = true;
+ 		perf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {
+ 			char *start;
  
++<<<<<<< HEAD
 +		ret = strlen(dummy_hpp.buf);
 +		if (advance_hpp_check(&dummy_hpp, ret))
 +			break;
++=======
+ 			if (perf_hpp__should_skip(fmt, hists))
+ 				continue;
+ 
+ 			if (!first_col) {
+ 				ret = scnprintf(dummy_hpp.buf, dummy_hpp.size, "+");
+ 				if (advance_hpp_check(&dummy_hpp, ret))
+ 					break;
+ 			}
+ 			first_col = false;
+ 
+ 			ret = fmt->header(fmt, &dummy_hpp, hists_to_evsel(hists));
+ 			dummy_hpp.buf[ret] = '\0';
+ 			rtrim(dummy_hpp.buf);
+ 
+ 			start = ltrim(dummy_hpp.buf);
+ 			ret = strlen(start);
+ 
+ 			if (start != dummy_hpp.buf)
+ 				memmove(dummy_hpp.buf, start, ret + 1);
+ 
+ 			if (advance_hpp_check(&dummy_hpp, ret))
+ 				break;
+ 		}
++>>>>>>> a61a22f6845f (perf hists browser: Use hierarchy hpp list)
  	}
  
  	return ret;
@@@ -1368,7 -1678,20 +1637,24 @@@ static unsigned int hist_browser__refre
  		if (percent < hb->min_pcnt)
  			continue;
  
++<<<<<<< HEAD
 +		row += hist_browser__show_entry(hb, h, row);
++=======
+ 		if (symbol_conf.report_hierarchy) {
+ 			row += hist_browser__show_hierarchy_entry(hb, h, row,
+ 								  h->depth);
+ 			if (row == browser->rows)
+ 				break;
+ 
+ 			if (h->has_no_entry) {
+ 				hist_browser__show_no_entry(hb, row, h->depth + 1);
+ 				row++;
+ 			}
+ 		} else {
+ 			row += hist_browser__show_entry(hb, h, row);
+ 		}
+ 
++>>>>>>> a61a22f6845f (perf hists browser: Use hierarchy hpp list)
  		if (row == browser->rows)
  			break;
  	}
* Unmerged path tools/perf/ui/browsers/hists.c
