net: sctp: Move sequence start handling into sctp_transport_get_idx()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] sctp: Move sequence start handling into sctp_transport_get_idx() (Xin Long) [1187584]
Rebuild_FUZZ: 96.24%
commit-author Geert Uytterhoeven <geert@linux-m68k.org>
commit fb3311853c0f23391fc3441d49a46d076de57757
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fb331185.failed

net/sctp/proc.c: In function ‘sctp_transport_get_idx’:
net/sctp/proc.c:313: warning: ‘obj’ may be used uninitialized in this function

This is currently a false positive, as all callers check for a zero
offset first, and handle this case in the exact same way.

Move the check and handling into sctp_transport_get_idx() to kill the
compiler warning, and avoid future bugs.

	Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
	Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fb3311853c0f23391fc3441d49a46d076de57757)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/proc.c
diff --cc net/sctp/proc.c
index aaeecb033eeb,684c5b31563b..000000000000
--- a/net/sctp/proc.c
+++ b/net/sctp/proc.c
@@@ -288,16 -281,96 +288,91 @@@ void sctp_eps_proc_exit(struct net *net
  	remove_proc_entry("eps", net->sctp.proc_net_sctp);
  }
  
 -struct sctp_ht_iter {
 -	struct seq_net_private p;
 -	struct rhashtable_iter hti;
 -};
  
 -static struct sctp_transport *sctp_transport_get_next(struct seq_file *seq)
 +static void * sctp_assocs_seq_start(struct seq_file *seq, loff_t *pos)
  {
 -	struct sctp_ht_iter *iter = seq->private;
 -	struct sctp_transport *t;
 +	if (*pos >= sctp_assoc_hashsize)
 +		return NULL;
  
 -	t = rhashtable_walk_next(&iter->hti);
 -	for (; t; t = rhashtable_walk_next(&iter->hti)) {
 -		if (IS_ERR(t)) {
 -			if (PTR_ERR(t) == -EAGAIN)
 -				continue;
 -			break;
 -		}
 +	if (*pos < 0)
 +		*pos = 0;
  
++<<<<<<< HEAD
 +	if (*pos == 0)
++=======
+ 		if (net_eq(sock_net(t->asoc->base.sk), seq_file_net(seq)) &&
+ 		    t->asoc->peer.primary_path == t)
+ 			break;
+ 	}
+ 
+ 	return t;
+ }
+ 
+ static struct sctp_transport *sctp_transport_get_idx(struct seq_file *seq,
+ 						     loff_t pos)
+ {
+ 	void *obj = SEQ_START_TOKEN;
+ 
+ 	while (pos && (obj = sctp_transport_get_next(seq)) && !IS_ERR(obj))
+ 		pos--;
+ 
+ 	return obj;
+ }
+ 
+ static int sctp_transport_walk_start(struct seq_file *seq)
+ {
+ 	struct sctp_ht_iter *iter = seq->private;
+ 	int err;
+ 
+ 	err = rhashtable_walk_init(&sctp_transport_hashtable, &iter->hti);
+ 	if (err)
+ 		return err;
+ 
+ 	err = rhashtable_walk_start(&iter->hti);
+ 
+ 	return err == -EAGAIN ? 0 : err;
+ }
+ 
+ static void sctp_transport_walk_stop(struct seq_file *seq)
+ {
+ 	struct sctp_ht_iter *iter = seq->private;
+ 
+ 	rhashtable_walk_stop(&iter->hti);
+ 	rhashtable_walk_exit(&iter->hti);
+ }
+ 
+ static void *sctp_assocs_seq_start(struct seq_file *seq, loff_t *pos)
+ {
+ 	int err = sctp_transport_walk_start(seq);
+ 
+ 	if (err)
+ 		return ERR_PTR(err);
+ 
+ 	return sctp_transport_get_idx(seq, *pos);
+ }
+ 
+ static void sctp_assocs_seq_stop(struct seq_file *seq, void *v)
+ {
+ 	sctp_transport_walk_stop(seq);
+ }
+ 
+ static void *sctp_assocs_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+ {
+ 	++*pos;
+ 
+ 	return sctp_transport_get_next(seq);
+ }
+ 
+ /* Display sctp associations (/proc/net/sctp/assocs). */
+ static int sctp_assocs_seq_show(struct seq_file *seq, void *v)
+ {
+ 	struct sctp_transport *transport;
+ 	struct sctp_association *assoc;
+ 	struct sctp_ep_common *epb;
+ 	struct sock *sk;
+ 
+ 	if (v == SEQ_START_TOKEN) {
++>>>>>>> fb3311853c0f (net: sctp: Move sequence start handling into sctp_transport_get_idx())
  		seq_printf(seq, " ASSOC     SOCK   STY SST ST HBKT "
  				"ASSOC-ID TX_QUEUE RX_QUEUE UID INODE LPORT "
  				"RPORT LADDRS <-> RADDRS "
@@@ -416,17 -457,12 +491,21 @@@ void sctp_assocs_proc_exit(struct net *
  
  static void *sctp_remaddr_seq_start(struct seq_file *seq, loff_t *pos)
  {
 -	int err = sctp_transport_walk_start(seq);
 +	if (*pos >= sctp_assoc_hashsize)
 +		return NULL;
  
 -	if (err)
 -		return ERR_PTR(err);
 +	if (*pos < 0)
 +		*pos = 0;
 +
++<<<<<<< HEAD
 +	if (*pos == 0)
 +		seq_printf(seq, "ADDR ASSOC_ID HB_ACT RTO MAX_PATH_RTX "
 +				"REM_ADDR_RTX START STATE\n");
  
 +	return (void *)pos;
++=======
+ 	return sctp_transport_get_idx(seq, *pos);
++>>>>>>> fb3311853c0f (net: sctp: Move sequence start handling into sctp_transport_get_idx())
  }
  
  static void *sctp_remaddr_seq_next(struct seq_file *seq, void *v, loff_t *pos)
* Unmerged path net/sctp/proc.c
