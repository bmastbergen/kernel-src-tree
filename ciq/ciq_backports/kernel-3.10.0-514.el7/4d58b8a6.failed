iommu/amd: Handle errors returned from iommu_init_device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [iommu] amd: Handle errors returned from iommu_init_device (Myron Stowe) [1050021]
Rebuild_FUZZ: 94.34%
commit-author Joerg Roedel <jroedel@suse.de>
commit 4d58b8a6de6b8c3611f10124f83e90e5a2406437
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4d58b8a6.failed

Without this patch only -ENOTSUPP is handled, but there are
other possible errors. Handle them too.

	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 4d58b8a6de6b8c3611f10124f83e90e5a2406437)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/amd_iommu.c
diff --cc drivers/iommu/amd_iommu.c
index 9bce8cd33ccb,e5b77d398e9b..000000000000
--- a/drivers/iommu/amd_iommu.c
+++ b/drivers/iommu/amd_iommu.c
@@@ -2369,44 -2250,57 +2369,73 @@@ static void detach_device(struct devic
  	dev_data->ats.enabled = false;
  }
  
 -static int amd_iommu_add_device(struct device *dev)
 +/*
 + * Find out the protection domain structure for a given PCI device. This
 + * will give us the pointer to the page table root for example.
 + */
 +static struct protection_domain *domain_for_device(struct device *dev)
  {
  	struct iommu_dev_data *dev_data;
 -	struct iommu_domain *domain;
 -	struct amd_iommu *iommu;
 -	u16 devid;
 -	int ret;
 +	struct protection_domain *dom = NULL;
 +	unsigned long flags;
  
 -	if (!check_device(dev) || get_dev_data(dev))
 -		return 0;
 +	dev_data   = get_dev_data(dev);
  
 -	devid = get_device_id(dev);
 -	iommu = amd_iommu_rlookup_table[devid];
 +	if (dev_data->domain)
 +		return dev_data->domain;
  
++<<<<<<< HEAD
 +	if (dev_data->alias_data != NULL) {
 +		struct iommu_dev_data *alias_data = dev_data->alias_data;
 +
 +		read_lock_irqsave(&amd_iommu_devtable_lock, flags);
 +		if (alias_data->domain != NULL) {
 +			__attach_device(dev_data, alias_data->domain);
 +			dom = alias_data->domain;
 +		}
 +		read_unlock_irqrestore(&amd_iommu_devtable_lock, flags);
++=======
+ 	ret = iommu_init_device(dev);
+ 	if (ret) {
+ 		if (ret != -ENOTSUPP)
+ 			pr_err("Failed to initialize device %s - trying to proceed anyway\n",
+ 				dev_name(dev));
+ 
+ 		iommu_ignore_device(dev);
+ 		dev->archdata.dma_ops = &nommu_dma_ops;
+ 		goto out;
+ 	}
+ 	init_iommu_group(dev);
+ 
+ 	dev_data = get_dev_data(dev);
+ 
+ 	BUG_ON(!dev_data);
+ 
+ 	if (dev_data->iommu_v2)
+ 		iommu_request_dm_for_dev(dev);
+ 
+ 	/* Domains are initialized for this device - have a look what we ended up with */
+ 	domain = iommu_get_domain_for_dev(dev);
+ 	if (domain->type == IOMMU_DOMAIN_IDENTITY) {
+ 		dev_data->passthrough = true;
+ 		dev->archdata.dma_ops = &nommu_dma_ops;
+ 	} else {
+ 		dev->archdata.dma_ops = &amd_iommu_dma_ops;
++>>>>>>> 4d58b8a6de6b (iommu/amd: Handle errors returned from iommu_init_device)
  	}
  
 -out:
 -	iommu_completion_wait(iommu);
 -
 -	return 0;
 +	return dom;
  }
  
 -static void amd_iommu_remove_device(struct device *dev)
 +static int device_change_notifier(struct notifier_block *nb,
 +				  unsigned long action, void *data)
  {
 +	struct dma_ops_domain *dma_domain;
 +	struct protection_domain *domain;
 +	struct iommu_dev_data *dev_data;
 +	struct device *dev = data;
  	struct amd_iommu *iommu;
 +	unsigned long flags;
  	u16 devid;
  
  	if (!check_device(dev))
* Unmerged path drivers/iommu/amd_iommu.c
