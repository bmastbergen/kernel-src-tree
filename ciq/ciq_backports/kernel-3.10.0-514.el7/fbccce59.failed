openvswitch: Extend ct_state match field to 32 bits

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Joe Stringer <joestringer@nicira.com>
commit fbccce5965a58d56aaed9e9acd1bec75d8a66e87
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fbccce59.failed

The ct_state field was initially added as an 8-bit field, however six of
the bits are already being used and use cases are already starting to
appear that may push the limits of this field. This patch extends the
field to 32 bits while retaining the internal representation of 8 bits.
This should cover forward compatibility of the ABI for the foreseeable
future.

This patch also reorders the OVS_CS_F_* bits to be sequential.

	Suggested-by: Jarno Rajahalme <jrajahalme@nicira.com>
	Signed-off-by: Joe Stringer <joestringer@nicira.com>
	Acked-by: Pravin B Shelar <pshelar@nicira.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fbccce5965a58d56aaed9e9acd1bec75d8a66e87)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/openvswitch.h
#	net/openvswitch/conntrack.c
#	net/openvswitch/conntrack.h
#	net/openvswitch/flow_netlink.c
diff --cc include/uapi/linux/openvswitch.h
index 1dab77601c21,c861a4cf5fec..000000000000
--- a/include/uapi/linux/openvswitch.h
+++ b/include/uapi/linux/openvswitch.h
@@@ -319,9 -323,13 +319,16 @@@ enum ovs_key_attr 
  	OVS_KEY_ATTR_MPLS,      /* array of struct ovs_key_mpls.
  				 * The implementation may restrict
  				 * the accepted length of the array. */
++<<<<<<< HEAD
++=======
+ 	OVS_KEY_ATTR_CT_STATE,	/* u32 bitmask of OVS_CS_F_* */
+ 	OVS_KEY_ATTR_CT_ZONE,	/* u16 connection tracking zone. */
+ 	OVS_KEY_ATTR_CT_MARK,	/* u32 connection tracking mark */
+ 	OVS_KEY_ATTR_CT_LABELS,	/* 16-octet connection tracking label */
++>>>>>>> fbccce5965a5 (openvswitch: Extend ct_state match field to 32 bits)
  
  #ifdef __KERNEL__
 -	OVS_KEY_ATTR_TUNNEL_INFO,  /* struct ip_tunnel_info */
 +	OVS_KEY_ATTR_TUNNEL_INFO,  /* struct ovs_tunnel_info */
  #endif
  	__OVS_KEY_ATTR_MAX
  };
@@@ -431,6 -439,20 +438,23 @@@ struct ovs_key_nd 
  	__u8	nd_tll[ETH_ALEN];
  };
  
++<<<<<<< HEAD
++=======
+ #define OVS_CT_LABELS_LEN	16
+ struct ovs_key_ct_labels {
+ 	__u8	ct_labels[OVS_CT_LABELS_LEN];
+ };
+ 
+ /* OVS_KEY_ATTR_CT_STATE flags */
+ #define OVS_CS_F_NEW               0x01 /* Beginning of a new connection. */
+ #define OVS_CS_F_ESTABLISHED       0x02 /* Part of an existing connection. */
+ #define OVS_CS_F_RELATED           0x04 /* Related to an established
+ 					 * connection. */
+ #define OVS_CS_F_REPLY_DIR         0x08 /* Flow is in the reply direction. */
+ #define OVS_CS_F_INVALID           0x10 /* Could not track connection. */
+ #define OVS_CS_F_TRACKED           0x20 /* Conntrack has occurred. */
+ 
++>>>>>>> fbccce5965a5 (openvswitch: Extend ct_state match field to 32 bits)
  /**
   * enum ovs_flow_attr - attributes for %OVS_FLOW_* commands.
   * @OVS_FLOW_ATTR_KEY: Nested %OVS_KEY_ATTR_* attributes specifying the flow
diff --cc net/openvswitch/flow_netlink.c
index 953a2c4bca92,171a691f1c32..000000000000
--- a/net/openvswitch/flow_netlink.c
+++ b/net/openvswitch/flow_netlink.c
@@@ -290,6 -291,10 +290,13 @@@ size_t ovs_key_attr_size(void
  		+ nla_total_size(4)   /* OVS_KEY_ATTR_SKB_MARK */
  		+ nla_total_size(4)   /* OVS_KEY_ATTR_DP_HASH */
  		+ nla_total_size(4)   /* OVS_KEY_ATTR_RECIRC_ID */
++<<<<<<< HEAD
++=======
+ 		+ nla_total_size(4)   /* OVS_KEY_ATTR_CT_STATE */
+ 		+ nla_total_size(2)   /* OVS_KEY_ATTR_CT_ZONE */
+ 		+ nla_total_size(4)   /* OVS_KEY_ATTR_CT_MARK */
+ 		+ nla_total_size(16)  /* OVS_KEY_ATTR_CT_LABELS */
++>>>>>>> fbccce5965a5 (openvswitch: Extend ct_state match field to 32 bits)
  		+ nla_total_size(12)  /* OVS_KEY_ATTR_ETHERNET */
  		+ nla_total_size(2)   /* OVS_KEY_ATTR_ETHERTYPE */
  		+ nla_total_size(4)   /* OVS_KEY_ATTR_VLAN */
@@@ -339,8 -349,19 +346,15 @@@ static const struct ovs_len_tbl ovs_key
  	[OVS_KEY_ATTR_TUNNEL]	 = { .len = OVS_ATTR_NESTED,
  				     .next = ovs_tunnel_key_lens, },
  	[OVS_KEY_ATTR_MPLS]	 = { .len = sizeof(struct ovs_key_mpls) },
++<<<<<<< HEAD
++=======
+ 	[OVS_KEY_ATTR_CT_STATE]	 = { .len = sizeof(u32) },
+ 	[OVS_KEY_ATTR_CT_ZONE]	 = { .len = sizeof(u16) },
+ 	[OVS_KEY_ATTR_CT_MARK]	 = { .len = sizeof(u32) },
+ 	[OVS_KEY_ATTR_CT_LABELS] = { .len = sizeof(struct ovs_key_ct_labels) },
++>>>>>>> fbccce5965a5 (openvswitch: Extend ct_state match field to 32 bits)
  };
  
 -static bool check_attr_len(unsigned int attr_len, unsigned int expected_len)
 -{
 -	return expected_len == attr_len ||
 -	       expected_len == OVS_ATTR_NESTED ||
 -	       expected_len == OVS_ATTR_VARIABLE;
 -}
 -
  static bool is_all_zero(const u8 *fp, size_t size)
  {
  	int i;
@@@ -768,6 -811,43 +782,46 @@@ static int metadata_from_nlattrs(struc
  			return -EINVAL;
  		*attrs &= ~(1 << OVS_KEY_ATTR_TUNNEL);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (*attrs & (1 << OVS_KEY_ATTR_CT_STATE) &&
+ 	    ovs_ct_verify(net, OVS_KEY_ATTR_CT_STATE)) {
+ 		u32 ct_state = nla_get_u32(a[OVS_KEY_ATTR_CT_STATE]);
+ 
+ 		if (!is_mask && !ovs_ct_state_supported(ct_state)) {
+ 			OVS_NLERR(log, "ct_state flags %08x unsupported",
+ 				  ct_state);
+ 			return -EINVAL;
+ 		}
+ 
+ 		SW_FLOW_KEY_PUT(match, ct.state, ct_state, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_STATE);
+ 	}
+ 	if (*attrs & (1 << OVS_KEY_ATTR_CT_ZONE) &&
+ 	    ovs_ct_verify(net, OVS_KEY_ATTR_CT_ZONE)) {
+ 		u16 ct_zone = nla_get_u16(a[OVS_KEY_ATTR_CT_ZONE]);
+ 
+ 		SW_FLOW_KEY_PUT(match, ct.zone, ct_zone, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_ZONE);
+ 	}
+ 	if (*attrs & (1 << OVS_KEY_ATTR_CT_MARK) &&
+ 	    ovs_ct_verify(net, OVS_KEY_ATTR_CT_MARK)) {
+ 		u32 mark = nla_get_u32(a[OVS_KEY_ATTR_CT_MARK]);
+ 
+ 		SW_FLOW_KEY_PUT(match, ct.mark, mark, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_MARK);
+ 	}
+ 	if (*attrs & (1 << OVS_KEY_ATTR_CT_LABELS) &&
+ 	    ovs_ct_verify(net, OVS_KEY_ATTR_CT_LABELS)) {
+ 		const struct ovs_key_ct_labels *cl;
+ 
+ 		cl = nla_data(a[OVS_KEY_ATTR_CT_LABELS]);
+ 		SW_FLOW_KEY_MEMCPY(match, ct.labels, cl->ct_labels,
+ 				   sizeof(*cl), is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_LABELS);
+ 	}
++>>>>>>> fbccce5965a5 (openvswitch: Extend ct_state match field to 32 bits)
  	return 0;
  }
  
* Unmerged path net/openvswitch/conntrack.c
* Unmerged path net/openvswitch/conntrack.h
* Unmerged path include/uapi/linux/openvswitch.h
* Unmerged path net/openvswitch/conntrack.c
* Unmerged path net/openvswitch/conntrack.h
* Unmerged path net/openvswitch/flow_netlink.c
