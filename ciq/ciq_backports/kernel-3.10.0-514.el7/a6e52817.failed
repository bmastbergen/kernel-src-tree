perf tools: Add event_update event unit type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit a6e5281780d1da65c15ce529707f43eb4a6df856
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a6e52817.failed

Adding unit type 'event update' event, that stores/transfer events unit
name. The unit name is part of the perf stat output data.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Kan Liang <kan.liang@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1445784728-21732-22-git-send-email-jolsa@kernel.org
[ Rename __alloc() to __new() for consistency ]
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit a6e5281780d1da65c15ce529707f43eb4a6df856)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/tests/Build
#	tools/perf/tests/builtin-test.c
#	tools/perf/tests/tests.h
#	tools/perf/util/event.h
#	tools/perf/util/header.c
diff --cc tools/perf/tests/Build
index d20d6e6ab65b,614899b88b37..000000000000
--- a/tools/perf/tests/Build
+++ b/tools/perf/tests/Build
@@@ -32,8 -31,33 +32,17 @@@ perf-y += sample-parsing.
  perf-y += parse-no-sample-id-all.o
  perf-y += kmod-path.o
  perf-y += thread-map.o
++<<<<<<< HEAD
++=======
+ perf-y += llvm.o llvm-src-base.o llvm-src-kbuild.o llvm-src-prologue.o
+ perf-y += bpf.o
+ perf-y += topology.o
+ perf-y += cpumap.o
+ perf-y += stat.o
+ perf-y += event_update.o
++>>>>>>> a6e5281780d1 (perf tools: Add event_update event unit type)
  
 -$(OUTPUT)tests/llvm-src-base.c: tests/bpf-script-example.c tests/Build
 -	$(call rule_mkdir)
 -	$(Q)echo '#include <tests/llvm.h>' > $@
 -	$(Q)echo 'const char test_llvm__bpf_base_prog[] =' >> $@
 -	$(Q)sed -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/g' $< >> $@
 -	$(Q)echo ';' >> $@
 -
 -$(OUTPUT)tests/llvm-src-kbuild.c: tests/bpf-script-test-kbuild.c tests/Build
 -	$(call rule_mkdir)
 -	$(Q)echo '#include <tests/llvm.h>' > $@
 -	$(Q)echo 'const char test_llvm__bpf_test_kbuild_prog[] =' >> $@
 -	$(Q)sed -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/g' $< >> $@
 -	$(Q)echo ';' >> $@
 -
 -$(OUTPUT)tests/llvm-src-prologue.c: tests/bpf-script-test-prologue.c tests/Build
 -	$(call rule_mkdir)
 -	$(Q)echo '#include <tests/llvm.h>' > $@
 -	$(Q)echo 'const char test_llvm__bpf_test_prologue_prog[] =' >> $@
 -	$(Q)sed -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/g' $< >> $@
 -	$(Q)echo ';' >> $@
 +perf-$(CONFIG_X86) += perf-time-to-tsc.o
  
  ifeq ($(ARCH),$(filter $(ARCH),x86 arm arm64))
  perf-$(CONFIG_DWARF_UNWIND) += dwarf-unwind.o
diff --cc tools/perf/tests/builtin-test.c
index 2337c002804d,f2b1dcac45d3..000000000000
--- a/tools/perf/tests/builtin-test.c
+++ b/tools/perf/tests/builtin-test.c
@@@ -178,6 -158,52 +178,55 @@@ static struct test generic_tests[] = 
  		.func = test__thread_map,
  	},
  	{
++<<<<<<< HEAD
++=======
+ 		.desc = "Test LLVM searching and compiling",
+ 		.func = test__llvm,
+ 		.subtest = {
+ 			.skip_if_fail	= true,
+ 			.get_nr		= test__llvm_subtest_get_nr,
+ 			.get_desc	= test__llvm_subtest_get_desc,
+ 		},
+ 	},
+ 	{
+ 		.desc = "Test topology in session",
+ 		.func = test_session_topology,
+ 	},
+ 	{
+ 		.desc = "Test BPF filter",
+ 		.func = test__bpf,
+ 		.subtest = {
+ 			.skip_if_fail	= true,
+ 			.get_nr		= test__bpf_subtest_get_nr,
+ 			.get_desc	= test__bpf_subtest_get_desc,
+ 		},
+ 	},
+ 	{
+ 		.desc = "Test thread map synthesize",
+ 		.func = test__thread_map_synthesize,
+ 	},
+ 	{
+ 		.desc = "Test cpu map synthesize",
+ 		.func = test__cpu_map_synthesize,
+ 	},
+ 	{
+ 		.desc = "Test stat config synthesize",
+ 		.func = test__synthesize_stat_config,
+ 	},
+ 	{
+ 		.desc = "Test stat synthesize",
+ 		.func = test__synthesize_stat,
+ 	},
+ 	{
+ 		.desc = "Test stat round synthesize",
+ 		.func = test__synthesize_stat_round,
+ 	},
+ 	{
+ 		.desc = "Test attr update synthesize",
+ 		.func = test__event_update,
+ 	},
+ 	{
++>>>>>>> a6e5281780d1 (perf tools: Add event_update event unit type)
  		.func = NULL,
  	},
  };
diff --cc tools/perf/tests/tests.h
index a08027794fa0,82b2b5e6ba7c..000000000000
--- a/tools/perf/tests/tests.h
+++ b/tools/perf/tests/tests.h
@@@ -30,45 -37,56 +30,96 @@@ struct test 
  };
  
  /* Tests */
++<<<<<<< HEAD
 +int test__vmlinux_matches_kallsyms(void);
 +int test__openat_syscall_event(void);
 +int test__openat_syscall_event_on_all_cpus(void);
 +int test__basic_mmap(void);
 +int test__PERF_RECORD(void);
 +int test__rdpmc(void);
 +int test__perf_evsel__roundtrip_name_test(void);
 +int test__perf_evsel__tp_sched_test(void);
 +int test__syscall_openat_tp_fields(void);
 +int test__pmu(void);
 +int test__attr(void);
 +int test__dso_data(void);
 +int test__dso_data_cache(void);
 +int test__dso_data_reopen(void);
 +int test__parse_events(void);
 +int test__hists_link(void);
 +int test__python_use(void);
 +int test__bp_signal(void);
 +int test__bp_signal_overflow(void);
 +int test__task_exit(void);
 +int test__sw_clock_freq(void);
 +int test__perf_time_to_tsc(void);
 +int test__code_reading(void);
 +int test__sample_parsing(void);
 +int test__keep_tracking(void);
 +int test__parse_no_sample_id_all(void);
 +int test__dwarf_unwind(void);
 +int test__hists_filter(void);
 +int test__mmap_thread_lookup(void);
 +int test__thread_mg_share(void);
 +int test__hists_output(void);
 +int test__hists_cumulate(void);
 +int test__switch_tracking(void);
 +int test__fdarray__filter(void);
 +int test__fdarray__add(void);
 +int test__kmod_path__parse(void);
 +int test__thread_map(void);
++=======
+ int test__vmlinux_matches_kallsyms(int subtest);
+ int test__openat_syscall_event(int subtest);
+ int test__openat_syscall_event_on_all_cpus(int subtest);
+ int test__basic_mmap(int subtest);
+ int test__PERF_RECORD(int subtest);
+ int test__perf_evsel__roundtrip_name_test(int subtest);
+ int test__perf_evsel__tp_sched_test(int subtest);
+ int test__syscall_openat_tp_fields(int subtest);
+ int test__pmu(int subtest);
+ int test__attr(int subtest);
+ int test__dso_data(int subtest);
+ int test__dso_data_cache(int subtest);
+ int test__dso_data_reopen(int subtest);
+ int test__parse_events(int subtest);
+ int test__hists_link(int subtest);
+ int test__python_use(int subtest);
+ int test__bp_signal(int subtest);
+ int test__bp_signal_overflow(int subtest);
+ int test__task_exit(int subtest);
+ int test__sw_clock_freq(int subtest);
+ int test__code_reading(int subtest);
+ int test__sample_parsing(int subtest);
+ int test__keep_tracking(int subtest);
+ int test__parse_no_sample_id_all(int subtest);
+ int test__dwarf_unwind(int subtest);
+ int test__hists_filter(int subtest);
+ int test__mmap_thread_lookup(int subtest);
+ int test__thread_mg_share(int subtest);
+ int test__hists_output(int subtest);
+ int test__hists_cumulate(int subtest);
+ int test__switch_tracking(int subtest);
+ int test__fdarray__filter(int subtest);
+ int test__fdarray__add(int subtest);
+ int test__kmod_path__parse(int subtest);
+ int test__thread_map(int subtest);
+ int test__llvm(int subtest);
+ const char *test__llvm_subtest_get_desc(int subtest);
+ int test__llvm_subtest_get_nr(void);
+ int test__bpf(int subtest);
+ const char *test__bpf_subtest_get_desc(int subtest);
+ int test__bpf_subtest_get_nr(void);
+ int test_session_topology(int subtest);
+ int test__thread_map_synthesize(int subtest);
+ int test__cpu_map_synthesize(int subtest);
+ int test__synthesize_stat_config(int subtest);
+ int test__synthesize_stat(int subtest);
+ int test__synthesize_stat_round(int subtest);
+ int test__event_update(int subtest);
++>>>>>>> a6e5281780d1 (perf tools: Add event_update event unit type)
  
 -#if defined(__arm__) || defined(__aarch64__)
 +#if defined(__x86_64__) || defined(__i386__) || defined(__arm__) || defined(__aarch64__)
  #ifdef HAVE_DWARF_UNWIND_SUPPORT
  struct thread;
  struct perf_sample;
diff --cc tools/perf/util/event.h
index 9400ef1c1335,64c4cdf5aada..000000000000
--- a/tools/perf/util/event.h
+++ b/tools/perf/util/event.h
@@@ -276,6 -308,18 +276,21 @@@ struct attr_event 
  	u64 id[];
  };
  
++<<<<<<< HEAD
++=======
+ enum {
+ 	PERF_EVENT_UPDATE__UNIT  = 0,
+ };
+ 
+ struct event_update_event {
+ 	struct perf_event_header header;
+ 	u64 type;
+ 	u64 id;
+ 
+ 	char data[];
+ };
+ 
++>>>>>>> a6e5281780d1 (perf tools: Add event_update event unit type)
  #define MAX_EVENT_NAME 64
  
  struct perf_trace_event_type {
diff --cc tools/perf/util/header.c
index 5ac7bdb0dff7,5759ebfde666..000000000000
--- a/tools/perf/util/header.c
+++ b/tools/perf/util/header.c
@@@ -2745,6 -2782,33 +2782,36 @@@ int perf_event__process_attr(struct per
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ int perf_event__process_event_update(struct perf_tool *tool __maybe_unused,
+ 				     union perf_event *event,
+ 				     struct perf_evlist **pevlist)
+ {
+ 	struct event_update_event *ev = &event->event_update;
+ 	struct perf_evlist *evlist;
+ 	struct perf_evsel *evsel;
+ 
+ 	if (!pevlist || *pevlist == NULL)
+ 		return -EINVAL;
+ 
+ 	evlist = *pevlist;
+ 
+ 	evsel = perf_evlist__id2evsel(evlist, ev->id);
+ 	if (evsel == NULL)
+ 		return -EINVAL;
+ 
+ 	switch (ev->type) {
+ 	case PERF_EVENT_UPDATE__UNIT:
+ 		evsel->unit = strdup(ev->data);
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> a6e5281780d1 (perf tools: Add event_update event unit type)
  int perf_event__synthesize_tracing_data(struct perf_tool *tool, int fd,
  					struct perf_evlist *evlist,
  					perf_event__handler_t process)
* Unmerged path tools/perf/tests/Build
* Unmerged path tools/perf/tests/builtin-test.c
diff --git a/tools/perf/tests/event_update.c b/tools/perf/tests/event_update.c
new file mode 100644
index 000000000000..9cdf4c934977
--- /dev/null
+++ b/tools/perf/tests/event_update.c
@@ -0,0 +1,42 @@
+#include <linux/compiler.h>
+#include "evlist.h"
+#include "evsel.h"
+#include "machine.h"
+#include "tests.h"
+#include "debug.h"
+
+static int process_event_unit(struct perf_tool *tool __maybe_unused,
+			      union perf_event *event,
+			      struct perf_sample *sample __maybe_unused,
+			      struct machine *machine __maybe_unused)
+{
+	struct event_update_event *ev = (struct event_update_event *) event;
+
+	TEST_ASSERT_VAL("wrong id", ev->id == 123);
+	TEST_ASSERT_VAL("wrong id", ev->type == PERF_EVENT_UPDATE__UNIT);
+	TEST_ASSERT_VAL("wrong unit", !strcmp(ev->data, "KRAVA"));
+	return 0;
+}
+
+int test__event_update(int subtest __maybe_unused)
+{
+	struct perf_evlist *evlist;
+	struct perf_evsel *evsel;
+
+	evlist = perf_evlist__new_default();
+	TEST_ASSERT_VAL("failed to get evlist", evlist);
+
+	evsel = perf_evlist__first(evlist);
+
+	TEST_ASSERT_VAL("failed to allos ids",
+			!perf_evsel__alloc_id(evsel, 1, 1));
+
+	perf_evlist__id_add(evlist, evsel, 0, 0, 123);
+
+	evsel->unit = strdup("KRAVA");
+
+	TEST_ASSERT_VAL("failed to synthesize attr update unit",
+			!perf_event__synthesize_event_update_unit(NULL, evsel, process_event_unit));
+
+	return 0;
+}
* Unmerged path tools/perf/tests/tests.h
* Unmerged path tools/perf/util/event.h
* Unmerged path tools/perf/util/header.c
diff --git a/tools/perf/util/header.h b/tools/perf/util/header.h
index 05f27cb6b7e3..80f875794c76 100644
--- a/tools/perf/util/header.h
+++ b/tools/perf/util/header.h
@@ -105,6 +105,9 @@ int perf_event__synthesize_attr(struct perf_tool *tool,
 int perf_event__synthesize_attrs(struct perf_tool *tool,
 				 struct perf_session *session,
 				 perf_event__handler_t process);
+int perf_event__synthesize_event_update_unit(struct perf_tool *tool,
+					     struct perf_evsel *evsel,
+					     perf_event__handler_t process);
 int perf_event__process_attr(struct perf_tool *tool, union perf_event *event,
 			     struct perf_evlist **pevlist);
 
