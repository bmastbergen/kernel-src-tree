mei: implement fasync for event notification

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 237092bf034a648611f61eb1f0965e9ba1b08871
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/237092bf.failed

A process can be informed about client notification also via
SIGIO with POLL_PRI event.

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 237092bf034a648611f61eb1f0965e9ba1b08871)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/client.c
#	drivers/misc/mei/client.h
#	drivers/misc/mei/hbm.c
#	drivers/misc/mei/main.c
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/client.c
index 3c539de435ba,db2436aee2dc..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -783,9 -1343,151 +783,154 @@@ int mei_cl_read_start(struct mei_cl *cl
  
  out:
  	cl_dbg(dev, cl, "rpm: autosuspend\n");
 -	pm_runtime_mark_last_busy(dev->dev);
 -	pm_runtime_put_autosuspend(dev->dev);
 +	pm_runtime_mark_last_busy(&dev->pdev->dev);
 +	pm_runtime_put_autosuspend(&dev->pdev->dev);
  
++<<<<<<< HEAD
++=======
+ 	mei_io_cb_free(cb);
+ 	return rets;
+ }
+ 
+ /**
+  * mei_cl_notify - raise notification
+  *
+  * @cl: host client
+  *
+  * Locking: called under "dev->device_lock" lock
+  */
+ void mei_cl_notify(struct mei_cl *cl)
+ {
+ 	struct mei_device *dev;
+ 
+ 	if (!cl || !cl->dev)
+ 		return;
+ 
+ 	dev = cl->dev;
+ 
+ 	if (!cl->notify_en)
+ 		return;
+ 
+ 	cl_dbg(dev, cl, "notify event");
+ 	cl->notify_ev = true;
+ 	wake_up_interruptible_all(&cl->ev_wait);
+ 
+ 	if (cl->ev_async)
+ 		kill_fasync(&cl->ev_async, SIGIO, POLL_PRI);
+ }
+ 
+ /**
+  * mei_cl_notify_get - get or wait for notification event
+  *
+  * @cl: host client
+  * @block: this request is blocking
+  * @notify_ev: true if notification event was received
+  *
+  * Locking: called under "dev->device_lock" lock
+  *
+  * Return: 0 on such and error otherwise.
+  */
+ int mei_cl_notify_get(struct mei_cl *cl, bool block, bool *notify_ev)
+ {
+ 	struct mei_device *dev;
+ 	int rets;
+ 
+ 	*notify_ev = false;
+ 
+ 	if (WARN_ON(!cl || !cl->dev))
+ 		return -ENODEV;
+ 
+ 	dev = cl->dev;
+ 
+ 	if (!mei_cl_is_connected(cl))
+ 		return -ENODEV;
+ 
+ 	if (cl->notify_ev)
+ 		goto out;
+ 
+ 	if (!block)
+ 		return -EAGAIN;
+ 
+ 	mutex_unlock(&dev->device_lock);
+ 	rets = wait_event_interruptible(cl->ev_wait, cl->notify_ev);
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (rets < 0)
+ 		return rets;
+ 
+ out:
+ 	*notify_ev = cl->notify_ev;
+ 	cl->notify_ev = false;
+ 	return 0;
+ }
+ 
+ /**
+  * mei_cl_read_start - the start read client message function.
+  *
+  * @cl: host client
+  * @length: number of bytes to read
+  * @fp: pointer to file structure
+  *
+  * Return: 0 on success, <0 on failure.
+  */
+ int mei_cl_read_start(struct mei_cl *cl, size_t length, struct file *fp)
+ {
+ 	struct mei_device *dev;
+ 	struct mei_cl_cb *cb;
+ 	int rets;
+ 
+ 	if (WARN_ON(!cl || !cl->dev))
+ 		return -ENODEV;
+ 
+ 	dev = cl->dev;
+ 
+ 	if (!mei_cl_is_connected(cl))
+ 		return -ENODEV;
+ 
+ 	/* HW currently supports only one pending read */
+ 	if (!list_empty(&cl->rd_pending))
+ 		return -EBUSY;
+ 
+ 	if (!mei_me_cl_is_active(cl->me_cl)) {
+ 		cl_err(dev, cl, "no such me client\n");
+ 		return  -ENOTTY;
+ 	}
+ 
+ 	/* always allocate at least client max message */
+ 	length = max_t(size_t, length, mei_cl_mtu(cl));
+ 	cb = mei_cl_alloc_cb(cl, length, MEI_FOP_READ, fp);
+ 	if (!cb)
+ 		return -ENOMEM;
+ 
+ 	if (mei_cl_is_fixed_address(cl)) {
+ 		list_add_tail(&cb->list, &cl->rd_pending);
+ 		return 0;
+ 	}
+ 
+ 	rets = pm_runtime_get(dev->dev);
+ 	if (rets < 0 && rets != -EINPROGRESS) {
+ 		pm_runtime_put_noidle(dev->dev);
+ 		cl_err(dev, cl, "rpm: get failed %d\n", rets);
+ 		goto nortpm;
+ 	}
+ 
+ 	if (mei_hbuf_acquire(dev)) {
+ 		rets = mei_hbm_cl_flow_control_req(dev, cl);
+ 		if (rets < 0)
+ 			goto out;
+ 
+ 		list_add_tail(&cb->list, &cl->rd_pending);
+ 	} else {
+ 		rets = 0;
+ 		list_add_tail(&cb->list, &dev->ctrl_wr_list.list);
+ 	}
+ 
+ out:
+ 	cl_dbg(dev, cl, "rpm: autosuspend\n");
+ 	pm_runtime_mark_last_busy(dev->dev);
+ 	pm_runtime_put_autosuspend(dev->dev);
+ nortpm:
++>>>>>>> 237092bf034a (mei: implement fasync for event notification)
  	if (rets)
  		mei_io_cb_free(cb);
  
diff --cc drivers/misc/mei/client.h
index f2a130967f1e,1c7cad07d731..000000000000
--- a/drivers/misc/mei/client.h
+++ b/drivers/misc/mei/client.h
@@@ -91,7 -219,13 +91,17 @@@ void mei_cl_complete(struct mei_cl *cl
  
  void mei_host_client_init(struct work_struct *work);
  
- 
++<<<<<<< HEAD
++
++=======
+ u8 mei_cl_notify_fop2req(enum mei_cb_file_ops fop);
+ enum mei_cb_file_ops mei_cl_notify_req2fop(u8 request);
+ int mei_cl_notify_request(struct mei_cl *cl, struct file *file, u8 request);
+ int mei_cl_irq_notify(struct mei_cl *cl, struct mei_cl_cb *cb,
+ 		      struct mei_cl_cb *cmpl_list);
+ int mei_cl_notify_get(struct mei_cl *cl, bool block, bool *notify_ev);
+ void mei_cl_notify(struct mei_cl *cl);
++>>>>>>> 237092bf034a (mei: implement fasync for event notification)
  
  void mei_cl_all_disconnect(struct mei_device *dev);
  void mei_cl_all_wakeup(struct mei_device *dev);
diff --cc drivers/misc/mei/hbm.c
index 3cb8e1000d69,7f53597e697a..000000000000
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@@ -288,6 -312,212 +288,215 @@@ static int mei_hbm_enum_clients_req(str
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * mei_hbm_me_cl_add - add new me client to the list
+  *
+  * @dev: the device structure
+  * @res: hbm property response
+  *
+  * Return: 0 on success and -ENOMEM on allocation failure
+  */
+ 
+ static int mei_hbm_me_cl_add(struct mei_device *dev,
+ 			     struct hbm_props_response *res)
+ {
+ 	struct mei_me_client *me_cl;
+ 	const uuid_le *uuid = &res->client_properties.protocol_name;
+ 
+ 	mei_me_cl_rm_by_uuid(dev, uuid);
+ 
+ 	me_cl = kzalloc(sizeof(struct mei_me_client), GFP_KERNEL);
+ 	if (!me_cl)
+ 		return -ENOMEM;
+ 
+ 	mei_me_cl_init(me_cl);
+ 
+ 	me_cl->props = res->client_properties;
+ 	me_cl->client_id = res->me_addr;
+ 	me_cl->mei_flow_ctrl_creds = 0;
+ 
+ 	mei_me_cl_add(dev, me_cl);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * mei_hbm_add_cl_resp - send response to fw on client add request
+  *
+  * @dev: the device structure
+  * @addr: me address
+  * @status: response status
+  *
+  * Return: 0 on success and < 0 on failure
+  */
+ static int mei_hbm_add_cl_resp(struct mei_device *dev, u8 addr, u8 status)
+ {
+ 	struct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;
+ 	struct hbm_add_client_response *resp;
+ 	const size_t len = sizeof(struct hbm_add_client_response);
+ 	int ret;
+ 
+ 	dev_dbg(dev->dev, "adding client response\n");
+ 
+ 	resp = (struct hbm_add_client_response *)dev->wr_msg.data;
+ 
+ 	mei_hbm_hdr(mei_hdr, len);
+ 	memset(resp, 0, sizeof(struct hbm_add_client_response));
+ 
+ 	resp->hbm_cmd = MEI_HBM_ADD_CLIENT_RES_CMD;
+ 	resp->me_addr = addr;
+ 	resp->status  = status;
+ 
+ 	ret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);
+ 	if (ret)
+ 		dev_err(dev->dev, "add client response write failed: ret = %d\n",
+ 			ret);
+ 	return ret;
+ }
+ 
+ /**
+  * mei_hbm_fw_add_cl_req - request from the fw to add a client
+  *
+  * @dev: the device structure
+  * @req: add client request
+  *
+  * Return: 0 on success and < 0 on failure
+  */
+ static int mei_hbm_fw_add_cl_req(struct mei_device *dev,
+ 			      struct hbm_add_client_request *req)
+ {
+ 	int ret;
+ 	u8 status = MEI_HBMS_SUCCESS;
+ 
+ 	BUILD_BUG_ON(sizeof(struct hbm_add_client_request) !=
+ 			sizeof(struct hbm_props_response));
+ 
+ 	ret = mei_hbm_me_cl_add(dev, (struct hbm_props_response *)req);
+ 	if (ret)
+ 		status = !MEI_HBMS_SUCCESS;
+ 
+ 	return mei_hbm_add_cl_resp(dev, req->me_addr, status);
+ }
+ 
+ /**
+  * mei_hbm_cl_notify_req - send notification request
+  *
+  * @dev: the device structure
+  * @cl: a client to disconnect from
+  * @start: true for start false for stop
+  *
+  * Return: 0 on success and -EIO on write failure
+  */
+ int mei_hbm_cl_notify_req(struct mei_device *dev,
+ 			  struct mei_cl *cl, u8 start)
+ {
+ 
+ 	struct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;
+ 	struct hbm_notification_request *req;
+ 	const size_t len = sizeof(struct hbm_notification_request);
+ 	int ret;
+ 
+ 	mei_hbm_hdr(mei_hdr, len);
+ 	mei_hbm_cl_hdr(cl, MEI_HBM_NOTIFY_REQ_CMD, dev->wr_msg.data, len);
+ 
+ 	req = (struct hbm_notification_request *)dev->wr_msg.data;
+ 	req->start = start;
+ 
+ 	ret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);
+ 	if (ret)
+ 		dev_err(dev->dev, "notify request failed: ret = %d\n", ret);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  *  notify_res_to_fop - convert notification response to the proper
+  *      notification FOP
+  *
+  * @cmd: client notification start response command
+  *
+  * Return:  MEI_FOP_NOTIFY_START or MEI_FOP_NOTIFY_STOP;
+  */
+ static inline enum mei_cb_file_ops notify_res_to_fop(struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct hbm_notification_response *rs =
+ 		(struct hbm_notification_response *)cmd;
+ 
+ 	return mei_cl_notify_req2fop(rs->start);
+ }
+ 
+ /**
+  * mei_hbm_cl_notify_start_res - update the client state according
+  *       notify start response
+  *
+  * @dev: the device structure
+  * @cl: mei host client
+  * @cmd: client notification start response command
+  */
+ static void mei_hbm_cl_notify_start_res(struct mei_device *dev,
+ 					struct mei_cl *cl,
+ 					struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct hbm_notification_response *rs =
+ 		(struct hbm_notification_response *)cmd;
+ 
+ 	cl_dbg(dev, cl, "hbm: notify start response status=%d\n", rs->status);
+ 
+ 	if (rs->status == MEI_HBMS_SUCCESS ||
+ 	    rs->status == MEI_HBMS_ALREADY_STARTED) {
+ 		cl->notify_en = true;
+ 		cl->status = 0;
+ 	} else {
+ 		cl->status = -EINVAL;
+ 	}
+ }
+ 
+ /**
+  * mei_hbm_cl_notify_stop_res - update the client state according
+  *       notify stop response
+  *
+  * @dev: the device structure
+  * @cl: mei host client
+  * @cmd: client notification stop response command
+  */
+ static void mei_hbm_cl_notify_stop_res(struct mei_device *dev,
+ 				       struct mei_cl *cl,
+ 				       struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct hbm_notification_response *rs =
+ 		(struct hbm_notification_response *)cmd;
+ 
+ 	cl_dbg(dev, cl, "hbm: notify stop response status=%d\n", rs->status);
+ 
+ 	if (rs->status == MEI_HBMS_SUCCESS ||
+ 	    rs->status == MEI_HBMS_NOT_STARTED) {
+ 		cl->notify_en = false;
+ 		cl->status = 0;
+ 	} else {
+ 		/* TODO: spec is not clear yet about other possible issues */
+ 		cl->status = -EINVAL;
+ 	}
+ }
+ 
+ /**
+  * mei_hbm_cl_notify - signal notification event
+  *
+  * @dev: the device structure
+  * @cmd: notification client message
+  */
+ static void mei_hbm_cl_notify(struct mei_device *dev,
+ 			      struct mei_hbm_cl_cmd *cmd)
+ {
+ 	struct mei_cl *cl;
+ 
+ 	cl = mei_hbm_cl_find_by_cmd(dev, cmd);
+ 	if (cl)
+ 		mei_cl_notify(cl);
+ }
+ 
++>>>>>>> 237092bf034a (mei: implement fasync for event notification)
  /**
   * mei_hbm_prop_req - request property for a single client
   *
diff --cc drivers/misc/mei/main.c
index b23f9eba9e3a,b2f2486b3d75..000000000000
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@@ -666,6 -650,64 +666,67 @@@ out
  	return mask;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * mei_fasync - asynchronous io support
+  *
+  * @fd: file descriptor
+  * @file: pointer to file structure
+  * @band: band bitmap
+  *
+  * Return: poll mask
+  */
+ static int mei_fasync(int fd, struct file *file, int band)
+ {
+ 
+ 	struct mei_cl *cl = file->private_data;
+ 
+ 	if (!mei_cl_is_connected(cl))
+ 		return POLLERR;
+ 
+ 	return fasync_helper(fd, file, band, &cl->ev_async);
+ }
+ 
+ /**
+  * fw_status_show - mei device attribute show method
+  *
+  * @device: device pointer
+  * @attr: attribute pointer
+  * @buf:  char out buffer
+  *
+  * Return: number of the bytes printed into buf or error
+  */
+ static ssize_t fw_status_show(struct device *device,
+ 		struct device_attribute *attr, char *buf)
+ {
+ 	struct mei_device *dev = dev_get_drvdata(device);
+ 	struct mei_fw_status fw_status;
+ 	int err, i;
+ 	ssize_t cnt = 0;
+ 
+ 	mutex_lock(&dev->device_lock);
+ 	err = mei_fw_status(dev, &fw_status);
+ 	mutex_unlock(&dev->device_lock);
+ 	if (err) {
+ 		dev_err(device, "read fw_status error = %d\n", err);
+ 		return err;
+ 	}
+ 
+ 	for (i = 0; i < fw_status.count; i++)
+ 		cnt += scnprintf(buf + cnt, PAGE_SIZE - cnt, "%08X\n",
+ 				fw_status.status[i]);
+ 	return cnt;
+ }
+ static DEVICE_ATTR_RO(fw_status);
+ 
+ static struct attribute *mei_attrs[] = {
+ 	&dev_attr_fw_status.attr,
+ 	NULL
+ };
+ ATTRIBUTE_GROUPS(mei);
+ 
++>>>>>>> 237092bf034a (mei: implement fasync for event notification)
  /*
   * file operations structure will be used for mei char device.
   */
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,c960aaa538c0..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -201,10 -220,37 +201,39 @@@ struct mei_cl_cb 
  	unsigned long buf_idx;
  	unsigned long read_time;
  	struct file *file_object;
 -	int status;
  	u32 internal:1;
 -	u32 completed:1;
  };
  
++<<<<<<< HEAD
 +/* MEI client instance carried as file->private_data*/
++=======
+ /**
+  * struct mei_cl - me client host representation
+  *    carried in file->private_data
+  *
+  * @link: link in the clients list
+  * @dev: mei parent device
+  * @state: file operation state
+  * @tx_wait: wait queue for tx completion
+  * @rx_wait: wait queue for rx completion
+  * @wait:  wait queue for management operation
+  * @ev_wait: notification wait queue
+  * @ev_async: event async notification
+  * @status: connection status
+  * @me_cl: fw client connected
+  * @host_client_id: host id
+  * @mei_flow_ctrl_creds: transmit flow credentials
+  * @timer_count:  watchdog timer for operation completion
+  * @reserved: reserved for alignment
+  * @notify_en: notification - enabled/disabled
+  * @notify_ev: pending notification event
+  * @writing_state: state of the tx
+  * @rd_pending: pending read credits
+  * @rd_completed: completed read
+  *
+  * @cldev: device on the mei client bus
+  */
++>>>>>>> 237092bf034a (mei: implement fasync for event notification)
  struct mei_cl {
  	struct list_head link;
  	struct mei_device *dev;
@@@ -212,21 -258,21 +241,26 @@@
  	wait_queue_head_t tx_wait;
  	wait_queue_head_t rx_wait;
  	wait_queue_head_t wait;
++<<<<<<< HEAD
++=======
+ 	wait_queue_head_t ev_wait;
+ 	struct fasync_struct *ev_async;
++>>>>>>> 237092bf034a (mei: implement fasync for event notification)
  	int status;
 -	struct mei_me_client *me_cl;
 +	/* ID of client connected */
  	u8 host_client_id;
 +	u8 me_client_id;
  	u8 mei_flow_ctrl_creds;
  	u8 timer_count;
 -	u8 reserved;
 -	u8 notify_en;
 -	u8 notify_ev;
 +	enum mei_file_transaction_states reading_state;
  	enum mei_file_transaction_states writing_state;
 -	struct list_head rd_pending;
 -	struct list_head rd_completed;
 +	int sm_state;
 +	struct mei_cl_cb *read_cb;
  
 -	struct mei_cl_device *cldev;
 +	/* MEI CL bus data */
 +	struct mei_cl_device *device;
 +	struct list_head device_link;
 +	uuid_le device_uuid;
  };
  
  /** struct mei_hw_ops
* Unmerged path drivers/misc/mei/client.c
* Unmerged path drivers/misc/mei/client.h
* Unmerged path drivers/misc/mei/hbm.c
* Unmerged path drivers/misc/mei/main.c
* Unmerged path drivers/misc/mei/mei_dev.h
