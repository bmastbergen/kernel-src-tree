x86/microcode/amd: Do not overwrite final patch levels

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] microcode/amd: Do not overwrite final patch levels (Prarit Bhargava) [1253762]
Rebuild_FUZZ: 96.15%
commit-author Borislav Petkov <bp@suse.de>
commit 0399f73299f1b7e04de329050f7111b362b7eeb5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0399f732.failed

A certain number of patch levels of applied microcode should not
be overwritten by the microcode loader, otherwise bad things
will happen.

Check those and abort update if the current core has one of
those final patch levels applied by the BIOS. 32-bit needs
special handling, of course.

See https://bugzilla.suse.com/show_bug.cgi?id=913996 for more
info.

	Tested-by: Peter Kirchge√üner <pkirchgessner@t-online.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Tony Luck <tony.luck@intel.com>
Link: http://lkml.kernel.org/r/1444641762-9437-7-git-send-email-bp@alien8.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 0399f73299f1b7e04de329050f7111b362b7eeb5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/microcode_amd.h
#	arch/x86/kernel/cpu/microcode/amd.c
#	arch/x86/kernel/cpu/microcode/amd_early.c
diff --cc arch/x86/include/asm/microcode_amd.h
index 48a48024ebe4,d3e86cfd08fe..000000000000
--- a/arch/x86/include/asm/microcode_amd.h
+++ b/arch/x86/include/asm/microcode_amd.h
@@@ -65,13 -65,16 +65,17 @@@ extern enum ucode_state load_microcode_
  extern u8 amd_ucode_patch[PATCH_MAX_SIZE];
  
  #ifdef CONFIG_MICROCODE_AMD_EARLY
 -extern void __init load_ucode_amd_bsp(unsigned int family);
 +extern void __init load_ucode_amd_bsp(void);
  extern void load_ucode_amd_ap(void);
  extern int __init save_microcode_in_initrd_amd(void);
 -void reload_ucode_amd(void);
  #else
 -static inline void __init load_ucode_amd_bsp(unsigned int family) {}
 +static inline void __init load_ucode_amd_bsp(void) {}
  static inline void load_ucode_amd_ap(void) {}
  static inline int __init save_microcode_in_initrd_amd(void) { return -EINVAL; }
 -void reload_ucode_amd(void) {}
  #endif
  
++<<<<<<< HEAD
++=======
+ extern bool check_current_patch_level(u32 *rev, bool early);
++>>>>>>> 0399f73299f1 (x86/microcode/amd: Do not overwrite final patch levels)
  #endif /* _ASM_X86_MICROCODE_AMD_H */
diff --cc arch/x86/kernel/cpu/microcode/amd.c
index 3b46cd738279,da922d1e2f71..000000000000
--- a/arch/x86/kernel/cpu/microcode/amd.c
+++ b/arch/x86/kernel/cpu/microcode/amd.c
@@@ -177,6 -177,53 +177,56 @@@ static unsigned int verify_patch_size(u
  	return patch_size;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Those patch levels cannot be updated to newer ones and thus should be final.
+  */
+ static u32 final_levels[] = {
+ 	0x01000098,
+ 	0x0100009f,
+ 	0x010000af,
+ 	0, /* T-101 terminator */
+ };
+ 
+ /*
+  * Check the current patch level on this CPU.
+  *
+  * @rev: Use it to return the patch level. It is set to 0 in the case of
+  * error.
+  *
+  * Returns:
+  *  - true: if update should stop
+  *  - false: otherwise
+  */
+ bool check_current_patch_level(u32 *rev, bool early)
+ {
+ 	u32 lvl, dummy, i;
+ 	bool ret = false;
+ 	u32 *levels;
+ 
+ 	native_rdmsr(MSR_AMD64_PATCH_LEVEL, lvl, dummy);
+ 
+ 	if (IS_ENABLED(CONFIG_X86_32) && early)
+ 		levels = (u32 *)__pa_nodebug(&final_levels);
+ 	else
+ 		levels = final_levels;
+ 
+ 	for (i = 0; levels[i]; i++) {
+ 		if (lvl == levels[i]) {
+ 			lvl = 0;
+ 			ret = true;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (rev)
+ 		*rev = lvl;
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 0399f73299f1 (x86/microcode/amd: Do not overwrite final patch levels)
  int __apply_microcode_amd(struct microcode_amd *mc_amd)
  {
  	u32 rev, dummy;
@@@ -210,7 -257,8 +260,12 @@@ int apply_microcode_amd(int cpu
  	mc_amd  = p->data;
  	uci->mc = p->data;
  
++<<<<<<< HEAD
 +	rdmsr(MSR_AMD64_PATCH_LEVEL, rev, dummy);
++=======
+ 	if (check_current_patch_level(&rev, false))
+ 		return -1;
++>>>>>>> 0399f73299f1 (x86/microcode/amd: Do not overwrite final patch levels)
  
  	/* need to apply patch? */
  	if (rev >= mc_amd->hdr.patch_id) {
diff --cc arch/x86/kernel/cpu/microcode/amd_early.c
index 3d988a30a21d,a54a47b9d8ea..000000000000
--- a/arch/x86/kernel/cpu/microcode/amd_early.c
+++ b/arch/x86/kernel/cpu/microcode/amd_early.c
@@@ -196,9 -196,8 +196,14 @@@ static void apply_ucode_in_initrd(void 
  		return;
  	}
  
++<<<<<<< HEAD
 +	/* find ucode and update if needed */
 +
 +	native_rdmsr(MSR_AMD64_PATCH_LEVEL, rev, eax);
++=======
+ 	if (check_current_patch_level(&rev, true))
+ 		return;
++>>>>>>> 0399f73299f1 (x86/microcode/amd: Do not overwrite final patch levels)
  
  	while (left > 0) {
  		struct microcode_amd *mc;
@@@ -314,10 -330,11 +319,18 @@@ void load_ucode_amd_ap(void
  	if (!container)
  		return;
  
++<<<<<<< HEAD
 +	rdmsr(MSR_AMD64_PATCH_LEVEL, rev, eax);
 +
 +	uci->cpu_sig.rev = rev;
 +	uci->cpu_sig.sig = eax;
++=======
+ 	/*
+ 	 * 64-bit runs with paging enabled, thus early==false.
+ 	 */
+ 	if (check_current_patch_level(&rev, false))
+ 		return;
++>>>>>>> 0399f73299f1 (x86/microcode/amd: Do not overwrite final patch levels)
  
  	eax = cpuid_eax(0x00000001);
  	eq  = (struct equiv_cpu_entry *)(container + CONTAINER_HDR_SZ);
@@@ -402,3 -419,26 +415,29 @@@ int __init save_microcode_in_initrd_amd
  
  	return retval;
  }
++<<<<<<< HEAD
++=======
+ 
+ void reload_ucode_amd(void)
+ {
+ 	struct microcode_amd *mc;
+ 	u32 rev;
+ 
+ 	/*
+ 	 * early==false because this is a syscore ->resume path and by
+ 	 * that time paging is long enabled.
+ 	 */
+ 	if (check_current_patch_level(&rev, false))
+ 		return;
+ 
+ 	mc = (struct microcode_amd *)amd_ucode_patch;
+ 
+ 	if (mc && rev < mc->hdr.patch_id) {
+ 		if (!__apply_microcode_amd(mc)) {
+ 			ucode_new_rev = mc->hdr.patch_id;
+ 			pr_info("microcode: reload patch_level=0x%08x\n",
+ 				ucode_new_rev);
+ 		}
+ 	}
+ }
++>>>>>>> 0399f73299f1 (x86/microcode/amd: Do not overwrite final patch levels)
* Unmerged path arch/x86/include/asm/microcode_amd.h
* Unmerged path arch/x86/kernel/cpu/microcode/amd.c
* Unmerged path arch/x86/kernel/cpu/microcode/amd_early.c
