mei: me: fix d0i3 register offset in tracing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit cf094ebe4d8b9efbc83c8f13b1b8453a573cbb66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/cf094ebe.failed

Fix copy-paste error in D0i3 register access tracing

Fixes: 13b14c3f ("mei: me: d0i3: add d0i3 enter/exit state machine")
	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit cf094ebe4d8b9efbc83c8f13b1b8453a573cbb66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/hw-me.c
diff --cc drivers/misc/mei/hw-me.c
index 1707fa5ea02a,25b1997a62cb..000000000000
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@@ -94,13 -130,73 +94,75 @@@ static inline u32 mei_hcsr_read(const s
   * and ignores the H_IS bit for it is write-one-to-zero.
   *
   * @dev: the device structure
 - * @reg: new register value
   */
 -static inline void mei_hcsr_set(struct mei_device *dev, u32 reg)
 +static inline void mei_hcsr_set(struct mei_me_hw *hw, u32 hcsr)
  {
 -	reg &= ~H_CSR_IS_MASK;
 -	mei_hcsr_write(dev, reg);
 +	hcsr &= ~H_IS;
 +	mei_me_reg_write(hw, H_CSR, hcsr);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * mei_me_d0i3c_read - Reads 32bit data from the D0I3C register
+  *
+  * @dev: the device structure
+  *
+  * Return: H_D0I3C register value (u32)
+  */
+ static inline u32 mei_me_d0i3c_read(const struct mei_device *dev)
+ {
+ 	u32 reg;
+ 
+ 	reg = mei_me_reg_read(to_me_hw(dev), H_D0I3C);
+ 	trace_mei_reg_read(dev->dev, "H_D0I3C", H_D0I3C, reg);
+ 
+ 	return reg;
+ }
+ 
+ /**
+  * mei_me_d0i3c_write - writes H_D0I3C register to device
+  *
+  * @dev: the device structure
+  * @reg: new register value
+  */
+ static inline void mei_me_d0i3c_write(struct mei_device *dev, u32 reg)
+ {
+ 	trace_mei_reg_write(dev->dev, "H_D0I3C", H_D0I3C, reg);
+ 	mei_me_reg_write(to_me_hw(dev), H_D0I3C, reg);
+ }
+ 
+ /**
+  * mei_me_fw_status - read fw status register from pci config space
+  *
+  * @dev: mei device
+  * @fw_status: fw status register values
+  *
+  * Return: 0 on success, error otherwise
+  */
+ static int mei_me_fw_status(struct mei_device *dev,
+ 			    struct mei_fw_status *fw_status)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev->dev);
+ 	struct mei_me_hw *hw = to_me_hw(dev);
+ 	const struct mei_fw_status *fw_src = &hw->cfg->fw_status;
+ 	int ret;
+ 	int i;
+ 
+ 	if (!fw_status)
+ 		return -EINVAL;
+ 
+ 	fw_status->count = fw_src->count;
+ 	for (i = 0; i < fw_src->count && i < MEI_FW_STATUS_MAX; i++) {
+ 		ret = pci_read_config_dword(pdev,
+ 			fw_src->status[i], &fw_status->status[i]);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
++>>>>>>> cf094ebe4d8b (mei: me: fix d0i3 register offset in tracing)
  
  /**
   * mei_me_hw_config - configure hw dependent settings
* Unmerged path drivers/misc/mei/hw-me.c
