gpio: remove gpio_descs global array

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [gpio] remove gpio_descs global array (Prarit Bhargava) [1358979]
Rebuild_FUZZ: 90.91%
commit-author Alexandre Courbot <acourbot@nvidia.com>
commit 14e85c0e69d5c7fdbd963edbbec1dc5cdd385200
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/14e85c0e.failed

Replace the ARCH_NR_GPIOS-sized static array of GPIO descriptors by
dynamically-allocated arrays for each GPIO chip.

This change makes gpio_to_desc() perform in O(n) (where n is the number
of GPIO chips registered) instead of O(1), however since n is rarely
bigger than 1 or 2 no noticeable performance issue is expected.
Besides this provides more incentive for GPIO consumers to move to the
gpiod interface. One could use a O(log(n)) structure to link the GPIO
chips together, but considering the low limit of n the hypothetical
performance benefit is probably not worth the added complexity.

This patch uses kcalloc() in gpiochip_add(), which removes the ability
to add a chip before kcalloc() can operate. I am not aware of such
cases, but if someone bisects up to this patch then I will be proven
wrong...

	Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 14e85c0e69d5c7fdbd963edbbec1dc5cdd385200)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpiolib.c
diff --cc drivers/gpio/gpiolib.c
index 9b50ed619d38,5619922ebf44..000000000000
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@@ -42,34 -45,8 +42,37 @@@
   * While any GPIO is requested, its gpio_chip is not removable;
   * each GPIO's "requested" flag serves as a lock and refcount.
   */
 -DEFINE_SPINLOCK(gpio_lock);
 +static DEFINE_SPINLOCK(gpio_lock);
 +
++<<<<<<< HEAD
 +struct gpio_desc {
 +	struct gpio_chip	*chip;
 +	unsigned long		flags;
 +/* flag symbols are bit numbers */
 +#define FLAG_REQUESTED	0
 +#define FLAG_IS_OUT	1
 +#define FLAG_EXPORT	2	/* protected by sysfs_lock */
 +#define FLAG_SYSFS	3	/* exported via /sys/class/gpio/control */
 +#define FLAG_TRIG_FALL	4	/* trigger on falling edge */
 +#define FLAG_TRIG_RISE	5	/* trigger on rising edge */
 +#define FLAG_ACTIVE_LOW	6	/* value has active low */
 +#define FLAG_OPEN_DRAIN	7	/* Gpio is open drain type */
 +#define FLAG_OPEN_SOURCE 8	/* Gpio is open source type */
 +#define FLAG_USED_AS_IRQ 9	/* GPIO is connected to an IRQ */
 +
 +#define ID_SHIFT	16	/* add new flags before this one */
 +
 +#define GPIO_FLAGS_MASK		((1 << ID_SHIFT) - 1)
 +#define GPIO_TRIGGER_MASK	(BIT(FLAG_TRIG_FALL) | BIT(FLAG_TRIG_RISE))
  
 +#ifdef CONFIG_DEBUG_FS
 +	const char		*label;
 +#endif
 +};
 +static struct gpio_desc gpio_desc[ARCH_NR_GPIOS];
 +
++=======
++>>>>>>> 14e85c0e69d5 (gpio: remove gpio_descs global array)
  #define GPIO_OFFSET_VALID(chip, offset) (offset >= 0 && offset < chip->ngpio)
  
  static DEFINE_MUTEX(gpio_lookup_lock);
@@@ -1178,12 -236,11 +1193,19 @@@ int gpiochip_add(struct gpio_chip *chip
  	int		status = 0;
  	unsigned	id;
  	int		base = chip->base;
+ 	struct gpio_desc *descs;
  
++<<<<<<< HEAD
 +	if ((!gpio_is_valid(base) || !gpio_is_valid(base + chip->ngpio - 1))
 +			&& base >= 0) {
 +		status = -EINVAL;
 +		goto fail;
 +	}
++=======
+ 	descs = kcalloc(chip->ngpio, sizeof(descs[0]), GFP_KERNEL);
+ 	if (!descs)
+ 		return -ENOMEM;
++>>>>>>> 14e85c0e69d5 (gpio: remove gpio_descs global array)
  
  	spin_lock_irqsave(&gpio_lock, flags);
  
@@@ -1268,24 -334,18 +1293,31 @@@ int gpiochip_remove(struct gpio_chip *c
  	of_gpiochip_remove(chip);
  
  	for (id = 0; id < chip->ngpio; id++) {
 -		if (test_bit(FLAG_REQUESTED, &chip->desc[id].flags))
 -			dev_crit(chip->dev, "REMOVING GPIOCHIP WITH GPIOS STILL REQUESTED\n");
 +		if (test_bit(FLAG_REQUESTED, &chip->desc[id].flags)) {
 +			status = -EBUSY;
 +			break;
 +		}
 +	}
 +	if (status == 0) {
 +		for (id = 0; id < chip->ngpio; id++)
 +			chip->desc[id].chip = NULL;
 +
 +		list_del(&chip->list);
  	}
 -	for (id = 0; id < chip->ngpio; id++)
 -		chip->desc[id].chip = NULL;
  
 -	list_del(&chip->list);
  	spin_unlock_irqrestore(&gpio_lock, flags);
++<<<<<<< HEAD
 +
 +	if (status == 0)
 +		gpiochip_unexport(chip);
 +
 +	return status;
++=======
+ 	gpiochip_unexport(chip);
+ 
+ 	kfree(chip->desc);
+ 	chip->desc = NULL;
++>>>>>>> 14e85c0e69d5 (gpio: remove gpio_descs global array)
  }
  EXPORT_SYMBOL_GPL(gpiochip_remove);
  
* Unmerged path drivers/gpio/gpiolib.c
