mmc: sdhci-pci: Fix card detect race for Intel BXT/APL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] sdhci-pci: Fix card detect race for Intel BXT/APL (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 95.15%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 163cbe31e5163459908a41a2b4e0d33a28fd557a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/163cbe31.failed

Intel BXT/APL use a card detect GPIO however the host controller
will not enable bus power unless it's card detect also reflects
the presence of a card.  Unfortunately those 2 things race which
can result in commands not starting, after which the controller
does nothing and there is a 10 second wait for the driver's
10-second timer to timeout.

That is fixed by having the driver look also at the present state
register to determine if the card is present.  Consequently, provide
a 'get_cd' mmc host operation for BXT/APL that does that.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Cc: stable@vger.kernel.org # v4.4+
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 163cbe31e5163459908a41a2b4e0d33a28fd557a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci-pci-core.c
diff --cc drivers/mmc/host/sdhci-pci-core.c
index 968d4349c1e2,df3b8eced8c4..000000000000
--- a/drivers/mmc/host/sdhci-pci-core.c
+++ b/drivers/mmc/host/sdhci-pci-core.c
@@@ -247,10 -252,125 +247,118 @@@ static const struct sdhci_pci_fixes sdh
  	.probe_slot	= pch_hc_probe_slot,
  };
  
++<<<<<<< HEAD
++=======
+ static void sdhci_pci_int_hw_reset(struct sdhci_host *host)
+ {
+ 	u8 reg;
+ 
+ 	reg = sdhci_readb(host, SDHCI_POWER_CONTROL);
+ 	reg |= 0x10;
+ 	sdhci_writeb(host, reg, SDHCI_POWER_CONTROL);
+ 	/* For eMMC, minimum is 1us but give it 9us for good measure */
+ 	udelay(9);
+ 	reg &= ~0x10;
+ 	sdhci_writeb(host, reg, SDHCI_POWER_CONTROL);
+ 	/* For eMMC, minimum is 200us but give it 300us for good measure */
+ 	usleep_range(300, 1000);
+ }
+ 
+ static int spt_select_drive_strength(struct sdhci_host *host,
+ 				     struct mmc_card *card,
+ 				     unsigned int max_dtr,
+ 				     int host_drv, int card_drv, int *drv_type)
+ {
+ 	int drive_strength;
+ 
+ 	if (sdhci_pci_spt_drive_strength > 0)
+ 		drive_strength = sdhci_pci_spt_drive_strength & 0xf;
+ 	else
+ 		drive_strength = 0; /* Default 50-ohm */
+ 
+ 	if ((mmc_driver_type_mask(drive_strength) & card_drv) == 0)
+ 		drive_strength = 0; /* Default 50-ohm */
+ 
+ 	return drive_strength;
+ }
+ 
+ /* Try to read the drive strength from the card */
+ static void spt_read_drive_strength(struct sdhci_host *host)
+ {
+ 	u32 val, i, t;
+ 	u16 m;
+ 
+ 	if (sdhci_pci_spt_drive_strength)
+ 		return;
+ 
+ 	sdhci_pci_spt_drive_strength = -1;
+ 
+ 	m = sdhci_readw(host, SDHCI_HOST_CONTROL2) & 0x7;
+ 	if (m != 3 && m != 5)
+ 		return;
+ 	val = sdhci_readl(host, SDHCI_PRESENT_STATE);
+ 	if (val & 0x3)
+ 		return;
+ 	sdhci_writel(host, 0x007f0023, SDHCI_INT_ENABLE);
+ 	sdhci_writel(host, 0, SDHCI_SIGNAL_ENABLE);
+ 	sdhci_writew(host, 0x10, SDHCI_TRANSFER_MODE);
+ 	sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
+ 	sdhci_writew(host, 512, SDHCI_BLOCK_SIZE);
+ 	sdhci_writew(host, 1, SDHCI_BLOCK_COUNT);
+ 	sdhci_writel(host, 0, SDHCI_ARGUMENT);
+ 	sdhci_writew(host, 0x83b, SDHCI_COMMAND);
+ 	for (i = 0; i < 1000; i++) {
+ 		val = sdhci_readl(host, SDHCI_INT_STATUS);
+ 		if (val & 0xffff8000)
+ 			return;
+ 		if (val & 0x20)
+ 			break;
+ 		udelay(1);
+ 	}
+ 	val = sdhci_readl(host, SDHCI_PRESENT_STATE);
+ 	if (!(val & 0x800))
+ 		return;
+ 	for (i = 0; i < 47; i++)
+ 		val = sdhci_readl(host, SDHCI_BUFFER);
+ 	t = val & 0xf00;
+ 	if (t != 0x200 && t != 0x300)
+ 		return;
+ 
+ 	sdhci_pci_spt_drive_strength = 0x10 | ((val >> 12) & 0xf);
+ }
+ 
+ static int bxt_get_cd(struct mmc_host *mmc)
+ {
+ 	int gpio_cd = mmc_gpio_get_cd(mmc);
+ 	struct sdhci_host *host = mmc_priv(mmc);
+ 	unsigned long flags;
+ 	int ret = 0;
+ 
+ 	if (!gpio_cd)
+ 		return 0;
+ 
+ 	pm_runtime_get_sync(mmc->parent);
+ 
+ 	spin_lock_irqsave(&host->lock, flags);
+ 
+ 	if (host->flags & SDHCI_DEVICE_DEAD)
+ 		goto out;
+ 
+ 	ret = !!(sdhci_readl(host, SDHCI_PRESENT_STATE) & SDHCI_CARD_PRESENT);
+ out:
+ 	spin_unlock_irqrestore(&host->lock, flags);
+ 
+ 	pm_runtime_mark_last_busy(mmc->parent);
+ 	pm_runtime_put_autosuspend(mmc->parent);
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 163cbe31e516 (mmc: sdhci-pci: Fix card detect race for Intel BXT/APL)
  static int byt_emmc_probe_slot(struct sdhci_pci_slot *slot)
  {
 -	slot->host->mmc->caps |= MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE |
 -				 MMC_CAP_HW_RESET | MMC_CAP_1_8V_DDR |
 -				 MMC_CAP_BUS_WIDTH_TEST |
 -				 MMC_CAP_WAIT_WHILE_BUSY;
 +	slot->host->mmc->caps |= MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE;
  	slot->host->mmc->caps2 |= MMC_CAP2_HC_ERASE_SZ;
 -	slot->hw_reset = sdhci_pci_int_hw_reset;
 -	if (slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_BSW_EMMC)
 -		slot->host->timeout_clk = 1000; /* 1000 kHz i.e. 1 MHz */
 -	if (slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_SPT_EMMC) {
 -		spt_read_drive_strength(slot->host);
 -		slot->select_drive_strength = spt_select_drive_strength;
 -	}
  	return 0;
  }
  
* Unmerged path drivers/mmc/host/sdhci-pci-core.c
