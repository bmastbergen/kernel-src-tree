ACPI / LPSS: Always disable I2C host controllers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 3293c7b8ec213a640f5ea2e5efeaa2b7559b1e19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3293c7b8.failed

On Baytrail and Braswell the BIOS might leave the I2C host controllers
enabled, probably because it uses them for its own purposes. This is fine
in normal cases because the I2C driver will disable the hardware when it
is probed anyway.

However, in case of suspend to disk it is different story. If the driver
happens to be compiled as a module the boot kernel never loads the driver
thus leaving host controllers enabled upon loading the hibernation image.

The I2C host controller interrupt mask register has default value of 0x8ff,
in other words it has most of the interrupts unmasked. When combined with
the fact that the host controller is enabled, the driver immediately starts
getting interrupts even before its resume hook is called (once IO-APIC is
resumed). Since the driver is not prepared for this it will crash the
kernel due to NULL pointer derefence because dev->msgs is NULL.

Unfortunately we were not able to get full backtrace to from the console
which could be reproduced here.

In order to fix this even when the driver is compiled as module, we disable
the I2C host controllers in byt_i2c_setup() before devices are created.

	Reported-by: Yu Chen <yu.c.chen@intel.com>
	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Cc: 3.17+ <stable@vger.kernel.org> # 3.17+
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 3293c7b8ec213a640f5ea2e5efeaa2b7559b1e19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpi_lpss.c
diff --cc drivers/acpi/acpi_lpss.c
index cfbdc9b37769,cb84efe7fc5d..000000000000
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@@ -105,7 -105,9 +105,13 @@@ static void lpss_uart_setup(struct lpss
  	}
  }
  
++<<<<<<< HEAD
 +static void lpss_i2c_setup(struct lpss_private_data *pdata)
++=======
+ #define LPSS_I2C_ENABLE			0x6c
+ 
+ static void byt_i2c_setup(struct lpss_private_data *pdata)
++>>>>>>> 3293c7b8ec21 (ACPI / LPSS: Always disable I2C host controllers)
  {
  	unsigned int offset;
  	u32 val;
@@@ -114,6 -116,11 +120,14 @@@
  	val = readl(pdata->mmio_base + offset);
  	val |= LPSS_RESETS_RESET_APB | LPSS_RESETS_RESET_FUNC;
  	writel(val, pdata->mmio_base + offset);
++<<<<<<< HEAD
++=======
+ 
+ 	if (readl(pdata->mmio_base + pdata->dev_desc->prv_offset))
+ 		pdata->fixed_clk_rate = 133000000;
+ 
+ 	writel(0, pdata->mmio_base + LPSS_I2C_ENABLE);
++>>>>>>> 3293c7b8ec21 (ACPI / LPSS: Always disable I2C host controllers)
  }
  
  static struct lpss_device_desc lpt_dev_desc = {
* Unmerged path drivers/acpi/acpi_lpss.c
