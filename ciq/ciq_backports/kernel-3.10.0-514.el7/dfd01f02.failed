sched/wait: Fix the signal handling fix

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit dfd01f026058a59a513f8a365b439a0681b803af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/dfd01f02.failed

Jan Stancek reported that I wrecked things for him by fixing things for
Vladimir :/

His report was due to an UNINTERRUPTIBLE wait getting -EINTR, which
should not be possible, however my previous patch made this possible by
unconditionally checking signal_pending().

We cannot use current->state as was done previously, because the
instruction after the store to that variable it can be changed.  We must
instead pass the initial state along and use that.

Fixes: 68985633bccb ("sched/wait: Fix signal handling in bit wait helpers")
	Reported-by: Jan Stancek <jstancek@redhat.com>
	Reported-by: Chris Mason <clm@fb.com>
	Tested-by: Jan Stancek <jstancek@redhat.com>
	Tested-by: Vladimir Murzin <vladimir.murzin@arm.com>
	Tested-by: Chris Mason <clm@fb.com>
	Reviewed-by: Paul Turner <pjt@google.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: tglx@linutronix.de
	Cc: Oleg Nesterov <oleg@redhat.com>
	Cc: hpa@zytor.com
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit dfd01f026058a59a513f8a365b439a0681b803af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/inode.c
#	fs/nfs/inode.c
#	fs/nfs/internal.h
#	fs/nfs/pagelist.c
#	fs/nfs/pnfs.c
#	include/linux/wait.h
#	kernel/wait.c
#	net/sunrpc/sched.c
diff --cc fs/cifs/inode.c
index 5e1a25971732,a329f5ba35aa..000000000000
--- a/fs/cifs/inode.c
+++ b/fs/cifs/inode.c
@@@ -1808,11 -1831,11 +1808,15 @@@ cifs_invalidate_mapping(struct inode *i
   * @word: long word containing the bit lock
   */
  static int
++<<<<<<< HEAD
 +cifs_wait_bit_killable(void *word)
++=======
+ cifs_wait_bit_killable(struct wait_bit_key *key, int mode)
++>>>>>>> dfd01f026058 (sched/wait: Fix the signal handling fix)
  {
- 	if (fatal_signal_pending(current))
- 		return -ERESTARTSYS;
  	freezable_schedule_unsafe();
+ 	if (signal_pending_state(mode, current))
+ 		return -ERESTARTSYS;
  	return 0;
  }
  
diff --cc fs/nfs/inode.c
index 010d0b9d900b,c7e8b87da5b2..000000000000
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@@ -75,11 -75,11 +75,15 @@@ nfs_fattr_to_ino_t(struct nfs_fattr *fa
   * nfs_wait_bit_killable - helper for functions that are sleeping on bit locks
   * @word: long word containing the bit lock
   */
++<<<<<<< HEAD
 +int nfs_wait_bit_killable(void *word)
++=======
+ int nfs_wait_bit_killable(struct wait_bit_key *key, int mode)
++>>>>>>> dfd01f026058 (sched/wait: Fix the signal handling fix)
  {
- 	if (fatal_signal_pending(current))
- 		return -ERESTARTSYS;
  	freezable_schedule_unsafe();
+ 	if (signal_pending_state(mode, current))
+ 		return -ERESTARTSYS;
  	return 0;
  }
  EXPORT_SYMBOL_GPL(nfs_wait_bit_killable);
diff --cc fs/nfs/internal.h
index 756432218866,9dea85f7f918..000000000000
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@@ -364,7 -379,7 +364,11 @@@ extern int nfs_drop_inode(struct inode 
  extern void nfs_clear_inode(struct inode *);
  extern void nfs_evict_inode(struct inode *);
  void nfs_zap_acl_cache(struct inode *inode);
++<<<<<<< HEAD
 +extern int nfs_wait_bit_killable(void *word);
++=======
+ extern int nfs_wait_bit_killable(struct wait_bit_key *key, int mode);
++>>>>>>> dfd01f026058 (sched/wait: Fix the signal handling fix)
  
  /* super.c */
  extern const struct super_operations nfs_sops;
diff --cc fs/nfs/pagelist.c
index 143ab6acb094,452a011ba0d8..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -129,7 -129,7 +129,11 @@@ __nfs_iocounter_wait(struct nfs_io_coun
  		set_bit(NFS_IO_INPROGRESS, &c->flags);
  		if (atomic_read(&c->io_count) == 0)
  			break;
++<<<<<<< HEAD
 +		ret = nfs_wait_bit_killable(&c->flags);
++=======
+ 		ret = nfs_wait_bit_killable(&q.key, TASK_KILLABLE);
++>>>>>>> dfd01f026058 (sched/wait: Fix the signal handling fix)
  	} while (atomic_read(&c->io_count) != 0 && !ret);
  	finish_wait(wq, &q.wait);
  	return ret;
diff --cc fs/nfs/pnfs.c
index 40ce52cc28db,bec0384499f7..000000000000
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@@ -1394,13 -1466,11 +1394,21 @@@ static bool pnfs_within_mdsthreshold(st
  }
  
  /* stop waiting if someone clears NFS_LAYOUT_RETRY_LAYOUTGET bit. */
++<<<<<<< HEAD
 +static int pnfs_layoutget_retry_bit_wait(void *_key)
++=======
+ static int pnfs_layoutget_retry_bit_wait(struct wait_bit_key *key, int mode)
++>>>>>>> dfd01f026058 (sched/wait: Fix the signal handling fix)
  {
 +	struct wait_bit_key *key = _key;
 +
  	if (!test_bit(NFS_LAYOUT_RETRY_LAYOUTGET, key->flags))
  		return 1;
++<<<<<<< HEAD
 +	return nfs_wait_bit_killable(_key);
++=======
+ 	return nfs_wait_bit_killable(key, mode);
++>>>>>>> dfd01f026058 (sched/wait: Fix the signal handling fix)
  }
  
  static bool pnfs_prepare_to_retry_layoutget(struct pnfs_layout_hdr *lo)
diff --cc include/linux/wait.h
index 65da9e322613,513b36f04dfd..000000000000
--- a/include/linux/wait.h
+++ b/include/linux/wait.h
@@@ -140,10 -145,10 +140,14 @@@ static inline void __remove_wait_queue(
  	list_del(&old->task_list);
  }
  
++<<<<<<< HEAD
++=======
+ typedef int wait_bit_action_f(struct wait_bit_key *, int mode);
++>>>>>>> dfd01f026058 (sched/wait: Fix the signal handling fix)
  void __wake_up(wait_queue_head_t *q, unsigned int mode, int nr, void *key);
  void __wake_up_locked_key(wait_queue_head_t *q, unsigned int mode, void *key);
 -void __wake_up_sync_key(wait_queue_head_t *q, unsigned int mode, int nr, void *key);
 +void __wake_up_sync_key(wait_queue_head_t *q, unsigned int mode, int nr,
 +			void *key);
  void __wake_up_locked(wait_queue_head_t *q, unsigned int mode, int nr);
  void __wake_up_sync(wait_queue_head_t *q, unsigned int mode, int nr);
  void __wake_up_bit(wait_queue_head_t *, void *, int);
@@@ -982,6 -959,12 +986,15 @@@ int wake_bit_function(wait_queue_t *wai
  		(wait)->flags = 0;					\
  	} while (0)
  
++<<<<<<< HEAD
++=======
+ 
+ extern int bit_wait(struct wait_bit_key *, int);
+ extern int bit_wait_io(struct wait_bit_key *, int);
+ extern int bit_wait_timeout(struct wait_bit_key *, int);
+ extern int bit_wait_io_timeout(struct wait_bit_key *, int);
+ 
++>>>>>>> dfd01f026058 (sched/wait: Fix the signal handling fix)
  /**
   * wait_on_bit - wait for a bit to be cleared
   * @word: the word being waited on, a kernel virtual address
diff --cc kernel/wait.c
index d550920e040c,f15d6b6a538a..000000000000
--- a/kernel/wait.c
+++ b/kernel/wait.c
@@@ -199,7 -392,7 +199,11 @@@ __wait_on_bit(wait_queue_head_t *wq, st
  	do {
  		prepare_to_wait(wq, &q->wait, mode);
  		if (test_bit(q->key.bit_nr, q->key.flags))
++<<<<<<< HEAD:kernel/wait.c
 +			ret = (*action)(q->key.flags);
++=======
+ 			ret = (*action)(&q->key, mode);
++>>>>>>> dfd01f026058 (sched/wait: Fix the signal handling fix):kernel/sched/wait.c
  	} while (test_bit(q->key.bit_nr, q->key.flags) && !ret);
  	finish_wait(wq, &q->wait);
  	return ret;
@@@ -226,7 -431,7 +230,11 @@@ __wait_on_bit_lock(wait_queue_head_t *w
  		prepare_to_wait_exclusive(wq, &q->wait, mode);
  		if (!test_bit(q->key.bit_nr, q->key.flags))
  			continue;
++<<<<<<< HEAD:kernel/wait.c
 +		ret = action(q->key.flags);
++=======
+ 		ret = action(&q->key, mode);
++>>>>>>> dfd01f026058 (sched/wait: Fix the signal handling fix):kernel/sched/wait.c
  		if (!ret)
  			continue;
  		abort_exclusive_wait(wq, &q->wait, mode, &q->key);
@@@ -375,3 -580,45 +383,48 @@@ void wake_up_atomic_t(atomic_t *p
  	__wake_up_bit(atomic_t_waitqueue(p), p, WAIT_ATOMIC_T_BIT_NR);
  }
  EXPORT_SYMBOL(wake_up_atomic_t);
++<<<<<<< HEAD:kernel/wait.c
++=======
+ 
+ __sched int bit_wait(struct wait_bit_key *word, int mode)
+ {
+ 	schedule();
+ 	if (signal_pending_state(mode, current))
+ 		return -EINTR;
+ 	return 0;
+ }
+ EXPORT_SYMBOL(bit_wait);
+ 
+ __sched int bit_wait_io(struct wait_bit_key *word, int mode)
+ {
+ 	io_schedule();
+ 	if (signal_pending_state(mode, current))
+ 		return -EINTR;
+ 	return 0;
+ }
+ EXPORT_SYMBOL(bit_wait_io);
+ 
+ __sched int bit_wait_timeout(struct wait_bit_key *word, int mode)
+ {
+ 	unsigned long now = READ_ONCE(jiffies);
+ 	if (time_after_eq(now, word->timeout))
+ 		return -EAGAIN;
+ 	schedule_timeout(word->timeout - now);
+ 	if (signal_pending_state(mode, current))
+ 		return -EINTR;
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(bit_wait_timeout);
+ 
+ __sched int bit_wait_io_timeout(struct wait_bit_key *word, int mode)
+ {
+ 	unsigned long now = READ_ONCE(jiffies);
+ 	if (time_after_eq(now, word->timeout))
+ 		return -EAGAIN;
+ 	io_schedule_timeout(word->timeout - now);
+ 	if (signal_pending_state(mode, current))
+ 		return -EINTR;
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(bit_wait_io_timeout);
++>>>>>>> dfd01f026058 (sched/wait: Fix the signal handling fix):kernel/sched/wait.c
diff --cc net/sunrpc/sched.c
index fae7a88bc14d,73ad57a59989..000000000000
--- a/net/sunrpc/sched.c
+++ b/net/sunrpc/sched.c
@@@ -250,11 -250,11 +250,15 @@@ void rpc_destroy_wait_queue(struct rpc_
  }
  EXPORT_SYMBOL_GPL(rpc_destroy_wait_queue);
  
++<<<<<<< HEAD
 +static int rpc_wait_bit_killable(void *word)
++=======
+ static int rpc_wait_bit_killable(struct wait_bit_key *key, int mode)
++>>>>>>> dfd01f026058 (sched/wait: Fix the signal handling fix)
  {
- 	if (fatal_signal_pending(current))
- 		return -ERESTARTSYS;
  	freezable_schedule_unsafe();
+ 	if (signal_pending_state(mode, current))
+ 		return -ERESTARTSYS;
  	return 0;
  }
  
* Unmerged path fs/cifs/inode.c
* Unmerged path fs/nfs/inode.c
* Unmerged path fs/nfs/internal.h
* Unmerged path fs/nfs/pagelist.c
* Unmerged path fs/nfs/pnfs.c
* Unmerged path include/linux/wait.h
* Unmerged path kernel/wait.c
* Unmerged path net/sunrpc/sched.c
