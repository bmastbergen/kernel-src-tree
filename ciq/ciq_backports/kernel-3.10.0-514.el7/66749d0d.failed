hpsa: generalize external arrays

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Scott Teel <scott.teel@pmcs.com>
commit 66749d0d617a9cda967f168802f1fb1a6e598a92
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/66749d0d.failed

External array LUNs must use target and lun numbers assigned by the
external array. So the driver must treat these differently from
local LUNs when assigning lun/target.

LUN's 'model' field has been used to detect Lun types that need
special treatment, but the desire is to eliminate the need to reference
specific array models, and support any external array.

Pass-through RAID (PTRAID) luns are not luns of the local controller,
so they are not reported in LUN count of command 'ID controller'.
However, they ARE reported in "Report logical Luns" command.
Local luns are listed first, then PTRAID LUNs.

The number of luns from "Report LUNs" in excess of those reported by
'ID controller' are therefore the PTRAID LUNS.

We can now remove function is_ext_target, and the 'white list'
array of supported model names.

	Reviewed-by: Scott Teel <scott.teel@pmcs.com>
	Reviewed-by: Justin Lindley <justin.lindley@pmcs.com>
	Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
	Signed-off-by: Don Brace <don.brace@pmcs.com>
	Reviewed-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 66749d0d617a9cda967f168802f1fb1a6e598a92)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.c
#	drivers/scsi/hpsa.h
diff --cc drivers/scsi/hpsa.c
index ef01b3ac8b79,1a67d63d5585..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -732,6 -730,99 +732,102 @@@ static ssize_t host_show_hp_ssd_smart_p
  	return snprintf(buf, 20, "%d\n", offload_enabled);
  }
  
++<<<<<<< HEAD
++=======
+ #define MAX_PATHS 8
+ #define PATH_STRING_LEN 50
+ 
+ static ssize_t path_info_show(struct device *dev,
+ 	     struct device_attribute *attr, char *buf)
+ {
+ 	struct ctlr_info *h;
+ 	struct scsi_device *sdev;
+ 	struct hpsa_scsi_dev_t *hdev;
+ 	unsigned long flags;
+ 	int i;
+ 	int output_len = 0;
+ 	u8 box;
+ 	u8 bay;
+ 	u8 path_map_index = 0;
+ 	char *active;
+ 	unsigned char phys_connector[2];
+ 	unsigned char path[MAX_PATHS][PATH_STRING_LEN];
+ 
+ 	memset(path, 0, MAX_PATHS * PATH_STRING_LEN);
+ 	sdev = to_scsi_device(dev);
+ 	h = sdev_to_hba(sdev);
+ 	spin_lock_irqsave(&h->devlock, flags);
+ 	hdev = sdev->hostdata;
+ 	if (!hdev) {
+ 		spin_unlock_irqrestore(&h->devlock, flags);
+ 		return -ENODEV;
+ 	}
+ 
+ 	bay = hdev->bay;
+ 	for (i = 0; i < MAX_PATHS; i++) {
+ 		path_map_index = 1<<i;
+ 		if (i == hdev->active_path_index)
+ 			active = "Active";
+ 		else if (hdev->path_map & path_map_index)
+ 			active = "Inactive";
+ 		else
+ 			continue;
+ 
+ 		output_len = snprintf(path[i],
+ 				PATH_STRING_LEN, "[%d:%d:%d:%d] %20.20s ",
+ 				h->scsi_host->host_no,
+ 				hdev->bus, hdev->target, hdev->lun,
+ 				scsi_device_type(hdev->devtype));
+ 
+ 		if (hdev->external ||
+ 			hdev->devtype == TYPE_RAID ||
+ 			is_logical_device(hdev)) {
+ 			output_len += snprintf(path[i] + output_len,
+ 						PATH_STRING_LEN, "%s\n",
+ 						active);
+ 			continue;
+ 		}
+ 
+ 		box = hdev->box[i];
+ 		memcpy(&phys_connector, &hdev->phys_connector[i],
+ 			sizeof(phys_connector));
+ 		if (phys_connector[0] < '0')
+ 			phys_connector[0] = '0';
+ 		if (phys_connector[1] < '0')
+ 			phys_connector[1] = '0';
+ 		if (hdev->phys_connector[i] > 0)
+ 			output_len += snprintf(path[i] + output_len,
+ 				PATH_STRING_LEN,
+ 				"PORT: %.2s ",
+ 				phys_connector);
+ 		if (hdev->devtype == TYPE_DISK && hdev->expose_device) {
+ 			if (box == 0 || box == 0xFF) {
+ 				output_len += snprintf(path[i] + output_len,
+ 					PATH_STRING_LEN,
+ 					"BAY: %hhu %s\n",
+ 					bay, active);
+ 			} else {
+ 				output_len += snprintf(path[i] + output_len,
+ 					PATH_STRING_LEN,
+ 					"BOX: %hhu BAY: %hhu %s\n",
+ 					box, bay, active);
+ 			}
+ 		} else if (box != 0 && box != 0xFF) {
+ 			output_len += snprintf(path[i] + output_len,
+ 				PATH_STRING_LEN, "BOX: %hhu %s\n",
+ 				box, active);
+ 		} else
+ 			output_len += snprintf(path[i] + output_len,
+ 				PATH_STRING_LEN, "%s\n", active);
+ 	}
+ 
+ 	spin_unlock_irqrestore(&h->devlock, flags);
+ 	return snprintf(buf, output_len+1, "%s%s%s%s%s%s%s%s",
+ 		path[0], path[1], path[2], path[3],
+ 		path[4], path[5], path[6], path[7]);
+ }
+ 
++>>>>>>> 66749d0d617a (hpsa: generalize external arrays)
  static DEVICE_ATTR(raid_level, S_IRUGO, raid_level_show, NULL);
  static DEVICE_ATTR(lunid, S_IRUGO, lunid_show, NULL);
  static DEVICE_ATTR(unique_id, S_IRUGO, unique_id_show, NULL);
@@@ -3687,7 -3772,59 +3812,63 @@@ static void hpsa_get_ioaccel_drive_info
  		dev->queue_depth = DRIVE_QUEUE_DEPTH; /* conservative */
  }
  
++<<<<<<< HEAD
 +static void hpsa_update_scsi_devices(struct ctlr_info *h, int hostno)
++=======
+ static void hpsa_get_path_info(struct hpsa_scsi_dev_t *this_device,
+ 	struct ReportExtendedLUNdata *rlep, int rle_index,
+ 	struct bmic_identify_physical_device *id_phys)
+ {
+ 	struct ext_report_lun_entry *rle = &rlep->LUN[rle_index];
+ 
+ 	if ((rle->device_flags & 0x08) && this_device->ioaccel_handle)
+ 		this_device->hba_ioaccel_enabled = 1;
+ 
+ 	memcpy(&this_device->active_path_index,
+ 		&id_phys->active_path_number,
+ 		sizeof(this_device->active_path_index));
+ 	memcpy(&this_device->path_map,
+ 		&id_phys->redundant_path_present_map,
+ 		sizeof(this_device->path_map));
+ 	memcpy(&this_device->box,
+ 		&id_phys->alternate_paths_phys_box_on_port,
+ 		sizeof(this_device->box));
+ 	memcpy(&this_device->phys_connector,
+ 		&id_phys->alternate_paths_phys_connector,
+ 		sizeof(this_device->phys_connector));
+ 	memcpy(&this_device->bay,
+ 		&id_phys->phys_bay_in_box,
+ 		sizeof(this_device->bay));
+ }
+ 
+ /* get number of local logical disks. */
+ static int hpsa_set_local_logical_count(struct ctlr_info *h,
+ 	struct bmic_identify_controller *id_ctlr,
+ 	u32 *nlocals)
+ {
+ 	int rc;
+ 
+ 	if (!id_ctlr) {
+ 		dev_warn(&h->pdev->dev, "%s: id_ctlr buffer is NULL.\n",
+ 			__func__);
+ 		return -ENOMEM;
+ 	}
+ 	memset(id_ctlr, 0, sizeof(*id_ctlr));
+ 	rc = hpsa_bmic_id_controller(h, id_ctlr, sizeof(*id_ctlr));
+ 	if (!rc)
+ 		if (id_ctlr->configured_logical_drive_count < 256)
+ 			*nlocals = id_ctlr->configured_logical_drive_count;
+ 		else
+ 			*nlocals = le16_to_cpu(
+ 					id_ctlr->extended_logical_unit_count);
+ 	else
+ 		*nlocals = -1;
+ 	return rc;
+ }
+ 
+ 
+ static void hpsa_update_scsi_devices(struct ctlr_info *h)
++>>>>>>> 66749d0d617a (hpsa: generalize external arrays)
  {
  	/* the idea here is we could get notified
  	 * that some devices have changed, so we do a report
@@@ -3725,21 -3865,21 +3909,28 @@@
  	}
  	memset(lunzerobits, 0, sizeof(lunzerobits));
  
 -	h->drv_req_rescan = 0; /* cancel scheduled rescan - we're doing it. */
 +	rescan_hba_mode = hpsa_hba_mode_enabled(h);
 +	if (rescan_hba_mode < 0)
 +		goto out;
 +
 +	if (!h->hba_mode_enabled && rescan_hba_mode)
 +		dev_warn(&h->pdev->dev, "HBA mode enabled\n");
 +	else if (h->hba_mode_enabled && !rescan_hba_mode)
 +		dev_warn(&h->pdev->dev, "HBA mode disabled\n");
 +
 +	h->hba_mode_enabled = rescan_hba_mode;
  
  	if (hpsa_gather_lun_info(h, physdev_list, &nphysicals,
 -			logdev_list, &nlogicals)) {
 -		h->drv_req_rescan = 1;
 +			logdev_list, &nlogicals))
  		goto out;
 -	}
  
+ 	/* Set number of local logicals (non PTRAID) */
+ 	if (hpsa_set_local_logical_count(h, id_ctlr, &nlocal_logicals)) {
+ 		dev_warn(&h->pdev->dev,
+ 			"%s: Can't determine number of local logical devices.\n",
+ 			__func__);
+ 	}
+ 
  	/* We might see up to the maximum number of logical and physical disks
  	 * plus external target devices, and a device for the local RAID
  	 * controller.
@@@ -3779,15 -3924,30 +3970,37 @@@
  			i, nphysicals, nlogicals, physdev_list, logdev_list);
  
  		/* skip masked non-disk devices */
 -		if (MASKED_DEVICE(lunaddrbytes) && physical_device &&
 -			(physdev_list->LUN[phys_dev_index].device_flags & 0x01))
 -			continue;
 +		if (MASKED_DEVICE(lunaddrbytes))
 +			if (i < nphysicals + (raid_ctlr_position == 0) &&
 +				NON_DISK_PHYS_DEV(lunaddrbytes))
 +				continue;
  
  		/* Get device type, vendor, model, device id */
++<<<<<<< HEAD
 +		if (hpsa_update_device_info(h, lunaddrbytes, tmpdevice,
 +							&is_OBDR))
 +			continue; /* skip it if we can't talk to it. */
++=======
+ 		rc = hpsa_update_device_info(h, lunaddrbytes, tmpdevice,
+ 							&is_OBDR);
+ 		if (rc == -ENOMEM) {
+ 			dev_warn(&h->pdev->dev,
+ 				"Out of memory, rescan deferred.\n");
+ 			h->drv_req_rescan = 1;
+ 			goto out;
+ 		}
+ 		if (rc) {
+ 			dev_warn(&h->pdev->dev,
+ 				"Inquiry failed, skipping device.\n");
+ 			continue;
+ 		}
+ 
+ 		/* Determine if this is a lun from an external target array */
+ 		tmpdevice->external =
+ 			figure_external_status(h, raid_ctlr_position, i,
+ 						nphysicals, nlocal_logicals);
+ 
++>>>>>>> 66749d0d617a (hpsa: generalize external arrays)
  		figure_bus_target_lun(h, lunaddrbytes, tmpdevice);
  		hpsa_update_device_supports_aborts(h, tmpdevice, lunaddrbytes);
  		this_device = currentsd[ncurrent];
diff --cc drivers/scsi/hpsa.h
index 3e07d020f3bd,ffcd4cbd5efc..000000000000
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@@ -70,11 -77,7 +70,15 @@@ struct hpsa_scsi_dev_t 
  	struct hpsa_scsi_dev_t *phys_disk[RAID_MAP_MAX_ENTRIES];
  	int nphysical_disks;
  	int supports_aborts;
++<<<<<<< HEAD
 +#define HPSA_DO_NOT_EXPOSE	0x0
 +#define HPSA_SG_ATTACH		0x1
 +#define HPSA_ULD_ATTACH		0x2
 +#define HPSA_SCSI_ADD		(HPSA_SG_ATTACH | HPSA_ULD_ATTACH)
 +	u8 expose_state;
++=======
+ 	int external;   /* 1-from external array 0-not <0-unknown */
++>>>>>>> 66749d0d617a (hpsa: generalize external arrays)
  };
  
  struct reply_queue_buffer {
* Unmerged path drivers/scsi/hpsa.c
* Unmerged path drivers/scsi/hpsa.h
diff --git a/drivers/scsi/hpsa_cmd.h b/drivers/scsi/hpsa_cmd.h
index 47c756ba8dce..27360c96b05e 100644
--- a/drivers/scsi/hpsa_cmd.h
+++ b/drivers/scsi/hpsa_cmd.h
@@ -288,6 +288,7 @@ struct SenseSubsystem_info {
 #define BMIC_FLASH_FIRMWARE 0xF7
 #define BMIC_SENSE_CONTROLLER_PARAMETERS 0x64
 #define BMIC_IDENTIFY_PHYSICAL_DEVICE 0x15
+#define BMIC_IDENTIFY_CONTROLLER 0x11
 
 /* Command List Structure */
 union SCSI3Addr {
@@ -684,6 +685,16 @@ struct hpsa_pci_info {
 	u32		board_id;
 };
 
+struct bmic_identify_controller {
+	u8	configured_logical_drive_count;	/* offset 0 */
+	u8	pad1[153];
+	__le16	extended_logical_unit_count;	/* offset 154 */
+	u8	pad2[136];
+	u8	controller_mode;	/* offset 292 */
+	u8	pad3[32];
+};
+
+
 struct bmic_identify_physical_device {
 	u8    scsi_bus;          /* SCSI Bus number on controller */
 	u8    scsi_id;           /* SCSI ID on this bus */
