fs/block_dev.c: Remove WARN_ON() when inode writeback fails

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [fs] block_dev.c: Remove WARN_ON() when inode writeback fails (Eric Sandeen) [1229014]
Rebuild_FUZZ: 97.39%
commit-author Vivek Goyal <vgoyal@redhat.com>
commit dbd3ca50753e70e09cad747dce23b1a7683a3342
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/dbd3ca50.failed

If a block device is hot removed and later last reference to device
is put, we try to writeback the dirty inode. But device is gone and
that writeback fails.

Currently we do a WARN_ON() which does not seem to be the right thing.
Convert it to a ratelimited kernel warning.

	Reported-by: Andi Kleen <andi@firstfloor.org>
	Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
	Acked-by: Tejun Heo <tj@kernel.org>
[jmoyer@redhat.com: get rid of unnecessary name initialization, 80 cols]
	Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit dbd3ca50753e70e09cad747dce23b1a7683a3342)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/block_dev.c
diff --cc fs/block_dev.c
index 2557803cf68e,bb0dfb1c7af1..000000000000
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@@ -49,23 -50,24 +49,42 @@@ inline struct block_device *I_BDEV(stru
  }
  EXPORT_SYMBOL(I_BDEV);
  
++<<<<<<< HEAD
 +/*
 + * Move the inode from its current bdi to a new bdi.  Make sure the inode
 + * is clean before moving so that it doesn't linger on the old bdi.
 + */
 +static void bdev_inode_switch_bdi(struct inode *inode,
 +			struct backing_dev_info *dst)
 +{
 +	while (true) {
 +		spin_lock(&inode->i_lock);
 +		if (!(inode->i_state & I_DIRTY)) {
 +			inode->i_data.backing_dev_info = dst;
 +			spin_unlock(&inode->i_lock);
 +			return;
 +		}
 +		spin_unlock(&inode->i_lock);
 +		WARN_ON_ONCE(write_inode_now(inode, true));
++=======
+ static void bdev_write_inode(struct block_device *bdev)
+ {
+ 	struct inode *inode = bdev->bd_inode;
+ 	int ret;
+ 
+ 	spin_lock(&inode->i_lock);
+ 	while (inode->i_state & I_DIRTY) {
+ 		spin_unlock(&inode->i_lock);
+ 		ret = write_inode_now(inode, true);
+ 		if (ret) {
+ 			char name[BDEVNAME_SIZE];
+ 			pr_warn_ratelimited("VFS: Dirty inode writeback failed "
+ 					    "for block device %s (err=%d).\n",
+ 					    bdevname(bdev, name), ret);
+ 		}
+ 		spin_lock(&inode->i_lock);
++>>>>>>> dbd3ca50753e (fs/block_dev.c: Remove WARN_ON() when inode writeback fails)
  	}
 -	spin_unlock(&inode->i_lock);
  }
  
  /* Kill _all_ buffers and pagecache , dirty or not.. */
@@@ -1525,11 -1509,11 +1544,15 @@@ static void __blkdev_put(struct block_d
  		WARN_ON_ONCE(bdev->bd_holders);
  		sync_blockdev(bdev);
  		kill_bdev(bdev);
 -		/*
 -		 * ->release can cause the queue to disappear, so flush all
 -		 * dirty data before.
 +		/* ->release can cause the old bdi to disappear,
 +		 * so must switch it out first
  		 */
++<<<<<<< HEAD
 +		bdev_inode_switch_bdi(bdev->bd_inode,
 +					&default_backing_dev_info);
++=======
+ 		bdev_write_inode(bdev);
++>>>>>>> dbd3ca50753e (fs/block_dev.c: Remove WARN_ON() when inode writeback fails)
  	}
  	if (bdev->bd_contains == bdev) {
  		if (disk->fops->release)
* Unmerged path fs/block_dev.c
