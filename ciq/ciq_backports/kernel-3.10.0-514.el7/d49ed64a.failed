mei: add a reference from the host client to the me client

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit d49ed64a6e3f73975b7eb570c4ea8f37e87d7e5d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d49ed64a.failed

Keep a pointer to associated me client in the host client object to
eliminate me client searches. Check if the me client is active in the
firmware by checking if its is linked on the me clients list
Add accessors for the me client properties from host client.

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit d49ed64a6e3f73975b7eb570c4ea8f37e87d7e5d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/amthif.c
#	drivers/misc/mei/bus.c
#	drivers/misc/mei/client.c
#	drivers/misc/mei/client.h
#	drivers/misc/mei/debugfs.c
#	drivers/misc/mei/main.c
#	drivers/misc/mei/mei_dev.h
#	drivers/misc/mei/nfc.c
#	drivers/misc/mei/wd.c
diff --cc drivers/misc/mei/amthif.c
index a11128c1997f,3c69616b2fa8..000000000000
--- a/drivers/misc/mei/amthif.c
+++ b/drivers/misc/mei/amthif.c
@@@ -64,49 -59,28 +64,61 @@@ void mei_amthif_reset_params(struct mei
   * mei_amthif_host_init - mei initialization amthif client.
   *
   * @dev: the device structure
+  * @me_cl: me client
   *
 - * Return: 0 on success, <0 on failure.
   */
- int mei_amthif_host_init(struct mei_device *dev)
+ int mei_amthif_host_init(struct mei_device *dev, struct mei_me_client *me_cl)
  {
  	struct mei_cl *cl = &dev->iamthif_cl;
++<<<<<<< HEAD
 +	unsigned char *msg_buf;
 +	int ret, i;
++=======
+ 	int ret;
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  
  	dev->iamthif_state = MEI_IAMTHIF_IDLE;
  
  	mei_cl_init(cl, dev);
  
++<<<<<<< HEAD
 +	i = mei_me_cl_by_uuid(dev, &mei_amthif_guid);
 +	if (i < 0) {
 +		dev_info(&dev->pdev->dev,
 +			"amthif: failed to find the client %d\n", i);
 +		return -ENOTTY;
 +	}
 +
 +	cl->me_client_id = dev->me_clients[i].client_id;
 +
++=======
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  	/* Assign iamthif_mtu to the value received from ME  */
  
 -	dev->iamthif_mtu = me_cl->props.max_msg_length;
 -	dev_dbg(dev->dev, "IAMTHIF_MTU = %d\n", dev->iamthif_mtu);
 +	dev->iamthif_mtu = dev->me_clients[i].props.max_msg_length;
 +	dev_dbg(&dev->pdev->dev, "IAMTHIF_MTU = %d\n",
 +			dev->me_clients[i].props.max_msg_length);
 +
 +	kfree(dev->iamthif_msg_buf);
 +	dev->iamthif_msg_buf = NULL;
 +
 +	/* allocate storage for ME message buffer */
 +	msg_buf = kcalloc(dev->iamthif_mtu,
 +			sizeof(unsigned char), GFP_KERNEL);
 +	if (!msg_buf)
 +		return -ENOMEM;
  
 +	dev->iamthif_msg_buf = msg_buf;
  
  	ret = mei_cl_link(cl, MEI_IAMTHIF_HOST_CLIENT_ID);
 +
  	if (ret < 0) {
++<<<<<<< HEAD
 +		dev_err(&dev->pdev->dev,
 +			"amthif: failed link client %d\n", ret);
++=======
+ 		dev_err(dev->dev, "amthif: failed cl_link %d\n", ret);
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  		return ret;
  	}
  
diff --cc drivers/misc/mei/bus.c
index ca8736c3675b,1101d6efaf27..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -141,13 -146,14 +147,23 @@@ static struct device_type mei_cl_device
  	.release	= mei_cl_dev_release,
  };
  
++<<<<<<< HEAD
 +static struct mei_cl *mei_bus_find_mei_cl_by_uuid(struct mei_device *dev,
 +						uuid_le uuid)
++=======
+ struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *dev,
+ 					 uuid_le uuid)
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  {
  	struct mei_cl *cl;
  
  	list_for_each_entry(cl, &dev->device_list, device_link) {
++<<<<<<< HEAD
 +		if (!uuid_le_cmp(uuid, cl->device_uuid))
++=======
+ 		if (cl->device && cl->device->me_cl &&
+ 		    !uuid_le_cmp(uuid, *mei_me_cl_uuid(cl->device->me_cl)))
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  			return cl;
  	}
  
@@@ -158,13 -167,8 +177,15 @@@ struct mei_cl_device *mei_cl_add_device
  					struct mei_cl_ops *ops)
  {
  	struct mei_cl_device *device;
- 	struct mei_cl *cl;
  	int status;
  
++<<<<<<< HEAD
 +	cl = mei_bus_find_mei_cl_by_uuid(dev, uuid);
 +	if (cl == NULL)
 +		return NULL;
 +
++=======
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  	device = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
  	if (!device)
  		return NULL;
@@@ -180,7 -189,8 +206,12 @@@
  
  	status = device_register(&device->dev);
  	if (status) {
++<<<<<<< HEAD
 +		dev_err(&dev->pdev->dev, "Failed to register MEI device\n");
++=======
+ 		dev_err(dev->dev, "Failed to register MEI device\n");
+ 		mei_me_cl_put(device->me_cl);
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  		kfree(device);
  		return NULL;
  	}
@@@ -229,42 -239,42 +260,63 @@@ static int ___mei_cl_send(struct mei_c
  			bool blocking)
  {
  	struct mei_device *dev;
++<<<<<<< HEAD
 +	struct mei_cl_cb *cb;
 +	int id;
 +	int rets;
++=======
+ 	struct mei_cl_cb *cb = NULL;
+ 	ssize_t rets;
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  
  	if (WARN_ON(!cl || !cl->dev))
  		return -ENODEV;
  
  	dev = cl->dev;
  
 -	mutex_lock(&dev->device_lock);
 -	if (!mei_cl_is_connected(cl)) {
 -		rets = -ENODEV;
 -		goto out;
 -	}
 +	if (cl->state != MEI_FILE_CONNECTED)
 +		return -ENODEV;
  
  	/* Check if we have an ME client device */
++<<<<<<< HEAD
 +	id = mei_me_cl_by_id(dev, cl->me_client_id);
 +	if (id < 0)
 +		return id;
 +
 +	if (length > dev->me_clients[id].props.max_msg_length)
 +		return -EINVAL;
 +
 +	cb = mei_io_cb_init(cl, NULL);
 +	if (!cb)
 +		return -ENOMEM;
 +
 +	rets = mei_io_cb_alloc_req_buf(cb, length);
 +	if (rets < 0) {
 +		mei_io_cb_free(cb);
 +		return rets;
 +	}
 +
 +	memcpy(cb->request_buffer.data, buf, length);
++=======
+ 	if (!mei_me_cl_is_active(cl->me_cl)) {
+ 		rets = -ENOTTY;
+ 		goto out;
+ 	}
+ 
+ 	if (length > mei_cl_mtu(cl)) {
+ 		rets = -EFBIG;
+ 		goto out;
+ 	}
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  
 -	cb = mei_cl_alloc_cb(cl, length, MEI_FOP_WRITE, NULL);
 -	if (!cb) {
 -		rets = -ENOMEM;
 -		goto out;
 -	}
 -
 -	memcpy(cb->buf.data, buf, length);
 +	mutex_lock(&dev->device_lock);
  
  	rets = mei_cl_write(cl, cb, blocking);
  
++<<<<<<< HEAD
++=======
+ out:
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  	mutex_unlock(&dev->device_lock);
  	if (rets < 0)
  		mei_io_cb_free(cb);
@@@ -427,10 -444,16 +479,20 @@@ int mei_cl_enable_device(struct mei_cl_
  
  	mutex_lock(&dev->device_lock);
  
++<<<<<<< HEAD
 +	err = mei_cl_connect(cl, NULL);
++=======
+ 	if (mei_cl_is_connected(cl)) {
+ 		mutex_unlock(&dev->device_lock);
+ 		dev_warn(dev->dev, "Already connected");
+ 		return -EBUSY;
+ 	}
+ 
+ 	err = mei_cl_connect(cl, device->me_cl, NULL);
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  	if (err < 0) {
  		mutex_unlock(&dev->device_lock);
 -		dev_err(dev->dev, "Could not connect to the ME client");
 +		dev_err(&dev->pdev->dev, "Could not connect to the ME client");
  
  		return err;
  	}
diff --cc drivers/misc/mei/client.c
index 3c539de435ba,aa1d35a51e9f..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -33,23 -44,143 +33,137 @@@
   *
   * Locking: called under "dev->device_lock" lock
   *
 - * Return: me client or NULL
 + * returns me client index or -ENOENT if not found
   */
 -struct mei_me_client *mei_me_cl_get(struct mei_me_client *me_cl)
 +int mei_me_cl_by_uuid(const struct mei_device *dev, const uuid_le *uuid)
  {
 -	if (me_cl && kref_get_unless_zero(&me_cl->refcnt))
 -		return me_cl;
 -
 -	return NULL;
 -}
 +	int i;
  
 -/**
 - * mei_me_cl_release - free me client
 - *
 - * Locking: called under "dev->device_lock" lock
 - *
 - * @ref: me_client refcount
 - */
 -static void mei_me_cl_release(struct kref *ref)
 -{
 -	struct mei_me_client *me_cl =
 -		container_of(ref, struct mei_me_client, refcnt);
 +	for (i = 0; i < dev->me_clients_num; ++i)
 +		if (uuid_le_cmp(*uuid,
 +				dev->me_clients[i].props.protocol_name) == 0)
 +			return i;
  
 -	kfree(me_cl);
 +	return -ENOENT;
  }
  
 +
  /**
++<<<<<<< HEAD
 + * mei_me_cl_by_id return index to me_clients for client_id
++=======
+  * mei_me_cl_put - decrease me client refcount and free client if necessary
+  *
+  * Locking: called under "dev->device_lock" lock
+  *
+  * @me_cl: me client
+  */
+ void mei_me_cl_put(struct mei_me_client *me_cl)
+ {
+ 	if (me_cl)
+ 		kref_put(&me_cl->refcnt, mei_me_cl_release);
+ }
+ 
+ /**
+  * __mei_me_cl_del  - delete me client from the list and decrease
+  *     reference counter
+  *
+  * @dev: mei device
+  * @me_cl: me client
+  *
+  * Locking: dev->me_clients_rwsem
+  */
+ static void __mei_me_cl_del(struct mei_device *dev, struct mei_me_client *me_cl)
+ {
+ 	if (!me_cl)
+ 		return;
+ 
+ 	list_del_init(&me_cl->list);
+ 	mei_me_cl_put(me_cl);
+ }
+ 
+ /**
+  * mei_me_cl_del - delete me client from the list and decrease
+  *     reference counter
+  *
+  * @dev: mei device
+  * @me_cl: me client
+  */
+ void mei_me_cl_del(struct mei_device *dev, struct mei_me_client *me_cl)
+ {
+ 	down_write(&dev->me_clients_rwsem);
+ 	__mei_me_cl_del(dev, me_cl);
+ 	up_write(&dev->me_clients_rwsem);
+ }
+ 
+ /**
+  * mei_me_cl_add - add me client to the list
+  *
+  * @dev: mei device
+  * @me_cl: me client
+  */
+ void mei_me_cl_add(struct mei_device *dev, struct mei_me_client *me_cl)
+ {
+ 	down_write(&dev->me_clients_rwsem);
+ 	list_add(&me_cl->list, &dev->me_clients);
+ 	up_write(&dev->me_clients_rwsem);
+ }
+ 
+ /**
+  * __mei_me_cl_by_uuid - locate me client by uuid
+  *	increases ref count
+  *
+  * @dev: mei device
+  * @uuid: me client uuid
+  *
+  * Return: me client or NULL if not found
+  *
+  * Locking: dev->me_clients_rwsem
+  */
+ static struct mei_me_client *__mei_me_cl_by_uuid(struct mei_device *dev,
+ 					const uuid_le *uuid)
+ {
+ 	struct mei_me_client *me_cl;
+ 	const uuid_le *pn;
+ 
+ 	WARN_ON(!rwsem_is_locked(&dev->me_clients_rwsem));
+ 
+ 	list_for_each_entry(me_cl, &dev->me_clients, list) {
+ 		pn = &me_cl->props.protocol_name;
+ 		if (uuid_le_cmp(*uuid, *pn) == 0)
+ 			return mei_me_cl_get(me_cl);
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ /**
+  * mei_me_cl_by_uuid - locate me client by uuid
+  *	increases ref count
+  *
+  * @dev: mei device
+  * @uuid: me client uuid
+  *
+  * Return: me client or NULL if not found
+  *
+  * Locking: dev->me_clients_rwsem
+  */
+ struct mei_me_client *mei_me_cl_by_uuid(struct mei_device *dev,
+ 					const uuid_le *uuid)
+ {
+ 	struct mei_me_client *me_cl;
+ 
+ 	down_read(&dev->me_clients_rwsem);
+ 	me_cl = __mei_me_cl_by_uuid(dev, uuid);
+ 	up_read(&dev->me_clients_rwsem);
+ 
+ 	return me_cl;
+ }
+ 
+ /**
+  * mei_me_cl_by_id - locate me client by client id
+  *	increases ref count
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
   *
   * @dev: the device structure
   * @client_id: me client id
@@@ -85,9 -331,50 +199,9 @@@ static inline bool mei_cl_cmp_id(const 
  {
  	return cl1 && cl2 &&
  		(cl1->host_client_id == cl2->host_client_id) &&
- 		(cl1->me_client_id == cl2->me_client_id);
+ 		(mei_cl_me_id(cl1) == mei_cl_me_id(cl2));
  }
  
 -/**
 - * mei_io_cb_free - free mei_cb_private related memory
 - *
 - * @cb: mei callback struct
 - */
 -void mei_io_cb_free(struct mei_cl_cb *cb)
 -{
 -	if (cb == NULL)
 -		return;
 -
 -	list_del(&cb->list);
 -	kfree(cb->buf.data);
 -	kfree(cb);
 -}
 -
 -/**
 - * mei_io_cb_init - allocate and initialize io callback
 - *
 - * @cl: mei client
 - * @type: operation type
 - * @fp: pointer to file structure
 - *
 - * Return: mei_cl_cb pointer or NULL;
 - */
 -struct mei_cl_cb *mei_io_cb_init(struct mei_cl *cl, enum mei_cb_file_ops type,
 -				 struct file *fp)
 -{
 -	struct mei_cl_cb *cb;
 -
 -	cb = kzalloc(sizeof(struct mei_cl_cb), GFP_KERNEL);
 -	if (!cb)
 -		return NULL;
 -
 -	INIT_LIST_HEAD(&cb->list);
 -	cb->file_object = fp;
 -	cb->cl = cl;
 -	cb->buf_idx = 0;
 -	cb->fop_type = type;
 -	return cb;
 -}
 -
  /**
   * __mei_io_list_flush - removes and frees cbs belonging to cl.
   *
@@@ -357,9 -634,11 +471,9 @@@ int mei_cl_link(struct mei_cl *cl, int 
  }
  
  /**
-  * mei_cl_unlink - remove me_cl from the list
+  * mei_cl_unlink - remove host client from the list
   *
   * @cl: host client
 - *
 - * Return: always 0
   */
  int mei_cl_unlink(struct mei_cl *cl)
  {
@@@ -401,17 -679,22 +515,34 @@@ void mei_host_client_init(struct work_s
  
  	mutex_lock(&dev->device_lock);
  
 -
 +	for (i = 0; i < dev->me_clients_num; i++) {
 +		client_props = &dev->me_clients[i].props;
 +
++<<<<<<< HEAD
 +		if (!uuid_le_cmp(client_props->protocol_name, mei_amthif_guid))
 +			mei_amthif_host_init(dev);
 +		else if (!uuid_le_cmp(client_props->protocol_name, mei_wd_guid))
 +			mei_wd_host_init(dev);
 +		else if (!uuid_le_cmp(client_props->protocol_name, mei_nfc_guid))
 +			mei_nfc_host_init(dev);
++=======
+ 	me_cl = mei_me_cl_by_uuid(dev, &mei_amthif_guid);
+ 	if (me_cl)
+ 		mei_amthif_host_init(dev, me_cl);
+ 	mei_me_cl_put(me_cl);
+ 
+ 	me_cl = mei_me_cl_by_uuid(dev, &mei_wd_guid);
+ 	if (me_cl)
+ 		mei_wd_host_init(dev, me_cl);
+ 	mei_me_cl_put(me_cl);
+ 
+ 	me_cl = mei_me_cl_by_uuid(dev, &mei_nfc_guid);
+ 	if (me_cl)
+ 		mei_nfc_host_init(dev, me_cl);
+ 	mei_me_cl_put(me_cl);
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  
 +	}
  
  	dev->dev_state = MEI_DEV_ENABLED;
  	dev->reset_count = 0;
@@@ -448,6 -730,91 +579,94 @@@ bool mei_hbuf_acquire(struct mei_devic
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mei_cl_set_disconnected - set disconnected state and clear
+  *   associated states and resources
+  *
+  * @cl: host client
+  */
+ void mei_cl_set_disconnected(struct mei_cl *cl)
+ {
+ 	struct mei_device *dev = cl->dev;
+ 
+ 	if (cl->state == MEI_FILE_DISCONNECTED ||
+ 	    cl->state == MEI_FILE_INITIALIZING)
+ 		return;
+ 
+ 	cl->state = MEI_FILE_DISCONNECTED;
+ 	mei_io_list_flush(&dev->ctrl_rd_list, cl);
+ 	mei_io_list_flush(&dev->ctrl_wr_list, cl);
+ 	cl->mei_flow_ctrl_creds = 0;
+ 	cl->timer_count = 0;
+ 
+ 	mei_me_cl_put(cl->me_cl);
+ 	cl->me_cl = NULL;
+ }
+ 
+ /*
+  * mei_cl_send_disconnect - send disconnect request
+  *
+  * @cl: host client
+  * @cb: callback block
+  *
+  * Return: 0, OK; otherwise, error.
+  */
+ static int mei_cl_send_disconnect(struct mei_cl *cl, struct mei_cl_cb *cb)
+ {
+ 	struct mei_device *dev;
+ 	int ret;
+ 
+ 	dev = cl->dev;
+ 
+ 	ret = mei_hbm_cl_disconnect_req(dev, cl);
+ 	cl->status = ret;
+ 	if (ret) {
+ 		cl->state = MEI_FILE_DISCONNECT_REPLY;
+ 		return ret;
+ 	}
+ 
+ 	list_move_tail(&cb->list, &dev->ctrl_rd_list.list);
+ 	cl->timer_count = MEI_CONNECT_TIMEOUT;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * mei_cl_irq_disconnect - processes close related operation from
+  *	interrupt thread context - send disconnect request
+  *
+  * @cl: client
+  * @cb: callback block.
+  * @cmpl_list: complete list.
+  *
+  * Return: 0, OK; otherwise, error.
+  */
+ int mei_cl_irq_disconnect(struct mei_cl *cl, struct mei_cl_cb *cb,
+ 			    struct mei_cl_cb *cmpl_list)
+ {
+ 	struct mei_device *dev = cl->dev;
+ 	u32 msg_slots;
+ 	int slots;
+ 	int ret;
+ 
+ 	msg_slots = mei_data2slots(sizeof(struct hbm_client_connect_request));
+ 	slots = mei_hbuf_empty_slots(dev);
+ 
+ 	if (slots < msg_slots)
+ 		return -EMSGSIZE;
+ 
+ 	ret = mei_cl_send_disconnect(cl, cb);
+ 	if (ret)
+ 		list_move_tail(&cb->list, &cmpl_list->list);
+ 
+ 	return ret;
+ }
+ 
+ 
+ 
+ /**
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
   * mei_cl_disconnect - disconnect host client from the me one
   *
   * @cl: host client
@@@ -547,27 -905,88 +766,39 @@@ bool mei_cl_is_other_connecting(struct 
  
  	dev = cl->dev;
  
++<<<<<<< HEAD
 +	list_for_each_entry(ocl, &dev->file_list, link) {
 +		if (ocl->state == MEI_FILE_CONNECTING &&
 +		    ocl != cl &&
 +		    cl->me_client_id == ocl->me_client_id)
++=======
+ 	list_for_each_entry(cb, &dev->ctrl_rd_list.list, list) {
+ 		if (cb->fop_type == MEI_FOP_CONNECT &&
+ 		    mei_cl_me_id(cl) == mei_cl_me_id(cb->cl))
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  			return true;
 -	}
  
 -	return false;
 -}
 -
 -/**
 - * mei_cl_send_connect - send connect request
 - *
 - * @cl: host client
 - * @cb: callback block
 - *
 - * Return: 0, OK; otherwise, error.
 - */
 -static int mei_cl_send_connect(struct mei_cl *cl, struct mei_cl_cb *cb)
 -{
 -	struct mei_device *dev;
 -	int ret;
 -
 -	dev = cl->dev;
 -
 -	ret = mei_hbm_cl_connect_req(dev, cl);
 -	cl->status = ret;
 -	if (ret) {
 -		cl->state = MEI_FILE_DISCONNECT_REPLY;
 -		return ret;
  	}
  
 -	list_move_tail(&cb->list, &dev->ctrl_rd_list.list);
 -	cl->timer_count = MEI_CONNECT_TIMEOUT;
 -	return 0;
 -}
 -
 -/**
 - * mei_cl_irq_connect - send connect request in irq_thread context
 - *
 - * @cl: host client
 - * @cb: callback block
 - * @cmpl_list: complete list
 - *
 - * Return: 0, OK; otherwise, error.
 - */
 -int mei_cl_irq_connect(struct mei_cl *cl, struct mei_cl_cb *cb,
 -			      struct mei_cl_cb *cmpl_list)
 -{
 -	struct mei_device *dev = cl->dev;
 -	u32 msg_slots;
 -	int slots;
 -	int rets;
 -
 -	msg_slots = mei_data2slots(sizeof(struct hbm_client_connect_request));
 -	slots = mei_hbuf_empty_slots(dev);
 -
 -	if (mei_cl_is_other_connecting(cl))
 -		return 0;
 -
 -	if (slots < msg_slots)
 -		return -EMSGSIZE;
 -
 -	rets = mei_cl_send_connect(cl, cb);
 -	if (rets)
 -		list_move_tail(&cb->list, &cmpl_list->list);
 -
 -	return rets;
 +	return false;
  }
  
  /**
   * mei_cl_connect - connect host client to the me one
   *
   * @cl: host client
++<<<<<<< HEAD
++=======
+  * @me_cl: me client
+  * @file: pointer to file structure
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
   *
   * Locking: called under "dev->device_lock" lock
   *
 - * Return: 0 on success, <0 on failure.
 + * returns 0 on success, <0 on failure.
   */
- int mei_cl_connect(struct mei_cl *cl, struct file *file)
+ int mei_cl_connect(struct mei_cl *cl, struct mei_me_client *me_cl,
+ 		   struct file *file)
  {
  	struct mei_device *dev;
  	struct mei_cl_cb *cb;
@@@ -585,13 -1004,19 +816,24 @@@
  		return rets;
  	}
  
 -	cb = mei_io_cb_init(cl, MEI_FOP_CONNECT, file);
 -	rets = cb ? 0 : -ENOMEM;
 -	if (rets)
 +	cb = mei_io_cb_init(cl, file);
 +	if (!cb) {
 +		rets = -ENOMEM;
  		goto out;
 +	}
  
++<<<<<<< HEAD
 +	cb->fop_type = MEI_FOP_CONNECT;
++=======
+ 	cl->me_cl = mei_me_cl_get(me_cl);
+ 	if (!cl->me_cl) {
+ 		rets = -ENODEV;
+ 		goto out;
+ 	}
+ 
+ 	cl->state = MEI_FILE_CONNECTING;
+ 	list_add_tail(&cb->list, &dev->ctrl_wr_list.list);
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  
  	/* run hbuf acquire last so we don't have to undo */
  	if (!mei_cl_is_other_connecting(cl) && mei_hbuf_acquire(dev)) {
@@@ -636,43 -1053,55 +878,60 @@@ out
  }
  
  /**
 - * mei_cl_alloc_linked - allocate and link host client
 + * mei_cl_flow_ctrl_creds - checks flow_control credits for cl.
   *
 - * @dev: the device structure
 - * @id: fixed host id or MEI_HOST_CLIENT_ID_ANY (-1) for generic one
 + * @cl: private data of the file object
   *
 - * Return: cl on success ERR_PTR on failure
++<<<<<<< HEAD
 + * returns 1 if mei_flow_ctrl_creds >0, 0 - otherwise.
 + *	-ENOENT if mei_cl is not present
 + *	-EINVAL if single_recv_buf == 0
   */
 -struct mei_cl *mei_cl_alloc_linked(struct mei_device *dev, int id)
 +int mei_cl_flow_ctrl_creds(struct mei_cl *cl)
  {
 -	struct mei_cl *cl;
 -	int ret;
 +	struct mei_device *dev;
 +	struct mei_me_client *me_cl;
 +	int id;
  
 -	cl = mei_cl_allocate(dev);
 -	if (!cl) {
 -		ret = -ENOMEM;
 -		goto err;
 -	}
 +	if (WARN_ON(!cl || !cl->dev))
 +		return -EINVAL;
  
 -	ret = mei_cl_link(cl, id);
 -	if (ret)
 -		goto err;
 +	dev = cl->dev;
  
 -	return cl;
 -err:
 -	kfree(cl);
 -	return ERR_PTR(ret);
 -}
 +	if (!dev->me_clients_num)
 +		return 0;
  
 +	if (cl->mei_flow_ctrl_creds > 0)
 +		return 1;
  
 +	id = mei_me_cl_by_id(dev, cl->me_client_id);
 +	if (id < 0) {
 +		cl_err(dev, cl, "no such me client %d\n", cl->me_client_id);
 +		return id;
 +	}
  
 -/**
 - * mei_cl_flow_ctrl_creds - checks flow_control credits for cl.
 - *
 - * @cl: private data of the file object
 - *
 +	me_cl = &dev->me_clients[id];
 +	if (me_cl->mei_flow_ctrl_creds) {
 +		if (WARN_ON(me_cl->props.single_recv_buf == 0))
 +			return -EINVAL;
 +		return 1;
 +	}
++=======
+  * Return: 1 if mei_flow_ctrl_creds >0, 0 - otherwise.
+  */
+ int mei_cl_flow_ctrl_creds(struct mei_cl *cl)
+ {
+ 	if (WARN_ON(!cl || !cl->me_cl))
+ 		return -EINVAL;
+ 
+ 	if (cl->mei_flow_ctrl_creds > 0)
+ 		return 1;
+ 
+ 	if (mei_cl_is_single_recv_buf(cl)) {
+ 		if (cl->me_cl->mei_flow_ctrl_creds > 0)
+ 			return 1;
+ 	}
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  	return 0;
  }
  
@@@ -681,33 -1110,19 +940,42 @@@
   *
   * @cl: private data of the file object
   *
 - * Return:
 + * @returns
   *	0 on success
-  *	-ENOENT when me client is not found
   *	-EINVAL when ctrl credits are <= 0
   */
  int mei_cl_flow_ctrl_reduce(struct mei_cl *cl)
  {
++<<<<<<< HEAD
 +	struct mei_device *dev;
 +	struct mei_me_client *me_cl;
 +	int id;
 +
 +	if (WARN_ON(!cl || !cl->dev))
 +		return -EINVAL;
 +
 +	dev = cl->dev;
 +
 +	id = mei_me_cl_by_id(dev, cl->me_client_id);
 +	if (id < 0) {
 +		cl_err(dev, cl, "no such me client %d\n", cl->me_client_id);
 +		return id;
 +	}
 +
 +	me_cl = &dev->me_clients[id];
 +	if (me_cl->props.single_recv_buf != 0) {
 +		if (WARN_ON(me_cl->mei_flow_ctrl_creds <= 0))
 +			return -EINVAL;
 +		me_cl->mei_flow_ctrl_creds--;
++=======
+ 	if (WARN_ON(!cl || !cl->me_cl))
+ 		return -EINVAL;
+ 
+ 	if (mei_cl_is_single_recv_buf(cl)) {
+ 		if (WARN_ON(cl->me_cl->mei_flow_ctrl_creds <= 0))
+ 			return -EINVAL;
+ 		cl->me_cl->mei_flow_ctrl_creds--;
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  	} else {
  		if (WARN_ON(cl->mei_flow_ctrl_creds <= 0))
  			return -EINVAL;
@@@ -738,19 -1154,20 +1006,29 @@@ int mei_cl_read_start(struct mei_cl *cl
  	if (!mei_cl_is_connected(cl))
  		return -ENODEV;
  
 -	/* HW currently supports only one pending read */
 -	if (!list_empty(&cl->rd_pending))
 +	if (cl->read_cb) {
 +		cl_dbg(dev, cl, "read is pending.\n");
  		return -EBUSY;
++<<<<<<< HEAD
 +	}
 +	i = mei_me_cl_by_id(dev, cl->me_client_id);
 +	if (i < 0) {
 +		cl_err(dev, cl, "no such me client %d\n", cl->me_client_id);
 +		return  -ENOTTY;
 +	}
++=======
+ 
+ 	if (!mei_me_cl_is_active(cl->me_cl)) {
+ 		cl_err(dev, cl, "no such me client\n");
+ 		return  -ENOTTY;
+ 	}
+ 	/* always allocate at least client max message */
+ 	length = max_t(size_t, length, mei_cl_mtu(cl));
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  
 -	rets = pm_runtime_get(dev->dev);
 +	rets = pm_runtime_get(&dev->pdev->dev);
  	if (rets < 0 && rets != -EINPROGRESS) {
 -		pm_runtime_put_noidle(dev->dev);
 +		pm_runtime_put_noidle(&dev->pdev->dev);
  		cl_err(dev, cl, "rpm: get failed %d\n", rets);
  		return rets;
  	}
diff --cc drivers/misc/mei/client.h
index f2a130967f1e,076265032450..000000000000
--- a/drivers/misc/mei/client.h
+++ b/drivers/misc/mei/client.h
@@@ -24,9 -24,50 +24,33 @@@
  
  #include "mei_dev.h"
  
 -/*
 - * reference counting base function
 - */
 -void mei_me_cl_init(struct mei_me_client *me_cl);
 -void mei_me_cl_put(struct mei_me_client *me_cl);
 -struct mei_me_client *mei_me_cl_get(struct mei_me_client *me_cl);
 -
 -void mei_me_cl_add(struct mei_device *dev, struct mei_me_client *me_cl);
 -void mei_me_cl_del(struct mei_device *dev, struct mei_me_client *me_cl);
 -
 -struct mei_me_client *mei_me_cl_by_uuid(struct mei_device *dev,
 -					const uuid_le *uuid);
 -struct mei_me_client *mei_me_cl_by_id(struct mei_device *dev, u8 client_id);
 -struct mei_me_client *mei_me_cl_by_uuid_id(struct mei_device *dev,
 -					   const uuid_le *uuid, u8 client_id);
 -void mei_me_cl_rm_by_uuid(struct mei_device *dev, const uuid_le *uuid);
 -void mei_me_cl_rm_by_uuid_id(struct mei_device *dev,
 -			     const uuid_le *uuid, u8 id);
 -void mei_me_cl_rm_all(struct mei_device *dev);
 +int mei_me_cl_by_uuid(const struct mei_device *dev, const uuid_le *cuuid);
 +int mei_me_cl_by_id(struct mei_device *dev, u8 client_id);
  
+ /**
+  * mei_me_cl_is_active - check whether me client is active in the fw
+  *
+  * @me_cl: me client
+  *
+  * Return: true if the me client is active in the firmware
+  */
+ static inline bool mei_me_cl_is_active(const struct mei_me_client *me_cl)
+ {
+ 	return !list_empty_careful(&me_cl->list);
+ }
+ 
+ /**
+  * mei_me_cl_uuid - return me client protocol name (uuid)
+  *
+  * @me_cl: me client
+  *
+  * Return: me client protocol name
+  */
+ static inline const uuid_le *mei_me_cl_uuid(const struct mei_me_client *me_cl)
+ {
+ 	return &me_cl->props.protocol_name;
+ }
+ 
  /*
   * MEI IO Functions
   */
@@@ -68,21 -114,91 +92,107 @@@ int mei_cl_flow_ctrl_reduce(struct mei_
  /*
   *  MEI input output function prototype
   */
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * mei_cl_is_connected - host client is connected
+  *
+  * @cl: host client
+  *
+  * Return: true if the host client is connected
+  */
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  static inline bool mei_cl_is_connected(struct mei_cl *cl)
  {
  	return  cl->state == MEI_FILE_CONNECTED;
  }
 +static inline bool mei_cl_is_transitioning(struct mei_cl *cl)
 +{
 +	return  MEI_FILE_INITIALIZING == cl->state ||
 +		MEI_FILE_DISCONNECTED == cl->state ||
 +		MEI_FILE_DISCONNECTING == cl->state;
 +}
  
++<<<<<<< HEAD
 +bool mei_cl_is_other_connecting(struct mei_cl *cl);
 +int mei_cl_disconnect(struct mei_cl *cl);
 +int mei_cl_connect(struct mei_cl *cl, struct file *file);
 +int mei_cl_read_start(struct mei_cl *cl, size_t length);
++=======
+ /**
+  * mei_cl_me_id - me client id
+  *
+  * @cl: host client
+  *
+  * Return: me client id or 0 if client is not connected
+  */
+ static inline u8 mei_cl_me_id(const struct mei_cl *cl)
+ {
+ 	return cl->me_cl ? cl->me_cl->client_id : 0;
+ }
+ 
+ /**
+  * mei_cl_mtu - maximal message that client can send and receive
+  *
+  * @cl: host client
+  *
+  * Return: mtu
+  */
+ static inline size_t mei_cl_mtu(const struct mei_cl *cl)
+ {
+ 	return cl->me_cl->props.max_msg_length;
+ }
+ 
+ /**
+  * mei_cl_is_fixed_address - check whether the me client uses fixed address
+  *
+  * @cl: host client
+  *
+  * Return: true if the client is connected and it has fixed me address
+  */
+ static inline bool mei_cl_is_fixed_address(const struct mei_cl *cl)
+ {
+ 	return cl->me_cl && cl->me_cl->props.fixed_address;
+ }
+ 
+ /**
+  * mei_cl_is_single_recv_buf- check whether the me client
+  *       uses single receiving buffer
+  *
+  * @cl: host client
+  *
+  * Return: true if single_recv_buf == 1; 0 otherwise
+  */
+ static inline bool mei_cl_is_single_recv_buf(const struct mei_cl *cl)
+ {
+ 	return cl->me_cl->props.single_recv_buf;
+ }
+ 
+ /**
+  * mei_cl_uuid -  client's uuid
+  *
+  * @cl: host client
+  *
+  * Return: return uuid of connected me client
+  */
+ static inline const uuid_le *mei_cl_uuid(const struct mei_cl *cl)
+ {
+ 	return mei_me_cl_uuid(cl->me_cl);
+ }
+ 
+ int mei_cl_disconnect(struct mei_cl *cl);
+ void mei_cl_set_disconnected(struct mei_cl *cl);
+ int mei_cl_irq_disconnect(struct mei_cl *cl, struct mei_cl_cb *cb,
+ 			  struct mei_cl_cb *cmpl_list);
+ int mei_cl_connect(struct mei_cl *cl, struct mei_me_client *me_cl,
+ 		   struct file *file);
+ int mei_cl_irq_connect(struct mei_cl *cl, struct mei_cl_cb *cb,
+ 			      struct mei_cl_cb *cmpl_list);
+ int mei_cl_read_start(struct mei_cl *cl, size_t length, struct file *fp);
+ int mei_cl_irq_read_msg(struct mei_cl *cl, struct mei_msg_hdr *hdr,
+ 			struct mei_cl_cb *cmpl_list);
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  int mei_cl_write(struct mei_cl *cl, struct mei_cl_cb *cb, bool blocking);
  int mei_cl_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,
  		     struct mei_cl_cb *cmpl_list);
@@@ -98,12 -212,12 +206,12 @@@ void mei_cl_all_wakeup(struct mei_devic
  void mei_cl_all_write_clear(struct mei_device *dev);
  
  #define MEI_CL_FMT "cl:host=%02d me=%02d "
- #define MEI_CL_PRM(cl) (cl)->host_client_id, (cl)->me_client_id
+ #define MEI_CL_PRM(cl) (cl)->host_client_id, mei_cl_me_id(cl)
  
  #define cl_dbg(dev, cl, format, arg...) \
 -	dev_dbg((dev)->dev, MEI_CL_FMT format, MEI_CL_PRM(cl), ##arg)
 +	dev_dbg(&(dev)->pdev->dev, MEI_CL_FMT format, MEI_CL_PRM(cl), ##arg)
  
  #define cl_err(dev, cl, format, arg...) \
 -	dev_err((dev)->dev, MEI_CL_FMT format, MEI_CL_PRM(cl), ##arg)
 +	dev_err(&(dev)->pdev->dev, MEI_CL_FMT format, MEI_CL_PRM(cl), ##arg)
  
  #endif /* _MEI_CLIENT_H_ */
diff --cc drivers/misc/mei/debugfs.c
index 85d1d2217fb8,3f6d855a7ecb..000000000000
--- a/drivers/misc/mei/debugfs.c
+++ b/drivers/misc/mei/debugfs.c
@@@ -106,8 -116,8 +106,13 @@@ static ssize_t mei_dbgfs_read_active(st
  
  		pos += scnprintf(buf + pos, bufsz - pos,
  			"%2d|%2d|%4d|%5d|%2d|%2d|\n",
++<<<<<<< HEAD
 +			i, cl->me_client_id, cl->host_client_id, cl->state,
 +			cl->reading_state, cl->writing_state);
++=======
+ 			i, mei_cl_me_id(cl), cl->host_client_id, cl->state,
+ 			!list_empty(&cl->rd_completed), cl->writing_state);
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  		i++;
  	}
  out:
diff --cc drivers/misc/mei/main.c
index b23f9eba9e3a,a69636594150..000000000000
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@@ -344,8 -288,13 +344,18 @@@ static ssize_t mei_write(struct file *f
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	id = mei_me_cl_by_id(dev, cl->me_client_id);
 +	if (id < 0) {
++=======
+ 	if (!mei_cl_is_connected(cl)) {
+ 		cl_err(dev, cl, "is not connected");
+ 		rets = -ENODEV;
+ 		goto out;
+ 	}
+ 
+ 	if (!mei_me_cl_is_active(cl->me_cl)) {
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  		rets = -ENOTTY;
  		goto out;
  	}
@@@ -355,17 -309,6 +370,20 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	if (length > dev->me_clients[id].props.max_msg_length) {
 +		rets = -EFBIG;
 +		goto out;
 +	}
 +
 +	if (cl->state != MEI_FILE_CONNECTED) {
 +		dev_err(&dev->pdev->dev, "host client = %d,  is not connected to ME client = %d",
 +			cl->host_client_id, cl->me_client_id);
 +		rets = -ENODEV;
 +		goto out;
 +	}
++=======
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  	if (cl == &dev->iamthif_cl) {
  		write_cb = mei_amthif_find_read_list_entry(dev, file);
  
@@@ -467,34 -380,28 +485,59 @@@ static int mei_ioctl_connect_client(str
  	cl = file->private_data;
  	dev = cl->dev;
  
++<<<<<<< HEAD
 +	if (dev->dev_state != MEI_DEV_ENABLED) {
 +		rets = -ENODEV;
 +		goto end;
 +	}
 +
 +	if (cl->state != MEI_FILE_INITIALIZING &&
 +	    cl->state != MEI_FILE_DISCONNECTED) {
 +		rets = -EBUSY;
 +		goto end;
 +	}
 +
 +	/* find ME client we're trying to connect to */
 +	i = mei_me_cl_by_uuid(dev, &data->in_client_uuid);
 +	if (i < 0 || dev->me_clients[i].props.fixed_address) {
 +		dev_dbg(&dev->pdev->dev, "Cannot connect to FW Client UUID = %pUl\n",
 +				&data->in_client_uuid);
 +		rets = -ENOTTY;
 +		goto end;
 +	}
 +
 +	cl->me_client_id = dev->me_clients[i].client_id;
 +
 +	dev_dbg(&dev->pdev->dev, "Connect to FW Client ID = %d\n",
 +			cl->me_client_id);
 +	dev_dbg(&dev->pdev->dev, "FW Client - Protocol Version = %d\n",
 +			dev->me_clients[i].props.protocol_version);
 +	dev_dbg(&dev->pdev->dev, "FW Client - Max Msg Len = %d\n",
 +			dev->me_clients[i].props.max_msg_length);
++=======
+ 	if (dev->dev_state != MEI_DEV_ENABLED)
+ 		return -ENODEV;
+ 
+ 	if (cl->state != MEI_FILE_INITIALIZING &&
+ 	    cl->state != MEI_FILE_DISCONNECTED)
+ 		return  -EBUSY;
+ 
+ 	/* find ME client we're trying to connect to */
+ 	me_cl = mei_me_cl_by_uuid(dev, &data->in_client_uuid);
+ 	if (!me_cl || me_cl->props.fixed_address) {
+ 		dev_dbg(dev->dev, "Cannot connect to FW Client UUID = %pUl\n",
+ 			&data->in_client_uuid);
+ 		mei_me_cl_put(me_cl);
+ 		return  -ENOTTY;
+ 	}
+ 
+ 	dev_dbg(dev->dev, "Connect to FW Client ID = %d\n",
+ 			me_cl->client_id);
+ 	dev_dbg(dev->dev, "FW Client - Protocol Version = %d\n",
+ 			me_cl->props.protocol_version);
+ 	dev_dbg(dev->dev, "FW Client - Max Msg Len = %d\n",
+ 			me_cl->props.max_msg_length);
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  
  	/* if we're connecting to amthif client then we will use the
  	 * existing connection
@@@ -522,17 -427,16 +565,17 @@@
  		goto end;
  	}
  
 +
  	/* prepare the output buffer */
  	client = &data->out_client_properties;
 -	client->max_msg_length = me_cl->props.max_msg_length;
 -	client->protocol_version = me_cl->props.protocol_version;
 -	dev_dbg(dev->dev, "Can connect?\n");
 +	client->max_msg_length = dev->me_clients[i].props.max_msg_length;
 +	client->protocol_version = dev->me_clients[i].props.protocol_version;
 +	dev_dbg(&dev->pdev->dev, "Can connect?\n");
 +
  
- 	rets = mei_cl_connect(cl, file);
+ 	rets = mei_cl_connect(cl, me_cl, file);
  
  end:
 -	mei_me_cl_put(me_cl);
  	return rets;
  }
  
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,87db0976671c..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -201,10 -211,34 +201,36 @@@ struct mei_cl_cb 
  	unsigned long buf_idx;
  	unsigned long read_time;
  	struct file *file_object;
 -	int status;
  	u32 internal:1;
 -	u32 completed:1;
  };
  
++<<<<<<< HEAD
 +/* MEI client instance carried as file->private_data*/
++=======
+ /**
+  * struct mei_cl - me client host representation
+  *    carried in file->private_data
+  *
+  * @link: link in the clients list
+  * @dev: mei parent device
+  * @state: file operation state
+  * @tx_wait: wait queue for tx completion
+  * @rx_wait: wait queue for rx completion
+  * @wait:  wait queue for management operation
+  * @status: connection status
+  * @me_cl: fw client connected
+  * @host_client_id: host id
+  * @mei_flow_ctrl_creds: transmit flow credentials
+  * @timer_count:  watchdog timer for operation completion
+  * @reserved: reserved for alignment
+  * @writing_state: state of the tx
+  * @rd_pending: pending read credits
+  * @rd_completed: completed read
+  *
+  * @device: device on the mei client bus
+  * @device_link:  link to bus clients
+  */
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  struct mei_cl {
  	struct list_head link;
  	struct mei_device *dev;
@@@ -213,15 -247,14 +239,22 @@@
  	wait_queue_head_t rx_wait;
  	wait_queue_head_t wait;
  	int status;
++<<<<<<< HEAD
 +	/* ID of client connected */
++=======
+ 	struct mei_me_client *me_cl;
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  	u8 host_client_id;
- 	u8 me_client_id;
  	u8 mei_flow_ctrl_creds;
  	u8 timer_count;
++<<<<<<< HEAD
 +	enum mei_file_transaction_states reading_state;
++=======
+ 	u8 reserved;
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  	enum mei_file_transaction_states writing_state;
 -	struct list_head rd_pending;
 -	struct list_head rd_completed;
 +	int sm_state;
 +	struct mei_cl_cb *read_cb;
  
  	/* MEI CL bus data */
  	struct mei_cl_device *device;
@@@ -332,11 -370,13 +367,15 @@@ void mei_cl_bus_exit(void)
   * when being probed and shall use it for doing ME bus I/O.
   *
   * @dev: linux driver model device pointer
++<<<<<<< HEAD
 + * @uuid: me client uuid
++=======
+  * @me_cl: me client
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
   * @cl: mei client
   * @ops: ME transport ops
 - * @event_work: async work to execute event callback
   * @event_cb: Drivers register this callback to get asynchronous ME
   *	events (e.g. Rx buffer pending) notifications.
 - * @event_context: event callback run context
   * @events: Events bitmask sent to the driver.
   * @priv_data: client private data
   */
@@@ -579,10 -657,8 +619,10 @@@ void mei_irq_compl_handler(struct mei_d
   */
  void mei_amthif_reset_params(struct mei_device *dev);
  
- int mei_amthif_host_init(struct mei_device *dev);
+ int mei_amthif_host_init(struct mei_device *dev, struct mei_me_client *me_cl);
  
 +int mei_amthif_write(struct mei_device *dev, struct mei_cl_cb *priv_cb);
 +
  int mei_amthif_read(struct mei_device *dev, struct file *file,
  		char __user *ubuf, size_t length, loff_t *offset);
  
diff --cc drivers/misc/mei/nfc.c
index 2b65e8021f0d,e2a6ba0236c8..000000000000
--- a/drivers/misc/mei/nfc.c
+++ b/drivers/misc/mei/nfc.c
@@@ -87,16 -88,24 +87,18 @@@ struct mei_nfc_hci_hdr 
  
  #define MEI_NFC_HEADER_SIZE 10
  
 -/**
 - * struct mei_nfc_dev - NFC mei device
 +/** mei_nfc_dev - NFC mei device
   *
+  * @me_cl: NFC me client
   * @cl: NFC host client
   * @cl_info: NFC info host client
   * @init_work: perform connection to the info client
   * @fw_ivn: NFC Interface Version Number
   * @vendor_id: NFC manufacturer ID
   * @radio_type: NFC radio type
 - * @bus_name: bus name
 - *
 - * @req_id:  message counter
 - * @recv_req_id: reception message counter
   */
  struct mei_nfc_dev {
+ 	struct mei_me_client *me_cl;
  	struct mei_cl *cl;
  	struct mei_cl *cl_info;
  	struct work_struct init_work;
@@@ -143,7 -153,8 +145,12 @@@ static void mei_nfc_free(struct mei_nfc
  		kfree(ndev->cl_info);
  	}
  
++<<<<<<< HEAD
 +	memset(ndev, 0, sizeof(struct mei_nfc_dev));
++=======
+ 	mei_me_cl_put(ndev->me_cl);
+ 	kfree(ndev);
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  }
  
  static int mei_nfc_build_bus_name(struct mei_nfc_dev *ndev)
@@@ -417,10 -429,18 +425,19 @@@ static void mei_nfc_init(struct work_st
  
  	mutex_lock(&dev->device_lock);
  
- 	if (mei_cl_connect(cl_info, NULL) < 0) {
+ 	/* check for valid client id */
+ 	me_cl_info = mei_me_cl_by_uuid(dev, &mei_nfc_info_guid);
+ 	if (!me_cl_info) {
+ 		mutex_unlock(&dev->device_lock);
+ 		dev_info(dev->dev, "nfc: failed to find the info client\n");
+ 		goto err;
+ 	}
+ 
+ 	if (mei_cl_connect(cl_info, me_cl_info, NULL) < 0) {
+ 		mei_me_cl_put(me_cl_info);
  		mutex_unlock(&dev->device_lock);
 -		dev_err(dev->dev, "Could not connect to the NFC INFO ME client");
 +		dev_err(&dev->pdev->dev,
 +			"Could not connect to the NFC INFO ME client");
  
  		goto err;
  	}
@@@ -455,10 -472,10 +472,11 @@@
  		return;
  	}
  
- 	cldev = mei_cl_add_device(dev, mei_nfc_guid, ndev->bus_name, &nfc_ops);
+ 	cldev = mei_cl_add_device(dev, ndev->me_cl, ndev->cl,
+ 				  ndev->bus_name, &nfc_ops);
  	if (!cldev) {
 -		dev_err(dev->dev, "Could not add the NFC device to the MEI bus\n");
 +		dev_err(&dev->pdev->dev,
 +			"Could not add the NFC device to the MEI bus\n");
  
  		goto err;
  	}
@@@ -476,64 -493,52 +494,89 @@@ err
  }
  
  
- int mei_nfc_host_init(struct mei_device *dev)
+ int mei_nfc_host_init(struct mei_device *dev, struct mei_me_client *me_cl)
  {
++<<<<<<< HEAD
 +	struct mei_nfc_dev *ndev = &nfc_dev;
 +	struct mei_cl *cl_info, *cl = NULL;
 +	int i, ret;
++=======
+ 	struct mei_nfc_dev *ndev;
+ 	struct mei_cl *cl_info, *cl;
+ 	int ret;
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  
 -
 -	/* in case of internal reset bail out
 -	 * as the device is already setup
 -	 */
 -	cl = mei_cl_bus_find_cl_by_uuid(dev, mei_nfc_guid);
 -	if (cl)
 +	/* already initialized */
 +	if (ndev->cl_info)
  		return 0;
  
 -	ndev = kzalloc(sizeof(struct mei_nfc_dev), GFP_KERNEL);
 -	if (!ndev) {
 +	ndev->cl_info = mei_cl_allocate(dev);
 +	ndev->cl = mei_cl_allocate(dev);
 +
 +	cl = ndev->cl;
 +	cl_info = ndev->cl_info;
 +
 +	if (!cl || !cl_info) {
  		ret = -ENOMEM;
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	/* check for valid client id */
 +	i = mei_me_cl_by_uuid(dev, &mei_nfc_info_guid);
 +	if (i < 0) {
 +		dev_info(&dev->pdev->dev, "nfc: failed to find the client\n");
 +		ret = -ENOTTY;
++=======
+ 	ndev->me_cl = mei_me_cl_get(me_cl);
+ 	if (!ndev->me_cl) {
+ 		ret = -ENODEV;
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  		goto err;
  	}
  
 -	cl_info = mei_cl_alloc_linked(dev, MEI_HOST_CLIENT_ID_ANY);
 -	if (IS_ERR(cl_info)) {
 -		ret = PTR_ERR(cl_info);
 +	cl_info->me_client_id = dev->me_clients[i].client_id;
 +
++<<<<<<< HEAD
 +	ret = mei_cl_link(cl_info, MEI_HOST_CLIENT_ID_ANY);
 +	if (ret)
 +		goto err;
 +
 +	cl_info->device_uuid = mei_nfc_info_guid;
 +
 +	list_add_tail(&cl_info->device_link, &dev->device_list);
 +
 +	/* check for valid client id */
 +	i = mei_me_cl_by_uuid(dev, &mei_nfc_guid);
 +	if (i < 0) {
 +		dev_info(&dev->pdev->dev, "nfc: failed to find the client\n");
 +		ret = -ENOTTY;
  		goto err;
  	}
  
 +	cl->me_client_id = dev->me_clients[i].client_id;
 +
 +	ret = mei_cl_link(cl, MEI_HOST_CLIENT_ID_ANY);
 +	if (ret)
 +		goto err;
 +
 +	cl->device_uuid = mei_nfc_guid;
 +
 +
++=======
+ 	list_add_tail(&cl_info->device_link, &dev->device_list);
+ 
+ 	ndev->cl_info = cl_info;
+ 
+ 	cl = mei_cl_alloc_linked(dev, MEI_HOST_CLIENT_ID_ANY);
+ 	if (IS_ERR(cl)) {
+ 		ret = PTR_ERR(cl);
+ 		goto err;
+ 	}
+ 
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  	list_add_tail(&cl->device_link, &dev->device_list);
  
 -	ndev->cl = cl;
 -
  	ndev->req_id = 1;
  
  	INIT_WORK(&ndev->init_work, mei_nfc_init);
diff --cc drivers/misc/mei/wd.c
index f22efbbc16aa,2bc0f5089f82..000000000000
--- a/drivers/misc/mei/wd.c
+++ b/drivers/misc/mei/wd.c
@@@ -57,15 -50,15 +57,19 @@@ static void mei_wd_set_start_timeout(st
   * mei_wd_host_init - connect to the watchdog client
   *
   * @dev: the device structure
+  * @me_cl: me client
   *
 - * Return: -ENOTTY if wd client cannot be found
 + * returns -ENOTTY if wd client cannot be found
   *         -EIO if write has failed
   *         0 on success
   */
- int mei_wd_host_init(struct mei_device *dev)
+ int mei_wd_host_init(struct mei_device *dev, struct mei_me_client *me_cl)
  {
  	struct mei_cl *cl = &dev->wd_cl;
++<<<<<<< HEAD
 +	int id;
++=======
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  	int ret;
  
  	mei_cl_init(cl, dev);
@@@ -73,27 -66,15 +77,28 @@@
  	dev->wd_timeout = MEI_WD_DEFAULT_TIMEOUT;
  	dev->wd_state = MEI_WD_IDLE;
  
++<<<<<<< HEAD
 +
 +	/* check for valid client id */
 +	id = mei_me_cl_by_uuid(dev, &mei_wd_guid);
 +	if (id < 0) {
 +		dev_info(&dev->pdev->dev, "wd: failed to find the client\n");
 +		return -ENOTTY;
 +	}
 +
 +	cl->me_client_id = dev->me_clients[id].client_id;
 +
++=======
++>>>>>>> d49ed64a6e3f (mei: add a reference from the host client to the me client)
  	ret = mei_cl_link(cl, MEI_WD_HOST_CLIENT_ID);
- 
  	if (ret < 0) {
 -		dev_info(dev->dev, "wd: failed link client\n");
 +		dev_info(&dev->pdev->dev, "wd: failed link client\n");
  		return ret;
  	}
  
- 	ret = mei_cl_connect(cl, NULL);
- 
+ 	ret = mei_cl_connect(cl, me_cl, NULL);
  	if (ret) {
 -		dev_err(dev->dev, "wd: failed to connect = %d\n", ret);
 +		dev_err(&dev->pdev->dev, "wd: failed to connect = %d\n", ret);
  		mei_cl_unlink(cl);
  		return ret;
  	}
* Unmerged path drivers/misc/mei/amthif.c
* Unmerged path drivers/misc/mei/bus.c
* Unmerged path drivers/misc/mei/client.c
* Unmerged path drivers/misc/mei/client.h
* Unmerged path drivers/misc/mei/debugfs.c
diff --git a/drivers/misc/mei/hbm.c b/drivers/misc/mei/hbm.c
index 3cb8e1000d69..b7761a1b5a12 100644
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@ -153,7 +153,7 @@ void mei_hbm_cl_hdr(struct mei_cl *cl, u8 hbm_cmd, void *buf, size_t len)
 
 	cmd->hbm_cmd = hbm_cmd;
 	cmd->host_addr = cl->host_client_id;
-	cmd->me_addr = cl->me_client_id;
+	cmd->me_addr = mei_cl_me_id(cl);
 }
 
 /**
@@ -189,7 +189,7 @@ bool mei_hbm_cl_addr_equal(struct mei_cl *cl, void *buf)
 {
 	struct mei_hbm_cl_cmd *cmd = buf;
 	return cl->host_client_id == cmd->host_addr &&
-		cl->me_client_id == cmd->me_addr;
+		mei_cl_me_id(cl) == cmd->me_addr;
 }
 
 /**
diff --git a/drivers/misc/mei/interrupt.c b/drivers/misc/mei/interrupt.c
index b8d9cfee3e87..9b11c01f9017 100644
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@ -68,7 +68,7 @@ static inline int mei_cl_hbm_equal(struct mei_cl *cl,
 			struct mei_msg_hdr *mei_hdr)
 {
 	return cl->host_client_id == mei_hdr->host_addr &&
-		cl->me_client_id == mei_hdr->me_addr;
+		mei_cl_me_id(cl) == mei_hdr->me_addr;
 }
 /**
  * mei_cl_is_reading - checks if the client
@@ -187,6 +187,8 @@ static int mei_cl_irq_disconnect_rsp(struct mei_cl *cl, struct mei_cl_cb *cb,
 	cl->status = 0;
 	list_del(&cb->list);
 	mei_io_cb_free(cb);
+	mei_me_cl_put(cl->me_cl);
+	cl->me_cl = NULL;
 
 	return ret;
 }
* Unmerged path drivers/misc/mei/main.c
* Unmerged path drivers/misc/mei/mei_dev.h
* Unmerged path drivers/misc/mei/nfc.c
* Unmerged path drivers/misc/mei/wd.c
