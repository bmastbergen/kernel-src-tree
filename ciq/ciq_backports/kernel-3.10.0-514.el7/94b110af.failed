mmc: tmio: add tmio_mmc_host_alloc/free()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
commit 94b110aff8679b14f46fd6653ea87b42fe1555be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/94b110af.failed

Current tmio_mmc driver is using tmio_mmc_data for driver/platform
specific data/callback, and it is needed for tmio_mmc_host_probe()
function. Because of this style, include/linux/mfd/tmio.h header has
tmio driver/framework specific data which is not needed from platform.

This patch adds new tmio_mmc_host_alloc/free() as cleanup preparation.
tmio driver specific data/callback will be implemented in tmio_mmc_host,
and platform specific data/callback will be implemented in tmio_mmc_data
in this cleanup.

	Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
	Acked-by: Lee Jones <lee.jones@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 94b110aff8679b14f46fd6653ea87b42fe1555be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sh_mobile_sdhi.c
#	drivers/mmc/host/tmio_mmc.c
#	drivers/mmc/host/tmio_mmc_pio.c
diff --cc drivers/mmc/host/sh_mobile_sdhi.c
index 79ee6f0c45bd,cf062c4d87a9..000000000000
--- a/drivers/mmc/host/sh_mobile_sdhi.c
+++ b/drivers/mmc/host/sh_mobile_sdhi.c
@@@ -199,12 -257,41 +205,19 @@@ static int sh_mobile_sdhi_probe(struct 
  	if (of_id && of_id->data) {
  		const struct sh_mobile_sdhi_of_data *of_data = of_id->data;
  		mmc_data->flags |= of_data->tmio_flags;
 -		mmc_data->capabilities |= of_data->capabilities;
 -		mmc_data->capabilities2 |= of_data->capabilities2;
 -		dma_priv->dma_rx_offset = of_data->dma_rx_offset;
  	}
  
++<<<<<<< HEAD
 +	ret = tmio_mmc_host_probe(&host, pdev, mmc_data);
++=======
+ 	/* SD control register space size is 0x100, 0x200 for bus_shift=1 */
+ 	mmc_data->bus_shift = resource_size(res) >> 9;
+ 
+ 	ret = tmio_mmc_host_probe(host, mmc_data);
++>>>>>>> 94b110aff867 (mmc: tmio: add tmio_mmc_host_alloc/free())
  	if (ret < 0)
- 		goto eprobe;
+ 		goto efree;
  
 -	/*
 -	 * FIXME:
 -	 * this Workaround can be more clever method
 -	 */
 -	ver = sd_ctrl_read16(host, CTL_VERSION);
 -	if (ver == 0xCB0D)
 -		sd_ctrl_write16(host, EXT_ACC, 1);
 -
  	/*
  	 * Allow one or more specific (named) ISRs or
  	 * one or more multiplexed (un-named) ISRs.
diff --cc drivers/mmc/host/tmio_mmc.c
index 8860d4d2bc22,a7c2e459187c..000000000000
--- a/drivers/mmc/host/tmio_mmc.c
+++ b/drivers/mmc/host/tmio_mmc.c
@@@ -84,10 -84,22 +84,27 @@@ static int tmio_mmc_probe(struct platfo
  			goto out;
  	}
  
++<<<<<<< HEAD
 +	ret = tmio_mmc_host_probe(&host, pdev, pdata);
 +	if (ret)
++=======
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	if (!res)
+ 		return -EINVAL;
+ 
+ 	/* SD control register space size is 0x200, 0x400 for bus_shift=1 */
+ 	pdata->bus_shift = resource_size(res) >> 10;
+ 	pdata->flags |= TMIO_MMC_HAVE_HIGH_REG;
+ 
+ 	host = tmio_mmc_host_alloc(pdev);
+ 	if (!host)
++>>>>>>> 94b110aff867 (mmc: tmio: add tmio_mmc_host_alloc/free())
  		goto cell_disable;
  
+ 	ret = tmio_mmc_host_probe(host, pdata);
+ 	if (ret)
+ 		goto host_free;
+ 
  	ret = request_irq(irq, tmio_mmc_irq, IRQF_TRIGGER_FALLING,
  				dev_name(&pdev->dev), host);
  	if (ret)
diff --cc drivers/mmc/host/tmio_mmc_pio.c
index d5da81365223,396be0e95a98..000000000000
--- a/drivers/mmc/host/tmio_mmc_pio.c
+++ b/drivers/mmc/host/tmio_mmc_pio.c
@@@ -983,17 -1098,11 +1008,19 @@@ int tmio_mmc_host_probe(struct tmio_mmc
  	if (!res_ctl)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	mmc = mmc_alloc_host(sizeof(struct tmio_mmc_host), &pdev->dev);
 +	if (!mmc)
 +		return -ENOMEM;
 +
 +	mmc_of_parse(mmc);
++=======
+ 	ret = mmc_of_parse(mmc);
+ 	if (ret < 0)
+ 		goto host_free;
++>>>>>>> 94b110aff867 (mmc: tmio: add tmio_mmc_host_alloc/free())
  
- 	pdata->dev = &pdev->dev;
- 	_host = mmc_priv(mmc);
  	_host->pdata = pdata;
- 	_host->mmc = mmc;
- 	_host->pdev = pdev;
  	platform_set_drvdata(pdev, mmc);
  
  	_host->set_pwr = pdata->set_pwr;
@@@ -1095,17 -1206,12 +1122,14 @@@
  			tmio_mmc_host_remove(_host);
  			return ret;
  		}
 -		mmc_gpiod_request_cd_irq(mmc);
  	}
  
- 	*host = _host;
- 
  	return 0;
  
 +pm_disable:
 +	pm_runtime_disable(&pdev->dev);
 +	iounmap(_host->ctl);
  host_free:
- 	mmc_free_host(mmc);
  
  	return ret;
  }
* Unmerged path drivers/mmc/host/sh_mobile_sdhi.c
* Unmerged path drivers/mmc/host/tmio_mmc.c
diff --git a/drivers/mmc/host/tmio_mmc.h b/drivers/mmc/host/tmio_mmc.h
index d857f5c6e7d9..5bcbacd64be4 100644
--- a/drivers/mmc/host/tmio_mmc.h
+++ b/drivers/mmc/host/tmio_mmc.h
@@ -87,8 +87,9 @@ struct tmio_mmc_host {
 	bool			native_hotplug;
 };
 
-int tmio_mmc_host_probe(struct tmio_mmc_host **host,
-			struct platform_device *pdev,
+struct tmio_mmc_host *tmio_mmc_host_alloc(struct platform_device *pdev);
+void tmio_mmc_host_free(struct tmio_mmc_host *host);
+int tmio_mmc_host_probe(struct tmio_mmc_host *host,
 			struct tmio_mmc_data *pdata);
 void tmio_mmc_host_remove(struct tmio_mmc_host *host);
 void tmio_mmc_do_data_irq(struct tmio_mmc_host *host);
* Unmerged path drivers/mmc/host/tmio_mmc_pio.c
diff --git a/include/linux/mfd/tmio.h b/include/linux/mfd/tmio.h
index 38409958f913..c1d363780901 100644
--- a/include/linux/mfd/tmio.h
+++ b/include/linux/mfd/tmio.h
@@ -105,7 +105,6 @@ struct tmio_mmc_data {
 	unsigned long			flags;
 	u32				ocr_mask;	/* available voltages */
 	struct tmio_mmc_dma		*dma;
-	struct device			*dev;
 	unsigned int			cd_gpio;
 	void (*set_pwr)(struct platform_device *host, int state);
 	void (*set_clk_div)(struct platform_device *host, int state);
