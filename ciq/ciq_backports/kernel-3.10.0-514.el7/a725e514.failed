vxlan: metadata based tunneling for IPv6

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit a725e514dbb444f2a39c2bc5de72eb5efbeb7d5e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a725e514.failed

Support metadata based (formerly flow based) tunneling also for IPv6.
This complements commit ee122c79d422 ("vxlan: Flow based tunneling").

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Acked-by: Alexei Starovoitov <ast@plumgrid.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a725e514dbb444f2a39c2bc5de72eb5efbeb7d5e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 0e7b16ce629b,54615bb9d916..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1200,6 -1268,42 +1200,45 @@@ static int vxlan_udp_encap_recv(struct 
  		vni &= VXLAN_VNI_MASK;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (vxlan_collect_metadata(vs)) {
+ 		tun_dst = metadata_dst_alloc(sizeof(*md), GFP_ATOMIC);
+ 		if (!tun_dst)
+ 			goto drop;
+ 
+ 		info = &tun_dst->u.tun_info;
+ 		if (vxlan_get_sk_family(vs) == AF_INET) {
+ 			const struct iphdr *iph = ip_hdr(skb);
+ 
+ 			info->key.u.ipv4.src = iph->saddr;
+ 			info->key.u.ipv4.dst = iph->daddr;
+ 			info->key.tos = iph->tos;
+ 			info->key.ttl = iph->ttl;
+ 		} else {
+ 			const struct ipv6hdr *ip6h = ipv6_hdr(skb);
+ 
+ 			info->key.u.ipv6.src = ip6h->saddr;
+ 			info->key.u.ipv6.dst = ip6h->daddr;
+ 			info->key.tos = ipv6_get_dsfield(ip6h);
+ 			info->key.ttl = ip6h->hop_limit;
+ 		}
+ 
+ 		info->key.tp_src = udp_hdr(skb)->source;
+ 		info->key.tp_dst = udp_hdr(skb)->dest;
+ 
+ 		info->mode = IP_TUNNEL_INFO_RX;
+ 		info->key.tun_flags = TUNNEL_KEY;
+ 		info->key.tun_id = cpu_to_be64(vni >> 8);
+ 		if (udp_hdr(skb)->check != 0)
+ 			info->key.tun_flags |= TUNNEL_CSUM;
+ 
+ 		md = ip_tunnel_info_opts(info, sizeof(*md));
+ 	} else {
+ 		memset(md, 0, sizeof(*md));
+ 	}
+ 
++>>>>>>> a725e514dbb4 (vxlan: metadata based tunneling for IPv6)
  	/* For backwards compatibility, only allow reserved fields to be
  	 * used by VXLAN extensions if explicitly requested.
  	 */
@@@ -1876,8 -1901,10 +1915,9 @@@ static void vxlan_encap_bypass(struct s
  static void vxlan_xmit_one(struct sk_buff *skb, struct net_device *dev,
  			   struct vxlan_rdst *rdst, bool did_rsc)
  {
 -	struct ip_tunnel_info *info;
  	struct vxlan_dev *vxlan = netdev_priv(dev);
  	struct sock *sk = vxlan->vn_sock->sock->sk;
+ 	unsigned short family = vxlan_get_sk_family(vxlan->vn_sock);
  	struct rtable *rt = NULL;
  	const struct iphdr *old_iph;
  	struct flowi4 fl4;
@@@ -1888,10 -1917,30 +1928,35 @@@
  	__be16 df = 0;
  	__u8 tos, ttl;
  	int err;
 -	u32 flags = vxlan->flags;
  
++<<<<<<< HEAD
 +	dst_port = rdst->remote_port ? rdst->remote_port : vxlan->dst_port;
 +	vni = rdst->remote_vni;
 +	dst = &rdst->remote_ip;
++=======
+ 	info = skb_tunnel_info(skb);
+ 
+ 	if (rdst) {
+ 		dst_port = rdst->remote_port ? rdst->remote_port : vxlan->cfg.dst_port;
+ 		vni = rdst->remote_vni;
+ 		dst = &rdst->remote_ip;
+ 	} else {
+ 		if (!info) {
+ 			WARN_ONCE(1, "%s: Missing encapsulation instructions\n",
+ 				  dev->name);
+ 			goto drop;
+ 		}
+ 
+ 		dst_port = info->key.tp_dst ? : vxlan->cfg.dst_port;
+ 		vni = be64_to_cpu(info->key.tun_id);
+ 		remote_ip.sa.sa_family = family;
+ 		if (family == AF_INET)
+ 			remote_ip.sin.sin_addr.s_addr = info->key.u.ipv4.dst;
+ 		else
+ 			remote_ip.sin6.sin6_addr = info->key.u.ipv6.dst;
+ 		dst = &remote_ip;
+ 	}
++>>>>>>> a725e514dbb4 (vxlan: metadata based tunneling for IPv6)
  
  	if (vxlan_addr_any(dst)) {
  		if (did_rsc) {
@@@ -1912,12 -1961,30 +1977,33 @@@
  	if (tos == 1)
  		tos = ip_tunnel_get_dsfield(old_iph, skb);
  
 -	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
 -				     vxlan->cfg.port_max, true);
 +	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->port_min,
 +				     vxlan->port_max, true);
  
+ 	if (info) {
+ 		if (info->key.tun_flags & TUNNEL_CSUM)
+ 			flags |= VXLAN_F_UDP_CSUM;
+ 		else
+ 			flags &= ~VXLAN_F_UDP_CSUM;
+ 
+ 		ttl = info->key.ttl;
+ 		tos = info->key.tos;
+ 
+ 		if (info->options_len)
+ 			md = ip_tunnel_info_opts(info, sizeof(*md));
+ 	} else {
+ 		md->gbp = skb->mark;
+ 	}
+ 
  	if (dst->sa.sa_family == AF_INET) {
++<<<<<<< HEAD
++=======
+ 		if (info && (info->key.tun_flags & TUNNEL_DONT_FRAGMENT))
+ 			df = htons(IP_DF);
+ 
++>>>>>>> a725e514dbb4 (vxlan: metadata based tunneling for IPv6)
  		memset(&fl4, 0, sizeof(fl4));
 -		fl4.flowi4_oif = rdst ? rdst->remote_ifindex : 0;
 +		fl4.flowi4_oif = rdst->remote_ifindex;
  		fl4.flowi4_tos = RT_TOS(tos);
  		fl4.flowi4_mark = skb->mark;
  		fl4.flowi4_proto = IPPROTO_UDP;
@@@ -2016,13 -2080,10 +2102,16 @@@
  		}
  
  		ttl = ttl ? : ip6_dst_hoplimit(ndst);
++<<<<<<< HEAD
 +		md.vni = htonl(vni << 8);
 +		md.gbp = skb->mark;
 +
++=======
++>>>>>>> a725e514dbb4 (vxlan: metadata based tunneling for IPv6)
  		err = vxlan6_xmit_skb(ndst, sk, skb, dev, &fl6.saddr, &fl6.daddr,
 -				      0, ttl, src_port, dst_port, htonl(vni << 8), md,
 +				      0, ttl, src_port, dst_port, &md,
  				      !net_eq(vxlan->net, dev_net(vxlan->dev)),
- 				      vxlan->flags);
+ 				      flags);
  #endif
  	}
  
@@@ -2054,6 -2116,8 +2143,11 @@@ static netdev_tx_t vxlan_xmit(struct sk
  	struct vxlan_rdst *rdst, *fdst = NULL;
  	struct vxlan_fdb *f;
  
++<<<<<<< HEAD
++=======
+ 	info = skb_tunnel_info(skb);
+ 
++>>>>>>> a725e514dbb4 (vxlan: metadata based tunneling for IPv6)
  	skb_reset_mac_header(skb);
  	eth = eth_hdr(skb);
  
* Unmerged path drivers/net/vxlan.c
