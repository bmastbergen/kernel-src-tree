netfilter: bridge: move nf_bridge_update_protocol to where its used

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Florian Westphal <fw@strlen.de>
commit 4a9d2f200862683d6680d5565f30c126625afe65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4a9d2f20.failed

no need to keep it in a header file.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 4a9d2f200862683d6680d5565f30c126625afe65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter_bridge.h
diff --cc include/linux/netfilter_bridge.h
index 754600083b7e,dd580a9a1add..000000000000
--- a/include/linux/netfilter_bridge.h
+++ b/include/linux/netfilter_bridge.h
@@@ -36,44 -36,6 +36,47 @@@ static inline unsigned int nf_bridge_en
  	}
  }
  
++<<<<<<< HEAD
 +static inline void nf_bridge_update_protocol(struct sk_buff *skb)
 +{
 +	if (skb->nf_bridge->mask & BRNF_8021Q)
 +		skb->protocol = htons(ETH_P_8021Q);
 +	else if (skb->nf_bridge->mask & BRNF_PPPoE)
 +		skb->protocol = htons(ETH_P_PPP_SES);
 +}
 +
 +/* Fill in the header for fragmented IP packets handled by
 + * the IPv4 connection tracking code.
 + *
 + * Only used in br_forward.c
 + */
 +static inline int nf_bridge_copy_header(struct sk_buff *skb)
 +{
 +	int err;
 +	unsigned int header_size;
 +
 +	nf_bridge_update_protocol(skb);
 +	header_size = ETH_HLEN + nf_bridge_encap_header_len(skb);
 +	err = skb_cow_head(skb, header_size);
 +	if (err)
 +		return err;
 +
 +	skb_copy_to_linear_data_offset(skb, -header_size,
 +				       skb->nf_bridge->data, header_size);
 +	__skb_push(skb, nf_bridge_encap_header_len(skb));
 +	return 0;
 +}
 +
 +static inline int nf_bridge_maybe_copy_header(struct sk_buff *skb)
 +{
 +	if (skb->nf_bridge &&
 +	    skb->nf_bridge->mask & (BRNF_BRIDGED | BRNF_BRIDGED_DNAT))
 +		return nf_bridge_copy_header(skb);
 +  	return 0;
 +}
 +
++=======
++>>>>>>> 4a9d2f200862 (netfilter: bridge: move nf_bridge_update_protocol to where its used)
  static inline unsigned int nf_bridge_mtu_reduction(const struct sk_buff *skb)
  {
  	if (unlikely(skb->nf_bridge->mask & BRNF_PPPoE))
* Unmerged path include/linux/netfilter_bridge.h
diff --git a/net/bridge/br_netfilter.c b/net/bridge/br_netfilter.c
index d354bf857875..27f3047164ad 100644
--- a/net/bridge/br_netfilter.c
+++ b/net/bridge/br_netfilter.c
@@ -298,6 +298,14 @@ drop:
 	return -1;
 }
 
+static void nf_bridge_update_protocol(struct sk_buff *skb)
+{
+	if (skb->nf_bridge->mask & BRNF_8021Q)
+		skb->protocol = htons(ETH_P_8021Q);
+	else if (skb->nf_bridge->mask & BRNF_PPPoE)
+		skb->protocol = htons(ETH_P_PPP_SES);
+}
+
 /* PF_BRIDGE/PRE_ROUTING *********************************************/
 /* Undo the changes made for ip6tables PREROUTING and continue the
  * bridge PRE_ROUTING hook. */
