lib: move strtobool() to kstrtobool()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Kees Cook <keescook@chromium.org>
commit ef951599074ba4fad2d0efa0a977129b41e6d203
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ef951599.failed

Create the kstrtobool_from_user() helper and move strtobool() logic into
the new kstrtobool() (matching all the other kstrto* functions).
Provides an inline wrapper for existing strtobool() callers.

	Signed-off-by: Kees Cook <keescook@chromium.org>
	Cc: Joe Perches <joe@perches.com>
	Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
	Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
	Cc: Daniel Borkmann <daniel@iogearbox.net>
	Cc: Amitkumar Karwar <akarwar@marvell.com>
	Cc: Nishant Sarmukadam <nishants@marvell.com>
	Cc: Kalle Valo <kvalo@codeaurora.org>
	Cc: Steve French <sfrench@samba.org>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ef951599074ba4fad2d0efa0a977129b41e6d203)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/string.c
diff --cc lib/string.c
index 28cb2d15ceea,ed83562a53ae..000000000000
--- a/lib/string.c
+++ b/lib/string.c
@@@ -556,33 -631,30 +556,60 @@@ bool sysfs_streq(const char *s1, const 
  EXPORT_SYMBOL(sysfs_streq);
  
  /**
++<<<<<<< HEAD
 + * strtobool - convert common user inputs into boolean values
 + * @s: input string
 + * @res: result
 + *
 + * This routine returns 0 iff the first character is one of 'Yy1Nn0'.
 + * Otherwise it will return -EINVAL.  Value pointed to by res is
 + * updated upon finding a match.
 + */
 +int strtobool(const char *s, bool *res)
 +{
 +	switch (s[0]) {
 +	case 'y':
 +	case 'Y':
 +	case '1':
 +		*res = true;
 +		break;
 +	case 'n':
 +	case 'N':
 +	case '0':
 +		*res = false;
 +		break;
 +	default:
 +		return -EINVAL;
 +	}
 +	return 0;
 +}
 +EXPORT_SYMBOL(strtobool);
++=======
+  * match_string - matches given string in an array
+  * @array:	array of strings
+  * @n:		number of strings in the array or -1 for NULL terminated arrays
+  * @string:	string to match with
+  *
+  * Return:
+  * index of a @string in the @array if matches, or %-EINVAL otherwise.
+  */
+ int match_string(const char * const *array, size_t n, const char *string)
+ {
+ 	int index;
+ 	const char *item;
+ 
+ 	for (index = 0; index < n; index++) {
+ 		item = array[index];
+ 		if (!item)
+ 			break;
+ 		if (!strcmp(item, string))
+ 			return index;
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ EXPORT_SYMBOL(match_string);
++>>>>>>> ef951599074b (lib: move strtobool() to kstrtobool())
  
  #ifndef __HAVE_ARCH_MEMSET
  /**
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 016971f1b4da..9c06021a99cb 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -352,6 +352,7 @@ int __must_check kstrtou16(const char *s, unsigned int base, u16 *res);
 int __must_check kstrtos16(const char *s, unsigned int base, s16 *res);
 int __must_check kstrtou8(const char *s, unsigned int base, u8 *res);
 int __must_check kstrtos8(const char *s, unsigned int base, s8 *res);
+int __must_check kstrtobool(const char *s, bool *res);
 
 int __must_check kstrtoull_from_user(const char __user *s, size_t count, unsigned int base, unsigned long long *res);
 int __must_check kstrtoll_from_user(const char __user *s, size_t count, unsigned int base, long long *res);
@@ -363,6 +364,7 @@ int __must_check kstrtou16_from_user(const char __user *s, size_t count, unsigne
 int __must_check kstrtos16_from_user(const char __user *s, size_t count, unsigned int base, s16 *res);
 int __must_check kstrtou8_from_user(const char __user *s, size_t count, unsigned int base, u8 *res);
 int __must_check kstrtos8_from_user(const char __user *s, size_t count, unsigned int base, s8 *res);
+int __must_check kstrtobool_from_user(const char __user *s, size_t count, bool *res);
 
 static inline int __must_check kstrtou64_from_user(const char __user *s, size_t count, unsigned int base, u64 *res)
 {
diff --git a/include/linux/string.h b/include/linux/string.h
index 3b42b3732da6..cad4e02550ac 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -123,7 +123,11 @@ extern char **argv_split(gfp_t gfp, const char *str, int *argcp);
 extern void argv_free(char **argv);
 
 extern bool sysfs_streq(const char *s1, const char *s2);
-extern int strtobool(const char *s, bool *res);
+extern int kstrtobool(const char *s, bool *res);
+static inline int strtobool(const char *s, bool *res)
+{
+	return kstrtobool(s, res);
+}
 
 #ifdef CONFIG_BINARY_PRINTF
 int vbin_printf(u32 *bin_buf, size_t size, const char *fmt, va_list args);
diff --git a/lib/kstrtox.c b/lib/kstrtox.c
index f78ae0c0c4e2..bb7b85b18992 100644
--- a/lib/kstrtox.c
+++ b/lib/kstrtox.c
@@ -322,6 +322,56 @@ int kstrtos8(const char *s, unsigned int base, s8 *res)
 }
 EXPORT_SYMBOL(kstrtos8);
 
+/**
+ * kstrtobool - convert common user inputs into boolean values
+ * @s: input string
+ * @res: result
+ *
+ * This routine returns 0 iff the first character is one of 'Yy1Nn0'.
+ * Otherwise it will return -EINVAL.  Value pointed to by res is
+ * updated upon finding a match.
+ */
+int kstrtobool(const char *s, bool *res)
+{
+	if (!s)
+		return -EINVAL;
+
+	switch (s[0]) {
+	case 'y':
+	case 'Y':
+	case '1':
+		*res = true;
+		return 0;
+	case 'n':
+	case 'N':
+	case '0':
+		*res = false;
+		return 0;
+	default:
+		break;
+	}
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL(kstrtobool);
+
+/*
+ * Since "base" would be a nonsense argument, this open-codes the
+ * _from_user helper instead of using the helper macro below.
+ */
+int kstrtobool_from_user(const char __user *s, size_t count, bool *res)
+{
+	/* Longest string needed to differentiate, newline, terminator */
+	char buf[4];
+
+	count = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, s, count))
+		return -EFAULT;
+	buf[count] = '\0';
+	return kstrtobool(buf, res);
+}
+EXPORT_SYMBOL(kstrtobool_from_user);
+
 #define kstrto_from_user(f, g, type)					\
 int f(const char __user *s, size_t count, unsigned int base, type *res)	\
 {									\
* Unmerged path lib/string.c
