sunrpc: add new tracepoints in xprt handling code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jeff Layton <jlayton@primarydata.com>
commit 3705ad64f123271b2b88dbff0c9891b7b90299d2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3705ad64.failed

...so we can keep track of when calls are sent and replies received.

	Signed-off-by: Jeff Layton <jlayton@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 3705ad64f123271b2b88dbff0c9891b7b90299d2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/trace/events/sunrpc.h
diff --cc include/trace/events/sunrpc.h
index 1fef3e6e9436,5edb16bcd836..000000000000
--- a/include/trace/events/sunrpc.h
+++ b/include/trace/events/sunrpc.h
@@@ -306,6 -307,123 +306,126 @@@ DEFINE_RPC_SOCKET_EVENT_DONE(rpc_socket
  DEFINE_RPC_SOCKET_EVENT(rpc_socket_close);
  DEFINE_RPC_SOCKET_EVENT(rpc_socket_shutdown);
  
++<<<<<<< HEAD
++=======
+ DECLARE_EVENT_CLASS(rpc_xprt_event,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 
+ 	TP_ARGS(xprt, xid, status),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(__be32, xid)
+ 		__field(int, status)
+ 		__string(addr, xprt->address_strings[RPC_DISPLAY_ADDR])
+ 		__string(port, xprt->address_strings[RPC_DISPLAY_PORT])
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->xid = xid;
+ 		__entry->status = status;
+ 		__assign_str(addr, xprt->address_strings[RPC_DISPLAY_ADDR]);
+ 		__assign_str(port, xprt->address_strings[RPC_DISPLAY_PORT]);
+ 	),
+ 
+ 	TP_printk("peer=%s/%s xid=0x%x status=%d", __get_str(addr),
+ 			__get_str(port), be32_to_cpu(__entry->xid),
+ 			__entry->status)
+ );
+ 
+ DEFINE_EVENT(rpc_xprt_event, xprt_lookup_rqst,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 	TP_ARGS(xprt, xid, status));
+ 
+ DEFINE_EVENT(rpc_xprt_event, xprt_transmit,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 	TP_ARGS(xprt, xid, status));
+ 
+ DEFINE_EVENT(rpc_xprt_event, xprt_complete_rqst,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 	TP_ARGS(xprt, xid, status));
+ 
+ TRACE_EVENT(xs_tcp_data_ready,
+ 	TP_PROTO(struct rpc_xprt *xprt, int err, unsigned int total),
+ 
+ 	TP_ARGS(xprt, err, total),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, err)
+ 		__field(unsigned int, total)
+ 		__string(addr, xprt ? xprt->address_strings[RPC_DISPLAY_ADDR] :
+ 				"(null)")
+ 		__string(port, xprt ? xprt->address_strings[RPC_DISPLAY_PORT] :
+ 				"(null)")
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->err = err;
+ 		__entry->total = total;
+ 		__assign_str(addr, xprt ?
+ 			xprt->address_strings[RPC_DISPLAY_ADDR] : "(null)");
+ 		__assign_str(port, xprt ?
+ 			xprt->address_strings[RPC_DISPLAY_PORT] : "(null)");
+ 	),
+ 
+ 	TP_printk("peer=[%s]:%s err=%d total=%u", __get_str(addr),
+ 			__get_str(port), __entry->err, __entry->total)
+ );
+ 
+ TRACE_EVENT(svc_recv,
+ 	TP_PROTO(struct svc_rqst *rqst, int status),
+ 
+ 	TP_ARGS(rqst, status),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(struct sockaddr *, addr)
+ 		__field(__be32, xid)
+ 		__field(int, status)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->addr = (struct sockaddr *)&rqst->rq_addr;
+ 		__entry->xid = status > 0 ? rqst->rq_xid : 0;
+ 		__entry->status = status;
+ 	),
+ 
+ 	TP_printk("addr=%pIScp xid=0x%x status=%d", __entry->addr,
+ 			be32_to_cpu(__entry->xid), __entry->status)
+ );
+ 
+ DECLARE_EVENT_CLASS(svc_rqst_status,
+ 
+ 	TP_PROTO(struct svc_rqst *rqst, int status),
+ 
+ 	TP_ARGS(rqst, status),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(struct sockaddr *, addr)
+ 		__field(__be32, xid)
+ 		__field(int, dropme)
+ 		__field(int, status)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->addr = (struct sockaddr *)&rqst->rq_addr;
+ 		__entry->xid = rqst->rq_xid;
+ 		__entry->dropme = (int)rqst->rq_dropme;
+ 		__entry->status = status;
+ 	),
+ 
+ 	TP_printk("addr=%pIScp rq_xid=0x%x dropme=%d status=%d",
+ 		__entry->addr, be32_to_cpu(__entry->xid), __entry->dropme,
+ 		__entry->status)
+ );
+ 
+ DEFINE_EVENT(svc_rqst_status, svc_process,
+ 	TP_PROTO(struct svc_rqst *rqst, int status),
+ 	TP_ARGS(rqst, status));
+ 
+ DEFINE_EVENT(svc_rqst_status, svc_send,
+ 	TP_PROTO(struct svc_rqst *rqst, int status),
+ 	TP_ARGS(rqst, status));
+ 
++>>>>>>> 3705ad64f123 (sunrpc: add new tracepoints in xprt handling code)
  #endif /* _TRACE_SUNRPC_H */
  
  #include <trace/define_trace.h>
* Unmerged path include/trace/events/sunrpc.h
diff --git a/net/sunrpc/xprt.c b/net/sunrpc/xprt.c
index cca0b403cca1..47da4c3ed8b7 100644
--- a/net/sunrpc/xprt.c
+++ b/net/sunrpc/xprt.c
@@ -49,6 +49,8 @@
 #include <linux/sunrpc/metrics.h>
 #include <linux/sunrpc/bc_xprt.h>
 
+#include <trace/events/sunrpc.h>
+
 #include "sunrpc.h"
 
 /*
@@ -801,11 +803,14 @@ struct rpc_rqst *xprt_lookup_rqst(struct rpc_xprt *xprt, __be32 xid)
 	struct rpc_rqst *entry;
 
 	list_for_each_entry(entry, &xprt->recv, rq_list)
-		if (entry->rq_xid == xid)
+		if (entry->rq_xid == xid) {
+			trace_xprt_lookup_rqst(xprt, xid, 0);
 			return entry;
+		}
 
 	dprintk("RPC:       xprt_lookup_rqst did not find xid %08x\n",
 			ntohl(xid));
+	trace_xprt_lookup_rqst(xprt, xid, -ENOENT);
 	xprt->stat.bad_xids++;
 	return NULL;
 }
@@ -839,6 +844,7 @@ void xprt_complete_rqst(struct rpc_task *task, int copied)
 
 	dprintk("RPC: %5u xid %08x complete (%d bytes received)\n",
 			task->tk_pid, ntohl(req->rq_xid), copied);
+	trace_xprt_complete_rqst(xprt, req->rq_xid, copied);
 
 	xprt->stat.recvs++;
 	req->rq_rtt = ktime_sub(ktime_get(), req->rq_xtime);
@@ -955,6 +961,7 @@ void xprt_transmit(struct rpc_task *task)
 
 	req->rq_xtime = ktime_get();
 	status = xprt->ops->send_request(task);
+	trace_xprt_transmit(xprt, req->rq_xid, status);
 	if (status != 0) {
 		task->tk_status = status;
 		return;
diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c
index 28893e435064..f159bec2db3b 100644
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@ -1445,12 +1445,15 @@ static void xs_tcp_data_ready(struct sock *sk, int bytes)
 	struct rpc_xprt *xprt;
 	read_descriptor_t rd_desc;
 	int read;
+	unsigned long total = 0;
 
 	dprintk("RPC:       xs_tcp_data_ready...\n");
 
 	read_lock_bh(&sk->sk_callback_lock);
-	if (!(xprt = xprt_from_sock(sk)))
+	if (!(xprt = xprt_from_sock(sk))) {
+		read = 0;
 		goto out;
+	}
 	/* Any data means we had a useful conversation, so
 	 * the we don't need to delay the next reconnect
 	 */
@@ -1462,8 +1465,11 @@ static void xs_tcp_data_ready(struct sock *sk, int bytes)
 	do {
 		rd_desc.count = 65536;
 		read = tcp_read_sock(sk, &rd_desc, xs_tcp_data_recv);
+		if (read > 0)
+			total += read;
 	} while (read > 0);
 out:
+	trace_xs_tcp_data_ready(xprt, read, total);
 	read_unlock_bh(&sk->sk_callback_lock);
 }
 
