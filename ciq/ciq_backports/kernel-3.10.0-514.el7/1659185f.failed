RDS: IB: Support Fastreg MR (FRMR) memory registration mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Avinash Repaka <avinash.repaka@oracle.com>
commit 1659185fb4d0025835eb2058a141f0746c5cab00
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1659185f.failed

Fastreg MR(FRMR) is another method with which one can
register memory to HCA. Some of the newer HCAs supports only fastreg
mr mode, so we need to add support for it to have RDS functional
on them.

	Signed-off-by: Santosh Shilimkar <ssantosh@kernel.org>
	Signed-off-by: Avinash Repaka <avinash.repaka@oracle.com>
	Signed-off-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1659185fb4d0025835eb2058a141f0746c5cab00)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rds/Makefile
#	net/rds/ib.h
#	net/rds/ib_cm.c
#	net/rds/ib_mr.h
#	net/rds/ib_rdma.c
diff --cc net/rds/Makefile
index 56d3f6023ced,0e72bec1529f..000000000000
--- a/net/rds/Makefile
+++ b/net/rds/Makefile
@@@ -6,9 -6,7 +6,13 @@@ rds-y :=	af_rds.o bind.o cong.o connect
  obj-$(CONFIG_RDS_RDMA) += rds_rdma.o
  rds_rdma-y :=	rdma_transport.o \
  			ib.o ib_cm.o ib_recv.o ib_ring.o ib_send.o ib_stats.o \
++<<<<<<< HEAD
 +			ib_sysctl.o ib_rdma.o \
 +			iw.o iw_cm.o iw_recv.o iw_ring.o iw_send.o iw_stats.o \
 +			iw_sysctl.o iw_rdma.o
++=======
+ 			ib_sysctl.o ib_rdma.o ib_fmr.o ib_frmr.o
++>>>>>>> 1659185fb4d0 (RDS: IB: Support Fastreg MR (FRMR) memory registration mode)
  
  
  obj-$(CONFIG_RDS_TCP) += rds_tcp.o
diff --cc net/rds/ib.h
index 1c9525b4fdbb,627fb79aee65..000000000000
--- a/net/rds/ib.h
+++ b/net/rds/ib.h
@@@ -324,17 -349,7 +324,21 @@@ int rds_ib_update_ipaddr(struct rds_ib_
  void rds_ib_add_conn(struct rds_ib_device *rds_ibdev, struct rds_connection *conn);
  void rds_ib_remove_conn(struct rds_ib_device *rds_ibdev, struct rds_connection *conn);
  void rds_ib_destroy_nodev_conns(void);
++<<<<<<< HEAD
 +struct rds_ib_mr_pool *rds_ib_create_mr_pool(struct rds_ib_device *rds_dev,
 +					     int npages);
 +void rds_ib_get_mr_info(struct rds_ib_device *rds_ibdev, struct rds_info_rdma_connection *iinfo);
 +void rds_ib_destroy_mr_pool(struct rds_ib_mr_pool *);
 +void *rds_ib_get_mr(struct scatterlist *sg, unsigned long nents,
 +		    struct rds_sock *rs, u32 *key_ret);
 +void rds_ib_sync_mr(void *trans_private, int dir);
 +void rds_ib_free_mr(void *trans_private, int invalidate);
 +void rds_ib_flush_mrs(void);
 +int rds_ib_fmr_init(void);
 +void rds_ib_fmr_exit(void);
++=======
+ void rds_ib_mr_cqe_handler(struct rds_ib_connection *ic, struct ib_wc *wc);
++>>>>>>> 1659185fb4d0 (RDS: IB: Support Fastreg MR (FRMR) memory registration mode)
  
  /* ib_recv.c */
  int rds_ib_recv_init(void);
diff --cc net/rds/ib_cm.c
index c129638ff6f1,8764970f0c24..000000000000
--- a/net/rds/ib_cm.c
+++ b/net/rds/ib_cm.c
@@@ -207,6 -216,113 +207,116 @@@ static void rds_ib_cq_event_handler(str
  		 event->event, ib_event_msg(event->event), data);
  }
  
++<<<<<<< HEAD
++=======
+ /* Plucking the oldest entry from the ring can be done concurrently with
+  * the thread refilling the ring.  Each ring operation is protected by
+  * spinlocks and the transient state of refilling doesn't change the
+  * recording of which entry is oldest.
+  *
+  * This relies on IB only calling one cq comp_handler for each cq so that
+  * there will only be one caller of rds_recv_incoming() per RDS connection.
+  */
+ static void rds_ib_cq_comp_handler_recv(struct ib_cq *cq, void *context)
+ {
+ 	struct rds_connection *conn = context;
+ 	struct rds_ib_connection *ic = conn->c_transport_data;
+ 
+ 	rdsdebug("conn %p cq %p\n", conn, cq);
+ 
+ 	rds_ib_stats_inc(s_ib_evt_handler_call);
+ 
+ 	tasklet_schedule(&ic->i_recv_tasklet);
+ }
+ 
+ static void poll_scq(struct rds_ib_connection *ic, struct ib_cq *cq,
+ 		     struct ib_wc *wcs)
+ {
+ 	int nr, i;
+ 	struct ib_wc *wc;
+ 
+ 	while ((nr = ib_poll_cq(cq, RDS_IB_WC_MAX, wcs)) > 0) {
+ 		for (i = 0; i < nr; i++) {
+ 			wc = wcs + i;
+ 			rdsdebug("wc wr_id 0x%llx status %u byte_len %u imm_data %u\n",
+ 				 (unsigned long long)wc->wr_id, wc->status,
+ 				 wc->byte_len, be32_to_cpu(wc->ex.imm_data));
+ 
+ 			if (wc->wr_id <= ic->i_send_ring.w_nr ||
+ 			    wc->wr_id == RDS_IB_ACK_WR_ID)
+ 				rds_ib_send_cqe_handler(ic, wc);
+ 			else
+ 				rds_ib_mr_cqe_handler(ic, wc);
+ 
+ 		}
+ 	}
+ }
+ 
+ static void rds_ib_tasklet_fn_send(unsigned long data)
+ {
+ 	struct rds_ib_connection *ic = (struct rds_ib_connection *)data;
+ 	struct rds_connection *conn = ic->conn;
+ 
+ 	rds_ib_stats_inc(s_ib_tasklet_call);
+ 
+ 	poll_scq(ic, ic->i_send_cq, ic->i_send_wc);
+ 	ib_req_notify_cq(ic->i_send_cq, IB_CQ_NEXT_COMP);
+ 	poll_scq(ic, ic->i_send_cq, ic->i_send_wc);
+ 
+ 	if (rds_conn_up(conn) &&
+ 	    (!test_bit(RDS_LL_SEND_FULL, &conn->c_flags) ||
+ 	    test_bit(0, &conn->c_map_queued)))
+ 		rds_send_xmit(ic->conn);
+ }
+ 
+ static void poll_rcq(struct rds_ib_connection *ic, struct ib_cq *cq,
+ 		     struct ib_wc *wcs,
+ 		     struct rds_ib_ack_state *ack_state)
+ {
+ 	int nr, i;
+ 	struct ib_wc *wc;
+ 
+ 	while ((nr = ib_poll_cq(cq, RDS_IB_WC_MAX, wcs)) > 0) {
+ 		for (i = 0; i < nr; i++) {
+ 			wc = wcs + i;
+ 			rdsdebug("wc wr_id 0x%llx status %u byte_len %u imm_data %u\n",
+ 				 (unsigned long long)wc->wr_id, wc->status,
+ 				 wc->byte_len, be32_to_cpu(wc->ex.imm_data));
+ 
+ 			rds_ib_recv_cqe_handler(ic, wc, ack_state);
+ 		}
+ 	}
+ }
+ 
+ static void rds_ib_tasklet_fn_recv(unsigned long data)
+ {
+ 	struct rds_ib_connection *ic = (struct rds_ib_connection *)data;
+ 	struct rds_connection *conn = ic->conn;
+ 	struct rds_ib_device *rds_ibdev = ic->rds_ibdev;
+ 	struct rds_ib_ack_state state;
+ 
+ 	if (!rds_ibdev)
+ 		rds_conn_drop(conn);
+ 
+ 	rds_ib_stats_inc(s_ib_tasklet_call);
+ 
+ 	memset(&state, 0, sizeof(state));
+ 	poll_rcq(ic, ic->i_recv_cq, ic->i_recv_wc, &state);
+ 	ib_req_notify_cq(ic->i_recv_cq, IB_CQ_SOLICITED);
+ 	poll_rcq(ic, ic->i_recv_cq, ic->i_recv_wc, &state);
+ 
+ 	if (state.ack_next_valid)
+ 		rds_ib_set_ack(ic, state.ack_next, state.ack_required);
+ 	if (state.ack_recv_valid && state.ack_recv > ic->i_ack_recv) {
+ 		rds_send_drop_acked(conn, state.ack_recv, NULL);
+ 		ic->i_ack_recv = state.ack_recv;
+ 	}
+ 
+ 	if (rds_conn_up(conn))
+ 		rds_ib_attempt_ack(ic);
+ }
+ 
++>>>>>>> 1659185fb4d0 (RDS: IB: Support Fastreg MR (FRMR) memory registration mode)
  static void rds_ib_qp_event_handler(struct ib_event *event, void *data)
  {
  	struct rds_connection *conn = data;
diff --cc net/rds/ib_rdma.c
index d3708de2e114,f7164ac1ffc1..000000000000
--- a/net/rds/ib_rdma.c
+++ b/net/rds/ib_rdma.c
@@@ -692,30 -397,10 +692,37 @@@ static int rds_ib_flush_mr_pool(struct 
  	if (list_empty(&unmap_list))
  		goto out;
  
++<<<<<<< HEAD
 +	/* String all ib_mr's onto one list and hand them to ib_unmap_fmr */
 +	list_for_each_entry(ibmr, &unmap_list, unmap_list)
 +		list_add(&ibmr->fmr->list, &fmr_list);
 +
 +	ret = ib_unmap_fmr(&fmr_list);
 +	if (ret)
 +		printk(KERN_WARNING "RDS/IB: ib_unmap_fmr failed (err=%d)\n", ret);
 +
 +	/* Now we can destroy the DMA mapping and unpin any pages */
 +	list_for_each_entry_safe(ibmr, next, &unmap_list, unmap_list) {
 +		unpinned += ibmr->sg_len;
 +		__rds_ib_teardown_mr(ibmr);
 +		if (nfreed < free_goal ||
 +		    ibmr->remap_count >= pool->fmr_attr.max_maps) {
 +			if (ibmr->pool->pool_type == RDS_IB_MR_8K_POOL)
 +				rds_ib_stats_inc(s_ib_rdma_mr_8k_free);
 +			else
 +				rds_ib_stats_inc(s_ib_rdma_mr_1m_free);
 +			list_del(&ibmr->unmap_list);
 +			ib_dealloc_fmr(ibmr->fmr);
 +			kfree(ibmr);
 +			nfreed++;
 +		}
 +	}
++=======
+ 	if (pool->use_fastreg)
+ 		rds_ib_unreg_frmr(&unmap_list, &nfreed, &unpinned, free_goal);
+ 	else
+ 		rds_ib_unreg_fmr(&unmap_list, &nfreed, &unpinned, free_goal);
++>>>>>>> 1659185fb4d0 (RDS: IB: Support Fastreg MR (FRMR) memory registration mode)
  
  	if (!list_empty(&unmap_list)) {
  		/* we have to make sure that none of the things we're about
@@@ -767,10 -492,10 +774,17 @@@ void rds_ib_free_mr(void *trans_private
  	rdsdebug("RDS/IB: free_mr nents %u\n", ibmr->sg_len);
  
  	/* Return it to the pool's free list */
++<<<<<<< HEAD
 +	if (ibmr->remap_count >= pool->fmr_attr.max_maps)
 +		llist_add(&ibmr->llnode, &pool->drop_list);
 +	else
 +		llist_add(&ibmr->llnode, &pool->free_list);
++=======
+ 	if (rds_ibdev->use_fastreg)
+ 		rds_ib_free_frmr_list(ibmr);
+ 	else
+ 		rds_ib_free_fmr_list(ibmr);
++>>>>>>> 1659185fb4d0 (RDS: IB: Support Fastreg MR (FRMR) memory registration mode)
  
  	atomic_add(ibmr->sg_len, &pool->free_pinned);
  	atomic_inc(&pool->dirty_count);
@@@ -828,29 -554,81 +843,102 @@@ void *rds_ib_get_mr(struct scatterlist 
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	ibmr = rds_ib_alloc_fmr(rds_ibdev, nents);
 +	if (IS_ERR(ibmr)) {
 +		rds_ib_dev_put(rds_ibdev);
 +		return ibmr;
 +	}
 +
 +	ret = rds_ib_map_fmr(rds_ibdev, ibmr, sg, nents);
 +	if (ret == 0)
 +		*key_ret = ibmr->fmr->rkey;
 +	else
 +		printk(KERN_WARNING "RDS/IB: map_fmr failed (errno=%d)\n", ret);
 +
 +	ibmr->device = rds_ibdev;
 +	rds_ibdev = NULL;
++=======
+ 	if (rds_ibdev->use_fastreg)
+ 		ibmr = rds_ib_reg_frmr(rds_ibdev, ic, sg, nents, key_ret);
+ 	else
+ 		ibmr = rds_ib_reg_fmr(rds_ibdev, sg, nents, key_ret);
+ 	if (ibmr)
+ 		rds_ibdev = NULL;
++>>>>>>> 1659185fb4d0 (RDS: IB: Support Fastreg MR (FRMR) memory registration mode)
  
   out:
 -	if (!ibmr)
 -		pr_warn("RDS/IB: rds_ib_get_mr failed (errno=%d)\n", ret);
 -
 +	if (ret) {
 +		if (ibmr)
 +			rds_ib_free_mr(ibmr, 0);
 +		ibmr = ERR_PTR(ret);
 +	}
  	if (rds_ibdev)
  		rds_ib_dev_put(rds_ibdev);
 -
  	return ibmr;
  }
  
++<<<<<<< HEAD
++=======
+ void rds_ib_destroy_mr_pool(struct rds_ib_mr_pool *pool)
+ {
+ 	cancel_delayed_work_sync(&pool->flush_worker);
+ 	rds_ib_flush_mr_pool(pool, 1, NULL);
+ 	WARN_ON(atomic_read(&pool->item_count));
+ 	WARN_ON(atomic_read(&pool->free_pinned));
+ 	kfree(pool);
+ }
+ 
+ struct rds_ib_mr_pool *rds_ib_create_mr_pool(struct rds_ib_device *rds_ibdev,
+ 					     int pool_type)
+ {
+ 	struct rds_ib_mr_pool *pool;
+ 
+ 	pool = kzalloc(sizeof(*pool), GFP_KERNEL);
+ 	if (!pool)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	pool->pool_type = pool_type;
+ 	init_llist_head(&pool->free_list);
+ 	init_llist_head(&pool->drop_list);
+ 	init_llist_head(&pool->clean_list);
+ 	mutex_init(&pool->flush_lock);
+ 	init_waitqueue_head(&pool->flush_wait);
+ 	INIT_DELAYED_WORK(&pool->flush_worker, rds_ib_mr_pool_flush_worker);
+ 
+ 	if (pool_type == RDS_IB_MR_1M_POOL) {
+ 		/* +1 allows for unaligned MRs */
+ 		pool->fmr_attr.max_pages = RDS_MR_1M_MSG_SIZE + 1;
+ 		pool->max_items = RDS_MR_1M_POOL_SIZE;
+ 	} else {
+ 		/* pool_type == RDS_IB_MR_8K_POOL */
+ 		pool->fmr_attr.max_pages = RDS_MR_8K_MSG_SIZE + 1;
+ 		pool->max_items = RDS_MR_8K_POOL_SIZE;
+ 	}
+ 
+ 	pool->max_free_pinned = pool->max_items * pool->fmr_attr.max_pages / 4;
+ 	pool->fmr_attr.max_maps = rds_ibdev->fmr_max_remaps;
+ 	pool->fmr_attr.page_shift = PAGE_SHIFT;
+ 	pool->max_items_soft = rds_ibdev->max_mrs * 3 / 4;
+ 	pool->use_fastreg = rds_ibdev->use_fastreg;
+ 
+ 	return pool;
+ }
+ 
+ int rds_ib_mr_init(void)
+ {
+ 	rds_ib_mr_wq = create_workqueue("rds_mr_flushd");
+ 	if (!rds_ib_mr_wq)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /* By the time this is called all the IB devices should have been torn down and
+  * had their pools freed.  As each pool is freed its work struct is waited on,
+  * so the pool flushing work queue should be idle by the time we get here.
+  */
+ void rds_ib_mr_exit(void)
+ {
+ 	destroy_workqueue(rds_ib_mr_wq);
+ }
++>>>>>>> 1659185fb4d0 (RDS: IB: Support Fastreg MR (FRMR) memory registration mode)
* Unmerged path net/rds/ib_mr.h
* Unmerged path net/rds/Makefile
* Unmerged path net/rds/ib.h
* Unmerged path net/rds/ib_cm.c
diff --git a/net/rds/ib_frmr.c b/net/rds/ib_frmr.c
new file mode 100644
index 000000000000..93ff038ea9d1
--- /dev/null
+++ b/net/rds/ib_frmr.c
@@ -0,0 +1,376 @@
+/*
+ * Copyright (c) 2016 Oracle.  All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include "ib_mr.h"
+
+static struct rds_ib_mr *rds_ib_alloc_frmr(struct rds_ib_device *rds_ibdev,
+					   int npages)
+{
+	struct rds_ib_mr_pool *pool;
+	struct rds_ib_mr *ibmr = NULL;
+	struct rds_ib_frmr *frmr;
+	int err = 0;
+
+	if (npages <= RDS_MR_8K_MSG_SIZE)
+		pool = rds_ibdev->mr_8k_pool;
+	else
+		pool = rds_ibdev->mr_1m_pool;
+
+	ibmr = rds_ib_try_reuse_ibmr(pool);
+	if (ibmr)
+		return ibmr;
+
+	ibmr = kzalloc_node(sizeof(*ibmr), GFP_KERNEL,
+			    rdsibdev_to_node(rds_ibdev));
+	if (!ibmr) {
+		err = -ENOMEM;
+		goto out_no_cigar;
+	}
+
+	frmr = &ibmr->u.frmr;
+	frmr->mr = ib_alloc_mr(rds_ibdev->pd, IB_MR_TYPE_MEM_REG,
+			 pool->fmr_attr.max_pages);
+	if (IS_ERR(frmr->mr)) {
+		pr_warn("RDS/IB: %s failed to allocate MR", __func__);
+		goto out_no_cigar;
+	}
+
+	ibmr->pool = pool;
+	if (pool->pool_type == RDS_IB_MR_8K_POOL)
+		rds_ib_stats_inc(s_ib_rdma_mr_8k_alloc);
+	else
+		rds_ib_stats_inc(s_ib_rdma_mr_1m_alloc);
+
+	if (atomic_read(&pool->item_count) > pool->max_items_soft)
+		pool->max_items_soft = pool->max_items;
+
+	frmr->fr_state = FRMR_IS_FREE;
+	return ibmr;
+
+out_no_cigar:
+	kfree(ibmr);
+	atomic_dec(&pool->item_count);
+	return ERR_PTR(err);
+}
+
+static void rds_ib_free_frmr(struct rds_ib_mr *ibmr, bool drop)
+{
+	struct rds_ib_mr_pool *pool = ibmr->pool;
+
+	if (drop)
+		llist_add(&ibmr->llnode, &pool->drop_list);
+	else
+		llist_add(&ibmr->llnode, &pool->free_list);
+	atomic_add(ibmr->sg_len, &pool->free_pinned);
+	atomic_inc(&pool->dirty_count);
+
+	/* If we've pinned too many pages, request a flush */
+	if (atomic_read(&pool->free_pinned) >= pool->max_free_pinned ||
+	    atomic_read(&pool->dirty_count) >= pool->max_items / 5)
+		queue_delayed_work(rds_ib_mr_wq, &pool->flush_worker, 10);
+}
+
+static int rds_ib_post_reg_frmr(struct rds_ib_mr *ibmr)
+{
+	struct rds_ib_frmr *frmr = &ibmr->u.frmr;
+	struct ib_send_wr *failed_wr;
+	struct ib_reg_wr reg_wr;
+	int ret;
+
+	while (atomic_dec_return(&ibmr->ic->i_fastreg_wrs) <= 0) {
+		atomic_inc(&ibmr->ic->i_fastreg_wrs);
+		cpu_relax();
+	}
+
+	ret = ib_map_mr_sg_zbva(frmr->mr, ibmr->sg, ibmr->sg_len, PAGE_SIZE);
+	if (unlikely(ret != ibmr->sg_len))
+		return ret < 0 ? ret : -EINVAL;
+
+	/* Perform a WR for the fast_reg_mr. Each individual page
+	 * in the sg list is added to the fast reg page list and placed
+	 * inside the fast_reg_mr WR.  The key used is a rolling 8bit
+	 * counter, which should guarantee uniqueness.
+	 */
+	ib_update_fast_reg_key(frmr->mr, ibmr->remap_count++);
+	frmr->fr_state = FRMR_IS_INUSE;
+
+	memset(&reg_wr, 0, sizeof(reg_wr));
+	reg_wr.wr.wr_id = (unsigned long)(void *)ibmr;
+	reg_wr.wr.opcode = IB_WR_REG_MR;
+	reg_wr.wr.num_sge = 0;
+	reg_wr.mr = frmr->mr;
+	reg_wr.key = frmr->mr->rkey;
+	reg_wr.access = IB_ACCESS_LOCAL_WRITE |
+			IB_ACCESS_REMOTE_READ |
+			IB_ACCESS_REMOTE_WRITE;
+	reg_wr.wr.send_flags = IB_SEND_SIGNALED;
+
+	failed_wr = &reg_wr.wr;
+	ret = ib_post_send(ibmr->ic->i_cm_id->qp, &reg_wr.wr, &failed_wr);
+	WARN_ON(failed_wr != &reg_wr.wr);
+	if (unlikely(ret)) {
+		/* Failure here can be because of -ENOMEM as well */
+		frmr->fr_state = FRMR_IS_STALE;
+		atomic_inc(&ibmr->ic->i_fastreg_wrs);
+		if (printk_ratelimit())
+			pr_warn("RDS/IB: %s returned error(%d)\n",
+				__func__, ret);
+	}
+	return ret;
+}
+
+static int rds_ib_map_frmr(struct rds_ib_device *rds_ibdev,
+			   struct rds_ib_mr_pool *pool,
+			   struct rds_ib_mr *ibmr,
+			   struct scatterlist *sg, unsigned int sg_len)
+{
+	struct ib_device *dev = rds_ibdev->dev;
+	struct rds_ib_frmr *frmr = &ibmr->u.frmr;
+	int i;
+	u32 len;
+	int ret = 0;
+
+	/* We want to teardown old ibmr values here and fill it up with
+	 * new sg values
+	 */
+	rds_ib_teardown_mr(ibmr);
+
+	ibmr->sg = sg;
+	ibmr->sg_len = sg_len;
+	ibmr->sg_dma_len = 0;
+	frmr->sg_byte_len = 0;
+	WARN_ON(ibmr->sg_dma_len);
+	ibmr->sg_dma_len = ib_dma_map_sg(dev, ibmr->sg, ibmr->sg_len,
+					 DMA_BIDIRECTIONAL);
+	if (unlikely(!ibmr->sg_dma_len)) {
+		pr_warn("RDS/IB: %s failed!\n", __func__);
+		return -EBUSY;
+	}
+
+	frmr->sg_byte_len = 0;
+	frmr->dma_npages = 0;
+	len = 0;
+
+	ret = -EINVAL;
+	for (i = 0; i < ibmr->sg_dma_len; ++i) {
+		unsigned int dma_len = ib_sg_dma_len(dev, &ibmr->sg[i]);
+		u64 dma_addr = ib_sg_dma_address(dev, &ibmr->sg[i]);
+
+		frmr->sg_byte_len += dma_len;
+		if (dma_addr & ~PAGE_MASK) {
+			if (i > 0)
+				goto out_unmap;
+			else
+				++frmr->dma_npages;
+		}
+
+		if ((dma_addr + dma_len) & ~PAGE_MASK) {
+			if (i < ibmr->sg_dma_len - 1)
+				goto out_unmap;
+			else
+				++frmr->dma_npages;
+		}
+
+		len += dma_len;
+	}
+	frmr->dma_npages += len >> PAGE_SHIFT;
+
+	if (frmr->dma_npages > ibmr->pool->fmr_attr.max_pages) {
+		ret = -EMSGSIZE;
+		goto out_unmap;
+	}
+
+	ret = rds_ib_post_reg_frmr(ibmr);
+	if (ret)
+		goto out_unmap;
+
+	if (ibmr->pool->pool_type == RDS_IB_MR_8K_POOL)
+		rds_ib_stats_inc(s_ib_rdma_mr_8k_used);
+	else
+		rds_ib_stats_inc(s_ib_rdma_mr_1m_used);
+
+	return ret;
+
+out_unmap:
+	ib_dma_unmap_sg(rds_ibdev->dev, ibmr->sg, ibmr->sg_len,
+			DMA_BIDIRECTIONAL);
+	ibmr->sg_dma_len = 0;
+	return ret;
+}
+
+static int rds_ib_post_inv(struct rds_ib_mr *ibmr)
+{
+	struct ib_send_wr *s_wr, *failed_wr;
+	struct rds_ib_frmr *frmr = &ibmr->u.frmr;
+	struct rdma_cm_id *i_cm_id = ibmr->ic->i_cm_id;
+	int ret = -EINVAL;
+
+	if (!i_cm_id || !i_cm_id->qp || !frmr->mr)
+		goto out;
+
+	if (frmr->fr_state != FRMR_IS_INUSE)
+		goto out;
+
+	while (atomic_dec_return(&ibmr->ic->i_fastreg_wrs) <= 0) {
+		atomic_inc(&ibmr->ic->i_fastreg_wrs);
+		cpu_relax();
+	}
+
+	frmr->fr_inv = true;
+	s_wr = &frmr->fr_wr;
+
+	memset(s_wr, 0, sizeof(*s_wr));
+	s_wr->wr_id = (unsigned long)(void *)ibmr;
+	s_wr->opcode = IB_WR_LOCAL_INV;
+	s_wr->ex.invalidate_rkey = frmr->mr->rkey;
+	s_wr->send_flags = IB_SEND_SIGNALED;
+
+	failed_wr = s_wr;
+	ret = ib_post_send(i_cm_id->qp, s_wr, &failed_wr);
+	WARN_ON(failed_wr != s_wr);
+	if (unlikely(ret)) {
+		frmr->fr_state = FRMR_IS_STALE;
+		frmr->fr_inv = false;
+		atomic_inc(&ibmr->ic->i_fastreg_wrs);
+		pr_err("RDS/IB: %s returned error(%d)\n", __func__, ret);
+		goto out;
+	}
+out:
+	return ret;
+}
+
+void rds_ib_mr_cqe_handler(struct rds_ib_connection *ic, struct ib_wc *wc)
+{
+	struct rds_ib_mr *ibmr = (void *)(unsigned long)wc->wr_id;
+	struct rds_ib_frmr *frmr = &ibmr->u.frmr;
+
+	if (wc->status != IB_WC_SUCCESS) {
+		frmr->fr_state = FRMR_IS_STALE;
+		if (rds_conn_up(ic->conn))
+			rds_ib_conn_error(ic->conn,
+					  "frmr completion <%pI4,%pI4> status %u(%s), vendor_err 0x%x, disconnecting and reconnecting\n",
+					  &ic->conn->c_laddr,
+					  &ic->conn->c_faddr,
+					  wc->status,
+					  ib_wc_status_msg(wc->status),
+					  wc->vendor_err);
+	}
+
+	if (frmr->fr_inv) {
+		frmr->fr_state = FRMR_IS_FREE;
+		frmr->fr_inv = false;
+	}
+
+	atomic_inc(&ic->i_fastreg_wrs);
+}
+
+void rds_ib_unreg_frmr(struct list_head *list, unsigned int *nfreed,
+		       unsigned long *unpinned, unsigned int goal)
+{
+	struct rds_ib_mr *ibmr, *next;
+	struct rds_ib_frmr *frmr;
+	int ret = 0;
+	unsigned int freed = *nfreed;
+
+	/* String all ib_mr's onto one list and hand them to ib_unmap_fmr */
+	list_for_each_entry(ibmr, list, unmap_list) {
+		if (ibmr->sg_dma_len)
+			ret |= rds_ib_post_inv(ibmr);
+	}
+	if (ret)
+		pr_warn("RDS/IB: %s failed (err=%d)\n", __func__, ret);
+
+	/* Now we can destroy the DMA mapping and unpin any pages */
+	list_for_each_entry_safe(ibmr, next, list, unmap_list) {
+		*unpinned += ibmr->sg_len;
+		frmr = &ibmr->u.frmr;
+		__rds_ib_teardown_mr(ibmr);
+		if (freed < goal || frmr->fr_state == FRMR_IS_STALE) {
+			/* Don't de-allocate if the MR is not free yet */
+			if (frmr->fr_state == FRMR_IS_INUSE)
+				continue;
+
+			if (ibmr->pool->pool_type == RDS_IB_MR_8K_POOL)
+				rds_ib_stats_inc(s_ib_rdma_mr_8k_free);
+			else
+				rds_ib_stats_inc(s_ib_rdma_mr_1m_free);
+			list_del(&ibmr->unmap_list);
+			if (frmr->mr)
+				ib_dereg_mr(frmr->mr);
+			kfree(ibmr);
+			freed++;
+		}
+	}
+	*nfreed = freed;
+}
+
+struct rds_ib_mr *rds_ib_reg_frmr(struct rds_ib_device *rds_ibdev,
+				  struct rds_ib_connection *ic,
+				  struct scatterlist *sg,
+				  unsigned long nents, u32 *key)
+{
+	struct rds_ib_mr *ibmr = NULL;
+	struct rds_ib_frmr *frmr;
+	int ret;
+
+	do {
+		if (ibmr)
+			rds_ib_free_frmr(ibmr, true);
+		ibmr = rds_ib_alloc_frmr(rds_ibdev, nents);
+		if (IS_ERR(ibmr))
+			return ibmr;
+		frmr = &ibmr->u.frmr;
+	} while (frmr->fr_state != FRMR_IS_FREE);
+
+	ibmr->ic = ic;
+	ibmr->device = rds_ibdev;
+	ret = rds_ib_map_frmr(rds_ibdev, ibmr->pool, ibmr, sg, nents);
+	if (ret == 0) {
+		*key = frmr->mr->rkey;
+	} else {
+		rds_ib_free_frmr(ibmr, false);
+		ibmr = ERR_PTR(ret);
+	}
+
+	return ibmr;
+}
+
+void rds_ib_free_frmr_list(struct rds_ib_mr *ibmr)
+{
+	struct rds_ib_mr_pool *pool = ibmr->pool;
+	struct rds_ib_frmr *frmr = &ibmr->u.frmr;
+
+	if (frmr->fr_state == FRMR_IS_STALE)
+		llist_add(&ibmr->llnode, &pool->drop_list);
+	else
+		llist_add(&ibmr->llnode, &pool->free_list);
+}
* Unmerged path net/rds/ib_mr.h
* Unmerged path net/rds/ib_rdma.c
