netdev: introduce ndo_set_rx_headroom

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Paolo Abeni <pabeni@redhat.com>
commit 871b642adebe300be2e50aa5f65a418510f636ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/871b642a.failed

This method allows the controlling device (i.e. the bridge) to specify
additional headroom to be allocated for skb head on frame reception.

	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 871b642adebe300be2e50aa5f65a418510f636ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
diff --cc include/linux/netdevice.h
index f42ad8e42b23,efe7cec111fa..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1006,9 -1078,28 +1006,33 @@@ struct netdev_phys_port_id 
   *	be otherwise expressed by feature flags. The check is called with
   *	the set of features that the stack has calculated and it returns
   *	those the driver believes to be appropriate.
++<<<<<<< HEAD
++=======
+  * int (*ndo_set_tx_maxrate)(struct net_device *dev,
+  *			     int queue_index, u32 maxrate);
+  *	Called when a user wants to set a max-rate limitation of specific
+  *	TX queue.
+  * int (*ndo_get_iflink)(const struct net_device *dev);
+  *	Called to get the iflink value of this device.
+  * void (*ndo_change_proto_down)(struct net_device *dev,
+  *				  bool proto_down);
+  *	This function is used to pass protocol port error state information
+  *	to the switch driver. The switch driver can react to the proto_down
+  *      by doing a phys down on the associated switch port.
+  * int (*ndo_fill_metadata_dst)(struct net_device *dev, struct sk_buff *skb);
+  *	This function is used to get egress tunnel information for given skb.
+  *	This is useful for retrieving outer tunnel header parameters while
+  *	sampling packet.
+  * void (*ndo_set_rx_headroom)(struct net_device *dev, int needed_headroom);
+  *	This function is used to specify the headroom that the skb must
+  *	consider when allocation skb during packet reception. Setting
+  *	appropriate rx headroom value allows avoiding skb head copy on
+  *	forward. Setting a negative value reset the rx headroom to the
+  *	default value.
++>>>>>>> 871b642adebe (netdev: introduce ndo_set_rx_headroom)
   *
 + * int (*ndo_set_vf_rate)(struct net_device *dev, int vf, int min_tx_rate,
 + *			  int max_tx_rate);
   */
  struct net_device_ops {
  	int			(*ndo_init)(struct net_device *dev);
@@@ -1145,40 -1261,31 +1169,57 @@@
  	void			(*ndo_del_vxlan_port)(struct  net_device *dev,
  						      sa_family_t sa_family,
  						      __be16 port);
 -	void			(*ndo_add_geneve_port)(struct  net_device *dev,
 -						       sa_family_t sa_family,
 -						       __be16 port);
 -	void			(*ndo_del_geneve_port)(struct  net_device *dev,
 -						       sa_family_t sa_family,
 -						       __be16 port);
 -	void*			(*ndo_dfwd_add_station)(struct net_device *pdev,
 -							struct net_device *dev);
 -	void			(*ndo_dfwd_del_station)(struct net_device *pdev,
 -							void *priv);
  
++<<<<<<< HEAD
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_USE_P(1, int	(*ndo_get_iflink)(const struct net_device *dev))
 +	RH_KABI_USE_P(2, netdev_features_t
 +				(*ndo_features_check)(struct sk_buff *skb,
 +						      struct net_device *dev,
 +						      netdev_features_t features))
 +	RH_KABI_USE_P(3, int	(*ndo_set_vf_rate)(struct net_device *dev,
 +						   int vf, int min_tx_rate,
 +						   int max_tx_rate))
 +	RH_KABI_USE_P(4, int	(*ndo_get_vf_stats)(struct net_device *dev,
 +						    int vf,
 +						    struct ifla_vf_stats
 +						    *vf_stats))
 +	RH_KABI_USE_P(5, int    (*ndo_set_vf_rss_query_en)(struct net_device *dev,
 +							   int vf, bool setting))
 +
 +	RH_KABI_RESERVE_P(6)
 +	RH_KABI_RESERVE_P(7)
 +	RH_KABI_RESERVE_P(8)
 +	RH_KABI_RESERVE_P(9)
 +	RH_KABI_RESERVE_P(10)
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_RESERVE_P(16)
++=======
+ 	netdev_tx_t		(*ndo_dfwd_start_xmit) (struct sk_buff *skb,
+ 							struct net_device *dev,
+ 							void *priv);
+ 	int			(*ndo_get_lock_subclass)(struct net_device *dev);
+ 	int			(*ndo_set_tx_maxrate)(struct net_device *dev,
+ 						      int queue_index,
+ 						      u32 maxrate);
+ 	int			(*ndo_get_iflink)(const struct net_device *dev);
+ 	int			(*ndo_change_proto_down)(struct net_device *dev,
+ 							 bool proto_down);
+ 	int			(*ndo_fill_metadata_dst)(struct net_device *dev,
+ 						       struct sk_buff *skb);
+ 	void			(*ndo_set_rx_headroom)(struct net_device *dev,
+ 						       int needed_headroom);
++>>>>>>> 871b642adebe (netdev: introduce ndo_set_rx_headroom)
  };
  
  /**
@@@ -1215,31 -1317,43 +1256,70 @@@
   * @IFF_LIVE_ADDR_CHANGE: device supports hardware address
   *	change when it's running
   * @IFF_MACVLAN: Macvlan device
++<<<<<<< HEAD
++=======
+  * @IFF_L3MDEV_MASTER: device is an L3 master device
+  * @IFF_NO_QUEUE: device can run without qdisc attached
+  * @IFF_OPENVSWITCH: device is a Open vSwitch master
+  * @IFF_L3MDEV_SLAVE: device is enslaved to an L3 master device
+  * @IFF_TEAM: device is a team device
+  * @IFF_RXFH_CONFIGURED: device has had Rx Flow indirection table configured
+  * @IFF_PHONY_HEADROOM: the headroom value is controlled by an external
+  *	entity (i.e. the master device for bridged veth)
++>>>>>>> 871b642adebe (netdev: introduce ndo_set_rx_headroom)
   */
  enum netdev_priv_flags {
  	IFF_802_1Q_VLAN			= 1<<0,
  	IFF_EBRIDGE			= 1<<1,
++<<<<<<< HEAD
 +	IFF_SLAVE_INACTIVE		= 1<<2,
 +	IFF_MASTER_8023AD		= 1<<3,
 +	IFF_MASTER_ALB			= 1<<4,
 +	IFF_BONDING			= 1<<5,
 +	IFF_SLAVE_NEEDARP		= 1<<6,
 +	IFF_ISATAP			= 1<<7,
 +	IFF_MASTER_ARPMON		= 1<<8,
 +	IFF_WAN_HDLC			= 1<<9,
 +	IFF_XMIT_DST_RELEASE		= 1<<10,
 +	IFF_DONT_BRIDGE			= 1<<11,
 +	IFF_DISABLE_NETPOLL		= 1<<12,
 +	IFF_MACVLAN_PORT		= 1<<13,
 +	IFF_BRIDGE_PORT			= 1<<14,
 +	IFF_OVS_DATAPATH		= 1<<15,
 +	IFF_TX_SKB_SHARING		= 1<<16,
 +	IFF_UNICAST_FLT			= 1<<17,
 +	IFF_TEAM_PORT			= 1<<18,
 +	IFF_SUPP_NOFCS			= 1<<19,
 +	IFF_LIVE_ADDR_CHANGE		= 1<<20,
 +	IFF_MACVLAN			= 1<<21,
 +	IFF_XMIT_DST_RELEASE_PERM	= 1<<22,
++=======
+ 	IFF_BONDING			= 1<<2,
+ 	IFF_ISATAP			= 1<<3,
+ 	IFF_WAN_HDLC			= 1<<4,
+ 	IFF_XMIT_DST_RELEASE		= 1<<5,
+ 	IFF_DONT_BRIDGE			= 1<<6,
+ 	IFF_DISABLE_NETPOLL		= 1<<7,
+ 	IFF_MACVLAN_PORT		= 1<<8,
+ 	IFF_BRIDGE_PORT			= 1<<9,
+ 	IFF_OVS_DATAPATH		= 1<<10,
+ 	IFF_TX_SKB_SHARING		= 1<<11,
+ 	IFF_UNICAST_FLT			= 1<<12,
+ 	IFF_TEAM_PORT			= 1<<13,
+ 	IFF_SUPP_NOFCS			= 1<<14,
+ 	IFF_LIVE_ADDR_CHANGE		= 1<<15,
+ 	IFF_MACVLAN			= 1<<16,
+ 	IFF_XMIT_DST_RELEASE_PERM	= 1<<17,
+ 	IFF_IPVLAN_MASTER		= 1<<18,
+ 	IFF_IPVLAN_SLAVE		= 1<<19,
+ 	IFF_L3MDEV_MASTER		= 1<<20,
+ 	IFF_NO_QUEUE			= 1<<21,
+ 	IFF_OPENVSWITCH			= 1<<22,
+ 	IFF_L3MDEV_SLAVE		= 1<<23,
+ 	IFF_TEAM			= 1<<24,
+ 	IFF_RXFH_CONFIGURED		= 1<<25,
+ 	IFF_PHONY_HEADROOM		= 1<<26,
++>>>>>>> 871b642adebe (netdev: introduce ndo_set_rx_headroom)
  };
  
  #define IFF_802_1Q_VLAN			IFF_802_1Q_VLAN
@@@ -1678,9 -1945,29 +1758,29 @@@ static inline void netdev_for_each_tx_q
  }
  
  struct netdev_queue *netdev_pick_tx(struct net_device *dev,
 -				    struct sk_buff *skb,
 -				    void *accel_priv);
 +				    struct sk_buff *skb);
 +u16 __netdev_pick_tx(struct net_device *dev, struct sk_buff *skb);
  
+ /* returns the headroom that the master device needs to take in account
+  * when forwarding to this dev
+  */
+ static inline unsigned netdev_get_fwd_headroom(struct net_device *dev)
+ {
+ 	return dev->priv_flags & IFF_PHONY_HEADROOM ? 0 : dev->needed_headroom;
+ }
+ 
+ static inline void netdev_set_rx_headroom(struct net_device *dev, int new_hr)
+ {
+ 	if (dev->netdev_ops->ndo_set_rx_headroom)
+ 		dev->netdev_ops->ndo_set_rx_headroom(dev, new_hr);
+ }
+ 
+ /* set the device rx headroom to the dev's default */
+ static inline void netdev_reset_rx_headroom(struct net_device *dev)
+ {
+ 	netdev_set_rx_headroom(dev, -1);
+ }
+ 
  /*
   * Net namespace inlines
   */
* Unmerged path include/linux/netdevice.h
