hv_netvsc: fix bonding devices check in netvsc_netdev_event()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 0dbff144a1e7310e2f8b7a957352c4be9aeb38e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0dbff144.failed

Bonding driver sets IFF_BONDING on both master (the bonding device) and
slave (the real NIC) devices and in netvsc_netdev_event() we want to skip
master devices only. Currently, there is an uncertainty when a slave
interface is removed: if bonding module comes first in netdev_chain it
clears IFF_BONDING flag on the netdev and netvsc_netdev_event() correctly
handles NETDEV_UNREGISTER event, but in case netvsc comes first on the
chain it sees the device with IFF_BONDING still attached and skips it. As
we still hold vf_netdev pointer to the device we crash on the next inject.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Acked-by: Haiyang Zhang <haiyangz@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0dbff144a1e7310e2f8b7a957352c4be9aeb38e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index 822e657fcee7,3ba29fc80d05..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -973,8 -1470,48 +973,50 @@@ static struct  hv_driver netvsc_drv = 
  	.remove = netvsc_remove,
  };
  
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * On Hyper-V, every VF interface is matched with a corresponding
+  * synthetic interface. The synthetic interface is presented first
+  * to the guest. When the corresponding VF instance is registered,
+  * we will take care of switching the data path.
+  */
+ static int netvsc_netdev_event(struct notifier_block *this,
+ 			       unsigned long event, void *ptr)
+ {
+ 	struct net_device *event_dev = netdev_notifier_info_to_dev(ptr);
+ 
+ 	/* Avoid Vlan dev with same MAC registering as VF */
+ 	if (event_dev->priv_flags & IFF_802_1Q_VLAN)
+ 		return NOTIFY_DONE;
+ 
+ 	/* Avoid Bonding master dev with same MAC registering as VF */
+ 	if (event_dev->priv_flags & IFF_BONDING &&
+ 	    event_dev->flags & IFF_MASTER)
+ 		return NOTIFY_DONE;
+ 
+ 	switch (event) {
+ 	case NETDEV_REGISTER:
+ 		return netvsc_register_vf(event_dev);
+ 	case NETDEV_UNREGISTER:
+ 		return netvsc_unregister_vf(event_dev);
+ 	case NETDEV_UP:
+ 		return netvsc_vf_up(event_dev);
+ 	case NETDEV_DOWN:
+ 		return netvsc_vf_down(event_dev);
+ 	default:
+ 		return NOTIFY_DONE;
+ 	}
+ }
+ 
+ static struct notifier_block netvsc_netdev_notifier = {
+ 	.notifier_call = netvsc_netdev_event,
+ };
+ 
++>>>>>>> 0dbff144a1e7 (hv_netvsc: fix bonding devices check in netvsc_netdev_event())
  static void __exit netvsc_drv_exit(void)
  {
 -	unregister_netdevice_notifier(&netvsc_netdev_notifier);
  	vmbus_driver_unregister(&netvsc_drv);
  }
  
* Unmerged path drivers/net/hyperv/netvsc_drv.c
