ACPI / utils: Add acpi_dev_present()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [include] alsa: acpi / utils: Add acpi_dev_present() (Jaroslav Kysela) [1288993]
Rebuild_FUZZ: 92.31%
commit-author Lukas Wunner <lukas@wunner.de>
commit 2d12b6b381ba059d5f92798f5ea739672a2f5fcf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2d12b6b3.failed

There's an idiom in use by 7 Linux drivers to detect the presence of a
particular ACPI HID by walking the namespace with acpi_get_devices().
The callback passed to acpi_get_devices() is mostly identical across
the drivers, leading to lots of duplicate code.

Add acpi_dev_present(), the ACPI equivalent to pci_dev_present(),
allowing us to deduplicate all that boilerplate in the drivers.

	Signed-off-by: Lukas Wunner <lukas@wunner.de>
	Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 2d12b6b381ba059d5f92798f5ea739672a2f5fcf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
#	drivers/acpi/utils.c
diff --cc drivers/acpi/scan.c
index 88c2d0368315,407a3760e8de..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -38,17 -37,19 +38,30 @@@ bool acpi_force_hot_remove
  
  static const char *dummy_hid = "device";
  
++<<<<<<< HEAD
 +static LIST_HEAD(acpi_bus_id_list);
++=======
+ static LIST_HEAD(acpi_dep_list);
+ static DEFINE_MUTEX(acpi_dep_list_lock);
+ LIST_HEAD(acpi_bus_id_list);
++>>>>>>> 2d12b6b381ba (ACPI / utils: Add acpi_dev_present())
  static DEFINE_MUTEX(acpi_scan_lock);
  static LIST_HEAD(acpi_scan_handlers_list);
  DEFINE_MUTEX(acpi_device_lock);
  LIST_HEAD(acpi_wakeup_device_list);
  static DEFINE_MUTEX(acpi_hp_context_lock);
  
++<<<<<<< HEAD
 +struct acpi_device_bus_id{
 +	char bus_id[15];
 +	unsigned int instance_no;
 +	struct list_head node;
++=======
+ struct acpi_dep_data {
+ 	struct list_head node;
+ 	acpi_handle master;
+ 	acpi_handle slave;
++>>>>>>> 2d12b6b381ba (ACPI / utils: Add acpi_dev_present())
  };
  
  void acpi_scan_lock_acquire(void)
diff --cc drivers/acpi/utils.c
index 86bd259e9e99,f2f9873bb5c3..000000000000
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@@ -30,10 -26,10 +30,11 @@@
  #include <linux/types.h>
  #include <linux/hardirq.h>
  #include <linux/acpi.h>
 -#include <linux/dynamic_debug.h>
 +#include <acpi/acpi_bus.h>
 +#include <acpi/acpi_drivers.h>
  
  #include "internal.h"
+ #include "sleep.h"
  
  #define _COMPONENT		ACPI_BUS_COMPONENT
  ACPI_MODULE_NAME("utils");
@@@ -656,3 -709,48 +657,51 @@@ bool acpi_check_dsm(acpi_handle handle
  	return false;
  }
  EXPORT_SYMBOL(acpi_check_dsm);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * acpi_dev_present - Detect presence of a given ACPI device in the system.
+  * @hid: Hardware ID of the device.
+  *
+  * Return %true if the device was present at the moment of invocation.
+  * Note that if the device is pluggable, it may since have disappeared.
+  *
+  * For this function to work, acpi_bus_scan() must have been executed
+  * which happens in the subsys_initcall() subsection. Hence, do not
+  * call from a subsys_initcall() or earlier (use acpi_get_devices()
+  * instead). Calling from module_init() is fine (which is synonymous
+  * with device_initcall()).
+  */
+ bool acpi_dev_present(const char *hid)
+ {
+ 	struct acpi_device_bus_id *acpi_device_bus_id;
+ 	bool found = false;
+ 
+ 	mutex_lock(&acpi_device_lock);
+ 	list_for_each_entry(acpi_device_bus_id, &acpi_bus_id_list, node)
+ 		if (!strcmp(acpi_device_bus_id->bus_id, hid)) {
+ 			found = true;
+ 			break;
+ 		}
+ 	mutex_unlock(&acpi_device_lock);
+ 
+ 	return found;
+ }
+ EXPORT_SYMBOL(acpi_dev_present);
+ 
+ /*
+  * acpi_backlight= handling, this is done here rather then in video_detect.c
+  * because __setup cannot be used in modules.
+  */
+ char acpi_video_backlight_string[16];
+ EXPORT_SYMBOL(acpi_video_backlight_string);
+ 
+ static int __init acpi_backlight(char *str)
+ {
+ 	strlcpy(acpi_video_backlight_string, str,
+ 		sizeof(acpi_video_backlight_string));
+ 	return 1;
+ }
+ __setup("acpi_backlight=", acpi_backlight);
++>>>>>>> 2d12b6b381ba (ACPI / utils: Add acpi_dev_present())
diff --git a/drivers/acpi/internal.h b/drivers/acpi/internal.h
index 7d374d497109..46292cbeae58 100644
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@ -86,6 +86,14 @@ bool acpi_scan_is_offline(struct acpi_device *adev, bool uevent);
 #define ACPI_STA_DEFAULT (ACPI_STA_DEVICE_PRESENT | ACPI_STA_DEVICE_ENABLED | \
 			  ACPI_STA_DEVICE_UI | ACPI_STA_DEVICE_FUNCTIONING)
 
+extern struct list_head acpi_bus_id_list;
+
+struct acpi_device_bus_id{
+	char bus_id[15];
+	unsigned int instance_no;
+	struct list_head node;
+};
+
 int acpi_device_add(struct acpi_device *device,
 		    void (*release)(struct device *));
 void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
* Unmerged path drivers/acpi/scan.c
* Unmerged path drivers/acpi/utils.c
diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
index 7a20ad523a53..edebfa9d9a36 100644
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@ -92,6 +92,8 @@ acpi_evaluate_dsm_typed(acpi_handle handle, const u8 *uuid, int rev, int func,
 	  .package.elements = (eles)			\
 	}
 
+bool acpi_dev_present(const char *hid);
+
 #ifdef CONFIG_ACPI
 
 #include <linux/proc_fs.h>
