mmc: core: Make tuning block patterns static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ulf Hansson <ulf.hansson@linaro.org>
commit 04cdbbfa73ebac57a30ec2ebebfd7e9342bbdc44
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/04cdbbfa.failed

Since previous patches removed the need for the tuning block patterns
to be exported, let's move them close to the mmc_send_tuning() API.

Those are now intended to be used only by the mmc core.

	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
	Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
(cherry picked from commit 04cdbbfa73ebac57a30ec2ebebfd7e9342bbdc44)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/mmc.c
diff --cc drivers/mmc/core/mmc.c
index 51a18b7ab66f,0b8ec87fc517..000000000000
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@@ -907,6 -1121,73 +907,76 @@@ err
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Activate High Speed or HS200 mode if supported.
+  */
+ static int mmc_select_timing(struct mmc_card *card)
+ {
+ 	int err = 0;
+ 
+ 	if (!mmc_can_ext_csd(card))
+ 		goto bus_speed;
+ 
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200)
+ 		err = mmc_select_hs200(card);
+ 	else if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS)
+ 		err = mmc_select_hs(card);
+ 
+ 	if (err && err != -EBADMSG)
+ 		return err;
+ 
+ 	if (err) {
+ 		pr_warn("%s: switch to %s failed\n",
+ 			mmc_card_hs(card) ? "high-speed" :
+ 			(mmc_card_hs200(card) ? "hs200" : ""),
+ 			mmc_hostname(card->host));
+ 		err = 0;
+ 	}
+ 
+ bus_speed:
+ 	/*
+ 	 * Set the bus speed to the selected bus timing.
+ 	 * If timing is not selected, backward compatible is the default.
+ 	 */
+ 	mmc_set_bus_speed(card);
+ 	return err;
+ }
+ 
+ /*
+  * Execute tuning sequence to seek the proper bus operating
+  * conditions for HS200 and HS400, which sends CMD21 to the device.
+  */
+ static int mmc_hs200_tuning(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	int err = 0;
+ 
+ 	/*
+ 	 * Timing should be adjusted to the HS400 target
+ 	 * operation frequency for tuning process
+ 	 */
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400 &&
+ 	    host->ios.bus_width == MMC_BUS_WIDTH_8)
+ 		if (host->ops->prepare_hs400_tuning)
+ 			host->ops->prepare_hs400_tuning(host, &host->ios);
+ 
+ 	if (host->ops->execute_tuning) {
+ 		mmc_host_clk_hold(host);
+ 		err = host->ops->execute_tuning(host,
+ 				MMC_SEND_TUNING_BLOCK_HS200);
+ 		mmc_host_clk_release(host);
+ 
+ 		if (err)
+ 			pr_err("%s: tuning execution failed\n",
+ 				mmc_hostname(host));
+ 	}
+ 
+ 	return err;
+ }
+ 
+ /*
++>>>>>>> 04cdbbfa73eb (mmc: core: Make tuning block patterns static)
   * Handle the detection and initialisation of a card.
   *
   * In the case of a resume, "oldcard" will contain the card
* Unmerged path drivers/mmc/core/mmc.c
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index 7d8324d583f4..792cf66d9aa1 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -23,6 +23,36 @@
 
 #define MMC_OPS_TIMEOUT_MS	(10 * 60 * 1000) /* 10 minute timeout */
 
+static const u8 tuning_blk_pattern_4bit[] = {
+	0xff, 0x0f, 0xff, 0x00, 0xff, 0xcc, 0xc3, 0xcc,
+	0xc3, 0x3c, 0xcc, 0xff, 0xfe, 0xff, 0xfe, 0xef,
+	0xff, 0xdf, 0xff, 0xdd, 0xff, 0xfb, 0xff, 0xfb,
+	0xbf, 0xff, 0x7f, 0xff, 0x77, 0xf7, 0xbd, 0xef,
+	0xff, 0xf0, 0xff, 0xf0, 0x0f, 0xfc, 0xcc, 0x3c,
+	0xcc, 0x33, 0xcc, 0xcf, 0xff, 0xef, 0xff, 0xee,
+	0xff, 0xfd, 0xff, 0xfd, 0xdf, 0xff, 0xbf, 0xff,
+	0xbb, 0xff, 0xf7, 0xff, 0xf7, 0x7f, 0x7b, 0xde,
+};
+
+static const u8 tuning_blk_pattern_8bit[] = {
+	0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
+	0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,
+	0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
+	0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
+	0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
+	0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
+	0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
+	0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
+	0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
+	0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,
+	0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,
+	0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
+	0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
+	0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
+	0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
+	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
+};
+
 static inline int __mmc_send_status(struct mmc_card *card, u32 *status,
 				    bool ignore_crc)
 {
