leds: Introduce devres helper for led_classdev_register

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bjorn Andersson <bjorn.andersson@sonymobile.com>
commit ca1bb4ee4c3a017bb66840d11d5efdf4e8f3f66d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ca1bb4ee.failed

(cooloney@gmail.com: add _unregister function into the document)

	Suggested-by: Stephen Boyd <sboyd@codeaurora.org>
	Signed-off-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
	Signed-off-by: Bryan Wu <cooloney@gmail.com>
(cherry picked from commit ca1bb4ee4c3a017bb66840d11d5efdf4e8f3f66d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/driver-model/devres.txt
diff --cc Documentation/driver-model/devres.txt
index b4671459857f,e1e2bbd7a404..000000000000
--- a/Documentation/driver-model/devres.txt
+++ b/Documentation/driver-model/devres.txt
@@@ -265,22 -276,48 +265,54 @@@ IOMA
    devm_ioport_unmap()
    devm_ioremap()
    devm_ioremap_nocache()
 -  devm_ioremap_resource() : checks resource, requests memory region, ioremaps
    devm_iounmap()
 +  devm_ioremap_resource() : checks resource, requests memory region, ioremaps
 +  devm_request_and_ioremap() : obsoleted by devm_ioremap_resource()
    pcim_iomap()
 -  pcim_iomap_regions()	: do request_region() and iomap() on multiple BARs
 -  pcim_iomap_table()	: array of mapped addresses indexed by BAR
    pcim_iounmap()
 +  pcim_iomap_table()	: array of mapped addresses indexed by BAR
 +  pcim_iomap_regions()	: do request_region() and iomap() on multiple BARs
  
 -IRQ
 -  devm_free_irq()
 -  devm_request_any_context_irq()
 -  devm_request_irq()
 -  devm_request_threaded_irq()
 +REGULATOR
 +  devm_regulator_get()
 +  devm_regulator_put()
 +  devm_regulator_bulk_get()
  
++<<<<<<< HEAD
 +CLOCK
 +  devm_clk_get()
 +  devm_clk_put()
++=======
+ LED
+   devm_led_classdev_register()
+   devm_led_classdev_unregister()
+ 
+ MDIO
+   devm_mdiobus_alloc()
+   devm_mdiobus_alloc_size()
+   devm_mdiobus_free()
+ 
+ MEM
+   devm_free_pages()
+   devm_get_free_pages()
+   devm_kasprintf()
+   devm_kcalloc()
+   devm_kfree()
+   devm_kmalloc()
+   devm_kmalloc_array()
+   devm_kmemdup()
+   devm_kstrdup()
+   devm_kvasprintf()
+   devm_kzalloc()
+ 
+ PCI
+   pcim_enable_device()	: after success, all PCI ops become managed
+   pcim_pin_device()	: keep PCI device enabled after release
+ 
+ PHY
+   devm_usb_get_phy()
+   devm_usb_put_phy()
++>>>>>>> ca1bb4ee4c3a (leds: Introduce devres helper for led_classdev_register)
  
  PINCTRL
    devm_pinctrl_get()
* Unmerged path Documentation/driver-model/devres.txt
diff --git a/drivers/leds/led-class.c b/drivers/leds/led-class.c
index a20752f562bc..2b1f8609ff00 100644
--- a/drivers/leds/led-class.c
+++ b/drivers/leds/led-class.c
@@ -247,6 +247,63 @@ void led_classdev_unregister(struct led_classdev *led_cdev)
 }
 EXPORT_SYMBOL_GPL(led_classdev_unregister);
 
+static void devm_led_classdev_release(struct device *dev, void *res)
+{
+	led_classdev_unregister(*(struct led_classdev **)res);
+}
+
+/**
+ * devm_led_classdev_register - resource managed led_classdev_register()
+ * @parent: The device to register.
+ * @led_cdev: the led_classdev structure for this device.
+ */
+int devm_led_classdev_register(struct device *parent,
+			       struct led_classdev *led_cdev)
+{
+	struct led_classdev **dr;
+	int rc;
+
+	dr = devres_alloc(devm_led_classdev_release, sizeof(*dr), GFP_KERNEL);
+	if (!dr)
+		return -ENOMEM;
+
+	rc = led_classdev_register(parent, led_cdev);
+	if (rc) {
+		devres_free(dr);
+		return rc;
+	}
+
+	*dr = led_cdev;
+	devres_add(parent, dr);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(devm_led_classdev_register);
+
+static int devm_led_classdev_match(struct device *dev, void *res, void *data)
+{
+	struct led_cdev **p = res;
+
+	if (WARN_ON(!p || !*p))
+		return 0;
+
+	return *p == data;
+}
+
+/**
+ * devm_led_classdev_unregister() - resource managed led_classdev_unregister()
+ * @parent: The device to unregister.
+ * @led_cdev: the led_classdev structure for this device.
+ */
+void devm_led_classdev_unregister(struct device *dev,
+				  struct led_classdev *led_cdev)
+{
+	WARN_ON(devres_release(dev,
+			       devm_led_classdev_release,
+			       devm_led_classdev_match, led_cdev));
+}
+EXPORT_SYMBOL_GPL(devm_led_classdev_unregister);
+
 static int __init leds_init(void)
 {
 	leds_class = class_create(THIS_MODULE, "leds");
diff --git a/include/linux/leds.h b/include/linux/leds.h
index 0287ab296689..c8a45933ab65 100644
--- a/include/linux/leds.h
+++ b/include/linux/leds.h
@@ -87,7 +87,11 @@ struct led_classdev {
 
 extern int led_classdev_register(struct device *parent,
 				 struct led_classdev *led_cdev);
+extern int devm_led_classdev_register(struct device *parent,
+				      struct led_classdev *led_cdev);
 extern void led_classdev_unregister(struct led_classdev *led_cdev);
+extern void devm_led_classdev_unregister(struct device *parent,
+					 struct led_classdev *led_cdev);
 extern void led_classdev_suspend(struct led_classdev *led_cdev);
 extern void led_classdev_resume(struct led_classdev *led_cdev);
 
