cxl: Support the cxl kernel API from a guest

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Frederic Barrat <fbarrat@linux.vnet.ibm.com>
commit d601ea918b878582e60b773f2f943d8d292b2abf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d601ea91.failed

Like on bare-metal, the cxl driver creates a virtual PHB and a pci
device for the AFU. The configuration space of the device is mapped to
the configuration record of the AFU.

Reuse the code defined in afu_cr_read8|16|32() when reading the
configuration space of the AFU device.

Even though the (virtual) AFU device is a pci device, the adapter is
not. So a driver using the cxl kernel API cannot read the VPD of the
adapter through the usual PCI interface. Therefore, we add a call to
the cxl kernel API:
ssize_t cxl_read_adapter_vpd(struct pci_dev *dev, void *buf, size_t count);

Co-authored-by: Christophe Lombard <clombard@linux.vnet.ibm.com>
	Signed-off-by: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
	Signed-off-by: Christophe Lombard <clombard@linux.vnet.ibm.com>
	Reviewed-by: Manoj Kumar <manoj@linux.vnet.ibm.com>
	Acked-by: Ian Munsie <imunsie@au1.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit d601ea918b878582e60b773f2f943d8d292b2abf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/cxl/api.c
#	drivers/misc/cxl/cxl.h
#	drivers/misc/cxl/guest.c
#	drivers/misc/cxl/native.c
#	drivers/misc/cxl/pci.c
#	drivers/misc/cxl/vphb.c
diff --cc drivers/misc/cxl/api.c
index b45d857b0207,75ec2f9afe71..000000000000
--- a/drivers/misc/cxl/api.c
+++ b/drivers/misc/cxl/api.c
@@@ -89,21 -89,6 +89,24 @@@ int cxl_release_context(struct cxl_cont
  }
  EXPORT_SYMBOL_GPL(cxl_release_context);
  
++<<<<<<< HEAD
 +int cxl_allocate_afu_irqs(struct cxl_context *ctx, int num)
 +{
 +	if (num == 0)
 +		num = ctx->afu->pp_irqs;
 +	return afu_allocate_irqs(ctx, num);
 +}
 +EXPORT_SYMBOL_GPL(cxl_allocate_afu_irqs);
 +
 +void cxl_free_afu_irqs(struct cxl_context *ctx)
 +{
 +	afu_irq_name_free(ctx);
 +	cxl_release_irq_ranges(&ctx->irqs, ctx->afu->adapter);
 +}
 +EXPORT_SYMBOL_GPL(cxl_free_afu_irqs);
 +
++=======
++>>>>>>> d601ea918b87 (cxl: Support the cxl kernel API from a guest)
  static irq_hw_number_t cxl_find_afu_irq(struct cxl_context *ctx, int num)
  {
  	__u16 range;
diff --cc drivers/misc/cxl/cxl.h
index ea4888bb5ce4,b388c971810f..000000000000
--- a/drivers/misc/cxl/cxl.h
+++ b/drivers/misc/cxl/cxl.h
@@@ -519,14 -579,15 +519,20 @@@ struct cxl 
  	bool perst_same_image;
  };
  
 -int cxl_pci_alloc_one_irq(struct cxl *adapter);
 -void cxl_pci_release_one_irq(struct cxl *adapter, int hwirq);
 -int cxl_pci_alloc_irq_ranges(struct cxl_irq_ranges *irqs, struct cxl *adapter, unsigned int num);
 -void cxl_pci_release_irq_ranges(struct cxl_irq_ranges *irqs, struct cxl *adapter);
 -int cxl_pci_setup_irq(struct cxl *adapter, unsigned int hwirq, unsigned int virq);
 +int cxl_alloc_one_irq(struct cxl *adapter);
 +void cxl_release_one_irq(struct cxl *adapter, int hwirq);
 +int cxl_alloc_irq_ranges(struct cxl_irq_ranges *irqs, struct cxl *adapter, unsigned int num);
 +void cxl_release_irq_ranges(struct cxl_irq_ranges *irqs, struct cxl *adapter);
 +int cxl_setup_irq(struct cxl *adapter, unsigned int hwirq, unsigned int virq);
  int cxl_update_image_control(struct cxl *adapter);
++<<<<<<< HEAD
 +int cxl_reset(struct cxl *adapter);
 +void cxl_release_afu(struct device *dev);
++=======
+ int cxl_pci_reset(struct cxl *adapter);
+ void cxl_pci_release_afu(struct device *dev);
+ ssize_t cxl_pci_read_adapter_vpd(struct cxl *adapter, void *buf, size_t len);
++>>>>>>> d601ea918b87 (cxl: Support the cxl kernel API from a guest)
  
  /* common == phyp + powernv */
  struct cxl_process_element_common {
@@@ -768,7 -812,70 +774,72 @@@ int cxl_pci_vphb_add(struct cxl_afu *af
  void cxl_pci_vphb_remove(struct cxl_afu *afu);
  
  extern struct pci_driver cxl_pci_driver;
 -extern struct platform_driver cxl_of_driver;
  int afu_allocate_irqs(struct cxl_context *ctx, u32 count);
  
++<<<<<<< HEAD
++=======
+ int afu_open(struct inode *inode, struct file *file);
+ int afu_release(struct inode *inode, struct file *file);
+ long afu_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+ int afu_mmap(struct file *file, struct vm_area_struct *vm);
+ unsigned int afu_poll(struct file *file, struct poll_table_struct *poll);
+ ssize_t afu_read(struct file *file, char __user *buf, size_t count, loff_t *off);
+ extern const struct file_operations afu_fops;
+ 
+ struct cxl *cxl_guest_init_adapter(struct device_node *np, struct platform_device *dev);
+ void cxl_guest_remove_adapter(struct cxl *adapter);
+ int cxl_of_read_adapter_handle(struct cxl *adapter, struct device_node *np);
+ int cxl_of_read_adapter_properties(struct cxl *adapter, struct device_node *np);
+ ssize_t cxl_guest_read_adapter_vpd(struct cxl *adapter, void *buf, size_t len);
+ ssize_t cxl_guest_read_afu_vpd(struct cxl_afu *afu, void *buf, size_t len);
+ int cxl_guest_init_afu(struct cxl *adapter, int slice, struct device_node *afu_np);
+ void cxl_guest_remove_afu(struct cxl_afu *afu);
+ int cxl_of_read_afu_handle(struct cxl_afu *afu, struct device_node *afu_np);
+ int cxl_of_read_afu_properties(struct cxl_afu *afu, struct device_node *afu_np);
+ int cxl_guest_add_chardev(struct cxl *adapter);
+ void cxl_guest_remove_chardev(struct cxl *adapter);
+ void cxl_guest_reload_module(struct cxl *adapter);
+ int cxl_of_probe(struct platform_device *pdev);
+ 
+ struct cxl_backend_ops {
+ 	struct module *module;
+ 	int (*adapter_reset)(struct cxl *adapter);
+ 	int (*alloc_one_irq)(struct cxl *adapter);
+ 	void (*release_one_irq)(struct cxl *adapter, int hwirq);
+ 	int (*alloc_irq_ranges)(struct cxl_irq_ranges *irqs,
+ 				struct cxl *adapter, unsigned int num);
+ 	void (*release_irq_ranges)(struct cxl_irq_ranges *irqs,
+ 				struct cxl *adapter);
+ 	int (*setup_irq)(struct cxl *adapter, unsigned int hwirq,
+ 			unsigned int virq);
+ 	irqreturn_t (*handle_psl_slice_error)(struct cxl_context *ctx,
+ 					u64 dsisr, u64 errstat);
+ 	irqreturn_t (*psl_interrupt)(int irq, void *data);
+ 	int (*ack_irq)(struct cxl_context *ctx, u64 tfc, u64 psl_reset_mask);
+ 	int (*attach_process)(struct cxl_context *ctx, bool kernel,
+ 			u64 wed, u64 amr);
+ 	int (*detach_process)(struct cxl_context *ctx);
+ 	bool (*support_attributes)(const char *attr_name, enum cxl_attrs type);
+ 	bool (*link_ok)(struct cxl *cxl);
+ 	void (*release_afu)(struct device *dev);
+ 	ssize_t (*afu_read_err_buffer)(struct cxl_afu *afu, char *buf,
+ 				loff_t off, size_t count);
+ 	int (*afu_check_and_enable)(struct cxl_afu *afu);
+ 	int (*afu_activate_mode)(struct cxl_afu *afu, int mode);
+ 	int (*afu_deactivate_mode)(struct cxl_afu *afu, int mode);
+ 	int (*afu_reset)(struct cxl_afu *afu);
+ 	int (*afu_cr_read8)(struct cxl_afu *afu, int cr_idx, u64 offset, u8 *val);
+ 	int (*afu_cr_read16)(struct cxl_afu *afu, int cr_idx, u64 offset, u16 *val);
+ 	int (*afu_cr_read32)(struct cxl_afu *afu, int cr_idx, u64 offset, u32 *val);
+ 	int (*afu_cr_read64)(struct cxl_afu *afu, int cr_idx, u64 offset, u64 *val);
+ 	int (*afu_cr_write8)(struct cxl_afu *afu, int cr_idx, u64 offset, u8 val);
+ 	int (*afu_cr_write16)(struct cxl_afu *afu, int cr_idx, u64 offset, u16 val);
+ 	int (*afu_cr_write32)(struct cxl_afu *afu, int cr_idx, u64 offset, u32 val);
+ 	ssize_t (*read_adapter_vpd)(struct cxl *adapter, void *buf, size_t count);
+ };
+ extern const struct cxl_backend_ops cxl_native_ops;
+ extern const struct cxl_backend_ops cxl_guest_ops;
+ extern const struct cxl_backend_ops *cxl_ops;
+ 
++>>>>>>> d601ea918b87 (cxl: Support the cxl kernel API from a guest)
  #endif
diff --cc drivers/misc/cxl/native.c
index 588c4e3aa772,e564ae657584..000000000000
--- a/drivers/misc/cxl/native.c
+++ b/drivers/misc/cxl/native.c
@@@ -998,7 -1011,87 +998,87 @@@ u8 cxl_afu_cr_read8(struct cxl_afu *afu
  {
  	u64 aligned_off = off & ~0x3L;
  	u32 val;
 -	int rc;
  
 -	rc = native_afu_cr_read32(afu, cr, aligned_off, &val);
 -	if (!rc)
 -		*out = (val >> ((off & 0x3) * 8)) & 0xff;
 -	return rc;
 +	val = cxl_afu_cr_read32(afu, cr, aligned_off);
 +	return (val >> ((off & 0x3) * 8)) & 0xff;
  }
++<<<<<<< HEAD
++=======
+ 
+ static int native_afu_cr_write32(struct cxl_afu *afu, int cr, u64 off, u32 in)
+ {
+ 	if (unlikely(!cxl_ops->link_ok(afu->adapter)))
+ 		return -EIO;
+ 	if (unlikely(off >= afu->crs_len))
+ 		return -ERANGE;
+ 	out_le32(afu->native->afu_desc_mmio + afu->crs_offset +
+ 		(cr * afu->crs_len) + off, in);
+ 	return 0;
+ }
+ 
+ static int native_afu_cr_write16(struct cxl_afu *afu, int cr, u64 off, u16 in)
+ {
+ 	u64 aligned_off = off & ~0x3L;
+ 	u32 val32, mask, shift;
+ 	int rc;
+ 
+ 	rc = native_afu_cr_read32(afu, cr, aligned_off, &val32);
+ 	if (rc)
+ 		return rc;
+ 	shift = (off & 0x3) * 8;
+ 	WARN_ON(shift == 24);
+ 	mask = 0xffff << shift;
+ 	val32 = (val32 & ~mask) | (in << shift);
+ 
+ 	rc = native_afu_cr_write32(afu, cr, aligned_off, val32);
+ 	return rc;
+ }
+ 
+ static int native_afu_cr_write8(struct cxl_afu *afu, int cr, u64 off, u8 in)
+ {
+ 	u64 aligned_off = off & ~0x3L;
+ 	u32 val32, mask, shift;
+ 	int rc;
+ 
+ 	rc = native_afu_cr_read32(afu, cr, aligned_off, &val32);
+ 	if (rc)
+ 		return rc;
+ 	shift = (off & 0x3) * 8;
+ 	mask = 0xff << shift;
+ 	val32 = (val32 & ~mask) | (in << shift);
+ 
+ 	rc = native_afu_cr_write32(afu, cr, aligned_off, val32);
+ 	return rc;
+ }
+ 
+ const struct cxl_backend_ops cxl_native_ops = {
+ 	.module = THIS_MODULE,
+ 	.adapter_reset = cxl_pci_reset,
+ 	.alloc_one_irq = cxl_pci_alloc_one_irq,
+ 	.release_one_irq = cxl_pci_release_one_irq,
+ 	.alloc_irq_ranges = cxl_pci_alloc_irq_ranges,
+ 	.release_irq_ranges = cxl_pci_release_irq_ranges,
+ 	.setup_irq = cxl_pci_setup_irq,
+ 	.handle_psl_slice_error = native_handle_psl_slice_error,
+ 	.psl_interrupt = NULL,
+ 	.ack_irq = native_ack_irq,
+ 	.attach_process = native_attach_process,
+ 	.detach_process = native_detach_process,
+ 	.support_attributes = native_support_attributes,
+ 	.link_ok = cxl_adapter_link_ok,
+ 	.release_afu = cxl_pci_release_afu,
+ 	.afu_read_err_buffer = cxl_pci_afu_read_err_buffer,
+ 	.afu_check_and_enable = native_afu_check_and_enable,
+ 	.afu_activate_mode = native_afu_activate_mode,
+ 	.afu_deactivate_mode = native_afu_deactivate_mode,
+ 	.afu_reset = native_afu_reset,
+ 	.afu_cr_read8 = native_afu_cr_read8,
+ 	.afu_cr_read16 = native_afu_cr_read16,
+ 	.afu_cr_read32 = native_afu_cr_read32,
+ 	.afu_cr_read64 = native_afu_cr_read64,
+ 	.afu_cr_write8 = native_afu_cr_write8,
+ 	.afu_cr_write16 = native_afu_cr_write16,
+ 	.afu_cr_write32 = native_afu_cr_write32,
+ 	.read_adapter_vpd = cxl_pci_read_adapter_vpd,
+ };
++>>>>>>> d601ea918b87 (cxl: Support the cxl kernel API from a guest)
diff --cc drivers/misc/cxl/pci.c
index c7dc27fa6ee0,6cae0445a7c8..000000000000
--- a/drivers/misc/cxl/pci.c
+++ b/drivers/misc/cxl/pci.c
@@@ -1290,10 -1278,9 +1296,14 @@@ static void cxl_remove(struct pci_dev *
  	 */
  	for (i = 0; i < adapter->slices; i++) {
  		afu = adapter->afu[i];
++<<<<<<< HEAD
 +		cxl_pci_vphb_remove(afu);
 +		cxl_remove_afu(afu);
++=======
+ 		cxl_pci_remove_afu(afu);
++>>>>>>> d601ea918b87 (cxl: Support the cxl kernel API from a guest)
  	}
 -	cxl_pci_remove_adapter(adapter);
 +	cxl_remove_adapter(adapter);
  }
  
  static pci_ers_result_t cxl_vphb_error_detected(struct cxl_afu *afu,
diff --cc drivers/misc/cxl/vphb.c
index cbd4331fb45c,c960a09a4232..000000000000
--- a/drivers/misc/cxl/vphb.c
+++ b/drivers/misc/cxl/vphb.c
@@@ -144,26 -120,6 +120,29 @@@ static int cxl_pcie_config_info(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
 +
 +static inline bool cxl_config_link_ok(struct pci_bus *bus)
 +{
 +	struct pci_controller *phb;
 +	struct cxl_afu *afu;
 +
 +	/* Config space IO is based on phb->cfg_addr, which is based on
 +	 * afu_desc_mmio. This isn't safe to read/write when the link
 +	 * goes down, as EEH tears down MMIO space.
 +	 *
 +	 * Check if the link is OK before proceeding.
 +	 */
 +
 +	phb = pci_bus_to_host(bus);
 +	if (phb == NULL)
 +		return false;
 +	afu = (struct cxl_afu *)phb->private_data;
 +	return cxl_adapter_link_ok(afu->adapter);
 +}
 +
++=======
++>>>>>>> d601ea918b87 (cxl: Support the cxl kernel API from a guest)
  static int cxl_pcie_read_config(struct pci_bus *bus, unsigned int devfn,
  				int offset, int len, u32 *val)
  {
@@@ -248,8 -233,8 +256,13 @@@ int cxl_pci_vphb_add(struct cxl_afu *af
  
  	/* Setup the PHB using arch provided callback */
  	phb->ops = &cxl_pcie_pci_ops;
++<<<<<<< HEAD
 +	phb->cfg_addr = afu->afu_desc_mmio + afu->crs_offset;
 +	phb->cfg_data = (void *)(u64)afu->crs_len;
++=======
+ 	phb->cfg_addr = NULL;
+ 	phb->cfg_data = 0;
++>>>>>>> d601ea918b87 (cxl: Support the cxl kernel API from a guest)
  	phb->private_data = afu;
  	phb->controller_ops = cxl_pci_controller_ops;
  
@@@ -272,15 -257,6 +285,18 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +void cxl_pci_vphb_reconfigure(struct cxl_afu *afu)
 +{
 +	/* When we are reconfigured, the AFU's MMIO space is unmapped
 +	 * and remapped. We need to reflect this in the PHB's view of
 +	 * the world.
 +	 */
 +	afu->phb->cfg_addr = afu->afu_desc_mmio + afu->crs_offset;
 +}
 +
++=======
++>>>>>>> d601ea918b87 (cxl: Support the cxl kernel API from a guest)
  void cxl_pci_vphb_remove(struct cxl_afu *afu)
  {
  	struct pci_controller *phb;
* Unmerged path drivers/misc/cxl/guest.c
* Unmerged path drivers/misc/cxl/api.c
* Unmerged path drivers/misc/cxl/cxl.h
* Unmerged path drivers/misc/cxl/guest.c
* Unmerged path drivers/misc/cxl/native.c
* Unmerged path drivers/misc/cxl/pci.c
* Unmerged path drivers/misc/cxl/vphb.c
diff --git a/include/misc/cxl.h b/include/misc/cxl.h
index f2ffe5bd720d..5bcf11a29f2a 100644
--- a/include/misc/cxl.h
+++ b/include/misc/cxl.h
@@ -210,4 +210,9 @@ ssize_t cxl_fd_read(struct file *file, char __user *buf, size_t count,
 void cxl_perst_reloads_same_image(struct cxl_afu *afu,
 				  bool perst_reloads_same_image);
 
+/*
+ * Read the VPD for the card where the AFU resides
+ */
+ssize_t cxl_read_adapter_vpd(struct pci_dev *dev, void *buf, size_t count);
+
 #endif /* _MISC_CXL_H */
