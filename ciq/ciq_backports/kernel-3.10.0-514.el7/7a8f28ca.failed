IB/hfi1: Remove unused HFI1_DO_INIT_ASIC flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dean Luick <dean.luick@intel.com>
commit 7a8f28ca3daa61dc48046b4f1fa73139fb47bbfe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7a8f28ca.failed

The flag HFI1_DO_INIT_ASIC flag is no longer used.  Remove
the flag and the code that sets it.

	Reviewed-by: Mitko Haralanov <mitko.haralanov@intel.com>
	Reviewed-by: Easwar Hariharan <easwar.hariharan@intel.com>
	Signed-off-by: Dean Luick <dean.luick@intel.com>
	Signed-off-by: Jubin John <jubin.john@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 7a8f28ca3daa61dc48046b4f1fa73139fb47bbfe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/chip.c
diff --cc drivers/staging/hfi1/chip.c
index cf871fab9b57,ac0345257b9c..000000000000
--- a/drivers/staging/hfi1/chip.c
+++ b/drivers/staging/hfi1/chip.c
@@@ -13880,12 -13812,11 +13880,18 @@@ void hfi1_start_cleanup(struct hfi1_dev
  	((dev)->base_guid & ~(1ULL << GUID_HFI_INDEX_SHIFT))
  
  /*
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 + * Certain chip functions need to be initialized only once per asic
 + * instead of per-device. This function finds the peer device and
 + * checks whether that chip initialization needs to be done by this
 + * device.
++=======
+  * Information can be shared between the two HFIs on the same ASIC
+  * in the same OS.  This function finds the peer device and sets
+  * up a shared structure.
++>>>>>>> 7a8f28ca3daa (IB/hfi1: Remove unused HFI1_DO_INIT_ASIC flag):drivers/staging/rdma/hfi1/chip.c
   */
 -static int init_asic_data(struct hfi1_devdata *dd)
 +static void asic_should_init(struct hfi1_devdata *dd)
  {
  	unsigned long flags;
  	struct hfi1_devdata *tmp, *peer = NULL;
@@@ -13900,13 -13832,91 +13906,29 @@@
  		}
  	}
  
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +	/*
 +	 * "Claim" the ASIC for initialization if it hasn't been
 +	 " "claimed" yet.
 +	 */
 +	if (!peer || !(peer->flags & HFI1_DO_INIT_ASIC))
 +		dd->flags |= HFI1_DO_INIT_ASIC;
++=======
+ 	if (peer) {
+ 		dd->asic_data = peer->asic_data;
+ 	} else {
+ 		dd->asic_data = kzalloc(sizeof(*dd->asic_data), GFP_KERNEL);
+ 		if (!dd->asic_data) {
+ 			ret = -ENOMEM;
+ 			goto done;
+ 		}
+ 		mutex_init(&dd->asic_data->asic_resource_mutex);
+ 	}
+ 	dd->asic_data->dds[dd->hfi1_id] = dd; /* self back-pointer */
+ 
+ done:
++>>>>>>> 7a8f28ca3daa (IB/hfi1: Remove unused HFI1_DO_INIT_ASIC flag):drivers/staging/rdma/hfi1/chip.c
  	spin_unlock_irqrestore(&hfi1_devs_lock, flags);
 -	return ret;
 -}
 -
 -/*
 - * Set dd->boardname.  Use a generic name if a name is not returned from
 - * EFI variable space.
 - *
 - * Return 0 on success, -ENOMEM if space could not be allocated.
 - */
 -static int obtain_boardname(struct hfi1_devdata *dd)
 -{
 -	/* generic board description */
 -	const char generic[] =
 -		"Intel Omni-Path Host Fabric Interface Adapter 100 Series";
 -	unsigned long size;
 -	int ret;
 -
 -	ret = read_hfi1_efi_var(dd, "description", &size,
 -				(void **)&dd->boardname);
 -	if (ret) {
 -		dd_dev_info(dd, "Board description not found\n");
 -		/* use generic description */
 -		dd->boardname = kstrdup(generic, GFP_KERNEL);
 -		if (!dd->boardname)
 -			return -ENOMEM;
 -	}
 -	return 0;
 -}
 -
 -/*
 - * Check the interrupt registers to make sure that they are mapped correctly.
 - * It is intended to help user identify any mismapping by VMM when the driver
 - * is running in a VM. This function should only be called before interrupt
 - * is set up properly.
 - *
 - * Return 0 on success, -EINVAL on failure.
 - */
 -static int check_int_registers(struct hfi1_devdata *dd)
 -{
 -	u64 reg;
 -	u64 all_bits = ~(u64)0;
 -	u64 mask;
 -
 -	/* Clear CceIntMask[0] to avoid raising any interrupts */
 -	mask = read_csr(dd, CCE_INT_MASK);
 -	write_csr(dd, CCE_INT_MASK, 0ull);
 -	reg = read_csr(dd, CCE_INT_MASK);
 -	if (reg)
 -		goto err_exit;
 -
 -	/* Clear all interrupt status bits */
 -	write_csr(dd, CCE_INT_CLEAR, all_bits);
 -	reg = read_csr(dd, CCE_INT_STATUS);
 -	if (reg)
 -		goto err_exit;
 -
 -	/* Set all interrupt status bits */
 -	write_csr(dd, CCE_INT_FORCE, all_bits);
 -	reg = read_csr(dd, CCE_INT_STATUS);
 -	if (reg != all_bits)
 -		goto err_exit;
 -
 -	/* Restore the interrupt mask */
 -	write_csr(dd, CCE_INT_CLEAR, all_bits);
 -	write_csr(dd, CCE_INT_MASK, mask);
 -
 -	return 0;
 -err_exit:
 -	write_csr(dd, CCE_INT_MASK, mask);
 -	dd_dev_err(dd, "Interrupt registers not properly mapped by VMM\n");
 -	return -EINVAL;
  }
  
  /**
* Unmerged path drivers/staging/hfi1/chip.c
diff --git a/drivers/staging/hfi1/hfi.h b/drivers/staging/hfi1/hfi.h
index 6438dccf5749..1bea51190a75 100644
--- a/drivers/staging/hfi1/hfi.h
+++ b/drivers/staging/hfi1/hfi.h
@@ -1558,7 +1558,6 @@ static inline struct cc_state *get_cc_state(struct hfi1_pportdata *ppd)
 #define HFI1_HAS_SDMA_TIMEOUT  0x8
 #define HFI1_HAS_SEND_DMA      0x10   /* Supports Send DMA */
 #define HFI1_FORCED_FREEZE     0x80   /* driver forced freeze mode */
-#define HFI1_DO_INIT_ASIC      0x100  /* This device will init the ASIC */
 
 /* IB dword length mask in PBC (lower 11 bits); same for all chips */
 #define HFI1_PBC_LENGTH_MASK                     ((1 << 11) - 1)
