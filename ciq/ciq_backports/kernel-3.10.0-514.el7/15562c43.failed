GFS2: Move glock superblock pointer to field gl_name

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit 15562c439d0a1850b71aa1c0d92d1f4fb9503c8d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/15562c43.failed

What uniquely identifies a glock in the glock hash table is not
gl_name, but gl_name and its superblock pointer. This patch makes
the gl_name field correspond to a unique glock identifier. That will
allow us to simplify hashing with a future patch, since the hash
algorithm can then take the gl_name and hash its components in one
operation.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Acked-by: Steven Whitehouse <swhiteho@redhat.com>
(cherry picked from commit 15562c439d0a1850b71aa1c0d92d1f4fb9503c8d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glops.c
#	fs/gfs2/lops.c
#	fs/gfs2/meta_io.h
#	fs/gfs2/quota.c
diff --cc fs/gfs2/glops.c
index 4522e7845260,1f6c9c3fe5cb..000000000000
--- a/fs/gfs2/glops.c
+++ b/fs/gfs2/glops.c
@@@ -28,15 -28,19 +28,17 @@@
  #include "trans.h"
  #include "dir.h"
  
 -struct workqueue_struct *gfs2_freeze_wq;
 -
  static void gfs2_ail_error(struct gfs2_glock *gl, const struct buffer_head *bh)
  {
- 	fs_err(gl->gl_sbd, "AIL buffer %p: blocknr %llu state 0x%08lx mapping %p page state 0x%lx\n",
+ 	fs_err(gl->gl_name.ln_sbd,
+ 	       "AIL buffer %p: blocknr %llu state 0x%08lx mapping %p page "
+ 	       "state 0x%lx\n",
  	       bh, (unsigned long long)bh->b_blocknr, bh->b_state,
  	       bh->b_page->mapping, bh->b_page->flags);
- 	fs_err(gl->gl_sbd, "AIL glock %u:%llu mapping %p\n",
+ 	fs_err(gl->gl_name.ln_sbd, "AIL glock %u:%llu mapping %p\n",
  	       gl->gl_name.ln_type, gl->gl_name.ln_number,
  	       gfs2_glock2aspace(gl));
- 	gfs2_lm_withdraw(gl->gl_sbd, "AIL error\n");
+ 	gfs2_lm_withdraw(gl->gl_name.ln_sbd, "AIL error\n");
  }
  
  /**
@@@ -141,7 -141,8 +143,12 @@@ void gfs2_ail_flush(struct gfs2_glock *
  
  static void rgrp_go_sync(struct gfs2_glock *gl)
  {
++<<<<<<< HEAD
 +	struct address_space *metamapping = gfs2_glock2aspace(gl);
++=======
+ 	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
+ 	struct address_space *mapping = &sdp->sd_aspace;
++>>>>>>> 15562c439d0a (GFS2: Move glock superblock pointer to field gl_name)
  	struct gfs2_rgrpd *rgd;
  	int error;
  
@@@ -180,7 -181,8 +187,12 @@@
  
  static void rgrp_go_inval(struct gfs2_glock *gl, int flags)
  {
++<<<<<<< HEAD
 +	struct address_space *mapping = gfs2_glock2aspace(gl);
++=======
+ 	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
+ 	struct address_space *mapping = &sdp->sd_aspace;
++>>>>>>> 15562c439d0a (GFS2: Move glock superblock pointer to field gl_name)
  	struct gfs2_rgrpd *rgd = gl->gl_object;
  
  	if (rgd)
@@@ -218,7 -220,7 +230,11 @@@ static void inode_go_sync(struct gfs2_g
  
  	GLOCK_BUG_ON(gl, gl->gl_state != LM_ST_EXCLUSIVE);
  
++<<<<<<< HEAD
 +	gfs2_log_flush(gl->gl_sbd, gl);
++=======
+ 	gfs2_log_flush(gl->gl_name.ln_sbd, gl, NORMAL_FLUSH);
++>>>>>>> 15562c439d0a (GFS2: Move glock superblock pointer to field gl_name)
  	filemap_fdatawrite(metamapping);
  	if (ip) {
  		struct address_space *mapping = ip->i_inode.i_mapping;
@@@ -264,9 -266,9 +280,15 @@@ static void inode_go_inval(struct gfs2_
  		}
  	}
  
++<<<<<<< HEAD
 +	if (ip == GFS2_I(gl->gl_sbd->sd_rindex)) {
 +		gfs2_log_flush(gl->gl_sbd, NULL);
 +		gl->gl_sbd->sd_rindex_uptodate = 0;
++=======
+ 	if (ip == GFS2_I(gl->gl_name.ln_sbd->sd_rindex)) {
+ 		gfs2_log_flush(gl->gl_name.ln_sbd, NULL, NORMAL_FLUSH);
+ 		gl->gl_name.ln_sbd->sd_rindex_uptodate = 0;
++>>>>>>> 15562c439d0a (GFS2: Move glock superblock pointer to field gl_name)
  	}
  	if (ip && S_ISREG(ip->i_inode.i_mode))
  		truncate_inode_pages(ip->i_inode.i_mapping, 0);
@@@ -476,14 -476,21 +498,19 @@@ static int inode_go_dump(struct seq_fil
   *
   */
  
 -static void freeze_go_sync(struct gfs2_glock *gl)
 +static void trans_go_sync(struct gfs2_glock *gl)
  {
++<<<<<<< HEAD
 +	struct gfs2_sbd *sdp = gl->gl_sbd;
++=======
+ 	int error = 0;
+ 	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
++>>>>>>> 15562c439d0a (GFS2: Move glock superblock pointer to field gl_name)
  
 -	if (gl->gl_state == LM_ST_SHARED &&
 +	if (gl->gl_state != LM_ST_UNLOCKED &&
  	    test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags)) {
 -		atomic_set(&sdp->sd_freeze_state, SFS_STARTING_FREEZE);
 -		error = freeze_super(sdp->sd_vfs);
 -		if (error) {
 -			printk(KERN_INFO "GFS2: couldn't freeze filesystem: %d\n", error);
 -			gfs2_assert_withdraw(sdp, 0);
 -		}
 -		queue_work(gfs2_freeze_wq, &sdp->sd_freeze_work);
 -		gfs2_log_flush(sdp, NULL, FREEZE_FLUSH);
 +		gfs2_meta_syncfs(sdp);
 +		gfs2_log_shutdown(sdp);
  	}
  }
  
@@@ -493,9 -500,9 +520,9 @@@
   *
   */
  
 -static int freeze_go_xmote_bh(struct gfs2_glock *gl, struct gfs2_holder *gh)
 +static int trans_go_xmote_bh(struct gfs2_glock *gl, struct gfs2_holder *gh)
  {
- 	struct gfs2_sbd *sdp = gl->gl_sbd;
+ 	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
  	struct gfs2_inode *ip = GFS2_I(sdp->sd_jdesc->jd_inode);
  	struct gfs2_glock *j_gl = ip->i_gl;
  	struct gfs2_log_header_host head;
diff --cc fs/gfs2/lops.c
index 382071679b7f,7833394a9a20..000000000000
--- a/fs/gfs2/lops.c
+++ b/fs/gfs2/lops.c
@@@ -562,6 -576,28 +562,31 @@@ static int buf_lo_scan_elements(struct 
  	return error;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * gfs2_meta_sync - Sync all buffers associated with a glock
+  * @gl: The glock
+  *
+  */
+ 
+ static void gfs2_meta_sync(struct gfs2_glock *gl)
+ {
+ 	struct address_space *mapping = gfs2_glock2aspace(gl);
+ 	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
+ 	int error;
+ 
+ 	if (mapping == NULL)
+ 		mapping = &sdp->sd_aspace;
+ 
+ 	filemap_fdatawrite(mapping);
+ 	error = filemap_fdatawait(mapping);
+ 
+ 	if (error)
+ 		gfs2_io_error(gl->gl_name.ln_sbd);
+ }
+ 
++>>>>>>> 15562c439d0a (GFS2: Move glock superblock pointer to field gl_name)
  static void buf_lo_after_scan(struct gfs2_jdesc *jd, int error, int pass)
  {
  	struct gfs2_inode *ip = GFS2_I(jd->jd_inode);
diff --cc fs/gfs2/meta_io.h
index 0d4c843b6f8e,8ca161567a93..000000000000
--- a/fs/gfs2/meta_io.h
+++ b/fs/gfs2/meta_io.h
@@@ -43,7 -44,9 +43,13 @@@ static inline struct gfs2_sbd *gfs2_map
  {
  	struct inode *inode = mapping->host;
  	if (mapping->a_ops == &gfs2_meta_aops)
++<<<<<<< HEAD
 +		return (((struct gfs2_glock *)mapping) - 1)->gl_sbd;
++=======
+ 		return (((struct gfs2_glock *)mapping) - 1)->gl_name.ln_sbd;
+ 	else if (mapping->a_ops == &gfs2_rgrp_aops)
+ 		return container_of(mapping, struct gfs2_sbd, sd_aspace);
++>>>>>>> 15562c439d0a (GFS2: Move glock superblock pointer to field gl_name)
  	else
  		return inode->i_sb->s_fs_info;
  }
diff --cc fs/gfs2/quota.c
index 481208bbcaf7,3a31226531ea..000000000000
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@@ -913,7 -922,7 +913,11 @@@ out
  		gfs2_glock_dq_uninit(&ghs[qx]);
  	mutex_unlock(&ip->i_inode.i_mutex);
  	kfree(ghs);
++<<<<<<< HEAD
 +	gfs2_log_flush(ip->i_gl->gl_sbd, ip->i_gl);
++=======
+ 	gfs2_log_flush(ip->i_gl->gl_name.ln_sbd, ip->i_gl, NORMAL_FLUSH);
++>>>>>>> 15562c439d0a (GFS2: Move glock superblock pointer to field gl_name)
  	return error;
  }
  
@@@ -1116,12 -1125,12 +1120,12 @@@ out
  
  static int print_message(struct gfs2_quota_data *qd, char *type)
  {
- 	struct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;
+ 	struct gfs2_sbd *sdp = qd->qd_gl->gl_name.ln_sbd;
  
 -	fs_info(sdp, "quota %s for %s %u\n",
 -		type,
 -		(qd->qd_id.type == USRQUOTA) ? "user" : "group",
 -		from_kqid(&init_user_ns, qd->qd_id));
 +	printk(KERN_INFO "GFS2: fsid=%s: quota %s for %s %u\n",
 +	       sdp->sd_fsname, type,
 +	       (qd->qd_id.type == USRQUOTA) ? "user" : "group",
 +	       from_kqid(&init_user_ns, qd->qd_id));
  
  	return 0;
  }
diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index 53742d4fa4ae..c502d0ea52c8 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -117,7 +117,7 @@ static void gfs2_glock_dealloc(struct rcu_head *rcu)
 
 void gfs2_glock_free(struct gfs2_glock *gl)
 {
-	struct gfs2_sbd *sdp = gl->gl_sbd;
+	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 
 	call_rcu(&gl->gl_rcu, gfs2_glock_dealloc);
 	if (atomic_dec_and_test(&sdp->sd_glock_disposal))
@@ -195,7 +195,7 @@ static void gfs2_glock_remove_from_lru(struct gfs2_glock *gl)
 
 void gfs2_glock_put(struct gfs2_glock *gl)
 {
-	struct gfs2_sbd *sdp = gl->gl_sbd;
+	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 	struct address_space *mapping = gfs2_glock2aspace(gl);
 
 	if (lockref_put_or_lock(&gl->gl_lockref))
@@ -225,7 +225,6 @@ void gfs2_glock_put(struct gfs2_glock *gl)
  */
 
 static struct gfs2_glock *search_bucket(unsigned int hash,
-					const struct gfs2_sbd *sdp,
 					const struct lm_lockname *name)
 {
 	struct gfs2_glock *gl;
@@ -234,8 +233,6 @@ static struct gfs2_glock *search_bucket(unsigned int hash,
 	hlist_bl_for_each_entry_rcu(gl, h, &gl_hash_table[hash], gl_list) {
 		if (!lm_name_equal(&gl->gl_name, name))
 			continue;
-		if (gl->gl_sbd != sdp)
-			continue;
 		if (lockref_get_not_dead(&gl->gl_lockref))
 			return gl;
 	}
@@ -511,7 +508,7 @@ __releases(&gl->gl_spin)
 __acquires(&gl->gl_spin)
 {
 	const struct gfs2_glock_operations *glops = gl->gl_ops;
-	struct gfs2_sbd *sdp = gl->gl_sbd;
+	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 	unsigned int lck_flags = gh ? gh->gh_flags : 0;
 	int ret;
 
@@ -633,7 +630,7 @@ out_unlock:
 static void delete_work_func(struct work_struct *work)
 {
 	struct gfs2_glock *gl = container_of(work, struct gfs2_glock, gl_delete);
-	struct gfs2_sbd *sdp = gl->gl_sbd;
+	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 	struct gfs2_inode *ip;
 	struct inode *inode;
 	u64 no_addr = gl->gl_name.ln_number;
@@ -709,14 +706,16 @@ int gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,
 		   struct gfs2_glock **glp)
 {
 	struct super_block *s = sdp->sd_vfs;
-	struct lm_lockname name = { .ln_number = number, .ln_type = glops->go_type };
+	struct lm_lockname name = { .ln_number = number,
+				    .ln_type = glops->go_type,
+				    .ln_sbd = sdp };
 	struct gfs2_glock *gl, *tmp;
 	unsigned int hash = gl_hash(sdp, &name);
 	struct address_space *mapping;
 	struct kmem_cache *cachep;
 
 	rcu_read_lock();
-	gl = search_bucket(hash, sdp, &name);
+	gl = search_bucket(hash, &name);
 	rcu_read_unlock();
 
 	*glp = gl;
@@ -744,7 +743,6 @@ int gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,
 	}
 
 	atomic_inc(&sdp->sd_glock_disposal);
-	gl->gl_sbd = sdp;
 	gl->gl_flags = 0;
 	gl->gl_name = name;
 	gl->gl_lockref.count = 1;
@@ -778,7 +776,7 @@ int gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,
 	}
 
 	spin_lock_bucket(hash);
-	tmp = search_bucket(hash, sdp, &name);
+	tmp = search_bucket(hash, &name);
 	if (tmp) {
 		spin_unlock_bucket(hash);
 		kfree(gl->gl_lksb.sb_lvbptr);
@@ -956,7 +954,7 @@ __releases(&gl->gl_spin)
 __acquires(&gl->gl_spin)
 {
 	struct gfs2_glock *gl = gh->gh_gl;
-	struct gfs2_sbd *sdp = gl->gl_sbd;
+	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 	struct list_head *insert_pt = NULL;
 	struct gfs2_holder *gh2;
 	int try_futile = 0;
@@ -1034,7 +1032,7 @@ trap_recursive:
 int gfs2_glock_nq(struct gfs2_holder *gh)
 {
 	struct gfs2_glock *gl = gh->gh_gl;
-	struct gfs2_sbd *sdp = gl->gl_sbd;
+	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 	int error = 0;
 
 	if (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))
@@ -1341,7 +1339,7 @@ static int gfs2_should_freeze(const struct gfs2_glock *gl)
 
 void gfs2_glock_complete(struct gfs2_glock *gl, int ret)
 {
-	struct lm_lockstruct *ls = &gl->gl_sbd->sd_lockstruct;
+	struct lm_lockstruct *ls = &gl->gl_name.ln_sbd->sd_lockstruct;
 
 	spin_lock(&gl->gl_spin);
 	gl->gl_reply = ret;
@@ -1494,7 +1492,7 @@ static void examine_bucket(glock_examiner examiner, const struct gfs2_sbd *sdp,
 
 	rcu_read_lock();
 	hlist_bl_for_each_entry_rcu(gl, pos, head, gl_list) {
-		if ((gl->gl_sbd == sdp) && lockref_get_not_dead(&gl->gl_lockref))
+		if ((gl->gl_name.ln_sbd == sdp) && lockref_get_not_dead(&gl->gl_lockref))
 			examiner(gl);
 	}
 	rcu_read_unlock();
@@ -1594,7 +1592,7 @@ void gfs2_glock_finish_truncate(struct gfs2_inode *ip)
 	int ret;
 
 	ret = gfs2_truncatei_resume(ip);
-	gfs2_assert_withdraw(gl->gl_sbd, ret == 0);
+	gfs2_assert_withdraw(gl->gl_name.ln_sbd, ret == 0);
 
 	spin_lock(&gl->gl_spin);
 	clear_bit(GLF_LOCK, &gl->gl_flags);
@@ -1903,7 +1901,7 @@ static int gfs2_glock_iter_next(struct gfs2_glock_iter *gi)
 			gi->nhash = 0;
 		}
 	/* Skip entries for other sb and dead entries */
-	} while (gi->sdp != gi->gl->gl_sbd ||
+	} while (gi->sdp != gi->gl->gl_name.ln_sbd ||
 		 __lockref_is_dead(&gi->gl->gl_lockref));
 
 	return 0;
* Unmerged path fs/gfs2/glops.c
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 2caf75dc0244..2fca0e6a7632 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -196,13 +196,15 @@ enum {
 };
 
 struct lm_lockname {
+	struct gfs2_sbd *ln_sbd;
 	u64 ln_number;
 	unsigned int ln_type;
 };
 
 #define lm_name_equal(name1, name2) \
-        (((name1)->ln_number == (name2)->ln_number) && \
-         ((name1)->ln_type == (name2)->ln_type))
+        (((name1)->ln_number == (name2)->ln_number) &&	\
+	 ((name1)->ln_type == (name2)->ln_type) &&	\
+	 ((name1)->ln_sbd == (name2)->ln_sbd))
 
 
 struct gfs2_glock_operations {
@@ -317,7 +319,6 @@ enum {
 
 struct gfs2_glock {
 	struct hlist_bl_node gl_list;
-	struct gfs2_sbd *gl_sbd;
 	unsigned long gl_flags;		/* GLF_... */
 	struct lm_lockname gl_name;
 
@@ -809,7 +810,7 @@ static inline void gfs2_glstats_inc(struct gfs2_glock *gl, int which)
 
 static inline void gfs2_sbstats_inc(const struct gfs2_glock *gl, int which)
 {
-	const struct gfs2_sbd *sdp = gl->gl_sbd;
+	const struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 	preempt_disable();
 	this_cpu_ptr(sdp->sd_lkstats)->lkstats[gl->gl_name.ln_type].stats[which]++;
 	preempt_enable();
diff --git a/fs/gfs2/lock_dlm.c b/fs/gfs2/lock_dlm.c
index c8423d6de6c3..ed7717be405d 100644
--- a/fs/gfs2/lock_dlm.c
+++ b/fs/gfs2/lock_dlm.c
@@ -78,7 +78,7 @@ static inline void gfs2_update_reply_times(struct gfs2_glock *gl)
 
 	preempt_disable();
 	rtt = ktime_to_ns(ktime_sub(ktime_get_real(), gl->gl_dstamp));
-	lks = this_cpu_ptr(gl->gl_sbd->sd_lkstats);
+	lks = this_cpu_ptr(gl->gl_name.ln_sbd->sd_lkstats);
 	gfs2_update_stats(&gl->gl_stats, index, rtt);		/* Local */
 	gfs2_update_stats(&lks->lkstats[gltype], index, rtt);	/* Global */
 	preempt_enable();
@@ -106,7 +106,7 @@ static inline void gfs2_update_request_times(struct gfs2_glock *gl)
 	dstamp = gl->gl_dstamp;
 	gl->gl_dstamp = ktime_get_real();
 	irt = ktime_to_ns(ktime_sub(gl->gl_dstamp, dstamp));
-	lks = this_cpu_ptr(gl->gl_sbd->sd_lkstats);
+	lks = this_cpu_ptr(gl->gl_name.ln_sbd->sd_lkstats);
 	gfs2_update_stats(&gl->gl_stats, GFS2_LKS_SIRT, irt);		/* Local */
 	gfs2_update_stats(&lks->lkstats[gltype], GFS2_LKS_SIRT, irt);	/* Global */
 	preempt_enable();
@@ -251,7 +251,7 @@ static void gfs2_reverse_hex(char *c, u64 value)
 static int gdlm_lock(struct gfs2_glock *gl, unsigned int req_state,
 		     unsigned int flags)
 {
-	struct lm_lockstruct *ls = &gl->gl_sbd->sd_lockstruct;
+	struct lm_lockstruct *ls = &gl->gl_name.ln_sbd->sd_lockstruct;
 	int req;
 	u32 lkf;
 	char strname[GDLM_STRNAME_BYTES] = "";
@@ -279,7 +279,7 @@ static int gdlm_lock(struct gfs2_glock *gl, unsigned int req_state,
 
 static void gdlm_put_lock(struct gfs2_glock *gl)
 {
-	struct gfs2_sbd *sdp = gl->gl_sbd;
+	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 	struct lm_lockstruct *ls = &sdp->sd_lockstruct;
 	int lvb_needs_unlock = 0;
 	int error;
@@ -317,7 +317,7 @@ static void gdlm_put_lock(struct gfs2_glock *gl)
 
 static void gdlm_cancel(struct gfs2_glock *gl)
 {
-	struct lm_lockstruct *ls = &gl->gl_sbd->sd_lockstruct;
+	struct lm_lockstruct *ls = &gl->gl_name.ln_sbd->sd_lockstruct;
 	dlm_unlock(ls->ls_dlm, gl->gl_lksb.sb_lkid, DLM_LKF_CANCEL, NULL, gl);
 }
 
* Unmerged path fs/gfs2/lops.c
diff --git a/fs/gfs2/meta_io.c b/fs/gfs2/meta_io.c
index 1a80ffddabcd..c3afe3e74692 100644
--- a/fs/gfs2/meta_io.c
+++ b/fs/gfs2/meta_io.c
@@ -127,7 +127,7 @@ void gfs2_meta_sync(struct gfs2_glock *gl)
 struct buffer_head *gfs2_getbuf(struct gfs2_glock *gl, u64 blkno, int create)
 {
 	struct address_space *mapping = gfs2_glock2aspace(gl);
-	struct gfs2_sbd *sdp = gl->gl_sbd;
+	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 	struct page *page;
 	struct buffer_head *bh;
 	unsigned int shift;
@@ -210,7 +210,7 @@ struct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)
 int gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,
 		   struct buffer_head **bhp)
 {
-	struct gfs2_sbd *sdp = gl->gl_sbd;
+	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 	struct buffer_head *bh;
 
 	if (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {
@@ -381,7 +381,7 @@ int gfs2_meta_indirect_buffer(struct gfs2_inode *ip, int height, u64 num,
 
 struct buffer_head *gfs2_meta_ra(struct gfs2_glock *gl, u64 dblock, u32 extlen)
 {
-	struct gfs2_sbd *sdp = gl->gl_sbd;
+	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 	struct buffer_head *first_bh, *bh;
 	u32 max_ra = gfs2_tune_get(sdp, gt_max_readahead) >>
 			  sdp->sd_sb.sb_bsize_shift;
* Unmerged path fs/gfs2/meta_io.h
* Unmerged path fs/gfs2/quota.c
diff --git a/fs/gfs2/rgrp.c b/fs/gfs2/rgrp.c
index 28da34fba03d..1231b9f2cbc7 100644
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@ -1825,7 +1825,7 @@ static void try_rgrp_unlink(struct gfs2_rgrpd *rgd, u64 *last_unlinked, u64 skip
 static bool gfs2_rgrp_congested(const struct gfs2_rgrpd *rgd, int loops)
 {
 	const struct gfs2_glock *gl = rgd->rd_gl;
-	const struct gfs2_sbd *sdp = gl->gl_sbd;
+	const struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 	struct gfs2_lkstats *st;
 	s64 r_dcount, l_dcount;
 	s64 l_srttb, a_srttb = 0;
diff --git a/fs/gfs2/trace_gfs2.h b/fs/gfs2/trace_gfs2.h
index 20c007d747ab..fff47d0e0ef5 100644
--- a/fs/gfs2/trace_gfs2.h
+++ b/fs/gfs2/trace_gfs2.h
@@ -104,7 +104,7 @@ TRACE_EVENT(gfs2_glock_state_change,
 	),
 
 	TP_fast_assign(
-		__entry->dev		= gl->gl_sbd->sd_vfs->s_dev;
+		__entry->dev		= gl->gl_name.ln_sbd->sd_vfs->s_dev;
 		__entry->glnum		= gl->gl_name.ln_number;
 		__entry->gltype		= gl->gl_name.ln_type;
 		__entry->cur_state	= glock_trace_state(gl->gl_state);
@@ -140,7 +140,7 @@ TRACE_EVENT(gfs2_glock_put,
 	),
 
 	TP_fast_assign(
-		__entry->dev		= gl->gl_sbd->sd_vfs->s_dev;
+		__entry->dev		= gl->gl_name.ln_sbd->sd_vfs->s_dev;
 		__entry->gltype		= gl->gl_name.ln_type;
 		__entry->glnum		= gl->gl_name.ln_number;
 		__entry->cur_state	= glock_trace_state(gl->gl_state);
@@ -174,7 +174,7 @@ TRACE_EVENT(gfs2_demote_rq,
 	),
 
 	TP_fast_assign(
-		__entry->dev		= gl->gl_sbd->sd_vfs->s_dev;
+		__entry->dev		= gl->gl_name.ln_sbd->sd_vfs->s_dev;
 		__entry->gltype		= gl->gl_name.ln_type;
 		__entry->glnum		= gl->gl_name.ln_number;
 		__entry->cur_state	= glock_trace_state(gl->gl_state);
@@ -209,7 +209,7 @@ TRACE_EVENT(gfs2_promote,
 	),
 
 	TP_fast_assign(
-		__entry->dev	= gh->gh_gl->gl_sbd->sd_vfs->s_dev;
+		__entry->dev	= gh->gh_gl->gl_name.ln_sbd->sd_vfs->s_dev;
 		__entry->glnum	= gh->gh_gl->gl_name.ln_number;
 		__entry->gltype	= gh->gh_gl->gl_name.ln_type;
 		__entry->first	= first;
@@ -239,7 +239,7 @@ TRACE_EVENT(gfs2_glock_queue,
 	),
 
 	TP_fast_assign(
-		__entry->dev	= gh->gh_gl->gl_sbd->sd_vfs->s_dev;
+		__entry->dev	= gh->gh_gl->gl_name.ln_sbd->sd_vfs->s_dev;
 		__entry->glnum	= gh->gh_gl->gl_name.ln_number;
 		__entry->gltype	= gh->gh_gl->gl_name.ln_type;
 		__entry->queue	= queue;
@@ -278,7 +278,7 @@ TRACE_EVENT(gfs2_glock_lock_time,
 	),
 
 	TP_fast_assign(
-		__entry->dev            = gl->gl_sbd->sd_vfs->s_dev;
+		__entry->dev            = gl->gl_name.ln_sbd->sd_vfs->s_dev;
 		__entry->glnum          = gl->gl_name.ln_number;
 		__entry->gltype         = gl->gl_name.ln_type;
 		__entry->status		= gl->gl_lksb.sb_status;
@@ -333,7 +333,7 @@ TRACE_EVENT(gfs2_pin,
 	),
 
 	TP_fast_assign(
-		__entry->dev		= bd->bd_gl->gl_sbd->sd_vfs->s_dev;
+		__entry->dev		= bd->bd_gl->gl_name.ln_sbd->sd_vfs->s_dev;
 		__entry->pin		= pin;
 		__entry->len		= bd->bd_bh->b_size;
 		__entry->block		= bd->bd_bh->b_blocknr;
@@ -449,7 +449,7 @@ TRACE_EVENT(gfs2_bmap,
 	),
 
 	TP_fast_assign(
-		__entry->dev            = ip->i_gl->gl_sbd->sd_vfs->s_dev;
+		__entry->dev            = ip->i_gl->gl_name.ln_sbd->sd_vfs->s_dev;
 		__entry->lblock		= lblock;
 		__entry->pblock		= buffer_mapped(bh) ?  bh->b_blocknr : 0;
 		__entry->inum		= ip->i_no_addr;
@@ -489,7 +489,7 @@ TRACE_EVENT(gfs2_block_alloc,
 	),
 
 	TP_fast_assign(
-		__entry->dev		= rgd->rd_gl->gl_sbd->sd_vfs->s_dev;
+		__entry->dev		= rgd->rd_gl->gl_name.ln_sbd->sd_vfs->s_dev;
 		__entry->start		= block;
 		__entry->inum		= ip->i_no_addr;
 		__entry->len		= len;
diff --git a/fs/gfs2/trans.c b/fs/gfs2/trans.c
index b2ddc40b6834..d7f68983ce8e 100644
--- a/fs/gfs2/trans.c
+++ b/fs/gfs2/trans.c
@@ -182,7 +182,7 @@ static struct gfs2_bufdata *gfs2_alloc_bufdata(struct gfs2_glock *gl,
 void gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)
 {
 	struct gfs2_trans *tr = current->journal_info;
-	struct gfs2_sbd *sdp = gl->gl_sbd;
+	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 	struct address_space *mapping = bh->b_page->mapping;
 	struct gfs2_inode *ip = GFS2_I(mapping->host);
 	struct gfs2_bufdata *bd;
@@ -248,7 +248,7 @@ static void meta_lo_add(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)
 void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)
 {
 
-	struct gfs2_sbd *sdp = gl->gl_sbd;
+	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 	struct gfs2_bufdata *bd;
 
 	lock_buffer(bh);
