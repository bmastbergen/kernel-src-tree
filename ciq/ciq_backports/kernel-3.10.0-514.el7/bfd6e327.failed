netfilter: nft_hash: convert to use rhashtable callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Patrick McHardy <kaber@trash.net>
commit bfd6e327e118d2fe443047829047862b49012457
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bfd6e327.failed

A following patch will convert sets to use so called set extensions,
where the key is not located in a fixed position anymore. This will
require rhashtable hashing and comparison callbacks to be used.

As preparation, convert nft_hash to use these callbacks without any
functional changes.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit bfd6e327e118d2fe443047829047862b49012457)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_hash.c
diff --cc net/netfilter/nft_hash.c
index f14a5e14123a,dc96a7e94f80..000000000000
--- a/net/netfilter/nft_hash.c
+++ b/net/netfilter/nft_hash.c
@@@ -29,14 -33,50 +29,57 @@@ struct nft_hash_elem 
  	struct nft_data			data[];
  };
  
++<<<<<<< HEAD
++=======
+ struct nft_hash_cmp_arg {
+ 	const struct nft_set		*set;
+ 	const struct nft_data		*key;
+ };
+ 
+ static const struct rhashtable_params nft_hash_params;
+ 
+ static inline u32 nft_hash_key(const void *data, u32 len, u32 seed)
+ {
+ 	const struct nft_hash_cmp_arg *arg = data;
+ 
+ 	return jhash(arg->key, len, seed);
+ }
+ 
+ static inline u32 nft_hash_obj(const void *data, u32 len, u32 seed)
+ {
+ 	const struct nft_hash_elem *he = data;
+ 
+ 	return jhash(&he->key, len, seed);
+ }
+ 
+ static inline int nft_hash_cmp(struct rhashtable_compare_arg *arg,
+ 			       const void *ptr)
+ {
+ 	const struct nft_hash_cmp_arg *x = arg->key;
+ 	const struct nft_hash_elem *he = ptr;
+ 
+ 	if (nft_data_cmp(&he->key, x->key, x->set->klen))
+ 		return 1;
+ 	return 0;
+ }
+ 
++>>>>>>> bfd6e327e118 (netfilter: nft_hash: convert to use rhashtable callbacks)
  static bool nft_hash_lookup(const struct nft_set *set,
  			    const struct nft_data *key,
  			    struct nft_data *data)
  {
 -	struct nft_hash *priv = nft_set_priv(set);
 +	const struct rhashtable *priv = nft_set_priv(set);
  	const struct nft_hash_elem *he;
+ 	struct nft_hash_cmp_arg arg = {
+ 		.set	 = set,
+ 		.key	 = key,
+ 	};
  
++<<<<<<< HEAD
 +	he = rhashtable_lookup(priv, key);
++=======
+ 	he = rhashtable_lookup_fast(&priv->ht, &arg, nft_hash_params);
++>>>>>>> bfd6e327e118 (netfilter: nft_hash: convert to use rhashtable callbacks)
  	if (he && set->flags & NFT_SET_MAP)
  		nft_data_copy(data, he->data);
  
@@@ -46,9 -86,14 +89,13 @@@
  static int nft_hash_insert(const struct nft_set *set,
  			   const struct nft_set_elem *elem)
  {
 -	struct nft_hash *priv = nft_set_priv(set);
 +	struct rhashtable *priv = nft_set_priv(set);
  	struct nft_hash_elem *he;
+ 	struct nft_hash_cmp_arg arg = {
+ 		.set	 = set,
+ 		.key	 = &elem->key,
+ 	};
  	unsigned int size;
 -	int err;
  
  	if (elem->flags != 0)
  		return -EINVAL;
@@@ -65,9 -110,12 +112,16 @@@
  	if (set->flags & NFT_SET_MAP)
  		nft_data_copy(he->data, &elem->data);
  
++<<<<<<< HEAD
 +	rhashtable_insert(priv, &he->node);
++=======
+ 	err = rhashtable_lookup_insert_key(&priv->ht, &arg, &he->node,
+ 					   nft_hash_params);
+ 	if (err)
+ 		kfree(he);
++>>>>>>> bfd6e327e118 (netfilter: nft_hash: convert to use rhashtable callbacks)
  
 -	return err;
 +	return 0;
  }
  
  static void nft_hash_elem_destroy(const struct nft_set *set,
@@@ -89,41 -137,25 +143,54 @@@ static void nft_hash_remove(const struc
  	kfree(elem->cookie);
  }
  
 +struct nft_compare_arg {
 +	const struct nft_set *set;
 +	struct nft_set_elem *elem;
 +};
 +
 +static bool nft_hash_compare(void *ptr, void *arg)
 +{
 +	struct nft_hash_elem *he = ptr;
 +	struct nft_compare_arg *x = arg;
 +
 +	if (!nft_data_cmp(&he->key, &x->elem->key, x->set->klen)) {
 +		x->elem->cookie = he;
 +		x->elem->flags = 0;
 +		if (x->set->flags & NFT_SET_MAP)
 +			nft_data_copy(&x->elem->data, he->data);
 +
 +		return true;
 +	}
 +
 +	return false;
 +}
 +
  static int nft_hash_get(const struct nft_set *set, struct nft_set_elem *elem)
  {
++<<<<<<< HEAD
 +	const struct rhashtable *priv = nft_set_priv(set);
 +	struct nft_compare_arg arg = {
 +		.set = set,
 +		.elem = elem,
 +	};
 +
 +	if (rhashtable_lookup_compare(priv, &elem->key,
 +				      &nft_hash_compare, &arg))
 +		return 0;
++=======
+ 	struct nft_hash *priv = nft_set_priv(set);
+ 	struct nft_hash_elem *he;
+ 	struct nft_hash_cmp_arg arg = {
+ 		.set	 = set,
+ 		.key	 = &elem->key,
+ 	};
+ 
+ 	he = rhashtable_lookup_fast(&priv->ht, &arg, nft_hash_params);
+ 	if (!he)
+ 		return -ENOENT;
++>>>>>>> bfd6e327e118 (netfilter: nft_hash: convert to use rhashtable callbacks)
  
 -	elem->cookie = he;
 -	elem->flags = 0;
 -	if (set->flags & NFT_SET_MAP)
 -		nft_data_copy(&elem->data, he->data);
 -
 -	return 0;
 +	return -ENOENT;
  }
  
  static void nft_hash_walk(const struct nft_ctx *ctx, const struct nft_set *set,
@@@ -159,13 -212,16 +226,23 @@@ cont
  
  static unsigned int nft_hash_privsize(const struct nlattr * const nla[])
  {
 -	return sizeof(struct nft_hash);
 +	return sizeof(struct rhashtable);
  }
  
++<<<<<<< HEAD
 +static int lockdep_nfnl_lock_is_held(void)
 +{
 +	return lockdep_nfnl_is_held(NFNL_SUBSYS_NFTABLES);
 +}
++=======
+ static const struct rhashtable_params nft_hash_params = {
+ 	.head_offset		= offsetof(struct nft_hash_elem, node),
+ 	.hashfn			= nft_hash_key,
+ 	.obj_hashfn		= nft_hash_obj,
+ 	.obj_cmpfn		= nft_hash_cmp,
+ 	.automatic_shrinking	= true,
+ };
++>>>>>>> bfd6e327e118 (netfilter: nft_hash: convert to use rhashtable callbacks)
  
  static int nft_hash_init(const struct nft_set *set,
  			 const struct nft_set_desc *desc,
* Unmerged path net/netfilter/nft_hash.c
