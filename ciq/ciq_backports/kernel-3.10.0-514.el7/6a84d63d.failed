mei: replace check for connection instead of transitioning

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 6a84d63d22a0ac79ab422b69ef2b4d75002c5641
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6a84d63d.failed

The function mei_cl_is_transitioning is just opposite
of mei_cl_is_connected. What we actually wanted to
check is if we lost connection so we can discard
the check for transition and check for 'not connected'

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 6a84d63d22a0ac79ab422b69ef2b4d75002c5641)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/bus.c
#	drivers/misc/mei/main.c
diff --cc drivers/misc/mei/bus.c
index ca8736c3675b,4cf38c39878a..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -300,8 -301,8 +300,13 @@@ int __mei_cl_recv(struct mei_cl *cl, u
  		mutex_unlock(&dev->device_lock);
  
  		if (wait_event_interruptible(cl->rx_wait,
++<<<<<<< HEAD
 +				cl->reading_state == MEI_READ_COMPLETE  ||
 +				mei_cl_is_transitioning(cl))) {
++=======
+ 				(!list_empty(&cl->rd_completed)) ||
+ 				(!mei_cl_is_connected(cl)))) {
++>>>>>>> 6a84d63d22a0 (mei: replace check for connection instead of transitioning)
  
  			if (signal_pending(current))
  				return -EINTR;
@@@ -309,13 -310,23 +314,21 @@@
  		}
  
  		mutex_lock(&dev->device_lock);
++<<<<<<< HEAD
++=======
+ 
+ 		if (!mei_cl_is_connected(cl)) {
+ 			rets = -EBUSY;
+ 			goto out;
+ 		}
++>>>>>>> 6a84d63d22a0 (mei: replace check for connection instead of transitioning)
  	}
  
 -	cb = mei_cl_read_cb(cl, NULL);
 -	if (!cb) {
 -		rets = 0;
 -		goto out;
 -	}
 +	cb = cl->read_cb;
  
 -copy:
 -	if (cb->status) {
 -		rets = cb->status;
 -		goto free;
 +	if (cl->reading_state != MEI_READ_COMPLETE) {
 +		r_length = 0;
 +		goto out;
  	}
  
  	r_length = min_t(size_t, length, cb->buf_idx);
diff --cc drivers/misc/mei/main.c
index b23f9eba9e3a,7f77f39c24a7..000000000000
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@@ -250,8 -202,8 +250,13 @@@ static ssize_t mei_read(struct file *fi
  		mutex_unlock(&dev->device_lock);
  
  		if (wait_event_interruptible(cl->rx_wait,
++<<<<<<< HEAD
 +				MEI_READ_COMPLETE == cl->reading_state ||
 +				mei_cl_is_transitioning(cl))) {
++=======
+ 				(!list_empty(&cl->rd_completed)) ||
+ 				(!mei_cl_is_connected(cl)))) {
++>>>>>>> 6a84d63d22a0 (mei: replace check for connection instead of transitioning)
  
  			if (signal_pending(current))
  				return -EINTR;
* Unmerged path drivers/misc/mei/bus.c
diff --git a/drivers/misc/mei/client.h b/drivers/misc/mei/client.h
index f2a130967f1e..dec29b892a46 100644
--- a/drivers/misc/mei/client.h
+++ b/drivers/misc/mei/client.h
@@ -68,16 +68,18 @@ int mei_cl_flow_ctrl_reduce(struct mei_cl *cl);
 /*
  *  MEI input output function prototype
  */
+
+/**
+ * mei_cl_is_connected - host client is connected
+ *
+ * @cl: host clinet
+ *
+ * Return: true if the host clinet is connected
+ */
 static inline bool mei_cl_is_connected(struct mei_cl *cl)
 {
 	return  cl->state == MEI_FILE_CONNECTED;
 }
-static inline bool mei_cl_is_transitioning(struct mei_cl *cl)
-{
-	return  MEI_FILE_INITIALIZING == cl->state ||
-		MEI_FILE_DISCONNECTED == cl->state ||
-		MEI_FILE_DISCONNECTING == cl->state;
-}
 
 bool mei_cl_is_other_connecting(struct mei_cl *cl);
 int mei_cl_disconnect(struct mei_cl *cl);
* Unmerged path drivers/misc/mei/main.c
