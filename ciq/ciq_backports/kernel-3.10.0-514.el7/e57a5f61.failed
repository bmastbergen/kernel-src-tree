mmc: sdhci: Add 64-bit ADMA support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit e57a5f61eae7e145aeeda18ccb22576822f534bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e57a5f61.failed

Add 64-bit ADMA support including:
	- add 64-bit ADMA descriptor
	- add SDHCI_USE_64_BIT_DMA flag
	- set upper 32-bits of DMA addresses
	- ability to select 64-bit ADMA
	- ability to use 64-bit ADMA sizes and alignment
	- display "ADMA 64-bit" when host is added

It is assumed that a 64-bit capable device has set a 64-bit DMA mask
and *must* do 64-bit DMA.  A driver has the opportunity to change
that during the first call to ->enable_dma().  Similarly
SDHCI_QUIRK2_BROKEN_64_BIT_DMA must be left to the drivers to
implement.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit e57a5f61eae7e145aeeda18ccb22576822f534bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci.c
#	drivers/mmc/host/sdhci.h
#	include/linux/mmc/sdhci.h
diff --cc drivers/mmc/host/sdhci.c
index e2d27069abbd,f895ab07fcc2..000000000000
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@@ -475,25 -453,26 +482,45 @@@ static void sdhci_kunmap_atomic(void *b
  	local_irq_restore(*flags);
  }
  
- static void sdhci_adma_write_desc(void *desc, u32 addr, int len, unsigned cmd)
+ static void sdhci_adma_write_desc(struct sdhci_host *host, void *desc,
+ 				  dma_addr_t addr, int len, unsigned cmd)
  {
++<<<<<<< HEAD
 +	__le32 *dataddr = (__le32 __force *)(desc + 4);
 +	__le16 *cmdlen = (__le16 __force *)desc;
 +
 +	/* SDHCI specification says ADMA descriptors should be 4 byte
 +	 * aligned, so using 16 or 32bit operations should be safe. */
 +
 +	cmdlen[0] = cpu_to_le16(cmd);
 +	cmdlen[1] = cpu_to_le16(len);
 +
 +	dataddr[0] = cpu_to_le32(addr);
++=======
+ 	struct sdhci_adma2_64_desc *dma_desc = desc;
+ 
+ 	/* 32-bit and 64-bit descriptors have these members in same position */
+ 	dma_desc->cmd = cpu_to_le16(cmd);
+ 	dma_desc->len = cpu_to_le16(len);
+ 	dma_desc->addr_lo = cpu_to_le32((u32)addr);
+ 
+ 	if (host->flags & SDHCI_USE_64_BIT_DMA)
+ 		dma_desc->addr_hi = cpu_to_le32((u64)addr >> 32);
++>>>>>>> e57a5f61eae7 (mmc: sdhci: Add 64-bit ADMA support)
  }
  
  static void sdhci_adma_mark_end(void *desc)
  {
++<<<<<<< HEAD
 +	u8 *dma_desc = desc;
 +
 +	dma_desc[0] |= 0x2; /* end */
++=======
+ 	struct sdhci_adma2_64_desc *dma_desc = desc;
+ 
+ 	/* 32-bit and 64-bit descriptors have 'cmd' in same position */
+ 	dma_desc->cmd |= cpu_to_le16(ADMA2_END);
++>>>>>>> e57a5f61eae7 (mmc: sdhci: Add 64-bit ADMA support)
  }
  
  static int sdhci_adma_table_pre(struct sdhci_host *host,
@@@ -560,7 -540,8 +587,12 @@@
  			}
  
  			/* tran, valid */
++<<<<<<< HEAD
 +			sdhci_adma_write_desc(desc, align_addr, offset, 0x21);
++=======
+ 			sdhci_adma_write_desc(host, desc, align_addr, offset,
+ 					      ADMA2_TRAN_VALID);
++>>>>>>> e57a5f61eae7 (mmc: sdhci: Add 64-bit ADMA support)
  
  			BUG_ON(offset > 65536);
  
@@@ -576,8 -557,8 +608,13 @@@
  		BUG_ON(len > 65536);
  
  		/* tran, valid */
++<<<<<<< HEAD
 +		sdhci_adma_write_desc(desc, addr, len, 0x21);
 +		desc += 8;
++=======
+ 		sdhci_adma_write_desc(host, desc, addr, len, ADMA2_TRAN_VALID);
+ 		desc += host->desc_sz;
++>>>>>>> e57a5f61eae7 (mmc: sdhci: Add 64-bit ADMA support)
  
  		/*
  		 * If this triggers then we have a calculation bug
@@@ -600,7 -581,7 +637,11 @@@
  		*/
  
  		/* nop, end, valid */
++<<<<<<< HEAD
 +		sdhci_adma_write_desc(desc, 0, 0, 0x3);
++=======
+ 		sdhci_adma_write_desc(host, desc, 0, 0, ADMA2_NOP_END_VALID);
++>>>>>>> e57a5f61eae7 (mmc: sdhci: Add 64-bit ADMA support)
  	}
  
  	/*
@@@ -2311,16 -2317,23 +2360,32 @@@ static void sdhci_adma_show_error(struc
  	sdhci_dumpregs(host);
  
  	while (true) {
++<<<<<<< HEAD
 +		dma = (__le32 *)(desc + 4);
 +		len = (__le16 *)(desc + 2);
 +		attr = *(u8 *)desc;
 +
 +		DBG("%s: %p: DMA 0x%08x, LEN 0x%04x, Attr=0x%02x\n",
 +		    name, desc, le32_to_cpu(*dma), le16_to_cpu(*len), attr);
++=======
+ 		struct sdhci_adma2_64_desc *dma_desc = desc;
+ 
+ 		if (host->flags & SDHCI_USE_64_BIT_DMA)
+ 			DBG("%s: %p: DMA 0x%08x%08x, LEN 0x%04x, Attr=0x%02x\n",
+ 			    name, desc, le32_to_cpu(dma_desc->addr_hi),
+ 			    le32_to_cpu(dma_desc->addr_lo),
+ 			    le16_to_cpu(dma_desc->len),
+ 			    le16_to_cpu(dma_desc->cmd));
+ 		else
+ 			DBG("%s: %p: DMA 0x%08x, LEN 0x%04x, Attr=0x%02x\n",
+ 			    name, desc, le32_to_cpu(dma_desc->addr_lo),
+ 			    le16_to_cpu(dma_desc->len),
+ 			    le16_to_cpu(dma_desc->cmd));
++>>>>>>> e57a5f61eae7 (mmc: sdhci: Add 64-bit ADMA support)
  
 -		desc += host->desc_sz;
 +		desc += 8;
  
 -		if (dma_desc->cmd & cpu_to_le16(ADMA2_END))
 +		if (attr & 2)
  			break;
  	}
  }
@@@ -2869,23 -2901,44 +2944,47 @@@ int sdhci_add_host(struct sdhci_host *h
  		}
  	}
  
+ 	/* SDMA does not support 64-bit DMA */
+ 	if (host->flags & SDHCI_USE_64_BIT_DMA)
+ 		host->flags &= ~SDHCI_USE_SDMA;
+ 
  	if (host->flags & SDHCI_USE_ADMA) {
  		/*
 -		 * The DMA descriptor table size is calculated as the maximum
 -		 * number of segments times 2, to allow for an alignment
 -		 * descriptor for each segment, plus 1 for a nop end descriptor,
 -		 * all multipled by the descriptor size.
 +		 * We need to allocate descriptors for all sg entries
 +		 * (128) and potentially one alignment transfer for
 +		 * each of those entries.
  		 */
++<<<<<<< HEAD
++=======
+ 		if (host->flags & SDHCI_USE_64_BIT_DMA) {
+ 			host->adma_table_sz = (SDHCI_MAX_SEGS * 2 + 1) *
+ 					      SDHCI_ADMA2_64_DESC_SZ;
+ 			host->align_buffer_sz = SDHCI_MAX_SEGS *
+ 						SDHCI_ADMA2_64_ALIGN;
+ 			host->desc_sz = SDHCI_ADMA2_64_DESC_SZ;
+ 			host->align_sz = SDHCI_ADMA2_64_ALIGN;
+ 			host->align_mask = SDHCI_ADMA2_64_ALIGN - 1;
+ 		} else {
+ 			host->adma_table_sz = (SDHCI_MAX_SEGS * 2 + 1) *
+ 					      SDHCI_ADMA2_32_DESC_SZ;
+ 			host->align_buffer_sz = SDHCI_MAX_SEGS *
+ 						SDHCI_ADMA2_32_ALIGN;
+ 			host->desc_sz = SDHCI_ADMA2_32_DESC_SZ;
+ 			host->align_sz = SDHCI_ADMA2_32_ALIGN;
+ 			host->align_mask = SDHCI_ADMA2_32_ALIGN - 1;
+ 		}
++>>>>>>> e57a5f61eae7 (mmc: sdhci: Add 64-bit ADMA support)
  		host->adma_table = dma_alloc_coherent(mmc_dev(mmc),
 -						      host->adma_table_sz,
 +						      ADMA_SIZE,
  						      &host->adma_addr,
  						      GFP_KERNEL);
 -		host->align_buffer = kmalloc(host->align_buffer_sz, GFP_KERNEL);
 +		host->align_buffer = kmalloc(128 * 4, GFP_KERNEL);
  		if (!host->adma_table || !host->align_buffer) {
 -			dma_free_coherent(mmc_dev(mmc), host->adma_table_sz,
 +			dma_free_coherent(mmc_dev(mmc), ADMA_SIZE,
  					  host->adma_table, host->adma_addr);
  			kfree(host->align_buffer);
 -			pr_warn("%s: Unable to allocate ADMA buffers - falling back to standard DMA\n",
 +			pr_warning("%s: Unable to allocate ADMA "
 +				"buffers. Falling back to standard DMA.\n",
  				mmc_hostname(mmc));
  			host->flags &= ~SDHCI_USE_ADMA;
  			host->adma_table = NULL;
diff --cc drivers/mmc/host/sdhci.h
index 4dea27050ed1,c2ec7fcd8a1f..000000000000
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@@ -266,6 -267,46 +267,49 @@@
  #define SDHCI_DEFAULT_BOUNDARY_SIZE  (512 * 1024)
  #define SDHCI_DEFAULT_BOUNDARY_ARG   (ilog2(SDHCI_DEFAULT_BOUNDARY_SIZE) - 12)
  
++<<<<<<< HEAD
++=======
+ /* ADMA2 32-bit DMA descriptor size */
+ #define SDHCI_ADMA2_32_DESC_SZ	8
+ 
+ /* ADMA2 32-bit DMA alignment */
+ #define SDHCI_ADMA2_32_ALIGN	4
+ 
+ /* ADMA2 32-bit descriptor */
+ struct sdhci_adma2_32_desc {
+ 	__le16	cmd;
+ 	__le16	len;
+ 	__le32	addr;
+ }  __packed __aligned(SDHCI_ADMA2_32_ALIGN);
+ 
+ /* ADMA2 64-bit DMA descriptor size */
+ #define SDHCI_ADMA2_64_DESC_SZ	12
+ 
+ /* ADMA2 64-bit DMA alignment */
+ #define SDHCI_ADMA2_64_ALIGN	8
+ 
+ /*
+  * ADMA2 64-bit descriptor. Note 12-byte descriptor can't always be 8-byte
+  * aligned.
+  */
+ struct sdhci_adma2_64_desc {
+ 	__le16	cmd;
+ 	__le16	len;
+ 	__le32	addr_lo;
+ 	__le32	addr_hi;
+ }  __packed __aligned(4);
+ 
+ #define ADMA2_TRAN_VALID	0x21
+ #define ADMA2_NOP_END_VALID	0x3
+ #define ADMA2_END		0x2
+ 
+ /*
+  * Maximum segments assuming a 512KiB maximum requisition size and a minimum
+  * 4KiB page size.
+  */
+ #define SDHCI_MAX_SEGS		128
+ 
++>>>>>>> e57a5f61eae7 (mmc: sdhci: Add 64-bit ADMA support)
  struct sdhci_ops {
  #ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
  	u32		(*read_l)(struct sdhci_host *host, int reg);
diff --cc include/linux/mmc/sdhci.h
index 7c176e5d3cf5,931ac5e05453..000000000000
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@@ -96,6 -92,16 +96,19 @@@ struct sdhci_host 
  #define SDHCI_QUIRK2_NO_1_8_V				(1<<2)
  #define SDHCI_QUIRK2_PRESET_VALUE_BROKEN		(1<<3)
  #define SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON		(1<<4)
++<<<<<<< HEAD
++=======
+ /* Controller has a non-standard host control register */
+ #define SDHCI_QUIRK2_BROKEN_HOST_CONTROL		(1<<5)
+ /* Controller does not support HS200 */
+ #define SDHCI_QUIRK2_BROKEN_HS200			(1<<6)
+ /* Controller does not support DDR50 */
+ #define SDHCI_QUIRK2_BROKEN_DDR50			(1<<7)
+ /* Stop command (CMD12) can set Transfer Complete when not using MMC_RSP_BUSY */
+ #define SDHCI_QUIRK2_STOP_WITH_TC			(1<<8)
+ /* Controller does not support 64-bit DMA */
+ #define SDHCI_QUIRK2_BROKEN_64_BIT_DMA			(1<<9)
++>>>>>>> e57a5f61eae7 (mmc: sdhci: Add 64-bit ADMA support)
  
  	int irq;		/* Device IRQ */
  	void __iomem *ioaddr;	/* Mapped address */
* Unmerged path drivers/mmc/host/sdhci.c
* Unmerged path drivers/mmc/host/sdhci.h
* Unmerged path include/linux/mmc/sdhci.h
