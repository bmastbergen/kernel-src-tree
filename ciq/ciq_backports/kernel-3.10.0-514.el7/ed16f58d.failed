mmc: core: Separate out the mmc_switch status check so it can be re-used

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] core: Separate out the mmc_switch status check so it can be re-used (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 96.40%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit ed16f58dc00d47439c201ab18ca4d981210bcafd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ed16f58d.failed

Make a separate function to do the mmc_switch status check
so it can be re-used. This is preparation for adding support
for HS400 re-tuning.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit ed16f58dc00d47439c201ab18ca4d981210bcafd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/mmc_ops.h
diff --cc drivers/mmc/core/mmc_ops.h
index f752ec67c102,f498f9ae21f0..000000000000
--- a/drivers/mmc/core/mmc_ops.h
+++ b/drivers/mmc/core/mmc_ops.h
@@@ -26,6 -26,8 +26,11 @@@ int mmc_spi_read_ocr(struct mmc_host *h
  int mmc_spi_set_crc(struct mmc_host *host, int use_crc);
  int mmc_bus_test(struct mmc_card *card, u8 bus_width);
  int mmc_send_hpi_cmd(struct mmc_card *card, u32 *status);
++<<<<<<< HEAD
++=======
+ int mmc_can_ext_csd(struct mmc_card *card);
+ int mmc_switch_status_error(struct mmc_host *host, u32 status);
++>>>>>>> ed16f58dc00d (mmc: core: Separate out the mmc_switch status check so it can be re-used)
  
  #endif
  
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index 5e2ad7c0c270..4717f09d6ef2 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -397,6 +397,21 @@ int mmc_spi_set_crc(struct mmc_host *host, int use_crc)
 	return err;
 }
 
+int mmc_switch_status_error(struct mmc_host *host, u32 status)
+{
+	if (mmc_host_is_spi(host)) {
+		if (status & R1_SPI_ILLEGAL_COMMAND)
+			return -EBADMSG;
+	} else {
+		if (status & 0xFDFFA000)
+			pr_warn("%s: unexpected status %#x after switch\n",
+				mmc_hostname(host), status);
+		if (status & R1_SWITCH_ERROR)
+			return -EBADMSG;
+	}
+	return 0;
+}
+
 /**
  *	__mmc_switch - modify EXT_CSD register
  *	@card: the MMC card associated with the data transfer
@@ -505,20 +520,7 @@ int __mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,
 		}
 	} while (R1_CURRENT_STATE(status) == R1_STATE_PRG);
 
-	if (mmc_host_is_spi(host)) {
-		if (status & R1_SPI_ILLEGAL_COMMAND) {
-			err = -EBADMSG;
-			goto out;
-		}
-	} else {
-		if (status & 0xFDFFA000)
-			pr_warn("%s: unexpected status %#x after switch\n",
-				mmc_hostname(host), status);
-		if (status & R1_SWITCH_ERROR) {
-			err = -EBADMSG;
-			goto out;
-		}
-	}
+	err = mmc_switch_status_error(host, status);
 out:
 	mmc_retune_release(host);
 
* Unmerged path drivers/mmc/core/mmc_ops.h
