net/mlx5e: Add per priority group to PPort counters

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Add per priority group to PPort counters (kamal heib) [1275159 1296272 1296405 1298421 1298422 1298423 1298424 1298425]
Rebuild_FUZZ: 95.92%
commit-author Gal Pressman <galp@mellanox.com>
commit cf678570d5a1022c4c4dbda7792f2a36f0b9fec0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/cf678570.failed

Expose counters providing information for each priority level (PCP) through
ethtool -S option and DCBNL.
This includes rx/tx bytes, frames, and pause counters.

	Signed-off-by: Gal Pressman <galp@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cf678570d5a1022c4c4dbda7792f2a36f0b9fec0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_stats.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index 72a2892f3570,522d584bc05f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -165,22 -165,109 +165,122 @@@ static const struct 
  	},
  };
  
++<<<<<<< HEAD
++=======
+ static unsigned long mlx5e_query_pfc_combined(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	u8 pfc_en_tx;
+ 	u8 pfc_en_rx;
+ 	int err;
+ 
+ 	err = mlx5_query_port_pfc(mdev, &pfc_en_tx, &pfc_en_rx);
+ 
+ 	return err ? 0 : pfc_en_tx | pfc_en_rx;
+ }
+ 
+ #define MLX5E_NUM_Q_CNTRS(priv) (NUM_Q_COUNTERS * (!!priv->q_counter))
+ #define MLX5E_NUM_RQ_STATS(priv) \
+ 	(NUM_RQ_STATS * priv->params.num_channels * \
+ 	 test_bit(MLX5E_STATE_OPENED, &priv->state))
+ #define MLX5E_NUM_SQ_STATS(priv) \
+ 	(NUM_SQ_STATS * priv->params.num_channels * priv->params.num_tc * \
+ 	 test_bit(MLX5E_STATE_OPENED, &priv->state))
+ #define MLX5E_NUM_PFC_COUNTERS(priv) hweight8(mlx5e_query_pfc_combined(priv))
+ 
++>>>>>>> cf678570d5a1 (net/mlx5e: Add per priority group to PPort counters)
  static int mlx5e_get_sset_count(struct net_device *dev, int sset)
  {
  	struct mlx5e_priv *priv = netdev_priv(dev);
  
  	switch (sset) {
  	case ETH_SS_STATS:
++<<<<<<< HEAD
 +		return NUM_VPORT_COUNTERS + NUM_PPORT_COUNTERS +
 +		       priv->params.num_channels * NUM_RQ_STATS +
 +		       priv->params.num_channels * priv->params.num_tc *
 +						   NUM_SQ_STATS;
++=======
+ 		return NUM_SW_COUNTERS +
+ 		       MLX5E_NUM_Q_CNTRS(priv) +
+ 		       NUM_VPORT_COUNTERS + NUM_PPORT_COUNTERS +
+ 		       MLX5E_NUM_RQ_STATS(priv) +
+ 		       MLX5E_NUM_SQ_STATS(priv) +
+ 		       MLX5E_NUM_PFC_COUNTERS(priv);
++>>>>>>> cf678570d5a1 (net/mlx5e: Add per priority group to PPort counters)
  	/* fallthrough */
  	default:
  		return -EOPNOTSUPP;
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void mlx5e_fill_stats_strings(struct mlx5e_priv *priv, uint8_t *data)
+ {
+ 	int i, j, tc, prio, idx = 0;
+ 	unsigned long pfc_combined;
+ 
+ 	/* SW counters */
+ 	for (i = 0; i < NUM_SW_COUNTERS; i++)
+ 		strcpy(data + (idx++) * ETH_GSTRING_LEN, sw_stats_desc[i].name);
+ 
+ 	/* Q counters */
+ 	for (i = 0; i < MLX5E_NUM_Q_CNTRS(priv); i++)
+ 		strcpy(data + (idx++) * ETH_GSTRING_LEN, q_stats_desc[i].name);
+ 
+ 	/* VPORT counters */
+ 	for (i = 0; i < NUM_VPORT_COUNTERS; i++)
+ 		strcpy(data + (idx++) * ETH_GSTRING_LEN,
+ 		       vport_stats_desc[i].name);
+ 
+ 	/* PPORT counters */
+ 	for (i = 0; i < NUM_PPORT_802_3_COUNTERS; i++)
+ 		strcpy(data + (idx++) * ETH_GSTRING_LEN,
+ 		       pport_802_3_stats_desc[i].name);
+ 
+ 	for (i = 0; i < NUM_PPORT_2863_COUNTERS; i++)
+ 		strcpy(data + (idx++) * ETH_GSTRING_LEN,
+ 		       pport_2863_stats_desc[i].name);
+ 
+ 	for (i = 0; i < NUM_PPORT_2819_COUNTERS; i++)
+ 		strcpy(data + (idx++) * ETH_GSTRING_LEN,
+ 		       pport_2819_stats_desc[i].name);
+ 
+ 	for (prio = 0; prio < NUM_PPORT_PRIO; prio++) {
+ 		for (i = 0; i < NUM_PPORT_PER_PRIO_TRAFFIC_COUNTERS; i++)
+ 			sprintf(data + (idx++) * ETH_GSTRING_LEN, "prio%d_%s",
+ 				prio,
+ 				pport_per_prio_traffic_stats_desc[i].name);
+ 	}
+ 
+ 	pfc_combined = mlx5e_query_pfc_combined(priv);
+ 	for_each_set_bit(prio, &pfc_combined, NUM_PPORT_PRIO) {
+ 		for (i = 0; i < NUM_PPORT_PER_PRIO_PFC_COUNTERS; i++) {
+ 			sprintf(data + (idx++) * ETH_GSTRING_LEN, "prio%d_%s",
+ 				prio, pport_per_prio_pfc_stats_desc[i].name);
+ 		}
+ 	}
+ 
+ 	if (!test_bit(MLX5E_STATE_OPENED, &priv->state))
+ 		return;
+ 
+ 	/* per channel counters */
+ 	for (i = 0; i < priv->params.num_channels; i++)
+ 		for (j = 0; j < NUM_RQ_STATS; j++)
+ 			sprintf(data + (idx++) * ETH_GSTRING_LEN, "rx%d_%s", i,
+ 				rq_stats_desc[j].name);
+ 
+ 	for (tc = 0; tc < priv->params.num_tc; tc++)
+ 		for (i = 0; i < priv->params.num_channels; i++)
+ 			for (j = 0; j < NUM_SQ_STATS; j++)
+ 				sprintf(data + (idx++) * ETH_GSTRING_LEN,
+ 					"tx%d_%s",
+ 					priv->channeltc_to_txq_map[i][tc],
+ 					sq_stats_desc[j].name);
+ }
+ 
++>>>>>>> cf678570d5a1 (net/mlx5e: Add per priority group to PPort counters)
  static void mlx5e_get_strings(struct net_device *dev,
  			      uint32_t stringset, uint8_t *data)
  {
@@@ -237,11 -301,46 +338,42 @@@ static void mlx5e_get_ethtool_stats(str
  		mlx5e_update_stats(priv);
  	mutex_unlock(&priv->state_lock);
  
 -	for (i = 0; i < NUM_SW_COUNTERS; i++)
 -		data[idx++] = MLX5E_READ_CTR64_CPU(&priv->stats.sw,
 -						   sw_stats_desc, i);
 -
 -	for (i = 0; i < MLX5E_NUM_Q_CNTRS(priv); i++)
 -		data[idx++] = MLX5E_READ_CTR32_CPU(&priv->stats.qcnt,
 -						   q_stats_desc, i);
 -
  	for (i = 0; i < NUM_VPORT_COUNTERS; i++)
 -		data[idx++] = MLX5E_READ_CTR64_BE(priv->stats.vport.query_vport_out,
 -						  vport_stats_desc, i);
 +		data[idx++] = ((u64 *)&priv->stats.vport)[i];
  
++<<<<<<< HEAD
 +	for (i = 0; i < NUM_PPORT_COUNTERS; i++)
 +		data[idx++] = be64_to_cpu(((__be64 *)&priv->stats.pport)[i]);
++=======
+ 	for (i = 0; i < NUM_PPORT_802_3_COUNTERS; i++)
+ 		data[idx++] = MLX5E_READ_CTR64_BE(&priv->stats.pport.IEEE_802_3_counters,
+ 						  pport_802_3_stats_desc, i);
+ 
+ 	for (i = 0; i < NUM_PPORT_2863_COUNTERS; i++)
+ 		data[idx++] = MLX5E_READ_CTR64_BE(&priv->stats.pport.RFC_2863_counters,
+ 						  pport_2863_stats_desc, i);
+ 
+ 	for (i = 0; i < NUM_PPORT_2819_COUNTERS; i++)
+ 		data[idx++] = MLX5E_READ_CTR64_BE(&priv->stats.pport.RFC_2819_counters,
+ 						  pport_2819_stats_desc, i);
+ 
+ 	for (prio = 0; prio < NUM_PPORT_PRIO; prio++) {
+ 		for (i = 0; i < NUM_PPORT_PER_PRIO_TRAFFIC_COUNTERS; i++)
+ 			data[idx++] = MLX5E_READ_CTR64_BE(&priv->stats.pport.per_prio_counters[prio],
+ 						 pport_per_prio_traffic_stats_desc, i);
+ 	}
+ 
+ 	pfc_combined = mlx5e_query_pfc_combined(priv);
+ 	for_each_set_bit(prio, &pfc_combined, NUM_PPORT_PRIO) {
+ 		for (i = 0; i < NUM_PPORT_PER_PRIO_PFC_COUNTERS; i++) {
+ 			data[idx++] = MLX5E_READ_CTR64_BE(&priv->stats.pport.per_prio_counters[prio],
+ 							  pport_per_prio_pfc_stats_desc, i);
+ 		}
+ 	}
+ 
+ 	if (!test_bit(MLX5E_STATE_OPENED, &priv->state))
+ 		return;
++>>>>>>> cf678570d5a1 (net/mlx5e: Add per priority group to PPort counters)
  
  	/* per channel counters */
  	for (i = 0; i < priv->params.num_channels; i++)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index b70e3293db0b,ef66ba65f5cd..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -194,56 -153,65 +194,87 @@@ void mlx5e_update_stats(struct mlx5e_pr
  
  	memset(out, 0, outlen);
  
++<<<<<<< HEAD
 +	if (mlx5_cmd_exec(mdev, in, sizeof(in), out, outlen))
++=======
+ 	mlx5_cmd_exec(mdev, in, sizeof(in), out, outlen);
+ }
+ 
+ static void mlx5e_update_pport_counters(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_pport_stats *pstats = &priv->stats.pport;
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	int sz = MLX5_ST_SZ_BYTES(ppcnt_reg);
+ 	int prio;
+ 	void *out;
+ 	u32 *in;
+ 
+ 	in = mlx5_vzalloc(sz);
+ 	if (!in)
++>>>>>>> cf678570d5a1 (net/mlx5e: Add per priority group to PPort counters)
  		goto free_out;
  
 -	MLX5_SET(ppcnt_reg, in, local_port, 1);
 -
 -	out = pstats->IEEE_802_3_counters;
 -	MLX5_SET(ppcnt_reg, in, grp, MLX5_IEEE_802_3_COUNTERS_GROUP);
 -	mlx5_core_access_reg(mdev, in, sz, out, sz, MLX5_REG_PPCNT, 0, 0);
 -
 -	out = pstats->RFC_2863_counters;
 -	MLX5_SET(ppcnt_reg, in, grp, MLX5_RFC_2863_COUNTERS_GROUP);
 -	mlx5_core_access_reg(mdev, in, sz, out, sz, MLX5_REG_PPCNT, 0, 0);
 -
 -	out = pstats->RFC_2819_counters;
 -	MLX5_SET(ppcnt_reg, in, grp, MLX5_RFC_2819_COUNTERS_GROUP);
 -	mlx5_core_access_reg(mdev, in, sz, out, sz, MLX5_REG_PPCNT, 0, 0);
 -
 +#define MLX5_GET_CTR(p, x) \
 +	MLX5_GET64(query_vport_counter_out, p, x)
 +
 +	s->rx_error_packets     =
 +		MLX5_GET_CTR(out, received_errors.packets);
 +	s->rx_error_bytes       =
 +		MLX5_GET_CTR(out, received_errors.octets);
 +	s->tx_error_packets     =
 +		MLX5_GET_CTR(out, transmit_errors.packets);
 +	s->tx_error_bytes       =
 +		MLX5_GET_CTR(out, transmit_errors.octets);
 +
 +	s->rx_unicast_packets   =
 +		MLX5_GET_CTR(out, received_eth_unicast.packets);
 +	s->rx_unicast_bytes     =
 +		MLX5_GET_CTR(out, received_eth_unicast.octets);
 +	s->tx_unicast_packets   =
 +		MLX5_GET_CTR(out, transmitted_eth_unicast.packets);
 +	s->tx_unicast_bytes     =
 +		MLX5_GET_CTR(out, transmitted_eth_unicast.octets);
 +
 +	s->rx_multicast_packets =
 +		MLX5_GET_CTR(out, received_eth_multicast.packets);
 +	s->rx_multicast_bytes   =
 +		MLX5_GET_CTR(out, received_eth_multicast.octets);
 +	s->tx_multicast_packets =
 +		MLX5_GET_CTR(out, transmitted_eth_multicast.packets);
 +	s->tx_multicast_bytes   =
 +		MLX5_GET_CTR(out, transmitted_eth_multicast.octets);
 +
++<<<<<<< HEAD
 +	s->rx_broadcast_packets =
 +		MLX5_GET_CTR(out, received_eth_broadcast.packets);
 +	s->rx_broadcast_bytes   =
 +		MLX5_GET_CTR(out, received_eth_broadcast.octets);
 +	s->tx_broadcast_packets =
 +		MLX5_GET_CTR(out, transmitted_eth_broadcast.packets);
 +	s->tx_broadcast_bytes   =
 +		MLX5_GET_CTR(out, transmitted_eth_broadcast.octets);
++=======
+ 	MLX5_SET(ppcnt_reg, in, grp, MLX5_PER_PRIORITY_COUNTERS_GROUP);
+ 	for (prio = 0; prio < NUM_PPORT_PRIO; prio++) {
+ 		out = pstats->per_prio_counters[prio];
+ 		MLX5_SET(ppcnt_reg, in, prio_tc, prio);
+ 		mlx5_core_access_reg(mdev, in, sz, out, sz,
+ 				     MLX5_REG_PPCNT, 0, 0);
+ 	}
+ 
+ free_out:
+ 	kvfree(in);
+ }
++>>>>>>> cf678570d5a1 (net/mlx5e: Add per priority group to PPort counters)
  
 -static void mlx5e_update_q_counter(struct mlx5e_priv *priv)
 -{
 -	struct mlx5e_qcounter_stats *qcnt = &priv->stats.qcnt;
 -
 -	if (!priv->q_counter)
 -		return;
 -
 -	mlx5_core_query_out_of_buffer(priv->mdev, priv->q_counter,
 -				      &qcnt->rx_out_of_buffer);
 -}
 +	/* Update calculated offload counters */
 +	s->tx_csum_offload = s->tx_packets - tx_offload_none;
 +	s->rx_csum_good    = s->rx_packets - s->rx_csum_none -
 +			       s->rx_csum_sw;
  
 -void mlx5e_update_stats(struct mlx5e_priv *priv)
 -{
 -	mlx5e_update_sw_counters(priv);
 -	mlx5e_update_q_counter(priv);
 -	mlx5e_update_vport_counters(priv);
  	mlx5e_update_pport_counters(priv);
 +free_out:
 +	kvfree(out);
  }
  
  static void mlx5e_update_stats_work(struct work_struct *work)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_stats.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_stats.h
