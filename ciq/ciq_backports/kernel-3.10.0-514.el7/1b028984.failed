cpufreq: powernv: Add sysfs attributes to show throttle stats

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [cpufreq] powernv: Add sysfs attributes to show throttle stats (Gustavo Duarte) [1346246]
Rebuild_FUZZ: 92.04%
commit-author Shilpasri G Bhat <shilpa.bhat@linux.vnet.ibm.com>
commit 1b0289848d5dcea74a6e5115d6c9892b0dbe9c8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1b028984.failed

Create sysfs attributes to export throttle information in
/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats directory. The
newly added sysfs files are as follows:

 1)/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/turbo_stat
 2)/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/sub-turbo_stat
 3)/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/unthrottle
 4)/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/powercap
 5)/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/overtemp
 6)/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/supply_fault
 7)/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/overcurrent
 8)/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/occ_reset

Detailed explanation of each attribute is added to
Documentation/ABI/testing/sysfs-devices-system-cpu

	Signed-off-by: Shilpasri G Bhat <shilpa.bhat@linux.vnet.ibm.com>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 1b0289848d5dcea74a6e5115d6c9892b0dbe9c8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/ABI/testing/sysfs-devices-system-cpu
#	drivers/cpufreq/powernv-cpufreq.c
diff --cc Documentation/ABI/testing/sysfs-devices-system-cpu
index 8ba715dd8608,16501334b99f..000000000000
--- a/Documentation/ABI/testing/sysfs-devices-system-cpu
+++ b/Documentation/ABI/testing/sysfs-devices-system-cpu
@@@ -200,3 -200,143 +200,146 @@@ Description:	address and size of the pe
  		note of cpu#.
  
  		crash_notes_size: size of the note of cpu#.
++<<<<<<< HEAD
++=======
+ 
+ 
+ What:		/sys/devices/system/cpu/intel_pstate/max_perf_pct
+ 		/sys/devices/system/cpu/intel_pstate/min_perf_pct
+ 		/sys/devices/system/cpu/intel_pstate/no_turbo
+ Date:		February 2013
+ Contact:	linux-pm@vger.kernel.org
+ Description:	Parameters for the Intel P-state driver
+ 
+ 		Logic for selecting the current P-state in Intel
+ 		Sandybridge+ processors. The three knobs control
+ 		limits for the P-state that will be requested by the
+ 		driver.
+ 
+ 		max_perf_pct: limits the maximum P state that will be requested by
+ 		the driver stated as a percentage of the available performance.
+ 
+ 		min_perf_pct: limits the minimum P state that will be requested by
+ 		the driver stated as a percentage of the available performance.
+ 
+ 		no_turbo: limits the driver to selecting P states below the turbo
+ 		frequency range.
+ 
+ 		More details can be found in Documentation/cpu-freq/intel-pstate.txt
+ 
+ What:		/sys/devices/system/cpu/cpu*/cache/index*/<set_of_attributes_mentioned_below>
+ Date:		July 2014(documented, existed before August 2008)
+ Contact:	Sudeep Holla <sudeep.holla@arm.com>
+ 		Linux kernel mailing list <linux-kernel@vger.kernel.org>
+ Description:	Parameters for the CPU cache attributes
+ 
+ 		allocation_policy:
+ 			- WriteAllocate: allocate a memory location to a cache line
+ 					 on a cache miss because of a write
+ 			- ReadAllocate: allocate a memory location to a cache line
+ 					on a cache miss because of a read
+ 			- ReadWriteAllocate: both writeallocate and readallocate
+ 
+ 		attributes: LEGACY used only on IA64 and is same as write_policy
+ 
+ 		coherency_line_size: the minimum amount of data in bytes that gets
+ 				     transferred from memory to cache
+ 
+ 		level: the cache hierarchy in the multi-level cache configuration
+ 
+ 		number_of_sets: total number of sets in the cache, a set is a
+ 				collection of cache lines with the same cache index
+ 
+ 		physical_line_partition: number of physical cache line per cache tag
+ 
+ 		shared_cpu_list: the list of logical cpus sharing the cache
+ 
+ 		shared_cpu_map: logical cpu mask containing the list of cpus sharing
+ 				the cache
+ 
+ 		size: the total cache size in kB
+ 
+ 		type:
+ 			- Instruction: cache that only holds instructions
+ 			- Data: cache that only caches data
+ 			- Unified: cache that holds both data and instructions
+ 
+ 		ways_of_associativity: degree of freedom in placing a particular block
+ 					of memory in the cache
+ 
+ 		write_policy:
+ 			- WriteThrough: data is written to both the cache line
+ 					and to the block in the lower-level memory
+ 			- WriteBack: data is written only to the cache line and
+ 				     the modified cache line is written to main
+ 				     memory only when it is replaced
+ 
+ What:		/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats
+ 		/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/turbo_stat
+ 		/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/sub_turbo_stat
+ 		/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/unthrottle
+ 		/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/powercap
+ 		/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/overtemp
+ 		/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/supply_fault
+ 		/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/overcurrent
+ 		/sys/devices/system/cpu/cpuX/cpufreq/throttle_stats/occ_reset
+ Date:		March 2016
+ Contact:	Linux kernel mailing list <linux-kernel@vger.kernel.org>
+ 		Linux for PowerPC mailing list <linuxppc-dev@ozlabs.org>
+ Description:	POWERNV CPUFreq driver's frequency throttle stats directory and
+ 		attributes
+ 
+ 		'cpuX/cpufreq/throttle_stats' directory contains the CPU frequency
+ 		throttle stat attributes for the chip. The throttle stats of a cpu
+ 		is common across all the cpus belonging to a chip. Below are the
+ 		throttle attributes exported in the 'throttle_stats' directory:
+ 
+ 		- turbo_stat : This file gives the total number of times the max
+ 		frequency is throttled to lower frequency in turbo (at and above
+ 		nominal frequency) range of frequencies.
+ 
+ 		- sub_turbo_stat : This file gives the total number of times the
+ 		max frequency is throttled to lower frequency in sub-turbo(below
+ 		nominal frequency) range of frequencies.
+ 
+ 		- unthrottle : This file gives the total number of times the max
+ 		frequency is unthrottled after being throttled.
+ 
+ 		- powercap : This file gives the total number of times the max
+ 		frequency is throttled due to 'Power Capping'.
+ 
+ 		- overtemp : This file gives the total number of times the max
+ 		frequency is throttled due to 'CPU Over Temperature'.
+ 
+ 		- supply_fault : This file gives the total number of times the
+ 		max frequency is throttled due to 'Power Supply Failure'.
+ 
+ 		- overcurrent : This file gives the total number of times the
+ 		max frequency is throttled due to 'Overcurrent'.
+ 
+ 		- occ_reset : This file gives the total number of times the max
+ 		frequency is throttled due to 'OCC Reset'.
+ 
+ 		The sysfs attributes representing different throttle reasons like
+ 		powercap, overtemp, supply_fault, overcurrent and occ_reset map to
+ 		the reasons provided by OCC firmware for throttling the frequency.
+ 
+ What:		/sys/devices/system/cpu/cpufreq/policyX/throttle_stats
+ 		/sys/devices/system/cpu/cpufreq/policyX/throttle_stats/turbo_stat
+ 		/sys/devices/system/cpu/cpufreq/policyX/throttle_stats/sub_turbo_stat
+ 		/sys/devices/system/cpu/cpufreq/policyX/throttle_stats/unthrottle
+ 		/sys/devices/system/cpu/cpufreq/policyX/throttle_stats/powercap
+ 		/sys/devices/system/cpu/cpufreq/policyX/throttle_stats/overtemp
+ 		/sys/devices/system/cpu/cpufreq/policyX/throttle_stats/supply_fault
+ 		/sys/devices/system/cpu/cpufreq/policyX/throttle_stats/overcurrent
+ 		/sys/devices/system/cpu/cpufreq/policyX/throttle_stats/occ_reset
+ Date:		March 2016
+ Contact:	Linux kernel mailing list <linux-kernel@vger.kernel.org>
+ 		Linux for PowerPC mailing list <linuxppc-dev@ozlabs.org>
+ Description:	POWERNV CPUFreq driver's frequency throttle stats directory and
+ 		attributes
+ 
+ 		'policyX/throttle_stats' directory and all the attributes are same as
+ 		the /sys/devices/system/cpu/cpuX/cpufreq/throttle_stats directory and
+ 		attributes which give the frequency throttle information of the chip.
++>>>>>>> 1b0289848d5d (cpufreq: powernv: Add sysfs attributes to show throttle stats)
diff --cc drivers/cpufreq/powernv-cpufreq.c
index f171dd3496cc,39ac78c94be0..000000000000
--- a/drivers/cpufreq/powernv-cpufreq.c
+++ b/drivers/cpufreq/powernv-cpufreq.c
@@@ -43,14 -44,36 +43,30 @@@
  
  static struct cpufreq_frequency_table powernv_freqs[POWERNV_MAX_PSTATES+1];
  static bool rebooting, throttled, occ_reset;
 -
 -static const char * const throttle_reason[] = {
 -	"No throttling",
 -	"Power Cap",
 -	"Processor Over Temperature",
 -	"Power Supply Failure",
 -	"Over Current",
 -	"OCC Reset"
 -};
 +static unsigned int *core_to_chip_map;
  
+ enum throttle_reason_type {
+ 	NO_THROTTLE = 0,
+ 	POWERCAP,
+ 	CPU_OVERTEMP,
+ 	POWER_SUPPLY_FAILURE,
+ 	OVERCURRENT,
+ 	OCC_RESET_THROTTLE,
+ 	OCC_MAX_REASON
+ };
+ 
  static struct chip {
  	unsigned int id;
  	bool throttled;
 -	bool restore;
 -	u8 throttle_reason;
  	cpumask_t mask;
  	struct work_struct throttle;
++<<<<<<< HEAD
 +	bool restore;
++=======
+ 	int throttle_turbo;
+ 	int throttle_sub_turbo;
+ 	int reason[OCC_MAX_REASON];
++>>>>>>> 1b0289848d5d (cpufreq: powernv: Add sysfs attributes to show throttle stats)
  } *chips;
  
  static int nr_chips;
@@@ -327,21 -384,25 +379,41 @@@ static void powernv_cpufreq_throttle_ch
  	/* Check for Pmax Capping */
  	pmsr_pmax = (s8)PMSR_MAX(pmsr);
  	if (pmsr_pmax != powernv_pstate_info.max) {
 -		if (chip->throttled)
 +		if (chips[i].throttled)
  			goto next;
++<<<<<<< HEAD
 +		chips[i].throttled = true;
 +		if (pmsr_pmax < powernv_pstate_info.nominal)
 +			pr_crit("CPU %d on Chip %u has Pmax reduced below nominal frequency (%d < %d)\n",
 +				cpu, chips[i].id, pmsr_pmax,
 +				powernv_pstate_info.nominal);
 +		else
 +			pr_info("CPU %d on Chip %u has Pmax reduced below turbo frequency (%d < %d)\n",
 +				cpu, chips[i].id, pmsr_pmax,
 +				powernv_pstate_info.max);
 +	} else if (chips[i].throttled) {
 +		chips[i].throttled = false;
 +		pr_info("CPU %d on Chip %u has Pmax restored to %d\n", cpu,
 +			chips[i].id, pmsr_pmax);
++=======
+ 		chip->throttled = true;
+ 		if (pmsr_pmax < powernv_pstate_info.nominal) {
+ 			pr_warn_once("CPU %d on Chip %u has Pmax reduced below nominal frequency (%d < %d)\n",
+ 				     cpu, chip->id, pmsr_pmax,
+ 				     powernv_pstate_info.nominal);
+ 			chip->throttle_sub_turbo++;
+ 		} else {
+ 			chip->throttle_turbo++;
+ 		}
+ 		trace_powernv_throttle(chip->id,
+ 				      throttle_reason[chip->throttle_reason],
+ 				      pmsr_pmax);
+ 	} else if (chip->throttled) {
+ 		chip->throttled = false;
+ 		trace_powernv_throttle(chip->id,
+ 				      throttle_reason[chip->throttle_reason],
+ 				      pmsr_pmax);
++>>>>>>> 1b0289848d5d (cpufreq: powernv: Add sysfs attributes to show throttle stats)
  	}
  
  	/* Check if Psafe_mode_active is set in PMSR. */
@@@ -509,23 -577,20 +596,35 @@@ static int powernv_cpufreq_occ_msg(stru
  			return 0;
  		}
  
++<<<<<<< HEAD
 +		if (omsg.throttle_status &&
 +		    omsg.throttle_status <= OCC_MAX_THROTTLE_STATUS)
 +			pr_info("OCC: Chip %u Pmax reduced due to %s\n",
 +				(unsigned int)omsg.chip,
 +				throttle_reason[omsg.throttle_status]);
 +		else if (!omsg.throttle_status)
 +			pr_info("OCC: Chip %u %s\n", (unsigned int)omsg.chip,
 +				throttle_reason[omsg.throttle_status]);
 +		else
 +			return 0;
++=======
+ 		for (i = 0; i < nr_chips; i++)
+ 			if (chips[i].id == omsg.chip)
+ 				break;
+ 
+ 		if (omsg.throttle_status >= 0 &&
+ 		    omsg.throttle_status <= OCC_MAX_THROTTLE_STATUS) {
+ 			chips[i].throttle_reason = omsg.throttle_status;
+ 			chips[i].reason[omsg.throttle_status]++;
+ 		}
++>>>>>>> 1b0289848d5d (cpufreq: powernv: Add sysfs attributes to show throttle stats)
  
 -		if (!omsg.throttle_status)
 -			chips[i].restore = true;
 -
 -		schedule_work(&chips[i].throttle);
 +		for (i = 0; i < nr_chips; i++)
 +			if (chips[i].id == omsg.chip) {
 +				if (!omsg.throttle_status)
 +					chips[i].restore = true;
 +				schedule_work(&chips[i].throttle);
 +			}
  	}
  	return 0;
  }
* Unmerged path Documentation/ABI/testing/sysfs-devices-system-cpu
* Unmerged path drivers/cpufreq/powernv-cpufreq.c
