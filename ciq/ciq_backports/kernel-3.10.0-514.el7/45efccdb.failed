netfilter: xt_TEE: fix NULL dereference

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 45efccdbec3cd465c4776ed9ca1d7b1bba1b7e34
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/45efccdb.failed

iptables -I INPUT ... -j TEE --gateway 10.1.2.3

<crash> because --oif was not specified

tee_tg_check() sets ->priv pointer to NULL in this case.

Fixes: bbde9fc1824a ("netfilter: factor out packet duplication for IPv4/IPv6")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 45efccdbec3cd465c4776ed9ca1d7b1bba1b7e34)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/xt_TEE.c
diff --cc net/netfilter/xt_TEE.c
index 1323252c4f67,c5fdea18a9af..000000000000
--- a/net/netfilter/xt_TEE.c
+++ b/net/netfilter/xt_TEE.c
@@@ -83,51 -31,10 +83,57 @@@ static unsigned in
  tee_tg4(struct sk_buff *skb, const struct xt_action_param *par)
  {
  	const struct xt_tee_tginfo *info = par->targinfo;
++<<<<<<< HEAD
 +	struct iphdr *iph;
 +
 +	if (__this_cpu_read(nf_skb_duplicated))
 +		return XT_CONTINUE;
 +	/*
 +	 * Copy the skb, and route the copy. Will later return %XT_CONTINUE for
 +	 * the original skb, which should continue on its way as if nothing has
 +	 * happened. The copy should be independently delivered to the TEE
 +	 * --gateway.
 +	 */
 +	skb = pskb_copy(skb, GFP_ATOMIC);
 +	if (skb == NULL)
 +		return XT_CONTINUE;
++=======
+ 	int oif = info->priv ? info->priv->oif : 0;
+ 
+ 	nf_dup_ipv4(skb, par->hooknum, &info->gw.in, oif);
++>>>>>>> 45efccdbec3c (netfilter: xt_TEE: fix NULL dereference)
 +
 +#if IS_ENABLED(CONFIG_NF_CONNTRACK)
 +	/* Avoid counting cloned packets towards the original connection. */
 +	nf_conntrack_put(skb->nfct);
 +	skb->nfct     = &nf_ct_untracked_get()->ct_general;
 +	skb->nfctinfo = IP_CT_NEW;
 +	nf_conntrack_get(skb->nfct);
 +#endif
 +	/*
 +	 * If we are in PREROUTING/INPUT, the checksum must be recalculated
 +	 * since the length could have changed as a result of defragmentation.
 +	 *
 +	 * We also decrease the TTL to mitigate potential TEE loops
 +	 * between two hosts.
 +	 *
 +	 * Set %IP_DF so that the original source is notified of a potentially
 +	 * decreased MTU on the clone route. IPv6 does this too.
 +	 */
 +	iph = ip_hdr(skb);
 +	iph->frag_off |= htons(IP_DF);
 +	if (par->hooknum == NF_INET_PRE_ROUTING ||
 +	    par->hooknum == NF_INET_LOCAL_IN)
 +		--iph->ttl;
 +	ip_send_check(iph);
  
 +	if (tee_tg_route4(skb, info)) {
 +		__this_cpu_write(nf_skb_duplicated, true);
 +		ip_local_out(skb);
 +		__this_cpu_write(nf_skb_duplicated, false);
 +	} else {
 +		kfree_skb(skb);
 +	}
  	return XT_CONTINUE;
  }
  
@@@ -166,31 -43,10 +172,36 @@@ static unsigned in
  tee_tg6(struct sk_buff *skb, const struct xt_action_param *par)
  {
  	const struct xt_tee_tginfo *info = par->targinfo;
+ 	int oif = info->priv ? info->priv->oif : 0;
  
++<<<<<<< HEAD
 +	if (__this_cpu_read(nf_skb_duplicated))
 +		return XT_CONTINUE;
 +	skb = pskb_copy(skb, GFP_ATOMIC);
 +	if (skb == NULL)
 +		return XT_CONTINUE;
++=======
+ 	nf_dup_ipv6(skb, par->hooknum, &info->gw.in6, oif);
++>>>>>>> 45efccdbec3c (netfilter: xt_TEE: fix NULL dereference)
  
 +#if IS_ENABLED(CONFIG_NF_CONNTRACK)
 +	nf_conntrack_put(skb->nfct);
 +	skb->nfct     = &nf_ct_untracked_get()->ct_general;
 +	skb->nfctinfo = IP_CT_NEW;
 +	nf_conntrack_get(skb->nfct);
 +#endif
 +	if (par->hooknum == NF_INET_PRE_ROUTING ||
 +	    par->hooknum == NF_INET_LOCAL_IN) {
 +		struct ipv6hdr *iph = ipv6_hdr(skb);
 +		--iph->hop_limit;
 +	}
 +	if (tee_tg_route6(skb, info)) {
 +		__this_cpu_write(nf_skb_duplicated, true);
 +		ip6_local_out(skb);
 +		__this_cpu_write(nf_skb_duplicated, false);
 +	} else {
 +		kfree_skb(skb);
 +	}
  	return XT_CONTINUE;
  }
  #endif
* Unmerged path net/netfilter/xt_TEE.c
