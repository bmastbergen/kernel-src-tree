i40e: Change the default for VFs to be not privileged

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Anjali Singhai Jain <anjali.singhai@intel.com>
commit 692fb0a75e816d2676f222c9db33e91f46ea1e03
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/692fb0a7.failed

Make sure a VF is not trusted/privileged until its explicitly
set for trust through the new NDO op interface.

Change-Id: I476385c290d2b4901d8fceb29de43546accdc499
	Signed-off-by: Anjali Singhai Jain <anjali.singhai@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 692fb0a75e816d2676f222c9db33e91f46ea1e03)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index d901afb6a12a,4c365d7f2ed1..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -1801,6 -2128,201 +1805,204 @@@ error_param
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * i40e_vc_iwarp_msg
+  * @vf: pointer to the VF info
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  *
+  * called from the VF for the iwarp msgs
+  **/
+ static int i40e_vc_iwarp_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)
+ {
+ 	struct i40e_pf *pf = vf->pf;
+ 	int abs_vf_id = vf->vf_id + pf->hw.func_caps.vf_base_id;
+ 	i40e_status aq_ret = 0;
+ 
+ 	if (!test_bit(I40E_VF_STAT_ACTIVE, &vf->vf_states) ||
+ 	    !test_bit(I40E_VF_STAT_IWARPENA, &vf->vf_states)) {
+ 		aq_ret = I40E_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	i40e_notify_client_of_vf_msg(pf->vsi[pf->lan_vsi], abs_vf_id,
+ 				     msg, msglen);
+ 
+ error_param:
+ 	/* send the response to the VF */
+ 	return i40e_vc_send_resp_to_vf(vf, I40E_VIRTCHNL_OP_IWARP,
+ 				       aq_ret);
+ }
+ 
+ /**
+  * i40e_vc_iwarp_qvmap_msg
+  * @vf: pointer to the VF info
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  * @config: config qvmap or release it
+  *
+  * called from the VF for the iwarp msgs
+  **/
+ static int i40e_vc_iwarp_qvmap_msg(struct i40e_vf *vf, u8 *msg, u16 msglen,
+ 				   bool config)
+ {
+ 	struct i40e_virtchnl_iwarp_qvlist_info *qvlist_info =
+ 				(struct i40e_virtchnl_iwarp_qvlist_info *)msg;
+ 	i40e_status aq_ret = 0;
+ 
+ 	if (!test_bit(I40E_VF_STAT_ACTIVE, &vf->vf_states) ||
+ 	    !test_bit(I40E_VF_STAT_IWARPENA, &vf->vf_states)) {
+ 		aq_ret = I40E_ERR_PARAM;
+ 		goto error_param;
+ 	}
+ 
+ 	if (config) {
+ 		if (i40e_config_iwarp_qvlist(vf, qvlist_info))
+ 			aq_ret = I40E_ERR_PARAM;
+ 	} else {
+ 		i40e_release_iwarp_qvlist(vf);
+ 	}
+ 
+ error_param:
+ 	/* send the response to the VF */
+ 	return i40e_vc_send_resp_to_vf(vf,
+ 			       config ? I40E_VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP :
+ 			       I40E_VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP,
+ 			       aq_ret);
+ }
+ 
+ /**
+  * i40e_vc_config_rss_key
+  * @vf: pointer to the VF info
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  *
+  * Configure the VF's RSS key
+  **/
+ static int i40e_vc_config_rss_key(struct i40e_vf *vf, u8 *msg, u16 msglen)
+ {
+ 	struct i40e_virtchnl_rss_key *vrk =
+ 		(struct i40e_virtchnl_rss_key *)msg;
+ 	struct i40e_pf *pf = vf->pf;
+ 	struct i40e_vsi *vsi = NULL;
+ 	u16 vsi_id = vrk->vsi_id;
+ 	i40e_status aq_ret = 0;
+ 
+ 	if (!test_bit(I40E_VF_STAT_ACTIVE, &vf->vf_states) ||
+ 	    !i40e_vc_isvalid_vsi_id(vf, vsi_id) ||
+ 	    (vrk->key_len != I40E_HKEY_ARRAY_SIZE)) {
+ 		aq_ret = I40E_ERR_PARAM;
+ 		goto err;
+ 	}
+ 
+ 	vsi = pf->vsi[vf->lan_vsi_idx];
+ 	aq_ret = i40e_config_rss(vsi, vrk->key, NULL, 0);
+ err:
+ 	/* send the response to the VF */
+ 	return i40e_vc_send_resp_to_vf(vf, I40E_VIRTCHNL_OP_CONFIG_RSS_KEY,
+ 				       aq_ret);
+ }
+ 
+ /**
+  * i40e_vc_config_rss_lut
+  * @vf: pointer to the VF info
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  *
+  * Configure the VF's RSS LUT
+  **/
+ static int i40e_vc_config_rss_lut(struct i40e_vf *vf, u8 *msg, u16 msglen)
+ {
+ 	struct i40e_virtchnl_rss_lut *vrl =
+ 		(struct i40e_virtchnl_rss_lut *)msg;
+ 	struct i40e_pf *pf = vf->pf;
+ 	struct i40e_vsi *vsi = NULL;
+ 	u16 vsi_id = vrl->vsi_id;
+ 	i40e_status aq_ret = 0;
+ 
+ 	if (!test_bit(I40E_VF_STAT_ACTIVE, &vf->vf_states) ||
+ 	    !i40e_vc_isvalid_vsi_id(vf, vsi_id) ||
+ 	    (vrl->lut_entries != I40E_VF_HLUT_ARRAY_SIZE)) {
+ 		aq_ret = I40E_ERR_PARAM;
+ 		goto err;
+ 	}
+ 
+ 	vsi = pf->vsi[vf->lan_vsi_idx];
+ 	aq_ret = i40e_config_rss(vsi, NULL, vrl->lut, I40E_VF_HLUT_ARRAY_SIZE);
+ 	/* send the response to the VF */
+ err:
+ 	return i40e_vc_send_resp_to_vf(vf, I40E_VIRTCHNL_OP_CONFIG_RSS_LUT,
+ 				       aq_ret);
+ }
+ 
+ /**
+  * i40e_vc_get_rss_hena
+  * @vf: pointer to the VF info
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  *
+  * Return the RSS HENA bits allowed by the hardware
+  **/
+ static int i40e_vc_get_rss_hena(struct i40e_vf *vf, u8 *msg, u16 msglen)
+ {
+ 	struct i40e_virtchnl_rss_hena *vrh = NULL;
+ 	struct i40e_pf *pf = vf->pf;
+ 	i40e_status aq_ret = 0;
+ 	int len = 0;
+ 
+ 	if (!test_bit(I40E_VF_STAT_ACTIVE, &vf->vf_states)) {
+ 		aq_ret = I40E_ERR_PARAM;
+ 		goto err;
+ 	}
+ 	len = sizeof(struct i40e_virtchnl_rss_hena);
+ 
+ 	vrh = kzalloc(len, GFP_KERNEL);
+ 	if (!vrh) {
+ 		aq_ret = I40E_ERR_NO_MEMORY;
+ 		len = 0;
+ 		goto err;
+ 	}
+ 	vrh->hena = i40e_pf_get_default_rss_hena(pf);
+ err:
+ 	/* send the response back to the VF */
+ 	aq_ret = i40e_vc_send_msg_to_vf(vf, I40E_VIRTCHNL_OP_GET_RSS_HENA_CAPS,
+ 					aq_ret, (u8 *)vrh, len);
+ 	return aq_ret;
+ }
+ 
+ /**
+  * i40e_vc_set_rss_hena
+  * @vf: pointer to the VF info
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  *
+  * Set the RSS HENA bits for the VF
+  **/
+ static int i40e_vc_set_rss_hena(struct i40e_vf *vf, u8 *msg, u16 msglen)
+ {
+ 	struct i40e_virtchnl_rss_hena *vrh =
+ 		(struct i40e_virtchnl_rss_hena *)msg;
+ 	struct i40e_pf *pf = vf->pf;
+ 	struct i40e_hw *hw = &pf->hw;
+ 	i40e_status aq_ret = 0;
+ 
+ 	if (!test_bit(I40E_VF_STAT_ACTIVE, &vf->vf_states)) {
+ 		aq_ret = I40E_ERR_PARAM;
+ 		goto err;
+ 	}
+ 	i40e_write_rx_ctl(hw, I40E_VFQF_HENA1(0, vf->vf_id), (u32)vrh->hena);
+ 	i40e_write_rx_ctl(hw, I40E_VFQF_HENA1(1, vf->vf_id),
+ 			  (u32)(vrh->hena >> 32));
+ 
+ 	/* send the response to the VF */
+ err:
+ 	return i40e_vc_send_resp_to_vf(vf, I40E_VIRTCHNL_OP_SET_RSS_HENA,
+ 				       aq_ret);
+ }
+ 
+ /**
++>>>>>>> 692fb0a75e81 (i40e: Change the default for VFs to be not privileged)
   * i40e_vc_validate_vf_msg
   * @vf: pointer to the VF info
   * @msg: pointer to the msg buffer
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
