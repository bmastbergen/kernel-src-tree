sctp: allow sctp_transmit_packet and others to use gfp

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
commit cea8768f333e3f0bc231d8b815aa4a9e63fa990c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/cea8768f.failed

Currently sctp_sendmsg() triggers some calls that will allocate memory
with GFP_ATOMIC even when not necessary. In the case of
sctp_packet_transmit it will allocate a linear skb that will be used to
construct the packet and this may cause sends to fail due to ENOMEM more
often than anticipated specially with big MTUs.

This patch thus allows it to inherit gfp flags from upper calls so that
it can use GFP_KERNEL if it was triggered by a sctp_sendmsg call or
similar. All others, like retransmits or flushes started from BH, are
still allocated using GFP_ATOMIC.

In netperf tests this didn't result in any performance drawbacks when
memory is not too fragmented and made it trigger ENOMEM way less often.

	Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cea8768f333e3f0bc231d8b815aa4a9e63fa990c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/sm_make_chunk.c
diff --cc net/sctp/sm_make_chunk.c
index 226deffa4e7d,8449ca26aa0b..000000000000
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@@ -68,9 -61,14 +68,20 @@@
  #include <net/sctp/sctp.h>
  #include <net/sctp/sm.h>
  
++<<<<<<< HEAD
 +SCTP_STATIC
 +struct sctp_chunk *sctp_make_chunk(const struct sctp_association *asoc,
 +				   __u8 type, __u8 flags, int paylen);
++=======
+ static struct sctp_chunk *sctp_make_control(const struct sctp_association *asoc,
+ 					    __u8 type, __u8 flags, int paylen,
+ 					    gfp_t gfp);
+ static struct sctp_chunk *sctp_make_data(const struct sctp_association *asoc,
+ 					 __u8 flags, int paylen, gfp_t gfp);
+ static struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,
+ 					   __u8 type, __u8 flags, int paylen,
+ 					   gfp_t gfp);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  static sctp_cookie_param_t *sctp_pack_cookie(const struct sctp_endpoint *ep,
  					const struct sctp_association *asoc,
  					const struct sctp_chunk *init_chunk,
@@@ -298,7 -320,7 +309,11 @@@ struct sctp_chunk *sctp_make_init(cons
  	 * PLEASE DO NOT FIXME [This version does not support Host Name.]
  	 */
  
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_INIT, 0, chunksize);
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_INIT, 0, chunksize, gfp);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  	if (!retval)
  		goto nodata;
  
@@@ -445,7 -467,7 +460,11 @@@ struct sctp_chunk *sctp_make_init_ack(c
  					num_ext);
  
  	/* Now allocate and fill out the chunk.  */
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_INIT_ACK, 0, chunksize);
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_INIT_ACK, 0, chunksize, gfp);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  	if (!retval)
  		goto nomem_chunk;
  
@@@ -550,7 -572,8 +569,12 @@@ struct sctp_chunk *sctp_make_cookie_ech
  	cookie_len = asoc->peer.cookie_len;
  
  	/* Build a cookie echo chunk.  */
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_COOKIE_ECHO, 0, cookie_len);
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_COOKIE_ECHO, 0,
+ 				   cookie_len, GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  	if (!retval)
  		goto nodata;
  	retval->subh.cookie_hdr =
@@@ -595,7 -618,7 +619,11 @@@ struct sctp_chunk *sctp_make_cookie_ack
  {
  	struct sctp_chunk *retval;
  
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_COOKIE_ACK, 0, 0);
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_COOKIE_ACK, 0, 0, GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  
  	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
  	 *
@@@ -643,8 -666,8 +671,13 @@@ struct sctp_chunk *sctp_make_cwr(const 
  	sctp_cwrhdr_t cwr;
  
  	cwr.lowest_tsn = htonl(lowest_tsn);
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_ECN_CWR, 0,
 +				 sizeof(sctp_cwrhdr_t));
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_ECN_CWR, 0,
+ 				   sizeof(sctp_cwrhdr_t), GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  
  	if (!retval)
  		goto nodata;
@@@ -677,8 -700,8 +710,13 @@@ struct sctp_chunk *sctp_make_ecne(cons
  	sctp_ecnehdr_t ecne;
  
  	ecne.lowest_tsn = htonl(lowest_tsn);
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_ECN_ECNE, 0,
 +				 sizeof(sctp_ecnehdr_t));
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_ECN_ECNE, 0,
+ 				   sizeof(sctp_ecnehdr_t), GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  	if (!retval)
  		goto nodata;
  	retval->subh.ecne_hdr =
@@@ -714,7 -738,7 +753,11 @@@ struct sctp_chunk *sctp_make_datafrag_e
  		dp.ssn = htons(ssn);
  
  	chunk_len = sizeof(dp) + data_len;
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_DATA, flags, chunk_len);
++=======
+ 	retval = sctp_make_data(asoc, flags, chunk_len, gfp);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  	if (!retval)
  		goto nodata;
  
@@@ -760,7 -785,7 +803,11 @@@ struct sctp_chunk *sctp_make_sack(cons
  		+ sizeof(__u32) * num_dup_tsns;
  
  	/* Create the chunk.  */
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_SACK, 0, len);
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_SACK, 0, len, GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  	if (!retval)
  		goto nodata;
  
@@@ -839,8 -864,8 +886,13 @@@ struct sctp_chunk *sctp_make_shutdown(c
  	ctsn = sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map);
  	shut.cum_tsn_ack = htonl(ctsn);
  
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_SHUTDOWN, 0,
 +				 sizeof(sctp_shutdownhdr_t));
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN, 0,
+ 				   sizeof(sctp_shutdownhdr_t), GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  	if (!retval)
  		goto nodata;
  
@@@ -858,7 -883,8 +910,12 @@@ struct sctp_chunk *sctp_make_shutdown_a
  {
  	struct sctp_chunk *retval;
  
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0);
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0,
+ 				   GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  
  	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
  	 *
@@@ -887,7 -913,8 +944,12 @@@ struct sctp_chunk *sctp_make_shutdown_c
  	 */
  	flags |= asoc ? 0 : SCTP_CHUNK_FLAG_T;
  
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_SHUTDOWN_COMPLETE, flags, 0);
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_COMPLETE, flags,
+ 				   0, GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  
  	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
  	 *
@@@ -926,7 -953,8 +988,12 @@@ struct sctp_chunk *sctp_make_abort(cons
  			flags = SCTP_CHUNK_FLAG_T;
  	}
  
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_ABORT, flags, hint);
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_ABORT, flags, hint,
+ 				   GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  
  	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
  	 *
@@@ -1118,7 -1146,8 +1185,12 @@@ struct sctp_chunk *sctp_make_heartbeat(
  	struct sctp_chunk *retval;
  	sctp_sender_hb_info_t hbinfo;
  
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_HEARTBEAT, 0, sizeof(hbinfo));
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_HEARTBEAT, 0,
+ 				   sizeof(hbinfo), GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  
  	if (!retval)
  		goto nodata;
@@@ -1146,7 -1175,8 +1218,12 @@@ struct sctp_chunk *sctp_make_heartbeat_
  {
  	struct sctp_chunk *retval;
  
++<<<<<<< HEAD
 +	retval  = sctp_make_chunk(asoc, SCTP_CID_HEARTBEAT_ACK, 0, paylen);
++=======
+ 	retval  = sctp_make_control(asoc, SCTP_CID_HEARTBEAT_ACK, 0, paylen,
+ 				    GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  	if (!retval)
  		goto nodata;
  
@@@ -1178,8 -1208,8 +1255,13 @@@ static struct sctp_chunk *sctp_make_op_
  {
  	struct sctp_chunk *retval;
  
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_ERROR, 0,
 +				 sizeof(sctp_errhdr_t) + size);
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_ERROR, 0,
+ 				   sizeof(sctp_errhdr_t) + size, GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  	if (!retval)
  		goto nodata;
  
@@@ -1249,8 -1279,9 +1331,14 @@@ struct sctp_chunk *sctp_make_auth(cons
  	if (unlikely(!hmac_desc))
  		return NULL;
  
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_AUTH, 0,
 +			hmac_desc->hmac_len + sizeof(sctp_authhdr_t));
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_AUTH, 0,
+ 			hmac_desc->hmac_len + sizeof(sctp_authhdr_t),
+ 			GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  	if (!retval)
  		return NULL;
  
@@@ -1354,9 -1370,9 +1442,15 @@@ const union sctp_addr *sctp_source(cons
  /* Create a new chunk, setting the type and flags headers from the
   * arguments, reserving enough space for a 'paylen' byte payload.
   */
++<<<<<<< HEAD
 +SCTP_STATIC
 +struct sctp_chunk *sctp_make_chunk(const struct sctp_association *asoc,
 +				   __u8 type, __u8 flags, int paylen)
++=======
+ static struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,
+ 					    __u8 type, __u8 flags, int paylen,
+ 					    gfp_t gfp)
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  {
  	struct sctp_chunk *retval;
  	sctp_chunkhdr_t *chunk_hdr;
@@@ -1397,6 -1409,24 +1490,27 @@@ nodata
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ static struct sctp_chunk *sctp_make_data(const struct sctp_association *asoc,
+ 					 __u8 flags, int paylen, gfp_t gfp)
+ {
+ 	return _sctp_make_chunk(asoc, SCTP_CID_DATA, flags, paylen, gfp);
+ }
+ 
+ static struct sctp_chunk *sctp_make_control(const struct sctp_association *asoc,
+ 					    __u8 type, __u8 flags, int paylen,
+ 					    gfp_t gfp)
+ {
+ 	struct sctp_chunk *chunk;
+ 
+ 	chunk = _sctp_make_chunk(asoc, type, flags, paylen, gfp);
+ 	if (chunk)
+ 		sctp_control_set_owner_w(chunk);
+ 
+ 	return chunk;
+ }
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  
  /* Release the memory occupied by a chunk.  */
  static void sctp_chunk_destroy(struct sctp_chunk *chunk)
@@@ -2740,7 -2768,8 +2854,12 @@@ static struct sctp_chunk *sctp_make_asc
  	length += addrlen;
  
  	/* Create the chunk.  */
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_ASCONF, 0, length);
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_ASCONF, 0, length,
+ 				   GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  	if (!retval)
  		return NULL;
  
@@@ -2921,7 -2953,8 +3040,12 @@@ static struct sctp_chunk *sctp_make_asc
  	int			length = sizeof(asconf) + vparam_len;
  
  	/* Create the chunk.  */
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_ASCONF_ACK, 0, length);
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_ASCONF_ACK, 0, length,
+ 				   GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  	if (!retval)
  		return NULL;
  
@@@ -3481,7 -3514,7 +3605,11 @@@ struct sctp_chunk *sctp_make_fwdtsn(con
  
  	hint = (nstreams + 1) * sizeof(__u32);
  
++<<<<<<< HEAD
 +	retval = sctp_make_chunk(asoc, SCTP_CID_FWD_TSN, 0, hint);
++=======
+ 	retval = sctp_make_control(asoc, SCTP_CID_FWD_TSN, 0, hint, GFP_ATOMIC);
++>>>>>>> cea8768f333e (sctp: allow sctp_transmit_packet and others to use gfp)
  
  	if (!retval)
  		return NULL;
diff --git a/include/net/sctp/sm.h b/include/net/sctp/sm.h
index c4c9458f37cd..5ca449f35190 100644
--- a/include/net/sctp/sm.h
+++ b/include/net/sctp/sm.h
@@ -208,7 +208,7 @@ struct sctp_chunk *sctp_make_cwr(const struct sctp_association *,
 struct sctp_chunk * sctp_make_datafrag_empty(struct sctp_association *,
 					const struct sctp_sndrcvinfo *sinfo,
 					int len, const __u8 flags,
-					__u16 ssn);
+					__u16 ssn, gfp_t gfp);
 struct sctp_chunk *sctp_make_ecne(const struct sctp_association *,
 				  const __u32);
 struct sctp_chunk *sctp_make_sack(const struct sctp_association *);
diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7a7c7cb8b173..df4089a9afba 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -666,7 +666,7 @@ void  *sctp_addto_chunk(struct sctp_chunk *, int len, const void *data);
 void  *sctp_addto_chunk_fixed(struct sctp_chunk *, int len, const void *data);
 struct sctp_chunk *sctp_chunkify(struct sk_buff *,
 				 const struct sctp_association *,
-				 struct sock *);
+				 struct sock *, gfp_t gfp);
 void sctp_init_addrs(struct sctp_chunk *, union sctp_addr *,
 		     union sctp_addr *);
 const union sctp_addr *sctp_source(const struct sctp_chunk *chunk);
@@ -728,10 +728,10 @@ struct sctp_packet *sctp_packet_init(struct sctp_packet *,
 				     __u16 sport, __u16 dport);
 struct sctp_packet *sctp_packet_config(struct sctp_packet *, __u32 vtag, int);
 sctp_xmit_t sctp_packet_transmit_chunk(struct sctp_packet *,
-                                       struct sctp_chunk *, int);
+				       struct sctp_chunk *, int, gfp_t);
 sctp_xmit_t sctp_packet_append_chunk(struct sctp_packet *,
                                      struct sctp_chunk *);
-int sctp_packet_transmit(struct sctp_packet *);
+int sctp_packet_transmit(struct sctp_packet *, gfp_t);
 void sctp_packet_free(struct sctp_packet *);
 
 static inline int sctp_packet_empty(struct sctp_packet *packet)
@@ -1067,7 +1067,7 @@ struct sctp_outq {
 void sctp_outq_init(struct sctp_association *, struct sctp_outq *);
 void sctp_outq_teardown(struct sctp_outq *);
 void sctp_outq_free(struct sctp_outq*);
-int sctp_outq_tail(struct sctp_outq *, struct sctp_chunk *chunk);
+int sctp_outq_tail(struct sctp_outq *, struct sctp_chunk *chunk, gfp_t);
 int sctp_outq_sack(struct sctp_outq *, struct sctp_chunk *);
 int sctp_outq_is_empty(const struct sctp_outq *);
 void sctp_outq_restart(struct sctp_outq *);
@@ -1075,7 +1075,7 @@ void sctp_outq_restart(struct sctp_outq *);
 void sctp_retransmit(struct sctp_outq *, struct sctp_transport *,
 		     sctp_retransmit_reason_t);
 void sctp_retransmit_mark(struct sctp_outq *, struct sctp_transport *, __u8);
-int sctp_outq_uncork(struct sctp_outq *);
+int sctp_outq_uncork(struct sctp_outq *, gfp_t gfp);
 /* Uncork and flush an outqueue.  */
 static inline void sctp_outq_cork(struct sctp_outq *q)
 {
diff --git a/net/sctp/associola.c b/net/sctp/associola.c
index 95613ef42a0c..eaf4736c6207 100644
--- a/net/sctp/associola.c
+++ b/net/sctp/associola.c
@@ -1475,7 +1475,7 @@ void sctp_assoc_rwnd_increase(struct sctp_association *asoc, unsigned int len)
 
 		asoc->peer.sack_needed = 0;
 
-		sctp_outq_tail(&asoc->outqueue, sack);
+		sctp_outq_tail(&asoc->outqueue, sack, GFP_ATOMIC);
 
 		/* Stop the SACK timer.  */
 		timer = &asoc->timers[SCTP_EVENT_TIMEOUT_SACK];
diff --git a/net/sctp/chunk.c b/net/sctp/chunk.c
index 3a4892aa38ae..f2f50e515408 100644
--- a/net/sctp/chunk.c
+++ b/net/sctp/chunk.c
@@ -278,7 +278,8 @@ struct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *asoc,
 				frag |= SCTP_DATA_SACK_IMM;
 		}
 
-		chunk = sctp_make_datafrag_empty(asoc, sinfo, len, frag, 0);
+		chunk = sctp_make_datafrag_empty(asoc, sinfo, len, frag,
+						 0, GFP_KERNEL);
 
 		if (!chunk) {
 			err = -ENOMEM;
@@ -316,7 +317,8 @@ struct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *asoc,
 		    (sinfo->sinfo_flags & SCTP_SACK_IMMEDIATELY))
 			frag |= SCTP_DATA_SACK_IMM;
 
-		chunk = sctp_make_datafrag_empty(asoc, sinfo, over, frag, 0);
+		chunk = sctp_make_datafrag_empty(asoc, sinfo, over, frag,
+						 0, GFP_KERNEL);
 
 		if (!chunk) {
 			err = -ENOMEM;
diff --git a/net/sctp/input.c b/net/sctp/input.c
index 336fe69bc6d8..e13a807aef13 100644
--- a/net/sctp/input.c
+++ b/net/sctp/input.c
@@ -229,7 +229,7 @@ int sctp_rcv(struct sk_buff *skb)
 		goto discard_release;
 
 	/* Create an SCTP packet structure. */
-	chunk = sctp_chunkify(skb, asoc, sk);
+	chunk = sctp_chunkify(skb, asoc, sk, GFP_ATOMIC);
 	if (!chunk)
 		goto discard_release;
 	SCTP_INPUT_CB(skb)->chunk = chunk;
diff --git a/net/sctp/output.c b/net/sctp/output.c
index 65d3554b32be..6a651b1eaba5 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -162,7 +162,7 @@ void sctp_packet_free(struct sctp_packet *packet)
  */
 sctp_xmit_t sctp_packet_transmit_chunk(struct sctp_packet *packet,
 				       struct sctp_chunk *chunk,
-				       int one_packet)
+				       int one_packet, gfp_t gfp)
 {
 	sctp_xmit_t retval;
 	int error = 0;
@@ -173,7 +173,7 @@ sctp_xmit_t sctp_packet_transmit_chunk(struct sctp_packet *packet,
 	switch ((retval = (sctp_packet_append_chunk(packet, chunk)))) {
 	case SCTP_XMIT_PMTU_FULL:
 		if (!packet->has_cookie_echo) {
-			error = sctp_packet_transmit(packet);
+			error = sctp_packet_transmit(packet, gfp);
 			if (error < 0)
 				chunk->skb->sk->sk_err = -error;
 
@@ -387,7 +387,7 @@ static void sctp_packet_set_owner_w(struct sk_buff *skb, struct sock *sk)
  *
  * The return value is a normal kernel error return value.
  */
-int sctp_packet_transmit(struct sctp_packet *packet)
+int sctp_packet_transmit(struct sctp_packet *packet, gfp_t gfp)
 {
 	struct sctp_transport *tp = packet->transport;
 	struct sctp_association *asoc = tp->asoc;
diff --git a/net/sctp/outqueue.c b/net/sctp/outqueue.c
index bd35dc2b52ec..6f14dec38201 100644
--- a/net/sctp/outqueue.c
+++ b/net/sctp/outqueue.c
@@ -75,7 +75,7 @@ static void sctp_mark_missing(struct sctp_outq *q,
 
 static void sctp_generate_fwdtsn(struct sctp_outq *q, __u32 sack_ctsn);
 
-static int sctp_outq_flush(struct sctp_outq *q, int rtx_timeout);
+static int sctp_outq_flush(struct sctp_outq *q, int rtx_timeout, gfp_t gfp);
 
 /* Add data to the front of the queue. */
 static inline void sctp_outq_head_data(struct sctp_outq *q,
@@ -294,7 +294,7 @@ void sctp_outq_free(struct sctp_outq *q)
 }
 
 /* Put a new chunk in an sctp_outq.  */
-int sctp_outq_tail(struct sctp_outq *q, struct sctp_chunk *chunk)
+int sctp_outq_tail(struct sctp_outq *q, struct sctp_chunk *chunk, gfp_t gfp)
 {
 	struct net *net = sock_net(q->asoc->base.sk);
 	int error = 0;
@@ -350,7 +350,7 @@ int sctp_outq_tail(struct sctp_outq *q, struct sctp_chunk *chunk)
 		return error;
 
 	if (!q->cork)
-		error = sctp_outq_flush(q, 0);
+		error = sctp_outq_flush(q, 0, gfp);
 
 	return error;
 }
@@ -521,7 +521,7 @@ void sctp_retransmit(struct sctp_outq *q, struct sctp_transport *transport,
 	 * will be flushed at the end.
 	 */
 	if (reason != SCTP_RTXR_FAST_RTX)
-		error = sctp_outq_flush(q, /* rtx_timeout */ 1);
+		error = sctp_outq_flush(q, /* rtx_timeout */ 1, GFP_ATOMIC);
 
 	if (error)
 		q->asoc->base.sk->sk_err = -error;
@@ -612,12 +612,12 @@ redo:
 				 * control chunks are already freed so there
 				 * is nothing we can do.
 				 */
-				sctp_packet_transmit(pkt);
+				sctp_packet_transmit(pkt, GFP_ATOMIC);
 				goto redo;
 			}
 
 			/* Send this packet.  */
-			error = sctp_packet_transmit(pkt);
+			error = sctp_packet_transmit(pkt, GFP_ATOMIC);
 
 			/* If we are retransmitting, we should only
 			 * send a single packet.
@@ -633,7 +633,7 @@ redo:
 
 		case SCTP_XMIT_RWND_FULL:
 			/* Send this packet. */
-			error = sctp_packet_transmit(pkt);
+			error = sctp_packet_transmit(pkt, GFP_ATOMIC);
 
 			/* Stop sending DATA as there is no more room
 			 * at the receiver.
@@ -643,7 +643,7 @@ redo:
 
 		case SCTP_XMIT_NAGLE_DELAY:
 			/* Send this packet. */
-			error = sctp_packet_transmit(pkt);
+			error = sctp_packet_transmit(pkt, GFP_ATOMIC);
 
 			/* Stop sending DATA because of nagle delay. */
 			done = 1;
@@ -697,12 +697,12 @@ redo:
 }
 
 /* Cork the outqueue so queued chunks are really queued. */
-int sctp_outq_uncork(struct sctp_outq *q)
+int sctp_outq_uncork(struct sctp_outq *q, gfp_t gfp)
 {
 	if (q->cork)
 		q->cork = 0;
 
-	return sctp_outq_flush(q, 0);
+	return sctp_outq_flush(q, 0, gfp);
 }
 
 
@@ -715,7 +715,7 @@ int sctp_outq_uncork(struct sctp_outq *q)
  * locking concerns must be made.  Today we use the sock lock to protect
  * this function.
  */
-static int sctp_outq_flush(struct sctp_outq *q, int rtx_timeout)
+static int sctp_outq_flush(struct sctp_outq *q, int rtx_timeout, gfp_t gfp)
 {
 	struct sctp_packet *packet;
 	struct sctp_packet singleton;
@@ -837,7 +837,7 @@ static int sctp_outq_flush(struct sctp_outq *q, int rtx_timeout)
 			sctp_packet_init(&singleton, transport, sport, dport);
 			sctp_packet_config(&singleton, vtag, 0);
 			sctp_packet_append_chunk(&singleton, chunk);
-			error = sctp_packet_transmit(&singleton);
+			error = sctp_packet_transmit(&singleton, gfp);
 			if (error < 0)
 				return error;
 			break;
@@ -868,7 +868,7 @@ static int sctp_outq_flush(struct sctp_outq *q, int rtx_timeout)
 		case SCTP_CID_ASCONF:
 		case SCTP_CID_FWD_TSN:
 			status = sctp_packet_transmit_chunk(packet, chunk,
-							    one_packet);
+							    one_packet, gfp);
 			if (status  != SCTP_XMIT_OK) {
 				/* put the chunk back */
 				list_add(&chunk->list, &q->control_chunk_list);
@@ -1029,7 +1029,7 @@ static int sctp_outq_flush(struct sctp_outq *q, int rtx_timeout)
 					atomic_read(&chunk->skb->users) : -1);
 
 			/* Add the chunk to the packet.  */
-			status = sctp_packet_transmit_chunk(packet, chunk, 0);
+			status = sctp_packet_transmit_chunk(packet, chunk, 0, gfp);
 
 			switch (status) {
 			case SCTP_XMIT_PMTU_FULL:
@@ -1109,7 +1109,7 @@ sctp_flush_out:
 						      send_ready);
 		packet = &t->packet;
 		if (!sctp_packet_empty(packet))
-			error = sctp_packet_transmit(packet);
+			error = sctp_packet_transmit(packet, gfp);
 
 		/* Clear the burst limited state, if any */
 		sctp_transport_burst_reset(t);
* Unmerged path net/sctp/sm_make_chunk.c
diff --git a/net/sctp/sm_sideeffect.c b/net/sctp/sm_sideeffect.c
index 3ff7b8167f35..3ddc991cb8b7 100644
--- a/net/sctp/sm_sideeffect.c
+++ b/net/sctp/sm_sideeffect.c
@@ -1041,13 +1041,13 @@ static void sctp_cmd_t1_timer_update(struct sctp_association *asoc,
  * encouraged for small fragments.
  */
 static int sctp_cmd_send_msg(struct sctp_association *asoc,
-				struct sctp_datamsg *msg)
+				struct sctp_datamsg *msg, gfp_t gfp)
 {
 	struct sctp_chunk *chunk;
 	int error = 0;
 
 	list_for_each_entry(chunk, &msg->chunks, frag_list) {
-		error = sctp_outq_tail(&asoc->outqueue, chunk);
+		error = sctp_outq_tail(&asoc->outqueue, chunk, gfp);
 		if (error)
 			break;
 	}
@@ -1278,7 +1278,7 @@ static int sctp_cmd_interpreter(sctp_event_t event_type,
 		case SCTP_CMD_NEW_ASOC:
 			/* Register a new association.  */
 			if (local_cork) {
-				sctp_outq_uncork(&asoc->outqueue);
+				sctp_outq_uncork(&asoc->outqueue, gfp);
 				local_cork = 0;
 			}
 
@@ -1299,7 +1299,7 @@ static int sctp_cmd_interpreter(sctp_event_t event_type,
 
 		case SCTP_CMD_DELETE_TCB:
 			if (local_cork) {
-				sctp_outq_uncork(&asoc->outqueue);
+				sctp_outq_uncork(&asoc->outqueue, gfp);
 				local_cork = 0;
 			}
 			/* Delete the current association.  */
@@ -1453,13 +1453,14 @@ static int sctp_cmd_interpreter(sctp_event_t event_type,
 				local_cork = 1;
 			}
 			/* Send a chunk to our peer.  */
-			error = sctp_outq_tail(&asoc->outqueue, cmd->obj.chunk);
+			error = sctp_outq_tail(&asoc->outqueue, cmd->obj.chunk,
+					       gfp);
 			break;
 
 		case SCTP_CMD_SEND_PKT:
 			/* Send a full packet to our peer.  */
 			packet = cmd->obj.packet;
-			sctp_packet_transmit(packet);
+			sctp_packet_transmit(packet, gfp);
 			sctp_ootb_pkt_free(packet);
 			break;
 
@@ -1669,7 +1670,7 @@ static int sctp_cmd_interpreter(sctp_event_t event_type,
 			 */
 			chunk->pdiscard = 1;
 			if (asoc) {
-				sctp_outq_uncork(&asoc->outqueue);
+				sctp_outq_uncork(&asoc->outqueue, gfp);
 				local_cork = 0;
 			}
 			break;
@@ -1707,7 +1708,7 @@ static int sctp_cmd_interpreter(sctp_event_t event_type,
 		case SCTP_CMD_FORCE_PRIM_RETRAN:
 			t = asoc->peer.retran_path;
 			asoc->peer.retran_path = asoc->peer.primary_path;
-			error = sctp_outq_uncork(&asoc->outqueue);
+			error = sctp_outq_uncork(&asoc->outqueue, gfp);
 			local_cork = 0;
 			asoc->peer.retran_path = t;
 			break;
@@ -1734,7 +1735,7 @@ static int sctp_cmd_interpreter(sctp_event_t event_type,
 				sctp_outq_cork(&asoc->outqueue);
 				local_cork = 1;
 			}
-			error = sctp_cmd_send_msg(asoc, cmd->obj.msg);
+			error = sctp_cmd_send_msg(asoc, cmd->obj.msg, gfp);
 			break;
 		case SCTP_CMD_SEND_NEXT_ASCONF:
 			sctp_cmd_send_asconf(asoc);
@@ -1764,9 +1765,9 @@ out:
 	 */
 	if (asoc && SCTP_EVENT_T_CHUNK == event_type && chunk) {
 		if (chunk->end_of_packet || chunk->singleton)
-			error = sctp_outq_uncork(&asoc->outqueue);
+			error = sctp_outq_uncork(&asoc->outqueue, gfp);
 	} else if (local_cork)
-		error = sctp_outq_uncork(&asoc->outqueue);
+		error = sctp_outq_uncork(&asoc->outqueue, gfp);
 	return error;
 nomem:
 	error = -ENOMEM;
