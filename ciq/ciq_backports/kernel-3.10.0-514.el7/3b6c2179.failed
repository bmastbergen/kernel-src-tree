i40e: Remove 100M SGMII unless hw is X722

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Catherine Sullivan <catherine.sullivan@intel.com>
commit 3b6c2179eebf4536d08cf966c9f585dd95c72367
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3b6c2179.failed

Only the X722 device now supports 100M SGMII, and nothing supports
100M on 1000Base_T.

Change-ID: I6f44dcd818944edd40041410e6de380f4a359a0c
	Signed-off-by: Catherine Sullivan <catherine.sullivan@intel.com>
	Signed-off-by: Shannon Nelson <shannon.nelson@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 3b6c2179eebf4536d08cf966c9f585dd95c72367)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_ethtool.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 0f60546f3f29,b31139127616..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@@ -351,13 -331,25 +354,16 @@@ static void i40e_get_settings_link_up(s
  		break;
  	case I40E_PHY_TYPE_SGMII:
  		ecmd->supported = SUPPORTED_Autoneg |
- 				  SUPPORTED_1000baseT_Full |
- 				  SUPPORTED_100baseT_Full;
+ 				  SUPPORTED_1000baseT_Full;
  		if (hw_link_info->requested_speeds & I40E_LINK_SPEED_1GB)
  			ecmd->advertising |= ADVERTISED_1000baseT_Full;
- 		if (hw_link_info->requested_speeds & I40E_LINK_SPEED_100MB)
- 			ecmd->advertising |= ADVERTISED_100baseT_Full;
+ 		if (pf->hw.mac.type == I40E_MAC_X722) {
+ 			ecmd->supported |= SUPPORTED_100baseT_Full;
+ 			if (hw_link_info->requested_speeds &
+ 			    I40E_LINK_SPEED_100MB)
+ 				ecmd->advertising |= ADVERTISED_100baseT_Full;
+ 		}
  		break;
 -	/* Backplane is set based on supported phy types in get_settings
 -	 * so don't set anything here but don't warn either
 -	 */
 -	case I40E_PHY_TYPE_40GBASE_KR4:
 -	case I40E_PHY_TYPE_20GBASE_KR2:
 -	case I40E_PHY_TYPE_10GBASE_KR:
 -	case I40E_PHY_TYPE_10GBASE_KX4:
 -	case I40E_PHY_TYPE_1000BASE_KX:
 -		break;
  	default:
  		/* if we got here and link is up something bad is afoot */
  		netdev_info(netdev, "WARNING: Link is up but PHY type 0x%x is not recognized.\n",
@@@ -395,65 -387,73 +401,128 @@@
   * Reports link settings that can be determined when link is down
   **/
  static void i40e_get_settings_link_down(struct i40e_hw *hw,
- 					struct ethtool_cmd *ecmd)
+ 					struct ethtool_cmd *ecmd,
+ 					struct i40e_pf *pf)
  {
 -	enum i40e_aq_capabilities_phy_type phy_types = hw->phy.phy_types;
 +	struct i40e_link_status *hw_link_info = &hw->phy.link_info;
  
  	/* link is down and the driver needs to fall back on
 -	 * supported phy types to figure out what info to display
 +	 * device ID to determine what kinds of info to display,
 +	 * it's mostly a guess that may change when link is up
  	 */
++<<<<<<< HEAD
 +	switch (hw->device_id) {
 +	case I40E_DEV_ID_QSFP_A:
 +	case I40E_DEV_ID_QSFP_B:
 +	case I40E_DEV_ID_QSFP_C:
 +		/* pluggable QSFP */
 +		ecmd->supported = SUPPORTED_40000baseSR4_Full |
 +				  SUPPORTED_40000baseCR4_Full |
 +				  SUPPORTED_40000baseLR4_Full;
 +		ecmd->advertising = ADVERTISED_40000baseSR4_Full |
 +				    ADVERTISED_40000baseCR4_Full |
 +				    ADVERTISED_40000baseLR4_Full;
 +		break;
 +	case I40E_DEV_ID_KX_B:
 +		/* backplane 40G */
 +		ecmd->supported = SUPPORTED_40000baseKR4_Full;
 +		ecmd->advertising = ADVERTISED_40000baseKR4_Full;
 +		break;
 +	case I40E_DEV_ID_KX_C:
 +		/* backplane 10G */
 +		ecmd->supported = SUPPORTED_10000baseKR_Full;
 +		ecmd->advertising = ADVERTISED_10000baseKR_Full;
 +		break;
 +	case I40E_DEV_ID_10G_BASE_T:
 +		ecmd->supported = SUPPORTED_10000baseT_Full |
 +				  SUPPORTED_1000baseT_Full |
 +				  SUPPORTED_100baseT_Full;
 +		/* Figure out what has been requested */
 +		if (hw_link_info->requested_speeds & I40E_LINK_SPEED_10GB)
 +			ecmd->advertising |= ADVERTISED_10000baseT_Full;
 +		if (hw_link_info->requested_speeds & I40E_LINK_SPEED_1GB)
 +			ecmd->advertising |= ADVERTISED_1000baseT_Full;
 +		if (hw_link_info->requested_speeds & I40E_LINK_SPEED_100MB)
 +			ecmd->advertising |= ADVERTISED_100baseT_Full;
 +		break;
 +	case I40E_DEV_ID_20G_KR2:
 +	case I40E_DEV_ID_20G_KR2_A:
 +		/* backplane 20G */
 +		ecmd->supported = SUPPORTED_20000baseKR2_Full;
 +		ecmd->advertising = ADVERTISED_20000baseKR2_Full;
 +		break;
 +	default:
 +		/* all the rest are 10G/1G */
 +		ecmd->supported = SUPPORTED_10000baseT_Full |
 +				  SUPPORTED_1000baseT_Full;
 +		/* Figure out what has been requested */
 +		if (hw_link_info->requested_speeds & I40E_LINK_SPEED_10GB)
 +			ecmd->advertising |= ADVERTISED_10000baseT_Full;
 +		if (hw_link_info->requested_speeds & I40E_LINK_SPEED_1GB)
 +			ecmd->advertising |= ADVERTISED_1000baseT_Full;
 +		break;
 +	}
++=======
+ 	ecmd->supported = 0x0;
+ 	ecmd->advertising = 0x0;
+ 	if (phy_types & I40E_CAP_PHY_TYPE_SGMII) {
+ 		ecmd->supported |= SUPPORTED_Autoneg |
+ 				   SUPPORTED_1000baseT_Full;
+ 		ecmd->advertising |= ADVERTISED_Autoneg |
+ 				     ADVERTISED_1000baseT_Full;
+ 		if (pf->hw.mac.type == I40E_MAC_X722) {
+ 			ecmd->supported |= SUPPORTED_100baseT_Full;
+ 			ecmd->advertising |= ADVERTISED_100baseT_Full;
+ 		}
+ 	}
+ 	if (phy_types & I40E_CAP_PHY_TYPE_XAUI ||
+ 	    phy_types & I40E_CAP_PHY_TYPE_XFI ||
+ 	    phy_types & I40E_CAP_PHY_TYPE_SFI ||
+ 	    phy_types & I40E_CAP_PHY_TYPE_10GBASE_SFPP_CU ||
+ 	    phy_types & I40E_CAP_PHY_TYPE_10GBASE_AOC)
+ 		ecmd->supported |= SUPPORTED_10000baseT_Full;
+ 	if (phy_types & I40E_CAP_PHY_TYPE_10GBASE_CR1_CU ||
+ 	    phy_types & I40E_CAP_PHY_TYPE_10GBASE_CR1 ||
+ 	    phy_types & I40E_CAP_PHY_TYPE_10GBASE_T ||
+ 	    phy_types & I40E_CAP_PHY_TYPE_10GBASE_SR ||
+ 	    phy_types & I40E_CAP_PHY_TYPE_10GBASE_LR) {
+ 		ecmd->supported |= SUPPORTED_Autoneg |
+ 				   SUPPORTED_10000baseT_Full;
+ 		ecmd->advertising |= ADVERTISED_Autoneg |
+ 				     ADVERTISED_10000baseT_Full;
+ 	}
+ 	if (phy_types & I40E_CAP_PHY_TYPE_XLAUI ||
+ 	    phy_types & I40E_CAP_PHY_TYPE_XLPPI ||
+ 	    phy_types & I40E_CAP_PHY_TYPE_40GBASE_AOC)
+ 		ecmd->supported |= SUPPORTED_40000baseCR4_Full;
+ 	if (phy_types & I40E_CAP_PHY_TYPE_40GBASE_CR4_CU ||
+ 	    phy_types & I40E_CAP_PHY_TYPE_40GBASE_CR4) {
+ 		ecmd->supported |= SUPPORTED_Autoneg |
+ 				  SUPPORTED_40000baseCR4_Full;
+ 		ecmd->advertising |= ADVERTISED_Autoneg |
+ 				    ADVERTISED_40000baseCR4_Full;
+ 	}
+ 	if ((phy_types & I40E_CAP_PHY_TYPE_100BASE_TX) &&
+ 	    !(phy_types & I40E_CAP_PHY_TYPE_1000BASE_T)) {
+ 		ecmd->supported |= SUPPORTED_Autoneg |
+ 				   SUPPORTED_100baseT_Full;
+ 		ecmd->advertising |= ADVERTISED_Autoneg |
+ 				     ADVERTISED_100baseT_Full;
+ 	}
+ 	if (phy_types & I40E_CAP_PHY_TYPE_1000BASE_T ||
+ 	    phy_types & I40E_CAP_PHY_TYPE_1000BASE_SX ||
+ 	    phy_types & I40E_CAP_PHY_TYPE_1000BASE_LX ||
+ 	    phy_types & I40E_CAP_PHY_TYPE_1000BASE_T_OPTICAL) {
+ 		ecmd->supported |= SUPPORTED_Autoneg |
+ 				   SUPPORTED_1000baseT_Full;
+ 		ecmd->advertising |= ADVERTISED_Autoneg |
+ 				     ADVERTISED_1000baseT_Full;
+ 	}
+ 	if (phy_types & I40E_CAP_PHY_TYPE_40GBASE_SR4)
+ 		ecmd->supported |= SUPPORTED_40000baseSR4_Full;
+ 	if (phy_types & I40E_CAP_PHY_TYPE_40GBASE_LR4)
+ 		ecmd->supported |= SUPPORTED_40000baseLR4_Full;
++>>>>>>> 3b6c2179eebf (i40e: Remove 100M SGMII unless hw is X722)
  
  	/* With no link speed and duplex are unknown */
  	ethtool_cmd_speed_set(ecmd, SPEED_UNKNOWN);
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_ethtool.c
