i40e/i40evf: Add exception handling for Tx checksum

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Duyck <aduyck@mirantis.com>
commit 529f1f652e3c3c6db6ab5a6e3a35469ddfd9575d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/529f1f65.failed

Add exception handling to the Tx checksum path so that we can handle cases
of TSO where the frame is bad, or Tx checksum where we didn't recognize a
protocol

Drop I40E_TX_FLAGS_CSUM as it is unused, move the CHECKSUM_PARTIAL check
into the function itself so that we can decrease indent.

	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 529f1f652e3c3c6db6ab5a6e3a35469ddfd9575d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_txrx.c
#	drivers/net/ethernet/intel/i40evf/i40e_txrx.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 5a3abb58e191,6b08b0fa6dcf..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@@ -2415,71 -2387,95 +2415,101 @@@ static int i40e_tsyn(struct i40e_ring *
   * @tx_ring: Tx descriptor ring
   * @cd_tunneling: ptr to context desc bits
   **/
- static void i40e_tx_enable_csum(struct sk_buff *skb, u32 *tx_flags,
- 				u32 *td_cmd, u32 *td_offset,
- 				struct i40e_ring *tx_ring,
- 				u32 *cd_tunneling)
+ static int i40e_tx_enable_csum(struct sk_buff *skb, u32 *tx_flags,
+ 			       u32 *td_cmd, u32 *td_offset,
+ 			       struct i40e_ring *tx_ring,
+ 			       u32 *cd_tunneling)
  {
++<<<<<<< HEAD
 +	struct ipv6hdr *this_ipv6_hdr;
 +	unsigned int this_tcp_hdrlen;
 +	struct iphdr *this_ip_hdr;
 +	u32 network_hdr_len;
 +	u8 l4_hdr = 0;
 +	u32 l4_tunnel = 0;
++=======
+ 	union {
+ 		struct iphdr *v4;
+ 		struct ipv6hdr *v6;
+ 		unsigned char *hdr;
+ 	} ip;
+ 	union {
+ 		struct tcphdr *tcp;
+ 		struct udphdr *udp;
+ 		unsigned char *hdr;
+ 	} l4;
+ 	unsigned char *exthdr;
+ 	u32 offset, cmd = 0, tunnel = 0;
+ 	__be16 frag_off;
+ 	u8 l4_proto = 0;
+ 
+ 	if (skb->ip_summed != CHECKSUM_PARTIAL)
+ 		return 0;
+ 
+ 	ip.hdr = skb_network_header(skb);
+ 	l4.hdr = skb_transport_header(skb);
+ 
+ 	/* compute outer L2 header size */
+ 	offset = ((ip.hdr - skb->data) / 2) << I40E_TX_DESC_LENGTH_MACLEN_SHIFT;
++>>>>>>> 529f1f652e3c (i40e/i40evf: Add exception handling for Tx checksum)
  
  	if (skb->encapsulation) {
 -		/* define outer network header type */
 -		if (*tx_flags & I40E_TX_FLAGS_IPV4) {
 -			tunnel |= (*tx_flags & I40E_TX_FLAGS_TSO) ?
 -				  I40E_TX_CTX_EXT_IP_IPV4 :
 -				  I40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;
 -
 -			l4_proto = ip.v4->protocol;
 -		} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
 -			tunnel |= I40E_TX_CTX_EXT_IP_IPV6;
 -
 -			exthdr = ip.hdr + sizeof(*ip.v6);
 -			l4_proto = ip.v6->nexthdr;
 -			if (l4.hdr != exthdr)
 -				ipv6_skip_exthdr(skb, exthdr - skb->data,
 -						 &l4_proto, &frag_off);
 -		}
 -
 -		/* compute outer L3 header size */
 -		tunnel |= ((l4.hdr - ip.hdr) / 4) <<
 -			  I40E_TXD_CTX_QW0_EXT_IPLEN_SHIFT;
 -
 -		/* switch IP header pointer from outer to inner header */
 -		ip.hdr = skb_inner_network_header(skb);
 -
 -		/* define outer transport */
 -		switch (l4_proto) {
 +		switch (ip_hdr(skb)->protocol) {
  		case IPPROTO_UDP:
 -			tunnel |= I40E_TXD_CTX_UDP_TUNNELING;
 +			l4_tunnel = I40E_TXD_CTX_UDP_TUNNELING;
  			*tx_flags |= I40E_TX_FLAGS_UDP_TUNNEL;
  			break;
  		case IPPROTO_GRE:
 -			tunnel |= I40E_TXD_CTX_GRE_TUNNELING;
 -			*tx_flags |= I40E_TX_FLAGS_UDP_TUNNEL;
 +			l4_tunnel = I40E_TXD_CTX_GRE_TUNNELING;
  			break;
  		default:
- 			return;
+ 			if (*tx_flags & I40E_TX_FLAGS_TSO)
+ 				return -1;
+ 
+ 			skb_checksum_help(skb);
+ 			return 0;
  		}
 +		network_hdr_len = skb_inner_network_header_len(skb);
 +		this_ip_hdr = inner_ip_hdr(skb);
 +		this_ipv6_hdr = inner_ipv6_hdr(skb);
 +		this_tcp_hdrlen = inner_tcp_hdrlen(skb);
  
 -		/* compute tunnel header size */
 -		tunnel |= ((ip.hdr - l4.hdr) / 2) <<
 -			  I40E_TXD_CTX_QW0_NATLEN_SHIFT;
 -
 -		/* record tunnel offload values */
 -		*cd_tunneling |= tunnel;
 -
 -		/* switch L4 header pointer from outer to inner */
 -		l4.hdr = skb_inner_transport_header(skb);
 -		l4_proto = 0;
 +		if (*tx_flags & I40E_TX_FLAGS_IPV4) {
 +			if (*tx_flags & I40E_TX_FLAGS_TSO) {
 +				*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV4;
 +			} else {
 +				*cd_tunneling |=
 +					 I40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;
 +			}
 +		} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
 +			*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV6;
 +		}
  
 -		/* reset type as we transition from outer to inner headers */
 -		*tx_flags &= ~(I40E_TX_FLAGS_IPV4 | I40E_TX_FLAGS_IPV6);
 -		if (ip.v4->version == 4)
 -			*tx_flags |= I40E_TX_FLAGS_IPV4;
 -		if (ip.v6->version == 6)
 +		/* Now set the ctx descriptor fields */
 +		*cd_tunneling |= (skb_network_header_len(skb) >> 2) <<
 +				   I40E_TXD_CTX_QW0_EXT_IPLEN_SHIFT      |
 +				   l4_tunnel                             |
 +				   ((skb_inner_network_offset(skb) -
 +					skb_transport_offset(skb)) >> 1) <<
 +				   I40E_TXD_CTX_QW0_NATLEN_SHIFT;
 +		if (this_ip_hdr->version == 6) {
 +			*tx_flags &= ~I40E_TX_FLAGS_IPV4;
  			*tx_flags |= I40E_TX_FLAGS_IPV6;
 +		}
 +		if ((tx_ring->flags & I40E_TXR_FLAGS_OUTER_UDP_CSUM) &&
 +		    (l4_tunnel == I40E_TXD_CTX_UDP_TUNNELING)        &&
 +		    (*cd_tunneling & I40E_TXD_CTX_QW0_EXT_IP_MASK)) {
 +			oudph->check = ~csum_tcpudp_magic(oiph->saddr,
 +					oiph->daddr,
 +					(skb->len - skb_transport_offset(skb)),
 +					IPPROTO_UDP, 0);
 +			*cd_tunneling |= I40E_TXD_CTX_QW0_L4T_CS_MASK;
 +		}
 +	} else {
 +		network_hdr_len = skb_network_header_len(skb);
 +		this_ip_hdr = ip_hdr(skb);
 +		this_ipv6_hdr = ipv6_hdr(skb);
 +		this_tcp_hdrlen = tcp_hdrlen(skb);
  	}
  
  	/* Enable IP checksum offloads */
@@@ -2523,13 -2515,21 +2553,24 @@@
  		break;
  	case IPPROTO_UDP:
  		/* enable UDP checksum offload */
 -		cmd |= I40E_TX_DESC_CMD_L4T_EOFT_UDP;
 -		offset |= (sizeof(struct udphdr) >> 2) <<
 -			  I40E_TX_DESC_LENGTH_L4_FC_LEN_SHIFT;
 +		*td_cmd |= I40E_TX_DESC_CMD_L4T_EOFT_UDP;
 +		*td_offset |= (sizeof(struct udphdr) >> 2) <<
 +			       I40E_TX_DESC_LENGTH_L4_FC_LEN_SHIFT;
  		break;
  	default:
- 		break;
+ 		if (*tx_flags & I40E_TX_FLAGS_TSO)
+ 			return -1;
+ 		skb_checksum_help(skb);
+ 		return 0;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	*td_cmd |= cmd;
+ 	*td_offset |= offset;
+ 
+ 	return 1;
++>>>>>>> 529f1f652e3c (i40e/i40evf: Add exception handling for Tx checksum)
  }
  
  /**
diff --cc drivers/net/ethernet/intel/i40evf/i40e_txrx.c
index f6384b0c8220,143c5703f54e..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
@@@ -1621,72 -1602,98 +1621,103 @@@ static int i40e_tso(struct i40e_ring *t
   * @tx_flags: pointer to Tx flags currently set
   * @td_cmd: Tx descriptor command bits to set
   * @td_offset: Tx descriptor header offsets to set
+  * @tx_ring: Tx descriptor ring
   * @cd_tunneling: ptr to context desc bits
   **/
- static void i40e_tx_enable_csum(struct sk_buff *skb, u32 *tx_flags,
- 				u32 *td_cmd, u32 *td_offset,
- 				struct i40e_ring *tx_ring,
- 				u32 *cd_tunneling)
+ static int i40e_tx_enable_csum(struct sk_buff *skb, u32 *tx_flags,
+ 			       u32 *td_cmd, u32 *td_offset,
+ 			       struct i40e_ring *tx_ring,
+ 			       u32 *cd_tunneling)
  {
++<<<<<<< HEAD
 +	struct ipv6hdr *this_ipv6_hdr;
 +	unsigned int this_tcp_hdrlen;
 +	struct iphdr *this_ip_hdr;
 +	u32 network_hdr_len;
 +	u8 l4_hdr = 0;
 +	u32 l4_tunnel = 0;
++=======
+ 	union {
+ 		struct iphdr *v4;
+ 		struct ipv6hdr *v6;
+ 		unsigned char *hdr;
+ 	} ip;
+ 	union {
+ 		struct tcphdr *tcp;
+ 		struct udphdr *udp;
+ 		unsigned char *hdr;
+ 	} l4;
+ 	unsigned char *exthdr;
+ 	u32 offset, cmd = 0, tunnel = 0;
+ 	__be16 frag_off;
+ 	u8 l4_proto = 0;
+ 
+ 	if (skb->ip_summed != CHECKSUM_PARTIAL)
+ 		return 0;
+ 
+ 	ip.hdr = skb_network_header(skb);
+ 	l4.hdr = skb_transport_header(skb);
+ 
+ 	/* compute outer L2 header size */
+ 	offset = ((ip.hdr - skb->data) / 2) << I40E_TX_DESC_LENGTH_MACLEN_SHIFT;
++>>>>>>> 529f1f652e3c (i40e/i40evf: Add exception handling for Tx checksum)
  
  	if (skb->encapsulation) {
 -		/* define outer network header type */
 -		if (*tx_flags & I40E_TX_FLAGS_IPV4) {
 -			tunnel |= (*tx_flags & I40E_TX_FLAGS_TSO) ?
 -				  I40E_TX_CTX_EXT_IP_IPV4 :
 -				  I40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;
 -
 -			l4_proto = ip.v4->protocol;
 -		} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
 -			tunnel |= I40E_TX_CTX_EXT_IP_IPV6;
 -
 -			exthdr = ip.hdr + sizeof(*ip.v6);
 -			l4_proto = ip.v6->nexthdr;
 -			if (l4.hdr != exthdr)
 -				ipv6_skip_exthdr(skb, exthdr - skb->data,
 -						 &l4_proto, &frag_off);
 -		}
 -
 -		/* compute outer L3 header size */
 -		tunnel |= ((l4.hdr - ip.hdr) / 4) <<
 -			  I40E_TXD_CTX_QW0_EXT_IPLEN_SHIFT;
 -
 -		/* switch IP header pointer from outer to inner header */
 -		ip.hdr = skb_inner_network_header(skb);
 -
 -		/* define outer transport */
 -		switch (l4_proto) {
 +		switch (ip_hdr(skb)->protocol) {
  		case IPPROTO_UDP:
 -			tunnel |= I40E_TXD_CTX_UDP_TUNNELING;
 -			*tx_flags |= I40E_TX_FLAGS_VXLAN_TUNNEL;
 -			break;
 -		case IPPROTO_GRE:
 -			tunnel |= I40E_TXD_CTX_GRE_TUNNELING;
 +			l4_tunnel = I40E_TXD_CTX_UDP_TUNNELING;
  			*tx_flags |= I40E_TX_FLAGS_VXLAN_TUNNEL;
  			break;
  		default:
- 			return;
+ 			if (*tx_flags & I40E_TX_FLAGS_TSO)
+ 				return -1;
+ 
+ 			skb_checksum_help(skb);
+ 			return 0;
  		}
 +		network_hdr_len = skb_inner_network_header_len(skb);
 +		this_ip_hdr = inner_ip_hdr(skb);
 +		this_ipv6_hdr = inner_ipv6_hdr(skb);
 +		this_tcp_hdrlen = inner_tcp_hdrlen(skb);
  
 -		/* compute tunnel header size */
 -		tunnel |= ((ip.hdr - l4.hdr) / 2) <<
 -			  I40E_TXD_CTX_QW0_NATLEN_SHIFT;
 +		if (*tx_flags & I40E_TX_FLAGS_IPV4) {
 +			if (*tx_flags & I40E_TX_FLAGS_TSO) {
 +				*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV4;
 +			} else {
 +				*cd_tunneling |=
 +					 I40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;
 +			}
 +		} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
 +			*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV6;
 +		}
  
 -		/* record tunnel offload values */
 -		*cd_tunneling |= tunnel;
 +		/* Now set the ctx descriptor fields */
 +		*cd_tunneling |= (skb_network_header_len(skb) >> 2) <<
 +				   I40E_TXD_CTX_QW0_EXT_IPLEN_SHIFT      |
 +				   l4_tunnel                             |
 +				   ((skb_inner_network_offset(skb) -
 +					skb_transport_offset(skb)) >> 1) <<
 +				   I40E_TXD_CTX_QW0_NATLEN_SHIFT;
 +		if (this_ip_hdr->version == 6) {
 +			*tx_flags &= ~I40E_TX_FLAGS_IPV4;
 +			*tx_flags |= I40E_TX_FLAGS_IPV6;
 +		}
  
 -		/* switch L4 header pointer from outer to inner */
 -		l4.hdr = skb_inner_transport_header(skb);
 -		l4_proto = 0;
  
 -		/* reset type as we transition from outer to inner headers */
 -		*tx_flags &= ~(I40E_TX_FLAGS_IPV4 | I40E_TX_FLAGS_IPV6);
 -		if (ip.v4->version == 4)
 -			*tx_flags |= I40E_TX_FLAGS_IPV4;
 -		if (ip.v6->version == 6)
 -			*tx_flags |= I40E_TX_FLAGS_IPV6;
 +		if ((tx_ring->flags & I40E_TXR_FLAGS_OUTER_UDP_CSUM) &&
 +		    (l4_tunnel == I40E_TXD_CTX_UDP_TUNNELING)        &&
 +		    (*cd_tunneling & I40E_TXD_CTX_QW0_EXT_IP_MASK)) {
 +			oudph->check = ~csum_tcpudp_magic(oiph->saddr,
 +					oiph->daddr,
 +					(skb->len - skb_transport_offset(skb)),
 +					IPPROTO_UDP, 0);
 +			*cd_tunneling |= I40E_TXD_CTX_QW0_L4T_CS_MASK;
 +		}
 +	} else {
 +		network_hdr_len = skb_network_header_len(skb);
 +		this_ip_hdr = ip_hdr(skb);
 +		this_ipv6_hdr = ipv6_hdr(skb);
 +		this_tcp_hdrlen = tcp_hdrlen(skb);
  	}
  
  	/* Enable IP checksum offloads */
@@@ -1730,13 -1733,21 +1761,24 @@@
  		break;
  	case IPPROTO_UDP:
  		/* enable UDP checksum offload */
 -		cmd |= I40E_TX_DESC_CMD_L4T_EOFT_UDP;
 -		offset |= (sizeof(struct udphdr) >> 2) <<
 -			  I40E_TX_DESC_LENGTH_L4_FC_LEN_SHIFT;
 +		*td_cmd |= I40E_TX_DESC_CMD_L4T_EOFT_UDP;
 +		*td_offset |= (sizeof(struct udphdr) >> 2) <<
 +			       I40E_TX_DESC_LENGTH_L4_FC_LEN_SHIFT;
  		break;
  	default:
- 		break;
+ 		if (*tx_flags & I40E_TX_FLAGS_TSO)
+ 			return -1;
+ 		skb_checksum_help(skb);
+ 		return 0;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	*td_cmd |= cmd;
+ 	*td_offset |= offset;
+ 
+ 	return 1;
++>>>>>>> 529f1f652e3c (i40e/i40evf: Add exception handling for Tx checksum)
  }
  
  /**
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_txrx.h b/drivers/net/ethernet/intel/i40e/i40e_txrx.h
index ae22c4e9162f..849cd2a8aa45 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.h
@@ -153,7 +153,6 @@ enum i40e_dyn_idx_t {
 #define DESC_NEEDED (MAX_SKB_FRAGS + 4)
 #define I40E_MIN_DESC_PENDING	4
 
-#define I40E_TX_FLAGS_CSUM		BIT(0)
 #define I40E_TX_FLAGS_HW_VLAN		BIT(1)
 #define I40E_TX_FLAGS_SW_VLAN		BIT(2)
 #define I40E_TX_FLAGS_TSO		BIT(3)
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_txrx.c
diff --git a/drivers/net/ethernet/intel/i40evf/i40e_txrx.h b/drivers/net/ethernet/intel/i40evf/i40e_txrx.h
index 5467fcdf7670..2f49fec3cca7 100644
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.h
@@ -153,7 +153,6 @@ enum i40e_dyn_idx_t {
 #define DESC_NEEDED (MAX_SKB_FRAGS + 4)
 #define I40E_MIN_DESC_PENDING	4
 
-#define I40E_TX_FLAGS_CSUM		BIT(0)
 #define I40E_TX_FLAGS_HW_VLAN		BIT(1)
 #define I40E_TX_FLAGS_SW_VLAN		BIT(2)
 #define I40E_TX_FLAGS_TSO		BIT(3)
