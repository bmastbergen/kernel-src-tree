vfs: remove get_xip_mem

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matthew Wilcox <matthew.r.wilcox@intel.com>
commit e748dcd095ddee50e7a7deda2e26247715318a2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e748dcd0.failed

All callers of get_xip_mem() are now gone.  Remove checks for it,
initialisers of it, documentation of it and the only implementation of it.
 Also remove mm/filemap_xip.c as it is now empty.  Also remove
documentation of the long-gone get_xip_page().

	Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
	Cc: Andreas Dilger <andreas.dilger@intel.com>
	Cc: Boaz Harrosh <boaz@plexistor.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Dave Chinner <david@fromorbit.com>
	Cc: Jan Kara <jack@suse.cz>
	Cc: Jens Axboe <axboe@kernel.dk>
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: Theodore Ts'o <tytso@mit.edu>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e748dcd095ddee50e7a7deda2e26247715318a2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/filesystems/Locking
#	Documentation/filesystems/vfs.txt
#	fs/ext2/inode.c
#	fs/ext2/xip.c
#	fs/ext2/xip.h
#	include/linux/fs.h
#	mm/filemap_xip.c
diff --cc Documentation/filesystems/Locking
index af63b7f9e0d8,2ca3d17eee56..000000000000
--- a/Documentation/filesystems/Locking
+++ b/Documentation/filesystems/Locking
@@@ -193,16 -195,13 +193,20 @@@ prototypes
  				loff_t pos, unsigned len, unsigned copied,
  				struct page *page, void *fsdata);
  	sector_t (*bmap)(struct address_space *, sector_t);
 -	void (*invalidatepage) (struct page *, unsigned int, unsigned int);
 +	int (*invalidatepage) (struct page *, unsigned long);
  	int (*releasepage) (struct page *, int);
  	void (*freepage)(struct page *);
++<<<<<<< HEAD
 +	int (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
 +			loff_t offset, unsigned long nr_segs);
 +	int (*get_xip_mem)(struct address_space *, pgoff_t, int, void **,
 +				unsigned long *);
++=======
+ 	int (*direct_IO)(int, struct kiocb *, struct iov_iter *iter, loff_t offset);
++>>>>>>> e748dcd095dd (vfs: remove get_xip_mem)
  	int (*migratepage)(struct address_space *, struct page *, struct page *);
  	int (*launder_page)(struct page *);
 -	int (*is_partially_uptodate)(struct page *, unsigned long, unsigned long);
 +	int (*is_partially_uptodate)(struct page *, read_descriptor_t *, unsigned long);
  	int (*error_remove_page)(struct address_space *, struct page *);
  	int (*swap_activate)(struct file *);
  	int (*swap_deactivate)(struct file *);
diff --cc Documentation/filesystems/vfs.txt
index 49cef1203c04,966b22829f3b..000000000000
--- a/Documentation/filesystems/vfs.txt
+++ b/Documentation/filesystems/vfs.txt
@@@ -584,13 -587,10 +584,17 @@@ struct address_space_operations 
  				loff_t pos, unsigned len, unsigned copied,
  				struct page *page, void *fsdata);
  	sector_t (*bmap)(struct address_space *, sector_t);
 -	void (*invalidatepage) (struct page *, unsigned int, unsigned int);
 +	int (*invalidatepage) (struct page *, unsigned long);
  	int (*releasepage) (struct page *, int);
  	void (*freepage)(struct page *);
++<<<<<<< HEAD
 +	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
 +			loff_t offset, unsigned long nr_segs);
 +	struct page* (*get_xip_page)(struct address_space *, sector_t,
 +			int);
++=======
+ 	ssize_t (*direct_IO)(int, struct kiocb *, struct iov_iter *iter, loff_t offset);
++>>>>>>> e748dcd095dd (vfs: remove get_xip_mem)
  	/* migrate the contents of a page to the specified target */
  	int (*migratepage) (struct page *, struct page *);
  	int (*launder_page) (struct page *);
diff --cc fs/ext2/inode.c
index 115fa58bb9ae,59d6c7d43740..000000000000
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@@ -885,7 -894,7 +885,11 @@@ const struct address_space_operations e
  
  const struct address_space_operations ext2_aops_xip = {
  	.bmap			= ext2_bmap,
++<<<<<<< HEAD
 +	.get_xip_mem		= ext2_get_xip_mem,
++=======
+ 	.direct_IO		= ext2_direct_IO,
++>>>>>>> e748dcd095dd (vfs: remove get_xip_mem)
  };
  
  const struct address_space_operations ext2_nobh_aops = {
diff --cc fs/ext2/xip.c
index c79eaf871406,132d4daf98c4..000000000000
--- a/fs/ext2/xip.c
+++ b/fs/ext2/xip.c
@@@ -13,48 -13,6 +13,51 @@@
  #include "ext2.h"
  #include "xip.h"
  
++<<<<<<< HEAD
 +static inline long __inode_direct_access(struct inode *inode, sector_t block,
 +				void **kaddr, unsigned long *pfn, long size)
 +{
 +	struct block_device *bdev = inode->i_sb->s_bdev;
 +	sector_t sector = block * (PAGE_SIZE / 512);
 +	return bdev_direct_access(bdev, sector, kaddr, pfn, size);
 +}
 +
 +static inline int
 +__ext2_get_block(struct inode *inode, pgoff_t pgoff, int create,
 +		   sector_t *result)
 +{
 +	struct buffer_head tmp;
 +	int rc;
 +
 +	memset(&tmp, 0, sizeof(struct buffer_head));
 +	rc = ext2_get_block(inode, pgoff, &tmp, create);
 +	*result = tmp.b_blocknr;
 +
 +	/* did we get a sparse block (hole in the file)? */
 +	if (!tmp.b_blocknr && !rc) {
 +		BUG_ON(create);
 +		rc = -ENODATA;
 +	}
 +
 +	return rc;
 +}
 +
 +int
 +ext2_clear_xip_target(struct inode *inode, sector_t block)
 +{
 +	void *kaddr;
 +	unsigned long pfn;
 +	long size;
 +
 +	size = __inode_direct_access(inode, block, &kaddr, &pfn, PAGE_SIZE);
 +	if (size < 0)
 +		return size;
 +	clear_page(kaddr);
 +	return 0;
 +}
 +
++=======
++>>>>>>> e748dcd095dd (vfs: remove get_xip_mem)
  void ext2_xip_verify_sb(struct super_block *sb)
  {
  	struct ext2_sb_info *sbi = EXT2_SB(sb);
diff --cc fs/ext2/xip.h
index 18b34d2f31b3,e7b9f0a2cc54..000000000000
--- a/fs/ext2/xip.h
+++ b/fs/ext2/xip.h
@@@ -14,13 -12,7 +14,19 @@@ static inline int ext2_use_xip (struct 
  	struct ext2_sb_info *sbi = EXT2_SB(sb);
  	return (sbi->s_mount_opt & EXT2_MOUNT_XIP);
  }
++<<<<<<< HEAD
 +int ext2_get_xip_mem(struct address_space *, pgoff_t, int,
 +				void **, unsigned long *);
 +#define mapping_is_xip(map) unlikely(map->a_ops->get_xip_mem)
++=======
++>>>>>>> e748dcd095dd (vfs: remove get_xip_mem)
  #else
 +#define mapping_is_xip(map)			0
  #define ext2_xip_verify_sb(sb)			do { } while (0)
  #define ext2_use_xip(sb)			0
++<<<<<<< HEAD
 +#define ext2_clear_xip_target(inode, chain)	0
 +#define ext2_get_xip_mem			NULL
++=======
++>>>>>>> e748dcd095dd (vfs: remove get_xip_mem)
  #endif
diff --cc include/linux/fs.h
index 37d4ac39152e,9772d655f444..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -391,16 -358,13 +391,20 @@@ struct address_space_operations 
  
  	/* Unfortunately this kludge is needed for FIBMAP. Don't use it */
  	sector_t (*bmap)(struct address_space *, sector_t);
 -	void (*invalidatepage) (struct page *, unsigned int, unsigned int);
 +	void (*invalidatepage) (struct page *, unsigned long);
  	int (*releasepage) (struct page *, gfp_t);
  	void (*freepage)(struct page *);
++<<<<<<< HEAD
 +	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
 +			loff_t offset, unsigned long nr_segs);
 +	int (*get_xip_mem)(struct address_space *, pgoff_t, int,
 +						void **, unsigned long *);
++=======
+ 	ssize_t (*direct_IO)(int, struct kiocb *, struct iov_iter *iter, loff_t offset);
++>>>>>>> e748dcd095dd (vfs: remove get_xip_mem)
  	/*
 -	 * migrate the contents of a page to the specified target. If
 -	 * migrate_mode is MIGRATE_ASYNC, it must not block.
 +	 * migrate the contents of a page to the specified target. If sync
 +	 * is false, it must not block.
  	 */
  	int (*migratepage) (struct address_space *,
  			struct page *, struct page *, enum migrate_mode);
* Unmerged path mm/filemap_xip.c
* Unmerged path Documentation/filesystems/Locking
* Unmerged path Documentation/filesystems/vfs.txt
diff --git a/fs/exofs/inode.c b/fs/exofs/inode.c
index 3bc143b92bc8..134de36697d1 100644
--- a/fs/exofs/inode.c
+++ b/fs/exofs/inode.c
@@ -975,7 +975,6 @@ const struct address_space_operations exofs_aops = {
 	.direct_IO	= NULL, /* TODO: Should be trivial to do */
 
 	/* With these NULL has special meaning or default is not exported */
-	.get_xip_mem	= NULL,
 	.migratepage	= NULL,
 	.launder_page	= NULL,
 	.is_partially_uptodate = NULL,
* Unmerged path fs/ext2/inode.c
* Unmerged path fs/ext2/xip.c
* Unmerged path fs/ext2/xip.h
diff --git a/fs/open.c b/fs/open.c
index eeadbd924dc1..6de34a9c5a2e 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -689,11 +689,8 @@ int open_check_o_direct(struct file *f)
 {
 	/* NB: we're sure to have correct a_ops only after f_op->open */
 	if (f->f_flags & O_DIRECT) {
-		if (!f->f_mapping->a_ops ||
-		    ((!f->f_mapping->a_ops->direct_IO) &&
-		    (!f->f_mapping->a_ops->get_xip_mem))) {
+		if (!f->f_mapping->a_ops || !f->f_mapping->a_ops->direct_IO)
 			return -EINVAL;
-		}
 	}
 	return 0;
 }
* Unmerged path include/linux/fs.h
diff --git a/include/linux/rmap.h b/include/linux/rmap.h
index 6dacb93a6d94..b8f824d6ffec 100644
--- a/include/linux/rmap.h
+++ b/include/linux/rmap.h
@@ -193,7 +193,7 @@ int try_to_unmap_one(struct page *, struct vm_area_struct *,
 			unsigned long address, enum ttu_flags flags);
 
 /*
- * Called from mm/filemap_xip.c to unmap empty zero page
+ * Used by uprobes to replace a userspace page safely
  */
 pte_t *__page_check_address(struct page *, struct mm_struct *,
 				unsigned long, spinlock_t **, int);
diff --git a/mm/Makefile b/mm/Makefile
index 19d2b6ae108d..aa6c6d359119 100644
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -47,7 +47,6 @@ obj-$(CONFIG_SLUB) += slub.o
 obj-$(CONFIG_KMEMCHECK) += kmemcheck.o
 obj-$(CONFIG_FAILSLAB) += failslab.o
 obj-$(CONFIG_MEMORY_HOTPLUG) += memory_hotplug.o
-obj-$(CONFIG_FS_XIP) += filemap_xip.o
 obj-$(CONFIG_MIGRATION) += migrate.o
 obj-$(CONFIG_QUICKLIST) += quicklist.o
 obj-$(CONFIG_TRANSPARENT_HUGEPAGE) += huge_memory.o
diff --git a/mm/fadvise.c b/mm/fadvise.c
index 3bcfd81db45e..1f1925fcb9ab 100644
--- a/mm/fadvise.c
+++ b/mm/fadvise.c
@@ -28,6 +28,7 @@
 SYSCALL_DEFINE4(fadvise64_64, int, fd, loff_t, offset, loff_t, len, int, advice)
 {
 	struct fd f = fdget(fd);
+	struct inode *inode;
 	struct address_space *mapping;
 	struct backing_dev_info *bdi;
 	loff_t endbyte;			/* inclusive */
@@ -39,7 +40,8 @@ SYSCALL_DEFINE4(fadvise64_64, int, fd, loff_t, offset, loff_t, len, int, advice)
 	if (!f.file)
 		return -EBADF;
 
-	if (S_ISFIFO(file_inode(f.file)->i_mode)) {
+	inode = file_inode(f.file);
+	if (S_ISFIFO(inode->i_mode)) {
 		ret = -ESPIPE;
 		goto out;
 	}
@@ -50,7 +52,7 @@ SYSCALL_DEFINE4(fadvise64_64, int, fd, loff_t, offset, loff_t, len, int, advice)
 		goto out;
 	}
 
-	if (mapping->a_ops->get_xip_mem) {
+	if (IS_DAX(inode)) {
 		switch (advice) {
 		case POSIX_FADV_NORMAL:
 		case POSIX_FADV_RANDOM:
* Unmerged path mm/filemap_xip.c
diff --git a/mm/madvise.c b/mm/madvise.c
index 0014522e78de..2eb3d5f499c1 100644
--- a/mm/madvise.c
+++ b/mm/madvise.c
@@ -237,7 +237,7 @@ static long madvise_willneed(struct vm_area_struct * vma,
 	if (!file)
 		return -EBADF;
 
-	if (file->f_mapping->a_ops->get_xip_mem) {
+	if (IS_DAX(file_inode(file))) {
 		/* no bad return value, but ignore advice */
 		return 0;
 	}
