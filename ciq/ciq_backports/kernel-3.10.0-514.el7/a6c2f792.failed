sctp: implement prsctp TTL policy

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit a6c2f792873aff332a4689717c3cd6104f46684c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a6c2f792.failed

prsctp TTL policy is a policy to abandon chunks when they expire
at the specific time in local stack. It's similar with expires_at
in struct sctp_datamsg.

This patch uses sinfo->sinfo_timetolive to set the specific time for
TTL policy. sinfo->sinfo_timetolive is also used for msg->expires_at.
So if prsctp_enable or TTL policy is not enabled, msg->expires_at
still works as before.

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a6c2f792873aff332a4689717c3cd6104f46684c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/socket.c
diff --cc net/sctp/socket.c
index 34a2b15b5d0d,08614296628a..000000000000
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@@ -6545,20 -7092,41 +6545,50 @@@ SCTP_STATIC int sctp_msghdr_parse(cons
  			 * ------------  ------------   ----------------------
  			 * IPPROTO_SCTP  SCTP_SNDRCV    struct sctp_sndrcvinfo
  			 */
 -			if (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_sndrcvinfo)))
 +			if (cmsg->cmsg_len !=
 +			    CMSG_LEN(sizeof(struct sctp_sndrcvinfo)))
  				return -EINVAL;
  
 -			cmsgs->srinfo = CMSG_DATA(cmsg);
 +			cmsgs->info =
 +				(struct sctp_sndrcvinfo *)CMSG_DATA(cmsg);
  
 -			if (cmsgs->srinfo->sinfo_flags &
 +			/* Minimally, validate the sinfo_flags. */
 +			if (cmsgs->info->sinfo_flags &
  			    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |
++<<<<<<< HEAD
++=======
+ 			      SCTP_SACK_IMMEDIATELY | SCTP_PR_SCTP_MASK |
++>>>>>>> a6c2f792873a (sctp: implement prsctp TTL policy)
  			      SCTP_ABORT | SCTP_EOF))
  				return -EINVAL;
  			break;
  
++<<<<<<< HEAD
++=======
+ 		case SCTP_SNDINFO:
+ 			/* SCTP Socket API Extension
+ 			 * 5.3.4 SCTP Send Information Structure (SCTP_SNDINFO)
+ 			 *
+ 			 * This cmsghdr structure specifies SCTP options for
+ 			 * sendmsg(). This structure and SCTP_RCVINFO replaces
+ 			 * SCTP_SNDRCV which has been deprecated.
+ 			 *
+ 			 * cmsg_level    cmsg_type      cmsg_data[]
+ 			 * ------------  ------------   ---------------------
+ 			 * IPPROTO_SCTP  SCTP_SNDINFO    struct sctp_sndinfo
+ 			 */
+ 			if (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_sndinfo)))
+ 				return -EINVAL;
+ 
+ 			cmsgs->sinfo = CMSG_DATA(cmsg);
+ 
+ 			if (cmsgs->sinfo->snd_flags &
+ 			    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |
+ 			      SCTP_SACK_IMMEDIATELY | SCTP_PR_SCTP_MASK |
+ 			      SCTP_ABORT | SCTP_EOF))
+ 				return -EINVAL;
+ 			break;
++>>>>>>> a6c2f792873a (sctp: implement prsctp TTL policy)
  		default:
  			return -EINVAL;
  		}
diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7fbce55da678..932468e8a3db 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -608,6 +608,16 @@ struct sctp_chunk {
 	/* This needs to be recoverable for SCTP_SEND_FAILED events. */
 	struct sctp_sndrcvinfo sinfo;
 
+	/* We use this field to record param for prsctp policies,
+	 * for TTL policy, it is the time_to_drop of this chunk,
+	 * for RTX policy, it is the max_sent_count of this chunk,
+	 * for PRIO policy, it is the priority of this chunk.
+	 */
+	unsigned long prsctp_param;
+
+	/* How many times this chunk have been sent, for prsctp RTX policy */
+	int sent_count;
+
 	/* Which association does this belong to?  */
 	struct sctp_association *asoc;
 
diff --git a/net/sctp/chunk.c b/net/sctp/chunk.c
index 9c5bf4f38327..e36179e340ba 100644
--- a/net/sctp/chunk.c
+++ b/net/sctp/chunk.c
@@ -353,13 +353,27 @@ errout:
 /* Check whether this message has expired. */
 int sctp_chunk_abandoned(struct sctp_chunk *chunk)
 {
-	struct sctp_datamsg *msg = chunk->msg;
+	if (!chunk->asoc->prsctp_enable ||
+	    !SCTP_PR_POLICY(chunk->sinfo.sinfo_flags)) {
+		struct sctp_datamsg *msg = chunk->msg;
+
+		if (!msg->can_abandon)
+			return 0;
+
+		if (time_after(jiffies, msg->expires_at))
+			return 1;
 
-	if (!msg->can_abandon)
 		return 0;
+	}
 
-	if (time_after(jiffies, msg->expires_at))
+	if (SCTP_PR_TTL_ENABLED(chunk->sinfo.sinfo_flags) &&
+	    time_after(jiffies, chunk->prsctp_param)) {
+		if (chunk->sent_count)
+			chunk->asoc->abandoned_sent[SCTP_PR_INDEX(TTL)]++;
+		else
+			chunk->asoc->abandoned_unsent[SCTP_PR_INDEX(TTL)]++;
 		return 1;
+	}
 
 	return 0;
 }
diff --git a/net/sctp/output.c b/net/sctp/output.c
index b1ac80d971ea..3201a30755d0 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -301,6 +301,8 @@ static sctp_xmit_t __sctp_packet_append_chunk(struct sctp_packet *packet,
 		packet->has_data = 1;
 		/* timestamp the chunk for rtx purposes */
 		chunk->sent_at = jiffies;
+		/* Mainly used for prsctp RTX policy */
+		chunk->sent_count++;
 		break;
 	    case SCTP_CID_COOKIE_ECHO:
 		packet->has_cookie_echo = 1;
diff --git a/net/sctp/sm_make_chunk.c b/net/sctp/sm_make_chunk.c
index 580d58afabf7..653dd5299375 100644
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@ -688,6 +688,17 @@ nodata:
 	return retval;
 }
 
+static void sctp_set_prsctp_policy(struct sctp_chunk *chunk,
+				   const struct sctp_sndrcvinfo *sinfo)
+{
+	if (!chunk->asoc->prsctp_enable)
+		return;
+
+	if (SCTP_PR_TTL_ENABLED(sinfo->sinfo_flags))
+		chunk->prsctp_param =
+			jiffies + msecs_to_jiffies(sinfo->sinfo_timetolive);
+}
+
 /* Make a DATA chunk for the given association from the provided
  * parameters.  However, do not populate the data payload.
  */
@@ -720,6 +731,7 @@ struct sctp_chunk *sctp_make_datafrag_empty(struct sctp_association *asoc,
 
 	retval->subh.data_hdr = sctp_addto_chunk(retval, sizeof(dp), &dp);
 	memcpy(&retval->sinfo, sinfo, sizeof(struct sctp_sndrcvinfo));
+	sctp_set_prsctp_policy(retval, sinfo);
 
 nodata:
 	return retval;
* Unmerged path net/sctp/socket.c
