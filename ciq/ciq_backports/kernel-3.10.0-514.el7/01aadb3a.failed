sctp: implement prsctp RTX policy

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit 01aadb3af6e1b10970c1f7e510b5097c8f725d64
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/01aadb3a.failed

prsctp RTX policy is a policy to abandon chunks when they are
retransmitted beyond the max count.

This patch uses sent_count to count how many times one chunk has
been sent, and prsctp_param is the max rtx count, which is from
sinfo->sinfo_timetolive in sctp_set_prsctp_policy(). So similar
to TTL policy, if RTX policy is enabled, msg->expire_at won't
work.

Then in sctp_chunk_abandoned, this patch checks if chunk->sent_count
is bigger than chunk->prsctp_param to abandon this chunk.

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 01aadb3af6e1b10970c1f7e510b5097c8f725d64)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/chunk.c
#	net/sctp/sm_make_chunk.c
diff --cc net/sctp/chunk.c
index 9c5bf4f38327,b3692b55a8d2..000000000000
--- a/net/sctp/chunk.c
+++ b/net/sctp/chunk.c
@@@ -353,13 -335,31 +353,21 @@@ errout
  /* Check whether this message has expired. */
  int sctp_chunk_abandoned(struct sctp_chunk *chunk)
  {
 -	if (!chunk->asoc->prsctp_enable ||
 -	    !SCTP_PR_POLICY(chunk->sinfo.sinfo_flags)) {
 -		struct sctp_datamsg *msg = chunk->msg;
 -
 -		if (!msg->can_abandon)
 -			return 0;
 -
 -		if (time_after(jiffies, msg->expires_at))
 -			return 1;
 +	struct sctp_datamsg *msg = chunk->msg;
  
 +	if (!msg->can_abandon)
  		return 0;
 -	}
  
 -	if (SCTP_PR_TTL_ENABLED(chunk->sinfo.sinfo_flags) &&
 -	    time_after(jiffies, chunk->prsctp_param)) {
 -		if (chunk->sent_count)
 -			chunk->asoc->abandoned_sent[SCTP_PR_INDEX(TTL)]++;
 -		else
 -			chunk->asoc->abandoned_unsent[SCTP_PR_INDEX(TTL)]++;
 +	if (time_after(jiffies, msg->expires_at))
  		return 1;
++<<<<<<< HEAD
++=======
+ 	} else if (SCTP_PR_RTX_ENABLED(chunk->sinfo.sinfo_flags) &&
+ 		   chunk->sent_count > chunk->prsctp_param) {
+ 		chunk->asoc->abandoned_sent[SCTP_PR_INDEX(RTX)]++;
+ 		return 1;
+ 	}
++>>>>>>> 01aadb3af6e1 (sctp: implement prsctp RTX policy)
  
  	return 0;
  }
diff --cc net/sctp/sm_make_chunk.c
index 580d58afabf7,cfde934af5c5..000000000000
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@@ -688,6 -711,19 +688,22 @@@ nodata
  	return retval;
  }
  
++<<<<<<< HEAD
++=======
+ static void sctp_set_prsctp_policy(struct sctp_chunk *chunk,
+ 				   const struct sctp_sndrcvinfo *sinfo)
+ {
+ 	if (!chunk->asoc->prsctp_enable)
+ 		return;
+ 
+ 	if (SCTP_PR_TTL_ENABLED(sinfo->sinfo_flags))
+ 		chunk->prsctp_param =
+ 			jiffies + msecs_to_jiffies(sinfo->sinfo_timetolive);
+ 	else if (SCTP_PR_RTX_ENABLED(sinfo->sinfo_flags))
+ 		chunk->prsctp_param = sinfo->sinfo_timetolive;
+ }
+ 
++>>>>>>> 01aadb3af6e1 (sctp: implement prsctp RTX policy)
  /* Make a DATA chunk for the given association from the provided
   * parameters.  However, do not populate the data payload.
   */
* Unmerged path net/sctp/chunk.c
* Unmerged path net/sctp/sm_make_chunk.c
