pinctrl: baytrail: Serialize all register access

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [pinctrl] baytrail: Serialize all register access (Prarit Bhargava) [1339663]
Rebuild_FUZZ: 89.66%
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 39ce8150a079e3ae6ed9abf26d7918a558ef7c19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/39ce8150.failed

There is a hardware issue in Intel Baytrail where concurrent GPIO register
access might result reads of 0xffffffff and writes might get dropped
completely.

Prevent this from happening by taking the serializing lock in all places
where it is possible that more than one thread might be accessing the
hardware concurrently.

	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 39ce8150a079e3ae6ed9abf26d7918a558ef7c19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pinctrl/pinctrl-baytrail.c
diff --cc drivers/pinctrl/pinctrl-baytrail.c
index ad68bcc7f9f9,016b4019d2a5..000000000000
--- a/drivers/pinctrl/pinctrl-baytrail.c
+++ b/drivers/pinctrl/pinctrl-baytrail.c
@@@ -469,32 -447,60 +478,48 @@@ static void byt_gpio_irq_handler(unsign
  	chip->irq_eoi(data);
  }
  
++<<<<<<< HEAD:drivers/pinctrl/pinctrl-baytrail.c
++=======
+ static void byt_irq_ack(struct irq_data *d)
+ {
+ 	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+ 	struct byt_gpio *vg = to_byt_gpio(gc);
+ 	unsigned offset = irqd_to_hwirq(d);
+ 	void __iomem *reg;
+ 
+ 	spin_lock(&vg->lock);
+ 	reg = byt_gpio_reg(&vg->chip, offset, BYT_INT_STAT_REG);
+ 	writel(BIT(offset % 32), reg);
+ 	spin_unlock(&vg->lock);
+ }
+ 
++>>>>>>> 39ce8150a079 (pinctrl: baytrail: Serialize all register access):drivers/pinctrl/intel/pinctrl-baytrail.c
  static void byt_irq_unmask(struct irq_data *d)
  {
 -	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
 -	struct byt_gpio *vg = to_byt_gpio(gc);
 -	unsigned offset = irqd_to_hwirq(d);
 -	unsigned long flags;
 -	void __iomem *reg;
 -	u32 value;
 -
 -	spin_lock_irqsave(&vg->lock, flags);
 -
 -	reg = byt_gpio_reg(&vg->chip, offset, BYT_CONF0_REG);
 -	value = readl(reg);
 +}
  
 -	switch (irqd_get_trigger_type(d)) {
 -	case IRQ_TYPE_LEVEL_HIGH:
 -		value |= BYT_TRIG_LVL;
 -	case IRQ_TYPE_EDGE_RISING:
 -		value |= BYT_TRIG_POS;
 -		break;
 -	case IRQ_TYPE_LEVEL_LOW:
 -		value |= BYT_TRIG_LVL;
 -	case IRQ_TYPE_EDGE_FALLING:
 -		value |= BYT_TRIG_NEG;
 -		break;
 -	case IRQ_TYPE_EDGE_BOTH:
 -		value |= (BYT_TRIG_NEG | BYT_TRIG_POS);
 -		break;
 -	}
 +static void byt_irq_mask(struct irq_data *d)
 +{
 +}
  
 -	writel(value, reg);
 +static unsigned int byt_irq_startup(struct irq_data *d)
 +{
 +	struct byt_gpio *vg = irq_data_get_irq_chip_data(d);
  
 -	spin_unlock_irqrestore(&vg->lock, flags);
 +	if (gpio_lock_as_irq(&vg->chip, irqd_to_hwirq(d)))
 +		dev_err(vg->chip.dev,
 +			"unable to lock HW IRQ %lu for IRQ\n",
 +			irqd_to_hwirq(d));
 +	byt_irq_unmask(d);
 +	return 0;
  }
  
 -static void byt_irq_mask(struct irq_data *d)
 +static void byt_irq_shutdown(struct irq_data *d)
  {
 -	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
 -	struct byt_gpio *vg = to_byt_gpio(gc);
 +	struct byt_gpio *vg = irq_data_get_irq_chip_data(d);
  
 -	byt_gpio_clear_triggering(vg, irqd_to_hwirq(d));
 +	byt_irq_mask(d);
 +	gpio_unlock_as_irq(&vg->chip, irqd_to_hwirq(d));
  }
  
  static struct irq_chip byt_irqchip = {
* Unmerged path drivers/pinctrl/pinctrl-baytrail.c
