gso: Remove arbitrary checks for unsupported GSO

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tom Herbert <tom@herbertland.com>
commit 5c7cdf339af560f980b12eb6b0b5aa5f68ac6658
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5c7cdf33.failed

In several gso_segment functions there are checks of gso_type against
a seemingly arbitrary list of SKB_GSO_* flags. This seems like an
attempt to identify unsupported GSO types, but since the stack is
the one that set these GSO types in the first place this seems
unnecessary to do. If a combination isn't valid in the first
place that stack should not allow setting it.

This is a code simplication especially for add new GSO types.

	Signed-off-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5c7cdf339af560f980b12eb6b0b5aa5f68ac6658)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/af_inet.c
#	net/ipv4/gre_offload.c
#	net/ipv4/tcp_offload.c
#	net/ipv4/udp_offload.c
#	net/ipv6/ip6_offload.c
#	net/ipv6/udp_offload.c
#	net/mpls/mpls_gso.c
diff --cc net/ipv4/af_inet.c
index 96cfb62894e8,7f08d4525981..000000000000
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@@ -1216,23 -1205,6 +1216,26 @@@ static struct sk_buff *inet_gso_segment
  	int ihl;
  	int id;
  
++<<<<<<< HEAD
 +	if (unlikely(skb_shinfo(skb)->gso_type &
 +		     ~(SKB_GSO_TCPV4 |
 +		       SKB_GSO_UDP |
 +		       SKB_GSO_DODGY |
 +		       SKB_GSO_TCP_ECN |
 +		       SKB_GSO_GRE |
 +		       SKB_GSO_GRE_CSUM |
 +		       SKB_GSO_IPIP |
 +		       SKB_GSO_SIT |
 +		       SKB_GSO_TCPV6 |
 +		       SKB_GSO_UDP_TUNNEL |
 +		       SKB_GSO_UDP_TUNNEL_CSUM |
 +		       SKB_GSO_TUNNEL_REMCSUM |
 +		       SKB_GSO_MPLS |
 +		       0)))
 +		goto out;
 +
++=======
++>>>>>>> 5c7cdf339af5 (gso: Remove arbitrary checks for unsupported GSO)
  	skb_reset_network_header(skb);
  	nhoff = skb_network_header(skb) - skb_mac_header(skb);
  	if (unlikely(!pskb_may_pull(skb, sizeof(*iph))))
diff --cc net/ipv4/gre_offload.c
index bb5947b0ce2d,ecd1e09dbbf1..000000000000
--- a/net/ipv4/gre_offload.c
+++ b/net/ipv4/gre_offload.c
@@@ -18,27 -18,14 +18,30 @@@
  static struct sk_buff *gre_gso_segment(struct sk_buff *skb,
  				       netdev_features_t features)
  {
 -	int tnl_hlen = skb_inner_mac_header(skb) - skb_transport_header(skb);
  	struct sk_buff *segs = ERR_PTR(-EINVAL);
 +	netdev_features_t enc_features;
 +	int ghl;
 +	struct gre_base_hdr *greh;
  	u16 mac_offset = skb->mac_header;
 +	int mac_len = skb->mac_len;
  	__be16 protocol = skb->protocol;
 -	u16 mac_len = skb->mac_len;
 -	int gre_offset, outer_hlen;
 -	bool need_csum, ufo;
 +	int tnl_hlen;
 +	bool csum;
 +
++<<<<<<< HEAD
 +	if (unlikely(skb_shinfo(skb)->gso_type &
 +				~(SKB_GSO_TCPV4 |
 +				  SKB_GSO_TCPV6 |
 +				  SKB_GSO_UDP |
 +				  SKB_GSO_DODGY |
 +				  SKB_GSO_TCP_ECN |
 +				  SKB_GSO_GRE |
 +				  SKB_GSO_GRE_CSUM |
 +				  SKB_GSO_IPIP)))
 +		goto out;
  
++=======
++>>>>>>> 5c7cdf339af5 (gso: Remove arbitrary checks for unsupported GSO)
  	if (!skb->encapsulation)
  		goto out;
  
diff --cc net/ipv4/tcp_offload.c
index 9c42f97c3178,5c5964962d0c..000000000000
--- a/net/ipv4/tcp_offload.c
+++ b/net/ipv4/tcp_offload.c
@@@ -68,24 -83,6 +68,27 @@@ struct sk_buff *tcp_gso_segment(struct 
  
  	if (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {
  		/* Packet is from an untrusted source, reset gso_segs. */
++<<<<<<< HEAD
 +		int type = skb_shinfo(skb)->gso_type;
 +
 +		if (unlikely(type &
 +			     ~(SKB_GSO_TCPV4 |
 +			       SKB_GSO_DODGY |
 +			       SKB_GSO_TCP_ECN |
 +			       SKB_GSO_TCPV6 |
 +			       SKB_GSO_GRE |
 +			       SKB_GSO_GRE_CSUM |
 +			       SKB_GSO_IPIP |
 +			       SKB_GSO_SIT |
 +			       SKB_GSO_MPLS |
 +			       SKB_GSO_UDP_TUNNEL |
 +			       SKB_GSO_UDP_TUNNEL_CSUM |
 +			       SKB_GSO_TUNNEL_REMCSUM |
 +			       0) ||
 +			     !(type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))))
 +			goto out;
++=======
++>>>>>>> 5c7cdf339af5 (gso: Remove arbitrary checks for unsupported GSO)
  
  		skb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);
  
diff --cc net/ipv4/udp_offload.c
index 2c896776f9f5,81f253b6ff36..000000000000
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@@ -201,17 -209,6 +201,20 @@@ static struct sk_buff *udp4_ufo_fragmen
  
  	if (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {
  		/* Packet is from an untrusted source, reset gso_segs. */
++<<<<<<< HEAD
 +		int type = skb_shinfo(skb)->gso_type;
 +
 +		if (unlikely(type & ~(SKB_GSO_UDP | SKB_GSO_DODGY |
 +				      SKB_GSO_UDP_TUNNEL |
 +				      SKB_GSO_UDP_TUNNEL_CSUM |
 +				      SKB_GSO_TUNNEL_REMCSUM |
 +				      SKB_GSO_IPIP |
 +				      SKB_GSO_GRE | SKB_GSO_GRE_CSUM |
 +				      SKB_GSO_MPLS) ||
 +			     !(type & (SKB_GSO_UDP))))
 +			goto out;
++=======
++>>>>>>> 5c7cdf339af5 (gso: Remove arbitrary checks for unsupported GSO)
  
  		skb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);
  
diff --cc net/ipv6/ip6_offload.c
index b2a15198951d,9ad743b2c624..000000000000
--- a/net/ipv6/ip6_offload.c
+++ b/net/ipv6/ip6_offload.c
@@@ -67,23 -69,6 +67,26 @@@ static struct sk_buff *ipv6_gso_segment
  	bool encap, udpfrag;
  	int nhoff;
  
++<<<<<<< HEAD
 +	if (unlikely(skb_shinfo(skb)->gso_type &
 +		     ~(SKB_GSO_TCPV4 |
 +		       SKB_GSO_UDP |
 +		       SKB_GSO_DODGY |
 +		       SKB_GSO_TCP_ECN |
 +		       SKB_GSO_GRE |
 +		       SKB_GSO_GRE_CSUM |
 +		       SKB_GSO_IPIP |
 +		       SKB_GSO_SIT |
 +		       SKB_GSO_UDP_TUNNEL |
 +		       SKB_GSO_UDP_TUNNEL_CSUM |
 +		       SKB_GSO_TUNNEL_REMCSUM |
 +		       SKB_GSO_MPLS |
 +		       SKB_GSO_TCPV6 |
 +		       0)))
 +		goto out;
 +
++=======
++>>>>>>> 5c7cdf339af5 (gso: Remove arbitrary checks for unsupported GSO)
  	skb_reset_network_header(skb);
  	nhoff = skb_network_header(skb) - skb_mac_header(skb);
  	if (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))
diff --cc net/ipv6/udp_offload.c
index f705fbdc6ee7,ac858c480f2f..000000000000
--- a/net/ipv6/udp_offload.c
+++ b/net/ipv6/udp_offload.c
@@@ -36,20 -36,6 +36,23 @@@ static struct sk_buff *udp6_ufo_fragmen
  
  	if (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {
  		/* Packet is from an untrusted source, reset gso_segs. */
++<<<<<<< HEAD
 +		int type = skb_shinfo(skb)->gso_type;
 +
 +		if (unlikely(type & ~(SKB_GSO_UDP |
 +				      SKB_GSO_DODGY |
 +				      SKB_GSO_UDP_TUNNEL |
 +				      SKB_GSO_UDP_TUNNEL_CSUM |
 +				      SKB_GSO_TUNNEL_REMCSUM |
 +				      SKB_GSO_GRE |
 +				      SKB_GSO_GRE_CSUM |
 +				      SKB_GSO_IPIP |
 +				      SKB_GSO_SIT |
 +				      SKB_GSO_MPLS) ||
 +			     !(type & (SKB_GSO_UDP))))
 +			goto out;
++=======
++>>>>>>> 5c7cdf339af5 (gso: Remove arbitrary checks for unsupported GSO)
  
  		skb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);
  
diff --cc net/mpls/mpls_gso.c
index 7699d3f41c04,2055e57ed1c3..000000000000
--- a/net/mpls/mpls_gso.c
+++ b/net/mpls/mpls_gso.c
@@@ -26,18 -26,6 +26,21 @@@ static struct sk_buff *mpls_gso_segment
  	netdev_features_t mpls_features;
  	__be16 mpls_protocol;
  
++<<<<<<< HEAD
 +	if (unlikely(skb_shinfo(skb)->gso_type &
 +				~(SKB_GSO_TCPV4 |
 +				  SKB_GSO_TCPV6 |
 +				  SKB_GSO_UDP |
 +				  SKB_GSO_DODGY |
 +				  SKB_GSO_TCP_ECN |
 +				  SKB_GSO_GRE |
 +				  SKB_GSO_GRE_CSUM |
 +				  SKB_GSO_IPIP |
 +				  SKB_GSO_MPLS)))
 +		goto out;
 +
++=======
++>>>>>>> 5c7cdf339af5 (gso: Remove arbitrary checks for unsupported GSO)
  	/* Setup inner SKB. */
  	mpls_protocol = skb->protocol;
  	skb->protocol = skb->inner_protocol;
@@@ -59,9 -47,8 +62,14 @@@
  	 * above pulled.  It will be re-pushed after returning
  	 * skb_mac_gso_segment(), an indirect caller of this function.
  	 */
++<<<<<<< HEAD
 +	__skb_push(skb, skb->data - skb_mac_header(skb));
 +
 +out:
++=======
+ 	__skb_pull(skb, skb->data - skb_mac_header(skb));
+ 
++>>>>>>> 5c7cdf339af5 (gso: Remove arbitrary checks for unsupported GSO)
  	return segs;
  }
  
* Unmerged path net/ipv4/af_inet.c
* Unmerged path net/ipv4/gre_offload.c
* Unmerged path net/ipv4/tcp_offload.c
* Unmerged path net/ipv4/udp_offload.c
* Unmerged path net/ipv6/ip6_offload.c
* Unmerged path net/ipv6/udp_offload.c
* Unmerged path net/mpls/mpls_gso.c
