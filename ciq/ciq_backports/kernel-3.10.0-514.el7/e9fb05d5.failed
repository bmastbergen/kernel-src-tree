mmc: sdhci: Add HS400 support to SDHCI driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit e9fb05d5bca7428f2749d059559e9657c710fe53
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e9fb05d5.failed

MMC core already has support for HS400.  Add HS400
support to SDHCI driver.  The SDHC Standard specification
does not define HS400 so consequently HS400 support is
non-standard.  However HS400 is not selected without
the host controller setting the corresponding capability
flags so host controllers not yet supporting HS400
will not be affected.  To support that, a quirk
SDHCI_QUIRK2_CAPS_BIT63_FOR_HS400 is introduced to
enable the use of capabilities register reserved bit-63
to indicate HS400 support.

Because HS400 is non-standard for SDHCI, it is possible
that different vendors will do things in different ways.
However HS200 support faced the same issue but currently
there is only one solution.  As such, no attempt has
been made to provide for alternate HS400 solutions except
for SDHCI_QUIRK2_CAPS_BIT63_FOR_HS400.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit e9fb05d5bca7428f2749d059559e9657c710fe53)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci.c
#	include/linux/mmc/sdhci.h
diff --cc drivers/mmc/host/sdhci.c
index ed12fc286f94,73de62a58d70..000000000000
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@@ -1122,26 -1129,28 +1122,29 @@@ static void sdhci_finish_command(struc
  
  static u16 sdhci_get_preset_value(struct sdhci_host *host)
  {
 -	u16 preset = 0;
 +	u16 ctrl, preset = 0;
  
 -	switch (host->timing) {
 -	case MMC_TIMING_UHS_SDR12:
 +	ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
 +
 +	switch (ctrl & SDHCI_CTRL_UHS_MASK) {
 +	case SDHCI_CTRL_UHS_SDR12:
  		preset = sdhci_readw(host, SDHCI_PRESET_FOR_SDR12);
  		break;
 -	case MMC_TIMING_UHS_SDR25:
 +	case SDHCI_CTRL_UHS_SDR25:
  		preset = sdhci_readw(host, SDHCI_PRESET_FOR_SDR25);
  		break;
 -	case MMC_TIMING_UHS_SDR50:
 +	case SDHCI_CTRL_UHS_SDR50:
  		preset = sdhci_readw(host, SDHCI_PRESET_FOR_SDR50);
  		break;
 -	case MMC_TIMING_UHS_SDR104:
 -	case MMC_TIMING_MMC_HS200:
 +	case SDHCI_CTRL_UHS_SDR104:
  		preset = sdhci_readw(host, SDHCI_PRESET_FOR_SDR104);
  		break;
 -	case MMC_TIMING_UHS_DDR50:
 +	case SDHCI_CTRL_UHS_DDR50:
  		preset = sdhci_readw(host, SDHCI_PRESET_FOR_DDR50);
  		break;
+ 	case MMC_TIMING_MMC_HS400:
+ 		preset = sdhci_readw(host, SDHCI_PRESET_FOR_HS400);
+ 		break;
  	default:
  		pr_warn("%s: Invalid UHS-I mode selected\n",
  			mmc_hostname(host->mmc));
@@@ -1444,6 -1438,52 +1447,55 @@@ static void sdhci_request(struct mmc_ho
  	spin_unlock_irqrestore(&host->lock, flags);
  }
  
++<<<<<<< HEAD
++=======
+ void sdhci_set_bus_width(struct sdhci_host *host, int width)
+ {
+ 	u8 ctrl;
+ 
+ 	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
+ 	if (width == MMC_BUS_WIDTH_8) {
+ 		ctrl &= ~SDHCI_CTRL_4BITBUS;
+ 		if (host->version >= SDHCI_SPEC_300)
+ 			ctrl |= SDHCI_CTRL_8BITBUS;
+ 	} else {
+ 		if (host->version >= SDHCI_SPEC_300)
+ 			ctrl &= ~SDHCI_CTRL_8BITBUS;
+ 		if (width == MMC_BUS_WIDTH_4)
+ 			ctrl |= SDHCI_CTRL_4BITBUS;
+ 		else
+ 			ctrl &= ~SDHCI_CTRL_4BITBUS;
+ 	}
+ 	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+ }
+ EXPORT_SYMBOL_GPL(sdhci_set_bus_width);
+ 
+ void sdhci_set_uhs_signaling(struct sdhci_host *host, unsigned timing)
+ {
+ 	u16 ctrl_2;
+ 
+ 	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+ 	/* Select Bus Speed Mode for host */
+ 	ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+ 	if ((timing == MMC_TIMING_MMC_HS200) ||
+ 	    (timing == MMC_TIMING_UHS_SDR104))
+ 		ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
+ 	else if (timing == MMC_TIMING_UHS_SDR12)
+ 		ctrl_2 |= SDHCI_CTRL_UHS_SDR12;
+ 	else if (timing == MMC_TIMING_UHS_SDR25)
+ 		ctrl_2 |= SDHCI_CTRL_UHS_SDR25;
+ 	else if (timing == MMC_TIMING_UHS_SDR50)
+ 		ctrl_2 |= SDHCI_CTRL_UHS_SDR50;
+ 	else if ((timing == MMC_TIMING_UHS_DDR50) ||
+ 		 (timing == MMC_TIMING_MMC_DDR52))
+ 		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
+ 	else if (timing == MMC_TIMING_MMC_HS400)
+ 		ctrl_2 |= SDHCI_CTRL_HS400; /* Non-standard */
+ 	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+ }
+ EXPORT_SYMBOL_GPL(sdhci_set_uhs_signaling);
+ 
++>>>>>>> e9fb05d5bca7 (mmc: sdhci: Add HS400 support to SDHCI driver)
  static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
  {
  	unsigned long flags;
@@@ -1887,15 -1898,19 +1940,23 @@@ static int sdhci_execute_tuning(struct 
  	 * If the Host Controller supports the HS200 mode then the
  	 * tuning function has to be executed.
  	 */
++<<<<<<< HEAD
 +	if (((ctrl & SDHCI_CTRL_UHS_MASK) == SDHCI_CTRL_UHS_SDR50) &&
 +	    (host->flags & SDHCI_SDR50_NEEDS_TUNING ||
 +	     host->flags & SDHCI_SDR104_NEEDS_TUNING))
 +		requires_tuning_nonuhs = true;
++=======
+ 	switch (host->timing) {
+ 	case MMC_TIMING_MMC_HS400:
+ 	case MMC_TIMING_MMC_HS200:
+ 	case MMC_TIMING_UHS_SDR104:
+ 		break;
++>>>>>>> e9fb05d5bca7 (mmc: sdhci: Add HS400 support to SDHCI driver)
  
 -	case MMC_TIMING_UHS_SDR50:
 -		if (host->flags & SDHCI_SDR50_NEEDS_TUNING ||
 -		    host->flags & SDHCI_SDR104_NEEDS_TUNING)
 -			break;
 -		/* FALLTHROUGH */
 -
 -	default:
 +	if (((ctrl & SDHCI_CTRL_UHS_MASK) == SDHCI_CTRL_UHS_SDR104) ||
 +	    requires_tuning_nonuhs)
 +		ctrl |= SDHCI_CTRL_EXEC_TUNING;
 +	else {
  		spin_unlock_irqrestore(&host->lock, flags);
  		sdhci_runtime_pm_put(host);
  		return 0;
@@@ -3056,7 -3127,18 +3117,22 @@@ int sdhci_add_host(struct sdhci_host *h
  	} else if (caps[1] & SDHCI_SUPPORT_SDR50)
  		mmc->caps |= MMC_CAP_UHS_SDR50;
  
++<<<<<<< HEAD
 +	if (caps[1] & SDHCI_SUPPORT_DDR50)
++=======
+ 	if (host->quirks2 & SDHCI_QUIRK2_CAPS_BIT63_FOR_HS400 &&
+ 	    (caps[1] & SDHCI_SUPPORT_HS400))
+ 		mmc->caps2 |= MMC_CAP2_HS400;
+ 
+ 	if ((mmc->caps2 & MMC_CAP2_HSX00_1_2V) &&
+ 	    (IS_ERR(mmc->supply.vqmmc) ||
+ 	     !regulator_is_supported_voltage(mmc->supply.vqmmc, 1100000,
+ 					     1300000)))
+ 		mmc->caps2 &= ~MMC_CAP2_HSX00_1_2V;
+ 
+ 	if ((caps[1] & SDHCI_SUPPORT_DDR50) &&
+ 		!(host->quirks2 & SDHCI_QUIRK2_BROKEN_DDR50))
++>>>>>>> e9fb05d5bca7 (mmc: sdhci: Add HS400 support to SDHCI driver)
  		mmc->caps |= MMC_CAP_UHS_DDR50;
  
  	/* Does the host need tuning for SDR50? */
diff --cc include/linux/mmc/sdhci.h
index 7c176e5d3cf5,375af80bde7d..000000000000
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@@ -96,6 -92,20 +96,23 @@@ struct sdhci_host 
  #define SDHCI_QUIRK2_NO_1_8_V				(1<<2)
  #define SDHCI_QUIRK2_PRESET_VALUE_BROKEN		(1<<3)
  #define SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON		(1<<4)
++<<<<<<< HEAD
++=======
+ /* Controller has a non-standard host control register */
+ #define SDHCI_QUIRK2_BROKEN_HOST_CONTROL		(1<<5)
+ /* Controller does not support HS200 */
+ #define SDHCI_QUIRK2_BROKEN_HS200			(1<<6)
+ /* Controller does not support DDR50 */
+ #define SDHCI_QUIRK2_BROKEN_DDR50			(1<<7)
+ /* Stop command (CMD12) can set Transfer Complete when not using MMC_RSP_BUSY */
+ #define SDHCI_QUIRK2_STOP_WITH_TC			(1<<8)
+ /* Controller does not support 64-bit DMA */
+ #define SDHCI_QUIRK2_BROKEN_64_BIT_DMA			(1<<9)
+ /* need clear transfer mode register before send cmd */
+ #define SDHCI_QUIRK2_CLEAR_TRANSFERMODE_REG_BEFORE_CMD	(1<<10)
+ /* Capability register bit-63 indicates HS400 support */
+ #define SDHCI_QUIRK2_CAPS_BIT63_FOR_HS400		(1<<11)
++>>>>>>> e9fb05d5bca7 (mmc: sdhci: Add HS400 support to SDHCI driver)
  
  	int irq;		/* Device IRQ */
  	void __iomem *ioaddr;	/* Mapped address */
* Unmerged path drivers/mmc/host/sdhci.c
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index 193d73594c5d..dbed6029d07c 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -161,6 +161,7 @@
 #define   SDHCI_CTRL_UHS_SDR50		0x0002
 #define   SDHCI_CTRL_UHS_SDR104		0x0003
 #define   SDHCI_CTRL_UHS_DDR50		0x0004
+#define   SDHCI_CTRL_HS400		0x0005 /* Non-standard */
 #define  SDHCI_CTRL_VDD_180		0x0008
 #define  SDHCI_CTRL_DRV_TYPE_MASK	0x0030
 #define   SDHCI_CTRL_DRV_TYPE_B		0x0000
@@ -203,6 +204,7 @@
 #define  SDHCI_RETUNING_MODE_SHIFT		14
 #define  SDHCI_CLOCK_MUL_MASK	0x00FF0000
 #define  SDHCI_CLOCK_MUL_SHIFT	16
+#define  SDHCI_SUPPORT_HS400	0x80000000 /* Non-standard */
 
 #define SDHCI_CAPABILITIES_1	0x44
 
@@ -234,6 +236,7 @@
 #define SDHCI_PRESET_FOR_SDR50 0x6A
 #define SDHCI_PRESET_FOR_SDR104        0x6C
 #define SDHCI_PRESET_FOR_DDR50 0x6E
+#define SDHCI_PRESET_FOR_HS400 0x74 /* Non-standard */
 #define SDHCI_PRESET_DRV_MASK  0xC000
 #define SDHCI_PRESET_DRV_SHIFT  14
 #define SDHCI_PRESET_CLKGEN_SEL_MASK   0x400
* Unmerged path include/linux/mmc/sdhci.h
