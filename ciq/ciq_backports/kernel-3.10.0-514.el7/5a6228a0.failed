lwtunnel: change prototype of lwtunnel_state_get()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Nicolas Dichtel <nicolas.dichtel@6wind.com>
commit 5a6228a0b472062646434cd2536d109c102b606e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/5a6228a0.failed

It saves some lines and simplify a bit the code when the state is returning
by this function. It's also useful to handle a NULL entry.

To avoid too long lines, I've also renamed lwtunnel_state_get() and
lwtunnel_state_put() to lwtstate_get() and lwtstate_put().

CC: Thomas Graf <tgraf@suug.ch>
CC: Roopa Prabhu <roopa@cumulusnetworks.com>
	Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5a6228a0b472062646434cd2536d109c102b606e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/lwtunnel.h
#	net/ipv4/fib_semantics.c
#	net/ipv4/route.c
#	net/ipv6/ip6_fib.c
#	net/ipv6/route.c
diff --cc net/ipv4/fib_semantics.c
index 1938e2490ebe,65e00399a9a6..000000000000
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@@ -208,6 -209,7 +208,10 @@@ static void free_fib_info_rcu(struct rc
  	change_nexthops(fi) {
  		if (nexthop_nh->nh_dev)
  			dev_put(nexthop_nh->nh_dev);
++<<<<<<< HEAD
++=======
+ 		lwtstate_put(nexthop_nh->nh_lwtstate);
++>>>>>>> 5a6228a0b472 (lwtunnel: change prototype of lwtunnel_state_get())
  		free_nh_exceptions(nexthop_nh);
  		rt_fibinfo_free_cpus(nexthop_nh->nh_pcpu_rth_output);
  		rt_fibinfo_free(&nexthop_nh->nh_rth_input);
@@@ -474,6 -497,26 +478,29 @@@ static int fib_get_nhs(struct fib_info 
  			if (nexthop_nh->nh_tclassid)
  				fi->fib_net->ipv4.fib_num_tclassid_users++;
  #endif
++<<<<<<< HEAD
++=======
+ 			nla = nla_find(attrs, attrlen, RTA_ENCAP);
+ 			if (nla) {
+ 				struct lwtunnel_state *lwtstate;
+ 				struct net_device *dev = NULL;
+ 				struct nlattr *nla_entype;
+ 
+ 				nla_entype = nla_find(attrs, attrlen,
+ 						      RTA_ENCAP_TYPE);
+ 				if (!nla_entype)
+ 					goto err_inval;
+ 				if (cfg->fc_oif)
+ 					dev = __dev_get_by_index(net, cfg->fc_oif);
+ 				ret = lwtunnel_build_state(dev, nla_get_u16(
+ 							   nla_entype),
+ 							   nla, &lwtstate);
+ 				if (ret)
+ 					goto errout;
+ 				nexthop_nh->nh_lwtstate =
+ 					lwtstate_get(lwtstate);
+ 			}
++>>>>>>> 5a6228a0b472 (lwtunnel: change prototype of lwtunnel_state_get())
  		}
  
  		rtnh = rtnh_next(rtnh, &remaining);
@@@ -896,6 -958,21 +923,24 @@@ struct fib_info *fib_create_info(struc
  	} else {
  		struct fib_nh *nh = fi->fib_nh;
  
++<<<<<<< HEAD
++=======
+ 		if (cfg->fc_encap) {
+ 			struct lwtunnel_state *lwtstate;
+ 			struct net_device *dev = NULL;
+ 
+ 			if (cfg->fc_encap_type == LWTUNNEL_ENCAP_NONE)
+ 				goto err_inval;
+ 			if (cfg->fc_oif)
+ 				dev = __dev_get_by_index(net, cfg->fc_oif);
+ 			err = lwtunnel_build_state(dev, cfg->fc_encap_type,
+ 						   cfg->fc_encap, &lwtstate);
+ 			if (err)
+ 				goto failure;
+ 
+ 			nh->nh_lwtstate = lwtstate_get(lwtstate);
+ 		}
++>>>>>>> 5a6228a0b472 (lwtunnel: change prototype of lwtunnel_state_get())
  		nh->nh_oif = cfg->fc_oif;
  		nh->nh_gw = cfg->fc_gw;
  		nh->nh_flags = cfg->fc_flags;
diff --cc net/ipv4/route.c
index bb601e82773a,11096396ef4a..000000000000
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@@ -1331,10 -1352,13 +1331,14 @@@ static void ipv4_dst_destroy(struct dst
  	struct rtable *rt = (struct rtable *) dst;
  
  	if (!list_empty(&rt->rt_uncached)) {
 -		struct uncached_list *ul = rt->rt_uncached_list;
 -
 -		spin_lock_bh(&ul->lock);
 +		spin_lock_bh(&rt_uncached_lock);
  		list_del(&rt->rt_uncached);
 -		spin_unlock_bh(&ul->lock);
 +		spin_unlock_bh(&rt_uncached_lock);
  	}
++<<<<<<< HEAD
++=======
+ 	lwtstate_put(rt->rt_lwtstate);
++>>>>>>> 5a6228a0b472 (lwtunnel: change prototype of lwtunnel_state_get())
  }
  
  void rt_flush_dev(struct net_device *dev)
@@@ -1380,6 -1407,7 +1384,10 @@@ static void rt_set_nexthop(struct rtabl
  #ifdef CONFIG_IP_ROUTE_CLASSID
  		rt->dst.tclassid = nh->nh_tclassid;
  #endif
++<<<<<<< HEAD
++=======
+ 		rt->rt_lwtstate = lwtstate_get(nh->nh_lwtstate);
++>>>>>>> 5a6228a0b472 (lwtunnel: change prototype of lwtunnel_state_get())
  		if (unlikely(fnhe))
  			cached = rt_bind_exception(rt, fnhe, daddr);
  		else if (!(rt->dst.flags & DST_NOCACHE))
diff --cc net/ipv6/ip6_fib.c
index f06e53333b5c,5693b5eb8482..000000000000
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@@ -161,10 -155,33 +161,36 @@@ static __inline__ void node_free(struc
  	kmem_cache_free(fib6_node_kmem, fn);
  }
  
 -static void rt6_free_pcpu(struct rt6_info *non_pcpu_rt)
 +static __inline__ void rt6_release(struct rt6_info *rt)
  {
++<<<<<<< HEAD
 +	if (atomic_dec_and_test(&rt->rt6i_ref))
++=======
+ 	int cpu;
+ 
+ 	if (!non_pcpu_rt->rt6i_pcpu)
+ 		return;
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		struct rt6_info **ppcpu_rt;
+ 		struct rt6_info *pcpu_rt;
+ 
+ 		ppcpu_rt = per_cpu_ptr(non_pcpu_rt->rt6i_pcpu, cpu);
+ 		pcpu_rt = *ppcpu_rt;
+ 		if (pcpu_rt) {
+ 			dst_free(&pcpu_rt->dst);
+ 			*ppcpu_rt = NULL;
+ 		}
+ 	}
+ }
+ 
+ static void rt6_release(struct rt6_info *rt)
+ {
+ 	if (atomic_dec_and_test(&rt->rt6i_ref)) {
+ 		lwtstate_put(rt->rt6i_lwtstate);
+ 		rt6_free_pcpu(rt);
++>>>>>>> 5a6228a0b472 (lwtunnel: change prototype of lwtunnel_state_get())
  		dst_free(&rt->dst);
 -	}
  }
  
  static void fib6_link_table(struct net *net, struct fib6_table *tb)
diff --cc net/ipv6/route.c
index 1b3524b3978c,c9b2b9fe83fc..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -1610,12 -1771,22 +1610,27 @@@ int ip6_route_add(struct fib6_config *c
  
  	rt->dst.output = ip6_output;
  
++<<<<<<< HEAD
++=======
+ 	if (cfg->fc_encap) {
+ 		struct lwtunnel_state *lwtstate;
+ 
+ 		err = lwtunnel_build_state(dev, cfg->fc_encap_type,
+ 					   cfg->fc_encap, &lwtstate);
+ 		if (err)
+ 			goto out;
+ 		rt->rt6i_lwtstate = lwtstate_get(lwtstate);
+ 		if (lwtunnel_output_redirect(rt->rt6i_lwtstate))
+ 			rt->dst.output = lwtunnel_output6;
+ 	}
+ 
++>>>>>>> 5a6228a0b472 (lwtunnel: change prototype of lwtunnel_state_get())
  	ipv6_addr_prefix(&rt->rt6i_dst.addr, &cfg->fc_dst, cfg->fc_dst_len);
  	rt->rt6i_dst.plen = cfg->fc_dst_len;
 -	if (rt->rt6i_dst.plen == 128)
 +	if (rt->rt6i_dst.plen == 128) {
  		rt->dst.flags |= DST_HOST;
 +		dst_metrics_set_force_overwrite(&rt->dst);
 +	}
  
  #ifdef CONFIG_IPV6_SUBTREES
  	ipv6_addr_prefix(&rt->rt6i_src.addr, &cfg->fc_src, cfg->fc_src_len);
@@@ -1961,42 -2131,36 +1976,48 @@@ out
   *	Misc support functions
   */
  
 -static void rt6_set_from(struct rt6_info *rt, struct rt6_info *from)
 +static struct rt6_info *ip6_rt_copy(struct rt6_info *ort,
 +				    const struct in6_addr *dest)
  {
 -	BUG_ON(from->dst.from);
 +	struct net *net = dev_net(ort->dst.dev);
 +	struct rt6_info *rt = ip6_dst_alloc(net, ort->dst.dev, 0,
 +					    ort->rt6i_table);
  
 -	rt->rt6i_flags &= ~RTF_EXPIRES;
 -	dst_hold(&from->dst);
 -	rt->dst.from = &from->dst;
 -	dst_init_metrics(&rt->dst, dst_metrics_ptr(&from->dst), true);
 -}
 +	if (rt) {
 +		rt->dst.input = ort->dst.input;
 +		rt->dst.output = ort->dst.output;
 +		rt->dst.flags |= DST_HOST;
 +
 +		rt->rt6i_dst.addr = *dest;
 +		rt->rt6i_dst.plen = 128;
 +		dst_copy_metrics(&rt->dst, &ort->dst);
 +		rt->dst.error = ort->dst.error;
 +		rt->rt6i_idev = ort->rt6i_idev;
 +		if (rt->rt6i_idev)
 +			in6_dev_hold(rt->rt6i_idev);
 +		rt->dst.lastuse = jiffies;
 +
 +		if (ort->rt6i_flags & RTF_GATEWAY)
 +			rt->rt6i_gateway = ort->rt6i_gateway;
 +		else
 +			rt->rt6i_gateway = *dest;
 +		rt->rt6i_flags = ort->rt6i_flags;
 +		rt6_set_from(rt, ort);
 +		rt->rt6i_metric = 0;
  
 -static void ip6_rt_copy_init(struct rt6_info *rt, struct rt6_info *ort)
 -{
 -	rt->dst.input = ort->dst.input;
 -	rt->dst.output = ort->dst.output;
 -	rt->rt6i_dst = ort->rt6i_dst;
 -	rt->dst.error = ort->dst.error;
 -	rt->rt6i_idev = ort->rt6i_idev;
 -	if (rt->rt6i_idev)
 -		in6_dev_hold(rt->rt6i_idev);
 -	rt->dst.lastuse = jiffies;
 -	rt->rt6i_gateway = ort->rt6i_gateway;
 -	rt->rt6i_flags = ort->rt6i_flags;
 -	rt6_set_from(rt, ort);
 -	rt->rt6i_metric = ort->rt6i_metric;
  #ifdef CONFIG_IPV6_SUBTREES
 -	rt->rt6i_src = ort->rt6i_src;
 +		memcpy(&rt->rt6i_src, &ort->rt6i_src, sizeof(struct rt6key));
  #endif
++<<<<<<< HEAD
 +		memcpy(&rt->rt6i_prefsrc, &ort->rt6i_prefsrc, sizeof(struct rt6key));
 +		rt->rt6i_table = ort->rt6i_table;
 +	}
 +	return rt;
++=======
+ 	rt->rt6i_prefsrc = ort->rt6i_prefsrc;
+ 	rt->rt6i_table = ort->rt6i_table;
+ 	rt->rt6i_lwtstate = lwtstate_get(ort->rt6i_lwtstate);
++>>>>>>> 5a6228a0b472 (lwtunnel: change prototype of lwtunnel_state_get())
  }
  
  #ifdef CONFIG_IPV6_ROUTE_INFO
* Unmerged path include/net/lwtunnel.h
* Unmerged path include/net/lwtunnel.h
* Unmerged path net/ipv4/fib_semantics.c
* Unmerged path net/ipv4/route.c
* Unmerged path net/ipv6/ip6_fib.c
* Unmerged path net/ipv6/route.c
