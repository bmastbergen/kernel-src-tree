mmc: sdhci: cache timing information locally

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Russell King <rmk+kernel@arm.linux.org.uk>
commit d975f121011a58223c7936ab483c3374a83236c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d975f121.failed

Rather than reading back the timing information from the registers,
cache it locally.  This allows implementations to translate the UHS
timing by overriding the set_uhs_signaling() method as required
without also having to emulate the SDHCI_HOST_CONTROL2 register.

	Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
	Tested-by: Markus Pargmann <mpa@pengutronix.de>
	Tested-by: Stephen Warren <swarren@nvidia.com>
[Ulf Hansson] Resolved conflict
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Chris Ball <chris@printf.net>
(cherry picked from commit d975f121011a58223c7936ab483c3374a83236c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci.c
diff --cc drivers/mmc/host/sdhci.c
index e292d602646d,956799c75df2..000000000000
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@@ -1539,26 -1536,8 +1538,31 @@@ static void sdhci_do_set_ios(struct sdh
  		clk &= ~SDHCI_CLOCK_CARD_EN;
  		sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
  
++<<<<<<< HEAD
 +		if (host->ops->set_uhs_signaling)
 +			host->ops->set_uhs_signaling(host, ios->timing);
 +		else {
 +			ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
 +			/* Select Bus Speed Mode for host */
 +			ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
 +			if ((ios->timing == MMC_TIMING_MMC_HS200) ||
 +			    (ios->timing == MMC_TIMING_UHS_SDR104))
 +				ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
 +			else if (ios->timing == MMC_TIMING_UHS_SDR12)
 +				ctrl_2 |= SDHCI_CTRL_UHS_SDR12;
 +			else if (ios->timing == MMC_TIMING_UHS_SDR25)
 +				ctrl_2 |= SDHCI_CTRL_UHS_SDR25;
 +			else if (ios->timing == MMC_TIMING_UHS_SDR50)
 +				ctrl_2 |= SDHCI_CTRL_UHS_SDR50;
 +			else if ((ios->timing == MMC_TIMING_UHS_DDR50) ||
 +				 (ios->timing == MMC_TIMING_MMC_DDR52))
 +				ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
 +			sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
 +		}
++=======
+ 		host->ops->set_uhs_signaling(host, ios->timing);
+ 		host->timing = ios->timing;
++>>>>>>> d975f121011a (mmc: sdhci: cache timing information locally)
  
  		if (!(host->quirks2 & SDHCI_QUIRK2_PRESET_VALUE_BROKEN) &&
  				((ios->timing == MMC_TIMING_UHS_SDR12) ||
* Unmerged path drivers/mmc/host/sdhci.c
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index 1f55d4bcbbfb..006f5b9d46e9 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -170,6 +170,8 @@ struct sdhci_host {
 	unsigned int            ocr_avail_mmc;
 	u32 ocr_mask;		/* available voltages */
 
+	unsigned		timing;		/* Current timing */
+
 	u32			thread_isr;
 
 	wait_queue_head_t	buf_ready_int;	/* Waitqueue for Buffer Read Ready interrupt */
