dm verity: clean up duplicate hashing code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sami Tolvanen <samitolvanen@google.com>
commit 6dbeda3469ced777bc3138ed5918f7ae79670b7b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6dbeda34.failed

Handle dm-verity salting in one place to simplify the code.

	Signed-off-by: Sami Tolvanen <samitolvanen@google.com>
	Reviewed-by: Kees Cook <keescook@chromium.org>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 6dbeda3469ced777bc3138ed5918f7ae79670b7b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-verity.c
diff --cc drivers/md/dm-verity.c
index b15d88861f1c,24517055bd8e..000000000000
--- a/drivers/md/dm-verity.c
+++ b/drivers/md/dm-verity.c
@@@ -356,106 -421,56 +431,89 @@@ static int verity_hash_for_block(struc
  static int verity_verify_io(struct dm_verity_io *io)
  {
  	struct dm_verity *v = io->v;
 -	struct bio *bio = dm_bio_from_per_bio_data(io,
 -						   v->ti->per_bio_data_size);
  	unsigned b;
++<<<<<<< HEAD
 +	int i;
 +	unsigned vector = 0, offset = 0;
++=======
++>>>>>>> 6dbeda3469ce (dm verity: clean up duplicate hashing code)
  
  	for (b = 0; b < io->n_blocks; b++) {
- 		struct shash_desc *desc;
- 		u8 *result;
  		int r;
  		unsigned todo;
+ 		struct shash_desc *desc = io_hash_desc(v, io);
  
- 		if (likely(v->levels)) {
- 			/*
- 			 * First, we try to get the requested hash for
- 			 * the current block. If the hash block itself is
- 			 * verified, zero is returned. If it isn't, this
- 			 * function returns 0 and we fall back to whole
- 			 * chain verification.
- 			 */
- 			int r = verity_verify_level(io, io->block + b, 0, true);
- 			if (likely(!r))
- 				goto test_block_hash;
- 			if (r < 0)
- 				return r;
- 		}
- 
- 		memcpy(io_want_digest(v, io), v->root_digest, v->digest_size);
- 
- 		for (i = v->levels - 1; i >= 0; i--) {
- 			int r = verity_verify_level(io, io->block + b, i, false);
- 			if (unlikely(r))
- 				return r;
- 		}
+ 		r = verity_hash_for_block(v, io, io->block + b,
+ 					  io_want_digest(v, io));
+ 		if (unlikely(r < 0))
+ 			return r;
  
- test_block_hash:
- 		desc = io_hash_desc(v, io);
- 		desc->tfm = v->tfm;
- 		desc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;
- 		r = crypto_shash_init(desc);
- 		if (r < 0) {
- 			DMERR("crypto_shash_init failed: %d", r);
+ 		r = verity_hash_init(v, desc);
+ 		if (unlikely(r < 0))
  			return r;
- 		}
  
++<<<<<<< HEAD
 +		if (likely(v->version >= 1)) {
 +			r = crypto_shash_update(desc, v->salt, v->salt_size);
 +			if (r < 0) {
 +				DMERR("crypto_shash_update failed: %d", r);
 +				return r;
 +			}
 +		}
 +
++=======
++>>>>>>> 6dbeda3469ce (dm verity: clean up duplicate hashing code)
  		todo = 1 << v->data_dev_block_bits;
  		do {
 +			struct bio_vec *bv;
  			u8 *page;
  			unsigned len;
 -			struct bio_vec bv = bio_iter_iovec(bio, io->iter);
  
 -			page = kmap_atomic(bv.bv_page);
 -			len = bv.bv_len;
 +			BUG_ON(vector >= io->io_vec_size);
 +			bv = &io->io_vec[vector];
 +			page = kmap_atomic(bv->bv_page);
 +			len = bv->bv_len - offset;
  			if (likely(len >= todo))
  				len = todo;
++<<<<<<< HEAD
 +			r = crypto_shash_update(desc,
 +					page + bv->bv_offset + offset, len);
 +			kunmap_atomic(page);
 +			if (r < 0) {
 +				DMERR("crypto_shash_update failed: %d", r);
 +				return r;
 +			}
 +			offset += len;
 +			if (likely(offset == bv->bv_len)) {
 +				offset = 0;
 +				vector++;
 +			}
- 			todo -= len;
- 		} while (todo);
++=======
+ 			r = verity_hash_update(v, desc,  page + bv.bv_offset,
+ 					       len);
+ 			kunmap_atomic(page);
  
- 		if (!v->version) {
- 			r = crypto_shash_update(desc, v->salt, v->salt_size);
- 			if (r < 0) {
- 				DMERR("crypto_shash_update failed: %d", r);
+ 			if (unlikely(r < 0))
  				return r;
- 			}
- 		}
  
- 		result = io_real_digest(v, io);
- 		r = crypto_shash_final(desc, result);
- 		if (r < 0) {
- 			DMERR("crypto_shash_final failed: %d", r);
+ 			bio_advance_iter(bio, &io->iter, len);
++>>>>>>> 6dbeda3469ce (dm verity: clean up duplicate hashing code)
+ 			todo -= len;
+ 		} while (todo);
+ 
+ 		r = verity_hash_final(v, desc, io_real_digest(v, io));
+ 		if (unlikely(r < 0))
  			return r;
- 		}
- 		if (unlikely(memcmp(result, io_want_digest(v, io), v->digest_size))) {
- 			if (verity_handle_err(v, DM_VERITY_BLOCK_TYPE_DATA,
- 					      io->block + b))
- 				return -EIO;
- 		}
+ 
+ 		if (likely(memcmp(io_real_digest(v, io),
+ 				io_want_digest(v, io), v->digest_size) == 0))
+ 			continue;
+ 		else if (verity_handle_err(v, DM_VERITY_BLOCK_TYPE_DATA,
+ 				io->block + b))
+ 			return -EIO;
  	}
 +	BUG_ON(vector != io->io_vec_size);
 +	BUG_ON(offset);
  
  	return 0;
  }
* Unmerged path drivers/md/dm-verity.c
