ext2: remove ext2_xip_verify_sb()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matthew Wilcox <matthew.r.wilcox@intel.com>
commit 0de4830fd49f60d04ba37e8b32f95100f3953c39
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0de4830f.failed

Jan Kara pointed out that calling ext2_xip_verify_sb() in ext2_remount()
doesn't make sense, since changing the XIP option on remount isn't
allowed.  It also doesn't make sense to re-check whether blocksize is
supported since it can't change between mounts.

Replace the call to ext2_xip_verify_sb() in ext2_fill_super() with the
equivalent check and delete the definition.

	Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
	Cc: Andreas Dilger <andreas.dilger@intel.com>
	Cc: Boaz Harrosh <boaz@plexistor.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Dave Chinner <david@fromorbit.com>
	Cc: Jan Kara <jack@suse.cz>
	Cc: Jens Axboe <axboe@kernel.dk>
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: Theodore Ts'o <tytso@mit.edu>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0de4830fd49f60d04ba37e8b32f95100f3953c39)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext2/xip.c
#	fs/ext2/xip.h
diff --cc fs/ext2/xip.c
index c79eaf871406,66ca1133827e..000000000000
--- a/fs/ext2/xip.c
+++ b/fs/ext2/xip.c
@@@ -13,73 -13,3 +13,76 @@@
  #include "ext2.h"
  #include "xip.h"
  
++<<<<<<< HEAD
 +static inline long __inode_direct_access(struct inode *inode, sector_t block,
 +				void **kaddr, unsigned long *pfn, long size)
 +{
 +	struct block_device *bdev = inode->i_sb->s_bdev;
 +	sector_t sector = block * (PAGE_SIZE / 512);
 +	return bdev_direct_access(bdev, sector, kaddr, pfn, size);
 +}
 +
 +static inline int
 +__ext2_get_block(struct inode *inode, pgoff_t pgoff, int create,
 +		   sector_t *result)
 +{
 +	struct buffer_head tmp;
 +	int rc;
 +
 +	memset(&tmp, 0, sizeof(struct buffer_head));
 +	rc = ext2_get_block(inode, pgoff, &tmp, create);
 +	*result = tmp.b_blocknr;
 +
 +	/* did we get a sparse block (hole in the file)? */
 +	if (!tmp.b_blocknr && !rc) {
 +		BUG_ON(create);
 +		rc = -ENODATA;
 +	}
 +
 +	return rc;
 +}
 +
 +int
 +ext2_clear_xip_target(struct inode *inode, sector_t block)
 +{
 +	void *kaddr;
 +	unsigned long pfn;
 +	long size;
 +
 +	size = __inode_direct_access(inode, block, &kaddr, &pfn, PAGE_SIZE);
 +	if (size < 0)
 +		return size;
 +	clear_page(kaddr);
 +	return 0;
 +}
 +
 +void ext2_xip_verify_sb(struct super_block *sb)
 +{
 +	struct ext2_sb_info *sbi = EXT2_SB(sb);
 +
 +	if ((sbi->s_mount_opt & EXT2_MOUNT_XIP) &&
 +	    !sb->s_bdev->bd_disk->fops->direct_access) {
 +		sbi->s_mount_opt &= (~EXT2_MOUNT_XIP);
 +		ext2_msg(sb, KERN_WARNING,
 +			     "warning: ignoring xip option - "
 +			     "not supported by bdev");
 +	}
 +}
 +
 +int ext2_get_xip_mem(struct address_space *mapping, pgoff_t pgoff, int create,
 +				void **kmem, unsigned long *pfn)
 +{
 +	long rc;
 +	sector_t block;
 +
 +	/* first, retrieve the sector number */
 +	rc = __ext2_get_block(mapping->host, pgoff, create, &block);
 +	if (rc)
 +		return rc;
 +
 +	/* retrieve address of the target data */
 +	rc = __inode_direct_access(mapping->host, block, kmem, pfn, PAGE_SIZE);
 +	return (rc < 0) ? rc : 0;
 +}
++=======
++>>>>>>> 0de4830fd49f (ext2: remove ext2_xip_verify_sb())
diff --cc fs/ext2/xip.h
index 18b34d2f31b3,87eeb0460e8c..000000000000
--- a/fs/ext2/xip.h
+++ b/fs/ext2/xip.h
@@@ -6,21 -6,11 +6,27 @@@
   */
  
  #ifdef CONFIG_EXT2_FS_XIP
++<<<<<<< HEAD
 +extern void ext2_xip_verify_sb (struct super_block *);
 +extern int ext2_clear_xip_target (struct inode *, sector_t);
 +
++=======
++>>>>>>> 0de4830fd49f (ext2: remove ext2_xip_verify_sb())
  static inline int ext2_use_xip (struct super_block *sb)
  {
  	struct ext2_sb_info *sbi = EXT2_SB(sb);
  	return (sbi->s_mount_opt & EXT2_MOUNT_XIP);
  }
 +int ext2_get_xip_mem(struct address_space *, pgoff_t, int,
 +				void **, unsigned long *);
 +#define mapping_is_xip(map) unlikely(map->a_ops->get_xip_mem)
  #else
++<<<<<<< HEAD
 +#define mapping_is_xip(map)			0
 +#define ext2_xip_verify_sb(sb)			do { } while (0)
++=======
++>>>>>>> 0de4830fd49f (ext2: remove ext2_xip_verify_sb())
  #define ext2_use_xip(sb)			0
 +#define ext2_clear_xip_target(inode, chain)	0
 +#define ext2_get_xip_mem			NULL
  #endif
diff --git a/fs/ext2/super.c b/fs/ext2/super.c
index a47e9381bae0..5e9f2e47beb5 100644
--- a/fs/ext2/super.c
+++ b/fs/ext2/super.c
@@ -868,9 +868,6 @@ static int ext2_fill_super(struct super_block *sb, void *data, int silent)
 		((EXT2_SB(sb)->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ?
 		 MS_POSIXACL : 0);
 
-	ext2_xip_verify_sb(sb); /* see if bdev supports xip, unset
-				    EXT2_MOUNT_XIP if not */
-
 	if (le32_to_cpu(es->s_rev_level) == EXT2_GOOD_OLD_REV &&
 	    (EXT2_HAS_COMPAT_FEATURE(sb, ~0U) ||
 	     EXT2_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||
@@ -900,11 +897,17 @@ static int ext2_fill_super(struct super_block *sb, void *data, int silent)
 
 	blocksize = BLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);
 
-	if (ext2_use_xip(sb) && blocksize != PAGE_SIZE) {
-		if (!silent)
+	if (sbi->s_mount_opt & EXT2_MOUNT_XIP) {
+		if (blocksize != PAGE_SIZE) {
 			ext2_msg(sb, KERN_ERR,
-				"error: unsupported blocksize for xip");
-		goto failed_mount;
+					"error: unsupported blocksize for xip");
+			goto failed_mount;
+		}
+		if (!sb->s_bdev->bd_disk->fops->direct_access) {
+			ext2_msg(sb, KERN_ERR,
+					"error: device does not support xip");
+			goto failed_mount;
+		}
 	}
 
 	/* If the blocksize doesn't match, re-read the thing.. */
@@ -1249,7 +1252,6 @@ static int ext2_remount (struct super_block * sb, int * flags, char * data)
 {
 	struct ext2_sb_info * sbi = EXT2_SB(sb);
 	struct ext2_super_block * es;
-	unsigned long old_mount_opt = sbi->s_mount_opt;
 	struct ext2_mount_options old_opts;
 	unsigned long old_sb_flags;
 	int err;
@@ -1273,22 +1275,11 @@ static int ext2_remount (struct super_block * sb, int * flags, char * data)
 	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
 		((sbi->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);
 
-	ext2_xip_verify_sb(sb); /* see if bdev supports xip, unset
-				    EXT2_MOUNT_XIP if not */
-
-	if ((ext2_use_xip(sb)) && (sb->s_blocksize != PAGE_SIZE)) {
-		ext2_msg(sb, KERN_WARNING,
-			"warning: unsupported blocksize for xip");
-		err = -EINVAL;
-		goto restore_opts;
-	}
-
 	es = sbi->s_es;
-	if ((sbi->s_mount_opt ^ old_mount_opt) & EXT2_MOUNT_XIP) {
+	if ((sbi->s_mount_opt ^ old_opts.s_mount_opt) & EXT2_MOUNT_XIP) {
 		ext2_msg(sb, KERN_WARNING, "warning: refusing change of "
 			 "xip flag with busy inodes while remounting");
-		sbi->s_mount_opt &= ~EXT2_MOUNT_XIP;
-		sbi->s_mount_opt |= old_mount_opt & EXT2_MOUNT_XIP;
+		sbi->s_mount_opt ^= EXT2_MOUNT_XIP;
 	}
 	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY)) {
 		spin_unlock(&sbi->s_lock);
* Unmerged path fs/ext2/xip.c
* Unmerged path fs/ext2/xip.h
