drm/i915/gen9: Only copy WM results for changed pipes to skl_hw

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drm] i915/gen9: Only copy WM results for changed pipes to skl_hw (Lyude Paul) [1341633 1355776]
Rebuild_FUZZ: 96.72%
commit-author Matt Roper <matthew.d.roper@intel.com>
commit 2722efb90b3420dee54b4cb3cdc7917efacc2dce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2722efb9.failed

When we write watermark values to the hardware, those values are stored
in dev_priv->wm.skl_hw.  However with recent watermark changes, the
results structure we're copying from only contains valid watermark and
DDB values for the pipes that are actually changing; the values for
other pipes remain 0.  Thus a blind copy of the entire skl_wm_values
structure will clobber the values for unchanged pipes...we need to be
more selective and only copy over the values for the changing pipes.

This mistake was hidden until recently due to another bug that caused us
to erroneously re-calculate watermarks for all active pipes rather than
changing pipes.  Only when that bug was fixed was the impact of this bug
discovered (e.g., modesets failing with "Requested display configuration
exceeds system watermark limitations" messages and leaving watermarks
non-functional, even ones initiated by intel_fbdev_restore_mode).

Changes since v1:
 - Add a function for copying a pipe's wm values
   (skl_copy_wm_for_pipe()) so we can reuse this later

Fixes: 734fa01f3a17 ("drm/i915/gen9: Calculate watermarks during atomic 'check' (v2)")
Fixes: 9b6130227495 ("drm/i915/gen9: Re-allocate DDB only for changed pipes")
	Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
	Signed-off-by: Lyude <cpaul@redhat.com>
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
	Cc: stable@vger.kernel.org
	Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
	Cc: Daniel Vetter <daniel.vetter@intel.com>
	Cc: Radhakrishna Sripada <radhakrishna.sripada@intel.com>
	Cc: Hans de Goede <hdegoede@redhat.com>
	Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1471463761-26796-4-git-send-email-cpaul@redhat.com
(cherry picked from commit 2722efb90b3420dee54b4cb3cdc7917efacc2dce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index 29a433e4d2d1,177fdf3194f7..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -3253,149 -4015,249 +3253,260 @@@ static void skl_flush_wm_values(struct 
  	}
  }
  
 -static int skl_update_pipe_wm(struct drm_crtc_state *cstate,
 -			      struct skl_ddb_allocation *ddb, /* out */
 -			      struct skl_pipe_wm *pipe_wm, /* out */
 -			      bool *changed /* out */)
 +static bool skl_update_pipe_wm(struct drm_crtc *crtc,
 +			       struct skl_pipe_wm_parameters *params,
 +			       struct intel_wm_config *config,
 +			       struct skl_ddb_allocation *ddb, /* out */
 +			       struct skl_pipe_wm *pipe_wm /* out */)
  {
 -	struct intel_crtc *intel_crtc = to_intel_crtc(cstate->crtc);
 -	struct intel_crtc_state *intel_cstate = to_intel_crtc_state(cstate);
 -	int ret;
 +	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
  
 -	ret = skl_build_pipe_wm(intel_cstate, ddb, pipe_wm);
 -	if (ret)
 -		return ret;
 +	skl_compute_wm_pipe_parameters(crtc, params);
 +	skl_allocate_pipe_ddb(crtc, config, params, ddb);
 +	skl_compute_pipe_wm(crtc, ddb, params, pipe_wm);
  
 -	if (!memcmp(&intel_crtc->wm.active.skl, pipe_wm, sizeof(*pipe_wm)))
 -		*changed = false;
 -	else
 -		*changed = true;
 +	if (!memcmp(&intel_crtc->wm.skl_active, pipe_wm, sizeof(*pipe_wm)))
 +		return false;
  
 -	return 0;
 +	intel_crtc->wm.skl_active = *pipe_wm;
 +	return true;
  }
  
 -static uint32_t
 -pipes_modified(struct drm_atomic_state *state)
 +static void skl_update_other_pipe_wm(struct drm_device *dev,
 +				     struct drm_crtc *crtc,
 +				     struct intel_wm_config *config,
 +				     struct skl_wm_values *r)
  {
 -	struct drm_crtc *crtc;
 -	struct drm_crtc_state *cstate;
 -	uint32_t i, ret = 0;
 -
 -	for_each_crtc_in_state(state, crtc, cstate, i)
 -		ret |= drm_crtc_mask(crtc);
 -
 -	return ret;
 -}
 -
 -static int
 -skl_compute_ddb(struct drm_atomic_state *state)
 -{
 -	struct drm_device *dev = state->dev;
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -	struct intel_atomic_state *intel_state = to_intel_atomic_state(state);
  	struct intel_crtc *intel_crtc;
 -	struct skl_ddb_allocation *ddb = &intel_state->wm_results.ddb;
 -	uint32_t realloc_pipes = pipes_modified(state);
 -	int ret;
 +	struct intel_crtc *this_crtc = to_intel_crtc(crtc);
  
  	/*
 -	 * If this is our first atomic update following hardware readout,
 -	 * we can't trust the DDB that the BIOS programmed for us.  Let's
 -	 * pretend that all pipes switched active status so that we'll
 -	 * ensure a full DDB recompute.
 +	 * If the WM update hasn't changed the allocation for this_crtc (the
 +	 * crtc we are currently computing the new WM values for), other
 +	 * enabled crtcs will keep the same allocation and we don't need to
 +	 * recompute anything for them.
  	 */
 -	if (dev_priv->wm.distrust_bios_wm) {
 -		ret = drm_modeset_lock(&dev->mode_config.connection_mutex,
 -				       state->acquire_ctx);
 -		if (ret)
 -			return ret;
 -
 -		intel_state->active_pipe_changes = ~0;
 -
 -		/*
 -		 * We usually only initialize intel_state->active_crtcs if we
 -		 * we're doing a modeset; make sure this field is always
 -		 * initialized during the sanitization process that happens
 -		 * on the first commit too.
 -		 */
 -		if (!intel_state->modeset)
 -			intel_state->active_crtcs = dev_priv->active_crtcs;
 -	}
 +	if (!skl_ddb_allocation_changed(&r->ddb, this_crtc))
 +		return;
  
  	/*
 -	 * If the modeset changes which CRTC's are active, we need to
 -	 * recompute the DDB allocation for *all* active pipes, even
 -	 * those that weren't otherwise being modified in any way by this
 -	 * atomic commit.  Due to the shrinking of the per-pipe allocations
 -	 * when new active CRTC's are added, it's possible for a pipe that
 -	 * we were already using and aren't changing at all here to suddenly
 -	 * become invalid if its DDB needs exceeds its new allocation.
 -	 *
 -	 * Note that if we wind up doing a full DDB recompute, we can't let
 -	 * any other display updates race with this transaction, so we need
 -	 * to grab the lock on *all* CRTC's.
 +	 * Otherwise, because of this_crtc being freshly enabled/disabled, the
 +	 * other active pipes need new DDB allocation and WM values.
  	 */
 -	if (intel_state->active_pipe_changes) {
 -		realloc_pipes = ~0;
 -		intel_state->wm_results.dirty_pipes = ~0;
 -	}
 -
 +	list_for_each_entry(intel_crtc, &dev->mode_config.crtc_list,
 +				base.head) {
 +		struct skl_pipe_wm_parameters params = {};
 +		struct skl_pipe_wm pipe_wm = {};
 +		bool wm_changed;
 +
++<<<<<<< HEAD
 +		if (this_crtc->pipe == intel_crtc->pipe)
++=======
+ 	for_each_intel_crtc_mask(dev, intel_crtc, realloc_pipes) {
+ 		struct intel_crtc_state *cstate;
+ 
+ 		cstate = intel_atomic_get_crtc_state(state, intel_crtc);
+ 		if (IS_ERR(cstate))
+ 			return PTR_ERR(cstate);
+ 
+ 		ret = skl_allocate_pipe_ddb(cstate, ddb);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void
+ skl_copy_wm_for_pipe(struct skl_wm_values *dst,
+ 		     struct skl_wm_values *src,
+ 		     enum pipe pipe)
+ {
+ 	dst->wm_linetime[pipe] = src->wm_linetime[pipe];
+ 	memcpy(dst->plane[pipe], src->plane[pipe],
+ 	       sizeof(dst->plane[pipe]));
+ 	memcpy(dst->plane_trans[pipe], src->plane_trans[pipe],
+ 	       sizeof(dst->plane_trans[pipe]));
+ 
+ 	dst->ddb.pipe[pipe] = src->ddb.pipe[pipe];
+ 	memcpy(dst->ddb.y_plane[pipe], src->ddb.y_plane[pipe],
+ 	       sizeof(dst->ddb.y_plane[pipe]));
+ 	memcpy(dst->ddb.plane[pipe], src->ddb.plane[pipe],
+ 	       sizeof(dst->ddb.plane[pipe]));
+ }
+ 
+ static int
+ skl_compute_wm(struct drm_atomic_state *state)
+ {
+ 	struct drm_crtc *crtc;
+ 	struct drm_crtc_state *cstate;
+ 	struct intel_atomic_state *intel_state = to_intel_atomic_state(state);
+ 	struct skl_wm_values *results = &intel_state->wm_results;
+ 	struct skl_pipe_wm *pipe_wm;
+ 	bool changed = false;
+ 	int ret, i;
+ 
+ 	/*
+ 	 * If this transaction isn't actually touching any CRTC's, don't
+ 	 * bother with watermark calculation.  Note that if we pass this
+ 	 * test, we're guaranteed to hold at least one CRTC state mutex,
+ 	 * which means we can safely use values like dev_priv->active_crtcs
+ 	 * since any racing commits that want to update them would need to
+ 	 * hold _all_ CRTC state mutexes.
+ 	 */
+ 	for_each_crtc_in_state(state, crtc, cstate, i)
+ 		changed = true;
+ 	if (!changed)
+ 		return 0;
+ 
+ 	/* Clear all dirty flags */
+ 	results->dirty_pipes = 0;
+ 
+ 	ret = skl_compute_ddb(state);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/*
+ 	 * Calculate WM's for all pipes that are part of this transaction.
+ 	 * Note that the DDB allocation above may have added more CRTC's that
+ 	 * weren't otherwise being modified (and set bits in dirty_pipes) if
+ 	 * pipe allocations had to change.
+ 	 *
+ 	 * FIXME:  Now that we're doing this in the atomic check phase, we
+ 	 * should allow skl_update_pipe_wm() to return failure in cases where
+ 	 * no suitable watermark values can be found.
+ 	 */
+ 	for_each_crtc_in_state(state, crtc, cstate, i) {
+ 		struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
+ 		struct intel_crtc_state *intel_cstate =
+ 			to_intel_crtc_state(cstate);
+ 
+ 		pipe_wm = &intel_cstate->wm.skl.optimal;
+ 		ret = skl_update_pipe_wm(cstate, &results->ddb, pipe_wm,
+ 					 &changed);
+ 		if (ret)
+ 			return ret;
+ 
+ 		if (changed)
+ 			results->dirty_pipes |= drm_crtc_mask(crtc);
+ 
+ 		if ((results->dirty_pipes & drm_crtc_mask(crtc)) == 0)
+ 			/* This pipe's WM's did not change */
++>>>>>>> 2722efb90b34 (drm/i915/gen9: Only copy WM results for changed pipes to skl_hw)
  			continue;
  
 -		intel_cstate->update_wm_pre = true;
 -		skl_compute_wm_results(crtc->dev, pipe_wm, results, intel_crtc);
 -	}
 +		if (!intel_crtc->active)
 +			continue;
  
 -	return 0;
 +		wm_changed = skl_update_pipe_wm(&intel_crtc->base,
 +						&params, config,
 +						&r->ddb, &pipe_wm);
 +
 +		/*
 +		 * If we end up re-computing the other pipe WM values, it's
 +		 * because it was really needed, so we expect the WM values to
 +		 * be different.
 +		 */
 +		WARN_ON(!wm_changed);
 +
 +		skl_compute_wm_results(dev, &params, &pipe_wm, r, intel_crtc);
 +		r->dirty[intel_crtc->pipe] = true;
 +	}
  }
  
  static void skl_update_wm(struct drm_crtc *crtc)
  {
  	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
  	struct drm_device *dev = crtc->dev;
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 +	struct drm_i915_private *dev_priv = dev->dev_private;
 +	struct skl_pipe_wm_parameters params = {};
  	struct skl_wm_values *results = &dev_priv->wm.skl_results;
++<<<<<<< HEAD
 +	struct skl_pipe_wm pipe_wm = {};
 +	struct intel_wm_config config = {};
++=======
+ 	struct skl_wm_values *hw_vals = &dev_priv->wm.skl_hw;
+ 	struct intel_crtc_state *cstate = to_intel_crtc_state(crtc->state);
+ 	struct skl_pipe_wm *pipe_wm = &cstate->wm.skl.optimal;
+ 	int pipe;
++>>>>>>> 2722efb90b34 (drm/i915/gen9: Only copy WM results for changed pipes to skl_hw)
  
 -	if ((results->dirty_pipes & drm_crtc_mask(crtc)) == 0)
 -		return;
 +	memset(results, 0, sizeof(*results));
  
 -	intel_crtc->wm.active.skl = *pipe_wm;
 +	skl_compute_wm_global_parameters(dev, &config);
  
 -	mutex_lock(&dev_priv->wm.wm_mutex);
 +	if (!skl_update_pipe_wm(crtc, &params, &config,
 +				&results->ddb, &pipe_wm))
 +		return;
 +
 +	skl_compute_wm_results(dev, &params, &pipe_wm, results, intel_crtc);
 +	results->dirty[intel_crtc->pipe] = true;
  
 +	skl_update_other_pipe_wm(dev, crtc, &config, results);
  	skl_write_wm_values(dev_priv, results);
  	skl_flush_wm_values(dev_priv, results);
  
++<<<<<<< HEAD
 +	/* store the new configuration */
 +	dev_priv->wm.skl_hw = *results;
++=======
+ 	/*
+ 	 * Store the new configuration (but only for the pipes that have
+ 	 * changed; the other values weren't recomputed).
+ 	 */
+ 	for_each_pipe_masked(dev_priv, pipe, results->dirty_pipes)
+ 		skl_copy_wm_for_pipe(hw_vals, results, pipe);
+ 
+ 	mutex_unlock(&dev_priv->wm.wm_mutex);
++>>>>>>> 2722efb90b34 (drm/i915/gen9: Only copy WM results for changed pipes to skl_hw)
  }
  
 -static void ilk_compute_wm_config(struct drm_device *dev,
 -				  struct intel_wm_config *config)
 -{
 -	struct intel_crtc *crtc;
 -
 -	/* Compute the currently _active_ config */
 -	for_each_intel_crtc(dev, crtc) {
 -		const struct intel_pipe_wm *wm = &crtc->wm.active.ilk;
 -
 -		if (!wm->pipe_enabled)
 -			continue;
 +static void
 +skl_update_sprite_wm(struct drm_plane *plane, struct drm_crtc *crtc,
 +		     uint32_t sprite_width, uint32_t sprite_height,
 +		     int pixel_size, bool enabled, bool scaled)
 +{
 +	struct intel_plane *intel_plane = to_intel_plane(plane);
 +	struct drm_framebuffer *fb = plane->state->fb;
 +
 +	intel_plane->wm.enabled = enabled;
 +	intel_plane->wm.scaled = scaled;
 +	intel_plane->wm.horiz_pixels = sprite_width;
 +	intel_plane->wm.vert_pixels = sprite_height;
 +	intel_plane->wm.bytes_per_pixel = pixel_size;
 +	intel_plane->wm.tiling = DRM_FORMAT_MOD_NONE;
 +	/*
 +	 * Framebuffer can be NULL on plane disable, but it does not
 +	 * matter for watermarks if we assume no tiling in that case.
 +	 */
 +	if (fb)
 +		intel_plane->wm.tiling = fb->modifier[0];
 +	intel_plane->wm.rotation = plane->state->rotation;
  
 -		config->sprites_enabled |= wm->sprites_enabled;
 -		config->sprites_scaled |= wm->sprites_scaled;
 -		config->num_pipes_active++;
 -	}
 +	skl_update_wm(crtc);
  }
  
 -static void ilk_program_watermarks(struct drm_i915_private *dev_priv)
 +static void ilk_update_wm(struct drm_crtc *crtc)
  {
 -	struct drm_device *dev = &dev_priv->drm;
 -	struct intel_pipe_wm lp_wm_1_2 = {}, lp_wm_5_6 = {}, *best_lp_wm;
 +	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 +	struct drm_device *dev = crtc->dev;
 +	struct drm_i915_private *dev_priv = dev->dev_private;
  	struct ilk_wm_maximums max;
 -	struct intel_wm_config config = {};
 +	struct ilk_pipe_wm_parameters params = {};
  	struct ilk_wm_values results = {};
  	enum intel_ddb_partitioning partitioning;
 +	struct intel_pipe_wm pipe_wm = {};
 +	struct intel_pipe_wm lp_wm_1_2 = {}, lp_wm_5_6 = {}, *best_lp_wm;
 +	struct intel_wm_config config = {};
 +
 +	ilk_compute_wm_parameters(crtc, &params);
 +
 +	intel_compute_pipe_wm(crtc, &params, &pipe_wm);
 +
 +	if (!memcmp(&intel_crtc->wm.active, &pipe_wm, sizeof(pipe_wm)))
 +		return;
 +
 +	intel_crtc->wm.active = pipe_wm;
  
  	ilk_compute_wm_config(dev, &config);
  
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
