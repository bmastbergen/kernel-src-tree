ipv6: Fix fragment id assignment on LE arches.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] ipv6: Fix fragment id assignment on LE arches (Lance Richardson) [1283886]
Rebuild_FUZZ: 98.90%
commit-author Vlad Yasevich <vyasevich@gmail.com>
commit 51f30770e50eb787200f30a79105e2615b379334
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/51f30770.failed

Recent commit:
0508c07f5e0c94f38afd5434e8b2a55b84553077
Author: Vlad Yasevich <vyasevich@gmail.com>
Date:   Tue Feb 3 16:36:15 2015 -0500

    ipv6: Select fragment id during UFO segmentation if not set.

Introduced a bug on LE in how ipv6 fragment id is assigned.
This was cought by nightly sparce check:

Resolve the following sparce error:
 net/ipv6/output_core.c:57:38: sparse: incorrect type in assignment
 (different base types)
   net/ipv6/output_core.c:57:38:    expected restricted __be32
[usertype] ip6_frag_id
   net/ipv6/output_core.c:57:38:    got unsigned int [unsigned]
[assigned] [usertype] id

Fixes: 0508c07f5e0c9 (ipv6: Select fragment id during UFO segmentation if not set.)
	Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 51f30770e50eb787200f30a79105e2615b379334)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/output_core.c
diff --cc net/ipv6/output_core.c
index f55ca250c2c9,a86cf60f0ca6..000000000000
--- a/net/ipv6/output_core.c
+++ b/net/ipv6/output_core.c
@@@ -6,6 -6,57 +6,59 @@@
  #include <net/ipv6.h>
  #include <net/ip6_fib.h>
  #include <net/addrconf.h>
++<<<<<<< HEAD
++=======
+ #include <net/secure_seq.h>
+ 
+ u32 __ipv6_select_ident(u32 hashrnd, struct in6_addr *dst, struct in6_addr *src)
+ {
+ 	u32 hash, id;
+ 
+ 	hash = __ipv6_addr_jhash(dst, hashrnd);
+ 	hash = __ipv6_addr_jhash(src, hash);
+ 
+ 	/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,
+ 	 * set the hight order instead thus minimizing possible future
+ 	 * collisions.
+ 	 */
+ 	id = ip_idents_reserve(hash, 1);
+ 	if (unlikely(!id))
+ 		id = 1 << 31;
+ 
+ 	return id;
+ }
+ 
+ /* This function exists only for tap drivers that must support broken
+  * clients requesting UFO without specifying an IPv6 fragment ID.
+  *
+  * This is similar to ipv6_select_ident() but we use an independent hash
+  * seed to limit information leakage.
+  *
+  * The network header must be set before calling this.
+  */
+ void ipv6_proxy_select_ident(struct sk_buff *skb)
+ {
+ 	static u32 ip6_proxy_idents_hashrnd __read_mostly;
+ 	struct in6_addr buf[2];
+ 	struct in6_addr *addrs;
+ 	u32 id;
+ 
+ 	addrs = skb_header_pointer(skb,
+ 				   skb_network_offset(skb) +
+ 				   offsetof(struct ipv6hdr, saddr),
+ 				   sizeof(buf), buf);
+ 	if (!addrs)
+ 		return;
+ 
+ 	net_get_random_once(&ip6_proxy_idents_hashrnd,
+ 			    sizeof(ip6_proxy_idents_hashrnd));
+ 
+ 	id = __ipv6_select_ident(ip6_proxy_idents_hashrnd,
+ 				 &addrs[1], &addrs[0]);
+ 	skb_shinfo(skb)->ip6_frag_id = htonl(id);
+ }
+ EXPORT_SYMBOL_GPL(ipv6_proxy_select_ident);
++>>>>>>> 51f30770e50e (ipv6: Fix fragment id assignment on LE arches.)
  
  void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)
  {
* Unmerged path net/ipv6/output_core.c
