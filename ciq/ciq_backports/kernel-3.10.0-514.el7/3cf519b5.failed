nvme: merge nvme_dev_start, nvme_dev_resume and nvme_async_probe

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 3cf519b5a8d4d067e3de19736283c9414402d3a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3cf519b5.failed

And give the resulting function a sensible name.  This keeps all the
error handling in a single place and will allow for further improvements
to it.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 3cf519b5a8d4d067e3de19736283c9414402d3a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index f5099f908371,61cfff34c3b8..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -79,9 -84,10 +79,10 @@@ static wait_queue_head_t nvme_kthread_w
  
  static struct class *nvme_class;
  
 -static int __nvme_reset(struct nvme_dev *dev);
 +static void nvme_reset_failed_dev(struct work_struct *ws);
  static int nvme_reset(struct nvme_dev *dev);
  static int nvme_process_cq(struct nvme_queue *nvmeq);
+ static void nvme_dead_ctrl(struct nvme_dev *dev);
  
  struct async_cmd_info {
  	struct kthread_work work;
@@@ -2806,26 -2950,11 +2807,31 @@@ static const struct file_operations nvm
  	.compat_ioctl	= nvme_dev_ioctl,
  };
  
++<<<<<<< HEAD
 +static void nvme_set_irq_hints(struct nvme_dev *dev)
 +{
 +	struct nvme_queue *nvmeq;
 +	int i;
 +
 +	for (i = 0; i < dev->online_queues; i++) {
 +		nvmeq = dev->queues[i];
 +
 +		if (!nvmeq->tags || !(*nvmeq->tags))
 +			continue;
 +
 +		irq_set_affinity_hint(dev->entry[nvmeq->cq_vector].vector,
 +					blk_mq_tags_cpumask(*nvmeq->tags));
 +	}
 +}
 +
 +static int nvme_dev_start(struct nvme_dev *dev)
++=======
+ static void nvme_probe_work(struct work_struct *work)
++>>>>>>> 3cf519b5a8d4 (nvme: merge nvme_dev_start, nvme_dev_resume and nvme_async_probe)
  {
- 	int result;
+ 	struct nvme_dev *dev = container_of(work, struct nvme_dev, probe_work);
  	bool start_thread = false;
+ 	int result;
  
  	result = nvme_dev_map(dev);
  	if (result)
@@@ -2863,10 -2992,18 +2869,20 @@@
  	if (result)
  		goto free_tags;
  
 +	nvme_set_irq_hints(dev);
 +
  	dev->event_limit = 1;
- 	return result;
+ 
+ 	if (dev->online_queues < 2) {
+ 		dev_warn(dev->dev, "IO queues not created\n");
+ 		nvme_free_queues(dev, 1);
+ 		nvme_dev_remove(dev);
+ 	} else {
+ 		nvme_unfreeze_queues(dev);
+ 		nvme_dev_add(dev);
+ 	}
+ 
+ 	return;
  
   free_tags:
  	nvme_dev_remove_admin(dev);
@@@ -2892,37 -3031,9 +2910,40 @@@ static int nvme_remove_dead_ctrl(void *
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void nvme_remove_disks(struct work_struct *ws)
 +{
 +	struct nvme_dev *dev = container_of(ws, struct nvme_dev, reset_work);
 +
 +	nvme_free_queues(dev, 1);
 +	nvme_dev_remove(dev);
 +}
 +
 +static int nvme_dev_resume(struct nvme_dev *dev)
 +{
 +	int ret;
 +
 +	ret = nvme_dev_start(dev);
 +	if (ret)
 +		return ret;
 +	if (dev->online_queues < 2) {
 +		spin_lock(&dev_list_lock);
 +		PREPARE_WORK(&dev->reset_work, nvme_remove_disks);
 +		queue_work(nvme_workq, &dev->reset_work);
 +		spin_unlock(&dev_list_lock);
 +	} else {
 +		nvme_unfreeze_queues(dev);
 +		nvme_dev_add(dev);
 +		nvme_set_irq_hints(dev);
 +	}
 +	return 0;
 +}
 +
++=======
++>>>>>>> 3cf519b5a8d4 (nvme: merge nvme_dev_start, nvme_dev_resume and nvme_async_probe)
  static void nvme_dead_ctrl(struct nvme_dev *dev)
  {
 -	dev_warn(dev->dev, "Device failed to resume\n");
 +	dev_warn(&dev->pci_dev->dev, "Device failed to resume\n");
  	kref_get(&dev->kref);
  	if (IS_ERR(kthread_run(nvme_remove_dead_ctrl, dev, "nvme%d",
  						dev->instance))) {
* Unmerged path drivers/block/nvme-core.c
