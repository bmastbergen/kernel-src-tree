perf hists: Support filtering in hierarchy mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit 155e9afff77916931f615a394cef187b342530dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/155e9aff.failed

The hists__filter_hierarchy() function implements filtering in hierarchy
mode.  Now we have hist_entry__filter() so use it for entries in the
hierarchy.  It returns 3 kind of values.

A negative value means that it's not filtered by this type.  It marks
current entry as filtered tentatively so if a lower level entry removes
the filter it also removes the all parent so that we can find the entry
in the output.

Zero means it's filtered out by this type. A positive value means it's
not filtered so it removes the filter and shows in the output.  In these
cases, it moves to next entry since lower level entry won't match by
this type of filter anymore.  Thus all children will be filtered or not
together.

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Acked-by: Pekka Enberg <penberg@kernel.org>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1456326830-30456-7-git-send-email-namhyung@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 155e9afff77916931f615a394cef187b342530dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/hist.c
diff --cc tools/perf/util/hist.c
index e1380b8f8200,dbab977f3a44..000000000000
--- a/tools/perf/util/hist.c
+++ b/tools/perf/util/hist.c
@@@ -1428,6 -1666,94 +1449,97 @@@ void hists__filter_by_symbol(struct his
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void hists__filter_hierarchy(struct hists *hists, int type, const void *arg)
+ {
+ 	struct rb_node *nd;
+ 
+ 	hists->stats.nr_non_filtered_samples = 0;
+ 
+ 	hists__reset_filter_stats(hists);
+ 	hists__reset_col_len(hists);
+ 
+ 	nd = rb_first(&hists->entries);
+ 	while (nd) {
+ 		struct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);
+ 		int ret;
+ 
+ 		ret = hist_entry__filter(h, type, arg);
+ 
+ 		/*
+ 		 * case 1. non-matching type
+ 		 * zero out the period, set filter marker and move to child
+ 		 */
+ 		if (ret < 0) {
+ 			memset(&h->stat, 0, sizeof(h->stat));
+ 			h->filtered |= (1 << type);
+ 
+ 			nd = __rb_hierarchy_next(&h->rb_node, HMD_FORCE_CHILD);
+ 		}
+ 		/*
+ 		 * case 2. matched type (filter out)
+ 		 * set filter marker and move to next
+ 		 */
+ 		else if (ret == 1) {
+ 			h->filtered |= (1 << type);
+ 
+ 			nd = __rb_hierarchy_next(&h->rb_node, HMD_FORCE_SIBLING);
+ 		}
+ 		/*
+ 		 * case 3. ok (not filtered)
+ 		 * add period to hists and parents, erase the filter marker
+ 		 * and move to next sibling
+ 		 */
+ 		else {
+ 			hists__remove_entry_filter(hists, h, type);
+ 
+ 			nd = __rb_hierarchy_next(&h->rb_node, HMD_FORCE_SIBLING);
+ 		}
+ 	}
+ }
+ 
+ void hists__filter_by_thread(struct hists *hists)
+ {
+ 	if (symbol_conf.report_hierarchy)
+ 		hists__filter_hierarchy(hists, HIST_FILTER__THREAD,
+ 					hists->thread_filter);
+ 	else
+ 		hists__filter_by_type(hists, HIST_FILTER__THREAD,
+ 				      hists__filter_entry_by_thread);
+ }
+ 
+ void hists__filter_by_dso(struct hists *hists)
+ {
+ 	if (symbol_conf.report_hierarchy)
+ 		hists__filter_hierarchy(hists, HIST_FILTER__DSO,
+ 					hists->dso_filter);
+ 	else
+ 		hists__filter_by_type(hists, HIST_FILTER__DSO,
+ 				      hists__filter_entry_by_dso);
+ }
+ 
+ void hists__filter_by_symbol(struct hists *hists)
+ {
+ 	if (symbol_conf.report_hierarchy)
+ 		hists__filter_hierarchy(hists, HIST_FILTER__SYMBOL,
+ 					hists->symbol_filter_str);
+ 	else
+ 		hists__filter_by_type(hists, HIST_FILTER__SYMBOL,
+ 				      hists__filter_entry_by_symbol);
+ }
+ 
+ void hists__filter_by_socket(struct hists *hists)
+ {
+ 	if (symbol_conf.report_hierarchy)
+ 		hists__filter_hierarchy(hists, HIST_FILTER__SOCKET,
+ 					&hists->socket_filter);
+ 	else
+ 		hists__filter_by_type(hists, HIST_FILTER__SOCKET,
+ 				      hists__filter_entry_by_socket);
+ }
+ 
++>>>>>>> 155e9afff779 (perf hists: Support filtering in hierarchy mode)
  void events_stats__inc(struct events_stats *stats, u32 type)
  {
  	++stats->nr_events[0];
* Unmerged path tools/perf/util/hist.c
