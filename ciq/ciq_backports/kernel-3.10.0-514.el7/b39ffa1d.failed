IB/core: Add gid_type to gid attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matan Barak <matanb@mellanox.com>
commit b39ffa1df505378336a85064ad9ec403765bbb0b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b39ffa1d.failed

In order to support multiple GID types, we need to store the gid_type
with each GID. This is also aligned with the RoCE v2 annex "RoCEv2 PORT
GID table entries shall have a "GID type" attribute that denotes the L3
Address type". The currently supported GID is IB_GID_TYPE_IB which is
also RoCE v1 GID type.

This implies that gid_type should be added to roce_gid_table meta-data.

	Signed-off-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit b39ffa1df505378336a85064ad9ec403765bbb0b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cache.c
#	drivers/infiniband/core/cm.c
#	drivers/infiniband/core/cma.c
#	drivers/infiniband/core/device.c
#	drivers/infiniband/core/multicast.c
#	drivers/infiniband/core/sa_query.c
#	drivers/infiniband/core/uverbs_marshall.c
#	drivers/infiniband/core/verbs.c
#	include/rdma/ib_cache.h
#	include/rdma/ib_sa.h
#	include/rdma/ib_verbs.h
diff --cc drivers/infiniband/core/cache.c
index 77177fb6d68f,06e47e197fde..000000000000
--- a/drivers/infiniband/core/cache.c
+++ b/drivers/infiniband/core/cache.c
@@@ -125,6 -126,23 +126,26 @@@ static void dispatch_gid_change_event(s
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static const char * const gid_type_str[] = {
+ 	[IB_GID_TYPE_IB]	= "IB/RoCE v1",
+ };
+ 
+ const char *ib_cache_gid_type_str(enum ib_gid_type gid_type)
+ {
+ 	if (gid_type < ARRAY_SIZE(gid_type_str) && gid_type_str[gid_type])
+ 		return gid_type_str[gid_type];
+ 
+ 	return "Invalid GID type";
+ }
+ EXPORT_SYMBOL(ib_cache_gid_type_str);
+ 
+ /* This function expects that rwlock will be write locked in all
+  * scenarios and that lock will be locked in sleep-able (RoCE)
+  * scenarios.
+  */
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  static int write_gid(struct ib_device *ib_dev, u8 port,
  		     struct ib_gid_table *table, int ix,
  		     const union ib_gid *gid,
@@@ -208,24 -219,41 +229,28 @@@ static int del_gid(struct ib_device *ib
  			 GID_TABLE_WRITE_ACTION_DEL, default_gid);
  }
  
 -/* rwlock should be read locked */
  static int find_gid(struct ib_gid_table *table, const union ib_gid *gid,
  		    const struct ib_gid_attr *val, bool default_gid,
 -		    unsigned long mask, int *pempty)
 +		    unsigned long mask)
  {
 -	int i = 0;
 -	int found = -1;
 -	int empty = pempty ? -1 : 0;
 -
 -	while (i < table->sz && (found < 0 || empty < 0)) {
 -		struct ib_gid_table_entry *data = &table->data_vec[i];
 -		struct ib_gid_attr *attr = &data->attr;
 -		int curr_index = i;
 -
 -		i++;
 +	int i;
  
 -		if (data->props & GID_TABLE_ENTRY_INVALID)
 -			continue;
 +	for (i = 0; i < table->sz; i++) {
 +		unsigned long flags;
 +		struct ib_gid_attr *attr = &table->data_vec[i].attr;
  
 -		if (empty < 0)
 -			if (!memcmp(&data->gid, &zgid, sizeof(*gid)) &&
 -			    !memcmp(attr, &zattr, sizeof(*attr)) &&
 -			    !data->props)
 -				empty = curr_index;
 +		read_lock_irqsave(&table->data_vec[i].lock, flags);
  
 -		if (found >= 0)
 -			continue;
 +		if (table->data_vec[i].props & GID_TABLE_ENTRY_INVALID)
 +			goto next;
  
+ 		if (mask & GID_ATTR_FIND_MASK_GID_TYPE &&
+ 		    attr->gid_type != val->gid_type)
+ 			continue;
+ 
  		if (mask & GID_ATTR_FIND_MASK_GID &&
 -		    memcmp(gid, &data->gid, sizeof(*gid)))
 -			continue;
 +		    memcmp(gid, &table->data_vec[i].gid, sizeof(*gid)))
 +			goto next;
  
  		if (mask & GID_ATTR_FIND_MASK_NETDEV &&
  		    attr->ndev != val->ndev)
@@@ -282,9 -311,11 +307,14 @@@ int ib_cache_gid_add(struct ib_device *
  	}
  
  	mutex_lock(&table->lock);
 -	write_lock_irq(&table->rwlock);
  
  	ix = find_gid(table, gid, attr, false, GID_ATTR_FIND_MASK_GID |
++<<<<<<< HEAD
 +		      GID_ATTR_FIND_MASK_NETDEV);
++=======
+ 		      GID_ATTR_FIND_MASK_GID_TYPE |
+ 		      GID_ATTR_FIND_MASK_NETDEV, &empty);
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  	if (ix >= 0)
  		goto out_unlock;
  
@@@ -315,8 -347,11 +345,9 @@@ int ib_cache_gid_del(struct ib_device *
  
  	ix = find_gid(table, gid, attr, false,
  		      GID_ATTR_FIND_MASK_GID	  |
+ 		      GID_ATTR_FIND_MASK_GID_TYPE |
  		      GID_ATTR_FIND_MASK_NETDEV	  |
 -		      GID_ATTR_FIND_MASK_DEFAULT,
 -		      NULL);
 +		      GID_ATTR_FIND_MASK_DEFAULT);
  	if (ix < 0)
  		goto out_unlock;
  
@@@ -416,16 -462,19 +449,31 @@@ static int ib_cache_gid_find(struct ib_
  					mask, port, index);
  }
  
++<<<<<<< HEAD
 +int ib_cache_gid_find_by_port(struct ib_device *ib_dev,
 +			      const union ib_gid *gid,
 +			      u8 port, struct net_device *ndev,
 +			      u16 *index)
++=======
+ int ib_find_cached_gid_by_port(struct ib_device *ib_dev,
+ 			       const union ib_gid *gid,
+ 			       enum ib_gid_type gid_type,
+ 			       u8 port, struct net_device *ndev,
+ 			       u16 *index)
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  {
  	int local_index;
  	struct ib_gid_table **ports_table = ib_dev->cache.gid_cache;
  	struct ib_gid_table *table;
++<<<<<<< HEAD
 +	unsigned long mask = GID_ATTR_FIND_MASK_GID;
 +	struct ib_gid_attr val = {.ndev = ndev};
++=======
+ 	unsigned long mask = GID_ATTR_FIND_MASK_GID |
+ 			     GID_ATTR_FIND_MASK_GID_TYPE;
+ 	struct ib_gid_attr val = {.ndev = ndev, .gid_type = gid_type};
+ 	unsigned long flags;
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  
  	if (port < rdma_start_port(ib_dev) ||
  	    port > rdma_end_port(ib_dev))
@@@ -515,37 -647,61 +563,87 @@@ void ib_cache_gid_set_default_gid(struc
  	memset(&gid_attr, 0, sizeof(gid_attr));
  	gid_attr.ndev = ndev;
  
++<<<<<<< HEAD
 +	mutex_lock(&table->lock);
 +	ix = find_gid(table, NULL, NULL, true, GID_ATTR_FIND_MASK_DEFAULT);
++=======
+ 	for (gid_type = 0; gid_type < IB_GID_TYPE_SIZE; ++gid_type) {
+ 		int ix;
+ 		union ib_gid current_gid;
+ 		struct ib_gid_attr current_gid_attr = {};
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  
- 	/* Coudn't find default GID location */
- 	WARN_ON(ix < 0);
+ 		if (1UL << gid_type & ~gid_type_mask)
+ 			continue;
  
- 	if (!__ib_cache_gid_get(ib_dev, port, ix,
- 				&current_gid, &current_gid_attr) &&
- 	    mode == IB_CACHE_GID_DEFAULT_MODE_SET &&
- 	    !memcmp(&gid, &current_gid, sizeof(gid)) &&
- 	    !memcmp(&gid_attr, &current_gid_attr, sizeof(gid_attr)))
- 		goto unlock;
+ 		gid_attr.gid_type = gid_type;
  
++<<<<<<< HEAD
 +	if ((memcmp(&current_gid, &zgid, sizeof(current_gid)) ||
 +	     memcmp(&current_gid_attr, &zattr,
 +		    sizeof(current_gid_attr))) &&
 +	    del_gid(ib_dev, port, table, ix, true)) {
 +		pr_warn("ib_cache_gid: can't delete index %d for default gid %pI6\n",
 +			ix, gid.raw);
 +		goto unlock;
 +	}
 +
 +	if (mode == IB_CACHE_GID_DEFAULT_MODE_SET)
 +		if (add_gid(ib_dev, port, table, ix, &gid, &gid_attr, true))
 +			pr_warn("ib_cache_gid: unable to add default gid %pI6\n",
 +				gid.raw);
 +
 +unlock:
 +	if (current_gid_attr.ndev)
 +		dev_put(current_gid_attr.ndev);
 +	mutex_unlock(&table->lock);
++=======
+ 		mutex_lock(&table->lock);
+ 		write_lock_irq(&table->rwlock);
+ 		ix = find_gid(table, NULL, &gid_attr, true,
+ 			      GID_ATTR_FIND_MASK_GID_TYPE |
+ 			      GID_ATTR_FIND_MASK_DEFAULT,
+ 			      NULL);
+ 
+ 		/* Coudn't find default GID location */
+ 		WARN_ON(ix < 0);
+ 
+ 		zattr_type.gid_type = gid_type;
+ 
+ 		if (!__ib_cache_gid_get(ib_dev, port, ix,
+ 					&current_gid, &current_gid_attr) &&
+ 		    mode == IB_CACHE_GID_DEFAULT_MODE_SET &&
+ 		    !memcmp(&gid, &current_gid, sizeof(gid)) &&
+ 		    !memcmp(&gid_attr, &current_gid_attr, sizeof(gid_attr)))
+ 			goto release;
+ 
+ 		if (memcmp(&current_gid, &zgid, sizeof(current_gid)) ||
+ 		    memcmp(&current_gid_attr, &zattr_type,
+ 			   sizeof(current_gid_attr))) {
+ 			if (del_gid(ib_dev, port, table, ix, true)) {
+ 				pr_warn("ib_cache_gid: can't delete index %d for default gid %pI6\n",
+ 					ix, gid.raw);
+ 				goto release;
+ 			} else {
+ 				dispatch_gid_change_event(ib_dev, port);
+ 			}
+ 		}
+ 
+ 		if (mode == IB_CACHE_GID_DEFAULT_MODE_SET) {
+ 			if (add_gid(ib_dev, port, table, ix, &gid, &gid_attr, true))
+ 				pr_warn("ib_cache_gid: unable to add default gid %pI6\n",
+ 					gid.raw);
+ 			else
+ 				dispatch_gid_change_event(ib_dev, port);
+ 		}
+ 
+ release:
+ 		if (current_gid_attr.ndev)
+ 			dev_put(current_gid_attr.ndev);
+ 		write_unlock_irq(&table->rwlock);
+ 		mutex_unlock(&table->lock);
+ 	}
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  }
  
  static int gid_table_reserve_default(struct ib_device *ib_dev, u8 port,
@@@ -667,10 -845,12 +777,19 @@@ EXPORT_SYMBOL(ib_get_cached_gid)
  
  int ib_find_cached_gid(struct ib_device *device,
  		       const union ib_gid *gid,
++<<<<<<< HEAD
 +		       u8               *port_num,
 +		       u16              *index)
 +{
 +	return ib_cache_gid_find(device, gid, NULL, port_num, index);
++=======
+ 		       enum ib_gid_type gid_type,
+ 		       struct net_device *ndev,
+ 		       u8               *port_num,
+ 		       u16              *index)
+ {
+ 	return ib_cache_gid_find(device, gid, gid_type, ndev, port_num, index);
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  }
  EXPORT_SYMBOL(ib_find_cached_gid);
  
diff --cc drivers/infiniband/core/cm.c
index d070930aadb5,d93b82fbc25b..000000000000
--- a/drivers/infiniband/core/cm.c
+++ b/drivers/infiniband/core/cm.c
@@@ -363,7 -364,7 +363,11 @@@ static int cm_init_av_by_path(struct ib
  	read_lock_irqsave(&cm.device_lock, flags);
  	list_for_each_entry(cm_dev, &cm.device_list, list) {
  		if (!ib_find_cached_gid(cm_dev->ib_device, &path->sgid,
++<<<<<<< HEAD
 +					&p, NULL)) {
++=======
+ 					IB_GID_TYPE_IB, ndev, &p, NULL)) {
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  			port = cm_dev->port[p-1];
  			break;
  		}
diff --cc drivers/infiniband/core/cma.c
index 1487f99e0916,2637ebfd1784..000000000000
--- a/drivers/infiniband/core/cma.c
+++ b/drivers/infiniband/core/cma.c
@@@ -452,9 -453,14 +452,20 @@@ static inline int cma_validate_port(str
  	if ((dev_type != ARPHRD_INFINIBAND) && rdma_protocol_ib(device, port))
  		return ret;
  
++<<<<<<< HEAD
 +	ret = ib_find_cached_gid(device, gid, &found_port, NULL);
 +	if (port != found_port)
 +		return -ENODEV;
++=======
+ 	if (dev_type == ARPHRD_ETHER)
+ 		ndev = dev_get_by_index(&init_net, bound_if_index);
+ 
+ 	ret = ib_find_cached_gid_by_port(device, gid, IB_GID_TYPE_IB, port,
+ 					 ndev, NULL);
+ 
+ 	if (ndev)
+ 		dev_put(ndev);
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  
  	return ret;
  }
diff --cc drivers/infiniband/core/device.c
index a9d577fd9178,00da80e02154..000000000000
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@@ -809,11 -815,14 +809,20 @@@ EXPORT_SYMBOL(ib_modify_port)
   *   a specified GID value occurs.
   * @device: The device to query.
   * @gid: The GID value to search for.
++<<<<<<< HEAD
++=======
+  * @gid_type: Type of GID.
+  * @ndev: The ndev related to the GID to search for.
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
   * @port_num: The port number of the device where the GID value was found.
   * @index: The index into the GID table where the GID was found.  This
   *   parameter may be NULL.
   */
  int ib_find_gid(struct ib_device *device, union ib_gid *gid,
++<<<<<<< HEAD
++=======
+ 		enum ib_gid_type gid_type, struct net_device *ndev,
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  		u8 *port_num, u16 *index)
  {
  	union ib_gid tmp_gid;
@@@ -821,15 -830,18 +830,23 @@@
  
  	for (port = rdma_start_port(device); port <= rdma_end_port(device); ++port) {
  		if (rdma_cap_roce_gid_table(device, port)) {
++<<<<<<< HEAD
 +			if (!ib_cache_gid_find_by_port(device, gid, port,
 +						       NULL, index)) {
++=======
+ 			if (!ib_find_cached_gid_by_port(device, gid, gid_type, port,
+ 							ndev, index)) {
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  				*port_num = port;
  				return 0;
  			}
  		}
  
+ 		if (gid_type != IB_GID_TYPE_IB)
+ 			continue;
+ 
  		for (i = 0; i < device->port_immutable[port].gid_tbl_len; ++i) {
 -			ret = ib_query_gid(device, port, i, &tmp_gid, NULL);
 +			ret = ib_query_gid(device, port, i, &tmp_gid);
  			if (ret)
  				return ret;
  			if (!memcmp(&tmp_gid, gid, sizeof *gid)) {
diff --cc drivers/infiniband/core/multicast.c
index d38d8b2b2979,6911ae68e8d8..000000000000
--- a/drivers/infiniband/core/multicast.c
+++ b/drivers/infiniband/core/multicast.c
@@@ -729,7 -729,8 +729,12 @@@ int ib_init_ah_from_mcmember(struct ib_
  	u16 gid_index;
  	u8 p;
  
++<<<<<<< HEAD
 +	ret = ib_find_cached_gid(device, &rec->port_gid, &p, &gid_index);
++=======
+ 	ret = ib_find_cached_gid(device, &rec->port_gid, IB_GID_TYPE_IB,
+ 				 NULL, &p, &gid_index);
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  	if (ret)
  		return ret;
  
diff --cc drivers/infiniband/core/sa_query.c
index 6ecb693c496b,270faaa2810f..000000000000
--- a/drivers/infiniband/core/sa_query.c
+++ b/drivers/infiniband/core/sa_query.c
@@@ -1012,10 -1012,15 +1012,18 @@@ int ib_init_ah_from_path(struct ib_devi
  		ah_attr->ah_flags = IB_AH_GRH;
  		ah_attr->grh.dgid = rec->dgid;
  
++<<<<<<< HEAD
 +		ret = ib_find_cached_gid(device, &rec->sgid, &port_num,
 +					 &gid_index);
 +		if (ret)
++=======
+ 		ret = ib_find_cached_gid(device, &rec->sgid, rec->gid_type, ndev,
+ 					 &port_num, &gid_index);
+ 		if (ret) {
+ 			if (ndev)
+ 				dev_put(ndev);
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  			return ret;
 -		}
  
  		ah_attr->grh.sgid_index    = gid_index;
  		ah_attr->grh.flow_label    = be32_to_cpu(rec->flow_label);
@@@ -1148,9 -1155,10 +1156,15 @@@ static void ib_sa_path_rec_callback(str
  
  		ib_unpack(path_rec_table, ARRAY_SIZE(path_rec_table),
  			  mad->data, &rec);
++<<<<<<< HEAD
 +		rec.vlan_id = 0xffff;
++=======
+ 		rec.net = NULL;
+ 		rec.ifindex = 0;
+ 		rec.gid_type = IB_GID_TYPE_IB;
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  		memset(rec.dmac, 0, ETH_ALEN);
 +		memset(rec.smac, 0, ETH_ALEN);
  		query->callback(status, &rec, query->context);
  	} else
  		query->callback(status, NULL, query->context);
diff --cc drivers/infiniband/core/uverbs_marshall.c
index abd97247443e,af020f80d50f..000000000000
--- a/drivers/infiniband/core/uverbs_marshall.c
+++ b/drivers/infiniband/core/uverbs_marshall.c
@@@ -141,8 -141,9 +141,14 @@@ void ib_copy_path_rec_from_user(struct 
  	dst->preference		= src->preference;
  	dst->packet_life_time_selector = src->packet_life_time_selector;
  
 +	memset(dst->smac, 0, sizeof(dst->smac));
  	memset(dst->dmac, 0, sizeof(dst->dmac));
++<<<<<<< HEAD
 +	dst->vlan_id = 0xffff;
++=======
+ 	dst->net = NULL;
+ 	dst->ifindex = 0;
+ 	dst->gid_type = IB_GID_TYPE_IB;
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  }
  EXPORT_SYMBOL(ib_copy_path_rec_from_user);
diff --cc drivers/infiniband/core/verbs.c
index 5fbf767fb963,e397d8bb4bde..000000000000
--- a/drivers/infiniband/core/verbs.c
+++ b/drivers/infiniband/core/verbs.c
@@@ -338,10 -379,14 +338,21 @@@ int ib_init_ah_from_wc(struct ib_devic
  		ah_attr->ah_flags = IB_AH_GRH;
  		ah_attr->grh.dgid = grh->sgid;
  
++<<<<<<< HEAD
 +		ret = ib_find_cached_gid(device, &grh->dgid, &port_num,
 +					 &gid_index);
 +		if (ret)
 +			return ret;
++=======
+ 		if (!rdma_cap_eth_ah(device, port_num)) {
+ 			ret = ib_find_cached_gid_by_port(device, &grh->dgid,
+ 							 IB_GID_TYPE_IB,
+ 							 port_num, NULL,
+ 							 &gid_index);
+ 			if (ret)
+ 				return ret;
+ 		}
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  
  		ah_attr->grh.sgid_index = (u8) gid_index;
  		flow_class = be32_to_cpu(grh->version_tclass_flow);
diff --cc include/rdma/ib_cache.h
index bd92130f4ac5,e30f19bd4a41..000000000000
--- a/include/rdma/ib_cache.h
+++ b/include/rdma/ib_cache.h
@@@ -57,6 -60,8 +57,11 @@@ int ib_get_cached_gid(struct ib_devic
   *   a specified GID value occurs.
   * @device: The device to query.
   * @gid: The GID value to search for.
++<<<<<<< HEAD
++=======
+  * @gid_type: The GID type to search for.
+  * @ndev: In RoCE, the net device of the device. NULL means ignore.
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
   * @port_num: The port number of the device where the GID value was found.
   * @index: The index into the cached GID table where the GID was found.  This
   *   parameter may be NULL.
@@@ -64,12 -69,43 +69,50 @@@
   * ib_find_cached_gid() searches for the specified GID value in
   * the local software cache.
   */
 -int ib_find_cached_gid(struct ib_device *device,
 +int ib_find_cached_gid(struct ib_device   *device,
  		       const union ib_gid *gid,
++<<<<<<< HEAD
 +		       u8                 *port_num,
 +		       u16                *index);
 +
 +/**
++=======
+ 		       enum ib_gid_type gid_type,
+ 		       struct net_device *ndev,
+ 		       u8               *port_num,
+ 		       u16              *index);
+ 
+ /**
+  * ib_find_cached_gid_by_port - Returns the GID table index where a specified
+  * GID value occurs
+  * @device: The device to query.
+  * @gid: The GID value to search for.
+  * @gid_type: The GID type to search for.
+  * @port_num: The port number of the device where the GID value sould be
+  *   searched.
+  * @ndev: In RoCE, the net device of the device. Null means ignore.
+  * @index: The index into the cached GID table where the GID was found.  This
+  *   parameter may be NULL.
+  *
+  * ib_find_cached_gid() searches for the specified GID value in
+  * the local software cache.
+  */
+ int ib_find_cached_gid_by_port(struct ib_device *device,
+ 			       const union ib_gid *gid,
+ 			       enum ib_gid_type gid_type,
+ 			       u8               port_num,
+ 			       struct net_device *ndev,
+ 			       u16              *index);
+ 
+ int ib_find_gid_by_filter(struct ib_device *device,
+ 			  const union ib_gid *gid,
+ 			  u8 port_num,
+ 			  bool (*filter)(const union ib_gid *gid,
+ 					 const struct ib_gid_attr *,
+ 					 void *),
+ 			  void *context, u16 *index);
+ /**
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
   * ib_get_cached_pkey - Returns a cached PKey table entry
   * @device: The device to query.
   * @port_num: The port number of the device to query.
diff --cc include/rdma/ib_sa.h
index 7e071a6abb34,0a40ed241156..000000000000
--- a/include/rdma/ib_sa.h
+++ b/include/rdma/ib_sa.h
@@@ -154,11 -155,19 +154,19 @@@ struct ib_sa_path_rec 
  	u8           packet_life_time_selector;
  	u8           packet_life_time;
  	u8           preference;
 +	u8           smac[ETH_ALEN];
  	u8           dmac[ETH_ALEN];
++<<<<<<< HEAD
 +	u16	     vlan_id;
++=======
+ 	/* ignored in IB */
+ 	int	     ifindex;
+ 	/* ignored in IB */
+ 	struct net  *net;
+ 	enum ib_gid_type gid_type;
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  };
  
 -static inline struct net_device *ib_get_ndev_from_path(struct ib_sa_path_rec *rec)
 -{
 -	return rec->net ? dev_get_by_index(rec->net, rec->ifindex) : NULL;
 -}
 -
  #define IB_SA_MCMEMBER_REC_MGID				IB_SA_COMP_MASK( 0)
  #define IB_SA_MCMEMBER_REC_PORT_GID			IB_SA_COMP_MASK( 1)
  #define IB_SA_MCMEMBER_REC_QKEY				IB_SA_COMP_MASK( 2)
diff --cc include/rdma/ib_verbs.h
index 95d565250d0a,00d2006ad816..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -2212,6 -2253,7 +2220,10 @@@ int ib_modify_port(struct ib_device *de
  		   struct ib_port_modify *port_modify);
  
  int ib_find_gid(struct ib_device *device, union ib_gid *gid,
++<<<<<<< HEAD
++=======
+ 		enum ib_gid_type gid_type, struct net_device *ndev,
++>>>>>>> b39ffa1df505 (IB/core: Add gid_type to gid attribute)
  		u8 *port_num, u16 *index);
  
  int ib_find_pkey(struct ib_device *device,
* Unmerged path drivers/infiniband/core/cache.c
* Unmerged path drivers/infiniband/core/cm.c
* Unmerged path drivers/infiniband/core/cma.c
diff --git a/drivers/infiniband/core/core_priv.h b/drivers/infiniband/core/core_priv.h
index 70bb36ebb03b..398d096d40e8 100644
--- a/drivers/infiniband/core/core_priv.h
+++ b/drivers/infiniband/core/core_priv.h
@@ -75,8 +75,11 @@ enum ib_cache_gid_default_mode {
 	IB_CACHE_GID_DEFAULT_MODE_DELETE
 };
 
+const char *ib_cache_gid_type_str(enum ib_gid_type gid_type);
+
 void ib_cache_gid_set_default_gid(struct ib_device *ib_dev, u8 port,
 				  struct net_device *ndev,
+				  unsigned long gid_type_mask,
 				  enum ib_cache_gid_default_mode mode);
 
 int ib_cache_gid_add(struct ib_device *ib_dev, u8 port,
@@ -92,6 +95,7 @@ int roce_gid_mgmt_init(void);
 void roce_gid_mgmt_cleanup(void);
 
 int roce_rescan_device(struct ib_device *ib_dev);
+unsigned long roce_gid_type_mask_support(struct ib_device *ib_dev, u8 port);
 
 int ib_cache_setup_one(struct ib_device *device);
 void ib_cache_cleanup_one(struct ib_device *device);
* Unmerged path drivers/infiniband/core/device.c
* Unmerged path drivers/infiniband/core/multicast.c
diff --git a/drivers/infiniband/core/roce_gid_mgmt.c b/drivers/infiniband/core/roce_gid_mgmt.c
index 154522c92174..a3381b6ade03 100644
--- a/drivers/infiniband/core/roce_gid_mgmt.c
+++ b/drivers/infiniband/core/roce_gid_mgmt.c
@@ -67,17 +67,52 @@ struct netdev_event_work {
 	struct netdev_event_work_cmd	cmds[ROCE_NETDEV_CALLBACK_SZ];
 };
 
+static const struct {
+	bool (*is_supported)(const struct ib_device *device, u8 port_num);
+	enum ib_gid_type gid_type;
+} PORT_CAP_TO_GID_TYPE[] = {
+	{rdma_protocol_roce,   IB_GID_TYPE_ROCE},
+};
+
+#define CAP_TO_GID_TABLE_SIZE	ARRAY_SIZE(PORT_CAP_TO_GID_TYPE)
+
+unsigned long roce_gid_type_mask_support(struct ib_device *ib_dev, u8 port)
+{
+	int i;
+	unsigned int ret_flags = 0;
+
+	if (!rdma_protocol_roce(ib_dev, port))
+		return 1UL << IB_GID_TYPE_IB;
+
+	for (i = 0; i < CAP_TO_GID_TABLE_SIZE; i++)
+		if (PORT_CAP_TO_GID_TYPE[i].is_supported(ib_dev, port))
+			ret_flags |= 1UL << PORT_CAP_TO_GID_TYPE[i].gid_type;
+
+	return ret_flags;
+}
+EXPORT_SYMBOL(roce_gid_type_mask_support);
+
 static void update_gid(enum gid_op_type gid_op, struct ib_device *ib_dev,
 		       u8 port, union ib_gid *gid,
 		       struct ib_gid_attr *gid_attr)
 {
-	switch (gid_op) {
-	case GID_ADD:
-		ib_cache_gid_add(ib_dev, port, gid, gid_attr);
-		break;
-	case GID_DEL:
-		ib_cache_gid_del(ib_dev, port, gid, gid_attr);
-		break;
+	int i;
+	unsigned long gid_type_mask = roce_gid_type_mask_support(ib_dev, port);
+
+	for (i = 0; i < IB_GID_TYPE_SIZE; i++) {
+		if ((1UL << i) & gid_type_mask) {
+			gid_attr->gid_type = i;
+			switch (gid_op) {
+			case GID_ADD:
+				ib_cache_gid_add(ib_dev, port,
+						 gid, gid_attr);
+				break;
+			case GID_DEL:
+				ib_cache_gid_del(ib_dev, port,
+						 gid, gid_attr);
+				break;
+			}
+		}
 	}
 }
 
@@ -203,6 +238,8 @@ static void enum_netdev_default_gids(struct ib_device *ib_dev,
 				     u8 port, struct net_device *event_ndev,
 				     struct net_device *rdma_ndev)
 {
+	unsigned long gid_type_mask;
+
 	rcu_read_lock();
 	if (!rdma_ndev ||
 	    ((rdma_ndev != event_ndev &&
@@ -215,7 +252,9 @@ static void enum_netdev_default_gids(struct ib_device *ib_dev,
 	}
 	rcu_read_unlock();
 
-	ib_cache_gid_set_default_gid(ib_dev, port, rdma_ndev,
+	gid_type_mask = roce_gid_type_mask_support(ib_dev, port);
+
+	ib_cache_gid_set_default_gid(ib_dev, port, rdma_ndev, gid_type_mask,
 				     IB_CACHE_GID_DEFAULT_MODE_SET);
 }
 
@@ -237,9 +276,14 @@ static void bond_delete_netdev_default_gids(struct ib_device *ib_dev,
 	if (is_upper_dev_rcu(rdma_ndev, event_ndev) &&
 	    is_eth_active_slave_of_bonding_rcu(rdma_ndev, real_dev) ==
 	    BONDING_SLAVE_STATE_INACTIVE) {
+		unsigned long gid_type_mask;
+
 		rcu_read_unlock();
 
+		gid_type_mask = roce_gid_type_mask_support(ib_dev, port);
+
 		ib_cache_gid_set_default_gid(ib_dev, port, rdma_ndev,
+					     gid_type_mask,
 					     IB_CACHE_GID_DEFAULT_MODE_DELETE);
 	} else {
 		rcu_read_unlock();
* Unmerged path drivers/infiniband/core/sa_query.c
* Unmerged path drivers/infiniband/core/uverbs_marshall.c
* Unmerged path drivers/infiniband/core/verbs.c
* Unmerged path include/rdma/ib_cache.h
* Unmerged path include/rdma/ib_sa.h
* Unmerged path include/rdma/ib_verbs.h
