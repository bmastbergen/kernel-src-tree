perf: Synchronously clean up child events

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit c6e5b73242d2d9172ea880483bc4ba7ffca0cfb2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c6e5b732.failed

The orphan cleanup workqueue doesn't always catch orphans, for example,
if they never schedule after they are orphaned. IOW, the event leak is
still very real. It also wouldn't work for kernel counters.

Doing it synchonously is a little hairy due to lock inversion issues,
but is made to work.

Patch based on work by Alexander Shishkin.

	Suggested-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
	Cc: vince@deater.net
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit c6e5b73242d2d9172ea880483bc4ba7ffca0cfb2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/perf_event.h
#	kernel/events/core.c
diff --cc include/linux/perf_event.h
index 41fd463bc411,b35a61a481fa..000000000000
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@@ -538,13 -632,8 +538,16 @@@ struct perf_event_context 
  	u64				generation;
  	int				pin_count;
  	int				nr_cgroups;	 /* cgroup evts */
 -	void				*task_ctx_data; /* pmu specific data */
 +	RH_KABI_DEPRECATE(int, nr_branch_stack)
  	struct rcu_head			rcu_head;
++<<<<<<< HEAD
 +
 +	RH_KABI_EXTEND(struct delayed_work	orphans_remove)
 +	RH_KABI_EXTEND(bool			orphans_remove_sched)
 +	RH_KABI_EXTEND(struct list_head		active_ctx_list)
 +	RH_KABI_EXTEND(void			*task_ctx_data) /* pmu specific data */
++=======
++>>>>>>> c6e5b73242d2 (perf: Synchronously clean up child events)
  };
  
  /*
diff --cc kernel/events/core.c
index e086d60d319b,98c862aff8fa..000000000000
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@@ -1512,45 -1643,17 +1510,54 @@@ out
  		perf_event__header_size(tmp);
  }
  
- /*
-  * User event without the task.
-  */
  static bool is_orphaned_event(struct perf_event *event)
  {
++<<<<<<< HEAD
 +	return event && !is_kernel_event(event) && !event->owner;
 +}
 +
 +/*
 + * Event has a parent but parent's task finished and it's
 + * alive only because of children holding refference.
 + */
 +static bool is_orphaned_child(struct perf_event *event)
 +{
 +	return is_orphaned_event(event->parent);
 +}
 +
 +static void orphans_remove_work(struct work_struct *work);
 +
 +static void schedule_orphans_remove(struct perf_event_context *ctx)
 +{
 +	if (!ctx->task || ctx->orphans_remove_sched || !perf_wq)
 +		return;
 +
 +	if (queue_delayed_work(perf_wq, &ctx->orphans_remove, 1)) {
 +		get_ctx(ctx);
 +		ctx->orphans_remove_sched = true;
 +	}
 +}
 +
 +static int __init perf_workqueue_init(void)
 +{
 +	perf_wq = create_singlethread_workqueue("perf");
 +	WARN(!perf_wq, "failed to create perf workqueue\n");
 +	return perf_wq ? 0 : -1;
 +}
 +
 +core_initcall(perf_workqueue_init);
 +
++=======
+ 	return event->state == PERF_EVENT_STATE_EXIT;
+ }
+ 
+ static inline int pmu_filter_match(struct perf_event *event)
+ {
+ 	struct pmu *pmu = event->pmu;
+ 	return pmu->filter_match ? pmu->filter_match(event) : 1;
+ }
+ 
++>>>>>>> c6e5b73242d2 (perf: Synchronously clean up child events)
  static inline int
  event_filter_match(struct perf_event *event)
  {
@@@ -3613,14 -3772,77 +3624,82 @@@ int perf_event_release_kernel(struct pe
  	 */
  	ctx = perf_event_ctx_lock_nested(event, SINGLE_DEPTH_NESTING);
  	WARN_ON_ONCE(ctx->parent_ctx);
 -	perf_remove_from_context(event, DETACH_GROUP | DETACH_STATE);
 +	perf_remove_from_context(event, true);
  	perf_event_ctx_unlock(event, ctx);
  
++<<<<<<< HEAD
 +	_free_event(event);
 +}
++=======
+ 	/*
+ 	 * At this point we must have event->state == PERF_EVENT_STATE_EXIT,
+ 	 * either from the above perf_remove_from_context() or through
+ 	 * perf_event_exit_event().
+ 	 *
+ 	 * Therefore, anybody acquiring event->child_mutex after the below
+ 	 * loop _must_ also see this, most importantly inherit_event() which
+ 	 * will avoid placing more children on the list.
+ 	 *
+ 	 * Thus this guarantees that we will in fact observe and kill _ALL_
+ 	 * child events.
+ 	 */
+ 	WARN_ON_ONCE(event->state != PERF_EVENT_STATE_EXIT);
  
- int perf_event_release_kernel(struct perf_event *event)
- {
+ again:
+ 	mutex_lock(&event->child_mutex);
+ 	list_for_each_entry(child, &event->child_list, child_list) {
++>>>>>>> c6e5b73242d2 (perf: Synchronously clean up child events)
+ 
+ 		/*
+ 		 * Cannot change, child events are not migrated, see the
+ 		 * comment with perf_event_ctx_lock_nested().
+ 		 */
+ 		ctx = lockless_dereference(child->ctx);
+ 		/*
+ 		 * Since child_mutex nests inside ctx::mutex, we must jump
+ 		 * through hoops. We start by grabbing a reference on the ctx.
+ 		 *
+ 		 * Since the event cannot get freed while we hold the
+ 		 * child_mutex, the context must also exist and have a !0
+ 		 * reference count.
+ 		 */
+ 		get_ctx(ctx);
+ 
+ 		/*
+ 		 * Now that we have a ctx ref, we can drop child_mutex, and
+ 		 * acquire ctx::mutex without fear of it going away. Then we
+ 		 * can re-acquire child_mutex.
+ 		 */
+ 		mutex_unlock(&event->child_mutex);
+ 		mutex_lock(&ctx->mutex);
+ 		mutex_lock(&event->child_mutex);
+ 
+ 		/*
+ 		 * Now that we hold ctx::mutex and child_mutex, revalidate our
+ 		 * state, if child is still the first entry, it didn't get freed
+ 		 * and we can continue doing so.
+ 		 */
+ 		tmp = list_first_entry_or_null(&event->child_list,
+ 					       struct perf_event, child_list);
+ 		if (tmp == child) {
+ 			perf_remove_from_context(child, DETACH_GROUP);
+ 			list_del(&child->child_list);
+ 			free_event(child);
+ 			/*
+ 			 * This matches the refcount bump in inherit_event();
+ 			 * this can't be the last reference.
+ 			 */
+ 			put_event(event);
+ 		}
+ 
+ 		mutex_unlock(&event->child_mutex);
+ 		mutex_unlock(&ctx->mutex);
+ 		put_ctx(ctx);
+ 		goto again;
+ 	}
+ 	mutex_unlock(&event->child_mutex);
+ 
+ 	/* Must be the last reference */
  	put_event(event);
  	return 0;
  }
@@@ -3635,42 -3857,6 +3714,45 @@@ static int perf_release(struct inode *i
  	return 0;
  }
  
++<<<<<<< HEAD
 +/*
 + * Remove all orphanes events from the context.
 + */
 +static void orphans_remove_work(struct work_struct *work)
 +{
 +	struct perf_event_context *ctx;
 +	struct perf_event *event, *tmp;
 +
 +	ctx = container_of(work, struct perf_event_context,
 +			   orphans_remove.work);
 +
 +	mutex_lock(&ctx->mutex);
 +	list_for_each_entry_safe(event, tmp, &ctx->event_list, event_entry) {
 +		struct perf_event *parent_event = event->parent;
 +
 +		if (!is_orphaned_child(event))
 +			continue;
 +
 +		perf_remove_from_context(event, true);
 +
 +		mutex_lock(&parent_event->child_mutex);
 +		list_del_init(&event->child_list);
 +		mutex_unlock(&parent_event->child_mutex);
 +
 +		free_event(event);
 +		put_event(parent_event);
 +	}
 +
 +	raw_spin_lock_irq(&ctx->lock);
 +	ctx->orphans_remove_sched = false;
 +	raw_spin_unlock_irq(&ctx->lock);
 +	mutex_unlock(&ctx->mutex);
 +
 +	put_ctx(ctx);
 +}
 +
++=======
++>>>>>>> c6e5b73242d2 (perf: Synchronously clean up child events)
  u64 perf_event_read_value(struct perf_event *event, u64 *enabled, u64 *running)
  {
  	struct perf_event *child;
@@@ -8109,9 -8704,10 +8191,13 @@@ __perf_event_exit_task(struct perf_even
  	raw_spin_lock_irq(&child_ctx->lock);
  	WARN_ON_ONCE(child_ctx->is_active);
  
 -	if (parent_event)
 +	if (!!child_event->parent)
  		perf_group_detach(child_event);
  	list_del_event(child_event, child_ctx);
++<<<<<<< HEAD
++=======
+ 	child_event->state = PERF_EVENT_STATE_EXIT; /* see perf_event_release_kernel() */
++>>>>>>> c6e5b73242d2 (perf: Synchronously clean up child events)
  	raw_spin_unlock_irq(&child_ctx->lock);
  
  	/*
* Unmerged path include/linux/perf_event.h
* Unmerged path kernel/events/core.c
