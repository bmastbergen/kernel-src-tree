staging/rdma/hfi1: use new timer routines

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: use new timer routines (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 89.19%
commit-author Mike Marciniszyn <mike.marciniszyn@intel.com>
commit e6f8c2b31f107f39e7301a02b5a6808d79c9f1f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e6f8c2b3.failed

Use the new timer routines.

	Reviewed-by: Jubin John <jubin.john@intel.com>
	Signed-off-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit e6f8c2b31f107f39e7301a02b5a6808d79c9f1f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/rc.c
diff --cc drivers/staging/hfi1/rc.c
index dd57d65aa9b2,5c32182dbf17..000000000000
--- a/drivers/staging/hfi1/rc.c
+++ b/drivers/staging/hfi1/rc.c
@@@ -74,15 -183,6 +74,18 @@@ static u32 restart_sge(struct hfi1_sge_
  	return wqe->length - len;
  }
  
++<<<<<<< HEAD:drivers/staging/hfi1/rc.c
 +static void start_timer(struct hfi1_qp *qp)
 +{
 +	qp->s_flags |= HFI1_S_TIMER;
 +	qp->s_timer.function = rc_timeout;
 +	/* 4.096 usec. * (1 << qp->timeout) */
 +	qp->s_timer.expires = jiffies + qp->timeout_jiffies;
 +	add_timer(&qp->s_timer);
 +}
 +
++=======
++>>>>>>> e6f8c2b31f10 (staging/rdma/hfi1: use new timer routines):drivers/staging/rdma/hfi1/rc.c
  /**
   * make_rc_ack - construct a response packet (ACK, NAK, or RDMA read)
   * @dev: the device for this QP
@@@ -945,11 -1045,8 +948,16 @@@ void hfi1_rc_rnr_retry(unsigned long ar
  	unsigned long flags;
  
  	spin_lock_irqsave(&qp->s_lock, flags);
++<<<<<<< HEAD:drivers/staging/hfi1/rc.c
 +	if (qp->s_flags & HFI1_S_WAIT_RNR) {
 +		qp->s_flags &= ~HFI1_S_WAIT_RNR;
 +		del_timer(&qp->s_timer);
 +		hfi1_schedule_send(qp);
 +	}
++=======
+ 	hfi1_stop_rnr_timer(qp);
+ 	hfi1_schedule_send(qp);
++>>>>>>> e6f8c2b31f10 (staging/rdma/hfi1: use new timer routines):drivers/staging/rdma/hfi1/rc.c
  	spin_unlock_irqrestore(&qp->s_lock, flags);
  }
  
@@@ -1017,12 -1114,12 +1025,18 @@@ void hfi1_rc_send_complete(struct hfi1_
  	 */
  	if ((psn & IB_BTH_REQ_ACK) && qp->s_acked != qp->s_tail &&
  	    !(qp->s_flags &
++<<<<<<< HEAD:drivers/staging/hfi1/rc.c
 +		(HFI1_S_TIMER | HFI1_S_WAIT_RNR | HFI1_S_WAIT_PSN)) &&
 +		(ib_hfi1_state_ops[qp->state] & HFI1_PROCESS_RECV_OK))
 +		start_timer(qp);
++=======
+ 		(RVT_S_TIMER | RVT_S_WAIT_RNR | RVT_S_WAIT_PSN)) &&
+ 		(ib_rvt_state_ops[qp->state] & RVT_PROCESS_RECV_OK))
+ 		hfi1_add_retry_timer(qp);
++>>>>>>> e6f8c2b31f10 (staging/rdma/hfi1: use new timer routines):drivers/staging/rdma/hfi1/rc.c
  
  	while (qp->s_last != qp->s_acked) {
 -		wqe = rvt_get_swqe_ptr(qp, qp->s_last);
 +		wqe = get_swqe_ptr(qp, qp->s_last);
  		if (cmp_psn(wqe->lpsn, qp->s_sending_psn) >= 0 &&
  		    cmp_psn(qp->s_sending_psn, qp->s_sending_hpsn) <= 0)
  			break;
@@@ -1167,12 -1264,10 +1181,17 @@@ static int do_rc_ack(struct hfi1_qp *qp
  	int ret = 0;
  	u32 ack_psn;
  	int diff;
+ 	unsigned long to;
  
  	/* Remove QP from retry timer */
++<<<<<<< HEAD:drivers/staging/hfi1/rc.c
 +	if (qp->s_flags & (HFI1_S_TIMER | HFI1_S_WAIT_RNR)) {
 +		qp->s_flags &= ~(HFI1_S_TIMER | HFI1_S_WAIT_RNR);
 +		del_timer(&qp->s_timer);
 +	}
++=======
+ 	hfi1_stop_rc_timers(qp);
++>>>>>>> e6f8c2b31f10 (staging/rdma/hfi1: use new timer routines):drivers/staging/rdma/hfi1/rc.c
  
  	/*
  	 * Note that NAKs implicitly ACK outstanding SEND and RDMA write
@@@ -1311,13 -1406,11 +1330,18 @@@
  
  		reset_psn(qp, psn);
  
++<<<<<<< HEAD:drivers/staging/hfi1/rc.c
 +		qp->s_flags &= ~(HFI1_S_WAIT_SSN_CREDIT | HFI1_S_WAIT_ACK);
 +		qp->s_flags |= HFI1_S_WAIT_RNR;
 +		qp->s_timer.function = hfi1_rc_rnr_retry;
 +		qp->s_timer.expires = jiffies + usecs_to_jiffies(
++=======
+ 		qp->s_flags &= ~(RVT_S_WAIT_SSN_CREDIT | RVT_S_WAIT_ACK);
+ 		to =
++>>>>>>> e6f8c2b31f10 (staging/rdma/hfi1: use new timer routines):drivers/staging/rdma/hfi1/rc.c
  			ib_hfi1_rnr_table[(aeth >> HFI1_AETH_CREDIT_SHIFT) &
- 					   HFI1_AETH_CREDIT_MASK]);
- 		add_timer(&qp->s_timer);
+ 					   HFI1_AETH_CREDIT_MASK];
+ 		hfi1_add_rnr_timer(qp, to);
  		goto bail;
  
  	case 3:         /* NAK */
@@@ -1381,18 -1474,15 +1405,22 @@@ bail
   * We have seen an out of sequence RDMA read middle or last packet.
   * This ACKs SENDs and RDMA writes up to the first RDMA read or atomic SWQE.
   */
 -static void rdma_seq_err(struct rvt_qp *qp, struct hfi1_ibport *ibp, u32 psn,
 +static void rdma_seq_err(struct hfi1_qp *qp, struct hfi1_ibport *ibp, u32 psn,
  			 struct hfi1_ctxtdata *rcd)
  {
 -	struct rvt_swqe *wqe;
 +	struct hfi1_swqe *wqe;
  
  	/* Remove QP from retry timer */
++<<<<<<< HEAD:drivers/staging/hfi1/rc.c
 +	if (qp->s_flags & (HFI1_S_TIMER | HFI1_S_WAIT_RNR)) {
 +		qp->s_flags &= ~(HFI1_S_TIMER | HFI1_S_WAIT_RNR);
 +		del_timer(&qp->s_timer);
 +	}
++=======
+ 	hfi1_stop_rc_timers(qp);
++>>>>>>> e6f8c2b31f10 (staging/rdma/hfi1: use new timer routines):drivers/staging/rdma/hfi1/rc.c
  
 -	wqe = rvt_get_swqe_ptr(qp, qp->s_acked);
 +	wqe = get_swqe_ptr(qp, qp->s_acked);
  
  	while (cmp_psn(psn, wqe->lpsn) > 0) {
  		if (wqe->wr.opcode == IB_WR_RDMA_READ ||
* Unmerged path drivers/staging/hfi1/rc.c
