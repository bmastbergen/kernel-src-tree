ACPI / property: Extend device_get_next_child_node() to data-only nodes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 504a33749971c36c54ba5ccb1364872dee1f17a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/504a3374.failed

Make device_get_next_child_node() work with ACPI data-only subnodes
introduced previously.

Namely, replace acpi_get_next_child() with acpi_get_next_subnode()
that can handle (and return) child device objects as well as child
data-only subnodes of the given device and modify the ACPI part
of the GPIO subsystem to handle data-only subnodes returned by it.

To that end, introduce acpi_node_get_gpiod() taking a struct
fwnode_handle pointer as the first argument.  That argument may
point to an ACPI device object as well as to a data-only subnode
and the function should do the right thing (ie. look for the matching
GPIO descriptor correctly) in either case.

Next, modify fwnode_get_named_gpiod() to use acpi_node_get_gpiod()
instead of acpi_get_gpiod_by_index() which automatically causes
devm_get_gpiod_from_child() to work with ACPI data-only subnodes
that may be returned by device_get_next_child_node() which in turn
is required by the users of that function (the gpio_keys_polled
and gpio-leds drivers).

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Acked-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 504a33749971c36c54ba5ccb1364872dee1f17a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/property.c
#	drivers/acpi/scan.c
#	drivers/base/property.c
#	drivers/gpio/gpiolib-acpi.c
#	drivers/gpio/gpiolib.c
#	drivers/gpio/gpiolib.h
#	include/linux/acpi.h
diff --cc drivers/acpi/property.c
index 3d47281953cd,14654435c295..000000000000
--- a/drivers/acpi/property.c
+++ b/drivers/acpi/property.c
@@@ -228,13 -459,11 +228,19 @@@ int acpi_dev_get_property_array(struct 
  
  	return 0;
  }
 +EXPORT_SYMBOL_GPL(acpi_dev_get_property_array);
  
  /**
++<<<<<<< HEAD
 + * acpi_dev_get_property_reference - returns handle to the referenced object
 + * @adev: ACPI device to get property
 + * @name: Name of the property
 + * @size_prop: Name of the "size" property in referenced object
++=======
+  * acpi_data_get_property_reference - returns handle to the referenced object
+  * @data: ACPI device data object containing the property
+  * @propname: Name of the property
++>>>>>>> 504a33749971 (ACPI / property: Extend device_get_next_child_node() to data-only nodes)
   * @index: Index of the reference to return
   * @args: Location to store the returned reference with optional arguments
   *
@@@ -251,9 -477,9 +257,15 @@@
   *
   * Return: %0 on success, negative error code on failure.
   */
++<<<<<<< HEAD
 +int acpi_dev_get_property_reference(struct acpi_device *adev, const char *name,
 +				    const char *size_prop, size_t index,
 +				    struct acpi_reference_args *args)
++=======
+ static int acpi_data_get_property_reference(struct acpi_device_data *data,
+ 					    const char *propname, size_t index,
+ 					    struct acpi_reference_args *args)
++>>>>>>> 504a33749971 (ACPI / property: Extend device_get_next_child_node() to data-only nodes)
  {
  	const union acpi_object *element, *end;
  	const union acpi_object *obj;
@@@ -361,17 -561,27 +373,33 @@@
  
  	return -EPROTO;
  }
- EXPORT_SYMBOL_GPL(acpi_dev_get_property_reference);
+ 
+ /**
+  * acpi_node_get_property_reference - get a handle to the referenced object.
+  * @fwnode: Firmware node to get the property from.
+  * @propname: Name of the property.
+  * @index: Index of the reference to return.
+  * @args: Location to store the returned reference with optional arguments.
+  */
+ int acpi_node_get_property_reference(struct fwnode_handle *fwnode,
+ 				     const char *name, size_t index,
+ 				     struct acpi_reference_args *args)
+ {
+ 	struct acpi_device_data *data = acpi_device_data_of_node(fwnode);
+ 
+ 	return data ? acpi_data_get_property_reference(data, name, index, args) : -EINVAL;
+ }
+ EXPORT_SYMBOL_GPL(acpi_node_get_property_reference);
  
 -static int acpi_data_prop_read_single(struct acpi_device_data *data,
 -				      const char *propname,
 -				      enum dev_prop_type proptype, void *val)
 +int acpi_dev_prop_get(struct acpi_device *adev, const char *propname,
 +		      void **valptr)
 +{
 +	return acpi_dev_get_property(adev, propname, ACPI_TYPE_ANY,
 +				     (const union acpi_object **)valptr);
 +}
 +
 +int acpi_dev_prop_read_single(struct acpi_device *adev, const char *propname,
 +			      enum dev_prop_type proptype, void *val)
  {
  	const union acpi_object *obj;
  	int ret;
@@@ -541,3 -759,84 +569,87 @@@ int acpi_dev_prop_read(struct acpi_devi
  	}
  	return ret;
  }
++<<<<<<< HEAD
++=======
+ 
+ int acpi_dev_prop_read(struct acpi_device *adev, const char *propname,
+ 		       enum dev_prop_type proptype, void *val, size_t nval)
+ {
+ 	return adev ? acpi_data_prop_read(&adev->data, propname, proptype, val, nval) : -EINVAL;
+ }
+ 
+ /**
+  * acpi_node_prop_read - retrieve the value of an ACPI property with given name.
+  * @fwnode: Firmware node to get the property from.
+  * @propname: Name of the property.
+  * @proptype: Expected property type.
+  * @val: Location to store the property value (if not %NULL).
+  * @nval: Size of the array pointed to by @val.
+  *
+  * If @val is %NULL, return the number of array elements comprising the value
+  * of the property.  Otherwise, read at most @nval values to the array at the
+  * location pointed to by @val.
+  */
+ int acpi_node_prop_read(struct fwnode_handle *fwnode,  const char *propname,
+ 		        enum dev_prop_type proptype, void *val, size_t nval)
+ {
+ 	return acpi_data_prop_read(acpi_device_data_of_node(fwnode),
+ 				   propname, proptype, val, nval);
+ }
+ 
+ /**
+  * acpi_get_next_subnode - Return the next child node handle for a device.
+  * @dev: Device to find the next child node for.
+  * @child: Handle to one of the device's child nodes or a null handle.
+  */
+ struct fwnode_handle *acpi_get_next_subnode(struct device *dev,
+ 					    struct fwnode_handle *child)
+ {
+ 	struct acpi_device *adev = ACPI_COMPANION(dev);
+ 	struct list_head *head, *next;
+ 
+ 	if (!adev)
+ 		return NULL;
+ 
+ 	if (!child || child->type == FWNODE_ACPI) {
+ 		head = &adev->children;
+ 		if (list_empty(head))
+ 			goto nondev;
+ 
+ 		if (child) {
+ 			adev = to_acpi_device_node(child);
+ 			next = adev->node.next;
+ 			if (next == head) {
+ 				child = NULL;
+ 				goto nondev;
+ 			}
+ 			adev = list_entry(next, struct acpi_device, node);
+ 		} else {
+ 			adev = list_first_entry(head, struct acpi_device, node);
+ 		}
+ 		return acpi_fwnode_handle(adev);
+ 	}
+ 
+  nondev:
+ 	if (!child || child->type == FWNODE_ACPI_DATA) {
+ 		struct acpi_data_node *dn;
+ 
+ 		head = &adev->data.subnodes;
+ 		if (list_empty(head))
+ 			return NULL;
+ 
+ 		if (child) {
+ 			dn = to_acpi_data_node(child);
+ 			next = dn->sibling.next;
+ 			if (next == head)
+ 				return NULL;
+ 
+ 			dn = list_entry(next, struct acpi_data_node, sibling);
+ 		} else {
+ 			dn = list_first_entry(head, struct acpi_data_node, sibling);
+ 		}
+ 		return &dn->fwnode;
+ 	}
+ 	return NULL;
+ }
++>>>>>>> 504a33749971 (ACPI / property: Extend device_get_next_child_node() to data-only nodes)
diff --cc drivers/acpi/scan.c
index b64d638cf134,d1ce377db3e9..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -1207,47 -695,6 +1207,50 @@@ int acpi_device_add(struct acpi_device 
  	return result;
  }
  
++<<<<<<< HEAD
 +/* --------------------------------------------------------------------------
 +                                 Driver Management
 +   -------------------------------------------------------------------------- */
 +/**
 + * acpi_bus_register_driver - register a driver with the ACPI bus
 + * @driver: driver being registered
 + *
 + * Registers a driver with the ACPI bus.  Searches the namespace for all
 + * devices that match the driver's criteria and binds.  Returns zero for
 + * success or a negative error status for failure.
 + */
 +int acpi_bus_register_driver(struct acpi_driver *driver)
 +{
 +	int ret;
 +
 +	if (acpi_disabled)
 +		return -ENODEV;
 +	driver->drv.name = driver->name;
 +	driver->drv.bus = &acpi_bus_type;
 +	driver->drv.owner = driver->owner;
 +
 +	ret = driver_register(&driver->drv);
 +	return ret;
 +}
 +
 +EXPORT_SYMBOL(acpi_bus_register_driver);
 +
 +/**
 + * acpi_bus_unregister_driver - unregisters a driver with the APIC bus
 + * @driver: driver to unregister
 + *
 + * Unregisters a driver with the ACPI bus.  Searches the namespace for all
 + * devices that match the driver's criteria and unbinds.
 + */
 +void acpi_bus_unregister_driver(struct acpi_driver *driver)
 +{
 +	driver_unregister(&driver->drv);
 +}
 +
 +EXPORT_SYMBOL(acpi_bus_unregister_driver);
 +
++=======
++>>>>>>> 504a33749971 (ACPI / property: Extend device_get_next_child_node() to data-only nodes)
  /* --------------------------------------------------------------------------
                                   Device Enumeration
     -------------------------------------------------------------------------- */
diff --cc drivers/base/property.c
index 6a94ef6e83c9,660ecec60bdf..000000000000
--- a/drivers/base/property.c
+++ b/drivers/base/property.c
@@@ -177,9 -283,340 +177,346 @@@ EXPORT_SYMBOL_GPL(device_property_read_
  int device_property_read_string(struct device *dev, const char *propname,
  				const char **val)
  {
 -	return fwnode_property_read_string(dev_fwnode(dev), propname, val);
 +	return IS_ENABLED(CONFIG_OF) && dev->of_node ?
 +		of_property_read_string(dev->of_node, propname, val) :
 +		acpi_dev_prop_read(ACPI_COMPANION(dev), propname,
 +				   DEV_PROP_STRING, val, 1);
  }
  EXPORT_SYMBOL_GPL(device_property_read_string);
++<<<<<<< HEAD
++=======
+ 
+ #define OF_DEV_PROP_READ_ARRAY(node, propname, type, val, nval) \
+ 	(val) ? of_property_read_##type##_array((node), (propname), (val), (nval)) \
+ 	      : of_property_count_elems_of_size((node), (propname), sizeof(type))
+ 
+ #define FWNODE_PROP_READ_ARRAY(_fwnode_, _propname_, _type_, _proptype_, _val_, _nval_) \
+ ({ \
+ 	int _ret_; \
+ 	if (is_of_node(_fwnode_)) \
+ 		_ret_ = OF_DEV_PROP_READ_ARRAY(to_of_node(_fwnode_), _propname_, \
+ 					       _type_, _val_, _nval_); \
+ 	else if (is_acpi_node(_fwnode_)) \
+ 		_ret_ = acpi_node_prop_read(_fwnode_, _propname_, _proptype_, \
+ 					    _val_, _nval_); \
+ 	else if (is_pset(_fwnode_)) \
+ 		_ret_ = pset_prop_read_array(to_pset(_fwnode_), _propname_, \
+ 					     _proptype_, _val_, _nval_); \
+ 	else \
+ 		_ret_ = -ENXIO; \
+ 	_ret_; \
+ })
+ 
+ /**
+  * fwnode_property_read_u8_array - return a u8 array property of firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u8 properties with @propname from @fwnode and stores them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u8_array(struct fwnode_handle *fwnode,
+ 				  const char *propname, u8 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u8, DEV_PROP_U8,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u8_array);
+ 
+ /**
+  * fwnode_property_read_u16_array - return a u16 array property of firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u16 properties with @propname from @fwnode and store them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u16_array(struct fwnode_handle *fwnode,
+ 				   const char *propname, u16 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u16, DEV_PROP_U16,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u16_array);
+ 
+ /**
+  * fwnode_property_read_u32_array - return a u32 array property of firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u32 properties with @propname from @fwnode store them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u32_array(struct fwnode_handle *fwnode,
+ 				   const char *propname, u32 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u32, DEV_PROP_U32,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u32_array);
+ 
+ /**
+  * fwnode_property_read_u64_array - return a u64 array property firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u64 properties with @propname from @fwnode and store them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u64_array(struct fwnode_handle *fwnode,
+ 				   const char *propname, u64 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u64, DEV_PROP_U64,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u64_array);
+ 
+ /**
+  * fwnode_property_read_string_array - return string array property of a node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an string list property @propname from the given firmware node and store
+  * them to @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of strings,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_string_array(struct fwnode_handle *fwnode,
+ 				      const char *propname, const char **val,
+ 				      size_t nval)
+ {
+ 	if (is_of_node(fwnode))
+ 		return val ?
+ 			of_property_read_string_array(to_of_node(fwnode),
+ 						      propname, val, nval) :
+ 			of_property_count_strings(to_of_node(fwnode), propname);
+ 	else if (is_acpi_node(fwnode))
+ 		return acpi_node_prop_read(fwnode, propname, DEV_PROP_STRING,
+ 					   val, nval);
+ 	else if (is_pset(fwnode))
+ 		return pset_prop_read_array(to_pset(fwnode), propname,
+ 					    DEV_PROP_STRING, val, nval);
+ 	return -ENXIO;
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_string_array);
+ 
+ /**
+  * fwnode_property_read_string - return a string property of a firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The value is stored here
+  *
+  * Read property @propname from the given firmware node and store the value into
+  * @val if found.  The value is checked to be a string.
+  *
+  * Return: %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO or %-EILSEQ if the property is not a string,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_string(struct fwnode_handle *fwnode,
+ 				const char *propname, const char **val)
+ {
+ 	if (is_of_node(fwnode))
+ 		return of_property_read_string(to_of_node(fwnode), propname, val);
+ 	else if (is_acpi_node(fwnode))
+ 		return acpi_node_prop_read(fwnode, propname, DEV_PROP_STRING,
+ 					   val, 1);
+ 
+ 	return pset_prop_read_array(to_pset(fwnode), propname,
+ 				    DEV_PROP_STRING, val, 1);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_string);
+ 
+ /**
+  * device_get_next_child_node - Return the next child node handle for a device
+  * @dev: Device to find the next child node for.
+  * @child: Handle to one of the device's child nodes or a null handle.
+  */
+ struct fwnode_handle *device_get_next_child_node(struct device *dev,
+ 						 struct fwnode_handle *child)
+ {
+ 	if (IS_ENABLED(CONFIG_OF) && dev->of_node) {
+ 		struct device_node *node;
+ 
+ 		node = of_get_next_available_child(dev->of_node, to_of_node(child));
+ 		if (node)
+ 			return &node->fwnode;
+ 	} else if (IS_ENABLED(CONFIG_ACPI)) {
+ 		return acpi_get_next_subnode(dev, child);
+ 	}
+ 	return NULL;
+ }
+ EXPORT_SYMBOL_GPL(device_get_next_child_node);
+ 
+ /**
+  * fwnode_handle_put - Drop reference to a device node
+  * @fwnode: Pointer to the device node to drop the reference to.
+  *
+  * This has to be used when terminating device_for_each_child_node() iteration
+  * with break or return to prevent stale device node references from being left
+  * behind.
+  */
+ void fwnode_handle_put(struct fwnode_handle *fwnode)
+ {
+ 	if (is_of_node(fwnode))
+ 		of_node_put(to_of_node(fwnode));
+ }
+ EXPORT_SYMBOL_GPL(fwnode_handle_put);
+ 
+ /**
+  * device_get_child_node_count - return the number of child nodes for device
+  * @dev: Device to cound the child nodes for
+  */
+ unsigned int device_get_child_node_count(struct device *dev)
+ {
+ 	struct fwnode_handle *child;
+ 	unsigned int count = 0;
+ 
+ 	device_for_each_child_node(dev, child)
+ 		count++;
+ 
+ 	return count;
+ }
+ EXPORT_SYMBOL_GPL(device_get_child_node_count);
+ 
+ bool device_dma_is_coherent(struct device *dev)
+ {
+ 	bool coherent = false;
+ 
+ 	if (IS_ENABLED(CONFIG_OF) && dev->of_node)
+ 		coherent = of_dma_is_coherent(dev->of_node);
+ 	else
+ 		acpi_check_dma(ACPI_COMPANION(dev), &coherent);
+ 
+ 	return coherent;
+ }
+ EXPORT_SYMBOL_GPL(device_dma_is_coherent);
+ 
+ /**
+  * device_get_phy_mode - Get phy mode for given device
+  * @dev:	Pointer to the given device
+  *
+  * The function gets phy interface string from property 'phy-mode' or
+  * 'phy-connection-type', and return its index in phy_modes table, or errno in
+  * error case.
+  */
+ int device_get_phy_mode(struct device *dev)
+ {
+ 	const char *pm;
+ 	int err, i;
+ 
+ 	err = device_property_read_string(dev, "phy-mode", &pm);
+ 	if (err < 0)
+ 		err = device_property_read_string(dev,
+ 						  "phy-connection-type", &pm);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	for (i = 0; i < PHY_INTERFACE_MODE_MAX; i++)
+ 		if (!strcasecmp(pm, phy_modes(i)))
+ 			return i;
+ 
+ 	return -ENODEV;
+ }
+ EXPORT_SYMBOL_GPL(device_get_phy_mode);
+ 
+ static void *device_get_mac_addr(struct device *dev,
+ 				 const char *name, char *addr,
+ 				 int alen)
+ {
+ 	int ret = device_property_read_u8_array(dev, name, addr, alen);
+ 
+ 	if (ret == 0 && alen == ETH_ALEN && is_valid_ether_addr(addr))
+ 		return addr;
+ 	return NULL;
+ }
+ 
+ /**
+  * device_get_mac_address - Get the MAC for a given device
+  * @dev:	Pointer to the device
+  * @addr:	Address of buffer to store the MAC in
+  * @alen:	Length of the buffer pointed to by addr, should be ETH_ALEN
+  *
+  * Search the firmware node for the best MAC address to use.  'mac-address' is
+  * checked first, because that is supposed to contain to "most recent" MAC
+  * address. If that isn't set, then 'local-mac-address' is checked next,
+  * because that is the default address.  If that isn't set, then the obsolete
+  * 'address' is checked, just in case we're using an old device tree.
+  *
+  * Note that the 'address' property is supposed to contain a virtual address of
+  * the register set, but some DTS files have redefined that property to be the
+  * MAC address.
+  *
+  * All-zero MAC addresses are rejected, because those could be properties that
+  * exist in the firmware tables, but were not updated by the firmware.  For
+  * example, the DTS could define 'mac-address' and 'local-mac-address', with
+  * zero MAC addresses.  Some older U-Boots only initialized 'local-mac-address'.
+  * In this case, the real MAC is in 'local-mac-address', and 'mac-address'
+  * exists but is all zeros.
+ */
+ void *device_get_mac_address(struct device *dev, char *addr, int alen)
+ {
+ 	char *res;
+ 
+ 	res = device_get_mac_addr(dev, "mac-address", addr, alen);
+ 	if (res)
+ 		return res;
+ 
+ 	res = device_get_mac_addr(dev, "local-mac-address", addr, alen);
+ 	if (res)
+ 		return res;
+ 
+ 	return device_get_mac_addr(dev, "address", addr, alen);
+ }
+ EXPORT_SYMBOL(device_get_mac_address);
++>>>>>>> 504a33749971 (ACPI / property: Extend device_get_next_child_node() to data-only nodes)
diff --cc drivers/gpio/gpiolib-acpi.c
index b027c227470a,69a83626f1ae..000000000000
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@@ -258,9 -427,69 +258,71 @@@ static int acpi_find_gpio(struct acpi_r
  	return 1;
  }
  
++<<<<<<< HEAD
++=======
+ static int acpi_gpio_resource_lookup(struct acpi_gpio_lookup *lookup,
+ 				     struct acpi_gpio_info *info)
+ {
+ 	struct list_head res_list;
+ 	int ret;
+ 
+ 	INIT_LIST_HEAD(&res_list);
+ 
+ 	ret = acpi_dev_get_resources(lookup->adev, &res_list, acpi_find_gpio,
+ 				     lookup);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	acpi_dev_free_resource_list(&res_list);
+ 
+ 	if (!lookup->desc)
+ 		return -ENOENT;
+ 
+ 	if (info) {
+ 		*info = lookup->info;
+ 		if (lookup->active_low)
+ 			info->active_low = lookup->active_low;
+ 	}
+ 	return 0;
+ }
+ 
+ static int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,
+ 				     const char *propname, int index,
+ 				     struct acpi_gpio_lookup *lookup)
+ {
+ 	struct acpi_reference_args args;
+ 	int ret;
+ 
+ 	memset(&args, 0, sizeof(args));
+ 	ret = acpi_node_get_property_reference(fwnode, propname, index, &args);
+ 	if (ret) {
+ 		struct acpi_device *adev = to_acpi_device_node(fwnode);
+ 
+ 		if (!adev)
+ 			return ret;
+ 
+ 		if (!acpi_get_driver_gpio_data(adev, propname, index, &args))
+ 			return ret;
+ 	}
+ 	/*
+ 	 * The property was found and resolved, so need to lookup the GPIO based
+ 	 * on returned args.
+ 	 */
+ 	lookup->adev = args.adev;
+ 	if (args.nargs >= 2) {
+ 		lookup->index = args.args[0];
+ 		lookup->pin_index = args.args[1];
+ 		/* 3rd argument, if present is used to specify active_low. */
+ 		if (args.nargs >= 3)
+ 			lookup->active_low = !!args.args[2];
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 504a33749971 (ACPI / property: Extend device_get_next_child_node() to data-only nodes)
  /**
   * acpi_get_gpiod_by_index() - get a GPIO descriptor from device resources
 - * @adev: pointer to a ACPI device to get GPIO from
 - * @propname: Property name of the GPIO (optional)
 + * @dev: pointer to a device to get GPIO from
   * @index: index of GpioIo/GpioInt resource (starting from %0)
   * @info: info pointer to fill in (optional)
   *
@@@ -294,17 -521,385 +356,392 @@@ struct gpio_desc *acpi_get_gpiod_by_ind
  	memset(&lookup, 0, sizeof(lookup));
  	lookup.index = index;
  
 -	if (propname) {
 -		dev_dbg(&adev->dev, "GPIO: looking up %s\n", propname);
 +	INIT_LIST_HEAD(&resource_list);
 +	ret = acpi_dev_get_resources(adev, &resource_list, acpi_find_gpio,
 +				     &lookup);
 +	if (ret < 0)
 +		return ERR_PTR(ret);
  
++<<<<<<< HEAD
 +	acpi_dev_free_resource_list(&resource_list);
++=======
+ 		ret = acpi_gpio_property_lookup(acpi_fwnode_handle(adev),
+ 						propname, index, &lookup);
+ 		if (ret)
+ 			return ERR_PTR(ret);
++>>>>>>> 504a33749971 (ACPI / property: Extend device_get_next_child_node() to data-only nodes)
  
 -		dev_dbg(&adev->dev, "GPIO: _DSD returned %s %d %d %u\n",
 -			dev_name(&lookup.adev->dev), lookup.index,
 -			lookup.pin_index, lookup.active_low);
 -	} else {
 -		dev_dbg(&adev->dev, "GPIO: looking up %d in _CRS\n", index);
 -		lookup.adev = adev;
 -	}
 +	if (lookup.desc && info)
 +		*info = lookup.info;
  
++<<<<<<< HEAD
 +	return lookup.desc ? lookup.desc : ERR_PTR(-ENOENT);
++=======
+ 	ret = acpi_gpio_resource_lookup(&lookup, info);
+ 	return ret ? ERR_PTR(ret) : lookup.desc;
+ }
+ 
+ /**
+  * acpi_node_get_gpiod() - get a GPIO descriptor from ACPI resources
+  * @fwnode: pointer to an ACPI firmware node to get the GPIO information from
+  * @propname: Property name of the GPIO
+  * @index: index of GpioIo/GpioInt resource (starting from %0)
+  * @info: info pointer to fill in (optional)
+  *
+  * If @fwnode is an ACPI device object, call %acpi_get_gpiod_by_index() for it.
+  * Otherwise (ie. it is a data-only non-device object), use the property-based
+  * GPIO lookup to get to the GPIO resource with the relevant information and use
+  * that to obtain the GPIO descriptor to return.
+  */
+ struct gpio_desc *acpi_node_get_gpiod(struct fwnode_handle *fwnode,
+ 				      const char *propname, int index,
+ 				      struct acpi_gpio_info *info)
+ {
+ 	struct acpi_gpio_lookup lookup;
+ 	struct acpi_device *adev;
+ 	int ret;
+ 
+ 	adev = to_acpi_device_node(fwnode);
+ 	if (adev)
+ 		return acpi_get_gpiod_by_index(adev, propname, index, info);
+ 
+ 	if (!is_acpi_data_node(fwnode))
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	if (!propname)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	memset(&lookup, 0, sizeof(lookup));
+ 	lookup.index = index;
+ 
+ 	ret = acpi_gpio_property_lookup(fwnode, propname, index, &lookup);
+ 	if (ret)
+ 		return ERR_PTR(ret);
+ 
+ 	ret = acpi_gpio_resource_lookup(&lookup, info);
+ 	return ret ? ERR_PTR(ret) : lookup.desc;
+ }
+ 
+ /**
+  * acpi_dev_gpio_irq_get() - Find GpioInt and translate it to Linux IRQ number
+  * @adev: pointer to a ACPI device to get IRQ from
+  * @index: index of GpioInt resource (starting from %0)
+  *
+  * If the device has one or more GpioInt resources, this function can be
+  * used to translate from the GPIO offset in the resource to the Linux IRQ
+  * number.
+  *
+  * Return: Linux IRQ number (>%0) on success, negative errno on failure.
+  */
+ int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
+ {
+ 	int idx, i;
+ 
+ 	for (i = 0, idx = 0; idx <= index; i++) {
+ 		struct acpi_gpio_info info;
+ 		struct gpio_desc *desc;
+ 
+ 		desc = acpi_get_gpiod_by_index(adev, NULL, i, &info);
+ 		if (IS_ERR(desc))
+ 			break;
+ 		if (info.gpioint && idx++ == index)
+ 			return gpiod_to_irq(desc);
+ 	}
+ 	return -ENOENT;
+ }
+ EXPORT_SYMBOL_GPL(acpi_dev_gpio_irq_get);
+ 
+ static acpi_status
+ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
+ 			    u32 bits, u64 *value, void *handler_context,
+ 			    void *region_context)
+ {
+ 	struct acpi_gpio_chip *achip = region_context;
+ 	struct gpio_chip *chip = achip->chip;
+ 	struct acpi_resource_gpio *agpio;
+ 	struct acpi_resource *ares;
+ 	int pin_index = (int)address;
+ 	acpi_status status;
+ 	bool pull_up;
+ 	int length;
+ 	int i;
+ 
+ 	status = acpi_buffer_to_resource(achip->conn_info.connection,
+ 					 achip->conn_info.length, &ares);
+ 	if (ACPI_FAILURE(status))
+ 		return status;
+ 
+ 	if (WARN_ON(ares->type != ACPI_RESOURCE_TYPE_GPIO)) {
+ 		ACPI_FREE(ares);
+ 		return AE_BAD_PARAMETER;
+ 	}
+ 
+ 	agpio = &ares->data.gpio;
+ 	pull_up = agpio->pin_config == ACPI_PIN_CONFIG_PULLUP;
+ 
+ 	if (WARN_ON(agpio->io_restriction == ACPI_IO_RESTRICT_INPUT &&
+ 	    function == ACPI_WRITE)) {
+ 		ACPI_FREE(ares);
+ 		return AE_BAD_PARAMETER;
+ 	}
+ 
+ 	length = min(agpio->pin_table_length, (u16)(pin_index + bits));
+ 	for (i = pin_index; i < length; ++i) {
+ 		int pin = agpio->pin_table[i];
+ 		struct acpi_gpio_connection *conn;
+ 		struct gpio_desc *desc;
+ 		bool found;
+ 
+ 		pin = acpi_gpiochip_pin_to_gpio_offset(chip, pin);
+ 		if (pin < 0) {
+ 			status = AE_BAD_PARAMETER;
+ 			goto out;
+ 		}
+ 
+ 		mutex_lock(&achip->conn_lock);
+ 
+ 		found = false;
+ 		list_for_each_entry(conn, &achip->conns, node) {
+ 			if (conn->pin == pin) {
+ 				found = true;
+ 				desc = conn->desc;
+ 				break;
+ 			}
+ 		}
+ 		if (!found) {
+ 			desc = gpiochip_request_own_desc(chip, pin,
+ 							 "ACPI:OpRegion");
+ 			if (IS_ERR(desc)) {
+ 				status = AE_ERROR;
+ 				mutex_unlock(&achip->conn_lock);
+ 				goto out;
+ 			}
+ 
+ 			switch (agpio->io_restriction) {
+ 			case ACPI_IO_RESTRICT_INPUT:
+ 				gpiod_direction_input(desc);
+ 				break;
+ 			case ACPI_IO_RESTRICT_OUTPUT:
+ 				/*
+ 				 * ACPI GPIO resources don't contain an
+ 				 * initial value for the GPIO. Therefore we
+ 				 * deduce that value from the pull field
+ 				 * instead. If the pin is pulled up we
+ 				 * assume default to be high, otherwise
+ 				 * low.
+ 				 */
+ 				gpiod_direction_output(desc, pull_up);
+ 				break;
+ 			default:
+ 				/*
+ 				 * Assume that the BIOS has configured the
+ 				 * direction and pull accordingly.
+ 				 */
+ 				break;
+ 			}
+ 
+ 			conn = kzalloc(sizeof(*conn), GFP_KERNEL);
+ 			if (!conn) {
+ 				status = AE_NO_MEMORY;
+ 				gpiochip_free_own_desc(desc);
+ 				mutex_unlock(&achip->conn_lock);
+ 				goto out;
+ 			}
+ 
+ 			conn->pin = pin;
+ 			conn->desc = desc;
+ 			list_add_tail(&conn->node, &achip->conns);
+ 		}
+ 
+ 		mutex_unlock(&achip->conn_lock);
+ 
+ 		if (function == ACPI_WRITE)
+ 			gpiod_set_raw_value_cansleep(desc,
+ 						     !!((1 << i) & *value));
+ 		else
+ 			*value |= (u64)gpiod_get_raw_value_cansleep(desc) << i;
+ 	}
+ 
+ out:
+ 	ACPI_FREE(ares);
+ 	return status;
+ }
+ 
+ static void acpi_gpiochip_request_regions(struct acpi_gpio_chip *achip)
+ {
+ 	struct gpio_chip *chip = achip->chip;
+ 	acpi_handle handle = ACPI_HANDLE(chip->dev);
+ 	acpi_status status;
+ 
+ 	INIT_LIST_HEAD(&achip->conns);
+ 	mutex_init(&achip->conn_lock);
+ 	status = acpi_install_address_space_handler(handle, ACPI_ADR_SPACE_GPIO,
+ 						    acpi_gpio_adr_space_handler,
+ 						    NULL, achip);
+ 	if (ACPI_FAILURE(status))
+ 		dev_err(chip->dev, "Failed to install GPIO OpRegion handler\n");
+ }
+ 
+ static void acpi_gpiochip_free_regions(struct acpi_gpio_chip *achip)
+ {
+ 	struct gpio_chip *chip = achip->chip;
+ 	acpi_handle handle = ACPI_HANDLE(chip->dev);
+ 	struct acpi_gpio_connection *conn, *tmp;
+ 	acpi_status status;
+ 
+ 	status = acpi_remove_address_space_handler(handle, ACPI_ADR_SPACE_GPIO,
+ 						   acpi_gpio_adr_space_handler);
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_err(chip->dev, "Failed to remove GPIO OpRegion handler\n");
+ 		return;
+ 	}
+ 
+ 	list_for_each_entry_safe_reverse(conn, tmp, &achip->conns, node) {
+ 		gpiochip_free_own_desc(conn->desc);
+ 		list_del(&conn->node);
+ 		kfree(conn);
+ 	}
+ }
+ 
+ void acpi_gpiochip_add(struct gpio_chip *chip)
+ {
+ 	struct acpi_gpio_chip *acpi_gpio;
+ 	acpi_handle handle;
+ 	acpi_status status;
+ 
+ 	if (!chip || !chip->dev)
+ 		return;
+ 
+ 	handle = ACPI_HANDLE(chip->dev);
+ 	if (!handle)
+ 		return;
+ 
+ 	acpi_gpio = kzalloc(sizeof(*acpi_gpio), GFP_KERNEL);
+ 	if (!acpi_gpio) {
+ 		dev_err(chip->dev,
+ 			"Failed to allocate memory for ACPI GPIO chip\n");
+ 		return;
+ 	}
+ 
+ 	acpi_gpio->chip = chip;
+ 
+ 	status = acpi_attach_data(handle, acpi_gpio_chip_dh, acpi_gpio);
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_err(chip->dev, "Failed to attach ACPI GPIO chip\n");
+ 		kfree(acpi_gpio);
+ 		return;
+ 	}
+ 
+ 	acpi_gpiochip_request_regions(acpi_gpio);
+ }
+ 
+ void acpi_gpiochip_remove(struct gpio_chip *chip)
+ {
+ 	struct acpi_gpio_chip *acpi_gpio;
+ 	acpi_handle handle;
+ 	acpi_status status;
+ 
+ 	if (!chip || !chip->dev)
+ 		return;
+ 
+ 	handle = ACPI_HANDLE(chip->dev);
+ 	if (!handle)
+ 		return;
+ 
+ 	status = acpi_get_data(handle, acpi_gpio_chip_dh, (void **)&acpi_gpio);
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_warn(chip->dev, "Failed to retrieve ACPI GPIO chip\n");
+ 		return;
+ 	}
+ 
+ 	acpi_gpiochip_free_regions(acpi_gpio);
+ 
+ 	acpi_detach_data(handle, acpi_gpio_chip_dh);
+ 	kfree(acpi_gpio);
+ }
+ 
+ static unsigned int acpi_gpio_package_count(const union acpi_object *obj)
+ {
+ 	const union acpi_object *element = obj->package.elements;
+ 	const union acpi_object *end = element + obj->package.count;
+ 	unsigned int count = 0;
+ 
+ 	while (element < end) {
+ 		if (element->type == ACPI_TYPE_LOCAL_REFERENCE)
+ 			count++;
+ 
+ 		element++;
+ 	}
+ 	return count;
+ }
+ 
+ static int acpi_find_gpio_count(struct acpi_resource *ares, void *data)
+ {
+ 	unsigned int *count = data;
+ 
+ 	if (ares->type == ACPI_RESOURCE_TYPE_GPIO)
+ 		*count += ares->data.gpio.pin_table_length;
+ 
+ 	return 1;
+ }
+ 
+ /**
+  * acpi_gpio_count - return the number of GPIOs associated with a
+  *		device / function or -ENOENT if no GPIO has been
+  *		assigned to the requested function.
+  * @dev:	GPIO consumer, can be NULL for system-global GPIOs
+  * @con_id:	function within the GPIO consumer
+  */
+ int acpi_gpio_count(struct device *dev, const char *con_id)
+ {
+ 	struct acpi_device *adev = ACPI_COMPANION(dev);
+ 	const union acpi_object *obj;
+ 	const struct acpi_gpio_mapping *gm;
+ 	int count = -ENOENT;
+ 	int ret;
+ 	char propname[32];
+ 	unsigned int i;
+ 
+ 	/* Try first from _DSD */
+ 	for (i = 0; i < ARRAY_SIZE(gpio_suffixes); i++) {
+ 		if (con_id && strcmp(con_id, "gpios"))
+ 			snprintf(propname, sizeof(propname), "%s-%s",
+ 				 con_id, gpio_suffixes[i]);
+ 		else
+ 			snprintf(propname, sizeof(propname), "%s",
+ 				 gpio_suffixes[i]);
+ 
+ 		ret = acpi_dev_get_property(adev, propname, ACPI_TYPE_ANY,
+ 					    &obj);
+ 		if (ret == 0) {
+ 			if (obj->type == ACPI_TYPE_LOCAL_REFERENCE)
+ 				count = 1;
+ 			else if (obj->type == ACPI_TYPE_PACKAGE)
+ 				count = acpi_gpio_package_count(obj);
+ 		} else if (adev->driver_gpios) {
+ 			for (gm = adev->driver_gpios; gm->name; gm++)
+ 				if (strcmp(propname, gm->name) == 0) {
+ 					count = gm->size;
+ 					break;
+ 				}
+ 		}
+ 		if (count >= 0)
+ 			break;
+ 	}
+ 
+ 	/* Then from plain _CRS GPIOs */
+ 	if (count < 0) {
+ 		struct list_head resource_list;
+ 		unsigned int crs_count = 0;
+ 
+ 		INIT_LIST_HEAD(&resource_list);
+ 		acpi_dev_get_resources(adev, &resource_list,
+ 				       acpi_find_gpio_count, &crs_count);
+ 		acpi_dev_free_resource_list(&resource_list);
+ 		if (crs_count > 0)
+ 			count = crs_count;
+ 	}
+ 	return count;
++>>>>>>> 504a33749971 (ACPI / property: Extend device_get_next_child_node() to data-only nodes)
  }
 +EXPORT_SYMBOL_GPL(acpi_get_gpiod_by_index);
diff --cc drivers/gpio/gpiolib.c
index 9b50ed619d38,7d61b506c42f..000000000000
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@@ -2460,7 -2041,65 +2460,69 @@@ struct gpio_desc *__must_check gpiod_ge
  	if (status < 0)
  		return ERR_PTR(status);
  
++<<<<<<< HEAD
 +	if (flags & GPIOF_ACTIVE_LOW)
++=======
+ 	status = gpiod_configure_flags(desc, con_id, lookupflags, flags);
+ 	if (status < 0) {
+ 		dev_dbg(dev, "setup of GPIO %s failed\n", con_id);
+ 		gpiod_put(desc);
+ 		return ERR_PTR(status);
+ 	}
+ 
+ 	return desc;
+ }
+ EXPORT_SYMBOL_GPL(gpiod_get_index);
+ 
+ /**
+  * fwnode_get_named_gpiod - obtain a GPIO from firmware node
+  * @fwnode:	handle of the firmware node
+  * @propname:	name of the firmware property representing the GPIO
+  *
+  * This function can be used for drivers that get their configuration
+  * from firmware.
+  *
+  * Function properly finds the corresponding GPIO using whatever is the
+  * underlying firmware interface and then makes sure that the GPIO
+  * descriptor is requested before it is returned to the caller.
+  *
+  * In case of error an ERR_PTR() is returned.
+  */
+ struct gpio_desc *fwnode_get_named_gpiod(struct fwnode_handle *fwnode,
+ 					 const char *propname)
+ {
+ 	struct gpio_desc *desc = ERR_PTR(-ENODEV);
+ 	bool active_low = false;
+ 	int ret;
+ 
+ 	if (!fwnode)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	if (is_of_node(fwnode)) {
+ 		enum of_gpio_flags flags;
+ 
+ 		desc = of_get_named_gpiod_flags(to_of_node(fwnode), propname, 0,
+ 						&flags);
+ 		if (!IS_ERR(desc))
+ 			active_low = flags & OF_GPIO_ACTIVE_LOW;
+ 	} else if (is_acpi_node(fwnode)) {
+ 		struct acpi_gpio_info info;
+ 
+ 		desc = acpi_node_get_gpiod(fwnode, propname, 0, &info);
+ 		if (!IS_ERR(desc))
+ 			active_low = info.active_low;
+ 	}
+ 
+ 	if (IS_ERR(desc))
+ 		return desc;
+ 
+ 	ret = gpiod_request(desc, NULL);
+ 	if (ret)
+ 		return ERR_PTR(ret);
+ 
+ 	/* Only value flag can be set from both DT and ACPI is active_low */
+ 	if (active_low)
++>>>>>>> 504a33749971 (ACPI / property: Extend device_get_next_child_node() to data-only nodes)
  		set_bit(FLAG_ACTIVE_LOW, &desc->flags);
  
  	return desc;
diff --cc include/linux/acpi.h
index 364918faf44f,865d948c60e6..000000000000
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@@ -616,19 -758,21 +616,31 @@@ struct acpi_reference_args 
  #ifdef CONFIG_ACPI
  int acpi_dev_get_property(struct acpi_device *adev, const char *name,
  			  acpi_object_type type, const union acpi_object **obj);
++<<<<<<< HEAD
 +int acpi_dev_get_property_array(struct acpi_device *adev, const char *name,
 +				acpi_object_type type,
 +				const union acpi_object **obj);
 +int acpi_dev_get_property_reference(struct acpi_device *adev, const char *name,
 +				    const char *cells_name, size_t index,
 +				    struct acpi_reference_args *args);
++=======
+ int acpi_node_get_property_reference(struct fwnode_handle *fwnode,
+ 				     const char *name, size_t index,
+ 				     struct acpi_reference_args *args);
++>>>>>>> 504a33749971 (ACPI / property: Extend device_get_next_child_node() to data-only nodes)
  
 -int acpi_node_prop_get(struct fwnode_handle *fwnode, const char *propname,
 -		       void **valptr);
 +int acpi_dev_prop_get(struct acpi_device *adev, const char *propname,
 +		      void **valptr);
  int acpi_dev_prop_read_single(struct acpi_device *adev, const char *propname,
  			      enum dev_prop_type proptype, void *val);
 -int acpi_node_prop_read(struct fwnode_handle *fwnode, const char *propname,
 -		        enum dev_prop_type proptype, void *val, size_t nval);
  int acpi_dev_prop_read(struct acpi_device *adev, const char *propname,
  		       enum dev_prop_type proptype, void *val, size_t nval);
++<<<<<<< HEAD
++=======
+ 
+ struct fwnode_handle *acpi_get_next_subnode(struct device *dev,
+ 					    struct fwnode_handle *subnode);
++>>>>>>> 504a33749971 (ACPI / property: Extend device_get_next_child_node() to data-only nodes)
  #else
  static inline int acpi_dev_get_property(struct acpi_device *adev,
  					const char *name, acpi_object_type type,
@@@ -636,10 -780,10 +648,17 @@@
  {
  	return -ENXIO;
  }
++<<<<<<< HEAD
 +static inline int acpi_dev_get_property_array(struct acpi_device *adev,
 +					      const char *name,
 +					      acpi_object_type type,
 +					      const union acpi_object **obj)
++=======
+ 
+ static inline int acpi_node_get_property_reference(struct fwnode_handle *fwnode,
+ 				const char *name, const char *cells_name,
+ 				size_t index, struct acpi_reference_args *args)
++>>>>>>> 504a33749971 (ACPI / property: Extend device_get_next_child_node() to data-only nodes)
  {
  	return -ENXIO;
  }
@@@ -673,6 -826,11 +692,14 @@@ static inline int acpi_dev_prop_read(st
  	return -ENXIO;
  }
  
++<<<<<<< HEAD
++=======
+ static inline struct fwnode_handle *acpi_get_next_subnode(struct device *dev,
+ 						struct fwnode_handle *subnode)
+ {
+ 	return NULL;
+ }
++>>>>>>> 504a33749971 (ACPI / property: Extend device_get_next_child_node() to data-only nodes)
  #endif
  
  #endif	/*_LINUX_ACPI_H*/
* Unmerged path drivers/gpio/gpiolib.h
* Unmerged path drivers/acpi/property.c
* Unmerged path drivers/acpi/scan.c
* Unmerged path drivers/base/property.c
* Unmerged path drivers/gpio/gpiolib-acpi.c
* Unmerged path drivers/gpio/gpiolib.c
* Unmerged path drivers/gpio/gpiolib.h
* Unmerged path include/linux/acpi.h
