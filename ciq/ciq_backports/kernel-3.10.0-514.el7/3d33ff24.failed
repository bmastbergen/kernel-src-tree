mei: fix device reset on mei_cl_irq_read_msg allocation failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 3d33ff2457355a9dd3c3178b04ab6669882b306c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3d33ff24.failed

On memory allocation failure mei_cl_irq_read_msg will
return with error that will cause device reset.
Instead we should propagate error to caller and
just clean the read queues.

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 3d33ff2457355a9dd3c3178b04ab6669882b306c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/interrupt.c
#	drivers/misc/mei/main.c
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/interrupt.c
index b8d9cfee3e87,587cb04a3cf5..000000000000
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@@ -71,87 -69,93 +71,155 @@@ static inline int mei_cl_hbm_equal(stru
  		cl->me_client_id == mei_hdr->me_addr;
  }
  /**
++<<<<<<< HEAD
 + * mei_cl_is_reading - checks if the client
 +		is the one to read this message
++=======
+  * mei_cl_is_reading - checks if the client is in reading state
++>>>>>>> 3d33ff245735 (mei: fix device reset on mei_cl_irq_read_msg allocation failure)
   *
   * @cl: mei client
-  * @mei_hdr: header of mei message
   *
++<<<<<<< HEAD
 + * returns true on match and false otherwise
++=======
+  * Return: true if the client is reading
++>>>>>>> 3d33ff245735 (mei: fix device reset on mei_cl_irq_read_msg allocation failure)
   */
- static bool mei_cl_is_reading(struct mei_cl *cl, struct mei_msg_hdr *mei_hdr)
+ static bool mei_cl_is_reading(struct mei_cl *cl)
  {
- 	return mei_cl_hbm_equal(cl, mei_hdr) &&
- 		cl->state == MEI_FILE_CONNECTED &&
+ 	return cl->state == MEI_FILE_CONNECTED &&
  		cl->reading_state != MEI_READ_COMPLETE;
  }
  
  /**
 - * mei_cl_irq_read_msg - process client message
 + * mei_irq_read_client_message - process client message
   *
-  * @dev: the device structure
+  * @cl: reading client
   * @mei_hdr: header of mei client message
-  * @complete_list: An instance of our list structure
+  * @complete_list: completion list
   *
++<<<<<<< HEAD
 + * returns 0 on success, <0 on failure.
++=======
+  * Return: always 0
++>>>>>>> 3d33ff245735 (mei: fix device reset on mei_cl_irq_read_msg allocation failure)
   */
- static int mei_cl_irq_read_msg(struct mei_device *dev,
+ static int mei_cl_irq_read_msg(struct mei_cl *cl,
  			       struct mei_msg_hdr *mei_hdr,
  			       struct mei_cl_cb *complete_list)
  {
- 	struct mei_cl *cl;
- 	struct mei_cl_cb *cb, *next;
+ 	struct mei_device *dev = cl->dev;
+ 	struct mei_cl_cb *cb;
  	unsigned char *buffer = NULL;
  
++<<<<<<< HEAD
 +	list_for_each_entry_safe(cb, next, &dev->read_list.list, list) {
 +		cl = cb->cl;
 +		if (!cl || !mei_cl_is_reading(cl, mei_hdr))
 +			continue;
 +
 +		cl->reading_state = MEI_READING;
 +
 +		if (cb->response_buffer.size == 0 ||
 +		    cb->response_buffer.data == NULL) {
 +			cl_err(dev, cl, "response buffer is not allocated.\n");
 +			list_del(&cb->list);
 +			return -ENOMEM;
 +		}
 +
 +		if (cb->response_buffer.size < mei_hdr->length + cb->buf_idx) {
 +			cl_dbg(dev, cl, "message overflow. size %d len %d idx %ld\n",
 +				cb->response_buffer.size,
 +				mei_hdr->length, cb->buf_idx);
 +			buffer = krealloc(cb->response_buffer.data,
 +					  mei_hdr->length + cb->buf_idx,
 +					  GFP_KERNEL);
 +
 +			if (!buffer) {
 +				list_del(&cb->list);
 +				return -ENOMEM;
 +			}
 +			cb->response_buffer.data = buffer;
 +			cb->response_buffer.size =
 +				mei_hdr->length + cb->buf_idx;
 +		}
 +
 +		buffer = cb->response_buffer.data + cb->buf_idx;
 +		mei_read_slots(dev, buffer, mei_hdr->length);
 +
 +		cb->buf_idx += mei_hdr->length;
 +		if (mei_hdr->msg_complete) {
 +			cl->status = 0;
 +			list_del(&cb->list);
 +			cl_dbg(dev, cl, "completed read length = %lu\n",
 +				cb->buf_idx);
 +			list_add_tail(&cb->list, &complete_list->list);
 +		}
 +		break;
 +	}
 +
 +	dev_dbg(&dev->pdev->dev, "message read\n");
++=======
+ 	list_for_each_entry(cb, &dev->read_list.list, list) {
+ 		if (cl == cb->cl)
+ 			break;
+ 	}
+ 
+ 	if (&cb->list == &dev->read_list.list) {
+ 		dev_err(dev->dev, "no reader found\n");
+ 		goto out;
+ 	}
+ 
+ 	if (!mei_cl_is_reading(cl)) {
+ 		cl_err(dev, cl, "cl is not reading state=%d reading state=%d\n",
+ 			cl->state, cl->reading_state);
+ 		goto out;
+ 	}
+ 
+ 	cl->reading_state = MEI_READING;
+ 
+ 	if (cb->response_buffer.size == 0 ||
+ 	    cb->response_buffer.data == NULL) {
+ 		cl_err(dev, cl, "response buffer is not allocated.\n");
+ 		list_move_tail(&cb->list, &complete_list->list);
+ 		cb->status = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	if (cb->response_buffer.size < mei_hdr->length + cb->buf_idx) {
+ 		cl_dbg(dev, cl, "message overflow. size %d len %d idx %ld\n",
+ 			cb->response_buffer.size, mei_hdr->length, cb->buf_idx);
+ 		buffer = krealloc(cb->response_buffer.data,
+ 				  mei_hdr->length + cb->buf_idx,
+ 				  GFP_KERNEL);
+ 
+ 		if (!buffer) {
+ 			cb->status = -ENOMEM;
+ 			list_move_tail(&cb->list, &complete_list->list);
+ 			goto out;
+ 		}
+ 		cb->response_buffer.data = buffer;
+ 		cb->response_buffer.size = mei_hdr->length + cb->buf_idx;
+ 	}
+ 
+ 	buffer = cb->response_buffer.data + cb->buf_idx;
+ 	mei_read_slots(dev, buffer, mei_hdr->length);
+ 
+ 	cb->buf_idx += mei_hdr->length;
+ 	if (mei_hdr->msg_complete) {
+ 		cl_dbg(dev, cl, "completed read length = %lu\n",
+ 			cb->buf_idx);
+ 		list_move_tail(&cb->list, &complete_list->list);
+ 	}
+ 
+ out:
++>>>>>>> 3d33ff245735 (mei: fix device reset on mei_cl_irq_read_msg allocation failure)
  	if (!buffer) {
+ 		/* assume that mei_hdr->length <= MEI_RD_MSG_BUF_SIZE */
+ 		BUG_ON(mei_hdr->length > MEI_RD_MSG_BUF_SIZE);
  		mei_read_slots(dev, dev->rd_msg_buf, mei_hdr->length);
 -		dev_dbg(dev->dev, "discarding message " MEI_HDR_FMT "\n",
 +		dev_dbg(&dev->pdev->dev, "discarding message " MEI_HDR_FMT "\n",
  				MEI_HDR_PRM(mei_hdr));
  	}
  
@@@ -391,14 -395,10 +459,19 @@@ int mei_irq_read_handler(struct mei_dev
  			goto end;
  		}
  	} else {
++<<<<<<< HEAD
 +		ret = mei_cl_irq_read_msg(dev, mei_hdr, cmpl_list);
 +		if (ret) {
 +			dev_err(&dev->pdev->dev, "mei_cl_irq_read_msg failed = %d\n",
 +					ret);
 +			goto end;
 +		}
++=======
+ 		ret = mei_cl_irq_read_msg(cl, mei_hdr, cmpl_list);
++>>>>>>> 3d33ff245735 (mei: fix device reset on mei_cl_irq_read_msg allocation failure)
  	}
  
+ 
  reset_slots:
  	/* reset the number of slots and header */
  	*slots = mei_count_full_read_slots(dev);
diff --cc drivers/misc/mei/main.c
index b23f9eba9e3a,cbdbf4af2bf7..000000000000
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@@ -275,9 -254,16 +277,20 @@@ static ssize_t mei_read(struct file *fi
  		rets = 0;
  		goto out;
  	}
- 	/* now copy the data to user space */
+ 
  copy_buffer:
++<<<<<<< HEAD
 +	dev_dbg(&dev->pdev->dev, "buf.size = %d buf.idx= %ld\n",
++=======
+ 	/* now copy the data to user space */
+ 	if (cb->status) {
+ 		rets = cb->status;
+ 		dev_dbg(dev->dev, "read operation failed %d\n", rets);
+ 		goto free;
+ 	}
+ 
+ 	dev_dbg(dev->dev, "buf.size = %d buf.idx= %ld\n",
++>>>>>>> 3d33ff245735 (mei: fix device reset on mei_cl_irq_read_msg allocation failure)
  	    cb->response_buffer.size, cb->buf_idx);
  	if (length == 0 || ubuf == NULL || *offset > cb->buf_idx) {
  		rets = -EMSGSIZE;
diff --cc drivers/misc/mei/mei_dev.h
index 1b981b70f5aa,195e426b08f0..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -189,8 -191,16 +189,21 @@@ struct mei_cl
  /**
   * struct mei_cl_cb - file operation callback structure
   *
++<<<<<<< HEAD
 + * @cl - file client who is running this operation
 + * @fop_type - file operation type
++=======
+  * @list: link in callback queue
+  * @cl: file client who is running this operation
+  * @fop_type: file operation type
+  * @request_buffer: buffer to store request data
+  * @response_buffer: buffer to store response data
+  * @buf_idx: last read index
+  * @read_time: last read operation time stamp (iamthif)
+  * @file_object: pointer to file structure
+  * @status: io status of the cb
+  * @internal: communication between driver and FW flag
++>>>>>>> 3d33ff245735 (mei: fix device reset on mei_cl_irq_read_msg allocation failure)
   */
  struct mei_cl_cb {
  	struct list_head list;
diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index ca8736c3675b..6d30cc81975f 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -318,10 +318,16 @@ int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 		goto out;
 	}
 
+	if (cb->status) {
+		rets = cb->status;
+		goto free;
+	}
+
 	r_length = min_t(size_t, length, cb->buf_idx);
 
 	memcpy(buf, cb->response_buffer.data, r_length);
 
+free:
 	mei_io_cb_free(cb);
 	cl->reading_state = MEI_IDLE;
 	cl->read_cb = NULL;
* Unmerged path drivers/misc/mei/interrupt.c
* Unmerged path drivers/misc/mei/main.c
* Unmerged path drivers/misc/mei/mei_dev.h
