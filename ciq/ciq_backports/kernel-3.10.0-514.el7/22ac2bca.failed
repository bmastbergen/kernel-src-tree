x86/platform/UV: Fix problem with UV4 BIOS providing incorrect PXM values

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] platform/uv: Fix problem with UV4 BIOS providing incorrect PXM values (Frank Ramsay) [1366020]
Rebuild_FUZZ: 97.18%
commit-author Mike Travis <travis@sgi.com>
commit 22ac2bca92f2d92c6495248d65ff648182df428d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/22ac2bca.failed

There are some circumstances where the UV4 BIOS cannot provide the
correct Proximity Node values to associate with specific Sockets and
Physical Nodes.  The decision was made to remove these values from BIOS
and for the kernel to get these values from the standard ACPI tables.

	Tested-by: Frank Ramsay <framsay@sgi.com>
	Tested-by: John Estabrook <estabrook@sgi.com>
	Signed-off-by: Mike Travis <travis@sgi.com>
	Reviewed-by: Dimitri Sivanich <sivanich@sgi.com>
	Reviewed-by: Nathan Zimmer <nzimmer@sgi.com>
	Cc: Alex Thorlton <athorlton@sgi.com>
	Cc: Andrew Banman <abanman@sgi.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Russ Anderson <rja@sgi.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/20160801184050.414210079@asylum.americas.sgi.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 22ac2bca92f2d92c6495248d65ff648182df428d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/apic/x2apic_uv_x.c
diff --cc arch/x86/kernel/apic/x2apic_uv_x.c
index fd86a4f25c81,6aa0545879bb..000000000000
--- a/arch/x86/kernel/apic/x2apic_uv_x.c
+++ b/arch/x86/kernel/apic/x2apic_uv_x.c
@@@ -1030,9 -1131,244 +1030,244 @@@ void __init uv_init_hub_info(struct uv_
  
  	pr_info("UV: gnode_upper:0x%lx gnode_extra:0x%x\n",
  		hub_info->gnode_upper, hub_info->gnode_extra);
 -}
  
 -static void __init decode_gam_params(unsigned long ptr)
 -{
 -	uv_gp_table = (struct uv_gam_parameters *)ptr;
 +	pr_info("UV: global MMR base 0x%lx\n", hub_info->global_mmr_base);
  
++<<<<<<< HEAD
++=======
+ 	pr_info("UV: GAM Params...\n");
+ 	pr_info("UV: mmr_base/shift:0x%llx/%d gru_base/shift:0x%llx/%d gpa_shift:%d\n",
+ 		uv_gp_table->mmr_base, uv_gp_table->mmr_shift,
+ 		uv_gp_table->gru_base, uv_gp_table->gru_shift,
+ 		uv_gp_table->gpa_shift);
+ }
+ 
+ static void __init decode_gam_rng_tbl(unsigned long ptr)
+ {
+ 	struct uv_gam_range_entry *gre = (struct uv_gam_range_entry *)ptr;
+ 	unsigned long lgre = 0;
+ 	int index = 0;
+ 	int sock_min = 999999, pnode_min = 99999;
+ 	int sock_max = -1, pnode_max = -1;
+ 
+ 	uv_gre_table = gre;
+ 	for (; gre->type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {
+ 		if (!index) {
+ 			pr_info("UV: GAM Range Table...\n");
+ 			pr_info("UV:  # %20s %14s %5s %4s %5s %3s %2s\n",
+ 				"Range", "", "Size", "Type", "NASID",
+ 				"SID", "PN");
+ 		}
+ 		pr_info(
+ 		"UV: %2d: 0x%014lx-0x%014lx %5luG %3d   %04x  %02x %02x\n",
+ 			index++,
+ 			(unsigned long)lgre << UV_GAM_RANGE_SHFT,
+ 			(unsigned long)gre->limit << UV_GAM_RANGE_SHFT,
+ 			((unsigned long)(gre->limit - lgre)) >>
+ 				(30 - UV_GAM_RANGE_SHFT), /* 64M -> 1G */
+ 			gre->type, gre->nasid, gre->sockid, gre->pnode);
+ 
+ 		lgre = gre->limit;
+ 		if (sock_min > gre->sockid)
+ 			sock_min = gre->sockid;
+ 		if (sock_max < gre->sockid)
+ 			sock_max = gre->sockid;
+ 		if (pnode_min > gre->pnode)
+ 			pnode_min = gre->pnode;
+ 		if (pnode_max < gre->pnode)
+ 			pnode_max = gre->pnode;
+ 	}
+ 	_min_socket = sock_min;
+ 	_max_socket = sock_max;
+ 	_min_pnode = pnode_min;
+ 	_max_pnode = pnode_max;
+ 	_gr_table_len = index;
+ 	pr_info(
+ 	"UV: GRT: %d entries, sockets(min:%x,max:%x) pnodes(min:%x,max:%x)\n",
+ 		index, _min_socket, _max_socket, _min_pnode, _max_pnode);
+ }
+ 
+ static void __init decode_uv_systab(void)
+ {
+ 	struct uv_systab *st;
+ 	int i;
+ 
+ 	st = uv_systab;
+ 	if ((!st || st->revision < UV_SYSTAB_VERSION_UV4) && !is_uv4_hub())
+ 		return;
+ 	if (st->revision != UV_SYSTAB_VERSION_UV4_LATEST) {
+ 		pr_crit(
+ 		"UV: BIOS UVsystab version(%x) mismatch, expecting(%x)\n",
+ 			st->revision, UV_SYSTAB_VERSION_UV4_LATEST);
+ 		BUG();
+ 	}
+ 
+ 	for (i = 0; st->entry[i].type != UV_SYSTAB_TYPE_UNUSED; i++) {
+ 		unsigned long ptr = st->entry[i].offset;
+ 
+ 		if (!ptr)
+ 			continue;
+ 
+ 		ptr = ptr + (unsigned long)st;
+ 
+ 		switch (st->entry[i].type) {
+ 		case UV_SYSTAB_TYPE_GAM_PARAMS:
+ 			decode_gam_params(ptr);
+ 			break;
+ 
+ 		case UV_SYSTAB_TYPE_GAM_RNG_TBL:
+ 			decode_gam_rng_tbl(ptr);
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ /*
+  * Setup physical blade translations from UVH_NODE_PRESENT_TABLE
+  * .. NB: UVH_NODE_PRESENT_TABLE is going away,
+  * .. being replaced by GAM Range Table
+  */
+ static __init void boot_init_possible_blades(struct uv_hub_info_s *hub_info)
+ {
+ 	int i, uv_pb = 0;
+ 
+ 	pr_info("UV: NODE_PRESENT_DEPTH = %d\n", UVH_NODE_PRESENT_TABLE_DEPTH);
+ 	for (i = 0; i < UVH_NODE_PRESENT_TABLE_DEPTH; i++) {
+ 		unsigned long np;
+ 
+ 		np = uv_read_local_mmr(UVH_NODE_PRESENT_TABLE + i * 8);
+ 		if (np)
+ 			pr_info("UV: NODE_PRESENT(%d) = 0x%016lx\n", i, np);
+ 
+ 		uv_pb += hweight64(np);
+ 	}
+ 	if (uv_possible_blades != uv_pb)
+ 		uv_possible_blades = uv_pb;
+ }
+ 
+ static void __init build_socket_tables(void)
+ {
+ 	struct uv_gam_range_entry *gre = uv_gre_table;
+ 	int num, nump;
+ 	int cpu, i, lnid;
+ 	int minsock = _min_socket;
+ 	int maxsock = _max_socket;
+ 	int minpnode = _min_pnode;
+ 	int maxpnode = _max_pnode;
+ 	size_t bytes;
+ 
+ 	if (!gre) {
+ 		if (is_uv1_hub() || is_uv2_hub() || is_uv3_hub()) {
+ 			pr_info("UV: No UVsystab socket table, ignoring\n");
+ 			return;		/* not required */
+ 		}
+ 		pr_crit(
+ 		"UV: Error: UVsystab address translations not available!\n");
+ 		BUG();
+ 	}
+ 
+ 	/* build socket id -> node id, pnode */
+ 	num = maxsock - minsock + 1;
+ 	bytes = num * sizeof(_socket_to_node[0]);
+ 	_socket_to_node = kmalloc(bytes, GFP_KERNEL);
+ 	_socket_to_pnode = kmalloc(bytes, GFP_KERNEL);
+ 
+ 	nump = maxpnode - minpnode + 1;
+ 	bytes = nump * sizeof(_pnode_to_socket[0]);
+ 	_pnode_to_socket = kmalloc(bytes, GFP_KERNEL);
+ 	BUG_ON(!_socket_to_node || !_socket_to_pnode || !_pnode_to_socket);
+ 
+ 	for (i = 0; i < num; i++)
+ 		_socket_to_node[i] = _socket_to_pnode[i] = SOCK_EMPTY;
+ 
+ 	for (i = 0; i < nump; i++)
+ 		_pnode_to_socket[i] = SOCK_EMPTY;
+ 
+ 	/* fill in pnode/node/addr conversion list values */
+ 	pr_info("UV: GAM Building socket/pnode conversion tables\n");
+ 	for (; gre->type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {
+ 		if (gre->type == UV_GAM_RANGE_TYPE_HOLE)
+ 			continue;
+ 		i = gre->sockid - minsock;
+ 		if (_socket_to_pnode[i] != SOCK_EMPTY)
+ 			continue;	/* duplicate */
+ 		_socket_to_pnode[i] = gre->pnode;
+ 
+ 		i = gre->pnode - minpnode;
+ 		_pnode_to_socket[i] = gre->sockid;
+ 
+ 		pr_info(
+ 		"UV: sid:%02x type:%d nasid:%04x pn:%02x pn2s:%2x\n",
+ 			gre->sockid, gre->type, gre->nasid,
+ 			_socket_to_pnode[gre->sockid - minsock],
+ 			_pnode_to_socket[gre->pnode - minpnode]);
+ 	}
+ 
+ 	/* Set socket -> node values */
+ 	lnid = -1;
+ 	for_each_present_cpu(cpu) {
+ 		int nid = cpu_to_node(cpu);
+ 		int apicid, sockid;
+ 
+ 		if (lnid == nid)
+ 			continue;
+ 		lnid = nid;
+ 		apicid = per_cpu(x86_cpu_to_apicid, cpu);
+ 		sockid = apicid >> uv_cpuid.socketid_shift;
+ 		_socket_to_node[sockid - minsock] = nid;
+ 		pr_info("UV: sid:%02x: apicid:%04x node:%2d\n",
+ 			sockid, apicid, nid);
+ 	}
+ 
+ 	/* Setup physical blade to pnode translation from GAM Range Table */
+ 	bytes = num_possible_nodes() * sizeof(_node_to_pnode[0]);
+ 	_node_to_pnode = kmalloc(bytes, GFP_KERNEL);
+ 	BUG_ON(!_node_to_pnode);
+ 
+ 	for (lnid = 0; lnid < num_possible_nodes(); lnid++) {
+ 		unsigned short sockid;
+ 
+ 		for (sockid = minsock; sockid <= maxsock; sockid++) {
+ 			if (lnid == _socket_to_node[sockid - minsock]) {
+ 				_node_to_pnode[lnid] =
+ 					_socket_to_pnode[sockid - minsock];
+ 				break;
+ 			}
+ 		}
+ 		if (sockid > maxsock) {
+ 			pr_err("UV: socket for node %d not found!\n", lnid);
+ 			BUG();
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * If socket id == pnode or socket id == node for all nodes,
+ 	 *   system runs faster by removing corresponding conversion table.
+ 	 */
+ 	pr_info("UV: Checking socket->node/pnode for identity maps\n");
+ 	if (minsock == 0) {
+ 		for (i = 0; i < num; i++)
+ 			if (_socket_to_node[i] == SOCK_EMPTY ||
+ 				i != _socket_to_node[i])
+ 				break;
+ 		if (i >= num) {
+ 			kfree(_socket_to_node);
+ 			_socket_to_node = NULL;
+ 			pr_info("UV: 1:1 socket_to_node table removed\n");
+ 		}
+ 	}
+ 	if (minsock == minpnode) {
+ 		for (i = 0; i < num; i++)
+ 			if (_socket_to_pnode[i] != SOCK_EMPTY &&
+ 				_socket_to_pnode[i] != i + minpnode)
+ 				break;
+ 		if (i >= num) {
+ 			kfree(_socket_to_pnode);
+ 			_socket_to_pnode = NULL;
+ 			pr_info("UV: 1:1 socket_to_pnode table removed\n");
+ 		}
+ 	}
++>>>>>>> 22ac2bca92f2 (x86/platform/UV: Fix problem with UV4 BIOS providing incorrect PXM values)
  }
  
  void __init uv_system_init(void)
diff --git a/arch/x86/include/asm/uv/bios.h b/arch/x86/include/asm/uv/bios.h
index c852590254d5..e652a7cc6186 100644
--- a/arch/x86/include/asm/uv/bios.h
+++ b/arch/x86/include/asm/uv/bios.h
@@ -79,7 +79,7 @@ struct uv_gam_range_entry {
 	u16	nasid;		/* HNasid */
 	u16	sockid;		/* Socket ID, high bits of APIC ID */
 	u16	pnode;		/* Index to MMR and GRU spaces */
-	u32	pxm;		/* ACPI proximity domain number */
+	u32	unused2;
 	u32	limit;		/* PA bits 56:26 (UV_GAM_RANGE_SHFT) */
 };
 
@@ -88,7 +88,8 @@ struct uv_gam_range_entry {
 #define	UV_SYSTAB_VERSION_UV4		0x400	/* UV4 BIOS base version */
 #define	UV_SYSTAB_VERSION_UV4_1		0x401	/* + gpa_shift */
 #define	UV_SYSTAB_VERSION_UV4_2		0x402	/* + TYPE_NVRAM/WINDOW/MBOX */
-#define	UV_SYSTAB_VERSION_UV4_LATEST	UV_SYSTAB_VERSION_UV4_2
+#define	UV_SYSTAB_VERSION_UV4_3		0x403	/* - GAM Range PXM Value */
+#define	UV_SYSTAB_VERSION_UV4_LATEST	UV_SYSTAB_VERSION_UV4_3
 
 #define	UV_SYSTAB_TYPE_UNUSED		0	/* End of table (offset == 0) */
 #define	UV_SYSTAB_TYPE_GAM_PARAMS	1	/* GAM PARAM conversions */
* Unmerged path arch/x86/kernel/apic/x2apic_uv_x.c
