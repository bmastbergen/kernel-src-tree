SUNRPC: Enforce an upper limit on the number of cached credentials

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit bae6746ff356478e1a2706072edbfb514072e0ff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bae6746f.failed

In some cases where the credentials are not often reused, we may want
to limit their total number just in order to make the negative lookups
in the hash table more manageable.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit bae6746ff356478e1a2706072edbfb514072e0ff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/auth.c
diff --cc net/sunrpc/auth.c
index 36ad8306c01b,360decdddc78..000000000000
--- a/net/sunrpc/auth.c
+++ b/net/sunrpc/auth.c
@@@ -476,29 -482,60 +480,76 @@@ rpcauth_prune_expired(struct list_head 
  		}
  		spin_unlock(cache_lock);
  	}
 -	return freed;
 +	return (number_cred_unused / 100) * sysctl_vfs_cache_pressure;
  }
  
+ static unsigned long
+ rpcauth_cache_do_shrink(int nr_to_scan)
+ {
+ 	LIST_HEAD(free);
+ 	unsigned long freed;
+ 
+ 	spin_lock(&rpc_credcache_lock);
+ 	freed = rpcauth_prune_expired(&free, nr_to_scan);
+ 	spin_unlock(&rpc_credcache_lock);
+ 	rpcauth_destroy_credlist(&free);
+ 
+ 	return freed;
+ }
+ 
  /*
   * Run memory cache shrinker.
   */
 -static unsigned long
 -rpcauth_cache_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)
 -
 +static int
 +rpcauth_cache_shrinker(struct shrinker *shrink, struct shrink_control *sc)
  {
++<<<<<<< HEAD
 +	LIST_HEAD(free);
 +	int res;
 +	int nr_to_scan = sc->nr_to_scan;
 +	gfp_t gfp_mask = sc->gfp_mask;
 +
 +	if ((gfp_mask & GFP_KERNEL) != GFP_KERNEL)
 +		return (nr_to_scan == 0) ? 0 : -1;
 +	if (list_empty(&cred_unused))
 +		return 0;
 +	spin_lock(&rpc_credcache_lock);
 +	res = rpcauth_prune_expired(&free, nr_to_scan);
 +	spin_unlock(&rpc_credcache_lock);
 +	rpcauth_destroy_credlist(&free);
 +	return res;
++=======
+ 	if ((sc->gfp_mask & GFP_KERNEL) != GFP_KERNEL)
+ 		return SHRINK_STOP;
+ 
+ 	/* nothing left, don't come back */
+ 	if (list_empty(&cred_unused))
+ 		return SHRINK_STOP;
+ 
+ 	return rpcauth_cache_do_shrink(sc->nr_to_scan);
+ }
+ 
+ static unsigned long
+ rpcauth_cache_shrink_count(struct shrinker *shrink, struct shrink_control *sc)
+ 
+ {
+ 	return (number_cred_unused / 100) * sysctl_vfs_cache_pressure;
++>>>>>>> bae6746ff356 (SUNRPC: Enforce an upper limit on the number of cached credentials)
+ }
+ 
+ static void
+ rpcauth_cache_enforce_limit(void)
+ {
+ 	unsigned long diff;
+ 	unsigned int nr_to_scan;
+ 
+ 	if (number_cred_unused <= auth_max_cred_cachesize)
+ 		return;
+ 	diff = number_cred_unused - auth_max_cred_cachesize;
+ 	nr_to_scan = 100;
+ 	if (diff < nr_to_scan)
+ 		nr_to_scan = diff;
+ 	rpcauth_cache_do_shrink(nr_to_scan);
  }
  
  /*
* Unmerged path net/sunrpc/auth.c
