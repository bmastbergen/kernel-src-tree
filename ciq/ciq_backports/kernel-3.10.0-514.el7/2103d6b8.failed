net: sctp: Don't use 64 kilobyte lookup table for four elements

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] sctp: Don't use 64 kilobyte lookup table for four elements (Marcelo Leitner) [1337639]
Rebuild_FUZZ: 95.87%
commit-author Denys Vlasenko <dvlasenk@redhat.com>
commit 2103d6b818fcdae15ffa04cf385f770e6c3892c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2103d6b8.failed

Seemingly innocuous sctp_trans_state_to_prio_map[] array
is way bigger than it looks, since
"[SCTP_UNKNOWN] = 2" expands into "[0xffff] = 2" !

This patch replaces it with switch() statement.

	Signed-off-by: Denys Vlasenko <dvlasenk@redhat.com>
CC: Vlad Yasevich <vyasevich@gmail.com>
CC: Neil Horman <nhorman@tuxdriver.com>
CC: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
CC: linux-sctp@vger.kernel.org
CC: netdev@vger.kernel.org
CC: linux-kernel@vger.kernel.org
	Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Acked-by: Neil Horman <nhorman@tuxdriver.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2103d6b818fcdae15ffa04cf385f770e6c3892c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/associola.c
diff --cc net/sctp/associola.c
index 1df7c2096b1d,b00f1f9611d6..000000000000
--- a/net/sctp/associola.c
+++ b/net/sctp/associola.c
@@@ -1293,72 -1185,192 +1293,153 @@@ void sctp_assoc_update(struct sctp_asso
  }
  
  /* Update the retran path for sending a retransmitted packet.
++<<<<<<< HEAD
 + * Round-robin through the active transports, else round-robin
 + * through the inactive transports as this is the next best thing
 + * we can try.
 + */
++=======
+  * See also RFC4960, 6.4. Multi-Homed SCTP Endpoints:
+  *
+  *   When there is outbound data to send and the primary path
+  *   becomes inactive (e.g., due to failures), or where the
+  *   SCTP user explicitly requests to send data to an
+  *   inactive destination transport address, before reporting
+  *   an error to its ULP, the SCTP endpoint should try to send
+  *   the data to an alternate active destination transport
+  *   address if one exists.
+  *
+  *   When retransmitting data that timed out, if the endpoint
+  *   is multihomed, it should consider each source-destination
+  *   address pair in its retransmission selection policy.
+  *   When retransmitting timed-out data, the endpoint should
+  *   attempt to pick the most divergent source-destination
+  *   pair from the original source-destination pair to which
+  *   the packet was transmitted.
+  *
+  *   Note: Rules for picking the most divergent source-destination
+  *   pair are an implementation decision and are not specified
+  *   within this document.
+  *
+  * Our basic strategy is to round-robin transports in priorities
+  * according to sctp_trans_score() e.g., if no such
+  * transport with state SCTP_ACTIVE exists, round-robin through
+  * SCTP_UNKNOWN, etc. You get the picture.
+  */
+ static u8 sctp_trans_score(const struct sctp_transport *trans)
+ {
+ 	switch (trans->state) {
+ 	case SCTP_ACTIVE:
+ 		return 3;	/* best case */
+ 	case SCTP_UNKNOWN:
+ 		return 2;
+ 	case SCTP_PF:
+ 		return 1;
+ 	default: /* case SCTP_INACTIVE */
+ 		return 0;	/* worst case */
+ 	}
+ }
+ 
+ static struct sctp_transport *sctp_trans_elect_tie(struct sctp_transport *trans1,
+ 						   struct sctp_transport *trans2)
+ {
+ 	if (trans1->error_count > trans2->error_count) {
+ 		return trans2;
+ 	} else if (trans1->error_count == trans2->error_count &&
+ 		   ktime_after(trans2->last_time_heard,
+ 			       trans1->last_time_heard)) {
+ 		return trans2;
+ 	} else {
+ 		return trans1;
+ 	}
+ }
+ 
+ static struct sctp_transport *sctp_trans_elect_best(struct sctp_transport *curr,
+ 						    struct sctp_transport *best)
+ {
+ 	u8 score_curr, score_best;
+ 
+ 	if (best == NULL || curr == best)
+ 		return curr;
+ 
+ 	score_curr = sctp_trans_score(curr);
+ 	score_best = sctp_trans_score(best);
+ 
+ 	/* First, try a score-based selection if both transport states
+ 	 * differ. If we're in a tie, lets try to make a more clever
+ 	 * decision here based on error counts and last time heard.
+ 	 */
+ 	if (score_curr > score_best)
+ 		return curr;
+ 	else if (score_curr == score_best)
+ 		return sctp_trans_elect_tie(curr, best);
+ 	else
+ 		return best;
+ }
+ 
++>>>>>>> 2103d6b818fc (net: sctp: Don't use 64 kilobyte lookup table for four elements)
  void sctp_assoc_update_retran_path(struct sctp_association *asoc)
  {
 -	struct sctp_transport *trans = asoc->peer.retran_path;
 -	struct sctp_transport *trans_next = NULL;
 +	struct sctp_transport *t, *next;
 +	struct list_head *head = &asoc->peer.transport_addr_list;
 +	struct list_head *pos;
  
 -	/* We're done as we only have the one and only path. */
  	if (asoc->peer.transport_count == 1)
  		return;
 -	/* If active_path and retran_path are the same and active,
 -	 * then this is the only active path. Use it.
 -	 */
 -	if (asoc->peer.active_path == asoc->peer.retran_path &&
 -	    asoc->peer.active_path->state == SCTP_ACTIVE)
 -		return;
  
 -	/* Iterate from retran_path's successor back to retran_path. */
 -	for (trans = list_next_entry(trans, transports); 1;
 -	     trans = list_next_entry(trans, transports)) {
 -		/* Manually skip the head element. */
 -		if (&trans->transports == &asoc->peer.transport_addr_list)
 -			continue;
 -		if (trans->state == SCTP_UNCONFIRMED)
 -			continue;
 -		trans_next = sctp_trans_elect_best(trans, trans_next);
 -		/* Active is good enough for immediate return. */
 -		if (trans_next->state == SCTP_ACTIVE)
 -			break;
 -		/* We've reached the end, time to update path. */
 -		if (trans == asoc->peer.retran_path)
 -			break;
 -	}
 +	/* Find the next transport in a round-robin fashion. */
 +	t = asoc->peer.retran_path;
 +	pos = &t->transports;
 +	next = NULL;
  
 -	asoc->peer.retran_path = trans_next;
 +	while (1) {
 +		/* Skip the head. */
 +		if (pos->next == head)
 +			pos = head->next;
 +		else
 +			pos = pos->next;
  
 -	pr_debug("%s: association:%p updated new path to addr:%pISpc\n",
 -		 __func__, asoc, &asoc->peer.retran_path->ipaddr.sa);
 -}
 +		t = list_entry(pos, struct sctp_transport, transports);
  
 -static void sctp_select_active_and_retran_path(struct sctp_association *asoc)
 -{
 -	struct sctp_transport *trans, *trans_pri = NULL, *trans_sec = NULL;
 -	struct sctp_transport *trans_pf = NULL;
 -
 -	/* Look for the two most recently used active transports. */
 -	list_for_each_entry(trans, &asoc->peer.transport_addr_list,
 -			    transports) {
 -		/* Skip uninteresting transports. */
 -		if (trans->state == SCTP_INACTIVE ||
 -		    trans->state == SCTP_UNCONFIRMED)
 -			continue;
 -		/* Keep track of the best PF transport from our
 -		 * list in case we don't find an active one.
 +		/* We have exhausted the list, but didn't find any
 +		 * other active transports.  If so, use the next
 +		 * transport.
  		 */
 -		if (trans->state == SCTP_PF) {
 -			trans_pf = sctp_trans_elect_best(trans, trans_pf);
 -			continue;
 -		}
 -		/* For active transports, pick the most recent ones. */
 -		if (trans_pri == NULL ||
 -		    ktime_after(trans->last_time_heard,
 -				trans_pri->last_time_heard)) {
 -			trans_sec = trans_pri;
 -			trans_pri = trans;
 -		} else if (trans_sec == NULL ||
 -			   ktime_after(trans->last_time_heard,
 -				       trans_sec->last_time_heard)) {
 -			trans_sec = trans;
 +		if (t == asoc->peer.retran_path) {
 +			t = next;
 +			break;
  		}
 -	}
 -
 -	/* RFC 2960 6.4 Multi-Homed SCTP Endpoints
 -	 *
 -	 * By default, an endpoint should always transmit to the primary
 -	 * path, unless the SCTP user explicitly specifies the
 -	 * destination transport address (and possibly source transport
 -	 * address) to use. [If the primary is active but not most recent,
 -	 * bump the most recently used transport.]
 -	 */
 -	if ((asoc->peer.primary_path->state == SCTP_ACTIVE ||
 -	     asoc->peer.primary_path->state == SCTP_UNKNOWN) &&
 -	     asoc->peer.primary_path != trans_pri) {
 -		trans_sec = trans_pri;
 -		trans_pri = asoc->peer.primary_path;
 -	}
  
 -	/* We did not find anything useful for a possible retransmission
 -	 * path; either primary path that we found is the the same as
 -	 * the current one, or we didn't generally find an active one.
 -	 */
 -	if (trans_sec == NULL)
 -		trans_sec = trans_pri;
 +		/* Try to find an active transport. */
  
 -	/* If we failed to find a usable transport, just camp on the
 -	 * active or pick a PF iff it's the better choice.
 -	 */
 -	if (trans_pri == NULL) {
 -		trans_pri = sctp_trans_elect_best(asoc->peer.active_path, trans_pf);
 -		trans_sec = trans_pri;
 +		if ((t->state == SCTP_ACTIVE) ||
 +		    (t->state == SCTP_UNKNOWN)) {
 +			break;
 +		} else {
 +			/* Keep track of the next transport in case
 +			 * we don't find any active transport.
 +			 */
 +			if (t->state != SCTP_UNCONFIRMED && !next)
 +				next = t;
 +		}
  	}
  
 -	/* Set the active and retran transports. */
 -	asoc->peer.active_path = trans_pri;
 -	asoc->peer.retran_path = trans_sec;
 +	if (t)
 +		asoc->peer.retran_path = t;
 +	else
 +		t = asoc->peer.retran_path;
 +
 +	SCTP_DEBUG_PRINTK_IPADDR("sctp_assoc_update_retran_path:association"
 +				 " %p addr: ",
 +				 " port: %d\n",
 +				 asoc,
 +				 (&t->ipaddr),
 +				 ntohs(t->ipaddr.v4.sin_port));
  }
  
 -struct sctp_transport *
 -sctp_assoc_choose_alter_transport(struct sctp_association *asoc,
 -				  struct sctp_transport *last_sent_to)
 +/* Choose the transport for sending retransmit packet.  */
 +struct sctp_transport *sctp_assoc_choose_alter_transport(
 +	struct sctp_association *asoc, struct sctp_transport *last_sent_to)
  {
  	/* If this is the first time packet is sent, use the active path,
  	 * else use the retran path. If the last packet was sent over the
* Unmerged path net/sctp/associola.c
