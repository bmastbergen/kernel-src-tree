mmc: sdhci check parameters before call dma_free_coherent

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] sdhci check parameters before call dma_free_coherent (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 95.41%
commit-author Peng Fan <van.freenix@gmail.com>
commit 7ac020366b0a436d726408841160b5dc32c19214
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7ac02036.failed

We should not call dma_free_coherent if host->adma_table is NULL,
otherwise may trigger panic.

Fixes: d1e49f77d7c7 ("mmc: sdhci: convert ADMA descriptors to a...")
	Signed-off-by: Peng Fan <van.freenix@gmail.com>
	Acked-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 7ac020366b0a436d726408841160b5dc32c19214)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci.c
diff --cc drivers/mmc/host/sdhci.c
index 48682666d1e9,655900f55244..000000000000
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@@ -2957,23 -2944,47 +2957,31 @@@ int sdhci_add_host(struct sdhci_host *h
  		}
  	}
  
 -	/* SDMA does not support 64-bit DMA */
 -	if (host->flags & SDHCI_USE_64_BIT_DMA)
 -		host->flags &= ~SDHCI_USE_SDMA;
 -
  	if (host->flags & SDHCI_USE_ADMA) {
  		/*
 -		 * The DMA descriptor table size is calculated as the maximum
 -		 * number of segments times 2, to allow for an alignment
 -		 * descriptor for each segment, plus 1 for a nop end descriptor,
 -		 * all multipled by the descriptor size.
 +		 * We need to allocate descriptors for all sg entries
 +		 * (128) and potentially one alignment transfer for
 +		 * each of those entries.
  		 */
 -		if (host->flags & SDHCI_USE_64_BIT_DMA) {
 -			host->adma_table_sz = (SDHCI_MAX_SEGS * 2 + 1) *
 -					      SDHCI_ADMA2_64_DESC_SZ;
 -			host->align_buffer_sz = SDHCI_MAX_SEGS *
 -						SDHCI_ADMA2_64_ALIGN;
 -			host->desc_sz = SDHCI_ADMA2_64_DESC_SZ;
 -			host->align_sz = SDHCI_ADMA2_64_ALIGN;
 -			host->align_mask = SDHCI_ADMA2_64_ALIGN - 1;
 -		} else {
 -			host->adma_table_sz = (SDHCI_MAX_SEGS * 2 + 1) *
 -					      SDHCI_ADMA2_32_DESC_SZ;
 -			host->align_buffer_sz = SDHCI_MAX_SEGS *
 -						SDHCI_ADMA2_32_ALIGN;
 -			host->desc_sz = SDHCI_ADMA2_32_DESC_SZ;
 -			host->align_sz = SDHCI_ADMA2_32_ALIGN;
 -			host->align_mask = SDHCI_ADMA2_32_ALIGN - 1;
 -		}
  		host->adma_table = dma_alloc_coherent(mmc_dev(mmc),
 -						      host->adma_table_sz,
 +						      ADMA_SIZE,
  						      &host->adma_addr,
  						      GFP_KERNEL);
 -		host->align_buffer = kmalloc(host->align_buffer_sz, GFP_KERNEL);
 +		host->align_buffer = kmalloc(128 * 4, GFP_KERNEL);
  		if (!host->adma_table || !host->align_buffer) {
++<<<<<<< HEAD
 +			dma_free_coherent(mmc_dev(mmc), ADMA_SIZE,
 +					  host->adma_table, host->adma_addr);
++=======
+ 			if (host->adma_table)
+ 				dma_free_coherent(mmc_dev(mmc),
+ 						  host->adma_table_sz,
+ 						  host->adma_table,
+ 						  host->adma_addr);
++>>>>>>> 7ac020366b0a (mmc: sdhci check parameters before call dma_free_coherent)
  			kfree(host->align_buffer);
 -			pr_warn("%s: Unable to allocate ADMA buffers - falling back to standard DMA\n",
 +			pr_warning("%s: Unable to allocate ADMA "
 +				"buffers. Falling back to standard DMA.\n",
  				mmc_hostname(mmc));
  			host->flags &= ~SDHCI_USE_ADMA;
  			host->adma_table = NULL;
* Unmerged path drivers/mmc/host/sdhci.c
