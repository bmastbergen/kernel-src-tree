perf tools: Fix column width setting on 'trace' sort key

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit 0c0af78d472f96efe04daaaccede7522b2394b76
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0c0af78d.failed

It missed to update column length of the 'trace' sort key in the
hists__calc_col_len() so it might truncate the output.  It calculated
the column length in the ->cmp() callback originally but it doesn't
guarantee it's called always.

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/1456064558-13086-5-git-send-email-namhyung@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 0c0af78d472f96efe04daaaccede7522b2394b76)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/sort.c
diff --cc tools/perf/util/sort.c
index efcd20c0a639,6d0f85894f38..000000000000
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@@ -430,6 -425,88 +430,91 @@@ struct sort_entry sort_cpu = 
  	.se_width_idx	= HISTC_CPU,
  };
  
++<<<<<<< HEAD
++=======
+ /* --sort socket */
+ 
+ static int64_t
+ sort__socket_cmp(struct hist_entry *left, struct hist_entry *right)
+ {
+ 	return right->socket - left->socket;
+ }
+ 
+ static int hist_entry__socket_snprintf(struct hist_entry *he, char *bf,
+ 				    size_t size, unsigned int width)
+ {
+ 	return repsep_snprintf(bf, size, "%*.*d", width, width-3, he->socket);
+ }
+ 
+ struct sort_entry sort_socket = {
+ 	.se_header      = "Socket",
+ 	.se_cmp	        = sort__socket_cmp,
+ 	.se_snprintf    = hist_entry__socket_snprintf,
+ 	.se_width_idx	= HISTC_SOCKET,
+ };
+ 
+ /* --sort trace */
+ 
+ static char *get_trace_output(struct hist_entry *he)
+ {
+ 	struct trace_seq seq;
+ 	struct perf_evsel *evsel;
+ 	struct pevent_record rec = {
+ 		.data = he->raw_data,
+ 		.size = he->raw_size,
+ 	};
+ 
+ 	evsel = hists_to_evsel(he->hists);
+ 
+ 	trace_seq_init(&seq);
+ 	if (symbol_conf.raw_trace) {
+ 		pevent_print_fields(&seq, he->raw_data, he->raw_size,
+ 				    evsel->tp_format);
+ 	} else {
+ 		pevent_event_info(&seq, evsel->tp_format, &rec);
+ 	}
+ 	return seq.buffer;
+ }
+ 
+ static int64_t
+ sort__trace_cmp(struct hist_entry *left, struct hist_entry *right)
+ {
+ 	struct perf_evsel *evsel;
+ 
+ 	evsel = hists_to_evsel(left->hists);
+ 	if (evsel->attr.type != PERF_TYPE_TRACEPOINT)
+ 		return 0;
+ 
+ 	if (left->trace_output == NULL)
+ 		left->trace_output = get_trace_output(left);
+ 	if (right->trace_output == NULL)
+ 		right->trace_output = get_trace_output(right);
+ 
+ 	return strcmp(right->trace_output, left->trace_output);
+ }
+ 
+ static int hist_entry__trace_snprintf(struct hist_entry *he, char *bf,
+ 				    size_t size, unsigned int width)
+ {
+ 	struct perf_evsel *evsel;
+ 
+ 	evsel = hists_to_evsel(he->hists);
+ 	if (evsel->attr.type != PERF_TYPE_TRACEPOINT)
+ 		return scnprintf(bf, size, "%-.*s", width, "N/A");
+ 
+ 	if (he->trace_output == NULL)
+ 		he->trace_output = get_trace_output(he);
+ 	return repsep_snprintf(bf, size, "%-.*s", width, he->trace_output);
+ }
+ 
+ struct sort_entry sort_trace = {
+ 	.se_header      = "Trace output",
+ 	.se_cmp	        = sort__trace_cmp,
+ 	.se_snprintf    = hist_entry__trace_snprintf,
+ 	.se_width_idx	= HISTC_TRACE,
+ };
+ 
++>>>>>>> 0c0af78d472f (perf tools: Fix column width setting on 'trace' sort key)
  /* sort keys for branch stacks */
  
  static int64_t
diff --git a/tools/perf/util/hist.c b/tools/perf/util/hist.c
index 17f64502833e..1cd7c8bd895e 100644
--- a/tools/perf/util/hist.c
+++ b/tools/perf/util/hist.c
@@ -176,6 +176,9 @@ void hists__calc_col_len(struct hists *hists, struct hist_entry *h)
 	if (h->transaction)
 		hists__new_col_len(hists, HISTC_TRANSACTION,
 				   hist_entry__transaction_len());
+
+	if (h->trace_output)
+		hists__new_col_len(hists, HISTC_TRACE, strlen(h->trace_output));
 }
 
 void hists__output_recalc_col_len(struct hists *hists, int max_rows)
* Unmerged path tools/perf/util/sort.c
