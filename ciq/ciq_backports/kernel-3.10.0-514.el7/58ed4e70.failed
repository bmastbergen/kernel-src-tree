ovl: store ovl_entry in inode->i_private for all inodes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 58ed4e70f253d80ed72faba7873dc11603b398bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/58ed4e70.failed

Previously this was only done for directory inodes.  Doing so for all
inodes makes for a nice cleanup in ovl_permission at zero cost.

Inodes are not shared for hard links on the overlay, so this works fine.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 58ed4e70f253d80ed72faba7873dc11603b398bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/inode.c
diff --cc fs/overlayfs/inode.c
index cec7c3f64b1e,32ae8b49a72c..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -147,30 -161,23 +125,26 @@@ int ovl_permission(struct inode *inode
  		 * constructed return EROFS to prevent modification of
  		 * upper layer.
  		 */
- 		err = -EROFS;
  		if (is_upper && !IS_RDONLY(inode) && IS_RDONLY(realinode) &&
  		    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
- 			goto out_dput;
+ 			return -EROFS;
  	}
  
- 	err = __inode_permission(realinode, mask);
- out_dput:
- 	dput(alias);
- 	return err;
+ 	return __inode_permission(realinode, mask);
  }
  
 -static const char *ovl_get_link(struct dentry *dentry,
 -				struct inode *inode,
 -				struct delayed_call *done)
 +
 +struct ovl_link_data {
 +	struct dentry *realdentry;
 +	void *cookie;
 +};
 +
 +static void *ovl_follow_link(struct dentry *dentry, struct nameidata *nd)
  {
 +	void *ret;
  	struct dentry *realdentry;
  	struct inode *realinode;
 -
 -	if (!dentry)
 -		return ERR_PTR(-ECHILD);
 +	struct ovl_link_data *data = NULL;
  
  	realdentry = ovl_dentry_real(dentry);
  	realinode = realdentry->d_inode;
@@@ -431,10 -384,8 +406,14 @@@ struct inode *ovl_new_inode(struct supe
  	mode &= S_IFMT;
  	switch (mode) {
  	case S_IFDIR:
++<<<<<<< HEAD
 +		inode->i_private = oe;
 +		inode->i_op = &ovl_dir_inode_operations.ops;
++=======
+ 		inode->i_op = &ovl_dir_inode_operations;
++>>>>>>> 58ed4e70f253 (ovl: store ovl_entry in inode->i_private for all inodes)
  		inode->i_fop = &ovl_dir_operations;
 +		inode->i_flags |= S_IOPS_WRAPPER;
  		break;
  
  	case S_IFLNK:
* Unmerged path fs/overlayfs/inode.c
