mmc: dw_mmc: add support for the other bit of sdio interrupt

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Addy Ke <addy.ke@rock-chips.com>
commit 767562348b72cb2612f5991ad35a5c0448254939
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/76756234.failed

The bit of sdio interrupt is 16 in designware implementation,
but it is 24 on Rockchip SoCs.This patch add sdio_id0 for the
number of slot0 in the SDIO interrupt registers.

	Signed-off-by: Addy Ke <addy.ke@rock-chips.com>
	Reviewed-by: Doug Anderson <dianders@chromium.org>
	Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 767562348b72cb2612f5991ad35a5c0448254939)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/dw_mmc-rockchip.c
#	drivers/mmc/host/dw_mmc.h
diff --cc drivers/mmc/host/dw_mmc.h
index f894414bb248,0d0f7a271d63..000000000000
--- a/drivers/mmc/host/dw_mmc.h
+++ b/drivers/mmc/host/dw_mmc.h
@@@ -191,6 -210,50 +191,53 @@@ extern int dw_mci_resume(struct dw_mci 
  #endif
  
  /**
++<<<<<<< HEAD
++=======
+  * struct dw_mci_slot - MMC slot state
+  * @mmc: The mmc_host representing this slot.
+  * @host: The MMC controller this slot is using.
+  * @quirks: Slot-level quirks (DW_MCI_SLOT_QUIRK_XXX)
+  * @ctype: Card type for this slot.
+  * @mrq: mmc_request currently being processed or waiting to be
+  *	processed, or NULL when the slot is idle.
+  * @queue_node: List node for placing this node in the @queue list of
+  *	&struct dw_mci.
+  * @clock: Clock rate configured by set_ios(). Protected by host->lock.
+  * @__clk_old: The last updated clock with reflecting clock divider.
+  *	Keeping track of this helps us to avoid spamming the console
+  *	with CONFIG_MMC_CLKGATE.
+  * @flags: Random state bits associated with the slot.
+  * @id: Number of this slot.
+  * @sdio_id: Number of this slot in the SDIO interrupt registers.
+  */
+ struct dw_mci_slot {
+ 	struct mmc_host		*mmc;
+ 	struct dw_mci		*host;
+ 
+ 	int			quirks;
+ 
+ 	u32			ctype;
+ 
+ 	struct mmc_request	*mrq;
+ 	struct list_head	queue_node;
+ 
+ 	unsigned int		clock;
+ 	unsigned int		__clk_old;
+ 
+ 	unsigned long		flags;
+ #define DW_MMC_CARD_PRESENT	0
+ #define DW_MMC_CARD_NEED_INIT	1
+ 	int			id;
+ 	int			sdio_id;
+ };
+ 
+ struct dw_mci_tuning_data {
+ 	const u8 *blk_pattern;
+ 	unsigned int blksz;
+ };
+ 
+ /**
++>>>>>>> 767562348b72 (mmc: dw_mmc: add support for the other bit of sdio interrupt)
   * dw_mci driver data - dw-mshc implementation specific driver data.
   * @caps: mmc subsystem specified capabilities of the controller(s).
   * @init: early implementation specific initialization.
* Unmerged path drivers/mmc/host/dw_mmc-rockchip.c
* Unmerged path drivers/mmc/host/dw_mmc-rockchip.c
diff --git a/drivers/mmc/host/dw_mmc.c b/drivers/mmc/host/dw_mmc.c
index 1add727a3cc5..b710df675202 100644
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@ -759,7 +759,7 @@ static void dw_mci_setup_bus(struct dw_mci_slot *slot, bool force_clkinit)
 
 		/* enable clock; only low power if no SDIO */
 		clk_en_a = SDMMC_CLKEN_ENABLE << slot->id;
-		if (!(mci_readl(host, INTMASK) & SDMMC_INT_SDIO(slot->id)))
+		if (!(mci_readl(host, INTMASK) & SDMMC_INT_SDIO(slot->sdio_id)))
 			clk_en_a |= SDMMC_CLKEN_LOW_PWR << slot->id;
 		mci_writel(host, CLKENA, clk_en_a);
 
@@ -1025,10 +1025,10 @@ static void dw_mci_enable_sdio_irq(struct mmc_host *mmc, int enb)
 		dw_mci_disable_low_power(slot);
 
 		mci_writel(host, INTMASK,
-			   (int_mask | SDMMC_INT_SDIO(slot->id)));
+			   (int_mask | SDMMC_INT_SDIO(slot->sdio_id)));
 	} else {
 		mci_writel(host, INTMASK,
-			   (int_mask & ~SDMMC_INT_SDIO(slot->id)));
+			   (int_mask & ~SDMMC_INT_SDIO(slot->sdio_id)));
 	}
 }
 
@@ -1760,8 +1760,9 @@ static irqreturn_t dw_mci_interrupt(int irq, void *dev_id)
 		/* Handle SDIO Interrupts */
 		for (i = 0; i < host->num_slots; i++) {
 			struct dw_mci_slot *slot = host->slot[i];
-			if (pending & SDMMC_INT_SDIO(i)) {
-				mci_writel(host, RINTSTS, SDMMC_INT_SDIO(i));
+			if (pending & SDMMC_INT_SDIO(slot->sdio_id)) {
+				mci_writel(host, RINTSTS,
+					   SDMMC_INT_SDIO(slot->sdio_id));
 				mmc_signal_sdio_irq(slot->mmc);
 			}
 		}
@@ -2006,6 +2007,7 @@ static int dw_mci_init_slot(struct dw_mci *host, unsigned int id)
 
 	slot = mmc_priv(mmc);
 	slot->id = id;
+	slot->sdio_id = host->sdio_id0 + id;
 	slot->mmc = mmc;
 	slot->host = host;
 	host->slot[id] = slot;
* Unmerged path drivers/mmc/host/dw_mmc.h
diff --git a/include/linux/mmc/dw_mmc.h b/include/linux/mmc/dw_mmc.h
index a578603b514c..cb8eaf70c1d0 100644
--- a/include/linux/mmc/dw_mmc.h
+++ b/include/linux/mmc/dw_mmc.h
@@ -93,6 +93,7 @@ struct mmc_data;
  * @quirks: Set of quirks that apply to specific versions of the IP.
  * @irq_flags: The flags to be passed to request_irq.
  * @irq: The irq value to be passed to request_irq.
+ * @sdio_id0: Number of slot0 in the SDIO interrupt registers.
  *
  * Locking
  * =======
@@ -189,6 +190,8 @@ struct dw_mci {
 	struct regulator	*vmmc;	/* Power regulator */
 	unsigned long		irq_flags; /* IRQ flags */
 	int			irq;
+
+	int			sdio_id0;
 };
 
 /* DMA ops for Internal/External DMAC interface */
