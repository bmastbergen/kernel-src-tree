net: introduce change upper device notifier change info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] introduce change upper device notifier change info (Ivan Vecera) [1268334]
Rebuild_FUZZ: 95.24%
commit-author Jiri Pirko <jiri@mellanox.com>
commit 0e4ead9d7b3655d76371604abb9b0dcc4e79bb7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0e4ead9d.failed

Add info that is passed along with NETDEV_CHANGEUPPER event.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0e4ead9d7b3655d76371604abb9b0dcc4e79bb7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/core/dev.c
diff --cc include/linux/netdevice.h
index eb7e9fa3e472,39f30daac483..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1941,6 -2116,36 +1941,38 @@@ struct pcpu_sw_netstats 
  
  int register_netdevice_notifier(struct notifier_block *nb);
  int unregister_netdevice_notifier(struct notifier_block *nb);
++<<<<<<< HEAD
++=======
+ 
+ struct netdev_notifier_info {
+ 	struct net_device *dev;
+ };
+ 
+ struct netdev_notifier_change_info {
+ 	struct netdev_notifier_info info; /* must be first */
+ 	unsigned int flags_changed;
+ };
+ 
+ struct netdev_notifier_changeupper_info {
+ 	struct netdev_notifier_info info; /* must be first */
+ 	struct net_device *upper_dev; /* new upper dev */
+ 	bool master; /* is upper dev master */
+ 	bool linking; /* is the nofication for link or unlink */
+ };
+ 
+ static inline void netdev_notifier_info_init(struct netdev_notifier_info *info,
+ 					     struct net_device *dev)
+ {
+ 	info->dev = dev;
+ }
+ 
+ static inline struct net_device *
+ netdev_notifier_info_to_dev(const struct netdev_notifier_info *info)
+ {
+ 	return info->dev;
+ }
+ 
++>>>>>>> 0e4ead9d7b36 (net: introduce change upper device notifier change info)
  int call_netdevice_notifiers(unsigned long val, struct net_device *dev);
  
  
diff --cc net/core/dev.c
index ce5758e98847,a8e6cf4298d3..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -4603,118 -4973,347 +4603,124 @@@ static struct netdev_adjacent *__netdev
  {
  	struct netdev_adjacent *upper;
  
 -	WARN_ON_ONCE(!rcu_read_lock_held() && !lockdep_rtnl_is_held());
 -
 -	upper = list_entry_rcu((*iter)->next, struct netdev_adjacent, list);
 -
 -	if (&upper->list == &dev->all_adj_list.upper)
 -		return NULL;
 -
 -	*iter = &upper->list;
 -
 -	return upper->dev;
 -}
 -EXPORT_SYMBOL(netdev_all_upper_get_next_dev_rcu);
 -
 -/**
 - * netdev_lower_get_next_private - Get the next ->private from the
 - *				   lower neighbour list
 - * @dev: device
 - * @iter: list_head ** of the current position
 - *
 - * Gets the next netdev_adjacent->private from the dev's lower neighbour
 - * list, starting from iter position. The caller must hold either hold the
 - * RTNL lock or its own locking that guarantees that the neighbour lower
 - * list will remain unchanged.
 - */
 -void *netdev_lower_get_next_private(struct net_device *dev,
 -				    struct list_head **iter)
 -{
 -	struct netdev_adjacent *lower;
 -
 -	lower = list_entry(*iter, struct netdev_adjacent, list);
 -
 -	if (&lower->list == &dev->adj_list.lower)
 -		return NULL;
 -
 -	*iter = lower->list.next;
 -
 -	return lower->private;
 -}
 -EXPORT_SYMBOL(netdev_lower_get_next_private);
 -
 -/**
 - * netdev_lower_get_next_private_rcu - Get the next ->private from the
 - *				       lower neighbour list, RCU
 - *				       variant
 - * @dev: device
 - * @iter: list_head ** of the current position
 - *
 - * Gets the next netdev_adjacent->private from the dev's lower neighbour
 - * list, starting from iter position. The caller must hold RCU read lock.
 - */
 -void *netdev_lower_get_next_private_rcu(struct net_device *dev,
 -					struct list_head **iter)
 -{
 -	struct netdev_adjacent *lower;
 -
 -	WARN_ON_ONCE(!rcu_read_lock_held());
 -
 -	lower = list_entry_rcu((*iter)->next, struct netdev_adjacent, list);
 -
 -	if (&lower->list == &dev->adj_list.lower)
 -		return NULL;
 -
 -	*iter = &lower->list;
 -
 -	return lower->private;
 -}
 -EXPORT_SYMBOL(netdev_lower_get_next_private_rcu);
 -
 -/**
 - * netdev_lower_get_next - Get the next device from the lower neighbour
 - *                         list
 - * @dev: device
 - * @iter: list_head ** of the current position
 - *
 - * Gets the next netdev_adjacent from the dev's lower neighbour
 - * list, starting from iter position. The caller must hold RTNL lock or
 - * its own locking that guarantees that the neighbour lower
 - * list will remain unchanged.
 - */
 -void *netdev_lower_get_next(struct net_device *dev, struct list_head **iter)
 -{
 -	struct netdev_adjacent *lower;
 -
 -	lower = list_entry((*iter)->next, struct netdev_adjacent, list);
 -
 -	if (&lower->list == &dev->adj_list.lower)
 -		return NULL;
 -
 -	*iter = &lower->list;
 -
 -	return lower->dev;
 -}
 -EXPORT_SYMBOL(netdev_lower_get_next);
 -
 -/**
 - * netdev_lower_get_first_private_rcu - Get the first ->private from the
 - *				       lower neighbour list, RCU
 - *				       variant
 - * @dev: device
 - *
 - * Gets the first netdev_adjacent->private from the dev's lower neighbour
 - * list. The caller must hold RCU read lock.
 - */
 -void *netdev_lower_get_first_private_rcu(struct net_device *dev)
 -{
 -	struct netdev_adjacent *lower;
 -
 -	lower = list_first_or_null_rcu(&dev->adj_list.lower,
 -			struct netdev_adjacent, list);
 -	if (lower)
 -		return lower->private;
 +	list_for_each_entry(upper, &dev->upper_dev_list, list) {
 +		if (upper->dev == upper_dev)
 +			return upper;
 +	}
  	return NULL;
  }
 -EXPORT_SYMBOL(netdev_lower_get_first_private_rcu);
  
  /**
 - * netdev_master_upper_dev_get_rcu - Get master upper device
 + * netdev_has_upper_dev - Check if device is linked to an upper device
   * @dev: device
 + * @upper_dev: upper device to check
   *
 - * Find a master upper device and return pointer to it or NULL in case
 - * it's not there. The caller must hold the RCU read lock.
 + * Find out if a device is linked to specified upper device and return true
 + * in case it is. Note that this checks only immediate upper device,
 + * not through a complete stack of devices. The caller must hold the RTNL lock.
   */
 -struct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev)
 -{
 -	struct netdev_adjacent *upper;
 -
 -	upper = list_first_or_null_rcu(&dev->adj_list.upper,
 -				       struct netdev_adjacent, list);
 -	if (upper && likely(upper->master))
 -		return upper->dev;
 -	return NULL;
 -}
 -EXPORT_SYMBOL(netdev_master_upper_dev_get_rcu);
 -
 -static int netdev_adjacent_sysfs_add(struct net_device *dev,
 -			      struct net_device *adj_dev,
 -			      struct list_head *dev_list)
 -{
 -	char linkname[IFNAMSIZ+7];
 -	sprintf(linkname, dev_list == &dev->adj_list.upper ?
 -		"upper_%s" : "lower_%s", adj_dev->name);
 -	return sysfs_create_link(&(dev->dev.kobj), &(adj_dev->dev.kobj),
 -				 linkname);
 -}
 -static void netdev_adjacent_sysfs_del(struct net_device *dev,
 -			       char *name,
 -			       struct list_head *dev_list)
 -{
 -	char linkname[IFNAMSIZ+7];
 -	sprintf(linkname, dev_list == &dev->adj_list.upper ?
 -		"upper_%s" : "lower_%s", name);
 -	sysfs_remove_link(&(dev->dev.kobj), linkname);
 -}
 -
 -static inline bool netdev_adjacent_is_neigh_list(struct net_device *dev,
 -						 struct net_device *adj_dev,
 -						 struct list_head *dev_list)
 -{
 -	return (dev_list == &dev->adj_list.upper ||
 -		dev_list == &dev->adj_list.lower) &&
 -		net_eq(dev_net(dev), dev_net(adj_dev));
 -}
 -
 -static int __netdev_adjacent_dev_insert(struct net_device *dev,
 -					struct net_device *adj_dev,
 -					struct list_head *dev_list,
 -					void *private, bool master)
 -{
 -	struct netdev_adjacent *adj;
 -	int ret;
 -
 -	adj = __netdev_find_adj(dev, adj_dev, dev_list);
 -
 -	if (adj) {
 -		adj->ref_nr++;
 -		return 0;
 -	}
 -
 -	adj = kmalloc(sizeof(*adj), GFP_KERNEL);
 -	if (!adj)
 -		return -ENOMEM;
 -
 -	adj->dev = adj_dev;
 -	adj->master = master;
 -	adj->ref_nr = 1;
 -	adj->private = private;
 -	dev_hold(adj_dev);
 -
 -	pr_debug("dev_hold for %s, because of link added from %s to %s\n",
 -		 adj_dev->name, dev->name, adj_dev->name);
 -
 -	if (netdev_adjacent_is_neigh_list(dev, adj_dev, dev_list)) {
 -		ret = netdev_adjacent_sysfs_add(dev, adj_dev, dev_list);
 -		if (ret)
 -			goto free_adj;
 -	}
 -
 -	/* Ensure that master link is always the first item in list. */
 -	if (master) {
 -		ret = sysfs_create_link(&(dev->dev.kobj),
 -					&(adj_dev->dev.kobj), "master");
 -		if (ret)
 -			goto remove_symlinks;
 -
 -		list_add_rcu(&adj->list, dev_list);
 -	} else {
 -		list_add_tail_rcu(&adj->list, dev_list);
 -	}
 -
 -	return 0;
 -
 -remove_symlinks:
 -	if (netdev_adjacent_is_neigh_list(dev, adj_dev, dev_list))
 -		netdev_adjacent_sysfs_del(dev, adj_dev->name, dev_list);
 -free_adj:
 -	kfree(adj);
 -	dev_put(adj_dev);
 -
 -	return ret;
 -}
 -
 -static void __netdev_adjacent_dev_remove(struct net_device *dev,
 -					 struct net_device *adj_dev,
 -					 struct list_head *dev_list)
 +bool netdev_has_upper_dev(struct net_device *dev,
 +			  struct net_device *upper_dev)
  {
 -	struct netdev_adjacent *adj;
 -
 -	adj = __netdev_find_adj(dev, adj_dev, dev_list);
 -
 -	if (!adj) {
 -		pr_err("tried to remove device %s from %s\n",
 -		       dev->name, adj_dev->name);
 -		BUG();
 -	}
 -
 -	if (adj->ref_nr > 1) {
 -		pr_debug("%s to %s ref_nr-- = %d\n", dev->name, adj_dev->name,
 -			 adj->ref_nr-1);
 -		adj->ref_nr--;
 -		return;
 -	}
 +	ASSERT_RTNL();
  
 -	if (adj->master)
 -		sysfs_remove_link(&(dev->dev.kobj), "master");
 +	return __netdev_find_upper(dev, upper_dev);
 +}
 +EXPORT_SYMBOL(netdev_has_upper_dev);
  
 -	if (netdev_adjacent_is_neigh_list(dev, adj_dev, dev_list))
 -		netdev_adjacent_sysfs_del(dev, adj_dev->name, dev_list);
 +/**
 + * netdev_has_any_upper_dev - Check if device is linked to some device
 + * @dev: device
 + *
 + * Find out if a device is linked to an upper device and return true in case
 + * it is. The caller must hold the RTNL lock.
 + */
 +bool netdev_has_any_upper_dev(struct net_device *dev)
 +{
 +	ASSERT_RTNL();
  
 -	list_del_rcu(&adj->list);
 -	pr_debug("dev_put for %s, because link removed from %s to %s\n",
 -		 adj_dev->name, dev->name, adj_dev->name);
 -	dev_put(adj_dev);
 -	kfree_rcu(adj, rcu);
 +	return !list_empty(&dev->upper_dev_list);
  }
 +EXPORT_SYMBOL(netdev_has_any_upper_dev);
  
 -static int __netdev_adjacent_dev_link_lists(struct net_device *dev,
 -					    struct net_device *upper_dev,
 -					    struct list_head *up_list,
 -					    struct list_head *down_list,
 -					    void *private, bool master)
 +/**
 + * netdev_master_upper_dev_get - Get master upper device
 + * @dev: device
 + *
 + * Find a master upper device and return pointer to it or NULL in case
 + * it's not there. The caller must hold the RTNL lock.
 + */
 +struct net_device *netdev_master_upper_dev_get(struct net_device *dev)
  {
 -	int ret;
 -
 -	ret = __netdev_adjacent_dev_insert(dev, upper_dev, up_list, private,
 -					   master);
 -	if (ret)
 -		return ret;
 +	struct netdev_adjacent *upper;
  
 -	ret = __netdev_adjacent_dev_insert(upper_dev, dev, down_list, private,
 -					   false);
 -	if (ret) {
 -		__netdev_adjacent_dev_remove(dev, upper_dev, up_list);
 -		return ret;
 -	}
 +	ASSERT_RTNL();
  
 -	return 0;
 -}
 +	if (list_empty(&dev->upper_dev_list))
 +		return NULL;
  
 -static int __netdev_adjacent_dev_link(struct net_device *dev,
 -				      struct net_device *upper_dev)
 -{
 -	return __netdev_adjacent_dev_link_lists(dev, upper_dev,
 -						&dev->all_adj_list.upper,
 -						&upper_dev->all_adj_list.lower,
 -						NULL, false);
 +	upper = list_first_entry(&dev->upper_dev_list,
 +				 struct netdev_adjacent, list);
 +	if (likely(upper->master))
 +		return upper->dev;
 +	return NULL;
  }
 +EXPORT_SYMBOL(netdev_master_upper_dev_get);
  
 -static void __netdev_adjacent_dev_unlink_lists(struct net_device *dev,
 -					       struct net_device *upper_dev,
 -					       struct list_head *up_list,
 -					       struct list_head *down_list)
 +/* netdev_upper_get_next_dev_rcu - Get the next dev from upper list
 + * @dev: device
 + * @iter: list_head ** of the current position
 + *
 + * Gets the next device from the dev's upper list, starting from iter
 + * position. The caller must hold RCU read lock.
 + */
 +struct net_device *netdev_upper_get_next_dev_rcu(struct net_device *dev,
 +						 struct list_head **iter)
  {
 -	__netdev_adjacent_dev_remove(dev, upper_dev, up_list);
 -	__netdev_adjacent_dev_remove(upper_dev, dev, down_list);
 -}
 +	struct netdev_adjacent *upper;
  
 -static void __netdev_adjacent_dev_unlink(struct net_device *dev,
 -					 struct net_device *upper_dev)
 -{
 -	__netdev_adjacent_dev_unlink_lists(dev, upper_dev,
 -					   &dev->all_adj_list.upper,
 -					   &upper_dev->all_adj_list.lower);
 -}
 +	WARN_ON_ONCE(!rcu_read_lock_held() && !lockdep_rtnl_is_held());
  
 -static int __netdev_adjacent_dev_link_neighbour(struct net_device *dev,
 -						struct net_device *upper_dev,
 -						void *private, bool master)
 -{
 -	int ret = __netdev_adjacent_dev_link(dev, upper_dev);
 +	upper = list_entry_rcu((*iter)->next, struct netdev_adjacent, list);
  
 -	if (ret)
 -		return ret;
 +	if (&upper->list == &dev->upper_dev_list)
 +		return NULL;
  
 -	ret = __netdev_adjacent_dev_link_lists(dev, upper_dev,
 -					       &dev->adj_list.upper,
 -					       &upper_dev->adj_list.lower,
 -					       private, master);
 -	if (ret) {
 -		__netdev_adjacent_dev_unlink(dev, upper_dev);
 -		return ret;
 -	}
 +	*iter = &upper->list;
  
 -	return 0;
 +	return upper->dev;
  }
 +EXPORT_SYMBOL(netdev_upper_get_next_dev_rcu);
  
 -static void __netdev_adjacent_dev_unlink_neighbour(struct net_device *dev,
 -						   struct net_device *upper_dev)
 +/**
 + * netdev_master_upper_dev_get_rcu - Get master upper device
 + * @dev: device
 + *
 + * Find a master upper device and return pointer to it or NULL in case
 + * it's not there. The caller must hold the RCU read lock.
 + */
 +struct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev)
  {
 -	__netdev_adjacent_dev_unlink(dev, upper_dev);
 -	__netdev_adjacent_dev_unlink_lists(dev, upper_dev,
 -					   &dev->adj_list.upper,
 -					   &upper_dev->adj_list.lower);
 +	struct netdev_adjacent *upper;
 +
 +	upper = list_first_or_null_rcu(&dev->upper_dev_list,
 +				       struct netdev_adjacent, list);
 +	if (upper && likely(upper->master))
 +		return upper->dev;
 +	return NULL;
  }
 +EXPORT_SYMBOL(netdev_master_upper_dev_get_rcu);
  
  static int __netdev_upper_dev_link(struct net_device *dev,
 -				   struct net_device *upper_dev, bool master,
 -				   void *private)
 +				   struct net_device *upper_dev, bool master)
  {
++<<<<<<< HEAD
 +	struct netdev_adjacent *upper;
++=======
+ 	struct netdev_notifier_changeupper_info changeupper_info;
+ 	struct netdev_adjacent *i, *j, *to_i, *to_j;
+ 	int ret = 0;
++>>>>>>> 0e4ead9d7b36 (net: introduce change upper device notifier change info)
  
  	ASSERT_RTNL();
  
@@@ -4731,22 -5330,88 +4737,47 @@@
  	if (master && netdev_master_upper_dev_get(dev))
  		return -EBUSY;
  
++<<<<<<< HEAD
 +	upper = kmalloc(sizeof(*upper), GFP_KERNEL);
 +	if (!upper)
 +		return -ENOMEM;
++=======
+ 	changeupper_info.upper_dev = upper_dev;
+ 	changeupper_info.master = master;
+ 	changeupper_info.linking = true;
+ 
+ 	ret = __netdev_adjacent_dev_link_neighbour(dev, upper_dev, private,
+ 						   master);
+ 	if (ret)
+ 		return ret;
++>>>>>>> 0e4ead9d7b36 (net: introduce change upper device notifier change info)
  
 -	/* Now that we linked these devs, make all the upper_dev's
 -	 * all_adj_list.upper visible to every dev's all_adj_list.lower an
 -	 * versa, and don't forget the devices itself. All of these
 -	 * links are non-neighbours.
 -	 */
 -	list_for_each_entry(i, &dev->all_adj_list.lower, list) {
 -		list_for_each_entry(j, &upper_dev->all_adj_list.upper, list) {
 -			pr_debug("Interlinking %s with %s, non-neighbour\n",
 -				 i->dev->name, j->dev->name);
 -			ret = __netdev_adjacent_dev_link(i->dev, j->dev);
 -			if (ret)
 -				goto rollback_mesh;
 -		}
 -	}
 +	upper->dev = upper_dev;
 +	upper->master = master;
 +	INIT_LIST_HEAD(&upper->search_list);
  
 -	/* add dev to every upper_dev's upper device */
 -	list_for_each_entry(i, &upper_dev->all_adj_list.upper, list) {
 -		pr_debug("linking %s's upper device %s with %s\n",
 -			 upper_dev->name, i->dev->name, dev->name);
 -		ret = __netdev_adjacent_dev_link(dev, i->dev);
 -		if (ret)
 -			goto rollback_upper_mesh;
 -	}
 +	/* Ensure that master upper link is always the first item in list. */
 +	if (master)
 +		list_add_rcu(&upper->list, &dev->upper_dev_list);
 +	else
 +		list_add_tail_rcu(&upper->list, &dev->upper_dev_list);
 +	dev_hold(upper_dev);
  
++<<<<<<< HEAD
++=======
+ 	/* add upper_dev to every dev's lower device */
+ 	list_for_each_entry(i, &dev->all_adj_list.lower, list) {
+ 		pr_debug("linking %s's lower device %s with %s\n", dev->name,
+ 			 i->dev->name, upper_dev->name);
+ 		ret = __netdev_adjacent_dev_link(i->dev, upper_dev);
+ 		if (ret)
+ 			goto rollback_lower_mesh;
+ 	}
+ 
+ 	call_netdevice_notifiers_info(NETDEV_CHANGEUPPER, dev,
+ 				      &changeupper_info.info);
++>>>>>>> 0e4ead9d7b36 (net: introduce change upper device notifier change info)
  	return 0;
 -
 -rollback_lower_mesh:
 -	to_i = i;
 -	list_for_each_entry(i, &dev->all_adj_list.lower, list) {
 -		if (i == to_i)
 -			break;
 -		__netdev_adjacent_dev_unlink(i->dev, upper_dev);
 -	}
 -
 -	i = NULL;
 -
 -rollback_upper_mesh:
 -	to_i = i;
 -	list_for_each_entry(i, &upper_dev->all_adj_list.upper, list) {
 -		if (i == to_i)
 -			break;
 -		__netdev_adjacent_dev_unlink(dev, i->dev);
 -	}
 -
 -	i = j = NULL;
 -
 -rollback_mesh:
 -	to_i = i;
 -	to_j = j;
 -	list_for_each_entry(i, &dev->all_adj_list.lower, list) {
 -		list_for_each_entry(j, &upper_dev->all_adj_list.upper, list) {
 -			if (i == to_i && j == to_j)
 -				break;
 -			__netdev_adjacent_dev_unlink(i->dev, j->dev);
 -		}
 -		if (i == to_i)
 -			break;
 -	}
 -
 -	__netdev_adjacent_dev_unlink_neighbour(dev, upper_dev);
 -
 -	return ret;
  }
  
  /**
@@@ -4795,16 -5468,35 +4826,48 @@@ EXPORT_SYMBOL(netdev_master_upper_dev_l
  void netdev_upper_dev_unlink(struct net_device *dev,
  			     struct net_device *upper_dev)
  {
++<<<<<<< HEAD
 +	struct netdev_adjacent *upper;
 +
 +	ASSERT_RTNL();
 +
 +	upper = __netdev_find_upper(dev, upper_dev);
 +	if (!upper)
 +		return;
 +	list_del_rcu(&upper->list);
 +	dev_put(upper_dev);
 +	kfree_rcu(upper, rcu);
++=======
+ 	struct netdev_notifier_changeupper_info changeupper_info;
+ 	struct netdev_adjacent *i, *j;
+ 	ASSERT_RTNL();
+ 
+ 	changeupper_info.upper_dev = upper_dev;
+ 	changeupper_info.master = netdev_master_upper_dev_get(dev) == upper_dev;
+ 	changeupper_info.linking = false;
+ 
+ 	__netdev_adjacent_dev_unlink_neighbour(dev, upper_dev);
+ 
+ 	/* Here is the tricky part. We must remove all dev's lower
+ 	 * devices from all upper_dev's upper devices and vice
+ 	 * versa, to maintain the graph relationship.
+ 	 */
+ 	list_for_each_entry(i, &dev->all_adj_list.lower, list)
+ 		list_for_each_entry(j, &upper_dev->all_adj_list.upper, list)
+ 			__netdev_adjacent_dev_unlink(i->dev, j->dev);
+ 
+ 	/* remove also the devices itself from lower/upper device
+ 	 * list
+ 	 */
+ 	list_for_each_entry(i, &dev->all_adj_list.lower, list)
+ 		__netdev_adjacent_dev_unlink(i->dev, upper_dev);
+ 
+ 	list_for_each_entry(i, &upper_dev->all_adj_list.upper, list)
+ 		__netdev_adjacent_dev_unlink(dev, i->dev);
+ 
+ 	call_netdevice_notifiers_info(NETDEV_CHANGEUPPER, dev,
+ 				      &changeupper_info.info);
++>>>>>>> 0e4ead9d7b36 (net: introduce change upper device notifier change info)
  }
  EXPORT_SYMBOL(netdev_upper_dev_unlink);
  
* Unmerged path include/linux/netdevice.h
* Unmerged path net/core/dev.c
