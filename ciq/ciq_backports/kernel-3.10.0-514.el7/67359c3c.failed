ixgbe: Add support for VXLAN RX offloads

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mark Rustad <mark.d.rustad@intel.com>
commit 67359c3c9fc8e9fbed991bbe0cfeda55c7e0a64c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/67359c3c.failed

Add support for VXLAN RX offloads for the X55x devices that support
them.

	Signed-off-by: Mark Rustad <mark.d.rustad@intel.com>
	Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 67359c3c9fc8e9fbed991bbe0cfeda55c7e0a64c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe.h
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe.h
index 4ac9978176ba,8830c0fb5ffb..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
@@@ -779,6 -761,9 +783,12 @@@ struct ixgbe_adapter 
  	u32 timer_event_accumulator;
  	u32 vferr_refcount;
  	struct ixgbe_mac_addr *mac_table;
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_IXGBE_VXLAN
+ 	u16 vxlan_port;
+ #endif
++>>>>>>> 67359c3c9fc8 (ixgbe: Add support for VXLAN RX offloads)
  	struct kobject *info_kobj;
  #ifdef CONFIG_IXGBE_HWMON
  	struct hwmon_buff *ixgbe_hwmon_buff;
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index aeecc9891f88,dcf849ddb7ce..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -64,10 -79,10 +67,10 @@@ char ixgbe_default_device_descr[] 
  static char ixgbe_default_device_descr[] =
  			      "Intel(R) 10 Gigabit Network Connection";
  #endif
 -#define DRV_VERSION "4.0.1-k"
 +#define DRV_VERSION "4.0.1-k-rh7.2"
  const char ixgbe_driver_version[] = DRV_VERSION;
  static const char ixgbe_copyright[] =
- 				"Copyright (c) 1999-2014 Intel Corporation.";
+ 				"Copyright (c) 1999-2015 Intel Corporation.";
  
  static const char ixgbe_overheat_msg[] = "Network adapter has been stopped because it has over heated. Restart the computer. If the problem persists, power off the system and replace the adapter";
  
@@@ -1405,6 -1429,12 +1408,15 @@@ static inline void ixgbe_rx_checksum(st
  	if (!(ring->netdev->features & NETIF_F_RXCSUM))
  		return;
  
++<<<<<<< HEAD
++=======
+ 	if ((pkt_info & cpu_to_le16(IXGBE_RXDADV_PKTTYPE_VXLAN)) &&
+ 	    (hdr_info & cpu_to_le16(IXGBE_RXDADV_PKTTYPE_TUNNEL >> 16))) {
+ 		encap_pkt = true;
+ 		skb->encapsulation = 1;
+ 	}
+ 
++>>>>>>> 67359c3c9fc8 (ixgbe: Add support for VXLAN RX offloads)
  	/* if IP and error */
  	if (ixgbe_test_staterr(rx_desc, IXGBE_RXD_STAT_IPCS) &&
  	    ixgbe_test_staterr(rx_desc, IXGBE_RXDADV_ERR_IPE)) {
@@@ -5517,6 -5773,11 +5547,14 @@@ static int ixgbe_open(struct net_devic
  
  	ixgbe_up_complete(adapter);
  
++<<<<<<< HEAD
++=======
+ 	ixgbe_clear_vxlan_port(adapter);
+ #ifdef CONFIG_IXGBE_VXLAN
+ 	vxlan_get_rx_port(netdev);
+ #endif
+ 
++>>>>>>> 67359c3c9fc8 (ixgbe: Add support for VXLAN RX offloads)
  	return 0;
  
  err_set_queues:
@@@ -7636,9 -8009,72 +7719,75 @@@ static int ixgbe_set_features(struct ne
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_IXGBE_VXLAN
+ /**
+  * ixgbe_add_vxlan_port - Get notifications about VXLAN ports that come up
+  * @dev: The port's netdev
+  * @sa_family: Socket Family that VXLAN is notifiying us about
+  * @port: New UDP port number that VXLAN started listening to
+  **/
+ static void ixgbe_add_vxlan_port(struct net_device *dev, sa_family_t sa_family,
+ 				 __be16 port)
+ {
+ 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	u16 new_port = ntohs(port);
+ 
+ 	if (!(adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE))
+ 		return;
+ 
+ 	if (sa_family == AF_INET6)
+ 		return;
+ 
+ 	if (adapter->vxlan_port == new_port)
+ 		return;
+ 
+ 	if (adapter->vxlan_port) {
+ 		netdev_info(dev,
+ 			    "Hit Max num of VXLAN ports, not adding port %d\n",
+ 			    new_port);
+ 		return;
+ 	}
+ 
+ 	adapter->vxlan_port = new_port;
+ 	IXGBE_WRITE_REG(hw, IXGBE_VXLANCTRL, new_port);
+ }
+ 
+ /**
+  * ixgbe_del_vxlan_port - Get notifications about VXLAN ports that go away
+  * @dev: The port's netdev
+  * @sa_family: Socket Family that VXLAN is notifying us about
+  * @port: UDP port number that VXLAN stopped listening to
+  **/
+ static void ixgbe_del_vxlan_port(struct net_device *dev, sa_family_t sa_family,
+ 				 __be16 port)
+ {
+ 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+ 	u16 new_port = ntohs(port);
+ 
+ 	if (!(adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE))
+ 		return;
+ 
+ 	if (sa_family == AF_INET6)
+ 		return;
+ 
+ 	if (adapter->vxlan_port != new_port) {
+ 		netdev_info(dev, "Port %d was not found, not deleting\n",
+ 			    new_port);
+ 		return;
+ 	}
+ 
+ 	ixgbe_clear_vxlan_port(adapter);
+ 	adapter->flags2 |= IXGBE_FLAG2_VXLAN_REREG_NEEDED;
+ }
+ #endif /* CONFIG_IXGBE_VXLAN */
+ 
++>>>>>>> 67359c3c9fc8 (ixgbe: Add support for VXLAN RX offloads)
  static int ixgbe_ndo_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
  			     struct net_device *dev,
 -			     const unsigned char *addr, u16 vid,
 +			     const unsigned char *addr,
  			     u16 flags)
  {
  	/* guarantee we can provide a unique filter for the unicast address */
@@@ -7817,6 -8359,13 +7966,16 @@@ static const struct net_device_ops ixgb
  	.ndo_fdb_add		= ixgbe_ndo_fdb_add,
  	.ndo_bridge_setlink	= ixgbe_ndo_bridge_setlink,
  	.ndo_bridge_getlink	= ixgbe_ndo_bridge_getlink,
++<<<<<<< HEAD
++=======
+ 	.ndo_dfwd_add_station	= ixgbe_fwd_add,
+ 	.ndo_dfwd_del_station	= ixgbe_fwd_del,
+ #ifdef CONFIG_IXGBE_VXLAN
+ 	.ndo_add_vxlan_port	= ixgbe_add_vxlan_port,
+ 	.ndo_del_vxlan_port	= ixgbe_del_vxlan_port,
+ #endif /* CONFIG_IXGBE_VXLAN */
+ 	.ndo_features_check	= ixgbe_features_check,
++>>>>>>> 67359c3c9fc8 (ixgbe: Add support for VXLAN RX offloads)
  };
  
  /**
@@@ -8156,6 -8728,22 +8315,22 @@@ skip_sriov
  	netdev->priv_flags |= IFF_UNICAST_FLT;
  	netdev->priv_flags |= IFF_SUPP_NOFCS;
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_IXGBE_VXLAN
+ 	switch (adapter->hw.mac.type) {
+ 	case ixgbe_mac_X550:
+ 	case ixgbe_mac_X550EM_x:
+ 		netdev->hw_enc_features |= NETIF_F_RXCSUM |
+ 					   NETIF_F_IP_CSUM |
+ 					   NETIF_F_IPV6_CSUM;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ #endif /* CONFIG_IXGBE_VXLAN */
+ 
++>>>>>>> 67359c3c9fc8 (ixgbe: Add support for VXLAN RX offloads)
  #ifdef CONFIG_IXGBE_DCB
  	netdev->dcbnl_ops = &dcbnl_ops;
  #endif
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe.h
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
index d91044297062..dd7062fed61a 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
@@ -1519,20 +1519,28 @@ static u32 ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input,
  *  @input: unique input dword
  *  @common: compressed common input dword
  *  @queue: queue index to direct traffic to
+ *
+ * Note that the tunnel bit in input must not be set when the hardware
+ * tunneling support does not exist.
  **/
 s32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw,
 					  union ixgbe_atr_hash_dword input,
 					  union ixgbe_atr_hash_dword common,
 					  u8 queue)
 {
-	u64  fdirhashcmd;
-	u32  fdircmd;
+	u64 fdirhashcmd;
+	u8 flow_type;
+	bool tunnel;
+	u32 fdircmd;
 
 	/*
 	 * Get the flow_type in order to program FDIRCMD properly
 	 * lowest 2 bits are FDIRCMD.L4TYPE, third lowest bit is FDIRCMD.IPV6
 	 */
-	switch (input.formatted.flow_type) {
+	tunnel = !!(input.formatted.flow_type & IXGBE_ATR_L4TYPE_TUNNEL_MASK);
+	flow_type = input.formatted.flow_type &
+		    (IXGBE_ATR_L4TYPE_TUNNEL_MASK - 1);
+	switch (flow_type) {
 	case IXGBE_ATR_FLOW_TYPE_TCPV4:
 	case IXGBE_ATR_FLOW_TYPE_UDPV4:
 	case IXGBE_ATR_FLOW_TYPE_SCTPV4:
@@ -1548,8 +1556,10 @@ s32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw,
 	/* configure FDIRCMD register */
 	fdircmd = IXGBE_FDIRCMD_CMD_ADD_FLOW | IXGBE_FDIRCMD_FILTER_UPDATE |
 		  IXGBE_FDIRCMD_LAST | IXGBE_FDIRCMD_QUEUE_EN;
-	fdircmd |= input.formatted.flow_type << IXGBE_FDIRCMD_FLOW_TYPE_SHIFT;
+	fdircmd |= (u32)flow_type << IXGBE_FDIRCMD_FLOW_TYPE_SHIFT;
 	fdircmd |= (u32)queue << IXGBE_FDIRCMD_RX_QUEUE_SHIFT;
+	if (tunnel)
+		fdircmd |= IXGBE_FDIRCMD_TUNNEL_FILTER;
 
 	/*
 	 * The lower 32-bits of fdirhashcmd is for FDIRHASH, the upper 32-bits
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
index 96580388d0fc..8041a7abed8d 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
@@ -2534,9 +2534,11 @@ enum ixgbe_fdir_pballoc_type {
 #define IXGBE_FDIRCMD_QUEUE_EN                  0x00008000
 #define IXGBE_FDIRCMD_FLOW_TYPE_SHIFT           5
 #define IXGBE_FDIRCMD_RX_QUEUE_SHIFT            16
+#define IXGBE_FDIRCMD_RX_TUNNEL_FILTER_SHIFT	23
 #define IXGBE_FDIRCMD_VT_POOL_SHIFT             24
 #define IXGBE_FDIR_INIT_DONE_POLL               10
 #define IXGBE_FDIRCMD_CMD_POLL                  10
+#define IXGBE_FDIRCMD_TUNNEL_FILTER		0x00800000
 
 #define IXGBE_FDIR_DROP_QUEUE                   127
 
@@ -2827,12 +2829,13 @@ typedef u32 ixgbe_link_speed;
 #define IXGBE_ATR_SIGNATURE_HASH_KEY 0x174D3614
 
 /* Software ATR input stream values and masks */
-#define IXGBE_ATR_HASH_MASK     0x7fff
-#define IXGBE_ATR_L4TYPE_MASK      0x3
-#define IXGBE_ATR_L4TYPE_UDP       0x1
-#define IXGBE_ATR_L4TYPE_TCP       0x2
-#define IXGBE_ATR_L4TYPE_SCTP      0x3
-#define IXGBE_ATR_L4TYPE_IPV6_MASK 0x4
+#define IXGBE_ATR_HASH_MASK		0x7fff
+#define IXGBE_ATR_L4TYPE_MASK		0x3
+#define IXGBE_ATR_L4TYPE_UDP		0x1
+#define IXGBE_ATR_L4TYPE_TCP		0x2
+#define IXGBE_ATR_L4TYPE_SCTP		0x3
+#define IXGBE_ATR_L4TYPE_IPV6_MASK	0x4
+#define IXGBE_ATR_L4TYPE_TUNNEL_MASK	0x10
 enum ixgbe_atr_flow_type {
 	IXGBE_ATR_FLOW_TYPE_IPV4   = 0x0,
 	IXGBE_ATR_FLOW_TYPE_UDPV4  = 0x1,
