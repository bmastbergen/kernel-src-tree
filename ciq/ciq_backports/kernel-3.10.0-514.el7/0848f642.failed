inet: frags: fix defragmented packet's IP header for af_packet

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Edward Hyunkoo Jee <edjee@google.com>
commit 0848f6428ba3a2e42db124d41ac6f548655735bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0848f642.failed

When ip_frag_queue() computes positions, it assumes that the passed
sk_buff does not contain L2 headers.

However, when PACKET_FANOUT_FLAG_DEFRAG is used, IP reassembly
functions can be called on outgoing packets that contain L2 headers.

Also, IPv4 checksum is not corrected after reassembly.

Fixes: 7736d33f4262 ("packet: Add pre-defragmentation support for ipv4 fanouts.")
	Signed-off-by: Edward Hyunkoo Jee <edjee@google.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Willem de Bruijn <willemb@google.com>
	Cc: Jerry Chu <hkchu@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0848f6428ba3a2e42db124d41ac6f548655735bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ip_fragment.c
diff --cc net/ipv4/ip_fragment.c
index c10a3ce5cbff,31f71b15cfba..000000000000
--- a/net/ipv4/ip_fragment.c
+++ b/net/ipv4/ip_fragment.c
@@@ -387,7 -381,7 +387,11 @@@ static int ip_frag_queue(struct ipq *qp
  		goto err;
  
  	err = -ENOMEM;
++<<<<<<< HEAD
 +	if (pskb_pull(skb, ihl) == NULL)
++=======
+ 	if (!pskb_pull(skb, skb_network_offset(skb) + ihl))
++>>>>>>> 0848f6428ba3 (inet: frags: fix defragmented packet's IP header for af_packet)
  		goto err;
  
  	err = pskb_trim_rcsum(skb, end - offset);
@@@ -621,13 -620,29 +625,34 @@@ static int ip_frag_reasm(struct ipq *qp
  	head->next = NULL;
  	head->dev = dev;
  	head->tstamp = qp->q.stamp;
 -	IPCB(head)->frag_max_size = max(qp->max_df_size, qp->q.max_size);
 +	IPCB(head)->frag_max_size = qp->q.max_size;
  
  	iph = ip_hdr(head);
 +	/* max_size != 0 implies at least one fragment had IP_DF set */
 +	iph->frag_off = qp->q.max_size ? htons(IP_DF) : 0;
  	iph->tot_len = htons(len);
  	iph->tos |= ecn;
++<<<<<<< HEAD
++=======
+ 
+ 	/* When we set IP_DF on a refragmented skb we must also force a
+ 	 * call to ip_fragment to avoid forwarding a DF-skb of size s while
+ 	 * original sender only sent fragments of size f (where f < s).
+ 	 *
+ 	 * We only set DF/IPSKB_FRAG_PMTU if such DF fragment was the largest
+ 	 * frag seen to avoid sending tiny DF-fragments in case skb was built
+ 	 * from one very small df-fragment and one large non-df frag.
+ 	 */
+ 	if (qp->max_df_size == qp->q.max_size) {
+ 		IPCB(head)->flags |= IPSKB_FRAG_PMTU;
+ 		iph->frag_off = htons(IP_DF);
+ 	} else {
+ 		iph->frag_off = 0;
+ 	}
+ 
+ 	ip_send_check(iph);
+ 
++>>>>>>> 0848f6428ba3 (inet: frags: fix defragmented packet's IP header for af_packet)
  	IP_INC_STATS_BH(net, IPSTATS_MIB_REASMOKS);
  	qp->q.fragments = NULL;
  	qp->q.fragments_tail = NULL;
* Unmerged path net/ipv4/ip_fragment.c
