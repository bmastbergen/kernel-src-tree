mmc: tmio: mmc: tmio: tmio_mmc_data has .chan_priv_?x

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
commit f33c9d655893d8632460696bbbdee737cb315711
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f33c9d65.failed

dma_request_slave_channel_compat() in tmio_mmc_dma
needs .chan_priv_tx/.chan_priv_rx. But these are copied from
sh_mobile_sdhi only, and sh_mobile_sdhi_info is now almost
same as tmio_mmc_data except .chan_priv_?x.
sh_mobile_sdhi_info can be replaced to tmio_mmc_data, but it is
used from ${LINUX}/arch/arm/mach-shmobile, ${LINUX}/arch/sh.
So, this patch adds .chan_priv_?x into tmio_mmc_data as 1st step,
and sh_mobile_sdhi driver has dummy operation for now.
It will be replaced/removed together with platform data replace.

	Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
	Acked-by: Arnd Bergmann <arnd@arndb.de>
	Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
	Acked-by: Lee Jones <lee.jones@linaro.org>
	Signed-off-by: Vinod Koul <vinod.koul@intel.com>
(cherry picked from commit f33c9d655893d8632460696bbbdee737cb315711)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sh_mobile_sdhi.c
#	drivers/mmc/host/tmio_mmc.h
#	drivers/mmc/host/tmio_mmc_dma.c
diff --cc drivers/mmc/host/sh_mobile_sdhi.c
index 79ee6f0c45bd,3137e292270e..000000000000
--- a/drivers/mmc/host/sh_mobile_sdhi.c
+++ b/drivers/mmc/host/sh_mobile_sdhi.c
@@@ -126,10 -201,17 +126,11 @@@ static int sh_mobile_sdhi_probe(struct 
  		of_match_device(sh_mobile_sdhi_of_match, &pdev->dev);
  	struct sh_mobile_sdhi *priv;
  	struct tmio_mmc_data *mmc_data;
+ 	struct tmio_mmc_data *mmd = pdev->dev.platform_data;
  	struct sh_mobile_sdhi_info *p = pdev->dev.platform_data;
  	struct tmio_mmc_host *host;
 -	struct resource *res;
  	int irq, ret, i = 0;
  	bool multiplexed_isr = true;
 -	struct tmio_mmc_dma *dma_priv;
 -
 -	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 -	if (!res)
 -		return -EINVAL;
  
  	priv = devm_kzalloc(&pdev->dev, sizeof(struct sh_mobile_sdhi), GFP_KERNEL);
  	if (priv == NULL) {
@@@ -151,39 -226,57 +152,90 @@@
  	if (IS_ERR(priv->clk)) {
  		ret = PTR_ERR(priv->clk);
  		dev_err(&pdev->dev, "cannot get clock: %d\n", ret);
 -		goto eprobe;
 +		goto eclkget;
  	}
  
++<<<<<<< HEAD
 +	mmc_data->clk_enable = sh_mobile_sdhi_clk_enable;
 +	mmc_data->clk_disable = sh_mobile_sdhi_clk_disable;
 +	mmc_data->capabilities = MMC_CAP_MMC_HIGHSPEED;
 +	mmc_data->write16_hook = sh_mobile_sdhi_write16_hook;
 +	if (p) {
 +		mmc_data->flags = p->tmio_flags;
 +		mmc_data->ocr_mask = p->tmio_ocr_mask;
 +		mmc_data->capabilities |= p->tmio_caps;
 +		mmc_data->capabilities2 |= p->tmio_caps2;
 +		mmc_data->cd_gpio = p->cd_gpio;
 +
 +		if (p->dma_slave_tx > 0 && p->dma_slave_rx > 0) {
 +			struct tmio_mmc_dma *dma_priv = &priv->dma_priv;
 +
 +			/*
 +			 * Yes, we have to provide slave IDs twice to TMIO:
 +			 * once as a filter parameter and once for channel
 +			 * configuration as an explicit slave ID
 +			 */
 +			dma_priv->chan_priv_tx = (void *)p->dma_slave_tx;
 +			dma_priv->chan_priv_rx = (void *)p->dma_slave_rx;
 +			dma_priv->slave_id_tx = p->dma_slave_tx;
 +			dma_priv->slave_id_rx = p->dma_slave_rx;
 +
 +			dma_priv->alignment_shift = 1; /* 2-byte alignment */
 +			dma_priv->filter = shdma_chan_filter;
 +
 +			mmc_data->dma = dma_priv;
 +		}
 +	}
++=======
+ 	host = tmio_mmc_host_alloc(pdev);
+ 	if (!host) {
+ 		ret = -ENOMEM;
+ 		goto eprobe;
+ 	}
+ 
+ 	host->dma		= dma_priv;
+ 	host->write16_hook	= sh_mobile_sdhi_write16_hook;
+ 	host->clk_enable	= sh_mobile_sdhi_clk_enable;
+ 	host->clk_disable	= sh_mobile_sdhi_clk_disable;
+ 	host->multi_io_quirk	= sh_mobile_sdhi_multi_io_quirk;
+ 	/* SD control register space size is 0x100, 0x200 for bus_shift=1 */
+ 	if (resource_size(res) > 0x100)
+ 		host->bus_shift = 1;
+ 	else
+ 		host->bus_shift = 0;
+ 
+ 	if (mmd) {
+ 		/*
+ 		 * FIXME
+ 		 *
+ 		 * sh_mobile_sdhi_info will be replaced to tmio_mmc_data soon.
+ 		 * But, sh_mobile_sdhi_info is used under
+ 		 * ${LINUX}/arch/arm/mach-shmobile/
+ 		 * ${LINUX}/arch/sh/
+ 		 * To separate large patch into "tmio_mmc_data has .chan_priv_?x"
+ 		 * and "replace sh_mobile_sdhi_info in tmio_mmc_data",
+ 		 * here has dummy method.
+ 		 * These should be removed.
+ 		 */
+ 		struct tmio_mmc_data m;
+ 
+ 		mmd = &m;
+ 		m.flags		= p->tmio_flags;
+ 		m.ocr_mask	= p->tmio_ocr_mask;
+ 		m.capabilities	= p->tmio_caps;
+ 		m.capabilities2	= p->tmio_caps2;
+ 		m.cd_gpio	= p->cd_gpio;
+ 		m.chan_priv_tx	= (void *)p->dma_slave_tx;
+ 		m.chan_priv_rx	= (void *)p->dma_slave_rx;
+ 
+ 		*mmc_data = *mmd;
+ 	}
+ 	dma_priv->filter = shdma_chan_filter;
+ 	dma_priv->enable = sh_mobile_sdhi_enable_dma;
+ 
+ 	mmc_data->alignment_shift = 1; /* 2-byte alignment */
+ 	mmc_data->capabilities |= MMC_CAP_MMC_HIGHSPEED;
++>>>>>>> f33c9d655893 (mmc: tmio: mmc: tmio: tmio_mmc_data has .chan_priv_?x)
  
  	/*
  	 * All SDHI blocks support 2-byte and larger block sizes in 4-bit
diff --cc drivers/mmc/host/tmio_mmc.h
index d857f5c6e7d9,4a597f5a53e2..000000000000
--- a/drivers/mmc/host/tmio_mmc.h
+++ b/drivers/mmc/host/tmio_mmc.h
@@@ -39,6 -40,13 +39,16 @@@
  #define TMIO_MASK_IRQ     (TMIO_MASK_READOP | TMIO_MASK_WRITEOP | TMIO_MASK_CMD)
  
  struct tmio_mmc_data;
++<<<<<<< HEAD
++=======
+ struct tmio_mmc_host;
+ 
+ struct tmio_mmc_dma {
+ 	enum dma_slave_buswidth dma_buswidth;
+ 	bool (*filter)(struct dma_chan *chan, void *arg);
+ 	void (*enable)(struct tmio_mmc_host *host, bool enable);
+ };
++>>>>>>> f33c9d655893 (mmc: tmio: mmc: tmio: tmio_mmc_data has .chan_priv_?x)
  
  struct tmio_mmc_host {
  	void __iomem *ctl;
diff --cc drivers/mmc/host/tmio_mmc_dma.c
index a8aaa7871c0d,e4b05dbb9ca8..000000000000
--- a/drivers/mmc/host/tmio_mmc_dma.c
+++ b/drivers/mmc/host/tmio_mmc_dma.c
@@@ -264,7 -260,8 +264,12 @@@ out
  void tmio_mmc_request_dma(struct tmio_mmc_host *host, struct tmio_mmc_data *pdata)
  {
  	/* We can only either use DMA for both Tx and Rx or not use it at all */
++<<<<<<< HEAD
 +	if (!pdata->dma)
++=======
+ 	if (!host->dma || (!host->pdev->dev.of_node &&
+ 		(!pdata->chan_priv_tx || !pdata->chan_priv_rx)))
++>>>>>>> f33c9d655893 (mmc: tmio: mmc: tmio: tmio_mmc_data has .chan_priv_?x)
  		return;
  
  	if (!host->chan_tx && !host->chan_rx) {
@@@ -280,8 -277,9 +285,14 @@@
  		dma_cap_zero(mask);
  		dma_cap_set(DMA_SLAVE, mask);
  
++<<<<<<< HEAD
 +		host->chan_tx = dma_request_channel(mask, pdata->dma->filter,
 +						    pdata->dma->chan_priv_tx);
++=======
+ 		host->chan_tx = dma_request_slave_channel_compat(mask,
+ 					host->dma->filter, pdata->chan_priv_tx,
+ 					&host->pdev->dev, "tx");
++>>>>>>> f33c9d655893 (mmc: tmio: mmc: tmio: tmio_mmc_data has .chan_priv_?x)
  		dev_dbg(&host->pdev->dev, "%s: TX: got channel %p\n", __func__,
  			host->chan_tx);
  
@@@ -296,8 -296,9 +307,14 @@@
  		if (ret < 0)
  			goto ecfgtx;
  
++<<<<<<< HEAD
 +		host->chan_rx = dma_request_channel(mask, pdata->dma->filter,
 +						    pdata->dma->chan_priv_rx);
++=======
+ 		host->chan_rx = dma_request_slave_channel_compat(mask,
+ 					host->dma->filter, pdata->chan_priv_rx,
+ 					&host->pdev->dev, "rx");
++>>>>>>> f33c9d655893 (mmc: tmio: mmc: tmio: tmio_mmc_data has .chan_priv_?x)
  		dev_dbg(&host->pdev->dev, "%s: RX: got channel %p\n", __func__,
  			host->chan_rx);
  
* Unmerged path drivers/mmc/host/sh_mobile_sdhi.c
* Unmerged path drivers/mmc/host/tmio_mmc.h
* Unmerged path drivers/mmc/host/tmio_mmc_dma.c
diff --git a/include/linux/mfd/tmio.h b/include/linux/mfd/tmio.h
index 38409958f913..44dbc4d7cad3 100644
--- a/include/linux/mfd/tmio.h
+++ b/include/linux/mfd/tmio.h
@@ -99,6 +99,8 @@ struct tmio_mmc_host;
  * data for the MMC controller
  */
 struct tmio_mmc_data {
+	void				*chan_priv_tx;
+	void				*chan_priv_rx;
 	unsigned int			hclk;
 	unsigned long			capabilities;
 	unsigned long			capabilities2;
