ACPI / property: Drop size_prop from acpi_dev_get_property_reference()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 60ba032ed76e851d30d4fa514847285252147d07
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/60ba032e.failed

The size_prop argument of the recently added function
acpi_dev_get_property_reference() is not used by the only current
caller of that function and is very unlikely to be used at any time
going forward.

Namely, for a property whose value is a list of items each containing
a references to a device object possibly accompanied by some integers,
the number of items in the list can always be computed as the number
of elements of type ACPI_TYPE_LOCAL_REFERENCE in the property package.
Thus it should never be necessary to provide an additional "cells"
property with a value equal to the number of items in that list.  It
also should never be necessary to provide a "cells" property specifying
how many integers are supposed to be following each reference.

For this reason, drop the size_prop argument from
acpi_dev_get_property_reference() and update its caller accordingly.

Link: http://marc.info/?l=linux-kernel&m=141511255610556&w=2
	Suggested-by: Grant Likely <grant.likely@linaro.org>
	Acked-by: Grant Likely <grant.likely@linaro.org>
	Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 60ba032ed76e851d30d4fa514847285252147d07)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpiolib-acpi.c
diff --cc drivers/gpio/gpiolib-acpi.c
index b027c227470a,ba98bb59a58f..000000000000
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@@ -294,6 -399,44 +294,47 @@@ struct gpio_desc *acpi_get_gpiod_by_ind
  	memset(&lookup, 0, sizeof(lookup));
  	lookup.index = index;
  
++<<<<<<< HEAD
++=======
+ 	if (propname) {
+ 		struct acpi_reference_args args;
+ 
+ 		dev_dbg(&adev->dev, "GPIO: looking up %s\n", propname);
+ 
+ 		memset(&args, 0, sizeof(args));
+ 		ret = acpi_dev_get_property_reference(adev, propname,
+ 						      index, &args);
+ 		if (ret) {
+ 			bool found = acpi_get_driver_gpio_data(adev, propname,
+ 							       index, &args);
+ 			if (!found)
+ 				return ERR_PTR(ret);
+ 		}
+ 
+ 		/*
+ 		 * The property was found and resolved so need to
+ 		 * lookup the GPIO based on returned args instead.
+ 		 */
+ 		adev = args.adev;
+ 		if (args.nargs >= 2) {
+ 			lookup.index = args.args[0];
+ 			lookup.pin_index = args.args[1];
+ 			/*
+ 			 * 3rd argument, if present is used to
+ 			 * specify active_low.
+ 			 */
+ 			if (args.nargs >= 3)
+ 				active_low = !!args.args[2];
+ 		}
+ 
+ 		dev_dbg(&adev->dev, "GPIO: _DSD returned %s %zd %llu %llu %llu\n",
+ 			dev_name(&adev->dev), args.nargs,
+ 			args.args[0], args.args[1], args.args[2]);
+ 	} else {
+ 		dev_dbg(&adev->dev, "GPIO: looking up %d in _CRS\n", index);
+ 	}
+ 
++>>>>>>> 60ba032ed76e (ACPI / property: Drop size_prop from acpi_dev_get_property_reference())
  	INIT_LIST_HEAD(&resource_list);
  	ret = acpi_dev_get_resources(adev, &resource_list, acpi_find_gpio,
  				     &lookup);
diff --git a/drivers/acpi/property.c b/drivers/acpi/property.c
index 2541b1fd1fa5..e0db4c98c251 100644
--- a/drivers/acpi/property.c
+++ b/drivers/acpi/property.c
@@ -234,25 +234,21 @@ EXPORT_SYMBOL_GPL(acpi_dev_get_property_array);
  * acpi_dev_get_property_reference - returns handle to the referenced object
  * @adev: ACPI device to get property
  * @name: Name of the property
- * @size_prop: Name of the "size" property in referenced object
  * @index: Index of the reference to return
  * @args: Location to store the returned reference with optional arguments
  *
  * Find property with @name, verifify that it is a package containing at least
  * one object reference and if so, store the ACPI device object pointer to the
- * target object in @args->adev.
+ * target object in @args->adev.  If the reference includes arguments, store
+ * them in the @args->args[] array.
  *
- * If the reference includes arguments (@size_prop is not %NULL) follow the
- * reference and check whether or not there is an integer property @size_prop
- * under the target object and if so, whether or not its value matches the
- * number of arguments that follow the reference.  If there's more than one
- * reference in the property value package, @index is used to select the one to
- * return.
+ * If there's more than one reference in the property value package, @index is
+ * used to select the one to return.
  *
  * Return: %0 on success, negative error code on failure.
  */
-int acpi_dev_get_property_reference(struct acpi_device *adev, const char *name,
-				    const char *size_prop, size_t index,
+int acpi_dev_get_property_reference(struct acpi_device *adev,
+				    const char *name, size_t index,
 				    struct acpi_reference_args *args)
 {
 	const union acpi_object *element, *end;
@@ -269,7 +265,7 @@ int acpi_dev_get_property_reference(struct acpi_device *adev, const char *name,
 	 * return that reference then.
 	 */
 	if (obj->type == ACPI_TYPE_LOCAL_REFERENCE) {
-		if (size_prop || index)
+		if (index)
 			return -EINVAL;
 
 		ret = acpi_bus_get_device(obj->reference.handle, &device);
@@ -309,42 +305,16 @@ int acpi_dev_get_property_reference(struct acpi_device *adev, const char *name,
 		element++;
 		nargs = 0;
 
-		if (size_prop) {
-			const union acpi_object *prop;
-
-			/*
-			 * Find out how many arguments the refenced object
-			 * expects by reading its size_prop property.
-			 */
-			ret = acpi_dev_get_property(device, size_prop,
-						    ACPI_TYPE_INTEGER, &prop);
-			if (ret)
-				return ret;
-
-			nargs = prop->integer.value;
-			if (nargs > MAX_ACPI_REFERENCE_ARGS
-			    || element + nargs > end)
-				return -EPROTO;
+		/* assume following integer elements are all args */
+		for (i = 0; element + i < end; i++) {
+			int type = element[i].type;
 
-			/*
-			 * Skip to the start of the arguments and verify
-			 * that they all are in fact integers.
-			 */
-			for (i = 0; i < nargs; i++)
-				if (element[i].type != ACPI_TYPE_INTEGER)
-					return -EPROTO;
-		} else {
-			/* assume following integer elements are all args */
-			for (i = 0; element + i < end; i++) {
-				int type = element[i].type;
-
-				if (type == ACPI_TYPE_INTEGER)
-					nargs++;
-				else if (type == ACPI_TYPE_LOCAL_REFERENCE)
-					break;
-				else
-					return -EPROTO;
-			}
+			if (type == ACPI_TYPE_INTEGER)
+				nargs++;
+			else if (type == ACPI_TYPE_LOCAL_REFERENCE)
+				break;
+			else
+				return -EPROTO;
 		}
 
 		if (idx++ == index) {
* Unmerged path drivers/gpio/gpiolib-acpi.c
diff --git a/include/linux/acpi.h b/include/linux/acpi.h
index 364918faf44f..d50ec7b47390 100644
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@ -619,8 +619,8 @@ int acpi_dev_get_property(struct acpi_device *adev, const char *name,
 int acpi_dev_get_property_array(struct acpi_device *adev, const char *name,
 				acpi_object_type type,
 				const union acpi_object **obj);
-int acpi_dev_get_property_reference(struct acpi_device *adev, const char *name,
-				    const char *cells_name, size_t index,
+int acpi_dev_get_property_reference(struct acpi_device *adev,
+				    const char *name, size_t index,
 				    struct acpi_reference_args *args);
 
 int acpi_dev_prop_get(struct acpi_device *adev, const char *propname,
