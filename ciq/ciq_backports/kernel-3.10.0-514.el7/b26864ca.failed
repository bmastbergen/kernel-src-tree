mei: bus: add client protocol version to the device alias

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit b26864cad1c9f66f4966726ba7bc81d2b9b8f990
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b26864ca.failed

The device alias now looks like mei:S:uuid:N:*
In that way we can bind different drivers to clients with
different protocol versions if required.

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit b26864cad1c9f66f4966726ba7bc81d2b9b8f990)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/bus.c
#	drivers/nfc/microread/mei.c
#	drivers/nfc/pn544/mei.c
#	include/linux/mod_devicetable.h
#	scripts/mod/devicetable-offsets.c
#	scripts/mod/file2alias.c
diff --cc drivers/misc/mei/bus.c
index 3365981198e7,38bc4380ad08..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -31,72 -30,587 +31,98 @@@
  #define to_mei_cl_driver(d) container_of(d, struct mei_cl_driver, driver)
  #define to_mei_cl_device(d) container_of(d, struct mei_cl_device, dev)
  
 -/**
 - * __mei_cl_send - internal client send (write)
 - *
 - * @cl: host client
 - * @buf: buffer to send
 - * @length: buffer length
 - * @blocking: wait for write completion
 - *
 - * Return: written size bytes or < 0 on error
 - */
 -ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 -			bool blocking)
 -{
 -	struct mei_device *bus;
 -	struct mei_cl_cb *cb = NULL;
 -	ssize_t rets;
 -
 -	if (WARN_ON(!cl || !cl->dev))
 -		return -ENODEV;
 -
 -	bus = cl->dev;
 -
 -	mutex_lock(&bus->device_lock);
 -	if (!mei_cl_is_connected(cl)) {
 -		rets = -ENODEV;
 -		goto out;
 -	}
 -
 -	/* Check if we have an ME client device */
 -	if (!mei_me_cl_is_active(cl->me_cl)) {
 -		rets = -ENOTTY;
 -		goto out;
 -	}
 -
 -	if (length > mei_cl_mtu(cl)) {
 -		rets = -EFBIG;
 -		goto out;
 -	}
 -
 -	cb = mei_cl_alloc_cb(cl, length, MEI_FOP_WRITE, NULL);
 -	if (!cb) {
 -		rets = -ENOMEM;
 -		goto out;
 -	}
 -
 -	memcpy(cb->buf.data, buf, length);
 -
 -	rets = mei_cl_write(cl, cb, blocking);
 -
 -out:
 -	mutex_unlock(&bus->device_lock);
 -	if (rets < 0)
 -		mei_io_cb_free(cb);
 -
 -	return rets;
 -}
 -
 -/**
 - * __mei_cl_recv - internal client receive (read)
 - *
 - * @cl: host client
 - * @buf: buffer to send
 - * @length: buffer length
 - *
 - * Return: read size in bytes of < 0 on error
 - */
 -ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 -{
 -	struct mei_device *bus;
 -	struct mei_cl_cb *cb;
 -	size_t r_length;
 -	ssize_t rets;
 -
 -	if (WARN_ON(!cl || !cl->dev))
 -		return -ENODEV;
 -
 -	bus = cl->dev;
 -
 -	mutex_lock(&bus->device_lock);
 -
 -	cb = mei_cl_read_cb(cl, NULL);
 -	if (cb)
 -		goto copy;
 -
 -	rets = mei_cl_read_start(cl, length, NULL);
 -	if (rets && rets != -EBUSY)
 -		goto out;
 -
 -	/* wait on event only if there is no other waiter */
 -	if (list_empty(&cl->rd_completed) && !waitqueue_active(&cl->rx_wait)) {
 -
 -		mutex_unlock(&bus->device_lock);
 -
 -		if (wait_event_interruptible(cl->rx_wait,
 -				(!list_empty(&cl->rd_completed)) ||
 -				(!mei_cl_is_connected(cl)))) {
 -
 -			if (signal_pending(current))
 -				return -EINTR;
 -			return -ERESTARTSYS;
 -		}
 -
 -		mutex_lock(&bus->device_lock);
 -
 -		if (!mei_cl_is_connected(cl)) {
 -			rets = -EBUSY;
 -			goto out;
 -		}
 -	}
 -
 -	cb = mei_cl_read_cb(cl, NULL);
 -	if (!cb) {
 -		rets = 0;
 -		goto out;
 -	}
 -
 -copy:
 -	if (cb->status) {
 -		rets = cb->status;
 -		goto free;
 -	}
 -
 -	r_length = min_t(size_t, length, cb->buf_idx);
 -	memcpy(buf, cb->buf.data, r_length);
 -	rets = r_length;
 -
 -free:
 -	mei_io_cb_free(cb);
 -out:
 -	mutex_unlock(&bus->device_lock);
 -
 -	return rets;
 -}
 -
 -/**
 - * mei_cl_send - me device send  (write)
 - *
 - * @cldev: me client device
 - * @buf: buffer to send
 - * @length: buffer length
 - *
 - * Return: written size in bytes or < 0 on error
 - */
 -ssize_t mei_cl_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
 -{
 -	struct mei_cl *cl = cldev->cl;
 -
 -	if (cl == NULL)
 -		return -ENODEV;
 -
 -	return __mei_cl_send(cl, buf, length, 1);
 -}
 -EXPORT_SYMBOL_GPL(mei_cl_send);
 -
 -/**
 - * mei_cl_recv - client receive (read)
 - *
 - * @cldev: me client device
 - * @buf: buffer to send
 - * @length: buffer length
 - *
 - * Return: read size in bytes of < 0 on error
 - */
 -ssize_t mei_cl_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
 -{
 -	struct mei_cl *cl = cldev->cl;
 -
 -	if (cl == NULL)
 -		return -ENODEV;
 -
 -	return __mei_cl_recv(cl, buf, length);
 -}
 -EXPORT_SYMBOL_GPL(mei_cl_recv);
 -
 -/**
 - * mei_bus_event_work  - dispatch rx event for a bus device
 - *    and schedule new work
 - *
 - * @work: work
 - */
 -static void mei_bus_event_work(struct work_struct *work)
 -{
 -	struct mei_cl_device *cldev;
 -
 -	cldev = container_of(work, struct mei_cl_device, event_work);
 -
 -	if (cldev->event_cb)
 -		cldev->event_cb(cldev, cldev->events, cldev->event_context);
 -
 -	cldev->events = 0;
 -
 -	/* Prepare for the next read */
 -	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX))
 -		mei_cl_read_start(cldev->cl, 0, NULL);
 -}
 -
 -/**
 - * mei_cl_bus_notify_event - schedule notify cb on bus client
 - *
 - * @cl: host client
 - */
 -void mei_cl_bus_notify_event(struct mei_cl *cl)
 -{
 -	struct mei_cl_device *cldev = cl->cldev;
 -
 -	if (!cldev || !cldev->event_cb)
 -		return;
 -
 -	if (!(cldev->events_mask & BIT(MEI_CL_EVENT_NOTIF)))
 -		return;
 -
 -	if (!cl->notify_ev)
 -		return;
 -
 -	set_bit(MEI_CL_EVENT_NOTIF, &cldev->events);
 -
 -	schedule_work(&cldev->event_work);
 -
 -	cl->notify_ev = false;
 -}
 -
 -/**
 - * mei_cl_bus_rx_event  - schedule rx evenet
 - *
 - * @cl: host client
 - */
 -void mei_cl_bus_rx_event(struct mei_cl *cl)
 -{
 -	struct mei_cl_device *cldev = cl->cldev;
 -
 -	if (!cldev || !cldev->event_cb)
 -		return;
 -
 -	if (!(cldev->events_mask & BIT(MEI_CL_EVENT_RX)))
 -		return;
 -
 -	set_bit(MEI_CL_EVENT_RX, &cldev->events);
 -
 -	schedule_work(&cldev->event_work);
 -}
 -
 -/**
 - * mei_cl_register_event_cb - register event callback
 - *
 - * @cldev: me client devices
 - * @event_cb: callback function
 - * @events_mask: requested events bitmask
 - * @context: driver context data
 - *
 - * Return: 0 on success
 - *         -EALREADY if an callback is already registered
 - *         <0 on other errors
 - */
 -int mei_cl_register_event_cb(struct mei_cl_device *cldev,
 -			  unsigned long events_mask,
 -			  mei_cl_event_cb_t event_cb, void *context)
 -{
 -	int ret;
 -
 -	if (cldev->event_cb)
 -		return -EALREADY;
 -
 -	cldev->events = 0;
 -	cldev->events_mask = events_mask;
 -	cldev->event_cb = event_cb;
 -	cldev->event_context = context;
 -	INIT_WORK(&cldev->event_work, mei_bus_event_work);
 -
 -	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX)) {
 -		ret = mei_cl_read_start(cldev->cl, 0, NULL);
 -		if (ret && ret != -EBUSY)
 -			return ret;
 -	}
 -
 -	if (cldev->events_mask & BIT(MEI_CL_EVENT_NOTIF)) {
 -		mutex_lock(&cldev->cl->dev->device_lock);
 -		ret = mei_cl_notify_request(cldev->cl, NULL, event_cb ? 1 : 0);
 -		mutex_unlock(&cldev->cl->dev->device_lock);
 -		if (ret)
 -			return ret;
 -	}
 -
 -	return 0;
 -}
 -EXPORT_SYMBOL_GPL(mei_cl_register_event_cb);
 -
 -/**
 - * mei_cl_get_drvdata - driver data getter
 - *
 - * @cldev: mei client device
 - *
 - * Return: driver private data
 - */
 -void *mei_cl_get_drvdata(const struct mei_cl_device *cldev)
 -{
 -	return dev_get_drvdata(&cldev->dev);
 -}
 -EXPORT_SYMBOL_GPL(mei_cl_get_drvdata);
 -
 -/**
 - * mei_cl_set_drvdata - driver data setter
 - *
 - * @cldev: mei client device
 - * @data: data to store
 - */
 -void mei_cl_set_drvdata(struct mei_cl_device *cldev, void *data)
 -{
 -	dev_set_drvdata(&cldev->dev, data);
 -}
 -EXPORT_SYMBOL_GPL(mei_cl_set_drvdata);
 -
 -/**
 - * mei_cl_enable_device - enable me client device
 - *     create connection with me client
 - *
 - * @cldev: me client device
 - *
 - * Return: 0 on success and < 0 on error
 - */
 -int mei_cl_enable_device(struct mei_cl_device *cldev)
 -{
 -	struct mei_device *bus = cldev->bus;
 -	struct mei_cl *cl;
 -	int ret;
 -
 -	cl = cldev->cl;
 -
 -	if (!cl) {
 -		mutex_lock(&bus->device_lock);
 -		cl = mei_cl_alloc_linked(bus, MEI_HOST_CLIENT_ID_ANY);
 -		mutex_unlock(&bus->device_lock);
 -		if (IS_ERR(cl))
 -			return PTR_ERR(cl);
 -		/* update pointers */
 -		cldev->cl = cl;
 -		cl->cldev = cldev;
 -	}
 -
 -	mutex_lock(&bus->device_lock);
 -	if (mei_cl_is_connected(cl)) {
 -		ret = 0;
 -		goto out;
 -	}
 -
 -	if (!mei_me_cl_is_active(cldev->me_cl)) {
 -		dev_err(&cldev->dev, "me client is not active\n");
 -		ret = -ENOTTY;
 -		goto out;
 -	}
 -
 -	ret = mei_cl_connect(cl, cldev->me_cl, NULL);
 -	if (ret < 0)
 -		dev_err(&cldev->dev, "cannot connect\n");
 -
 -out:
 -	mutex_unlock(&bus->device_lock);
 -
 -	return ret;
 -}
 -EXPORT_SYMBOL_GPL(mei_cl_enable_device);
 -
 -/**
 - * mei_cl_disable_device - disable me client device
 - *     disconnect form the me client
 - *
 - * @cldev: me client device
 - *
 - * Return: 0 on success and < 0 on error
 - */
 -int mei_cl_disable_device(struct mei_cl_device *cldev)
 +static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
  {
 -	struct mei_device *bus;
 -	struct mei_cl *cl;
 -	int err;
 -
 -	if (!cldev || !cldev->cl)
 -		return -ENODEV;
 -
 -	cl = cldev->cl;
 -
 -	bus = cldev->bus;
 -
 -	cldev->event_cb = NULL;
 -
 -	mutex_lock(&bus->device_lock);
 -
 -	if (!mei_cl_is_connected(cl)) {
 -		dev_err(bus->dev, "Already disconnected");
 -		err = 0;
 -		goto out;
 -	}
 -
 -	err = mei_cl_disconnect(cl);
 -	if (err < 0)
 -		dev_err(bus->dev, "Could not disconnect from the ME client");
 +	struct mei_cl_device *device = to_mei_cl_device(dev);
 +	struct mei_cl_driver *driver = to_mei_cl_driver(drv);
 +	const struct mei_cl_device_id *id;
++<<<<<<< HEAD
  
 -out:
 -	/* Flush queues and remove any pending read */
 -	mei_cl_flush_queues(cl, NULL);
 -	mei_cl_unlink(cl);
 +	if (!device)
 +		return 0;
  
 -	kfree(cl);
 -	cldev->cl = NULL;
 +	if (!driver || !driver->id_table)
 +		return 0;
  
 -	mutex_unlock(&bus->device_lock);
 -	return err;
 -}
 -EXPORT_SYMBOL_GPL(mei_cl_disable_device);
 +	id = driver->id_table;
  
 -/**
 - * mei_cl_device_find - find matching entry in the driver id table
 - *
 - * @cldev: me client device
 - * @cldrv: me client driver
 - *
 - * Return: id on success; NULL if no id is matching
 - */
 -static const
 -struct mei_cl_device_id *mei_cl_device_find(struct mei_cl_device *cldev,
 -					    struct mei_cl_driver *cldrv)
 -{
 -	const struct mei_cl_device_id *id;
 +	while (id->name[0]) {
 +		if (!strncmp(dev_name(dev), id->name, sizeof(id->name)))
 +			return 1;
++=======
+ 	const uuid_le *uuid;
+ 	u8 version;
+ 	bool match;
+ 
+ 	uuid = mei_me_cl_uuid(cldev->me_cl);
+ 	version = mei_me_cl_ver(cldev->me_cl);
+ 
+ 	id = cldrv->id_table;
+ 	while (uuid_le_cmp(NULL_UUID_LE, id->uuid)) {
+ 		if (!uuid_le_cmp(*uuid, id->uuid)) {
+ 			match = true;
+ 
+ 			if (cldev->name[0])
+ 				if (strncmp(cldev->name, id->name,
+ 					    sizeof(id->name)))
+ 					match = false;
+ 
+ 			if (id->version != MEI_CL_VERSION_ANY)
+ 				if (id->version != version)
+ 					match = false;
+ 			if (match)
+ 				return id;
+ 		}
++>>>>>>> b26864cad1c9 (mei: bus: add client protocol version to the device alias)
  
  		id++;
 -	}
 -
 -	return NULL;
 -}
 -
 -/**
 - * mei_cl_device_match  - device match function
 - *
 - * @dev: device
 - * @drv: driver
 - *
 - * Return:  1 if matching device was found 0 otherwise
 - */
 -static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
 -{
 -	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 -	struct mei_cl_driver *cldrv = to_mei_cl_driver(drv);
 -	const struct mei_cl_device_id *found_id;
 -
 -	if (!cldev)
 -		return 0;
 -
 -	if (!cldev->do_match)
 -		return 0;
 -
 -	if (!cldrv || !cldrv->id_table)
 -		return 0;
 -
 -	found_id = mei_cl_device_find(cldev, cldrv);
 -	if (found_id)
 -		return 1;
 -
 -	return 0;
 -}
 -
 -/**
 - * mei_cl_device_probe - bus probe function
 - *
 - * @dev: device
 - *
 - * Return:  0 on success; < 0 otherwise
 - */
 -static int mei_cl_device_probe(struct device *dev)
 -{
 -	struct mei_cl_device *cldev;
 -	struct mei_cl_driver *cldrv;
 -	const struct mei_cl_device_id *id;
 -
 -	cldev = to_mei_cl_device(dev);
 -	cldrv = to_mei_cl_driver(dev->driver);
 -
 -	if (!cldev)
 -		return 0;
 -
 -	if (!cldrv || !cldrv->probe)
 -		return -ENODEV;
 -
 -	id = mei_cl_device_find(cldev, cldrv);
 -	if (!id)
 -		return -ENODEV;
 -
 -	__module_get(THIS_MODULE);
 -
 -	return cldrv->probe(cldev, id);
 -}
 -
 -/**
 - * mei_cl_device_remove - remove device from the bus
 - *
 - * @dev: device
 - *
 - * Return:  0 on success; < 0 otherwise
 - */
 -static int mei_cl_device_remove(struct device *dev)
 -{
 -	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 -	struct mei_cl_driver *cldrv;
 -	int ret = 0;
 -
 -	if (!cldev || !dev->driver)
 -		return 0;
 -
 -	if (cldev->event_cb) {
 -		cldev->event_cb = NULL;
 -		cancel_work_sync(&cldev->event_work);
 -	}
 -
 -	cldrv = to_mei_cl_driver(dev->driver);
 -	if (cldrv->remove)
 -		ret = cldrv->remove(cldev);
 -
 -	module_put(THIS_MODULE);
 -	dev->driver = NULL;
 -	return ret;
 +	}
  
 +	return 0;
  }
  
 -static ssize_t name_show(struct device *dev, struct device_attribute *a,
 -			     char *buf)
 +static int mei_cl_device_probe(struct device *dev)
  {
 -	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 -	size_t len;
 +	struct mei_cl_device *device = to_mei_cl_device(dev);
 +	struct mei_cl_driver *driver;
 +	struct mei_cl_device_id id;
  
 -	len = snprintf(buf, PAGE_SIZE, "%s", cldev->name);
 +	if (!device)
 +		return 0;
  
 -	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 -}
 -static DEVICE_ATTR_RO(name);
 +	driver = to_mei_cl_driver(dev->driver);
 +	if (!driver || !driver->probe)
 +		return -ENODEV;
  
 -static ssize_t uuid_show(struct device *dev, struct device_attribute *a,
 -			     char *buf)
 -{
 -	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 -	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
 -	size_t len;
 +	dev_dbg(dev, "Device probe\n");
  
 -	len = snprintf(buf, PAGE_SIZE, "%pUl", uuid);
 +	strlcpy(id.name, dev_name(dev), sizeof(id.name));
  
 -	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 +	return driver->probe(device, &id);
  }
 -static DEVICE_ATTR_RO(uuid);
  
 -static ssize_t version_show(struct device *dev, struct device_attribute *a,
 -			     char *buf)
 +static int mei_cl_device_remove(struct device *dev)
  {
 -	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 -	u8 version = mei_me_cl_ver(cldev->me_cl);
 -	size_t len;
 +	struct mei_cl_device *device = to_mei_cl_device(dev);
 +	struct mei_cl_driver *driver;
  
 -	len = snprintf(buf, PAGE_SIZE, "%02X", version);
 +	if (!device || !dev->driver)
 +		return 0;
  
 -	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 +	if (device->event_cb) {
 +		device->event_cb = NULL;
 +		cancel_work_sync(&device->event_work);
 +	}
 +
 +	driver = to_mei_cl_driver(dev->driver);
 +	if (!driver->remove) {
 +		dev->driver = NULL;
 +
 +		return 0;
 +	}
 +
 +	return driver->remove(device);
  }
 -static DEVICE_ATTR_RO(version);
  
  static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
  			     char *buf)
@@@ -125,7 -643,21 +151,25 @@@ ATTRIBUTE_GROUPS(mei_cl_dev)
   */
  static int mei_cl_device_uevent(struct device *dev, struct kobj_uevent_env *env)
  {
++<<<<<<< HEAD
 +	if (add_uevent_var(env, "MODALIAS=mei:%s", dev_name(dev)))
++=======
+ 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+ 	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
+ 	u8 version = mei_me_cl_ver(cldev->me_cl);
+ 
+ 	if (add_uevent_var(env, "MEI_CL_VERSION=%d", version))
+ 		return -ENOMEM;
+ 
+ 	if (add_uevent_var(env, "MEI_CL_UUID=%pUl", uuid))
+ 		return -ENOMEM;
+ 
+ 	if (add_uevent_var(env, "MEI_CL_NAME=%s", cldev->name))
+ 		return -ENOMEM;
+ 
+ 	if (add_uevent_var(env, "MODALIAS=mei:%s:%pUl:%02X:",
+ 			   cldev->name, uuid, version))
++>>>>>>> b26864cad1c9 (mei: bus: add client protocol version to the device alias)
  		return -ENOMEM;
  
  	return 0;
@@@ -149,65 -702,203 +193,214 @@@ static struct device_type mei_cl_device
  	.release	= mei_cl_dev_release,
  };
  
 -/**
 - * mei_cl_dev_alloc - initialize and allocate mei client device
 - *
 - * @bus: mei device
 - * @me_cl: me client
 - *
 - * Return: allocated device structur or NULL on allocation failure
 - */
 -static struct mei_cl_device *mei_cl_dev_alloc(struct mei_device *bus,
 -					      struct mei_me_client *me_cl)
 +static struct mei_cl *mei_bus_find_mei_cl_by_uuid(struct mei_device *dev,
 +						uuid_le uuid)
  {
 -	struct mei_cl_device *cldev;
 +	struct mei_cl *cl;
  
 -	cldev = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
 -	if (!cldev)
 +	list_for_each_entry(cl, &dev->device_list, device_link) {
 +		if (!uuid_le_cmp(uuid, cl->device_uuid))
 +			return cl;
 +	}
 +
 +	return NULL;
 +}
 +struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops)
 +{
 +	struct mei_cl_device *device;
 +	struct mei_cl *cl;
 +	int status;
 +
 +	cl = mei_bus_find_mei_cl_by_uuid(dev, uuid);
 +	if (cl == NULL)
  		return NULL;
  
 -	device_initialize(&cldev->dev);
 -	cldev->dev.parent = bus->dev;
 -	cldev->dev.bus    = &mei_cl_bus_type;
 -	cldev->dev.type   = &mei_cl_device_type;
 -	cldev->bus        = mei_dev_bus_get(bus);
 -	cldev->me_cl      = mei_me_cl_get(me_cl);
 -	cldev->is_added   = 0;
 -	INIT_LIST_HEAD(&cldev->bus_list);
 +	device = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
 +	if (!device)
 +		return NULL;
  
 -	return cldev;
 -}
 +	device->cl = cl;
 +	device->ops = ops;
  
 -/**
 - * mei_cl_dev_setup - setup me client device
 - *    run fix up routines and set the device name
 - *
 - * @bus: mei device
 - * @cldev: me client device
 - *
 - * Return: true if the device is eligible for enumeration
 - */
 -static bool mei_cl_dev_setup(struct mei_device *bus,
 -			     struct mei_cl_device *cldev)
 -{
 -	cldev->do_match = 1;
 -	mei_cl_dev_fixup(cldev);
 +	device->dev.parent = &dev->pdev->dev;
 +	device->dev.bus = &mei_cl_bus_type;
 +	device->dev.type = &mei_cl_device_type;
 +
++<<<<<<< HEAD
 +	dev_set_name(&device->dev, "%s", name);
  
 +	status = device_register(&device->dev);
 +	if (status) {
 +		dev_err(&dev->pdev->dev, "Failed to register MEI device\n");
 +		kfree(device);
 +		return NULL;
++=======
+ 	if (cldev->do_match)
+ 		dev_set_name(&cldev->dev, "mei:%s:%pUl:%02X",
+ 			     cldev->name,
+ 			     mei_me_cl_uuid(cldev->me_cl),
+ 			     mei_me_cl_ver(cldev->me_cl));
+ 
+ 	return cldev->do_match == 1;
+ }
+ 
+ /**
+  * mei_cl_bus_dev_add - add me client devices
+  *
+  * @cldev: me client device
+  *
+  * Return: 0 on success; < 0 on failre
+  */
+ static int mei_cl_bus_dev_add(struct mei_cl_device *cldev)
+ {
+ 	int ret;
+ 
+ 	dev_dbg(cldev->bus->dev, "adding %pUL:%02X\n",
+ 		mei_me_cl_uuid(cldev->me_cl),
+ 		mei_me_cl_ver(cldev->me_cl));
+ 	ret = device_add(&cldev->dev);
+ 	if (!ret)
+ 		cldev->is_added = 1;
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * mei_cl_bus_dev_stop - stop the driver
+  *
+  * @cldev: me client device
+  */
+ static void mei_cl_bus_dev_stop(struct mei_cl_device *cldev)
+ {
+ 	if (cldev->is_added)
+ 		device_release_driver(&cldev->dev);
+ }
+ 
+ /**
+  * mei_cl_bus_dev_destroy - destroy me client devices object
+  *
+  * @cldev: me client device
+  */
+ static void mei_cl_bus_dev_destroy(struct mei_cl_device *cldev)
+ {
+ 	if (!cldev->is_added)
+ 		return;
+ 
+ 	device_del(&cldev->dev);
+ 
+ 	mutex_lock(&cldev->bus->cl_bus_lock);
+ 	list_del_init(&cldev->bus_list);
+ 	mutex_unlock(&cldev->bus->cl_bus_lock);
+ 
+ 	cldev->is_added = 0;
+ 	put_device(&cldev->dev);
+ }
+ 
+ /**
+  * mei_cl_bus_remove_device - remove a devices form the bus
+  *
+  * @cldev: me client device
+  */
+ static void mei_cl_bus_remove_device(struct mei_cl_device *cldev)
+ {
+ 	mei_cl_bus_dev_stop(cldev);
+ 	mei_cl_bus_dev_destroy(cldev);
+ }
+ 
+ /**
+  * mei_cl_bus_remove_devices - remove all devices form the bus
+  *
+  * @bus: mei device
+  */
+ void mei_cl_bus_remove_devices(struct mei_device *bus)
+ {
+ 	struct mei_cl_device *cldev, *next;
+ 
+ 	list_for_each_entry_safe(cldev, next, &bus->device_list, bus_list)
+ 		mei_cl_bus_remove_device(cldev);
+ }
+ 
+ 
+ /**
+  * mei_cl_dev_init - allocate and initializes an mei client devices
+  *     based on me client
+  *
+  * @bus: mei device
+  * @me_cl: me client
+  */
+ static void mei_cl_dev_init(struct mei_device *bus, struct mei_me_client *me_cl)
+ {
+ 	struct mei_cl_device *cldev;
+ 
+ 	dev_dbg(bus->dev, "initializing %pUl", mei_me_cl_uuid(me_cl));
+ 
+ 	if (me_cl->bus_added)
+ 		return;
+ 
+ 	cldev = mei_cl_dev_alloc(bus, me_cl);
+ 	if (!cldev)
+ 		return;
+ 
+ 	mutex_lock(&cldev->bus->cl_bus_lock);
+ 	me_cl->bus_added = true;
+ 	list_add_tail(&cldev->bus_list, &bus->device_list);
+ 	mutex_unlock(&cldev->bus->cl_bus_lock);
+ 
+ }
+ 
+ /**
+  * mei_cl_bus_rescan - scan me clients list and add create
+  *    devices for eligible clients
+  *
+  * @bus: mei device
+  */
+ void mei_cl_bus_rescan(struct mei_device *bus)
+ {
+ 	struct mei_cl_device *cldev, *n;
+ 	struct mei_me_client *me_cl;
+ 
+ 	down_read(&bus->me_clients_rwsem);
+ 	list_for_each_entry(me_cl, &bus->me_clients, list)
+ 		mei_cl_dev_init(bus, me_cl);
+ 	up_read(&bus->me_clients_rwsem);
+ 
+ 	mutex_lock(&bus->cl_bus_lock);
+ 	list_for_each_entry_safe(cldev, n, &bus->device_list, bus_list) {
+ 
+ 		if (!mei_me_cl_is_active(cldev->me_cl)) {
+ 			mei_cl_bus_remove_device(cldev);
+ 			continue;
+ 		}
+ 
+ 		if (cldev->is_added)
+ 			continue;
+ 
+ 		if (mei_cl_dev_setup(bus, cldev))
+ 			mei_cl_bus_dev_add(cldev);
+ 		else {
+ 			list_del_init(&cldev->bus_list);
+ 			put_device(&cldev->dev);
+ 		}
++>>>>>>> b26864cad1c9 (mei: bus: add client protocol version to the device alias)
  	}
 -	mutex_unlock(&bus->cl_bus_lock);
  
 -	dev_dbg(bus->dev, "rescan end");
 +	cl->device = device;
 +
 +	dev_dbg(&device->dev, "client %s registered\n", name);
 +
 +	return device;
 +}
 +EXPORT_SYMBOL_GPL(mei_cl_add_device);
 +
 +void mei_cl_remove_device(struct mei_cl_device *device)
 +{
 +	device_unregister(&device->dev);
  }
 +EXPORT_SYMBOL_GPL(mei_cl_remove_device);
  
 -int __mei_cl_driver_register(struct mei_cl_driver *cldrv, struct module *owner)
 +int __mei_cl_driver_register(struct mei_cl_driver *driver, struct module *owner)
  {
  	int err;
  
diff --cc drivers/nfc/microread/mei.c
index cdf1bc53b257,93328bd45110..000000000000
--- a/drivers/nfc/microread/mei.c
+++ b/drivers/nfc/microread/mei.c
@@@ -69,7 -67,7 +69,11 @@@ static int microread_mei_remove(struct 
  }
  
  static struct mei_cl_device_id microread_mei_tbl[] = {
++<<<<<<< HEAD
 +	{ MICROREAD_DRIVER_NAME },
++=======
+ 	{ MICROREAD_DRIVER_NAME, MEI_NFC_UUID, MEI_CL_VERSION_ANY},
++>>>>>>> b26864cad1c9 (mei: bus: add client protocol version to the device alias)
  
  	/* required last entry */
  	{ }
diff --cc drivers/nfc/pn544/mei.c
index b5d3d18179eb,80f897b4a401..000000000000
--- a/drivers/nfc/pn544/mei.c
+++ b/drivers/nfc/pn544/mei.c
@@@ -69,7 -67,7 +69,11 @@@ static int pn544_mei_remove(struct mei_
  }
  
  static struct mei_cl_device_id pn544_mei_tbl[] = {
++<<<<<<< HEAD
 +	{ PN544_DRIVER_NAME },
++=======
+ 	{ PN544_DRIVER_NAME, MEI_NFC_UUID, MEI_CL_VERSION_ANY},
++>>>>>>> b26864cad1c9 (mei: bus: add client protocol version to the device alias)
  
  	/* required last entry */
  	{ }
diff --cc include/linux/mod_devicetable.h
index b3bd7e737e8b,6975cbf1435b..000000000000
--- a/include/linux/mod_devicetable.h
+++ b/include/linux/mod_devicetable.h
@@@ -573,9 -601,21 +573,26 @@@ struct ipack_device_id 
  
  #define MEI_CL_MODULE_PREFIX "mei:"
  #define MEI_CL_NAME_SIZE 32
+ #define MEI_CL_VERSION_ANY 0xff
  
++<<<<<<< HEAD
 +struct mei_cl_device_id {
 +	char name[MEI_CL_NAME_SIZE];
++=======
+ /**
+  * struct mei_cl_device_id - MEI client device identifier
+  * @name: helper name
+  * @uuid: client uuid
+  * @version: client protocol version
+  * @driver_info: information used by the driver.
+  *
+  * identifies mei client device by uuid and name
+  */
+ struct mei_cl_device_id {
+ 	char name[MEI_CL_NAME_SIZE];
+ 	uuid_le uuid;
+ 	__u8    version;
++>>>>>>> b26864cad1c9 (mei: bus: add client protocol version to the device alias)
  	kernel_ulong_t driver_info;
  };
  
diff --cc scripts/mod/devicetable-offsets.c
index e66d4d258e1a,5a6edacc85d9..000000000000
--- a/scripts/mod/devicetable-offsets.c
+++ b/scripts/mod/devicetable-offsets.c
@@@ -174,8 -179,23 +174,23 @@@ int main(void
  	DEVID_FIELD(x86_cpu_id, model);
  	DEVID_FIELD(x86_cpu_id, vendor);
  
 -	DEVID(cpu_feature);
 -	DEVID_FIELD(cpu_feature, feature);
 -
  	DEVID(mei_cl_device_id);
  	DEVID_FIELD(mei_cl_device_id, name);
++<<<<<<< HEAD
++=======
+ 	DEVID_FIELD(mei_cl_device_id, uuid);
+ 	DEVID_FIELD(mei_cl_device_id, version);
+ 
+ 	DEVID(rio_device_id);
+ 	DEVID_FIELD(rio_device_id, did);
+ 	DEVID_FIELD(rio_device_id, vid);
+ 	DEVID_FIELD(rio_device_id, asm_did);
+ 	DEVID_FIELD(rio_device_id, asm_vid);
+ 
+ 	DEVID(ulpi_device_id);
+ 	DEVID_FIELD(ulpi_device_id, vendor);
+ 	DEVID_FIELD(ulpi_device_id, product);
++>>>>>>> b26864cad1c9 (mei: bus: add client protocol version to the device alias)
  
  	return 0;
  }
diff --cc scripts/mod/file2alias.c
index 45f9a3377dcd,9bc2cfe0ee37..000000000000
--- a/scripts/mod/file2alias.c
+++ b/scripts/mod/file2alias.c
@@@ -1133,13 -1192,30 +1133,39 @@@ static int do_x86cpu_entry(const char *
  }
  ADD_TO_DEVTABLE("x86cpu", x86_cpu_id, do_x86cpu_entry);
  
++<<<<<<< HEAD
 +/* Looks like: mei:S */
++=======
+ /* LOOKS like cpu:type:*:feature:*FEAT* */
+ static int do_cpu_entry(const char *filename, void *symval, char *alias)
+ {
+ 	DEF_FIELD(symval, cpu_feature, feature);
+ 
+ 	sprintf(alias, "cpu:type:*:feature:*%04X*", feature);
+ 	return 1;
+ }
+ ADD_TO_DEVTABLE("cpu", cpu_feature, do_cpu_entry);
+ 
+ /* Looks like: mei:S:uuid:N:* */
++>>>>>>> b26864cad1c9 (mei: bus: add client protocol version to the device alias)
  static int do_mei_entry(const char *filename, void *symval,
  			char *alias)
  {
  	DEF_FIELD_ADDR(symval, mei_cl_device_id, name);
++<<<<<<< HEAD
 +
 +	sprintf(alias, MEI_CL_MODULE_PREFIX "%s", *name);
++=======
+ 	DEF_FIELD_ADDR(symval, mei_cl_device_id, uuid);
+ 	DEF_FIELD(symval, mei_cl_device_id, version);
+ 
+ 	sprintf(alias, MEI_CL_MODULE_PREFIX);
+ 	sprintf(alias + strlen(alias), "%s:",  (*name)[0]  ? *name : "*");
+ 	add_uuid(alias, *uuid);
+ 	ADD(alias, ":", version != MEI_CL_VERSION_ANY, version);
+ 
+ 	strcat(alias, ":*");
++>>>>>>> b26864cad1c9 (mei: bus: add client protocol version to the device alias)
  
  	return 1;
  }
* Unmerged path drivers/misc/mei/bus.c
* Unmerged path drivers/nfc/microread/mei.c
* Unmerged path drivers/nfc/pn544/mei.c
* Unmerged path include/linux/mod_devicetable.h
* Unmerged path scripts/mod/devicetable-offsets.c
* Unmerged path scripts/mod/file2alias.c
