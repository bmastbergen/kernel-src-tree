Drivers: hv: vmbus: Fix signaling logic in hv_need_to_signal_on_read()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hv] vmbus: Fix signaling logic in hv_need_to_signal_on_read() (Vitaly Kuznetsov) [1339684]
Rebuild_FUZZ: 89.76%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit a389fcfd2cb57793931a9fb98fed076aae50bb6c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a389fcfd.failed

On the consumer side, we have interrupt driven flow management of the
producer. It is sufficient to base the signaling decision on the
amount of space that is available to write after the read is complete.
The current code samples the previous available space and uses this
in making the signaling decision. This state can be stale and is
unnecessary. Since the state can be stale, we end up not signaling
the host (when we should) and this can result in a hang. Fix this
problem by removing the unnecessary check. I would like to thank
Arseney Romanenko <arseneyr@microsoft.com> for pointing out this issue.

Also, issue a full memory barrier before making the signaling descision
to correctly deal with potential reordering of the write (read index)
followed by the read of pending_sz.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Tested-by: Dexuan Cui <decui@microsoft.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit a389fcfd2cb57793931a9fb98fed076aae50bb6c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/ring_buffer.c
diff --cc drivers/hv/ring_buffer.c
index 6361d124f67d,a40a73a7b71d..000000000000
--- a/drivers/hv/ring_buffer.c
+++ b/drivers/hv/ring_buffer.c
@@@ -103,19 -103,30 +103,41 @@@ static bool hv_need_to_signal(u32 old_w
   *    there is room for the producer to send the pending packet.
   */
  
++<<<<<<< HEAD
 +static bool hv_need_to_signal_on_read(u32 old_rd,
 +					 struct hv_ring_buffer_info *rbi)
++=======
+ static bool hv_need_to_signal_on_read(struct hv_ring_buffer_info *rbi)
++>>>>>>> a389fcfd2cb5 (Drivers: hv: vmbus: Fix signaling logic in hv_need_to_signal_on_read())
  {
 +	u32 prev_write_sz;
  	u32 cur_write_sz;
  	u32 r_size;
- 	u32 write_loc = rbi->ring_buffer->write_index;
+ 	u32 write_loc;
  	u32 read_loc = rbi->ring_buffer->read_index;
- 	u32 pending_sz = rbi->ring_buffer->pending_send_sz;
+ 	u32 pending_sz;
  
  	/*
++<<<<<<< HEAD
 +	 * If the other end is not blocked on write don't bother.
 +	 */
++=======
+ 	 * Issue a full memory barrier before making the signaling decision.
+ 	 * Here is the reason for having this barrier:
+ 	 * If the reading of the pend_sz (in this function)
+ 	 * were to be reordered and read before we commit the new read
+ 	 * index (in the calling function)  we could
+ 	 * have a problem. If the host were to set the pending_sz after we
+ 	 * have sampled pending_sz and go to sleep before we commit the
+ 	 * read index, we could miss sending the interrupt. Issue a full
+ 	 * memory barrier to address this.
+ 	 */
+ 	mb();
+ 
+ 	pending_sz = rbi->ring_buffer->pending_send_sz;
+ 	write_loc = rbi->ring_buffer->write_index;
+ 	/* If the other end is not blocked on write don't bother. */
++>>>>>>> a389fcfd2cb5 (Drivers: hv: vmbus: Fix signaling logic in hv_need_to_signal_on_read())
  	if (pending_sz == 0)
  		return false;
  
@@@ -123,11 -134,7 +145,15 @@@
  	cur_write_sz = write_loc >= read_loc ? r_size - (write_loc - read_loc) :
  			read_loc - write_loc;
  
++<<<<<<< HEAD
 +	prev_write_sz = write_loc >= old_rd ? r_size - (write_loc - old_rd) :
 +			old_rd - write_loc;
 +
 +
 +	if ((prev_write_sz < pending_sz) && (cur_write_sz >= pending_sz))
++=======
+ 	if (cur_write_sz >= pending_sz)
++>>>>>>> a389fcfd2cb5 (Drivers: hv: vmbus: Fix signaling logic in hv_need_to_signal_on_read())
  		return true;
  
  	return false;
@@@ -558,9 -469,7 +584,13 @@@ int hv_ringbuffer_read(struct hv_ring_b
  	/* Update the read index */
  	hv_set_next_read_location(inring_info, next_read_location);
  
++<<<<<<< HEAD
 +	spin_unlock_irqrestore(&inring_info->ring_lock, flags);
++=======
+ 	*signal = hv_need_to_signal_on_read(inring_info);
++>>>>>>> a389fcfd2cb5 (Drivers: hv: vmbus: Fix signaling logic in hv_need_to_signal_on_read())
 +
 +	*signal = hv_need_to_signal_on_read(old_read, inring_info);
  
 -	return ret;
 +	return 0;
  }
* Unmerged path drivers/hv/ring_buffer.c
