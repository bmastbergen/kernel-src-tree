dax: drop size parameter to ->direct_access()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit cb389b9c0e00c30c9daf20287f7d91e2466edbb1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/cb389b9c.failed

None of the implementations currently use it.  The common
bdev_direct_access() entry point handles all the size checks before
calling ->direct_access().

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit cb389b9c0e00c30c9daf20287f7d91e2466edbb1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/sysdev/axonram.c
#	drivers/block/brd.c
#	drivers/nvdimm/pmem.c
#	drivers/s390/block/dcssblk.c
#	include/linux/blkdev.h
diff --cc arch/powerpc/sysdev/axonram.c
index 45bc123f9227,4419c84ac15a..000000000000
--- a/arch/powerpc/sysdev/axonram.c
+++ b/arch/powerpc/sysdev/axonram.c
@@@ -140,7 -141,7 +140,11 @@@ axon_ram_make_request(struct request_qu
   */
  static long
  axon_ram_direct_access(struct block_device *device, sector_t sector,
++<<<<<<< HEAD
 +		       void **kaddr, unsigned long *pfn, long size)
++=======
+ 		       void __pmem **kaddr, unsigned long *pfn)
++>>>>>>> cb389b9c0e00 (dax: drop size parameter to ->direct_access())
  {
  	struct axon_ram_bank *bank = device->bd_disk->private_data;
  	loff_t offset = (loff_t)sector << AXON_RAM_SECTOR_SHIFT;
diff --cc drivers/block/brd.c
index 898ba5c2e588,03c45c41bdfa..000000000000
--- a/drivers/block/brd.c
+++ b/drivers/block/brd.c
@@@ -369,9 -369,9 +369,13 @@@ static int brd_rw_page(struct block_dev
  	return err;
  }
  
 -#ifdef CONFIG_BLK_DEV_RAM_DAX
 +#ifdef CONFIG_BLK_DEV_XIP
  static long brd_direct_access(struct block_device *bdev, sector_t sector,
++<<<<<<< HEAD
 +			void **kaddr, unsigned long *pfn, long size)
++=======
+ 			void __pmem **kaddr, unsigned long *pfn)
++>>>>>>> cb389b9c0e00 (dax: drop size parameter to ->direct_access())
  {
  	struct brd_device *brd = bdev->bd_disk->private_data;
  	struct page *page;
@@@ -381,15 -381,13 +385,11 @@@
  	page = brd_insert_page(brd, sector);
  	if (!page)
  		return -ENOSPC;
 -	*kaddr = (void __pmem *)page_address(page);
 +	*kaddr = page_address(page);
  	*pfn = page_to_pfn(page);
  
- 	/*
- 	 * TODO: If size > PAGE_SIZE, we could look to see if the next page in
- 	 * the file happens to be mapped to the next page of physical RAM.
- 	 */
  	return PAGE_SIZE;
  }
 -#else
 -#define brd_direct_access NULL
  #endif
  
  static int brd_ioctl(struct block_device *bdev, fmode_t mode,
diff --cc drivers/s390/block/dcssblk.c
index 234818c98b8f,8c027a9e4e8a..000000000000
--- a/drivers/s390/block/dcssblk.c
+++ b/drivers/s390/block/dcssblk.c
@@@ -29,7 -29,7 +29,11 @@@ static int dcssblk_open(struct block_de
  static void dcssblk_release(struct gendisk *disk, fmode_t mode);
  static void dcssblk_make_request(struct request_queue *q, struct bio *bio);
  static long dcssblk_direct_access(struct block_device *bdev, sector_t secnum,
++<<<<<<< HEAD
 +				 void **kaddr, unsigned long *pfn, long size);
++=======
+ 			 void __pmem **kaddr, unsigned long *pfn);
++>>>>>>> cb389b9c0e00 (dax: drop size parameter to ->direct_access())
  
  static char dcssblk_segments[DCSSBLK_PARM_LEN] = "\0";
  
@@@ -867,7 -879,7 +871,11 @@@ fail
  
  static long
  dcssblk_direct_access (struct block_device *bdev, sector_t secnum,
++<<<<<<< HEAD
 +			void **kaddr, unsigned long *pfn, long size)
++=======
+ 			void __pmem **kaddr, unsigned long *pfn)
++>>>>>>> cb389b9c0e00 (dax: drop size parameter to ->direct_access())
  {
  	struct dcssblk_dev_info *dev_info;
  	unsigned long offset, dev_sz;
diff --cc include/linux/blkdev.h
index 7ce94e9d0a73,c22064f326b2..000000000000
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@@ -1649,8 -1555,8 +1649,13 @@@ struct block_device_operations 
  	int (*rw_page)(struct block_device *, sector_t, struct page *, int rw);
  	int (*ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);
  	int (*compat_ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);
++<<<<<<< HEAD
 +	long (*direct_access)(struct block_device *, sector_t,
 +					void **, unsigned long *pfn, long size);
++=======
+ 	long (*direct_access)(struct block_device *, sector_t, void __pmem **,
+ 			unsigned long *pfn);
++>>>>>>> cb389b9c0e00 (dax: drop size parameter to ->direct_access())
  	unsigned int (*check_events) (struct gendisk *disk,
  				      unsigned int clearing);
  	/* ->media_changed() is DEPRECATED, use ->check_events() instead */
* Unmerged path drivers/nvdimm/pmem.c
* Unmerged path arch/powerpc/sysdev/axonram.c
* Unmerged path drivers/block/brd.c
* Unmerged path drivers/nvdimm/pmem.c
* Unmerged path drivers/s390/block/dcssblk.c
diff --git a/fs/block_dev.c b/fs/block_dev.c
index 5b74b6b9e551..b0095c241c6e 100644
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@ -477,7 +477,7 @@ long bdev_direct_access(struct block_device *bdev, sector_t sector,
 	sector += get_start_sect(bdev);
 	if (sector % (PAGE_SIZE / 512))
 		return -EINVAL;
-	avail = ops->direct_access(bdev, sector, addr, pfn, size);
+	avail = ops->direct_access(bdev, sector, addr, pfn);
 	if (!avail)
 		return -ERANGE;
 	return min(avail, size);
* Unmerged path include/linux/blkdev.h
