zram: do not pass rw argument to __zram_make_request()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
commit be257c61306750d11c20d2ac567bf63304c696a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/be257c61.failed

Do not pass rw argument down the __zram_make_request() -> zram_bvec_rw()
chain, decode it in zram_bvec_rw() instead.  Besides, this is the place
where we distinguish READ and WRITE bio data directions, so account zram
RW stats here, instead of __zram_make_request().  This also allows to
account a real number of zram READ/WRITE operations, not just requests
(single RW request may cause a number of zram RW ops with separate
locking, compression/decompression, etc).

	Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
	Acked-by: Minchan Kim <minchan@kernel.org>
	Acked-by: Jerome Marchand <jmarchan@redhat.com>
	Cc: Nitin Gupta <ngupta@vflare.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit be257c61306750d11c20d2ac567bf63304c696a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/zram/zram_drv.c
diff --cc drivers/block/zram/zram_drv.c
index 5e4c81d01856,3f0d6de36f74..000000000000
--- a/drivers/block/zram/zram_drv.c
+++ b/drivers/block/zram/zram_drv.c
@@@ -671,51 -676,43 +675,61 @@@ out
  	return ret;
  }
  
- static void __zram_make_request(struct zram *zram, struct bio *bio, int rw)
+ static void __zram_make_request(struct zram *zram, struct bio *bio)
  {
 -	int offset;
 +	int i, offset;
  	u32 index;
 -	struct bio_vec bvec;
 -	struct bvec_iter iter;
 +	struct bio_vec *bvec;
  
++<<<<<<< HEAD
 +	switch (rw) {
 +	case READ:
 +		atomic64_inc(&zram->stats.num_reads);
 +		break;
 +	case WRITE:
 +		atomic64_inc(&zram->stats.num_writes);
 +		break;
 +	}
 +
 +	index = bio->bi_sector >> SECTORS_PER_PAGE_SHIFT;
 +	offset = (bio->bi_sector & (SECTORS_PER_PAGE - 1)) << SECTOR_SHIFT;
++=======
+ 	index = bio->bi_iter.bi_sector >> SECTORS_PER_PAGE_SHIFT;
+ 	offset = (bio->bi_iter.bi_sector &
+ 		  (SECTORS_PER_PAGE - 1)) << SECTOR_SHIFT;
++>>>>>>> be257c613067 (zram: do not pass rw argument to __zram_make_request())
  
 -	bio_for_each_segment(bvec, bio, iter) {
 +	bio_for_each_segment(bvec, bio, i) {
  		int max_transfer_size = PAGE_SIZE - offset;
  
 -		if (bvec.bv_len > max_transfer_size) {
 +		if (bvec->bv_len > max_transfer_size) {
  			/*
  			 * zram_bvec_rw() can only make operation on a single
  			 * zram page. Split the bio vector.
  			 */
  			struct bio_vec bv;
  
 -			bv.bv_page = bvec.bv_page;
 +			bv.bv_page = bvec->bv_page;
  			bv.bv_len = max_transfer_size;
 -			bv.bv_offset = bvec.bv_offset;
 +			bv.bv_offset = bvec->bv_offset;
  
- 			if (zram_bvec_rw(zram, &bv, index, offset, bio, rw) < 0)
+ 			if (zram_bvec_rw(zram, &bv, index, offset, bio) < 0)
  				goto out;
  
 -			bv.bv_len = bvec.bv_len - max_transfer_size;
 +			bv.bv_len = bvec->bv_len - max_transfer_size;
  			bv.bv_offset += max_transfer_size;
- 			if (zram_bvec_rw(zram, &bv, index+1, 0, bio, rw) < 0)
+ 			if (zram_bvec_rw(zram, &bv, index + 1, 0, bio) < 0)
  				goto out;
  		} else
++<<<<<<< HEAD
 +			if (zram_bvec_rw(zram, bvec, index, offset, bio, rw)
 +			    < 0)
++=======
+ 			if (zram_bvec_rw(zram, &bvec, index, offset, bio) < 0)
++>>>>>>> be257c613067 (zram: do not pass rw argument to __zram_make_request())
  				goto out;
  
 -		update_position(&index, &offset, &bvec);
 +		update_position(&index, &offset, bvec);
  	}
  
  	set_bit(BIO_UPTODATE, &bio->bi_flags);
* Unmerged path drivers/block/zram/zram_drv.c
