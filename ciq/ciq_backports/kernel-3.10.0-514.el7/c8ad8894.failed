NFSv4.2/pnfs: Use GFP_NOIO for layoutstat reporting in the writeback path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit c8ad8894e92b853df5a766061ee9cde7e10e682f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c8ad8894.failed

Prevent a potential deadlock.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit c8ad8894e92b853df5a766061ee9cde7e10e682f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pnfs.c
#	fs/nfs/pnfs.h
diff --cc fs/nfs/pnfs.c
index fc5892a40143,a6ec420983d1..000000000000
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@@ -2249,3 -2264,63 +2249,66 @@@ struct nfs4_threshold *pnfs_mdsthreshol
  	}
  	return thp;
  }
++<<<<<<< HEAD
++=======
+ 
+ #if IS_ENABLED(CONFIG_NFS_V4_2)
+ int
+ pnfs_report_layoutstat(struct inode *inode, gfp_t gfp_flags)
+ {
+ 	struct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;
+ 	struct nfs_server *server = NFS_SERVER(inode);
+ 	struct nfs_inode *nfsi = NFS_I(inode);
+ 	struct nfs42_layoutstat_data *data;
+ 	struct pnfs_layout_hdr *hdr;
+ 	int status = 0;
+ 
+ 	if (!pnfs_enabled_sb(server) || !ld->prepare_layoutstats)
+ 		goto out;
+ 
+ 	if (!nfs_server_capable(inode, NFS_CAP_LAYOUTSTATS))
+ 		goto out;
+ 
+ 	if (test_and_set_bit(NFS_INO_LAYOUTSTATS, &nfsi->flags))
+ 		goto out;
+ 
+ 	spin_lock(&inode->i_lock);
+ 	if (!NFS_I(inode)->layout) {
+ 		spin_unlock(&inode->i_lock);
+ 		goto out;
+ 	}
+ 	hdr = NFS_I(inode)->layout;
+ 	pnfs_get_layout_hdr(hdr);
+ 	spin_unlock(&inode->i_lock);
+ 
+ 	data = kzalloc(sizeof(*data), gfp_flags);
+ 	if (!data) {
+ 		status = -ENOMEM;
+ 		goto out_put;
+ 	}
+ 
+ 	data->args.fh = NFS_FH(inode);
+ 	data->args.inode = inode;
+ 	nfs4_stateid_copy(&data->args.stateid, &hdr->plh_stateid);
+ 	status = ld->prepare_layoutstats(&data->args);
+ 	if (status)
+ 		goto out_free;
+ 
+ 	status = nfs42_proc_layoutstats_generic(NFS_SERVER(inode), data);
+ 
+ out:
+ 	dprintk("%s returns %d\n", __func__, status);
+ 	return status;
+ 
+ out_free:
+ 	kfree(data);
+ out_put:
+ 	pnfs_put_layout_hdr(hdr);
+ 	smp_mb__before_atomic();
+ 	clear_bit(NFS_INO_LAYOUTSTATS, &nfsi->flags);
+ 	smp_mb__after_atomic();
+ 	goto out;
+ }
+ EXPORT_SYMBOL_GPL(pnfs_report_layoutstat);
+ #endif
++>>>>>>> c8ad8894e92b (NFSv4.2/pnfs: Use GFP_NOIO for layoutstat reporting in the writeback path)
diff --cc fs/nfs/pnfs.h
index e9fec461d335,738672a0f8da..000000000000
--- a/fs/nfs/pnfs.h
+++ b/fs/nfs/pnfs.h
@@@ -679,4 -690,14 +679,17 @@@ static inline void nfs4_pnfs_v3_ds_conn
  
  #endif /* CONFIG_NFS_V4_1 */
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_NFS_V4_2)
+ int pnfs_report_layoutstat(struct inode *inode, gfp_t gfp_flags);
+ #else
+ static inline int
+ pnfs_report_layoutstat(struct inode *inode, gfp_t gfp_flags)
+ {
+ 	return 0;
+ }
+ #endif
+ 
++>>>>>>> c8ad8894e92b (NFSv4.2/pnfs: Use GFP_NOIO for layoutstat reporting in the writeback path)
  #endif /* FS_NFS_PNFS_H */
diff --git a/fs/nfs/flexfilelayout/flexfilelayout.c b/fs/nfs/flexfilelayout/flexfilelayout.c
index 095059ea72d4..702db2880866 100644
--- a/fs/nfs/flexfilelayout/flexfilelayout.c
+++ b/fs/nfs/flexfilelayout/flexfilelayout.c
@@ -510,7 +510,8 @@ nfs4_ff_layout_stat_io_start_read(struct nfs4_ff_layout_mirror *mirror,
 	spin_unlock(&mirror->lock);
 
 	if (report)
-		pnfs_report_layoutstat(mirror->lseg->pls_layout->plh_inode);
+		pnfs_report_layoutstat(mirror->lseg->pls_layout->plh_inode,
+				GFP_KERNEL);
 }
 
 static void
@@ -538,7 +539,8 @@ nfs4_ff_layout_stat_io_start_write(struct nfs4_ff_layout_mirror *mirror,
 	spin_unlock(&mirror->lock);
 
 	if (report)
-		pnfs_report_layoutstat(mirror->lseg->pls_layout->plh_inode);
+		pnfs_report_layoutstat(mirror->lseg->pls_layout->plh_inode,
+				GFP_NOIO);
 }
 
 static void
* Unmerged path fs/nfs/pnfs.c
* Unmerged path fs/nfs/pnfs.h
