netlink: Move namespace into hash key

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit c428ecd1a21f1457ca3beb4df71b8a079c410e41
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c428ecd1.failed

Currently the name space is a de facto key because it has to match
before we find an object in the hash table.  However, it isn't in
the hash value so all objects from different name spaces with the
same port ID hash to the same bucket.

This is bad as the number of name spaces is unbounded.

This patch fixes this by using the namespace when doing the hash.

Because the namespace field doesn't lie next to the portid field
in the netlink socket, this patch switches over to the rhashtable
interface without a fixed key.

This patch also uses the new inlined rhashtable interface where
possible.

	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c428ecd1a21f1457ca3beb4df71b8a079c410e41)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netlink/af_netlink.c
diff --cc net/netlink/af_netlink.c
index 9d53ffe3d114,72c6b55af741..000000000000
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@@ -1015,15 -1000,23 +1029,26 @@@ static void netlink_compare_arg_init(st
  static struct sock *__netlink_lookup(struct netlink_table *table, u32 portid,
  				     struct net *net)
  {
- 	struct netlink_compare_arg arg = {
- 		.net = net,
- 		.portid = portid,
- 	};
+ 	struct netlink_compare_arg arg;
+ 
+ 	netlink_compare_arg_init(&arg, net, portid);
+ 	return rhashtable_lookup_fast(&table->hash, &arg,
+ 				      netlink_rhashtable_params);
+ }
+ 
++<<<<<<< HEAD
++=======
+ static int __netlink_insert(struct netlink_table *table, struct sock *sk)
+ {
+ 	struct netlink_compare_arg arg;
  
- 	return rhashtable_lookup_compare(&table->hash, &portid,
- 					 &netlink_compare, &arg);
+ 	netlink_compare_arg_init(&arg, sock_net(sk), nlk_sk(sk)->portid);
+ 	return rhashtable_lookup_insert_key(&table->hash, &arg,
+ 					    &nlk_sk(sk)->node,
+ 					    netlink_rhashtable_params);
  }
  
++>>>>>>> c428ecd1a21f (netlink: Move namespace into hash key)
  static struct sock *netlink_lookup(struct net *net, int protocol, u32 portid)
  {
  	struct netlink_table *table = &nl_table[protocol];
@@@ -1083,10 -1075,16 +1108,21 @@@ static int netlink_insert(struct sock *
  
  	nlk_sk(sk)->portid = portid;
  	sock_hold(sk);
++<<<<<<< HEAD
 +	rhashtable_insert(&table->hash, &nlk_sk(sk)->node);
 +	err = 0;
++=======
+ 
+ 	err = __netlink_insert(table, sk);
+ 	if (err) {
+ 		if (err == -EEXIST)
+ 			err = -EADDRINUSE;
+ 		sock_put(sk);
+ 	}
+ 
++>>>>>>> c428ecd1a21f (netlink: Move namespace into hash key)
  err:
 -	release_sock(sk);
 +	mutex_unlock(&nl_sk_hash_lock);
  	return err;
  }
  
@@@ -1094,9 -1092,9 +1130,10 @@@ static void netlink_remove(struct sock 
  {
  	struct netlink_table *table;
  
 +	mutex_lock(&nl_sk_hash_lock);
  	table = &nl_table[sk->sk_protocol];
- 	if (rhashtable_remove(&table->hash, &nlk_sk(sk)->node)) {
+ 	if (!rhashtable_remove_fast(&table->hash, &nlk_sk(sk)->node,
+ 				    netlink_rhashtable_params)) {
  		WARN_ON(atomic_read(&sk->sk_refcnt) == 1);
  		__sock_put(sk);
  	}
@@@ -3150,16 -3148,6 +3205,19 @@@ static int __init netlink_proto_init(vo
  {
  	int i;
  	int err = proto_register(&netlink_proto, 0);
++<<<<<<< HEAD
 +	struct rhashtable_params ht_params = {
 +		.head_offset = offsetof(struct netlink_sock, node),
 +		.key_offset = offsetof(struct netlink_sock, portid),
 +		.key_len = sizeof(u32), /* portid */
 +		.hashfn = jhash,
 +		.max_shift = 16, /* 64K */
 +		.grow_decision = rht_grow_above_75,
 +		.shrink_decision = rht_shrink_below_30,
 +		.mutex_is_held = lockdep_nl_sk_hash_is_held,
 +	};
++=======
++>>>>>>> c428ecd1a21f (netlink: Move namespace into hash key)
  
  	if (err != 0)
  		goto out;
* Unmerged path net/netlink/af_netlink.c
