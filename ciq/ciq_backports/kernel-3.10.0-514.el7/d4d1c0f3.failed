iommu/vt-d: Set IRTA in intel_setup_irq_remapping

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [iommu] vt-d: Set IRTA in intel_setup_irq_remapping (Myron Stowe) [1050021]
Rebuild_FUZZ: 93.48%
commit-author Joerg Roedel <jroedel@suse.de>
commit d4d1c0f3d6a9558fe3857853afdf2f93e1679c03
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d4d1c0f3.failed

This way we can give the hardware the new IR table right
after it has been allocated and initialized.

	Tested-by: ZhenHua Li <zhen-hual@hp.com>
	Tested-by: Baoquan He <bhe@redhat.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit d4d1c0f3d6a9558fe3857853afdf2f93e1679c03)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel_irq_remapping.c
diff --cc drivers/iommu/intel_irq_remapping.c
index 085a116a8b0a,84970281b754..000000000000
--- a/drivers/iommu/intel_irq_remapping.c
+++ b/drivers/iommu/intel_irq_remapping.c
@@@ -505,8 -513,30 +511,31 @@@ static int intel_setup_irq_remapping(st
  	ir_table->base = page_address(pages);
  	ir_table->bitmap = bitmap;
  	iommu->ir_table = ir_table;
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * If the queued invalidation is already initialized,
+ 	 * shouldn't disable it.
+ 	 */
+ 	if (!iommu->qi) {
+ 		/*
+ 		 * Clear previous faults.
+ 		 */
+ 		dmar_fault(-1, iommu);
+ 		dmar_disable_qi(iommu);
+ 
+ 		if (dmar_enable_qi(iommu)) {
+ 			pr_err("Failed to enable queued invalidation\n");
+ 			goto out_free_bitmap;
+ 		}
+ 	}
+ 
+ 	iommu_set_irq_remapping(iommu, eim_mode);
+ 
++>>>>>>> d4d1c0f3d6a9 (iommu/vt-d: Set IRTA in intel_setup_irq_remapping)
  	return 0;
  
 -out_free_bitmap:
 -	kfree(bitmap);
  out_free_pages:
  	__free_pages(pages, INTR_REMAP_PAGE_ORDER);
  out_free_table:
@@@ -693,7 -697,7 +722,11 @@@ static int __init intel_enable_irq_rema
  	 * Setup Interrupt-remapping for all the DRHD's now.
  	 */
  	for_each_iommu(iommu, drhd) {
++<<<<<<< HEAD
 +		iommu_set_irq_remapping(iommu, eim);
++=======
+ 		iommu_enable_irq_remapping(iommu);
++>>>>>>> d4d1c0f3d6a9 (iommu/vt-d: Set IRTA in intel_setup_irq_remapping)
  		setup = true;
  	}
  
@@@ -1242,28 -1245,12 +1276,33 @@@ static int dmar_ir_add(struct dmar_drhd
  	/* Setup Interrupt-remapping now. */
  	ret = intel_setup_irq_remapping(iommu);
  	if (ret) {
 -		pr_err("Failed to setup irq remapping for %s\n",
 -		       iommu->name);
 +		pr_err("DRHD %Lx: failed to allocate resource\n",
 +		       iommu->reg_phys);
 +		ir_remove_ioapic_hpet_scope(iommu);
 +		return ret;
 +	}
 +
 +	if (!iommu->qi) {
 +		/* Clear previous faults. */
 +		dmar_fault(-1, iommu);
 +		iommu_disable_irq_remapping(iommu);
 +		dmar_disable_qi(iommu);
 +	}
 +
 +	/* Enable queued invalidation */
 +	ret = dmar_enable_qi(iommu);
 +	if (!ret) {
 +		iommu_set_irq_remapping(iommu, eim);
 +	} else {
 +		pr_err("DRHD %Lx: failed to enable queued invalidation, ecap %Lx, ret %d\n",
 +		       iommu->reg_phys, iommu->ecap, ret);
  		intel_teardown_irq_remapping(iommu);
  		ir_remove_ioapic_hpet_scope(iommu);
++<<<<<<< HEAD
++=======
+ 	} else {
+ 		iommu_enable_irq_remapping(iommu);
++>>>>>>> d4d1c0f3d6a9 (iommu/vt-d: Set IRTA in intel_setup_irq_remapping)
  	}
  
  	return ret;
* Unmerged path drivers/iommu/intel_irq_remapping.c
