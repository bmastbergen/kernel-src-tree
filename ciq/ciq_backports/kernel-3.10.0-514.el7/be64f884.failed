dax: unify ext2/4_{dax,}_file_operations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Boaz Harrosh <boaz@plexistor.com>
commit be64f884bed729b5d127db6a737155a4e514d286
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/be64f884.failed

The original dax patchset split the ext2/4_file_operations because of the
two NULL splice_read/splice_write in the dax case.

In the vfs if splice_read/splice_write are NULL we then call
default_splice_read/write.

What we do here is make generic_file_splice_read aware of IS_DAX() so the
original ext2/4_file_operations can be used as is.

For write it appears that iter_file_splice_write is just fine.  It uses
the regular f_op->write(file,..) or new_sync_write(file, ...).

	Signed-off-by: Boaz Harrosh <boaz@plexistor.com>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Cc: Dave Chinner <dchinner@redhat.com>
	Cc: Matthew Wilcox <willy@linux.intel.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit be64f884bed729b5d127db6a737155a4e514d286)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext2/ext2.h
#	fs/ext2/file.c
#	fs/ext2/inode.c
#	fs/ext2/namei.c
#	fs/ext4/namei.c
diff --cc fs/ext2/ext2.h
index d9a17d0b124d,8d15febd0aa3..000000000000
--- a/fs/ext2/ext2.h
+++ b/fs/ext2/ext2.h
@@@ -785,7 -793,6 +785,10 @@@ extern int ext2_fsync(struct file *file
  		      int datasync);
  extern const struct inode_operations ext2_file_inode_operations;
  extern const struct file_operations ext2_file_operations;
++<<<<<<< HEAD
 +extern const struct file_operations ext2_xip_file_operations;
++=======
++>>>>>>> be64f884bed7 (dax: unify ext2/4_{dax,}_file_operations)
  
  /* inode.c */
  extern const struct address_space_operations ext2_aops;
diff --cc fs/ext2/file.c
index a5b3a5db3120,19cac93a65d3..000000000000
--- a/fs/ext2/file.c
+++ b/fs/ext2/file.c
@@@ -75,25 -106,9 +75,28 @@@ const struct file_operations ext2_file_
  	.release	= ext2_release_file,
  	.fsync		= ext2_fsync,
  	.splice_read	= generic_file_splice_read,
 -	.splice_write	= iter_file_splice_write,
 +	.splice_write	= generic_file_splice_write,
 +};
 +
++<<<<<<< HEAD
 +#ifdef CONFIG_EXT2_FS_XIP
 +const struct file_operations ext2_xip_file_operations = {
 +	.llseek		= generic_file_llseek,
 +	.read		= xip_file_read,
 +	.write		= xip_file_write,
 +	.unlocked_ioctl = ext2_ioctl,
 +#ifdef CONFIG_COMPAT
 +	.compat_ioctl	= ext2_compat_ioctl,
 +#endif
 +	.mmap		= xip_file_mmap,
 +	.open		= dquot_file_open,
 +	.release	= ext2_release_file,
 +	.fsync		= ext2_fsync,
  };
 +#endif
  
++=======
++>>>>>>> be64f884bed7 (dax: unify ext2/4_{dax,}_file_operations)
  const struct inode_operations ext2_file_inode_operations = {
  #ifdef CONFIG_EXT2_FS_XATTR
  	.setxattr	= generic_setxattr,
diff --cc fs/ext2/inode.c
index 115fa58bb9ae,b29eb6747116..000000000000
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@@ -1382,10 -1388,7 +1382,14 @@@ struct inode *ext2_iget (struct super_b
  
  	if (S_ISREG(inode->i_mode)) {
  		inode->i_op = &ext2_file_inode_operations;
++<<<<<<< HEAD
 +		if (ext2_use_xip(inode->i_sb)) {
 +			inode->i_mapping->a_ops = &ext2_aops_xip;
 +			inode->i_fop = &ext2_xip_file_operations;
 +		} else if (test_opt(inode->i_sb, NOBH)) {
++=======
+ 		if (test_opt(inode->i_sb, NOBH)) {
++>>>>>>> be64f884bed7 (dax: unify ext2/4_{dax,}_file_operations)
  			inode->i_mapping->a_ops = &ext2_nobh_aops;
  			inode->i_fop = &ext2_file_operations;
  		} else {
diff --cc fs/ext2/namei.c
index 73b0d9519836,ce422931f411..000000000000
--- a/fs/ext2/namei.c
+++ b/fs/ext2/namei.c
@@@ -105,10 -104,7 +105,14 @@@ static int ext2_create (struct inode * 
  		return PTR_ERR(inode);
  
  	inode->i_op = &ext2_file_inode_operations;
++<<<<<<< HEAD
 +	if (ext2_use_xip(inode->i_sb)) {
 +		inode->i_mapping->a_ops = &ext2_aops_xip;
 +		inode->i_fop = &ext2_xip_file_operations;
 +	} else if (test_opt(inode->i_sb, NOBH)) {
++=======
+ 	if (test_opt(inode->i_sb, NOBH)) {
++>>>>>>> be64f884bed7 (dax: unify ext2/4_{dax,}_file_operations)
  		inode->i_mapping->a_ops = &ext2_nobh_aops;
  		inode->i_fop = &ext2_file_operations;
  	} else {
@@@ -119,6 -115,26 +123,29 @@@
  	return ext2_add_nondir(dentry, inode);
  }
  
++<<<<<<< HEAD
++=======
+ static int ext2_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)
+ {
+ 	struct inode *inode = ext2_new_inode(dir, mode, NULL);
+ 	if (IS_ERR(inode))
+ 		return PTR_ERR(inode);
+ 
+ 	inode->i_op = &ext2_file_inode_operations;
+ 	if (test_opt(inode->i_sb, NOBH)) {
+ 		inode->i_mapping->a_ops = &ext2_nobh_aops;
+ 		inode->i_fop = &ext2_file_operations;
+ 	} else {
+ 		inode->i_mapping->a_ops = &ext2_aops;
+ 		inode->i_fop = &ext2_file_operations;
+ 	}
+ 	mark_inode_dirty(inode);
+ 	d_tmpfile(dentry, inode);
+ 	unlock_new_inode(inode);
+ 	return 0;
+ }
+ 
++>>>>>>> be64f884bed7 (dax: unify ext2/4_{dax,}_file_operations)
  static int ext2_mknod (struct inode * dir, struct dentry *dentry, umode_t mode, dev_t rdev)
  {
  	struct inode * inode;
diff --cc fs/ext4/namei.c
index 06be148622f8,2291923dae4e..000000000000
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@@ -2307,6 -2281,44 +2307,47 @@@ retry
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int ext4_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)
+ {
+ 	handle_t *handle;
+ 	struct inode *inode;
+ 	int err, retries = 0;
+ 
+ 	dquot_initialize(dir);
+ 
+ retry:
+ 	inode = ext4_new_inode_start_handle(dir, mode,
+ 					    NULL, 0, NULL,
+ 					    EXT4_HT_DIR,
+ 			EXT4_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +
+ 			  4 + EXT4_XATTR_TRANS_BLOCKS);
+ 	handle = ext4_journal_current_handle();
+ 	err = PTR_ERR(inode);
+ 	if (!IS_ERR(inode)) {
+ 		inode->i_op = &ext4_file_inode_operations;
+ 		inode->i_fop = &ext4_file_operations;
+ 		ext4_set_aops(inode);
+ 		d_tmpfile(dentry, inode);
+ 		err = ext4_orphan_add(handle, inode);
+ 		if (err)
+ 			goto err_unlock_inode;
+ 		mark_inode_dirty(inode);
+ 		unlock_new_inode(inode);
+ 	}
+ 	if (handle)
+ 		ext4_journal_stop(handle);
+ 	if (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))
+ 		goto retry;
+ 	return err;
+ err_unlock_inode:
+ 	ext4_journal_stop(handle);
+ 	unlock_new_inode(inode);
+ 	return err;
+ }
+ 
++>>>>>>> be64f884bed7 (dax: unify ext2/4_{dax,}_file_operations)
  struct ext4_dir_entry_2 *ext4_init_dot_dotdot(struct inode *inode,
  			  struct ext4_dir_entry_2 *de,
  			  int blocksize, int csum_size,
* Unmerged path fs/ext2/ext2.h
* Unmerged path fs/ext2/file.c
* Unmerged path fs/ext2/inode.c
* Unmerged path fs/ext2/namei.c
* Unmerged path fs/ext4/namei.c
diff --git a/fs/splice.c b/fs/splice.c
index 883d55b93ddb..f2d7d43a5abf 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -526,6 +526,9 @@ ssize_t generic_file_splice_read(struct file *in, loff_t *ppos,
 	loff_t isize, left;
 	int ret;
 
+	if (IS_DAX(in->f_mapping->host))
+		return default_file_splice_read(in, ppos, pipe, len, flags);
+
 	isize = i_size_read(in->f_mapping->host);
 	if (unlikely(*ppos >= isize))
 		return 0;
