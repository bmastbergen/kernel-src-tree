nvme: move remaining CC setup into nvme_enable_ctrl

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 1b2eb374651f0496b86ed5f095d4c448bff214fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1b2eb374.failed

Remove the calculation of all the bits written into the CC register into
nvme_enable_ctrl, so that they can be moved into the core NVMe driver in
the future.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 1b2eb374651f0496b86ed5f095d4c448bff214fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index 2a6eb55ad96c,1ae94cd74702..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -1400,9 -1446,29 +1400,33 @@@ static int nvme_disable_ctrl(struct nvm
  
  static int nvme_enable_ctrl(struct nvme_dev *dev, u64 cap)
  {
- 	dev->ctrl_config &= ~NVME_CC_SHN_MASK;
+ 	/*
+ 	 * Default to a 4K page size, with the intention to update this
+ 	 * path in the future to accomodate architectures with differing
+ 	 * kernel and IO page sizes.
+ 	 */
+ 	unsigned dev_page_min = NVME_CAP_MPSMIN(cap) + 12, page_shift = 12;
+ 
+ 	if (page_shift < dev_page_min) {
+ 		dev_err(dev->dev,
+ 			"Minimum device page size %u too large for host (%u)\n",
+ 			1 << dev_page_min, 1 << page_shift);
+ 		return -ENODEV;
+ 	}
+ 
+ 	dev->page_size = 1 << page_shift;
+ 
+ 	dev->ctrl_config = NVME_CC_CSS_NVM;
+ 	dev->ctrl_config |= (page_shift - 12) << NVME_CC_MPS_SHIFT;
+ 	dev->ctrl_config |= NVME_CC_ARB_RR | NVME_CC_SHN_NONE;
+ 	dev->ctrl_config |= NVME_CC_IOSQES | NVME_CC_IOCQES;
  	dev->ctrl_config |= NVME_CC_ENABLE;
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +	writel(dev->ctrl_config, &dev->bar->cc);
++=======
+ 
+ 	writel(dev->ctrl_config, dev->bar + NVME_REG_CC);
++>>>>>>> 1b2eb374651f (nvme: move remaining CC setup into nvme_enable_ctrl):drivers/nvme/host/pci.c
  
  	return nvme_wait_ready(dev, cap, true);
  }
@@@ -1492,32 -1559,15 +1516,35 @@@ static int nvme_configure_admin_queue(s
  {
  	int result;
  	u32 aqa;
 -	u64 cap = lo_hi_readq(dev->bar + NVME_REG_CAP);
 +	u64 cap = readq(&dev->bar->cap);
  	struct nvme_queue *nvmeq;
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +	unsigned page_shift = PAGE_SHIFT;
 +	unsigned dev_page_min = NVME_CAP_MPSMIN(cap) + 12;
 +	unsigned dev_page_max = NVME_CAP_MPSMAX(cap) + 12;
 +
 +	if (page_shift < dev_page_min) {
 +		dev_err(&dev->pci_dev->dev,
 +				"Minimum device page size (%u) too large for "
 +				"host (%u)\n", 1 << dev_page_min,
 +				1 << page_shift);
 +		return -ENODEV;
 +	}
 +	if (page_shift > dev_page_max) {
 +		dev_info(&dev->pci_dev->dev,
 +				"Device maximum page size (%u) smaller than "
 +				"host (%u); enabling work-around\n",
 +				1 << dev_page_max, 1 << page_shift);
 +		page_shift = dev_page_max;
 +	}
++=======
++>>>>>>> 1b2eb374651f (nvme: move remaining CC setup into nvme_enable_ctrl):drivers/nvme/host/pci.c
  
 -	dev->subsystem = readl(dev->bar + NVME_REG_VS) >= NVME_VS(1, 1) ?
 +	dev->subsystem = readl(&dev->bar->vs) >= NVME_VS(1, 1) ?
  						NVME_CAP_NSSRC(cap) : 0;
  
 -	if (dev->subsystem &&
 -	    (readl(dev->bar + NVME_REG_CSTS) & NVME_CSTS_NSSRO))
 -		writel(NVME_CSTS_NSSRO, dev->bar + NVME_REG_CSTS);
 +	if (dev->subsystem && (readl(&dev->bar->csts) & NVME_CSTS_NSSRO))
 +		writel(NVME_CSTS_NSSRO, &dev->bar->csts);
  
  	result = nvme_disable_ctrl(dev, cap);
  	if (result < 0)
@@@ -1533,16 -1583,9 +1560,22 @@@
  	aqa = nvmeq->q_depth - 1;
  	aqa |= aqa << 16;
  
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +	dev->page_size = 1 << page_shift;
 +
 +	dev->ctrl_config = NVME_CC_CSS_NVM;
 +	dev->ctrl_config |= (page_shift - 12) << NVME_CC_MPS_SHIFT;
 +	dev->ctrl_config |= NVME_CC_ARB_RR | NVME_CC_SHN_NONE;
 +	dev->ctrl_config |= NVME_CC_IOSQES | NVME_CC_IOCQES;
 +
 +	writel(aqa, &dev->bar->aqa);
 +	writeq(nvmeq->sq_dma_addr, &dev->bar->asq);
 +	writeq(nvmeq->cq_dma_addr, &dev->bar->acq);
++=======
+ 	writel(aqa, dev->bar + NVME_REG_AQA);
+ 	lo_hi_writeq(nvmeq->sq_dma_addr, dev->bar + NVME_REG_ASQ);
+ 	lo_hi_writeq(nvmeq->cq_dma_addr, dev->bar + NVME_REG_ACQ);
++>>>>>>> 1b2eb374651f (nvme: move remaining CC setup into nvme_enable_ctrl):drivers/nvme/host/pci.c
  
  	result = nvme_enable_ctrl(dev, cap);
  	if (result)
* Unmerged path drivers/block/nvme-core.c
