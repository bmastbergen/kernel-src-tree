cxl: IRQ allocation for guests

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Frederic Barrat <fbarrat@linux.vnet.ibm.com>
commit 73d55c3b59f7d9cadc1dbc07d75ccee6c81fdf5b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/73d55c3b.failed

The PSL interrupt cannot be multiplexed in a guest, as it is not
supported by the hypervisor. So an interrupt will be allocated
for it for each context. It will still be the first interrupt found in
the first interrupt range, but is treated almost like any other AFU
interrupt when creating/deleting the context. Only the handler is
different. Rework the code so that the range 0 is treated like the
other ranges.

Co-authored-by: Christophe Lombard <clombard@linux.vnet.ibm.com>
	Signed-off-by: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
	Signed-off-by: Christophe Lombard <clombard@linux.vnet.ibm.com>
	Reviewed-by: Manoj Kumar <manoj@linux.vnet.ibm.com>
	Acked-by: Ian Munsie <imunsie@au1.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 73d55c3b59f7d9cadc1dbc07d75ccee6c81fdf5b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/cxl/irq.c
diff --cc drivers/misc/cxl/irq.c
index 0123d6e2be16,3c04c14d1c60..000000000000
--- a/drivers/misc/cxl/irq.c
+++ b/drivers/misc/cxl/irq.c
@@@ -229,12 -264,15 +262,19 @@@ int afu_allocate_irqs(struct cxl_contex
  	/* Initialize the list head to hold irq names */
  	INIT_LIST_HEAD(&ctx->irq_names);
  
++<<<<<<< HEAD
 +	if ((rc = cxl_alloc_irq_ranges(&ctx->irqs, ctx->afu->adapter, count)))
++=======
+ 	if ((rc = cxl_ops->alloc_irq_ranges(&ctx->irqs, ctx->afu->adapter,
+ 							alloc_count)))
++>>>>>>> 73d55c3b59f7 (cxl: IRQ allocation for guests)
  		return rc;
  
- 	/* Multiplexed PSL Interrupt */
- 	ctx->irqs.offset[0] = ctx->afu->psl_hwirq;
- 	ctx->irqs.range[0] = 1;
+ 	if (cpu_has_feature(CPU_FTR_HVMODE)) {
+ 		/* Multiplexed PSL Interrupt */
+ 		ctx->irqs.offset[0] = ctx->afu->psl_hwirq;
+ 		ctx->irqs.range[0] = 1;
+ 	}
  
  	ctx->irq_count = count;
  	ctx->irq_bitmap = kcalloc(BITS_TO_LONGS(count),
* Unmerged path drivers/misc/cxl/irq.c
