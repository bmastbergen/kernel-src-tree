Bluetooth: Fix potential buffer overflow with Add Advertising

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Johan Hedberg <johan.hedberg@intel.com>
commit 6a0e78072c2ae7b20b14e0249d8108441ea928d2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6a0e7807.failed

The Add Advertising command handler does the appropriate checks for
the AD and Scan Response data, however fails to take into account the
general length of the mgmt command itself, which could lead to
potential buffer overflows. This patch adds the necessary check that
the mgmt command length is consistent with the given ad and scan_rsp
lengths.

	Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
	Cc: stable@vger.kernel.org
(cherry picked from commit 6a0e78072c2ae7b20b14e0249d8108441ea928d2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/mgmt.c
diff --cc net/bluetooth/mgmt.c
index b3dcf0e11c28,9e4b931588cf..000000000000
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@@ -3114,213 -4660,1797 +3114,1824 @@@ static int load_long_term_keys(struct s
  	return err;
  }
  
++<<<<<<< HEAD
 +static const struct mgmt_handler {
 +	int (*func) (struct sock *sk, struct hci_dev *hdev, void *data,
 +		     u16 data_len);
 +	bool var_len;
 +	size_t data_len;
 +} mgmt_handlers[] = {
++=======
+ static int conn_info_cmd_complete(struct mgmt_pending_cmd *cmd, u8 status)
+ {
+ 	struct hci_conn *conn = cmd->user_data;
+ 	struct mgmt_rp_get_conn_info rp;
+ 	int err;
+ 
+ 	memcpy(&rp.addr, cmd->param, sizeof(rp.addr));
+ 
+ 	if (status == MGMT_STATUS_SUCCESS) {
+ 		rp.rssi = conn->rssi;
+ 		rp.tx_power = conn->tx_power;
+ 		rp.max_tx_power = conn->max_tx_power;
+ 	} else {
+ 		rp.rssi = HCI_RSSI_INVALID;
+ 		rp.tx_power = HCI_TX_POWER_INVALID;
+ 		rp.max_tx_power = HCI_TX_POWER_INVALID;
+ 	}
+ 
+ 	err = mgmt_cmd_complete(cmd->sk, cmd->index, MGMT_OP_GET_CONN_INFO,
+ 				status, &rp, sizeof(rp));
+ 
+ 	hci_conn_drop(conn);
+ 	hci_conn_put(conn);
+ 
+ 	return err;
+ }
+ 
+ static void conn_info_refresh_complete(struct hci_dev *hdev, u8 hci_status,
+ 				       u16 opcode)
+ {
+ 	struct hci_cp_read_rssi *cp;
+ 	struct mgmt_pending_cmd *cmd;
+ 	struct hci_conn *conn;
+ 	u16 handle;
+ 	u8 status;
+ 
+ 	BT_DBG("status 0x%02x", hci_status);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	/* Commands sent in request are either Read RSSI or Read Transmit Power
+ 	 * Level so we check which one was last sent to retrieve connection
+ 	 * handle.  Both commands have handle as first parameter so it's safe to
+ 	 * cast data on the same command struct.
+ 	 *
+ 	 * First command sent is always Read RSSI and we fail only if it fails.
+ 	 * In other case we simply override error to indicate success as we
+ 	 * already remembered if TX power value is actually valid.
+ 	 */
+ 	cp = hci_sent_cmd_data(hdev, HCI_OP_READ_RSSI);
+ 	if (!cp) {
+ 		cp = hci_sent_cmd_data(hdev, HCI_OP_READ_TX_POWER);
+ 		status = MGMT_STATUS_SUCCESS;
+ 	} else {
+ 		status = mgmt_status(hci_status);
+ 	}
+ 
+ 	if (!cp) {
+ 		BT_ERR("invalid sent_cmd in conn_info response");
+ 		goto unlock;
+ 	}
+ 
+ 	handle = __le16_to_cpu(cp->handle);
+ 	conn = hci_conn_hash_lookup_handle(hdev, handle);
+ 	if (!conn) {
+ 		BT_ERR("unknown handle (%d) in conn_info response", handle);
+ 		goto unlock;
+ 	}
+ 
+ 	cmd = pending_find_data(MGMT_OP_GET_CONN_INFO, hdev, conn);
+ 	if (!cmd)
+ 		goto unlock;
+ 
+ 	cmd->cmd_complete(cmd, status);
+ 	mgmt_pending_remove(cmd);
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ }
+ 
+ static int get_conn_info(struct sock *sk, struct hci_dev *hdev, void *data,
+ 			 u16 len)
+ {
+ 	struct mgmt_cp_get_conn_info *cp = data;
+ 	struct mgmt_rp_get_conn_info rp;
+ 	struct hci_conn *conn;
+ 	unsigned long conn_info_age;
+ 	int err = 0;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	memset(&rp, 0, sizeof(rp));
+ 	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
+ 	rp.addr.type = cp->addr.type;
+ 
+ 	if (!bdaddr_type_is_valid(cp->addr.type))
+ 		return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,
+ 					 MGMT_STATUS_INVALID_PARAMS,
+ 					 &rp, sizeof(rp));
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	if (!hdev_is_powered(hdev)) {
+ 		err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,
+ 					MGMT_STATUS_NOT_POWERED, &rp,
+ 					sizeof(rp));
+ 		goto unlock;
+ 	}
+ 
+ 	if (cp->addr.type == BDADDR_BREDR)
+ 		conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,
+ 					       &cp->addr.bdaddr);
+ 	else
+ 		conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->addr.bdaddr);
+ 
+ 	if (!conn || conn->state != BT_CONNECTED) {
+ 		err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,
+ 					MGMT_STATUS_NOT_CONNECTED, &rp,
+ 					sizeof(rp));
+ 		goto unlock;
+ 	}
+ 
+ 	if (pending_find_data(MGMT_OP_GET_CONN_INFO, hdev, conn)) {
+ 		err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,
+ 					MGMT_STATUS_BUSY, &rp, sizeof(rp));
+ 		goto unlock;
+ 	}
+ 
+ 	/* To avoid client trying to guess when to poll again for information we
+ 	 * calculate conn info age as random value between min/max set in hdev.
+ 	 */
+ 	conn_info_age = hdev->conn_info_min_age +
+ 			prandom_u32_max(hdev->conn_info_max_age -
+ 					hdev->conn_info_min_age);
+ 
+ 	/* Query controller to refresh cached values if they are too old or were
+ 	 * never read.
+ 	 */
+ 	if (time_after(jiffies, conn->conn_info_timestamp +
+ 		       msecs_to_jiffies(conn_info_age)) ||
+ 	    !conn->conn_info_timestamp) {
+ 		struct hci_request req;
+ 		struct hci_cp_read_tx_power req_txp_cp;
+ 		struct hci_cp_read_rssi req_rssi_cp;
+ 		struct mgmt_pending_cmd *cmd;
+ 
+ 		hci_req_init(&req, hdev);
+ 		req_rssi_cp.handle = cpu_to_le16(conn->handle);
+ 		hci_req_add(&req, HCI_OP_READ_RSSI, sizeof(req_rssi_cp),
+ 			    &req_rssi_cp);
+ 
+ 		/* For LE links TX power does not change thus we don't need to
+ 		 * query for it once value is known.
+ 		 */
+ 		if (!bdaddr_type_is_le(cp->addr.type) ||
+ 		    conn->tx_power == HCI_TX_POWER_INVALID) {
+ 			req_txp_cp.handle = cpu_to_le16(conn->handle);
+ 			req_txp_cp.type = 0x00;
+ 			hci_req_add(&req, HCI_OP_READ_TX_POWER,
+ 				    sizeof(req_txp_cp), &req_txp_cp);
+ 		}
+ 
+ 		/* Max TX power needs to be read only once per connection */
+ 		if (conn->max_tx_power == HCI_TX_POWER_INVALID) {
+ 			req_txp_cp.handle = cpu_to_le16(conn->handle);
+ 			req_txp_cp.type = 0x01;
+ 			hci_req_add(&req, HCI_OP_READ_TX_POWER,
+ 				    sizeof(req_txp_cp), &req_txp_cp);
+ 		}
+ 
+ 		err = hci_req_run(&req, conn_info_refresh_complete);
+ 		if (err < 0)
+ 			goto unlock;
+ 
+ 		cmd = mgmt_pending_add(sk, MGMT_OP_GET_CONN_INFO, hdev,
+ 				       data, len);
+ 		if (!cmd) {
+ 			err = -ENOMEM;
+ 			goto unlock;
+ 		}
+ 
+ 		hci_conn_hold(conn);
+ 		cmd->user_data = hci_conn_get(conn);
+ 		cmd->cmd_complete = conn_info_cmd_complete;
+ 
+ 		conn->conn_info_timestamp = jiffies;
+ 	} else {
+ 		/* Cache is valid, just reply with values cached in hci_conn */
+ 		rp.rssi = conn->rssi;
+ 		rp.tx_power = conn->tx_power;
+ 		rp.max_tx_power = conn->max_tx_power;
+ 
+ 		err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,
+ 					MGMT_STATUS_SUCCESS, &rp, sizeof(rp));
+ 	}
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ 	return err;
+ }
+ 
+ static int clock_info_cmd_complete(struct mgmt_pending_cmd *cmd, u8 status)
+ {
+ 	struct hci_conn *conn = cmd->user_data;
+ 	struct mgmt_rp_get_clock_info rp;
+ 	struct hci_dev *hdev;
+ 	int err;
+ 
+ 	memset(&rp, 0, sizeof(rp));
+ 	memcpy(&rp.addr, &cmd->param, sizeof(rp.addr));
+ 
+ 	if (status)
+ 		goto complete;
+ 
+ 	hdev = hci_dev_get(cmd->index);
+ 	if (hdev) {
+ 		rp.local_clock = cpu_to_le32(hdev->clock);
+ 		hci_dev_put(hdev);
+ 	}
+ 
+ 	if (conn) {
+ 		rp.piconet_clock = cpu_to_le32(conn->clock);
+ 		rp.accuracy = cpu_to_le16(conn->clock_accuracy);
+ 	}
+ 
+ complete:
+ 	err = mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, status, &rp,
+ 				sizeof(rp));
+ 
+ 	if (conn) {
+ 		hci_conn_drop(conn);
+ 		hci_conn_put(conn);
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static void get_clock_info_complete(struct hci_dev *hdev, u8 status, u16 opcode)
+ {
+ 	struct hci_cp_read_clock *hci_cp;
+ 	struct mgmt_pending_cmd *cmd;
+ 	struct hci_conn *conn;
+ 
+ 	BT_DBG("%s status %u", hdev->name, status);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	hci_cp = hci_sent_cmd_data(hdev, HCI_OP_READ_CLOCK);
+ 	if (!hci_cp)
+ 		goto unlock;
+ 
+ 	if (hci_cp->which) {
+ 		u16 handle = __le16_to_cpu(hci_cp->handle);
+ 		conn = hci_conn_hash_lookup_handle(hdev, handle);
+ 	} else {
+ 		conn = NULL;
+ 	}
+ 
+ 	cmd = pending_find_data(MGMT_OP_GET_CLOCK_INFO, hdev, conn);
+ 	if (!cmd)
+ 		goto unlock;
+ 
+ 	cmd->cmd_complete(cmd, mgmt_status(status));
+ 	mgmt_pending_remove(cmd);
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ }
+ 
+ static int get_clock_info(struct sock *sk, struct hci_dev *hdev, void *data,
+ 			 u16 len)
+ {
+ 	struct mgmt_cp_get_clock_info *cp = data;
+ 	struct mgmt_rp_get_clock_info rp;
+ 	struct hci_cp_read_clock hci_cp;
+ 	struct mgmt_pending_cmd *cmd;
+ 	struct hci_request req;
+ 	struct hci_conn *conn;
+ 	int err;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	memset(&rp, 0, sizeof(rp));
+ 	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
+ 	rp.addr.type = cp->addr.type;
+ 
+ 	if (cp->addr.type != BDADDR_BREDR)
+ 		return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CLOCK_INFO,
+ 					 MGMT_STATUS_INVALID_PARAMS,
+ 					 &rp, sizeof(rp));
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	if (!hdev_is_powered(hdev)) {
+ 		err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CLOCK_INFO,
+ 					MGMT_STATUS_NOT_POWERED, &rp,
+ 					sizeof(rp));
+ 		goto unlock;
+ 	}
+ 
+ 	if (bacmp(&cp->addr.bdaddr, BDADDR_ANY)) {
+ 		conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,
+ 					       &cp->addr.bdaddr);
+ 		if (!conn || conn->state != BT_CONNECTED) {
+ 			err = mgmt_cmd_complete(sk, hdev->id,
+ 						MGMT_OP_GET_CLOCK_INFO,
+ 						MGMT_STATUS_NOT_CONNECTED,
+ 						&rp, sizeof(rp));
+ 			goto unlock;
+ 		}
+ 	} else {
+ 		conn = NULL;
+ 	}
+ 
+ 	cmd = mgmt_pending_add(sk, MGMT_OP_GET_CLOCK_INFO, hdev, data, len);
+ 	if (!cmd) {
+ 		err = -ENOMEM;
+ 		goto unlock;
+ 	}
+ 
+ 	cmd->cmd_complete = clock_info_cmd_complete;
+ 
+ 	hci_req_init(&req, hdev);
+ 
+ 	memset(&hci_cp, 0, sizeof(hci_cp));
+ 	hci_req_add(&req, HCI_OP_READ_CLOCK, sizeof(hci_cp), &hci_cp);
+ 
+ 	if (conn) {
+ 		hci_conn_hold(conn);
+ 		cmd->user_data = hci_conn_get(conn);
+ 
+ 		hci_cp.handle = cpu_to_le16(conn->handle);
+ 		hci_cp.which = 0x01; /* Piconet clock */
+ 		hci_req_add(&req, HCI_OP_READ_CLOCK, sizeof(hci_cp), &hci_cp);
+ 	}
+ 
+ 	err = hci_req_run(&req, get_clock_info_complete);
+ 	if (err < 0)
+ 		mgmt_pending_remove(cmd);
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ 	return err;
+ }
+ 
+ static bool is_connected(struct hci_dev *hdev, bdaddr_t *addr, u8 type)
+ {
+ 	struct hci_conn *conn;
+ 
+ 	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, addr);
+ 	if (!conn)
+ 		return false;
+ 
+ 	if (conn->dst_type != type)
+ 		return false;
+ 
+ 	if (conn->state != BT_CONNECTED)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ static int hci_conn_params_set(struct hci_dev *hdev, bdaddr_t *addr,
+ 			       u8 addr_type, u8 auto_connect)
+ {
+ 	struct hci_conn_params *params;
+ 
+ 	params = hci_conn_params_add(hdev, addr, addr_type);
+ 	if (!params)
+ 		return -EIO;
+ 
+ 	if (params->auto_connect == auto_connect)
+ 		return 0;
+ 
+ 	list_del_init(&params->action);
+ 
+ 	switch (auto_connect) {
+ 	case HCI_AUTO_CONN_DISABLED:
+ 	case HCI_AUTO_CONN_LINK_LOSS:
+ 		/* If auto connect is being disabled when we're trying to
+ 		 * connect to device, keep connecting.
+ 		 */
+ 		if (params->explicit_connect)
+ 			list_add(&params->action, &hdev->pend_le_conns);
+ 		break;
+ 	case HCI_AUTO_CONN_REPORT:
+ 		if (params->explicit_connect)
+ 			list_add(&params->action, &hdev->pend_le_conns);
+ 		else
+ 			list_add(&params->action, &hdev->pend_le_reports);
+ 		break;
+ 	case HCI_AUTO_CONN_DIRECT:
+ 	case HCI_AUTO_CONN_ALWAYS:
+ 		if (!is_connected(hdev, addr, addr_type))
+ 			list_add(&params->action, &hdev->pend_le_conns);
+ 		break;
+ 	}
+ 
+ 	params->auto_connect = auto_connect;
+ 
+ 	BT_DBG("addr %pMR (type %u) auto_connect %u", addr, addr_type,
+ 	       auto_connect);
+ 
+ 	return 0;
+ }
+ 
+ static void device_added(struct sock *sk, struct hci_dev *hdev,
+ 			 bdaddr_t *bdaddr, u8 type, u8 action)
+ {
+ 	struct mgmt_ev_device_added ev;
+ 
+ 	bacpy(&ev.addr.bdaddr, bdaddr);
+ 	ev.addr.type = type;
+ 	ev.action = action;
+ 
+ 	mgmt_event(MGMT_EV_DEVICE_ADDED, hdev, &ev, sizeof(ev), sk);
+ }
+ 
+ static int add_device(struct sock *sk, struct hci_dev *hdev,
+ 		      void *data, u16 len)
+ {
+ 	struct mgmt_cp_add_device *cp = data;
+ 	u8 auto_conn, addr_type;
+ 	int err;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	if (!bdaddr_type_is_valid(cp->addr.type) ||
+ 	    !bacmp(&cp->addr.bdaddr, BDADDR_ANY))
+ 		return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,
+ 					 MGMT_STATUS_INVALID_PARAMS,
+ 					 &cp->addr, sizeof(cp->addr));
+ 
+ 	if (cp->action != 0x00 && cp->action != 0x01 && cp->action != 0x02)
+ 		return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,
+ 					 MGMT_STATUS_INVALID_PARAMS,
+ 					 &cp->addr, sizeof(cp->addr));
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	if (cp->addr.type == BDADDR_BREDR) {
+ 		/* Only incoming connections action is supported for now */
+ 		if (cp->action != 0x01) {
+ 			err = mgmt_cmd_complete(sk, hdev->id,
+ 						MGMT_OP_ADD_DEVICE,
+ 						MGMT_STATUS_INVALID_PARAMS,
+ 						&cp->addr, sizeof(cp->addr));
+ 			goto unlock;
+ 		}
+ 
+ 		err = hci_bdaddr_list_add(&hdev->whitelist, &cp->addr.bdaddr,
+ 					  cp->addr.type);
+ 		if (err)
+ 			goto unlock;
+ 
+ 		hci_req_update_scan(hdev);
+ 
+ 		goto added;
+ 	}
+ 
+ 	addr_type = le_addr_type(cp->addr.type);
+ 
+ 	if (cp->action == 0x02)
+ 		auto_conn = HCI_AUTO_CONN_ALWAYS;
+ 	else if (cp->action == 0x01)
+ 		auto_conn = HCI_AUTO_CONN_DIRECT;
+ 	else
+ 		auto_conn = HCI_AUTO_CONN_REPORT;
+ 
+ 	/* Kernel internally uses conn_params with resolvable private
+ 	 * address, but Add Device allows only identity addresses.
+ 	 * Make sure it is enforced before calling
+ 	 * hci_conn_params_lookup.
+ 	 */
+ 	if (!hci_is_identity_address(&cp->addr.bdaddr, addr_type)) {
+ 		err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,
+ 					MGMT_STATUS_INVALID_PARAMS,
+ 					&cp->addr, sizeof(cp->addr));
+ 		goto unlock;
+ 	}
+ 
+ 	/* If the connection parameters don't exist for this device,
+ 	 * they will be created and configured with defaults.
+ 	 */
+ 	if (hci_conn_params_set(hdev, &cp->addr.bdaddr, addr_type,
+ 				auto_conn) < 0) {
+ 		err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,
+ 					MGMT_STATUS_FAILED, &cp->addr,
+ 					sizeof(cp->addr));
+ 		goto unlock;
+ 	}
+ 
+ 	hci_update_background_scan(hdev);
+ 
+ added:
+ 	device_added(sk, hdev, &cp->addr.bdaddr, cp->addr.type, cp->action);
+ 
+ 	err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,
+ 				MGMT_STATUS_SUCCESS, &cp->addr,
+ 				sizeof(cp->addr));
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ 	return err;
+ }
+ 
+ static void device_removed(struct sock *sk, struct hci_dev *hdev,
+ 			   bdaddr_t *bdaddr, u8 type)
+ {
+ 	struct mgmt_ev_device_removed ev;
+ 
+ 	bacpy(&ev.addr.bdaddr, bdaddr);
+ 	ev.addr.type = type;
+ 
+ 	mgmt_event(MGMT_EV_DEVICE_REMOVED, hdev, &ev, sizeof(ev), sk);
+ }
+ 
+ static int remove_device(struct sock *sk, struct hci_dev *hdev,
+ 			 void *data, u16 len)
+ {
+ 	struct mgmt_cp_remove_device *cp = data;
+ 	int err;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	if (bacmp(&cp->addr.bdaddr, BDADDR_ANY)) {
+ 		struct hci_conn_params *params;
+ 		u8 addr_type;
+ 
+ 		if (!bdaddr_type_is_valid(cp->addr.type)) {
+ 			err = mgmt_cmd_complete(sk, hdev->id,
+ 						MGMT_OP_REMOVE_DEVICE,
+ 						MGMT_STATUS_INVALID_PARAMS,
+ 						&cp->addr, sizeof(cp->addr));
+ 			goto unlock;
+ 		}
+ 
+ 		if (cp->addr.type == BDADDR_BREDR) {
+ 			err = hci_bdaddr_list_del(&hdev->whitelist,
+ 						  &cp->addr.bdaddr,
+ 						  cp->addr.type);
+ 			if (err) {
+ 				err = mgmt_cmd_complete(sk, hdev->id,
+ 							MGMT_OP_REMOVE_DEVICE,
+ 							MGMT_STATUS_INVALID_PARAMS,
+ 							&cp->addr,
+ 							sizeof(cp->addr));
+ 				goto unlock;
+ 			}
+ 
+ 			hci_req_update_scan(hdev);
+ 
+ 			device_removed(sk, hdev, &cp->addr.bdaddr,
+ 				       cp->addr.type);
+ 			goto complete;
+ 		}
+ 
+ 		addr_type = le_addr_type(cp->addr.type);
+ 
+ 		/* Kernel internally uses conn_params with resolvable private
+ 		 * address, but Remove Device allows only identity addresses.
+ 		 * Make sure it is enforced before calling
+ 		 * hci_conn_params_lookup.
+ 		 */
+ 		if (!hci_is_identity_address(&cp->addr.bdaddr, addr_type)) {
+ 			err = mgmt_cmd_complete(sk, hdev->id,
+ 						MGMT_OP_REMOVE_DEVICE,
+ 						MGMT_STATUS_INVALID_PARAMS,
+ 						&cp->addr, sizeof(cp->addr));
+ 			goto unlock;
+ 		}
+ 
+ 		params = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,
+ 						addr_type);
+ 		if (!params) {
+ 			err = mgmt_cmd_complete(sk, hdev->id,
+ 						MGMT_OP_REMOVE_DEVICE,
+ 						MGMT_STATUS_INVALID_PARAMS,
+ 						&cp->addr, sizeof(cp->addr));
+ 			goto unlock;
+ 		}
+ 
+ 		if (params->auto_connect == HCI_AUTO_CONN_DISABLED ||
+ 		    params->auto_connect == HCI_AUTO_CONN_EXPLICIT) {
+ 			err = mgmt_cmd_complete(sk, hdev->id,
+ 						MGMT_OP_REMOVE_DEVICE,
+ 						MGMT_STATUS_INVALID_PARAMS,
+ 						&cp->addr, sizeof(cp->addr));
+ 			goto unlock;
+ 		}
+ 
+ 		list_del(&params->action);
+ 		list_del(&params->list);
+ 		kfree(params);
+ 		hci_update_background_scan(hdev);
+ 
+ 		device_removed(sk, hdev, &cp->addr.bdaddr, cp->addr.type);
+ 	} else {
+ 		struct hci_conn_params *p, *tmp;
+ 		struct bdaddr_list *b, *btmp;
+ 
+ 		if (cp->addr.type) {
+ 			err = mgmt_cmd_complete(sk, hdev->id,
+ 						MGMT_OP_REMOVE_DEVICE,
+ 						MGMT_STATUS_INVALID_PARAMS,
+ 						&cp->addr, sizeof(cp->addr));
+ 			goto unlock;
+ 		}
+ 
+ 		list_for_each_entry_safe(b, btmp, &hdev->whitelist, list) {
+ 			device_removed(sk, hdev, &b->bdaddr, b->bdaddr_type);
+ 			list_del(&b->list);
+ 			kfree(b);
+ 		}
+ 
+ 		hci_req_update_scan(hdev);
+ 
+ 		list_for_each_entry_safe(p, tmp, &hdev->le_conn_params, list) {
+ 			if (p->auto_connect == HCI_AUTO_CONN_DISABLED)
+ 				continue;
+ 			device_removed(sk, hdev, &p->addr, p->addr_type);
+ 			if (p->explicit_connect) {
+ 				p->auto_connect = HCI_AUTO_CONN_EXPLICIT;
+ 				continue;
+ 			}
+ 			list_del(&p->action);
+ 			list_del(&p->list);
+ 			kfree(p);
+ 		}
+ 
+ 		BT_DBG("All LE connection parameters were removed");
+ 
+ 		hci_update_background_scan(hdev);
+ 	}
+ 
+ complete:
+ 	err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_DEVICE,
+ 				MGMT_STATUS_SUCCESS, &cp->addr,
+ 				sizeof(cp->addr));
+ unlock:
+ 	hci_dev_unlock(hdev);
+ 	return err;
+ }
+ 
+ static int load_conn_param(struct sock *sk, struct hci_dev *hdev, void *data,
+ 			   u16 len)
+ {
+ 	struct mgmt_cp_load_conn_param *cp = data;
+ 	const u16 max_param_count = ((U16_MAX - sizeof(*cp)) /
+ 				     sizeof(struct mgmt_conn_param));
+ 	u16 param_count, expected_len;
+ 	int i;
+ 
+ 	if (!lmp_le_capable(hdev))
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM,
+ 				       MGMT_STATUS_NOT_SUPPORTED);
+ 
+ 	param_count = __le16_to_cpu(cp->param_count);
+ 	if (param_count > max_param_count) {
+ 		BT_ERR("load_conn_param: too big param_count value %u",
+ 		       param_count);
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 	}
+ 
+ 	expected_len = sizeof(*cp) + param_count *
+ 					sizeof(struct mgmt_conn_param);
+ 	if (expected_len != len) {
+ 		BT_ERR("load_conn_param: expected %u bytes, got %u bytes",
+ 		       expected_len, len);
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 	}
+ 
+ 	BT_DBG("%s param_count %u", hdev->name, param_count);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	hci_conn_params_clear_disabled(hdev);
+ 
+ 	for (i = 0; i < param_count; i++) {
+ 		struct mgmt_conn_param *param = &cp->params[i];
+ 		struct hci_conn_params *hci_param;
+ 		u16 min, max, latency, timeout;
+ 		u8 addr_type;
+ 
+ 		BT_DBG("Adding %pMR (type %u)", &param->addr.bdaddr,
+ 		       param->addr.type);
+ 
+ 		if (param->addr.type == BDADDR_LE_PUBLIC) {
+ 			addr_type = ADDR_LE_DEV_PUBLIC;
+ 		} else if (param->addr.type == BDADDR_LE_RANDOM) {
+ 			addr_type = ADDR_LE_DEV_RANDOM;
+ 		} else {
+ 			BT_ERR("Ignoring invalid connection parameters");
+ 			continue;
+ 		}
+ 
+ 		min = le16_to_cpu(param->min_interval);
+ 		max = le16_to_cpu(param->max_interval);
+ 		latency = le16_to_cpu(param->latency);
+ 		timeout = le16_to_cpu(param->timeout);
+ 
+ 		BT_DBG("min 0x%04x max 0x%04x latency 0x%04x timeout 0x%04x",
+ 		       min, max, latency, timeout);
+ 
+ 		if (hci_check_conn_params(min, max, latency, timeout) < 0) {
+ 			BT_ERR("Ignoring invalid connection parameters");
+ 			continue;
+ 		}
+ 
+ 		hci_param = hci_conn_params_add(hdev, &param->addr.bdaddr,
+ 						addr_type);
+ 		if (!hci_param) {
+ 			BT_ERR("Failed to add connection parameters");
+ 			continue;
+ 		}
+ 
+ 		hci_param->conn_min_interval = min;
+ 		hci_param->conn_max_interval = max;
+ 		hci_param->conn_latency = latency;
+ 		hci_param->supervision_timeout = timeout;
+ 	}
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM, 0,
+ 				 NULL, 0);
+ }
+ 
+ static int set_external_config(struct sock *sk, struct hci_dev *hdev,
+ 			       void *data, u16 len)
+ {
+ 	struct mgmt_cp_set_external_config *cp = data;
+ 	bool changed;
+ 	int err;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	if (hdev_is_powered(hdev))
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_EXTERNAL_CONFIG,
+ 				       MGMT_STATUS_REJECTED);
+ 
+ 	if (cp->config != 0x00 && cp->config != 0x01)
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_EXTERNAL_CONFIG,
+ 				         MGMT_STATUS_INVALID_PARAMS);
+ 
+ 	if (!test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks))
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_EXTERNAL_CONFIG,
+ 				       MGMT_STATUS_NOT_SUPPORTED);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	if (cp->config)
+ 		changed = !hci_dev_test_and_set_flag(hdev, HCI_EXT_CONFIGURED);
+ 	else
+ 		changed = hci_dev_test_and_clear_flag(hdev, HCI_EXT_CONFIGURED);
+ 
+ 	err = send_options_rsp(sk, MGMT_OP_SET_EXTERNAL_CONFIG, hdev);
+ 	if (err < 0)
+ 		goto unlock;
+ 
+ 	if (!changed)
+ 		goto unlock;
+ 
+ 	err = new_options(hdev, sk);
+ 
+ 	if (hci_dev_test_flag(hdev, HCI_UNCONFIGURED) == is_configured(hdev)) {
+ 		mgmt_index_removed(hdev);
+ 
+ 		if (hci_dev_test_and_change_flag(hdev, HCI_UNCONFIGURED)) {
+ 			hci_dev_set_flag(hdev, HCI_CONFIG);
+ 			hci_dev_set_flag(hdev, HCI_AUTO_OFF);
+ 
+ 			queue_work(hdev->req_workqueue, &hdev->power_on);
+ 		} else {
+ 			set_bit(HCI_RAW, &hdev->flags);
+ 			mgmt_index_added(hdev);
+ 		}
+ 	}
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ 	return err;
+ }
+ 
+ static int set_public_address(struct sock *sk, struct hci_dev *hdev,
+ 			      void *data, u16 len)
+ {
+ 	struct mgmt_cp_set_public_address *cp = data;
+ 	bool changed;
+ 	int err;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	if (hdev_is_powered(hdev))
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PUBLIC_ADDRESS,
+ 				       MGMT_STATUS_REJECTED);
+ 
+ 	if (!bacmp(&cp->bdaddr, BDADDR_ANY))
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PUBLIC_ADDRESS,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 	if (!hdev->set_bdaddr)
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PUBLIC_ADDRESS,
+ 				       MGMT_STATUS_NOT_SUPPORTED);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	changed = !!bacmp(&hdev->public_addr, &cp->bdaddr);
+ 	bacpy(&hdev->public_addr, &cp->bdaddr);
+ 
+ 	err = send_options_rsp(sk, MGMT_OP_SET_PUBLIC_ADDRESS, hdev);
+ 	if (err < 0)
+ 		goto unlock;
+ 
+ 	if (!changed)
+ 		goto unlock;
+ 
+ 	if (hci_dev_test_flag(hdev, HCI_UNCONFIGURED))
+ 		err = new_options(hdev, sk);
+ 
+ 	if (is_configured(hdev)) {
+ 		mgmt_index_removed(hdev);
+ 
+ 		hci_dev_clear_flag(hdev, HCI_UNCONFIGURED);
+ 
+ 		hci_dev_set_flag(hdev, HCI_CONFIG);
+ 		hci_dev_set_flag(hdev, HCI_AUTO_OFF);
+ 
+ 		queue_work(hdev->req_workqueue, &hdev->power_on);
+ 	}
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ 	return err;
+ }
+ 
+ static inline u16 eir_append_data(u8 *eir, u16 eir_len, u8 type, u8 *data,
+ 				  u8 data_len)
+ {
+ 	eir[eir_len++] = sizeof(type) + data_len;
+ 	eir[eir_len++] = type;
+ 	memcpy(&eir[eir_len], data, data_len);
+ 	eir_len += data_len;
+ 
+ 	return eir_len;
+ }
+ 
+ static void read_local_oob_ext_data_complete(struct hci_dev *hdev, u8 status,
+ 					     u16 opcode, struct sk_buff *skb)
+ {
+ 	const struct mgmt_cp_read_local_oob_ext_data *mgmt_cp;
+ 	struct mgmt_rp_read_local_oob_ext_data *mgmt_rp;
+ 	u8 *h192, *r192, *h256, *r256;
+ 	struct mgmt_pending_cmd *cmd;
+ 	u16 eir_len;
+ 	int err;
+ 
+ 	BT_DBG("%s status %u", hdev->name, status);
+ 
+ 	cmd = pending_find(MGMT_OP_READ_LOCAL_OOB_EXT_DATA, hdev);
+ 	if (!cmd)
+ 		return;
+ 
+ 	mgmt_cp = cmd->param;
+ 
+ 	if (status) {
+ 		status = mgmt_status(status);
+ 		eir_len = 0;
+ 
+ 		h192 = NULL;
+ 		r192 = NULL;
+ 		h256 = NULL;
+ 		r256 = NULL;
+ 	} else if (opcode == HCI_OP_READ_LOCAL_OOB_DATA) {
+ 		struct hci_rp_read_local_oob_data *rp;
+ 
+ 		if (skb->len != sizeof(*rp)) {
+ 			status = MGMT_STATUS_FAILED;
+ 			eir_len = 0;
+ 		} else {
+ 			status = MGMT_STATUS_SUCCESS;
+ 			rp = (void *)skb->data;
+ 
+ 			eir_len = 5 + 18 + 18;
+ 			h192 = rp->hash;
+ 			r192 = rp->rand;
+ 			h256 = NULL;
+ 			r256 = NULL;
+ 		}
+ 	} else {
+ 		struct hci_rp_read_local_oob_ext_data *rp;
+ 
+ 		if (skb->len != sizeof(*rp)) {
+ 			status = MGMT_STATUS_FAILED;
+ 			eir_len = 0;
+ 		} else {
+ 			status = MGMT_STATUS_SUCCESS;
+ 			rp = (void *)skb->data;
+ 
+ 			if (hci_dev_test_flag(hdev, HCI_SC_ONLY)) {
+ 				eir_len = 5 + 18 + 18;
+ 				h192 = NULL;
+ 				r192 = NULL;
+ 			} else {
+ 				eir_len = 5 + 18 + 18 + 18 + 18;
+ 				h192 = rp->hash192;
+ 				r192 = rp->rand192;
+ 			}
+ 
+ 			h256 = rp->hash256;
+ 			r256 = rp->rand256;
+ 		}
+ 	}
+ 
+ 	mgmt_rp = kmalloc(sizeof(*mgmt_rp) + eir_len, GFP_KERNEL);
+ 	if (!mgmt_rp)
+ 		goto done;
+ 
+ 	if (status)
+ 		goto send_rsp;
+ 
+ 	eir_len = eir_append_data(mgmt_rp->eir, 0, EIR_CLASS_OF_DEV,
+ 				  hdev->dev_class, 3);
+ 
+ 	if (h192 && r192) {
+ 		eir_len = eir_append_data(mgmt_rp->eir, eir_len,
+ 					  EIR_SSP_HASH_C192, h192, 16);
+ 		eir_len = eir_append_data(mgmt_rp->eir, eir_len,
+ 					  EIR_SSP_RAND_R192, r192, 16);
+ 	}
+ 
+ 	if (h256 && r256) {
+ 		eir_len = eir_append_data(mgmt_rp->eir, eir_len,
+ 					  EIR_SSP_HASH_C256, h256, 16);
+ 		eir_len = eir_append_data(mgmt_rp->eir, eir_len,
+ 					  EIR_SSP_RAND_R256, r256, 16);
+ 	}
+ 
+ send_rsp:
+ 	mgmt_rp->type = mgmt_cp->type;
+ 	mgmt_rp->eir_len = cpu_to_le16(eir_len);
+ 
+ 	err = mgmt_cmd_complete(cmd->sk, hdev->id,
+ 				MGMT_OP_READ_LOCAL_OOB_EXT_DATA, status,
+ 				mgmt_rp, sizeof(*mgmt_rp) + eir_len);
+ 	if (err < 0 || status)
+ 		goto done;
+ 
+ 	hci_sock_set_flag(cmd->sk, HCI_MGMT_OOB_DATA_EVENTS);
+ 
+ 	err = mgmt_limited_event(MGMT_EV_LOCAL_OOB_DATA_UPDATED, hdev,
+ 				 mgmt_rp, sizeof(*mgmt_rp) + eir_len,
+ 				 HCI_MGMT_OOB_DATA_EVENTS, cmd->sk);
+ done:
+ 	kfree(mgmt_rp);
+ 	mgmt_pending_remove(cmd);
+ }
+ 
+ static int read_local_ssp_oob_req(struct hci_dev *hdev, struct sock *sk,
+ 				  struct mgmt_cp_read_local_oob_ext_data *cp)
+ {
+ 	struct mgmt_pending_cmd *cmd;
+ 	struct hci_request req;
+ 	int err;
+ 
+ 	cmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_EXT_DATA, hdev,
+ 			       cp, sizeof(*cp));
+ 	if (!cmd)
+ 		return -ENOMEM;
+ 
+ 	hci_req_init(&req, hdev);
+ 
+ 	if (bredr_sc_enabled(hdev))
+ 		hci_req_add(&req, HCI_OP_READ_LOCAL_OOB_EXT_DATA, 0, NULL);
+ 	else
+ 		hci_req_add(&req, HCI_OP_READ_LOCAL_OOB_DATA, 0, NULL);
+ 
+ 	err = hci_req_run_skb(&req, read_local_oob_ext_data_complete);
+ 	if (err < 0) {
+ 		mgmt_pending_remove(cmd);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int read_local_oob_ext_data(struct sock *sk, struct hci_dev *hdev,
+ 				   void *data, u16 data_len)
+ {
+ 	struct mgmt_cp_read_local_oob_ext_data *cp = data;
+ 	struct mgmt_rp_read_local_oob_ext_data *rp;
+ 	size_t rp_len;
+ 	u16 eir_len;
+ 	u8 status, flags, role, addr[7], hash[16], rand[16];
+ 	int err;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	if (hdev_is_powered(hdev)) {
+ 		switch (cp->type) {
+ 		case BIT(BDADDR_BREDR):
+ 			status = mgmt_bredr_support(hdev);
+ 			if (status)
+ 				eir_len = 0;
+ 			else
+ 				eir_len = 5;
+ 			break;
+ 		case (BIT(BDADDR_LE_PUBLIC) | BIT(BDADDR_LE_RANDOM)):
+ 			status = mgmt_le_support(hdev);
+ 			if (status)
+ 				eir_len = 0;
+ 			else
+ 				eir_len = 9 + 3 + 18 + 18 + 3;
+ 			break;
+ 		default:
+ 			status = MGMT_STATUS_INVALID_PARAMS;
+ 			eir_len = 0;
+ 			break;
+ 		}
+ 	} else {
+ 		status = MGMT_STATUS_NOT_POWERED;
+ 		eir_len = 0;
+ 	}
+ 
+ 	rp_len = sizeof(*rp) + eir_len;
+ 	rp = kmalloc(rp_len, GFP_ATOMIC);
+ 	if (!rp)
+ 		return -ENOMEM;
+ 
+ 	if (status)
+ 		goto complete;
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	eir_len = 0;
+ 	switch (cp->type) {
+ 	case BIT(BDADDR_BREDR):
+ 		if (hci_dev_test_flag(hdev, HCI_SSP_ENABLED)) {
+ 			err = read_local_ssp_oob_req(hdev, sk, cp);
+ 			hci_dev_unlock(hdev);
+ 			if (!err)
+ 				goto done;
+ 
+ 			status = MGMT_STATUS_FAILED;
+ 			goto complete;
+ 		} else {
+ 			eir_len = eir_append_data(rp->eir, eir_len,
+ 						  EIR_CLASS_OF_DEV,
+ 						  hdev->dev_class, 3);
+ 		}
+ 		break;
+ 	case (BIT(BDADDR_LE_PUBLIC) | BIT(BDADDR_LE_RANDOM)):
+ 		if (hci_dev_test_flag(hdev, HCI_SC_ENABLED) &&
+ 		    smp_generate_oob(hdev, hash, rand) < 0) {
+ 			hci_dev_unlock(hdev);
+ 			status = MGMT_STATUS_FAILED;
+ 			goto complete;
+ 		}
+ 
+ 		/* This should return the active RPA, but since the RPA
+ 		 * is only programmed on demand, it is really hard to fill
+ 		 * this in at the moment. For now disallow retrieving
+ 		 * local out-of-band data when privacy is in use.
+ 		 *
+ 		 * Returning the identity address will not help here since
+ 		 * pairing happens before the identity resolving key is
+ 		 * known and thus the connection establishment happens
+ 		 * based on the RPA and not the identity address.
+ 		 */
+ 		if (hci_dev_test_flag(hdev, HCI_PRIVACY)) {
+ 			hci_dev_unlock(hdev);
+ 			status = MGMT_STATUS_REJECTED;
+ 			goto complete;
+ 		}
+ 
+ 		if (hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR) ||
+ 		   !bacmp(&hdev->bdaddr, BDADDR_ANY) ||
+ 		   (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) &&
+ 		    bacmp(&hdev->static_addr, BDADDR_ANY))) {
+ 			memcpy(addr, &hdev->static_addr, 6);
+ 			addr[6] = 0x01;
+ 		} else {
+ 			memcpy(addr, &hdev->bdaddr, 6);
+ 			addr[6] = 0x00;
+ 		}
+ 
+ 		eir_len = eir_append_data(rp->eir, eir_len, EIR_LE_BDADDR,
+ 					  addr, sizeof(addr));
+ 
+ 		if (hci_dev_test_flag(hdev, HCI_ADVERTISING))
+ 			role = 0x02;
+ 		else
+ 			role = 0x01;
+ 
+ 		eir_len = eir_append_data(rp->eir, eir_len, EIR_LE_ROLE,
+ 					  &role, sizeof(role));
+ 
+ 		if (hci_dev_test_flag(hdev, HCI_SC_ENABLED)) {
+ 			eir_len = eir_append_data(rp->eir, eir_len,
+ 						  EIR_LE_SC_CONFIRM,
+ 						  hash, sizeof(hash));
+ 
+ 			eir_len = eir_append_data(rp->eir, eir_len,
+ 						  EIR_LE_SC_RANDOM,
+ 						  rand, sizeof(rand));
+ 		}
+ 
+ 		flags = mgmt_get_adv_discov_flags(hdev);
+ 
+ 		if (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))
+ 			flags |= LE_AD_NO_BREDR;
+ 
+ 		eir_len = eir_append_data(rp->eir, eir_len, EIR_FLAGS,
+ 					  &flags, sizeof(flags));
+ 		break;
+ 	}
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	hci_sock_set_flag(sk, HCI_MGMT_OOB_DATA_EVENTS);
+ 
+ 	status = MGMT_STATUS_SUCCESS;
+ 
+ complete:
+ 	rp->type = cp->type;
+ 	rp->eir_len = cpu_to_le16(eir_len);
+ 
+ 	err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_EXT_DATA,
+ 				status, rp, sizeof(*rp) + eir_len);
+ 	if (err < 0 || status)
+ 		goto done;
+ 
+ 	err = mgmt_limited_event(MGMT_EV_LOCAL_OOB_DATA_UPDATED, hdev,
+ 				 rp, sizeof(*rp) + eir_len,
+ 				 HCI_MGMT_OOB_DATA_EVENTS, sk);
+ 
+ done:
+ 	kfree(rp);
+ 
+ 	return err;
+ }
+ 
+ static u32 get_supported_adv_flags(struct hci_dev *hdev)
+ {
+ 	u32 flags = 0;
+ 
+ 	flags |= MGMT_ADV_FLAG_CONNECTABLE;
+ 	flags |= MGMT_ADV_FLAG_DISCOV;
+ 	flags |= MGMT_ADV_FLAG_LIMITED_DISCOV;
+ 	flags |= MGMT_ADV_FLAG_MANAGED_FLAGS;
+ 
+ 	if (hdev->adv_tx_power != HCI_TX_POWER_INVALID)
+ 		flags |= MGMT_ADV_FLAG_TX_POWER;
+ 
+ 	return flags;
+ }
+ 
+ static int read_adv_features(struct sock *sk, struct hci_dev *hdev,
+ 			     void *data, u16 data_len)
+ {
+ 	struct mgmt_rp_read_adv_features *rp;
+ 	size_t rp_len;
+ 	int err;
+ 	struct adv_info *adv_instance;
+ 	u32 supported_flags;
+ 	u8 *instance;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	if (!lmp_le_capable(hdev))
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_ADV_FEATURES,
+ 				       MGMT_STATUS_REJECTED);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	rp_len = sizeof(*rp) + hdev->adv_instance_cnt;
+ 	rp = kmalloc(rp_len, GFP_ATOMIC);
+ 	if (!rp) {
+ 		hci_dev_unlock(hdev);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	supported_flags = get_supported_adv_flags(hdev);
+ 
+ 	rp->supported_flags = cpu_to_le32(supported_flags);
+ 	rp->max_adv_data_len = HCI_MAX_AD_LENGTH;
+ 	rp->max_scan_rsp_len = HCI_MAX_AD_LENGTH;
+ 	rp->max_instances = HCI_MAX_ADV_INSTANCES;
+ 	rp->num_instances = hdev->adv_instance_cnt;
+ 
+ 	instance = rp->instance;
+ 	list_for_each_entry(adv_instance, &hdev->adv_instances, list) {
+ 		*instance = adv_instance->instance;
+ 		instance++;
+ 	}
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_ADV_FEATURES,
+ 				MGMT_STATUS_SUCCESS, rp, rp_len);
+ 
+ 	kfree(rp);
+ 
+ 	return err;
+ }
+ 
+ static bool tlv_data_is_valid(struct hci_dev *hdev, u32 adv_flags, u8 *data,
+ 			      u8 len, bool is_adv_data)
+ {
+ 	u8 max_len = HCI_MAX_AD_LENGTH;
+ 	int i, cur_len;
+ 	bool flags_managed = false;
+ 	bool tx_power_managed = false;
+ 
+ 	if (is_adv_data) {
+ 		if (adv_flags & (MGMT_ADV_FLAG_DISCOV |
+ 				 MGMT_ADV_FLAG_LIMITED_DISCOV |
+ 				 MGMT_ADV_FLAG_MANAGED_FLAGS)) {
+ 			flags_managed = true;
+ 			max_len -= 3;
+ 		}
+ 
+ 		if (adv_flags & MGMT_ADV_FLAG_TX_POWER) {
+ 			tx_power_managed = true;
+ 			max_len -= 3;
+ 		}
+ 	}
+ 
+ 	if (len > max_len)
+ 		return false;
+ 
+ 	/* Make sure that the data is correctly formatted. */
+ 	for (i = 0, cur_len = 0; i < len; i += (cur_len + 1)) {
+ 		cur_len = data[i];
+ 
+ 		if (flags_managed && data[i + 1] == EIR_FLAGS)
+ 			return false;
+ 
+ 		if (tx_power_managed && data[i + 1] == EIR_TX_POWER)
+ 			return false;
+ 
+ 		/* If the current field length would exceed the total data
+ 		 * length, then it's invalid.
+ 		 */
+ 		if (i + cur_len >= len)
+ 			return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static void add_advertising_complete(struct hci_dev *hdev, u8 status,
+ 				     u16 opcode)
+ {
+ 	struct mgmt_pending_cmd *cmd;
+ 	struct mgmt_cp_add_advertising *cp;
+ 	struct mgmt_rp_add_advertising rp;
+ 	struct adv_info *adv_instance, *n;
+ 	u8 instance;
+ 
+ 	BT_DBG("status %d", status);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	cmd = pending_find(MGMT_OP_ADD_ADVERTISING, hdev);
+ 
+ 	list_for_each_entry_safe(adv_instance, n, &hdev->adv_instances, list) {
+ 		if (!adv_instance->pending)
+ 			continue;
+ 
+ 		if (!status) {
+ 			adv_instance->pending = false;
+ 			continue;
+ 		}
+ 
+ 		instance = adv_instance->instance;
+ 
+ 		if (hdev->cur_adv_instance == instance)
+ 			cancel_adv_timeout(hdev);
+ 
+ 		hci_remove_adv_instance(hdev, instance);
+ 		mgmt_advertising_removed(cmd ? cmd->sk : NULL, hdev, instance);
+ 	}
+ 
+ 	if (!cmd)
+ 		goto unlock;
+ 
+ 	cp = cmd->param;
+ 	rp.instance = cp->instance;
+ 
+ 	if (status)
+ 		mgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode,
+ 				mgmt_status(status));
+ 	else
+ 		mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,
+ 				  mgmt_status(status), &rp, sizeof(rp));
+ 
+ 	mgmt_pending_remove(cmd);
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ }
+ 
+ static int add_advertising(struct sock *sk, struct hci_dev *hdev,
+ 			   void *data, u16 data_len)
+ {
+ 	struct mgmt_cp_add_advertising *cp = data;
+ 	struct mgmt_rp_add_advertising rp;
+ 	u32 flags;
+ 	u32 supported_flags;
+ 	u8 status;
+ 	u16 timeout, duration;
+ 	unsigned int prev_instance_cnt = hdev->adv_instance_cnt;
+ 	u8 schedule_instance = 0;
+ 	struct adv_info *next_instance;
+ 	int err;
+ 	struct mgmt_pending_cmd *cmd;
+ 	struct hci_request req;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	status = mgmt_le_support(hdev);
+ 	if (status)
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
+ 				       status);
+ 
+ 	if (cp->instance < 1 || cp->instance > HCI_MAX_ADV_INSTANCES)
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 	if (data_len != sizeof(*cp) + cp->adv_data_len + cp->scan_rsp_len)
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 	flags = __le32_to_cpu(cp->flags);
+ 	timeout = __le16_to_cpu(cp->timeout);
+ 	duration = __le16_to_cpu(cp->duration);
+ 
+ 	/* The current implementation only supports a subset of the specified
+ 	 * flags.
+ 	 */
+ 	supported_flags = get_supported_adv_flags(hdev);
+ 	if (flags & ~supported_flags)
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	if (timeout && !hdev_is_powered(hdev)) {
+ 		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
+ 				      MGMT_STATUS_REJECTED);
+ 		goto unlock;
+ 	}
+ 
+ 	if (pending_find(MGMT_OP_ADD_ADVERTISING, hdev) ||
+ 	    pending_find(MGMT_OP_REMOVE_ADVERTISING, hdev) ||
+ 	    pending_find(MGMT_OP_SET_LE, hdev)) {
+ 		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
+ 				      MGMT_STATUS_BUSY);
+ 		goto unlock;
+ 	}
+ 
+ 	if (!tlv_data_is_valid(hdev, flags, cp->data, cp->adv_data_len, true) ||
+ 	    !tlv_data_is_valid(hdev, flags, cp->data + cp->adv_data_len,
+ 			       cp->scan_rsp_len, false)) {
+ 		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
+ 				      MGMT_STATUS_INVALID_PARAMS);
+ 		goto unlock;
+ 	}
+ 
+ 	err = hci_add_adv_instance(hdev, cp->instance, flags,
+ 				   cp->adv_data_len, cp->data,
+ 				   cp->scan_rsp_len,
+ 				   cp->data + cp->adv_data_len,
+ 				   timeout, duration);
+ 	if (err < 0) {
+ 		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
+ 				      MGMT_STATUS_FAILED);
+ 		goto unlock;
+ 	}
+ 
+ 	/* Only trigger an advertising added event if a new instance was
+ 	 * actually added.
+ 	 */
+ 	if (hdev->adv_instance_cnt > prev_instance_cnt)
+ 		mgmt_advertising_added(sk, hdev, cp->instance);
+ 
+ 	if (hdev->cur_adv_instance == cp->instance) {
+ 		/* If the currently advertised instance is being changed then
+ 		 * cancel the current advertising and schedule the next
+ 		 * instance. If there is only one instance then the overridden
+ 		 * advertising data will be visible right away.
+ 		 */
+ 		cancel_adv_timeout(hdev);
+ 
+ 		next_instance = hci_get_next_instance(hdev, cp->instance);
+ 		if (next_instance)
+ 			schedule_instance = next_instance->instance;
+ 	} else if (!hdev->adv_instance_timeout) {
+ 		/* Immediately advertise the new instance if no other
+ 		 * instance is currently being advertised.
+ 		 */
+ 		schedule_instance = cp->instance;
+ 	}
+ 
+ 	/* If the HCI_ADVERTISING flag is set or the device isn't powered or
+ 	 * there is no instance to be advertised then we have no HCI
+ 	 * communication to make. Simply return.
+ 	 */
+ 	if (!hdev_is_powered(hdev) ||
+ 	    hci_dev_test_flag(hdev, HCI_ADVERTISING) ||
+ 	    !schedule_instance) {
+ 		rp.instance = cp->instance;
+ 		err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
+ 					MGMT_STATUS_SUCCESS, &rp, sizeof(rp));
+ 		goto unlock;
+ 	}
+ 
+ 	/* We're good to go, update advertising data, parameters, and start
+ 	 * advertising.
+ 	 */
+ 	cmd = mgmt_pending_add(sk, MGMT_OP_ADD_ADVERTISING, hdev, data,
+ 			       data_len);
+ 	if (!cmd) {
+ 		err = -ENOMEM;
+ 		goto unlock;
+ 	}
+ 
+ 	hci_req_init(&req, hdev);
+ 
+ 	err = __hci_req_schedule_adv_instance(&req, schedule_instance, true);
+ 
+ 	if (!err)
+ 		err = hci_req_run(&req, add_advertising_complete);
+ 
+ 	if (err < 0)
+ 		mgmt_pending_remove(cmd);
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ 
+ 	return err;
+ }
+ 
+ static void remove_advertising_complete(struct hci_dev *hdev, u8 status,
+ 					u16 opcode)
+ {
+ 	struct mgmt_pending_cmd *cmd;
+ 	struct mgmt_cp_remove_advertising *cp;
+ 	struct mgmt_rp_remove_advertising rp;
+ 
+ 	BT_DBG("status %d", status);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	/* A failure status here only means that we failed to disable
+ 	 * advertising. Otherwise, the advertising instance has been removed,
+ 	 * so report success.
+ 	 */
+ 	cmd = pending_find(MGMT_OP_REMOVE_ADVERTISING, hdev);
+ 	if (!cmd)
+ 		goto unlock;
+ 
+ 	cp = cmd->param;
+ 	rp.instance = cp->instance;
+ 
+ 	mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, MGMT_STATUS_SUCCESS,
+ 			  &rp, sizeof(rp));
+ 	mgmt_pending_remove(cmd);
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ }
+ 
+ static int remove_advertising(struct sock *sk, struct hci_dev *hdev,
+ 			      void *data, u16 data_len)
+ {
+ 	struct mgmt_cp_remove_advertising *cp = data;
+ 	struct mgmt_rp_remove_advertising rp;
+ 	struct mgmt_pending_cmd *cmd;
+ 	struct hci_request req;
+ 	int err;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	if (cp->instance && !hci_find_adv_instance(hdev, cp->instance)) {
+ 		err = mgmt_cmd_status(sk, hdev->id,
+ 				      MGMT_OP_REMOVE_ADVERTISING,
+ 				      MGMT_STATUS_INVALID_PARAMS);
+ 		goto unlock;
+ 	}
+ 
+ 	if (pending_find(MGMT_OP_ADD_ADVERTISING, hdev) ||
+ 	    pending_find(MGMT_OP_REMOVE_ADVERTISING, hdev) ||
+ 	    pending_find(MGMT_OP_SET_LE, hdev)) {
+ 		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_ADVERTISING,
+ 				      MGMT_STATUS_BUSY);
+ 		goto unlock;
+ 	}
+ 
+ 	if (list_empty(&hdev->adv_instances)) {
+ 		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_ADVERTISING,
+ 				      MGMT_STATUS_INVALID_PARAMS);
+ 		goto unlock;
+ 	}
+ 
+ 	hci_req_init(&req, hdev);
+ 
+ 	hci_req_clear_adv_instance(hdev, &req, cp->instance, true);
+ 
+ 	if (list_empty(&hdev->adv_instances))
+ 		__hci_req_disable_advertising(&req);
+ 
+ 	/* If no HCI commands have been collected so far or the HCI_ADVERTISING
+ 	 * flag is set or the device isn't powered then we have no HCI
+ 	 * communication to make. Simply return.
+ 	 */
+ 	if (skb_queue_empty(&req.cmd_q) ||
+ 	    !hdev_is_powered(hdev) ||
+ 	    hci_dev_test_flag(hdev, HCI_ADVERTISING)) {
+ 		rp.instance = cp->instance;
+ 		err = mgmt_cmd_complete(sk, hdev->id,
+ 					MGMT_OP_REMOVE_ADVERTISING,
+ 					MGMT_STATUS_SUCCESS, &rp, sizeof(rp));
+ 		goto unlock;
+ 	}
+ 
+ 	cmd = mgmt_pending_add(sk, MGMT_OP_REMOVE_ADVERTISING, hdev, data,
+ 			       data_len);
+ 	if (!cmd) {
+ 		err = -ENOMEM;
+ 		goto unlock;
+ 	}
+ 
+ 	err = hci_req_run(&req, remove_advertising_complete);
+ 	if (err < 0)
+ 		mgmt_pending_remove(cmd);
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ 
+ 	return err;
+ }
+ 
+ static u8 tlv_data_max_len(u32 adv_flags, bool is_adv_data)
+ {
+ 	u8 max_len = HCI_MAX_AD_LENGTH;
+ 
+ 	if (is_adv_data) {
+ 		if (adv_flags & (MGMT_ADV_FLAG_DISCOV |
+ 				 MGMT_ADV_FLAG_LIMITED_DISCOV |
+ 				 MGMT_ADV_FLAG_MANAGED_FLAGS))
+ 			max_len -= 3;
+ 
+ 		if (adv_flags & MGMT_ADV_FLAG_TX_POWER)
+ 			max_len -= 3;
+ 	}
+ 
+ 	return max_len;
+ }
+ 
+ static int get_adv_size_info(struct sock *sk, struct hci_dev *hdev,
+ 			     void *data, u16 data_len)
+ {
+ 	struct mgmt_cp_get_adv_size_info *cp = data;
+ 	struct mgmt_rp_get_adv_size_info rp;
+ 	u32 flags, supported_flags;
+ 	int err;
+ 
+ 	BT_DBG("%s", hdev->name);
+ 
+ 	if (!lmp_le_capable(hdev))
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,
+ 				       MGMT_STATUS_REJECTED);
+ 
+ 	if (cp->instance < 1 || cp->instance > HCI_MAX_ADV_INSTANCES)
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 	flags = __le32_to_cpu(cp->flags);
+ 
+ 	/* The current implementation only supports a subset of the specified
+ 	 * flags.
+ 	 */
+ 	supported_flags = get_supported_adv_flags(hdev);
+ 	if (flags & ~supported_flags)
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 	rp.instance = cp->instance;
+ 	rp.flags = cp->flags;
+ 	rp.max_adv_data_len = tlv_data_max_len(flags, true);
+ 	rp.max_scan_rsp_len = tlv_data_max_len(flags, false);
+ 
+ 	err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,
+ 				MGMT_STATUS_SUCCESS, &rp, sizeof(rp));
+ 
+ 	return err;
+ }
+ 
+ static const struct hci_mgmt_handler mgmt_handlers[] = {
++>>>>>>> 6a0e78072c2a (Bluetooth: Fix potential buffer overflow with Add Advertising)
  	{ NULL }, /* 0x0000 (no command) */
 -	{ read_version,            MGMT_READ_VERSION_SIZE,
 -						HCI_MGMT_NO_HDEV |
 -						HCI_MGMT_UNTRUSTED },
 -	{ read_commands,           MGMT_READ_COMMANDS_SIZE,
 -						HCI_MGMT_NO_HDEV |
 -						HCI_MGMT_UNTRUSTED },
 -	{ read_index_list,         MGMT_READ_INDEX_LIST_SIZE,
 -						HCI_MGMT_NO_HDEV |
 -						HCI_MGMT_UNTRUSTED },
 -	{ read_controller_info,    MGMT_READ_INFO_SIZE,
 -						HCI_MGMT_UNTRUSTED },
 -	{ set_powered,             MGMT_SETTING_SIZE },
 -	{ set_discoverable,        MGMT_SET_DISCOVERABLE_SIZE },
 -	{ set_connectable,         MGMT_SETTING_SIZE },
 -	{ set_fast_connectable,    MGMT_SETTING_SIZE },
 -	{ set_bondable,            MGMT_SETTING_SIZE },
 -	{ set_link_security,       MGMT_SETTING_SIZE },
 -	{ set_ssp,                 MGMT_SETTING_SIZE },
 -	{ set_hs,                  MGMT_SETTING_SIZE },
 -	{ set_le,                  MGMT_SETTING_SIZE },
 -	{ set_dev_class,           MGMT_SET_DEV_CLASS_SIZE },
 -	{ set_local_name,          MGMT_SET_LOCAL_NAME_SIZE },
 -	{ add_uuid,                MGMT_ADD_UUID_SIZE },
 -	{ remove_uuid,             MGMT_REMOVE_UUID_SIZE },
 -	{ load_link_keys,          MGMT_LOAD_LINK_KEYS_SIZE,
 -						HCI_MGMT_VAR_LEN },
 -	{ load_long_term_keys,     MGMT_LOAD_LONG_TERM_KEYS_SIZE,
 -						HCI_MGMT_VAR_LEN },
 -	{ disconnect,              MGMT_DISCONNECT_SIZE },
 -	{ get_connections,         MGMT_GET_CONNECTIONS_SIZE },
 -	{ pin_code_reply,          MGMT_PIN_CODE_REPLY_SIZE },
 -	{ pin_code_neg_reply,      MGMT_PIN_CODE_NEG_REPLY_SIZE },
 -	{ set_io_capability,       MGMT_SET_IO_CAPABILITY_SIZE },
 -	{ pair_device,             MGMT_PAIR_DEVICE_SIZE },
 -	{ cancel_pair_device,      MGMT_CANCEL_PAIR_DEVICE_SIZE },
 -	{ unpair_device,           MGMT_UNPAIR_DEVICE_SIZE },
 -	{ user_confirm_reply,      MGMT_USER_CONFIRM_REPLY_SIZE },
 -	{ user_confirm_neg_reply,  MGMT_USER_CONFIRM_NEG_REPLY_SIZE },
 -	{ user_passkey_reply,      MGMT_USER_PASSKEY_REPLY_SIZE },
 -	{ user_passkey_neg_reply,  MGMT_USER_PASSKEY_NEG_REPLY_SIZE },
 -	{ read_local_oob_data,     MGMT_READ_LOCAL_OOB_DATA_SIZE },
 -	{ add_remote_oob_data,     MGMT_ADD_REMOTE_OOB_DATA_SIZE,
 -						HCI_MGMT_VAR_LEN },
 -	{ remove_remote_oob_data,  MGMT_REMOVE_REMOTE_OOB_DATA_SIZE },
 -	{ start_discovery,         MGMT_START_DISCOVERY_SIZE },
 -	{ stop_discovery,          MGMT_STOP_DISCOVERY_SIZE },
 -	{ confirm_name,            MGMT_CONFIRM_NAME_SIZE },
 -	{ block_device,            MGMT_BLOCK_DEVICE_SIZE },
 -	{ unblock_device,          MGMT_UNBLOCK_DEVICE_SIZE },
 -	{ set_device_id,           MGMT_SET_DEVICE_ID_SIZE },
 -	{ set_advertising,         MGMT_SETTING_SIZE },
 -	{ set_bredr,               MGMT_SETTING_SIZE },
 -	{ set_static_address,      MGMT_SET_STATIC_ADDRESS_SIZE },
 -	{ set_scan_params,         MGMT_SET_SCAN_PARAMS_SIZE },
 -	{ set_secure_conn,         MGMT_SETTING_SIZE },
 -	{ set_debug_keys,          MGMT_SETTING_SIZE },
 -	{ set_privacy,             MGMT_SET_PRIVACY_SIZE },
 -	{ load_irks,               MGMT_LOAD_IRKS_SIZE,
 -						HCI_MGMT_VAR_LEN },
 -	{ get_conn_info,           MGMT_GET_CONN_INFO_SIZE },
 -	{ get_clock_info,          MGMT_GET_CLOCK_INFO_SIZE },
 -	{ add_device,              MGMT_ADD_DEVICE_SIZE },
 -	{ remove_device,           MGMT_REMOVE_DEVICE_SIZE },
 -	{ load_conn_param,         MGMT_LOAD_CONN_PARAM_SIZE,
 -						HCI_MGMT_VAR_LEN },
 -	{ read_unconf_index_list,  MGMT_READ_UNCONF_INDEX_LIST_SIZE,
 -						HCI_MGMT_NO_HDEV |
 -						HCI_MGMT_UNTRUSTED },
 -	{ read_config_info,        MGMT_READ_CONFIG_INFO_SIZE,
 -						HCI_MGMT_UNCONFIGURED |
 -						HCI_MGMT_UNTRUSTED },
 -	{ set_external_config,     MGMT_SET_EXTERNAL_CONFIG_SIZE,
 -						HCI_MGMT_UNCONFIGURED },
 -	{ set_public_address,      MGMT_SET_PUBLIC_ADDRESS_SIZE,
 -						HCI_MGMT_UNCONFIGURED },
 -	{ start_service_discovery, MGMT_START_SERVICE_DISCOVERY_SIZE,
 -						HCI_MGMT_VAR_LEN },
 -	{ read_local_oob_ext_data, MGMT_READ_LOCAL_OOB_EXT_DATA_SIZE },
 -	{ read_ext_index_list,     MGMT_READ_EXT_INDEX_LIST_SIZE,
 -						HCI_MGMT_NO_HDEV |
 -						HCI_MGMT_UNTRUSTED },
 -	{ read_adv_features,       MGMT_READ_ADV_FEATURES_SIZE },
 -	{ add_advertising,	   MGMT_ADD_ADVERTISING_SIZE,
 -						HCI_MGMT_VAR_LEN },
 -	{ remove_advertising,	   MGMT_REMOVE_ADVERTISING_SIZE },
 -	{ get_adv_size_info,       MGMT_GET_ADV_SIZE_INFO_SIZE },
 -	{ start_limited_discovery, MGMT_START_DISCOVERY_SIZE },
 +	{ read_version,           false, MGMT_READ_VERSION_SIZE },
 +	{ read_commands,          false, MGMT_READ_COMMANDS_SIZE },
 +	{ read_index_list,        false, MGMT_READ_INDEX_LIST_SIZE },
 +	{ read_controller_info,   false, MGMT_READ_INFO_SIZE },
 +	{ set_powered,            false, MGMT_SETTING_SIZE },
 +	{ set_discoverable,       false, MGMT_SET_DISCOVERABLE_SIZE },
 +	{ set_connectable,        false, MGMT_SETTING_SIZE },
 +	{ set_fast_connectable,   false, MGMT_SETTING_SIZE },
 +	{ set_pairable,           false, MGMT_SETTING_SIZE },
 +	{ set_link_security,      false, MGMT_SETTING_SIZE },
 +	{ set_ssp,                false, MGMT_SETTING_SIZE },
 +	{ set_hs,                 false, MGMT_SETTING_SIZE },
 +	{ set_le,                 false, MGMT_SETTING_SIZE },
 +	{ set_dev_class,          false, MGMT_SET_DEV_CLASS_SIZE },
 +	{ set_local_name,         false, MGMT_SET_LOCAL_NAME_SIZE },
 +	{ add_uuid,               false, MGMT_ADD_UUID_SIZE },
 +	{ remove_uuid,            false, MGMT_REMOVE_UUID_SIZE },
 +	{ load_link_keys,         true,  MGMT_LOAD_LINK_KEYS_SIZE },
 +	{ load_long_term_keys,    true,  MGMT_LOAD_LONG_TERM_KEYS_SIZE },
 +	{ disconnect,             false, MGMT_DISCONNECT_SIZE },
 +	{ get_connections,        false, MGMT_GET_CONNECTIONS_SIZE },
 +	{ pin_code_reply,         false, MGMT_PIN_CODE_REPLY_SIZE },
 +	{ pin_code_neg_reply,     false, MGMT_PIN_CODE_NEG_REPLY_SIZE },
 +	{ set_io_capability,      false, MGMT_SET_IO_CAPABILITY_SIZE },
 +	{ pair_device,            false, MGMT_PAIR_DEVICE_SIZE },
 +	{ cancel_pair_device,     false, MGMT_CANCEL_PAIR_DEVICE_SIZE },
 +	{ unpair_device,          false, MGMT_UNPAIR_DEVICE_SIZE },
 +	{ user_confirm_reply,     false, MGMT_USER_CONFIRM_REPLY_SIZE },
 +	{ user_confirm_neg_reply, false, MGMT_USER_CONFIRM_NEG_REPLY_SIZE },
 +	{ user_passkey_reply,     false, MGMT_USER_PASSKEY_REPLY_SIZE },
 +	{ user_passkey_neg_reply, false, MGMT_USER_PASSKEY_NEG_REPLY_SIZE },
 +	{ read_local_oob_data,    false, MGMT_READ_LOCAL_OOB_DATA_SIZE },
 +	{ add_remote_oob_data,    false, MGMT_ADD_REMOTE_OOB_DATA_SIZE },
 +	{ remove_remote_oob_data, false, MGMT_REMOVE_REMOTE_OOB_DATA_SIZE },
 +	{ start_discovery,        false, MGMT_START_DISCOVERY_SIZE },
 +	{ stop_discovery,         false, MGMT_STOP_DISCOVERY_SIZE },
 +	{ confirm_name,           false, MGMT_CONFIRM_NAME_SIZE },
 +	{ block_device,           false, MGMT_BLOCK_DEVICE_SIZE },
 +	{ unblock_device,         false, MGMT_UNBLOCK_DEVICE_SIZE },
 +	{ set_device_id,          false, MGMT_SET_DEVICE_ID_SIZE },
  };
  
 -void mgmt_index_added(struct hci_dev *hdev)
 +
 +int mgmt_control(struct sock *sk, struct msghdr *msg, size_t msglen)
  {
 -	struct mgmt_ev_ext_index ev;
 +	void *buf;
 +	u8 *cp;
 +	struct mgmt_hdr *hdr;
 +	u16 opcode, index, len;
 +	struct hci_dev *hdev = NULL;
 +	const struct mgmt_handler *handler;
 +	int err;
  
 -	if (test_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks))
 -		return;
 +	BT_DBG("got %zu bytes", msglen);
  
 -	switch (hdev->dev_type) {
 -	case HCI_BREDR:
 -		if (hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {
 -			mgmt_index_event(MGMT_EV_UNCONF_INDEX_ADDED, hdev,
 -					 NULL, 0, HCI_MGMT_UNCONF_INDEX_EVENTS);
 -			ev.type = 0x01;
 -		} else {
 -			mgmt_index_event(MGMT_EV_INDEX_ADDED, hdev, NULL, 0,
 -					 HCI_MGMT_INDEX_EVENTS);
 -			ev.type = 0x00;
 +	if (msglen < sizeof(*hdr))
 +		return -EINVAL;
 +
 +	buf = kmalloc(msglen, GFP_KERNEL);
 +	if (!buf)
 +		return -ENOMEM;
 +
 +	if (memcpy_fromiovec(buf, msg->msg_iov, msglen)) {
 +		err = -EFAULT;
 +		goto done;
 +	}
 +
 +	hdr = buf;
 +	opcode = __le16_to_cpu(hdr->opcode);
 +	index = __le16_to_cpu(hdr->index);
 +	len = __le16_to_cpu(hdr->len);
 +
 +	if (len != msglen - sizeof(*hdr)) {
 +		err = -EINVAL;
 +		goto done;
 +	}
 +
 +	if (index != MGMT_INDEX_NONE) {
 +		hdev = hci_dev_get(index);
 +		if (!hdev) {
 +			err = cmd_status(sk, index, opcode,
 +					 MGMT_STATUS_INVALID_INDEX);
 +			goto done;
  		}
 -		break;
 -	case HCI_AMP:
 -		ev.type = 0x02;
 -		break;
 -	default:
 -		return;
  	}
  
 -	ev.bus = hdev->bus;
 +	if (opcode >= ARRAY_SIZE(mgmt_handlers) ||
 +	    mgmt_handlers[opcode].func == NULL) {
 +		BT_DBG("Unknown op %u", opcode);
 +		err = cmd_status(sk, index, opcode,
 +				 MGMT_STATUS_UNKNOWN_COMMAND);
 +		goto done;
 +	}
 +
 +	if ((hdev && opcode < MGMT_OP_READ_INFO) ||
 +	    (!hdev && opcode >= MGMT_OP_READ_INFO)) {
 +		err = cmd_status(sk, index, opcode,
 +				 MGMT_STATUS_INVALID_INDEX);
 +		goto done;
 +	}
 +
 +	handler = &mgmt_handlers[opcode];
 +
 +	if ((handler->var_len && len < handler->data_len) ||
 +	    (!handler->var_len && len != handler->data_len)) {
 +		err = cmd_status(sk, index, opcode,
 +				 MGMT_STATUS_INVALID_PARAMS);
 +		goto done;
 +	}
 +
 +	if (hdev)
 +		mgmt_init_hdev(sk, hdev);
 +
 +	cp = buf + sizeof(*hdr);
 +
 +	err = handler->func(sk, hdev, cp, len);
 +	if (err < 0)
 +		goto done;
 +
 +	err = msglen;
 +
 +done:
 +	if (hdev)
 +		hci_dev_put(hdev);
  
 -	mgmt_index_event(MGMT_EV_EXT_INDEX_ADDED, hdev, &ev, sizeof(ev),
 -			 HCI_MGMT_EXT_INDEX_EVENTS);
 +	kfree(buf);
 +	return err;
  }
  
 -void mgmt_index_removed(struct hci_dev *hdev)
 +static void cmd_status_rsp(struct pending_cmd *cmd, void *data)
  {
 -	struct mgmt_ev_ext_index ev;
 -	u8 status = MGMT_STATUS_INVALID_INDEX;
 +	u8 *status = data;
  
 -	if (test_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks))
 -		return;
 +	cmd_status(cmd->sk, cmd->index, cmd->opcode, *status);
 +	mgmt_pending_remove(cmd);
 +}
  
 -	switch (hdev->dev_type) {
 -	case HCI_BREDR:
 -		mgmt_pending_foreach(0, hdev, cmd_complete_rsp, &status);
 +int mgmt_index_added(struct hci_dev *hdev)
 +{
 +	if (!mgmt_valid_hdev(hdev))
 +		return -ENOTSUPP;
  
 -		if (hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {
 -			mgmt_index_event(MGMT_EV_UNCONF_INDEX_REMOVED, hdev,
 -					 NULL, 0, HCI_MGMT_UNCONF_INDEX_EVENTS);
 -			ev.type = 0x01;
 -		} else {
 -			mgmt_index_event(MGMT_EV_INDEX_REMOVED, hdev, NULL, 0,
 -					 HCI_MGMT_INDEX_EVENTS);
 -			ev.type = 0x00;
 -		}
 -		break;
 -	case HCI_AMP:
 -		ev.type = 0x02;
 -		break;
 -	default:
 -		return;
 -	}
 +	return mgmt_event(MGMT_EV_INDEX_ADDED, hdev, NULL, 0, NULL);
 +}
 +
 +int mgmt_index_removed(struct hci_dev *hdev)
 +{
 +	u8 status = MGMT_STATUS_INVALID_INDEX;
 +
 +	if (!mgmt_valid_hdev(hdev))
 +		return -ENOTSUPP;
  
 -	ev.bus = hdev->bus;
 +	mgmt_pending_foreach(0, hdev, cmd_status_rsp, &status);
  
 -	mgmt_index_event(MGMT_EV_EXT_INDEX_REMOVED, hdev, &ev, sizeof(ev),
 -			 HCI_MGMT_EXT_INDEX_EVENTS);
 +	return mgmt_event(MGMT_EV_INDEX_REMOVED, hdev, NULL, 0, NULL);
  }
  
 -/* This function requires the caller holds hdev->lock */
 -static void restart_le_actions(struct hci_dev *hdev)
 +struct cmd_lookup {
 +	struct sock *sk;
 +	struct hci_dev *hdev;
 +	u8 mgmt_status;
 +};
 +
 +static void settings_rsp(struct pending_cmd *cmd, void *data)
  {
 -	struct hci_conn_params *p;
 +	struct cmd_lookup *match = data;
  
 -	list_for_each_entry(p, &hdev->le_conn_params, list) {
 -		/* Needed for AUTO_OFF case where might not "really"
 -		 * have been powered off.
 -		 */
 -		list_del_init(&p->action);
 +	send_settings_rsp(cmd->sk, cmd->opcode, match->hdev);
  
 -		switch (p->auto_connect) {
 -		case HCI_AUTO_CONN_DIRECT:
 -		case HCI_AUTO_CONN_ALWAYS:
 -			list_add(&p->action, &hdev->pend_le_conns);
 -			break;
 -		case HCI_AUTO_CONN_REPORT:
 -			list_add(&p->action, &hdev->pend_le_reports);
 -			break;
 -		default:
 -			break;
 -		}
 +	list_del(&cmd->list);
 +
 +	if (match->sk == NULL) {
 +		match->sk = cmd->sk;
 +		sock_hold(match->sk);
  	}
 +
 +	mgmt_pending_free(cmd);
 +}
 +
 +static void set_bredr_scan(struct hci_request *req)
 +{
 +	struct hci_dev *hdev = req->hdev;
 +	u8 scan = 0;
 +
 +	/* Ensure that fast connectable is disabled. This function will
 +	 * not do anything if the page scan parameters are already what
 +	 * they should be.
 +	 */
 +	write_fast_connectable(req, false);
 +
 +	if (test_bit(HCI_CONNECTABLE, &hdev->dev_flags))
 +		scan |= SCAN_PAGE;
 +	if (test_bit(HCI_DISCOVERABLE, &hdev->dev_flags))
 +		scan |= SCAN_INQUIRY;
 +
 +	if (scan)
 +		hci_req_add(req, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);
  }
  
 -void mgmt_power_on(struct hci_dev *hdev, int err)
 +static void powered_complete(struct hci_dev *hdev, u8 status)
  {
  	struct cmd_lookup match = { NULL, hdev };
  
* Unmerged path net/bluetooth/mgmt.c
