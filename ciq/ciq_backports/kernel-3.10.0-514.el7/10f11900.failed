Btrfs: Include map_type in raid_bio

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Zhao Lei <zhaolei@cn.fujitsu.com>
commit 10f11900167a83e0c229c4c27e73e720ebd55b5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/10f11900.failed

Corrent code use many kinds of "clever" way to determine operation
target's raid type, as:
  raid_map != NULL
  or
  raid_map[MAX_NR] == RAID[56]_Q_STRIPE

To make code easy to maintenance, this patch put raid type into
bbio, and we can always get raid type from bbio with a "stupid"
way.

	Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
	Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit 10f11900167a83e0c229c4c27e73e720ebd55b5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/raid56.c
#	fs/btrfs/scrub.c
diff --cc fs/btrfs/raid56.c
index 7f7e258d9628,5264858ed768..000000000000
--- a/fs/btrfs/raid56.c
+++ b/fs/btrfs/raid56.c
@@@ -1028,10 -994,12 +1028,16 @@@ static struct btrfs_raid_bio *alloc_rbi
  	rbio->bio_pages = p + sizeof(struct page *) * num_pages;
  	rbio->dbitmap = p + sizeof(struct page *) * num_pages * 2;
  
++<<<<<<< HEAD
 +	if (raid_map[real_stripes - 1] == RAID6_Q_STRIPE)
++=======
+ 	if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)
+ 		nr_data = real_stripes - 1;
+ 	else if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)
++>>>>>>> 10f11900167a (Btrfs: Include map_type in raid_bio)
  		nr_data = real_stripes - 2;
  	else
- 		nr_data = real_stripes - 1;
+ 		BUG();
  
  	rbio->nr_data = nr_data;
  	return rbio;
@@@ -1885,9 -1852,7 +1891,13 @@@ static void __raid_recover_end_io(struc
  		}
  
  		/* all raid6 handling here */
++<<<<<<< HEAD
 +		if (rbio->raid_map[rbio->real_stripes - 1] ==
 +		    RAID6_Q_STRIPE) {
 +
++=======
+ 		if (rbio->bbio->map_type & BTRFS_BLOCK_GROUP_RAID6) {
++>>>>>>> 10f11900167a (Btrfs: Include map_type in raid_bio)
  			/*
  			 * single failure, rebuild from parity raid5
  			 * style
diff --cc fs/btrfs/scrub.c
index 37f347301744,19781e924443..000000000000
--- a/fs/btrfs/scrub.c
+++ b/fs/btrfs/scrub.c
@@@ -1260,21 -1254,18 +1260,29 @@@ out
  	return 0;
  }
  
 -static inline int scrub_nr_raid_mirrors(struct btrfs_bio *bbio)
 +static inline int scrub_nr_raid_mirrors(struct btrfs_bio *bbio, u64 *raid_map)
  {
++<<<<<<< HEAD
 +	if (raid_map) {
 +		int real_stripes = bbio->num_stripes - bbio->num_tgtdevs;
 +
 +		if (raid_map[real_stripes - 1] == RAID6_Q_STRIPE)
 +			return 3;
 +		else
 +			return 2;
 +	} else {
++=======
+ 	if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)
+ 		return 2;
+ 	else if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)
+ 		return 3;
+ 	else
++>>>>>>> 10f11900167a (Btrfs: Include map_type in raid_bio)
  		return (int)bbio->num_stripes;
- 	}
  }
  
- static inline void scrub_stripe_index_and_offset(u64 logical, u64 *raid_map,
+ static inline void scrub_stripe_index_and_offset(u64 logical, u64 map_type,
+ 						 u64 *raid_map,
  						 u64 mapped_length,
  						 int nstripes, int mirror,
  						 int *stripe_index,
@@@ -1360,7 -1346,8 +1368,12 @@@ static int scrub_setup_recheck_block(st
  
  		BUG_ON(page_index >= SCRUB_PAGES_PER_RD_BIO);
  
++<<<<<<< HEAD
 +		nmirrors = scrub_nr_raid_mirrors(bbio, raid_map);
++=======
+ 		nmirrors = min(scrub_nr_raid_mirrors(bbio), BTRFS_MAX_MIRRORS);
+ 
++>>>>>>> 10f11900167a (Btrfs: Include map_type in raid_bio)
  		for (mirror_index = 0; mirror_index < nmirrors;
  		     mirror_index++) {
  			struct scrub_block *sblock;
@@@ -1384,7 -1368,9 +1397,13 @@@ leave_nomem
  			sblock->pagev[page_index] = page;
  			page->logical = logical;
  
++<<<<<<< HEAD
 +			scrub_stripe_index_and_offset(logical, raid_map,
++=======
+ 			scrub_stripe_index_and_offset(logical,
+ 						      bbio->map_type,
+ 						      bbio->raid_map,
++>>>>>>> 10f11900167a (Btrfs: Include map_type in raid_bio)
  						      mapped_length,
  						      bbio->num_stripes -
  						      bbio->num_tgtdevs,
@@@ -1433,7 -1419,9 +1452,13 @@@ static void scrub_bio_wait_endio(struc
  
  static inline int scrub_is_page_on_raid56(struct scrub_page *page)
  {
++<<<<<<< HEAD
 +	return page->recover && page->recover->raid_map;
++=======
+ 	return page->recover &&
+ 	       (page->recover->bbio->map_type & (BTRFS_BLOCK_GROUP_RAID5 |
+ 	       BTRFS_BLOCK_GROUP_RAID6));
++>>>>>>> 10f11900167a (Btrfs: Include map_type in raid_bio)
  }
  
  static int scrub_submit_raid56_bio_wait(struct btrfs_fs_info *fs_info,
* Unmerged path fs/btrfs/raid56.c
* Unmerged path fs/btrfs/scrub.c
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 6efc272f0e6d..0d163d64b453 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -5422,6 +5422,7 @@ static int __btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,
 	}
 
 	*bbio_ret = bbio;
+	bbio->map_type = map->type;
 	bbio->num_stripes = num_stripes;
 	bbio->max_errors = max_errors;
 	bbio->mirror_num = mirror_num;
diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index bc4a84130854..94d1446d12ae 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -295,6 +295,7 @@ typedef void (btrfs_bio_end_io_t) (struct btrfs_bio *bio, int err);
 struct btrfs_bio {
 	atomic_t stripes_pending;
 	struct btrfs_fs_info *fs_info;
+	u64 map_type; /* get from map_lookup->type */
 	bio_end_io_t *end_io;
 	struct bio *orig_bio;
 	unsigned long flags;
