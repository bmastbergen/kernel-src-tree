drm/i915: Track whether an atomic transaction changes the active CRTC's

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Matt Roper <matthew.d.roper@intel.com>
commit 8b4a7d0597cd9910d7127ffae6ae91d21853a8a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8b4a7d05.failed

For the purposes of DDB re-allocation we need to know whether a
transaction changes the list of CRTC's that are active.  While
state->modeset could be used for this purpose, that would be slightly
too aggressive since it would lead us to re-allocate the DDB when a
CRTC's mode changes, but not its final active state.

	Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1463061971-19638-7-git-send-email-matthew.d.roper@intel.com
(cherry picked from commit 8b4a7d0597cd9910d7127ffae6ae91d21853a8a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_display.c
#	drivers/gpu/drm/i915/intel_drv.h
diff --cc drivers/gpu/drm/i915/intel_display.c
index e2e955a9df5d,5d9909049180..000000000000
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@@ -11595,35 -13249,31 +11595,47 @@@ done
  	return ret;
  }
  
 -static int intel_modeset_checks(struct drm_atomic_state *state)
 +static int __intel_set_mode(struct drm_crtc *crtc,
 +			    struct drm_display_mode *mode,
 +			    int x, int y, struct drm_framebuffer *fb,
 +			    struct intel_crtc_state *pipe_config,
 +			    unsigned modeset_pipes,
 +			    unsigned prepare_pipes,
 +			    unsigned disable_pipes)
  {
 -	struct intel_atomic_state *intel_state = to_intel_atomic_state(state);
 -	struct drm_i915_private *dev_priv = state->dev->dev_private;
 -	struct drm_crtc *crtc;
 -	struct drm_crtc_state *crtc_state;
 -	int ret = 0, i;
 +	struct drm_device *dev = crtc->dev;
 +	struct drm_i915_private *dev_priv = dev->dev_private;
 +	struct drm_display_mode *saved_mode;
 +	struct intel_crtc_state *crtc_state_copy = NULL;
 +	struct intel_crtc *intel_crtc;
 +	int ret = 0;
  
 -	if (!check_digital_port_conflicts(state)) {
 -		DRM_DEBUG_KMS("rejecting conflicting digital port configuration\n");
 -		return -EINVAL;
 +	saved_mode = kmalloc(sizeof(*saved_mode), GFP_KERNEL);
 +	if (!saved_mode)
 +		return -ENOMEM;
 +
 +	crtc_state_copy = kmalloc(sizeof(*crtc_state_copy), GFP_KERNEL);
 +	if (!crtc_state_copy) {
 +		ret = -ENOMEM;
 +		goto done;
  	}
  
 -	intel_state->modeset = true;
 -	intel_state->active_crtcs = dev_priv->active_crtcs;
 +	*saved_mode = crtc->mode;
  
++<<<<<<< HEAD
 +	if (modeset_pipes)
 +		to_intel_crtc(crtc)->new_config = pipe_config;
++=======
+ 	for_each_crtc_in_state(state, crtc, crtc_state, i) {
+ 		if (crtc_state->active)
+ 			intel_state->active_crtcs |= 1 << i;
+ 		else
+ 			intel_state->active_crtcs &= ~(1 << i);
+ 
+ 		if (crtc_state->active != crtc->state->active)
+ 			intel_state->active_pipe_changes |= drm_crtc_mask(crtc);
+ 	}
++>>>>>>> 8b4a7d0597cd (drm/i915: Track whether an atomic transaction changes the active CRTC's)
  
  	/*
  	 * See if the config requires any additional preparation, e.g.
diff --cc drivers/gpu/drm/i915/intel_drv.h
index 640e923ced09,9f9c9cb82a20..000000000000
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@@ -239,7 -276,43 +239,47 @@@ typedef struct dpll 
  	int	vco;
  	int	m;
  	int	p;
++<<<<<<< HEAD
 +} intel_clock_t;
++=======
+ };
+ 
+ struct intel_atomic_state {
+ 	struct drm_atomic_state base;
+ 
+ 	unsigned int cdclk;
+ 
+ 	/*
+ 	 * Calculated device cdclk, can be different from cdclk
+ 	 * only when all crtc's are DPMS off.
+ 	 */
+ 	unsigned int dev_cdclk;
+ 
+ 	bool dpll_set, modeset;
+ 
+ 	/*
+ 	 * Does this transaction change the pipes that are active?  This mask
+ 	 * tracks which CRTC's have changed their active state at the end of
+ 	 * the transaction (not counting the temporary disable during modesets).
+ 	 * This mask should only be non-zero when intel_state->modeset is true,
+ 	 * but the converse is not necessarily true; simply changing a mode may
+ 	 * not flip the final active status of any CRTC's
+ 	 */
+ 	unsigned int active_pipe_changes;
+ 
+ 	unsigned int active_crtcs;
+ 	unsigned int min_pixclk[I915_MAX_PIPES];
+ 
+ 	struct intel_shared_dpll_config shared_dpll[I915_NUM_PLLS];
+ 	struct intel_wm_config wm_config;
+ 
+ 	/*
+ 	 * Current watermarks can't be trusted during hardware readout, so
+ 	 * don't bother calculating intermediate watermarks.
+ 	 */
+ 	bool skip_intermediate_wm;
+ };
++>>>>>>> 8b4a7d0597cd (drm/i915: Track whether an atomic transaction changes the active CRTC's)
  
  struct intel_plane_state {
  	struct drm_plane_state base;
* Unmerged path drivers/gpu/drm/i915/intel_display.c
* Unmerged path drivers/gpu/drm/i915/intel_drv.h
