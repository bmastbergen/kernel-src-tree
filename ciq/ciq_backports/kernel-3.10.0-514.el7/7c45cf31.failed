cpufreq: Introduce ->ready() callback for cpufreq drivers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [cpufreq] powernv: Introduce ->ready() callback for cpufreq drivers (Gustavo Duarte) [1346246]
Rebuild_FUZZ: 91.23%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 7c45cf31b3ab9be270a7bf6af2926631dc566436
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7c45cf31.failed

Currently there is no callback for cpufreq drivers which is called once the
policy is ready to be used. There are some requirements where such a callback is
required.

One of them is registering a cooling device with the help of
of_cpufreq_cooling_register(). This routine tries to get 'struct cpufreq_policy'
for CPUs which isn't yet initialed at the time ->init() is called and so we face
issues while registering the cooling device.

Because we can't register cooling device from ->init(), we need a callback that
is called after the policy is ready to be used and hence we introduce ->ready()
callback.

	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Reviewed-by: Eduardo Valentin <edubezval@gmail.com>
	Tested-by: Eduardo Valentin <edubezval@gmail.com>
	Reviewed-by: Lukasz Majewski <l.majewski@samsung.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 7c45cf31b3ab9be270a7bf6af2926631dc566436)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/cpufreq.h
diff --cc include/linux/cpufreq.h
index 0c6cbe6ccb72,4d078cebafd2..000000000000
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@@ -419,39 -215,174 +419,143 @@@ __ATTR(_name, 0444, show_##_name, NULL
  static struct global_attr _name =		\
  __ATTR(_name, 0644, show_##_name, store_##_name)
  
++<<<<<<< HEAD
 +struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
 +void cpufreq_cpu_put(struct cpufreq_policy *policy);
++=======
+ 
+ struct cpufreq_driver {
+ 	char		name[CPUFREQ_NAME_LEN];
+ 	u8		flags;
+ 	void		*driver_data;
+ 
+ 	/* needed by all drivers */
+ 	int		(*init)(struct cpufreq_policy *policy);
+ 	int		(*verify)(struct cpufreq_policy *policy);
+ 
+ 	/* define one out of two */
+ 	int		(*setpolicy)(struct cpufreq_policy *policy);
+ 
+ 	/*
+ 	 * On failure, should always restore frequency to policy->restore_freq
+ 	 * (i.e. old freq).
+ 	 */
+ 	int		(*target)(struct cpufreq_policy *policy,
+ 				  unsigned int target_freq,
+ 				  unsigned int relation);	/* Deprecated */
+ 	int		(*target_index)(struct cpufreq_policy *policy,
+ 					unsigned int index);
+ 	/*
+ 	 * Only for drivers with target_index() and CPUFREQ_ASYNC_NOTIFICATION
+ 	 * unset.
+ 	 *
+ 	 * get_intermediate should return a stable intermediate frequency
+ 	 * platform wants to switch to and target_intermediate() should set CPU
+ 	 * to to that frequency, before jumping to the frequency corresponding
+ 	 * to 'index'. Core will take care of sending notifications and driver
+ 	 * doesn't have to handle them in target_intermediate() or
+ 	 * target_index().
+ 	 *
+ 	 * Drivers can return '0' from get_intermediate() in case they don't
+ 	 * wish to switch to intermediate frequency for some target frequency.
+ 	 * In that case core will directly call ->target_index().
+ 	 */
+ 	unsigned int	(*get_intermediate)(struct cpufreq_policy *policy,
+ 					    unsigned int index);
+ 	int		(*target_intermediate)(struct cpufreq_policy *policy,
+ 					       unsigned int index);
+ 
+ 	/* should be defined, if possible */
+ 	unsigned int	(*get)(unsigned int cpu);
+ 
+ 	/* optional */
+ 	int		(*bios_limit)(int cpu, unsigned int *limit);
+ 
+ 	int		(*exit)(struct cpufreq_policy *policy);
+ 	void		(*stop_cpu)(struct cpufreq_policy *policy);
+ 	int		(*suspend)(struct cpufreq_policy *policy);
+ 	int		(*resume)(struct cpufreq_policy *policy);
+ 
+ 	/* Will be called after the driver is fully initialized */
+ 	void		(*ready)(struct cpufreq_policy *policy);
+ 
+ 	struct freq_attr **attr;
+ 
+ 	/* platform specific boost support code */
+ 	bool		boost_supported;
+ 	bool		boost_enabled;
+ 	int		(*set_boost)(int state);
+ };
+ 
+ /* flags */
+ #define CPUFREQ_STICKY		(1 << 0)	/* driver isn't removed even if
+ 						   all ->init() calls failed */
+ #define CPUFREQ_CONST_LOOPS	(1 << 1)	/* loops_per_jiffy or other
+ 						   kernel "constants" aren't
+ 						   affected by frequency
+ 						   transitions */
+ #define CPUFREQ_PM_NO_WARN	(1 << 2)	/* don't warn on suspend/resume
+ 						   speed mismatches */
+ 
+ /*
+  * This should be set by platforms having multiple clock-domains, i.e.
+  * supporting multiple policies. With this sysfs directories of governor would
+  * be created in cpu/cpu<num>/cpufreq/ directory and so they can use the same
+  * governor with different tunables for different clusters.
+  */
+ #define CPUFREQ_HAVE_GOVERNOR_PER_POLICY (1 << 3)
+ 
+ /*
+  * Driver will do POSTCHANGE notifications from outside of their ->target()
+  * routine and so must set cpufreq_driver->flags with this flag, so that core
+  * can handle them specially.
+  */
+ #define CPUFREQ_ASYNC_NOTIFICATION  (1 << 4)
+ 
+ /*
+  * Set by drivers which want cpufreq core to check if CPU is running at a
+  * frequency present in freq-table exposed by the driver. For these drivers if
+  * CPU is found running at an out of table freq, we will try to set it to a freq
+  * from the table. And if that fails, we will stop further boot process by
+  * issuing a BUG_ON().
+  */
+ #define CPUFREQ_NEED_INITIAL_FREQ_CHECK	(1 << 5)
+ 
+ int cpufreq_register_driver(struct cpufreq_driver *driver_data);
+ int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
+ 
++>>>>>>> 7c45cf31b3ab (cpufreq: Introduce ->ready() callback for cpufreq drivers)
  const char *cpufreq_get_current_driver(void);
 -void *cpufreq_get_driver_data(void);
  
 -static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
 -		unsigned int min, unsigned int max)
 -{
 -	if (policy->min < min)
 -		policy->min = min;
 -	if (policy->max < min)
 -		policy->max = min;
 -	if (policy->min > max)
 -		policy->min = max;
 -	if (policy->max > max)
 -		policy->max = max;
 -	if (policy->min > policy->max)
 -		policy->min = policy->max;
 -	return;
 -}
 -
 -static inline void
 -cpufreq_verify_within_cpu_limits(struct cpufreq_policy *policy)
 -{
 -	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
 -			policy->cpuinfo.max_freq);
 -}
 +/*********************************************************************
 + *                        CPUFREQ 2.6. INTERFACE                     *
 + *********************************************************************/
 +u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
 +int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 +int cpufreq_update_policy(unsigned int cpu);
 +bool have_governor_per_policy(void);
 +struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
  
  #ifdef CONFIG_CPU_FREQ
 -void cpufreq_suspend(void);
 -void cpufreq_resume(void);
 -int cpufreq_generic_suspend(struct cpufreq_policy *policy);
 +/*
 + * query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it
 + */
 +unsigned int cpufreq_get(unsigned int cpu);
  #else
 -static inline void cpufreq_suspend(void) {}
 -static inline void cpufreq_resume(void) {}
 +static inline unsigned int cpufreq_get(unsigned int cpu)
 +{
 +	return 0;
 +}
  #endif
  
 -/*********************************************************************
 - *                     CPUFREQ NOTIFIER INTERFACE                    *
 - *********************************************************************/
 -
 -#define CPUFREQ_TRANSITION_NOTIFIER	(0)
 -#define CPUFREQ_POLICY_NOTIFIER		(1)
 -
 -/* Transition notifiers */
 -#define CPUFREQ_PRECHANGE		(0)
 -#define CPUFREQ_POSTCHANGE		(1)
 -
 -/* Policy Notifiers  */
 -#define CPUFREQ_ADJUST			(0)
 -#define CPUFREQ_INCOMPATIBLE		(1)
 -#define CPUFREQ_NOTIFY			(2)
 -#define CPUFREQ_START			(3)
 -#define CPUFREQ_UPDATE_POLICY_CPU	(4)
 -#define CPUFREQ_CREATE_POLICY		(5)
 -#define CPUFREQ_REMOVE_POLICY		(6)
 -
 +/*
 + * query the last known CPU freq (in kHz). If zero, cpufreq couldn't detect it
 + */
  #ifdef CONFIG_CPU_FREQ
 -int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
 -int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
 -
 -void cpufreq_freq_transition_begin(struct cpufreq_policy *policy,
 -		struct cpufreq_freqs *freqs);
 -void cpufreq_freq_transition_end(struct cpufreq_policy *policy,
 -		struct cpufreq_freqs *freqs, int transition_failed);
 -
 -#else /* CONFIG_CPU_FREQ */
 -static inline int cpufreq_register_notifier(struct notifier_block *nb,
 -						unsigned int list)
 +unsigned int cpufreq_quick_get(unsigned int cpu);
 +unsigned int cpufreq_quick_get_max(unsigned int cpu);
 +#else
 +static inline unsigned int cpufreq_quick_get(unsigned int cpu)
  {
  	return 0;
  }
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 1eac8b4523be..395a5ce778b6 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -1276,8 +1276,13 @@ static int __cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)
 	up_write(&policy->rwsem);
 
 	kobject_uevent(&policy->kobj, KOBJ_ADD);
+
 	up_read(&cpufreq_rwsem);
 
+	/* Callback for handling stuff after policy is ready */
+	if (cpufreq_driver->ready)
+		cpufreq_driver->ready(policy);
+
 	pr_debug("initialization complete\n");
 
 	return 0;
* Unmerged path include/linux/cpufreq.h
