SUNRPC: Remove TCP socket linger code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 9cbc94fb06f98de0e8d393eaff09c790f4c3ba46
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9cbc94fb.failed

Now that we no longer use the partial shutdown code when closing the
socket, we no longer need to worry about the TCP linger2 state.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 9cbc94fb06f98de0e8d393eaff09c790f4c3ba46)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtsock.c
diff --cc net/sunrpc/xprtsock.c
index 44e3d5b48882,c65f74019288..000000000000
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@@ -1471,47 -1426,7 +1471,50 @@@ out
  	read_unlock_bh(&sk->sk_callback_lock);
  }
  
++<<<<<<< HEAD
 +/*
 + * Do the equivalent of linger/linger2 handling for dealing with
 + * broken servers that don't close the socket in a timely
 + * fashion
 + */
 +static void xs_tcp_schedule_linger_timeout(struct rpc_xprt *xprt,
 +		unsigned long timeout)
 +{
 +	struct sock_xprt *transport;
 +
 +	if (xprt_test_and_set_connecting(xprt))
 +		return;
 +	set_bit(XPRT_CONNECTION_ABORT, &xprt->state);
 +	transport = container_of(xprt, struct sock_xprt, xprt);
 +	queue_delayed_work(rpciod_workqueue, &transport->connect_worker,
 +			   timeout);
 +}
 +
 +static void xs_tcp_cancel_linger_timeout(struct rpc_xprt *xprt)
 +{
 +	struct sock_xprt *transport;
 +
 +	transport = container_of(xprt, struct sock_xprt, xprt);
 +
 +	if (!test_bit(XPRT_CONNECTION_ABORT, &xprt->state) ||
 +	    !cancel_delayed_work(&transport->connect_worker))
 +		return;
 +	clear_bit(XPRT_CONNECTION_ABORT, &xprt->state);
 +	xprt_clear_connecting(xprt);
 +}
 +
 +static void xs_sock_reset_connection_flags(struct rpc_xprt *xprt)
 +{
 +	smp_mb__before_clear_bit();
 +	clear_bit(XPRT_CONNECTION_ABORT, &xprt->state);
 +	clear_bit(XPRT_CONNECTION_CLOSE, &xprt->state);
 +	clear_bit(XPRT_CLOSE_WAIT, &xprt->state);
 +	clear_bit(XPRT_CLOSING, &xprt->state);
 +	smp_mb__after_clear_bit();
 +}
 +
++=======
++>>>>>>> 9cbc94fb06f9 (SUNRPC: Remove TCP socket linger code)
  static void xs_sock_mark_closed(struct rpc_xprt *xprt)
  {
  	xs_sock_reset_connection_flags(xprt);
@@@ -1563,11 -1478,10 +1566,15 @@@ static void xs_tcp_state_change(struct 
  		xprt->connect_cookie++;
  		xprt->reestablish_timeout = 0;
  		set_bit(XPRT_CLOSING, &xprt->state);
 -		smp_mb__before_atomic();
 +		smp_mb__before_clear_bit();
  		clear_bit(XPRT_CONNECTED, &xprt->state);
  		clear_bit(XPRT_CLOSE_WAIT, &xprt->state);
++<<<<<<< HEAD
 +		smp_mb__after_clear_bit();
 +		xs_tcp_schedule_linger_timeout(xprt, xs_tcp_fin_timeout);
++=======
+ 		smp_mb__after_atomic();
++>>>>>>> 9cbc94fb06f9 (SUNRPC: Remove TCP socket linger code)
  		break;
  	case TCP_CLOSE_WAIT:
  		/* The server initiated a shutdown of the socket */
@@@ -1584,13 -1498,11 +1591,16 @@@
  		break;
  	case TCP_LAST_ACK:
  		set_bit(XPRT_CLOSING, &xprt->state);
++<<<<<<< HEAD
 +		xs_tcp_schedule_linger_timeout(xprt, xs_tcp_fin_timeout);
 +		smp_mb__before_clear_bit();
++=======
+ 		smp_mb__before_atomic();
++>>>>>>> 9cbc94fb06f9 (SUNRPC: Remove TCP socket linger code)
  		clear_bit(XPRT_CONNECTED, &xprt->state);
 -		smp_mb__after_atomic();
 +		smp_mb__after_clear_bit();
  		break;
  	case TCP_CLOSE:
- 		xs_tcp_cancel_linger_timeout(xprt);
  		xs_sock_mark_closed(xprt);
  	}
   out:
* Unmerged path net/sunrpc/xprtsock.c
