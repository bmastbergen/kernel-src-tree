IB/hfi1: Remove fast registration from the code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 349abd059ed195c75b5f787102a333a4dae10775
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/349abd05.failed

The driver does not support it anyway, and the support
should be added to a generic layer shared by both hfi1,
qib and softroce drivers.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 349abd059ed195c75b5f787102a333a4dae10775)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/keys.c
#	drivers/staging/hfi1/verbs.c
#	drivers/staging/hfi1/verbs.h
diff --cc drivers/staging/hfi1/keys.c
index f6eff177ace1,cb4e6087dfdb..000000000000
--- a/drivers/staging/hfi1/keys.c
+++ b/drivers/staging/hfi1/keys.c
@@@ -354,58 -354,3 +354,61 @@@ bail
  	rcu_read_unlock();
  	return 0;
  }
++<<<<<<< HEAD:drivers/staging/hfi1/keys.c
 +
 +/*
 + * Initialize the memory region specified by the work request.
 + */
 +int hfi1_fast_reg_mr(struct hfi1_qp *qp, struct ib_send_wr *wr)
 +{
 +	struct hfi1_lkey_table *rkt = &to_idev(qp->ibqp.device)->lk_table;
 +	struct hfi1_pd *pd = to_ipd(qp->ibqp.pd);
 +	struct hfi1_mregion *mr;
 +	u32 rkey = wr->wr.fast_reg.rkey;
 +	unsigned i, n, m;
 +	int ret = -EINVAL;
 +	unsigned long flags;
 +	u64 *page_list;
 +	size_t ps;
 +
 +	spin_lock_irqsave(&rkt->lock, flags);
 +	if (pd->user || rkey == 0)
 +		goto bail;
 +
 +	mr = rcu_dereference_protected(
 +		rkt->table[(rkey >> (32 - hfi1_lkey_table_size))],
 +		lockdep_is_held(&rkt->lock));
 +	if (unlikely(mr == NULL || qp->ibqp.pd != mr->pd))
 +		goto bail;
 +
 +	if (wr->wr.fast_reg.page_list_len > mr->max_segs)
 +		goto bail;
 +
 +	ps = 1UL << wr->wr.fast_reg.page_shift;
 +	if (wr->wr.fast_reg.length > ps * wr->wr.fast_reg.page_list_len)
 +		goto bail;
 +
 +	mr->user_base = wr->wr.fast_reg.iova_start;
 +	mr->iova = wr->wr.fast_reg.iova_start;
 +	mr->lkey = rkey;
 +	mr->length = wr->wr.fast_reg.length;
 +	mr->access_flags = wr->wr.fast_reg.access_flags;
 +	page_list = wr->wr.fast_reg.page_list->page_list;
 +	m = 0;
 +	n = 0;
 +	for (i = 0; i < wr->wr.fast_reg.page_list_len; i++) {
 +		mr->map[m]->segs[n].vaddr = (void *) page_list[i];
 +		mr->map[m]->segs[n].length = ps;
 +		if (++n == HFI1_SEGSZ) {
 +			m++;
 +			n = 0;
 +		}
 +	}
 +
 +	ret = 0;
 +bail:
 +	spin_unlock_irqrestore(&rkt->lock, flags);
 +	return ret;
 +}
++=======
++>>>>>>> 349abd059ed1 (IB/hfi1: Remove fast registration from the code):drivers/staging/rdma/hfi1/keys.c
diff --cc drivers/staging/hfi1/verbs.c
index a13a2b135365,6e2da7ee6d2f..000000000000
--- a/drivers/staging/hfi1/verbs.c
+++ b/drivers/staging/hfi1/verbs.c
@@@ -415,7 -410,21 +413,25 @@@ static int post_one_send(struct hfi1_q
  	rkt = &to_idev(qp->ibqp.device)->lk_table;
  	pd = to_ipd(qp->ibqp.pd);
  	wqe = get_swqe_ptr(qp, qp->s_head);
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +	wqe->wr = *wr;
++=======
+ 
+ 
+ 	if (qp->ibqp.qp_type != IB_QPT_UC &&
+ 	    qp->ibqp.qp_type != IB_QPT_RC)
+ 		memcpy(&wqe->ud_wr, ud_wr(wr), sizeof(wqe->ud_wr));
+ 	else if (wr->opcode == IB_WR_RDMA_WRITE_WITH_IMM ||
+ 		 wr->opcode == IB_WR_RDMA_WRITE ||
+ 		 wr->opcode == IB_WR_RDMA_READ)
+ 		memcpy(&wqe->rdma_wr, rdma_wr(wr), sizeof(wqe->rdma_wr));
+ 	else if (wr->opcode == IB_WR_ATOMIC_CMP_AND_SWP ||
+ 		 wr->opcode == IB_WR_ATOMIC_FETCH_AND_ADD)
+ 		memcpy(&wqe->atomic_wr, atomic_wr(wr), sizeof(wqe->atomic_wr));
+ 	else
+ 		memcpy(&wqe->wr, wr, sizeof(wqe->wr));
+ 
++>>>>>>> 349abd059ed1 (IB/hfi1: Remove fast registration from the code):drivers/staging/rdma/hfi1/verbs.c
  	wqe->length = 0;
  	j = 0;
  	if (wr->num_sge) {
diff --cc drivers/staging/hfi1/verbs.h
index e4a8a0d4ccf8,159ec08bfcd8..000000000000
--- a/drivers/staging/hfi1/verbs.h
+++ b/drivers/staging/hfi1/verbs.h
@@@ -348,7 -348,12 +348,16 @@@ struct hfi1_mr 
   * in qp->s_max_sge.
   */
  struct hfi1_swqe {
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.h
 +	struct ib_send_wr wr;   /* don't use wr.sg_list */
++=======
+ 	union {
+ 		struct ib_send_wr wr;   /* don't use wr.sg_list */
+ 		struct ib_rdma_wr rdma_wr;
+ 		struct ib_atomic_wr atomic_wr;
+ 		struct ib_ud_wr ud_wr;
+ 	};
++>>>>>>> 349abd059ed1 (IB/hfi1: Remove fast registration from the code):drivers/staging/rdma/hfi1/verbs.h
  	u32 psn;                /* first packet sequence number */
  	u32 lpsn;               /* last packet sequence number */
  	u32 ssn;                /* send sequence number */
@@@ -1021,13 -1025,6 +1030,16 @@@ struct ib_mr *hfi1_alloc_mr(struct ib_p
  			    enum ib_mr_type mr_type,
  			    u32 max_entries);
  
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.h
 +struct ib_fast_reg_page_list *hfi1_alloc_fast_reg_page_list(
 +				struct ib_device *ibdev, int page_list_len);
 +
 +void hfi1_free_fast_reg_page_list(struct ib_fast_reg_page_list *pl);
 +
 +int hfi1_fast_reg_mr(struct hfi1_qp *qp, struct ib_send_wr *wr);
 +
++=======
++>>>>>>> 349abd059ed1 (IB/hfi1: Remove fast registration from the code):drivers/staging/rdma/hfi1/verbs.h
  struct ib_fmr *hfi1_alloc_fmr(struct ib_pd *pd, int mr_access_flags,
  			      struct ib_fmr_attr *fmr_attr);
  
* Unmerged path drivers/staging/hfi1/keys.c
diff --git a/drivers/staging/hfi1/mr.c b/drivers/staging/hfi1/mr.c
index 0208fc200c1a..568f185a022d 100644
--- a/drivers/staging/hfi1/mr.c
+++ b/drivers/staging/hfi1/mr.c
@@ -344,9 +344,10 @@ out:
 
 /*
  * Allocate a memory region usable with the
- * IB_WR_FAST_REG_MR send work request.
+ * IB_WR_REG_MR send work request.
  *
  * Return the memory region on success, otherwise return an errno.
+ * FIXME: IB_WR_REG_MR is not supported
  */
 struct ib_mr *hfi1_alloc_mr(struct ib_pd *pd,
 			    enum ib_mr_type mr_type,
@@ -364,36 +365,6 @@ struct ib_mr *hfi1_alloc_mr(struct ib_pd *pd,
 	return &mr->ibmr;
 }
 
-struct ib_fast_reg_page_list *
-hfi1_alloc_fast_reg_page_list(struct ib_device *ibdev, int page_list_len)
-{
-	unsigned size = page_list_len * sizeof(u64);
-	struct ib_fast_reg_page_list *pl;
-
-	if (size > PAGE_SIZE)
-		return ERR_PTR(-EINVAL);
-
-	pl = kzalloc(sizeof(*pl), GFP_KERNEL);
-	if (!pl)
-		return ERR_PTR(-ENOMEM);
-
-	pl->page_list = kzalloc(size, GFP_KERNEL);
-	if (!pl->page_list)
-		goto err_free;
-
-	return pl;
-
-err_free:
-	kfree(pl);
-	return ERR_PTR(-ENOMEM);
-}
-
-void hfi1_free_fast_reg_page_list(struct ib_fast_reg_page_list *pl)
-{
-	kfree(pl->page_list);
-	kfree(pl);
-}
-
 /**
  * hfi1_alloc_fmr - allocate a fast memory region
  * @pd: the protection domain for this memory region
* Unmerged path drivers/staging/hfi1/verbs.c
* Unmerged path drivers/staging/hfi1/verbs.h
