locks: have flock_lock_file take an inode pointer instead of a filp

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jeff Layton <jeff.layton@primarydata.com>
commit bcd7f78d078ff6197715c1ed070c92aca57ec12c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bcd7f78d.failed

...and rename it to better describe how it works.

In order to fix a use-after-free in NFS, we need to be able to remove
locks from an inode after the filp associated with them may have already
been freed. flock_lock_file already only dereferences the filp to get to
the inode, so just change it so the callers do that.

All of the callers already pass in a lock request that has the fl_file
set properly, so we don't need to pass it in individually. With that
change it now only dereferences the filp to get to the inode, so just
push that out to the callers.

	Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
	Reviewed-by: "J. Bruce Fields" <bfields@fieldses.org>
	Tested-by: "J. Bruce Fields" <bfields@fieldses.org>
(cherry picked from commit bcd7f78d078ff6197715c1ed070c92aca57ec12c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/locks.c
diff --cc fs/locks.c
index 4da168d46db3,4366b7c54e6d..000000000000
--- a/fs/locks.c
+++ b/fs/locks.c
@@@ -827,13 -862,21 +827,18 @@@ static int posix_locks_deadlock(struct 
   * whether or not a lock was successfully freed by testing the return
   * value for -ENOENT.
   */
- static int flock_lock_file(struct file *filp, struct file_lock *request)
+ static int flock_lock_inode(struct inode *inode, struct file_lock *request)
  {
  	struct file_lock *new_fl = NULL;
++<<<<<<< HEAD
 +	struct file_lock **before;
 +	struct inode * inode = file_inode(filp);
++=======
+ 	struct file_lock *fl;
+ 	struct file_lock_context *ctx;
++>>>>>>> bcd7f78d078f (locks: have flock_lock_file take an inode pointer instead of a filp)
  	int error = 0;
 -	bool found = false;
 -	LIST_HEAD(dispose);
 -
 -	ctx = locks_get_lock_context(inode, request->fl_type);
 -	if (!ctx) {
 -		if (request->fl_type != F_UNLCK)
 -			return -ENOMEM;
 -		return (request->fl_flags & FL_EXISTS) ? -ENOENT : 0;
 -	}
 +	int found = 0;
  
  	if (!(request->fl_flags & FL_ACCESS) && (request->fl_type != F_UNLCK)) {
  		new_fl = locks_alloc_lock();
@@@ -845,13 -888,8 +850,18 @@@
  	if (request->fl_flags & FL_ACCESS)
  		goto find_conflict;
  
++<<<<<<< HEAD
 +	for_each_lock(inode, before) {
 +		struct file_lock *fl = *before;
 +		if (IS_POSIX(fl))
 +			break;
 +		if (IS_LEASE(fl))
 +			continue;
 +		if (filp != fl->fl_file)
++=======
+ 	list_for_each_entry(fl, &ctx->flc_flock, fl_list) {
+ 		if (request->fl_file != fl->fl_file)
++>>>>>>> bcd7f78d078f (locks: have flock_lock_file take an inode pointer instead of a filp)
  			continue;
  		if (request->fl_type == fl->fl_type)
  			goto out;
@@@ -2258,6 -2388,53 +2268,56 @@@ void locks_remove_posix(struct file *fi
  
  EXPORT_SYMBOL(locks_remove_posix);
  
++<<<<<<< HEAD
++=======
+ /* The i_flctx must be valid when calling into here */
+ static void
+ locks_remove_flock(struct file *filp)
+ {
+ 	struct file_lock fl = {
+ 		.fl_owner = filp,
+ 		.fl_pid = current->tgid,
+ 		.fl_file = filp,
+ 		.fl_flags = FL_FLOCK,
+ 		.fl_type = F_UNLCK,
+ 		.fl_end = OFFSET_MAX,
+ 	};
+ 	struct inode *inode = file_inode(filp);
+ 	struct file_lock_context *flctx = inode->i_flctx;
+ 
+ 	if (list_empty(&flctx->flc_flock))
+ 		return;
+ 
+ 	if (filp->f_op->flock)
+ 		filp->f_op->flock(filp, F_SETLKW, &fl);
+ 	else
+ 		flock_lock_inode(inode, &fl);
+ 
+ 	if (fl.fl_ops && fl.fl_ops->fl_release_private)
+ 		fl.fl_ops->fl_release_private(&fl);
+ }
+ 
+ /* The i_flctx must be valid when calling into here */
+ static void
+ locks_remove_lease(struct file *filp)
+ {
+ 	struct inode *inode = file_inode(filp);
+ 	struct file_lock_context *ctx = inode->i_flctx;
+ 	struct file_lock *fl, *tmp;
+ 	LIST_HEAD(dispose);
+ 
+ 	if (list_empty(&ctx->flc_lease))
+ 		return;
+ 
+ 	spin_lock(&ctx->flc_lock);
+ 	list_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list)
+ 		if (filp == fl->fl_file)
+ 			lease_modify(fl, F_UNLCK, &dispose);
+ 	spin_unlock(&ctx->flc_lock);
+ 	locks_dispose_list(&dispose);
+ }
+ 
++>>>>>>> bcd7f78d078f (locks: have flock_lock_file take an inode pointer instead of a filp)
  /*
   * This function is called on the last close of an open file.
   */
* Unmerged path fs/locks.c
