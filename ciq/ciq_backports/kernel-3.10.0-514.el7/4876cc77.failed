SUNRPC: Ensure we release the TCP socket once it has been closed

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 4876cc779ff525b9c2376d8076edf47815e71f2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4876cc77.failed

This fixes a regression introduced by commit caf4ccd4e88cf2 ("SUNRPC:
Make xs_tcp_close() do a socket shutdown rather than a sock_release").
Prior to that commit, the autoclose feature would ensure that an
idle connection would result in the socket being both disconnected and
released, whereas now only gets disconnected.

While the current behaviour is harmless, it does leave the port bound
until either RPC traffic resumes or the RPC client is shut down.

	Reported-by: Steven Rostedt <rostedt@goodmis.org>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 4876cc779ff525b9c2376d8076edf47815e71f2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtsock.c
diff --cc net/sunrpc/xprtsock.c
index fde0663566e1,ee0715dfc3c7..000000000000
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@@ -835,6 -755,22 +817,25 @@@ static void xs_restore_old_callbacks(st
  	sk->sk_error_report = transport->old_error_report;
  }
  
++<<<<<<< HEAD
++=======
+ static void xs_sock_reset_connection_flags(struct rpc_xprt *xprt)
+ {
+ 	smp_mb__before_atomic();
+ 	clear_bit(XPRT_CLOSE_WAIT, &xprt->state);
+ 	clear_bit(XPRT_CLOSING, &xprt->state);
+ 	smp_mb__after_atomic();
+ }
+ 
+ static void xs_sock_mark_closed(struct rpc_xprt *xprt)
+ {
+ 	xs_sock_reset_connection_flags(xprt);
+ 	/* Mark transport as closed and wake up all pending tasks */
+ 	xprt_disconnect_done(xprt);
+ 	xprt_force_disconnect(xprt);
+ }
+ 
++>>>>>>> 4876cc779ff5 (SUNRPC: Ensure we release the TCP socket once it has been closed)
  /**
   * xs_error_report - callback to handle TCP socket state errors
   * @sk: socket
diff --git a/net/sunrpc/xprt.c b/net/sunrpc/xprt.c
index 4c15e68170a7..340ab2e9bf6d 100644
--- a/net/sunrpc/xprt.c
+++ b/net/sunrpc/xprt.c
@@ -609,8 +609,8 @@ static void xprt_autoclose(struct work_struct *work)
 	struct rpc_xprt *xprt =
 		container_of(work, struct rpc_xprt, task_cleanup);
 
-	xprt->ops->close(xprt);
 	clear_bit(XPRT_CLOSE_WAIT, &xprt->state);
+	xprt->ops->close(xprt);
 	xprt_release_write(xprt, NULL);
 }
 
* Unmerged path net/sunrpc/xprtsock.c
