netfilter: bridge: re-order check_hbh_len()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bernhard Thaler <bernhard.thaler@wvnet.at>
commit a4611d3b74b56658438ad1de4737a61a46be0fc0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a4611d3b.failed

Prepare check_hbh_len() to be called from newly introduced
br_validate_ipv6() in next commit.

	Signed-off-by: Bernhard Thaler <bernhard.thaler@wvnet.at>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit a4611d3b74b56658438ad1de4737a61a46be0fc0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_netfilter.c
diff --cc net/bridge/br_netfilter.c
index bfa28cea8c79,d201ea4440c9..000000000000
--- a/net/bridge/br_netfilter.c
+++ b/net/bridge/br_netfilter.c
@@@ -297,35 -264,74 +297,95 @@@ drop
  	return -1;
  }
  
++<<<<<<< HEAD
 +/* PF_BRIDGE/PRE_ROUTING *********************************************/
 +/* Undo the changes made for ip6tables PREROUTING and continue the
 + * bridge PRE_ROUTING hook. */
 +static int br_nf_pre_routing_finish_ipv6(struct sock *sk, struct sk_buff *skb)
++=======
+ /* We only check the length. A bridge shouldn't do any hop-by-hop stuff
+  * anyway
+  */
+ static int check_hbh_len(struct sk_buff *skb)
+ {
+ 	unsigned char *raw = (u8 *)(ipv6_hdr(skb) + 1);
+ 	u32 pkt_len;
+ 	const unsigned char *nh = skb_network_header(skb);
+ 	int off = raw - nh;
+ 	int len = (raw[1] + 1) << 3;
+ 
+ 	if ((raw + len) - skb->data > skb_headlen(skb))
+ 		goto bad;
+ 
+ 	off += 2;
+ 	len -= 2;
+ 
+ 	while (len > 0) {
+ 		int optlen = nh[off + 1] + 2;
+ 
+ 		switch (nh[off]) {
+ 		case IPV6_TLV_PAD1:
+ 			optlen = 1;
+ 			break;
+ 
+ 		case IPV6_TLV_PADN:
+ 			break;
+ 
+ 		case IPV6_TLV_JUMBO:
+ 			if (nh[off + 1] != 4 || (off & 3) != 2)
+ 				goto bad;
+ 			pkt_len = ntohl(*(__be32 *)(nh + off + 2));
+ 			if (pkt_len <= IPV6_MAXPLEN ||
+ 			    ipv6_hdr(skb)->payload_len)
+ 				goto bad;
+ 			if (pkt_len > skb->len - sizeof(struct ipv6hdr))
+ 				goto bad;
+ 			if (pskb_trim_rcsum(skb,
+ 					    pkt_len + sizeof(struct ipv6hdr)))
+ 				goto bad;
+ 			nh = skb_network_header(skb);
+ 			break;
+ 		default:
+ 			if (optlen > len)
+ 				goto bad;
+ 			break;
+ 		}
+ 		off += optlen;
+ 		len -= optlen;
+ 	}
+ 	if (len == 0)
+ 		return 0;
+ bad:
+ 	return -1;
+ }
+ 
+ static void nf_bridge_update_protocol(struct sk_buff *skb)
++>>>>>>> a4611d3b74b5 (netfilter: bridge: re-order check_hbh_len())
  {
 -	switch (skb->nf_bridge->orig_proto) {
 -	case BRNF_PROTO_8021Q:
 -		skb->protocol = htons(ETH_P_8021Q);
 -		break;
 -	case BRNF_PROTO_PPPOE:
 -		skb->protocol = htons(ETH_P_PPP_SES);
 -		break;
 -	case BRNF_PROTO_UNCHANGED:
 -		break;
 +	struct nf_bridge_info *nf_bridge = skb->nf_bridge;
 +	struct rtable *rt;
 +
 +	if (nf_bridge->mask & BRNF_PKT_TYPE) {
 +		skb->pkt_type = PACKET_OTHERHOST;
 +		nf_bridge->mask ^= BRNF_PKT_TYPE;
 +	}
 +	nf_bridge->mask ^= BRNF_NF_BRIDGE_PREROUTING;
 +
 +	rt = bridge_parent_rtable(nf_bridge->physindev);
 +	if (!rt) {
 +		kfree_skb(skb);
 +		return 0;
  	}
 +	skb_dst_set_noref(skb, &rt->dst);
 +
 +	skb->dev = nf_bridge->physindev;
 +	nf_bridge_update_protocol(skb);
 +	nf_bridge_push_encap_header(skb);
 +	NF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, sk, skb,
 +		       skb->dev, NULL,
 +		       br_handle_frame_finish, 1);
 +
 +	return 0;
  }
  
  /* Obtain the correct destination MAC address, while preserving the original
* Unmerged path net/bridge/br_netfilter.c
