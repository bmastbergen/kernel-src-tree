usb: musb: core: Fix handling of the phy notifications

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tony Lindgren <tony@atomide.com>
commit 8055555fc4590fbda32d4bbf7888bdb2cd4b2b74
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8055555f.failed

We currently can't unload omap2430 MUSB platform glue driver module and
this cause issues for fixing the MUSB code further. The reason we can't
remove omap2430 is because it uses the PHY functions and also exports the
omap_musb_mailbox function that some PHY drivers are using.

Let's fix the issue by exporting a more generic musb_mailbox function
from the MUSB core and allow platform glue layers to register phy_callback
function as needed.

And now we can now also get rid of the include/linux/musb-omap.h.

	Cc: Bin Liu <b-liu@ti.com>
	Cc: Felipe Balbi <balbi@ti.com>
	Cc: Kishon Vijay Abraham I <kishon@ti.com>
	Cc: NeilBrown <neil@brown.name>
	Reviewed-by: Kishon Vijay Abraham I <kishon@ti.com>
	Signed-off-by: Tony Lindgren <tony@atomide.com>
	Signed-off-by: Felipe Balbi <balbi@ti.com>
(cherry picked from commit 8055555fc4590fbda32d4bbf7888bdb2cd4b2b74)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/musb/musb_core.h
#	drivers/usb/musb/omap2430.c
#	drivers/usb/phy/phy-twl4030-usb.c
diff --cc drivers/usb/musb/musb_core.h
index 7fb4819a6f11,fd215fb45fd4..000000000000
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@@ -196,8 -166,21 +196,14 @@@ enum musb_g_ep0_state 
   * @vbus_status: returns vbus status if possible
   * @set_vbus:	forces vbus status
   * @adjust_channel_params: pre check for standard dma channel_program func
++<<<<<<< HEAD
++=======
+  * @pre_root_reset_end: called before the root usb port reset flag gets cleared
+  * @post_root_reset_end: called after the root usb port reset flag gets cleared
+  * @phy_callback: optional callback function for the phy to call
++>>>>>>> 8055555fc459 (usb: musb: core: Fix handling of the phy notifications)
   */
  struct musb_platform_ops {
 -
 -#define MUSB_DMA_UX500		BIT(6)
 -#define MUSB_DMA_CPPI41		BIT(5)
 -#define MUSB_DMA_CPPI		BIT(4)
 -#define MUSB_DMA_TUSB_OMAP	BIT(3)
 -#define MUSB_DMA_INVENTRA	BIT(2)
 -#define MUSB_IN_TUSB		BIT(1)
 -#define MUSB_INDEXED_EP		BIT(0)
 -	u32	quirks;
 -
  	int	(*init)(struct musb *musb);
  	int	(*exit)(struct musb *musb);
  
@@@ -213,6 -213,9 +219,12 @@@
  	int	(*adjust_channel_params)(struct dma_channel *channel,
  				u16 packet_sz, u8 *mode,
  				dma_addr_t *dma_addr, u32 *len);
++<<<<<<< HEAD
++=======
+ 	void	(*pre_root_reset_end)(struct musb *musb);
+ 	void	(*post_root_reset_end)(struct musb *musb);
+ 	void	(*phy_callback)(enum musb_vbus_id_status status);
++>>>>>>> 8055555fc459 (usb: musb: core: Fix handling of the phy notifications)
  };
  
  /*
diff --cc drivers/usb/musb/omap2430.c
index 628b93fe5ccc,bf05f807729f..000000000000
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@@ -36,8 -36,9 +36,14 @@@
  #include <linux/pm_runtime.h>
  #include <linux/err.h>
  #include <linux/delay.h>
++<<<<<<< HEAD
 +#include <linux/usb/musb-omap.h>
 +#include <linux/usb/omap_control_usb.h>
++=======
+ #include <linux/usb/musb.h>
+ #include <linux/phy/omap_control_phy.h>
+ #include <linux/of_platform.h>
++>>>>>>> 8055555fc459 (usb: musb: core: Fix handling of the phy notifications)
  
  #include "musb_core.h"
  #include "omap2430.h"
@@@ -394,12 -429,14 +399,12 @@@ static int omap2430_musb_init(struct mu
  
  	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
  
- 	if (glue->status != OMAP_MUSB_UNKNOWN)
+ 	if (glue->status != MUSB_UNKNOWN)
  		omap_musb_set_mailbox(glue);
  
 -	phy_init(musb->phy);
 -	phy_power_on(musb->phy);
 +	usb_phy_init(musb->xceiv);
  
  	pm_runtime_put_noidle(musb->controller);
 -	pm_runtime_put_noidle(glue->dev);
  	return 0;
  
  err1:
@@@ -507,29 -552,24 +514,34 @@@ static int omap2430_probe(struct platfo
  
  	glue->dev			= &pdev->dev;
  	glue->musb			= musb;
++<<<<<<< HEAD
 +	glue->status			= OMAP_MUSB_UNKNOWN;
++=======
+ 	glue->status			= MUSB_UNKNOWN;
+ 	glue->control_otghs = ERR_PTR(-ENODEV);
++>>>>>>> 8055555fc459 (usb: musb: core: Fix handling of the phy notifications)
  
  	if (np) {
 -		struct device_node *control_node;
 -		struct platform_device *control_pdev;
 -
  		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 -		if (!pdata)
 +		if (!pdata) {
 +			dev_err(&pdev->dev,
 +				"failed to allocate musb platfrom data\n");
  			goto err2;
 +		}
  
  		data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
 -		if (!data)
 +		if (!data) {
 +			dev_err(&pdev->dev,
 +				"failed to allocate musb board data\n");
  			goto err2;
 +		}
  
  		config = devm_kzalloc(&pdev->dev, sizeof(*config), GFP_KERNEL);
 -		if (!config)
 +		if (!config) {
 +			dev_err(&pdev->dev,
 +				"failed to allocate musb hdrc config\n");
  			goto err2;
 +		}
  
  		of_property_read_u32(np, "mode", (u32 *)&pdata->mode);
  		of_property_read_u32(np, "interface-type",
diff --cc drivers/usb/phy/phy-twl4030-usb.c
index 8f78d2d40722,4a3fc6e59f8e..000000000000
--- a/drivers/usb/phy/phy-twl4030-usb.c
+++ b/drivers/usb/phy/phy-twl4030-usb.c
@@@ -33,7 -32,9 +33,13 @@@
  #include <linux/io.h>
  #include <linux/delay.h>
  #include <linux/usb/otg.h>
++<<<<<<< HEAD:drivers/usb/phy/phy-twl4030-usb.c
 +#include <linux/usb/musb-omap.h>
++=======
+ #include <linux/phy/phy.h>
+ #include <linux/pm_runtime.h>
+ #include <linux/usb/musb.h>
++>>>>>>> 8055555fc459 (usb: musb: core: Fix handling of the phy notifications):drivers/phy/phy-twl4030-usb.c
  #include <linux/usb/ulpi.h>
  #include <linux/i2c/twl.h>
  #include <linux/regulator/consumer.h>
@@@ -143,6 -144,16 +149,19 @@@
  #define PMBR1				0x0D
  #define GPIO_USB_4PIN_ULPI_2430C	(3 << 0)
  
++<<<<<<< HEAD:drivers/usb/phy/phy-twl4030-usb.c
++=======
+ /*
+  * If VBUS is valid or ID is ground, then we know a
+  * cable is present and we need to be runtime-enabled
+  */
+ static inline bool cable_present(enum musb_vbus_id_status stat)
+ {
+ 	return stat == MUSB_VBUS_VALID ||
+ 		stat == MUSB_ID_GROUND;
+ }
+ 
++>>>>>>> 8055555fc459 (usb: musb: core: Fix handling of the phy notifications):drivers/phy/phy-twl4030-usb.c
  struct twl4030_usb {
  	struct usb_phy		phy;
  	struct device		*dev;
@@@ -159,10 -170,8 +178,10 @@@
  	enum twl4030_usb_mode	usb_mode;
  
  	int			irq;
- 	enum omap_musb_vbus_id_status linkstat;
+ 	enum musb_vbus_id_status linkstat;
  	bool			vbus_supplied;
 +	u8			asleep;
 +	bool			irq_enabled;
  
  	struct delayed_work	id_workaround_work;
  };
@@@ -551,9 -561,23 +570,29 @@@ static irqreturn_t twl4030_usb_irq(int 
  		 * USB_LINK_VBUS state.  musb_hdrc won't care until it
  		 * starts to handle softconnect right.
  		 */
++<<<<<<< HEAD:drivers/usb/phy/phy-twl4030-usb.c
 +		omap_musb_mailbox(status);
 +	}
 +	sysfs_notify(&twl->dev->kobj, NULL, "vbus");
++=======
+ 		if (cable_present(status)) {
+ 			pm_runtime_get_sync(twl->dev);
+ 		} else {
+ 			pm_runtime_mark_last_busy(twl->dev);
+ 			pm_runtime_put_autosuspend(twl->dev);
+ 		}
+ 		musb_mailbox(status);
+ 	}
+ 
+ 	/* don't schedule during sleep - irq works right then */
+ 	if (status == MUSB_ID_GROUND && pm_runtime_active(twl->dev)) {
+ 		cancel_delayed_work(&twl->id_workaround_work);
+ 		schedule_delayed_work(&twl->id_workaround_work, HZ);
+ 	}
+ 
+ 	if (irq)
+ 		sysfs_notify(&twl->dev->kobj, NULL, "vbus");
++>>>>>>> 8055555fc459 (usb: musb: core: Fix handling of the phy notifications):drivers/phy/phy-twl4030-usb.c
  
  	return IRQ_HANDLED;
  }
@@@ -675,8 -670,7 +714,12 @@@ static int twl4030_usb_probe(struct pla
  	twl->dev		= &pdev->dev;
  	twl->irq		= platform_get_irq(pdev, 0);
  	twl->vbus_supplied	= false;
++<<<<<<< HEAD:drivers/usb/phy/phy-twl4030-usb.c
 +	twl->asleep		= 1;
 +	twl->linkstat		= OMAP_MUSB_UNKNOWN;
++=======
+ 	twl->linkstat		= MUSB_UNKNOWN;
++>>>>>>> 8055555fc459 (usb: musb: core: Fix handling of the phy notifications):drivers/phy/phy-twl4030-usb.c
  
  	twl->phy.dev		= twl->dev;
  	twl->phy.label		= "twl4030";
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 5e488ace94f1..84a65ad75f0b 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -1622,6 +1622,23 @@ EXPORT_SYMBOL_GPL(musb_dma_completion);
 #define use_dma			0
 #endif
 
+static void (*musb_phy_callback)(enum musb_vbus_id_status status);
+
+/*
+ * musb_mailbox - optional phy notifier function
+ * @status phy state change
+ *
+ * Optionally gets called from the USB PHY. Note that the USB PHY must be
+ * disabled at the point the phy_callback is registered or unregistered.
+ */
+void musb_mailbox(enum musb_vbus_id_status status)
+{
+	if (musb_phy_callback)
+		musb_phy_callback(status);
+
+};
+EXPORT_SYMBOL_GPL(musb_mailbox);
+
 /*-------------------------------------------------------------------------*/
 
 static ssize_t
@@ -1890,6 +1907,9 @@ musb_init_controller(struct device *dev, int nIrq, void __iomem *ctrl)
 		musb->xceiv->io_ops = &musb_ulpi_access;
 	}
 
+	if (musb->ops->phy_callback)
+		musb_phy_callback = musb->ops->phy_callback;
+
 	pm_runtime_get_sync(musb->controller);
 
 #ifndef CONFIG_MUSB_PIO_ONLY
@@ -2038,6 +2058,7 @@ static int musb_remove(struct platform_device *pdev)
 	 */
 	musb_exit_debugfs(musb);
 	musb_shutdown(pdev);
+	musb_phy_callback = NULL;
 
 	musb_free(musb);
 	device_init_wakeup(dev, 0);
* Unmerged path drivers/usb/musb/musb_core.h
* Unmerged path drivers/usb/musb/omap2430.c
* Unmerged path drivers/usb/phy/phy-twl4030-usb.c
diff --git a/drivers/usb/phy/phy-twl6030-usb.c b/drivers/usb/phy/phy-twl6030-usb.c
index 9de7ada90a8b..046fa845b34c 100644
--- a/drivers/usb/phy/phy-twl6030-usb.c
+++ b/drivers/usb/phy/phy-twl6030-usb.c
@@ -25,7 +25,7 @@
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
-#include <linux/usb/musb-omap.h>
+#include <linux/usb/musb.h>
 #include <linux/usb/phy_companion.h>
 #include <linux/usb/omap_usb.h>
 #include <linux/i2c/twl.h>
@@ -101,7 +101,7 @@ struct twl6030_usb {
 
 	int			irq1;
 	int			irq2;
-	enum omap_musb_vbus_id_status linkstat;
+	enum musb_vbus_id_status linkstat;
 	u8			asleep;
 	bool			irq_enabled;
 	bool			vbus_enable;
@@ -188,13 +188,13 @@ static ssize_t twl6030_usb_vbus_show(struct device *dev,
 	spin_lock_irqsave(&twl->lock, flags);
 
 	switch (twl->linkstat) {
-	case OMAP_MUSB_VBUS_VALID:
+	case MUSB_VBUS_VALID:
 	       ret = snprintf(buf, PAGE_SIZE, "vbus\n");
 	       break;
-	case OMAP_MUSB_ID_GROUND:
+	case MUSB_ID_GROUND:
 	       ret = snprintf(buf, PAGE_SIZE, "id\n");
 	       break;
-	case OMAP_MUSB_VBUS_OFF:
+	case MUSB_VBUS_OFF:
 	       ret = snprintf(buf, PAGE_SIZE, "none\n");
 	       break;
 	default:
@@ -209,7 +209,7 @@ static DEVICE_ATTR(vbus, 0444, twl6030_usb_vbus_show, NULL);
 static irqreturn_t twl6030_usb_irq(int irq, void *_twl)
 {
 	struct twl6030_usb *twl = _twl;
-	enum omap_musb_vbus_id_status status = OMAP_MUSB_UNKNOWN;
+	enum musb_vbus_id_status status = MUSB_UNKNOWN;
 	u8 vbus_state, hw_state;
 	int ret;
 
@@ -224,14 +224,14 @@ static irqreturn_t twl6030_usb_irq(int irq, void *_twl)
 				dev_err(twl->dev, "Failed to enable usb3v3\n");
 
 			twl->asleep = 1;
-			status = OMAP_MUSB_VBUS_VALID;
+			status = MUSB_VBUS_VALID;
 			twl->linkstat = status;
-			omap_musb_mailbox(status);
+			musb_mailbox(status);
 		} else {
-			if (twl->linkstat != OMAP_MUSB_UNKNOWN) {
-				status = OMAP_MUSB_VBUS_OFF;
+			if (twl->linkstat != MUSB_UNKNOWN) {
+				status = MUSB_VBUS_OFF;
 				twl->linkstat = status;
-				omap_musb_mailbox(status);
+				musb_mailbox(status);
 				if (twl->asleep) {
 					regulator_disable(twl->usb3v3);
 					twl->asleep = 0;
@@ -247,7 +247,7 @@ static irqreturn_t twl6030_usb_irq(int irq, void *_twl)
 static irqreturn_t twl6030_usbotg_irq(int irq, void *_twl)
 {
 	struct twl6030_usb *twl = _twl;
-	enum omap_musb_vbus_id_status status = OMAP_MUSB_UNKNOWN;
+	enum musb_vbus_id_status status = MUSB_UNKNOWN;
 	u8 hw_state;
 	int ret;
 
@@ -261,9 +261,9 @@ static irqreturn_t twl6030_usbotg_irq(int irq, void *_twl)
 		twl->asleep = 1;
 		twl6030_writeb(twl, TWL_MODULE_USB, 0x1, USB_ID_INT_EN_HI_CLR);
 		twl6030_writeb(twl, TWL_MODULE_USB, 0x10, USB_ID_INT_EN_HI_SET);
-		status = OMAP_MUSB_ID_GROUND;
+		status = MUSB_ID_GROUND;
 		twl->linkstat = status;
-		omap_musb_mailbox(status);
+		musb_mailbox(status);
 	} else  {
 		twl6030_writeb(twl, TWL_MODULE_USB, 0x10, USB_ID_INT_EN_HI_CLR);
 		twl6030_writeb(twl, TWL_MODULE_USB, 0x1, USB_ID_INT_EN_HI_SET);
@@ -333,7 +333,7 @@ static int twl6030_usb_probe(struct platform_device *pdev)
 	twl->dev		= &pdev->dev;
 	twl->irq1		= platform_get_irq(pdev, 0);
 	twl->irq2		= platform_get_irq(pdev, 1);
-	twl->linkstat		= OMAP_MUSB_UNKNOWN;
+	twl->linkstat		= MUSB_UNKNOWN;
 
 	twl->comparator.set_vbus	= twl6030_set_vbus;
 	twl->comparator.start_srp	= twl6030_start_srp;
diff --git a/include/linux/usb/musb-omap.h b/include/linux/usb/musb-omap.h
deleted file mode 100644
index 7774c5986f07..000000000000
--- a/include/linux/usb/musb-omap.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2011-2012 by Texas Instruments
- *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
- */
-
-#ifndef __MUSB_OMAP_H__
-#define __MUSB_OMAP_H__
-
-enum omap_musb_vbus_id_status {
-	OMAP_MUSB_UNKNOWN = 0,
-	OMAP_MUSB_ID_GROUND,
-	OMAP_MUSB_ID_FLOAT,
-	OMAP_MUSB_VBUS_VALID,
-	OMAP_MUSB_VBUS_OFF,
-};
-
-#if (defined(CONFIG_USB_MUSB_OMAP2PLUS) || \
-				defined(CONFIG_USB_MUSB_OMAP2PLUS_MODULE))
-void omap_musb_mailbox(enum omap_musb_vbus_id_status status);
-#else
-static inline void omap_musb_mailbox(enum omap_musb_vbus_id_status status)
-{
-}
-#endif
-
-#endif	/* __MUSB_OMAP_H__ */
diff --git a/include/linux/usb/musb.h b/include/linux/usb/musb.h
index 053c26841cc3..60d0820e10ec 100644
--- a/include/linux/usb/musb.h
+++ b/include/linux/usb/musb.h
@@ -132,6 +132,21 @@ struct musb_hdrc_platform_data {
 	const void	*platform_ops;
 };
 
+enum musb_vbus_id_status {
+	MUSB_UNKNOWN = 0,
+	MUSB_ID_GROUND,
+	MUSB_ID_FLOAT,
+	MUSB_VBUS_VALID,
+	MUSB_VBUS_OFF,
+};
+
+#if IS_ENABLED(CONFIG_USB_MUSB_HDRC)
+void musb_mailbox(enum musb_vbus_id_status status);
+#else
+static inline void musb_mailbox(enum musb_vbus_id_status status)
+{
+}
+#endif
 
 /* TUSB 6010 support */
 
