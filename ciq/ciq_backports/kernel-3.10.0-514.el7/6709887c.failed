drm: make drm_atomic_set_mode_prop_for_crtc() more reliable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drm] make drm_atomic_set_mode_prop_for_crtc() more reliable (Rob Clark) [1348329 1349064]
Rebuild_FUZZ: 95.58%
commit-author Tomi Valkeinen <tomi.valkeinen@ti.com>
commit 6709887c448d1cff51b52d09763c7b834ea5f0be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6709887c.failed

drm_atomic_set_mode_prop_for_crtc() does not clear the state->mode, so
old data may be left there when a new mode is set, possibly causing odd
issues.

This patch improves the situation by always clearing the state->mode
first.

	Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
	Cc: stable@vger.kernel.org
	Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit 6709887c448d1cff51b52d09763c7b834ea5f0be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/drm_atomic.c
diff --cc drivers/gpu/drm/drm_atomic.c
index 6e3b78ee7d16,c204ef32df16..000000000000
--- a/drivers/gpu/drm/drm_atomic.c
+++ b/drivers/gpu/drm/drm_atomic.c
@@@ -231,6 -282,151 +231,154 @@@ drm_atomic_get_crtc_state(struct drm_at
  EXPORT_SYMBOL(drm_atomic_get_crtc_state);
  
  /**
++<<<<<<< HEAD
++=======
+  * drm_atomic_set_mode_for_crtc - set mode for CRTC
+  * @state: the CRTC whose incoming state to update
+  * @mode: kernel-internal mode to use for the CRTC, or NULL to disable
+  *
+  * Set a mode (originating from the kernel) on the desired CRTC state. Does
+  * not change any other state properties, including enable, active, or
+  * mode_changed.
+  *
+  * RETURNS:
+  * Zero on success, error code on failure. Cannot return -EDEADLK.
+  */
+ int drm_atomic_set_mode_for_crtc(struct drm_crtc_state *state,
+ 				 struct drm_display_mode *mode)
+ {
+ 	struct drm_mode_modeinfo umode;
+ 
+ 	/* Early return for no change. */
+ 	if (mode && memcmp(&state->mode, mode, sizeof(*mode)) == 0)
+ 		return 0;
+ 
+ 	drm_property_unreference_blob(state->mode_blob);
+ 	state->mode_blob = NULL;
+ 
+ 	if (mode) {
+ 		drm_mode_convert_to_umode(&umode, mode);
+ 		state->mode_blob =
+ 			drm_property_create_blob(state->crtc->dev,
+ 		                                 sizeof(umode),
+ 		                                 &umode);
+ 		if (IS_ERR(state->mode_blob))
+ 			return PTR_ERR(state->mode_blob);
+ 
+ 		drm_mode_copy(&state->mode, mode);
+ 		state->enable = true;
+ 		DRM_DEBUG_ATOMIC("Set [MODE:%s] for CRTC state %p\n",
+ 				 mode->name, state);
+ 	} else {
+ 		memset(&state->mode, 0, sizeof(state->mode));
+ 		state->enable = false;
+ 		DRM_DEBUG_ATOMIC("Set [NOMODE] for CRTC state %p\n",
+ 				 state);
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(drm_atomic_set_mode_for_crtc);
+ 
+ /**
+  * drm_atomic_set_mode_prop_for_crtc - set mode for CRTC
+  * @state: the CRTC whose incoming state to update
+  * @blob: pointer to blob property to use for mode
+  *
+  * Set a mode (originating from a blob property) on the desired CRTC state.
+  * This function will take a reference on the blob property for the CRTC state,
+  * and release the reference held on the state's existing mode property, if any
+  * was set.
+  *
+  * RETURNS:
+  * Zero on success, error code on failure. Cannot return -EDEADLK.
+  */
+ int drm_atomic_set_mode_prop_for_crtc(struct drm_crtc_state *state,
+                                       struct drm_property_blob *blob)
+ {
+ 	if (blob == state->mode_blob)
+ 		return 0;
+ 
+ 	drm_property_unreference_blob(state->mode_blob);
+ 	state->mode_blob = NULL;
+ 
+ 	memset(&state->mode, 0, sizeof(state->mode));
+ 
+ 	if (blob) {
+ 		if (blob->length != sizeof(struct drm_mode_modeinfo) ||
+ 		    drm_mode_convert_umode(&state->mode,
+ 		                           (const struct drm_mode_modeinfo *)
+ 		                            blob->data))
+ 			return -EINVAL;
+ 
+ 		state->mode_blob = drm_property_reference_blob(blob);
+ 		state->enable = true;
+ 		DRM_DEBUG_ATOMIC("Set [MODE:%s] for CRTC state %p\n",
+ 				 state->mode.name, state);
+ 	} else {
+ 		state->enable = false;
+ 		DRM_DEBUG_ATOMIC("Set [NOMODE] for CRTC state %p\n",
+ 				 state);
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(drm_atomic_set_mode_prop_for_crtc);
+ 
+ /**
+  * drm_atomic_replace_property_blob - replace a blob property
+  * @blob: a pointer to the member blob to be replaced
+  * @new_blob: the new blob to replace with
+  * @replaced: whether the blob has been replaced
+  *
+  * RETURNS:
+  * Zero on success, error code on failure
+  */
+ static void
+ drm_atomic_replace_property_blob(struct drm_property_blob **blob,
+ 				 struct drm_property_blob *new_blob,
+ 				 bool *replaced)
+ {
+ 	struct drm_property_blob *old_blob = *blob;
+ 
+ 	if (old_blob == new_blob)
+ 		return;
+ 
+ 	if (old_blob)
+ 		drm_property_unreference_blob(old_blob);
+ 	if (new_blob)
+ 		drm_property_reference_blob(new_blob);
+ 	*blob = new_blob;
+ 	*replaced = true;
+ 
+ 	return;
+ }
+ 
+ static int
+ drm_atomic_replace_property_blob_from_id(struct drm_crtc *crtc,
+ 					 struct drm_property_blob **blob,
+ 					 uint64_t blob_id,
+ 					 ssize_t expected_size,
+ 					 bool *replaced)
+ {
+ 	struct drm_device *dev = crtc->dev;
+ 	struct drm_property_blob *new_blob = NULL;
+ 
+ 	if (blob_id != 0) {
+ 		new_blob = drm_property_lookup_blob(dev, blob_id);
+ 		if (new_blob == NULL)
+ 			return -EINVAL;
+ 		if (expected_size > 0 && expected_size != new_blob->length)
+ 			return -EINVAL;
+ 	}
+ 
+ 	drm_atomic_replace_property_blob(blob, new_blob, replaced);
+ 
+ 	return 0;
+ }
+ 
+ /**
++>>>>>>> 6709887c448d (drm: make drm_atomic_set_mode_prop_for_crtc() more reliable)
   * drm_atomic_crtc_set_property - set property on CRTC
   * @crtc: the drm CRTC to set a property on
   * @state: the state object to update with the new property value
* Unmerged path drivers/gpu/drm/drm_atomic.c
