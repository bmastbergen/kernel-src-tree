x86/platform/UV: Build GAM reference tables

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] platform/uv: Build GAM reference tables (Frank Ramsay) [1276458]
Rebuild_FUZZ: 95.12%
commit-author Mike Travis <travis@sgi.com>
commit 6e27b91cf46834391c59062d3f26d277cc299f4b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6e27b91c.failed

An aspect of the UV4 system architecture changes involve changing the
way sockets, nodes, and pnodes are translated between one another.
Decode the information from the BIOS provided EFI system table to build
the needed conversion tables.

	Tested-by: Dimitri Sivanich <sivanich@sgi.com>
	Tested-by: John Estabrook <estabrook@sgi.com>
	Tested-by: Gary Kroening <gfk@sgi.com>
	Tested-by: Nathan Zimmer <nzimmer@sgi.com>
	Signed-off-by: Mike Travis <travis@sgi.com>
	Reviewed-by: Dimitri Sivanich <sivanich@sgi.com>
	Cc: Andrew Banman <abanman@sgi.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Len Brown <len.brown@intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Russ Anderson <rja@sgi.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/20160429215405.673495324@asylum.americas.sgi.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 6e27b91cf46834391c59062d3f26d277cc299f4b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/uv/uv_hub.h
#	arch/x86/kernel/apic/x2apic_uv_x.c
diff --cc arch/x86/include/asm/uv/uv_hub.h
index 74f8c4a9bc11,6900161e1684..000000000000
--- a/arch/x86/include/asm/uv/uv_hub.h
+++ b/arch/x86/include/asm/uv/uv_hub.h
@@@ -146,12 -147,19 +146,20 @@@ struct uv_scir_s 
   */
  struct uv_hub_info_s {
  	unsigned long		global_mmr_base;
 -	unsigned long		global_mmr_shift;
  	unsigned long		gpa_mask;
++<<<<<<< HEAD
 +	unsigned int		gnode_extra;
++=======
+ 	unsigned short		*socket_to_node;
+ 	unsigned short		*socket_to_pnode;
+ 	unsigned short		*pnode_to_socket;
+ 	unsigned short		min_socket;
+ 	unsigned short		min_pnode;
++>>>>>>> 6e27b91cf468 (x86/platform/UV: Build GAM reference tables)
  	unsigned char		hub_revision;
  	unsigned char		apic_pnode_shift;
 -	unsigned char		gpa_shift;
  	unsigned char		m_shift;
  	unsigned char		n_lshift;
 -	unsigned int		gnode_extra;
  	unsigned long		gnode_upper;
  	unsigned long		lowmem_remap_top;
  	unsigned long		lowmem_remap_base;
@@@ -444,18 -484,24 +452,33 @@@ static inline void *uv_pnode_offset_to_
  	return __va(((unsigned long)pnode << uv_hub_info->m_val) | offset);
  }
  
++<<<<<<< HEAD
 +
 +/*
 + * Extract a PNODE from an APICID (full apicid, not processor subset)
 + */
++=======
+ /* Convert socket to node */
+ static inline int uv_socket_to_node(int socket)
+ {
+ 	unsigned short *s2nid = uv_hub_info->socket_to_node;
+ 
+ 	return s2nid ? s2nid[socket - uv_hub_info->min_socket] : socket;
+ }
+ 
+ /* Extract/Convert a PNODE from an APICID (full apicid, not processor subset) */
++>>>>>>> 6e27b91cf468 (x86/platform/UV: Build GAM reference tables)
  static inline int uv_apicid_to_pnode(int apicid)
  {
- 	return (apicid >> uv_hub_info->apic_pnode_shift);
+ 	int pnode = apicid >> uv_hub_info->apic_pnode_shift;
+ 	unsigned short *s2pn = uv_hub_info->socket_to_pnode;
+ 
+ 	return s2pn ? s2pn[pnode - uv_hub_info->min_socket] : pnode;
  }
  
 -/* Convert an apicid to the socket number on the blade */
 +/*
 + * Convert an apicid to the socket number on the blade
 + */
  static inline int uv_apicid_to_socket(int apicid)
  {
  	if (is_uv1_hub())
diff --cc arch/x86/kernel/apic/x2apic_uv_x.c
index fd86a4f25c81,259c3dd889c6..000000000000
--- a/arch/x86/kernel/apic/x2apic_uv_x.c
+++ b/arch/x86/kernel/apic/x2apic_uv_x.c
@@@ -306,9 -301,25 +306,29 @@@ EXPORT_SYMBOL_GPL(uv_possible_blades)
  unsigned long sn_rtc_cycles_per_second;
  EXPORT_SYMBOL(sn_rtc_cycles_per_second);
  
++<<<<<<< HEAD
++=======
+ /* the following values are used for the per node hub info struct */
+ static __initdata unsigned short *_node_to_pnode;
+ static __initdata unsigned short _min_socket, _max_socket;
+ static __initdata unsigned short _min_pnode, _max_pnode, _gr_table_len;
+ static __initdata struct uv_gam_range_entry *uv_gre_table;
+ static __initdata struct uv_gam_parameters *uv_gp_table;
+ static __initdata unsigned short *_socket_to_node;
+ static __initdata unsigned short *_socket_to_pnode;
+ static __initdata unsigned short *_pnode_to_socket;
+ #define	SOCK_EMPTY	((unsigned short)~0)
+ 
+ extern int uv_hub_info_version(void)
+ {
+ 	return UV_HUB_INFO_VERSION;
+ }
+ EXPORT_SYMBOL(uv_hub_info_version);
+ 
++>>>>>>> 6e27b91cf468 (x86/platform/UV: Build GAM reference tables)
  static int uv_wakeup_secondary(int phys_apicid, unsigned long start_rip)
  {
 +#ifdef CONFIG_SMP
  	unsigned long val;
  	int pnode;
  
@@@ -999,6 -987,11 +1019,14 @@@ void __init uv_init_hub_info(struct uv_
  
  	hub_info->hub_revision = uv_hub_info->hub_revision;
  	hub_info->pnode_mask = uv_cpuid.pnode_mask;
++<<<<<<< HEAD
++=======
+ 	hub_info->min_pnode = _min_pnode;
+ 	hub_info->min_socket = _min_socket;
+ 	hub_info->pnode_to_socket = _pnode_to_socket;
+ 	hub_info->socket_to_node = _socket_to_node;
+ 	hub_info->socket_to_pnode = _socket_to_pnode;
++>>>>>>> 6e27b91cf468 (x86/platform/UV: Build GAM reference tables)
  	hub_info->gpa_mask = mn.m_val ?
  		(1UL << (mn.m_val + mn.n_val)) - 1 :
  		(1UL << uv_cpuid.gpa_shift) - 1;
@@@ -1030,11 -1037,278 +1058,142 @@@
  
  	pr_info("UV: gnode_upper:0x%lx gnode_extra:0x%x\n",
  		hub_info->gnode_upper, hub_info->gnode_extra);
 -}
 -
 -static void __init decode_gam_params(unsigned long ptr)
 -{
 -	uv_gp_table = (struct uv_gam_parameters *)ptr;
 -
 -	pr_info("UV: GAM Params...\n");
 -	pr_info("UV: mmr_base/shift:0x%llx/%d gru_base/shift:0x%llx/%d gpa_shift:%d\n",
 -		uv_gp_table->mmr_base, uv_gp_table->mmr_shift,
 -		uv_gp_table->gru_base, uv_gp_table->gru_shift,
 -		uv_gp_table->gpa_shift);
 -}
 -
 -static void __init decode_gam_rng_tbl(unsigned long ptr)
 -{
 -	struct uv_gam_range_entry *gre = (struct uv_gam_range_entry *)ptr;
 -	unsigned long lgre = 0;
 -	int index = 0;
 -	int sock_min = 999999, pnode_min = 99999;
 -	int sock_max = -1, pnode_max = -1;
 -
 -	uv_gre_table = gre;
 -	for (; gre->type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {
 -		if (!index) {
 -			pr_info("UV: GAM Range Table...\n");
 -			pr_info("UV:  # %20s %14s %5s %4s %5s %3s %2s %3s\n",
 -				"Range", "", "Size", "Type", "NASID",
 -				"SID", "PN", "PXM");
 -		}
 -		pr_info(
 -		"UV: %2d: 0x%014lx-0x%014lx %5luG %3d   %04x  %02x %02x %3d\n",
 -			index++,
 -			(unsigned long)lgre << UV_GAM_RANGE_SHFT,
 -			(unsigned long)gre->limit << UV_GAM_RANGE_SHFT,
 -			((unsigned long)(gre->limit - lgre)) >>
 -				(30 - UV_GAM_RANGE_SHFT), /* 64M -> 1G */
 -			gre->type, gre->nasid, gre->sockid,
 -			gre->pnode, gre->pxm);
 -
 -		lgre = gre->limit;
 -		if (sock_min > gre->sockid)
 -			sock_min = gre->sockid;
 -		if (sock_max < gre->sockid)
 -			sock_max = gre->sockid;
 -		if (pnode_min > gre->pnode)
 -			pnode_min = gre->pnode;
 -		if (pnode_max < gre->pnode)
 -			pnode_max = gre->pnode;
 -	}
 -
 -	_min_socket = sock_min;
 -	_max_socket = sock_max;
 -	_min_pnode = pnode_min;
 -	_max_pnode = pnode_max;
 -	_gr_table_len = index;
 -	pr_info(
 -	"UV: GRT: %d entries, sockets(min:%x,max:%x) pnodes(min:%x,max:%x)\n",
 -		index, _min_socket, _max_socket, _min_pnode, _max_pnode);
 -}
 -
 -static void __init decode_uv_systab(void)
 -{
 -	struct uv_systab *st;
 -	int i;
 -
 -	st = uv_systab;
 -	if ((!st || st->revision < UV_SYSTAB_VERSION_UV4) && !is_uv4_hub())
 -		return;
 -	if (st->revision != UV_SYSTAB_VERSION_UV4_LATEST) {
 -		pr_crit(
 -		"UV: BIOS UVsystab version(%x) mismatch, expecting(%x)\n",
 -			st->revision, UV_SYSTAB_VERSION_UV4_LATEST);
 -		BUG();
 -	}
 -
 -	for (i = 0; st->entry[i].type != UV_SYSTAB_TYPE_UNUSED; i++) {
 -		unsigned long ptr = st->entry[i].offset;
 -
 -		if (!ptr)
 -			continue;
 -
 -		ptr = ptr + (unsigned long)st;
  
 -		switch (st->entry[i].type) {
 -		case UV_SYSTAB_TYPE_GAM_PARAMS:
 -			decode_gam_params(ptr);
 -			break;
 +	pr_info("UV: global MMR base 0x%lx\n", hub_info->global_mmr_base);
  
 -		case UV_SYSTAB_TYPE_GAM_RNG_TBL:
 -			decode_gam_rng_tbl(ptr);
 -			break;
 -		}
 -	}
 -}
 -
 -/*
 - * Setup physical blade translations from UVH_NODE_PRESENT_TABLE
 - * .. NB: UVH_NODE_PRESENT_TABLE is going away,
 - * .. being replaced by GAM Range Table
 - */
 -static __init void boot_init_possible_blades(struct uv_hub_info_s *hub_info)
 -{
 -	size_t bytes;
 -	int blade, i, j, uv_pb = 0, num_nodes = num_possible_nodes();
 -
 -	pr_info("UV: NODE_PRESENT_DEPTH = %d\n", UVH_NODE_PRESENT_TABLE_DEPTH);
 -	for (i = 0; i < UVH_NODE_PRESENT_TABLE_DEPTH; i++) {
 -		unsigned long np;
 -
 -		np = uv_read_local_mmr(UVH_NODE_PRESENT_TABLE + i * 8);
 -		if (np)
 -			pr_info("UV: NODE_PRESENT(%d) = 0x%016lx\n", i, np);
 -
 -		uv_pb += hweight64(np);
 -	}
 -	if (uv_possible_blades != uv_pb)
 -		uv_possible_blades = uv_pb;
 -
 -	bytes = num_nodes * sizeof(_node_to_pnode[0]);
 -	_node_to_pnode = kmalloc(bytes, GFP_KERNEL);
 -	BUG_ON(!_node_to_pnode);
 -
 -	for (blade = 0, i = 0; i < UVH_NODE_PRESENT_TABLE_DEPTH; i++) {
 -		unsigned short pnode;
 -		unsigned long present =
 -			uv_read_local_mmr(UVH_NODE_PRESENT_TABLE + i * 8);
 -
 -		for (j = 0; j < 64; j++) {
 -			if (!test_bit(j, &present))
 -				continue;
 -			pnode = (i * 64 + j) & hub_info->pnode_mask;
 -			_node_to_pnode[blade++] = pnode;
 -		}
 -		if (blade > num_nodes) {
 -			pr_err("UV: blade count(%d) exceeds node count(%d)!\n",
 -				blade, num_nodes);
 -			BUG();
 -		}
 -	}
  }
  
+ static void __init build_socket_tables(void)
+ {
+ 	struct uv_gam_range_entry *gre = uv_gre_table;
+ 	int num, nump;
+ 	int cpu, i, lnid;
+ 	int minsock = _min_socket;
+ 	int maxsock = _max_socket;
+ 	int minpnode = _min_pnode;
+ 	int maxpnode = _max_pnode;
+ 	size_t bytes;
+ 
+ 	if (!gre) {
+ 		if (is_uv1_hub() || is_uv2_hub() || is_uv3_hub()) {
+ 			pr_info("UV: No UVsystab socket table, ignoring\n");
+ 			return;		/* not required */
+ 		}
+ 		pr_crit(
+ 		"UV: Error: UVsystab address translations not available!\n");
+ 		BUG();
+ 	}
+ 
+ 	/* build socket id -> node id, pnode */
+ 	num = maxsock - minsock + 1;
+ 	bytes = num * sizeof(_socket_to_node[0]);
+ 	_socket_to_node = kmalloc(bytes, GFP_KERNEL);
+ 	_socket_to_pnode = kmalloc(bytes, GFP_KERNEL);
+ 
+ 	nump = maxpnode - minpnode + 1;
+ 	bytes = nump * sizeof(_pnode_to_socket[0]);
+ 	_pnode_to_socket = kmalloc(bytes, GFP_KERNEL);
+ 	BUG_ON(!_socket_to_node || !_socket_to_pnode || !_pnode_to_socket);
+ 
+ 	for (i = 0; i < num; i++)
+ 		_socket_to_node[i] = _socket_to_pnode[i] = SOCK_EMPTY;
+ 
+ 	for (i = 0; i < nump; i++)
+ 		_pnode_to_socket[i] = SOCK_EMPTY;
+ 
+ 	/* fill in pnode/node/addr conversion list values */
+ 	pr_info("UV: GAM Building socket/pnode/pxm conversion tables\n");
+ 	for (; gre->type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {
+ 		if (gre->type == UV_GAM_RANGE_TYPE_HOLE)
+ 			continue;
+ 		i = gre->sockid - minsock;
+ 		if (_socket_to_pnode[i] != SOCK_EMPTY)
+ 			continue;	/* duplicate */
+ 		_socket_to_pnode[i] = gre->pnode;
+ 		_socket_to_node[i] = gre->pxm;
+ 
+ 		i = gre->pnode - minpnode;
+ 		_pnode_to_socket[i] = gre->sockid;
+ 
+ 		pr_info(
+ 		"UV: sid:%02x type:%d nasid:%04x pn:%02x pxm:%2d pn2s:%2x\n",
+ 			gre->sockid, gre->type, gre->nasid,
+ 			_socket_to_pnode[gre->sockid - minsock],
+ 			_socket_to_node[gre->sockid - minsock],
+ 			_pnode_to_socket[gre->pnode - minpnode]);
+ 	}
+ 
+ 	/* check socket -> node values */
+ 	lnid = -1;
+ 	for_each_present_cpu(cpu) {
+ 		int nid = cpu_to_node(cpu);
+ 		int apicid, sockid;
+ 
+ 		if (lnid == nid)
+ 			continue;
+ 		lnid = nid;
+ 		apicid = per_cpu(x86_cpu_to_apicid, cpu);
+ 		sockid = apicid >> uv_cpuid.socketid_shift;
+ 		i = sockid - minsock;
+ 
+ 		if (nid != _socket_to_node[i]) {
+ 			pr_warn(
+ 			"UV: %02x: type:%d socket:%02x PXM:%02x != node:%2d\n",
+ 				i, sockid, gre->type, _socket_to_node[i], nid);
+ 			_socket_to_node[i] = nid;
+ 		}
+ 	}
+ 
+ 	/* Setup physical blade to pnode translation from GAM Range Table */
+ 	bytes = num_possible_nodes() * sizeof(_node_to_pnode[0]);
+ 	_node_to_pnode = kmalloc(bytes, GFP_KERNEL);
+ 	BUG_ON(!_node_to_pnode);
+ 
+ 	for (lnid = 0; lnid < num_possible_nodes(); lnid++) {
+ 		unsigned short sockid;
+ 
+ 		for (sockid = minsock; sockid <= maxsock; sockid++) {
+ 			if (lnid == _socket_to_node[sockid - minsock]) {
+ 				_node_to_pnode[lnid] =
+ 					_socket_to_pnode[sockid - minsock];
+ 				break;
+ 			}
+ 		}
+ 		if (sockid > maxsock) {
+ 			pr_err("UV: socket for node %d not found!\n", lnid);
+ 			BUG();
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * If socket id == pnode or socket id == node for all nodes,
+ 	 *   system runs faster by removing corresponding conversion table.
+ 	 */
+ 	pr_info("UV: Checking socket->node/pnode for identity maps\n");
+ 	if (minsock == 0) {
+ 		for (i = 0; i < num; i++)
+ 			if (_socket_to_node[i] == SOCK_EMPTY ||
+ 				i != _socket_to_node[i])
+ 				break;
+ 		if (i >= num) {
+ 			kfree(_socket_to_node);
+ 			_socket_to_node = NULL;
+ 			pr_info("UV: 1:1 socket_to_node table removed\n");
+ 		}
+ 	}
+ 	if (minsock == minpnode) {
+ 		for (i = 0; i < num; i++)
+ 			if (_socket_to_pnode[i] != SOCK_EMPTY &&
+ 				_socket_to_pnode[i] != i + minpnode)
+ 				break;
+ 		if (i >= num) {
+ 			kfree(_socket_to_pnode);
+ 			_socket_to_pnode = NULL;
+ 			pr_info("UV: 1:1 socket_to_pnode table removed\n");
+ 		}
+ 	}
+ }
+ 
  void __init uv_system_init(void)
  {
  	struct uv_hub_info_s hub_info = {0};
@@@ -1050,13 -1324,18 +1209,23 @@@
  		return;
  	}
  	pr_info("UV: Found %s hub\n", hub);
 +	map_low_mmrs();
  
++<<<<<<< HEAD
++=======
+ 	/* We now only need to map the MMRs on UV1 */
+ 	if (is_uv1_hub())
+ 		map_low_mmrs();
+ 
+ 	uv_bios_init();			/* get uv_systab for decoding */
+ 	decode_uv_systab();
+ 	build_socket_tables();
++>>>>>>> 6e27b91cf468 (x86/platform/UV: Build GAM reference tables)
  	uv_init_hub_info(&hub_info);
 -	uv_possible_blades = num_possible_nodes();
 -	if (!_node_to_pnode)
 -		boot_init_possible_blades(&hub_info);
 +
 +	for(i = 0; i < UVH_NODE_PRESENT_TABLE_DEPTH; i++)
 +		uv_possible_blades +=
 +		  hweight64(uv_read_local_mmr( UVH_NODE_PRESENT_TABLE + i * 8));
  
  	/* uv_num_possible_blades() is really the hub count */
  	pr_info("UV: Found %d hubs, %d nodes, %d cpus\n",
* Unmerged path arch/x86/include/asm/uv/uv_hub.h
* Unmerged path arch/x86/kernel/apic/x2apic_uv_x.c
