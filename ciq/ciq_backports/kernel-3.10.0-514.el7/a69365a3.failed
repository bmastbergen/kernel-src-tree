RDS: IB: create struct rds_ib_fmr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author santosh.shilimkar@oracle.com <santosh.shilimkar@oracle.com>
commit a69365a39cd35d0ad11be7d4a896b2f76a8fde44
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a69365a3.failed

Keep fmr related filed in its own struct. Fastreg MR structure
will be added to the union.

	Signed-off-by: Santosh Shilimkar <ssantosh@kernel.org>
	Signed-off-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a69365a39cd35d0ad11be7d4a896b2f76a8fde44)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rds/ib_fmr.c
#	net/rds/ib_mr.h
* Unmerged path net/rds/ib_fmr.c
* Unmerged path net/rds/ib_mr.h
* Unmerged path net/rds/ib_fmr.c
* Unmerged path net/rds/ib_mr.h
diff --git a/net/rds/ib_rdma.c b/net/rds/ib_rdma.c
index 676225d1748c..c0e6913318fe 100644
--- a/net/rds/ib_rdma.c
+++ b/net/rds/ib_rdma.c
@@ -627,6 +627,7 @@ static int rds_ib_flush_mr_pool(struct rds_ib_mr_pool *pool,
 				int free_all, struct rds_ib_mr **ibmr_ret)
 {
 	struct rds_ib_mr *ibmr, *next;
+	struct rds_ib_fmr *fmr;
 	struct llist_node *clean_nodes;
 	struct llist_node *clean_tail;
 	LIST_HEAD(unmap_list);
@@ -688,8 +689,10 @@ static int rds_ib_flush_mr_pool(struct rds_ib_mr_pool *pool,
 		goto out;
 
 	/* String all ib_mr's onto one list and hand them to ib_unmap_fmr */
-	list_for_each_entry(ibmr, &unmap_list, unmap_list)
-		list_add(&ibmr->fmr->list, &fmr_list);
+	list_for_each_entry(ibmr, &unmap_list, unmap_list) {
+		fmr = &ibmr->u.fmr;
+		list_add(&fmr->fmr->list, &fmr_list);
+	}
 
 	ret = ib_unmap_fmr(&fmr_list);
 	if (ret)
@@ -698,6 +701,7 @@ static int rds_ib_flush_mr_pool(struct rds_ib_mr_pool *pool,
 	/* Now we can destroy the DMA mapping and unpin any pages */
 	list_for_each_entry_safe(ibmr, next, &unmap_list, unmap_list) {
 		unpinned += ibmr->sg_len;
+		fmr = &ibmr->u.fmr;
 		__rds_ib_teardown_mr(ibmr);
 		if (nfreed < free_goal ||
 		    ibmr->remap_count >= pool->fmr_attr.max_maps) {
@@ -706,7 +710,7 @@ static int rds_ib_flush_mr_pool(struct rds_ib_mr_pool *pool,
 			else
 				rds_ib_stats_inc(s_ib_rdma_mr_1m_free);
 			list_del(&ibmr->unmap_list);
-			ib_dealloc_fmr(ibmr->fmr);
+			ib_dealloc_fmr(fmr->fmr);
 			kfree(ibmr);
 			nfreed++;
 		}
@@ -810,6 +814,7 @@ void *rds_ib_get_mr(struct scatterlist *sg, unsigned long nents,
 {
 	struct rds_ib_device *rds_ibdev;
 	struct rds_ib_mr *ibmr = NULL;
+	struct rds_ib_fmr *fmr;
 	int ret;
 
 	rds_ibdev = rds_ib_get_device(rs->rs_bound_addr);
@@ -829,9 +834,10 @@ void *rds_ib_get_mr(struct scatterlist *sg, unsigned long nents,
 		return ibmr;
 	}
 
+	fmr = &ibmr->u.fmr;
 	ret = rds_ib_map_fmr(rds_ibdev, ibmr, sg, nents);
 	if (ret == 0)
-		*key_ret = ibmr->fmr->rkey;
+		*key_ret = fmr->fmr->rkey;
 	else
 		printk(KERN_WARNING "RDS/IB: map_fmr failed (errno=%d)\n", ret);
 
