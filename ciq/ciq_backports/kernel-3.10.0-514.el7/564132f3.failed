perf hists: Properly release format fields

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 564132f3116cf376fdc04b2380e621f35efbb6c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/564132f3.failed

With multiple list holding format entries, we need the support properly
releasing format output/sort fields.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1453109064-1026-12-git-send-email-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 564132f3116cf376fdc04b2380e621f35efbb6c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/hist.h
#	tools/perf/util/sort.c
diff --cc tools/perf/util/hist.h
index 09ef88f97433,f3bcf2d38733..000000000000
--- a/tools/perf/util/hist.h
+++ b/tools/perf/util/hist.h
@@@ -209,6 -215,8 +209,11 @@@ struct perf_hpp_fmt 
  			    struct hist_entry *a, struct hist_entry *b);
  	int64_t (*sort)(struct perf_hpp_fmt *fmt,
  			struct hist_entry *a, struct hist_entry *b);
++<<<<<<< HEAD
++=======
+ 	bool (*equal)(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b);
+ 	void (*free)(struct perf_hpp_fmt *fmt);
++>>>>>>> 564132f3116c (perf hists: Properly release format fields)
  
  	struct list_head list;
  	struct list_head sort_list;
diff --cc tools/perf/util/sort.c
index cb6856b79208,b5389a54356d..000000000000
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@@ -1451,6 -1526,33 +1451,36 @@@ static int64_t __sort__hpp_sort(struct 
  	return sort_fn(a, b);
  }
  
++<<<<<<< HEAD
++=======
+ bool perf_hpp__is_sort_entry(struct perf_hpp_fmt *format)
+ {
+ 	return format->header == __sort__hpp_header;
+ }
+ 
+ static bool __sort__hpp_equal(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b)
+ {
+ 	struct hpp_sort_entry *hse_a;
+ 	struct hpp_sort_entry *hse_b;
+ 
+ 	if (!perf_hpp__is_sort_entry(a) || !perf_hpp__is_sort_entry(b))
+ 		return false;
+ 
+ 	hse_a = container_of(a, struct hpp_sort_entry, hpp);
+ 	hse_b = container_of(b, struct hpp_sort_entry, hpp);
+ 
+ 	return hse_a->se == hse_b->se;
+ }
+ 
+ static void hse_free(struct perf_hpp_fmt *fmt)
+ {
+ 	struct hpp_sort_entry *hse;
+ 
+ 	hse = container_of(fmt, struct hpp_sort_entry, hpp);
+ 	free(hse);
+ }
+ 
++>>>>>>> 564132f3116c (perf hists: Properly release format fields)
  static struct hpp_sort_entry *
  __sort_dimension__alloc_hpp(struct sort_dimension *sd)
  {
@@@ -1472,6 -1574,8 +1502,11 @@@
  	hse->hpp.cmp = __sort__hpp_cmp;
  	hse->hpp.collapse = __sort__hpp_collapse;
  	hse->hpp.sort = __sort__hpp_sort;
++<<<<<<< HEAD
++=======
+ 	hse->hpp.equal = __sort__hpp_equal;
+ 	hse->hpp.free = hse_free;
++>>>>>>> 564132f3116c (perf hists: Properly release format fields)
  
  	INIT_LIST_HEAD(&hse->hpp.list);
  	INIT_LIST_HEAD(&hse->hpp.sort_list);
@@@ -1482,9 -1586,23 +1517,29 @@@
  	return hse;
  }
  
++<<<<<<< HEAD
 +bool perf_hpp__is_sort_entry(struct perf_hpp_fmt *format)
 +{
 +	return format->header == __sort__hpp_header;
++=======
+ static void hpp_free(struct perf_hpp_fmt *fmt)
+ {
+ 	free(fmt);
+ }
+ 
+ static struct perf_hpp_fmt *__hpp_dimension__alloc_hpp(struct hpp_dimension *hd)
+ {
+ 	struct perf_hpp_fmt *fmt;
+ 
+ 	fmt = memdup(hd->fmt, sizeof(*fmt));
+ 	if (fmt) {
+ 		INIT_LIST_HEAD(&fmt->list);
+ 		INIT_LIST_HEAD(&fmt->sort_list);
+ 		fmt->free = hpp_free;
+ 	}
+ 
+ 	return fmt;
++>>>>>>> 564132f3116c (perf hists: Properly release format fields)
  }
  
  static int __sort_dimension__add_hpp_sort(struct sort_dimension *sd)
@@@ -1716,6 -1828,19 +1771,22 @@@ static int64_t __sort__hde_cmp(struct p
  	return memcmp(a->raw_data + offset, b->raw_data + offset, size);
  }
  
++<<<<<<< HEAD
++=======
+ bool perf_hpp__is_dynamic_entry(struct perf_hpp_fmt *fmt)
+ {
+ 	return fmt->cmp == __sort__hde_cmp;
+ }
+ 
+ static void hde_free(struct perf_hpp_fmt *fmt)
+ {
+ 	struct hpp_dynamic_entry *hde;
+ 
+ 	hde = container_of(fmt, struct hpp_dynamic_entry, hpp);
+ 	free(hde);
+ }
+ 
++>>>>>>> 564132f3116c (perf hists: Properly release format fields)
  static struct hpp_dynamic_entry *
  __alloc_dynamic_entry(struct perf_evsel *evsel, struct format_field *field)
  {
diff --git a/tools/perf/ui/hist.c b/tools/perf/ui/hist.c
index 76605c161829..113a98ef982e 100644
--- a/tools/perf/ui/hist.c
+++ b/tools/perf/ui/hist.c
@@ -586,6 +586,12 @@ next:
 	}
 }
 
+static void fmt_free(struct perf_hpp_fmt *fmt)
+{
+	if (fmt->free)
+		fmt->free(fmt);
+}
+
 void perf_hpp__reset_output_field(void)
 {
 	struct perf_hpp_fmt *fmt, *tmp;
@@ -594,12 +600,14 @@ void perf_hpp__reset_output_field(void)
 	perf_hpp__for_each_format_safe(fmt, tmp) {
 		list_del_init(&fmt->list);
 		list_del_init(&fmt->sort_list);
+		fmt_free(fmt);
 	}
 
 	/* reset sort keys */
 	perf_hpp__for_each_sort_list_safe(fmt, tmp) {
 		list_del_init(&fmt->list);
 		list_del_init(&fmt->sort_list);
+		fmt_free(fmt);
 	}
 }
 
* Unmerged path tools/perf/util/hist.h
* Unmerged path tools/perf/util/sort.c
