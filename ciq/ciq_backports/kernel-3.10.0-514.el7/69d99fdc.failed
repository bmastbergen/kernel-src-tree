mmc: dw_mmc: Add IDMAC 64-bit address mode support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Prabu Thangamuthu <Prabu.T@synopsys.com>
commit 69d99fdcfd7815dfb2318f0777a46181d5bf42dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/69d99fdc.failed

Synopsys DW_MMC IP core supports Internal DMA Controller with 64-bit address mode from IP version 2.70a onwards.
Updated the driver to support IDMAC 64-bit addressing mode.

	Signed-off-by: Prabu Thangamuthu <prabu.t@synopsys.com>
	Reviewed-by: Alim Akhtar <alim.akhtar@samsung.com>
	Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 69d99fdcfd7815dfb2318f0777a46181d5bf42dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/dw_mmc.c
diff --cc drivers/mmc/host/dw_mmc.c
index 1add727a3cc5,5a37c33879a1..000000000000
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@@ -50,7 -52,33 +50,33 @@@
  #define DW_MCI_RECV_STATUS	2
  #define DW_MCI_DMA_THRESHOLD	16
  
 -#define DW_MCI_FREQ_MAX	200000000	/* unit: HZ */
 -#define DW_MCI_FREQ_MIN	400000		/* unit: HZ */
 -
  #ifdef CONFIG_MMC_DW_IDMAC
++<<<<<<< HEAD
++=======
+ #define IDMAC_INT_CLR		(SDMMC_IDMAC_INT_AI | SDMMC_IDMAC_INT_NI | \
+ 				 SDMMC_IDMAC_INT_CES | SDMMC_IDMAC_INT_DU | \
+ 				 SDMMC_IDMAC_INT_FBE | SDMMC_IDMAC_INT_RI | \
+ 				 SDMMC_IDMAC_INT_TI)
+ 
+ struct idmac_desc_64addr {
+ 	u32		des0;	/* Control Descriptor */
+ 
+ 	u32		des1;	/* Reserved */
+ 
+ 	u32		des2;	/*Buffer sizes */
+ #define IDMAC_64ADDR_SET_BUFFER1_SIZE(d, s) \
+ 	((d)->des2 = ((d)->des2 & 0x03ffe000) | ((s) & 0x1fff))
+ 
+ 	u32		des3;	/* Reserved */
+ 
+ 	u32		des4;	/* Lower 32-bits of Buffer Address Pointer 1*/
+ 	u32		des5;	/* Upper 32-bits of Buffer Address Pointer 1*/
+ 
+ 	u32		des6;	/* Lower 32-bits of Next Descriptor Address */
+ 	u32		des7;	/* Upper 32-bits of Next Descriptor Address */
+ };
+ 
++>>>>>>> 69d99fdcfd78 (mmc: dw_mmc: Add IDMAC 64-bit address mode support)
  struct idmac_desc {
  	u32		des0;	/* Control Descriptor */
  #define IDMAC_DES0_DIC	BIT(1)
@@@ -416,28 -524,71 +478,77 @@@ static void dw_mci_idmac_start_dma(stru
  
  static int dw_mci_idmac_init(struct dw_mci *host)
  {
- 	struct idmac_desc *p;
  	int i;
  
- 	/* Number of descriptors in the ring buffer */
- 	host->ring_size = PAGE_SIZE / sizeof(struct idmac_desc);
+ 	if (host->dma_64bit_address == 1) {
+ 		struct idmac_desc_64addr *p;
+ 		/* Number of descriptors in the ring buffer */
+ 		host->ring_size = PAGE_SIZE / sizeof(struct idmac_desc_64addr);
+ 
+ 		/* Forward link the descriptor list */
+ 		for (i = 0, p = host->sg_cpu; i < host->ring_size - 1;
+ 								i++, p++) {
+ 			p->des6 = (host->sg_dma +
+ 					(sizeof(struct idmac_desc_64addr) *
+ 							(i + 1))) & 0xffffffff;
+ 
+ 			p->des7 = (u64)(host->sg_dma +
+ 					(sizeof(struct idmac_desc_64addr) *
+ 							(i + 1))) >> 32;
+ 			/* Initialize reserved and buffer size fields to "0" */
+ 			p->des1 = 0;
+ 			p->des2 = 0;
+ 			p->des3 = 0;
+ 		}
  
- 	/* Forward link the descriptor list */
- 	for (i = 0, p = host->sg_cpu; i < host->ring_size - 1; i++, p++)
- 		p->des3 = host->sg_dma + (sizeof(struct idmac_desc) * (i + 1));
+ 		/* Set the last descriptor as the end-of-ring descriptor */
+ 		p->des6 = host->sg_dma & 0xffffffff;
+ 		p->des7 = (u64)host->sg_dma >> 32;
+ 		p->des0 = IDMAC_DES0_ER;
  
- 	/* Set the last descriptor as the end-of-ring descriptor */
- 	p->des3 = host->sg_dma;
- 	p->des0 = IDMAC_DES0_ER;
+ 	} else {
+ 		struct idmac_desc *p;
+ 		/* Number of descriptors in the ring buffer */
+ 		host->ring_size = PAGE_SIZE / sizeof(struct idmac_desc);
+ 
+ 		/* Forward link the descriptor list */
+ 		for (i = 0, p = host->sg_cpu; i < host->ring_size - 1; i++, p++)
+ 			p->des3 = host->sg_dma + (sizeof(struct idmac_desc) *
+ 								(i + 1));
+ 
+ 		/* Set the last descriptor as the end-of-ring descriptor */
+ 		p->des3 = host->sg_dma;
+ 		p->des0 = IDMAC_DES0_ER;
+ 	}
  
 -	dw_mci_idmac_reset(host);
 +	mci_writel(host, BMOD, SDMMC_IDMAC_SWRESET);
  
++<<<<<<< HEAD
 +	/* Mask out interrupts - get Tx & Rx complete only */
 +	mci_writel(host, IDINTEN, SDMMC_IDMAC_INT_NI | SDMMC_IDMAC_INT_RI |
 +		   SDMMC_IDMAC_INT_TI);
++=======
+ 	if (host->dma_64bit_address == 1) {
+ 		/* Mask out interrupts - get Tx & Rx complete only */
+ 		mci_writel(host, IDSTS64, IDMAC_INT_CLR);
+ 		mci_writel(host, IDINTEN64, SDMMC_IDMAC_INT_NI |
+ 				SDMMC_IDMAC_INT_RI | SDMMC_IDMAC_INT_TI);
+ 
+ 		/* Set the descriptor base address */
+ 		mci_writel(host, DBADDRL, host->sg_dma & 0xffffffff);
+ 		mci_writel(host, DBADDRU, (u64)host->sg_dma >> 32);
+ 
+ 	} else {
+ 		/* Mask out interrupts - get Tx & Rx complete only */
+ 		mci_writel(host, IDSTS, IDMAC_INT_CLR);
+ 		mci_writel(host, IDINTEN, SDMMC_IDMAC_INT_NI |
+ 				SDMMC_IDMAC_INT_RI | SDMMC_IDMAC_INT_TI);
+ 
+ 		/* Set the descriptor base address */
+ 		mci_writel(host, DBADDR, host->sg_dma);
+ 	}
++>>>>>>> 69d99fdcfd78 (mmc: dw_mmc: Add IDMAC 64-bit address mode support)
  
- 	/* Set the descriptor base address */
- 	mci_writel(host, DBADDR, host->sg_dma);
  	return 0;
  }
  
* Unmerged path drivers/mmc/host/dw_mmc.c
diff --git a/drivers/mmc/host/dw_mmc.h b/drivers/mmc/host/dw_mmc.h
index f894414bb248..c2d46dee8718 100644
--- a/drivers/mmc/host/dw_mmc.h
+++ b/drivers/mmc/host/dw_mmc.h
@@ -55,6 +55,17 @@
 #define SDMMC_BUFADDR		0x098
 #define SDMMC_CDTHRCTL		0x100
 #define SDMMC_DATA(x)		(x)
+/*
+* Registers to support idmac 64-bit address mode
+*/
+#define SDMMC_DBADDRL		0x088
+#define SDMMC_DBADDRU		0x08c
+#define SDMMC_IDSTS64		0x090
+#define SDMMC_IDINTEN64		0x094
+#define SDMMC_DSCADDRL		0x098
+#define SDMMC_DSCADDRU		0x09c
+#define SDMMC_BUFADDRL		0x0A0
+#define SDMMC_BUFADDRU		0x0A4
 
 /*
  * Data offset is difference according to Version
diff --git a/include/linux/mmc/dw_mmc.h b/include/linux/mmc/dw_mmc.h
index a578603b514c..4238d031b201 100644
--- a/include/linux/mmc/dw_mmc.h
+++ b/include/linux/mmc/dw_mmc.h
@@ -51,6 +51,7 @@ struct mmc_data;
  *	transfer is in progress.
  * @use_dma: Whether DMA channel is initialized or not.
  * @using_dma: Whether DMA is in use for the current transfer.
+ * @dma_64bit_address: Whether DMA supports 64-bit address mode or not.
  * @sg_dma: Bus address of DMA buffer.
  * @sg_cpu: Virtual address of DMA buffer.
  * @dma_ops: Pointer to platform-specific DMA callbacks.
@@ -136,6 +137,7 @@ struct dw_mci {
 	/* DMA interface members*/
 	int			use_dma;
 	int			using_dma;
+	int			dma_64bit_address;
 
 	dma_addr_t		sg_dma;
 	void			*sg_cpu;
