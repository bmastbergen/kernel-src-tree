mei: add mei_me_cl_by_uuid_id function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit d880f3294d0576e79dfab4e2cd5a2eb62fe188f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d880f329.failed

When handling dynamic clients there might be a race
scenario in which two me clients with the same me
address would be linked in the me clients list,
therefore we need to search by both uuid and me address.

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit d880f3294d0576e79dfab4e2cd5a2eb62fe188f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/amthif.c
#	drivers/misc/mei/bus.c
#	drivers/misc/mei/client.c
#	drivers/misc/mei/client.h
#	drivers/misc/mei/main.c
#	drivers/misc/mei/nfc.c
#	drivers/misc/mei/wd.c
diff --cc drivers/misc/mei/amthif.c
index 48cf2935c66b,4114758cd1ce..000000000000
--- a/drivers/misc/mei/amthif.c
+++ b/drivers/misc/mei/amthif.c
@@@ -83,7 -82,8 +83,12 @@@ int mei_amthif_host_init(struct mei_dev
  		return -ENOTTY;
  	}
  
++<<<<<<< HEAD
 +	cl->me_client_id = dev->me_clients[i].client_id;
++=======
+ 	cl->me_client_id = me_cl->client_id;
+ 	cl->cl_uuid = me_cl->props.protocol_name;
++>>>>>>> d880f3294d05 (mei: add mei_me_cl_by_uuid_id function)
  
  	/* Assign iamthif_mtu to the value received from ME  */
  
diff --cc drivers/misc/mei/bus.c
index bac5d49667ff,09dad2df7aae..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -242,12 -242,12 +242,18 @@@ static int ___mei_cl_send(struct mei_c
  		return -ENODEV;
  
  	/* Check if we have an ME client device */
++<<<<<<< HEAD
 +	id = mei_me_cl_by_id(dev, cl->me_client_id);
 +	if (id < 0)
 +		return id;
++=======
+ 	me_cl = mei_me_cl_by_uuid_id(dev, &cl->cl_uuid, cl->me_client_id);
+ 	if (!me_cl)
+ 		return -ENOTTY;
++>>>>>>> d880f3294d05 (mei: add mei_me_cl_by_uuid_id function)
  
 -	if (length > me_cl->props.max_msg_length)
 -		return -EFBIG;
 +	if (length > dev->me_clients[id].props.max_msg_length)
 +		return -EINVAL;
  
  	cb = mei_io_cb_init(cl, NULL);
  	if (!cb)
diff --cc drivers/misc/mei/client.c
index 3be58ecdef41,1a4dafb77205..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -56,18 -55,51 +56,58 @@@ int mei_me_cl_by_uuid(const struct mei_
   *
   * Locking: called under "dev->device_lock" lock
   *
 - * returns me client or NULL if not found
 + * returns index on success, -ENOENT on failure.
   */
  
 -struct mei_me_client *mei_me_cl_by_id(struct mei_device *dev, u8 client_id)
 +int mei_me_cl_by_id(struct mei_device *dev, u8 client_id)
  {
 +	int i;
  
 -	struct mei_me_client *me_cl;
 +	for (i = 0; i < dev->me_clients_num; i++)
 +		if (dev->me_clients[i].client_id == client_id)
 +			return i;
  
++<<<<<<< HEAD
 +	return -ENOENT;
++=======
+ 	list_for_each_entry(me_cl, &dev->me_clients, list)
+ 		if (me_cl->client_id == client_id)
+ 			return me_cl;
+ 	return NULL;
+ }
+ 
+ struct mei_me_client *mei_me_cl_by_uuid_id(struct mei_device *dev,
+ 					   const uuid_le *uuid, u8 client_id)
+ {
+ 	struct mei_me_client *me_cl;
+ 
+ 	list_for_each_entry(me_cl, &dev->me_clients, list)
+ 		if (uuid_le_cmp(*uuid, me_cl->props.protocol_name) == 0 &&
+ 		    me_cl->client_id == client_id)
+ 			return me_cl;
+ 	return NULL;
+ }
+ 
+ /**
+  * mei_me_cl_remove - remove me client matching uuid and client_id
+  *
+  * @dev: the device structure
+  * @uuid: me client uuid
+  * @client_id: me client address
+  */
+ void mei_me_cl_remove(struct mei_device *dev, const uuid_le *uuid, u8 client_id)
+ {
+ 	struct mei_me_client *me_cl, *next;
+ 
+ 	list_for_each_entry_safe(me_cl, next, &dev->me_clients, list) {
+ 		if (uuid_le_cmp(*uuid, me_cl->props.protocol_name) == 0 &&
+ 		    me_cl->client_id == client_id) {
+ 			list_del(&me_cl->list);
+ 			kfree(me_cl);
+ 			break;
+ 		}
+ 	}
++>>>>>>> d880f3294d05 (mei: add mei_me_cl_by_uuid_id function)
  }
  
  
@@@ -740,8 -765,8 +780,13 @@@ int mei_cl_read_start(struct mei_cl *cl
  		cl_dbg(dev, cl, "read is pending.\n");
  		return -EBUSY;
  	}
++<<<<<<< HEAD
 +	i = mei_me_cl_by_id(dev, cl->me_client_id);
 +	if (i < 0) {
++=======
+ 	me_cl = mei_me_cl_by_uuid_id(dev, &cl->cl_uuid, cl->me_client_id);
+ 	if (!me_cl) {
++>>>>>>> d880f3294d05 (mei: add mei_me_cl_by_uuid_id function)
  		cl_err(dev, cl, "no such me client %d\n", cl->me_client_id);
  		return  -ENOTTY;
  	}
diff --cc drivers/misc/mei/client.h
index bf2b0b1b493d,f5d03d622923..000000000000
--- a/drivers/misc/mei/client.h
+++ b/drivers/misc/mei/client.h
@@@ -24,8 -24,15 +24,20 @@@
  
  #include "mei_dev.h"
  
++<<<<<<< HEAD
 +int mei_me_cl_by_uuid(const struct mei_device *dev, const uuid_le *cuuid);
 +int mei_me_cl_by_id(struct mei_device *dev, u8 client_id);
++=======
+ struct mei_me_client *mei_me_cl_by_uuid(const struct mei_device *dev,
+ 					const uuid_le *cuuid);
+ struct mei_me_client *mei_me_cl_by_id(struct mei_device *dev, u8 client_id);
+ 
+ struct mei_me_client *mei_me_cl_by_uuid_id(struct mei_device *dev,
+ 					   const uuid_le *uuid, u8 client_id);
+ 
+ void mei_me_cl_remove(struct mei_device *dev,
+ 		      const uuid_le *uuid, u8 client_id);
++>>>>>>> d880f3294d05 (mei: add mei_me_cl_by_uuid_id function)
  
  /*
   * MEI IO Functions
diff --cc drivers/misc/mei/main.c
index a248b970782a,957f44aaa97a..000000000000
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@@ -344,8 -321,8 +344,13 @@@ static ssize_t mei_write(struct file *f
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	id = mei_me_cl_by_id(dev, cl->me_client_id);
 +	if (id < 0) {
++=======
+ 	me_cl = mei_me_cl_by_uuid_id(dev, &cl->cl_uuid, cl->me_client_id);
+ 	if (!me_cl) {
++>>>>>>> d880f3294d05 (mei: add mei_me_cl_by_uuid_id function)
  		rets = -ENOTTY;
  		goto out;
  	}
@@@ -491,7 -458,8 +496,12 @@@ static int mei_ioctl_connect_client(str
  		goto end;
  	}
  
++<<<<<<< HEAD
 +	cl->me_client_id = dev->me_clients[i].client_id;
++=======
+ 	cl->me_client_id = me_cl->client_id;
+ 	cl->cl_uuid = me_cl->props.protocol_name;
++>>>>>>> d880f3294d05 (mei: add mei_me_cl_by_uuid_id function)
  
  	dev_dbg(&dev->pdev->dev, "Connect to FW Client ID = %d\n",
  			cl->me_client_id);
diff --cc drivers/misc/mei/nfc.c
index 3095fc514a65,e0e75d429fdf..000000000000
--- a/drivers/misc/mei/nfc.c
+++ b/drivers/misc/mei/nfc.c
@@@ -506,7 -506,8 +506,12 @@@ int mei_nfc_host_init(struct mei_devic
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	cl_info->me_client_id = dev->me_clients[i].client_id;
++=======
+ 	cl_info->me_client_id = me_cl->client_id;
+ 	cl_info->cl_uuid = me_cl->props.protocol_name;
++>>>>>>> d880f3294d05 (mei: add mei_me_cl_by_uuid_id function)
  
  	ret = mei_cl_link(cl_info, MEI_HOST_CLIENT_ID_ANY);
  	if (ret)
@@@ -524,7 -524,8 +528,12 @@@
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	cl->me_client_id = dev->me_clients[i].client_id;
++=======
+ 	cl->me_client_id = me_cl->client_id;
+ 	cl->cl_uuid = me_cl->props.protocol_name;
++>>>>>>> d880f3294d05 (mei: add mei_me_cl_by_uuid_id function)
  
  	ret = mei_cl_link(cl, MEI_HOST_CLIENT_ID_ANY);
  	if (ret)
diff --cc drivers/misc/mei/wd.c
index 1e4f4283f10e,40f46e4c2e9c..000000000000
--- a/drivers/misc/mei/wd.c
+++ b/drivers/misc/mei/wd.c
@@@ -81,7 -75,8 +81,12 @@@ int mei_wd_host_init(struct mei_device 
  		return -ENOTTY;
  	}
  
++<<<<<<< HEAD
 +	cl->me_client_id = dev->me_clients[id].client_id;
++=======
+ 	cl->me_client_id = me_cl->client_id;
+ 	cl->cl_uuid = me_cl->props.protocol_name;
++>>>>>>> d880f3294d05 (mei: add mei_me_cl_by_uuid_id function)
  
  	ret = mei_cl_link(cl, MEI_WD_HOST_CLIENT_ID);
  
* Unmerged path drivers/misc/mei/amthif.c
* Unmerged path drivers/misc/mei/bus.c
* Unmerged path drivers/misc/mei/client.c
* Unmerged path drivers/misc/mei/client.h
* Unmerged path drivers/misc/mei/main.c
diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h
index 1fdacf4aceb2..9a4b494476fc 100644
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -216,6 +216,7 @@ struct mei_cl {
 	wait_queue_head_t wait;
 	int status;
 	/* ID of client connected */
+	uuid_le cl_uuid;
 	u8 host_client_id;
 	u8 me_client_id;
 	u8 mei_flow_ctrl_creds;
@@ -228,7 +229,6 @@ struct mei_cl {
 	/* MEI CL bus data */
 	struct mei_cl_device *device;
 	struct list_head device_link;
-	uuid_le device_uuid;
 };
 
 /** struct mei_hw_ops
* Unmerged path drivers/misc/mei/nfc.c
* Unmerged path drivers/misc/mei/wd.c
