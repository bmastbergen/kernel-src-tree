openvswitch: Allow matching on conntrack mark

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Joe Stringer <joestringer@nicira.com>
commit 182e3042e15de759e81618d11fe4f62f5259d982
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/182e3042.failed

Allow matching and setting the ct_mark field. As with ct_state and
ct_zone, these fields are populated when the CT action is executed. To
write to this field, a value and mask can be specified as a nested
attribute under the CT action. This data is stored with the conntrack
entry, and is executed after the lookup occurs for the CT action. The
conntrack entry itself must be committed using the COMMIT flag in the CT
action flags for this change to persist.

	Signed-off-by: Justin Pettit <jpettit@nicira.com>
	Signed-off-by: Joe Stringer <joestringer@nicira.com>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Acked-by: Pravin B Shelar <pshelar@nicira.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 182e3042e15de759e81618d11fe4f62f5259d982)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/openvswitch.h
#	net/openvswitch/actions.c
#	net/openvswitch/conntrack.c
#	net/openvswitch/conntrack.h
#	net/openvswitch/flow.h
#	net/openvswitch/flow_netlink.c
diff --cc include/uapi/linux/openvswitch.h
index 1dab77601c21,7a185b554343..000000000000
--- a/include/uapi/linux/openvswitch.h
+++ b/include/uapi/linux/openvswitch.h
@@@ -319,9 -323,12 +319,15 @@@ enum ovs_key_attr 
  	OVS_KEY_ATTR_MPLS,      /* array of struct ovs_key_mpls.
  				 * The implementation may restrict
  				 * the accepted length of the array. */
++<<<<<<< HEAD
++=======
+ 	OVS_KEY_ATTR_CT_STATE,	/* u8 bitmask of OVS_CS_F_* */
+ 	OVS_KEY_ATTR_CT_ZONE,	/* u16 connection tracking zone. */
+ 	OVS_KEY_ATTR_CT_MARK,	/* u32 connection tracking mark */
++>>>>>>> 182e3042e15d (openvswitch: Allow matching on conntrack mark)
  
  #ifdef __KERNEL__
 -	OVS_KEY_ATTR_TUNNEL_INFO,  /* struct ip_tunnel_info */
 +	OVS_KEY_ATTR_TUNNEL_INFO,  /* struct ovs_tunnel_info */
  #endif
  	__OVS_KEY_ATTR_MAX
  };
@@@ -595,6 -611,32 +601,35 @@@ struct ovs_action_hash 
  };
  
  /**
++<<<<<<< HEAD
++=======
+  * enum ovs_ct_attr - Attributes for %OVS_ACTION_ATTR_CT action.
+  * @OVS_CT_ATTR_FLAGS: u32 connection tracking flags.
+  * @OVS_CT_ATTR_ZONE: u16 connection tracking zone.
+  * @OVS_CT_ATTR_MARK: u32 value followed by u32 mask. For each bit set in the
+  * mask, the corresponding bit in the value is copied to the connection
+  * tracking mark field in the connection.
+  */
+ enum ovs_ct_attr {
+ 	OVS_CT_ATTR_UNSPEC,
+ 	OVS_CT_ATTR_FLAGS,      /* u8 bitmask of OVS_CT_F_*. */
+ 	OVS_CT_ATTR_ZONE,       /* u16 zone id. */
+ 	OVS_CT_ATTR_MARK,       /* mark to associate with this connection. */
+ 	__OVS_CT_ATTR_MAX
+ };
+ 
+ #define OVS_CT_ATTR_MAX (__OVS_CT_ATTR_MAX - 1)
+ 
+ /*
+  * OVS_CT_ATTR_FLAGS flags - bitmask of %OVS_CT_F_*
+  * @OVS_CT_F_COMMIT: Commits the flow to the conntrack table. This allows
+  * future packets for the same connection to be identified as 'established'
+  * or 'related'.
+  */
+ #define OVS_CT_F_COMMIT		0x01
+ 
+ /**
++>>>>>>> 182e3042e15d (openvswitch: Allow matching on conntrack mark)
   * enum ovs_action_attr - Action types.
   *
   * @OVS_ACTION_ATTR_OUTPUT: Output packet to port.
diff --cc net/openvswitch/actions.c
index 264af44ed85b,9741d2c703df..000000000000
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@@ -805,6 -965,12 +805,15 @@@ static int execute_masked_set_action(st
  		err = set_mpls(skb, flow_key, nla_data(a), get_mask(a,
  								    __be32 *));
  		break;
++<<<<<<< HEAD
++=======
+ 
+ 	case OVS_KEY_ATTR_CT_STATE:
+ 	case OVS_KEY_ATTR_CT_ZONE:
+ 	case OVS_KEY_ATTR_CT_MARK:
+ 		err = -EINVAL;
+ 		break;
++>>>>>>> 182e3042e15d (openvswitch: Allow matching on conntrack mark)
  	}
  
  	return err;
diff --cc net/openvswitch/flow.h
index 998401ae6927,e05e69711ce1..000000000000
--- a/net/openvswitch/flow.h
+++ b/net/openvswitch/flow.h
@@@ -176,6 -111,13 +176,16 @@@ struct sw_flow_key 
  			} nd;
  		} ipv6;
  	};
++<<<<<<< HEAD
++=======
+ 	struct {
+ 		/* Connection tracking fields. */
+ 		u16 zone;
+ 		u32 mark;
+ 		u8 state;
+ 	} ct;
+ 
++>>>>>>> 182e3042e15d (openvswitch: Allow matching on conntrack mark)
  } __aligned(BITS_PER_LONG/8); /* Ensure that we can do comparisons as longs. */
  
  struct sw_flow_key_range {
diff --cc net/openvswitch/flow_netlink.c
index 953a2c4bca92,b17a4ec348f9..000000000000
--- a/net/openvswitch/flow_netlink.c
+++ b/net/openvswitch/flow_netlink.c
@@@ -281,7 -281,7 +281,11 @@@ size_t ovs_key_attr_size(void
  	/* Whenever adding new OVS_KEY_ FIELDS, we should consider
  	 * updating this function.
  	 */
++<<<<<<< HEAD
 +	BUILD_BUG_ON(OVS_KEY_ATTR_TUNNEL_INFO != 22);
++=======
+ 	BUILD_BUG_ON(OVS_KEY_ATTR_TUNNEL_INFO != 25);
++>>>>>>> 182e3042e15d (openvswitch: Allow matching on conntrack mark)
  
  	return    nla_total_size(4)   /* OVS_KEY_ATTR_PRIORITY */
  		+ nla_total_size(0)   /* OVS_KEY_ATTR_TUNNEL */
@@@ -290,6 -290,9 +294,12 @@@
  		+ nla_total_size(4)   /* OVS_KEY_ATTR_SKB_MARK */
  		+ nla_total_size(4)   /* OVS_KEY_ATTR_DP_HASH */
  		+ nla_total_size(4)   /* OVS_KEY_ATTR_RECIRC_ID */
++<<<<<<< HEAD
++=======
+ 		+ nla_total_size(1)   /* OVS_KEY_ATTR_CT_STATE */
+ 		+ nla_total_size(2)   /* OVS_KEY_ATTR_CT_ZONE */
+ 		+ nla_total_size(4)   /* OVS_KEY_ATTR_CT_MARK */
++>>>>>>> 182e3042e15d (openvswitch: Allow matching on conntrack mark)
  		+ nla_total_size(12)  /* OVS_KEY_ATTR_ETHERNET */
  		+ nla_total_size(2)   /* OVS_KEY_ATTR_ETHERTYPE */
  		+ nla_total_size(4)   /* OVS_KEY_ATTR_VLAN */
@@@ -339,6 -342,9 +349,12 @@@ static const struct ovs_len_tbl ovs_key
  	[OVS_KEY_ATTR_TUNNEL]	 = { .len = OVS_ATTR_NESTED,
  				     .next = ovs_tunnel_key_lens, },
  	[OVS_KEY_ATTR_MPLS]	 = { .len = sizeof(struct ovs_key_mpls) },
++<<<<<<< HEAD
++=======
+ 	[OVS_KEY_ATTR_CT_STATE]	 = { .len = sizeof(u8) },
+ 	[OVS_KEY_ATTR_CT_ZONE]	 = { .len = sizeof(u16) },
+ 	[OVS_KEY_ATTR_CT_MARK]	 = { .len = sizeof(u32) },
++>>>>>>> 182e3042e15d (openvswitch: Allow matching on conntrack mark)
  };
  
  static bool is_all_zero(const u8 *fp, size_t size)
@@@ -768,6 -774,28 +784,31 @@@ static int metadata_from_nlattrs(struc
  			return -EINVAL;
  		*attrs &= ~(1 << OVS_KEY_ATTR_TUNNEL);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (*attrs & (1 << OVS_KEY_ATTR_CT_STATE) &&
+ 	    ovs_ct_verify(OVS_KEY_ATTR_CT_STATE)) {
+ 		u8 ct_state = nla_get_u8(a[OVS_KEY_ATTR_CT_STATE]);
+ 
+ 		SW_FLOW_KEY_PUT(match, ct.state, ct_state, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_STATE);
+ 	}
+ 	if (*attrs & (1 << OVS_KEY_ATTR_CT_ZONE) &&
+ 	    ovs_ct_verify(OVS_KEY_ATTR_CT_ZONE)) {
+ 		u16 ct_zone = nla_get_u16(a[OVS_KEY_ATTR_CT_ZONE]);
+ 
+ 		SW_FLOW_KEY_PUT(match, ct.zone, ct_zone, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_ZONE);
+ 	}
+ 	if (*attrs & (1 << OVS_KEY_ATTR_CT_MARK) &&
+ 	    ovs_ct_verify(OVS_KEY_ATTR_CT_MARK)) {
+ 		u32 mark = nla_get_u32(a[OVS_KEY_ATTR_CT_MARK]);
+ 
+ 		SW_FLOW_KEY_PUT(match, ct.mark, mark, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_MARK);
+ 	}
++>>>>>>> 182e3042e15d (openvswitch: Allow matching on conntrack mark)
  	return 0;
  }
  
* Unmerged path net/openvswitch/conntrack.c
* Unmerged path net/openvswitch/conntrack.h
* Unmerged path include/uapi/linux/openvswitch.h
* Unmerged path net/openvswitch/actions.c
* Unmerged path net/openvswitch/conntrack.c
* Unmerged path net/openvswitch/conntrack.h
* Unmerged path net/openvswitch/flow.h
* Unmerged path net/openvswitch/flow_netlink.c
