libceph: behave in mon_fault() if cur_mon < 0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ilya Dryomov <idryomov@gmail.com>
commit b5d91704f53efc5a2a93e88e323877e6889b0f5b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b5d91704.failed

This can happen if __close_session() in ceph_monc_stop() races with
a connection reset.  We need to ignore such faults, otherwise it's
likely we would take !hunting, call __schedule_delayed() and end up
with delayed_work() executing on invalid memory, among other things.

The (two!) con->private tests are useless, as nothing ever clears
con->private.  Nuke them.

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit b5d91704f53efc5a2a93e88e323877e6889b0f5b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ceph/mon_client.c
diff --cc net/ceph/mon_client.c
index 4a66c44fabbd,cf638c009cfa..000000000000
--- a/net/ceph/mon_client.c
+++ b/net/ceph/mon_client.c
@@@ -1031,29 -1155,17 +1031,36 @@@ static void mon_fault(struct ceph_conne
  {
  	struct ceph_mon_client *monc = con->private;
  
- 	if (!monc)
- 		return;
- 
- 	dout("mon_fault\n");
  	mutex_lock(&monc->mutex);
++<<<<<<< HEAD
 +	if (!con->private)
 +		goto out;
 +
 +	if (!monc->hunting)
 +		pr_info("mon%d %s session lost, "
 +			"hunting for new mon\n", monc->cur_mon,
 +			ceph_pr_addr(&monc->con.peer_addr.in_addr));
 +
 +	__close_session(monc);
 +	if (!monc->hunting) {
 +		/* start hunting */
 +		monc->hunting = true;
 +		__open_session(monc);
 +	} else {
 +		/* already hunting, let's wait a bit */
 +		__schedule_delayed(monc);
++=======
+ 	dout("%s mon%d\n", __func__, monc->cur_mon);
+ 	if (monc->cur_mon >= 0) {
+ 		if (!monc->hunting) {
+ 			dout("%s hunting for new mon\n", __func__);
+ 			reopen_session(monc);
+ 			__schedule_delayed(monc);
+ 		} else {
+ 			dout("%s already hunting\n", __func__);
+ 		}
++>>>>>>> b5d91704f53e (libceph: behave in mon_fault() if cur_mon < 0)
  	}
- out:
  	mutex_unlock(&monc->mutex);
  }
  
* Unmerged path net/ceph/mon_client.c
