sunrpc: move rq_splice_ok flag into rq_flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jeff Layton <jlayton@primarydata.com>
commit 779fb0f3af3089daa2e88cf8ef0ef0c5d2fecb40
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/779fb0f3.failed

	Signed-off-by: Jeff Layton <jlayton@primarydata.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 779fb0f3af3089daa2e88cf8ef0ef0c5d2fecb40)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/sunrpc/svc.h
#	include/trace/events/sunrpc.h
diff --cc include/linux/sunrpc/svc.h
index 21678464883a,2714287fc4f6..000000000000
--- a/include/linux/sunrpc/svc.h
+++ b/include/linux/sunrpc/svc.h
@@@ -253,9 -252,14 +253,20 @@@ struct svc_rqst 
  	u32			rq_vers;	/* program version */
  	u32			rq_proc;	/* procedure number */
  	u32			rq_prot;	/* IP protocol */
++<<<<<<< HEAD
 +	unsigned short
 +				rq_secure  : 1;	/* secure port */
 +	unsigned short		rq_local   : 1;	/* local request */
++=======
+ #define	RQ_SECURE	(0)			/* secure port */
+ #define	RQ_LOCAL	(1)			/* local request */
+ #define	RQ_USEDEFERRAL	(2)			/* use deferral */
+ #define	RQ_DROPME	(3)			/* drop current reply */
+ #define	RQ_SPLICE_OK	(4)			/* turned off in gss privacy
+ 						 * to prevent encrypting page
+ 						 * cache pages */
+ 	unsigned long		rq_flags;	/* flags field */
++>>>>>>> 779fb0f3af30 (sunrpc: move rq_splice_ok flag into rq_flags)
  
  	void *			rq_argp;	/* decoded arguments */
  	void *			rq_resp;	/* xdr'd results */
diff --cc include/trace/events/sunrpc.h
index 6260f5134212,5848fc235869..000000000000
--- a/include/trace/events/sunrpc.h
+++ b/include/trace/events/sunrpc.h
@@@ -307,6 -308,118 +307,121 @@@ DEFINE_RPC_SOCKET_EVENT_DONE(rpc_socket
  DEFINE_RPC_SOCKET_EVENT(rpc_socket_close);
  DEFINE_RPC_SOCKET_EVENT(rpc_socket_shutdown);
  
++<<<<<<< HEAD
++=======
+ DECLARE_EVENT_CLASS(rpc_xprt_event,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 
+ 	TP_ARGS(xprt, xid, status),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(__be32, xid)
+ 		__field(int, status)
+ 		__string(addr, xprt->address_strings[RPC_DISPLAY_ADDR])
+ 		__string(port, xprt->address_strings[RPC_DISPLAY_PORT])
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->xid = xid;
+ 		__entry->status = status;
+ 		__assign_str(addr, xprt->address_strings[RPC_DISPLAY_ADDR]);
+ 		__assign_str(port, xprt->address_strings[RPC_DISPLAY_PORT]);
+ 	),
+ 
+ 	TP_printk("peer=[%s]:%s xid=0x%x status=%d", __get_str(addr),
+ 			__get_str(port), be32_to_cpu(__entry->xid),
+ 			__entry->status)
+ );
+ 
+ DEFINE_EVENT(rpc_xprt_event, xprt_lookup_rqst,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 	TP_ARGS(xprt, xid, status));
+ 
+ DEFINE_EVENT(rpc_xprt_event, xprt_transmit,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 	TP_ARGS(xprt, xid, status));
+ 
+ DEFINE_EVENT(rpc_xprt_event, xprt_complete_rqst,
+ 	TP_PROTO(struct rpc_xprt *xprt, __be32 xid, int status),
+ 	TP_ARGS(xprt, xid, status));
+ 
+ TRACE_EVENT(xs_tcp_data_ready,
+ 	TP_PROTO(struct rpc_xprt *xprt, int err, unsigned int total),
+ 
+ 	TP_ARGS(xprt, err, total),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, err)
+ 		__field(unsigned int, total)
+ 		__string(addr, xprt ? xprt->address_strings[RPC_DISPLAY_ADDR] :
+ 				"(null)")
+ 		__string(port, xprt ? xprt->address_strings[RPC_DISPLAY_PORT] :
+ 				"(null)")
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->err = err;
+ 		__entry->total = total;
+ 		__assign_str(addr, xprt ?
+ 			xprt->address_strings[RPC_DISPLAY_ADDR] : "(null)");
+ 		__assign_str(port, xprt ?
+ 			xprt->address_strings[RPC_DISPLAY_PORT] : "(null)");
+ 	),
+ 
+ 	TP_printk("peer=[%s]:%s err=%d total=%u", __get_str(addr),
+ 			__get_str(port), __entry->err, __entry->total)
+ );
+ 
+ #define rpc_show_sock_xprt_flags(flags) \
+ 	__print_flags(flags, "|", \
+ 		{ TCP_RCV_LAST_FRAG, "TCP_RCV_LAST_FRAG" }, \
+ 		{ TCP_RCV_COPY_FRAGHDR, "TCP_RCV_COPY_FRAGHDR" }, \
+ 		{ TCP_RCV_COPY_XID, "TCP_RCV_COPY_XID" }, \
+ 		{ TCP_RCV_COPY_DATA, "TCP_RCV_COPY_DATA" }, \
+ 		{ TCP_RCV_READ_CALLDIR, "TCP_RCV_READ_CALLDIR" }, \
+ 		{ TCP_RCV_COPY_CALLDIR, "TCP_RCV_COPY_CALLDIR" }, \
+ 		{ TCP_RPC_REPLY, "TCP_RPC_REPLY" })
+ 
+ TRACE_EVENT(xs_tcp_data_recv,
+ 	TP_PROTO(struct sock_xprt *xs),
+ 
+ 	TP_ARGS(xs),
+ 
+ 	TP_STRUCT__entry(
+ 		__string(addr, xs->xprt.address_strings[RPC_DISPLAY_ADDR])
+ 		__string(port, xs->xprt.address_strings[RPC_DISPLAY_PORT])
+ 		__field(__be32, xid)
+ 		__field(unsigned long, flags)
+ 		__field(unsigned long, copied)
+ 		__field(unsigned int, reclen)
+ 		__field(unsigned long, offset)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__assign_str(addr, xs->xprt.address_strings[RPC_DISPLAY_ADDR]);
+ 		__assign_str(port, xs->xprt.address_strings[RPC_DISPLAY_PORT]);
+ 		__entry->xid = xs->tcp_xid;
+ 		__entry->flags = xs->tcp_flags;
+ 		__entry->copied = xs->tcp_copied;
+ 		__entry->reclen = xs->tcp_reclen;
+ 		__entry->offset = xs->tcp_offset;
+ 	),
+ 
+ 	TP_printk("peer=[%s]:%s xid=0x%x flags=%s copied=%lu reclen=%u offset=%lu",
+ 			__get_str(addr), __get_str(port), be32_to_cpu(__entry->xid),
+ 			rpc_show_sock_xprt_flags(__entry->flags),
+ 			__entry->copied, __entry->reclen, __entry->offset)
+ );
+ 
+ #define show_rqstp_flags(flags)						\
+ 	__print_flags(flags, "|",					\
+ 		{ (1UL << RQ_SECURE),		"RQ_SECURE"},		\
+ 		{ (1UL << RQ_LOCAL),		"RQ_LOCAL"},		\
+ 		{ (1UL << RQ_USEDEFERRAL),	"RQ_USEDEFERRAL"},	\
+ 		{ (1UL << RQ_DROPME),		"RQ_DROPME"},		\
+ 		{ (1UL << RQ_SPLICE_OK),	"RQ_SPLICE_OK"})
+ 
++>>>>>>> 779fb0f3af30 (sunrpc: move rq_splice_ok flag into rq_flags)
  TRACE_EVENT(svc_recv,
  	TP_PROTO(struct svc_rqst *rqst, int status),
  
diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index 62d2f99f3c74..311f839a78aa 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -774,7 +774,7 @@ nfsd4_read(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	 * the client wants us to do more in this compound:
 	 */
 	if (!nfsd4_last_compound_op(rqstp))
-		rqstp->rq_splice_ok = false;
+		clear_bit(RQ_SPLICE_OK, &rqstp->rq_flags);
 
 	/* check stateid */
 	if ((status = nfs4_preprocess_stateid_op(SVC_NET(rqstp),
diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 7f583d8e4f4c..a8cbeeb5e872 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -1870,7 +1870,7 @@ nfsd4_decode_compound(struct nfsd4_compoundargs *argp)
 	argp->rqstp->rq_cachetype = cachethis ? RC_REPLBUFF : RC_NOCACHE;
 
 	if (readcount > 1 || max_reply > PAGE_SIZE - auth_slack)
-		argp->rqstp->rq_splice_ok = false;
+		clear_bit(RQ_SPLICE_OK, &argp->rqstp->rq_flags);
 
 	DECODE_TAIL;
 }
@@ -3419,10 +3419,10 @@ nfsd4_encode_read(struct nfsd4_compoundres *resp, __be32 nfserr,
 
 	p = xdr_reserve_space(xdr, 8); /* eof flag and byte count */
 	if (!p) {
-		WARN_ON_ONCE(resp->rqstp->rq_splice_ok);
+		WARN_ON_ONCE(test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags));
 		return nfserr_resource;
 	}
-	if (resp->xdr.buf->page_len && resp->rqstp->rq_splice_ok) {
+	if (resp->xdr.buf->page_len && test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags)) {
 		WARN_ON_ONCE(1);
 		return nfserr_resource;
 	}
@@ -3439,7 +3439,7 @@ nfsd4_encode_read(struct nfsd4_compoundres *resp, __be32 nfserr,
 			goto err_truncate;
 	}
 
-	if (file->f_op->splice_read && resp->rqstp->rq_splice_ok)
+	if (file->f_op->splice_read && test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags))
 		err = nfsd4_encode_splice_read(resp, read, file, maxcount);
 	else
 		err = nfsd4_encode_readv(resp, read, file, maxcount);
diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
index a139207b71c1..801724a9a0d4 100644
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -1053,7 +1053,7 @@ static __be32
 nfsd_vfs_read(struct svc_rqst *rqstp, struct file *file,
 	      loff_t offset, struct kvec *vec, int vlen, unsigned long *count)
 {
-	if (file->f_op->splice_read && rqstp->rq_splice_ok)
+	if (file->f_op->splice_read && test_bit(RQ_SPLICE_OK, &rqstp->rq_flags))
 		return nfsd_splice_read(rqstp, file, offset, count);
 	else
 		return nfsd_readv(file, offset, vec, vlen, count);
* Unmerged path include/linux/sunrpc/svc.h
* Unmerged path include/trace/events/sunrpc.h
diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c
index da7a29f1ac01..b4e7f8f673c4 100644
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@ -886,7 +886,7 @@ unwrap_priv_data(struct svc_rqst *rqstp, struct xdr_buf *buf, u32 seq, struct gs
 	u32 priv_len, maj_stat;
 	int pad, saved_len, remaining_len, offset;
 
-	rqstp->rq_splice_ok = false;
+	clear_bit(RQ_SPLICE_OK, &rqstp->rq_flags);
 
 	priv_len = svc_getnl(&buf->head[0]);
 	if (rqstp->rq_deferred) {
diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c
index 942c67131e18..d87ec460815d 100644
--- a/net/sunrpc/svc.c
+++ b/net/sunrpc/svc.c
@@ -1088,7 +1088,7 @@ svc_process_common(struct svc_rqst *rqstp, struct kvec *argv, struct kvec *resv)
 		goto err_short_len;
 
 	/* Will be turned off only in gss privacy case: */
-	rqstp->rq_splice_ok = true;
+	set_bit(RQ_SPLICE_OK, &rqstp->rq_flags);
 	/* Will be turned off only when NFSv4 Sessions are used */
 	rqstp->rq_usedeferral = true;
 	rqstp->rq_dropme = false;
