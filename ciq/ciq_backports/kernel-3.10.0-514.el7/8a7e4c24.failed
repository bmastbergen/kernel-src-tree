mpt3sas: Added mpt2sas driver definitions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sreekanth Reddy <sreekanth.reddy@avagotech.com>
commit 8a7e4c24e08fceb94887eb6d8123d6059dc5ddcd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8a7e4c24.failed

1. Added mpt2sas driver related macros in mpt3sas header files

2. Made scsi host's, raid class', pci's, ioctl's callback functions
global so that both drivers can use them.

	Signed-off-by: Sreekanth Reddy <Sreekanth.Reddy@avagotech.com>
	Acked-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 8a7e4c24e08fceb94887eb6d8123d6059dc5ddcd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpt3sas/mpt3sas_scsih.c
diff --cc drivers/scsi/mpt3sas/mpt3sas_scsih.c
index d94b7501c72c,3353b487ab70..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
@@@ -1094,9 -1092,15 +1092,21 @@@ _scsih_scsi_lookup_find_by_lun(struct M
  	return found;
  }
  
++<<<<<<< HEAD
 +
 +static void
 +_scsih_adjust_queue_depth(struct scsi_device *sdev, int qdepth)
++=======
+ /**
+  * scsih_change_queue_depth - setting device queue depth
+  * @sdev: scsi device struct
+  * @qdepth: requested queue depth
+  *
+  * Returns queue depth.
+  */
+ int
+ scsih_change_queue_depth(struct scsi_device *sdev, int qdepth)
++>>>>>>> 8a7e4c24e08f (mpt3sas: Added mpt2sas driver definitions)
  {
  	struct Scsi_Host *shost = sdev->host;
  	int max_depth;
@@@ -1131,63 -1135,11 +1141,67 @@@
  		max_depth = 1;
  	if (qdepth > max_depth)
  		qdepth = max_depth;
 -	return scsi_change_queue_depth(sdev, qdepth);
 +	scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), qdepth);
 +}
 +
 +/**
++<<<<<<< HEAD
 + * _scsih_change_queue_depth - setting device queue depth
 + * @sdev: scsi device struct
 + * @qdepth: requested queue depth
 + * @reason: SCSI_QDEPTH_DEFAULT/SCSI_QDEPTH_QFULL/SCSI_QDEPTH_RAMP_UP
 + * (see include/scsi/scsi_host.h for definition)
 + *
 + * Returns queue depth.
 + */
 +static int
 +_scsih_change_queue_depth(struct scsi_device *sdev, int qdepth, int reason)
 +{
 +	if (reason == SCSI_QDEPTH_DEFAULT || reason == SCSI_QDEPTH_RAMP_UP)
 +		_scsih_adjust_queue_depth(sdev, qdepth);
 +	else if (reason == SCSI_QDEPTH_QFULL)
 +		scsi_track_queue_full(sdev, qdepth);
 +	else
 +		return -EOPNOTSUPP;
 +
 +	if (sdev->inquiry_len > 7)
 +		sdev_printk(KERN_INFO, sdev, "qdepth(%d), tagged(%d), " \
 +		"simple(%d), ordered(%d), scsi_level(%d), cmd_que(%d)\n",
 +		sdev->queue_depth, sdev->tagged_supported, sdev->simple_tags,
 +		sdev->ordered_tags, sdev->scsi_level,
 +		(sdev->inquiry[7] & 2) >> 1);
 +
 +	return sdev->queue_depth;
  }
  
  /**
 + * _scsih_change_queue_type - changing device queue tag type
 + * @sdev: scsi device struct
 + * @tag_type: requested tag type
 + *
 + * Returns queue tag type.
 + */
 +static int
 +_scsih_change_queue_type(struct scsi_device *sdev, int tag_type)
 +{
 +	if (sdev->tagged_supported) {
 +		scsi_set_tag_type(sdev, tag_type);
 +		if (tag_type)
 +			scsi_activate_tcq(sdev, sdev->queue_depth);
 +		else
 +			scsi_deactivate_tcq(sdev, sdev->queue_depth);
 +	} else
 +		tag_type = 0;
 +
 +	return tag_type;
 +}
 +
 +
 +/**
 + * _scsih_target_alloc - target add routine
++=======
+  * scsih_target_alloc - target add routine
++>>>>>>> 8a7e4c24e08f (mpt3sas: Added mpt2sas driver definitions)
   * @starget: scsi target struct
   *
   * Returns 0 if ok. Any other return is assumed to be an error and
@@@ -1803,7 -1755,7 +1817,11 @@@ scsih_slave_configure(struct scsi_devic
  			 raid_device->num_pds, ds);
  
  
++<<<<<<< HEAD
 +		_scsih_change_queue_depth(sdev, qdepth, SCSI_QDEPTH_DEFAULT);
++=======
+ 		scsih_change_queue_depth(sdev, qdepth);
++>>>>>>> 8a7e4c24e08f (mpt3sas: Added mpt2sas driver definitions)
  
  /* raid transport support */
  		_scsih_set_level(sdev, raid_device->volume_type);
@@@ -1875,7 -1827,7 +1893,11 @@@
  		_scsih_display_sata_capabilities(ioc, handle, sdev);
  
  
++<<<<<<< HEAD
 +	_scsih_change_queue_depth(sdev, qdepth, SCSI_QDEPTH_DEFAULT);
++=======
+ 	scsih_change_queue_depth(sdev, qdepth);
++>>>>>>> 8a7e4c24e08f (mpt3sas: Added mpt2sas driver definitions)
  
  	if (ssp_target) {
  		sas_read_port_mode_page(sdev);
@@@ -7554,21 -7491,20 +7576,38 @@@ static struct scsi_host_template scsih_
  	.module				= THIS_MODULE,
  	.name				= "Fusion MPT SAS Host",
  	.proc_name			= MPT3SAS_DRIVER_NAME,
++<<<<<<< HEAD
 +	.queuecommand			= _scsih_qcmd,
 +	.target_alloc			= _scsih_target_alloc,
 +	.slave_alloc			= _scsih_slave_alloc,
 +	.slave_configure		= _scsih_slave_configure,
 +	.target_destroy			= _scsih_target_destroy,
 +	.slave_destroy			= _scsih_slave_destroy,
 +	.scan_finished			= _scsih_scan_finished,
 +	.scan_start			= _scsih_scan_start,
 +	.change_queue_depth		= _scsih_change_queue_depth,
 +	.change_queue_type		= _scsih_change_queue_type,
 +	.eh_abort_handler		= _scsih_abort,
 +	.eh_device_reset_handler	= _scsih_dev_reset,
 +	.eh_target_reset_handler	= _scsih_target_reset,
 +	.eh_host_reset_handler		= _scsih_host_reset,
 +	.bios_param			= _scsih_bios_param,
++=======
+ 	.queuecommand			= scsih_qcmd,
+ 	.target_alloc			= scsih_target_alloc,
+ 	.slave_alloc			= scsih_slave_alloc,
+ 	.slave_configure		= scsih_slave_configure,
+ 	.target_destroy			= scsih_target_destroy,
+ 	.slave_destroy			= scsih_slave_destroy,
+ 	.scan_finished			= scsih_scan_finished,
+ 	.scan_start			= scsih_scan_start,
+ 	.change_queue_depth		= scsih_change_queue_depth,
+ 	.eh_abort_handler		= scsih_abort,
+ 	.eh_device_reset_handler	= scsih_dev_reset,
+ 	.eh_target_reset_handler	= scsih_target_reset,
+ 	.eh_host_reset_handler		= scsih_host_reset,
+ 	.bios_param			= scsih_bios_param,
++>>>>>>> 8a7e4c24e08f (mpt3sas: Added mpt2sas driver definitions)
  	.can_queue			= 1,
  	.this_id			= -1,
  	.sg_tablesize			= MPT3SAS_SG_DEPTH,
diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.c b/drivers/scsi/mpt3sas/mpt3sas_base.c
index f1a0ae072eef..95aaaf125919 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_base.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c
@@ -2857,15 +2857,15 @@ _base_allocate_memory_pools(struct MPT3SAS_ADAPTER *ioc,  int sleep_flag)
 	else
 		sg_tablesize = MPT3SAS_SG_DEPTH;
 
-	if (sg_tablesize < MPT3SAS_MIN_PHYS_SEGMENTS)
-		sg_tablesize = MPT3SAS_MIN_PHYS_SEGMENTS;
-	else if (sg_tablesize > MPT3SAS_MAX_PHYS_SEGMENTS) {
+	if (sg_tablesize < MPT_MIN_PHYS_SEGMENTS)
+		sg_tablesize = MPT_MIN_PHYS_SEGMENTS;
+	else if (sg_tablesize > MPT_MAX_PHYS_SEGMENTS) {
 		sg_tablesize = min_t(unsigned short, sg_tablesize,
 				      SCSI_MAX_SG_CHAIN_SEGMENTS);
 		pr_warn(MPT3SAS_FMT
 		 "sg_tablesize(%u) is bigger than kernel"
 		 " defined SCSI_MAX_SG_SEGMENTS(%u)\n", ioc->name,
-		 sg_tablesize, MPT3SAS_MAX_PHYS_SEGMENTS);
+		 sg_tablesize, MPT_MAX_PHYS_SEGMENTS);
 	}
 	ioc->shost->sg_tablesize = sg_tablesize;
 
diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.h b/drivers/scsi/mpt3sas/mpt3sas_base.h
index 4a187ecbb856..c2533258afff 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_base.h
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.h
@@ -63,15 +63,20 @@
 #include <scsi/scsi_transport_sas.h>
 #include <scsi/scsi_dbg.h>
 #include <scsi/scsi_eh.h>
+#include <linux/pci.h>
+#include <linux/poll.h>
 
 #include "mpt3sas_debug.h"
 #include "mpt3sas_trigger_diag.h"
 
 /* driver versioning info */
 #define MPT3SAS_DRIVER_NAME		"mpt3sas"
+#define MPT2SAS_DRIVER_NAME		"mpt2sas"
 #define MPT3SAS_AUTHOR "Avago Technologies <MPT-FusionLinux.pdl@avagotech.com>"
 #define MPT3SAS_DESCRIPTION	"LSI MPT Fusion SAS 3.0 Device Driver"
+#define MPT2SAS_DESCRIPTION	"LSI MPT Fusion SAS 2.0 Device Driver"
 #define MPT3SAS_DRIVER_VERSION		"09.100.00.00"
+#define MPT2SAS_DRIVER_VERSION		"20.101.00.00"
 #define MPT3SAS_MAJOR_VERSION		9
 #define MPT3SAS_MINOR_VERSION		100
 #define MPT3SAS_BUILD_VERSION		0
@@ -80,14 +85,20 @@
 /*
  * Set MPT3SAS_SG_DEPTH value based on user input.
  */
-#define MPT3SAS_MAX_PHYS_SEGMENTS	SCSI_MAX_SG_SEGMENTS
-#define MPT3SAS_MIN_PHYS_SEGMENTS	16
+#define MPT_MAX_PHYS_SEGMENTS	SCSI_MAX_SG_SEGMENTS
+#define MPT_MIN_PHYS_SEGMENTS	16
+
 #ifdef CONFIG_SCSI_MPT3SAS_MAX_SGE
 #define MPT3SAS_SG_DEPTH		CONFIG_SCSI_MPT3SAS_MAX_SGE
 #else
-#define MPT3SAS_SG_DEPTH		MPT3SAS_MAX_PHYS_SEGMENTS
+#define MPT3SAS_SG_DEPTH		MPT_MAX_PHYS_SEGMENTS
 #endif
 
+#ifdef CONFIG_SCSI_MPT2SAS_MAX_SGE
+#define MPT2SAS_SG_DEPTH		CONFIG_SCSI_MPT2SAS_MAX_SGE
+#else
+#define MPT2SAS_SG_DEPTH		MPT_MAX_PHYS_SEGMENTS
+#endif
 
 /*
  * Generic Defines
@@ -1098,6 +1109,39 @@ struct _sas_device *mpt3sas_scsih_sas_device_find_by_sas_address(
 
 void mpt3sas_port_enable_complete(struct MPT3SAS_ADAPTER *ioc);
 
+void scsih_exit(void);
+int scsih_init(void);
+int scsih_probe(struct pci_dev *pdev, const struct pci_device_id *id);
+void scsih_remove(struct pci_dev *pdev);
+void scsih_shutdown(struct pci_dev *pdev);
+pci_ers_result_t scsih_pci_error_detected(struct pci_dev *pdev,
+	pci_channel_state_t state);
+pci_ers_result_t scsih_pci_mmio_enabled(struct pci_dev *pdev);
+pci_ers_result_t scsih_pci_slot_reset(struct pci_dev *pdev);
+void scsih_pci_resume(struct pci_dev *pdev);
+int scsih_suspend(struct pci_dev *pdev, pm_message_t state);
+int scsih_resume(struct pci_dev *pdev);
+
+int scsih_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *scmd);
+int scsih_target_alloc(struct scsi_target *starget);
+int scsih_slave_alloc(struct scsi_device *sdev);
+int scsih_slave_configure(struct scsi_device *sdev);
+void scsih_target_destroy(struct scsi_target *starget);
+void scsih_slave_destroy(struct scsi_device *sdev);
+int scsih_scan_finished(struct Scsi_Host *shost, unsigned long time);
+void scsih_scan_start(struct Scsi_Host *shost);
+int scsih_change_queue_depth(struct scsi_device *sdev, int qdepth);
+int scsih_abort(struct scsi_cmnd *scmd);
+int scsih_dev_reset(struct scsi_cmnd *scmd);
+int scsih_target_reset(struct scsi_cmnd *scmd);
+int scsih_host_reset(struct scsi_cmnd *scmd);
+int scsih_bios_param(struct scsi_device *sdev, struct block_device *bdev,
+	sector_t capacity, int params[]);
+
+int scsih_is_raid(struct device *dev);
+void scsih_get_resync(struct device *dev);
+void scsih_get_state(struct device *dev);
+
 /* config shared API */
 u8 mpt3sas_config_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
 	u32 reply);
@@ -1180,8 +1224,12 @@ int mpt3sas_config_get_volume_wwid(struct MPT3SAS_ADAPTER *ioc,
 /* ctl shared API */
 extern struct device_attribute *mpt3sas_host_attrs[];
 extern struct device_attribute *mpt3sas_dev_attrs[];
-void mpt3sas_ctl_init(void);
-void mpt3sas_ctl_exit(void);
+long ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+unsigned int ctl_poll(struct file *filep, poll_table *wait);
+int ctl_fasync(int fd, struct file *filep, int mode);
+long ctl_ioctl_compat(struct file *file, unsigned cmd, unsigned long arg);
+void ctl_init(void);
+void ctl_exit(void);
 u8 mpt3sas_ctl_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
 	u32 reply);
 void mpt3sas_ctl_reset_handler(struct MPT3SAS_ADAPTER *ioc, int reset_phase);
diff --git a/drivers/scsi/mpt3sas/mpt3sas_ctl.c b/drivers/scsi/mpt3sas/mpt3sas_ctl.c
index 704bdf20b4dc..587f980a5ea8 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_ctl.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_ctl.c
@@ -490,27 +490,27 @@ mpt3sas_ctl_reset_handler(struct MPT3SAS_ADAPTER *ioc, int reset_phase)
 }
 
 /**
- * _ctl_fasync -
+ * ctl_fasync -
  * @fd -
  * @filep -
  * @mode -
  *
  * Called when application request fasyn callback handler.
  */
-static int
-_ctl_fasync(int fd, struct file *filep, int mode)
+int
+ctl_fasync(int fd, struct file *filep, int mode)
 {
 	return fasync_helper(fd, filep, mode, &async_queue);
 }
 
 /**
- * _ctl_poll -
+ * ctl_poll -
  * @file -
  * @wait -
  *
  */
-static unsigned int
-_ctl_poll(struct file *filep, poll_table *wait)
+unsigned int
+ctl_poll(struct file *filep, poll_table *wait)
 {
 	struct MPT3SAS_ADAPTER *ioc;
 
@@ -2298,13 +2298,13 @@ _ctl_ioctl_main(struct file *file, unsigned int cmd, void __user *arg,
 }
 
 /**
- * _ctl_ioctl - main ioctl entry point (unlocked)
+ * ctl_ioctl - main ioctl entry point (unlocked)
  * @file - (struct file)
  * @cmd - ioctl opcode
  * @arg -
  */
-static long
-_ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+long
+ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	long ret;
 
@@ -2314,15 +2314,15 @@ _ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 #ifdef CONFIG_COMPAT
 /**
- * _ctl_ioctl_compat - main ioctl entry point (compat)
+ * ctl_ioctl_compat - main ioctl entry point (compat)
  * @file -
  * @cmd -
  * @arg -
  *
  * This routine handles 32 bit applications in 64bit os.
  */
-static long
-_ctl_ioctl_compat(struct file *file, unsigned cmd, unsigned long arg)
+long
+ctl_ioctl_compat(struct file *file, unsigned cmd, unsigned long arg)
 {
 	long ret;
 
@@ -3220,11 +3220,11 @@ struct device_attribute *mpt3sas_dev_attrs[] = {
 
 static const struct file_operations ctl_fops = {
 	.owner = THIS_MODULE,
-	.unlocked_ioctl = _ctl_ioctl,
-	.poll = _ctl_poll,
-	.fasync = _ctl_fasync,
+	.unlocked_ioctl = ctl_ioctl,
+	.poll = ctl_poll,
+	.fasync = ctl_fasync,
 #ifdef CONFIG_COMPAT
-	.compat_ioctl = _ctl_ioctl_compat,
+	.compat_ioctl = ctl_ioctl_compat,
 #endif
 };
 
@@ -3235,11 +3235,11 @@ static struct miscdevice ctl_dev = {
 };
 
 /**
- * mpt3sas_ctl_init - main entry point for ctl.
+ * ctl_init - main entry point for ctl.
  *
  */
 void
-mpt3sas_ctl_init(void)
+ctl_init(void)
 {
 	async_queue = NULL;
 	if (misc_register(&ctl_dev) < 0)
@@ -3250,11 +3250,11 @@ mpt3sas_ctl_init(void)
 }
 
 /**
- * mpt3sas_ctl_exit - exit point for ctl
+ * ctl_exit - exit point for ctl
  *
  */
 void
-mpt3sas_ctl_exit(void)
+ctl_exit(void)
 {
 	struct MPT3SAS_ADAPTER *ioc;
 	int i;
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_scsih.c
