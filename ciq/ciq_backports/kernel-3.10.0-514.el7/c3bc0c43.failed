perf hists: Introduce perf_hpp__setup_hists_formats()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit c3bc0c436899d01c3a09fddb308d487cc032fbd2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c3bc0c43.failed

The perf_hpp__setup_hists_formats() is to build hists-specific output
formats (and sort keys).  Currently it's only used in order to build the
output format in a hierarchy with same sort keys, but it could be used
with different sort keys in non-hierarchy mode later.

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1457361308-514-2-git-send-email-namhyung@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit c3bc0c436899d01c3a09fddb308d487cc032fbd2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/hist.c
#	tools/perf/util/hist.h
#	tools/perf/util/sort.c
diff --cc tools/perf/util/hist.c
index 9a525a5b649f,fea92fcb6903..000000000000
--- a/tools/perf/util/hist.c
+++ b/tools/perf/util/hist.c
@@@ -1677,6 -2103,9 +1677,12 @@@ int __hists__init(struct hists *hists
  	hists->entries_collapsed = RB_ROOT;
  	hists->entries = RB_ROOT;
  	pthread_mutex_init(&hists->lock, NULL);
++<<<<<<< HEAD
++=======
+ 	hists->socket_filter = -1;
+ 	hists->hpp_list = hpp_list;
+ 	INIT_LIST_HEAD(&hists->hpp_formats);
++>>>>>>> c3bc0c436899 (perf hists: Introduce perf_hpp__setup_hists_formats())
  	return 0;
  }
  
diff --cc tools/perf/util/hist.h
index 1d52912874e9,3cab9dc20822..000000000000
--- a/tools/perf/util/hist.h
+++ b/tools/perf/util/hist.h
@@@ -71,6 -76,10 +71,13 @@@ struct hists 
  	struct events_stats	stats;
  	u64			event_stream;
  	u16			col_len[HISTC_NR_COLS];
++<<<<<<< HEAD
++=======
+ 	int			socket_filter;
+ 	struct perf_hpp_list	*hpp_list;
+ 	struct list_head	hpp_formats;
+ 	int			nr_sort_keys;
++>>>>>>> c3bc0c436899 (perf hists: Introduce perf_hpp__setup_hists_formats())
  };
  
  struct hist_entry_iter;
@@@ -272,16 -303,35 +285,34 @@@ enum 
  void perf_hpp__init(void);
  void perf_hpp__column_unregister(struct perf_hpp_fmt *format);
  void perf_hpp__cancel_cumulate(void);
++<<<<<<< HEAD
 +void perf_hpp__setup_output_field(void);
 +void perf_hpp__reset_output_field(void);
 +void perf_hpp__append_sort_keys(void);
++=======
+ void perf_hpp__setup_output_field(struct perf_hpp_list *list);
+ void perf_hpp__reset_output_field(struct perf_hpp_list *list);
+ void perf_hpp__append_sort_keys(struct perf_hpp_list *list);
+ int perf_hpp__setup_hists_formats(struct perf_hpp_list *list,
+ 				  struct perf_evlist *evlist);
+ 
++>>>>>>> c3bc0c436899 (perf hists: Introduce perf_hpp__setup_hists_formats())
  
  bool perf_hpp__is_sort_entry(struct perf_hpp_fmt *format);
 -bool perf_hpp__is_dynamic_entry(struct perf_hpp_fmt *format);
 -bool perf_hpp__defined_dynamic_entry(struct perf_hpp_fmt *fmt, struct hists *hists);
 -bool perf_hpp__is_trace_entry(struct perf_hpp_fmt *fmt);
 -bool perf_hpp__is_srcline_entry(struct perf_hpp_fmt *fmt);
 -bool perf_hpp__is_srcfile_entry(struct perf_hpp_fmt *fmt);
 +bool perf_hpp__same_sort_entry(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b);
  
++<<<<<<< HEAD
 +static inline bool perf_hpp__should_skip(struct perf_hpp_fmt *format)
++=======
+ struct perf_hpp_fmt *perf_hpp_fmt__dup(struct perf_hpp_fmt *fmt);
+ 
+ int hist_entry__filter(struct hist_entry *he, int type, const void *arg);
+ 
+ static inline bool perf_hpp__should_skip(struct perf_hpp_fmt *format,
+ 					 struct hists *hists)
++>>>>>>> c3bc0c436899 (perf hists: Introduce perf_hpp__setup_hists_formats())
  {
 -	if (format->elide)
 -		return true;
 -
 -	if (perf_hpp__is_dynamic_entry(format) &&
 -	    !perf_hpp__defined_dynamic_entry(format, hists))
 -		return true;
 -
 -	return false;
 +	return format->elide;
  }
  
  void perf_hpp__reset_width(struct perf_hpp_fmt *fmt, struct hists *hists);
diff --cc tools/perf/util/sort.c
index 8f36c1d6fd38,71d45d147376..000000000000
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@@ -1747,12 -1908,181 +1747,115 @@@ __alloc_dynamic_entry(struct perf_evse
  	return hde;
  }
  
++<<<<<<< HEAD
 +static int add_dynamic_entry(struct perf_evlist *evlist, const char *tok)
++=======
+ struct perf_hpp_fmt *perf_hpp_fmt__dup(struct perf_hpp_fmt *fmt)
+ {
+ 	struct perf_hpp_fmt *new_fmt = NULL;
+ 
+ 	if (perf_hpp__is_sort_entry(fmt)) {
+ 		struct hpp_sort_entry *hse, *new_hse;
+ 
+ 		hse = container_of(fmt, struct hpp_sort_entry, hpp);
+ 		new_hse = memdup(hse, sizeof(*hse));
+ 		if (new_hse)
+ 			new_fmt = &new_hse->hpp;
+ 	} else if (perf_hpp__is_dynamic_entry(fmt)) {
+ 		struct hpp_dynamic_entry *hde, *new_hde;
+ 
+ 		hde = container_of(fmt, struct hpp_dynamic_entry, hpp);
+ 		new_hde = memdup(hde, sizeof(*hde));
+ 		if (new_hde)
+ 			new_fmt = &new_hde->hpp;
+ 	} else {
+ 		new_fmt = memdup(fmt, sizeof(*fmt));
+ 	}
+ 
+ 	INIT_LIST_HEAD(&new_fmt->list);
+ 	INIT_LIST_HEAD(&new_fmt->sort_list);
+ 
+ 	return new_fmt;
+ }
+ 
+ static int parse_field_name(char *str, char **event, char **field, char **opt)
+ {
+ 	char *event_name, *field_name, *opt_name;
+ 
+ 	event_name = str;
+ 	field_name = strchr(str, '.');
+ 
+ 	if (field_name) {
+ 		*field_name++ = '\0';
+ 	} else {
+ 		event_name = NULL;
+ 		field_name = str;
+ 	}
+ 
+ 	opt_name = strchr(field_name, '/');
+ 	if (opt_name)
+ 		*opt_name++ = '\0';
+ 
+ 	*event = event_name;
+ 	*field = field_name;
+ 	*opt   = opt_name;
+ 
+ 	return 0;
+ }
+ 
+ /* find match evsel using a given event name.  The event name can be:
+  *   1. '%' + event index (e.g. '%1' for first event)
+  *   2. full event name (e.g. sched:sched_switch)
+  *   3. partial event name (should not contain ':')
+  */
+ static struct perf_evsel *find_evsel(struct perf_evlist *evlist, char *event_name)
+ {
+ 	struct perf_evsel *evsel = NULL;
+ 	struct perf_evsel *pos;
+ 	bool full_name;
+ 
+ 	/* case 1 */
+ 	if (event_name[0] == '%') {
+ 		int nr = strtol(event_name+1, NULL, 0);
+ 
+ 		if (nr > evlist->nr_entries)
+ 			return NULL;
+ 
+ 		evsel = perf_evlist__first(evlist);
+ 		while (--nr > 0)
+ 			evsel = perf_evsel__next(evsel);
+ 
+ 		return evsel;
+ 	}
+ 
+ 	full_name = !!strchr(event_name, ':');
+ 	evlist__for_each(evlist, pos) {
+ 		/* case 2 */
+ 		if (full_name && !strcmp(pos->name, event_name))
+ 			return pos;
+ 		/* case 3 */
+ 		if (!full_name && strstr(pos->name, event_name)) {
+ 			if (evsel) {
+ 				pr_debug("'%s' event is ambiguous: it can be %s or %s\n",
+ 					 event_name, evsel->name, pos->name);
+ 				return NULL;
+ 			}
+ 			evsel = pos;
+ 		}
+ 	}
+ 
+ 	return evsel;
+ }
+ 
+ static int __dynamic_dimension__add(struct perf_evsel *evsel,
+ 				    struct format_field *field,
+ 				    bool raw_trace, int level)
++>>>>>>> c3bc0c436899 (perf hists: Introduce perf_hpp__setup_hists_formats())
  {
 -	struct hpp_dynamic_entry *hde;
 -
 -	hde = __alloc_dynamic_entry(evsel, field, level);
 -	if (hde == NULL)
 -		return -ENOMEM;
 -
 -	hde->raw_trace = raw_trace;
 -
 -	perf_hpp__register_sort_field(&hde->hpp);
 -	return 0;
 -}
 -
 -static int add_evsel_fields(struct perf_evsel *evsel, bool raw_trace, int level)
 -{
 -	int ret;
 +	char *str, *event_name, *field_name;
 +	struct perf_evsel *evsel, *pos;
  	struct format_field *field;
 -
 -	field = evsel->tp_format->format.fields;
 -	while (field) {
 -		ret = __dynamic_dimension__add(evsel, field, raw_trace, level);
 -		if (ret < 0)
 -			return ret;
 -
 -		field = field->next;
 -	}
 -	return 0;
 -}
 -
 -static int add_all_dynamic_fields(struct perf_evlist *evlist, bool raw_trace,
 -				  int level)
 -{
 -	int ret;
 -	struct perf_evsel *evsel;
 -
 -	evlist__for_each(evlist, evsel) {
 -		if (evsel->attr.type != PERF_TYPE_TRACEPOINT)
 -			continue;
 -
 -		ret = add_evsel_fields(evsel, raw_trace, level);
 -		if (ret < 0)
 -			return ret;
 -	}
 -	return 0;
 -}
 -
 -static int add_all_matching_fields(struct perf_evlist *evlist,
 -				   char *field_name, bool raw_trace, int level)
 -{
 -	int ret = -ESRCH;
 -	struct perf_evsel *evsel;
 -	struct format_field *field;
 -
 -	evlist__for_each(evlist, evsel) {
 -		if (evsel->attr.type != PERF_TYPE_TRACEPOINT)
 -			continue;
 -
 -		field = pevent_find_any_field(evsel->tp_format, field_name);
 -		if (field == NULL)
 -			continue;
 -
 -		ret = __dynamic_dimension__add(evsel, field, raw_trace, level);
 -		if (ret < 0)
 -			break;
 -	}
 -	return ret;
 -}
 -
 -static int add_dynamic_entry(struct perf_evlist *evlist, const char *tok,
 -			     int level)
 -{
 -	char *str, *event_name, *field_name, *opt_name;
 -	struct perf_evsel *evsel;
 -	struct format_field *field;
 -	bool raw_trace = symbol_conf.raw_trace;
 +	struct hpp_dynamic_entry *hde;
  	int ret = 0;
  
  	if (evlist == NULL)
@@@ -2343,10 -2724,14 +2446,14 @@@ int setup_sorting(struct perf_evlist *e
  		return err;
  
  	/* copy sort keys to output fields */
 -	perf_hpp__setup_output_field(&perf_hpp_list);
 +	perf_hpp__setup_output_field();
  	/* and then copy output fields to sort keys */
 -	perf_hpp__append_sort_keys(&perf_hpp_list);
 +	perf_hpp__append_sort_keys();
  
+ 	/* setup hists-specific output fields */
+ 	if (perf_hpp__setup_hists_formats(&perf_hpp_list, evlist) < 0)
+ 		return -1;
+ 
  	return 0;
  }
  
diff --git a/tools/perf/ui/hist.c b/tools/perf/ui/hist.c
index ad40452da995..b51c3ea08838 100644
--- a/tools/perf/ui/hist.c
+++ b/tools/perf/ui/hist.c
@@ -5,6 +5,7 @@
 #include "../util/util.h"
 #include "../util/sort.h"
 #include "../util/evsel.h"
+#include "../util/evlist.h"
 
 /* hist period print (hpp) functions */
 
@@ -687,3 +688,65 @@ void perf_hpp__set_user_width(const char *width_list_str)
 			break;
 	}
 }
+
+static int add_hierarchy_fmt(struct hists *hists, struct perf_hpp_fmt *fmt)
+{
+	struct perf_hpp_list_node *node = NULL;
+	struct perf_hpp_fmt *fmt_copy;
+	bool found = false;
+
+	list_for_each_entry(node, &hists->hpp_formats, list) {
+		if (node->level == fmt->level) {
+			found = true;
+			break;
+		}
+	}
+
+	if (!found) {
+		node = malloc(sizeof(*node));
+		if (node == NULL)
+			return -1;
+
+		node->level = fmt->level;
+		perf_hpp_list__init(&node->hpp);
+
+		list_add_tail(&node->list, &hists->hpp_formats);
+	}
+
+	fmt_copy = perf_hpp_fmt__dup(fmt);
+	if (fmt_copy == NULL)
+		return -1;
+
+	list_add_tail(&fmt_copy->list, &node->hpp.fields);
+	list_add_tail(&fmt_copy->sort_list, &node->hpp.sorts);
+
+	return 0;
+}
+
+int perf_hpp__setup_hists_formats(struct perf_hpp_list *list,
+				  struct perf_evlist *evlist)
+{
+	struct perf_evsel *evsel;
+	struct perf_hpp_fmt *fmt;
+	struct hists *hists;
+	int ret;
+
+	if (!symbol_conf.report_hierarchy)
+		return 0;
+
+	evlist__for_each(evlist, evsel) {
+		hists = evsel__hists(evsel);
+
+		perf_hpp_list__for_each_sort_list(list, fmt) {
+			if (perf_hpp__is_dynamic_entry(fmt) &&
+			    !perf_hpp__defined_dynamic_entry(fmt, hists))
+				continue;
+
+			ret = add_hierarchy_fmt(hists, fmt);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return 0;
+}
* Unmerged path tools/perf/util/hist.c
* Unmerged path tools/perf/util/hist.h
* Unmerged path tools/perf/util/sort.c
