lwtunnel: remove source and destination UDP port config option

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit b194f30c61efb0767a98f47a64530baa8b731670
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b194f30c.failed

The UDP tunnel config is asymmetric wrt. to the ports used. The source and
destination ports from one direction of the tunnel are not related to the
ports of the other direction. We need to be able to respond to ARP requests
using the correct ports without involving routing.

As the consequence, UDP ports need to be fixed property of the tunnel
interface and cannot be set per route. Remove the ability to set ports per
route. This is still okay to do, as no kernel has been released with these
attributes yet.

Note that the ability to specify source and destination ports is preserved
for other users of the lwtunnel API which don't use routes for tunnel key
specification (like openvswitch).

If in the future we rework ARP handling to allow port specification, the
attributes can be added back.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b194f30c61efb0767a98f47a64530baa8b731670)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/lwtunnel.h
#	net/ipv4/ip_tunnel_core.c
diff --cc net/ipv4/ip_tunnel_core.c
index c969294e6abb,84dce6a92f93..000000000000
--- a/net/ipv4/ip_tunnel_core.c
+++ b/net/ipv4/ip_tunnel_core.c
@@@ -188,3 -219,208 +188,211 @@@ struct rtnl_link_stats64 *ip_tunnel_get
  	return tot;
  }
  EXPORT_SYMBOL_GPL(ip_tunnel_get_stats64);
++<<<<<<< HEAD
++=======
+ 
+ static const struct nla_policy ip_tun_policy[LWTUNNEL_IP_MAX + 1] = {
+ 	[LWTUNNEL_IP_ID]	= { .type = NLA_U64 },
+ 	[LWTUNNEL_IP_DST]	= { .type = NLA_U32 },
+ 	[LWTUNNEL_IP_SRC]	= { .type = NLA_U32 },
+ 	[LWTUNNEL_IP_TTL]	= { .type = NLA_U8 },
+ 	[LWTUNNEL_IP_TOS]	= { .type = NLA_U8 },
+ 	[LWTUNNEL_IP_FLAGS]	= { .type = NLA_U16 },
+ };
+ 
+ static int ip_tun_build_state(struct net_device *dev, struct nlattr *attr,
+ 			      unsigned int family, const void *cfg,
+ 			      struct lwtunnel_state **ts)
+ {
+ 	struct ip_tunnel_info *tun_info;
+ 	struct lwtunnel_state *new_state;
+ 	struct nlattr *tb[LWTUNNEL_IP_MAX + 1];
+ 	int err;
+ 
+ 	err = nla_parse_nested(tb, LWTUNNEL_IP_MAX, attr, ip_tun_policy);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	new_state = lwtunnel_state_alloc(sizeof(*tun_info));
+ 	if (!new_state)
+ 		return -ENOMEM;
+ 
+ 	new_state->type = LWTUNNEL_ENCAP_IP;
+ 
+ 	tun_info = lwt_tun_info(new_state);
+ 
+ 	if (tb[LWTUNNEL_IP_ID])
+ 		tun_info->key.tun_id = nla_get_u64(tb[LWTUNNEL_IP_ID]);
+ 
+ 	if (tb[LWTUNNEL_IP_DST])
+ 		tun_info->key.u.ipv4.dst = nla_get_be32(tb[LWTUNNEL_IP_DST]);
+ 
+ 	if (tb[LWTUNNEL_IP_SRC])
+ 		tun_info->key.u.ipv4.src = nla_get_be32(tb[LWTUNNEL_IP_SRC]);
+ 
+ 	if (tb[LWTUNNEL_IP_TTL])
+ 		tun_info->key.ttl = nla_get_u8(tb[LWTUNNEL_IP_TTL]);
+ 
+ 	if (tb[LWTUNNEL_IP_TOS])
+ 		tun_info->key.tos = nla_get_u8(tb[LWTUNNEL_IP_TOS]);
+ 
+ 	if (tb[LWTUNNEL_IP_FLAGS])
+ 		tun_info->key.tun_flags = nla_get_u16(tb[LWTUNNEL_IP_FLAGS]);
+ 
+ 	tun_info->mode = IP_TUNNEL_INFO_TX;
+ 	tun_info->options_len = 0;
+ 
+ 	*ts = new_state;
+ 
+ 	return 0;
+ }
+ 
+ static int ip_tun_fill_encap_info(struct sk_buff *skb,
+ 				  struct lwtunnel_state *lwtstate)
+ {
+ 	struct ip_tunnel_info *tun_info = lwt_tun_info(lwtstate);
+ 
+ 	if (nla_put_u64(skb, LWTUNNEL_IP_ID, tun_info->key.tun_id) ||
+ 	    nla_put_be32(skb, LWTUNNEL_IP_DST, tun_info->key.u.ipv4.dst) ||
+ 	    nla_put_be32(skb, LWTUNNEL_IP_SRC, tun_info->key.u.ipv4.src) ||
+ 	    nla_put_u8(skb, LWTUNNEL_IP_TOS, tun_info->key.tos) ||
+ 	    nla_put_u8(skb, LWTUNNEL_IP_TTL, tun_info->key.ttl) ||
+ 	    nla_put_u16(skb, LWTUNNEL_IP_FLAGS, tun_info->key.tun_flags))
+ 		return -ENOMEM;
+ 
+ 	return 0;
+ }
+ 
+ static int ip_tun_encap_nlsize(struct lwtunnel_state *lwtstate)
+ {
+ 	return nla_total_size(8)	/* LWTUNNEL_IP_ID */
+ 		+ nla_total_size(4)	/* LWTUNNEL_IP_DST */
+ 		+ nla_total_size(4)	/* LWTUNNEL_IP_SRC */
+ 		+ nla_total_size(1)	/* LWTUNNEL_IP_TOS */
+ 		+ nla_total_size(1)	/* LWTUNNEL_IP_TTL */
+ 		+ nla_total_size(2);	/* LWTUNNEL_IP_FLAGS */
+ }
+ 
+ static int ip_tun_cmp_encap(struct lwtunnel_state *a, struct lwtunnel_state *b)
+ {
+ 	return memcmp(lwt_tun_info(a), lwt_tun_info(b),
+ 		      sizeof(struct ip_tunnel_info));
+ }
+ 
+ static const struct lwtunnel_encap_ops ip_tun_lwt_ops = {
+ 	.build_state = ip_tun_build_state,
+ 	.fill_encap = ip_tun_fill_encap_info,
+ 	.get_encap_size = ip_tun_encap_nlsize,
+ 	.cmp_encap = ip_tun_cmp_encap,
+ };
+ 
+ static const struct nla_policy ip6_tun_policy[LWTUNNEL_IP6_MAX + 1] = {
+ 	[LWTUNNEL_IP6_ID]		= { .type = NLA_U64 },
+ 	[LWTUNNEL_IP6_DST]		= { .len = sizeof(struct in6_addr) },
+ 	[LWTUNNEL_IP6_SRC]		= { .len = sizeof(struct in6_addr) },
+ 	[LWTUNNEL_IP6_HOPLIMIT]		= { .type = NLA_U8 },
+ 	[LWTUNNEL_IP6_TC]		= { .type = NLA_U8 },
+ 	[LWTUNNEL_IP6_FLAGS]		= { .type = NLA_U16 },
+ };
+ 
+ static int ip6_tun_build_state(struct net_device *dev, struct nlattr *attr,
+ 			       unsigned int family, const void *cfg,
+ 			       struct lwtunnel_state **ts)
+ {
+ 	struct ip_tunnel_info *tun_info;
+ 	struct lwtunnel_state *new_state;
+ 	struct nlattr *tb[LWTUNNEL_IP6_MAX + 1];
+ 	int err;
+ 
+ 	err = nla_parse_nested(tb, LWTUNNEL_IP6_MAX, attr, ip6_tun_policy);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	new_state = lwtunnel_state_alloc(sizeof(*tun_info));
+ 	if (!new_state)
+ 		return -ENOMEM;
+ 
+ 	new_state->type = LWTUNNEL_ENCAP_IP6;
+ 
+ 	tun_info = lwt_tun_info(new_state);
+ 
+ 	if (tb[LWTUNNEL_IP6_ID])
+ 		tun_info->key.tun_id = nla_get_u64(tb[LWTUNNEL_IP6_ID]);
+ 
+ 	if (tb[LWTUNNEL_IP6_DST])
+ 		tun_info->key.u.ipv6.dst = nla_get_in6_addr(tb[LWTUNNEL_IP6_DST]);
+ 
+ 	if (tb[LWTUNNEL_IP6_SRC])
+ 		tun_info->key.u.ipv6.src = nla_get_in6_addr(tb[LWTUNNEL_IP6_SRC]);
+ 
+ 	if (tb[LWTUNNEL_IP6_HOPLIMIT])
+ 		tun_info->key.ttl = nla_get_u8(tb[LWTUNNEL_IP6_HOPLIMIT]);
+ 
+ 	if (tb[LWTUNNEL_IP6_TC])
+ 		tun_info->key.tos = nla_get_u8(tb[LWTUNNEL_IP6_TC]);
+ 
+ 	if (tb[LWTUNNEL_IP6_FLAGS])
+ 		tun_info->key.tun_flags = nla_get_u16(tb[LWTUNNEL_IP6_FLAGS]);
+ 
+ 	tun_info->mode = IP_TUNNEL_INFO_TX | IP_TUNNEL_INFO_IPV6;
+ 	tun_info->options_len = 0;
+ 
+ 	*ts = new_state;
+ 
+ 	return 0;
+ }
+ 
+ static int ip6_tun_fill_encap_info(struct sk_buff *skb,
+ 				   struct lwtunnel_state *lwtstate)
+ {
+ 	struct ip_tunnel_info *tun_info = lwt_tun_info(lwtstate);
+ 
+ 	if (nla_put_u64(skb, LWTUNNEL_IP6_ID, tun_info->key.tun_id) ||
+ 	    nla_put_in6_addr(skb, LWTUNNEL_IP6_DST, &tun_info->key.u.ipv6.dst) ||
+ 	    nla_put_in6_addr(skb, LWTUNNEL_IP6_SRC, &tun_info->key.u.ipv6.src) ||
+ 	    nla_put_u8(skb, LWTUNNEL_IP6_HOPLIMIT, tun_info->key.tos) ||
+ 	    nla_put_u8(skb, LWTUNNEL_IP6_TC, tun_info->key.ttl) ||
+ 	    nla_put_u16(skb, LWTUNNEL_IP6_FLAGS, tun_info->key.tun_flags))
+ 		return -ENOMEM;
+ 
+ 	return 0;
+ }
+ 
+ static int ip6_tun_encap_nlsize(struct lwtunnel_state *lwtstate)
+ {
+ 	return nla_total_size(8)	/* LWTUNNEL_IP6_ID */
+ 		+ nla_total_size(16)	/* LWTUNNEL_IP6_DST */
+ 		+ nla_total_size(16)	/* LWTUNNEL_IP6_SRC */
+ 		+ nla_total_size(1)	/* LWTUNNEL_IP6_HOPLIMIT */
+ 		+ nla_total_size(1)	/* LWTUNNEL_IP6_TC */
+ 		+ nla_total_size(2);	/* LWTUNNEL_IP6_FLAGS */
+ }
+ 
+ static const struct lwtunnel_encap_ops ip6_tun_lwt_ops = {
+ 	.build_state = ip6_tun_build_state,
+ 	.fill_encap = ip6_tun_fill_encap_info,
+ 	.get_encap_size = ip6_tun_encap_nlsize,
+ 	.cmp_encap = ip_tun_cmp_encap,
+ };
+ 
+ void __init ip_tunnel_core_init(void)
+ {
+ 	lwtunnel_encap_add_ops(&ip_tun_lwt_ops, LWTUNNEL_ENCAP_IP);
+ 	lwtunnel_encap_add_ops(&ip6_tun_lwt_ops, LWTUNNEL_ENCAP_IP6);
+ }
+ 
+ struct static_key ip_tunnel_metadata_cnt = STATIC_KEY_INIT_FALSE;
+ EXPORT_SYMBOL(ip_tunnel_metadata_cnt);
+ 
+ void ip_tunnel_need_metadata(void)
+ {
+ 	static_key_slow_inc(&ip_tunnel_metadata_cnt);
+ }
+ EXPORT_SYMBOL_GPL(ip_tunnel_need_metadata);
+ 
+ void ip_tunnel_unneed_metadata(void)
+ {
+ 	static_key_slow_dec(&ip_tunnel_metadata_cnt);
+ }
+ EXPORT_SYMBOL_GPL(ip_tunnel_unneed_metadata);
++>>>>>>> b194f30c61ef (lwtunnel: remove source and destination UDP port config option)
* Unmerged path include/uapi/linux/lwtunnel.h
* Unmerged path include/uapi/linux/lwtunnel.h
* Unmerged path net/ipv4/ip_tunnel_core.c
