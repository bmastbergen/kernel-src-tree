ixgbe: fix inconsistent clearing of the multicast table

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Emil Tantilov <emil.s.tantilov@intel.com>
commit cf78959c0d7afbde31498afc4212294c28e2c278
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/cf78959c.failed

This patch resolves an issue where the MTA table can be cleared when the
interface is reset while in promisc mode. As result IPv6 traffic between
VFs will be interrupted.

This patch makes the update of the MTA table unconditional to avoid the
inconsistent clearing on reset.

	Signed-off-by: Emil Tantilov <emil.s.tantilov@intel.com>
	Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit cf78959c0d7afbde31498afc4212294c28e2c278)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index aed374c42f81,5191b3ca9a26..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -4213,16 -3823,8 +4213,8 @@@ void ixgbe_set_rx_mode(struct net_devic
  		if (netdev->flags & IFF_ALLMULTI) {
  			fctrl |= IXGBE_FCTRL_MPE;
  			vmolr |= IXGBE_VMOLR_MPE;
- 		} else {
- 			/*
- 			 * Write addresses to the MTA, if the attempt fails
- 			 * then we should just turn on promiscuous mode so
- 			 * that we can at least receive multicast traffic
- 			 */
- 			hw->mac.ops.update_mc_addr_list(hw, netdev);
- 			vmolr |= IXGBE_VMOLR_ROMPE;
  		}
 -		ixgbe_vlan_filter_enable(adapter);
 +		vlnctrl |= IXGBE_VLNCTRL_VFE;
  		hw->addr_ctrl.user_set_promisc = false;
  	}
  
@@@ -4240,13 -3843,11 +4232,21 @@@
  	 * then we should just turn on promiscuous mode so
  	 * that we can at least receive multicast traffic
  	 */
++<<<<<<< HEAD
 +	count = ixgbe_write_mc_addr_list(netdev);
 +	if (count < 0) {
 +		fctrl |= IXGBE_FCTRL_MPE;
 +		vmolr |= IXGBE_VMOLR_MPE;
 +	} else if (count) {
 +		vmolr |= IXGBE_VMOLR_ROMPE;
 +	}
++=======
+ 	hw->mac.ops.update_mc_addr_list(hw, netdev);
+ 	vmolr |= IXGBE_VMOLR_ROMPE;
+ 
+ 	if (adapter->num_vfs)
+ 		ixgbe_restore_vf_multicasts(adapter);
++>>>>>>> cf78959c0d7a (ixgbe: fix inconsistent clearing of the multicast table)
  
  	if (hw->mac.type != ixgbe_mac_82598EB) {
  		vmolr |= IXGBE_READ_REG(hw, IXGBE_VMOLR(VMDQ_P(0))) &
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
