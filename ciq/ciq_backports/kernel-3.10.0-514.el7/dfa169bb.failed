Revert "KVM: x86: add pcommit support"

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit dfa169bbee00671288df25f8ef8a2f6e13fe2581
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/dfa169bb.failed

This reverts commit 8b3e34e46aca9b6d349b331cd9cf71ccbdc91b2e.

Given the deprecation of the pcommit instruction, the relevant VMX
features and CPUID bits are not going to be rolled into the SDM.  Remove
their usage from KVM.

	Cc: Xiao Guangrong <guangrong.xiao@linux.intel.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit dfa169bbee00671288df25f8ef8a2f6e13fe2581)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/vmx.h
#	arch/x86/include/uapi/asm/vmx.h
#	arch/x86/kvm/cpuid.h
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/include/asm/vmx.h
index b963514887da,a002b07a7099..000000000000
--- a/arch/x86/include/asm/vmx.h
+++ b/arch/x86/include/asm/vmx.h
@@@ -71,7 -71,8 +71,12 @@@
  #define SECONDARY_EXEC_ENABLE_INVPCID		0x00001000
  #define SECONDARY_EXEC_SHADOW_VMCS              0x00004000
  #define SECONDARY_EXEC_ENABLE_PML               0x00020000
++<<<<<<< HEAD
 +
++=======
+ #define SECONDARY_EXEC_XSAVES			0x00100000
+ #define SECONDARY_EXEC_TSC_SCALING              0x02000000
++>>>>>>> dfa169bbee00 (Revert "KVM: x86: add pcommit support")
  
  #define PIN_BASED_EXT_INTR_MASK                 0x00000001
  #define PIN_BASED_NMI_EXITING                   0x00000008
diff --cc arch/x86/include/uapi/asm/vmx.h
index adfadcc6f962,37fee272618f..000000000000
--- a/arch/x86/include/uapi/asm/vmx.h
+++ b/arch/x86/include/uapi/asm/vmx.h
@@@ -75,6 -76,8 +75,11 @@@
  #define EXIT_REASON_APIC_WRITE          56
  #define EXIT_REASON_INVPCID             58
  #define EXIT_REASON_PML_FULL            62
++<<<<<<< HEAD
++=======
+ #define EXIT_REASON_XSAVES              63
+ #define EXIT_REASON_XRSTORS             64
++>>>>>>> dfa169bbee00 (Revert "KVM: x86: add pcommit support")
  
  #define VMX_EXIT_REASONS \
  	{ EXIT_REASON_EXCEPTION_NMI,         "EXCEPTION_NMI" }, \
@@@ -120,7 -125,8 +125,12 @@@
  	{ EXIT_REASON_INVD,                  "INVD" }, \
  	{ EXIT_REASON_INVVPID,               "INVVPID" }, \
  	{ EXIT_REASON_INVPCID,               "INVPCID" }, \
++<<<<<<< HEAD
 +	{ EXIT_REASON_PREEMPTION_TIMER,      "PREEMPTION_TIMER" }
++=======
+ 	{ EXIT_REASON_XSAVES,                "XSAVES" }, \
+ 	{ EXIT_REASON_XRSTORS,               "XRSTORS" }
++>>>>>>> dfa169bbee00 (Revert "KVM: x86: add pcommit support")
  
  #define VMX_ABORT_SAVE_GUEST_MSR_FAIL        1
  #define VMX_ABORT_LOAD_HOST_MSR_FAIL         4
diff --cc arch/x86/kvm/cpuid.h
index c346c610bd63,35058c2c0eea..000000000000
--- a/arch/x86/kvm/cpuid.h
+++ b/arch/x86/kvm/cpuid.h
@@@ -120,11 -144,65 +120,75 @@@ static inline bool guest_cpuid_has_rtm(
  	return best && (best->ebx & bit(X86_FEATURE_RTM));
  }
  
++<<<<<<< HEAD
 +static inline bool guest_cpuid_has_mpx(struct kvm_vcpu *vcpu)
 +{
 +	struct kvm_cpuid_entry2 *best;
 +
 +	best = kvm_find_cpuid_entry(vcpu, 7, 0);
 +	return best && (best->ebx & bit(X86_FEATURE_MPX));
 +}
++=======
+ static inline bool guest_cpuid_has_rdtscp(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvm_cpuid_entry2 *best;
+ 
+ 	best = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);
+ 	return best && (best->edx & bit(X86_FEATURE_RDTSCP));
+ }
+ 
+ /*
+  * NRIPS is provided through cpuidfn 0x8000000a.edx bit 3
+  */
+ #define BIT_NRIPS	3
+ 
+ static inline bool guest_cpuid_has_nrips(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvm_cpuid_entry2 *best;
+ 
+ 	best = kvm_find_cpuid_entry(vcpu, 0x8000000a, 0);
+ 
+ 	/*
+ 	 * NRIPS is a scattered cpuid feature, so we can't use
+ 	 * X86_FEATURE_NRIPS here (X86_FEATURE_NRIPS would be bit
+ 	 * position 8, not 3).
+ 	 */
+ 	return best && (best->edx & bit(BIT_NRIPS));
+ }
+ #undef BIT_NRIPS
+ 
+ static inline int guest_cpuid_family(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvm_cpuid_entry2 *best;
+ 
+ 	best = kvm_find_cpuid_entry(vcpu, 0x1, 0);
+ 	if (!best)
+ 		return -1;
+ 
+ 	return x86_family(best->eax);
+ }
+ 
+ static inline int guest_cpuid_model(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvm_cpuid_entry2 *best;
+ 
+ 	best = kvm_find_cpuid_entry(vcpu, 0x1, 0);
+ 	if (!best)
+ 		return -1;
+ 
+ 	return x86_model(best->eax);
+ }
+ 
+ static inline int guest_cpuid_stepping(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvm_cpuid_entry2 *best;
+ 
+ 	best = kvm_find_cpuid_entry(vcpu, 0x1, 0);
+ 	if (!best)
+ 		return -1;
+ 
+ 	return x86_stepping(best->eax);
+ }
+ 
++>>>>>>> dfa169bbee00 (Revert "KVM: x86: add pcommit support")
  #endif
diff --cc arch/x86/kvm/vmx.c
index 2a45db3ac9a4,2e2685424fdc..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -2458,11 -2694,18 +2458,21 @@@ static __init void nested_vmx_setup_ctl
  
  	/* secondary cpu-based controls */
  	rdmsr(MSR_IA32_VMX_PROCBASED_CTLS2,
 -		vmx->nested.nested_vmx_secondary_ctls_low,
 -		vmx->nested.nested_vmx_secondary_ctls_high);
 -	vmx->nested.nested_vmx_secondary_ctls_low = 0;
 -	vmx->nested.nested_vmx_secondary_ctls_high &=
 +		nested_vmx_secondary_ctls_low, nested_vmx_secondary_ctls_high);
 +	nested_vmx_secondary_ctls_low = 0;
 +	nested_vmx_secondary_ctls_high &=
  		SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
++<<<<<<< HEAD
 +		SECONDARY_EXEC_WBINVD_EXITING;
++=======
+ 		SECONDARY_EXEC_RDTSCP |
+ 		SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |
+ 		SECONDARY_EXEC_ENABLE_VPID |
+ 		SECONDARY_EXEC_APIC_REGISTER_VIRT |
+ 		SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
+ 		SECONDARY_EXEC_WBINVD_EXITING |
+ 		SECONDARY_EXEC_XSAVES;
++>>>>>>> dfa169bbee00 (Revert "KVM: x86: add pcommit support")
  
  	if (enable_ept) {
  		/* nested EPT: emulate EPT also to L1 */
@@@ -2967,7 -3265,9 +2977,13 @@@ static __init int setup_vmcs_config(str
  			SECONDARY_EXEC_APIC_REGISTER_VIRT |
  			SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
  			SECONDARY_EXEC_SHADOW_VMCS |
++<<<<<<< HEAD
 +			SECONDARY_EXEC_ENABLE_PML;
++=======
+ 			SECONDARY_EXEC_XSAVES |
+ 			SECONDARY_EXEC_ENABLE_PML |
+ 			SECONDARY_EXEC_TSC_SCALING;
++>>>>>>> dfa169bbee00 (Revert "KVM: x86: add pcommit support")
  		if (adjust_vmx_controls(min2, opt2,
  					MSR_IA32_VMX_PROCBASED_CTLS2,
  					&_cpu_based_2nd_exec_control) < 0)
@@@ -4399,8 -4850,9 +4415,14 @@@ static u32 vmx_secondary_exec_control(s
  	   a current VMCS12
  	*/
  	exec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;
++<<<<<<< HEAD
 +	/* PML is enabled/disabled in creating/destorying vcpu */
 +	exec_control &= ~SECONDARY_EXEC_ENABLE_PML;
++=======
+ 
+ 	if (!enable_pml)
+ 		exec_control &= ~SECONDARY_EXEC_ENABLE_PML;
++>>>>>>> dfa169bbee00 (Revert "KVM: x86: add pcommit support")
  
  	return exec_control;
  }
@@@ -7350,9 -7902,17 +7372,21 @@@ static bool nested_vmx_exit_handled(str
  	case EXIT_REASON_WBINVD:
  		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);
  	case EXIT_REASON_XSETBV:
++<<<<<<< HEAD
 +		return 1;
++=======
+ 		return true;
+ 	case EXIT_REASON_XSAVES: case EXIT_REASON_XRSTORS:
+ 		/*
+ 		 * This should never happen, since it is not possible to
+ 		 * set XSS to a non-zero value---neither in L1 nor in L2.
+ 		 * If if it were, XSS would have to be checked against
+ 		 * the XSS exit bitmap in vmcs12.
+ 		 */
+ 		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_XSAVES);
++>>>>>>> dfa169bbee00 (Revert "KVM: x86: add pcommit support")
  	default:
 -		return true;
 +		return 1;
  	}
  }
  
@@@ -8462,6 -9068,9 +8496,12 @@@ static void vmx_cpuid_update(struct kvm
  		if (best)
  			best->ebx &= ~bit(X86_FEATURE_INVPCID);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (cpu_has_secondary_exec_ctrls())
+ 		vmcs_set_secondary_exec_control(secondary_exec_ctl);
++>>>>>>> dfa169bbee00 (Revert "KVM: x86: add pcommit support")
  }
  
  static void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)
@@@ -8911,8 -9681,9 +8951,12 @@@ static void prepare_vmcs02(struct kvm_v
  
  		/* Take the following fields only from vmcs12 */
  		exec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
 -				  SECONDARY_EXEC_RDTSCP |
  				  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
++<<<<<<< HEAD
 +                                  SECONDARY_EXEC_APIC_REGISTER_VIRT);
++=======
+ 				  SECONDARY_EXEC_APIC_REGISTER_VIRT);
++>>>>>>> dfa169bbee00 (Revert "KVM: x86: add pcommit support")
  		if (nested_cpu_has(vmcs12,
  				CPU_BASED_ACTIVATE_SECONDARY_CONTROLS))
  			exec_control |= vmcs12->secondary_vm_exec_control;
* Unmerged path arch/x86/include/asm/vmx.h
* Unmerged path arch/x86/include/uapi/asm/vmx.h
* Unmerged path arch/x86/kvm/cpuid.h
* Unmerged path arch/x86/kvm/vmx.c
