perf stat: Bail out on unsupported event config modifiers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Wang Nan <wangnan0@huawei.com>
commit 1669e509ea25e4e3e871d913d21b1cac4a96d1e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1669e509.failed

'perf stat' accepts some config terms but doesn't apply them. For
example:

  # perf stat -e 'instructions/no-inherit/' -e 'instructions/inherit/' bash
  # ls
  # exit

  Performance counter stats for 'bash':

         266258061      instructions/no-inherit/
         266258061      instructions/inherit/

       1.402183915 seconds time elapsed

The result is confusing, because user may expect the first
'instructions' event exclude the 'ls' command.

This patch forbid most of these config terms for 'perf stat'.

Result:

  # ./perf stat -e 'instructions/no-inherit/' -e 'instructions/inherit/' bash
  event syntax error: 'instructions/no-inherit/'
                       \___ 'no-inherit' is not usable in 'perf stat'
  ...

We can add blocked config terms back when 'perf stat' really supports them.

This patch also removes unavailable config term from error message:

  # ./perf stat -e 'instructions/badterm/' ls
  event syntax error: 'instructions/badterm/'
                                    \___ unknown term

  valid terms: config,config1,config2,name

  # ./perf stat -e 'cpu/badterm/' ls
  event syntax error: 'cpu/badterm/'
                           \___ unknown term

  valid terms: pc,any,inv,edge,cmask,event,in_tx,ldlat,umask,in_tx_cp,offcore_rsp,config,config1,config2,name

	Signed-off-by: Wang Nan <wangnan0@huawei.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Alexei Starovoitov <ast@kernel.org>
	Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
	Cc: Cody P Schafer <dev@codyps.com>
	Cc: He Kuang <hekuang@huawei.com>
	Cc: Jeremie Galarneau <jeremie.galarneau@efficios.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Kirill Smelkov <kirr@nexedi.com>
	Cc: Li Zefan <lizefan@huawei.com>
	Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/r/1455882283-79592-11-git-send-email-wangnan0@huawei.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 1669e509ea25e4e3e871d913d21b1cac4a96d1e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-stat.c
#	tools/perf/util/parse-events.c
diff --cc tools/perf/builtin-stat.c
index 59a81f0ac2bd,8c0bc0fe5179..000000000000
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@@ -1222,8 -1831,24 +1222,29 @@@ int cmd_stat(int argc, const char **arg
  	if (evsel_list == NULL)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	argc = parse_options(argc, argv, options, stat_usage,
 +		PARSE_OPT_STOP_AT_NON_OPTION);
++=======
+ 	parse_events__shrink_config_terms();
+ 	argc = parse_options_subcommand(argc, argv, stat_options, stat_subcommands,
+ 					(const char **) stat_usage,
+ 					PARSE_OPT_STOP_AT_NON_OPTION);
+ 
+ 	if (csv_sep) {
+ 		csv_output = true;
+ 		if (!strcmp(csv_sep, "\\t"))
+ 			csv_sep = "\t";
+ 	} else
+ 		csv_sep = DEFAULT_SEPARATOR;
+ 
+ 	if (argc && !strncmp(argv[0], "rec", 3)) {
+ 		argc = __cmd_record(argc, argv);
+ 		if (argc < 0)
+ 			return -1;
+ 	} else if (argc && !strncmp(argv[0], "rep", 3))
+ 		return __cmd_report(argc, argv);
++>>>>>>> 1669e509ea25 (perf stat: Bail out on unsupported event config modifiers)
  
  	interval = stat_config.interval;
  
diff --cc tools/perf/util/parse-events.c
index ee3541614df9,eb5df43ec68f..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -596,9 -746,67 +596,73 @@@ static int check_type_val(struct parse_
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
 +static int config_term(struct perf_event_attr *attr,
 +		       struct parse_events_term *term,
 +		       struct parse_events_error *err)
++=======
+ /*
+  * Update according to parse-events.l
+  */
+ static const char *config_term_names[__PARSE_EVENTS__TERM_TYPE_NR] = {
+ 	[PARSE_EVENTS__TERM_TYPE_USER]			= "<sysfs term>",
+ 	[PARSE_EVENTS__TERM_TYPE_CONFIG]		= "config",
+ 	[PARSE_EVENTS__TERM_TYPE_CONFIG1]		= "config1",
+ 	[PARSE_EVENTS__TERM_TYPE_CONFIG2]		= "config2",
+ 	[PARSE_EVENTS__TERM_TYPE_NAME]			= "name",
+ 	[PARSE_EVENTS__TERM_TYPE_SAMPLE_PERIOD]		= "period",
+ 	[PARSE_EVENTS__TERM_TYPE_SAMPLE_FREQ]		= "freq",
+ 	[PARSE_EVENTS__TERM_TYPE_BRANCH_SAMPLE_TYPE]	= "branch_type",
+ 	[PARSE_EVENTS__TERM_TYPE_TIME]			= "time",
+ 	[PARSE_EVENTS__TERM_TYPE_CALLGRAPH]		= "call-graph",
+ 	[PARSE_EVENTS__TERM_TYPE_STACKSIZE]		= "stack-size",
+ 	[PARSE_EVENTS__TERM_TYPE_NOINHERIT]		= "no-inherit",
+ 	[PARSE_EVENTS__TERM_TYPE_INHERIT]		= "inherit",
+ };
+ 
+ static bool config_term_shrinked;
+ 
+ static bool
+ config_term_avail(int term_type, struct parse_events_error *err)
+ {
+ 	if (term_type < 0 || term_type >= __PARSE_EVENTS__TERM_TYPE_NR) {
+ 		err->str = strdup("Invalid term_type");
+ 		return false;
+ 	}
+ 	if (!config_term_shrinked)
+ 		return true;
+ 
+ 	switch (term_type) {
+ 	case PARSE_EVENTS__TERM_TYPE_CONFIG:
+ 	case PARSE_EVENTS__TERM_TYPE_CONFIG1:
+ 	case PARSE_EVENTS__TERM_TYPE_CONFIG2:
+ 	case PARSE_EVENTS__TERM_TYPE_NAME:
+ 		return true;
+ 	default:
+ 		if (!err)
+ 			return false;
+ 
+ 		/* term_type is validated so indexing is safe */
+ 		if (asprintf(&err->str, "'%s' is not usable in 'perf stat'",
+ 			     config_term_names[term_type]) < 0)
+ 			err->str = NULL;
+ 		return false;
+ 	}
+ }
+ 
+ void parse_events__shrink_config_terms(void)
+ {
+ 	config_term_shrinked = true;
+ }
+ 
+ typedef int config_term_func_t(struct perf_event_attr *attr,
+ 			       struct parse_events_term *term,
+ 			       struct parse_events_error *err);
+ 
+ static int config_term_common(struct perf_event_attr *attr,
+ 			      struct parse_events_term *term,
+ 			      struct parse_events_error *err)
++>>>>>>> 1669e509ea25 (perf stat: Bail out on unsupported event config modifiers)
  {
  #define CHECK_TYPE_VAL(type)						   \
  do {									   \
@@@ -1798,3 -2161,57 +1873,60 @@@ void parse_events_evlist_error(struct p
  	err->str = strdup(str);
  	WARN_ONCE(!err->str, "WARNING: failed to allocate error string");
  }
++<<<<<<< HEAD
++=======
+ 
+ static void config_terms_list(char *buf, size_t buf_sz)
+ {
+ 	int i;
+ 	bool first = true;
+ 
+ 	buf[0] = '\0';
+ 	for (i = 0; i < __PARSE_EVENTS__TERM_TYPE_NR; i++) {
+ 		const char *name = config_term_names[i];
+ 
+ 		if (!config_term_avail(i, NULL))
+ 			continue;
+ 		if (!name)
+ 			continue;
+ 		if (name[0] == '<')
+ 			continue;
+ 
+ 		if (strlen(buf) + strlen(name) + 2 >= buf_sz)
+ 			return;
+ 
+ 		if (!first)
+ 			strcat(buf, ",");
+ 		else
+ 			first = false;
+ 		strcat(buf, name);
+ 	}
+ }
+ 
+ /*
+  * Return string contains valid config terms of an event.
+  * @additional_terms: For terms such as PMU sysfs terms.
+  */
+ char *parse_events_formats_error_string(char *additional_terms)
+ {
+ 	char *str;
+ 	/* "branch_type" is the longest name */
+ 	char static_terms[__PARSE_EVENTS__TERM_TYPE_NR *
+ 			  (sizeof("branch_type") - 1)];
+ 
+ 	config_terms_list(static_terms, sizeof(static_terms));
+ 	/* valid terms */
+ 	if (additional_terms) {
+ 		if (asprintf(&str, "valid terms: %s,%s",
+ 			     additional_terms, static_terms) < 0)
+ 			goto fail;
+ 	} else {
+ 		if (asprintf(&str, "valid terms: %s", static_terms) < 0)
+ 			goto fail;
+ 	}
+ 	return str;
+ 
+ fail:
+ 	return NULL;
+ }
++>>>>>>> 1669e509ea25 (perf stat: Bail out on unsupported event config modifiers)
* Unmerged path tools/perf/builtin-stat.c
* Unmerged path tools/perf/util/parse-events.c
diff --git a/tools/perf/util/parse-events.h b/tools/perf/util/parse-events.h
index 8417467c7342..ecfc219a0033 100644
--- a/tools/perf/util/parse-events.h
+++ b/tools/perf/util/parse-events.h
@@ -98,6 +98,7 @@ struct parse_events_terms {
 	struct list_head *terms;
 };
 
+void parse_events__shrink_config_terms(void);
 int parse_events__is_hardcoded_term(struct parse_events_term *term);
 int parse_events_term__num(struct parse_events_term **term,
 			   int type_term, char *config, u64 num,
