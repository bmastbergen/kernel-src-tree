xfs: fix xfs_error_get_cfg for negative errnos

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Eric Sandeen <sandeen@redhat.com>
commit e97f6c545f963abd7de56a58a29ba73a9edee015
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e97f6c54.failed

xfs_error_get_cfg() is called with bp->b_error as an arg, which is
negative, so the switch statement won't ever find any matches.

This results in only the default error handler having any effect, as
EIO/ENOSPC/ENODEV get ignored due to the wrong sign.

It seems simplest to always flip the error sign to positive, so that
we can handle either negative errors in bp->b_error, or possibly a
positive errno via something like xfs_error_get_cfg(EIO) - this
future-proofs the function.

	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Carlos Maiolino <cmaiolino@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit e97f6c545f963abd7de56a58a29ba73a9edee015)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_sysfs.c
diff --cc fs/xfs/xfs_sysfs.c
index 641d625eb334,79cfd3fc5324..000000000000
--- a/fs/xfs/xfs_sysfs.c
+++ b/fs/xfs/xfs_sysfs.c
@@@ -304,3 -363,294 +304,297 @@@ struct kobj_type xfs_log_ktype = 
  	.sysfs_ops = &xfs_sysfs_ops,
  	.default_attrs = xfs_log_attrs,
  };
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Metadata IO error configuration
+  *
+  * The sysfs structure here is:
+  *	...xfs/<dev>/error/<class>/<errno>/<error_attrs>
+  *
+  * where <class> allows us to discriminate between data IO and metadata IO,
+  * and any other future type of IO (e.g. special inode or directory error
+  * handling) we care to support.
+  */
+ static inline struct xfs_error_cfg *
+ to_error_cfg(struct kobject *kobject)
+ {
+ 	struct xfs_kobj *kobj = to_kobj(kobject);
+ 	return container_of(kobj, struct xfs_error_cfg, kobj);
+ }
+ 
+ static inline struct xfs_mount *
+ err_to_mp(struct kobject *kobject)
+ {
+ 	struct xfs_kobj *kobj = to_kobj(kobject);
+ 	return container_of(kobj, struct xfs_mount, m_error_kobj);
+ }
+ 
+ static ssize_t
+ max_retries_show(
+ 	struct kobject	*kobject,
+ 	char		*buf)
+ {
+ 	struct xfs_error_cfg *cfg = to_error_cfg(kobject);
+ 
+ 	return snprintf(buf, PAGE_SIZE, "%d\n", cfg->max_retries);
+ }
+ 
+ static ssize_t
+ max_retries_store(
+ 	struct kobject	*kobject,
+ 	const char	*buf,
+ 	size_t		count)
+ {
+ 	struct xfs_error_cfg *cfg = to_error_cfg(kobject);
+ 	int		ret;
+ 	int		val;
+ 
+ 	ret = kstrtoint(buf, 0, &val);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (val < -1)
+ 		return -EINVAL;
+ 
+ 	cfg->max_retries = val;
+ 	return count;
+ }
+ XFS_SYSFS_ATTR_RW(max_retries);
+ 
+ static ssize_t
+ retry_timeout_seconds_show(
+ 	struct kobject	*kobject,
+ 	char		*buf)
+ {
+ 	struct xfs_error_cfg *cfg = to_error_cfg(kobject);
+ 
+ 	return snprintf(buf, PAGE_SIZE, "%ld\n",
+ 			jiffies_to_msecs(cfg->retry_timeout) / MSEC_PER_SEC);
+ }
+ 
+ static ssize_t
+ retry_timeout_seconds_store(
+ 	struct kobject	*kobject,
+ 	const char	*buf,
+ 	size_t		count)
+ {
+ 	struct xfs_error_cfg *cfg = to_error_cfg(kobject);
+ 	int		ret;
+ 	int		val;
+ 
+ 	ret = kstrtoint(buf, 0, &val);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* 1 day timeout maximum */
+ 	if (val < 0 || val > 86400)
+ 		return -EINVAL;
+ 
+ 	cfg->retry_timeout = msecs_to_jiffies(val * MSEC_PER_SEC);
+ 	return count;
+ }
+ XFS_SYSFS_ATTR_RW(retry_timeout_seconds);
+ 
+ static ssize_t
+ fail_at_unmount_show(
+ 	struct kobject	*kobject,
+ 	char		*buf)
+ {
+ 	struct xfs_mount	*mp = err_to_mp(kobject);
+ 
+ 	return snprintf(buf, PAGE_SIZE, "%d\n", mp->m_fail_unmount);
+ }
+ 
+ static ssize_t
+ fail_at_unmount_store(
+ 	struct kobject	*kobject,
+ 	const char	*buf,
+ 	size_t		count)
+ {
+ 	struct xfs_mount	*mp = err_to_mp(kobject);
+ 	int		ret;
+ 	int		val;
+ 
+ 	ret = kstrtoint(buf, 0, &val);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (val < 0 || val > 1)
+ 		return -EINVAL;
+ 
+ 	mp->m_fail_unmount = val;
+ 	return count;
+ }
+ XFS_SYSFS_ATTR_RW(fail_at_unmount);
+ 
+ static struct attribute *xfs_error_attrs[] = {
+ 	ATTR_LIST(max_retries),
+ 	ATTR_LIST(retry_timeout_seconds),
+ 	NULL,
+ };
+ 
+ 
+ struct kobj_type xfs_error_cfg_ktype = {
+ 	.release = xfs_sysfs_release,
+ 	.sysfs_ops = &xfs_sysfs_ops,
+ 	.default_attrs = xfs_error_attrs,
+ };
+ 
+ struct kobj_type xfs_error_ktype = {
+ 	.release = xfs_sysfs_release,
+ 	.sysfs_ops = &xfs_sysfs_ops,
+ };
+ 
+ /*
+  * Error initialization tables. These need to be ordered in the same
+  * order as the enums used to index the array. All class init tables need to
+  * define a "default" behaviour as the first entry, all other entries can be
+  * empty.
+  */
+ struct xfs_error_init {
+ 	char		*name;
+ 	int		max_retries;
+ 	int		retry_timeout;	/* in seconds */
+ };
+ 
+ static const struct xfs_error_init xfs_error_meta_init[XFS_ERR_ERRNO_MAX] = {
+ 	{ .name = "default",
+ 	  .max_retries = XFS_ERR_RETRY_FOREVER,
+ 	  .retry_timeout = 0,
+ 	},
+ 	{ .name = "EIO",
+ 	  .max_retries = XFS_ERR_RETRY_FOREVER,
+ 	  .retry_timeout = 0,
+ 	},
+ 	{ .name = "ENOSPC",
+ 	  .max_retries = XFS_ERR_RETRY_FOREVER,
+ 	  .retry_timeout = 0,
+ 	},
+ 	{ .name = "ENODEV",
+ 	  .max_retries = 0,
+ 	},
+ };
+ 
+ static int
+ xfs_error_sysfs_init_class(
+ 	struct xfs_mount	*mp,
+ 	int			class,
+ 	const char		*parent_name,
+ 	struct xfs_kobj		*parent_kobj,
+ 	const struct xfs_error_init init[])
+ {
+ 	struct xfs_error_cfg	*cfg;
+ 	int			error;
+ 	int			i;
+ 
+ 	ASSERT(class < XFS_ERR_CLASS_MAX);
+ 
+ 	error = xfs_sysfs_init(parent_kobj, &xfs_error_ktype,
+ 				&mp->m_error_kobj, parent_name);
+ 	if (error)
+ 		return error;
+ 
+ 	for (i = 0; i < XFS_ERR_ERRNO_MAX; i++) {
+ 		cfg = &mp->m_error_cfg[class][i];
+ 		error = xfs_sysfs_init(&cfg->kobj, &xfs_error_cfg_ktype,
+ 					parent_kobj, init[i].name);
+ 		if (error)
+ 			goto out_error;
+ 
+ 		cfg->max_retries = init[i].max_retries;
+ 		cfg->retry_timeout = msecs_to_jiffies(
+ 					init[i].retry_timeout * MSEC_PER_SEC);
+ 	}
+ 	return 0;
+ 
+ out_error:
+ 	/* unwind the entries that succeeded */
+ 	for (i--; i >= 0; i--) {
+ 		cfg = &mp->m_error_cfg[class][i];
+ 		xfs_sysfs_del(&cfg->kobj);
+ 	}
+ 	xfs_sysfs_del(parent_kobj);
+ 	return error;
+ }
+ 
+ int
+ xfs_error_sysfs_init(
+ 	struct xfs_mount	*mp)
+ {
+ 	int			error;
+ 
+ 	/* .../xfs/<dev>/error/ */
+ 	error = xfs_sysfs_init(&mp->m_error_kobj, &xfs_error_ktype,
+ 				&mp->m_kobj, "error");
+ 	if (error)
+ 		return error;
+ 
+ 	error = sysfs_create_file(&mp->m_error_kobj.kobject,
+ 				  ATTR_LIST(fail_at_unmount));
+ 
+ 	if (error)
+ 		goto out_error;
+ 
+ 	/* .../xfs/<dev>/error/metadata/ */
+ 	error = xfs_error_sysfs_init_class(mp, XFS_ERR_METADATA,
+ 				"metadata", &mp->m_error_meta_kobj,
+ 				xfs_error_meta_init);
+ 	if (error)
+ 		goto out_error;
+ 
+ 	return 0;
+ 
+ out_error:
+ 	xfs_sysfs_del(&mp->m_error_kobj);
+ 	return error;
+ }
+ 
+ void
+ xfs_error_sysfs_del(
+ 	struct xfs_mount	*mp)
+ {
+ 	struct xfs_error_cfg	*cfg;
+ 	int			i, j;
+ 
+ 	for (i = 0; i < XFS_ERR_CLASS_MAX; i++) {
+ 		for (j = 0; j < XFS_ERR_ERRNO_MAX; j++) {
+ 			cfg = &mp->m_error_cfg[i][j];
+ 
+ 			xfs_sysfs_del(&cfg->kobj);
+ 		}
+ 	}
+ 	xfs_sysfs_del(&mp->m_error_meta_kobj);
+ 	xfs_sysfs_del(&mp->m_error_kobj);
+ }
+ 
+ struct xfs_error_cfg *
+ xfs_error_get_cfg(
+ 	struct xfs_mount	*mp,
+ 	int			error_class,
+ 	int			error)
+ {
+ 	struct xfs_error_cfg	*cfg;
+ 
+ 	if (error < 0)
+ 		error = -error;
+ 
+ 	switch (error) {
+ 	case EIO:
+ 		cfg = &mp->m_error_cfg[error_class][XFS_ERR_EIO];
+ 		break;
+ 	case ENOSPC:
+ 		cfg = &mp->m_error_cfg[error_class][XFS_ERR_ENOSPC];
+ 		break;
+ 	case ENODEV:
+ 		cfg = &mp->m_error_cfg[error_class][XFS_ERR_ENODEV];
+ 		break;
+ 	default:
+ 		cfg = &mp->m_error_cfg[error_class][XFS_ERR_DEFAULT];
+ 		break;
+ 	}
+ 
+ 	return cfg;
+ }
++>>>>>>> e97f6c545f96 (xfs: fix xfs_error_get_cfg for negative errnos)
* Unmerged path fs/xfs/xfs_sysfs.c
