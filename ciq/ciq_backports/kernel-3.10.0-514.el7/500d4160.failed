HID: wacom: add support for Cintiq 27QHD and 27QHD touch

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Ping Cheng <pinglinux@gmail.com>
commit 500d4160abe9a2e88b12e319c13ae3ebd1e18108
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/500d4160.failed

These devices have accelerometers. To report accelerometer coordinates, a new
property, INPUT_PROP_ACCELEROMETER, is added.

	Signed-off-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 500d4160abe9a2e88b12e319c13ae3ebd1e18108)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
#	drivers/input/tablet/wacom_wac.c
#	drivers/input/tablet/wacom_wac.h
diff --cc drivers/input/tablet/wacom_wac.c
index 1148f237b068,1a6507999a65..000000000000
--- a/drivers/input/tablet/wacom_wac.c
+++ b/drivers/input/tablet/wacom_wac.c
@@@ -529,7 -669,9 +531,13 @@@ static int wacom_intuos_irq(struct waco
  		idx = data[1] & 0x01;
  
  	/* pad packets. Works as a second tool and is always in prox */
++<<<<<<< HEAD:drivers/input/tablet/wacom_wac.c
 +	if (data[0] == WACOM_REPORT_INTUOSPAD || data[0] == WACOM_REPORT_INTUOS5PAD) {
++=======
+ 	if (data[0] == WACOM_REPORT_INTUOSPAD || data[0] == WACOM_REPORT_INTUOS5PAD ||
+ 	    data[0] == WACOM_REPORT_CINTIQPAD) {
+ 		input = wacom->pad_input;
++>>>>>>> 500d4160abe9 (HID: wacom: add support for Cintiq 27QHD and 27QHD touch):drivers/hid/wacom_wac.c
  		if (features->type >= INTUOS4S && features->type <= INTUOS4L) {
  			input_report_key(input, BTN_0, (data[2] & 0x01));
  			input_report_key(input, BTN_1, (data[3] & 0x01));
@@@ -628,6 -770,36 +636,39 @@@
  			} else {
  				input_report_abs(input, ABS_MISC, 0);
  			}
++<<<<<<< HEAD:drivers/input/tablet/wacom_wac.c
++=======
+ 		} else if (features->type == WACOM_27QHD) {
+ 			input_report_key(input, KEY_PROG1, data[2] & 0x01);
+ 			input_report_key(input, KEY_PROG2, data[2] & 0x02);
+ 			input_report_key(input, KEY_PROG3, data[2] & 0x04);
+ 
+ 			input_report_abs(input, ABS_X, be16_to_cpup((__be16 *)&data[4]));
+ 			input_report_abs(input, ABS_Y, be16_to_cpup((__be16 *)&data[6]));
+ 			input_report_abs(input, ABS_Z, be16_to_cpup((__be16 *)&data[8]));
+ 		} else if (features->type == CINTIQ_HYBRID) {
+ 			/*
+ 			 * Do not send hardware buttons under Android. They
+ 			 * are already sent to the system through GPIO (and
+ 			 * have different meaning).
+ 			 */
+ 			input_report_key(input, BTN_1, (data[4] & 0x01));
+ 			input_report_key(input, BTN_2, (data[4] & 0x02));
+ 			input_report_key(input, BTN_3, (data[4] & 0x04));
+ 			input_report_key(input, BTN_4, (data[4] & 0x08));
+ 
+ 			input_report_key(input, BTN_5, (data[4] & 0x10));  /* Right  */
+ 			input_report_key(input, BTN_6, (data[4] & 0x20));  /* Up     */
+ 			input_report_key(input, BTN_7, (data[4] & 0x40));  /* Left   */
+ 			input_report_key(input, BTN_8, (data[4] & 0x80));  /* Down   */
+ 			input_report_key(input, BTN_0, (data[3] & 0x01));  /* Center */
+ 
+ 			if (data[4] | (data[3] & 0x01)) {
+ 				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
+ 			} else {
+ 				input_report_abs(input, ABS_MISC, 0);
+ 			}
++>>>>>>> 500d4160abe9 (HID: wacom: add support for Cintiq 27QHD and 27QHD touch):drivers/hid/wacom_wac.c
  		} else if (features->type >= INTUOS5S && features->type <= INTUOSPL) {
  			int i;
  
@@@ -834,10 -984,74 +875,22 @@@ static int int_dist(int x1, int y1, in
  static int wacom_24hdt_irq(struct wacom_wac *wacom)
  {
  	struct input_dev *input = wacom->input;
 -	unsigned char *data = wacom->data;
 +	char *data = wacom->data;
  	int i;
- 	int current_num_contacts = data[61];
+ 	int current_num_contacts = 0;
  	int contacts_to_send = 0;
+ 	int num_contacts_left = 4; /* maximum contacts per packet */
+ 	int byte_per_packet = WACOM_BYTES_PER_24HDT_PACKET;
+ 	int y_offset = 2;
+ 
+ 	if (wacom->features.type == WACOM_27QHDT) {
+ 		current_num_contacts = data[63];
+ 		num_contacts_left = 10;
+ 		byte_per_packet = WACOM_BYTES_PER_QHDTHID_PACKET;
+ 		y_offset = 0;
+ 	} else {
+ 		current_num_contacts = data[61];
+ 	}
  
  	/*
  	 * First packet resets the counter since only the first
@@@ -846,12 -1060,11 +899,16 @@@
  	if (current_num_contacts)
  		wacom->num_contacts_left = current_num_contacts;
  
- 	/* There are at most 4 contacts per packet */
- 	contacts_to_send = min(4, wacom->num_contacts_left);
+ 	contacts_to_send = min(num_contacts_left, wacom->num_contacts_left);
  
  	for (i = 0; i < contacts_to_send; i++) {
++<<<<<<< HEAD:drivers/input/tablet/wacom_wac.c
 +		int offset = (WACOM_BYTES_PER_24HDT_PACKET * i) + 1;
 +		bool touch = data[offset] & 0x1 && !wacom->shared->stylus_in_proximity;
++=======
+ 		int offset = (byte_per_packet * i) + 1;
+ 		bool touch = (data[offset] & 0x1) && !wacom->shared->stylus_in_proximity;
++>>>>>>> 500d4160abe9 (HID: wacom: add support for Cintiq 27QHD and 27QHD touch):drivers/hid/wacom_wac.c
  		int slot = input_mt_get_slot_by_key(input, data[offset + 1]);
  
  		if (slot < 0)
@@@ -860,12 -1073,8 +917,17 @@@
  		input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);
  
  		if (touch) {
++<<<<<<< HEAD:drivers/input/tablet/wacom_wac.c
 +			int t_x = le16_to_cpup((__le16 *)&data[offset + 2]);
 +			int c_x = le16_to_cpup((__le16 *)&data[offset + 4]);
 +			int t_y = le16_to_cpup((__le16 *)&data[offset + 6]);
 +			int c_y = le16_to_cpup((__le16 *)&data[offset + 8]);
 +			int w = le16_to_cpup((__le16 *)&data[offset + 10]);
 +			int h = le16_to_cpup((__le16 *)&data[offset + 12]);
++=======
+ 			int t_x = get_unaligned_le16(&data[offset + 2]);
+ 			int t_y = get_unaligned_le16(&data[offset + 4 + y_offset]);
++>>>>>>> 500d4160abe9 (HID: wacom: add support for Cintiq 27QHD and 27QHD touch):drivers/hid/wacom_wac.c
  
  			input_report_abs(input, ABS_MT_POSITION_X, t_x);
  			input_report_abs(input, ABS_MT_POSITION_Y, t_y);
@@@ -1345,11 -1921,18 +1416,13 @@@ void wacom_wac_irq(struct wacom_wac *wa
  	case WACOM_21UX2:
  	case WACOM_22HD:
  	case WACOM_24HD:
+ 	case WACOM_27QHD:
  	case DTK:
 -	case CINTIQ_HYBRID:
  		sync = wacom_intuos_irq(wacom_wac);
  		break;
  
 -	case INTUOS4WL:
 -		sync = wacom_intuos_bt_irq(wacom_wac, len);
 -		break;
 -
  	case WACOM_24HDT:
+ 	case WACOM_27QHDT:
  		sync = wacom_24hdt_irq(wacom_wac);
  		break;
  
@@@ -1549,7 -2144,205 +1622,208 @@@ int wacom_setup_input_capabilities(stru
  		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
  		break;
  
+ 	case WACOM_27QHD:
  	case WACOM_24HD:
++<<<<<<< HEAD:drivers/input/tablet/wacom_wac.c
++=======
+ 	case DTK:
+ 	case WACOM_22HD:
+ 	case WACOM_21UX2:
+ 	case WACOM_BEE:
+ 	case CINTIQ:
+ 	case WACOM_13HD:
+ 	case CINTIQ_HYBRID:
+ 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 287);
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 		wacom_setup_cintiq(wacom_wac);
+ 		break;
+ 
+ 	case INTUOS3:
+ 	case INTUOS3L:
+ 	case INTUOS3S:
+ 	case INTUOS4:
+ 	case INTUOS4WL:
+ 	case INTUOS4L:
+ 	case INTUOS4S:
+ 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 287);
+ 		/* fall through */
+ 
+ 	case INTUOS:
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 		wacom_setup_intuos(wacom_wac);
+ 		break;
+ 
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 		if (features->device_type == BTN_TOOL_PEN) {
+ 			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
+ 					      features->distance_max,
+ 					      0, 0);
+ 
+ 			input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 			input_abs_set_res(input_dev, ABS_Z, 287);
+ 
+ 			wacom_setup_intuos(wacom_wac);
+ 		} else if (features->device_type == BTN_TOOL_FINGER) {
+ 			__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 			input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,
+ 			                     0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR,
+ 			                     0, features->y_max, 0, 0);
+ 			input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 		}
+ 		break;
+ 
+ 	case WACOM_24HDT:
+ 		if (features->device_type == BTN_TOOL_FINGER) {
+ 			input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);
+ 		}
+ 		/* fall through */
+ 
+ 	case WACOM_27QHDT:
+ 	case MTSCREEN:
+ 	case MTTPC:
+ 	case MTTPC_B:
+ 	case TABLETPC2FG:
+ 		if (features->device_type == BTN_TOOL_FINGER && features->touch_max > 1)
+ 			input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_DIRECT);
+ 		/* fall through */
+ 
+ 	case TABLETPC:
+ 	case TABLETPCE:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 
+ 		if (features->device_type != BTN_TOOL_PEN)
+ 			break;  /* no need to process stylus stuff */
+ 
+ 		/* fall through */
+ 
+ 	case DTUS:
+ 	case DTUSX:
+ 	case PL:
+ 	case DTU:
+ 		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 		break;
+ 
+ 	case PTU:
+ 		__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case PENPARTNER:
+ 		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 		break;
+ 
+ 	case INTUOSHT:
+ 		if (features->touch_max &&
+ 		    features->device_type == BTN_TOOL_FINGER) {
+ 			input_dev->evbit[0] |= BIT_MASK(EV_SW);
+ 			__set_bit(SW_MUTE_DEVICE, input_dev->swbit);
+ 		}
+ 		/* fall through */
+ 
+ 	case BAMBOO_PT:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 		if (features->device_type == BTN_TOOL_FINGER) {
+ 
+ 			if (features->touch_max) {
+ 				if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
+ 					input_set_abs_params(input_dev,
+ 						     ABS_MT_TOUCH_MAJOR,
+ 						     0, features->x_max, 0, 0);
+ 					input_set_abs_params(input_dev,
+ 						     ABS_MT_TOUCH_MINOR,
+ 						     0, features->y_max, 0, 0);
+ 				}
+ 				input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 			} else {
+ 				/* buttons/keys only interface */
+ 				__clear_bit(ABS_X, input_dev->absbit);
+ 				__clear_bit(ABS_Y, input_dev->absbit);
+ 				__clear_bit(BTN_TOUCH, input_dev->keybit);
+ 
+ 				/* PAD is setup by wacom_setup_pad_input_capabilities later */
+ 				return 1;
+ 			}
+ 		} else if (features->device_type == BTN_TOOL_PEN) {
+ 			__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 			__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 			__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 			__set_bit(BTN_STYLUS, input_dev->keybit);
+ 			__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
+ 					      features->distance_max,
+ 					      0, 0);
+ 		}
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
+ 				   struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	int i;
+ 
+ 	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+ 
+ 	/* kept for making legacy xf86-input-wacom working with the wheels */
+ 	__set_bit(ABS_MISC, input_dev->absbit);
+ 
+ 	/* kept for making legacy xf86-input-wacom accepting the pad */
+ 	input_set_abs_params(input_dev, ABS_X, 0, 1, 0, 0);
+ 	input_set_abs_params(input_dev, ABS_Y, 0, 1, 0, 0);
+ 
+ 	/* kept for making udev and libwacom accepting the pad */
+ 	__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 	switch (features->type) {
+ 	case GRAPHIRE_BT:
+ 		__set_bit(BTN_0, input_dev->keybit);
+ 		__set_bit(BTN_1, input_dev->keybit);
+ 		break;
+ 
+ 	case WACOM_MO:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_G4:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		input_set_capability(input_dev, EV_REL, REL_WHEEL);
+ 		break;
+ 
+ 	case WACOM_24HD:
++>>>>>>> 500d4160abe9 (HID: wacom: add support for Cintiq 27QHD and 27QHD touch):drivers/hid/wacom_wac.c
  		__set_bit(BTN_A, input_dev->keybit);
  		__set_bit(BTN_B, input_dev->keybit);
  		__set_bit(BTN_C, input_dev->keybit);
@@@ -1564,10 -2357,23 +1838,23 @@@
  		__set_bit(KEY_PROG2, input_dev->keybit);
  		__set_bit(KEY_PROG3, input_dev->keybit);
  
 -		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
 +		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
  		input_set_abs_params(input_dev, ABS_THROTTLE, 0, 71, 0, 0);
 -		break;
 +		/* fall through */
  
+ 	case WACOM_27QHD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_X, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_X, 1024); /* points/g */
+ 		input_set_abs_params(input_dev, ABS_Y, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Y, 1024);
+ 		input_set_abs_params(input_dev, ABS_Z, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 1024);
+ 		__set_bit(INPUT_PROP_ACCELEROMETER, input_dev->propbit);
+ 		break;
+ 
  	case DTK:
  		for (i = 0; i < 6; i++)
  			__set_bit(BTN_0 + i, input_dev->keybit);
@@@ -1998,34 -2722,59 +2285,51 @@@ static const struct wacom_features waco
  	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0xf6 };
  static const struct wacom_features wacom_features_0xF6 =
  	{ "Wacom Cintiq 24HD touch", .type = WACOM_24HDT, /* Touch */
++<<<<<<< HEAD:drivers/input/tablet/wacom_wac.c
 +	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0xf8, .touch_max = 10 };
++=======
+ 	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0xf8, .touch_max = 10,
+ 	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
+ static const struct wacom_features wacom_features_0x32A =
+ 	{ "Wacom Cintiq 27QHD", 119740, 67520, 2047,
+ 	  63, WACOM_27QHD, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES,
+ 	  WACOM_27QHD, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES };
+ static const struct wacom_features wacom_features_0x32B =
+ 	{ "Wacom Cintiq 27QHD touch", 119740, 67520, 2047, 63,
+ 	  WACOM_27QHD, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES,
+ 	  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,
+ 	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x32C };
+ static const struct wacom_features wacom_features_0x32C =
+ 	{ "Wacom Cintiq 27QHD touch", .type = WACOM_27QHDT,
+ 	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x32B, .touch_max = 10 };
++>>>>>>> 500d4160abe9 (HID: wacom: add support for Cintiq 27QHD and 27QHD touch):drivers/hid/wacom_wac.c
  static const struct wacom_features wacom_features_0x3F =
 -	{ "Wacom Cintiq 21UX", 87200, 65600, 1023, 63,
 -	  CINTIQ, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES };
 +	{ "Wacom Cintiq 21UX",    WACOM_PKGLEN_INTUOS,    87200, 65600, 1023,
 +	  63, CINTIQ, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES };
  static const struct wacom_features wacom_features_0xC5 =
 -	{ "Wacom Cintiq 20WSX", 86680, 54180, 1023, 63,
 -	  WACOM_BEE, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES };
 +	{ "Wacom Cintiq 20WSX",   WACOM_PKGLEN_INTUOS,    86680, 54180, 1023,
 +	  63, WACOM_BEE, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES };
  static const struct wacom_features wacom_features_0xC6 =
 -	{ "Wacom Cintiq 12WX", 53020, 33440, 1023, 63,
 -	  WACOM_BEE, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES };
 +	{ "Wacom Cintiq 12WX",    WACOM_PKGLEN_INTUOS,    53020, 33440, 1023,
 +	  63, WACOM_BEE, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES };
  static const struct wacom_features wacom_features_0x304 =
 -	{ "Wacom Cintiq 13HD", 59152, 33448, 1023, 63,
 -	  WACOM_13HD, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES,
 -	  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET };
 +	{ "Wacom Cintiq 13HD",    WACOM_PKGLEN_INTUOS,    59552, 33848, 1023,
 +	  63, WACOM_13HD, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES };
  static const struct wacom_features wacom_features_0xC7 =
 -	{ "Wacom DTU1931", 37832, 30305, 511, 0,
 -	  PL, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom DTU1931",        WACOM_PKGLEN_GRAPHIRE,  37832, 30305,  511,
 +	  0, PL, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xCE =
 -	{ "Wacom DTU2231", 47864, 27011, 511, 0,
 -	  DTU, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 -	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBMOUSE };
 +	{ "Wacom DTU2231",        WACOM_PKGLEN_GRAPHIRE,  47864, 27011,  511,
 +	  0, DTU, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xF0 =
 -	{ "Wacom DTU1631", 34623, 19553, 511, 0,
 -	  DTU, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0xFB =
 -	{ "Wacom DTU1031", 21896, 13760, 511, 0,
 -	  DTUS, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 -	  WACOM_DTU_OFFSET, WACOM_DTU_OFFSET };
 -static const struct wacom_features wacom_features_0x32F =
 -	{ "Wacom DTU1031X", 22472, 12728, 511, 0,
 -	  DTUSX, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 -	  WACOM_DTU_OFFSET, WACOM_DTU_OFFSET };
 +	{ "Wacom DTU1631",        WACOM_PKGLEN_GRAPHIRE,  34623, 19553,  511,
 +	  0, DTU, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x57 =
 -	{ "Wacom DTK2241", 95640, 54060, 2047, 63,
 -	  DTK, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES,
 -	  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET };
 +	{ "Wacom DTK2241",        WACOM_PKGLEN_INTUOS,    95840, 54260, 2047,
 +	  63, DTK, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES};
  static const struct wacom_features wacom_features_0x59 = /* Pen */
 -	{ "Wacom DTH2242", 95640, 54060, 2047, 63,
 -	  DTK, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES,
 -	  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,
 +	{ "Wacom DTH2242",        WACOM_PKGLEN_INTUOS,    95840, 54260, 2047,
 +	  63, DTK, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES,
  	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x5D };
  static const struct wacom_features wacom_features_0x5D = /* Touch */
  	{ "Wacom DTH2242",       .type = WACOM_24HDT,
@@@ -2279,17 -3078,41 +2583,33 @@@ const struct usb_device_id wacom_ids[] 
  	{ USB_DEVICE_WACOM(0x100) },
  	{ USB_DEVICE_WACOM(0x101) },
  	{ USB_DEVICE_WACOM(0x10D) },
 -	{ USB_DEVICE_WACOM(0x10E) },
 -	{ USB_DEVICE_WACOM(0x10F) },
 -	{ USB_DEVICE_WACOM(0x116) },
 -	{ USB_DEVICE_WACOM(0x12C) },
 -	{ USB_DEVICE_WACOM(0x300) },
 -	{ USB_DEVICE_WACOM(0x301) },
 -	{ USB_DEVICE_WACOM(0x302) },
 -	{ USB_DEVICE_WACOM(0x303) },
  	{ USB_DEVICE_WACOM(0x304) },
++<<<<<<< HEAD:drivers/input/tablet/wacom_wac.c
 +	{ USB_DEVICE_DETAILED(0x314, USB_CLASS_HID, 0, 0) },
 +	{ USB_DEVICE_DETAILED(0x315, USB_CLASS_HID, 0, 0) },
 +	{ USB_DEVICE_DETAILED(0x317, USB_CLASS_HID, 0, 0) },
++=======
+ 	{ USB_DEVICE_WACOM(0x307) },
+ 	{ USB_DEVICE_WACOM(0x309) },
+ 	{ USB_DEVICE_WACOM(0x30A) },
+ 	{ USB_DEVICE_WACOM(0x30C) },
+ 	{ USB_DEVICE_WACOM(0x30E) },
+ 	{ USB_DEVICE_WACOM(0x314) },
+ 	{ USB_DEVICE_WACOM(0x315) },
+ 	{ USB_DEVICE_WACOM(0x317) },
+ 	{ USB_DEVICE_WACOM(0x323) },
+ 	{ USB_DEVICE_WACOM(0x32A) },
+ 	{ USB_DEVICE_WACOM(0x32B) },
+ 	{ USB_DEVICE_WACOM(0x32C) },
+ 	{ USB_DEVICE_WACOM(0x32F) },
++>>>>>>> 500d4160abe9 (HID: wacom: add support for Cintiq 27QHD and 27QHD touch):drivers/hid/wacom_wac.c
  	{ USB_DEVICE_WACOM(0x4001) },
 -	{ USB_DEVICE_WACOM(0x4004) },
 -	{ USB_DEVICE_WACOM(0x5000) },
 -	{ USB_DEVICE_WACOM(0x5002) },
 +	{ USB_DEVICE_WACOM(0x47) },
 +	{ USB_DEVICE_WACOM(0xF4) },
 +	{ USB_DEVICE_WACOM(0xF8) },
 +	{ USB_DEVICE_DETAILED(0xF6, USB_CLASS_HID, 0, 0) },
 +	{ USB_DEVICE_WACOM(0xFA) },
  	{ USB_DEVICE_LENOVO(0x6004) },
 -
 -	{ USB_DEVICE_WACOM(HID_ANY_ID) },
  	{ }
  };
 -MODULE_DEVICE_TABLE(hid, wacom_ids);
 +MODULE_DEVICE_TABLE(usb, wacom_ids);
diff --cc drivers/input/tablet/wacom_wac.h
index b90fa383bbd7,021ee1c1980a..000000000000
--- a/drivers/input/tablet/wacom_wac.h
+++ b/drivers/input/tablet/wacom_wac.h
@@@ -10,9 -10,10 +10,13 @@@
  #define WACOM_WAC_H
  
  #include <linux/types.h>
 -#include <linux/hid.h>
  
  /* maximum packet length for USB devices */
++<<<<<<< HEAD:drivers/input/tablet/wacom_wac.h
 +#define WACOM_PKGLEN_MAX	64
++=======
+ #define WACOM_PKGLEN_MAX	192
++>>>>>>> 500d4160abe9 (HID: wacom: add support for Cintiq 27QHD and 27QHD touch):drivers/hid/wacom_wac.h
  
  #define WACOM_NAME_MAX		64
  
@@@ -50,10 -56,17 +55,12 @@@
  #define WACOM_REPORT_TPC1FG		6
  #define WACOM_REPORT_TPC2FG		13
  #define WACOM_REPORT_TPCMT		13
 -#define WACOM_REPORT_TPCMT2		3
  #define WACOM_REPORT_TPCHID		15
+ #define WACOM_REPORT_CINTIQ		16
+ #define WACOM_REPORT_CINTIQPAD		17
  #define WACOM_REPORT_TPCST		16
 -#define WACOM_REPORT_DTUS		17
  #define WACOM_REPORT_TPC1FGE		18
  #define WACOM_REPORT_24HDT		1
 -#define WACOM_REPORT_WL			128
 -#define WACOM_REPORT_USB		192
  
  /* device quirks */
  #define WACOM_QUIRK_MULTI_INPUT		0x0001
@@@ -85,6 -112,8 +92,11 @@@ enum 
  	WACOM_22HD,
  	DTK,
  	WACOM_24HD,
++<<<<<<< HEAD:drivers/input/tablet/wacom_wac.h
++=======
+ 	WACOM_27QHD,
+ 	CINTIQ_HYBRID,
++>>>>>>> 500d4160abe9 (HID: wacom: add support for Cintiq 27QHD and 27QHD touch):drivers/hid/wacom_wac.h
  	CINTIQ,
  	WACOM_BEE,
  	WACOM_13HD,
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/input/tablet/wacom_wac.c
* Unmerged path drivers/input/tablet/wacom_wac.h
diff --git a/include/uapi/linux/input.h b/include/uapi/linux/input.h
index 0f869c7693bd..1fae095e072a 100644
--- a/include/uapi/linux/input.h
+++ b/include/uapi/linux/input.h
@@ -165,6 +165,7 @@ struct input_keymap_entry {
 #define INPUT_PROP_SEMI_MT		0x03	/* touch rectangle only */
 #define INPUT_PROP_TOPBUTTONPAD		0x04	/* softbuttons at top of pad */
 #define INPUT_PROP_POINTING_STICK	0x05	/* is a pointing stick */
+#define INPUT_PROP_ACCELEROMETER	0x06	/* has accelerometer */
 
 #define INPUT_PROP_MAX			0x1f
 #define INPUT_PROP_CNT			(INPUT_PROP_MAX + 1)
