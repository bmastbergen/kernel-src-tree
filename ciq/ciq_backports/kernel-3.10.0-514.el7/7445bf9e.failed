mmc: tmio: tmio_mmc_host has .bus_shift

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
commit 7445bf9e6f4e5d7755e22c7c9b06f4ae0d6160c6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7445bf9e.failed

Current .bus_shift is implemented under tmio_mmc_data.
It goes to tmio_mmc_host by this patch.

	Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
	Acked-by: Lee Jones <lee.jones@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 7445bf9e6f4e5d7755e22c7c9b06f4ae0d6160c6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sh_mobile_sdhi.c
#	drivers/mmc/host/tmio_mmc.c
#	drivers/mmc/host/tmio_mmc_dma.c
diff --cc drivers/mmc/host/sh_mobile_sdhi.c
index 79ee6f0c45bd,0db2a0a0376b..000000000000
--- a/drivers/mmc/host/sh_mobile_sdhi.c
+++ b/drivers/mmc/host/sh_mobile_sdhi.c
@@@ -154,10 -207,21 +154,27 @@@ static int sh_mobile_sdhi_probe(struct 
  		goto eclkget;
  	}
  
++<<<<<<< HEAD
 +	mmc_data->clk_enable = sh_mobile_sdhi_clk_enable;
 +	mmc_data->clk_disable = sh_mobile_sdhi_clk_disable;
++=======
+ 	host = tmio_mmc_host_alloc(pdev);
+ 	if (!host) {
+ 		ret = -ENOMEM;
+ 		goto eprobe;
+ 	}
+ 
+ 	host->dma		= dma_priv;
+ 	host->write16_hook	= sh_mobile_sdhi_write16_hook;
+ 	host->clk_enable	= sh_mobile_sdhi_clk_enable;
+ 	host->clk_disable	= sh_mobile_sdhi_clk_disable;
+ 	host->multi_io_quirk	= sh_mobile_sdhi_multi_io_quirk;
+ 	/* SD control register space size is 0x100, 0x200 for bus_shift=1 */
+ 	host->bus_shift		= resource_size(res) >> 9;
+ 
++>>>>>>> 7445bf9e6f4e (mmc: tmio: tmio_mmc_host has .bus_shift)
  	mmc_data->capabilities = MMC_CAP_MMC_HIGHSPEED;
 +	mmc_data->write16_hook = sh_mobile_sdhi_write16_hook;
  	if (p) {
  		mmc_data->flags = p->tmio_flags;
  		mmc_data->ocr_mask = p->tmio_ocr_mask;
@@@ -199,11 -259,37 +216,15 @@@
  	if (of_id && of_id->data) {
  		const struct sh_mobile_sdhi_of_data *of_data = of_id->data;
  		mmc_data->flags |= of_data->tmio_flags;
 -		mmc_data->capabilities |= of_data->capabilities;
 -		mmc_data->capabilities2 |= of_data->capabilities2;
 -		dma_priv->dma_rx_offset = of_data->dma_rx_offset;
  	}
  
++<<<<<<< HEAD
 +	ret = tmio_mmc_host_probe(&host, pdev, mmc_data);
++=======
+ 	ret = tmio_mmc_host_probe(host, mmc_data);
++>>>>>>> 7445bf9e6f4e (mmc: tmio: tmio_mmc_host has .bus_shift)
  	if (ret < 0)
 -		goto efree;
 -
 -	/*
 -	 * FIXME:
 -	 * this Workaround can be more clever method
 -	 */
 -	ver = sd_ctrl_read16(host, CTL_VERSION);
 -	if (ver == 0xCB0D)
 -		sd_ctrl_write16(host, EXT_ACC, 1);
 +		goto eprobe;
  
  	/*
  	 * Allow one or more specific (named) ISRs or
diff --cc drivers/mmc/host/tmio_mmc.c
index 8860d4d2bc22,f746df493892..000000000000
--- a/drivers/mmc/host/tmio_mmc.c
+++ b/drivers/mmc/host/tmio_mmc.c
@@@ -84,9 -84,22 +84,26 @@@ static int tmio_mmc_probe(struct platfo
  			goto out;
  	}
  
++<<<<<<< HEAD
 +	ret = tmio_mmc_host_probe(&host, pdev, pdata);
++=======
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	if (!res)
+ 		return -EINVAL;
+ 
+ 	pdata->flags |= TMIO_MMC_HAVE_HIGH_REG;
+ 
+ 	host = tmio_mmc_host_alloc(pdev);
+ 	if (!host)
+ 		goto cell_disable;
+ 
+ 	/* SD control register space size is 0x200, 0x400 for bus_shift=1 */
+ 	host->bus_shift = resource_size(res) >> 10;
+ 
+ 	ret = tmio_mmc_host_probe(host, pdata);
++>>>>>>> 7445bf9e6f4e (mmc: tmio: tmio_mmc_host has .bus_shift)
  	if (ret)
 -		goto host_free;
 +		goto cell_disable;
  
  	ret = request_irq(irq, tmio_mmc_irq, IRQF_TRIGGER_FALLING,
  				dev_name(&pdev->dev), host);
diff --cc drivers/mmc/host/tmio_mmc_dma.c
index a8aaa7871c0d,ee0131eb078d..000000000000
--- a/drivers/mmc/host/tmio_mmc_dma.c
+++ b/drivers/mmc/host/tmio_mmc_dma.c
@@@ -288,9 -286,11 +288,13 @@@ void tmio_mmc_request_dma(struct tmio_m
  		if (!host->chan_tx)
  			return;
  
 -		if (host->dma->chan_priv_tx)
 -			cfg.slave_id = host->dma->slave_id_tx;
 +		cfg.slave_id = pdata->dma->slave_id_tx;
  		cfg.direction = DMA_MEM_TO_DEV;
  		cfg.dst_addr = res->start + (CTL_SD_DATA_PORT << host->bus_shift);
++<<<<<<< HEAD
++=======
+ 		cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
++>>>>>>> 7445bf9e6f4e (mmc: tmio: tmio_mmc_host has .bus_shift)
  		cfg.src_addr = 0;
  		ret = dmaengine_slave_config(host->chan_tx, &cfg);
  		if (ret < 0)
* Unmerged path drivers/mmc/host/sh_mobile_sdhi.c
* Unmerged path drivers/mmc/host/tmio_mmc.c
diff --git a/drivers/mmc/host/tmio_mmc.h b/drivers/mmc/host/tmio_mmc.h
index d857f5c6e7d9..2c1ed21c9dae 100644
--- a/drivers/mmc/host/tmio_mmc.h
+++ b/drivers/mmc/host/tmio_mmc.h
@@ -60,6 +60,7 @@ struct tmio_mmc_host {
 	struct scatterlist      *sg_orig;
 	unsigned int            sg_len;
 	unsigned int            sg_off;
+	unsigned long		bus_shift;
 
 	struct platform_device *pdev;
 	struct tmio_mmc_data *pdata;
* Unmerged path drivers/mmc/host/tmio_mmc_dma.c
