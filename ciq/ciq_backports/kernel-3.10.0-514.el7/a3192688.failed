nfs: make nfs4_init_nonuniform_client_string use a dynamically allocated buffer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jeff Layton <jlayton@poochiereds.net>
commit a319268891089386bd303bb90ace89d75e47102f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a3192688.failed

The way the *_client_string functions work is a little goofy. They build
the string in an on-stack buffer and then use kstrdup to copy it. This
is not only stack-heavy but artificially limits the size of the client
name string. Change it so that we determine the length of the string,
allocate it and then scnprintf into it.

Since the contents of the nonuniform string depend on rcu-managed data
structures, it's possible that they'll change between when we allocate
the string and when we go to fill it. If that happens, free the string,
recalculate the length and try again. If it the mismatch isn't resolved
on the second try then just give up and return -EINVAL.

	Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit a319268891089386bd303bb90ace89d75e47102f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/nfs4proc.c
index 4a74bf22dd3e,c20322636a68..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -5004,21 -4957,54 +5004,67 @@@ static void nfs4_init_boot_verifier(con
  	memcpy(bootverf->data, verf, sizeof(bootverf->data));
  }
  
++<<<<<<< HEAD
 +static unsigned int
 +nfs4_init_nonuniform_client_string(const struct nfs_client *clp,
 +				   char *buf, size_t len)
++=======
+ static int
+ nfs4_init_nonuniform_client_string(struct nfs_client *clp)
++>>>>>>> a31926889108 (nfs: make nfs4_init_nonuniform_client_string use a dynamically allocated buffer)
  {
- 	unsigned int result;
+ 	int result;
+ 	size_t len;
+ 	char *str;
+ 	bool retried = false;
+ 
++<<<<<<< HEAD
++=======
+ 	if (clp->cl_owner_id != NULL)
+ 		return 0;
+ retry:
+ 	rcu_read_lock();
+ 	len = 10 + strlen(clp->cl_ipaddr) + 1 +
+ 		strlen(rpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR)) +
+ 		1 +
+ 		strlen(rpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_PROTO)) +
+ 		1;
+ 	rcu_read_unlock();
+ 
+ 	if (len > NFS4_OPAQUE_LIMIT + 1)
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * Since this string is allocated at mount time, and held until the
+ 	 * nfs_client is destroyed, we can use GFP_KERNEL here w/o worrying
+ 	 * about a memory-reclaim deadlock.
+ 	 */
+ 	str = kmalloc(len, GFP_KERNEL);
+ 	if (!str)
+ 		return -ENOMEM;
  
++>>>>>>> a31926889108 (nfs: make nfs4_init_nonuniform_client_string use a dynamically allocated buffer)
  	rcu_read_lock();
- 	result = scnprintf(buf, len, "Linux NFSv4.0 %s/%s %s",
- 				clp->cl_ipaddr,
- 				rpc_peeraddr2str(clp->cl_rpcclient,
- 							RPC_DISPLAY_ADDR),
- 				rpc_peeraddr2str(clp->cl_rpcclient,
- 							RPC_DISPLAY_PROTO));
+ 	result = scnprintf(str, len, "Linux NFSv4.0 %s/%s %s",
+ 			clp->cl_ipaddr,
+ 			rpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR),
+ 			rpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_PROTO));
  	rcu_read_unlock();
++<<<<<<< HEAD
 +	return result;
++=======
+ 
+ 	/* Did something change? */
+ 	if (result >= len) {
+ 		kfree(str);
+ 		if (retried)
+ 			return -EINVAL;
+ 		retried = true;
+ 		goto retry;
+ 	}
+ 	clp->cl_owner_id = str;
+ 	return 0;
++>>>>>>> a31926889108 (nfs: make nfs4_init_nonuniform_client_string use a dynamically allocated buffer)
  }
  
  static unsigned int
* Unmerged path fs/nfs/nfs4proc.c
