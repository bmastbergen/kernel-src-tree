x86/microcode/intel: Cleanup apply_microcode_intel()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] microcode/intel: Cleanup apply_microcode_intel() (Prarit Bhargava) [1253762]
Rebuild_FUZZ: 96.00%
commit-author Borislav Petkov <bp@suse.de>
commit 26cbaa4dc676a444aa626cbc642c4c8181ef1378
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/26cbaa4d.failed

Get rid of local variable cpu_num as it is equal to @cpu now. Deref
cpu_data() only when it is really needed at the end.

No functionality change.

	Tested-by: Thomas Voegtle <tv@lio96.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/1454499225-21544-12-git-send-email-bp@alien8.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 26cbaa4dc676a444aa626cbc642c4c8181ef1378)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/microcode/intel.c
diff --cc arch/x86/kernel/cpu/microcode/intel.c
index 865d78872256,35186a0dd5fc..000000000000
--- a/arch/x86/kernel/cpu/microcode/intel.c
+++ b/arch/x86/kernel/cpu/microcode/intel.c
@@@ -68,19 -837,18 +68,25 @@@ static int get_matching_mc(struct micro
  
  static int apply_microcode_intel(int cpu)
  {
 -	struct microcode_intel *mc;
 +	struct microcode_intel *mc_intel;
  	struct ucode_cpu_info *uci;
+ 	struct cpuinfo_x86 *c;
  	unsigned int val[2];
- 	int cpu_num = raw_smp_processor_id();
- 	struct cpuinfo_x86 *c = &cpu_data(cpu_num);
  
++<<<<<<< HEAD
++=======
+ 	/* We should bind the task to the CPU */
+ 	if (WARN_ON(raw_smp_processor_id() != cpu))
+ 		return -1;
+ 
++>>>>>>> 26cbaa4dc676 (x86/microcode/intel: Cleanup apply_microcode_intel())
  	uci = ucode_cpu_info + cpu;
 -	mc = uci->mc;
 -	if (!mc)
 +	mc_intel = uci->mc;
 +
 +	/* We should bind the task to the CPU */
 +	BUG_ON(cpu_num != cpu);
 +
 +	if (mc_intel == NULL)
  		return 0;
  
  	/*
@@@ -103,16 -871,19 +109,30 @@@
  	/* get the current revision from MSR 0x8B */
  	rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);
  
 -	if (val[1] != mc->hdr.rev) {
 +	if (val[1] != mc_intel->hdr.rev) {
  		pr_err("CPU%d update to revision 0x%x failed\n",
++<<<<<<< HEAD
 +		       cpu_num, mc_intel->hdr.rev);
++=======
+ 		       cpu, mc->hdr.rev);
++>>>>>>> 26cbaa4dc676 (x86/microcode/intel: Cleanup apply_microcode_intel())
  		return -1;
  	}
+ 
  	pr_info("CPU%d updated to revision 0x%x, date = %04x-%02x-%02x\n",
++<<<<<<< HEAD
 +		cpu_num, val[1],
 +		mc_intel->hdr.date & 0xffff,
 +		mc_intel->hdr.date >> 24,
 +		(mc_intel->hdr.date >> 16) & 0xff);
++=======
+ 		cpu, val[1],
+ 		mc->hdr.date & 0xffff,
+ 		mc->hdr.date >> 24,
+ 		(mc->hdr.date >> 16) & 0xff);
++>>>>>>> 26cbaa4dc676 (x86/microcode/intel: Cleanup apply_microcode_intel())
+ 
+ 	c = &cpu_data(cpu);
  
  	uci->cpu_sig.rev = val[1];
  	c->microcode = val[1];
* Unmerged path arch/x86/kernel/cpu/microcode/intel.c
