mei: add async event notification ioctls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 3c7c8468e5d993dfe377a67e41cbb23cda93af9e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3c7c8468.failed

Add ioctl IOCTL_MEI_NOTIFY_SET for enabling and disabling
async event notification.
Add ioctl IOCTL_MEI_NOTIFY_GET for receiving and acking
an event notification.

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 3c7c8468e5d993dfe377a67e41cbb23cda93af9e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/misc-devices/mei/mei.txt
diff --cc Documentation/misc-devices/mei/mei.txt
index 6ec702950719,91c1fa34f48b..000000000000
--- a/Documentation/misc-devices/mei/mei.txt
+++ b/Documentation/misc-devices/mei/mei.txt
@@@ -91,9 -92,11 +91,17 @@@ A code snippet for an application commu
  	[...]
  	close(fd);
  
++<<<<<<< HEAD
 +IOCTL:
 +======
 +The Intel MEI Driver supports the following IOCTL command:
++=======
+ 
+ IOCTL
+ =====
+ 
+ The Intel MEI Driver supports the following IOCTL commands:
++>>>>>>> 3c7c8468e5d9 (mei: add async event notification ioctls)
  	IOCTL_MEI_CONNECT_CLIENT	Connect to firmware Feature (client).
  
  	usage:
@@@ -120,60 -123,106 +128,103 @@@
  	Notes:
          max_msg_length (MTU) in client properties describes the maximum
          data that can be sent or received. (e.g. if MTU=2K, can send
 -        requests up to bytes 2k and received responses up to 2k bytes).
 +        requests up to bytes 2k and received responses upto 2k bytes).
 +
 +Intel ME Applications:
 +==============
 +
 +1) Intel Local Management Service (Intel LMS)
 +
 +	Applications running locally on the platform communicate with Intel AMT Release
 +	2.0 and later releases in the same way that network applications do via SOAP
 +	over HTTP (deprecated starting with Release 6.0) or with WS-Management over
 +	SOAP over HTTP. This means that some Intel AMT features can be accessed from a
 +	local application using the same network interface as a remote application
 +	communicating with Intel AMT over the network.
 +
 +	When a local application sends a message addressed to the local Intel AMT host
 +	name, the Intel LMS, which listens for traffic directed to the host name,
 +	intercepts the message and routes it to the Intel MEI.
 +	For more information:
 +	http://software.intel.com/sites/manageability/AMT_Implementation_and_Reference_Guide
 +	Under "About Intel AMT" => "Local Access"
 +
 +	For downloading Intel LMS:
 +	http://software.intel.com/en-us/articles/download-the-latest-intel-amt-open-source-drivers/
 +
 +	The Intel LMS opens a connection using the Intel MEI driver to the Intel LMS
 +	firmware feature using a defined UUID and then communicates with the feature
 +	using a protocol called Intel AMT Port Forwarding Protocol(Intel APF protocol).
 +	The protocol is used to maintain multiple sessions with Intel AMT from a
 +	single application.
 +
 +	See the protocol specification in the Intel AMT Software Development Kit(SDK)
 +	http://software.intel.com/sites/manageability/AMT_Implementation_and_Reference_Guide
 +	Under "SDK Resources" => "Intel(R) vPro(TM) Gateway(MPS)"
 +	=> "Information for Intel(R) vPro(TM) Gateway Developers"
 +	=> "Description of the Intel AMT Port Forwarding (APF)Protocol"
 +
 +  2) Intel AMT Remote configuration using a Local Agent
 +	A Local Agent enables IT personnel to configure Intel AMT out-of-the-box
 +	without requiring installing additional data to enable setup. The remote
 +	configuration process may involve an ISV-developed remote configuration
 +	agent that runs on the host.
 +	For more information:
 +	http://software.intel.com/sites/manageability/AMT_Implementation_and_Reference_Guide
 +	Under "Setup and Configuration of Intel AMT" =>
 +	"SDK Tools Supporting Setup and Configuration" =>
 +	"Using the Local Agent Sample"
 +
 +	An open source Intel AMT configuration utility,	implementing a local agent
 +	that accesses the Intel MEI driver, can be found here:
 +	http://software.intel.com/en-us/articles/download-the-latest-intel-amt-open-source-drivers/
  
+ 	IOCTL_MEI_NOTIFY_SET: enable or disable event notifications
+ 
+ 	Usage:
+ 		uint32_t enable;
+ 		ioctl(fd, IOCTL_MEI_NOTIFY_SET, &enable);
+ 
+ 	Inputs:
+ 		uint32_t enable = 1;
+ 		or
+ 		uint32_t enable[disable] = 0;
+ 
+ 	Error returns:
+ 		EINVAL	Wrong IOCTL Number
+ 		ENODEV	Device  is not initialized or the client not connected
+ 		ENOMEM	Unable to allocate memory to client internal data.
+ 		EFAULT	Fatal Error (e.g. Unable to access user input data)
+ 		EOPNOTSUPP if the device doesn't support the feature
+ 
+ 	Notes:
+ 	The client must be connected in order to enable notification events
+ 
+ 
+ 	IOCTL_MEI_NOTIFY_GET : retrieve event
+ 
+ 	Usage:
+ 		uint32_t event;
+ 		ioctl(fd, IOCTL_MEI_NOTIFY_GET, &event);
+ 
+ 	Outputs:
+ 		1 - if an event is pending
+ 		0 - if there is no even pending
+ 
+ 	Error returns:
+ 		EINVAL	Wrong IOCTL Number
+ 		ENODEV	Device is not initialized or the client not connected
+ 		ENOMEM	Unable to allocate memory to client internal data.
+ 		EFAULT	Fatal Error (e.g. Unable to access user input data)
+ 		EOPNOTSUPP if the device doesn't support the feature
+ 
+ 	Notes:
+ 	The client must be connected and event notification has to be enabled
+ 	in order to receive an event
+ 
  
 -Intel ME Applications
 -=====================
 -
 -	1) Intel Local Management Service (Intel LMS)
 -
 -	   Applications running locally on the platform communicate with Intel AMT Release
 -	   2.0 and later releases in the same way that network applications do via SOAP
 -	   over HTTP (deprecated starting with Release 6.0) or with WS-Management over
 -	   SOAP over HTTP. This means that some Intel AMT features can be accessed from a
 -	   local application using the same network interface as a remote application
 -	   communicating with Intel AMT over the network.
 -
 -	   When a local application sends a message addressed to the local Intel AMT host
 -	   name, the Intel LMS, which listens for traffic directed to the host name,
 -	   intercepts the message and routes it to the Intel MEI.
 -	   For more information:
 -	   http://software.intel.com/sites/manageability/AMT_Implementation_and_Reference_Guide
 -	   Under "About Intel AMT" => "Local Access"
 -
 -	   For downloading Intel LMS:
 -	   http://software.intel.com/en-us/articles/download-the-latest-intel-amt-open-source-drivers/
 -
 -	   The Intel LMS opens a connection using the Intel MEI driver to the Intel LMS
 -	   firmware feature using a defined UUID and then communicates with the feature
 -	   using a protocol called Intel AMT Port Forwarding Protocol (Intel APF protocol).
 -	   The protocol is used to maintain multiple sessions with Intel AMT from a
 -	   single application.
 -
 -	   See the protocol specification in the Intel AMT Software Development Kit (SDK)
 -	   http://software.intel.com/sites/manageability/AMT_Implementation_and_Reference_Guide
 -	   Under "SDK Resources" => "Intel(R) vPro(TM) Gateway (MPS)"
 -	   => "Information for Intel(R) vPro(TM) Gateway Developers"
 -	   => "Description of the Intel AMT Port Forwarding (APF) Protocol"
 -
 -	2) Intel AMT Remote configuration using a Local Agent
 -
 -	   A Local Agent enables IT personnel to configure Intel AMT out-of-the-box
 -	   without requiring installing additional data to enable setup. The remote
 -	   configuration process may involve an ISV-developed remote configuration
 -	   agent that runs on the host.
 -	   For more information:
 -	   http://software.intel.com/sites/manageability/AMT_Implementation_and_Reference_Guide
 -	   Under "Setup and Configuration of Intel AMT" =>
 -	   "SDK Tools Supporting Setup and Configuration" =>
 -	   "Using the Local Agent Sample"
 -
 -	   An open source Intel AMT configuration utility,	implementing a local agent
 -	   that accesses the Intel MEI driver, can be found here:
 -	   http://software.intel.com/en-us/articles/download-the-latest-intel-amt-open-source-drivers/
 -
 -
 -Intel AMT OS Health Watchdog
 -============================
 -
 +Intel AMT OS Health Watchdog:
 +=============================
  The Intel AMT Watchdog is an OS Health (Hang/Crash) watchdog.
  Whenever the OS hangs or crashes, Intel AMT will send an event
  to any subscriber to this event. This mechanism means that
diff --git a/Documentation/ioctl/ioctl-number.txt b/Documentation/ioctl/ioctl-number.txt
index aa4ea294a8be..77f89b079d62 100644
--- a/Documentation/ioctl/ioctl-number.txt
+++ b/Documentation/ioctl/ioctl-number.txt
@@ -123,6 +123,8 @@ Code  Seq#(hex)	Include File		Comments
 'H'	00-7F	linux/hiddev.h		conflict!
 'H'	00-0F	linux/hidraw.h		conflict!
 'H'	01	linux/mei.h		conflict!
+'H'	02	linux/mei.h		conflict!
+'H'	03	linux/mei.h		conflict!
 'H'	00-0F	sound/asound.h		conflict!
 'H'	20-40	sound/asound_fm.h	conflict!
 'H'	80-8F	sound/sfnt_info.h	conflict!
* Unmerged path Documentation/misc-devices/mei/mei.txt
diff --git a/drivers/misc/mei/main.c b/drivers/misc/mei/main.c
index b23f9eba9e3a..0fdd77291de0 100644
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@ -536,6 +536,45 @@ end:
 	return rets;
 }
 
+/**
+ * mei_ioctl_client_notify_request -
+ *     propagate event notification request to client
+ *
+ * @file: pointer to file structure
+ * @request: 0 - disable, 1 - enable
+ *
+ * Return: 0 on success , <0 on error
+ */
+static int mei_ioctl_client_notify_request(struct file *file, u32 request)
+{
+	struct mei_cl *cl = file->private_data;
+
+	return mei_cl_notify_request(cl, file, request);
+}
+
+/**
+ * mei_ioctl_client_notify_get -  wait for notification request
+ *
+ * @file: pointer to file structure
+ * @notify_get: 0 - disable, 1 - enable
+ *
+ * Return: 0 on success , <0 on error
+ */
+static int mei_ioctl_client_notify_get(struct file *file, u32 *notify_get)
+{
+	struct mei_cl *cl = file->private_data;
+	bool notify_ev;
+	bool block = (file->f_flags & O_NONBLOCK) == 0;
+	int rets;
+
+	rets = mei_cl_notify_get(cl, block, &notify_ev);
+	if (rets)
+		return rets;
+
+	*notify_get = notify_ev ? 1 : 0;
+	return 0;
+}
+
 /**
  * mei_ioctl - the IOCTL function
  *
@@ -550,6 +589,7 @@ static long mei_ioctl(struct file *file, unsigned int cmd, unsigned long data)
 	struct mei_device *dev;
 	struct mei_cl *cl = file->private_data;
 	struct mei_connect_client_data connect_data;
+	u32 notify_get, notify_req;
 	int rets;
 
 
@@ -590,6 +630,33 @@ static long mei_ioctl(struct file *file, unsigned int cmd, unsigned long data)
 
 		break;
 
+	case IOCTL_MEI_NOTIFY_SET:
+		dev_dbg(dev->dev, ": IOCTL_MEI_NOTIFY_SET.\n");
+		if (copy_from_user(&notify_req,
+				   (char __user *)data, sizeof(notify_req))) {
+			dev_dbg(dev->dev, "failed to copy data from userland\n");
+			rets = -EFAULT;
+			goto out;
+		}
+		rets = mei_ioctl_client_notify_request(file, notify_req);
+		break;
+
+	case IOCTL_MEI_NOTIFY_GET:
+		dev_dbg(dev->dev, ": IOCTL_MEI_NOTIFY_GET.\n");
+		rets = mei_ioctl_client_notify_get(file, &notify_get);
+		if (rets)
+			goto out;
+
+		dev_dbg(dev->dev, "copy connect data to user\n");
+		if (copy_to_user((char __user *)data,
+				&notify_get, sizeof(notify_get))) {
+			dev_dbg(dev->dev, "failed to copy data to userland\n");
+			rets = -EFAULT;
+			goto out;
+
+		}
+		break;
+
 	default:
 		dev_err(&dev->pdev->dev, ": unsupported ioctl %d.\n", cmd);
 		rets = -ENOIOCTLCMD;
diff --git a/include/uapi/linux/mei.h b/include/uapi/linux/mei.h
index bc0d8b69c49e..7c3b64f6a215 100644
--- a/include/uapi/linux/mei.h
+++ b/include/uapi/linux/mei.h
@@ -107,4 +107,23 @@ struct mei_connect_client_data {
 	};
 };
 
+/**
+ * DOC: set and unset event notification for a connected client
+ *
+ * The IOCTL argument is 1 for enabling event notification and 0 for
+ * disabling the service
+ * Return:  -EOPNOTSUPP if the devices doesn't support the feature
+ */
+#define IOCTL_MEI_NOTIFY_SET _IOW('H', 0x02, __u32)
+
+/**
+ * DOC: retrieve notification
+ *
+ * The IOCTL output argument is 1 if an event was is pending and 0 otherwise
+ * the ioctl has to be called in order to acknowledge pending event
+ *
+ * Return:  -EOPNOTSUPP if the devices doesn't support the feature
+ */
+#define IOCTL_MEI_NOTIFY_GET _IOR('H', 0x03, __u32)
+
 #endif /* _LINUX_MEI_H  */
