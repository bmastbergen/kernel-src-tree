iscsi-target: add int (*iscsit_xmit_pdu)()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Varun Prakash <varun@chelsio.com>
commit 2854bb23cd5bef39fd845b7bdfac7799438bb920
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2854bb23.failed

Add int (*iscsit_xmit_pdu)() to
struct iscsit_transport, iscsi-target
uses this callback to transmit an
iSCSI PDU.

cxgbit.ko needs this callback to
avoid duplicating iscsit_immediate_queue()
and iscsit_response_queue() code.

	Signed-off-by: Varun Prakash <varun@chelsio.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 2854bb23cd5bef39fd845b7bdfac7799438bb920)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/iscsi/iscsi_target.c
diff --cc drivers/target/iscsi/iscsi_target.c
index c4fef98585d3,0724c8355e29..000000000000
--- a/drivers/target/iscsi/iscsi_target.c
+++ b/drivers/target/iscsi/iscsi_target.c
@@@ -2545,21 -2714,6 +2707,24 @@@ static int iscsit_send_conn_drop_async_
  	hdr->param2		= cpu_to_be16(conn->sess->sess_ops->DefaultTime2Wait);
  	hdr->param3		= cpu_to_be16(conn->sess->sess_ops->DefaultTime2Retain);
  
++<<<<<<< HEAD
 +	if (conn->conn_ops->HeaderDigest) {
 +		u32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];
 +
 +		iscsit_do_crypto_hash_buf(&conn->conn_tx_hash, hdr,
 +				ISCSI_HDR_LEN, 0, NULL, (u8 *)header_digest);
 +
 +		cmd->tx_size += ISCSI_CRC_LEN;
 +		pr_debug("Attaching CRC32C HeaderDigest to"
 +			" Async Message 0x%08x\n", *header_digest);
 +	}
 +
 +	cmd->iov_misc[0].iov_base	= cmd->pdu;
 +	cmd->iov_misc[0].iov_len	= cmd->tx_size;
 +	cmd->iov_misc_count		= 1;
 +
++=======
++>>>>>>> 2854bb23cd5b (iscsi-target: add int (*iscsit_xmit_pdu)())
  	pr_debug("Sending Connection Dropped Async Message StatSN:"
  		" 0x%08x, for CID: %hu on CID: %hu\n", cmd->stat_sn,
  			cmd->logout_cid, conn->cid);
@@@ -2670,68 -2823,9 +2834,72 @@@ static int iscsit_send_datain(struct is
  
  	iscsit_build_datain_pdu(cmd, conn, &datain, hdr, set_statsn);
  
++<<<<<<< HEAD
 +	iov = &cmd->iov_data[0];
 +	iov[iov_count].iov_base	= cmd->pdu;
 +	iov[iov_count++].iov_len	= ISCSI_HDR_LEN;
 +	tx_size += ISCSI_HDR_LEN;
 +
 +	if (conn->conn_ops->HeaderDigest) {
 +		u32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];
 +
 +		iscsit_do_crypto_hash_buf(&conn->conn_tx_hash, cmd->pdu,
 +				ISCSI_HDR_LEN, 0, NULL, (u8 *)header_digest);
 +
 +		iov[0].iov_len += ISCSI_CRC_LEN;
 +		tx_size += ISCSI_CRC_LEN;
 +
 +		pr_debug("Attaching CRC32 HeaderDigest"
 +			" for DataIN PDU 0x%08x\n", *header_digest);
 +	}
 +
 +	iov_ret = iscsit_map_iovec(cmd, &cmd->iov_data[1],
 +				datain.offset, datain.length);
 +	if (iov_ret < 0)
 +		return -1;
 +
 +	iov_count += iov_ret;
 +	tx_size += datain.length;
 +
 +	cmd->padding = ((-datain.length) & 3);
 +	if (cmd->padding) {
 +		iov[iov_count].iov_base		= cmd->pad_bytes;
 +		iov[iov_count++].iov_len	= cmd->padding;
 +		tx_size += cmd->padding;
 +
 +		pr_debug("Attaching %u padding bytes\n",
 +				cmd->padding);
 +	}
 +	if (conn->conn_ops->DataDigest) {
 +		cmd->data_crc = iscsit_do_crypto_hash_sg(&conn->conn_tx_hash, cmd,
 +			 datain.offset, datain.length, cmd->padding, cmd->pad_bytes);
 +
 +		iov[iov_count].iov_base	= &cmd->data_crc;
 +		iov[iov_count++].iov_len = ISCSI_CRC_LEN;
 +		tx_size += ISCSI_CRC_LEN;
 +
 +		pr_debug("Attached CRC32C DataDigest %d bytes, crc"
 +			" 0x%08x\n", datain.length+cmd->padding, cmd->data_crc);
 +	}
 +
 +	cmd->iov_data_count = iov_count;
 +	cmd->tx_size = tx_size;
 +
 +	/* sendpage is preferred but can't insert markers */
 +	if (!conn->conn_ops->IFMarker)
 +		ret = iscsit_fe_sendpage_sg(cmd, conn);
 +	else
 +		ret = iscsit_send_tx_data(cmd, conn, 0);
 +
 +	iscsit_unmap_iovec(cmd);
 +
 +	if (ret < 0) {
 +		iscsit_tx_thread_wait_for_tcp(conn);
++=======
+ 	ret = conn->conn_transport->iscsit_xmit_pdu(conn, cmd, dr, &datain, 0);
+ 	if (ret < 0)
++>>>>>>> 2854bb23cd5b (iscsi-target: add int (*iscsit_xmit_pdu)())
  		return ret;
- 	}
  
  	if (dr->dr_complete) {
  		eodr = (cmd->se_cmd.se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) ?
@@@ -2848,26 -2941,7 +3015,30 @@@ iscsit_send_logout(struct iscsi_cmd *cm
  	if (rc < 0)
  		return rc;
  
++<<<<<<< HEAD
 +	tx_size = ISCSI_HDR_LEN;
 +	iov = &cmd->iov_misc[0];
 +	iov[niov].iov_base	= cmd->pdu;
 +	iov[niov++].iov_len	= ISCSI_HDR_LEN;
 +
 +	if (conn->conn_ops->HeaderDigest) {
 +		u32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];
 +
 +		iscsit_do_crypto_hash_buf(&conn->conn_tx_hash, &cmd->pdu[0],
 +				ISCSI_HDR_LEN, 0, NULL, (u8 *)header_digest);
 +
 +		iov[0].iov_len += ISCSI_CRC_LEN;
 +		tx_size += ISCSI_CRC_LEN;
 +		pr_debug("Attaching CRC32C HeaderDigest to"
 +			" Logout Response 0x%08x\n", *header_digest);
 +	}
 +	cmd->iov_misc_count = niov;
 +	cmd->tx_size = tx_size;
 +
 +	return 0;
++=======
+ 	return conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL, NULL, 0);
++>>>>>>> 2854bb23cd5b (iscsi-target: add int (*iscsit_xmit_pdu)())
  }
  
  void
@@@ -2911,22 -2985,6 +3082,25 @@@ static int iscsit_send_unsolicited_nopi
  
  	iscsit_build_nopin_rsp(cmd, conn, hdr, false);
  
++<<<<<<< HEAD
 +	if (conn->conn_ops->HeaderDigest) {
 +		u32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];
 +
 +		iscsit_do_crypto_hash_buf(&conn->conn_tx_hash, hdr,
 +				ISCSI_HDR_LEN, 0, NULL, (u8 *)header_digest);
 +
 +		tx_size += ISCSI_CRC_LEN;
 +		pr_debug("Attaching CRC32C HeaderDigest to"
 +			" NopIN 0x%08x\n", *header_digest);
 +	}
 +
 +	cmd->iov_misc[0].iov_base	= cmd->pdu;
 +	cmd->iov_misc[0].iov_len	= tx_size;
 +	cmd->iov_misc_count	= 1;
 +	cmd->tx_size		= tx_size;
 +
++=======
++>>>>>>> 2854bb23cd5b (iscsi-target: add int (*iscsit_xmit_pdu)())
  	pr_debug("Sending Unsolicited NOPIN TTT: 0x%08x StatSN:"
  		" 0x%08x CID: %hu\n", hdr->ttt, cmd->stat_sn, conn->cid);
  
@@@ -2951,65 -3007,15 +3123,68 @@@ iscsit_send_nopin(struct iscsi_cmd *cmd
  
  	iscsit_build_nopin_rsp(cmd, conn, hdr, true);
  
++<<<<<<< HEAD
 +	tx_size = ISCSI_HDR_LEN;
 +	iov = &cmd->iov_misc[0];
 +	iov[niov].iov_base	= cmd->pdu;
 +	iov[niov++].iov_len	= ISCSI_HDR_LEN;
 +
 +	if (conn->conn_ops->HeaderDigest) {
 +		u32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];
 +
 +		iscsit_do_crypto_hash_buf(&conn->conn_tx_hash, hdr,
 +				ISCSI_HDR_LEN, 0, NULL, (u8 *)header_digest);
 +
 +		iov[0].iov_len += ISCSI_CRC_LEN;
 +		tx_size += ISCSI_CRC_LEN;
 +		pr_debug("Attaching CRC32C HeaderDigest"
 +			" to NopIn 0x%08x\n", *header_digest);
 +	}
 +
++=======
++>>>>>>> 2854bb23cd5b (iscsi-target: add int (*iscsit_xmit_pdu)())
  	/*
  	 * NOPOUT Ping Data is attached to struct iscsi_cmd->buf_ptr.
  	 * NOPOUT DataSegmentLength is at struct iscsi_cmd->buf_ptr_size.
  	 */
- 	if (cmd->buf_ptr_size) {
- 		iov[niov].iov_base	= cmd->buf_ptr;
- 		iov[niov++].iov_len	= cmd->buf_ptr_size;
- 		tx_size += cmd->buf_ptr_size;
+ 	pr_debug("Echoing back %u bytes of ping data.\n", cmd->buf_ptr_size);
  
++<<<<<<< HEAD
 +		pr_debug("Echoing back %u bytes of ping"
 +			" data.\n", cmd->buf_ptr_size);
 +
 +		padding = ((-cmd->buf_ptr_size) & 3);
 +		if (padding != 0) {
 +			iov[niov].iov_base = &cmd->pad_bytes;
 +			iov[niov++].iov_len = padding;
 +			tx_size += padding;
 +			pr_debug("Attaching %u additional"
 +				" padding bytes.\n", padding);
 +		}
 +		if (conn->conn_ops->DataDigest) {
 +			iscsit_do_crypto_hash_buf(&conn->conn_tx_hash,
 +				cmd->buf_ptr, cmd->buf_ptr_size,
 +				padding, (u8 *)&cmd->pad_bytes,
 +				(u8 *)&cmd->data_crc);
 +
 +			iov[niov].iov_base = &cmd->data_crc;
 +			iov[niov++].iov_len = ISCSI_CRC_LEN;
 +			tx_size += ISCSI_CRC_LEN;
 +			pr_debug("Attached DataDigest for %u"
 +				" bytes of ping data, CRC 0x%08x\n",
 +				cmd->buf_ptr_size, cmd->data_crc);
 +		}
 +	}
 +
 +	cmd->iov_misc_count = niov;
 +	cmd->tx_size = tx_size;
 +
 +	return 0;
++=======
+ 	return conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL,
+ 						     cmd->buf_ptr,
+ 						     cmd->buf_ptr_size);
++>>>>>>> 2854bb23cd5b (iscsi-target: add int (*iscsit_xmit_pdu)())
  }
  
  static int iscsit_send_r2t(
@@@ -3041,22 -3046,6 +3215,25 @@@
  	hdr->data_offset	= cpu_to_be32(r2t->offset);
  	hdr->data_length	= cpu_to_be32(r2t->xfer_len);
  
++<<<<<<< HEAD
 +	cmd->iov_misc[0].iov_base	= cmd->pdu;
 +	cmd->iov_misc[0].iov_len	= ISCSI_HDR_LEN;
 +	tx_size += ISCSI_HDR_LEN;
 +
 +	if (conn->conn_ops->HeaderDigest) {
 +		u32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];
 +
 +		iscsit_do_crypto_hash_buf(&conn->conn_tx_hash, hdr,
 +				ISCSI_HDR_LEN, 0, NULL, (u8 *)header_digest);
 +
 +		cmd->iov_misc[0].iov_len += ISCSI_CRC_LEN;
 +		tx_size += ISCSI_CRC_LEN;
 +		pr_debug("Attaching CRC32 HeaderDigest for R2T"
 +			" PDU 0x%08x\n", *header_digest);
 +	}
 +
++=======
++>>>>>>> 2854bb23cd5b (iscsi-target: add int (*iscsit_xmit_pdu)())
  	pr_debug("Built %sR2T, ITT: 0x%08x, TTT: 0x%08x, StatSN:"
  		" 0x%08x, R2TSN: 0x%08x, Offset: %u, DDTL: %u, CID: %hu\n",
  		(!r2t->recovery_r2t) ? "" : "Recovery ", cmd->init_task_tag,
@@@ -3237,43 -3213,13 +3401,51 @@@ static int iscsit_send_response(struct 
  				" SENSE.\n", padding);
  		}
  
++<<<<<<< HEAD
 +		if (conn->conn_ops->DataDigest) {
 +			iscsit_do_crypto_hash_buf(&conn->conn_tx_hash,
 +				cmd->sense_buffer,
 +				(cmd->se_cmd.scsi_sense_length + padding),
 +				0, NULL, (u8 *)&cmd->data_crc);
 +
 +			iov[iov_count].iov_base    = &cmd->data_crc;
 +			iov[iov_count++].iov_len     = ISCSI_CRC_LEN;
 +			tx_size += ISCSI_CRC_LEN;
 +
 +			pr_debug("Attaching CRC32 DataDigest for"
 +				" SENSE, %u bytes CRC 0x%08x\n",
 +				(cmd->se_cmd.scsi_sense_length + padding),
 +				cmd->data_crc);
 +		}
 +
++=======
++>>>>>>> 2854bb23cd5b (iscsi-target: add int (*iscsit_xmit_pdu)())
  		pr_debug("Attaching SENSE DATA: %u bytes to iSCSI"
  				" Response PDU\n",
  				cmd->se_cmd.scsi_sense_length);
  	}
  
++<<<<<<< HEAD
 +	if (conn->conn_ops->HeaderDigest) {
 +		u32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];
 +
 +		iscsit_do_crypto_hash_buf(&conn->conn_tx_hash, cmd->pdu,
 +				ISCSI_HDR_LEN, 0, NULL, (u8 *)header_digest);
 +
 +		iov[0].iov_len += ISCSI_CRC_LEN;
 +		tx_size += ISCSI_CRC_LEN;
 +		pr_debug("Attaching CRC32 HeaderDigest for Response"
 +				" PDU 0x%08x\n", *header_digest);
 +	}
 +
 +	cmd->iov_misc_count = iov_count;
 +	cmd->tx_size = tx_size;
 +
 +	return 0;
++=======
+ 	return conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL, data_buf,
+ 						     data_buf_len);
++>>>>>>> 2854bb23cd5b (iscsi-target: add int (*iscsit_xmit_pdu)())
  }
  
  static u8 iscsit_convert_tcm_tmr_rsp(struct se_tmr_req *se_tmr)
@@@ -3323,27 -3269,7 +3495,30 @@@ iscsit_send_task_mgt_rsp(struct iscsi_c
  
  	iscsit_build_task_mgt_rsp(cmd, conn, hdr);
  
++<<<<<<< HEAD
 +	cmd->iov_misc[0].iov_base	= cmd->pdu;
 +	cmd->iov_misc[0].iov_len	= ISCSI_HDR_LEN;
 +	tx_size += ISCSI_HDR_LEN;
 +
 +	if (conn->conn_ops->HeaderDigest) {
 +		u32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];
 +
 +		iscsit_do_crypto_hash_buf(&conn->conn_tx_hash, hdr,
 +				ISCSI_HDR_LEN, 0, NULL, (u8 *)header_digest);
 +
 +		cmd->iov_misc[0].iov_len += ISCSI_CRC_LEN;
 +		tx_size += ISCSI_CRC_LEN;
 +		pr_debug("Attaching CRC32 HeaderDigest for Task"
 +			" Mgmt Response PDU 0x%08x\n", *header_digest);
 +	}
 +
 +	cmd->iov_misc_count = 1;
 +	cmd->tx_size = tx_size;
 +
 +	return 0;
++=======
+ 	return conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL, NULL, 0);
++>>>>>>> 2854bb23cd5b (iscsi-target: add int (*iscsit_xmit_pdu)())
  }
  
  static bool iscsit_check_inaddr_any(struct iscsi_np *np)
@@@ -3580,53 -3506,15 +3755,57 @@@ static int iscsit_send_text_rsp
  	struct iscsi_conn *conn)
  {
  	struct iscsi_text_rsp *hdr = (struct iscsi_text_rsp *)cmd->pdu;
- 	struct kvec *iov;
- 	u32 tx_size = 0;
- 	int text_length, iov_count = 0, rc;
+ 	int text_length;
  
- 	rc = iscsit_build_text_rsp(cmd, conn, hdr, ISCSI_TCP);
- 	if (rc < 0)
- 		return rc;
+ 	text_length = iscsit_build_text_rsp(cmd, conn, hdr, ISCSI_TCP);
+ 	if (text_length < 0)
+ 		return text_length;
  
++<<<<<<< HEAD
 +	text_length = rc;
 +	iov = &cmd->iov_misc[0];
 +	iov[iov_count].iov_base = cmd->pdu;
 +	iov[iov_count++].iov_len = ISCSI_HDR_LEN;
 +	iov[iov_count].iov_base	= cmd->buf_ptr;
 +	iov[iov_count++].iov_len = text_length;
 +
 +	tx_size += (ISCSI_HDR_LEN + text_length);
 +
 +	if (conn->conn_ops->HeaderDigest) {
 +		u32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];
 +
 +		iscsit_do_crypto_hash_buf(&conn->conn_tx_hash, hdr,
 +				ISCSI_HDR_LEN, 0, NULL, (u8 *)header_digest);
 +
 +		iov[0].iov_len += ISCSI_CRC_LEN;
 +		tx_size += ISCSI_CRC_LEN;
 +		pr_debug("Attaching CRC32 HeaderDigest for"
 +			" Text Response PDU 0x%08x\n", *header_digest);
 +	}
 +
 +	if (conn->conn_ops->DataDigest) {
 +		iscsit_do_crypto_hash_buf(&conn->conn_tx_hash,
 +				cmd->buf_ptr, text_length,
 +				0, NULL, (u8 *)&cmd->data_crc);
 +
 +		iov[iov_count].iov_base	= &cmd->data_crc;
 +		iov[iov_count++].iov_len = ISCSI_CRC_LEN;
 +		tx_size	+= ISCSI_CRC_LEN;
 +
 +		pr_debug("Attaching DataDigest for %u bytes of text"
 +			" data, CRC 0x%08x\n", text_length,
 +			cmd->data_crc);
 +	}
 +
 +	cmd->iov_misc_count = iov_count;
 +	cmd->tx_size = tx_size;
 +
 +	return 0;
++=======
+ 	return conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL,
+ 						     cmd->buf_ptr,
+ 						     text_length);
++>>>>>>> 2854bb23cd5b (iscsi-target: add int (*iscsit_xmit_pdu)())
  }
  
  void
@@@ -3654,42 -3542,6 +3833,43 @@@ static int iscsit_send_reject
  
  	iscsit_build_reject(cmd, conn, hdr);
  
++<<<<<<< HEAD
 +	iov = &cmd->iov_misc[0];
 +	iov[iov_count].iov_base = cmd->pdu;
 +	iov[iov_count++].iov_len = ISCSI_HDR_LEN;
 +	iov[iov_count].iov_base = cmd->buf_ptr;
 +	iov[iov_count++].iov_len = ISCSI_HDR_LEN;
 +
 +	tx_size = (ISCSI_HDR_LEN + ISCSI_HDR_LEN);
 +
 +	if (conn->conn_ops->HeaderDigest) {
 +		u32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];
 +
 +		iscsit_do_crypto_hash_buf(&conn->conn_tx_hash, hdr,
 +				ISCSI_HDR_LEN, 0, NULL, (u8 *)header_digest);
 +
 +		iov[0].iov_len += ISCSI_CRC_LEN;
 +		tx_size += ISCSI_CRC_LEN;
 +		pr_debug("Attaching CRC32 HeaderDigest for"
 +			" REJECT PDU 0x%08x\n", *header_digest);
 +	}
 +
 +	if (conn->conn_ops->DataDigest) {
 +		iscsit_do_crypto_hash_buf(&conn->conn_tx_hash, cmd->buf_ptr,
 +				ISCSI_HDR_LEN, 0, NULL, (u8 *)&cmd->data_crc);
 +
 +		iov[iov_count].iov_base = &cmd->data_crc;
 +		iov[iov_count++].iov_len  = ISCSI_CRC_LEN;
 +		tx_size += ISCSI_CRC_LEN;
 +		pr_debug("Attaching CRC32 DataDigest for REJECT"
 +				" PDU 0x%08x\n", cmd->data_crc);
 +	}
 +
 +	cmd->iov_misc_count = iov_count;
 +	cmd->tx_size = tx_size;
 +
++=======
++>>>>>>> 2854bb23cd5b (iscsi-target: add int (*iscsit_xmit_pdu)())
  	pr_debug("Built Reject PDU StatSN: 0x%08x, Reason: 0x%02x,"
  		" CID: %hu\n", ntohl(hdr->statsn), hdr->reason, conn->cid);
  
* Unmerged path drivers/target/iscsi/iscsi_target.c
diff --git a/include/target/iscsi/iscsi_transport.h b/include/target/iscsi/iscsi_transport.h
index e6bb166f12c2..edda7f9b95a5 100644
--- a/include/target/iscsi/iscsi_transport.h
+++ b/include/target/iscsi/iscsi_transport.h
@@ -22,6 +22,8 @@ struct iscsit_transport {
 	int (*iscsit_queue_data_in)(struct iscsi_conn *, struct iscsi_cmd *);
 	int (*iscsit_queue_status)(struct iscsi_conn *, struct iscsi_cmd *);
 	void (*iscsit_aborted_task)(struct iscsi_conn *, struct iscsi_cmd *);
+	int (*iscsit_xmit_pdu)(struct iscsi_conn *, struct iscsi_cmd *,
+			       struct iscsi_datain_req *, const void *, u32);
 	enum target_prot_op (*iscsit_get_sup_prot_ops)(struct iscsi_conn *);
 };
 
