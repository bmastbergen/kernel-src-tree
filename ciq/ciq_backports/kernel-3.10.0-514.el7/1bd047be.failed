tpm_crb: Use devm_ioremap_resource

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
commit 1bd047be37d95bf65a219f4931215f71878ac060
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1bd047be.failed

To support the force mode in tpm_tis we need to use resource locking
in tpm_crb as well, via devm_ioremap_resource.

The light restructuring better aligns crb and tis and makes it easier
to see the that new changes make sense.

The control area and its associated buffers do not always fall in the
range of the iomem resource given by the ACPI object. This patch fixes
the issue by mapping the buffers if this is the case.

[jarkko.sakkinen@linux.intel.com: squashed update described in the
 last paragraph.]

	Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
	Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Acked-by: Peter Huewe <peterhuewe@gmx.de>
	Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
(cherry picked from commit 1bd047be37d95bf65a219f4931215f71878ac060)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm_crb.c
diff --cc drivers/char/tpm/tpm_crb.c
index 21a066b73f54,916332c9d906..000000000000
--- a/drivers/char/tpm/tpm_crb.c
+++ b/drivers/char/tpm/tpm_crb.c
@@@ -210,44 -198,126 +212,157 @@@ static const struct tpm_class_ops tpm_c
  	.req_complete_val = CRB_STS_COMPLETE,
  };
  
- static int crb_acpi_add(struct acpi_device *device)
+ static int crb_init(struct acpi_device *device, struct crb_priv *priv)
  {
  	struct tpm_chip *chip;
++<<<<<<< HEAD
 +	struct acpi_tpm2 *buf;
++=======
+ 	int rc;
+ 
+ 	chip = tpmm_chip_alloc(&device->dev, &tpm_crb);
+ 	if (IS_ERR(chip))
+ 		return PTR_ERR(chip);
+ 
+ 	chip->vendor.priv = priv;
+ 	chip->acpi_dev_handle = device->handle;
+ 	chip->flags = TPM_CHIP_FLAG_TPM2;
+ 
+ 	rc = tpm_get_timeouts(chip);
+ 	if (rc)
+ 		return rc;
+ 
+ 	rc = tpm2_do_selftest(chip);
+ 	if (rc)
+ 		return rc;
+ 
+ 	return tpm_chip_register(chip);
+ }
+ 
+ static int crb_check_resource(struct acpi_resource *ares, void *data)
+ {
+ 	struct crb_priv *priv = data;
+ 	struct resource res;
+ 
+ 	if (acpi_dev_resource_memory(ares, &res))
+ 		priv->res = res;
+ 
+ 	return 1;
+ }
+ 
+ static void __iomem *crb_map_res(struct device *dev, struct crb_priv *priv,
+ 				 u64 start, u32 size)
+ {
+ 	struct resource new_res = {
+ 		.start	= start,
+ 		.end	= start + size - 1,
+ 		.flags	= IORESOURCE_MEM,
+ 	};
+ 
+ 	/* Detect a 64 bit address on a 32 bit system */
+ 	if (start != new_res.start)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	if (!resource_contains(&priv->res, &new_res))
+ 		return devm_ioremap_resource(dev, &new_res);
+ 
+ 	return priv->iobase + (new_res.start - priv->res.start);
+ }
+ 
+ static int crb_map_io(struct acpi_device *device, struct crb_priv *priv,
+ 		      struct acpi_table_tpm2 *buf)
+ {
+ 	struct list_head resources;
+ 	struct device *dev = &device->dev;
+ 	u64 pa;
+ 	int ret;
+ 
+ 	INIT_LIST_HEAD(&resources);
+ 	ret = acpi_dev_get_resources(device, &resources, crb_check_resource,
+ 				     priv);
+ 	if (ret < 0)
+ 		return ret;
+ 	acpi_dev_free_resource_list(&resources);
+ 
+ 	if (resource_type(&priv->res) != IORESOURCE_MEM) {
+ 		dev_err(dev,
+ 			FW_BUG "TPM2 ACPI table does not define a memory resource\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	priv->iobase = devm_ioremap_resource(dev, &priv->res);
+ 	if (IS_ERR(priv->iobase))
+ 		return PTR_ERR(priv->iobase);
+ 
+ 	priv->cca = crb_map_res(dev, priv, buf->control_address, 0x1000);
+ 	if (IS_ERR(priv->cca))
+ 		return PTR_ERR(priv->cca);
+ 
+ 	pa = ((u64) ioread32(&priv->cca->cmd_pa_high) << 32) |
+ 	      (u64) ioread32(&priv->cca->cmd_pa_low);
+ 	priv->cmd = crb_map_res(dev, priv, pa, ioread32(&priv->cca->cmd_size));
+ 	if (IS_ERR(priv->cmd))
+ 		return PTR_ERR(priv->cmd);
+ 
+ 	memcpy_fromio(&pa, &priv->cca->rsp_pa, 8);
+ 	pa = le64_to_cpu(pa);
+ 	priv->rsp = crb_map_res(dev, priv, pa, ioread32(&priv->cca->rsp_size));
+ 	return PTR_ERR_OR_ZERO(priv->rsp);
+ }
+ 
+ static int crb_acpi_add(struct acpi_device *device)
+ {
+ 	struct acpi_table_tpm2 *buf;
++>>>>>>> 1bd047be37d9 (tpm_crb: Use devm_ioremap_resource)
  	struct crb_priv *priv;
  	struct device *dev = &device->dev;
  	acpi_status status;
  	u32 sm;
- 	u64 pa;
  	int rc;
  
++<<<<<<< HEAD
 +	chip = tpmm_chip_alloc(dev, &tpm_crb);
 +	if (IS_ERR(chip))
 +		return PTR_ERR(chip);
 +
 +	chip->flags = TPM_CHIP_FLAG_TPM2;
 +
 +	status = acpi_get_table(ACPI_SIG_TPM2, 1,
 +				(struct acpi_table_header **) &buf);
 +	if (ACPI_FAILURE(status)) {
 +		dev_err(dev, "failed to get TPM2 ACPI table\n");
 +		return -ENODEV;
 +	}
 +
 +	if (buf->hdr.length < sizeof(struct acpi_tpm2)) {
 +		dev_err(dev, "TPM2 ACPI table has wrong size");
 +		return -EINVAL;
 +	}
 +
 +	priv = (struct crb_priv *) devm_kzalloc(dev, sizeof(struct crb_priv),
 +						GFP_KERNEL);
 +	if (!priv) {
 +		dev_err(dev, "failed to devm_kzalloc for private data\n");
- 		return -ENOMEM;
++=======
+ 	status = acpi_get_table(ACPI_SIG_TPM2, 1,
+ 				(struct acpi_table_header **) &buf);
+ 	if (ACPI_FAILURE(status) || buf->header.length < sizeof(*buf)) {
+ 		dev_err(dev, FW_BUG "failed to get TPM2 ACPI table\n");
+ 		return -EINVAL;
  	}
  
+ 	/* Should the FIFO driver handle this? */
+ 	sm = buf->start_method;
+ 	if (sm == ACPI_TPM2_MEMORY_MAPPED)
+ 		return -ENODEV;
+ 
+ 	priv = devm_kzalloc(dev, sizeof(struct crb_priv), GFP_KERNEL);
+ 	if (!priv)
++>>>>>>> 1bd047be37d9 (tpm_crb: Use devm_ioremap_resource)
+ 		return -ENOMEM;
+ 
 +	sm = le32_to_cpu(buf->start_method);
 +
  	/* The reason for the extra quirk is that the PTT in 4th Gen Core CPUs
  	 * report only ACPI start but in practice seems to require both
  	 * ACPI start and CRB start.
@@@ -256,37 -326,11 +371,41 @@@
  	    !strcmp(acpi_device_hid(device), "MSFT0101"))
  		priv->flags |= CRB_FL_CRB_START;
  
 -	if (sm == ACPI_TPM2_START_METHOD ||
 -	    sm == ACPI_TPM2_COMMAND_BUFFER_WITH_START_METHOD)
 +	if (sm == CRB_SM_ACPI_START || sm == CRB_SM_CRB_WITH_ACPI_START)
  		priv->flags |= CRB_FL_ACPI_START;
  
++<<<<<<< HEAD
 +	priv->cca = (struct crb_control_area __iomem *)
 +		devm_ioremap_nocache(dev, buf->control_area_pa, 0x1000);
 +	if (!priv->cca) {
 +		dev_err(dev, "ioremap of the control area failed\n");
 +		return -ENOMEM;
 +	}
 +
 +	pa = ((u64)ioread32(&priv->cca->cmd_pa_high) << 32) |
 +	     (u64)ioread32(&priv->cca->cmd_pa_low);
 +	priv->cmd =
 +	    devm_ioremap_nocache(dev, pa, ioread32(&priv->cca->cmd_size));
 +	if (!priv->cmd) {
 +		dev_err(dev, "ioremap of the command buffer failed\n");
 +		return -ENOMEM;
 +	}
 +
 +	memcpy_fromio(&pa, &priv->cca->rsp_pa, 8);
 +	pa = le64_to_cpu(pa);
 +	priv->rsp =
 +	    devm_ioremap_nocache(dev, pa, ioread32(&priv->cca->rsp_size));
 +	if (!priv->rsp) {
 +		dev_err(dev, "ioremap of the response buffer failed\n");
 +		return -ENOMEM;
 +	}
 +
 +	chip->vendor.priv = priv;
 +
 +	rc = tpm_get_timeouts(chip);
++=======
+ 	rc = crb_map_io(device, priv, buf);
++>>>>>>> 1bd047be37d9 (tpm_crb: Use devm_ioremap_resource)
  	if (rc)
  		return rc;
  
* Unmerged path drivers/char/tpm/tpm_crb.c
