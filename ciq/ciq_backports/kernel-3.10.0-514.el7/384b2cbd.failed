mmc: tmio: care about DMA tx/rx addr offset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
commit 384b2cbd56a02efb16358ed7c0c039e4afca5ed0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/384b2cbd.failed

Basically, SD_BUF0 Tx/Rx addresses are same
in normal TMIO controller,
but, it is different on Renesas R-Car SDHI controller
if it uses DMAC
(Rx address needs to add 0x2000 to Tx address)

This patch adds new .dma_rx_offset and cares it

	Tested-by: Nguyen Xuan Nui <nx-nui@jinso.co.jp>
	Tested-by: Hiep Cao Minh <cm-hiep@jinso.co.jp>
	Acked-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
	Acked-by: Ben Dooks <ben-linux@fluff.org>
	Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 384b2cbd56a02efb16358ed7c0c039e4afca5ed0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sh_mobile_sdhi.c
#	drivers/mmc/host/tmio_mmc_dma.c
diff --cc drivers/mmc/host/sh_mobile_sdhi.c
index 79ee6f0c45bd,f0818cd0242c..000000000000
--- a/drivers/mmc/host/sh_mobile_sdhi.c
+++ b/drivers/mmc/host/sh_mobile_sdhi.c
@@@ -33,8 -33,13 +33,14 @@@
  
  #include "tmio_mmc.h"
  
 -#define EXT_ACC           0xe4
 -
  struct sh_mobile_sdhi_of_data {
  	unsigned long tmio_flags;
++<<<<<<< HEAD
++=======
+ 	unsigned long capabilities;
+ 	unsigned long capabilities2;
+ 	dma_addr_t dma_rx_offset;
++>>>>>>> 384b2cbd56a0 (mmc: tmio: care about DMA tx/rx addr offset)
  };
  
  static const struct sh_mobile_sdhi_of_data sh_mobile_sdhi_of_cfg[] = {
@@@ -43,6 -48,32 +49,35 @@@
  	},
  };
  
++<<<<<<< HEAD
++=======
+ static const struct sh_mobile_sdhi_of_data of_rcar_gen1_compatible = {
+ 	.tmio_flags	= TMIO_MMC_HAS_IDLE_WAIT | TMIO_MMC_WRPROTECT_DISABLE,
+ 	.capabilities	= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ,
+ };
+ 
+ static const struct sh_mobile_sdhi_of_data of_rcar_gen2_compatible = {
+ 	.tmio_flags	= TMIO_MMC_HAS_IDLE_WAIT | TMIO_MMC_WRPROTECT_DISABLE,
+ 	.capabilities	= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ,
+ 	.capabilities2	= MMC_CAP2_NO_MULTI_READ,
+ 	.dma_rx_offset	= 0x2000,
+ };
+ 
+ static const struct of_device_id sh_mobile_sdhi_of_match[] = {
+ 	{ .compatible = "renesas,sdhi-shmobile" },
+ 	{ .compatible = "renesas,sdhi-sh7372" },
+ 	{ .compatible = "renesas,sdhi-sh73a0", .data = &sh_mobile_sdhi_of_cfg[0], },
+ 	{ .compatible = "renesas,sdhi-r8a73a4", .data = &sh_mobile_sdhi_of_cfg[0], },
+ 	{ .compatible = "renesas,sdhi-r8a7740", .data = &sh_mobile_sdhi_of_cfg[0], },
+ 	{ .compatible = "renesas,sdhi-r8a7778", .data = &of_rcar_gen1_compatible, },
+ 	{ .compatible = "renesas,sdhi-r8a7779", .data = &of_rcar_gen1_compatible, },
+ 	{ .compatible = "renesas,sdhi-r8a7790", .data = &of_rcar_gen2_compatible, },
+ 	{ .compatible = "renesas,sdhi-r8a7791", .data = &of_rcar_gen2_compatible, },
+ 	{},
+ };
+ MODULE_DEVICE_TABLE(of, sh_mobile_sdhi_of_match);
+ 
++>>>>>>> 384b2cbd56a0 (mmc: tmio: care about DMA tx/rx addr offset)
  struct sh_mobile_sdhi {
  	struct clk *clk;
  	struct tmio_mmc_data mmc_data;
@@@ -199,8 -228,14 +234,14 @@@ static int sh_mobile_sdhi_probe(struct 
  	if (of_id && of_id->data) {
  		const struct sh_mobile_sdhi_of_data *of_data = of_id->data;
  		mmc_data->flags |= of_data->tmio_flags;
++<<<<<<< HEAD
++=======
+ 		mmc_data->capabilities |= of_data->capabilities;
+ 		mmc_data->capabilities2 |= of_data->capabilities2;
+ 		dma_priv->dma_rx_offset = of_data->dma_rx_offset;
++>>>>>>> 384b2cbd56a0 (mmc: tmio: care about DMA tx/rx addr offset)
  	}
  
 -	/* SD control register space size is 0x100, 0x200 for bus_shift=1 */
 -	mmc_data->bus_shift = resource_size(res) >> 9;
 -
  	ret = tmio_mmc_host_probe(&host, pdev, mmc_data);
  	if (ret < 0)
  		goto eprobe;
diff --cc drivers/mmc/host/tmio_mmc_dma.c
index a8aaa7871c0d,bd646b041085..000000000000
--- a/drivers/mmc/host/tmio_mmc_dma.c
+++ b/drivers/mmc/host/tmio_mmc_dma.c
@@@ -304,9 -309,11 +304,14 @@@ void tmio_mmc_request_dma(struct tmio_m
  		if (!host->chan_rx)
  			goto ereqrx;
  
 -		if (pdata->dma->chan_priv_rx)
 -			cfg.slave_id = pdata->dma->slave_id_rx;
 +		cfg.slave_id = pdata->dma->slave_id_rx;
  		cfg.direction = DMA_DEV_TO_MEM;
++<<<<<<< HEAD
 +		cfg.src_addr = cfg.dst_addr;
++=======
+ 		cfg.src_addr = cfg.dst_addr + pdata->dma->dma_rx_offset;
+ 		cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
++>>>>>>> 384b2cbd56a0 (mmc: tmio: care about DMA tx/rx addr offset)
  		cfg.dst_addr = 0;
  		ret = dmaengine_slave_config(host->chan_rx, &cfg);
  		if (ret < 0)
* Unmerged path drivers/mmc/host/sh_mobile_sdhi.c
* Unmerged path drivers/mmc/host/tmio_mmc_dma.c
diff --git a/include/linux/mfd/tmio.h b/include/linux/mfd/tmio.h
index b22883d60500..3cde3b068a50 100644
--- a/include/linux/mfd/tmio.h
+++ b/include/linux/mfd/tmio.h
@@ -89,6 +89,7 @@ struct tmio_mmc_dma {
 	int slave_id_tx;
 	int slave_id_rx;
 	int alignment_shift;
+	dma_addr_t dma_rx_offset;
 	bool (*filter)(struct dma_chan *chan, void *arg);
 };
 
