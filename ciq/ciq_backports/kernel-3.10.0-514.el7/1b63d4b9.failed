netfilter: nf_tables_bridge: set the pktinfo for IPv4/IPv6 traffic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alvaro Neira <alvaroneay@gmail.com>
commit 1b63d4b9b54cee6002757a8d20b537aa4037ae8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1b63d4b9.failed

This patch adds the missing bits to allow to match per meta l4proto from
the bridge. Example:

  nft add rule bridge filter input ether type {ip, ip6} meta l4proto udp counter

	Signed-off-by: Alvaro Neira Ayuso <alvaroneay@gmail.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 1b63d4b9b54cee6002757a8d20b537aa4037ae8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/netfilter/nf_tables_bridge.c
diff --cc net/bridge/netfilter/nf_tables_bridge.c
index ff54b9e660b9,19473a9371b8..000000000000
--- a/net/bridge/netfilter/nf_tables_bridge.c
+++ b/net/bridge/netfilter/nf_tables_bridge.c
@@@ -13,6 -13,82 +13,85 @@@
  #include <linux/module.h>
  #include <linux/netfilter_bridge.h>
  #include <net/netfilter/nf_tables.h>
++<<<<<<< HEAD
++=======
+ #include <net/netfilter/nf_tables_bridge.h>
+ #include <linux/ip.h>
+ #include <linux/ipv6.h>
+ #include <net/netfilter/nf_tables_ipv4.h>
+ #include <net/netfilter/nf_tables_ipv6.h>
+ 
+ int nft_bridge_iphdr_validate(struct sk_buff *skb)
+ {
+ 	struct iphdr *iph;
+ 	u32 len;
+ 
+ 	if (!pskb_may_pull(skb, sizeof(struct iphdr)))
+ 		return 0;
+ 
+ 	iph = ip_hdr(skb);
+ 	if (iph->ihl < 5 || iph->version != 4)
+ 		return 0;
+ 
+ 	len = ntohs(iph->tot_len);
+ 	if (skb->len < len)
+ 		return 0;
+ 	else if (len < (iph->ihl*4))
+ 		return 0;
+ 
+ 	if (!pskb_may_pull(skb, iph->ihl*4))
+ 		return 0;
+ 
+ 	return 1;
+ }
+ EXPORT_SYMBOL_GPL(nft_bridge_iphdr_validate);
+ 
+ int nft_bridge_ip6hdr_validate(struct sk_buff *skb)
+ {
+ 	struct ipv6hdr *hdr;
+ 	u32 pkt_len;
+ 
+ 	if (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))
+ 		return 0;
+ 
+ 	hdr = ipv6_hdr(skb);
+ 	if (hdr->version != 6)
+ 		return 0;
+ 
+ 	pkt_len = ntohs(hdr->payload_len);
+ 	if (pkt_len + sizeof(struct ipv6hdr) > skb->len)
+ 		return 0;
+ 
+ 	return 1;
+ }
+ EXPORT_SYMBOL_GPL(nft_bridge_ip6hdr_validate);
++>>>>>>> 1b63d4b9b54c (netfilter: nf_tables_bridge: set the pktinfo for IPv4/IPv6 traffic)
+ 
+ static inline void nft_bridge_set_pktinfo_ipv4(struct nft_pktinfo *pkt,
+ 					       const struct nf_hook_ops *ops,
+ 					       struct sk_buff *skb,
+ 					       const struct net_device *in,
+ 					       const struct net_device *out)
+ {
+ 	if (nft_bridge_iphdr_validate(skb))
+ 		nft_set_pktinfo_ipv4(pkt, ops, skb, in, out);
+ 	else
+ 		nft_set_pktinfo(pkt, ops, skb, in, out);
+ }
+ 
+ static inline void nft_bridge_set_pktinfo_ipv6(struct nft_pktinfo *pkt,
+ 					      const struct nf_hook_ops *ops,
+ 					      struct sk_buff *skb,
+ 					      const struct net_device *in,
+ 					      const struct net_device *out)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (nft_bridge_ip6hdr_validate(skb) &&
+ 	    nft_set_pktinfo_ipv6(pkt, ops, skb, in, out) == 0)
+ 		return;
+ #endif
+ 	nft_set_pktinfo(pkt, ops, skb, in, out);
+ }
  
  static unsigned int
  nft_do_chain_bridge(const struct nf_hook_ops *ops,
@@@ -23,7 -99,17 +102,21 @@@
  {
  	struct nft_pktinfo pkt;
  
++<<<<<<< HEAD
 +	nft_set_pktinfo(&pkt, ops, skb, state);
++=======
+ 	switch (eth_hdr(skb)->h_proto) {
+ 	case htons(ETH_P_IP):
+ 		nft_bridge_set_pktinfo_ipv4(&pkt, ops, skb, in, out);
+ 		break;
+ 	case htons(ETH_P_IPV6):
+ 		nft_bridge_set_pktinfo_ipv6(&pkt, ops, skb, in, out);
+ 		break;
+ 	default:
+ 		nft_set_pktinfo(&pkt, ops, skb, in, out);
+ 		break;
+ 	}
++>>>>>>> 1b63d4b9b54c (netfilter: nf_tables_bridge: set the pktinfo for IPv4/IPv6 traffic)
  
  	return nft_do_chain(&pkt, ops);
  }
* Unmerged path net/bridge/netfilter/nf_tables_bridge.c
