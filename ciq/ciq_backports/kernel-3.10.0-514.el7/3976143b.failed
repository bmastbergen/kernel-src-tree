NFS41: remove NFS_LAYOUT_ROC flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peng Tao <tao.peng@primarydata.com>
commit 3976143b063e3c42fe5471d87860f6ae118e0eee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3976143b.failed

If we return delegation before closing, we fail to do roc check
during close because NFS_LAYOUT_ROC is cleared by delegreturn
and it causes layouts to be still hanging around after delegreturn
+ close, which is a voilation against protocol.

	Signed-off-by: Peng Tao <tao.peng@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 3976143b063e3c42fe5471d87860f6ae118e0eee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pnfs.c
diff --cc fs/nfs/pnfs.c
index ae25804d58d5,247c5a5d2d6b..000000000000
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@@ -1059,16 -1064,34 +1059,40 @@@ bool pnfs_roc(struct inode *ino
  	struct pnfs_layout_segment *lseg, *tmp;
  	nfs4_stateid stateid;
  	LIST_HEAD(tmp_list);
 -	bool found = false, layoutreturn = false, roc = false;
 +	bool found = false, layoutreturn = false;
  
  	spin_lock(&ino->i_lock);
++<<<<<<< HEAD
 +	lo = NFS_I(ino)->layout;
 +	if (!lo || !test_and_clear_bit(NFS_LAYOUT_ROC, &lo->plh_flags) ||
 +	    test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags))
 +		goto out_nolayout;
++=======
+ 	lo = nfsi->layout;
+ 	if (!lo || test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags))
+ 		goto out_noroc;
+ 
+ 	/* no roc if we hold a delegation */
+ 	if (nfs4_check_delegation(ino, FMODE_READ))
+ 		goto out_noroc;
+ 
+ 	list_for_each_entry(ctx, &nfsi->open_files, list) {
+ 		state = ctx->state;
+ 		/* Don't return layout if there is open file state */
+ 		if (state != NULL && state->state != 0)
+ 			goto out_noroc;
+ 	}
+ 
+ 	stateid = lo->plh_stateid;
+ 	/* always send layoutreturn if being marked so */
+ 	if (test_and_clear_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,
+ 				   &lo->plh_flags))
+ 		layoutreturn = pnfs_prepare_layoutreturn(lo);
+ 
++>>>>>>> 3976143b063e (NFS41: remove NFS_LAYOUT_ROC flag)
  	pnfs_clear_retry_layoutget(lo);
  	list_for_each_entry_safe(lseg, tmp, &lo->plh_segs, pls_list)
 -		/* If we are sending layoutreturn, invalidate all valid lsegs */
 -		if (layoutreturn || test_bit(NFS_LSEG_ROC, &lseg->pls_flags)) {
 +		if (test_bit(NFS_LSEG_ROC, &lseg->pls_flags)) {
  			mark_lseg_invalid(lseg, &tmp_list);
  			found = true;
  		}
* Unmerged path fs/nfs/pnfs.c
diff --git a/fs/nfs/pnfs.h b/fs/nfs/pnfs.h
index 9c425a959f66..ddf1abdc97e1 100644
--- a/fs/nfs/pnfs.h
+++ b/fs/nfs/pnfs.h
@@ -94,7 +94,6 @@ enum {
 	NFS_LAYOUT_RO_FAILED = 0,	/* get ro layout failed stop trying */
 	NFS_LAYOUT_RW_FAILED,		/* get rw layout failed stop trying */
 	NFS_LAYOUT_BULK_RECALL,		/* bulk recall affecting layout */
-	NFS_LAYOUT_ROC,			/* some lseg had roc bit set */
 	NFS_LAYOUT_RETURN,		/* Return this layout ASAP */
 	NFS_LAYOUT_RETURN_BEFORE_CLOSE,	/* Return this layout before close */
 	NFS_LAYOUT_INVALID_STID,	/* layout stateid id is invalid */
