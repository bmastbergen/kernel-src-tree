rhashtable: Add arbitrary rehash function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit aa34a6cb0478842452bac58edb50d3ef9e178c92
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/aa34a6cb.failed

This patch adds a rehash function that supports the use of any
hash function for the new table.  This is needed to support changing
the random seed value during the lifetime of the hash table.

However for now the random seed value is still constant and the
rehash function is simply used to replace the existing expand/shrink
functions.

[ ASSERT_BUCKET_LOCK() and thus debug_dump_table() +
  debug_dump_buckets() are not longer used, so delete them
  entirely. -DaveM ]

	Signed-off-by: Herbert Xu <herbert.xu@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit aa34a6cb0478842452bac58edb50d3ef9e178c92)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/rhashtable.c
diff --cc lib/rhashtable.c
index 6d0c4774001c,b1c19c5fb326..000000000000
--- a/lib/rhashtable.c
+++ b/lib/rhashtable.c
@@@ -54,49 -66,97 +54,130 @@@ static u32 rht_bucket_index(const struc
  	return hash & (tbl->size - 1);
  }
  
 -static u32 obj_raw_hashfn(struct rhashtable *ht,
 -			  const struct bucket_table *tbl, const void *ptr)
++<<<<<<< HEAD
 +static u32 obj_raw_hashfn(const struct rhashtable *ht, const void *ptr)
  {
  	u32 hash;
  
  	if (unlikely(!ht->p.key_len))
 -		hash = ht->p.obj_hashfn(ptr, tbl->hash_rnd);
 +		hash = ht->p.obj_hashfn(ptr, ht->p.hash_rnd);
  	else
  		hash = ht->p.hashfn(ptr + ht->p.key_offset, ht->p.key_len,
 -				    tbl->hash_rnd);
 +				    ht->p.hash_rnd);
  
 -	return hash >> HASH_RESERVED_SPACE;
 +	return hash;
  }
  
 +static u32 key_hashfn(const struct rhashtable *ht, const void *key, u32 len)
++=======
++static u32 obj_raw_hashfn(struct rhashtable *ht,
++			  const struct bucket_table *tbl, const void *ptr)
++>>>>>>> aa34a6cb0478 (rhashtable: Add arbitrary rehash function)
 +{
- 	struct bucket_table *tbl = rht_dereference_rcu(ht->tbl, ht);
 +	u32 hash;
 +
 +	hash = ht->p.hashfn(key, len, ht->p.hash_rnd);
 +
 +	return rht_bucket_index(tbl, hash);
 +}
 +
++<<<<<<< HEAD
 +static u32 head_hashfn(const struct rhashtable *ht,
++=======
+ static u32 key_hashfn(struct rhashtable *ht, const struct bucket_table *tbl,
+ 		      const void *key, u32 len)
+ {
+ 	return ht->p.hashfn(key, len, tbl->hash_rnd) >> HASH_RESERVED_SPACE;
+ }
+ 
+ static u32 head_hashfn(struct rhashtable *ht,
++>>>>>>> aa34a6cb0478 (rhashtable: Add arbitrary rehash function)
  		       const struct bucket_table *tbl,
  		       const struct rhash_head *he)
  {
- 	return rht_bucket_index(tbl, obj_raw_hashfn(ht, rht_obj(ht, he)));
+ 	return rht_bucket_index(tbl, obj_raw_hashfn(ht, tbl, rht_obj(ht, he)));
  }
  
++<<<<<<< HEAD
 +static struct rhash_head __rcu **bucket_tail(struct bucket_table *tbl, u32 n)
 +{
 +	struct rhash_head __rcu **pprev;
 +
 +	for (pprev = &tbl->buckets[n];
 +	     rht_dereference_bucket(*pprev, tbl, n);
 +	     pprev = &rht_dereference_bucket(*pprev, tbl, n)->next)
 +		;
 +
 +	return pprev;
 +}
 +
 +static struct bucket_table *bucket_table_alloc(size_t nbuckets)
++=======
+ #ifdef CONFIG_PROVE_LOCKING
+ #define ASSERT_RHT_MUTEX(HT) BUG_ON(!lockdep_rht_mutex_is_held(HT))
+ 
+ int lockdep_rht_mutex_is_held(struct rhashtable *ht)
+ {
+ 	return (debug_locks) ? lockdep_is_held(&ht->mutex) : 1;
+ }
+ EXPORT_SYMBOL_GPL(lockdep_rht_mutex_is_held);
+ 
+ int lockdep_rht_bucket_is_held(const struct bucket_table *tbl, u32 hash)
+ {
+ 	spinlock_t *lock = bucket_lock(tbl, hash);
+ 
+ 	return (debug_locks) ? lockdep_is_held(lock) : 1;
+ }
+ EXPORT_SYMBOL_GPL(lockdep_rht_bucket_is_held);
+ #else
+ #define ASSERT_RHT_MUTEX(HT)
+ #endif
+ 
+ 
+ static int alloc_bucket_locks(struct rhashtable *ht, struct bucket_table *tbl)
+ {
+ 	unsigned int i, size;
+ #if defined(CONFIG_PROVE_LOCKING)
+ 	unsigned int nr_pcpus = 2;
+ #else
+ 	unsigned int nr_pcpus = num_possible_cpus();
+ #endif
+ 
+ 	nr_pcpus = min_t(unsigned int, nr_pcpus, 32UL);
+ 	size = roundup_pow_of_two(nr_pcpus * ht->p.locks_mul);
+ 
+ 	/* Never allocate more than 0.5 locks per bucket */
+ 	size = min_t(unsigned int, size, tbl->size >> 1);
+ 
+ 	if (sizeof(spinlock_t) != 0) {
+ #ifdef CONFIG_NUMA
+ 		if (size * sizeof(spinlock_t) > PAGE_SIZE)
+ 			tbl->locks = vmalloc(size * sizeof(spinlock_t));
+ 		else
+ #endif
+ 		tbl->locks = kmalloc_array(size, sizeof(spinlock_t),
+ 					   GFP_KERNEL);
+ 		if (!tbl->locks)
+ 			return -ENOMEM;
+ 		for (i = 0; i < size; i++)
+ 			spin_lock_init(&tbl->locks[i]);
+ 	}
+ 	tbl->locks_mask = size - 1;
+ 
+ 	return 0;
+ }
+ 
+ static void bucket_table_free(const struct bucket_table *tbl)
+ {
+ 	if (tbl)
+ 		kvfree(tbl->locks);
+ 
+ 	kvfree(tbl);
+ }
+ 
+ static struct bucket_table *bucket_table_alloc(struct rhashtable *ht,
+ 					       size_t nbuckets)
++>>>>>>> aa34a6cb0478 (rhashtable: Add arbitrary rehash function)
  {
  	struct bucket_table *tbl = NULL;
  	size_t size;
@@@ -136,54 -200,99 +217,143 @@@ EXPORT_SYMBOL_GPL(rht_grow_above_75)
   * @ht:		hash table
   * @new_size:	new table size
   */
 -static bool rht_shrink_below_30(const struct rhashtable *ht, size_t new_size)
 +bool rht_shrink_below_30(const struct rhashtable *ht, size_t new_size)
  {
  	/* Shrink table beneath 30% load */
 -	return atomic_read(&ht->nelems) < (new_size * 3 / 10) &&
 -	       (atomic_read(&ht->shift) > ht->p.min_shift);
 +	return ht->nelems < (new_size * 3 / 10);
  }
 +EXPORT_SYMBOL_GPL(rht_shrink_below_30);
 +
++<<<<<<< HEAD
 +static void hashtable_chain_unzip(const struct rhashtable *ht,
 +				  const struct bucket_table *new_tbl,
 +				  struct bucket_table *old_tbl, size_t n)
 +{
 +	struct rhash_head *he, *p, *next;
 +	unsigned int h;
 +
 +	/* Old bucket empty, no work needed. */
 +	p = rht_dereference(old_tbl->buckets[n], ht);
 +	if (!p)
 +		return;
  
 +	/* Advance the old bucket pointer one or more times until it
 +	 * reaches a node that doesn't hash to the same bucket as the
 +	 * previous node p. Call the previous node p;
 +	 */
 +	h = head_hashfn(ht, new_tbl, p);
 +	rht_for_each_continue(he, p->next, old_tbl, n) {
 +		if (head_hashfn(ht, new_tbl, he) != h)
 +			break;
 +		p = he;
 +	}
 +	RCU_INIT_POINTER(old_tbl->buckets[n], p->next);
 +
 +	/* Find the subsequent node which does hash to the same
 +	 * bucket as node P, or NULL if no such node exists.
 +	 */
 +	next = NULL;
 +	if (he) {
 +		rht_for_each_continue(he, he->next, old_tbl, n) {
 +			if (head_hashfn(ht, new_tbl, he) == h) {
 +				next = he;
 +				break;
 +			}
 +		}
 +	}
 +
 +	/* Set p's next pointer to that subsequent node pointer,
 +	 * bypassing the nodes which do not hash to p's bucket
 +	 */
 +	RCU_INIT_POINTER(p->next, next);
++=======
+ static int rhashtable_rehash_one(struct rhashtable *ht, unsigned old_hash)
+ {
+ 	struct bucket_table *new_tbl = rht_dereference(ht->future_tbl, ht);
+ 	struct bucket_table *old_tbl = rht_dereference(ht->tbl, ht);
+ 	struct rhash_head __rcu **pprev = &old_tbl->buckets[old_hash];
+ 	int err = -ENOENT;
+ 	struct rhash_head *head, *next, *entry;
+ 	spinlock_t *new_bucket_lock;
+ 	unsigned new_hash;
+ 
+ 	rht_for_each(entry, old_tbl, old_hash) {
+ 		err = 0;
+ 		next = rht_dereference_bucket(entry->next, old_tbl, old_hash);
+ 
+ 		if (rht_is_a_nulls(next))
+ 			break;
+ 
+ 		pprev = &entry->next;
+ 	}
+ 
+ 	if (err)
+ 		goto out;
+ 
+ 	new_hash = head_hashfn(ht, new_tbl, entry);
+ 
+ 	new_bucket_lock = bucket_lock(new_tbl, new_hash);
+ 
+ 	spin_lock(new_bucket_lock);
+ 	head = rht_dereference_bucket(new_tbl->buckets[new_hash],
+ 				      new_tbl, new_hash);
+ 
+ 	if (rht_is_a_nulls(head))
+ 		INIT_RHT_NULLS_HEAD(entry->next, ht, new_hash);
+ 	else
+ 		RCU_INIT_POINTER(entry->next, head);
+ 
+ 	rcu_assign_pointer(new_tbl->buckets[new_hash], entry);
+ 	spin_unlock(new_bucket_lock);
+ 
+ 	rcu_assign_pointer(*pprev, next);
+ 
+ out:
+ 	return err;
+ }
+ 
+ static void rhashtable_rehash_chain(struct rhashtable *ht, unsigned old_hash)
+ {
+ 	struct bucket_table *old_tbl = rht_dereference(ht->tbl, ht);
+ 	spinlock_t *old_bucket_lock;
+ 
+ 	old_bucket_lock = bucket_lock(old_tbl, old_hash);
+ 
+ 	spin_lock_bh(old_bucket_lock);
+ 	while (!rhashtable_rehash_one(ht, old_hash))
+ 		;
+ 	spin_unlock_bh(old_bucket_lock);
+ }
+ 
+ static void rhashtable_rehash(struct rhashtable *ht,
+ 			      struct bucket_table *new_tbl)
+ {
+ 	struct bucket_table *old_tbl = rht_dereference(ht->tbl, ht);
+ 	unsigned old_hash;
+ 
+ 	get_random_bytes(&new_tbl->hash_rnd, sizeof(new_tbl->hash_rnd));
+ 
+ 	/* Make insertions go into the new, empty table right away. Deletions
+ 	 * and lookups will be attempted in both tables until we synchronize.
+ 	 * The synchronize_rcu() guarantees for the new table to be picked up
+ 	 * so no new additions go into the old table while we relink.
+ 	 */
+ 	rcu_assign_pointer(ht->future_tbl, new_tbl);
+ 
+ 	for (old_hash = 0; old_hash < old_tbl->size; old_hash++)
+ 		rhashtable_rehash_chain(ht, old_hash);
+ 
+ 	/* Publish the new table pointer. */
+ 	rcu_assign_pointer(ht->tbl, new_tbl);
+ 
+ 	/* Wait for readers. All new readers will see the new
+ 	 * table, and thus no references to the old table will
+ 	 * remain.
+ 	 */
+ 	synchronize_rcu();
+ 
+ 	bucket_table_free(old_tbl);
++>>>>>>> aa34a6cb0478 (rhashtable: Add arbitrary rehash function)
  }
  
  /**
@@@ -202,9 -313,6 +371,12 @@@
  int rhashtable_expand(struct rhashtable *ht)
  {
  	struct bucket_table *new_tbl, *old_tbl = rht_dereference(ht->tbl, ht);
++<<<<<<< HEAD
 +	struct rhash_head *he;
 +	unsigned int i, h;
 +	bool complete;
++=======
++>>>>>>> aa34a6cb0478 (rhashtable: Add arbitrary rehash function)
  
  	ASSERT_RHT_MUTEX(ht);
  
@@@ -215,55 -320,12 +387,62 @@@
  	if (new_tbl == NULL)
  		return -ENOMEM;
  
 -	new_tbl->hash_rnd = old_tbl->hash_rnd;
 +	ht->shift++;
 +
++<<<<<<< HEAD
 +	/* For each new bucket, search the corresponding old bucket
 +	 * for the first entry that hashes to the new bucket, and
 +	 * link the new bucket to that entry. Since all the entries
 +	 * which will end up in the new bucket appear in the same
 +	 * old bucket, this constructs an entirely valid new hash
 +	 * table, but with multiple buckets "zipped" together into a
 +	 * single imprecise chain.
 +	 */
 +	for (i = 0; i < new_tbl->size; i++) {
 +		h = rht_bucket_index(old_tbl, i);
 +		rht_for_each(he, old_tbl, h) {
 +			if (head_hashfn(ht, new_tbl, he) == i) {
 +				RCU_INIT_POINTER(new_tbl->buckets[i], he);
 +				break;
 +			}
 +		}
 +	}
 +
 +	/* Publish the new table pointer. Lookups may now traverse
 +	 * the new table, but they will not benefit from any
 +	 * additional efficiency until later steps unzip the buckets.
 +	 */
 +	rcu_assign_pointer(ht->tbl, new_tbl);
 +
 +	/* Unzip interleaved hash chains */
 +	do {
 +		/* Wait for readers. All new readers will see the new
 +		 * table, and thus no references to the old table will
 +		 * remain.
 +		 */
 +		synchronize_rcu();
 +
 +		/* For each bucket in the old table (each of which
 +		 * contains items from multiple buckets of the new
 +		 * table): ...
 +		 */
 +		complete = true;
 +		for (i = 0; i < old_tbl->size; i++) {
 +			hashtable_chain_unzip(ht, new_tbl, old_tbl, i);
 +			if (old_tbl->buckets[i] != NULL)
 +				complete = false;
 +		}
 +	} while (!complete);
 +
 +	synchronize_rcu();
  
 +	bucket_table_free(old_tbl);
++=======
+ 	atomic_inc(&ht->shift);
+ 
+ 	rhashtable_rehash(ht, new_tbl);
+ 
++>>>>>>> aa34a6cb0478 (rhashtable: Add arbitrary rehash function)
  	return 0;
  }
  EXPORT_SYMBOL_GPL(rhashtable_expand);
@@@ -280,47 -345,118 +459,142 @@@
   */
  int rhashtable_shrink(struct rhashtable *ht)
  {
++<<<<<<< HEAD
 +	struct bucket_table *ntbl, *tbl = rht_dereference(ht->tbl, ht);
 +	unsigned int i;
++=======
+ 	struct bucket_table *new_tbl, *tbl = rht_dereference(ht->tbl, ht);
++>>>>>>> aa34a6cb0478 (rhashtable: Add arbitrary rehash function)
  
  	ASSERT_RHT_MUTEX(ht);
  
 -	new_tbl = bucket_table_alloc(ht, tbl->size / 2);
 -	if (new_tbl == NULL)
 +	if (ht->shift <= ht->p.min_shift)
 +		return 0;
 +
 +	ntbl = bucket_table_alloc(tbl->size / 2);
 +	if (ntbl == NULL)
  		return -ENOMEM;
  
 -	new_tbl->hash_rnd = tbl->hash_rnd;
 +	ht->shift--;
 +
++<<<<<<< HEAD
 +	/* Link each bucket in the new table to the first bucket
 +	 * in the old table that contains entries which will hash
 +	 * to the new bucket.
 +	 */
 +	for (i = 0; i < ntbl->size; i++) {
 +		ntbl->buckets[i] = tbl->buckets[i];
 +		RCU_INIT_POINTER(*bucket_tail(ntbl, i),
 +				 tbl->buckets[i + ntbl->size]);
  
 +	}
 +
 +	/* Publish the new, valid hash table */
 +	rcu_assign_pointer(ht->tbl, ntbl);
++=======
+ 	atomic_dec(&ht->shift);
++>>>>>>> aa34a6cb0478 (rhashtable: Add arbitrary rehash function)
  
- 	/* Wait for readers. No new readers will have references to the
- 	 * old hash table.
- 	 */
- 	synchronize_rcu();
- 
- 	bucket_table_free(tbl);
+ 	rhashtable_rehash(ht, new_tbl);
  
  	return 0;
  }
  EXPORT_SYMBOL_GPL(rhashtable_shrink);
  
++<<<<<<< HEAD
++=======
+ static void rht_deferred_worker(struct work_struct *work)
+ {
+ 	struct rhashtable *ht;
+ 	struct bucket_table *tbl;
+ 	struct rhashtable_walker *walker;
+ 
+ 	ht = container_of(work, struct rhashtable, run_work);
+ 	mutex_lock(&ht->mutex);
+ 	if (ht->being_destroyed)
+ 		goto unlock;
+ 
+ 	tbl = rht_dereference(ht->tbl, ht);
+ 
+ 	list_for_each_entry(walker, &ht->walkers, list)
+ 		walker->resize = true;
+ 
+ 	if (rht_grow_above_75(ht, tbl->size))
+ 		rhashtable_expand(ht);
+ 	else if (rht_shrink_below_30(ht, tbl->size))
+ 		rhashtable_shrink(ht);
+ unlock:
+ 	mutex_unlock(&ht->mutex);
+ }
+ 
+ static bool __rhashtable_insert(struct rhashtable *ht, struct rhash_head *obj,
+ 				bool (*compare)(void *, void *), void *arg)
+ {
+ 	struct bucket_table *tbl, *old_tbl;
+ 	struct rhash_head *head;
+ 	bool no_resize_running;
+ 	unsigned hash;
+ 	bool success = true;
+ 
+ 	rcu_read_lock();
+ 
+ 	old_tbl = rht_dereference_rcu(ht->tbl, ht);
+ 	hash = obj_raw_hashfn(ht, old_tbl, rht_obj(ht, obj));
+ 
+ 	spin_lock_bh(bucket_lock(old_tbl, hash));
+ 
+ 	/* Because we have already taken the bucket lock in old_tbl,
+ 	 * if we find that future_tbl is not yet visible then that
+ 	 * guarantees all other insertions of the same entry will
+ 	 * also grab the bucket lock in old_tbl because until the
+ 	 * rehash completes ht->tbl won't be changed.
+ 	 */
+ 	tbl = rht_dereference_rcu(ht->future_tbl, ht);
+ 	if (tbl != old_tbl) {
+ 		hash = obj_raw_hashfn(ht, tbl, rht_obj(ht, obj));
+ 		spin_lock(bucket_lock(tbl, hash));
+ 	}
+ 
+ 	if (compare &&
+ 	    rhashtable_lookup_compare(ht, rht_obj(ht, obj) + ht->p.key_offset,
+ 				      compare, arg)) {
+ 		success = false;
+ 		goto exit;
+ 	}
+ 
+ 	no_resize_running = tbl == old_tbl;
+ 
+ 	hash = rht_bucket_index(tbl, hash);
+ 	head = rht_dereference_bucket(tbl->buckets[hash], tbl, hash);
+ 
+ 	if (rht_is_a_nulls(head))
+ 		INIT_RHT_NULLS_HEAD(obj->next, ht, hash);
+ 	else
+ 		RCU_INIT_POINTER(obj->next, head);
+ 
+ 	rcu_assign_pointer(tbl->buckets[hash], obj);
+ 
+ 	atomic_inc(&ht->nelems);
+ 	if (no_resize_running && rht_grow_above_75(ht, tbl->size))
+ 		schedule_work(&ht->run_work);
+ 
+ exit:
+ 	if (tbl != old_tbl) {
+ 		hash = obj_raw_hashfn(ht, tbl, rht_obj(ht, obj));
+ 		spin_unlock(bucket_lock(tbl, hash));
+ 	}
+ 
+ 	hash = obj_raw_hashfn(ht, old_tbl, rht_obj(ht, obj));
+ 	spin_unlock_bh(bucket_lock(old_tbl, hash));
+ 
+ 	rcu_read_unlock();
+ 
+ 	return success;
+ }
+ 
++>>>>>>> aa34a6cb0478 (rhashtable: Add arbitrary rehash function)
  /**
 - * rhashtable_insert - insert object into hash table
 + * rhashtable_insert - insert object into hash hash table
   * @ht:		hash table
   * @obj:	pointer to hash head inside object
   *
@@@ -332,18 -472,7 +606,22 @@@
   */
  void rhashtable_insert(struct rhashtable *ht, struct rhash_head *obj)
  {
++<<<<<<< HEAD
 +	struct bucket_table *tbl = rht_dereference(ht->tbl, ht);
 +	u32 hash;
 +
 +	ASSERT_RHT_MUTEX(ht);
 +
 +	hash = head_hashfn(ht, tbl, obj);
 +	RCU_INIT_POINTER(obj->next, tbl->buckets[hash]);
 +	rcu_assign_pointer(tbl->buckets[hash], obj);
 +	ht->nelems++;
 +
 +	if (ht->p.grow_decision && ht->p.grow_decision(ht, tbl->size))
 +		rhashtable_expand(ht);
++=======
+ 	__rhashtable_insert(ht, obj, NULL, NULL);
++>>>>>>> aa34a6cb0478 (rhashtable: Add arbitrary rehash function)
  }
  EXPORT_SYMBOL_GPL(rhashtable_insert);
  
@@@ -364,33 -526,34 +675,64 @@@ static bool __rhashtable_remove(struct 
   */
  bool rhashtable_remove(struct rhashtable *ht, struct rhash_head *obj)
  {
++<<<<<<< HEAD
 +	struct bucket_table *tbl = rht_dereference(ht->tbl, ht);
 +	struct rhash_head __rcu **pprev;
 +	struct rhash_head *he;
 +	u32 h;
 +
 +	ASSERT_RHT_MUTEX(ht);
 +
 +	h = head_hashfn(ht, tbl, obj);
 +
 +	pprev = &tbl->buckets[h];
 +	rht_for_each(he, tbl, h) {
 +		if (he != obj) {
 +			pprev = &he->next;
 +			continue;
 +		}
 +
 +		RCU_INIT_POINTER(*pprev, he->next);
 +		ht->nelems--;
 +
 +		if (ht->p.shrink_decision &&
 +		    ht->p.shrink_decision(ht, tbl->size))
 +			rhashtable_shrink(ht);
 +
 +		return true;
 +	}
 +
 +	return false;
++=======
+ 	struct bucket_table *tbl, *old_tbl;
+ 	bool ret;
+ 
+ 	rcu_read_lock();
+ 
+ 	old_tbl = rht_dereference_rcu(ht->tbl, ht);
+ 	ret = __rhashtable_remove(ht, old_tbl, obj);
+ 
+ 	/* Because we have already taken (and released) the bucket
+ 	 * lock in old_tbl, if we find that future_tbl is not yet
+ 	 * visible then that guarantees the entry to still be in
+ 	 * old_tbl if it exists.
+ 	 */
+ 	tbl = rht_dereference_rcu(ht->future_tbl, ht);
+ 	if (!ret && old_tbl != tbl)
+ 		ret = __rhashtable_remove(ht, tbl, obj);
+ 
+ 	if (ret) {
+ 		bool no_resize_running = tbl == old_tbl;
+ 
+ 		atomic_dec(&ht->nelems);
+ 		if (no_resize_running && rht_shrink_below_30(ht, tbl->size))
+ 			schedule_work(&ht->run_work);
+ 	}
+ 
+ 	rcu_read_unlock();
+ 
+ 	return ret;
++>>>>>>> aa34a6cb0478 (rhashtable: Add arbitrary rehash function)
  }
  EXPORT_SYMBOL_GPL(rhashtable_remove);
  
@@@ -450,17 -617,254 +792,264 @@@ void *rhashtable_lookup_compare(const s
  	struct rhash_head *he;
  	u32 hash;
  
++<<<<<<< HEAD
 +	hash = key_hashfn(ht, key, ht->p.key_len);
 +	rht_for_each_rcu(he, tbl, hash) {
++=======
+ 	rcu_read_lock();
+ 
+ 	tbl = rht_dereference_rcu(ht->tbl, ht);
+ 	hash = key_hashfn(ht, tbl, key, ht->p.key_len);
+ restart:
+ 	rht_for_each_rcu(he, tbl, rht_bucket_index(tbl, hash)) {
++>>>>>>> aa34a6cb0478 (rhashtable: Add arbitrary rehash function)
  		if (!compare(rht_obj(ht, he), arg))
  			continue;
 -		rcu_read_unlock();
  		return rht_obj(ht, he);
  	}
  
++<<<<<<< HEAD
++=======
+ 	old_tbl = tbl;
+ 	tbl = rht_dereference_rcu(ht->future_tbl, ht);
+ 	if (unlikely(tbl != old_tbl))
+ 		goto restart;
+ 	rcu_read_unlock();
+ 
++>>>>>>> aa34a6cb0478 (rhashtable: Add arbitrary rehash function)
  	return NULL;
  }
  EXPORT_SYMBOL_GPL(rhashtable_lookup_compare);
  
++<<<<<<< HEAD
++=======
+ /**
+  * rhashtable_lookup_insert - lookup and insert object into hash table
+  * @ht:		hash table
+  * @obj:	pointer to hash head inside object
+  *
+  * Locks down the bucket chain in both the old and new table if a resize
+  * is in progress to ensure that writers can't remove from the old table
+  * and can't insert to the new table during the atomic operation of search
+  * and insertion. Searches for duplicates in both the old and new table if
+  * a resize is in progress.
+  *
+  * This lookup function may only be used for fixed key hash table (key_len
+  * parameter set). It will BUG() if used inappropriately.
+  *
+  * It is safe to call this function from atomic context.
+  *
+  * Will trigger an automatic deferred table resizing if the size grows
+  * beyond the watermark indicated by grow_decision() which can be passed
+  * to rhashtable_init().
+  */
+ bool rhashtable_lookup_insert(struct rhashtable *ht, struct rhash_head *obj)
+ {
+ 	struct rhashtable_compare_arg arg = {
+ 		.ht = ht,
+ 		.key = rht_obj(ht, obj) + ht->p.key_offset,
+ 	};
+ 
+ 	BUG_ON(!ht->p.key_len);
+ 
+ 	return rhashtable_lookup_compare_insert(ht, obj, &rhashtable_compare,
+ 						&arg);
+ }
+ EXPORT_SYMBOL_GPL(rhashtable_lookup_insert);
+ 
+ /**
+  * rhashtable_lookup_compare_insert - search and insert object to hash table
+  *                                    with compare function
+  * @ht:		hash table
+  * @obj:	pointer to hash head inside object
+  * @compare:	compare function, must return true on match
+  * @arg:	argument passed on to compare function
+  *
+  * Locks down the bucket chain in both the old and new table if a resize
+  * is in progress to ensure that writers can't remove from the old table
+  * and can't insert to the new table during the atomic operation of search
+  * and insertion. Searches for duplicates in both the old and new table if
+  * a resize is in progress.
+  *
+  * Lookups may occur in parallel with hashtable mutations and resizing.
+  *
+  * Will trigger an automatic deferred table resizing if the size grows
+  * beyond the watermark indicated by grow_decision() which can be passed
+  * to rhashtable_init().
+  */
+ bool rhashtable_lookup_compare_insert(struct rhashtable *ht,
+ 				      struct rhash_head *obj,
+ 				      bool (*compare)(void *, void *),
+ 				      void *arg)
+ {
+ 	BUG_ON(!ht->p.key_len);
+ 
+ 	return __rhashtable_insert(ht, obj, compare, arg);
+ }
+ EXPORT_SYMBOL_GPL(rhashtable_lookup_compare_insert);
+ 
+ /**
+  * rhashtable_walk_init - Initialise an iterator
+  * @ht:		Table to walk over
+  * @iter:	Hash table Iterator
+  *
+  * This function prepares a hash table walk.
+  *
+  * Note that if you restart a walk after rhashtable_walk_stop you
+  * may see the same object twice.  Also, you may miss objects if
+  * there are removals in between rhashtable_walk_stop and the next
+  * call to rhashtable_walk_start.
+  *
+  * For a completely stable walk you should construct your own data
+  * structure outside the hash table.
+  *
+  * This function may sleep so you must not call it from interrupt
+  * context or with spin locks held.
+  *
+  * You must call rhashtable_walk_exit if this function returns
+  * successfully.
+  */
+ int rhashtable_walk_init(struct rhashtable *ht, struct rhashtable_iter *iter)
+ {
+ 	iter->ht = ht;
+ 	iter->p = NULL;
+ 	iter->slot = 0;
+ 	iter->skip = 0;
+ 
+ 	iter->walker = kmalloc(sizeof(*iter->walker), GFP_KERNEL);
+ 	if (!iter->walker)
+ 		return -ENOMEM;
+ 
+ 	INIT_LIST_HEAD(&iter->walker->list);
+ 	iter->walker->resize = false;
+ 
+ 	mutex_lock(&ht->mutex);
+ 	list_add(&iter->walker->list, &ht->walkers);
+ 	mutex_unlock(&ht->mutex);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(rhashtable_walk_init);
+ 
+ /**
+  * rhashtable_walk_exit - Free an iterator
+  * @iter:	Hash table Iterator
+  *
+  * This function frees resources allocated by rhashtable_walk_init.
+  */
+ void rhashtable_walk_exit(struct rhashtable_iter *iter)
+ {
+ 	mutex_lock(&iter->ht->mutex);
+ 	list_del(&iter->walker->list);
+ 	mutex_unlock(&iter->ht->mutex);
+ 	kfree(iter->walker);
+ }
+ EXPORT_SYMBOL_GPL(rhashtable_walk_exit);
+ 
+ /**
+  * rhashtable_walk_start - Start a hash table walk
+  * @iter:	Hash table iterator
+  *
+  * Start a hash table walk.  Note that we take the RCU lock in all
+  * cases including when we return an error.  So you must always call
+  * rhashtable_walk_stop to clean up.
+  *
+  * Returns zero if successful.
+  *
+  * Returns -EAGAIN if resize event occured.  Note that the iterator
+  * will rewind back to the beginning and you may use it immediately
+  * by calling rhashtable_walk_next.
+  */
+ int rhashtable_walk_start(struct rhashtable_iter *iter)
+ {
+ 	rcu_read_lock();
+ 
+ 	if (iter->walker->resize) {
+ 		iter->slot = 0;
+ 		iter->skip = 0;
+ 		iter->walker->resize = false;
+ 		return -EAGAIN;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(rhashtable_walk_start);
+ 
+ /**
+  * rhashtable_walk_next - Return the next object and advance the iterator
+  * @iter:	Hash table iterator
+  *
+  * Note that you must call rhashtable_walk_stop when you are finished
+  * with the walk.
+  *
+  * Returns the next object or NULL when the end of the table is reached.
+  *
+  * Returns -EAGAIN if resize event occured.  Note that the iterator
+  * will rewind back to the beginning and you may continue to use it.
+  */
+ void *rhashtable_walk_next(struct rhashtable_iter *iter)
+ {
+ 	const struct bucket_table *tbl;
+ 	struct rhashtable *ht = iter->ht;
+ 	struct rhash_head *p = iter->p;
+ 	void *obj = NULL;
+ 
+ 	tbl = rht_dereference_rcu(ht->tbl, ht);
+ 
+ 	if (p) {
+ 		p = rht_dereference_bucket_rcu(p->next, tbl, iter->slot);
+ 		goto next;
+ 	}
+ 
+ 	for (; iter->slot < tbl->size; iter->slot++) {
+ 		int skip = iter->skip;
+ 
+ 		rht_for_each_rcu(p, tbl, iter->slot) {
+ 			if (!skip)
+ 				break;
+ 			skip--;
+ 		}
+ 
+ next:
+ 		if (!rht_is_a_nulls(p)) {
+ 			iter->skip++;
+ 			iter->p = p;
+ 			obj = rht_obj(ht, p);
+ 			goto out;
+ 		}
+ 
+ 		iter->skip = 0;
+ 	}
+ 
+ 	iter->p = NULL;
+ 
+ out:
+ 	if (iter->walker->resize) {
+ 		iter->p = NULL;
+ 		iter->slot = 0;
+ 		iter->skip = 0;
+ 		iter->walker->resize = false;
+ 		return ERR_PTR(-EAGAIN);
+ 	}
+ 
+ 	return obj;
+ }
+ EXPORT_SYMBOL_GPL(rhashtable_walk_next);
+ 
+ /**
+  * rhashtable_walk_stop - Finish a hash table walk
+  * @iter:	Hash table iterator
+  *
+  * Finish a hash table walk.
+  */
+ void rhashtable_walk_stop(struct rhashtable_iter *iter)
+ {
+ 	rcu_read_unlock();
+ 	iter->p = NULL;
+ }
+ EXPORT_SYMBOL_GPL(rhashtable_walk_stop);
+ 
++>>>>>>> aa34a6cb0478 (rhashtable: Add arbitrary rehash function)
  static size_t rounded_hashtable_size(struct rhashtable_params *params)
  {
  	return max(roundup_pow_of_two(params->nelem_hint * 4 / 3),
* Unmerged path lib/rhashtable.c
