drm: add missing drm_mode_set_crtcinfo call

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drm] add missing drm_mode_set_crtcinfo call (Rob Clark) [1348329 1349064]
Rebuild_FUZZ: 93.83%
commit-author Tomi Valkeinen <tomi.valkeinen@ti.com>
commit b201e743f42d143f4bcdcb14587caf7cb1d99229
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b201e743.failed

When setting mode via MODE_ID property,
drm_atomic_set_mode_prop_for_crtc() does not call
drm_mode_set_crtcinfo() which possibly causes:

"[drm:drm_calc_timestamping_constants [drm]] *ERROR* crtc 32: Can't
calculate constants, dotclock = 0!"

Whether the error is seen depends on the previous data in state->mode,
as state->mode is not cleared when setting new mode.

This patch adds drm_mode_set_crtcinfo() call to
drm_mode_convert_umode(), which is called in both legacy and atomic
paths. This should be fine as there's no reason to call
drm_mode_convert_umode() without also setting the crtc related fields.

drm_mode_set_crtcinfo() is removed from the legacy drm_mode_setcrtc() as
that is no longer needed.

	Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
	Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
	Cc: stable@vger.kernel.org
	Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit b201e743f42d143f4bcdcb14587caf7cb1d99229)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/drm_crtc.c
#	drivers/gpu/drm/drm_modes.c
diff --cc drivers/gpu/drm/drm_crtc.c
index 800a025dd062,06b6e2173697..000000000000
--- a/drivers/gpu/drm/drm_crtc.c
+++ b/drivers/gpu/drm/drm_crtc.c
@@@ -2799,14 -2821,6 +2799,17 @@@ int drm_mode_setcrtc(struct drm_device 
  			goto out;
  		}
  
++<<<<<<< HEAD
 +		mode->status = drm_mode_validate_basic(mode);
 +		if (mode->status != MODE_OK) {
 +			ret = -EINVAL;
 +			goto out;
 +		}
 +
 +		drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);
 +
++=======
++>>>>>>> b201e743f42d (drm: add missing drm_mode_set_crtcinfo call)
  		/*
  		 * Check whether the primary plane supports the fb pixel format.
  		 * Drivers not implementing the universal planes API use a
diff --cc drivers/gpu/drm/drm_modes.c
index 213b11ea69b5,e5e6f504d8cc..000000000000
--- a/drivers/gpu/drm/drm_modes.c
+++ b/drivers/gpu/drm/drm_modes.c
@@@ -1405,3 -1436,92 +1405,95 @@@ drm_mode_create_from_cmdline_mode(struc
  	return mode;
  }
  EXPORT_SYMBOL(drm_mode_create_from_cmdline_mode);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * drm_crtc_convert_to_umode - convert a drm_display_mode into a modeinfo
+  * @out: drm_mode_modeinfo struct to return to the user
+  * @in: drm_display_mode to use
+  *
+  * Convert a drm_display_mode into a drm_mode_modeinfo structure to return to
+  * the user.
+  */
+ void drm_mode_convert_to_umode(struct drm_mode_modeinfo *out,
+ 			       const struct drm_display_mode *in)
+ {
+ 	WARN(in->hdisplay > USHRT_MAX || in->hsync_start > USHRT_MAX ||
+ 	     in->hsync_end > USHRT_MAX || in->htotal > USHRT_MAX ||
+ 	     in->hskew > USHRT_MAX || in->vdisplay > USHRT_MAX ||
+ 	     in->vsync_start > USHRT_MAX || in->vsync_end > USHRT_MAX ||
+ 	     in->vtotal > USHRT_MAX || in->vscan > USHRT_MAX,
+ 	     "timing values too large for mode info\n");
+ 
+ 	out->clock = in->clock;
+ 	out->hdisplay = in->hdisplay;
+ 	out->hsync_start = in->hsync_start;
+ 	out->hsync_end = in->hsync_end;
+ 	out->htotal = in->htotal;
+ 	out->hskew = in->hskew;
+ 	out->vdisplay = in->vdisplay;
+ 	out->vsync_start = in->vsync_start;
+ 	out->vsync_end = in->vsync_end;
+ 	out->vtotal = in->vtotal;
+ 	out->vscan = in->vscan;
+ 	out->vrefresh = in->vrefresh;
+ 	out->flags = in->flags;
+ 	out->type = in->type;
+ 	strncpy(out->name, in->name, DRM_DISPLAY_MODE_LEN);
+ 	out->name[DRM_DISPLAY_MODE_LEN-1] = 0;
+ }
+ 
+ /**
+  * drm_crtc_convert_umode - convert a modeinfo into a drm_display_mode
+  * @out: drm_display_mode to return to the user
+  * @in: drm_mode_modeinfo to use
+  *
+  * Convert a drm_mode_modeinfo into a drm_display_mode structure to return to
+  * the caller.
+  *
+  * Returns:
+  * Zero on success, negative errno on failure.
+  */
+ int drm_mode_convert_umode(struct drm_display_mode *out,
+ 			   const struct drm_mode_modeinfo *in)
+ {
+ 	int ret = -EINVAL;
+ 
+ 	if (in->clock > INT_MAX || in->vrefresh > INT_MAX) {
+ 		ret = -ERANGE;
+ 		goto out;
+ 	}
+ 
+ 	if ((in->flags & DRM_MODE_FLAG_3D_MASK) > DRM_MODE_FLAG_3D_MAX)
+ 		goto out;
+ 
+ 	out->clock = in->clock;
+ 	out->hdisplay = in->hdisplay;
+ 	out->hsync_start = in->hsync_start;
+ 	out->hsync_end = in->hsync_end;
+ 	out->htotal = in->htotal;
+ 	out->hskew = in->hskew;
+ 	out->vdisplay = in->vdisplay;
+ 	out->vsync_start = in->vsync_start;
+ 	out->vsync_end = in->vsync_end;
+ 	out->vtotal = in->vtotal;
+ 	out->vscan = in->vscan;
+ 	out->vrefresh = in->vrefresh;
+ 	out->flags = in->flags;
+ 	out->type = in->type;
+ 	strncpy(out->name, in->name, DRM_DISPLAY_MODE_LEN);
+ 	out->name[DRM_DISPLAY_MODE_LEN-1] = 0;
+ 
+ 	out->status = drm_mode_validate_basic(out);
+ 	if (out->status != MODE_OK)
+ 		goto out;
+ 
+ 	drm_mode_set_crtcinfo(out, CRTC_INTERLACE_HALVE_V);
+ 
+ 	ret = 0;
+ 
+ out:
+ 	return ret;
+ }
++>>>>>>> b201e743f42d (drm: add missing drm_mode_set_crtcinfo call)
* Unmerged path drivers/gpu/drm/drm_crtc.c
* Unmerged path drivers/gpu/drm/drm_modes.c
