net/mlx5_core: Fix soft lockup in steering error flow

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [netdrv] mlx5_core: Fix soft lockup in steering error flow (kamal heib) [1275159 1296272 1296405 1298421 1298422 1298423 1298424 1298425]
Rebuild_FUZZ: 96.08%
commit-author Maor Gottlieb <maorg@mellanox.com>
commit c3f9bf628bc7edda298897d952f5e761137229c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c3f9bf62.failed

In the error flow of adding flow rule to auto-grouped flow
table, we call to tree_remove_node.

tree_remove_node locks the node's parent, however the node's parent
is already locked by mlx5_add_flow_rule and this causes a deadlock.
After this patch, if we failed to add the flow rule, we unlock the
flow table before calling to tree_remove_node.

fixes: f0d22d187473 ('net/mlx5_core: Introduce flow steering autogrouped
flow table')
	Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
	Reported-by: Amir Vadai <amir@vadai.me>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c3f9bf628bc7edda298897d952f5e761137229c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index 2de4496022ff,3c7e3e581835..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@@ -965,41 -1065,14 +965,52 @@@ unlock_fg
  	return rule;
  }
  
++<<<<<<< HEAD
 +static struct mlx5_flow_rule *add_rule_to_auto_fg(struct mlx5_flow_table *ft,
 +						  u8 match_criteria_enable,
 +						  u32 *match_criteria,
 +						  u32 *match_value,
 +						  u8 action,
 +						  u32 flow_tag,
 +						  struct mlx5_flow_destination *dest)
 +{
 +	struct mlx5_flow_rule *rule;
 +	struct mlx5_flow_group *g;
 +
 +	g = create_autogroup(ft, match_criteria_enable, match_criteria);
 +	if (IS_ERR(g))
 +		return (void *)g;
 +
 +	rule = add_rule_fg(g, match_value,
 +			   action, flow_tag, dest);
 +	if (IS_ERR(rule)) {
 +		/* Remove assumes refcount > 0 and autogroup creates a group
 +		 * with a refcount = 0.
 +		 */
 +		tree_get_node(&g->node);
 +		tree_remove_node(&g->node);
 +	}
 +	return rule;
 +}
 +
 +struct mlx5_flow_rule *
 +mlx5_add_flow_rule(struct mlx5_flow_table *ft,
 +		   u8 match_criteria_enable,
 +		   u32 *match_criteria,
 +		   u32 *match_value,
 +		   u32 action,
 +		   u32 flow_tag,
 +		   struct mlx5_flow_destination *dest)
++=======
+ static struct mlx5_flow_rule *
+ _mlx5_add_flow_rule(struct mlx5_flow_table *ft,
+ 		    u8 match_criteria_enable,
+ 		    u32 *match_criteria,
+ 		    u32 *match_value,
+ 		    u32 action,
+ 		    u32 flow_tag,
+ 		    struct mlx5_flow_destination *dest)
++>>>>>>> c3f9bf628bc7 (net/mlx5_core: Fix soft lockup in steering error flow)
  {
  	struct mlx5_flow_group *g;
  	struct mlx5_flow_rule *rule;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
