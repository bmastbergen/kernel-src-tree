i40evf: Add driver support for promiscuous mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Anjali Singhai Jain <anjali.singhai@intel.com>
commit 47d3483988f649739ad8d6462eaa1723e5d077c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/47d34839.failed

Add necessary Linux Ethernet driver support for promiscuous mode
operation. Add a flag so the VF knows it is in promiscuous mode
and two state flags to discreetly track multicast and unicast
promiscuous states.

Change-Id: Ib2f2dc7a7582304fec90fc917ebb7ded21ba1de4
	Signed-off-by: Anjali Singhai Jain <anjali.singhai@intel.com>
	Signed-off-by: Greg Rose <gregory.v.rose@intel.com>
	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 47d3483988f649739ad8d6462eaa1723e5d077c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index 226c5459dd61,c226c2dad247..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -1299,10 -1478,105 +1299,109 @@@ static int i40e_vc_config_promiscuous_m
  		aq_ret = I40E_ERR_PARAM;
  		goto error_param;
  	}
 -	/* Multicast promiscuous handling*/
  	if (info->flags & I40E_FLAG_VF_MULTICAST_PROMISC)
  		allmulti = true;
++<<<<<<< HEAD
 +	aq_ret = i40e_aq_set_vsi_multicast_promiscuous(hw, vsi->seid,
 +						       allmulti, NULL);
++=======
+ 
+ 	if (vf->port_vlan_id) {
+ 		aq_ret = i40e_aq_set_vsi_mc_promisc_on_vlan(hw, vsi->seid,
+ 							    allmulti,
+ 							    vf->port_vlan_id,
+ 							    NULL);
+ 	} else if (i40e_getnum_vf_vsi_vlan_filters(vsi)) {
+ 		list_for_each_entry(f, &vsi->mac_filter_list, list) {
+ 			if (f->vlan < 0 || f->vlan > I40E_MAX_VLANID)
+ 				continue;
+ 			aq_ret = i40e_aq_set_vsi_mc_promisc_on_vlan(hw,
+ 								    vsi->seid,
+ 								    allmulti,
+ 								    f->vlan,
+ 								    NULL);
+ 			aq_err = pf->hw.aq.asq_last_status;
+ 			if (aq_ret) {
+ 				dev_err(&pf->pdev->dev,
+ 					"Could not add VLAN %d to multicast promiscuous domain err %s aq_err %s\n",
+ 					f->vlan,
+ 					i40e_stat_str(&pf->hw, aq_ret),
+ 					i40e_aq_str(&pf->hw, aq_err));
+ 				break;
+ 			}
+ 		}
+ 	} else {
+ 		aq_ret = i40e_aq_set_vsi_multicast_promiscuous(hw, vsi->seid,
+ 							       allmulti, NULL);
+ 		aq_err = pf->hw.aq.asq_last_status;
+ 		if (aq_ret) {
+ 			dev_err(&pf->pdev->dev,
+ 				"VF %d failed to set multicast promiscuous mode err %s aq_err %s\n",
+ 				vf->vf_id,
+ 				i40e_stat_str(&pf->hw, aq_ret),
+ 				i40e_aq_str(&pf->hw, aq_err));
+ 			goto error_param_int;
+ 		}
+ 	}
+ 
+ 	if (!aq_ret) {
+ 		dev_info(&pf->pdev->dev,
+ 			 "VF %d successfully set multicast promiscuous mode\n",
+ 			 vf->vf_id);
+ 		if (allmulti)
+ 			set_bit(I40E_VF_STAT_MC_PROMISC, &vf->vf_states);
+ 		else
+ 			clear_bit(I40E_VF_STAT_MC_PROMISC, &vf->vf_states);
+ 	}
+ 
+ 	if (info->flags & I40E_FLAG_VF_UNICAST_PROMISC)
+ 		alluni = true;
+ 	if (vf->port_vlan_id) {
+ 		aq_ret = i40e_aq_set_vsi_uc_promisc_on_vlan(hw, vsi->seid,
+ 							    alluni,
+ 							    vf->port_vlan_id,
+ 							    NULL);
+ 	} else if (i40e_getnum_vf_vsi_vlan_filters(vsi)) {
+ 		list_for_each_entry(f, &vsi->mac_filter_list, list) {
+ 			aq_ret = 0;
+ 			if (f->vlan >= 0 && f->vlan <= I40E_MAX_VLANID)
+ 				aq_ret =
+ 				i40e_aq_set_vsi_uc_promisc_on_vlan(hw,
+ 								   vsi->seid,
+ 								   alluni,
+ 								   f->vlan,
+ 								   NULL);
+ 				aq_err = pf->hw.aq.asq_last_status;
+ 			if (aq_ret)
+ 				dev_err(&pf->pdev->dev,
+ 					"Could not add VLAN %d to Unicast promiscuous domain err %s aq_err %s\n",
+ 					f->vlan,
+ 					i40e_stat_str(&pf->hw, aq_ret),
+ 					i40e_aq_str(&pf->hw, aq_err));
+ 		}
+ 	} else {
+ 		aq_ret = i40e_aq_set_vsi_unicast_promiscuous(hw, vsi->seid,
+ 							     allmulti, NULL);
+ 		aq_err = pf->hw.aq.asq_last_status;
+ 		if (aq_ret)
+ 			dev_err(&pf->pdev->dev,
+ 				"VF %d failed to set unicast promiscuous mode %8.8x err %s aq_err %s\n",
+ 				vf->vf_id, info->flags,
+ 				i40e_stat_str(&pf->hw, aq_ret),
+ 				i40e_aq_str(&pf->hw, aq_err));
+ 	}
+ 
+ error_param_int:
+ 	if (!aq_ret) {
+ 		dev_info(&pf->pdev->dev,
+ 			 "VF %d successfully set unicast promiscuous mode\n",
+ 			 vf->vf_id);
+ 		if (alluni)
+ 			set_bit(I40E_VF_STAT_UC_PROMISC, &vf->vf_states);
+ 		else
+ 			clear_bit(I40E_VF_STAT_UC_PROMISC, &vf->vf_states);
+ 	}
++>>>>>>> 47d3483988f6 (i40evf: Add driver support for promiscuous mode)
  
  error_param:
  	/* send the response to the VF */
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf.h b/drivers/net/ethernet/intel/i40evf/i40evf.h
index 63f7aae2c8ce..25afabf999d0 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf.h
+++ b/drivers/net/ethernet/intel/i40evf/i40evf.h
@@ -220,6 +220,7 @@ struct i40evf_adapter {
 #define I40EVF_FLAG_WB_ON_ITR_CAPABLE		BIT(11)
 #define I40EVF_FLAG_OUTER_UDP_CSUM_CAPABLE	BIT(12)
 #define I40EVF_FLAG_ADDR_SET_BY_PF		BIT(13)
+#define I40EVF_FLAG_PROMISC_ON			BIT(15)
 /* duplicates for common code */
 #define I40E_FLAG_FDIR_ATR_ENABLED		 0
 #define I40E_FLAG_DCB_ENABLED			 0
@@ -244,6 +245,8 @@ struct i40evf_adapter {
 #define I40EVF_FLAG_AQ_SET_HENA			BIT(12)
 #define I40EVF_FLAG_AQ_SET_RSS_KEY		BIT(13)
 #define I40EVF_FLAG_AQ_SET_RSS_LUT		BIT(14)
+#define I40EVF_FLAG_AQ_REQUEST_PROMISC		BIT(15)
+#define I40EVF_FLAG_AQ_RELEASE_PROMISC		BIT(16)
 
 	/* OS defined structs */
 	struct net_device *netdev;
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf_main.c b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
index 6d080064b9bf..d2bed3d68ba1 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf_main.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
@@ -935,6 +935,14 @@ static void i40evf_set_rx_mode(struct net_device *netdev)
 bottom_of_search_loop:
 		continue;
 	}
+
+	if (netdev->flags & IFF_PROMISC &&
+	    !(adapter->flags & I40EVF_FLAG_PROMISC_ON))
+		adapter->aq_required |= I40EVF_FLAG_AQ_REQUEST_PROMISC;
+	else if (!(netdev->flags & IFF_PROMISC) &&
+		 adapter->flags & I40EVF_FLAG_PROMISC_ON)
+		adapter->aq_required |= I40EVF_FLAG_AQ_RELEASE_PROMISC;
+
 	clear_bit(__I40EVF_IN_CRITICAL_TASK, &adapter->crit_section);
 }
 
@@ -1614,6 +1622,17 @@ static void i40evf_watchdog_task(struct work_struct *work)
 		goto watchdog_done;
 	}
 
+	if (adapter->aq_required & I40EVF_FLAG_AQ_REQUEST_PROMISC) {
+		i40evf_set_promiscuous(adapter, I40E_FLAG_VF_UNICAST_PROMISC |
+				       I40E_FLAG_VF_MULTICAST_PROMISC);
+		goto watchdog_done;
+	}
+
+	if (adapter->aq_required & I40EVF_FLAG_AQ_RELEASE_PROMISC) {
+		i40evf_set_promiscuous(adapter, 0);
+		goto watchdog_done;
+	}
+
 	if (adapter->state == __I40EVF_RUNNING)
 		i40evf_request_stats(adapter);
 watchdog_done:
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c b/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
index e62c56b5a141..ba7fbc0608a6 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
@@ -652,6 +652,17 @@ void i40evf_set_promiscuous(struct i40evf_adapter *adapter, int flags)
 			adapter->current_op);
 		return;
 	}
+
+	if (flags) {
+		adapter->flags |= I40EVF_FLAG_PROMISC_ON;
+		adapter->aq_required &= ~I40EVF_FLAG_AQ_REQUEST_PROMISC;
+		dev_info(&adapter->pdev->dev, "Entering promiscuous mode\n");
+	} else {
+		adapter->flags &= ~I40EVF_FLAG_PROMISC_ON;
+		adapter->aq_required &= ~I40EVF_FLAG_AQ_RELEASE_PROMISC;
+		dev_info(&adapter->pdev->dev, "Leaving promiscuous mode\n");
+	}
+
 	adapter->current_op = I40E_VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE;
 	vpi.vsi_id = adapter->vsi_res->vsi_id;
 	vpi.flags = flags;
