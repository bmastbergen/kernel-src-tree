cxgb4: Update mps_tcam output to include T6 fields

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit 115b56af88b538147cf241d0f75a370a73009ed9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/115b56af.failed

In T6, MPS classification has a 512 deep TCAM to do the match lookup.
Each entry has 80x2b sets containing 48 bit MAC address, port number,
VLAN Valid/ID, VNI, lookup type (outer or inner packet header).
[71:48] bit locations are overloaded for outer vs. inner lookup types.

	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 115b56af88b538147cf241d0f75a370a73009ed9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
#	drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
index ebdc323e11e2,1bab34f923e7..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
@@@ -1264,20 -1583,91 +1264,108 @@@ static inline void tcamxy2valmask(u64 x
  
  static int mps_tcam_show(struct seq_file *seq, void *v)
  {
++<<<<<<< HEAD
 +	if (v == SEQ_START_TOKEN)
 +		seq_puts(seq, "Idx  Ethernet address     Mask     Vld Ports PF"
 +			 "  VF              Replication             "
 +			 "P0 P1 P2 P3  ML\n");
 +	else {
 +		u64 mask;
 +		u8 addr[ETH_ALEN];
 +		struct adapter *adap = seq->private;
 +		unsigned int idx = (uintptr_t)v - 2;
 +		u64 tcamy = t4_read_reg64(adap, MPS_CLS_TCAM_Y_L(idx));
 +		u64 tcamx = t4_read_reg64(adap, MPS_CLS_TCAM_X_L(idx));
 +		u32 cls_lo = t4_read_reg(adap, MPS_CLS_SRAM_L(idx));
 +		u32 cls_hi = t4_read_reg(adap, MPS_CLS_SRAM_H(idx));
 +		u32 rplc[4] = {0, 0, 0, 0};
++=======
+ 	struct adapter *adap = seq->private;
+ 	unsigned int chip_ver = CHELSIO_CHIP_VERSION(adap->params.chip);
+ 	if (v == SEQ_START_TOKEN) {
+ 		if (chip_ver > CHELSIO_T5) {
+ 			seq_puts(seq, "Idx  Ethernet address     Mask     "
+ 				 "  VNI   Mask   IVLAN Vld "
+ 				 "DIP_Hit   Lookup  Port "
+ 				 "Vld Ports PF  VF                           "
+ 				 "Replication                                "
+ 				 "    P0 P1 P2 P3  ML\n");
+ 		} else {
+ 			if (adap->params.arch.mps_rplc_size > 128)
+ 				seq_puts(seq, "Idx  Ethernet address     Mask     "
+ 					 "Vld Ports PF  VF                           "
+ 					 "Replication                                "
+ 					 "    P0 P1 P2 P3  ML\n");
+ 			else
+ 				seq_puts(seq, "Idx  Ethernet address     Mask     "
+ 					 "Vld Ports PF  VF              Replication"
+ 					 "	         P0 P1 P2 P3  ML\n");
+ 		}
+ 	} else {
+ 		u64 mask;
+ 		u8 addr[ETH_ALEN];
+ 		bool replicate, dip_hit = false, vlan_vld = false;
+ 		unsigned int idx = (uintptr_t)v - 2;
+ 		u64 tcamy, tcamx, val;
+ 		u32 cls_lo, cls_hi, ctl, data2, vnix = 0, vniy = 0;
+ 		u32 rplc[8] = {0};
+ 		u8 lookup_type = 0, port_num = 0;
+ 		u16 ivlan = 0;
+ 
+ 		if (chip_ver > CHELSIO_T5) {
+ 			/* CtlCmdType - 0: Read, 1: Write
+ 			 * CtlTcamSel - 0: TCAM0, 1: TCAM1
+ 			 * CtlXYBitSel- 0: Y bit, 1: X bit
+ 			 */
+ 
+ 			/* Read tcamy */
+ 			ctl = CTLCMDTYPE_V(0) | CTLXYBITSEL_V(0);
+ 			if (idx < 256)
+ 				ctl |= CTLTCAMINDEX_V(idx) | CTLTCAMSEL_V(0);
+ 			else
+ 				ctl |= CTLTCAMINDEX_V(idx - 256) |
+ 				       CTLTCAMSEL_V(1);
+ 			t4_write_reg(adap, MPS_CLS_TCAM_DATA2_CTL_A, ctl);
+ 			val = t4_read_reg(adap, MPS_CLS_TCAM_DATA1_A);
+ 			tcamy = DMACH_G(val) << 32;
+ 			tcamy |= t4_read_reg(adap, MPS_CLS_TCAM_DATA0_A);
+ 			data2 = t4_read_reg(adap, MPS_CLS_TCAM_DATA2_CTL_A);
+ 			lookup_type = DATALKPTYPE_G(data2);
+ 			/* 0 - Outer header, 1 - Inner header
+ 			 * [71:48] bit locations are overloaded for
+ 			 * outer vs. inner lookup types.
+ 			 */
+ 			if (lookup_type && (lookup_type != DATALKPTYPE_M)) {
+ 				/* Inner header VNI */
+ 				vniy = ((data2 & DATAVIDH2_F) << 23) |
+ 				       (DATAVIDH1_G(data2) << 16) | VIDL_G(val);
+ 				dip_hit = data2 & DATADIPHIT_F;
+ 			} else {
+ 				vlan_vld = data2 & DATAVIDH2_F;
+ 				ivlan = VIDL_G(val);
+ 			}
+ 			port_num = DATAPORTNUM_G(data2);
+ 
+ 			/* Read tcamx. Change the control param */
+ 			ctl |= CTLXYBITSEL_V(1);
+ 			t4_write_reg(adap, MPS_CLS_TCAM_DATA2_CTL_A, ctl);
+ 			val = t4_read_reg(adap, MPS_CLS_TCAM_DATA1_A);
+ 			tcamx = DMACH_G(val) << 32;
+ 			tcamx |= t4_read_reg(adap, MPS_CLS_TCAM_DATA0_A);
+ 			data2 = t4_read_reg(adap, MPS_CLS_TCAM_DATA2_CTL_A);
+ 			if (lookup_type && (lookup_type != DATALKPTYPE_M)) {
+ 				/* Inner header VNI mask */
+ 				vnix = ((data2 & DATAVIDH2_F) << 23) |
+ 				       (DATAVIDH1_G(data2) << 16) | VIDL_G(val);
+ 			}
+ 		} else {
+ 			tcamy = t4_read_reg64(adap, MPS_CLS_TCAM_Y_L(idx));
+ 			tcamx = t4_read_reg64(adap, MPS_CLS_TCAM_X_L(idx));
+ 		}
+ 
+ 		cls_lo = t4_read_reg(adap, MPS_CLS_SRAM_L(idx));
+ 		cls_hi = t4_read_reg(adap, MPS_CLS_SRAM_H(idx));
++>>>>>>> 115b56af88b5 (cxgb4: Update mps_tcam output to include T6 fields)
  
  		if (tcamx & tcamy) {
  			seq_printf(seq, "%3u         -\n", idx);
@@@ -1314,22 -1720,84 +1402,103 @@@
  		}
  
  		tcamxy2valmask(tcamx, tcamy, addr, &mask);
++<<<<<<< HEAD
 +		seq_printf(seq, "%3u %02x:%02x:%02x:%02x:%02x:%02x %012llx"
 +			   "%3c   %#x%4u%4d",
 +			   idx, addr[0], addr[1], addr[2], addr[3], addr[4],
 +			   addr[5], (unsigned long long)mask,
 +			   (cls_lo & SRAM_VLD_F) ? 'Y' : 'N', PORTMAP_G(cls_hi),
 +			   PF_G(cls_lo),
 +			   (cls_lo & VF_VALID_F) ? VF_G(cls_lo) : -1);
 +		if (cls_lo & REPLICATE_F)
 +			seq_printf(seq, " %08x %08x %08x %08x",
 +				   rplc[3], rplc[2], rplc[1], rplc[0]);
 +		else
 +			seq_printf(seq, "%36c", ' ');
 +		seq_printf(seq, "%4u%3u%3u%3u %#x\n",
 +			   SRAM_PRIO0_G(cls_lo), SRAM_PRIO1_G(cls_lo),
 +			   SRAM_PRIO2_G(cls_lo), SRAM_PRIO3_G(cls_lo),
 +			   (cls_lo >> MULTILISTEN0_S) & 0xf);
++=======
+ 		if (chip_ver > CHELSIO_T5) {
+ 			/* Inner header lookup */
+ 			if (lookup_type && (lookup_type != DATALKPTYPE_M)) {
+ 				seq_printf(seq,
+ 					   "%3u %02x:%02x:%02x:%02x:%02x:%02x "
+ 					   "%012llx %06x %06x    -    -   %3c"
+ 					   "      %3c  %4x   "
+ 					   "%3c   %#x%4u%4d", idx, addr[0],
+ 					   addr[1], addr[2], addr[3],
+ 					   addr[4], addr[5],
+ 					   (unsigned long long)mask,
+ 					   vniy, vnix, dip_hit ? 'Y' : 'N',
+ 					   lookup_type ? 'I' : 'O', port_num,
+ 					   (cls_lo & T6_SRAM_VLD_F) ? 'Y' : 'N',
+ 					   PORTMAP_G(cls_hi),
+ 					   T6_PF_G(cls_lo),
+ 					   (cls_lo & T6_VF_VALID_F) ?
+ 					   T6_VF_G(cls_lo) : -1);
+ 			} else {
+ 				seq_printf(seq,
+ 					   "%3u %02x:%02x:%02x:%02x:%02x:%02x "
+ 					   "%012llx    -       -   ",
+ 					   idx, addr[0], addr[1], addr[2],
+ 					   addr[3], addr[4], addr[5],
+ 					   (unsigned long long)mask);
+ 
+ 				if (vlan_vld)
+ 					seq_printf(seq, "%4u   Y     ", ivlan);
+ 				else
+ 					seq_puts(seq, "  -    N     ");
+ 
+ 				seq_printf(seq,
+ 					   "-      %3c  %4x   %3c   %#x%4u%4d",
+ 					   lookup_type ? 'I' : 'O', port_num,
+ 					   (cls_lo & T6_SRAM_VLD_F) ? 'Y' : 'N',
+ 					   PORTMAP_G(cls_hi),
+ 					   T6_PF_G(cls_lo),
+ 					   (cls_lo & T6_VF_VALID_F) ?
+ 					   T6_VF_G(cls_lo) : -1);
+ 			}
+ 		} else
+ 			seq_printf(seq, "%3u %02x:%02x:%02x:%02x:%02x:%02x "
+ 				   "%012llx%3c   %#x%4u%4d",
+ 				   idx, addr[0], addr[1], addr[2], addr[3],
+ 				   addr[4], addr[5], (unsigned long long)mask,
+ 				   (cls_lo & SRAM_VLD_F) ? 'Y' : 'N',
+ 				   PORTMAP_G(cls_hi),
+ 				   PF_G(cls_lo),
+ 				   (cls_lo & VF_VALID_F) ? VF_G(cls_lo) : -1);
+ 
+ 		if (replicate) {
+ 			if (adap->params.arch.mps_rplc_size > 128)
+ 				seq_printf(seq, " %08x %08x %08x %08x "
+ 					   "%08x %08x %08x %08x",
+ 					   rplc[7], rplc[6], rplc[5], rplc[4],
+ 					   rplc[3], rplc[2], rplc[1], rplc[0]);
+ 			else
+ 				seq_printf(seq, " %08x %08x %08x %08x",
+ 					   rplc[3], rplc[2], rplc[1], rplc[0]);
+ 		} else {
+ 			if (adap->params.arch.mps_rplc_size > 128)
+ 				seq_printf(seq, "%72c", ' ');
+ 			else
+ 				seq_printf(seq, "%36c", ' ');
+ 		}
+ 
+ 		if (chip_ver > CHELSIO_T5)
+ 			seq_printf(seq, "%4u%3u%3u%3u %#x\n",
+ 				   T6_SRAM_PRIO0_G(cls_lo),
+ 				   T6_SRAM_PRIO1_G(cls_lo),
+ 				   T6_SRAM_PRIO2_G(cls_lo),
+ 				   T6_SRAM_PRIO3_G(cls_lo),
+ 				   (cls_lo >> T6_MULTILISTEN0_S) & 0xf);
+ 		else
+ 			seq_printf(seq, "%4u%3u%3u%3u %#x\n",
+ 				   SRAM_PRIO0_G(cls_lo), SRAM_PRIO1_G(cls_lo),
+ 				   SRAM_PRIO2_G(cls_lo), SRAM_PRIO3_G(cls_lo),
+ 				   (cls_lo >> MULTILISTEN0_S) & 0xf);
++>>>>>>> 115b56af88b5 (cxgb4: Update mps_tcam output to include T6 fields)
  	}
  out:	return 0;
  }
diff --cc drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
index 3b4d3351bed7,9fea255c7e87..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
@@@ -2232,10 -2388,75 +2232,60 @@@
  #define MATCHSRAM_V(x) ((x) << MATCHSRAM_S)
  #define MATCHSRAM_F    MATCHSRAM_V(1U)
  
 -#define MPS_RX_PG_RSV0_A 0x11010
 -#define MPS_RX_PG_RSV4_A 0x11020
  #define MPS_RX_PERR_INT_CAUSE_A 0x11074
 -#define MPS_RX_MAC_BG_PG_CNT0_A 0x11208
 -#define MPS_RX_LPBK_BG_PG_CNT0_A 0x11218
  
  #define MPS_CLS_TCAM_Y_L_A 0xf000
++<<<<<<< HEAD
++=======
+ #define MPS_CLS_TCAM_DATA0_A 0xf000
+ #define MPS_CLS_TCAM_DATA1_A 0xf004
+ 
+ #define VIDL_S    16
+ #define VIDL_M    0xffffU
+ #define VIDL_G(x) (((x) >> VIDL_S) & VIDL_M)
+ 
+ #define DATALKPTYPE_S    10
+ #define DATALKPTYPE_M    0x3U
+ #define DATALKPTYPE_G(x) (((x) >> DATALKPTYPE_S) & DATALKPTYPE_M)
+ 
+ #define DATAPORTNUM_S    12
+ #define DATAPORTNUM_M    0xfU
+ #define DATAPORTNUM_G(x) (((x) >> DATAPORTNUM_S) & DATAPORTNUM_M)
+ 
+ #define DATADIPHIT_S    8
+ #define DATADIPHIT_V(x) ((x) << DATADIPHIT_S)
+ #define DATADIPHIT_F    DATADIPHIT_V(1U)
+ 
+ #define DATAVIDH2_S    7
+ #define DATAVIDH2_V(x) ((x) << DATAVIDH2_S)
+ #define DATAVIDH2_F    DATAVIDH2_V(1U)
+ 
+ #define DATAVIDH1_S    0
+ #define DATAVIDH1_M    0x7fU
+ #define DATAVIDH1_G(x) (((x) >> DATAVIDH1_S) & DATAVIDH1_M)
+ 
+ #define USED_S    16
+ #define USED_M    0x7ffU
+ #define USED_G(x) (((x) >> USED_S) & USED_M)
+ 
+ #define ALLOC_S    0
+ #define ALLOC_M    0x7ffU
+ #define ALLOC_G(x) (((x) >> ALLOC_S) & ALLOC_M)
+ 
+ #define T5_USED_S    16
+ #define T5_USED_M    0xfffU
+ #define T5_USED_G(x) (((x) >> T5_USED_S) & T5_USED_M)
+ 
+ #define T5_ALLOC_S    0
+ #define T5_ALLOC_M    0xfffU
+ #define T5_ALLOC_G(x) (((x) >> T5_ALLOC_S) & T5_ALLOC_M)
+ 
+ #define DMACH_S    0
+ #define DMACH_M    0xffffU
+ #define DMACH_G(x) (((x) >> DMACH_S) & DMACH_M)
+ 
++>>>>>>> 115b56af88b5 (cxgb4: Update mps_tcam output to include T6 fields)
  #define MPS_CLS_TCAM_X_L_A 0xf008
 -#define MPS_CLS_TCAM_DATA2_CTL_A 0xf008
 -
 -#define CTLCMDTYPE_S    31
 -#define CTLCMDTYPE_V(x) ((x) << CTLCMDTYPE_S)
 -#define CTLCMDTYPE_F    CTLCMDTYPE_V(1U)
 -
 -#define CTLTCAMSEL_S    25
 -#define CTLTCAMSEL_V(x) ((x) << CTLTCAMSEL_S)
 -
 -#define CTLTCAMINDEX_S    17
 -#define CTLTCAMINDEX_V(x) ((x) << CTLTCAMINDEX_S)
 -
 -#define CTLXYBITSEL_S    16
 -#define CTLXYBITSEL_V(x) ((x) << CTLXYBITSEL_S)
  
  #define MPS_CLS_TCAM_Y_L(idx) (MPS_CLS_TCAM_Y_L_A + (idx) * 16)
  #define NUM_MPS_CLS_TCAM_Y_L_INSTANCES 512
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
