mmc: mmc: Add driver strength selection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit cc4f414c885cd04f7227ad9bcd6b18fd78d718d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/cc4f414c.failed

Add the ability to set eMMC driver strength
for HS200 and HS400.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit cc4f414c885cd04f7227ad9bcd6b18fd78d718d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/mmc.c
#	include/linux/mmc/mmc.h
diff --cc drivers/mmc/core/mmc.c
index 33983b7d000a,e519e3110a20..000000000000
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@@ -900,23 -927,364 +900,334 @@@ static int mmc_select_hs200(struct mmc_
  		if (err)
  			continue;
  
 -		bus_width = bus_widths[idx];
 -		mmc_set_bus_width(host, bus_width);
 +		mmc_set_bus_width(card->host, bus_widths[idx]);
  
 -		/*
 -		 * If controller can't handle bus width test,
 -		 * compare ext_csd previously read in 1 bit mode
 -		 * against ext_csd at new bus width
 -		 */
  		if (!(host->caps & MMC_CAP_BUS_WIDTH_TEST))
 -			err = mmc_compare_ext_csds(card, bus_width);
 +			err = mmc_compare_ext_csds(card, bus_widths[idx]);
  		else
++<<<<<<< HEAD
 +			err = mmc_bus_test(card, bus_widths[idx]);
++=======
+ 			err = mmc_bus_test(card, bus_width);
+ 
+ 		if (!err) {
+ 			err = bus_width;
+ 			break;
+ 		} else {
+ 			pr_warn("%s: switch to bus width %d failed\n",
+ 				mmc_hostname(host), ext_csd_bits[idx]);
+ 		}
+ 	}
+ 
+ 	return err;
+ }
+ 
+ /*
+  * Switch to the high-speed mode
+  */
+ static int mmc_select_hs(struct mmc_card *card)
+ {
+ 	int err;
+ 
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS,
+ 			   card->ext_csd.generic_cmd6_time,
+ 			   true, true, true);
+ 	if (!err)
+ 		mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
+ 
+ 	return err;
+ }
+ 
+ /*
+  * Activate wide bus and DDR if supported.
+  */
+ static int mmc_select_hs_ddr(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	u32 bus_width, ext_csd_bits;
+ 	int err = 0;
+ 
+ 	if (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_52))
+ 		return 0;
+ 
+ 	bus_width = host->ios.bus_width;
+ 	if (bus_width == MMC_BUS_WIDTH_1)
+ 		return 0;
+ 
+ 	ext_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?
+ 		EXT_CSD_DDR_BUS_WIDTH_8 : EXT_CSD_DDR_BUS_WIDTH_4;
+ 
+ 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			EXT_CSD_BUS_WIDTH,
+ 			ext_csd_bits,
+ 			card->ext_csd.generic_cmd6_time);
+ 	if (err) {
+ 		pr_err("%s: switch to bus width %d ddr failed\n",
+ 			mmc_hostname(host), 1 << bus_width);
+ 		return err;
+ 	}
+ 
+ 	/*
+ 	 * eMMC cards can support 3.3V to 1.2V i/o (vccq)
+ 	 * signaling.
+ 	 *
+ 	 * EXT_CSD_CARD_TYPE_DDR_1_8V means 3.3V or 1.8V vccq.
+ 	 *
+ 	 * 1.8V vccq at 3.3V core voltage (vcc) is not required
+ 	 * in the JEDEC spec for DDR.
+ 	 *
+ 	 * Even (e)MMC card can support 3.3v to 1.2v vccq, but not all
+ 	 * host controller can support this, like some of the SDHCI
+ 	 * controller which connect to an eMMC device. Some of these
+ 	 * host controller still needs to use 1.8v vccq for supporting
+ 	 * DDR mode.
+ 	 *
+ 	 * So the sequence will be:
+ 	 * if (host and device can both support 1.2v IO)
+ 	 *	use 1.2v IO;
+ 	 * else if (host and device can both support 1.8v IO)
+ 	 *	use 1.8v IO;
+ 	 * so if host and device can only support 3.3v IO, this is the
+ 	 * last choice.
+ 	 *
+ 	 * WARNING: eMMC rules are NOT the same as SD DDR
+ 	 */
+ 	err = -EINVAL;
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_1_2V)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);
+ 
+ 	if (err && (card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_1_8V))
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
+ 
+ 	/* make sure vccq is 3.3v after switching disaster */
+ 	if (err)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330);
+ 
+ 	if (!err)
+ 		mmc_set_timing(host, MMC_TIMING_MMC_DDR52);
+ 
+ 	return err;
+ }
+ 
+ static int mmc_select_hs400(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	int err = 0;
+ 	u8 val;
+ 
+ 	/*
+ 	 * HS400 mode requires 8-bit bus width
+ 	 */
+ 	if (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400 &&
+ 	      host->ios.bus_width == MMC_BUS_WIDTH_8))
+ 		return 0;
+ 
+ 	/*
+ 	 * Before switching to dual data rate operation for HS400,
+ 	 * it is required to convert from HS200 mode to HS mode.
+ 	 */
+ 	mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
+ 	mmc_set_bus_speed(card);
+ 
+ 	val = EXT_CSD_TIMING_HS |
+ 	      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			   EXT_CSD_HS_TIMING, val,
+ 			   card->ext_csd.generic_cmd6_time,
+ 			   true, true, true);
+ 	if (err) {
+ 		pr_err("%s: switch to high-speed from hs200 failed, err:%d\n",
+ 			mmc_hostname(host), err);
+ 		return err;
+ 	}
+ 
+ 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			 EXT_CSD_BUS_WIDTH,
+ 			 EXT_CSD_DDR_BUS_WIDTH_8,
+ 			 card->ext_csd.generic_cmd6_time);
+ 	if (err) {
+ 		pr_err("%s: switch to bus width for hs400 failed, err:%d\n",
+ 			mmc_hostname(host), err);
+ 		return err;
+ 	}
+ 
+ 	val = EXT_CSD_TIMING_HS400 |
+ 	      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 			   EXT_CSD_HS_TIMING, val,
+ 			   card->ext_csd.generic_cmd6_time,
+ 			   true, true, true);
+ 	if (err) {
+ 		pr_err("%s: switch to hs400 failed, err:%d\n",
+ 			 mmc_hostname(host), err);
+ 		return err;
+ 	}
+ 
+ 	mmc_set_timing(host, MMC_TIMING_MMC_HS400);
+ 	mmc_set_bus_speed(card);
+ 
+ 	return 0;
+ }
+ 
+ int mmc_hs200_to_hs400(struct mmc_card *card)
+ {
+ 	return mmc_select_hs400(card);
+ }
+ 
+ /* Caller must hold re-tuning */
+ static int mmc_switch_status(struct mmc_card *card)
+ {
+ 	u32 status;
+ 	int err;
+ 
+ 	err = mmc_send_status(card, &status);
+ 	if (err)
+ 		return err;
+ 
+ 	return mmc_switch_status_error(card->host, status);
+ }
+ 
+ int mmc_hs400_to_hs200(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	bool send_status = true;
+ 	unsigned int max_dtr;
+ 	int err;
+ 	u8 val;
+ 
+ 	if (host->caps & MMC_CAP_WAIT_WHILE_BUSY)
+ 		send_status = false;
+ 
+ 	/* Reduce frequency to HS */
+ 	max_dtr = card->ext_csd.hs_max_dtr;
+ 	mmc_set_clock(host, max_dtr);
+ 
+ 	/* Switch HS400 to HS DDR */
+ 	val = EXT_CSD_TIMING_HS |
+ 	      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING,
+ 			   val, card->ext_csd.generic_cmd6_time,
+ 			   true, send_status, true);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	mmc_set_timing(host, MMC_TIMING_MMC_DDR52);
+ 
+ 	if (!send_status) {
+ 		err = mmc_switch_status(card);
+ 		if (err)
+ 			goto out_err;
+ 	}
+ 
+ 	/* Switch HS DDR to HS */
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_BUS_WIDTH,
+ 			   EXT_CSD_BUS_WIDTH_8, card->ext_csd.generic_cmd6_time,
+ 			   true, send_status, true);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	mmc_set_timing(host, MMC_TIMING_MMC_HS);
+ 
+ 	if (!send_status) {
+ 		err = mmc_switch_status(card);
+ 		if (err)
+ 			goto out_err;
+ 	}
+ 
+ 	/* Switch HS to HS200 */
+ 	val = EXT_CSD_TIMING_HS200 |
+ 	      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;
+ 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING,
+ 			   val, card->ext_csd.generic_cmd6_time, true,
+ 			   send_status, true);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	mmc_set_timing(host, MMC_TIMING_MMC_HS200);
+ 
+ 	if (!send_status) {
+ 		err = mmc_switch_status(card);
+ 		if (err)
+ 			goto out_err;
+ 	}
+ 
+ 	mmc_set_bus_speed(card);
+ 
+ 	return 0;
+ 
+ out_err:
+ 	pr_err("%s: %s failed, error %d\n", mmc_hostname(card->host),
+ 	       __func__, err);
+ 	return err;
+ }
+ 
+ static void mmc_select_driver_type(struct mmc_card *card)
+ {
+ 	int card_drv_type, drive_strength, drv_type;
+ 
+ 	card_drv_type = card->ext_csd.raw_driver_strength |
+ 			mmc_driver_type_mask(0);
+ 
+ 	drive_strength = mmc_select_drive_strength(card,
+ 						   card->ext_csd.hs200_max_dtr,
+ 						   card_drv_type, &drv_type);
+ 
+ 	card->drive_strength = drive_strength;
+ 
+ 	if (drv_type)
+ 		mmc_set_driver_type(card->host, drv_type);
+ }
+ 
+ /*
+  * For device supporting HS200 mode, the following sequence
+  * should be done before executing the tuning process.
+  * 1. set the desired bus width(4-bit or 8-bit, 1-bit is not supported)
+  * 2. switch to HS200 mode
+  * 3. set the clock to > 52Mhz and <=200MHz
+  */
+ static int mmc_select_hs200(struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	int err = -EINVAL;
+ 	u8 val;
+ 
+ 	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_2V)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);
+ 
+ 	if (err && card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_8V)
+ 		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
+ 
+ 	/* If fails try again during next card power cycle */
+ 	if (err)
+ 		goto err;
+ 
+ 	mmc_select_driver_type(card);
+ 
+ 	/*
+ 	 * Set the bus width(4 or 8) with host's support and
+ 	 * switch to HS200 mode if bus width is set successfully.
+ 	 */
+ 	err = mmc_select_bus_width(card);
+ 	if (!IS_ERR_VALUE(err)) {
+ 		val = EXT_CSD_TIMING_HS200 |
+ 		      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;
+ 		err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+ 				   EXT_CSD_HS_TIMING, val,
+ 				   card->ext_csd.generic_cmd6_time,
+ 				   true, true, true);
++>>>>>>> cc4f414c885c (mmc: mmc: Add driver strength selection)
  		if (!err)
 -			mmc_set_timing(host, MMC_TIMING_MMC_HS200);
 -	}
 -err:
 -	return err;
 -}
 -
 -/*
 - * Activate High Speed or HS200 mode if supported.
 - */
 -static int mmc_select_timing(struct mmc_card *card)
 -{
 -	int err = 0;
 -
 -	if (!mmc_can_ext_csd(card))
 -		goto bus_speed;
 -
 -	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200)
 -		err = mmc_select_hs200(card);
 -	else if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS)
 -		err = mmc_select_hs(card);
 -
 -	if (err && err != -EBADMSG)
 -		return err;
 -
 -	if (err) {
 -		pr_warn("%s: switch to %s failed\n",
 -			mmc_card_hs(card) ? "high-speed" :
 -			(mmc_card_hs200(card) ? "hs200" : ""),
 -			mmc_hostname(card->host));
 -		err = 0;
 +			break;
  	}
  
 -bus_speed:
 -	/*
 -	 * Set the bus speed to the selected bus timing.
 -	 * If timing is not selected, backward compatible is the default.
 -	 */
 -	mmc_set_bus_speed(card);
 +	/* switch to HS200 mode if bus width set successfully */
 +	if (!err)
 +		err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 +				EXT_CSD_HS_TIMING, 2,
 +				card->ext_csd.generic_cmd6_time,
 +				true, true, true);
 +err:
  	return err;
  }
  
diff --cc include/linux/mmc/mmc.h
index 009f67b3c5d0,15f2c4a0a62c..000000000000
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@@ -376,6 -387,12 +376,15 @@@ struct _mmc_csd 
  #define EXT_CSD_DDR_BUS_WIDTH_4	5	/* Card is in 4 bit DDR mode */
  #define EXT_CSD_DDR_BUS_WIDTH_8	6	/* Card is in 8 bit DDR mode */
  
++<<<<<<< HEAD
++=======
+ #define EXT_CSD_TIMING_BC	0	/* Backwards compatility */
+ #define EXT_CSD_TIMING_HS	1	/* High speed */
+ #define EXT_CSD_TIMING_HS200	2	/* HS200 */
+ #define EXT_CSD_TIMING_HS400	3	/* HS400 */
+ #define EXT_CSD_DRV_STR_SHIFT	4	/* Driver Strength shift */
+ 
++>>>>>>> cc4f414c885c (mmc: mmc: Add driver strength selection)
  #define EXT_CSD_SEC_ER_EN	BIT(0)
  #define EXT_CSD_SEC_BD_BLK_EN	BIT(2)
  #define EXT_CSD_SEC_GB_CL_EN	BIT(4)
* Unmerged path drivers/mmc/core/mmc.c
* Unmerged path include/linux/mmc/mmc.h
