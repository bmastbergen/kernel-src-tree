nvme: use vendor it from identify

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 01fec28a6f3ba96d4f46a538eae089dd92189fd1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/01fec28a.failed

Use the vendor ID from the identify data instead of the PCI device to
make the SCSI translation layer independent from the PCI driver.  The NVMe
spec defines them as having the same value for current PCIe devices.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 01fec28a6f3ba96d4f46a538eae089dd92189fd1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-scsi.c
diff --cc drivers/block/nvme-scsi.c
index daa0d50b3bfd,0bf90b62ec27..000000000000
--- a/drivers/block/nvme-scsi.c
+++ b/drivers/block/nvme-scsi.c
@@@ -612,81 -600,102 +612,103 @@@ static int nvme_trans_unit_serial_page(
  	return nvme_trans_copy_to_user(hdr, inq_response, xfer_len);
  }
  
 -static int nvme_fill_device_id_eui64(struct nvme_ns *ns, struct sg_io_hdr *hdr,
 -		u8 *inq_response, int alloc_len)
 -{
 -	struct nvme_id_ns *id_ns;
 -	int nvme_sc, res;
 -	size_t len;
 -	void *eui;
 -
 -	nvme_sc = nvme_identify_ns(ns->dev, ns->ns_id, &id_ns);
 -	res = nvme_trans_status_code(hdr, nvme_sc);
 -	if (res)
 -		return res;
 -
 -	eui = id_ns->eui64;
 -	len = sizeof(id_ns->eui64);
 -
 -	if (readl(ns->dev->bar + NVME_REG_VS) >= NVME_VS(1, 2)) {
 -		if (bitmap_empty(eui, len * 8)) {
 -			eui = id_ns->nguid;
 -			len = sizeof(id_ns->nguid);
 -		}
 -	}
 -
 -	if (bitmap_empty(eui, len * 8)) {
 -		res = -EOPNOTSUPP;
 -		goto out_free_id;
 -	}
 -
 -	memset(inq_response, 0, alloc_len);
 -	inq_response[1] = INQ_DEVICE_IDENTIFICATION_PAGE;
 -	inq_response[3] = 4 + len; /* Page Length */
 -
 -	/* Designation Descriptor start */
 -	inq_response[4] = 0x01;	/* Proto ID=0h | Code set=1h */
 -	inq_response[5] = 0x02;	/* PIV=0b | Asso=00b | Designator Type=2h */
 -	inq_response[6] = 0x00;	/* Rsvd */
 -	inq_response[7] = len;	/* Designator Length */
 -	memcpy(&inq_response[8], eui, len);
 -
 -	res = nvme_trans_copy_to_user(hdr, inq_response, alloc_len);
 -out_free_id:
 -	kfree(id_ns);
 -	return res;
 -}
 -
 -static int nvme_fill_device_id_scsi_string(struct nvme_ns *ns,
 -		struct sg_io_hdr *hdr, u8 *inq_response, int alloc_len)
 +static int nvme_trans_device_id_page(struct nvme_ns *ns, struct sg_io_hdr *hdr,
 +					u8 *inq_response, int alloc_len)
  {
  	struct nvme_dev *dev = ns->dev;
++<<<<<<< HEAD:drivers/block/nvme-scsi.c
 +	dma_addr_t dma_addr;
 +	void *mem;
 +	int res;
 +	int nvme_sc;
 +	int xfer_len;
 +	__be32 tmp_id = cpu_to_be32(ns->ns_id);
++=======
+ 	struct nvme_id_ctrl *id_ctrl;
+ 	int nvme_sc, res;
++>>>>>>> 01fec28a6f3b (nvme: use vendor it from identify):drivers/nvme/host/scsi.c
  
 -	if (alloc_len < 72) {
 -		return nvme_trans_completion(hdr,
 -				SAM_STAT_CHECK_CONDITION,
 -				ILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,
 -				SCSI_ASCQ_CAUSE_NOT_REPORTABLE);
 +	mem = dma_alloc_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns),
 +					&dma_addr, GFP_KERNEL);
 +	if (mem == NULL) {
 +		res = -ENOMEM;
 +		goto out_dma;
  	}
  
+ 	nvme_sc = nvme_identify_ctrl(dev, &id_ctrl);
+ 	res = nvme_trans_status_code(hdr, nvme_sc);
+ 	if (res)
+ 		return res;
+ 
  	memset(inq_response, 0, alloc_len);
 -	inq_response[1] = INQ_DEVICE_IDENTIFICATION_PAGE;
 -	inq_response[3] = 0x48;	/* Page Length */
 +	inq_response[1] = INQ_DEVICE_IDENTIFICATION_PAGE;    /* Page Code */
 +	if (readl(&dev->bar->vs) >= NVME_VS(1, 1)) {
 +		struct nvme_id_ns *id_ns = mem;
 +		void *eui = id_ns->eui64;
 +		int len = sizeof(id_ns->eui64);
  
 -	/* Designation Descriptor start */
 -	inq_response[4] = 0x03;	/* Proto ID=0h | Code set=3h */
 -	inq_response[5] = 0x08;	/* PIV=0b | Asso=00b | Designator Type=8h */
 -	inq_response[6] = 0x00;	/* Rsvd */
 -	inq_response[7] = 0x44;	/* Designator Length */
 +		nvme_sc = nvme_identify(dev, ns->ns_id, 0, dma_addr);
 +		res = nvme_trans_status_code(hdr, nvme_sc);
 +		if (res)
 +			goto out_free;
  
++<<<<<<< HEAD:drivers/block/nvme-scsi.c
 +		if (readl(&dev->bar->vs) >= NVME_VS(1, 2)) {
 +			if (bitmap_empty(eui, len * 8)) {
 +				eui = id_ns->nguid;
 +				len = sizeof(id_ns->nguid);
 +			}
 +		}
 +		if (bitmap_empty(eui, len * 8))
 +			goto scsi_string;
 +
 +		inq_response[3] = 4 + len; /* Page Length */
 +		/* Designation Descriptor start */
 +		inq_response[4] = 0x01;    /* Proto ID=0h | Code set=1h */
 +		inq_response[5] = 0x02;    /* PIV=0b | Asso=00b | Designator Type=2h */
 +		inq_response[6] = 0x00;    /* Rsvd */
 +		inq_response[7] = len;     /* Designator Length */
 +		memcpy(&inq_response[8], eui, len);
 +	} else {
 + scsi_string:
 +		if (alloc_len < 72) {
 +			res = nvme_trans_completion(hdr,
 +					SAM_STAT_CHECK_CONDITION,
 +					ILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,
 +					SCSI_ASCQ_CAUSE_NOT_REPORTABLE);
 +			goto out_free;
 +		}
 +		inq_response[3] = 0x48;    /* Page Length */
 +		/* Designation Descriptor start */
 +		inq_response[4] = 0x03;    /* Proto ID=0h | Code set=3h */
 +		inq_response[5] = 0x08;    /* PIV=0b | Asso=00b | Designator Type=8h */
 +		inq_response[6] = 0x00;    /* Rsvd */
 +		inq_response[7] = 0x44;    /* Designator Length */
++=======
+ 	sprintf(&inq_response[8], "%04x", le16_to_cpu(id_ctrl->vid));
+ 	memcpy(&inq_response[12], dev->model, sizeof(dev->model));
+ 	sprintf(&inq_response[52], "%04x", cpu_to_be32(ns->ns_id));
+ 	memcpy(&inq_response[56], dev->serial, sizeof(dev->serial));
+ 
+ 	res = nvme_trans_copy_to_user(hdr, inq_response, alloc_len);
+ 	kfree(id_ctrl);
+ 	return res;
+ }
++>>>>>>> 01fec28a6f3b (nvme: use vendor it from identify):drivers/nvme/host/scsi.c
  
 -static int nvme_trans_device_id_page(struct nvme_ns *ns, struct sg_io_hdr *hdr,
 -					u8 *resp, int alloc_len)
 -{
 -	int res;
 -
 -	if (readl(ns->dev->bar + NVME_REG_VS) >= NVME_VS(1, 1)) {
 -		res = nvme_fill_device_id_eui64(ns, hdr, resp, alloc_len);
 -		if (res != -EOPNOTSUPP)
 -			return res;
 +		sprintf(&inq_response[8], "%04x", dev->pci_dev->vendor);
 +		memcpy(&inq_response[12], dev->model, sizeof(dev->model));
 +		sprintf(&inq_response[52], "%04x", tmp_id);
 +		memcpy(&inq_response[56], dev->serial, sizeof(dev->serial));
  	}
 +	xfer_len = alloc_len;
 +	res = nvme_trans_copy_to_user(hdr, inq_response, xfer_len);
  
 -	return nvme_fill_device_id_scsi_string(ns, hdr, resp, alloc_len);
 + out_free:
 +	dma_free_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns), mem,
 +			  dma_addr);
 + out_dma:
 +	return res;
  }
  
  static int nvme_trans_ext_inq_page(struct nvme_ns *ns, struct sg_io_hdr *hdr,
* Unmerged path drivers/block/nvme-scsi.c
