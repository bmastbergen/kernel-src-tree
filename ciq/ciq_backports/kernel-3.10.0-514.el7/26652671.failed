mmc: slot-gpio: Split out CD IRQ request into a separate function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] slot-gpio: Split out CD IRQ request into a separate function (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 96.00%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 26652671338a443fd33cf47b50658dd8b095d54a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/26652671.failed

In preparation for adding a descriptor-based CD GPIO API, split out
CD IRQ request into a separate function.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Chris Ball <chris@printf.net>
(cherry picked from commit 26652671338a443fd33cf47b50658dd8b095d54a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/slot-gpio.c
diff --cc drivers/mmc/core/slot-gpio.c
index 2d78bc46fa68,47fa07e3604d..000000000000
--- a/drivers/mmc/core/slot-gpio.c
+++ b/drivers/mmc/core/slot-gpio.c
@@@ -151,12 -185,16 +184,11 @@@ static void mmc_gpiod_request_cd_irq(st
   * switching for card-detection, they are responsible for calling
   * mmc_gpio_request_cd() and mmc_gpio_free_cd() as a pair on their own.
   *
 - * If GPIO debouncing is desired, set the debounce parameter to a non-zero
 - * value. The caller is responsible for ensuring that the GPIO driver associated
 - * with the GPIO supports debouncing, otherwise an error will be returned.
 - *
   * Returns zero on success, else an error.
   */
 -int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio,
 -			unsigned int debounce)
 +int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio)
  {
  	struct mmc_gpio *ctx;
- 	int irq = gpio_to_irq(gpio);
  	int ret;
  
  	ret = mmc_gpio_alloc(host);
@@@ -175,28 -213,12 +207,37 @@@
  		 */
  		return ret;
  
++<<<<<<< HEAD
 +	/*
 +	 * Even if gpio_to_irq() returns a valid IRQ number, the platform might
 +	 * still prefer to poll, e.g., because that IRQ number is already used
 +	 * by another unit and cannot be shared.
 +	 */
 +	if (irq >= 0 && host->caps & MMC_CAP_NEEDS_POLL)
 +		irq = -EINVAL;
 +
 +	if (irq >= 0) {
 +		ret = devm_request_threaded_irq(&host->class_dev, irq,
 +			NULL, mmc_gpio_cd_irqt,
 +			IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
 +			ctx->cd_label, host);
 +		if (ret < 0)
 +			irq = ret;
 +	}
 +
 +	host->slot.cd_irq = irq;
 +
 +	if (irq < 0)
 +		host->caps |= MMC_CAP_NEEDS_POLL;
 +
++=======
+ 	if (debounce) {
+ 		ret = gpio_set_debounce(gpio, debounce);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
++>>>>>>> 26652671338a (mmc: slot-gpio: Split out CD IRQ request into a separate function)
  	ctx->override_cd_active_level = true;
  	ctx->cd_gpio = gpio_to_desc(gpio);
  
* Unmerged path drivers/mmc/core/slot-gpio.c
