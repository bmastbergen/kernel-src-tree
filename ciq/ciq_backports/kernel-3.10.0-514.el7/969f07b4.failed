gpio: use kzalloc to allocate gpio_device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [gpio] use kzalloc to allocate gpio_device (Steve Best) [1358979]
Rebuild_FUZZ: 92.11%
commit-author Josh Cartwright <joshc@ni.com>
commit 969f07b445d1c30479f53ce6818e1263043b999a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/969f07b4.failed

The use of kmalloc() to allocate the gpio_device leaves the contained struct
device object in an unknown state.  Calling dev_set_name() on a struct device
of unknown state can trigger the free() of an invalid pointer, as seen in the
following backtrace (collected by Tony Lindgren):

  kfree
  kobject_set_name_vargs
  dev_set_name
  gpiochip_add_data
  omap_gpio_probe
  platform_drv_probe
  ...

	Reported-by: Geert Uytterhoeven <geert+renesas@glider.be>
	Reported-by: Michael Welling <mwelling@ieee.org>
	Reported-by: Tony Lindgren <tony@atomide.com>
	Tested-by: Michael Welling <mwelling@ieee.org>
	Tested-by: Tony Lindgren <tony@atomide.com>
	Signed-off-by: Josh Cartwright <joshc@ni.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 969f07b445d1c30479f53ce6818e1263043b999a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpiolib.c
diff --cc drivers/gpio/gpiolib.c
index 9b50ed619d38,59f0045c5950..000000000000
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@@ -1176,14 -427,60 +1176,62 @@@ int gpiochip_add(struct gpio_chip *chip
  {
  	unsigned long	flags;
  	int		status = 0;
 -	unsigned	i;
 +	unsigned	id;
  	int		base = chip->base;
 -	struct gpio_device *gdev;
  
++<<<<<<< HEAD
 +	if ((!gpio_is_valid(base) || !gpio_is_valid(base + chip->ngpio - 1))
 +			&& base >= 0) {
++=======
+ 	/*
+ 	 * First: allocate and populate the internal stat container, and
+ 	 * set up the struct device.
+ 	 */
+ 	gdev = kzalloc(sizeof(*gdev), GFP_KERNEL);
+ 	if (!gdev)
+ 		return -ENOMEM;
+ 	gdev->dev.bus = &gpio_bus_type;
+ 	gdev->chip = chip;
+ 	chip->gpiodev = gdev;
+ 	if (chip->parent) {
+ 		gdev->dev.parent = chip->parent;
+ 		gdev->dev.of_node = chip->parent->of_node;
+ 	} else {
+ #ifdef CONFIG_OF_GPIO
+ 	/* If the gpiochip has an assigned OF node this takes precedence */
+ 		if (chip->of_node)
+ 			gdev->dev.of_node = chip->of_node;
+ #endif
+ 	}
+ 	gdev->id = ida_simple_get(&gpio_ida, 0, 0, GFP_KERNEL);
+ 	if (gdev->id < 0) {
+ 		status = gdev->id;
+ 		goto err_free_gdev;
+ 	}
+ 	dev_set_name(&gdev->dev, "gpiochip%d", gdev->id);
+ 	device_initialize(&gdev->dev);
+ 	dev_set_drvdata(&gdev->dev, gdev);
+ 	if (chip->parent && chip->parent->driver)
+ 		gdev->owner = chip->parent->driver->owner;
+ 	else if (chip->owner)
+ 		/* TODO: remove chip->owner */
+ 		gdev->owner = chip->owner;
+ 	else
+ 		gdev->owner = THIS_MODULE;
+ 
+ 	gdev->descs = devm_kcalloc(&gdev->dev, chip->ngpio,
+ 				   sizeof(gdev->descs[0]), GFP_KERNEL);
+ 	if (!gdev->descs) {
+ 		status = -ENOMEM;
+ 		goto err_free_gdev;
+ 	}
+ 
+ 	if (chip->ngpio == 0) {
+ 		chip_err(chip, "tried to insert a GPIO chip with zero lines\n");
++>>>>>>> 969f07b445d1 (gpio: use kzalloc to allocate gpio_device)
  		status = -EINVAL;
 -		goto err_free_gdev;
 +		goto fail;
  	}
 -	gdev->ngpio = chip->ngpio;
 -	gdev->data = data;
  
  	spin_lock_irqsave(&gpio_lock, flags);
  
* Unmerged path drivers/gpio/gpiolib.c
