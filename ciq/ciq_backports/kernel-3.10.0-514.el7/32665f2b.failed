mm/migrate: correct failure handling if !hugepage_migration_support()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mm] migrate: correct failure handling if !hugepage_migration_support() (Tomoaki Nishimura) [1287322]
Rebuild_FUZZ: 97.78%
commit-author Joonsoo Kim <iamjoonsoo.kim@lge.com>
commit 32665f2bbfed2e325d37236d9b0071a11a69124e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/32665f2b.failed

We should remove the page from the list if we fail with ENOSYS, since
migrate_pages() consider error cases except -ENOMEM and -EAGAIN as
permanent failure and it assumes that the page would be removed from the
list.  Without this patch, we could overcount number of failure.

In addition, we should put back the new hugepage if
!hugepage_migration_support().  If not, we would leak hugepage memory.

	Signed-off-by: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Acked-by: Christoph Lameter <cl@linux.com>
	Reviewed-by: Wanpeng Li <liwanp@linux.vnet.ibm.com>
	Reviewed-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Cc: Rafael Aquini <aquini@redhat.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Wanpeng Li <liwanp@linux.vnet.ibm.com>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Zhang Yanfei <zhangyanfei@cn.fujitsu.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 32665f2bbfed2e325d37236d9b0071a11a69124e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/migrate.c
diff --cc mm/migrate.c
index c1313d07c550,13bedcc4656b..000000000000
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@@ -1006,9 -1013,22 +1006,25 @@@ static int unmap_and_move_huge_page(new
  {
  	int rc = 0;
  	int *result = NULL;
- 	struct page *new_hpage = get_new_page(hpage, private, &result);
+ 	struct page *new_hpage;
  	struct anon_vma *anon_vma = NULL;
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Movability of hugepages depends on architectures and hugepage size.
+ 	 * This check is necessary because some callers of hugepage migration
+ 	 * like soft offline and memory hotremove don't walk through page
+ 	 * tables or check whether the hugepage is pmd-based or not before
+ 	 * kicking migration.
+ 	 */
+ 	if (!hugepage_migration_support(page_hstate(hpage))) {
+ 		putback_active_hugepage(hpage);
+ 		return -ENOSYS;
+ 	}
+ 
+ 	new_hpage = get_new_page(hpage, private, &result);
++>>>>>>> 32665f2bbfed (mm/migrate: correct failure handling if !hugepage_migration_support())
  	if (!new_hpage)
  		return -ENOMEM;
  
* Unmerged path mm/migrate.c
