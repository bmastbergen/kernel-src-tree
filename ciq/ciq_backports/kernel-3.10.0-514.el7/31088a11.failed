net: add for_each iterators through neighbour lower link's private

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] add for_each iterators through neighbour lower link's private (Ivan Vecera) [1268334]
Rebuild_FUZZ: 96.06%
commit-author Veaceslav Falico <vfalico@redhat.com>
commit 31088a113c2a948856ed2047d8c21c217b13e85d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/31088a11.failed

Add a possibility to iterate through netdev_adjacent's private, currently
only for lower neighbours.

Add both RCU and RTNL/other locking variants of iterators, and make the
non-rcu variant to be safe from removal.

CC: "David S. Miller" <davem@davemloft.net>
CC: Eric Dumazet <edumazet@google.com>
CC: Jiri Pirko <jiri@resnulli.us>
CC: Alexander Duyck <alexander.h.duyck@intel.com>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 31088a113c2a948856ed2047d8c21c217b13e85d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/core/dev.c
diff --cc include/linux/netdevice.h
index 7b10147de03d,168974e40cf5..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -3273,30 -2820,56 +3273,70 @@@ extern int		netdev_tstamp_prequeue
  extern int		weight_p;
  extern int		bpf_jit_enable;
  
 -extern bool netdev_has_upper_dev(struct net_device *dev,
 +bool netdev_has_upper_dev(struct net_device *dev, struct net_device *upper_dev);
 +bool netdev_has_any_upper_dev(struct net_device *dev);
 +struct net_device *netdev_master_upper_dev_get(struct net_device *dev);
 +struct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev);
 +int netdev_upper_dev_link(struct net_device *dev, struct net_device *upper_dev);
 +int netdev_master_upper_dev_link(struct net_device *dev,
  				 struct net_device *upper_dev);
 -extern bool netdev_has_any_upper_dev(struct net_device *dev);
 -extern struct net_device *netdev_all_upper_get_next_dev_rcu(struct net_device *dev,
 -							    struct list_head **iter);
 -
 -/* iterate through upper list, must be called under RCU read lock */
 -#define netdev_for_each_all_upper_dev_rcu(dev, updev, iter) \
 -	for (iter = &(dev)->all_adj_list.upper, \
 -	     updev = netdev_all_upper_get_next_dev_rcu(dev, &(iter)); \
 -	     updev; \
 -	     updev = netdev_all_upper_get_next_dev_rcu(dev, &(iter)))
 -
 +void netdev_upper_dev_unlink(struct net_device *dev,
 +			     struct net_device *upper_dev);
 +void *netdev_lower_dev_get_private_rcu(struct net_device *dev,
 +				       struct net_device *lower_dev);
 +void *netdev_lower_dev_get_private(struct net_device *dev,
 +				   struct net_device *lower_dev);
 +
 +/* RSS keys are 40 or 52 bytes long */
 +#define NETDEV_RSS_KEY_LEN 52
 +extern u8 netdev_rss_key[NETDEV_RSS_KEY_LEN];
 +void netdev_rss_key_fill(void *buffer, size_t len);
 +
++<<<<<<< HEAD
 +int skb_checksum_help(struct sk_buff *skb);
 +struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
 +				  netdev_features_t features, bool tx_path);
 +struct sk_buff *skb_mac_gso_segment(struct sk_buff *skb,
 +				    netdev_features_t features);
++=======
+ extern void *netdev_lower_get_next_private(struct net_device *dev,
+ 					   struct list_head **iter);
+ extern void *netdev_lower_get_next_private_rcu(struct net_device *dev,
+ 					       struct list_head **iter);
+ 
+ #define netdev_for_each_lower_private(dev, priv, iter) \
+ 	for (iter = (dev)->adj_list.lower.next, \
+ 	     priv = netdev_lower_get_next_private(dev, &(iter)); \
+ 	     priv; \
+ 	     priv = netdev_lower_get_next_private(dev, &(iter)))
+ 
+ #define netdev_for_each_lower_private_rcu(dev, priv, iter) \
+ 	for (iter = &(dev)->adj_list.lower, \
+ 	     priv = netdev_lower_get_next_private_rcu(dev, &(iter)); \
+ 	     priv; \
+ 	     priv = netdev_lower_get_next_private_rcu(dev, &(iter)))
+ 
+ extern struct net_device *netdev_master_upper_dev_get(struct net_device *dev);
+ extern struct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev);
+ extern int netdev_upper_dev_link(struct net_device *dev,
+ 				 struct net_device *upper_dev);
+ extern int netdev_master_upper_dev_link(struct net_device *dev,
+ 					struct net_device *upper_dev);
+ extern int netdev_master_upper_dev_link_private(struct net_device *dev,
+ 						struct net_device *upper_dev,
+ 						void *private);
+ extern void netdev_upper_dev_unlink(struct net_device *dev,
+ 				    struct net_device *upper_dev);
+ extern void *netdev_lower_dev_get_private_rcu(struct net_device *dev,
+ 					      struct net_device *lower_dev);
+ extern void *netdev_lower_dev_get_private(struct net_device *dev,
+ 					  struct net_device *lower_dev);
+ extern int skb_checksum_help(struct sk_buff *skb);
+ extern struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
+ 	netdev_features_t features, bool tx_path);
+ extern struct sk_buff *skb_mac_gso_segment(struct sk_buff *skb,
+ 					  netdev_features_t features);
++>>>>>>> 31088a113c2a (net: add for_each iterators through neighbour lower link's private)
  
  static inline
  struct sk_buff *skb_gso_segment(struct sk_buff *skb, netdev_features_t features)
diff --cc net/core/dev.c
index 004e3f31d664,0aa844aae40b..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -4606,7 -4466,8 +4606,12 @@@ struct net_device *netdev_master_upper_
  }
  EXPORT_SYMBOL(netdev_master_upper_dev_get);
  
++<<<<<<< HEAD
 +/* netdev_upper_get_next_dev_rcu - Get the next dev from upper list
++=======
+ /**
+  * netdev_all_upper_get_next_dev_rcu - Get the next dev from upper list
++>>>>>>> 31088a113c2a (net: add for_each iterators through neighbour lower link's private)
   * @dev: device
   * @iter: list_head ** of the current position
   *
@@@ -4629,8 -4490,65 +4634,65 @@@ struct net_device *netdev_upper_get_nex
  
  	return upper->dev;
  }
 -EXPORT_SYMBOL(netdev_all_upper_get_next_dev_rcu);
 +EXPORT_SYMBOL(netdev_upper_get_next_dev_rcu);
  
+ /**
+  * netdev_lower_get_next_private - Get the next ->private from the
+  *				   lower neighbour list
+  * @dev: device
+  * @iter: list_head ** of the current position
+  *
+  * Gets the next netdev_adjacent->private from the dev's lower neighbour
+  * list, starting from iter position. The caller must hold either hold the
+  * RTNL lock or its own locking that guarantees that the neighbour lower
+  * list will remain unchainged.
+  */
+ void *netdev_lower_get_next_private(struct net_device *dev,
+ 				    struct list_head **iter)
+ {
+ 	struct netdev_adjacent *lower;
+ 
+ 	lower = list_entry(*iter, struct netdev_adjacent, list);
+ 
+ 	if (&lower->list == &dev->adj_list.lower)
+ 		return NULL;
+ 
+ 	if (iter)
+ 		*iter = lower->list.next;
+ 
+ 	return lower->private;
+ }
+ EXPORT_SYMBOL(netdev_lower_get_next_private);
+ 
+ /**
+  * netdev_lower_get_next_private_rcu - Get the next ->private from the
+  *				       lower neighbour list, RCU
+  *				       variant
+  * @dev: device
+  * @iter: list_head ** of the current position
+  *
+  * Gets the next netdev_adjacent->private from the dev's lower neighbour
+  * list, starting from iter position. The caller must hold RCU read lock.
+  */
+ void *netdev_lower_get_next_private_rcu(struct net_device *dev,
+ 					struct list_head **iter)
+ {
+ 	struct netdev_adjacent *lower;
+ 
+ 	WARN_ON_ONCE(!rcu_read_lock_held());
+ 
+ 	lower = list_entry_rcu((*iter)->next, struct netdev_adjacent, list);
+ 
+ 	if (&lower->list == &dev->adj_list.lower)
+ 		return NULL;
+ 
+ 	if (iter)
+ 		*iter = &lower->list;
+ 
+ 	return lower->private;
+ }
+ EXPORT_SYMBOL(netdev_lower_get_next_private_rcu);
+ 
  /**
   * netdev_master_upper_dev_get_rcu - Get master upper device
   * @dev: device
* Unmerged path include/linux/netdevice.h
* Unmerged path net/core/dev.c
