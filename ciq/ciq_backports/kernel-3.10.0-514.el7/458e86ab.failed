staging/rdma/hfi1: Remove blank line after an open brace

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Remove blank line after an open brace (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 92.31%
commit-author Jubin John <jubin.john@intel.com>
commit 458e86ab471b44a28a736cb8b0d364f3ec0d3e3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/458e86ab.failed

Remove blank line after an open brace to fix checkpatch check:
CHECK: Blank lines aren't necessary after an open brace '{'

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Jubin John <jubin.john@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 458e86ab471b44a28a736cb8b0d364f3ec0d3e3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/chip.c
#	drivers/staging/rdma/hfi1/qp.c
diff --cc drivers/staging/hfi1/chip.c
index 2f61b64fc695,05e4f07e137d..000000000000
--- a/drivers/staging/hfi1/chip.c
+++ b/drivers/staging/hfi1/chip.c
@@@ -9219,20 -9263,19 +9216,30 @@@ static void qsfp_event(struct work_stru
  	dc_start(dd);
  
  	if (qd->cache_refresh_required) {
++<<<<<<< HEAD:drivers/staging/hfi1/chip.c
 +		msleep(3000);
 +		reset_qsfp(ppd);
 +
 +		/* Check for QSFP interrupt after t_init (SFF 8679)
 +		 * + extra
++=======
+ 		set_qsfp_int_n(ppd, 0);
+ 
+ 		wait_for_qsfp_init(ppd);
+ 
+ 		/*
+ 		 * Allow INT_N to trigger the QSFP interrupt to watch
+ 		 * for alarms and warnings
++>>>>>>> 458e86ab471b (staging/rdma/hfi1: Remove blank line after an open brace):drivers/staging/rdma/hfi1/chip.c
  		 */
 -		set_qsfp_int_n(ppd, 1);
 -
 -		tune_serdes(ppd);
 -
 -		start_link(ppd);
 +		msleep(3000);
 +		if (!qd->qsfp_interrupt_functional) {
 +			if (do_qsfp_intr_fallback(ppd) < 0)
 +				dd_dev_info(dd, "%s: QSFP fallback failed\n",
 +					__func__);
 +			ppd->driver_link_ready = 1;
 +			start_link(ppd);
 +		}
  	}
  
  	if (qd->check_interrupt_flags) {
* Unmerged path drivers/staging/rdma/hfi1/qp.c
* Unmerged path drivers/staging/hfi1/chip.c
diff --git a/drivers/staging/hfi1/driver.c b/drivers/staging/hfi1/driver.c
index 31605ee909b6..3c5c164fe570 100644
--- a/drivers/staging/hfi1/driver.c
+++ b/drivers/staging/hfi1/driver.c
@@ -421,7 +421,6 @@ drop:
 static inline void init_packet(struct hfi1_ctxtdata *rcd,
 			      struct hfi1_packet *packet)
 {
-
 	packet->rsize = rcd->rcvhdrqentsize; /* words */
 	packet->maxcnt = rcd->rcvhdrq_cnt * packet->rsize; /* words */
 	packet->rcd = rcd;
@@ -737,7 +736,6 @@ static inline void process_rcv_update(int last, struct hfi1_packet *packet)
 
 static inline void finish_packet(struct hfi1_packet *packet)
 {
-
 	/*
 	 * Nothing we need to free for the packet.
 	 *
@@ -751,7 +749,6 @@ static inline void finish_packet(struct hfi1_packet *packet)
 
 static inline void process_rcv_qp_work(struct hfi1_packet *packet)
 {
-
 	struct hfi1_ctxtdata *rcd;
 	struct hfi1_qp *qp, *nqp;
 
diff --git a/drivers/staging/hfi1/mad.c b/drivers/staging/hfi1/mad.c
index b6006cf469fc..44f20e10dc4a 100644
--- a/drivers/staging/hfi1/mad.c
+++ b/drivers/staging/hfi1/mad.c
@@ -2168,7 +2168,6 @@ struct opa_port_error_info_msg {
 	__be32 error_info_select_mask;
 	__be32 reserved1;
 	struct _port_ei {
-
 		u8 port_number;
 		u8 reserved2[7];
 
@@ -3126,7 +3125,6 @@ static int pma_set_opa_portstatus(struct opa_pma_mad *pmp,
 
 	for_each_set_bit(vl, (unsigned long *)&(vl_select_mask),
 			 8 * sizeof(vl_select_mask)) {
-
 		if (counter_select & CS_PORT_XMIT_DATA)
 			write_port_cntr(ppd, C_TX_FLIT_VL, idx_from_vl(vl), 0);
 
diff --git a/drivers/staging/hfi1/qsfp.c b/drivers/staging/hfi1/qsfp.c
index c9d1e64ef681..f8234435f4d3 100644
--- a/drivers/staging/hfi1/qsfp.c
+++ b/drivers/staging/hfi1/qsfp.c
@@ -360,7 +360,6 @@ int refresh_qsfp_cache(struct hfi1_pportdata *ppd, struct qsfp_data *cp)
 
 	/* Is paging enabled? */
 	if (!(cache[2] & 4)) {
-
 		/* Paging enabled, page 03 required */
 		if ((cache[195] & 0xC0) == 0xC0) {
 			/* all */
@@ -521,7 +520,6 @@ int qsfp_dump(struct hfi1_pportdata *ppd, char *buf, int len)
 	lenstr[1] = '\0';
 
 	if (ppd->qsfp_info.cache_valid) {
-
 		if (QSFP_IS_CU(cache[QSFP_MOD_TECH_OFFS]))
 			sprintf(lenstr, "%dM ", cache[QSFP_MOD_LEN_OFFS]);
 
diff --git a/drivers/staging/hfi1/sdma.c b/drivers/staging/hfi1/sdma.c
index 8a57bc183ce2..c332478ed18e 100644
--- a/drivers/staging/hfi1/sdma.c
+++ b/drivers/staging/hfi1/sdma.c
@@ -472,7 +472,6 @@ static void sdma_err_halt_wait(struct work_struct *work)
 static void sdma_err_progress_check_schedule(struct sdma_engine *sde)
 {
 	if (!is_bx(sde->dd) && HFI1_CAP_IS_KSET(SDMA_AHG)) {
-
 		unsigned index;
 		struct hfi1_devdata *dd = sde->dd;
 
@@ -1259,7 +1258,6 @@ void sdma_exit(struct hfi1_devdata *dd)
 
 	for (this_idx = 0; dd->per_sdma && this_idx < dd->num_sdma;
 			++this_idx) {
-
 		sde = &dd->per_sdma[this_idx];
 		if (!list_empty(&sde->dmawait))
 			dd_dev_err(dd, "sde %u: dmawait list not empty!\n",
* Unmerged path drivers/staging/rdma/hfi1/qp.c
