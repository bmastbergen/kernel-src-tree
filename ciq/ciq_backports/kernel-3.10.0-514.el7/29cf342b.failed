btrfs: cleanup, use correct type in div_u64_rem

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author David Sterba <dsterba@suse.cz>
commit 29cf342b8f1056486557015aba4538804a872dc1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/29cf342b.failed

div_u64_rem expects u32 for divisior and reminder.

	Signed-off-by: David Sterba <dsterba@suse.cz>
(cherry picked from commit 29cf342b8f1056486557015aba4538804a872dc1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/volumes.c
diff --cc fs/btrfs/volumes.c
index 0455a2c06b77,4b8917ee1fdf..000000000000
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@@ -4909,8 -4954,7 +4909,12 @@@ static int __btrfs_map_block(struct btr
  	u64 stripe_nr_orig;
  	u64 stripe_nr_end;
  	u64 stripe_len;
++<<<<<<< HEAD
 +	u64 *raid_map = NULL;
 +	int stripe_index;
++=======
+ 	u32 stripe_index;
++>>>>>>> 29cf342b8f10 (btrfs: cleanup, use correct type in div_u64_rem)
  	int i;
  	int ret = 0;
  	int num_stripes;
@@@ -5127,9 -5172,9 +5131,9 @@@
  		}
  
  	} else if (map->type & BTRFS_BLOCK_GROUP_RAID10) {
- 		int factor = map->num_stripes / map->sub_stripes;
+ 		u32 factor = map->num_stripes / map->sub_stripes;
  
 -		stripe_nr = div_u64_rem(stripe_nr, factor, &stripe_index);
 +		stripe_index = do_div(stripe_nr, factor);
  		stripe_index *= map->sub_stripes;
  
  		if (rw & (REQ_WRITE | REQ_GET_READ_MIRRORS))
@@@ -5241,9 -5258,37 +5245,40 @@@
  	if (dev_replace_is_ongoing)
  		bbio->tgtdev_map = (int *)(bbio->stripes + num_alloc_stripes);
  
++<<<<<<< HEAD
++=======
+ 	/* build raid_map */
+ 	if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK &&
+ 	    need_raid_map && ((rw & (REQ_WRITE | REQ_GET_READ_MIRRORS)) ||
+ 	    mirror_num > 1)) {
+ 		u64 tmp;
+ 		int i;
+ 		unsigned rot;
+ 
+ 		bbio->raid_map = (u64 *)((void *)bbio->stripes +
+ 				 sizeof(struct btrfs_bio_stripe) *
+ 				 num_alloc_stripes +
+ 				 sizeof(int) * tgtdev_indexes);
+ 
+ 		/* Work out the disk rotation on this stripe-set */
+ 		div_u64_rem(stripe_nr, num_stripes, &rot);
+ 
+ 		/* Fill in the logical address of each stripe */
+ 		tmp = stripe_nr * nr_data_stripes(map);
+ 		for (i = 0; i < nr_data_stripes(map); i++)
+ 			bbio->raid_map[(i+rot) % num_stripes] =
+ 				em->start + (tmp + i) * map->stripe_len;
+ 
+ 		bbio->raid_map[(i+rot) % map->num_stripes] = RAID5_P_STRIPE;
+ 		if (map->type & BTRFS_BLOCK_GROUP_RAID6)
+ 			bbio->raid_map[(i+rot+1) % num_stripes] =
+ 				RAID6_Q_STRIPE;
+ 	}
+ 
++>>>>>>> 29cf342b8f10 (btrfs: cleanup, use correct type in div_u64_rem)
  	if (rw & REQ_DISCARD) {
- 		int factor = 0;
- 		int sub_stripes = 0;
+ 		u32 factor = 0;
+ 		u32 sub_stripes = 0;
  		u64 stripes_per_dev = 0;
  		u32 remaining_stripes = 0;
  		u32 last_stripe = 0;
diff --git a/fs/btrfs/scrub.c b/fs/btrfs/scrub.c
index 5662ab657252..2ab609bda736 100644
--- a/fs/btrfs/scrub.c
+++ b/fs/btrfs/scrub.c
@@ -2332,7 +2332,7 @@ static inline void __scrub_mark_bitmap(struct scrub_parity *sparity,
 				       unsigned long *bitmap,
 				       u64 start, u64 len)
 {
-	int offset;
+	u32 offset;
 	int nsectors;
 	int sectorsize = sparity->sctx->dev_root->sectorsize;
 
@@ -2625,8 +2625,8 @@ static int get_raid56_logic_offset(u64 physical, int num,
 	int j = 0;
 	u64 stripe_nr;
 	u64 last_offset;
-	int stripe_index;
-	int rot;
+	u32 stripe_index;
+	u32 rot;
 
 	last_offset = (physical - map->stripes[num].physical) *
 		      nr_data_stripes(map);
* Unmerged path fs/btrfs/volumes.c
