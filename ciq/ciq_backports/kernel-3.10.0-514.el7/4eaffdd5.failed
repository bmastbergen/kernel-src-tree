x86/mm: Improve switch_mm() barrier comments

jira LE-1907
cve CVE-2016-2069
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] mm: Improve switch_mm() barrier comments (Rafael Aquini) [1332602] {CVE-2016-2069}
Rebuild_FUZZ: 95.24%
commit-author Andy Lutomirski <luto@kernel.org>
commit 4eaffdd5a5fe6ff9f95e1ab4de1ac904d5e0fa8b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4eaffdd5.failed

My previous comments were still a bit confusing and there was a
typo. Fix it up.

	Reported-by: Peter Zijlstra <peterz@infradead.org>
	Signed-off-by: Andy Lutomirski <luto@kernel.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: stable@vger.kernel.org
Fixes: 71b3c126e611 ("x86/mm: Add barriers and document switch_mm()-vs-flush synchronization")
Link: http://lkml.kernel.org/r/0a0b43cdcdd241c5faaaecfbcc91a155ddedc9a1.1452631609.git.luto@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 4eaffdd5a5fe6ff9f95e1ab4de1ac904d5e0fa8b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/mmu_context.h
diff --cc arch/x86/include/asm/mmu_context.h
index be12c534fd59,bfd9b2a35a0b..000000000000
--- a/arch/x86/include/asm/mmu_context.h
+++ b/arch/x86/include/asm/mmu_context.h
@@@ -42,9 -116,38 +42,40 @@@ static inline void switch_mm(struct mm_
  #endif
  		cpumask_set_cpu(cpu, mm_cpumask(next));
  
++<<<<<<< HEAD
 +		/* Re-load page tables */
++=======
+ 		/*
+ 		 * Re-load page tables.
+ 		 *
+ 		 * This logic has an ordering constraint:
+ 		 *
+ 		 *  CPU 0: Write to a PTE for 'next'
+ 		 *  CPU 0: load bit 1 in mm_cpumask.  if nonzero, send IPI.
+ 		 *  CPU 1: set bit 1 in next's mm_cpumask
+ 		 *  CPU 1: load from the PTE that CPU 0 writes (implicit)
+ 		 *
+ 		 * We need to prevent an outcome in which CPU 1 observes
+ 		 * the new PTE value and CPU 0 observes bit 1 clear in
+ 		 * mm_cpumask.  (If that occurs, then the IPI will never
+ 		 * be sent, and CPU 0's TLB will contain a stale entry.)
+ 		 *
+ 		 * The bad outcome can occur if either CPU's load is
+ 		 * reordered before that CPU's store, so both CPUs must
+ 		 * execute full barriers to prevent this from happening.
+ 		 *
+ 		 * Thus, switch_mm needs a full barrier between the
+ 		 * store to mm_cpumask and any operation that could load
+ 		 * from next->pgd.  TLB fills are special and can happen
+ 		 * due to instruction fetches or for no reason at all,
+ 		 * and neither LOCK nor MFENCE orders them.
+ 		 * Fortunately, load_cr3() is serializing and gives the
+ 		 * ordering guarantee we need.
+ 		 *
+ 		 */
++>>>>>>> 4eaffdd5a5fe (x86/mm: Improve switch_mm() barrier comments)
  		load_cr3(next->pgd);
  
 -		trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);
 -
  		/* Stop flush ipis for the previous mm */
  		cpumask_clear_cpu(cpu, mm_cpumask(prev));
  
@@@ -69,9 -189,14 +100,15 @@@
  			 * We were in lazy tlb mode and leave_mm disabled
  			 * tlb flush IPI delivery. We must reload CR3
  			 * to make sure to use no freed page tables.
++<<<<<<< HEAD
++=======
+ 			 *
+ 			 * As above, load_cr3() is serializing and orders TLB
+ 			 * fills with respect to the mm_cpumask write.
++>>>>>>> 4eaffdd5a5fe (x86/mm: Improve switch_mm() barrier comments)
  			 */
  			load_cr3(next->pgd);
 -			trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);
 -			load_mm_cr4(next);
 -			load_mm_ldt(next);
 +			load_LDT_nolock(&next->context);
  		}
  	}
  #endif
* Unmerged path arch/x86/include/asm/mmu_context.h
