ipv6: Only create RTF_CACHE routes after encountering pmtu exception

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit 45e4fd26683c9a5f88600d91b08a484f7f09226a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/45e4fd26.failed

This patch creates a RTF_CACHE routes only after encountering a pmtu
exception.

After ip6_rt_update_pmtu() has inserted the RTF_CACHE route to the fib6
tree, the rt->rt6i_node->fn_sernum is bumped which will fail the
ip6_dst_check() and trigger a relookup.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Cc: Steffen Klassert <steffen.klassert@secunet.com>
	Cc: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 45e4fd26683c9a5f88600d91b08a484f7f09226a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip6_route.h
#	net/ipv6/route.c
diff --cc include/net/ip6_route.h
index c2439795bc4f,784ee3d01dbf..000000000000
--- a/include/net/ip6_route.h
+++ b/include/net/ip6_route.h
@@@ -208,9 -197,15 +208,18 @@@ static inline bool ip6_sk_ignore_df(con
  	       inet6_sk(sk)->pmtudisc == IPV6_PMTUDISC_OMIT;
  }
  
 -static inline struct in6_addr *rt6_nexthop(struct rt6_info *rt,
 -					   struct in6_addr *daddr)
 +static inline struct in6_addr *rt6_nexthop(struct rt6_info *rt)
  {
++<<<<<<< HEAD
 +	return &rt->rt6i_gateway;
++=======
+ 	if (rt->rt6i_flags & RTF_GATEWAY)
+ 		return &rt->rt6i_gateway;
+ 	else if (unlikely(rt->rt6i_flags & RTF_CACHE))
+ 		return &rt->rt6i_dst.addr;
+ 	else
+ 		return daddr;
++>>>>>>> 45e4fd26683c (ipv6: Only create RTF_CACHE routes after encountering pmtu exception)
  }
  
  #endif
diff --cc net/ipv6/route.c
index d52d1361c9f9,e7ae2430dfed..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -956,36 -904,7 +949,40 @@@ redo_rt6_select
  	dst_hold(&rt->dst);
  	read_unlock_bh(&table->tb6_lock);
  
++<<<<<<< HEAD
 +	if (rt->rt6i_flags & RTF_CACHE)
 +		goto out2;
 +
 +	if (!rt6_is_gw_or_nonexthop(rt) ||
 +	    !(rt->dst.flags & DST_HOST) || !(rt->rt6i_flags & RTF_LOCAL))
 +		nrt = ip6_rt_cache_alloc(rt, &fl6->daddr, &fl6->saddr);
 +	else
 +		goto out2;
 +
 +	ip6_rt_put(rt);
 +	rt = nrt ? : net->ipv6.ip6_null_entry;
 +
 +	dst_hold(&rt->dst);
 +	if (nrt) {
 +		err = ip6_ins_rt(nrt);
 +		if (!err)
 +			goto out2;
 +	}
 +
 +	if (--attempts <= 0)
 +		goto out2;
 +
 +	/*
 +	 * Race condition! In the gap, when table->tb6_lock was
 +	 * released someone could insert this route.  Relookup.
 +	 */
 +	ip6_rt_put(rt);
 +	goto redo_fib6_lookup_lock;
 +
 +out2:
++=======
+ 	rt6_dst_from_metrics_check(rt);
++>>>>>>> 45e4fd26683c (ipv6: Only create RTF_CACHE routes after encountering pmtu exception)
  	rt->dst.lastuse = jiffies;
  	rt->dst.__use++;
  
@@@ -1153,21 -1076,54 +1150,59 @@@ static void ip6_link_failure(struct sk_
  	}
  }
  
- static void ip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 			       struct sk_buff *skb, u32 mtu)
+ static void rt6_do_update_pmtu(struct rt6_info *rt, u32 mtu)
+ {
+ 	struct net *net = dev_net(rt->dst.dev);
+ 
+ 	rt->rt6i_flags |= RTF_MODIFIED;
+ 	rt->rt6i_pmtu = mtu;
+ 	rt6_update_expires(rt, net->ipv6.sysctl.ip6_rt_mtu_expires);
+ }
+ 
+ static void __ip6_rt_update_pmtu(struct dst_entry *dst, const struct sock *sk,
+ 				 const struct ipv6hdr *iph, u32 mtu)
  {
 -	struct rt6_info *rt6 = (struct rt6_info *)dst;
 +	struct rt6_info *rt6 = (struct rt6_info*)dst;
  
+ 	if (rt6->rt6i_flags & RTF_LOCAL)
+ 		return;
+ 
  	dst_confirm(dst);
- 	if (mtu < dst_mtu(dst) && (rt6->rt6i_flags & RTF_CACHE)) {
- 		struct net *net = dev_net(dst->dev);
+ 	mtu = max_t(u32, mtu, IPV6_MIN_MTU);
+ 	if (mtu >= dst_mtu(dst))
+ 		return;
  
- 		rt6->rt6i_flags |= RTF_MODIFIED;
- 		if (mtu < IPV6_MIN_MTU)
- 			mtu = IPV6_MIN_MTU;
+ 	if (rt6->rt6i_flags & RTF_CACHE) {
+ 		rt6_do_update_pmtu(rt6, mtu);
+ 	} else {
+ 		const struct in6_addr *daddr, *saddr;
+ 		struct rt6_info *nrt6;
  
++<<<<<<< HEAD
 +		dst_metric_set(dst, RTAX_MTU, mtu);
 +		rt6_update_expires(rt6, net->ipv6.sysctl.ip6_rt_mtu_expires);
++=======
+ 		if (iph) {
+ 			daddr = &iph->daddr;
+ 			saddr = &iph->saddr;
+ 		} else if (sk) {
+ 			daddr = &sk->sk_v6_daddr;
+ 			saddr = &inet6_sk(sk)->saddr;
+ 		} else {
+ 			return;
+ 		}
+ 		nrt6 = ip6_rt_cache_alloc(rt6, daddr, saddr);
+ 		if (nrt6) {
+ 			rt6_do_update_pmtu(nrt6, mtu);
+ 
+ 			/* ip6_ins_rt(nrt6) will bump the
+ 			 * rt6->rt6i_node->fn_sernum
+ 			 * which will fail the next rt6_check() and
+ 			 * invalidate the sk->sk_dst_cache.
+ 			 */
+ 			ip6_ins_rt(nrt6);
+ 		}
++>>>>>>> 45e4fd26683c (ipv6: Only create RTF_CACHE routes after encountering pmtu exception)
  	}
  }
  
* Unmerged path include/net/ip6_route.h
diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index 8695f0809e6d..368b9f7b93c7 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -750,6 +750,7 @@ static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,
 					rt6_clean_expires(iter);
 				else
 					rt6_set_expires(iter, rt->dst.expires);
+				iter->rt6i_pmtu = rt->rt6i_pmtu;
 				return -EEXIST;
 			}
 			/* If we have the same destination and the same metric,
* Unmerged path net/ipv6/route.c
