perf/x86: Remove warning for zero PEBS status

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Andi Kleen <ak@linux.intel.com>
commit 957ea1fdbcdb909e1540f06f06f1a9ce6e696efa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/957ea1fd.failed

The recent commit:

  75f80859b130 ("perf/x86/intel/pebs: Robustify PEBS buffer drain")

causes lots of warnings on different CPUs before Skylake
when running PEBS intensive workloads.

They can have a zero status field in the PEBS record when
PEBS is racing with clearing of GLOBAl_STATUS.

This also can cause hangs (it seems there are still
problems with printk in NMI).

Disable the warning, but still ignore the record.

	Signed-off-by: Andi Kleen <ak@linux.intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
Link: http://lkml.kernel.org/r/1449177740-5422-1-git-send-email-andi@firstfloor.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 957ea1fdbcdb909e1540f06f06f1a9ce6e696efa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/perf_event_intel_ds.c
diff --cc arch/x86/kernel/cpu/perf_event_intel_ds.c
index 4f06fbb202c7,0e3a9c73187d..000000000000
--- a/arch/x86/kernel/cpu/perf_event_intel_ds.c
+++ b/arch/x86/kernel/cpu/perf_event_intel_ds.c
@@@ -1151,13 -1216,25 +1151,16 @@@ static void intel_pmu_drain_pebs_nhm(st
  
  	for (at = base; at < top; at += x86_pmu.pebs_record_size) {
  		struct pebs_record_nhm *p = at;
 -		u64 pebs_status;
 -
 -		/* PEBS v3 has accurate status bits */
 -		if (x86_pmu.intel_cap.pebs_format >= 3) {
 -			for_each_set_bit(bit, (unsigned long *)&p->status,
 -					 MAX_PEBS_EVENTS)
 -				counts[bit]++;
 -
 -			continue;
 -		}
 -
 -		pebs_status = p->status & cpuc->pebs_enabled;
 -		pebs_status &= (1ULL << x86_pmu.max_pebs_events) - 1;
  
 -		bit = find_first_bit((unsigned long *)&pebs_status,
 +		bit = find_first_bit((unsigned long *)&p->status,
  					x86_pmu.max_pebs_events);
  		if (bit >= x86_pmu.max_pebs_events)
++<<<<<<< HEAD
 +			continue;
 +		if (!test_bit(bit, cpuc->active_mask))
++=======
++>>>>>>> 957ea1fdbcdb (perf/x86: Remove warning for zero PEBS status)
  			continue;
 -
  		/*
  		 * The PEBS hardware does not deal well with the situation
  		 * when events happen near to each other and multiple bits
* Unmerged path arch/x86/kernel/cpu/perf_event_intel_ds.c
