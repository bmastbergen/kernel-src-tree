KVM: x86: add a flag to disable KVM x2apic broadcast quirk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] kvm: add a flag to disable KVM x2apic broadcast quirk (Radim Krcmar) [1273718]
Rebuild_FUZZ: 95.50%
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit c519265f2aa348b2f1b9ecf8fbe20bb7c0fb102e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/c519265f.failed

Add KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK as a feature flag to
KVM_CAP_X2APIC_API.

The quirk made KVM interpret 0xff as a broadcast even in x2APIC mode.
The enableable capability is needed in order to support standard x2APIC and
remain backward compatible.

	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
[Expand kvm_apic_mda comment. - Paolo]
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit c519265f2aa348b2f1b9ecf8fbe20bb7c0fb102e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virtual/kvm/api.txt
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/lapic.c
#	arch/x86/kvm/x86.c
#	include/uapi/linux/kvm.h
diff --cc Documentation/virtual/kvm/api.txt
index d54a8098c59b,c4d2fb0e28de..000000000000
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@@ -3081,3 -3747,142 +3081,145 @@@ userspace from doing that
  If the hcall number specified is not one that has an in-kernel
  implementation, the KVM_ENABLE_CAP ioctl will fail with an EINVAL
  error.
++<<<<<<< HEAD
++=======
+ 
+ 7.2 KVM_CAP_S390_USER_SIGP
+ 
+ Architectures: s390
+ Parameters: none
+ 
+ This capability controls which SIGP orders will be handled completely in user
+ space. With this capability enabled, all fast orders will be handled completely
+ in the kernel:
+ - SENSE
+ - SENSE RUNNING
+ - EXTERNAL CALL
+ - EMERGENCY SIGNAL
+ - CONDITIONAL EMERGENCY SIGNAL
+ 
+ All other orders will be handled completely in user space.
+ 
+ Only privileged operation exceptions will be checked for in the kernel (or even
+ in the hardware prior to interception). If this capability is not enabled, the
+ old way of handling SIGP orders is used (partially in kernel and user space).
+ 
+ 7.3 KVM_CAP_S390_VECTOR_REGISTERS
+ 
+ Architectures: s390
+ Parameters: none
+ Returns: 0 on success, negative value on error
+ 
+ Allows use of the vector registers introduced with z13 processor, and
+ provides for the synchronization between host and user space.  Will
+ return -EINVAL if the machine does not support vectors.
+ 
+ 7.4 KVM_CAP_S390_USER_STSI
+ 
+ Architectures: s390
+ Parameters: none
+ 
+ This capability allows post-handlers for the STSI instruction. After
+ initial handling in the kernel, KVM exits to user space with
+ KVM_EXIT_S390_STSI to allow user space to insert further data.
+ 
+ Before exiting to userspace, kvm handlers should fill in s390_stsi field of
+ vcpu->run:
+ struct {
+ 	__u64 addr;
+ 	__u8 ar;
+ 	__u8 reserved;
+ 	__u8 fc;
+ 	__u8 sel1;
+ 	__u16 sel2;
+ } s390_stsi;
+ 
+ @addr - guest address of STSI SYSIB
+ @fc   - function code
+ @sel1 - selector 1
+ @sel2 - selector 2
+ @ar   - access register number
+ 
+ KVM handlers should exit to userspace with rc = -EREMOTE.
+ 
+ 7.5 KVM_CAP_SPLIT_IRQCHIP
+ 
+ Architectures: x86
+ Parameters: args[0] - number of routes reserved for userspace IOAPICs
+ Returns: 0 on success, -1 on error
+ 
+ Create a local apic for each processor in the kernel. This can be used
+ instead of KVM_CREATE_IRQCHIP if the userspace VMM wishes to emulate the
+ IOAPIC and PIC (and also the PIT, even though this has to be enabled
+ separately).
+ 
+ This capability also enables in kernel routing of interrupt requests;
+ when KVM_CAP_SPLIT_IRQCHIP only routes of KVM_IRQ_ROUTING_MSI type are
+ used in the IRQ routing table.  The first args[0] MSI routes are reserved
+ for the IOAPIC pins.  Whenever the LAPIC receives an EOI for these routes,
+ a KVM_EXIT_IOAPIC_EOI vmexit will be reported to userspace.
+ 
+ Fails if VCPU has already been created, or if the irqchip is already in the
+ kernel (i.e. KVM_CREATE_IRQCHIP has already been called).
+ 
+ 7.6 KVM_CAP_S390_RI
+ 
+ Architectures: s390
+ Parameters: none
+ 
+ Allows use of runtime-instrumentation introduced with zEC12 processor.
+ Will return -EINVAL if the machine does not support runtime-instrumentation.
+ Will return -EBUSY if a VCPU has already been created.
+ 
+ 7.7 KVM_CAP_X2APIC_API
+ 
+ Architectures: x86
+ Parameters: args[0] - features that should be enabled
+ Returns: 0 on success, -EINVAL when args[0] contains invalid features
+ 
+ Valid feature flags in args[0] are
+ 
+ #define KVM_X2APIC_API_USE_32BIT_IDS            (1ULL << 0)
+ #define KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK  (1ULL << 1)
+ 
+ Enabling KVM_X2APIC_API_USE_32BIT_IDS changes the behavior of
+ KVM_SET_GSI_ROUTING, KVM_SIGNAL_MSI, KVM_SET_LAPIC, and KVM_GET_LAPIC,
+ allowing the use of 32-bit APIC IDs.  See KVM_CAP_X2APIC_API in their
+ respective sections.
+ 
+ KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK must be enabled for x2APIC to work
+ in logical mode or with more than 255 VCPUs.  Otherwise, KVM treats 0xff
+ as a broadcast even in x2APIC mode in order to support physical x2APIC
+ without interrupt remapping.  This is undesirable in logical mode,
+ where 0xff represents CPUs 0-7 in cluster 0.
+ 
+ 
+ 8. Other capabilities.
+ ----------------------
+ 
+ This section lists capabilities that give information about other
+ features of the KVM implementation.
+ 
+ 8.1 KVM_CAP_PPC_HWRNG
+ 
+ Architectures: ppc
+ 
+ This capability, if KVM_CHECK_EXTENSION indicates that it is
+ available, means that that the kernel has an implementation of the
+ H_RANDOM hypercall backed by a hardware random-number generator.
+ If present, the kernel H_RANDOM handler can be enabled for guest use
+ with the KVM_CAP_PPC_ENABLE_HCALL capability.
+ 
+ 8.2 KVM_CAP_HYPERV_SYNIC
+ 
+ Architectures: x86
+ This capability, if KVM_CHECK_EXTENSION indicates that it is
+ available, means that that the kernel has an implementation of the
+ Hyper-V Synthetic interrupt controller(SynIC). Hyper-V SynIC is
+ used to support Windows Hyper-V based guest paravirt drivers(VMBus).
+ 
+ In order to use SynIC, it has to be activated by setting this
+ capability via KVM_ENABLE_CAP ioctl on the vcpu fd. Note that this
+ will disable the use of APIC hardware virtualization even if supported
+ by the CPU, as it's incompatible with SynIC auto-EOI behavior.
++>>>>>>> c519265f2aa3 (KVM: x86: add a flag to disable KVM x2apic broadcast quirk)
diff --cc arch/x86/include/asm/kvm_host.h
index 5d383a89c9d4,074b5c760327..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -657,6 -772,19 +657,22 @@@ struct kvm_arch 
  	u32 bsp_vcpu_id;
  
  	u64 disabled_quirks;
++<<<<<<< HEAD
++=======
+ 
+ 	bool irqchip_split;
+ 	u8 nr_reserved_ioapic_pins;
+ 
+ 	bool disabled_lapic_found;
+ 
+ 	/* Struct members for AVIC */
+ 	u32 ldr_mode;
+ 	struct page *avic_logical_id_table_page;
+ 	struct page *avic_physical_id_table_page;
+ 
+ 	bool x2apic_format;
+ 	bool x2apic_broadcast_quirk_disabled;
++>>>>>>> c519265f2aa3 (KVM: x86: add a flag to disable KVM x2apic broadcast quirk)
  };
  
  struct kvm_vm_stat {
diff --cc arch/x86/kvm/lapic.c
index 8b28377e3167,a16e0bb95d28..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -673,6 -674,123 +686,126 @@@ bool kvm_apic_match_dest(struct kvm_vcp
  		return false;
  	}
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL_GPL(kvm_apic_match_dest);
+ 
+ int kvm_vector_to_index(u32 vector, u32 dest_vcpus,
+ 		       const unsigned long *bitmap, u32 bitmap_size)
+ {
+ 	u32 mod;
+ 	int i, idx = -1;
+ 
+ 	mod = vector % dest_vcpus;
+ 
+ 	for (i = 0; i <= mod; i++) {
+ 		idx = find_next_bit(bitmap, bitmap_size, idx + 1);
+ 		BUG_ON(idx == bitmap_size);
+ 	}
+ 
+ 	return idx;
+ }
+ 
+ static void kvm_apic_disabled_lapic_found(struct kvm *kvm)
+ {
+ 	if (!kvm->arch.disabled_lapic_found) {
+ 		kvm->arch.disabled_lapic_found = true;
+ 		printk(KERN_INFO
+ 		       "Disabled LAPIC found during irq injection\n");
+ 	}
+ }
+ 
+ static bool kvm_apic_is_broadcast_dest(struct kvm *kvm, struct kvm_lapic **src,
+ 		struct kvm_lapic_irq *irq, struct kvm_apic_map *map)
+ {
+ 	if (kvm->arch.x2apic_broadcast_quirk_disabled) {
+ 		if ((irq->dest_id == APIC_BROADCAST &&
+ 				map->mode != KVM_APIC_MODE_X2APIC))
+ 			return true;
+ 		if (irq->dest_id == X2APIC_BROADCAST)
+ 			return true;
+ 	} else {
+ 		bool x2apic_ipi = src && *src && apic_x2apic_mode(*src);
+ 		if (irq->dest_id == (x2apic_ipi ?
+ 		                     X2APIC_BROADCAST : APIC_BROADCAST))
+ 			return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ /* Return true if the interrupt can be handled by using *bitmap as index mask
+  * for valid destinations in *dst array.
+  * Return false if kvm_apic_map_get_dest_lapic did nothing useful.
+  * Note: we may have zero kvm_lapic destinations when we return true, which
+  * means that the interrupt should be dropped.  In this case, *bitmap would be
+  * zero and *dst undefined.
+  */
+ static inline bool kvm_apic_map_get_dest_lapic(struct kvm *kvm,
+ 		struct kvm_lapic **src, struct kvm_lapic_irq *irq,
+ 		struct kvm_apic_map *map, struct kvm_lapic ***dst,
+ 		unsigned long *bitmap)
+ {
+ 	int i, lowest;
+ 
+ 	if (irq->shorthand == APIC_DEST_SELF && src) {
+ 		*dst = src;
+ 		*bitmap = 1;
+ 		return true;
+ 	} else if (irq->shorthand)
+ 		return false;
+ 
+ 	if (!map || kvm_apic_is_broadcast_dest(kvm, src, irq, map))
+ 		return false;
+ 
+ 	if (irq->dest_mode == APIC_DEST_PHYSICAL) {
+ 		if (irq->dest_id > map->max_apic_id) {
+ 			*bitmap = 0;
+ 		} else {
+ 			*dst = &map->phys_map[irq->dest_id];
+ 			*bitmap = 1;
+ 		}
+ 		return true;
+ 	}
+ 
+ 	*bitmap = 0;
+ 	if (!kvm_apic_map_get_logical_dest(map, irq->dest_id, dst,
+ 				(u16 *)bitmap))
+ 		return false;
+ 
+ 	if (!kvm_lowest_prio_delivery(irq))
+ 		return true;
+ 
+ 	if (!kvm_vector_hashing_enabled()) {
+ 		lowest = -1;
+ 		for_each_set_bit(i, bitmap, 16) {
+ 			if (!(*dst)[i])
+ 				continue;
+ 			if (lowest < 0)
+ 				lowest = i;
+ 			else if (kvm_apic_compare_prio((*dst)[i]->vcpu,
+ 						(*dst)[lowest]->vcpu) < 0)
+ 				lowest = i;
+ 		}
+ 	} else {
+ 		if (!*bitmap)
+ 			return true;
+ 
+ 		lowest = kvm_vector_to_index(irq->vector, hweight16(*bitmap),
+ 				bitmap, 16);
+ 
+ 		if (!(*dst)[lowest]) {
+ 			kvm_apic_disabled_lapic_found(kvm);
+ 			*bitmap = 0;
+ 			return true;
+ 		}
+ 	}
+ 
+ 	*bitmap = (lowest >= 0) ? 1 << lowest : 0;
+ 
+ 	return true;
+ }
++>>>>>>> c519265f2aa3 (KVM: x86: add a flag to disable KVM x2apic broadcast quirk)
  
  bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,
  		struct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)
diff --cc arch/x86/kvm/x86.c
index 733894b44f8d,f0d23622bc4e..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -89,8 -90,12 +89,14 @@@ static u64 __read_mostly efer_reserved_
  #define VM_STAT(x) offsetof(struct kvm, stat.x), KVM_STAT_VM
  #define VCPU_STAT(x) offsetof(struct kvm_vcpu, stat.x), KVM_STAT_VCPU
  
++<<<<<<< HEAD
++=======
+ #define KVM_X2APIC_API_VALID_FLAGS (KVM_X2APIC_API_USE_32BIT_IDS | \
+                                     KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK)
+ 
++>>>>>>> c519265f2aa3 (KVM: x86: add a flag to disable KVM x2apic broadcast quirk)
  static void update_cr8_intercept(struct kvm_vcpu *vcpu);
  static void process_nmi(struct kvm_vcpu *vcpu);
 -static void enter_smm(struct kvm_vcpu *vcpu);
  static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);
  
  struct kvm_x86_ops *kvm_x86_ops __read_mostly;
@@@ -3970,6 -3783,40 +3976,43 @@@ static int kvm_vm_ioctl_enable_cap(stru
  		kvm->arch.disabled_quirks = cap->args[0];
  		r = 0;
  		break;
++<<<<<<< HEAD
++=======
+ 	case KVM_CAP_SPLIT_IRQCHIP: {
+ 		mutex_lock(&kvm->lock);
+ 		r = -EINVAL;
+ 		if (cap->args[0] > MAX_NR_RESERVED_IOAPIC_PINS)
+ 			goto split_irqchip_unlock;
+ 		r = -EEXIST;
+ 		if (irqchip_in_kernel(kvm))
+ 			goto split_irqchip_unlock;
+ 		if (kvm->created_vcpus)
+ 			goto split_irqchip_unlock;
+ 		r = kvm_setup_empty_irq_routing(kvm);
+ 		if (r)
+ 			goto split_irqchip_unlock;
+ 		/* Pairs with irqchip_in_kernel. */
+ 		smp_wmb();
+ 		kvm->arch.irqchip_split = true;
+ 		kvm->arch.nr_reserved_ioapic_pins = cap->args[0];
+ 		r = 0;
+ split_irqchip_unlock:
+ 		mutex_unlock(&kvm->lock);
+ 		break;
+ 	}
+ 	case KVM_CAP_X2APIC_API:
+ 		r = -EINVAL;
+ 		if (cap->args[0] & ~KVM_X2APIC_API_VALID_FLAGS)
+ 			break;
+ 
+ 		if (cap->args[0] & KVM_X2APIC_API_USE_32BIT_IDS)
+ 			kvm->arch.x2apic_format = true;
+ 		if (cap->args[0] & KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK)
+ 			kvm->arch.x2apic_broadcast_quirk_disabled = true;
+ 
+ 		r = 0;
+ 		break;
++>>>>>>> c519265f2aa3 (KVM: x86: add a flag to disable KVM x2apic broadcast quirk)
  	default:
  		r = -EINVAL;
  		break;
diff --cc include/uapi/linux/kvm.h
index 39df9ac6ee22,4f8030e5b05d..000000000000
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@@ -1106,4 -1314,7 +1106,10 @@@ struct kvm_assigned_msix_entry 
  	__u16 padding[3];
  };
  
++<<<<<<< HEAD
++=======
+ #define KVM_X2APIC_API_USE_32BIT_IDS            (1ULL << 0)
+ #define KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK  (1ULL << 1)
+ 
++>>>>>>> c519265f2aa3 (KVM: x86: add a flag to disable KVM x2apic broadcast quirk)
  #endif /* __LINUX_KVM_H */
* Unmerged path Documentation/virtual/kvm/api.txt
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/lapic.c
* Unmerged path arch/x86/kvm/x86.c
* Unmerged path include/uapi/linux/kvm.h
