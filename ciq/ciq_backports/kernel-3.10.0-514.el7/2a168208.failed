hpsa: simplify check for device exposure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Kevin Barnett <kevin.barnett@pmcs.com>
commit 2a168208a35515b8ca54fbf1a17581ad2a852a3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2a168208.failed

remove macros and cleanup device exposure checking

	Reviewed-by: Scott Teel <scott.teel@pmcs.com>
	Reviewed-by: Justin Lindley <justin.lindley@pmcs.com>
	Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Don Brace <don.brace@pmcs.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 2a168208a35515b8ca54fbf1a17581ad2a852a3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.c
diff --cc drivers/scsi/hpsa.c
index e6b21f6ebf7d,77c14aeb43eb..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -732,6 -726,99 +732,102 @@@ static ssize_t host_show_hp_ssd_smart_p
  	return snprintf(buf, 20, "%d\n", offload_enabled);
  }
  
++<<<<<<< HEAD
++=======
+ #define MAX_PATHS 8
+ #define PATH_STRING_LEN 50
+ 
+ static ssize_t path_info_show(struct device *dev,
+ 	     struct device_attribute *attr, char *buf)
+ {
+ 	struct ctlr_info *h;
+ 	struct scsi_device *sdev;
+ 	struct hpsa_scsi_dev_t *hdev;
+ 	unsigned long flags;
+ 	int i;
+ 	int output_len = 0;
+ 	u8 box;
+ 	u8 bay;
+ 	u8 path_map_index = 0;
+ 	char *active;
+ 	unsigned char phys_connector[2];
+ 	unsigned char path[MAX_PATHS][PATH_STRING_LEN];
+ 
+ 	memset(path, 0, MAX_PATHS * PATH_STRING_LEN);
+ 	sdev = to_scsi_device(dev);
+ 	h = sdev_to_hba(sdev);
+ 	spin_lock_irqsave(&h->devlock, flags);
+ 	hdev = sdev->hostdata;
+ 	if (!hdev) {
+ 		spin_unlock_irqrestore(&h->devlock, flags);
+ 		return -ENODEV;
+ 	}
+ 
+ 	bay = hdev->bay;
+ 	for (i = 0; i < MAX_PATHS; i++) {
+ 		path_map_index = 1<<i;
+ 		if (i == hdev->active_path_index)
+ 			active = "Active";
+ 		else if (hdev->path_map & path_map_index)
+ 			active = "Inactive";
+ 		else
+ 			continue;
+ 
+ 		output_len = snprintf(path[i],
+ 				PATH_STRING_LEN, "[%d:%d:%d:%d] %20.20s ",
+ 				h->scsi_host->host_no,
+ 				hdev->bus, hdev->target, hdev->lun,
+ 				scsi_device_type(hdev->devtype));
+ 
+ 		if (is_ext_target(h, hdev) ||
+ 			(hdev->devtype == TYPE_RAID) ||
+ 			is_logical_dev_addr_mode(hdev->scsi3addr)) {
+ 			output_len += snprintf(path[i] + output_len,
+ 						PATH_STRING_LEN, "%s\n",
+ 						active);
+ 			continue;
+ 		}
+ 
+ 		box = hdev->box[i];
+ 		memcpy(&phys_connector, &hdev->phys_connector[i],
+ 			sizeof(phys_connector));
+ 		if (phys_connector[0] < '0')
+ 			phys_connector[0] = '0';
+ 		if (phys_connector[1] < '0')
+ 			phys_connector[1] = '0';
+ 		if (hdev->phys_connector[i] > 0)
+ 			output_len += snprintf(path[i] + output_len,
+ 				PATH_STRING_LEN,
+ 				"PORT: %.2s ",
+ 				phys_connector);
+ 		if (hdev->devtype == TYPE_DISK && hdev->expose_device) {
+ 			if (box == 0 || box == 0xFF) {
+ 				output_len += snprintf(path[i] + output_len,
+ 					PATH_STRING_LEN,
+ 					"BAY: %hhu %s\n",
+ 					bay, active);
+ 			} else {
+ 				output_len += snprintf(path[i] + output_len,
+ 					PATH_STRING_LEN,
+ 					"BOX: %hhu BAY: %hhu %s\n",
+ 					box, bay, active);
+ 			}
+ 		} else if (box != 0 && box != 0xFF) {
+ 			output_len += snprintf(path[i] + output_len,
+ 				PATH_STRING_LEN, "BOX: %hhu %s\n",
+ 				box, active);
+ 		} else
+ 			output_len += snprintf(path[i] + output_len,
+ 				PATH_STRING_LEN, "%s\n", active);
+ 	}
+ 
+ 	spin_unlock_irqrestore(&h->devlock, flags);
+ 	return snprintf(buf, output_len+1, "%s%s%s%s%s%s%s%s",
+ 		path[0], path[1], path[2], path[3],
+ 		path[4], path[5], path[6], path[7]);
+ }
+ 
++>>>>>>> 2a168208a355 (hpsa: simplify check for device exposure)
  static DEVICE_ATTR(raid_level, S_IRUGO, raid_level_show, NULL);
  static DEVICE_ATTR(lunid, S_IRUGO, lunid_show, NULL);
  static DEVICE_ATTR(unique_id, S_IRUGO, unique_id_show, NULL);
@@@ -1771,26 -1858,12 +1867,31 @@@ static int hpsa_slave_alloc(struct scsi
  	spin_lock_irqsave(&h->devlock, flags);
  	sd = lookup_hpsa_scsi_dev(h, sdev_channel(sdev),
  		sdev_id(sdev), sdev->lun);
 +
  	if (likely(sd)) {
  		atomic_set(&sd->ioaccel_cmds_out, 0);
++<<<<<<< HEAD
 +		sdev->hostdata = (sd->expose_state & HPSA_SCSI_ADD) ? sd : NULL;
 +		queue_depth = sd->queue_depth != 0 ?
 +			sd->queue_depth : sdev->host->can_queue;
 +	} else {
++=======
+ 		sdev->hostdata = sd->expose_device ? sd : NULL;
+ 	} else
++>>>>>>> 2a168208a355 (hpsa: simplify check for device exposure)
  		sdev->hostdata = NULL;
 +		queue_depth = sdev->host->can_queue;
 +	}
 +
 +	scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), queue_depth);
 +
 +	if (!shost_use_blk_mq(sdev->host)) {
 +		sdev->tagged_supported = 1;
 +		scsi_set_tag_type(sdev, MSG_SIMPLE_TAG);
 +		scsi_activate_tcq(sdev, queue_depth);
 +	}
  	spin_unlock_irqrestore(&h->devlock, flags);
 +
  	return 0;
  }
  
@@@ -1798,10 -1871,18 +1899,10 @@@
  static int hpsa_slave_configure(struct scsi_device *sdev)
  {
  	struct hpsa_scsi_dev_t *sd;
 -	int queue_depth;
  
  	sd = sdev->hostdata;
- 	sdev->no_uld_attach = !sd || !(sd->expose_state & HPSA_ULD_ATTACH);
+ 	sdev->no_uld_attach = !sd || !sd->expose_device;
  
 -	if (sd)
 -		queue_depth = sd->queue_depth != 0 ?
 -			sd->queue_depth : sdev->host->can_queue;
 -	else
 -		queue_depth = sdev->host->can_queue;
 -
 -	scsi_change_queue_depth(sdev, queue_depth);
  
  	return 0;
  }
@@@ -3794,15 -3860,10 +3895,22 @@@ static void hpsa_update_scsi_devices(st
  
  		/* do not expose masked devices */
  		if (MASKED_DEVICE(lunaddrbytes) &&
++<<<<<<< HEAD
 +			i < nphysicals + (raid_ctlr_position == 0)) {
 +			if (h->hba_mode_enabled)
 +				dev_warn(&h->pdev->dev,
 +					"Masked physical device detected\n");
 +			this_device->expose_state = HPSA_DO_NOT_EXPOSE;
 +		} else {
 +			this_device->expose_state =
 +					HPSA_SG_ATTACH | HPSA_ULD_ATTACH;
 +		}
++=======
+ 			i < nphysicals + (raid_ctlr_position == 0))
+ 			this_device->expose_device = 0;
+ 		else
+ 			this_device->expose_device = 1;
++>>>>>>> 2a168208a355 (hpsa: simplify check for device exposure)
  
  		switch (this_device->devtype) {
  		case TYPE_ROM:
* Unmerged path drivers/scsi/hpsa.c
diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 5dffb7026c33..c71ea0f19d5b 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -37,6 +37,7 @@ struct hpsa_scsi_dev_t {
 	unsigned int devtype;
 	int bus, target, lun;		/* as presented to the OS */
 	unsigned char scsi3addr[8];	/* as presented to the HW */
+	u8 expose_device;
 #define RAID_CTLR_LUNID "\0\0\0\0\0\0\0\0"
 	unsigned char device_id[16];    /* from inquiry pg. 0x83 */
 	unsigned char vendor[8];        /* bytes 8-15 of inquiry data */
@@ -70,11 +71,6 @@ struct hpsa_scsi_dev_t {
 	struct hpsa_scsi_dev_t *phys_disk[RAID_MAP_MAX_ENTRIES];
 	int nphysical_disks;
 	int supports_aborts;
-#define HPSA_DO_NOT_EXPOSE	0x0
-#define HPSA_SG_ATTACH		0x1
-#define HPSA_ULD_ATTACH		0x2
-#define HPSA_SCSI_ADD		(HPSA_SG_ATTACH | HPSA_ULD_ATTACH)
-	u8 expose_state;
 };
 
 struct reply_queue_buffer {
