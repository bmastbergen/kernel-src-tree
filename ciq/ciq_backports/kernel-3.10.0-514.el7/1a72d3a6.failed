crypto: qat - move isr files to qat common so that they can be reused

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [crypto] qat - move isr files to qat common so that they can be reused (Neil Horman) [1274179]
Rebuild_FUZZ: 93.85%
commit-author Tadeusz Struk <tadeusz.struk@intel.com>
commit 1a72d3a6d1d9a08705546eba14f0390c565ccd24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1a72d3a6.failed

Move qat_isr.c and qat_isrvf.c files to qat_common dir
so that they can be reused by all devices.
Remove adf_drv.h files because thay are not longer needed.
Move adf_dev_configure() function to qat_common so it can be reused.
Also some minor updates to common code for multidevice.

	Signed-off-by: Tadeusz Struk <tadeusz.struk@intel.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 1a72d3a6d1d9a08705546eba14f0390c565ccd24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/qat/qat_common/adf_accel_devices.h
#	drivers/crypto/qat/qat_common/adf_admin.c
#	drivers/crypto/qat/qat_common/adf_common_drv.h
#	drivers/crypto/qat/qat_common/adf_isr.c
#	drivers/crypto/qat/qat_common/adf_pf2vf_msg.c
#	drivers/crypto/qat/qat_dh895xcc/Makefile
#	drivers/crypto/qat/qat_dh895xcc/adf_dh895xcc_hw_data.c
#	drivers/crypto/qat/qat_dh895xcc/adf_dh895xcc_hw_data.h
#	drivers/crypto/qat/qat_dh895xcc/adf_drv.c
#	drivers/crypto/qat/qat_dh895xcc/adf_drv.h
#	drivers/crypto/qat/qat_dh895xcc/adf_hw_arbiter.c
diff --cc drivers/crypto/qat/qat_common/adf_accel_devices.h
index 91c969eb6e6b,4d78ec0ae879..000000000000
--- a/drivers/crypto/qat/qat_common/adf_accel_devices.h
+++ b/drivers/crypto/qat/qat_common/adf_accel_devices.h
@@@ -52,7 -53,22 +52,19 @@@
  #include "adf_cfg_common.h"
  
  #define ADF_DH895XCC_DEVICE_NAME "dh895xcc"
 -#define ADF_DH895XCCVF_DEVICE_NAME "dh895xccvf"
 -#define ADF_C62X_DEVICE_NAME "c62x"
 -#define ADF_C62XVF_DEVICE_NAME "c62xvf"
 -#define ADF_C3XXX_DEVICE_NAME "c3xxx"
 -#define ADF_C3XXXVF_DEVICE_NAME "c3xxxvf"
  #define ADF_DH895XCC_PCI_DEVICE_ID 0x435
++<<<<<<< HEAD
++=======
+ #define ADF_DH895XCCIOV_PCI_DEVICE_ID 0x443
+ #define ADF_C62X_PCI_DEVICE_ID 0x37c8
+ #define ADF_C62XIOV_PCI_DEVICE_ID 0x37c9
+ #define ADF_C3XXX_PCI_DEVICE_ID 0x19e2
+ #define ADF_C3XXXIOV_PCI_DEVICE_ID 0x19e3
+ #define ADF_ERRSOU3 (0x3A000 + 0x0C)
+ #define ADF_ERRSOU5 (0x3A000 + 0xD8)
+ #define ADF_DEVICE_FUSECTL_OFFSET 0x40
+ #define ADF_DEVICE_LEGFUSE_OFFSET 0x4C
++>>>>>>> 1a72d3a6d1d9 (crypto: qat - move isr files to qat common so that they can be reused)
  #define ADF_PCI_MAX_BARS 3
  #define ADF_DEVICE_NAME_LENGTH 32
  #define ADF_ETR_MAX_RINGS_PER_BANK 16
@@@ -148,13 -168,19 +160,14 @@@ struct adf_hw_device_data 
  	void (*enable_error_correction)(struct adf_accel_dev *accel_dev);
  	int (*init_admin_comms)(struct adf_accel_dev *accel_dev);
  	void (*exit_admin_comms)(struct adf_accel_dev *accel_dev);
 -	int (*send_admin_init)(struct adf_accel_dev *accel_dev);
  	int (*init_arb)(struct adf_accel_dev *accel_dev);
  	void (*exit_arb)(struct adf_accel_dev *accel_dev);
 -	void (*get_arb_mapping)(struct adf_accel_dev *accel_dev,
 -				const uint32_t **cfg);
 -	void (*disable_iov)(struct adf_accel_dev *accel_dev);
  	void (*enable_ints)(struct adf_accel_dev *accel_dev);
 -	int (*enable_vf2pf_comms)(struct adf_accel_dev *accel_dev);
  	const char *fw_name;
 -	const char *fw_mmp_name;
 +	uint32_t pci_dev_id;
  	uint32_t fuses;
  	uint32_t accel_capabilities_mask;
+ 	uint32_t instance_id;
  	uint16_t accel_mask;
  	uint16_t ae_mask;
  	uint16_t tx_rings_mask;
diff --cc drivers/crypto/qat/qat_common/adf_common_drv.h
index 3695dfa679f6,c03e2869c652..000000000000
--- a/drivers/crypto/qat/qat_common/adf_common_drv.h
+++ b/drivers/crypto/qat/qat_common/adf_common_drv.h
@@@ -53,6 -53,13 +53,16 @@@
  #include "icp_qat_fw_loader_handle.h"
  #include "icp_qat_hal.h"
  
++<<<<<<< HEAD
++=======
+ #define ADF_MAJOR_VERSION	0
+ #define ADF_MINOR_VERSION	6
+ #define ADF_BUILD_VERSION	0
+ #define ADF_DRV_VERSION		__stringify(ADF_MAJOR_VERSION) "." \
+ 				__stringify(ADF_MINOR_VERSION) "." \
+ 				__stringify(ADF_BUILD_VERSION)
+ 
++>>>>>>> 1a72d3a6d1d9 (crypto: qat - move isr files to qat common so that they can be reused)
  #define ADF_STATUS_RESTARTING 0
  #define ADF_STATUS_STARTING 1
  #define ADF_STATUS_CONFIGURED 2
@@@ -121,8 -143,15 +131,9 @@@ int adf_ae_stop(struct adf_accel_dev *a
  
  int adf_enable_aer(struct adf_accel_dev *accel_dev, struct pci_driver *adf);
  void adf_disable_aer(struct adf_accel_dev *accel_dev);
+ void adf_dev_restore(struct adf_accel_dev *accel_dev);
  int adf_init_aer(void);
  void adf_exit_aer(void);
 -int adf_init_admin_comms(struct adf_accel_dev *accel_dev);
 -void adf_exit_admin_comms(struct adf_accel_dev *accel_dev);
 -int adf_send_admin_init(struct adf_accel_dev *accel_dev);
 -int adf_init_arb(struct adf_accel_dev *accel_dev);
 -void adf_exit_arb(struct adf_accel_dev *accel_dev);
 -void adf_update_ring_arb(struct adf_etr_ring_data *ring);
  
  int adf_dev_get(struct adf_accel_dev *accel_dev);
  void adf_dev_put(struct adf_accel_dev *accel_dev);
@@@ -134,11 -164,17 +146,16 @@@ int qat_crypto_dev_config(struct adf_ac
  struct qat_crypto_instance *qat_crypto_get_instance_node(int node);
  void qat_crypto_put_instance(struct qat_crypto_instance *inst);
  void qat_alg_callback(void *resp);
 -void qat_alg_asym_callback(void *resp);
 +int qat_algs_init(void);
 +void qat_algs_exit(void);
  int qat_algs_register(void);
 -void qat_algs_unregister(void);
 -int qat_asym_algs_register(void);
 -void qat_asym_algs_unregister(void);
 +int qat_algs_unregister(void);
  
+ int adf_isr_resource_alloc(struct adf_accel_dev *accel_dev);
+ void adf_isr_resource_free(struct adf_accel_dev *accel_dev);
+ int adf_vf_isr_resource_alloc(struct adf_accel_dev *accel_dev);
+ void adf_vf_isr_resource_free(struct adf_accel_dev *accel_dev);
+ 
  int qat_hal_init(struct adf_accel_dev *accel_dev);
  void qat_hal_deinit(struct icp_qat_fw_loader_handle *handle);
  void qat_hal_start(struct icp_qat_fw_loader_handle *handle, unsigned char ae,
diff --cc drivers/crypto/qat/qat_common/adf_isr.c
index 0d03c109c2d3,b81f79acc4ea..000000000000
--- a/drivers/crypto/qat/qat_common/adf_isr.c
+++ b/drivers/crypto/qat/qat_common/adf_isr.c
@@@ -51,14 -51,13 +51,24 @@@
  #include <linux/slab.h>
  #include <linux/errno.h>
  #include <linux/interrupt.h>
++<<<<<<< HEAD:drivers/crypto/qat/qat_dh895xcc/adf_isr.c
 +#include <adf_accel_devices.h>
 +#include <adf_common_drv.h>
 +#include <adf_cfg.h>
 +#include <adf_cfg_strings.h>
 +#include <adf_cfg_common.h>
 +#include <adf_transport_access_macros.h>
 +#include <adf_transport_internal.h>
 +#include "adf_drv.h"
++=======
+ #include "adf_accel_devices.h"
+ #include "adf_common_drv.h"
+ #include "adf_cfg.h"
+ #include "adf_cfg_strings.h"
+ #include "adf_cfg_common.h"
+ #include "adf_transport_access_macros.h"
+ #include "adf_transport_internal.h"
++>>>>>>> 1a72d3a6d1d9 (crypto: qat - move isr files to qat common so that they can be reused):drivers/crypto/qat/qat_common/adf_isr.c
  
  static int adf_enable_msix(struct adf_accel_dev *accel_dev)
  {
@@@ -97,9 -104,60 +107,66 @@@ static irqreturn_t adf_msix_isr_ae(int 
  {
  	struct adf_accel_dev *accel_dev = dev_ptr;
  
++<<<<<<< HEAD:drivers/crypto/qat/qat_dh895xcc/adf_isr.c
 +	dev_info(&GET_DEV(accel_dev), "qat_dev%d spurious AE interrupt\n",
 +		 accel_dev->accel_id);
 +	return IRQ_HANDLED;
++=======
+ #ifdef CONFIG_PCI_IOV
+ 	/* If SR-IOV is enabled (vf_info is non-NULL), check for VF->PF ints */
+ 	if (accel_dev->pf.vf_info) {
+ 		struct adf_hw_device_data *hw_data = accel_dev->hw_device;
+ 		struct adf_bar *pmisc =
+ 			&GET_BARS(accel_dev)[hw_data->get_misc_bar_id(hw_data)];
+ 		void __iomem *pmisc_bar_addr = pmisc->virt_addr;
+ 		u32 vf_mask;
+ 
+ 		/* Get the interrupt sources triggered by VFs */
+ 		vf_mask = ((ADF_CSR_RD(pmisc_bar_addr, ADF_ERRSOU5) &
+ 			    0x0000FFFF) << 16) |
+ 			  ((ADF_CSR_RD(pmisc_bar_addr, ADF_ERRSOU3) &
+ 			    0x01FFFE00) >> 9);
+ 
+ 		if (vf_mask) {
+ 			struct adf_accel_vf_info *vf_info;
+ 			bool irq_handled = false;
+ 			int i;
+ 
+ 			/* Disable VF2PF interrupts for VFs with pending ints */
+ 			adf_disable_vf2pf_interrupts(accel_dev, vf_mask);
+ 
+ 			/*
+ 			 * Schedule tasklets to handle VF2PF interrupt BHs
+ 			 * unless the VF is malicious and is attempting to
+ 			 * flood the host OS with VF2PF interrupts.
+ 			 */
+ 			for_each_set_bit(i, (const unsigned long *)&vf_mask,
+ 					 (sizeof(vf_mask) * BITS_PER_BYTE)) {
+ 				vf_info = accel_dev->pf.vf_info + i;
+ 
+ 				if (!__ratelimit(&vf_info->vf2pf_ratelimit)) {
+ 					dev_info(&GET_DEV(accel_dev),
+ 						 "Too many ints from VF%d\n",
+ 						  vf_info->vf_nr + 1);
+ 					continue;
+ 				}
+ 
+ 				/* Tasklet will re-enable ints from this VF */
+ 				tasklet_hi_schedule(&vf_info->vf2pf_bh_tasklet);
+ 				irq_handled = true;
+ 			}
+ 
+ 			if (irq_handled)
+ 				return IRQ_HANDLED;
+ 		}
+ 	}
+ #endif /* CONFIG_PCI_IOV */
+ 
+ 	dev_dbg(&GET_DEV(accel_dev), "qat_dev%d spurious AE interrupt\n",
+ 		accel_dev->accel_id);
+ 
+ 	return IRQ_NONE;
++>>>>>>> 1a72d3a6d1d9 (crypto: qat - move isr files to qat common so that they can be reused):drivers/crypto/qat/qat_common/adf_isr.c
  }
  
  static int adf_request_irqs(struct adf_accel_dev *accel_dev)
diff --cc drivers/crypto/qat/qat_dh895xcc/Makefile
index 25171c557043,180a00ed7f89..000000000000
--- a/drivers/crypto/qat/qat_dh895xcc/Makefile
+++ b/drivers/crypto/qat/qat_dh895xcc/Makefile
@@@ -1,8 -1,3 +1,12 @@@
  ccflags-y := -I$(src)/../qat_common
  obj-$(CONFIG_CRYPTO_DEV_QAT_DH895xCC) += qat_dh895xcc.o
++<<<<<<< HEAD
 +qat_dh895xcc-objs := adf_drv.o \
 +		adf_isr.o \
 +		adf_dh895xcc_hw_data.o \
 +		adf_hw_arbiter.o \
 +		qat_admin.o \
 +		adf_admin.o
++=======
+ qat_dh895xcc-objs := adf_drv.o adf_dh895xcc_hw_data.o
++>>>>>>> 1a72d3a6d1d9 (crypto: qat - move isr files to qat common so that they can be reused)
diff --cc drivers/crypto/qat/qat_dh895xcc/adf_dh895xcc_hw_data.c
index 7093fc0fe8da,6e1d5e185526..000000000000
--- a/drivers/crypto/qat/qat_dh895xcc/adf_dh895xcc_hw_data.c
+++ b/drivers/crypto/qat/qat_dh895xcc/adf_dh895xcc_hw_data.c
@@@ -45,9 -45,9 +45,12 @@@
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
  #include <adf_accel_devices.h>
 -#include <adf_pf2vf_msg.h>
 -#include <adf_common_drv.h>
  #include "adf_dh895xcc_hw_data.h"
++<<<<<<< HEAD
 +#include "adf_common_drv.h"
 +#include "adf_drv.h"
++=======
++>>>>>>> 1a72d3a6d1d9 (crypto: qat - move isr files to qat common so that they can be reused)
  
  /* Worker thread to service arbiter mappings based on dev SKUs */
  static const uint32_t thrd_to_arb_map_sku4[] = {
diff --cc drivers/crypto/qat/qat_dh895xcc/adf_dh895xcc_hw_data.h
index 87fb1fadb4b2,72eacfd6654a..000000000000
--- a/drivers/crypto/qat/qat_dh895xcc/adf_dh895xcc_hw_data.h
+++ b/drivers/crypto/qat/qat_dh895xcc/adf_dh895xcc_hw_data.h
@@@ -80,10 -78,12 +78,21 @@@
  #define ADF_DH895XCC_CERRSSMSH(i) (i * 0x4000 + 0x10)
  #define ADF_DH895XCC_ERRSSMSH_EN BIT(3)
  
++<<<<<<< HEAD
 +/* Admin Messages Registers */
 +#define ADF_DH895XCC_ADMINMSGUR_OFFSET (0x3A000 + 0x574)
 +#define ADF_DH895XCC_ADMINMSGLR_OFFSET (0x3A000 + 0x578)
 +#define ADF_DH895XCC_MAILBOX_BASE_OFFSET 0x20970
 +#define ADF_DH895XCC_MAILBOX_STRIDE 0x1000
 +#define ADF_DH895XCC_FW "qat_895xcc.bin"
++=======
+ #define ADF_DH895XCC_PF2VF_OFFSET(i)	(0x3A000 + 0x280 + ((i) * 0x04))
+ #define ADF_DH895XCC_VINTMSK_OFFSET(i)	(0x3A000 + 0x200 + ((i) * 0x04))
+ /* FW names */
+ #define ADF_DH895XCC_FW "qat_895xcc.bin"
+ #define ADF_DH895XCC_MMP "qat_mmp.bin"
+ 
+ void adf_init_hw_data_dh895xcc(struct adf_hw_device_data *hw_data);
+ void adf_clean_hw_data_dh895xcc(struct adf_hw_device_data *hw_data);
++>>>>>>> 1a72d3a6d1d9 (crypto: qat - move isr files to qat common so that they can be reused)
  #endif
diff --cc drivers/crypto/qat/qat_dh895xcc/adf_drv.c
index c1b3f0b342e2,a8c4b92a7cbd..000000000000
--- a/drivers/crypto/qat/qat_dh895xcc/adf_drv.c
+++ b/drivers/crypto/qat/qat_dh895xcc/adf_drv.c
@@@ -80,11 -76,18 +76,11 @@@ static void adf_remove(struct pci_dev *
  
  static struct pci_driver adf_driver = {
  	.id_table = adf_pci_tbl,
- 	.name = adf_driver_name,
+ 	.name = ADF_DH895XCC_DEVICE_NAME,
  	.probe = adf_probe,
 -	.remove = adf_remove,
 -	.sriov_configure = adf_sriov_configure,
 +	.remove = adf_remove
  };
  
 -static void adf_cleanup_pci_dev(struct adf_accel_dev *accel_dev)
 -{
 -	pci_release_regions(accel_dev->accel_pci_dev.pci_dev);
 -	pci_disable_device(accel_dev->accel_pci_dev.pci_dev);
 -}
 -
  static void adf_cleanup_accel(struct adf_accel_dev *accel_dev)
  {
  	struct adf_accel_pci *accel_pci_dev = &accel_dev->accel_pci_dev;
@@@ -111,105 -112,10 +107,108 @@@
  	}
  	adf_cfg_dev_remove(accel_dev);
  	debugfs_remove(accel_dev->debugfs_dir);
 -	adf_devmgr_rm_dev(accel_dev, NULL);
 +	adf_devmgr_rm_dev(accel_dev);
 +	pci_release_regions(accel_pci_dev->pci_dev);
 +	pci_disable_device(accel_pci_dev->pci_dev);
 +	kfree(accel_dev);
  }
  
++<<<<<<< HEAD
 +static int adf_dev_configure(struct adf_accel_dev *accel_dev)
 +{
 +	int cpus = num_online_cpus();
 +	int banks = GET_MAX_BANKS(accel_dev);
 +	int instances = min(cpus, banks);
 +	char key[ADF_CFG_MAX_KEY_LEN_IN_BYTES];
 +	int i;
 +	unsigned long val;
 +
 +	if (adf_cfg_section_add(accel_dev, ADF_KERNEL_SEC))
 +		goto err;
 +	if (adf_cfg_section_add(accel_dev, "Accelerator0"))
 +		goto err;
 +	for (i = 0; i < instances; i++) {
 +		val = i;
 +		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_BANK_NUM, i);
 +		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
 +						key, (void *)&val, ADF_DEC))
 +			goto err;
 +
 +		snprintf(key, sizeof(key), ADF_CY "%d" ADF_ETRMGR_CORE_AFFINITY,
 +			 i);
 +		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
 +						key, (void *)&val, ADF_DEC))
 +			goto err;
 +
 +		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_ASYM_SIZE, i);
 +		val = 128;
 +		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
 +						key, (void *)&val, ADF_DEC))
 +			goto err;
 +
 +		val = 512;
 +		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_SYM_SIZE, i);
 +		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
 +						key, (void *)&val, ADF_DEC))
 +			goto err;
 +
 +		val = 0;
 +		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_ASYM_TX, i);
 +		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
 +						key, (void *)&val, ADF_DEC))
 +			goto err;
 +
 +		val = 2;
 +		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_SYM_TX, i);
 +		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
 +						key, (void *)&val, ADF_DEC))
 +			goto err;
 +
 +		val = 4;
 +		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_RND_TX, i);
 +		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
 +						key, (void *)&val, ADF_DEC))
 +			goto err;
 +
 +		val = 8;
 +		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_ASYM_RX, i);
 +		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
 +						key, (void *)&val, ADF_DEC))
 +			goto err;
 +
 +		val = 10;
 +		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_SYM_RX, i);
 +		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
 +						key, (void *)&val, ADF_DEC))
 +			goto err;
 +
 +		val = 12;
 +		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_RND_RX, i);
 +		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
 +						key, (void *)&val, ADF_DEC))
 +			goto err;
 +
 +		val = ADF_COALESCING_DEF_TIME;
 +		snprintf(key, sizeof(key), ADF_ETRMGR_COALESCE_TIMER_FORMAT, i);
 +		if (adf_cfg_add_key_value_param(accel_dev, "Accelerator0",
 +						key, (void *)&val, ADF_DEC))
 +			goto err;
 +	}
 +
 +	val = i;
 +	if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
 +					ADF_NUM_CY, (void *)&val, ADF_DEC))
 +		goto err;
 +
 +	set_bit(ADF_STATUS_CONFIGURED, &accel_dev->status);
 +	return 0;
 +err:
 +	dev_err(&GET_DEV(accel_dev), "Failed to start QAT accel dev\n");
 +	return -EINVAL;
 +}
 +
++=======
++>>>>>>> 1a72d3a6d1d9 (crypto: qat - move isr files to qat common so that they can be reused)
  static int adf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
  {
  	struct adf_accel_dev *accel_dev;
@@@ -260,16 -168,9 +259,16 @@@
  	}
  
  	accel_dev->hw_device = hw_data;
 -	adf_init_hw_data_dh895xcc(accel_dev->hw_device);
 +	switch (ent->device) {
 +	case ADF_DH895XCC_PCI_DEVICE_ID:
 +		adf_init_hw_data_dh895xcc(accel_dev->hw_device);
 +		break;
 +	default:
 +		return -ENODEV;
 +	}
 +	accel_pci_dev = &accel_dev->accel_pci_dev;
  	pci_read_config_byte(pdev, PCI_REVISION_ID, &accel_pci_dev->revid);
- 	pci_read_config_dword(pdev, ADF_DH895XCC_FUSECTL_OFFSET,
+ 	pci_read_config_dword(pdev, ADF_DEVICE_FUSECTL_OFFSET,
  			      &hw_data->fuses);
  
  	/* Get Accelerators and Accelerators Engines masks */
@@@ -320,9 -225,9 +319,9 @@@
  		pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));
  	}
  
- 	if (pci_request_regions(pdev, adf_driver_name)) {
+ 	if (pci_request_regions(pdev, ADF_DH895XCC_DEVICE_NAME)) {
  		ret = -EFAULT;
 -		goto out_err_disable;
 +		goto out_err;
  	}
  
  	/* Read accelerator capabilities mask */
@@@ -356,12 -263,12 +355,12 @@@
  	if (pci_save_state(pdev)) {
  		dev_err(&pdev->dev, "Failed to save pci state\n");
  		ret = -ENOMEM;
 -		goto out_err_free_reg;
 +		goto out_err;
  	}
  
- 	ret = adf_dev_configure(accel_dev);
+ 	ret = qat_crypto_dev_config(accel_dev);
  	if (ret)
 -		goto out_err_free_reg;
 +		goto out_err;
  
  	ret = adf_dev_init(accel_dev);
  	if (ret)
diff --cc drivers/crypto/qat/qat_dh895xcc/adf_hw_arbiter.c
index 1864bdb36f8f,f267d9e42e0b..000000000000
--- a/drivers/crypto/qat/qat_dh895xcc/adf_hw_arbiter.c
+++ b/drivers/crypto/qat/qat_dh895xcc/adf_hw_arbiter.c
@@@ -44,9 -44,9 +44,15 @@@
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
++<<<<<<< HEAD:drivers/crypto/qat/qat_dh895xcc/adf_hw_arbiter.c
 +#include <adf_accel_devices.h>
 +#include <adf_transport_internal.h>
 +#include "adf_drv.h"
++=======
+ #include "adf_accel_devices.h"
+ #include "adf_common_drv.h"
+ #include "adf_transport_internal.h"
++>>>>>>> 1a72d3a6d1d9 (crypto: qat - move isr files to qat common so that they can be reused):drivers/crypto/qat/qat_common/adf_hw_arbiter.c
  
  #define ADF_ARB_NUM 4
  #define ADF_ARB_REQ_RING_NUM 8
@@@ -123,8 -123,9 +129,12 @@@ int adf_init_arb(struct adf_accel_dev *
  
  	return 0;
  }
 -EXPORT_SYMBOL_GPL(adf_init_arb);
  
++<<<<<<< HEAD:drivers/crypto/qat/qat_dh895xcc/adf_hw_arbiter.c
 +void adf_update_ring_arb_enable(struct adf_etr_ring_data *ring)
++=======
+ void adf_update_ring_arb(struct adf_etr_ring_data *ring)
++>>>>>>> 1a72d3a6d1d9 (crypto: qat - move isr files to qat common so that they can be reused):drivers/crypto/qat/qat_common/adf_hw_arbiter.c
  {
  	WRITE_CSR_ARB_RINGSRVARBEN(ring->bank->csr_addr,
  				   ring->bank->bank_number,
* Unmerged path drivers/crypto/qat/qat_common/adf_admin.c
* Unmerged path drivers/crypto/qat/qat_common/adf_pf2vf_msg.c
* Unmerged path drivers/crypto/qat/qat_dh895xcc/adf_drv.h
diff --git a/drivers/crypto/qat/qat_common/Makefile b/drivers/crypto/qat/qat_common/Makefile
index e0424dc382fe..b80af8b5e534 100644
--- a/drivers/crypto/qat/qat_common/Makefile
+++ b/drivers/crypto/qat/qat_common/Makefile
@@ -1,5 +1,7 @@
 obj-$(CONFIG_CRYPTO_DEV_QAT) += intel_qat.o
 intel_qat-objs := adf_cfg.o \
+	adf_isr.o \
+	adf_vf_isr.o \
 	adf_ctl_drv.o \
 	adf_dev_mgr.o \
 	adf_init.o \
* Unmerged path drivers/crypto/qat/qat_common/adf_accel_devices.h
* Unmerged path drivers/crypto/qat/qat_common/adf_admin.c
diff --git a/drivers/crypto/qat/qat_common/adf_aer.c b/drivers/crypto/qat/qat_common/adf_aer.c
index 8d9ec1c7bed1..d7e58993242d 100644
--- a/drivers/crypto/qat/qat_common/adf_aer.c
+++ b/drivers/crypto/qat/qat_common/adf_aer.c
@@ -82,7 +82,7 @@ struct adf_reset_dev_data {
 	struct work_struct reset_work;
 };
 
-static void adf_dev_restore(struct adf_accel_dev *accel_dev)
+void adf_dev_restore(struct adf_accel_dev *accel_dev)
 {
 	struct pci_dev *pdev = accel_to_pci_dev(accel_dev);
 	struct pci_dev *parent = pdev->bus->self;
* Unmerged path drivers/crypto/qat/qat_common/adf_common_drv.h
diff --git a/drivers/crypto/qat/qat_common/adf_ctl_drv.c b/drivers/crypto/qat/qat_common/adf_ctl_drv.c
index 4ca0b2350316..8f567e86f3b9 100644
--- a/drivers/crypto/qat/qat_common/adf_ctl_drv.c
+++ b/drivers/crypto/qat/qat_common/adf_ctl_drv.c
@@ -198,7 +198,7 @@ static int adf_copy_key_value_data(struct adf_accel_dev *accel_dev,
 			goto out_err;
 		}
 
-		params_head = section_head->params;
+		params_head = section.params;
 
 		while (params_head) {
 			if (copy_from_user(&key_val, (void __user *)params_head,
@@ -342,12 +342,10 @@ static int adf_ctl_ioctl_dev_start(struct file *fp, unsigned int cmd,
 	if (ret)
 		return ret;
 
+	ret = -ENODEV;
 	accel_dev = adf_devmgr_get_dev_by_id(ctl_data->device_id);
-	if (!accel_dev) {
-		pr_err("QAT: Device %d not found\n", ctl_data->device_id);
-		ret = -ENODEV;
+	if (!accel_dev)
 		goto out;
-	}
 
 	if (!adf_dev_started(accel_dev)) {
 		dev_info(&GET_DEV(accel_dev),
diff --git a/drivers/crypto/qat/qat_common/adf_init.c b/drivers/crypto/qat/qat_common/adf_init.c
index 6b6a98ec5be4..2e3c2342aa8d 100644
--- a/drivers/crypto/qat/qat_common/adf_init.c
+++ b/drivers/crypto/qat/qat_common/adf_init.c
@@ -62,15 +62,6 @@ static void adf_service_add(struct service_hndl *service)
 	mutex_unlock(&service_lock);
 }
 
-/**
- * adf_service_register() - Register acceleration service in the accel framework
- * @service:    Pointer to the service
- *
- * Function adds the acceleration service to the acceleration framework.
- * To be used by QAT device specific drivers.
- *
- * Return: 0 on success, error code otherwise.
- */
 int adf_service_register(struct service_hndl *service)
 {
 	service->init_status = 0;
@@ -78,7 +69,6 @@ int adf_service_register(struct service_hndl *service)
 	adf_service_add(service);
 	return 0;
 }
-EXPORT_SYMBOL_GPL(adf_service_register);
 
 static void adf_service_remove(struct service_hndl *service)
 {
@@ -87,15 +77,6 @@ static void adf_service_remove(struct service_hndl *service)
 	mutex_unlock(&service_lock);
 }
 
-/**
- * adf_service_unregister() - Unregister acceleration service from the framework
- * @service:    Pointer to the service
- *
- * Function remove the acceleration service from the acceleration framework.
- * To be used by QAT device specific drivers.
- *
- * Return: 0 on success, error code otherwise.
- */
 int adf_service_unregister(struct service_hndl *service)
 {
 	if (service->init_status || service->start_status) {
@@ -105,7 +86,6 @@ int adf_service_unregister(struct service_hndl *service)
 	adf_service_remove(service);
 	return 0;
 }
-EXPORT_SYMBOL_GPL(adf_service_unregister);
 
 /**
  * adf_dev_init() - Init data structures and services for the given accel device
@@ -414,6 +394,7 @@ void adf_dev_shutdown(struct adf_accel_dev *accel_dev)
 		hw_data->exit_admin_comms(accel_dev);
 
 	adf_cleanup_etr_data(accel_dev);
+	adf_dev_restore(accel_dev);
 }
 EXPORT_SYMBOL_GPL(adf_dev_shutdown);
 
* Unmerged path drivers/crypto/qat/qat_common/adf_isr.c
* Unmerged path drivers/crypto/qat/qat_common/adf_pf2vf_msg.c
diff --git a/drivers/crypto/qat/qat_common/adf_transport.c b/drivers/crypto/qat/qat_common/adf_transport.c
index 0ae43763cc49..291850c2b922 100644
--- a/drivers/crypto/qat/qat_common/adf_transport.c
+++ b/drivers/crypto/qat/qat_common/adf_transport.c
@@ -122,7 +122,7 @@ int adf_send_message(struct adf_etr_ring_data *ring, uint32_t *msg)
 		return -EAGAIN;
 	}
 	spin_lock_bh(&ring->lock);
-	memcpy(ring->base_addr + ring->tail, msg,
+	memcpy((void *)((uintptr_t)ring->base_addr + ring->tail), msg,
 	       ADF_MSG_SIZE_TO_BYTES(ring->msg_size));
 
 	ring->tail = adf_modulo(ring->tail +
@@ -137,7 +137,7 @@ int adf_send_message(struct adf_etr_ring_data *ring, uint32_t *msg)
 static int adf_handle_response(struct adf_etr_ring_data *ring)
 {
 	uint32_t msg_counter = 0;
-	uint32_t *msg = (uint32_t *)(ring->base_addr + ring->head);
+	uint32_t *msg = (uint32_t *)((uintptr_t)ring->base_addr + ring->head);
 
 	while (*msg != ADF_RING_EMPTY_SIG) {
 		ring->callback((uint32_t *)msg);
@@ -146,7 +146,7 @@ static int adf_handle_response(struct adf_etr_ring_data *ring)
 					ADF_MSG_SIZE_TO_BYTES(ring->msg_size),
 					ADF_RING_SIZE_MODULO(ring->ring_size));
 		msg_counter++;
-		msg = (uint32_t *)(ring->base_addr + ring->head);
+		msg = (uint32_t *)((uintptr_t)ring->base_addr + ring->head);
 	}
 	if (msg_counter > 0) {
 		WRITE_CSR_RING_HEAD(ring->bank->csr_addr,
@@ -343,18 +343,7 @@ static void adf_ring_response_handler(struct adf_etr_bank_data *bank)
 	}
 }
 
-/**
- * adf_response_handler() - Bottom half handler response handler
- * @bank_addr:  Address of a ring bank for with the BH was scheduled.
- *
- * Function is the bottom half handler for the response from acceleration
- * device. There is one handler for every ring bank. Function checks all
- * communication rings in the bank.
- * To be used by QAT device specific drivers.
- *
- * Return: void
- */
-void adf_response_handler(unsigned long bank_addr)
+void adf_response_handler(uintptr_t bank_addr)
 {
 	struct adf_etr_bank_data *bank = (void *)bank_addr;
 
@@ -363,7 +352,6 @@ void adf_response_handler(unsigned long bank_addr)
 	WRITE_CSR_INT_FLAG_AND_COL(bank->csr_addr, bank->bank_number,
 				   bank->irq_mask);
 }
-EXPORT_SYMBOL_GPL(adf_response_handler);
 
 static inline int adf_get_cfg_int(struct adf_accel_dev *accel_dev,
 				  const char *section, const char *format,
diff --git a/drivers/crypto/qat/qat_common/adf_transport_internal.h b/drivers/crypto/qat/qat_common/adf_transport_internal.h
index a4869627fd57..bb883368ac01 100644
--- a/drivers/crypto/qat/qat_common/adf_transport_internal.h
+++ b/drivers/crypto/qat/qat_common/adf_transport_internal.h
@@ -91,7 +91,7 @@ struct adf_etr_data {
 	struct dentry *debug;
 };
 
-void adf_response_handler(unsigned long bank_addr);
+void adf_response_handler(uintptr_t bank_addr);
 #ifdef CONFIG_DEBUG_FS
 #include <linux/debugfs.h>
 int adf_bank_debugfs_add(struct adf_etr_bank_data *bank);
diff --git a/drivers/crypto/qat/qat_dh895xccvf/adf_isr.c b/drivers/crypto/qat/qat_common/adf_vf_isr.c
similarity index 82%
rename from drivers/crypto/qat/qat_dh895xccvf/adf_isr.c
rename to drivers/crypto/qat/qat_common/adf_vf_isr.c
index 87c5d8adb125..09427b3d4d55 100644
--- a/drivers/crypto/qat/qat_dh895xccvf/adf_isr.c
+++ b/drivers/crypto/qat/qat_common/adf_vf_isr.c
@@ -51,16 +51,18 @@
 #include <linux/slab.h>
 #include <linux/errno.h>
 #include <linux/interrupt.h>
-#include <adf_accel_devices.h>
-#include <adf_common_drv.h>
-#include <adf_cfg.h>
-#include <adf_cfg_strings.h>
-#include <adf_cfg_common.h>
-#include <adf_transport_access_macros.h>
-#include <adf_transport_internal.h>
-#include <adf_pf2vf_msg.h>
-#include "adf_drv.h"
-#include "adf_dh895xccvf_hw_data.h"
+#include "adf_accel_devices.h"
+#include "adf_common_drv.h"
+#include "adf_cfg.h"
+#include "adf_cfg_strings.h"
+#include "adf_cfg_common.h"
+#include "adf_transport_access_macros.h"
+#include "adf_transport_internal.h"
+#include "adf_pf2vf_msg.h"
+
+#define ADF_VINTSOU_OFFSET	0x204
+#define ADF_VINTSOU_BUN		BIT(0)
+#define ADF_VINTSOU_PF2VF	BIT(1)
 
 static int adf_enable_msi(struct adf_accel_dev *accel_dev)
 {
@@ -91,12 +93,14 @@ static void adf_disable_msi(struct adf_accel_dev *accel_dev)
 static void adf_pf2vf_bh_handler(void *data)
 {
 	struct adf_accel_dev *accel_dev = data;
-	void __iomem *pmisc_bar_addr =
-		(&GET_BARS(accel_dev)[ADF_DH895XCCIOV_PMISC_BAR])->virt_addr;
+	struct adf_hw_device_data *hw_data = accel_dev->hw_device;
+	struct adf_bar *pmisc =
+			&GET_BARS(accel_dev)[hw_data->get_misc_bar_id(hw_data)];
+	void __iomem *pmisc_bar_addr = pmisc->virt_addr;
 	u32 msg;
 
 	/* Read the message from PF */
-	msg = ADF_CSR_RD(pmisc_bar_addr, ADF_DH895XCCIOV_PF2VF_OFFSET);
+	msg = ADF_CSR_RD(pmisc_bar_addr, hw_data->get_pf2vf_offset(0));
 
 	if (!(msg & ADF_PF2VF_MSGORIGIN_SYSTEM))
 		/* Ignore legacy non-system (non-kernel) PF2VF messages */
@@ -124,8 +128,8 @@ static void adf_pf2vf_bh_handler(void *data)
 	}
 
 	/* To ack, clear the PF2VFINT bit */
-	msg &= ~ADF_DH895XCC_PF2VF_PF2VFINT;
-	ADF_CSR_WR(pmisc_bar_addr, ADF_DH895XCCIOV_PF2VF_OFFSET, msg);
+	msg &= ~BIT(0);
+	ADF_CSR_WR(pmisc_bar_addr, hw_data->get_pf2vf_offset(0), msg);
 
 	/* Re-enable PF2VF interrupts */
 	adf_enable_pf2vf_interrupts(accel_dev);
@@ -155,15 +159,17 @@ static void adf_cleanup_pf2vf_bh(struct adf_accel_dev *accel_dev)
 static irqreturn_t adf_isr(int irq, void *privdata)
 {
 	struct adf_accel_dev *accel_dev = privdata;
-	void __iomem *pmisc_bar_addr =
-		(&GET_BARS(accel_dev)[ADF_DH895XCCIOV_PMISC_BAR])->virt_addr;
+	struct adf_hw_device_data *hw_data = accel_dev->hw_device;
+	struct adf_bar *pmisc =
+			&GET_BARS(accel_dev)[hw_data->get_misc_bar_id(hw_data)];
+	void __iomem *pmisc_bar_addr = pmisc->virt_addr;
 	u32 v_int;
 
 	/* Read VF INT source CSR to determine the source of VF interrupt */
-	v_int = ADF_CSR_RD(pmisc_bar_addr, ADF_DH895XCCIOV_VINTSOU_OFFSET);
+	v_int = ADF_CSR_RD(pmisc_bar_addr, ADF_VINTSOU_OFFSET);
 
 	/* Check for PF2VF interrupt */
-	if (v_int & ADF_DH895XCC_VINTSOU_PF2VF) {
+	if (v_int & ADF_VINTSOU_PF2VF) {
 		/* Disable PF to VF interrupt */
 		adf_disable_pf2vf_interrupts(accel_dev);
 
@@ -173,7 +179,7 @@ static irqreturn_t adf_isr(int irq, void *privdata)
 	}
 
 	/* Check bundle interrupt */
-	if (v_int & ADF_DH895XCC_VINTSOU_BUN) {
+	if (v_int & ADF_VINTSOU_BUN) {
 		struct adf_etr_data *etr_data = accel_dev->transport;
 		struct adf_etr_bank_data *bank = &etr_data->banks[0];
 
@@ -226,6 +232,12 @@ static void adf_cleanup_bh(struct adf_accel_dev *accel_dev)
 	tasklet_kill(&priv_data->banks[0].resp_handler);
 }
 
+/**
+ * adf_vf_isr_resource_free() - Free IRQ for acceleration device
+ * @accel_dev:  Pointer to acceleration device.
+ *
+ * Function frees interrupts for acceleration device virtual function.
+ */
 void adf_vf_isr_resource_free(struct adf_accel_dev *accel_dev)
 {
 	struct pci_dev *pdev = accel_to_pci_dev(accel_dev);
@@ -236,7 +248,16 @@ void adf_vf_isr_resource_free(struct adf_accel_dev *accel_dev)
 	adf_cleanup_pf2vf_bh(accel_dev);
 	adf_disable_msi(accel_dev);
 }
-
+EXPORT_SYMBOL_GPL(adf_vf_isr_resource_free);
+
+/**
+ * adf_vf_isr_resource_alloc() - Allocate IRQ for acceleration device
+ * @accel_dev:  Pointer to acceleration device.
+ *
+ * Function allocates interrupts for acceleration device virtual function.
+ *
+ * Return: 0 on success, error code otherwise.
+ */
 int adf_vf_isr_resource_alloc(struct adf_accel_dev *accel_dev)
 {
 	if (adf_enable_msi(accel_dev))
@@ -256,3 +277,4 @@ err_out:
 	adf_vf_isr_resource_free(accel_dev);
 	return -EFAULT;
 }
+EXPORT_SYMBOL_GPL(adf_vf_isr_resource_alloc);
diff --git a/drivers/crypto/qat/qat_common/qat_crypto.c b/drivers/crypto/qat/qat_common/qat_crypto.c
index b73551e286c4..7ed80251e2fd 100644
--- a/drivers/crypto/qat/qat_common/qat_crypto.c
+++ b/drivers/crypto/qat/qat_common/qat_crypto.c
@@ -49,6 +49,7 @@
 #include "adf_accel_devices.h"
 #include "adf_common_drv.h"
 #include "adf_transport.h"
+#include "adf_transport_access_macros.h"
 #include "adf_cfg.h"
 #include "adf_cfg_strings.h"
 #include "qat_crypto.h"
@@ -158,6 +159,97 @@ struct qat_crypto_instance *qat_crypto_get_instance_node(int node)
 	return inst_best;
 }
 
+/**
+ * qat_crypto_dev_config() - create dev config required to create crypto inst.
+ *
+ * @accel_dev: Pointer to acceleration device.
+ *
+ * Function creates device configuration required to create crypto instances
+ *
+ * Return: 0 on success, error code otherwise.
+ */
+int qat_crypto_dev_config(struct adf_accel_dev *accel_dev)
+{
+	int cpus = num_online_cpus();
+	int banks = GET_MAX_BANKS(accel_dev);
+	int instances = min(cpus, banks);
+	char key[ADF_CFG_MAX_KEY_LEN_IN_BYTES];
+	int i;
+	unsigned long val;
+
+	if (adf_cfg_section_add(accel_dev, ADF_KERNEL_SEC))
+		goto err;
+	if (adf_cfg_section_add(accel_dev, "Accelerator0"))
+		goto err;
+	for (i = 0; i < instances; i++) {
+		val = i;
+		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_BANK_NUM, i);
+		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
+						key, (void *)&val, ADF_DEC))
+			goto err;
+
+		snprintf(key, sizeof(key), ADF_CY "%d" ADF_ETRMGR_CORE_AFFINITY,
+			 i);
+		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
+						key, (void *)&val, ADF_DEC))
+			goto err;
+
+		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_ASYM_SIZE, i);
+		val = 128;
+		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
+						key, (void *)&val, ADF_DEC))
+			goto err;
+
+		val = 512;
+		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_SYM_SIZE, i);
+		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
+						key, (void *)&val, ADF_DEC))
+			goto err;
+
+		val = 0;
+		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_ASYM_TX, i);
+		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
+						key, (void *)&val, ADF_DEC))
+			goto err;
+
+		val = 2;
+		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_SYM_TX, i);
+		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
+						key, (void *)&val, ADF_DEC))
+			goto err;
+
+		val = 8;
+		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_ASYM_RX, i);
+		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
+						key, (void *)&val, ADF_DEC))
+			goto err;
+
+		val = 10;
+		snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_SYM_RX, i);
+		if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
+						key, (void *)&val, ADF_DEC))
+			goto err;
+
+		val = ADF_COALESCING_DEF_TIME;
+		snprintf(key, sizeof(key), ADF_ETRMGR_COALESCE_TIMER_FORMAT, i);
+		if (adf_cfg_add_key_value_param(accel_dev, "Accelerator0",
+						key, (void *)&val, ADF_DEC))
+			goto err;
+	}
+
+	val = i;
+	if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
+					ADF_NUM_CY, (void *)&val, ADF_DEC))
+		goto err;
+
+	set_bit(ADF_STATUS_CONFIGURED, &accel_dev->status);
+	return 0;
+err:
+	dev_err(&GET_DEV(accel_dev), "Failed to start QAT accel dev\n");
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(qat_crypto_dev_config);
+
 static int qat_crypto_create_instances(struct adf_accel_dev *accel_dev)
 {
 	int i;
* Unmerged path drivers/crypto/qat/qat_dh895xcc/Makefile
* Unmerged path drivers/crypto/qat/qat_dh895xcc/adf_dh895xcc_hw_data.c
* Unmerged path drivers/crypto/qat/qat_dh895xcc/adf_dh895xcc_hw_data.h
* Unmerged path drivers/crypto/qat/qat_dh895xcc/adf_drv.c
* Unmerged path drivers/crypto/qat/qat_dh895xcc/adf_drv.h
* Unmerged path drivers/crypto/qat/qat_dh895xcc/adf_hw_arbiter.c
diff --git a/drivers/crypto/qat/qat_dh895xcc/adf_isr.c b/drivers/crypto/qat/qat_dh895xcc/adf_isr.c
deleted file mode 100644
index 0d03c109c2d3..000000000000
--- a/drivers/crypto/qat/qat_dh895xcc/adf_isr.c
+++ /dev/null
@@ -1,265 +0,0 @@
-/*
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-  Copyright(c) 2014 Intel Corporation.
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  qat-linux@intel.com
-
-  BSD LICENSE
-  Copyright(c) 2014 Intel Corporation.
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/pci.h>
-#include <linux/slab.h>
-#include <linux/errno.h>
-#include <linux/interrupt.h>
-#include <adf_accel_devices.h>
-#include <adf_common_drv.h>
-#include <adf_cfg.h>
-#include <adf_cfg_strings.h>
-#include <adf_cfg_common.h>
-#include <adf_transport_access_macros.h>
-#include <adf_transport_internal.h>
-#include "adf_drv.h"
-
-static int adf_enable_msix(struct adf_accel_dev *accel_dev)
-{
-	struct adf_accel_pci *pci_dev_info = &accel_dev->accel_pci_dev;
-	struct adf_hw_device_data *hw_data = accel_dev->hw_device;
-	uint32_t msix_num_entries = hw_data->num_banks + 1;
-	int i;
-
-	for (i = 0; i < msix_num_entries; i++)
-		pci_dev_info->msix_entries.entries[i].entry = i;
-
-	if (pci_enable_msix_exact(pci_dev_info->pci_dev,
-				  pci_dev_info->msix_entries.entries,
-				  msix_num_entries)) {
-		dev_err(&GET_DEV(accel_dev), "Failed to enable MSIX IRQ\n");
-		return -EFAULT;
-	}
-	return 0;
-}
-
-static void adf_disable_msix(struct adf_accel_pci *pci_dev_info)
-{
-	pci_disable_msix(pci_dev_info->pci_dev);
-}
-
-static irqreturn_t adf_msix_isr_bundle(int irq, void *bank_ptr)
-{
-	struct adf_etr_bank_data *bank = bank_ptr;
-
-	WRITE_CSR_INT_FLAG_AND_COL(bank->csr_addr, bank->bank_number, 0);
-	tasklet_hi_schedule(&bank->resp_handler);
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t adf_msix_isr_ae(int irq, void *dev_ptr)
-{
-	struct adf_accel_dev *accel_dev = dev_ptr;
-
-	dev_info(&GET_DEV(accel_dev), "qat_dev%d spurious AE interrupt\n",
-		 accel_dev->accel_id);
-	return IRQ_HANDLED;
-}
-
-static int adf_request_irqs(struct adf_accel_dev *accel_dev)
-{
-	struct adf_accel_pci *pci_dev_info = &accel_dev->accel_pci_dev;
-	struct adf_hw_device_data *hw_data = accel_dev->hw_device;
-	struct msix_entry *msixe = pci_dev_info->msix_entries.entries;
-	struct adf_etr_data *etr_data = accel_dev->transport;
-	int ret, i;
-	char *name;
-
-	/* Request msix irq for all banks */
-	for (i = 0; i < hw_data->num_banks; i++) {
-		struct adf_etr_bank_data *bank = &etr_data->banks[i];
-		unsigned int cpu, cpus = num_online_cpus();
-
-		name = *(pci_dev_info->msix_entries.names + i);
-		snprintf(name, ADF_MAX_MSIX_VECTOR_NAME,
-			 "qat%d-bundle%d", accel_dev->accel_id, i);
-		ret = request_irq(msixe[i].vector,
-				  adf_msix_isr_bundle, 0, name, bank);
-		if (ret) {
-			dev_err(&GET_DEV(accel_dev),
-				"failed to enable irq %d for %s\n",
-				msixe[i].vector, name);
-			return ret;
-		}
-
-		cpu = ((accel_dev->accel_id * hw_data->num_banks) + i) % cpus;
-		irq_set_affinity_hint(msixe[i].vector, get_cpu_mask(cpu));
-	}
-
-	/* Request msix irq for AE */
-	name = *(pci_dev_info->msix_entries.names + i);
-	snprintf(name, ADF_MAX_MSIX_VECTOR_NAME,
-		 "qat%d-ae-cluster", accel_dev->accel_id);
-	ret = request_irq(msixe[i].vector, adf_msix_isr_ae, 0, name, accel_dev);
-	if (ret) {
-		dev_err(&GET_DEV(accel_dev),
-			"failed to enable irq %d, for %s\n",
-			msixe[i].vector, name);
-		return ret;
-	}
-	return ret;
-}
-
-static void adf_free_irqs(struct adf_accel_dev *accel_dev)
-{
-	struct adf_accel_pci *pci_dev_info = &accel_dev->accel_pci_dev;
-	struct adf_hw_device_data *hw_data = accel_dev->hw_device;
-	struct msix_entry *msixe = pci_dev_info->msix_entries.entries;
-	struct adf_etr_data *etr_data = accel_dev->transport;
-	int i;
-
-	for (i = 0; i < hw_data->num_banks; i++) {
-		irq_set_affinity_hint(msixe[i].vector, NULL);
-		free_irq(msixe[i].vector, &etr_data->banks[i]);
-	}
-	irq_set_affinity_hint(msixe[i].vector, NULL);
-	free_irq(msixe[i].vector, accel_dev);
-}
-
-static int adf_isr_alloc_msix_entry_table(struct adf_accel_dev *accel_dev)
-{
-	int i;
-	char **names;
-	struct msix_entry *entries;
-	struct adf_hw_device_data *hw_data = accel_dev->hw_device;
-	uint32_t msix_num_entries = hw_data->num_banks + 1;
-
-	entries = kzalloc_node(msix_num_entries * sizeof(*entries),
-			       GFP_KERNEL, dev_to_node(&GET_DEV(accel_dev)));
-	if (!entries)
-		return -ENOMEM;
-
-	names = kcalloc(msix_num_entries, sizeof(char *), GFP_KERNEL);
-	if (!names) {
-		kfree(entries);
-		return -ENOMEM;
-	}
-	for (i = 0; i < msix_num_entries; i++) {
-		*(names + i) = kzalloc(ADF_MAX_MSIX_VECTOR_NAME, GFP_KERNEL);
-		if (!(*(names + i)))
-			goto err;
-	}
-	accel_dev->accel_pci_dev.msix_entries.entries = entries;
-	accel_dev->accel_pci_dev.msix_entries.names = names;
-	return 0;
-err:
-	for (i = 0; i < msix_num_entries; i++)
-		kfree(*(names + i));
-	kfree(entries);
-	kfree(names);
-	return -ENOMEM;
-}
-
-static void adf_isr_free_msix_entry_table(struct adf_accel_dev *accel_dev)
-{
-	struct adf_hw_device_data *hw_data = accel_dev->hw_device;
-	uint32_t msix_num_entries = hw_data->num_banks + 1;
-	char **names = accel_dev->accel_pci_dev.msix_entries.names;
-	int i;
-
-	kfree(accel_dev->accel_pci_dev.msix_entries.entries);
-	for (i = 0; i < msix_num_entries; i++)
-		kfree(*(names + i));
-	kfree(names);
-}
-
-static int adf_setup_bh(struct adf_accel_dev *accel_dev)
-{
-	struct adf_etr_data *priv_data = accel_dev->transport;
-	struct adf_hw_device_data *hw_data = accel_dev->hw_device;
-	int i;
-
-	for (i = 0; i < hw_data->num_banks; i++)
-		tasklet_init(&priv_data->banks[i].resp_handler,
-			     adf_response_handler,
-			     (unsigned long)&priv_data->banks[i]);
-	return 0;
-}
-
-static void adf_cleanup_bh(struct adf_accel_dev *accel_dev)
-{
-	struct adf_etr_data *priv_data = accel_dev->transport;
-	struct adf_hw_device_data *hw_data = accel_dev->hw_device;
-	int i;
-
-	for (i = 0; i < hw_data->num_banks; i++) {
-		tasklet_disable(&priv_data->banks[i].resp_handler);
-		tasklet_kill(&priv_data->banks[i].resp_handler);
-	}
-}
-
-void adf_isr_resource_free(struct adf_accel_dev *accel_dev)
-{
-	adf_free_irqs(accel_dev);
-	adf_cleanup_bh(accel_dev);
-	adf_disable_msix(&accel_dev->accel_pci_dev);
-	adf_isr_free_msix_entry_table(accel_dev);
-}
-
-int adf_isr_resource_alloc(struct adf_accel_dev *accel_dev)
-{
-	int ret;
-
-	ret = adf_isr_alloc_msix_entry_table(accel_dev);
-	if (ret)
-		return ret;
-	if (adf_enable_msix(accel_dev))
-		goto err_out;
-
-	if (adf_setup_bh(accel_dev))
-		goto err_out;
-
-	if (adf_request_irqs(accel_dev))
-		goto err_out;
-
-	return 0;
-err_out:
-	adf_isr_resource_free(accel_dev);
-	return -EFAULT;
-}
diff --git a/drivers/crypto/qat/qat_dh895xccvf/Makefile b/drivers/crypto/qat/qat_dh895xccvf/Makefile
index 85399fcbbad4..5c3ccf8267eb 100644
--- a/drivers/crypto/qat/qat_dh895xccvf/Makefile
+++ b/drivers/crypto/qat/qat_dh895xccvf/Makefile
@@ -1,5 +1,3 @@
 ccflags-y := -I$(src)/../qat_common
 obj-$(CONFIG_CRYPTO_DEV_QAT_DH895xCCVF) += qat_dh895xccvf.o
-qat_dh895xccvf-objs := adf_drv.o \
-		adf_isr.o \
-		adf_dh895xccvf_hw_data.o
+qat_dh895xccvf-objs := adf_drv.o adf_dh895xccvf_hw_data.o
diff --git a/drivers/crypto/qat/qat_dh895xccvf/adf_dh895xccvf_hw_data.c b/drivers/crypto/qat/qat_dh895xccvf/adf_dh895xccvf_hw_data.c
index a9a27eff41fb..dc04ab68d24d 100644
--- a/drivers/crypto/qat/qat_dh895xccvf/adf_dh895xccvf_hw_data.c
+++ b/drivers/crypto/qat/qat_dh895xccvf/adf_dh895xccvf_hw_data.c
@@ -48,7 +48,6 @@
 #include <adf_pf2vf_msg.h>
 #include <adf_common_drv.h>
 #include "adf_dh895xccvf_hw_data.h"
-#include "adf_drv.h"
 
 static struct adf_hw_device_class dh895xcciov_class = {
 	.name = ADF_DH895XCCVF_DEVICE_NAME,
@@ -136,7 +135,6 @@ static void adf_vf2pf_shutdown(struct adf_accel_dev *accel_dev)
 void adf_init_hw_data_dh895xcciov(struct adf_hw_device_data *hw_data)
 {
 	hw_data->dev_class = &dh895xcciov_class;
-	hw_data->instance_id = dh895xcciov_class.instances++;
 	hw_data->num_banks = ADF_DH895XCCIOV_ETR_MAX_BANKS;
 	hw_data->num_accel = ADF_DH895XCCIOV_MAX_ACCELERATORS;
 	hw_data->num_logical_accel = 1;
@@ -164,9 +162,12 @@ void adf_init_hw_data_dh895xcciov(struct adf_hw_device_data *hw_data)
 	hw_data->enable_ints = adf_vf_void_noop;
 	hw_data->enable_vf2pf_comms = adf_enable_vf2pf_comms;
 	hw_data->min_iov_compat_ver = ADF_PFVF_COMPATIBILITY_VERSION;
+	hw_data->dev_class->instances++;
+	adf_devmgr_update_class_index(hw_data);
 }
 
 void adf_clean_hw_data_dh895xcciov(struct adf_hw_device_data *hw_data)
 {
 	hw_data->dev_class->instances--;
+	adf_devmgr_update_class_index(hw_data);
 }
diff --git a/drivers/crypto/qat/qat_dh895xccvf/adf_dh895xccvf_hw_data.h b/drivers/crypto/qat/qat_dh895xccvf/adf_dh895xccvf_hw_data.h
index 8f6babfef629..6ddc19bd4410 100644
--- a/drivers/crypto/qat/qat_dh895xccvf/adf_dh895xccvf_hw_data.h
+++ b/drivers/crypto/qat/qat_dh895xccvf/adf_dh895xccvf_hw_data.h
@@ -56,13 +56,9 @@
 #define ADF_DH895XCCIOV_TX_RINGS_MASK 0xFF
 #define ADF_DH895XCCIOV_ETR_BAR 0
 #define ADF_DH895XCCIOV_ETR_MAX_BANKS 1
-
 #define ADF_DH895XCCIOV_PF2VF_OFFSET	0x200
-#define ADF_DH895XCC_PF2VF_PF2VFINT	BIT(0)
-
-#define ADF_DH895XCCIOV_VINTSOU_OFFSET	0x204
-#define ADF_DH895XCC_VINTSOU_BUN	BIT(0)
-#define ADF_DH895XCC_VINTSOU_PF2VF	BIT(1)
-
 #define ADF_DH895XCCIOV_VINTMSK_OFFSET	0x208
+
+void adf_init_hw_data_dh895xcciov(struct adf_hw_device_data *hw_data);
+void adf_clean_hw_data_dh895xcciov(struct adf_hw_device_data *hw_data);
 #endif
diff --git a/drivers/crypto/qat/qat_dh895xccvf/adf_drv.c b/drivers/crypto/qat/qat_dh895xccvf/adf_drv.c
index 789426f21882..a8d7ef0a7569 100644
--- a/drivers/crypto/qat/qat_dh895xccvf/adf_drv.c
+++ b/drivers/crypto/qat/qat_dh895xccvf/adf_drv.c
@@ -60,11 +60,7 @@
 #include <adf_accel_devices.h>
 #include <adf_common_drv.h>
 #include <adf_cfg.h>
-#include <adf_transport_access_macros.h>
 #include "adf_dh895xccvf_hw_data.h"
-#include "adf_drv.h"
-
-static const char adf_driver_name[] = ADF_DH895XCCVF_DEVICE_NAME;
 
 #define ADF_SYSTEM_DEVICE(device_id) \
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, device_id)}
@@ -80,7 +76,7 @@ static void adf_remove(struct pci_dev *dev);
 
 static struct pci_driver adf_driver = {
 	.id_table = adf_pci_tbl,
-	.name = adf_driver_name,
+	.name = ADF_DH895XCCVF_DEVICE_NAME,
 	.probe = adf_probe,
 	.remove = adf_remove,
 };
@@ -121,83 +117,6 @@ static void adf_cleanup_accel(struct adf_accel_dev *accel_dev)
 	adf_devmgr_rm_dev(accel_dev, pf);
 }
 
-static int adf_dev_configure(struct adf_accel_dev *accel_dev)
-{
-	char key[ADF_CFG_MAX_KEY_LEN_IN_BYTES];
-	unsigned long val, bank = 0;
-
-	if (adf_cfg_section_add(accel_dev, ADF_KERNEL_SEC))
-		goto err;
-	if (adf_cfg_section_add(accel_dev, "Accelerator0"))
-		goto err;
-
-	snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_BANK_NUM, 0);
-	if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC, key,
-					(void *)&bank, ADF_DEC))
-		goto err;
-
-	val = bank;
-	snprintf(key, sizeof(key), ADF_CY "%d" ADF_ETRMGR_CORE_AFFINITY, 0);
-	if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC, key,
-					(void *)&val, ADF_DEC))
-		goto err;
-
-	snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_ASYM_SIZE, 0);
-
-	val = 128;
-	if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC, key,
-					(void *)&val, ADF_DEC))
-		goto err;
-
-	val = 512;
-	snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_SYM_SIZE, 0);
-	if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
-					key, (void *)&val, ADF_DEC))
-		goto err;
-
-	val = 0;
-	snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_ASYM_TX, 0);
-	if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
-					key, (void *)&val, ADF_DEC))
-		goto err;
-
-	val = 2;
-	snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_SYM_TX, 0);
-	if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
-					key, (void *)&val, ADF_DEC))
-		goto err;
-
-	val = 8;
-	snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_ASYM_RX, 0);
-	if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
-					key, (void *)&val, ADF_DEC))
-		goto err;
-
-	val = 10;
-	snprintf(key, sizeof(key), ADF_CY "%d" ADF_RING_SYM_RX, 0);
-	if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
-					key, (void *)&val, ADF_DEC))
-			goto err;
-
-	val = ADF_COALESCING_DEF_TIME;
-	snprintf(key, sizeof(key), ADF_ETRMGR_COALESCE_TIMER_FORMAT,
-		 (int)bank);
-	if (adf_cfg_add_key_value_param(accel_dev, "Accelerator0",
-					key, (void *)&val, ADF_DEC))
-		goto err;
-
-	val = 1;
-	if (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,
-					ADF_NUM_CY, (void *)&val, ADF_DEC))
-		goto err;
-
-	set_bit(ADF_STATUS_CONFIGURED, &accel_dev->status);
-	return 0;
-err:
-	dev_err(&GET_DEV(accel_dev), "Failed to configure QAT accel dev\n");
-	return -EINVAL;
-}
-
 static int adf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	struct adf_accel_dev *accel_dev;
@@ -295,7 +214,7 @@ static int adf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));
 	}
 
-	if (pci_request_regions(pdev, adf_driver_name)) {
+	if (pci_request_regions(pdev, ADF_DH895XCCVF_DEVICE_NAME)) {
 		ret = -EFAULT;
 		goto out_err_disable;
 	}
@@ -322,7 +241,7 @@ static int adf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	/* Completion for VF2PF request/response message exchange */
 	init_completion(&accel_dev->vf.iov_msg_completion);
 
-	ret = adf_dev_configure(accel_dev);
+	ret = qat_crypto_dev_config(accel_dev);
 	if (ret)
 		goto out_err_free_reg;
 
diff --git a/drivers/crypto/qat/qat_dh895xccvf/adf_drv.h b/drivers/crypto/qat/qat_dh895xccvf/adf_drv.h
deleted file mode 100644
index e270e4a63d14..000000000000
--- a/drivers/crypto/qat/qat_dh895xccvf/adf_drv.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-  Copyright(c) 2014 Intel Corporation.
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  Contact Information:
-  qat-linux@intel.com
-
-  BSD LICENSE
-  Copyright(c) 2014 Intel Corporation.
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#ifndef ADF_DH895xVF_DRV_H_
-#define ADF_DH895xVF_DRV_H_
-#include <adf_accel_devices.h>
-#include <adf_transport.h>
-
-void adf_init_hw_data_dh895xcciov(struct adf_hw_device_data *hw_data);
-void adf_clean_hw_data_dh895xcciov(struct adf_hw_device_data *hw_data);
-int adf_vf_isr_resource_alloc(struct adf_accel_dev *accel_dev);
-void adf_vf_isr_resource_free(struct adf_accel_dev *accel_dev);
-void adf_update_ring_arb_enable(struct adf_etr_ring_data *ring);
-#endif
