drm/i915/gen9: minimum scanlines for Y tile is not always 4

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [drm] i915/gen9: minimum scanlines for Y tile is not always 4 (Lyude Paul) [1341633 1355776]
Rebuild_FUZZ: 96.49%
commit-author Paulo Zanoni <paulo.r.zanoni@intel.com>
commit 1186fa85eb9b3cc0589990fbc39617e50e38759a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1186fa85.failed

During watermarks calculations, this value is used in 3 different
places. Only one of them was not using a hardcoded 4. Move the code up
so everybody can benefit from the actual value.

This should only help on situations with Y tiling + 90/270 rotation +
1 or 2 bpp or NV12.

	Cc: stable@vger.kernel.org
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1474578035-424-6-git-send-email-paulo.r.zanoni@intel.com
(cherry picked from commit 1186fa85eb9b3cc0589990fbc39617e50e38759a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index b2b6b26d47bc,fbab3eae27b8..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -2748,8 -3494,9 +2748,14 @@@ static uint32_t skl_wm_method1(uint32_
  }
  
  static uint32_t skl_wm_method2(uint32_t pixel_rate, uint32_t pipe_htotal,
++<<<<<<< HEAD
 +			       uint32_t horiz_pixels, uint8_t bytes_per_pixel,
 +			       uint64_t tiling, uint32_t latency)
++=======
+ 			       uint32_t horiz_pixels, uint8_t cpp,
+ 			       uint64_t tiling, uint32_t latency,
+ 			       uint32_t y_min_scanlines)
++>>>>>>> 1186fa85eb9b (drm/i915/gen9: minimum scanlines for Y tile is not always 4)
  {
  	uint32_t ret;
  	uint32_t plane_bytes_per_line, plane_blocks_per_line;
@@@ -2762,9 -3509,11 +2768,15 @@@
  
  	if (tiling == I915_FORMAT_MOD_Y_TILED ||
  	    tiling == I915_FORMAT_MOD_Yf_TILED) {
- 		plane_bytes_per_line *= 4;
+ 		plane_bytes_per_line *= y_min_scanlines;
  		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);
++<<<<<<< HEAD
 +		plane_blocks_per_line /= 4;
++=======
+ 		plane_blocks_per_line /= y_min_scanlines;
+ 	} else if (tiling == DRM_FORMAT_MOD_NONE) {
+ 		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512) + 1;
++>>>>>>> 1186fa85eb9b (drm/i915/gen9: minimum scanlines for Y tile is not always 4)
  	} else {
  		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);
  	}
@@@ -2878,41 -3565,63 +2890,97 @@@ static bool skl_compute_plane_wm(const 
  	uint32_t plane_bytes_per_line, plane_blocks_per_line;
  	uint32_t res_blocks, res_lines;
  	uint32_t selected_result;
++<<<<<<< HEAD
++=======
+ 	uint8_t cpp;
+ 	uint32_t width = 0, height = 0;
+ 	uint32_t plane_pixel_rate;
+ 	uint32_t y_min_scanlines;
++>>>>>>> 1186fa85eb9b (drm/i915/gen9: minimum scanlines for Y tile is not always 4)
  
 -	if (latency == 0 || !cstate->base.active || !intel_pstate->base.visible) {
 -		*enabled = false;
 -		return 0;
 -	}
 +	if (latency == 0 || !p->active || !p_params->enabled)
 +		return false;
  
++<<<<<<< HEAD
 +	method1 = skl_wm_method1(p->pixel_rate,
 +				 p_params->bytes_per_pixel,
 +				 latency);
 +	method2 = skl_wm_method2(p->pixel_rate,
 +				 p->pipe_htotal,
 +				 p_params->horiz_pixels,
 +				 p_params->bytes_per_pixel,
 +				 p_params->tiling,
 +				 latency);
++=======
+ 	width = drm_rect_width(&intel_pstate->base.src) >> 16;
+ 	height = drm_rect_height(&intel_pstate->base.src) >> 16;
+ 
+ 	if (intel_rotation_90_or_270(pstate->rotation))
+ 		swap(width, height);
+ 
+ 	cpp = drm_format_plane_cpp(fb->pixel_format, 0);
+ 	plane_pixel_rate = skl_adjusted_plane_pixel_rate(cstate, intel_pstate);
+ 
+ 	if (intel_rotation_90_or_270(pstate->rotation)) {
+ 		int cpp = (fb->pixel_format == DRM_FORMAT_NV12) ?
+ 			drm_format_plane_cpp(fb->pixel_format, 1) :
+ 			drm_format_plane_cpp(fb->pixel_format, 0);
+ 
+ 		switch (cpp) {
+ 		case 1:
+ 			y_min_scanlines = 16;
+ 			break;
+ 		case 2:
+ 			y_min_scanlines = 8;
+ 			break;
+ 		default:
+ 			WARN(1, "Unsupported pixel depth for rotation");
+ 		case 4:
+ 			y_min_scanlines = 4;
+ 			break;
+ 		}
+ 	} else {
+ 		y_min_scanlines = 4;
+ 	}
+ 
+ 	method1 = skl_wm_method1(plane_pixel_rate, cpp, latency);
+ 	method2 = skl_wm_method2(plane_pixel_rate,
+ 				 cstate->base.adjusted_mode.crtc_htotal,
+ 				 width,
+ 				 cpp,
+ 				 fb->modifier[0],
+ 				 latency,
+ 				 y_min_scanlines);
++>>>>>>> 1186fa85eb9b (drm/i915/gen9: minimum scanlines for Y tile is not always 4)
  
 -	plane_bytes_per_line = width * cpp;
 +	plane_bytes_per_line = p_params->horiz_pixels *
 +					p_params->bytes_per_pixel;
  	plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);
  
++<<<<<<< HEAD
 +	if (p_params->tiling == I915_FORMAT_MOD_Y_TILED ||
 +	    p_params->tiling == I915_FORMAT_MOD_Yf_TILED) {
 +		uint32_t min_scanlines = 4;
 +		uint32_t y_tile_minimum;
 +		if (intel_rotation_90_or_270(p_params->rotation)) {
 +			switch (p_params->bytes_per_pixel) {
 +			case 1:
 +				min_scanlines = 16;
 +				break;
 +			case 2:
 +				min_scanlines = 8;
 +				break;
 +			case 8:
 +				WARN(1, "Unsupported pixel depth for rotation");
 +			}
 +		}
 +		y_tile_minimum = plane_blocks_per_line * min_scanlines;
++=======
+ 	if (fb->modifier[0] == I915_FORMAT_MOD_Y_TILED ||
+ 	    fb->modifier[0] == I915_FORMAT_MOD_Yf_TILED) {
+ 		uint32_t y_tile_minimum = plane_blocks_per_line *
+ 					  y_min_scanlines;
++>>>>>>> 1186fa85eb9b (drm/i915/gen9: minimum scanlines for Y tile is not always 4)
  		selected_result = max(method2, y_tile_minimum);
  	} else {
  		if ((ddb_allocation / plane_blocks_per_line) >= 1)
@@@ -2925,9 -3634,9 +2993,15 @@@
  	res_lines = DIV_ROUND_UP(selected_result, plane_blocks_per_line);
  
  	if (level >= 1 && level <= 7) {
++<<<<<<< HEAD
 +		if (p_params->tiling == I915_FORMAT_MOD_Y_TILED ||
 +		    p_params->tiling == I915_FORMAT_MOD_Yf_TILED)
 +			res_lines += 4;
++=======
+ 		if (fb->modifier[0] == I915_FORMAT_MOD_Y_TILED ||
+ 		    fb->modifier[0] == I915_FORMAT_MOD_Yf_TILED)
+ 			res_lines += y_min_scanlines;
++>>>>>>> 1186fa85eb9b (drm/i915/gen9: minimum scanlines for Y tile is not always 4)
  		else
  			res_blocks++;
  	}
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
