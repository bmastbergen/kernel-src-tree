perf tools: Support '<event>.*' dynamic sort key

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit 3b099bf5898ac1bf44d822f0bc15a7517e6fa117
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3b099bf5.failed

Support '*' character for field name to add all (non-common) fields as
sort keys easily.

  $ perf report -s 'switch.*' --stdio
  ...
  # Overhead    prev_comm  prev_pid   prev_prio  prev_state     next_comm  next_pid  next_prio
  # ........  ...........  .........  .........  ..........  ............  ........  .........
  #
       3.82%    swapper/0         0         120           0   netctl-auto     18711        120
       3.75%  netctl-auto     18711         120           1     swapper/0         0        120
       2.24%    swapper/1         0         120           0   netctl-auto     18709        120
       2.24%  netctl-auto     18709         120           1     swapper/1         0        120
       1.80%    swapper/2         0         120           0   rcu_preempt         7        120
       1.80%    swapper/2         0         120           0   netctl-auto     18711        120
       1.80%  rcu_preempt         7         120           1     swapper/2         0        120
       1.80%  netctl-auto     18711         120           1     swapper/2         0        120
  ...

Suggested-and-acked-by: Jiri Olsa <jolsa@redhat.com>
	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1450804030-29193-11-git-send-email-namhyung@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 3b099bf5898ac1bf44d822f0bc15a7517e6fa117)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/sort.c
diff --cc tools/perf/util/sort.c
index 7a0efdc373c2,f6aef15a651d..000000000000
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@@ -1749,12 -1828,108 +1749,115 @@@ __alloc_dynamic_entry(struct perf_evse
  	return hde;
  }
  
++<<<<<<< HEAD
++=======
+ static int parse_field_name(char *str, char **event, char **field, char **opt)
+ {
+ 	char *event_name, *field_name, *opt_name;
+ 
+ 	event_name = str;
+ 	field_name = strchr(str, '.');
+ 
+ 	if (field_name) {
+ 		*field_name++ = '\0';
+ 	} else {
+ 		event_name = NULL;
+ 		field_name = str;
+ 	}
+ 
+ 	opt_name = strchr(field_name, '/');
+ 	if (opt_name)
+ 		*opt_name++ = '\0';
+ 
+ 	*event = event_name;
+ 	*field = field_name;
+ 	*opt   = opt_name;
+ 
+ 	return 0;
+ }
+ 
+ /* find match evsel using a given event name.  The event name can be:
+  *   1. NULL - only valid for single event session
+  *   2. '%' + event index (e.g. '%1' for first event)
+  *   3. full event name (e.g. sched:sched_switch)
+  *   4. partial event name (should not contain ':')
+  */
+ static struct perf_evsel *find_evsel(struct perf_evlist *evlist, char *event_name)
+ {
+ 	struct perf_evsel *evsel = NULL;
+ 	struct perf_evsel *pos;
+ 	bool full_name;
+ 
+ 	/* case 1 */
+ 	if (event_name == NULL) {
+ 		if (evlist->nr_entries != 1) {
+ 			pr_debug("event name should be given\n");
+ 			return NULL;
+ 		}
+ 
+ 		return perf_evlist__first(evlist);
+ 	}
+ 
+ 	/* case 2 */
+ 	if (event_name[0] == '%') {
+ 		int nr = strtol(event_name+1, NULL, 0);
+ 
+ 		if (nr > evlist->nr_entries)
+ 			return NULL;
+ 
+ 		evsel = perf_evlist__first(evlist);
+ 		while (--nr > 0)
+ 			evsel = perf_evsel__next(evsel);
+ 
+ 		return evsel;
+ 	}
+ 
+ 	full_name = !!strchr(event_name, ':');
+ 	evlist__for_each(evlist, pos) {
+ 		/* case 3 */
+ 		if (full_name && !strcmp(pos->name, event_name))
+ 			return pos;
+ 		/* case 4 */
+ 		if (!full_name && strstr(pos->name, event_name)) {
+ 			if (evsel) {
+ 				pr_debug("'%s' event is ambiguous: it can be %s or %s\n",
+ 					 event_name, evsel->name, pos->name);
+ 				return NULL;
+ 			}
+ 			evsel = pos;
+ 		}
+ 	}
+ 
+ 	return evsel;
+ }
+ 
+ static int __dynamic_dimension__add(struct perf_evsel *evsel,
+ 				    struct format_field *field,
+ 				    bool raw_trace)
+ {
+ 	struct hpp_dynamic_entry *hde;
+ 
+ 	hde = __alloc_dynamic_entry(evsel, field);
+ 	if (hde == NULL)
+ 		return -ENOMEM;
+ 
+ 	hde->raw_trace = raw_trace;
+ 
+ 	perf_hpp__register_sort_field(&hde->hpp);
+ 	return 0;
+ }
+ 
++>>>>>>> 3b099bf5898a (perf tools: Support '<event>.*' dynamic sort key)
  static int add_dynamic_entry(struct perf_evlist *evlist, const char *tok)
  {
 -	char *str, *event_name, *field_name, *opt_name;
 -	struct perf_evsel *evsel;
 +	char *str, *event_name, *field_name;
 +	struct perf_evsel *evsel, *pos;
  	struct format_field *field;
++<<<<<<< HEAD
 +	struct hpp_dynamic_entry *hde;
++=======
+ 	bool raw_trace = symbol_conf.raw_trace;
++>>>>>>> 3b099bf5898a (perf tools: Support '<event>.*' dynamic sort key)
  	int ret = 0;
  
  	if (evlist == NULL)
@@@ -1792,21 -1966,26 +1895,34 @@@
  		goto out;
  	}
  
- 	field = pevent_find_any_field(evsel->tp_format, field_name);
- 	if (field == NULL) {
- 		pr_debug("Cannot find event field for %s.%s\n",
- 		       event_name, field_name);
- 		ret = -ENOENT;
- 		goto out;
- 	}
+ 	if (!strcmp(field_name, "*")) {
+ 		field = evsel->tp_format->format.fields;
  
++<<<<<<< HEAD
 +	hde = __alloc_dynamic_entry(evsel, field);
 +	if (hde == NULL) {
 +		ret = -ENOMEM;
 +		goto out;
 +	}
++=======
+ 		while (field) {
+ 			ret = __dynamic_dimension__add(evsel, field, raw_trace);
+ 			if (ret < 0)
+ 				goto out;
++>>>>>>> 3b099bf5898a (perf tools: Support '<event>.*' dynamic sort key)
+ 
+ 			field = field->next;
+ 		}
+ 	} else {
+ 		field = pevent_find_any_field(evsel->tp_format, field_name);
+ 		if (field == NULL) {
+ 			pr_debug("Cannot find event field for %s.%s\n",
+ 				 event_name, field_name);
+ 			return -ENOENT;
+ 		}
  
- 	perf_hpp__register_sort_field(&hde->hpp);
+ 		ret = __dynamic_dimension__add(evsel, field, raw_trace);
+ 	}
  
  out:
  	free(str);
* Unmerged path tools/perf/util/sort.c
