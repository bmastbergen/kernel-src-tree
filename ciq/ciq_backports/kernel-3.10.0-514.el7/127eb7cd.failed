lwt: Add cfg argument to build_state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] lwtunnel: Add cfg argument to build_state (Lance Richardson) [1283886]
Rebuild_FUZZ: 93.51%
commit-author Tom Herbert <tom@herbertland.com>
commit 127eb7cd3c210afead788991a30950a9e36759ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/127eb7cd.failed

Add cfg and family arguments to lwt build state functions. cfg is a void
pointer and will either be a pointer to a fib_config or fib6_config
structure. The family parameter indicates which one (either AF_INET
or AF_INET6).

LWT encpasulation implementation may use the fib configuration to build
the LWT state.

	Signed-off-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 127eb7cd3c210afead788991a30950a9e36759ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/lwtunnel.h
#	net/core/lwtunnel.c
#	net/ipv4/fib_semantics.c
#	net/ipv4/ip_tunnel_core.c
#	net/ipv6/ila.c
#	net/ipv6/route.c
#	net/mpls/mpls_iptunnel.c
diff --cc net/ipv4/fib_semantics.c
index 1938e2490ebe,1b2d01170a4d..000000000000
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@@ -474,6 -497,27 +474,30 @@@ static int fib_get_nhs(struct fib_info 
  			if (nexthop_nh->nh_tclassid)
  				fi->fib_net->ipv4.fib_num_tclassid_users++;
  #endif
++<<<<<<< HEAD
++=======
+ 			nla = nla_find(attrs, attrlen, RTA_ENCAP);
+ 			if (nla) {
+ 				struct lwtunnel_state *lwtstate;
+ 				struct net_device *dev = NULL;
+ 				struct nlattr *nla_entype;
+ 
+ 				nla_entype = nla_find(attrs, attrlen,
+ 						      RTA_ENCAP_TYPE);
+ 				if (!nla_entype)
+ 					goto err_inval;
+ 				if (cfg->fc_oif)
+ 					dev = __dev_get_by_index(net, cfg->fc_oif);
+ 				ret = lwtunnel_build_state(dev, nla_get_u16(
+ 							   nla_entype),
+ 							   nla,  AF_INET, cfg,
+ 							   &lwtstate);
+ 				if (ret)
+ 					goto errout;
+ 				nexthop_nh->nh_lwtstate =
+ 					lwtstate_get(lwtstate);
+ 			}
++>>>>>>> 127eb7cd3c21 (lwt: Add cfg argument to build_state)
  		}
  
  		rtnh = rtnh_next(rtnh, &remaining);
@@@ -484,8 -534,33 +508,35 @@@
  
  #endif
  
++<<<<<<< HEAD
++=======
+ static int fib_encap_match(struct net *net, u16 encap_type,
+ 			   struct nlattr *encap,
+ 			   int oif, const struct fib_nh *nh,
+ 			   const struct fib_config *cfg)
+ {
+ 	struct lwtunnel_state *lwtstate;
+ 	struct net_device *dev = NULL;
+ 	int ret, result = 0;
+ 
+ 	if (encap_type == LWTUNNEL_ENCAP_NONE)
+ 		return 0;
+ 
+ 	if (oif)
+ 		dev = __dev_get_by_index(net, oif);
+ 	ret = lwtunnel_build_state(dev, encap_type, encap,
+ 				   AF_INET, cfg, &lwtstate);
+ 	if (!ret) {
+ 		result = lwtunnel_cmp_encap(lwtstate, nh->nh_lwtstate);
+ 		lwtstate_free(lwtstate);
+ 	}
+ 
+ 	return result;
+ }
+ 
++>>>>>>> 127eb7cd3c21 (lwt: Add cfg argument to build_state)
  int fib_nh_match(struct fib_config *cfg, struct fib_info *fi)
  {
 -	struct net *net = cfg->fc_nlinfo.nl_net;
  #ifdef CONFIG_IP_ROUTE_MULTIPATH
  	struct rtnexthop *rtnh;
  	int remaining;
@@@ -495,6 -570,12 +546,15 @@@
  		return 1;
  
  	if (cfg->fc_oif || cfg->fc_gw) {
++<<<<<<< HEAD
++=======
+ 		if (cfg->fc_encap) {
+ 			if (fib_encap_match(net, cfg->fc_encap_type,
+ 					    cfg->fc_encap, cfg->fc_oif,
+ 					    fi->fib_nh, cfg))
+ 			    return 1;
+ 		}
++>>>>>>> 127eb7cd3c21 (lwt: Add cfg argument to build_state)
  		if ((!cfg->fc_oif || cfg->fc_oif == fi->fib_nh->nh_oif) &&
  		    (!cfg->fc_gw  || cfg->fc_gw == fi->fib_nh->nh_gw))
  			return 0;
@@@ -896,6 -998,22 +956,25 @@@ struct fib_info *fib_create_info(struc
  	} else {
  		struct fib_nh *nh = fi->fib_nh;
  
++<<<<<<< HEAD
++=======
+ 		if (cfg->fc_encap) {
+ 			struct lwtunnel_state *lwtstate;
+ 			struct net_device *dev = NULL;
+ 
+ 			if (cfg->fc_encap_type == LWTUNNEL_ENCAP_NONE)
+ 				goto err_inval;
+ 			if (cfg->fc_oif)
+ 				dev = __dev_get_by_index(net, cfg->fc_oif);
+ 			err = lwtunnel_build_state(dev, cfg->fc_encap_type,
+ 						   cfg->fc_encap, AF_INET, cfg,
+ 						   &lwtstate);
+ 			if (err)
+ 				goto failure;
+ 
+ 			nh->nh_lwtstate = lwtstate_get(lwtstate);
+ 		}
++>>>>>>> 127eb7cd3c21 (lwt: Add cfg argument to build_state)
  		nh->nh_oif = cfg->fc_oif;
  		nh->nh_gw = cfg->fc_gw;
  		nh->nh_flags = cfg->fc_flags;
diff --cc net/ipv4/ip_tunnel_core.c
index 010b54caceed,934f2ac8ad61..000000000000
--- a/net/ipv4/ip_tunnel_core.c
+++ b/net/ipv4/ip_tunnel_core.c
@@@ -188,3 -191,234 +188,237 @@@ struct rtnl_link_stats64 *ip_tunnel_get
  	return tot;
  }
  EXPORT_SYMBOL_GPL(ip_tunnel_get_stats64);
++<<<<<<< HEAD
++=======
+ 
+ static const struct nla_policy ip_tun_policy[LWTUNNEL_IP_MAX + 1] = {
+ 	[LWTUNNEL_IP_ID]	= { .type = NLA_U64 },
+ 	[LWTUNNEL_IP_DST]	= { .type = NLA_U32 },
+ 	[LWTUNNEL_IP_SRC]	= { .type = NLA_U32 },
+ 	[LWTUNNEL_IP_TTL]	= { .type = NLA_U8 },
+ 	[LWTUNNEL_IP_TOS]	= { .type = NLA_U8 },
+ 	[LWTUNNEL_IP_SPORT]	= { .type = NLA_U16 },
+ 	[LWTUNNEL_IP_DPORT]	= { .type = NLA_U16 },
+ 	[LWTUNNEL_IP_FLAGS]	= { .type = NLA_U16 },
+ };
+ 
+ static int ip_tun_build_state(struct net_device *dev, struct nlattr *attr,
+ 			      unsigned int family, const void *cfg,
+ 			      struct lwtunnel_state **ts)
+ {
+ 	struct ip_tunnel_info *tun_info;
+ 	struct lwtunnel_state *new_state;
+ 	struct nlattr *tb[LWTUNNEL_IP_MAX + 1];
+ 	int err;
+ 
+ 	err = nla_parse_nested(tb, LWTUNNEL_IP_MAX, attr, ip_tun_policy);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	new_state = lwtunnel_state_alloc(sizeof(*tun_info));
+ 	if (!new_state)
+ 		return -ENOMEM;
+ 
+ 	new_state->type = LWTUNNEL_ENCAP_IP;
+ 
+ 	tun_info = lwt_tun_info(new_state);
+ 
+ 	if (tb[LWTUNNEL_IP_ID])
+ 		tun_info->key.tun_id = nla_get_u64(tb[LWTUNNEL_IP_ID]);
+ 
+ 	if (tb[LWTUNNEL_IP_DST])
+ 		tun_info->key.u.ipv4.dst = nla_get_be32(tb[LWTUNNEL_IP_DST]);
+ 
+ 	if (tb[LWTUNNEL_IP_SRC])
+ 		tun_info->key.u.ipv4.src = nla_get_be32(tb[LWTUNNEL_IP_SRC]);
+ 
+ 	if (tb[LWTUNNEL_IP_TTL])
+ 		tun_info->key.ttl = nla_get_u8(tb[LWTUNNEL_IP_TTL]);
+ 
+ 	if (tb[LWTUNNEL_IP_TOS])
+ 		tun_info->key.tos = nla_get_u8(tb[LWTUNNEL_IP_TOS]);
+ 
+ 	if (tb[LWTUNNEL_IP_SPORT])
+ 		tun_info->key.tp_src = nla_get_be16(tb[LWTUNNEL_IP_SPORT]);
+ 
+ 	if (tb[LWTUNNEL_IP_DPORT])
+ 		tun_info->key.tp_dst = nla_get_be16(tb[LWTUNNEL_IP_DPORT]);
+ 
+ 	if (tb[LWTUNNEL_IP_FLAGS])
+ 		tun_info->key.tun_flags = nla_get_u16(tb[LWTUNNEL_IP_FLAGS]);
+ 
+ 	tun_info->mode = IP_TUNNEL_INFO_TX;
+ 	tun_info->options = NULL;
+ 	tun_info->options_len = 0;
+ 
+ 	*ts = new_state;
+ 
+ 	return 0;
+ }
+ 
+ static int ip_tun_fill_encap_info(struct sk_buff *skb,
+ 				  struct lwtunnel_state *lwtstate)
+ {
+ 	struct ip_tunnel_info *tun_info = lwt_tun_info(lwtstate);
+ 
+ 	if (nla_put_u64(skb, LWTUNNEL_IP_ID, tun_info->key.tun_id) ||
+ 	    nla_put_be32(skb, LWTUNNEL_IP_DST, tun_info->key.u.ipv4.dst) ||
+ 	    nla_put_be32(skb, LWTUNNEL_IP_SRC, tun_info->key.u.ipv4.src) ||
+ 	    nla_put_u8(skb, LWTUNNEL_IP_TOS, tun_info->key.tos) ||
+ 	    nla_put_u8(skb, LWTUNNEL_IP_TTL, tun_info->key.ttl) ||
+ 	    nla_put_u16(skb, LWTUNNEL_IP_SPORT, tun_info->key.tp_src) ||
+ 	    nla_put_u16(skb, LWTUNNEL_IP_DPORT, tun_info->key.tp_dst) ||
+ 	    nla_put_u16(skb, LWTUNNEL_IP_FLAGS, tun_info->key.tun_flags))
+ 		return -ENOMEM;
+ 
+ 	return 0;
+ }
+ 
+ static int ip_tun_encap_nlsize(struct lwtunnel_state *lwtstate)
+ {
+ 	return nla_total_size(8)	/* LWTUNNEL_IP_ID */
+ 		+ nla_total_size(4)	/* LWTUNNEL_IP_DST */
+ 		+ nla_total_size(4)	/* LWTUNNEL_IP_SRC */
+ 		+ nla_total_size(1)	/* LWTUNNEL_IP_TOS */
+ 		+ nla_total_size(1)	/* LWTUNNEL_IP_TTL */
+ 		+ nla_total_size(2)	/* LWTUNNEL_IP_SPORT */
+ 		+ nla_total_size(2)	/* LWTUNNEL_IP_DPORT */
+ 		+ nla_total_size(2);	/* LWTUNNEL_IP_FLAGS */
+ }
+ 
+ static int ip_tun_cmp_encap(struct lwtunnel_state *a, struct lwtunnel_state *b)
+ {
+ 	return memcmp(lwt_tun_info(a), lwt_tun_info(b),
+ 		      sizeof(struct ip_tunnel_info));
+ }
+ 
+ static const struct lwtunnel_encap_ops ip_tun_lwt_ops = {
+ 	.build_state = ip_tun_build_state,
+ 	.fill_encap = ip_tun_fill_encap_info,
+ 	.get_encap_size = ip_tun_encap_nlsize,
+ 	.cmp_encap = ip_tun_cmp_encap,
+ };
+ 
+ static const struct nla_policy ip6_tun_policy[LWTUNNEL_IP6_MAX + 1] = {
+ 	[LWTUNNEL_IP6_ID]		= { .type = NLA_U64 },
+ 	[LWTUNNEL_IP6_DST]		= { .len = sizeof(struct in6_addr) },
+ 	[LWTUNNEL_IP6_SRC]		= { .len = sizeof(struct in6_addr) },
+ 	[LWTUNNEL_IP6_HOPLIMIT]		= { .type = NLA_U8 },
+ 	[LWTUNNEL_IP6_TC]		= { .type = NLA_U8 },
+ 	[LWTUNNEL_IP6_SPORT]		= { .type = NLA_U16 },
+ 	[LWTUNNEL_IP6_DPORT]		= { .type = NLA_U16 },
+ 	[LWTUNNEL_IP6_FLAGS]		= { .type = NLA_U16 },
+ };
+ 
+ static int ip6_tun_build_state(struct net_device *dev, struct nlattr *attr,
+ 			       unsigned int family, const void *cfg,
+ 			       struct lwtunnel_state **ts)
+ {
+ 	struct ip_tunnel_info *tun_info;
+ 	struct lwtunnel_state *new_state;
+ 	struct nlattr *tb[LWTUNNEL_IP6_MAX + 1];
+ 	int err;
+ 
+ 	err = nla_parse_nested(tb, LWTUNNEL_IP6_MAX, attr, ip6_tun_policy);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	new_state = lwtunnel_state_alloc(sizeof(*tun_info));
+ 	if (!new_state)
+ 		return -ENOMEM;
+ 
+ 	new_state->type = LWTUNNEL_ENCAP_IP6;
+ 
+ 	tun_info = lwt_tun_info(new_state);
+ 
+ 	if (tb[LWTUNNEL_IP6_ID])
+ 		tun_info->key.tun_id = nla_get_u64(tb[LWTUNNEL_IP6_ID]);
+ 
+ 	if (tb[LWTUNNEL_IP6_DST])
+ 		tun_info->key.u.ipv6.dst = nla_get_in6_addr(tb[LWTUNNEL_IP6_DST]);
+ 
+ 	if (tb[LWTUNNEL_IP6_SRC])
+ 		tun_info->key.u.ipv6.src = nla_get_in6_addr(tb[LWTUNNEL_IP6_SRC]);
+ 
+ 	if (tb[LWTUNNEL_IP6_HOPLIMIT])
+ 		tun_info->key.ttl = nla_get_u8(tb[LWTUNNEL_IP6_HOPLIMIT]);
+ 
+ 	if (tb[LWTUNNEL_IP6_TC])
+ 		tun_info->key.tos = nla_get_u8(tb[LWTUNNEL_IP6_TC]);
+ 
+ 	if (tb[LWTUNNEL_IP6_SPORT])
+ 		tun_info->key.tp_src = nla_get_be16(tb[LWTUNNEL_IP6_SPORT]);
+ 
+ 	if (tb[LWTUNNEL_IP6_DPORT])
+ 		tun_info->key.tp_dst = nla_get_be16(tb[LWTUNNEL_IP6_DPORT]);
+ 
+ 	if (tb[LWTUNNEL_IP6_FLAGS])
+ 		tun_info->key.tun_flags = nla_get_u16(tb[LWTUNNEL_IP6_FLAGS]);
+ 
+ 	tun_info->mode = IP_TUNNEL_INFO_TX;
+ 	tun_info->options = NULL;
+ 	tun_info->options_len = 0;
+ 
+ 	*ts = new_state;
+ 
+ 	return 0;
+ }
+ 
+ static int ip6_tun_fill_encap_info(struct sk_buff *skb,
+ 				   struct lwtunnel_state *lwtstate)
+ {
+ 	struct ip_tunnel_info *tun_info = lwt_tun_info(lwtstate);
+ 
+ 	if (nla_put_u64(skb, LWTUNNEL_IP6_ID, tun_info->key.tun_id) ||
+ 	    nla_put_in6_addr(skb, LWTUNNEL_IP6_DST, &tun_info->key.u.ipv6.dst) ||
+ 	    nla_put_in6_addr(skb, LWTUNNEL_IP6_SRC, &tun_info->key.u.ipv6.src) ||
+ 	    nla_put_u8(skb, LWTUNNEL_IP6_HOPLIMIT, tun_info->key.tos) ||
+ 	    nla_put_u8(skb, LWTUNNEL_IP6_TC, tun_info->key.ttl) ||
+ 	    nla_put_u16(skb, LWTUNNEL_IP6_SPORT, tun_info->key.tp_src) ||
+ 	    nla_put_u16(skb, LWTUNNEL_IP6_DPORT, tun_info->key.tp_dst) ||
+ 	    nla_put_u16(skb, LWTUNNEL_IP6_FLAGS, tun_info->key.tun_flags))
+ 		return -ENOMEM;
+ 
+ 	return 0;
+ }
+ 
+ static int ip6_tun_encap_nlsize(struct lwtunnel_state *lwtstate)
+ {
+ 	return nla_total_size(8)	/* LWTUNNEL_IP6_ID */
+ 		+ nla_total_size(16)	/* LWTUNNEL_IP6_DST */
+ 		+ nla_total_size(16)	/* LWTUNNEL_IP6_SRC */
+ 		+ nla_total_size(1)	/* LWTUNNEL_IP6_HOPLIMIT */
+ 		+ nla_total_size(1)	/* LWTUNNEL_IP6_TC */
+ 		+ nla_total_size(2)	/* LWTUNNEL_IP6_SPORT */
+ 		+ nla_total_size(2)	/* LWTUNNEL_IP6_DPORT */
+ 		+ nla_total_size(2);	/* LWTUNNEL_IP6_FLAGS */
+ }
+ 
+ static const struct lwtunnel_encap_ops ip6_tun_lwt_ops = {
+ 	.build_state = ip6_tun_build_state,
+ 	.fill_encap = ip6_tun_fill_encap_info,
+ 	.get_encap_size = ip6_tun_encap_nlsize,
+ 	.cmp_encap = ip_tun_cmp_encap,
+ };
+ 
+ void __init ip_tunnel_core_init(void)
+ {
+ 	lwtunnel_encap_add_ops(&ip_tun_lwt_ops, LWTUNNEL_ENCAP_IP);
+ 	lwtunnel_encap_add_ops(&ip6_tun_lwt_ops, LWTUNNEL_ENCAP_IP6);
+ }
+ 
+ struct static_key ip_tunnel_metadata_cnt = STATIC_KEY_INIT_FALSE;
+ EXPORT_SYMBOL(ip_tunnel_metadata_cnt);
+ 
+ void ip_tunnel_need_metadata(void)
+ {
+ 	static_key_slow_inc(&ip_tunnel_metadata_cnt);
+ }
+ EXPORT_SYMBOL_GPL(ip_tunnel_need_metadata);
+ 
+ void ip_tunnel_unneed_metadata(void)
+ {
+ 	static_key_slow_dec(&ip_tunnel_metadata_cnt);
+ }
+ EXPORT_SYMBOL_GPL(ip_tunnel_unneed_metadata);
++>>>>>>> 127eb7cd3c21 (lwt: Add cfg argument to build_state)
diff --cc net/ipv6/route.c
index 637dad9bab3f,df3e353a012d..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -1611,12 -1815,29 +1611,34 @@@ int ip6_route_add(struct fib6_config *c
  
  	rt->dst.output = ip6_output;
  
++<<<<<<< HEAD
++=======
+ 	if (cfg->fc_encap) {
+ 		struct lwtunnel_state *lwtstate;
+ 
+ 		err = lwtunnel_build_state(dev, cfg->fc_encap_type,
+ 					   cfg->fc_encap, AF_INET6, cfg,
+ 					   &lwtstate);
+ 		if (err)
+ 			goto out;
+ 		rt->dst.lwtstate = lwtstate_get(lwtstate);
+ 		if (lwtunnel_output_redirect(rt->dst.lwtstate)) {
+ 			rt->dst.lwtstate->orig_output = rt->dst.output;
+ 			rt->dst.output = lwtunnel_output;
+ 		}
+ 		if (lwtunnel_input_redirect(rt->dst.lwtstate)) {
+ 			rt->dst.lwtstate->orig_input = rt->dst.input;
+ 			rt->dst.input = lwtunnel_input;
+ 		}
+ 	}
+ 
++>>>>>>> 127eb7cd3c21 (lwt: Add cfg argument to build_state)
  	ipv6_addr_prefix(&rt->rt6i_dst.addr, &cfg->fc_dst, cfg->fc_dst_len);
  	rt->rt6i_dst.plen = cfg->fc_dst_len;
 -	if (rt->rt6i_dst.plen == 128)
 +	if (rt->rt6i_dst.plen == 128) {
  		rt->dst.flags |= DST_HOST;
 +		dst_metrics_set_force_overwrite(&rt->dst);
 +	}
  
  #ifdef CONFIG_IPV6_SUBTREES
  	ipv6_addr_prefix(&rt->rt6i_src.addr, &cfg->fc_src, cfg->fc_src_len);
* Unmerged path include/net/lwtunnel.h
* Unmerged path net/core/lwtunnel.c
* Unmerged path net/ipv6/ila.c
* Unmerged path net/mpls/mpls_iptunnel.c
* Unmerged path include/net/lwtunnel.h
* Unmerged path net/core/lwtunnel.c
* Unmerged path net/ipv4/fib_semantics.c
* Unmerged path net/ipv4/ip_tunnel_core.c
* Unmerged path net/ipv6/ila.c
* Unmerged path net/ipv6/route.c
* Unmerged path net/mpls/mpls_iptunnel.c
