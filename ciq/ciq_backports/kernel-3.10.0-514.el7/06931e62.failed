sched/topology: Rename topology_thread_cpumask() to topology_sibling_cpumask()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bartosz Golaszewski <bgolaszewski@baylibre.com>
commit 06931e62246844c73fba24d7aeb4a5dc897a2739
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/06931e62.failed

Rename topology_thread_cpumask() to topology_sibling_cpumask()
for more consistency with scheduler code.

	Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
	Acked-by: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Benoit Cousson <bcousson@baylibre.com>
	Cc: Fenghua Yu <fenghua.yu@intel.com>
	Cc: Guenter Roeck <linux@roeck-us.net>
	Cc: Jean Delvare <jdelvare@suse.de>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Oleg Drokin <oleg.drokin@intel.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
	Cc: Russell King <linux@arm.linux.org.uk>
	Cc: Viresh Kumar <viresh.kumar@linaro.org>
Link: http://lkml.kernel.org/r/1432645896-12588-2-git-send-email-bgolaszewski@baylibre.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 06931e62246844c73fba24d7aeb4a5dc897a2739)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/topology.h
#	arch/ia64/include/asm/topology.h
#	arch/mips/include/asm/topology.h
#	arch/s390/include/asm/topology.h
#	arch/sparc/include/asm/topology_64.h
#	arch/tile/include/asm/topology.h
#	arch/x86/include/asm/topology.h
#	arch/x86/kernel/cpu/perf_event_intel.c
#	drivers/base/topology.c
#	drivers/staging/lustre/lustre/libcfs/linux/linux-cpu.c
#	drivers/staging/lustre/lustre/ptlrpc/service.c
diff --cc arch/ia64/include/asm/topology.h
index e1d484e9321f,3ad8f6988363..000000000000
--- a/arch/ia64/include/asm/topology.h
+++ b/arch/ia64/include/asm/topology.h
@@@ -77,8 -53,7 +77,12 @@@ void build_cpu_to_node_map(void)
  #define topology_physical_package_id(cpu)	(cpu_data(cpu)->socket_id)
  #define topology_core_id(cpu)			(cpu_data(cpu)->core_id)
  #define topology_core_cpumask(cpu)		(&cpu_core_map[cpu])
++<<<<<<< HEAD
 +#define topology_thread_cpumask(cpu)		(&per_cpu(cpu_sibling_map, cpu))
 +#define smt_capable() 				(smp_num_siblings > 1)
++=======
+ #define topology_sibling_cpumask(cpu)		(&per_cpu(cpu_sibling_map, cpu))
++>>>>>>> 06931e622468 (sched/topology: Rename topology_thread_cpumask() to topology_sibling_cpumask())
  #endif
  
  extern void arch_fix_phys_package_id(int num, u32 slot);
diff --cc arch/mips/include/asm/topology.h
index 12609a17dc8b,7afda4150a59..000000000000
--- a/arch/mips/include/asm/topology.h
+++ b/arch/mips/include/asm/topology.h
@@@ -9,9 -9,13 +9,16 @@@
  #define __ASM_TOPOLOGY_H
  
  #include <topology.h>
 -#include <linux/smp.h>
  
  #ifdef CONFIG_SMP
++<<<<<<< HEAD
 +#define smt_capable()	(smp_num_siblings > 1)
++=======
+ #define topology_physical_package_id(cpu)	(cpu_data[cpu].package)
+ #define topology_core_id(cpu)			(cpu_data[cpu].core)
+ #define topology_core_cpumask(cpu)		(&cpu_core_map[cpu])
+ #define topology_sibling_cpumask(cpu)		(&cpu_sibling_map[cpu])
++>>>>>>> 06931e622468 (sched/topology: Rename topology_thread_cpumask() to topology_sibling_cpumask())
  #endif
  
  #endif /* __ASM_TOPOLOGY_H */
diff --cc arch/s390/include/asm/topology.h
index 134c639719ca,4990f6c66288..000000000000
--- a/arch/s390/include/asm/topology.h
+++ b/arch/s390/include/asm/topology.h
@@@ -18,15 -18,16 +18,26 @@@ struct cpu_topology_s390 
  	cpumask_t book_mask;
  };
  
 -DECLARE_PER_CPU(struct cpu_topology_s390, cpu_topology);
 +extern struct cpu_topology_s390 cpu_topology[NR_CPUS];
  
++<<<<<<< HEAD
 +#define topology_physical_package_id(cpu)	(cpu_topology[cpu].socket_id)
 +#define topology_thread_id(cpu)			(cpu_topology[cpu].thread_id)
 +#define topology_thread_cpumask(cpu)		(&cpu_topology[cpu].thread_mask)
 +#define topology_core_id(cpu)			(cpu_topology[cpu].core_id)
 +#define topology_core_cpumask(cpu)		(&cpu_topology[cpu].core_mask)
 +#define topology_book_id(cpu)			(cpu_topology[cpu].book_id)
 +#define topology_book_cpumask(cpu)		(&cpu_topology[cpu].book_mask)
++=======
+ #define topology_physical_package_id(cpu) (per_cpu(cpu_topology, cpu).socket_id)
+ #define topology_thread_id(cpu)		  (per_cpu(cpu_topology, cpu).thread_id)
+ #define topology_sibling_cpumask(cpu) \
+ 		(&per_cpu(cpu_topology, cpu).thread_mask)
+ #define topology_core_id(cpu)		  (per_cpu(cpu_topology, cpu).core_id)
+ #define topology_core_cpumask(cpu)	  (&per_cpu(cpu_topology, cpu).core_mask)
+ #define topology_book_id(cpu)		  (per_cpu(cpu_topology, cpu).book_id)
+ #define topology_book_cpumask(cpu)	  (&per_cpu(cpu_topology, cpu).book_mask)
++>>>>>>> 06931e622468 (sched/topology: Rename topology_thread_cpumask() to topology_sibling_cpumask())
  
  #define mc_capable() 1
  
diff --cc arch/sparc/include/asm/topology_64.h
index 1754390a426f,9a928fcb7a9b..000000000000
--- a/arch/sparc/include/asm/topology_64.h
+++ b/arch/sparc/include/asm/topology_64.h
@@@ -41,9 -41,7 +41,13 @@@ static inline int pcibus_to_node(struc
  #define topology_physical_package_id(cpu)	(cpu_data(cpu).proc_id)
  #define topology_core_id(cpu)			(cpu_data(cpu).core_id)
  #define topology_core_cpumask(cpu)		(&cpu_core_map[cpu])
++<<<<<<< HEAD
 +#define topology_thread_cpumask(cpu)		(&per_cpu(cpu_sibling_map, cpu))
 +#define mc_capable()				(sparc64_multi_core)
 +#define smt_capable()				(sparc64_multi_core)
++=======
+ #define topology_sibling_cpumask(cpu)		(&per_cpu(cpu_sibling_map, cpu))
++>>>>>>> 06931e622468 (sched/topology: Rename topology_thread_cpumask() to topology_sibling_cpumask())
  #endif /* CONFIG_SMP */
  
  extern cpumask_t cpu_core_map[NR_CPUS];
diff --cc arch/tile/include/asm/topology.h
index d5e86c9f74fd,76b0d0ebb244..000000000000
--- a/arch/tile/include/asm/topology.h
+++ b/arch/tile/include/asm/topology.h
@@@ -88,10 -55,7 +88,14 @@@ static inline const struct cpumask *cpu
  #define topology_physical_package_id(cpu)       ((void)(cpu), 0)
  #define topology_core_id(cpu)                   (cpu)
  #define topology_core_cpumask(cpu)              ((void)(cpu), cpu_online_mask)
++<<<<<<< HEAD
 +#define topology_thread_cpumask(cpu)            cpumask_of(cpu)
 +
 +/* indicates that pointers to the topology struct cpumask maps are valid */
 +#define arch_provides_topology_pointers         yes
++=======
+ #define topology_sibling_cpumask(cpu)           cpumask_of(cpu)
++>>>>>>> 06931e622468 (sched/topology: Rename topology_thread_cpumask() to topology_sibling_cpumask())
  #endif
  
  #endif /* _ASM_TILE_TOPOLOGY_H */
diff --cc arch/x86/include/asm/topology.h
index be305348af96,5a77593fdace..000000000000
--- a/arch/x86/include/asm/topology.h
+++ b/arch/x86/include/asm/topology.h
@@@ -119,14 -119,12 +119,18 @@@ static inline void setup_node_to_cpumas
  
  extern const struct cpumask *cpu_coregroup_mask(int cpu);
  
 +#ifdef ENABLE_TOPO_DEFINES
  #define topology_physical_package_id(cpu)	(cpu_data(cpu).phys_proc_id)
  #define topology_core_id(cpu)			(cpu_data(cpu).cpu_core_id)
 -
 -#ifdef ENABLE_TOPO_DEFINES
  #define topology_core_cpumask(cpu)		(per_cpu(cpu_core_map, cpu))
++<<<<<<< HEAD
 +#define topology_thread_cpumask(cpu)		(per_cpu(cpu_sibling_map, cpu))
 +
 +/* indicates that pointers to the topology cpumask_t maps are valid */
 +#define arch_provides_topology_pointers		yes
++=======
+ #define topology_sibling_cpumask(cpu)		(per_cpu(cpu_sibling_map, cpu))
++>>>>>>> 06931e622468 (sched/topology: Rename topology_thread_cpumask() to topology_sibling_cpumask())
  #endif
  
  static inline void arch_fix_phys_package_id(int num, u32 slot)
diff --cc arch/x86/kernel/cpu/perf_event_intel.c
index 0f48998cfbb8,324817735771..000000000000
--- a/arch/x86/kernel/cpu/perf_event_intel.c
+++ b/arch/x86/kernel/cpu/perf_event_intel.c
@@@ -2870,7 -2639,9 +2870,13 @@@ static void intel_pmu_cpu_starting(int 
  		cpuc->lbr_sel = &cpuc->shared_regs->regs[EXTRA_REG_LBR];
  
  	if (x86_pmu.flags & PMU_FL_EXCL_CNTRS) {
++<<<<<<< HEAD
 +		for_each_cpu(i, topology_thread_cpumask(cpu)) {
++=======
+ 		int h = x86_pmu.num_counters >> 1;
+ 
+ 		for_each_cpu(i, topology_sibling_cpumask(cpu)) {
++>>>>>>> 06931e622468 (sched/topology: Rename topology_thread_cpumask() to topology_sibling_cpumask())
  			struct intel_excl_cntrs *c;
  
  			c = per_cpu(cpu_hw_events, i).excl_cntrs;
diff --cc drivers/base/topology.c
index 6209484360c8,8b7d7f8e5851..000000000000
--- a/drivers/base/topology.c
+++ b/drivers/base/topology.c
@@@ -30,89 -29,45 +30,95 @@@
  #include <linux/hardirq.h>
  #include <linux/topology.h>
  
 +#define define_one_ro_named(_name, _func)				\
 +	static DEVICE_ATTR(_name, 0444, _func, NULL)
 +
 +#define define_one_ro(_name)				\
 +	static DEVICE_ATTR(_name, 0444, show_##_name, NULL)
 +
  #define define_id_show_func(name)				\
 -static ssize_t name##_show(struct device *dev,			\
 +static ssize_t show_##name(struct device *dev,			\
  		struct device_attribute *attr, char *buf)	\
  {								\
 -	return sprintf(buf, "%d\n", topology_##name(dev->id));	\
 +	unsigned int cpu = dev->id;				\
 +	return sprintf(buf, "%d\n", topology_##name(cpu));	\
 +}
 +
 +#if defined(topology_thread_cpumask) || defined(topology_core_cpumask) || \
 +    defined(topology_book_cpumask)
 +static ssize_t show_cpumap(int type, const struct cpumask *mask, char *buf)
 +{
 +	ptrdiff_t len = PTR_ALIGN(buf + PAGE_SIZE - 1, PAGE_SIZE) - buf;
 +	int n = 0;
 +
 +	if (len > 1) {
 +		n = type?
 +			cpulist_scnprintf(buf, len-2, mask) :
 +			cpumask_scnprintf(buf, len-2, mask);
 +		buf[n++] = '\n';
 +		buf[n] = '\0';
 +	}
 +	return n;
 +}
 +#endif
 +
 +#ifdef arch_provides_topology_pointers
 +#define define_siblings_show_map(name)					\
 +static ssize_t show_##name(struct device *dev,				\
 +			   struct device_attribute *attr, char *buf)	\
 +{									\
 +	unsigned int cpu = dev->id;					\
 +	return show_cpumap(0, topology_##name(cpu), buf);		\
  }
  
 -#define define_siblings_show_map(name, mask)				\
 -static ssize_t name##_show(struct device *dev,				\
 +#define define_siblings_show_list(name)					\
 +static ssize_t show_##name##_list(struct device *dev,			\
 +				  struct device_attribute *attr,	\
 +				  char *buf)				\
 +{									\
 +	unsigned int cpu = dev->id;					\
 +	return show_cpumap(1, topology_##name(cpu), buf);		\
 +}
 +
 +#else
 +#define define_siblings_show_map(name)					\
 +static ssize_t show_##name(struct device *dev,				\
  			   struct device_attribute *attr, char *buf)	\
  {									\
 -	return cpumap_print_to_pagebuf(false, buf, topology_##mask(dev->id));\
 +	return show_cpumap(0, topology_##name(dev->id), buf);		\
  }
  
 -#define define_siblings_show_list(name, mask)				\
 -static ssize_t name##_list_show(struct device *dev,			\
 -				struct device_attribute *attr,		\
 -				char *buf)				\
 +#define define_siblings_show_list(name)					\
 +static ssize_t show_##name##_list(struct device *dev,			\
 +				  struct device_attribute *attr,	\
 +				  char *buf)				\
  {									\
 -	return cpumap_print_to_pagebuf(true, buf, topology_##mask(dev->id));\
 +	return show_cpumap(1, topology_##name(dev->id), buf);		\
  }
 +#endif
  
 -#define define_siblings_show_func(name, mask)	\
 -	define_siblings_show_map(name, mask);	\
 -	define_siblings_show_list(name, mask)
 +#define define_siblings_show_func(name)		\
 +	define_siblings_show_map(name); define_siblings_show_list(name)
  
  define_id_show_func(physical_package_id);
 -static DEVICE_ATTR_RO(physical_package_id);
 +define_one_ro(physical_package_id);
  
  define_id_show_func(core_id);
 -static DEVICE_ATTR_RO(core_id);
 +define_one_ro(core_id);
  
++<<<<<<< HEAD
 +define_siblings_show_func(thread_cpumask);
 +define_one_ro_named(thread_siblings, show_thread_cpumask);
 +define_one_ro_named(thread_siblings_list, show_thread_cpumask_list);
++=======
+ define_siblings_show_func(thread_siblings, sibling_cpumask);
+ static DEVICE_ATTR_RO(thread_siblings);
+ static DEVICE_ATTR_RO(thread_siblings_list);
++>>>>>>> 06931e622468 (sched/topology: Rename topology_thread_cpumask() to topology_sibling_cpumask())
  
 -define_siblings_show_func(core_siblings, core_cpumask);
 -static DEVICE_ATTR_RO(core_siblings);
 -static DEVICE_ATTR_RO(core_siblings_list);
 +define_siblings_show_func(core_cpumask);
 +define_one_ro_named(core_siblings, show_core_cpumask);
 +define_one_ro_named(core_siblings_list, show_core_cpumask_list);
  
  #ifdef CONFIG_SCHED_BOOK
  define_id_show_func(book_id);
* Unmerged path arch/arm64/include/asm/topology.h
* Unmerged path drivers/staging/lustre/lustre/libcfs/linux/linux-cpu.c
* Unmerged path drivers/staging/lustre/lustre/ptlrpc/service.c
diff --git a/Documentation/cputopology.txt b/Documentation/cputopology.txt
index 902d3151f527..076ecc9c47cd 100644
--- a/Documentation/cputopology.txt
+++ b/Documentation/cputopology.txt
@@ -44,7 +44,7 @@ these macros in include/asm-XXX/topology.h:
 #define topology_physical_package_id(cpu)
 #define topology_core_id(cpu)
 #define topology_book_id(cpu)
-#define topology_thread_cpumask(cpu)
+#define topology_sibling_cpumask(cpu)
 #define topology_core_cpumask(cpu)
 #define topology_book_cpumask(cpu)
 
diff --git a/arch/arm/include/asm/topology.h b/arch/arm/include/asm/topology.h
index 58b8b84adcd2..7fc3da71c83f 100644
--- a/arch/arm/include/asm/topology.h
+++ b/arch/arm/include/asm/topology.h
@@ -18,7 +18,7 @@ extern struct cputopo_arm cpu_topology[NR_CPUS];
 #define topology_physical_package_id(cpu)	(cpu_topology[cpu].socket_id)
 #define topology_core_id(cpu)		(cpu_topology[cpu].core_id)
 #define topology_core_cpumask(cpu)	(&cpu_topology[cpu].core_sibling)
-#define topology_thread_cpumask(cpu)	(&cpu_topology[cpu].thread_sibling)
+#define topology_sibling_cpumask(cpu)	(&cpu_topology[cpu].thread_sibling)
 
 #define mc_capable()	(cpu_topology[0].socket_id != -1)
 #define smt_capable()	(cpu_topology[0].thread_id != -1)
* Unmerged path arch/arm64/include/asm/topology.h
* Unmerged path arch/ia64/include/asm/topology.h
* Unmerged path arch/mips/include/asm/topology.h
diff --git a/arch/powerpc/include/asm/topology.h b/arch/powerpc/include/asm/topology.h
index 938ad4a4af55..2cf3dd30acf2 100644
--- a/arch/powerpc/include/asm/topology.h
+++ b/arch/powerpc/include/asm/topology.h
@@ -88,7 +88,7 @@ static inline int prrn_is_enabled(void)
 #include <asm/smp.h>
 
 #define topology_physical_package_id(cpu)	(cpu_to_chip_id(cpu))
-#define topology_thread_cpumask(cpu)	(per_cpu(cpu_sibling_map, cpu))
+#define topology_sibling_cpumask(cpu)	(per_cpu(cpu_sibling_map, cpu))
 #define topology_core_cpumask(cpu)	(per_cpu(cpu_core_map, cpu))
 #define topology_core_id(cpu)		(cpu_to_core_id(cpu))
 #endif
diff --git a/arch/powerpc/mm/tlb_nohash.c b/arch/powerpc/mm/tlb_nohash.c
index 41cd68dee681..5e4bab344b7b 100644
--- a/arch/powerpc/mm/tlb_nohash.c
+++ b/arch/powerpc/mm/tlb_nohash.c
@@ -203,7 +203,7 @@ static DEFINE_RAW_SPINLOCK(tlbivax_lock);
 static int mm_is_core_local(struct mm_struct *mm)
 {
 	return cpumask_subset(mm_cpumask(mm),
-			      topology_thread_cpumask(smp_processor_id()));
+			      topology_sibling_cpumask(smp_processor_id()));
 }
 
 struct tlb_flush_param {
* Unmerged path arch/s390/include/asm/topology.h
* Unmerged path arch/sparc/include/asm/topology_64.h
* Unmerged path arch/tile/include/asm/topology.h
* Unmerged path arch/x86/include/asm/topology.h
* Unmerged path arch/x86/kernel/cpu/perf_event_intel.c
diff --git a/block/blk-mq-cpumap.c b/block/blk-mq-cpumap.c
index 0689ad00d36c..d0634bcf322f 100644
--- a/block/blk-mq-cpumap.c
+++ b/block/blk-mq-cpumap.c
@@ -24,7 +24,7 @@ static int get_first_sibling(unsigned int cpu)
 {
 	unsigned int ret;
 
-	ret = cpumask_first(topology_thread_cpumask(cpu));
+	ret = cpumask_first(topology_sibling_cpumask(cpu));
 	if (ret < nr_cpu_ids)
 		return ret;
 
diff --git a/drivers/acpi/acpi_pad.c b/drivers/acpi/acpi_pad.c
index eda9c01b8136..54c0c178d2da 100644
--- a/drivers/acpi/acpi_pad.c
+++ b/drivers/acpi/acpi_pad.c
@@ -111,7 +111,7 @@ static void round_robin_cpu(unsigned int tsk_index)
 	mutex_lock(&round_robin_lock);
 	cpumask_clear(tmp);
 	for_each_cpu(cpu, pad_busy_cpus)
-		cpumask_or(tmp, tmp, topology_thread_cpumask(cpu));
+		cpumask_or(tmp, tmp, topology_sibling_cpumask(cpu));
 	cpumask_andnot(tmp, cpu_online_mask, tmp);
 	/* avoid HT sibilings if possible */
 	if (cpumask_empty(tmp))
* Unmerged path drivers/base/topology.c
diff --git a/drivers/net/ethernet/sfc/efx.c b/drivers/net/ethernet/sfc/efx.c
index 273bd5c7bbec..b201c2354f87 100644
--- a/drivers/net/ethernet/sfc/efx.c
+++ b/drivers/net/ethernet/sfc/efx.c
@@ -1344,7 +1344,7 @@ static unsigned int efx_wanted_parallelism(struct efx_nic *efx)
 			if (!cpumask_test_cpu(cpu, thread_mask)) {
 				++count;
 				cpumask_or(thread_mask, thread_mask,
-					   topology_thread_cpumask(cpu));
+					   topology_sibling_cpumask(cpu));
 			}
 		}
 
* Unmerged path drivers/staging/lustre/lustre/libcfs/linux/linux-cpu.c
* Unmerged path drivers/staging/lustre/lustre/ptlrpc/service.c
diff --git a/include/linux/topology.h b/include/linux/topology.h
index 4e2bd57be237..b78521a0a044 100644
--- a/include/linux/topology.h
+++ b/include/linux/topology.h
@@ -191,8 +191,8 @@ static inline int cpu_to_mem(int cpu)
 #ifndef topology_core_id
 #define topology_core_id(cpu)			((void)(cpu), 0)
 #endif
-#ifndef topology_thread_cpumask
-#define topology_thread_cpumask(cpu)		cpumask_of(cpu)
+#ifndef topology_sibling_cpumask
+#define topology_sibling_cpumask(cpu)		cpumask_of(cpu)
 #endif
 #ifndef topology_core_cpumask
 #define topology_core_cpumask(cpu)		cpumask_of(cpu)
@@ -201,7 +201,7 @@ static inline int cpu_to_mem(int cpu)
 #ifdef CONFIG_SCHED_SMT
 static inline const struct cpumask *cpu_smt_mask(int cpu)
 {
-	return topology_thread_cpumask(cpu);
+	return topology_sibling_cpumask(cpu);
 }
 #endif
 
diff --git a/lib/cpu_rmap.c b/lib/cpu_rmap.c
index 5fbed5caba6e..5e55e4040d66 100644
--- a/lib/cpu_rmap.c
+++ b/lib/cpu_rmap.c
@@ -193,7 +193,7 @@ int cpu_rmap_update(struct cpu_rmap *rmap, u16 index,
 	/* Update distances based on topology */
 	for_each_cpu(cpu, update_mask) {
 		if (cpu_rmap_copy_neigh(rmap, cpu,
-					topology_thread_cpumask(cpu), 1))
+					topology_sibling_cpumask(cpu), 1))
 			continue;
 		if (cpu_rmap_copy_neigh(rmap, cpu,
 					topology_core_cpumask(cpu), 2))
