be2iscsi: Couple MCC tag and WRB alloc and free

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jitendra Bhivare <jitendra.bhivare@broadcom.com>
commit 090e2184ba8fedff44b65e480d0f30229bb85621
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/090e2184.failed

WARN_ON(atomic_read(&mccq->used) >= mccq->len) seen when FW gets into
UE.

MCCQ overflow is happening because driver discards any new request and
frees up the tag. The tag allocation controls the number of MCC WRB
posted.  It is being replenished but WRBs are not hence the WARN_ON.

Allocation and freeing of WRB and tags for MCC is now done in one place.
This helps to achieve proper accounting of WRB indices and MCC tags.

	Signed-off-by: Jitendra Bhivare <jitendra.bhivare@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 090e2184ba8fedff44b65e480d0f30229bb85621)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/be2iscsi/be_cmds.c
#	drivers/scsi/be2iscsi/be_cmds.h
#	drivers/scsi/be2iscsi/be_main.c
diff --cc drivers/scsi/be2iscsi/be_cmds.c
index f6abd01429a1,a55eaeea37e7..000000000000
--- a/drivers/scsi/be2iscsi/be_cmds.c
+++ b/drivers/scsi/be2iscsi/be_cmds.c
@@@ -139,8 -126,85 +139,88 @@@ unsigned int alloc_mcc_tag(struct beisc
  	return tag;
  }
  
++<<<<<<< HEAD
++=======
+ struct be_mcc_wrb *alloc_mcc_wrb(struct beiscsi_hba *phba,
+ 				 unsigned int *ref_tag)
+ {
+ 	struct be_queue_info *mccq = &phba->ctrl.mcc_obj.q;
+ 	struct be_mcc_wrb *wrb = NULL;
+ 	unsigned int tag;
+ 
+ 	spin_lock_bh(&phba->ctrl.mcc_lock);
+ 	if (mccq->used == mccq->len) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT |
+ 			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+ 			    "BC_%d : MCC queue full: WRB used %u tag avail %u\n",
+ 			    mccq->used, phba->ctrl.mcc_tag_available);
+ 		goto alloc_failed;
+ 	}
+ 
+ 	if (!phba->ctrl.mcc_tag_available)
+ 		goto alloc_failed;
+ 
+ 	tag = phba->ctrl.mcc_tag[phba->ctrl.mcc_alloc_index];
+ 	if (!tag) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT |
+ 			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+ 			    "BC_%d : MCC tag 0 allocated: tag avail %u alloc index %u\n",
+ 			    phba->ctrl.mcc_tag_available,
+ 			    phba->ctrl.mcc_alloc_index);
+ 		goto alloc_failed;
+ 	}
+ 
+ 	/* return this tag for further reference */
+ 	*ref_tag = tag;
+ 	phba->ctrl.mcc_tag[phba->ctrl.mcc_alloc_index] = 0;
+ 	phba->ctrl.mcc_tag_status[tag] = 0;
+ 	phba->ctrl.ptag_state[tag].tag_state = 0;
+ 	phba->ctrl.mcc_tag_available--;
+ 	if (phba->ctrl.mcc_alloc_index == (MAX_MCC_CMD - 1))
+ 		phba->ctrl.mcc_alloc_index = 0;
+ 	else
+ 		phba->ctrl.mcc_alloc_index++;
+ 
+ 	wrb = queue_head_node(mccq);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	wrb->tag0 = tag;
+ 	wrb->tag0 |= (mccq->head << MCC_Q_WRB_IDX_SHIFT) & MCC_Q_WRB_IDX_MASK;
+ 	queue_head_inc(mccq);
+ 	mccq->used++;
+ 
+ alloc_failed:
+ 	spin_unlock_bh(&phba->ctrl.mcc_lock);
+ 	return wrb;
+ }
+ 
+ void free_mcc_wrb(struct be_ctrl_info *ctrl, unsigned int tag)
+ {
+ 	struct be_queue_info *mccq = &ctrl->mcc_obj.q;
+ 
+ 	spin_lock_bh(&ctrl->mcc_lock);
+ 	tag = tag & MCC_Q_CMD_TAG_MASK;
+ 	ctrl->mcc_tag[ctrl->mcc_free_index] = tag;
+ 	if (ctrl->mcc_free_index == (MAX_MCC_CMD - 1))
+ 		ctrl->mcc_free_index = 0;
+ 	else
+ 		ctrl->mcc_free_index++;
+ 	ctrl->mcc_tag_available++;
+ 	mccq->used--;
+ 	spin_unlock_bh(&ctrl->mcc_lock);
+ }
+ 
+ /**
+  * beiscsi_fail_session(): Closing session with appropriate error
+  * @cls_session: ptr to session
+  **/
+ void beiscsi_fail_session(struct iscsi_cls_session *cls_session)
+ {
+ 	iscsi_session_failure(cls_session->dd_data, ISCSI_ERR_CONN_FAILED);
+ }
+ 
++>>>>>>> 090e2184ba8f (be2iscsi: Couple MCC tag and WRB alloc and free)
  /*
 - * beiscsi_mccq_compl_wait()- Process completion in MCC CQ
 + * beiscsi_mccq_compl()- Wait for completion of MBX
   * @phba: Driver private structure
   * @tag: Tag for the MBX Command
   * @wrb: the WRB used for the MBX Command
@@@ -524,46 -567,53 +602,68 @@@ int beiscsi_process_mcc(struct beiscsi_
   * Failure: Non-Zero
   *
   **/
 -int be_mcc_compl_poll(struct beiscsi_hba *phba, unsigned int tag)
 +static int be_mcc_wait_compl(struct beiscsi_hba *phba)
  {
++<<<<<<< HEAD
 +	int i, status;
++=======
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	int i;
+ 
+ 	if (!test_bit(MCC_TAG_STATE_RUNNING,
+ 		      &ctrl->ptag_state[tag].tag_state)) {
+ 		beiscsi_log(phba, KERN_ERR,
+ 			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+ 			    "BC_%d: tag %u state not running\n", tag);
+ 		return 0;
+ 	}
++>>>>>>> 090e2184ba8f (be2iscsi: Couple MCC tag and WRB alloc and free)
  	for (i = 0; i < mcc_timeout; i++) {
  		if (beiscsi_error(phba))
  			return -EIO;
  
++<<<<<<< HEAD
 +		status = beiscsi_process_mcc(phba);
 +		if (status)
 +			return status;
 +
 +		if (atomic_read(&phba->ctrl.mcc_obj.q.used) == 0)
++=======
+ 		beiscsi_process_mcc_cq(phba);
+ 		/* after polling, wrb and tag need to be released */
+ 		if (!test_bit(MCC_TAG_STATE_RUNNING,
+ 			      &ctrl->ptag_state[tag].tag_state)) {
+ 			free_mcc_wrb(ctrl, tag);
++>>>>>>> 090e2184ba8f (be2iscsi: Couple MCC tag and WRB alloc and free)
  			break;
+ 		}
  		udelay(100);
  	}
 -
 -	if (i < mcc_timeout)
 -		return 0;
 -
 -	beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
 -		    "BC_%d : FW Timed Out\n");
 -	phba->fw_timeout = true;
 -	beiscsi_ue_detect(phba);
 -	return -EBUSY;
 +	if (i == mcc_timeout) {
 +		beiscsi_log(phba, KERN_ERR,
 +			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
 +			    "BC_%d : FW Timed Out\n");
 +		phba->fw_timeout = true;
 +		beiscsi_ue_detect(phba);
 +		return -EBUSY;
 +	}
 +	return 0;
  }
  
 -void be_mcc_notify(struct beiscsi_hba *phba, unsigned int tag)
 +/*
 + * be_mcc_notify_wait()- Notify and wait for Compl
 + * @phba: driver private structure
 + *
 + * Notify MCC requests and wait for completion
 + *
 + * return
 + * Success: 0
 + * Failure: Non-Zero
 + **/
 +int be_mcc_notify_wait(struct beiscsi_hba *phba, unsigned int tag)
  {
 -	struct be_queue_info *mccq = &phba->ctrl.mcc_obj.q;
 -	u32 val = 0;
 -
 -	set_bit(MCC_TAG_STATE_RUNNING, &phba->ctrl.ptag_state[tag].tag_state);
 -	val |= mccq->id & DB_MCCQ_RING_ID_MASK;
 -	val |= 1 << DB_MCCQ_NUM_POSTED_SHIFT;
 -	/* make request available for DMA */
 -	wmb();
 -	iowrite32(val, phba->db_va + DB_MCCQ_OFFSET);
 +	be_mcc_notify(phba, tag);
 +	return be_mcc_wait_compl(phba);
  }
  
  /*
diff --cc drivers/scsi/be2iscsi/be_cmds.h
index 522c53180d02,deeb951e6874..000000000000
--- a/drivers/scsi/be2iscsi/be_cmds.h
+++ b/drivers/scsi/be2iscsi/be_cmds.h
@@@ -731,9 -727,8 +731,9 @@@ int be_poll_mcc(struct be_ctrl_info *ct
  int mgmt_check_supported_fw(struct be_ctrl_info *ctrl,
  				      struct beiscsi_hba *phba);
  unsigned int be_cmd_get_initname(struct beiscsi_hba *phba);
 +unsigned int be_cmd_get_port_speed(struct beiscsi_hba *phba);
  
- void free_mcc_tag(struct be_ctrl_info *ctrl, unsigned int tag);
+ void free_mcc_wrb(struct be_ctrl_info *ctrl, unsigned int tag);
  
  int be_cmd_modify_eq_delay(struct beiscsi_hba *phba, struct be_set_eqd *,
  			    int num);
@@@ -745,14 -740,15 +745,26 @@@ int be_cmd_fw_initialize(struct be_ctrl
  int be_cmd_fw_uninit(struct be_ctrl_info *ctrl);
  
  struct be_mcc_wrb *wrb_from_mbox(struct be_dma_mem *mbox_mem);
++<<<<<<< HEAD
 +struct be_mcc_wrb *wrb_from_mccq(struct beiscsi_hba *phba);
 +int be_mcc_notify_wait(struct beiscsi_hba *phba, unsigned int tag);
 +void be_mcc_notify(struct beiscsi_hba *phba, unsigned int tag);
 +unsigned int alloc_mcc_tag(struct beiscsi_hba *phba);
 +void beiscsi_async_link_state_process(struct beiscsi_hba *phba,
 +		struct be_async_event_link_state *evt);
 +int be_mcc_compl_process_isr(struct be_ctrl_info *ctrl,
 +				    struct be_mcc_compl *compl);
++=======
+ int be_mcc_compl_poll(struct beiscsi_hba *phba, unsigned int tag);
+ void be_mcc_notify(struct beiscsi_hba *phba, unsigned int tag);
+ struct be_mcc_wrb *alloc_mcc_wrb(struct beiscsi_hba *phba,
+ 				 unsigned int *ref_tag);
+ void beiscsi_process_async_event(struct beiscsi_hba *phba,
+ 				struct be_mcc_compl *compl);
+ int beiscsi_process_mcc_compl(struct be_ctrl_info *ctrl,
+ 			      struct be_mcc_compl *compl);
+ 
++>>>>>>> 090e2184ba8f (be2iscsi: Couple MCC tag and WRB alloc and free)
  
  int be_mbox_notify(struct be_ctrl_info *ctrl);
  
diff --cc drivers/scsi/be2iscsi/be_main.c
index 7885533b6626,3f08a11880d5..000000000000
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@@ -2110,24 -2044,9 +2110,28 @@@ static void  beiscsi_process_mcc_isr(st
  			num_processed = 0;
  		}
  		if (mcc_compl->flags & CQE_FLAGS_ASYNC_MASK) {
 -			beiscsi_process_async_event(phba, mcc_compl);
 +			/* Interpret flags as an async trailer */
 +			if (is_link_state_evt(mcc_compl->flags))
 +				/* Interpret compl as a async link evt */
 +				beiscsi_async_link_state_process(phba,
 +				(struct be_async_event_link_state *) mcc_compl);
 +			else {
 +				beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_MBOX,
 +					    "BM_%d :  Unsupported Async Event, flags"
 +					    " = 0x%08x\n",
 +					    mcc_compl->flags);
 +				if (phba->state & BE_ADAPTER_LINK_UP) {
 +					phba->state |= BE_ADAPTER_CHECK_BOOT;
 +					phba->get_boot = BE_GET_BOOT_RETRIES;
 +				}
 +			}
  		} else if (mcc_compl->flags & CQE_FLAGS_COMPLETED_MASK) {
++<<<<<<< HEAD
 +			be_mcc_compl_process_isr(&phba->ctrl, mcc_compl);
 +			atomic_dec(&phba->ctrl.mcc_obj.q.used);
++=======
+ 			beiscsi_process_mcc_compl(&phba->ctrl, mcc_compl);
++>>>>>>> 090e2184ba8f (be2iscsi: Couple MCC tag and WRB alloc and free)
  		}
  
  		mcc_compl->flags = 0;
diff --git a/drivers/scsi/be2iscsi/be.h b/drivers/scsi/be2iscsi/be.h
index 972e5fdae7f5..f29dc4b519c6 100644
--- a/drivers/scsi/be2iscsi/be.h
+++ b/drivers/scsi/be2iscsi/be.h
@@ -42,7 +42,7 @@ struct be_queue_info {
 	u16 id;
 	u16 tail, head;
 	bool created;
-	atomic_t used;		/* Number of valid elements in the queue */
+	u16 used;		/* Number of valid elements in the queue */
 };
 
 static inline u32 MODULO(u16 val, u16 limit)
* Unmerged path drivers/scsi/be2iscsi/be_cmds.c
* Unmerged path drivers/scsi/be2iscsi/be_cmds.h
* Unmerged path drivers/scsi/be2iscsi/be_main.c
diff --git a/drivers/scsi/be2iscsi/be_mgmt.c b/drivers/scsi/be2iscsi/be_mgmt.c
index 66d5498370fd..793138cf5468 100644
--- a/drivers/scsi/be2iscsi/be_mgmt.c
+++ b/drivers/scsi/be2iscsi/be_mgmt.c
@@ -161,20 +161,17 @@ int be_cmd_modify_eq_delay(struct beiscsi_hba *phba,
 	struct be_ctrl_info *ctrl = &phba->ctrl;
 	struct be_mcc_wrb *wrb;
 	struct be_cmd_req_modify_eq_delay *req;
-	unsigned int tag = 0;
+	unsigned int tag;
 	int i;
 
 	mutex_lock(&ctrl->mbox_lock);
-	tag = alloc_mcc_tag(phba);
-	if (!tag) {
+	wrb = alloc_mcc_wrb(phba, &tag);
+	if (!wrb) {
 		mutex_unlock(&ctrl->mbox_lock);
-		return tag;
+		return 0;
 	}
 
-	wrb = wrb_from_mccq(phba);
 	req = embedded_payload(wrb);
-
-	wrb->tag0 |= tag;
 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,
 		OPCODE_COMMON_MODIFY_EQ_DELAY, sizeof(*req));
@@ -209,22 +206,20 @@ unsigned int mgmt_reopen_session(struct beiscsi_hba *phba,
 	struct be_ctrl_info *ctrl = &phba->ctrl;
 	struct be_mcc_wrb *wrb;
 	struct be_cmd_reopen_session_req *req;
-	unsigned int tag = 0;
+	unsigned int tag;
 
 	beiscsi_log(phba, KERN_INFO,
 		    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
 		    "BG_%d : In bescsi_get_boot_target\n");
 
 	mutex_lock(&ctrl->mbox_lock);
-	tag = alloc_mcc_tag(phba);
-	if (!tag) {
+	wrb = alloc_mcc_wrb(phba, &tag);
+	if (!wrb) {
 		mutex_unlock(&ctrl->mbox_lock);
-		return tag;
+		return 0;
 	}
 
-	wrb = wrb_from_mccq(phba);
 	req = embedded_payload(wrb);
-	wrb->tag0 |= tag;
 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,
 			   OPCODE_ISCSI_INI_DRIVER_REOPEN_ALL_SESSIONS,
@@ -244,22 +239,20 @@ unsigned int mgmt_get_boot_target(struct beiscsi_hba *phba)
 	struct be_ctrl_info *ctrl = &phba->ctrl;
 	struct be_mcc_wrb *wrb;
 	struct be_cmd_get_boot_target_req *req;
-	unsigned int tag = 0;
+	unsigned int tag;
 
 	beiscsi_log(phba, KERN_INFO,
 		    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
 		    "BG_%d : In bescsi_get_boot_target\n");
 
 	mutex_lock(&ctrl->mbox_lock);
-	tag = alloc_mcc_tag(phba);
-	if (!tag) {
+	wrb = alloc_mcc_wrb(phba, &tag);
+	if (!wrb) {
 		mutex_unlock(&ctrl->mbox_lock);
-		return tag;
+		return 0;
 	}
 
-	wrb = wrb_from_mccq(phba);
 	req = embedded_payload(wrb);
-	wrb->tag0 |= tag;
 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,
 			   OPCODE_ISCSI_INI_BOOT_GET_BOOT_TARGET,
@@ -276,7 +269,7 @@ unsigned int mgmt_get_session_info(struct beiscsi_hba *phba,
 {
 	struct be_ctrl_info *ctrl = &phba->ctrl;
 	struct be_mcc_wrb *wrb;
-	unsigned int tag = 0;
+	unsigned int tag;
 	struct  be_cmd_get_session_req *req;
 	struct be_cmd_get_session_resp *resp;
 	struct be_sge *sge;
@@ -286,21 +279,16 @@ unsigned int mgmt_get_session_info(struct beiscsi_hba *phba,
 		    "BG_%d : In beiscsi_get_session_info\n");
 
 	mutex_lock(&ctrl->mbox_lock);
-	tag = alloc_mcc_tag(phba);
-	if (!tag) {
+	wrb = alloc_mcc_wrb(phba, &tag);
+	if (!wrb) {
 		mutex_unlock(&ctrl->mbox_lock);
-		return tag;
+		return 0;
 	}
 
 	nonemb_cmd->size = sizeof(*resp);
 	req = nonemb_cmd->va;
 	memset(req, 0, sizeof(*req));
-	wrb = wrb_from_mccq(phba);
 	sge = nonembedded_sgl(wrb);
-	wrb->tag0 |= tag;
-
-
-	wrb->tag0 |= tag;
 	be_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);
 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,
 			   OPCODE_ISCSI_INI_SESSION_GET_A_SESSION,
@@ -526,20 +514,18 @@ unsigned int mgmt_vendor_specific_fw_cmd(struct be_ctrl_info *ctrl,
 		return -ENOSYS;
 	}
 
-	tag = alloc_mcc_tag(phba);
-	if (!tag) {
+	wrb = alloc_mcc_wrb(phba, &tag);
+	if (!wrb) {
 		mutex_unlock(&ctrl->mbox_lock);
-		return tag;
+		return 0;
 	}
 
-	wrb = wrb_from_mccq(phba);
 	mcc_sge = nonembedded_sgl(wrb);
 	be_wrb_hdr_prepare(wrb, nonemb_cmd->size, false,
 			   job->request_payload.sg_cnt);
 	mcc_sge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));
 	mcc_sge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);
 	mcc_sge->len = cpu_to_le32(nonemb_cmd->size);
-	wrb->tag0 |= tag;
 
 	be_mcc_notify(phba, tag);
 
@@ -559,22 +545,22 @@ unsigned int mgmt_vendor_specific_fw_cmd(struct be_ctrl_info *ctrl,
 int mgmt_epfw_cleanup(struct beiscsi_hba *phba, unsigned short ulp_num)
 {
 	struct be_ctrl_info *ctrl = &phba->ctrl;
-	struct be_mcc_wrb *wrb = wrb_from_mccq(phba);
-	struct iscsi_cleanup_req *req = embedded_payload(wrb);
+	struct be_mcc_wrb *wrb;
+	struct iscsi_cleanup_req *req;
 	unsigned int tag;
 	int status;
 
 	mutex_lock(&ctrl->mbox_lock);
-	tag = alloc_mcc_tag(phba);
-	if (!tag) {
+	wrb = alloc_mcc_wrb(phba, &tag);
+	if (!wrb) {
 		mutex_unlock(&ctrl->mbox_lock);
 		return -EBUSY;
 	}
 
+	req = embedded_payload(wrb);
 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,
 			   OPCODE_COMMON_ISCSI_CLEANUP, sizeof(*req));
-	wrb->tag0 |= tag;
 
 	req->chute = (1 << ulp_num);
 	req->hdr_ring_id = cpu_to_le16(HWI_GET_DEF_HDRQ_ID(phba, ulp_num));
@@ -598,20 +584,18 @@ unsigned int  mgmt_invalidate_icds(struct beiscsi_hba *phba,
 	struct be_mcc_wrb *wrb;
 	struct be_sge *sge;
 	struct invalidate_commands_params_in *req;
-	unsigned int i, tag = 0;
+	unsigned int i, tag;
 
 	mutex_lock(&ctrl->mbox_lock);
-	tag = alloc_mcc_tag(phba);
-	if (!tag) {
+	wrb = alloc_mcc_wrb(phba, &tag);
+	if (!wrb) {
 		mutex_unlock(&ctrl->mbox_lock);
-		return tag;
+		return 0;
 	}
 
 	req = nonemb_cmd->va;
 	memset(req, 0, sizeof(*req));
-	wrb = wrb_from_mccq(phba);
 	sge = nonembedded_sgl(wrb);
-	wrb->tag0 |= tag;
 
 	be_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);
 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,
@@ -646,15 +630,13 @@ unsigned int mgmt_invalidate_connection(struct beiscsi_hba *phba,
 	unsigned int tag = 0;
 
 	mutex_lock(&ctrl->mbox_lock);
-	tag = alloc_mcc_tag(phba);
-	if (!tag) {
+	wrb = alloc_mcc_wrb(phba, &tag);
+	if (!wrb) {
 		mutex_unlock(&ctrl->mbox_lock);
-		return tag;
+		return 0;
 	}
-	wrb = wrb_from_mccq(phba);
-	wrb->tag0 |= tag;
-	req = embedded_payload(wrb);
 
+	req = embedded_payload(wrb);
 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,
 			   OPCODE_ISCSI_INI_DRIVER_INVALIDATE_CONNECTION,
@@ -677,18 +659,16 @@ unsigned int mgmt_upload_connection(struct beiscsi_hba *phba,
 	struct be_ctrl_info *ctrl = &phba->ctrl;
 	struct be_mcc_wrb *wrb;
 	struct tcp_upload_params_in *req;
-	unsigned int tag = 0;
+	unsigned int tag;
 
 	mutex_lock(&ctrl->mbox_lock);
-	tag = alloc_mcc_tag(phba);
-	if (!tag) {
+	wrb = alloc_mcc_wrb(phba, &tag);
+	if (!wrb) {
 		mutex_unlock(&ctrl->mbox_lock);
-		return tag;
+		return 0;
 	}
-	wrb = wrb_from_mccq(phba);
-	req = embedded_payload(wrb);
-	wrb->tag0 |= tag;
 
+	req = embedded_payload(wrb);
 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
 	be_cmd_hdr_prepare(&req->hdr, CMD_COMMON_TCP_UPLOAD,
 			   OPCODE_COMMON_TCP_UPLOAD, sizeof(*req));
@@ -749,17 +729,15 @@ int mgmt_open_connection(struct beiscsi_hba *phba,
 	ISCSI_GET_PDU_TEMPLATE_ADDRESS(phba, ptemplate_address);
 	if (mutex_lock_interruptible(&ctrl->mbox_lock))
 		return 0;
-	tag = alloc_mcc_tag(phba);
-	if (!tag) {
+	wrb = alloc_mcc_wrb(phba, &tag);
+	if (!wrb) {
 		mutex_unlock(&ctrl->mbox_lock);
-		return tag;
+		return 0;
 	}
-	wrb = wrb_from_mccq(phba);
-	sge = nonembedded_sgl(wrb);
 
+	sge = nonembedded_sgl(wrb);
 	req = nonemb_cmd->va;
 	memset(req, 0, sizeof(*req));
-	wrb->tag0 |= tag;
 
 	be_wrb_hdr_prepare(wrb, nonemb_cmd->size, false, 1);
 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,
@@ -826,16 +804,13 @@ unsigned int mgmt_get_all_if_id(struct beiscsi_hba *phba)
 
 	if (mutex_lock_interruptible(&ctrl->mbox_lock))
 		return -EINTR;
-	tag = alloc_mcc_tag(phba);
-	if (!tag) {
+	wrb = alloc_mcc_wrb(phba, &tag);
+	if (!wrb) {
 		mutex_unlock(&ctrl->mbox_lock);
 		return -ENOMEM;
 	}
 
-	wrb = wrb_from_mccq(phba);
 	req = embedded_payload(wrb);
-	wrb->tag0 |= tag;
-
 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,
 			   OPCODE_COMMON_ISCSI_NTWK_GET_ALL_IF_ID,
@@ -875,17 +850,14 @@ static int mgmt_exec_nonemb_cmd(struct beiscsi_hba *phba,
 	int rc = 0;
 
 	mutex_lock(&ctrl->mbox_lock);
-	tag = alloc_mcc_tag(phba);
-	if (!tag) {
+	wrb = alloc_mcc_wrb(phba, &tag);
+	if (!wrb) {
 		mutex_unlock(&ctrl->mbox_lock);
 		rc = -ENOMEM;
 		goto free_cmd;
 	}
 
-	wrb = wrb_from_mccq(phba);
-	wrb->tag0 |= tag;
 	sge = nonembedded_sgl(wrb);
-
 	be_wrb_hdr_prepare(wrb, nonemb_cmd->size, false, 1);
 	sge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));
 	sge->pa_lo = cpu_to_le32(lower_32_bits(nonemb_cmd->dma));
@@ -1270,22 +1242,20 @@ int mgmt_get_nic_conf(struct beiscsi_hba *phba,
 
 unsigned int be_cmd_get_initname(struct beiscsi_hba *phba)
 {
-	unsigned int tag = 0;
+	unsigned int tag;
 	struct be_mcc_wrb *wrb;
 	struct be_cmd_hba_name *req;
 	struct be_ctrl_info *ctrl = &phba->ctrl;
 
 	if (mutex_lock_interruptible(&ctrl->mbox_lock))
 		return 0;
-	tag = alloc_mcc_tag(phba);
-	if (!tag) {
+	wrb = alloc_mcc_wrb(phba, &tag);
+	if (!wrb) {
 		mutex_unlock(&ctrl->mbox_lock);
-		return tag;
+		return 0;
 	}
 
-	wrb = wrb_from_mccq(phba);
 	req = embedded_payload(wrb);
-	wrb->tag0 |= tag;
 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,
 			OPCODE_ISCSI_INI_CFG_GET_HBA_NAME,
@@ -1777,8 +1747,8 @@ int beiscsi_logout_fw_sess(struct beiscsi_hba *phba,
 		    "BG_%d : In bescsi_logout_fwboot_sess\n");
 
 	mutex_lock(&ctrl->mbox_lock);
-	tag = alloc_mcc_tag(phba);
-	if (!tag) {
+	wrb = alloc_mcc_wrb(phba, &tag);
+	if (!wrb) {
 		mutex_unlock(&ctrl->mbox_lock);
 		beiscsi_log(phba, KERN_INFO,
 			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
@@ -1786,9 +1756,7 @@ int beiscsi_logout_fw_sess(struct beiscsi_hba *phba,
 		return -EINVAL;
 	}
 
-	wrb = wrb_from_mccq(phba);
 	req = embedded_payload(wrb);
-	wrb->tag0 |= tag;
 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,
 			   OPCODE_ISCSI_INI_SESSION_LOGOUT_TARGET,
