mei: bus: use mei_cldev_ prefix for the API functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit d49dc5e76fc917e5dfef76cb56fe3b3868deed5d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d49dc5e7.failed

Use mei_cldev_ prefix for all mei client bus api functions
in order to resolve prefix conflict with functions that handle
client function and are defined in client.c

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit d49dc5e76fc917e5dfef76cb56fe3b3868deed5d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/bus.c
#	drivers/nfc/mei_phy.c
#	drivers/nfc/microread/mei.c
#	drivers/nfc/pn544/mei.c
#	include/linux/mei_cl_bus.h
diff --cc drivers/misc/mei/bus.c
index 3365981198e7,0406e7201fe4..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -31,26 -30,523 +31,488 @@@
  #define to_mei_cl_driver(d) container_of(d, struct mei_cl_driver, driver)
  #define to_mei_cl_device(d) container_of(d, struct mei_cl_device, dev)
  
++<<<<<<< HEAD
 +static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
++=======
+ /**
+  * __mei_cl_send - internal client send (write)
+  *
+  * @cl: host client
+  * @buf: buffer to send
+  * @length: buffer length
+  * @blocking: wait for write completion
+  *
+  * Return: written size bytes or < 0 on error
+  */
+ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
+ 			bool blocking)
+ {
+ 	struct mei_device *bus;
+ 	struct mei_cl_cb *cb = NULL;
+ 	ssize_t rets;
+ 
+ 	if (WARN_ON(!cl || !cl->dev))
+ 		return -ENODEV;
+ 
+ 	bus = cl->dev;
+ 
+ 	mutex_lock(&bus->device_lock);
+ 	if (!mei_cl_is_connected(cl)) {
+ 		rets = -ENODEV;
+ 		goto out;
+ 	}
+ 
+ 	/* Check if we have an ME client device */
+ 	if (!mei_me_cl_is_active(cl->me_cl)) {
+ 		rets = -ENOTTY;
+ 		goto out;
+ 	}
+ 
+ 	if (length > mei_cl_mtu(cl)) {
+ 		rets = -EFBIG;
+ 		goto out;
+ 	}
+ 
+ 	cb = mei_cl_alloc_cb(cl, length, MEI_FOP_WRITE, NULL);
+ 	if (!cb) {
+ 		rets = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	memcpy(cb->buf.data, buf, length);
+ 
+ 	rets = mei_cl_write(cl, cb, blocking);
+ 
+ out:
+ 	mutex_unlock(&bus->device_lock);
+ 	if (rets < 0)
+ 		mei_io_cb_free(cb);
+ 
+ 	return rets;
+ }
+ 
+ /**
+  * __mei_cl_recv - internal client receive (read)
+  *
+  * @cl: host client
+  * @buf: buffer to send
+  * @length: buffer length
+  *
+  * Return: read size in bytes of < 0 on error
+  */
+ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
+ {
+ 	struct mei_device *bus;
+ 	struct mei_cl_cb *cb;
+ 	size_t r_length;
+ 	ssize_t rets;
+ 
+ 	if (WARN_ON(!cl || !cl->dev))
+ 		return -ENODEV;
+ 
+ 	bus = cl->dev;
+ 
+ 	mutex_lock(&bus->device_lock);
+ 
+ 	cb = mei_cl_read_cb(cl, NULL);
+ 	if (cb)
+ 		goto copy;
+ 
+ 	rets = mei_cl_read_start(cl, length, NULL);
+ 	if (rets && rets != -EBUSY)
+ 		goto out;
+ 
+ 	/* wait on event only if there is no other waiter */
+ 	if (list_empty(&cl->rd_completed) && !waitqueue_active(&cl->rx_wait)) {
+ 
+ 		mutex_unlock(&bus->device_lock);
+ 
+ 		if (wait_event_interruptible(cl->rx_wait,
+ 				(!list_empty(&cl->rd_completed)) ||
+ 				(!mei_cl_is_connected(cl)))) {
+ 
+ 			if (signal_pending(current))
+ 				return -EINTR;
+ 			return -ERESTARTSYS;
+ 		}
+ 
+ 		mutex_lock(&bus->device_lock);
+ 
+ 		if (!mei_cl_is_connected(cl)) {
+ 			rets = -EBUSY;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	cb = mei_cl_read_cb(cl, NULL);
+ 	if (!cb) {
+ 		rets = 0;
+ 		goto out;
+ 	}
+ 
+ copy:
+ 	if (cb->status) {
+ 		rets = cb->status;
+ 		goto free;
+ 	}
+ 
+ 	r_length = min_t(size_t, length, cb->buf_idx);
+ 	memcpy(buf, cb->buf.data, r_length);
+ 	rets = r_length;
+ 
+ free:
+ 	mei_io_cb_free(cb);
+ out:
+ 	mutex_unlock(&bus->device_lock);
+ 
+ 	return rets;
+ }
+ 
+ /**
+  * mei_cldev_send - me device send  (write)
+  *
+  * @cldev: me client device
+  * @buf: buffer to send
+  * @length: buffer length
+  *
+  * Return: written size in bytes or < 0 on error
+  */
+ ssize_t mei_cldev_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
+ {
+ 	struct mei_cl *cl = cldev->cl;
+ 
+ 	if (cl == NULL)
+ 		return -ENODEV;
+ 
+ 	return __mei_cl_send(cl, buf, length, 1);
+ }
+ EXPORT_SYMBOL_GPL(mei_cldev_send);
+ 
+ /**
+  * mei_cldev_recv - client receive (read)
+  *
+  * @cldev: me client device
+  * @buf: buffer to send
+  * @length: buffer length
+  *
+  * Return: read size in bytes of < 0 on error
+  */
+ ssize_t mei_cldev_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
+ {
+ 	struct mei_cl *cl = cldev->cl;
+ 
+ 	if (cl == NULL)
+ 		return -ENODEV;
+ 
+ 	return __mei_cl_recv(cl, buf, length);
+ }
+ EXPORT_SYMBOL_GPL(mei_cldev_recv);
+ 
+ /**
+  * mei_cl_bus_event_work  - dispatch rx event for a bus device
+  *    and schedule new work
+  *
+  * @work: work
+  */
+ static void mei_cl_bus_event_work(struct work_struct *work)
+ {
+ 	struct mei_cl_device *cldev;
+ 
+ 	cldev = container_of(work, struct mei_cl_device, event_work);
+ 
+ 	if (cldev->event_cb)
+ 		cldev->event_cb(cldev, cldev->events, cldev->event_context);
+ 
+ 	cldev->events = 0;
+ 
+ 	/* Prepare for the next read */
+ 	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX))
+ 		mei_cl_read_start(cldev->cl, 0, NULL);
+ }
+ 
+ /**
+  * mei_cl_bus_notify_event - schedule notify cb on bus client
+  *
+  * @cl: host client
+  */
+ void mei_cl_bus_notify_event(struct mei_cl *cl)
+ {
+ 	struct mei_cl_device *cldev = cl->cldev;
+ 
+ 	if (!cldev || !cldev->event_cb)
+ 		return;
+ 
+ 	if (!(cldev->events_mask & BIT(MEI_CL_EVENT_NOTIF)))
+ 		return;
+ 
+ 	if (!cl->notify_ev)
+ 		return;
+ 
+ 	set_bit(MEI_CL_EVENT_NOTIF, &cldev->events);
+ 
+ 	schedule_work(&cldev->event_work);
+ 
+ 	cl->notify_ev = false;
+ }
+ 
+ /**
+  * mei_cl_bus_rx_event  - schedule rx evenet
+  *
+  * @cl: host client
+  */
+ void mei_cl_bus_rx_event(struct mei_cl *cl)
+ {
+ 	struct mei_cl_device *cldev = cl->cldev;
+ 
+ 	if (!cldev || !cldev->event_cb)
+ 		return;
+ 
+ 	if (!(cldev->events_mask & BIT(MEI_CL_EVENT_RX)))
+ 		return;
+ 
+ 	set_bit(MEI_CL_EVENT_RX, &cldev->events);
+ 
+ 	schedule_work(&cldev->event_work);
+ }
+ 
+ /**
+  * mei_cldev_register_event_cb - register event callback
+  *
+  * @cldev: me client devices
+  * @event_cb: callback function
+  * @events_mask: requested events bitmask
+  * @context: driver context data
+  *
+  * Return: 0 on success
+  *         -EALREADY if an callback is already registered
+  *         <0 on other errors
+  */
+ int mei_cldev_register_event_cb(struct mei_cl_device *cldev,
+ 				unsigned long events_mask,
+ 				mei_cldev_event_cb_t event_cb, void *context)
+ {
+ 	int ret;
+ 
+ 	if (cldev->event_cb)
+ 		return -EALREADY;
+ 
+ 	cldev->events = 0;
+ 	cldev->events_mask = events_mask;
+ 	cldev->event_cb = event_cb;
+ 	cldev->event_context = context;
+ 	INIT_WORK(&cldev->event_work, mei_cl_bus_event_work);
+ 
+ 	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX)) {
+ 		ret = mei_cl_read_start(cldev->cl, 0, NULL);
+ 		if (ret && ret != -EBUSY)
+ 			return ret;
+ 	}
+ 
+ 	if (cldev->events_mask & BIT(MEI_CL_EVENT_NOTIF)) {
+ 		mutex_lock(&cldev->cl->dev->device_lock);
+ 		ret = mei_cl_notify_request(cldev->cl, NULL, event_cb ? 1 : 0);
+ 		mutex_unlock(&cldev->cl->dev->device_lock);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(mei_cldev_register_event_cb);
+ 
+ /**
+  * mei_cldev_get_drvdata - driver data getter
+  *
+  * @cldev: mei client device
+  *
+  * Return: driver private data
+  */
+ void *mei_cldev_get_drvdata(const struct mei_cl_device *cldev)
+ {
+ 	return dev_get_drvdata(&cldev->dev);
+ }
+ EXPORT_SYMBOL_GPL(mei_cldev_get_drvdata);
+ 
+ /**
+  * mei_cldev_set_drvdata - driver data setter
+  *
+  * @cldev: mei client device
+  * @data: data to store
+  */
+ void mei_cldev_set_drvdata(struct mei_cl_device *cldev, void *data)
+ {
+ 	dev_set_drvdata(&cldev->dev, data);
+ }
+ EXPORT_SYMBOL_GPL(mei_cldev_set_drvdata);
+ 
+ /**
+  * mei_cldev_uuid - return uuid of the underlying me client
+  *
+  * @cldev: mei client device
+  *
+  * Return: me client uuid
+  */
+ const uuid_le *mei_cldev_uuid(const struct mei_cl_device *cldev)
+ {
+ 	return mei_me_cl_uuid(cldev->me_cl);
+ }
+ EXPORT_SYMBOL_GPL(mei_cldev_uuid);
+ 
+ /**
+  * mei_cldev_ver - return protocol version of the underlying me client
+  *
+  * @cldev: mei client device
+  *
+  * Return: me client protocol version
+  */
+ u8 mei_cldev_ver(const struct mei_cl_device *cldev)
+ {
+ 	return mei_me_cl_ver(cldev->me_cl);
+ }
+ EXPORT_SYMBOL_GPL(mei_cldev_ver);
+ 
+ /**
+  * mei_cldev_enabled - check whether the device is enabled
+  *
+  * @cldev: mei client device
+  *
+  * Return: true if me client is initialized and connected
+  */
+ bool mei_cldev_enabled(struct mei_cl_device *cldev)
+ {
+ 	return cldev->cl && mei_cl_is_connected(cldev->cl);
+ }
+ EXPORT_SYMBOL_GPL(mei_cldev_enabled);
+ 
+ /**
+  * mei_cldev_enable_device - enable me client device
+  *     create connection with me client
+  *
+  * @cldev: me client device
+  *
+  * Return: 0 on success and < 0 on error
+  */
+ int mei_cldev_enable(struct mei_cl_device *cldev)
+ {
+ 	struct mei_device *bus = cldev->bus;
+ 	struct mei_cl *cl;
+ 	int ret;
+ 
+ 	cl = cldev->cl;
+ 
+ 	if (!cl) {
+ 		mutex_lock(&bus->device_lock);
+ 		cl = mei_cl_alloc_linked(bus, MEI_HOST_CLIENT_ID_ANY);
+ 		mutex_unlock(&bus->device_lock);
+ 		if (IS_ERR(cl))
+ 			return PTR_ERR(cl);
+ 		/* update pointers */
+ 		cldev->cl = cl;
+ 		cl->cldev = cldev;
+ 	}
+ 
+ 	mutex_lock(&bus->device_lock);
+ 	if (mei_cl_is_connected(cl)) {
+ 		ret = 0;
+ 		goto out;
+ 	}
+ 
+ 	if (!mei_me_cl_is_active(cldev->me_cl)) {
+ 		dev_err(&cldev->dev, "me client is not active\n");
+ 		ret = -ENOTTY;
+ 		goto out;
+ 	}
+ 
+ 	ret = mei_cl_connect(cl, cldev->me_cl, NULL);
+ 	if (ret < 0)
+ 		dev_err(&cldev->dev, "cannot connect\n");
+ 
+ out:
+ 	mutex_unlock(&bus->device_lock);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(mei_cldev_enable);
+ 
+ /**
+  * mei_cldev_disable - disable me client device
+  *     disconnect form the me client
+  *
+  * @cldev: me client device
+  *
+  * Return: 0 on success and < 0 on error
+  */
+ int mei_cldev_disable(struct mei_cl_device *cldev)
+ {
+ 	struct mei_device *bus;
+ 	struct mei_cl *cl;
+ 	int err;
+ 
+ 	if (!cldev || !cldev->cl)
+ 		return -ENODEV;
+ 
+ 	cl = cldev->cl;
+ 
+ 	bus = cldev->bus;
+ 
+ 	cldev->event_cb = NULL;
+ 
+ 	mutex_lock(&bus->device_lock);
+ 
+ 	if (!mei_cl_is_connected(cl)) {
+ 		dev_err(bus->dev, "Already disconnected");
+ 		err = 0;
+ 		goto out;
+ 	}
+ 
+ 	err = mei_cl_disconnect(cl);
+ 	if (err < 0)
+ 		dev_err(bus->dev, "Could not disconnect from the ME client");
+ 
+ out:
+ 	/* Flush queues and remove any pending read */
+ 	mei_cl_flush_queues(cl, NULL);
+ 	mei_cl_unlink(cl);
+ 
+ 	kfree(cl);
+ 	cldev->cl = NULL;
+ 
+ 	mutex_unlock(&bus->device_lock);
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(mei_cldev_disable);
+ 
+ /**
+  * mei_cl_device_find - find matching entry in the driver id table
+  *
+  * @cldev: me client device
+  * @cldrv: me client driver
+  *
+  * Return: id on success; NULL if no id is matching
+  */
+ static const
+ struct mei_cl_device_id *mei_cl_device_find(struct mei_cl_device *cldev,
+ 					    struct mei_cl_driver *cldrv)
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  {
 +	struct mei_cl_device *device = to_mei_cl_device(dev);
 +	struct mei_cl_driver *driver = to_mei_cl_driver(drv);
  	const struct mei_cl_device_id *id;
 -	const uuid_le *uuid;
 -	u8 version;
 -	bool match;
 -
 -	uuid = mei_me_cl_uuid(cldev->me_cl);
 -	version = mei_me_cl_ver(cldev->me_cl);
 -
 -	id = cldrv->id_table;
 -	while (uuid_le_cmp(NULL_UUID_LE, id->uuid)) {
 -		if (!uuid_le_cmp(*uuid, id->uuid)) {
 -			match = true;
 -
 -			if (cldev->name[0])
 -				if (strncmp(cldev->name, id->name,
 -					    sizeof(id->name)))
 -					match = false;
 -
 -			if (id->version != MEI_CL_VERSION_ANY)
 -				if (id->version != version)
 -					match = false;
 -			if (match)
 -				return id;
 -		}
 -
 -		id++;
 -	}
 -
 -	return NULL;
 -}
 -
 -/**
 - * mei_cl_device_match  - device match function
 - *
 - * @dev: device
 - * @drv: driver
 - *
 - * Return:  1 if matching device was found 0 otherwise
 - */
 -static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
 -{
 -	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 -	struct mei_cl_driver *cldrv = to_mei_cl_driver(drv);
 -	const struct mei_cl_device_id *found_id;
  
 -	if (!cldev)
 +	if (!device)
  		return 0;
  
 -	if (!cldev->do_match)
 +	if (!driver || !driver->id_table)
  		return 0;
  
 -	if (!cldrv || !cldrv->id_table)
 -		return 0;
 +	id = driver->id_table;
 +
 +	while (id->name[0]) {
 +		if (!strncmp(dev_name(dev), id->name, sizeof(id->name)))
 +			return 1;
  
 -	found_id = mei_cl_device_find(cldev, cldrv);
 -	if (found_id)
 -		return 1;
 +		id++;
 +	}
  
  	return 0;
  }
@@@ -109,7 -663,10 +571,14 @@@ static ssize_t modalias_show(struct dev
  }
  static DEVICE_ATTR_RO(modalias);
  
++<<<<<<< HEAD
 +static struct attribute *mei_cl_dev_attrs[] = {
++=======
+ static struct attribute *mei_cldev_attrs[] = {
+ 	&dev_attr_name.attr,
+ 	&dev_attr_uuid.attr,
+ 	&dev_attr_version.attr,
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  	&dev_attr_modalias.attr,
  	NULL,
  };
@@@ -140,410 -711,259 +609,419 @@@ static struct bus_type mei_cl_bus_type 
  	.uevent		= mei_cl_device_uevent,
  };
  
 -static struct mei_device *mei_dev_bus_get(struct mei_device *bus)
 +static void mei_cl_dev_release(struct device *dev)
  {
 -	if (bus)
 -		get_device(bus->dev);
 -
 -	return bus;
 +	kfree(to_mei_cl_device(dev));
  }
  
 -static void mei_dev_bus_put(struct mei_device *bus)
 +static struct device_type mei_cl_device_type = {
 +	.release	= mei_cl_dev_release,
 +};
 +
 +static struct mei_cl *mei_bus_find_mei_cl_by_uuid(struct mei_device *dev,
 +						uuid_le uuid)
  {
 -	if (bus)
 -		put_device(bus->dev);
 -}
 +	struct mei_cl *cl;
  
 -static void mei_cl_dev_release(struct device *dev)
 +	list_for_each_entry(cl, &dev->device_list, device_link) {
 +		if (!uuid_le_cmp(uuid, cl->device_uuid))
 +			return cl;
 +	}
 +
 +	return NULL;
 +}
 +struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops)
  {
 -	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 +	struct mei_cl_device *device;
 +	struct mei_cl *cl;
 +	int status;
  
 -	if (!cldev)
 -		return;
 +	cl = mei_bus_find_mei_cl_by_uuid(dev, uuid);
 +	if (cl == NULL)
 +		return NULL;
 +
 +	device = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
 +	if (!device)
 +		return NULL;
  
 -	mei_me_cl_put(cldev->me_cl);
 -	mei_dev_bus_put(cldev->bus);
 -	kfree(cldev);
 +	device->cl = cl;
 +	device->ops = ops;
 +
 +	device->dev.parent = &dev->pdev->dev;
 +	device->dev.bus = &mei_cl_bus_type;
 +	device->dev.type = &mei_cl_device_type;
 +
 +	dev_set_name(&device->dev, "%s", name);
 +
 +	status = device_register(&device->dev);
 +	if (status) {
 +		dev_err(&dev->pdev->dev, "Failed to register MEI device\n");
 +		kfree(device);
 +		return NULL;
 +	}
 +
 +	cl->device = device;
 +
 +	dev_dbg(&device->dev, "client %s registered\n", name);
 +
 +	return device;
  }
 +EXPORT_SYMBOL_GPL(mei_cl_add_device);
  
 -static struct device_type mei_cl_device_type = {
 -	.release	= mei_cl_dev_release,
 -};
++<<<<<<< HEAD
 +void mei_cl_remove_device(struct mei_cl_device *device)
 +{
 +	device_unregister(&device->dev);
 +}
 +EXPORT_SYMBOL_GPL(mei_cl_remove_device);
  
 -/**
 - * mei_cl_dev_alloc - initialize and allocate mei client device
 - *
 - * @bus: mei device
 - * @me_cl: me client
 - *
 - * Return: allocated device structur or NULL on allocation failure
 - */
 -static struct mei_cl_device *mei_cl_dev_alloc(struct mei_device *bus,
 -					      struct mei_me_client *me_cl)
 +int __mei_cl_driver_register(struct mei_cl_driver *driver, struct module *owner)
++=======
++int __mei_cldev_driver_register(struct mei_cl_driver *cldrv,
++				struct module *owner)
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  {
 -	struct mei_cl_device *cldev;
 +	int err;
  
 -	cldev = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
 -	if (!cldev)
 -		return NULL;
 +	driver->driver.name = driver->name;
 +	driver->driver.owner = owner;
 +	driver->driver.bus = &mei_cl_bus_type;
  
 -	device_initialize(&cldev->dev);
 -	cldev->dev.parent = bus->dev;
 -	cldev->dev.bus    = &mei_cl_bus_type;
 -	cldev->dev.type   = &mei_cl_device_type;
 -	cldev->bus        = mei_dev_bus_get(bus);
 -	cldev->me_cl      = mei_me_cl_get(me_cl);
 -	cldev->is_added   = 0;
 -	INIT_LIST_HEAD(&cldev->bus_list);
 +	err = driver_register(&driver->driver);
 +	if (err)
 +		return err;
  
 -	return cldev;
 +	pr_debug("mei: driver [%s] registered\n", driver->driver.name);
 +
 +	return 0;
  }
- EXPORT_SYMBOL_GPL(__mei_cl_driver_register);
++EXPORT_SYMBOL_GPL(__mei_cldev_driver_register);
  
 -/**
 - * mei_cl_dev_setup - setup me client device
 - *    run fix up routines and set the device name
 - *
 - * @bus: mei device
 - * @cldev: me client device
 - *
 - * Return: true if the device is eligible for enumeration
 - */
 -static bool mei_cl_dev_setup(struct mei_device *bus,
 -			     struct mei_cl_device *cldev)
++<<<<<<< HEAD
 +void mei_cl_driver_unregister(struct mei_cl_driver *driver)
++=======
++void mei_cldev_driver_unregister(struct mei_cl_driver *cldrv)
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  {
 -	cldev->do_match = 1;
 -	mei_cl_dev_fixup(cldev);
 +	driver_unregister(&driver->driver);
  
 -	if (cldev->do_match)
 -		dev_set_name(&cldev->dev, "mei:%s:%pUl:%02X",
 -			     cldev->name,
 -			     mei_me_cl_uuid(cldev->me_cl),
 -			     mei_me_cl_ver(cldev->me_cl));
 +	pr_debug("mei: driver [%s] unregistered\n", driver->driver.name);
 +}
- EXPORT_SYMBOL_GPL(mei_cl_driver_unregister);
++EXPORT_SYMBOL_GPL(mei_cldev_driver_unregister);
 +
 +static int ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 +			bool blocking)
 +{
 +	struct mei_device *dev;
 +	struct mei_cl_cb *cb;
 +	int id;
 +	int rets;
  
 -	return cldev->do_match == 1;
 +	if (WARN_ON(!cl || !cl->dev))
 +		return -ENODEV;
 +
 +	dev = cl->dev;
 +
 +	if (cl->state != MEI_FILE_CONNECTED)
 +		return -ENODEV;
 +
 +	/* Check if we have an ME client device */
 +	id = mei_me_cl_by_id(dev, cl->me_client_id);
 +	if (id < 0)
 +		return id;
 +
 +	if (length > dev->me_clients[id].props.max_msg_length)
 +		return -EINVAL;
 +
 +	cb = mei_io_cb_init(cl, NULL);
 +	if (!cb)
 +		return -ENOMEM;
 +
 +	rets = mei_io_cb_alloc_req_buf(cb, length);
 +	if (rets < 0) {
 +		mei_io_cb_free(cb);
 +		return rets;
 +	}
 +
 +	memcpy(cb->request_buffer.data, buf, length);
 +
 +	mutex_lock(&dev->device_lock);
 +
 +	rets = mei_cl_write(cl, cb, blocking);
 +
 +	mutex_unlock(&dev->device_lock);
 +	if (rets < 0)
 +		mei_io_cb_free(cb);
 +
 +	return rets;
  }
  
 -/**
 - * mei_cl_bus_dev_add - add me client devices
 - *
 - * @cldev: me client device
 - *
 - * Return: 0 on success; < 0 on failre
 - */
 -static int mei_cl_bus_dev_add(struct mei_cl_device *cldev)
 +int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
  {
 -	int ret;
 +	struct mei_device *dev;
 +	struct mei_cl_cb *cb;
 +	size_t r_length;
 +	int err;
  
 -	dev_dbg(cldev->bus->dev, "adding %pUL:%02X\n",
 -		mei_me_cl_uuid(cldev->me_cl),
 -		mei_me_cl_ver(cldev->me_cl));
 -	ret = device_add(&cldev->dev);
 -	if (!ret)
 -		cldev->is_added = 1;
 +	if (WARN_ON(!cl || !cl->dev))
 +		return -ENODEV;
  
 -	return ret;
 +	dev = cl->dev;
 +
 +	mutex_lock(&dev->device_lock);
 +
 +	if (!cl->read_cb) {
 +		err = mei_cl_read_start(cl, length);
 +		if (err < 0) {
 +			mutex_unlock(&dev->device_lock);
 +			return err;
 +		}
 +	}
 +
 +	if (cl->reading_state != MEI_READ_COMPLETE &&
 +	    !waitqueue_active(&cl->rx_wait)) {
 +
 +		mutex_unlock(&dev->device_lock);
 +
 +		if (wait_event_interruptible(cl->rx_wait,
 +				cl->reading_state == MEI_READ_COMPLETE  ||
 +				mei_cl_is_transitioning(cl))) {
 +
 +			if (signal_pending(current))
 +				return -EINTR;
 +			return -ERESTARTSYS;
 +		}
 +
 +		mutex_lock(&dev->device_lock);
 +	}
 +
 +	cb = cl->read_cb;
 +
 +	if (cl->reading_state != MEI_READ_COMPLETE) {
 +		r_length = 0;
 +		goto out;
 +	}
 +
 +	r_length = min_t(size_t, length, cb->buf_idx);
 +
 +	memcpy(buf, cb->response_buffer.data, r_length);
 +
 +	mei_io_cb_free(cb);
 +	cl->reading_state = MEI_IDLE;
 +	cl->read_cb = NULL;
 +
 +out:
 +	mutex_unlock(&dev->device_lock);
 +
 +	return r_length;
  }
  
 -/**
 - * mei_cl_bus_dev_stop - stop the driver
 - *
 - * @cldev: me client device
 - */
 -static void mei_cl_bus_dev_stop(struct mei_cl_device *cldev)
 +inline int __mei_cl_async_send(struct mei_cl *cl, u8 *buf, size_t length)
  {
 -	if (cldev->is_added)
 -		device_release_driver(&cldev->dev);
 +	return ___mei_cl_send(cl, buf, length, 0);
  }
  
 -/**
 - * mei_cl_bus_dev_destroy - destroy me client devices object
 - *
 - * @cldev: me client device
 - */
 -static void mei_cl_bus_dev_destroy(struct mei_cl_device *cldev)
 +inline int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length)
  {
 -	if (!cldev->is_added)
 -		return;
 +	return ___mei_cl_send(cl, buf, length, 1);
 +}
 +
 +int mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
 +{
 +	struct mei_cl *cl = device->cl;
  
 -	device_del(&cldev->dev);
 +	if (cl == NULL)
 +		return -ENODEV;
  
 -	mutex_lock(&cldev->bus->cl_bus_lock);
 -	list_del_init(&cldev->bus_list);
 -	mutex_unlock(&cldev->bus->cl_bus_lock);
 +	if (device->ops && device->ops->send)
 +		return device->ops->send(device, buf, length);
  
 -	cldev->is_added = 0;
 -	put_device(&cldev->dev);
 +	return __mei_cl_send(cl, buf, length);
  }
 +EXPORT_SYMBOL_GPL(mei_cl_send);
  
 -/**
 - * mei_cl_bus_remove_device - remove a devices form the bus
 - *
 - * @cldev: me client device
 - */
 -static void mei_cl_bus_remove_device(struct mei_cl_device *cldev)
 +int mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length)
  {
 -	mei_cl_bus_dev_stop(cldev);
 -	mei_cl_bus_dev_destroy(cldev);
 +	struct mei_cl *cl =  device->cl;
 +
 +	if (cl == NULL)
 +		return -ENODEV;
 +
 +	if (device->ops && device->ops->recv)
 +		return device->ops->recv(device, buf, length);
 +
 +	return __mei_cl_recv(cl, buf, length);
  }
 +EXPORT_SYMBOL_GPL(mei_cl_recv);
  
 -/**
 - * mei_cl_bus_remove_devices - remove all devices form the bus
 - *
 - * @bus: mei device
 - */
 -void mei_cl_bus_remove_devices(struct mei_device *bus)
 +static void mei_bus_event_work(struct work_struct *work)
  {
 -	struct mei_cl_device *cldev, *next;
 +	struct mei_cl_device *device;
  
 -	list_for_each_entry_safe(cldev, next, &bus->device_list, bus_list)
 -		mei_cl_bus_remove_device(cldev);
 -}
 +	device = container_of(work, struct mei_cl_device, event_work);
  
 +	if (device->event_cb)
 +		device->event_cb(device, device->events, device->event_context);
  
 -/**
 - * mei_cl_dev_init - allocate and initializes an mei client devices
 - *     based on me client
 - *
 - * @bus: mei device
 - * @me_cl: me client
 - */
 -static void mei_cl_dev_init(struct mei_device *bus, struct mei_me_client *me_cl)
 +	device->events = 0;
 +
 +	/* Prepare for the next read */
 +	mei_cl_read_start(device->cl, 0);
 +}
 +
 +int mei_cl_register_event_cb(struct mei_cl_device *device,
 +			  mei_cl_event_cb_t event_cb, void *context)
  {
 -	struct mei_cl_device *cldev;
 +	if (device->event_cb)
 +		return -EALREADY;
  
 -	dev_dbg(bus->dev, "initializing %pUl", mei_me_cl_uuid(me_cl));
 +	device->events = 0;
 +	device->event_cb = event_cb;
 +	device->event_context = context;
 +	INIT_WORK(&device->event_work, mei_bus_event_work);
  
 -	if (me_cl->bus_added)
 -		return;
 +	mei_cl_read_start(device->cl, 0);
  
 -	cldev = mei_cl_dev_alloc(bus, me_cl);
 -	if (!cldev)
 -		return;
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(mei_cl_register_event_cb);
  
 -	mutex_lock(&cldev->bus->cl_bus_lock);
 -	me_cl->bus_added = true;
 -	list_add_tail(&cldev->bus_list, &bus->device_list);
 -	mutex_unlock(&cldev->bus->cl_bus_lock);
 +void *mei_cl_get_drvdata(const struct mei_cl_device *device)
 +{
 +	return dev_get_drvdata(&device->dev);
 +}
 +EXPORT_SYMBOL_GPL(mei_cl_get_drvdata);
  
 +void mei_cl_set_drvdata(struct mei_cl_device *device, void *data)
 +{
 +	dev_set_drvdata(&device->dev, data);
  }
 +EXPORT_SYMBOL_GPL(mei_cl_set_drvdata);
  
 -/**
 - * mei_cl_bus_rescan - scan me clients list and add create
 - *    devices for eligible clients
 - *
 - * @bus: mei device
 - */
 -void mei_cl_bus_rescan(struct mei_device *bus)
 +int mei_cl_enable_device(struct mei_cl_device *device)
  {
 -	struct mei_cl_device *cldev, *n;
 -	struct mei_me_client *me_cl;
 +	int err;
 +	struct mei_device *dev;
 +	struct mei_cl *cl = device->cl;
  
 -	down_read(&bus->me_clients_rwsem);
 -	list_for_each_entry(me_cl, &bus->me_clients, list)
 -		mei_cl_dev_init(bus, me_cl);
 -	up_read(&bus->me_clients_rwsem);
 +	if (cl == NULL)
 +		return -ENODEV;
  
 -	mutex_lock(&bus->cl_bus_lock);
 -	list_for_each_entry_safe(cldev, n, &bus->device_list, bus_list) {
 +	dev = cl->dev;
  
 -		if (!mei_me_cl_is_active(cldev->me_cl)) {
 -			mei_cl_bus_remove_device(cldev);
 -			continue;
 -		}
 +	mutex_lock(&dev->device_lock);
  
 -		if (cldev->is_added)
 -			continue;
 +	err = mei_cl_connect(cl, NULL);
 +	if (err < 0) {
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev, "Could not connect to the ME client");
  
 -		if (mei_cl_dev_setup(bus, cldev))
 -			mei_cl_bus_dev_add(cldev);
 -		else {
 -			list_del_init(&cldev->bus_list);
 -			put_device(&cldev->dev);
 -		}
 +		return err;
  	}
 -	mutex_unlock(&bus->cl_bus_lock);
  
 -	dev_dbg(bus->dev, "rescan end");
 +	mutex_unlock(&dev->device_lock);
 +
 +	if (device->event_cb && !cl->read_cb)
 +		mei_cl_read_start(device->cl, 0);
 +
 +	if (!device->ops || !device->ops->enable)
 +		return 0;
 +
 +	return device->ops->enable(device);
  }
 +EXPORT_SYMBOL_GPL(mei_cl_enable_device);
  
 -int __mei_cldev_driver_register(struct mei_cl_driver *cldrv,
 -				struct module *owner)
 +int mei_cl_disable_device(struct mei_cl_device *device)
  {
  	int err;
 +	struct mei_device *dev;
 +	struct mei_cl *cl = device->cl;
 +
 +	if (cl == NULL)
 +		return -ENODEV;
  
 -	cldrv->driver.name = cldrv->name;
 -	cldrv->driver.owner = owner;
 -	cldrv->driver.bus = &mei_cl_bus_type;
 +	dev = cl->dev;
 +
 +	mutex_lock(&dev->device_lock);
 +
 +	if (cl->state != MEI_FILE_CONNECTED) {
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev, "Already disconnected");
 +
 +		return 0;
 +	}
 +
 +	cl->state = MEI_FILE_DISCONNECTING;
 +
 +	err = mei_cl_disconnect(cl);
 +	if (err < 0) {
 +		mutex_unlock(&dev->device_lock);
 +		dev_err(&dev->pdev->dev,
 +			"Could not disconnect from the ME client");
  
 -	err = driver_register(&cldrv->driver);
 -	if (err)
  		return err;
 +	}
  
 -	pr_debug("mei: driver [%s] registered\n", cldrv->driver.name);
 +	/* Flush queues and remove any pending read */
 +	mei_cl_flush_queues(cl);
  
 -	return 0;
 +	if (cl->read_cb) {
 +		struct mei_cl_cb *cb = NULL;
 +
 +		cb = mei_cl_find_read_cb(cl);
 +		/* Remove entry from read list */
 +		if (cb)
 +			list_del(&cb->list);
 +
 +		cb = cl->read_cb;
 +		cl->read_cb = NULL;
 +
 +		if (cb) {
 +			mei_io_cb_free(cb);
 +			cb = NULL;
 +		}
 +	}
 +
 +	device->event_cb = NULL;
 +
 +	mutex_unlock(&dev->device_lock);
 +
 +	if (!device->ops || !device->ops->disable)
 +		return 0;
 +
 +	return device->ops->disable(device);
  }
 -EXPORT_SYMBOL_GPL(__mei_cldev_driver_register);
 +EXPORT_SYMBOL_GPL(mei_cl_disable_device);
  
 -void mei_cldev_driver_unregister(struct mei_cl_driver *cldrv)
 +void mei_cl_bus_rx_event(struct mei_cl *cl)
  {
 -	driver_unregister(&cldrv->driver);
 +	struct mei_cl_device *device = cl->device;
  
 -	pr_debug("mei: driver [%s] unregistered\n", cldrv->driver.name);
 +	if (!device || !device->event_cb)
 +		return;
 +
 +	set_bit(MEI_CL_EVENT_RX, &device->events);
 +
 +	schedule_work(&device->event_work);
  }
 -EXPORT_SYMBOL_GPL(mei_cldev_driver_unregister);
  
 +void mei_cl_bus_remove_devices(struct mei_device *dev)
 +{
 +	struct mei_cl *cl, *next;
 +
 +	mutex_lock(&dev->device_lock);
 +	list_for_each_entry_safe(cl, next, &dev->device_list, device_link) {
 +		if (cl->device)
 +			mei_cl_remove_device(cl->device);
 +
 +		list_del(&cl->device_link);
 +		mei_cl_unlink(cl);
 +		kfree(cl);
 +	}
 +	mutex_unlock(&dev->device_lock);
 +}
  
  int __init mei_cl_bus_init(void)
  {
diff --cc drivers/nfc/mei_phy.c
index 606bf55e76ec,83deda4bb4d6..000000000000
--- a/drivers/nfc/mei_phy.c
+++ b/drivers/nfc/mei_phy.c
@@@ -55,41 -112,148 +55,151 @@@ int nfc_mei_phy_enable(void *phy_id
  
  	pr_info("%s\n", __func__);
  
 -	memset(&cmd, 0, sizeof(struct mei_nfc_cmd));
 -	cmd.hdr.cmd = MEI_NFC_CMD_MAINTENANCE;
 -	cmd.hdr.data_size = 1;
 -	cmd.sub_command = MEI_NFC_SUBCMD_IF_VERSION;
 +	if (phy->powered == 1)
 +		return 0;
  
++<<<<<<< HEAD
 +	r = mei_cl_enable_device(phy->device);
++=======
+ 	MEI_DUMP_NFC_HDR("version", &cmd.hdr);
+ 	r = mei_cldev_send(phy->cldev, (u8 *)&cmd, sizeof(struct mei_nfc_cmd));
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  	if (r < 0) {
 -		pr_err("Could not send IF version cmd\n");
 +		pr_err("MEI_PHY: Could not enable device\n");
  		return r;
  	}
  
 -	/* to be sure on the stack we alloc memory */
 -	if_version_length = sizeof(struct mei_nfc_reply) +
 -		sizeof(struct mei_nfc_if_version);
 +	r = mei_cl_register_event_cb(phy->device, nfc_mei_event_cb, phy);
 +	if (r) {
 +		pr_err("MEY_PHY: Event cb registration failed\n");
 +		mei_cl_disable_device(phy->device);
 +		phy->powered = 0;
  
++<<<<<<< HEAD
 +		return r;
++=======
+ 	reply = kzalloc(if_version_length, GFP_KERNEL);
+ 	if (!reply)
+ 		return -ENOMEM;
+ 
+ 	bytes_recv = mei_cldev_recv(phy->cldev, (u8 *)reply, if_version_length);
+ 	if (bytes_recv < 0 || bytes_recv < sizeof(struct mei_nfc_reply)) {
+ 		pr_err("Could not read IF version\n");
+ 		r = -EIO;
+ 		goto err;
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  	}
  
 -	version = (struct mei_nfc_if_version *)reply->data;
 -
 -	phy->fw_ivn = version->fw_ivn;
 -	phy->vendor_id = version->vendor_id;
 -	phy->radio_type = version->radio_type;
 +	phy->powered = 1;
  
 -err:
 -	kfree(reply);
 -	return r;
 +	return 0;
  }
 +EXPORT_SYMBOL_GPL(nfc_mei_phy_enable);
  
 -static int mei_nfc_connect(struct nfc_mei_phy *phy)
 +void nfc_mei_phy_disable(void *phy_id)
  {
 -	struct mei_nfc_cmd *cmd, *reply;
 -	struct mei_nfc_connect *connect;
 -	struct mei_nfc_connect_resp *connect_resp;
 -	size_t connect_length, connect_resp_length;
 -	int bytes_recv, r;
 +	struct nfc_mei_phy *phy = phy_id;
  
  	pr_info("%s\n", __func__);
  
 -	connect_length = sizeof(struct mei_nfc_cmd) +
 -			sizeof(struct mei_nfc_connect);
 +	mei_cl_disable_device(phy->device);
  
++<<<<<<< HEAD
 +	phy->powered = 0;
++=======
+ 	connect_resp_length = sizeof(struct mei_nfc_cmd) +
+ 			sizeof(struct mei_nfc_connect_resp);
+ 
+ 	cmd = kzalloc(connect_length, GFP_KERNEL);
+ 	if (!cmd)
+ 		return -ENOMEM;
+ 	connect = (struct mei_nfc_connect *)cmd->data;
+ 
+ 	reply = kzalloc(connect_resp_length, GFP_KERNEL);
+ 	if (!reply) {
+ 		kfree(cmd);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	connect_resp = (struct mei_nfc_connect_resp *)reply->data;
+ 
+ 	cmd->hdr.cmd = MEI_NFC_CMD_MAINTENANCE;
+ 	cmd->hdr.data_size = 3;
+ 	cmd->sub_command = MEI_NFC_SUBCMD_CONNECT;
+ 	connect->fw_ivn = phy->fw_ivn;
+ 	connect->vendor_id = phy->vendor_id;
+ 
+ 	MEI_DUMP_NFC_HDR("connect request", &cmd->hdr);
+ 	r = mei_cldev_send(phy->cldev, (u8 *)cmd, connect_length);
+ 	if (r < 0) {
+ 		pr_err("Could not send connect cmd %d\n", r);
+ 		goto err;
+ 	}
+ 
+ 	bytes_recv = mei_cldev_recv(phy->cldev, (u8 *)reply,
+ 				    connect_resp_length);
+ 	if (bytes_recv < 0) {
+ 		r = bytes_recv;
+ 		pr_err("Could not read connect response %d\n", r);
+ 		goto err;
+ 	}
+ 
+ 	MEI_DUMP_NFC_HDR("connect reply", &reply->hdr);
+ 
+ 	pr_info("IVN 0x%x Vendor ID 0x%x\n",
+ 		 connect_resp->fw_ivn, connect_resp->vendor_id);
+ 
+ 	pr_info("ME FW %d.%d.%d.%d\n",
+ 		connect_resp->me_major, connect_resp->me_minor,
+ 		connect_resp->me_hotfix, connect_resp->me_build);
+ 
+ 	r = 0;
+ 
+ err:
+ 	kfree(reply);
+ 	kfree(cmd);
+ 
+ 	return r;
+ }
+ 
+ static int mei_nfc_send(struct nfc_mei_phy *phy, u8 *buf, size_t length)
+ {
+ 	struct mei_nfc_hdr *hdr;
+ 	u8 *mei_buf;
+ 	int err;
+ 
+ 	err = -ENOMEM;
+ 	mei_buf = kzalloc(length + MEI_NFC_HEADER_SIZE, GFP_KERNEL);
+ 	if (!mei_buf)
+ 		goto out;
+ 
+ 	hdr = (struct mei_nfc_hdr *)mei_buf;
+ 	hdr->cmd = MEI_NFC_CMD_HCI_SEND;
+ 	hdr->status = 0;
+ 	hdr->req_id = phy->req_id;
+ 	hdr->reserved = 0;
+ 	hdr->data_size = length;
+ 
+ 	MEI_DUMP_NFC_HDR("send", hdr);
+ 
+ 	memcpy(mei_buf + MEI_NFC_HEADER_SIZE, buf, length);
+ 	err = mei_cldev_send(phy->cldev, mei_buf, length + MEI_NFC_HEADER_SIZE);
+ 	if (err < 0)
+ 		goto out;
+ 
+ 	if (!wait_event_interruptible_timeout(phy->send_wq,
+ 				phy->recv_req_id == phy->req_id, HZ)) {
+ 		pr_err("NFC MEI command timeout\n");
+ 		err = -ETIME;
+ 	} else {
+ 		phy->req_id++;
+ 	}
+ out:
+ 	kfree(mei_buf);
+ 	return err;
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  }
 +EXPORT_SYMBOL_GPL(nfc_mei_phy_disable);
  
  /*
   * Writing a frame must not return the number of written bytes.
@@@ -110,7 -274,31 +220,35 @@@ static int nfc_mei_phy_write(void *phy_
  	return r;
  }
  
++<<<<<<< HEAD
 +void nfc_mei_event_cb(struct mei_cl_device *device, u32 events, void *context)
++=======
+ static int mei_nfc_recv(struct nfc_mei_phy *phy, u8 *buf, size_t length)
+ {
+ 	struct mei_nfc_hdr *hdr;
+ 	int received_length;
+ 
+ 	received_length = mei_cldev_recv(phy->cldev, buf, length);
+ 	if (received_length < 0)
+ 		return received_length;
+ 
+ 	hdr = (struct mei_nfc_hdr *) buf;
+ 
+ 	MEI_DUMP_NFC_HDR("receive", hdr);
+ 	if (hdr->cmd == MEI_NFC_CMD_HCI_SEND) {
+ 		phy->recv_req_id = hdr->req_id;
+ 		wake_up(&phy->send_wq);
+ 
+ 		return 0;
+ 	}
+ 
+ 	return received_length;
+ }
+ 
+ 
+ static void nfc_mei_event_cb(struct mei_cl_device *cldev, u32 events,
+ 			     void *context)
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  {
  	struct nfc_mei_phy *phy = context;
  
@@@ -139,7 -327,62 +277,66 @@@
  		nfc_hci_recv_frame(phy->hdev, skb);
  	}
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(nfc_mei_event_cb);
++=======
+ 
+ static int nfc_mei_phy_enable(void *phy_id)
+ {
+ 	int r;
+ 	struct nfc_mei_phy *phy = phy_id;
+ 
+ 	pr_info("%s\n", __func__);
+ 
+ 	if (phy->powered == 1)
+ 		return 0;
+ 
+ 	r = mei_cldev_enable(phy->cldev);
+ 	if (r < 0) {
+ 		pr_err("Could not enable device %d\n", r);
+ 		return r;
+ 	}
+ 
+ 	r = mei_nfc_if_version(phy);
+ 	if (r < 0) {
+ 		pr_err("Could not enable device %d\n", r);
+ 		goto err;
+ 	}
+ 
+ 	r = mei_nfc_connect(phy);
+ 	if (r < 0) {
+ 		pr_err("Could not connect to device %d\n", r);
+ 		goto err;
+ 	}
+ 
+ 	r = mei_cldev_register_event_cb(phy->cldev, BIT(MEI_CL_EVENT_RX),
+ 				     nfc_mei_event_cb, phy);
+ 	if (r) {
+ 		pr_err("Event cb registration failed %d\n", r);
+ 		goto err;
+ 	}
+ 
+ 	phy->powered = 1;
+ 
+ 	return 0;
+ 
+ err:
+ 	phy->powered = 0;
+ 	mei_cldev_disable(phy->cldev);
+ 	return r;
+ }
+ 
+ static void nfc_mei_phy_disable(void *phy_id)
+ {
+ 	struct nfc_mei_phy *phy = phy_id;
+ 
+ 	pr_info("%s\n", __func__);
+ 
+ 	mei_cldev_disable(phy->cldev);
+ 
+ 	phy->powered = 0;
+ }
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  
  struct nfc_phy_ops mei_phy_ops = {
  	.write = nfc_mei_phy_write,
@@@ -156,8 -399,9 +353,14 @@@ struct nfc_mei_phy *nfc_mei_phy_alloc(s
  	if (!phy)
  		return NULL;
  
++<<<<<<< HEAD
 +	phy->device = device;
 +	mei_cl_set_drvdata(device, phy);
++=======
+ 	phy->cldev = cldev;
+ 	init_waitqueue_head(&phy->send_wq);
+ 	mei_cldev_set_drvdata(cldev, phy);
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  
  	return phy;
  }
@@@ -165,6 -409,7 +368,10 @@@ EXPORT_SYMBOL_GPL(nfc_mei_phy_alloc)
  
  void nfc_mei_phy_free(struct nfc_mei_phy *phy)
  {
++<<<<<<< HEAD
++=======
+ 	mei_cldev_disable(phy->cldev);
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  	kfree(phy);
  }
  EXPORT_SYMBOL_GPL(nfc_mei_phy_free);
diff --cc drivers/nfc/microread/mei.c
index cdf1bc53b257,3092501f26c4..000000000000
--- a/drivers/nfc/microread/mei.c
+++ b/drivers/nfc/microread/mei.c
@@@ -55,11 -55,9 +55,15 @@@ static int microread_mei_probe(struct m
  	return 0;
  }
  
 -static int microread_mei_remove(struct mei_cl_device *cldev)
 +static int microread_mei_remove(struct mei_cl_device *device)
  {
++<<<<<<< HEAD
 +	struct nfc_mei_phy *phy = mei_cl_get_drvdata(device);
 +
 +	pr_info("Removing microread\n");
++=======
+ 	struct nfc_mei_phy *phy = mei_cldev_get_drvdata(cldev);
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  
  	microread_remove(phy->hdev);
  
diff --cc drivers/nfc/pn544/mei.c
index b5d3d18179eb,46d0eb24eef9..000000000000
--- a/drivers/nfc/pn544/mei.c
+++ b/drivers/nfc/pn544/mei.c
@@@ -55,9 -53,9 +55,13 @@@ static int pn544_mei_probe(struct mei_c
  	return 0;
  }
  
 -static int pn544_mei_remove(struct mei_cl_device *cldev)
 +static int pn544_mei_remove(struct mei_cl_device *device)
  {
++<<<<<<< HEAD
 +	struct nfc_mei_phy *phy = mei_cl_get_drvdata(device);
++=======
+ 	struct nfc_mei_phy *phy = mei_cldev_get_drvdata(cldev);
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  
  	pr_info("Removing pn544\n");
  
diff --cc include/linux/mei_cl_bus.h
index d14af7b722ef,e746919530f5..000000000000
--- a/include/linux/mei_cl_bus.h
+++ b/include/linux/mei_cl_bus.h
@@@ -3,8 -3,58 +3,60 @@@
  
  #include <linux/device.h>
  #include <linux/uuid.h>
 -#include <linux/mod_devicetable.h>
  
  struct mei_cl_device;
++<<<<<<< HEAD
++=======
+ struct mei_device;
+ 
+ typedef void (*mei_cldev_event_cb_t)(struct mei_cl_device *cldev,
+ 				     u32 events, void *context);
+ 
+ /**
+  * struct mei_cl_device - MEI device handle
+  * An mei_cl_device pointer is returned from mei_add_device()
+  * and links MEI bus clients to their actual ME host client pointer.
+  * Drivers for MEI devices will get an mei_cl_device pointer
+  * when being probed and shall use it for doing ME bus I/O.
+  *
+  * @bus_list: device on the bus list
+  * @bus: parent mei device
+  * @dev: linux driver model device pointer
+  * @me_cl: me client
+  * @cl: mei client
+  * @name: device name
+  * @event_work: async work to execute event callback
+  * @event_cb: Drivers register this callback to get asynchronous ME
+  *	events (e.g. Rx buffer pending) notifications.
+  * @event_context: event callback run context
+  * @events_mask: Events bit mask requested by driver.
+  * @events: Events bitmask sent to the driver.
+  *
+  * @do_match: wheather device can be matched with a driver
+  * @is_added: device is already scanned
+  * @priv_data: client private data
+  */
+ struct mei_cl_device {
+ 	struct list_head bus_list;
+ 	struct mei_device *bus;
+ 	struct device dev;
+ 
+ 	struct mei_me_client *me_cl;
+ 	struct mei_cl *cl;
+ 	char name[MEI_CL_NAME_SIZE];
+ 
+ 	struct work_struct event_work;
+ 	mei_cldev_event_cb_t event_cb;
+ 	void *event_context;
+ 	unsigned long events_mask;
+ 	unsigned long events;
+ 
+ 	unsigned int do_match:1;
+ 	unsigned int is_added:1;
+ 
+ 	void *priv_data;
+ };
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  
  struct mei_cl_driver {
  	struct device_driver driver;
@@@ -12,33 -62,37 +64,58 @@@
  
  	const struct mei_cl_device_id *id_table;
  
 -	int (*probe)(struct mei_cl_device *cldev,
 +	int (*probe)(struct mei_cl_device *dev,
  		     const struct mei_cl_device_id *id);
 -	int (*remove)(struct mei_cl_device *cldev);
 +	int (*remove)(struct mei_cl_device *dev);
  };
  
++<<<<<<< HEAD
 +int __mei_cl_driver_register(struct mei_cl_driver *driver,
 +				struct module *owner);
 +#define mei_cl_driver_register(driver)             \
 +	__mei_cl_driver_register(driver, THIS_MODULE)
 +
 +void mei_cl_driver_unregister(struct mei_cl_driver *driver);
 +
 +int mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length);
 +int mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length);
 +
 +typedef void (*mei_cl_event_cb_t)(struct mei_cl_device *device,
 +			       u32 events, void *context);
 +int mei_cl_register_event_cb(struct mei_cl_device *device,
 +			  mei_cl_event_cb_t read_cb, void *context);
++=======
+ int __mei_cldev_driver_register(struct mei_cl_driver *cldrv,
+ 				struct module *owner);
+ #define mei_cldev_driver_register(cldrv)             \
+ 	__mei_cldev_driver_register(cldrv, THIS_MODULE)
+ 
+ void mei_cldev_driver_unregister(struct mei_cl_driver *cldrv);
+ 
+ ssize_t mei_cldev_send(struct mei_cl_device *cldev, u8 *buf, size_t length);
+ ssize_t  mei_cldev_recv(struct mei_cl_device *cldev, u8 *buf, size_t length);
+ 
+ int mei_cldev_register_event_cb(struct mei_cl_device *cldev,
+ 				unsigned long event_mask,
+ 				mei_cldev_event_cb_t read_cb, void *context);
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  
  #define MEI_CL_EVENT_RX 0
  #define MEI_CL_EVENT_TX 1
 -#define MEI_CL_EVENT_NOTIF 2
  
 -const uuid_le *mei_cldev_uuid(const struct mei_cl_device *cldev);
 -u8 mei_cldev_ver(const struct mei_cl_device *cldev);
 +void *mei_cl_get_drvdata(const struct mei_cl_device *device);
 +void mei_cl_set_drvdata(struct mei_cl_device *device, void *data);
  
++<<<<<<< HEAD
 +int mei_cl_enable_device(struct mei_cl_device *device);
 +int mei_cl_disable_device(struct mei_cl_device *device);
++=======
+ void *mei_cldev_get_drvdata(const struct mei_cl_device *cldev);
+ void mei_cldev_set_drvdata(struct mei_cl_device *cldev, void *data);
+ 
+ int mei_cldev_enable(struct mei_cl_device *cldev);
+ int mei_cldev_disable(struct mei_cl_device *cldev);
+ bool mei_cldev_enabled(struct mei_cl_device *cldev);
++>>>>>>> d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
  
  #endif /* _LINUX_MEI_CL_BUS_H */
* Unmerged path drivers/misc/mei/bus.c
* Unmerged path drivers/nfc/mei_phy.c
* Unmerged path drivers/nfc/microread/mei.c
* Unmerged path drivers/nfc/pn544/mei.c
* Unmerged path include/linux/mei_cl_bus.h
