KVM: svm: do not call kvm_set_cr0 from init_vmcb

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 79a8059d244e99454e474902e4325ee9b50e9178
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/79a8059d.failed

kvm_set_cr0 may want to call kvm_zap_gfn_range and thus access the
memslots array (SRCU protected).  Using a mini SRCU critical section
is ugly, and adding it to kvm_arch_vcpu_create doesn't work because
the VMX vcpu_create callback calls synchronize_srcu.

Fixes this lockdep splat:

===============================
[ INFO: suspicious RCU usage. ]
4.3.0-rc1+ #1 Not tainted
-------------------------------
include/linux/kvm_host.h:488 suspicious rcu_dereference_check() usage!

other info that might help us debug this:
rcu_scheduler_active = 1, debug_locks = 0
1 lock held by qemu-system-i38/17000:
 #0:  (&(&kvm->mmu_lock)->rlock){+.+...}, at: kvm_zap_gfn_range+0x24/0x1a0 [kvm]

[...]
Call Trace:
 dump_stack+0x4e/0x84
 lockdep_rcu_suspicious+0xfd/0x130
 kvm_zap_gfn_range+0x188/0x1a0 [kvm]
 kvm_set_cr0+0xde/0x1e0 [kvm]
 init_vmcb+0x760/0xad0 [kvm_amd]
 svm_create_vcpu+0x197/0x250 [kvm_amd]
 kvm_arch_vcpu_create+0x47/0x70 [kvm]
 kvm_vm_ioctl+0x302/0x7e0 [kvm]
 ? __lock_is_held+0x51/0x70
 ? __fget+0x101/0x210
 do_vfs_ioctl+0x2f4/0x560
 ? __fget_light+0x29/0x90
 SyS_ioctl+0x4c/0x90
 entry_SYSCALL_64_fastpath+0x16/0x73

	Reported-by: Borislav Petkov <bp@alien8.de>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 79a8059d244e99454e474902e4325ee9b50e9178)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm.c
diff --cc arch/x86/kvm/svm.c
index 9d6cd92386ab,94b7d15db3fc..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -199,9 -199,10 +199,10 @@@ static int npt = true
  module_param(npt, int, S_IRUGO);
  
  /* allow nested virtualization in KVM/SVM */
 -static int nested = true;
 +static int nested = false;
  module_param(nested, int, S_IRUGO);
  
+ static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);
  static void svm_flush_tlb(struct kvm_vcpu *vcpu);
  static void svm_complete_interrupts(struct vcpu_svm *svm);
  
@@@ -1163,11 -1261,10 +1164,15 @@@ static void init_vmcb(struct vcpu_svm *
  	svm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;
  
  	/*
 +	 * This is the guest-visible cr0 value.
  	 * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.
 -	 * It also updates the guest-visible cr0 value.
  	 */
++<<<<<<< HEAD
 +	svm->vcpu.arch.cr0 = 0;
 +	(void)kvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);
++=======
+ 	svm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);
++>>>>>>> 79a8059d244e (KVM: svm: do not call kvm_set_cr0 from init_vmcb)
  	kvm_mmu_reset_context(&svm->vcpu);
  
  	save->cr4 = X86_CR4_PAE;
* Unmerged path arch/x86/kvm/svm.c
