hv_netvsc: use start_remove flag to protect netvsc_link_change()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 1bdcec8a5f05445752a0639edd603ac09ae6c553
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1bdcec8a.failed

netvsc_link_change() can race with netvsc_change_mtu() or
netvsc_set_channels() as these functions destroy struct netvsc_device and
rndis filter. Use start_remove flag for syncronization. As
netvsc_change_mtu()/netvsc_set_channels() are called with rtnl lock held
we need to take it before checking start_remove value in
netvsc_link_change().

	Reported-by: Haiyang Zhang <haiyangz@microsoft.com>
	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1bdcec8a5f05445752a0639edd603ac09ae6c553)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index 822e657fcee7,01de2dcef170..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -728,6 -752,159 +728,162 @@@ static void netvsc_get_channels(struct 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int netvsc_set_channels(struct net_device *net,
+ 			       struct ethtool_channels *channels)
+ {
+ 	struct net_device_context *net_device_ctx = netdev_priv(net);
+ 	struct hv_device *dev = net_device_ctx->device_ctx;
+ 	struct netvsc_device *nvdev = hv_get_drvdata(dev);
+ 	struct netvsc_device_info device_info;
+ 	u32 num_chn;
+ 	u32 max_chn;
+ 	int ret = 0;
+ 	bool recovering = false;
+ 
+ 	if (!nvdev || nvdev->destroy)
+ 		return -ENODEV;
+ 
+ 	num_chn = nvdev->num_chn;
+ 	max_chn = min_t(u32, nvdev->max_chn, num_online_cpus());
+ 
+ 	if (nvdev->nvsp_version < NVSP_PROTOCOL_VERSION_5) {
+ 		pr_info("vRSS unsupported before NVSP Version 5\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* We do not support rx, tx, or other */
+ 	if (!channels ||
+ 	    channels->rx_count ||
+ 	    channels->tx_count ||
+ 	    channels->other_count ||
+ 	    (channels->combined_count < 1))
+ 		return -EINVAL;
+ 
+ 	if (channels->combined_count > max_chn) {
+ 		pr_info("combined channels too high, using %d\n", max_chn);
+ 		channels->combined_count = max_chn;
+ 	}
+ 
+ 	ret = netvsc_close(net);
+ 	if (ret)
+ 		goto out;
+ 
+  do_set:
+ 	net_device_ctx->start_remove = true;
+ 	rndis_filter_device_remove(dev);
+ 
+ 	nvdev->num_chn = channels->combined_count;
+ 
+ 	net_device_ctx->device_ctx = dev;
+ 	hv_set_drvdata(dev, net);
+ 
+ 	memset(&device_info, 0, sizeof(device_info));
+ 	device_info.num_chn = nvdev->num_chn; /* passed to RNDIS */
+ 	device_info.ring_size = ring_size;
+ 	device_info.max_num_vrss_chns = max_num_vrss_chns;
+ 
+ 	ret = rndis_filter_device_add(dev, &device_info);
+ 	if (ret) {
+ 		if (recovering) {
+ 			netdev_err(net, "unable to add netvsc device (ret %d)\n", ret);
+ 			return ret;
+ 		}
+ 		goto recover;
+ 	}
+ 
+ 	nvdev = hv_get_drvdata(dev);
+ 
+ 	ret = netif_set_real_num_tx_queues(net, nvdev->num_chn);
+ 	if (ret) {
+ 		if (recovering) {
+ 			netdev_err(net, "could not set tx queue count (ret %d)\n", ret);
+ 			return ret;
+ 		}
+ 		goto recover;
+ 	}
+ 
+ 	ret = netif_set_real_num_rx_queues(net, nvdev->num_chn);
+ 	if (ret) {
+ 		if (recovering) {
+ 			netdev_err(net, "could not set rx queue count (ret %d)\n", ret);
+ 			return ret;
+ 		}
+ 		goto recover;
+ 	}
+ 
+  out:
+ 	netvsc_open(net);
+ 	net_device_ctx->start_remove = false;
+ 	/* We may have missed link change notifications */
+ 	schedule_delayed_work(&net_device_ctx->dwork, 0);
+ 
+ 	return ret;
+ 
+  recover:
+ 	/* If the above failed, we attempt to recover through the same
+ 	 * process but with the original number of channels.
+ 	 */
+ 	netdev_err(net, "could not set channels, recovering\n");
+ 	recovering = true;
+ 	channels->combined_count = num_chn;
+ 	goto do_set;
+ }
+ 
+ static bool netvsc_validate_ethtool_ss_cmd(const struct ethtool_cmd *cmd)
+ {
+ 	struct ethtool_cmd diff1 = *cmd;
+ 	struct ethtool_cmd diff2 = {};
+ 
+ 	ethtool_cmd_speed_set(&diff1, 0);
+ 	diff1.duplex = 0;
+ 	/* advertising and cmd are usually set */
+ 	diff1.advertising = 0;
+ 	diff1.cmd = 0;
+ 	/* We set port to PORT_OTHER */
+ 	diff2.port = PORT_OTHER;
+ 
+ 	return !memcmp(&diff1, &diff2, sizeof(diff1));
+ }
+ 
+ static void netvsc_init_settings(struct net_device *dev)
+ {
+ 	struct net_device_context *ndc = netdev_priv(dev);
+ 
+ 	ndc->speed = SPEED_UNKNOWN;
+ 	ndc->duplex = DUPLEX_UNKNOWN;
+ }
+ 
+ static int netvsc_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+ {
+ 	struct net_device_context *ndc = netdev_priv(dev);
+ 
+ 	ethtool_cmd_speed_set(cmd, ndc->speed);
+ 	cmd->duplex = ndc->duplex;
+ 	cmd->port = PORT_OTHER;
+ 
+ 	return 0;
+ }
+ 
+ static int netvsc_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+ {
+ 	struct net_device_context *ndc = netdev_priv(dev);
+ 	u32 speed;
+ 
+ 	speed = ethtool_cmd_speed(cmd);
+ 	if (!ethtool_validate_speed(speed) ||
+ 	    !ethtool_validate_duplex(cmd->duplex) ||
+ 	    !netvsc_validate_ethtool_ss_cmd(cmd))
+ 		return -EINVAL;
+ 
+ 	ndc->speed = speed;
+ 	ndc->duplex = cmd->duplex;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 1bdcec8a5f05 (hv_netvsc: use start_remove flag to protect netvsc_link_change())
  static int netvsc_change_mtu(struct net_device *ndev, int mtu)
  {
  	struct net_device_context *ndevctx = netdev_priv(ndev);
@@@ -762,7 -946,11 +918,10 @@@
  
  out:
  	netvsc_open(ndev);
 -	ndevctx->start_remove = false;
  
+ 	/* We may have missed link change notifications */
+ 	schedule_delayed_work(&ndevctx->dwork, 0);
+ 
  	return ret;
  }
  
@@@ -836,29 -1066,276 +995,111 @@@ static void netvsc_link_change(struct w
  	struct net_device *net;
  	struct netvsc_device *net_device;
  	struct rndis_device *rdev;
 -	struct netvsc_reconfig *event = NULL;
 -	bool notify = false, reschedule = false;
 -	unsigned long flags, next_reconfig, delay;
 +	bool notify;
 +
 +	rtnl_lock();
  
  	ndev_ctx = container_of(w, struct net_device_context, dwork.work);
+ 
+ 	rtnl_lock();
+ 	if (ndev_ctx->start_remove)
+ 		goto out_unlock;
+ 
  	net_device = hv_get_drvdata(ndev_ctx->device_ctx);
  	rdev = net_device->extension;
  	net = net_device->ndev;
  
++<<<<<<< HEAD
 +	if (rdev->link_state) {
 +		netif_carrier_off(net);
 +		notify = false;
 +	} else {
 +		netif_carrier_on(net);
 +		notify = true;
++=======
+ 	next_reconfig = ndev_ctx->last_reconfig + LINKCHANGE_INT;
+ 	if (time_is_after_jiffies(next_reconfig)) {
+ 		/* link_watch only sends one notification with current state
+ 		 * per second, avoid doing reconfig more frequently. Handle
+ 		 * wrap around.
+ 		 */
+ 		delay = next_reconfig - jiffies;
+ 		delay = delay < LINKCHANGE_INT ? delay : LINKCHANGE_INT;
+ 		schedule_delayed_work(&ndev_ctx->dwork, delay);
+ 		goto out_unlock;
+ 	}
+ 	ndev_ctx->last_reconfig = jiffies;
+ 
+ 	spin_lock_irqsave(&ndev_ctx->lock, flags);
+ 	if (!list_empty(&ndev_ctx->reconfig_events)) {
+ 		event = list_first_entry(&ndev_ctx->reconfig_events,
+ 					 struct netvsc_reconfig, list);
+ 		list_del(&event->list);
+ 		reschedule = !list_empty(&ndev_ctx->reconfig_events);
+ 	}
+ 	spin_unlock_irqrestore(&ndev_ctx->lock, flags);
+ 
+ 	if (!event)
+ 		goto out_unlock;
+ 
+ 	switch (event->event) {
+ 		/* Only the following events are possible due to the check in
+ 		 * netvsc_linkstatus_callback()
+ 		 */
+ 	case RNDIS_STATUS_MEDIA_CONNECT:
+ 		if (rdev->link_state) {
+ 			rdev->link_state = false;
+ 			netif_carrier_on(net);
+ 			netif_tx_wake_all_queues(net);
+ 		} else {
+ 			notify = true;
+ 		}
+ 		kfree(event);
+ 		break;
+ 	case RNDIS_STATUS_MEDIA_DISCONNECT:
+ 		if (!rdev->link_state) {
+ 			rdev->link_state = true;
+ 			netif_carrier_off(net);
+ 			netif_tx_stop_all_queues(net);
+ 		}
+ 		kfree(event);
+ 		break;
+ 	case RNDIS_STATUS_NETWORK_CHANGE:
+ 		/* Only makes sense if carrier is present */
+ 		if (!rdev->link_state) {
+ 			rdev->link_state = true;
+ 			netif_carrier_off(net);
+ 			netif_tx_stop_all_queues(net);
+ 			event->event = RNDIS_STATUS_MEDIA_CONNECT;
+ 			spin_lock_irqsave(&ndev_ctx->lock, flags);
+ 			list_add(&event->list, &ndev_ctx->reconfig_events);
+ 			spin_unlock_irqrestore(&ndev_ctx->lock, flags);
+ 			reschedule = true;
+ 		}
+ 		break;
++>>>>>>> 1bdcec8a5f05 (hv_netvsc: use start_remove flag to protect netvsc_link_change())
  	}
  
  	rtnl_unlock();
  
  	if (notify)
  		netdev_notify_peers(net);
++<<<<<<< HEAD
++=======
+ 
+ 	/* link_watch only sends one notification with current state per
+ 	 * second, handle next reconfig event in 2 seconds.
+ 	 */
+ 	if (reschedule)
+ 		schedule_delayed_work(&ndev_ctx->dwork, LINKCHANGE_INT);
+ 
+ 	return;
+ 
+ out_unlock:
+ 	rtnl_unlock();
++>>>>>>> 1bdcec8a5f05 (hv_netvsc: use start_remove flag to protect netvsc_link_change())
  }
  
 -static void netvsc_free_netdev(struct net_device *netdev)
 -{
 -	struct net_device_context *net_device_ctx = netdev_priv(netdev);
 -
 -	free_percpu(net_device_ctx->tx_stats);
 -	free_percpu(net_device_ctx->rx_stats);
 -	free_netdev(netdev);
 -}
 -
 -static void netvsc_notify_peers(struct work_struct *wrk)
 -{
 -	struct garp_wrk *gwrk;
 -
 -	gwrk = container_of(wrk, struct garp_wrk, dwrk);
 -
 -	netdev_notify_peers(gwrk->netdev);
 -
 -	atomic_dec(&gwrk->netvsc_dev->vf_use_cnt);
 -}
 -
 -static struct netvsc_device *get_netvsc_device(char *mac)
 -{
 -	struct net_device *dev;
 -	struct net_device_context *netvsc_ctx = NULL;
 -	int rtnl_locked;
 -
 -	rtnl_locked = rtnl_trylock();
 -
 -	for_each_netdev(&init_net, dev) {
 -		if (memcmp(dev->dev_addr, mac, ETH_ALEN) == 0) {
 -			if (dev->netdev_ops != &device_ops)
 -				continue;
 -			netvsc_ctx = netdev_priv(dev);
 -			break;
 -		}
 -	}
 -	if (rtnl_locked)
 -		rtnl_unlock();
 -
 -	if (netvsc_ctx == NULL)
 -		return NULL;
 -
 -	return hv_get_drvdata(netvsc_ctx->device_ctx);
 -}
 -
 -static int netvsc_register_vf(struct net_device *vf_netdev)
 -{
 -	struct netvsc_device *netvsc_dev;
 -	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
 -
 -	if (eth_ops == NULL || eth_ops == &ethtool_ops)
 -		return NOTIFY_DONE;
 -
 -	/*
 -	 * We will use the MAC address to locate the synthetic interface to
 -	 * associate with the VF interface. If we don't find a matching
 -	 * synthetic interface, move on.
 -	 */
 -	netvsc_dev = get_netvsc_device(vf_netdev->dev_addr);
 -	if (netvsc_dev == NULL)
 -		return NOTIFY_DONE;
 -
 -	netdev_info(netvsc_dev->ndev, "VF registering: %s\n", vf_netdev->name);
 -	/*
 -	 * Take a reference on the module.
 -	 */
 -	try_module_get(THIS_MODULE);
 -	netvsc_dev->vf_netdev = vf_netdev;
 -	return NOTIFY_OK;
 -}
 -
 -
 -static int netvsc_vf_up(struct net_device *vf_netdev)
 -{
 -	struct netvsc_device *netvsc_dev;
 -	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
 -	struct net_device_context *net_device_ctx;
 -
 -	if (eth_ops == &ethtool_ops)
 -		return NOTIFY_DONE;
 -
 -	netvsc_dev = get_netvsc_device(vf_netdev->dev_addr);
 -
 -	if ((netvsc_dev == NULL) || (netvsc_dev->vf_netdev == NULL))
 -		return NOTIFY_DONE;
 -
 -	netdev_info(netvsc_dev->ndev, "VF up: %s\n", vf_netdev->name);
 -	net_device_ctx = netdev_priv(netvsc_dev->ndev);
 -	netvsc_dev->vf_inject = true;
 -
 -	/*
 -	 * Open the device before switching data path.
 -	 */
 -	rndis_filter_open(net_device_ctx->device_ctx);
 -
 -	/*
 -	 * notify the host to switch the data path.
 -	 */
 -	netvsc_switch_datapath(netvsc_dev, true);
 -	netdev_info(netvsc_dev->ndev, "Data path switched to VF: %s\n",
 -		    vf_netdev->name);
 -
 -	netif_carrier_off(netvsc_dev->ndev);
 -
 -	/*
 -	 * Now notify peers. We are scheduling work to
 -	 * notify peers; take a reference to prevent
 -	 * the VF interface from vanishing.
 -	 */
 -	atomic_inc(&netvsc_dev->vf_use_cnt);
 -	net_device_ctx->gwrk.netdev = vf_netdev;
 -	net_device_ctx->gwrk.netvsc_dev = netvsc_dev;
 -	schedule_work(&net_device_ctx->gwrk.dwrk);
 -
 -	return NOTIFY_OK;
 -}
 -
 -
 -static int netvsc_vf_down(struct net_device *vf_netdev)
 -{
 -	struct netvsc_device *netvsc_dev;
 -	struct net_device_context *net_device_ctx;
 -	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
 -
 -	if (eth_ops == &ethtool_ops)
 -		return NOTIFY_DONE;
 -
 -	netvsc_dev = get_netvsc_device(vf_netdev->dev_addr);
 -
 -	if ((netvsc_dev == NULL) || (netvsc_dev->vf_netdev == NULL))
 -		return NOTIFY_DONE;
 -
 -	netdev_info(netvsc_dev->ndev, "VF down: %s\n", vf_netdev->name);
 -	net_device_ctx = netdev_priv(netvsc_dev->ndev);
 -	netvsc_dev->vf_inject = false;
 -	/*
 -	 * Wait for currently active users to
 -	 * drain out.
 -	 */
 -
 -	while (atomic_read(&netvsc_dev->vf_use_cnt) != 0)
 -		udelay(50);
 -	netvsc_switch_datapath(netvsc_dev, false);
 -	netdev_info(netvsc_dev->ndev, "Data path switched from VF: %s\n",
 -		    vf_netdev->name);
 -	rndis_filter_close(net_device_ctx->device_ctx);
 -	netif_carrier_on(netvsc_dev->ndev);
 -	/*
 -	 * Notify peers.
 -	 */
 -	atomic_inc(&netvsc_dev->vf_use_cnt);
 -	net_device_ctx->gwrk.netdev = netvsc_dev->ndev;
 -	net_device_ctx->gwrk.netvsc_dev = netvsc_dev;
 -	schedule_work(&net_device_ctx->gwrk.dwrk);
 -
 -	return NOTIFY_OK;
 -}
 -
 -
 -static int netvsc_unregister_vf(struct net_device *vf_netdev)
 -{
 -	struct netvsc_device *netvsc_dev;
 -	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
 -
 -	if (eth_ops == &ethtool_ops)
 -		return NOTIFY_DONE;
 -
 -	netvsc_dev = get_netvsc_device(vf_netdev->dev_addr);
 -	if (netvsc_dev == NULL)
 -		return NOTIFY_DONE;
 -	netdev_info(netvsc_dev->ndev, "VF unregistering: %s\n",
 -		    vf_netdev->name);
 -
 -	netvsc_dev->vf_netdev = NULL;
 -	module_put(THIS_MODULE);
 -	return NOTIFY_OK;
 -}
  
  static int netvsc_probe(struct hv_device *dev,
  			const struct hv_vmbus_device_id *dev_id)
* Unmerged path drivers/net/hyperv/netvsc_drv.c
