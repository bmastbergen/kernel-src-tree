perf hists browser: Show message for percent limit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit 79dded8776c2dc4d6e1229de69f4027e84d63673
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/79dded87.failed

Like the stdio, it should show messages about omitted hierarchy entries.
Please refer the previous commit for more details.

As it needs to check an entry is omitted or not multiple times, add the
has_no_entry field in the hist entry.

Suggested-and-Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1456488800-28124-4-git-send-email-namhyung@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 79dded8776c2dc4d6e1229de69f4027e84d63673)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/ui/browsers/hists.c
#	tools/perf/util/hist.c
diff --cc tools/perf/ui/browsers/hists.c
index d1445dd5bb7f,71c6d510390f..000000000000
--- a/tools/perf/ui/browsers/hists.c
+++ b/tools/perf/ui/browsers/hists.c
@@@ -500,14 -536,32 +511,40 @@@ static voi
  __hist_browser__set_folding(struct hist_browser *browser, bool unfold)
  {
  	struct rb_node *nd;
 -	struct hist_entry *he;
 -	double percent;
 +	struct hists *hists = browser->hists;
  
++<<<<<<< HEAD
 +	for (nd = rb_first(&hists->entries);
 +	     (nd = hists__filter_entries(nd, browser->min_pcnt)) != NULL;
 +	     nd = rb_next(nd)) {
 +		struct hist_entry *he = rb_entry(nd, struct hist_entry, rb_node);
 +		hist_entry__set_folding(he, unfold);
 +		browser->nr_callchain_rows += he->nr_rows;
++=======
+ 	nd = rb_first(&browser->hists->entries);
+ 	while (nd) {
+ 		he = rb_entry(nd, struct hist_entry, rb_node);
+ 
+ 		/* set folding state even if it's currently folded */
+ 		nd = __rb_hierarchy_next(nd, HMD_FORCE_CHILD);
+ 
+ 		hist_entry__set_folding(he, browser, unfold);
+ 
+ 		percent = hist_entry__get_percent_limit(he);
+ 		if (he->filtered || percent < browser->min_pcnt)
+ 			continue;
+ 
+ 		if (!he->depth || unfold)
+ 			browser->nr_hierarchy_entries++;
+ 		if (he->leaf)
+ 			browser->nr_callchain_rows += he->nr_rows;
+ 		else if (unfold && !hist_entry__has_hierarchy_children(he, browser->min_pcnt)) {
+ 			browser->nr_hierarchy_entries++;
+ 			he->has_no_entry = true;
+ 			he->nr_rows = 1;
+ 		} else
+ 			he->has_no_entry = false;
++>>>>>>> 79dded8776c2 (perf hists browser: Show message for percent limit)
  	}
  }
  
@@@ -1213,6 -1277,227 +1250,230 @@@ static int hist_browser__show_entry(str
  	return printed;
  }
  
++<<<<<<< HEAD
++=======
+ static int hist_browser__show_hierarchy_entry(struct hist_browser *browser,
+ 					      struct hist_entry *entry,
+ 					      unsigned short row,
+ 					      int level, int nr_sort_keys)
+ {
+ 	int printed = 0;
+ 	int width = browser->b.width;
+ 	char folded_sign = ' ';
+ 	bool current_entry = ui_browser__is_current_entry(&browser->b, row);
+ 	off_t row_offset = entry->row_offset;
+ 	bool first = true;
+ 	struct perf_hpp_fmt *fmt;
+ 	struct hpp_arg arg = {
+ 		.b		= &browser->b,
+ 		.current_entry	= current_entry,
+ 	};
+ 	int column = 0;
+ 	int hierarchy_indent = (nr_sort_keys - 1) * HIERARCHY_INDENT;
+ 
+ 	if (current_entry) {
+ 		browser->he_selection = entry;
+ 		browser->selection = &entry->ms;
+ 	}
+ 
+ 	hist_entry__init_have_children(entry);
+ 	folded_sign = hist_entry__folded(entry);
+ 	arg.folded_sign = folded_sign;
+ 
+ 	if (entry->leaf && row_offset) {
+ 		row_offset--;
+ 		goto show_callchain;
+ 	}
+ 
+ 	hist_browser__gotorc(browser, row, 0);
+ 
+ 	if (current_entry && browser->b.navkeypressed)
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_SELECTED);
+ 	else
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_NORMAL);
+ 
+ 	ui_browser__write_nstring(&browser->b, "", level * HIERARCHY_INDENT);
+ 	width -= level * HIERARCHY_INDENT;
+ 
+ 	hists__for_each_format(entry->hists, fmt) {
+ 		char s[2048];
+ 		struct perf_hpp hpp = {
+ 			.buf		= s,
+ 			.size		= sizeof(s),
+ 			.ptr		= &arg,
+ 		};
+ 
+ 		if (perf_hpp__should_skip(fmt, entry->hists) ||
+ 		    column++ < browser->b.horiz_scroll)
+ 			continue;
+ 
+ 		if (perf_hpp__is_sort_entry(fmt) ||
+ 		    perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		if (current_entry && browser->b.navkeypressed) {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_SELECTED);
+ 		} else {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_NORMAL);
+ 		}
+ 
+ 		if (first) {
+ 			ui_browser__printf(&browser->b, "%c", folded_sign);
+ 			width--;
+ 			first = false;
+ 		} else {
+ 			ui_browser__printf(&browser->b, "  ");
+ 			width -= 2;
+ 		}
+ 
+ 		if (fmt->color) {
+ 			int ret = fmt->color(fmt, &hpp, entry);
+ 			hist_entry__snprintf_alignment(entry, &hpp, fmt, ret);
+ 			/*
+ 			 * fmt->color() already used ui_browser to
+ 			 * print the non alignment bits, skip it (+ret):
+ 			 */
+ 			ui_browser__printf(&browser->b, "%s", s + ret);
+ 		} else {
+ 			int ret = fmt->entry(fmt, &hpp, entry);
+ 			hist_entry__snprintf_alignment(entry, &hpp, fmt, ret);
+ 			ui_browser__printf(&browser->b, "%s", s);
+ 		}
+ 		width -= hpp.buf - s;
+ 	}
+ 
+ 	ui_browser__write_nstring(&browser->b, "", hierarchy_indent);
+ 	width -= hierarchy_indent;
+ 
+ 	if (column >= browser->b.horiz_scroll) {
+ 		char s[2048];
+ 		struct perf_hpp hpp = {
+ 			.buf		= s,
+ 			.size		= sizeof(s),
+ 			.ptr		= &arg,
+ 		};
+ 
+ 		if (current_entry && browser->b.navkeypressed) {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_SELECTED);
+ 		} else {
+ 			ui_browser__set_color(&browser->b,
+ 					      HE_COLORSET_NORMAL);
+ 		}
+ 
+ 		ui_browser__write_nstring(&browser->b, "", 2);
+ 		width -= 2;
+ 
+ 		/*
+ 		 * No need to call hist_entry__snprintf_alignment()
+ 		 * since this fmt is always the last column in the
+ 		 * hierarchy mode.
+ 		 */
+ 		fmt = entry->fmt;
+ 		if (fmt->color) {
+ 			width -= fmt->color(fmt, &hpp, entry);
+ 		} else {
+ 			width -= fmt->entry(fmt, &hpp, entry);
+ 			ui_browser__printf(&browser->b, "%s", s);
+ 		}
+ 	}
+ 
+ 	/* The scroll bar isn't being used */
+ 	if (!browser->b.navkeypressed)
+ 		width += 1;
+ 
+ 	ui_browser__write_nstring(&browser->b, "", width);
+ 
+ 	++row;
+ 	++printed;
+ 
+ show_callchain:
+ 	if (entry->leaf && folded_sign == '-' && row != browser->b.rows) {
+ 		struct callchain_print_arg carg = {
+ 			.row_offset = row_offset,
+ 		};
+ 
+ 		printed += hist_browser__show_callchain(browser, entry,
+ 					level + 1, row,
+ 					hist_browser__show_callchain_entry, &carg,
+ 					hist_browser__check_output_full);
+ 	}
+ 
+ 	return printed;
+ }
+ 
+ static int hist_browser__show_no_entry(struct hist_browser *browser,
+ 				       unsigned short row,
+ 				       int level, int nr_sort_keys)
+ {
+ 	int width = browser->b.width;
+ 	bool current_entry = ui_browser__is_current_entry(&browser->b, row);
+ 	bool first = true;
+ 	int column = 0;
+ 	int ret;
+ 	struct perf_hpp_fmt *fmt;
+ 
+ 	if (current_entry) {
+ 		browser->he_selection = NULL;
+ 		browser->selection = NULL;
+ 	}
+ 
+ 	hist_browser__gotorc(browser, row, 0);
+ 
+ 	if (current_entry && browser->b.navkeypressed)
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_SELECTED);
+ 	else
+ 		ui_browser__set_color(&browser->b, HE_COLORSET_NORMAL);
+ 
+ 	ui_browser__write_nstring(&browser->b, "", level * HIERARCHY_INDENT);
+ 	width -= level * HIERARCHY_INDENT;
+ 
+ 	hists__for_each_format(browser->hists, fmt) {
+ 		if (perf_hpp__should_skip(fmt, browser->hists) ||
+ 		    column++ < browser->b.horiz_scroll)
+ 			continue;
+ 
+ 		if (perf_hpp__is_sort_entry(fmt) ||
+ 		    perf_hpp__is_dynamic_entry(fmt))
+ 			break;
+ 
+ 		ret = fmt->width(fmt, NULL, hists_to_evsel(browser->hists));
+ 
+ 		if (first) {
+ 			/* for folded sign */
+ 			first = false;
+ 			ret++;
+ 		} else {
+ 			/* space between columns */
+ 			ret += 2;
+ 		}
+ 
+ 		ui_browser__write_nstring(&browser->b, "", ret);
+ 		width -= ret;
+ 	}
+ 
+ 	ui_browser__write_nstring(&browser->b, "", nr_sort_keys * HIERARCHY_INDENT);
+ 	width -= nr_sort_keys * HIERARCHY_INDENT;
+ 
+ 	if (column >= browser->b.horiz_scroll) {
+ 		char buf[32];
+ 
+ 		ret = snprintf(buf, sizeof(buf), "no entry >= %.2f%%", browser->min_pcnt);
+ 		ui_browser__printf(&browser->b, "  %s", buf);
+ 		width -= ret + 2;
+ 	}
+ 
+ 	/* The scroll bar isn't being used */
+ 	if (!browser->b.navkeypressed)
+ 		width += 1;
+ 
+ 	ui_browser__write_nstring(&browser->b, "", width);
+ 	return 1;
+ }
+ 
++>>>>>>> 79dded8776c2 (perf hists browser: Show message for percent limit)
  static int advance_hpp_check(struct perf_hpp *hpp, int inc)
  {
  	advance_hpp(hpp, inc);
@@@ -1368,7 -1657,22 +1629,26 @@@ static unsigned int hist_browser__refre
  		if (percent < hb->min_pcnt)
  			continue;
  
++<<<<<<< HEAD
 +		row += hist_browser__show_entry(hb, h, row);
++=======
+ 		if (symbol_conf.report_hierarchy) {
+ 			row += hist_browser__show_hierarchy_entry(hb, h, row,
+ 								  h->depth,
+ 								  nr_sort);
+ 			if (row == browser->rows)
+ 				break;
+ 
+ 			if (h->has_no_entry) {
+ 				hist_browser__show_no_entry(hb, row, h->depth,
+ 							    nr_sort);
+ 				row++;
+ 			}
+ 		} else {
+ 			row += hist_browser__show_entry(hb, h, row);
+ 		}
+ 
++>>>>>>> 79dded8776c2 (perf hists browser: Show message for percent limit)
  		if (row == browser->rows)
  			break;
  	}
@@@ -2116,6 -2542,48 +2396,51 @@@ static void hist_browser__update_nr_ent
  	hb->nr_hierarchy_entries = nr_entries;
  }
  
++<<<<<<< HEAD
++=======
+ static void hist_browser__update_percent_limit(struct hist_browser *hb,
+ 					       double percent)
+ {
+ 	struct hist_entry *he;
+ 	struct rb_node *nd = rb_first(&hb->hists->entries);
+ 	u64 total = hists__total_period(hb->hists);
+ 	u64 min_callchain_hits = total * (percent / 100);
+ 
+ 	hb->min_pcnt = callchain_param.min_percent = percent;
+ 
+ 	while ((nd = hists__filter_entries(nd, hb->min_pcnt)) != NULL) {
+ 		he = rb_entry(nd, struct hist_entry, rb_node);
+ 
+ 		if (he->has_no_entry) {
+ 			he->has_no_entry = false;
+ 			he->nr_rows = 0;
+ 		}
+ 
+ 		if (!he->leaf || !symbol_conf.use_callchain)
+ 			goto next;
+ 
+ 		if (callchain_param.mode == CHAIN_GRAPH_REL) {
+ 			total = he->stat.period;
+ 
+ 			if (symbol_conf.cumulate_callchain)
+ 				total = he->stat_acc->period;
+ 
+ 			min_callchain_hits = total * (percent / 100);
+ 		}
+ 
+ 		callchain_param.sort(&he->sorted_chain, he->callchain,
+ 				     min_callchain_hits, &callchain_param);
+ 
+ next:
+ 		nd = __rb_hierarchy_next(nd, HMD_FORCE_CHILD);
+ 
+ 		/* force to re-evaluate folding state of callchains */
+ 		he->init_have_children = false;
+ 		hist_entry__set_folding(he, hb, false);
+ 	}
+ }
+ 
++>>>>>>> 79dded8776c2 (perf hists browser: Show message for percent limit)
  static int perf_evsel__hists_browse(struct perf_evsel *evsel, int nr_events,
  				    const char *helpline,
  				    bool left_exits,
diff --cc tools/perf/util/hist.c
index 9a525a5b649f,75dc41d2dca9..000000000000
--- a/tools/perf/util/hist.c
+++ b/tools/perf/util/hist.c
@@@ -1345,6 -1611,28 +1345,31 @@@ static void hists__remove_entry_filter(
  				       enum hist_filter filter)
  {
  	h->filtered &= ~(1 << filter);
++<<<<<<< HEAD
++=======
+ 
+ 	if (symbol_conf.report_hierarchy) {
+ 		struct hist_entry *parent = h->parent_he;
+ 
+ 		while (parent) {
+ 			he_stat__add_stat(&parent->stat, &h->stat);
+ 
+ 			parent->filtered &= ~(1 << filter);
+ 
+ 			if (parent->filtered)
+ 				goto next;
+ 
+ 			/* force fold unfiltered entry for simplicity */
+ 			parent->unfolded = false;
+ 			parent->has_no_entry = false;
+ 			parent->row_offset = 0;
+ 			parent->nr_rows = 0;
+ next:
+ 			parent = parent->parent_he;
+ 		}
+ 	}
+ 
++>>>>>>> 79dded8776c2 (perf hists browser: Show message for percent limit)
  	if (h->filtered)
  		return;
  
* Unmerged path tools/perf/ui/browsers/hists.c
* Unmerged path tools/perf/util/hist.c
diff --git a/tools/perf/util/sort.h b/tools/perf/util/sort.h
index cb167fb3da85..d44645a1dc8a 100644
--- a/tools/perf/util/sort.h
+++ b/tools/perf/util/sort.h
@@ -112,6 +112,7 @@ struct hist_entry {
 			bool	init_have_children;
 			bool	unfolded;
 			bool	has_children;
+			bool	has_no_entry;
 		};
 	};
 	char			*srcline;
