i40e/i40evf: Replace header pointers with unions of pointers in Tx checksum path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexander Duyck <aduyck@mirantis.com>
commit b96b78f2b789ab8398e7ec0111bb8b4588ed42bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b96b78f2.failed

The Tx checksum path was maintaining a set of 3 pointers and two lengths in
order to prepare the packet for being checksummed.  The thing is we only
really needed 2 pointers, and the lengths that were being maintained can
easily be computed.

As such we can replace the IPv4 and IPv6 header pointers with one single
union that represents both, or a generic pointer to the start of the
network header.  For the L4 headers we can do the same with TCP and a
generic pointer to the start of the transport header.  The length of the
TCP header is obtained by simply multiplying doff by 4, and the network
header length can be obtained by subtracting the network header pointer
from the transport header pointer.

While I was at it I renamed l4_hdr to l4_proto to make it a bit more clear
and less likely to be confused with l4.hdr which is the transport header
pointer.

	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit b96b78f2b789ab8398e7ec0111bb8b4588ed42bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_txrx.c
#	drivers/net/ethernet/intel/i40evf/i40e_txrx.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 5a3abb58e191,5cc7e711068d..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@@ -2466,20 -2447,6 +2475,23 @@@ static void i40e_tx_enable_csum(struct 
  			*tx_flags &= ~I40E_TX_FLAGS_IPV4;
  			*tx_flags |= I40E_TX_FLAGS_IPV6;
  		}
++<<<<<<< HEAD
 +		if ((tx_ring->flags & I40E_TXR_FLAGS_OUTER_UDP_CSUM) &&
 +		    (l4_tunnel == I40E_TXD_CTX_UDP_TUNNELING)        &&
 +		    (*cd_tunneling & I40E_TXD_CTX_QW0_EXT_IP_MASK)) {
 +			oudph->check = ~csum_tcpudp_magic(oiph->saddr,
 +					oiph->daddr,
 +					(skb->len - skb_transport_offset(skb)),
 +					IPPROTO_UDP, 0);
 +			*cd_tunneling |= I40E_TXD_CTX_QW0_L4T_CS_MASK;
 +		}
 +	} else {
 +		network_hdr_len = skb_network_header_len(skb);
 +		this_ip_hdr = ip_hdr(skb);
 +		this_ipv6_hdr = ipv6_hdr(skb);
 +		this_tcp_hdrlen = tcp_hdrlen(skb);
++=======
++>>>>>>> b96b78f2b789 (i40e/i40evf: Replace header pointers with unions of pointers in Tx checksum path)
  	}
  
  	/* Enable IP checksum offloads */
diff --cc drivers/net/ethernet/intel/i40evf/i40e_txrx.c
index f6384b0c8220,29af3c9fc120..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
@@@ -1671,22 -1661,6 +1680,25 @@@ static void i40e_tx_enable_csum(struct 
  			*tx_flags &= ~I40E_TX_FLAGS_IPV4;
  			*tx_flags |= I40E_TX_FLAGS_IPV6;
  		}
++<<<<<<< HEAD
 +
 +
 +		if ((tx_ring->flags & I40E_TXR_FLAGS_OUTER_UDP_CSUM) &&
 +		    (l4_tunnel == I40E_TXD_CTX_UDP_TUNNELING)        &&
 +		    (*cd_tunneling & I40E_TXD_CTX_QW0_EXT_IP_MASK)) {
 +			oudph->check = ~csum_tcpudp_magic(oiph->saddr,
 +					oiph->daddr,
 +					(skb->len - skb_transport_offset(skb)),
 +					IPPROTO_UDP, 0);
 +			*cd_tunneling |= I40E_TXD_CTX_QW0_L4T_CS_MASK;
 +		}
 +	} else {
 +		network_hdr_len = skb_network_header_len(skb);
 +		this_ip_hdr = ip_hdr(skb);
 +		this_ipv6_hdr = ipv6_hdr(skb);
 +		this_tcp_hdrlen = tcp_hdrlen(skb);
++=======
++>>>>>>> b96b78f2b789 (i40e/i40evf: Replace header pointers with unions of pointers in Tx checksum path)
  	}
  
  	/* Enable IP checksum offloads */
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_txrx.c
