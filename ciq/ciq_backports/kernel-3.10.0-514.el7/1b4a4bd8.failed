pNFS: fill in nfs42_layoutstat_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Peng Tao <tao.peng@primarydata.com>
commit 1b4a4bd82c308aed36f13fff4beb33d3840cfa0e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1b4a4bd8.failed

	Reviewed-by: Jeff Layton <jeff.layton@primarydata.com>
	Signed-off-by: Peng Tao <tao.peng@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 1b4a4bd82c308aed36f13fff4beb33d3840cfa0e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs42proc.c
diff --cc fs/nfs/nfs42proc.c
index 0899db096637,a0530418255f..000000000000
--- a/fs/nfs/nfs42proc.c
+++ b/fs/nfs/nfs42proc.c
@@@ -166,20 -171,71 +171,78 @@@ static loff_t _nfs42_proc_llseek(struc
  	return vfs_setpos(filep, res.sr_offset, inode->i_sb->s_maxbytes);
  }
  
++<<<<<<< HEAD
 +loff_t nfs42_proc_llseek(struct file *filep, loff_t offset, int whence)
++=======
+ static void
+ nfs42_layoutstat_prepare(struct rpc_task *task, void *calldata)
+ {
+ 	struct nfs42_layoutstat_data *data = calldata;
+ 	struct nfs_server *server = NFS_SERVER(data->args.inode);
+ 
+ 	nfs41_setup_sequence(nfs4_get_session(server), &data->args.seq_args,
+ 			     &data->res.seq_res, task);
+ }
+ 
+ static void
+ nfs42_layoutstat_done(struct rpc_task *task, void *calldata)
+ {
+ 	struct nfs42_layoutstat_data *data = calldata;
+ 
+ 	if (!nfs4_sequence_done(task, &data->res.seq_res))
+ 		return;
+ 
+ 	/* well, we don't care about errors at all! */
+ 	if (task->tk_status)
+ 		dprintk("%s server returns %d\n", __func__, task->tk_status);
+ }
+ 
+ static void
+ nfs42_layoutstat_release(void *calldata)
+ {
+ 	struct nfs42_layoutstat_data *data = calldata;
+ 
+ 	pnfs_put_layout_hdr(NFS_I(data->args.inode)->layout);
+ 	nfs_iput_and_deactive(data->inode);
+ 	kfree(data->args.devinfo);
+ 	kfree(data);
+ }
+ 
+ static const struct rpc_call_ops nfs42_layoutstat_ops = {
+ 	.rpc_call_prepare = nfs42_layoutstat_prepare,
+ 	.rpc_call_done = nfs42_layoutstat_done,
+ 	.rpc_release = nfs42_layoutstat_release,
+ };
+ 
+ int nfs42_proc_layoutstats_generic(struct nfs_server *server,
+ 				   struct nfs42_layoutstat_data *data)
++>>>>>>> 1b4a4bd82c30 (pNFS: fill in nfs42_layoutstat_ops)
  {
 -	struct rpc_message msg = {
 -		.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTSTATS],
 -		.rpc_argp = &data->args,
 -		.rpc_resp = &data->res,
 -	};
 -	struct rpc_task_setup task_setup = {
 -		.rpc_client = server->client,
 -		.rpc_message = &msg,
 -		.callback_ops = &nfs42_layoutstat_ops,
 -		.callback_data = data,
 -		.flags = RPC_TASK_ASYNC,
 -	};
 -	struct rpc_task *task;
 +	struct nfs_server *server = NFS_SERVER(file_inode(filep));
 +	struct nfs4_exception exception = { };
 +	loff_t err;
  
++<<<<<<< HEAD
 +	do {
 +		err = _nfs42_proc_llseek(filep, offset, whence);
 +		if (err >= 0)
 +			break;
 +		if (err == -ENOTSUPP)
 +			return -EOPNOTSUPP;
 +		err = nfs4_handle_exception(server, err, &exception);
 +	} while (exception.retry);
 +
 +	return err;
++=======
+ 	data->inode = nfs_igrab_and_active(data->args.inode);
+ 	if (!data->inode) {
+ 		nfs42_layoutstat_release(data);
+ 		return -EAGAIN;
+ 	}
+ 	nfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 0);
+ 	task = rpc_run_task(&task_setup);
+ 	if (IS_ERR(task))
+ 		return PTR_ERR(task);
+ 	return 0;
++>>>>>>> 1b4a4bd82c30 (pNFS: fill in nfs42_layoutstat_ops)
  }
* Unmerged path fs/nfs/nfs42proc.c
