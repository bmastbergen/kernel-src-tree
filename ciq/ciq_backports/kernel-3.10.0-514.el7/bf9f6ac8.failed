KVM: Update Posted-Interrupts Descriptor when vCPU is blocked

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Feng Wu <feng.wu@intel.com>
commit bf9f6ac8d74969690df1485b33b7c238ca9f2269
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bf9f6ac8.failed

This patch updates the Posted-Interrupts Descriptor when vCPU
is blocked.

pre-block:
- Add the vCPU to the blocked per-CPU list
- Set 'NV' to POSTED_INTR_WAKEUP_VECTOR

post-block:
- Remove the vCPU from the per-CPU list

	Signed-off-by: Feng Wu <feng.wu@intel.com>
[Concentrate invocation of pre/post-block hooks to vcpu_block. - Paolo]
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit bf9f6ac8d74969690df1485b33b7c238ca9f2269)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/vmx.c
#	arch/x86/kvm/x86.c
diff --cc arch/x86/include/asm/kvm_host.h
index 9c7ddbb4cbd2,cdbdb559ecd2..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -843,6 -898,20 +843,23 @@@ struct kvm_x86_ops 
  					   gfn_t offset, unsigned long mask);
  	/* pmu operations of sub-arch */
  	const struct kvm_pmu_ops *pmu_ops;
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * Architecture specific hooks for vCPU blocking due to
+ 	 * HLT instruction.
+ 	 * Returns for .pre_block():
+ 	 *    - 0 means continue to block the vCPU.
+ 	 *    - 1 means we cannot block the vCPU since some event
+ 	 *        happens during this period, such as, 'ON' bit in
+ 	 *        posted-interrupts descriptor is set.
+ 	 */
+ 	int (*pre_block)(struct kvm_vcpu *vcpu);
+ 	void (*post_block)(struct kvm_vcpu *vcpu);
+ 	int (*update_pi_irte)(struct kvm *kvm, unsigned int host_irq,
+ 			      uint32_t guest_irq, bool set);
++>>>>>>> bf9f6ac8d749 (KVM: Update Posted-Interrupts Descriptor when vCPU is blocked)
  };
  
  struct kvm_arch_async_pf {
diff --cc arch/x86/kvm/vmx.c
index f9a5d46f7d5b,c5c22831aee2..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -9826,6 -10461,201 +9856,204 @@@ static void vmx_enable_log_dirty_pt_mas
  	kvm_mmu_clear_dirty_pt_masked(kvm, memslot, offset, mask);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * This routine does the following things for vCPU which is going
+  * to be blocked if VT-d PI is enabled.
+  * - Store the vCPU to the wakeup list, so when interrupts happen
+  *   we can find the right vCPU to wake up.
+  * - Change the Posted-interrupt descriptor as below:
+  *      'NDST' <-- vcpu->pre_pcpu
+  *      'NV' <-- POSTED_INTR_WAKEUP_VECTOR
+  * - If 'ON' is set during this process, which means at least one
+  *   interrupt is posted for this vCPU, we cannot block it, in
+  *   this case, return 1, otherwise, return 0.
+  *
+  */
+ static int vmx_pre_block(struct kvm_vcpu *vcpu)
+ {
+ 	unsigned long flags;
+ 	unsigned int dest;
+ 	struct pi_desc old, new;
+ 	struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+ 
+ 	if (!kvm_arch_has_assigned_device(vcpu->kvm) ||
+ 		!irq_remapping_cap(IRQ_POSTING_CAP))
+ 		return 0;
+ 
+ 	vcpu->pre_pcpu = vcpu->cpu;
+ 	spin_lock_irqsave(&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			  vcpu->pre_pcpu), flags);
+ 	list_add_tail(&vcpu->blocked_vcpu_list,
+ 		      &per_cpu(blocked_vcpu_on_cpu,
+ 		      vcpu->pre_pcpu));
+ 	spin_unlock_irqrestore(&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			       vcpu->pre_pcpu), flags);
+ 
+ 	do {
+ 		old.control = new.control = pi_desc->control;
+ 
+ 		/*
+ 		 * We should not block the vCPU if
+ 		 * an interrupt is posted for it.
+ 		 */
+ 		if (pi_test_on(pi_desc) == 1) {
+ 			spin_lock_irqsave(&per_cpu(blocked_vcpu_on_cpu_lock,
+ 					  vcpu->pre_pcpu), flags);
+ 			list_del(&vcpu->blocked_vcpu_list);
+ 			spin_unlock_irqrestore(
+ 					&per_cpu(blocked_vcpu_on_cpu_lock,
+ 					vcpu->pre_pcpu), flags);
+ 			vcpu->pre_pcpu = -1;
+ 
+ 			return 1;
+ 		}
+ 
+ 		WARN((pi_desc->sn == 1),
+ 		     "Warning: SN field of posted-interrupts "
+ 		     "is set before blocking\n");
+ 
+ 		/*
+ 		 * Since vCPU can be preempted during this process,
+ 		 * vcpu->cpu could be different with pre_pcpu, we
+ 		 * need to set pre_pcpu as the destination of wakeup
+ 		 * notification event, then we can find the right vCPU
+ 		 * to wakeup in wakeup handler if interrupts happen
+ 		 * when the vCPU is in blocked state.
+ 		 */
+ 		dest = cpu_physical_id(vcpu->pre_pcpu);
+ 
+ 		if (x2apic_enabled())
+ 			new.ndst = dest;
+ 		else
+ 			new.ndst = (dest << 8) & 0xFF00;
+ 
+ 		/* set 'NV' to 'wakeup vector' */
+ 		new.nv = POSTED_INTR_WAKEUP_VECTOR;
+ 	} while (cmpxchg(&pi_desc->control, old.control,
+ 			new.control) != old.control);
+ 
+ 	return 0;
+ }
+ 
+ static void vmx_post_block(struct kvm_vcpu *vcpu)
+ {
+ 	struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+ 	struct pi_desc old, new;
+ 	unsigned int dest;
+ 	unsigned long flags;
+ 
+ 	if (!kvm_arch_has_assigned_device(vcpu->kvm) ||
+ 		!irq_remapping_cap(IRQ_POSTING_CAP))
+ 		return;
+ 
+ 	do {
+ 		old.control = new.control = pi_desc->control;
+ 
+ 		dest = cpu_physical_id(vcpu->cpu);
+ 
+ 		if (x2apic_enabled())
+ 			new.ndst = dest;
+ 		else
+ 			new.ndst = (dest << 8) & 0xFF00;
+ 
+ 		/* Allow posting non-urgent interrupts */
+ 		new.sn = 0;
+ 
+ 		/* set 'NV' to 'notification vector' */
+ 		new.nv = POSTED_INTR_VECTOR;
+ 	} while (cmpxchg(&pi_desc->control, old.control,
+ 			new.control) != old.control);
+ 
+ 	if(vcpu->pre_pcpu != -1) {
+ 		spin_lock_irqsave(
+ 			&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			vcpu->pre_pcpu), flags);
+ 		list_del(&vcpu->blocked_vcpu_list);
+ 		spin_unlock_irqrestore(
+ 			&per_cpu(blocked_vcpu_on_cpu_lock,
+ 			vcpu->pre_pcpu), flags);
+ 		vcpu->pre_pcpu = -1;
+ 	}
+ }
+ 
+ /*
+  * vmx_update_pi_irte - set IRTE for Posted-Interrupts
+  *
+  * @kvm: kvm
+  * @host_irq: host irq of the interrupt
+  * @guest_irq: gsi of the interrupt
+  * @set: set or unset PI
+  * returns 0 on success, < 0 on failure
+  */
+ static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,
+ 			      uint32_t guest_irq, bool set)
+ {
+ 	struct kvm_kernel_irq_routing_entry *e;
+ 	struct kvm_irq_routing_table *irq_rt;
+ 	struct kvm_lapic_irq irq;
+ 	struct kvm_vcpu *vcpu;
+ 	struct vcpu_data vcpu_info;
+ 	int idx, ret = -EINVAL;
+ 
+ 	if (!kvm_arch_has_assigned_device(kvm) ||
+ 		!irq_remapping_cap(IRQ_POSTING_CAP))
+ 		return 0;
+ 
+ 	idx = srcu_read_lock(&kvm->irq_srcu);
+ 	irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+ 	BUG_ON(guest_irq >= irq_rt->nr_rt_entries);
+ 
+ 	hlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {
+ 		if (e->type != KVM_IRQ_ROUTING_MSI)
+ 			continue;
+ 		/*
+ 		 * VT-d PI cannot support posting multicast/broadcast
+ 		 * interrupts to a vCPU, we still use interrupt remapping
+ 		 * for these kind of interrupts.
+ 		 *
+ 		 * For lowest-priority interrupts, we only support
+ 		 * those with single CPU as the destination, e.g. user
+ 		 * configures the interrupts via /proc/irq or uses
+ 		 * irqbalance to make the interrupts single-CPU.
+ 		 *
+ 		 * We will support full lowest-priority interrupt later.
+ 		 */
+ 
+ 		kvm_set_msi_irq(e, &irq);
+ 		if (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu))
+ 			continue;
+ 
+ 		vcpu_info.pi_desc_addr = __pa(vcpu_to_pi_desc(vcpu));
+ 		vcpu_info.vector = irq.vector;
+ 
+ 		trace_kvm_pi_irte_update(vcpu->vcpu_id, e->gsi,
+ 				vcpu_info.vector, vcpu_info.pi_desc_addr, set);
+ 
+ 		if (set)
+ 			ret = irq_set_vcpu_affinity(host_irq, &vcpu_info);
+ 		else {
+ 			/* suppress notification event before unposting */
+ 			pi_set_sn(vcpu_to_pi_desc(vcpu));
+ 			ret = irq_set_vcpu_affinity(host_irq, NULL);
+ 			pi_clear_sn(vcpu_to_pi_desc(vcpu));
+ 		}
+ 
+ 		if (ret < 0) {
+ 			printk(KERN_INFO "%s: failed to update PI IRTE\n",
+ 					__func__);
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	ret = 0;
+ out:
+ 	srcu_read_unlock(&kvm->irq_srcu, idx);
+ 	return ret;
+ }
+ 
++>>>>>>> bf9f6ac8d749 (KVM: Update Posted-Interrupts Descriptor when vCPU is blocked)
  static struct kvm_x86_ops vmx_x86_ops = {
  	.cpu_has_kvm_support = cpu_has_kvm_support,
  	.disabled_by_bios = vmx_disabled_by_bios,
@@@ -9941,7 -10772,12 +10169,10 @@@
  	.flush_log_dirty = vmx_flush_log_dirty,
  	.enable_log_dirty_pt_masked = vmx_enable_log_dirty_pt_masked,
  
+ 	.pre_block = vmx_pre_block,
+ 	.post_block = vmx_post_block,
+ 
  	.pmu_ops = &intel_pmu_ops,
 -
 -	.update_pi_irte = vmx_update_pi_irte,
  };
  
  static int __init vmx_init(void)
diff --cc arch/x86/kvm/x86.c
index 45f59cb670bb,2d2c9bb0d6d6..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -6732,8 -6321,34 +6732,22 @@@ static int vcpu_enter_guest(struct kvm_
  			vcpu_scan_ioapic(vcpu);
  		if (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))
  			kvm_vcpu_reload_apic_access_page(vcpu);
 -		if (kvm_check_request(KVM_REQ_HV_CRASH, vcpu)) {
 -			vcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;
 -			vcpu->run->system_event.type = KVM_SYSTEM_EVENT_CRASH;
 -			r = 0;
 -			goto out;
 -		}
 -		if (kvm_check_request(KVM_REQ_HV_RESET, vcpu)) {
 -			vcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;
 -			vcpu->run->system_event.type = KVM_SYSTEM_EVENT_RESET;
 -			r = 0;
 -			goto out;
 -		}
  	}
  
+ 	/*
+ 	 * KVM_REQ_EVENT is not set when posted interrupts are set by
+ 	 * VT-d hardware, so we have to update RVI unconditionally.
+ 	 */
+ 	if (kvm_lapic_enabled(vcpu)) {
+ 		/*
+ 		 * Update architecture specific hints for APIC
+ 		 * virtual interrupt delivery.
+ 		 */
+ 		if (kvm_x86_ops->hwapic_irr_update)
+ 			kvm_x86_ops->hwapic_irr_update(vcpu,
+ 				kvm_lapic_find_highest_irr(vcpu));
+ 	}
+ 
  	if (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) {
  		kvm_apic_accept_events(vcpu);
  		if (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {
@@@ -6932,10 -6539,13 +6944,17 @@@ static int vcpu_run(struct kvm_vcpu *vc
  	vcpu->srcu_idx = srcu_read_lock(&kvm->srcu);
  
  	for (;;) {
++<<<<<<< HEAD
 +		if (kvm_vcpu_running(vcpu))
++=======
+ 		if (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&
+ 		    !vcpu->arch.apf.halted) {
++>>>>>>> bf9f6ac8d749 (KVM: Update Posted-Interrupts Descriptor when vCPU is blocked)
  			r = vcpu_enter_guest(vcpu);
- 		else
+ 		} else {
  			r = vcpu_block(kvm, vcpu);
+ 		}
+ 
  		if (r <= 0)
  			break;
  
diff --git a/Documentation/virtual/kvm/locking.txt b/Documentation/virtual/kvm/locking.txt
index d68af4dc3006..19f94a6b9bb0 100644
--- a/Documentation/virtual/kvm/locking.txt
+++ b/Documentation/virtual/kvm/locking.txt
@@ -166,3 +166,15 @@ Comment:	The srcu read lock must be held while accessing memslots (e.g.
 		MMIO/PIO address->device structure mapping (kvm->buses).
 		The srcu index can be stored in kvm_vcpu->srcu_idx per vcpu
 		if it is needed by multiple functions.
+
+Name:		blocked_vcpu_on_cpu_lock
+Type:		spinlock_t
+Arch:		x86
+Protects:	blocked_vcpu_on_cpu
+Comment:	This is a per-CPU lock and it is used for VT-d posted-interrupts.
+		When VT-d posted-interrupts is supported and the VM has assigned
+		devices, we put the blocked vCPU on the list blocked_vcpu_on_cpu
+		protected by blocked_vcpu_on_cpu_lock, when VT-d hardware issues
+		wakeup notification event since external interrupts from the
+		assigned devices happens, we will find the vCPU on the list to
+		wakeup.
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/vmx.c
* Unmerged path arch/x86/kvm/x86.c
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index fa2bee22c9da..ab9d890ef49c 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -232,6 +232,9 @@ struct kvm_vcpu {
 	unsigned long requests;
 	unsigned long guest_debug;
 
+	int pre_pcpu;
+	struct list_head blocked_vcpu_list;
+
 	struct mutex mutex;
 	struct kvm_run *run;
 
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 60d061de3cb9..7bb73af3b7a2 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -229,6 +229,9 @@ int kvm_vcpu_init(struct kvm_vcpu *vcpu, struct kvm *kvm, unsigned id)
 	init_waitqueue_head(&vcpu->wq);
 	kvm_async_pf_vcpu_init(vcpu);
 
+	vcpu->pre_pcpu = -1;
+	INIT_LIST_HEAD(&vcpu->blocked_vcpu_list);
+
 	page = alloc_page(GFP_KERNEL | __GFP_ZERO);
 	if (!page) {
 		r = -ENOMEM;
