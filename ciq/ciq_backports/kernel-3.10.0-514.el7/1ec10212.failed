netfilter: nf_tables: rename nft_validate_data_load()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Patrick McHardy <kaber@trash.net>
commit 1ec10212f9bc62645932b0ca39bab0eb57d5331a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1ec10212.failed

The existing name is ambiguous, data is loaded as well when we read from
a register. Rename to nft_validate_register_store() for clarity and
consistency with the upcoming patch to introduce its counterpart,
nft_validate_register_load().

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 1ec10212f9bc62645932b0ca39bab0eb57d5331a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables.h
#	net/bridge/netfilter/nft_meta_bridge.c
#	net/netfilter/nf_tables_api.c
#	net/netfilter/nft_bitwise.c
#	net/netfilter/nft_byteorder.c
#	net/netfilter/nft_ct.c
#	net/netfilter/nft_exthdr.c
#	net/netfilter/nft_immediate.c
#	net/netfilter/nft_meta.c
#	net/netfilter/nft_payload.c
diff --cc include/net/netfilter/nf_tables.h
index 4ab50d820db0,7251f2034e30..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -114,9 -114,10 +114,16 @@@ static inline enum nft_registers nft_ty
  
  int nft_validate_input_register(enum nft_registers reg);
  int nft_validate_output_register(enum nft_registers reg);
++<<<<<<< HEAD
 +int nft_validate_data_load(const struct nft_ctx *ctx, enum nft_registers reg,
 +			   const struct nft_data *data,
 +			   enum nft_data_types type);
++=======
+ int nft_validate_register_store(const struct nft_ctx *ctx,
+ 				enum nft_registers reg,
+ 				const struct nft_data *data,
+ 				enum nft_data_types type, unsigned int len);
++>>>>>>> 1ec10212f9bc (netfilter: nf_tables: rename nft_validate_data_load())
  
  
  /**
diff --cc net/bridge/netfilter/nft_meta_bridge.c
index 4f02109d708f,ee9e0b73d50e..000000000000
--- a/net/bridge/netfilter/nft_meta_bridge.c
+++ b/net/bridge/netfilter/nft_meta_bridge.c
@@@ -69,7 -71,8 +69,12 @@@ static int nft_meta_bridge_get_init(con
  	if (err < 0)
  		return err;
  
++<<<<<<< HEAD
 +	err = nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
++=======
+ 	err = nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					  NFT_DATA_VALUE, len);
++>>>>>>> 1ec10212f9bc (netfilter: nf_tables: rename nft_validate_data_load())
  	if (err < 0)
  		return err;
  
diff --cc net/netfilter/nf_tables_api.c
index 399ca83793bb,a1e4a928f00c..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -2791,9 -2796,11 +2791,16 @@@ static int nf_tables_bind_check_setelem
  	enum nft_registers dreg;
  
  	dreg = nft_type_to_reg(set->dtype);
++<<<<<<< HEAD
 +	return nft_validate_data_load(ctx, dreg, &elem->data,
 +				      set->dtype == NFT_DATA_VERDICT ?
 +				      NFT_DATA_VERDICT : NFT_DATA_VALUE);
++=======
+ 	return nft_validate_register_store(ctx, dreg, nft_set_ext_data(ext),
+ 					   set->dtype == NFT_DATA_VERDICT ?
+ 					   NFT_DATA_VERDICT : NFT_DATA_VALUE,
+ 					   set->dlen);
++>>>>>>> 1ec10212f9bc (netfilter: nf_tables: rename nft_validate_data_load())
  }
  
  int nf_tables_bind_set(const struct nft_ctx *ctx, struct nft_set *set,
@@@ -3222,8 -3334,9 +3229,14 @@@ static int nft_add_set_elem(struct nft_
  			if (!(binding->flags & NFT_SET_MAP))
  				continue;
  
++<<<<<<< HEAD
 +			err = nft_validate_data_load(&bind_ctx, dreg,
 +						     &elem.data, d2.type);
++=======
+ 			err = nft_validate_register_store(&bind_ctx, dreg,
+ 							  &data,
+ 							  d2.type, d2.len);
++>>>>>>> 1ec10212f9bc (netfilter: nf_tables: rename nft_validate_data_load())
  			if (err < 0)
  				goto err3;
  		}
@@@ -3999,15 -4164,17 +4012,22 @@@ EXPORT_SYMBOL_GPL(nft_validate_output_r
   * 	@reg: the destination register number
   * 	@data: the data to load
   * 	@type: the data type
 - * 	@len: the length of the data
   *
   * 	Validate that a data load uses the appropriate data type for
 - * 	the destination register and the length is within the bounds.
 - * 	A value of NULL for the data means that its runtime gathered
 - * 	data, which is always of type NFT_DATA_VALUE.
 + * 	the destination register. A value of NULL for the data means
 + * 	that its runtime gathered data, which is always of type
 + * 	NFT_DATA_VALUE.
   */
++<<<<<<< HEAD
 +int nft_validate_data_load(const struct nft_ctx *ctx, enum nft_registers reg,
 +			   const struct nft_data *data,
 +			   enum nft_data_types type)
++=======
+ int nft_validate_register_store(const struct nft_ctx *ctx,
+ 				enum nft_registers reg,
+ 				const struct nft_data *data,
+ 				enum nft_data_types type, unsigned int len)
++>>>>>>> 1ec10212f9bc (netfilter: nf_tables: rename nft_validate_data_load())
  {
  	int err;
  
diff --cc net/netfilter/nft_bitwise.c
index 4fb6ee2c1106,afad27c700a1..000000000000
--- a/net/netfilter/nft_bitwise.c
+++ b/net/netfilter/nft_bitwise.c
@@@ -72,7 -74,9 +72,13 @@@ static int nft_bitwise_init(const struc
  	err = nft_validate_output_register(priv->dreg);
  	if (err < 0)
  		return err;
++<<<<<<< HEAD
 +	err = nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
++=======
+ 
+ 	err = nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					  NFT_DATA_VALUE, priv->len);
++>>>>>>> 1ec10212f9bc (netfilter: nf_tables: rename nft_validate_data_load())
  	if (err < 0)
  		return err;
  
diff --cc net/netfilter/nft_byteorder.c
index c39ed8d29df1,03bfb7598395..000000000000
--- a/net/netfilter/nft_byteorder.c
+++ b/net/netfilter/nft_byteorder.c
@@@ -122,6 -109,20 +122,23 @@@ static int nft_byteorder_init(const str
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
++=======
+ 	priv->sreg = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_SREG]));
+ 	err = nft_validate_input_register(priv->sreg);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	priv->dreg = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_DREG]));
+ 	err = nft_validate_output_register(priv->dreg);
+ 	if (err < 0)
+ 		return err;
+ 	err = nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					  NFT_DATA_VALUE, priv->len);
+ 	if (err < 0)
+ 		return err;
+ 
++>>>>>>> 1ec10212f9bc (netfilter: nf_tables: rename nft_validate_data_load())
  	return 0;
  }
  
diff --cc net/netfilter/nft_ct.c
index 18d520e0ca0a,e23ddb663c69..000000000000
--- a/net/netfilter/nft_ct.c
+++ b/net/netfilter/nft_ct.c
@@@ -278,7 -311,8 +278,12 @@@ static int nft_ct_get_init(const struc
  	if (err < 0)
  		return err;
  
++<<<<<<< HEAD
 +	err = nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
++=======
+ 	err = nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					  NFT_DATA_VALUE, len);
++>>>>>>> 1ec10212f9bc (netfilter: nf_tables: rename nft_validate_data_load())
  	if (err < 0)
  		return err;
  
diff --cc net/netfilter/nft_exthdr.c
index 55c939f5371f,ab16a3809628..000000000000
--- a/net/netfilter/nft_exthdr.c
+++ b/net/netfilter/nft_exthdr.c
@@@ -77,7 -74,8 +77,12 @@@ static int nft_exthdr_init(const struc
  	err = nft_validate_output_register(priv->dreg);
  	if (err < 0)
  		return err;
++<<<<<<< HEAD
 +	return nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
++=======
+ 	return nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					   NFT_DATA_VALUE, priv->len);
++>>>>>>> 1ec10212f9bc (netfilter: nf_tables: rename nft_validate_data_load())
  }
  
  static int nft_exthdr_dump(struct sk_buff *skb, const struct nft_expr *expr)
diff --cc net/netfilter/nft_immediate.c
index 810385eb7249,d058a9338ea7..000000000000
--- a/net/netfilter/nft_immediate.c
+++ b/net/netfilter/nft_immediate.c
@@@ -59,7 -59,8 +59,12 @@@ static int nft_immediate_init(const str
  		return err;
  	priv->dlen = desc.len;
  
++<<<<<<< HEAD
 +	err = nft_validate_data_load(ctx, priv->dreg, &priv->data, desc.type);
++=======
+ 	err = nft_validate_register_store(ctx, priv->dreg, &priv->data,
+ 					  desc.type, desc.len);
++>>>>>>> 1ec10212f9bc (netfilter: nf_tables: rename nft_validate_data_load())
  	if (err < 0)
  		goto err1;
  
diff --cc net/netfilter/nft_meta.c
index a4cdc254de57,b733755811e7..000000000000
--- a/net/netfilter/nft_meta.c
+++ b/net/netfilter/nft_meta.c
@@@ -256,7 -262,8 +256,12 @@@ int nft_meta_get_init(const struct nft_
  	if (err < 0)
  		return err;
  
++<<<<<<< HEAD
 +	err = nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
++=======
+ 	err = nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					  NFT_DATA_VALUE, len);
++>>>>>>> 1ec10212f9bc (netfilter: nf_tables: rename nft_validate_data_load())
  	if (err < 0)
  		return err;
  
diff --cc net/netfilter/nft_payload.c
index 85daa84bfdfe,9c7ad4bfe9d6..000000000000
--- a/net/netfilter/nft_payload.c
+++ b/net/netfilter/nft_payload.c
@@@ -72,7 -72,8 +72,12 @@@ static int nft_payload_init(const struc
  	err = nft_validate_output_register(priv->dreg);
  	if (err < 0)
  		return err;
++<<<<<<< HEAD
 +	return nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);
++=======
+ 	return nft_validate_register_store(ctx, priv->dreg, NULL,
+ 					   NFT_DATA_VALUE, priv->len);
++>>>>>>> 1ec10212f9bc (netfilter: nf_tables: rename nft_validate_data_load())
  }
  
  static int nft_payload_dump(struct sk_buff *skb, const struct nft_expr *expr)
* Unmerged path include/net/netfilter/nf_tables.h
* Unmerged path net/bridge/netfilter/nft_meta_bridge.c
* Unmerged path net/netfilter/nf_tables_api.c
* Unmerged path net/netfilter/nft_bitwise.c
* Unmerged path net/netfilter/nft_byteorder.c
* Unmerged path net/netfilter/nft_ct.c
* Unmerged path net/netfilter/nft_exthdr.c
* Unmerged path net/netfilter/nft_immediate.c
* Unmerged path net/netfilter/nft_meta.c
* Unmerged path net/netfilter/nft_payload.c
