IB/core: Register SA ibnl client during ib_core initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mark Bloch <markb@mellanox.com>
commit 735c631ae99d4b6cffc9e2774258329c526daa65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/735c631a.failed

Move SA ibnl client registration to ib_core module init.
This will allow us to register a single client to handle
all RDMA_NL_LS operations and make it SA independent.

	Signed-off-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 735c631ae99d4b6cffc9e2774258329c526daa65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/core_priv.h
#	drivers/infiniband/core/device.c
#	drivers/infiniband/core/sa_query.c
diff --cc drivers/infiniband/core/core_priv.h
index 0d01fb95d944,1ff334587e7b..000000000000
--- a/drivers/infiniband/core/core_priv.h
+++ b/drivers/infiniband/core/core_priv.h
@@@ -114,4 -137,18 +114,21 @@@ static inline bool rdma_is_upper_dev_rc
  	return _upper == upper;
  }
  
++<<<<<<< HEAD
++=======
+ int addr_init(void);
+ void addr_cleanup(void);
+ 
+ int ib_mad_init(void);
+ void ib_mad_cleanup(void);
+ 
+ int ib_sa_init(void);
+ void ib_sa_cleanup(void);
+ 
+ int ib_nl_handle_resolve_resp(struct sk_buff *skb,
+ 			      struct netlink_callback *cb);
+ int ib_nl_handle_set_timeout(struct sk_buff *skb,
+ 			     struct netlink_callback *cb);
+ 
++>>>>>>> 735c631ae99d (IB/core: Register SA ibnl client during ib_core initialization)
  #endif /* _CORE_PRIV_H */
diff --cc drivers/infiniband/core/device.c
index 84b0c0c4193b,8b4366b2e358..000000000000
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@@ -974,10 -1003,41 +994,47 @@@ static int __init ib_core_init(void
  		goto err_sysfs;
  	}
  
++<<<<<<< HEAD
++=======
+ 	ret = addr_init();
+ 	if (ret) {
+ 		pr_warn("Could't init IB address resolution\n");
+ 		goto err_ibnl;
+ 	}
+ 
+ 	ret = ib_mad_init();
+ 	if (ret) {
+ 		pr_warn("Couldn't init IB MAD\n");
+ 		goto err_addr;
+ 	}
+ 
+ 	ret = ib_sa_init();
+ 	if (ret) {
+ 		pr_warn("Couldn't init SA\n");
+ 		goto err_mad;
+ 	}
+ 
+ 	if (ib_add_ibnl_clients()) {
+ 		pr_warn("Couldn't register ibnl clients\n");
+ 		goto err_sa;
+ 	}
+ 
++>>>>>>> 735c631ae99d (IB/core: Register SA ibnl client during ib_core initialization)
  	ib_cache_setup();
  
  	return 0;
  
++<<<<<<< HEAD
++=======
+ err_sa:
+ 	ib_sa_cleanup();
+ err_mad:
+ 	ib_mad_cleanup();
+ err_addr:
+ 	addr_cleanup();
+ err_ibnl:
+ 	ibnl_cleanup();
++>>>>>>> 735c631ae99d (IB/core: Register SA ibnl client during ib_core initialization)
  err_sysfs:
  	class_unregister(&ib_class);
  err_comp:
@@@ -990,6 -1050,10 +1047,13 @@@ err
  static void __exit ib_core_cleanup(void)
  {
  	ib_cache_cleanup();
++<<<<<<< HEAD
++=======
+ 	ib_remove_ibnl_clients();
+ 	ib_sa_cleanup();
+ 	ib_mad_cleanup();
+ 	addr_cleanup();
++>>>>>>> 735c631ae99d (IB/core: Register SA ibnl client during ib_core initialization)
  	ibnl_cleanup();
  	class_unregister(&ib_class);
  	destroy_workqueue(ib_comp_wq);
diff --cc drivers/infiniband/core/sa_query.c
index 963e90469018,8bd61a612001..000000000000
--- a/drivers/infiniband/core/sa_query.c
+++ b/drivers/infiniband/core/sa_query.c
@@@ -1754,12 -1807,6 +1745,15 @@@ static int __init ib_sa_init(void
  		goto err3;
  	}
  
++<<<<<<< HEAD
 +	if (ibnl_add_client(RDMA_NL_LS, RDMA_NL_LS_NUM_OPS,
 +			    ib_sa_cb_table)) {
 +		pr_err("Failed to add netlink callback\n");
 +		ret = -EINVAL;
 +		goto err4;
 +	}
++=======
++>>>>>>> 735c631ae99d (IB/core: Register SA ibnl client during ib_core initialization)
  	INIT_DELAYED_WORK(&ib_nl_timed_work, ib_nl_request_timeout);
  
  	return 0;
@@@ -1773,9 -1819,8 +1766,8 @@@ err1
  	return ret;
  }
  
 -void ib_sa_cleanup(void)
 +static void __exit ib_sa_cleanup(void)
  {
- 	ibnl_remove_client(RDMA_NL_LS);
  	cancel_delayed_work(&ib_nl_timed_work);
  	flush_workqueue(ib_nl_wq);
  	destroy_workqueue(ib_nl_wq);
* Unmerged path drivers/infiniband/core/core_priv.h
* Unmerged path drivers/infiniband/core/device.c
* Unmerged path drivers/infiniband/core/sa_query.c
