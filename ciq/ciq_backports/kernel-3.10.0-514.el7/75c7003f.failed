perf/x86/intel/rapl: Calculate timing once

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 75c7003fbf419f05215d4ca09bf3964d0b1c99e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/75c7003f.failed

No point in doing the same calculation over and over. Do it once in
rapl_check_hw_unit().

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Andi Kleen <andi.kleen@intel.com>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Harish Chegondi <harish.chegondi@intel.com>
	Cc: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Kan Liang <kan.liang@intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
	Cc: linux-kernel@vger.kernel.org
Link: http://lkml.kernel.org/r/20160222221012.409238136@linutronix.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 75c7003fbf419f05215d4ca09bf3964d0b1c99e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/perf_event_intel_rapl.c
diff --cc arch/x86/kernel/cpu/perf_event_intel_rapl.c
index c019c57572a7,b1d4a2f1feeb..000000000000
--- a/arch/x86/kernel/cpu/perf_event_intel_rapl.c
+++ b/arch/x86/kernel/cpu/perf_event_intel_rapl.c
@@@ -693,6 -661,22 +681,25 @@@ static int rapl_check_hw_unit(void
  	for (i = 0; i < NR_RAPL_DOMAINS; i++)
  		rapl_hw_unit[i] = (msr_rapl_power_unit_bits >> 8) & 0x1FULL;
  
++<<<<<<< HEAD:arch/x86/kernel/cpu/perf_event_intel_rapl.c
++=======
+ 	/* Apply cpu model quirk */
+ 	if (quirk)
+ 		quirk();
+ 
+ 	/*
+ 	 * Calculate the timer rate:
+ 	 * Use reference of 200W for scaling the timeout to avoid counter
+ 	 * overflows. 200W = 200 Joules/sec
+ 	 * Divide interval by 2 to avoid lockstep (2 * 100)
+ 	 * if hw unit is 32, then we use 2 ms 1/200/2
+ 	 */
+ 	rapl_timer_ms = 2;
+ 	if (rapl_hw_unit[0] < 32) {
+ 		rapl_timer_ms = (1000 / (2 * 100));
+ 		rapl_timer_ms *= (1ULL << (32 - rapl_hw_unit[0] - 1));
+ 	}
++>>>>>>> 75c7003fbf41 (perf/x86/intel/rapl: Calculate timing once):arch/x86/events/intel/rapl.c
  	return 0;
  }
  
@@@ -703,10 -695,8 +710,15 @@@ static const struct x86_cpu_id rapl_cpu
  
  static int __init rapl_pmu_init(void)
  {
++<<<<<<< HEAD:arch/x86/kernel/cpu/perf_event_intel_rapl.c
 +	struct rapl_pmu *pmu;
 +	int cpu, ret;
 +	struct x86_pmu_quirk *quirk;
 +	int i;
++=======
+ 	void (*quirk)(void) = NULL;
+ 	int cpu, ret, i;
++>>>>>>> 75c7003fbf41 (perf/x86/intel/rapl: Calculate timing once):arch/x86/events/intel/rapl.c
  
  	/*
  	 * check for Intel processor family 6
@@@ -767,11 -753,11 +779,16 @@@
  	ret = perf_pmu_register(&rapl_pmu_class, "power", -1);
  	if (WARN_ON(ret)) {
  		pr_info("RAPL PMU detected, registration failed (%d), RAPL PMU disabled\n", ret);
 -		goto out;
 +		cpu_notifier_register_done();
 +		return -1;
  	}
  
++<<<<<<< HEAD:arch/x86/kernel/cpu/perf_event_intel_rapl.c
 +	pmu = __get_cpu_var(rapl_pmu);
++=======
+ 	__perf_cpu_notifier(rapl_cpu_notifier);
+ 	cpu_notifier_register_done();
++>>>>>>> 75c7003fbf41 (perf/x86/intel/rapl: Calculate timing once):arch/x86/events/intel/rapl.c
  
  	pr_info("RAPL PMU detected,"
  		" API unit is 2^-32 Joules,"
@@@ -785,9 -771,12 +802,15 @@@
  				rapl_domain_names[i], rapl_hw_unit[i]);
  		}
  	}
++<<<<<<< HEAD:arch/x86/kernel/cpu/perf_event_intel_rapl.c
++=======
+ 
+ 	return 0;
+ 
++>>>>>>> 75c7003fbf41 (perf/x86/intel/rapl: Calculate timing once):arch/x86/events/intel/rapl.c
  out:
 -	cleanup_rapl_pmus();
  	cpu_notifier_register_done();
 -	return ret;
 +
 +	return 0;
  }
  device_initcall(rapl_pmu_init);
* Unmerged path arch/x86/kernel/cpu/perf_event_intel_rapl.c
