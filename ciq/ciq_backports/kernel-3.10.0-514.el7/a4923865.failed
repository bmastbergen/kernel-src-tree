GFS2: Prevent delete work from occurring on glocks used for create

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit a4923865ea071b0bd708339df7a83c76732fa2db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a4923865.failed

This patch tries to prevent delete work (queued via iopen callback)
from executing if the glock is currently being used to create
a new inode.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Acked-by: Steven Whitehouse <swhiteho@redhat.com>
(cherry picked from commit a4923865ea071b0bd708339df7a83c76732fa2db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/inode.c
diff --cc fs/gfs2/inode.c
index 0db2e94034ce,95a914524a39..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -558,11 -592,11 +558,16 @@@ static int gfs2_create_inode(struct ino
  	struct inode *inode = NULL;
  	struct gfs2_inode *dip = GFS2_I(dir), *ip;
  	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
++<<<<<<< HEAD
 +	struct gfs2_glock *io_gl;
 +	struct dentry *d;
 +	int error, free_vfs_inode = 0;
++=======
+ 	struct gfs2_glock *io_gl = NULL;
+ 	int error, free_vfs_inode = 1;
++>>>>>>> a4923865ea07 (GFS2: Prevent delete work from occurring on glocks used for create)
  	u32 aflags = 0;
 -	unsigned blocks = 1;
 -	struct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };
 +	int arq;
  
  	if (!name->len || name->len > GFS2_FNAMESIZE)
  		return -ENAMETOOLONG;
@@@ -718,12 -777,11 +726,14 @@@
  	return error;
  
  fail_gunlock3:
 -	gfs2_glock_dq_uninit(&ip->i_iopen_gh);
 -	gfs2_glock_put(io_gl);
 +	gfs2_glock_dq_uninit(ghs + 1);
 +	if (ip->i_gl)
 +		gfs2_glock_put(ip->i_gl);
 +	goto fail_gunlock;
 +
  fail_gunlock2:
+ 	if (io_gl)
+ 		clear_bit(GLF_INODE_CREATING, &io_gl->gl_flags);
  	gfs2_glock_dq_uninit(ghs + 1);
  fail_free_inode:
  	if (ip->i_gl)
diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index ea771a5d5be5..e90990d6a7af 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -638,6 +638,12 @@ static void delete_work_func(struct work_struct *work)
 	struct inode *inode;
 	u64 no_addr = gl->gl_name.ln_number;
 
+	/* If someone's using this glock to create a new dinode, the block must
+	   have been freed by another node, then re-used, in which case our
+	   iopen callback is too late after the fact. Ignore it. */
+	if (test_bit(GLF_INODE_CREATING, &gl->gl_flags))
+		goto out;
+
 	ip = gl->gl_object;
 	/* Note: Unsafe to dereference ip as we don't hold right refs/locks */
 
@@ -649,6 +655,7 @@ static void delete_work_func(struct work_struct *work)
 		d_prune_aliases(inode);
 		iput(inode);
 	}
+out:
 	gfs2_glock_put(gl);
 }
 
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 2caf75dc0244..745cdb2ce086 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -313,6 +313,7 @@ enum {
 	GLF_LRU				= 13,
 	GLF_OBJECT			= 14, /* Used only for tracing */
 	GLF_BLOCKING			= 15,
+	GLF_INODE_CREATING		= 16, /* Inode creation occurring */
 };
 
 struct gfs2_glock {
* Unmerged path fs/gfs2/inode.c
