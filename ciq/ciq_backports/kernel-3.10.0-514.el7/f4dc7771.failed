netfilter: x_tables: speed up jump target validation

jira LE-1907
cve CVE-2016-3134
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Florian Westphal <fw@strlen.de>
commit f4dc77713f8016d2e8a3295e1c9c53a21f296def
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f4dc7771.failed

The dummy ruleset I used to test the original validation change was broken,
most rules were unreachable and were not tested by mark_source_chains().

In some cases rulesets that used to load in a few seconds now require
several minutes.

sample ruleset that shows the behaviour:

echo "*filter"
for i in $(seq 0 100000);do
        printf ":chain_%06x - [0:0]\n" $i
done
for i in $(seq 0 100000);do
   printf -- "-A INPUT -j chain_%06x\n" $i
   printf -- "-A INPUT -j chain_%06x\n" $i
   printf -- "-A INPUT -j chain_%06x\n" $i
done
echo COMMIT

[ pipe result into iptables-restore ]

This ruleset will be about 74mbyte in size, with ~500k searches
though all 500k[1] rule entries. iptables-restore will take forever
(gave up after 10 minutes)

Instead of always searching the entire blob for a match, fill an
array with the start offsets of every single ipt_entry struct,
then do a binary search to check if the jump target is present or not.

After this change ruleset restore times get again close to what one
gets when reverting 36472341017529e (~3 seconds on my workstation).

[1] every user-defined rule gets an implicit RETURN, so we get
300k jumps + 100k userchains + 100k returns -> 500k rule entries

Fixes: 36472341017529e ("netfilter: x_tables: validate targets of jumps")
	Reported-by: Jeff Wu <wujiafu@gmail.com>
	Tested-by: Jeff Wu <wujiafu@gmail.com>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit f4dc77713f8016d2e8a3295e1c9c53a21f296def)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/arp_tables.c
#	net/ipv4/netfilter/ip_tables.c
#	net/ipv6/netfilter/ip6_tables.c
diff --cc net/ipv4/netfilter/arp_tables.c
index def7a1b54c02,b31df597fd37..000000000000
--- a/net/ipv4/netfilter/arp_tables.c
+++ b/net/ipv4/netfilter/arp_tables.c
@@@ -465,21 -376,12 +454,25 @@@ static int mark_source_chains(const str
  				if (strcmp(t->target.u.user.name,
  					   XT_STANDARD_TARGET) == 0 &&
  				    newpos >= 0) {
 +					if (newpos > newinfo->size -
 +						sizeof(struct arpt_entry)) {
 +						duprintf("mark_source_chains: "
 +							"bad verdict (%i)\n",
 +								newpos);
 +						return 0;
 +					}
 +
  					/* This a jump; chase it. */
++<<<<<<< HEAD
 +					duprintf("Jump rule %u -> %u\n",
 +						 pos, newpos);
++=======
+ 					if (!xt_find_jump_offset(offsets, newpos,
+ 								 newinfo->number))
+ 						return 0;
++>>>>>>> f4dc77713f80 (netfilter: x_tables: speed up jump target validation)
  					e = (struct arpt_entry *)
  						(entry0 + newpos);
- 					if (!find_jump_target(newinfo, e))
- 						return 0;
  				} else {
  					/* ... this is a fallthru */
  					newpos = pos + e->next_offset;
@@@ -643,9 -530,10 +636,10 @@@ static inline void cleanup_entry(struc
   * newinfo).
   */
  static int translate_table(struct xt_table_info *newinfo, void *entry0,
 -			   const struct arpt_replace *repl)
 +                           const struct arpt_replace *repl)
  {
  	struct arpt_entry *iter;
+ 	unsigned int *offsets;
  	unsigned int i;
  	int ret = 0;
  
@@@ -658,7 -546,9 +652,13 @@@
  		newinfo->underflow[i] = 0xFFFFFFFF;
  	}
  
++<<<<<<< HEAD
 +	duprintf("translate_table: size %u\n", newinfo->size);
++=======
+ 	offsets = xt_alloc_entry_offsets(newinfo->number);
+ 	if (!offsets)
+ 		return -ENOMEM;
++>>>>>>> f4dc77713f80 (netfilter: x_tables: speed up jump target validation)
  	i = 0;
  
  	/* Walk through entries, checking offsets. */
@@@ -675,35 -567,29 +677,51 @@@
  		    XT_ERROR_TARGET) == 0)
  			++newinfo->stacksize;
  	}
 +	duprintf("translate_table: ARPT_ENTRY_ITERATE gives %d\n", ret);
  	if (ret != 0)
- 		return ret;
+ 		goto out_free;
  
++<<<<<<< HEAD
 +	if (i != repl->num_entries) {
 +		duprintf("translate_table: %u not %u entries\n",
 +			 i, repl->num_entries);
 +		return -EINVAL;
 +	}
++=======
+ 	ret = -EINVAL;
+ 	if (i != repl->num_entries)
+ 		goto out_free;
++>>>>>>> f4dc77713f80 (netfilter: x_tables: speed up jump target validation)
  
  	/* Check hooks all assigned */
  	for (i = 0; i < NF_ARP_NUMHOOKS; i++) {
  		/* Only hooks which are valid */
  		if (!(repl->valid_hooks & (1 << i)))
  			continue;
++<<<<<<< HEAD
 +		if (newinfo->hook_entry[i] == 0xFFFFFFFF) {
 +			duprintf("Invalid hook entry %u %u\n",
 +				 i, repl->hook_entry[i]);
 +			return -EINVAL;
 +		}
 +		if (newinfo->underflow[i] == 0xFFFFFFFF) {
 +			duprintf("Invalid underflow %u %u\n",
 +				 i, repl->underflow[i]);
 +			return -EINVAL;
 +		}
++=======
+ 		if (newinfo->hook_entry[i] == 0xFFFFFFFF)
+ 			goto out_free;
+ 		if (newinfo->underflow[i] == 0xFFFFFFFF)
+ 			goto out_free;
++>>>>>>> f4dc77713f80 (netfilter: x_tables: speed up jump target validation)
  	}
  
- 	if (!mark_source_chains(newinfo, repl->valid_hooks, entry0))
- 		return -ELOOP;
+ 	if (!mark_source_chains(newinfo, repl->valid_hooks, entry0, offsets)) {
+ 		ret = -ELOOP;
+ 		goto out_free;
+ 	}
+ 	kvfree(offsets);
  
  	/* Finally, each sanity check must pass */
  	i = 0;
diff --cc net/ipv4/netfilter/ip_tables.c
index 910d524e46ff,f993545a3373..000000000000
--- a/net/ipv4/netfilter/ip_tables.c
+++ b/net/ipv4/netfilter/ip_tables.c
@@@ -435,21 -371,8 +435,9 @@@ ipt_do_table(struct sk_buff *skb
  	if (acpar.hotdrop)
  		return NF_DROP;
  	else return verdict;
 +#endif
  }
  
- static bool find_jump_target(const struct xt_table_info *t,
- 			     const struct ipt_entry *target)
- {
- 	struct ipt_entry *iter;
- 
- 	xt_entry_foreach(iter, t->entries, t->size) {
- 		 if (iter == target)
- 			return true;
- 	}
- 	return false;
- }
- 
  /* Figures out from what hook each rule can be called: returns 0 if
     there are loops.  Puts hook bitmask in comefrom. */
  static int
@@@ -537,20 -446,12 +526,24 @@@ mark_source_chains(const struct xt_tabl
  				if (strcmp(t->target.u.user.name,
  					   XT_STANDARD_TARGET) == 0 &&
  				    newpos >= 0) {
 +					if (newpos > newinfo->size -
 +						sizeof(struct ipt_entry)) {
 +						duprintf("mark_source_chains: "
 +							"bad verdict (%i)\n",
 +								newpos);
 +						return 0;
 +					}
  					/* This a jump; chase it. */
++<<<<<<< HEAD
 +					duprintf("Jump rule %u -> %u\n",
 +						 pos, newpos);
++=======
+ 					if (!xt_find_jump_offset(offsets, newpos,
+ 								 newinfo->number))
+ 						return 0;
++>>>>>>> f4dc77713f80 (netfilter: x_tables: speed up jump target validation)
  					e = (struct ipt_entry *)
  						(entry0 + newpos);
- 					if (!find_jump_target(newinfo, e))
- 						return 0;
  				} else {
  					/* ... this is a fallthru */
  					newpos = pos + e->next_offset;
@@@ -803,9 -681,10 +796,10 @@@ cleanup_entry(struct ipt_entry *e, stru
     newinfo) */
  static int
  translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,
 -		const struct ipt_replace *repl)
 +                const struct ipt_replace *repl)
  {
  	struct ipt_entry *iter;
+ 	unsigned int *offsets;
  	unsigned int i;
  	int ret = 0;
  
@@@ -818,7 -697,9 +812,13 @@@
  		newinfo->underflow[i] = 0xFFFFFFFF;
  	}
  
++<<<<<<< HEAD
 +	duprintf("translate_table: size %u\n", newinfo->size);
++=======
+ 	offsets = xt_alloc_entry_offsets(newinfo->number);
+ 	if (!offsets)
+ 		return -ENOMEM;
++>>>>>>> f4dc77713f80 (netfilter: x_tables: speed up jump target validation)
  	i = 0;
  	/* Walk through entries, checking offsets. */
  	xt_entry_foreach(iter, entry0, newinfo->size) {
@@@ -835,31 -718,26 +837,47 @@@
  			++newinfo->stacksize;
  	}
  
++<<<<<<< HEAD
 +	if (i != repl->num_entries) {
 +		duprintf("translate_table: %u not %u entries\n",
 +			 i, repl->num_entries);
 +		return -EINVAL;
 +	}
++=======
+ 	ret = -EINVAL;
+ 	if (i != repl->num_entries)
+ 		goto out_free;
++>>>>>>> f4dc77713f80 (netfilter: x_tables: speed up jump target validation)
  
  	/* Check hooks all assigned */
  	for (i = 0; i < NF_INET_NUMHOOKS; i++) {
  		/* Only hooks which are valid */
  		if (!(repl->valid_hooks & (1 << i)))
  			continue;
++<<<<<<< HEAD
 +		if (newinfo->hook_entry[i] == 0xFFFFFFFF) {
 +			duprintf("Invalid hook entry %u %u\n",
 +				 i, repl->hook_entry[i]);
 +			return -EINVAL;
 +		}
 +		if (newinfo->underflow[i] == 0xFFFFFFFF) {
 +			duprintf("Invalid underflow %u %u\n",
 +				 i, repl->underflow[i]);
 +			return -EINVAL;
 +		}
++=======
+ 		if (newinfo->hook_entry[i] == 0xFFFFFFFF)
+ 			goto out_free;
+ 		if (newinfo->underflow[i] == 0xFFFFFFFF)
+ 			goto out_free;
++>>>>>>> f4dc77713f80 (netfilter: x_tables: speed up jump target validation)
  	}
  
- 	if (!mark_source_chains(newinfo, repl->valid_hooks, entry0))
- 		return -ELOOP;
+ 	if (!mark_source_chains(newinfo, repl->valid_hooks, entry0, offsets)) {
+ 		ret = -ELOOP;
+ 		goto out_free;
+ 	}
+ 	kvfree(offsets);
  
  	/* Finally, each sanity check must pass */
  	i = 0;
diff --cc net/ipv6/netfilter/ip6_tables.c
index 5ab744563ff1,552fac2f390a..000000000000
--- a/net/ipv6/netfilter/ip6_tables.c
+++ b/net/ipv6/netfilter/ip6_tables.c
@@@ -445,21 -400,8 +445,9 @@@ ip6t_do_table(struct sk_buff *skb
  	if (acpar.hotdrop)
  		return NF_DROP;
  	else return verdict;
 +#endif
  }
  
- static bool find_jump_target(const struct xt_table_info *t,
- 			     const struct ip6t_entry *target)
- {
- 	struct ip6t_entry *iter;
- 
- 	xt_entry_foreach(iter, t->entries, t->size) {
- 		 if (iter == target)
- 			return true;
- 	}
- 	return false;
- }
- 
  /* Figures out from what hook each rule can be called: returns 0 if
     there are loops.  Puts hook bitmask in comefrom. */
  static int
@@@ -547,20 -475,12 +536,24 @@@ mark_source_chains(const struct xt_tabl
  				if (strcmp(t->target.u.user.name,
  					   XT_STANDARD_TARGET) == 0 &&
  				    newpos >= 0) {
 +					if (newpos > newinfo->size -
 +						sizeof(struct ip6t_entry)) {
 +						duprintf("mark_source_chains: "
 +							"bad verdict (%i)\n",
 +								newpos);
 +						return 0;
 +					}
  					/* This a jump; chase it. */
++<<<<<<< HEAD
 +					duprintf("Jump rule %u -> %u\n",
 +						 pos, newpos);
++=======
+ 					if (!xt_find_jump_offset(offsets, newpos,
+ 								 newinfo->number))
+ 						return 0;
++>>>>>>> f4dc77713f80 (netfilter: x_tables: speed up jump target validation)
  					e = (struct ip6t_entry *)
  						(entry0 + newpos);
- 					if (!find_jump_target(newinfo, e))
- 						return 0;
  				} else {
  					/* ... this is a fallthru */
  					newpos = pos + e->next_offset;
@@@ -813,9 -711,10 +806,10 @@@ static void cleanup_entry(struct ip6t_e
     newinfo) */
  static int
  translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,
 -		const struct ip6t_replace *repl)
 +                const struct ip6t_replace *repl)
  {
  	struct ip6t_entry *iter;
+ 	unsigned int *offsets;
  	unsigned int i;
  	int ret = 0;
  
@@@ -828,7 -727,9 +822,13 @@@
  		newinfo->underflow[i] = 0xFFFFFFFF;
  	}
  
++<<<<<<< HEAD
 +	duprintf("translate_table: size %u\n", newinfo->size);
++=======
+ 	offsets = xt_alloc_entry_offsets(newinfo->number);
+ 	if (!offsets)
+ 		return -ENOMEM;
++>>>>>>> f4dc77713f80 (netfilter: x_tables: speed up jump target validation)
  	i = 0;
  	/* Walk through entries, checking offsets. */
  	xt_entry_foreach(iter, entry0, newinfo->size) {
@@@ -845,31 -748,26 +847,47 @@@
  			++newinfo->stacksize;
  	}
  
++<<<<<<< HEAD
 +	if (i != repl->num_entries) {
 +		duprintf("translate_table: %u not %u entries\n",
 +			 i, repl->num_entries);
 +		return -EINVAL;
 +	}
++=======
+ 	ret = -EINVAL;
+ 	if (i != repl->num_entries)
+ 		goto out_free;
++>>>>>>> f4dc77713f80 (netfilter: x_tables: speed up jump target validation)
  
  	/* Check hooks all assigned */
  	for (i = 0; i < NF_INET_NUMHOOKS; i++) {
  		/* Only hooks which are valid */
  		if (!(repl->valid_hooks & (1 << i)))
  			continue;
++<<<<<<< HEAD
 +		if (newinfo->hook_entry[i] == 0xFFFFFFFF) {
 +			duprintf("Invalid hook entry %u %u\n",
 +				 i, repl->hook_entry[i]);
 +			return -EINVAL;
 +		}
 +		if (newinfo->underflow[i] == 0xFFFFFFFF) {
 +			duprintf("Invalid underflow %u %u\n",
 +				 i, repl->underflow[i]);
 +			return -EINVAL;
 +		}
++=======
+ 		if (newinfo->hook_entry[i] == 0xFFFFFFFF)
+ 			goto out_free;
+ 		if (newinfo->underflow[i] == 0xFFFFFFFF)
+ 			goto out_free;
++>>>>>>> f4dc77713f80 (netfilter: x_tables: speed up jump target validation)
  	}
  
- 	if (!mark_source_chains(newinfo, repl->valid_hooks, entry0))
- 		return -ELOOP;
+ 	if (!mark_source_chains(newinfo, repl->valid_hooks, entry0, offsets)) {
+ 		ret = -ELOOP;
+ 		goto out_free;
+ 	}
+ 	kvfree(offsets);
  
  	/* Finally, each sanity check must pass */
  	i = 0;
diff --git a/include/linux/netfilter/x_tables.h b/include/linux/netfilter/x_tables.h
index 3d7ef66809de..49f88f897050 100644
--- a/include/linux/netfilter/x_tables.h
+++ b/include/linux/netfilter/x_tables.h
@@ -249,6 +249,10 @@ int xt_check_entry_offsets(const void *base, const char *elems,
 			   unsigned int target_offset,
 			   unsigned int next_offset);
 
+unsigned int *xt_alloc_entry_offsets(unsigned int size);
+bool xt_find_jump_offset(const unsigned int *offsets,
+			 unsigned int target, unsigned int size);
+
 int xt_check_match(struct xt_mtchk_param *, unsigned int size, u_int8_t proto,
 		   bool inv_proto);
 int xt_check_target(struct xt_tgchk_param *, unsigned int size, u_int8_t proto,
* Unmerged path net/ipv4/netfilter/arp_tables.c
* Unmerged path net/ipv4/netfilter/ip_tables.c
* Unmerged path net/ipv6/netfilter/ip6_tables.c
diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c
index a66c76d3a555..551407ae5911 100644
--- a/net/netfilter/x_tables.c
+++ b/net/netfilter/x_tables.c
@@ -721,6 +721,56 @@ int xt_check_entry_offsets(const void *base,
 }
 EXPORT_SYMBOL(xt_check_entry_offsets);
 
+/**
+ * xt_alloc_entry_offsets - allocate array to store rule head offsets
+ *
+ * @size: number of entries
+ *
+ * Return: NULL or kmalloc'd or vmalloc'd array
+ */
+unsigned int *xt_alloc_entry_offsets(unsigned int size)
+{
+	unsigned int *off;
+
+	off = kcalloc(size, sizeof(unsigned int), GFP_KERNEL | __GFP_NOWARN);
+
+	if (off)
+		return off;
+
+	if (size < (SIZE_MAX / sizeof(unsigned int)))
+		off = vmalloc(size * sizeof(unsigned int));
+
+	return off;
+}
+EXPORT_SYMBOL(xt_alloc_entry_offsets);
+
+/**
+ * xt_find_jump_offset - check if target is a valid jump offset
+ *
+ * @offsets: array containing all valid rule start offsets of a rule blob
+ * @target: the jump target to search for
+ * @size: entries in @offset
+ */
+bool xt_find_jump_offset(const unsigned int *offsets,
+			 unsigned int target, unsigned int size)
+{
+	int m, low = 0, hi = size;
+
+	while (hi > low) {
+		m = (low + hi) / 2u;
+
+		if (offsets[m] > target)
+			hi = m;
+		else if (offsets[m] < target)
+			low = m + 1;
+		else
+			return true;
+	}
+
+	return false;
+}
+EXPORT_SYMBOL(xt_find_jump_offset);
+
 int xt_check_target(struct xt_tgchk_param *par,
 		    unsigned int size, u_int8_t proto, bool inv_proto)
 {
