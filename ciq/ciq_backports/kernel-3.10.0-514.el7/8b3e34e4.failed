KVM: x86: add pcommit support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Xiao Guangrong <guangrong.xiao@linux.intel.com>
commit 8b3e34e46aca9b6d349b331cd9cf71ccbdc91b2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8b3e34e4.failed

Pass PCOMMIT CPU feature to guest to enable PCOMMIT instruction

Currently we do not catch pcommit instruction for L1 guest and
allow L1 to catch this instruction for L2 if, as required by the spec,
L1 can enumerate the PCOMMIT instruction via CPUID:
| IA32_VMX_PROCBASED_CTLS2[53] (which enumerates support for the
| 1-setting of PCOMMIT exiting) is always the same as
| CPUID.07H:EBX.PCOMMIT[bit 22]. Thus, software can set PCOMMIT exiting
| to 1 if and only if the PCOMMIT instruction is enumerated via CPUID

The spec can be found at
https://software.intel.com/sites/default/files/managed/0d/53/319433-022.pdf

	Signed-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 8b3e34e46aca9b6d349b331cd9cf71ccbdc91b2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/vmx.h
#	arch/x86/include/uapi/asm/vmx.h
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/include/asm/vmx.h
index b963514887da,d25f32ac9c5c..000000000000
--- a/arch/x86/include/asm/vmx.h
+++ b/arch/x86/include/asm/vmx.h
@@@ -71,7 -71,8 +71,12 @@@
  #define SECONDARY_EXEC_ENABLE_INVPCID		0x00001000
  #define SECONDARY_EXEC_SHADOW_VMCS              0x00004000
  #define SECONDARY_EXEC_ENABLE_PML               0x00020000
++<<<<<<< HEAD
 +
++=======
+ #define SECONDARY_EXEC_XSAVES			0x00100000
+ #define SECONDARY_EXEC_PCOMMIT			0x00200000
++>>>>>>> 8b3e34e46aca (KVM: x86: add pcommit support)
  
  #define PIN_BASED_EXT_INTR_MASK                 0x00000001
  #define PIN_BASED_NMI_EXITING                   0x00000008
diff --cc arch/x86/include/uapi/asm/vmx.h
index adfadcc6f962,5b15d94a33f8..000000000000
--- a/arch/x86/include/uapi/asm/vmx.h
+++ b/arch/x86/include/uapi/asm/vmx.h
@@@ -75,6 -76,9 +75,12 @@@
  #define EXIT_REASON_APIC_WRITE          56
  #define EXIT_REASON_INVPCID             58
  #define EXIT_REASON_PML_FULL            62
++<<<<<<< HEAD
++=======
+ #define EXIT_REASON_XSAVES              63
+ #define EXIT_REASON_XRSTORS             64
+ #define EXIT_REASON_PCOMMIT             65
++>>>>>>> 8b3e34e46aca (KVM: x86: add pcommit support)
  
  #define VMX_EXIT_REASONS \
  	{ EXIT_REASON_EXCEPTION_NMI,         "EXCEPTION_NMI" }, \
@@@ -120,7 -126,9 +126,13 @@@
  	{ EXIT_REASON_INVD,                  "INVD" }, \
  	{ EXIT_REASON_INVVPID,               "INVVPID" }, \
  	{ EXIT_REASON_INVPCID,               "INVPCID" }, \
++<<<<<<< HEAD
 +	{ EXIT_REASON_PREEMPTION_TIMER,      "PREEMPTION_TIMER" }
++=======
+ 	{ EXIT_REASON_XSAVES,                "XSAVES" }, \
+ 	{ EXIT_REASON_XRSTORS,               "XRSTORS" }, \
+ 	{ EXIT_REASON_PCOMMIT,               "PCOMMIT" }
++>>>>>>> 8b3e34e46aca (KVM: x86: add pcommit support)
  
  #define VMX_ABORT_SAVE_GUEST_MSR_FAIL        1
  #define VMX_ABORT_LOAD_HOST_MSR_FAIL         4
diff --cc arch/x86/kvm/vmx.c
index d9faa33faa54,691010604144..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -2391,11 -2465,18 +2391,21 @@@ static __init void nested_vmx_setup_ctl
  
  	/* secondary cpu-based controls */
  	rdmsr(MSR_IA32_VMX_PROCBASED_CTLS2,
 -		vmx->nested.nested_vmx_secondary_ctls_low,
 -		vmx->nested.nested_vmx_secondary_ctls_high);
 -	vmx->nested.nested_vmx_secondary_ctls_low = 0;
 -	vmx->nested.nested_vmx_secondary_ctls_high &=
 +		nested_vmx_secondary_ctls_low, nested_vmx_secondary_ctls_high);
 +	nested_vmx_secondary_ctls_low = 0;
 +	nested_vmx_secondary_ctls_high &=
  		SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
++<<<<<<< HEAD
 +		SECONDARY_EXEC_WBINVD_EXITING;
++=======
+ 		SECONDARY_EXEC_RDTSCP |
+ 		SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |
+ 		SECONDARY_EXEC_APIC_REGISTER_VIRT |
+ 		SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
+ 		SECONDARY_EXEC_WBINVD_EXITING |
+ 		SECONDARY_EXEC_XSAVES |
+ 		SECONDARY_EXEC_PCOMMIT;
++>>>>>>> 8b3e34e46aca (KVM: x86: add pcommit support)
  
  	if (enable_ept) {
  		/* nested EPT: emulate EPT also to L1 */
@@@ -2900,7 -3016,9 +2910,13 @@@ static __init int setup_vmcs_config(str
  			SECONDARY_EXEC_APIC_REGISTER_VIRT |
  			SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
  			SECONDARY_EXEC_SHADOW_VMCS |
++<<<<<<< HEAD
 +			SECONDARY_EXEC_ENABLE_PML;
++=======
+ 			SECONDARY_EXEC_XSAVES |
+ 			SECONDARY_EXEC_ENABLE_PML |
+ 			SECONDARY_EXEC_PCOMMIT;
++>>>>>>> 8b3e34e46aca (KVM: x86: add pcommit support)
  		if (adjust_vmx_controls(min2, opt2,
  					MSR_IA32_VMX_PROCBASED_CTLS2,
  					&_cpu_based_2nd_exec_control) < 0)
@@@ -4372,12 -4619,11 +4391,11 @@@ static int vmx_vcpu_setup(struct vcpu_v
  
  	vmcs_write32(CPU_BASED_VM_EXEC_CONTROL, vmx_exec_control(vmx));
  
- 	if (cpu_has_secondary_exec_ctrls()) {
+ 	if (cpu_has_secondary_exec_ctrls())
  		vmcs_write32(SECONDARY_VM_EXEC_CONTROL,
  				vmx_secondary_exec_control(vmx));
- 	}
  
 -	if (vmx_cpu_uses_apicv(&vmx->vcpu)) {
 +	if (vmx_vm_has_apicv(vmx->vcpu.kvm)) {
  		vmcs_write64(EOI_EXIT_BITMAP0, 0);
  		vmcs_write64(EOI_EXIT_BITMAP1, 0);
  		vmcs_write64(EOI_EXIT_BITMAP2, 0);
@@@ -7000,7 -7270,10 +7025,8 @@@ static int (*const kvm_vmx_exit_handler
  	[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_monitor,
  	[EXIT_REASON_INVEPT]                  = handle_invept,
  	[EXIT_REASON_INVVPID]                 = handle_invvpid,
 -	[EXIT_REASON_XSAVES]                  = handle_xsaves,
 -	[EXIT_REASON_XRSTORS]                 = handle_xrstors,
  	[EXIT_REASON_PML_FULL]		      = handle_pml_full,
+ 	[EXIT_REASON_PCOMMIT]                 = handle_pcommit,
  };
  
  static const int kvm_vmx_max_exit_handlers =
@@@ -7289,9 -7566,19 +7315,23 @@@ static bool nested_vmx_exit_handled(str
  	case EXIT_REASON_WBINVD:
  		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);
  	case EXIT_REASON_XSETBV:
++<<<<<<< HEAD
 +		return 1;
++=======
+ 		return true;
+ 	case EXIT_REASON_XSAVES: case EXIT_REASON_XRSTORS:
+ 		/*
+ 		 * This should never happen, since it is not possible to
+ 		 * set XSS to a non-zero value---neither in L1 nor in L2.
+ 		 * If if it were, XSS would have to be checked against
+ 		 * the XSS exit bitmap in vmcs12.
+ 		 */
+ 		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_XSAVES);
+ 	case EXIT_REASON_PCOMMIT:
+ 		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_PCOMMIT);
++>>>>>>> 8b3e34e46aca (KVM: x86: add pcommit support)
  	default:
 -		return true;
 +		return 1;
  	}
  }
  
@@@ -8860,8 -9331,10 +8909,13 @@@ static void prepare_vmcs02(struct kvm_v
  			exec_control &= ~SECONDARY_EXEC_RDTSCP;
  		/* Take the following fields only from vmcs12 */
  		exec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
 -				  SECONDARY_EXEC_RDTSCP |
  				  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
++<<<<<<< HEAD
 +                                  SECONDARY_EXEC_APIC_REGISTER_VIRT);
++=======
+ 				  SECONDARY_EXEC_APIC_REGISTER_VIRT |
+ 				  SECONDARY_EXEC_PCOMMIT);
++>>>>>>> 8b3e34e46aca (KVM: x86: add pcommit support)
  		if (nested_cpu_has(vmcs12,
  				CPU_BASED_ACTIVATE_SECONDARY_CONTROLS))
  			exec_control |= vmcs12->secondary_vm_exec_control;
* Unmerged path arch/x86/include/asm/vmx.h
* Unmerged path arch/x86/include/uapi/asm/vmx.h
diff --git a/arch/x86/kvm/cpuid.c b/arch/x86/kvm/cpuid.c
index efc7f3feeced..10792461e14e 100644
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@ -330,7 +330,7 @@ static inline int __do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 function,
 		F(FSGSBASE) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |
 		F(BMI2) | F(ERMS) | f_invpcid | F(RTM) | f_mpx | F(RDSEED) |
 		F(ADX) | F(SMAP) | F(AVX512F) | F(AVX512PF) | F(AVX512ER) |
-		F(AVX512CD) | F(CLFLUSHOPT) | F(CLWB);
+		F(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(PCOMMIT);
 
 	/* cpuid 0xD.1.eax */
 	const u32 kvm_supported_word10_x86_features =
diff --git a/arch/x86/kvm/cpuid.h b/arch/x86/kvm/cpuid.h
index c346c610bd63..5be17bfff5ce 100644
--- a/arch/x86/kvm/cpuid.h
+++ b/arch/x86/kvm/cpuid.h
@@ -127,4 +127,12 @@ static inline bool guest_cpuid_has_mpx(struct kvm_vcpu *vcpu)
 	best = kvm_find_cpuid_entry(vcpu, 7, 0);
 	return best && (best->ebx & bit(X86_FEATURE_MPX));
 }
+
+static inline bool guest_cpuid_has_pcommit(struct kvm_vcpu *vcpu)
+{
+	struct kvm_cpuid_entry2 *best;
+
+	best = kvm_find_cpuid_entry(vcpu, 7, 0);
+	return best && (best->ebx & bit(X86_FEATURE_PCOMMIT));
+}
 #endif
* Unmerged path arch/x86/kvm/vmx.c
