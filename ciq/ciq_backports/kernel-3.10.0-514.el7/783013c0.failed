GFS2: Release iopen glock in gfs2_create_inode error cases

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit 783013c0f5c7263a31703b15aeebbac279b4d4fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/783013c0.failed

Some error cases in gfs2_create_inode were not unlocking the iopen
glock, getting the reference count off. This adds the proper unlock.
The error logic in function gfs2_create_inode was also convoluted,
so this patch simplifies it. It also takes care of a bug in
which gfs2_qa_delete() was not called in an error case.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 783013c0f5c7263a31703b15aeebbac279b4d4fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/inode.c
diff --cc fs/gfs2/inode.c
index 0db2e94034ce,87fa5992e12a..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -559,10 -594,10 +559,14 @@@ static int gfs2_create_inode(struct ino
  	struct gfs2_inode *dip = GFS2_I(dir), *ip;
  	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
  	struct gfs2_glock *io_gl;
++<<<<<<< HEAD
 +	struct dentry *d;
 +	int error, free_vfs_inode = 0;
++=======
+ 	int error, free_vfs_inode = 1;
++>>>>>>> 783013c0f5c7 (GFS2: Release iopen glock in gfs2_create_inode error cases)
  	u32 aflags = 0;
 -	unsigned blocks = 1;
 -	struct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };
 +	int arq;
  
  	if (!name->len || name->len > GFS2_FNAMESIZE)
  		return -ENAMETOOLONG;
@@@ -618,10 -649,14 +622,17 @@@
  	if (!inode)
  		goto fail_gunlock;
  
++<<<<<<< HEAD
++=======
+ 	error = posix_acl_create(dir, &mode, &default_acl, &acl);
+ 	if (error)
+ 		goto fail_gunlock;
+ 
++>>>>>>> 783013c0f5c7 (GFS2: Release iopen glock in gfs2_create_inode error cases)
  	ip = GFS2_I(inode);
 -	error = gfs2_rsqa_alloc(ip);
 +	error = gfs2_rs_alloc(ip);
  	if (error)
 -		goto fail_free_acls;
 +		goto fail_free_inode;
  
  	inode->i_mode = mode;
  	set_nlink(inode, S_ISDIR(mode) ? 2 : 1);
@@@ -695,7 -739,19 +706,23 @@@
  	gfs2_set_iop(inode);
  	insert_inode_hash(inode);
  
++<<<<<<< HEAD
 +	error = gfs2_acl_create(dip, inode);
++=======
+ 	free_vfs_inode = 0; /* After this point, the inode is no longer
+ 			       considered free. Any failures need to undo
+ 			       the gfs2 structures. */
+ 	if (default_acl) {
+ 		error = gfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);
+ 		posix_acl_release(default_acl);
+ 	}
+ 	if (acl) {
+ 		if (!error)
+ 			error = gfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);
+ 		posix_acl_release(acl);
+ 	}
+ 
++>>>>>>> 783013c0f5c7 (GFS2: Release iopen glock in gfs2_create_inode error cases)
  	if (error)
  		goto fail_gunlock3;
  
@@@ -728,9 -782,14 +752,18 @@@ fail_gunlock2
  fail_free_inode:
  	if (ip->i_gl)
  		gfs2_glock_put(ip->i_gl);
++<<<<<<< HEAD
 +	gfs2_rs_delete(ip);
 +	free_vfs_inode = 1;
++=======
+ 	gfs2_rsqa_delete(ip, NULL);
+ fail_free_acls:
+ 	if (default_acl)
+ 		posix_acl_release(default_acl);
+ 	if (acl)
+ 		posix_acl_release(acl);
++>>>>>>> 783013c0f5c7 (GFS2: Release iopen glock in gfs2_create_inode error cases)
  fail_gunlock:
 -	gfs2_dir_no_add(&da);
  	gfs2_glock_dq_uninit(ghs);
  	if (inode && !IS_ERR(inode)) {
  		clear_nlink(inode);
* Unmerged path fs/gfs2/inode.c
