tpm_tis: Disable interrupt auto probing on a per-device basis

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
commit ef7b81dc78642e1a33c890acf3214d1e04c90a8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ef7b81dc.failed

Instead of clearing the global interrupts flag when any device
does not have an interrupt just pass -1 through tpm_info.irq.

The only thing that asks for autoprobing is the force=1 path.

	Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
	Tested-by: Wilck, Martin <martin.wilck@ts.fujitsu.com>
	Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Acked-by: Peter Huewe <peterhuewe@gmx.de>
(cherry picked from commit ef7b81dc78642e1a33c890acf3214d1e04c90a8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm_tis.c
diff --cc drivers/char/tpm/tpm_tis.c
index b6392eb21cdb,d993fed51f23..000000000000
--- a/drivers/char/tpm/tpm_tis.c
+++ b/drivers/char/tpm/tpm_tis.c
@@@ -65,6 -65,21 +65,24 @@@ enum tis_defaults 
  	TIS_LONG_TIMEOUT = 2000,	/* 2 sec */
  };
  
++<<<<<<< HEAD
++=======
+ struct tpm_info {
+ 	unsigned long start;
+ 	unsigned long len;
+ 	/* irq > 0 means: use irq $irq;
+ 	 * irq = 0 means: autoprobe for an irq;
+ 	 * irq = -1 means: no irq support
+ 	 */
+ 	int irq;
+ };
+ 
+ static struct tpm_info tis_default_info = {
+ 	.start = TIS_MEM_BASE,
+ 	.len = TIS_MEM_LEN,
+ 	.irq = 0,
+ };
++>>>>>>> ef7b81dc7864 (tpm_tis: Disable interrupt auto probing on a per-device basis)
  
  /* Some timeout values are needed before it is known whether the chip is
   * TPM 1.0 or TPM 2.0.
@@@ -696,98 -810,15 +714,110 @@@ static int tpm_tis_init(struct device *
  	/* INTERRUPT Setup */
  	init_waitqueue_head(&chip->vendor.read_queue);
  	init_waitqueue_head(&chip->vendor.int_queue);
++<<<<<<< HEAD
 +
 +	if (interrupts)
 +		chip->vendor.irq = irq;
 +	if (interrupts && !chip->vendor.irq) {
 +		irq_s =
 +		    ioread8(chip->vendor.iobase +
 +			    TPM_INT_VECTOR(chip->vendor.locality));
 +		irq_r = irq_s;
 +		if (irq_s) {
 +			irq_e = irq_s;
 +		} else {
 +			irq_s = 3;
 +			irq_e = 15;
 +		}
 +
 +		for (i = irq_s; i <= irq_e && chip->vendor.irq == 0; i++) {
 +			iowrite8(i, chip->vendor.iobase +
 +				 TPM_INT_VECTOR(chip->vendor.locality));
 +			if (devm_request_irq
 +			    (dev, i, tis_int_handler, IRQF_SHARED,
 +			     chip->devname, chip) != 0) {
 +				dev_info(chip->pdev,
 +					 "Unable to request irq: %d for probe\n",
 +					 i);
 +				continue;
 +			}
 +			chip->vendor.irq = i;
 +
 +			/* Clear all existing */
 +			iowrite32(ioread32
 +				  (chip->vendor.iobase +
 +				   TPM_INT_STATUS(chip->vendor.locality)),
 +				  chip->vendor.iobase +
 +				  TPM_INT_STATUS(chip->vendor.locality));
 +
 +			/* Turn on */
 +			iowrite32(intmask | TPM_GLOBAL_INT_ENABLE,
 +				  chip->vendor.iobase +
 +				  TPM_INT_ENABLE(chip->vendor.locality));
 +
 +			priv->irq_tested = false;
 +			priv->irq_probing = true;
 +
 +			/* Generate Interrupts */
 +			if (chip->flags & TPM_CHIP_FLAG_TPM2)
 +				tpm2_gen_interrupt(chip);
 +			else
 +				tpm_gen_interrupt(chip);
 +
 +			priv->irq_probing = false;
 +
 +			/* tpm_tis_send will either confirm the interrupt is
 +			 * working or it will call disable_irq which undoes
 +			 * all of the above.
 +			 */
 +			if (chip->vendor.irq)
 +				break;
 +		}
 +		if (!chip->vendor.irq)
 +			iowrite8(irq_r, chip->vendor.iobase +
 +				 TPM_INT_VECTOR(chip->vendor.locality));
 +	}
 +	if (chip->vendor.irq && !priv->irq_tested) {
 +		iowrite8(chip->vendor.irq,
 +			 chip->vendor.iobase +
 +			 TPM_INT_VECTOR(chip->vendor.locality));
 +		if (devm_request_irq
 +		    (dev, chip->vendor.irq, tis_int_handler, IRQF_SHARED,
 +		     chip->devname, chip) != 0) {
 +			dev_info(chip->pdev,
 +				 "Unable to request irq: %d for use\n",
 +				 chip->vendor.irq);
 +			chip->vendor.irq = 0;
 +		} else {
 +			/* Clear all existing */
 +			iowrite32(ioread32
 +				  (chip->vendor.iobase +
 +				   TPM_INT_STATUS(chip->vendor.locality)),
 +				  chip->vendor.iobase +
 +				  TPM_INT_STATUS(chip->vendor.locality));
 +
 +			/* Turn on */
 +			iowrite32(intmask | TPM_GLOBAL_INT_ENABLE,
 +				  chip->vendor.iobase +
 +				  TPM_INT_ENABLE(chip->vendor.locality));
 +		}
 +	}
 +
 +	if (tpm_get_timeouts(chip)) {
 +		dev_err(dev, "Could not get TPM timeouts and durations\n");
 +		rc = -ENODEV;
 +		goto out_err;
++=======
+ 	if (interrupts && tpm_info->irq != -1) {
+ 		if (tpm_info->irq) {
+ 			tpm_tis_probe_irq_single(chip, intmask, IRQF_SHARED,
+ 						 tpm_info->irq);
+ 			if (!chip->vendor.irq)
+ 				dev_err(chip->pdev, FW_BUG
+ 					"TPM interrupt not working, polling instead\n");
+ 		} else
+ 			tpm_tis_probe_irq(chip, intmask);
++>>>>>>> ef7b81dc7864 (tpm_tis: Disable interrupt auto probing on a per-device basis)
  	}
  
  	if (chip->flags & TPM_CHIP_FLAG_TPM2) {
@@@ -867,29 -898,29 +897,33 @@@ static SIMPLE_DEV_PM_OPS(tpm_tis_pm, tp
  
  #ifdef CONFIG_PNP
  static int tpm_tis_pnp_init(struct pnp_dev *pnp_dev,
- 				      const struct pnp_device_id *pnp_id)
+ 			    const struct pnp_device_id *pnp_id)
  {
++<<<<<<< HEAD
 +	resource_size_t start, len;
 +	unsigned int irq = 0;
++=======
+ 	struct tpm_info tpm_info = {};
++>>>>>>> ef7b81dc7864 (tpm_tis: Disable interrupt auto probing on a per-device basis)
  	acpi_handle acpi_dev_handle = NULL;
  
 -	tpm_info.start = pnp_mem_start(pnp_dev, 0);
 -	tpm_info.len = pnp_mem_len(pnp_dev, 0);
 +	start = pnp_mem_start(pnp_dev, 0);
 +	len = pnp_mem_len(pnp_dev, 0);
  
  	if (pnp_irq_valid(pnp_dev, 0))
 -		tpm_info.irq = pnp_irq(pnp_dev, 0);
 +		irq = pnp_irq(pnp_dev, 0);
  	else
- 		interrupts = false;
+ 		tpm_info.irq = -1;
  
 -#ifdef CONFIG_ACPI
 -	if (pnp_acpi_device(pnp_dev)) {
 -		if (is_itpm(pnp_acpi_device(pnp_dev)))
 -			itpm = true;
 +	if (is_itpm(pnp_dev))
 +		itpm = true;
  
 +#ifdef CONFIG_ACPI
 +	if (pnp_acpi_device(pnp_dev))
  		acpi_dev_handle = pnp_acpi_device(pnp_dev)->handle;
 -	}
  #endif
  
 -	return tpm_tis_init(&pnp_dev->dev, &tpm_info, acpi_dev_handle);
 +	return tpm_tis_init(&pnp_dev->dev, acpi_dev_handle, start, len, irq);
  }
  
  static struct pnp_device_id tpm_pnp_tbl[] = {
@@@ -929,6 -961,77 +963,80 @@@ module_param_string(hid, tpm_pnp_tbl[TI
  MODULE_PARM_DESC(hid, "Set additional specific HID for this driver to probe");
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ACPI
+ static int tpm_check_resource(struct acpi_resource *ares, void *data)
+ {
+ 	struct tpm_info *tpm_info = (struct tpm_info *) data;
+ 	struct resource res;
+ 
+ 	if (acpi_dev_resource_interrupt(ares, 0, &res)) {
+ 		tpm_info->irq = res.start;
+ 	} else if (acpi_dev_resource_memory(ares, &res)) {
+ 		tpm_info->start = res.start;
+ 		tpm_info->len = resource_size(&res);
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ static int tpm_tis_acpi_init(struct acpi_device *acpi_dev)
+ {
+ 	struct list_head resources;
+ 	struct tpm_info tpm_info = tis_default_info;
+ 	int ret;
+ 
+ 	if (!is_fifo(acpi_dev))
+ 		return -ENODEV;
+ 
+ 	INIT_LIST_HEAD(&resources);
+ 	tpm_info.irq = -1;
+ 	ret = acpi_dev_get_resources(acpi_dev, &resources, tpm_check_resource,
+ 				     &tpm_info);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	acpi_dev_free_resource_list(&resources);
+ 
+ 	if (is_itpm(acpi_dev))
+ 		itpm = true;
+ 
+ 	return tpm_tis_init(&acpi_dev->dev, &tpm_info, acpi_dev->handle);
+ }
+ 
+ static int tpm_tis_acpi_remove(struct acpi_device *dev)
+ {
+ 	struct tpm_chip *chip = dev_get_drvdata(&dev->dev);
+ 
+ 	tpm_chip_unregister(chip);
+ 	tpm_tis_remove(chip);
+ 
+ 	return 0;
+ }
+ 
+ static struct acpi_device_id tpm_acpi_tbl[] = {
+ 	{"MSFT0101", 0},	/* TPM 2.0 */
+ 	/* Add new here */
+ 	{"", 0},		/* User Specified */
+ 	{"", 0}			/* Terminator */
+ };
+ MODULE_DEVICE_TABLE(acpi, tpm_acpi_tbl);
+ 
+ static struct acpi_driver tis_acpi_driver = {
+ 	.name = "tpm_tis",
+ 	.ids = tpm_acpi_tbl,
+ 	.ops = {
+ 		.add = tpm_tis_acpi_init,
+ 		.remove = tpm_tis_acpi_remove,
+ 	},
+ 	.drv = {
+ 		.pm = &tpm_tis_pm,
+ 	},
+ };
+ #endif
+ 
++>>>>>>> ef7b81dc7864 (tpm_tis: Disable interrupt auto probing on a per-device basis)
  static struct platform_driver tis_drv = {
  	.driver = {
  		.name		= "tpm_tis",
* Unmerged path drivers/char/tpm/tpm_tis.c
