Fix NULL pointer dereference in bl_free_device().

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [fs] Fix NULL pointer dereference in bl_free_device() (Benjamin Coddington) [1356796]
Rebuild_FUZZ: 98.97%
commit-author Artem Savkov <asavkov@redhat.com>
commit 297fae4d0bee5d683533f3324baf1b363e7b48bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/297fae4d.failed

When bl_parse_deviceid() fails in bl_alloc_deviceid_node() on
blkdev_get_by_*() step we get an pnfs_block_dev struct that is
uninitialized except for bdev field which is set to whatever error
blkdev_get_by_*() returns.  bl_free_device() then tries to call
blkdev_put() if bdev is not 0 resulting in a wrong pointer dereference.

Fixing this by setting bdev in struct pnfs_block_dev only if we didn't
get an error from blkdev_get_by_*().

	Signed-off-by: Artem Savkov <asavkov@redhat.com>
	Reviewed-by: Benjamin Coddington <bcodding@redhat.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 297fae4d0bee5d683533f3324baf1b363e7b48bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/blocklayout/dev.c
diff --cc fs/nfs/blocklayout/dev.c
index a861bbdfe577,a69ef4e9c24c..000000000000
--- a/fs/nfs/blocklayout/dev.c
+++ b/fs/nfs/blocklayout/dev.c
@@@ -216,6 -259,143 +218,146 @@@ bl_parse_simple(struct nfs_server *serv
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static bool
+ bl_validate_designator(struct pnfs_block_volume *v)
+ {
+ 	switch (v->scsi.designator_type) {
+ 	case PS_DESIGNATOR_EUI64:
+ 		if (v->scsi.code_set != PS_CODE_SET_BINARY)
+ 			return false;
+ 
+ 		if (v->scsi.designator_len != 8 &&
+ 		    v->scsi.designator_len != 10 &&
+ 		    v->scsi.designator_len != 16)
+ 			return false;
+ 
+ 		return true;
+ 	case PS_DESIGNATOR_NAA:
+ 		if (v->scsi.code_set != PS_CODE_SET_BINARY)
+ 			return false;
+ 
+ 		if (v->scsi.designator_len != 8 &&
+ 		    v->scsi.designator_len != 16)
+ 			return false;
+ 
+ 		return true;
+ 	case PS_DESIGNATOR_T10:
+ 	case PS_DESIGNATOR_NAME:
+ 		pr_err("pNFS: unsupported designator "
+ 			"(code set %d, type %d, len %d.\n",
+ 			v->scsi.code_set,
+ 			v->scsi.designator_type,
+ 			v->scsi.designator_len);
+ 		return false;
+ 	default:
+ 		pr_err("pNFS: invalid designator "
+ 			"(code set %d, type %d, len %d.\n",
+ 			v->scsi.code_set,
+ 			v->scsi.designator_type,
+ 			v->scsi.designator_len);
+ 		return false;
+ 	}
+ }
+ 
+ /*
+  * Try to open the udev path for the WWN.  At least on Debian the udev
+  * by-id path will always point to the dm-multipath device if one exists.
+  */
+ static struct block_device *
+ bl_open_udev_path(struct pnfs_block_volume *v)
+ {
+ 	struct block_device *bdev;
+ 	const char *devname;
+ 
+ 	devname = kasprintf(GFP_KERNEL, "/dev/disk/by-id/wwn-0x%*phN",
+ 				v->scsi.designator_len, v->scsi.designator);
+ 	if (!devname)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	bdev = blkdev_get_by_path(devname, FMODE_READ | FMODE_WRITE, NULL);
+ 	if (IS_ERR(bdev)) {
+ 		pr_warn("pNFS: failed to open device %s (%ld)\n",
+ 			devname, PTR_ERR(bdev));
+ 	}
+ 
+ 	kfree(devname);
+ 	return bdev;
+ }
+ 
+ /*
+  * Try to open the RH/Fedora specific dm-mpath udev path for this WWN, as the
+  * wwn- links will only point to the first discovered SCSI device there.
+  */
+ static struct block_device *
+ bl_open_dm_mpath_udev_path(struct pnfs_block_volume *v)
+ {
+ 	struct block_device *bdev;
+ 	const char *devname;
+ 
+ 	devname = kasprintf(GFP_KERNEL,
+ 			"/dev/disk/by-id/dm-uuid-mpath-%d%*phN",
+ 			v->scsi.designator_type,
+ 			v->scsi.designator_len, v->scsi.designator);
+ 	if (!devname)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	bdev = blkdev_get_by_path(devname, FMODE_READ | FMODE_WRITE, NULL);
+ 	kfree(devname);
+ 	return bdev;
+ }
+ 
+ static int
+ bl_parse_scsi(struct nfs_server *server, struct pnfs_block_dev *d,
+ 		struct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)
+ {
+ 	struct pnfs_block_volume *v = &volumes[idx];
+ 	struct block_device *bdev;
+ 	const struct pr_ops *ops;
+ 	int error;
+ 
+ 	if (!bl_validate_designator(v))
+ 		return -EINVAL;
+ 
+ 	bdev = bl_open_dm_mpath_udev_path(v);
+ 	if (IS_ERR(bdev))
+ 		bdev = bl_open_udev_path(v);
+ 	if (IS_ERR(bdev))
+ 		return PTR_ERR(bdev);
+ 	d->bdev = bdev;
+ 
+ 	d->len = i_size_read(d->bdev->bd_inode);
+ 	d->map = bl_map_simple;
+ 	d->pr_key = v->scsi.pr_key;
+ 
+ 	pr_info("pNFS: using block device %s (reservation key 0x%llx)\n",
+ 		d->bdev->bd_disk->disk_name, d->pr_key);
+ 
+ 	ops = d->bdev->bd_disk->fops->pr_ops;
+ 	if (!ops) {
+ 		pr_err("pNFS: block device %s does not support reservations.",
+ 				d->bdev->bd_disk->disk_name);
+ 		error = -EINVAL;
+ 		goto out_blkdev_put;
+ 	}
+ 
+ 	error = ops->pr_register(d->bdev, 0, d->pr_key, true);
+ 	if (error) {
+ 		pr_err("pNFS: failed to register key for block device %s.",
+ 				d->bdev->bd_disk->disk_name);
+ 		goto out_blkdev_put;
+ 	}
+ 
+ 	d->pr_registered = true;
+ 	return 0;
+ 
+ out_blkdev_put:
+ 	blkdev_put(d->bdev, FMODE_READ | FMODE_WRITE);
+ 	return error;
+ }
+ 
++>>>>>>> 297fae4d0bee (Fix NULL pointer dereference in bl_free_device().)
  static int
  bl_parse_slice(struct nfs_server *server, struct pnfs_block_dev *d,
  		struct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)
* Unmerged path fs/nfs/blocklayout/dev.c
