x86/efi: Implement a __efi_call_virt macro

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] efi: Implement a __efi_call_virt macro (Lenny Szubowicz) [1310154]
Rebuild_FUZZ: 95.00%
commit-author Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
commit 982e239cd2c73d2c70e14615a42c0c7391415a44
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/982e239c.failed

For i386, all the EFI system runtime services functions return efi_status_t
except efi_reset_system_system. Therefore, not all functions can be covered
by the same macro in case the macro needs to do more than calling the function
(i.e., return a value). The purpose of the __efi_call_virt macro is to be used
when no return value is expected.

For x86_64, this macro would not be needed as all the runtime services return
u64. However, the same code is used for both x86_64 and i386. Thus, the macro
__efi_call_virt is also defined to not break compilation.

	Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
	Cc: Borislav Petkov <bp@suse.de>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit 982e239cd2c73d2c70e14615a42c0c7391415a44)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/efi.h
#	arch/x86/platform/efi/efi.c
diff --cc arch/x86/include/asm/efi.h
index 46e39ba1f72c,19292e7cae58..000000000000
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@@ -42,16 -35,8 +43,21 @@@ extern unsigned long asmlinkage efi_cal
  #define efi_call_virt(f, args...) \
  	((efi_##f##_t __attribute__((regparm(0)))*)efi.systab->runtime->f)(args)
  
++<<<<<<< HEAD
 +#define efi_call_virt0(f)		efi_call_virt(f)
 +#define efi_call_virt1(f, a1)		efi_call_virt(f, a1)
 +#define efi_call_virt2(f, a1, a2)	efi_call_virt(f, a1, a2)
 +#define efi_call_virt3(f, a1, a2, a3)	efi_call_virt(f, a1, a2, a3)
 +#define efi_call_virt4(f, a1, a2, a3, a4)	\
 +	efi_call_virt(f, a1, a2, a3, a4)
 +#define efi_call_virt5(f, a1, a2, a3, a4, a5)	\
 +	efi_call_virt(f, a1, a2, a3, a4, a5)
 +#define efi_call_virt6(f, a1, a2, a3, a4, a5, a6)	\
 +	efi_call_virt(f, a1, a2, a3, a4, a5, a6)
++=======
+ /* Use this macro if your virtual call does not return any value */
+ #define __efi_call_virt(f, args...) efi_call_virt(f, args)
++>>>>>>> 982e239cd2c7 (x86/efi: Implement a __efi_call_virt macro)
  
  #define efi_ioremap(addr, size, type, attr)	ioremap_cache(addr, size)
  
@@@ -98,20 -59,11 +104,28 @@@ extern u64 efi_call6(void *fp, u64 arg1
  	__s;								\
  })
  
++<<<<<<< HEAD
 +#define efi_call_virt0(f)				\
 +	_efi_call_virtX(0, f)
 +#define efi_call_virt1(f, a1)				\
 +	_efi_call_virtX(1, f, (u64)(a1))
 +#define efi_call_virt2(f, a1, a2)			\
 +	_efi_call_virtX(2, f, (u64)(a1), (u64)(a2))
 +#define efi_call_virt3(f, a1, a2, a3)			\
 +	_efi_call_virtX(3, f, (u64)(a1), (u64)(a2), (u64)(a3))
 +#define efi_call_virt4(f, a1, a2, a3, a4)		\
 +	_efi_call_virtX(4, f, (u64)(a1), (u64)(a2), (u64)(a3), (u64)(a4))
 +#define efi_call_virt5(f, a1, a2, a3, a4, a5)		\
 +	_efi_call_virtX(5, f, (u64)(a1), (u64)(a2), (u64)(a3), (u64)(a4), (u64)(a5))
 +#define efi_call_virt6(f, a1, a2, a3, a4, a5, a6)	\
 +	_efi_call_virtX(6, f, (u64)(a1), (u64)(a2), (u64)(a3), (u64)(a4), (u64)(a5), (u64)(a6))
++=======
+ /*
+  * All X86_64 virt calls return non-void values. Thus, use non-void call for
+  * virt calls that would be void on X86_32.
+  */
+ #define __efi_call_virt(f, args...) efi_call_virt(f, args)
++>>>>>>> 982e239cd2c7 (x86/efi: Implement a __efi_call_virt macro)
  
  extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
  				 u32 type, u64 attribute);
diff --cc arch/x86/platform/efi/efi.c
index 4374bb91ee4e,835b24820eaa..000000000000
--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@@ -215,8 -202,8 +215,13 @@@ static void virt_efi_reset_system(int r
  				  unsigned long data_size,
  				  efi_char16_t *data)
  {
++<<<<<<< HEAD
 +	efi_call_virt4(reset_system, reset_type, status,
 +		       data_size, data);
++=======
+ 	__efi_call_virt(reset_system, reset_type, status,
+ 			data_size, data);
++>>>>>>> 982e239cd2c7 (x86/efi: Implement a __efi_call_virt macro)
  }
  
  static efi_status_t virt_efi_update_capsule(efi_capsule_header_t **capsules,
* Unmerged path arch/x86/include/asm/efi.h
* Unmerged path arch/x86/platform/efi/efi.c
