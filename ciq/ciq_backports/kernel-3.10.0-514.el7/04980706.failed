tty: Remove TTY_CLOSING

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [tty] Remove TTY_CLOSING ("Herton R. Krzesinski") [1327403]
Rebuild_FUZZ: 87.80%
commit-author Peter Hurley <peter@hurleysoftware.com>
commit 04980706c8febe41ec598116b174bd3a2dc82355
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/04980706.failed

Now that re-open is not permitted for a legacy BSD pty master,
using TTY_CLOSING to indicate when a tty can be torn-down is
no longer necessary.

	Reviewed-by: Alan Cox <alan@linux.intel.com>
	Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 04980706c8febe41ec598116b174bd3a2dc82355)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/tty.h
diff --cc include/linux/tty.h
index 8ddae3b5452c,35b29f0750f8..000000000000
--- a/include/linux/tty.h
+++ b/include/linux/tty.h
@@@ -307,8 -316,6 +307,11 @@@ struct tty_file_private 
  #define TTY_EXCLUSIVE 		3	/* Exclusive open mode */
  #define TTY_DEBUG 		4	/* Debugging */
  #define TTY_DO_WRITE_WAKEUP 	5	/* Call write_wakeup after queuing new */
++<<<<<<< HEAD
 +#define TTY_PUSH 		6	/* n_tty private */
 +#define TTY_CLOSING 		7	/* ->close() in progress */
++=======
++>>>>>>> 04980706c8fe (tty: Remove TTY_CLOSING)
  #define TTY_LDISC_OPEN	 	11	/* Line discipline is open */
  #define TTY_PTY_LOCK 		16	/* pty private */
  #define TTY_NO_WRITE_SPLIT 	17	/* Preserve write boundaries to driver */
diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c
index e455c78cb633..b0724b7fba09 100644
--- a/drivers/tty/tty_io.c
+++ b/drivers/tty/tty_io.c
@@ -1163,7 +1163,7 @@ void tty_write_message(struct tty_struct *tty, char *msg)
 	if (tty) {
 		mutex_lock(&tty->atomic_write_lock);
 		tty_lock(tty);
-		if (tty->ops->write && !test_bit(TTY_CLOSING, &tty->flags)) {
+		if (tty->ops->write && tty->count > 0) {
 			tty_unlock(tty);
 			tty->ops->write(tty, msg, strlen(msg));
 		} else
@@ -1817,16 +1817,6 @@ int tty_release(struct inode *inode, struct file *filp)
 	/*
 	 * Perform some housekeeping before deciding whether to return.
 	 *
-	 * Set the TTY_CLOSING flag if this was the last open.  In the
-	 * case of a pty we may have to wait around for the other side
-	 * to close, and TTY_CLOSING makes sure we can't be reopened.
-	 */
-	if (tty_closing)
-		set_bit(TTY_CLOSING, &tty->flags);
-	if (o_tty_closing)
-		set_bit(TTY_CLOSING, &o_tty->flags);
-
-	/*
 	 * If _either_ side is closing, make sure there aren't any
 	 * processes that still think tty or o_tty is their controlling
 	 * tty.
@@ -1841,7 +1831,7 @@ int tty_release(struct inode *inode, struct file *filp)
 
 	mutex_unlock(&tty_mutex);
 	tty_unlock_pair(tty, o_tty);
-	/* At this point the TTY_CLOSING flag should ensure a dead tty
+	/* At this point, the tty->count == 0 should ensure a dead tty
 	   cannot be re-opened by a racing opener */
 
 	/* check whether both sides are closing ... */
* Unmerged path include/linux/tty.h
