ip_tunnel: implement __iptunnel_pull_header

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit a6d5bbf34efa8330af7b0b1dba0f38148516ed97
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a6d5bbf3.failed

Allow calling of iptunnel_pull_header without special casing ETH_P_TEB inner
protocol.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a6d5bbf34efa8330af7b0b1dba0f38148516ed97)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip_tunnels.h
#	net/ipv4/ip_tunnel_core.c
diff --cc include/net/ip_tunnels.h
index 3a5ac80169cf,16435d8b1f93..000000000000
--- a/include/net/ip_tunnels.h
+++ b/include/net/ip_tunnels.h
@@@ -267,23 -295,46 +267,40 @@@ static inline u8 ip_tunnel_ecn_encap(u
  	return INET_ECN_encapsulate(tos, inner);
  }
  
++<<<<<<< HEAD
 +int iptunnel_pull_header(struct sk_buff *skb, int hdr_len, __be16 inner_proto);
 +int iptunnel_xmit(struct sock *sk, struct rtable *rt, struct sk_buff *skb,
 +		  __be32 src, __be32 dst, u8 proto,
 +		  u8 tos, u8 ttl, __be16 df, bool xnet);
++=======
+ int __iptunnel_pull_header(struct sk_buff *skb, int hdr_len,
+ 			   __be16 inner_proto, bool raw_proto, bool xnet);
+ 
+ static inline int iptunnel_pull_header(struct sk_buff *skb, int hdr_len,
+ 				       __be16 inner_proto, bool xnet)
+ {
+ 	return __iptunnel_pull_header(skb, hdr_len, inner_proto, false, xnet);
+ }
+ 
+ void iptunnel_xmit(struct sock *sk, struct rtable *rt, struct sk_buff *skb,
+ 		   __be32 src, __be32 dst, u8 proto,
+ 		   u8 tos, u8 ttl, __be16 df, bool xnet);
+ struct metadata_dst *iptunnel_metadata_reply(struct metadata_dst *md,
+ 					     gfp_t flags);
++>>>>>>> a6d5bbf34efa (ip_tunnel: implement __iptunnel_pull_header)
  
 -struct sk_buff *iptunnel_handle_offloads(struct sk_buff *skb, int gso_type_mask);
 +struct sk_buff *iptunnel_handle_offloads(struct sk_buff *skb, bool gre_csum,
 +					 int gso_type_mask);
  
 -static inline int iptunnel_pull_offloads(struct sk_buff *skb)
 +static inline void iptunnel_xmit_stats(int err,
 +				       struct net_device_stats *err_stats,
 +				       struct pcpu_sw_netstats __percpu *stats)
  {
 -	if (skb_is_gso(skb)) {
 -		int err;
 -
 -		err = skb_unclone(skb, GFP_ATOMIC);
 -		if (unlikely(err))
 -			return err;
 -		skb_shinfo(skb)->gso_type &= ~(NETIF_F_GSO_ENCAP_ALL >>
 -					       NETIF_F_GSO_SHIFT);
 -	}
 -
 -	skb->encapsulation = 0;
 -	return 0;
 -}
 -
 -static inline void iptunnel_xmit_stats(struct net_device *dev, int pkt_len)
 -{
 -	if (pkt_len > 0) {
 -		struct pcpu_sw_netstats *tstats = get_cpu_ptr(dev->tstats);
 +	if (err > 0) {
 +		struct pcpu_sw_netstats *tstats = get_cpu_ptr(stats);
  
  		u64_stats_update_begin(&tstats->syncp);
 -		tstats->tx_bytes += pkt_len;
 +		tstats->tx_bytes += err;
  		tstats->tx_packets++;
  		u64_stats_update_end(&tstats->syncp);
  		put_cpu_ptr(tstats);
diff --cc net/ipv4/ip_tunnel_core.c
index c969294e6abb,43445df61efd..000000000000
--- a/net/ipv4/ip_tunnel_core.c
+++ b/net/ipv4/ip_tunnel_core.c
@@@ -83,7 -86,8 +83,12 @@@ int iptunnel_xmit(struct sock *sk, stru
  }
  EXPORT_SYMBOL_GPL(iptunnel_xmit);
  
++<<<<<<< HEAD
 +int iptunnel_pull_header(struct sk_buff *skb, int hdr_len, __be16 inner_proto)
++=======
+ int __iptunnel_pull_header(struct sk_buff *skb, int hdr_len,
+ 			   __be16 inner_proto, bool raw_proto, bool xnet)
++>>>>>>> a6d5bbf34efa (ip_tunnel: implement __iptunnel_pull_header)
  {
  	if (unlikely(!pskb_may_pull(skb, hdr_len)))
  		return -ENOMEM;
@@@ -106,19 -110,43 +111,19 @@@
  		skb->protocol = inner_proto;
  	}
  
 +	nf_reset(skb);
 +	secpath_reset(skb);
  	skb_clear_hash_if_not_l4(skb);
 +	skb_dst_drop(skb);
  	skb->vlan_tci = 0;
  	skb_set_queue_mapping(skb, 0);
 -	skb_scrub_packet(skb, xnet);
 -
 -	return iptunnel_pull_offloads(skb);
 +	skb->pkt_type = PACKET_HOST;
 +	return 0;
  }
- EXPORT_SYMBOL_GPL(iptunnel_pull_header);
+ EXPORT_SYMBOL_GPL(__iptunnel_pull_header);
  
 -struct metadata_dst *iptunnel_metadata_reply(struct metadata_dst *md,
 -					     gfp_t flags)
 -{
 -	struct metadata_dst *res;
 -	struct ip_tunnel_info *dst, *src;
 -
 -	if (!md || md->u.tun_info.mode & IP_TUNNEL_INFO_TX)
 -		return NULL;
 -
 -	res = metadata_dst_alloc(0, flags);
 -	if (!res)
 -		return NULL;
 -
 -	dst = &res->u.tun_info;
 -	src = &md->u.tun_info;
 -	dst->key.tun_id = src->key.tun_id;
 -	if (src->mode & IP_TUNNEL_INFO_IPV6)
 -		memcpy(&dst->key.u.ipv6.dst, &src->key.u.ipv6.src,
 -		       sizeof(struct in6_addr));
 -	else
 -		dst->key.u.ipv4.dst = src->key.u.ipv4.src;
 -	dst->mode = src->mode | IP_TUNNEL_INFO_TX;
 -
 -	return res;
 -}
 -EXPORT_SYMBOL_GPL(iptunnel_metadata_reply);
 -
  struct sk_buff *iptunnel_handle_offloads(struct sk_buff *skb,
 +					 bool csum_help,
  					 int gso_type_mask)
  {
  	int err;
* Unmerged path include/net/ip_tunnels.h
* Unmerged path net/ipv4/ip_tunnel_core.c
