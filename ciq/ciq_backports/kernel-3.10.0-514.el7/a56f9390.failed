perf stat report: Process stat and stat round events

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit a56f9390aa9d9b1c782c3dbd5ca2c4245eb265fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a56f9390.failed

Adding processing of stat and stat round events.

The stat data com in stat events, using generic function
process_stat_round_event to store data under perf_evsel object.

The stat-round events comes each interval or as last event in non
interval mode. The function process_stat_round_event process stored data
for each perf_evsel object and print it out.

Committer note:

After this patch:

  $ perf stat record usleep 1

   Performance counter stats for 'usleep 1':

        0.498381  task-clock (msec)       #    0.571 CPUs utilized
               2  context-switches        #    0.004 M/sec
               0  cpu-migrations          #    0.000 K/sec
             149  page-faults             #    0.299 M/sec
       1,271,635  cycles                  #    2.552 GHz
         928,712  stalled-cycles-frontend #   73.03% frontend cycles idle
         663,286  stalled-cycles-backend  #   52.16% backend  cycles idle
         792,614  instructions            #    0.62  insns per cycle
                                          #    1.17  stalled cycles per insn
         136,850  branches                #  274.589 M/sec
   <not counted>  branch-misses            (0.00%)

     0.000873419 seconds time elapsed

  $
  $ perf stat report

   Performance counter stats for '/home/acme/bin/perf stat record usleep 1':

        0.498381  task-clock (msec)       #    0.571 CPUs utilized
               2  context-switches        #    0.004 M/sec
               0  cpu-migrations          #    0.000 K/sec
             149  page-faults             #    0.299 M/sec
       1,271,635  cycles                  #    2.552 GHz
         928,712  stalled-cycles-frontend #   73.03% frontend cycles idle
         663,286  stalled-cycles-backend  #   52.16% backend  cycles idle
         792,614  instructions            #    0.62  insns per cycle
                                          #    1.17  stalled cycles per insn
         136,850  branches                #  274.589 M/sec
   <not counted>  branch-misses            (0.00%)

     0.000873419 seconds time elapsed

  $

	Reported-by: Kan Liang <kan.liang@intel.com>
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1446734469-11352-16-git-send-email-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit a56f9390aa9d9b1c782c3dbd5ca2c4245eb265fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-stat.c
diff --cc tools/perf/builtin-stat.c
index 473fc692d35a,d27d1b921efa..000000000000
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@@ -1136,71 -1580,210 +1136,276 @@@ static int add_default_attributes(void
  	return perf_evlist__add_default_attrs(evsel_list, very_very_detailed_attrs);
  }
  
++<<<<<<< HEAD
++=======
+ static const char * const recort_usage[] = {
+ 	"perf stat record [<options>]",
+ 	NULL,
+ };
+ 
+ static void init_features(struct perf_session *session)
+ {
+ 	int feat;
+ 
+ 	for (feat = HEADER_FIRST_FEATURE; feat < HEADER_LAST_FEATURE; feat++)
+ 		perf_header__set_feat(&session->header, feat);
+ 
+ 	perf_header__clear_feat(&session->header, HEADER_BUILD_ID);
+ 	perf_header__clear_feat(&session->header, HEADER_TRACING_DATA);
+ 	perf_header__clear_feat(&session->header, HEADER_BRANCH_STACK);
+ 	perf_header__clear_feat(&session->header, HEADER_AUXTRACE);
+ }
+ 
+ static int __cmd_record(int argc, const char **argv)
+ {
+ 	struct perf_session *session;
+ 	struct perf_data_file *file = &perf_stat.file;
+ 
+ 	argc = parse_options(argc, argv, stat_options, record_usage,
+ 			     PARSE_OPT_STOP_AT_NON_OPTION);
+ 
+ 	if (output_name)
+ 		file->path = output_name;
+ 
+ 	if (run_count != 1 || forever) {
+ 		pr_err("Cannot use -r option with perf stat record.\n");
+ 		return -1;
+ 	}
+ 
+ 	session = perf_session__new(file, false, NULL);
+ 	if (session == NULL) {
+ 		pr_err("Perf session creation failed.\n");
+ 		return -1;
+ 	}
+ 
+ 	init_features(session);
+ 
+ 	session->evlist   = evsel_list;
+ 	perf_stat.session = session;
+ 	perf_stat.record  = true;
+ 	return argc;
+ }
+ 
+ static int process_stat_round_event(struct perf_tool *tool __maybe_unused,
+ 				    union perf_event *event,
+ 				    struct perf_session *session)
+ {
+ 	struct stat_round_event *round = &event->stat_round;
+ 	struct perf_evsel *counter;
+ 	struct timespec tsh, *ts = NULL;
+ 	const char **argv = session->header.env.cmdline_argv;
+ 	int argc = session->header.env.nr_cmdline;
+ 
+ 	evlist__for_each(evsel_list, counter)
+ 		perf_stat_process_counter(&stat_config, counter);
+ 
+ 	if (round->type == PERF_STAT_ROUND_TYPE__FINAL)
+ 		update_stats(&walltime_nsecs_stats, round->time);
+ 
+ 	if (stat_config.interval && round->time) {
+ 		tsh.tv_sec  = round->time / NSECS_PER_SEC;
+ 		tsh.tv_nsec = round->time % NSECS_PER_SEC;
+ 		ts = &tsh;
+ 	}
+ 
+ 	print_counters(ts, argc, argv);
+ 	return 0;
+ }
+ 
+ static
+ int process_stat_config_event(struct perf_tool *tool __maybe_unused,
+ 			      union perf_event *event,
+ 			      struct perf_session *session __maybe_unused)
+ {
+ 	struct perf_stat *st = container_of(tool, struct perf_stat, tool);
+ 
+ 	perf_event__read_stat_config(&stat_config, &event->stat_config);
+ 
+ 	if (perf_stat.file.is_pipe)
+ 		perf_stat_init_aggr_mode();
+ 	else
+ 		perf_stat_init_aggr_mode_file(st);
+ 
+ 	return 0;
+ }
+ 
+ static int set_maps(struct perf_stat *st)
+ {
+ 	if (!st->cpus || !st->threads)
+ 		return 0;
+ 
+ 	if (WARN_ONCE(st->maps_allocated, "stats double allocation\n"))
+ 		return -EINVAL;
+ 
+ 	perf_evlist__set_maps(evsel_list, st->cpus, st->threads);
+ 
+ 	if (perf_evlist__alloc_stats(evsel_list, true))
+ 		return -ENOMEM;
+ 
+ 	st->maps_allocated = true;
+ 	return 0;
+ }
+ 
+ static
+ int process_thread_map_event(struct perf_tool *tool __maybe_unused,
+ 			     union perf_event *event,
+ 			     struct perf_session *session __maybe_unused)
+ {
+ 	struct perf_stat *st = container_of(tool, struct perf_stat, tool);
+ 
+ 	if (st->threads) {
+ 		pr_warning("Extra thread map event, ignoring.\n");
+ 		return 0;
+ 	}
+ 
+ 	st->threads = thread_map__new_event(&event->thread_map);
+ 	if (!st->threads)
+ 		return -ENOMEM;
+ 
+ 	return set_maps(st);
+ }
+ 
+ static
+ int process_cpu_map_event(struct perf_tool *tool __maybe_unused,
+ 			  union perf_event *event,
+ 			  struct perf_session *session __maybe_unused)
+ {
+ 	struct perf_stat *st = container_of(tool, struct perf_stat, tool);
+ 	struct cpu_map *cpus;
+ 
+ 	if (st->cpus) {
+ 		pr_warning("Extra cpu map event, ignoring.\n");
+ 		return 0;
+ 	}
+ 
+ 	cpus = cpu_map__new_data(&event->cpu_map.data);
+ 	if (!cpus)
+ 		return -ENOMEM;
+ 
+ 	st->cpus = cpus;
+ 	return set_maps(st);
+ }
+ 
+ static const char * const report_usage[] = {
+ 	"perf stat report [<options>]",
+ 	NULL,
+ };
+ 
+ static struct perf_stat perf_stat = {
+ 	.tool = {
+ 		.attr		= perf_event__process_attr,
+ 		.thread_map	= process_thread_map_event,
+ 		.cpu_map	= process_cpu_map_event,
+ 		.stat_config	= process_stat_config_event,
+ 		.stat		= perf_event__process_stat_event,
+ 		.stat_round	= process_stat_round_event,
+ 	},
+ };
+ 
+ static int __cmd_report(int argc, const char **argv)
+ {
+ 	struct perf_session *session;
+ 	const struct option options[] = {
+ 	OPT_STRING('i', "input", &input_name, "file", "input file name"),
+ 	OPT_END()
+ 	};
+ 	struct stat st;
+ 	int ret;
+ 
+ 	argc = parse_options(argc, argv, options, report_usage, 0);
+ 
+ 	if (!input_name || !strlen(input_name)) {
+ 		if (!fstat(STDIN_FILENO, &st) && S_ISFIFO(st.st_mode))
+ 			input_name = "-";
+ 		else
+ 			input_name = "perf.data";
+ 	}
+ 
+ 	perf_stat.file.path = input_name;
+ 	perf_stat.file.mode = PERF_DATA_MODE_READ;
+ 
+ 	session = perf_session__new(&perf_stat.file, false, &perf_stat.tool);
+ 	if (session == NULL)
+ 		return -1;
+ 
+ 	perf_stat.session  = session;
+ 	stat_config.output = stderr;
+ 	evsel_list         = session->evlist;
+ 
+ 	ret = perf_session__process_events(session);
+ 	if (ret)
+ 		return ret;
+ 
+ 	perf_session__delete(session);
+ 	return 0;
+ }
+ 
++>>>>>>> a56f9390aa9d (perf stat report: Process stat and stat round events)
  int cmd_stat(int argc, const char **argv, const char *prefix __maybe_unused)
  {
 +	bool append_file = false;
 +	int output_fd = 0;
 +	const char *output_name	= NULL;
 +	const struct option options[] = {
 +	OPT_BOOLEAN('T', "transaction", &transaction_run,
 +		    "hardware transaction statistics"),
 +	OPT_CALLBACK('e', "event", &evsel_list, "event",
 +		     "event selector. use 'perf list' to list available events",
 +		     parse_events_option),
 +	OPT_CALLBACK(0, "filter", &evsel_list, "filter",
 +		     "event filter", parse_filter),
 +	OPT_BOOLEAN('i', "no-inherit", &no_inherit,
 +		    "child tasks do not inherit counters"),
 +	OPT_STRING('p', "pid", &target.pid, "pid",
 +		   "stat events on existing process id"),
 +	OPT_STRING('t', "tid", &target.tid, "tid",
 +		   "stat events on existing thread id"),
 +	OPT_BOOLEAN('a', "all-cpus", &target.system_wide,
 +		    "system-wide collection from all CPUs"),
 +	OPT_BOOLEAN('g', "group", &group,
 +		    "put the counters into a counter group"),
 +	OPT_BOOLEAN('c', "scale", &stat_config.scale, "scale/normalize counters"),
 +	OPT_INCR('v', "verbose", &verbose,
 +		    "be more verbose (show counter open errors, etc)"),
 +	OPT_INTEGER('r', "repeat", &run_count,
 +		    "repeat command and print average + stddev (max: 100, forever: 0)"),
 +	OPT_BOOLEAN('n', "null", &null_run,
 +		    "null run - dont start any counters"),
 +	OPT_INCR('d', "detailed", &detailed_run,
 +		    "detailed run - start a lot of events"),
 +	OPT_BOOLEAN('S', "sync", &sync_run,
 +		    "call sync() before starting a run"),
 +	OPT_CALLBACK_NOOPT('B', "big-num", NULL, NULL,
 +			   "print large numbers with thousands\' separators",
 +			   stat__set_big_num),
 +	OPT_STRING('C', "cpu", &target.cpu_list, "cpu",
 +		    "list of cpus to monitor in system-wide"),
 +	OPT_SET_UINT('A', "no-aggr", &stat_config.aggr_mode,
 +		    "disable CPU count aggregation", AGGR_NONE),
 +	OPT_STRING('x', "field-separator", &csv_sep, "separator",
 +		   "print counts with custom separator"),
 +	OPT_CALLBACK('G', "cgroup", &evsel_list, "name",
 +		     "monitor event in cgroup name only", parse_cgroups),
 +	OPT_STRING('o', "output", &output_name, "file", "output file name"),
 +	OPT_BOOLEAN(0, "append", &append_file, "append to the output file"),
 +	OPT_INTEGER(0, "log-fd", &output_fd,
 +		    "log output to fd, instead of stderr"),
 +	OPT_STRING(0, "pre", &pre_cmd, "command",
 +			"command to run prior to the measured command"),
 +	OPT_STRING(0, "post", &post_cmd, "command",
 +			"command to run after to the measured command"),
 +	OPT_UINTEGER('I', "interval-print", &stat_config.interval,
 +		    "print counts at regular interval in ms (>= 10)"),
 +	OPT_SET_UINT(0, "per-socket", &stat_config.aggr_mode,
 +		     "aggregate counts per processor socket", AGGR_SOCKET),
 +	OPT_SET_UINT(0, "per-core", &stat_config.aggr_mode,
 +		     "aggregate counts per physical processor core", AGGR_CORE),
 +	OPT_SET_UINT(0, "per-thread", &stat_config.aggr_mode,
 +		     "aggregate counts per thread", AGGR_THREAD),
 +	OPT_UINTEGER('D', "delay", &initial_delay,
 +		     "ms to wait before starting measurement after program start"),
 +	OPT_END()
 +	};
  	const char * const stat_usage[] = {
  		"perf stat [<options>] [<command>]",
  		NULL
* Unmerged path tools/perf/builtin-stat.c
