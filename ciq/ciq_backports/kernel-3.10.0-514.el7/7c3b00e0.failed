ptrace: make wait_on_bit(JOBCTL_TRAPPING_BIT) in ptrace_attach() killable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Oleg Nesterov <oleg@redhat.com>
commit 7c3b00e06d731a28fc3d17ed02ba250642b15b81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7c3b00e0.failed

ptrace_attach() can hang waiting for STOPPED -> TRACED transition if the
tracee gets frozen in between, change wait_on_bit() to use TASK_KILLABLE.

This doesn't really solve the problem(s) and we probably need to fix the
freezer.  In particular, note that this means that pm freezer will fail if
it races attach-to-stopped-task.

And otoh perhaps we can just remove JOBCTL_TRAPPING_BIT altogether, it is
not clear if we really need to hide this transition from debugger, WNOHANG
after PTRACE_ATTACH can fail anyway if it races with SIGCONT.

	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Reported-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Roland McGrath <roland@hack.frob.com>
	Acked-by: Tejun Heo <tj@kernel.org>
	Cc: Pedro Alves <palves@redhat.com>
	Cc: Jan Kratochvil <jan.kratochvil@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 7c3b00e06d731a28fc3d17ed02ba250642b15b81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/ptrace.c
diff --cc kernel/ptrace.c
index 7b8da0fa6306,aa94aee9d4c9..000000000000
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@@ -370,8 -364,14 +370,19 @@@ unlock_creds
  	mutex_unlock(&task->signal->cred_guard_mutex);
  out:
  	if (!retval) {
++<<<<<<< HEAD
 +		wait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT,
 +			    ptrace_trapping_sleep_fn, TASK_UNINTERRUPTIBLE);
++=======
+ 		/*
+ 		 * We do not bother to change retval or clear JOBCTL_TRAPPING
+ 		 * if wait_on_bit() was interrupted by SIGKILL. The tracer will
+ 		 * not return to user-mode, it will exit and clear this bit in
+ 		 * __ptrace_unlink() if it wasn't already cleared by the tracee;
+ 		 * and until then nobody can ptrace this task.
+ 		 */
+ 		wait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);
++>>>>>>> 7c3b00e06d73 (ptrace: make wait_on_bit(JOBCTL_TRAPPING_BIT) in ptrace_attach() killable)
  		proc_ptrace_connector(task, PTRACE_ATTACH);
  	}
  
* Unmerged path kernel/ptrace.c
