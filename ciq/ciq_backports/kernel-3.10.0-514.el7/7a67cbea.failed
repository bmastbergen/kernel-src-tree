nvme: use offset instead of a struct for registers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 7a67cbea653e444d04d7e850ab9631a14a196422
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7a67cbea.failed

This makes life easier for future non-PCI drivers where access to the
registers might be more complicated.  Note that Linux drivers are
pretty evenly split between the two versions, and in fact the NVMe
driver already uses offsets for the doorbells.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Acked-by: Keith Busch <keith.busch@intel.com>
[Fixed CMBSZ offset]
	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 7a67cbea653e444d04d7e850ab9631a14a196422)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
#	drivers/block/nvme-scsi.c
#	drivers/nvme/host/nvme.h
#	include/linux/nvme.h
diff --cc drivers/block/nvme-core.c
index 2a6eb55ad96c,bfea7ec22b98..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -1492,32 -1600,30 +1492,37 @@@ static int nvme_configure_admin_queue(s
  {
  	int result;
  	u32 aqa;
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +	u64 cap = readq(&dev->bar->cap);
++=======
+ 	u64 cap = lo_hi_readq(dev->bar + NVME_REG_CAP);
++>>>>>>> 7a67cbea653e (nvme: use offset instead of a struct for registers):drivers/nvme/host/pci.c
  	struct nvme_queue *nvmeq;
 -	/*
 -	 * default to a 4K page size, with the intention to update this
 -	 * path in the future to accomodate architectures with differing
 -	 * kernel and IO page sizes.
 -	 */
 -	unsigned page_shift = 12;
 +	unsigned page_shift = PAGE_SHIFT;
  	unsigned dev_page_min = NVME_CAP_MPSMIN(cap) + 12;
 +	unsigned dev_page_max = NVME_CAP_MPSMAX(cap) + 12;
  
  	if (page_shift < dev_page_min) {
 -		dev_err(dev->dev,
 +		dev_err(&dev->pci_dev->dev,
  				"Minimum device page size (%u) too large for "
  				"host (%u)\n", 1 << dev_page_min,
  				1 << page_shift);
  		return -ENODEV;
  	}
 +	if (page_shift > dev_page_max) {
 +		dev_info(&dev->pci_dev->dev,
 +				"Device maximum page size (%u) smaller than "
 +				"host (%u); enabling work-around\n",
 +				1 << dev_page_max, 1 << page_shift);
 +		page_shift = dev_page_max;
 +	}
  
- 	dev->subsystem = readl(&dev->bar->vs) >= NVME_VS(1, 1) ?
+ 	dev->subsystem = readl(dev->bar + NVME_REG_VS) >= NVME_VS(1, 1) ?
  						NVME_CAP_NSSRC(cap) : 0;
  
- 	if (dev->subsystem && (readl(&dev->bar->csts) & NVME_CSTS_NSSRO))
- 		writel(NVME_CSTS_NSSRO, &dev->bar->csts);
+ 	if (dev->subsystem &&
+ 	    (readl(dev->bar + NVME_REG_CSTS) & NVME_CSTS_NSSRO))
+ 		writel(NVME_CSTS_NSSRO, dev->bar + NVME_REG_CSTS);
  
  	result = nvme_disable_ctrl(dev, cap);
  	if (result < 0)
@@@ -1540,9 -1646,9 +1545,15 @@@
  	dev->ctrl_config |= NVME_CC_ARB_RR | NVME_CC_SHN_NONE;
  	dev->ctrl_config |= NVME_CC_IOSQES | NVME_CC_IOCQES;
  
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +	writel(aqa, &dev->bar->aqa);
 +	writeq(nvmeq->sq_dma_addr, &dev->bar->asq);
 +	writeq(nvmeq->cq_dma_addr, &dev->bar->acq);
++=======
+ 	writel(aqa, dev->bar + NVME_REG_AQA);
+ 	lo_hi_writeq(nvmeq->sq_dma_addr, dev->bar + NVME_REG_ASQ);
+ 	lo_hi_writeq(nvmeq->cq_dma_addr, dev->bar + NVME_REG_ACQ);
++>>>>>>> 7a67cbea653e (nvme: use offset instead of a struct for registers):drivers/nvme/host/pci.c
  
  	result = nvme_enable_ctrl(dev, cap);
  	if (result)
@@@ -2073,15 -2081,11 +2084,23 @@@ static int nvme_kthread(void *data
  
  			if ((dev->subsystem && (csts & NVME_CSTS_NSSRO)) ||
  							csts & NVME_CSTS_CFS) {
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +				if (work_busy(&dev->reset_work))
 +					continue;
 +				list_del_init(&dev->node);
 +				dev_warn(&dev->pci_dev->dev,
 +					"Failed status: %x, reset controller\n",
 +					readl(&dev->bar->csts));
 +				PREPARE_WORK(&dev->reset_work,
 +							nvme_reset_failed_dev);
 +				queue_work(nvme_workq, &dev->reset_work);
++=======
+ 				if (!__nvme_reset(dev)) {
+ 					dev_warn(dev->dev,
+ 						"Failed status: %x, reset controller\n",
+ 						readl(dev->bar + NVME_REG_CSTS));
+ 				}
++>>>>>>> 7a67cbea653e (nvme: use offset instead of a struct for registers):drivers/nvme/host/pci.c
  				continue;
  			}
  			for (i = 0; i < dev->queue_count; i++) {
@@@ -2218,6 -2232,58 +2237,61 @@@ static int set_queue_count(struct nvme_
  	return min(result & 0xffff, result >> 16) + 1;
  }
  
++<<<<<<< HEAD:drivers/block/nvme-core.c
++=======
+ static void __iomem *nvme_map_cmb(struct nvme_dev *dev)
+ {
+ 	u64 szu, size, offset;
+ 	u32 cmbloc;
+ 	resource_size_t bar_size;
+ 	struct pci_dev *pdev = to_pci_dev(dev->dev);
+ 	void __iomem *cmb;
+ 	dma_addr_t dma_addr;
+ 
+ 	if (!use_cmb_sqes)
+ 		return NULL;
+ 
+ 	dev->cmbsz = readl(dev->bar + NVME_REG_CMBSZ);
+ 	if (!(NVME_CMB_SZ(dev->cmbsz)))
+ 		return NULL;
+ 
+ 	cmbloc = readl(dev->bar + NVME_REG_CMBLOC);
+ 
+ 	szu = (u64)1 << (12 + 4 * NVME_CMB_SZU(dev->cmbsz));
+ 	size = szu * NVME_CMB_SZ(dev->cmbsz);
+ 	offset = szu * NVME_CMB_OFST(cmbloc);
+ 	bar_size = pci_resource_len(pdev, NVME_CMB_BIR(cmbloc));
+ 
+ 	if (offset > bar_size)
+ 		return NULL;
+ 
+ 	/*
+ 	 * Controllers may support a CMB size larger than their BAR,
+ 	 * for example, due to being behind a bridge. Reduce the CMB to
+ 	 * the reported size of the BAR
+ 	 */
+ 	if (size > bar_size - offset)
+ 		size = bar_size - offset;
+ 
+ 	dma_addr = pci_resource_start(pdev, NVME_CMB_BIR(cmbloc)) + offset;
+ 	cmb = ioremap_wc(dma_addr, size);
+ 	if (!cmb)
+ 		return NULL;
+ 
+ 	dev->cmb_dma_addr = dma_addr;
+ 	dev->cmb_size = size;
+ 	return cmb;
+ }
+ 
+ static inline void nvme_release_cmb(struct nvme_dev *dev)
+ {
+ 	if (dev->cmb) {
+ 		iounmap(dev->cmb);
+ 		dev->cmb = NULL;
+ 	}
+ }
+ 
++>>>>>>> 7a67cbea653e (nvme: use offset instead of a struct for registers):drivers/nvme/host/pci.c
  static size_t db_bar_size(struct nvme_dev *dev, unsigned nr_io_queues)
  {
  	return 4096 + ((nr_io_queues + 1) * 8 * dev->db_stride);
@@@ -2411,22 -2477,14 +2486,26 @@@ static void nvme_dev_scan(struct work_s
   */
  static int nvme_dev_add(struct nvme_dev *dev)
  {
 -	struct pci_dev *pdev = to_pci_dev(dev->dev);
 +	struct pci_dev *pdev = dev->pci_dev;
  	int res;
 +	unsigned nn;
  	struct nvme_id_ctrl *ctrl;
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +	void *mem;
 +	dma_addr_t dma_addr;
 +	int shift = NVME_CAP_MPSMIN(readq(&dev->bar->cap)) + 12;
++=======
+ 	int shift = NVME_CAP_MPSMIN(lo_hi_readq(dev->bar + NVME_REG_CAP)) + 12;
++>>>>>>> 7a67cbea653e (nvme: use offset instead of a struct for registers):drivers/nvme/host/pci.c
 +
 +	mem = dma_alloc_coherent(&pdev->dev, 4096, &dma_addr, GFP_KERNEL);
 +	if (!mem)
 +		return -ENOMEM;
  
 -	res = nvme_identify_ctrl(dev, &ctrl);
 +	res = nvme_identify(dev, 0, 1, dma_addr);
  	if (res) {
 -		dev_err(dev->dev, "Identify Controller failed (%d)\n", res);
 +		dev_err(&pdev->dev, "Identify Controller failed (%d)\n", res);
 +		dma_free_coherent(&dev->pci_dev->dev, 4096, mem, dma_addr);
  		return -EIO;
  	}
  
@@@ -2515,10 -2571,13 +2594,20 @@@ static int nvme_dev_map(struct nvme_de
  			goto unmap;
  	}
  
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +	cap = readq(&dev->bar->cap);
 +	dev->q_depth = min_t(int, NVME_CAP_MQES(cap) + 1, NVME_Q_DEPTH);
 +	dev->db_stride = 1 << NVME_CAP_STRIDE(cap);
 +	dev->dbs = ((void __iomem *)dev->bar) + 4096;
++=======
+ 	cap = lo_hi_readq(dev->bar + NVME_REG_CAP);
+ 
+ 	dev->q_depth = min_t(int, NVME_CAP_MQES(cap) + 1, NVME_Q_DEPTH);
+ 	dev->db_stride = 1 << NVME_CAP_STRIDE(cap);
+ 	dev->dbs = dev->bar + 4096;
+ 	if (readl(dev->bar + NVME_REG_VS) >= NVME_VS(1, 2))
+ 		dev->cmb = nvme_map_cmb(dev);
++>>>>>>> 7a67cbea653e (nvme: use offset instead of a struct for registers):drivers/nvme/host/pci.c
  
  	return 0;
  
@@@ -2574,7 -2635,8 +2663,12 @@@ static void nvme_wait_dq(struct nvme_de
  			 * queues than admin tags.
  			 */
  			set_current_state(TASK_RUNNING);
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +			nvme_disable_ctrl(dev, readq(&dev->bar->cap));
++=======
+ 			nvme_disable_ctrl(dev,
+ 				lo_hi_readq(dev->bar + NVME_REG_CAP));
++>>>>>>> 7a67cbea653e (nvme: use offset instead of a struct for registers):drivers/nvme/host/pci.c
  			nvme_clear_queue(dev->queues[0]);
  			flush_kthread_worker(dq->worker);
  			nvme_disable_queue(dev, 0);
diff --cc drivers/block/nvme-scsi.c
index daa0d50b3bfd,85869946d226..000000000000
--- a/drivers/block/nvme-scsi.c
+++ b/drivers/block/nvme-scsi.c
@@@ -623,26 -609,21 +623,39 @@@ static int nvme_trans_device_id_page(st
  	int xfer_len;
  	__be32 tmp_id = cpu_to_be32(ns->ns_id);
  
 +	mem = dma_alloc_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns),
 +					&dma_addr, GFP_KERNEL);
 +	if (mem == NULL) {
 +		res = -ENOMEM;
 +		goto out_dma;
 +	}
 +
  	memset(inq_response, 0, alloc_len);
  	inq_response[1] = INQ_DEVICE_IDENTIFICATION_PAGE;    /* Page Code */
++<<<<<<< HEAD:drivers/block/nvme-scsi.c
 +	if (readl(&dev->bar->vs) >= NVME_VS(1, 1)) {
 +		struct nvme_id_ns *id_ns = mem;
 +		void *eui = id_ns->eui64;
 +		int len = sizeof(id_ns->eui64);
++=======
+ 	if (readl(dev->bar + NVME_REG_VS) >= NVME_VS(1, 1)) {
+ 		struct nvme_id_ns *id_ns;
+ 		void *eui;
+ 		int len;
++>>>>>>> 7a67cbea653e (nvme: use offset instead of a struct for registers):drivers/nvme/host/scsi.c
  
 -		nvme_sc = nvme_identify_ns(dev, ns->ns_id, &id_ns);
 +		nvme_sc = nvme_identify(dev, ns->ns_id, 0, dma_addr);
  		res = nvme_trans_status_code(hdr, nvme_sc);
  		if (res)
 -			return res;
 +			goto out_free;
  
++<<<<<<< HEAD:drivers/block/nvme-scsi.c
 +		if (readl(&dev->bar->vs) >= NVME_VS(1, 2)) {
++=======
+ 		eui = id_ns->eui64;
+ 		len = sizeof(id_ns->eui64);
+ 		if (readl(dev->bar + NVME_REG_VS) >= NVME_VS(1, 2)) {
++>>>>>>> 7a67cbea653e (nvme: use offset instead of a struct for registers):drivers/nvme/host/scsi.c
  			if (bitmap_empty(eui, len * 8)) {
  				eui = id_ns->nguid;
  				len = sizeof(id_ns->nguid);
diff --cc include/linux/nvme.h
index 026d52b232ed,a55986f6fe38..000000000000
--- a/include/linux/nvme.h
+++ b/include/linux/nvme.h
@@@ -15,23 -15,21 +15,39 @@@
  #ifndef _LINUX_NVME_H
  #define _LINUX_NVME_H
  
 -#include <linux/types.h>
 -
 +#include <uapi/linux/nvme.h>
 +#include <linux/pci.h>
 +#include <linux/kref.h>
 +#include <linux/blk-mq.h>
 +
++<<<<<<< HEAD
 +struct nvme_bar {
 +	__u64			cap;	/* Controller Capabilities */
 +	__u32			vs;	/* Version */
 +	__u32			intms;	/* Interrupt Mask Set */
 +	__u32			intmc;	/* Interrupt Mask Clear */
 +	__u32			cc;	/* Controller Configuration */
 +	__u32			rsvd1;	/* Reserved */
 +	__u32			csts;	/* Controller Status */
 +	__u32			nssr;	/* Subsystem Reset */
 +	__u32			aqa;	/* Admin Queue Attributes */
 +	__u64			asq;	/* Admin SQ Base Address */
 +	__u64			acq;	/* Admin CQ Base Address */
++=======
+ enum {
+ 	NVME_REG_CAP	= 0x0000,	/* Controller Capabilities */
+ 	NVME_REG_VS	= 0x0008,	/* Version */
+ 	NVME_REG_INTMS	= 0x000c,	/* Interrupt Mask Set */
+ 	NVME_REG_INTMC	= 0x0010,	/* Interrupt Mask Set */
+ 	NVME_REG_CC	= 0x0014,	/* Controller Configuration */
+ 	NVME_REG_CSTS	= 0x001c,	/* Controller Status */
+ 	NVME_REG_NSSR	= 0x0020,	/* NVM Subsystem Reset */
+ 	NVME_REG_AQA	= 0x0024,	/* Admin Queue Attributes */
+ 	NVME_REG_ASQ	= 0x0028,	/* Admin SQ Base Address */
+ 	NVME_REG_ACQ	= 0x0030,	/* Admin SQ Base Address */
+ 	NVME_REG_CMBLOC = 0x0038,	/* Controller Memory Buffer Location */
+ 	NVME_REG_CMBSZ	= 0x003c,	/* Controller Memory Buffer Size */
++>>>>>>> 7a67cbea653e (nvme: use offset instead of a struct for registers)
  };
  
  #define NVME_CAP_MQES(cap)	((cap) & 0xffff)
* Unmerged path drivers/nvme/host/nvme.h
* Unmerged path drivers/block/nvme-core.c
* Unmerged path drivers/block/nvme-scsi.c
* Unmerged path drivers/nvme/host/nvme.h
* Unmerged path include/linux/nvme.h
