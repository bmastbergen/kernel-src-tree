if_link: Add control trust VF

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Hiroshi Shimamoto <h-shimamoto@ct.jp.nec.com>
commit dd461d6aa894761fe67c30ddf81eec0d08be216b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/dd461d6a.failed

Add netlink directives and ndo entry to trust VF user.

This controls the special permission of VF user.
The administrator will dedicatedly trust VF user to use some features
which impacts security and/or performance.

The administrator never turn it on unless VF user is fully trusted.

CC: Sy Jong Choi <sy.jong.choi@intel.com>
	Signed-off-by: Hiroshi Shimamoto <h-shimamoto@ct.jp.nec.com>
	Acked-by: Greg Rose <gregory.v.rose@intel.com>
	Tested-by: Krishneil Singh <Krishneil.k.singh@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit dd461d6aa894761fe67c30ddf81eec0d08be216b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/if_link.h
#	net/core/rtnetlink.c
diff --cc include/linux/if_link.h
index ccc131edad5e,f923d15b432c..000000000000
--- a/include/linux/if_link.h
+++ b/include/linux/if_link.h
@@@ -19,10 -19,11 +19,17 @@@ struct ifla_vf_info 
  	__u8 mac[32];
  	__u32 vlan;
  	__u32 qos;
 +	RH_KABI_REPLACE(__u32 tx_rate, __u32 max_tx_rate)
  	__u32 spoofchk;
  	__u32 linkstate;
++<<<<<<< HEAD
 +	RH_KABI_EXTEND(__u32 min_tx_rate)
 +	RH_KABI_EXTEND(__u32 rss_query_en)
++=======
+ 	__u32 min_tx_rate;
+ 	__u32 max_tx_rate;
+ 	__u32 rss_query_en;
+ 	__u32 trusted;
++>>>>>>> dd461d6aa894 (if_link: Add control trust VF)
  };
  #endif /* _LINUX_IF_LINK_H */
diff --cc net/core/rtnetlink.c
index bca0c57300c0,504bd17b7456..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -1459,101 -1503,108 +1467,191 @@@ static int validate_linkmsg(struct net_
  	return 0;
  }
  
 -static int do_setvfinfo(struct net_device *dev, struct nlattr **tb)
 +static int do_setvfinfo(struct net_device *dev, struct nlattr *attr)
  {
 +	int rem, err = -EINVAL;
 +	struct nlattr *vf;
  	const struct net_device_ops *ops = dev->netdev_ops;
 -	int err = -EINVAL;
  
 -	if (tb[IFLA_VF_MAC]) {
 -		struct ifla_vf_mac *ivm = nla_data(tb[IFLA_VF_MAC]);
 +	nla_for_each_nested(vf, attr, rem) {
 +		switch (nla_type(vf)) {
 +		case IFLA_VF_MAC: {
 +			struct ifla_vf_mac *ivm;
 +			ivm = nla_data(vf);
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_mac)
 +				err = ops->ndo_set_vf_mac(dev, ivm->vf,
 +							  ivm->mac);
 +			break;
 +		}
 +		case IFLA_VF_VLAN: {
 +			struct ifla_vf_vlan *ivv;
 +			ivv = nla_data(vf);
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_vlan)
 +				err = ops->ndo_set_vf_vlan(dev, ivv->vf,
 +							   ivv->vlan,
 +							   ivv->qos);
 +			break;
 +		}
 +		case IFLA_VF_TX_RATE: {
 +			struct ifla_vf_tx_rate *ivt;
 +			struct ifla_vf_info ivf;
 +			ivt = nla_data(vf);
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_tx_rate) {
 +				err = ops->ndo_set_vf_tx_rate(dev, ivt->vf,
 +							      ivt->rate);
 +				break;
 +			}
 +			if (ops->ndo_get_vf_config)
 +				err = ops->ndo_get_vf_config(dev, ivt->vf,
 +							     &ivf);
 +			if (err)
 +				break;
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_rate)
 +				err = ops->ndo_set_vf_rate(dev, ivt->vf,
 +							   ivf.min_tx_rate,
 +							   ivt->rate);
 +			break;
 +		}
 +		case IFLA_VF_RATE: {
 +			struct ifla_vf_rate *ivt;
 +			ivt = nla_data(vf);
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_rate)
 +				err = ops->ndo_set_vf_rate(dev, ivt->vf,
 +							   ivt->min_tx_rate,
 +							   ivt->max_tx_rate);
 +			break;
 +		}
 +		case IFLA_VF_SPOOFCHK: {
 +			struct ifla_vf_spoofchk *ivs;
 +			ivs = nla_data(vf);
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_spoofchk)
 +				err = ops->ndo_set_vf_spoofchk(dev, ivs->vf,
 +							       ivs->setting);
 +			break;
 +		}
 +		case IFLA_VF_LINK_STATE: {
 +			struct ifla_vf_link_state *ivl;
 +			ivl = nla_data(vf);
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_link_state)
 +				err = ops->ndo_set_vf_link_state(dev, ivl->vf,
 +								 ivl->link_state);
 +			break;
 +		}
 +		case IFLA_VF_RSS_QUERY_EN: {
 +			struct ifla_vf_rss_query_en *ivrssq_en;
  
 -		err = -EOPNOTSUPP;
 -		if (ops->ndo_set_vf_mac)
 -			err = ops->ndo_set_vf_mac(dev, ivm->vf,
 -						  ivm->mac);
 -		if (err < 0)
 -			return err;
 +			ivrssq_en = nla_data(vf);
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_rss_query_en)
 +				err = ops->ndo_set_vf_rss_query_en(dev,
 +							    ivrssq_en->vf,
 +							    ivrssq_en->setting);
 +			break;
 +		}
 +		default:
 +			err = -EINVAL;
 +			break;
 +		}
 +		if (err)
 +			break;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (tb[IFLA_VF_VLAN]) {
+ 		struct ifla_vf_vlan *ivv = nla_data(tb[IFLA_VF_VLAN]);
+ 
+ 		err = -EOPNOTSUPP;
+ 		if (ops->ndo_set_vf_vlan)
+ 			err = ops->ndo_set_vf_vlan(dev, ivv->vf, ivv->vlan,
+ 						   ivv->qos);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (tb[IFLA_VF_TX_RATE]) {
+ 		struct ifla_vf_tx_rate *ivt = nla_data(tb[IFLA_VF_TX_RATE]);
+ 		struct ifla_vf_info ivf;
+ 
+ 		err = -EOPNOTSUPP;
+ 		if (ops->ndo_get_vf_config)
+ 			err = ops->ndo_get_vf_config(dev, ivt->vf, &ivf);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = -EOPNOTSUPP;
+ 		if (ops->ndo_set_vf_rate)
+ 			err = ops->ndo_set_vf_rate(dev, ivt->vf,
+ 						   ivf.min_tx_rate,
+ 						   ivt->rate);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (tb[IFLA_VF_RATE]) {
+ 		struct ifla_vf_rate *ivt = nla_data(tb[IFLA_VF_RATE]);
+ 
+ 		err = -EOPNOTSUPP;
+ 		if (ops->ndo_set_vf_rate)
+ 			err = ops->ndo_set_vf_rate(dev, ivt->vf,
+ 						   ivt->min_tx_rate,
+ 						   ivt->max_tx_rate);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (tb[IFLA_VF_SPOOFCHK]) {
+ 		struct ifla_vf_spoofchk *ivs = nla_data(tb[IFLA_VF_SPOOFCHK]);
+ 
+ 		err = -EOPNOTSUPP;
+ 		if (ops->ndo_set_vf_spoofchk)
+ 			err = ops->ndo_set_vf_spoofchk(dev, ivs->vf,
+ 						       ivs->setting);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (tb[IFLA_VF_LINK_STATE]) {
+ 		struct ifla_vf_link_state *ivl = nla_data(tb[IFLA_VF_LINK_STATE]);
+ 
+ 		err = -EOPNOTSUPP;
+ 		if (ops->ndo_set_vf_link_state)
+ 			err = ops->ndo_set_vf_link_state(dev, ivl->vf,
+ 							 ivl->link_state);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (tb[IFLA_VF_RSS_QUERY_EN]) {
+ 		struct ifla_vf_rss_query_en *ivrssq_en;
+ 
+ 		err = -EOPNOTSUPP;
+ 		ivrssq_en = nla_data(tb[IFLA_VF_RSS_QUERY_EN]);
+ 		if (ops->ndo_set_vf_rss_query_en)
+ 			err = ops->ndo_set_vf_rss_query_en(dev, ivrssq_en->vf,
+ 							   ivrssq_en->setting);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (tb[IFLA_VF_TRUST]) {
+ 		struct ifla_vf_trust *ivt = nla_data(tb[IFLA_VF_TRUST]);
+ 
+ 		err = -EOPNOTSUPP;
+ 		if (ops->ndo_set_vf_trust)
+ 			err = ops->ndo_set_vf_trust(dev, ivt->vf, ivt->setting);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
++>>>>>>> dd461d6aa894 (if_link: Add control trust VF)
  	return err;
  }
  
* Unmerged path include/linux/if_link.h
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index eb7e9fa3e472..725be6dcc830 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -863,6 +863,7 @@ struct netdev_phys_port_id {
  * int (*ndo_set_vf_vlan)(struct net_device *dev, int vf, u16 vlan, u8 qos);
  * int (*ndo_set_vf_tx_rate)(struct net_device *dev, int vf, int rate);
  * int (*ndo_set_vf_spoofchk)(struct net_device *dev, int vf, bool setting);
+ * int (*ndo_set_vf_trust)(struct net_device *dev, int vf, bool setting);
  * int (*ndo_get_vf_config)(struct net_device *dev,
  *			    int vf, struct ifla_vf_info *ivf);
  * int (*ndo_set_vf_link_state)(struct net_device *dev, int vf, int link_state);
@@ -1060,6 +1061,8 @@ struct net_device_ops {
 						      int vf, int rate);
 	int			(*ndo_set_vf_spoofchk)(struct net_device *dev,
 						       int vf, bool setting);
+	int			(*ndo_set_vf_trust)(struct net_device *dev,
+						    int vf, bool setting);
 	int			(*ndo_get_vf_config)(struct net_device *dev,
 						     int vf,
 						     struct ifla_vf_info *ivf);
diff --git a/include/uapi/linux/if_link.h b/include/uapi/linux/if_link.h
index ac2e08bad99b..5135f607373d 100644
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@ -431,6 +431,7 @@ enum {
 				 * on/off switch
 				 */
 	IFLA_VF_STATS,		/* network device statistics */
+	IFLA_VF_TRUST,		/* Trust VF */
 	__IFLA_VF_MAX,
 };
 
@@ -492,6 +493,11 @@ enum {
 
 #define IFLA_VF_STATS_MAX (__IFLA_VF_STATS_MAX - 1)
 
+struct ifla_vf_trust {
+	__u32 vf;
+	__u32 setting;
+};
+
 /* VF ports management section
  *
  *	Nested layout of set/get msg is:
* Unmerged path net/core/rtnetlink.c
