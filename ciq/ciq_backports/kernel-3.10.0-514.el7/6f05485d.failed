KVM: VMX: Fix guest debugging while in L2

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jan Kiszka <jan.kiszka@siemens.com>
commit 6f05485d3a161caebc0fc7a73d641fa42a0dd263
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6f05485d.failed

When we take a #DB or #BP vmexit while in guest mode, we first of all
need to check if there is ongoing guest debugging that might be
interested in the event. Currently, we unconditionally leave L2 and
inject the event into L1 if it is intercepting the exceptions. That
breaks things marvelously.

	Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 6f05485d3a161caebc0fc7a73d641fa42a0dd263)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 0fa504f5d5d8,cb501d306416..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -7263,7 -7762,14 +7273,18 @@@ static bool nested_vmx_exit_handled(str
  			return enable_ept;
  		else if (is_no_device(intr_info) &&
  			 !(vmcs12->guest_cr0 & X86_CR0_TS))
++<<<<<<< HEAD
 +			return 0;
++=======
+ 			return false;
+ 		else if (is_debug(intr_info) &&
+ 			 vcpu->guest_debug &
+ 			 (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))
+ 			return false;
+ 		else if (is_breakpoint(intr_info) &&
+ 			 vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)
+ 			return false;
++>>>>>>> 6f05485d3a16 (KVM: VMX: Fix guest debugging while in L2)
  		return vmcs12->exception_bitmap &
  				(1u << (intr_info & INTR_INFO_VECTOR_MASK));
  	case EXIT_REASON_EXTERNAL_INTERRUPT:
* Unmerged path arch/x86/kvm/vmx.c
