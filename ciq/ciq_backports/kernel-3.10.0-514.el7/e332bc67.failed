ipv6: Don't call with rt6_uncached_list_flush_dev

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit e332bc67cf5e5e5b71a1aec9750d0791aac65183
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e332bc67.failed

As originally written rt6_uncached_list_flush_dev makes no sense when
called with dev == NULL as it attempts to flush all uncached routes
regardless of network namespace when dev == NULL.  Which is simply
incorrect behavior.

Furthermore at the point rt6_ifdown is called with dev == NULL no more
network devices exist in the network namespace so even if the code in
rt6_uncached_list_flush_dev were to attempt something sensible it
would be meaningless.

Therefore remove support in rt6_uncached_list_flush_dev for handling
network devices where dev == NULL, and only call rt6_uncached_list_flush_dev
 when rt6_ifdown is called with a network device.

Fixes: 8d0b94afdca8 ("ipv6: Keep track of DST_NOCACHE routes in case of iface down/unregister")
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
	Reviewed-by: Martin KaFai Lau <kafai@fb.com>
	Tested-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e332bc67cf5e5e5b71a1aec9750d0791aac65183)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/route.c
diff --cc net/ipv6/route.c
index e3cf3592b9d2,ed04e29a6aa3..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -104,35 -107,83 +104,105 @@@ static struct rt6_info *rt6_get_route_i
  					   const struct in6_addr *gwaddr, int ifindex);
  #endif
  
++<<<<<<< HEAD
++=======
+ struct uncached_list {
+ 	spinlock_t		lock;
+ 	struct list_head	head;
+ };
+ 
+ static DEFINE_PER_CPU_ALIGNED(struct uncached_list, rt6_uncached_list);
+ 
+ static void rt6_uncached_list_add(struct rt6_info *rt)
+ {
+ 	struct uncached_list *ul = raw_cpu_ptr(&rt6_uncached_list);
+ 
+ 	rt->dst.flags |= DST_NOCACHE;
+ 	rt->rt6i_uncached_list = ul;
+ 
+ 	spin_lock_bh(&ul->lock);
+ 	list_add_tail(&rt->rt6i_uncached, &ul->head);
+ 	spin_unlock_bh(&ul->lock);
+ }
+ 
+ static void rt6_uncached_list_del(struct rt6_info *rt)
+ {
+ 	if (!list_empty(&rt->rt6i_uncached)) {
+ 		struct uncached_list *ul = rt->rt6i_uncached_list;
+ 
+ 		spin_lock_bh(&ul->lock);
+ 		list_del(&rt->rt6i_uncached);
+ 		spin_unlock_bh(&ul->lock);
+ 	}
+ }
+ 
+ static void rt6_uncached_list_flush_dev(struct net *net, struct net_device *dev)
+ {
+ 	struct net_device *loopback_dev = net->loopback_dev;
+ 	int cpu;
+ 
+ 	if (dev == loopback_dev)
+ 		return;
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		struct uncached_list *ul = per_cpu_ptr(&rt6_uncached_list, cpu);
+ 		struct rt6_info *rt;
+ 
+ 		spin_lock_bh(&ul->lock);
+ 		list_for_each_entry(rt, &ul->head, rt6i_uncached) {
+ 			struct inet6_dev *rt_idev = rt->rt6i_idev;
+ 			struct net_device *rt_dev = rt->dst.dev;
+ 
+ 			if (rt_idev->dev == dev) {
+ 				rt->rt6i_idev = in6_dev_get(loopback_dev);
+ 				in6_dev_put(rt_idev);
+ 			}
+ 
+ 			if (rt_dev == dev) {
+ 				rt->dst.dev = loopback_dev;
+ 				dev_hold(rt->dst.dev);
+ 				dev_put(rt_dev);
+ 			}
+ 		}
+ 		spin_unlock_bh(&ul->lock);
+ 	}
+ }
+ 
+ static u32 *rt6_pcpu_cow_metrics(struct rt6_info *rt)
+ {
+ 	return dst_metrics_write_ptr(rt->dst.from);
+ }
+ 
++>>>>>>> e332bc67cf5e (ipv6: Don't call with rt6_uncached_list_flush_dev)
  static u32 *ipv6_cow_metrics(struct dst_entry *dst, unsigned long old)
  {
 -	struct rt6_info *rt = (struct rt6_info *)dst;
 +	struct rt6_info *rt = (struct rt6_info *) dst;
 +	struct inet_peer *peer;
 +	u32 *p = NULL;
  
 -	if (rt->rt6i_flags & RTF_PCPU)
 -		return rt6_pcpu_cow_metrics(rt);
 -	else if (rt->rt6i_flags & RTF_CACHE)
 -		return NULL;
 -	else
 +	if (!(rt->dst.flags & DST_HOST))
  		return dst_cow_metrics_generic(dst, old);
 +
 +	peer = rt6_get_peer_create(rt);
 +	if (peer) {
 +		u32 *old_p = __DST_METRICS_PTR(old);
 +		unsigned long prev, new;
 +
 +		p = peer->metrics;
 +		if (inet_metrics_new(peer) ||
 +		    (old & DST_METRICS_FORCE_OVERWRITE))
 +			memcpy(p, old_p, sizeof(u32) * RTAX_MAX);
 +
 +		new = (unsigned long) p;
 +		prev = cmpxchg(&dst->_metrics, old, new);
 +
 +		if (prev != old) {
 +			p = __DST_METRICS_PTR(prev);
 +			if (prev & DST_METRICS_READ_ONLY)
 +				p = NULL;
 +		}
 +	}
 +	return p;
  }
  
  static inline const void *choose_neigh_daddr(struct rt6_info *rt,
@@@ -2353,6 -2623,8 +2423,11 @@@ void rt6_ifdown(struct net *net, struc
  
  	fib6_clean_all(net, fib6_ifdown, &adn);
  	icmp6_clean_all(fib6_ifdown, &adn);
++<<<<<<< HEAD
++=======
+ 	if (dev)
+ 		rt6_uncached_list_flush_dev(net, dev);
++>>>>>>> e332bc67cf5e (ipv6: Don't call with rt6_uncached_list_flush_dev)
  }
  
  struct rt6_mtu_change_arg {
* Unmerged path net/ipv6/route.c
