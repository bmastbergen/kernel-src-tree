[SCSI] qla2xxx: Refactor shutdown code so some functionality can be reused.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Refactor shutdown code so some functionality can be reused (Chad Dupuis) [1273080]
Rebuild_FUZZ: 94.37%
commit-author Chad Dupuis <chad.dupuis@qlogic.com>
commit fe1b806f4f7172b1eae18ddeebb7d8fb351043f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fe1b806f.failed

	Signed-off-by: Chad Dupuis <chad.dupuis@qlogic.com>
	Signed-off-by: Saurav Kashyap <saurav.kashyap@qlogic.com>
	Signed-off-by: James Bottomley <JBottomley@Parallels.com>
(cherry picked from commit fe1b806f4f7172b1eae18ddeebb7d8fb351043f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_os.c
index d474e1847a2b,c9e4372698a2..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -3040,36 -2946,16 +3024,40 @@@ qla2x00_shutdown(struct pci_dev *pdev
  	qla2x00_free_irqs(vha);
  
  	qla2x00_free_fw_dump(ha);
 +
 +	pci_disable_pcie_error_reporting(pdev);
 +	pci_disable_device(pdev);
  }
  
+ /* Deletes all the virtual ports for a given ha */
  static void
- qla2x00_remove_one(struct pci_dev *pdev)
+ qla2x00_delete_all_vps(struct qla_hw_data *ha, scsi_qla_host_t *base_vha)
  {
- 	scsi_qla_host_t *base_vha, *vha;
- 	struct qla_hw_data  *ha;
+ 	struct Scsi_Host *scsi_host;
+ 	scsi_qla_host_t *vha;
  	unsigned long flags;
  
++<<<<<<< HEAD
 +	/*
 +	 * If the PCI device is disabled that means that probe failed and any
 +	 * resources should be have cleaned up on probe exit.
 +	 */
 +	if (!atomic_read(&pdev->enable_cnt))
 +		return;
 +
 +	base_vha = pci_get_drvdata(pdev);
 +	ha = base_vha->hw;
 +
 +	qla2x00_wait_for_hba_ready(base_vha);
 +
 +	ha->flags.host_shutting_down = 1;
 +
 +	set_bit(UNLOADING, &base_vha->dpc_flags);
 +	if (IS_QLAFX00(ha))
 +		qlafx00_driver_shutdown(base_vha, 20);
 +
++=======
++>>>>>>> fe1b806f4f71 ([SCSI] qla2xxx: Refactor shutdown code so some functionality can be reused.)
  	mutex_lock(&ha->vport_lock);
  	while (ha->cur_vport_count) {
  		spin_lock_irqsave(&ha->vport_slock, flags);
@@@ -3088,31 -2974,12 +3076,39 @@@
  		mutex_lock(&ha->vport_lock);
  	}
  	mutex_unlock(&ha->vport_lock);
+ }
  
++<<<<<<< HEAD
 +	if (IS_QLA8031(ha)) {
 +		ql_dbg(ql_dbg_p3p, base_vha, 0xb07e,
 +		    "Clearing fcoe driver presence.\n");
 +		if (qla83xx_clear_drv_presence(base_vha) != QLA_SUCCESS)
 +			ql_dbg(ql_dbg_p3p, base_vha, 0xb079,
 +			    "Error while clearing DRV-Presence.\n");
 +	}
 +
 +	qla2x00_abort_all_cmds(base_vha, DID_NO_CONNECT << 16);
 +
 +	qla2x00_dfs_remove(base_vha);
 +
 +	qla84xx_put_chip(base_vha);
 +
 +	/* Laser should be disabled only for ISP2031 */
 +	if (IS_QLA2031(ha))
 +		qla83xx_disable_laser(base_vha);
 +
 +	/* Disable timer */
 +	if (base_vha->timer_active)
 +		qla2x00_stop_timer(base_vha);
 +
 +	base_vha->flags.online = 0;
 +
++=======
+ /* Stops all deferred work threads */
+ static void
+ qla2x00_destroy_deferred_work(struct qla_hw_data *ha)
+ {
++>>>>>>> fe1b806f4f71 ([SCSI] qla2xxx: Refactor shutdown code so some functionality can be reused.)
  	/* Flush the work queue and remove it */
  	if (ha->wq) {
  		flush_workqueue(ha->wq);
@@@ -3146,29 -3013,16 +3142,32 @@@
  		ha->dpc_thread = NULL;
  		kthread_stop(t);
  	}
- 	qlt_remove_target(ha, base_vha);
+ }
  
++<<<<<<< HEAD
 +	qla2x00_free_sysfs_attr(base_vha);
 +
 +	fc_remove_host(base_vha->host);
 +
 +	scsi_remove_host(base_vha->host);
 +
 +	qla2x00_free_device(base_vha);
 +
 +	if (IS_QLA8044(ha)) {
 +		qla8044_idc_lock(ha);
 +		qla8044_clear_drv_active(ha);
 +		qla8044_idc_unlock(ha);
 +	}
++=======
+ static void
+ qla2x00_unmap_iobases(struct qla_hw_data *ha)
+ {
++>>>>>>> fe1b806f4f71 ([SCSI] qla2xxx: Refactor shutdown code so some functionality can be reused.)
  	if (IS_QLA82XX(ha)) {
- 		qla82xx_idc_lock(ha);
- 		qla82xx_clear_drv_active(ha);
- 		qla82xx_idc_unlock(ha);
  
 -		iounmap((device_reg_t __iomem *)ha->nx_pcibase);
 +		iounmap((device_reg_t *)ha->nx_pcibase);
  		if (!ql2xdbwr)
 -			iounmap((device_reg_t __iomem *)ha->nxdb_wr_ptr);
 +			iounmap((device_reg_t *)ha->nxdb_wr_ptr);
  	} else {
  		if (ha->iobase)
  			iounmap(ha->iobase);
@@@ -3179,11 -3033,88 +3178,89 @@@
  		if (ha->mqiobase)
  			iounmap(ha->mqiobase);
  
 -		if (IS_QLA83XX(ha) && ha->msixbase)
 +		if ((IS_QLA83XX(ha) || IS_QLA27XX(ha)) && ha->msixbase)
  			iounmap(ha->msixbase);
  	}
+ }
+ 
+ static void
+ qla2x00_clear_drv_active(scsi_qla_host_t *vha)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	if (IS_QLA8044(ha)) {
+ 		qla8044_idc_lock(ha);
+ 		qla8044_clear_drv_active(vha);
+ 		qla8044_idc_unlock(ha);
+ 	} else if (IS_QLA82XX(ha)) {
+ 		qla82xx_idc_lock(ha);
+ 		qla82xx_clear_drv_active(ha);
+ 		qla82xx_idc_unlock(ha);
+ 	}
+ }
+ 
+ static void
+ qla2x00_remove_one(struct pci_dev *pdev)
+ {
+ 	scsi_qla_host_t *base_vha;
+ 	struct qla_hw_data  *ha;
+ 
+ 	/*
+ 	 * If the PCI device is disabled that means that probe failed and any
+ 	 * resources should be have cleaned up on probe exit.
+ 	 */
+ 	if (!atomic_read(&pdev->enable_cnt))
+ 		return;
+ 
+ 	base_vha = pci_get_drvdata(pdev);
+ 	ha = base_vha->hw;
+ 
+ 	set_bit(UNLOADING, &base_vha->dpc_flags);
+ 
+ 	if (IS_QLAFX00(ha))
+ 		qlafx00_driver_shutdown(base_vha, 20);
+ 
+ 	qla2x00_delete_all_vps(ha, base_vha);
+ 
+ 	if (IS_QLA8031(ha)) {
+ 		ql_dbg(ql_dbg_p3p, base_vha, 0xb07e,
+ 		    "Clearing fcoe driver presence.\n");
+ 		if (qla83xx_clear_drv_presence(base_vha) != QLA_SUCCESS)
+ 			ql_dbg(ql_dbg_p3p, base_vha, 0xb079,
+ 			    "Error while clearing DRV-Presence.\n");
+ 	}
+ 
+ 	qla2x00_abort_all_cmds(base_vha, DID_NO_CONNECT << 16);
+ 
+ 	qla2x00_dfs_remove(base_vha);
+ 
+ 	qla84xx_put_chip(base_vha);
+ 
+ 	/* Disable timer */
+ 	if (base_vha->timer_active)
+ 		qla2x00_stop_timer(base_vha);
+ 
+ 	base_vha->flags.online = 0;
+ 
+ 	qla2x00_destroy_deferred_work(ha);
+ 
+ 	qlt_remove_target(ha, base_vha);
+ 
+ 	qla2x00_free_sysfs_attr(base_vha, true);
+ 
+ 	fc_remove_host(base_vha->host);
+ 
+ 	scsi_remove_host(base_vha->host);
+ 
+ 	qla2x00_free_device(base_vha);
+ 
+ 	scsi_host_put(base_vha->host);
+ 
+ 	qla2x00_clear_drv_active(base_vha);
+ 
+ 	qla2x00_unmap_iobases(ha);
  
 +	scsi_host_put(base_vha->host);
  	pci_release_selected_regions(ha->pdev, ha->bars);
  	kfree(ha);
  	ha = NULL;
diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c
index deca736e73d9..bc309f8a58fc 100644
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@ -975,7 +975,7 @@ qla2x00_alloc_sysfs_attr(scsi_qla_host_t *vha)
 }
 
 void
-qla2x00_free_sysfs_attr(scsi_qla_host_t *vha)
+qla2x00_free_sysfs_attr(scsi_qla_host_t *vha, bool stop_beacon)
 {
 	struct Scsi_Host *host = vha->host;
 	struct sysfs_entry *iter;
@@ -995,7 +995,7 @@ qla2x00_free_sysfs_attr(scsi_qla_host_t *vha)
 		    iter->attr);
 	}
 
-	if (ha->beacon_blink_led == 1)
+	if (stop_beacon && ha->beacon_blink_led == 1)
 		ha->isp_ops->beacon_off(vha);
 }
 
diff --git a/drivers/scsi/qla2xxx/qla_gbl.h b/drivers/scsi/qla2xxx/qla_gbl.h
index 4a34762f8a9c..4d2bcf817139 100644
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@ -561,10 +561,9 @@ struct fc_function_template;
 extern struct fc_function_template qla2xxx_transport_functions;
 extern struct fc_function_template qla2xxx_transport_vport_functions;
 extern void qla2x00_alloc_sysfs_attr(scsi_qla_host_t *);
-extern void qla2x00_free_sysfs_attr(scsi_qla_host_t *);
+extern void qla2x00_free_sysfs_attr(scsi_qla_host_t *, bool);
 extern void qla2x00_init_host_attr(scsi_qla_host_t *);
 extern void qla2x00_alloc_sysfs_attr(scsi_qla_host_t *);
-extern void qla2x00_free_sysfs_attr(scsi_qla_host_t *);
 extern int qla2x00_loopback_test(scsi_qla_host_t *, struct msg_echo_lb *, uint16_t *);
 extern int qla2x00_echo_test(scsi_qla_host_t *,
 	struct msg_echo_lb *, uint16_t *);
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
