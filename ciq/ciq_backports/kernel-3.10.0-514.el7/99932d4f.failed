netdevice: add queue selection fallback handler for ndo_select_queue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Daniel Borkmann <dborkman@redhat.com>
commit 99932d4fc03a13bb3e94938fe25458fabc8f2fc3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/99932d4f.failed

Add a new argument for ndo_select_queue() callback that passes a
fallback handler. This gets invoked through netdev_pick_tx();
fallback handler is currently __netdev_pick_tx() as most drivers
invoke this function within their customized implementation in
case for skbs that don't need any special handling. This fallback
handler can then be replaced on other call-sites with different
queue selection methods (e.g. in packet sockets, pktgen etc).

This also has the nice side-effect that __netdev_pick_tx() is
then only invoked from netdev_pick_tx() and export of that
function to modules can be undone.

	Suggested-by: David S. Miller <davem@davemloft.net>
	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 99932d4fc03a13bb3e94938fe25458fabc8f2fc3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
#	drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
#	drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
#	drivers/net/ethernet/lantiq_etop.c
#	drivers/net/ethernet/mellanox/mlx4/en_tx.c
#	drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
#	drivers/net/ethernet/tile/tilegx.c
#	drivers/net/team/team.c
#	drivers/net/tun.c
#	drivers/net/wireless/mwifiex/main.c
#	drivers/staging/bcm/Bcmnet.c
#	drivers/staging/netlogic/xlr_net.c
#	drivers/staging/rtl8188eu/os_dep/os_intfs.c
#	include/linux/netdevice.h
#	net/core/flow_dissector.c
#	net/mac80211/iface.c
diff --cc drivers/net/bonding/bond_main.c
index dd9219794eca,1c6104d3501d..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -3898,9 -3706,11 +3898,14 @@@ static inline int bond_slave_override(s
  }
  
  
++<<<<<<< HEAD
 +static u16 bond_select_queue(struct net_device *dev, struct sk_buff *skb)
++=======
+ static u16 bond_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 			     void *accel_priv, select_queue_fallback_t fallback)
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  {
 -	/*
 -	 * This helper function exists to help dev_pick_tx get the correct
 +	/* This helper function exists to help dev_pick_tx get the correct
  	 * destination queue.  Using a helper function skips a call to
  	 * skb_tx_hash and will put the skbs in the queue we expect on their
  	 * way down to the bonding driver.
diff --cc drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
index d064e02443c2,66c0df78c3ff..000000000000
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
@@@ -1924,7 -1872,8 +1924,12 @@@ void bnx2x_netif_stop(struct bnx2x *bp
  		bnx2x_napi_disable_cnic(bp);
  }
  
++<<<<<<< HEAD
 +u16 bnx2x_select_queue(struct net_device *dev, struct sk_buff *skb)
++=======
+ u16 bnx2x_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 		       void *accel_priv, select_queue_fallback_t fallback)
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  {
  	struct bnx2x *bp = netdev_priv(dev);
  
diff --cc drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
index 265d0ec91d32,a89a40f88c25..000000000000
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
@@@ -491,7 -495,8 +491,12 @@@ int bnx2x_set_vf_mac(struct net_device 
  int bnx2x_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan, u8 qos);
  
  /* select_queue callback */
++<<<<<<< HEAD
 +u16 bnx2x_select_queue(struct net_device *dev, struct sk_buff *skb);
++=======
+ u16 bnx2x_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 		       void *accel_priv, select_queue_fallback_t fallback);
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  
  static inline void bnx2x_update_rx_prod(struct bnx2x *bp,
  					struct bnx2x_fastpath *fp,
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index e464f2e3e2eb,18076c4178b4..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -7033,9 -6854,37 +7033,42 @@@ static void ixgbe_atr(struct ixgbe_rin
  					      input, common, ring->queue_index);
  }
  
++<<<<<<< HEAD
++=======
+ static int __ixgbe_maybe_stop_tx(struct ixgbe_ring *tx_ring, u16 size)
+ {
+ 	netif_stop_subqueue(tx_ring->netdev, tx_ring->queue_index);
+ 	/* Herbert's original patch had:
+ 	 *  smp_mb__after_netif_stop_queue();
+ 	 * but since that doesn't exist yet, just open code it. */
+ 	smp_mb();
+ 
+ 	/* We need to check again in a case another CPU has just
+ 	 * made room available. */
+ 	if (likely(ixgbe_desc_unused(tx_ring) < size))
+ 		return -EBUSY;
+ 
+ 	/* A reprieve! - use start_queue because it doesn't call schedule */
+ 	netif_start_subqueue(tx_ring->netdev, tx_ring->queue_index);
+ 	++tx_ring->tx_stats.restart_queue;
+ 	return 0;
+ }
+ 
+ static inline int ixgbe_maybe_stop_tx(struct ixgbe_ring *tx_ring, u16 size)
+ {
+ 	if (likely(ixgbe_desc_unused(tx_ring) >= size))
+ 		return 0;
+ 	return __ixgbe_maybe_stop_tx(tx_ring, size);
+ }
+ 
+ static u16 ixgbe_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 			      void *accel_priv, select_queue_fallback_t fallback)
+ {
+ 	struct ixgbe_fwd_adapter *fwd_adapter = accel_priv;
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  #ifdef IXGBE_FCOE
 +static u16 ixgbe_select_queue(struct net_device *dev, struct sk_buff *skb)
 +{
  	struct ixgbe_adapter *adapter;
  	struct ixgbe_ring_feature *f;
  	int txq;
@@@ -7064,9 -6919,11 +7097,15 @@@
  		txq -= f->indices;
  
  	return txq + f->offset;
++<<<<<<< HEAD
++=======
+ #else
+ 	return fallback(dev, skb);
+ #endif
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  }
  
 +#endif
  netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *skb,
  			  struct ixgbe_adapter *adapter,
  			  struct ixgbe_ring *tx_ring)
diff --cc drivers/net/ethernet/lantiq_etop.c
index bfdb06860397,fd4b6aecf6ee..000000000000
--- a/drivers/net/ethernet/lantiq_etop.c
+++ b/drivers/net/ethernet/lantiq_etop.c
@@@ -621,7 -618,8 +621,12 @@@ ltq_etop_set_multicast_list(struct net_
  }
  
  static u16
++<<<<<<< HEAD
 +ltq_etop_select_queue(struct net_device *dev, struct sk_buff *skb)
++=======
+ ltq_etop_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 		      void *accel_priv, select_queue_fallback_t fallback)
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  {
  	/* we are currently only using the first queue */
  	return 0;
diff --cc drivers/net/ethernet/mellanox/mlx4/en_tx.c
index 49eb82ce6e53,13457032d15f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_tx.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_tx.c
@@@ -680,7 -628,8 +680,12 @@@ static void build_inline_wqe(struct mlx
  	}
  }
  
++<<<<<<< HEAD
 +u16 mlx4_en_select_queue(struct net_device *dev, struct sk_buff *skb)
++=======
+ u16 mlx4_en_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 			 void *accel_priv, select_queue_fallback_t fallback)
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  {
  	struct mlx4_en_priv *priv = netdev_priv(dev);
  	u16 rings_p_up = priv->num_tx_rings_p_up;
@@@ -689,14 -638,13 +694,14 @@@
  	if (dev->num_tc)
  		return skb_tx_hash(dev, skb);
  
 -	if (vlan_tx_tag_present(skb))
 -		up = vlan_tx_tag_get(skb) >> VLAN_PRIO_SHIFT;
 +	if (skb_vlan_tag_present(skb))
 +		up = skb_vlan_tag_get(skb) >> VLAN_PRIO_SHIFT;
  
- 	return __netdev_pick_tx(dev, skb) % rings_p_up + up * rings_p_up;
+ 	return fallback(dev, skb) % rings_p_up + up * rings_p_up;
  }
  
 -static void mlx4_bf_copy(void __iomem *dst, unsigned long *src, unsigned bytecnt)
 +static void mlx4_bf_copy(void __iomem *dst, const void *src,
 +			 unsigned int bytecnt)
  {
  	__iowrite64_copy(dst, src, bytecnt / 8);
  }
diff --cc drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
index aec9d953ef9e,9ca223bc90fc..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
@@@ -758,7 -722,8 +758,12 @@@ int mlx4_en_set_cq_moder(struct mlx4_en
  int mlx4_en_arm_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq);
  
  void mlx4_en_tx_irq(struct mlx4_cq *mcq);
++<<<<<<< HEAD
 +u16 mlx4_en_select_queue(struct net_device *dev, struct sk_buff *skb);
++=======
+ u16 mlx4_en_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 			 void *accel_priv, select_queue_fallback_t fallback);
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  netdev_tx_t mlx4_en_xmit(struct sk_buff *skb, struct net_device *dev);
  
  int mlx4_en_create_tx_ring(struct mlx4_en_priv *priv,
diff --cc drivers/net/ethernet/tile/tilegx.c
index f3c2d034b32c,17503da9f7a5..000000000000
--- a/drivers/net/ethernet/tile/tilegx.c
+++ b/drivers/net/ethernet/tile/tilegx.c
@@@ -1710,7 -2070,8 +1710,12 @@@ static int tile_net_tx(struct sk_buff *
  }
  
  /* Return subqueue id on this core (one per core). */
++<<<<<<< HEAD
 +static u16 tile_net_select_queue(struct net_device *dev, struct sk_buff *skb)
++=======
+ static u16 tile_net_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 				 void *accel_priv, select_queue_fallback_t fallback)
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  {
  	return smp_processor_id();
  }
diff --cc drivers/net/team/team.c
index 6ef5eb991fa3,c8624a8235ab..000000000000
--- a/drivers/net/team/team.c
+++ b/drivers/net/team/team.c
@@@ -1685,7 -1647,8 +1685,12 @@@ static netdev_tx_t team_xmit(struct sk_
  	return NETDEV_TX_OK;
  }
  
++<<<<<<< HEAD
 +static u16 team_select_queue(struct net_device *dev, struct sk_buff *skb)
++=======
+ static u16 team_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 			     void *accel_priv, select_queue_fallback_t fallback)
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  {
  	/*
  	 * This helper function exists to help dev_pick_tx get the correct
diff --cc drivers/net/tun.c
index 0b2c3191eea2,8fe9cb7d0f72..000000000000
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@@ -423,7 -365,8 +423,12 @@@ unlock
   * different rxq no. here. If we could not get rxhash, then we would
   * hope the rxq no. may help here.
   */
++<<<<<<< HEAD
 +static u16 tun_select_queue(struct net_device *dev, struct sk_buff *skb)
++=======
+ static u16 tun_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 			    void *accel_priv, select_queue_fallback_t fallback)
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  {
  	struct tun_struct *tun = netdev_priv(dev);
  	struct tun_flow_entry *e;
diff --cc drivers/net/wireless/mwifiex/main.c
index 823418877a35,9d3d2758ec35..000000000000
--- a/drivers/net/wireless/mwifiex/main.c
+++ b/drivers/net/wireless/mwifiex/main.c
@@@ -977,12 -747,8 +977,15 @@@ static struct net_device_stats *mwifiex
  }
  
  static u16
 +#if 0 /* Not in RHEL */
  mwifiex_netdev_select_wmm_queue(struct net_device *dev, struct sk_buff *skb,
  				void *accel_priv, select_queue_fallback_t fallback)
++<<<<<<< HEAD
 +#else
 +mwifiex_netdev_select_wmm_queue(struct net_device *dev, struct sk_buff *skb)
 +#endif
++=======
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  {
  	skb->priority = cfg80211_classify8021d(skb, NULL);
  	return mwifiex_1d_to_wmm_queue[skb->priority];
diff --cc drivers/staging/bcm/Bcmnet.c
index 4e470d4bb4e8,95a2358267ba..000000000000
--- a/drivers/staging/bcm/Bcmnet.c
+++ b/drivers/staging/bcm/Bcmnet.c
@@@ -39,7 -39,8 +39,12 @@@ static INT bcm_close(struct net_device 
  	return 0;
  }
  
++<<<<<<< HEAD
 +static u16 bcm_select_queue(struct net_device *dev, struct sk_buff *skb)
++=======
+ static u16 bcm_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 			    void *accel_priv, select_queue_fallback_t fallback)
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  {
  	return ClassifyPacket(netdev_priv(dev), skb);
  }
diff --cc drivers/staging/netlogic/xlr_net.c
index dd98cb1468a4,6f9ac27730af..000000000000
--- a/drivers/staging/netlogic/xlr_net.c
+++ b/drivers/staging/netlogic/xlr_net.c
@@@ -304,7 -306,8 +304,12 @@@ static netdev_tx_t xlr_net_start_xmit(s
  	return NETDEV_TX_OK;
  }
  
++<<<<<<< HEAD
 +static u16 xlr_net_select_queue(struct net_device *ndev, struct sk_buff *skb)
++=======
+ static u16 xlr_net_select_queue(struct net_device *ndev, struct sk_buff *skb,
+ 				void *accel_priv, select_queue_fallback_t fallback)
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  {
  	return (u16)smp_processor_id();
  }
diff --cc include/linux/netdevice.h
index 7b10147de03d,1de9c136b066..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -802,7 -785,8 +805,12 @@@ typedef u16 (*select_queue_fallback_t)(
   *        (can also return NETDEV_TX_LOCKED iff NETIF_F_LLTX)
   *	Required can not be NULL.
   *
++<<<<<<< HEAD
 + * u16 (*ndo_select_queue)(struct net_device *dev, struct sk_buff *skb);
++=======
+  * u16 (*ndo_select_queue)(struct net_device *dev, struct sk_buff *skb,
+  *                         void *accel_priv, select_queue_fallback_t fallback);
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
   *	Called to decide which queue to when device supports multiple
   *	transmit queues.
   *
@@@ -1025,7 -1007,9 +1033,13 @@@ struct net_device_ops 
  	netdev_tx_t		(*ndo_start_xmit) (struct sk_buff *skb,
  						   struct net_device *dev);
  	u16			(*ndo_select_queue)(struct net_device *dev,
++<<<<<<< HEAD
 +						    struct sk_buff *skb);
++=======
+ 						    struct sk_buff *skb,
+ 						    void *accel_priv,
+ 						    select_queue_fallback_t fallback);
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  	void			(*ndo_change_rx_flags)(struct net_device *dev,
  						       int flags);
  	void			(*ndo_set_rx_mode)(struct net_device *dev);
@@@ -1685,8 -1553,8 +1699,13 @@@ static inline void netdev_for_each_tx_q
  }
  
  struct netdev_queue *netdev_pick_tx(struct net_device *dev,
++<<<<<<< HEAD
 +				    struct sk_buff *skb);
 +u16 __netdev_pick_tx(struct net_device *dev, struct sk_buff *skb);
++=======
+ 				    struct sk_buff *skb,
+ 				    void *accel_priv);
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  
  /*
   * Net namespace inlines
diff --cc net/core/flow_dissector.c
index 243f397103e5,75fe83f590ea..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -424,20 -392,23 +424,24 @@@ static u16 __netdev_pick_tx(struct net_
  
  	return queue_index;
  }
- EXPORT_SYMBOL(__netdev_pick_tx);
  
  struct netdev_queue *netdev_pick_tx(struct net_device *dev,
 -				    struct sk_buff *skb,
 -				    void *accel_priv)
 +				    struct sk_buff *skb)
  {
  	int queue_index = 0;
  
  	if (dev->real_num_tx_queues != 1) {
  		const struct net_device_ops *ops = dev->netdev_ops;
  		if (ops->ndo_select_queue)
++<<<<<<< HEAD
 +			queue_index = ops->ndo_select_queue(dev, skb);
++=======
+ 			queue_index = ops->ndo_select_queue(dev, skb, accel_priv,
+ 							    __netdev_pick_tx);
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  		else
  			queue_index = __netdev_pick_tx(dev, skb);
 -
 -		if (!accel_priv)
 -			queue_index = dev_cap_txqueue(dev, queue_index);
 +		queue_index = dev_cap_txqueue(dev, queue_index);
  	}
  
  	skb_set_queue_mapping(skb, queue_index);
diff --cc net/mac80211/iface.c
index 2ce1784757ad,ce1c44370610..000000000000
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@@ -1114,9 -1059,6 +1114,12 @@@ static u16 ieee80211_netdev_select_queu
  					 struct sk_buff *skb,
  					 void *accel_priv,
  					 select_queue_fallback_t fallback)
++<<<<<<< HEAD
 +#else
 +					 struct sk_buff *skb)
 +#endif
++=======
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  {
  	return ieee80211_select_queue(IEEE80211_DEV_TO_SUB_IF(dev), skb);
  }
@@@ -1137,9 -1078,6 +1140,12 @@@ static u16 ieee80211_monitor_select_que
  					  struct sk_buff *skb,
  					  void *accel_priv,
  					  select_queue_fallback_t fallback)
++<<<<<<< HEAD
 +#else
 +					  struct sk_buff *skb)
 +#endif
++=======
++>>>>>>> 99932d4fc03a (netdevice: add queue selection fallback handler for ndo_select_queue)
  {
  	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
  	struct ieee80211_local *local = sdata->local;
* Unmerged path drivers/staging/rtl8188eu/os_dep/os_intfs.c
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
* Unmerged path drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
* Unmerged path drivers/net/ethernet/lantiq_etop.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_tx.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
* Unmerged path drivers/net/ethernet/tile/tilegx.c
* Unmerged path drivers/net/team/team.c
* Unmerged path drivers/net/tun.c
* Unmerged path drivers/net/wireless/mwifiex/main.c
* Unmerged path drivers/staging/bcm/Bcmnet.c
* Unmerged path drivers/staging/netlogic/xlr_net.c
* Unmerged path drivers/staging/rtl8188eu/os_dep/os_intfs.c
* Unmerged path include/linux/netdevice.h
* Unmerged path net/core/flow_dissector.c
* Unmerged path net/mac80211/iface.c
