hv_netvsc: protect module refcount by checking net_device_ctx->vf_netdev

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 0f20d795f78d182c4b743d880a5e8dc4d39892fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/0f20d795.failed

We're not guaranteed to see NETDEV_REGISTER/NETDEV_UNREGISTER notifications
only once per VF but we increase/decrease module refcount unconditionally.
Check vf_netdev to make sure we don't take/release it twice. We presume
that only one VF per netvsc device may exist.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Acked-by: Haiyang Zhang <haiyangz@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0f20d795f78d182c4b743d880a5e8dc4d39892fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index 822e657fcee7,62a4e6e3c63e..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -857,8 -1129,197 +857,189 @@@ static void netvsc_link_change(struct w
  
  	if (notify)
  		netdev_notify_peers(net);
 -
 -	/* link_watch only sends one notification with current state per
 -	 * second, handle next reconfig event in 2 seconds.
 -	 */
 -	if (reschedule)
 -		schedule_delayed_work(&ndev_ctx->dwork, LINKCHANGE_INT);
 -
 -	return;
 -
 -out_unlock:
 -	rtnl_unlock();
  }
  
++<<<<<<< HEAD
++=======
+ static void netvsc_free_netdev(struct net_device *netdev)
+ {
+ 	struct net_device_context *net_device_ctx = netdev_priv(netdev);
+ 
+ 	free_percpu(net_device_ctx->tx_stats);
+ 	free_percpu(net_device_ctx->rx_stats);
+ 	free_netdev(netdev);
+ }
+ 
+ static struct net_device *get_netvsc_net_device(char *mac)
+ {
+ 	struct net_device *dev, *found = NULL;
+ 	int rtnl_locked;
+ 
+ 	rtnl_locked = rtnl_trylock();
+ 
+ 	for_each_netdev(&init_net, dev) {
+ 		if (memcmp(dev->dev_addr, mac, ETH_ALEN) == 0) {
+ 			if (dev->netdev_ops != &device_ops)
+ 				continue;
+ 			found = dev;
+ 			break;
+ 		}
+ 	}
+ 	if (rtnl_locked)
+ 		rtnl_unlock();
+ 
+ 	return found;
+ }
+ 
+ static int netvsc_register_vf(struct net_device *vf_netdev)
+ {
+ 	struct net_device *ndev;
+ 	struct net_device_context *net_device_ctx;
+ 	struct netvsc_device *netvsc_dev;
+ 	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
+ 
+ 	if (eth_ops == NULL || eth_ops == &ethtool_ops)
+ 		return NOTIFY_DONE;
+ 
+ 	/*
+ 	 * We will use the MAC address to locate the synthetic interface to
+ 	 * associate with the VF interface. If we don't find a matching
+ 	 * synthetic interface, move on.
+ 	 */
+ 	ndev = get_netvsc_net_device(vf_netdev->dev_addr);
+ 	if (!ndev)
+ 		return NOTIFY_DONE;
+ 
+ 	net_device_ctx = netdev_priv(ndev);
+ 	netvsc_dev = net_device_ctx->nvdev;
+ 	if (!netvsc_dev || net_device_ctx->vf_netdev)
+ 		return NOTIFY_DONE;
+ 
+ 	netdev_info(ndev, "VF registering: %s\n", vf_netdev->name);
+ 	/*
+ 	 * Take a reference on the module.
+ 	 */
+ 	try_module_get(THIS_MODULE);
+ 	net_device_ctx->vf_netdev = vf_netdev;
+ 	return NOTIFY_OK;
+ }
+ 
+ static void netvsc_inject_enable(struct net_device_context *net_device_ctx)
+ {
+ 	net_device_ctx->vf_inject = true;
+ }
+ 
+ static void netvsc_inject_disable(struct net_device_context *net_device_ctx)
+ {
+ 	net_device_ctx->vf_inject = false;
+ 
+ 	/* Wait for currently active users to drain out. */
+ 	while (atomic_read(&net_device_ctx->vf_use_cnt) != 0)
+ 		udelay(50);
+ }
+ 
+ static int netvsc_vf_up(struct net_device *vf_netdev)
+ {
+ 	struct net_device *ndev;
+ 	struct netvsc_device *netvsc_dev;
+ 	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
+ 	struct net_device_context *net_device_ctx;
+ 
+ 	if (eth_ops == &ethtool_ops)
+ 		return NOTIFY_DONE;
+ 
+ 	ndev = get_netvsc_net_device(vf_netdev->dev_addr);
+ 	if (!ndev)
+ 		return NOTIFY_DONE;
+ 
+ 	net_device_ctx = netdev_priv(ndev);
+ 	netvsc_dev = net_device_ctx->nvdev;
+ 
+ 	if (!netvsc_dev || !net_device_ctx->vf_netdev)
+ 		return NOTIFY_DONE;
+ 
+ 	netdev_info(ndev, "VF up: %s\n", vf_netdev->name);
+ 	netvsc_inject_enable(net_device_ctx);
+ 
+ 	/*
+ 	 * Open the device before switching data path.
+ 	 */
+ 	rndis_filter_open(netvsc_dev);
+ 
+ 	/*
+ 	 * notify the host to switch the data path.
+ 	 */
+ 	netvsc_switch_datapath(ndev, true);
+ 	netdev_info(ndev, "Data path switched to VF: %s\n", vf_netdev->name);
+ 
+ 	netif_carrier_off(ndev);
+ 
+ 	/* Now notify peers through VF device. */
+ 	call_netdevice_notifiers(NETDEV_NOTIFY_PEERS, vf_netdev);
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ 
+ static int netvsc_vf_down(struct net_device *vf_netdev)
+ {
+ 	struct net_device *ndev;
+ 	struct netvsc_device *netvsc_dev;
+ 	struct net_device_context *net_device_ctx;
+ 	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
+ 
+ 	if (eth_ops == &ethtool_ops)
+ 		return NOTIFY_DONE;
+ 
+ 	ndev = get_netvsc_net_device(vf_netdev->dev_addr);
+ 	if (!ndev)
+ 		return NOTIFY_DONE;
+ 
+ 	net_device_ctx = netdev_priv(ndev);
+ 	netvsc_dev = net_device_ctx->nvdev;
+ 
+ 	if (!netvsc_dev || !net_device_ctx->vf_netdev)
+ 		return NOTIFY_DONE;
+ 
+ 	netdev_info(ndev, "VF down: %s\n", vf_netdev->name);
+ 	netvsc_inject_disable(net_device_ctx);
+ 	netvsc_switch_datapath(ndev, false);
+ 	netdev_info(ndev, "Data path switched from VF: %s\n", vf_netdev->name);
+ 	rndis_filter_close(netvsc_dev);
+ 	netif_carrier_on(ndev);
+ 
+ 	/* Now notify peers through netvsc device. */
+ 	call_netdevice_notifiers(NETDEV_NOTIFY_PEERS, ndev);
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ 
+ static int netvsc_unregister_vf(struct net_device *vf_netdev)
+ {
+ 	struct net_device *ndev;
+ 	struct netvsc_device *netvsc_dev;
+ 	const struct ethtool_ops *eth_ops = vf_netdev->ethtool_ops;
+ 	struct net_device_context *net_device_ctx;
+ 
+ 	if (eth_ops == &ethtool_ops)
+ 		return NOTIFY_DONE;
+ 
+ 	ndev = get_netvsc_net_device(vf_netdev->dev_addr);
+ 	if (!ndev)
+ 		return NOTIFY_DONE;
+ 
+ 	net_device_ctx = netdev_priv(ndev);
+ 	netvsc_dev = net_device_ctx->nvdev;
+ 	if (!netvsc_dev || !net_device_ctx->vf_netdev)
+ 		return NOTIFY_DONE;
+ 	netdev_info(ndev, "VF unregistering: %s\n", vf_netdev->name);
+ 	netvsc_inject_disable(net_device_ctx);
+ 	net_device_ctx->vf_netdev = NULL;
+ 	module_put(THIS_MODULE);
+ 	return NOTIFY_OK;
+ }
++>>>>>>> 0f20d795f78d (hv_netvsc: protect module refcount by checking net_device_ctx->vf_netdev)
  
  static int netvsc_probe(struct hv_device *dev,
  			const struct hv_vmbus_device_id *dev_id)
* Unmerged path drivers/net/hyperv/netvsc_drv.c
