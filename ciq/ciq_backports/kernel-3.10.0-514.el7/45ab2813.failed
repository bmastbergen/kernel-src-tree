tracing: Do not add event files for modules that fail tracepoints

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Steven Rostedt (Red Hat) <rostedt@goodmis.org>
commit 45ab2813d40d88fc575e753c38478de242d03f88
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/45ab2813.failed

If a module fails to add its tracepoints due to module tainting, do not
create the module event infrastructure in the debugfs directory. As the events
will not work and worse yet, they will silently fail, making the user wonder
why the events they enable do not display anything.

Having a warning on module load and the events not visible to the users
will make the cause of the problem much clearer.

Link: http://lkml.kernel.org/r/20140227154923.265882695@goodmis.org

Fixes: 6d723736e472 "tracing/events: add support for modules to TRACE_EVENT"
	Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
	Cc: stable@vger.kernel.org # 2.6.31+
	Cc: Rusty Russell <rusty@rustcorp.com.au>
	Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
(cherry picked from commit 45ab2813d40d88fc575e753c38478de242d03f88)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/tracepoint.c
diff --cc kernel/tracepoint.c
index e13e0767476a,031cc5655a51..000000000000
--- a/kernel/tracepoint.c
+++ b/kernel/tracepoint.c
@@@ -639,10 -644,9 +644,14 @@@ static int tracepoint_module_coming(str
  	/*
  	 * We skip modules that taint the kernel, especially those with different
  	 * module headers (for forced load), to make sure we don't cause a crash.
 -	 * Staging and out-of-tree GPL modules are fine.
 +	 * Staging, out-of-tree, and unsigned GPL modules are fine.
  	 */
++<<<<<<< HEAD
 +	if (mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |
 +			    (1 << TAINT_UNSIGNED_MODULE)))
++=======
+ 	if (trace_module_has_bad_taint(mod))
++>>>>>>> 45ab2813d40d (tracing: Do not add event files for modules that fail tracepoints)
  		return 0;
  	mutex_lock(&tracepoints_mutex);
  	tp_mod = kmalloc(sizeof(struct tp_module), GFP_KERNEL);
diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index ebeab360d851..0ecc46e7af3d 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -60,6 +60,12 @@ struct tp_module {
 	unsigned int num_tracepoints;
 	struct tracepoint * const *tracepoints_ptrs;
 };
+bool trace_module_has_bad_taint(struct module *mod);
+#else
+static inline bool trace_module_has_bad_taint(struct module *mod)
+{
+	return false;
+}
 #endif /* CONFIG_MODULES */
 
 struct tracepoint_iter {
diff --git a/kernel/trace/trace_events.c b/kernel/trace/trace_events.c
index 3d18aadef493..2f4b185bfc23 100644
--- a/kernel/trace/trace_events.c
+++ b/kernel/trace/trace_events.c
@@ -1860,6 +1860,16 @@ static void trace_module_add_events(struct module *mod)
 	struct ftrace_module_file_ops *file_ops = NULL;
 	struct ftrace_event_call **call, **start, **end;
 
+	if (!mod->num_trace_events)
+		return;
+
+	/* Don't add infrastructure for mods without tracepoints */
+	if (trace_module_has_bad_taint(mod)) {
+		pr_err("%s: module has bad taint, not creating trace events\n",
+		       mod->name);
+		return;
+	}
+
 	start = mod->trace_events;
 	end = mod->trace_events + mod->num_trace_events;
 
* Unmerged path kernel/tracepoint.c
