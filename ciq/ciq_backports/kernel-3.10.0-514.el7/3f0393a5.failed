net/mlx5_core: Introduce offload arithmetic hardware capabilities

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [include] mlx5_core: Introduce offload arithmetic hardware capabilities (kamal heib) [1275159 1296272 1296405 1298421 1298422 1298423 1298424 1298425]
Rebuild_FUZZ: 96.83%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 3f0393a57509c200aeecc5e3984bf1a47bffc578
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/3f0393a5.failed

Define the necessary hardware structures for the offload
arithmetic capabilities and read/cache them on driver load.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Reviewed-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 3f0393a57509c200aeecc5e3984bf1a47bffc578)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mlx5/mlx5_ifc.h
diff --cc include/linux/mlx5/mlx5_ifc.h
index 08e2b9ad01d1,ad0a44b1592c..000000000000
--- a/include/linux/mlx5/mlx5_ifc.h
+++ b/include/linux/mlx5/mlx5_ifc.h
@@@ -612,9 -613,36 +612,36 @@@ struct mlx5_ifc_odp_cap_bits 
  
  	struct mlx5_ifc_odp_per_transport_service_cap_bits ud_odp_caps;
  
 -	u8         reserved_at_e0[0x720];
 +	u8         reserved_3[0x720];
  };
  
+ struct mlx5_ifc_calc_op {
+ 	u8        reserved_at_0[0x10];
+ 	u8        reserved_at_10[0x9];
+ 	u8        op_swap_endianness[0x1];
+ 	u8        op_min[0x1];
+ 	u8        op_xor[0x1];
+ 	u8        op_or[0x1];
+ 	u8        op_and[0x1];
+ 	u8        op_max[0x1];
+ 	u8        op_add[0x1];
+ };
+ 
+ struct mlx5_ifc_vector_calc_cap_bits {
+ 	u8         calc_matrix[0x1];
+ 	u8         reserved_at_1[0x1f];
+ 	u8         reserved_at_20[0x8];
+ 	u8         max_vec_count[0x8];
+ 	u8         reserved_at_30[0xd];
+ 	u8         max_chunk_size[0x3];
+ 	struct mlx5_ifc_calc_op calc0;
+ 	struct mlx5_ifc_calc_op calc1;
+ 	struct mlx5_ifc_calc_op calc2;
+ 	struct mlx5_ifc_calc_op calc3;
+ 
+ 	u8         reserved_at_e0[0x720];
+ };
+ 
  enum {
  	MLX5_WQ_TYPE_LINKED_LIST  = 0x0,
  	MLX5_WQ_TYPE_CYCLIC       = 0x1,
@@@ -761,16 -791,20 +788,23 @@@ struct mlx5_ifc_cmd_hca_cap_bits 
  	u8         cq_eq_remap[0x1];
  	u8         pg[0x1];
  	u8         block_lb_mc[0x1];
 -	u8         reserved_at_228[0x1];
 +	u8         reserved_29[0x1];
  	u8         scqe_break_moderation[0x1];
 -	u8         reserved_at_22a[0x1];
 +	u8         reserved_30[0x1];
  	u8         cd[0x1];
 -	u8         reserved_at_22c[0x1];
 +	u8         reserved_31[0x1];
  	u8         apm[0x1];
++<<<<<<< HEAD
 +	u8         reserved_32[0x7];
++=======
+ 	u8         vector_calc[0x1];
+ 	u8         reserved_at_22f[0x1];
+ 	u8	   imaicl[0x1];
+ 	u8         reserved_at_231[0x4];
++>>>>>>> 3f0393a57509 (net/mlx5_core: Introduce offload arithmetic hardware capabilities)
  	u8         qkv[0x1];
  	u8         pkv[0x1];
 -	u8         set_deth_sqpn[0x1];
 -	u8         reserved_at_239[0x3];
 +	u8         reserved_33[0x4];
  	u8         xrc[0x1];
  	u8         ud[0x1];
  	u8         uc[0x1];
@@@ -1933,7 -1968,8 +1967,12 @@@ union mlx5_ifc_hca_cap_union_bits 
  	struct mlx5_ifc_flow_table_nic_cap_bits flow_table_nic_cap;
  	struct mlx5_ifc_flow_table_eswitch_cap_bits flow_table_eswitch_cap;
  	struct mlx5_ifc_e_switch_cap_bits e_switch_cap;
++<<<<<<< HEAD
 +	u8         reserved_0[0x8000];
++=======
+ 	struct mlx5_ifc_vector_calc_cap_bits vector_calc_cap;
+ 	u8         reserved_at_0[0x8000];
++>>>>>>> 3f0393a57509 (net/mlx5_core: Introduce offload arithmetic hardware capabilities)
  };
  
  enum {
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fw.c b/drivers/net/ethernet/mellanox/mlx5/core/fw.c
index fe6dfd8697f4..75c7ae6a5cc4 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fw.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fw.c
@@ -145,6 +145,12 @@ int mlx5_query_hca_caps(struct mlx5_core_dev *dev)
 			return err;
 	}
 
+	if (MLX5_CAP_GEN(dev, vector_calc)) {
+		err = mlx5_core_get_caps(dev, MLX5_CAP_VECTOR_CALC);
+		if (err)
+			return err;
+	}
+
 	return 0;
 }
 
diff --git a/include/linux/mlx5/device.h b/include/linux/mlx5/device.h
index 4e9c2d87be96..dc62fa4bfe56 100644
--- a/include/linux/mlx5/device.h
+++ b/include/linux/mlx5/device.h
@@ -1208,6 +1208,8 @@ enum mlx5_cap_type {
 	MLX5_CAP_FLOW_TABLE,
 	MLX5_CAP_ESWITCH_FLOW_TABLE,
 	MLX5_CAP_ESWITCH,
+	MLX5_CAP_RESERVED,
+	MLX5_CAP_VECTOR_CALC,
 	/* NUM OF CAP Types */
 	MLX5_CAP_NUM
 };
@@ -1270,6 +1272,10 @@ enum mlx5_cap_type {
 #define MLX5_CAP_ODP(mdev, cap)\
 	MLX5_GET(odp_cap, mdev->hca_caps_cur[MLX5_CAP_ODP], cap)
 
+#define MLX5_CAP_VECTOR_CALC(mdev, cap) \
+	MLX5_GET(vector_calc_cap, \
+		 mdev->hca_caps_cur[MLX5_CAP_VECTOR_CALC], cap)
+
 enum {
 	MLX5_CMD_STAT_OK			= 0x0,
 	MLX5_CMD_STAT_INT_ERR			= 0x1,
* Unmerged path include/linux/mlx5/mlx5_ifc.h
