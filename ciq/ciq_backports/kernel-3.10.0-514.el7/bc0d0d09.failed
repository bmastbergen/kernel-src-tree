libnvdimm, e820: skip module loading when no type-12

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit bc0d0d093b379b0b379c429e3348498287c8a9ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/bc0d0d09.failed

If there are no persistent memory ranges present then don't bother
creating the platform device.  Otherwise, it loads the full libnvdimm
sub-system only to discover no resources present.

	Reported-by: Andy Lutomirski <luto@amacapital.net>
	Acked-by: Andy Lutomirski <luto@amacapital.net>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit bc0d0d093b379b0b379c429e3348498287c8a9ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/pmem.c
diff --cc arch/x86/kernel/pmem.c
index 0f4ef472ab9e,14415aff1813..000000000000
--- a/arch/x86/kernel/pmem.c
+++ b/arch/x86/kernel/pmem.c
@@@ -3,79 -3,29 +3,98 @@@
   * Copyright (c) 2015, Intel Corporation.
   */
  #include <linux/platform_device.h>
 +#include <linux/libnvdimm.h>
  #include <linux/module.h>
++<<<<<<< HEAD
 +#include <asm/e820.h>
 +
 +static void e820_pmem_release(struct device *dev)
 +{
 +	struct nvdimm_bus *nvdimm_bus = dev->platform_data;
 +
 +	if (nvdimm_bus)
 +		nvdimm_bus_unregister(nvdimm_bus);
 +}
 +
 +static struct platform_device e820_pmem = {
 +	.name = "e820_pmem",
 +	.id = -1,
 +	.dev = {
 +		.release = e820_pmem_release,
 +	},
 +};
 +
 +static const struct attribute_group *e820_pmem_attribute_groups[] = {
 +	&nvdimm_bus_attribute_group,
 +	NULL,
 +};
 +
 +static const struct attribute_group *e820_pmem_region_attribute_groups[] = {
 +	&nd_region_attribute_group,
 +	&nd_device_attribute_group,
 +	NULL,
 +};
 +
 +static __init int register_e820_pmem(void)
 +{
 +	static struct nvdimm_bus_descriptor nd_desc;
 +	struct device *dev = &e820_pmem.dev;
 +	struct nvdimm_bus *nvdimm_bus;
 +	int rc, i;
++=======
+ #include <linux/ioport.h>
+ 
+ static int found(u64 start, u64 end, void *data)
+ {
+ 	return 1;
+ }
+ 
+ static __init int register_e820_pmem(void)
+ {
+ 	char *pmem = "Persistent Memory (legacy)";
+ 	struct platform_device *pdev;
+ 	int rc;
+ 
+ 	rc = walk_iomem_res(pmem, IORESOURCE_MEM, 0, -1, NULL, found);
+ 	if (rc <= 0)
+ 		return 0;
++>>>>>>> bc0d0d093b37 (libnvdimm, e820: skip module loading when no type-12)
 +
 +	rc = platform_device_register(&e820_pmem);
 +	if (rc)
 +		return rc;
 +
 +	nd_desc.attr_groups = e820_pmem_attribute_groups;
 +	nd_desc.provider_name = "e820";
 +	nvdimm_bus = nvdimm_bus_register(dev, &nd_desc);
 +	if (!nvdimm_bus)
 +		goto err;
 +	dev->platform_data = nvdimm_bus;
 +
 +	for (i = 0; i < e820.nr_map; i++) {
 +		struct e820entry *ei = &e820.map[i];
 +		struct resource res = {
 +			.flags	= IORESOURCE_MEM,
 +			.start	= ei->addr,
 +			.end	= ei->addr + ei->size - 1,
 +		};
 +		struct nd_region_desc ndr_desc;
 +
 +		if (ei->type != E820_PRAM)
 +			continue;
 +
 +		memset(&ndr_desc, 0, sizeof(ndr_desc));
 +		ndr_desc.res = &res;
 +		ndr_desc.attr_groups = e820_pmem_region_attribute_groups;
 +		if (!nvdimm_pmem_region_create(nvdimm_bus, &ndr_desc))
 +			goto err;
 +	}
 +
 +	return 0;
  
 -	/*
 -	 * See drivers/nvdimm/e820.c for the implementation, this is
 -	 * simply here to trigger the module to load on demand.
 -	 */
 -	pdev = platform_device_alloc("e820_pmem", -1);
 -	return platform_device_add(pdev);
 + err:
 +	dev_err(dev, "failed to register legacy persistent memory ranges\n");
 +	platform_device_unregister(&e820_pmem);
 +	return -ENXIO;
  }
  device_initcall(register_e820_pmem);
* Unmerged path arch/x86/kernel/pmem.c
