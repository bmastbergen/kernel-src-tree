tpm_crb: fix mapping of the buffers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
commit 422eac3f7deae34dbaffd08e03e27f37a5394a56
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/422eac3f.failed

On my Lenovo x250 the following situation occurs:

[18697.813871] tpm_crb MSFT0101:00: can't request region for resource
[mem 0xacdff080-0xacdfffff]

The mapping of the control area overlaps the mapping of the command
buffer. The control area is mapped over page, which is not right. It
should mapped over sizeof(struct crb_control_area).

Fixing this issue unmasks another issue. Command and response buffers
can overlap and they do interleave on this machine. According to the PTP
specification the overlapping means that they are mapped to the same
buffer.

The commit has been also on a Haswell NUC where things worked before
applying this fix so that the both code paths for response buffer
initialization are tested.

	Cc: stable@vger.kernel.org
Fixes: 1bd047be37d9 ("tpm_crb: Use devm_ioremap_resource")
	Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Reviewed-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
(cherry picked from commit 422eac3f7deae34dbaffd08e03e27f37a5394a56)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm_crb.c
diff --cc drivers/char/tpm/tpm_crb.c
index 575071101beb,5afe6840030e..000000000000
--- a/drivers/char/tpm/tpm_crb.c
+++ b/drivers/char/tpm/tpm_crb.c
@@@ -299,6 -221,144 +299,147 @@@ static int crb_acpi_add(struct acpi_dev
  	return tpm_chip_register(chip);
  }
  
++<<<<<<< HEAD
++=======
+ static int crb_check_resource(struct acpi_resource *ares, void *data)
+ {
+ 	struct resource *io_res = data;
+ 	struct resource res;
+ 
+ 	if (acpi_dev_resource_memory(ares, &res)) {
+ 		*io_res = res;
+ 		io_res->name = NULL;
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ static void __iomem *crb_map_res(struct device *dev, struct crb_priv *priv,
+ 				 struct resource *io_res, u64 start, u32 size)
+ {
+ 	struct resource new_res = {
+ 		.start	= start,
+ 		.end	= start + size - 1,
+ 		.flags	= IORESOURCE_MEM,
+ 	};
+ 
+ 	/* Detect a 64 bit address on a 32 bit system */
+ 	if (start != new_res.start)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	if (!resource_contains(io_res, &new_res))
+ 		return devm_ioremap_resource(dev, &new_res);
+ 
+ 	return priv->iobase + (new_res.start - io_res->start);
+ }
+ 
+ static int crb_map_io(struct acpi_device *device, struct crb_priv *priv,
+ 		      struct acpi_table_tpm2 *buf)
+ {
+ 	struct list_head resources;
+ 	struct resource io_res;
+ 	struct device *dev = &device->dev;
+ 	u64 cmd_pa;
+ 	u32 cmd_size;
+ 	u64 rsp_pa;
+ 	u32 rsp_size;
+ 	int ret;
+ 
+ 	INIT_LIST_HEAD(&resources);
+ 	ret = acpi_dev_get_resources(device, &resources, crb_check_resource,
+ 				     &io_res);
+ 	if (ret < 0)
+ 		return ret;
+ 	acpi_dev_free_resource_list(&resources);
+ 
+ 	if (resource_type(&io_res) != IORESOURCE_MEM) {
+ 		dev_err(dev,
+ 			FW_BUG "TPM2 ACPI table does not define a memory resource\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	priv->iobase = devm_ioremap_resource(dev, &io_res);
+ 	if (IS_ERR(priv->iobase))
+ 		return PTR_ERR(priv->iobase);
+ 
+ 	priv->cca = crb_map_res(dev, priv, &io_res, buf->control_address,
+ 				sizeof(struct crb_control_area));
+ 	if (IS_ERR(priv->cca))
+ 		return PTR_ERR(priv->cca);
+ 
+ 	cmd_pa = ((u64) ioread32(&priv->cca->cmd_pa_high) << 32) |
+ 		  (u64) ioread32(&priv->cca->cmd_pa_low);
+ 	cmd_size = ioread32(&priv->cca->cmd_size);
+ 	priv->cmd = crb_map_res(dev, priv, &io_res, cmd_pa, cmd_size);
+ 	if (IS_ERR(priv->cmd))
+ 		return PTR_ERR(priv->cmd);
+ 
+ 	memcpy_fromio(&rsp_pa, &priv->cca->rsp_pa, 8);
+ 	rsp_pa = le64_to_cpu(rsp_pa);
+ 	rsp_size = ioread32(&priv->cca->rsp_size);
+ 
+ 	if (cmd_pa != rsp_pa) {
+ 		priv->rsp = crb_map_res(dev, priv, &io_res, rsp_pa, rsp_size);
+ 		return PTR_ERR_OR_ZERO(priv->rsp);
+ 	}
+ 
+ 	/* According to the PTP specification, overlapping command and response
+ 	 * buffer sizes must be identical.
+ 	 */
+ 	if (cmd_size != rsp_size) {
+ 		dev_err(dev, FW_BUG "overlapping command and response buffer sizes are not identical");
+ 		return -EINVAL;
+ 	}
+ 
+ 	priv->rsp = priv->cmd;
+ 	return 0;
+ }
+ 
+ static int crb_acpi_add(struct acpi_device *device)
+ {
+ 	struct acpi_table_tpm2 *buf;
+ 	struct crb_priv *priv;
+ 	struct device *dev = &device->dev;
+ 	acpi_status status;
+ 	u32 sm;
+ 	int rc;
+ 
+ 	status = acpi_get_table(ACPI_SIG_TPM2, 1,
+ 				(struct acpi_table_header **) &buf);
+ 	if (ACPI_FAILURE(status) || buf->header.length < sizeof(*buf)) {
+ 		dev_err(dev, FW_BUG "failed to get TPM2 ACPI table\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Should the FIFO driver handle this? */
+ 	sm = buf->start_method;
+ 	if (sm == ACPI_TPM2_MEMORY_MAPPED)
+ 		return -ENODEV;
+ 
+ 	priv = devm_kzalloc(dev, sizeof(struct crb_priv), GFP_KERNEL);
+ 	if (!priv)
+ 		return -ENOMEM;
+ 
+ 	/* The reason for the extra quirk is that the PTT in 4th Gen Core CPUs
+ 	 * report only ACPI start but in practice seems to require both
+ 	 * ACPI start and CRB start.
+ 	 */
+ 	if (sm == ACPI_TPM2_COMMAND_BUFFER || sm == ACPI_TPM2_MEMORY_MAPPED ||
+ 	    !strcmp(acpi_device_hid(device), "MSFT0101"))
+ 		priv->flags |= CRB_FL_CRB_START;
+ 
+ 	if (sm == ACPI_TPM2_START_METHOD ||
+ 	    sm == ACPI_TPM2_COMMAND_BUFFER_WITH_START_METHOD)
+ 		priv->flags |= CRB_FL_ACPI_START;
+ 
+ 	rc = crb_map_io(device, priv, buf);
+ 	if (rc)
+ 		return rc;
+ 
+ 	return crb_init(device, priv);
+ }
+ 
++>>>>>>> 422eac3f7dea (tpm_crb: fix mapping of the buffers)
  static int crb_acpi_remove(struct acpi_device *device)
  {
  	struct device *dev = &device->dev;
* Unmerged path drivers/char/tpm/tpm_crb.c
