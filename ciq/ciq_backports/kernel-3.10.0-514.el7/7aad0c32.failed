perf stat record: Write stat round events on record

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 7aad0c32bb6aaa39aab596264ddc49d44c8088f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/7aad0c32.failed

Writing stat round events on 'perf stat record' for each interval round.
In non interval mode we store round event after the last stat event.

Committer note:

After the patch:

  $ perf report -D | grep PERF_RECORD | grep ROUND
  0x852 [0x18]: PERF_RECORD_STAT_ROUND
  $

	Reported-by: Kan Liang <kan.liang@intel.com>
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1446734469-11352-9-git-send-email-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 7aad0c32bb6aaa39aab596264ddc49d44c8088f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-stat.c
diff --cc tools/perf/builtin-stat.c
index 473fc692d35a,fcece42c2611..000000000000
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@@ -197,6 -217,42 +197,45 @@@ static inline int nsec_counter(struct p
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int process_synthesized_event(struct perf_tool *tool __maybe_unused,
+ 				     union perf_event *event,
+ 				     struct perf_sample *sample __maybe_unused,
+ 				     struct machine *machine __maybe_unused)
+ {
+ 	if (perf_data_file__write(&perf_stat.file, event, event->header.size) < 0) {
+ 		pr_err("failed to write perf data, error: %m\n");
+ 		return -1;
+ 	}
+ 
+ 	perf_stat.bytes_written += event->header.size;
+ 	return 0;
+ }
+ 
+ static int write_stat_round_event(u64 time, u64 type)
+ {
+ 	return perf_event__synthesize_stat_round(NULL, time, type,
+ 						 process_synthesized_event,
+ 						 NULL);
+ }
+ 
+ #define WRITE_STAT_ROUND_EVENT(time, interval) \
+ 	write_stat_round_event(time, PERF_STAT_ROUND_TYPE__ ## interval)
+ 
+ #define SID(e, x, y) xyarray__entry(e->sample_id, x, y)
+ 
+ static int
+ perf_evsel__write_stat_event(struct perf_evsel *counter, u32 cpu, u32 thread,
+ 			     struct perf_counts_values *count)
+ {
+ 	struct perf_sample_id *sid = SID(counter, cpu, thread);
+ 
+ 	return perf_event__synthesize_stat(NULL, cpu, thread, sid->id, count,
+ 					   process_synthesized_event, NULL);
+ }
+ 
++>>>>>>> 7aad0c32bb6a (perf stat record: Write stat round events on record)
  /*
   * Read out the results of a single counter:
   * do not aggregate counts across CPUs in system-wide mode
@@@ -1388,6 -1663,41 +1432,44 @@@ int cmd_stat(int argc, const char **arg
  	if (!forever && status != -1 && !interval)
  		print_counters(NULL, argc, argv);
  
++<<<<<<< HEAD
++=======
+ 	if (STAT_RECORD) {
+ 		/*
+ 		 * We synthesize the kernel mmap record just so that older tools
+ 		 * don't emit warnings about not being able to resolve symbols
+ 		 * due to /proc/sys/kernel/kptr_restrict settings and instear provide
+ 		 * a saner message about no samples being in the perf.data file.
+ 		 *
+ 		 * This also serves to suppress a warning about f_header.data.size == 0
+ 		 * in header.c at the moment 'perf stat record' gets introduced, which
+ 		 * is not really needed once we start adding the stat specific PERF_RECORD_
+ 		 * records, but the need to suppress the kptr_restrict messages in older
+ 		 * tools remain  -acme
+ 		 */
+ 		int fd = perf_data_file__fd(&perf_stat.file);
+ 		int err = perf_event__synthesize_kernel_mmap((void *)&perf_stat,
+ 							     process_synthesized_event,
+ 							     &perf_stat.session->machines.host);
+ 		if (err) {
+ 			pr_warning("Couldn't synthesize the kernel mmap record, harmless, "
+ 				   "older tools may produce warnings about this file\n.");
+ 		}
+ 
+ 		if (!interval) {
+ 			if (WRITE_STAT_ROUND_EVENT(walltime_nsecs_stats.max, FINAL))
+ 				pr_err("failed to write stat round event\n");
+ 		}
+ 
+ 		if (!perf_stat.file.is_pipe) {
+ 			perf_stat.session->header.data_size += perf_stat.bytes_written;
+ 			perf_session__write_header(perf_stat.session, evsel_list, fd, true);
+ 		}
+ 
+ 		perf_session__delete(perf_stat.session);
+ 	}
+ 
++>>>>>>> 7aad0c32bb6a (perf stat record: Write stat round events on record)
  	perf_stat__exit_aggr_mode();
  	perf_evlist__free_stats(evsel_list);
  out:
* Unmerged path tools/perf/builtin-stat.c
