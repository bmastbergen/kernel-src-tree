mei: bus: set the device name before running fixup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 213dd193fab8288e2b0b96dc93f974ec33ba2298
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/213dd193.failed

The mei bus fixup use dev_xxx services for printing
to kernel log so we need to setup the device name
prior to running fixup hooks.

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 213dd193fab8288e2b0b96dc93f974ec33ba2298)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/bus.c
diff --cc drivers/misc/mei/bus.c
index 3365981198e7,0b05aa938799..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -130,96 -314,239 +130,140 @@@ static int mei_cl_device_uevent(struct 
  
  	return 0;
  }
 -EXPORT_SYMBOL_GPL(mei_cldev_register_event_cb);
  
 -/**
 - * mei_cldev_get_drvdata - driver data getter
 - *
 - * @cldev: mei client device
 - *
 - * Return: driver private data
 - */
 -void *mei_cldev_get_drvdata(const struct mei_cl_device *cldev)
 -{
 -	return dev_get_drvdata(&cldev->dev);
 -}
 -EXPORT_SYMBOL_GPL(mei_cldev_get_drvdata);
 -
 -/**
 - * mei_cldev_set_drvdata - driver data setter
 - *
 - * @cldev: mei client device
 - * @data: data to store
 - */
 -void mei_cldev_set_drvdata(struct mei_cl_device *cldev, void *data)
 -{
 -	dev_set_drvdata(&cldev->dev, data);
 -}
 -EXPORT_SYMBOL_GPL(mei_cldev_set_drvdata);
 +static struct bus_type mei_cl_bus_type = {
 +	.name		= "mei",
 +	.dev_groups	= mei_cl_dev_groups,
 +	.match		= mei_cl_device_match,
 +	.probe		= mei_cl_device_probe,
 +	.remove		= mei_cl_device_remove,
 +	.uevent		= mei_cl_device_uevent,
 +};
  
 -/**
 - * mei_cldev_uuid - return uuid of the underlying me client
 - *
 - * @cldev: mei client device
 - *
 - * Return: me client uuid
 - */
 -const uuid_le *mei_cldev_uuid(const struct mei_cl_device *cldev)
 +static void mei_cl_dev_release(struct device *dev)
  {
 -	return mei_me_cl_uuid(cldev->me_cl);
 +	kfree(to_mei_cl_device(dev));
  }
 -EXPORT_SYMBOL_GPL(mei_cldev_uuid);
  
 -/**
 - * mei_cldev_ver - return protocol version of the underlying me client
 - *
 - * @cldev: mei client device
 - *
 - * Return: me client protocol version
 - */
 -u8 mei_cldev_ver(const struct mei_cl_device *cldev)
 -{
 -	return mei_me_cl_ver(cldev->me_cl);
 -}
 -EXPORT_SYMBOL_GPL(mei_cldev_ver);
 +static struct device_type mei_cl_device_type = {
 +	.release	= mei_cl_dev_release,
 +};
  
++<<<<<<< HEAD
 +static struct mei_cl *mei_bus_find_mei_cl_by_uuid(struct mei_device *dev,
 +						uuid_le uuid)
++=======
+ /**
 - * mei_cldev_enabled - check whether the device is enabled
 - *
 - * @cldev: mei client device
++ * mei_cl_bus_set_name - set device name for me client device
+  *
 - * Return: true if me client is initialized and connected
++ * @cldev: me client device
+  */
 -bool mei_cldev_enabled(struct mei_cl_device *cldev)
++static inline void mei_cl_bus_set_name(struct mei_cl_device *cldev)
+ {
 -	return cldev->cl && mei_cl_is_connected(cldev->cl);
++	dev_set_name(&cldev->dev, "mei:%s:%pUl:%02X",
++		     cldev->name,
++		     mei_me_cl_uuid(cldev->me_cl),
++		     mei_me_cl_ver(cldev->me_cl));
+ }
 -EXPORT_SYMBOL_GPL(mei_cldev_enabled);
+ 
+ /**
 - * mei_cldev_enable_device - enable me client device
 - *     create connection with me client
++ * mei_cl_bus_dev_alloc - initialize and allocate mei client device
+  *
 - * @cldev: me client device
++ * @bus: mei device
++ * @me_cl: me client
+  *
 - * Return: 0 on success and < 0 on error
++ * Return: allocated device structur or NULL on allocation failure
+  */
 -int mei_cldev_enable(struct mei_cl_device *cldev)
++static struct mei_cl_device *mei_cl_bus_dev_alloc(struct mei_device *bus,
++						  struct mei_me_client *me_cl)
++>>>>>>> 213dd193fab8 (mei: bus: set the device name before running fixup)
  {
 -	struct mei_device *bus = cldev->bus;
  	struct mei_cl *cl;
 -	int ret;
 -
 -	cl = cldev->cl;
 -
 -	if (!cl) {
 -		mutex_lock(&bus->device_lock);
 -		cl = mei_cl_alloc_linked(bus, MEI_HOST_CLIENT_ID_ANY);
 -		mutex_unlock(&bus->device_lock);
 -		if (IS_ERR(cl))
 -			return PTR_ERR(cl);
 -		/* update pointers */
 -		cldev->cl = cl;
 -		cl->cldev = cldev;
 -	}
  
 -	mutex_lock(&bus->device_lock);
 -	if (mei_cl_is_connected(cl)) {
 -		ret = 0;
 -		goto out;
 +	list_for_each_entry(cl, &dev->device_list, device_link) {
 +		if (!uuid_le_cmp(uuid, cl->device_uuid))
 +			return cl;
  	}
  
 -	if (!mei_me_cl_is_active(cldev->me_cl)) {
 -		dev_err(&cldev->dev, "me client is not active\n");
 -		ret = -ENOTTY;
 -		goto out;
 -	}
 -
 -	ret = mei_cl_connect(cl, cldev->me_cl, NULL);
 -	if (ret < 0)
 -		dev_err(&cldev->dev, "cannot connect\n");
 -
 -out:
 -	mutex_unlock(&bus->device_lock);
 -
 -	return ret;
 +	return NULL;
  }
 -EXPORT_SYMBOL_GPL(mei_cldev_enable);
 -
 -/**
 - * mei_cldev_disable - disable me client device
 - *     disconnect form the me client
 - *
 - * @cldev: me client device
 - *
 - * Return: 0 on success and < 0 on error
 - */
 -int mei_cldev_disable(struct mei_cl_device *cldev)
 +struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 +					uuid_le uuid, char *name,
 +					struct mei_cl_ops *ops)
  {
 -	struct mei_device *bus;
 +	struct mei_cl_device *device;
  	struct mei_cl *cl;
 -	int err;
 +	int status;
  
 -	if (!cldev || !cldev->cl)
 -		return -ENODEV;
 +	cl = mei_bus_find_mei_cl_by_uuid(dev, uuid);
 +	if (cl == NULL)
 +		return NULL;
  
 -	cl = cldev->cl;
++<<<<<<< HEAD
 +	device = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
 +	if (!device)
 +		return NULL;
++=======
++	device_initialize(&cldev->dev);
++	cldev->dev.parent = bus->dev;
++	cldev->dev.bus    = &mei_cl_bus_type;
++	cldev->dev.type   = &mei_cl_device_type;
++	cldev->bus        = mei_dev_bus_get(bus);
++	cldev->me_cl      = mei_me_cl_get(me_cl);
++	mei_cl_bus_set_name(cldev);
++	cldev->is_added   = 0;
++	INIT_LIST_HEAD(&cldev->bus_list);
++>>>>>>> 213dd193fab8 (mei: bus: set the device name before running fixup)
  
 -	bus = cldev->bus;
 +	device->cl = cl;
 +	device->ops = ops;
  
 -	cldev->event_cb = NULL;
 +	device->dev.parent = &dev->pdev->dev;
 +	device->dev.bus = &mei_cl_bus_type;
 +	device->dev.type = &mei_cl_device_type;
  
 -	mutex_lock(&bus->device_lock);
++<<<<<<< HEAD
 +	dev_set_name(&device->dev, "%s", name);
++=======
++	/* the device name can change during fix up */
++	if (cldev->do_match)
++		mei_cl_bus_set_name(cldev);
++>>>>>>> 213dd193fab8 (mei: bus: set the device name before running fixup)
  
 -	if (!mei_cl_is_connected(cl)) {
 -		dev_err(bus->dev, "Already disconnected");
 -		err = 0;
 -		goto out;
 +	status = device_register(&device->dev);
 +	if (status) {
 +		dev_err(&dev->pdev->dev, "Failed to register MEI device\n");
 +		kfree(device);
 +		return NULL;
  	}
  
 -	err = mei_cl_disconnect(cl);
 -	if (err < 0)
 -		dev_err(bus->dev, "Could not disconnect from the ME client");
 -
 -out:
 -	/* Flush queues and remove any pending read */
 -	mei_cl_flush_queues(cl, NULL);
 -	mei_cl_unlink(cl);
 +	cl->device = device;
  
 -	kfree(cl);
 -	cldev->cl = NULL;
 +	dev_dbg(&device->dev, "client %s registered\n", name);
  
 -	mutex_unlock(&bus->device_lock);
 -	return err;
 +	return device;
  }
 -EXPORT_SYMBOL_GPL(mei_cldev_disable);
 +EXPORT_SYMBOL_GPL(mei_cl_add_device);
  
 -/**
 - * mei_cl_device_find - find matching entry in the driver id table
 - *
 - * @cldev: me client device
 - * @cldrv: me client driver
 - *
 - * Return: id on success; NULL if no id is matching
 - */
 -static const
 -struct mei_cl_device_id *mei_cl_device_find(struct mei_cl_device *cldev,
 -					    struct mei_cl_driver *cldrv)
 +void mei_cl_remove_device(struct mei_cl_device *device)
  {
 -	const struct mei_cl_device_id *id;
 -	const uuid_le *uuid;
 -	u8 version;
 -	bool match;
 -
 -	uuid = mei_me_cl_uuid(cldev->me_cl);
 -	version = mei_me_cl_ver(cldev->me_cl);
 -
 -	id = cldrv->id_table;
 -	while (uuid_le_cmp(NULL_UUID_LE, id->uuid)) {
 -		if (!uuid_le_cmp(*uuid, id->uuid)) {
 -			match = true;
 -
 -			if (cldev->name[0])
 -				if (strncmp(cldev->name, id->name,
 -					    sizeof(id->name)))
 -					match = false;
 -
 -			if (id->version != MEI_CL_VERSION_ANY)
 -				if (id->version != version)
 -					match = false;
 -			if (match)
 -				return id;
 -		}
 -
 -		id++;
 -	}
 -
 -	return NULL;
 +	device_unregister(&device->dev);
  }
 +EXPORT_SYMBOL_GPL(mei_cl_remove_device);
  
 -/**
 - * mei_cl_device_match  - device match function
 - *
 - * @dev: device
 - * @drv: driver
 - *
 - * Return:  1 if matching device was found 0 otherwise
 - */
 -static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
 +int __mei_cl_driver_register(struct mei_cl_driver *driver, struct module *owner)
  {
 -	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 -	struct mei_cl_driver *cldrv = to_mei_cl_driver(drv);
 -	const struct mei_cl_device_id *found_id;
 -
 -	if (!cldev)
 -		return 0;
 +	int err;
  
 -	if (!cldev->do_match)
 -		return 0;
 +	driver->driver.name = driver->name;
 +	driver->driver.owner = owner;
 +	driver->driver.bus = &mei_cl_bus_type;
  
 -	if (!cldrv || !cldrv->id_table)
 -		return 0;
 +	err = driver_register(&driver->driver);
 +	if (err)
 +		return err;
  
 -	found_id = mei_cl_device_find(cldev, cldrv);
 -	if (found_id)
 -		return 1;
 +	pr_debug("mei: driver [%s] registered\n", driver->driver.name);
  
  	return 0;
  }
* Unmerged path drivers/misc/mei/bus.c
