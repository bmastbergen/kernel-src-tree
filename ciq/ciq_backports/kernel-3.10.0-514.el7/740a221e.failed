mmc: slot-gpio: Add GPIO descriptor based CD GPIO API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 740a221ef0e579dc7c675cf6b90f5313509788f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/740a221e.failed

Add functions to request a CD GPIO using the GPIO descriptor API.
Note that the new request function is paired with mmc_gpiod_free_cd()
not mmc_gpio_free_cd().  Note also that it must be called prior to
mmc_add_host() otherwise the caller must also call
mmc_gpiod_request_cd_irq().

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Chris Ball <chris@printf.net>
(cherry picked from commit 740a221ef0e579dc7c675cf6b90f5313509788f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/slot-gpio.c
diff --cc drivers/mmc/core/slot-gpio.c
index 2d78bc46fa68,f7650b899e3d..000000000000
--- a/drivers/mmc/core/slot-gpio.c
+++ b/drivers/mmc/core/slot-gpio.c
@@@ -139,44 -139,18 +139,48 @@@ int mmc_gpio_request_ro(struct mmc_hos
  }
  EXPORT_SYMBOL(mmc_gpio_request_ro);
  
++<<<<<<< HEAD
 +/**
 + * mmc_gpio_request_cd - request a gpio for card-detection
 + * @host: mmc host
 + * @gpio: gpio number requested
 + *
 + * As devm_* managed functions are used in mmc_gpio_request_cd(), client
 + * drivers do not need to explicitly call mmc_gpio_free_cd() for freeing up,
 + * if the requesting and freeing are only needed at probing and unbinding time
 + * for once.  However, if client drivers do something special like runtime
 + * switching for card-detection, they are responsible for calling
 + * mmc_gpio_request_cd() and mmc_gpio_free_cd() as a pair on their own.
 + *
 + * Returns zero on success, else an error.
 + */
 +int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio)
++=======
+ void mmc_gpiod_request_cd_irq(struct mmc_host *host)
++>>>>>>> 740a221ef0e5 (mmc: slot-gpio: Add GPIO descriptor based CD GPIO API)
  {
 -	struct mmc_gpio *ctx = host->slot.handler_priv;
 -	int ret, irq;
 +	struct mmc_gpio *ctx;
 +	int irq = gpio_to_irq(gpio);
 +	int ret;
 +
 +	ret = mmc_gpio_alloc(host);
 +	if (ret < 0)
 +		return ret;
  
 -	if (host->slot.cd_irq >= 0 || !ctx || !ctx->cd_gpio)
 -		return;
 +	ctx = host->slot.handler_priv;
  
 -	irq = gpiod_to_irq(ctx->cd_gpio);
 +	ret = devm_gpio_request_one(&host->class_dev, gpio, GPIOF_DIR_IN,
 +				    ctx->cd_label);
 +	if (ret < 0)
 +		/*
 +		 * don't bother freeing memory. It might still get used by other
 +		 * slot functions, in any case it will be freed, when the device
 +		 * is destroyed.
 +		 */
 +		return ret;
  
  	/*
 -	 * Even if gpiod_to_irq() returns a valid IRQ number, the platform might
 +	 * Even if gpio_to_irq() returns a valid IRQ number, the platform might
  	 * still prefer to poll, e.g., because that IRQ number is already used
  	 * by another unit and cannot be shared.
  	 */
@@@ -196,6 -170,55 +200,58 @@@
  
  	if (irq < 0)
  		host->caps |= MMC_CAP_NEEDS_POLL;
++<<<<<<< HEAD
++=======
+ }
+ EXPORT_SYMBOL(mmc_gpiod_request_cd_irq);
+ 
+ /**
+  * mmc_gpio_request_cd - request a gpio for card-detection
+  * @host: mmc host
+  * @gpio: gpio number requested
+  * @debounce: debounce time in microseconds
+  *
+  * As devm_* managed functions are used in mmc_gpio_request_cd(), client
+  * drivers do not need to explicitly call mmc_gpio_free_cd() for freeing up,
+  * if the requesting and freeing are only needed at probing and unbinding time
+  * for once.  However, if client drivers do something special like runtime
+  * switching for card-detection, they are responsible for calling
+  * mmc_gpio_request_cd() and mmc_gpio_free_cd() as a pair on their own.
+  *
+  * If GPIO debouncing is desired, set the debounce parameter to a non-zero
+  * value. The caller is responsible for ensuring that the GPIO driver associated
+  * with the GPIO supports debouncing, otherwise an error will be returned.
+  *
+  * Returns zero on success, else an error.
+  */
+ int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio,
+ 			unsigned int debounce)
+ {
+ 	struct mmc_gpio *ctx;
+ 	int ret;
+ 
+ 	ret = mmc_gpio_alloc(host);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ctx = host->slot.handler_priv;
+ 
+ 	ret = devm_gpio_request_one(&host->class_dev, gpio, GPIOF_DIR_IN,
+ 				    ctx->cd_label);
+ 	if (ret < 0)
+ 		/*
+ 		 * don't bother freeing memory. It might still get used by other
+ 		 * slot functions, in any case it will be freed, when the device
+ 		 * is destroyed.
+ 		 */
+ 		return ret;
+ 
+ 	if (debounce) {
+ 		ret = gpio_set_debounce(gpio, debounce);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
++>>>>>>> 740a221ef0e5 (mmc: slot-gpio: Add GPIO descriptor based CD GPIO API)
  
  	ctx->override_cd_active_level = true;
  	ctx->cd_gpio = gpio_to_desc(gpio);
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index dc7a5fb81a5c..acbc3f2aaaf9 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -34,6 +34,7 @@
 #include <linux/mmc/host.h>
 #include <linux/mmc/mmc.h>
 #include <linux/mmc/sd.h>
+#include <linux/mmc/slot-gpio.h>
 
 #include "core.h"
 #include "bus.h"
@@ -2471,6 +2472,7 @@ void mmc_start_host(struct mmc_host *host)
 		mmc_power_off(host);
 	else
 		mmc_power_up(host, host->ocr_avail);
+	mmc_gpiod_request_cd_irq(host);
 	_mmc_detect_change(host, 0, false);
 }
 
@@ -2482,6 +2484,8 @@ void mmc_stop_host(struct mmc_host *host)
 	host->removed = 1;
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
+	if (host->slot.cd_irq >= 0)
+		disable_irq(host->slot.cd_irq);
 
 	host->rescan_disable = 1;
 	cancel_delayed_work_sync(&host->detect);
* Unmerged path drivers/mmc/core/slot-gpio.c
diff --git a/include/linux/mmc/slot-gpio.h b/include/linux/mmc/slot-gpio.h
index 7d88d27bfafa..b9ccfaa7694c 100644
--- a/include/linux/mmc/slot-gpio.h
+++ b/include/linux/mmc/slot-gpio.h
@@ -21,4 +21,10 @@ int mmc_gpio_get_cd(struct mmc_host *host);
 int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio);
 void mmc_gpio_free_cd(struct mmc_host *host);
 
+int mmc_gpiod_request_cd(struct mmc_host *host, const char *con_id,
+			 unsigned int idx, bool override_active_level,
+			 unsigned int debounce);
+void mmc_gpiod_free_cd(struct mmc_host *host);
+void mmc_gpiod_request_cd_irq(struct mmc_host *host);
+
 #endif
