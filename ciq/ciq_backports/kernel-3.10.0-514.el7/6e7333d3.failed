net: add rx_nohandler stat counter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] add rx_nohandler stat counter (Jarod Wilson) [1289198]
Rebuild_FUZZ: 92.06%
commit-author Jarod Wilson <jarod@redhat.com>
commit 6e7333d315a768170a59ac771297ee0551bdddbf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6e7333d3.failed

This adds an rx_nohandler stat counter, along with a sysfs statistics
node, and copies the counter out via netlink as well.

CC: "David S. Miller" <davem@davemloft.net>
CC: Eric Dumazet <edumazet@google.com>
CC: Jiri Pirko <jiri@mellanox.com>
CC: Daniel Borkmann <daniel@iogearbox.net>
CC: Tom Herbert <tom@herbertland.com>
CC: Jay Vosburgh <j.vosburgh@gmail.com>
CC: Veaceslav Falico <vfalico@gmail.com>
CC: Andy Gospodarek <gospo@cumulusnetworks.com>
CC: netdev@vger.kernel.org
	Signed-off-by: Jarod Wilson <jarod@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6e7333d315a768170a59ac771297ee0551bdddbf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/core/dev.c
diff --cc include/linux/netdevice.h
index 341e8588b936,78a20cec2a0a..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1272,12 -1338,222 +1272,223 @@@ enum netdev_priv_flags 
  #define IFF_LIVE_ADDR_CHANGE		IFF_LIVE_ADDR_CHANGE
  #define IFF_MACVLAN			IFF_MACVLAN
  #define IFF_XMIT_DST_RELEASE_PERM	IFF_XMIT_DST_RELEASE_PERM
 -#define IFF_IPVLAN_MASTER		IFF_IPVLAN_MASTER
 -#define IFF_IPVLAN_SLAVE		IFF_IPVLAN_SLAVE
 -#define IFF_L3MDEV_MASTER		IFF_L3MDEV_MASTER
 -#define IFF_NO_QUEUE			IFF_NO_QUEUE
 -#define IFF_OPENVSWITCH			IFF_OPENVSWITCH
 -#define IFF_L3MDEV_SLAVE		IFF_L3MDEV_SLAVE
 -#define IFF_TEAM			IFF_TEAM
  
++<<<<<<< HEAD
 +/*
 + *	The DEVICE structure.
 + *	Actually, this whole structure is a big mistake.  It mixes I/O
 + *	data with strictly "high-level" data, and it has to know about
 + *	almost every data structure used in the INET module.
++=======
+ /**
+  *	struct net_device - The DEVICE structure.
+  *		Actually, this whole structure is a big mistake.  It mixes I/O
+  *		data with strictly "high-level" data, and it has to know about
+  *		almost every data structure used in the INET module.
+  *
+  *	@name:	This is the first field of the "visible" part of this structure
+  *		(i.e. as seen by users in the "Space.c" file).  It is the name
+  *	 	of the interface.
+  *
+  *	@name_hlist: 	Device name hash chain, please keep it close to name[]
+  *	@ifalias:	SNMP alias
+  *	@mem_end:	Shared memory end
+  *	@mem_start:	Shared memory start
+  *	@base_addr:	Device I/O address
+  *	@irq:		Device IRQ number
+  *
+  *	@carrier_changes:	Stats to monitor carrier on<->off transitions
+  *
+  *	@state:		Generic network queuing layer state, see netdev_state_t
+  *	@dev_list:	The global list of network devices
+  *	@napi_list:	List entry, that is used for polling napi devices
+  *	@unreg_list:	List entry, that is used, when we are unregistering the
+  *			device, see the function unregister_netdev
+  *	@close_list:	List entry, that is used, when we are closing the device
+  *
+  *	@adj_list:	Directly linked devices, like slaves for bonding
+  *	@all_adj_list:	All linked devices, *including* neighbours
+  *	@features:	Currently active device features
+  *	@hw_features:	User-changeable features
+  *
+  *	@wanted_features:	User-requested features
+  *	@vlan_features:		Mask of features inheritable by VLAN devices
+  *
+  *	@hw_enc_features:	Mask of features inherited by encapsulating devices
+  *				This field indicates what encapsulation
+  *				offloads the hardware is capable of doing,
+  *				and drivers will need to set them appropriately.
+  *
+  *	@mpls_features:	Mask of features inheritable by MPLS
+  *
+  *	@ifindex:	interface index
+  *	@group:		The group, that the device belongs to
+  *
+  *	@stats:		Statistics struct, which was left as a legacy, use
+  *			rtnl_link_stats64 instead
+  *
+  *	@rx_dropped:	Dropped packets by core network,
+  *			do not use this in drivers
+  *	@tx_dropped:	Dropped packets by core network,
+  *			do not use this in drivers
+  *	@rx_nohandler:	nohandler dropped packets by core network on
+  *			inactive devices, do not use this in drivers
+  *
+  *	@wireless_handlers:	List of functions to handle Wireless Extensions,
+  *				instead of ioctl,
+  *				see <net/iw_handler.h> for details.
+  *	@wireless_data:	Instance data managed by the core of wireless extensions
+  *
+  *	@netdev_ops:	Includes several pointers to callbacks,
+  *			if one wants to override the ndo_*() functions
+  *	@ethtool_ops:	Management operations
+  *	@header_ops:	Includes callbacks for creating,parsing,caching,etc
+  *			of Layer 2 headers.
+  *
+  *	@flags:		Interface flags (a la BSD)
+  *	@priv_flags:	Like 'flags' but invisible to userspace,
+  *			see if.h for the definitions
+  *	@gflags:	Global flags ( kept as legacy )
+  *	@padded:	How much padding added by alloc_netdev()
+  *	@operstate:	RFC2863 operstate
+  *	@link_mode:	Mapping policy to operstate
+  *	@if_port:	Selectable AUI, TP, ...
+  *	@dma:		DMA channel
+  *	@mtu:		Interface MTU value
+  *	@type:		Interface hardware type
+  *	@hard_header_len: Hardware header length, which means that this is the
+  *			  minimum size of a packet.
+  *
+  *	@needed_headroom: Extra headroom the hardware may need, but not in all
+  *			  cases can this be guaranteed
+  *	@needed_tailroom: Extra tailroom the hardware may need, but not in all
+  *			  cases can this be guaranteed. Some cases also use
+  *			  LL_MAX_HEADER instead to allocate the skb
+  *
+  *	interface address info:
+  *
+  * 	@perm_addr:		Permanent hw address
+  * 	@addr_assign_type:	Hw address assignment type
+  * 	@addr_len:		Hardware address length
+  * 	@neigh_priv_len;	Used in neigh_alloc(),
+  * 				initialized only in atm/clip.c
+  * 	@dev_id:		Used to differentiate devices that share
+  * 				the same link layer address
+  * 	@dev_port:		Used to differentiate devices that share
+  * 				the same function
+  *	@addr_list_lock:	XXX: need comments on this one
+  *	@uc_promisc:		Counter, that indicates, that promiscuous mode
+  *				has been enabled due to the need to listen to
+  *				additional unicast addresses in a device that
+  *				does not implement ndo_set_rx_mode()
+  *	@uc:			unicast mac addresses
+  *	@mc:			multicast mac addresses
+  *	@dev_addrs:		list of device hw addresses
+  *	@queues_kset:		Group of all Kobjects in the Tx and RX queues
+  *	@promiscuity:		Number of times, the NIC is told to work in
+  *				Promiscuous mode, if it becomes 0 the NIC will
+  *				exit from working in Promiscuous mode
+  *	@allmulti:		Counter, enables or disables allmulticast mode
+  *
+  *	@vlan_info:	VLAN info
+  *	@dsa_ptr:	dsa specific data
+  *	@tipc_ptr:	TIPC specific data
+  *	@atalk_ptr:	AppleTalk link
+  *	@ip_ptr:	IPv4 specific data
+  *	@dn_ptr:	DECnet specific data
+  *	@ip6_ptr:	IPv6 specific data
+  *	@ax25_ptr:	AX.25 specific data
+  *	@ieee80211_ptr:	IEEE 802.11 specific data, assign before registering
+  *
+  *	@last_rx:	Time of last Rx
+  *	@dev_addr:	Hw address (before bcast,
+  *			because most packets are unicast)
+  *
+  *	@_rx:			Array of RX queues
+  *	@num_rx_queues:		Number of RX queues
+  *				allocated at register_netdev() time
+  *	@real_num_rx_queues: 	Number of RX queues currently active in device
+  *
+  *	@rx_handler:		handler for received packets
+  *	@rx_handler_data: 	XXX: need comments on this one
+  *	@ingress_queue:		XXX: need comments on this one
+  *	@broadcast:		hw bcast address
+  *
+  *	@rx_cpu_rmap:	CPU reverse-mapping for RX completion interrupts,
+  *			indexed by RX queue number. Assigned by driver.
+  *			This must only be set if the ndo_rx_flow_steer
+  *			operation is defined
+  *	@index_hlist:		Device index hash chain
+  *
+  *	@_tx:			Array of TX queues
+  *	@num_tx_queues:		Number of TX queues allocated at alloc_netdev_mq() time
+  *	@real_num_tx_queues: 	Number of TX queues currently active in device
+  *	@qdisc:			Root qdisc from userspace point of view
+  *	@tx_queue_len:		Max frames per queue allowed
+  *	@tx_global_lock: 	XXX: need comments on this one
+  *
+  *	@xps_maps:	XXX: need comments on this one
+  *
+  *	@offload_fwd_mark:	Offload device fwding mark
+  *
+  *	@trans_start:		Time (in jiffies) of last Tx
+  *	@watchdog_timeo:	Represents the timeout that is used by
+  *				the watchdog ( see dev_watchdog() )
+  *	@watchdog_timer:	List of timers
+  *
+  *	@pcpu_refcnt:		Number of references to this device
+  *	@todo_list:		Delayed register/unregister
+  *	@link_watch_list:	XXX: need comments on this one
+  *
+  *	@reg_state:		Register/unregister state machine
+  *	@dismantle:		Device is going to be freed
+  *	@rtnl_link_state:	This enum represents the phases of creating
+  *				a new link
+  *
+  *	@destructor:		Called from unregister,
+  *				can be used to call free_netdev
+  *	@npinfo:		XXX: need comments on this one
+  * 	@nd_net:		Network namespace this network device is inside
+  *
+  * 	@ml_priv:	Mid-layer private
+  * 	@lstats:	Loopback statistics
+  * 	@tstats:	Tunnel statistics
+  * 	@dstats:	Dummy statistics
+  * 	@vstats:	Virtual ethernet statistics
+  *
+  *	@garp_port:	GARP
+  *	@mrp_port:	MRP
+  *
+  *	@dev:		Class/net/name entry
+  *	@sysfs_groups:	Space for optional device, statistics and wireless
+  *			sysfs groups
+  *
+  *	@sysfs_rx_queue_group:	Space for optional per-rx queue attributes
+  *	@rtnl_link_ops:	Rtnl_link_ops
+  *
+  *	@gso_max_size:	Maximum size of generic segmentation offload
+  *	@gso_max_segs:	Maximum number of segments that can be passed to the
+  *			NIC for GSO
+  *	@gso_min_segs:	Minimum number of segments that can be passed to the
+  *			NIC for GSO
+  *
+  *	@dcbnl_ops:	Data Center Bridging netlink ops
+  *	@num_tc:	Number of traffic classes in the net device
+  *	@tc_to_txq:	XXX: need comments on this one
+  *	@prio_tc_map	XXX: need comments on this one
+  *
+  *	@fcoe_ddp_xid:	Max exchange id for FCoE LRO by ddp
+  *
+  *	@priomap:	XXX: need comments on this one
+  *	@phydev:	Physical device may attach itself
+  *			for hardware timestamping
+  *
+  *	@qdisc_tx_busylock:	XXX: need comments on this one
+  *
+  *	@proto_down:	protocol port state information can be sent to the
+  *			switch driver and used to set the phys state of the
+  *			switch port.
++>>>>>>> 6e7333d315a7 (net: add rx_nohandler stat counter)
   *
   *	FIXME: cleanup struct net_device such that network protocol info
   *	moves out.
@@@ -1317,69 -1585,67 +1528,76 @@@ struct net_device 
  	struct list_head	dev_list;
  	struct list_head	napi_list;
  	struct list_head	unreg_list;
 -	struct list_head	close_list;
 -	struct list_head	ptype_all;
 -	struct list_head	ptype_specific;
 -
 -	struct {
 -		struct list_head upper;
 -		struct list_head lower;
 -	} adj_list;
 +	struct list_head	upper_dev_list; /* List of upper devices */
  
 -	struct {
 -		struct list_head upper;
 -		struct list_head lower;
 -	} all_adj_list;
  
 +	/* currently active device features */
  	netdev_features_t	features;
 +	/* user-changeable features */
  	netdev_features_t	hw_features;
 +	/* user-requested features */
  	netdev_features_t	wanted_features;
 +	/* mask of features inheritable by VLAN devices */
  	netdev_features_t	vlan_features;
 +	/* mask of features inherited by encapsulating devices
 +	 * This field indicates what encapsulation offloads
 +	 * the hardware is capable of doing, and drivers will
 +	 * need to set them appropriately.
 +	 */
  	netdev_features_t	hw_enc_features;
 +	/* mask of fetures inheritable by MPLS */
  	netdev_features_t	mpls_features;
  
 +	/* Interface index. Unique device identifier	*/
  	int			ifindex;
 -	int			group;
 +	int			iflink;
  
  	struct net_device_stats	stats;
++<<<<<<< HEAD
 +	atomic_long_t		rx_dropped; /* dropped packets by core network
 +					     * Do not use this in drivers.
 +					     */
++=======
+ 
+ 	atomic_long_t		rx_dropped;
+ 	atomic_long_t		tx_dropped;
+ 	atomic_long_t		rx_nohandler;
++>>>>>>> 6e7333d315a7 (net: add rx_nohandler stat counter)
  
  #ifdef CONFIG_WIRELESS_EXT
 +	/* List of functions to handle Wireless Extensions (instead of ioctl).
 +	 * See <net/iw_handler.h> for details. Jean II */
  	const struct iw_handler_def *	wireless_handlers;
 +	/* Instance data managed by the core of Wireless Extensions. */
  	struct iw_public_data *	wireless_data;
  #endif
 +	/* Management operations */
  	const struct net_device_ops *netdev_ops;
  	const struct ethtool_ops *ethtool_ops;
 -#ifdef CONFIG_NET_SWITCHDEV
 -	const struct switchdev_ops *switchdev_ops;
 -#endif
 -#ifdef CONFIG_NET_L3_MASTER_DEV
 -	const struct l3mdev_ops	*l3mdev_ops;
 -#endif
  
 +	/* Hardware header description */
  	const struct header_ops *header_ops;
  
 -	unsigned int		flags;
 -	unsigned int		priv_flags;
 -
 +	unsigned int		flags;	/* interface flags (a la BSD)	*/
 +	unsigned int		priv_flags; /* Like 'flags' but invisible to userspace.
 +					     * See if.h for definitions. */
  	unsigned short		gflags;
 -	unsigned short		padded;
 +	unsigned short		padded;	/* How much padding added by alloc_netdev() */
  
 -	unsigned char		operstate;
 -	unsigned char		link_mode;
 +	unsigned char		operstate; /* RFC2863 operstate */
 +	unsigned char		link_mode; /* mapping policy to operstate */
  
 -	unsigned char		if_port;
 -	unsigned char		dma;
 +	unsigned char		if_port;	/* Selectable AUI, TP,..*/
 +	unsigned char		dma;		/* DMA channel		*/
  
 -	unsigned int		mtu;
 -	unsigned short		type;
 -	unsigned short		hard_header_len;
 +	unsigned int		mtu;	/* interface MTU value		*/
 +	unsigned short		type;	/* interface hardware type	*/
 +	unsigned short		hard_header_len;	/* hardware hdr length	*/
  
 +	/* extra head- and tailroom the hardware may need, but not in all cases
 +	 * can this be guaranteed, especially tailroom. Some cases also use
 +	 * LL_MAX_HEADER instead to allocate the skb.
 +	 */
  	unsigned short		needed_headroom;
  	unsigned short		needed_tailroom;
  
diff --cc net/core/dev.c
index 60da7083ece8,f1284835b8c9..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -5928,6 -7309,8 +5931,11 @@@ struct rtnl_link_stats64 *dev_get_stats
  		netdev_stats_to_stats64(storage, &dev->stats);
  	}
  	storage->rx_dropped += atomic_long_read(&dev->rx_dropped);
++<<<<<<< HEAD
++=======
+ 	storage->tx_dropped += atomic_long_read(&dev->tx_dropped);
+ 	storage->rx_nohandler += atomic_long_read(&dev->rx_nohandler);
++>>>>>>> 6e7333d315a7 (net: add rx_nohandler stat counter)
  	return storage;
  }
  EXPORT_SYMBOL(dev_get_stats);
* Unmerged path include/linux/netdevice.h
diff --git a/include/uapi/linux/if_link.h b/include/uapi/linux/if_link.h
index 30b75598aa6b..b34bcfa3c7ab 100644
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@ -35,6 +35,8 @@ struct rtnl_link_stats {
 	/* for cslip etc */
 	__u32	rx_compressed;
 	__u32	tx_compressed;
+
+	__u32	rx_nohandler;		/* dropped, no handler found	*/
 };
 
 /* The main device statistics structure */
@@ -68,6 +70,8 @@ struct rtnl_link_stats64 {
 	/* for cslip etc */
 	__u64	rx_compressed;
 	__u64	tx_compressed;
+
+	__u64	rx_nohandler;		/* dropped, no handler found	*/
 };
 
 /* The struct should be in sync with struct ifmap */
* Unmerged path net/core/dev.c
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index 5594a4cef283..b5042dd52898 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -477,6 +477,7 @@ NETSTAT_ENTRY(tx_heartbeat_errors);
 NETSTAT_ENTRY(tx_window_errors);
 NETSTAT_ENTRY(rx_compressed);
 NETSTAT_ENTRY(tx_compressed);
+NETSTAT_ENTRY(rx_nohandler);
 
 static struct attribute *netstat_attrs[] = {
 	&dev_attr_rx_packets.attr,
@@ -502,6 +503,7 @@ static struct attribute *netstat_attrs[] = {
 	&dev_attr_tx_window_errors.attr,
 	&dev_attr_rx_compressed.attr,
 	&dev_attr_tx_compressed.attr,
+	&dev_attr_rx_nohandler.attr,
 	NULL
 };
 
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 1bedb5be9105..cead3e8d606e 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -821,6 +821,8 @@ static void copy_rtnl_link_stats(struct rtnl_link_stats *a,
 
 	a->rx_compressed = b->rx_compressed;
 	a->tx_compressed = b->tx_compressed;
+
+	a->rx_nohandler = b->rx_nohandler;
 }
 
 static void copy_rtnl_link_stats64(void *v, const struct rtnl_link_stats64 *b)
