usb: dwc3: pci: add Intel Kabylake PCI ID

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [usb] dwc3: pci: add Intel Kabylake PCI ID (David Arcari) [1310953]
Rebuild_FUZZ: 93.51%
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit 4491ed5042f0419b22a4b08331adb54af31e2caa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4491ed50.failed

Intel Kabylake PCH has the same DWC3 than Intel
Sunrisepoint. Add the new ID to the supported devices.

	Cc: <stable@vger.kernel.org>
	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
(cherry picked from commit 4491ed5042f0419b22a4b08331adb54af31e2caa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/dwc3/dwc3-pci.c
diff --cc drivers/usb/dwc3/dwc3-pci.c
index fc404193b22e,2eb84d6c24a6..000000000000
--- a/drivers/usb/dwc3/dwc3-pci.c
+++ b/drivers/usb/dwc3/dwc3-pci.c
@@@ -40,76 -20,120 +40,91 @@@
  #include <linux/module.h>
  #include <linux/slab.h>
  #include <linux/pci.h>
 -#include <linux/pm_runtime.h>
  #include <linux/platform_device.h>
 -#include <linux/gpio/consumer.h>
 -#include <linux/acpi.h>
 -#include <linux/delay.h>
  
++<<<<<<< HEAD
 +#include <linux/usb/otg.h>
 +#include <linux/usb/nop-usb-xceiv.h>
++=======
+ #define PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3		0xabcd
+ #define PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3_AXI	0xabce
+ #define PCI_DEVICE_ID_SYNOPSYS_HAPSUSB31	0xabcf
+ #define PCI_DEVICE_ID_INTEL_BYT			0x0f37
+ #define PCI_DEVICE_ID_INTEL_MRFLD		0x119e
+ #define PCI_DEVICE_ID_INTEL_BSW			0x22b7
+ #define PCI_DEVICE_ID_INTEL_SPTLP		0x9d30
+ #define PCI_DEVICE_ID_INTEL_SPTH		0xa130
+ #define PCI_DEVICE_ID_INTEL_BXT			0x0aaa
+ #define PCI_DEVICE_ID_INTEL_BXT_M		0x1aaa
+ #define PCI_DEVICE_ID_INTEL_APL			0x5aaa
+ #define PCI_DEVICE_ID_INTEL_KBP			0xa2b0
++>>>>>>> 4491ed5042f0 (usb: dwc3: pci: add Intel Kabylake PCI ID)
  
 -static const struct acpi_gpio_params reset_gpios = { 0, 0, false };
 -static const struct acpi_gpio_params cs_gpios = { 1, 0, false };
 +/* FIXME define these in <linux/pci_ids.h> */
 +#define PCI_VENDOR_ID_SYNOPSYS		0x16c3
 +#define PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3	0xabcd
 +#define PCI_DEVICE_ID_INTEL_BYT		0x0f37
 +#define PCI_DEVICE_ID_INTEL_MRFLD	0x119e
  
 -static const struct acpi_gpio_mapping acpi_dwc3_byt_gpios[] = {
 -	{ "reset-gpios", &reset_gpios, 1 },
 -	{ "cs-gpios", &cs_gpios, 1 },
 -	{ },
 +struct dwc3_pci {
 +	struct device		*dev;
 +	struct platform_device	*dwc3;
 +	struct platform_device	*usb2_phy;
 +	struct platform_device	*usb3_phy;
  };
  
 -static int dwc3_pci_quirks(struct pci_dev *pdev, struct platform_device *dwc3)
 +static int dwc3_pci_register_phys(struct dwc3_pci *glue)
  {
 -	if (pdev->vendor == PCI_VENDOR_ID_AMD &&
 -	    pdev->device == PCI_DEVICE_ID_AMD_NL_USB) {
 -		struct property_entry properties[] = {
 -			PROPERTY_ENTRY_BOOL("snps,has-lpm-erratum"),
 -			PROPERTY_ENTRY_U8("snps,lpm-nyet-threshold", 0xf),
 -			PROPERTY_ENTRY_BOOL("snps,u2exit_lfps_quirk"),
 -			PROPERTY_ENTRY_BOOL("snps,u2ss_inp3_quirk"),
 -			PROPERTY_ENTRY_BOOL("snps,req_p1p2p3_quirk"),
 -			PROPERTY_ENTRY_BOOL("snps,del_p1p2p3_quirk"),
 -			PROPERTY_ENTRY_BOOL("snps,del_phy_power_chg_quirk"),
 -			PROPERTY_ENTRY_BOOL("snps,lfps_filter_quirk"),
 -			PROPERTY_ENTRY_BOOL("snps,rx_detect_poll_quirk"),
 -			PROPERTY_ENTRY_BOOL("snps,tx_de_emphasis_quirk"),
 -			PROPERTY_ENTRY_U8("snps,tx_de_emphasis", 1),
 -			/*
 -			 * FIXME these quirks should be removed when AMD NL
 -			 * tapes out
 -			 */
 -			PROPERTY_ENTRY_BOOL("snps,disable_scramble_quirk"),
 -			PROPERTY_ENTRY_BOOL("snps,dis_u3_susphy_quirk"),
 -			PROPERTY_ENTRY_BOOL("snps,dis_u2_susphy_quirk"),
 -			{ },
 -		};
 -
 -		return platform_device_add_properties(dwc3, properties);
 -	}
 +	struct nop_usb_xceiv_platform_data pdata;
 +	struct platform_device	*pdev;
 +	int			ret;
  
 -	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
 -		int ret;
 -
 -		struct property_entry properties[] = {
 -			PROPERTY_ENTRY_STRING("dr-mode", "peripheral"),
 -			{ }
 -		};
 -
 -		ret = platform_device_add_properties(dwc3, properties);
 -		if (ret < 0)
 -			return ret;
 -
 -		if (pdev->device == PCI_DEVICE_ID_INTEL_BYT) {
 -			struct gpio_desc *gpio;
 -
 -			acpi_dev_add_driver_gpios(ACPI_COMPANION(&pdev->dev),
 -					acpi_dwc3_byt_gpios);
 -
 -			/*
 -			 * These GPIOs will turn on the USB2 PHY. Note that we have to
 -			 * put the gpio descriptors again here because the phy driver
 -			 * might want to grab them, too.
 -			 */
 -			gpio = gpiod_get_optional(&pdev->dev, "cs", GPIOD_OUT_LOW);
 -			if (IS_ERR(gpio))
 -				return PTR_ERR(gpio);
 -
 -			gpiod_set_value_cansleep(gpio, 1);
 -			gpiod_put(gpio);
 -
 -			gpio = gpiod_get_optional(&pdev->dev, "reset", GPIOD_OUT_LOW);
 -			if (IS_ERR(gpio))
 -				return PTR_ERR(gpio);
 -
 -			if (gpio) {
 -				gpiod_set_value_cansleep(gpio, 1);
 -				gpiod_put(gpio);
 -				usleep_range(10000, 11000);
 -			}
 -		}
 -	}
 +	memset(&pdata, 0x00, sizeof(pdata));
 +
 +	pdev = platform_device_alloc("nop_usb_xceiv", 0);
 +	if (!pdev)
 +		return -ENOMEM;
 +
 +	glue->usb2_phy = pdev;
 +	pdata.type = USB_PHY_TYPE_USB2;
  
 -	if (pdev->vendor == PCI_VENDOR_ID_SYNOPSYS &&
 -	    (pdev->device == PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3 ||
 -	     pdev->device == PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3_AXI ||
 -	     pdev->device == PCI_DEVICE_ID_SYNOPSYS_HAPSUSB31)) {
 -		struct property_entry properties[] = {
 -			PROPERTY_ENTRY_BOOL("snps,usb3_lpm_capable"),
 -			PROPERTY_ENTRY_BOOL("snps,has-lpm-erratum"),
 -			PROPERTY_ENTRY_BOOL("snps,dis_enblslpm_quirk"),
 -			{ },
 -		};
 -
 -		return platform_device_add_properties(dwc3, properties);
 +	ret = platform_device_add_data(glue->usb2_phy, &pdata, sizeof(pdata));
 +	if (ret)
 +		goto err1;
 +
 +	pdev = platform_device_alloc("nop_usb_xceiv", 1);
 +	if (!pdev) {
 +		ret = -ENOMEM;
 +		goto err1;
  	}
  
 +	glue->usb3_phy = pdev;
 +	pdata.type = USB_PHY_TYPE_USB3;
 +
 +	ret = platform_device_add_data(glue->usb3_phy, &pdata, sizeof(pdata));
 +	if (ret)
 +		goto err2;
 +
 +	ret = platform_device_add(glue->usb2_phy);
 +	if (ret)
 +		goto err2;
 +
 +	ret = platform_device_add(glue->usb3_phy);
 +	if (ret)
 +		goto err3;
 +
  	return 0;
 +
 +err3:
 +	platform_device_del(glue->usb2_phy);
 +
 +err2:
 +	platform_device_put(glue->usb3_phy);
 +
 +err1:
 +	platform_device_put(glue->usb2_phy);
 +
 +	return ret;
  }
  
  static int dwc3_pci_probe(struct pci_dev *pci,
@@@ -210,8 -212,24 +225,18 @@@ static const struct pci_device_id dwc3_
  		PCI_DEVICE(PCI_VENDOR_ID_SYNOPSYS,
  				PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3),
  	},
 -	{
 -		PCI_DEVICE(PCI_VENDOR_ID_SYNOPSYS,
 -				PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3_AXI),
 -	},
 -	{
 -		PCI_DEVICE(PCI_VENDOR_ID_SYNOPSYS,
 -				PCI_DEVICE_ID_SYNOPSYS_HAPSUSB31),
 -	},
 -	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_BSW), },
  	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_BYT), },
  	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_MRFLD), },
++<<<<<<< HEAD
++=======
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_SPTLP), },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_SPTH), },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_BXT), },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_BXT_M), },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_APL), },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_KBP), },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_NL_USB), },
++>>>>>>> 4491ed5042f0 (usb: dwc3: pci: add Intel Kabylake PCI ID)
  	{  }	/* Terminating Entry */
  };
  MODULE_DEVICE_TABLE(pci, dwc3_pci_id_table);
* Unmerged path drivers/usb/dwc3/dwc3-pci.c
