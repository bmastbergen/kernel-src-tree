IB/rdamvt: fix cross build with rdmavt

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mike Marciniszyn <mike.marciniszyn@intel.com>
commit 9debaaecb9070c05bbc3b5d2257d6aea416ccab6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9debaaec.failed

The new check routine causes a larger than supported frame size
on s390.

Changing the check routine to noinline fixes the issue.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 9debaaecb9070c05bbc3b5d2257d6aea416ccab6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/sw/rdmavt/vt.c
diff --cc drivers/infiniband/sw/rdmavt/vt.c
index f5cb09b718be,6caf5272ba1f..000000000000
--- a/drivers/infiniband/sw/rdmavt/vt.c
+++ b/drivers/infiniband/sw/rdmavt/vt.c
@@@ -325,12 -325,375 +325,384 @@@ static int rvt_get_port_immutable(struc
  	return 0;
  }
  
++<<<<<<< HEAD
 +/*
 + * Check driver override. If driver passes a value use it, otherwise we use our
 + * own value.
 + */
 +#define CHECK_DRIVER_OVERRIDE(rdi, x) \
 +	rdi->ibdev.x = rdi->ibdev.x ? : rvt_ ##x
++=======
+ enum {
+ 	MISC,
+ 	QUERY_DEVICE,
+ 	MODIFY_DEVICE,
+ 	QUERY_PORT,
+ 	MODIFY_PORT,
+ 	QUERY_PKEY,
+ 	QUERY_GID,
+ 	ALLOC_UCONTEXT,
+ 	DEALLOC_UCONTEXT,
+ 	GET_PORT_IMMUTABLE,
+ 	CREATE_QP,
+ 	MODIFY_QP,
+ 	DESTROY_QP,
+ 	QUERY_QP,
+ 	POST_SEND,
+ 	POST_RECV,
+ 	POST_SRQ_RECV,
+ 	CREATE_AH,
+ 	DESTROY_AH,
+ 	MODIFY_AH,
+ 	QUERY_AH,
+ 	CREATE_SRQ,
+ 	MODIFY_SRQ,
+ 	DESTROY_SRQ,
+ 	QUERY_SRQ,
+ 	ATTACH_MCAST,
+ 	DETACH_MCAST,
+ 	GET_DMA_MR,
+ 	REG_USER_MR,
+ 	DEREG_MR,
+ 	ALLOC_MR,
+ 	ALLOC_FMR,
+ 	MAP_PHYS_FMR,
+ 	UNMAP_FMR,
+ 	DEALLOC_FMR,
+ 	MMAP,
+ 	CREATE_CQ,
+ 	DESTROY_CQ,
+ 	POLL_CQ,
+ 	REQ_NOTFIY_CQ,
+ 	RESIZE_CQ,
+ 	ALLOC_PD,
+ 	DEALLOC_PD,
+ 	_VERB_IDX_MAX /* Must always be last! */
+ };
+ 
+ static inline int check_driver_override(struct rvt_dev_info *rdi,
+ 					size_t offset, void *func)
+ {
+ 	if (!*(void **)((void *)&rdi->ibdev + offset)) {
+ 		*(void **)((void *)&rdi->ibdev + offset) = func;
+ 		return 0;
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ static noinline int check_support(struct rvt_dev_info *rdi, int verb)
+ {
+ 	switch (verb) {
+ 	case MISC:
+ 		/*
+ 		 * These functions are not part of verbs specifically but are
+ 		 * required for rdmavt to function.
+ 		 */
+ 		if ((!rdi->driver_f.port_callback) ||
+ 		    (!rdi->driver_f.get_card_name) ||
+ 		    (!rdi->driver_f.get_pci_dev))
+ 			return -EINVAL;
+ 		break;
+ 
+ 	case QUERY_DEVICE:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    query_device),
+ 						    rvt_query_device);
+ 		break;
+ 
+ 	case MODIFY_DEVICE:
+ 		/*
+ 		 * rdmavt does not support modify device currently drivers must
+ 		 * provide.
+ 		 */
+ 		if (!check_driver_override(rdi, offsetof(struct ib_device,
+ 							 modify_device),
+ 					   rvt_modify_device))
+ 			return -EOPNOTSUPP;
+ 		break;
+ 
+ 	case QUERY_PORT:
+ 		if (!check_driver_override(rdi, offsetof(struct ib_device,
+ 							 query_port),
+ 					   rvt_query_port))
+ 			if (!rdi->driver_f.query_port_state)
+ 				return -EINVAL;
+ 		break;
+ 
+ 	case MODIFY_PORT:
+ 		if (!check_driver_override(rdi, offsetof(struct ib_device,
+ 							 modify_port),
+ 					   rvt_modify_port))
+ 			if (!rdi->driver_f.cap_mask_chg ||
+ 			    !rdi->driver_f.shut_down_port)
+ 				return -EINVAL;
+ 		break;
+ 
+ 	case QUERY_PKEY:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    query_pkey),
+ 				      rvt_query_pkey);
+ 		break;
+ 
+ 	case QUERY_GID:
+ 		if (!check_driver_override(rdi, offsetof(struct ib_device,
+ 							 query_gid),
+ 					   rvt_query_gid))
+ 			if (!rdi->driver_f.get_guid_be)
+ 				return -EINVAL;
+ 		break;
+ 
+ 	case ALLOC_UCONTEXT:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    alloc_ucontext),
+ 				      rvt_alloc_ucontext);
+ 		break;
+ 
+ 	case DEALLOC_UCONTEXT:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    dealloc_ucontext),
+ 				      rvt_dealloc_ucontext);
+ 		break;
+ 
+ 	case GET_PORT_IMMUTABLE:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    get_port_immutable),
+ 				      rvt_get_port_immutable);
+ 		break;
+ 
+ 	case CREATE_QP:
+ 		if (!check_driver_override(rdi, offsetof(struct ib_device,
+ 							 create_qp),
+ 					   rvt_create_qp))
+ 			if (!rdi->driver_f.qp_priv_alloc ||
+ 			    !rdi->driver_f.qp_priv_free ||
+ 			    !rdi->driver_f.notify_qp_reset ||
+ 			    !rdi->driver_f.flush_qp_waiters ||
+ 			    !rdi->driver_f.stop_send_queue ||
+ 			    !rdi->driver_f.quiesce_qp)
+ 				return -EINVAL;
+ 		break;
+ 
+ 	case MODIFY_QP:
+ 		if (!check_driver_override(rdi, offsetof(struct ib_device,
+ 							 modify_qp),
+ 					   rvt_modify_qp))
+ 			if (!rdi->driver_f.notify_qp_reset ||
+ 			    !rdi->driver_f.schedule_send ||
+ 			    !rdi->driver_f.get_pmtu_from_attr ||
+ 			    !rdi->driver_f.flush_qp_waiters ||
+ 			    !rdi->driver_f.stop_send_queue ||
+ 			    !rdi->driver_f.quiesce_qp ||
+ 			    !rdi->driver_f.notify_error_qp ||
+ 			    !rdi->driver_f.mtu_from_qp ||
+ 			    !rdi->driver_f.mtu_to_path_mtu ||
+ 			    !rdi->driver_f.shut_down_port ||
+ 			    !rdi->driver_f.cap_mask_chg)
+ 				return -EINVAL;
+ 		break;
+ 
+ 	case DESTROY_QP:
+ 		if (!check_driver_override(rdi, offsetof(struct ib_device,
+ 							 destroy_qp),
+ 					   rvt_destroy_qp))
+ 			if (!rdi->driver_f.qp_priv_free ||
+ 			    !rdi->driver_f.notify_qp_reset ||
+ 			    !rdi->driver_f.flush_qp_waiters ||
+ 			    !rdi->driver_f.stop_send_queue ||
+ 			    !rdi->driver_f.quiesce_qp)
+ 				return -EINVAL;
+ 		break;
+ 
+ 	case QUERY_QP:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    query_qp),
+ 						    rvt_query_qp);
+ 		break;
+ 
+ 	case POST_SEND:
+ 		if (!check_driver_override(rdi, offsetof(struct ib_device,
+ 							 post_send),
+ 					   rvt_post_send))
+ 			if (!rdi->driver_f.schedule_send ||
+ 			    !rdi->driver_f.do_send)
+ 				return -EINVAL;
+ 		break;
+ 
+ 	case POST_RECV:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    post_recv),
+ 				      rvt_post_recv);
+ 		break;
+ 	case POST_SRQ_RECV:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    post_srq_recv),
+ 				      rvt_post_srq_recv);
+ 		break;
+ 
+ 	case CREATE_AH:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    create_ah),
+ 				      rvt_create_ah);
+ 		break;
+ 
+ 	case DESTROY_AH:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    destroy_ah),
+ 				      rvt_destroy_ah);
+ 		break;
+ 
+ 	case MODIFY_AH:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    modify_ah),
+ 				      rvt_modify_ah);
+ 		break;
+ 
+ 	case QUERY_AH:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    query_ah),
+ 				      rvt_query_ah);
+ 		break;
+ 
+ 	case CREATE_SRQ:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    create_srq),
+ 				      rvt_create_srq);
+ 		break;
+ 
+ 	case MODIFY_SRQ:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    modify_srq),
+ 				      rvt_modify_srq);
+ 		break;
+ 
+ 	case DESTROY_SRQ:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    destroy_srq),
+ 				      rvt_destroy_srq);
+ 		break;
+ 
+ 	case QUERY_SRQ:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    query_srq),
+ 				      rvt_query_srq);
+ 		break;
+ 
+ 	case ATTACH_MCAST:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    attach_mcast),
+ 				      rvt_attach_mcast);
+ 		break;
+ 
+ 	case DETACH_MCAST:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    detach_mcast),
+ 				      rvt_detach_mcast);
+ 		break;
+ 
+ 	case GET_DMA_MR:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    get_dma_mr),
+ 				      rvt_get_dma_mr);
+ 		break;
+ 
+ 	case REG_USER_MR:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    reg_user_mr),
+ 				      rvt_reg_user_mr);
+ 		break;
+ 
+ 	case DEREG_MR:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    dereg_mr),
+ 				      rvt_dereg_mr);
+ 		break;
+ 
+ 	case ALLOC_FMR:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    alloc_fmr),
+ 				      rvt_alloc_fmr);
+ 		break;
+ 
+ 	case ALLOC_MR:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    alloc_mr),
+ 				      rvt_alloc_mr);
+ 		break;
+ 
+ 	case MAP_PHYS_FMR:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    map_phys_fmr),
+ 				      rvt_map_phys_fmr);
+ 		break;
+ 
+ 	case UNMAP_FMR:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    unmap_fmr),
+ 				      rvt_unmap_fmr);
+ 		break;
+ 
+ 	case DEALLOC_FMR:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    dealloc_fmr),
+ 				      rvt_dealloc_fmr);
+ 		break;
+ 
+ 	case MMAP:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    mmap),
+ 				      rvt_mmap);
+ 		break;
+ 
+ 	case CREATE_CQ:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    create_cq),
+ 				      rvt_create_cq);
+ 		break;
+ 
+ 	case DESTROY_CQ:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    destroy_cq),
+ 				      rvt_destroy_cq);
+ 		break;
+ 
+ 	case POLL_CQ:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    poll_cq),
+ 				      rvt_poll_cq);
+ 		break;
+ 
+ 	case REQ_NOTFIY_CQ:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    req_notify_cq),
+ 				      rvt_req_notify_cq);
+ 		break;
+ 
+ 	case RESIZE_CQ:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    resize_cq),
+ 				      rvt_resize_cq);
+ 		break;
+ 
+ 	case ALLOC_PD:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    alloc_pd),
+ 				      rvt_alloc_pd);
+ 		break;
+ 
+ 	case DEALLOC_PD:
+ 		check_driver_override(rdi, offsetof(struct ib_device,
+ 						    dealloc_pd),
+ 				      rvt_dealloc_pd);
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
++>>>>>>> 9debaaecb907 (IB/rdamvt: fix cross build with rdmavt)
  
  /**
   * rvt_register_device - register a driver
* Unmerged path drivers/infiniband/sw/rdmavt/vt.c
