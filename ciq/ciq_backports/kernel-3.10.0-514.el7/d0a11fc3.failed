netfilter: nf_tables: support variable sized data in nft_data_init()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Patrick McHardy <kaber@trash.net>
commit d0a11fc3dc4ab4c717642c9c15c8ad1cbc00d2ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d0a11fc3.failed

Add a size argument to nft_data_init() and pass in the available space.
This will be used by the following patches to support variable sized
set element data.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit d0a11fc3dc4ab4c717642c9c15c8ad1cbc00d2ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
#	net/netfilter/nft_cmp.c
#	net/netfilter/nft_immediate.c
diff --cc net/netfilter/nf_tables_api.c
index 399ca83793bb,2b3f88f4c70f..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -3191,19 -3290,33 +3191,38 @@@ static int nft_add_set_elem(struct nft_
  			return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	err = nft_data_init(ctx, &elem.key, &d1, nla[NFTA_SET_ELEM_KEY]);
++=======
+ 	timeout = 0;
+ 	if (nla[NFTA_SET_ELEM_TIMEOUT] != NULL) {
+ 		if (!(set->flags & NFT_SET_TIMEOUT))
+ 			return -EINVAL;
+ 		timeout = be64_to_cpu(nla_get_be64(nla[NFTA_SET_ELEM_TIMEOUT]));
+ 	} else if (set->flags & NFT_SET_TIMEOUT) {
+ 		timeout = set->timeout;
+ 	}
+ 
+ 	err = nft_data_init(ctx, &elem.key, sizeof(elem.key), &d1,
+ 			    nla[NFTA_SET_ELEM_KEY]);
++>>>>>>> d0a11fc3dc4a (netfilter: nf_tables: support variable sized data in nft_data_init())
  	if (err < 0)
  		goto err1;
  	err = -EINVAL;
  	if (d1.type != NFT_DATA_VALUE || d1.len != set->klen)
  		goto err2;
  
 -	nft_set_ext_add(&tmpl, NFT_SET_EXT_KEY);
 -	if (timeout > 0) {
 -		nft_set_ext_add(&tmpl, NFT_SET_EXT_EXPIRATION);
 -		if (timeout != set->timeout)
 -			nft_set_ext_add(&tmpl, NFT_SET_EXT_TIMEOUT);
 -	}
 +	err = -EEXIST;
 +	if (set->ops->get(set, &elem) == 0)
 +		goto err2;
  
  	if (nla[NFTA_SET_ELEM_DATA] != NULL) {
++<<<<<<< HEAD
 +		err = nft_data_init(ctx, &elem.data, &d2, nla[NFTA_SET_ELEM_DATA]);
++=======
+ 		err = nft_data_init(ctx, &data, sizeof(data), &d2,
+ 				    nla[NFTA_SET_ELEM_DATA]);
++>>>>>>> d0a11fc3dc4a (netfilter: nf_tables: support variable sized data in nft_data_init())
  		if (err < 0)
  			goto err2;
  
diff --cc net/netfilter/nft_cmp.c
index e2b3f51c81f1,e25b35d70e4d..000000000000
--- a/net/netfilter/nft_cmp.c
+++ b/net/netfilter/nft_cmp.c
@@@ -75,12 -75,16 +75,17 @@@ static int nft_cmp_init(const struct nf
  	struct nft_data_desc desc;
  	int err;
  
++<<<<<<< HEAD
 +	priv->sreg = ntohl(nla_get_be32(tb[NFTA_CMP_SREG]));
 +	priv->op = ntohl(nla_get_be32(tb[NFTA_CMP_OP]));
 +
 +	err = nft_data_init(NULL, &priv->data, &desc, tb[NFTA_CMP_DATA]);
++=======
+ 	err = nft_data_init(NULL, &priv->data, sizeof(priv->data), &desc,
+ 			    tb[NFTA_CMP_DATA]);
++>>>>>>> d0a11fc3dc4a (netfilter: nf_tables: support variable sized data in nft_data_init())
  	BUG_ON(err < 0);
  
 -	priv->sreg = nft_parse_register(tb[NFTA_CMP_SREG]);
 -	err = nft_validate_register_load(priv->sreg, desc.len);
 -	if (err < 0)
 -		return err;
 -
 -	priv->op  = ntohl(nla_get_be32(tb[NFTA_CMP_OP]));
  	priv->len = desc.len;
  	return 0;
  }
@@@ -122,13 -126,18 +127,18 @@@ static int nft_cmp_fast_init(const stru
  	u32 mask;
  	int err;
  
++<<<<<<< HEAD
 +	priv->sreg = ntohl(nla_get_be32(tb[NFTA_CMP_SREG]));
 +
 +	err = nft_data_init(NULL, &data, &desc, tb[NFTA_CMP_DATA]);
++=======
+ 	err = nft_data_init(NULL, &data, sizeof(data), &desc,
+ 			    tb[NFTA_CMP_DATA]);
++>>>>>>> d0a11fc3dc4a (netfilter: nf_tables: support variable sized data in nft_data_init())
  	BUG_ON(err < 0);
 -
 -	priv->sreg = nft_parse_register(tb[NFTA_CMP_SREG]);
 -	err = nft_validate_register_load(priv->sreg, desc.len);
 -	if (err < 0)
 -		return err;
 -
  	desc.len *= BITS_PER_BYTE;
 -	mask = nft_cmp_fast_mask(desc.len);
  
 +	mask = nft_cmp_fast_mask(desc.len);
  	priv->data = data.data[0] & mask;
  	priv->len  = desc.len;
  	return 0;
diff --cc net/netfilter/nft_immediate.c
index 810385eb7249,db3b746858e3..000000000000
--- a/net/netfilter/nft_immediate.c
+++ b/net/netfilter/nft_immediate.c
@@@ -49,12 -49,8 +49,17 @@@ static int nft_immediate_init(const str
  	    tb[NFTA_IMMEDIATE_DATA] == NULL)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	priv->dreg = ntohl(nla_get_be32(tb[NFTA_IMMEDIATE_DREG]));
 +	err = nft_validate_output_register(priv->dreg);
 +	if (err < 0)
 +		return err;
 +
 +	err = nft_data_init(ctx, &priv->data, &desc, tb[NFTA_IMMEDIATE_DATA]);
++=======
+ 	err = nft_data_init(ctx, &priv->data, sizeof(priv->data), &desc,
+ 			    tb[NFTA_IMMEDIATE_DATA]);
++>>>>>>> d0a11fc3dc4a (netfilter: nf_tables: support variable sized data in nft_data_init())
  	if (err < 0)
  		return err;
  	priv->dlen = desc.len;
diff --git a/include/net/netfilter/nf_tables.h b/include/net/netfilter/nf_tables.h
index 4ab50d820db0..dc1f20a34ae9 100644
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -96,7 +96,8 @@ struct nft_data_desc {
 	unsigned int			len;
 };
 
-int nft_data_init(const struct nft_ctx *ctx, struct nft_data *data,
+int nft_data_init(const struct nft_ctx *ctx,
+		  struct nft_data *data, unsigned int size,
 		  struct nft_data_desc *desc, const struct nlattr *nla);
 void nft_data_uninit(const struct nft_data *data, enum nft_data_types type);
 int nft_data_dump(struct sk_buff *skb, int attr, const struct nft_data *data,
* Unmerged path net/netfilter/nf_tables_api.c
diff --git a/net/netfilter/nft_bitwise.c b/net/netfilter/nft_bitwise.c
index 4fb6ee2c1106..c0776ea84faf 100644
--- a/net/netfilter/nft_bitwise.c
+++ b/net/netfilter/nft_bitwise.c
@@ -78,13 +78,15 @@ static int nft_bitwise_init(const struct nft_ctx *ctx,
 
 	priv->len = ntohl(nla_get_be32(tb[NFTA_BITWISE_LEN]));
 
-	err = nft_data_init(NULL, &priv->mask, &d1, tb[NFTA_BITWISE_MASK]);
+	err = nft_data_init(NULL, &priv->mask, sizeof(priv->mask), &d1,
+			    tb[NFTA_BITWISE_MASK]);
 	if (err < 0)
 		return err;
 	if (d1.len != priv->len)
 		return -EINVAL;
 
-	err = nft_data_init(NULL, &priv->xor, &d2, tb[NFTA_BITWISE_XOR]);
+	err = nft_data_init(NULL, &priv->xor, sizeof(priv->xor), &d2,
+			    tb[NFTA_BITWISE_XOR]);
 	if (err < 0)
 		return err;
 	if (d2.len != priv->len)
* Unmerged path net/netfilter/nft_cmp.c
* Unmerged path net/netfilter/nft_immediate.c
