nfs/blocklayout: refactor open-by-wwn

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit d702d41ed41328487bd3b270467721222f8036e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d702d41e.failed

The current code works with the standard udev/systemd names, but we'll have
to add another method in the next patch.  Refactor it into a separate helper
to make room for the new variant.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit d702d41ed41328487bd3b270467721222f8036e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/blocklayout/dev.c
diff --cc fs/nfs/blocklayout/dev.c
index a861bbdfe577,ea70883a174a..000000000000
--- a/fs/nfs/blocklayout/dev.c
+++ b/fs/nfs/blocklayout/dev.c
@@@ -216,6 -246,117 +216,120 @@@ bl_parse_simple(struct nfs_server *serv
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static bool
+ bl_validate_designator(struct pnfs_block_volume *v)
+ {
+ 	switch (v->scsi.designator_type) {
+ 	case PS_DESIGNATOR_EUI64:
+ 		if (v->scsi.code_set != PS_CODE_SET_BINARY)
+ 			return false;
+ 
+ 		if (v->scsi.designator_len != 8 &&
+ 		    v->scsi.designator_len != 10 &&
+ 		    v->scsi.designator_len != 16)
+ 			return false;
+ 
+ 		return true;
+ 	case PS_DESIGNATOR_NAA:
+ 		if (v->scsi.code_set != PS_CODE_SET_BINARY)
+ 			return false;
+ 
+ 		if (v->scsi.designator_len != 8 &&
+ 		    v->scsi.designator_len != 16)
+ 			return false;
+ 
+ 		return true;
+ 	case PS_DESIGNATOR_T10:
+ 	case PS_DESIGNATOR_NAME:
+ 		pr_err("pNFS: unsupported designator "
+ 			"(code set %d, type %d, len %d.\n",
+ 			v->scsi.code_set,
+ 			v->scsi.designator_type,
+ 			v->scsi.designator_len);
+ 		return false;
+ 	default:
+ 		pr_err("pNFS: invalid designator "
+ 			"(code set %d, type %d, len %d.\n",
+ 			v->scsi.code_set,
+ 			v->scsi.designator_type,
+ 			v->scsi.designator_len);
+ 		return false;
+ 	}
+ }
+ 
+ /*
+  * Try to open the udev path for the WWN.  At least on Debian the udev
+  * by-id path will always point to the dm-multipath device if one exists.
+  */
+ static struct block_device *
+ bl_open_udev_path(struct pnfs_block_volume *v)
+ {
+ 	struct block_device *bdev;
+ 	const char *devname;
+ 
+ 	devname = kasprintf(GFP_KERNEL, "/dev/disk/by-id/wwn-0x%*phN",
+ 				v->scsi.designator_len, v->scsi.designator);
+ 	if (!devname)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	bdev = blkdev_get_by_path(devname, FMODE_READ | FMODE_WRITE, NULL);
+ 	if (IS_ERR(bdev)) {
+ 		pr_warn("pNFS: failed to open device %s (%ld)\n",
+ 			devname, PTR_ERR(bdev));
+ 	}
+ 
+ 	kfree(devname);
+ 	return bdev;
+ }
+ 
+ static int
+ bl_parse_scsi(struct nfs_server *server, struct pnfs_block_dev *d,
+ 		struct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)
+ {
+ 	struct pnfs_block_volume *v = &volumes[idx];
+ 	const struct pr_ops *ops;
+ 	int error;
+ 
+ 	if (!bl_validate_designator(v))
+ 		return -EINVAL;
+ 
+ 	d->bdev = bl_open_udev_path(v);
+ 	if (IS_ERR(d->bdev))
+ 		return PTR_ERR(d->bdev);
+ 
+ 	d->len = i_size_read(d->bdev->bd_inode);
+ 	d->map = bl_map_simple;
+ 	d->pr_key = v->scsi.pr_key;
+ 
+ 	pr_info("pNFS: using block device %s (reservation key 0x%llx)\n",
+ 		d->bdev->bd_disk->disk_name, d->pr_key);
+ 
+ 	ops = d->bdev->bd_disk->fops->pr_ops;
+ 	if (!ops) {
+ 		pr_err("pNFS: block device %s does not support reservations.",
+ 				d->bdev->bd_disk->disk_name);
+ 		error = -EINVAL;
+ 		goto out_blkdev_put;
+ 	}
+ 
+ 	error = ops->pr_register(d->bdev, 0, d->pr_key, true);
+ 	if (error) {
+ 		pr_err("pNFS: failed to register key for block device %s.",
+ 				d->bdev->bd_disk->disk_name);
+ 		goto out_blkdev_put;
+ 	}
+ 
+ 	d->pr_registered = true;
+ 	return 0;
+ 
+ out_blkdev_put:
+ 	blkdev_put(d->bdev, FMODE_READ | FMODE_WRITE);
+ 	return error;
+ }
+ 
++>>>>>>> d702d41ed413 (nfs/blocklayout: refactor open-by-wwn)
  static int
  bl_parse_slice(struct nfs_server *server, struct pnfs_block_dev *d,
  		struct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)
* Unmerged path fs/nfs/blocklayout/dev.c
