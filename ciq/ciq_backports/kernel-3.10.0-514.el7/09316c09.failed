mm/balloon_compaction: add vmstat counters and kpageflags bit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mm] balloon_compaction: add vmstat counters and kpageflags bit (Luiz Capitulino) [1263649]
Rebuild_FUZZ: 97.48%
commit-author Konstantin Khlebnikov <k.khlebnikov@samsung.com>
commit 09316c09dde33aae14f34489d9e3d243ec0d5938
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/09316c09.failed

Always mark pages with PageBalloon even if balloon compaction is disabled
and expose this mark in /proc/kpageflags as KPF_BALLOON.

Also this patch adds three counters into /proc/vmstat: "balloon_inflate",
"balloon_deflate" and "balloon_migrate".  They accumulate balloon
activity.  Current size of balloon is (balloon_inflate - balloon_deflate)
pages.

All generic balloon code now gathered under option CONFIG_MEMORY_BALLOON.
It should be selected by ballooning driver which wants use this feature.
Currently virtio-balloon is the only user.

	Signed-off-by: Konstantin Khlebnikov <k.khlebnikov@samsung.com>
	Cc: Rafael Aquini <aquini@redhat.com>
	Cc: Andrey Ryabinin <ryabinin.a.a@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 09316c09dde33aae14f34489d9e3d243ec0d5938)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/balloon_compaction.h
#	include/linux/vm_event_item.h
#	mm/Makefile
#	mm/balloon_compaction.c
#	mm/vmstat.c
diff --cc include/linux/balloon_compaction.h
index 089743ade734,9b0a15d06a4f..000000000000
--- a/include/linux/balloon_compaction.h
+++ b/include/linux/balloon_compaction.h
@@@ -228,29 -161,13 +228,34 @@@ static inline gfp_t balloon_mapping_gfp
  	return GFP_HIGHUSER_MOVABLE;
  }
  
 +static inline bool balloon_compaction_check(void)
 +{
 +	return true;
 +}
 +
  #else /* !CONFIG_BALLOON_COMPACTION */
  
 -static inline void balloon_page_insert(struct balloon_dev_info *balloon,
 -				       struct page *page)
 +static inline void *balloon_mapping_alloc(void *balloon_device,
 +				const struct address_space_operations *a_ops)
 +{
++<<<<<<< HEAD
 +	return ERR_PTR(-EOPNOTSUPP);
 +}
 +
 +static inline void balloon_mapping_free(struct address_space *balloon_mapping)
 +{
 +	return;
 +}
 +
 +static inline void balloon_page_insert(struct page *page,
 +				       struct address_space *mapping,
 +				       struct list_head *head)
  {
 +	list_add(&page->lru, head);
++=======
+ 	__SetPageBalloon(page);
+ 	list_add(&page->lru, &balloon->pages);
++>>>>>>> 09316c09dde3 (mm/balloon_compaction: add vmstat counters and kpageflags bit)
  }
  
  static inline void balloon_page_delete(struct page *page)
diff --cc include/linux/vm_event_item.h
index de4e34d72311,730334cdf037..000000000000
--- a/include/linux/vm_event_item.h
+++ b/include/linux/vm_event_item.h
@@@ -72,6 -72,25 +72,28 @@@ enum vm_event_item { PGPGIN, PGPGOUT, P
  		THP_ZERO_PAGE_ALLOC,
  		THP_ZERO_PAGE_ALLOC_FAILED,
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_MEMORY_BALLOON
+ 		BALLOON_INFLATE,
+ 		BALLOON_DEFLATE,
+ #ifdef CONFIG_BALLOON_COMPACTION
+ 		BALLOON_MIGRATE,
+ #endif
+ #endif
+ #ifdef CONFIG_DEBUG_TLBFLUSH
+ #ifdef CONFIG_SMP
+ 		NR_TLB_REMOTE_FLUSH,	/* cpu tried to flush others' tlbs */
+ 		NR_TLB_REMOTE_FLUSH_RECEIVED,/* cpu received ipi for flush */
+ #endif /* CONFIG_SMP */
+ 		NR_TLB_LOCAL_FLUSH_ALL,
+ 		NR_TLB_LOCAL_FLUSH_ONE,
+ #endif /* CONFIG_DEBUG_TLBFLUSH */
+ #ifdef CONFIG_DEBUG_VM_VMACACHE
+ 		VMACACHE_FIND_CALLS,
+ 		VMACACHE_FIND_HITS,
+ #endif
++>>>>>>> 09316c09dde3 (mm/balloon_compaction: add vmstat counters and kpageflags bit)
  		NR_VM_EVENT_ITEMS
  };
  
diff --cc mm/Makefile
index 19d2b6ae108d,1f534a7f0a71..000000000000
--- a/mm/Makefile
+++ b/mm/Makefile
@@@ -16,8 -16,9 +16,14 @@@ obj-y			:= filemap.o mempool.o oom_kill
  			   readahead.o swap.o truncate.o vmscan.o shmem.o \
  			   util.o mmzone.o vmstat.o backing-dev.o \
  			   mm_init.o mmu_context.o percpu.o slab_common.o \
++<<<<<<< HEAD
 +			   compaction.o balloon_compaction.o \
 +			   interval_tree.o list_lru.o workingset.o $(mmu-y)
++=======
+ 			   compaction.o vmacache.o \
+ 			   interval_tree.o list_lru.o workingset.o \
+ 			   iov_iter.o debug.o $(mmu-y)
++>>>>>>> 09316c09dde3 (mm/balloon_compaction: add vmstat counters and kpageflags bit)
  
  obj-y += init-mm.o
  
@@@ -62,4 -65,6 +68,10 @@@ obj-$(CONFIG_MEMORY_ISOLATION) += page_
  obj-$(CONFIG_ZPOOL)	+= zpool.o
  obj-$(CONFIG_ZBUD)	+= zbud.o
  obj-$(CONFIG_ZSMALLOC)	+= zsmalloc.o
++<<<<<<< HEAD
 +obj-$(CONFIG_USERFAULTFD) += userfaultfd.o
++=======
+ obj-$(CONFIG_GENERIC_EARLY_IOREMAP) += early_ioremap.o
+ obj-$(CONFIG_CMA)	+= cma.o
+ obj-$(CONFIG_MEMORY_BALLOON) += balloon_compaction.o
++>>>>>>> 09316c09dde3 (mm/balloon_compaction: add vmstat counters and kpageflags bit)
diff --cc mm/balloon_compaction.c
index 6e45a5074bf0,b3cbe19f71b5..000000000000
--- a/mm/balloon_compaction.c
+++ b/mm/balloon_compaction.c
@@@ -61,7 -35,8 +61,12 @@@ struct page *balloon_page_enqueue(struc
  	 */
  	BUG_ON(!trylock_page(page));
  	spin_lock_irqsave(&b_dev_info->pages_lock, flags);
++<<<<<<< HEAD
 +	balloon_page_insert(page, b_dev_info->mapping, &b_dev_info->pages);
++=======
+ 	balloon_page_insert(b_dev_info, page);
+ 	__count_vm_event(BALLOON_INFLATE);
++>>>>>>> 09316c09dde3 (mm/balloon_compaction: add vmstat counters and kpageflags bit)
  	spin_unlock_irqrestore(&b_dev_info->pages_lock, flags);
  	unlock_page(page);
  	return page;
@@@ -93,18 -68,14 +98,19 @@@ struct page *balloon_page_dequeue(struc
  		 * to be released by the balloon driver.
  		 */
  		if (trylock_page(page)) {
 -			if (!PagePrivate(page)) {
 -				/* raced with isolation */
 -				unlock_page(page);
 -				continue;
 -			}
  			spin_lock_irqsave(&b_dev_info->pages_lock, flags);
 +			/*
 +			 * Raise the page refcount here to prevent any wrong
 +			 * attempt to isolate this page, in case of coliding
 +			 * with balloon_page_isolate() just after we release
 +			 * the page lock.
 +			 *
 +			 * balloon_page_free() will take care of dropping
 +			 * this extra refcount later.
 +			 */
 +			get_page(page);
  			balloon_page_delete(page);
+ 			__count_vm_event(BALLOON_DEFLATE);
  			spin_unlock_irqrestore(&b_dev_info->pages_lock, flags);
  			unlock_page(page);
  			dequeued_page = true;
diff --cc mm/vmstat.c
index f08f371beef8,cce7c766da7a..000000000000
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@@ -870,7 -863,26 +873,25 @@@ const char * const vmstat_text[] = 
  	"thp_zero_page_alloc",
  	"thp_zero_page_alloc_failed",
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_MEMORY_BALLOON
+ 	"balloon_inflate",
+ 	"balloon_deflate",
+ #ifdef CONFIG_BALLOON_COMPACTION
+ 	"balloon_migrate",
+ #endif
+ #endif /* CONFIG_MEMORY_BALLOON */
+ #ifdef CONFIG_DEBUG_TLBFLUSH
+ #ifdef CONFIG_SMP
+ 	"nr_tlb_remote_flush",
+ 	"nr_tlb_remote_flush_received",
+ #endif /* CONFIG_SMP */
+ 	"nr_tlb_local_flush_all",
+ 	"nr_tlb_local_flush_one",
+ #endif /* CONFIG_DEBUG_TLBFLUSH */
++>>>>>>> 09316c09dde3 (mm/balloon_compaction: add vmstat counters and kpageflags bit)
  
 -#ifdef CONFIG_DEBUG_VM_VMACACHE
 -	"vmacache_find_calls",
 -	"vmacache_find_hits",
 -#endif
  #endif /* CONFIG_VM_EVENTS_COUNTERS */
  };
  #endif /* CONFIG_PROC_FS || CONFIG_SYSFS || CONFIG_NUMA */
diff --git a/drivers/virtio/Kconfig b/drivers/virtio/Kconfig
index 1729a2adbe9c..cab9f3f63a38 100644
--- a/drivers/virtio/Kconfig
+++ b/drivers/virtio/Kconfig
@@ -41,6 +41,7 @@ config VIRTIO_PCI_LEGACY
 config VIRTIO_BALLOON
 	tristate "Virtio balloon driver"
 	depends on VIRTIO
+	select MEMORY_BALLOON
 	---help---
 	 This driver supports increasing and decreasing the amount
 	 of memory within a KVM guest.
diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c
index f4f518c36eab..591cc332f2de 100644
--- a/drivers/virtio/virtio_balloon.c
+++ b/drivers/virtio/virtio_balloon.c
@@ -406,6 +406,7 @@ static int virtballoon_migratepage(struct address_space *mapping,
 	spin_lock_irqsave(&vb_dev_info->pages_lock, flags);
 	balloon_page_insert(newpage, mapping, &vb_dev_info->pages);
 	vb_dev_info->isolated_pages--;
+	__count_vm_event(BALLOON_MIGRATE);
 	spin_unlock_irqrestore(&vb_dev_info->pages_lock, flags);
 	vb->num_pfns = VIRTIO_BALLOON_PAGES_PER_PAGE;
 	set_page_pfns(vb->pfns, newpage);
diff --git a/fs/proc/page.c b/fs/proc/page.c
index 54e111e436a5..4bb8e0142f7a 100644
--- a/fs/proc/page.c
+++ b/fs/proc/page.c
@@ -133,6 +133,9 @@ u64 stable_page_flags(struct page *page)
 	if (PageBuddy(page))
 		u |= 1 << KPF_BUDDY;
 
+	if (PageBalloon(page))
+		u |= 1 << KPF_BALLOON;
+
 	u |= kpf_copy_bit(k, KPF_LOCKED,	PG_locked);
 
 	u |= kpf_copy_bit(k, KPF_SLAB,		PG_slab);
* Unmerged path include/linux/balloon_compaction.h
* Unmerged path include/linux/vm_event_item.h
diff --git a/include/uapi/linux/kernel-page-flags.h b/include/uapi/linux/kernel-page-flags.h
index 5116a0e48172..2f96d233c980 100644
--- a/include/uapi/linux/kernel-page-flags.h
+++ b/include/uapi/linux/kernel-page-flags.h
@@ -31,6 +31,7 @@
 
 #define KPF_KSM			21
 #define KPF_THP			22
+#define KPF_BALLOON		23
 
 
 #endif /* _UAPILINUX_KERNEL_PAGE_FLAGS_H */
diff --git a/mm/Kconfig b/mm/Kconfig
index 88ac087b6ee9..4646188809b1 100644
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@ -223,12 +223,17 @@ config SPLIT_PTLOCK_CPUS
 config ARCH_ENABLE_SPLIT_PMD_PTLOCK
 	boolean
 
+#
+# support for memory balloon
+config MEMORY_BALLOON
+	boolean
+
 #
 # support for memory balloon compaction
 config BALLOON_COMPACTION
 	bool "Allow for balloon memory compaction/migration"
 	def_bool y
-	depends on COMPACTION && VIRTIO_BALLOON
+	depends on COMPACTION && MEMORY_BALLOON
 	help
 	  Memory fragmentation introduced by ballooning might reduce
 	  significantly the number of 2MB contiguous memory blocks that can be
* Unmerged path mm/Makefile
* Unmerged path mm/balloon_compaction.c
* Unmerged path mm/vmstat.c
diff --git a/tools/vm/page-types.c b/tools/vm/page-types.c
index 9c1892348362..d2af0ceca03c 100644
--- a/tools/vm/page-types.c
+++ b/tools/vm/page-types.c
@@ -123,6 +123,7 @@ static const char * const page_flag_names[] = {
 	[KPF_NOPAGE]		= "n:nopage",
 	[KPF_KSM]		= "x:ksm",
 	[KPF_THP]		= "t:thp",
+	[KPF_BALLOON]		= "o:balloon",
 
 	[KPF_RESERVED]		= "r:reserved",
 	[KPF_MLOCKED]		= "m:mlocked",
