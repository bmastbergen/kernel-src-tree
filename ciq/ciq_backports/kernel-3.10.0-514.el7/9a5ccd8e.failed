asix: Simplify asix_rx_fixup_internal() netdev alloc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dean Jenkins <Dean_Jenkins@mentor.com>
commit 9a5ccd8e039eef53336e45d01c7d8a1acbd36b47
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/9a5ccd8e.failed

The code is checking that the Ethernet frame will fit into a
netdev allocated socket buffer within the constraints of MTU size,
Ethernet header length plus VLAN header length.

The original code was checking rx->remaining each loop of the while
loop that processes multiple Ethernet frames per URB and/or Ethernet
frames that span across URBs. rx->remaining decreases per while loop
so there is no point in potentially checking multiple times that the
Ethernet frame (remaining part) will fit into the netdev socket buffer.

The modification checks that the size of the Ethernet frame will fit
the netdev socket buffer before allocating the netdev socket buffer.
This avoids grabbing memory and then deciding that the Ethernet frame
is too big and then freeing the memory.

	Signed-off-by: Dean Jenkins <Dean_Jenkins@mentor.com>
	Signed-off-by: Mark Craske <Mark_Craske@mentor.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9a5ccd8e039eef53336e45d01c7d8a1acbd36b47)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/asix_common.c
diff --cc drivers/net/usb/asix_common.c
index 99bf5d9050e8,6a8eddfea229..000000000000
--- a/drivers/net/usb/asix_common.c
+++ b/drivers/net/usb/asix_common.c
@@@ -81,44 -80,40 +81,58 @@@ int asix_rx_fixup_internal(struct usbne
  				offset += sizeof(u32);
  			}
  
 -			/* take frame length from Data header 32-bit word */
 -			size = (u16)(rx->header & 0x7ff);
 -			if (size != ((~rx->header >> 16) & 0x7ff)) {
 +			/* get the packet length */
 +			rx->size = (u16) (rx->header & 0x7ff);
 +			if (rx->size != ((~rx->header >> 16) & 0x7ff)) {
  				netdev_err(dev->net, "asix_rx_fixup() Bad Header Length 0x%x, offset %d\n",
  					   rx->header, offset);
 +				rx->size = 0;
 +				return 0;
 +			}
++<<<<<<< HEAD
 +			rx->ax_skb = netdev_alloc_skb_ip_align(dev->net,
 +							       rx->size);
 +			if (!rx->ax_skb) {
 +				rx->size = 0;
  				return 0;
  			}
 +		}
 +
 +		if (rx->size > dev->net->mtu + ETH_HLEN + VLAN_HLEN) {
 +			netdev_err(dev->net, "asix_rx_fixup() Bad RX Length %d\n",
 +				   rx->size);
 +			kfree_skb(rx->ax_skb);
 +			rx->ax_skb = NULL;
 +			rx->size = 0U;
 +
 +			return 0;
++=======
+ 			if (size > dev->net->mtu + ETH_HLEN + VLAN_HLEN) {
+ 				netdev_err(dev->net, "asix_rx_fixup() Bad RX Length %d\n",
+ 					   size);
+ 				return 0;
+ 			}
+ 
+ 			rx->ax_skb = netdev_alloc_skb_ip_align(dev->net, size);
+ 			if (!rx->ax_skb)
+ 				return 0;
+ 
+ 			rx->remaining = size;
++>>>>>>> 9a5ccd8e039e (asix: Simplify asix_rx_fixup_internal() netdev alloc)
  		}
  
 -		if (rx->remaining > skb->len - offset) {
 -			copy_length = skb->len - offset;
 -			rx->remaining -= copy_length;
 -		} else {
 -			copy_length = rx->remaining;
 -			rx->remaining = 0;
 +		if (rx->size > skb->len - offset) {
 +			remaining = rx->size - (skb->len - offset);
 +			rx->size = skb->len - offset;
  		}
  
 -		data = skb_put(rx->ax_skb, copy_length);
 -		memcpy(data, skb->data + offset, copy_length);
 -		if (!rx->remaining)
 +		data = skb_put(rx->ax_skb, rx->size);
 +		memcpy(data, skb->data + offset, rx->size);
 +		if (!remaining)
  			usbnet_skb_return(dev, rx->ax_skb);
  
 -		offset += (copy_length + 1) & 0xfffe;
 +		offset += (rx->size + 1) & 0xfffe;
 +		rx->size = remaining;
  	}
  
  	if (skb->len != offset) {
* Unmerged path drivers/net/usb/asix_common.c
