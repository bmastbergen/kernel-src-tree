bridge: Save frag_max_size between PRE_ROUTING and POST_ROUTING

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit 93fdd47e52f3f869a437319db9da1ea409acc07e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/93fdd47e.failed

As we may defragment the packet in IPv4 PRE_ROUTING and refragment
it after POST_ROUTING we should save the value of frag_max_size.

This is still very wrong as the bridge is supposed to leave the
packets intact, meaning that the right thing to do is to use the
original frag_list for fragmentation.

Unfortunately we don't currently guarantee that the frag_list is
left untouched throughout netfilter so until this changes this is
the best we can do.

There is also a spot in FORWARD where it appears that we can
forward a packet without going through fragmentation, mark it
so that we can fix it later.

	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 93fdd47e52f3f869a437319db9da1ea409acc07e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_netfilter.c
#	net/bridge/br_private.h
diff --cc net/bridge/br_netfilter.c
index 0881e25f4ca4,4063898cf8aa..000000000000
--- a/net/bridge/br_netfilter.c
+++ b/net/bridge/br_netfilter.c
@@@ -836,20 -864,26 +841,34 @@@ static unsigned int br_nf_forward_arp(c
  	return NF_STOLEN;
  }
  
 -#if IS_ENABLED(CONFIG_NF_DEFRAG_IPV4)
 -static int br_nf_dev_queue_xmit(struct sk_buff *skb)
 +#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV4)
 +static int br_nf_dev_queue_xmit(struct sock *sk, struct sk_buff *skb)
  {
  	int ret;
+ 	int frag_max_size;
  
++<<<<<<< HEAD
 +	if (skb->nfct != NULL && skb->protocol == htons(ETH_P_IP) &&
++=======
+ 	/* This is wrong! We should preserve the original fragment
+ 	 * boundaries by preserving frag_list rather than refragmenting.
+ 	 */
+ 	if (skb->protocol == htons(ETH_P_IP) &&
++>>>>>>> 93fdd47e52f3 (bridge: Save frag_max_size between PRE_ROUTING and POST_ROUTING)
  	    skb->len + nf_bridge_mtu_reduction(skb) > skb->dev->mtu &&
  	    !skb_is_gso(skb)) {
+ 		frag_max_size = BR_INPUT_SKB_CB(skb)->frag_max_size;
  		if (br_parse_ip_options(skb))
  			/* Drop invalid packet */
  			return NF_DROP;
++<<<<<<< HEAD
 +		ret = ip_fragment(sk, skb, br_dev_queue_push_xmit);
++=======
+ 		IPCB(skb)->frag_max_size = frag_max_size;
+ 		ret = ip_fragment(skb, br_dev_queue_push_xmit);
++>>>>>>> 93fdd47e52f3 (bridge: Save frag_max_size between PRE_ROUTING and POST_ROUTING)
  	} else
 -		ret = br_dev_queue_push_xmit(skb);
 +		ret = br_dev_queue_push_xmit(sk, skb);
  
  	return ret;
  }
diff --cc net/bridge/br_private.h
index 42f63e0bc8cf,2398369c6dda..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -288,6 -310,12 +289,15 @@@ struct br_input_skb_cb 
  	int igmp;
  	int mrouters_only;
  #endif
++<<<<<<< HEAD
++=======
+ 
+ 	u16 frag_max_size;
+ 
+ #ifdef CONFIG_BRIDGE_VLAN_FILTERING
+ 	bool vlan_filtered;
+ #endif
++>>>>>>> 93fdd47e52f3 (bridge: Save frag_max_size between PRE_ROUTING and POST_ROUTING)
  };
  
  #define BR_INPUT_SKB_CB(__skb)	((struct br_input_skb_cb *)(__skb)->cb)
* Unmerged path net/bridge/br_netfilter.c
* Unmerged path net/bridge/br_private.h
