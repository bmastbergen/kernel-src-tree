device property: Adding DMA Attribute APIs for Generic Devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Suthikulpanit, Suravee <Suravee.Suthikulpanit@amd.com>
commit e5e558644bbb23cad03c586703331b8bcd9e0e6c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e5e55864.failed

The function device_dma_is_coherent() does not sufficiently
communicate device DMA attributes. Instead, this patch introduces
device_get_dma_attr(), which returns enum dev_dma_attr.
It replaces the acpi_check_dma(), which will be removed in
subsequent patch.

This also provides a convenient function, device_dma_supported(),
to check DMA support of the specified device.

	Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
	Acked-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit e5e558644bbb23cad03c586703331b8bcd9e0e6c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/property.c
#	include/linux/property.h
diff --cc drivers/base/property.c
index 6a94ef6e83c9,05d57a2afa05..000000000000
--- a/drivers/base/property.c
+++ b/drivers/base/property.c
@@@ -177,9 -283,437 +177,443 @@@ EXPORT_SYMBOL_GPL(device_property_read_
  int device_property_read_string(struct device *dev, const char *propname,
  				const char **val)
  {
 -	return fwnode_property_read_string(dev_fwnode(dev), propname, val);
 +	return IS_ENABLED(CONFIG_OF) && dev->of_node ?
 +		of_property_read_string(dev->of_node, propname, val) :
 +		acpi_dev_prop_read(ACPI_COMPANION(dev), propname,
 +				   DEV_PROP_STRING, val, 1);
  }
  EXPORT_SYMBOL_GPL(device_property_read_string);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * device_property_match_string - find a string in an array and return index
+  * @dev: Device to get the property of
+  * @propname: Name of the property holding the array
+  * @string: String to look for
+  *
+  * Find a given string in a string array and if it is found return the
+  * index back.
+  *
+  * Return: %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of strings,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int device_property_match_string(struct device *dev, const char *propname,
+ 				 const char *string)
+ {
+ 	return fwnode_property_match_string(dev_fwnode(dev), propname, string);
+ }
+ EXPORT_SYMBOL_GPL(device_property_match_string);
+ 
+ #define OF_DEV_PROP_READ_ARRAY(node, propname, type, val, nval) \
+ 	(val) ? of_property_read_##type##_array((node), (propname), (val), (nval)) \
+ 	      : of_property_count_elems_of_size((node), (propname), sizeof(type))
+ 
+ #define FWNODE_PROP_READ_ARRAY(_fwnode_, _propname_, _type_, _proptype_, _val_, _nval_) \
+ ({ \
+ 	int _ret_; \
+ 	if (is_of_node(_fwnode_)) \
+ 		_ret_ = OF_DEV_PROP_READ_ARRAY(to_of_node(_fwnode_), _propname_, \
+ 					       _type_, _val_, _nval_); \
+ 	else if (is_acpi_node(_fwnode_)) \
+ 		_ret_ = acpi_node_prop_read(_fwnode_, _propname_, _proptype_, \
+ 					    _val_, _nval_); \
+ 	else if (is_pset(_fwnode_)) \
+ 		_ret_ = pset_prop_read_array(to_pset(_fwnode_), _propname_, \
+ 					     _proptype_, _val_, _nval_); \
+ 	else \
+ 		_ret_ = -ENXIO; \
+ 	_ret_; \
+ })
+ 
+ /**
+  * fwnode_property_read_u8_array - return a u8 array property of firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u8 properties with @propname from @fwnode and stores them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u8_array(struct fwnode_handle *fwnode,
+ 				  const char *propname, u8 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u8, DEV_PROP_U8,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u8_array);
+ 
+ /**
+  * fwnode_property_read_u16_array - return a u16 array property of firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u16 properties with @propname from @fwnode and store them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u16_array(struct fwnode_handle *fwnode,
+ 				   const char *propname, u16 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u16, DEV_PROP_U16,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u16_array);
+ 
+ /**
+  * fwnode_property_read_u32_array - return a u32 array property of firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u32 properties with @propname from @fwnode store them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u32_array(struct fwnode_handle *fwnode,
+ 				   const char *propname, u32 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u32, DEV_PROP_U32,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u32_array);
+ 
+ /**
+  * fwnode_property_read_u64_array - return a u64 array property firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an array of u64 properties with @propname from @fwnode and store them to
+  * @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of numbers,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_u64_array(struct fwnode_handle *fwnode,
+ 				   const char *propname, u64 *val, size_t nval)
+ {
+ 	return FWNODE_PROP_READ_ARRAY(fwnode, propname, u64, DEV_PROP_U64,
+ 				      val, nval);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_u64_array);
+ 
+ /**
+  * fwnode_property_read_string_array - return string array property of a node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The values are stored here or %NULL to return the number of values
+  * @nval: Size of the @val array
+  *
+  * Read an string list property @propname from the given firmware node and store
+  * them to @val if found.
+  *
+  * Return: number of values if @val was %NULL,
+  *         %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of strings,
+  *	   %-EOVERFLOW if the size of the property is not as expected,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_string_array(struct fwnode_handle *fwnode,
+ 				      const char *propname, const char **val,
+ 				      size_t nval)
+ {
+ 	if (is_of_node(fwnode))
+ 		return val ?
+ 			of_property_read_string_array(to_of_node(fwnode),
+ 						      propname, val, nval) :
+ 			of_property_count_strings(to_of_node(fwnode), propname);
+ 	else if (is_acpi_node(fwnode))
+ 		return acpi_node_prop_read(fwnode, propname, DEV_PROP_STRING,
+ 					   val, nval);
+ 	else if (is_pset(fwnode))
+ 		return pset_prop_read_array(to_pset(fwnode), propname,
+ 					    DEV_PROP_STRING, val, nval);
+ 	return -ENXIO;
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_string_array);
+ 
+ /**
+  * fwnode_property_read_string - return a string property of a firmware node
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property
+  * @val: The value is stored here
+  *
+  * Read property @propname from the given firmware node and store the value into
+  * @val if found.  The value is checked to be a string.
+  *
+  * Return: %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO or %-EILSEQ if the property is not a string,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_read_string(struct fwnode_handle *fwnode,
+ 				const char *propname, const char **val)
+ {
+ 	if (is_of_node(fwnode))
+ 		return of_property_read_string(to_of_node(fwnode), propname, val);
+ 	else if (is_acpi_node(fwnode))
+ 		return acpi_node_prop_read(fwnode, propname, DEV_PROP_STRING,
+ 					   val, 1);
+ 
+ 	return pset_prop_read_array(to_pset(fwnode), propname,
+ 				    DEV_PROP_STRING, val, 1);
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_read_string);
+ 
+ /**
+  * fwnode_property_match_string - find a string in an array and return index
+  * @fwnode: Firmware node to get the property of
+  * @propname: Name of the property holding the array
+  * @string: String to look for
+  *
+  * Find a given string in a string array and if it is found return the
+  * index back.
+  *
+  * Return: %0 if the property was found (success),
+  *	   %-EINVAL if given arguments are not valid,
+  *	   %-ENODATA if the property does not have a value,
+  *	   %-EPROTO if the property is not an array of strings,
+  *	   %-ENXIO if no suitable firmware interface is present.
+  */
+ int fwnode_property_match_string(struct fwnode_handle *fwnode,
+ 	const char *propname, const char *string)
+ {
+ 	const char **values;
+ 	int nval, ret, i;
+ 
+ 	nval = fwnode_property_read_string_array(fwnode, propname, NULL, 0);
+ 	if (nval < 0)
+ 		return nval;
+ 
+ 	values = kcalloc(nval, sizeof(*values), GFP_KERNEL);
+ 	if (!values)
+ 		return -ENOMEM;
+ 
+ 	ret = fwnode_property_read_string_array(fwnode, propname, values, nval);
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	ret = -ENODATA;
+ 	for (i = 0; i < nval; i++) {
+ 		if (!strcmp(values[i], string)) {
+ 			ret = i;
+ 			break;
+ 		}
+ 	}
+ out:
+ 	kfree(values);
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(fwnode_property_match_string);
+ 
+ /**
+  * device_get_next_child_node - Return the next child node handle for a device
+  * @dev: Device to find the next child node for.
+  * @child: Handle to one of the device's child nodes or a null handle.
+  */
+ struct fwnode_handle *device_get_next_child_node(struct device *dev,
+ 						 struct fwnode_handle *child)
+ {
+ 	if (IS_ENABLED(CONFIG_OF) && dev->of_node) {
+ 		struct device_node *node;
+ 
+ 		node = of_get_next_available_child(dev->of_node, to_of_node(child));
+ 		if (node)
+ 			return &node->fwnode;
+ 	} else if (IS_ENABLED(CONFIG_ACPI)) {
+ 		return acpi_get_next_subnode(dev, child);
+ 	}
+ 	return NULL;
+ }
+ EXPORT_SYMBOL_GPL(device_get_next_child_node);
+ 
+ /**
+  * fwnode_handle_put - Drop reference to a device node
+  * @fwnode: Pointer to the device node to drop the reference to.
+  *
+  * This has to be used when terminating device_for_each_child_node() iteration
+  * with break or return to prevent stale device node references from being left
+  * behind.
+  */
+ void fwnode_handle_put(struct fwnode_handle *fwnode)
+ {
+ 	if (is_of_node(fwnode))
+ 		of_node_put(to_of_node(fwnode));
+ }
+ EXPORT_SYMBOL_GPL(fwnode_handle_put);
+ 
+ /**
+  * device_get_child_node_count - return the number of child nodes for device
+  * @dev: Device to cound the child nodes for
+  */
+ unsigned int device_get_child_node_count(struct device *dev)
+ {
+ 	struct fwnode_handle *child;
+ 	unsigned int count = 0;
+ 
+ 	device_for_each_child_node(dev, child)
+ 		count++;
+ 
+ 	return count;
+ }
+ EXPORT_SYMBOL_GPL(device_get_child_node_count);
+ 
+ bool device_dma_is_coherent(struct device *dev)
+ {
+ 	bool coherent = false;
+ 
+ 	if (IS_ENABLED(CONFIG_OF) && dev->of_node)
+ 		coherent = of_dma_is_coherent(dev->of_node);
+ 	else
+ 		acpi_check_dma(ACPI_COMPANION(dev), &coherent);
+ 
+ 	return coherent;
+ }
+ EXPORT_SYMBOL_GPL(device_dma_is_coherent);
+ 
+ bool device_dma_supported(struct device *dev)
+ {
+ 	/* For DT, this is always supported.
+ 	 * For ACPI, this depends on CCA, which
+ 	 * is determined by the acpi_dma_supported().
+ 	 */
+ 	if (IS_ENABLED(CONFIG_OF) && dev->of_node)
+ 		return true;
+ 
+ 	return acpi_dma_supported(ACPI_COMPANION(dev));
+ }
+ EXPORT_SYMBOL_GPL(device_dma_supported);
+ 
+ enum dev_dma_attr device_get_dma_attr(struct device *dev)
+ {
+ 	enum dev_dma_attr attr = DEV_DMA_NOT_SUPPORTED;
+ 
+ 	if (IS_ENABLED(CONFIG_OF) && dev->of_node) {
+ 		if (of_dma_is_coherent(dev->of_node))
+ 			attr = DEV_DMA_COHERENT;
+ 		else
+ 			attr = DEV_DMA_NON_COHERENT;
+ 	} else
+ 		attr = acpi_get_dma_attr(ACPI_COMPANION(dev));
+ 
+ 	return attr;
+ }
+ EXPORT_SYMBOL_GPL(device_get_dma_attr);
+ 
+ /**
+  * device_get_phy_mode - Get phy mode for given device
+  * @dev:	Pointer to the given device
+  *
+  * The function gets phy interface string from property 'phy-mode' or
+  * 'phy-connection-type', and return its index in phy_modes table, or errno in
+  * error case.
+  */
+ int device_get_phy_mode(struct device *dev)
+ {
+ 	const char *pm;
+ 	int err, i;
+ 
+ 	err = device_property_read_string(dev, "phy-mode", &pm);
+ 	if (err < 0)
+ 		err = device_property_read_string(dev,
+ 						  "phy-connection-type", &pm);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	for (i = 0; i < PHY_INTERFACE_MODE_MAX; i++)
+ 		if (!strcasecmp(pm, phy_modes(i)))
+ 			return i;
+ 
+ 	return -ENODEV;
+ }
+ EXPORT_SYMBOL_GPL(device_get_phy_mode);
+ 
+ static void *device_get_mac_addr(struct device *dev,
+ 				 const char *name, char *addr,
+ 				 int alen)
+ {
+ 	int ret = device_property_read_u8_array(dev, name, addr, alen);
+ 
+ 	if (ret == 0 && alen == ETH_ALEN && is_valid_ether_addr(addr))
+ 		return addr;
+ 	return NULL;
+ }
+ 
+ /**
+  * device_get_mac_address - Get the MAC for a given device
+  * @dev:	Pointer to the device
+  * @addr:	Address of buffer to store the MAC in
+  * @alen:	Length of the buffer pointed to by addr, should be ETH_ALEN
+  *
+  * Search the firmware node for the best MAC address to use.  'mac-address' is
+  * checked first, because that is supposed to contain to "most recent" MAC
+  * address. If that isn't set, then 'local-mac-address' is checked next,
+  * because that is the default address.  If that isn't set, then the obsolete
+  * 'address' is checked, just in case we're using an old device tree.
+  *
+  * Note that the 'address' property is supposed to contain a virtual address of
+  * the register set, but some DTS files have redefined that property to be the
+  * MAC address.
+  *
+  * All-zero MAC addresses are rejected, because those could be properties that
+  * exist in the firmware tables, but were not updated by the firmware.  For
+  * example, the DTS could define 'mac-address' and 'local-mac-address', with
+  * zero MAC addresses.  Some older U-Boots only initialized 'local-mac-address'.
+  * In this case, the real MAC is in 'local-mac-address', and 'mac-address'
+  * exists but is all zeros.
+ */
+ void *device_get_mac_address(struct device *dev, char *addr, int alen)
+ {
+ 	char *res;
+ 
+ 	res = device_get_mac_addr(dev, "mac-address", addr, alen);
+ 	if (res)
+ 		return res;
+ 
+ 	res = device_get_mac_addr(dev, "local-mac-address", addr, alen);
+ 	if (res)
+ 		return res;
+ 
+ 	return device_get_mac_addr(dev, "address", addr, alen);
+ }
+ EXPORT_SYMBOL(device_get_mac_address);
++>>>>>>> e5e558644bbb (device property: Adding DMA Attribute APIs for Generic Devices)
diff --cc include/linux/property.h
index 07076ebbcd68,7200490b7e6f..000000000000
--- a/include/linux/property.h
+++ b/include/linux/property.h
@@@ -76,4 -111,77 +76,80 @@@ static inline int device_property_read_
  	return device_property_read_u64_array(dev, propname, val, 1);
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool fwnode_property_read_bool(struct fwnode_handle *fwnode,
+ 					     const char *propname)
+ {
+ 	return fwnode_property_present(fwnode, propname);
+ }
+ 
+ static inline int fwnode_property_read_u8(struct fwnode_handle *fwnode,
+ 					  const char *propname, u8 *val)
+ {
+ 	return fwnode_property_read_u8_array(fwnode, propname, val, 1);
+ }
+ 
+ static inline int fwnode_property_read_u16(struct fwnode_handle *fwnode,
+ 					   const char *propname, u16 *val)
+ {
+ 	return fwnode_property_read_u16_array(fwnode, propname, val, 1);
+ }
+ 
+ static inline int fwnode_property_read_u32(struct fwnode_handle *fwnode,
+ 					   const char *propname, u32 *val)
+ {
+ 	return fwnode_property_read_u32_array(fwnode, propname, val, 1);
+ }
+ 
+ static inline int fwnode_property_read_u64(struct fwnode_handle *fwnode,
+ 					   const char *propname, u64 *val)
+ {
+ 	return fwnode_property_read_u64_array(fwnode, propname, val, 1);
+ }
+ 
+ /**
+  * struct property_entry - "Built-in" device property representation.
+  * @name: Name of the property.
+  * @type: Type of the property.
+  * @nval: Number of items of type @type making up the value.
+  * @value: Value of the property (an array of @nval items of type @type).
+  */
+ struct property_entry {
+ 	const char *name;
+ 	enum dev_prop_type type;
+ 	size_t nval;
+ 	union {
+ 		void *raw_data;
+ 		u8 *u8_data;
+ 		u16 *u16_data;
+ 		u32 *u32_data;
+ 		u64 *u64_data;
+ 		const char **str;
+ 	} value;
+ };
+ 
+ /**
+  * struct property_set - Collection of "built-in" device properties.
+  * @fwnode: Handle to be pointed to by the fwnode field of struct device.
+  * @properties: Array of properties terminated with a null entry.
+  */
+ struct property_set {
+ 	struct fwnode_handle fwnode;
+ 	struct property_entry *properties;
+ };
+ 
+ void device_add_property_set(struct device *dev, struct property_set *pset);
+ 
+ bool device_dma_is_coherent(struct device *dev);
+ 
+ bool device_dma_supported(struct device *dev);
+ 
+ enum dev_dma_attr device_get_dma_attr(struct device *dev);
+ 
+ int device_get_phy_mode(struct device *dev);
+ 
+ void *device_get_mac_address(struct device *dev, char *addr, int alen);
+ 
++>>>>>>> e5e558644bbb (device property: Adding DMA Attribute APIs for Generic Devices)
  #endif /* _LINUX_PROPERTY_H_ */
* Unmerged path drivers/base/property.c
* Unmerged path include/linux/property.h
