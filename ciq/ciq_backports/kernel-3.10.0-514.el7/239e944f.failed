vxlan: support ndo_fill_metadata_dst also for IPv6

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 239e944ff532de6e9579b3913d7f76b4f01c7e2f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/239e944f.failed

Fill the metadata correctly even when tunneling over IPv6. Also, check that
the provided metadata is of an address family that is supported by the
tunnel.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 239e944ff532de6e9579b3913d7f76b4f01c7e2f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 4e5b7ab9acd0,14cfa4cdf903..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -2290,6 -2384,67 +2290,70 @@@ static int vxlan_change_mtu(struct net_
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int egress_ipv4_tun_info(struct net_device *dev, struct sk_buff *skb,
+ 				struct ip_tunnel_info *info,
+ 				__be16 sport, __be16 dport)
+ {
+ 	struct vxlan_dev *vxlan = netdev_priv(dev);
+ 	struct rtable *rt;
+ 	struct flowi4 fl4;
+ 
+ 	memset(&fl4, 0, sizeof(fl4));
+ 	fl4.flowi4_tos = RT_TOS(info->key.tos);
+ 	fl4.flowi4_mark = skb->mark;
+ 	fl4.flowi4_proto = IPPROTO_UDP;
+ 	fl4.daddr = info->key.u.ipv4.dst;
+ 
+ 	rt = ip_route_output_key(vxlan->net, &fl4);
+ 	if (IS_ERR(rt))
+ 		return PTR_ERR(rt);
+ 	ip_rt_put(rt);
+ 
+ 	info->key.u.ipv4.src = fl4.saddr;
+ 	info->key.tp_src = sport;
+ 	info->key.tp_dst = dport;
+ 	return 0;
+ }
+ 
+ static int vxlan_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
+ {
+ 	struct vxlan_dev *vxlan = netdev_priv(dev);
+ 	struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 	__be16 sport, dport;
+ 
+ 	sport = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
+ 				  vxlan->cfg.port_max, true);
+ 	dport = info->key.tp_dst ? : vxlan->cfg.dst_port;
+ 
+ 	if (ip_tunnel_info_af(info) == AF_INET) {
+ 		if (!vxlan->vn4_sock)
+ 			return -EINVAL;
+ 		return egress_ipv4_tun_info(dev, skb, info, sport, dport);
+ 	} else {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		struct dst_entry *ndst;
+ 
+ 		if (!vxlan->vn6_sock)
+ 			return -EINVAL;
+ 		ndst = vxlan6_get_route(vxlan, skb, 0,
+ 					&info->key.u.ipv6.dst,
+ 					&info->key.u.ipv6.src);
+ 		if (IS_ERR(ndst))
+ 			return PTR_ERR(ndst);
+ 		dst_release(ndst);
+ 
+ 		info->key.tp_src = sport;
+ 		info->key.tp_dst = dport;
+ #else /* !CONFIG_IPV6 */
+ 		return -EPFNOSUPPORT;
+ #endif
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 239e944ff532 (vxlan: support ndo_fill_metadata_dst also for IPv6)
  static const struct net_device_ops vxlan_netdev_ops = {
  	.ndo_init		= vxlan_init,
  	.ndo_uninit		= vxlan_uninit,
* Unmerged path drivers/net/vxlan.c
