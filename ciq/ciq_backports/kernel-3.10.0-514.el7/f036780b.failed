IB/hfi1: Immediately apply congestion setting MAD

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Dean Luick <dean.luick@intel.com>
commit f036780be8ac7abee912bd1eeb459230e6bcc878
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/f036780b.failed

The handling of the congestion setting MAD packet only
saved off the values, waiting for a congestion control
table packet before going active.  Instead, immediately
apply the values.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Dean Luick <dean.luick@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit f036780be8ac7abee912bd1eeb459230e6bcc878)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/mad.c
diff --cc drivers/staging/hfi1/mad.c
index a1d1bd3b5d27,17882dc8650e..000000000000
--- a/drivers/staging/hfi1/mad.c
+++ b/drivers/staging/hfi1/mad.c
@@@ -3504,45 -3598,20 +3556,42 @@@ static int __subn_set_opa_cc_table(stru
  		return reply((struct ib_mad_hdr *)smp);
  	}
  
++<<<<<<< HEAD:drivers/staging/hfi1/mad.c
 +	new_cc_state = kzalloc(sizeof(*new_cc_state), GFP_KERNEL);
 +	if (new_cc_state == NULL)
 +		goto getit;
 +
 +	spin_lock(&ppd->cc_state_lock);
 +
 +	old_cc_state = get_cc_state(ppd);
 +
 +	if (old_cc_state == NULL) {
 +		spin_unlock(&ppd->cc_state_lock);
 +		kfree(new_cc_state);
 +		return reply((struct ib_mad_hdr *)smp);
 +	}
 +
 +	*new_cc_state = *old_cc_state;
 +
 +	new_cc_state->cct.ccti_limit = ccti_limit;
 +
 +	entries = ppd->ccti_entries;
++=======
+ 	/*
+ 	 * Save details from packet into the ppd.  Hold the cc_state_lock so
+ 	 * our information is consistent with anyone trying to apply the state.
+ 	 */
+ 	spin_lock(&ppd->cc_state_lock);
++>>>>>>> f036780be8ac (IB/hfi1: Immediately apply congestion setting MAD):drivers/staging/rdma/hfi1/mad.c
  	ppd->total_cct_entry = ccti_limit + 1;
- 
+ 	entries = ppd->ccti_entries;
  	for (j = 0, i = sentry; i < eentry; j++, i++)
  		entries[i].entry = be16_to_cpu(p->ccti_entries[j].entry);
- 
- 	memcpy(new_cc_state->cct.entries, entries,
- 	       eentry * sizeof(struct ib_cc_table_entry));
- 
- 	new_cc_state->cong_setting.port_control = IB_CC_CCS_PC_SL_BASED;
- 	new_cc_state->cong_setting.control_map = ppd->cc_sl_control_map;
- 	memcpy(new_cc_state->cong_setting.entries, ppd->congestion_entries,
- 	       OPA_MAX_SLS * sizeof(struct opa_congestion_setting_entry));
- 
- 	rcu_assign_pointer(ppd->cc_state, new_cc_state);
- 
  	spin_unlock(&ppd->cc_state_lock);
  
- 	call_rcu(&old_cc_state->rcu, cc_state_reclaim);
+ 	/* now apply the information */
+ 	apply_cc_state(ppd);
  
- getit:
  	return __subn_get_opa_cc_table(smp, am, data, ibdev, port, resp_len);
  }
  
* Unmerged path drivers/staging/hfi1/mad.c
