netfilter: nf_tables: switch registers to 32 bit addressing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Patrick McHardy <kaber@trash.net>
commit 49499c3e6e18b7677a63316f3ff54a16533dc28f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/49499c3e.failed

Switch the nf_tables registers from 128 bit addressing to 32 bit
addressing to support so called concatenations, where multiple values
can be concatenated over multiple registers for O(1) exact matches of
multiple dimensions using sets.

The old register values are mapped to areas of 128 bits for compatibility.
When dumping register numbers, values are expressed using the old values
if they refer to the beginning of a 128 bit area for compatibility.

To support concatenations, register loads of less than a full 32 bit
value need to be padded. This mainly affects the payload and exthdr
expressions, which both unconditionally zero the last word before
copying the data.

Userspace fully passes the testsuite using both old and new register
addressing.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 49499c3e6e18b7677a63316f3ff54a16533dc28f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables.h
#	net/bridge/netfilter/nft_meta_bridge.c
#	net/ipv4/netfilter/nft_redir_ipv4.c
#	net/ipv6/netfilter/nft_redir_ipv6.c
#	net/netfilter/nf_tables_api.c
#	net/netfilter/nf_tables_core.c
#	net/netfilter/nft_bitwise.c
#	net/netfilter/nft_byteorder.c
#	net/netfilter/nft_ct.c
#	net/netfilter/nft_exthdr.c
#	net/netfilter/nft_immediate.c
#	net/netfilter/nft_lookup.c
#	net/netfilter/nft_meta.c
#	net/netfilter/nft_nat.c
#	net/netfilter/nft_payload.c
diff --cc include/net/netfilter/nf_tables.h
index 4ab50d820db0,1f9b848c778c..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -46,19 -54,25 +46,34 @@@ struct nft_data 
  	};
  } __attribute__((aligned(__alignof__(u64))));
  
++<<<<<<< HEAD
 +static inline int nft_data_cmp(const struct nft_data *d1,
 +			       const struct nft_data *d2,
 +			       unsigned int len)
 +{
 +	return memcmp(d1->data, d2->data, len);
 +}
++=======
+ /**
+  *	struct nft_regs - nf_tables register set
+  *
+  *	@data: data registers
+  *	@verdict: verdict register
+  *
+  *	The first four data registers alias to the verdict register.
+  */
+ struct nft_regs {
+ 	union {
+ 		u32			data[20];
+ 		struct nft_verdict	verdict;
+ 	};
+ };
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  
- static inline void nft_data_copy(struct nft_data *dst,
- 				 const struct nft_data *src)
+ static inline void nft_data_copy(u32 *dst, const struct nft_data *src,
+ 				 unsigned int len)
  {
- 	BUILD_BUG_ON(__alignof__(*dst) != __alignof__(u64));
- 	*(u64 *)&dst->data[0] = *(u64 *)&src->data[0];
- 	*(u64 *)&dst->data[2] = *(u64 *)&src->data[2];
+ 	memcpy(dst, src, len);
  }
  
  static inline void nft_data_debug(const struct nft_data *data)
@@@ -427,6 -471,39 +442,42 @@@ static inline u8 *nft_set_ext_flags(con
  	return nft_set_ext(ext, NFT_SET_EXT_FLAGS);
  }
  
++<<<<<<< HEAD
++=======
+ static inline u64 *nft_set_ext_timeout(const struct nft_set_ext *ext)
+ {
+ 	return nft_set_ext(ext, NFT_SET_EXT_TIMEOUT);
+ }
+ 
+ static inline unsigned long *nft_set_ext_expiration(const struct nft_set_ext *ext)
+ {
+ 	return nft_set_ext(ext, NFT_SET_EXT_EXPIRATION);
+ }
+ 
+ static inline struct nft_userdata *nft_set_ext_userdata(const struct nft_set_ext *ext)
+ {
+ 	return nft_set_ext(ext, NFT_SET_EXT_USERDATA);
+ }
+ 
+ static inline bool nft_set_elem_expired(const struct nft_set_ext *ext)
+ {
+ 	return nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION) &&
+ 	       time_is_before_eq_jiffies(*nft_set_ext_expiration(ext));
+ }
+ 
+ static inline struct nft_set_ext *nft_set_elem_ext(const struct nft_set *set,
+ 						   void *elem)
+ {
+ 	return elem + set->ops->elemsize;
+ }
+ 
+ void *nft_set_elem_init(const struct nft_set *set,
+ 			const struct nft_set_ext_tmpl *tmpl,
+ 			const u32 *key, const u32 *data,
+ 			u64 timeout, gfp_t gfp);
+ void nft_set_elem_destroy(const struct nft_set *set, void *elem);
+ 
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  /**
   *	struct nft_set_gc_batch_head - nf_tables set garbage collection batch
   *
diff --cc net/bridge/netfilter/nft_meta_bridge.c
index 4f02109d708f,a21269b83f16..000000000000
--- a/net/bridge/netfilter/nft_meta_bridge.c
+++ b/net/bridge/netfilter/nft_meta_bridge.c
@@@ -24,7 -24,7 +24,11 @@@ static void nft_meta_bridge_get_eval(co
  {
  	const struct nft_meta *priv = nft_expr_priv(expr);
  	const struct net_device *in = pkt->in, *out = pkt->out;
++<<<<<<< HEAD
 +	struct nft_data *dest = &data[priv->dreg];
++=======
+ 	u32 *dest = &regs->data[priv->dreg];
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  	const struct net_bridge_port *p;
  
  	switch (priv->key) {
diff --cc net/ipv4/netfilter/nft_redir_ipv4.c
index 6ecfce63201a,d8d795df9c13..000000000000
--- a/net/ipv4/netfilter/nft_redir_ipv4.c
+++ b/net/ipv4/netfilter/nft_redir_ipv4.c
@@@ -28,9 -27,9 +28,15 @@@ static void nft_redir_ipv4_eval(const s
  	memset(&mr, 0, sizeof(mr));
  	if (priv->sreg_proto_min) {
  		mr.range[0].min.all =
++<<<<<<< HEAD
 +			*(__be16 *)&data[priv->sreg_proto_min].data[0];
 +		mr.range[0].max.all =
 +			*(__be16 *)&data[priv->sreg_proto_max].data[0];
++=======
+ 			*(__be16 *)&regs->data[priv->sreg_proto_min];
+ 		mr.range[0].max.all =
+ 			*(__be16 *)&regs->data[priv->sreg_proto_max];
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  		mr.range[0].flags |= NF_NAT_RANGE_PROTO_SPECIFIED;
  	}
  
diff --cc net/ipv6/netfilter/nft_redir_ipv6.c
index 11820b6b3613,effd393bd517..000000000000
--- a/net/ipv6/netfilter/nft_redir_ipv6.c
+++ b/net/ipv6/netfilter/nft_redir_ipv6.c
@@@ -28,9 -27,9 +28,15 @@@ static void nft_redir_ipv6_eval(const s
  	memset(&range, 0, sizeof(range));
  	if (priv->sreg_proto_min) {
  		range.min_proto.all =
++<<<<<<< HEAD
 +			*(__be16 *)&data[priv->sreg_proto_min].data[0];
 +		range.max_proto.all =
 +			*(__be16 *)&data[priv->sreg_proto_max].data[0];
++=======
+ 			*(__be16 *)&regs->data[priv->sreg_proto_min],
+ 		range.max_proto.all =
+ 			*(__be16 *)&regs->data[priv->sreg_proto_max],
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  		range.flags |= NF_NAT_RANGE_PROTO_SPECIFIED;
  	}
  
diff --cc net/netfilter/nf_tables_api.c
index 399ca83793bb,03faf76ce3b8..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -3147,6 -3199,45 +3147,48 @@@ static struct nft_trans *nft_trans_elem
  	return trans;
  }
  
++<<<<<<< HEAD
++=======
+ void *nft_set_elem_init(const struct nft_set *set,
+ 			const struct nft_set_ext_tmpl *tmpl,
+ 			const u32 *key, const u32 *data,
+ 			u64 timeout, gfp_t gfp)
+ {
+ 	struct nft_set_ext *ext;
+ 	void *elem;
+ 
+ 	elem = kzalloc(set->ops->elemsize + tmpl->len, gfp);
+ 	if (elem == NULL)
+ 		return NULL;
+ 
+ 	ext = nft_set_elem_ext(set, elem);
+ 	nft_set_ext_init(ext, tmpl);
+ 
+ 	memcpy(nft_set_ext_key(ext), key, set->klen);
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
+ 		memcpy(nft_set_ext_data(ext), data, set->dlen);
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION))
+ 		*nft_set_ext_expiration(ext) =
+ 			jiffies + msecs_to_jiffies(timeout);
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_TIMEOUT))
+ 		*nft_set_ext_timeout(ext) = timeout;
+ 
+ 	return elem;
+ }
+ 
+ void nft_set_elem_destroy(const struct nft_set *set, void *elem)
+ {
+ 	struct nft_set_ext *ext = nft_set_elem_ext(set, elem);
+ 
+ 	nft_data_uninit(nft_set_ext_key(ext), NFT_DATA_VALUE);
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
+ 		nft_data_uninit(nft_set_ext_data(ext), set->dtype);
+ 
+ 	kfree(elem);
+ }
+ EXPORT_SYMBOL_GPL(nft_set_elem_destroy);
+ 
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,
  			    const struct nlattr *attr)
  {
@@@ -3227,6 -3339,35 +3269,38 @@@
  			if (err < 0)
  				goto err3;
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		nft_set_ext_add(&tmpl, NFT_SET_EXT_DATA);
+ 	}
+ 
+ 	/* The full maximum length of userdata can exceed the maximum
+ 	 * offset value (U8_MAX) for following extensions, therefor it
+ 	 * must be the last extension added.
+ 	 */
+ 	ulen = 0;
+ 	if (nla[NFTA_SET_ELEM_USERDATA] != NULL) {
+ 		ulen = nla_len(nla[NFTA_SET_ELEM_USERDATA]);
+ 		if (ulen > 0)
+ 			nft_set_ext_add_length(&tmpl, NFT_SET_EXT_USERDATA,
+ 					       ulen);
+ 	}
+ 
+ 	err = -ENOMEM;
+ 	elem.priv = nft_set_elem_init(set, &tmpl, elem.key.data, data.data,
+ 				      timeout, GFP_KERNEL);
+ 	if (elem.priv == NULL)
+ 		goto err3;
+ 
+ 	ext = nft_set_elem_ext(set, elem.priv);
+ 	if (flags)
+ 		*nft_set_ext_flags(ext) = flags;
+ 	if (ulen > 0) {
+ 		udata = nft_set_ext_userdata(ext);
+ 		udata->len = ulen - 1;
+ 		nla_memcpy(&udata->data, nla[NFTA_SET_ELEM_USERDATA], ulen);
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  	}
  
  	trans = nft_trans_elem_alloc(ctx, NFT_MSG_NEWSETELEM, set);
@@@ -3956,44 -4121,75 +4030,99 @@@ static int nf_tables_check_loops(const 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  *	nft_parse_register - parse a register value from a netlink attribute
+  *
+  *	@attr: netlink attribute
+  *
+  *	Parse and translate a register value from a netlink attribute.
+  *	Registers used to be 128 bit wide, these register numbers will be
+  *	mapped to the corresponding 32 bit register numbers.
+  */
+ unsigned int nft_parse_register(const struct nlattr *attr)
+ {
+ 	unsigned int reg;
+ 
+ 	reg = ntohl(nla_get_be32(attr));
+ 	switch (reg) {
+ 	case NFT_REG_VERDICT...NFT_REG_4:
+ 		return reg * NFT_REG_SIZE / NFT_REG32_SIZE;
+ 	default:
+ 		return reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00;
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(nft_parse_register);
+ 
+ /**
+  *	nft_dump_register - dump a register value to a netlink attribute
+  *
+  *	@skb: socket buffer
+  *	@attr: attribute number
+  *	@reg: register number
+  *
+  *	Construct a netlink attribute containing the register number. For
+  *	compatibility reasons, register numbers being a multiple of 4 are
+  *	translated to the corresponding 128 bit register numbers.
+  */
+ int nft_dump_register(struct sk_buff *skb, unsigned int attr, unsigned int reg)
+ {
+ 	if (reg % (NFT_REG_SIZE / NFT_REG32_SIZE) == 0)
+ 		reg = reg / (NFT_REG_SIZE / NFT_REG32_SIZE);
+ 	else
+ 		reg = reg - NFT_REG_SIZE / NFT_REG32_SIZE + NFT_REG32_00;
+ 
+ 	return nla_put_be32(skb, attr, htonl(reg));
+ }
+ EXPORT_SYMBOL_GPL(nft_dump_register);
+ 
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  /**
 - *	nft_validate_register_load - validate a load from a register
 + *	nft_validate_input_register - validate an expressions' input register
   *
   *	@reg: the register number
 - *	@len: the length of the data
   *
   * 	Validate that the input register is one of the general purpose
 - * 	registers and that the length of the load is within the bounds.
 + * 	registers.
   */
 -int nft_validate_register_load(enum nft_registers reg, unsigned int len)
 +int nft_validate_input_register(enum nft_registers reg)
  {
- 	if (reg <= NFT_REG_VERDICT)
+ 	if (reg < NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE)
  		return -EINVAL;
++<<<<<<< HEAD
 +	if (reg > NFT_REG_MAX)
 +		return -ERANGE;
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(nft_validate_input_register);
 +
 +/**
 + *	nft_validate_output_register - validate an expressions' output register
 + *
 + *	@reg: the register number
 + *
 + * 	Validate that the output register is one of the general purpose
 + * 	registers or the verdict register.
 + */
 +int nft_validate_output_register(enum nft_registers reg)
 +{
 +	if (reg < NFT_REG_VERDICT)
 +		return -EINVAL;
 +	if (reg > NFT_REG_MAX)
++=======
+ 	if (len == 0)
+ 		return -EINVAL;
+ 	if (reg * NFT_REG32_SIZE + len > FIELD_SIZEOF(struct nft_regs, data))
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  		return -ERANGE;
+ 
  	return 0;
  }
 -EXPORT_SYMBOL_GPL(nft_validate_register_load);
 +EXPORT_SYMBOL_GPL(nft_validate_output_register);
  
  /**
 - *	nft_validate_register_store - validate an expressions' register store
 + *	nft_validate_data_load - validate an expressions' data load
   *
   *	@ctx: context of the expression performing the load
   * 	@reg: the destination register number
@@@ -4030,6 -4231,14 +4159,17 @@@ int nft_validate_data_load(const struc
  
  		return 0;
  	default:
++<<<<<<< HEAD
++=======
+ 		if (reg < NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE)
+ 			return -EINVAL;
+ 		if (len == 0)
+ 			return -EINVAL;
+ 		if (reg * NFT_REG32_SIZE + len >
+ 		    FIELD_SIZEOF(struct nft_regs, data))
+ 			return -ERANGE;
+ 
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  		if (data != NULL && type != NFT_DATA_VALUE)
  			return -EINVAL;
  		return 0;
diff --cc net/netfilter/nf_tables_core.c
index 8c00baffe14b,f153b07073af..000000000000
--- a/net/netfilter/nf_tables_core.c
+++ b/net/netfilter/nf_tables_core.c
@@@ -69,9 -70,9 +69,13 @@@ static void nft_cmp_fast_eval(const str
  	const struct nft_cmp_fast_expr *priv = nft_expr_priv(expr);
  	u32 mask = nft_cmp_fast_mask(priv->len);
  
++<<<<<<< HEAD
 +	if ((data[priv->sreg].data[0] & mask) == priv->data)
++=======
+ 	if ((regs->data[priv->sreg] & mask) == priv->data)
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  		return;
 -	regs->verdict.code = NFT_BREAK;
 +	data[NFT_REG_VERDICT].verdict = NFT_BREAK;
  }
  
  static bool nft_payload_fast_eval(const struct nft_expr *expr,
@@@ -80,7 -81,7 +84,11 @@@
  {
  	const struct nft_payload *priv = nft_expr_priv(expr);
  	const struct sk_buff *skb = pkt->skb;
++<<<<<<< HEAD
 +	struct nft_data *dest = &data[priv->dreg];
++=======
+ 	u32 *dest = &regs->data[priv->dreg];
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  	unsigned char *ptr;
  
  	if (priv->base == NFT_PAYLOAD_NETWORK_HEADER)
@@@ -93,12 -94,13 +101,13 @@@
  	if (unlikely(ptr + priv->len >= skb_tail_pointer(skb)))
  		return false;
  
+ 	*dest = 0;
  	if (priv->len == 2)
 -		*(u16 *)dest = *(u16 *)ptr;
 +		*(u16 *)dest->data = *(u16 *)ptr;
  	else if (priv->len == 4)
 -		*(u32 *)dest = *(u32 *)ptr;
 +		*(u32 *)dest->data = *(u32 *)ptr;
  	else
 -		*(u8 *)dest = *(u8 *)ptr;
 +		*(u8 *)dest->data = *(u8 *)ptr;
  	return true;
  }
  
diff --cc net/netfilter/nft_bitwise.c
index 4fb6ee2c1106,f1a9be2aecd1..000000000000
--- a/net/netfilter/nft_bitwise.c
+++ b/net/netfilter/nft_bitwise.c
@@@ -30,14 -30,12 +30,19 @@@ static void nft_bitwise_eval(const stru
  			     const struct nft_pktinfo *pkt)
  {
  	const struct nft_bitwise *priv = nft_expr_priv(expr);
++<<<<<<< HEAD
 +	const struct nft_data *src = &data[priv->sreg];
 +	struct nft_data *dst = &data[priv->dreg];
++=======
+ 	const u32 *src = &regs->data[priv->sreg];
+ 	u32 *dst = &regs->data[priv->dreg];
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  	unsigned int i;
  
 -	for (i = 0; i < DIV_ROUND_UP(priv->len, 4); i++)
 -		dst[i] = (src[i] & priv->mask.data[i]) ^ priv->xor.data[i];
 +	for (i = 0; i < DIV_ROUND_UP(priv->len, 4); i++) {
 +		dst->data[i] = (src->data[i] & priv->mask.data[i]) ^
 +			       priv->xor.data[i];
 +	}
  }
  
  static const struct nla_policy nft_bitwise_policy[NFTA_BITWISE_MAX + 1] = {
diff --cc net/netfilter/nft_byteorder.c
index c39ed8d29df1,fde5145f2e36..000000000000
--- a/net/netfilter/nft_byteorder.c
+++ b/net/netfilter/nft_byteorder.c
@@@ -30,7 -30,8 +30,12 @@@ static void nft_byteorder_eval(const st
  			       const struct nft_pktinfo *pkt)
  {
  	const struct nft_byteorder *priv = nft_expr_priv(expr);
++<<<<<<< HEAD
 +	struct nft_data *src = &data[priv->sreg], *dst = &data[priv->dreg];
++=======
+ 	u32 *src = &regs->data[priv->sreg];
+ 	u32 *dst = &regs->data[priv->dreg];
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  	union { u32 u32; u16 u16; } *s, *d;
  	unsigned int i;
  
diff --cc net/netfilter/nft_ct.c
index 18d520e0ca0a,8cbca3432f90..000000000000
--- a/net/netfilter/nft_ct.c
+++ b/net/netfilter/nft_ct.c
@@@ -35,7 -35,7 +35,11 @@@ static void nft_ct_get_eval(const struc
  			    const struct nft_pktinfo *pkt)
  {
  	const struct nft_ct *priv = nft_expr_priv(expr);
++<<<<<<< HEAD
 +	struct nft_data *dest = &data[priv->dreg];
++=======
+ 	u32 *dest = &regs->data[priv->dreg];
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  	enum ip_conntrack_info ctinfo;
  	const struct nf_conn *ct;
  	const struct nf_conn_help *help;
@@@ -160,7 -156,7 +164,11 @@@ static void nft_ct_set_eval(const struc
  	const struct nft_ct *priv = nft_expr_priv(expr);
  	struct sk_buff *skb = pkt->skb;
  #ifdef CONFIG_NF_CONNTRACK_MARK
++<<<<<<< HEAD
 +	u32 value = data[priv->sreg].data[0];
++=======
+ 	u32 value = regs->data[priv->sreg];
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  #endif
  	enum ip_conntrack_info ctinfo;
  	struct nf_conn *ct;
diff --cc net/netfilter/nft_exthdr.c
index 55c939f5371f,ba7aed13e174..000000000000
--- a/net/netfilter/nft_exthdr.c
+++ b/net/netfilter/nft_exthdr.c
@@@ -30,7 -30,7 +30,11 @@@ static void nft_exthdr_eval(const struc
  			    const struct nft_pktinfo *pkt)
  {
  	struct nft_exthdr *priv = nft_expr_priv(expr);
++<<<<<<< HEAD
 +	struct nft_data *dest = &data[priv->dreg];
++=======
+ 	u32 *dest = &regs->data[priv->dreg];
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  	unsigned int offset = 0;
  	int err;
  
@@@ -39,7 -39,8 +43,12 @@@
  		goto err;
  	offset += priv->offset;
  
++<<<<<<< HEAD
 +	if (skb_copy_bits(pkt->skb, offset, dest->data, priv->len) < 0)
++=======
+ 	dest[priv->len / NFT_REG32_SIZE] = 0;
+ 	if (skb_copy_bits(pkt->skb, offset, dest, priv->len) < 0)
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  		goto err;
  	return;
  err:
diff --cc net/netfilter/nft_immediate.c
index 810385eb7249,1e8e412eadae..000000000000
--- a/net/netfilter/nft_immediate.c
+++ b/net/netfilter/nft_immediate.c
@@@ -29,7 -29,7 +29,11 @@@ static void nft_immediate_eval(const st
  {
  	const struct nft_immediate_expr *priv = nft_expr_priv(expr);
  
++<<<<<<< HEAD
 +	nft_data_copy(&data[priv->dreg], &priv->data);
++=======
+ 	nft_data_copy(&regs->data[priv->dreg], &priv->data, priv->dlen);
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  }
  
  static const struct nla_policy nft_immediate_policy[NFTA_IMMEDIATE_MAX + 1] = {
diff --cc net/netfilter/nft_lookup.c
index f8e400a6b239,ba1466209f2a..000000000000
--- a/net/netfilter/nft_lookup.c
+++ b/net/netfilter/nft_lookup.c
@@@ -31,10 -31,15 +31,17 @@@ static void nft_lookup_eval(const struc
  {
  	const struct nft_lookup *priv = nft_expr_priv(expr);
  	const struct nft_set *set = priv->set;
 -	const struct nft_set_ext *ext;
  
++<<<<<<< HEAD
 +	if (set->ops->lookup(set, &data[priv->sreg], &data[priv->dreg]))
++=======
+ 	if (set->ops->lookup(set, &regs->data[priv->sreg], &ext)) {
+ 		if (set->flags & NFT_SET_MAP)
+ 			nft_data_copy(&regs->data[priv->dreg],
+ 				      nft_set_ext_data(ext), set->dlen);
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  		return;
 -	}
 -	regs->verdict.code = NFT_BREAK;
 +	data[NFT_REG_VERDICT].verdict = NFT_BREAK;
  }
  
  static const struct nla_policy nft_lookup_policy[NFTA_LOOKUP_MAX + 1] = {
diff --cc net/netfilter/nft_meta.c
index a4cdc254de57,52561e1c31e2..000000000000
--- a/net/netfilter/nft_meta.c
+++ b/net/netfilter/nft_meta.c
@@@ -31,26 -31,27 +31,35 @@@ void nft_meta_get_eval(const struct nft
  	const struct nft_meta *priv = nft_expr_priv(expr);
  	const struct sk_buff *skb = pkt->skb;
  	const struct net_device *in = pkt->in, *out = pkt->out;
++<<<<<<< HEAD
 +	struct nft_data *dest = &data[priv->dreg];
++=======
+ 	u32 *dest = &regs->data[priv->dreg];
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  
  	switch (priv->key) {
  	case NFT_META_LEN:
 -		*dest = skb->len;
 +		dest->data[0] = skb->len;
  		break;
  	case NFT_META_PROTOCOL:
++<<<<<<< HEAD
 +		*(__be16 *)dest->data = skb->protocol;
++=======
+ 		*dest = 0;
+ 		*(__be16 *)dest = skb->protocol;
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  		break;
  	case NFT_META_NFPROTO:
 -		*dest = pkt->ops->pf;
 +		dest->data[0] = pkt->ops->pf;
  		break;
  	case NFT_META_L4PROTO:
 -		*dest = pkt->tprot;
 +		dest->data[0] = pkt->tprot;
  		break;
  	case NFT_META_PRIORITY:
 -		*dest = skb->priority;
 +		dest->data[0] = skb->priority;
  		break;
  	case NFT_META_MARK:
 -		*dest = skb->mark;
 +		dest->data[0] = skb->mark;
  		break;
  	case NFT_META_IIF:
  		if (in == NULL)
@@@ -75,15 -76,17 +84,25 @@@
  	case NFT_META_IIFTYPE:
  		if (in == NULL)
  			goto err;
++<<<<<<< HEAD
 +		*(u16 *)dest->data = in->type;
++=======
+ 		*dest = 0;
+ 		*(u16 *)dest = in->type;
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  		break;
  	case NFT_META_OIFTYPE:
  		if (out == NULL)
  			goto err;
++<<<<<<< HEAD
 +		*(u16 *)dest->data = out->type;
++=======
+ 		*dest = 0;
+ 		*(u16 *)dest = out->type;
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  		break;
  	case NFT_META_SKUID:
 -		if (skb->sk == NULL || !sk_fullsock(skb->sk))
 +		if (skb->sk == NULL || skb->sk->sk_state == TCP_TIME_WAIT)
  			goto err;
  
  		read_lock_bh(&skb->sk->sk_callback_lock);
@@@ -187,7 -188,7 +206,11 @@@ void nft_meta_set_eval(const struct nft
  {
  	const struct nft_meta *meta = nft_expr_priv(expr);
  	struct sk_buff *skb = pkt->skb;
++<<<<<<< HEAD
 +	u32 value = data[meta->sreg].data[0];
++=======
+ 	u32 value = regs->data[meta->sreg];
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  
  	switch (meta->key) {
  	case NFT_META_MARK:
diff --cc net/netfilter/nft_nat.c
index a0837c6c9283,ee2d71753746..000000000000
--- a/net/netfilter/nft_nat.c
+++ b/net/netfilter/nft_nat.c
@@@ -49,26 -49,26 +49,46 @@@ static void nft_nat_eval(const struct n
  	if (priv->sreg_addr_min) {
  		if (priv->family == AF_INET) {
  			range.min_addr.ip = (__force __be32)
++<<<<<<< HEAD
 +					data[priv->sreg_addr_min].data[0];
 +			range.max_addr.ip = (__force __be32)
 +					data[priv->sreg_addr_max].data[0];
 +
 +		} else {
 +			memcpy(range.min_addr.ip6,
 +			       data[priv->sreg_addr_min].data,
 +			       sizeof(struct nft_data));
 +			memcpy(range.max_addr.ip6,
 +			       data[priv->sreg_addr_max].data,
 +			       sizeof(struct nft_data));
++=======
+ 					regs->data[priv->sreg_addr_min];
+ 			range.max_addr.ip = (__force __be32)
+ 					regs->data[priv->sreg_addr_max];
+ 
+ 		} else {
+ 			memcpy(range.min_addr.ip6,
+ 			       &regs->data[priv->sreg_addr_min],
+ 			       sizeof(range.min_addr.ip6));
+ 			memcpy(range.max_addr.ip6,
+ 			       &regs->data[priv->sreg_addr_max],
+ 			       sizeof(range.max_addr.ip6));
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  		}
  		range.flags |= NF_NAT_RANGE_MAP_IPS;
  	}
  
  	if (priv->sreg_proto_min) {
  		range.min_proto.all =
++<<<<<<< HEAD
 +			*(__be16 *)&data[priv->sreg_proto_min].data[0];
 +		range.max_proto.all =
 +			*(__be16 *)&data[priv->sreg_proto_max].data[0];
++=======
+ 			*(__be16 *)&regs->data[priv->sreg_proto_min];
+ 		range.max_proto.all =
+ 			*(__be16 *)&regs->data[priv->sreg_proto_max];
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  		range.flags |= NF_NAT_RANGE_PROTO_SPECIFIED;
  	}
  
diff --cc net/netfilter/nft_payload.c
index 85daa84bfdfe,94fb3b27a2c5..000000000000
--- a/net/netfilter/nft_payload.c
+++ b/net/netfilter/nft_payload.c
@@@ -23,7 -23,7 +23,11 @@@ static void nft_payload_eval(const stru
  {
  	const struct nft_payload *priv = nft_expr_priv(expr);
  	const struct sk_buff *skb = pkt->skb;
++<<<<<<< HEAD
 +	struct nft_data *dest = &data[priv->dreg];
++=======
+ 	u32 *dest = &regs->data[priv->dreg];
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  	int offset;
  
  	switch (priv->base) {
@@@ -43,7 -43,8 +47,12 @@@
  	}
  	offset += priv->offset;
  
++<<<<<<< HEAD
 +	if (skb_copy_bits(skb, offset, dest->data, priv->len) < 0)
++=======
+ 	dest[priv->len / NFT_REG32_SIZE] = 0;
+ 	if (skb_copy_bits(skb, offset, dest, priv->len) < 0)
++>>>>>>> 49499c3e6e18 (netfilter: nf_tables: switch registers to 32 bit addressing)
  		goto err;
  	return;
  err:
* Unmerged path include/net/netfilter/nf_tables.h
diff --git a/include/uapi/linux/netfilter/nf_tables.h b/include/uapi/linux/netfilter/nf_tables.h
index 971d245e7378..25580f34df69 100644
--- a/include/uapi/linux/netfilter/nf_tables.h
+++ b/include/uapi/linux/netfilter/nf_tables.h
@@ -5,16 +5,45 @@
 #define NFT_CHAIN_MAXNAMELEN	32
 #define NFT_USERDATA_MAXLEN	256
 
+/**
+ * enum nft_registers - nf_tables registers
+ *
+ * nf_tables used to have five registers: a verdict register and four data
+ * registers of size 16. The data registers have been changed to 16 registers
+ * of size 4. For compatibility reasons, the NFT_REG_[1-4] registers still
+ * map to areas of size 16, the 4 byte registers are addressed using
+ * NFT_REG32_00 - NFT_REG32_15.
+ */
 enum nft_registers {
 	NFT_REG_VERDICT,
 	NFT_REG_1,
 	NFT_REG_2,
 	NFT_REG_3,
 	NFT_REG_4,
-	__NFT_REG_MAX
+	__NFT_REG_MAX,
+
+	NFT_REG32_00	= 8,
+	MFT_REG32_01,
+	NFT_REG32_02,
+	NFT_REG32_03,
+	NFT_REG32_04,
+	NFT_REG32_05,
+	NFT_REG32_06,
+	NFT_REG32_07,
+	NFT_REG32_08,
+	NFT_REG32_09,
+	NFT_REG32_10,
+	NFT_REG32_11,
+	NFT_REG32_12,
+	NFT_REG32_13,
+	NFT_REG32_14,
+	NFT_REG32_15,
 };
 #define NFT_REG_MAX	(__NFT_REG_MAX - 1)
 
+#define NFT_REG_SIZE	16
+#define NFT_REG32_SIZE	4
+
 /**
  * enum nft_verdicts - nf_tables internal verdicts
  *
* Unmerged path net/bridge/netfilter/nft_meta_bridge.c
* Unmerged path net/ipv4/netfilter/nft_redir_ipv4.c
* Unmerged path net/ipv6/netfilter/nft_redir_ipv6.c
* Unmerged path net/netfilter/nf_tables_api.c
* Unmerged path net/netfilter/nf_tables_core.c
* Unmerged path net/netfilter/nft_bitwise.c
* Unmerged path net/netfilter/nft_byteorder.c
* Unmerged path net/netfilter/nft_ct.c
* Unmerged path net/netfilter/nft_exthdr.c
* Unmerged path net/netfilter/nft_immediate.c
* Unmerged path net/netfilter/nft_lookup.c
* Unmerged path net/netfilter/nft_meta.c
* Unmerged path net/netfilter/nft_nat.c
* Unmerged path net/netfilter/nft_payload.c
