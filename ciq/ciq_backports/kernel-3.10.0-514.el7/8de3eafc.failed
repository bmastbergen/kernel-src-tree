x86/microcode/intel: Rename get_matching_microcode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [x86] microcode/intel: Rename get_matching_microcode (Prarit Bhargava) [1253762]
Rebuild_FUZZ: 95.83%
commit-author Borislav Petkov <bp@suse.de>
commit 8de3eafc161022dd094fa009346509c712e9c4b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8de3eafc.failed

... to has_newer_microcode() as it does exactly that: checks
whether binary data @mc has newer microcode patch than the
applied one. Move @mc to be the first function arg too.

	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Quentin Casasnovas <quentin.casasnovas@oracle.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/1431860101-14847-2-git-send-email-bp@alien8.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 8de3eafc161022dd094fa009346509c712e9c4b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/microcode_intel.h
#	arch/x86/kernel/cpu/microcode/intel.c
#	arch/x86/kernel/cpu/microcode/intel_early.c
#	arch/x86/kernel/cpu/microcode/intel_lib.c
diff --cc arch/x86/include/asm/microcode_intel.h
index e2c7404deded,8e87e6fe98b5..000000000000
--- a/arch/x86/include/asm/microcode_intel.h
+++ b/arch/x86/include/asm/microcode_intel.h
@@@ -56,16 -56,9 +56,20 @@@ struct extended_sigtable 
  
  #define exttable_size(et) ((et)->count * EXT_SIGNATURE_SIZE + EXT_HEADER_SIZE)
  
++<<<<<<< HEAD
 +extern int
 +get_matching_microcode(unsigned int csig, int cpf, void *mc, int rev);
++=======
+ extern int has_newer_microcode(void *mc, unsigned int csig, int cpf, int rev);
++>>>>>>> 8de3eafc1610 (x86/microcode/intel: Rename get_matching_microcode)
  extern int microcode_sanity_check(void *mc, int print_err);
 -extern int get_matching_sig(unsigned int csig, int cpf, void *mc);
 +extern int get_matching_sig(unsigned int csig, int cpf, void *mc, int rev);
 +
 +static inline int
 +revision_is_newer(struct microcode_header_intel *mc_header, int rev)
 +{
 +	return (mc_header->rev <= rev) ? 0 : 1;
 +}
  
  #ifdef CONFIG_MICROCODE_INTEL_EARLY
  extern void __init load_ucode_intel_bsp(void);
diff --cc arch/x86/kernel/cpu/microcode/intel.c
index 865d78872256,969dc17eb1b4..000000000000
--- a/arch/x86/kernel/cpu/microcode/intel.c
+++ b/arch/x86/kernel/cpu/microcode/intel.c
@@@ -63,7 -63,7 +63,11 @@@ static int get_matching_mc(struct micro
  	cpf = cpu_sig.pf;
  	crev = cpu_sig.rev;
  
++<<<<<<< HEAD
 +	return get_matching_microcode(csig, cpf, mc_intel, crev);
++=======
+ 	return has_newer_microcode(mc_intel, csig, cpf, crev);
++>>>>>>> 8de3eafc1610 (x86/microcode/intel: Rename get_matching_microcode)
  }
  
  static int apply_microcode_intel(int cpu)
@@@ -165,7 -165,7 +169,11 @@@ static enum ucode_state generic_load_mi
  
  		csig = uci->cpu_sig.sig;
  		cpf = uci->cpu_sig.pf;
++<<<<<<< HEAD
 +		if (get_matching_microcode(csig, cpf, mc, new_rev)) {
++=======
+ 		if (has_newer_microcode(mc, csig, cpf, new_rev)) {
++>>>>>>> 8de3eafc1610 (x86/microcode/intel: Rename get_matching_microcode)
  			vfree(new_mc);
  			new_rev = mc_header.rev;
  			new_mc  = mc;
diff --cc arch/x86/kernel/cpu/microcode/intel_early.c
index f074fe1d5a06,5f828268357d..000000000000
--- a/arch/x86/kernel/cpu/microcode/intel_early.c
+++ b/arch/x86/kernel/cpu/microcode/intel_early.c
@@@ -46,38 -46,35 +46,54 @@@ static struct mc_saved_data 
  } mc_saved_data;
  
  static enum ucode_state
 -load_microcode_early(struct microcode_intel **saved,
 -		     unsigned int num_saved, struct ucode_cpu_info *uci)
 +generic_load_microcode_early(struct microcode_intel **mc_saved_p,
 +			     unsigned int mc_saved_count,
 +			     struct ucode_cpu_info *uci)
  {
  	struct microcode_intel *ucode_ptr, *new_mc = NULL;
 -	struct microcode_header_intel *mc_hdr;
 -	int new_rev, ret, i;
 +	int new_rev = uci->cpu_sig.rev;
 +	enum ucode_state state = UCODE_OK;
 +	unsigned int mc_size;
 +	struct microcode_header_intel *mc_header;
 +	unsigned int csig = uci->cpu_sig.sig;
 +	unsigned int cpf = uci->cpu_sig.pf;
 +	int i;
  
 -	new_rev = uci->cpu_sig.rev;
 +	for (i = 0; i < mc_saved_count; i++) {
 +		ucode_ptr = mc_saved_p[i];
  
++<<<<<<< HEAD
 +		mc_header = (struct microcode_header_intel *)ucode_ptr;
 +		mc_size = get_totalsize(mc_header);
 +		if (get_matching_microcode(csig, cpf, ucode_ptr, new_rev)) {
 +			new_rev = mc_header->rev;
 +			new_mc  = ucode_ptr;
 +		}
++=======
+ 	for (i = 0; i < num_saved; i++) {
+ 		ucode_ptr = saved[i];
+ 		mc_hdr	  = (struct microcode_header_intel *)ucode_ptr;
+ 
+ 		ret = has_newer_microcode(ucode_ptr,
+ 					  uci->cpu_sig.sig,
+ 					  uci->cpu_sig.pf,
+ 					  new_rev);
+ 		if (!ret)
+ 			continue;
+ 
+ 		new_rev = mc_hdr->rev;
+ 		new_mc  = ucode_ptr;
++>>>>>>> 8de3eafc1610 (x86/microcode/intel: Rename get_matching_microcode)
  	}
  
 -	if (!new_mc)
 -		return UCODE_NFOUND;
 +	if (!new_mc) {
 +		state = UCODE_NFOUND;
 +		goto out;
 +	}
  
  	uci->mc = (struct microcode_intel *)new_mc;
 -	return UCODE_OK;
 +out:
 +	return state;
  }
  
  static inline void
diff --cc arch/x86/kernel/cpu/microcode/intel_lib.c
index 7e259d99b0aa,425f8e29b795..000000000000
--- a/arch/x86/kernel/cpu/microcode/intel_lib.c
+++ b/arch/x86/kernel/cpu/microcode/intel_lib.c
@@@ -153,16 -152,15 +153,20 @@@ int get_matching_sig(unsigned int csig
  }
  
  /*
 - * Returns 1 if update has been found, 0 otherwise.
 + * return 0 - no update found
 + * return 1 - found update
   */
++<<<<<<< HEAD
 +int get_matching_microcode(unsigned int csig, int cpf, void *mc, int rev)
++=======
+ int has_newer_microcode(void *mc, unsigned int csig, int cpf, int new_rev)
++>>>>>>> 8de3eafc1610 (x86/microcode/intel: Rename get_matching_microcode)
  {
 -	struct microcode_header_intel *mc_hdr = mc;
 +	struct microcode_header_intel *mc_header = mc;
  
 -	if (mc_hdr->rev <= new_rev)
 +	if (!revision_is_newer(mc_header, rev))
  		return 0;
  
 -	return get_matching_sig(csig, cpf, mc);
 +	return get_matching_sig(csig, cpf, mc, rev);
  }
- EXPORT_SYMBOL_GPL(get_matching_microcode);
+ EXPORT_SYMBOL_GPL(has_newer_microcode);
* Unmerged path arch/x86/include/asm/microcode_intel.h
* Unmerged path arch/x86/kernel/cpu/microcode/intel.c
* Unmerged path arch/x86/kernel/cpu/microcode/intel_early.c
* Unmerged path arch/x86/kernel/cpu/microcode/intel_lib.c
