i40e/i40evf: Move stack var deeper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jesse Brandeburg <jesse.brandeburg@intel.com>
commit d1bd743b5b4d675e739b574284d1412ba996fe07
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/d1bd743b.failed

A local variable could move down inside the context where it is used.

Change-ID: I9caba9e1eacf921037077f2665cbce83fd8e95d6
	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit d1bd743b5b4d675e739b574284d1412ba996fe07)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_txrx.c
#	drivers/net/ethernet/intel/i40evf/i40e_txrx.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 5a3abb58e191,76a48e9c859b..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@@ -2415,22 -2392,65 +2415,77 @@@ static int i40e_tsyn(struct i40e_ring *
   * @tx_ring: Tx descriptor ring
   * @cd_tunneling: ptr to context desc bits
   **/
 -static int i40e_tx_enable_csum(struct sk_buff *skb, u32 *tx_flags,
 -			       u32 *td_cmd, u32 *td_offset,
 -			       struct i40e_ring *tx_ring,
 -			       u32 *cd_tunneling)
 +static void i40e_tx_enable_csum(struct sk_buff *skb, u32 *tx_flags,
 +				u32 *td_cmd, u32 *td_offset,
 +				struct i40e_ring *tx_ring,
 +				u32 *cd_tunneling)
  {
++<<<<<<< HEAD
 +	struct ipv6hdr *this_ipv6_hdr;
 +	unsigned int this_tcp_hdrlen;
 +	struct iphdr *this_ip_hdr;
 +	u32 network_hdr_len;
 +	u8 l4_hdr = 0;
 +	u32 l4_tunnel = 0;
 +
 +	if (skb->encapsulation) {
 +		switch (ip_hdr(skb)->protocol) {
++=======
+ 	union {
+ 		struct iphdr *v4;
+ 		struct ipv6hdr *v6;
+ 		unsigned char *hdr;
+ 	} ip;
+ 	union {
+ 		struct tcphdr *tcp;
+ 		struct udphdr *udp;
+ 		unsigned char *hdr;
+ 	} l4;
+ 	unsigned char *exthdr;
+ 	u32 offset, cmd = 0;
+ 	__be16 frag_off;
+ 	u8 l4_proto = 0;
+ 
+ 	if (skb->ip_summed != CHECKSUM_PARTIAL)
+ 		return 0;
+ 
+ 	ip.hdr = skb_network_header(skb);
+ 	l4.hdr = skb_transport_header(skb);
+ 
+ 	/* compute outer L2 header size */
+ 	offset = ((ip.hdr - skb->data) / 2) << I40E_TX_DESC_LENGTH_MACLEN_SHIFT;
+ 
+ 	if (skb->encapsulation) {
+ 		u32 tunnel = 0;
+ 		/* define outer network header type */
+ 		if (*tx_flags & I40E_TX_FLAGS_IPV4) {
+ 			tunnel |= (*tx_flags & I40E_TX_FLAGS_TSO) ?
+ 				  I40E_TX_CTX_EXT_IP_IPV4 :
+ 				  I40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;
+ 
+ 			l4_proto = ip.v4->protocol;
+ 		} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
+ 			tunnel |= I40E_TX_CTX_EXT_IP_IPV6;
+ 
+ 			exthdr = ip.hdr + sizeof(*ip.v6);
+ 			l4_proto = ip.v6->nexthdr;
+ 			if (l4.hdr != exthdr)
+ 				ipv6_skip_exthdr(skb, exthdr - skb->data,
+ 						 &l4_proto, &frag_off);
+ 		}
+ 
+ 		/* compute outer L3 header size */
+ 		tunnel |= ((l4.hdr - ip.hdr) / 4) <<
+ 			  I40E_TXD_CTX_QW0_EXT_IPLEN_SHIFT;
+ 
+ 		/* switch IP header pointer from outer to inner header */
+ 		ip.hdr = skb_inner_network_header(skb);
+ 
+ 		/* define outer transport */
+ 		switch (l4_proto) {
++>>>>>>> d1bd743b5b4d (i40e/i40evf: Move stack var deeper)
  		case IPPROTO_UDP:
 -			tunnel |= I40E_TXD_CTX_UDP_TUNNELING;
 +			l4_tunnel = I40E_TXD_CTX_UDP_TUNNELING;
  			*tx_flags |= I40E_TX_FLAGS_UDP_TUNNEL;
  			break;
  		case IPPROTO_GRE:
diff --cc drivers/net/ethernet/intel/i40evf/i40e_txrx.c
index f6384b0c8220,d633dcf4a882..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
@@@ -1621,24 -1614,72 +1621,79 @@@ static int i40e_tso(struct i40e_ring *t
   * @tx_flags: pointer to Tx flags currently set
   * @td_cmd: Tx descriptor command bits to set
   * @td_offset: Tx descriptor header offsets to set
 - * @tx_ring: Tx descriptor ring
   * @cd_tunneling: ptr to context desc bits
   **/
 -static int i40e_tx_enable_csum(struct sk_buff *skb, u32 *tx_flags,
 -			       u32 *td_cmd, u32 *td_offset,
 -			       struct i40e_ring *tx_ring,
 -			       u32 *cd_tunneling)
 +static void i40e_tx_enable_csum(struct sk_buff *skb, u32 *tx_flags,
 +				u32 *td_cmd, u32 *td_offset,
 +				struct i40e_ring *tx_ring,
 +				u32 *cd_tunneling)
  {
++<<<<<<< HEAD
 +	struct ipv6hdr *this_ipv6_hdr;
 +	unsigned int this_tcp_hdrlen;
 +	struct iphdr *this_ip_hdr;
 +	u32 network_hdr_len;
 +	u8 l4_hdr = 0;
 +	u32 l4_tunnel = 0;
 +
 +	if (skb->encapsulation) {
 +		switch (ip_hdr(skb)->protocol) {
++=======
+ 	union {
+ 		struct iphdr *v4;
+ 		struct ipv6hdr *v6;
+ 		unsigned char *hdr;
+ 	} ip;
+ 	union {
+ 		struct tcphdr *tcp;
+ 		struct udphdr *udp;
+ 		unsigned char *hdr;
+ 	} l4;
+ 	unsigned char *exthdr;
+ 	u32 offset, cmd = 0;
+ 	__be16 frag_off;
+ 	u8 l4_proto = 0;
+ 
+ 	if (skb->ip_summed != CHECKSUM_PARTIAL)
+ 		return 0;
+ 
+ 	ip.hdr = skb_network_header(skb);
+ 	l4.hdr = skb_transport_header(skb);
+ 
+ 	/* compute outer L2 header size */
+ 	offset = ((ip.hdr - skb->data) / 2) << I40E_TX_DESC_LENGTH_MACLEN_SHIFT;
+ 
+ 	if (skb->encapsulation) {
+ 		u32 tunnel = 0;
+ 		/* define outer network header type */
+ 		if (*tx_flags & I40E_TX_FLAGS_IPV4) {
+ 			tunnel |= (*tx_flags & I40E_TX_FLAGS_TSO) ?
+ 				  I40E_TX_CTX_EXT_IP_IPV4 :
+ 				  I40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;
+ 
+ 			l4_proto = ip.v4->protocol;
+ 		} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
+ 			tunnel |= I40E_TX_CTX_EXT_IP_IPV6;
+ 
+ 			exthdr = ip.hdr + sizeof(*ip.v6);
+ 			l4_proto = ip.v6->nexthdr;
+ 			if (l4.hdr != exthdr)
+ 				ipv6_skip_exthdr(skb, exthdr - skb->data,
+ 						 &l4_proto, &frag_off);
+ 		}
+ 
+ 		/* compute outer L3 header size */
+ 		tunnel |= ((l4.hdr - ip.hdr) / 4) <<
+ 			  I40E_TXD_CTX_QW0_EXT_IPLEN_SHIFT;
+ 
+ 		/* switch IP header pointer from outer to inner header */
+ 		ip.hdr = skb_inner_network_header(skb);
+ 
+ 		/* define outer transport */
+ 		switch (l4_proto) {
++>>>>>>> d1bd743b5b4d (i40e/i40evf: Move stack var deeper)
  		case IPPROTO_UDP:
 -			tunnel |= I40E_TXD_CTX_UDP_TUNNELING;
 -			*tx_flags |= I40E_TX_FLAGS_VXLAN_TUNNEL;
 -			break;
 -		case IPPROTO_GRE:
 -			tunnel |= I40E_TXD_CTX_GRE_TUNNELING;
 +			l4_tunnel = I40E_TXD_CTX_UDP_TUNNELING;
  			*tx_flags |= I40E_TX_FLAGS_VXLAN_TUNNEL;
  			break;
  		default:
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_txrx.c
