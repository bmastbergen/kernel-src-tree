be2iscsi: Remove redundant MCC processing code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jitendra Bhivare <jitendra.bhivare@broadcom.com>
commit 2e4e8f6574ab14937ca6aac9c9551876e744154d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2e4e8f65.failed

be_mcc_compl_process_isr is removed. MCC CQ processing is done only in
beiscsi_process_mcc_cq and MCC CQE processing is done only in
beiscsi_process_mcc_compl.

	Signed-off-by: Jitendra Bhivare <jitendra.bhivare@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 2e4e8f6574ab14937ca6aac9c9551876e744154d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/be2iscsi/be_cmds.c
#	drivers/scsi/be2iscsi/be_cmds.h
#	drivers/scsi/be2iscsi/be_main.c
#	drivers/scsi/be2iscsi/be_main.h
diff --cc drivers/scsi/be2iscsi/be_cmds.c
index f6abd01429a1,f59dbdf465f5..000000000000
--- a/drivers/scsi/be2iscsi/be_cmds.c
+++ b/drivers/scsi/be2iscsi/be_cmds.c
@@@ -427,90 -337,186 +357,144 @@@ void beiscsi_fail_session(struct iscsi_
  	iscsi_session_failure(cls_session->dd_data, ISCSI_ERR_CONN_FAILED);
  }
  
 -static void beiscsi_process_async_link(struct beiscsi_hba *phba,
 -				       struct be_mcc_compl *compl)
 +void beiscsi_async_link_state_process(struct beiscsi_hba *phba,
 +		struct be_async_event_link_state *evt)
  {
 -	struct be_async_event_link_state *evt;
 +	if ((evt->port_link_status == ASYNC_EVENT_LINK_DOWN) ||
 +	    ((evt->port_link_status & ASYNC_EVENT_LOGICAL) &&
 +	     (evt->port_fault != BEISCSI_PHY_LINK_FAULT_NONE))) {
 +		phba->state = BE_ADAPTER_LINK_DOWN;
  
 -	evt = (struct be_async_event_link_state *)compl;
 +		beiscsi_log(phba, KERN_ERR,
 +			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_INIT,
 +			    "BC_%d : Link Down on Port %d\n",
 +			    evt->physical_port);
  
 -	phba->port_speed = evt->port_speed;
 -	/**
 -	 * Check logical link status in ASYNC event.
 -	 * This has been newly introduced in SKH-R Firmware 10.0.338.45.
 -	 **/
 -	if (evt->port_link_status & BE_ASYNC_LINK_UP_MASK) {
 -		phba->state = BE_ADAPTER_LINK_UP | BE_ADAPTER_CHECK_BOOT;
 -		phba->get_boot = BE_GET_BOOT_RETRIES;
 -		__beiscsi_log(phba, KERN_ERR,
 -			      "BC_%d : Link Up on Port %d tag 0x%x\n",
 -			      evt->physical_port, evt->event_tag);
 -	} else {
 -		phba->state = BE_ADAPTER_LINK_DOWN;
 -		__beiscsi_log(phba, KERN_ERR,
 -			      "BC_%d : Link Down on Port %d tag 0x%x\n",
 -			      evt->physical_port, evt->event_tag);
  		iscsi_host_for_each_session(phba->shost,
  					    beiscsi_fail_session);
 -	}
 -}
 -
 -static char *beiscsi_port_misconf_event_msg[] = {
 -	"Physical Link is functional.",
 -	"Optics faulted/incorrectly installed/not installed - Reseat optics, if issue not resolved, replace.",
 -	"Optics of two types installed - Remove one optic or install matching pair of optics.",
 -	"Incompatible optics - Replace with compatible optics for card to function.",
 -	"Unqualified optics - Replace with Avago optics for Warranty and Technical Support.",
 -	"Uncertified optics - Replace with Avago Certified optics to enable link operation."
 -};
 -
 -static void beiscsi_process_async_sli(struct beiscsi_hba *phba,
 -				      struct be_mcc_compl *compl)
 -{
 -	struct be_async_event_sli *async_sli;
 -	u8 evt_type, state, old_state, le;
 -	char *sev = KERN_WARNING;
 -	char *msg = NULL;
 -
 -	evt_type = compl->flags >> ASYNC_TRAILER_EVENT_TYPE_SHIFT;
 -	evt_type &= ASYNC_TRAILER_EVENT_TYPE_MASK;
 -
 -	/* processing only MISCONFIGURED physical port event */
 -	if (evt_type != ASYNC_SLI_EVENT_TYPE_MISCONFIGURED)
 -		return;
 -
 -	async_sli = (struct be_async_event_sli *)compl;
 -	state = async_sli->event_data1 >>
 -		 (phba->fw_config.phys_port * 8) & 0xff;
 -	le = async_sli->event_data2 >>
 -		 (phba->fw_config.phys_port * 8) & 0xff;
 -
 -	old_state = phba->optic_state;
 -	phba->optic_state = state;
 -
 -	if (state >= ARRAY_SIZE(beiscsi_port_misconf_event_msg)) {
 -		/* fw is reporting a state we don't know, log and return */
 -		__beiscsi_log(phba, KERN_ERR,
 -			    "BC_%d : Port %c: Unrecognized optic state 0x%x\n",
 -			    phba->port_name, async_sli->event_data1);
 -		return;
 -	}
 -
 -	if (ASYNC_SLI_LINK_EFFECT_VALID(le)) {
 -		/* log link effect for unqualified-4, uncertified-5 optics */
 -		if (state > 3)
 -			msg = (ASYNC_SLI_LINK_EFFECT_STATE(le)) ?
 -				" Link is non-operational." :
 -				" Link is operational.";
 -		/* 1 - info */
 -		if (ASYNC_SLI_LINK_EFFECT_SEV(le) == 1)
 -			sev = KERN_INFO;
 -		/* 2 - error */
 -		if (ASYNC_SLI_LINK_EFFECT_SEV(le) == 2)
 -			sev = KERN_ERR;
 -	}
 -
 -	if (old_state != phba->optic_state)
 -		__beiscsi_log(phba, sev, "BC_%d : Port %c: %s%s\n",
 -			      phba->port_name,
 -			      beiscsi_port_misconf_event_msg[state],
 -			      !msg ? "" : msg);
 -}
 -
 -void beiscsi_process_async_event(struct beiscsi_hba *phba,
 -				struct be_mcc_compl *compl)
 -{
 -	char *sev = KERN_INFO;
 -	u8 evt_code;
 -
 -	/* interpret flags as an async trailer */
 -	evt_code = compl->flags >> ASYNC_TRAILER_EVENT_CODE_SHIFT;
 -	evt_code &= ASYNC_TRAILER_EVENT_CODE_MASK;
 -	switch (evt_code) {
 -	case ASYNC_EVENT_CODE_LINK_STATE:
 -		beiscsi_process_async_link(phba, compl);
 -		break;
 -	case ASYNC_EVENT_CODE_ISCSI:
 -		phba->state |= BE_ADAPTER_CHECK_BOOT;
 +	} else if ((evt->port_link_status & ASYNC_EVENT_LINK_UP) ||
 +		    ((evt->port_link_status & ASYNC_EVENT_LOGICAL) &&
 +		     (evt->port_fault == BEISCSI_PHY_LINK_FAULT_NONE))) {
 +		phba->state = BE_ADAPTER_LINK_UP | BE_ADAPTER_CHECK_BOOT;
  		phba->get_boot = BE_GET_BOOT_RETRIES;
 -		sev = KERN_ERR;
 -		break;
 -	case ASYNC_EVENT_CODE_SLI:
 -		beiscsi_process_async_sli(phba, compl);
 -		break;
 -	default:
 -		/* event not registered */
 -		sev = KERN_ERR;
 -	}
  
 -	beiscsi_log(phba, sev, BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
 -		    "BC_%d : ASYNC Event %x: status 0x%08x flags 0x%08x\n",
 -		    evt_code, compl->status, compl->flags);
 +		beiscsi_log(phba, KERN_ERR,
 +			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_INIT,
 +			    "BC_%d : Link UP on Port %d\n",
 +			    evt->physical_port);
 +	}
  }
  
- int beiscsi_process_mcc(struct beiscsi_hba *phba)
+ int beiscsi_process_mcc_compl(struct be_ctrl_info *ctrl,
+ 			      struct be_mcc_compl *compl)
  {
- 	struct be_mcc_compl *compl;
- 	int num = 0, status = 0;
- 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	struct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);
+ 	u16 compl_status, extd_status;
+ 	struct be_dma_mem *tag_mem;
+ 	unsigned int tag, wrb_idx;
  
++<<<<<<< HEAD
 +	while ((compl = be_mcc_compl_get(phba))) {
 +		if (compl->flags & CQE_FLAGS_ASYNC_MASK) {
 +			/* Interpret flags as an async trailer */
 +			if (is_link_state_evt(compl->flags))
 +				/* Interpret compl as a async link evt */
 +				beiscsi_async_link_state_process(phba,
 +				   (struct be_async_event_link_state *) compl);
 +			else if (is_iscsi_evt(compl->flags)) {
 +				switch (iscsi_evt_type(compl->flags)) {
 +				case ASYNC_EVENT_NEW_ISCSI_TGT_DISC:
 +				case ASYNC_EVENT_NEW_ISCSI_CONN:
 +				case ASYNC_EVENT_NEW_TCP_CONN:
 +					phba->state |= BE_ADAPTER_CHECK_BOOT;
 +					phba->get_boot = BE_GET_BOOT_RETRIES;
 +					beiscsi_log(phba, KERN_ERR,
 +						    BEISCSI_LOG_CONFIG |
 +						    BEISCSI_LOG_MBOX,
 +						    "BC_%d : Async iscsi Event, flags "
 +						    "handled = 0x%08x\n",
 +						    compl->flags);
 +					break;
 +				default:
 +					phba->state |= BE_ADAPTER_CHECK_BOOT;
 +					phba->get_boot = BE_GET_BOOT_RETRIES;
 +					beiscsi_log(phba, KERN_ERR,
 +						    BEISCSI_LOG_CONFIG |
 +						    BEISCSI_LOG_MBOX,
 +						    "BC_%d : Unsupported Async iscsi "
 +						    "Event, flags = 0x%08x\n",
 +						    compl->flags);
 +				}
 +			} else
 +				beiscsi_log(phba, KERN_ERR,
 +					    BEISCSI_LOG_CONFIG |
 +					    BEISCSI_LOG_MBOX,
 +					    "BC_%d : Unsupported Async Event, flags"
 +					    " = 0x%08x\n", compl->flags);
 +
 +		} else if (compl->flags & CQE_FLAGS_COMPLETED_MASK) {
 +				status = be_mcc_compl_process(ctrl, compl);
 +				atomic_dec(&phba->ctrl.mcc_obj.q.used);
 +		}
 +		be_mcc_compl_use(compl);
 +		num++;
 +	}
 +
 +	if (num)
 +		hwi_ring_cq_db(phba, phba->ctrl.mcc_obj.cq.id, num, 1, 0);
++=======
+ 	/**
+ 	 * Just swap the status to host endian; mcc tag is opaquely copied
+ 	 * from mcc_wrb
+ 	 */
+ 	be_dws_le_to_cpu(compl, 4);
+ 	tag = (compl->tag0 & MCC_Q_CMD_TAG_MASK);
+ 	wrb_idx = (compl->tag0 & CQE_STATUS_WRB_MASK) >> CQE_STATUS_WRB_SHIFT;
+ 
+ 	if (!test_bit(MCC_TAG_STATE_RUNNING,
+ 		      &ctrl->ptag_state[tag].tag_state)) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_MBOX |
+ 			    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,
+ 			    "BC_%d : MBX cmd completed but not posted\n");
+ 		return 0;
+ 	}
+ 
+ 	if (test_bit(MCC_TAG_STATE_TIMEOUT, &ctrl->ptag_state[tag].tag_state)) {
+ 		beiscsi_log(phba, KERN_WARNING,
+ 			    BEISCSI_LOG_MBOX | BEISCSI_LOG_INIT |
+ 			    BEISCSI_LOG_CONFIG,
+ 			    "BC_%d : MBX Completion for timeout Command from FW\n");
+ 		/**
+ 		 * Check for the size before freeing resource.
+ 		 * Only for non-embedded cmd, PCI resource is allocated.
+ 		 **/
+ 		tag_mem = &ctrl->ptag_state[tag].tag_mem_state;
+ 		if (tag_mem->size)
+ 			pci_free_consistent(ctrl->pdev, tag_mem->size,
+ 					tag_mem->va, tag_mem->dma);
+ 		free_mcc_tag(ctrl, tag);
+ 		return 0;
+ 	}
++>>>>>>> 2e4e8f6574ab (be2iscsi: Remove redundant MCC processing code)
+ 
+ 	compl_status = (compl->status >> CQE_STATUS_COMPL_SHIFT) &
+ 		       CQE_STATUS_COMPL_MASK;
+ 	extd_status = (compl->status >> CQE_STATUS_EXTD_SHIFT) &
+ 		      CQE_STATUS_EXTD_MASK;
+ 	/* The ctrl.mcc_tag_status[tag] is filled with
+ 	 * [31] = valid, [30:24] = Rsvd, [23:16] = wrb, [15:8] = extd_status,
+ 	 * [7:0] = compl_status
+ 	 */
+ 	ctrl->mcc_tag_status[tag] = CQE_VALID_MASK;
+ 	ctrl->mcc_tag_status[tag] |= (wrb_idx << CQE_STATUS_WRB_SHIFT);
+ 	ctrl->mcc_tag_status[tag] |= (extd_status << CQE_STATUS_ADDL_SHIFT) &
+ 				     CQE_STATUS_ADDL_MASK;
+ 	ctrl->mcc_tag_status[tag] |= (compl_status & CQE_STATUS_MASK);
  
- 	return status;
+ 	/* write ordering forced in wake_up_interruptible */
+ 	clear_bit(MCC_TAG_STATE_RUNNING, &ctrl->ptag_state[tag].tag_state);
+ 	wake_up_interruptible(&ctrl->mcc_wait[tag]);
+ 	return 0;
  }
  
  /*
diff --cc drivers/scsi/be2iscsi/be_cmds.h
index 522c53180d02,f50b32ac72ee..000000000000
--- a/drivers/scsi/be2iscsi/be_cmds.h
+++ b/drivers/scsi/be2iscsi/be_cmds.h
@@@ -746,13 -741,14 +746,21 @@@ int be_cmd_fw_uninit(struct be_ctrl_inf
  
  struct be_mcc_wrb *wrb_from_mbox(struct be_dma_mem *mbox_mem);
  struct be_mcc_wrb *wrb_from_mccq(struct beiscsi_hba *phba);
- int be_mcc_notify_wait(struct beiscsi_hba *phba, unsigned int tag);
+ int be_mcc_compl_poll(struct beiscsi_hba *phba, unsigned int tag);
  void be_mcc_notify(struct beiscsi_hba *phba, unsigned int tag);
  unsigned int alloc_mcc_tag(struct beiscsi_hba *phba);
++<<<<<<< HEAD
 +void beiscsi_async_link_state_process(struct beiscsi_hba *phba,
 +		struct be_async_event_link_state *evt);
 +int be_mcc_compl_process_isr(struct be_ctrl_info *ctrl,
 +				    struct be_mcc_compl *compl);
++=======
+ void beiscsi_process_async_event(struct beiscsi_hba *phba,
+ 				struct be_mcc_compl *compl);
+ int beiscsi_process_mcc_compl(struct be_ctrl_info *ctrl,
+ 			      struct be_mcc_compl *compl);
+ 
++>>>>>>> 2e4e8f6574ab (be2iscsi: Remove redundant MCC processing code)
  
  int be_mbox_notify(struct be_ctrl_info *ctrl);
  
diff --cc drivers/scsi/be2iscsi/be_main.c
index 7885533b6626,8b9d01a765fc..000000000000
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@@ -2103,30 -2038,15 +2103,29 @@@ void beiscsi_process_mcc_cq(struct beis
  	mcc_compl = queue_tail_node(mcc_cq);
  	mcc_compl->flags = le32_to_cpu(mcc_compl->flags);
  	while (mcc_compl->flags & CQE_FLAGS_VALID_MASK) {
- 
  		if (num_processed >= 32) {
  			hwi_ring_cq_db(phba, mcc_cq->id,
 -					num_processed, 0);
 +					num_processed, 0, 0);
  			num_processed = 0;
  		}
  		if (mcc_compl->flags & CQE_FLAGS_ASYNC_MASK) {
 -			beiscsi_process_async_event(phba, mcc_compl);
 +			/* Interpret flags as an async trailer */
 +			if (is_link_state_evt(mcc_compl->flags))
 +				/* Interpret compl as a async link evt */
 +				beiscsi_async_link_state_process(phba,
 +				(struct be_async_event_link_state *) mcc_compl);
 +			else {
 +				beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_MBOX,
 +					    "BM_%d :  Unsupported Async Event, flags"
 +					    " = 0x%08x\n",
 +					    mcc_compl->flags);
 +				if (phba->state & BE_ADAPTER_LINK_UP) {
 +					phba->state |= BE_ADAPTER_CHECK_BOOT;
 +					phba->get_boot = BE_GET_BOOT_RETRIES;
 +				}
 +			}
  		} else if (mcc_compl->flags & CQE_FLAGS_COMPLETED_MASK) {
- 			be_mcc_compl_process_isr(&phba->ctrl, mcc_compl);
+ 			beiscsi_process_mcc_compl(&phba->ctrl, mcc_compl);
  			atomic_dec(&phba->ctrl.mcc_obj.q.used);
  		}
  
@@@ -2138,8 -2058,7 +2137,12 @@@
  	}
  
  	if (num_processed > 0)
++<<<<<<< HEAD
 +		hwi_ring_cq_db(phba, mcc_cq->id, num_processed, 1, 0);
 +
++=======
+ 		hwi_ring_cq_db(phba, mcc_cq->id, num_processed, 1);
++>>>>>>> 2e4e8f6574ab (be2iscsi: Remove redundant MCC processing code)
  }
  
  /**
diff --cc drivers/scsi/be2iscsi/be_main.h
index 7c1871cc0ca5,5ded3fabc942..000000000000
--- a/drivers/scsi/be2iscsi/be_main.h
+++ b/drivers/scsi/be2iscsi/be_main.h
@@@ -844,9 -850,10 +844,14 @@@ void beiscsi_free_mgmt_task_handles(str
  
  void hwi_ring_cq_db(struct beiscsi_hba *phba,
  		     unsigned int id, unsigned int num_processed,
 -		     unsigned char rearm);
 +		     unsigned char rearm, unsigned char event);
  
++<<<<<<< HEAD
 +unsigned int beiscsi_process_cq(struct be_eq_obj *pbe_eq);
++=======
+ unsigned int beiscsi_process_cq(struct be_eq_obj *pbe_eq, int budget);
+ void beiscsi_process_mcc_cq(struct beiscsi_hba *phba);
++>>>>>>> 2e4e8f6574ab (be2iscsi: Remove redundant MCC processing code)
  
  static inline bool beiscsi_error(struct beiscsi_hba *phba)
  {
* Unmerged path drivers/scsi/be2iscsi/be_cmds.c
* Unmerged path drivers/scsi/be2iscsi/be_cmds.h
* Unmerged path drivers/scsi/be2iscsi/be_main.c
* Unmerged path drivers/scsi/be2iscsi/be_main.h
diff --git a/drivers/scsi/be2iscsi/be_mgmt.c b/drivers/scsi/be2iscsi/be_mgmt.c
index 229fa208398d..94e8b541391b 100644
--- a/drivers/scsi/be2iscsi/be_mgmt.c
+++ b/drivers/scsi/be2iscsi/be_mgmt.c
@@ -580,7 +580,8 @@ int mgmt_epfw_cleanup(struct beiscsi_hba *phba, unsigned short ulp_num)
 	req->hdr_ring_id = cpu_to_le16(HWI_GET_DEF_HDRQ_ID(phba, ulp_num));
 	req->data_ring_id = cpu_to_le16(HWI_GET_DEF_BUFQ_ID(phba, ulp_num));
 
-	status = be_mcc_notify_wait(phba, tag);
+	be_mcc_notify(phba, tag);
+	status = be_mcc_compl_poll(phba, tag);
 	if (status)
 		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,
 			    "BG_%d : mgmt_epfw_cleanup , FAILED\n");
