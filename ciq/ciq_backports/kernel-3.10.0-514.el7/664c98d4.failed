perf stat record: Add pipe support for record command

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 664c98d4e1c2ff60627d78d4c8ae81cd2df13783
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/664c98d4.failed

Allowing storing stat record data into pipe, so report tools
(report/script) could read data directly from record.

Committer note:

Before this patch:

  $ perf stat record -o - usleep 1 | perf report -i -
  incompatible file format (rerun with -v to learn more)
  $ perf stat record -o - usleep 1 | perf script -i -
  incompatible file format (rerun with -v to learn more)
  $ ls -la perf.data
  ls: cannot access perf.data: No such file or directory
  $

After:

  $ perf stat record -o - usleep 1 | perf report -i -
  # To display the perf.data header info, please use
  # --header/--header-only options.
  #
  Error:
  The - file has no samples!
  $ perf stat record -o - usleep 1 | perf script -i -
  Display of symbols requested but neither sample IP nor sample address
  is selected. Hence, no addresses to convert to symbols.
  0 [0x80]: failed to process type: 64
  $ ls -la perf.data
  ls: cannot access perf.data: No such file or directory
  $

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Tested-by: Kan Liang <kan.liang@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1446734469-11352-7-git-send-email-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 664c98d4e1c2ff60627d78d4c8ae81cd2df13783)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-stat.c
diff --cc tools/perf/builtin-stat.c
index 473fc692d35a,8a2f9ce677e7..000000000000
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@@ -283,6 -317,76 +283,79 @@@ static void workload_exec_failed_signal
  	workload_exec_errno = info->si_value.sival_int;
  }
  
++<<<<<<< HEAD
++=======
+ static int perf_stat_synthesize_config(bool is_pipe)
+ {
+ 	int err;
+ 
+ 	if (is_pipe) {
+ 		err = perf_event__synthesize_attrs(NULL, perf_stat.session,
+ 						   process_synthesized_event);
+ 		if (err < 0) {
+ 			pr_err("Couldn't synthesize attrs.\n");
+ 			return err;
+ 		}
+ 	}
+ 
+ 	err = perf_event__synthesize_thread_map2(NULL, evsel_list->threads,
+ 						process_synthesized_event,
+ 						NULL);
+ 	if (err < 0) {
+ 		pr_err("Couldn't synthesize thread map.\n");
+ 		return err;
+ 	}
+ 
+ 	err = perf_event__synthesize_cpu_map(NULL, evsel_list->cpus,
+ 					     process_synthesized_event, NULL);
+ 	if (err < 0) {
+ 		pr_err("Couldn't synthesize thread map.\n");
+ 		return err;
+ 	}
+ 
+ 	err = perf_event__synthesize_stat_config(NULL, &stat_config,
+ 						 process_synthesized_event, NULL);
+ 	if (err < 0) {
+ 		pr_err("Couldn't synthesize config.\n");
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ #define FD(e, x, y) (*(int *)xyarray__entry(e->fd, x, y))
+ 
+ static int __store_counter_ids(struct perf_evsel *counter,
+ 			       struct cpu_map *cpus,
+ 			       struct thread_map *threads)
+ {
+ 	int cpu, thread;
+ 
+ 	for (cpu = 0; cpu < cpus->nr; cpu++) {
+ 		for (thread = 0; thread < threads->nr; thread++) {
+ 			int fd = FD(counter, cpu, thread);
+ 
+ 			if (perf_evlist__id_add_fd(evsel_list, counter,
+ 						   cpu, thread, fd) < 0)
+ 				return -1;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int store_counter_ids(struct perf_evsel *counter)
+ {
+ 	struct cpu_map *cpus = counter->cpus;
+ 	struct thread_map *threads = counter->threads;
+ 
+ 	if (perf_evsel__alloc_id(counter, cpus->nr, threads->nr))
+ 		return -ENOMEM;
+ 
+ 	return __store_counter_ids(counter, cpus, threads);
+ }
+ 
++>>>>>>> 664c98d4e1c2 (perf stat record: Add pipe support for record command)
  static int __run_perf_stat(int argc, const char **argv)
  {
  	int interval = stat_config.interval;
@@@ -356,6 -464,24 +430,27 @@@
  		return -1;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (STAT_RECORD) {
+ 		int err, fd = perf_data_file__fd(&perf_stat.file);
+ 
+ 		if (is_pipe) {
+ 			err = perf_header__write_pipe(perf_data_file__fd(&perf_stat.file));
+ 		} else {
+ 			err = perf_session__write_header(perf_stat.session, evsel_list,
+ 							 fd, false);
+ 		}
+ 
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = perf_stat_synthesize_config(is_pipe);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
++>>>>>>> 664c98d4e1c2 (perf stat record: Add pipe support for record command)
  	/*
  	 * Enable counters and exec the command:
  	 */
@@@ -1136,71 -1386,51 +1235,117 @@@ static int add_default_attributes(void
  	return perf_evlist__add_default_attrs(evsel_list, very_very_detailed_attrs);
  }
  
++<<<<<<< HEAD
++=======
+ static const char * const recort_usage[] = {
+ 	"perf stat record [<options>]",
+ 	NULL,
+ };
+ 
+ static void init_features(struct perf_session *session)
+ {
+ 	int feat;
+ 
+ 	for (feat = HEADER_FIRST_FEATURE; feat < HEADER_LAST_FEATURE; feat++)
+ 		perf_header__set_feat(&session->header, feat);
+ 
+ 	perf_header__clear_feat(&session->header, HEADER_BUILD_ID);
+ 	perf_header__clear_feat(&session->header, HEADER_TRACING_DATA);
+ 	perf_header__clear_feat(&session->header, HEADER_BRANCH_STACK);
+ 	perf_header__clear_feat(&session->header, HEADER_AUXTRACE);
+ }
+ 
+ static int __cmd_record(int argc, const char **argv)
+ {
+ 	struct perf_session *session;
+ 	struct perf_data_file *file = &perf_stat.file;
+ 
+ 	argc = parse_options(argc, argv, stat_options, record_usage,
+ 			     PARSE_OPT_STOP_AT_NON_OPTION);
+ 
+ 	if (output_name)
+ 		file->path = output_name;
+ 
+ 	session = perf_session__new(file, false, NULL);
+ 	if (session == NULL) {
+ 		pr_err("Perf session creation failed.\n");
+ 		return -1;
+ 	}
+ 
+ 	init_features(session);
+ 
+ 	session->evlist   = evsel_list;
+ 	perf_stat.session = session;
+ 	perf_stat.record  = true;
+ 	return argc;
+ }
+ 
++>>>>>>> 664c98d4e1c2 (perf stat record: Add pipe support for record command)
  int cmd_stat(int argc, const char **argv, const char *prefix __maybe_unused)
  {
 +	bool append_file = false;
 +	int output_fd = 0;
 +	const char *output_name	= NULL;
 +	const struct option options[] = {
 +	OPT_BOOLEAN('T', "transaction", &transaction_run,
 +		    "hardware transaction statistics"),
 +	OPT_CALLBACK('e', "event", &evsel_list, "event",
 +		     "event selector. use 'perf list' to list available events",
 +		     parse_events_option),
 +	OPT_CALLBACK(0, "filter", &evsel_list, "filter",
 +		     "event filter", parse_filter),
 +	OPT_BOOLEAN('i', "no-inherit", &no_inherit,
 +		    "child tasks do not inherit counters"),
 +	OPT_STRING('p', "pid", &target.pid, "pid",
 +		   "stat events on existing process id"),
 +	OPT_STRING('t', "tid", &target.tid, "tid",
 +		   "stat events on existing thread id"),
 +	OPT_BOOLEAN('a', "all-cpus", &target.system_wide,
 +		    "system-wide collection from all CPUs"),
 +	OPT_BOOLEAN('g', "group", &group,
 +		    "put the counters into a counter group"),
 +	OPT_BOOLEAN('c', "scale", &stat_config.scale, "scale/normalize counters"),
 +	OPT_INCR('v', "verbose", &verbose,
 +		    "be more verbose (show counter open errors, etc)"),
 +	OPT_INTEGER('r', "repeat", &run_count,
 +		    "repeat command and print average + stddev (max: 100, forever: 0)"),
 +	OPT_BOOLEAN('n', "null", &null_run,
 +		    "null run - dont start any counters"),
 +	OPT_INCR('d', "detailed", &detailed_run,
 +		    "detailed run - start a lot of events"),
 +	OPT_BOOLEAN('S', "sync", &sync_run,
 +		    "call sync() before starting a run"),
 +	OPT_CALLBACK_NOOPT('B', "big-num", NULL, NULL,
 +			   "print large numbers with thousands\' separators",
 +			   stat__set_big_num),
 +	OPT_STRING('C', "cpu", &target.cpu_list, "cpu",
 +		    "list of cpus to monitor in system-wide"),
 +	OPT_SET_UINT('A', "no-aggr", &stat_config.aggr_mode,
 +		    "disable CPU count aggregation", AGGR_NONE),
 +	OPT_STRING('x', "field-separator", &csv_sep, "separator",
 +		   "print counts with custom separator"),
 +	OPT_CALLBACK('G', "cgroup", &evsel_list, "name",
 +		     "monitor event in cgroup name only", parse_cgroups),
 +	OPT_STRING('o', "output", &output_name, "file", "output file name"),
 +	OPT_BOOLEAN(0, "append", &append_file, "append to the output file"),
 +	OPT_INTEGER(0, "log-fd", &output_fd,
 +		    "log output to fd, instead of stderr"),
 +	OPT_STRING(0, "pre", &pre_cmd, "command",
 +			"command to run prior to the measured command"),
 +	OPT_STRING(0, "post", &post_cmd, "command",
 +			"command to run after to the measured command"),
 +	OPT_UINTEGER('I', "interval-print", &stat_config.interval,
 +		    "print counts at regular interval in ms (>= 10)"),
 +	OPT_SET_UINT(0, "per-socket", &stat_config.aggr_mode,
 +		     "aggregate counts per processor socket", AGGR_SOCKET),
 +	OPT_SET_UINT(0, "per-core", &stat_config.aggr_mode,
 +		     "aggregate counts per physical processor core", AGGR_CORE),
 +	OPT_SET_UINT(0, "per-thread", &stat_config.aggr_mode,
 +		     "aggregate counts per thread", AGGR_THREAD),
 +	OPT_UINTEGER('D', "delay", &initial_delay,
 +		     "ms to wait before starting measurement after program start"),
 +	OPT_END()
 +	};
  	const char * const stat_usage[] = {
  		"perf stat [<options>] [<command>]",
  		NULL
@@@ -1388,6 -1629,36 +1533,39 @@@
  	if (!forever && status != -1 && !interval)
  		print_counters(NULL, argc, argv);
  
++<<<<<<< HEAD
++=======
+ 	if (STAT_RECORD) {
+ 		/*
+ 		 * We synthesize the kernel mmap record just so that older tools
+ 		 * don't emit warnings about not being able to resolve symbols
+ 		 * due to /proc/sys/kernel/kptr_restrict settings and instear provide
+ 		 * a saner message about no samples being in the perf.data file.
+ 		 *
+ 		 * This also serves to suppress a warning about f_header.data.size == 0
+ 		 * in header.c at the moment 'perf stat record' gets introduced, which
+ 		 * is not really needed once we start adding the stat specific PERF_RECORD_
+ 		 * records, but the need to suppress the kptr_restrict messages in older
+ 		 * tools remain  -acme
+ 		 */
+ 		int fd = perf_data_file__fd(&perf_stat.file);
+ 		int err = perf_event__synthesize_kernel_mmap((void *)&perf_stat,
+ 							     process_synthesized_event,
+ 							     &perf_stat.session->machines.host);
+ 		if (err) {
+ 			pr_warning("Couldn't synthesize the kernel mmap record, harmless, "
+ 				   "older tools may produce warnings about this file\n.");
+ 		}
+ 
+ 		if (!perf_stat.file.is_pipe) {
+ 			perf_stat.session->header.data_size += perf_stat.bytes_written;
+ 			perf_session__write_header(perf_stat.session, evsel_list, fd, true);
+ 		}
+ 
+ 		perf_session__delete(perf_stat.session);
+ 	}
+ 
++>>>>>>> 664c98d4e1c2 (perf stat record: Add pipe support for record command)
  	perf_stat__exit_aggr_mode();
  	perf_evlist__free_stats(evsel_list);
  out:
* Unmerged path tools/perf/builtin-stat.c
