r8152: return -EBUSY for runtime suspend

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author hayeswang <hayeswang@realtek.com>
commit 6cc69f2a404dea8641d6cf97c0fbe8d24579e259
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/6cc69f2a.failed

Remove calling cancel_delayed_work_sync() for runtime suspend,
because it would cause dead lock. Instead, return -EBUSY to
avoid the device enters suspending if the net is running and
the delayed work is pending or running. The delayed work would
try to wake up the device later, so the suspending is not
necessary.

	Signed-off-by: Hayes Wang <hayeswang@realtek.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6cc69f2a404dea8641d6cf97c0fbe8d24579e259)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/r8152.c
diff --cc drivers/net/usb/r8152.c
index 0f9c353ad1ea,e3d84c322e4e..000000000000
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@@ -3129,26 -3189,39 +3129,58 @@@ static void r8153_init(struct r8152 *tp
  static int rtl8152_suspend(struct usb_interface *intf, pm_message_t message)
  {
  	struct r8152 *tp = usb_get_intfdata(intf);
+ 	struct net_device *netdev = tp->netdev;
+ 	int ret = 0;
  
++<<<<<<< HEAD
 +	if (PMSG_IS_AUTO(message))
 +		set_bit(SELECTIVE_SUSPEND, &tp->flags);
 +	else
 +		netif_device_detach(tp->netdev);
++=======
+ 	mutex_lock(&tp->control);
  
- 	if (netif_running(tp->netdev)) {
+ 	if (PMSG_IS_AUTO(message)) {
+ 		if (netif_running(netdev) && work_busy(&tp->schedule.work)) {
+ 			ret = -EBUSY;
+ 			goto out1;
+ 		}
++>>>>>>> 6cc69f2a404d (r8152: return -EBUSY for runtime suspend)
+ 
+ 		set_bit(SELECTIVE_SUSPEND, &tp->flags);
+ 	} else {
+ 		netif_device_detach(netdev);
+ 	}
+ 
+ 	if (netif_running(netdev)) {
  		clear_bit(WORK_ENABLE, &tp->flags);
  		usb_kill_urb(tp->intr_urb);
++<<<<<<< HEAD
 +		cancel_delayed_work_sync(&tp->schedule);
++=======
+ 		tasklet_disable(&tp->tl);
++>>>>>>> 6cc69f2a404d (r8152: return -EBUSY for runtime suspend)
  		if (test_bit(SELECTIVE_SUSPEND, &tp->flags)) {
 -			rtl_stop_rx(tp);
  			rtl_runtime_suspend_enable(tp, true);
  		} else {
++<<<<<<< HEAD
 +			tasklet_disable(&tp->tl);
++=======
+ 			cancel_delayed_work_sync(&tp->schedule);
++>>>>>>> 6cc69f2a404d (r8152: return -EBUSY for runtime suspend)
  			tp->rtl_ops.down(tp);
 +			tasklet_enable(&tp->tl);
  		}
 -		tasklet_enable(&tp->tl);
  	}
++<<<<<<< HEAD
 +
 +	return 0;
++=======
+ out1:
+ 	mutex_unlock(&tp->control);
+ 
+ 	return ret;
++>>>>>>> 6cc69f2a404d (r8152: return -EBUSY for runtime suspend)
  }
  
  static int rtl8152_resume(struct usb_interface *intf)
* Unmerged path drivers/net/usb/r8152.c
