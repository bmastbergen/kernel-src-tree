iommu, x86: Implement irq_set_vcpu_affinity for intel_ir_chip

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [iommu]  x86: Implement irq_set_vcpu_affinity for intel_ir_chip (Paolo Bonzini) [1301888]
Rebuild_FUZZ: 94.83%
commit-author Feng Wu <feng.wu@intel.com>
commit 8541186faf3b59623c86022cc5f21ce9bd1332c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8541186f.failed

Interrupt chip callback to set the VCPU affinity for posted interrupts.

[ tglx: Use the helper function to copy from the remap irte instead of
        open coding it. Massage the comment as well ]

	Signed-off-by: Feng Wu <feng.wu@intel.com>
	Reviewed-by: Jiang Liu <jiang.liu@linux.intel.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: David Woodhouse <David.Woodhouse@intel.com>
	Cc: iommu@lists.linux-foundation.org
	Cc: joro@8bytes.org
	Cc: dwmw2@infradead.org
Link: http://lkml.kernel.org/r/1433827237-3382-5-git-send-email-feng.wu@intel.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 8541186faf3b59623c86022cc5f21ce9bd1332c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel_irq_remapping.c
diff --cc drivers/iommu/intel_irq_remapping.c
index 085a116a8b0a,a643eecf9d29..000000000000
--- a/drivers/iommu/intel_irq_remapping.c
+++ b/drivers/iommu/intel_irq_remapping.c
@@@ -1093,94 -1000,220 +1093,144 @@@ intel_ioapic_set_affinity(struct irq_da
  	 * at the new destination. So, time to cleanup the previous
  	 * vector allocation.
  	 */
 -	send_cleanup_vector(cfg);
 +	if (cfg->move_in_progress)
 +		send_cleanup_vector(cfg);
  
 -	return IRQ_SET_MASK_OK_DONE;
 +	cpumask_copy(data->affinity, mask);
 +	return 0;
  }
  
 -static void intel_ir_compose_msi_msg(struct irq_data *irq_data,
 -				     struct msi_msg *msg)
 +static void intel_compose_msi_msg(struct pci_dev *pdev,
 +				  unsigned int irq, unsigned int dest,
 +				  struct msi_msg *msg, u8 hpet_id)
  {
 -	struct intel_ir_data *ir_data = irq_data->chip_data;
 +	struct irq_cfg *cfg;
 +	struct irte irte;
 +	u16 sub_handle = 0;
 +	int ir_index;
 +
 +	cfg = irq_get_chip_data(irq);
  
 -	*msg = ir_data->msi_entry;
 +	ir_index = map_irq_to_irte_handle(irq, &sub_handle);
 +	BUG_ON(ir_index == -1);
 +
 +	prepare_irte(&irte, cfg->vector, dest);
 +
 +	/* Set source-id of interrupt request */
 +	if (pdev)
 +		set_msi_sid(&irte, pdev);
 +	else
 +		set_hpet_sid(&irte, hpet_id);
 +
 +	modify_irte(irq, &irte);
 +
 +	msg->address_hi = MSI_ADDR_BASE_HI;
 +	msg->data = sub_handle;
 +	msg->address_lo = MSI_ADDR_BASE_LO | MSI_ADDR_IR_EXT_INT |
 +			  MSI_ADDR_IR_SHV |
 +			  MSI_ADDR_IR_INDEX1(ir_index) |
 +			  MSI_ADDR_IR_INDEX2(ir_index);
  }
  
++<<<<<<< HEAD
 +/*
 + * Map the PCI dev to the corresponding remapping hardware unit
 + * and allocate 'nvec' consecutive interrupt-remapping table entries
 + * in it.
 + */
 +static int intel_msi_alloc_irq(struct pci_dev *dev, int irq, int nvec)
++=======
+ static int intel_ir_set_vcpu_affinity(struct irq_data *data, void *info)
+ {
+ 	struct intel_ir_data *ir_data = data->chip_data;
+ 	struct vcpu_data *vcpu_pi_info = info;
+ 
+ 	/* stop posting interrupts, back to remapping mode */
+ 	if (!vcpu_pi_info) {
+ 		modify_irte(&ir_data->irq_2_iommu, &ir_data->irte_entry);
+ 	} else {
+ 		struct irte irte_pi;
+ 
+ 		/*
+ 		 * We are not caching the posted interrupt entry. We
+ 		 * copy the data from the remapped entry and modify
+ 		 * the fields which are relevant for posted mode. The
+ 		 * cached remapped entry is used for switching back to
+ 		 * remapped mode.
+ 		 */
+ 		memset(&irte_pi, 0, sizeof(irte_pi));
+ 		dmar_copy_shared_irte(&irte_pi, &ir_data->irte_entry);
+ 
+ 		/* Update the posted mode fields */
+ 		irte_pi.p_pst = 1;
+ 		irte_pi.p_urgent = 0;
+ 		irte_pi.p_vector = vcpu_pi_info->vector;
+ 		irte_pi.pda_l = (vcpu_pi_info->pi_desc_addr >>
+ 				(32 - PDA_LOW_BIT)) & ~(-1UL << PDA_LOW_BIT);
+ 		irte_pi.pda_h = (vcpu_pi_info->pi_desc_addr >> 32) &
+ 				~(-1UL << PDA_HIGH_BIT);
+ 
+ 		modify_irte(&ir_data->irq_2_iommu, &irte_pi);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static struct irq_chip intel_ir_chip = {
+ 	.irq_ack = ir_ack_apic_edge,
+ 	.irq_set_affinity = intel_ir_set_affinity,
+ 	.irq_compose_msi_msg = intel_ir_compose_msi_msg,
+ 	.irq_set_vcpu_affinity = intel_ir_set_vcpu_affinity,
+ };
+ 
+ static void intel_irq_remapping_prepare_irte(struct intel_ir_data *data,
+ 					     struct irq_cfg *irq_cfg,
+ 					     struct irq_alloc_info *info,
+ 					     int index, int sub_handle)
++>>>>>>> 8541186faf3b (iommu, x86: Implement irq_set_vcpu_affinity for intel_ir_chip)
  {
 -	struct IR_IO_APIC_route_entry *entry;
 -	struct irte *irte = &data->irte_entry;
 -	struct msi_msg *msg = &data->msi_entry;
 -
 -	prepare_irte(irte, irq_cfg->vector, irq_cfg->dest_apicid);
 -	switch (info->type) {
 -	case X86_IRQ_ALLOC_TYPE_IOAPIC:
 -		/* Set source-id of interrupt request */
 -		set_ioapic_sid(irte, info->ioapic_id);
 -		apic_printk(APIC_VERBOSE, KERN_DEBUG "IOAPIC[%d]: Set IRTE entry (P:%d FPD:%d Dst_Mode:%d Redir_hint:%d Trig_Mode:%d Dlvry_Mode:%X Avail:%X Vector:%02X Dest:%08X SID:%04X SQ:%X SVT:%X)\n",
 -			info->ioapic_id, irte->present, irte->fpd,
 -			irte->dst_mode, irte->redir_hint,
 -			irte->trigger_mode, irte->dlvry_mode,
 -			irte->avail, irte->vector, irte->dest_id,
 -			irte->sid, irte->sq, irte->svt);
 -
 -		entry = (struct IR_IO_APIC_route_entry *)info->ioapic_entry;
 -		info->ioapic_entry = NULL;
 -		memset(entry, 0, sizeof(*entry));
 -		entry->index2	= (index >> 15) & 0x1;
 -		entry->zero	= 0;
 -		entry->format	= 1;
 -		entry->index	= (index & 0x7fff);
 -		/*
 -		 * IO-APIC RTE will be configured with virtual vector.
 -		 * irq handler will do the explicit EOI to the io-apic.
 -		 */
 -		entry->vector	= info->ioapic_pin;
 -		entry->mask	= 0;			/* enable IRQ */
 -		entry->trigger	= info->ioapic_trigger;
 -		entry->polarity	= info->ioapic_polarity;
 -		if (info->ioapic_trigger)
 -			entry->mask = 1; /* Mask level triggered irqs. */
 -		break;
 -
 -	case X86_IRQ_ALLOC_TYPE_HPET:
 -	case X86_IRQ_ALLOC_TYPE_MSI:
 -	case X86_IRQ_ALLOC_TYPE_MSIX:
 -		if (info->type == X86_IRQ_ALLOC_TYPE_HPET)
 -			set_hpet_sid(irte, info->hpet_id);
 -		else
 -			set_msi_sid(irte, info->msi_dev);
 -
 -		msg->address_hi = MSI_ADDR_BASE_HI;
 -		msg->data = sub_handle;
 -		msg->address_lo = MSI_ADDR_BASE_LO | MSI_ADDR_IR_EXT_INT |
 -				  MSI_ADDR_IR_SHV |
 -				  MSI_ADDR_IR_INDEX1(index) |
 -				  MSI_ADDR_IR_INDEX2(index);
 -		break;
 -
 -	default:
 -		BUG_ON(1);
 -		break;
 -	}
 -}
 -
 -static void intel_free_irq_resources(struct irq_domain *domain,
 -				     unsigned int virq, unsigned int nr_irqs)
 -{
 -	struct irq_data *irq_data;
 -	struct intel_ir_data *data;
 -	struct irq_2_iommu *irq_iommu;
 -	unsigned long flags;
 -	int i;
 +	struct intel_iommu *iommu;
 +	int index;
  
 -	for (i = 0; i < nr_irqs; i++) {
 -		irq_data = irq_domain_get_irq_data(domain, virq  + i);
 -		if (irq_data && irq_data->chip_data) {
 -			data = irq_data->chip_data;
 -			irq_iommu = &data->irq_2_iommu;
 -			raw_spin_lock_irqsave(&irq_2_ir_lock, flags);
 -			clear_entries(irq_iommu);
 -			raw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);
 -			irq_domain_reset_irq_data(irq_data);
 -			kfree(data);
 +	down_read(&dmar_global_lock);
 +	iommu = map_dev_to_ir(dev);
 +	if (!iommu) {
 +		printk(KERN_ERR
 +		       "Unable to map PCI %s to iommu\n", pci_name(dev));
 +		index = -ENOENT;
 +	} else {
 +		index = alloc_irte(iommu, irq, nvec);
 +		if (index < 0) {
 +			printk(KERN_ERR
 +			       "Unable to allocate %d IRTE for PCI %s\n",
 +			       nvec, pci_name(dev));
 +			index = -ENOSPC;
  		}
  	}
 +	up_read(&dmar_global_lock);
 +
 +	return index;
  }
  
 -static int intel_irq_remapping_alloc(struct irq_domain *domain,
 -				     unsigned int virq, unsigned int nr_irqs,
 -				     void *arg)
 +static int intel_msi_setup_irq(struct pci_dev *pdev, unsigned int irq,
 +			       int index, int sub_handle)
  {
 -	struct intel_iommu *iommu = domain->host_data;
 -	struct irq_alloc_info *info = arg;
 -	struct intel_ir_data *data, *ird;
 -	struct irq_data *irq_data;
 -	struct irq_cfg *irq_cfg;
 -	int i, ret, index;
 -
 -	if (!info || !iommu)
 -		return -EINVAL;
 -	if (nr_irqs > 1 && info->type != X86_IRQ_ALLOC_TYPE_MSI &&
 -	    info->type != X86_IRQ_ALLOC_TYPE_MSIX)
 -		return -EINVAL;
 -
 -	/*
 -	 * With IRQ remapping enabled, don't need contiguous CPU vectors
 -	 * to support multiple MSI interrupts.
 -	 */
 -	if (info->type == X86_IRQ_ALLOC_TYPE_MSI)
 -		info->flags &= ~X86_IRQ_ALLOC_CONTIGUOUS_VECTORS;
 -
 -	ret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, arg);
 -	if (ret < 0)
 -		return ret;
 -
 -	ret = -ENOMEM;
 -	data = kzalloc(sizeof(*data), GFP_KERNEL);
 -	if (!data)
 -		goto out_free_parent;
 +	struct intel_iommu *iommu;
 +	int ret = -ENOENT;
  
  	down_read(&dmar_global_lock);
 -	index = alloc_irte(iommu, virq, &data->irq_2_iommu, nr_irqs);
 -	up_read(&dmar_global_lock);
 -	if (index < 0) {
 -		pr_warn("Failed to allocate IRTE\n");
 -		kfree(data);
 -		goto out_free_parent;
 -	}
 -
 -	for (i = 0; i < nr_irqs; i++) {
 -		irq_data = irq_domain_get_irq_data(domain, virq + i);
 -		irq_cfg = irqd_cfg(irq_data);
 -		if (!irq_data || !irq_cfg) {
 -			ret = -EINVAL;
 -			goto out_free_data;
 -		}
 -
 -		if (i > 0) {
 -			ird = kzalloc(sizeof(*ird), GFP_KERNEL);
 -			if (!ird)
 -				goto out_free_data;
 -			/* Initialize the common data */
 -			ird->irq_2_iommu = data->irq_2_iommu;
 -			ird->irq_2_iommu.sub_handle = i;
 -		} else {
 -			ird = data;
 -		}
 -
 -		irq_data->hwirq = (index << 16) + i;
 -		irq_data->chip_data = ird;
 -		irq_data->chip = &intel_ir_chip;
 -		intel_irq_remapping_prepare_irte(ird, irq_cfg, info, index, i);
 -		irq_set_status_flags(virq + i, IRQ_MOVE_PCNTXT);
 +	iommu = map_dev_to_ir(pdev);
 +	if (iommu) {
 +		/*
 +		 * setup the mapping between the irq and the IRTE
 +		 * base index, the sub_handle pointing to the
 +		 * appropriate interrupt remap table entry.
 +		 */
 +		set_irte_irq(irq, iommu, index, sub_handle);
 +		ret = 0;
  	}
 -	return 0;
 +	up_read(&dmar_global_lock);
  
 -out_free_data:
 -	intel_free_irq_resources(domain, virq, i);
 -out_free_parent:
 -	irq_domain_free_irqs_common(domain, virq, nr_irqs);
  	return ret;
  }
  
diff --git a/arch/x86/include/asm/irq_remapping.h b/arch/x86/include/asm/irq_remapping.h
index e19bb8620a99..47d427ecc7a9 100644
--- a/arch/x86/include/asm/irq_remapping.h
+++ b/arch/x86/include/asm/irq_remapping.h
@@ -61,6 +61,11 @@ extern bool setup_remapped_irq(int irq,
 
 void irq_remap_modify_chip_defaults(struct irq_chip *chip);
 
+struct vcpu_data {
+	u64 pi_desc_addr;	/* Physical address of PI Descriptor */
+	u32 vector;		/* Guest vector of the interrupt */
+};
+
 #else  /* CONFIG_IRQ_REMAP */
 
 static inline bool irq_remapping_cap(enum irq_remap_cap cap) { return 0; }
* Unmerged path drivers/iommu/intel_irq_remapping.c
