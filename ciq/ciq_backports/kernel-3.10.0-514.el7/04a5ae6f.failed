mmc: sdhci: 64-bit DMA actually has 4-byte alignment

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [mmc] sdhci: 64-bit DMA actually has 4-byte alignment (Don Zickus) [1127975 1277866 1280133 1286932 1297039]
Rebuild_FUZZ: 94.95%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 04a5ae6fdd018af29675eb8b6c2550c87f471570
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/04a5ae6f.failed

The version 3.00 SDHCI spec. was a bit unclear about the
required data alignment for 64-bit DMA, whereas the version
4.10 spec. uses different language and indicates that only
4-byte alignment is required rather than the 8-byte alignment
currently implemented.  That make no difference to SD and EMMC
which invariably transfer data in sector-aligned blocks.
However with SDIO, it results in using more DMA descriptors
than necessary.  Theoretically that slows DMA slightly although
DMA is not the limiting factor for throughput, so there is no
discernable impact on performance.  Nevertheless, the driver
should follw the spec unless there is good reason not to, so
this patch corrects the alignment criterion.

There is a more complicated criterion for the DMA descriptor
table itself.  However the table is allocated by dma_alloc_coherent()
which allocates pages (i.e. aligned to a page boundary).
For simplicity just check it is 8-byte aligned, but add a comment
that some Intel controllers actually require 8-byte alignment
even when using 32-bit DMA.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 04a5ae6fdd018af29675eb8b6c2550c87f471570)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci.c
#	drivers/mmc/host/sdhci.h
diff --cc drivers/mmc/host/sdhci.c
index 16717b3387b4,1a8f42eb8c50..000000000000
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@@ -524,12 -489,12 +524,16 @@@ static int sdhci_adma_table_pre(struct 
  		direction = DMA_TO_DEVICE;
  
  	host->align_addr = dma_map_single(mmc_dev(host->mmc),
 -		host->align_buffer, host->align_buffer_sz, direction);
 +		host->align_buffer, 128 * 4, direction);
  	if (dma_mapping_error(mmc_dev(host->mmc), host->align_addr))
  		goto fail;
++<<<<<<< HEAD
 +	BUG_ON(host->align_addr & 0x3);
++=======
+ 	BUG_ON(host->align_addr & SDHCI_ADMA2_MASK);
++>>>>>>> 04a5ae6fdd01 (mmc: sdhci: 64-bit DMA actually has 4-byte alignment)
  
 -	host->sg_count = sdhci_pre_dma_transfer(host, data);
 +	host->sg_count = sdhci_pre_dma_transfer(host, data, NULL);
  	if (host->sg_count < 0)
  		goto unmap_align;
  
@@@ -549,7 -514,8 +553,12 @@@
  		 * the (up to three) bytes that screw up the
  		 * alignment.
  		 */
++<<<<<<< HEAD
 +		offset = (4 - (addr & 0x3)) & 0x3;
++=======
+ 		offset = (SDHCI_ADMA2_ALIGN - (addr & SDHCI_ADMA2_MASK)) &
+ 			 SDHCI_ADMA2_MASK;
++>>>>>>> 04a5ae6fdd01 (mmc: sdhci: 64-bit DMA actually has 4-byte alignment)
  		if (offset) {
  			if (data->flags & MMC_DATA_WRITE) {
  				buffer = sdhci_kmap_atomic(sg, &flags);
@@@ -562,10 -529,10 +571,15 @@@
  
  			BUG_ON(offset > 65536);
  
++<<<<<<< HEAD
 +			align += 4;
 +			align_addr += 4;
++=======
+ 			align += SDHCI_ADMA2_ALIGN;
+ 			align_addr += SDHCI_ADMA2_ALIGN;
++>>>>>>> 04a5ae6fdd01 (mmc: sdhci: 64-bit DMA actually has 4-byte alignment)
  
 -			desc += host->desc_sz;
 +			desc += 8;
  
  			addr += offset;
  			len -= offset;
@@@ -641,7 -611,7 +655,11 @@@ static void sdhci_adma_table_post(struc
  	/* Do a quick scan of the SG list for any unaligned mappings */
  	has_unaligned = false;
  	for_each_sg(data->sg, sg, host->sg_count, i)
++<<<<<<< HEAD
 +		if (sg_dma_address(sg) & 3) {
++=======
+ 		if (sg_dma_address(sg) & SDHCI_ADMA2_MASK) {
++>>>>>>> 04a5ae6fdd01 (mmc: sdhci: 64-bit DMA actually has 4-byte alignment)
  			has_unaligned = true;
  			break;
  		}
@@@ -653,14 -623,15 +671,24 @@@
  		align = host->align_buffer;
  
  		for_each_sg(data->sg, sg, host->sg_count, i) {
++<<<<<<< HEAD
 +			if (sg_dma_address(sg) & 0x3) {
 +				size = 4 - (sg_dma_address(sg) & 0x3);
++=======
+ 			if (sg_dma_address(sg) & SDHCI_ADMA2_MASK) {
+ 				size = SDHCI_ADMA2_ALIGN -
+ 				       (sg_dma_address(sg) & SDHCI_ADMA2_MASK);
++>>>>>>> 04a5ae6fdd01 (mmc: sdhci: 64-bit DMA actually has 4-byte alignment)
  
  				buffer = sdhci_kmap_atomic(sg, &flags);
  				memcpy(buffer, align, size);
  				sdhci_kunmap_atomic(buffer, &flags);
  
++<<<<<<< HEAD
 +				align += 4;
++=======
+ 				align += SDHCI_ADMA2_ALIGN;
++>>>>>>> 04a5ae6fdd01 (mmc: sdhci: 64-bit DMA actually has 4-byte alignment)
  			}
  		}
  	}
@@@ -2965,32 -2947,49 +2993,55 @@@ int sdhci_add_host(struct sdhci_host *h
  		}
  	}
  
 -	/* SDMA does not support 64-bit DMA */
 -	if (host->flags & SDHCI_USE_64_BIT_DMA)
 -		host->flags &= ~SDHCI_USE_SDMA;
 -
  	if (host->flags & SDHCI_USE_ADMA) {
  		/*
 -		 * The DMA descriptor table size is calculated as the maximum
 -		 * number of segments times 2, to allow for an alignment
 -		 * descriptor for each segment, plus 1 for a nop end descriptor,
 -		 * all multipled by the descriptor size.
 +		 * We need to allocate descriptors for all sg entries
 +		 * (128) and potentially one alignment transfer for
 +		 * each of those entries.
  		 */
++<<<<<<< HEAD
++=======
+ 		if (host->flags & SDHCI_USE_64_BIT_DMA) {
+ 			host->adma_table_sz = (SDHCI_MAX_SEGS * 2 + 1) *
+ 					      SDHCI_ADMA2_64_DESC_SZ;
+ 			host->desc_sz = SDHCI_ADMA2_64_DESC_SZ;
+ 		} else {
+ 			host->adma_table_sz = (SDHCI_MAX_SEGS * 2 + 1) *
+ 					      SDHCI_ADMA2_32_DESC_SZ;
+ 			host->desc_sz = SDHCI_ADMA2_32_DESC_SZ;
+ 		}
++>>>>>>> 04a5ae6fdd01 (mmc: sdhci: 64-bit DMA actually has 4-byte alignment)
  		host->adma_table = dma_alloc_coherent(mmc_dev(mmc),
 -						      host->adma_table_sz,
 +						      ADMA_SIZE,
  						      &host->adma_addr,
  						      GFP_KERNEL);
++<<<<<<< HEAD
 +		host->align_buffer = kmalloc(128 * 4, GFP_KERNEL);
++=======
+ 		host->align_buffer_sz = SDHCI_MAX_SEGS * SDHCI_ADMA2_ALIGN;
+ 		host->align_buffer = kmalloc(host->align_buffer_sz, GFP_KERNEL);
++>>>>>>> 04a5ae6fdd01 (mmc: sdhci: 64-bit DMA actually has 4-byte alignment)
  		if (!host->adma_table || !host->align_buffer) {
 -			if (host->adma_table)
 -				dma_free_coherent(mmc_dev(mmc),
 -						  host->adma_table_sz,
 -						  host->adma_table,
 -						  host->adma_addr);
 +			dma_free_coherent(mmc_dev(mmc), ADMA_SIZE,
 +					  host->adma_table, host->adma_addr);
  			kfree(host->align_buffer);
 -			pr_warn("%s: Unable to allocate ADMA buffers - falling back to standard DMA\n",
 +			pr_warning("%s: Unable to allocate ADMA "
 +				"buffers. Falling back to standard DMA.\n",
  				mmc_hostname(mmc));
  			host->flags &= ~SDHCI_USE_ADMA;
  			host->adma_table = NULL;
  			host->align_buffer = NULL;
++<<<<<<< HEAD
 +		} else if (host->adma_addr & 3) {
 +			pr_warning("%s: unable to allocate aligned ADMA descriptor\n",
 +				   mmc_hostname(mmc));
++=======
+ 		} else if (host->adma_addr & (SDHCI_ADMA2_DESC_ALIGN - 1)) {
+ 			pr_warn("%s: unable to allocate aligned ADMA descriptor\n",
+ 				mmc_hostname(mmc));
++>>>>>>> 04a5ae6fdd01 (mmc: sdhci: 64-bit DMA actually has 4-byte alignment)
  			host->flags &= ~SDHCI_USE_ADMA;
 -			dma_free_coherent(mmc_dev(mmc), host->adma_table_sz,
 +			dma_free_coherent(mmc_dev(mmc), ADMA_SIZE,
  					  host->adma_table, host->adma_addr);
  			kfree(host->align_buffer);
  			host->adma_table = NULL;
diff --cc drivers/mmc/host/sdhci.h
index 23802c7404be,7654ae5d2b4e..000000000000
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@@ -265,6 -269,254 +265,257 @@@
  #define SDHCI_DEFAULT_BOUNDARY_SIZE  (512 * 1024)
  #define SDHCI_DEFAULT_BOUNDARY_ARG   (ilog2(SDHCI_DEFAULT_BOUNDARY_SIZE) - 12)
  
++<<<<<<< HEAD
++=======
+ /* ADMA2 32-bit DMA descriptor size */
+ #define SDHCI_ADMA2_32_DESC_SZ	8
+ 
+ /* ADMA2 32-bit descriptor */
+ struct sdhci_adma2_32_desc {
+ 	__le16	cmd;
+ 	__le16	len;
+ 	__le32	addr;
+ }  __packed __aligned(4);
+ 
+ /* ADMA2 data alignment */
+ #define SDHCI_ADMA2_ALIGN	4
+ #define SDHCI_ADMA2_MASK	(SDHCI_ADMA2_ALIGN - 1)
+ 
+ /*
+  * ADMA2 descriptor alignment.  Some controllers (e.g. Intel) require 8 byte
+  * alignment for the descriptor table even in 32-bit DMA mode.  Memory
+  * allocation is at least 8 byte aligned anyway, so just stipulate 8 always.
+  */
+ #define SDHCI_ADMA2_DESC_ALIGN	8
+ 
+ /* ADMA2 64-bit DMA descriptor size */
+ #define SDHCI_ADMA2_64_DESC_SZ	12
+ 
+ /*
+  * ADMA2 64-bit descriptor. Note 12-byte descriptor can't always be 8-byte
+  * aligned.
+  */
+ struct sdhci_adma2_64_desc {
+ 	__le16	cmd;
+ 	__le16	len;
+ 	__le32	addr_lo;
+ 	__le32	addr_hi;
+ }  __packed __aligned(4);
+ 
+ #define ADMA2_TRAN_VALID	0x21
+ #define ADMA2_NOP_END_VALID	0x3
+ #define ADMA2_END		0x2
+ 
+ /*
+  * Maximum segments assuming a 512KiB maximum requisition size and a minimum
+  * 4KiB page size.
+  */
+ #define SDHCI_MAX_SEGS		128
+ 
+ enum sdhci_cookie {
+ 	COOKIE_UNMAPPED,
+ 	COOKIE_MAPPED,
+ 	COOKIE_GIVEN,
+ };
+ 
+ struct sdhci_host {
+ 	/* Data set by hardware interface driver */
+ 	const char *hw_name;	/* Hardware bus name */
+ 
+ 	unsigned int quirks;	/* Deviations from spec. */
+ 
+ /* Controller doesn't honor resets unless we touch the clock register */
+ #define SDHCI_QUIRK_CLOCK_BEFORE_RESET			(1<<0)
+ /* Controller has bad caps bits, but really supports DMA */
+ #define SDHCI_QUIRK_FORCE_DMA				(1<<1)
+ /* Controller doesn't like to be reset when there is no card inserted. */
+ #define SDHCI_QUIRK_NO_CARD_NO_RESET			(1<<2)
+ /* Controller doesn't like clearing the power reg before a change */
+ #define SDHCI_QUIRK_SINGLE_POWER_WRITE			(1<<3)
+ /* Controller has flaky internal state so reset it on each ios change */
+ #define SDHCI_QUIRK_RESET_CMD_DATA_ON_IOS		(1<<4)
+ /* Controller has an unusable DMA engine */
+ #define SDHCI_QUIRK_BROKEN_DMA				(1<<5)
+ /* Controller has an unusable ADMA engine */
+ #define SDHCI_QUIRK_BROKEN_ADMA				(1<<6)
+ /* Controller can only DMA from 32-bit aligned addresses */
+ #define SDHCI_QUIRK_32BIT_DMA_ADDR			(1<<7)
+ /* Controller can only DMA chunk sizes that are a multiple of 32 bits */
+ #define SDHCI_QUIRK_32BIT_DMA_SIZE			(1<<8)
+ /* Controller can only ADMA chunks that are a multiple of 32 bits */
+ #define SDHCI_QUIRK_32BIT_ADMA_SIZE			(1<<9)
+ /* Controller needs to be reset after each request to stay stable */
+ #define SDHCI_QUIRK_RESET_AFTER_REQUEST			(1<<10)
+ /* Controller needs voltage and power writes to happen separately */
+ #define SDHCI_QUIRK_NO_SIMULT_VDD_AND_POWER		(1<<11)
+ /* Controller provides an incorrect timeout value for transfers */
+ #define SDHCI_QUIRK_BROKEN_TIMEOUT_VAL			(1<<12)
+ /* Controller has an issue with buffer bits for small transfers */
+ #define SDHCI_QUIRK_BROKEN_SMALL_PIO			(1<<13)
+ /* Controller does not provide transfer-complete interrupt when not busy */
+ #define SDHCI_QUIRK_NO_BUSY_IRQ				(1<<14)
+ /* Controller has unreliable card detection */
+ #define SDHCI_QUIRK_BROKEN_CARD_DETECTION		(1<<15)
+ /* Controller reports inverted write-protect state */
+ #define SDHCI_QUIRK_INVERTED_WRITE_PROTECT		(1<<16)
+ /* Controller does not like fast PIO transfers */
+ #define SDHCI_QUIRK_PIO_NEEDS_DELAY			(1<<18)
+ /* Controller has to be forced to use block size of 2048 bytes */
+ #define SDHCI_QUIRK_FORCE_BLK_SZ_2048			(1<<20)
+ /* Controller cannot do multi-block transfers */
+ #define SDHCI_QUIRK_NO_MULTIBLOCK			(1<<21)
+ /* Controller can only handle 1-bit data transfers */
+ #define SDHCI_QUIRK_FORCE_1_BIT_DATA			(1<<22)
+ /* Controller needs 10ms delay between applying power and clock */
+ #define SDHCI_QUIRK_DELAY_AFTER_POWER			(1<<23)
+ /* Controller uses SDCLK instead of TMCLK for data timeouts */
+ #define SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK		(1<<24)
+ /* Controller reports wrong base clock capability */
+ #define SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN		(1<<25)
+ /* Controller cannot support End Attribute in NOP ADMA descriptor */
+ #define SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC		(1<<26)
+ /* Controller is missing device caps. Use caps provided by host */
+ #define SDHCI_QUIRK_MISSING_CAPS			(1<<27)
+ /* Controller uses Auto CMD12 command to stop the transfer */
+ #define SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12		(1<<28)
+ /* Controller doesn't have HISPD bit field in HI-SPEED SD card */
+ #define SDHCI_QUIRK_NO_HISPD_BIT			(1<<29)
+ /* Controller treats ADMA descriptors with length 0000h incorrectly */
+ #define SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC		(1<<30)
+ /* The read-only detection via SDHCI_PRESENT_STATE register is unstable */
+ #define SDHCI_QUIRK_UNSTABLE_RO_DETECT			(1<<31)
+ 
+ 	unsigned int quirks2;	/* More deviations from spec. */
+ 
+ #define SDHCI_QUIRK2_HOST_OFF_CARD_ON			(1<<0)
+ #define SDHCI_QUIRK2_HOST_NO_CMD23			(1<<1)
+ /* The system physically doesn't support 1.8v, even if the host does */
+ #define SDHCI_QUIRK2_NO_1_8_V				(1<<2)
+ #define SDHCI_QUIRK2_PRESET_VALUE_BROKEN		(1<<3)
+ #define SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON		(1<<4)
+ /* Controller has a non-standard host control register */
+ #define SDHCI_QUIRK2_BROKEN_HOST_CONTROL		(1<<5)
+ /* Controller does not support HS200 */
+ #define SDHCI_QUIRK2_BROKEN_HS200			(1<<6)
+ /* Controller does not support DDR50 */
+ #define SDHCI_QUIRK2_BROKEN_DDR50			(1<<7)
+ /* Stop command (CMD12) can set Transfer Complete when not using MMC_RSP_BUSY */
+ #define SDHCI_QUIRK2_STOP_WITH_TC			(1<<8)
+ /* Controller does not support 64-bit DMA */
+ #define SDHCI_QUIRK2_BROKEN_64_BIT_DMA			(1<<9)
+ /* need clear transfer mode register before send cmd */
+ #define SDHCI_QUIRK2_CLEAR_TRANSFERMODE_REG_BEFORE_CMD	(1<<10)
+ /* Capability register bit-63 indicates HS400 support */
+ #define SDHCI_QUIRK2_CAPS_BIT63_FOR_HS400		(1<<11)
+ /* forced tuned clock */
+ #define SDHCI_QUIRK2_TUNING_WORK_AROUND			(1<<12)
+ /* disable the block count for single block transactions */
+ #define SDHCI_QUIRK2_SUPPORT_SINGLE			(1<<13)
+ /* Controller broken with using ACMD23 */
+ #define SDHCI_QUIRK2_ACMD23_BROKEN			(1<<14)
+ /* Broken Clock divider zero in controller */
+ #define SDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN		(1<<15)
+ /*
+  * When internal clock is disabled, a delay is needed before modifying the
+  * SD clock frequency or enabling back the internal clock.
+  */
+ #define SDHCI_QUIRK2_NEED_DELAY_AFTER_INT_CLK_RST	(1<<16)
+ 
+ 	int irq;		/* Device IRQ */
+ 	void __iomem *ioaddr;	/* Mapped address */
+ 
+ 	const struct sdhci_ops *ops;	/* Low level hw interface */
+ 
+ 	/* Internal data */
+ 	struct mmc_host *mmc;	/* MMC structure */
+ 	u64 dma_mask;		/* custom DMA mask */
+ 
+ #if defined(CONFIG_LEDS_CLASS) || defined(CONFIG_LEDS_CLASS_MODULE)
+ 	struct led_classdev led;	/* LED control */
+ 	char led_name[32];
+ #endif
+ 
+ 	spinlock_t lock;	/* Mutex */
+ 
+ 	int flags;		/* Host attributes */
+ #define SDHCI_USE_SDMA		(1<<0)	/* Host is SDMA capable */
+ #define SDHCI_USE_ADMA		(1<<1)	/* Host is ADMA capable */
+ #define SDHCI_REQ_USE_DMA	(1<<2)	/* Use DMA for this req. */
+ #define SDHCI_DEVICE_DEAD	(1<<3)	/* Device unresponsive */
+ #define SDHCI_SDR50_NEEDS_TUNING (1<<4)	/* SDR50 needs tuning */
+ #define SDHCI_AUTO_CMD12	(1<<6)	/* Auto CMD12 support */
+ #define SDHCI_AUTO_CMD23	(1<<7)	/* Auto CMD23 support */
+ #define SDHCI_PV_ENABLED	(1<<8)	/* Preset value enabled */
+ #define SDHCI_SDIO_IRQ_ENABLED	(1<<9)	/* SDIO irq enabled */
+ #define SDHCI_SDR104_NEEDS_TUNING (1<<10)	/* SDR104/HS200 needs tuning */
+ #define SDHCI_USE_64_BIT_DMA	(1<<12)	/* Use 64-bit DMA */
+ #define SDHCI_HS400_TUNING	(1<<13)	/* Tuning for HS400 */
+ 
+ 	unsigned int version;	/* SDHCI spec. version */
+ 
+ 	unsigned int max_clk;	/* Max possible freq (MHz) */
+ 	unsigned int timeout_clk;	/* Timeout freq (KHz) */
+ 	unsigned int clk_mul;	/* Clock Muliplier value */
+ 
+ 	unsigned int clock;	/* Current clock (MHz) */
+ 	u8 pwr;			/* Current voltage */
+ 
+ 	bool runtime_suspended;	/* Host is runtime suspended */
+ 	bool bus_on;		/* Bus power prevents runtime suspend */
+ 	bool preset_enabled;	/* Preset is enabled */
+ 
+ 	struct mmc_request *mrq;	/* Current request */
+ 	struct mmc_command *cmd;	/* Current command */
+ 	struct mmc_data *data;	/* Current data request */
+ 	unsigned int data_early:1;	/* Data finished before cmd */
+ 	unsigned int busy_handle:1;	/* Handling the order of Busy-end */
+ 
+ 	struct sg_mapping_iter sg_miter;	/* SG state for PIO */
+ 	unsigned int blocks;	/* remaining PIO blocks */
+ 
+ 	int sg_count;		/* Mapped sg entries */
+ 
+ 	void *adma_table;	/* ADMA descriptor table */
+ 	void *align_buffer;	/* Bounce buffer */
+ 
+ 	size_t adma_table_sz;	/* ADMA descriptor table size */
+ 	size_t align_buffer_sz;	/* Bounce buffer size */
+ 
+ 	dma_addr_t adma_addr;	/* Mapped ADMA descr. table */
+ 	dma_addr_t align_addr;	/* Mapped bounce buffer */
+ 
+ 	unsigned int desc_sz;	/* ADMA descriptor size */
+ 
+ 	struct tasklet_struct finish_tasklet;	/* Tasklet structures */
+ 
+ 	struct timer_list timer;	/* Timer for timeouts */
+ 
+ 	u32 caps;		/* Alternative CAPABILITY_0 */
+ 	u32 caps1;		/* Alternative CAPABILITY_1 */
+ 
+ 	unsigned int            ocr_avail_sdio;	/* OCR bit masks */
+ 	unsigned int            ocr_avail_sd;
+ 	unsigned int            ocr_avail_mmc;
+ 	u32 ocr_mask;		/* available voltages */
+ 
+ 	unsigned		timing;		/* Current timing */
+ 
+ 	u32			thread_isr;
+ 
+ 	/* cached registers */
+ 	u32			ier;
+ 
+ 	wait_queue_head_t	buf_ready_int;	/* Waitqueue for Buffer Read Ready interrupt */
+ 	unsigned int		tuning_done;	/* Condition flag set when CMD19 succeeds */
+ 
+ 	unsigned int		tuning_count;	/* Timer count for re-tuning */
+ 	unsigned int		tuning_mode;	/* Re-tuning mode supported by host */
+ #define SDHCI_TUNING_MODE_1	0
+ 
+ 	unsigned long private[0] ____cacheline_aligned;
+ };
+ 
++>>>>>>> 04a5ae6fdd01 (mmc: sdhci: 64-bit DMA actually has 4-byte alignment)
  struct sdhci_ops {
  #ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
  	u32		(*read_l)(struct sdhci_host *host, int reg);
* Unmerged path drivers/mmc/host/sdhci.c
* Unmerged path drivers/mmc/host/sdhci.h
