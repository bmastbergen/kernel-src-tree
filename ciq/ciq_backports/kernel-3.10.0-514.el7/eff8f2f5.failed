mmc: dw_mmc: Use core to handle absent write protect line

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Lars-Peter Clausen <lars@metafoo.de>
commit eff8f2f5df1c509c873cdc70c84eb2ee75b41e65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/eff8f2f5.failed

Use the new MMC_CAP2_NO_WRITE_PROTECT to let the core handle the case where
no write protect line is present instead of having custom driver code to
handle it.

dw_mci_of_get_slot_quirks() is slightly refactored to directly modify the
mmc_host capabilities instead of returning a quirk mask.

	Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
	Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit eff8f2f5df1c509c873cdc70c84eb2ee75b41e65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/dw_mmc.c
#	drivers/mmc/host/dw_mmc.h
diff --cc drivers/mmc/host/dw_mmc.c
index bc4f99ee919c,55179f1001fb..000000000000
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@@ -940,16 -1279,11 +940,21 @@@ static int dw_mci_get_ro(struct mmc_hos
  {
  	int read_only;
  	struct dw_mci_slot *slot = mmc_priv(mmc);
 -	int gpio_ro = mmc_gpio_get_ro(mmc);
 +	struct dw_mci_board *brd = slot->host->pdata;
  
  	/* Use platform get_ro function, else try on board write protect */
++<<<<<<< HEAD
 +	if ((slot->quirks & DW_MCI_SLOT_QUIRK_NO_WRITE_PROTECT) ||
 +			(slot->host->quirks & DW_MCI_QUIRK_NO_WRITE_PROTECT))
 +		read_only = 0;
 +	else if (brd->get_ro)
 +		read_only = brd->get_ro(slot->id);
 +	else if (gpio_is_valid(slot->wp_gpio))
 +		read_only = gpio_get_value(slot->wp_gpio);
++=======
+ 	if (!IS_ERR_VALUE(gpio_ro))
+ 		read_only = gpio_ro;
++>>>>>>> eff8f2f5df1c (mmc: dw_mmc: Use core to handle absent write protect line)
  	else
  		read_only =
  			mci_readl(slot->host, WRTPRT) & (1 << slot->id) ? 1 : 0;
@@@ -1770,117 -2280,11 +1775,118 @@@ static irqreturn_t dw_mci_interrupt(in
  	return IRQ_HANDLED;
  }
  
 +static void dw_mci_work_routine_card(struct work_struct *work)
 +{
 +	struct dw_mci *host = container_of(work, struct dw_mci, card_work);
 +	int i;
 +
 +	for (i = 0; i < host->num_slots; i++) {
 +		struct dw_mci_slot *slot = host->slot[i];
 +		struct mmc_host *mmc = slot->mmc;
 +		struct mmc_request *mrq;
 +		int present;
 +		u32 ctrl;
 +
 +		present = dw_mci_get_cd(mmc);
 +		while (present != slot->last_detect_state) {
 +			dev_dbg(&slot->mmc->class_dev, "card %s\n",
 +				present ? "inserted" : "removed");
 +
 +			spin_lock_bh(&host->lock);
 +
 +			/* Card change detected */
 +			slot->last_detect_state = present;
 +
 +			/* Mark card as present if applicable */
 +			if (present != 0)
 +				set_bit(DW_MMC_CARD_PRESENT, &slot->flags);
 +
 +			/* Clean up queue if present */
 +			mrq = slot->mrq;
 +			if (mrq) {
 +				if (mrq == host->mrq) {
 +					host->data = NULL;
 +					host->cmd = NULL;
 +
 +					switch (host->state) {
 +					case STATE_IDLE:
 +						break;
 +					case STATE_SENDING_CMD:
 +						mrq->cmd->error = -ENOMEDIUM;
 +						if (!mrq->data)
 +							break;
 +						/* fall through */
 +					case STATE_SENDING_DATA:
 +						mrq->data->error = -ENOMEDIUM;
 +						dw_mci_stop_dma(host);
 +						break;
 +					case STATE_DATA_BUSY:
 +					case STATE_DATA_ERROR:
 +						if (mrq->data->error == -EINPROGRESS)
 +							mrq->data->error = -ENOMEDIUM;
 +						if (!mrq->stop)
 +							break;
 +						/* fall through */
 +					case STATE_SENDING_STOP:
 +						mrq->stop->error = -ENOMEDIUM;
 +						break;
 +					}
 +
 +					dw_mci_request_end(host, mrq);
 +				} else {
 +					list_del(&slot->queue_node);
 +					mrq->cmd->error = -ENOMEDIUM;
 +					if (mrq->data)
 +						mrq->data->error = -ENOMEDIUM;
 +					if (mrq->stop)
 +						mrq->stop->error = -ENOMEDIUM;
 +
 +					spin_unlock(&host->lock);
 +					mmc_request_done(slot->mmc, mrq);
 +					spin_lock(&host->lock);
 +				}
 +			}
 +
 +			/* Power down slot */
 +			if (present == 0) {
 +				clear_bit(DW_MMC_CARD_PRESENT, &slot->flags);
 +
 +				/*
 +				 * Clear down the FIFO - doing so generates a
 +				 * block interrupt, hence setting the
 +				 * scatter-gather pointer to NULL.
 +				 */
 +				sg_miter_stop(&host->sg_miter);
 +				host->sg = NULL;
 +
 +				ctrl = mci_readl(host, CTRL);
 +				ctrl |= SDMMC_CTRL_FIFO_RESET;
 +				mci_writel(host, CTRL, ctrl);
 +
 +#ifdef CONFIG_MMC_DW_IDMAC
 +				ctrl = mci_readl(host, BMOD);
 +				/* Software reset of DMA */
 +				ctrl |= SDMMC_IDMAC_SWRESET;
 +				mci_writel(host, BMOD, ctrl);
 +#endif
 +
 +			}
 +
 +			spin_unlock_bh(&host->lock);
 +
 +			present = dw_mci_get_cd(mmc);
 +		}
 +
 +		mmc_detect_change(slot->mmc,
 +			msecs_to_jiffies(host->pdata->detect_delay_ms));
 +	}
 +}
 +
  #ifdef CONFIG_OF
- /* given a slot id, find out the device node representing that slot */
- static struct device_node *dw_mci_of_find_slot_node(struct device *dev, u8 slot)
+ /* given a slot, find out the device node representing that slot */
+ static struct device_node *dw_mci_of_find_slot_node(struct dw_mci_slot *slot)
  {
+ 	struct device *dev = slot->mmc->parent;
  	struct device_node *np;
  	const __be32 *addr;
  	int len;
@@@ -1898,87 -2302,23 +1904,73 @@@
  	return NULL;
  }
  
- static struct dw_mci_of_slot_quirks {
- 	char *quirk;
- 	int id;
- } of_slot_quirks[] = {
- 	{
- 		.quirk	= "disable-wp",
- 		.id	= DW_MCI_SLOT_QUIRK_NO_WRITE_PROTECT,
- 	},
- };
- 
- static int dw_mci_of_get_slot_quirks(struct device *dev, u8 slot)
+ static void dw_mci_slot_of_parse(struct dw_mci_slot *slot)
  {
- 	struct device_node *np = dw_mci_of_find_slot_node(dev, slot);
- 	int quirks = 0;
- 	int idx;
+ 	struct device_node *np = dw_mci_of_find_slot_node(slot);
  
- 	/* get quirks */
- 	for (idx = 0; idx < ARRAY_SIZE(of_slot_quirks); idx++)
- 		if (of_get_property(np, of_slot_quirks[idx].quirk, NULL)) {
- 			dev_warn(dev, "Slot quirk %s is deprecated\n",
- 					of_slot_quirks[idx].quirk);
- 			quirks |= of_slot_quirks[idx].id;
- 		}
+ 	if (!np)
+ 		return;
  
- 	return quirks;
+ 	if (of_property_read_bool(np, "disable-wp")) {
+ 		slot->mmc->caps2 |= MMC_CAP2_NO_WRITE_PROTECT;
+ 		dev_warn(slot->mmc->parent,
+ 			"Slot quirk 'disable-wp' is deprecated\n");
+ 	}
  }
 +
 +/* find out bus-width for a given slot */
 +static u32 dw_mci_of_get_bus_wd(struct device *dev, u8 slot)
 +{
 +	struct device_node *np = dw_mci_of_find_slot_node(dev, slot);
 +	u32 bus_wd = 1;
 +
 +	if (!np)
 +		return 1;
 +
 +	if (of_property_read_u32(np, "bus-width", &bus_wd))
 +		dev_err(dev, "bus-width property not found, assuming width"
 +			       " as 1\n");
 +	return bus_wd;
 +}
 +
 +/* find the write protect gpio for a given slot; or -1 if none specified */
 +static int dw_mci_of_get_wp_gpio(struct device *dev, u8 slot)
 +{
 +	struct device_node *np = dw_mci_of_find_slot_node(dev, slot);
 +	int gpio;
 +
 +	if (!np)
 +		return -EINVAL;
 +
 +	gpio = of_get_named_gpio(np, "wp-gpios", 0);
 +
 +	/* Having a missing entry is valid; return silently */
 +	if (!gpio_is_valid(gpio))
 +		return -EINVAL;
 +
 +	if (devm_gpio_request(dev, gpio, "dw-mci-wp")) {
 +		dev_warn(dev, "gpio [%d] request failed\n", gpio);
 +		return -EINVAL;
 +	}
 +
 +	return gpio;
 +}
  #else /* CONFIG_OF */
- static int dw_mci_of_get_slot_quirks(struct device *dev, u8 slot)
+ static void dw_mci_slot_of_parse(struct dw_mci_slot *slot)
  {
- 	return 0;
  }
 +static u32 dw_mci_of_get_bus_wd(struct device *dev, u8 slot)
 +{
 +	return 1;
 +}
 +static struct device_node *dw_mci_of_find_slot_node(struct device *dev, u8 slot)
 +{
 +	return NULL;
 +}
 +static int dw_mci_of_get_wp_gpio(struct device *dev, u8 slot)
 +{
 +	return -EINVAL;
 +}
  #endif /* CONFIG_OF */
  
  static int dw_mci_init_slot(struct dw_mci *host, unsigned int id)
@@@ -1999,24 -2340,24 +1991,22 @@@
  	slot->host = host;
  	host->slot[id] = slot;
  
- 	slot->quirks = dw_mci_of_get_slot_quirks(host->dev, slot->id);
- 
  	mmc->ops = &dw_mci_ops;
 -	if (of_property_read_u32_array(host->dev->of_node,
 -				       "clock-freq-min-max", freq, 2)) {
 -		mmc->f_min = DW_MCI_FREQ_MIN;
 -		mmc->f_max = DW_MCI_FREQ_MAX;
 -	} else {
 -		mmc->f_min = freq[0];
 -		mmc->f_max = freq[1];
 -	}
 -
 -	/*if there are external regulators, get them*/
 -	ret = mmc_regulator_get_supply(mmc);
 -	if (ret == -EPROBE_DEFER)
 -		goto err_host_allocated;
 +	mmc->f_min = DIV_ROUND_UP(host->bus_hz, 510);
 +	mmc->f_max = host->bus_hz;
  
 -	if (!mmc->ocr_avail)
 +	if (host->pdata->get_ocr)
 +		mmc->ocr_avail = host->pdata->get_ocr(id);
 +	else
  		mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
  
 +	/*
 +	 * Start with slot power disabled, it will be enabled when a card
 +	 * is detected.
 +	 */
 +	if (host->pdata->setpower)
 +		host->pdata->setpower(id, 0);
 +
  	if (host->pdata->caps)
  		mmc->caps = host->pdata->caps;
  
@@@ -2036,22 -2377,11 +2026,30 @@@
  	if (host->pdata->caps2)
  		mmc->caps2 = host->pdata->caps2;
  
++<<<<<<< HEAD
 +	if (host->pdata->get_bus_wd)
 +		bus_width = host->pdata->get_bus_wd(slot->id);
 +	else if (host->dev->of_node)
 +		bus_width = dw_mci_of_get_bus_wd(host->dev, slot->id);
 +	else
 +		bus_width = 1;
 +
 +	switch (bus_width) {
 +	case 8:
 +		mmc->caps |= MMC_CAP_8_BIT_DATA;
 +	case 4:
 +		mmc->caps |= MMC_CAP_4_BIT_DATA;
 +	}
 +
 +	if (host->pdata->quirks & DW_MCI_QUIRK_HIGHSPEED)
 +		mmc->caps |= MMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED;
++=======
+ 	dw_mci_slot_of_parse(slot);
+ 
+ 	ret = mmc_of_parse(mmc);
+ 	if (ret)
+ 		goto err_host_allocated;
++>>>>>>> eff8f2f5df1c (mmc: dw_mmc: Use core to handle absent write protect line)
  
  	if (host->pdata->blk_settings) {
  		mmc->max_segs = host->pdata->blk_settings->max_segs;
@@@ -2187,14 -2604,8 +2185,11 @@@ static struct dw_mci_of_quirks 
  	int id;
  } of_quirks[] = {
  	{
 +		.quirk	= "supports-highspeed",
 +		.id	= DW_MCI_QUIRK_HIGHSPEED,
 +	}, {
  		.quirk	= "broken-cd",
  		.id	= DW_MCI_QUIRK_BROKEN_CARD_DETECTION,
- 	}, {
- 		.quirk	= "disable-wp",
- 		.id	= DW_MCI_QUIRK_NO_WRITE_PROTECT,
  	},
  };
  
diff --cc drivers/mmc/host/dw_mmc.h
index 7f05a02a5484,8ce4674730a6..000000000000
--- a/drivers/mmc/host/dw_mmc.h
+++ b/drivers/mmc/host/dw_mmc.h
@@@ -205,6 -224,43 +205,46 @@@ extern int dw_mci_resume(struct dw_mci 
  #endif
  
  /**
++<<<<<<< HEAD
++=======
+  * struct dw_mci_slot - MMC slot state
+  * @mmc: The mmc_host representing this slot.
+  * @host: The MMC controller this slot is using.
+  * @ctype: Card type for this slot.
+  * @mrq: mmc_request currently being processed or waiting to be
+  *	processed, or NULL when the slot is idle.
+  * @queue_node: List node for placing this node in the @queue list of
+  *	&struct dw_mci.
+  * @clock: Clock rate configured by set_ios(). Protected by host->lock.
+  * @__clk_old: The last updated clock with reflecting clock divider.
+  *	Keeping track of this helps us to avoid spamming the console
+  *	with CONFIG_MMC_CLKGATE.
+  * @flags: Random state bits associated with the slot.
+  * @id: Number of this slot.
+  * @sdio_id: Number of this slot in the SDIO interrupt registers.
+  */
+ struct dw_mci_slot {
+ 	struct mmc_host		*mmc;
+ 	struct dw_mci		*host;
+ 
+ 	u32			ctype;
+ 
+ 	struct mmc_request	*mrq;
+ 	struct list_head	queue_node;
+ 
+ 	unsigned int		clock;
+ 	unsigned int		__clk_old;
+ 
+ 	unsigned long		flags;
+ #define DW_MMC_CARD_PRESENT	0
+ #define DW_MMC_CARD_NEED_INIT	1
+ #define DW_MMC_CARD_NO_LOW_PWR	2
+ 	int			id;
+ 	int			sdio_id;
+ };
+ 
+ /**
++>>>>>>> eff8f2f5df1c (mmc: dw_mmc: Use core to handle absent write protect line)
   * dw_mci driver data - dw-mshc implementation specific driver data.
   * @caps: mmc subsystem specified capabilities of the controller(s).
   * @init: early implementation specific initialization.
* Unmerged path drivers/mmc/host/dw_mmc.c
* Unmerged path drivers/mmc/host/dw_mmc.h
diff --git a/include/linux/mmc/dw_mmc.h b/include/linux/mmc/dw_mmc.h
index a2d9a022a8fd..3bc7fd49eb1b 100644
--- a/include/linux/mmc/dw_mmc.h
+++ b/include/linux/mmc/dw_mmc.h
@@ -211,12 +211,6 @@ struct dw_mci_dma_ops {
 #define DW_MCI_QUIRK_HIGHSPEED			BIT(2)
 /* Unreliable card detection */
 #define DW_MCI_QUIRK_BROKEN_CARD_DETECTION	BIT(3)
-/* No write protect */
-#define DW_MCI_QUIRK_NO_WRITE_PROTECT		BIT(4)
-
-/* Slot level quirks */
-/* This slot has no write protect */
-#define DW_MCI_SLOT_QUIRK_NO_WRITE_PROTECT	BIT(0)
 
 struct dma_pdata;
 
