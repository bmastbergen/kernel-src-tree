IB/core: Initialize sysfs attributes before sysfs create group

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mark Bloch <markb@mellanox.com>
commit 8aec013afe6d9665eb478396026ebd4384dbe934
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8aec013a.failed

For dynamically allocated sysfs attributes there is a need to call
sysfs_attr_init in order to comply with lockdep, not calling it
will result in error complaining key is not in .data section.

Fixes: b40f4757daa1 ("IB/core: Make device counter infrastructure dynamic")
	Signed-off-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 8aec013afe6d9665eb478396026ebd4384dbe934)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/sysfs.c
diff --cc drivers/infiniband/core/sysfs.c
index 38b55b5fac75,a5793c8f1590..000000000000
--- a/drivers/infiniband/core/sysfs.c
+++ b/drivers/infiniband/core/sysfs.c
@@@ -733,6 -747,220 +733,223 @@@ static struct attribute_group *get_coun
  	return &pma_group;
  }
  
++<<<<<<< HEAD
++=======
+ static int update_hw_stats(struct ib_device *dev, struct rdma_hw_stats *stats,
+ 			   u8 port_num, int index)
+ {
+ 	int ret;
+ 
+ 	if (time_is_after_eq_jiffies(stats->timestamp + stats->lifespan))
+ 		return 0;
+ 	ret = dev->get_hw_stats(dev, stats, port_num, index);
+ 	if (ret < 0)
+ 		return ret;
+ 	if (ret == stats->num_counters)
+ 		stats->timestamp = jiffies;
+ 
+ 	return 0;
+ }
+ 
+ static ssize_t print_hw_stat(struct rdma_hw_stats *stats, int index, char *buf)
+ {
+ 	return sprintf(buf, "%llu\n", stats->value[index]);
+ }
+ 
+ static ssize_t show_hw_stats(struct kobject *kobj, struct attribute *attr,
+ 			     char *buf)
+ {
+ 	struct ib_device *dev;
+ 	struct ib_port *port;
+ 	struct hw_stats_attribute *hsa;
+ 	struct rdma_hw_stats *stats;
+ 	int ret;
+ 
+ 	hsa = container_of(attr, struct hw_stats_attribute, attr);
+ 	if (!hsa->port_num) {
+ 		dev = container_of((struct device *)kobj,
+ 				   struct ib_device, dev);
+ 		stats = dev->hw_stats;
+ 	} else {
+ 		port = container_of(kobj, struct ib_port, kobj);
+ 		dev = port->ibdev;
+ 		stats = port->hw_stats;
+ 	}
+ 	ret = update_hw_stats(dev, stats, hsa->port_num, hsa->index);
+ 	if (ret)
+ 		return ret;
+ 	return print_hw_stat(stats, hsa->index, buf);
+ }
+ 
+ static ssize_t show_stats_lifespan(struct kobject *kobj,
+ 				   struct attribute *attr,
+ 				   char *buf)
+ {
+ 	struct hw_stats_attribute *hsa;
+ 	int msecs;
+ 
+ 	hsa = container_of(attr, struct hw_stats_attribute, attr);
+ 	if (!hsa->port_num) {
+ 		struct ib_device *dev = container_of((struct device *)kobj,
+ 						     struct ib_device, dev);
+ 		msecs = jiffies_to_msecs(dev->hw_stats->lifespan);
+ 	} else {
+ 		struct ib_port *p = container_of(kobj, struct ib_port, kobj);
+ 		msecs = jiffies_to_msecs(p->hw_stats->lifespan);
+ 	}
+ 	return sprintf(buf, "%d\n", msecs);
+ }
+ 
+ static ssize_t set_stats_lifespan(struct kobject *kobj,
+ 				  struct attribute *attr,
+ 				  const char *buf, size_t count)
+ {
+ 	struct hw_stats_attribute *hsa;
+ 	int msecs;
+ 	int jiffies;
+ 	int ret;
+ 
+ 	ret = kstrtoint(buf, 10, &msecs);
+ 	if (ret)
+ 		return ret;
+ 	if (msecs < 0 || msecs > 10000)
+ 		return -EINVAL;
+ 	jiffies = msecs_to_jiffies(msecs);
+ 	hsa = container_of(attr, struct hw_stats_attribute, attr);
+ 	if (!hsa->port_num) {
+ 		struct ib_device *dev = container_of((struct device *)kobj,
+ 						     struct ib_device, dev);
+ 		dev->hw_stats->lifespan = jiffies;
+ 	} else {
+ 		struct ib_port *p = container_of(kobj, struct ib_port, kobj);
+ 		p->hw_stats->lifespan = jiffies;
+ 	}
+ 	return count;
+ }
+ 
+ static void free_hsag(struct kobject *kobj, struct attribute_group *attr_group)
+ {
+ 	struct attribute **attr;
+ 
+ 	sysfs_remove_group(kobj, attr_group);
+ 
+ 	for (attr = attr_group->attrs; *attr; attr++)
+ 		kfree(*attr);
+ 	kfree(attr_group);
+ }
+ 
+ static struct attribute *alloc_hsa(int index, u8 port_num, const char *name)
+ {
+ 	struct hw_stats_attribute *hsa;
+ 
+ 	hsa = kmalloc(sizeof(*hsa), GFP_KERNEL);
+ 	if (!hsa)
+ 		return NULL;
+ 
+ 	hsa->attr.name = (char *)name;
+ 	hsa->attr.mode = S_IRUGO;
+ 	hsa->show = show_hw_stats;
+ 	hsa->store = NULL;
+ 	hsa->index = index;
+ 	hsa->port_num = port_num;
+ 
+ 	return &hsa->attr;
+ }
+ 
+ static struct attribute *alloc_hsa_lifespan(char *name, u8 port_num)
+ {
+ 	struct hw_stats_attribute *hsa;
+ 
+ 	hsa = kmalloc(sizeof(*hsa), GFP_KERNEL);
+ 	if (!hsa)
+ 		return NULL;
+ 
+ 	hsa->attr.name = name;
+ 	hsa->attr.mode = S_IWUSR | S_IRUGO;
+ 	hsa->show = show_stats_lifespan;
+ 	hsa->store = set_stats_lifespan;
+ 	hsa->index = 0;
+ 	hsa->port_num = port_num;
+ 
+ 	return &hsa->attr;
+ }
+ 
+ static void setup_hw_stats(struct ib_device *device, struct ib_port *port,
+ 			   u8 port_num)
+ {
+ 	struct attribute_group *hsag;
+ 	struct rdma_hw_stats *stats;
+ 	int i, ret;
+ 
+ 	stats = device->alloc_hw_stats(device, port_num);
+ 
+ 	if (!stats)
+ 		return;
+ 
+ 	if (!stats->names || stats->num_counters <= 0)
+ 		goto err_free_stats;
+ 
+ 	/*
+ 	 * Two extra attribue elements here, one for the lifespan entry and
+ 	 * one to NULL terminate the list for the sysfs core code
+ 	 */
+ 	hsag = kzalloc(sizeof(*hsag) +
+ 		       sizeof(void *) * (stats->num_counters + 2),
+ 		       GFP_KERNEL);
+ 	if (!hsag)
+ 		goto err_free_stats;
+ 
+ 	ret = device->get_hw_stats(device, stats, port_num,
+ 				   stats->num_counters);
+ 	if (ret != stats->num_counters)
+ 		goto err_free_hsag;
+ 
+ 	stats->timestamp = jiffies;
+ 
+ 	hsag->name = "hw_counters";
+ 	hsag->attrs = (void *)hsag + sizeof(*hsag);
+ 
+ 	for (i = 0; i < stats->num_counters; i++) {
+ 		hsag->attrs[i] = alloc_hsa(i, port_num, stats->names[i]);
+ 		if (!hsag->attrs[i])
+ 			goto err;
+ 		sysfs_attr_init(hsag->attrs[i]);
+ 	}
+ 
+ 	/* treat an error here as non-fatal */
+ 	hsag->attrs[i] = alloc_hsa_lifespan("lifespan", port_num);
+ 	if (hsag->attrs[i])
+ 		sysfs_attr_init(hsag->attrs[i]);
+ 
+ 	if (port) {
+ 		struct kobject *kobj = &port->kobj;
+ 		ret = sysfs_create_group(kobj, hsag);
+ 		if (ret)
+ 			goto err;
+ 		port->hw_stats_ag = hsag;
+ 		port->hw_stats = stats;
+ 	} else {
+ 		struct kobject *kobj = &device->dev.kobj;
+ 		ret = sysfs_create_group(kobj, hsag);
+ 		if (ret)
+ 			goto err;
+ 		device->hw_stats_ag = hsag;
+ 		device->hw_stats = stats;
+ 	}
+ 
+ 	return;
+ 
+ err:
+ 	for (; i >= 0; i--)
+ 		kfree(hsag->attrs[i]);
+ err_free_hsag:
+ 	kfree(hsag);
+ err_free_stats:
+ 	kfree(stats);
+ 	return;
+ }
+ 
++>>>>>>> 8aec013afe6d (IB/core: Initialize sysfs attributes before sysfs create group)
  static int add_port(struct ib_device *device, int port_num,
  		    int (*port_callback)(struct ib_device *,
  					 u8, struct kobject *))
* Unmerged path drivers/infiniband/core/sysfs.c
