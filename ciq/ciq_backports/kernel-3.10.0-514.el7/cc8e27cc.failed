net/core: Add support for configuring VF GUIDs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [net] Add support for configuring VF GUIDs (Ivan Vecera) [1268334]
Rebuild_FUZZ: 87.80%
commit-author Eli Cohen <eli@mellanox.com>
commit cc8e27cc97318471b7e707932d5b93b0d5f70830
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/cc8e27cc.failed

Add two new NLAs to support configuration of Infiniband node or port
GUIDs. New applications can choose to use this interface to configure
GUIDs with iproute2 with commands such as:

ip link set dev ib0 vf 0 node_guid 00:02:c9:03:00:21:6e:70
ip link set dev ib0 vf 0 port_guid 00:02:c9:03:00:21:6e:78

A new ndo, ndo_sef_vf_guid is introduced to notify the net device of the
request to change the GUID.

	Signed-off-by: Eli Cohen <eli@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit cc8e27cc97318471b7e707932d5b93b0d5f70830)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	include/uapi/linux/if_link.h
#	net/core/rtnetlink.c
diff --cc include/linux/netdevice.h
index f42ad8e42b23,7b4ae218b90b..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1071,6 -1147,12 +1071,15 @@@ struct net_device_ops 
  						   struct nlattr *port[]);
  	int			(*ndo_get_vf_port)(struct net_device *dev,
  						   int vf, struct sk_buff *skb);
++<<<<<<< HEAD
++=======
+ 	int			(*ndo_set_vf_guid)(struct net_device *dev,
+ 						   int vf, u64 guid,
+ 						   int guid_type);
+ 	int			(*ndo_set_vf_rss_query_en)(
+ 						   struct net_device *dev,
+ 						   int vf, bool setting);
++>>>>>>> cc8e27cc9731 (net/core: Add support for configuring VF GUIDs)
  	int			(*ndo_setup_tc)(struct net_device *dev, u8 tc);
  #if IS_ENABLED(CONFIG_FCOE)
  	int			(*ndo_fcoe_enable)(struct net_device *dev);
diff --cc include/uapi/linux/if_link.h
index 719f99b573ac,1d01e8a4e5dd..000000000000
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@@ -444,6 -555,9 +444,12 @@@ enum 
  				 * on/off switch
  				 */
  	IFLA_VF_STATS,		/* network device statistics */
++<<<<<<< HEAD
++=======
+ 	IFLA_VF_TRUST,		/* Trust VF */
+ 	IFLA_VF_IB_NODE_GUID,	/* VF Infiniband node GUID */
+ 	IFLA_VF_IB_PORT_GUID,	/* VF Infiniband port GUID */
++>>>>>>> cc8e27cc9731 (net/core: Add support for configuring VF GUIDs)
  	__IFLA_VF_MAX,
  };
  
diff --cc net/core/rtnetlink.c
index bca0c57300c0,4b6f3db9f8af..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -1312,6 -1386,9 +1312,12 @@@ static const struct nla_policy ifla_vf_
  	[IFLA_VF_LINK_STATE]	= { .len = sizeof(struct ifla_vf_link_state) },
  	[IFLA_VF_RSS_QUERY_EN]	= { .len = sizeof(struct ifla_vf_rss_query_en) },
  	[IFLA_VF_STATS]		= { .type = NLA_NESTED },
++<<<<<<< HEAD
++=======
+ 	[IFLA_VF_TRUST]		= { .len = sizeof(struct ifla_vf_trust) },
+ 	[IFLA_VF_IB_NODE_GUID]	= { .len = sizeof(struct ifla_vf_guid) },
+ 	[IFLA_VF_IB_PORT_GUID]	= { .len = sizeof(struct ifla_vf_guid) },
++>>>>>>> cc8e27cc9731 (net/core: Add support for configuring VF GUIDs)
  };
  
  static const struct nla_policy ifla_vf_stats_policy[IFLA_VF_STATS_MAX + 1] = {
@@@ -1459,101 -1536,142 +1465,229 @@@ static int validate_linkmsg(struct net_
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int do_setvfinfo(struct net_device *dev, struct nlattr *attr)
++=======
+ static int handle_infiniband_guid(struct net_device *dev, struct ifla_vf_guid *ivt,
+ 				  int guid_type)
+ {
+ 	const struct net_device_ops *ops = dev->netdev_ops;
+ 
+ 	return ops->ndo_set_vf_guid(dev, ivt->vf, ivt->guid, guid_type);
+ }
+ 
+ static int handle_vf_guid(struct net_device *dev, struct ifla_vf_guid *ivt, int guid_type)
+ {
+ 	if (dev->type != ARPHRD_INFINIBAND)
+ 		return -EOPNOTSUPP;
+ 
+ 	return handle_infiniband_guid(dev, ivt, guid_type);
+ }
+ 
+ static int do_setvfinfo(struct net_device *dev, struct nlattr **tb)
++>>>>>>> cc8e27cc9731 (net/core: Add support for configuring VF GUIDs)
  {
 +	int rem, err = -EINVAL;
 +	struct nlattr *vf;
  	const struct net_device_ops *ops = dev->netdev_ops;
 -	int err = -EINVAL;
  
 -	if (tb[IFLA_VF_MAC]) {
 -		struct ifla_vf_mac *ivm = nla_data(tb[IFLA_VF_MAC]);
 +	nla_for_each_nested(vf, attr, rem) {
 +		switch (nla_type(vf)) {
 +		case IFLA_VF_MAC: {
 +			struct ifla_vf_mac *ivm;
 +			ivm = nla_data(vf);
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_mac)
 +				err = ops->ndo_set_vf_mac(dev, ivm->vf,
 +							  ivm->mac);
 +			break;
 +		}
 +		case IFLA_VF_VLAN: {
 +			struct ifla_vf_vlan *ivv;
 +			ivv = nla_data(vf);
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_vlan)
 +				err = ops->ndo_set_vf_vlan(dev, ivv->vf,
 +							   ivv->vlan,
 +							   ivv->qos);
 +			break;
 +		}
 +		case IFLA_VF_TX_RATE: {
 +			struct ifla_vf_tx_rate *ivt;
 +			struct ifla_vf_info ivf;
 +			ivt = nla_data(vf);
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_tx_rate) {
 +				err = ops->ndo_set_vf_tx_rate(dev, ivt->vf,
 +							      ivt->rate);
 +				break;
 +			}
 +			if (ops->ndo_get_vf_config)
 +				err = ops->ndo_get_vf_config(dev, ivt->vf,
 +							     &ivf);
 +			if (err)
 +				break;
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_rate)
 +				err = ops->ndo_set_vf_rate(dev, ivt->vf,
 +							   ivf.min_tx_rate,
 +							   ivt->rate);
 +			break;
 +		}
 +		case IFLA_VF_RATE: {
 +			struct ifla_vf_rate *ivt;
 +			ivt = nla_data(vf);
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_rate)
 +				err = ops->ndo_set_vf_rate(dev, ivt->vf,
 +							   ivt->min_tx_rate,
 +							   ivt->max_tx_rate);
 +			break;
 +		}
 +		case IFLA_VF_SPOOFCHK: {
 +			struct ifla_vf_spoofchk *ivs;
 +			ivs = nla_data(vf);
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_spoofchk)
 +				err = ops->ndo_set_vf_spoofchk(dev, ivs->vf,
 +							       ivs->setting);
 +			break;
 +		}
 +		case IFLA_VF_LINK_STATE: {
 +			struct ifla_vf_link_state *ivl;
 +			ivl = nla_data(vf);
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_link_state)
 +				err = ops->ndo_set_vf_link_state(dev, ivl->vf,
 +								 ivl->link_state);
 +			break;
 +		}
 +		case IFLA_VF_RSS_QUERY_EN: {
 +			struct ifla_vf_rss_query_en *ivrssq_en;
  
 -		err = -EOPNOTSUPP;
 -		if (ops->ndo_set_vf_mac)
 -			err = ops->ndo_set_vf_mac(dev, ivm->vf,
 -						  ivm->mac);
 -		if (err < 0)
 -			return err;
 +			ivrssq_en = nla_data(vf);
 +			err = -EOPNOTSUPP;
 +			if (ops->ndo_set_vf_rss_query_en)
 +				err = ops->ndo_set_vf_rss_query_en(dev,
 +							    ivrssq_en->vf,
 +							    ivrssq_en->setting);
 +			break;
 +		}
 +		default:
 +			err = -EINVAL;
 +			break;
 +		}
 +		if (err)
 +			break;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (tb[IFLA_VF_VLAN]) {
+ 		struct ifla_vf_vlan *ivv = nla_data(tb[IFLA_VF_VLAN]);
+ 
+ 		err = -EOPNOTSUPP;
+ 		if (ops->ndo_set_vf_vlan)
+ 			err = ops->ndo_set_vf_vlan(dev, ivv->vf, ivv->vlan,
+ 						   ivv->qos);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (tb[IFLA_VF_TX_RATE]) {
+ 		struct ifla_vf_tx_rate *ivt = nla_data(tb[IFLA_VF_TX_RATE]);
+ 		struct ifla_vf_info ivf;
+ 
+ 		err = -EOPNOTSUPP;
+ 		if (ops->ndo_get_vf_config)
+ 			err = ops->ndo_get_vf_config(dev, ivt->vf, &ivf);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = -EOPNOTSUPP;
+ 		if (ops->ndo_set_vf_rate)
+ 			err = ops->ndo_set_vf_rate(dev, ivt->vf,
+ 						   ivf.min_tx_rate,
+ 						   ivt->rate);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (tb[IFLA_VF_RATE]) {
+ 		struct ifla_vf_rate *ivt = nla_data(tb[IFLA_VF_RATE]);
+ 
+ 		err = -EOPNOTSUPP;
+ 		if (ops->ndo_set_vf_rate)
+ 			err = ops->ndo_set_vf_rate(dev, ivt->vf,
+ 						   ivt->min_tx_rate,
+ 						   ivt->max_tx_rate);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (tb[IFLA_VF_SPOOFCHK]) {
+ 		struct ifla_vf_spoofchk *ivs = nla_data(tb[IFLA_VF_SPOOFCHK]);
+ 
+ 		err = -EOPNOTSUPP;
+ 		if (ops->ndo_set_vf_spoofchk)
+ 			err = ops->ndo_set_vf_spoofchk(dev, ivs->vf,
+ 						       ivs->setting);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (tb[IFLA_VF_LINK_STATE]) {
+ 		struct ifla_vf_link_state *ivl = nla_data(tb[IFLA_VF_LINK_STATE]);
+ 
+ 		err = -EOPNOTSUPP;
+ 		if (ops->ndo_set_vf_link_state)
+ 			err = ops->ndo_set_vf_link_state(dev, ivl->vf,
+ 							 ivl->link_state);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (tb[IFLA_VF_RSS_QUERY_EN]) {
+ 		struct ifla_vf_rss_query_en *ivrssq_en;
+ 
+ 		err = -EOPNOTSUPP;
+ 		ivrssq_en = nla_data(tb[IFLA_VF_RSS_QUERY_EN]);
+ 		if (ops->ndo_set_vf_rss_query_en)
+ 			err = ops->ndo_set_vf_rss_query_en(dev, ivrssq_en->vf,
+ 							   ivrssq_en->setting);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (tb[IFLA_VF_TRUST]) {
+ 		struct ifla_vf_trust *ivt = nla_data(tb[IFLA_VF_TRUST]);
+ 
+ 		err = -EOPNOTSUPP;
+ 		if (ops->ndo_set_vf_trust)
+ 			err = ops->ndo_set_vf_trust(dev, ivt->vf, ivt->setting);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (tb[IFLA_VF_IB_NODE_GUID]) {
+ 		struct ifla_vf_guid *ivt = nla_data(tb[IFLA_VF_IB_NODE_GUID]);
+ 
+ 		if (!ops->ndo_set_vf_guid)
+ 			return -EOPNOTSUPP;
+ 
+ 		return handle_vf_guid(dev, ivt, IFLA_VF_IB_NODE_GUID);
+ 	}
+ 
+ 	if (tb[IFLA_VF_IB_PORT_GUID]) {
+ 		struct ifla_vf_guid *ivt = nla_data(tb[IFLA_VF_IB_PORT_GUID]);
+ 
+ 		if (!ops->ndo_set_vf_guid)
+ 			return -EOPNOTSUPP;
+ 
+ 		return handle_vf_guid(dev, ivt, IFLA_VF_IB_PORT_GUID);
+ 	}
+ 
++>>>>>>> cc8e27cc9731 (net/core: Add support for configuring VF GUIDs)
  	return err;
  }
  
* Unmerged path include/linux/netdevice.h
* Unmerged path include/uapi/linux/if_link.h
* Unmerged path net/core/rtnetlink.c
