IB/hfi1: Improve LED beaconing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Easwar Hariharan <easwar.hariharan@intel.com>
commit 2243472e9d98c3ca0cb735f96ad48a7b59bdb34d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/2243472e.failed

The current LED beaconing code is unclear and uses the timer handler to
turn off the timer. This patch simplifies the code by removing the
special semantics of timeon = timeoff = 0 being interpreted as a request
to turn off the beaconing.

	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Easwar Hariharan <easwar.hariharan@intel.com>
	Signed-off-by: Jubin John <jubin.john@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 2243472e9d98c3ca0cb735f96ad48a7b59bdb34d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/driver.c
#	drivers/staging/hfi1/mad.c
diff --cc drivers/staging/hfi1/driver.c
index 2fbf6ec51009,914beedb556b..000000000000
--- a/drivers/staging/hfi1/driver.c
+++ b/drivers/staging/hfi1/driver.c
@@@ -1158,6 -1169,12 +1158,15 @@@ void shutdown_led_override(struct hfi1_
  {
  	struct hfi1_devdata *dd = ppd->dd;
  
++<<<<<<< HEAD:drivers/staging/hfi1/driver.c
++=======
+ 	/*
+ 	 * This pairs with the memory barrier in hfi1_start_led_override to
+ 	 * ensure that we read the correct state of LED beaconing represented
+ 	 * by led_override_timer_active
+ 	 */
+ 	smp_rmb();
++>>>>>>> 2243472e9d98 (IB/hfi1: Improve LED beaconing):drivers/staging/rdma/hfi1/driver.c
  	if (atomic_read(&ppd->led_override_timer_active)) {
  		del_timer_sync(&ppd->led_override_timer);
  		atomic_set(&ppd->led_override_timer_active, 0);
@@@ -1184,15 -1205,7 +1197,19 @@@ static void run_led_override(unsigned l
  	/* Set up for next phase */
  	ppd->led_override_phase = !ppd->led_override_phase;
  
++<<<<<<< HEAD:drivers/staging/hfi1/driver.c
 +	/*
 +	 * don't re-fire the timer if user asked for it to be off; we let
 +	 * it fire one more time after they turn it off to simplify
 +	 */
 +	if (ppd->led_override_vals[0] || ppd->led_override_vals[1])
 +		mod_timer(&ppd->led_override_timer, jiffies + timeout);
 +	else
 +		/* Hand control of the LED to the DC for normal operation */
 +		write_csr(dd, DCC_CFG_LED_CNTRL, 0);
++=======
+ 	mod_timer(&ppd->led_override_timer, jiffies + timeout);
++>>>>>>> 2243472e9d98 (IB/hfi1: Improve LED beaconing):drivers/staging/rdma/hfi1/driver.c
  }
  
  /*
@@@ -1215,19 -1229,16 +1233,24 @@@ void hfi1_start_led_override(struct hfi
  
  	/*
  	 * If the timer has not already been started, do so. Use a "quick"
- 	 * timeout so the function will be called soon, to look at our request.
+ 	 * timeout so the handler will be called soon to look at our request.
  	 */
++<<<<<<< HEAD:drivers/staging/hfi1/driver.c
 +	if (atomic_inc_return(&ppd->led_override_timer_active) == 1) {
 +		/* Need to start timer */
 +		init_timer(&ppd->led_override_timer);
 +		ppd->led_override_timer.function = run_led_override;
 +		ppd->led_override_timer.data = (unsigned long) ppd;
++=======
+ 	if (!timer_pending(&ppd->led_override_timer)) {
+ 		setup_timer(&ppd->led_override_timer, run_led_override,
+ 			    (unsigned long)ppd);
++>>>>>>> 2243472e9d98 (IB/hfi1: Improve LED beaconing):drivers/staging/rdma/hfi1/driver.c
  		ppd->led_override_timer.expires = jiffies + 1;
  		add_timer(&ppd->led_override_timer);
- 	} else {
- 		if (ppd->led_override_vals[0] || ppd->led_override_vals[1])
- 			mod_timer(&ppd->led_override_timer, jiffies + 1);
- 		atomic_dec(&ppd->led_override_timer_active);
+ 		atomic_set(&ppd->led_override_timer_active, 1);
+ 		/* Ensure the atomic_set is visible to all CPUs */
+ 		smp_wmb();
  	}
  }
  
diff --cc drivers/staging/hfi1/mad.c
index 4900f79eb54a,0ec748e7e7b6..000000000000
--- a/drivers/staging/hfi1/mad.c
+++ b/drivers/staging/hfi1/mad.c
@@@ -577,6 -582,14 +577,17 @@@ static int __subn_get_opa_portinfo(stru
  	pi->port_states.ledenable_offlinereason = ppd->neighbor_normal << 4;
  	pi->port_states.ledenable_offlinereason |=
  		ppd->is_sm_config_started << 5;
++<<<<<<< HEAD:drivers/staging/hfi1/mad.c
++=======
+ 	/*
+ 	 * This pairs with the memory barrier in hfi1_start_led_override to
+ 	 * ensure that we read the correct state of LED beaconing represented
+ 	 * by led_override_timer_active
+ 	 */
+ 	smp_rmb();
+ 	is_beaconing_active = !!atomic_read(&ppd->led_override_timer_active);
+ 	pi->port_states.ledenable_offlinereason |= is_beaconing_active << 6;
++>>>>>>> 2243472e9d98 (IB/hfi1: Improve LED beaconing):drivers/staging/rdma/hfi1/mad.c
  	pi->port_states.ledenable_offlinereason |=
  		ppd->offline_disabled_reason;
  #else
@@@ -3554,10 -3597,14 +3565,21 @@@ static int __subn_get_opa_led_info(stru
  		return reply((struct ib_mad_hdr *)smp);
  	}
  
++<<<<<<< HEAD:drivers/staging/hfi1/mad.c
 +	reg = read_csr(dd, DCC_CFG_LED_CNTRL);
 +	if ((reg & DCC_CFG_LED_CNTRL_LED_CNTRL_SMASK) &&
 +		((reg & DCC_CFG_LED_CNTRL_LED_SW_BLINK_RATE_SMASK) == 0xf))
 +			p->rsvd_led_mask = cpu_to_be32(OPA_LED_MASK);
++=======
+ 	/*
+ 	 * This pairs with the memory barrier in hfi1_start_led_override to
+ 	 * ensure that we read the correct state of LED beaconing represented
+ 	 * by led_override_timer_active
+ 	 */
+ 	smp_rmb();
+ 	is_beaconing_active = !!atomic_read(&ppd->led_override_timer_active);
+ 	p->rsvd_led_mask = cpu_to_be32(is_beaconing_active << OPA_LED_SHIFT);
++>>>>>>> 2243472e9d98 (IB/hfi1: Improve LED beaconing):drivers/staging/rdma/hfi1/mad.c
  
  	if (resp_len)
  		*resp_len += sizeof(struct opa_led_info);
* Unmerged path drivers/staging/hfi1/driver.c
diff --git a/drivers/staging/hfi1/hfi.h b/drivers/staging/hfi1/hfi.h
index 6438dccf5749..a8afd28315f6 100644
--- a/drivers/staging/hfi1/hfi.h
+++ b/drivers/staging/hfi1/hfi.h
@@ -1581,13 +1581,9 @@ void hfi1_free_devdata(struct hfi1_devdata *);
 void cc_state_reclaim(struct rcu_head *rcu);
 struct hfi1_devdata *hfi1_alloc_devdata(struct pci_dev *pdev, size_t extra);
 
-void hfi1_set_led_override(struct hfi1_pportdata *ppd, unsigned int timeon,
-			   unsigned int timeoff);
-/*
- * Only to be used for driver unload or device reset where we cannot allow
- * the timer to fire even the one extra time, else use hfi1_set_led_override
- * with timeon = timeoff = 0
- */
+/* LED beaconing functions */
+void hfi1_start_led_override(struct hfi1_pportdata *ppd, unsigned int timeon,
+			     unsigned int timeoff);
 void shutdown_led_override(struct hfi1_pportdata *ppd);
 
 #define HFI1_CREDIT_RETURN_RATE (100)
* Unmerged path drivers/staging/hfi1/mad.c
