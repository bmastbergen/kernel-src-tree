perf thread_map: Add thread_map event sythesize function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 99471c967a00c875bb5d61f377d4267904545499
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/99471c96.failed

Introduce the perf_event__synthesize_thread_map2 function to synthesize
struct thread_map.

The perf_event__synthesize_thread_map name is already taken for
synthesizing the complete threads data (comm/mmap/fork).

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Kan Liang <kan.liang@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1445784728-21732-5-git-send-email-jolsa@kernel.org
[ Rename thread_map_data_event to thread_map_event_entry ]
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 99471c967a00c875bb5d61f377d4267904545499)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/tests/builtin-test.c
#	tools/perf/tests/tests.h
#	tools/perf/util/event.h
diff --cc tools/perf/tests/builtin-test.c
index 2337c002804d,745bdb02d22b..000000000000
--- a/tools/perf/tests/builtin-test.c
+++ b/tools/perf/tests/builtin-test.c
@@@ -178,6 -158,32 +178,35 @@@ static struct test generic_tests[] = 
  		.func = test__thread_map,
  	},
  	{
++<<<<<<< HEAD
++=======
+ 		.desc = "Test LLVM searching and compiling",
+ 		.func = test__llvm,
+ 		.subtest = {
+ 			.skip_if_fail	= true,
+ 			.get_nr		= test__llvm_subtest_get_nr,
+ 			.get_desc	= test__llvm_subtest_get_desc,
+ 		},
+ 	},
+ 	{
+ 		.desc = "Test topology in session",
+ 		.func = test_session_topology,
+ 	},
+ 	{
+ 		.desc = "Test BPF filter",
+ 		.func = test__bpf,
+ 		.subtest = {
+ 			.skip_if_fail	= true,
+ 			.get_nr		= test__bpf_subtest_get_nr,
+ 			.get_desc	= test__bpf_subtest_get_desc,
+ 		},
+ 	},
+ 	{
+ 		.desc = "Test thread map synthesize",
+ 		.func = test__thread_map_synthesize,
+ 	},
+ 	{
++>>>>>>> 99471c967a00 (perf thread_map: Add thread_map event sythesize function)
  		.func = NULL,
  	},
  };
diff --cc tools/perf/tests/tests.h
index a08027794fa0,3fe52ccc4d05..000000000000
--- a/tools/perf/tests/tests.h
+++ b/tools/perf/tests/tests.h
@@@ -30,45 -37,51 +30,91 @@@ struct test 
  };
  
  /* Tests */
++<<<<<<< HEAD
 +int test__vmlinux_matches_kallsyms(void);
 +int test__openat_syscall_event(void);
 +int test__openat_syscall_event_on_all_cpus(void);
 +int test__basic_mmap(void);
 +int test__PERF_RECORD(void);
 +int test__rdpmc(void);
 +int test__perf_evsel__roundtrip_name_test(void);
 +int test__perf_evsel__tp_sched_test(void);
 +int test__syscall_openat_tp_fields(void);
 +int test__pmu(void);
 +int test__attr(void);
 +int test__dso_data(void);
 +int test__dso_data_cache(void);
 +int test__dso_data_reopen(void);
 +int test__parse_events(void);
 +int test__hists_link(void);
 +int test__python_use(void);
 +int test__bp_signal(void);
 +int test__bp_signal_overflow(void);
 +int test__task_exit(void);
 +int test__sw_clock_freq(void);
 +int test__perf_time_to_tsc(void);
 +int test__code_reading(void);
 +int test__sample_parsing(void);
 +int test__keep_tracking(void);
 +int test__parse_no_sample_id_all(void);
 +int test__dwarf_unwind(void);
 +int test__hists_filter(void);
 +int test__mmap_thread_lookup(void);
 +int test__thread_mg_share(void);
 +int test__hists_output(void);
 +int test__hists_cumulate(void);
 +int test__switch_tracking(void);
 +int test__fdarray__filter(void);
 +int test__fdarray__add(void);
 +int test__kmod_path__parse(void);
 +int test__thread_map(void);
++=======
+ int test__vmlinux_matches_kallsyms(int subtest);
+ int test__openat_syscall_event(int subtest);
+ int test__openat_syscall_event_on_all_cpus(int subtest);
+ int test__basic_mmap(int subtest);
+ int test__PERF_RECORD(int subtest);
+ int test__perf_evsel__roundtrip_name_test(int subtest);
+ int test__perf_evsel__tp_sched_test(int subtest);
+ int test__syscall_openat_tp_fields(int subtest);
+ int test__pmu(int subtest);
+ int test__attr(int subtest);
+ int test__dso_data(int subtest);
+ int test__dso_data_cache(int subtest);
+ int test__dso_data_reopen(int subtest);
+ int test__parse_events(int subtest);
+ int test__hists_link(int subtest);
+ int test__python_use(int subtest);
+ int test__bp_signal(int subtest);
+ int test__bp_signal_overflow(int subtest);
+ int test__task_exit(int subtest);
+ int test__sw_clock_freq(int subtest);
+ int test__code_reading(int subtest);
+ int test__sample_parsing(int subtest);
+ int test__keep_tracking(int subtest);
+ int test__parse_no_sample_id_all(int subtest);
+ int test__dwarf_unwind(int subtest);
+ int test__hists_filter(int subtest);
+ int test__mmap_thread_lookup(int subtest);
+ int test__thread_mg_share(int subtest);
+ int test__hists_output(int subtest);
+ int test__hists_cumulate(int subtest);
+ int test__switch_tracking(int subtest);
+ int test__fdarray__filter(int subtest);
+ int test__fdarray__add(int subtest);
+ int test__kmod_path__parse(int subtest);
+ int test__thread_map(int subtest);
+ int test__llvm(int subtest);
+ const char *test__llvm_subtest_get_desc(int subtest);
+ int test__llvm_subtest_get_nr(void);
+ int test__bpf(int subtest);
+ const char *test__bpf_subtest_get_desc(int subtest);
+ int test__bpf_subtest_get_nr(void);
+ int test_session_topology(int subtest);
+ int test__thread_map_synthesize(int subtest);
++>>>>>>> 99471c967a00 (perf thread_map: Add thread_map event sythesize function)
  
 -#if defined(__arm__) || defined(__aarch64__)
 +#if defined(__x86_64__) || defined(__i386__) || defined(__arm__) || defined(__aarch64__)
  #ifdef HAVE_DWARF_UNWIND_SUPPORT
  struct thread;
  struct perf_sample;
diff --cc tools/perf/util/event.h
index 9400ef1c1335,952dd4d83f81..000000000000
--- a/tools/perf/util/event.h
+++ b/tools/perf/util/event.h
@@@ -386,10 -406,16 +386,19 @@@ typedef int (*perf_event__handler_t)(st
  int perf_event__synthesize_thread_map(struct perf_tool *tool,
  				      struct thread_map *threads,
  				      perf_event__handler_t process,
++<<<<<<< HEAD
 +				      struct machine *machine, bool mmap_data);
++=======
+ 				      struct machine *machine, bool mmap_data,
+ 				      unsigned int proc_map_timeout);
+ int perf_event__synthesize_thread_map2(struct perf_tool *tool,
+ 				      struct thread_map *threads,
+ 				      perf_event__handler_t process,
+ 				      struct machine *machine);
++>>>>>>> 99471c967a00 (perf thread_map: Add thread_map event sythesize function)
  int perf_event__synthesize_threads(struct perf_tool *tool,
  				   perf_event__handler_t process,
 -				   struct machine *machine, bool mmap_data,
 -				   unsigned int proc_map_timeout);
 +				   struct machine *machine, bool mmap_data);
  int perf_event__synthesize_kernel_mmap(struct perf_tool *tool,
  				       perf_event__handler_t process,
  				       struct machine *machine);
* Unmerged path tools/perf/tests/builtin-test.c
* Unmerged path tools/perf/tests/tests.h
diff --git a/tools/perf/tests/thread-map.c b/tools/perf/tests/thread-map.c
index 138a0e3431fa..4a363606e0c7 100644
--- a/tools/perf/tests/thread-map.c
+++ b/tools/perf/tests/thread-map.c
@@ -40,3 +40,32 @@ int test__thread_map(void)
 	thread_map__put(map);
 	return 0;
 }
+
+static int process_event(struct perf_tool *tool __maybe_unused,
+			 union perf_event *event,
+			 struct perf_sample *sample __maybe_unused,
+			 struct machine *machine __maybe_unused)
+{
+	struct thread_map_event *map = &event->thread_map;
+
+	TEST_ASSERT_VAL("wrong nr",   map->nr == 1);
+	TEST_ASSERT_VAL("wrong pid",  map->entries[0].pid == (u64) getpid());
+	TEST_ASSERT_VAL("wrong comm", !strcmp(map->entries[0].comm, "perf"));
+	return 0;
+}
+
+int test__thread_map_synthesize(int subtest __maybe_unused)
+{
+	struct thread_map *threads;
+
+	/* test map on current pid */
+	threads = thread_map__new_by_pid(getpid());
+	TEST_ASSERT_VAL("failed to alloc map", threads);
+
+	thread_map__read_comms(threads);
+
+	TEST_ASSERT_VAL("failed to synthesize map",
+		!perf_event__synthesize_thread_map2(NULL, threads, process_event, NULL));
+
+	return 0;
+}
diff --git a/tools/perf/util/event.c b/tools/perf/util/event.c
index 763fbcde76fc..5adfde1a53d1 100644
--- a/tools/perf/util/event.c
+++ b/tools/perf/util/event.c
@@ -687,6 +687,42 @@ int perf_event__synthesize_kernel_mmap(struct perf_tool *tool,
 	return err;
 }
 
+int perf_event__synthesize_thread_map2(struct perf_tool *tool,
+				      struct thread_map *threads,
+				      perf_event__handler_t process,
+				      struct machine *machine)
+{
+	union perf_event *event;
+	int i, err, size;
+
+	size  = sizeof(event->thread_map);
+	size +=	threads->nr * sizeof(event->thread_map.entries[0]);
+
+	event = zalloc(size);
+	if (!event)
+		return -ENOMEM;
+
+	event->header.type = PERF_RECORD_THREAD_MAP;
+	event->header.size = size;
+	event->thread_map.nr = threads->nr;
+
+	for (i = 0; i < threads->nr; i++) {
+		struct thread_map_event_entry *entry = &event->thread_map.entries[i];
+		char *comm = thread_map__comm(threads, i);
+
+		if (!comm)
+			comm = (char *) "";
+
+		entry->pid = thread_map__pid(threads, i);
+		strncpy((char *) &entry->comm, comm, sizeof(entry->comm));
+	}
+
+	err = process(tool, event, NULL, machine);
+
+	free(event);
+	return err;
+}
+
 size_t perf_event__fprintf_comm(union perf_event *event, FILE *fp)
 {
 	const char *s;
* Unmerged path tools/perf/util/event.h
