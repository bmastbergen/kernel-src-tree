staging/rdma/hfi1: Remove CQ data structures and functions from hfi1

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [infiniband] rdma/hfi1: Remove CQ data structures and functions from hfi1 (Alex Estrin) [1272062 1273170]
Rebuild_FUZZ: 93.75%
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit abd712daeeb4461aee5ca5a2bfe2717dc22577ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/abd712da.failed

The completion queue is not a complex data structure and it can be removed
at the same time as its functions. Unlike the more complicated queue pair
which was done in multiple patches. This single patch removes all traces
of hfi1 specific completeion queues from the hfi1 driver.

	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Reviewed-by: Harish Chegondi <harish.chegondi@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit abd712daeeb4461aee5ca5a2bfe2717dc22577ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/hfi1/Makefile
#	drivers/staging/hfi1/cq.c
#	drivers/staging/hfi1/ud.c
#	drivers/staging/hfi1/verbs.c
#	drivers/staging/rdma/hfi1/verbs.h
diff --cc drivers/staging/hfi1/Makefile
index 2e5daa6cdcc2,7797f2c0f01f..000000000000
--- a/drivers/staging/hfi1/Makefile
+++ b/drivers/staging/hfi1/Makefile
@@@ -7,10 -7,10 +7,15 @@@
  #
  obj-$(CONFIG_INFINIBAND_HFI1) += hfi1.o
  
++<<<<<<< HEAD:drivers/staging/hfi1/Makefile
 +hfi1-y := chip.o cq.o device.o diag.o dma.o driver.o eprom.o file_ops.o firmware.o \
 +	init.o intr.o keys.o mad.o mmap.o mr.o pcie.o pio.o pio_copy.o \
++=======
+ hfi1-y := chip.o device.o diag.o driver.o efivar.o eprom.o file_ops.o firmware.o \
+ 	init.o intr.o mad.o pcie.o pio.o pio_copy.o \
++>>>>>>> abd712daeeb4 (staging/rdma/hfi1: Remove CQ data structures and functions from hfi1):drivers/staging/rdma/hfi1/Makefile
  	qp.o qsfp.o rc.o ruc.o sdma.o srq.o sysfs.o trace.o twsi.o \
 -	uc.o ud.o user_exp_rcv.o user_pages.o user_sdma.o verbs_mcast.o verbs.o
 +	uc.o ud.o user_pages.o user_sdma.o verbs_mcast.o verbs.o
  hfi1-$(CONFIG_DEBUG_FS) += debugfs.o
  
  CFLAGS_trace.o = -I$(src)
diff --cc drivers/staging/hfi1/ud.c
index a7f67b0111da,a4746e83999d..000000000000
--- a/drivers/staging/hfi1/ud.c
+++ b/drivers/staging/hfi1/ud.c
@@@ -247,9 -247,9 +247,15 @@@ static void ud_loopback(struct hfi1_qp 
  	wc.dlid_path_bits = ah_attr->dlid & ((1 << ppd->lmc) - 1);
  	wc.port_num = qp->port_num;
  	/* Signal completion event if the solicited bit is set. */
++<<<<<<< HEAD:drivers/staging/hfi1/ud.c
 +	hfi1_cq_enter(to_icq(qp->ibqp.recv_cq), &wc,
 +		      swqe->wr.send_flags & IB_SEND_SOLICITED);
 +	ibp->n_loop_pkts++;
++=======
+ 	rvt_cq_enter(ibcq_to_rvtcq(qp->ibqp.recv_cq), &wc,
+ 		     swqe->wr.send_flags & IB_SEND_SOLICITED);
+ 	ibp->rvp.n_loop_pkts++;
++>>>>>>> abd712daeeb4 (staging/rdma/hfi1: Remove CQ data structures and functions from hfi1):drivers/staging/rdma/hfi1/ud.c
  bail_unlock:
  	spin_unlock_irqrestore(&qp->r_lock, flags);
  drop:
diff --cc drivers/staging/hfi1/verbs.c
index d228eb7fc4f0,ee969d0dcd77..000000000000
--- a/drivers/staging/hfi1/verbs.c
+++ b/drivers/staging/hfi1/verbs.c
@@@ -1849,8 -1719,6 +1849,11 @@@ int hfi1_register_ib_device(struct hfi1
  
  	/* Only need to initialize non-zero fields. */
  
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +	spin_lock_init(&dev->n_ahs_lock);
 +	spin_lock_init(&dev->n_cqs_lock);
++=======
++>>>>>>> abd712daeeb4 (staging/rdma/hfi1: Remove CQ data structures and functions from hfi1):drivers/staging/rdma/hfi1/verbs.c
  	spin_lock_init(&dev->n_qps_lock);
  	spin_lock_init(&dev->n_srqs_lock);
  	spin_lock_init(&dev->n_mcast_grps_lock);
@@@ -1974,22 -1815,20 +1977,39 @@@
  	ibdev->post_send = post_send;
  	ibdev->post_recv = post_receive;
  	ibdev->post_srq_recv = hfi1_post_srq_receive;
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +	ibdev->create_cq = hfi1_create_cq;
 +	ibdev->destroy_cq = hfi1_destroy_cq;
 +	ibdev->resize_cq = hfi1_resize_cq;
 +	ibdev->poll_cq = hfi1_poll_cq;
 +	ibdev->req_notify_cq = hfi1_req_notify_cq;
 +	ibdev->get_dma_mr = hfi1_get_dma_mr;
 +	ibdev->reg_phys_mr = hfi1_reg_phys_mr;
 +	ibdev->reg_user_mr = hfi1_reg_user_mr;
 +	ibdev->dereg_mr = hfi1_dereg_mr;
 +	ibdev->alloc_mr = hfi1_alloc_mr;
 +	ibdev->alloc_fast_reg_page_list = hfi1_alloc_fast_reg_page_list;
 +	ibdev->free_fast_reg_page_list = hfi1_free_fast_reg_page_list;
 +	ibdev->alloc_fmr = hfi1_alloc_fmr;
 +	ibdev->map_phys_fmr = hfi1_map_phys_fmr;
 +	ibdev->unmap_fmr = hfi1_unmap_fmr;
 +	ibdev->dealloc_fmr = hfi1_dealloc_fmr;
++=======
+ 	ibdev->create_cq = NULL;
+ 	ibdev->destroy_cq = NULL;
+ 	ibdev->resize_cq = NULL;
+ 	ibdev->poll_cq = NULL;
+ 	ibdev->req_notify_cq = NULL;
+ 	ibdev->get_dma_mr = NULL;
+ 	ibdev->reg_user_mr = NULL;
+ 	ibdev->dereg_mr = NULL;
+ 	ibdev->alloc_mr = NULL;
+ 	ibdev->map_mr_sg = NULL;
+ 	ibdev->alloc_fmr = NULL;
+ 	ibdev->map_phys_fmr = NULL;
+ 	ibdev->unmap_fmr = NULL;
+ 	ibdev->dealloc_fmr = NULL;
++>>>>>>> abd712daeeb4 (staging/rdma/hfi1: Remove CQ data structures and functions from hfi1):drivers/staging/rdma/hfi1/verbs.c
  	ibdev->attach_mcast = hfi1_multicast_attach;
  	ibdev->detach_mcast = hfi1_multicast_detach;
  	ibdev->process_mad = hfi1_process_mad;
@@@ -2000,7 -1839,52 +2020,56 @@@
  	strncpy(ibdev->node_desc, init_utsname()->nodename,
  		sizeof(ibdev->node_desc));
  
++<<<<<<< HEAD:drivers/staging/hfi1/verbs.c
 +	ret = ib_register_device(ibdev, hfi1_create_port_files);
++=======
+ 	/*
+ 	 * Fill in rvt info object.
+ 	 */
+ 	dd->verbs_dev.rdi.driver_f.port_callback = hfi1_create_port_files;
+ 	dd->verbs_dev.rdi.driver_f.get_card_name = get_card_name;
+ 	dd->verbs_dev.rdi.driver_f.get_pci_dev = get_pci_dev;
+ 	dd->verbs_dev.rdi.driver_f.check_ah = hfi1_check_ah;
+ 	dd->verbs_dev.rdi.driver_f.notify_new_ah = hfi1_notify_new_ah;
+ 	/*
+ 	 * Fill in rvt info device attributes.
+ 	 */
+ 	hfi1_fill_device_attr(dd);
+ 
+ 	/* queue pair */
+ 	dd->verbs_dev.rdi.dparms.qp_table_size = hfi1_qp_table_size;
+ 	dd->verbs_dev.rdi.dparms.qpn_start = 0;
+ 	dd->verbs_dev.rdi.dparms.qpn_inc = 1;
+ 	dd->verbs_dev.rdi.dparms.qos_shift = dd->qos_shift;
+ 	dd->verbs_dev.rdi.dparms.qpn_res_start = kdeth_qp << 16;
+ 	dd->verbs_dev.rdi.dparms.qpn_res_end =
+ 	dd->verbs_dev.rdi.dparms.qpn_res_start + 65535;
+ 	dd->verbs_dev.rdi.driver_f.qp_priv_alloc = qp_priv_alloc;
+ 	dd->verbs_dev.rdi.driver_f.qp_priv_free = qp_priv_free;
+ 	dd->verbs_dev.rdi.driver_f.free_all_qps = free_all_qps;
+ 	dd->verbs_dev.rdi.driver_f.notify_qp_reset = notify_qp_reset;
+ 
+ 	/* completeion queue */
+ 	snprintf(dd->verbs_dev.rdi.dparms.cq_name,
+ 		 sizeof(dd->verbs_dev.rdi.dparms.cq_name),
+ 		 "hfi1_cq%d", dd->unit);
+ 	dd->verbs_dev.rdi.dparms.node = dd->assigned_node_id;
+ 
+ 	/* misc settings */
+ 	dd->verbs_dev.rdi.flags = 0; /* Let rdmavt handle it all */
+ 	dd->verbs_dev.rdi.dparms.lkey_table_size = hfi1_lkey_table_size;
+ 	dd->verbs_dev.rdi.dparms.nports = dd->num_pports;
+ 	dd->verbs_dev.rdi.dparms.npkeys = hfi1_get_npkeys(dd);
+ 
+ 	ppd = dd->pport;
+ 	for (i = 0; i < dd->num_pports; i++, ppd++)
+ 		rvt_init_port(&dd->verbs_dev.rdi,
+ 			      &ppd->ibport_data.rvp,
+ 			      i,
+ 			      ppd->pkeys);
+ 
+ 	ret = rvt_register_device(&dd->verbs_dev.rdi);
++>>>>>>> abd712daeeb4 (staging/rdma/hfi1: Remove CQ data structures and functions from hfi1):drivers/staging/rdma/hfi1/verbs.c
  	if (ret)
  		goto err_reg;
  
* Unmerged path drivers/staging/hfi1/cq.c
* Unmerged path drivers/staging/rdma/hfi1/verbs.h
* Unmerged path drivers/staging/hfi1/Makefile
* Unmerged path drivers/staging/hfi1/cq.c
diff --git a/drivers/staging/hfi1/hfi.h b/drivers/staging/hfi1/hfi.h
index e9ab6719e29f..0f8296f2b7cd 100644
--- a/drivers/staging/hfi1/hfi.h
+++ b/drivers/staging/hfi1/hfi.h
@@ -1020,8 +1020,6 @@ struct hfi1_devdata {
 	u16 psxmitwait_check_rate;
 	/* high volume overflow errors deferred to tasklet */
 	struct tasklet_struct error_tasklet;
-	/* per device cq worker */
-	struct kthread_worker *worker;
 
 	/* MSI-X information */
 	struct hfi1_msix_entry *msix_entries;
diff --git a/drivers/staging/hfi1/init.c b/drivers/staging/hfi1/init.c
index bc2846ba67c5..686819552e27 100644
--- a/drivers/staging/hfi1/init.c
+++ b/drivers/staging/hfi1/init.c
@@ -764,7 +764,6 @@ int hfi1_init(struct hfi1_devdata *dd, int reinit)
 	/* enable chip even if we have an error, so we can debug cause */
 	enable_chip(dd);
 
-	ret = hfi1_cq_init(dd);
 done:
 	/*
 	 * Set status even if port serdes is not initialized
@@ -1314,7 +1313,6 @@ static void cleanup_device_data(struct hfi1_devdata *dd)
 	kfree(dd->boardname);
 	vfree(dd->events);
 	vfree(dd->status);
-	hfi1_cq_exit(dd);
 }
 
 /*
diff --git a/drivers/staging/hfi1/qp.c b/drivers/staging/hfi1/qp.c
index 9ffed6e14d8e..4bedc2b6e8ce 100644
--- a/drivers/staging/hfi1/qp.c
+++ b/drivers/staging/hfi1/qp.c
@@ -509,7 +509,7 @@ int hfi1_error_qp(struct hfi1_qp *qp, enum ib_wc_status err)
 	if (test_and_clear_bit(HFI1_R_WRID_VALID, &qp->r_aflags)) {
 		wc.wr_id = qp->r_wr_id;
 		wc.status = err;
-		hfi1_cq_enter(to_icq(qp->ibqp.recv_cq), &wc, 1);
+		rvt_cq_enter(ibcq_to_rvtcq(qp->ibqp.recv_cq), &wc, 1);
 	}
 	wc.status = IB_WC_WR_FLUSH_ERR;
 
@@ -532,7 +532,7 @@ int hfi1_error_qp(struct hfi1_qp *qp, enum ib_wc_status err)
 			wc.wr_id = get_rwqe_ptr(&qp->r_rq, tail)->wr_id;
 			if (++tail >= qp->r_rq.size)
 				tail = 0;
-			hfi1_cq_enter(to_icq(qp->ibqp.recv_cq), &wc, 1);
+			rvt_cq_enter(ibcq_to_rvtcq(qp->ibqp.recv_cq), &wc, 1);
 		}
 		wq->tail = tail;
 
diff --git a/drivers/staging/hfi1/rc.c b/drivers/staging/hfi1/rc.c
index dd57d65aa9b2..9ce7d5748996 100644
--- a/drivers/staging/hfi1/rc.c
+++ b/drivers/staging/hfi1/rc.c
@@ -1040,7 +1040,7 @@ void hfi1_rc_send_complete(struct hfi1_qp *qp, struct hfi1_ib_header *hdr)
 			wc.opcode = ib_hfi1_wc_opcode[wqe->wr.opcode];
 			wc.byte_len = wqe->length;
 			wc.qp = &qp->ibqp;
-			hfi1_cq_enter(to_icq(qp->ibqp.send_cq), &wc, 0);
+			rvt_cq_enter(ibcq_to_rvtcq(qp->ibqp.send_cq), &wc, 0);
 		}
 		if (++qp->s_last >= qp->s_size)
 			qp->s_last = 0;
@@ -1097,7 +1097,7 @@ static struct hfi1_swqe *do_rc_completion(struct hfi1_qp *qp,
 			wc.opcode = ib_hfi1_wc_opcode[wqe->wr.opcode];
 			wc.byte_len = wqe->length;
 			wc.qp = &qp->ibqp;
-			hfi1_cq_enter(to_icq(qp->ibqp.send_cq), &wc, 0);
+			rvt_cq_enter(ibcq_to_rvtcq(qp->ibqp.send_cq), &wc, 0);
 		}
 		if (++qp->s_last >= qp->s_size)
 			qp->s_last = 0;
@@ -2157,8 +2157,8 @@ send_last:
 		wc.dlid_path_bits = 0;
 		wc.port_num = 0;
 		/* Signal completion event if the solicited bit is set. */
-		hfi1_cq_enter(to_icq(qp->ibqp.recv_cq), &wc,
-			      (bth0 & IB_BTH_SOLICITED) != 0);
+		rvt_cq_enter(ibcq_to_rvtcq(qp->ibqp.recv_cq), &wc,
+			     (bth0 & IB_BTH_SOLICITED) != 0);
 		break;
 
 	case OP(RDMA_WRITE_FIRST):
diff --git a/drivers/staging/hfi1/ruc.c b/drivers/staging/hfi1/ruc.c
index c4280b6f47d4..24d1f6a994e4 100644
--- a/drivers/staging/hfi1/ruc.c
+++ b/drivers/staging/hfi1/ruc.c
@@ -138,7 +138,7 @@ bad_lkey:
 	wc.opcode = IB_WC_RECV;
 	wc.qp = &qp->ibqp;
 	/* Signal solicited completion event. */
-	hfi1_cq_enter(to_icq(qp->ibqp.recv_cq), &wc, 1);
+	rvt_cq_enter(ibcq_to_rvtcq(qp->ibqp.recv_cq), &wc, 1);
 	ret = 0;
 bail:
 	return ret;
@@ -565,8 +565,8 @@ again:
 	wc.sl = qp->remote_ah_attr.sl;
 	wc.port_num = 1;
 	/* Signal completion event if the solicited bit is set. */
-	hfi1_cq_enter(to_icq(qp->ibqp.recv_cq), &wc,
-		      wqe->wr.send_flags & IB_SEND_SOLICITED);
+	rvt_cq_enter(ibcq_to_rvtcq(qp->ibqp.recv_cq), &wc,
+		     wqe->wr.send_flags & IB_SEND_SOLICITED);
 
 send_comp:
 	spin_lock_irqsave(&sqp->s_lock, flags);
@@ -908,8 +908,8 @@ void hfi1_send_complete(struct hfi1_qp *qp, struct hfi1_swqe *wqe,
 		wc.qp = &qp->ibqp;
 		if (status == IB_WC_SUCCESS)
 			wc.byte_len = wqe->length;
-		hfi1_cq_enter(to_icq(qp->ibqp.send_cq), &wc,
-			      status != IB_WC_SUCCESS);
+		rvt_cq_enter(ibcq_to_rvtcq(qp->ibqp.send_cq), &wc,
+			     status != IB_WC_SUCCESS);
 	}
 
 	last = qp->s_last;
diff --git a/drivers/staging/hfi1/uc.c b/drivers/staging/hfi1/uc.c
index fc90d4f544e4..bab50510a78d 100644
--- a/drivers/staging/hfi1/uc.c
+++ b/drivers/staging/hfi1/uc.c
@@ -469,9 +469,9 @@ last_imm:
 		wc.dlid_path_bits = 0;
 		wc.port_num = 0;
 		/* Signal completion event if the solicited bit is set. */
-		hfi1_cq_enter(to_icq(qp->ibqp.recv_cq), &wc,
-			      (ohdr->bth[0] &
-				cpu_to_be32(IB_BTH_SOLICITED)) != 0);
+		rvt_cq_enter(ibcq_to_rvtcq(qp->ibqp.recv_cq), &wc,
+			     (ohdr->bth[0] &
+			      cpu_to_be32(IB_BTH_SOLICITED)) != 0);
 		break;
 
 	case OP(RDMA_WRITE_FIRST):
* Unmerged path drivers/staging/hfi1/ud.c
* Unmerged path drivers/staging/hfi1/verbs.c
* Unmerged path drivers/staging/rdma/hfi1/verbs.h
