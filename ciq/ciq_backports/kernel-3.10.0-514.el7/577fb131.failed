mmc: rework selection of bus speed mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Seungwon Jeon <tgih.jun@samsung.com>
commit 577fb13199b11d8cd75609183649be4b5561243f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/577fb131.failed

Current implementation for bus speed mode selection is too
complicated. This patch is to simplify the codes and remove
some duplicate parts.

The following changes are including:
* Adds functions for each mode selection(HS, HS-DDR, HS200 and etc)
* Rearranged the mode selection sequence with supported device type
* Adds maximum speed for HS200 mode(hs200_max_dtr)
* Adds field definition for HS_TIMING of EXT_CSD

	Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
	Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
	Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Chris Ball <chris@printf.net>
(cherry picked from commit 577fb13199b11d8cd75609183649be4b5561243f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/mmc.c
diff --cc drivers/mmc/core/mmc.c
index 10980284f769,bec6786efd19..000000000000
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@@ -242,29 -242,48 +242,58 @@@ static void mmc_select_card_type(struc
  	struct mmc_host *host = card->host;
  	u8 card_type = card->ext_csd.raw_card_type & EXT_CSD_CARD_TYPE_MASK;
  	u32 caps = host->caps, caps2 = host->caps2;
++<<<<<<< HEAD
 +	unsigned int hs_max_dtr = 0;
++=======
+ 	unsigned int hs_max_dtr = 0, hs200_max_dtr = 0;
+ 	unsigned int avail_type = 0;
++>>>>>>> 577fb13199b1 (mmc: rework selection of bus speed mode)
  
 -	if (caps & MMC_CAP_MMC_HIGHSPEED &&
 -	    card_type & EXT_CSD_CARD_TYPE_HS_26) {
 +	if (card_type & EXT_CSD_CARD_TYPE_26)
  		hs_max_dtr = MMC_HIGH_26_MAX_DTR;
 -		avail_type |= EXT_CSD_CARD_TYPE_HS_26;
 -	}
  
  	if (caps & MMC_CAP_MMC_HIGHSPEED &&
 -	    card_type & EXT_CSD_CARD_TYPE_HS_52) {
 +			card_type & EXT_CSD_CARD_TYPE_52)
  		hs_max_dtr = MMC_HIGH_52_MAX_DTR;
 -		avail_type |= EXT_CSD_CARD_TYPE_HS_52;
 -	}
  
 -	if (caps & MMC_CAP_1_8V_DDR &&
 -	    card_type & EXT_CSD_CARD_TYPE_DDR_1_8V) {
 +	if ((caps & MMC_CAP_1_8V_DDR &&
 +			card_type & EXT_CSD_CARD_TYPE_DDR_1_8V) ||
 +	    (caps & MMC_CAP_1_2V_DDR &&
 +			card_type & EXT_CSD_CARD_TYPE_DDR_1_2V))
  		hs_max_dtr = MMC_HIGH_DDR_MAX_DTR;
 -		avail_type |= EXT_CSD_CARD_TYPE_DDR_1_8V;
 -	}
  
++<<<<<<< HEAD
 +	if ((caps2 & MMC_CAP2_HS200_1_8V_SDR &&
 +			card_type & EXT_CSD_CARD_TYPE_SDR_1_8V) ||
 +	    (caps2 & MMC_CAP2_HS200_1_2V_SDR &&
 +			card_type & EXT_CSD_CARD_TYPE_SDR_1_2V))
 +		hs_max_dtr = MMC_HS200_MAX_DTR;
 +
 +	card->ext_csd.hs_max_dtr = hs_max_dtr;
 +	card->ext_csd.card_type = card_type;
++=======
+ 	if (caps & MMC_CAP_1_2V_DDR &&
+ 	    card_type & EXT_CSD_CARD_TYPE_DDR_1_2V) {
+ 		hs_max_dtr = MMC_HIGH_DDR_MAX_DTR;
+ 		avail_type |= EXT_CSD_CARD_TYPE_DDR_1_2V;
+ 	}
+ 
+ 	if (caps2 & MMC_CAP2_HS200_1_8V_SDR &&
+ 	    card_type & EXT_CSD_CARD_TYPE_HS200_1_8V) {
+ 		hs200_max_dtr = MMC_HS200_MAX_DTR;
+ 		avail_type |= EXT_CSD_CARD_TYPE_HS200_1_8V;
+ 	}
+ 
+ 	if (caps2 & MMC_CAP2_HS200_1_2V_SDR &&
+ 	    card_type & EXT_CSD_CARD_TYPE_HS200_1_2V) {
+ 		hs200_max_dtr = MMC_HS200_MAX_DTR;
+ 		avail_type |= EXT_CSD_CARD_TYPE_HS200_1_2V;
+ 	}
+ 
+ 	card->ext_csd.hs_max_dtr = hs_max_dtr;
+ 	card->ext_csd.hs200_max_dtr = hs200_max_dtr;
+ 	card->mmc_avail_type = avail_type;
++>>>>>>> 577fb13199b1 (mmc: rework selection of bus speed mode)
  }
  
  /*
@@@ -807,39 -826,46 +836,64 @@@ static int mmc_select_powerclass(struc
  }
  
  /*
-  * Selects the desired buswidth and switch to the HS200 mode
-  * if bus width set without error
+  * Set the bus speed for the selected speed mode.
   */
- static int mmc_select_hs200(struct mmc_card *card)
+ static void mmc_set_bus_speed(struct mmc_card *card)
+ {
+ 	unsigned int max_dtr = (unsigned int)-1;
+ 
+ 	if (mmc_card_hs200(card) && max_dtr > card->ext_csd.hs200_max_dtr)
+ 		max_dtr = card->ext_csd.hs200_max_dtr;
+ 	else if (mmc_card_hs(card) && max_dtr > card->ext_csd.hs_max_dtr)
+ 		max_dtr = card->ext_csd.hs_max_dtr;
+ 	else if (max_dtr > card->csd.max_dtr)
+ 		max_dtr = card->csd.max_dtr;
+ 
+ 	mmc_set_clock(card->host, max_dtr);
+ }
+ 
+ /*
+  * Select the bus width amoung 4-bit and 8-bit(SDR).
+  * If the bus width is changed successfully, return the selected width value.
+  * Zero is returned instead of error value if the wide width is not supported.
+  */
+ static int mmc_select_bus_width(struct mmc_card *card)
  {
- 	int idx, err = -EINVAL;
- 	struct mmc_host *host;
  	static unsigned ext_csd_bits[] = {
- 		EXT_CSD_BUS_WIDTH_4,
  		EXT_CSD_BUS_WIDTH_8,
+ 		EXT_CSD_BUS_WIDTH_4,
  	};
  	static unsigned bus_widths[] = {
- 		MMC_BUS_WIDTH_4,
  		MMC_BUS_WIDTH_8,
+ 		MMC_BUS_WIDTH_4,
  	};
+ 	struct mmc_host *host = card->host;
+ 	unsigned idx, bus_width = 0;
+ 	int err = 0;
  
- 	BUG_ON(!card);
+ 	if ((card->csd.mmca_vsn < CSD_SPEC_VER_4) &&
+ 	    !(host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA)))
+ 		return 0;
  
++<<<<<<< HEAD
 +	host = card->host;
 +
 +	if (card->ext_csd.card_type & EXT_CSD_CARD_TYPE_SDR_1_2V &&
 +			host->caps2 & MMC_CAP2_HS200_1_2V_SDR)
 +		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);
 +
 +	if (err && card->ext_csd.card_type & EXT_CSD_CARD_TYPE_SDR_1_8V &&
 +			host->caps2 & MMC_CAP2_HS200_1_8V_SDR)
 +		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
 +
 +	/* If fails try again during next card power cycle */
 +	if (err)
 +		goto err;
 +
 +	idx = (host->caps & MMC_CAP_8_BIT_DATA) ? 1 : 0;
++=======
+ 	idx = (host->caps & MMC_CAP_8_BIT_DATA) ? 0 : 1;
++>>>>>>> 577fb13199b1 (mmc: rework selection of bus speed mode)
  
  	/*
  	 * Unlike SD, MMC cards dont have a configuration register to notify
@@@ -1087,186 -1286,23 +1314,204 @@@ static int mmc_init_card(struct mmc_hos
  	}
  
  	/*
- 	 * Activate high speed (if supported)
+ 	 * Select timing interface
  	 */
++<<<<<<< HEAD
 +	if (card->ext_csd.hs_max_dtr != 0) {
 +		err = 0;
 +		if (card->ext_csd.hs_max_dtr > 52000000 &&
 +		    host->caps2 & MMC_CAP2_HS200)
 +			err = mmc_select_hs200(card);
 +		else if	(host->caps & MMC_CAP_MMC_HIGHSPEED)
 +			err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 +					EXT_CSD_HS_TIMING, 1,
 +					card->ext_csd.generic_cmd6_time,
 +					true, true, true);
 +
 +		if (err && err != -EBADMSG)
 +			goto free_card;
 +
 +		if (err) {
 +			pr_warning("%s: switch to highspeed failed\n",
 +			       mmc_hostname(card->host));
 +			err = 0;
 +		} else {
 +			if (card->ext_csd.hs_max_dtr > 52000000 &&
 +			    host->caps2 & MMC_CAP2_HS200) {
 +				mmc_card_set_hs200(card);
 +				mmc_set_timing(card->host,
 +					       MMC_TIMING_MMC_HS200);
 +			} else {
 +				mmc_card_set_highspeed(card);
 +				mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
 +			}
 +		}
 +	}
 +
 +	/*
 +	 * Compute bus speed.
 +	 */
 +	max_dtr = (unsigned int)-1;
 +
 +	if (mmc_card_highspeed(card) || mmc_card_hs200(card)) {
 +		if (max_dtr > card->ext_csd.hs_max_dtr)
 +			max_dtr = card->ext_csd.hs_max_dtr;
 +		if (mmc_card_highspeed(card) && (max_dtr > 52000000))
 +			max_dtr = 52000000;
 +	} else if (max_dtr > card->csd.max_dtr) {
 +		max_dtr = card->csd.max_dtr;
 +	}
 +
 +	mmc_set_clock(host, max_dtr);
 +
 +	/*
 +	 * Indicate DDR mode (if supported).
 +	 */
 +	if (mmc_card_highspeed(card)) {
 +		if ((card->ext_csd.card_type & EXT_CSD_CARD_TYPE_DDR_1_8V)
 +			&& (host->caps & MMC_CAP_1_8V_DDR))
 +				ddr = MMC_1_8V_DDR_MODE;
 +		else if ((card->ext_csd.card_type & EXT_CSD_CARD_TYPE_DDR_1_2V)
 +			&& (host->caps & MMC_CAP_1_2V_DDR))
 +				ddr = MMC_1_2V_DDR_MODE;
 +	}
 +
 +	/*
 +	 * Indicate HS200 SDR mode (if supported).
 +	 */
 +	if (mmc_card_hs200(card)) {
 +		u32 ext_csd_bits;
 +		u32 bus_width = card->host->ios.bus_width;
 +
 +		/*
 +		 * For devices supporting HS200 mode, the bus width has
 +		 * to be set before executing the tuning function. If
 +		 * set before tuning, then device will respond with CRC
 +		 * errors for responses on CMD line. So for HS200 the
 +		 * sequence will be
 +		 * 1. set bus width 4bit / 8 bit (1 bit not supported)
 +		 * 2. switch to HS200 mode
 +		 * 3. set the clock to > 52Mhz <=200MHz and
 +		 * 4. execute tuning for HS200
 +		 */
 +		if ((host->caps2 & MMC_CAP2_HS200) &&
 +		    card->host->ops->execute_tuning) {
 +			mmc_host_clk_hold(card->host);
 +			err = card->host->ops->execute_tuning(card->host,
 +				MMC_SEND_TUNING_BLOCK_HS200);
 +			mmc_host_clk_release(card->host);
 +		}
 +		if (err) {
 +			pr_warning("%s: tuning execution failed\n",
 +				   mmc_hostname(card->host));
 +			goto err;
 +		}
 +
 +		ext_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?
 +				EXT_CSD_BUS_WIDTH_8 : EXT_CSD_BUS_WIDTH_4;
 +	}
 +
 +	/*
 +	 * Activate wide bus and DDR (if supported).
 +	 */
 +	if (!mmc_card_hs200(card) &&
 +	    (card->csd.mmca_vsn >= CSD_SPEC_VER_4) &&
 +	    (host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA))) {
 +		static unsigned ext_csd_bits[][2] = {
 +			{ EXT_CSD_BUS_WIDTH_8, EXT_CSD_DDR_BUS_WIDTH_8 },
 +			{ EXT_CSD_BUS_WIDTH_4, EXT_CSD_DDR_BUS_WIDTH_4 },
 +			{ EXT_CSD_BUS_WIDTH_1, EXT_CSD_BUS_WIDTH_1 },
 +		};
 +		static unsigned bus_widths[] = {
 +			MMC_BUS_WIDTH_8,
 +			MMC_BUS_WIDTH_4,
 +			MMC_BUS_WIDTH_1
 +		};
 +		unsigned idx, bus_width = 0;
 +
 +		if (host->caps & MMC_CAP_8_BIT_DATA)
 +			idx = 0;
 +		else
 +			idx = 1;
 +		for (; idx < ARRAY_SIZE(bus_widths); idx++) {
 +			bus_width = bus_widths[idx];
 +			if (bus_width == MMC_BUS_WIDTH_1)
 +				ddr = 0; /* no DDR for 1-bit width */
 +
 +			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 +					 EXT_CSD_BUS_WIDTH,
 +					 ext_csd_bits[idx][0],
 +					 card->ext_csd.generic_cmd6_time);
 +			if (!err) {
 +				mmc_set_bus_width(card->host, bus_width);
 +
 +				/*
 +				 * If controller can't handle bus width test,
 +				 * compare ext_csd previously read in 1 bit mode
 +				 * against ext_csd at new bus width
 +				 */
 +				if (!(host->caps & MMC_CAP_BUS_WIDTH_TEST))
 +					err = mmc_compare_ext_csds(card,
 +						bus_width);
 +				else
 +					err = mmc_bus_test(card, bus_width);
 +				if (!err)
 +					break;
 +			}
 +		}
 +
 +		if (!err && ddr) {
 +			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 +					 EXT_CSD_BUS_WIDTH,
 +					 ext_csd_bits[idx][1],
 +					 card->ext_csd.generic_cmd6_time);
 +		}
 +		if (err) {
 +			pr_warning("%s: switch to bus width %d ddr %d "
 +				"failed\n", mmc_hostname(card->host),
 +				1 << bus_width, ddr);
 +			goto free_card;
 +		} else if (ddr) {
 +			/*
 +			 * eMMC cards can support 3.3V to 1.2V i/o (vccq)
 +			 * signaling.
 +			 *
 +			 * EXT_CSD_CARD_TYPE_DDR_1_8V means 3.3V or 1.8V vccq.
 +			 *
 +			 * 1.8V vccq at 3.3V core voltage (vcc) is not required
 +			 * in the JEDEC spec for DDR.
 +			 *
 +			 * Do not force change in vccq since we are obviously
 +			 * working and no change to vccq is needed.
 +			 *
 +			 * WARNING: eMMC rules are NOT the same as SD DDR
 +			 */
 +			if (ddr == MMC_1_2V_DDR_MODE) {
 +				err = __mmc_set_signal_voltage(host,
 +					MMC_SIGNAL_VOLTAGE_120);
 +				if (err)
 +					goto err;
 +			}
 +			mmc_card_set_ddr_mode(card);
 +			mmc_set_timing(card->host, MMC_TIMING_MMC_DDR52);
 +			mmc_set_bus_width(card->host, bus_width);
++=======
+ 	err = mmc_select_timing(card);
+ 	if (err)
+ 		goto free_card;
+ 
+ 	if (mmc_card_hs200(card)) {
+ 		err = mmc_hs200_tuning(card);
+ 		if (err)
+ 			goto err;
+ 	} else if (mmc_card_hs(card)) {
+ 		/* Select the desired bus width optionally */
+ 		err = mmc_select_bus_width(card);
+ 		if (!IS_ERR_VALUE(err)) {
+ 			err = mmc_select_hs_ddr(card);
+ 			if (err)
+ 				goto err;
++>>>>>>> 577fb13199b1 (mmc: rework selection of bus speed mode)
  		}
  	}
  
diff --git a/drivers/mmc/core/debugfs.c b/drivers/mmc/core/debugfs.c
index 509229b48b55..1f730dbfaeea 100644
--- a/drivers/mmc/core/debugfs.c
+++ b/drivers/mmc/core/debugfs.c
@@ -139,7 +139,7 @@ static int mmc_ios_show(struct seq_file *s, void *data)
 		str = "mmc DDR52";
 		break;
 	case MMC_TIMING_MMC_HS200:
-		str = "mmc high-speed SDR200";
+		str = "mmc HS200";
 		break;
 	default:
 		str = "invalid";
* Unmerged path drivers/mmc/core/mmc.c
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index aa7e57f60fb2..98d6e29d4db1 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -63,6 +63,7 @@ struct mmc_ext_csd {
 	unsigned int            power_off_longtime;     /* Units: ms */
 	u8			power_off_notification;	/* state */
 	unsigned int		hs_max_dtr;
+	unsigned int		hs200_max_dtr;
 #define MMC_HIGH_26_MAX_DTR	26000000
 #define MMC_HIGH_52_MAX_DTR	52000000
 #define MMC_HIGH_DDR_MAX_DTR	52000000
diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 50bcde3677ca..87df5083c3a4 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -373,6 +373,10 @@ struct _mmc_csd {
 #define EXT_CSD_DDR_BUS_WIDTH_4	5	/* Card is in 4 bit DDR mode */
 #define EXT_CSD_DDR_BUS_WIDTH_8	6	/* Card is in 8 bit DDR mode */
 
+#define EXT_CSD_TIMING_BC	0	/* Backwards compatility */
+#define EXT_CSD_TIMING_HS	1	/* High speed */
+#define EXT_CSD_TIMING_HS200	2	/* HS200 */
+
 #define EXT_CSD_SEC_ER_EN	BIT(0)
 #define EXT_CSD_SEC_BD_BLK_EN	BIT(2)
 #define EXT_CSD_SEC_GB_CL_EN	BIT(4)
