mmc: tmio: control multiple block transfer mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Shinobu Uehara <shinobu.uehara.xc@renesas.com>
commit b8d11962c2d83c984d5afd091e5b725ad2fd5607
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/b8d11962.failed

Renesas SDHI has "Multiple Block Transfer Mode" settings
on SD_CMD register which controls CMD12 automatically.

This patch cares it, because
CMD12 is not needed when CMD53 (= SD_IO_RW_EXTENDED)

[Kuninori Morimoto: tidyuped for upstreaming
                    enabled this flags for all SH-Mobile/R-Car]

	Tested-by: Nguyen Xuan Nui <nx-nui@jinso.co.jp>
	Tested-by: Hiep Cao Minh <cm-hiep@jinso.co.jp>
	Signed-off-by: Shinobu Uehara <shinobu.uehara.xc@renesas.com>
	Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit b8d11962c2d83c984d5afd091e5b725ad2fd5607)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mfd/tmio.h
diff --cc include/linux/mfd/tmio.h
index b22883d60500,7432d95b08e2..000000000000
--- a/include/linux/mfd/tmio.h
+++ b/include/linux/mfd/tmio.h
@@@ -76,6 -76,19 +76,22 @@@
   */
  #define TMIO_MMC_USE_GPIO_CD		(1 << 5)
  
++<<<<<<< HEAD
++=======
+ /*
+  * Some controllers doesn't have over 0x100 register.
+  * it is used to checking accessibility of
+  * CTL_SD_CARD_CLK_CTL / CTL_CLK_AND_WAIT_CTL
+  */
+ #define TMIO_MMC_HAVE_HIGH_REG		(1 << 6)
+ 
+ /*
+  * Some controllers have CMD12 automatically
+  * issue/non-issue register
+  */
+ #define TMIO_MMC_HAVE_CMD12_CTRL	(1 << 7)
+ 
++>>>>>>> b8d11962c2d8 (mmc: tmio: control multiple block transfer mode)
  int tmio_core_mmc_enable(void __iomem *cnf, int shift, unsigned long base);
  int tmio_core_mmc_resume(void __iomem *cnf, int shift, unsigned long base);
  void tmio_core_mmc_pwr(void __iomem *cnf, int shift, int state);
diff --git a/drivers/mmc/host/sh_mobile_sdhi.c b/drivers/mmc/host/sh_mobile_sdhi.c
index 79ee6f0c45bd..5e83e59e7161 100644
--- a/drivers/mmc/host/sh_mobile_sdhi.c
+++ b/drivers/mmc/host/sh_mobile_sdhi.c
@@ -196,6 +196,11 @@ static int sh_mobile_sdhi_probe(struct platform_device *pdev)
 	 */
 	mmc_data->flags |= TMIO_MMC_SDIO_IRQ;
 
+	/*
+	 * All SDHI have CMD12 controll bit
+	 */
+	mmc_data->flags |= TMIO_MMC_HAVE_CMD12_CTRL;
+
 	if (of_id && of_id->data) {
 		const struct sh_mobile_sdhi_of_data *of_data = of_id->data;
 		mmc_data->flags |= of_data->tmio_flags;
diff --git a/drivers/mmc/host/tmio_mmc_pio.c b/drivers/mmc/host/tmio_mmc_pio.c
index ff722d753e2f..49346adff66e 100644
--- a/drivers/mmc/host/tmio_mmc_pio.c
+++ b/drivers/mmc/host/tmio_mmc_pio.c
@@ -44,6 +44,7 @@
 #include <linux/pm_qos.h>
 #include <linux/pm_runtime.h>
 #include <linux/regulator/consumer.h>
+#include <linux/mmc/sdio.h>
 #include <linux/scatterlist.h>
 #include <linux/spinlock.h>
 #include <linux/workqueue.h>
@@ -301,6 +302,7 @@ static void tmio_mmc_done_work(struct work_struct *work)
 #define TRANSFER_READ  0x1000
 #define TRANSFER_MULTI 0x2000
 #define SECURITY_CMD   0x4000
+#define NO_CMD12_ISSUE 0x4000 /* TMIO_MMC_HAVE_CMD12_CTRL */
 
 static int tmio_mmc_start_command(struct tmio_mmc_host *host, struct mmc_command *cmd)
 {
@@ -337,6 +339,14 @@ static int tmio_mmc_start_command(struct tmio_mmc_host *host, struct mmc_command
 		if (data->blocks > 1) {
 			sd_ctrl_write16(host, CTL_STOP_INTERNAL_ACTION, 0x100);
 			c |= TRANSFER_MULTI;
+
+			/*
+			 * Disable auto CMD12 at IO_RW_EXTENDED when
+			 * multiple block transfer
+			 */
+			if ((host->pdata->flags & TMIO_MMC_HAVE_CMD12_CTRL) &&
+			    (cmd->opcode == SD_IO_RW_EXTENDED))
+				c |= NO_CMD12_ISSUE;
 		}
 		if (data->flags & MMC_DATA_READ)
 			c |= TRANSFER_READ;
* Unmerged path include/linux/mfd/tmio.h
