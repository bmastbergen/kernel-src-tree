perf/core: Add a 'flags' parameter to the PMU transactional interfaces

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
commit fbbe07011581990ef74dfac06dc8511b1a14badb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/fbbe0701.failed

Currently, the PMU interface allows reading only one counter at a time.
But some PMUs like the 24x7 counters in Power, support reading several
counters at once. To leveage this functionality, extend the transaction
interface to support a "transaction type".

The first type, PERF_PMU_TXN_ADD, refers to the existing transactions,
i.e. used to _schedule_ all the events on the PMU as a group. A second
transaction type, PERF_PMU_TXN_READ, will be used in a follow-on patch,
by the 24x7 counters to read several counters at once.

Extend the transaction interfaces to the PMU to accept a 'txn_flags'
parameter and use this parameter to ignore any transactions that are
not of type PERF_PMU_TXN_ADD.

Thanks to Peter Zijlstra for his input.

	Signed-off-by: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
[peterz: s390 compile fix]
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Acked-by: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
Link: http://lkml.kernel.org/r/1441336073-22750-3-git-send-email-sukadev@linux.vnet.ibm.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit fbbe07011581990ef74dfac06dc8511b1a14badb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/perf/core-book3s.c
#	arch/s390/kernel/perf_cpum_cf.c
#	arch/sparc/kernel/perf_event.c
diff --cc arch/powerpc/perf/core-book3s.c
index 33009684c666,c84074185c80..000000000000
--- a/arch/powerpc/perf/core-book3s.c
+++ b/arch/powerpc/perf/core-book3s.c
@@@ -1552,11 -1587,21 +1553,25 @@@ static void power_pmu_stop(struct perf_
   * Start group events scheduling transaction
   * Set the flag to make pmu::enable() not perform the
   * schedulability test, it will be performed at commit time
+  *
+  * We only support PERF_PMU_TXN_ADD transactions. Save the
+  * transaction flags but otherwise ignore non-PERF_PMU_TXN_ADD
+  * transactions.
   */
++<<<<<<< HEAD
 +void power_pmu_start_txn(struct pmu *pmu)
++=======
+ static void power_pmu_start_txn(struct pmu *pmu, unsigned int txn_flags)
++>>>>>>> fbbe07011581 (perf/core: Add a 'flags' parameter to the PMU transactional interfaces)
  {
 -	struct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);
 +	struct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);
  
+ 	WARN_ON_ONCE(cpuhw->txn_flags);		/* txn already in flight */
+ 
+ 	cpuhw->txn_flags = txn_flags;
+ 	if (txn_flags & ~PERF_PMU_TXN_ADD)
+ 		return;
+ 
  	perf_pmu_disable(pmu);
  	cpuhw->group_flag |= PERF_EVENT_TXN;
  	cpuhw->n_txn_start = cpuhw->n_events;
@@@ -1567,9 -1612,17 +1582,21 @@@
   * Clear the flag and pmu::enable() will perform the
   * schedulability test.
   */
 -static void power_pmu_cancel_txn(struct pmu *pmu)
 +void power_pmu_cancel_txn(struct pmu *pmu)
  {
++<<<<<<< HEAD
 +	struct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);
++=======
+ 	struct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);
+ 	unsigned int txn_flags;
+ 
+ 	WARN_ON_ONCE(!cpuhw->txn_flags);	/* no txn in flight */
+ 
+ 	txn_flags = cpuhw->txn_flags;
+ 	cpuhw->txn_flags = 0;
+ 	if (txn_flags & ~PERF_PMU_TXN_ADD)
+ 		return;
++>>>>>>> fbbe07011581 (perf/core: Add a 'flags' parameter to the PMU transactional interfaces)
  
  	cpuhw->group_flag &= ~PERF_EVENT_TXN;
  	perf_pmu_enable(pmu);
@@@ -1587,7 -1640,15 +1614,19 @@@ int power_pmu_commit_txn(struct pmu *pm
  
  	if (!ppmu)
  		return -EAGAIN;
++<<<<<<< HEAD
 +	cpuhw = &__get_cpu_var(cpu_hw_events);
++=======
+ 
+ 	cpuhw = this_cpu_ptr(&cpu_hw_events);
+ 	WARN_ON_ONCE(!cpuhw->txn_flags);	/* no txn in flight */
+ 
+ 	if (cpuhw->txn_flags & ~PERF_PMU_TXN_ADD) {
+ 		cpuhw->txn_flags = 0;
+ 		return 0;
+ 	}
+ 
++>>>>>>> fbbe07011581 (perf/core: Add a 'flags' parameter to the PMU transactional interfaces)
  	n = cpuhw->n_events;
  	if (check_excludes(cpuhw->event, cpuhw->flags, 0, n))
  		return -EAGAIN;
diff --cc arch/s390/kernel/perf_cpum_cf.c
index ea75d011a6fc,19138be412d6..000000000000
--- a/arch/s390/kernel/perf_cpum_cf.c
+++ b/arch/s390/kernel/perf_cpum_cf.c
@@@ -578,11 -574,21 +580,21 @@@ static void cpumf_pmu_del(struct perf_e
  /*
   * Start group events scheduling transaction.
   * Set flags to perform a single test at commit time.
+  *
+  * We only support PERF_PMU_TXN_ADD transactions. Save the
+  * transaction flags but otherwise ignore non-PERF_PMU_TXN_ADD
+  * transactions.
   */
- static void cpumf_pmu_start_txn(struct pmu *pmu)
+ static void cpumf_pmu_start_txn(struct pmu *pmu, unsigned int txn_flags)
  {
 -	struct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);
 +	struct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);
  
+ 	WARN_ON_ONCE(cpuhw->txn_flags);		/* txn already in flight */
+ 
+ 	cpuhw->txn_flags = txn_flags;
+ 	if (txn_flags & ~PERF_PMU_TXN_ADD)
+ 		return;
+ 
  	perf_pmu_disable(pmu);
  	cpuhw->flags |= PERF_EVENT_TXN;
  	cpuhw->tx_state = cpuhw->state;
@@@ -595,7 -601,15 +607,19 @@@
   */
  static void cpumf_pmu_cancel_txn(struct pmu *pmu)
  {
++<<<<<<< HEAD
 +	struct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);
++=======
+ 	unsigned int txn_flags;
+ 	struct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);
++>>>>>>> fbbe07011581 (perf/core: Add a 'flags' parameter to the PMU transactional interfaces)
+ 
+ 	WARN_ON_ONCE(!cpuhw->txn_flags);	/* no txn in flight */
+ 
+ 	txn_flags = cpuhw->txn_flags;
+ 	cpuhw->txn_flags = 0;
+ 	if (txn_flags & ~PERF_PMU_TXN_ADD)
+ 		return;
  
  	WARN_ON(cpuhw->tx_state != cpuhw->state);
  
@@@ -610,9 -624,16 +634,16 @@@
   */
  static int cpumf_pmu_commit_txn(struct pmu *pmu)
  {
 -	struct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);
 +	struct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);
  	u64 state;
  
+ 	WARN_ON_ONCE(!cpuhw->txn_flags);	/* no txn in flight */
+ 
+ 	if (cpuhw->txn_flags & ~PERF_PMU_TXN_ADD) {
+ 		cpuhw->txn_flags = 0;
+ 		return 0;
+ 	}
+ 
  	/* check if the updated state can be scheduled */
  	state = cpuhw->state & ~((1 << CPUMF_LCCTL_ENABLE_SHIFT) - 1);
  	state >>= CPUMF_LCCTL_ENABLE_SHIFT;
diff --cc arch/sparc/kernel/perf_event.c
index b5c38faa4ead,2c0984d146ec..000000000000
--- a/arch/sparc/kernel/perf_event.c
+++ b/arch/sparc/kernel/perf_event.c
@@@ -109,8 -109,9 +109,9 @@@ struct cpu_hw_events 
  	int			enabled;
  
  	unsigned int		group_flag;
+ 	unsigned int		txn_flags;
  };
 -static DEFINE_PER_CPU(struct cpu_hw_events, cpu_hw_events) = { .enabled = 1, };
 +DEFINE_PER_CPU(struct cpu_hw_events, cpu_hw_events) = { .enabled = 1, };
  
  /* An event map describes the characteristics of a performance
   * counter event.  In particular it gives the encoding as well as
@@@ -1496,10 -1495,16 +1497,16 @@@ static int sparc_pmu_event_init(struct 
   * Set the flag to make pmu::enable() not perform the
   * schedulability test, it will be performed at commit time
   */
- static void sparc_pmu_start_txn(struct pmu *pmu)
+ static void sparc_pmu_start_txn(struct pmu *pmu, unsigned int txn_flags)
  {
 -	struct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);
 +	struct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);
  
+ 	WARN_ON_ONCE(cpuhw->txn_flags);		/* txn already in flight */
+ 
+ 	cpuhw->txn_flags = txn_flags;
+ 	if (txn_flags & ~PERF_PMU_TXN_ADD)
+ 		return;
+ 
  	perf_pmu_disable(pmu);
  	cpuhw->group_flag |= PERF_EVENT_TXN;
  }
@@@ -1511,7 -1516,15 +1518,19 @@@
   */
  static void sparc_pmu_cancel_txn(struct pmu *pmu)
  {
++<<<<<<< HEAD
 +	struct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);
++=======
+ 	struct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);
+ 	unsigned int txn_flags;
+ 
+ 	WARN_ON_ONCE(!cpuhw->txn_flags);	/* no txn in flight */
+ 
+ 	txn_flags = cpuhw->txn_flags;
+ 	cpuhw->txn_flags = 0;
+ 	if (txn_flags & ~PERF_PMU_TXN_ADD)
+ 		return;
++>>>>>>> fbbe07011581 (perf/core: Add a 'flags' parameter to the PMU transactional interfaces)
  
  	cpuhw->group_flag &= ~PERF_EVENT_TXN;
  	perf_pmu_enable(pmu);
@@@ -1530,7 -1543,13 +1549,17 @@@ static int sparc_pmu_commit_txn(struct 
  	if (!sparc_pmu)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	cpuc = &__get_cpu_var(cpu_hw_events);
++=======
+ 	WARN_ON_ONCE(!cpuc->txn_flags);	/* no txn in flight */
+ 
+ 	if (cpuc->txn_flags & ~PERF_PMU_TXN_ADD) {
+ 		cpuc->txn_flags = 0;
+ 		return 0;
+ 	}
+ 
++>>>>>>> fbbe07011581 (perf/core: Add a 'flags' parameter to the PMU transactional interfaces)
  	n = cpuc->n_events;
  	if (check_excludes(cpuc->event, 0, n))
  		return -EINVAL;
* Unmerged path arch/powerpc/perf/core-book3s.c
* Unmerged path arch/s390/kernel/perf_cpum_cf.c
* Unmerged path arch/sparc/kernel/perf_event.c
diff --git a/arch/x86/kernel/cpu/perf_event.c b/arch/x86/kernel/cpu/perf_event.c
index 422b52ebe193..122b490a2256 100644
--- a/arch/x86/kernel/cpu/perf_event.c
+++ b/arch/x86/kernel/cpu/perf_event.c
@@ -1716,9 +1716,21 @@ static inline void x86_pmu_read(struct perf_event *event)
  * Start group events scheduling transaction
  * Set the flag to make pmu::enable() not perform the
  * schedulability test, it will be performed at commit time
+ *
+ * We only support PERF_PMU_TXN_ADD transactions. Save the
+ * transaction flags but otherwise ignore non-PERF_PMU_TXN_ADD
+ * transactions.
  */
-static void x86_pmu_start_txn(struct pmu *pmu)
+static void x86_pmu_start_txn(struct pmu *pmu, unsigned int txn_flags)
 {
+	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
+
+	WARN_ON_ONCE(cpuc->txn_flags);		/* txn already in flight */
+
+	cpuc->txn_flags = txn_flags;
+	if (txn_flags & ~PERF_PMU_TXN_ADD)
+		return;
+
 	perf_pmu_disable(pmu);
 	__this_cpu_or(cpu_hw_events.group_flag, PERF_EVENT_TXN);
 	__this_cpu_write(cpu_hw_events.n_txn, 0);
@@ -1731,6 +1743,16 @@ static void x86_pmu_start_txn(struct pmu *pmu)
  */
 static void x86_pmu_cancel_txn(struct pmu *pmu)
 {
+	unsigned int txn_flags;
+	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
+
+	WARN_ON_ONCE(!cpuc->txn_flags);	/* no txn in flight */
+
+	txn_flags = cpuc->txn_flags;
+	cpuc->txn_flags = 0;
+	if (txn_flags & ~PERF_PMU_TXN_ADD)
+		return;
+
 	__this_cpu_and(cpu_hw_events.group_flag, ~PERF_EVENT_TXN);
 	/*
 	 * Truncate collected array by the number of events added in this
@@ -1754,6 +1776,13 @@ static int x86_pmu_commit_txn(struct pmu *pmu)
 	int assign[X86_PMC_IDX_MAX];
 	int n, ret;
 
+	WARN_ON_ONCE(!cpuc->txn_flags);	/* no txn in flight */
+
+	if (cpuc->txn_flags & ~PERF_PMU_TXN_ADD) {
+		cpuc->txn_flags = 0;
+		return 0;
+	}
+
 	n = cpuc->n_events;
 
 	if (!x86_pmu_initialized())
@@ -1770,6 +1799,7 @@ static int x86_pmu_commit_txn(struct pmu *pmu)
 	memcpy(cpuc->assign, assign, n*sizeof(int));
 
 	cpuc->group_flag &= ~PERF_EVENT_TXN;
+	cpuc->txn_flags = 0;
 	perf_pmu_enable(pmu);
 	return 0;
 }
diff --git a/arch/x86/kernel/cpu/perf_event.h b/arch/x86/kernel/cpu/perf_event.h
index 22325d5f1d4e..199ce1c3b9df 100644
--- a/arch/x86/kernel/cpu/perf_event.h
+++ b/arch/x86/kernel/cpu/perf_event.h
@@ -196,6 +196,7 @@ struct cpu_hw_events {
 	int			n_excl; /* the number of exclusive events */
 
 	unsigned int		group_flag;
+	unsigned int		txn_flags;
 	int			is_fake;
 
 	/*
diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h
index 855e6baed4cb..8daaea84116e 100644
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -177,6 +177,8 @@ struct perf_event;
  */
 #define PERF_EVENT_TXN 0x1
 
+#define PERF_PMU_TXN_ADD  0x1		/* txn to add/schedule event on PMU */
+
 /**
  * pmu::capabilities flags
  */
@@ -242,20 +244,26 @@ struct pmu {
 	 *
 	 * Start the transaction, after this ->add() doesn't need to
 	 * do schedulability tests.
+	 *
+	 * Optional.
 	 */
-	void (*start_txn)		(struct pmu *pmu); /* optional */
+	void (*start_txn)		(struct pmu *pmu, unsigned int txn_flags);
 	/*
 	 * If ->start_txn() disabled the ->add() schedulability test
 	 * then ->commit_txn() is required to perform one. On success
 	 * the transaction is closed. On error the transaction is kept
 	 * open until ->cancel_txn() is called.
+	 *
+	 * Optional.
 	 */
-	int  (*commit_txn)		(struct pmu *pmu); /* optional */
+	int  (*commit_txn)		(struct pmu *pmu);
 	/*
 	 * Will cancel the transaction, assumes ->del() is called
 	 * for each successful ->add() during the transaction.
+	 *
+	 * Optional.
 	 */
-	void (*cancel_txn)		(struct pmu *pmu); /* optional */
+	void (*cancel_txn)		(struct pmu *pmu);
 
 	/*
 	 * Will return the value for perf_event_mmap_page::index for this event,
diff --git a/kernel/events/core.c b/kernel/events/core.c
index cfbd86b18144..78fd316ab75a 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -1931,7 +1931,7 @@ group_sched_in(struct perf_event *group_event,
 	if (group_event->state == PERF_EVENT_STATE_OFF)
 		return 0;
 
-	pmu->start_txn(pmu);
+	pmu->start_txn(pmu, PERF_PMU_TXN_ADD);
 
 	if (event_sched_in(group_event, cpuctx, ctx)) {
 		pmu->cancel_txn(pmu);
@@ -6880,24 +6880,49 @@ static void perf_pmu_nop_void(struct pmu *pmu)
 {
 }
 
+static void perf_pmu_nop_txn(struct pmu *pmu, unsigned int flags)
+{
+}
+
 static int perf_pmu_nop_int(struct pmu *pmu)
 {
 	return 0;
 }
 
-static void perf_pmu_start_txn(struct pmu *pmu)
+DEFINE_PER_CPU(unsigned int, nop_txn_flags);
+
+static void perf_pmu_start_txn(struct pmu *pmu, unsigned int flags)
 {
+	__this_cpu_write(nop_txn_flags, flags);
+
+	if (flags & ~PERF_PMU_TXN_ADD)
+		return;
+
 	perf_pmu_disable(pmu);
 }
 
 static int perf_pmu_commit_txn(struct pmu *pmu)
 {
+	unsigned int flags = __this_cpu_read(nop_txn_flags);
+
+	__this_cpu_write(nop_txn_flags, 0);
+
+	if (flags & ~PERF_PMU_TXN_ADD)
+		return 0;
+
 	perf_pmu_enable(pmu);
 	return 0;
 }
 
 static void perf_pmu_cancel_txn(struct pmu *pmu)
 {
+	unsigned int flags =  __this_cpu_read(nop_txn_flags);
+
+	__this_cpu_write(nop_txn_flags, 0);
+
+	if (flags & ~PERF_PMU_TXN_ADD)
+		return;
+
 	perf_pmu_enable(pmu);
 }
 
@@ -7127,7 +7152,7 @@ got_cpu_context:
 			pmu->commit_txn = perf_pmu_commit_txn;
 			pmu->cancel_txn = perf_pmu_cancel_txn;
 		} else {
-			pmu->start_txn  = perf_pmu_nop_void;
+			pmu->start_txn  = perf_pmu_nop_txn;
 			pmu->commit_txn = perf_pmu_nop_int;
 			pmu->cancel_txn = perf_pmu_nop_void;
 		}
