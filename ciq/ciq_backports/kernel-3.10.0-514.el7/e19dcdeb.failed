ixgbe: Make ATR recognize IPv6 extended headers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Mark Rustad <mark.d.rustad@intel.com>
commit e19dcdeb3527e996a96ea49d86cccce768b1079a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e19dcdeb.failed

Right now ATR is not handling IPv6 extended headers, so ATR is not
being performed on such packets. Fix that by skipping extended
headers when they are present. This also fixes a problem where
the ATR code was not checking that the inner protocol was actually
TCP before setting up the signature rules. Since the protocol check
is intimately involved with the extended header processing as well,
this all gets fixed together.

	Signed-off-by: Mark Rustad <mark.d.rustad@intel.com>
	Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit e19dcdeb3527e996a96ea49d86cccce768b1079a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index a79ce7a8be19,c4003a88bbf6..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -7122,16 -7571,58 +7122,59 @@@ static void ixgbe_atr(struct ixgbe_rin
  	ring->atr_count++;
  
  	/* snag network header to get L4 type and address */
++<<<<<<< HEAD
 +	hdr.network = skb_network_header(first->skb);
++=======
+ 	skb = first->skb;
+ 	hdr.network = skb_network_header(skb);
+ 	if (!skb->encapsulation) {
+ 		th = tcp_hdr(skb);
+ 	} else {
+ #ifdef CONFIG_IXGBE_VXLAN
+ 		struct ixgbe_adapter *adapter = q_vector->adapter;
++>>>>>>> e19dcdeb3527 (ixgbe: Make ATR recognize IPv6 extended headers)
  
 -		if (!adapter->vxlan_port)
 -			return;
 -		if (first->protocol != htons(ETH_P_IP) ||
 -		    hdr.ipv4->version != IPVERSION ||
 -		    hdr.ipv4->protocol != IPPROTO_UDP) {
 -			return;
 -		}
 -		if (ntohs(udp_hdr(skb)->dest) != adapter->vxlan_port)
 -			return;
 -		encap = true;
 -		hdr.network = skb_inner_network_header(skb);
 -		th = inner_tcp_hdr(skb);
 -#else
 +	/* Currently only IPv4/IPv6 with TCP is supported */
 +	if ((first->protocol != htons(ETH_P_IPV6) ||
 +	     hdr.ipv6->nexthdr != IPPROTO_TCP) &&
 +	    (first->protocol != htons(ETH_P_IP) ||
 +	     hdr.ipv4->protocol != IPPROTO_TCP))
  		return;
++<<<<<<< HEAD
 +
 +	th = tcp_hdr(first->skb);
++=======
+ #endif /* CONFIG_IXGBE_VXLAN */
+ 	}
+ 
+ 	/* Currently only IPv4/IPv6 with TCP is supported */
+ 	switch (hdr.ipv4->version) {
+ 	case IPVERSION:
+ 		if (hdr.ipv4->protocol != IPPROTO_TCP)
+ 			return;
+ 		break;
+ 	case 6:
+ 		if (likely((unsigned char *)th - hdr.network ==
+ 			   sizeof(struct ipv6hdr))) {
+ 			if (hdr.ipv6->nexthdr != IPPROTO_TCP)
+ 				return;
+ 		} else {
+ 			__be16 frag_off;
+ 			u8 l4_hdr;
+ 
+ 			ipv6_skip_exthdr(skb, hdr.network - skb->data +
+ 					      sizeof(struct ipv6hdr),
+ 					 &l4_hdr, &frag_off);
+ 			if (unlikely(frag_off))
+ 				return;
+ 			if (l4_hdr != IPPROTO_TCP)
+ 				return;
+ 		}
+ 		break;
+ 	default:
+ 		return;
+ 	}
++>>>>>>> e19dcdeb3527 (ixgbe: Make ATR recognize IPv6 extended headers)
  
  	/* skip this packet since it is invalid or the socket is closing */
  	if (!th || th->fin)
@@@ -7178,8 -7671,16 +7223,11 @@@
  			     hdr.ipv6->daddr.s6_addr32[1] ^
  			     hdr.ipv6->daddr.s6_addr32[2] ^
  			     hdr.ipv6->daddr.s6_addr32[3];
+ 		break;
+ 	default:
+ 		break;
  	}
  
 -#ifdef CONFIG_IXGBE_VXLAN
 -	if (encap)
 -		input.formatted.flow_type |= IXGBE_ATR_L4TYPE_TUNNEL_MASK;
 -#endif /* CONFIG_IXGBE_VXLAN */
 -
  	/* This assumes the Rx queue and Tx queue are bound to the same CPU */
  	ixgbe_fdir_add_signature_filter_82599(&q_vector->adapter->hw,
  					      input, common, ring->queue_index);
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
