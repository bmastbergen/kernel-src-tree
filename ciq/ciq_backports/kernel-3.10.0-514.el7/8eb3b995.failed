geneve: support setting IPv6 flow label

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit 8eb3b99554b82da968d1fbc00df9f3156c5e2d63
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/8eb3b995.failed

This work adds support for setting the IPv6 flow label for geneve per
device and through collect metadata (ip_tunnel_key) frontends. Also here,
the geneve dst cache does not need any special considerations, for the
cases where caches can be used, the label is static per cache.

	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8eb3b99554b82da968d1fbc00df9f3156c5e2d63)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
#	include/uapi/linux/if_link.h
diff --cc drivers/net/geneve.c
index d82906728571,33185b9a435e..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -55,8 -66,9 +55,9 @@@ struct geneve_dev 
  	u8                 vni[3];	/* virtual network ID for tunnel */
  	u8                 ttl;		/* TTL override */
  	u8                 tos;		/* TOS override */
 -	union geneve_addr  remote;	/* IP address for link partner */
 +	struct sockaddr_in remote;	/* IPv4 address for link partner */
  	struct list_head   next;	/* geneve's per namespace list */
+ 	__be32		   label;	/* IPv6 flowlabel override */
  	__be16		   dst_port;
  	bool		   collect_md;
  	struct gro_cells   gro_cells;
@@@ -609,6 -824,68 +610,69 @@@ static struct rtable *geneve_get_rt(str
  	return rt;
  }
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_IPV6)
+ static struct dst_entry *geneve_get_v6_dst(struct sk_buff *skb,
+ 					   struct net_device *dev,
+ 					   struct flowi6 *fl6,
+ 					   struct ip_tunnel_info *info)
+ {
+ 	bool use_cache = ip_tunnel_dst_cache_usable(skb, info);
+ 	struct geneve_dev *geneve = netdev_priv(dev);
+ 	struct geneve_sock *gs6 = geneve->sock6;
+ 	struct dst_entry *dst = NULL;
+ 	struct dst_cache *dst_cache;
+ 	__u8 prio;
+ 
+ 	memset(fl6, 0, sizeof(*fl6));
+ 	fl6->flowi6_mark = skb->mark;
+ 	fl6->flowi6_proto = IPPROTO_UDP;
+ 
+ 	if (info) {
+ 		fl6->daddr = info->key.u.ipv6.dst;
+ 		fl6->saddr = info->key.u.ipv6.src;
+ 		fl6->flowi6_tos = RT_TOS(info->key.tos);
+ 		fl6->flowlabel = info->key.label;
+ 		dst_cache = &info->dst_cache;
+ 	} else {
+ 		prio = geneve->tos;
+ 		if (prio == 1) {
+ 			const struct iphdr *iip = ip_hdr(skb);
+ 
+ 			prio = ip_tunnel_get_dsfield(iip, skb);
+ 			use_cache = false;
+ 		}
+ 
+ 		fl6->flowi6_tos = RT_TOS(prio);
+ 		fl6->flowlabel = geneve->label;
+ 		fl6->daddr = geneve->remote.sin6.sin6_addr;
+ 		dst_cache = &geneve->dst_cache;
+ 	}
+ 
+ 	if (use_cache) {
+ 		dst = dst_cache_get_ip6(dst_cache, &fl6->saddr);
+ 		if (dst)
+ 			return dst;
+ 	}
+ 
+ 	if (ipv6_stub->ipv6_dst_lookup(geneve->net, gs6->sock->sk, &dst, fl6)) {
+ 		netdev_dbg(dev, "no route to %pI6\n", &fl6->daddr);
+ 		return ERR_PTR(-ENETUNREACH);
+ 	}
+ 	if (dst->dev == dev) { /* is this necessary? */
+ 		netdev_dbg(dev, "circular route to %pI6\n", &fl6->daddr);
+ 		dst_release(dst);
+ 		return ERR_PTR(-ELOOP);
+ 	}
+ 
+ 	if (use_cache)
+ 		dst_cache_set_ip6(dst_cache, dst, &fl6->saddr);
+ 	return dst;
+ }
+ #endif
+ 
++>>>>>>> 8eb3b99554b8 (geneve: support setting IPv6 flow label)
  /* Convert 64 bit tunnel ID to 24 bit VNI. */
  static void tunnel_id_to_vni(__be64 tun_id, __u8 *vni)
  {
@@@ -704,6 -989,177 +768,180 @@@ err
  	return NETDEV_TX_OK;
  }
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_IPV6)
+ static netdev_tx_t geneve6_xmit_skb(struct sk_buff *skb, struct net_device *dev,
+ 				    struct ip_tunnel_info *info)
+ {
+ 	struct geneve_dev *geneve = netdev_priv(dev);
+ 	struct geneve_sock *gs6 = geneve->sock6;
+ 	struct dst_entry *dst = NULL;
+ 	const struct iphdr *iip; /* interior IP header */
+ 	int err = -EINVAL;
+ 	struct flowi6 fl6;
+ 	__u8 prio, ttl;
+ 	__be16 sport;
+ 	__be32 label;
+ 	bool xnet = !net_eq(geneve->net, dev_net(geneve->dev));
+ 	u32 flags = geneve->flags;
+ 
+ 	if (geneve->collect_md) {
+ 		if (unlikely(!info || !(info->mode & IP_TUNNEL_INFO_TX))) {
+ 			netdev_dbg(dev, "no tunnel metadata\n");
+ 			goto tx_error;
+ 		}
+ 	}
+ 
+ 	dst = geneve_get_v6_dst(skb, dev, &fl6, info);
+ 	if (IS_ERR(dst)) {
+ 		err = PTR_ERR(dst);
+ 		goto tx_error;
+ 	}
+ 
+ 	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
+ 	skb_reset_mac_header(skb);
+ 
+ 	iip = ip_hdr(skb);
+ 
+ 	if (info) {
+ 		const struct ip_tunnel_key *key = &info->key;
+ 		u8 *opts = NULL;
+ 		u8 vni[3];
+ 
+ 		tunnel_id_to_vni(key->tun_id, vni);
+ 		if (info->options_len)
+ 			opts = ip_tunnel_info_opts(info);
+ 
+ 		if (key->tun_flags & TUNNEL_CSUM)
+ 			flags &= ~GENEVE_F_UDP_ZERO_CSUM6_TX;
+ 		else
+ 			flags |= GENEVE_F_UDP_ZERO_CSUM6_TX;
+ 
+ 		err = geneve6_build_skb(dst, skb, key->tun_flags, vni,
+ 					info->options_len, opts,
+ 					flags, xnet);
+ 		if (unlikely(err))
+ 			goto err;
+ 
+ 		prio = ip_tunnel_ecn_encap(key->tos, iip, skb);
+ 		ttl = key->ttl;
+ 		label = info->key.label;
+ 	} else {
+ 		err = geneve6_build_skb(dst, skb, 0, geneve->vni,
+ 					0, NULL, flags, xnet);
+ 		if (unlikely(err))
+ 			goto err;
+ 
+ 		prio = ip_tunnel_ecn_encap(fl6.flowi6_tos, iip, skb);
+ 		ttl = geneve->ttl;
+ 		if (!ttl && ipv6_addr_is_multicast(&fl6.daddr))
+ 			ttl = 1;
+ 		ttl = ttl ? : ip6_dst_hoplimit(dst);
+ 		label = geneve->label;
+ 	}
+ 
+ 	udp_tunnel6_xmit_skb(dst, gs6->sock->sk, skb, dev,
+ 			     &fl6.saddr, &fl6.daddr, prio, ttl, label,
+ 			     sport, geneve->dst_port,
+ 			     !!(flags & GENEVE_F_UDP_ZERO_CSUM6_TX));
+ 	return NETDEV_TX_OK;
+ 
+ tx_error:
+ 	dev_kfree_skb(skb);
+ err:
+ 	if (err == -ELOOP)
+ 		dev->stats.collisions++;
+ 	else if (err == -ENETUNREACH)
+ 		dev->stats.tx_carrier_errors++;
+ 	else
+ 		dev->stats.tx_errors++;
+ 	return NETDEV_TX_OK;
+ }
+ #endif
+ 
+ static netdev_tx_t geneve_xmit(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct geneve_dev *geneve = netdev_priv(dev);
+ 	struct ip_tunnel_info *info = NULL;
+ 
+ 	if (geneve->collect_md)
+ 		info = skb_tunnel_info(skb);
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if ((info && ip_tunnel_info_af(info) == AF_INET6) ||
+ 	    (!info && geneve->remote.sa.sa_family == AF_INET6))
+ 		return geneve6_xmit_skb(skb, dev, info);
+ #endif
+ 	return geneve_xmit_skb(skb, dev, info);
+ }
+ 
+ static int __geneve_change_mtu(struct net_device *dev, int new_mtu, bool strict)
+ {
+ 	/* The max_mtu calculation does not take account of GENEVE
+ 	 * options, to avoid excluding potentially valid
+ 	 * configurations.
+ 	 */
+ 	int max_mtu = IP_MAX_MTU - GENEVE_BASE_HLEN - sizeof(struct iphdr)
+ 		- dev->hard_header_len;
+ 
+ 	if (new_mtu < 68)
+ 		return -EINVAL;
+ 
+ 	if (new_mtu > max_mtu) {
+ 		if (strict)
+ 			return -EINVAL;
+ 
+ 		new_mtu = max_mtu;
+ 	}
+ 
+ 	dev->mtu = new_mtu;
+ 	return 0;
+ }
+ 
+ static int geneve_change_mtu(struct net_device *dev, int new_mtu)
+ {
+ 	return __geneve_change_mtu(dev, new_mtu, true);
+ }
+ 
+ static int geneve_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
+ {
+ 	struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 	struct geneve_dev *geneve = netdev_priv(dev);
+ 	struct rtable *rt;
+ 	struct flowi4 fl4;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	struct dst_entry *dst;
+ 	struct flowi6 fl6;
+ #endif
+ 
+ 	if (ip_tunnel_info_af(info) == AF_INET) {
+ 		rt = geneve_get_v4_rt(skb, dev, &fl4, info);
+ 		if (IS_ERR(rt))
+ 			return PTR_ERR(rt);
+ 
+ 		ip_rt_put(rt);
+ 		info->key.u.ipv4.src = fl4.saddr;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	} else if (ip_tunnel_info_af(info) == AF_INET6) {
+ 		dst = geneve_get_v6_dst(skb, dev, &fl6, info);
+ 		if (IS_ERR(dst))
+ 			return PTR_ERR(dst);
+ 
+ 		dst_release(dst);
+ 		info->key.u.ipv6.src = fl6.saddr;
+ #endif
+ 	} else {
+ 		return -EINVAL;
+ 	}
+ 
+ 	info->key.tp_src = udp_flow_src_port(geneve->net, skb,
+ 					     1, USHRT_MAX, true);
+ 	info->key.tp_dst = geneve->dst_port;
+ 	return 0;
+ }
+ 
++>>>>>>> 8eb3b99554b8 (geneve: support setting IPv6 flow label)
  static const struct net_device_ops geneve_netdev_ops = {
  	.ndo_init		= geneve_init,
  	.ndo_uninit		= geneve_uninit,
@@@ -785,10 -1242,15 +1023,11 @@@ static void geneve_setup(struct net_dev
  static const struct nla_policy geneve_policy[IFLA_GENEVE_MAX + 1] = {
  	[IFLA_GENEVE_ID]		= { .type = NLA_U32 },
  	[IFLA_GENEVE_REMOTE]		= { .len = FIELD_SIZEOF(struct iphdr, daddr) },
 -	[IFLA_GENEVE_REMOTE6]		= { .len = sizeof(struct in6_addr) },
  	[IFLA_GENEVE_TTL]		= { .type = NLA_U8 },
  	[IFLA_GENEVE_TOS]		= { .type = NLA_U8 },
+ 	[IFLA_GENEVE_LABEL]		= { .type = NLA_U32 },
  	[IFLA_GENEVE_PORT]		= { .type = NLA_U16 },
  	[IFLA_GENEVE_COLLECT_METADATA]	= { .type = NLA_FLAG },
 -	[IFLA_GENEVE_UDP_CSUM]		= { .type = NLA_U8 },
 -	[IFLA_GENEVE_UDP_ZERO_CSUM6_TX]	= { .type = NLA_U8 },
 -	[IFLA_GENEVE_UDP_ZERO_CSUM6_RX]	= { .type = NLA_U8 },
  };
  
  static int geneve_validate(struct nlattr *tb[], struct nlattr *data[])
@@@ -840,18 -1302,20 +1079,32 @@@ static struct geneve_dev *geneve_find_d
  }
  
  static int geneve_configure(struct net *net, struct net_device *dev,
++<<<<<<< HEAD
 +			    __be32 rem_addr, __u32 vni, __u8 ttl, __u8 tos,
 +			    __be16 dst_port, bool metadata)
++=======
+ 			    union geneve_addr *remote,
+ 			    __u32 vni, __u8 ttl, __u8 tos, __be32 label,
+ 			    __be16 dst_port, bool metadata, u32 flags)
++>>>>>>> 8eb3b99554b8 (geneve: support setting IPv6 flow label)
  {
  	struct geneve_net *gn = net_generic(net, geneve_net_id);
  	struct geneve_dev *t, *geneve = netdev_priv(dev);
  	bool tun_collect_md, tun_on_same_port;
  	int err, encap_len;
  
++<<<<<<< HEAD
 +	if (metadata) {
 +		if (rem_addr || vni || tos || ttl)
 +			return -EINVAL;
 +	}
++=======
+ 	if (!remote)
+ 		return -EINVAL;
+ 	if (metadata &&
+ 	    (remote->sa.sa_family != AF_UNSPEC || vni || tos || ttl || label))
+ 		return -EINVAL;
++>>>>>>> 8eb3b99554b8 (geneve: support setting IPv6 flow label)
  
  	geneve->net = net;
  	geneve->dev = dev;
@@@ -860,16 -1324,24 +1113,24 @@@
  	geneve->vni[1] = (vni & 0x0000ff00) >> 8;
  	geneve->vni[2] =  vni & 0x000000ff;
  
 -	if ((remote->sa.sa_family == AF_INET &&
 -	     IN_MULTICAST(ntohl(remote->sin.sin_addr.s_addr))) ||
 -	    (remote->sa.sa_family == AF_INET6 &&
 -	     ipv6_addr_is_multicast(&remote->sin6.sin6_addr)))
 +	geneve->remote.sin_addr.s_addr = rem_addr;
 +	if (IN_MULTICAST(ntohl(geneve->remote.sin_addr.s_addr)))
  		return -EINVAL;
++<<<<<<< HEAD
++=======
+ 	if (label && remote->sa.sa_family != AF_INET6)
+ 		return -EINVAL;
+ 
+ 	geneve->remote = *remote;
++>>>>>>> 8eb3b99554b8 (geneve: support setting IPv6 flow label)
  
  	geneve->ttl = ttl;
  	geneve->tos = tos;
+ 	geneve->label = label;
  	geneve->dst_port = dst_port;
  	geneve->collect_md = metadata;
 -	geneve->flags = flags;
  
 -	t = geneve_find_dev(gn, dst_port, remote, geneve->vni,
 +	t = geneve_find_dev(gn, dst_port, rem_addr, geneve->vni,
  			    &tun_on_same_port, &tun_collect_md);
  	if (t)
  		return -EBUSY;
@@@ -904,14 -1378,37 +1165,21 @@@ static int geneve_newlink(struct net *n
  	__be16 dst_port = htons(GENEVE_UDP_PORT);
  	__u8 ttl = 0, tos = 0;
  	bool metadata = false;
++<<<<<<< HEAD
 +	__be32 rem_addr;
 +	__u32 vni;
++=======
+ 	union geneve_addr remote = geneve_remote_unspec;
+ 	__be32 label = 0;
+ 	__u32 vni = 0;
+ 	u32 flags = 0;
++>>>>>>> 8eb3b99554b8 (geneve: support setting IPv6 flow label)
  
 -	if (data[IFLA_GENEVE_REMOTE] && data[IFLA_GENEVE_REMOTE6])
 +	if (!data[IFLA_GENEVE_ID] || !data[IFLA_GENEVE_REMOTE])
  		return -EINVAL;
  
 -	if (data[IFLA_GENEVE_REMOTE]) {
 -		remote.sa.sa_family = AF_INET;
 -		remote.sin.sin_addr.s_addr =
 -			nla_get_in_addr(data[IFLA_GENEVE_REMOTE]);
 -	}
 -
 -	if (data[IFLA_GENEVE_REMOTE6]) {
 -		if (!IS_ENABLED(CONFIG_IPV6))
 -			return -EPFNOSUPPORT;
 -
 -		remote.sa.sa_family = AF_INET6;
 -		remote.sin6.sin6_addr =
 -			nla_get_in6_addr(data[IFLA_GENEVE_REMOTE6]);
 -
 -		if (ipv6_addr_type(&remote.sin6.sin6_addr) &
 -		    IPV6_ADDR_LINKLOCAL) {
 -			netdev_dbg(dev, "link-local remote is unsupported\n");
 -			return -EINVAL;
 -		}
 -	}
 -
 -	if (data[IFLA_GENEVE_ID])
 -		vni = nla_get_u32(data[IFLA_GENEVE_ID]);
 +	vni = nla_get_u32(data[IFLA_GENEVE_ID]);
 +	rem_addr = nla_get_in_addr(data[IFLA_GENEVE_REMOTE]);
  
  	if (data[IFLA_GENEVE_TTL])
  		ttl = nla_get_u8(data[IFLA_GENEVE_TTL]);
@@@ -925,8 -1426,20 +1197,25 @@@
  	if (data[IFLA_GENEVE_COLLECT_METADATA])
  		metadata = true;
  
++<<<<<<< HEAD
 +	return geneve_configure(net, dev, rem_addr, vni,
 +				ttl, tos, dst_port, metadata);
++=======
+ 	if (data[IFLA_GENEVE_UDP_CSUM] &&
+ 	    !nla_get_u8(data[IFLA_GENEVE_UDP_CSUM]))
+ 		flags |= GENEVE_F_UDP_ZERO_CSUM_TX;
+ 
+ 	if (data[IFLA_GENEVE_UDP_ZERO_CSUM6_TX] &&
+ 	    nla_get_u8(data[IFLA_GENEVE_UDP_ZERO_CSUM6_TX]))
+ 		flags |= GENEVE_F_UDP_ZERO_CSUM6_TX;
+ 
+ 	if (data[IFLA_GENEVE_UDP_ZERO_CSUM6_RX] &&
+ 	    nla_get_u8(data[IFLA_GENEVE_UDP_ZERO_CSUM6_RX]))
+ 		flags |= GENEVE_F_UDP_ZERO_CSUM6_RX;
+ 
+ 	return geneve_configure(net, dev, &remote, vni, ttl, tos, label,
+ 				dst_port, metadata, flags);
++>>>>>>> 8eb3b99554b8 (geneve: support setting IPv6 flow label)
  }
  
  static void geneve_dellink(struct net_device *dev, struct list_head *head)
@@@ -940,11 -1453,15 +1229,12 @@@
  static size_t geneve_get_size(const struct net_device *dev)
  {
  	return nla_total_size(sizeof(__u32)) +	/* IFLA_GENEVE_ID */
 -		nla_total_size(sizeof(struct in6_addr)) + /* IFLA_GENEVE_REMOTE{6} */
 +		nla_total_size(sizeof(struct in_addr)) + /* IFLA_GENEVE_REMOTE */
  		nla_total_size(sizeof(__u8)) +  /* IFLA_GENEVE_TTL */
  		nla_total_size(sizeof(__u8)) +  /* IFLA_GENEVE_TOS */
+ 		nla_total_size(sizeof(__be32)) +  /* IFLA_GENEVE_LABEL */
  		nla_total_size(sizeof(__be16)) +  /* IFLA_GENEVE_PORT */
  		nla_total_size(0) +	 /* IFLA_GENEVE_COLLECT_METADATA */
 -		nla_total_size(sizeof(__u8)) + /* IFLA_GENEVE_UDP_CSUM */
 -		nla_total_size(sizeof(__u8)) + /* IFLA_GENEVE_UDP_ZERO_CSUM6_TX */
 -		nla_total_size(sizeof(__u8)) + /* IFLA_GENEVE_UDP_ZERO_CSUM6_RX */
  		0;
  }
  
@@@ -957,12 -1474,21 +1247,13 @@@ static int geneve_fill_info(struct sk_b
  	if (nla_put_u32(skb, IFLA_GENEVE_ID, vni))
  		goto nla_put_failure;
  
 -	if (geneve->remote.sa.sa_family == AF_INET) {
 -		if (nla_put_in_addr(skb, IFLA_GENEVE_REMOTE,
 -				    geneve->remote.sin.sin_addr.s_addr))
 -			goto nla_put_failure;
 -#if IS_ENABLED(CONFIG_IPV6)
 -	} else {
 -		if (nla_put_in6_addr(skb, IFLA_GENEVE_REMOTE6,
 -				     &geneve->remote.sin6.sin6_addr))
 -			goto nla_put_failure;
 -#endif
 -	}
 +	if (nla_put_in_addr(skb, IFLA_GENEVE_REMOTE,
 +			    geneve->remote.sin_addr.s_addr))
 +		goto nla_put_failure;
  
  	if (nla_put_u8(skb, IFLA_GENEVE_TTL, geneve->ttl) ||
- 	    nla_put_u8(skb, IFLA_GENEVE_TOS, geneve->tos))
+ 	    nla_put_u8(skb, IFLA_GENEVE_TOS, geneve->tos) ||
+ 	    nla_put_be32(skb, IFLA_GENEVE_LABEL, geneve->label))
  		goto nla_put_failure;
  
  	if (nla_put_be16(skb, IFLA_GENEVE_PORT, geneve->dst_port))
@@@ -1005,12 -1539,24 +1296,28 @@@ struct net_device *geneve_dev_create_fb
  	if (IS_ERR(dev))
  		return dev;
  
++<<<<<<< HEAD
 +	err = geneve_configure(net, dev, 0, 0, 0, 0, htons(dst_port), true);
 +	if (err) {
 +		free_netdev(dev);
 +		return ERR_PTR(err);
 +	}
++=======
+ 	err = geneve_configure(net, dev, &geneve_remote_unspec,
+ 			       0, 0, 0, 0, htons(dst_port), true,
+ 			       GENEVE_F_UDP_ZERO_CSUM6_RX);
+ 	if (err)
+ 		goto err;
+ 
+ 	/* openvswitch users expect packet sizes to be unrestricted,
+ 	 * so set the largest MTU we can.
+ 	 */
+ 	err = __geneve_change_mtu(dev, IP_MAX_MTU, false);
+ 	if (err)
+ 		goto err;
+ 
++>>>>>>> 8eb3b99554b8 (geneve: support setting IPv6 flow label)
  	return dev;
 -
 - err:
 -	free_netdev(dev);
 -	return ERR_PTR(err);
  }
  EXPORT_SYMBOL_GPL(geneve_dev_create_fb);
  
diff --cc include/uapi/linux/if_link.h
index 719f99b573ac,249eef9a21bd..000000000000
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@@ -355,6 -475,11 +355,14 @@@ enum 
  	IFLA_GENEVE_TOS,
  	IFLA_GENEVE_PORT,	/* destination port */
  	IFLA_GENEVE_COLLECT_METADATA,
++<<<<<<< HEAD
++=======
+ 	IFLA_GENEVE_REMOTE6,
+ 	IFLA_GENEVE_UDP_CSUM,
+ 	IFLA_GENEVE_UDP_ZERO_CSUM6_TX,
+ 	IFLA_GENEVE_UDP_ZERO_CSUM6_RX,
+ 	IFLA_GENEVE_LABEL,
++>>>>>>> 8eb3b99554b8 (geneve: support setting IPv6 flow label)
  	__IFLA_GENEVE_MAX
  };
  #define IFLA_GENEVE_MAX	(__IFLA_GENEVE_MAX - 1)
* Unmerged path drivers/net/geneve.c
* Unmerged path include/uapi/linux/if_link.h
