mmc: slot-gpio: Add debouncing capability to mmc_gpio_request_cd()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
commit 214fc309d1387e822d606a33a10e31cacfe83520
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/214fc309.failed

Add a debounce parameter to the mmc_gpio_request_cd() function that
enables GPIO debouncing when set to a non-zero value. This can be used
by MMC host drivers to enable debouncing on the card detect signal.

	Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
	Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
	Signed-off-by: Chris Ball <cjb@laptop.org>
(cherry picked from commit 214fc309d1387e822d606a33a10e31cacfe83520)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/jz4740_mmc.c
#	drivers/mmc/host/mvsdio.c
diff --cc drivers/mmc/host/jz4740_mmc.c
index 1c47b3473ce3,66516339e3a0..000000000000
--- a/drivers/mmc/host/jz4740_mmc.c
+++ b/drivers/mmc/host/jz4740_mmc.c
@@@ -732,50 -707,25 +732,58 @@@ static int jz4740_mmc_request_gpios(str
  	if (!pdata)
  		return 0;
  
 -	if (!pdata->card_detect_active_low)
 -		mmc->caps2 |= MMC_CAP2_CD_ACTIVE_HIGH;
 -	if (!pdata->read_only_active_low)
 -		mmc->caps2 |= MMC_CAP2_RO_ACTIVE_HIGH;
 +	ret = jz4740_mmc_request_gpio(&pdev->dev, pdata->gpio_card_detect,
 +			"MMC detect change", false, 0);
 +	if (ret)
 +		goto err;
  
++<<<<<<< HEAD
 +	ret = jz4740_mmc_request_gpio(&pdev->dev, pdata->gpio_read_only,
 +			"MMC read only", false, 0);
 +	if (ret)
 +		goto err_free_gpio_card_detect;
++=======
+ 	if (gpio_is_valid(pdata->gpio_card_detect)) {
+ 		ret = mmc_gpio_request_cd(mmc, pdata->gpio_card_detect, 0);
+ 		if (ret)
+ 			return ret;
+ 	}
++>>>>>>> 214fc309d138 (mmc: slot-gpio: Add debouncing capability to mmc_gpio_request_cd())
  
 -	if (gpio_is_valid(pdata->gpio_read_only)) {
 -		ret = mmc_gpio_request_ro(mmc, pdata->gpio_read_only);
 -		if (ret)
 -			return ret;
 +	ret = jz4740_mmc_request_gpio(&pdev->dev, pdata->gpio_power,
 +			"MMC read only", true, pdata->power_active_low);
 +	if (ret)
 +		goto err_free_gpio_read_only;
 +
 +	return 0;
 +
 +err_free_gpio_read_only:
 +	if (gpio_is_valid(pdata->gpio_read_only))
 +		gpio_free(pdata->gpio_read_only);
 +err_free_gpio_card_detect:
 +	if (gpio_is_valid(pdata->gpio_card_detect))
 +		gpio_free(pdata->gpio_card_detect);
 +err:
 +	return ret;
 +}
 +
 +static int jz4740_mmc_request_cd_irq(struct platform_device *pdev,
 +	struct jz4740_mmc_host *host)
 +{
 +	struct jz4740_mmc_platform_data *pdata = pdev->dev.platform_data;
 +
 +	if (!gpio_is_valid(pdata->gpio_card_detect))
 +		return 0;
 +
 +	host->card_detect_irq = gpio_to_irq(pdata->gpio_card_detect);
 +	if (host->card_detect_irq < 0) {
 +		dev_warn(&pdev->dev, "Failed to get card detect irq\n");
 +		return 0;
  	}
  
 -	return jz4740_mmc_request_gpio(&pdev->dev, pdata->gpio_power,
 -			"MMC read only", true, pdata->power_active_low);
 +	return request_irq(host->card_detect_irq, jz4740_mmc_card_detect_irq,
 +			IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
 +			"MMC card detect", host);
  }
  
  static void jz4740_mmc_free_gpios(struct platform_device *pdev)
diff --cc drivers/mmc/host/mvsdio.c
index d08fe6ae9bf8,06c5b0b28ebc..000000000000
--- a/drivers/mmc/host/mvsdio.c
+++ b/drivers/mmc/host/mvsdio.c
@@@ -735,26 -750,28 +735,44 @@@ static int __init mvsd_probe(struct pla
  			ret = -ENXIO;
  			goto out;
  		}
 -		mmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ |
 -			    MMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED;
  		host->base_clock = mvsd_data->clock / 2;
++<<<<<<< HEAD
 +		gpio_card_detect = mvsd_data->gpio_card_detect ? : -EINVAL;
 +		gpio_write_protect = mvsd_data->gpio_write_protect ? : -EINVAL;
++=======
+ 		/* GPIO 0 regarded as invalid for backward compatibility */
+ 		if (mvsd_data->gpio_card_detect &&
+ 		    gpio_is_valid(mvsd_data->gpio_card_detect)) {
+ 			ret = mmc_gpio_request_cd(mmc,
+ 						  mvsd_data->gpio_card_detect,
+ 						  0);
+ 			if (ret)
+ 				goto out;
+ 		} else {
+ 			mmc->caps |= MMC_CAP_NEEDS_POLL;
+ 		}
+ 
+ 		if (mvsd_data->gpio_write_protect &&
+ 		    gpio_is_valid(mvsd_data->gpio_write_protect))
+ 			mmc_gpio_request_ro(mmc, mvsd_data->gpio_write_protect);
++>>>>>>> 214fc309d138 (mmc: slot-gpio: Add debouncing capability to mmc_gpio_request_cd())
  	}
  
 -	if (maxfreq)
 -		mmc->f_max = maxfreq;
 +	mmc->ops = &mvsd_ops;
 +
 +	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
 +	mmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ |
 +		    MMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED;
 +
 +	mmc->f_min = DIV_ROUND_UP(host->base_clock, MVSD_BASE_DIV_MAX);
 +	mmc->f_max = maxfreq;
 +
 +	mmc->max_blk_size = 2048;
 +	mmc->max_blk_count = 65535;
 +
 +	mmc->max_segs = 1;
 +	mmc->max_seg_size = mmc->max_blk_size * mmc->max_blk_count;
 +	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
  
  	spin_lock_init(&host->lock);
  
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index 6fb6f77450cb..49bc403e31f0 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -374,7 +374,7 @@ int mmc_of_parse(struct mmc_host *host)
 			if (!(flags & OF_GPIO_ACTIVE_LOW))
 				gpio_inv_cd = true;
 
-			ret = mmc_gpio_request_cd(host, gpio);
+			ret = mmc_gpio_request_cd(host, gpio, 0);
 			if (ret < 0) {
 				dev_err(host->parent,
 					"Failed to request CD GPIO #%d: %d!\n",
diff --git a/drivers/mmc/core/slot-gpio.c b/drivers/mmc/core/slot-gpio.c
index 324235105519..46596b71a32f 100644
--- a/drivers/mmc/core/slot-gpio.c
+++ b/drivers/mmc/core/slot-gpio.c
@@ -135,6 +135,7 @@ EXPORT_SYMBOL(mmc_gpio_request_ro);
  * mmc_gpio_request_cd - request a gpio for card-detection
  * @host: mmc host
  * @gpio: gpio number requested
+ * @debounce: debounce time in microseconds
  *
  * As devm_* managed functions are used in mmc_gpio_request_cd(), client
  * drivers do not need to explicitly call mmc_gpio_free_cd() for freeing up,
@@ -143,9 +144,14 @@ EXPORT_SYMBOL(mmc_gpio_request_ro);
  * switching for card-detection, they are responsible for calling
  * mmc_gpio_request_cd() and mmc_gpio_free_cd() as a pair on their own.
  *
+ * If GPIO debouncing is desired, set the debounce parameter to a non-zero
+ * value. The caller is responsible for ensuring that the GPIO driver associated
+ * with the GPIO supports debouncing, otherwise an error will be returned.
+ *
  * Returns zero on success, else an error.
  */
-int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio)
+int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio,
+			unsigned int debounce)
 {
 	struct mmc_gpio *ctx;
 	int irq = gpio_to_irq(gpio);
@@ -167,6 +173,12 @@ int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio)
 		 */
 		return ret;
 
+	if (debounce) {
+		ret = gpio_set_debounce(gpio, debounce);
+		if (ret < 0)
+			return ret;
+	}
+
 	/*
 	 * Even if gpio_to_irq() returns a valid IRQ number, the platform might
 	 * still prefer to poll, e.g., because that IRQ number is already used
* Unmerged path drivers/mmc/host/jz4740_mmc.c
* Unmerged path drivers/mmc/host/mvsdio.c
diff --git a/drivers/mmc/host/sdhci-esdhc-imx.c b/drivers/mmc/host/sdhci-esdhc-imx.c
index 98f46704baa6..ef215ac09bab 100644
--- a/drivers/mmc/host/sdhci-esdhc-imx.c
+++ b/drivers/mmc/host/sdhci-esdhc-imx.c
@@ -592,7 +592,7 @@ static int sdhci_esdhc_imx_probe(struct platform_device *pdev)
 	/* card_detect */
 	switch (boarddata->cd_type) {
 	case ESDHC_CD_GPIO:
-		err = mmc_gpio_request_cd(host->mmc, boarddata->cd_gpio);
+		err = mmc_gpio_request_cd(host->mmc, boarddata->cd_gpio, 0);
 		if (err) {
 			dev_err(mmc_dev(host->mmc),
 				"failed to request card-detect gpio!\n");
diff --git a/drivers/mmc/host/sdhci-pxav3.c b/drivers/mmc/host/sdhci-pxav3.c
index 56d9bee93d8f..848018cdaa58 100644
--- a/drivers/mmc/host/sdhci-pxav3.c
+++ b/drivers/mmc/host/sdhci-pxav3.c
@@ -276,7 +276,8 @@ static int sdhci_pxav3_probe(struct platform_device *pdev)
 			host->mmc->pm_caps |= pdata->pm_caps;
 
 		if (gpio_is_valid(pdata->ext_cd_gpio)) {
-			ret = mmc_gpio_request_cd(host->mmc, pdata->ext_cd_gpio);
+			ret = mmc_gpio_request_cd(host->mmc, pdata->ext_cd_gpio,
+						  0);
 			if (ret) {
 				dev_err(mmc_dev(host->mmc),
 					"failed to allocate card detect gpio\n");
diff --git a/drivers/mmc/host/sdhci-sirf.c b/drivers/mmc/host/sdhci-sirf.c
index 09805af0526d..b665326d878e 100644
--- a/drivers/mmc/host/sdhci-sirf.c
+++ b/drivers/mmc/host/sdhci-sirf.c
@@ -97,7 +97,7 @@ static int sdhci_sirf_probe(struct platform_device *pdev)
 	 * gets setup in sdhci_add_host() and we oops.
 	 */
 	if (gpio_is_valid(priv->gpio_cd)) {
-		ret = mmc_gpio_request_cd(host->mmc, priv->gpio_cd);
+		ret = mmc_gpio_request_cd(host->mmc, priv->gpio_cd, 0);
 		if (ret) {
 			dev_err(&pdev->dev, "card detect irq request failed: %d\n",
 				ret);
diff --git a/drivers/mmc/host/sh_mmcif.c b/drivers/mmc/host/sh_mmcif.c
index 117a1f774720..c219033d8328 100644
--- a/drivers/mmc/host/sh_mmcif.c
+++ b/drivers/mmc/host/sh_mmcif.c
@@ -1431,7 +1431,7 @@ static int sh_mmcif_probe(struct platform_device *pdev)
 	}
 
 	if (pd && pd->use_cd_gpio) {
-		ret = mmc_gpio_request_cd(mmc, pd->cd_gpio);
+		ret = mmc_gpio_request_cd(mmc, pd->cd_gpio, 0);
 		if (ret < 0)
 			goto erqcd;
 	}
diff --git a/drivers/mmc/host/tmio_mmc_pio.c b/drivers/mmc/host/tmio_mmc_pio.c
index f508ecb5b8a7..5a1bc3b4ec8b 100644
--- a/drivers/mmc/host/tmio_mmc_pio.c
+++ b/drivers/mmc/host/tmio_mmc_pio.c
@@ -1091,7 +1091,7 @@ int tmio_mmc_host_probe(struct tmio_mmc_host **host,
 	dev_pm_qos_expose_latency_limit(&pdev->dev, 100);
 
 	if (pdata->flags & TMIO_MMC_USE_GPIO_CD) {
-		ret = mmc_gpio_request_cd(mmc, pdata->cd_gpio);
+		ret = mmc_gpio_request_cd(mmc, pdata->cd_gpio, 0);
 		if (ret < 0) {
 			tmio_mmc_host_remove(_host);
 			return ret;
diff --git a/include/linux/mmc/slot-gpio.h b/include/linux/mmc/slot-gpio.h
index 7d88d27bfafa..b0c73e4cacea 100644
--- a/include/linux/mmc/slot-gpio.h
+++ b/include/linux/mmc/slot-gpio.h
@@ -18,7 +18,8 @@ int mmc_gpio_request_ro(struct mmc_host *host, unsigned int gpio);
 void mmc_gpio_free_ro(struct mmc_host *host);
 
 int mmc_gpio_get_cd(struct mmc_host *host);
-int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio);
+int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio,
+			unsigned int debounce);
 void mmc_gpio_free_cd(struct mmc_host *host);
 
 #endif
