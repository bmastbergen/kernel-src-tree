KVM: x86: Add a common TSC scaling ratio field in kvm_vcpu_arch

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Haozhong Zhang <haozhong.zhang@intel.com>
commit ad721883e9c5f46cc5fa9496bc12c097c6238b4a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/ad721883.failed

This patch moves the field of TSC scaling ratio from the architecture
struct vcpu_svm to the common struct kvm_vcpu_arch.

	Signed-off-by: Haozhong Zhang <haozhong.zhang@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit ad721883e9c5f46cc5fa9496bc12c097c6238b4a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm.c
diff --cc arch/x86/kvm/svm.c
index f4d872b9eba6,9c92e6f429d0..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -158,7 -158,8 +158,12 @@@ struct vcpu_svm 
  	unsigned long int3_rip;
  	u32 apf_reason;
  
++<<<<<<< HEAD
 +	u64  tsc_ratio;
++=======
+ 	/* cached guest cpuid flags for faster access */
+ 	bool nrips_enabled	: 1;
++>>>>>>> ad721883e9c5 (KVM: x86: Add a common TSC scaling ratio field in kvm_vcpu_arch)
  };
  
  static DEFINE_PER_CPU(u64, current_tsc_ratio);
@@@ -1321,10 -1319,12 +1322,19 @@@ static void svm_vcpu_load(struct kvm_vc
  	for (i = 0; i < NR_HOST_SAVE_USER_MSRS; i++)
  		rdmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);
  
++<<<<<<< HEAD
 +	if (static_cpu_has(X86_FEATURE_TSCRATEMSR) &&
 +	    svm->tsc_ratio != __get_cpu_var(current_tsc_ratio)) {
 +		__get_cpu_var(current_tsc_ratio) = svm->tsc_ratio;
 +		wrmsrl(MSR_AMD64_TSC_RATIO, svm->tsc_ratio);
++=======
+ 	if (static_cpu_has(X86_FEATURE_TSCRATEMSR)) {
+ 		u64 tsc_ratio = vcpu->arch.tsc_scaling_ratio;
+ 		if (tsc_ratio != __this_cpu_read(current_tsc_ratio)) {
+ 			__this_cpu_write(current_tsc_ratio, tsc_ratio);
+ 			wrmsrl(MSR_AMD64_TSC_RATIO, tsc_ratio);
+ 		}
++>>>>>>> ad721883e9c5 (KVM: x86: Add a common TSC scaling ratio field in kvm_vcpu_arch)
  	}
  }
  
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index c40aad26d942..85400d3301b5 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -474,6 +474,7 @@ struct kvm_vcpu_arch {
 	u32 virtual_tsc_mult;
 	u32 virtual_tsc_khz;
 	s64 ia32_tsc_adjust_msr;
+	u64 tsc_scaling_ratio;
 
 	atomic_t nmi_queued;  /* unprocessed asynchronous NMIs */
 	unsigned nmi_pending; /* NMI queued after currently running handler */
* Unmerged path arch/x86/kvm/svm.c
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 24f418aad1ea..679f5e9023ec 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -113,6 +113,7 @@ u8   __read_mostly kvm_tsc_scaling_ratio_frac_bits;
 EXPORT_SYMBOL_GPL(kvm_tsc_scaling_ratio_frac_bits);
 u64  __read_mostly kvm_max_tsc_scaling_ratio;
 EXPORT_SYMBOL_GPL(kvm_max_tsc_scaling_ratio);
+static u64 __read_mostly kvm_default_tsc_scaling_ratio;
 
 /* tsc tolerance in parts per million - default to 1/2 of the NTP threshold */
 static u32 __read_mostly tsc_tolerance_ppm = 250;
@@ -1243,8 +1244,11 @@ static void kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 this_tsc_khz)
 	int use_scaling = 0;
 
 	/* tsc_khz can be zero if TSC calibration fails */
-	if (this_tsc_khz == 0)
+	if (this_tsc_khz == 0) {
+		/* set tsc_scaling_ratio to a safe value */
+		vcpu->arch.tsc_scaling_ratio = kvm_default_tsc_scaling_ratio;
 		return;
+	}
 
 	/* Compute a scale to convert nanoseconds in TSC cycles */
 	kvm_get_time_scale(this_tsc_khz, NSEC_PER_SEC / 1000,
@@ -7754,6 +7758,9 @@ int kvm_arch_hardware_setup(void)
 	if (r != 0)
 		return r;
 
+	if (kvm_has_tsc_control)
+		kvm_default_tsc_scaling_ratio = 1ULL << kvm_tsc_scaling_ratio_frac_bits;
+
 	kvm_init_msr_list();
 	return 0;
 }
