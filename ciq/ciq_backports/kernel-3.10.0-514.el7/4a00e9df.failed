prctl: more prctl(PR_SET_MM_*) checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Alexey Dobriyan <adobriyan@gmail.com>
commit 4a00e9df293d010acbea118b9521e08cb85016c6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/4a00e9df.failed

Individual prctl(PR_SET_MM_*) calls do some checking to maintain a
consistent view of mm->arg_start et al fields, but not enough.  In
particular PR_SET_MM_ARG_START/PR_SET_MM_ARG_END/ R_SET_MM_ENV_START/
PR_SET_MM_ENV_END only check that the address lies in an existing VMA,
but don't check that the start address is lower than the end address _at
all_.

Consolidate all consistency checks, so there will be no difference in
the future between PR_SET_MM_MAP and individual PR_SET_MM_* calls.

The program below makes both ARGV and ENVP areas be reversed.  It makes
/proc/$PID/cmdline show garbage (it doesn't oops by luck).

#include <sys/mman.h>
#include <sys/prctl.h>
#include <unistd.h>

enum {PAGE_SIZE=4096};

int main(void)
{
	void *p;

	p = mmap(NULL, PAGE_SIZE, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);

#define PR_SET_MM               35
#define PR_SET_MM_ARG_START     8
#define PR_SET_MM_ARG_END       9
#define PR_SET_MM_ENV_START     10
#define PR_SET_MM_ENV_END       11
	prctl(PR_SET_MM, PR_SET_MM_ARG_START, (unsigned long)p + PAGE_SIZE - 1, 0, 0);
	prctl(PR_SET_MM, PR_SET_MM_ARG_END,   (unsigned long)p, 0, 0);
	prctl(PR_SET_MM, PR_SET_MM_ENV_START, (unsigned long)p + PAGE_SIZE - 1, 0, 0);
	prctl(PR_SET_MM, PR_SET_MM_ENV_END,   (unsigned long)p, 0, 0);

	pause();
	return 0;
}

[akpm@linux-foundation.org: tidy code, tweak comment]
	Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
	Acked-by: Cyrill Gorcunov <gorcunov@openvz.org>
	Cc: Jarod Wilson <jarod@redhat.com>
	Cc: Jan Stancek <jstancek@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 4a00e9df293d010acbea118b9521e08cb85016c6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sys.c
diff --cc kernel/sys.c
index 5149ddb9041c,259fda25eb6b..000000000000
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@@ -1949,9 -1716,12 +1949,8 @@@ static int prctl_set_mm_exe_file_locked
  exit:
  	fdput(exe);
  	return err;
 -exit_err:
 -	up_read(&mm->mmap_sem);
 -	fput(exe_file);
 -	goto exit;
  }
  
- #ifdef CONFIG_CHECKPOINT_RESTORE
  /*
   * WARNING: we don't require any capability here so be very careful
   * in what is allowed for modification from userspace.
@@@ -2135,8 -1935,8 +2165,9 @@@ static int prctl_set_auxv(struct mm_str
  static int prctl_set_mm(int opt, unsigned long addr,
  			unsigned long arg4, unsigned long arg5)
  {
 +	unsigned long rlim = rlimit(RLIMIT_DATA);
  	struct mm_struct *mm = current->mm;
+ 	struct prctl_mm_map prctl_map;
  	struct vm_area_struct *vma;
  	int error;
  
@@@ -2153,13 -1953,12 +2184,16 @@@
  	if (!capable(CAP_SYS_RESOURCE))
  		return -EPERM;
  
 -	if (opt == PR_SET_MM_EXE_FILE)
 -		return prctl_set_mm_exe_file(mm, (unsigned int)addr);
 +	if (opt == PR_SET_MM_EXE_FILE) {
 +		down_write(&mm->mmap_sem);
 +		error = prctl_set_mm_exe_file_locked(mm, (unsigned int)addr);
 +		up_write(&mm->mmap_sem);
 +		return error;
 +	}
  
+ 	if (opt == PR_SET_MM_AUXV)
+ 		return prctl_set_auxv(mm, addr, arg4);
+ 
  	if (addr >= TASK_SIZE || addr < mmap_min_addr)
  		return -EINVAL;
  
@@@ -2168,44 -1967,64 +2202,88 @@@
  	down_read(&mm->mmap_sem);
  	vma = find_vma(mm, addr);
  
+ 	prctl_map.start_code	= mm->start_code;
+ 	prctl_map.end_code	= mm->end_code;
+ 	prctl_map.start_data	= mm->start_data;
+ 	prctl_map.end_data	= mm->end_data;
+ 	prctl_map.start_brk	= mm->start_brk;
+ 	prctl_map.brk		= mm->brk;
+ 	prctl_map.start_stack	= mm->start_stack;
+ 	prctl_map.arg_start	= mm->arg_start;
+ 	prctl_map.arg_end	= mm->arg_end;
+ 	prctl_map.env_start	= mm->env_start;
+ 	prctl_map.env_end	= mm->env_end;
+ 	prctl_map.auxv		= NULL;
+ 	prctl_map.auxv_size	= 0;
+ 	prctl_map.exe_fd	= -1;
+ 
  	switch (opt) {
  	case PR_SET_MM_START_CODE:
- 		mm->start_code = addr;
+ 		prctl_map.start_code = addr;
  		break;
  	case PR_SET_MM_END_CODE:
- 		mm->end_code = addr;
+ 		prctl_map.end_code = addr;
  		break;
  	case PR_SET_MM_START_DATA:
- 		mm->start_data = addr;
+ 		prctl_map.start_data = addr;
  		break;
  	case PR_SET_MM_END_DATA:
- 		mm->end_data = addr;
+ 		prctl_map.end_data = addr;
+ 		break;
+ 	case PR_SET_MM_START_STACK:
+ 		prctl_map.start_stack = addr;
  		break;
- 
  	case PR_SET_MM_START_BRK:
++<<<<<<< HEAD
 +		if (addr <= mm->end_data)
 +			goto out;
 +
 +		if (rlim < RLIM_INFINITY &&
 +		    (mm->brk - addr) +
 +		    (mm->end_data - mm->start_data) > rlim)
 +			goto out;
 +
 +		mm->start_brk = addr;
++=======
+ 		prctl_map.start_brk = addr;
++>>>>>>> 4a00e9df293d (prctl: more prctl(PR_SET_MM_*) checks)
  		break;
- 
  	case PR_SET_MM_BRK:
++<<<<<<< HEAD
 +		if (addr <= mm->end_data)
 +			goto out;
 +
 +		if (rlim < RLIM_INFINITY &&
 +		    (addr - mm->start_brk) +
 +		    (mm->end_data - mm->start_data) > rlim)
 +			goto out;
 +
 +		mm->brk = addr;
++=======
+ 		prctl_map.brk = addr;
++>>>>>>> 4a00e9df293d (prctl: more prctl(PR_SET_MM_*) checks)
+ 		break;
+ 	case PR_SET_MM_ARG_START:
+ 		prctl_map.arg_start = addr;
  		break;
+ 	case PR_SET_MM_ARG_END:
+ 		prctl_map.arg_end = addr;
+ 		break;
+ 	case PR_SET_MM_ENV_START:
+ 		prctl_map.env_start = addr;
+ 		break;
+ 	case PR_SET_MM_ENV_END:
+ 		prctl_map.env_end = addr;
+ 		break;
+ 	default:
+ 		goto out;
+ 	}
+ 
+ 	error = validate_prctl_map(&prctl_map);
+ 	if (error)
+ 		goto out;
  
+ 	switch (opt) {
  	/*
  	 * If command line arguments and environment
  	 * are placed somewhere else on stack, we can
* Unmerged path kernel/sys.c
