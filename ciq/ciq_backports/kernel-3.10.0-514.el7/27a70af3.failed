hv_netvsc: rework link status change handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 27a70af3f4cf633a1b86c0ac7b426e2fe16ad2e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/27a70af3.failed

There are several issues in hv_netvsc driver with regards to link status
change handling:
- RNDIS_STATUS_NETWORK_CHANGE results in calling userspace helper doing
  '/etc/init.d/network restart' and this is inappropriate and broken for
  many reasons.
- link_watch infrastructure only sends one notification per second and
  in case of e.g. paired disconnect/connect events we get only one
  notification with last status. This makes it impossible to handle such
  situations in userspace.

Redo link status changes handling in the following way:
- Create a list of reconfig events in network device context.
- On a reconfig event add it to the list of events and schedule
  netvsc_link_change().
- In netvsc_link_change() ensure 2-second delay between link status
  changes.
- Handle RNDIS_STATUS_NETWORK_CHANGE as a paired disconnect/connect event.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 27a70af3f4cf633a1b86c0ac7b426e2fe16ad2e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/hyperv_net.h
index cf498664d989,7661a12b00f4..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -596,7 -628,47 +596,51 @@@ struct nvsp_message 
  
  #define VRSS_SEND_TAB_SIZE 16
  
++<<<<<<< HEAD
 +/* Per netvsc channel-specific */
++=======
+ #define RNDIS_MAX_PKT_DEFAULT 8
+ #define RNDIS_PKT_ALIGN_DEFAULT 8
+ 
+ struct multi_send_data {
+ 	spinlock_t lock; /* protect struct multi_send_data */
+ 	struct hv_netvsc_packet *pkt; /* netvsc pkt pending */
+ 	u32 count; /* counter of batched packets */
+ };
+ 
+ struct netvsc_stats {
+ 	u64 packets;
+ 	u64 bytes;
+ 	struct u64_stats_sync syncp;
+ };
+ 
+ struct netvsc_reconfig {
+ 	struct list_head list;
+ 	u32 event;
+ };
+ 
+ /* The context of the netvsc device  */
+ struct net_device_context {
+ 	/* point back to our device context */
+ 	struct hv_device *device_ctx;
+ 	/* reconfigure work */
+ 	struct delayed_work dwork;
+ 	/* last reconfig time */
+ 	unsigned long last_reconfig;
+ 	/* reconfig events */
+ 	struct list_head reconfig_events;
+ 	/* list protection */
+ 	spinlock_t lock;
+ 
+ 	struct work_struct work;
+ 	u32 msg_enable; /* debug level */
+ 
+ 	struct netvsc_stats __percpu *tx_stats;
+ 	struct netvsc_stats __percpu *rx_stats;
+ };
+ 
+ /* Per netvsc device */
++>>>>>>> 27a70af3f4cf (hv_netvsc: rework link status change handling)
  struct netvsc_device {
  	struct hv_device *dev;
  
diff --cc drivers/net/hyperv/netvsc_drv.c
index 56b76b7b9a27,268a05821d46..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -41,14 -40,9 +41,15 @@@
  
  #include "hyperv_net.h"
  
 +struct net_device_context {
 +	/* point back to our device context */
 +	struct hv_device *device_ctx;
 +	struct delayed_work dwork;
 +	struct work_struct work;
 +};
  
  #define RING_SIZE_MIN 64
+ #define LINKCHANGE_INT (2 * HZ)
  static int ring_size = 128;
  module_param(ring_size, int, S_IRUGO);
  MODULE_PARM_DESC(ring_size, "Ring buffer size (# of pages)");
@@@ -623,25 -647,34 +624,49 @@@ void netvsc_linkstatus_callback(struct 
  	struct net_device *net;
  	struct net_device_context *ndev_ctx;
  	struct netvsc_device *net_device;
- 	struct rndis_device *rdev;
+ 	struct netvsc_reconfig *event;
+ 	unsigned long flags;
+ 
+ 	/* Handle link change statuses only */
+ 	if (indicate->status != RNDIS_STATUS_NETWORK_CHANGE &&
+ 	    indicate->status != RNDIS_STATUS_MEDIA_CONNECT &&
+ 	    indicate->status != RNDIS_STATUS_MEDIA_DISCONNECT)
+ 		return;
  
  	net_device = hv_get_drvdata(device_obj);
++<<<<<<< HEAD
 +	rdev = net_device->extension;
 +
 +	rdev->link_state = status != 1;
 +
++=======
++>>>>>>> 27a70af3f4cf (hv_netvsc: rework link status change handling)
  	net = net_device->ndev;
  
  	if (!net || net->reg_state != NETREG_REGISTERED)
  		return;
  
  	ndev_ctx = netdev_priv(net);
++<<<<<<< HEAD
 +	if (status == 1) {
 +		schedule_delayed_work(&ndev_ctx->dwork, 0);
 +		schedule_delayed_work(&ndev_ctx->dwork, msecs_to_jiffies(20));
 +	} else {
 +		schedule_delayed_work(&ndev_ctx->dwork, 0);
 +	}
++=======
+ 
+ 	event = kzalloc(sizeof(*event), GFP_ATOMIC);
+ 	if (!event)
+ 		return;
+ 	event->event = indicate->status;
+ 
+ 	spin_lock_irqsave(&ndev_ctx->lock, flags);
+ 	list_add_tail(&event->list, &ndev_ctx->reconfig_events);
+ 	spin_unlock_irqrestore(&ndev_ctx->lock, flags);
+ 
+ 	schedule_delayed_work(&ndev_ctx->dwork, 0);
++>>>>>>> 27a70af3f4cf (hv_netvsc: rework link status change handling)
  }
  
  /*
@@@ -836,29 -1016,99 +858,106 @@@ static void netvsc_link_change(struct w
  	struct net_device *net;
  	struct netvsc_device *net_device;
  	struct rndis_device *rdev;
++<<<<<<< HEAD
 +	bool notify;
 +
 +	rtnl_lock();
++=======
+ 	struct netvsc_reconfig *event = NULL;
+ 	bool notify = false, reschedule = false;
+ 	unsigned long flags, next_reconfig, delay;
++>>>>>>> 27a70af3f4cf (hv_netvsc: rework link status change handling)
  
  	ndev_ctx = container_of(w, struct net_device_context, dwork.work);
  	net_device = hv_get_drvdata(ndev_ctx->device_ctx);
  	rdev = net_device->extension;
  	net = net_device->ndev;
  
++<<<<<<< HEAD
 +	if (rdev->link_state) {
 +		netif_carrier_off(net);
 +		notify = false;
 +	} else {
 +		netif_carrier_on(net);
 +		notify = true;
++=======
+ 	next_reconfig = ndev_ctx->last_reconfig + LINKCHANGE_INT;
+ 	if (time_is_after_jiffies(next_reconfig)) {
+ 		/* link_watch only sends one notification with current state
+ 		 * per second, avoid doing reconfig more frequently. Handle
+ 		 * wrap around.
+ 		 */
+ 		delay = next_reconfig - jiffies;
+ 		delay = delay < LINKCHANGE_INT ? delay : LINKCHANGE_INT;
+ 		schedule_delayed_work(&ndev_ctx->dwork, delay);
+ 		return;
+ 	}
+ 	ndev_ctx->last_reconfig = jiffies;
+ 
+ 	spin_lock_irqsave(&ndev_ctx->lock, flags);
+ 	if (!list_empty(&ndev_ctx->reconfig_events)) {
+ 		event = list_first_entry(&ndev_ctx->reconfig_events,
+ 					 struct netvsc_reconfig, list);
+ 		list_del(&event->list);
+ 		reschedule = !list_empty(&ndev_ctx->reconfig_events);
+ 	}
+ 	spin_unlock_irqrestore(&ndev_ctx->lock, flags);
+ 
+ 	if (!event)
+ 		return;
+ 
+ 	rtnl_lock();
+ 
+ 	switch (event->event) {
+ 		/* Only the following events are possible due to the check in
+ 		 * netvsc_linkstatus_callback()
+ 		 */
+ 	case RNDIS_STATUS_MEDIA_CONNECT:
+ 		if (rdev->link_state) {
+ 			rdev->link_state = false;
+ 			netif_carrier_on(net);
+ 			netif_tx_wake_all_queues(net);
+ 		} else {
+ 			notify = true;
+ 		}
+ 		kfree(event);
+ 		break;
+ 	case RNDIS_STATUS_MEDIA_DISCONNECT:
+ 		if (!rdev->link_state) {
+ 			rdev->link_state = true;
+ 			netif_carrier_off(net);
+ 			netif_tx_stop_all_queues(net);
+ 		}
+ 		kfree(event);
+ 		break;
+ 	case RNDIS_STATUS_NETWORK_CHANGE:
+ 		/* Only makes sense if carrier is present */
+ 		if (!rdev->link_state) {
+ 			rdev->link_state = true;
+ 			netif_carrier_off(net);
+ 			netif_tx_stop_all_queues(net);
+ 			event->event = RNDIS_STATUS_MEDIA_CONNECT;
+ 			spin_lock_irqsave(&ndev_ctx->lock, flags);
+ 			list_add_tail(&event->list, &ndev_ctx->reconfig_events);
+ 			spin_unlock_irqrestore(&ndev_ctx->lock, flags);
+ 			reschedule = true;
+ 		}
+ 		break;
++>>>>>>> 27a70af3f4cf (hv_netvsc: rework link status change handling)
  	}
  
  	rtnl_unlock();
  
  	if (notify)
  		netdev_notify_peers(net);
+ 
+ 	/* link_watch only sends one notification with current state per
+ 	 * second, handle next reconfig event in 2 seconds.
+ 	 */
+ 	if (reschedule)
+ 		schedule_delayed_work(&ndev_ctx->dwork, LINKCHANGE_INT);
  }
  
 -static void netvsc_free_netdev(struct net_device *netdev)
 -{
 -	struct net_device_context *net_device_ctx = netdev_priv(netdev);
 -
 -	free_percpu(net_device_ctx->tx_stats);
 -	free_percpu(net_device_ctx->rx_stats);
 -	free_netdev(netdev);
 -}
  
  static int netvsc_probe(struct hv_device *dev,
  			const struct hv_vmbus_device_id *dev_id)
@@@ -911,9 -1194,7 +1013,13 @@@
  	if (ret != 0) {
  		pr_err("Unable to register netdev.\n");
  		rndis_filter_device_remove(dev);
++<<<<<<< HEAD
 +		free_netdev(net);
 +	} else {
 +		schedule_delayed_work(&net_device_ctx->dwork, 0);
++=======
+ 		netvsc_free_netdev(net);
++>>>>>>> 27a70af3f4cf (hv_netvsc: rework link status change handling)
  	}
  
  	return ret;
* Unmerged path drivers/net/hyperv/hyperv_net.h
* Unmerged path drivers/net/hyperv/netvsc_drv.c
