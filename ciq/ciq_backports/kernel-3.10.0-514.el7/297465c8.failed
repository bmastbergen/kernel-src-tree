nvme: add NVME_SC_CANCELLED

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 297465c873ae8c99180617ca904dc1a4a738f25d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/297465c8.failed

To properly document how we are using a negative Linux error value to
communicate request cancellations inside the driver.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Acked-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 297465c873ae8c99180617ca904dc1a4a738f25d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
#	drivers/nvme/host/nvme.h
diff --cc drivers/block/nvme-core.c
index 2a6eb55ad96c,e683bd1a05e6..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -530,30 -618,33 +530,48 @@@ static void req_completion(struct nvme_
  			spin_unlock_irqrestore(req->q->queue_lock, flags);
  			return;
  		}
++<<<<<<< HEAD:drivers/block/nvme-core.c
 +		req->errors = nvme_error_status(status);
 +	} else
 +		req->errors = 0;
++=======
+ 
+ 		if (req->cmd_type == REQ_TYPE_DRV_PRIV) {
+ 			if (cmd_rq->ctx == CMD_CTX_CANCELLED)
+ 				error = NVME_SC_CANCELLED;
+ 			else
+ 				error = status;
+ 		} else {
+ 			error = nvme_error_status(status);
+ 		}
+ 	}
+ 
+ 	if (req->cmd_type == REQ_TYPE_DRV_PRIV) {
+ 		u32 result = le32_to_cpup(&cqe->result);
+ 		req->special = (void *)(uintptr_t)result;
+ 	}
++>>>>>>> 297465c873ae (nvme: add NVME_SC_CANCELLED):drivers/nvme/host/pci.c
  
  	if (cmd_rq->aborted)
 -		dev_warn(nvmeq->dev->dev,
 +		dev_warn(&nvmeq->dev->pci_dev->dev,
  			"completing aborted command with status:%04x\n",
 -			error);
 +			status);
  
 -	nvme_unmap_data(nvmeq->dev, iod);
 -	blk_mq_complete_request(req, error);
 +	if (iod->nents) {
 +		dma_unmap_sg(&nvmeq->dev->pci_dev->dev, iod->sg, iod->nents,
 +			rq_data_dir(req) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 +		if (blk_integrity_rq(req))
 +			dma_unmap_sg(&nvmeq->dev->pci_dev->dev, iod->meta_sg, 1,
 +				rq_data_dir(req) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 +	}
 +	nvme_free_iod(nvmeq->dev, iod);
 +
 +	blk_mq_complete_request(req);
  }
  
 -static bool nvme_setup_prps(struct nvme_dev *dev, struct nvme_iod *iod,
 -		int total_len)
 +/* length is in bytes.  gfp flags indicates whether we may sleep. */
 +int nvme_setup_prps(struct nvme_dev *dev, struct nvme_iod *iod, int total_len,
 +								gfp_t gfp)
  {
  	struct dma_pool *pool;
  	int length = total_len;
* Unmerged path drivers/nvme/host/nvme.h
* Unmerged path drivers/block/nvme-core.c
* Unmerged path drivers/nvme/host/nvme.h
