i40e/ethtool: support coalesce getting by queue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Kan Liang <kan.liang@intel.com>
commit be280bad15fafc0f7e7b90bdbd99170366f5e9bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/be280bad.failed

This patch implements get_per_queue_coalesce for i40e driver.

	Signed-off-by: Kan Liang <kan.liang@intel.com>
	Acked-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit be280bad15fafc0f7e7b90bdbd99170366f5e9bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_ethtool.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index d917fccb5422,dd572abddb8e..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@@ -1812,14 -1889,142 +1812,138 @@@ static int i40e_get_coalesce(struct net
  	ec->tx_max_coalesced_frames_irq = vsi->work_limit;
  	ec->rx_max_coalesced_frames_irq = vsi->work_limit;
  
 -	/* rx and tx usecs has per queue value. If user doesn't specify the queue,
 -	 * return queue 0's value to represent.
 -	 */
 -	if (queue < 0) {
 -		queue = 0;
 -	} else if (queue >= vsi->num_queue_pairs) {
 -		return -EINVAL;
 -	}
 -
 -	if (ITR_IS_DYNAMIC(vsi->rx_rings[queue]->rx_itr_setting))
 +	if (ITR_IS_DYNAMIC(vsi->rx_itr_setting))
  		ec->use_adaptive_rx_coalesce = 1;
  
 -	if (ITR_IS_DYNAMIC(vsi->tx_rings[queue]->tx_itr_setting))
 +	if (ITR_IS_DYNAMIC(vsi->tx_itr_setting))
  		ec->use_adaptive_tx_coalesce = 1;
  
++<<<<<<< HEAD
 +	ec->rx_coalesce_usecs = vsi->rx_itr_setting & ~I40E_ITR_DYNAMIC;
 +	ec->tx_coalesce_usecs = vsi->tx_itr_setting & ~I40E_ITR_DYNAMIC;
++=======
+ 	ec->rx_coalesce_usecs = vsi->rx_rings[queue]->rx_itr_setting & ~I40E_ITR_DYNAMIC;
+ 	ec->tx_coalesce_usecs = vsi->tx_rings[queue]->tx_itr_setting & ~I40E_ITR_DYNAMIC;
+ 
+ 	/* we use the _usecs_high to store/set the interrupt rate limit
+ 	 * that the hardware supports, that almost but not quite
+ 	 * fits the original intent of the ethtool variable,
+ 	 * the rx_coalesce_usecs_high limits total interrupts
+ 	 * per second from both tx/rx sources.
+ 	 */
+ 	ec->rx_coalesce_usecs_high = vsi->int_rate_limit;
+ 	ec->tx_coalesce_usecs_high = vsi->int_rate_limit;
+ 
+ 	return 0;
+ }
+ 
+ static int i40e_get_coalesce(struct net_device *netdev,
+ 			     struct ethtool_coalesce *ec)
+ {
+ 	return __i40e_get_coalesce(netdev, ec, -1);
+ }
+ 
+ static int i40e_get_per_queue_coalesce(struct net_device *netdev, u32 queue,
+ 				       struct ethtool_coalesce *ec)
+ {
+ 	return __i40e_get_coalesce(netdev, ec, queue);
+ }
+ 
+ static void i40e_set_itr_per_queue(struct i40e_vsi *vsi,
+ 				   struct ethtool_coalesce *ec,
+ 				   int queue)
+ {
+ 	struct i40e_pf *pf = vsi->back;
+ 	struct i40e_hw *hw = &pf->hw;
+ 	struct i40e_q_vector *q_vector;
+ 	u16 vector, intrl;
+ 
+ 	intrl = INTRL_USEC_TO_REG(vsi->int_rate_limit);
+ 
+ 	vsi->rx_rings[queue]->rx_itr_setting = ec->rx_coalesce_usecs;
+ 	vsi->tx_rings[queue]->tx_itr_setting = ec->tx_coalesce_usecs;
+ 
+ 	if (ec->use_adaptive_rx_coalesce)
+ 		vsi->rx_rings[queue]->rx_itr_setting |= I40E_ITR_DYNAMIC;
+ 	else
+ 		vsi->rx_rings[queue]->rx_itr_setting &= ~I40E_ITR_DYNAMIC;
+ 
+ 	if (ec->use_adaptive_tx_coalesce)
+ 		vsi->tx_rings[queue]->tx_itr_setting |= I40E_ITR_DYNAMIC;
+ 	else
+ 		vsi->tx_rings[queue]->tx_itr_setting &= ~I40E_ITR_DYNAMIC;
+ 
+ 	q_vector = vsi->rx_rings[queue]->q_vector;
+ 	q_vector->rx.itr = ITR_TO_REG(vsi->rx_rings[queue]->rx_itr_setting);
+ 	vector = vsi->base_vector + q_vector->v_idx;
+ 	wr32(hw, I40E_PFINT_ITRN(I40E_RX_ITR, vector - 1), q_vector->rx.itr);
+ 
+ 	q_vector = vsi->tx_rings[queue]->q_vector;
+ 	q_vector->tx.itr = ITR_TO_REG(vsi->tx_rings[queue]->tx_itr_setting);
+ 	vector = vsi->base_vector + q_vector->v_idx;
+ 	wr32(hw, I40E_PFINT_ITRN(I40E_TX_ITR, vector - 1), q_vector->tx.itr);
+ 
+ 	wr32(hw, I40E_PFINT_RATEN(vector - 1), intrl);
+ 	i40e_flush(hw);
+ }
+ 
+ static int __i40e_set_coalesce(struct net_device *netdev,
+ 			       struct ethtool_coalesce *ec,
+ 			       int queue)
+ {
+ 	struct i40e_netdev_priv *np = netdev_priv(netdev);
+ 	struct i40e_vsi *vsi = np->vsi;
+ 	struct i40e_pf *pf = vsi->back;
+ 	int i;
+ 
+ 	if (ec->tx_max_coalesced_frames_irq || ec->rx_max_coalesced_frames_irq)
+ 		vsi->work_limit = ec->tx_max_coalesced_frames_irq;
+ 
+ 	/* tx_coalesce_usecs_high is ignored, use rx-usecs-high instead */
+ 	if (ec->tx_coalesce_usecs_high != vsi->int_rate_limit) {
+ 		netif_info(pf, drv, netdev, "tx-usecs-high is not used, please program rx-usecs-high\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (ec->rx_coalesce_usecs_high >= INTRL_REG_TO_USEC(I40E_MAX_INTRL)) {
+ 		netif_info(pf, drv, netdev, "Invalid value, rx-usecs-high range is 0-235\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (ec->rx_coalesce_usecs == 0) {
+ 		if (ec->use_adaptive_rx_coalesce)
+ 			netif_info(pf, drv, netdev, "rx-usecs=0, need to disable adaptive-rx for a complete disable\n");
+ 	} else if ((ec->rx_coalesce_usecs < (I40E_MIN_ITR << 1)) ||
+ 		   (ec->rx_coalesce_usecs > (I40E_MAX_ITR << 1))) {
+ 			netif_info(pf, drv, netdev, "Invalid value, rx-usecs range is 0-8160\n");
+ 			return -EINVAL;
+ 	}
+ 
+ 	vsi->int_rate_limit = ec->rx_coalesce_usecs_high;
+ 
+ 	if (ec->tx_coalesce_usecs == 0) {
+ 		if (ec->use_adaptive_tx_coalesce)
+ 			netif_info(pf, drv, netdev, "tx-usecs=0, need to disable adaptive-tx for a complete disable\n");
+ 	} else if ((ec->tx_coalesce_usecs < (I40E_MIN_ITR << 1)) ||
+ 		   (ec->tx_coalesce_usecs > (I40E_MAX_ITR << 1))) {
+ 			netif_info(pf, drv, netdev, "Invalid value, tx-usecs range is 0-8160\n");
+ 			return -EINVAL;
+ 	}
+ 
+ 	/* rx and tx usecs has per queue value. If user doesn't specify the queue,
+ 	 * apply to all queues.
+ 	 */
+ 	if (queue < 0) {
+ 		for (i = 0; i < vsi->num_queue_pairs; i++)
+ 			i40e_set_itr_per_queue(vsi, ec, i);
+ 	} else if (queue < vsi->num_queue_pairs) {
+ 		i40e_set_itr_per_queue(vsi, ec, queue);
+ 	} else {
+ 		netif_info(pf, drv, netdev, "Invalid queue value, queue range is 0 - %d\n",
+ 			   vsi->num_queue_pairs - 1);
+ 		return -EINVAL;
+ 	}
++>>>>>>> be280bad15fa (i40e/ethtool: support coalesce getting by queue)
  
  	return 0;
  }
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_ethtool.c
