mei: add mei_cl_alloc_linked function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 03b8d3419fdfc02d1984a0db51c8b74426e12605
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/03b8d341.failed

Add convenient wrapper mei_cl_alloc_linked
to simplify error handling

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 03b8d3419fdfc02d1984a0db51c8b74426e12605)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/nfc.c
diff --cc drivers/misc/mei/nfc.c
index 2b65e8021f0d,c3bcb63686d7..000000000000
--- a/drivers/misc/mei/nfc.c
+++ b/drivers/misc/mei/nfc.c
@@@ -478,21 -481,21 +478,33 @@@ err
  
  int mei_nfc_host_init(struct mei_device *dev)
  {
++<<<<<<< HEAD
 +	struct mei_nfc_dev *ndev = &nfc_dev;
 +	struct mei_cl *cl_info, *cl = NULL;
 +	int i, ret;
++=======
+ 	struct mei_nfc_dev *ndev;
+ 	struct mei_cl *cl_info, *cl;
+ 	struct mei_me_client *me_cl = NULL;
+ 	int ret;
++>>>>>>> 03b8d3419fdf (mei: add mei_cl_alloc_linked function)
  
 -
 -	/* in case of internal reset bail out
 -	 * as the device is already setup
 -	 */
 -	cl = mei_cl_bus_find_cl_by_uuid(dev, mei_nfc_guid);
 -	if (cl)
 +	/* already initialized */
 +	if (ndev->cl_info)
  		return 0;
  
++<<<<<<< HEAD
 +	ndev->cl_info = mei_cl_allocate(dev);
 +	ndev->cl = mei_cl_allocate(dev);
 +
 +	cl = ndev->cl;
 +	cl_info = ndev->cl_info;
 +
 +	if (!cl || !cl_info) {
++=======
+ 	ndev = kzalloc(sizeof(struct mei_nfc_dev), GFP_KERNEL);
+ 	if (!ndev) {
++>>>>>>> 03b8d3419fdf (mei: add mei_cl_alloc_linked function)
  		ret = -ENOMEM;
  		goto err;
  	}
@@@ -505,32 -508,39 +517,60 @@@
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	cl_info->me_client_id = dev->me_clients[i].client_id;
 +
 +	ret = mei_cl_link(cl_info, MEI_HOST_CLIENT_ID_ANY);
 +	if (ret)
 +		goto err;
 +
 +	cl_info->device_uuid = mei_nfc_info_guid;
++=======
+ 	cl_info = mei_cl_alloc_linked(dev, MEI_HOST_CLIENT_ID_ANY);
+ 	if (IS_ERR(cl_info)) {
+ 		ret = PTR_ERR(cl_info);
+ 		goto err;
+ 	}
+ 
+ 	cl_info->me_client_id = me_cl->client_id;
+ 	cl_info->cl_uuid = me_cl->props.protocol_name;
+ 	mei_me_cl_put(me_cl);
+ 	me_cl = NULL;
++>>>>>>> 03b8d3419fdf (mei: add mei_cl_alloc_linked function)
  
  	list_add_tail(&cl_info->device_link, &dev->device_list);
  
+ 	ndev->cl_info = cl_info;
+ 
  	/* check for valid client id */
 -	me_cl = mei_me_cl_by_uuid(dev, &mei_nfc_guid);
 -	if (!me_cl) {
 -		dev_info(dev->dev, "nfc: failed to find the client\n");
 +	i = mei_me_cl_by_uuid(dev, &mei_nfc_guid);
 +	if (i < 0) {
 +		dev_info(&dev->pdev->dev, "nfc: failed to find the client\n");
  		ret = -ENOTTY;
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	cl->me_client_id = dev->me_clients[i].client_id;
 +
 +	ret = mei_cl_link(cl, MEI_HOST_CLIENT_ID_ANY);
 +	if (ret)
 +		goto err;
++=======
+ 	cl = mei_cl_alloc_linked(dev, MEI_HOST_CLIENT_ID_ANY);
+ 	if (IS_ERR(cl)) {
+ 		ret = PTR_ERR(cl);
+ 		goto err;
+ 	}
+ 
+ 	cl->me_client_id = me_cl->client_id;
+ 	cl->cl_uuid = me_cl->props.protocol_name;
+ 	mei_me_cl_put(me_cl);
+ 	me_cl = NULL;
++>>>>>>> 03b8d3419fdf (mei: add mei_cl_alloc_linked function)
 +
 +	cl->device_uuid = mei_nfc_guid;
 +
  
  	list_add_tail(&cl->device_link, &dev->device_list);
  
diff --git a/drivers/misc/mei/client.c b/drivers/misc/mei/client.c
index 3c539de435ba..7c73aff7e4dc 100644
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@ -310,11 +310,11 @@ struct mei_cl_cb *mei_cl_find_read_cb(struct mei_cl *cl)
  * mei_cl_link - allocate host id in the host map
  *
  * @cl: host client
- * @id: fixed host id or -1 for generic one
+ * @id: fixed host id or MEI_HOST_CLIENT_ID_ANY (-1) for generic one
  *
  * returns 0 on success
  *	-EINVAL on incorrect values
- *	-ENONET if client not found
+ *	-EMFILE if open count exceeded.
  */
 int mei_cl_link(struct mei_cl *cl, int id)
 {
@@ -635,6 +635,37 @@ out:
 	return rets;
 }
 
+/**
+ * mei_cl_alloc_linked - allocate and link host client
+ *
+ * @dev: the device structure
+ * @id: fixed host id or MEI_HOST_CLIENT_ID_ANY (-1) for generic one
+ *
+ * Return: cl on success ERR_PTR on failure
+ */
+struct mei_cl *mei_cl_alloc_linked(struct mei_device *dev, int id)
+{
+	struct mei_cl *cl;
+	int ret;
+
+	cl = mei_cl_allocate(dev);
+	if (!cl) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	ret = mei_cl_link(cl, id);
+	if (ret)
+		goto err;
+
+	return cl;
+err:
+	kfree(cl);
+	return ERR_PTR(ret);
+}
+
+
+
 /**
  * mei_cl_flow_ctrl_creds - checks flow_control credits for cl.
  *
diff --git a/drivers/misc/mei/client.h b/drivers/misc/mei/client.h
index bf2b0b1b493d..9d228fc89aef 100644
--- a/drivers/misc/mei/client.h
+++ b/drivers/misc/mei/client.h
@@ -58,6 +58,8 @@ void mei_cl_init(struct mei_cl *cl, struct mei_device *dev);
 int mei_cl_link(struct mei_cl *cl, int id);
 int mei_cl_unlink(struct mei_cl *cl);
 
+struct mei_cl *mei_cl_alloc_linked(struct mei_device *dev, int id);
+
 int mei_cl_flush_queues(struct mei_cl *cl);
 struct mei_cl_cb *mei_cl_find_read_cb(struct mei_cl *cl);
 
diff --git a/drivers/misc/mei/main.c b/drivers/misc/mei/main.c
index b23f9eba9e3a..daf08fd2d443 100644
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@ -67,24 +67,18 @@ static int mei_open(struct inode *inode, struct file *file)
 
 	mutex_lock(&dev->device_lock);
 
-	cl = NULL;
-
-	err = -ENODEV;
 	if (dev->dev_state != MEI_DEV_ENABLED) {
 		dev_dbg(&dev->pdev->dev, "dev_state != MEI_ENABLED  dev_state = %s\n",
 		    mei_dev_state_str(dev->dev_state));
+		err = -ENODEV;
 		goto err_unlock;
 	}
 
-	err = -ENOMEM;
-	cl = mei_cl_allocate(dev);
-	if (!cl)
-		goto err_unlock;
-
-	/* open_handle_count check is handled in the mei_cl_link */
-	err = mei_cl_link(cl, MEI_HOST_CLIENT_ID_ANY);
-	if (err)
+	cl = mei_cl_alloc_linked(dev, MEI_HOST_CLIENT_ID_ANY);
+	if (IS_ERR(cl)) {
+		err = PTR_ERR(cl);
 		goto err_unlock;
+	}
 
 	file->private_data = cl;
 
@@ -94,7 +88,6 @@ static int mei_open(struct inode *inode, struct file *file)
 
 err_unlock:
 	mutex_unlock(&dev->device_lock);
-	kfree(cl);
 	return err;
 }
 
* Unmerged path drivers/misc/mei/nfc.c
