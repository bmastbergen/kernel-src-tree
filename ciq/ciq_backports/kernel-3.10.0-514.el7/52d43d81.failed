s390/pci_dma: improve debugging of errors during dma map

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [s390] pci_dma: improve debugging of errors during dma map (Hendrik Brueckner) [1330100]
Rebuild_FUZZ: 95.33%
commit-author Sebastian Ott <sebott@linux.vnet.ibm.com>
commit 52d43d8184b1840c7cf6136724223585f51a1074
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/52d43d81.failed

Improve debugging to find out what went wrong during a failed
dma map/unmap operation.

	Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
	Reviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 52d43d8184b1840c7cf6136724223585f51a1074)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci_dma.c
diff --cc arch/s390/pci/pci_dma.c
index 66b7fc6591c4,d348f2c09a1e..000000000000
--- a/arch/s390/pci/pci_dma.c
+++ b/arch/s390/pci/pci_dma.c
@@@ -261,15 -269,15 +261,27 @@@ out
  	spin_unlock_irqrestore(&zdev->iommu_bitmap_lock, flags);
  }
  
++<<<<<<< HEAD
 +int dma_set_mask(struct device *dev, u64 mask)
 +{
 +	if (!dev->dma_mask || !dma_supported(dev, mask))
 +		return -EIO;
 +
 +	*dev->dma_mask = mask;
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(dma_set_mask);
++=======
+ static inline void zpci_err_dma(unsigned long rc, unsigned long addr)
+ {
+ 	struct {
+ 		unsigned long rc;
+ 		unsigned long addr;
+ 	} __packed data = {rc, addr};
+ 
+ 	zpci_err_hex(&data, sizeof(data));
+ }
++>>>>>>> 52d43d8184b1 (s390/pci_dma: improve debugging of errors during dma map)
  
  static dma_addr_t s390_dma_map_pages(struct device *dev, struct page *page,
  				     unsigned long offset, size_t size,
@@@ -298,10 -311,12 +315,19 @@@
  	if (direction == DMA_NONE || direction == DMA_TO_DEVICE)
  		flags |= ZPCI_TABLE_PROTECTED;
  
++<<<<<<< HEAD
 +	if (!dma_update_trans(zdev, pa, dma_addr, size, flags)) {
 +		atomic64_add(nr_pages, &zdev->fmb->mapped_pages);
 +		return dma_addr + (offset & ~PAGE_MASK);
 +	}
++=======
+ 	ret = dma_update_trans(zdev, pa, dma_addr, size, flags);
+ 	if (ret)
+ 		goto out_free;
+ 
+ 	atomic64_add(nr_pages, &zdev->mapped_pages);
+ 	return dma_addr + (offset & ~PAGE_MASK);
++>>>>>>> 52d43d8184b1 (s390/pci_dma: improve debugging of errors during dma map)
  
  out_free:
  	dma_free_iommu(zdev, iommu_page_index, nr_pages);
@@@ -315,19 -330,21 +341,21 @@@ static void s390_dma_unmap_pages(struc
  				 size_t size, enum dma_data_direction direction,
  				 struct dma_attrs *attrs)
  {
 -	struct zpci_dev *zdev = to_zpci(to_pci_dev(dev));
 +	struct zpci_dev *zdev = get_zdev(to_pci_dev(dev));
  	unsigned long iommu_page_index;
- 	int npages;
+ 	int npages, ret;
  
  	npages = iommu_num_pages(dma_addr, size, PAGE_SIZE);
  	dma_addr = dma_addr & PAGE_MASK;
- 	if (dma_update_trans(zdev, 0, dma_addr, npages * PAGE_SIZE,
- 			     ZPCI_PTE_INVALID)) {
+ 	ret = dma_update_trans(zdev, 0, dma_addr, npages * PAGE_SIZE,
+ 			       ZPCI_PTE_INVALID);
+ 	if (ret) {
  		zpci_err("unmap error:\n");
- 		zpci_err_hex(&dma_addr, sizeof(dma_addr));
+ 		zpci_err_dma(ret, dma_addr);
+ 		return;
  	}
  
 -	atomic64_add(npages, &zdev->unmapped_pages);
 +	atomic64_add(npages, &zdev->fmb->unmapped_pages);
  	iommu_page_index = (dma_addr - zdev->start_dma) >> PAGE_SHIFT;
  	dma_free_iommu(zdev, iommu_page_index, npages);
  }
* Unmerged path arch/s390/pci/pci_dma.c
