perf stat: Cache aggregated map entries in extra cpumap

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 1e5a29318ba8506f52a8d727b5c6a53143f9882a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/1e5a2931.failed

Currently any time we need to access socket or core id for given cpu, we
access the sysfs topology file.

Adding a cpus_aggr_map cpu_map to cache those entries.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Kan Liang <kan.liang@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1445784728-21732-3-git-send-email-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 1e5a29318ba8506f52a8d727b5c6a53143f9882a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-stat.c
diff --cc tools/perf/builtin-stat.c
index abeb15aebd12,2f438f76cceb..000000000000
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@@ -944,22 -946,73 +946,84 @@@ static int stat__set_big_num(const stru
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int perf_stat__get_socket(struct cpu_map *map, int cpu)
+ {
+ 	return cpu_map__get_socket(map, cpu, NULL);
+ }
+ 
+ static int perf_stat__get_core(struct cpu_map *map, int cpu)
+ {
+ 	return cpu_map__get_core(map, cpu, NULL);
+ }
+ 
+ static int cpu_map__get_max(struct cpu_map *map)
+ {
+ 	int i, max = -1;
+ 
+ 	for (i = 0; i < map->nr; i++) {
+ 		if (map->map[i] > max)
+ 			max = map->map[i];
+ 	}
+ 
+ 	return max;
+ }
+ 
+ static struct cpu_map *cpus_aggr_map;
+ 
+ static int perf_stat__get_aggr(aggr_get_id_t get_id, struct cpu_map *map, int idx)
+ {
+ 	int cpu;
+ 
+ 	if (idx >= map->nr)
+ 		return -1;
+ 
+ 	cpu = map->map[idx];
+ 
+ 	if (cpus_aggr_map->map[cpu] == -1)
+ 		cpus_aggr_map->map[cpu] = get_id(map, idx);
+ 
+ 	return cpus_aggr_map->map[cpu];
+ }
+ 
+ static int perf_stat__get_socket_cached(struct cpu_map *map, int idx)
+ {
+ 	return perf_stat__get_aggr(perf_stat__get_socket, map, idx);
+ }
+ 
+ static int perf_stat__get_core_cached(struct cpu_map *map, int idx)
+ {
+ 	return perf_stat__get_aggr(perf_stat__get_core, map, idx);
+ }
+ 
++>>>>>>> 1e5a29318ba8 (perf stat: Cache aggregated map entries in extra cpumap)
  static int perf_stat_init_aggr_mode(void)
  {
+ 	int nr;
+ 
  	switch (stat_config.aggr_mode) {
  	case AGGR_SOCKET:
  		if (cpu_map__build_socket_map(evsel_list->cpus, &aggr_map)) {
  			perror("cannot build socket map");
  			return -1;
  		}
++<<<<<<< HEAD
 +		aggr_get_id = cpu_map__get_socket;
++=======
+ 		aggr_get_id = perf_stat__get_socket_cached;
++>>>>>>> 1e5a29318ba8 (perf stat: Cache aggregated map entries in extra cpumap)
  		break;
  	case AGGR_CORE:
  		if (cpu_map__build_core_map(evsel_list->cpus, &aggr_map)) {
  			perror("cannot build core map");
  			return -1;
  		}
++<<<<<<< HEAD
 +		aggr_get_id = cpu_map__get_core;
++=======
+ 		aggr_get_id = perf_stat__get_core_cached;
++>>>>>>> 1e5a29318ba8 (perf stat: Cache aggregated map entries in extra cpumap)
  		break;
  	case AGGR_NONE:
  	case AGGR_GLOBAL:
* Unmerged path tools/perf/builtin-stat.c
