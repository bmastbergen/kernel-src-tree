HID: sony: do not rely on hid_output_raw_report

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
Rebuild_CHGLOG: - [hid] sony: do not rely on hid_output_raw_report (Benjamin Tissoires) [1311883]
Rebuild_FUZZ: 94.38%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit e534a9352237e84263cecedff283387b144b3ed8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/e534a935.failed

hid_out_raw_report is going to be obsoleted as it is not part of the
unified HID low level transport documentation
(Documentation/hid/hid-transport.txt)

To do so, we need to introduce two new quirks:
* HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP: this quirks prevents the
  transport driver to use the interrupt channel to send output report
  (and thus force to use HID_REQ_SET_REPORT command)
* HID_QUIRK_SKIP_OUTPUT_REPORT_ID: this one forces usbhid to not
  include the report ID in the buffer it sends to the device through
  HID_REQ_SET_REPORT in case of an output report

This also fixes a regression introduced in commit 3a75b24949a8
(HID: hidraw: replace hid_output_raw_report() calls by appropriates ones).
The hidraw API was not able to communicate with the PS3 SixAxis
controllers in USB mode.

	Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Tested-by: Antonio Ospite <ao2@ao2.it>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit e534a9352237e84263cecedff283387b144b3ed8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/hid-sony.c
#	drivers/hid/hidraw.c
diff --cc drivers/hid/hid-sony.c
index 312098e4af4f,4884bb567bf8..000000000000
--- a/drivers/hid/hid-sony.c
+++ b/drivers/hid/hid-sony.c
@@@ -19,7 -29,11 +19,15 @@@
  #include <linux/hid.h>
  #include <linux/module.h>
  #include <linux/slab.h>
++<<<<<<< HEAD
 +#include <linux/usb.h>
++=======
+ #include <linux/leds.h>
+ #include <linux/power_supply.h>
+ #include <linux/spinlock.h>
+ #include <linux/list.h>
+ #include <linux/input/mt.h>
++>>>>>>> e534a9352237 (HID: sony: do not rely on hid_output_raw_report)
  
  #include "hid-ids.h"
  
@@@ -189,9 -1032,553 +158,555 @@@ static int sixaxis_set_operational_usb(
  static int sixaxis_set_operational_bt(struct hid_device *hdev)
  {
  	unsigned char buf[] = { 0xf4,  0x42, 0x03, 0x00, 0x00 };
 -	return hid_hw_raw_request(hdev, buf[0], buf, sizeof(buf),
 -				  HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
 +	return hdev->hid_output_raw_report(hdev, buf, sizeof(buf), HID_FEATURE_REPORT);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Requesting feature report 0x02 in Bluetooth mode changes the state of the
+  * controller so that it sends full input reports of type 0x11.
+  */
+ static int dualshock4_set_operational_bt(struct hid_device *hdev)
+ {
+ 	__u8 buf[37] = { 0 };
+ 
+ 	return hid_hw_raw_request(hdev, 0x02, buf, sizeof(buf),
+ 				HID_FEATURE_REPORT, HID_REQ_GET_REPORT);
+ }
+ 
+ static void buzz_set_leds(struct hid_device *hdev, const __u8 *leds)
+ {
+ 	struct list_head *report_list =
+ 		&hdev->report_enum[HID_OUTPUT_REPORT].report_list;
+ 	struct hid_report *report = list_entry(report_list->next,
+ 		struct hid_report, list);
+ 	__s32 *value = report->field[0]->value;
+ 
+ 	value[0] = 0x00;
+ 	value[1] = leds[0] ? 0xff : 0x00;
+ 	value[2] = leds[1] ? 0xff : 0x00;
+ 	value[3] = leds[2] ? 0xff : 0x00;
+ 	value[4] = leds[3] ? 0xff : 0x00;
+ 	value[5] = 0x00;
+ 	value[6] = 0x00;
+ 	hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
+ }
+ 
+ static void sony_set_leds(struct hid_device *hdev, const __u8 *leds, int count)
+ {
+ 	struct sony_sc *drv_data = hid_get_drvdata(hdev);
+ 	int n;
+ 
+ 	BUG_ON(count > MAX_LEDS);
+ 
+ 	if (drv_data->quirks & BUZZ_CONTROLLER && count == 4) {
+ 		buzz_set_leds(hdev, leds);
+ 	} else {
+ 		for (n = 0; n < count; n++)
+ 			drv_data->led_state[n] = leds[n];
+ 		schedule_work(&drv_data->state_worker);
+ 	}
+ }
+ 
+ static void sony_led_set_brightness(struct led_classdev *led,
+ 				    enum led_brightness value)
+ {
+ 	struct device *dev = led->dev->parent;
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct sony_sc *drv_data;
+ 
+ 	int n;
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	if (!drv_data) {
+ 		hid_err(hdev, "No device data\n");
+ 		return;
+ 	}
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		if (led == drv_data->leds[n]) {
+ 			if (value != drv_data->led_state[n]) {
+ 				drv_data->led_state[n] = value;
+ 				sony_set_leds(hdev, drv_data->led_state, drv_data->led_count);
+ 			}
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ static enum led_brightness sony_led_get_brightness(struct led_classdev *led)
+ {
+ 	struct device *dev = led->dev->parent;
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct sony_sc *drv_data;
+ 
+ 	int n;
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	if (!drv_data) {
+ 		hid_err(hdev, "No device data\n");
+ 		return LED_OFF;
+ 	}
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		if (led == drv_data->leds[n])
+ 			return drv_data->led_state[n];
+ 	}
+ 
+ 	return LED_OFF;
+ }
+ 
+ static void sony_leds_remove(struct hid_device *hdev)
+ {
+ 	struct sony_sc *drv_data;
+ 	struct led_classdev *led;
+ 	int n;
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	BUG_ON(!(drv_data->quirks & SONY_LED_SUPPORT));
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		led = drv_data->leds[n];
+ 		drv_data->leds[n] = NULL;
+ 		if (!led)
+ 			continue;
+ 		led_classdev_unregister(led);
+ 		kfree(led);
+ 	}
+ 
+ 	drv_data->led_count = 0;
+ }
+ 
+ static int sony_leds_init(struct hid_device *hdev)
+ {
+ 	struct sony_sc *drv_data;
+ 	int n, ret = 0;
+ 	int max_brightness;
+ 	int use_colors;
+ 	struct led_classdev *led;
+ 	size_t name_sz;
+ 	char *name;
+ 	size_t name_len;
+ 	const char *name_fmt;
+ 	static const char * const color_str[] = { "red", "green", "blue" };
+ 	static const __u8 initial_values[MAX_LEDS] = { 0x00, 0x00, 0x00, 0x00 };
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	BUG_ON(!(drv_data->quirks & SONY_LED_SUPPORT));
+ 
+ 	if (drv_data->quirks & BUZZ_CONTROLLER) {
+ 		drv_data->led_count = 4;
+ 		max_brightness = 1;
+ 		use_colors = 0;
+ 		name_len = strlen("::buzz#");
+ 		name_fmt = "%s::buzz%d";
+ 		/* Validate expected report characteristics. */
+ 		if (!hid_validate_values(hdev, HID_OUTPUT_REPORT, 0, 0, 7))
+ 			return -ENODEV;
+ 	} else if (drv_data->quirks & DUALSHOCK4_CONTROLLER) {
+ 		drv_data->led_count = 3;
+ 		max_brightness = 255;
+ 		use_colors = 1;
+ 		name_len = 0;
+ 		name_fmt = "%s:%s";
+ 	} else {
+ 		drv_data->led_count = 4;
+ 		max_brightness = 1;
+ 		use_colors = 0;
+ 		name_len = strlen("::sony#");
+ 		name_fmt = "%s::sony%d";
+ 	}
+ 
+ 	/*
+ 	 * Clear LEDs as we have no way of reading their initial state. This is
+ 	 * only relevant if the driver is loaded after somebody actively set the
+ 	 * LEDs to on
+ 	 */
+ 	sony_set_leds(hdev, initial_values, drv_data->led_count);
+ 
+ 	name_sz = strlen(dev_name(&hdev->dev)) + name_len + 1;
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 
+ 		if (use_colors)
+ 			name_sz = strlen(dev_name(&hdev->dev)) + strlen(color_str[n]) + 2;
+ 
+ 		led = kzalloc(sizeof(struct led_classdev) + name_sz, GFP_KERNEL);
+ 		if (!led) {
+ 			hid_err(hdev, "Couldn't allocate memory for LED %d\n", n);
+ 			ret = -ENOMEM;
+ 			goto error_leds;
+ 		}
+ 
+ 		name = (void *)(&led[1]);
+ 		if (use_colors)
+ 			snprintf(name, name_sz, name_fmt, dev_name(&hdev->dev), color_str[n]);
+ 		else
+ 			snprintf(name, name_sz, name_fmt, dev_name(&hdev->dev), n + 1);
+ 		led->name = name;
+ 		led->brightness = 0;
+ 		led->max_brightness = max_brightness;
+ 		led->brightness_get = sony_led_get_brightness;
+ 		led->brightness_set = sony_led_set_brightness;
+ 
+ 		ret = led_classdev_register(&hdev->dev, led);
+ 		if (ret) {
+ 			hid_err(hdev, "Failed to register LED %d\n", n);
+ 			kfree(led);
+ 			goto error_leds;
+ 		}
+ 
+ 		drv_data->leds[n] = led;
+ 	}
+ 
+ 	return ret;
+ 
+ error_leds:
+ 	sony_leds_remove(hdev);
+ 
+ 	return ret;
+ }
+ 
+ static void sixaxis_state_worker(struct work_struct *work)
+ {
+ 	struct sony_sc *sc = container_of(work, struct sony_sc, state_worker);
+ 	unsigned char buf[] = {
+ 		0x01,
+ 		0x00, 0xff, 0x00, 0xff, 0x00,
+ 		0x00, 0x00, 0x00, 0x00, 0x00,
+ 		0xff, 0x27, 0x10, 0x00, 0x32,
+ 		0xff, 0x27, 0x10, 0x00, 0x32,
+ 		0xff, 0x27, 0x10, 0x00, 0x32,
+ 		0xff, 0x27, 0x10, 0x00, 0x32,
+ 		0x00, 0x00, 0x00, 0x00, 0x00
+ 	};
+ 
+ #ifdef CONFIG_SONY_FF
+ 	buf[3] = sc->right ? 1 : 0;
+ 	buf[5] = sc->left;
+ #endif
+ 
+ 	buf[10] |= sc->led_state[0] << 1;
+ 	buf[10] |= sc->led_state[1] << 2;
+ 	buf[10] |= sc->led_state[2] << 3;
+ 	buf[10] |= sc->led_state[3] << 4;
+ 
+ 	hid_hw_raw_request(sc->hdev, 0x01, buf, sizeof(buf), HID_OUTPUT_REPORT,
+ 			HID_REQ_SET_REPORT);
+ }
+ 
+ static void dualshock4_state_worker(struct work_struct *work)
+ {
+ 	struct sony_sc *sc = container_of(work, struct sony_sc, state_worker);
+ 	struct hid_device *hdev = sc->hdev;
+ 	int offset;
+ 
+ 	__u8 buf[78] = { 0 };
+ 
+ 	if (sc->quirks & DUALSHOCK4_CONTROLLER_USB) {
+ 		buf[0] = 0x05;
+ 		buf[1] = 0x03;
+ 		offset = 4;
+ 	} else {
+ 		buf[0] = 0x11;
+ 		buf[1] = 0xB0;
+ 		buf[3] = 0x0F;
+ 		offset = 6;
+ 	}
+ 
+ #ifdef CONFIG_SONY_FF
+ 	buf[offset++] = sc->right;
+ 	buf[offset++] = sc->left;
+ #else
+ 	offset += 2;
+ #endif
+ 
+ 	buf[offset++] = sc->led_state[0];
+ 	buf[offset++] = sc->led_state[1];
+ 	buf[offset++] = sc->led_state[2];
+ 
+ 	if (sc->quirks & DUALSHOCK4_CONTROLLER_USB)
+ 		hid_hw_output_report(hdev, buf, 32);
+ 	else
+ 		hid_hw_raw_request(hdev, 0x11, buf, 78,
+ 				HID_OUTPUT_REPORT, HID_REQ_SET_REPORT);
+ }
+ 
+ #ifdef CONFIG_SONY_FF
+ static int sony_play_effect(struct input_dev *dev, void *data,
+ 			    struct ff_effect *effect)
+ {
+ 	struct hid_device *hid = input_get_drvdata(dev);
+ 	struct sony_sc *sc = hid_get_drvdata(hid);
+ 
+ 	if (effect->type != FF_RUMBLE)
+ 		return 0;
+ 
+ 	sc->left = effect->u.rumble.strong_magnitude / 256;
+ 	sc->right = effect->u.rumble.weak_magnitude / 256;
+ 
+ 	schedule_work(&sc->state_worker);
+ 	return 0;
+ }
+ 
+ static int sony_init_ff(struct hid_device *hdev)
+ {
+ 	struct hid_input *hidinput = list_entry(hdev->inputs.next,
+ 						struct hid_input, list);
+ 	struct input_dev *input_dev = hidinput->input;
+ 
+ 	input_set_capability(input_dev, EV_FF, FF_RUMBLE);
+ 	return input_ff_create_memless(input_dev, NULL, sony_play_effect);
+ }
+ 
+ #else
+ static int sony_init_ff(struct hid_device *hdev)
+ {
+ 	return 0;
+ }
+ 
+ #endif
+ 
+ static int sony_battery_get_property(struct power_supply *psy,
+ 				     enum power_supply_property psp,
+ 				     union power_supply_propval *val)
+ {
+ 	struct sony_sc *sc = container_of(psy, struct sony_sc, battery);
+ 	unsigned long flags;
+ 	int ret = 0;
+ 	u8 battery_charging, battery_capacity, cable_state;
+ 
+ 	spin_lock_irqsave(&sc->lock, flags);
+ 	battery_charging = sc->battery_charging;
+ 	battery_capacity = sc->battery_capacity;
+ 	cable_state = sc->cable_state;
+ 	spin_unlock_irqrestore(&sc->lock, flags);
+ 
+ 	switch (psp) {
+ 	case POWER_SUPPLY_PROP_PRESENT:
+ 		val->intval = 1;
+ 		break;
+ 	case POWER_SUPPLY_PROP_SCOPE:
+ 		val->intval = POWER_SUPPLY_SCOPE_DEVICE;
+ 		break;
+ 	case POWER_SUPPLY_PROP_CAPACITY:
+ 		val->intval = battery_capacity;
+ 		break;
+ 	case POWER_SUPPLY_PROP_STATUS:
+ 		if (battery_charging)
+ 			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+ 		else
+ 			if (battery_capacity == 100 && cable_state)
+ 				val->intval = POWER_SUPPLY_STATUS_FULL;
+ 			else
+ 				val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 	return ret;
+ }
+ 
+ static int sony_battery_probe(struct sony_sc *sc)
+ {
+ 	static atomic_t power_id_seq = ATOMIC_INIT(0);
+ 	unsigned long power_id;
+ 	struct hid_device *hdev = sc->hdev;
+ 	int ret;
+ 
+ 	/*
+ 	 * Set the default battery level to 100% to avoid low battery warnings
+ 	 * if the battery is polled before the first device report is received.
+ 	 */
+ 	sc->battery_capacity = 100;
+ 
+ 	power_id = (unsigned long)atomic_inc_return(&power_id_seq);
+ 
+ 	sc->battery.properties = sony_battery_props;
+ 	sc->battery.num_properties = ARRAY_SIZE(sony_battery_props);
+ 	sc->battery.get_property = sony_battery_get_property;
+ 	sc->battery.type = POWER_SUPPLY_TYPE_BATTERY;
+ 	sc->battery.use_for_apm = 0;
+ 	sc->battery.name = kasprintf(GFP_KERNEL, "sony_controller_battery_%lu",
+ 				     power_id);
+ 	if (!sc->battery.name)
+ 		return -ENOMEM;
+ 
+ 	ret = power_supply_register(&hdev->dev, &sc->battery);
+ 	if (ret) {
+ 		hid_err(hdev, "Unable to register battery device\n");
+ 		goto err_free;
+ 	}
+ 
+ 	power_supply_powers(&sc->battery, &hdev->dev);
+ 	return 0;
+ 
+ err_free:
+ 	kfree(sc->battery.name);
+ 	sc->battery.name = NULL;
+ 	return ret;
+ }
+ 
+ static void sony_battery_remove(struct sony_sc *sc)
+ {
+ 	if (!sc->battery.name)
+ 		return;
+ 
+ 	power_supply_unregister(&sc->battery);
+ 	kfree(sc->battery.name);
+ 	sc->battery.name = NULL;
+ }
+ 
+ static int sony_register_touchpad(struct sony_sc *sc, int touch_count,
+ 					int w, int h)
+ {
+ 	struct hid_input *hidinput = list_entry(sc->hdev->inputs.next,
+ 						struct hid_input, list);
+ 	struct input_dev *input_dev = hidinput->input;
+ 	int ret;
+ 
+ 	ret = input_mt_init_slots(input_dev, touch_count, 0);
+ 	if (ret < 0) {
+ 		hid_err(sc->hdev, "Unable to initialize multi-touch slots\n");
+ 		return ret;
+ 	}
+ 
+ 	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, w, 0, 0);
+ 	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, h, 0, 0);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * If a controller is plugged in via USB while already connected via Bluetooth
+  * it will show up as two devices. A global list of connected controllers and
+  * their MAC addresses is maintained to ensure that a device is only connected
+  * once.
+  */
+ static int sony_check_add_dev_list(struct sony_sc *sc)
+ {
+ 	struct sony_sc *entry;
+ 	unsigned long flags;
+ 	int ret;
+ 
+ 	spin_lock_irqsave(&sony_dev_list_lock, flags);
+ 
+ 	list_for_each_entry(entry, &sony_device_list, list_node) {
+ 		ret = memcmp(sc->mac_address, entry->mac_address,
+ 				sizeof(sc->mac_address));
+ 		if (!ret) {
+ 			ret = -EEXIST;
+ 			hid_info(sc->hdev, "controller with MAC address %pMR already connected\n",
+ 				sc->mac_address);
+ 			goto unlock;
+ 		}
+ 	}
+ 
+ 	ret = 0;
+ 	list_add(&(sc->list_node), &sony_device_list);
+ 
+ unlock:
+ 	spin_unlock_irqrestore(&sony_dev_list_lock, flags);
+ 	return ret;
+ }
+ 
+ static void sony_remove_dev_list(struct sony_sc *sc)
+ {
+ 	unsigned long flags;
+ 
+ 	if (sc->list_node.next) {
+ 		spin_lock_irqsave(&sony_dev_list_lock, flags);
+ 		list_del(&(sc->list_node));
+ 		spin_unlock_irqrestore(&sony_dev_list_lock, flags);
+ 	}
+ }
+ 
+ static int sony_get_bt_devaddr(struct sony_sc *sc)
+ {
+ 	int ret;
+ 
+ 	/* HIDP stores the device MAC address as a string in the uniq field. */
+ 	ret = strlen(sc->hdev->uniq);
+ 	if (ret != 17)
+ 		return -EINVAL;
+ 
+ 	ret = sscanf(sc->hdev->uniq,
+ 		"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+ 		&sc->mac_address[5], &sc->mac_address[4], &sc->mac_address[3],
+ 		&sc->mac_address[2], &sc->mac_address[1], &sc->mac_address[0]);
+ 
+ 	if (ret != 6)
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ static int sony_check_add(struct sony_sc *sc)
+ {
+ 	int n, ret;
+ 
+ 	if ((sc->quirks & DUALSHOCK4_CONTROLLER_BT) ||
+ 	    (sc->quirks & SIXAXIS_CONTROLLER_BT)) {
+ 		/*
+ 		 * sony_get_bt_devaddr() attempts to parse the Bluetooth MAC
+ 		 * address from the uniq string where HIDP stores it.
+ 		 * As uniq cannot be guaranteed to be a MAC address in all cases
+ 		 * a failure of this function should not prevent the connection.
+ 		 */
+ 		if (sony_get_bt_devaddr(sc) < 0) {
+ 			hid_warn(sc->hdev, "UNIQ does not contain a MAC address; duplicate check skipped\n");
+ 			return 0;
+ 		}
+ 	} else if (sc->quirks & DUALSHOCK4_CONTROLLER_USB) {
+ 		__u8 buf[7];
+ 
+ 		/*
+ 		 * The MAC address of a DS4 controller connected via USB can be
+ 		 * retrieved with feature report 0x81. The address begins at
+ 		 * offset 1.
+ 		 */
+ 		ret = hid_hw_raw_request(sc->hdev, 0x81, buf, sizeof(buf),
+ 				HID_FEATURE_REPORT, HID_REQ_GET_REPORT);
+ 
+ 		if (ret != 7) {
+ 			hid_err(sc->hdev, "failed to retrieve feature report 0x81 with the DualShock 4 MAC address\n");
+ 			return ret < 0 ? ret : -EINVAL;
+ 		}
+ 
+ 		memcpy(sc->mac_address, &buf[1], sizeof(sc->mac_address));
+ 	} else if (sc->quirks & SIXAXIS_CONTROLLER_USB) {
+ 		__u8 buf[18];
+ 
+ 		/*
+ 		 * The MAC address of a Sixaxis controller connected via USB can
+ 		 * be retrieved with feature report 0xf2. The address begins at
+ 		 * offset 4.
+ 		 */
+ 		ret = hid_hw_raw_request(sc->hdev, 0xf2, buf, sizeof(buf),
+ 				HID_FEATURE_REPORT, HID_REQ_GET_REPORT);
+ 
+ 		if (ret != 18) {
+ 			hid_err(sc->hdev, "failed to retrieve feature report 0xf2 with the Sixaxis MAC address\n");
+ 			return ret < 0 ? ret : -EINVAL;
+ 		}
+ 
+ 		/*
+ 		 * The Sixaxis device MAC in the report is big-endian and must
+ 		 * be byte-swapped.
+ 		 */
+ 		for (n = 0; n < 6; n++)
+ 			sc->mac_address[5-n] = buf[4+n];
+ 	} else {
+ 		return 0;
+ 	}
+ 
+ 	return sony_check_add_dev_list(sc);
+ }
+ 
+ 
++>>>>>>> e534a9352237 (HID: sony: do not rely on hid_output_raw_report)
  static int sony_probe(struct hid_device *hdev, const struct hid_device_id *id)
  {
  	int ret;
@@@ -221,14 -1616,51 +736,25 @@@
  	}
  
  	if (sc->quirks & SIXAXIS_CONTROLLER_USB) {
- 		hdev->hid_output_raw_report = sixaxis_usb_output_raw_report;
+ 		/*
+ 		 * The Sony Sixaxis does not handle HID Output Reports on the
+ 		 * Interrupt EP like it could, so we need to force HID Output
+ 		 * Reports to use HID_REQ_SET_REPORT on the Control EP.
+ 		 *
+ 		 * There is also another issue about HID Output Reports via USB,
+ 		 * the Sixaxis does not want the report_id as part of the data
+ 		 * packet, so we have to discard buf[0] when sending the actual
+ 		 * control message, even for numbered reports, humpf!
+ 		 */
+ 		hdev->quirks |= HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP;
+ 		hdev->quirks |= HID_QUIRK_SKIP_OUTPUT_REPORT_ID;
  		ret = sixaxis_set_operational_usb(hdev);
 -		sc->worker_initialized = 1;
 -		INIT_WORK(&sc->state_worker, sixaxis_state_worker);
 -	} else if (sc->quirks & SIXAXIS_CONTROLLER_BT) {
 +	}
 +	else if (sc->quirks & SIXAXIS_CONTROLLER_BT)
  		ret = sixaxis_set_operational_bt(hdev);
 -		sc->worker_initialized = 1;
 -		INIT_WORK(&sc->state_worker, sixaxis_state_worker);
 -	} else if (sc->quirks & DUALSHOCK4_CONTROLLER) {
 -		if (sc->quirks & DUALSHOCK4_CONTROLLER_BT) {
 -			ret = dualshock4_set_operational_bt(hdev);
 -			if (ret < 0) {
 -				hid_err(hdev, "failed to set the Dualshock 4 operational mode\n");
 -				goto err_stop;
 -			}
 -		}
 -		/*
 -		 * The Dualshock 4 touchpad supports 2 touches and has a
 -		 * resolution of 1920x940.
 -		 */
 -		ret = sony_register_touchpad(sc, 2, 1920, 940);
 -		if (ret < 0)
 -			goto err_stop;
 -
 -		sc->worker_initialized = 1;
 -		INIT_WORK(&sc->state_worker, dualshock4_state_worker);
 -	} else {
 +	else
  		ret = 0;
 -	}
 -
 -	if (ret < 0)
 -		goto err_stop;
  
 -	ret = sony_check_add(sc);
  	if (ret < 0)
  		goto err_stop;
  
diff --cc drivers/hid/hidraw.c
index 9cc86097e507,ffa648ce002e..000000000000
--- a/drivers/hid/hidraw.c
+++ b/drivers/hid/hidraw.c
@@@ -153,7 -149,21 +153,25 @@@ static ssize_t hidraw_send_report(struc
  		goto out_free;
  	}
  
++<<<<<<< HEAD
 +	ret = dev->hid_output_raw_report(dev, buf, count, report_type);
++=======
+ 	if ((report_type == HID_OUTPUT_REPORT) &&
+ 	    !(dev->quirks & HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP)) {
+ 		ret = hid_hw_output_report(dev, buf, count);
+ 		/*
+ 		 * compatibility with old implementation of USB-HID and I2C-HID:
+ 		 * if the device does not support receiving output reports,
+ 		 * on an interrupt endpoint, fallback to SET_REPORT HID command.
+ 		 */
+ 		if (ret != -ENOSYS)
+ 			goto out_free;
+ 	}
+ 
+ 	ret = hid_hw_raw_request(dev, buf[0], buf, count, report_type,
+ 				HID_REQ_SET_REPORT);
+ 
++>>>>>>> e534a9352237 (HID: sony: do not rely on hid_output_raw_report)
  out_free:
  	kfree(buf);
  out:
* Unmerged path drivers/hid/hid-sony.c
* Unmerged path drivers/hid/hidraw.c
diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 5c89ddffc29c..d0fda3f855d3 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -889,7 +889,12 @@ static int usbhid_set_raw_report(struct hid_device *hid, unsigned int reportnum,
 	int ret, skipped_report_id = 0;
 
 	/* Byte 0 is the report number. Report data starts at byte 1.*/
-	buf[0] = reportnum;
+	if ((rtype == HID_OUTPUT_REPORT) &&
+	    (hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORT_ID))
+		buf[0] = 0;
+	else
+		buf[0] = reportnum;
+
 	if (buf[0] == 0x0) {
 		/* Don't send the Report ID */
 		buf++;
diff --git a/include/linux/hid.h b/include/linux/hid.h
index 537af3092265..c0c0715c38d8 100644
--- a/include/linux/hid.h
+++ b/include/linux/hid.h
@@ -282,6 +282,8 @@ struct hid_item {
 #define HID_QUIRK_NO_EMPTY_INPUT		0x00000100
 #define HID_QUIRK_ALWAYS_POLL			0x00000400
 #define HID_QUIRK_SKIP_OUTPUT_REPORTS		0x00010000
+#define HID_QUIRK_SKIP_OUTPUT_REPORT_ID		0x00020000
+#define HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP	0x00040000
 #define HID_QUIRK_FULLSPEED_INTERVAL		0x10000000
 #define HID_QUIRK_NO_INIT_REPORTS		0x20000000
 #define HID_QUIRK_NO_IGNORE			0x40000000
