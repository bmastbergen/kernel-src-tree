NVMe: Fix obtaining command result

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Keith Busch <keith.busch@intel.com>
commit a0a931d6a2c1fbc5d5966ebf0e7a043748692c22
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/a0a931d6.failed

Replaces req->sense_len usage, which is not owned by the LLD, to
req->special to contain the command result for driver created commands,
and sets the result unconditionally on completion.

	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Jens Axboe <axboe@fb.com>
Fixes: d29ec8241c10 ("nvme: submit internal commands through the block layer")
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit a0a931d6a2c1fbc5d5966ebf0e7a043748692c22)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index a8d9055d2103,c42bc53f3765..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -524,12 -605,20 +524,24 @@@ static void req_completion(struct nvme_
  			spin_unlock_irqrestore(req->q->queue_lock, flags);
  			return;
  		}
++<<<<<<< HEAD
 +		req->errors = nvme_error_status(status);
++=======
+ 		if (req->cmd_type == REQ_TYPE_DRV_PRIV) {
+ 			req->errors = status;
+ 		} else {
+ 			req->errors = nvme_error_status(status);
+ 		}
++>>>>>>> a0a931d6a2c1 (NVMe: Fix obtaining command result)
  	} else
  		req->errors = 0;
+ 	if (req->cmd_type == REQ_TYPE_DRV_PRIV) {
+ 		u32 result = le32_to_cpup(&cqe->result);
+ 		req->special = (void *)(uintptr_t)result;
+ 	}
  
  	if (cmd_rq->aborted)
 -		dev_warn(nvmeq->dev->dev,
 +		dev_warn(&nvmeq->dev->pci_dev->dev,
  			"completing aborted command with status:%04x\n",
  			status);
  
@@@ -905,28 -1009,43 +917,40 @@@ static int __nvme_submit_sync_cmd(struc
  	if (IS_ERR(req))
  		return PTR_ERR(req);
  
 -	req->cmd_type = REQ_TYPE_DRV_PRIV;
 -	req->__data_len = 0;
 -	req->__sector = (sector_t) -1;
 -	req->bio = req->biotail = NULL;
 +	cmdinfo.task = current;
 +	cmdinfo.status = -EINTR;
  
 -	req->timeout = ADMIN_TIMEOUT;
 +	cmd->common.command_id = req->tag;
  
++<<<<<<< HEAD
 +	cmd_rq = blk_mq_rq_to_pdu(req);
 +	nvme_set_info(cmd_rq, &cmdinfo, sync_completion);
++=======
+ 	req->cmd = (unsigned char *)cmd;
+ 	req->cmd_len = sizeof(struct nvme_command);
+ 	req->special = (void *)0;
++>>>>>>> a0a931d6a2c1 (NVMe: Fix obtaining command result)
  
 -	if (buffer && bufflen) {
 -		ret = blk_rq_map_kern(q, req, buffer, bufflen, __GFP_WAIT);
 -		if (ret)
 -			goto out;
 -	} else if (ubuffer && bufflen) {
 -		ret = blk_rq_map_user(q, req, NULL, ubuffer, bufflen, __GFP_WAIT);
 -		if (ret)
 -			goto out;
 -		bio = req->bio;
 -	}
 +	set_current_state(TASK_UNINTERRUPTIBLE);
 +	nvme_submit_cmd(cmd_rq->nvmeq, cmd);
 +	schedule();
  
 -	blk_execute_rq(req->q, NULL, req, 0);
 -	if (bio)
 -		blk_rq_unmap_user(bio);
  	if (result)
++<<<<<<< HEAD
 +		*result = cmdinfo.result;
 +	res = cmdinfo.status;
++=======
+ 		*result = (u32)(uintptr_t)req->special;
+ 	ret = req->errors;
+  out:
++>>>>>>> a0a931d6a2c1 (NVMe: Fix obtaining command result)
  	blk_mq_free_request(req);
 -	return ret;
 +	return res;
  }
  
 -int nvme_submit_sync_cmd(struct request_queue *q, struct nvme_command *cmd,
 -		void *buffer, unsigned bufflen)
 +int nvme_submit_sync_cmd(struct request_queue *q, struct nvme_command *cmd)
  {
 -	return __nvme_submit_sync_cmd(q, cmd, buffer, NULL, bufflen, NULL, 0);
 +	return __nvme_submit_sync_cmd(q, cmd, NULL, 0);
  }
  
  static int nvme_submit_async_admin_req(struct nvme_dev *dev)
* Unmerged path drivers/block/nvme-core.c
