xprtrdma: Handle incoming backward direction RPC calls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 63cae47005af51c937f4cdcc4835f29075add2ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/63cae470.failed

Introduce a code path in the rpcrdma_reply_handler() to catch
incoming backward direction RPC calls and route them to the ULP's
backchannel server.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
Tested-By: Devesh Sharma <devesh.sharma@avagotech.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 63cae47005af51c937f4cdcc4835f29075add2ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/backchannel.c
#	net/sunrpc/xprtrdma/rpc_rdma.c
#	net/sunrpc/xprtrdma/xprt_rdma.h
diff --cc net/sunrpc/xprtrdma/rpc_rdma.c
index cbbf36c8c6ad,c10d9699441c..000000000000
--- a/net/sunrpc/xprtrdma/rpc_rdma.c
+++ b/net/sunrpc/xprtrdma/rpc_rdma.c
@@@ -759,52 -777,32 +790,61 @@@ rpcrdma_reply_handler(struct rpcrdma_re
  	unsigned long cwnd;
  	u32 credits;
  
 -	dprintk("RPC:       %s: incoming rep %p\n", __func__, rep);
 -
 -	if (rep->rr_len == RPCRDMA_BAD_LEN)
 -		goto out_badstatus;
 -	if (rep->rr_len < RPCRDMA_HDRLEN_MIN)
 -		goto out_shortreply;
 -
 +	/* Check status. If bad, signal disconnect and return rep to pool */
 +	if (rep->rr_len == ~0U) {
 +		rpcrdma_recv_buffer_put(rep);
 +		if (r_xprt->rx_ep.rep_connected == 1) {
 +			r_xprt->rx_ep.rep_connected = -EIO;
 +			rpcrdma_conn_func(&r_xprt->rx_ep);
 +		}
 +		return;
 +	}
 +	if (rep->rr_len < RPCRDMA_HDRLEN_MIN) {
 +		dprintk("RPC:       %s: short/invalid reply\n", __func__);
 +		goto repost;
 +	}
  	headerp = rdmab_to_msg(rep->rr_rdmabuf);
++<<<<<<< HEAD
 +	if (headerp->rm_vers != rpcrdma_version) {
 +		dprintk("RPC:       %s: invalid version %d\n",
 +			__func__, be32_to_cpu(headerp->rm_vers));
 +		goto repost;
 +	}
++=======
+ 	if (headerp->rm_vers != rpcrdma_version)
+ 		goto out_badversion;
+ #if defined(CONFIG_SUNRPC_BACKCHANNEL)
+ 	if (rpcrdma_is_bcall(headerp))
+ 		goto out_bcall;
+ #endif
++>>>>>>> 63cae47005af (xprtrdma: Handle incoming backward direction RPC calls)
  
 -	/* Match incoming rpcrdma_rep to an rpcrdma_req to
 -	 * get context for handling any incoming chunks.
 -	 */
 -	spin_lock_bh(&xprt->transport_lock);
 +	/* Get XID and try for a match. */
 +	spin_lock(&xprt->transport_lock);
  	rqst = xprt_lookup_rqst(xprt, headerp->rm_xid);
 -	if (!rqst)
 -		goto out_nomatch;
 +	if (rqst == NULL) {
 +		spin_unlock(&xprt->transport_lock);
 +		dprintk("RPC:       %s: reply 0x%p failed "
 +			"to match any request xid 0x%08x len %d\n",
 +			__func__, rep, be32_to_cpu(headerp->rm_xid),
 +			rep->rr_len);
 +repost:
 +		r_xprt->rx_stats.bad_reply_count++;
 +		if (rpcrdma_ep_post_recv(&r_xprt->rx_ia, &r_xprt->rx_ep, rep))
 +			rpcrdma_recv_buffer_put(rep);
  
 +		return;
 +	}
 +
 +	/* get request object */
  	req = rpcr_to_rdmar(rqst);
 -	if (req->rl_reply)
 -		goto out_duplicate;
 +	if (req->rl_reply) {
 +		spin_unlock(&xprt->transport_lock);
 +		dprintk("RPC:       %s: duplicate reply 0x%p to RPC "
 +			"request 0x%p: xid 0x%08x\n", __func__, rep, req,
 +			be32_to_cpu(headerp->rm_xid));
 +		goto repost;
 +	}
  
  	dprintk("RPC:       %s: reply 0x%p completes request 0x%p\n"
  		"                   RPC request 0x%p xid 0x%08x\n",
@@@ -901,8 -899,50 +941,53 @@@ badheader
  	if (xprt->cwnd > cwnd)
  		xprt_release_rqst_cong(rqst->rq_task);
  
 -	xprt_complete_rqst(rqst->rq_task, status);
 -	spin_unlock_bh(&xprt->transport_lock);
  	dprintk("RPC:       %s: xprt_complete_rqst(0x%p, 0x%p, %d)\n",
  			__func__, xprt, rqst, status);
++<<<<<<< HEAD
 +	xprt_complete_rqst(rqst->rq_task, status);
 +	spin_unlock(&xprt->transport_lock);
++=======
+ 	return;
+ 
+ out_badstatus:
+ 	rpcrdma_recv_buffer_put(rep);
+ 	if (r_xprt->rx_ep.rep_connected == 1) {
+ 		r_xprt->rx_ep.rep_connected = -EIO;
+ 		rpcrdma_conn_func(&r_xprt->rx_ep);
+ 	}
+ 	return;
+ 
+ #if defined(CONFIG_SUNRPC_BACKCHANNEL)
+ out_bcall:
+ 	rpcrdma_bc_receive_call(r_xprt, rep);
+ 	return;
+ #endif
+ 
+ out_shortreply:
+ 	dprintk("RPC:       %s: short/invalid reply\n", __func__);
+ 	goto repost;
+ 
+ out_badversion:
+ 	dprintk("RPC:       %s: invalid version %d\n",
+ 		__func__, be32_to_cpu(headerp->rm_vers));
+ 	goto repost;
+ 
+ out_nomatch:
+ 	spin_unlock_bh(&xprt->transport_lock);
+ 	dprintk("RPC:       %s: no match for incoming xid 0x%08x len %d\n",
+ 		__func__, be32_to_cpu(headerp->rm_xid),
+ 		rep->rr_len);
+ 	goto repost;
+ 
+ out_duplicate:
+ 	spin_unlock_bh(&xprt->transport_lock);
+ 	dprintk("RPC:       %s: "
+ 		"duplicate reply %p to RPC request %p: xid 0x%08x\n",
+ 		__func__, rep, req, be32_to_cpu(headerp->rm_xid));
+ 
+ repost:
+ 	r_xprt->rx_stats.bad_reply_count++;
+ 	if (rpcrdma_ep_post_recv(&r_xprt->rx_ia, &r_xprt->rx_ep, rep))
+ 		rpcrdma_recv_buffer_put(rep);
++>>>>>>> 63cae47005af (xprtrdma: Handle incoming backward direction RPC calls)
  }
diff --cc net/sunrpc/xprtrdma/xprt_rdma.h
index b2d2c86a7023,eb87d96e80ca..000000000000
--- a/net/sunrpc/xprtrdma/xprt_rdma.h
+++ b/net/sunrpc/xprtrdma/xprt_rdma.h
@@@ -485,6 -511,22 +486,25 @@@ void rpcrdma_reply_handler(struct rpcrd
   */
  int rpcrdma_marshal_req(struct rpc_rqst *);
  
++<<<<<<< HEAD
++=======
+ /* RPC/RDMA module init - xprtrdma/transport.c
+  */
+ int xprt_rdma_init(void);
+ void xprt_rdma_cleanup(void);
+ 
+ /* Backchannel calls - xprtrdma/backchannel.c
+  */
+ #if defined(CONFIG_SUNRPC_BACKCHANNEL)
+ int xprt_rdma_bc_setup(struct rpc_xprt *, unsigned int);
+ int rpcrdma_bc_post_recv(struct rpcrdma_xprt *, unsigned int);
+ void rpcrdma_bc_receive_call(struct rpcrdma_xprt *, struct rpcrdma_rep *);
+ int rpcrdma_bc_marshal_reply(struct rpc_rqst *);
+ void xprt_rdma_bc_free_rqst(struct rpc_rqst *);
+ void xprt_rdma_bc_destroy(struct rpc_xprt *, unsigned int);
+ #endif	/* CONFIG_SUNRPC_BACKCHANNEL */
+ 
++>>>>>>> 63cae47005af (xprtrdma: Handle incoming backward direction RPC calls)
  /* Temporary NFS request map cache. Created in svc_rdma.c  */
  extern struct kmem_cache *svc_rdma_map_cachep;
  /* WR context cache. Created in svc_rdma.c  */
* Unmerged path net/sunrpc/xprtrdma/backchannel.c
* Unmerged path net/sunrpc/xprtrdma/backchannel.c
* Unmerged path net/sunrpc/xprtrdma/rpc_rdma.c
* Unmerged path net/sunrpc/xprtrdma/xprt_rdma.h
