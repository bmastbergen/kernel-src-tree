perf tools: Fix segfault on dynamic entries

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-514.el7
commit-author Namhyung Kim <namhyung@kernel.org>
commit 665aa75700edda07bd7f05acab86cef1a1a1ea66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-514.el7/665aa757.failed

A dynamic entry is created for each tracepoint event.  When it sets up
the sort key, it checks with existing keys using ->equal() callback.
But it missed to set the ->equal for dynamic entries.  The following
segfault was due to the missing ->equal() callback.

  (gdb) bt
  #0  0x0000000000140003 in ?? ()
  #1  0x0000000000537769 in fmt_equal (b=0x2106980, a=0x21067a0) at ui/hist.c:548
  #2  perf_hpp__setup_output_field (list=0x8c6d80 <perf_hpp_list>) at ui/hist.c:560
  #3  0x00000000004e927e in setup_sorting (evlist=<optimized out>) at util/sort.c:2642
  #4  0x000000000043cf50 in cmd_report (argc=<optimized out>, argv=<optimized out>, prefix=<optimized out>)
      at builtin-report.c:932
  #5  0x00000000004865a1 in run_builtin (p=p@entry=0x8bbce0 <commands+192>, argc=argc@entry=7,
      argv=argv@entry=0x7ffd24d56ce0) at perf.c:390
  #6  0x000000000042dc1f in handle_internal_command (argv=0x7ffd24d56ce0, argc=7) at perf.c:451
  #7  run_argv (argv=0x7ffd24d56a70, argcp=0x7ffd24d56a7c) at perf.c:495
  #8  main (argc=7, argv=0x7ffd24d56ce0) at perf.c:620

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/1456064558-13086-2-git-send-email-namhyung@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 665aa75700edda07bd7f05acab86cef1a1a1ea66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/sort.c
diff --cc tools/perf/util/sort.c
index fd679d5f90f2,7daea71691df..000000000000
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@@ -1724,6 -1830,33 +1724,36 @@@ static int64_t __sort__hde_cmp(struct p
  	return memcmp(a->raw_data + offset, b->raw_data + offset, size);
  }
  
++<<<<<<< HEAD
++=======
+ bool perf_hpp__is_dynamic_entry(struct perf_hpp_fmt *fmt)
+ {
+ 	return fmt->cmp == __sort__hde_cmp;
+ }
+ 
+ static bool __sort__hde_equal(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b)
+ {
+ 	struct hpp_dynamic_entry *hde_a;
+ 	struct hpp_dynamic_entry *hde_b;
+ 
+ 	if (!perf_hpp__is_dynamic_entry(a) || !perf_hpp__is_dynamic_entry(b))
+ 		return false;
+ 
+ 	hde_a = container_of(a, struct hpp_dynamic_entry, hpp);
+ 	hde_b = container_of(b, struct hpp_dynamic_entry, hpp);
+ 
+ 	return hde_a->field == hde_b->field;
+ }
+ 
+ static void hde_free(struct perf_hpp_fmt *fmt)
+ {
+ 	struct hpp_dynamic_entry *hde;
+ 
+ 	hde = container_of(fmt, struct hpp_dynamic_entry, hpp);
+ 	free(hde);
+ }
+ 
++>>>>>>> 665aa75700ed (perf tools: Fix segfault on dynamic entries)
  static struct hpp_dynamic_entry *
  __alloc_dynamic_entry(struct perf_evsel *evsel, struct format_field *field)
  {
@@@ -1748,6 -1881,8 +1778,11 @@@
  	hde->hpp.cmp = __sort__hde_cmp;
  	hde->hpp.collapse = __sort__hde_cmp;
  	hde->hpp.sort = __sort__hde_cmp;
++<<<<<<< HEAD
++=======
+ 	hde->hpp.equal = __sort__hde_equal;
+ 	hde->hpp.free = hde_free;
++>>>>>>> 665aa75700ed (perf tools: Fix segfault on dynamic entries)
  
  	INIT_LIST_HEAD(&hde->hpp.list);
  	INIT_LIST_HEAD(&hde->hpp.sort_list);
* Unmerged path tools/perf/util/sort.c
